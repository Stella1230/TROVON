static void rtw_2g_channels_init(struct ieee80211_channel *channels)\r\n{\r\nmemcpy((void*)channels, (void*)rtw_2ghz_channels,\r\nsizeof(struct ieee80211_channel)*RTW_2G_CHANNELS_NUM\r\n);\r\n}\r\nstatic void rtw_2g_rates_init(struct ieee80211_rate *rates)\r\n{\r\nmemcpy(rates, rtw_g_rates,\r\nsizeof(struct ieee80211_rate)*RTW_G_RATES_NUM\r\n);\r\n}\r\nstatic struct ieee80211_supported_band *rtw_spt_band_alloc(\r\nenum nl80211_band band\r\n)\r\n{\r\nstruct ieee80211_supported_band *spt_band = NULL;\r\nint n_channels, n_bitrates;\r\nif (band == NL80211_BAND_2GHZ)\r\n{\r\nn_channels = RTW_2G_CHANNELS_NUM;\r\nn_bitrates = RTW_G_RATES_NUM;\r\n}\r\nelse\r\n{\r\ngoto exit;\r\n}\r\nspt_band = (struct ieee80211_supported_band *)rtw_zmalloc(\r\nsizeof(struct ieee80211_supported_band)\r\n+ sizeof(struct ieee80211_channel)*n_channels\r\n+ sizeof(struct ieee80211_rate)*n_bitrates\r\n);\r\nif (!spt_band)\r\ngoto exit;\r\nspt_band->channels = (struct ieee80211_channel*)(((u8 *)spt_band)+sizeof(struct ieee80211_supported_band));\r\nspt_band->bitrates = (struct ieee80211_rate*)(((u8 *)spt_band->channels)+sizeof(struct ieee80211_channel)*n_channels);\r\nspt_band->band = band;\r\nspt_band->n_channels = n_channels;\r\nspt_band->n_bitrates = n_bitrates;\r\nif (band == NL80211_BAND_2GHZ)\r\n{\r\nrtw_2g_channels_init(spt_band->channels);\r\nrtw_2g_rates_init(spt_band->bitrates);\r\n}\r\nexit:\r\nreturn spt_band;\r\n}\r\nstatic void rtw_spt_band_free(struct ieee80211_supported_band *spt_band)\r\n{\r\nu32 size = 0;\r\nif (!spt_band)\r\nreturn;\r\nif (spt_band->band == NL80211_BAND_2GHZ)\r\n{\r\nsize = sizeof(struct ieee80211_supported_band)\r\n+ sizeof(struct ieee80211_channel)*RTW_2G_CHANNELS_NUM\r\n+ sizeof(struct ieee80211_rate)*RTW_G_RATES_NUM;\r\n}\r\nkfree((u8 *)spt_band);\r\n}\r\nstatic int rtw_ieee80211_channel_to_frequency(int chan, int band)\r\n{\r\nif (band == NL80211_BAND_2GHZ) {\r\nif (chan == 14)\r\nreturn 2484;\r\nelse if (chan < 14)\r\nreturn 2407 + chan * 5;\r\n}\r\nreturn 0;\r\n}\r\nstatic u64 rtw_get_systime_us(void)\r\n{\r\nstruct timespec ts;\r\nget_monotonic_boottime(&ts);\r\nreturn ((u64)ts.tv_sec*1000000) + ts.tv_nsec / 1000;\r\n}\r\nstruct cfg80211_bss *rtw_cfg80211_inform_bss(struct adapter *padapter, struct wlan_network *pnetwork)\r\n{\r\nstruct ieee80211_channel *notify_channel;\r\nstruct cfg80211_bss *bss = NULL;\r\nu16 channel;\r\nu32 freq;\r\nu64 notify_timestamp;\r\nu16 notify_capability;\r\nu16 notify_interval;\r\nu8 *notify_ie;\r\nsize_t notify_ielen;\r\ns32 notify_signal;\r\nu8 *buf = NULL, *pbuf;\r\nsize_t len, bssinf_len = 0;\r\nstruct ieee80211_hdr *pwlanhdr;\r\n__le16 *fctrl;\r\nu8 bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nstruct wireless_dev *wdev = padapter->rtw_wdev;\r\nstruct wiphy *wiphy = wdev->wiphy;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nbssinf_len = pnetwork->network.IELength+sizeof (struct ieee80211_hdr_3addr);\r\nif (bssinf_len > MAX_BSSINFO_LEN) {\r\nDBG_871X("%s IE Length too long > %d byte\n", __func__, MAX_BSSINFO_LEN);\r\ngoto exit;\r\n}\r\n{\r\nu16 wapi_len = 0;\r\nif (rtw_get_wapi_ie(pnetwork->network.IEs, pnetwork->network.IELength, NULL, &wapi_len)>0)\r\n{\r\nif (wapi_len > 0)\r\n{\r\nDBG_871X("%s, no support wapi!\n", __func__);\r\ngoto exit;\r\n}\r\n}\r\n}\r\nif (adapter_wdev_data(padapter)->scan_request != NULL)\r\n{\r\nu8 *psr = NULL, sr = 0;\r\nstruct ndis_802_11_ssid *pssid = &pnetwork->network.Ssid;\r\nstruct cfg80211_scan_request *request = adapter_wdev_data(padapter)->scan_request;\r\nstruct cfg80211_ssid *ssids = request->ssids;\r\nu32 wpsielen = 0;\r\nu8 *wpsie = NULL;\r\nwpsie = rtw_get_wps_ie(pnetwork->network.IEs+_FIXED_IE_LENGTH_, pnetwork->network.IELength-_FIXED_IE_LENGTH_, NULL, &wpsielen);\r\nif (wpsie && wpsielen>0)\r\npsr = rtw_get_wps_attr_content(wpsie, wpsielen, WPS_ATTR_SELECTED_REGISTRAR, (u8 *)(&sr), NULL);\r\nif (sr != 0)\r\n{\r\nif (request->n_ssids == 1 && request->n_channels == 1)\r\n{\r\nDBG_8192C("ssid =%s, len =%d\n", pssid->Ssid, pssid->SsidLength);\r\nif (ssids[0].ssid_len == 0) {\r\n}\r\nelse if (pssid->SsidLength == ssids[0].ssid_len &&\r\n!memcmp(pssid->Ssid, ssids[0].ssid, ssids[0].ssid_len))\r\n{\r\nDBG_871X("%s, got sr and ssid match!\n", __func__);\r\n}\r\nelse\r\n{\r\nif (psr != NULL)\r\n*psr = 0;\r\n}\r\n}\r\n}\r\n}\r\nchannel = pnetwork->network.Configuration.DSConfig;\r\nfreq = rtw_ieee80211_channel_to_frequency(channel, NL80211_BAND_2GHZ);\r\nnotify_channel = ieee80211_get_channel(wiphy, freq);\r\nnotify_timestamp = rtw_get_systime_us();\r\nnotify_interval = le16_to_cpu(*(__le16 *)rtw_get_beacon_interval_from_ie(pnetwork->network.IEs));\r\nnotify_capability = le16_to_cpu(*(__le16 *)rtw_get_capability_from_ie(pnetwork->network.IEs));\r\nnotify_ie = pnetwork->network.IEs+_FIXED_IE_LENGTH_;\r\nnotify_ielen = pnetwork->network.IELength-_FIXED_IE_LENGTH_;\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) == true &&\r\nis_same_network(&pmlmepriv->cur_network.network, &pnetwork->network, 0)) {\r\nnotify_signal = 100*translate_percentage_to_dbm(padapter->recvpriv.signal_strength);\r\n} else {\r\nnotify_signal = 100*translate_percentage_to_dbm(pnetwork->network.PhyInfo.SignalStrength);\r\n}\r\nbuf = kzalloc(MAX_BSSINFO_LEN, GFP_ATOMIC);\r\nif (!buf)\r\ngoto exit;\r\npbuf = buf;\r\npwlanhdr = (struct ieee80211_hdr *)pbuf;\r\nfctrl = &(pwlanhdr->frame_control);\r\n*(fctrl) = 0;\r\nSetSeqNum(pwlanhdr, 0);\r\nif (pnetwork->network.Reserved[0] == 1) {\r\nmemcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);\r\nSetFrameSubType(pbuf, WIFI_BEACON);\r\n} else {\r\nmemcpy(pwlanhdr->addr1, myid(&(padapter->eeprompriv)), ETH_ALEN);\r\nSetFrameSubType(pbuf, WIFI_PROBERSP);\r\n}\r\nmemcpy(pwlanhdr->addr2, pnetwork->network.MacAddress, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, pnetwork->network.MacAddress, ETH_ALEN);\r\npbuf += sizeof(struct ieee80211_hdr_3addr);\r\nlen = sizeof (struct ieee80211_hdr_3addr);\r\nmemcpy(pbuf, pnetwork->network.IEs, pnetwork->network.IELength);\r\nlen += pnetwork->network.IELength;\r\n*((__le64*)pbuf) = cpu_to_le64(notify_timestamp);\r\nbss = cfg80211_inform_bss_frame(wiphy, notify_channel, (struct ieee80211_mgmt *)buf,\r\nlen, notify_signal, GFP_ATOMIC);\r\nif (unlikely(!bss)) {\r\nDBG_8192C(FUNC_ADPT_FMT" bss NULL\n", FUNC_ADPT_ARG(padapter));\r\ngoto exit;\r\n}\r\ncfg80211_put_bss(wiphy, bss);\r\nkfree(buf);\r\nexit:\r\nreturn bss;\r\n}\r\nint rtw_cfg80211_check_bss(struct adapter *padapter)\r\n{\r\nstruct wlan_bssid_ex *pnetwork = &(padapter->mlmeextpriv.mlmext_info.network);\r\nstruct cfg80211_bss *bss = NULL;\r\nstruct ieee80211_channel *notify_channel = NULL;\r\nu32 freq;\r\nif (!(pnetwork) || !(padapter->rtw_wdev))\r\nreturn false;\r\nfreq = rtw_ieee80211_channel_to_frequency(pnetwork->Configuration.DSConfig, NL80211_BAND_2GHZ);\r\nnotify_channel = ieee80211_get_channel(padapter->rtw_wdev->wiphy, freq);\r\nbss = cfg80211_get_bss(padapter->rtw_wdev->wiphy, notify_channel,\r\npnetwork->MacAddress, pnetwork->Ssid.Ssid,\r\npnetwork->Ssid.SsidLength,\r\nWLAN_CAPABILITY_ESS, WLAN_CAPABILITY_ESS);\r\ncfg80211_put_bss(padapter->rtw_wdev->wiphy, bss);\r\nreturn (bss!= NULL);\r\n}\r\nvoid rtw_cfg80211_ibss_indicate_connect(struct adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct wlan_network *cur_network = &(pmlmepriv->cur_network);\r\nstruct wireless_dev *pwdev = padapter->rtw_wdev;\r\nstruct wiphy *wiphy = pwdev->wiphy;\r\nint freq = (int)cur_network->network.Configuration.DSConfig;\r\nstruct ieee80211_channel *chan;\r\nDBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));\r\nif (pwdev->iftype != NL80211_IFTYPE_ADHOC)\r\n{\r\nreturn;\r\n}\r\nif (!rtw_cfg80211_check_bss(padapter)) {\r\nstruct wlan_bssid_ex *pnetwork = &(padapter->mlmeextpriv.mlmext_info.network);\r\nstruct wlan_network *scanned = pmlmepriv->cur_network_scanned;\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) ==true)\r\n{\r\nmemcpy(&cur_network->network, pnetwork, sizeof(struct wlan_bssid_ex));\r\nif (!rtw_cfg80211_inform_bss(padapter, cur_network))\r\nDBG_871X(FUNC_ADPT_FMT" inform fail !!\n", FUNC_ADPT_ARG(padapter));\r\nelse\r\nDBG_871X(FUNC_ADPT_FMT" inform success !!\n", FUNC_ADPT_ARG(padapter));\r\n}\r\nelse\r\n{\r\nif (scanned == NULL) {\r\nrtw_warn_on(1);\r\nreturn;\r\n}\r\nif (!memcmp(&(scanned->network.Ssid), &(pnetwork->Ssid), sizeof(struct ndis_802_11_ssid))\r\n&& !memcmp(scanned->network.MacAddress, pnetwork->MacAddress, sizeof(NDIS_802_11_MAC_ADDRESS))\r\n) {\r\nif (!rtw_cfg80211_inform_bss(padapter, scanned)) {\r\nDBG_871X(FUNC_ADPT_FMT" inform fail !!\n", FUNC_ADPT_ARG(padapter));\r\n} else {\r\n}\r\n} else {\r\nDBG_871X("scanned & pnetwork compare fail\n");\r\nrtw_warn_on(1);\r\n}\r\n}\r\nif (!rtw_cfg80211_check_bss(padapter))\r\nDBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" BSS not found !!\n", FUNC_ADPT_ARG(padapter));\r\n}\r\nchan = ieee80211_get_channel(wiphy, freq);\r\ncfg80211_ibss_joined(padapter->pnetdev, cur_network->network.MacAddress, chan, GFP_ATOMIC);\r\n}\r\nvoid rtw_cfg80211_indicate_connect(struct adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct wlan_network *cur_network = &(pmlmepriv->cur_network);\r\nstruct wireless_dev *pwdev = padapter->rtw_wdev;\r\nDBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));\r\nif (pwdev->iftype != NL80211_IFTYPE_STATION\r\n&& pwdev->iftype != NL80211_IFTYPE_P2P_CLIENT\r\n) {\r\nreturn;\r\n}\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)\r\nreturn;\r\n{\r\nstruct wlan_bssid_ex *pnetwork = &(padapter->mlmeextpriv.mlmext_info.network);\r\nstruct wlan_network *scanned = pmlmepriv->cur_network_scanned;\r\nif (scanned == NULL) {\r\nrtw_warn_on(1);\r\ngoto check_bss;\r\n}\r\nif (!memcmp(scanned->network.MacAddress, pnetwork->MacAddress, sizeof(NDIS_802_11_MAC_ADDRESS))\r\n&& !memcmp(&(scanned->network.Ssid), &(pnetwork->Ssid), sizeof(struct ndis_802_11_ssid))\r\n) {\r\nif (!rtw_cfg80211_inform_bss(padapter, scanned)) {\r\nDBG_871X(FUNC_ADPT_FMT" inform fail !!\n", FUNC_ADPT_ARG(padapter));\r\n} else {\r\n}\r\n} else {\r\nDBG_871X("scanned: %s("MAC_FMT"), cur: %s("MAC_FMT")\n",\r\nscanned->network.Ssid.Ssid, MAC_ARG(scanned->network.MacAddress),\r\npnetwork->Ssid.Ssid, MAC_ARG(pnetwork->MacAddress)\r\n);\r\nrtw_warn_on(1);\r\n}\r\n}\r\ncheck_bss:\r\nif (!rtw_cfg80211_check_bss(padapter))\r\nDBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" BSS not found !!\n", FUNC_ADPT_ARG(padapter));\r\nif (rtw_to_roam(padapter) > 0) {\r\nstruct wiphy *wiphy = pwdev->wiphy;\r\nstruct ieee80211_channel *notify_channel;\r\nu32 freq;\r\nu16 channel = cur_network->network.Configuration.DSConfig;\r\nstruct cfg80211_roam_info roam_info = {};\r\nfreq = rtw_ieee80211_channel_to_frequency(channel, NL80211_BAND_2GHZ);\r\nnotify_channel = ieee80211_get_channel(wiphy, freq);\r\nDBG_871X(FUNC_ADPT_FMT" call cfg80211_roamed\n", FUNC_ADPT_ARG(padapter));\r\nroam_info.channel = notify_channel;\r\nroam_info.bssid = cur_network->network.MacAddress;\r\nroam_info.req_ie =\r\npmlmepriv->assoc_req+sizeof(struct ieee80211_hdr_3addr)+2;\r\nroam_info.req_ie_len =\r\npmlmepriv->assoc_req_len-sizeof(struct ieee80211_hdr_3addr)-2;\r\nroam_info.resp_ie =\r\npmlmepriv->assoc_rsp+sizeof(struct ieee80211_hdr_3addr)+6;\r\nroam_info.resp_ie_len =\r\npmlmepriv->assoc_rsp_len-sizeof(struct ieee80211_hdr_3addr)-6;\r\ncfg80211_roamed(padapter->pnetdev, &roam_info, GFP_ATOMIC);\r\n}\r\nelse\r\n{\r\ncfg80211_connect_result(padapter->pnetdev, cur_network->network.MacAddress\r\n, pmlmepriv->assoc_req+sizeof(struct ieee80211_hdr_3addr)+2\r\n, pmlmepriv->assoc_req_len-sizeof(struct ieee80211_hdr_3addr)-2\r\n, pmlmepriv->assoc_rsp+sizeof(struct ieee80211_hdr_3addr)+6\r\n, pmlmepriv->assoc_rsp_len-sizeof(struct ieee80211_hdr_3addr)-6\r\n, WLAN_STATUS_SUCCESS, GFP_ATOMIC);\r\n}\r\n}\r\nvoid rtw_cfg80211_indicate_disconnect(struct adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct wireless_dev *pwdev = padapter->rtw_wdev;\r\nDBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));\r\nif (pwdev->iftype != NL80211_IFTYPE_STATION\r\n&& pwdev->iftype != NL80211_IFTYPE_P2P_CLIENT\r\n) {\r\nreturn;\r\n}\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)\r\nreturn;\r\nif (!padapter->mlmepriv.not_indic_disco) {\r\nif (check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {\r\ncfg80211_disconnected(padapter->pnetdev, 0,\r\nNULL, 0, true, GFP_ATOMIC);\r\n} else {\r\ncfg80211_connect_result(padapter->pnetdev, NULL, NULL, 0, NULL, 0,\r\nWLAN_STATUS_UNSPECIFIED_FAILURE, GFP_ATOMIC);\r\n}\r\n}\r\n}\r\nstatic int rtw_cfg80211_ap_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)\r\n{\r\nint ret = 0;\r\nu32 wep_key_idx, wep_key_len;\r\nstruct sta_info *psta = NULL, *pbcmc_sta = NULL;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct security_priv* psecuritypriv =&(padapter->securitypriv);\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nDBG_8192C("%s\n", __func__);\r\nparam->u.crypt.err = 0;\r\nparam->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';\r\nif (param_len != sizeof(struct ieee_param) + param->u.crypt.key_len)\r\n{\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nif (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&\r\nparam->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&\r\nparam->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)\r\n{\r\nif (param->u.crypt.idx >= WEP_KEYS)\r\n{\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\n}\r\nelse\r\n{\r\npsta = rtw_get_stainfo(pstapriv, param->sta_addr);\r\nif (!psta)\r\n{\r\nDBG_8192C("rtw_set_encryption(), sta has already been removed or never been added\n");\r\ngoto exit;\r\n}\r\n}\r\nif (strcmp(param->u.crypt.alg, "none") == 0 && (psta == NULL))\r\n{\r\nDBG_8192C("clear default encryption keys, keyid =%d\n", param->u.crypt.idx);\r\ngoto exit;\r\n}\r\nif (strcmp(param->u.crypt.alg, "WEP") == 0 && (psta == NULL))\r\n{\r\nDBG_8192C("r871x_set_encryption, crypt.alg = WEP\n");\r\nwep_key_idx = param->u.crypt.idx;\r\nwep_key_len = param->u.crypt.key_len;\r\nDBG_8192C("r871x_set_encryption, wep_key_idx =%d, len =%d\n", wep_key_idx, wep_key_len);\r\nif ((wep_key_idx >= WEP_KEYS) || (wep_key_len<= 0))\r\n{\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nif (wep_key_len > 0)\r\n{\r\nwep_key_len = wep_key_len <= 5 ? 5 : 13;\r\n}\r\nif (psecuritypriv->bWepDefaultKeyIdxSet == 0)\r\n{\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;\r\npsecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;\r\npsecuritypriv->dot11PrivacyAlgrthm = _WEP40_;\r\npsecuritypriv->dot118021XGrpPrivacy = _WEP40_;\r\nif (wep_key_len == 13)\r\n{\r\npsecuritypriv->dot11PrivacyAlgrthm = _WEP104_;\r\npsecuritypriv->dot118021XGrpPrivacy = _WEP104_;\r\n}\r\npsecuritypriv->dot11PrivacyKeyIndex = wep_key_idx;\r\n}\r\nmemcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), param->u.crypt.key, wep_key_len);\r\npsecuritypriv->dot11DefKeylen[wep_key_idx] = wep_key_len;\r\nrtw_ap_set_wep_key(padapter, param->u.crypt.key, wep_key_len, wep_key_idx, 1);\r\ngoto exit;\r\n}\r\nif (!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE))\r\n{\r\nif (param->u.crypt.set_tx == 0)\r\n{\r\nif (strcmp(param->u.crypt.alg, "WEP") == 0)\r\n{\r\nDBG_8192C("%s, set group_key, WEP\n", __func__);\r\nmemcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey, param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));\r\npsecuritypriv->dot118021XGrpPrivacy = _WEP40_;\r\nif (param->u.crypt.key_len == 13)\r\n{\r\npsecuritypriv->dot118021XGrpPrivacy = _WEP104_;\r\n}\r\n}\r\nelse if (strcmp(param->u.crypt.alg, "TKIP") == 0)\r\n{\r\nDBG_8192C("%s, set group_key, TKIP\n", __func__);\r\npsecuritypriv->dot118021XGrpPrivacy = _TKIP_;\r\nmemcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey, param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));\r\nmemcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);\r\nmemcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);\r\npsecuritypriv->busetkipkey = true;\r\n}\r\nelse if (strcmp(param->u.crypt.alg, "CCMP") == 0)\r\n{\r\nDBG_8192C("%s, set group_key, CCMP\n", __func__);\r\npsecuritypriv->dot118021XGrpPrivacy = _AES_;\r\nmemcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey, param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));\r\n}\r\nelse\r\n{\r\nDBG_8192C("%s, set group_key, none\n", __func__);\r\npsecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;\r\n}\r\npsecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;\r\npsecuritypriv->binstallGrpkey = true;\r\npsecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;\r\nrtw_ap_set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);\r\npbcmc_sta =rtw_get_bcmc_stainfo(padapter);\r\nif (pbcmc_sta)\r\n{\r\npbcmc_sta->ieee8021x_blocked = false;\r\npbcmc_sta->dot118021XPrivacy = psecuritypriv->dot118021XGrpPrivacy;\r\n}\r\n}\r\ngoto exit;\r\n}\r\nif (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta)\r\n{\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE))\r\n{\r\nif (param->u.crypt.set_tx == 1)\r\n{\r\nmemcpy(psta->dot118021x_UncstKey.skey, param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));\r\nif (strcmp(param->u.crypt.alg, "WEP") == 0)\r\n{\r\nDBG_8192C("%s, set pairwise key, WEP\n", __func__);\r\npsta->dot118021XPrivacy = _WEP40_;\r\nif (param->u.crypt.key_len == 13)\r\n{\r\npsta->dot118021XPrivacy = _WEP104_;\r\n}\r\n}\r\nelse if (strcmp(param->u.crypt.alg, "TKIP") == 0)\r\n{\r\nDBG_8192C("%s, set pairwise key, TKIP\n", __func__);\r\npsta->dot118021XPrivacy = _TKIP_;\r\nmemcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);\r\nmemcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);\r\npsecuritypriv->busetkipkey = true;\r\n}\r\nelse if (strcmp(param->u.crypt.alg, "CCMP") == 0)\r\n{\r\nDBG_8192C("%s, set pairwise key, CCMP\n", __func__);\r\npsta->dot118021XPrivacy = _AES_;\r\n}\r\nelse\r\n{\r\nDBG_8192C("%s, set pairwise key, none\n", __func__);\r\npsta->dot118021XPrivacy = _NO_PRIVACY_;\r\n}\r\nrtw_ap_set_pairwise_key(padapter, psta);\r\npsta->ieee8021x_blocked = false;\r\npsta->bpairwise_key_installed = true;\r\n}\r\nelse\r\n{\r\nif (strcmp(param->u.crypt.alg, "WEP") == 0)\r\n{\r\nmemcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey, param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));\r\npsecuritypriv->dot118021XGrpPrivacy = _WEP40_;\r\nif (param->u.crypt.key_len == 13)\r\n{\r\npsecuritypriv->dot118021XGrpPrivacy = _WEP104_;\r\n}\r\n}\r\nelse if (strcmp(param->u.crypt.alg, "TKIP") == 0)\r\n{\r\npsecuritypriv->dot118021XGrpPrivacy = _TKIP_;\r\nmemcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey, param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));\r\nmemcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);\r\nmemcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);\r\npsecuritypriv->busetkipkey = true;\r\n}\r\nelse if (strcmp(param->u.crypt.alg, "CCMP") == 0)\r\n{\r\npsecuritypriv->dot118021XGrpPrivacy = _AES_;\r\nmemcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey, param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));\r\n}\r\nelse\r\n{\r\npsecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;\r\n}\r\npsecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;\r\npsecuritypriv->binstallGrpkey = true;\r\npsecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;\r\nrtw_ap_set_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);\r\npbcmc_sta =rtw_get_bcmc_stainfo(padapter);\r\nif (pbcmc_sta)\r\n{\r\npbcmc_sta->ieee8021x_blocked = false;\r\npbcmc_sta->dot118021XPrivacy = psecuritypriv->dot118021XGrpPrivacy;\r\n}\r\n}\r\n}\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int rtw_cfg80211_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)\r\n{\r\nint ret = 0;\r\nu32 wep_key_idx, wep_key_len;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nDBG_8192C("%s\n", __func__);\r\nparam->u.crypt.err = 0;\r\nparam->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';\r\nif (param_len < (u32) ((u8 *) param->u.crypt.key - (u8 *) param) + param->u.crypt.key_len)\r\n{\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nif (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&\r\nparam->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&\r\nparam->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)\r\n{\r\nif (param->u.crypt.idx >= WEP_KEYS\r\n|| param->u.crypt.idx >= BIP_MAX_KEYID\r\n)\r\n{\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\n} else {\r\n{\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\n}\r\nif (strcmp(param->u.crypt.alg, "WEP") == 0)\r\n{\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("wpa_set_encryption, crypt.alg = WEP\n"));\r\nDBG_8192C("wpa_set_encryption, crypt.alg = WEP\n");\r\nwep_key_idx = param->u.crypt.idx;\r\nwep_key_len = param->u.crypt.key_len;\r\nif ((wep_key_idx >= WEP_KEYS) || (wep_key_len <= 0))\r\n{\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nif (psecuritypriv->bWepDefaultKeyIdxSet == 0)\r\n{\r\nwep_key_len = wep_key_len <= 5 ? 5 : 13;\r\npsecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;\r\npsecuritypriv->dot11PrivacyAlgrthm = _WEP40_;\r\npsecuritypriv->dot118021XGrpPrivacy = _WEP40_;\r\nif (wep_key_len == 13)\r\n{\r\npsecuritypriv->dot11PrivacyAlgrthm = _WEP104_;\r\npsecuritypriv->dot118021XGrpPrivacy = _WEP104_;\r\n}\r\npsecuritypriv->dot11PrivacyKeyIndex = wep_key_idx;\r\n}\r\nmemcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), param->u.crypt.key, wep_key_len);\r\npsecuritypriv->dot11DefKeylen[wep_key_idx] = wep_key_len;\r\nrtw_set_key(padapter, psecuritypriv, wep_key_idx, 0, true);\r\ngoto exit;\r\n}\r\nif (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)\r\n{\r\nstruct sta_info * psta,*pbcmc_sta;\r\nstruct sta_priv * pstapriv = &padapter->stapriv;\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == true)\r\n{\r\npsta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));\r\nif (psta == NULL) {\r\nDBG_8192C("%s, : Obtain Sta_info fail\n", __func__);\r\n}\r\nelse\r\n{\r\nif (strcmp(param->u.crypt.alg, "none") != 0)\r\npsta->ieee8021x_blocked = false;\r\nif ((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||\r\n(padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption3Enabled))\r\n{\r\npsta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;\r\n}\r\nif (param->u.crypt.set_tx == 1)\r\n{\r\nDBG_8192C("%s, : param->u.crypt.set_tx == 1\n", __func__);\r\nmemcpy(psta->dot118021x_UncstKey.skey, param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));\r\nif (strcmp(param->u.crypt.alg, "TKIP") == 0)\r\n{\r\nmemcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);\r\nmemcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);\r\npadapter->securitypriv.busetkipkey =false;\r\n}\r\nDBG_871X(" ~~~~set sta key:unicastkey\n");\r\nrtw_setstakey_cmd(padapter, psta, true, true);\r\n}\r\nelse\r\n{\r\nif (strcmp(param->u.crypt.alg, "TKIP") == 0 || strcmp(param->u.crypt.alg, "CCMP") == 0)\r\n{\r\nmemcpy(padapter->securitypriv.dot118021XGrpKey[param->u.crypt.idx].skey, param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));\r\nmemcpy(padapter->securitypriv.dot118021XGrptxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[16]), 8);\r\nmemcpy(padapter->securitypriv.dot118021XGrprxmickey[param->u.crypt.idx].skey,&(param->u.crypt.key[24]), 8);\r\npadapter->securitypriv.binstallGrpkey = true;\r\nDBG_871X(" ~~~~set sta key:groupkey\n");\r\npadapter->securitypriv.dot118021XGrpKeyid = param->u.crypt.idx;\r\nrtw_set_key(padapter,&padapter->securitypriv, param->u.crypt.idx, 1, true);\r\n}\r\nelse if (strcmp(param->u.crypt.alg, "BIP") == 0)\r\n{\r\nmemcpy(padapter->securitypriv.dot11wBIPKey[param->u.crypt.idx].skey, param->u.crypt.key, (param->u.crypt.key_len>16 ?16:param->u.crypt.key_len));\r\npadapter->securitypriv.dot11wBIPKeyid = param->u.crypt.idx;\r\npadapter->securitypriv.binstallBIPkey = true;\r\nDBG_871X(" ~~~~set sta key:IGKT\n");\r\n}\r\n}\r\n}\r\npbcmc_sta =rtw_get_bcmc_stainfo(padapter);\r\nif (pbcmc_sta == NULL)\r\n{\r\n}\r\nelse\r\n{\r\nif (strcmp(param->u.crypt.alg, "none") != 0)\r\npbcmc_sta->ieee8021x_blocked = false;\r\nif ((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled)||\r\n(padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption3Enabled))\r\n{\r\npbcmc_sta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;\r\n}\r\n}\r\n}\r\nelse if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE))\r\n{\r\n}\r\n}\r\nexit:\r\nDBG_8192C("%s, ret =%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_add_key(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 key_index, bool pairwise, const u8 *mac_addr,\r\nstruct key_params *params)\r\n{\r\nchar *alg_name;\r\nu32 param_len;\r\nstruct ieee_param *param = NULL;\r\nint ret = 0;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(ndev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nDBG_871X(FUNC_NDEV_FMT" adding key for %pM\n", FUNC_NDEV_ARG(ndev), mac_addr);\r\nDBG_871X("cipher = 0x%x\n", params->cipher);\r\nDBG_871X("key_len = 0x%x\n", params->key_len);\r\nDBG_871X("seq_len = 0x%x\n", params->seq_len);\r\nDBG_871X("key_index =%d\n", key_index);\r\nDBG_871X("pairwise =%d\n", pairwise);\r\nparam_len = sizeof(struct ieee_param) + params->key_len;\r\nparam = (struct ieee_param *)rtw_malloc(param_len);\r\nif (param == NULL)\r\nreturn -1;\r\nmemset(param, 0, param_len);\r\nparam->cmd = IEEE_CMD_SET_ENCRYPTION;\r\nmemset(param->sta_addr, 0xff, ETH_ALEN);\r\nswitch (params->cipher) {\r\ncase IW_AUTH_CIPHER_NONE:\r\nalg_name = "none";\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nalg_name = "WEP";\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nalg_name = "TKIP";\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nalg_name = "CCMP";\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_AES_CMAC:\r\nalg_name = "BIP";\r\nbreak;\r\ndefault:\r\nret = -ENOTSUPP;\r\ngoto addkey_end;\r\n}\r\nstrncpy((char *)param->u.crypt.alg, alg_name, IEEE_CRYPT_ALG_NAME_LEN);\r\nif (!mac_addr || is_broadcast_ether_addr(mac_addr))\r\n{\r\nparam->u.crypt.set_tx = 0;\r\n} else {\r\nparam->u.crypt.set_tx = 1;\r\n}\r\nparam->u.crypt.idx = key_index;\r\nif (params->seq_len && params->seq)\r\n{\r\nmemcpy(param->u.crypt.seq, (u8 *)params->seq, params->seq_len);\r\n}\r\nif (params->key_len && params->key)\r\n{\r\nparam->u.crypt.key_len = params->key_len;\r\nmemcpy(param->u.crypt.key, (u8 *)params->key, params->key_len);\r\n}\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)\r\n{\r\nret = rtw_cfg80211_set_encryption(ndev, param, param_len);\r\n}\r\nelse if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)\r\n{\r\nif (mac_addr)\r\nmemcpy(param->sta_addr, (void*)mac_addr, ETH_ALEN);\r\nret = rtw_cfg80211_ap_set_encryption(ndev, param, param_len);\r\n}\r\nelse if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true\r\n|| check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)\r\n{\r\nret = rtw_cfg80211_set_encryption(ndev, param, param_len);\r\n}\r\nelse\r\n{\r\nDBG_8192C("error!\n");\r\n}\r\naddkey_end:\r\nkfree((u8 *)param);\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_get_key(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 key_index, bool pairwise, const u8 *mac_addr,\r\nvoid *cookie,\r\nvoid (*callback)(void *cookie,\r\nstruct key_params*))\r\n{\r\nDBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_del_key(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 key_index, bool pairwise, const u8 *mac_addr)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(ndev);\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nDBG_871X(FUNC_NDEV_FMT" key_index =%d\n", FUNC_NDEV_ARG(ndev), key_index);\r\nif (key_index == psecuritypriv->dot11PrivacyKeyIndex)\r\n{\r\npsecuritypriv->bWepDefaultKeyIdxSet = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_set_default_key(struct wiphy *wiphy,\r\nstruct net_device *ndev, u8 key_index\r\n, bool unicast, bool multicast\r\n)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(ndev);\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nDBG_871X(FUNC_NDEV_FMT" key_index =%d, unicast =%d, multicast =%d\n",\r\nFUNC_NDEV_ARG(ndev), key_index, unicast, multicast);\r\nif ((key_index < WEP_KEYS) && ((psecuritypriv->dot11PrivacyAlgrthm == _WEP40_) || (psecuritypriv->dot11PrivacyAlgrthm == _WEP104_)))\r\n{\r\npsecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;\r\npsecuritypriv->dot11PrivacyKeyIndex = key_index;\r\npsecuritypriv->dot11PrivacyAlgrthm = _WEP40_;\r\npsecuritypriv->dot118021XGrpPrivacy = _WEP40_;\r\nif (psecuritypriv->dot11DefKeylen[key_index] == 13)\r\n{\r\npsecuritypriv->dot11PrivacyAlgrthm = _WEP104_;\r\npsecuritypriv->dot118021XGrpPrivacy = _WEP104_;\r\n}\r\npsecuritypriv->bWepDefaultKeyIdxSet = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_get_station(struct wiphy *wiphy,\r\nstruct net_device *ndev,\r\nconst u8 *mac,\r\nstruct station_info *sinfo)\r\n{\r\nint ret = 0;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(ndev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct sta_info *psta = NULL;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nsinfo->filled = 0;\r\nif (!mac) {\r\nDBG_871X(FUNC_NDEV_FMT" mac ==%p\n", FUNC_NDEV_ARG(ndev), mac);\r\nret = -ENOENT;\r\ngoto exit;\r\n}\r\npsta = rtw_get_stainfo(pstapriv, (u8 *)mac);\r\nif (psta == NULL) {\r\nDBG_8192C("%s, sta_info is null\n", __func__);\r\nret = -ENOENT;\r\ngoto exit;\r\n}\r\n#ifdef DEBUG_CFG80211\r\nDBG_871X(FUNC_NDEV_FMT" mac ="MAC_FMT"\n", FUNC_NDEV_ARG(ndev), MAC_ARG(mac));\r\n#endif\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE)\r\n&& check_fwstate(pmlmepriv, _FW_LINKED)\r\n)\r\n{\r\nstruct wlan_network *cur_network = &(pmlmepriv->cur_network);\r\nif (memcmp((u8 *)mac, cur_network->network.MacAddress, ETH_ALEN)) {\r\nDBG_871X("%s, mismatch bssid ="MAC_FMT"\n", __func__, MAC_ARG(cur_network->network.MacAddress));\r\nret = -ENOENT;\r\ngoto exit;\r\n}\r\nsinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);\r\nsinfo->signal = translate_percentage_to_dbm(padapter->recvpriv.signal_strength);\r\nsinfo->filled |= BIT(NL80211_STA_INFO_TX_BITRATE);\r\nsinfo->txrate.legacy = rtw_get_cur_max_rate(padapter);\r\nsinfo->filled |= BIT(NL80211_STA_INFO_RX_PACKETS);\r\nsinfo->rx_packets = sta_rx_data_pkts(psta);\r\nsinfo->filled |= BIT(NL80211_STA_INFO_TX_PACKETS);\r\nsinfo->tx_packets = psta->sta_stats.tx_pkts;\r\n}\r\nif ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)\r\n||check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)\r\n||check_fwstate(pmlmepriv, WIFI_AP_STATE))\r\n&& check_fwstate(pmlmepriv, _FW_LINKED)\r\n)\r\n{\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_change_iface(struct wiphy *wiphy,\r\nstruct net_device *ndev,\r\nenum nl80211_iftype type,\r\nstruct vif_params *params)\r\n{\r\nenum nl80211_iftype old_type;\r\nenum NDIS_802_11_NETWORK_INFRASTRUCTURE networkType;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(ndev);\r\nstruct wireless_dev *rtw_wdev = padapter->rtw_wdev;\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nint ret = 0;\r\nu8 change = false;\r\nDBG_871X(FUNC_NDEV_FMT" type =%d\n", FUNC_NDEV_ARG(ndev), type);\r\nif (adapter_to_dvobj(padapter)->processing_dev_remove == true)\r\n{\r\nret = -EPERM;\r\ngoto exit;\r\n}\r\n{\r\nDBG_871X(FUNC_NDEV_FMT" call netdev_open\n", FUNC_NDEV_ARG(ndev));\r\nif (netdev_open(ndev) != 0) {\r\nDBG_871X(FUNC_NDEV_FMT" call netdev_open fail\n", FUNC_NDEV_ARG(ndev));\r\nret = -EPERM;\r\ngoto exit;\r\n}\r\n}\r\nif (_FAIL == rtw_pwr_wakeup(padapter)) {\r\nDBG_871X(FUNC_NDEV_FMT" call rtw_pwr_wakeup fail\n", FUNC_NDEV_ARG(ndev));\r\nret = -EPERM;\r\ngoto exit;\r\n}\r\nold_type = rtw_wdev->iftype;\r\nDBG_871X(FUNC_NDEV_FMT" old_iftype =%d, new_iftype =%d\n",\r\nFUNC_NDEV_ARG(ndev), old_type, type);\r\nif (old_type != type)\r\n{\r\nchange = true;\r\npmlmeext->action_public_rxseq = 0xffff;\r\npmlmeext->action_public_dialog_token = 0xff;\r\n}\r\nswitch (type) {\r\ncase NL80211_IFTYPE_ADHOC:\r\nnetworkType = Ndis802_11IBSS;\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\nnetworkType = Ndis802_11Infrastructure;\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\nnetworkType = Ndis802_11APMode;\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\ngoto exit;\r\n}\r\nrtw_wdev->iftype = type;\r\nif (rtw_set_802_11_infrastructure_mode(padapter, networkType) ==false)\r\n{\r\nrtw_wdev->iftype = old_type;\r\nret = -EPERM;\r\ngoto exit;\r\n}\r\nrtw_setopmode_cmd(padapter, networkType, true);\r\nexit:\r\nDBG_871X(FUNC_NDEV_FMT" ret:%d\n", FUNC_NDEV_ARG(ndev), ret);\r\nreturn ret;\r\n}\r\nvoid rtw_cfg80211_indicate_scan_done(struct adapter *adapter, bool aborted)\r\n{\r\nstruct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(adapter);\r\nstruct cfg80211_scan_info info = {\r\n.aborted = aborted\r\n};\r\nspin_lock_bh(&pwdev_priv->scan_req_lock);\r\nif (pwdev_priv->scan_request != NULL) {\r\n#ifdef DEBUG_CFG80211\r\nDBG_871X("%s with scan req\n", __func__);\r\n#endif\r\nif (pwdev_priv->scan_request->wiphy != pwdev_priv->rtw_wdev->wiphy)\r\n{\r\nDBG_8192C("error wiphy compare\n");\r\n}\r\nelse\r\n{\r\ncfg80211_scan_done(pwdev_priv->scan_request, &info);\r\n}\r\npwdev_priv->scan_request = NULL;\r\n} else {\r\n#ifdef DEBUG_CFG80211\r\nDBG_871X("%s without scan req\n", __func__);\r\n#endif\r\n}\r\nspin_unlock_bh(&pwdev_priv->scan_req_lock);\r\n}\r\nvoid rtw_cfg80211_unlink_bss(struct adapter *padapter, struct wlan_network *pnetwork)\r\n{\r\nstruct wireless_dev *pwdev = padapter->rtw_wdev;\r\nstruct wiphy *wiphy = pwdev->wiphy;\r\nstruct cfg80211_bss *bss = NULL;\r\nstruct wlan_bssid_ex select_network = pnetwork->network;\r\nbss = cfg80211_get_bss(wiphy, NULL,\r\nselect_network.MacAddress, select_network.Ssid.Ssid,\r\nselect_network.Ssid.SsidLength, 0,\r\n0);\r\nif (bss) {\r\ncfg80211_unlink_bss(wiphy, bss);\r\nDBG_8192C("%s(): cfg80211_unlink %s!! () ", __func__, select_network.Ssid.Ssid);\r\ncfg80211_put_bss(padapter->rtw_wdev->wiphy, bss);\r\n}\r\nreturn;\r\n}\r\nvoid rtw_cfg80211_surveydone_event_callback(struct adapter *padapter)\r\n{\r\nstruct list_head *plist, *phead;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct __queue *queue = &(pmlmepriv->scanned_queue);\r\nstruct wlan_network *pnetwork = NULL;\r\n#ifdef DEBUG_CFG80211\r\nDBG_8192C("%s\n", __func__);\r\n#endif\r\nspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\r\nphead = get_list_head(queue);\r\nplist = get_next(phead);\r\nwhile (1)\r\n{\r\nif (phead == plist)\r\nbreak;\r\npnetwork = LIST_CONTAINOR(plist, struct wlan_network, list);\r\nif (rtw_ch_set_search_ch(padapter->mlmeextpriv.channel_set, pnetwork->network.Configuration.DSConfig) >= 0\r\n&& rtw_mlme_band_check(padapter, pnetwork->network.Configuration.DSConfig) == true\r\n&& true == rtw_validate_ssid(&(pnetwork->network.Ssid))\r\n)\r\n{\r\nrtw_cfg80211_inform_bss(padapter, pnetwork);\r\n}\r\nplist = get_next(plist);\r\n}\r\nspin_unlock_bh(&(pmlmepriv->scanned_queue.lock));\r\n}\r\nstatic int rtw_cfg80211_set_probe_req_wpsp2pie(struct adapter *padapter, char *buf, int len)\r\n{\r\nint ret = 0;\r\nuint wps_ielen = 0;\r\nu8 *wps_ie;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\n#ifdef DEBUG_CFG80211\r\nDBG_8192C("%s, ielen =%d\n", __func__, len);\r\n#endif\r\nif (len>0)\r\n{\r\nif ((wps_ie = rtw_get_wps_ie(buf, len, NULL, &wps_ielen)))\r\n{\r\n#ifdef DEBUG_CFG80211\r\nDBG_8192C("probe_req_wps_ielen =%d\n", wps_ielen);\r\n#endif\r\nif (pmlmepriv->wps_probe_req_ie)\r\n{\r\npmlmepriv->wps_probe_req_ie_len = 0;\r\nkfree(pmlmepriv->wps_probe_req_ie);\r\npmlmepriv->wps_probe_req_ie = NULL;\r\n}\r\npmlmepriv->wps_probe_req_ie = rtw_malloc(wps_ielen);\r\nif (pmlmepriv->wps_probe_req_ie == NULL) {\r\nDBG_8192C("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(pmlmepriv->wps_probe_req_ie, wps_ie, wps_ielen);\r\npmlmepriv->wps_probe_req_ie_len = wps_ielen;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_scan(struct wiphy *wiphy\r\n, struct cfg80211_scan_request *request)\r\n{\r\nstruct net_device *ndev = wdev_to_ndev(request->wdev);\r\nint i;\r\nu8 _status = false;\r\nint ret = 0;\r\nstruct ndis_802_11_ssid ssid[RTW_SSID_SCAN_AMOUNT];\r\nstruct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];\r\nu8 survey_times =3;\r\nu8 survey_times_for_one_ch =6;\r\nstruct cfg80211_ssid *ssids = request->ssids;\r\nint j = 0;\r\nbool need_indicate_scan_done = false;\r\nstruct adapter *padapter;\r\nstruct rtw_wdev_priv *pwdev_priv;\r\nstruct mlme_priv *pmlmepriv;\r\nif (ndev == NULL) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\npadapter = (struct adapter *)rtw_netdev_priv(ndev);\r\npwdev_priv = adapter_wdev_data(padapter);\r\npmlmepriv = &padapter->mlmepriv;\r\nDBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));\r\nspin_lock_bh(&pwdev_priv->scan_req_lock);\r\npwdev_priv->scan_request = request;\r\nspin_unlock_bh(&pwdev_priv->scan_req_lock);\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)\r\n{\r\n#ifdef DEBUG_CFG80211\r\nDBG_871X("%s under WIFI_AP_STATE\n", __func__);\r\n#endif\r\nif (check_fwstate(pmlmepriv, WIFI_UNDER_WPS|_FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)\r\n{\r\nDBG_8192C("%s, fwstate = 0x%x\n", __func__, pmlmepriv->fw_state);\r\nif (check_fwstate(pmlmepriv, WIFI_UNDER_WPS))\r\n{\r\nDBG_8192C("AP mode process WPS\n");\r\n}\r\nneed_indicate_scan_done = true;\r\ngoto check_need_indicate_scan_done;\r\n}\r\n}\r\nrtw_ps_deny(padapter, PS_DENY_SCAN);\r\nif (_FAIL == rtw_pwr_wakeup(padapter)) {\r\nneed_indicate_scan_done = true;\r\ngoto check_need_indicate_scan_done;\r\n}\r\nif (request->ie && request->ie_len>0)\r\n{\r\nrtw_cfg80211_set_probe_req_wpsp2pie(padapter, (u8 *)request->ie, request->ie_len);\r\n}\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) {\r\nDBG_8192C("%s, fwstate = 0x%x\n", __func__, pmlmepriv->fw_state);\r\nneed_indicate_scan_done = true;\r\ngoto check_need_indicate_scan_done;\r\n} else if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true) {\r\nDBG_8192C("%s, fwstate = 0x%x\n", __func__, pmlmepriv->fw_state);\r\nret = -EBUSY;\r\ngoto check_need_indicate_scan_done;\r\n}\r\nif (pmlmepriv->LinkDetectInfo.bBusyTraffic == true)\r\n{\r\nstatic unsigned long lastscantime = 0;\r\nunsigned long passtime;\r\npasstime = jiffies_to_msecs(jiffies - lastscantime);\r\nlastscantime = jiffies;\r\nif (passtime > 12000)\r\n{\r\nDBG_871X("%s: bBusyTraffic == true\n", __func__);\r\nneed_indicate_scan_done = true;\r\ngoto check_need_indicate_scan_done;\r\n}\r\n}\r\nif (rtw_is_scan_deny(padapter)) {\r\nDBG_871X(FUNC_ADPT_FMT ": scan deny\n", FUNC_ADPT_ARG(padapter));\r\nneed_indicate_scan_done = true;\r\ngoto check_need_indicate_scan_done;\r\n}\r\nmemset(ssid, 0, sizeof(struct ndis_802_11_ssid)*RTW_SSID_SCAN_AMOUNT);\r\nfor (i = 0; i < request->n_ssids && i < RTW_SSID_SCAN_AMOUNT; i++) {\r\n#ifdef DEBUG_CFG80211\r\nDBG_8192C("ssid =%s, len =%d\n", ssids[i].ssid, ssids[i].ssid_len);\r\n#endif\r\nmemcpy(ssid[i].Ssid, ssids[i].ssid, ssids[i].ssid_len);\r\nssid[i].SsidLength = ssids[i].ssid_len;\r\n}\r\nmemset(ch, 0, sizeof(struct rtw_ieee80211_channel)*RTW_CHANNEL_SCAN_AMOUNT);\r\nfor (i = 0;i<request->n_channels && i<RTW_CHANNEL_SCAN_AMOUNT;i++) {\r\n#ifdef DEBUG_CFG80211\r\nDBG_871X(FUNC_ADPT_FMT CHAN_FMT"\n", FUNC_ADPT_ARG(padapter), CHAN_ARG(request->channels[i]));\r\n#endif\r\nch[i].hw_value = request->channels[i]->hw_value;\r\nch[i].flags = request->channels[i]->flags;\r\n}\r\nspin_lock_bh(&pmlmepriv->lock);\r\nif (request->n_channels == 1) {\r\nfor (i = 1;i<survey_times_for_one_ch;i++)\r\nmemcpy(&ch[i], &ch[0], sizeof(struct rtw_ieee80211_channel));\r\n_status = rtw_sitesurvey_cmd(padapter, ssid, RTW_SSID_SCAN_AMOUNT, ch, survey_times_for_one_ch);\r\n} else if (request->n_channels <= 4) {\r\nfor (j =request->n_channels-1;j>= 0;j--)\r\nfor (i = 0;i<survey_times;i++)\r\n{\r\nmemcpy(&ch[j*survey_times+i], &ch[j], sizeof(struct rtw_ieee80211_channel));\r\n}\r\n_status = rtw_sitesurvey_cmd(padapter, ssid, RTW_SSID_SCAN_AMOUNT, ch, survey_times * request->n_channels);\r\n} else {\r\n_status = rtw_sitesurvey_cmd(padapter, ssid, RTW_SSID_SCAN_AMOUNT, NULL, 0);\r\n}\r\nspin_unlock_bh(&pmlmepriv->lock);\r\nif (_status == false)\r\n{\r\nret = -1;\r\n}\r\ncheck_need_indicate_scan_done:\r\nif (true == need_indicate_scan_done)\r\n{\r\nrtw_cfg80211_surveydone_event_callback(padapter);\r\nrtw_cfg80211_indicate_scan_done(padapter, false);\r\n}\r\nrtw_ps_deny_cancel(padapter, PS_DENY_SCAN);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_set_wiphy_params(struct wiphy *wiphy, u32 changed)\r\n{\r\nDBG_8192C("%s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int rtw_cfg80211_set_wpa_version(struct security_priv *psecuritypriv, u32 wpa_version)\r\n{\r\nDBG_8192C("%s, wpa_version =%d\n", __func__, wpa_version);\r\nif (!wpa_version) {\r\npsecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;\r\nreturn 0;\r\n}\r\nif (wpa_version & (NL80211_WPA_VERSION_1 | NL80211_WPA_VERSION_2))\r\n{\r\npsecuritypriv->ndisauthtype = Ndis802_11AuthModeWPAPSK;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtw_cfg80211_set_auth_type(struct security_priv *psecuritypriv,\r\nenum nl80211_auth_type sme_auth_type)\r\n{\r\nDBG_8192C("%s, nl80211_auth_type =%d\n", __func__, sme_auth_type);\r\nswitch (sme_auth_type) {\r\ncase NL80211_AUTHTYPE_AUTOMATIC:\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;\r\nbreak;\r\ncase NL80211_AUTHTYPE_OPEN_SYSTEM:\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;\r\nif (psecuritypriv->ndisauthtype>Ndis802_11AuthModeWPA)\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\r\nbreak;\r\ncase NL80211_AUTHTYPE_SHARED_KEY:\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Shared;\r\npsecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;\r\nbreak;\r\ndefault:\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtw_cfg80211_set_cipher(struct security_priv *psecuritypriv, u32 cipher, bool ucast)\r\n{\r\nu32 ndisencryptstatus = Ndis802_11EncryptionDisabled;\r\nu32 *profile_cipher = ucast ? &psecuritypriv->dot11PrivacyAlgrthm :\r\n&psecuritypriv->dot118021XGrpPrivacy;\r\nDBG_8192C("%s, ucast =%d, cipher = 0x%x\n", __func__, ucast, cipher);\r\nif (!cipher) {\r\n*profile_cipher = _NO_PRIVACY_;\r\npsecuritypriv->ndisencryptstatus = ndisencryptstatus;\r\nreturn 0;\r\n}\r\nswitch (cipher) {\r\ncase IW_AUTH_CIPHER_NONE:\r\n*profile_cipher = _NO_PRIVACY_;\r\nndisencryptstatus = Ndis802_11EncryptionDisabled;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\n*profile_cipher = _WEP40_;\r\nndisencryptstatus = Ndis802_11Encryption1Enabled;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\n*profile_cipher = _WEP104_;\r\nndisencryptstatus = Ndis802_11Encryption1Enabled;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\n*profile_cipher = _TKIP_;\r\nndisencryptstatus = Ndis802_11Encryption2Enabled;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\n*profile_cipher = _AES_;\r\nndisencryptstatus = Ndis802_11Encryption3Enabled;\r\nbreak;\r\ndefault:\r\nDBG_8192C("Unsupported cipher: 0x%x\n", cipher);\r\nreturn -ENOTSUPP;\r\n}\r\nif (ucast)\r\n{\r\npsecuritypriv->ndisencryptstatus = ndisencryptstatus;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtw_cfg80211_set_key_mgt(struct security_priv *psecuritypriv, u32 key_mgt)\r\n{\r\nDBG_8192C("%s, key_mgt = 0x%x\n", __func__, key_mgt);\r\nif (key_mgt == WLAN_AKM_SUITE_8021X)\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\r\nelse if (key_mgt == WLAN_AKM_SUITE_PSK) {\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\r\n}\r\nelse {\r\nDBG_8192C("Invalid key mgt: 0x%x\n", key_mgt);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtw_cfg80211_set_wpa_ie(struct adapter *padapter, u8 *pie, size_t ielen)\r\n{\r\nu8 *buf = NULL, *pos = NULL;\r\nint group_cipher = 0, pairwise_cipher = 0;\r\nint ret = 0;\r\nint wpa_ielen = 0;\r\nint wpa2_ielen = 0;\r\nu8 *pwpa, *pwpa2;\r\nu8 null_addr[]= {0, 0, 0, 0, 0, 0};\r\nif (pie == NULL || !ielen) {\r\n_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);\r\ngoto exit;\r\n}\r\nif (ielen > MAX_WPA_IE_LEN+MAX_WPS_IE_LEN+MAX_P2P_IE_LEN) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nbuf = rtw_zmalloc(ielen);\r\nif (buf == NULL) {\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\nmemcpy(buf, pie , ielen);\r\n{\r\nint i;\r\nDBG_8192C("set wpa_ie(length:%zu):\n", ielen);\r\nfor (i = 0;i<ielen;i =i+8)\r\nDBG_8192C("0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x\n", buf[i], buf[i+1], buf[i+2], buf[i+3], buf[i+4], buf[i+5], buf[i+6], buf[i+7]);\r\n}\r\npos = buf;\r\nif (ielen < RSN_HEADER_LEN) {\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("Ie len too short %d\n", ielen));\r\nret = -1;\r\ngoto exit;\r\n}\r\npwpa = rtw_get_wpa_ie(buf, &wpa_ielen, ielen);\r\nif (pwpa && wpa_ielen>0)\r\n{\r\nif (rtw_parse_wpa_ie(pwpa, wpa_ielen+2, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS)\r\n{\r\npadapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\r\npadapter->securitypriv.ndisauthtype =Ndis802_11AuthModeWPAPSK;\r\nmemcpy(padapter->securitypriv.supplicant_ie, &pwpa[0], wpa_ielen+2);\r\nDBG_8192C("got wpa_ie, wpa_ielen:%u\n", wpa_ielen);\r\n}\r\n}\r\npwpa2 = rtw_get_wpa2_ie(buf, &wpa2_ielen, ielen);\r\nif (pwpa2 && wpa2_ielen>0)\r\n{\r\nif (rtw_parse_wpa2_ie(pwpa2, wpa2_ielen+2, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS)\r\n{\r\npadapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\r\npadapter->securitypriv.ndisauthtype =Ndis802_11AuthModeWPA2PSK;\r\nmemcpy(padapter->securitypriv.supplicant_ie, &pwpa2[0], wpa2_ielen+2);\r\nDBG_8192C("got wpa2_ie, wpa2_ielen:%u\n", wpa2_ielen);\r\n}\r\n}\r\nif (group_cipher == 0)\r\n{\r\ngroup_cipher = WPA_CIPHER_NONE;\r\n}\r\nif (pairwise_cipher == 0)\r\n{\r\npairwise_cipher = WPA_CIPHER_NONE;\r\n}\r\nswitch (group_cipher)\r\n{\r\ncase WPA_CIPHER_NONE:\r\npadapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;\r\npadapter->securitypriv.ndisencryptstatus =Ndis802_11EncryptionDisabled;\r\nbreak;\r\ncase WPA_CIPHER_WEP40:\r\npadapter->securitypriv.dot118021XGrpPrivacy = _WEP40_;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\r\nbreak;\r\ncase WPA_CIPHER_TKIP:\r\npadapter->securitypriv.dot118021XGrpPrivacy = _TKIP_;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;\r\nbreak;\r\ncase WPA_CIPHER_CCMP:\r\npadapter->securitypriv.dot118021XGrpPrivacy = _AES_;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;\r\nbreak;\r\ncase WPA_CIPHER_WEP104:\r\npadapter->securitypriv.dot118021XGrpPrivacy = _WEP104_;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\r\nbreak;\r\n}\r\nswitch (pairwise_cipher)\r\n{\r\ncase WPA_CIPHER_NONE:\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;\r\npadapter->securitypriv.ndisencryptstatus =Ndis802_11EncryptionDisabled;\r\nbreak;\r\ncase WPA_CIPHER_WEP40:\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _WEP40_;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\r\nbreak;\r\ncase WPA_CIPHER_TKIP:\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _TKIP_;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;\r\nbreak;\r\ncase WPA_CIPHER_CCMP:\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _AES_;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;\r\nbreak;\r\ncase WPA_CIPHER_WEP104:\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _WEP104_;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\r\nbreak;\r\n}\r\n{\r\nuint wps_ielen;\r\nu8 *wps_ie;\r\nwps_ie = rtw_get_wps_ie(buf, ielen, NULL, &wps_ielen);\r\nif (wps_ie && wps_ielen > 0) {\r\nDBG_8192C("got wps_ie, wps_ielen:%u\n", wps_ielen);\r\npadapter->securitypriv.wps_ie_len = wps_ielen<MAX_WPS_IE_LEN?wps_ielen:MAX_WPS_IE_LEN;\r\nmemcpy(padapter->securitypriv.wps_ie, wps_ie, padapter->securitypriv.wps_ie_len);\r\nset_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS);\r\n} else {\r\n_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);\r\n}\r\n}\r\nif (padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_\r\n|| padapter->securitypriv.dot11PrivacyAlgrthm == _TKIP_WTMIC_\r\n|| padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)\r\nrtw_hal_set_hwreg(padapter, HW_VAR_OFF_RCR_AM, null_addr);\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,\r\n("rtw_set_wpa_ie: pairwise_cipher = 0x%08x padapter->securitypriv.ndisencryptstatus =%d padapter->securitypriv.ndisauthtype =%d\n",\r\npairwise_cipher, padapter->securitypriv.ndisencryptstatus, padapter->securitypriv.ndisauthtype));\r\nexit:\r\nkfree(buf);\r\nif (ret)\r\n_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_join_ibss(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct cfg80211_ibss_params *params)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(ndev);\r\nstruct ndis_802_11_ssid ndis_ssid;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nint ret = 0;\r\nif (_FAIL == rtw_pwr_wakeup(padapter)) {\r\nret = -EPERM;\r\ngoto exit;\r\n}\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\nret = -EPERM;\r\ngoto exit;\r\n}\r\nif (!params->ssid || !params->ssid_len)\r\n{\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nif (params->ssid_len > IW_ESSID_MAX_SIZE) {\r\nret = -E2BIG;\r\ngoto exit;\r\n}\r\nmemset(&ndis_ssid, 0, sizeof(struct ndis_802_11_ssid));\r\nndis_ssid.SsidLength = params->ssid_len;\r\nmemcpy(ndis_ssid.Ssid, (u8 *)params->ssid, params->ssid_len);\r\npsecuritypriv->ndisencryptstatus = Ndis802_11EncryptionDisabled;\r\npsecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;\r\npsecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;\r\npsecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;\r\nret = rtw_cfg80211_set_auth_type(psecuritypriv, NL80211_AUTHTYPE_OPEN_SYSTEM);\r\nrtw_set_802_11_authentication_mode(padapter, psecuritypriv->ndisauthtype);\r\nif (rtw_set_802_11_ssid(padapter, &ndis_ssid) == false)\r\n{\r\nret = -1;\r\ngoto exit;\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_leave_ibss(struct wiphy *wiphy, struct net_device *ndev)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(ndev);\r\nstruct wireless_dev *rtw_wdev = padapter->rtw_wdev;\r\nenum nl80211_iftype old_type;\r\nint ret = 0;\r\nDBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));\r\npadapter->mlmepriv.not_indic_disco = true;\r\nold_type = rtw_wdev->iftype;\r\nrtw_set_to_roam(padapter, 0);\r\nif (check_fwstate(&padapter->mlmepriv, _FW_LINKED))\r\n{\r\nrtw_scan_abort(padapter);\r\nLeaveAllPowerSaveMode(padapter);\r\nrtw_wdev->iftype = NL80211_IFTYPE_STATION;\r\nif (rtw_set_802_11_infrastructure_mode(padapter, Ndis802_11Infrastructure) ==false)\r\n{\r\nrtw_wdev->iftype = old_type;\r\nret = -EPERM;\r\ngoto leave_ibss;\r\n}\r\nrtw_setopmode_cmd(padapter, Ndis802_11Infrastructure, true);\r\n}\r\nleave_ibss:\r\npadapter->mlmepriv.not_indic_disco = false;\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_connect(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct cfg80211_connect_params *sme)\r\n{\r\nint ret = 0;\r\nenum NDIS_802_11_AUTHENTICATION_MODE authmode;\r\nstruct ndis_802_11_ssid ndis_ssid;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(ndev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\npadapter->mlmepriv.not_indic_disco = true;\r\nDBG_871X("=>"FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));\r\nDBG_871X("privacy =%d, key =%p, key_len =%d, key_idx =%d\n",\r\nsme->privacy, sme->key, sme->key_len, sme->key_idx);\r\nif (adapter_wdev_data(padapter)->block == true)\r\n{\r\nret = -EBUSY;\r\nDBG_871X("%s wdev_priv.block is set\n", __func__);\r\ngoto exit;\r\n}\r\nrtw_ps_deny(padapter, PS_DENY_JOIN);\r\nif (_FAIL == rtw_pwr_wakeup(padapter)) {\r\nret = -EPERM;\r\ngoto exit;\r\n}\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\nret = -EPERM;\r\ngoto exit;\r\n}\r\nif (!sme->ssid || !sme->ssid_len)\r\n{\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nif (sme->ssid_len > IW_ESSID_MAX_SIZE) {\r\nret = -E2BIG;\r\ngoto exit;\r\n}\r\nmemset(&ndis_ssid, 0, sizeof(struct ndis_802_11_ssid));\r\nndis_ssid.SsidLength = sme->ssid_len;\r\nmemcpy(ndis_ssid.Ssid, (u8 *)sme->ssid, sme->ssid_len);\r\nDBG_8192C("ssid =%s, len =%zu\n", ndis_ssid.Ssid, sme->ssid_len);\r\nif (sme->bssid)\r\nDBG_8192C("bssid ="MAC_FMT"\n", MAC_ARG(sme->bssid));\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true) {\r\nret = -EBUSY;\r\nDBG_8192C("%s, fw_state = 0x%x, goto exit\n", __func__, pmlmepriv->fw_state);\r\ngoto exit;\r\n}\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) {\r\nrtw_scan_abort(padapter);\r\n}\r\npsecuritypriv->ndisencryptstatus = Ndis802_11EncryptionDisabled;\r\npsecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;\r\npsecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;\r\npsecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;\r\nret = rtw_cfg80211_set_wpa_version(psecuritypriv, sme->crypto.wpa_versions);\r\nif (ret < 0)\r\ngoto exit;\r\nret = rtw_cfg80211_set_auth_type(psecuritypriv, sme->auth_type);\r\nif (ret < 0)\r\ngoto exit;\r\nDBG_8192C("%s, ie_len =%zu\n", __func__, sme->ie_len);\r\nret = rtw_cfg80211_set_wpa_ie(padapter, (u8 *)sme->ie, sme->ie_len);\r\nif (ret < 0)\r\ngoto exit;\r\nif (sme->crypto.n_ciphers_pairwise) {\r\nret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.ciphers_pairwise[0], true);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\nif ((psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_Shared\r\n|| psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_Auto) && sme->key\r\n)\r\n{\r\nu32 wep_key_idx, wep_key_len, wep_total_len;\r\nstruct ndis_802_11_wep *pwep = NULL;\r\nDBG_871X("%s(): Shared/Auto WEP\n", __func__);\r\nwep_key_idx = sme->key_idx;\r\nwep_key_len = sme->key_len;\r\nif (sme->key_idx > WEP_KEYS) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nif (wep_key_len > 0)\r\n{\r\nwep_key_len = wep_key_len <= 5 ? 5 : 13;\r\nwep_total_len = wep_key_len + FIELD_OFFSET(struct ndis_802_11_wep, KeyMaterial);\r\npwep =(struct ndis_802_11_wep *) rtw_malloc(wep_total_len);\r\nif (pwep == NULL) {\r\nDBG_871X(" wpa_set_encryption: pwep allocate fail !!!\n");\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\nmemset(pwep, 0, wep_total_len);\r\npwep->KeyLength = wep_key_len;\r\npwep->Length = wep_total_len;\r\nif (wep_key_len == 13)\r\n{\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _WEP104_;\r\npadapter->securitypriv.dot118021XGrpPrivacy = _WEP104_;\r\n}\r\n}\r\nelse {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\npwep->KeyIndex = wep_key_idx;\r\npwep->KeyIndex |= 0x80000000;\r\nmemcpy(pwep->KeyMaterial, (void *)sme->key, pwep->KeyLength);\r\nif (rtw_set_802_11_add_wep(padapter, pwep) == (u8)_FAIL)\r\n{\r\nret = -EOPNOTSUPP ;\r\n}\r\nkfree((u8 *)pwep);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\nret = rtw_cfg80211_set_cipher(psecuritypriv, sme->crypto.cipher_group, false);\r\nif (ret < 0)\r\nreturn ret;\r\nif (sme->crypto.n_akm_suites) {\r\nret = rtw_cfg80211_set_key_mgt(psecuritypriv, sme->crypto.akm_suites[0]);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\nauthmode = psecuritypriv->ndisauthtype;\r\nrtw_set_802_11_authentication_mode(padapter, authmode);\r\nif (rtw_set_802_11_connect(padapter, (u8 *)sme->bssid, &ndis_ssid) == false) {\r\nret = -1;\r\ngoto exit;\r\n}\r\nDBG_8192C("set ssid:dot11AuthAlgrthm =%d, dot11PrivacyAlgrthm =%d, dot118021XGrpPrivacy =%d\n", psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm, psecuritypriv->dot118021XGrpPrivacy);\r\nexit:\r\nrtw_ps_deny_cancel(padapter, PS_DENY_JOIN);\r\nDBG_8192C("<=%s, ret %d\n", __func__, ret);\r\npadapter->mlmepriv.not_indic_disco = false;\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_disconnect(struct wiphy *wiphy, struct net_device *ndev,\r\nu16 reason_code)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(ndev);\r\nDBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));\r\npadapter->mlmepriv.not_indic_disco = true;\r\nrtw_set_to_roam(padapter, 0);\r\nrtw_scan_abort(padapter);\r\nLeaveAllPowerSaveMode(padapter);\r\nrtw_disassoc_cmd(padapter, 500, false);\r\nDBG_871X("%s...call rtw_indicate_disconnect\n", __func__);\r\nrtw_indicate_disconnect(padapter);\r\nrtw_free_assoc_resources(padapter, 1);\r\nrtw_pwr_wakeup(padapter);\r\npadapter->mlmepriv.not_indic_disco = false;\r\nDBG_871X(FUNC_NDEV_FMT" return 0\n", FUNC_NDEV_ARG(ndev));\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_set_txpower(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev,\r\nenum nl80211_tx_power_setting type, int mbm)\r\n{\r\nDBG_8192C("%s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_get_txpower(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev,\r\nint *dbm)\r\n{\r\nDBG_8192C("%s\n", __func__);\r\n*dbm = (12);\r\nreturn 0;\r\n}\r\ninline bool rtw_cfg80211_pwr_mgmt(struct adapter *adapter)\r\n{\r\nstruct rtw_wdev_priv *rtw_wdev_priv = adapter_wdev_data(adapter);\r\nreturn rtw_wdev_priv->power_mgmt;\r\n}\r\nstatic int cfg80211_rtw_set_power_mgmt(struct wiphy *wiphy,\r\nstruct net_device *ndev,\r\nbool enabled, int timeout)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(ndev);\r\nstruct rtw_wdev_priv *rtw_wdev_priv = adapter_wdev_data(padapter);\r\nDBG_871X(FUNC_NDEV_FMT" enabled:%u, timeout:%d\n", FUNC_NDEV_ARG(ndev),\r\nenabled, timeout);\r\nrtw_wdev_priv->power_mgmt = enabled;\r\nif (!enabled)\r\nLPS_Leave(padapter, "CFG80211_PWRMGMT");\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_set_pmksa(struct wiphy *wiphy,\r\nstruct net_device *ndev,\r\nstruct cfg80211_pmksa *pmksa)\r\n{\r\nu8 index, blInserted = false;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(ndev);\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nu8 strZeroMacAddress[ ETH_ALEN ] = { 0x00 };\r\nDBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));\r\nif (!memcmp((u8 *)pmksa->bssid, strZeroMacAddress, ETH_ALEN))\r\n{\r\nreturn -EINVAL;\r\n}\r\nblInserted = false;\r\nfor (index = 0 ; index<NUM_PMKID_CACHE; index++)\r\n{\r\nif (!memcmp(psecuritypriv->PMKIDList[index].Bssid, (u8 *)pmksa->bssid, ETH_ALEN))\r\n{\r\nDBG_871X(FUNC_NDEV_FMT" BSSID exists in the PMKList.\n", FUNC_NDEV_ARG(ndev));\r\nmemcpy(psecuritypriv->PMKIDList[index].PMKID, (u8 *)pmksa->pmkid, WLAN_PMKID_LEN);\r\npsecuritypriv->PMKIDList[index].bUsed = true;\r\npsecuritypriv->PMKIDIndex = index+1;\r\nblInserted = true;\r\nbreak;\r\n}\r\n}\r\nif (!blInserted)\r\n{\r\nDBG_871X(FUNC_NDEV_FMT" Use the new entry index = %d for this PMKID.\n",\r\nFUNC_NDEV_ARG(ndev), psecuritypriv->PMKIDIndex);\r\nmemcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].Bssid, (u8 *)pmksa->bssid, ETH_ALEN);\r\nmemcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].PMKID, (u8 *)pmksa->pmkid, WLAN_PMKID_LEN);\r\npsecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].bUsed = true;\r\npsecuritypriv->PMKIDIndex++ ;\r\nif (psecuritypriv->PMKIDIndex == 16)\r\n{\r\npsecuritypriv->PMKIDIndex = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_del_pmksa(struct wiphy *wiphy,\r\nstruct net_device *ndev,\r\nstruct cfg80211_pmksa *pmksa)\r\n{\r\nu8 index, bMatched = false;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(ndev);\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nDBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));\r\nfor (index = 0 ; index<NUM_PMKID_CACHE; index++)\r\n{\r\nif (!memcmp(psecuritypriv->PMKIDList[index].Bssid, (u8 *)pmksa->bssid, ETH_ALEN))\r\n{\r\nmemset(psecuritypriv->PMKIDList[index].Bssid, 0x00, ETH_ALEN);\r\nmemset(psecuritypriv->PMKIDList[index].PMKID, 0x00, WLAN_PMKID_LEN);\r\npsecuritypriv->PMKIDList[index].bUsed = false;\r\nbMatched = true;\r\nbreak;\r\n}\r\n}\r\nif (false == bMatched)\r\n{\r\nDBG_871X(FUNC_NDEV_FMT" do not have matched BSSID\n"\r\n, FUNC_NDEV_ARG(ndev));\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_flush_pmksa(struct wiphy *wiphy,\r\nstruct net_device *ndev)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(ndev);\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nDBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));\r\nmemset(&psecuritypriv->PMKIDList[ 0 ], 0x00, sizeof(RT_PMKID_LIST) * NUM_PMKID_CACHE);\r\npsecuritypriv->PMKIDIndex = 0;\r\nreturn 0;\r\n}\r\nvoid rtw_cfg80211_indicate_sta_assoc(struct adapter *padapter, u8 *pmgmt_frame, uint frame_len)\r\n{\r\nstruct net_device *ndev = padapter->pnetdev;\r\nDBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));\r\n{\r\nstruct station_info sinfo;\r\nu8 ie_offset;\r\nif (GetFrameSubType(pmgmt_frame) == WIFI_ASSOCREQ)\r\nie_offset = _ASOCREQ_IE_OFFSET_;\r\nelse\r\nie_offset = _REASOCREQ_IE_OFFSET_;\r\nsinfo.filled = 0;\r\nsinfo.assoc_req_ies = pmgmt_frame + WLAN_HDR_A3_LEN + ie_offset;\r\nsinfo.assoc_req_ies_len = frame_len - WLAN_HDR_A3_LEN - ie_offset;\r\ncfg80211_new_sta(ndev, GetAddr2Ptr(pmgmt_frame), &sinfo, GFP_ATOMIC);\r\n}\r\n}\r\nvoid rtw_cfg80211_indicate_sta_disassoc(struct adapter *padapter, unsigned char *da, unsigned short reason)\r\n{\r\nstruct net_device *ndev = padapter->pnetdev;\r\nDBG_871X(FUNC_ADPT_FMT"\n", FUNC_ADPT_ARG(padapter));\r\ncfg80211_del_sta(ndev, da, GFP_ATOMIC);\r\n}\r\nstatic int rtw_cfg80211_monitor_if_open(struct net_device *ndev)\r\n{\r\nint ret = 0;\r\nDBG_8192C("%s\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int rtw_cfg80211_monitor_if_close(struct net_device *ndev)\r\n{\r\nint ret = 0;\r\nDBG_8192C("%s\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int rtw_cfg80211_monitor_if_xmit_entry(struct sk_buff *skb, struct net_device *ndev)\r\n{\r\nint ret = 0;\r\nint rtap_len;\r\nint qos_len = 0;\r\nint dot11_hdr_len = 24;\r\nint snap_len = 6;\r\nunsigned char *pdata;\r\nu16 frame_control;\r\nunsigned char src_mac_addr[6];\r\nunsigned char dst_mac_addr[6];\r\nstruct ieee80211_hdr *dot11_hdr;\r\nstruct ieee80211_radiotap_header *rtap_hdr;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(ndev);\r\nDBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));\r\nif (!skb)\r\ngoto fail;\r\nrtw_mstat_update(MSTAT_TYPE_SKB, MSTAT_ALLOC_SUCCESS, skb->truesize);\r\nif (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))\r\ngoto fail;\r\nrtap_hdr = (struct ieee80211_radiotap_header *)skb->data;\r\nif (unlikely(rtap_hdr->it_version))\r\ngoto fail;\r\nrtap_len = ieee80211_get_radiotap_len(skb->data);\r\nif (unlikely(skb->len < rtap_len))\r\ngoto fail;\r\nif (rtap_len != 14)\r\n{\r\nDBG_8192C("radiotap len (should be 14): %d\n", rtap_len);\r\ngoto fail;\r\n}\r\nskb_pull(skb, rtap_len);\r\ndot11_hdr = (struct ieee80211_hdr *)skb->data;\r\nframe_control = le16_to_cpu(dot11_hdr->frame_control);\r\nif ((frame_control & RTW_IEEE80211_FCTL_FTYPE) == RTW_IEEE80211_FTYPE_DATA) {\r\nif (frame_control & 0x0080)\r\nqos_len = 2;\r\nif ((frame_control & 0x0300) == 0x0300)\r\ndot11_hdr_len += 6;\r\nmemcpy(dst_mac_addr, dot11_hdr->addr1, sizeof(dst_mac_addr));\r\nmemcpy(src_mac_addr, dot11_hdr->addr2, sizeof(src_mac_addr));\r\nskb_pull(skb, dot11_hdr_len + qos_len + snap_len - sizeof(src_mac_addr) * 2);\r\npdata = (unsigned char*)skb->data;\r\nmemcpy(pdata, dst_mac_addr, sizeof(dst_mac_addr));\r\nmemcpy(pdata + sizeof(dst_mac_addr), src_mac_addr, sizeof(src_mac_addr));\r\nDBG_8192C("should be eapol packet\n");\r\nret = _rtw_xmit_entry(skb, padapter->pnetdev);\r\nreturn ret;\r\n}\r\nelse if ((frame_control & (RTW_IEEE80211_FCTL_FTYPE|RTW_IEEE80211_FCTL_STYPE))\r\n== (RTW_IEEE80211_FTYPE_MGMT|RTW_IEEE80211_STYPE_ACTION)\r\n)\r\n{\r\nstruct xmit_frame *pmgntframe;\r\nstruct pkt_attrib *pattrib;\r\nunsigned char *pframe;\r\nstruct ieee80211_hdr *pwlanhdr;\r\nstruct xmit_priv *pxmitpriv = &(padapter->xmitpriv);\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nu8 *buf = skb->data;\r\nu32 len = skb->len;\r\nu8 category, action;\r\nif (rtw_action_frame_parse(buf, len, &category, &action) == false) {\r\nDBG_8192C(FUNC_NDEV_FMT" frame_control:0x%x\n", FUNC_NDEV_ARG(ndev),\r\nle16_to_cpu(((struct ieee80211_hdr_3addr *)buf)->frame_control));\r\ngoto fail;\r\n}\r\nDBG_8192C("RTW_Tx:da ="MAC_FMT" via "FUNC_NDEV_FMT"\n",\r\nMAC_ARG(GetAddr1Ptr(buf)), FUNC_NDEV_ARG(ndev));\r\nif (category == RTW_WLAN_CATEGORY_PUBLIC)\r\nDBG_871X("RTW_Tx:%s\n", action_public_str(action));\r\nelse\r\nDBG_871X("RTW_Tx:category(%u), action(%u)\n", category, action);\r\nif ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)\r\n{\r\ngoto fail;\r\n}\r\npattrib = &pmgntframe->attrib;\r\nupdate_mgntframe_attrib(padapter, pattrib);\r\npattrib->retry_ctrl = false;\r\nmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\r\npframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\r\nmemcpy(pframe, (void*)buf, len);\r\npattrib->pktlen = len;\r\npwlanhdr = (struct ieee80211_hdr *)pframe;\r\npmlmeext->mgnt_seq = GetSequence(pwlanhdr);\r\npattrib->seqnum = pmlmeext->mgnt_seq;\r\npmlmeext->mgnt_seq++;\r\npattrib->last_txcmdsz = pattrib->pktlen;\r\ndump_mgntframe(padapter, pmgntframe);\r\n}\r\nelse\r\n{\r\nDBG_8192C("frame_control = 0x%x\n", frame_control & (RTW_IEEE80211_FCTL_FTYPE|RTW_IEEE80211_FCTL_STYPE));\r\n}\r\nfail:\r\ndev_kfree_skb_any(skb);\r\nreturn 0;\r\n}\r\nstatic int rtw_cfg80211_monitor_if_set_mac_address(struct net_device *ndev, void *addr)\r\n{\r\nint ret = 0;\r\nDBG_8192C("%s\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int rtw_cfg80211_add_monitor_if (struct adapter *padapter, char *name, struct net_device **ndev)\r\n{\r\nint ret = 0;\r\nstruct net_device* mon_ndev = NULL;\r\nstruct wireless_dev* mon_wdev = NULL;\r\nstruct rtw_netdev_priv_indicator *pnpi;\r\nstruct rtw_wdev_priv *pwdev_priv = adapter_wdev_data(padapter);\r\nif (!name) {\r\nDBG_871X(FUNC_ADPT_FMT" without specific name\n", FUNC_ADPT_ARG(padapter));\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (pwdev_priv->pmon_ndev) {\r\nDBG_871X(FUNC_ADPT_FMT" monitor interface exist: "NDEV_FMT"\n",\r\nFUNC_ADPT_ARG(padapter), NDEV_ARG(pwdev_priv->pmon_ndev));\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nmon_ndev = alloc_etherdev(sizeof(struct rtw_netdev_priv_indicator));\r\nif (!mon_ndev) {\r\nDBG_871X(FUNC_ADPT_FMT" allocate ndev fail\n", FUNC_ADPT_ARG(padapter));\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmon_ndev->type = ARPHRD_IEEE80211_RADIOTAP;\r\nstrncpy(mon_ndev->name, name, IFNAMSIZ);\r\nmon_ndev->name[IFNAMSIZ - 1] = 0;\r\nmon_ndev->needs_free_netdev = true;\r\nmon_ndev->priv_destructor = rtw_ndev_destructor;\r\nmon_ndev->netdev_ops = &rtw_cfg80211_monitor_if_ops;\r\npnpi = netdev_priv(mon_ndev);\r\npnpi->priv = padapter;\r\npnpi->sizeof_priv = sizeof(struct adapter);\r\nmon_wdev = (struct wireless_dev *)rtw_zmalloc(sizeof(struct wireless_dev));\r\nif (!mon_wdev) {\r\nDBG_871X(FUNC_ADPT_FMT" allocate mon_wdev fail\n", FUNC_ADPT_ARG(padapter));\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmon_wdev->wiphy = padapter->rtw_wdev->wiphy;\r\nmon_wdev->netdev = mon_ndev;\r\nmon_wdev->iftype = NL80211_IFTYPE_MONITOR;\r\nmon_ndev->ieee80211_ptr = mon_wdev;\r\nret = register_netdevice(mon_ndev);\r\nif (ret) {\r\ngoto out;\r\n}\r\n*ndev = pwdev_priv->pmon_ndev = mon_ndev;\r\nmemcpy(pwdev_priv->ifname_mon, name, IFNAMSIZ+1);\r\nout:\r\nif (ret && mon_wdev) {\r\nkfree((u8 *)mon_wdev);\r\nmon_wdev = NULL;\r\n}\r\nif (ret && mon_ndev) {\r\nfree_netdev(mon_ndev);\r\n*ndev = mon_ndev = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic struct wireless_dev *\r\ncfg80211_rtw_add_virtual_intf(\r\nstruct wiphy *wiphy,\r\nconst char *name,\r\nunsigned char name_assign_type,\r\nenum nl80211_iftype type, struct vif_params *params)\r\n{\r\nint ret = 0;\r\nstruct net_device* ndev = NULL;\r\nstruct adapter *padapter = wiphy_to_adapter(wiphy);\r\nDBG_871X(FUNC_ADPT_FMT " wiphy:%s, name:%s, type:%d\n",\r\nFUNC_ADPT_ARG(padapter), wiphy_name(wiphy), name, type);\r\nswitch (type) {\r\ncase NL80211_IFTYPE_ADHOC:\r\ncase NL80211_IFTYPE_AP_VLAN:\r\ncase NL80211_IFTYPE_WDS:\r\ncase NL80211_IFTYPE_MESH_POINT:\r\nret = -ENODEV;\r\nbreak;\r\ncase NL80211_IFTYPE_MONITOR:\r\nret = rtw_cfg80211_add_monitor_if(padapter, (char *)name, &ndev);\r\nbreak;\r\ncase NL80211_IFTYPE_P2P_CLIENT:\r\ncase NL80211_IFTYPE_STATION:\r\nret = -ENODEV;\r\nbreak;\r\ncase NL80211_IFTYPE_P2P_GO:\r\ncase NL80211_IFTYPE_AP:\r\nret = -ENODEV;\r\nbreak;\r\ndefault:\r\nret = -ENODEV;\r\nDBG_871X("Unsupported interface type\n");\r\nbreak;\r\n}\r\nDBG_871X(FUNC_ADPT_FMT" ndev:%p, ret:%d\n", FUNC_ADPT_ARG(padapter), ndev, ret);\r\nreturn ndev ? ndev->ieee80211_ptr : ERR_PTR(ret);\r\n}\r\nstatic int cfg80211_rtw_del_virtual_intf(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev\r\n)\r\n{\r\nstruct net_device *ndev = wdev_to_ndev(wdev);\r\nint ret = 0;\r\nstruct adapter *adapter;\r\nstruct rtw_wdev_priv *pwdev_priv;\r\nif (!ndev) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nadapter = (struct adapter *)rtw_netdev_priv(ndev);\r\npwdev_priv = adapter_wdev_data(adapter);\r\nunregister_netdevice(ndev);\r\nif (ndev == pwdev_priv->pmon_ndev) {\r\npwdev_priv->pmon_ndev = NULL;\r\npwdev_priv->ifname_mon[0] = '\0';\r\nDBG_871X(FUNC_NDEV_FMT" remove monitor interface\n", FUNC_NDEV_ARG(ndev));\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int rtw_add_beacon(struct adapter *adapter, const u8 *head, size_t head_len, const u8 *tail, size_t tail_len)\r\n{\r\nint ret = 0;\r\nu8 *pbuf = NULL;\r\nuint len, wps_ielen = 0;\r\nstruct mlme_priv *pmlmepriv = &(adapter->mlmepriv);\r\nDBG_8192C("%s beacon_head_len =%zu, beacon_tail_len =%zu\n", __func__, head_len, tail_len);\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)\r\nreturn -EINVAL;\r\nif (head_len<24)\r\nreturn -EINVAL;\r\npbuf = rtw_zmalloc(head_len+tail_len);\r\nif (!pbuf)\r\nreturn -ENOMEM;\r\nmemcpy(pbuf, (void *)head+24, head_len-24);\r\nmemcpy(pbuf+head_len-24, (void *)tail, tail_len);\r\nlen = head_len+tail_len-24;\r\nif (rtw_get_wps_ie(pbuf+_FIXED_IE_LENGTH_, len-_FIXED_IE_LENGTH_, NULL, &wps_ielen))\r\nDBG_8192C("add bcn, wps_ielen =%d\n", wps_ielen);\r\nrtw_ies_remove_ie(pbuf, &len, _BEACON_IE_OFFSET_, _VENDOR_SPECIFIC_IE_, P2P_OUI, 4);\r\nrtw_ies_remove_ie(pbuf, &len, _BEACON_IE_OFFSET_, _VENDOR_SPECIFIC_IE_, WFD_OUI, 4);\r\nif (rtw_check_beacon_data(adapter, pbuf, len) == _SUCCESS)\r\n{\r\nret = 0;\r\n}\r\nelse\r\n{\r\nret = -EINVAL;\r\n}\r\nkfree(pbuf);\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_start_ap(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct cfg80211_ap_settings *settings)\r\n{\r\nint ret = 0;\r\nstruct adapter *adapter = (struct adapter *)rtw_netdev_priv(ndev);\r\nDBG_871X(FUNC_NDEV_FMT" hidden_ssid:%d, auth_type:%d\n", FUNC_NDEV_ARG(ndev),\r\nsettings->hidden_ssid, settings->auth_type);\r\nret = rtw_add_beacon(adapter, settings->beacon.head, settings->beacon.head_len,\r\nsettings->beacon.tail, settings->beacon.tail_len);\r\nadapter->mlmeextpriv.mlmext_info.hidden_ssid_mode = settings->hidden_ssid;\r\nif (settings->ssid && settings->ssid_len) {\r\nstruct wlan_bssid_ex *pbss_network = &adapter->mlmepriv.cur_network.network;\r\nstruct wlan_bssid_ex *pbss_network_ext = &adapter->mlmeextpriv.mlmext_info.network;\r\nmemcpy(pbss_network->Ssid.Ssid, (void *)settings->ssid, settings->ssid_len);\r\npbss_network->Ssid.SsidLength = settings->ssid_len;\r\nmemcpy(pbss_network_ext->Ssid.Ssid, (void *)settings->ssid, settings->ssid_len);\r\npbss_network_ext->Ssid.SsidLength = settings->ssid_len;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_change_beacon(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct cfg80211_beacon_data *info)\r\n{\r\nint ret = 0;\r\nstruct adapter *adapter = (struct adapter *)rtw_netdev_priv(ndev);\r\nDBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));\r\nret = rtw_add_beacon(adapter, info->head, info->head_len, info->tail, info->tail_len);\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_stop_ap(struct wiphy *wiphy, struct net_device *ndev)\r\n{\r\nDBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_add_station(struct wiphy *wiphy, struct net_device *ndev,\r\nconst u8 *mac,\r\nstruct station_parameters *params)\r\n{\r\nDBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));\r\nreturn 0;\r\n}\r\nstatic int cfg80211_rtw_del_station(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct station_del_parameters *params)\r\n{\r\nint ret = 0;\r\nstruct list_head *phead, *plist;\r\nu8 updated = false;\r\nstruct sta_info *psta = NULL;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(ndev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nconst u8 *mac = params->mac;\r\nDBG_871X("+"FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));\r\nif (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != true)\r\n{\r\nDBG_8192C("%s, fw_state != FW_LINKED|WIFI_AP_STATE\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (!mac)\r\n{\r\nDBG_8192C("flush all sta, and cam_entry\n");\r\nflush_all_cam_entry(padapter);\r\nret = rtw_sta_flush(padapter);\r\nreturn ret;\r\n}\r\nDBG_8192C("free sta macaddr =" MAC_FMT "\n", MAC_ARG(mac));\r\nif (mac[0] == 0xff && mac[1] == 0xff &&\r\nmac[2] == 0xff && mac[3] == 0xff &&\r\nmac[4] == 0xff && mac[5] == 0xff)\r\n{\r\nreturn -EINVAL;\r\n}\r\nspin_lock_bh(&pstapriv->asoc_list_lock);\r\nphead = &pstapriv->asoc_list;\r\nplist = get_next(phead);\r\nwhile (phead != plist)\r\n{\r\npsta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);\r\nplist = get_next(plist);\r\nif (!memcmp((u8 *)mac, psta->hwaddr, ETH_ALEN))\r\n{\r\nif (psta->dot8021xalg == 1 && psta->bpairwise_key_installed == false)\r\n{\r\nDBG_8192C("%s, sta's dot8021xalg = 1 and key_installed = false\n", __func__);\r\n}\r\nelse\r\n{\r\nDBG_8192C("free psta =%p, aid =%d\n", psta, psta->aid);\r\nlist_del_init(&psta->asoc_list);\r\npstapriv->asoc_list_cnt--;\r\nupdated = ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);\r\npsta = NULL;\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&pstapriv->asoc_list_lock);\r\nassociated_clients_update(padapter, updated);\r\nDBG_871X("-"FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_change_station(struct wiphy *wiphy, struct net_device *ndev,\r\nconst u8 *mac, struct station_parameters *params)\r\n{\r\nDBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));\r\nreturn 0;\r\n}\r\nstatic struct sta_info *rtw_sta_info_get_by_idx(const int idx, struct sta_priv *pstapriv)\r\n{\r\nstruct list_head *phead, *plist;\r\nstruct sta_info *psta = NULL;\r\nint i = 0;\r\nphead = &pstapriv->asoc_list;\r\nplist = get_next(phead);\r\nwhile (phead != plist)\r\n{\r\nif (idx == i) psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);\r\nplist = get_next(plist);\r\ni++;\r\n}\r\nreturn psta;\r\n}\r\nstatic int cfg80211_rtw_dump_station(struct wiphy *wiphy, struct net_device *ndev,\r\nint idx, u8 *mac, struct station_info *sinfo)\r\n{\r\nint ret = 0;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(ndev);\r\nstruct sta_info *psta = NULL;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nDBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));\r\nspin_lock_bh(&pstapriv->asoc_list_lock);\r\npsta = rtw_sta_info_get_by_idx(idx, pstapriv);\r\nspin_unlock_bh(&pstapriv->asoc_list_lock);\r\nif (NULL == psta)\r\n{\r\nDBG_871X("Station is not found\n");\r\nret = -ENOENT;\r\ngoto exit;\r\n}\r\nmemcpy(mac, psta->hwaddr, ETH_ALEN);\r\nsinfo->filled = BIT(NL80211_STA_INFO_SIGNAL);\r\nsinfo->signal = psta->rssi;\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_change_bss(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct bss_parameters *params)\r\n{\r\nDBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));\r\nreturn 0;\r\n}\r\nvoid rtw_cfg80211_rx_action(struct adapter *adapter, u8 *frame, uint frame_len, const char*msg)\r\n{\r\ns32 freq;\r\nint channel;\r\nu8 category, action;\r\nchannel = rtw_get_oper_ch(adapter);\r\nrtw_action_frame_parse(frame, frame_len, &category, &action);\r\nDBG_8192C("RTW_Rx:cur_ch =%d\n", channel);\r\nif (msg)\r\nDBG_871X("RTW_Rx:%s\n", msg);\r\nelse\r\nDBG_871X("RTW_Rx:category(%u), action(%u)\n", category, action);\r\nfreq = rtw_ieee80211_channel_to_frequency(channel, NL80211_BAND_2GHZ);\r\nrtw_cfg80211_rx_mgmt(adapter, freq, 0, frame, frame_len, GFP_ATOMIC);\r\n}\r\nstatic int _cfg80211_rtw_mgmt_tx(struct adapter *padapter, u8 tx_ch, const u8 *buf, size_t len)\r\n{\r\nstruct xmit_frame *pmgntframe;\r\nstruct pkt_attrib *pattrib;\r\nunsigned char *pframe;\r\nint ret = _FAIL;\r\nbool ack = true;\r\nstruct ieee80211_hdr *pwlanhdr;\r\nstruct xmit_priv *pxmitpriv = &(padapter->xmitpriv);\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nrtw_set_scan_deny(padapter, 1000);\r\nrtw_scan_abort(padapter);\r\nif (tx_ch != rtw_get_oper_ch(padapter)) {\r\nif (!check_fwstate(&padapter->mlmepriv, _FW_LINKED))\r\npmlmeext->cur_channel = tx_ch;\r\nset_channel_bwmode(padapter, tx_ch, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);\r\n}\r\nif ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)\r\n{\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\npattrib = &pmgntframe->attrib;\r\nupdate_mgntframe_attrib(padapter, pattrib);\r\npattrib->retry_ctrl = false;\r\nmemset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);\r\npframe = (u8 *)(pmgntframe->buf_addr) + TXDESC_OFFSET;\r\nmemcpy(pframe, (void*)buf, len);\r\npattrib->pktlen = len;\r\npwlanhdr = (struct ieee80211_hdr *)pframe;\r\npmlmeext->mgnt_seq = GetSequence(pwlanhdr);\r\npattrib->seqnum = pmlmeext->mgnt_seq;\r\npmlmeext->mgnt_seq++;\r\npattrib->last_txcmdsz = pattrib->pktlen;\r\nif (dump_mgntframe_and_wait_ack(padapter, pmgntframe) != _SUCCESS)\r\n{\r\nack = false;\r\nret = _FAIL;\r\n#ifdef DEBUG_CFG80211\r\nDBG_8192C("%s, ack == _FAIL\n", __func__);\r\n#endif\r\n}\r\nelse\r\n{\r\nmsleep(50);\r\n#ifdef DEBUG_CFG80211\r\nDBG_8192C("%s, ack =%d, ok!\n", __func__, ack);\r\n#endif\r\nret = _SUCCESS;\r\n}\r\nexit:\r\n#ifdef DEBUG_CFG80211\r\nDBG_8192C("%s, ret =%d\n", __func__, ret);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_mgmt_tx(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev,\r\nstruct cfg80211_mgmt_tx_params *params,\r\nu64 *cookie)\r\n{\r\nstruct net_device *ndev = wdev_to_ndev(wdev);\r\nstruct ieee80211_channel *chan = params->chan;\r\nconst u8 *buf = params->buf;\r\nsize_t len = params->len;\r\nint ret = 0;\r\nint tx_ret;\r\nu32 dump_limit = RTW_MAX_MGMT_TX_CNT;\r\nu32 dump_cnt = 0;\r\nbool ack = true;\r\nu8 tx_ch = (u8)ieee80211_frequency_to_channel(chan->center_freq);\r\nu8 category, action;\r\nint type = (-1);\r\nstruct adapter *padapter;\r\nstruct rtw_wdev_priv *pwdev_priv;\r\nif (ndev == NULL) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\npadapter = (struct adapter *)rtw_netdev_priv(ndev);\r\npwdev_priv = adapter_wdev_data(padapter);\r\n*cookie = (unsigned long) buf;\r\n#ifdef DEBUG_CFG80211\r\nDBG_871X(FUNC_ADPT_FMT" len =%zu, ch =%d"\r\n"\n", FUNC_ADPT_ARG(padapter),\r\nlen, tx_ch\r\n);\r\n#endif\r\nrtw_cfg80211_mgmt_tx_status(padapter, *cookie, buf, len, ack, GFP_KERNEL);\r\nif (rtw_action_frame_parse(buf, len, &category, &action) == false) {\r\nDBG_8192C(FUNC_ADPT_FMT" frame_control:0x%x\n", FUNC_ADPT_ARG(padapter),\r\nle16_to_cpu(((struct ieee80211_hdr_3addr *)buf)->frame_control));\r\ngoto exit;\r\n}\r\nDBG_8192C("RTW_Tx:tx_ch =%d, da ="MAC_FMT"\n", tx_ch, MAC_ARG(GetAddr1Ptr(buf)));\r\nif (category == RTW_WLAN_CATEGORY_PUBLIC)\r\nDBG_871X("RTW_Tx:%s\n", action_public_str(action));\r\nelse\r\nDBG_871X("RTW_Tx:category(%u), action(%u)\n", category, action);\r\nrtw_ps_deny(padapter, PS_DENY_MGNT_TX);\r\nif (_FAIL == rtw_pwr_wakeup(padapter)) {\r\nret = -EFAULT;\r\ngoto cancel_ps_deny;\r\n}\r\ndo {\r\ndump_cnt++;\r\ntx_ret = _cfg80211_rtw_mgmt_tx(padapter, tx_ch, buf, len);\r\n} while (dump_cnt < dump_limit && tx_ret != _SUCCESS);\r\nif (tx_ret != _SUCCESS || dump_cnt > 1) {\r\nDBG_871X(FUNC_ADPT_FMT" %s (%d/%d)\n", FUNC_ADPT_ARG(padapter),\r\ntx_ret == _SUCCESS?"OK":"FAIL", dump_cnt, dump_limit);\r\n}\r\nswitch (type) {\r\ncase P2P_GO_NEGO_CONF:\r\nrtw_clear_scan_deny(padapter);\r\nbreak;\r\ncase P2P_INVIT_RESP:\r\nif (pwdev_priv->invit_info.flags & BIT(0)\r\n&& pwdev_priv->invit_info.status == 0)\r\n{\r\nDBG_871X(FUNC_ADPT_FMT" agree with invitation of persistent group\n",\r\nFUNC_ADPT_ARG(padapter));\r\nrtw_set_scan_deny(padapter, 5000);\r\nrtw_pwr_wakeup_ex(padapter, 5000);\r\nrtw_clear_scan_deny(padapter);\r\n}\r\nbreak;\r\n}\r\ncancel_ps_deny:\r\nrtw_ps_deny_cancel(padapter, PS_DENY_MGNT_TX);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic void cfg80211_rtw_mgmt_frame_register(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev,\r\nu16 frame_type, bool reg)\r\n{\r\nstruct net_device *ndev = wdev_to_ndev(wdev);\r\nstruct adapter *adapter;\r\nif (ndev == NULL)\r\ngoto exit;\r\nadapter = (struct adapter *)rtw_netdev_priv(ndev);\r\n#ifdef DEBUG_CFG80211\r\nDBG_871X(FUNC_ADPT_FMT" frame_type:%x, reg:%d\n", FUNC_ADPT_ARG(adapter),\r\nframe_type, reg);\r\n#endif\r\nif (frame_type != (IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_PROBE_REQ))\r\nreturn;\r\nexit:\r\nreturn;\r\n}\r\nstatic int cfg80211_rtw_sched_scan_start(struct wiphy *wiphy,\r\nstruct net_device *dev,\r\nstruct cfg80211_sched_scan_request *request) {\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nu8 ret;\r\nif (padapter->bup == false) {\r\nDBG_871X("%s: net device is down.\n", __func__);\r\nreturn -EIO;\r\n}\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true ||\r\ncheck_fwstate(pmlmepriv, _FW_LINKED) == true ||\r\ncheck_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true) {\r\nDBG_871X("%s: device is busy.\n", __func__);\r\nrtw_scan_abort(padapter);\r\n}\r\nif (request == NULL) {\r\nDBG_871X("%s: invalid cfg80211_requests parameters.\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nret = rtw_android_cfg80211_pno_setup(dev, request->ssids,\r\nrequest->n_ssids, request->interval);\r\nif (ret < 0) {\r\nDBG_871X("%s ret: %d\n", __func__, ret);\r\ngoto exit;\r\n}\r\nret = rtw_android_pno_enable(dev, true);\r\nif (ret < 0) {\r\nDBG_871X("%s ret: %d\n", __func__, ret);\r\ngoto exit;\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int cfg80211_rtw_sched_scan_stop(struct wiphy *wiphy,\r\nstruct net_device *dev) {\r\nreturn rtw_android_pno_enable(dev, false);\r\n}\r\nstatic void rtw_cfg80211_init_ht_capab(struct ieee80211_sta_ht_cap *ht_cap, enum nl80211_band band, u8 rf_type)\r\n{\r\n#define MAX_BIT_RATE_40MHZ_MCS15 300\r\n#define MAX_BIT_RATE_40MHZ_MCS7 150\r\nht_cap->ht_supported = true;\r\nht_cap->cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |\r\nIEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_SGI_20 |\r\nIEEE80211_HT_CAP_DSSSCCK40 | IEEE80211_HT_CAP_MAX_AMSDU;\r\nht_cap->ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\r\nht_cap->ampdu_density = IEEE80211_HT_MPDU_DENSITY_16;\r\nht_cap->mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\r\nif (rf_type == RF_1T1R)\r\n{\r\nht_cap->mcs.rx_mask[0] = 0xFF;\r\nht_cap->mcs.rx_mask[1] = 0x00;\r\nht_cap->mcs.rx_mask[4] = 0x01;\r\nht_cap->mcs.rx_highest = cpu_to_le16(MAX_BIT_RATE_40MHZ_MCS7);\r\n}\r\nelse if ((rf_type == RF_1T2R) || (rf_type ==RF_2T2R))\r\n{\r\nht_cap->mcs.rx_mask[0] = 0xFF;\r\nht_cap->mcs.rx_mask[1] = 0xFF;\r\nht_cap->mcs.rx_mask[4] = 0x01;\r\nht_cap->mcs.rx_highest = cpu_to_le16(MAX_BIT_RATE_40MHZ_MCS15);\r\n}\r\nelse\r\n{\r\nDBG_8192C("%s, error rf_type =%d\n", __func__, rf_type);\r\n}\r\n}\r\nvoid rtw_cfg80211_init_wiphy(struct adapter *padapter)\r\n{\r\nu8 rf_type;\r\nstruct ieee80211_supported_band *bands;\r\nstruct wireless_dev *pwdev = padapter->rtw_wdev;\r\nstruct wiphy *wiphy = pwdev->wiphy;\r\nrtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));\r\nDBG_8192C("%s:rf_type =%d\n", __func__, rf_type);\r\n{\r\nbands = wiphy->bands[NL80211_BAND_2GHZ];\r\nif (bands)\r\nrtw_cfg80211_init_ht_capab(&bands->ht_cap, NL80211_BAND_2GHZ, rf_type);\r\n}\r\nrtw_regd_init(padapter, rtw_reg_notifier);\r\nmemcpy(wiphy->perm_addr, padapter->eeprompriv.mac_addr, ETH_ALEN);\r\n}\r\nstatic void rtw_cfg80211_preinit_wiphy(struct adapter *padapter, struct wiphy *wiphy)\r\n{\r\nwiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\r\nwiphy->max_scan_ssids = RTW_SSID_SCAN_AMOUNT;\r\nwiphy->max_scan_ie_len = RTW_SCAN_IE_LEN_MAX;\r\nwiphy->max_num_pmkids = RTW_MAX_NUM_PMKIDS;\r\nwiphy->max_remain_on_channel_duration = RTW_MAX_REMAIN_ON_CHANNEL_DURATION;\r\nwiphy->interface_modes = BIT(NL80211_IFTYPE_STATION)\r\n| BIT(NL80211_IFTYPE_ADHOC)\r\n| BIT(NL80211_IFTYPE_AP)\r\n| BIT(NL80211_IFTYPE_MONITOR)\r\n;\r\nwiphy->mgmt_stypes = rtw_cfg80211_default_mgmt_stypes;\r\nwiphy->software_iftypes |= BIT(NL80211_IFTYPE_MONITOR);\r\nwiphy->cipher_suites = rtw_cipher_suites;\r\nwiphy->n_cipher_suites = ARRAY_SIZE(rtw_cipher_suites);\r\nwiphy->bands[NL80211_BAND_2GHZ] = rtw_spt_band_alloc(NL80211_BAND_2GHZ);\r\nwiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;\r\nwiphy->flags |= WIPHY_FLAG_OFFCHAN_TX | WIPHY_FLAG_HAVE_AP_SME;\r\n#if defined(CONFIG_PM)\r\nwiphy->max_sched_scan_reqs = 1;\r\n#ifdef CONFIG_PNO_SUPPORT\r\nwiphy->max_sched_scan_ssids = MAX_PNO_LIST_COUNT;\r\n#endif\r\n#endif\r\n#if defined(CONFIG_PM)\r\nwiphy->wowlan = &wowlan_stub;\r\n#endif\r\nif (padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)\r\nwiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;\r\nelse\r\nwiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;\r\n}\r\nint rtw_wdev_alloc(struct adapter *padapter, struct device *dev)\r\n{\r\nint ret = 0;\r\nstruct wiphy *wiphy;\r\nstruct wireless_dev *wdev;\r\nstruct rtw_wdev_priv *pwdev_priv;\r\nstruct net_device *pnetdev = padapter->pnetdev;\r\nDBG_8192C("%s(padapter =%p)\n", __func__, padapter);\r\nwiphy = wiphy_new(&rtw_cfg80211_ops, sizeof(struct adapter *));\r\nif (!wiphy) {\r\nDBG_8192C("Couldn't allocate wiphy device\n");\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\nset_wiphy_dev(wiphy, dev);\r\n*((struct adapter **)wiphy_priv(wiphy)) = padapter;\r\nrtw_cfg80211_preinit_wiphy(padapter, wiphy);\r\nret = wiphy_register(wiphy);\r\nif (ret < 0) {\r\nDBG_8192C("Couldn't register wiphy device\n");\r\ngoto free_wiphy;\r\n}\r\nwdev = (struct wireless_dev *)rtw_zmalloc(sizeof(struct wireless_dev));\r\nif (!wdev) {\r\nDBG_8192C("Couldn't allocate wireless device\n");\r\nret = -ENOMEM;\r\ngoto unregister_wiphy;\r\n}\r\nwdev->wiphy = wiphy;\r\nwdev->netdev = pnetdev;\r\nwdev->iftype = NL80211_IFTYPE_STATION;\r\npadapter->rtw_wdev = wdev;\r\npnetdev->ieee80211_ptr = wdev;\r\npwdev_priv = adapter_wdev_data(padapter);\r\npwdev_priv->rtw_wdev = wdev;\r\npwdev_priv->pmon_ndev = NULL;\r\npwdev_priv->ifname_mon[0] = '\0';\r\npwdev_priv->padapter = padapter;\r\npwdev_priv->scan_request = NULL;\r\nspin_lock_init(&pwdev_priv->scan_req_lock);\r\npwdev_priv->p2p_enabled = false;\r\npwdev_priv->provdisc_req_issued = false;\r\nrtw_wdev_invit_info_init(&pwdev_priv->invit_info);\r\nrtw_wdev_nego_info_init(&pwdev_priv->nego_info);\r\npwdev_priv->bandroid_scan = false;\r\nif (padapter->registrypriv.power_mgnt != PS_MODE_ACTIVE)\r\npwdev_priv->power_mgmt = true;\r\nelse\r\npwdev_priv->power_mgmt = false;\r\nreturn ret;\r\nunregister_wiphy:\r\nwiphy_unregister(wiphy);\r\nfree_wiphy:\r\nwiphy_free(wiphy);\r\nexit:\r\nreturn ret;\r\n}\r\nvoid rtw_wdev_free(struct wireless_dev *wdev)\r\n{\r\nDBG_8192C("%s(wdev =%p)\n", __func__, wdev);\r\nif (!wdev)\r\nreturn;\r\nrtw_spt_band_free(wdev->wiphy->bands[NL80211_BAND_2GHZ]);\r\nwiphy_free(wdev->wiphy);\r\nkfree((u8 *)wdev);\r\n}\r\nvoid rtw_wdev_unregister(struct wireless_dev *wdev)\r\n{\r\nstruct net_device *ndev;\r\nstruct adapter *adapter;\r\nstruct rtw_wdev_priv *pwdev_priv;\r\nDBG_8192C("%s(wdev =%p)\n", __func__, wdev);\r\nif (!wdev)\r\nreturn;\r\nif (!(ndev = wdev_to_ndev(wdev)))\r\nreturn;\r\nadapter = (struct adapter *)rtw_netdev_priv(ndev);\r\npwdev_priv = adapter_wdev_data(adapter);\r\nrtw_cfg80211_indicate_scan_done(adapter, true);\r\nif (pwdev_priv->pmon_ndev) {\r\nDBG_8192C("%s, unregister monitor interface\n", __func__);\r\nunregister_netdev(pwdev_priv->pmon_ndev);\r\n}\r\nwiphy_unregister(wdev->wiphy);\r\n}
