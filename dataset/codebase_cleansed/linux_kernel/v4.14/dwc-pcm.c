static void dw_pcm_transfer(struct dw_i2s_dev *dev, bool push)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nbool active, period_elapsed;\r\nrcu_read_lock();\r\nif (push)\r\nsubstream = rcu_dereference(dev->tx_substream);\r\nelse\r\nsubstream = rcu_dereference(dev->rx_substream);\r\nactive = substream && snd_pcm_running(substream);\r\nif (active) {\r\nunsigned int ptr;\r\nunsigned int new_ptr;\r\nif (push) {\r\nptr = READ_ONCE(dev->tx_ptr);\r\nnew_ptr = dev->tx_fn(dev, substream->runtime, ptr,\r\n&period_elapsed);\r\ncmpxchg(&dev->tx_ptr, ptr, new_ptr);\r\n} else {\r\nptr = READ_ONCE(dev->rx_ptr);\r\nnew_ptr = dev->rx_fn(dev, substream->runtime, ptr,\r\n&period_elapsed);\r\ncmpxchg(&dev->rx_ptr, ptr, new_ptr);\r\n}\r\nif (period_elapsed)\r\nsnd_pcm_period_elapsed(substream);\r\n}\r\nrcu_read_unlock();\r\n}\r\nvoid dw_pcm_push_tx(struct dw_i2s_dev *dev)\r\n{\r\ndw_pcm_transfer(dev, true);\r\n}\r\nvoid dw_pcm_pop_rx(struct dw_i2s_dev *dev)\r\n{\r\ndw_pcm_transfer(dev, false);\r\n}\r\nstatic int dw_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nsnd_soc_set_runtime_hwparams(substream, &dw_pcm_hardware);\r\nsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\r\nruntime->private_data = dev;\r\nreturn 0;\r\n}\r\nstatic int dw_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nsynchronize_rcu();\r\nreturn 0;\r\n}\r\nstatic int dw_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct dw_i2s_dev *dev = runtime->private_data;\r\nint ret;\r\nswitch (params_channels(hw_params)) {\r\ncase 2:\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "invalid channels number\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (params_format(hw_params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\ndev->tx_fn = dw_pcm_tx_16;\r\ndev->rx_fn = dw_pcm_rx_16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\ndev->tx_fn = dw_pcm_tx_32;\r\ndev->rx_fn = dw_pcm_rx_32;\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "invalid format\n");\r\nreturn -EINVAL;\r\n}\r\nret = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int dw_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int dw_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct dw_i2s_dev *dev = runtime->private_data;\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nWRITE_ONCE(dev->tx_ptr, 0);\r\nrcu_assign_pointer(dev->tx_substream, substream);\r\n} else {\r\nWRITE_ONCE(dev->rx_ptr, 0);\r\nrcu_assign_pointer(dev->rx_substream, substream);\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nrcu_assign_pointer(dev->tx_substream, NULL);\r\nelse\r\nrcu_assign_pointer(dev->rx_substream, NULL);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic snd_pcm_uframes_t dw_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct dw_i2s_dev *dev = runtime->private_data;\r\nsnd_pcm_uframes_t pos;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\npos = READ_ONCE(dev->tx_ptr);\r\nelse\r\npos = READ_ONCE(dev->rx_ptr);\r\nreturn pos < runtime->buffer_size ? pos : 0;\r\n}\r\nstatic int dw_pcm_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nsize_t size = dw_pcm_hardware.buffer_bytes_max;\r\nreturn snd_pcm_lib_preallocate_pages_for_all(rtd->pcm,\r\nSNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL), size, size);\r\n}\r\nstatic void dw_pcm_free(struct snd_pcm *pcm)\r\n{\r\nsnd_pcm_lib_preallocate_free_for_all(pcm);\r\n}\r\nint dw_pcm_register(struct platform_device *pdev)\r\n{\r\nreturn devm_snd_soc_register_platform(&pdev->dev, &dw_pcm_platform);\r\n}
