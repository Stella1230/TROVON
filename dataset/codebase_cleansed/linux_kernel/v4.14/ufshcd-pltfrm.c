static int ufshcd_parse_clock_info(struct ufs_hba *hba)\r\n{\r\nint ret = 0;\r\nint cnt;\r\nint i;\r\nstruct device *dev = hba->dev;\r\nstruct device_node *np = dev->of_node;\r\nchar *name;\r\nu32 *clkfreq = NULL;\r\nstruct ufs_clk_info *clki;\r\nint len = 0;\r\nsize_t sz = 0;\r\nif (!np)\r\ngoto out;\r\ncnt = of_property_count_strings(np, "clock-names");\r\nif (!cnt || (cnt == -EINVAL)) {\r\ndev_info(dev, "%s: Unable to find clocks, assuming enabled\n",\r\n__func__);\r\n} else if (cnt < 0) {\r\ndev_err(dev, "%s: count clock strings failed, err %d\n",\r\n__func__, cnt);\r\nret = cnt;\r\n}\r\nif (cnt <= 0)\r\ngoto out;\r\nif (!of_get_property(np, "freq-table-hz", &len)) {\r\ndev_info(dev, "freq-table-hz property not specified\n");\r\ngoto out;\r\n}\r\nif (len <= 0)\r\ngoto out;\r\nsz = len / sizeof(*clkfreq);\r\nif (sz != 2 * cnt) {\r\ndev_err(dev, "%s len mismatch\n", "freq-table-hz");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nclkfreq = devm_kzalloc(dev, sz * sizeof(*clkfreq),\r\nGFP_KERNEL);\r\nif (!clkfreq) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = of_property_read_u32_array(np, "freq-table-hz",\r\nclkfreq, sz);\r\nif (ret && (ret != -EINVAL)) {\r\ndev_err(dev, "%s: error reading array %d\n",\r\n"freq-table-hz", ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < sz; i += 2) {\r\nret = of_property_read_string_index(np,\r\n"clock-names", i/2, (const char **)&name);\r\nif (ret)\r\ngoto out;\r\nclki = devm_kzalloc(dev, sizeof(*clki), GFP_KERNEL);\r\nif (!clki) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nclki->min_freq = clkfreq[i];\r\nclki->max_freq = clkfreq[i+1];\r\nclki->name = kstrdup(name, GFP_KERNEL);\r\ndev_dbg(dev, "%s: min %u max %u name %s\n", "freq-table-hz",\r\nclki->min_freq, clki->max_freq, clki->name);\r\nlist_add_tail(&clki->list, &hba->clk_list_head);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ufshcd_populate_vreg(struct device *dev, const char *name,\r\nstruct ufs_vreg **out_vreg)\r\n{\r\nint ret = 0;\r\nchar prop_name[MAX_PROP_SIZE];\r\nstruct ufs_vreg *vreg = NULL;\r\nstruct device_node *np = dev->of_node;\r\nif (!np) {\r\ndev_err(dev, "%s: non DT initialization\n", __func__);\r\ngoto out;\r\n}\r\nsnprintf(prop_name, MAX_PROP_SIZE, "%s-supply", name);\r\nif (!of_parse_phandle(np, prop_name, 0)) {\r\ndev_info(dev, "%s: Unable to find %s regulator, assuming enabled\n",\r\n__func__, prop_name);\r\ngoto out;\r\n}\r\nvreg = devm_kzalloc(dev, sizeof(*vreg), GFP_KERNEL);\r\nif (!vreg)\r\nreturn -ENOMEM;\r\nvreg->name = kstrdup(name, GFP_KERNEL);\r\nsnprintf(prop_name, MAX_PROP_SIZE, "%s-fixed-regulator", name);\r\nif (of_property_read_bool(np, prop_name))\r\ngoto out;\r\nsnprintf(prop_name, MAX_PROP_SIZE, "%s-max-microamp", name);\r\nret = of_property_read_u32(np, prop_name, &vreg->max_uA);\r\nif (ret) {\r\ndev_err(dev, "%s: unable to find %s err %d\n",\r\n__func__, prop_name, ret);\r\ngoto out;\r\n}\r\nvreg->min_uA = 0;\r\nif (!strcmp(name, "vcc")) {\r\nif (of_property_read_bool(np, "vcc-supply-1p8")) {\r\nvreg->min_uV = UFS_VREG_VCC_1P8_MIN_UV;\r\nvreg->max_uV = UFS_VREG_VCC_1P8_MAX_UV;\r\n} else {\r\nvreg->min_uV = UFS_VREG_VCC_MIN_UV;\r\nvreg->max_uV = UFS_VREG_VCC_MAX_UV;\r\n}\r\n} else if (!strcmp(name, "vccq")) {\r\nvreg->min_uV = UFS_VREG_VCCQ_MIN_UV;\r\nvreg->max_uV = UFS_VREG_VCCQ_MAX_UV;\r\n} else if (!strcmp(name, "vccq2")) {\r\nvreg->min_uV = UFS_VREG_VCCQ2_MIN_UV;\r\nvreg->max_uV = UFS_VREG_VCCQ2_MAX_UV;\r\n}\r\ngoto out;\r\nout:\r\nif (!ret)\r\n*out_vreg = vreg;\r\nreturn ret;\r\n}\r\nstatic int ufshcd_parse_regulator_info(struct ufs_hba *hba)\r\n{\r\nint err;\r\nstruct device *dev = hba->dev;\r\nstruct ufs_vreg_info *info = &hba->vreg_info;\r\nerr = ufshcd_populate_vreg(dev, "vdd-hba", &info->vdd_hba);\r\nif (err)\r\ngoto out;\r\nerr = ufshcd_populate_vreg(dev, "vcc", &info->vcc);\r\nif (err)\r\ngoto out;\r\nerr = ufshcd_populate_vreg(dev, "vccq", &info->vccq);\r\nif (err)\r\ngoto out;\r\nerr = ufshcd_populate_vreg(dev, "vccq2", &info->vccq2);\r\nout:\r\nreturn err;\r\n}\r\nint ufshcd_pltfrm_suspend(struct device *dev)\r\n{\r\nreturn ufshcd_system_suspend(dev_get_drvdata(dev));\r\n}\r\nint ufshcd_pltfrm_resume(struct device *dev)\r\n{\r\nreturn ufshcd_system_resume(dev_get_drvdata(dev));\r\n}\r\nint ufshcd_pltfrm_runtime_suspend(struct device *dev)\r\n{\r\nreturn ufshcd_runtime_suspend(dev_get_drvdata(dev));\r\n}\r\nint ufshcd_pltfrm_runtime_resume(struct device *dev)\r\n{\r\nreturn ufshcd_runtime_resume(dev_get_drvdata(dev));\r\n}\r\nint ufshcd_pltfrm_runtime_idle(struct device *dev)\r\n{\r\nreturn ufshcd_runtime_idle(dev_get_drvdata(dev));\r\n}\r\nvoid ufshcd_pltfrm_shutdown(struct platform_device *pdev)\r\n{\r\nufshcd_shutdown((struct ufs_hba *)platform_get_drvdata(pdev));\r\n}\r\nstatic void ufshcd_init_lanes_per_dir(struct ufs_hba *hba)\r\n{\r\nstruct device *dev = hba->dev;\r\nint ret;\r\nret = of_property_read_u32(dev->of_node, "lanes-per-direction",\r\n&hba->lanes_per_direction);\r\nif (ret) {\r\ndev_dbg(hba->dev,\r\n"%s: failed to read lanes-per-direction, ret=%d\n",\r\n__func__, ret);\r\nhba->lanes_per_direction = UFSHCD_DEFAULT_LANES_PER_DIRECTION;\r\n}\r\n}\r\nint ufshcd_pltfrm_init(struct platform_device *pdev,\r\nstruct ufs_hba_variant_ops *vops)\r\n{\r\nstruct ufs_hba *hba;\r\nvoid __iomem *mmio_base;\r\nstruct resource *mem_res;\r\nint irq, err;\r\nstruct device *dev = &pdev->dev;\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmmio_base = devm_ioremap_resource(dev, mem_res);\r\nif (IS_ERR(mmio_base)) {\r\nerr = PTR_ERR(mmio_base);\r\ngoto out;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "IRQ resource not available\n");\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nerr = ufshcd_alloc_host(dev, &hba);\r\nif (err) {\r\ndev_err(&pdev->dev, "Allocation failed\n");\r\ngoto out;\r\n}\r\nhba->vops = vops;\r\nerr = ufshcd_parse_clock_info(hba);\r\nif (err) {\r\ndev_err(&pdev->dev, "%s: clock parse failed %d\n",\r\n__func__, err);\r\ngoto dealloc_host;\r\n}\r\nerr = ufshcd_parse_regulator_info(hba);\r\nif (err) {\r\ndev_err(&pdev->dev, "%s: regulator init failed %d\n",\r\n__func__, err);\r\ngoto dealloc_host;\r\n}\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\nufshcd_init_lanes_per_dir(hba);\r\nerr = ufshcd_init(hba, mmio_base, irq);\r\nif (err) {\r\ndev_err(dev, "Initialization failed\n");\r\ngoto out_disable_rpm;\r\n}\r\nplatform_set_drvdata(pdev, hba);\r\nreturn 0;\r\nout_disable_rpm:\r\npm_runtime_disable(&pdev->dev);\r\npm_runtime_set_suspended(&pdev->dev);\r\ndealloc_host:\r\nufshcd_dealloc_host(hba);\r\nout:\r\nreturn err;\r\n}
