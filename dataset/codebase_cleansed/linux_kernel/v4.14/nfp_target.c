static int target_rw(u32 cpp_id, int pp, int start, int len)\r\n{\r\nswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\r\nAT(0, 0, 0, pp);\r\nAT(1, 0, pp, 0);\r\nAT(NFP_CPP_ACTION_RW, 0, pp, pp);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int nfp6000_nbi_dma(u32 cpp_id)\r\n{\r\nswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\r\nAT(0, 0, 0, P64);\r\nAT(1, 0, P64, 0);\r\nAT(NFP_CPP_ACTION_RW, 0, P64, P64);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int nfp6000_nbi_stats(u32 cpp_id)\r\n{\r\nswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\r\nAT(0, 0, 0, P32);\r\nAT(1, 0, P32, 0);\r\nAT(NFP_CPP_ACTION_RW, 0, P32, P32);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int nfp6000_nbi_tm(u32 cpp_id)\r\n{\r\nswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\r\nAT(0, 0, 0, P64);\r\nAT(1, 0, P64, 0);\r\nAT(NFP_CPP_ACTION_RW, 0, P64, P64);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int nfp6000_nbi_ppc(u32 cpp_id)\r\n{\r\nswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\r\nAT(0, 0, 0, P64);\r\nAT(1, 0, P64, 0);\r\nAT(NFP_CPP_ACTION_RW, 0, P64, P64);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int nfp6000_nbi(u32 cpp_id, u64 address)\r\n{\r\nu64 rel_addr = address & 0x3fFFFF;\r\nif (rel_addr < (1 << 20))\r\nreturn nfp6000_nbi_dma(cpp_id);\r\nif (rel_addr < (2 << 20))\r\nreturn nfp6000_nbi_stats(cpp_id);\r\nif (rel_addr < (3 << 20))\r\nreturn nfp6000_nbi_tm(cpp_id);\r\nreturn nfp6000_nbi_ppc(cpp_id);\r\n}\r\nstatic int nfp6000_mu_common(u32 cpp_id)\r\n{\r\nswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\r\nAT(NFP_CPP_ACTION_RW, 0, P64, P64);\r\nAT(NFP_CPP_ACTION_RW, 1, P64, P64);\r\nAT(NFP_CPP_ACTION_RW, 2, P64, P64);\r\nAT(NFP_CPP_ACTION_RW, 3, P64, P64);\r\nAT(0, 0, 0, P64);\r\nAT(0, 1, 0, P64);\r\nAT(0, 2, 0, P64);\r\nAT(0, 3, 0, P64);\r\nAT(1, 0, P64, 0);\r\nAT(1, 1, P64, 0);\r\nAT(1, 2, P64, 0);\r\nAT(1, 3, P64, 0);\r\nAT(3, 0, 0, P32);\r\nAT(3, 2, P32, 0);\r\nAT(4, 0, P32, 0);\r\nAT(4, 2, 0, 0);\r\nAT(4, 3, 0, P32);\r\nAT(5, 0, P32, 0);\r\nAT(5, 3, 0, P32);\r\nAT(6, 0, P32, 0);\r\nAT(6, 3, 0, P32);\r\nAT(7, 0, P32, 0);\r\nAT(7, 3, 0, P32);\r\nAT(8, 0, P32, 0);\r\nAT(8, 3, 0, P32);\r\nAT(9, 0, P32, 0);\r\nAT(9, 3, 0, P32);\r\nAT(10, 0, P32, 0);\r\nAT(10, 3, 0, P32);\r\nAT(13, 0, 0, P32);\r\nAT(13, 1, 0, P32);\r\nAT(13, 2, P32, 0);\r\nAT(15, 0, P32, 0);\r\nAT(15, 3, 0, P32);\r\nAT(28, 0, 0, P32);\r\nAT(28, 1, 0, P32);\r\nAT(28, 2, 0, P32);\r\nAT(28, 3, 0, P32);\r\nAT(31, 0, P32, 0);\r\nAT(31, 1, P32, 0);\r\nAT(31, 2, P32, 0);\r\nAT(31, 3, P32, 0);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int nfp6000_mu_ctm(u32 cpp_id)\r\n{\r\nswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\r\nAT(16, 1, 0, P32);\r\nAT(17, 1, 0, P32);\r\nAT(17, 3, 0, P64);\r\nAT(18, 2, 0, P64);\r\nAT(18, 3, 0, P64);\r\nAT(21, 0, 0, P64);\r\nAT(21, 1, 0, P64);\r\nAT(21, 2, 0, P64);\r\nAT(21, 3, 0, P64);\r\ndefault:\r\nreturn nfp6000_mu_common(cpp_id);\r\n}\r\n}\r\nstatic int nfp6000_mu_emu(u32 cpp_id)\r\n{\r\nswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\r\nAT(18, 0, 0, P32);\r\nAT(18, 1, 0, P32);\r\nAT(18, 2, P32, 0);\r\nAT(18, 3, P32, 0);\r\nAT(20, 2, P32, 0);\r\nAT(21, 0, 0, P32);\r\nAT(21, 1, 0, P32);\r\nAT(21, 2, 0, P32);\r\nAT(22, 0, 0, P32);\r\nAT(22, 1, 0, P32);\r\nAT(22, 2, 0, P32);\r\ndefault:\r\nreturn nfp6000_mu_common(cpp_id);\r\n}\r\n}\r\nstatic int nfp6000_mu_imu(u32 cpp_id)\r\n{\r\nreturn nfp6000_mu_common(cpp_id);\r\n}\r\nstatic int nfp6000_mu(u32 cpp_id, u64 address)\r\n{\r\nint pp;\r\nif (address < 0x2000000000ULL)\r\npp = nfp6000_mu_ctm(cpp_id);\r\nelse if (address < 0x8000000000ULL)\r\npp = nfp6000_mu_emu(cpp_id);\r\nelse if (address < 0x9800000000ULL)\r\npp = nfp6000_mu_ctm(cpp_id);\r\nelse if (address < 0x9C00000000ULL)\r\npp = nfp6000_mu_emu(cpp_id);\r\nelse if (address < 0xA000000000ULL)\r\npp = nfp6000_mu_imu(cpp_id);\r\nelse\r\npp = nfp6000_mu_ctm(cpp_id);\r\nreturn pp;\r\n}\r\nstatic int nfp6000_ila(u32 cpp_id)\r\n{\r\nswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\r\nAT(0, 1, 0, P32);\r\nAT(2, 0, 0, P32);\r\nAT(3, 0, P32, 0);\r\ndefault:\r\nreturn target_rw(cpp_id, P32, 48, 4);\r\n}\r\n}\r\nstatic int nfp6000_pci(u32 cpp_id)\r\n{\r\nswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\r\nAT(2, 0, 0, P32);\r\nAT(3, 0, P32, 0);\r\ndefault:\r\nreturn target_rw(cpp_id, P32, 4, 4);\r\n}\r\n}\r\nstatic int nfp6000_crypto(u32 cpp_id)\r\n{\r\nswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\r\nAT(2, 0, P64, 0);\r\ndefault:\r\nreturn target_rw(cpp_id, P64, 12, 4);\r\n}\r\n}\r\nstatic int nfp6000_cap_xpb(u32 cpp_id)\r\n{\r\nswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\r\nAT(0, 1, 0, P32);\r\nAT(0, 2, P32, 0);\r\nAT(1, 1, P32, 0);\r\nAT(1, 2, P32, 0);\r\nAT(2, 0, 0, P32);\r\nAT(2, 1, 0, P32);\r\nAT(2, 2, 0, P32);\r\nAT(2, 3, 0, P32);\r\nAT(3, 0, P32, 0);\r\nAT(3, 1, P32, 0);\r\nAT(3, 2, P32, 0);\r\nAT(3, 3, P32, 0);\r\nAT(NFP_CPP_ACTION_RW, 1, P32, P32);\r\ndefault:\r\nreturn target_rw(cpp_id, P32, 1, 63);\r\n}\r\n}\r\nstatic int nfp6000_cls(u32 cpp_id)\r\n{\r\nswitch (cpp_id & NFP_CPP_ID(0, ~0, ~0)) {\r\nAT(0, 3, P32, 0);\r\nAT(2, 0, P32, 0);\r\nAT(2, 1, P32, 0);\r\nAT(4, 0, P32, 0);\r\nAT(4, 1, P32, 0);\r\nAT(6, 0, P32, 0);\r\nAT(6, 1, P32, 0);\r\nAT(6, 2, P32, 0);\r\nAT(8, 2, P32, 0);\r\nAT(8, 3, P32, 0);\r\nAT(9, 0, 0, P32);\r\nAT(9, 1, 0, P32);\r\nAT(9, 2, 0, P32);\r\nAT(9, 3, 0, P32);\r\nAT(10, 0, P32, 0);\r\nAT(10, 2, P32, 0);\r\nAT(14, 0, P32, 0);\r\nAT(15, 1, 0, P32);\r\nAT(17, 2, P32, 0);\r\nAT(24, 0, 0, P32);\r\nAT(24, 1, P32, 0);\r\nAT(25, 0, 0, P32);\r\nAT(25, 1, P32, 0);\r\ndefault:\r\nreturn target_rw(cpp_id, P32, 0, 64);\r\n}\r\n}\r\nint nfp_target_pushpull(u32 cpp_id, u64 address)\r\n{\r\nswitch (NFP_CPP_ID_TARGET_of(cpp_id)) {\r\ncase NFP_CPP_TARGET_NBI:\r\nreturn nfp6000_nbi(cpp_id, address);\r\ncase NFP_CPP_TARGET_QDR:\r\nreturn target_rw(cpp_id, P32, 24, 4);\r\ncase NFP_CPP_TARGET_ILA:\r\nreturn nfp6000_ila(cpp_id);\r\ncase NFP_CPP_TARGET_MU:\r\nreturn nfp6000_mu(cpp_id, address);\r\ncase NFP_CPP_TARGET_PCIE:\r\nreturn nfp6000_pci(cpp_id);\r\ncase NFP_CPP_TARGET_ARM:\r\nif (address < 0x10000)\r\nreturn target_rw(cpp_id, P64, 1, 1);\r\nelse\r\nreturn target_rw(cpp_id, P32, 1, 1);\r\ncase NFP_CPP_TARGET_CRYPTO:\r\nreturn nfp6000_crypto(cpp_id);\r\ncase NFP_CPP_TARGET_CT_XPB:\r\nreturn nfp6000_cap_xpb(cpp_id);\r\ncase NFP_CPP_TARGET_CLS:\r\nreturn nfp6000_cls(cpp_id);\r\ncase 0:\r\nreturn target_rw(cpp_id, P32, 4, 4);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int nfp_decode_basic(u64 addr, int *dest_island, int cpp_tgt,\r\nint mode, bool addr40, int isld1, int isld0)\r\n{\r\nint iid_lsb, idx_lsb;\r\nif (cpp_tgt == NFP_CPP_TARGET_MU || cpp_tgt == NFP_CPP_TARGET_CT_XPB)\r\nreturn -EINVAL;\r\nswitch (mode) {\r\ncase 0:\r\niid_lsb = addr40 ? 34 : 26;\r\n*dest_island = (addr >> iid_lsb) & 0x3F;\r\nreturn 0;\r\ncase 1:\r\nidx_lsb = addr40 ? 39 : 31;\r\nif (addr & BIT_ULL(idx_lsb))\r\n*dest_island = isld1;\r\nelse\r\n*dest_island = isld0;\r\nreturn 0;\r\ncase 2:\r\nisld0 &= ~1;\r\nisld1 &= ~1;\r\nidx_lsb = addr40 ? 39 : 31;\r\niid_lsb = idx_lsb - 1;\r\nif (addr & BIT_ULL(idx_lsb))\r\n*dest_island = isld1 | (int)((addr >> iid_lsb) & 1);\r\nelse\r\n*dest_island = isld0 | (int)((addr >> iid_lsb) & 1);\r\nreturn 0;\r\ncase 3:\r\nisld0 &= ~3;\r\nisld1 &= ~3;\r\nidx_lsb = addr40 ? 39 : 31;\r\niid_lsb = idx_lsb - 2;\r\nif (addr & BIT_ULL(idx_lsb))\r\n*dest_island = isld1 | (int)((addr >> iid_lsb) & 3);\r\nelse\r\n*dest_island = isld0 | (int)((addr >> iid_lsb) & 3);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int nfp_encode_basic_qdr(u64 addr, int dest_island, int cpp_tgt,\r\nint mode, bool addr40, int isld1, int isld0)\r\n{\r\nint v, ret;\r\nret = nfp_decode_basic(addr, &v, cpp_tgt, mode, addr40, isld1, isld0);\r\nif (ret)\r\nreturn ret;\r\nif (dest_island != -1 && dest_island != v)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int nfp_encode_basic_search(u64 *addr, int dest_island, int *isld,\r\nint iid_lsb, int idx_lsb, int v_max)\r\n{\r\nint i, v;\r\nfor (i = 0; i < 2; i++)\r\nfor (v = 0; v < v_max; v++) {\r\nif (dest_island != (isld[i] | v))\r\ncontinue;\r\n*addr &= ~GENMASK_ULL(idx_lsb, iid_lsb);\r\n*addr |= ((u64)i << idx_lsb);\r\n*addr |= ((u64)v << iid_lsb);\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int nfp_encode_basic(u64 *addr, int dest_island, int cpp_tgt,\r\nint mode, bool addr40, int isld1, int isld0)\r\n{\r\nint iid_lsb, idx_lsb;\r\nint isld[2];\r\nu64 v64;\r\nisld[0] = isld0;\r\nisld[1] = isld1;\r\nif (cpp_tgt == NFP_CPP_TARGET_MU || cpp_tgt == NFP_CPP_TARGET_CT_XPB)\r\nreturn -EINVAL;\r\nswitch (mode) {\r\ncase 0:\r\nif (cpp_tgt == NFP_CPP_TARGET_QDR && !addr40)\r\nreturn nfp_encode_basic_qdr(*addr, cpp_tgt, dest_island,\r\nmode, addr40, isld1, isld0);\r\niid_lsb = addr40 ? 34 : 26;\r\nv64 = GENMASK_ULL(iid_lsb + 5, iid_lsb);\r\n*addr &= ~v64;\r\n*addr |= ((u64)dest_island << iid_lsb) & v64;\r\nreturn 0;\r\ncase 1:\r\nif (cpp_tgt == NFP_CPP_TARGET_QDR && !addr40)\r\nreturn nfp_encode_basic_qdr(*addr, cpp_tgt, dest_island,\r\nmode, addr40, isld1, isld0);\r\nidx_lsb = addr40 ? 39 : 31;\r\nif (dest_island == isld0) {\r\n*addr &= ~BIT_ULL(idx_lsb);\r\nreturn 0;\r\n}\r\nif (dest_island == isld1) {\r\n*addr |= BIT_ULL(idx_lsb);\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\ncase 2:\r\nif (cpp_tgt == NFP_CPP_TARGET_QDR && !addr40)\r\nreturn nfp_encode_basic_qdr(*addr, cpp_tgt, dest_island,\r\nmode, addr40, isld1, isld0);\r\nisld[0] &= ~1;\r\nisld[1] &= ~1;\r\nidx_lsb = addr40 ? 39 : 31;\r\niid_lsb = idx_lsb - 1;\r\nreturn nfp_encode_basic_search(addr, dest_island, isld,\r\niid_lsb, idx_lsb, 2);\r\ncase 3:\r\nif (cpp_tgt == NFP_CPP_TARGET_QDR && !addr40)\r\nreturn nfp_encode_basic_qdr(*addr, cpp_tgt, dest_island,\r\nmode, addr40, isld1, isld0);\r\nisld[0] &= ~3;\r\nisld[1] &= ~3;\r\nidx_lsb = addr40 ? 39 : 31;\r\niid_lsb = idx_lsb - 2;\r\nreturn nfp_encode_basic_search(addr, dest_island, isld,\r\niid_lsb, idx_lsb, 4);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int nfp_encode_mu(u64 *addr, int dest_island, int mode,\r\nbool addr40, int isld1, int isld0)\r\n{\r\nint iid_lsb, idx_lsb, locality_lsb;\r\nint isld[2];\r\nu64 v64;\r\nint da;\r\nisld[0] = isld0;\r\nisld[1] = isld1;\r\nlocality_lsb = nfp_cppat_mu_locality_lsb(mode, addr40);\r\nif (((*addr >> locality_lsb) & 3) == _NIC_NFP6000_MU_LOCALITY_DIRECT)\r\nda = 1;\r\nelse\r\nda = 0;\r\nswitch (mode) {\r\ncase 0:\r\niid_lsb = addr40 ? 32 : 24;\r\nv64 = GENMASK_ULL(iid_lsb + 5, iid_lsb);\r\n*addr &= ~v64;\r\n*addr |= (((u64)dest_island) << iid_lsb) & v64;\r\nreturn 0;\r\ncase 1:\r\nif (da) {\r\niid_lsb = addr40 ? 32 : 24;\r\nv64 = GENMASK_ULL(iid_lsb + 5, iid_lsb);\r\n*addr &= ~v64;\r\n*addr |= (((u64)dest_island) << iid_lsb) & v64;\r\nreturn 0;\r\n}\r\nidx_lsb = addr40 ? 37 : 29;\r\nif (dest_island == isld0) {\r\n*addr &= ~BIT_ULL(idx_lsb);\r\nreturn 0;\r\n}\r\nif (dest_island == isld1) {\r\n*addr |= BIT_ULL(idx_lsb);\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\ncase 2:\r\nif (da) {\r\niid_lsb = addr40 ? 32 : 24;\r\nv64 = GENMASK_ULL(iid_lsb + 5, iid_lsb);\r\n*addr &= ~v64;\r\n*addr |= (((u64)dest_island) << iid_lsb) & v64;\r\nreturn 0;\r\n}\r\nisld[0] &= ~1;\r\nisld[1] &= ~1;\r\nidx_lsb = addr40 ? 37 : 29;\r\niid_lsb = idx_lsb - 1;\r\nreturn nfp_encode_basic_search(addr, dest_island, isld,\r\niid_lsb, idx_lsb, 2);\r\ncase 3:\r\nif (dest_island > 0 && (dest_island < 24 || dest_island > 26)) {\r\n*addr |= ((u64)_NIC_NFP6000_MU_LOCALITY_DIRECT)\r\n<< locality_lsb;\r\nda = 1;\r\n}\r\nif (da) {\r\niid_lsb = addr40 ? 32 : 24;\r\nv64 = GENMASK_ULL(iid_lsb + 5, iid_lsb);\r\n*addr &= ~v64;\r\n*addr |= (((u64)dest_island) << iid_lsb) & v64;\r\nreturn 0;\r\n}\r\nisld[0] &= ~3;\r\nisld[1] &= ~3;\r\nidx_lsb = addr40 ? 37 : 29;\r\niid_lsb = idx_lsb - 2;\r\nreturn nfp_encode_basic_search(addr, dest_island, isld,\r\niid_lsb, idx_lsb, 4);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int nfp_cppat_addr_encode(u64 *addr, int dest_island, int cpp_tgt,\r\nint mode, bool addr40, int isld1, int isld0)\r\n{\r\nswitch (cpp_tgt) {\r\ncase NFP_CPP_TARGET_NBI:\r\ncase NFP_CPP_TARGET_QDR:\r\ncase NFP_CPP_TARGET_ILA:\r\ncase NFP_CPP_TARGET_PCIE:\r\ncase NFP_CPP_TARGET_ARM:\r\ncase NFP_CPP_TARGET_CRYPTO:\r\ncase NFP_CPP_TARGET_CLS:\r\nreturn nfp_encode_basic(addr, dest_island, cpp_tgt, mode,\r\naddr40, isld1, isld0);\r\ncase NFP_CPP_TARGET_MU:\r\nreturn nfp_encode_mu(addr, dest_island, mode,\r\naddr40, isld1, isld0);\r\ncase NFP_CPP_TARGET_CT_XPB:\r\nif (mode != 1 || addr40)\r\nreturn -EINVAL;\r\n*addr &= ~GENMASK_ULL(29, 24);\r\n*addr |= ((u64)dest_island << 24) & GENMASK_ULL(29, 24);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint nfp_target_cpp(u32 cpp_island_id, u64 cpp_island_address,\r\nu32 *cpp_target_id, u64 *cpp_target_address,\r\nconst u32 *imb_table)\r\n{\r\nconst int island = NFP_CPP_ID_ISLAND_of(cpp_island_id);\r\nconst int target = NFP_CPP_ID_TARGET_of(cpp_island_id);\r\nu32 imb;\r\nint err;\r\nif (target < 0 || target >= 16)\r\nreturn -EINVAL;\r\nif (island == 0) {\r\n*cpp_target_id = cpp_island_id;\r\n*cpp_target_address = cpp_island_address;\r\nreturn 0;\r\n}\r\nif (!imb_table)\r\nreturn -EINVAL;\r\nimb = imb_table[target];\r\n*cpp_target_address = cpp_island_address;\r\nerr = nfp_cppat_addr_encode(cpp_target_address, island, target,\r\n((imb >> 13) & 7), ((imb >> 12) & 1),\r\n((imb >> 6) & 0x3f), ((imb >> 0) & 0x3f));\r\nif (err)\r\nreturn err;\r\n*cpp_target_id = NFP_CPP_ID(target,\r\nNFP_CPP_ID_ACTION_of(cpp_island_id),\r\nNFP_CPP_ID_TOKEN_of(cpp_island_id));\r\nreturn 0;\r\n}
