static void amd_nb_smu_index_read(struct pci_dev *pdev, unsigned int devfn,\r\nint offset, u32 *val)\r\n{\r\nmutex_lock(&nb_smu_ind_mutex);\r\npci_bus_write_config_dword(pdev->bus, devfn,\r\n0xb8, offset);\r\npci_bus_read_config_dword(pdev->bus, devfn,\r\n0xbc, val);\r\nmutex_unlock(&nb_smu_ind_mutex);\r\n}\r\nstatic ssize_t temp1_input_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu32 regval;\r\nstruct pci_dev *pdev = dev_get_drvdata(dev);\r\nif (boot_cpu_data.x86 == 0x15 && boot_cpu_data.x86_model == 0x60) {\r\namd_nb_smu_index_read(pdev, PCI_DEVFN(0, 0),\r\nF15H_M60H_REPORTED_TEMP_CTRL_OFFSET,\r\n&regval);\r\n} else {\r\npci_read_config_dword(pdev, REG_REPORTED_TEMPERATURE, &regval);\r\n}\r\nreturn sprintf(buf, "%u\n", (regval >> 21) * 125);\r\n}\r\nstatic ssize_t temp1_max_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", 70 * 1000);\r\n}\r\nstatic ssize_t show_temp_crit(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint show_hyst = attr->index;\r\nu32 regval;\r\nint value;\r\npci_read_config_dword(dev_get_drvdata(dev),\r\nREG_HARDWARE_THERMAL_CONTROL, &regval);\r\nvalue = ((regval >> 16) & 0x7f) * 500 + 52000;\r\nif (show_hyst)\r\nvalue -= ((regval >> 24) & 0xf) * 500;\r\nreturn sprintf(buf, "%d\n", value);\r\n}\r\nstatic umode_t k10temp_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int index)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct pci_dev *pdev = dev_get_drvdata(dev);\r\nif (index >= 2) {\r\nu32 reg_caps, reg_htc;\r\npci_read_config_dword(pdev, REG_NORTHBRIDGE_CAPABILITIES,\r\n&reg_caps);\r\npci_read_config_dword(pdev, REG_HARDWARE_THERMAL_CONTROL,\r\n&reg_htc);\r\nif (!(reg_caps & NB_CAP_HTC) || !(reg_htc & HTC_ENABLE))\r\nreturn 0;\r\n}\r\nreturn attr->mode;\r\n}\r\nstatic bool has_erratum_319(struct pci_dev *pdev)\r\n{\r\nu32 pkg_type, reg_dram_cfg;\r\nif (boot_cpu_data.x86 != 0x10)\r\nreturn false;\r\npkg_type = cpuid_ebx(0x80000001) & CPUID_PKGTYPE_MASK;\r\nif (pkg_type == CPUID_PKGTYPE_F)\r\nreturn true;\r\nif (pkg_type != CPUID_PKGTYPE_AM2R2_AM3)\r\nreturn false;\r\npci_bus_read_config_dword(pdev->bus,\r\nPCI_DEVFN(PCI_SLOT(pdev->devfn), 2),\r\nREG_DCT0_CONFIG_HIGH, &reg_dram_cfg);\r\nif (reg_dram_cfg & DDR3_MODE)\r\nreturn false;\r\nreturn boot_cpu_data.x86_model < 4 ||\r\n(boot_cpu_data.x86_model == 4 && boot_cpu_data.x86_mask <= 2);\r\n}\r\nstatic int k10temp_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nint unreliable = has_erratum_319(pdev);\r\nstruct device *dev = &pdev->dev;\r\nstruct device *hwmon_dev;\r\nif (unreliable) {\r\nif (!force) {\r\ndev_err(dev,\r\n"unreliable CPU thermal sensor; monitoring disabled\n");\r\nreturn -ENODEV;\r\n}\r\ndev_warn(dev,\r\n"unreliable CPU thermal sensor; check erratum 319\n");\r\n}\r\nhwmon_dev = devm_hwmon_device_register_with_groups(dev, "k10temp", pdev,\r\nk10temp_groups);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
