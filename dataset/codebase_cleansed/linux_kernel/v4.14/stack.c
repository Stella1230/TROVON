static inline void\r\n_queue_message(struct mISDNstack *st, struct sk_buff *skb)\r\n{\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nif (*debug & DEBUG_QUEUE_FUNC)\r\nprintk(KERN_DEBUG "%s prim(%x) id(%x) %p\n",\r\n__func__, hh->prim, hh->id, skb);\r\nskb_queue_tail(&st->msgq, skb);\r\nif (likely(!test_bit(mISDN_STACK_STOPPED, &st->status))) {\r\ntest_and_set_bit(mISDN_STACK_WORK, &st->status);\r\nwake_up_interruptible(&st->workq);\r\n}\r\n}\r\nstatic int\r\nmISDN_queue_message(struct mISDNchannel *ch, struct sk_buff *skb)\r\n{\r\n_queue_message(ch->st, skb);\r\nreturn 0;\r\n}\r\nstatic struct mISDNchannel *\r\nget_channel4id(struct mISDNstack *st, u_int id)\r\n{\r\nstruct mISDNchannel *ch;\r\nmutex_lock(&st->lmutex);\r\nlist_for_each_entry(ch, &st->layer2, list) {\r\nif (id == ch->nr)\r\ngoto unlock;\r\n}\r\nch = NULL;\r\nunlock:\r\nmutex_unlock(&st->lmutex);\r\nreturn ch;\r\n}\r\nstatic void\r\nsend_socklist(struct mISDN_sock_list *sl, struct sk_buff *skb)\r\n{\r\nstruct sock *sk;\r\nstruct sk_buff *cskb = NULL;\r\nread_lock(&sl->lock);\r\nsk_for_each(sk, &sl->head) {\r\nif (sk->sk_state != MISDN_BOUND)\r\ncontinue;\r\nif (!cskb)\r\ncskb = skb_copy(skb, GFP_ATOMIC);\r\nif (!cskb) {\r\nprintk(KERN_WARNING "%s no skb\n", __func__);\r\nbreak;\r\n}\r\nif (!sock_queue_rcv_skb(sk, cskb))\r\ncskb = NULL;\r\n}\r\nread_unlock(&sl->lock);\r\nif (cskb)\r\ndev_kfree_skb(cskb);\r\n}\r\nstatic void\r\nsend_layer2(struct mISDNstack *st, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *cskb;\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nstruct mISDNchannel *ch;\r\nint ret;\r\nif (!st)\r\nreturn;\r\nmutex_lock(&st->lmutex);\r\nif ((hh->id & MISDN_ID_ADDR_MASK) == MISDN_ID_ANY) {\r\nlist_for_each_entry(ch, &st->layer2, list) {\r\nif (list_is_last(&ch->list, &st->layer2)) {\r\ncskb = skb;\r\nskb = NULL;\r\n} else {\r\ncskb = skb_copy(skb, GFP_KERNEL);\r\n}\r\nif (cskb) {\r\nret = ch->send(ch, cskb);\r\nif (ret) {\r\nif (*debug & DEBUG_SEND_ERR)\r\nprintk(KERN_DEBUG\r\n"%s ch%d prim(%x) addr(%x)"\r\n" err %d\n",\r\n__func__, ch->nr,\r\nhh->prim, ch->addr, ret);\r\ndev_kfree_skb(cskb);\r\n}\r\n} else {\r\nprintk(KERN_WARNING "%s ch%d addr %x no mem\n",\r\n__func__, ch->nr, ch->addr);\r\ngoto out;\r\n}\r\n}\r\n} else {\r\nlist_for_each_entry(ch, &st->layer2, list) {\r\nif ((hh->id & MISDN_ID_ADDR_MASK) == ch->addr) {\r\nret = ch->send(ch, skb);\r\nif (!ret)\r\nskb = NULL;\r\ngoto out;\r\n}\r\n}\r\nret = st->dev->teimgr->ctrl(st->dev->teimgr, CHECK_DATA, skb);\r\nif (!ret)\r\nskb = NULL;\r\nelse if (*debug & DEBUG_SEND_ERR)\r\nprintk(KERN_DEBUG\r\n"%s mgr prim(%x) err %d\n",\r\n__func__, hh->prim, ret);\r\n}\r\nout:\r\nmutex_unlock(&st->lmutex);\r\nif (skb)\r\ndev_kfree_skb(skb);\r\n}\r\nstatic inline int\r\nsend_msg_to_layer(struct mISDNstack *st, struct sk_buff *skb)\r\n{\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nstruct mISDNchannel *ch;\r\nint lm;\r\nlm = hh->prim & MISDN_LAYERMASK;\r\nif (*debug & DEBUG_QUEUE_FUNC)\r\nprintk(KERN_DEBUG "%s prim(%x) id(%x) %p\n",\r\n__func__, hh->prim, hh->id, skb);\r\nif (lm == 0x1) {\r\nif (!hlist_empty(&st->l1sock.head)) {\r\n__net_timestamp(skb);\r\nsend_socklist(&st->l1sock, skb);\r\n}\r\nreturn st->layer1->send(st->layer1, skb);\r\n} else if (lm == 0x2) {\r\nif (!hlist_empty(&st->l1sock.head))\r\nsend_socklist(&st->l1sock, skb);\r\nsend_layer2(st, skb);\r\nreturn 0;\r\n} else if (lm == 0x4) {\r\nch = get_channel4id(st, hh->id);\r\nif (ch)\r\nreturn ch->send(ch, skb);\r\nelse\r\nprintk(KERN_WARNING\r\n"%s: dev(%s) prim(%x) id(%x) no channel\n",\r\n__func__, dev_name(&st->dev->dev), hh->prim,\r\nhh->id);\r\n} else if (lm == 0x8) {\r\nWARN_ON(lm == 0x8);\r\nch = get_channel4id(st, hh->id);\r\nif (ch)\r\nreturn ch->send(ch, skb);\r\nelse\r\nprintk(KERN_WARNING\r\n"%s: dev(%s) prim(%x) id(%x) no channel\n",\r\n__func__, dev_name(&st->dev->dev), hh->prim,\r\nhh->id);\r\n} else {\r\nprintk(KERN_WARNING "%s: dev(%s) prim %x not delivered\n",\r\n__func__, dev_name(&st->dev->dev), hh->prim);\r\n}\r\nreturn -ESRCH;\r\n}\r\nstatic void\r\ndo_clear_stack(struct mISDNstack *st)\r\n{\r\n}\r\nstatic int\r\nmISDNStackd(void *data)\r\n{\r\nstruct mISDNstack *st = data;\r\n#ifdef MISDN_MSG_STATS\r\nu64 utime, stime;\r\n#endif\r\nint err = 0;\r\nsigfillset(&current->blocked);\r\nif (*debug & DEBUG_MSG_THREAD)\r\nprintk(KERN_DEBUG "mISDNStackd %s started\n",\r\ndev_name(&st->dev->dev));\r\nif (st->notify != NULL) {\r\ncomplete(st->notify);\r\nst->notify = NULL;\r\n}\r\nfor (;;) {\r\nstruct sk_buff *skb;\r\nif (unlikely(test_bit(mISDN_STACK_STOPPED, &st->status))) {\r\ntest_and_clear_bit(mISDN_STACK_WORK, &st->status);\r\ntest_and_clear_bit(mISDN_STACK_RUNNING, &st->status);\r\n} else\r\ntest_and_set_bit(mISDN_STACK_RUNNING, &st->status);\r\nwhile (test_bit(mISDN_STACK_WORK, &st->status)) {\r\nskb = skb_dequeue(&st->msgq);\r\nif (!skb) {\r\ntest_and_clear_bit(mISDN_STACK_WORK,\r\n&st->status);\r\nskb = skb_dequeue(&st->msgq);\r\nif (!skb)\r\ncontinue;\r\ntest_and_set_bit(mISDN_STACK_WORK,\r\n&st->status);\r\n}\r\n#ifdef MISDN_MSG_STATS\r\nst->msg_cnt++;\r\n#endif\r\nerr = send_msg_to_layer(st, skb);\r\nif (unlikely(err)) {\r\nif (*debug & DEBUG_SEND_ERR)\r\nprintk(KERN_DEBUG\r\n"%s: %s prim(%x) id(%x) "\r\n"send call(%d)\n",\r\n__func__, dev_name(&st->dev->dev),\r\nmISDN_HEAD_PRIM(skb),\r\nmISDN_HEAD_ID(skb), err);\r\ndev_kfree_skb(skb);\r\ncontinue;\r\n}\r\nif (unlikely(test_bit(mISDN_STACK_STOPPED,\r\n&st->status))) {\r\ntest_and_clear_bit(mISDN_STACK_WORK,\r\n&st->status);\r\ntest_and_clear_bit(mISDN_STACK_RUNNING,\r\n&st->status);\r\nbreak;\r\n}\r\n}\r\nif (test_bit(mISDN_STACK_CLEARING, &st->status)) {\r\ntest_and_set_bit(mISDN_STACK_STOPPED, &st->status);\r\ntest_and_clear_bit(mISDN_STACK_RUNNING, &st->status);\r\ndo_clear_stack(st);\r\ntest_and_clear_bit(mISDN_STACK_CLEARING, &st->status);\r\ntest_and_set_bit(mISDN_STACK_RESTART, &st->status);\r\n}\r\nif (test_and_clear_bit(mISDN_STACK_RESTART, &st->status)) {\r\ntest_and_clear_bit(mISDN_STACK_STOPPED, &st->status);\r\ntest_and_set_bit(mISDN_STACK_RUNNING, &st->status);\r\nif (!skb_queue_empty(&st->msgq))\r\ntest_and_set_bit(mISDN_STACK_WORK,\r\n&st->status);\r\n}\r\nif (test_bit(mISDN_STACK_ABORT, &st->status))\r\nbreak;\r\nif (st->notify != NULL) {\r\ncomplete(st->notify);\r\nst->notify = NULL;\r\n}\r\n#ifdef MISDN_MSG_STATS\r\nst->sleep_cnt++;\r\n#endif\r\ntest_and_clear_bit(mISDN_STACK_ACTIVE, &st->status);\r\nwait_event_interruptible(st->workq, (st->status &\r\nmISDN_STACK_ACTION_MASK));\r\nif (*debug & DEBUG_MSG_THREAD)\r\nprintk(KERN_DEBUG "%s: %s wake status %08lx\n",\r\n__func__, dev_name(&st->dev->dev), st->status);\r\ntest_and_set_bit(mISDN_STACK_ACTIVE, &st->status);\r\ntest_and_clear_bit(mISDN_STACK_WAKEUP, &st->status);\r\nif (test_bit(mISDN_STACK_STOPPED, &st->status)) {\r\ntest_and_clear_bit(mISDN_STACK_RUNNING, &st->status);\r\n#ifdef MISDN_MSG_STATS\r\nst->stopped_cnt++;\r\n#endif\r\n}\r\n}\r\n#ifdef MISDN_MSG_STATS\r\nprintk(KERN_DEBUG "mISDNStackd daemon for %s proceed %d "\r\n"msg %d sleep %d stopped\n",\r\ndev_name(&st->dev->dev), st->msg_cnt, st->sleep_cnt,\r\nst->stopped_cnt);\r\ntask_cputime(st->thread, &utime, &stime);\r\nprintk(KERN_DEBUG\r\n"mISDNStackd daemon for %s utime(%llu) stime(%llu)\n",\r\ndev_name(&st->dev->dev), utime, stime);\r\nprintk(KERN_DEBUG\r\n"mISDNStackd daemon for %s nvcsw(%ld) nivcsw(%ld)\n",\r\ndev_name(&st->dev->dev), st->thread->nvcsw, st->thread->nivcsw);\r\nprintk(KERN_DEBUG "mISDNStackd daemon for %s killed now\n",\r\ndev_name(&st->dev->dev));\r\n#endif\r\ntest_and_set_bit(mISDN_STACK_KILLED, &st->status);\r\ntest_and_clear_bit(mISDN_STACK_RUNNING, &st->status);\r\ntest_and_clear_bit(mISDN_STACK_ACTIVE, &st->status);\r\ntest_and_clear_bit(mISDN_STACK_ABORT, &st->status);\r\nskb_queue_purge(&st->msgq);\r\nst->thread = NULL;\r\nif (st->notify != NULL) {\r\ncomplete(st->notify);\r\nst->notify = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nl1_receive(struct mISDNchannel *ch, struct sk_buff *skb)\r\n{\r\nif (!ch->st)\r\nreturn -ENODEV;\r\n__net_timestamp(skb);\r\n_queue_message(ch->st, skb);\r\nreturn 0;\r\n}\r\nvoid\r\nset_channel_address(struct mISDNchannel *ch, u_int sapi, u_int tei)\r\n{\r\nch->addr = sapi | (tei << 8);\r\n}\r\nvoid\r\n__add_layer2(struct mISDNchannel *ch, struct mISDNstack *st)\r\n{\r\nlist_add_tail(&ch->list, &st->layer2);\r\n}\r\nvoid\r\nadd_layer2(struct mISDNchannel *ch, struct mISDNstack *st)\r\n{\r\nmutex_lock(&st->lmutex);\r\n__add_layer2(ch, st);\r\nmutex_unlock(&st->lmutex);\r\n}\r\nstatic int\r\nst_own_ctrl(struct mISDNchannel *ch, u_int cmd, void *arg)\r\n{\r\nif (!ch->st || !ch->st->layer1)\r\nreturn -EINVAL;\r\nreturn ch->st->layer1->ctrl(ch->st->layer1, cmd, arg);\r\n}\r\nint\r\ncreate_stack(struct mISDNdevice *dev)\r\n{\r\nstruct mISDNstack *newst;\r\nint err;\r\nDECLARE_COMPLETION_ONSTACK(done);\r\nnewst = kzalloc(sizeof(struct mISDNstack), GFP_KERNEL);\r\nif (!newst) {\r\nprintk(KERN_ERR "kmalloc mISDN_stack failed\n");\r\nreturn -ENOMEM;\r\n}\r\nnewst->dev = dev;\r\nINIT_LIST_HEAD(&newst->layer2);\r\nINIT_HLIST_HEAD(&newst->l1sock.head);\r\nrwlock_init(&newst->l1sock.lock);\r\ninit_waitqueue_head(&newst->workq);\r\nskb_queue_head_init(&newst->msgq);\r\nmutex_init(&newst->lmutex);\r\ndev->D.st = newst;\r\nerr = create_teimanager(dev);\r\nif (err) {\r\nprintk(KERN_ERR "kmalloc teimanager failed\n");\r\nkfree(newst);\r\nreturn err;\r\n}\r\ndev->teimgr->peer = &newst->own;\r\ndev->teimgr->recv = mISDN_queue_message;\r\ndev->teimgr->st = newst;\r\nnewst->layer1 = &dev->D;\r\ndev->D.recv = l1_receive;\r\ndev->D.peer = &newst->own;\r\nnewst->own.st = newst;\r\nnewst->own.ctrl = st_own_ctrl;\r\nnewst->own.send = mISDN_queue_message;\r\nnewst->own.recv = mISDN_queue_message;\r\nif (*debug & DEBUG_CORE_FUNC)\r\nprintk(KERN_DEBUG "%s: st(%s)\n", __func__,\r\ndev_name(&newst->dev->dev));\r\nnewst->notify = &done;\r\nnewst->thread = kthread_run(mISDNStackd, (void *)newst, "mISDN_%s",\r\ndev_name(&newst->dev->dev));\r\nif (IS_ERR(newst->thread)) {\r\nerr = PTR_ERR(newst->thread);\r\nprintk(KERN_ERR\r\n"mISDN:cannot create kernel thread for %s (%d)\n",\r\ndev_name(&newst->dev->dev), err);\r\ndelete_teimanager(dev->teimgr);\r\nkfree(newst);\r\n} else\r\nwait_for_completion(&done);\r\nreturn err;\r\n}\r\nint\r\nconnect_layer1(struct mISDNdevice *dev, struct mISDNchannel *ch,\r\nu_int protocol, struct sockaddr_mISDN *adr)\r\n{\r\nstruct mISDN_sock *msk = container_of(ch, struct mISDN_sock, ch);\r\nstruct channel_req rq;\r\nint err;\r\nif (*debug & DEBUG_CORE_FUNC)\r\nprintk(KERN_DEBUG "%s: %s proto(%x) adr(%d %d %d %d)\n",\r\n__func__, dev_name(&dev->dev), protocol, adr->dev,\r\nadr->channel, adr->sapi, adr->tei);\r\nswitch (protocol) {\r\ncase ISDN_P_NT_S0:\r\ncase ISDN_P_NT_E1:\r\ncase ISDN_P_TE_S0:\r\ncase ISDN_P_TE_E1:\r\nch->recv = mISDN_queue_message;\r\nch->peer = &dev->D.st->own;\r\nch->st = dev->D.st;\r\nrq.protocol = protocol;\r\nrq.adr.channel = adr->channel;\r\nerr = dev->D.ctrl(&dev->D, OPEN_CHANNEL, &rq);\r\nprintk(KERN_DEBUG "%s: ret %d (dev %d)\n", __func__, err,\r\ndev->id);\r\nif (err)\r\nreturn err;\r\nwrite_lock_bh(&dev->D.st->l1sock.lock);\r\nsk_add_node(&msk->sk, &dev->D.st->l1sock.head);\r\nwrite_unlock_bh(&dev->D.st->l1sock.lock);\r\nbreak;\r\ndefault:\r\nreturn -ENOPROTOOPT;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nconnect_Bstack(struct mISDNdevice *dev, struct mISDNchannel *ch,\r\nu_int protocol, struct sockaddr_mISDN *adr)\r\n{\r\nstruct channel_req rq, rq2;\r\nint pmask, err;\r\nstruct Bprotocol *bp;\r\nif (*debug & DEBUG_CORE_FUNC)\r\nprintk(KERN_DEBUG "%s: %s proto(%x) adr(%d %d %d %d)\n",\r\n__func__, dev_name(&dev->dev), protocol,\r\nadr->dev, adr->channel, adr->sapi,\r\nadr->tei);\r\nch->st = dev->D.st;\r\npmask = 1 << (protocol & ISDN_P_B_MASK);\r\nif (pmask & dev->Bprotocols) {\r\nrq.protocol = protocol;\r\nrq.adr = *adr;\r\nerr = dev->D.ctrl(&dev->D, OPEN_CHANNEL, &rq);\r\nif (err)\r\nreturn err;\r\nch->recv = rq.ch->send;\r\nch->peer = rq.ch;\r\nrq.ch->recv = ch->send;\r\nrq.ch->peer = ch;\r\nrq.ch->st = dev->D.st;\r\n} else {\r\nbp = get_Bprotocol4mask(pmask);\r\nif (!bp)\r\nreturn -ENOPROTOOPT;\r\nrq2.protocol = protocol;\r\nrq2.adr = *adr;\r\nrq2.ch = ch;\r\nerr = bp->create(&rq2);\r\nif (err)\r\nreturn err;\r\nch->recv = rq2.ch->send;\r\nch->peer = rq2.ch;\r\nrq2.ch->st = dev->D.st;\r\nrq.protocol = rq2.protocol;\r\nrq.adr = *adr;\r\nerr = dev->D.ctrl(&dev->D, OPEN_CHANNEL, &rq);\r\nif (err) {\r\nrq2.ch->ctrl(rq2.ch, CLOSE_CHANNEL, NULL);\r\nreturn err;\r\n}\r\nrq2.ch->recv = rq.ch->send;\r\nrq2.ch->peer = rq.ch;\r\nrq.ch->recv = rq2.ch->send;\r\nrq.ch->peer = rq2.ch;\r\nrq.ch->st = dev->D.st;\r\n}\r\nch->protocol = protocol;\r\nch->nr = rq.ch->nr;\r\nreturn 0;\r\n}\r\nint\r\ncreate_l2entity(struct mISDNdevice *dev, struct mISDNchannel *ch,\r\nu_int protocol, struct sockaddr_mISDN *adr)\r\n{\r\nstruct channel_req rq;\r\nint err;\r\nif (*debug & DEBUG_CORE_FUNC)\r\nprintk(KERN_DEBUG "%s: %s proto(%x) adr(%d %d %d %d)\n",\r\n__func__, dev_name(&dev->dev), protocol,\r\nadr->dev, adr->channel, adr->sapi,\r\nadr->tei);\r\nrq.protocol = ISDN_P_TE_S0;\r\nif (dev->Dprotocols & (1 << ISDN_P_TE_E1))\r\nrq.protocol = ISDN_P_TE_E1;\r\nswitch (protocol) {\r\ncase ISDN_P_LAPD_NT:\r\nrq.protocol = ISDN_P_NT_S0;\r\nif (dev->Dprotocols & (1 << ISDN_P_NT_E1))\r\nrq.protocol = ISDN_P_NT_E1;\r\ncase ISDN_P_LAPD_TE:\r\nch->recv = mISDN_queue_message;\r\nch->peer = &dev->D.st->own;\r\nch->st = dev->D.st;\r\nrq.adr.channel = 0;\r\nerr = dev->D.ctrl(&dev->D, OPEN_CHANNEL, &rq);\r\nprintk(KERN_DEBUG "%s: ret 1 %d\n", __func__, err);\r\nif (err)\r\nbreak;\r\nrq.protocol = protocol;\r\nrq.adr = *adr;\r\nrq.ch = ch;\r\nerr = dev->teimgr->ctrl(dev->teimgr, OPEN_CHANNEL, &rq);\r\nprintk(KERN_DEBUG "%s: ret 2 %d\n", __func__, err);\r\nif (!err) {\r\nif ((protocol == ISDN_P_LAPD_NT) && !rq.ch)\r\nbreak;\r\nadd_layer2(rq.ch, dev->D.st);\r\nrq.ch->recv = mISDN_queue_message;\r\nrq.ch->peer = &dev->D.st->own;\r\nrq.ch->ctrl(rq.ch, OPEN_CHANNEL, NULL);\r\n}\r\nbreak;\r\ndefault:\r\nerr = -EPROTONOSUPPORT;\r\n}\r\nreturn err;\r\n}\r\nvoid\r\ndelete_channel(struct mISDNchannel *ch)\r\n{\r\nstruct mISDN_sock *msk = container_of(ch, struct mISDN_sock, ch);\r\nstruct mISDNchannel *pch;\r\nif (!ch->st) {\r\nprintk(KERN_WARNING "%s: no stack\n", __func__);\r\nreturn;\r\n}\r\nif (*debug & DEBUG_CORE_FUNC)\r\nprintk(KERN_DEBUG "%s: st(%s) protocol(%x)\n", __func__,\r\ndev_name(&ch->st->dev->dev), ch->protocol);\r\nif (ch->protocol >= ISDN_P_B_START) {\r\nif (ch->peer) {\r\nch->peer->ctrl(ch->peer, CLOSE_CHANNEL, NULL);\r\nch->peer = NULL;\r\n}\r\nreturn;\r\n}\r\nswitch (ch->protocol) {\r\ncase ISDN_P_NT_S0:\r\ncase ISDN_P_TE_S0:\r\ncase ISDN_P_NT_E1:\r\ncase ISDN_P_TE_E1:\r\nwrite_lock_bh(&ch->st->l1sock.lock);\r\nsk_del_node_init(&msk->sk);\r\nwrite_unlock_bh(&ch->st->l1sock.lock);\r\nch->st->dev->D.ctrl(&ch->st->dev->D, CLOSE_CHANNEL, NULL);\r\nbreak;\r\ncase ISDN_P_LAPD_TE:\r\npch = get_channel4id(ch->st, ch->nr);\r\nif (pch) {\r\nmutex_lock(&ch->st->lmutex);\r\nlist_del(&pch->list);\r\nmutex_unlock(&ch->st->lmutex);\r\npch->ctrl(pch, CLOSE_CHANNEL, NULL);\r\npch = ch->st->dev->teimgr;\r\npch->ctrl(pch, CLOSE_CHANNEL, NULL);\r\n} else\r\nprintk(KERN_WARNING "%s: no l2 channel\n",\r\n__func__);\r\nbreak;\r\ncase ISDN_P_LAPD_NT:\r\npch = ch->st->dev->teimgr;\r\nif (pch) {\r\npch->ctrl(pch, CLOSE_CHANNEL, NULL);\r\n} else\r\nprintk(KERN_WARNING "%s: no l2 channel\n",\r\n__func__);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nvoid\r\ndelete_stack(struct mISDNdevice *dev)\r\n{\r\nstruct mISDNstack *st = dev->D.st;\r\nDECLARE_COMPLETION_ONSTACK(done);\r\nif (*debug & DEBUG_CORE_FUNC)\r\nprintk(KERN_DEBUG "%s: st(%s)\n", __func__,\r\ndev_name(&st->dev->dev));\r\nif (dev->teimgr)\r\ndelete_teimanager(dev->teimgr);\r\nif (st->thread) {\r\nif (st->notify) {\r\nprintk(KERN_WARNING "%s: notifier in use\n",\r\n__func__);\r\ncomplete(st->notify);\r\n}\r\nst->notify = &done;\r\ntest_and_set_bit(mISDN_STACK_ABORT, &st->status);\r\ntest_and_set_bit(mISDN_STACK_WAKEUP, &st->status);\r\nwake_up_interruptible(&st->workq);\r\nwait_for_completion(&done);\r\n}\r\nif (!list_empty(&st->layer2))\r\nprintk(KERN_WARNING "%s: layer2 list not empty\n",\r\n__func__);\r\nif (!hlist_empty(&st->l1sock.head))\r\nprintk(KERN_WARNING "%s: layer1 list not empty\n",\r\n__func__);\r\nkfree(st);\r\n}\r\nvoid\r\nmISDN_initstack(u_int *dp)\r\n{\r\ndebug = dp;\r\n}
