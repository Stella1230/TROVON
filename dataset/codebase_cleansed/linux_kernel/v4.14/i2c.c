static int st_nci_i2c_enable(void *phy_id)\r\n{\r\nstruct st_nci_i2c_phy *phy = phy_id;\r\ngpiod_set_value(phy->gpiod_reset, 0);\r\nusleep_range(10000, 15000);\r\ngpiod_set_value(phy->gpiod_reset, 1);\r\nusleep_range(80000, 85000);\r\nif (phy->ndlc->powered == 0 && phy->irq_active == 0) {\r\nenable_irq(phy->i2c_dev->irq);\r\nphy->irq_active = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic void st_nci_i2c_disable(void *phy_id)\r\n{\r\nstruct st_nci_i2c_phy *phy = phy_id;\r\ndisable_irq_nosync(phy->i2c_dev->irq);\r\nphy->irq_active = false;\r\n}\r\nstatic int st_nci_i2c_write(void *phy_id, struct sk_buff *skb)\r\n{\r\nint r = -1;\r\nstruct st_nci_i2c_phy *phy = phy_id;\r\nstruct i2c_client *client = phy->i2c_dev;\r\nif (phy->ndlc->hard_fault != 0)\r\nreturn phy->ndlc->hard_fault;\r\nr = i2c_master_send(client, skb->data, skb->len);\r\nif (r < 0) {\r\nusleep_range(1000, 4000);\r\nr = i2c_master_send(client, skb->data, skb->len);\r\n}\r\nif (r >= 0) {\r\nif (r != skb->len)\r\nr = -EREMOTEIO;\r\nelse\r\nr = 0;\r\n}\r\nreturn r;\r\n}\r\nstatic int st_nci_i2c_read(struct st_nci_i2c_phy *phy,\r\nstruct sk_buff **skb)\r\n{\r\nint r;\r\nu8 len;\r\nu8 buf[ST_NCI_I2C_MAX_SIZE];\r\nstruct i2c_client *client = phy->i2c_dev;\r\nr = i2c_master_recv(client, buf, ST_NCI_I2C_MIN_SIZE);\r\nif (r < 0) {\r\nusleep_range(1000, 4000);\r\nr = i2c_master_recv(client, buf, ST_NCI_I2C_MIN_SIZE);\r\n}\r\nif (r != ST_NCI_I2C_MIN_SIZE)\r\nreturn -EREMOTEIO;\r\nlen = be16_to_cpu(*(__be16 *) (buf + 2));\r\nif (len > ST_NCI_I2C_MAX_SIZE) {\r\nnfc_err(&client->dev, "invalid frame len\n");\r\nreturn -EBADMSG;\r\n}\r\n*skb = alloc_skb(ST_NCI_I2C_MIN_SIZE + len, GFP_KERNEL);\r\nif (*skb == NULL)\r\nreturn -ENOMEM;\r\nskb_reserve(*skb, ST_NCI_I2C_MIN_SIZE);\r\nskb_put(*skb, ST_NCI_I2C_MIN_SIZE);\r\nmemcpy((*skb)->data, buf, ST_NCI_I2C_MIN_SIZE);\r\nif (!len)\r\nreturn 0;\r\nr = i2c_master_recv(client, buf, len);\r\nif (r != len) {\r\nkfree_skb(*skb);\r\nreturn -EREMOTEIO;\r\n}\r\nskb_put(*skb, len);\r\nmemcpy((*skb)->data + ST_NCI_I2C_MIN_SIZE, buf, len);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t st_nci_irq_thread_fn(int irq, void *phy_id)\r\n{\r\nstruct st_nci_i2c_phy *phy = phy_id;\r\nstruct i2c_client *client;\r\nstruct sk_buff *skb = NULL;\r\nint r;\r\nif (!phy || !phy->ndlc || irq != phy->i2c_dev->irq) {\r\nWARN_ON_ONCE(1);\r\nreturn IRQ_NONE;\r\n}\r\nclient = phy->i2c_dev;\r\ndev_dbg(&client->dev, "IRQ\n");\r\nif (phy->ndlc->hard_fault)\r\nreturn IRQ_HANDLED;\r\nif (!phy->ndlc->powered) {\r\nst_nci_i2c_disable(phy);\r\nreturn IRQ_HANDLED;\r\n}\r\nr = st_nci_i2c_read(phy, &skb);\r\nif (r == -EREMOTEIO || r == -ENOMEM || r == -EBADMSG)\r\nreturn IRQ_HANDLED;\r\nndlc_recv(phy->ndlc, skb);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int st_nci_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct st_nci_i2c_phy *phy;\r\nint r;\r\ndev_dbg(&client->dev, "%s\n", __func__);\r\ndev_dbg(&client->dev, "IRQ: %d\n", client->irq);\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\nnfc_err(&client->dev, "Need I2C_FUNC_I2C\n");\r\nreturn -ENODEV;\r\n}\r\nphy = devm_kzalloc(dev, sizeof(struct st_nci_i2c_phy), GFP_KERNEL);\r\nif (!phy)\r\nreturn -ENOMEM;\r\nphy->i2c_dev = client;\r\ni2c_set_clientdata(client, phy);\r\nr = devm_acpi_dev_add_driver_gpios(dev, acpi_st_nci_gpios);\r\nif (r)\r\ndev_dbg(dev, "Unable to add GPIO mapping table\n");\r\nphy->gpiod_reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);\r\nif (IS_ERR(phy->gpiod_reset)) {\r\nnfc_err(dev, "Unable to get RESET GPIO\n");\r\nreturn -ENODEV;\r\n}\r\nphy->se_status.is_ese_present =\r\ndevice_property_read_bool(dev, "ese-present");\r\nphy->se_status.is_uicc_present =\r\ndevice_property_read_bool(dev, "uicc-present");\r\nr = ndlc_probe(phy, &i2c_phy_ops, &client->dev,\r\nST_NCI_FRAME_HEADROOM, ST_NCI_FRAME_TAILROOM,\r\n&phy->ndlc, &phy->se_status);\r\nif (r < 0) {\r\nnfc_err(&client->dev, "Unable to register ndlc layer\n");\r\nreturn r;\r\n}\r\nphy->irq_active = true;\r\nr = devm_request_threaded_irq(&client->dev, client->irq, NULL,\r\nst_nci_irq_thread_fn,\r\nIRQF_ONESHOT,\r\nST_NCI_DRIVER_NAME, phy);\r\nif (r < 0)\r\nnfc_err(&client->dev, "Unable to register IRQ handler\n");\r\nreturn r;\r\n}\r\nstatic int st_nci_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct st_nci_i2c_phy *phy = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "%s\n", __func__);\r\nndlc_remove(phy->ndlc);\r\nreturn 0;\r\n}
