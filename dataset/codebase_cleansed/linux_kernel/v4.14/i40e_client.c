static\r\nint i40e_client_get_params(struct i40e_vsi *vsi, struct i40e_params *params)\r\n{\r\nstruct i40e_dcbx_config *dcb_cfg = &vsi->back->hw.local_dcbx_config;\r\nint i = 0;\r\nfor (i = 0; i < I40E_MAX_USER_PRIORITY; i++) {\r\nu8 tc = dcb_cfg->etscfg.prioritytable[i];\r\nu16 qs_handle;\r\nif (!(vsi->tc_config.enabled_tc & BIT(tc)))\r\ntc = 0;\r\nqs_handle = le16_to_cpu(vsi->info.qs_handle[tc]);\r\nparams->qos.prio_qos[i].tc = tc;\r\nparams->qos.prio_qos[i].qs_handle = qs_handle;\r\nif (qs_handle == I40E_AQ_VSI_QS_HANDLE_INVALID) {\r\ndev_err(&vsi->back->pdev->dev, "Invalid queue set handle for TC = %d, vsi id = %d\n",\r\ntc, vsi->id);\r\nreturn -EINVAL;\r\n}\r\n}\r\nparams->mtu = vsi->netdev->mtu;\r\nreturn 0;\r\n}\r\nvoid\r\ni40e_notify_client_of_vf_msg(struct i40e_vsi *vsi, u32 vf_id, u8 *msg, u16 len)\r\n{\r\nstruct i40e_pf *pf = vsi->back;\r\nstruct i40e_client_instance *cdev = pf->cinst;\r\nif (!cdev || !cdev->client)\r\nreturn;\r\nif (!cdev->client->ops || !cdev->client->ops->virtchnl_receive) {\r\ndev_dbg(&pf->pdev->dev,\r\n"Cannot locate client instance virtual channel receive routine\n");\r\nreturn;\r\n}\r\nif (!test_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state)) {\r\ndev_dbg(&pf->pdev->dev, "Client is not open, abort virtchnl_receive\n");\r\nreturn;\r\n}\r\ncdev->client->ops->virtchnl_receive(&cdev->lan_info, cdev->client,\r\nvf_id, msg, len);\r\n}\r\nvoid i40e_notify_client_of_l2_param_changes(struct i40e_vsi *vsi)\r\n{\r\nstruct i40e_pf *pf = vsi->back;\r\nstruct i40e_client_instance *cdev = pf->cinst;\r\nstruct i40e_params params;\r\nif (!cdev || !cdev->client)\r\nreturn;\r\nif (!cdev->client->ops || !cdev->client->ops->l2_param_change) {\r\ndev_dbg(&vsi->back->pdev->dev,\r\n"Cannot locate client instance l2_param_change routine\n");\r\nreturn;\r\n}\r\nif (!test_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state)) {\r\ndev_dbg(&vsi->back->pdev->dev, "Client is not open, abort l2 param change\n");\r\nreturn;\r\n}\r\nmemset(&params, 0, sizeof(params));\r\ni40e_client_get_params(vsi, &params);\r\nmemcpy(&cdev->lan_info.params, &params, sizeof(struct i40e_params));\r\ncdev->client->ops->l2_param_change(&cdev->lan_info, cdev->client,\r\n&params);\r\n}\r\nstatic void i40e_client_release_qvlist(struct i40e_info *ldev)\r\n{\r\nstruct i40e_qvlist_info *qvlist_info = ldev->qvlist_info;\r\nu32 i;\r\nif (!ldev->qvlist_info)\r\nreturn;\r\nfor (i = 0; i < qvlist_info->num_vectors; i++) {\r\nstruct i40e_pf *pf = ldev->pf;\r\nstruct i40e_qv_info *qv_info;\r\nu32 reg_idx;\r\nqv_info = &qvlist_info->qv_info[i];\r\nif (!qv_info)\r\ncontinue;\r\nreg_idx = I40E_PFINT_LNKLSTN(qv_info->v_idx - 1);\r\nwr32(&pf->hw, reg_idx, I40E_PFINT_LNKLSTN_FIRSTQ_INDX_MASK);\r\n}\r\nkfree(ldev->qvlist_info);\r\nldev->qvlist_info = NULL;\r\n}\r\nvoid i40e_notify_client_of_netdev_close(struct i40e_vsi *vsi, bool reset)\r\n{\r\nstruct i40e_pf *pf = vsi->back;\r\nstruct i40e_client_instance *cdev = pf->cinst;\r\nif (!cdev || !cdev->client)\r\nreturn;\r\nif (!cdev->client->ops || !cdev->client->ops->close) {\r\ndev_dbg(&vsi->back->pdev->dev,\r\n"Cannot locate client instance close routine\n");\r\nreturn;\r\n}\r\ncdev->client->ops->close(&cdev->lan_info, cdev->client, reset);\r\nclear_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state);\r\ni40e_client_release_qvlist(&cdev->lan_info);\r\n}\r\nvoid i40e_notify_client_of_vf_reset(struct i40e_pf *pf, u32 vf_id)\r\n{\r\nstruct i40e_client_instance *cdev = pf->cinst;\r\nif (!cdev || !cdev->client)\r\nreturn;\r\nif (!cdev->client->ops || !cdev->client->ops->vf_reset) {\r\ndev_dbg(&pf->pdev->dev,\r\n"Cannot locate client instance VF reset routine\n");\r\nreturn;\r\n}\r\nif (!test_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state)) {\r\ndev_dbg(&pf->pdev->dev, "Client is not open, abort vf-reset\n");\r\nreturn;\r\n}\r\ncdev->client->ops->vf_reset(&cdev->lan_info, cdev->client, vf_id);\r\n}\r\nvoid i40e_notify_client_of_vf_enable(struct i40e_pf *pf, u32 num_vfs)\r\n{\r\nstruct i40e_client_instance *cdev = pf->cinst;\r\nif (!cdev || !cdev->client)\r\nreturn;\r\nif (!cdev->client->ops || !cdev->client->ops->vf_enable) {\r\ndev_dbg(&pf->pdev->dev,\r\n"Cannot locate client instance VF enable routine\n");\r\nreturn;\r\n}\r\nif (!test_bit(__I40E_CLIENT_INSTANCE_OPENED,\r\n&cdev->state)) {\r\ndev_dbg(&pf->pdev->dev, "Client is not open, abort vf-enable\n");\r\nreturn;\r\n}\r\ncdev->client->ops->vf_enable(&cdev->lan_info, cdev->client, num_vfs);\r\n}\r\nint i40e_vf_client_capable(struct i40e_pf *pf, u32 vf_id)\r\n{\r\nstruct i40e_client_instance *cdev = pf->cinst;\r\nint capable = false;\r\nif (!cdev || !cdev->client)\r\ngoto out;\r\nif (!cdev->client->ops || !cdev->client->ops->vf_capable) {\r\ndev_dbg(&pf->pdev->dev,\r\n"Cannot locate client instance VF capability routine\n");\r\ngoto out;\r\n}\r\nif (!test_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state))\r\ngoto out;\r\ncapable = cdev->client->ops->vf_capable(&cdev->lan_info,\r\ncdev->client,\r\nvf_id);\r\nout:\r\nreturn capable;\r\n}\r\nstatic void i40e_client_add_instance(struct i40e_pf *pf)\r\n{\r\nstruct i40e_client_instance *cdev = NULL;\r\nstruct netdev_hw_addr *mac = NULL;\r\nstruct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];\r\nif (!registered_client || pf->cinst)\r\nreturn;\r\ncdev = kzalloc(sizeof(*cdev), GFP_KERNEL);\r\nif (!cdev)\r\nreturn;\r\ncdev->lan_info.pf = (void *)pf;\r\ncdev->lan_info.netdev = vsi->netdev;\r\ncdev->lan_info.pcidev = pf->pdev;\r\ncdev->lan_info.fid = pf->hw.pf_id;\r\ncdev->lan_info.ftype = I40E_CLIENT_FTYPE_PF;\r\ncdev->lan_info.hw_addr = pf->hw.hw_addr;\r\ncdev->lan_info.ops = &i40e_lan_ops;\r\ncdev->lan_info.version.major = I40E_CLIENT_VERSION_MAJOR;\r\ncdev->lan_info.version.minor = I40E_CLIENT_VERSION_MINOR;\r\ncdev->lan_info.version.build = I40E_CLIENT_VERSION_BUILD;\r\ncdev->lan_info.fw_maj_ver = pf->hw.aq.fw_maj_ver;\r\ncdev->lan_info.fw_min_ver = pf->hw.aq.fw_min_ver;\r\ncdev->lan_info.fw_build = pf->hw.aq.fw_build;\r\nset_bit(__I40E_CLIENT_INSTANCE_NONE, &cdev->state);\r\nif (i40e_client_get_params(vsi, &cdev->lan_info.params)) {\r\nkfree(cdev);\r\ncdev = NULL;\r\nreturn;\r\n}\r\ncdev->lan_info.msix_count = pf->num_iwarp_msix;\r\ncdev->lan_info.msix_entries = &pf->msix_entries[pf->iwarp_base_vector];\r\nmac = list_first_entry(&cdev->lan_info.netdev->dev_addrs.list,\r\nstruct netdev_hw_addr, list);\r\nif (mac)\r\nether_addr_copy(cdev->lan_info.lanmac, mac->addr);\r\nelse\r\ndev_err(&pf->pdev->dev, "MAC address list is empty!\n");\r\ncdev->client = registered_client;\r\npf->cinst = cdev;\r\n}\r\nstatic\r\nvoid i40e_client_del_instance(struct i40e_pf *pf)\r\n{\r\nkfree(pf->cinst);\r\npf->cinst = NULL;\r\n}\r\nvoid i40e_client_subtask(struct i40e_pf *pf)\r\n{\r\nstruct i40e_client *client = registered_client;\r\nstruct i40e_client_instance *cdev;\r\nstruct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];\r\nint ret = 0;\r\nif (!(pf->flags & I40E_FLAG_SERVICE_CLIENT_REQUESTED))\r\nreturn;\r\npf->flags &= ~I40E_FLAG_SERVICE_CLIENT_REQUESTED;\r\ncdev = pf->cinst;\r\nif (test_bit(__I40E_DOWN, pf->state) ||\r\ntest_bit(__I40E_CONFIG_BUSY, pf->state))\r\nreturn;\r\nif (!client || !cdev)\r\nreturn;\r\nif (!test_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state)) {\r\nif (!test_bit(__I40E_VSI_DOWN, vsi->state) &&\r\nclient->ops && client->ops->open) {\r\nset_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state);\r\nret = client->ops->open(&cdev->lan_info, client);\r\nif (ret) {\r\nclear_bit(__I40E_CLIENT_INSTANCE_OPENED,\r\n&cdev->state);\r\ni40e_client_del_instance(pf);\r\n}\r\n}\r\n} else {\r\nif (test_bit(__I40E_VSI_DOWN, vsi->state) &&\r\nclient->ops && client->ops->close) {\r\nclear_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state);\r\nclient->ops->close(&cdev->lan_info, client, false);\r\ni40e_client_release_qvlist(&cdev->lan_info);\r\n}\r\n}\r\n}\r\nint i40e_lan_add_device(struct i40e_pf *pf)\r\n{\r\nstruct i40e_device *ldev;\r\nint ret = 0;\r\nmutex_lock(&i40e_device_mutex);\r\nlist_for_each_entry(ldev, &i40e_devices, list) {\r\nif (ldev->pf == pf) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nldev = kzalloc(sizeof(*ldev), GFP_KERNEL);\r\nif (!ldev) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nldev->pf = pf;\r\nINIT_LIST_HEAD(&ldev->list);\r\nlist_add(&ldev->list, &i40e_devices);\r\ndev_info(&pf->pdev->dev, "Added LAN device PF%d bus=0x%02x dev=0x%02x func=0x%02x\n",\r\npf->hw.pf_id, pf->hw.bus.bus_id,\r\npf->hw.bus.device, pf->hw.bus.func);\r\nif (registered_client)\r\ni40e_client_add_instance(pf);\r\npf->flags |= I40E_FLAG_SERVICE_CLIENT_REQUESTED;\r\ni40e_service_event_schedule(pf);\r\nout:\r\nmutex_unlock(&i40e_device_mutex);\r\nreturn ret;\r\n}\r\nint i40e_lan_del_device(struct i40e_pf *pf)\r\n{\r\nstruct i40e_device *ldev, *tmp;\r\nint ret = -ENODEV;\r\ni40e_client_del_instance(pf);\r\nmutex_lock(&i40e_device_mutex);\r\nlist_for_each_entry_safe(ldev, tmp, &i40e_devices, list) {\r\nif (ldev->pf == pf) {\r\ndev_info(&pf->pdev->dev, "Deleted LAN device PF%d bus=0x%02x dev=0x%02x func=0x%02x\n",\r\npf->hw.pf_id, pf->hw.bus.bus_id,\r\npf->hw.bus.device, pf->hw.bus.func);\r\nlist_del(&ldev->list);\r\nkfree(ldev);\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&i40e_device_mutex);\r\nreturn ret;\r\n}\r\nstatic void i40e_client_release(struct i40e_client *client)\r\n{\r\nstruct i40e_client_instance *cdev;\r\nstruct i40e_device *ldev;\r\nstruct i40e_pf *pf;\r\nmutex_lock(&i40e_device_mutex);\r\nlist_for_each_entry(ldev, &i40e_devices, list) {\r\npf = ldev->pf;\r\ncdev = pf->cinst;\r\nif (!cdev)\r\ncontinue;\r\nwhile (test_and_set_bit(__I40E_SERVICE_SCHED,\r\npf->state))\r\nusleep_range(500, 1000);\r\nif (test_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state)) {\r\nif (client->ops && client->ops->close)\r\nclient->ops->close(&cdev->lan_info, client,\r\nfalse);\r\ni40e_client_release_qvlist(&cdev->lan_info);\r\nclear_bit(__I40E_CLIENT_INSTANCE_OPENED, &cdev->state);\r\ndev_warn(&pf->pdev->dev,\r\n"Client %s instance for PF id %d closed\n",\r\nclient->name, pf->hw.pf_id);\r\n}\r\ni40e_client_del_instance(pf);\r\ndev_info(&pf->pdev->dev, "Deleted client instance of Client %s\n",\r\nclient->name);\r\nclear_bit(__I40E_SERVICE_SCHED, pf->state);\r\n}\r\nmutex_unlock(&i40e_device_mutex);\r\n}\r\nstatic void i40e_client_prepare(struct i40e_client *client)\r\n{\r\nstruct i40e_device *ldev;\r\nstruct i40e_pf *pf;\r\nmutex_lock(&i40e_device_mutex);\r\nlist_for_each_entry(ldev, &i40e_devices, list) {\r\npf = ldev->pf;\r\ni40e_client_add_instance(pf);\r\npf->flags |= I40E_FLAG_SERVICE_CLIENT_REQUESTED;\r\ni40e_service_event_schedule(pf);\r\n}\r\nmutex_unlock(&i40e_device_mutex);\r\n}\r\nstatic int i40e_client_virtchnl_send(struct i40e_info *ldev,\r\nstruct i40e_client *client,\r\nu32 vf_id, u8 *msg, u16 len)\r\n{\r\nstruct i40e_pf *pf = ldev->pf;\r\nstruct i40e_hw *hw = &pf->hw;\r\ni40e_status err;\r\nerr = i40e_aq_send_msg_to_vf(hw, vf_id, VIRTCHNL_OP_IWARP,\r\n0, msg, len, NULL);\r\nif (err)\r\ndev_err(&pf->pdev->dev, "Unable to send iWarp message to VF, error %d, aq status %d\n",\r\nerr, hw->aq.asq_last_status);\r\nreturn err;\r\n}\r\nstatic int i40e_client_setup_qvlist(struct i40e_info *ldev,\r\nstruct i40e_client *client,\r\nstruct i40e_qvlist_info *qvlist_info)\r\n{\r\nstruct i40e_pf *pf = ldev->pf;\r\nstruct i40e_hw *hw = &pf->hw;\r\nstruct i40e_qv_info *qv_info;\r\nu32 v_idx, i, reg_idx, reg;\r\nu32 size;\r\nsize = sizeof(struct i40e_qvlist_info) +\r\n(sizeof(struct i40e_qv_info) * (qvlist_info->num_vectors - 1));\r\nldev->qvlist_info = kzalloc(size, GFP_KERNEL);\r\nif (!ldev->qvlist_info)\r\nreturn -ENOMEM;\r\nldev->qvlist_info->num_vectors = qvlist_info->num_vectors;\r\nfor (i = 0; i < qvlist_info->num_vectors; i++) {\r\nqv_info = &qvlist_info->qv_info[i];\r\nif (!qv_info)\r\ncontinue;\r\nv_idx = qv_info->v_idx;\r\nif ((v_idx >= (pf->iwarp_base_vector + pf->num_iwarp_msix)) ||\r\n(v_idx < pf->iwarp_base_vector))\r\ngoto err;\r\nldev->qvlist_info->qv_info[i] = *qv_info;\r\nreg_idx = I40E_PFINT_LNKLSTN(v_idx - 1);\r\nif (qv_info->ceq_idx == I40E_QUEUE_INVALID_IDX) {\r\nwr32(hw, reg_idx, I40E_PFINT_LNKLSTN_FIRSTQ_INDX_MASK);\r\n} else {\r\nreg = (qv_info->ceq_idx &\r\nI40E_PFINT_LNKLSTN_FIRSTQ_INDX_MASK) |\r\n(I40E_QUEUE_TYPE_PE_CEQ <<\r\nI40E_PFINT_LNKLSTN_FIRSTQ_TYPE_SHIFT);\r\nwr32(hw, reg_idx, reg);\r\nreg = (I40E_PFINT_CEQCTL_CAUSE_ENA_MASK |\r\n(v_idx << I40E_PFINT_CEQCTL_MSIX_INDX_SHIFT) |\r\n(qv_info->itr_idx <<\r\nI40E_PFINT_CEQCTL_ITR_INDX_SHIFT) |\r\n(I40E_QUEUE_END_OF_LIST <<\r\nI40E_PFINT_CEQCTL_NEXTQ_INDX_SHIFT));\r\nwr32(hw, I40E_PFINT_CEQCTL(qv_info->ceq_idx), reg);\r\n}\r\nif (qv_info->aeq_idx != I40E_QUEUE_INVALID_IDX) {\r\nreg = (I40E_PFINT_AEQCTL_CAUSE_ENA_MASK |\r\n(v_idx << I40E_PFINT_AEQCTL_MSIX_INDX_SHIFT) |\r\n(qv_info->itr_idx <<\r\nI40E_PFINT_AEQCTL_ITR_INDX_SHIFT));\r\nwr32(hw, I40E_PFINT_AEQCTL, reg);\r\n}\r\n}\r\ni40e_flush(hw);\r\nreturn 0;\r\nerr:\r\nkfree(ldev->qvlist_info);\r\nldev->qvlist_info = NULL;\r\nreturn -EINVAL;\r\n}\r\nstatic void i40e_client_request_reset(struct i40e_info *ldev,\r\nstruct i40e_client *client,\r\nu32 reset_level)\r\n{\r\nstruct i40e_pf *pf = ldev->pf;\r\nswitch (reset_level) {\r\ncase I40E_CLIENT_RESET_LEVEL_PF:\r\nset_bit(__I40E_PF_RESET_REQUESTED, pf->state);\r\nbreak;\r\ncase I40E_CLIENT_RESET_LEVEL_CORE:\r\nset_bit(__I40E_PF_RESET_REQUESTED, pf->state);\r\nbreak;\r\ndefault:\r\ndev_warn(&pf->pdev->dev,\r\n"Client for PF id %d requested an unsupported reset: %d.\n",\r\npf->hw.pf_id, reset_level);\r\nbreak;\r\n}\r\ni40e_service_event_schedule(pf);\r\n}\r\nstatic int i40e_client_update_vsi_ctxt(struct i40e_info *ldev,\r\nstruct i40e_client *client,\r\nbool is_vf, u32 vf_id,\r\nu32 flag, u32 valid_flag)\r\n{\r\nstruct i40e_pf *pf = ldev->pf;\r\nstruct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];\r\nstruct i40e_vsi_context ctxt;\r\nbool update = true;\r\ni40e_status err;\r\nif (is_vf)\r\nreturn -EINVAL;\r\nctxt.seid = pf->main_vsi_seid;\r\nctxt.pf_num = pf->hw.pf_id;\r\nerr = i40e_aq_get_vsi_params(&pf->hw, &ctxt, NULL);\r\nctxt.flags = I40E_AQ_VSI_TYPE_PF;\r\nif (err) {\r\ndev_info(&pf->pdev->dev,\r\n"couldn't get PF vsi config, err %s aq_err %s\n",\r\ni40e_stat_str(&pf->hw, err),\r\ni40e_aq_str(&pf->hw,\r\npf->hw.aq.asq_last_status));\r\nreturn -ENOENT;\r\n}\r\nif ((valid_flag & I40E_CLIENT_VSI_FLAG_TCP_PACKET_ENABLE) &&\r\n(flag & I40E_CLIENT_VSI_FLAG_TCP_PACKET_ENABLE)) {\r\nctxt.info.valid_sections =\r\ncpu_to_le16(I40E_AQ_VSI_PROP_QUEUE_OPT_VALID);\r\nctxt.info.queueing_opt_flags |= I40E_AQ_VSI_QUE_OPT_TCP_ENA;\r\n} else if ((valid_flag & I40E_CLIENT_VSI_FLAG_TCP_PACKET_ENABLE) &&\r\n!(flag & I40E_CLIENT_VSI_FLAG_TCP_PACKET_ENABLE)) {\r\nctxt.info.valid_sections =\r\ncpu_to_le16(I40E_AQ_VSI_PROP_QUEUE_OPT_VALID);\r\nctxt.info.queueing_opt_flags &= ~I40E_AQ_VSI_QUE_OPT_TCP_ENA;\r\n} else {\r\nupdate = false;\r\ndev_warn(&pf->pdev->dev,\r\n"Client for PF id %d request an unsupported Config: %x.\n",\r\npf->hw.pf_id, flag);\r\n}\r\nif (update) {\r\nerr = i40e_aq_update_vsi_params(&vsi->back->hw, &ctxt, NULL);\r\nif (err) {\r\ndev_info(&pf->pdev->dev,\r\n"update VSI ctxt for PE failed, err %s aq_err %s\n",\r\ni40e_stat_str(&pf->hw, err),\r\ni40e_aq_str(&pf->hw,\r\npf->hw.aq.asq_last_status));\r\n}\r\n}\r\nreturn err;\r\n}\r\nint i40e_register_client(struct i40e_client *client)\r\n{\r\nint ret = 0;\r\nif (!client) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (strlen(client->name) == 0) {\r\npr_info("i40e: Failed to register client with no name\n");\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (registered_client) {\r\npr_info("i40e: Client %s has already been registered!\n",\r\nclient->name);\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\nif ((client->version.major != I40E_CLIENT_VERSION_MAJOR) ||\r\n(client->version.minor != I40E_CLIENT_VERSION_MINOR)) {\r\npr_info("i40e: Failed to register client %s due to mismatched client interface version\n",\r\nclient->name);\r\npr_info("Client is using version: %02d.%02d.%02d while LAN driver supports %s\n",\r\nclient->version.major, client->version.minor,\r\nclient->version.build,\r\ni40e_client_interface_version_str);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nregistered_client = client;\r\ni40e_client_prepare(client);\r\npr_info("i40e: Registered client %s\n", client->name);\r\nout:\r\nreturn ret;\r\n}\r\nint i40e_unregister_client(struct i40e_client *client)\r\n{\r\nint ret = 0;\r\nif (registered_client != client) {\r\npr_info("i40e: Client %s has not been registered\n",\r\nclient->name);\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nregistered_client = NULL;\r\ni40e_client_release(client);\r\npr_info("i40e: Unregistered client %s\n", client->name);\r\nout:\r\nreturn ret;\r\n}
