static void mpc8xxx_wdt_keepalive(struct mpc8xxx_wdt_ddata *ddata)\r\n{\r\nspin_lock(&ddata->lock);\r\nout_be16(&ddata->base->swsrr, 0x556c);\r\nout_be16(&ddata->base->swsrr, 0xaa39);\r\nspin_unlock(&ddata->lock);\r\n}\r\nstatic void mpc8xxx_wdt_timer_ping(unsigned long arg)\r\n{\r\nstruct mpc8xxx_wdt_ddata *ddata = (void *)arg;\r\nmpc8xxx_wdt_keepalive(ddata);\r\nmod_timer(&ddata->timer, jiffies + HZ * ddata->wdd.timeout / 2);\r\n}\r\nstatic int mpc8xxx_wdt_start(struct watchdog_device *w)\r\n{\r\nstruct mpc8xxx_wdt_ddata *ddata =\r\ncontainer_of(w, struct mpc8xxx_wdt_ddata, wdd);\r\nu32 tmp = SWCRR_SWEN | SWCRR_SWPR;\r\nif (reset)\r\ntmp |= SWCRR_SWRI;\r\ntmp |= timeout << 16;\r\nout_be32(&ddata->base->swcrr, tmp);\r\ndel_timer_sync(&ddata->timer);\r\nreturn 0;\r\n}\r\nstatic int mpc8xxx_wdt_ping(struct watchdog_device *w)\r\n{\r\nstruct mpc8xxx_wdt_ddata *ddata =\r\ncontainer_of(w, struct mpc8xxx_wdt_ddata, wdd);\r\nmpc8xxx_wdt_keepalive(ddata);\r\nreturn 0;\r\n}\r\nstatic int mpc8xxx_wdt_stop(struct watchdog_device *w)\r\n{\r\nstruct mpc8xxx_wdt_ddata *ddata =\r\ncontainer_of(w, struct mpc8xxx_wdt_ddata, wdd);\r\nmod_timer(&ddata->timer, jiffies);\r\nreturn 0;\r\n}\r\nstatic int mpc8xxx_wdt_probe(struct platform_device *ofdev)\r\n{\r\nint ret;\r\nstruct resource *res;\r\nconst struct mpc8xxx_wdt_type *wdt_type;\r\nstruct mpc8xxx_wdt_ddata *ddata;\r\nu32 freq = fsl_get_sys_freq();\r\nbool enabled;\r\nunsigned int timeout_sec;\r\nwdt_type = of_device_get_match_data(&ofdev->dev);\r\nif (!wdt_type)\r\nreturn -EINVAL;\r\nif (!freq || freq == -1)\r\nreturn -EINVAL;\r\nddata = devm_kzalloc(&ofdev->dev, sizeof(*ddata), GFP_KERNEL);\r\nif (!ddata)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(ofdev, IORESOURCE_MEM, 0);\r\nddata->base = devm_ioremap_resource(&ofdev->dev, res);\r\nif (IS_ERR(ddata->base))\r\nreturn PTR_ERR(ddata->base);\r\nenabled = in_be32(&ddata->base->swcrr) & SWCRR_SWEN;\r\nif (!enabled && wdt_type->hw_enabled) {\r\npr_info("could not be enabled in software\n");\r\nreturn -ENODEV;\r\n}\r\nspin_lock_init(&ddata->lock);\r\nsetup_timer(&ddata->timer, mpc8xxx_wdt_timer_ping,\r\n(unsigned long)ddata);\r\nddata->wdd.info = &mpc8xxx_wdt_info,\r\nddata->wdd.ops = &mpc8xxx_wdt_ops,\r\ntimeout_sec = (timeout * wdt_type->prescaler) / freq;\r\nddata->wdd.timeout = timeout_sec;\r\nwatchdog_set_nowayout(&ddata->wdd, nowayout);\r\nret = watchdog_register_device(&ddata->wdd);\r\nif (ret) {\r\npr_err("cannot register watchdog device (err=%d)\n", ret);\r\nreturn ret;\r\n}\r\npr_info("WDT driver for MPC8xxx initialized. mode:%s timeout=%d (%d seconds)\n",\r\nreset ? "reset" : "interrupt", timeout, timeout_sec);\r\nif (enabled)\r\nmod_timer(&ddata->timer, jiffies);\r\nplatform_set_drvdata(ofdev, ddata);\r\nreturn 0;\r\n}\r\nstatic int mpc8xxx_wdt_remove(struct platform_device *ofdev)\r\n{\r\nstruct mpc8xxx_wdt_ddata *ddata = platform_get_drvdata(ofdev);\r\npr_crit("Watchdog removed, expect the %s soon!\n",\r\nreset ? "reset" : "machine check exception");\r\ndel_timer_sync(&ddata->timer);\r\nwatchdog_unregister_device(&ddata->wdd);\r\nreturn 0;\r\n}\r\nstatic int __init mpc8xxx_wdt_init(void)\r\n{\r\nreturn platform_driver_register(&mpc8xxx_wdt_driver);\r\n}\r\nstatic void __exit mpc8xxx_wdt_exit(void)\r\n{\r\nplatform_driver_unregister(&mpc8xxx_wdt_driver);\r\n}
