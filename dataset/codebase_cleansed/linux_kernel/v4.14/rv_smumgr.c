bool rv_is_smc_ram_running(struct pp_smumgr *smumgr)\r\n{\r\nuint32_t mp1_fw_flags, reg;\r\nreg = soc15_get_register_offset(NBIF_HWID, 0,\r\nmmPCIE_INDEX2_BASE_IDX, mmPCIE_INDEX2);\r\ncgs_write_register(smumgr->device, reg,\r\n(MP1_Public | (smnMP1_FIRMWARE_FLAGS & 0xffffffff)));\r\nreg = soc15_get_register_offset(NBIF_HWID, 0,\r\nmmPCIE_DATA2_BASE_IDX, mmPCIE_DATA2);\r\nmp1_fw_flags = cgs_read_register(smumgr->device, reg);\r\nif (mp1_fw_flags & MP1_FIRMWARE_FLAGS__INTERRUPTS_ENABLED_MASK)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic uint32_t rv_wait_for_response(struct pp_smumgr *smumgr)\r\n{\r\nuint32_t reg;\r\nif (!rv_is_smc_ram_running(smumgr))\r\nreturn -EINVAL;\r\nreg = soc15_get_register_offset(MP1_HWID, 0,\r\nmmMP1_SMN_C2PMSG_90_BASE_IDX, mmMP1_SMN_C2PMSG_90);\r\nsmum_wait_for_register_unequal(smumgr, reg,\r\n0, MP1_C2PMSG_90__CONTENT_MASK);\r\nreturn cgs_read_register(smumgr->device, reg);\r\n}\r\nint rv_send_msg_to_smc_without_waiting(struct pp_smumgr *smumgr,\r\nuint16_t msg)\r\n{\r\nuint32_t reg;\r\nif (!rv_is_smc_ram_running(smumgr))\r\nreturn -EINVAL;\r\nreg = soc15_get_register_offset(MP1_HWID, 0,\r\nmmMP1_SMN_C2PMSG_66_BASE_IDX, mmMP1_SMN_C2PMSG_66);\r\ncgs_write_register(smumgr->device, reg, msg);\r\nreturn 0;\r\n}\r\nint rv_read_arg_from_smc(struct pp_smumgr *smumgr, uint32_t *arg)\r\n{\r\nuint32_t reg;\r\nreg = soc15_get_register_offset(MP1_HWID, 0,\r\nmmMP1_SMN_C2PMSG_82_BASE_IDX, mmMP1_SMN_C2PMSG_82);\r\n*arg = cgs_read_register(smumgr->device, reg);\r\nreturn 0;\r\n}\r\nint rv_send_msg_to_smc(struct pp_smumgr *smumgr, uint16_t msg)\r\n{\r\nuint32_t reg;\r\nrv_wait_for_response(smumgr);\r\nreg = soc15_get_register_offset(MP1_HWID, 0,\r\nmmMP1_SMN_C2PMSG_90_BASE_IDX, mmMP1_SMN_C2PMSG_90);\r\ncgs_write_register(smumgr->device, reg, 0);\r\nrv_send_msg_to_smc_without_waiting(smumgr, msg);\r\nif (rv_wait_for_response(smumgr) == 0)\r\nprintk("Failed to send Message %x.\n", msg);\r\nreturn 0;\r\n}\r\nint rv_send_msg_to_smc_with_parameter(struct pp_smumgr *smumgr,\r\nuint16_t msg, uint32_t parameter)\r\n{\r\nuint32_t reg;\r\nrv_wait_for_response(smumgr);\r\nreg = soc15_get_register_offset(MP1_HWID, 0,\r\nmmMP1_SMN_C2PMSG_90_BASE_IDX, mmMP1_SMN_C2PMSG_90);\r\ncgs_write_register(smumgr->device, reg, 0);\r\nreg = soc15_get_register_offset(MP1_HWID, 0,\r\nmmMP1_SMN_C2PMSG_82_BASE_IDX, mmMP1_SMN_C2PMSG_82);\r\ncgs_write_register(smumgr->device, reg, parameter);\r\nrv_send_msg_to_smc_without_waiting(smumgr, msg);\r\nif (rv_wait_for_response(smumgr) == 0)\r\nprintk("Failed to send Message %x.\n", msg);\r\nreturn 0;\r\n}\r\nint rv_copy_table_from_smc(struct pp_smumgr *smumgr,\r\nuint8_t *table, int16_t table_id)\r\n{\r\nstruct rv_smumgr *priv =\r\n(struct rv_smumgr *)(smumgr->backend);\r\nPP_ASSERT_WITH_CODE(table_id < MAX_SMU_TABLE,\r\n"Invalid SMU Table ID!", return -EINVAL;);\r\nPP_ASSERT_WITH_CODE(priv->smu_tables.entry[table_id].version != 0,\r\n"Invalid SMU Table version!", return -EINVAL;);\r\nPP_ASSERT_WITH_CODE(priv->smu_tables.entry[table_id].size != 0,\r\n"Invalid SMU Table Length!", return -EINVAL;);\r\nPP_ASSERT_WITH_CODE(rv_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_SetDriverDramAddrHigh,\r\npriv->smu_tables.entry[table_id].table_addr_high) == 0,\r\n"[CopyTableFromSMC] Attempt to Set Dram Addr High Failed!", return -EINVAL;);\r\nPP_ASSERT_WITH_CODE(rv_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_SetDriverDramAddrLow,\r\npriv->smu_tables.entry[table_id].table_addr_low) == 0,\r\n"[CopyTableFromSMC] Attempt to Set Dram Addr Low Failed!",\r\nreturn -EINVAL;);\r\nPP_ASSERT_WITH_CODE(rv_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_TransferTableSmu2Dram,\r\npriv->smu_tables.entry[table_id].table_id) == 0,\r\n"[CopyTableFromSMC] Attempt to Transfer Table From SMU Failed!",\r\nreturn -EINVAL;);\r\nmemcpy(table, priv->smu_tables.entry[table_id].table,\r\npriv->smu_tables.entry[table_id].size);\r\nreturn 0;\r\n}\r\nint rv_copy_table_to_smc(struct pp_smumgr *smumgr,\r\nuint8_t *table, int16_t table_id)\r\n{\r\nstruct rv_smumgr *priv =\r\n(struct rv_smumgr *)(smumgr->backend);\r\nPP_ASSERT_WITH_CODE(table_id < MAX_SMU_TABLE,\r\n"Invalid SMU Table ID!", return -EINVAL;);\r\nPP_ASSERT_WITH_CODE(priv->smu_tables.entry[table_id].version != 0,\r\n"Invalid SMU Table version!", return -EINVAL;);\r\nPP_ASSERT_WITH_CODE(priv->smu_tables.entry[table_id].size != 0,\r\n"Invalid SMU Table Length!", return -EINVAL;);\r\nmemcpy(priv->smu_tables.entry[table_id].table, table,\r\npriv->smu_tables.entry[table_id].size);\r\nPP_ASSERT_WITH_CODE(rv_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_SetDriverDramAddrHigh,\r\npriv->smu_tables.entry[table_id].table_addr_high) == 0,\r\n"[CopyTableToSMC] Attempt to Set Dram Addr High Failed!",\r\nreturn -EINVAL;);\r\nPP_ASSERT_WITH_CODE(rv_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_SetDriverDramAddrLow,\r\npriv->smu_tables.entry[table_id].table_addr_low) == 0,\r\n"[CopyTableToSMC] Attempt to Set Dram Addr Low Failed!",\r\nreturn -EINVAL;);\r\nPP_ASSERT_WITH_CODE(rv_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_TransferTableDram2Smu,\r\npriv->smu_tables.entry[table_id].table_id) == 0,\r\n"[CopyTableToSMC] Attempt to Transfer Table To SMU Failed!",\r\nreturn -EINVAL;);\r\nreturn 0;\r\n}\r\nstatic int rv_verify_smc_interface(struct pp_smumgr *smumgr)\r\n{\r\nuint32_t smc_driver_if_version;\r\nPP_ASSERT_WITH_CODE(!rv_send_msg_to_smc(smumgr,\r\nPPSMC_MSG_GetDriverIfVersion),\r\n"Attempt to get SMC IF Version Number Failed!",\r\nreturn -EINVAL);\r\nPP_ASSERT_WITH_CODE(!rv_read_arg_from_smc(smumgr,\r\n&smc_driver_if_version),\r\n"Attempt to read SMC IF Version Number Failed!",\r\nreturn -EINVAL);\r\nif (smc_driver_if_version != SMU10_DRIVER_IF_VERSION)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int rv_smc_enable_sdma(struct pp_smumgr *smumgr)\r\n{\r\nPP_ASSERT_WITH_CODE(!rv_send_msg_to_smc(smumgr,\r\nPPSMC_MSG_PowerUpSdma),\r\n"Attempt to power up sdma Failed!",\r\nreturn -EINVAL);\r\nreturn 0;\r\n}\r\nstatic int rv_smc_disable_sdma(struct pp_smumgr *smumgr)\r\n{\r\nPP_ASSERT_WITH_CODE(!rv_send_msg_to_smc(smumgr,\r\nPPSMC_MSG_PowerDownSdma),\r\n"Attempt to power down sdma Failed!",\r\nreturn -EINVAL);\r\nreturn 0;\r\n}\r\nstatic int rv_smc_enable_vcn(struct pp_smumgr *smumgr)\r\n{\r\nPP_ASSERT_WITH_CODE(!rv_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_PowerUpVcn, 0),\r\n"Attempt to power up vcn Failed!",\r\nreturn -EINVAL);\r\nreturn 0;\r\n}\r\nstatic int rv_smc_disable_vcn(struct pp_smumgr *smumgr)\r\n{\r\nPP_ASSERT_WITH_CODE(!rv_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_PowerDownVcn, 0),\r\n"Attempt to power down vcn Failed!",\r\nreturn -EINVAL);\r\nreturn 0;\r\n}\r\nstatic int rv_smu_fini(struct pp_smumgr *smumgr)\r\n{\r\nstruct rv_smumgr *priv =\r\n(struct rv_smumgr *)(smumgr->backend);\r\nif (priv) {\r\nrv_smc_disable_sdma(smumgr);\r\nrv_smc_disable_vcn(smumgr);\r\ncgs_free_gpu_mem(smumgr->device,\r\npriv->smu_tables.entry[WMTABLE].handle);\r\ncgs_free_gpu_mem(smumgr->device,\r\npriv->smu_tables.entry[CLOCKTABLE].handle);\r\nkfree(smumgr->backend);\r\nsmumgr->backend = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rv_start_smu(struct pp_smumgr *smumgr)\r\n{\r\nif (rv_verify_smc_interface(smumgr))\r\nreturn -EINVAL;\r\nif (rv_smc_enable_sdma(smumgr))\r\nreturn -EINVAL;\r\nif (rv_smc_enable_vcn(smumgr))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int rv_smu_init(struct pp_smumgr *smumgr)\r\n{\r\nstruct rv_smumgr *priv;\r\nuint64_t mc_addr;\r\nvoid *kaddr = NULL;\r\nunsigned long handle;\r\npriv = kzalloc(sizeof(struct rv_smumgr), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nsmumgr->backend = priv;\r\nsmu_allocate_memory(smumgr->device,\r\nsizeof(Watermarks_t),\r\nCGS_GPU_MEM_TYPE__GART_CACHEABLE,\r\nPAGE_SIZE,\r\n&mc_addr,\r\n&kaddr,\r\n&handle);\r\nPP_ASSERT_WITH_CODE(kaddr,\r\n"[rv_smu_init] Out of memory for wmtable.",\r\nkfree(smumgr->backend);\r\nsmumgr->backend = NULL;\r\nreturn -EINVAL);\r\npriv->smu_tables.entry[WMTABLE].version = 0x01;\r\npriv->smu_tables.entry[WMTABLE].size = sizeof(Watermarks_t);\r\npriv->smu_tables.entry[WMTABLE].table_id = TABLE_WATERMARKS;\r\npriv->smu_tables.entry[WMTABLE].table_addr_high =\r\nsmu_upper_32_bits(mc_addr);\r\npriv->smu_tables.entry[WMTABLE].table_addr_low =\r\nsmu_lower_32_bits(mc_addr);\r\npriv->smu_tables.entry[WMTABLE].table = kaddr;\r\npriv->smu_tables.entry[WMTABLE].handle = handle;\r\nsmu_allocate_memory(smumgr->device,\r\nsizeof(DpmClocks_t),\r\nCGS_GPU_MEM_TYPE__GART_CACHEABLE,\r\nPAGE_SIZE,\r\n&mc_addr,\r\n&kaddr,\r\n&handle);\r\nPP_ASSERT_WITH_CODE(kaddr,\r\n"[rv_smu_init] Out of memory for CLOCKTABLE.",\r\ncgs_free_gpu_mem(smumgr->device,\r\n(cgs_handle_t)priv->smu_tables.entry[WMTABLE].handle);\r\nkfree(smumgr->backend);\r\nsmumgr->backend = NULL;\r\nreturn -EINVAL);\r\npriv->smu_tables.entry[CLOCKTABLE].version = 0x01;\r\npriv->smu_tables.entry[CLOCKTABLE].size = sizeof(DpmClocks_t);\r\npriv->smu_tables.entry[CLOCKTABLE].table_id = TABLE_DPMCLOCKS;\r\npriv->smu_tables.entry[CLOCKTABLE].table_addr_high =\r\nsmu_upper_32_bits(mc_addr);\r\npriv->smu_tables.entry[CLOCKTABLE].table_addr_low =\r\nsmu_lower_32_bits(mc_addr);\r\npriv->smu_tables.entry[CLOCKTABLE].table = kaddr;\r\npriv->smu_tables.entry[CLOCKTABLE].handle = handle;\r\nreturn 0;\r\n}
