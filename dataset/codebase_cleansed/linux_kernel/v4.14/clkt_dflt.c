static int _wait_idlest_generic(struct clk_hw_omap *clk,\r\nstruct clk_omap_reg *reg,\r\nu32 mask, u8 idlest, const char *name)\r\n{\r\nint i = 0, ena = 0;\r\nena = (idlest) ? 0 : mask;\r\nfor (i = 0; i < MAX_MODULE_ENABLE_WAIT; i++) {\r\nif ((ti_clk_ll_ops->clk_readl(reg) & mask) == ena)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (i < MAX_MODULE_ENABLE_WAIT)\r\npr_debug("omap clock: module associated with clock %s ready after %d loops\n",\r\nname, i);\r\nelse\r\npr_err("omap clock: module associated with clock %s didn't enable in %d tries\n",\r\nname, MAX_MODULE_ENABLE_WAIT);\r\nreturn (i < MAX_MODULE_ENABLE_WAIT) ? 1 : 0;\r\n}\r\nstatic void _omap2_module_wait_ready(struct clk_hw_omap *clk)\r\n{\r\nstruct clk_omap_reg companion_reg, idlest_reg;\r\nu8 other_bit, idlest_bit, idlest_val, idlest_reg_id;\r\ns16 prcm_mod;\r\nint r;\r\nif (clk->ops->find_companion) {\r\nclk->ops->find_companion(clk, &companion_reg, &other_bit);\r\nif (!(ti_clk_ll_ops->clk_readl(&companion_reg) &\r\n(1 << other_bit)))\r\nreturn;\r\n}\r\nclk->ops->find_idlest(clk, &idlest_reg, &idlest_bit, &idlest_val);\r\nr = ti_clk_ll_ops->cm_split_idlest_reg(&idlest_reg, &prcm_mod,\r\n&idlest_reg_id);\r\nif (r) {\r\n_wait_idlest_generic(clk, &idlest_reg, (1 << idlest_bit),\r\nidlest_val, clk_hw_get_name(&clk->hw));\r\n} else {\r\nti_clk_ll_ops->cm_wait_module_ready(0, prcm_mod, idlest_reg_id,\r\nidlest_bit);\r\n}\r\n}\r\nvoid omap2_clk_dflt_find_companion(struct clk_hw_omap *clk,\r\nstruct clk_omap_reg *other_reg,\r\nu8 *other_bit)\r\n{\r\nmemcpy(other_reg, &clk->enable_reg, sizeof(*other_reg));\r\nother_reg->offset ^= (CM_FCLKEN ^ CM_ICLKEN);\r\n*other_bit = clk->enable_bit;\r\n}\r\nvoid omap2_clk_dflt_find_idlest(struct clk_hw_omap *clk,\r\nstruct clk_omap_reg *idlest_reg, u8 *idlest_bit,\r\nu8 *idlest_val)\r\n{\r\nmemcpy(idlest_reg, &clk->enable_reg, sizeof(*idlest_reg));\r\nidlest_reg->offset &= ~0xf0;\r\nidlest_reg->offset |= 0x20;\r\n*idlest_bit = clk->enable_bit;\r\n*idlest_val = ti_clk_get_features()->cm_idlest_val;\r\n}\r\nint omap2_dflt_clk_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *clk;\r\nu32 v;\r\nint ret = 0;\r\nbool clkdm_control;\r\nif (ti_clk_get_features()->flags & TI_CLK_DISABLE_CLKDM_CONTROL)\r\nclkdm_control = false;\r\nelse\r\nclkdm_control = true;\r\nclk = to_clk_hw_omap(hw);\r\nif (clkdm_control && clk->clkdm) {\r\nret = ti_clk_ll_ops->clkdm_clk_enable(clk->clkdm, hw->clk);\r\nif (ret) {\r\nWARN(1,\r\n"%s: could not enable %s's clockdomain %s: %d\n",\r\n__func__, clk_hw_get_name(hw),\r\nclk->clkdm_name, ret);\r\nreturn ret;\r\n}\r\n}\r\nv = ti_clk_ll_ops->clk_readl(&clk->enable_reg);\r\nif (clk->flags & INVERT_ENABLE)\r\nv &= ~(1 << clk->enable_bit);\r\nelse\r\nv |= (1 << clk->enable_bit);\r\nti_clk_ll_ops->clk_writel(v, &clk->enable_reg);\r\nv = ti_clk_ll_ops->clk_readl(&clk->enable_reg);\r\nif (clk->ops && clk->ops->find_idlest)\r\n_omap2_module_wait_ready(clk);\r\nreturn 0;\r\n}\r\nvoid omap2_dflt_clk_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *clk;\r\nu32 v;\r\nclk = to_clk_hw_omap(hw);\r\nv = ti_clk_ll_ops->clk_readl(&clk->enable_reg);\r\nif (clk->flags & INVERT_ENABLE)\r\nv |= (1 << clk->enable_bit);\r\nelse\r\nv &= ~(1 << clk->enable_bit);\r\nti_clk_ll_ops->clk_writel(v, &clk->enable_reg);\r\nif (!(ti_clk_get_features()->flags & TI_CLK_DISABLE_CLKDM_CONTROL) &&\r\nclk->clkdm)\r\nti_clk_ll_ops->clkdm_clk_disable(clk->clkdm, hw->clk);\r\n}\r\nint omap2_dflt_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nu32 v;\r\nv = ti_clk_ll_ops->clk_readl(&clk->enable_reg);\r\nif (clk->flags & INVERT_ENABLE)\r\nv ^= BIT(clk->enable_bit);\r\nv &= BIT(clk->enable_bit);\r\nreturn v ? 1 : 0;\r\n}
