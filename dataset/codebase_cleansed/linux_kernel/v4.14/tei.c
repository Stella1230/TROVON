static unsigned int\r\nrandom_ri(void)\r\n{\r\nunsigned int x;\r\nget_random_bytes(&x, sizeof(x));\r\nreturn (x & 0xffff);\r\n}\r\nstatic struct PStack *\r\nfindtei(struct PStack *st, int tei)\r\n{\r\nstruct PStack *ptr = *(st->l1.stlistp);\r\nif (tei == 127)\r\nreturn (NULL);\r\nwhile (ptr)\r\nif (ptr->l2.tei == tei)\r\nreturn (ptr);\r\nelse\r\nptr = ptr->next;\r\nreturn (NULL);\r\n}\r\nstatic void\r\nput_tei_msg(struct PStack *st, u_char m_id, unsigned int ri, u_char tei)\r\n{\r\nstruct sk_buff *skb;\r\nu_char *bp;\r\nif (!(skb = alloc_skb(8, GFP_ATOMIC))) {\r\nprintk(KERN_WARNING "HiSax: No skb for TEI manager\n");\r\nreturn;\r\n}\r\nbp = skb_put(skb, 3);\r\nbp[0] = (TEI_SAPI << 2);\r\nbp[1] = (GROUP_TEI << 1) | 0x1;\r\nbp[2] = UI;\r\nbp = skb_put(skb, 5);\r\nbp[0] = TEI_ENTITY_ID;\r\nbp[1] = ri >> 8;\r\nbp[2] = ri & 0xff;\r\nbp[3] = m_id;\r\nbp[4] = (tei << 1) | 1;\r\nst->l2.l2l1(st, PH_DATA | REQUEST, skb);\r\n}\r\nstatic void\r\ntei_id_request(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nif (st->l2.tei != -1) {\r\nst->ma.tei_m.printdebug(&st->ma.tei_m,\r\n"assign request for already assigned tei %d",\r\nst->l2.tei);\r\nreturn;\r\n}\r\nst->ma.ri = random_ri();\r\nif (st->ma.debug)\r\nst->ma.tei_m.printdebug(&st->ma.tei_m,\r\n"assign request ri %d", st->ma.ri);\r\nput_tei_msg(st, ID_REQUEST, st->ma.ri, 127);\r\nFsmChangeState(&st->ma.tei_m, ST_TEI_IDREQ);\r\nFsmAddTimer(&st->ma.t202, st->ma.T202, EV_T202, NULL, 1);\r\nst->ma.N202 = 3;\r\n}\r\nstatic void\r\ntei_id_assign(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *ost, *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nstruct IsdnCardState *cs;\r\nint ri, tei;\r\nri = ((unsigned int) skb->data[1] << 8) + skb->data[2];\r\ntei = skb->data[4] >> 1;\r\nif (st->ma.debug)\r\nst->ma.tei_m.printdebug(&st->ma.tei_m,\r\n"identity assign ri %d tei %d", ri, tei);\r\nif ((ost = findtei(st, tei))) {\r\nif (ri != ost->ma.ri) {\r\nst->ma.tei_m.printdebug(&st->ma.tei_m,\r\n"possible duplicate assignment tei %d", tei);\r\nost->l2.l2tei(ost, MDL_ERROR | RESPONSE, NULL);\r\n}\r\n} else if (ri == st->ma.ri) {\r\nFsmDelTimer(&st->ma.t202, 1);\r\nFsmChangeState(&st->ma.tei_m, ST_TEI_NOP);\r\nst->l3.l3l2(st, MDL_ASSIGN | REQUEST, (void *) (long) tei);\r\ncs = (struct IsdnCardState *) st->l1.hardware;\r\ncs->cardmsg(cs, MDL_ASSIGN | REQUEST, NULL);\r\n}\r\n}\r\nstatic void\r\ntei_id_test_dup(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *ost, *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nint tei, ri;\r\nri = ((unsigned int) skb->data[1] << 8) + skb->data[2];\r\ntei = skb->data[4] >> 1;\r\nif (st->ma.debug)\r\nst->ma.tei_m.printdebug(&st->ma.tei_m,\r\n"foreign identity assign ri %d tei %d", ri, tei);\r\nif ((ost = findtei(st, tei))) {\r\nif (ri != ost->ma.ri) {\r\nst->ma.tei_m.printdebug(&st->ma.tei_m,\r\n"possible duplicate assignment tei %d", tei);\r\nFsmEvent(&ost->ma.tei_m, EV_VERIFY, NULL);\r\n}\r\n}\r\n}\r\nstatic void\r\ntei_id_denied(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nint ri, tei;\r\nri = ((unsigned int) skb->data[1] << 8) + skb->data[2];\r\ntei = skb->data[4] >> 1;\r\nif (st->ma.debug)\r\nst->ma.tei_m.printdebug(&st->ma.tei_m,\r\n"identity denied ri %d tei %d", ri, tei);\r\n}\r\nstatic void\r\ntei_id_chk_req(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nint tei;\r\ntei = skb->data[4] >> 1;\r\nif (st->ma.debug)\r\nst->ma.tei_m.printdebug(&st->ma.tei_m,\r\n"identity check req tei %d", tei);\r\nif ((st->l2.tei != -1) && ((tei == GROUP_TEI) || (tei == st->l2.tei))) {\r\nFsmDelTimer(&st->ma.t202, 4);\r\nFsmChangeState(&st->ma.tei_m, ST_TEI_NOP);\r\nput_tei_msg(st, ID_CHK_RES, random_ri(), st->l2.tei);\r\n}\r\n}\r\nstatic void\r\ntei_id_remove(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nstruct IsdnCardState *cs;\r\nint tei;\r\ntei = skb->data[4] >> 1;\r\nif (st->ma.debug)\r\nst->ma.tei_m.printdebug(&st->ma.tei_m,\r\n"identity remove tei %d", tei);\r\nif ((st->l2.tei != -1) && ((tei == GROUP_TEI) || (tei == st->l2.tei))) {\r\nFsmDelTimer(&st->ma.t202, 5);\r\nFsmChangeState(&st->ma.tei_m, ST_TEI_NOP);\r\nst->l3.l3l2(st, MDL_REMOVE | REQUEST, NULL);\r\ncs = (struct IsdnCardState *) st->l1.hardware;\r\ncs->cardmsg(cs, MDL_REMOVE | REQUEST, NULL);\r\n}\r\n}\r\nstatic void\r\ntei_id_verify(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nif (st->ma.debug)\r\nst->ma.tei_m.printdebug(&st->ma.tei_m,\r\n"id verify request for tei %d", st->l2.tei);\r\nput_tei_msg(st, ID_VERIFY, 0, st->l2.tei);\r\nFsmChangeState(&st->ma.tei_m, ST_TEI_IDVERIFY);\r\nFsmAddTimer(&st->ma.t202, st->ma.T202, EV_T202, NULL, 2);\r\nst->ma.N202 = 2;\r\n}\r\nstatic void\r\ntei_id_req_tout(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct IsdnCardState *cs;\r\nif (--st->ma.N202) {\r\nst->ma.ri = random_ri();\r\nif (st->ma.debug)\r\nst->ma.tei_m.printdebug(&st->ma.tei_m,\r\n"assign req(%d) ri %d", 4 - st->ma.N202,\r\nst->ma.ri);\r\nput_tei_msg(st, ID_REQUEST, st->ma.ri, 127);\r\nFsmAddTimer(&st->ma.t202, st->ma.T202, EV_T202, NULL, 3);\r\n} else {\r\nst->ma.tei_m.printdebug(&st->ma.tei_m, "assign req failed");\r\nst->l3.l3l2(st, MDL_ERROR | RESPONSE, NULL);\r\ncs = (struct IsdnCardState *) st->l1.hardware;\r\ncs->cardmsg(cs, MDL_REMOVE | REQUEST, NULL);\r\nFsmChangeState(fi, ST_TEI_NOP);\r\n}\r\n}\r\nstatic void\r\ntei_id_ver_tout(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct IsdnCardState *cs;\r\nif (--st->ma.N202) {\r\nif (st->ma.debug)\r\nst->ma.tei_m.printdebug(&st->ma.tei_m,\r\n"id verify req(%d) for tei %d",\r\n3 - st->ma.N202, st->l2.tei);\r\nput_tei_msg(st, ID_VERIFY, 0, st->l2.tei);\r\nFsmAddTimer(&st->ma.t202, st->ma.T202, EV_T202, NULL, 4);\r\n} else {\r\nst->ma.tei_m.printdebug(&st->ma.tei_m,\r\n"verify req for tei %d failed", st->l2.tei);\r\nst->l3.l3l2(st, MDL_REMOVE | REQUEST, NULL);\r\ncs = (struct IsdnCardState *) st->l1.hardware;\r\ncs->cardmsg(cs, MDL_REMOVE | REQUEST, NULL);\r\nFsmChangeState(fi, ST_TEI_NOP);\r\n}\r\n}\r\nstatic void\r\ntei_l1l2(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nint mt;\r\nif (test_bit(FLG_FIXED_TEI, &st->l2.flag)) {\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nif (pr == (PH_DATA | INDICATION)) {\r\nif (skb->len < 3) {\r\nst->ma.tei_m.printdebug(&st->ma.tei_m,\r\n"short mgr frame %ld/3", skb->len);\r\n} else if ((skb->data[0] != ((TEI_SAPI << 2) | 2)) ||\r\n(skb->data[1] != ((GROUP_TEI << 1) | 1))) {\r\nst->ma.tei_m.printdebug(&st->ma.tei_m,\r\n"wrong mgr sapi/tei %x/%x",\r\nskb->data[0], skb->data[1]);\r\n} else if ((skb->data[2] & 0xef) != UI) {\r\nst->ma.tei_m.printdebug(&st->ma.tei_m,\r\n"mgr frame is not ui %x", skb->data[2]);\r\n} else {\r\nskb_pull(skb, 3);\r\nif (skb->len < 5) {\r\nst->ma.tei_m.printdebug(&st->ma.tei_m,\r\n"short mgr frame %ld/5", skb->len);\r\n} else if (skb->data[0] != TEI_ENTITY_ID) {\r\nst->ma.tei_m.printdebug(&st->ma.tei_m,\r\n"tei handler wrong entity id %x",\r\nskb->data[0]);\r\n} else {\r\nmt = skb->data[3];\r\nif (mt == ID_ASSIGNED)\r\nFsmEvent(&st->ma.tei_m, EV_ASSIGN, skb);\r\nelse if (mt == ID_DENIED)\r\nFsmEvent(&st->ma.tei_m, EV_DENIED, skb);\r\nelse if (mt == ID_CHK_REQ)\r\nFsmEvent(&st->ma.tei_m, EV_CHKREQ, skb);\r\nelse if (mt == ID_REMOVE)\r\nFsmEvent(&st->ma.tei_m, EV_REMOVE, skb);\r\nelse {\r\nst->ma.tei_m.printdebug(&st->ma.tei_m,\r\n"tei handler wrong mt %x\n", mt);\r\n}\r\n}\r\n}\r\n} else {\r\nst->ma.tei_m.printdebug(&st->ma.tei_m,\r\n"tei handler wrong pr %x\n", pr);\r\n}\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void\r\ntei_l2tei(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct IsdnCardState *cs;\r\nif (test_bit(FLG_FIXED_TEI, &st->l2.flag)) {\r\nif (pr == (MDL_ASSIGN | INDICATION)) {\r\nif (st->ma.debug)\r\nst->ma.tei_m.printdebug(&st->ma.tei_m,\r\n"fixed assign tei %d", st->l2.tei);\r\nst->l3.l3l2(st, MDL_ASSIGN | REQUEST, (void *) (long) st->l2.tei);\r\ncs = (struct IsdnCardState *) st->l1.hardware;\r\ncs->cardmsg(cs, MDL_ASSIGN | REQUEST, NULL);\r\n}\r\nreturn;\r\n}\r\nswitch (pr) {\r\ncase (MDL_ASSIGN | INDICATION):\r\nFsmEvent(&st->ma.tei_m, EV_IDREQ, arg);\r\nbreak;\r\ncase (MDL_ERROR | REQUEST):\r\nFsmEvent(&st->ma.tei_m, EV_VERIFY, arg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ntei_debug(struct FsmInst *fi, char *fmt, ...)\r\n{\r\nva_list args;\r\nstruct PStack *st = fi->userdata;\r\nva_start(args, fmt);\r\nVHiSax_putstatus(st->l1.hardware, "tei ", fmt, args);\r\nva_end(args);\r\n}\r\nvoid\r\nsetstack_tei(struct PStack *st)\r\n{\r\nst->l2.l2tei = tei_l2tei;\r\nst->ma.T202 = 2000;\r\nst->l1.l1tei = tei_l1l2;\r\nst->ma.debug = 1;\r\nst->ma.tei_m.fsm = &teifsm;\r\nst->ma.tei_m.state = ST_TEI_NOP;\r\nst->ma.tei_m.debug = 1;\r\nst->ma.tei_m.userdata = st;\r\nst->ma.tei_m.userint = 0;\r\nst->ma.tei_m.printdebug = tei_debug;\r\nFsmInitTimer(&st->ma.tei_m, &st->ma.t202);\r\n}\r\nvoid\r\ninit_tei(struct IsdnCardState *cs, int protocol)\r\n{\r\n}\r\nvoid\r\nrelease_tei(struct IsdnCardState *cs)\r\n{\r\nstruct PStack *st = cs->stlist;\r\nwhile (st) {\r\nFsmDelTimer(&st->ma.t202, 1);\r\nst = st->next;\r\n}\r\n}\r\nint __init\r\nTeiNew(void)\r\n{\r\nteifsm.state_count = TEI_STATE_COUNT;\r\nteifsm.event_count = TEI_EVENT_COUNT;\r\nteifsm.strEvent = strTeiEvent;\r\nteifsm.strState = strTeiState;\r\nreturn FsmNew(&teifsm, TeiFnList, ARRAY_SIZE(TeiFnList));\r\n}\r\nvoid\r\nTeiFree(void)\r\n{\r\nFsmFree(&teifsm);\r\n}
