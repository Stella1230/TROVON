static int ti_adc_read_measurement(struct ti_adc_data *data,\r\nstruct iio_chan_spec const *chan, int *val)\r\n{\r\nint ret;\r\nswitch (data->read_size) {\r\ncase 2: {\r\n__be16 buf;\r\nret = spi_read(data->spi, (void *) &buf, 2);\r\nif (ret)\r\nreturn ret;\r\n*val = be16_to_cpu(buf);\r\nbreak;\r\n}\r\ncase 3: {\r\n__be32 buf;\r\nret = spi_read(data->spi, (void *) &buf, 3);\r\nif (ret)\r\nreturn ret;\r\n*val = be32_to_cpu(buf) >> 8;\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*val = sign_extend32(*val >> data->shift, chan->scan_type.realbits - 1);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ti_adc_trigger_handler(int irq, void *private)\r\n{\r\nstruct iio_poll_func *pf = private;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nstruct ti_adc_data *data = iio_priv(indio_dev);\r\nint ret;\r\nret = ti_adc_read_measurement(data, &indio_dev->channels[0],\r\n(int *) &data->buffer);\r\nif (!ret)\r\niio_push_to_buffers_with_timestamp(indio_dev,\r\ndata->buffer,\r\niio_get_time_ns(indio_dev));\r\niio_trigger_notify_done(indio_dev->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ti_adc_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct ti_adc_data *data = iio_priv(indio_dev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nret = iio_device_claim_direct_mode(indio_dev);\r\nif (ret)\r\nreturn ret;\r\nret = ti_adc_read_measurement(data, chan, val);\r\niio_device_release_direct_mode(indio_dev);\r\nif (ret)\r\nreturn ret;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nret = regulator_get_voltage(data->ref);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret / 1000;\r\n*val2 = chan->scan_type.realbits;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ncase IIO_CHAN_INFO_OFFSET:\r\n*val = 1 << (chan->scan_type.realbits - 1);\r\nreturn IIO_VAL_INT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ti_adc_probe(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev;\r\nstruct ti_adc_data *data;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nindio_dev->info = &ti_adc_info;\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->dev.of_node = spi->dev.of_node;\r\nindio_dev->name = TI_ADC_DRV_NAME;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nspi_set_drvdata(spi, indio_dev);\r\ndata = iio_priv(indio_dev);\r\ndata->spi = spi;\r\nswitch (spi_get_device_id(spi)->driver_data) {\r\ncase TI_ADC141S626:\r\nindio_dev->channels = ti_adc141s626_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(ti_adc141s626_channels);\r\ndata->shift = 0;\r\ndata->read_size = 2;\r\nbreak;\r\ncase TI_ADC161S626:\r\nindio_dev->channels = ti_adc161s626_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(ti_adc161s626_channels);\r\ndata->shift = 6;\r\ndata->read_size = 3;\r\nbreak;\r\n}\r\ndata->ref = devm_regulator_get(&spi->dev, "vdda");\r\nif (!IS_ERR(data->ref)) {\r\nret = regulator_enable(data->ref);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = iio_triggered_buffer_setup(indio_dev, NULL,\r\nti_adc_trigger_handler, NULL);\r\nif (ret)\r\ngoto error_regulator_disable;\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_unreg_buffer;\r\nreturn 0;\r\nerror_unreg_buffer:\r\niio_triggered_buffer_cleanup(indio_dev);\r\nerror_regulator_disable:\r\nregulator_disable(data->ref);\r\nreturn ret;\r\n}\r\nstatic int ti_adc_remove(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev = spi_get_drvdata(spi);\r\nstruct ti_adc_data *data = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\niio_triggered_buffer_cleanup(indio_dev);\r\nregulator_disable(data->ref);\r\nreturn 0;\r\n}
