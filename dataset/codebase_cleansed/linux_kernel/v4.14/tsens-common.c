char *qfprom_read(struct device *dev, const char *cname)\r\n{\r\nstruct nvmem_cell *cell;\r\nssize_t data;\r\nchar *ret;\r\ncell = nvmem_cell_get(dev, cname);\r\nif (IS_ERR(cell))\r\nreturn ERR_CAST(cell);\r\nret = nvmem_cell_read(cell, &data);\r\nnvmem_cell_put(cell);\r\nreturn ret;\r\n}\r\nvoid compute_intercept_slope(struct tsens_device *tmdev, u32 *p1,\r\nu32 *p2, u32 mode)\r\n{\r\nint i;\r\nint num, den;\r\nfor (i = 0; i < tmdev->num_sensors; i++) {\r\ndev_dbg(tmdev->dev,\r\n"sensor%d - data_point1:%#x data_point2:%#x\n",\r\ni, p1[i], p2[i]);\r\ntmdev->sensor[i].slope = SLOPE_DEFAULT;\r\nif (mode == TWO_PT_CALIB) {\r\nnum = p2[i] - p1[i];\r\nnum *= SLOPE_FACTOR;\r\nden = CAL_DEGC_PT2 - CAL_DEGC_PT1;\r\ntmdev->sensor[i].slope = num / den;\r\n}\r\ntmdev->sensor[i].offset = (p1[i] * SLOPE_FACTOR) -\r\n(CAL_DEGC_PT1 *\r\ntmdev->sensor[i].slope);\r\ndev_dbg(tmdev->dev, "offset:%d\n", tmdev->sensor[i].offset);\r\n}\r\n}\r\nstatic inline int code_to_degc(u32 adc_code, const struct tsens_sensor *s)\r\n{\r\nint degc, num, den;\r\nnum = (adc_code * SLOPE_FACTOR) - s->offset;\r\nden = s->slope;\r\nif (num > 0)\r\ndegc = num + (den / 2);\r\nelse if (num < 0)\r\ndegc = num - (den / 2);\r\nelse\r\ndegc = num;\r\ndegc /= den;\r\nreturn degc;\r\n}\r\nint get_temp_common(struct tsens_device *tmdev, int id, int *temp)\r\n{\r\nstruct tsens_sensor *s = &tmdev->sensor[id];\r\nu32 code;\r\nunsigned int sensor_addr;\r\nint last_temp = 0, ret;\r\nsensor_addr = S0_ST_ADDR + s->hw_id * SN_ADDR_OFFSET;\r\nret = regmap_read(tmdev->map, sensor_addr, &code);\r\nif (ret)\r\nreturn ret;\r\nlast_temp = code & SN_ST_TEMP_MASK;\r\n*temp = code_to_degc(last_temp, s) * 1000;\r\nreturn 0;\r\n}\r\nint __init init_common(struct tsens_device *tmdev)\r\n{\r\nvoid __iomem *base;\r\nbase = of_iomap(tmdev->dev->of_node, 0);\r\nif (!base)\r\nreturn -EINVAL;\r\ntmdev->map = devm_regmap_init_mmio(tmdev->dev, base, &tsens_config);\r\nif (IS_ERR(tmdev->map)) {\r\niounmap(base);\r\nreturn PTR_ERR(tmdev->map);\r\n}\r\nreturn 0;\r\n}
