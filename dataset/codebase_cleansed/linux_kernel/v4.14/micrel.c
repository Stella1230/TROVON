static int kszphy_extended_write(struct phy_device *phydev,\r\nu32 regnum, u16 val)\r\n{\r\nphy_write(phydev, MII_KSZPHY_EXTREG, KSZPHY_EXTREG_WRITE | regnum);\r\nreturn phy_write(phydev, MII_KSZPHY_EXTREG_WRITE, val);\r\n}\r\nstatic int kszphy_extended_read(struct phy_device *phydev,\r\nu32 regnum)\r\n{\r\nphy_write(phydev, MII_KSZPHY_EXTREG, regnum);\r\nreturn phy_read(phydev, MII_KSZPHY_EXTREG_READ);\r\n}\r\nstatic int kszphy_ack_interrupt(struct phy_device *phydev)\r\n{\r\nint rc;\r\nrc = phy_read(phydev, MII_KSZPHY_INTCS);\r\nreturn (rc < 0) ? rc : 0;\r\n}\r\nstatic int kszphy_config_intr(struct phy_device *phydev)\r\n{\r\nconst struct kszphy_type *type = phydev->drv->driver_data;\r\nint temp;\r\nu16 mask;\r\nif (type && type->interrupt_level_mask)\r\nmask = type->interrupt_level_mask;\r\nelse\r\nmask = KSZPHY_CTRL_INT_ACTIVE_HIGH;\r\ntemp = phy_read(phydev, MII_KSZPHY_CTRL);\r\nif (temp < 0)\r\nreturn temp;\r\ntemp &= ~mask;\r\nphy_write(phydev, MII_KSZPHY_CTRL, temp);\r\nif (phydev->interrupts == PHY_INTERRUPT_ENABLED)\r\ntemp = KSZPHY_INTCS_ALL;\r\nelse\r\ntemp = 0;\r\nreturn phy_write(phydev, MII_KSZPHY_INTCS, temp);\r\n}\r\nstatic int kszphy_rmii_clk_sel(struct phy_device *phydev, bool val)\r\n{\r\nint ctrl;\r\nctrl = phy_read(phydev, MII_KSZPHY_CTRL);\r\nif (ctrl < 0)\r\nreturn ctrl;\r\nif (val)\r\nctrl |= KSZPHY_RMII_REF_CLK_SEL;\r\nelse\r\nctrl &= ~KSZPHY_RMII_REF_CLK_SEL;\r\nreturn phy_write(phydev, MII_KSZPHY_CTRL, ctrl);\r\n}\r\nstatic int kszphy_setup_led(struct phy_device *phydev, u32 reg, int val)\r\n{\r\nint rc, temp, shift;\r\nswitch (reg) {\r\ncase MII_KSZPHY_CTRL_1:\r\nshift = 14;\r\nbreak;\r\ncase MII_KSZPHY_CTRL_2:\r\nshift = 4;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ntemp = phy_read(phydev, reg);\r\nif (temp < 0) {\r\nrc = temp;\r\ngoto out;\r\n}\r\ntemp &= ~(3 << shift);\r\ntemp |= val << shift;\r\nrc = phy_write(phydev, reg, temp);\r\nout:\r\nif (rc < 0)\r\nphydev_err(phydev, "failed to set led mode\n");\r\nreturn rc;\r\n}\r\nstatic int kszphy_broadcast_disable(struct phy_device *phydev)\r\n{\r\nint ret;\r\nret = phy_read(phydev, MII_KSZPHY_OMSO);\r\nif (ret < 0)\r\ngoto out;\r\nret = phy_write(phydev, MII_KSZPHY_OMSO, ret | KSZPHY_OMSO_B_CAST_OFF);\r\nout:\r\nif (ret)\r\nphydev_err(phydev, "failed to disable broadcast address\n");\r\nreturn ret;\r\n}\r\nstatic int kszphy_nand_tree_disable(struct phy_device *phydev)\r\n{\r\nint ret;\r\nret = phy_read(phydev, MII_KSZPHY_OMSO);\r\nif (ret < 0)\r\ngoto out;\r\nif (!(ret & KSZPHY_OMSO_NAND_TREE_ON))\r\nreturn 0;\r\nret = phy_write(phydev, MII_KSZPHY_OMSO,\r\nret & ~KSZPHY_OMSO_NAND_TREE_ON);\r\nout:\r\nif (ret)\r\nphydev_err(phydev, "failed to disable NAND tree mode\n");\r\nreturn ret;\r\n}\r\nstatic int kszphy_config_reset(struct phy_device *phydev)\r\n{\r\nstruct kszphy_priv *priv = phydev->priv;\r\nint ret;\r\nif (priv->rmii_ref_clk_sel) {\r\nret = kszphy_rmii_clk_sel(phydev, priv->rmii_ref_clk_sel_val);\r\nif (ret) {\r\nphydev_err(phydev,\r\n"failed to set rmii reference clock\n");\r\nreturn ret;\r\n}\r\n}\r\nif (priv->led_mode >= 0)\r\nkszphy_setup_led(phydev, priv->type->led_mode_reg, priv->led_mode);\r\nreturn 0;\r\n}\r\nstatic int kszphy_config_init(struct phy_device *phydev)\r\n{\r\nstruct kszphy_priv *priv = phydev->priv;\r\nconst struct kszphy_type *type;\r\nif (!priv)\r\nreturn 0;\r\ntype = priv->type;\r\nif (type->has_broadcast_disable)\r\nkszphy_broadcast_disable(phydev);\r\nif (type->has_nand_tree_disable)\r\nkszphy_nand_tree_disable(phydev);\r\nreturn kszphy_config_reset(phydev);\r\n}\r\nstatic int ksz8041_config_init(struct phy_device *phydev)\r\n{\r\nstruct device_node *of_node = phydev->mdio.dev.of_node;\r\nif (of_property_read_bool(of_node, "micrel,fiber-mode")) {\r\nphydev->dev_flags |= MICREL_PHY_FXEN;\r\nphydev->supported &= SUPPORTED_100baseT_Full |\r\nSUPPORTED_100baseT_Half;\r\nphydev->supported |= SUPPORTED_FIBRE;\r\nphydev->advertising &= ADVERTISED_100baseT_Full |\r\nADVERTISED_100baseT_Half;\r\nphydev->advertising |= ADVERTISED_FIBRE;\r\nphydev->autoneg = AUTONEG_DISABLE;\r\n}\r\nreturn kszphy_config_init(phydev);\r\n}\r\nstatic int ksz8041_config_aneg(struct phy_device *phydev)\r\n{\r\nif (phydev->dev_flags & MICREL_PHY_FXEN) {\r\nphydev->speed = SPEED_100;\r\nreturn 0;\r\n}\r\nreturn genphy_config_aneg(phydev);\r\n}\r\nstatic int ksz9021_load_values_from_of(struct phy_device *phydev,\r\nconst struct device_node *of_node,\r\nu16 reg,\r\nconst char *field1, const char *field2,\r\nconst char *field3, const char *field4)\r\n{\r\nint val1 = -1;\r\nint val2 = -2;\r\nint val3 = -3;\r\nint val4 = -4;\r\nint newval;\r\nint matches = 0;\r\nif (!of_property_read_u32(of_node, field1, &val1))\r\nmatches++;\r\nif (!of_property_read_u32(of_node, field2, &val2))\r\nmatches++;\r\nif (!of_property_read_u32(of_node, field3, &val3))\r\nmatches++;\r\nif (!of_property_read_u32(of_node, field4, &val4))\r\nmatches++;\r\nif (!matches)\r\nreturn 0;\r\nif (matches < 4)\r\nnewval = kszphy_extended_read(phydev, reg);\r\nelse\r\nnewval = 0;\r\nif (val1 != -1)\r\nnewval = ((newval & 0xfff0) | ((val1 / PS_TO_REG) & 0xf) << 0);\r\nif (val2 != -2)\r\nnewval = ((newval & 0xff0f) | ((val2 / PS_TO_REG) & 0xf) << 4);\r\nif (val3 != -3)\r\nnewval = ((newval & 0xf0ff) | ((val3 / PS_TO_REG) & 0xf) << 8);\r\nif (val4 != -4)\r\nnewval = ((newval & 0x0fff) | ((val4 / PS_TO_REG) & 0xf) << 12);\r\nreturn kszphy_extended_write(phydev, reg, newval);\r\n}\r\nstatic int ksz9021_config_init(struct phy_device *phydev)\r\n{\r\nconst struct device *dev = &phydev->mdio.dev;\r\nconst struct device_node *of_node = dev->of_node;\r\nconst struct device *dev_walker;\r\ndev_walker = &phydev->mdio.dev;\r\ndo {\r\nof_node = dev_walker->of_node;\r\ndev_walker = dev_walker->parent;\r\n} while (!of_node && dev_walker);\r\nif (of_node) {\r\nksz9021_load_values_from_of(phydev, of_node,\r\nMII_KSZPHY_CLK_CONTROL_PAD_SKEW,\r\n"txen-skew-ps", "txc-skew-ps",\r\n"rxdv-skew-ps", "rxc-skew-ps");\r\nksz9021_load_values_from_of(phydev, of_node,\r\nMII_KSZPHY_RX_DATA_PAD_SKEW,\r\n"rxd0-skew-ps", "rxd1-skew-ps",\r\n"rxd2-skew-ps", "rxd3-skew-ps");\r\nksz9021_load_values_from_of(phydev, of_node,\r\nMII_KSZPHY_TX_DATA_PAD_SKEW,\r\n"txd0-skew-ps", "txd1-skew-ps",\r\n"txd2-skew-ps", "txd3-skew-ps");\r\n}\r\nreturn 0;\r\n}\r\nstatic int ksz9031_extended_write(struct phy_device *phydev,\r\nu8 mode, u32 dev_addr, u32 regnum, u16 val)\r\n{\r\nphy_write(phydev, MII_KSZ9031RN_MMD_CTRL_REG, dev_addr);\r\nphy_write(phydev, MII_KSZ9031RN_MMD_REGDATA_REG, regnum);\r\nphy_write(phydev, MII_KSZ9031RN_MMD_CTRL_REG, (mode << 14) | dev_addr);\r\nreturn phy_write(phydev, MII_KSZ9031RN_MMD_REGDATA_REG, val);\r\n}\r\nstatic int ksz9031_extended_read(struct phy_device *phydev,\r\nu8 mode, u32 dev_addr, u32 regnum)\r\n{\r\nphy_write(phydev, MII_KSZ9031RN_MMD_CTRL_REG, dev_addr);\r\nphy_write(phydev, MII_KSZ9031RN_MMD_REGDATA_REG, regnum);\r\nphy_write(phydev, MII_KSZ9031RN_MMD_CTRL_REG, (mode << 14) | dev_addr);\r\nreturn phy_read(phydev, MII_KSZ9031RN_MMD_REGDATA_REG);\r\n}\r\nstatic int ksz9031_of_load_skew_values(struct phy_device *phydev,\r\nconst struct device_node *of_node,\r\nu16 reg, size_t field_sz,\r\nconst char *field[], u8 numfields)\r\n{\r\nint val[4] = {-1, -2, -3, -4};\r\nint matches = 0;\r\nu16 mask;\r\nu16 maxval;\r\nu16 newval;\r\nint i;\r\nfor (i = 0; i < numfields; i++)\r\nif (!of_property_read_u32(of_node, field[i], val + i))\r\nmatches++;\r\nif (!matches)\r\nreturn 0;\r\nif (matches < numfields)\r\nnewval = ksz9031_extended_read(phydev, OP_DATA, 2, reg);\r\nelse\r\nnewval = 0;\r\nmaxval = (field_sz == 4) ? 0xf : 0x1f;\r\nfor (i = 0; i < numfields; i++)\r\nif (val[i] != -(i + 1)) {\r\nmask = 0xffff;\r\nmask ^= maxval << (field_sz * i);\r\nnewval = (newval & mask) |\r\n(((val[i] / KSZ9031_PS_TO_REG) & maxval)\r\n<< (field_sz * i));\r\n}\r\nreturn ksz9031_extended_write(phydev, OP_DATA, 2, reg, newval);\r\n}\r\nstatic int ksz9031_center_flp_timing(struct phy_device *phydev)\r\n{\r\nint result;\r\nresult = ksz9031_extended_write(phydev, OP_DATA, 0,\r\nMII_KSZ9031RN_FLP_BURST_TX_HI, 0x0006);\r\nresult = ksz9031_extended_write(phydev, OP_DATA, 0,\r\nMII_KSZ9031RN_FLP_BURST_TX_LO, 0x1A80);\r\nif (result)\r\nreturn result;\r\nreturn genphy_restart_aneg(phydev);\r\n}\r\nstatic int ksz9031_enable_edpd(struct phy_device *phydev)\r\n{\r\nint reg;\r\nreg = ksz9031_extended_read(phydev, OP_DATA, 0x1C, MII_KSZ9031RN_EDPD);\r\nif (reg < 0)\r\nreturn reg;\r\nreturn ksz9031_extended_write(phydev, OP_DATA, 0x1C, MII_KSZ9031RN_EDPD,\r\nreg | MII_KSZ9031RN_EDPD_ENABLE);\r\n}\r\nstatic int ksz9031_config_init(struct phy_device *phydev)\r\n{\r\nconst struct device *dev = &phydev->mdio.dev;\r\nconst struct device_node *of_node = dev->of_node;\r\nstatic const char *clk_skews[2] = {"rxc-skew-ps", "txc-skew-ps"};\r\nstatic const char *rx_data_skews[4] = {\r\n"rxd0-skew-ps", "rxd1-skew-ps",\r\n"rxd2-skew-ps", "rxd3-skew-ps"\r\n};\r\nstatic const char *tx_data_skews[4] = {\r\n"txd0-skew-ps", "txd1-skew-ps",\r\n"txd2-skew-ps", "txd3-skew-ps"\r\n};\r\nstatic const char *control_skews[2] = {"txen-skew-ps", "rxdv-skew-ps"};\r\nconst struct device *dev_walker;\r\nint result;\r\nresult = ksz9031_enable_edpd(phydev);\r\nif (result < 0)\r\nreturn result;\r\ndev_walker = &phydev->mdio.dev;\r\ndo {\r\nof_node = dev_walker->of_node;\r\ndev_walker = dev_walker->parent;\r\n} while (!of_node && dev_walker);\r\nif (of_node) {\r\nksz9031_of_load_skew_values(phydev, of_node,\r\nMII_KSZ9031RN_CLK_PAD_SKEW, 5,\r\nclk_skews, 2);\r\nksz9031_of_load_skew_values(phydev, of_node,\r\nMII_KSZ9031RN_CONTROL_PAD_SKEW, 4,\r\ncontrol_skews, 2);\r\nksz9031_of_load_skew_values(phydev, of_node,\r\nMII_KSZ9031RN_RX_DATA_PAD_SKEW, 4,\r\nrx_data_skews, 4);\r\nksz9031_of_load_skew_values(phydev, of_node,\r\nMII_KSZ9031RN_TX_DATA_PAD_SKEW, 4,\r\ntx_data_skews, 4);\r\n}\r\nreturn ksz9031_center_flp_timing(phydev);\r\n}\r\nstatic int ksz8873mll_read_status(struct phy_device *phydev)\r\n{\r\nint regval;\r\nregval = phy_read(phydev, KSZ8873MLL_GLOBAL_CONTROL_4);\r\nregval = phy_read(phydev, KSZ8873MLL_GLOBAL_CONTROL_4);\r\nif (regval & KSZ8873MLL_GLOBAL_CONTROL_4_DUPLEX)\r\nphydev->duplex = DUPLEX_HALF;\r\nelse\r\nphydev->duplex = DUPLEX_FULL;\r\nif (regval & KSZ8873MLL_GLOBAL_CONTROL_4_SPEED)\r\nphydev->speed = SPEED_10;\r\nelse\r\nphydev->speed = SPEED_100;\r\nphydev->link = 1;\r\nphydev->pause = phydev->asym_pause = 0;\r\nreturn 0;\r\n}\r\nstatic int ksz9031_read_status(struct phy_device *phydev)\r\n{\r\nint err;\r\nint regval;\r\nerr = genphy_read_status(phydev);\r\nif (err)\r\nreturn err;\r\nregval = phy_read(phydev, MII_STAT1000);\r\nif ((regval & 0xFF) == 0xFF) {\r\nphy_init_hw(phydev);\r\nphydev->link = 0;\r\nif (phydev->drv->config_intr && phy_interrupt_is_valid(phydev))\r\nphydev->drv->config_intr(phydev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ksz8873mll_config_aneg(struct phy_device *phydev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\nksz9021_rd_mmd_phyreg(struct phy_device *phydev, int devad, u16 regnum)\r\n{\r\nreturn -1;\r\n}\r\nstatic int\r\nksz9021_wr_mmd_phyreg(struct phy_device *phydev, int devad, u16 regnum, u16 val)\r\n{\r\nreturn -1;\r\n}\r\nstatic int kszphy_get_sset_count(struct phy_device *phydev)\r\n{\r\nreturn ARRAY_SIZE(kszphy_hw_stats);\r\n}\r\nstatic void kszphy_get_strings(struct phy_device *phydev, u8 *data)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(kszphy_hw_stats); i++) {\r\nmemcpy(data + i * ETH_GSTRING_LEN,\r\nkszphy_hw_stats[i].string, ETH_GSTRING_LEN);\r\n}\r\n}\r\nstatic u64 kszphy_get_stat(struct phy_device *phydev, int i)\r\n{\r\nstruct kszphy_hw_stat stat = kszphy_hw_stats[i];\r\nstruct kszphy_priv *priv = phydev->priv;\r\nint val;\r\nu64 ret;\r\nval = phy_read(phydev, stat.reg);\r\nif (val < 0) {\r\nret = UINT64_MAX;\r\n} else {\r\nval = val & ((1 << stat.bits) - 1);\r\npriv->stats[i] += val;\r\nret = priv->stats[i];\r\n}\r\nreturn ret;\r\n}\r\nstatic void kszphy_get_stats(struct phy_device *phydev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(kszphy_hw_stats); i++)\r\ndata[i] = kszphy_get_stat(phydev, i);\r\n}\r\nstatic int kszphy_suspend(struct phy_device *phydev)\r\n{\r\nif (phy_interrupt_is_valid(phydev)) {\r\nphydev->interrupts = PHY_INTERRUPT_DISABLED;\r\nif (phydev->drv->config_intr)\r\nphydev->drv->config_intr(phydev);\r\n}\r\nreturn genphy_suspend(phydev);\r\n}\r\nstatic int kszphy_resume(struct phy_device *phydev)\r\n{\r\nint ret;\r\ngenphy_resume(phydev);\r\nret = kszphy_config_reset(phydev);\r\nif (ret)\r\nreturn ret;\r\nif (phy_interrupt_is_valid(phydev)) {\r\nphydev->interrupts = PHY_INTERRUPT_ENABLED;\r\nif (phydev->drv->config_intr)\r\nphydev->drv->config_intr(phydev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int kszphy_probe(struct phy_device *phydev)\r\n{\r\nconst struct kszphy_type *type = phydev->drv->driver_data;\r\nconst struct device_node *np = phydev->mdio.dev.of_node;\r\nstruct kszphy_priv *priv;\r\nstruct clk *clk;\r\nint ret;\r\npriv = devm_kzalloc(&phydev->mdio.dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nphydev->priv = priv;\r\npriv->type = type;\r\nif (type->led_mode_reg) {\r\nret = of_property_read_u32(np, "micrel,led-mode",\r\n&priv->led_mode);\r\nif (ret)\r\npriv->led_mode = -1;\r\nif (priv->led_mode > 3) {\r\nphydev_err(phydev, "invalid led mode: 0x%02x\n",\r\npriv->led_mode);\r\npriv->led_mode = -1;\r\n}\r\n} else {\r\npriv->led_mode = -1;\r\n}\r\nclk = devm_clk_get(&phydev->mdio.dev, "rmii-ref");\r\nif (!IS_ERR_OR_NULL(clk)) {\r\nunsigned long rate = clk_get_rate(clk);\r\nbool rmii_ref_clk_sel_25_mhz;\r\npriv->rmii_ref_clk_sel = type->has_rmii_ref_clk_sel;\r\nrmii_ref_clk_sel_25_mhz = of_property_read_bool(np,\r\n"micrel,rmii-reference-clock-select-25-mhz");\r\nif (rate > 24500000 && rate < 25500000) {\r\npriv->rmii_ref_clk_sel_val = rmii_ref_clk_sel_25_mhz;\r\n} else if (rate > 49500000 && rate < 50500000) {\r\npriv->rmii_ref_clk_sel_val = !rmii_ref_clk_sel_25_mhz;\r\n} else {\r\nphydev_err(phydev, "Clock rate out of range: %ld\n",\r\nrate);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (phydev->dev_flags & MICREL_PHY_50MHZ_CLK) {\r\npriv->rmii_ref_clk_sel = true;\r\npriv->rmii_ref_clk_sel_val = true;\r\n}\r\nreturn 0;\r\n}
