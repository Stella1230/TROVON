static inline int pp_check(struct pp_instance *handle)\r\n{\r\nif (handle == NULL || handle->pp_valid != PP_VALID)\r\nreturn -EINVAL;\r\nif (handle->smu_mgr == NULL || handle->smu_mgr->smumgr_funcs == NULL)\r\nreturn -EINVAL;\r\nif (handle->pm_en == 0)\r\nreturn PP_DPM_DISABLED;\r\nif (handle->hwmgr == NULL || handle->hwmgr->hwmgr_func == NULL\r\n|| handle->eventmgr == NULL)\r\nreturn PP_DPM_DISABLED;\r\nreturn 0;\r\n}\r\nstatic int pp_early_init(void *handle)\r\n{\r\nint ret;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nret = smum_early_init(pp_handle);\r\nif (ret)\r\nreturn ret;\r\nif ((pp_handle->pm_en == 0)\r\n|| cgs_is_virtualization_enabled(pp_handle->device))\r\nreturn PP_DPM_DISABLED;\r\nret = hwmgr_early_init(pp_handle);\r\nif (ret) {\r\npp_handle->pm_en = 0;\r\nreturn PP_DPM_DISABLED;\r\n}\r\nret = eventmgr_early_init(pp_handle);\r\nif (ret) {\r\nkfree(pp_handle->hwmgr);\r\npp_handle->hwmgr = NULL;\r\npp_handle->pm_en = 0;\r\nreturn PP_DPM_DISABLED;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pp_sw_init(void *handle)\r\n{\r\nstruct pp_smumgr *smumgr;\r\nint ret = 0;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nret = pp_check(pp_handle);\r\nif (ret == 0 || ret == PP_DPM_DISABLED) {\r\nsmumgr = pp_handle->smu_mgr;\r\nif (smumgr->smumgr_funcs->smu_init == NULL)\r\nreturn -EINVAL;\r\nret = smumgr->smumgr_funcs->smu_init(smumgr);\r\npr_info("amdgpu: powerplay sw initialized\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int pp_sw_fini(void *handle)\r\n{\r\nstruct pp_smumgr *smumgr;\r\nint ret = 0;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nret = pp_check(pp_handle);\r\nif (ret == 0 || ret == PP_DPM_DISABLED) {\r\nsmumgr = pp_handle->smu_mgr;\r\nif (smumgr->smumgr_funcs->smu_fini == NULL)\r\nreturn -EINVAL;\r\nret = smumgr->smumgr_funcs->smu_fini(smumgr);\r\n}\r\nreturn ret;\r\n}\r\nstatic int pp_hw_init(void *handle)\r\n{\r\nstruct pp_smumgr *smumgr;\r\nstruct pp_eventmgr *eventmgr;\r\nint ret = 0;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nret = pp_check(pp_handle);\r\nif (ret == 0 || ret == PP_DPM_DISABLED) {\r\nsmumgr = pp_handle->smu_mgr;\r\nif (smumgr->smumgr_funcs->start_smu == NULL)\r\nreturn -EINVAL;\r\nif(smumgr->smumgr_funcs->start_smu(smumgr)) {\r\npr_err("smc start failed\n");\r\nsmumgr->smumgr_funcs->smu_fini(smumgr);\r\nreturn -EINVAL;;\r\n}\r\nif (ret == PP_DPM_DISABLED)\r\nreturn PP_DPM_DISABLED;\r\n}\r\nret = hwmgr_hw_init(pp_handle);\r\nif (ret)\r\ngoto err;\r\neventmgr = pp_handle->eventmgr;\r\nif (eventmgr->pp_eventmgr_init == NULL ||\r\neventmgr->pp_eventmgr_init(eventmgr))\r\ngoto err;\r\nreturn 0;\r\nerr:\r\npp_handle->pm_en = 0;\r\nkfree(pp_handle->eventmgr);\r\nkfree(pp_handle->hwmgr);\r\npp_handle->hwmgr = NULL;\r\npp_handle->eventmgr = NULL;\r\nreturn PP_DPM_DISABLED;\r\n}\r\nstatic int pp_hw_fini(void *handle)\r\n{\r\nstruct pp_eventmgr *eventmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret == 0) {\r\neventmgr = pp_handle->eventmgr;\r\nif (eventmgr->pp_eventmgr_fini != NULL)\r\neventmgr->pp_eventmgr_fini(eventmgr);\r\nhwmgr_hw_fini(pp_handle);\r\n}\r\nreturn 0;\r\n}\r\nstatic bool pp_is_idle(void *handle)\r\n{\r\nreturn false;\r\n}\r\nstatic int pp_wait_for_idle(void *handle)\r\n{\r\nreturn 0;\r\n}\r\nstatic int pp_sw_reset(void *handle)\r\n{\r\nreturn 0;\r\n}\r\nint amd_set_clockgating_by_smu(void *handle, uint32_t msg_id)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->update_clock_gatings == NULL) {\r\npr_info("%s was not implemented.\n", __func__);\r\nreturn 0;\r\n}\r\nreturn hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);\r\n}\r\nstatic int pp_set_powergating_state(void *handle,\r\nenum amd_powergating_state state)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->enable_per_cu_power_gating == NULL) {\r\npr_info("%s was not implemented.\n", __func__);\r\nreturn 0;\r\n}\r\nreturn hwmgr->hwmgr_func->enable_per_cu_power_gating(hwmgr,\r\nstate == AMD_PG_STATE_GATE);\r\n}\r\nstatic int pp_suspend(void *handle)\r\n{\r\nstruct pp_eventmgr *eventmgr;\r\nstruct pem_event_data event_data = { {0} };\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret == PP_DPM_DISABLED)\r\nreturn 0;\r\nelse if (ret != 0)\r\nreturn ret;\r\neventmgr = pp_handle->eventmgr;\r\npem_handle_event(eventmgr, AMD_PP_EVENT_SUSPEND, &event_data);\r\nreturn 0;\r\n}\r\nstatic int pp_resume(void *handle)\r\n{\r\nstruct pp_eventmgr *eventmgr;\r\nstruct pem_event_data event_data = { {0} };\r\nstruct pp_smumgr *smumgr;\r\nint ret, ret1;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nret1 = pp_check(pp_handle);\r\nif (ret1 != 0 && ret1 != PP_DPM_DISABLED)\r\nreturn ret1;\r\nsmumgr = pp_handle->smu_mgr;\r\nif (smumgr->smumgr_funcs->start_smu == NULL)\r\nreturn -EINVAL;\r\nret = smumgr->smumgr_funcs->start_smu(smumgr);\r\nif (ret) {\r\npr_err("smc start failed\n");\r\nsmumgr->smumgr_funcs->smu_fini(smumgr);\r\nreturn ret;\r\n}\r\nif (ret1 == PP_DPM_DISABLED)\r\nreturn 0;\r\neventmgr = pp_handle->eventmgr;\r\npem_handle_event(eventmgr, AMD_PP_EVENT_RESUME, &event_data);\r\nreturn 0;\r\n}\r\nstatic int pp_dpm_load_fw(void *handle)\r\n{\r\nreturn 0;\r\n}\r\nstatic int pp_dpm_fw_loading_complete(void *handle)\r\n{\r\nreturn 0;\r\n}\r\nstatic int pp_dpm_force_performance_level(void *handle,\r\nenum amd_dpm_forced_level level)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->force_dpm_level == NULL) {\r\npr_info("%s was not implemented.\n", __func__);\r\nreturn 0;\r\n}\r\nmutex_lock(&pp_handle->pp_lock);\r\nhwmgr->hwmgr_func->force_dpm_level(hwmgr, level);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn 0;\r\n}\r\nstatic enum amd_dpm_forced_level pp_dpm_get_performance_level(\r\nvoid *handle)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nenum amd_dpm_forced_level level;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nmutex_lock(&pp_handle->pp_lock);\r\nlevel = hwmgr->dpm_level;\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn level;\r\n}\r\nstatic int pp_dpm_get_sclk(void *handle, bool low)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->get_sclk == NULL) {\r\npr_info("%s was not implemented.\n", __func__);\r\nreturn 0;\r\n}\r\nmutex_lock(&pp_handle->pp_lock);\r\nret = hwmgr->hwmgr_func->get_sclk(hwmgr, low);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nstatic int pp_dpm_get_mclk(void *handle, bool low)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->get_mclk == NULL) {\r\npr_info("%s was not implemented.\n", __func__);\r\nreturn 0;\r\n}\r\nmutex_lock(&pp_handle->pp_lock);\r\nret = hwmgr->hwmgr_func->get_mclk(hwmgr, low);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nstatic int pp_dpm_powergate_vce(void *handle, bool gate)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->powergate_vce == NULL) {\r\npr_info("%s was not implemented.\n", __func__);\r\nreturn 0;\r\n}\r\nmutex_lock(&pp_handle->pp_lock);\r\nret = hwmgr->hwmgr_func->powergate_vce(hwmgr, gate);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nstatic int pp_dpm_powergate_uvd(void *handle, bool gate)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->powergate_uvd == NULL) {\r\npr_info("%s was not implemented.\n", __func__);\r\nreturn 0;\r\n}\r\nmutex_lock(&pp_handle->pp_lock);\r\nret = hwmgr->hwmgr_func->powergate_uvd(hwmgr, gate);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nstatic enum PP_StateUILabel power_state_convert(enum amd_pm_state_type state)\r\n{\r\nswitch (state) {\r\ncase POWER_STATE_TYPE_BATTERY:\r\nreturn PP_StateUILabel_Battery;\r\ncase POWER_STATE_TYPE_BALANCED:\r\nreturn PP_StateUILabel_Balanced;\r\ncase POWER_STATE_TYPE_PERFORMANCE:\r\nreturn PP_StateUILabel_Performance;\r\ndefault:\r\nreturn PP_StateUILabel_None;\r\n}\r\n}\r\nstatic int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_event event_id,\r\nvoid *input, void *output)\r\n{\r\nint ret = 0;\r\nstruct pem_event_data data = { {0} };\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nmutex_lock(&pp_handle->pp_lock);\r\nswitch (event_id) {\r\ncase AMD_PP_EVENT_DISPLAY_CONFIG_CHANGE:\r\nret = pem_handle_event(pp_handle->eventmgr, event_id, &data);\r\nbreak;\r\ncase AMD_PP_EVENT_ENABLE_USER_STATE:\r\n{\r\nenum amd_pm_state_type ps;\r\nif (input == NULL) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nps = *(unsigned long *)input;\r\ndata.requested_ui_label = power_state_convert(ps);\r\nret = pem_handle_event(pp_handle->eventmgr, event_id, &data);\r\nbreak;\r\n}\r\ncase AMD_PP_EVENT_COMPLETE_INIT:\r\nret = pem_handle_event(pp_handle->eventmgr, event_id, &data);\r\nbreak;\r\ncase AMD_PP_EVENT_READJUST_POWER_STATE:\r\nret = pem_handle_event(pp_handle->eventmgr, event_id, &data);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nstatic enum amd_pm_state_type pp_dpm_get_current_power_state(void *handle)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_power_state *state;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nenum amd_pm_state_type pm_type;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->current_ps == NULL)\r\nreturn -EINVAL;\r\nmutex_lock(&pp_handle->pp_lock);\r\nstate = hwmgr->current_ps;\r\nswitch (state->classification.ui_label) {\r\ncase PP_StateUILabel_Battery:\r\npm_type = POWER_STATE_TYPE_BATTERY;\r\nbreak;\r\ncase PP_StateUILabel_Balanced:\r\npm_type = POWER_STATE_TYPE_BALANCED;\r\nbreak;\r\ncase PP_StateUILabel_Performance:\r\npm_type = POWER_STATE_TYPE_PERFORMANCE;\r\nbreak;\r\ndefault:\r\nif (state->classification.flags & PP_StateClassificationFlag_Boot)\r\npm_type = POWER_STATE_TYPE_INTERNAL_BOOT;\r\nelse\r\npm_type = POWER_STATE_TYPE_DEFAULT;\r\nbreak;\r\n}\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn pm_type;\r\n}\r\nstatic int pp_dpm_set_fan_control_mode(void *handle, uint32_t mode)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->set_fan_control_mode == NULL) {\r\npr_info("%s was not implemented.\n", __func__);\r\nreturn 0;\r\n}\r\nmutex_lock(&pp_handle->pp_lock);\r\nret = hwmgr->hwmgr_func->set_fan_control_mode(hwmgr, mode);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nstatic int pp_dpm_get_fan_control_mode(void *handle)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->get_fan_control_mode == NULL) {\r\npr_info("%s was not implemented.\n", __func__);\r\nreturn 0;\r\n}\r\nmutex_lock(&pp_handle->pp_lock);\r\nret = hwmgr->hwmgr_func->get_fan_control_mode(hwmgr);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nstatic int pp_dpm_set_fan_speed_percent(void *handle, uint32_t percent)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->set_fan_speed_percent == NULL) {\r\npr_info("%s was not implemented.\n", __func__);\r\nreturn 0;\r\n}\r\nmutex_lock(&pp_handle->pp_lock);\r\nret = hwmgr->hwmgr_func->set_fan_speed_percent(hwmgr, percent);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nstatic int pp_dpm_get_fan_speed_percent(void *handle, uint32_t *speed)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->get_fan_speed_percent == NULL) {\r\npr_info("%s was not implemented.\n", __func__);\r\nreturn 0;\r\n}\r\nmutex_lock(&pp_handle->pp_lock);\r\nret = hwmgr->hwmgr_func->get_fan_speed_percent(hwmgr, speed);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nstatic int pp_dpm_get_fan_speed_rpm(void *handle, uint32_t *rpm)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->get_fan_speed_rpm == NULL)\r\nreturn -EINVAL;\r\nmutex_lock(&pp_handle->pp_lock);\r\nret = hwmgr->hwmgr_func->get_fan_speed_rpm(hwmgr, rpm);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nstatic int pp_dpm_get_temperature(void *handle)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->get_temperature == NULL) {\r\npr_info("%s was not implemented.\n", __func__);\r\nreturn 0;\r\n}\r\nmutex_lock(&pp_handle->pp_lock);\r\nret = hwmgr->hwmgr_func->get_temperature(hwmgr);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nstatic int pp_dpm_get_pp_num_states(void *handle,\r\nstruct pp_states_info *data)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nint i;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->ps == NULL)\r\nreturn -EINVAL;\r\nmutex_lock(&pp_handle->pp_lock);\r\ndata->nums = hwmgr->num_ps;\r\nfor (i = 0; i < hwmgr->num_ps; i++) {\r\nstruct pp_power_state *state = (struct pp_power_state *)\r\n((unsigned long)hwmgr->ps + i * hwmgr->ps_size);\r\nswitch (state->classification.ui_label) {\r\ncase PP_StateUILabel_Battery:\r\ndata->states[i] = POWER_STATE_TYPE_BATTERY;\r\nbreak;\r\ncase PP_StateUILabel_Balanced:\r\ndata->states[i] = POWER_STATE_TYPE_BALANCED;\r\nbreak;\r\ncase PP_StateUILabel_Performance:\r\ndata->states[i] = POWER_STATE_TYPE_PERFORMANCE;\r\nbreak;\r\ndefault:\r\nif (state->classification.flags & PP_StateClassificationFlag_Boot)\r\ndata->states[i] = POWER_STATE_TYPE_INTERNAL_BOOT;\r\nelse\r\ndata->states[i] = POWER_STATE_TYPE_DEFAULT;\r\n}\r\n}\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn 0;\r\n}\r\nstatic int pp_dpm_get_pp_table(void *handle, char **table)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nint size = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (!hwmgr->soft_pp_table)\r\nreturn -EINVAL;\r\nmutex_lock(&pp_handle->pp_lock);\r\n*table = (char *)hwmgr->soft_pp_table;\r\nsize = hwmgr->soft_pp_table_size;\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn size;\r\n}\r\nstatic int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nmutex_lock(&pp_handle->pp_lock);\r\nif (!hwmgr->hardcode_pp_table) {\r\nhwmgr->hardcode_pp_table = kmemdup(hwmgr->soft_pp_table,\r\nhwmgr->soft_pp_table_size,\r\nGFP_KERNEL);\r\nif (!hwmgr->hardcode_pp_table) {\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nmemcpy(hwmgr->hardcode_pp_table, buf, size);\r\nhwmgr->soft_pp_table = hwmgr->hardcode_pp_table;\r\nmutex_unlock(&pp_handle->pp_lock);\r\nret = amd_powerplay_reset(handle);\r\nif (ret)\r\nreturn ret;\r\nif (hwmgr->hwmgr_func->avfs_control) {\r\nret = hwmgr->hwmgr_func->avfs_control(hwmgr, false);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pp_dpm_force_clock_level(void *handle,\r\nenum pp_clock_type type, uint32_t mask)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->force_clock_level == NULL) {\r\npr_info("%s was not implemented.\n", __func__);\r\nreturn 0;\r\n}\r\nmutex_lock(&pp_handle->pp_lock);\r\nhwmgr->hwmgr_func->force_clock_level(hwmgr, type, mask);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nstatic int pp_dpm_print_clock_levels(void *handle,\r\nenum pp_clock_type type, char *buf)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->print_clock_levels == NULL) {\r\npr_info("%s was not implemented.\n", __func__);\r\nreturn 0;\r\n}\r\nmutex_lock(&pp_handle->pp_lock);\r\nret = hwmgr->hwmgr_func->print_clock_levels(hwmgr, type, buf);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nstatic int pp_dpm_get_sclk_od(void *handle)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->get_sclk_od == NULL) {\r\npr_info("%s was not implemented.\n", __func__);\r\nreturn 0;\r\n}\r\nmutex_lock(&pp_handle->pp_lock);\r\nret = hwmgr->hwmgr_func->get_sclk_od(hwmgr);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nstatic int pp_dpm_set_sclk_od(void *handle, uint32_t value)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->set_sclk_od == NULL) {\r\npr_info("%s was not implemented.\n", __func__);\r\nreturn 0;\r\n}\r\nmutex_lock(&pp_handle->pp_lock);\r\nret = hwmgr->hwmgr_func->set_sclk_od(hwmgr, value);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nstatic int pp_dpm_get_mclk_od(void *handle)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->get_mclk_od == NULL) {\r\npr_info("%s was not implemented.\n", __func__);\r\nreturn 0;\r\n}\r\nmutex_lock(&pp_handle->pp_lock);\r\nret = hwmgr->hwmgr_func->get_mclk_od(hwmgr);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nstatic int pp_dpm_set_mclk_od(void *handle, uint32_t value)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->set_mclk_od == NULL) {\r\npr_info("%s was not implemented.\n", __func__);\r\nreturn 0;\r\n}\r\nmutex_lock(&pp_handle->pp_lock);\r\nret = hwmgr->hwmgr_func->set_mclk_od(hwmgr, value);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nstatic int pp_dpm_read_sensor(void *handle, int idx,\r\nvoid *value, int *size)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->read_sensor == NULL) {\r\npr_info("%s was not implemented.\n", __func__);\r\nreturn 0;\r\n}\r\nmutex_lock(&pp_handle->pp_lock);\r\nret = hwmgr->hwmgr_func->read_sensor(hwmgr, idx, value, size);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nstatic struct amd_vce_state*\r\npp_dpm_get_vce_clock_state(void *handle, unsigned idx)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn NULL;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr && idx < hwmgr->num_vce_state_tables)\r\nreturn &hwmgr->vce_states[idx];\r\nreturn NULL;\r\n}\r\nstatic int pp_dpm_reset_power_profile_state(void *handle,\r\nstruct amd_pp_profile *request)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nif (!request || pp_check(pp_handle))\r\nreturn -EINVAL;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->set_power_profile_state == NULL) {\r\npr_info("%s was not implemented.\n", __func__);\r\nreturn 0;\r\n}\r\nif (request->type == AMD_PP_GFX_PROFILE) {\r\nhwmgr->gfx_power_profile = hwmgr->default_gfx_power_profile;\r\nreturn hwmgr->hwmgr_func->set_power_profile_state(hwmgr,\r\n&hwmgr->gfx_power_profile);\r\n} else if (request->type == AMD_PP_COMPUTE_PROFILE) {\r\nhwmgr->compute_power_profile =\r\nhwmgr->default_compute_power_profile;\r\nreturn hwmgr->hwmgr_func->set_power_profile_state(hwmgr,\r\n&hwmgr->compute_power_profile);\r\n} else\r\nreturn -EINVAL;\r\n}\r\nstatic int pp_dpm_get_power_profile_state(void *handle,\r\nstruct amd_pp_profile *query)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nif (!query || pp_check(pp_handle))\r\nreturn -EINVAL;\r\nhwmgr = pp_handle->hwmgr;\r\nif (query->type == AMD_PP_GFX_PROFILE)\r\nmemcpy(query, &hwmgr->gfx_power_profile,\r\nsizeof(struct amd_pp_profile));\r\nelse if (query->type == AMD_PP_COMPUTE_PROFILE)\r\nmemcpy(query, &hwmgr->compute_power_profile,\r\nsizeof(struct amd_pp_profile));\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int pp_dpm_set_power_profile_state(void *handle,\r\nstruct amd_pp_profile *request)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = -1;\r\nif (!request || pp_check(pp_handle))\r\nreturn -EINVAL;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->hwmgr_func->set_power_profile_state == NULL) {\r\npr_info("%s was not implemented.\n", __func__);\r\nreturn 0;\r\n}\r\nif (request->min_sclk ||\r\nrequest->min_mclk ||\r\nrequest->activity_threshold ||\r\nrequest->up_hyst ||\r\nrequest->down_hyst) {\r\nif (request->type == AMD_PP_GFX_PROFILE)\r\nmemcpy(&hwmgr->gfx_power_profile, request,\r\nsizeof(struct amd_pp_profile));\r\nelse if (request->type == AMD_PP_COMPUTE_PROFILE)\r\nmemcpy(&hwmgr->compute_power_profile, request,\r\nsizeof(struct amd_pp_profile));\r\nelse\r\nreturn -EINVAL;\r\nif (request->type == hwmgr->current_power_profile)\r\nret = hwmgr->hwmgr_func->set_power_profile_state(\r\nhwmgr,\r\nrequest);\r\n} else {\r\nswitch (request->type) {\r\ncase AMD_PP_GFX_PROFILE:\r\nret = hwmgr->hwmgr_func->set_power_profile_state(\r\nhwmgr,\r\n&hwmgr->gfx_power_profile);\r\nbreak;\r\ncase AMD_PP_COMPUTE_PROFILE:\r\nret = hwmgr->hwmgr_func->set_power_profile_state(\r\nhwmgr,\r\n&hwmgr->compute_power_profile);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!ret)\r\nhwmgr->current_power_profile = request->type;\r\nreturn 0;\r\n}\r\nstatic int pp_dpm_switch_power_profile(void *handle,\r\nenum amd_pp_profile_type type)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct amd_pp_profile request = {0};\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nif (pp_check(pp_handle))\r\nreturn -EINVAL;\r\nhwmgr = pp_handle->hwmgr;\r\nif (hwmgr->current_power_profile != type) {\r\nrequest.type = type;\r\npp_dpm_set_power_profile_state(handle, &request);\r\n}\r\nreturn 0;\r\n}\r\nint amd_powerplay_create(struct amd_pp_init *pp_init,\r\nvoid **handle)\r\n{\r\nstruct pp_instance *instance;\r\nif (pp_init == NULL || handle == NULL)\r\nreturn -EINVAL;\r\ninstance = kzalloc(sizeof(struct pp_instance), GFP_KERNEL);\r\nif (instance == NULL)\r\nreturn -ENOMEM;\r\ninstance->pp_valid = PP_VALID;\r\ninstance->chip_family = pp_init->chip_family;\r\ninstance->chip_id = pp_init->chip_id;\r\ninstance->pm_en = pp_init->pm_en;\r\ninstance->feature_mask = pp_init->feature_mask;\r\ninstance->device = pp_init->device;\r\nmutex_init(&instance->pp_lock);\r\n*handle = instance;\r\nreturn 0;\r\n}\r\nint amd_powerplay_destroy(void *handle)\r\n{\r\nstruct pp_instance *instance = (struct pp_instance *)handle;\r\nif (instance->pm_en) {\r\nkfree(instance->eventmgr);\r\nkfree(instance->hwmgr);\r\ninstance->hwmgr = NULL;\r\ninstance->eventmgr = NULL;\r\n}\r\nkfree(instance->smu_mgr);\r\ninstance->smu_mgr = NULL;\r\nkfree(instance);\r\ninstance = NULL;\r\nreturn 0;\r\n}\r\nint amd_powerplay_reset(void *handle)\r\n{\r\nstruct pp_instance *instance = (struct pp_instance *)handle;\r\nstruct pp_eventmgr *eventmgr;\r\nstruct pem_event_data event_data = { {0} };\r\nint ret;\r\nif (cgs_is_virtualization_enabled(instance->smu_mgr->device))\r\nreturn PP_DPM_DISABLED;\r\nret = pp_check(instance);\r\nif (ret != 0)\r\nreturn ret;\r\nret = pp_hw_fini(handle);\r\nif (ret)\r\nreturn ret;\r\nret = hwmgr_hw_init(instance);\r\nif (ret)\r\nreturn PP_DPM_DISABLED;\r\neventmgr = instance->eventmgr;\r\nif (eventmgr->pp_eventmgr_init == NULL)\r\nreturn PP_DPM_DISABLED;\r\nret = eventmgr->pp_eventmgr_init(eventmgr);\r\nif (ret)\r\nreturn ret;\r\nreturn pem_handle_event(eventmgr, AMD_PP_EVENT_COMPLETE_INIT, &event_data);\r\n}\r\nint amd_powerplay_display_configuration_change(void *handle,\r\nconst struct amd_pp_display_configuration *display_config)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nmutex_lock(&pp_handle->pp_lock);\r\nphm_store_dal_configuration_data(hwmgr, display_config);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn 0;\r\n}\r\nint amd_powerplay_get_display_power_level(void *handle,\r\nstruct amd_pp_simple_clock_info *output)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (output == NULL)\r\nreturn -EINVAL;\r\nmutex_lock(&pp_handle->pp_lock);\r\nret = phm_get_dal_power_level(hwmgr, output);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nint amd_powerplay_get_current_clocks(void *handle,\r\nstruct amd_pp_clock_info *clocks)\r\n{\r\nstruct amd_pp_simple_clock_info simple_clocks;\r\nstruct pp_clock_info hw_clocks;\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nmutex_lock(&pp_handle->pp_lock);\r\nphm_get_dal_power_level(hwmgr, &simple_clocks);\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\r\nPHM_PlatformCaps_PowerContainment))\r\nret = phm_get_clock_info(hwmgr, &hwmgr->current_ps->hardware,\r\n&hw_clocks, PHM_PerformanceLevelDesignation_PowerContainment);\r\nelse\r\nret = phm_get_clock_info(hwmgr, &hwmgr->current_ps->hardware,\r\n&hw_clocks, PHM_PerformanceLevelDesignation_Activity);\r\nif (ret != 0) {\r\npr_info("Error in phm_get_clock_info \n");\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn -EINVAL;\r\n}\r\nclocks->min_engine_clock = hw_clocks.min_eng_clk;\r\nclocks->max_engine_clock = hw_clocks.max_eng_clk;\r\nclocks->min_memory_clock = hw_clocks.min_mem_clk;\r\nclocks->max_memory_clock = hw_clocks.max_mem_clk;\r\nclocks->min_bus_bandwidth = hw_clocks.min_bus_bandwidth;\r\nclocks->max_bus_bandwidth = hw_clocks.max_bus_bandwidth;\r\nclocks->max_engine_clock_in_sr = hw_clocks.max_eng_clk;\r\nclocks->min_engine_clock_in_sr = hw_clocks.min_eng_clk;\r\nclocks->max_clocks_state = simple_clocks.level;\r\nif (0 == phm_get_current_shallow_sleep_clocks(hwmgr, &hwmgr->current_ps->hardware, &hw_clocks)) {\r\nclocks->max_engine_clock_in_sr = hw_clocks.max_eng_clk;\r\nclocks->min_engine_clock_in_sr = hw_clocks.min_eng_clk;\r\n}\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn 0;\r\n}\r\nint amd_powerplay_get_clock_by_type(void *handle, enum amd_pp_clock_type type, struct amd_pp_clocks *clocks)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (clocks == NULL)\r\nreturn -EINVAL;\r\nmutex_lock(&pp_handle->pp_lock);\r\nret = phm_get_clock_by_type(hwmgr, type, clocks);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nint amd_powerplay_get_clock_by_type_with_latency(void *handle,\r\nenum amd_pp_clock_type type,\r\nstruct pp_clock_levels_with_latency *clocks)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nif (!clocks)\r\nreturn -EINVAL;\r\nmutex_lock(&pp_handle->pp_lock);\r\nhwmgr = ((struct pp_instance *)handle)->hwmgr;\r\nret = phm_get_clock_by_type_with_latency(hwmgr, type, clocks);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nint amd_powerplay_get_clock_by_type_with_voltage(void *handle,\r\nenum amd_pp_clock_type type,\r\nstruct pp_clock_levels_with_voltage *clocks)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nif (!clocks)\r\nreturn -EINVAL;\r\nhwmgr = ((struct pp_instance *)handle)->hwmgr;\r\nmutex_lock(&pp_handle->pp_lock);\r\nret = phm_get_clock_by_type_with_voltage(hwmgr, type, clocks);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nint amd_powerplay_set_watermarks_for_clocks_ranges(void *handle,\r\nstruct pp_wm_sets_with_clock_ranges_soc15 *wm_with_clock_ranges)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nif (!wm_with_clock_ranges)\r\nreturn -EINVAL;\r\nhwmgr = ((struct pp_instance *)handle)->hwmgr;\r\nmutex_lock(&pp_handle->pp_lock);\r\nret = phm_set_watermarks_for_clocks_ranges(hwmgr,\r\nwm_with_clock_ranges);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nint amd_powerplay_display_clock_voltage_request(void *handle,\r\nstruct pp_display_clock_request *clock)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nif (!clock)\r\nreturn -EINVAL;\r\nhwmgr = ((struct pp_instance *)handle)->hwmgr;\r\nmutex_lock(&pp_handle->pp_lock);\r\nret = phm_display_clock_voltage_request(hwmgr, clock);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}\r\nint amd_powerplay_get_display_mode_validation_clocks(void *handle,\r\nstruct amd_pp_simple_clock_info *clocks)\r\n{\r\nstruct pp_hwmgr *hwmgr;\r\nstruct pp_instance *pp_handle = (struct pp_instance *)handle;\r\nint ret = 0;\r\nret = pp_check(pp_handle);\r\nif (ret != 0)\r\nreturn ret;\r\nhwmgr = pp_handle->hwmgr;\r\nif (clocks == NULL)\r\nreturn -EINVAL;\r\nmutex_lock(&pp_handle->pp_lock);\r\nif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_DynamicPatchPowerState))\r\nret = phm_get_max_high_clocks(hwmgr, clocks);\r\nmutex_unlock(&pp_handle->pp_lock);\r\nreturn ret;\r\n}
