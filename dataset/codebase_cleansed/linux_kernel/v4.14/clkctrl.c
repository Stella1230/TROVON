static u32 _omap4_idlest(u32 val)\r\n{\r\nval &= OMAP4_IDLEST_MASK;\r\nval >>= OMAP4_IDLEST_SHIFT;\r\nreturn val;\r\n}\r\nstatic bool _omap4_is_idle(u32 val)\r\n{\r\nval = _omap4_idlest(val);\r\nreturn val == CLKCTRL_IDLEST_DISABLED;\r\n}\r\nstatic bool _omap4_is_ready(u32 val)\r\n{\r\nval = _omap4_idlest(val);\r\nreturn val == CLKCTRL_IDLEST_FUNCTIONAL ||\r\nval == CLKCTRL_IDLEST_INTERFACE_IDLE;\r\n}\r\nstatic bool _omap4_is_timeout(union omap4_timeout *time, u32 timeout)\r\n{\r\nif (unlikely(_early_timeout)) {\r\nif (time->cycles++ < timeout) {\r\nudelay(1);\r\nreturn false;\r\n}\r\n} else {\r\nif (!ktime_to_ns(time->start)) {\r\ntime->start = ktime_get();\r\nreturn false;\r\n}\r\nif (ktime_us_delta(ktime_get(), time->start) < timeout) {\r\ncpu_relax();\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic int __init _omap4_disable_early_timeout(void)\r\n{\r\n_early_timeout = false;\r\nreturn 0;\r\n}\r\nstatic int _omap4_clkctrl_clk_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nu32 val;\r\nint ret;\r\nunion omap4_timeout timeout = { 0 };\r\nif (!clk->enable_bit)\r\nreturn 0;\r\nif (clk->clkdm) {\r\nret = ti_clk_ll_ops->clkdm_clk_enable(clk->clkdm, hw->clk);\r\nif (ret) {\r\nWARN(1,\r\n"%s: could not enable %s's clockdomain %s: %d\n",\r\n__func__, clk_hw_get_name(hw),\r\nclk->clkdm_name, ret);\r\nreturn ret;\r\n}\r\n}\r\nval = ti_clk_ll_ops->clk_readl(&clk->enable_reg);\r\nval &= ~OMAP4_MODULEMODE_MASK;\r\nval |= clk->enable_bit;\r\nti_clk_ll_ops->clk_writel(val, &clk->enable_reg);\r\nif (clk->flags & NO_IDLEST)\r\nreturn 0;\r\nwhile (!_omap4_is_ready(ti_clk_ll_ops->clk_readl(&clk->enable_reg))) {\r\nif (_omap4_is_timeout(&timeout, OMAP4_MAX_MODULE_READY_TIME)) {\r\npr_err("%s: failed to enable\n", clk_hw_get_name(hw));\r\nreturn -EBUSY;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void _omap4_clkctrl_clk_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nu32 val;\r\nunion omap4_timeout timeout = { 0 };\r\nif (!clk->enable_bit)\r\nreturn;\r\nval = ti_clk_ll_ops->clk_readl(&clk->enable_reg);\r\nval &= ~OMAP4_MODULEMODE_MASK;\r\nti_clk_ll_ops->clk_writel(val, &clk->enable_reg);\r\nif (clk->flags & NO_IDLEST)\r\ngoto exit;\r\nwhile (!_omap4_is_idle(ti_clk_ll_ops->clk_readl(&clk->enable_reg))) {\r\nif (_omap4_is_timeout(&timeout,\r\nOMAP4_MAX_MODULE_DISABLE_TIME)) {\r\npr_err("%s: failed to disable\n", clk_hw_get_name(hw));\r\nbreak;\r\n}\r\n}\r\nexit:\r\nif (clk->clkdm)\r\nti_clk_ll_ops->clkdm_clk_disable(clk->clkdm, hw->clk);\r\n}\r\nstatic int _omap4_clkctrl_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nu32 val;\r\nval = ti_clk_ll_ops->clk_readl(&clk->enable_reg);\r\nif (val & clk->enable_bit)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic struct clk_hw *_ti_omap4_clkctrl_xlate(struct of_phandle_args *clkspec,\r\nvoid *data)\r\n{\r\nstruct omap_clkctrl_provider *provider = data;\r\nstruct omap_clkctrl_clk *entry;\r\nif (clkspec->args_count != 2)\r\nreturn ERR_PTR(-EINVAL);\r\npr_debug("%s: looking for %x:%x\n", __func__,\r\nclkspec->args[0], clkspec->args[1]);\r\nlist_for_each_entry(entry, &provider->clocks, node) {\r\nif (entry->reg_offset == clkspec->args[0] &&\r\nentry->bit_offset == clkspec->args[1])\r\nbreak;\r\n}\r\nif (!entry)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn entry->clk;\r\n}\r\nstatic int __init\r\n_ti_clkctrl_clk_register(struct omap_clkctrl_provider *provider,\r\nstruct device_node *node, struct clk_hw *clk_hw,\r\nu16 offset, u8 bit, const char * const *parents,\r\nint num_parents, const struct clk_ops *ops)\r\n{\r\nstruct clk_init_data init = { NULL };\r\nstruct clk *clk;\r\nstruct omap_clkctrl_clk *clkctrl_clk;\r\nint ret = 0;\r\ninit.name = kasprintf(GFP_KERNEL, "%s:%s:%04x:%d", node->parent->name,\r\nnode->name, offset, bit);\r\nclkctrl_clk = kzalloc(sizeof(*clkctrl_clk), GFP_KERNEL);\r\nif (!init.name || !clkctrl_clk) {\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nclk_hw->init = &init;\r\ninit.parent_names = parents;\r\ninit.num_parents = num_parents;\r\ninit.ops = ops;\r\ninit.flags = CLK_IS_BASIC;\r\nclk = ti_clk_register(NULL, clk_hw, init.name);\r\nif (IS_ERR_OR_NULL(clk)) {\r\nret = -EINVAL;\r\ngoto cleanup;\r\n}\r\nclkctrl_clk->reg_offset = offset;\r\nclkctrl_clk->bit_offset = bit;\r\nclkctrl_clk->clk = clk_hw;\r\nlist_add(&clkctrl_clk->node, &provider->clocks);\r\nreturn 0;\r\ncleanup:\r\nkfree(init.name);\r\nkfree(clkctrl_clk);\r\nreturn ret;\r\n}\r\nstatic void __init\r\n_ti_clkctrl_setup_gate(struct omap_clkctrl_provider *provider,\r\nstruct device_node *node, u16 offset,\r\nconst struct omap_clkctrl_bit_data *data,\r\nvoid __iomem *reg)\r\n{\r\nstruct clk_hw_omap *clk_hw;\r\nclk_hw = kzalloc(sizeof(*clk_hw), GFP_KERNEL);\r\nif (!clk_hw)\r\nreturn;\r\nclk_hw->enable_bit = data->bit;\r\nclk_hw->enable_reg.ptr = reg;\r\nif (_ti_clkctrl_clk_register(provider, node, &clk_hw->hw, offset,\r\ndata->bit, data->parents, 1,\r\n&omap_gate_clk_ops))\r\nkfree(clk_hw);\r\n}\r\nstatic void __init\r\n_ti_clkctrl_setup_mux(struct omap_clkctrl_provider *provider,\r\nstruct device_node *node, u16 offset,\r\nconst struct omap_clkctrl_bit_data *data,\r\nvoid __iomem *reg)\r\n{\r\nstruct clk_omap_mux *mux;\r\nint num_parents = 0;\r\nconst char * const *pname;\r\nmux = kzalloc(sizeof(*mux), GFP_KERNEL);\r\nif (!mux)\r\nreturn;\r\npname = data->parents;\r\nwhile (*pname) {\r\nnum_parents++;\r\npname++;\r\n}\r\nmux->mask = num_parents;\r\nmux->mask = (1 << fls(mux->mask)) - 1;\r\nmux->shift = data->bit;\r\nmux->reg.ptr = reg;\r\nif (_ti_clkctrl_clk_register(provider, node, &mux->hw, offset,\r\ndata->bit, data->parents, num_parents,\r\n&ti_clk_mux_ops))\r\nkfree(mux);\r\n}\r\nstatic void __init\r\n_ti_clkctrl_setup_div(struct omap_clkctrl_provider *provider,\r\nstruct device_node *node, u16 offset,\r\nconst struct omap_clkctrl_bit_data *data,\r\nvoid __iomem *reg)\r\n{\r\nstruct clk_omap_divider *div;\r\nconst struct omap_clkctrl_div_data *div_data = data->data;\r\ndiv = kzalloc(sizeof(*div), GFP_KERNEL);\r\nif (!div)\r\nreturn;\r\ndiv->reg.ptr = reg;\r\ndiv->shift = data->bit;\r\nif (ti_clk_parse_divider_data((int *)div_data->dividers,\r\ndiv_data->max_div, 0, 0,\r\n&div->width, &div->table)) {\r\npr_err("%s: Data parsing for %s:%04x:%d failed\n", __func__,\r\nnode->name, offset, data->bit);\r\nkfree(div);\r\nreturn;\r\n}\r\nif (_ti_clkctrl_clk_register(provider, node, &div->hw, offset,\r\ndata->bit, data->parents, 1,\r\n&ti_clk_divider_ops))\r\nkfree(div);\r\n}\r\nstatic void __init\r\n_ti_clkctrl_setup_subclks(struct omap_clkctrl_provider *provider,\r\nstruct device_node *node,\r\nconst struct omap_clkctrl_reg_data *data,\r\nvoid __iomem *reg)\r\n{\r\nconst struct omap_clkctrl_bit_data *bits = data->bit_data;\r\nif (!bits)\r\nreturn;\r\nwhile (bits->bit) {\r\nswitch (bits->type) {\r\ncase TI_CLK_GATE:\r\n_ti_clkctrl_setup_gate(provider, node, data->offset,\r\nbits, reg);\r\nbreak;\r\ncase TI_CLK_DIVIDER:\r\n_ti_clkctrl_setup_div(provider, node, data->offset,\r\nbits, reg);\r\nbreak;\r\ncase TI_CLK_MUX:\r\n_ti_clkctrl_setup_mux(provider, node, data->offset,\r\nbits, reg);\r\nbreak;\r\ndefault:\r\npr_err("%s: bad subclk type: %d\n", __func__,\r\nbits->type);\r\nreturn;\r\n}\r\nbits++;\r\n}\r\n}\r\nstatic void __init _ti_omap4_clkctrl_setup(struct device_node *node)\r\n{\r\nstruct omap_clkctrl_provider *provider;\r\nconst struct omap_clkctrl_data *data = default_clkctrl_data;\r\nconst struct omap_clkctrl_reg_data *reg_data;\r\nstruct clk_init_data init = { NULL };\r\nstruct clk_hw_omap *hw;\r\nstruct clk *clk;\r\nstruct omap_clkctrl_clk *clkctrl_clk;\r\nconst __be32 *addrp;\r\nu32 addr;\r\naddrp = of_get_address(node, 0, NULL, NULL);\r\naddr = (u32)of_translate_address(node, addrp);\r\n#ifdef CONFIG_ARCH_OMAP4\r\nif (of_machine_is_compatible("ti,omap4"))\r\ndata = omap4_clkctrl_data;\r\n#endif\r\nwhile (data->addr) {\r\nif (addr == data->addr)\r\nbreak;\r\ndata++;\r\n}\r\nif (!data->addr) {\r\npr_err("%s not found from clkctrl data.\n", node->name);\r\nreturn;\r\n}\r\nprovider = kzalloc(sizeof(*provider), GFP_KERNEL);\r\nif (!provider)\r\nreturn;\r\nprovider->base = of_iomap(node, 0);\r\nINIT_LIST_HEAD(&provider->clocks);\r\nreg_data = data->regs;\r\nwhile (reg_data->parent) {\r\nhw = kzalloc(sizeof(*hw), GFP_KERNEL);\r\nif (!hw)\r\nreturn;\r\nhw->enable_reg.ptr = provider->base + reg_data->offset;\r\n_ti_clkctrl_setup_subclks(provider, node, reg_data,\r\nhw->enable_reg.ptr);\r\nif (reg_data->flags & CLKF_SW_SUP)\r\nhw->enable_bit = MODULEMODE_SWCTRL;\r\nif (reg_data->flags & CLKF_HW_SUP)\r\nhw->enable_bit = MODULEMODE_HWCTRL;\r\nif (reg_data->flags & CLKF_NO_IDLEST)\r\nhw->flags |= NO_IDLEST;\r\ninit.parent_names = &reg_data->parent;\r\ninit.num_parents = 1;\r\ninit.flags = 0;\r\ninit.name = kasprintf(GFP_KERNEL, "%s:%s:%04x:%d",\r\nnode->parent->name, node->name,\r\nreg_data->offset, 0);\r\nclkctrl_clk = kzalloc(sizeof(*clkctrl_clk), GFP_KERNEL);\r\nif (!init.name || !clkctrl_clk)\r\ngoto cleanup;\r\ninit.ops = &omap4_clkctrl_clk_ops;\r\nhw->hw.init = &init;\r\nclk = ti_clk_register(NULL, &hw->hw, init.name);\r\nif (IS_ERR_OR_NULL(clk))\r\ngoto cleanup;\r\nclkctrl_clk->reg_offset = reg_data->offset;\r\nclkctrl_clk->clk = &hw->hw;\r\nlist_add(&clkctrl_clk->node, &provider->clocks);\r\nreg_data++;\r\n}\r\nof_clk_add_hw_provider(node, _ti_omap4_clkctrl_xlate, provider);\r\nreturn;\r\ncleanup:\r\nkfree(hw);\r\nkfree(init.name);\r\nkfree(clkctrl_clk);\r\n}
