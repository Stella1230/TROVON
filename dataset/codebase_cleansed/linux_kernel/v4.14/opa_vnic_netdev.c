static void opa_vnic_get_stats64(struct net_device *netdev,\r\nstruct rtnl_link_stats64 *stats)\r\n{\r\nstruct opa_vnic_adapter *adapter = opa_vnic_priv(netdev);\r\nstruct opa_vnic_stats vstats;\r\nmemset(&vstats, 0, sizeof(vstats));\r\nspin_lock(&adapter->stats_lock);\r\nadapter->rn_ops->ndo_get_stats64(netdev, &vstats.netstats);\r\nspin_unlock(&adapter->stats_lock);\r\nmemcpy(stats, &vstats.netstats, sizeof(*stats));\r\n}\r\nstatic netdev_tx_t opa_netdev_start_xmit(struct sk_buff *skb,\r\nstruct net_device *netdev)\r\n{\r\nstruct opa_vnic_adapter *adapter = opa_vnic_priv(netdev);\r\nv_dbg("xmit: queue %d skb len %d\n", skb->queue_mapping, skb->len);\r\nif (unlikely(skb->len < ETH_ZLEN)) {\r\nif (skb_padto(skb, ETH_ZLEN))\r\nreturn NETDEV_TX_OK;\r\nskb_put(skb, ETH_ZLEN - skb->len);\r\n}\r\nopa_vnic_encap_skb(adapter, skb);\r\nreturn adapter->rn_ops->ndo_start_xmit(skb, netdev);\r\n}\r\nstatic u16 opa_vnic_select_queue(struct net_device *netdev, struct sk_buff *skb,\r\nvoid *accel_priv,\r\nselect_queue_fallback_t fallback)\r\n{\r\nstruct opa_vnic_adapter *adapter = opa_vnic_priv(netdev);\r\nstruct opa_vnic_skb_mdata *mdata;\r\nint rc;\r\nmdata = skb_push(skb, sizeof(*mdata));\r\nmdata->entropy = opa_vnic_calc_entropy(adapter, skb);\r\nmdata->vl = opa_vnic_get_vl(adapter, skb);\r\nrc = adapter->rn_ops->ndo_select_queue(netdev, skb,\r\naccel_priv, fallback);\r\nskb_pull(skb, sizeof(*mdata));\r\nreturn rc;\r\n}\r\nvoid opa_vnic_process_vema_config(struct opa_vnic_adapter *adapter)\r\n{\r\nstruct __opa_veswport_info *info = &adapter->info;\r\nstruct rdma_netdev *rn = netdev_priv(adapter->netdev);\r\nu8 port_num[OPA_VESW_MAX_NUM_DEF_PORT] = { 0 };\r\nstruct net_device *netdev = adapter->netdev;\r\nu8 i, port_count = 0;\r\nu16 port_mask;\r\nif (memcmp(info->vport.base_mac_addr, adapter->vema_mac_addr,\r\nARRAY_SIZE(info->vport.base_mac_addr))) {\r\nstruct sockaddr saddr;\r\nmemcpy(saddr.sa_data, info->vport.base_mac_addr,\r\nARRAY_SIZE(info->vport.base_mac_addr));\r\nmutex_lock(&adapter->lock);\r\neth_mac_addr(netdev, &saddr);\r\nmemcpy(adapter->vema_mac_addr,\r\ninfo->vport.base_mac_addr, ETH_ALEN);\r\nmutex_unlock(&adapter->lock);\r\n}\r\nrn->set_id(netdev, info->vesw.vesw_id);\r\nrtnl_lock();\r\nnetdev->max_mtu = max_t(unsigned int, info->vesw.eth_mtu_non_vlan,\r\nnetdev->min_mtu);\r\nif (netdev->mtu > netdev->max_mtu)\r\ndev_set_mtu(netdev, netdev->max_mtu);\r\nrtnl_unlock();\r\nport_mask = info->vesw.def_port_mask;\r\nfor (i = 0; i < OPA_VESW_MAX_NUM_DEF_PORT; i++) {\r\nif (port_mask & 1)\r\nport_num[port_count++] = i;\r\nport_mask >>= 1;\r\n}\r\nfor (i = 0; i < OPA_VNIC_FLOW_TBL_SIZE; i++)\r\nadapter->flow_tbl[i] = port_count ? port_num[i % port_count] :\r\nOPA_VNIC_INVALID_PORT;\r\nif (info->vport.config_state == OPA_VNIC_STATE_FORWARDING) {\r\ninfo->vport.oper_state = OPA_VNIC_STATE_FORWARDING;\r\nnetif_dormant_off(netdev);\r\n} else {\r\ninfo->vport.oper_state = OPA_VNIC_STATE_DROP_ALL;\r\nnetif_dormant_on(netdev);\r\n}\r\n}\r\nstatic inline void opa_vnic_set_pod_values(struct opa_vnic_adapter *adapter)\r\n{\r\nadapter->info.vport.max_mac_tbl_ent = OPA_VNIC_MAC_TBL_MAX_ENTRIES;\r\nadapter->info.vport.max_smac_ent = OPA_VNIC_MAX_SMAC_LIMIT;\r\nadapter->info.vport.config_state = OPA_VNIC_STATE_DROP_ALL;\r\nadapter->info.vport.eth_link_status = OPA_VNIC_ETH_LINK_DOWN;\r\n}\r\nstatic int opa_vnic_set_mac_addr(struct net_device *netdev, void *addr)\r\n{\r\nstruct opa_vnic_adapter *adapter = opa_vnic_priv(netdev);\r\nstruct sockaddr *sa = addr;\r\nint rc;\r\nif (!memcmp(netdev->dev_addr, sa->sa_data, ETH_ALEN))\r\nreturn 0;\r\nmutex_lock(&adapter->lock);\r\nrc = eth_mac_addr(netdev, addr);\r\nmutex_unlock(&adapter->lock);\r\nif (rc)\r\nreturn rc;\r\nadapter->info.vport.uc_macs_gen_count++;\r\nopa_vnic_vema_report_event(adapter,\r\nOPA_VESWPORT_TRAP_IFACE_UCAST_MAC_CHANGE);\r\nreturn 0;\r\n}\r\nstatic void opa_vnic_mac_send_event(struct net_device *netdev, u8 event)\r\n{\r\nstruct opa_vnic_adapter *adapter = opa_vnic_priv(netdev);\r\nstruct netdev_hw_addr *ha;\r\nstruct netdev_hw_addr_list *hw_list;\r\nu32 *ref_crc;\r\nu32 l, crc = 0;\r\nswitch (event) {\r\ncase OPA_VESWPORT_TRAP_IFACE_UCAST_MAC_CHANGE:\r\nhw_list = &netdev->uc;\r\nadapter->info.vport.uc_macs_gen_count++;\r\nref_crc = &adapter->umac_hash;\r\nbreak;\r\ncase OPA_VESWPORT_TRAP_IFACE_MCAST_MAC_CHANGE:\r\nhw_list = &netdev->mc;\r\nadapter->info.vport.mc_macs_gen_count++;\r\nref_crc = &adapter->mmac_hash;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nnetdev_hw_addr_list_for_each(ha, hw_list) {\r\ncrc = crc32_le(crc, ha->addr, ETH_ALEN);\r\n}\r\nl = netdev_hw_addr_list_count(hw_list) * ETH_ALEN;\r\ncrc = ~crc32_le(crc, (void *)&l, sizeof(l));\r\nif (crc != *ref_crc) {\r\n*ref_crc = crc;\r\nopa_vnic_vema_report_event(adapter, event);\r\n}\r\n}\r\nstatic void opa_vnic_set_rx_mode(struct net_device *netdev)\r\n{\r\nopa_vnic_mac_send_event(netdev,\r\nOPA_VESWPORT_TRAP_IFACE_UCAST_MAC_CHANGE);\r\nopa_vnic_mac_send_event(netdev,\r\nOPA_VESWPORT_TRAP_IFACE_MCAST_MAC_CHANGE);\r\n}\r\nstatic int opa_netdev_open(struct net_device *netdev)\r\n{\r\nstruct opa_vnic_adapter *adapter = opa_vnic_priv(netdev);\r\nint rc;\r\nrc = adapter->rn_ops->ndo_open(adapter->netdev);\r\nif (rc) {\r\nv_dbg("open failed %d\n", rc);\r\nreturn rc;\r\n}\r\nadapter->info.vport.eth_link_status = OPA_VNIC_ETH_LINK_UP;\r\nopa_vnic_vema_report_event(adapter,\r\nOPA_VESWPORT_TRAP_ETH_LINK_STATUS_CHANGE);\r\nreturn 0;\r\n}\r\nstatic int opa_netdev_close(struct net_device *netdev)\r\n{\r\nstruct opa_vnic_adapter *adapter = opa_vnic_priv(netdev);\r\nint rc;\r\nrc = adapter->rn_ops->ndo_stop(adapter->netdev);\r\nif (rc) {\r\nv_dbg("close failed %d\n", rc);\r\nreturn rc;\r\n}\r\nadapter->info.vport.eth_link_status = OPA_VNIC_ETH_LINK_DOWN;\r\nopa_vnic_vema_report_event(adapter,\r\nOPA_VESWPORT_TRAP_ETH_LINK_STATUS_CHANGE);\r\nreturn 0;\r\n}\r\nstruct opa_vnic_adapter *opa_vnic_add_netdev(struct ib_device *ibdev,\r\nu8 port_num, u8 vport_num)\r\n{\r\nstruct opa_vnic_adapter *adapter;\r\nstruct net_device *netdev;\r\nstruct rdma_netdev *rn;\r\nint rc;\r\nnetdev = ibdev->alloc_rdma_netdev(ibdev, port_num,\r\nRDMA_NETDEV_OPA_VNIC,\r\n"veth%d", NET_NAME_UNKNOWN,\r\nether_setup);\r\nif (!netdev)\r\nreturn ERR_PTR(-ENOMEM);\r\nelse if (IS_ERR(netdev))\r\nreturn ERR_CAST(netdev);\r\nrn = netdev_priv(netdev);\r\nadapter = kzalloc(sizeof(*adapter), GFP_KERNEL);\r\nif (!adapter) {\r\nrc = -ENOMEM;\r\ngoto adapter_err;\r\n}\r\nrn->clnt_priv = adapter;\r\nrn->hca = ibdev;\r\nrn->port_num = port_num;\r\nadapter->netdev = netdev;\r\nadapter->ibdev = ibdev;\r\nadapter->port_num = port_num;\r\nadapter->vport_num = vport_num;\r\nadapter->rn_ops = netdev->netdev_ops;\r\nnetdev->netdev_ops = &opa_netdev_ops;\r\nnetdev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\r\nnetdev->hard_header_len += OPA_VNIC_SKB_HEADROOM;\r\nmutex_init(&adapter->lock);\r\nmutex_init(&adapter->mactbl_lock);\r\nspin_lock_init(&adapter->stats_lock);\r\nSET_NETDEV_DEV(netdev, ibdev->dev.parent);\r\nopa_vnic_set_ethtool_ops(netdev);\r\nopa_vnic_set_pod_values(adapter);\r\nrc = register_netdev(netdev);\r\nif (rc)\r\ngoto netdev_err;\r\nnetif_carrier_off(netdev);\r\nnetif_dormant_on(netdev);\r\nv_info("initialized\n");\r\nreturn adapter;\r\nnetdev_err:\r\nmutex_destroy(&adapter->lock);\r\nmutex_destroy(&adapter->mactbl_lock);\r\nkfree(adapter);\r\nadapter_err:\r\nrn->free_rdma_netdev(netdev);\r\nreturn ERR_PTR(rc);\r\n}\r\nvoid opa_vnic_rem_netdev(struct opa_vnic_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct rdma_netdev *rn = netdev_priv(netdev);\r\nv_info("removing\n");\r\nunregister_netdev(netdev);\r\nopa_vnic_release_mac_tbl(adapter);\r\nmutex_destroy(&adapter->lock);\r\nmutex_destroy(&adapter->mactbl_lock);\r\nkfree(adapter);\r\nrn->free_rdma_netdev(netdev);\r\n}
