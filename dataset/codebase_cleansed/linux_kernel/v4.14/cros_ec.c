static irqreturn_t ec_irq_thread(int irq, void *data)\r\n{\r\nstruct cros_ec_device *ec_dev = data;\r\nbool wake_event = true;\r\nint ret;\r\nret = cros_ec_get_next_event(ec_dev, &wake_event);\r\nif (wake_event && device_may_wakeup(ec_dev->dev))\r\npm_wakeup_event(ec_dev->dev, 0);\r\nif (ret > 0)\r\nblocking_notifier_call_chain(&ec_dev->event_notifier,\r\n0, ec_dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int cros_ec_sleep_event(struct cros_ec_device *ec_dev, u8 sleep_event)\r\n{\r\nstruct {\r\nstruct cros_ec_command msg;\r\nstruct ec_params_host_sleep_event req;\r\n} __packed buf;\r\nmemset(&buf, 0, sizeof(buf));\r\nbuf.req.sleep_event = sleep_event;\r\nbuf.msg.command = EC_CMD_HOST_SLEEP_EVENT;\r\nbuf.msg.version = 0;\r\nbuf.msg.outsize = sizeof(buf.req);\r\nreturn cros_ec_cmd_xfer(ec_dev, &buf.msg);\r\n}\r\nint cros_ec_register(struct cros_ec_device *ec_dev)\r\n{\r\nstruct device *dev = ec_dev->dev;\r\nint err = 0;\r\nBLOCKING_INIT_NOTIFIER_HEAD(&ec_dev->event_notifier);\r\nec_dev->max_request = sizeof(struct ec_params_hello);\r\nec_dev->max_response = sizeof(struct ec_response_get_protocol_info);\r\nec_dev->max_passthru = 0;\r\nec_dev->din = devm_kzalloc(dev, ec_dev->din_size, GFP_KERNEL);\r\nif (!ec_dev->din)\r\nreturn -ENOMEM;\r\nec_dev->dout = devm_kzalloc(dev, ec_dev->dout_size, GFP_KERNEL);\r\nif (!ec_dev->dout)\r\nreturn -ENOMEM;\r\nmutex_init(&ec_dev->lock);\r\ncros_ec_query_all(ec_dev);\r\nif (ec_dev->irq) {\r\nerr = request_threaded_irq(ec_dev->irq, NULL, ec_irq_thread,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\n"chromeos-ec", ec_dev);\r\nif (err) {\r\ndev_err(dev, "Failed to request IRQ %d: %d",\r\nec_dev->irq, err);\r\nreturn err;\r\n}\r\n}\r\nerr = mfd_add_devices(ec_dev->dev, PLATFORM_DEVID_AUTO, &ec_cell, 1,\r\nNULL, ec_dev->irq, NULL);\r\nif (err) {\r\ndev_err(dev,\r\n"Failed to register Embedded Controller subdevice %d\n",\r\nerr);\r\ngoto fail_mfd;\r\n}\r\nif (ec_dev->max_passthru) {\r\nerr = mfd_add_devices(ec_dev->dev, PLATFORM_DEVID_AUTO,\r\n&ec_pd_cell, 1, NULL, ec_dev->irq, NULL);\r\nif (err) {\r\ndev_err(dev,\r\n"Failed to register Power Delivery subdevice %d\n",\r\nerr);\r\ngoto fail_mfd;\r\n}\r\n}\r\nif (IS_ENABLED(CONFIG_OF) && dev->of_node) {\r\nerr = devm_of_platform_populate(dev);\r\nif (err) {\r\nmfd_remove_devices(dev);\r\ndev_err(dev, "Failed to register sub-devices\n");\r\ngoto fail_mfd;\r\n}\r\n}\r\nerr = cros_ec_sleep_event(ec_dev, 0);\r\nif (err < 0)\r\ndev_dbg(ec_dev->dev, "Error %d clearing sleep event to ec",\r\nerr);\r\ndev_info(dev, "Chrome EC device registered\n");\r\ncros_ec_acpi_install_gpe_handler(dev);\r\nreturn 0;\r\nfail_mfd:\r\nif (ec_dev->irq)\r\nfree_irq(ec_dev->irq, ec_dev);\r\nreturn err;\r\n}\r\nint cros_ec_remove(struct cros_ec_device *ec_dev)\r\n{\r\nmfd_remove_devices(ec_dev->dev);\r\ncros_ec_acpi_remove_gpe_handler();\r\nif (ec_dev->irq)\r\nfree_irq(ec_dev->irq, ec_dev);\r\nreturn 0;\r\n}\r\nint cros_ec_suspend(struct cros_ec_device *ec_dev)\r\n{\r\nstruct device *dev = ec_dev->dev;\r\nint ret;\r\nu8 sleep_event;\r\nif (!IS_ENABLED(CONFIG_ACPI) || pm_suspend_via_firmware()) {\r\nsleep_event = HOST_SLEEP_EVENT_S3_SUSPEND;\r\n} else {\r\nsleep_event = HOST_SLEEP_EVENT_S0IX_SUSPEND;\r\ncros_ec_acpi_clear_gpe();\r\n}\r\nret = cros_ec_sleep_event(ec_dev, sleep_event);\r\nif (ret < 0)\r\ndev_dbg(ec_dev->dev, "Error %d sending suspend event to ec",\r\nret);\r\nif (device_may_wakeup(dev))\r\nec_dev->wake_enabled = !enable_irq_wake(ec_dev->irq);\r\ndisable_irq(ec_dev->irq);\r\nec_dev->was_wake_device = ec_dev->wake_enabled;\r\nec_dev->suspended = true;\r\nreturn 0;\r\n}\r\nstatic void cros_ec_drain_events(struct cros_ec_device *ec_dev)\r\n{\r\nwhile (cros_ec_get_next_event(ec_dev, NULL) > 0)\r\nblocking_notifier_call_chain(&ec_dev->event_notifier,\r\n1, ec_dev);\r\n}\r\nint cros_ec_resume(struct cros_ec_device *ec_dev)\r\n{\r\nint ret;\r\nu8 sleep_event;\r\nec_dev->suspended = false;\r\nenable_irq(ec_dev->irq);\r\nsleep_event = (!IS_ENABLED(CONFIG_ACPI) || pm_suspend_via_firmware()) ?\r\nHOST_SLEEP_EVENT_S3_RESUME :\r\nHOST_SLEEP_EVENT_S0IX_RESUME;\r\nret = cros_ec_sleep_event(ec_dev, sleep_event);\r\nif (ret < 0)\r\ndev_dbg(ec_dev->dev, "Error %d sending resume event to ec",\r\nret);\r\nif (ec_dev->wake_enabled) {\r\ndisable_irq_wake(ec_dev->irq);\r\nec_dev->wake_enabled = 0;\r\n} else {\r\ncros_ec_drain_events(ec_dev);\r\n}\r\nreturn 0;\r\n}
