static void __calc_pre_post_dividers(u32 div, u32 *pre, u32 *post,\r\nu32 max_pre, u32 max_post)\r\n{\r\nif (div >= max_pre * max_post) {\r\n*pre = max_pre;\r\n*post = max_post;\r\n} else if (div >= max_pre) {\r\nu32 min_pre, temp_pre, old_err, err;\r\nmin_pre = DIV_ROUND_UP(div, max_post);\r\nold_err = max_pre;\r\nfor (temp_pre = max_pre; temp_pre >= min_pre; temp_pre--) {\r\nerr = div % temp_pre;\r\nif (err == 0) {\r\n*pre = temp_pre;\r\nbreak;\r\n}\r\nerr = temp_pre - err;\r\nif (err < old_err) {\r\nold_err = err;\r\n*pre = temp_pre;\r\n}\r\n}\r\n*post = DIV_ROUND_UP(div, *pre);\r\n} else {\r\n*pre = div;\r\n*post = 1;\r\n}\r\n}\r\nstatic void _clk_ccgr_setclk(struct clk *clk, unsigned mode)\r\n{\r\nu32 reg = __raw_readl(clk->enable_reg);\r\nreg &= ~(MXC_CCM_CCGRx_CG_MASK << clk->enable_shift);\r\nreg |= mode << clk->enable_shift;\r\n__raw_writel(reg, clk->enable_reg);\r\n}\r\nstatic int _clk_ccgr_enable(struct clk *clk)\r\n{\r\n_clk_ccgr_setclk(clk, MXC_CCM_CCGRx_MOD_ON);\r\nreturn 0;\r\n}\r\nstatic void _clk_ccgr_disable(struct clk *clk)\r\n{\r\n_clk_ccgr_setclk(clk, MXC_CCM_CCGRx_MOD_OFF);\r\n}\r\nstatic int _clk_ccgr_enable_inrun(struct clk *clk)\r\n{\r\n_clk_ccgr_setclk(clk, MXC_CCM_CCGRx_MOD_IDLE);\r\nreturn 0;\r\n}\r\nstatic void _clk_ccgr_disable_inwait(struct clk *clk)\r\n{\r\n_clk_ccgr_setclk(clk, MXC_CCM_CCGRx_MOD_IDLE);\r\n}\r\nstatic inline u32 _get_mux(struct clk *parent, struct clk *m0,\r\nstruct clk *m1, struct clk *m2, struct clk *m3)\r\n{\r\nif (parent == m0)\r\nreturn 0;\r\nelse if (parent == m1)\r\nreturn 1;\r\nelse if (parent == m2)\r\nreturn 2;\r\nelse if (parent == m3)\r\nreturn 3;\r\nelse\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nstatic inline void __iomem *_mx51_get_pll_base(struct clk *pll)\r\n{\r\nif (pll == &pll1_main_clk)\r\nreturn MX51_DPLL1_BASE;\r\nelse if (pll == &pll2_sw_clk)\r\nreturn MX51_DPLL2_BASE;\r\nelse if (pll == &pll3_sw_clk)\r\nreturn MX51_DPLL3_BASE;\r\nelse\r\nBUG();\r\nreturn NULL;\r\n}\r\nstatic inline void __iomem *_mx53_get_pll_base(struct clk *pll)\r\n{\r\nif (pll == &pll1_main_clk)\r\nreturn MX53_DPLL1_BASE;\r\nelse if (pll == &pll2_sw_clk)\r\nreturn MX53_DPLL2_BASE;\r\nelse if (pll == &pll3_sw_clk)\r\nreturn MX53_DPLL3_BASE;\r\nelse if (pll == &mx53_pll4_sw_clk)\r\nreturn MX53_DPLL4_BASE;\r\nelse\r\nBUG();\r\nreturn NULL;\r\n}\r\nstatic inline void __iomem *_get_pll_base(struct clk *pll)\r\n{\r\nif (cpu_is_mx51())\r\nreturn _mx51_get_pll_base(pll);\r\nelse\r\nreturn _mx53_get_pll_base(pll);\r\n}\r\nstatic unsigned long clk_pll_get_rate(struct clk *clk)\r\n{\r\nlong mfi, mfn, mfd, pdf, ref_clk, mfn_abs;\r\nunsigned long dp_op, dp_mfd, dp_mfn, dp_ctl, pll_hfsm, dbl;\r\nvoid __iomem *pllbase;\r\ns64 temp;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\npllbase = _get_pll_base(clk);\r\ndp_ctl = __raw_readl(pllbase + MXC_PLL_DP_CTL);\r\npll_hfsm = dp_ctl & MXC_PLL_DP_CTL_HFSM;\r\ndbl = dp_ctl & MXC_PLL_DP_CTL_DPDCK0_2_EN;\r\nif (pll_hfsm == 0) {\r\ndp_op = __raw_readl(pllbase + MXC_PLL_DP_OP);\r\ndp_mfd = __raw_readl(pllbase + MXC_PLL_DP_MFD);\r\ndp_mfn = __raw_readl(pllbase + MXC_PLL_DP_MFN);\r\n} else {\r\ndp_op = __raw_readl(pllbase + MXC_PLL_DP_HFS_OP);\r\ndp_mfd = __raw_readl(pllbase + MXC_PLL_DP_HFS_MFD);\r\ndp_mfn = __raw_readl(pllbase + MXC_PLL_DP_HFS_MFN);\r\n}\r\npdf = dp_op & MXC_PLL_DP_OP_PDF_MASK;\r\nmfi = (dp_op & MXC_PLL_DP_OP_MFI_MASK) >> MXC_PLL_DP_OP_MFI_OFFSET;\r\nmfi = (mfi <= 5) ? 5 : mfi;\r\nmfd = dp_mfd & MXC_PLL_DP_MFD_MASK;\r\nmfn = mfn_abs = dp_mfn & MXC_PLL_DP_MFN_MASK;\r\nif (mfn >= 0x04000000) {\r\nmfn |= 0xFC000000;\r\nmfn_abs = -mfn;\r\n}\r\nref_clk = 2 * parent_rate;\r\nif (dbl != 0)\r\nref_clk *= 2;\r\nref_clk /= (pdf + 1);\r\ntemp = (u64) ref_clk * mfn_abs;\r\ndo_div(temp, mfd + 1);\r\nif (mfn < 0)\r\ntemp = -temp;\r\ntemp = (ref_clk * mfi) + temp;\r\nreturn temp;\r\n}\r\nstatic int _clk_pll_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nu32 reg;\r\nvoid __iomem *pllbase;\r\nlong mfi, pdf, mfn, mfd = 999999;\r\ns64 temp64;\r\nunsigned long quad_parent_rate;\r\nunsigned long pll_hfsm, dp_ctl;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\npllbase = _get_pll_base(clk);\r\nquad_parent_rate = 4 * parent_rate;\r\npdf = mfi = -1;\r\nwhile (++pdf < 16 && mfi < 5)\r\nmfi = rate * (pdf+1) / quad_parent_rate;\r\nif (mfi > 15)\r\nreturn -EINVAL;\r\npdf--;\r\ntemp64 = rate * (pdf+1) - quad_parent_rate * mfi;\r\ndo_div(temp64, quad_parent_rate/1000000);\r\nmfn = (long)temp64;\r\ndp_ctl = __raw_readl(pllbase + MXC_PLL_DP_CTL);\r\n__raw_writel(dp_ctl | 0x1000L, pllbase + MXC_PLL_DP_CTL);\r\npll_hfsm = dp_ctl & MXC_PLL_DP_CTL_HFSM;\r\nif (pll_hfsm == 0) {\r\nreg = mfi << 4 | pdf;\r\n__raw_writel(reg, pllbase + MXC_PLL_DP_OP);\r\n__raw_writel(mfd, pllbase + MXC_PLL_DP_MFD);\r\n__raw_writel(mfn, pllbase + MXC_PLL_DP_MFN);\r\n} else {\r\nreg = mfi << 4 | pdf;\r\n__raw_writel(reg, pllbase + MXC_PLL_DP_HFS_OP);\r\n__raw_writel(mfd, pllbase + MXC_PLL_DP_HFS_MFD);\r\n__raw_writel(mfn, pllbase + MXC_PLL_DP_HFS_MFN);\r\n}\r\nreturn 0;\r\n}\r\nstatic int _clk_pll_enable(struct clk *clk)\r\n{\r\nu32 reg;\r\nvoid __iomem *pllbase;\r\nint i = 0;\r\npllbase = _get_pll_base(clk);\r\nreg = __raw_readl(pllbase + MXC_PLL_DP_CTL);\r\nif (reg & MXC_PLL_DP_CTL_UPEN)\r\nreturn 0;\r\nreg |= MXC_PLL_DP_CTL_UPEN;\r\n__raw_writel(reg, pllbase + MXC_PLL_DP_CTL);\r\ndo {\r\nreg = __raw_readl(pllbase + MXC_PLL_DP_CTL);\r\nif (reg & MXC_PLL_DP_CTL_LRF)\r\nbreak;\r\nudelay(1);\r\n} while (++i < MAX_DPLL_WAIT_TRIES);\r\nif (i == MAX_DPLL_WAIT_TRIES) {\r\npr_err("MX5: pll locking failed\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void _clk_pll_disable(struct clk *clk)\r\n{\r\nu32 reg;\r\nvoid __iomem *pllbase;\r\npllbase = _get_pll_base(clk);\r\nreg = __raw_readl(pllbase + MXC_PLL_DP_CTL) & ~MXC_PLL_DP_CTL_UPEN;\r\n__raw_writel(reg, pllbase + MXC_PLL_DP_CTL);\r\n}\r\nstatic int _clk_pll1_sw_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nu32 reg, step;\r\nreg = __raw_readl(MXC_CCM_CCSR);\r\nif (parent == &pll1_main_clk) {\r\nreg &= ~MXC_CCM_CCSR_PLL1_SW_CLK_SEL;\r\n__raw_writel(reg, MXC_CCM_CCSR);\r\nreg = __raw_readl(MXC_CCM_CCSR);\r\nreg &= ~MXC_CCM_CCSR_STEP_SEL_MASK;\r\nreg |= (MXC_CCM_CCSR_STEP_SEL_LP_APM <<\r\nMXC_CCM_CCSR_STEP_SEL_OFFSET);\r\n} else {\r\nif (parent == &lp_apm_clk) {\r\nstep = MXC_CCM_CCSR_STEP_SEL_LP_APM;\r\n} else if (parent == &pll2_sw_clk) {\r\nstep = MXC_CCM_CCSR_STEP_SEL_PLL2_DIVIDED;\r\n} else if (parent == &pll3_sw_clk) {\r\nstep = MXC_CCM_CCSR_STEP_SEL_PLL3_DIVIDED;\r\n} else\r\nreturn -EINVAL;\r\nreg &= ~MXC_CCM_CCSR_STEP_SEL_MASK;\r\nreg |= (step << MXC_CCM_CCSR_STEP_SEL_OFFSET);\r\n__raw_writel(reg, MXC_CCM_CCSR);\r\nreg = __raw_readl(MXC_CCM_CCSR);\r\nreg |= MXC_CCM_CCSR_PLL1_SW_CLK_SEL;\r\n}\r\n__raw_writel(reg, MXC_CCM_CCSR);\r\nreturn 0;\r\n}\r\nstatic unsigned long clk_pll1_sw_get_rate(struct clk *clk)\r\n{\r\nu32 reg, div;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\nreg = __raw_readl(MXC_CCM_CCSR);\r\nif (clk->parent == &pll2_sw_clk) {\r\ndiv = ((reg & MXC_CCM_CCSR_PLL2_PODF_MASK) >>\r\nMXC_CCM_CCSR_PLL2_PODF_OFFSET) + 1;\r\n} else if (clk->parent == &pll3_sw_clk) {\r\ndiv = ((reg & MXC_CCM_CCSR_PLL3_PODF_MASK) >>\r\nMXC_CCM_CCSR_PLL3_PODF_OFFSET) + 1;\r\n} else\r\ndiv = 1;\r\nreturn parent_rate / div;\r\n}\r\nstatic int _clk_pll2_sw_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nu32 reg;\r\nreg = __raw_readl(MXC_CCM_CCSR);\r\nif (parent == &pll2_sw_clk)\r\nreg &= ~MXC_CCM_CCSR_PLL2_SW_CLK_SEL;\r\nelse\r\nreg |= MXC_CCM_CCSR_PLL2_SW_CLK_SEL;\r\n__raw_writel(reg, MXC_CCM_CCSR);\r\nreturn 0;\r\n}\r\nstatic int _clk_lp_apm_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nu32 reg;\r\nif (parent == &osc_clk)\r\nreg = __raw_readl(MXC_CCM_CCSR) & ~MXC_CCM_CCSR_LP_APM_SEL;\r\nelse\r\nreturn -EINVAL;\r\n__raw_writel(reg, MXC_CCM_CCSR);\r\nreturn 0;\r\n}\r\nstatic unsigned long clk_cpu_get_rate(struct clk *clk)\r\n{\r\nu32 cacrr, div;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\ncacrr = __raw_readl(MXC_CCM_CACRR);\r\ndiv = (cacrr & MXC_CCM_CACRR_ARM_PODF_MASK) + 1;\r\nreturn parent_rate / div;\r\n}\r\nstatic int clk_cpu_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nu32 reg, cpu_podf;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\ncpu_podf = parent_rate / rate - 1;\r\nreg = __raw_readl(MXC_CCM_CACRR);\r\nreg &= ~MXC_CCM_CACRR_ARM_PODF_MASK;\r\nreg |= cpu_podf << MXC_CCM_CACRR_ARM_PODF_OFFSET;\r\n__raw_writel(reg, MXC_CCM_CACRR);\r\nreturn 0;\r\n}\r\nstatic int _clk_periph_apm_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nu32 reg, mux;\r\nint i = 0;\r\nmux = _get_mux(parent, &pll1_sw_clk, &pll3_sw_clk, &lp_apm_clk, NULL);\r\nreg = __raw_readl(MXC_CCM_CBCMR) & ~MXC_CCM_CBCMR_PERIPH_CLK_SEL_MASK;\r\nreg |= mux << MXC_CCM_CBCMR_PERIPH_CLK_SEL_OFFSET;\r\n__raw_writel(reg, MXC_CCM_CBCMR);\r\ndo {\r\nreg = __raw_readl(MXC_CCM_CDHIPR);\r\nif (!(reg & MXC_CCM_CDHIPR_PERIPH_CLK_SEL_BUSY))\r\nbreak;\r\nudelay(1);\r\n} while (++i < MAX_DPLL_WAIT_TRIES);\r\nif (i == MAX_DPLL_WAIT_TRIES) {\r\npr_err("MX5: Set parent for periph_apm clock failed\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int _clk_main_bus_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nu32 reg;\r\nreg = __raw_readl(MXC_CCM_CBCDR);\r\nif (parent == &pll2_sw_clk)\r\nreg &= ~MXC_CCM_CBCDR_PERIPH_CLK_SEL;\r\nelse if (parent == &periph_apm_clk)\r\nreg |= MXC_CCM_CBCDR_PERIPH_CLK_SEL;\r\nelse\r\nreturn -EINVAL;\r\n__raw_writel(reg, MXC_CCM_CBCDR);\r\nreturn 0;\r\n}\r\nstatic unsigned long clk_ahb_get_rate(struct clk *clk)\r\n{\r\nu32 reg, div;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\nreg = __raw_readl(MXC_CCM_CBCDR);\r\ndiv = ((reg & MXC_CCM_CBCDR_AHB_PODF_MASK) >>\r\nMXC_CCM_CBCDR_AHB_PODF_OFFSET) + 1;\r\nreturn parent_rate / div;\r\n}\r\nstatic int _clk_ahb_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nu32 reg, div;\r\nunsigned long parent_rate;\r\nint i = 0;\r\nparent_rate = clk_get_rate(clk->parent);\r\ndiv = parent_rate / rate;\r\nif (div > 8 || div < 1 || ((parent_rate / div) != rate))\r\nreturn -EINVAL;\r\nreg = __raw_readl(MXC_CCM_CBCDR);\r\nreg &= ~MXC_CCM_CBCDR_AHB_PODF_MASK;\r\nreg |= (div - 1) << MXC_CCM_CBCDR_AHB_PODF_OFFSET;\r\n__raw_writel(reg, MXC_CCM_CBCDR);\r\ndo {\r\nreg = __raw_readl(MXC_CCM_CDHIPR);\r\nif (!(reg & MXC_CCM_CDHIPR_AHB_PODF_BUSY))\r\nbreak;\r\nudelay(1);\r\n} while (++i < MAX_DPLL_WAIT_TRIES);\r\nif (i == MAX_DPLL_WAIT_TRIES) {\r\npr_err("MX5: clk_ahb_set_rate failed\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned long _clk_ahb_round_rate(struct clk *clk,\r\nunsigned long rate)\r\n{\r\nu32 div;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\ndiv = parent_rate / rate;\r\nif (div > 8)\r\ndiv = 8;\r\nelse if (div == 0)\r\ndiv++;\r\nreturn parent_rate / div;\r\n}\r\nstatic int _clk_max_enable(struct clk *clk)\r\n{\r\nu32 reg;\r\n_clk_ccgr_enable(clk);\r\nreg = __raw_readl(MXC_CCM_CLPCR);\r\nif (cpu_is_mx51())\r\nreg &= ~MX51_CCM_CLPCR_BYPASS_MAX_LPM_HS;\r\nelse if (cpu_is_mx53())\r\nreg &= ~MX53_CCM_CLPCR_BYPASS_MAX_LPM_HS;\r\n__raw_writel(reg, MXC_CCM_CLPCR);\r\nreturn 0;\r\n}\r\nstatic void _clk_max_disable(struct clk *clk)\r\n{\r\nu32 reg;\r\n_clk_ccgr_disable_inwait(clk);\r\nreg = __raw_readl(MXC_CCM_CLPCR);\r\nif (cpu_is_mx51())\r\nreg |= MX51_CCM_CLPCR_BYPASS_MAX_LPM_HS;\r\nelse if (cpu_is_mx53())\r\nreg &= ~MX53_CCM_CLPCR_BYPASS_MAX_LPM_HS;\r\n__raw_writel(reg, MXC_CCM_CLPCR);\r\n}\r\nstatic unsigned long clk_ipg_get_rate(struct clk *clk)\r\n{\r\nu32 reg, div;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\nreg = __raw_readl(MXC_CCM_CBCDR);\r\ndiv = ((reg & MXC_CCM_CBCDR_IPG_PODF_MASK) >>\r\nMXC_CCM_CBCDR_IPG_PODF_OFFSET) + 1;\r\nreturn parent_rate / div;\r\n}\r\nstatic unsigned long clk_ipg_per_get_rate(struct clk *clk)\r\n{\r\nu32 reg, prediv1, prediv2, podf;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\nif (clk->parent == &main_bus_clk || clk->parent == &lp_apm_clk) {\r\nreg = __raw_readl(MXC_CCM_CBCDR);\r\nprediv1 = ((reg & MXC_CCM_CBCDR_PERCLK_PRED1_MASK) >>\r\nMXC_CCM_CBCDR_PERCLK_PRED1_OFFSET) + 1;\r\nprediv2 = ((reg & MXC_CCM_CBCDR_PERCLK_PRED2_MASK) >>\r\nMXC_CCM_CBCDR_PERCLK_PRED2_OFFSET) + 1;\r\npodf = ((reg & MXC_CCM_CBCDR_PERCLK_PODF_MASK) >>\r\nMXC_CCM_CBCDR_PERCLK_PODF_OFFSET) + 1;\r\nreturn parent_rate / (prediv1 * prediv2 * podf);\r\n} else if (clk->parent == &ipg_clk)\r\nreturn parent_rate;\r\nelse\r\nBUG();\r\n}\r\nstatic int _clk_ipg_per_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nu32 reg;\r\nreg = __raw_readl(MXC_CCM_CBCMR);\r\nreg &= ~MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL;\r\nreg &= ~MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL;\r\nif (parent == &ipg_clk)\r\nreg |= MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL;\r\nelse if (parent == &lp_apm_clk)\r\nreg |= MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL;\r\nelse if (parent != &main_bus_clk)\r\nreturn -EINVAL;\r\n__raw_writel(reg, MXC_CCM_CBCMR);\r\nreturn 0;\r\n}\r\nstatic unsigned long clk_nfc_get_rate(struct clk *clk)\r\n{\r\nunsigned long rate;\r\nu32 reg, div;\r\nreg = __raw_readl(MXC_CCM_CBCDR);\r\ndiv = ((reg & MXC_CCM_CBCDR_NFC_PODF_MASK) >>\r\nMXC_CCM_CBCDR_NFC_PODF_OFFSET) + 1;\r\nrate = clk_get_rate(clk->parent) / div;\r\nWARN_ON(rate == 0);\r\nreturn rate;\r\n}\r\nstatic unsigned long clk_nfc_round_rate(struct clk *clk,\r\nunsigned long rate)\r\n{\r\nu32 div;\r\nunsigned long parent_rate = clk_get_rate(clk->parent);\r\nif (!rate)\r\nreturn -EINVAL;\r\ndiv = parent_rate / rate;\r\nif (parent_rate % rate)\r\ndiv++;\r\nif (div > 8)\r\nreturn -EINVAL;\r\nreturn parent_rate / div;\r\n}\r\nstatic int clk_nfc_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nu32 reg, div;\r\ndiv = clk_get_rate(clk->parent) / rate;\r\nif (div == 0)\r\ndiv++;\r\nif (((clk_get_rate(clk->parent) / div) != rate) || (div > 8))\r\nreturn -EINVAL;\r\nreg = __raw_readl(MXC_CCM_CBCDR);\r\nreg &= ~MXC_CCM_CBCDR_NFC_PODF_MASK;\r\nreg |= (div - 1) << MXC_CCM_CBCDR_NFC_PODF_OFFSET;\r\n__raw_writel(reg, MXC_CCM_CBCDR);\r\nwhile (__raw_readl(MXC_CCM_CDHIPR) &\r\nMXC_CCM_CDHIPR_NFC_IPG_INT_MEM_PODF_BUSY){\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned long get_high_reference_clock_rate(struct clk *clk)\r\n{\r\nreturn external_high_reference;\r\n}\r\nstatic unsigned long get_low_reference_clock_rate(struct clk *clk)\r\n{\r\nreturn external_low_reference;\r\n}\r\nstatic unsigned long get_oscillator_reference_clock_rate(struct clk *clk)\r\n{\r\nreturn oscillator_reference;\r\n}\r\nstatic unsigned long get_ckih2_reference_clock_rate(struct clk *clk)\r\n{\r\nreturn ckih2_reference;\r\n}\r\nstatic unsigned long clk_emi_slow_get_rate(struct clk *clk)\r\n{\r\nu32 reg, div;\r\nreg = __raw_readl(MXC_CCM_CBCDR);\r\ndiv = ((reg & MXC_CCM_CBCDR_EMI_PODF_MASK) >>\r\nMXC_CCM_CBCDR_EMI_PODF_OFFSET) + 1;\r\nreturn clk_get_rate(clk->parent) / div;\r\n}\r\nstatic unsigned long _clk_ddr_hf_get_rate(struct clk *clk)\r\n{\r\nunsigned long rate;\r\nu32 reg, div;\r\nreg = __raw_readl(MXC_CCM_CBCDR);\r\ndiv = ((reg & MXC_CCM_CBCDR_DDR_PODF_MASK) >>\r\nMXC_CCM_CBCDR_DDR_PODF_OFFSET) + 1;\r\nrate = clk_get_rate(clk->parent) / div;\r\nreturn rate;\r\n}\r\nstatic int clk_ipu_enable(struct clk *clk)\r\n{\r\nu32 reg;\r\n_clk_ccgr_enable(clk);\r\nreg = __raw_readl(MXC_CCM_CCDR);\r\nreg &= ~MXC_CCM_CCDR_IPU_HS_MASK;\r\n__raw_writel(reg, MXC_CCM_CCDR);\r\nreg = __raw_readl(MXC_CCM_CLPCR);\r\nreg &= ~MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS;\r\n__raw_writel(reg, MXC_CCM_CLPCR);\r\nreturn 0;\r\n}\r\nstatic void clk_ipu_disable(struct clk *clk)\r\n{\r\nu32 reg;\r\n_clk_ccgr_disable(clk);\r\nreg = __raw_readl(MXC_CCM_CCDR);\r\nreg |= MXC_CCM_CCDR_IPU_HS_MASK;\r\n__raw_writel(reg, MXC_CCM_CCDR);\r\nreg = __raw_readl(MXC_CCM_CLPCR);\r\nreg |= MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS;\r\n__raw_writel(reg, MXC_CCM_CLPCR);\r\n}\r\nstatic int _clk_hsc_enable(struct clk *clk)\r\n{\r\nu32 reg;\r\n_clk_ccgr_enable(clk);\r\nreg = __raw_readl(MXC_CCM_CCDR);\r\nreg &= ~MXC_CCM_CCDR_HSC_HS_MASK;\r\n__raw_writel(reg, MXC_CCM_CCDR);\r\nreg = __raw_readl(MXC_CCM_CLPCR);\r\nreg &= ~MXC_CCM_CLPCR_BYPASS_HSC_LPM_HS;\r\n__raw_writel(reg, MXC_CCM_CLPCR);\r\nreturn 0;\r\n}\r\nstatic void _clk_hsc_disable(struct clk *clk)\r\n{\r\nu32 reg;\r\n_clk_ccgr_disable(clk);\r\nreg = __raw_readl(MXC_CCM_CCDR);\r\nreg |= MXC_CCM_CCDR_HSC_HS_MASK;\r\n__raw_writel(reg, MXC_CCM_CCDR);\r\nreg = __raw_readl(MXC_CCM_CLPCR);\r\nreg |= MXC_CCM_CLPCR_BYPASS_HSC_LPM_HS;\r\n__raw_writel(reg, MXC_CCM_CLPCR);\r\n}\r\nstatic int clk_usb_phy1_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nu32 reg;\r\nreg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_USB_PHY_CLK_SEL;\r\nif (parent == &pll3_sw_clk)\r\nreg |= 1 << MXC_CCM_CSCMR1_USB_PHY_CLK_SEL_OFFSET;\r\n__raw_writel(reg, MXC_CCM_CSCMR1);\r\nreturn 0;\r\n}\r\nstatic int clk_esdhc3_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nu32 reg;\r\nreg = __raw_readl(MXC_CCM_CSCMR1);\r\nif (parent == &esdhc1_clk)\r\nreg &= ~MXC_CCM_CSCMR1_ESDHC3_CLK_SEL;\r\nelse if (parent == &esdhc2_clk)\r\nreg |= MXC_CCM_CSCMR1_ESDHC3_CLK_SEL;\r\nelse\r\nreturn -EINVAL;\r\n__raw_writel(reg, MXC_CCM_CSCMR1);\r\nreturn 0;\r\n}\r\nstatic int clk_esdhc4_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nu32 reg;\r\nreg = __raw_readl(MXC_CCM_CSCMR1);\r\nif (parent == &esdhc1_clk)\r\nreg &= ~MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;\r\nelse if (parent == &esdhc2_clk)\r\nreg |= MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;\r\nelse\r\nreturn -EINVAL;\r\n__raw_writel(reg, MXC_CCM_CSCMR1);\r\nreturn 0;\r\n}\r\nstatic int clk_esdhc2_mx53_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nu32 reg;\r\nreg = __raw_readl(MXC_CCM_CSCMR1);\r\nif (parent == &esdhc1_clk)\r\nreg &= ~MXC_CCM_CSCMR1_ESDHC2_MSHC2_MX53_CLK_SEL;\r\nelse if (parent == &esdhc3_mx53_clk)\r\nreg |= MXC_CCM_CSCMR1_ESDHC2_MSHC2_MX53_CLK_SEL;\r\nelse\r\nreturn -EINVAL;\r\n__raw_writel(reg, MXC_CCM_CSCMR1);\r\nreturn 0;\r\n}\r\nstatic int clk_esdhc4_mx53_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nu32 reg;\r\nreg = __raw_readl(MXC_CCM_CSCMR1);\r\nif (parent == &esdhc1_clk)\r\nreg &= ~MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;\r\nelse if (parent == &esdhc3_mx53_clk)\r\nreg |= MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;\r\nelse\r\nreturn -EINVAL;\r\n__raw_writel(reg, MXC_CCM_CSCMR1);\r\nreturn 0;\r\n}\r\nstatic void clk_tree_init(void)\r\n{\r\nu32 reg;\r\nipg_perclk.set_parent(&ipg_perclk, &lp_apm_clk);\r\nreg = __raw_readl(MXC_CCM_CBCDR);\r\nreg &= ~MXC_CCM_CBCDR_PERCLK_PRED1_MASK;\r\nreg &= ~MXC_CCM_CBCDR_PERCLK_PRED2_MASK;\r\nreg &= ~MXC_CCM_CBCDR_PERCLK_PODF_MASK;\r\nreg |= (2 << MXC_CCM_CBCDR_PERCLK_PRED1_OFFSET);\r\n__raw_writel(reg, MXC_CCM_CBCDR);\r\n}\r\nint __init mx51_clocks_init(unsigned long ckil, unsigned long osc,\r\nunsigned long ckih1, unsigned long ckih2)\r\n{\r\nint i;\r\nexternal_low_reference = ckil;\r\nexternal_high_reference = ckih1;\r\nckih2_reference = ckih2;\r\noscillator_reference = osc;\r\nfor (i = 0; i < ARRAY_SIZE(mx51_lookups); i++)\r\nclkdev_add(&mx51_lookups[i]);\r\nclk_tree_init();\r\nclk_enable(&cpu_clk);\r\nclk_enable(&main_bus_clk);\r\nclk_enable(&iim_clk);\r\nimx_print_silicon_rev("i.MX51", mx51_revision());\r\nclk_disable(&iim_clk);\r\nclk_set_parent(&usb_phy1_clk, &osc_clk);\r\nclk_set_parent(&usboh3_clk, &pll2_sw_clk);\r\nclk_set_parent(&esdhc1_clk, &pll2_sw_clk);\r\nclk_set_parent(&esdhc2_clk, &pll2_sw_clk);\r\nclk_set_rate(&esdhc1_clk, 166250000);\r\nclk_set_rate(&esdhc2_clk, 166250000);\r\nmxc_timer_init(&gpt_clk, MX51_IO_ADDRESS(MX51_GPT1_BASE_ADDR),\r\nMX51_INT_GPT);\r\nreturn 0;\r\n}\r\nint __init mx53_clocks_init(unsigned long ckil, unsigned long osc,\r\nunsigned long ckih1, unsigned long ckih2)\r\n{\r\nint i;\r\nexternal_low_reference = ckil;\r\nexternal_high_reference = ckih1;\r\nckih2_reference = ckih2;\r\noscillator_reference = osc;\r\nfor (i = 0; i < ARRAY_SIZE(mx53_lookups); i++)\r\nclkdev_add(&mx53_lookups[i]);\r\nclk_tree_init();\r\nclk_set_parent(&uart_root_clk, &pll3_sw_clk);\r\nclk_enable(&cpu_clk);\r\nclk_enable(&main_bus_clk);\r\nclk_enable(&iim_clk);\r\nimx_print_silicon_rev("i.MX53", mx53_revision());\r\nclk_disable(&iim_clk);\r\nclk_set_parent(&esdhc1_clk, &pll2_sw_clk);\r\nclk_set_parent(&esdhc3_mx53_clk, &pll2_sw_clk);\r\nclk_set_rate(&esdhc1_clk, 200000000);\r\nclk_set_rate(&esdhc3_mx53_clk, 200000000);\r\nmxc_timer_init(&gpt_clk, MX53_IO_ADDRESS(MX53_GPT1_BASE_ADDR),\r\nMX53_INT_GPT);\r\nreturn 0;\r\n}\r\nstatic void __init clk_get_freq_dt(unsigned long *ckil, unsigned long *osc,\r\nunsigned long *ckih1, unsigned long *ckih2)\r\n{\r\nstruct device_node *np;\r\nfor_each_compatible_node(np, NULL, "fixed-clock") {\r\nu32 rate;\r\nif (of_property_read_u32(np, "clock-frequency", &rate))\r\ncontinue;\r\nif (of_device_is_compatible(np, "fsl,imx-ckil"))\r\n*ckil = rate;\r\nelse if (of_device_is_compatible(np, "fsl,imx-osc"))\r\n*osc = rate;\r\nelse if (of_device_is_compatible(np, "fsl,imx-ckih1"))\r\n*ckih1 = rate;\r\nelse if (of_device_is_compatible(np, "fsl,imx-ckih2"))\r\n*ckih2 = rate;\r\n}\r\n}\r\nint __init mx51_clocks_init_dt(void)\r\n{\r\nunsigned long ckil, osc, ckih1, ckih2;\r\nclk_get_freq_dt(&ckil, &osc, &ckih1, &ckih2);\r\nreturn mx51_clocks_init(ckil, osc, ckih1, ckih2);\r\n}\r\nint __init mx53_clocks_init_dt(void)\r\n{\r\nunsigned long ckil, osc, ckih1, ckih2;\r\nclk_get_freq_dt(&ckil, &osc, &ckih1, &ckih2);\r\nreturn mx53_clocks_init(ckil, osc, ckih1, ckih2);\r\n}
