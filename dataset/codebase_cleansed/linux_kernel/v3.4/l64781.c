static int l64781_writereg (struct l64781_state* state, u8 reg, u8 data)\r\n{\r\nint ret;\r\nu8 buf [] = { reg, data };\r\nstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = buf, .len = 2 };\r\nif ((ret = i2c_transfer(state->i2c, &msg, 1)) != 1)\r\ndprintk ("%s: write_reg error (reg == %02x) = %02x!\n",\r\n__func__, reg, ret);\r\nreturn (ret != 1) ? -1 : 0;\r\n}\r\nstatic int l64781_readreg (struct l64781_state* state, u8 reg)\r\n{\r\nint ret;\r\nu8 b0 [] = { reg };\r\nu8 b1 [] = { 0 };\r\nstruct i2c_msg msg [] = { { .addr = state->config->demod_address, .flags = 0, .buf = b0, .len = 1 },\r\n{ .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 1 } };\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2) return ret;\r\nreturn b1[0];\r\n}\r\nstatic void apply_tps (struct l64781_state* state)\r\n{\r\nl64781_writereg (state, 0x2a, 0x00);\r\nl64781_writereg (state, 0x2a, 0x01);\r\nl64781_writereg (state, 0x2a, 0x02);\r\n}\r\nstatic void reset_afc (struct l64781_state* state)\r\n{\r\nl64781_writereg (state, 0x07, 0x9e);\r\nl64781_writereg (state, 0x08, 0);\r\nl64781_writereg (state, 0x09, 0);\r\nl64781_writereg (state, 0x0a, 0);\r\nl64781_writereg (state, 0x07, 0x8e);\r\nl64781_writereg (state, 0x0e, 0);\r\nl64781_writereg (state, 0x11, 0x80);\r\nl64781_writereg (state, 0x10, 0);\r\nl64781_writereg (state, 0x12, 0);\r\nl64781_writereg (state, 0x13, 0);\r\nl64781_writereg (state, 0x11, 0x00);\r\n}\r\nstatic int reset_and_configure (struct l64781_state* state)\r\n{\r\nu8 buf [] = { 0x06 };\r\nstruct i2c_msg msg = { .addr = 0x00, .flags = 0, .buf = buf, .len = 1 };\r\nreturn (i2c_transfer(state->i2c, &msg, 1) == 1) ? 0 : -ENODEV;\r\n}\r\nstatic int apply_frontend_param(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct l64781_state* state = fe->demodulator_priv;\r\nstatic const u8 fec_tab[] = { 7, 0, 1, 2, 9, 3, 10, 4 };\r\nstatic const u8 qam_tab [] = { 2, 4, 0, 6 };\r\nstatic const u8 guard_tab [] = { 1, 2, 4, 8 };\r\nstatic const u32 ppm = 8000;\r\nu32 ddfs_offset_fixed;\r\nu32 init_freq;\r\nu32 spi_bias;\r\nu8 val0x04;\r\nu8 val0x05;\r\nu8 val0x06;\r\nint bw;\r\nswitch (p->bandwidth_hz) {\r\ncase 8000000:\r\nbw = 8;\r\nbreak;\r\ncase 7000000:\r\nbw = 7;\r\nbreak;\r\ncase 6000000:\r\nbw = 6;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nif (p->inversion != INVERSION_ON &&\r\np->inversion != INVERSION_OFF)\r\nreturn -EINVAL;\r\nif (p->code_rate_HP != FEC_1_2 && p->code_rate_HP != FEC_2_3 &&\r\np->code_rate_HP != FEC_3_4 && p->code_rate_HP != FEC_5_6 &&\r\np->code_rate_HP != FEC_7_8)\r\nreturn -EINVAL;\r\nif (p->hierarchy != HIERARCHY_NONE &&\r\n(p->code_rate_LP != FEC_1_2 && p->code_rate_LP != FEC_2_3 &&\r\np->code_rate_LP != FEC_3_4 && p->code_rate_LP != FEC_5_6 &&\r\np->code_rate_LP != FEC_7_8))\r\nreturn -EINVAL;\r\nif (p->modulation != QPSK && p->modulation != QAM_16 &&\r\np->modulation != QAM_64)\r\nreturn -EINVAL;\r\nif (p->transmission_mode != TRANSMISSION_MODE_2K &&\r\np->transmission_mode != TRANSMISSION_MODE_8K)\r\nreturn -EINVAL;\r\nif (p->guard_interval < GUARD_INTERVAL_1_32 ||\r\np->guard_interval > GUARD_INTERVAL_1_4)\r\nreturn -EINVAL;\r\nif (p->hierarchy < HIERARCHY_NONE ||\r\np->hierarchy > HIERARCHY_4)\r\nreturn -EINVAL;\r\nddfs_offset_fixed = 0x4000-(ppm<<16)/bw/1000000;\r\ninit_freq = (((8UL<<25) + (8UL<<19) / 25*ppm / (15625/25)) /\r\nbw & 0xFFFFFF);\r\nspi_bias = 378 * (1 << 10);\r\nspi_bias *= 16;\r\nspi_bias *= bw;\r\nspi_bias *= qam_tab[p->modulation];\r\nspi_bias /= p->code_rate_HP + 1;\r\nspi_bias /= (guard_tab[p->guard_interval] + 32);\r\nspi_bias *= 1000;\r\nspi_bias /= 1000 + ppm/1000;\r\nspi_bias *= p->code_rate_HP;\r\nval0x04 = (p->transmission_mode << 2) | p->guard_interval;\r\nval0x05 = fec_tab[p->code_rate_HP];\r\nif (p->hierarchy != HIERARCHY_NONE)\r\nval0x05 |= (p->code_rate_LP - FEC_1_2) << 3;\r\nval0x06 = (p->hierarchy << 2) | p->modulation;\r\nl64781_writereg (state, 0x04, val0x04);\r\nl64781_writereg (state, 0x05, val0x05);\r\nl64781_writereg (state, 0x06, val0x06);\r\nreset_afc (state);\r\nl64781_writereg (state, 0x15,\r\np->transmission_mode == TRANSMISSION_MODE_2K ? 1 : 3);\r\nl64781_writereg (state, 0x16, init_freq & 0xff);\r\nl64781_writereg (state, 0x17, (init_freq >> 8) & 0xff);\r\nl64781_writereg (state, 0x18, (init_freq >> 16) & 0xff);\r\nl64781_writereg (state, 0x1b, spi_bias & 0xff);\r\nl64781_writereg (state, 0x1c, (spi_bias >> 8) & 0xff);\r\nl64781_writereg (state, 0x1d, ((spi_bias >> 16) & 0x7f) |\r\n(p->inversion == INVERSION_ON ? 0x80 : 0x00));\r\nl64781_writereg (state, 0x22, ddfs_offset_fixed & 0xff);\r\nl64781_writereg (state, 0x23, (ddfs_offset_fixed >> 8) & 0x3f);\r\nl64781_readreg (state, 0x00);\r\nl64781_readreg (state, 0x01);\r\napply_tps (state);\r\nreturn 0;\r\n}\r\nstatic int get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct l64781_state* state = fe->demodulator_priv;\r\nint tmp;\r\ntmp = l64781_readreg(state, 0x04);\r\nswitch(tmp & 3) {\r\ncase 0:\r\np->guard_interval = GUARD_INTERVAL_1_32;\r\nbreak;\r\ncase 1:\r\np->guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\ncase 2:\r\np->guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\np->guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\n}\r\nswitch((tmp >> 2) & 3) {\r\ncase 0:\r\np->transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 1:\r\np->transmission_mode = TRANSMISSION_MODE_8K;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "Unexpected value for transmission_mode\n");\r\n}\r\ntmp = l64781_readreg(state, 0x05);\r\nswitch(tmp & 7) {\r\ncase 0:\r\np->code_rate_HP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\np->code_rate_HP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\np->code_rate_HP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\np->code_rate_HP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\np->code_rate_HP = FEC_7_8;\r\nbreak;\r\ndefault:\r\nprintk("Unexpected value for code_rate_HP\n");\r\n}\r\nswitch((tmp >> 3) & 7) {\r\ncase 0:\r\np->code_rate_LP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\np->code_rate_LP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\np->code_rate_LP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\np->code_rate_LP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\np->code_rate_LP = FEC_7_8;\r\nbreak;\r\ndefault:\r\nprintk("Unexpected value for code_rate_LP\n");\r\n}\r\ntmp = l64781_readreg(state, 0x06);\r\nswitch(tmp & 3) {\r\ncase 0:\r\np->modulation = QPSK;\r\nbreak;\r\ncase 1:\r\np->modulation = QAM_16;\r\nbreak;\r\ncase 2:\r\np->modulation = QAM_64;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "Unexpected value for modulation\n");\r\n}\r\nswitch((tmp >> 2) & 7) {\r\ncase 0:\r\np->hierarchy = HIERARCHY_NONE;\r\nbreak;\r\ncase 1:\r\np->hierarchy = HIERARCHY_1;\r\nbreak;\r\ncase 2:\r\np->hierarchy = HIERARCHY_2;\r\nbreak;\r\ncase 3:\r\np->hierarchy = HIERARCHY_4;\r\nbreak;\r\ndefault:\r\nprintk("Unexpected value for hierarchy\n");\r\n}\r\ntmp = l64781_readreg (state, 0x1d);\r\np->inversion = (tmp & 0x80) ? INVERSION_ON : INVERSION_OFF;\r\ntmp = (int) (l64781_readreg (state, 0x08) |\r\n(l64781_readreg (state, 0x09) << 8) |\r\n(l64781_readreg (state, 0x0a) << 16));\r\np->frequency += tmp;\r\nreturn 0;\r\n}\r\nstatic int l64781_read_status(struct dvb_frontend* fe, fe_status_t* status)\r\n{\r\nstruct l64781_state* state = fe->demodulator_priv;\r\nint sync = l64781_readreg (state, 0x32);\r\nint gain = l64781_readreg (state, 0x0e);\r\nl64781_readreg (state, 0x00);\r\nl64781_readreg (state, 0x01);\r\n*status = 0;\r\nif (gain > 5)\r\n*status |= FE_HAS_SIGNAL;\r\nif (sync & 0x02)\r\n*status |= FE_HAS_CARRIER;\r\nif (sync & 0x20)\r\n*status |= FE_HAS_VITERBI;\r\nif (sync & 0x40)\r\n*status |= FE_HAS_SYNC;\r\nif (sync == 0x7f)\r\n*status |= FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int l64781_read_ber(struct dvb_frontend* fe, u32* ber)\r\n{\r\nstruct l64781_state* state = fe->demodulator_priv;\r\n*ber = l64781_readreg (state, 0x39)\r\n| (l64781_readreg (state, 0x3a) << 8);\r\nreturn 0;\r\n}\r\nstatic int l64781_read_signal_strength(struct dvb_frontend* fe, u16* signal_strength)\r\n{\r\nstruct l64781_state* state = fe->demodulator_priv;\r\nu8 gain = l64781_readreg (state, 0x0e);\r\n*signal_strength = (gain << 8) | gain;\r\nreturn 0;\r\n}\r\nstatic int l64781_read_snr(struct dvb_frontend* fe, u16* snr)\r\n{\r\nstruct l64781_state* state = fe->demodulator_priv;\r\nu8 avg_quality = 0xff - l64781_readreg (state, 0x33);\r\n*snr = (avg_quality << 8) | avg_quality;\r\nreturn 0;\r\n}\r\nstatic int l64781_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\r\n{\r\nstruct l64781_state* state = fe->demodulator_priv;\r\n*ucblocks = l64781_readreg (state, 0x37)\r\n| (l64781_readreg (state, 0x38) << 8);\r\nreturn 0;\r\n}\r\nstatic int l64781_sleep(struct dvb_frontend* fe)\r\n{\r\nstruct l64781_state* state = fe->demodulator_priv;\r\nreturn l64781_writereg (state, 0x3e, 0x5a);\r\n}\r\nstatic int l64781_init(struct dvb_frontend* fe)\r\n{\r\nstruct l64781_state* state = fe->demodulator_priv;\r\nreset_and_configure (state);\r\nl64781_writereg (state, 0x3e, 0xa5);\r\nl64781_writereg (state, 0x2a, 0x04);\r\nl64781_writereg (state, 0x2a, 0x00);\r\nl64781_writereg (state, 0x07, 0x8e);\r\nl64781_writereg (state, 0x0b, 0x81);\r\nl64781_writereg (state, 0x0c, 0x84);\r\nl64781_writereg (state, 0x0d, 0x8c);\r\nl64781_writereg (state, 0x1e, 0x09);\r\nif (state->first) {\r\nstate->first = 0;\r\nmsleep(200);\r\n}\r\nreturn 0;\r\n}\r\nstatic int l64781_get_tune_settings(struct dvb_frontend* fe,\r\nstruct dvb_frontend_tune_settings* fesettings)\r\n{\r\nfesettings->min_delay_ms = 4000;\r\nfesettings->step_size = 0;\r\nfesettings->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic void l64781_release(struct dvb_frontend* fe)\r\n{\r\nstruct l64781_state* state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend* l64781_attach(const struct l64781_config* config,\r\nstruct i2c_adapter* i2c)\r\n{\r\nstruct l64781_state* state = NULL;\r\nint reg0x3e = -1;\r\nu8 b0 [] = { 0x1a };\r\nu8 b1 [] = { 0x00 };\r\nstruct i2c_msg msg [] = { { .addr = config->demod_address, .flags = 0, .buf = b0, .len = 1 },\r\n{ .addr = config->demod_address, .flags = I2C_M_RD, .buf = b1, .len = 1 } };\r\nstate = kzalloc(sizeof(struct l64781_state), GFP_KERNEL);\r\nif (state == NULL) goto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->first = 1;\r\nif (reset_and_configure(state) < 0) {\r\ndprintk("No response to reset and configure broadcast...\n");\r\ngoto error;\r\n}\r\nif (i2c_transfer(state->i2c, msg, 2) != 2) {\r\ndprintk("No response to read on I2C bus\n");\r\ngoto error;\r\n}\r\nreg0x3e = l64781_readreg(state, 0x3e);\r\nif (reg0x3e != 0) {\r\ndprintk("Device doesn't look like L64781\n");\r\ngoto error;\r\n}\r\nl64781_writereg (state, 0x3e, 0x5a);\r\nif (l64781_readreg(state, 0x1a) != 0) {\r\ndprintk("Read 1 returned unexpcted value\n");\r\ngoto error;\r\n}\r\nl64781_writereg (state, 0x3e, 0xa5);\r\nif (l64781_readreg(state, 0x1a) != 0xa1) {\r\ndprintk("Read 2 returned unexpcted value\n");\r\ngoto error;\r\n}\r\nmemcpy(&state->frontend.ops, &l64781_ops, sizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nif (reg0x3e >= 0)\r\nl64781_writereg (state, 0x3e, reg0x3e);\r\nkfree(state);\r\nreturn NULL;\r\n}
