static void send_reset(struct net *net, struct sk_buff *oldskb)\r\n{\r\nstruct sk_buff *nskb;\r\nstruct tcphdr otcph, *tcph;\r\nunsigned int otcplen, hh_len;\r\nint tcphoff, needs_ack;\r\nconst struct ipv6hdr *oip6h = ipv6_hdr(oldskb);\r\nstruct ipv6hdr *ip6h;\r\n#define DEFAULT_TOS_VALUE 0x0U\r\nconst __u8 tclass = DEFAULT_TOS_VALUE;\r\nstruct dst_entry *dst = NULL;\r\nu8 proto;\r\n__be16 frag_off;\r\nstruct flowi6 fl6;\r\nif ((!(ipv6_addr_type(&oip6h->saddr) & IPV6_ADDR_UNICAST)) ||\r\n(!(ipv6_addr_type(&oip6h->daddr) & IPV6_ADDR_UNICAST))) {\r\npr_debug("addr is not unicast.\n");\r\nreturn;\r\n}\r\nproto = oip6h->nexthdr;\r\ntcphoff = ipv6_skip_exthdr(oldskb, ((u8*)(oip6h+1) - oldskb->data), &proto, &frag_off);\r\nif ((tcphoff < 0) || (tcphoff > oldskb->len)) {\r\npr_debug("Cannot get TCP header.\n");\r\nreturn;\r\n}\r\notcplen = oldskb->len - tcphoff;\r\nif (proto != IPPROTO_TCP || otcplen < sizeof(struct tcphdr)) {\r\npr_debug("proto(%d) != IPPROTO_TCP, "\r\n"or too short. otcplen = %d\n",\r\nproto, otcplen);\r\nreturn;\r\n}\r\nif (skb_copy_bits(oldskb, tcphoff, &otcph, sizeof(struct tcphdr)))\r\nBUG();\r\nif (otcph.rst) {\r\npr_debug("RST is set\n");\r\nreturn;\r\n}\r\nif (csum_ipv6_magic(&oip6h->saddr, &oip6h->daddr, otcplen, IPPROTO_TCP,\r\nskb_checksum(oldskb, tcphoff, otcplen, 0))) {\r\npr_debug("TCP checksum is invalid\n");\r\nreturn;\r\n}\r\nmemset(&fl6, 0, sizeof(fl6));\r\nfl6.flowi6_proto = IPPROTO_TCP;\r\nfl6.saddr = oip6h->daddr;\r\nfl6.daddr = oip6h->saddr;\r\nfl6.fl6_sport = otcph.dest;\r\nfl6.fl6_dport = otcph.source;\r\nsecurity_skb_classify_flow(oldskb, flowi6_to_flowi(&fl6));\r\ndst = ip6_route_output(net, NULL, &fl6);\r\nif (dst == NULL || dst->error) {\r\ndst_release(dst);\r\nreturn;\r\n}\r\ndst = xfrm_lookup(net, dst, flowi6_to_flowi(&fl6), NULL, 0);\r\nif (IS_ERR(dst))\r\nreturn;\r\nhh_len = (dst->dev->hard_header_len + 15)&~15;\r\nnskb = alloc_skb(hh_len + 15 + dst->header_len + sizeof(struct ipv6hdr)\r\n+ sizeof(struct tcphdr) + dst->trailer_len,\r\nGFP_ATOMIC);\r\nif (!nskb) {\r\nif (net_ratelimit())\r\npr_debug("cannot alloc skb\n");\r\ndst_release(dst);\r\nreturn;\r\n}\r\nskb_dst_set(nskb, dst);\r\nskb_reserve(nskb, hh_len + dst->header_len);\r\nskb_put(nskb, sizeof(struct ipv6hdr));\r\nskb_reset_network_header(nskb);\r\nip6h = ipv6_hdr(nskb);\r\n*(__be32 *)ip6h = htonl(0x60000000 | (tclass << 20));\r\nip6h->hop_limit = ip6_dst_hoplimit(dst);\r\nip6h->nexthdr = IPPROTO_TCP;\r\nip6h->saddr = oip6h->daddr;\r\nip6h->daddr = oip6h->saddr;\r\ntcph = (struct tcphdr *)skb_put(nskb, sizeof(struct tcphdr));\r\ntcph->doff = sizeof(struct tcphdr)/4;\r\ntcph->source = otcph.dest;\r\ntcph->dest = otcph.source;\r\nif (otcph.ack) {\r\nneeds_ack = 0;\r\ntcph->seq = otcph.ack_seq;\r\ntcph->ack_seq = 0;\r\n} else {\r\nneeds_ack = 1;\r\ntcph->ack_seq = htonl(ntohl(otcph.seq) + otcph.syn + otcph.fin\r\n+ otcplen - (otcph.doff<<2));\r\ntcph->seq = 0;\r\n}\r\n((u_int8_t *)tcph)[13] = 0;\r\ntcph->rst = 1;\r\ntcph->ack = needs_ack;\r\ntcph->window = 0;\r\ntcph->urg_ptr = 0;\r\ntcph->check = 0;\r\ntcph->check = csum_ipv6_magic(&ipv6_hdr(nskb)->saddr,\r\n&ipv6_hdr(nskb)->daddr,\r\nsizeof(struct tcphdr), IPPROTO_TCP,\r\ncsum_partial(tcph,\r\nsizeof(struct tcphdr), 0));\r\nnf_ct_attach(nskb, oldskb);\r\nip6_local_out(nskb);\r\n}\r\nstatic inline void\r\nsend_unreach(struct net *net, struct sk_buff *skb_in, unsigned char code,\r\nunsigned int hooknum)\r\n{\r\nif (hooknum == NF_INET_LOCAL_OUT && skb_in->dev == NULL)\r\nskb_in->dev = net->loopback_dev;\r\nicmpv6_send(skb_in, ICMPV6_DEST_UNREACH, code, 0);\r\n}\r\nstatic unsigned int\r\nreject_tg6(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct ip6t_reject_info *reject = par->targinfo;\r\nstruct net *net = dev_net((par->in != NULL) ? par->in : par->out);\r\npr_debug("%s: medium point\n", __func__);\r\nswitch (reject->with) {\r\ncase IP6T_ICMP6_NO_ROUTE:\r\nsend_unreach(net, skb, ICMPV6_NOROUTE, par->hooknum);\r\nbreak;\r\ncase IP6T_ICMP6_ADM_PROHIBITED:\r\nsend_unreach(net, skb, ICMPV6_ADM_PROHIBITED, par->hooknum);\r\nbreak;\r\ncase IP6T_ICMP6_NOT_NEIGHBOUR:\r\nsend_unreach(net, skb, ICMPV6_NOT_NEIGHBOUR, par->hooknum);\r\nbreak;\r\ncase IP6T_ICMP6_ADDR_UNREACH:\r\nsend_unreach(net, skb, ICMPV6_ADDR_UNREACH, par->hooknum);\r\nbreak;\r\ncase IP6T_ICMP6_PORT_UNREACH:\r\nsend_unreach(net, skb, ICMPV6_PORT_UNREACH, par->hooknum);\r\nbreak;\r\ncase IP6T_ICMP6_ECHOREPLY:\r\nbreak;\r\ncase IP6T_TCP_RESET:\r\nsend_reset(net, skb);\r\nbreak;\r\ndefault:\r\nif (net_ratelimit())\r\npr_info("case %u not handled yet\n", reject->with);\r\nbreak;\r\n}\r\nreturn NF_DROP;\r\n}\r\nstatic int reject_tg6_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct ip6t_reject_info *rejinfo = par->targinfo;\r\nconst struct ip6t_entry *e = par->entryinfo;\r\nif (rejinfo->with == IP6T_ICMP6_ECHOREPLY) {\r\npr_info("ECHOREPLY is not supported.\n");\r\nreturn -EINVAL;\r\n} else if (rejinfo->with == IP6T_TCP_RESET) {\r\nif (e->ipv6.proto != IPPROTO_TCP ||\r\n(e->ipv6.invflags & XT_INV_PROTO)) {\r\npr_info("TCP_RESET illegal for non-tcp\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init reject_tg6_init(void)\r\n{\r\nreturn xt_register_target(&reject_tg6_reg);\r\n}\r\nstatic void __exit reject_tg6_exit(void)\r\n{\r\nxt_unregister_target(&reject_tg6_reg);\r\n}
