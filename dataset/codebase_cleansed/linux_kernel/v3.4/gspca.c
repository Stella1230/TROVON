static void PDEBUG_MODE(char *txt, __u32 pixfmt, int w, int h)\r\n{\r\nif ((pixfmt >> 24) >= '0' && (pixfmt >> 24) <= 'z') {\r\nPDEBUG(D_CONF|D_STREAM, "%s %c%c%c%c %dx%d",\r\ntxt,\r\npixfmt & 0xff,\r\n(pixfmt >> 8) & 0xff,\r\n(pixfmt >> 16) & 0xff,\r\npixfmt >> 24,\r\nw, h);\r\n} else {\r\nPDEBUG(D_CONF|D_STREAM, "%s 0x%08x %dx%d",\r\ntxt,\r\npixfmt,\r\nw, h);\r\n}\r\n}\r\nstatic void gspca_vm_open(struct vm_area_struct *vma)\r\n{\r\nstruct gspca_frame *frame = vma->vm_private_data;\r\nframe->vma_use_count++;\r\nframe->v4l2_buf.flags |= V4L2_BUF_FLAG_MAPPED;\r\n}\r\nstatic void gspca_vm_close(struct vm_area_struct *vma)\r\n{\r\nstruct gspca_frame *frame = vma->vm_private_data;\r\nif (--frame->vma_use_count <= 0)\r\nframe->v4l2_buf.flags &= ~V4L2_BUF_FLAG_MAPPED;\r\n}\r\nstatic void int_irq(struct urb *urb)\r\n{\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *) urb->context;\r\nint ret;\r\nret = urb->status;\r\nswitch (ret) {\r\ncase 0:\r\nif (gspca_dev->sd_desc->int_pkt_scan(gspca_dev,\r\nurb->transfer_buffer, urb->actual_length) < 0) {\r\nPDEBUG(D_ERR, "Unknown packet received");\r\n}\r\nbreak;\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ncase -ENODEV:\r\ncase -ESHUTDOWN:\r\nbreak;\r\ndefault:\r\nPDEBUG(D_ERR, "URB error %i, resubmitting", urb->status);\r\nurb->status = 0;\r\nret = 0;\r\n}\r\nif (ret == 0) {\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (ret < 0)\r\npr_err("Resubmit URB failed with error %i\n", ret);\r\n}\r\n}\r\nstatic int gspca_input_connect(struct gspca_dev *dev)\r\n{\r\nstruct input_dev *input_dev;\r\nint err = 0;\r\ndev->input_dev = NULL;\r\nif (dev->sd_desc->int_pkt_scan || dev->sd_desc->other_input) {\r\ninput_dev = input_allocate_device();\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\nusb_make_path(dev->dev, dev->phys, sizeof(dev->phys));\r\nstrlcat(dev->phys, "/input0", sizeof(dev->phys));\r\ninput_dev->name = dev->sd_desc->name;\r\ninput_dev->phys = dev->phys;\r\nusb_to_input_id(dev->dev, &input_dev->id);\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY);\r\ninput_dev->keybit[BIT_WORD(KEY_CAMERA)] = BIT_MASK(KEY_CAMERA);\r\ninput_dev->dev.parent = &dev->dev->dev;\r\nerr = input_register_device(input_dev);\r\nif (err) {\r\npr_err("Input device registration failed with error %i\n",\r\nerr);\r\ninput_dev->dev.parent = NULL;\r\ninput_free_device(input_dev);\r\n} else {\r\ndev->input_dev = input_dev;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int alloc_and_submit_int_urb(struct gspca_dev *gspca_dev,\r\nstruct usb_endpoint_descriptor *ep)\r\n{\r\nunsigned int buffer_len;\r\nint interval;\r\nstruct urb *urb;\r\nstruct usb_device *dev;\r\nvoid *buffer = NULL;\r\nint ret = -EINVAL;\r\nbuffer_len = le16_to_cpu(ep->wMaxPacketSize);\r\ninterval = ep->bInterval;\r\nPDEBUG(D_CONF, "found int in endpoint: 0x%x, "\r\n"buffer_len=%u, interval=%u",\r\nep->bEndpointAddress, buffer_len, interval);\r\ndev = gspca_dev->dev;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nbuffer = usb_alloc_coherent(dev, buffer_len,\r\nGFP_KERNEL, &urb->transfer_dma);\r\nif (!buffer) {\r\nret = -ENOMEM;\r\ngoto error_buffer;\r\n}\r\nusb_fill_int_urb(urb, dev,\r\nusb_rcvintpipe(dev, ep->bEndpointAddress),\r\nbuffer, buffer_len,\r\nint_irq, (void *)gspca_dev, interval);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nret = usb_submit_urb(urb, GFP_KERNEL);\r\nif (ret < 0) {\r\nPDEBUG(D_ERR, "submit int URB failed with error %i", ret);\r\ngoto error_submit;\r\n}\r\ngspca_dev->int_urb = urb;\r\nreturn ret;\r\nerror_submit:\r\nusb_free_coherent(dev,\r\nurb->transfer_buffer_length,\r\nurb->transfer_buffer,\r\nurb->transfer_dma);\r\nerror_buffer:\r\nusb_free_urb(urb);\r\nerror:\r\nreturn ret;\r\n}\r\nstatic void gspca_input_create_urb(struct gspca_dev *gspca_dev)\r\n{\r\nstruct usb_interface *intf;\r\nstruct usb_host_interface *intf_desc;\r\nstruct usb_endpoint_descriptor *ep;\r\nint i;\r\nif (gspca_dev->sd_desc->int_pkt_scan) {\r\nintf = usb_ifnum_to_if(gspca_dev->dev, gspca_dev->iface);\r\nintf_desc = intf->cur_altsetting;\r\nfor (i = 0; i < intf_desc->desc.bNumEndpoints; i++) {\r\nep = &intf_desc->endpoint[i].desc;\r\nif (usb_endpoint_dir_in(ep) &&\r\nusb_endpoint_xfer_int(ep)) {\r\nalloc_and_submit_int_urb(gspca_dev, ep);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic void gspca_input_destroy_urb(struct gspca_dev *gspca_dev)\r\n{\r\nstruct urb *urb;\r\nurb = gspca_dev->int_urb;\r\nif (urb) {\r\ngspca_dev->int_urb = NULL;\r\nusb_kill_urb(urb);\r\nusb_free_coherent(gspca_dev->dev,\r\nurb->transfer_buffer_length,\r\nurb->transfer_buffer,\r\nurb->transfer_dma);\r\nusb_free_urb(urb);\r\n}\r\n}\r\nstatic inline void gspca_input_destroy_urb(struct gspca_dev *gspca_dev)\r\n{\r\n}\r\nstatic inline void gspca_input_create_urb(struct gspca_dev *gspca_dev)\r\n{\r\n}\r\nstatic inline int gspca_input_connect(struct gspca_dev *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void fill_frame(struct gspca_dev *gspca_dev,\r\nstruct urb *urb)\r\n{\r\nu8 *data;\r\nint i, len, st;\r\ncam_pkt_op pkt_scan;\r\nif (urb->status != 0) {\r\nif (urb->status == -ESHUTDOWN)\r\nreturn;\r\n#ifdef CONFIG_PM\r\nif (gspca_dev->frozen)\r\nreturn;\r\n#endif\r\nPDEBUG(D_ERR|D_PACK, "urb status: %d", urb->status);\r\nurb->status = 0;\r\ngoto resubmit;\r\n}\r\npkt_scan = gspca_dev->sd_desc->pkt_scan;\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nlen = urb->iso_frame_desc[i].actual_length;\r\nst = urb->iso_frame_desc[i].status;\r\nif (st) {\r\npr_err("ISOC data error: [%d] len=%d, status=%d\n",\r\ni, len, st);\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\ncontinue;\r\n}\r\nif (len == 0) {\r\nif (gspca_dev->empty_packet == 0)\r\ngspca_dev->empty_packet = 1;\r\ncontinue;\r\n}\r\nPDEBUG(D_PACK, "packet [%d] o:%d l:%d",\r\ni, urb->iso_frame_desc[i].offset, len);\r\ndata = (u8 *) urb->transfer_buffer\r\n+ urb->iso_frame_desc[i].offset;\r\npkt_scan(gspca_dev, data, len);\r\n}\r\nresubmit:\r\nst = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (st < 0)\r\npr_err("usb_submit_urb() ret %d\n", st);\r\n}\r\nstatic void isoc_irq(struct urb *urb)\r\n{\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *) urb->context;\r\nPDEBUG(D_PACK, "isoc irq");\r\nif (!gspca_dev->streaming)\r\nreturn;\r\nfill_frame(gspca_dev, urb);\r\n}\r\nstatic void bulk_irq(struct urb *urb)\r\n{\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *) urb->context;\r\nint st;\r\nPDEBUG(D_PACK, "bulk irq");\r\nif (!gspca_dev->streaming)\r\nreturn;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\n#ifdef CONFIG_PM\r\nif (gspca_dev->frozen)\r\nreturn;\r\n#endif\r\nPDEBUG(D_ERR|D_PACK, "urb status: %d", urb->status);\r\nurb->status = 0;\r\ngoto resubmit;\r\n}\r\nPDEBUG(D_PACK, "packet l:%d", urb->actual_length);\r\ngspca_dev->sd_desc->pkt_scan(gspca_dev,\r\nurb->transfer_buffer,\r\nurb->actual_length);\r\nresubmit:\r\nif (gspca_dev->cam.bulk_nurbs != 0) {\r\nst = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (st < 0)\r\npr_err("usb_submit_urb() ret %d\n", st);\r\n}\r\n}\r\nvoid gspca_frame_add(struct gspca_dev *gspca_dev,\r\nenum gspca_packet_type packet_type,\r\nconst u8 *data,\r\nint len)\r\n{\r\nstruct gspca_frame *frame;\r\nint i, j;\r\nPDEBUG(D_PACK, "add t:%d l:%d", packet_type, len);\r\nif (packet_type == FIRST_PACKET) {\r\ni = atomic_read(&gspca_dev->fr_i);\r\nif (i == atomic_read(&gspca_dev->fr_q)) {\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\ngspca_dev->sequence++;\r\nreturn;\r\n}\r\nj = gspca_dev->fr_queue[i];\r\nframe = &gspca_dev->frame[j];\r\nframe->v4l2_buf.timestamp = ktime_to_timeval(ktime_get());\r\nframe->v4l2_buf.sequence = gspca_dev->sequence++;\r\ngspca_dev->image = frame->data;\r\ngspca_dev->image_len = 0;\r\n} else {\r\nswitch (gspca_dev->last_packet_type) {\r\ncase DISCARD_PACKET:\r\nif (packet_type == LAST_PACKET) {\r\ngspca_dev->last_packet_type = packet_type;\r\ngspca_dev->image = NULL;\r\ngspca_dev->image_len = 0;\r\n}\r\nreturn;\r\ncase LAST_PACKET:\r\nreturn;\r\n}\r\n}\r\nif (len > 0) {\r\nif (gspca_dev->image_len + len > gspca_dev->frsz) {\r\nPDEBUG(D_ERR|D_PACK, "frame overflow %d > %d",\r\ngspca_dev->image_len + len,\r\ngspca_dev->frsz);\r\npacket_type = DISCARD_PACKET;\r\n} else {\r\nmemcpy(gspca_dev->image + gspca_dev->image_len,\r\ndata, len);\r\ngspca_dev->image_len += len;\r\n}\r\n}\r\ngspca_dev->last_packet_type = packet_type;\r\nif (packet_type == LAST_PACKET) {\r\ni = atomic_read(&gspca_dev->fr_i);\r\nj = gspca_dev->fr_queue[i];\r\nframe = &gspca_dev->frame[j];\r\nframe->v4l2_buf.bytesused = gspca_dev->image_len;\r\nframe->v4l2_buf.flags = (frame->v4l2_buf.flags\r\n| V4L2_BUF_FLAG_DONE)\r\n& ~V4L2_BUF_FLAG_QUEUED;\r\ni = (i + 1) % GSPCA_MAX_FRAMES;\r\natomic_set(&gspca_dev->fr_i, i);\r\nwake_up_interruptible(&gspca_dev->wq);\r\nPDEBUG(D_FRAM, "frame complete len:%d",\r\nframe->v4l2_buf.bytesused);\r\ngspca_dev->image = NULL;\r\ngspca_dev->image_len = 0;\r\n}\r\n}\r\nstatic int frame_alloc(struct gspca_dev *gspca_dev, struct file *file,\r\nenum v4l2_memory memory, unsigned int count)\r\n{\r\nstruct gspca_frame *frame;\r\nunsigned int frsz;\r\nint i;\r\ni = gspca_dev->curr_mode;\r\nfrsz = gspca_dev->cam.cam_mode[i].sizeimage;\r\nPDEBUG(D_STREAM, "frame alloc frsz: %d", frsz);\r\nfrsz = PAGE_ALIGN(frsz);\r\nif (count >= GSPCA_MAX_FRAMES)\r\ncount = GSPCA_MAX_FRAMES - 1;\r\ngspca_dev->frbuf = vmalloc_32(frsz * count);\r\nif (!gspca_dev->frbuf) {\r\npr_err("frame alloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\ngspca_dev->capt_file = file;\r\ngspca_dev->memory = memory;\r\ngspca_dev->frsz = frsz;\r\ngspca_dev->nframes = count;\r\nfor (i = 0; i < count; i++) {\r\nframe = &gspca_dev->frame[i];\r\nframe->v4l2_buf.index = i;\r\nframe->v4l2_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nframe->v4l2_buf.flags = 0;\r\nframe->v4l2_buf.field = V4L2_FIELD_NONE;\r\nframe->v4l2_buf.length = frsz;\r\nframe->v4l2_buf.memory = memory;\r\nframe->v4l2_buf.sequence = 0;\r\nframe->data = gspca_dev->frbuf + i * frsz;\r\nframe->v4l2_buf.m.offset = i * frsz;\r\n}\r\natomic_set(&gspca_dev->fr_q, 0);\r\natomic_set(&gspca_dev->fr_i, 0);\r\ngspca_dev->fr_o = 0;\r\nreturn 0;\r\n}\r\nstatic void frame_free(struct gspca_dev *gspca_dev)\r\n{\r\nint i;\r\nPDEBUG(D_STREAM, "frame free");\r\nif (gspca_dev->frbuf != NULL) {\r\nvfree(gspca_dev->frbuf);\r\ngspca_dev->frbuf = NULL;\r\nfor (i = 0; i < gspca_dev->nframes; i++)\r\ngspca_dev->frame[i].data = NULL;\r\n}\r\ngspca_dev->nframes = 0;\r\ngspca_dev->frsz = 0;\r\ngspca_dev->capt_file = NULL;\r\ngspca_dev->memory = GSPCA_MEMORY_NO;\r\n}\r\nstatic void destroy_urbs(struct gspca_dev *gspca_dev)\r\n{\r\nstruct urb *urb;\r\nunsigned int i;\r\nPDEBUG(D_STREAM, "kill transfer");\r\nfor (i = 0; i < MAX_NURBS; i++) {\r\nurb = gspca_dev->urb[i];\r\nif (urb == NULL)\r\nbreak;\r\ngspca_dev->urb[i] = NULL;\r\nusb_kill_urb(urb);\r\nif (urb->transfer_buffer != NULL)\r\nusb_free_coherent(gspca_dev->dev,\r\nurb->transfer_buffer_length,\r\nurb->transfer_buffer,\r\nurb->transfer_dma);\r\nusb_free_urb(urb);\r\n}\r\n}\r\nstatic int gspca_set_alt0(struct gspca_dev *gspca_dev)\r\n{\r\nint ret;\r\nif (gspca_dev->alt == 0)\r\nreturn 0;\r\nret = usb_set_interface(gspca_dev->dev, gspca_dev->iface, 0);\r\nif (ret < 0)\r\npr_err("set alt 0 err %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void gspca_stream_off(struct gspca_dev *gspca_dev)\r\n{\r\ngspca_dev->streaming = 0;\r\nif (gspca_dev->present) {\r\nif (gspca_dev->sd_desc->stopN)\r\ngspca_dev->sd_desc->stopN(gspca_dev);\r\ndestroy_urbs(gspca_dev);\r\ngspca_input_destroy_urb(gspca_dev);\r\ngspca_set_alt0(gspca_dev);\r\ngspca_input_create_urb(gspca_dev);\r\n}\r\nif (gspca_dev->sd_desc->stop0)\r\ngspca_dev->sd_desc->stop0(gspca_dev);\r\nPDEBUG(D_STREAM, "stream off OK");\r\n}\r\nstatic struct usb_host_endpoint *alt_xfer(struct usb_host_interface *alt,\r\nint xfer)\r\n{\r\nstruct usb_host_endpoint *ep;\r\nint i, attr;\r\nfor (i = 0; i < alt->desc.bNumEndpoints; i++) {\r\nep = &alt->endpoint[i];\r\nattr = ep->desc.bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;\r\nif (attr == xfer\r\n&& ep->desc.wMaxPacketSize != 0\r\n&& usb_endpoint_dir_in(&ep->desc))\r\nreturn ep;\r\n}\r\nreturn NULL;\r\n}\r\nstatic u32 which_bandwidth(struct gspca_dev *gspca_dev)\r\n{\r\nu32 bandwidth;\r\nint i;\r\ni = gspca_dev->curr_mode;\r\nbandwidth = gspca_dev->cam.cam_mode[i].sizeimage;\r\nif (!gspca_dev->cam.needs_full_bandwidth &&\r\nbandwidth < gspca_dev->cam.cam_mode[i].width *\r\ngspca_dev->cam.cam_mode[i].height)\r\nbandwidth = bandwidth * 3 / 8;\r\nif (gspca_dev->sd_desc->get_streamparm) {\r\nstruct v4l2_streamparm parm;\r\ngspca_dev->sd_desc->get_streamparm(gspca_dev, &parm);\r\nbandwidth *= parm.parm.capture.timeperframe.denominator;\r\nbandwidth /= parm.parm.capture.timeperframe.numerator;\r\n} else {\r\nif (gspca_dev->width >= 640\r\n&& gspca_dev->dev->speed == USB_SPEED_FULL)\r\nbandwidth *= 15;\r\nelse\r\nbandwidth *= 30;\r\n}\r\nPDEBUG(D_STREAM, "min bandwidth: %d", bandwidth);\r\nreturn bandwidth;\r\n}\r\nstatic int build_isoc_ep_tb(struct gspca_dev *gspca_dev,\r\nstruct usb_interface *intf,\r\nstruct ep_tb_s *ep_tb)\r\n{\r\nstruct usb_host_endpoint *ep;\r\nint i, j, nbalt, psize, found;\r\nu32 bandwidth, last_bw;\r\nnbalt = intf->num_altsetting;\r\nif (nbalt > MAX_ALT)\r\nnbalt = MAX_ALT;\r\ni = 0;\r\nlast_bw = 0;\r\nfor (;;) {\r\nep_tb->bandwidth = 2000 * 2000 * 120;\r\nfound = 0;\r\nfor (j = 0; j < nbalt; j++) {\r\nep = alt_xfer(&intf->altsetting[j],\r\nUSB_ENDPOINT_XFER_ISOC);\r\nif (ep == NULL)\r\ncontinue;\r\nif (ep->desc.bInterval == 0) {\r\npr_err("alt %d iso endp with 0 interval\n", j);\r\ncontinue;\r\n}\r\npsize = le16_to_cpu(ep->desc.wMaxPacketSize);\r\npsize = (psize & 0x07ff) * (1 + ((psize >> 11) & 3));\r\nbandwidth = psize * 1000;\r\nif (gspca_dev->dev->speed == USB_SPEED_HIGH\r\n|| gspca_dev->dev->speed == USB_SPEED_SUPER)\r\nbandwidth *= 8;\r\nbandwidth /= 1 << (ep->desc.bInterval - 1);\r\nif (bandwidth <= last_bw)\r\ncontinue;\r\nif (bandwidth < ep_tb->bandwidth) {\r\nep_tb->bandwidth = bandwidth;\r\nep_tb->alt = j;\r\nfound = 1;\r\n}\r\n}\r\nif (!found)\r\nbreak;\r\nPDEBUG(D_STREAM, "alt %d bandwidth %d",\r\nep_tb->alt, ep_tb->bandwidth);\r\nlast_bw = ep_tb->bandwidth;\r\ni++;\r\nep_tb++;\r\n}\r\nif (gspca_dev->audio &&\r\ngspca_dev->dev->speed == USB_SPEED_FULL &&\r\nlast_bw >= 1000000 &&\r\ni > 1) {\r\nPDEBUG(D_STREAM, "dev has usb audio, skipping highest alt");\r\ni--;\r\nep_tb--;\r\n}\r\nbandwidth = which_bandwidth(gspca_dev);\r\nep_tb--;\r\nwhile (i > 1) {\r\nep_tb--;\r\nif (ep_tb->bandwidth < bandwidth)\r\nbreak;\r\ni--;\r\n}\r\nreturn i;\r\n}\r\nstatic int create_urbs(struct gspca_dev *gspca_dev,\r\nstruct usb_host_endpoint *ep)\r\n{\r\nstruct urb *urb;\r\nint n, nurbs, i, psize, npkt, bsize;\r\npsize = le16_to_cpu(ep->desc.wMaxPacketSize);\r\nif (!gspca_dev->cam.bulk) {\r\nif (gspca_dev->pkt_size == 0)\r\npsize = (psize & 0x07ff) * (1 + ((psize >> 11) & 3));\r\nelse\r\npsize = gspca_dev->pkt_size;\r\nnpkt = gspca_dev->cam.npkt;\r\nif (npkt == 0)\r\nnpkt = 32;\r\nbsize = psize * npkt;\r\nPDEBUG(D_STREAM,\r\n"isoc %d pkts size %d = bsize:%d",\r\nnpkt, psize, bsize);\r\nnurbs = DEF_NURBS;\r\n} else {\r\nnpkt = 0;\r\nbsize = gspca_dev->cam.bulk_size;\r\nif (bsize == 0)\r\nbsize = psize;\r\nPDEBUG(D_STREAM, "bulk bsize:%d", bsize);\r\nif (gspca_dev->cam.bulk_nurbs != 0)\r\nnurbs = gspca_dev->cam.bulk_nurbs;\r\nelse\r\nnurbs = 1;\r\n}\r\nfor (n = 0; n < nurbs; n++) {\r\nurb = usb_alloc_urb(npkt, GFP_KERNEL);\r\nif (!urb) {\r\npr_err("usb_alloc_urb failed\n");\r\nreturn -ENOMEM;\r\n}\r\ngspca_dev->urb[n] = urb;\r\nurb->transfer_buffer = usb_alloc_coherent(gspca_dev->dev,\r\nbsize,\r\nGFP_KERNEL,\r\n&urb->transfer_dma);\r\nif (urb->transfer_buffer == NULL) {\r\npr_err("usb_alloc_coherent failed\n");\r\nreturn -ENOMEM;\r\n}\r\nurb->dev = gspca_dev->dev;\r\nurb->context = gspca_dev;\r\nurb->transfer_buffer_length = bsize;\r\nif (npkt != 0) {\r\nurb->pipe = usb_rcvisocpipe(gspca_dev->dev,\r\nep->desc.bEndpointAddress);\r\nurb->transfer_flags = URB_ISO_ASAP\r\n| URB_NO_TRANSFER_DMA_MAP;\r\nurb->interval = 1 << (ep->desc.bInterval - 1);\r\nurb->complete = isoc_irq;\r\nurb->number_of_packets = npkt;\r\nfor (i = 0; i < npkt; i++) {\r\nurb->iso_frame_desc[i].length = psize;\r\nurb->iso_frame_desc[i].offset = psize * i;\r\n}\r\n} else {\r\nurb->pipe = usb_rcvbulkpipe(gspca_dev->dev,\r\nep->desc.bEndpointAddress);\r\nurb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\r\nurb->complete = bulk_irq;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int gspca_init_transfer(struct gspca_dev *gspca_dev)\r\n{\r\nstruct usb_interface *intf;\r\nstruct usb_host_endpoint *ep;\r\nstruct urb *urb;\r\nstruct ep_tb_s ep_tb[MAX_ALT];\r\nint n, ret, xfer, alt, alt_idx;\r\nif (mutex_lock_interruptible(&gspca_dev->usb_lock))\r\nreturn -ERESTARTSYS;\r\nif (!gspca_dev->present) {\r\nret = -ENODEV;\r\ngoto unlock;\r\n}\r\ngspca_dev->image = NULL;\r\ngspca_dev->image_len = 0;\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\ngspca_dev->sequence = 0;\r\ngspca_dev->usb_err = 0;\r\nintf = usb_ifnum_to_if(gspca_dev->dev, gspca_dev->iface);\r\ngspca_dev->alt = gspca_dev->cam.bulk ? intf->num_altsetting : 0;\r\nif (gspca_dev->sd_desc->isoc_init) {\r\nret = gspca_dev->sd_desc->isoc_init(gspca_dev);\r\nif (ret < 0)\r\ngoto unlock;\r\n}\r\nxfer = gspca_dev->cam.bulk ? USB_ENDPOINT_XFER_BULK\r\n: USB_ENDPOINT_XFER_ISOC;\r\nif (gspca_dev->alt != 0) {\r\ngspca_dev->alt--;\r\nep = alt_xfer(&intf->altsetting[gspca_dev->alt], xfer);\r\nif (ep == NULL) {\r\npr_err("bad altsetting %d\n", gspca_dev->alt);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nep_tb[0].alt = gspca_dev->alt;\r\nalt_idx = 1;\r\n} else {\r\nalt_idx = build_isoc_ep_tb(gspca_dev, intf, ep_tb);\r\nif (alt_idx <= 0) {\r\npr_err("no transfer endpoint found\n");\r\nret = -EIO;\r\ngoto unlock;\r\n}\r\n}\r\ngspca_input_destroy_urb(gspca_dev);\r\ngspca_dev->alt = ep_tb[--alt_idx].alt;\r\nalt = -1;\r\nfor (;;) {\r\nif (alt != gspca_dev->alt) {\r\nalt = gspca_dev->alt;\r\nif (intf->num_altsetting > 1) {\r\nret = usb_set_interface(gspca_dev->dev,\r\ngspca_dev->iface,\r\nalt);\r\nif (ret < 0) {\r\nif (ret == -ENOSPC)\r\ngoto retry;\r\npr_err("set alt %d err %d\n", alt, ret);\r\ngoto out;\r\n}\r\n}\r\n}\r\nif (!gspca_dev->cam.no_urb_create) {\r\nPDEBUG(D_STREAM, "init transfer alt %d", alt);\r\nret = create_urbs(gspca_dev,\r\nalt_xfer(&intf->altsetting[alt], xfer));\r\nif (ret < 0) {\r\ndestroy_urbs(gspca_dev);\r\ngoto out;\r\n}\r\n}\r\nif (gspca_dev->cam.bulk)\r\nusb_clear_halt(gspca_dev->dev,\r\ngspca_dev->urb[0]->pipe);\r\nret = gspca_dev->sd_desc->start(gspca_dev);\r\nif (ret < 0) {\r\ndestroy_urbs(gspca_dev);\r\ngoto out;\r\n}\r\ngspca_dev->streaming = 1;\r\nif (gspca_dev->cam.bulk && gspca_dev->cam.bulk_nurbs == 0)\r\nbreak;\r\nfor (n = 0; n < MAX_NURBS; n++) {\r\nurb = gspca_dev->urb[n];\r\nif (urb == NULL)\r\nbreak;\r\nret = usb_submit_urb(urb, GFP_KERNEL);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nif (ret >= 0)\r\nbreak;\r\ngspca_stream_off(gspca_dev);\r\nif (ret != -ENOSPC) {\r\npr_err("usb_submit_urb alt %d err %d\n",\r\ngspca_dev->alt, ret);\r\ngoto out;\r\n}\r\nretry:\r\nPDEBUG(D_ERR|D_STREAM,\r\n"alt %d - bandwidth not wide enough - trying again",\r\nalt);\r\nmsleep(20);\r\nif (gspca_dev->sd_desc->isoc_nego) {\r\nret = gspca_dev->sd_desc->isoc_nego(gspca_dev);\r\nif (ret < 0)\r\ngoto out;\r\n} else {\r\nif (alt_idx <= 0) {\r\npr_err("no transfer endpoint found\n");\r\nret = -EIO;\r\ngoto out;\r\n}\r\ngspca_dev->alt = ep_tb[--alt_idx].alt;\r\n}\r\n}\r\nout:\r\ngspca_input_create_urb(gspca_dev);\r\nunlock:\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nreturn ret;\r\n}\r\nstatic void gspca_set_default_mode(struct gspca_dev *gspca_dev)\r\n{\r\nstruct gspca_ctrl *ctrl;\r\nint i;\r\ni = gspca_dev->cam.nmodes - 1;\r\ngspca_dev->curr_mode = i;\r\ngspca_dev->width = gspca_dev->cam.cam_mode[i].width;\r\ngspca_dev->height = gspca_dev->cam.cam_mode[i].height;\r\ngspca_dev->pixfmt = gspca_dev->cam.cam_mode[i].pixelformat;\r\nctrl = gspca_dev->cam.ctrls;\r\nif (ctrl != NULL) {\r\nfor (i = 0;\r\ni < gspca_dev->sd_desc->nctrls;\r\ni++, ctrl++)\r\nctrl->val = ctrl->def;\r\n}\r\n}\r\nstatic int wxh_to_mode(struct gspca_dev *gspca_dev,\r\nint width, int height)\r\n{\r\nint i;\r\nfor (i = gspca_dev->cam.nmodes; --i > 0; ) {\r\nif (width >= gspca_dev->cam.cam_mode[i].width\r\n&& height >= gspca_dev->cam.cam_mode[i].height)\r\nbreak;\r\n}\r\nreturn i;\r\n}\r\nstatic int gspca_get_mode(struct gspca_dev *gspca_dev,\r\nint mode,\r\nint pixfmt)\r\n{\r\nint modeU, modeD;\r\nmodeU = modeD = mode;\r\nwhile ((modeU < gspca_dev->cam.nmodes) || modeD >= 0) {\r\nif (--modeD >= 0) {\r\nif (gspca_dev->cam.cam_mode[modeD].pixelformat\r\n== pixfmt)\r\nreturn modeD;\r\n}\r\nif (++modeU < gspca_dev->cam.nmodes) {\r\nif (gspca_dev->cam.cam_mode[modeU].pixelformat\r\n== pixfmt)\r\nreturn modeU;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nint ret;\r\nstruct gspca_dev *gspca_dev = priv;\r\nif (!gspca_dev->sd_desc->get_chip_ident)\r\nreturn -EINVAL;\r\nif (!gspca_dev->sd_desc->get_register)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&gspca_dev->usb_lock))\r\nreturn -ERESTARTSYS;\r\ngspca_dev->usb_err = 0;\r\nif (gspca_dev->present)\r\nret = gspca_dev->sd_desc->get_register(gspca_dev, reg);\r\nelse\r\nret = -ENODEV;\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_s_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nint ret;\r\nstruct gspca_dev *gspca_dev = priv;\r\nif (!gspca_dev->sd_desc->get_chip_ident)\r\nreturn -EINVAL;\r\nif (!gspca_dev->sd_desc->set_register)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&gspca_dev->usb_lock))\r\nreturn -ERESTARTSYS;\r\ngspca_dev->usb_err = 0;\r\nif (gspca_dev->present)\r\nret = gspca_dev->sd_desc->set_register(gspca_dev, reg);\r\nelse\r\nret = -ENODEV;\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_g_chip_ident(struct file *file, void *priv,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nint ret;\r\nstruct gspca_dev *gspca_dev = priv;\r\nif (!gspca_dev->sd_desc->get_chip_ident)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&gspca_dev->usb_lock))\r\nreturn -ERESTARTSYS;\r\ngspca_dev->usb_err = 0;\r\nif (gspca_dev->present)\r\nret = gspca_dev->sd_desc->get_chip_ident(gspca_dev, chip);\r\nelse\r\nret = -ENODEV;\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *fmtdesc)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nint i, j, index;\r\n__u32 fmt_tb[8];\r\nindex = 0;\r\nj = 0;\r\nfor (i = gspca_dev->cam.nmodes; --i >= 0; ) {\r\nfmt_tb[index] = gspca_dev->cam.cam_mode[i].pixelformat;\r\nj = 0;\r\nfor (;;) {\r\nif (fmt_tb[j] == fmt_tb[index])\r\nbreak;\r\nj++;\r\n}\r\nif (j == index) {\r\nif (fmtdesc->index == index)\r\nbreak;\r\nindex++;\r\nif (index >= ARRAY_SIZE(fmt_tb))\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (i < 0)\r\nreturn -EINVAL;\r\nfmtdesc->pixelformat = fmt_tb[index];\r\nif (gspca_dev->cam.cam_mode[i].sizeimage <\r\ngspca_dev->cam.cam_mode[i].width *\r\ngspca_dev->cam.cam_mode[i].height)\r\nfmtdesc->flags = V4L2_FMT_FLAG_COMPRESSED;\r\nfmtdesc->description[0] = fmtdesc->pixelformat & 0xff;\r\nfmtdesc->description[1] = (fmtdesc->pixelformat >> 8) & 0xff;\r\nfmtdesc->description[2] = (fmtdesc->pixelformat >> 16) & 0xff;\r\nfmtdesc->description[3] = fmtdesc->pixelformat >> 24;\r\nfmtdesc->description[4] = '\0';\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nint mode;\r\nmode = gspca_dev->curr_mode;\r\nmemcpy(&fmt->fmt.pix, &gspca_dev->cam.cam_mode[mode],\r\nsizeof fmt->fmt.pix);\r\nreturn 0;\r\n}\r\nstatic int try_fmt_vid_cap(struct gspca_dev *gspca_dev,\r\nstruct v4l2_format *fmt)\r\n{\r\nint w, h, mode, mode2;\r\nw = fmt->fmt.pix.width;\r\nh = fmt->fmt.pix.height;\r\n#ifdef GSPCA_DEBUG\r\nif (gspca_debug & D_CONF)\r\nPDEBUG_MODE("try fmt cap", fmt->fmt.pix.pixelformat, w, h);\r\n#endif\r\nmode = wxh_to_mode(gspca_dev, w, h);\r\nif (gspca_dev->cam.cam_mode[mode].pixelformat\r\n!= fmt->fmt.pix.pixelformat) {\r\nmode2 = gspca_get_mode(gspca_dev, mode,\r\nfmt->fmt.pix.pixelformat);\r\nif (mode2 >= 0)\r\nmode = mode2;\r\n}\r\nmemcpy(&fmt->fmt.pix, &gspca_dev->cam.cam_mode[mode],\r\nsizeof fmt->fmt.pix);\r\nreturn mode;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file,\r\nvoid *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nint ret;\r\nret = try_fmt_vid_cap(gspca_dev, fmt);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nint ret;\r\nif (mutex_lock_interruptible(&gspca_dev->queue_lock))\r\nreturn -ERESTARTSYS;\r\nret = try_fmt_vid_cap(gspca_dev, fmt);\r\nif (ret < 0)\r\ngoto out;\r\nif (gspca_dev->nframes != 0\r\n&& fmt->fmt.pix.sizeimage > gspca_dev->frsz) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (ret == gspca_dev->curr_mode) {\r\nret = 0;\r\ngoto out;\r\n}\r\nif (gspca_dev->streaming) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\ngspca_dev->width = fmt->fmt.pix.width;\r\ngspca_dev->height = fmt->fmt.pix.height;\r\ngspca_dev->pixfmt = fmt->fmt.pix.pixelformat;\r\ngspca_dev->curr_mode = ret;\r\nret = 0;\r\nout:\r\nmutex_unlock(&gspca_dev->queue_lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_enum_framesizes(struct file *file, void *priv,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nint i;\r\n__u32 index = 0;\r\nfor (i = 0; i < gspca_dev->cam.nmodes; i++) {\r\nif (fsize->pixel_format !=\r\ngspca_dev->cam.cam_mode[i].pixelformat)\r\ncontinue;\r\nif (fsize->index == index) {\r\nfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\r\nfsize->discrete.width =\r\ngspca_dev->cam.cam_mode[i].width;\r\nfsize->discrete.height =\r\ngspca_dev->cam.cam_mode[i].height;\r\nreturn 0;\r\n}\r\nindex++;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_enum_frameintervals(struct file *filp, void *priv,\r\nstruct v4l2_frmivalenum *fival)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nint mode = wxh_to_mode(gspca_dev, fival->width, fival->height);\r\n__u32 i;\r\nif (gspca_dev->cam.mode_framerates == NULL ||\r\ngspca_dev->cam.mode_framerates[mode].nrates == 0)\r\nreturn -EINVAL;\r\nif (fival->pixel_format !=\r\ngspca_dev->cam.cam_mode[mode].pixelformat)\r\nreturn -EINVAL;\r\nfor (i = 0; i < gspca_dev->cam.mode_framerates[mode].nrates; i++) {\r\nif (fival->index == i) {\r\nfival->type = V4L2_FRMSIZE_TYPE_DISCRETE;\r\nfival->discrete.numerator = 1;\r\nfival->discrete.denominator =\r\ngspca_dev->cam.mode_framerates[mode].rates[i];\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void gspca_release(struct video_device *vfd)\r\n{\r\nstruct gspca_dev *gspca_dev = container_of(vfd, struct gspca_dev, vdev);\r\nPDEBUG(D_PROBE, "%s released",\r\nvideo_device_node_name(&gspca_dev->vdev));\r\nkfree(gspca_dev->usb_buf);\r\nkfree(gspca_dev);\r\n}\r\nstatic int dev_open(struct file *file)\r\n{\r\nstruct gspca_dev *gspca_dev;\r\nPDEBUG(D_STREAM, "[%s] open", current->comm);\r\ngspca_dev = (struct gspca_dev *) video_devdata(file);\r\nif (!gspca_dev->present)\r\nreturn -ENODEV;\r\nif (!try_module_get(gspca_dev->module))\r\nreturn -ENODEV;\r\nfile->private_data = gspca_dev;\r\n#ifdef GSPCA_DEBUG\r\nif (gspca_debug & D_V4L2)\r\ngspca_dev->vdev.debug |= V4L2_DEBUG_IOCTL\r\n| V4L2_DEBUG_IOCTL_ARG;\r\nelse\r\ngspca_dev->vdev.debug &= ~(V4L2_DEBUG_IOCTL\r\n| V4L2_DEBUG_IOCTL_ARG);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int dev_close(struct file *file)\r\n{\r\nstruct gspca_dev *gspca_dev = file->private_data;\r\nPDEBUG(D_STREAM, "[%s] close", current->comm);\r\nif (mutex_lock_interruptible(&gspca_dev->queue_lock))\r\nreturn -ERESTARTSYS;\r\nif (gspca_dev->capt_file == file) {\r\nif (gspca_dev->streaming) {\r\nmutex_lock(&gspca_dev->usb_lock);\r\ngspca_dev->usb_err = 0;\r\ngspca_stream_off(gspca_dev);\r\nmutex_unlock(&gspca_dev->usb_lock);\r\n}\r\nframe_free(gspca_dev);\r\n}\r\nfile->private_data = NULL;\r\nmodule_put(gspca_dev->module);\r\nmutex_unlock(&gspca_dev->queue_lock);\r\nPDEBUG(D_STREAM, "close done");\r\nreturn 0;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nint ret;\r\nif (mutex_lock_interruptible(&gspca_dev->usb_lock))\r\nreturn -ERESTARTSYS;\r\nif (!gspca_dev->present) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nstrlcpy((char *) cap->driver, gspca_dev->sd_desc->name,\r\nsizeof cap->driver);\r\nif (gspca_dev->dev->product != NULL) {\r\nstrlcpy((char *) cap->card, gspca_dev->dev->product,\r\nsizeof cap->card);\r\n} else {\r\nsnprintf((char *) cap->card, sizeof cap->card,\r\n"USB Camera (%04x:%04x)",\r\nle16_to_cpu(gspca_dev->dev->descriptor.idVendor),\r\nle16_to_cpu(gspca_dev->dev->descriptor.idProduct));\r\n}\r\nusb_make_path(gspca_dev->dev, (char *) cap->bus_info,\r\nsizeof(cap->bus_info));\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE\r\n| V4L2_CAP_STREAMING\r\n| V4L2_CAP_READWRITE;\r\nret = 0;\r\nout:\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nreturn ret;\r\n}\r\nstatic int get_ctrl(struct gspca_dev *gspca_dev,\r\nint id)\r\n{\r\nconst struct ctrl *ctrls;\r\nint i;\r\nfor (i = 0, ctrls = gspca_dev->sd_desc->ctrls;\r\ni < gspca_dev->sd_desc->nctrls;\r\ni++, ctrls++) {\r\nif (gspca_dev->ctrl_dis & (1 << i))\r\ncontinue;\r\nif (id == ctrls->qctrl.id)\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *q_ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nconst struct ctrl *ctrls;\r\nstruct gspca_ctrl *gspca_ctrl;\r\nint i, idx;\r\nu32 id;\r\nid = q_ctrl->id;\r\nif (id & V4L2_CTRL_FLAG_NEXT_CTRL) {\r\nid &= V4L2_CTRL_ID_MASK;\r\nid++;\r\nidx = -1;\r\nfor (i = 0; i < gspca_dev->sd_desc->nctrls; i++) {\r\nif (gspca_dev->ctrl_dis & (1 << i))\r\ncontinue;\r\nif (gspca_dev->sd_desc->ctrls[i].qctrl.id < id)\r\ncontinue;\r\nif (idx >= 0\r\n&& gspca_dev->sd_desc->ctrls[i].qctrl.id\r\n> gspca_dev->sd_desc->ctrls[idx].qctrl.id)\r\ncontinue;\r\nidx = i;\r\n}\r\n} else {\r\nidx = get_ctrl(gspca_dev, id);\r\n}\r\nif (idx < 0)\r\nreturn -EINVAL;\r\nctrls = &gspca_dev->sd_desc->ctrls[idx];\r\nmemcpy(q_ctrl, &ctrls->qctrl, sizeof *q_ctrl);\r\nif (gspca_dev->cam.ctrls != NULL) {\r\ngspca_ctrl = &gspca_dev->cam.ctrls[idx];\r\nq_ctrl->default_value = gspca_ctrl->def;\r\nq_ctrl->minimum = gspca_ctrl->min;\r\nq_ctrl->maximum = gspca_ctrl->max;\r\n}\r\nif (gspca_dev->ctrl_inac & (1 << idx))\r\nq_ctrl->flags |= V4L2_CTRL_FLAG_INACTIVE;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nconst struct ctrl *ctrls;\r\nstruct gspca_ctrl *gspca_ctrl;\r\nint idx, ret;\r\nidx = get_ctrl(gspca_dev, ctrl->id);\r\nif (idx < 0)\r\nreturn -EINVAL;\r\nif (gspca_dev->ctrl_inac & (1 << idx))\r\nreturn -EINVAL;\r\nctrls = &gspca_dev->sd_desc->ctrls[idx];\r\nif (gspca_dev->cam.ctrls != NULL) {\r\ngspca_ctrl = &gspca_dev->cam.ctrls[idx];\r\nif (ctrl->value < gspca_ctrl->min\r\n|| ctrl->value > gspca_ctrl->max)\r\nreturn -ERANGE;\r\n} else {\r\ngspca_ctrl = NULL;\r\nif (ctrl->value < ctrls->qctrl.minimum\r\n|| ctrl->value > ctrls->qctrl.maximum)\r\nreturn -ERANGE;\r\n}\r\nPDEBUG(D_CONF, "set ctrl [%08x] = %d", ctrl->id, ctrl->value);\r\nif (mutex_lock_interruptible(&gspca_dev->usb_lock))\r\nreturn -ERESTARTSYS;\r\nif (!gspca_dev->present) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\ngspca_dev->usb_err = 0;\r\nif (ctrls->set != NULL) {\r\nret = ctrls->set(gspca_dev, ctrl->value);\r\ngoto out;\r\n}\r\nif (gspca_ctrl != NULL) {\r\ngspca_ctrl->val = ctrl->value;\r\nif (ctrls->set_control != NULL\r\n&& gspca_dev->streaming)\r\nctrls->set_control(gspca_dev);\r\n}\r\nret = gspca_dev->usb_err;\r\nout:\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nconst struct ctrl *ctrls;\r\nint idx, ret;\r\nidx = get_ctrl(gspca_dev, ctrl->id);\r\nif (idx < 0)\r\nreturn -EINVAL;\r\nctrls = &gspca_dev->sd_desc->ctrls[idx];\r\nif (mutex_lock_interruptible(&gspca_dev->usb_lock))\r\nreturn -ERESTARTSYS;\r\nif (!gspca_dev->present) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\ngspca_dev->usb_err = 0;\r\nif (ctrls->get != NULL) {\r\nret = ctrls->get(gspca_dev, &ctrl->value);\r\ngoto out;\r\n}\r\nif (gspca_dev->cam.ctrls != NULL)\r\nctrl->value = gspca_dev->cam.ctrls[idx].val;\r\nret = 0;\r\nout:\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_querymenu(struct file *file, void *priv,\r\nstruct v4l2_querymenu *qmenu)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nif (!gspca_dev->sd_desc->querymenu)\r\nreturn -EINVAL;\r\nreturn gspca_dev->sd_desc->querymenu(gspca_dev, qmenu);\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *input)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nif (input->index != 0)\r\nreturn -EINVAL;\r\ninput->type = V4L2_INPUT_TYPE_CAMERA;\r\ninput->status = gspca_dev->cam.input_flags;\r\nstrlcpy(input->name, gspca_dev->sd_desc->name,\r\nsizeof input->name);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nif (i > 0)\r\nreturn -EINVAL;\r\nreturn (0);\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *rb)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nint i, ret = 0, streaming;\r\ni = rb->memory;\r\nswitch (i) {\r\ncase GSPCA_MEMORY_READ:\r\ncase V4L2_MEMORY_MMAP:\r\ncase V4L2_MEMORY_USERPTR:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (mutex_lock_interruptible(&gspca_dev->queue_lock))\r\nreturn -ERESTARTSYS;\r\nif (gspca_dev->memory != GSPCA_MEMORY_NO\r\n&& gspca_dev->memory != GSPCA_MEMORY_READ\r\n&& gspca_dev->memory != rb->memory) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (gspca_dev->capt_file != NULL\r\n&& gspca_dev->capt_file != file) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nfor (i = 0; i < gspca_dev->nframes; i++) {\r\nif (gspca_dev->frame[i].vma_use_count) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\n}\r\nstreaming = gspca_dev->streaming;\r\nif (streaming) {\r\nmutex_lock(&gspca_dev->usb_lock);\r\ngspca_dev->usb_err = 0;\r\ngspca_stream_off(gspca_dev);\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nif (gspca_dev->memory == GSPCA_MEMORY_READ)\r\nstreaming = 0;\r\n}\r\nif (gspca_dev->nframes != 0)\r\nframe_free(gspca_dev);\r\nif (rb->count == 0)\r\ngoto out;\r\nret = frame_alloc(gspca_dev, file, rb->memory, rb->count);\r\nif (ret == 0) {\r\nrb->count = gspca_dev->nframes;\r\nif (streaming)\r\nret = gspca_init_transfer(gspca_dev);\r\n}\r\nout:\r\nmutex_unlock(&gspca_dev->queue_lock);\r\nPDEBUG(D_STREAM, "reqbufs st:%d c:%d", ret, rb->count);\r\nreturn ret;\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *v4l2_buf)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nstruct gspca_frame *frame;\r\nif (v4l2_buf->index < 0\r\n|| v4l2_buf->index >= gspca_dev->nframes)\r\nreturn -EINVAL;\r\nframe = &gspca_dev->frame[v4l2_buf->index];\r\nmemcpy(v4l2_buf, &frame->v4l2_buf, sizeof *v4l2_buf);\r\nreturn 0;\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type buf_type)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nint ret;\r\nif (buf_type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&gspca_dev->queue_lock))\r\nreturn -ERESTARTSYS;\r\nif (gspca_dev->capt_file != file) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (gspca_dev->nframes == 0\r\n|| !(gspca_dev->frame[0].v4l2_buf.flags & V4L2_BUF_FLAG_QUEUED)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (!gspca_dev->streaming) {\r\nret = gspca_init_transfer(gspca_dev);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\n#ifdef GSPCA_DEBUG\r\nif (gspca_debug & D_STREAM) {\r\nPDEBUG_MODE("stream on OK",\r\ngspca_dev->pixfmt,\r\ngspca_dev->width,\r\ngspca_dev->height);\r\n}\r\n#endif\r\nret = 0;\r\nout:\r\nmutex_unlock(&gspca_dev->queue_lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type buf_type)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nint ret;\r\nif (buf_type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&gspca_dev->queue_lock))\r\nreturn -ERESTARTSYS;\r\nif (!gspca_dev->streaming) {\r\nret = 0;\r\ngoto out;\r\n}\r\nif (gspca_dev->capt_file != file) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (mutex_lock_interruptible(&gspca_dev->usb_lock)) {\r\nret = -ERESTARTSYS;\r\ngoto out;\r\n}\r\ngspca_dev->usb_err = 0;\r\ngspca_stream_off(gspca_dev);\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nwake_up_interruptible(&gspca_dev->wq);\r\natomic_set(&gspca_dev->fr_q, 0);\r\natomic_set(&gspca_dev->fr_i, 0);\r\ngspca_dev->fr_o = 0;\r\nret = 0;\r\nout:\r\nmutex_unlock(&gspca_dev->queue_lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_g_jpegcomp(struct file *file, void *priv,\r\nstruct v4l2_jpegcompression *jpegcomp)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nint ret;\r\nif (!gspca_dev->sd_desc->get_jcomp)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&gspca_dev->usb_lock))\r\nreturn -ERESTARTSYS;\r\ngspca_dev->usb_err = 0;\r\nif (gspca_dev->present)\r\nret = gspca_dev->sd_desc->get_jcomp(gspca_dev, jpegcomp);\r\nelse\r\nret = -ENODEV;\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_s_jpegcomp(struct file *file, void *priv,\r\nstruct v4l2_jpegcompression *jpegcomp)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nint ret;\r\nif (!gspca_dev->sd_desc->set_jcomp)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&gspca_dev->usb_lock))\r\nreturn -ERESTARTSYS;\r\ngspca_dev->usb_err = 0;\r\nif (gspca_dev->present)\r\nret = gspca_dev->sd_desc->set_jcomp(gspca_dev, jpegcomp);\r\nelse\r\nret = -ENODEV;\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_g_parm(struct file *filp, void *priv,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nparm->parm.capture.readbuffers = gspca_dev->nbufread;\r\nif (gspca_dev->sd_desc->get_streamparm) {\r\nint ret;\r\nif (mutex_lock_interruptible(&gspca_dev->usb_lock))\r\nreturn -ERESTARTSYS;\r\nif (gspca_dev->present) {\r\ngspca_dev->usb_err = 0;\r\ngspca_dev->sd_desc->get_streamparm(gspca_dev, parm);\r\nret = gspca_dev->usb_err;\r\n} else {\r\nret = -ENODEV;\r\n}\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_parm(struct file *filp, void *priv,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nint n;\r\nn = parm->parm.capture.readbuffers;\r\nif (n == 0 || n >= GSPCA_MAX_FRAMES)\r\nparm->parm.capture.readbuffers = gspca_dev->nbufread;\r\nelse\r\ngspca_dev->nbufread = n;\r\nif (gspca_dev->sd_desc->set_streamparm) {\r\nint ret;\r\nif (mutex_lock_interruptible(&gspca_dev->usb_lock))\r\nreturn -ERESTARTSYS;\r\nif (gspca_dev->present) {\r\ngspca_dev->usb_err = 0;\r\ngspca_dev->sd_desc->set_streamparm(gspca_dev, parm);\r\nret = gspca_dev->usb_err;\r\n} else {\r\nret = -ENODEV;\r\n}\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dev_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct gspca_dev *gspca_dev = file->private_data;\r\nstruct gspca_frame *frame;\r\nstruct page *page;\r\nunsigned long addr, start, size;\r\nint i, ret;\r\nstart = vma->vm_start;\r\nsize = vma->vm_end - vma->vm_start;\r\nPDEBUG(D_STREAM, "mmap start:%08x size:%d", (int) start, (int) size);\r\nif (mutex_lock_interruptible(&gspca_dev->queue_lock))\r\nreturn -ERESTARTSYS;\r\nif (!gspca_dev->present) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (gspca_dev->capt_file != file) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nframe = NULL;\r\nfor (i = 0; i < gspca_dev->nframes; ++i) {\r\nif (gspca_dev->frame[i].v4l2_buf.memory != V4L2_MEMORY_MMAP) {\r\nPDEBUG(D_STREAM, "mmap bad memory type");\r\nbreak;\r\n}\r\nif ((gspca_dev->frame[i].v4l2_buf.m.offset >> PAGE_SHIFT)\r\n== vma->vm_pgoff) {\r\nframe = &gspca_dev->frame[i];\r\nbreak;\r\n}\r\n}\r\nif (frame == NULL) {\r\nPDEBUG(D_STREAM, "mmap no frame buffer found");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (size != frame->v4l2_buf.length) {\r\nPDEBUG(D_STREAM, "mmap bad size");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nvma->vm_flags |= VM_IO;\r\naddr = (unsigned long) frame->data;\r\nwhile (size > 0) {\r\npage = vmalloc_to_page((void *) addr);\r\nret = vm_insert_page(vma, start, page);\r\nif (ret < 0)\r\ngoto out;\r\nstart += PAGE_SIZE;\r\naddr += PAGE_SIZE;\r\nsize -= PAGE_SIZE;\r\n}\r\nvma->vm_ops = &gspca_vm_ops;\r\nvma->vm_private_data = frame;\r\ngspca_vm_open(vma);\r\nret = 0;\r\nout:\r\nmutex_unlock(&gspca_dev->queue_lock);\r\nreturn ret;\r\n}\r\nstatic int frame_ready_nolock(struct gspca_dev *gspca_dev, struct file *file,\r\nenum v4l2_memory memory)\r\n{\r\nif (!gspca_dev->present)\r\nreturn -ENODEV;\r\nif (gspca_dev->capt_file != file || gspca_dev->memory != memory ||\r\n!gspca_dev->streaming)\r\nreturn -EINVAL;\r\nreturn gspca_dev->fr_o != atomic_read(&gspca_dev->fr_i);\r\n}\r\nstatic int frame_ready(struct gspca_dev *gspca_dev, struct file *file,\r\nenum v4l2_memory memory)\r\n{\r\nint ret;\r\nif (mutex_lock_interruptible(&gspca_dev->queue_lock))\r\nreturn -ERESTARTSYS;\r\nret = frame_ready_nolock(gspca_dev, file, memory);\r\nmutex_unlock(&gspca_dev->queue_lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *v4l2_buf)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nstruct gspca_frame *frame;\r\nint i, j, ret;\r\nPDEBUG(D_FRAM, "dqbuf");\r\nif (mutex_lock_interruptible(&gspca_dev->queue_lock))\r\nreturn -ERESTARTSYS;\r\nfor (;;) {\r\nret = frame_ready_nolock(gspca_dev, file, v4l2_buf->memory);\r\nif (ret < 0)\r\ngoto out;\r\nif (ret > 0)\r\nbreak;\r\nmutex_unlock(&gspca_dev->queue_lock);\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nret = wait_event_interruptible_timeout(gspca_dev->wq,\r\nframe_ready(gspca_dev, file, v4l2_buf->memory),\r\nmsecs_to_jiffies(3000));\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret == 0)\r\nreturn -EIO;\r\nif (mutex_lock_interruptible(&gspca_dev->queue_lock))\r\nreturn -ERESTARTSYS;\r\n}\r\ni = gspca_dev->fr_o;\r\nj = gspca_dev->fr_queue[i];\r\nframe = &gspca_dev->frame[j];\r\ngspca_dev->fr_o = (i + 1) % GSPCA_MAX_FRAMES;\r\nif (gspca_dev->sd_desc->dq_callback) {\r\nmutex_lock(&gspca_dev->usb_lock);\r\ngspca_dev->usb_err = 0;\r\nif (gspca_dev->present)\r\ngspca_dev->sd_desc->dq_callback(gspca_dev);\r\nmutex_unlock(&gspca_dev->usb_lock);\r\n}\r\nframe->v4l2_buf.flags &= ~V4L2_BUF_FLAG_DONE;\r\nmemcpy(v4l2_buf, &frame->v4l2_buf, sizeof *v4l2_buf);\r\nPDEBUG(D_FRAM, "dqbuf %d", j);\r\nret = 0;\r\nif (gspca_dev->memory == V4L2_MEMORY_USERPTR) {\r\nif (copy_to_user((__u8 __user *) frame->v4l2_buf.m.userptr,\r\nframe->data,\r\nframe->v4l2_buf.bytesused)) {\r\nPDEBUG(D_ERR|D_STREAM,\r\n"dqbuf cp to user failed");\r\nret = -EFAULT;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&gspca_dev->queue_lock);\r\nreturn ret;\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *v4l2_buf)\r\n{\r\nstruct gspca_dev *gspca_dev = priv;\r\nstruct gspca_frame *frame;\r\nint i, index, ret;\r\nPDEBUG(D_FRAM, "qbuf %d", v4l2_buf->index);\r\nif (mutex_lock_interruptible(&gspca_dev->queue_lock))\r\nreturn -ERESTARTSYS;\r\nindex = v4l2_buf->index;\r\nif ((unsigned) index >= gspca_dev->nframes) {\r\nPDEBUG(D_FRAM,\r\n"qbuf idx %d >= %d", index, gspca_dev->nframes);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (v4l2_buf->memory != gspca_dev->memory) {\r\nPDEBUG(D_FRAM, "qbuf bad memory type");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nframe = &gspca_dev->frame[index];\r\nif (frame->v4l2_buf.flags & BUF_ALL_FLAGS) {\r\nPDEBUG(D_FRAM, "qbuf bad state");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nframe->v4l2_buf.flags |= V4L2_BUF_FLAG_QUEUED;\r\nif (frame->v4l2_buf.memory == V4L2_MEMORY_USERPTR) {\r\nframe->v4l2_buf.m.userptr = v4l2_buf->m.userptr;\r\nframe->v4l2_buf.length = v4l2_buf->length;\r\n}\r\ni = atomic_read(&gspca_dev->fr_q);\r\ngspca_dev->fr_queue[i] = index;\r\natomic_set(&gspca_dev->fr_q, (i + 1) % GSPCA_MAX_FRAMES);\r\nv4l2_buf->flags |= V4L2_BUF_FLAG_QUEUED;\r\nv4l2_buf->flags &= ~V4L2_BUF_FLAG_DONE;\r\nret = 0;\r\nout:\r\nmutex_unlock(&gspca_dev->queue_lock);\r\nreturn ret;\r\n}\r\nstatic int read_alloc(struct gspca_dev *gspca_dev,\r\nstruct file *file)\r\n{\r\nstruct v4l2_buffer v4l2_buf;\r\nint i, ret;\r\nPDEBUG(D_STREAM, "read alloc");\r\nif (gspca_dev->nframes == 0) {\r\nstruct v4l2_requestbuffers rb;\r\nmemset(&rb, 0, sizeof rb);\r\nrb.count = gspca_dev->nbufread;\r\nrb.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nrb.memory = GSPCA_MEMORY_READ;\r\nret = vidioc_reqbufs(file, gspca_dev, &rb);\r\nif (ret != 0) {\r\nPDEBUG(D_STREAM, "read reqbuf err %d", ret);\r\nreturn ret;\r\n}\r\nmemset(&v4l2_buf, 0, sizeof v4l2_buf);\r\nv4l2_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nv4l2_buf.memory = GSPCA_MEMORY_READ;\r\nfor (i = 0; i < gspca_dev->nbufread; i++) {\r\nv4l2_buf.index = i;\r\nret = vidioc_qbuf(file, gspca_dev, &v4l2_buf);\r\nif (ret != 0) {\r\nPDEBUG(D_STREAM, "read qbuf err: %d", ret);\r\nreturn ret;\r\n}\r\n}\r\ngspca_dev->memory = GSPCA_MEMORY_READ;\r\n}\r\nret = vidioc_streamon(file, gspca_dev, V4L2_BUF_TYPE_VIDEO_CAPTURE);\r\nif (ret != 0)\r\nPDEBUG(D_STREAM, "read streamon err %d", ret);\r\nreturn ret;\r\n}\r\nstatic unsigned int dev_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct gspca_dev *gspca_dev = file->private_data;\r\nint ret;\r\nPDEBUG(D_FRAM, "poll");\r\npoll_wait(file, &gspca_dev->wq, wait);\r\nif (gspca_dev->memory == GSPCA_MEMORY_NO) {\r\nret = read_alloc(gspca_dev, file);\r\nif (ret != 0)\r\nreturn POLLERR;\r\n}\r\nif (mutex_lock_interruptible(&gspca_dev->queue_lock) != 0)\r\nreturn POLLERR;\r\nif (gspca_dev->fr_o != atomic_read(&gspca_dev->fr_i))\r\nret = POLLIN | POLLRDNORM;\r\nelse\r\nret = 0;\r\nmutex_unlock(&gspca_dev->queue_lock);\r\nif (!gspca_dev->present)\r\nreturn POLLHUP;\r\nreturn ret;\r\n}\r\nstatic ssize_t dev_read(struct file *file, char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct gspca_dev *gspca_dev = file->private_data;\r\nstruct gspca_frame *frame;\r\nstruct v4l2_buffer v4l2_buf;\r\nstruct timeval timestamp;\r\nint n, ret, ret2;\r\nPDEBUG(D_FRAM, "read (%zd)", count);\r\nif (!gspca_dev->present)\r\nreturn -ENODEV;\r\nif (gspca_dev->memory == GSPCA_MEMORY_NO) {\r\nret = read_alloc(gspca_dev, file);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\ntimestamp = ktime_to_timeval(ktime_get());\r\ntimestamp.tv_sec--;\r\nn = 2;\r\nfor (;;) {\r\nmemset(&v4l2_buf, 0, sizeof v4l2_buf);\r\nv4l2_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nv4l2_buf.memory = GSPCA_MEMORY_READ;\r\nret = vidioc_dqbuf(file, gspca_dev, &v4l2_buf);\r\nif (ret != 0) {\r\nPDEBUG(D_STREAM, "read dqbuf err %d", ret);\r\nreturn ret;\r\n}\r\nframe = &gspca_dev->frame[v4l2_buf.index];\r\nif (--n < 0)\r\nbreak;\r\nif (frame->v4l2_buf.timestamp.tv_sec >= timestamp.tv_sec)\r\nbreak;\r\nret = vidioc_qbuf(file, gspca_dev, &v4l2_buf);\r\nif (ret != 0) {\r\nPDEBUG(D_STREAM, "read qbuf err %d", ret);\r\nreturn ret;\r\n}\r\n}\r\nif (count > frame->v4l2_buf.bytesused)\r\ncount = frame->v4l2_buf.bytesused;\r\nret = copy_to_user(data, frame->data, count);\r\nif (ret != 0) {\r\nPDEBUG(D_ERR|D_STREAM,\r\n"read cp to user lack %d / %zd", ret, count);\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nret = count;\r\nout:\r\nret2 = vidioc_qbuf(file, gspca_dev, &v4l2_buf);\r\nif (ret2 != 0)\r\nreturn ret2;\r\nreturn ret;\r\n}\r\nstatic void ctrls_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct gspca_ctrl *ctrl;\r\nint i;\r\nfor (i = 0, ctrl = gspca_dev->cam.ctrls;\r\ni < gspca_dev->sd_desc->nctrls;\r\ni++, ctrl++) {\r\nctrl->def = gspca_dev->sd_desc->ctrls[i].qctrl.default_value;\r\nctrl->val = ctrl->def;\r\nctrl->min = gspca_dev->sd_desc->ctrls[i].qctrl.minimum;\r\nctrl->max = gspca_dev->sd_desc->ctrls[i].qctrl.maximum;\r\n}\r\n}\r\nint gspca_dev_probe2(struct usb_interface *intf,\r\nconst struct usb_device_id *id,\r\nconst struct sd_desc *sd_desc,\r\nint dev_size,\r\nstruct module *module)\r\n{\r\nstruct gspca_dev *gspca_dev;\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nint ret;\r\npr_info("%s-" GSPCA_VERSION " probing %04x:%04x\n",\r\nsd_desc->name, id->idVendor, id->idProduct);\r\nif (dev_size < sizeof *gspca_dev)\r\ndev_size = sizeof *gspca_dev;\r\ngspca_dev = kzalloc(dev_size, GFP_KERNEL);\r\nif (!gspca_dev) {\r\npr_err("couldn't kzalloc gspca struct\n");\r\nreturn -ENOMEM;\r\n}\r\ngspca_dev->usb_buf = kmalloc(USB_BUF_SZ, GFP_KERNEL);\r\nif (!gspca_dev->usb_buf) {\r\npr_err("out of memory\n");\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ngspca_dev->dev = dev;\r\ngspca_dev->iface = intf->cur_altsetting->desc.bInterfaceNumber;\r\nif (dev->actconfig->desc.bNumInterfaces != 1) {\r\nint i;\r\nstruct usb_interface *intf2;\r\nfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {\r\nintf2 = dev->actconfig->interface[i];\r\nif (intf2 != NULL\r\n&& intf2->altsetting != NULL\r\n&& intf2->altsetting->desc.bInterfaceClass ==\r\nUSB_CLASS_AUDIO) {\r\ngspca_dev->audio = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\ngspca_dev->sd_desc = sd_desc;\r\ngspca_dev->nbufread = 2;\r\ngspca_dev->empty_packet = -1;\r\nret = sd_desc->config(gspca_dev, id);\r\nif (ret < 0)\r\ngoto out;\r\nif (gspca_dev->cam.ctrls != NULL)\r\nctrls_init(gspca_dev);\r\nret = sd_desc->init(gspca_dev);\r\nif (ret < 0)\r\ngoto out;\r\ngspca_set_default_mode(gspca_dev);\r\nret = gspca_input_connect(gspca_dev);\r\nif (ret)\r\ngoto out;\r\nmutex_init(&gspca_dev->usb_lock);\r\nmutex_init(&gspca_dev->queue_lock);\r\ninit_waitqueue_head(&gspca_dev->wq);\r\nmemcpy(&gspca_dev->vdev, &gspca_template, sizeof gspca_template);\r\ngspca_dev->vdev.parent = &intf->dev;\r\ngspca_dev->module = module;\r\ngspca_dev->present = 1;\r\nret = video_register_device(&gspca_dev->vdev,\r\nVFL_TYPE_GRABBER,\r\n-1);\r\nif (ret < 0) {\r\npr_err("video_register_device err %d\n", ret);\r\ngoto out;\r\n}\r\nusb_set_intfdata(intf, gspca_dev);\r\nPDEBUG(D_PROBE, "%s created", video_device_node_name(&gspca_dev->vdev));\r\ngspca_input_create_urb(gspca_dev);\r\nreturn 0;\r\nout:\r\n#if defined(CONFIG_INPUT) || defined(CONFIG_INPUT_MODULE)\r\nif (gspca_dev->input_dev)\r\ninput_unregister_device(gspca_dev->input_dev);\r\n#endif\r\nkfree(gspca_dev->usb_buf);\r\nkfree(gspca_dev);\r\nreturn ret;\r\n}\r\nint gspca_dev_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id,\r\nconst struct sd_desc *sd_desc,\r\nint dev_size,\r\nstruct module *module)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nif (dev->descriptor.bNumConfigurations != 1) {\r\npr_err("%04x:%04x too many config\n",\r\nid->idVendor, id->idProduct);\r\nreturn -ENODEV;\r\n}\r\nif (dev->actconfig->desc.bNumInterfaces != 1\r\n&& intf->cur_altsetting->desc.bInterfaceNumber != 0)\r\nreturn -ENODEV;\r\nreturn gspca_dev_probe2(intf, id, sd_desc, dev_size, module);\r\n}\r\nvoid gspca_disconnect(struct usb_interface *intf)\r\n{\r\nstruct gspca_dev *gspca_dev = usb_get_intfdata(intf);\r\n#if defined(CONFIG_INPUT) || defined(CONFIG_INPUT_MODULE)\r\nstruct input_dev *input_dev;\r\n#endif\r\nPDEBUG(D_PROBE, "%s disconnect",\r\nvideo_device_node_name(&gspca_dev->vdev));\r\nmutex_lock(&gspca_dev->usb_lock);\r\ngspca_dev->present = 0;\r\nwake_up_interruptible(&gspca_dev->wq);\r\ndestroy_urbs(gspca_dev);\r\n#if defined(CONFIG_INPUT) || defined(CONFIG_INPUT_MODULE)\r\ngspca_input_destroy_urb(gspca_dev);\r\ninput_dev = gspca_dev->input_dev;\r\nif (input_dev) {\r\ngspca_dev->input_dev = NULL;\r\ninput_unregister_device(input_dev);\r\n}\r\n#endif\r\ngspca_dev->dev = NULL;\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nusb_set_intfdata(intf, NULL);\r\nvideo_unregister_device(&gspca_dev->vdev);\r\n}\r\nint gspca_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct gspca_dev *gspca_dev = usb_get_intfdata(intf);\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\ngspca_dev->frozen = 1;\r\nif (gspca_dev->sd_desc->stopN)\r\ngspca_dev->sd_desc->stopN(gspca_dev);\r\ndestroy_urbs(gspca_dev);\r\ngspca_input_destroy_urb(gspca_dev);\r\ngspca_set_alt0(gspca_dev);\r\nif (gspca_dev->sd_desc->stop0)\r\ngspca_dev->sd_desc->stop0(gspca_dev);\r\nreturn 0;\r\n}\r\nint gspca_resume(struct usb_interface *intf)\r\n{\r\nstruct gspca_dev *gspca_dev = usb_get_intfdata(intf);\r\ngspca_dev->frozen = 0;\r\ngspca_dev->sd_desc->init(gspca_dev);\r\ngspca_input_create_urb(gspca_dev);\r\nif (gspca_dev->streaming)\r\nreturn gspca_init_transfer(gspca_dev);\r\nreturn 0;\r\n}\r\nint gspca_auto_gain_n_exposure(struct gspca_dev *gspca_dev, int avg_lum,\r\nint desired_avg_lum, int deadzone, int gain_knee, int exposure_knee)\r\n{\r\nint i, steps, gain, orig_gain, exposure, orig_exposure, autogain;\r\nconst struct ctrl *gain_ctrl = NULL;\r\nconst struct ctrl *exposure_ctrl = NULL;\r\nconst struct ctrl *autogain_ctrl = NULL;\r\nint retval = 0;\r\nfor (i = 0; i < gspca_dev->sd_desc->nctrls; i++) {\r\nif (gspca_dev->ctrl_dis & (1 << i))\r\ncontinue;\r\nif (gspca_dev->sd_desc->ctrls[i].qctrl.id == V4L2_CID_GAIN)\r\ngain_ctrl = &gspca_dev->sd_desc->ctrls[i];\r\nif (gspca_dev->sd_desc->ctrls[i].qctrl.id == V4L2_CID_EXPOSURE)\r\nexposure_ctrl = &gspca_dev->sd_desc->ctrls[i];\r\nif (gspca_dev->sd_desc->ctrls[i].qctrl.id == V4L2_CID_AUTOGAIN)\r\nautogain_ctrl = &gspca_dev->sd_desc->ctrls[i];\r\n}\r\nif (!gain_ctrl || !exposure_ctrl || !autogain_ctrl) {\r\nPDEBUG(D_ERR, "Error: gspca_auto_gain_n_exposure called "\r\n"on cam without (auto)gain/exposure");\r\nreturn 0;\r\n}\r\nif (gain_ctrl->get(gspca_dev, &gain) ||\r\nexposure_ctrl->get(gspca_dev, &exposure) ||\r\nautogain_ctrl->get(gspca_dev, &autogain) || !autogain)\r\nreturn 0;\r\norig_gain = gain;\r\norig_exposure = exposure;\r\nsteps = abs(desired_avg_lum - avg_lum) / deadzone;\r\nPDEBUG(D_FRAM, "autogain: lum: %d, desired: %d, steps: %d",\r\navg_lum, desired_avg_lum, steps);\r\nfor (i = 0; i < steps; i++) {\r\nif (avg_lum > desired_avg_lum) {\r\nif (gain > gain_knee)\r\ngain--;\r\nelse if (exposure > exposure_knee)\r\nexposure--;\r\nelse if (gain > gain_ctrl->qctrl.default_value)\r\ngain--;\r\nelse if (exposure > exposure_ctrl->qctrl.minimum)\r\nexposure--;\r\nelse if (gain > gain_ctrl->qctrl.minimum)\r\ngain--;\r\nelse\r\nbreak;\r\n} else {\r\nif (gain < gain_ctrl->qctrl.default_value)\r\ngain++;\r\nelse if (exposure < exposure_knee)\r\nexposure++;\r\nelse if (gain < gain_knee)\r\ngain++;\r\nelse if (exposure < exposure_ctrl->qctrl.maximum)\r\nexposure++;\r\nelse if (gain < gain_ctrl->qctrl.maximum)\r\ngain++;\r\nelse\r\nbreak;\r\n}\r\n}\r\nif (gain != orig_gain) {\r\ngain_ctrl->set(gspca_dev, gain);\r\nretval = 1;\r\n}\r\nif (exposure != orig_exposure) {\r\nexposure_ctrl->set(gspca_dev, exposure);\r\nretval = 1;\r\n}\r\nreturn retval;\r\n}\r\nstatic int __init gspca_init(void)\r\n{\r\npr_info("v" GSPCA_VERSION " registered\n");\r\nreturn 0;\r\n}\r\nstatic void __exit gspca_exit(void)\r\n{\r\n}
