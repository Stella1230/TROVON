int v4l2_device_register(struct device *dev, struct v4l2_device *v4l2_dev)\r\n{\r\nif (v4l2_dev == NULL)\r\nreturn -EINVAL;\r\nINIT_LIST_HEAD(&v4l2_dev->subdevs);\r\nspin_lock_init(&v4l2_dev->lock);\r\nmutex_init(&v4l2_dev->ioctl_lock);\r\nv4l2_prio_init(&v4l2_dev->prio);\r\nkref_init(&v4l2_dev->ref);\r\nget_device(dev);\r\nv4l2_dev->dev = dev;\r\nif (dev == NULL) {\r\nWARN_ON(!v4l2_dev->name[0]);\r\nreturn 0;\r\n}\r\nif (!v4l2_dev->name[0])\r\nsnprintf(v4l2_dev->name, sizeof(v4l2_dev->name), "%s %s",\r\ndev->driver->name, dev_name(dev));\r\nif (!dev_get_drvdata(dev))\r\ndev_set_drvdata(dev, v4l2_dev);\r\nreturn 0;\r\n}\r\nstatic void v4l2_device_release(struct kref *ref)\r\n{\r\nstruct v4l2_device *v4l2_dev =\r\ncontainer_of(ref, struct v4l2_device, ref);\r\nif (v4l2_dev->release)\r\nv4l2_dev->release(v4l2_dev);\r\n}\r\nint v4l2_device_put(struct v4l2_device *v4l2_dev)\r\n{\r\nreturn kref_put(&v4l2_dev->ref, v4l2_device_release);\r\n}\r\nint v4l2_device_set_name(struct v4l2_device *v4l2_dev, const char *basename,\r\natomic_t *instance)\r\n{\r\nint num = atomic_inc_return(instance) - 1;\r\nint len = strlen(basename);\r\nif (basename[len - 1] >= '0' && basename[len - 1] <= '9')\r\nsnprintf(v4l2_dev->name, sizeof(v4l2_dev->name),\r\n"%s-%d", basename, num);\r\nelse\r\nsnprintf(v4l2_dev->name, sizeof(v4l2_dev->name),\r\n"%s%d", basename, num);\r\nreturn num;\r\n}\r\nvoid v4l2_device_disconnect(struct v4l2_device *v4l2_dev)\r\n{\r\nif (v4l2_dev->dev == NULL)\r\nreturn;\r\nif (dev_get_drvdata(v4l2_dev->dev) == v4l2_dev)\r\ndev_set_drvdata(v4l2_dev->dev, NULL);\r\nput_device(v4l2_dev->dev);\r\nv4l2_dev->dev = NULL;\r\n}\r\nvoid v4l2_device_unregister(struct v4l2_device *v4l2_dev)\r\n{\r\nstruct v4l2_subdev *sd, *next;\r\nif (v4l2_dev == NULL)\r\nreturn;\r\nv4l2_device_disconnect(v4l2_dev);\r\nlist_for_each_entry_safe(sd, next, &v4l2_dev->subdevs, list) {\r\nv4l2_device_unregister_subdev(sd);\r\n#if defined(CONFIG_I2C) || (defined(CONFIG_I2C_MODULE) && defined(MODULE))\r\nif (sd->flags & V4L2_SUBDEV_FL_IS_I2C) {\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (client)\r\ni2c_unregister_device(client);\r\ncontinue;\r\n}\r\n#endif\r\n#if defined(CONFIG_SPI)\r\nif (sd->flags & V4L2_SUBDEV_FL_IS_SPI) {\r\nstruct spi_device *spi = v4l2_get_subdevdata(sd);\r\nif (spi)\r\nspi_unregister_device(spi);\r\ncontinue;\r\n}\r\n#endif\r\n}\r\n}\r\nint v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,\r\nstruct v4l2_subdev *sd)\r\n{\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nstruct media_entity *entity = &sd->entity;\r\n#endif\r\nint err;\r\nif (v4l2_dev == NULL || sd == NULL || !sd->name[0])\r\nreturn -EINVAL;\r\nWARN_ON(sd->v4l2_dev != NULL);\r\nif (!try_module_get(sd->owner))\r\nreturn -ENODEV;\r\nsd->v4l2_dev = v4l2_dev;\r\nif (sd->internal_ops && sd->internal_ops->registered) {\r\nerr = sd->internal_ops->registered(sd);\r\nif (err) {\r\nmodule_put(sd->owner);\r\nreturn err;\r\n}\r\n}\r\nerr = v4l2_ctrl_add_handler(v4l2_dev->ctrl_handler, sd->ctrl_handler);\r\nif (err) {\r\nif (sd->internal_ops && sd->internal_ops->unregistered)\r\nsd->internal_ops->unregistered(sd);\r\nmodule_put(sd->owner);\r\nreturn err;\r\n}\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nif (v4l2_dev->mdev) {\r\nerr = media_device_register_entity(v4l2_dev->mdev, entity);\r\nif (err < 0) {\r\nif (sd->internal_ops && sd->internal_ops->unregistered)\r\nsd->internal_ops->unregistered(sd);\r\nmodule_put(sd->owner);\r\nreturn err;\r\n}\r\n}\r\n#endif\r\nspin_lock(&v4l2_dev->lock);\r\nlist_add_tail(&sd->list, &v4l2_dev->subdevs);\r\nspin_unlock(&v4l2_dev->lock);\r\nreturn 0;\r\n}\r\nstatic void v4l2_device_release_subdev_node(struct video_device *vdev)\r\n{\r\nstruct v4l2_subdev *sd = video_get_drvdata(vdev);\r\nsd->devnode = NULL;\r\nkfree(vdev);\r\n}\r\nint v4l2_device_register_subdev_nodes(struct v4l2_device *v4l2_dev)\r\n{\r\nstruct video_device *vdev;\r\nstruct v4l2_subdev *sd;\r\nint err;\r\nlist_for_each_entry(sd, &v4l2_dev->subdevs, list) {\r\nif (!(sd->flags & V4L2_SUBDEV_FL_HAS_DEVNODE))\r\ncontinue;\r\nvdev = kzalloc(sizeof(*vdev), GFP_KERNEL);\r\nif (!vdev) {\r\nerr = -ENOMEM;\r\ngoto clean_up;\r\n}\r\nvideo_set_drvdata(vdev, sd);\r\nstrlcpy(vdev->name, sd->name, sizeof(vdev->name));\r\nvdev->v4l2_dev = v4l2_dev;\r\nvdev->fops = &v4l2_subdev_fops;\r\nvdev->release = v4l2_device_release_subdev_node;\r\nvdev->ctrl_handler = sd->ctrl_handler;\r\nerr = __video_register_device(vdev, VFL_TYPE_SUBDEV, -1, 1,\r\nsd->owner);\r\nif (err < 0) {\r\nkfree(vdev);\r\ngoto clean_up;\r\n}\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nsd->entity.info.v4l.major = VIDEO_MAJOR;\r\nsd->entity.info.v4l.minor = vdev->minor;\r\n#endif\r\nsd->devnode = vdev;\r\n}\r\nreturn 0;\r\nclean_up:\r\nlist_for_each_entry(sd, &v4l2_dev->subdevs, list) {\r\nif (!sd->devnode)\r\nbreak;\r\nvideo_unregister_device(sd->devnode);\r\n}\r\nreturn err;\r\n}\r\nvoid v4l2_device_unregister_subdev(struct v4l2_subdev *sd)\r\n{\r\nstruct v4l2_device *v4l2_dev;\r\nif (sd == NULL || sd->v4l2_dev == NULL)\r\nreturn;\r\nv4l2_dev = sd->v4l2_dev;\r\nspin_lock(&v4l2_dev->lock);\r\nlist_del(&sd->list);\r\nspin_unlock(&v4l2_dev->lock);\r\nif (sd->internal_ops && sd->internal_ops->unregistered)\r\nsd->internal_ops->unregistered(sd);\r\nsd->v4l2_dev = NULL;\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nif (v4l2_dev->mdev)\r\nmedia_device_unregister_entity(&sd->entity);\r\n#endif\r\nvideo_unregister_device(sd->devnode);\r\nmodule_put(sd->owner);\r\n}
