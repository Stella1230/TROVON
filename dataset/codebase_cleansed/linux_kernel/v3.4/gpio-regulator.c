static int gpio_regulator_is_enabled(struct regulator_dev *dev)\r\n{\r\nstruct gpio_regulator_data *data = rdev_get_drvdata(dev);\r\nreturn data->is_enabled;\r\n}\r\nstatic int gpio_regulator_enable(struct regulator_dev *dev)\r\n{\r\nstruct gpio_regulator_data *data = rdev_get_drvdata(dev);\r\nif (gpio_is_valid(data->enable_gpio)) {\r\ngpio_set_value_cansleep(data->enable_gpio, data->enable_high);\r\ndata->is_enabled = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gpio_regulator_disable(struct regulator_dev *dev)\r\n{\r\nstruct gpio_regulator_data *data = rdev_get_drvdata(dev);\r\nif (gpio_is_valid(data->enable_gpio)) {\r\ngpio_set_value_cansleep(data->enable_gpio, !data->enable_high);\r\ndata->is_enabled = false;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gpio_regulator_enable_time(struct regulator_dev *dev)\r\n{\r\nstruct gpio_regulator_data *data = rdev_get_drvdata(dev);\r\nreturn data->startup_delay;\r\n}\r\nstatic int gpio_regulator_get_value(struct regulator_dev *dev)\r\n{\r\nstruct gpio_regulator_data *data = rdev_get_drvdata(dev);\r\nint ptr;\r\nfor (ptr = 0; ptr < data->nr_states; ptr++)\r\nif (data->states[ptr].gpios == data->state)\r\nreturn data->states[ptr].value;\r\nreturn -EINVAL;\r\n}\r\nstatic int gpio_regulator_set_value(struct regulator_dev *dev,\r\nint min, int max)\r\n{\r\nstruct gpio_regulator_data *data = rdev_get_drvdata(dev);\r\nint ptr, target, state;\r\ntarget = -1;\r\nfor (ptr = 0; ptr < data->nr_states; ptr++)\r\nif (data->states[ptr].value >= min &&\r\ndata->states[ptr].value <= max)\r\ntarget = data->states[ptr].gpios;\r\nif (target < 0)\r\nreturn -EINVAL;\r\nfor (ptr = 0; ptr < data->nr_gpios; ptr++) {\r\nstate = (target & (1 << ptr)) >> ptr;\r\ngpio_set_value(data->gpios[ptr].gpio, state);\r\n}\r\ndata->state = target;\r\nreturn 0;\r\n}\r\nstatic int gpio_regulator_set_voltage(struct regulator_dev *dev,\r\nint min_uV, int max_uV,\r\nunsigned *selector)\r\n{\r\nreturn gpio_regulator_set_value(dev, min_uV, max_uV);\r\n}\r\nstatic int gpio_regulator_list_voltage(struct regulator_dev *dev,\r\nunsigned selector)\r\n{\r\nstruct gpio_regulator_data *data = rdev_get_drvdata(dev);\r\nif (selector >= data->nr_states)\r\nreturn -EINVAL;\r\nreturn data->states[selector].value;\r\n}\r\nstatic int gpio_regulator_set_current_limit(struct regulator_dev *dev,\r\nint min_uA, int max_uA)\r\n{\r\nreturn gpio_regulator_set_value(dev, min_uA, max_uA);\r\n}\r\nstatic int __devinit gpio_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct gpio_regulator_config *config = pdev->dev.platform_data;\r\nstruct gpio_regulator_data *drvdata;\r\nint ptr, ret, state;\r\ndrvdata = kzalloc(sizeof(struct gpio_regulator_data), GFP_KERNEL);\r\nif (drvdata == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate device data\n");\r\nreturn -ENOMEM;\r\n}\r\ndrvdata->desc.name = kstrdup(config->supply_name, GFP_KERNEL);\r\nif (drvdata->desc.name == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate supply name\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndrvdata->gpios = kmemdup(config->gpios,\r\nconfig->nr_gpios * sizeof(struct gpio),\r\nGFP_KERNEL);\r\nif (drvdata->gpios == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate gpio data\n");\r\nret = -ENOMEM;\r\ngoto err_name;\r\n}\r\ndrvdata->states = kmemdup(config->states,\r\nconfig->nr_states *\r\nsizeof(struct gpio_regulator_state),\r\nGFP_KERNEL);\r\nif (drvdata->states == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate state data\n");\r\nret = -ENOMEM;\r\ngoto err_memgpio;\r\n}\r\ndrvdata->nr_states = config->nr_states;\r\ndrvdata->desc.owner = THIS_MODULE;\r\nswitch (config->type) {\r\ncase REGULATOR_VOLTAGE:\r\ndrvdata->desc.type = REGULATOR_VOLTAGE;\r\ndrvdata->desc.ops = &gpio_regulator_voltage_ops;\r\ndrvdata->desc.n_voltages = config->nr_states;\r\nbreak;\r\ncase REGULATOR_CURRENT:\r\ndrvdata->desc.type = REGULATOR_CURRENT;\r\ndrvdata->desc.ops = &gpio_regulator_current_ops;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "No regulator type set\n");\r\nret = -EINVAL;\r\ngoto err_memgpio;\r\nbreak;\r\n}\r\ndrvdata->enable_gpio = config->enable_gpio;\r\ndrvdata->startup_delay = config->startup_delay;\r\nif (gpio_is_valid(config->enable_gpio)) {\r\ndrvdata->enable_high = config->enable_high;\r\nret = gpio_request(config->enable_gpio, config->supply_name);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Could not obtain regulator enable GPIO %d: %d\n",\r\nconfig->enable_gpio, ret);\r\ngoto err_memstate;\r\n}\r\nif (config->enabled_at_boot) {\r\ndrvdata->is_enabled = true;\r\nret = gpio_direction_output(config->enable_gpio,\r\nconfig->enable_high);\r\n} else {\r\ndrvdata->is_enabled = false;\r\nret = gpio_direction_output(config->enable_gpio,\r\n!config->enable_high);\r\n}\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Could not configure regulator enable GPIO %d direction: %d\n",\r\nconfig->enable_gpio, ret);\r\ngoto err_enablegpio;\r\n}\r\n} else {\r\ndrvdata->is_enabled = true;\r\n}\r\ndrvdata->nr_gpios = config->nr_gpios;\r\nret = gpio_request_array(drvdata->gpios, drvdata->nr_gpios);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Could not obtain regulator setting GPIOs: %d\n", ret);\r\ngoto err_enablegpio;\r\n}\r\nstate = 0;\r\nfor (ptr = 0; ptr < drvdata->nr_gpios; ptr++) {\r\nif (config->gpios[ptr].flags & GPIOF_OUT_INIT_HIGH)\r\nstate |= (1 << ptr);\r\n}\r\ndrvdata->state = state;\r\ndrvdata->dev = regulator_register(&drvdata->desc, &pdev->dev,\r\nconfig->init_data, drvdata, NULL);\r\nif (IS_ERR(drvdata->dev)) {\r\nret = PTR_ERR(drvdata->dev);\r\ndev_err(&pdev->dev, "Failed to register regulator: %d\n", ret);\r\ngoto err_stategpio;\r\n}\r\nplatform_set_drvdata(pdev, drvdata);\r\nreturn 0;\r\nerr_stategpio:\r\ngpio_free_array(drvdata->gpios, drvdata->nr_gpios);\r\nerr_enablegpio:\r\nif (gpio_is_valid(config->enable_gpio))\r\ngpio_free(config->enable_gpio);\r\nerr_memstate:\r\nkfree(drvdata->states);\r\nerr_memgpio:\r\nkfree(drvdata->gpios);\r\nerr_name:\r\nkfree(drvdata->desc.name);\r\nerr:\r\nkfree(drvdata);\r\nreturn ret;\r\n}\r\nstatic int __devexit gpio_regulator_remove(struct platform_device *pdev)\r\n{\r\nstruct gpio_regulator_data *drvdata = platform_get_drvdata(pdev);\r\nregulator_unregister(drvdata->dev);\r\ngpio_free_array(drvdata->gpios, drvdata->nr_gpios);\r\nkfree(drvdata->states);\r\nkfree(drvdata->gpios);\r\nif (gpio_is_valid(drvdata->enable_gpio))\r\ngpio_free(drvdata->enable_gpio);\r\nkfree(drvdata->desc.name);\r\nkfree(drvdata);\r\nreturn 0;\r\n}\r\nstatic int __init gpio_regulator_init(void)\r\n{\r\nreturn platform_driver_register(&gpio_regulator_driver);\r\n}\r\nstatic void __exit gpio_regulator_exit(void)\r\n{\r\nplatform_driver_unregister(&gpio_regulator_driver);\r\n}
