static int\r\nqtd_fill(struct ehci_hcd *ehci, struct ehci_qtd *qtd, dma_addr_t buf,\r\nsize_t len, int token, int maxpacket)\r\n{\r\nint i, count;\r\nu64 addr = buf;\r\nqtd->hw_buf[0] = cpu_to_hc32(ehci, (u32)addr);\r\nqtd->hw_buf_hi[0] = cpu_to_hc32(ehci, (u32)(addr >> 32));\r\ncount = 0x1000 - (buf & 0x0fff);\r\nif (likely (len < count))\r\ncount = len;\r\nelse {\r\nbuf += 0x1000;\r\nbuf &= ~0x0fff;\r\nfor (i = 1; count < len && i < 5; i++) {\r\naddr = buf;\r\nqtd->hw_buf[i] = cpu_to_hc32(ehci, (u32)addr);\r\nqtd->hw_buf_hi[i] = cpu_to_hc32(ehci,\r\n(u32)(addr >> 32));\r\nbuf += 0x1000;\r\nif ((count + 0x1000) < len)\r\ncount += 0x1000;\r\nelse\r\ncount = len;\r\n}\r\nif (count != len)\r\ncount -= (count % maxpacket);\r\n}\r\nqtd->hw_token = cpu_to_hc32(ehci, (count << 16) | token);\r\nqtd->length = count;\r\nreturn count;\r\n}\r\nstatic inline void\r\nqh_update (struct ehci_hcd *ehci, struct ehci_qh *qh, struct ehci_qtd *qtd)\r\n{\r\nstruct ehci_qh_hw *hw = qh->hw;\r\nBUG_ON(qh->qh_state != QH_STATE_IDLE);\r\nhw->hw_qtd_next = QTD_NEXT(ehci, qtd->qtd_dma);\r\nhw->hw_alt_next = EHCI_LIST_END(ehci);\r\nif (!(hw->hw_info1 & cpu_to_hc32(ehci, 1 << 14))) {\r\nunsigned is_out, epnum;\r\nis_out = qh->is_out;\r\nepnum = (hc32_to_cpup(ehci, &hw->hw_info1) >> 8) & 0x0f;\r\nif (unlikely (!usb_gettoggle (qh->dev, epnum, is_out))) {\r\nhw->hw_token &= ~cpu_to_hc32(ehci, QTD_TOGGLE);\r\nusb_settoggle (qh->dev, epnum, is_out, 1);\r\n}\r\n}\r\nhw->hw_token &= cpu_to_hc32(ehci, QTD_TOGGLE | QTD_STS_PING);\r\n}\r\nstatic void\r\nqh_refresh (struct ehci_hcd *ehci, struct ehci_qh *qh)\r\n{\r\nstruct ehci_qtd *qtd;\r\nif (list_empty (&qh->qtd_list))\r\nqtd = qh->dummy;\r\nelse {\r\nqtd = list_entry (qh->qtd_list.next,\r\nstruct ehci_qtd, qtd_list);\r\nif (cpu_to_hc32(ehci, qtd->qtd_dma) == qh->hw->hw_current)\r\nqtd = NULL;\r\n}\r\nif (qtd)\r\nqh_update (ehci, qh, qtd);\r\n}\r\nstatic void ehci_clear_tt_buffer_complete(struct usb_hcd *hcd,\r\nstruct usb_host_endpoint *ep)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nstruct ehci_qh *qh = ep->hcpriv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ehci->lock, flags);\r\nqh->clearing_tt = 0;\r\nif (qh->qh_state == QH_STATE_IDLE && !list_empty(&qh->qtd_list)\r\n&& ehci->rh_state == EHCI_RH_RUNNING)\r\nqh_link_async(ehci, qh);\r\nspin_unlock_irqrestore(&ehci->lock, flags);\r\n}\r\nstatic void ehci_clear_tt_buffer(struct ehci_hcd *ehci, struct ehci_qh *qh,\r\nstruct urb *urb, u32 token)\r\n{\r\nif (urb->dev->tt && !usb_pipeint(urb->pipe) && !qh->clearing_tt) {\r\n#ifdef DEBUG\r\nstruct usb_device *tt = urb->dev->tt->hub;\r\ndev_dbg(&tt->dev,\r\n"clear tt buffer port %d, a%d ep%d t%08x\n",\r\nurb->dev->ttport, urb->dev->devnum,\r\nusb_pipeendpoint(urb->pipe), token);\r\n#endif\r\nif (!ehci_is_TDI(ehci)\r\n|| urb->dev->tt->hub !=\r\nehci_to_hcd(ehci)->self.root_hub) {\r\nif (usb_hub_clear_tt_buffer(urb) == 0)\r\nqh->clearing_tt = 1;\r\n} else {\r\n}\r\n}\r\n}\r\nstatic int qtd_copy_status (\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\nsize_t length,\r\nu32 token\r\n)\r\n{\r\nint status = -EINPROGRESS;\r\nif (likely (QTD_PID (token) != 2))\r\nurb->actual_length += length - QTD_LENGTH (token);\r\nif (unlikely(urb->unlinked))\r\nreturn status;\r\nif (unlikely (IS_SHORT_READ (token)))\r\nstatus = -EREMOTEIO;\r\nif (token & QTD_STS_HALT) {\r\nif (token & QTD_STS_BABBLE) {\r\nstatus = -EOVERFLOW;\r\n} else if (QTD_CERR(token)) {\r\nstatus = -EPIPE;\r\n} else if (token & QTD_STS_MMF) {\r\nstatus = -EPROTO;\r\n} else if (token & QTD_STS_DBE) {\r\nstatus = (QTD_PID (token) == 1)\r\n? -ENOSR\r\n: -ECOMM;\r\n} else if (token & QTD_STS_XACT) {\r\nehci_dbg(ehci, "devpath %s ep%d%s 3strikes\n",\r\nurb->dev->devpath,\r\nusb_pipeendpoint(urb->pipe),\r\nusb_pipein(urb->pipe) ? "in" : "out");\r\nstatus = -EPROTO;\r\n} else {\r\nstatus = -EPROTO;\r\n}\r\nehci_vdbg (ehci,\r\n"dev%d ep%d%s qtd token %08x --> status %d\n",\r\nusb_pipedevice (urb->pipe),\r\nusb_pipeendpoint (urb->pipe),\r\nusb_pipein (urb->pipe) ? "in" : "out",\r\ntoken, status);\r\n}\r\nreturn status;\r\n}\r\nstatic void\r\nehci_urb_done(struct ehci_hcd *ehci, struct urb *urb, int status)\r\n__releases(ehci->lock)\r\n__acquires(ehci->lock)\r\n{\r\nif (likely (urb->hcpriv != NULL)) {\r\nstruct ehci_qh *qh = (struct ehci_qh *) urb->hcpriv;\r\nif ((qh->hw->hw_info2 & cpu_to_hc32(ehci, QH_SMASK)) != 0) {\r\nehci_to_hcd(ehci)->self.bandwidth_int_reqs--;\r\n}\r\nqh_put (qh);\r\n}\r\nif (unlikely(urb->unlinked)) {\r\nCOUNT(ehci->stats.unlink);\r\n} else {\r\nif (status == -EINPROGRESS || status == -EREMOTEIO)\r\nstatus = 0;\r\nCOUNT(ehci->stats.complete);\r\n}\r\n#ifdef EHCI_URB_TRACE\r\nehci_dbg (ehci,\r\n"%s %s urb %p ep%d%s status %d len %d/%d\n",\r\n__func__, urb->dev->devpath, urb,\r\nusb_pipeendpoint (urb->pipe),\r\nusb_pipein (urb->pipe) ? "in" : "out",\r\nstatus,\r\nurb->actual_length, urb->transfer_buffer_length);\r\n#endif\r\nusb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);\r\nspin_unlock (&ehci->lock);\r\nusb_hcd_giveback_urb(ehci_to_hcd(ehci), urb, status);\r\nspin_lock (&ehci->lock);\r\n}\r\nstatic unsigned\r\nqh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)\r\n{\r\nstruct ehci_qtd *last, *end = qh->dummy;\r\nstruct list_head *entry, *tmp;\r\nint last_status;\r\nint stopped;\r\nunsigned count = 0;\r\nu8 state;\r\nstruct ehci_qh_hw *hw = qh->hw;\r\nif (unlikely (list_empty (&qh->qtd_list)))\r\nreturn count;\r\nstate = qh->qh_state;\r\nqh->qh_state = QH_STATE_COMPLETING;\r\nstopped = (state == QH_STATE_IDLE);\r\nrescan:\r\nlast = NULL;\r\nlast_status = -EINPROGRESS;\r\nqh->needs_rescan = 0;\r\nlist_for_each_safe (entry, tmp, &qh->qtd_list) {\r\nstruct ehci_qtd *qtd;\r\nstruct urb *urb;\r\nu32 token = 0;\r\nqtd = list_entry (entry, struct ehci_qtd, qtd_list);\r\nurb = qtd->urb;\r\nif (last) {\r\nif (likely (last->urb != urb)) {\r\nehci_urb_done(ehci, last->urb, last_status);\r\ncount++;\r\nlast_status = -EINPROGRESS;\r\n}\r\nehci_qtd_free (ehci, last);\r\nlast = NULL;\r\n}\r\nif (qtd == end)\r\nbreak;\r\nrmb ();\r\ntoken = hc32_to_cpu(ehci, qtd->hw_token);\r\nretry_xacterr:\r\nif ((token & QTD_STS_ACTIVE) == 0) {\r\nif (token & QTD_STS_DBE)\r\nehci_dbg(ehci,\r\n"detected DataBufferErr for urb %p ep%d%s len %d, qtd %p [qh %p]\n",\r\nurb,\r\nusb_endpoint_num(&urb->ep->desc),\r\nusb_endpoint_dir_in(&urb->ep->desc) ? "in" : "out",\r\nurb->transfer_buffer_length,\r\nqtd,\r\nqh);\r\nif ((token & QTD_STS_HALT) != 0) {\r\nif ((token & QTD_STS_XACT) &&\r\nQTD_CERR(token) == 0 &&\r\n++qh->xacterrs < QH_XACTERR_MAX &&\r\n!urb->unlinked) {\r\nehci_dbg(ehci,\r\n"detected XactErr len %zu/%zu retry %d\n",\r\nqtd->length - QTD_LENGTH(token), qtd->length, qh->xacterrs);\r\ntoken &= ~QTD_STS_HALT;\r\ntoken |= QTD_STS_ACTIVE |\r\n(EHCI_TUNE_CERR << 10);\r\nqtd->hw_token = cpu_to_hc32(ehci,\r\ntoken);\r\nwmb();\r\nhw->hw_token = cpu_to_hc32(ehci,\r\ntoken);\r\ngoto retry_xacterr;\r\n}\r\nstopped = 1;\r\n} else if (IS_SHORT_READ (token)\r\n&& !(qtd->hw_alt_next\r\n& EHCI_LIST_END(ehci))) {\r\nstopped = 1;\r\n}\r\n} else if (likely (!stopped\r\n&& ehci->rh_state == EHCI_RH_RUNNING)) {\r\nbreak;\r\n} else {\r\nstopped = 1;\r\nif (ehci->rh_state != EHCI_RH_RUNNING)\r\nlast_status = -ESHUTDOWN;\r\nelse if (last_status == -EINPROGRESS && !urb->unlinked)\r\ncontinue;\r\nif (state == QH_STATE_IDLE\r\n&& cpu_to_hc32(ehci, qtd->qtd_dma)\r\n== hw->hw_current) {\r\ntoken = hc32_to_cpu(ehci, hw->hw_token);\r\nehci_clear_tt_buffer(ehci, qh, urb, token);\r\n}\r\n}\r\nif (last_status == -EINPROGRESS) {\r\nlast_status = qtd_copy_status(ehci, urb,\r\nqtd->length, token);\r\nif (last_status == -EREMOTEIO\r\n&& (qtd->hw_alt_next\r\n& EHCI_LIST_END(ehci)))\r\nlast_status = -EINPROGRESS;\r\nif (unlikely(last_status != -EINPROGRESS &&\r\nlast_status != -EREMOTEIO)) {\r\nif (last_status != -EPIPE)\r\nehci_clear_tt_buffer(ehci, qh, urb,\r\ntoken);\r\n}\r\n}\r\nif (stopped && qtd->qtd_list.prev != &qh->qtd_list) {\r\nlast = list_entry (qtd->qtd_list.prev,\r\nstruct ehci_qtd, qtd_list);\r\nlast->hw_next = qtd->hw_next;\r\n}\r\nlist_del (&qtd->qtd_list);\r\nlast = qtd;\r\nqh->xacterrs = 0;\r\n}\r\nif (likely (last != NULL)) {\r\nehci_urb_done(ehci, last->urb, last_status);\r\ncount++;\r\nehci_qtd_free (ehci, last);\r\n}\r\nif (unlikely(qh->needs_rescan)) {\r\nif (state == QH_STATE_IDLE)\r\ngoto rescan;\r\nif (state != QH_STATE_LINKED)\r\nqh->needs_rescan = 0;\r\n}\r\nqh->qh_state = state;\r\nif (stopped != 0 || hw->hw_qtd_next == EHCI_LIST_END(ehci)) {\r\nswitch (state) {\r\ncase QH_STATE_IDLE:\r\nqh_refresh(ehci, qh);\r\nbreak;\r\ncase QH_STATE_LINKED:\r\nqh->needs_rescan = 1;\r\nbreak;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic void qtd_list_free (\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\nstruct list_head *qtd_list\r\n) {\r\nstruct list_head *entry, *temp;\r\nlist_for_each_safe (entry, temp, qtd_list) {\r\nstruct ehci_qtd *qtd;\r\nqtd = list_entry (entry, struct ehci_qtd, qtd_list);\r\nlist_del (&qtd->qtd_list);\r\nehci_qtd_free (ehci, qtd);\r\n}\r\n}\r\nstatic struct list_head *\r\nqh_urb_transaction (\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\nstruct list_head *head,\r\ngfp_t flags\r\n) {\r\nstruct ehci_qtd *qtd, *qtd_prev;\r\ndma_addr_t buf;\r\nint len, this_sg_len, maxpacket;\r\nint is_input;\r\nu32 token;\r\nint i;\r\nstruct scatterlist *sg;\r\nqtd = ehci_qtd_alloc (ehci, flags);\r\nif (unlikely (!qtd))\r\nreturn NULL;\r\nlist_add_tail (&qtd->qtd_list, head);\r\nqtd->urb = urb;\r\ntoken = QTD_STS_ACTIVE;\r\ntoken |= (EHCI_TUNE_CERR << 10);\r\nlen = urb->transfer_buffer_length;\r\nis_input = usb_pipein (urb->pipe);\r\nif (usb_pipecontrol (urb->pipe)) {\r\nqtd_fill(ehci, qtd, urb->setup_dma,\r\nsizeof (struct usb_ctrlrequest),\r\ntoken | (2 << 8), 8);\r\ntoken ^= QTD_TOGGLE;\r\nqtd_prev = qtd;\r\nqtd = ehci_qtd_alloc (ehci, flags);\r\nif (unlikely (!qtd))\r\ngoto cleanup;\r\nqtd->urb = urb;\r\nqtd_prev->hw_next = QTD_NEXT(ehci, qtd->qtd_dma);\r\nlist_add_tail (&qtd->qtd_list, head);\r\nif (len == 0)\r\ntoken |= (1 << 8);\r\n}\r\ni = urb->num_mapped_sgs;\r\nif (len > 0 && i > 0) {\r\nsg = urb->sg;\r\nbuf = sg_dma_address(sg);\r\nthis_sg_len = min_t(int, sg_dma_len(sg), len);\r\n} else {\r\nsg = NULL;\r\nbuf = urb->transfer_dma;\r\nthis_sg_len = len;\r\n}\r\nif (is_input)\r\ntoken |= (1 << 8);\r\nmaxpacket = max_packet(usb_maxpacket(urb->dev, urb->pipe, !is_input));\r\nfor (;;) {\r\nint this_qtd_len;\r\nthis_qtd_len = qtd_fill(ehci, qtd, buf, this_sg_len, token,\r\nmaxpacket);\r\nthis_sg_len -= this_qtd_len;\r\nlen -= this_qtd_len;\r\nbuf += this_qtd_len;\r\nif (is_input)\r\nqtd->hw_alt_next = ehci->async->hw->hw_alt_next;\r\nif ((maxpacket & (this_qtd_len + (maxpacket - 1))) == 0)\r\ntoken ^= QTD_TOGGLE;\r\nif (likely(this_sg_len <= 0)) {\r\nif (--i <= 0 || len <= 0)\r\nbreak;\r\nsg = sg_next(sg);\r\nbuf = sg_dma_address(sg);\r\nthis_sg_len = min_t(int, sg_dma_len(sg), len);\r\n}\r\nqtd_prev = qtd;\r\nqtd = ehci_qtd_alloc (ehci, flags);\r\nif (unlikely (!qtd))\r\ngoto cleanup;\r\nqtd->urb = urb;\r\nqtd_prev->hw_next = QTD_NEXT(ehci, qtd->qtd_dma);\r\nlist_add_tail (&qtd->qtd_list, head);\r\n}\r\nif (likely ((urb->transfer_flags & URB_SHORT_NOT_OK) == 0\r\n|| usb_pipecontrol (urb->pipe)))\r\nqtd->hw_alt_next = EHCI_LIST_END(ehci);\r\nif (likely (urb->transfer_buffer_length != 0)) {\r\nint one_more = 0;\r\nif (usb_pipecontrol (urb->pipe)) {\r\none_more = 1;\r\ntoken ^= 0x0100;\r\ntoken |= QTD_TOGGLE;\r\n} else if (usb_pipeout(urb->pipe)\r\n&& (urb->transfer_flags & URB_ZERO_PACKET)\r\n&& !(urb->transfer_buffer_length % maxpacket)) {\r\none_more = 1;\r\n}\r\nif (one_more) {\r\nqtd_prev = qtd;\r\nqtd = ehci_qtd_alloc (ehci, flags);\r\nif (unlikely (!qtd))\r\ngoto cleanup;\r\nqtd->urb = urb;\r\nqtd_prev->hw_next = QTD_NEXT(ehci, qtd->qtd_dma);\r\nlist_add_tail (&qtd->qtd_list, head);\r\nqtd_fill(ehci, qtd, 0, 0, token, 0);\r\n}\r\n}\r\nif (likely (!(urb->transfer_flags & URB_NO_INTERRUPT)))\r\nqtd->hw_token |= cpu_to_hc32(ehci, QTD_IOC);\r\nreturn head;\r\ncleanup:\r\nqtd_list_free (ehci, urb, head);\r\nreturn NULL;\r\n}\r\nstatic struct ehci_qh *\r\nqh_make (\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\ngfp_t flags\r\n) {\r\nstruct ehci_qh *qh = ehci_qh_alloc (ehci, flags);\r\nu32 info1 = 0, info2 = 0;\r\nint is_input, type;\r\nint maxp = 0;\r\nstruct usb_tt *tt = urb->dev->tt;\r\nstruct ehci_qh_hw *hw;\r\nif (!qh)\r\nreturn qh;\r\ninfo1 |= usb_pipeendpoint (urb->pipe) << 8;\r\ninfo1 |= usb_pipedevice (urb->pipe) << 0;\r\nis_input = usb_pipein (urb->pipe);\r\ntype = usb_pipetype (urb->pipe);\r\nmaxp = usb_maxpacket (urb->dev, urb->pipe, !is_input);\r\nif (max_packet(maxp) > 1024) {\r\nehci_dbg(ehci, "bogus qh maxpacket %d\n", max_packet(maxp));\r\ngoto done;\r\n}\r\nif (type == PIPE_INTERRUPT) {\r\nqh->usecs = NS_TO_US(usb_calc_bus_time(USB_SPEED_HIGH,\r\nis_input, 0,\r\nhb_mult(maxp) * max_packet(maxp)));\r\nqh->start = NO_FRAME;\r\nqh->stamp = ehci->periodic_stamp;\r\nif (urb->dev->speed == USB_SPEED_HIGH) {\r\nqh->c_usecs = 0;\r\nqh->gap_uf = 0;\r\nqh->period = urb->interval >> 3;\r\nif (qh->period == 0 && urb->interval != 1) {\r\nurb->interval = 1;\r\n} else if (qh->period > ehci->periodic_size) {\r\nqh->period = ehci->periodic_size;\r\nurb->interval = qh->period << 3;\r\n}\r\n} else {\r\nint think_time;\r\nqh->gap_uf = 1 + usb_calc_bus_time (urb->dev->speed,\r\nis_input, 0, maxp) / (125 * 1000);\r\nif (is_input) {\r\nqh->c_usecs = qh->usecs + HS_USECS (0);\r\nqh->usecs = HS_USECS (1);\r\n} else {\r\nqh->usecs += HS_USECS (1);\r\nqh->c_usecs = HS_USECS (0);\r\n}\r\nthink_time = tt ? tt->think_time : 0;\r\nqh->tt_usecs = NS_TO_US (think_time +\r\nusb_calc_bus_time (urb->dev->speed,\r\nis_input, 0, max_packet (maxp)));\r\nqh->period = urb->interval;\r\nif (qh->period > ehci->periodic_size) {\r\nqh->period = ehci->periodic_size;\r\nurb->interval = qh->period;\r\n}\r\n}\r\n}\r\nqh->dev = urb->dev;\r\nswitch (urb->dev->speed) {\r\ncase USB_SPEED_LOW:\r\ninfo1 |= (1 << 12);\r\ncase USB_SPEED_FULL:\r\nif (type != PIPE_INTERRUPT)\r\ninfo1 |= (EHCI_TUNE_RL_TT << 28);\r\nif (type == PIPE_CONTROL) {\r\ninfo1 |= (1 << 27);\r\ninfo1 |= 1 << 14;\r\n}\r\ninfo1 |= maxp << 16;\r\ninfo2 |= (EHCI_TUNE_MULT_TT << 30);\r\nif (ehci_has_fsl_portno_bug(ehci))\r\ninfo2 |= (urb->dev->ttport-1) << 23;\r\nelse\r\ninfo2 |= urb->dev->ttport << 23;\r\nif (tt && tt->hub != ehci_to_hcd(ehci)->self.root_hub)\r\ninfo2 |= tt->hub->devnum << 16;\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\ninfo1 |= (2 << 12);\r\nif (type == PIPE_CONTROL) {\r\ninfo1 |= (EHCI_TUNE_RL_HS << 28);\r\ninfo1 |= 64 << 16;\r\ninfo1 |= 1 << 14;\r\ninfo2 |= (EHCI_TUNE_MULT_HS << 30);\r\n} else if (type == PIPE_BULK) {\r\ninfo1 |= (EHCI_TUNE_RL_HS << 28);\r\ninfo1 |= max_packet(maxp) << 16;\r\ninfo2 |= (EHCI_TUNE_MULT_HS << 30);\r\n} else {\r\ninfo1 |= max_packet (maxp) << 16;\r\ninfo2 |= hb_mult (maxp) << 30;\r\n}\r\nbreak;\r\ndefault:\r\ndbg ("bogus dev %p speed %d", urb->dev, urb->dev->speed);\r\ndone:\r\nqh_put (qh);\r\nreturn NULL;\r\n}\r\nqh->qh_state = QH_STATE_IDLE;\r\nhw = qh->hw;\r\nhw->hw_info1 = cpu_to_hc32(ehci, info1);\r\nhw->hw_info2 = cpu_to_hc32(ehci, info2);\r\nqh->is_out = !is_input;\r\nusb_settoggle (urb->dev, usb_pipeendpoint (urb->pipe), !is_input, 1);\r\nqh_refresh (ehci, qh);\r\nreturn qh;\r\n}\r\nstatic void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)\r\n{\r\n__hc32 dma = QH_NEXT(ehci, qh->qh_dma);\r\nstruct ehci_qh *head;\r\nif (unlikely(qh->clearing_tt))\r\nreturn;\r\nWARN_ON(qh->qh_state != QH_STATE_IDLE);\r\nhead = ehci->async;\r\ntimer_action_done (ehci, TIMER_ASYNC_OFF);\r\nif (!head->qh_next.qh) {\r\nu32 cmd = ehci_readl(ehci, &ehci->regs->command);\r\nif (!(cmd & CMD_ASE)) {\r\n(void)handshake(ehci, &ehci->regs->status,\r\nSTS_ASS, 0, 150);\r\ncmd |= CMD_ASE;\r\nehci_writel(ehci, cmd, &ehci->regs->command);\r\n}\r\n}\r\nqh_refresh(ehci, qh);\r\nqh->qh_next = head->qh_next;\r\nqh->hw->hw_next = head->hw->hw_next;\r\nwmb ();\r\nhead->qh_next.qh = qh;\r\nhead->hw->hw_next = dma;\r\nqh_get(qh);\r\nqh->xacterrs = 0;\r\nqh->qh_state = QH_STATE_LINKED;\r\n}\r\nstatic struct ehci_qh *qh_append_tds (\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\nstruct list_head *qtd_list,\r\nint epnum,\r\nvoid **ptr\r\n)\r\n{\r\nstruct ehci_qh *qh = NULL;\r\n__hc32 qh_addr_mask = cpu_to_hc32(ehci, 0x7f);\r\nqh = (struct ehci_qh *) *ptr;\r\nif (unlikely (qh == NULL)) {\r\nqh = qh_make (ehci, urb, GFP_ATOMIC);\r\n*ptr = qh;\r\n}\r\nif (likely (qh != NULL)) {\r\nstruct ehci_qtd *qtd;\r\nif (unlikely (list_empty (qtd_list)))\r\nqtd = NULL;\r\nelse\r\nqtd = list_entry (qtd_list->next, struct ehci_qtd,\r\nqtd_list);\r\nif (unlikely (epnum == 0)) {\r\nif (usb_pipedevice (urb->pipe) == 0)\r\nqh->hw->hw_info1 &= ~qh_addr_mask;\r\n}\r\nif (likely (qtd != NULL)) {\r\nstruct ehci_qtd *dummy;\r\ndma_addr_t dma;\r\n__hc32 token;\r\ntoken = qtd->hw_token;\r\nqtd->hw_token = HALT_BIT(ehci);\r\ndummy = qh->dummy;\r\ndma = dummy->qtd_dma;\r\n*dummy = *qtd;\r\ndummy->qtd_dma = dma;\r\nlist_del (&qtd->qtd_list);\r\nlist_add (&dummy->qtd_list, qtd_list);\r\nlist_splice_tail(qtd_list, &qh->qtd_list);\r\nehci_qtd_init(ehci, qtd, qtd->qtd_dma);\r\nqh->dummy = qtd;\r\ndma = qtd->qtd_dma;\r\nqtd = list_entry (qh->qtd_list.prev,\r\nstruct ehci_qtd, qtd_list);\r\nqtd->hw_next = QTD_NEXT(ehci, dma);\r\nwmb ();\r\ndummy->hw_token = token;\r\nurb->hcpriv = qh_get (qh);\r\n}\r\n}\r\nreturn qh;\r\n}\r\nstatic int\r\nsubmit_async (\r\nstruct ehci_hcd *ehci,\r\nstruct urb *urb,\r\nstruct list_head *qtd_list,\r\ngfp_t mem_flags\r\n) {\r\nint epnum;\r\nunsigned long flags;\r\nstruct ehci_qh *qh = NULL;\r\nint rc;\r\nepnum = urb->ep->desc.bEndpointAddress;\r\n#ifdef EHCI_URB_TRACE\r\n{\r\nstruct ehci_qtd *qtd;\r\nqtd = list_entry(qtd_list->next, struct ehci_qtd, qtd_list);\r\nehci_dbg(ehci,\r\n"%s %s urb %p ep%d%s len %d, qtd %p [qh %p]\n",\r\n__func__, urb->dev->devpath, urb,\r\nepnum & 0x0f, (epnum & USB_DIR_IN) ? "in" : "out",\r\nurb->transfer_buffer_length,\r\nqtd, urb->ep->hcpriv);\r\n}\r\n#endif\r\nspin_lock_irqsave (&ehci->lock, flags);\r\nif (unlikely(!HCD_HW_ACCESSIBLE(ehci_to_hcd(ehci)))) {\r\nrc = -ESHUTDOWN;\r\ngoto done;\r\n}\r\nrc = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);\r\nif (unlikely(rc))\r\ngoto done;\r\nqh = qh_append_tds(ehci, urb, qtd_list, epnum, &urb->ep->hcpriv);\r\nif (unlikely(qh == NULL)) {\r\nusb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);\r\nrc = -ENOMEM;\r\ngoto done;\r\n}\r\nif (likely (qh->qh_state == QH_STATE_IDLE))\r\nqh_link_async(ehci, qh);\r\ndone:\r\nspin_unlock_irqrestore (&ehci->lock, flags);\r\nif (unlikely (qh == NULL))\r\nqtd_list_free (ehci, urb, qtd_list);\r\nreturn rc;\r\n}\r\nstatic void end_unlink_async (struct ehci_hcd *ehci)\r\n{\r\nstruct ehci_qh *qh = ehci->reclaim;\r\nstruct ehci_qh *next;\r\niaa_watchdog_done(ehci);\r\nqh->qh_state = QH_STATE_IDLE;\r\nqh->qh_next.qh = NULL;\r\nqh_put (qh);\r\nnext = qh->reclaim;\r\nehci->reclaim = next;\r\nqh->reclaim = NULL;\r\nqh_completions (ehci, qh);\r\nif (!list_empty(&qh->qtd_list) && ehci->rh_state == EHCI_RH_RUNNING) {\r\nqh_link_async (ehci, qh);\r\n} else {\r\nif (ehci->rh_state == EHCI_RH_RUNNING\r\n&& ehci->async->qh_next.qh == NULL)\r\ntimer_action (ehci, TIMER_ASYNC_OFF);\r\n}\r\nqh_put(qh);\r\nif (next) {\r\nehci->reclaim = NULL;\r\nstart_unlink_async (ehci, next);\r\n}\r\nif (ehci->has_synopsys_hc_bug)\r\nehci_writel(ehci, (u32) ehci->async->qh_dma,\r\n&ehci->regs->async_next);\r\n}\r\nstatic void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)\r\n{\r\nint cmd = ehci_readl(ehci, &ehci->regs->command);\r\nstruct ehci_qh *prev;\r\n#ifdef DEBUG\r\nassert_spin_locked(&ehci->lock);\r\nif (ehci->reclaim\r\n|| (qh->qh_state != QH_STATE_LINKED\r\n&& qh->qh_state != QH_STATE_UNLINK_WAIT)\r\n)\r\nBUG ();\r\n#endif\r\nif (unlikely (qh == ehci->async)) {\r\nif (ehci->rh_state != EHCI_RH_HALTED\r\n&& !ehci->reclaim) {\r\nehci_writel(ehci, cmd & ~CMD_ASE,\r\n&ehci->regs->command);\r\nwmb ();\r\ntimer_action_done (ehci, TIMER_ASYNC_OFF);\r\n}\r\nreturn;\r\n}\r\nqh->qh_state = QH_STATE_UNLINK;\r\nehci->reclaim = qh = qh_get (qh);\r\nprev = ehci->async;\r\nwhile (prev->qh_next.qh != qh)\r\nprev = prev->qh_next.qh;\r\nprev->hw->hw_next = qh->hw->hw_next;\r\nprev->qh_next = qh->qh_next;\r\nif (ehci->qh_scan_next == qh)\r\nehci->qh_scan_next = qh->qh_next.qh;\r\nwmb ();\r\nif (unlikely(ehci->rh_state != EHCI_RH_RUNNING)) {\r\nend_unlink_async (ehci);\r\nreturn;\r\n}\r\ncmd |= CMD_IAAD;\r\nehci_writel(ehci, cmd, &ehci->regs->command);\r\n(void)ehci_readl(ehci, &ehci->regs->command);\r\niaa_watchdog_start(ehci);\r\n}\r\nstatic void scan_async (struct ehci_hcd *ehci)\r\n{\r\nbool stopped;\r\nstruct ehci_qh *qh;\r\nenum ehci_timer_action action = TIMER_IO_WATCHDOG;\r\ntimer_action_done (ehci, TIMER_ASYNC_SHRINK);\r\nstopped = (ehci->rh_state != EHCI_RH_RUNNING);\r\nehci->qh_scan_next = ehci->async->qh_next.qh;\r\nwhile (ehci->qh_scan_next) {\r\nqh = ehci->qh_scan_next;\r\nehci->qh_scan_next = qh->qh_next.qh;\r\nrescan:\r\nif (!list_empty(&qh->qtd_list)) {\r\nint temp;\r\nqh = qh_get(qh);\r\ntemp = qh_completions(ehci, qh);\r\nif (qh->needs_rescan)\r\nunlink_async(ehci, qh);\r\nqh->unlink_time = jiffies + EHCI_SHRINK_JIFFIES;\r\nqh_put(qh);\r\nif (temp != 0)\r\ngoto rescan;\r\n}\r\nif (list_empty(&qh->qtd_list)\r\n&& qh->qh_state == QH_STATE_LINKED) {\r\nif (!ehci->reclaim && (stopped ||\r\ntime_after_eq(jiffies, qh->unlink_time)))\r\nstart_unlink_async(ehci, qh);\r\nelse\r\naction = TIMER_ASYNC_SHRINK;\r\n}\r\n}\r\nif (action == TIMER_ASYNC_SHRINK)\r\ntimer_action (ehci, TIMER_ASYNC_SHRINK);\r\n}
