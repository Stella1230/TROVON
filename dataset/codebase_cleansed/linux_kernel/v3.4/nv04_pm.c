int\r\nnv04_pm_clocks_get(struct drm_device *dev, struct nouveau_pm_level *perflvl)\r\n{\r\nint ret;\r\nret = nouveau_hw_get_clock(dev, PLL_CORE);\r\nif (ret < 0)\r\nreturn ret;\r\nperflvl->core = ret;\r\nret = nouveau_hw_get_clock(dev, PLL_MEMORY);\r\nif (ret < 0)\r\nreturn ret;\r\nperflvl->memory = ret;\r\nreturn 0;\r\n}\r\nstatic int\r\ncalc_pll(struct drm_device *dev, u32 id, int khz, struct nv04_pm_clock *clk)\r\n{\r\nint ret;\r\nret = get_pll_limits(dev, id, &clk->pll);\r\nif (ret)\r\nreturn ret;\r\nret = nouveau_calc_pll_mnp(dev, &clk->pll, khz, &clk->calc);\r\nif (!ret)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nvoid *\r\nnv04_pm_clocks_pre(struct drm_device *dev, struct nouveau_pm_level *perflvl)\r\n{\r\nstruct nv04_pm_state *info;\r\nint ret;\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = calc_pll(dev, PLL_CORE, perflvl->core, &info->core);\r\nif (ret)\r\ngoto error;\r\nif (perflvl->memory) {\r\nret = calc_pll(dev, PLL_MEMORY, perflvl->memory, &info->memory);\r\nif (ret)\r\ngoto error;\r\n}\r\nreturn info;\r\nerror:\r\nkfree(info);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void\r\nprog_pll(struct drm_device *dev, struct nv04_pm_clock *clk)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nu32 reg = clk->pll.reg;\r\nif (dev_priv->card_type >= NV_40)\r\nreg += 4;\r\nnouveau_hw_setpll(dev, reg, &clk->calc);\r\n}\r\nint\r\nnv04_pm_clocks_set(struct drm_device *dev, void *pre_state)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_timer_engine *ptimer = &dev_priv->engine.timer;\r\nstruct nv04_pm_state *state = pre_state;\r\nprog_pll(dev, &state->core);\r\nif (state->memory.pll.reg) {\r\nprog_pll(dev, &state->memory);\r\nif (dev_priv->card_type < NV_30) {\r\nif (dev_priv->card_type == NV_20)\r\nnv_mask(dev, 0x1002c4, 0, 1 << 20);\r\nnv_mask(dev, 0x1002c0, 0, 1 << 8);\r\n}\r\n}\r\nptimer->init(dev);\r\nkfree(state);\r\nreturn 0;\r\n}
