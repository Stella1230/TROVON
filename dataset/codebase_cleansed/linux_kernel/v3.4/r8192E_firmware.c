void firmware_init_param(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rt_firmware *pfirmware = priv->pFirmware;\r\npfirmware->cmdpacket_frag_thresold = GET_COMMAND_PACKET_FRAG_THRESHOLD(\r\nMAX_TRANSMIT_BUFFER_SIZE);\r\n}\r\nstatic bool fw_download_code(struct net_device *dev, u8 *code_virtual_address,\r\nu32 buffer_len)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nbool rt_status = true;\r\nu16 frag_threshold;\r\nu16 frag_length, frag_offset = 0;\r\nint i;\r\nstruct rt_firmware *pfirmware = priv->pFirmware;\r\nstruct sk_buff *skb;\r\nunsigned char *seg_ptr;\r\nstruct cb_desc *tcb_desc;\r\nu8 bLastIniPkt;\r\nfirmware_init_param(dev);\r\nfrag_threshold = pfirmware->cmdpacket_frag_thresold;\r\ndo {\r\nif ((buffer_len - frag_offset) > frag_threshold) {\r\nfrag_length = frag_threshold ;\r\nbLastIniPkt = 0;\r\n} else {\r\nfrag_length = buffer_len - frag_offset;\r\nbLastIniPkt = 1;\r\n}\r\nskb = dev_alloc_skb(frag_length + 4);\r\nmemcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));\r\ntcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\r\ntcb_desc->queue_index = TXCMD_QUEUE;\r\ntcb_desc->bCmdOrInit = DESC_PACKET_TYPE_INIT;\r\ntcb_desc->bLastIniPkt = bLastIniPkt;\r\nseg_ptr = skb->data;\r\nfor (i = 0; i < frag_length; i += 4) {\r\n*seg_ptr++ = ((i+0) < frag_length) ?\r\ncode_virtual_address[i+3] : 0;\r\n*seg_ptr++ = ((i+1) < frag_length) ?\r\ncode_virtual_address[i+2] : 0;\r\n*seg_ptr++ = ((i+2) < frag_length) ?\r\ncode_virtual_address[i+1] : 0;\r\n*seg_ptr++ = ((i+3) < frag_length) ?\r\ncode_virtual_address[i+0] : 0;\r\n}\r\ntcb_desc->txbuf_size = (u16)i;\r\nskb_put(skb, i);\r\nif (!priv->rtllib->check_nic_enough_desc(dev, tcb_desc->queue_index) ||\r\n(!skb_queue_empty(&priv->rtllib->skb_waitQ[tcb_desc->queue_index])) ||\r\n(priv->rtllib->queue_stop)) {\r\nRT_TRACE(COMP_FIRMWARE, "===================> tx "\r\n"full!\n");\r\nskb_queue_tail(&priv->rtllib->skb_waitQ\r\n[tcb_desc->queue_index], skb);\r\n} else {\r\npriv->rtllib->softmac_hard_start_xmit(skb, dev);\r\n}\r\ncode_virtual_address += frag_length;\r\nfrag_offset += frag_length;\r\n} while (frag_offset < buffer_len);\r\nwrite_nic_byte(dev, TPPoll, TPPoll_CQ);\r\nreturn rt_status;\r\n}\r\nstatic bool CPUcheck_maincodeok_turnonCPU(struct net_device *dev)\r\n{\r\nbool rt_status = true;\r\nu32 CPU_status = 0;\r\nunsigned long timeout;\r\ntimeout = jiffies + MSECS(200);\r\nwhile (time_before(jiffies, timeout)) {\r\nCPU_status = read_nic_dword(dev, CPU_GEN);\r\nif (CPU_status & CPU_GEN_PUT_CODE_OK)\r\nbreak;\r\nmdelay(2);\r\n}\r\nif (!(CPU_status&CPU_GEN_PUT_CODE_OK)) {\r\nRT_TRACE(COMP_ERR, "Download Firmware: Put code fail!\n");\r\ngoto CPUCheckMainCodeOKAndTurnOnCPU_Fail;\r\n} else {\r\nRT_TRACE(COMP_FIRMWARE, "Download Firmware: Put code ok!\n");\r\n}\r\nCPU_status = read_nic_dword(dev, CPU_GEN);\r\nwrite_nic_byte(dev, CPU_GEN,\r\n(u8)((CPU_status|CPU_GEN_PWR_STB_CPU)&0xff));\r\nmdelay(1);\r\ntimeout = jiffies + MSECS(200);\r\nwhile (time_before(jiffies, timeout)) {\r\nCPU_status = read_nic_dword(dev, CPU_GEN);\r\nif (CPU_status&CPU_GEN_BOOT_RDY)\r\nbreak;\r\nmdelay(2);\r\n}\r\nif (!(CPU_status&CPU_GEN_BOOT_RDY))\r\ngoto CPUCheckMainCodeOKAndTurnOnCPU_Fail;\r\nelse\r\nRT_TRACE(COMP_FIRMWARE, "Download Firmware: Boot ready!\n");\r\nreturn rt_status;\r\nCPUCheckMainCodeOKAndTurnOnCPU_Fail:\r\nRT_TRACE(COMP_ERR, "ERR in %s()\n", __func__);\r\nrt_status = false;\r\nreturn rt_status;\r\n}\r\nstatic bool CPUcheck_firmware_ready(struct net_device *dev)\r\n{\r\nbool rt_status = true;\r\nu32 CPU_status = 0;\r\nunsigned long timeout;\r\ntimeout = jiffies + MSECS(20);\r\nwhile (time_before(jiffies, timeout)) {\r\nCPU_status = read_nic_dword(dev, CPU_GEN);\r\nif (CPU_status&CPU_GEN_FIRM_RDY)\r\nbreak;\r\nmdelay(2);\r\n}\r\nif (!(CPU_status&CPU_GEN_FIRM_RDY))\r\ngoto CPUCheckFirmwareReady_Fail;\r\nelse\r\nRT_TRACE(COMP_FIRMWARE, "Download Firmware: Firmware ready!\n");\r\nreturn rt_status;\r\nCPUCheckFirmwareReady_Fail:\r\nRT_TRACE(COMP_ERR, "ERR in %s()\n", __func__);\r\nrt_status = false;\r\nreturn rt_status;\r\n}\r\nstatic bool firmware_check_ready(struct net_device *dev,\r\nu8 load_fw_status)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rt_firmware *pfirmware = priv->pFirmware;\r\nbool rt_status = true;\r\nswitch (load_fw_status) {\r\ncase FW_INIT_STEP0_BOOT:\r\npfirmware->firmware_status = FW_STATUS_1_MOVE_BOOT_CODE;\r\nbreak;\r\ncase FW_INIT_STEP1_MAIN:\r\npfirmware->firmware_status = FW_STATUS_2_MOVE_MAIN_CODE;\r\nrt_status = CPUcheck_maincodeok_turnonCPU(dev);\r\nif (rt_status)\r\npfirmware->firmware_status = FW_STATUS_3_TURNON_CPU;\r\nelse\r\nRT_TRACE(COMP_FIRMWARE, "CPUcheck_maincodeok_turnon"\r\n"CPU fail!\n");\r\nbreak;\r\ncase FW_INIT_STEP2_DATA:\r\npfirmware->firmware_status = FW_STATUS_4_MOVE_DATA_CODE;\r\nmdelay(1);\r\nrt_status = CPUcheck_firmware_ready(dev);\r\nif (rt_status)\r\npfirmware->firmware_status = FW_STATUS_5_READY;\r\nelse\r\nRT_TRACE(COMP_FIRMWARE, "CPUcheck_firmware_ready fail"\r\n"(%d)!\n", rt_status);\r\nbreak;\r\ndefault:\r\nrt_status = false;\r\nRT_TRACE(COMP_FIRMWARE, "Unknown firware status");\r\nbreak;\r\n}\r\nreturn rt_status;\r\n}\r\nbool init_firmware(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nbool rt_status = true;\r\nu8 *firmware_img_buf[3] = { &Rtl8192PciEFwBootArray[0],\r\n&Rtl8192PciEFwMainArray[0],\r\n&Rtl8192PciEFwDataArray[0]};\r\nu32 firmware_img_len[3] = { sizeof(Rtl8192PciEFwBootArray),\r\nsizeof(Rtl8192PciEFwMainArray),\r\nsizeof(Rtl8192PciEFwDataArray)};\r\nu32 file_length = 0;\r\nu8 *mapped_file = NULL;\r\nu8 init_step = 0;\r\nenum opt_rst_type rst_opt = OPT_SYSTEM_RESET;\r\nenum firmware_init_step starting_state = FW_INIT_STEP0_BOOT;\r\nstruct rt_firmware *pfirmware = priv->pFirmware;\r\nRT_TRACE(COMP_FIRMWARE, " PlatformInitFirmware()==>\n");\r\nif (pfirmware->firmware_status == FW_STATUS_0_INIT) {\r\nrst_opt = OPT_SYSTEM_RESET;\r\nstarting_state = FW_INIT_STEP0_BOOT;\r\n} else if (pfirmware->firmware_status == FW_STATUS_5_READY) {\r\nrst_opt = OPT_FIRMWARE_RESET;\r\nstarting_state = FW_INIT_STEP2_DATA;\r\n} else {\r\nRT_TRACE(COMP_FIRMWARE, "PlatformInitFirmware: undefined"\r\n" firmware state\n");\r\n}\r\npriv->firmware_source = FW_SOURCE_IMG_FILE;\r\nfor (init_step = starting_state; init_step <= FW_INIT_STEP2_DATA;\r\ninit_step++) {\r\nif (rst_opt == OPT_SYSTEM_RESET) {\r\nswitch (priv->firmware_source) {\r\ncase FW_SOURCE_IMG_FILE:\r\n{\r\nif (pfirmware->firmware_buf_size[init_step] == 0) {\r\nconst char *fw_name[3] = { "RTL8192E/boot.img",\r\n"RTL8192E/main.img",\r\n"RTL8192E/data.img"\r\n};\r\nconst struct firmware *fw_entry;\r\nint rc;\r\nrc = request_firmware(&fw_entry,\r\nfw_name[init_step], &priv->pdev->dev);\r\nif (rc < 0) {\r\nRT_TRACE(COMP_FIRMWARE, "request firm"\r\n"ware fail!\n");\r\ngoto download_firmware_fail;\r\n}\r\nif (fw_entry->size >\r\nsizeof(pfirmware->firmware_buf[init_step])) {\r\nRT_TRACE(COMP_FIRMWARE, "img file size "\r\n"exceed the container struct "\r\n"buffer fail!\n");\r\ngoto download_firmware_fail;\r\n}\r\nif (init_step != FW_INIT_STEP1_MAIN) {\r\nmemcpy(pfirmware->firmware_buf[init_step],\r\nfw_entry->data, fw_entry->size);\r\npfirmware->firmware_buf_size[init_step] =\r\nfw_entry->size;\r\n} else {\r\nmemset(pfirmware->firmware_buf[init_step],\r\n0, 128);\r\nmemcpy(&pfirmware->firmware_buf[init_step][128],\r\nfw_entry->data, fw_entry->size);\r\npfirmware->firmware_buf_size[init_step] =\r\nfw_entry->size + 128;\r\n}\r\nif (rst_opt == OPT_SYSTEM_RESET)\r\nrelease_firmware(fw_entry);\r\n}\r\nmapped_file = pfirmware->firmware_buf[init_step];\r\nfile_length = pfirmware->firmware_buf_size[init_step];\r\nbreak;\r\n}\r\ncase FW_SOURCE_HEADER_FILE:\r\nmapped_file = firmware_img_buf[init_step];\r\nfile_length = firmware_img_len[init_step];\r\nif (init_step == FW_INIT_STEP2_DATA) {\r\nmemcpy(pfirmware->firmware_buf[init_step], mapped_file, file_length);\r\npfirmware->firmware_buf_size[init_step] = file_length;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else if (rst_opt == OPT_FIRMWARE_RESET) {\r\nmapped_file = pfirmware->firmware_buf[init_step];\r\nfile_length = pfirmware->firmware_buf_size[init_step];\r\n}\r\nrt_status = fw_download_code(dev, mapped_file, file_length);\r\nif (rt_status != true) {\r\ngoto download_firmware_fail;\r\n}\r\nif (!firmware_check_ready(dev, init_step)) {\r\ngoto download_firmware_fail;\r\n}\r\n}\r\nRT_TRACE(COMP_FIRMWARE, "Firmware Download Success\n");\r\nreturn rt_status;\r\ndownload_firmware_fail:\r\nRT_TRACE(COMP_ERR, "ERR in %s()\n", __func__);\r\nrt_status = false;\r\nreturn rt_status;\r\n}
