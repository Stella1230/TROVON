static int load_cpu_fw_direct(const char *fn, u8 __iomem *mem, struct cx18 *cx)\r\n{\r\nconst struct firmware *fw = NULL;\r\nint i, j;\r\nunsigned size;\r\nu32 __iomem *dst = (u32 __iomem *)mem;\r\nconst u32 *src;\r\nif (request_firmware(&fw, fn, &cx->pci_dev->dev)) {\r\nCX18_ERR("Unable to open firmware %s\n", fn);\r\nCX18_ERR("Did you put the firmware in the hotplug firmware directory?\n");\r\nreturn -ENOMEM;\r\n}\r\nsrc = (const u32 *)fw->data;\r\nfor (i = 0; i < fw->size; i += 4096) {\r\ncx18_setup_page(cx, i);\r\nfor (j = i; j < fw->size && j < i + 4096; j += 4) {\r\ncx18_raw_writel(cx, *src, dst);\r\nif (cx18_raw_readl(cx, dst) != *src) {\r\nCX18_ERR("Mismatch at offset %x\n", i);\r\nrelease_firmware(fw);\r\ncx18_setup_page(cx, 0);\r\nreturn -EIO;\r\n}\r\ndst++;\r\nsrc++;\r\n}\r\n}\r\nif (!test_bit(CX18_F_I_LOADED_FW, &cx->i_flags))\r\nCX18_INFO("loaded %s firmware (%zd bytes)\n", fn, fw->size);\r\nsize = fw->size;\r\nrelease_firmware(fw);\r\ncx18_setup_page(cx, SCB_OFFSET);\r\nreturn size;\r\n}\r\nstatic int load_apu_fw_direct(const char *fn, u8 __iomem *dst, struct cx18 *cx,\r\nu32 *entry_addr)\r\n{\r\nconst struct firmware *fw = NULL;\r\nint i, j;\r\nunsigned size;\r\nconst u32 *src;\r\nstruct cx18_apu_rom_seghdr seghdr;\r\nconst u8 *vers;\r\nu32 offset = 0;\r\nu32 apu_version = 0;\r\nint sz;\r\nif (request_firmware(&fw, fn, &cx->pci_dev->dev)) {\r\nCX18_ERR("unable to open firmware %s\n", fn);\r\nCX18_ERR("did you put the firmware in the hotplug firmware directory?\n");\r\ncx18_setup_page(cx, 0);\r\nreturn -ENOMEM;\r\n}\r\n*entry_addr = 0;\r\nsrc = (const u32 *)fw->data;\r\nvers = fw->data + sizeof(seghdr);\r\nsz = fw->size;\r\napu_version = (vers[0] << 24) | (vers[4] << 16) | vers[32];\r\nwhile (offset + sizeof(seghdr) < fw->size) {\r\nmemcpy(&seghdr, src + offset / 4, sizeof(seghdr));\r\noffset += sizeof(seghdr);\r\nif (seghdr.sync1 != APU_ROM_SYNC1 ||\r\nseghdr.sync2 != APU_ROM_SYNC2) {\r\noffset += seghdr.size;\r\ncontinue;\r\n}\r\nCX18_DEBUG_INFO("load segment %x-%x\n", seghdr.addr,\r\nseghdr.addr + seghdr.size - 1);\r\nif (*entry_addr == 0)\r\n*entry_addr = seghdr.addr;\r\nif (offset + seghdr.size > sz)\r\nbreak;\r\nfor (i = 0; i < seghdr.size; i += 4096) {\r\ncx18_setup_page(cx, seghdr.addr + i);\r\nfor (j = i; j < seghdr.size && j < i + 4096; j += 4) {\r\ncx18_raw_writel(cx, src[(offset + j) / 4],\r\ndst + seghdr.addr + j);\r\nif (cx18_raw_readl(cx, dst + seghdr.addr + j)\r\n!= src[(offset + j) / 4]) {\r\nCX18_ERR("Mismatch at offset %x\n",\r\noffset + j);\r\nrelease_firmware(fw);\r\ncx18_setup_page(cx, 0);\r\nreturn -EIO;\r\n}\r\n}\r\n}\r\noffset += seghdr.size;\r\n}\r\nif (!test_bit(CX18_F_I_LOADED_FW, &cx->i_flags))\r\nCX18_INFO("loaded %s firmware V%08x (%zd bytes)\n",\r\nfn, apu_version, fw->size);\r\nsize = fw->size;\r\nrelease_firmware(fw);\r\ncx18_setup_page(cx, 0);\r\nreturn size;\r\n}\r\nvoid cx18_halt_firmware(struct cx18 *cx)\r\n{\r\nCX18_DEBUG_INFO("Preparing for firmware halt.\n");\r\ncx18_write_reg_expect(cx, 0x000F000F, CX18_PROC_SOFT_RESET,\r\n0x0000000F, 0x000F000F);\r\ncx18_write_reg_expect(cx, 0x00020002, CX18_ADEC_CONTROL,\r\n0x00000002, 0x00020002);\r\n}\r\nvoid cx18_init_power(struct cx18 *cx, int lowpwr)\r\n{\r\ncx18_write_reg(cx, 0x00000008, CX18_PLL_POWER_DOWN);\r\ncx18_write_reg_expect(cx, 0x00020000, CX18_ADEC_CONTROL,\r\n0x00000000, 0x00020002);\r\ncx18_write_reg(cx, lowpwr ? 0xD : 0x11, CX18_FAST_CLOCK_PLL_INT);\r\ncx18_write_reg(cx, lowpwr ? 0x1EFBF37 : 0x038E3D7,\r\nCX18_FAST_CLOCK_PLL_FRAC);\r\ncx18_write_reg(cx, 2, CX18_FAST_CLOCK_PLL_POST);\r\ncx18_write_reg(cx, 1, CX18_FAST_CLOCK_PLL_PRESCALE);\r\ncx18_write_reg(cx, 4, CX18_FAST_CLOCK_PLL_ADJUST_BANDWIDTH);\r\ncx18_write_reg(cx, lowpwr ? 0xD : 0xC, CX18_SLOW_CLOCK_PLL_INT);\r\ncx18_write_reg(cx, lowpwr ? 0x30C344 : 0x124927F,\r\nCX18_SLOW_CLOCK_PLL_FRAC);\r\ncx18_write_reg(cx, 3, CX18_SLOW_CLOCK_PLL_POST);\r\ncx18_write_reg(cx, 0xF, CX18_MPEG_CLOCK_PLL_INT);\r\ncx18_write_reg(cx, 0x2BE2FE, CX18_MPEG_CLOCK_PLL_FRAC);\r\ncx18_write_reg(cx, 8, CX18_MPEG_CLOCK_PLL_POST);\r\nif (lowpwr) {\r\ncx18_write_reg_expect(cx, 0xFFFF0020, CX18_CLOCK_SELECT1,\r\n0x00000020, 0xFFFFFFFF);\r\ncx18_write_reg_expect(cx, 0xFFFF0004, CX18_CLOCK_SELECT2,\r\n0x00000004, 0xFFFFFFFF);\r\n} else {\r\ncx18_write_reg_expect(cx, 0x00060004, CX18_CLOCK_SELECT1,\r\n0x00000004, 0x00060006);\r\ncx18_write_reg_expect(cx, 0x00060006, CX18_CLOCK_SELECT2,\r\n0x00000006, 0x00060006);\r\n}\r\ncx18_write_reg_expect(cx, 0xFFFF0002, CX18_HALF_CLOCK_SELECT1,\r\n0x00000002, 0xFFFFFFFF);\r\ncx18_write_reg_expect(cx, 0xFFFF0104, CX18_HALF_CLOCK_SELECT2,\r\n0x00000104, 0xFFFFFFFF);\r\ncx18_write_reg_expect(cx, 0xFFFF9026, CX18_CLOCK_ENABLE1,\r\n0x00009026, 0xFFFFFFFF);\r\ncx18_write_reg_expect(cx, 0xFFFF3105, CX18_CLOCK_ENABLE2,\r\n0x00003105, 0xFFFFFFFF);\r\n}\r\nvoid cx18_init_memory(struct cx18 *cx)\r\n{\r\ncx18_msleep_timeout(10, 0);\r\ncx18_write_reg_expect(cx, 0x00010000, CX18_DDR_SOFT_RESET,\r\n0x00000000, 0x00010001);\r\ncx18_msleep_timeout(10, 0);\r\ncx18_write_reg(cx, cx->card->ddr.chip_config, CX18_DDR_CHIP_CONFIG);\r\ncx18_msleep_timeout(10, 0);\r\ncx18_write_reg(cx, cx->card->ddr.refresh, CX18_DDR_REFRESH);\r\ncx18_write_reg(cx, cx->card->ddr.timing1, CX18_DDR_TIMING1);\r\ncx18_write_reg(cx, cx->card->ddr.timing2, CX18_DDR_TIMING2);\r\ncx18_msleep_timeout(10, 0);\r\ncx18_write_reg(cx, cx->card->ddr.tune_lane, CX18_DDR_TUNE_LANE);\r\ncx18_write_reg(cx, cx->card->ddr.initial_emrs, CX18_DDR_INITIAL_EMRS);\r\ncx18_msleep_timeout(10, 0);\r\ncx18_write_reg_expect(cx, 0x00020000, CX18_DDR_SOFT_RESET,\r\n0x00000000, 0x00020002);\r\ncx18_msleep_timeout(10, 0);\r\ncx18_write_reg(cx, 0x00000010, CX18_DDR_POWER_REG);\r\ncx18_write_reg_expect(cx, 0x00010001, CX18_REG_BUS_TIMEOUT_EN,\r\n0x00000001, 0x00010001);\r\ncx18_write_reg(cx, 0x48, CX18_DDR_MB_PER_ROW_7);\r\ncx18_write_reg(cx, 0xE0000, CX18_DDR_BASE_63_ADDR);\r\ncx18_write_reg(cx, 0x00000101, CX18_WMB_CLIENT02);\r\ncx18_write_reg(cx, 0x00000101, CX18_WMB_CLIENT09);\r\ncx18_write_reg(cx, 0x00000101, CX18_WMB_CLIENT05);\r\ncx18_write_reg(cx, 0x00000101, CX18_WMB_CLIENT06);\r\ncx18_write_reg(cx, 0x00000101, CX18_WMB_CLIENT07);\r\ncx18_write_reg(cx, 0x00000101, CX18_WMB_CLIENT10);\r\ncx18_write_reg(cx, 0x00000101, CX18_WMB_CLIENT12);\r\ncx18_write_reg(cx, 0x00000101, CX18_WMB_CLIENT13);\r\ncx18_write_reg(cx, 0x00000101, CX18_WMB_CLIENT11);\r\ncx18_write_reg(cx, 0x00000101, CX18_WMB_CLIENT14);\r\n}\r\nint cx18_firmware_init(struct cx18 *cx)\r\n{\r\nu32 fw_entry_addr;\r\nint sz, retries;\r\nu32 api_args[MAX_MB_ARGUMENTS];\r\ncx18_write_reg(cx, 0x5, CX18_DSP0_INTERRUPT_MASK);\r\ncx18_write_reg_expect(cx, 0x000F000F, CX18_PROC_SOFT_RESET,\r\n0x0000000F, 0x000F000F);\r\ncx18_msleep_timeout(1, 0);\r\nif ((cx18_read_reg(cx, CX18_PROC_SOFT_RESET) & 8) == 0) {\r\nCX18_ERR("%s: couldn't stop CPU to load firmware\n", __func__);\r\nreturn -EIO;\r\n}\r\ncx18_sw1_irq_enable(cx, IRQ_CPU_TO_EPU | IRQ_APU_TO_EPU);\r\ncx18_sw2_irq_enable(cx, IRQ_CPU_TO_EPU_ACK | IRQ_APU_TO_EPU_ACK);\r\nsz = load_cpu_fw_direct("v4l-cx23418-cpu.fw", cx->enc_mem, cx);\r\nif (sz <= 0)\r\nreturn sz;\r\ncx18_init_scb(cx);\r\nfw_entry_addr = 0;\r\nsz = load_apu_fw_direct("v4l-cx23418-apu.fw", cx->enc_mem, cx,\r\n&fw_entry_addr);\r\nif (sz <= 0)\r\nreturn sz;\r\ncx18_write_reg_expect(cx, 0x00080000, CX18_PROC_SOFT_RESET,\r\n0x00000000, 0x00080008);\r\nfor (retries = 0;\r\nretries < 50 && (cx18_read_reg(cx, CX18_PROC_SOFT_RESET) & 1) == 1;\r\nretries++)\r\ncx18_msleep_timeout(10, 0);\r\ncx18_msleep_timeout(200, 0);\r\nif (retries == 50 &&\r\n(cx18_read_reg(cx, CX18_PROC_SOFT_RESET) & 1) == 1) {\r\nCX18_ERR("Could not start the CPU\n");\r\nreturn -EIO;\r\n}\r\ncx18_sw2_irq_disable_cpu(cx, IRQ_CPU_TO_EPU_ACK | IRQ_APU_TO_EPU_ACK);\r\nsz = cx18_vapi_result(cx, api_args, CX18_CPU_DEBUG_PEEK32, 1, 0);\r\nif (sz < 0)\r\nreturn sz;\r\ncx18_write_reg_expect(cx, 0x14001400, 0xc78110, 0x00001400, 0x14001400);\r\nreturn 0;\r\n}
