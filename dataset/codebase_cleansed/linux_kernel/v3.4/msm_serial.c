static inline void wait_for_xmitr(struct uart_port *port, int bits)\r\n{\r\nif (!(msm_read(port, UART_SR) & UART_SR_TX_EMPTY))\r\nwhile ((msm_read(port, UART_ISR) & bits) != bits)\r\ncpu_relax();\r\n}\r\nstatic void msm_stop_tx(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nmsm_port->imr &= ~UART_IMR_TXLEV;\r\nmsm_write(port, msm_port->imr, UART_IMR);\r\n}\r\nstatic void msm_start_tx(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nmsm_port->imr |= UART_IMR_TXLEV;\r\nmsm_write(port, msm_port->imr, UART_IMR);\r\n}\r\nstatic void msm_stop_rx(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nmsm_port->imr &= ~(UART_IMR_RXLEV | UART_IMR_RXSTALE);\r\nmsm_write(port, msm_port->imr, UART_IMR);\r\n}\r\nstatic void msm_enable_ms(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nmsm_port->imr |= UART_IMR_DELTA_CTS;\r\nmsm_write(port, msm_port->imr, UART_IMR);\r\n}\r\nstatic void handle_rx_dm(struct uart_port *port, unsigned int misr)\r\n{\r\nstruct tty_struct *tty = port->state->port.tty;\r\nunsigned int sr;\r\nint count = 0;\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nif ((msm_read(port, UART_SR) & UART_SR_OVERRUN)) {\r\nport->icount.overrun++;\r\ntty_insert_flip_char(tty, 0, TTY_OVERRUN);\r\nmsm_write(port, UART_CR_CMD_RESET_ERR, UART_CR);\r\n}\r\nif (misr & UART_IMR_RXSTALE) {\r\ncount = msm_read(port, UARTDM_RX_TOTAL_SNAP) -\r\nmsm_port->old_snap_state;\r\nmsm_port->old_snap_state = 0;\r\n} else {\r\ncount = 4 * (msm_read(port, UART_RFWR));\r\nmsm_port->old_snap_state += count;\r\n}\r\nport->icount.rx += count;\r\nwhile (count > 0) {\r\nunsigned int c;\r\nsr = msm_read(port, UART_SR);\r\nif ((sr & UART_SR_RX_READY) == 0) {\r\nmsm_port->old_snap_state -= count;\r\nbreak;\r\n}\r\nc = msm_read(port, UARTDM_RF);\r\nif (sr & UART_SR_RX_BREAK) {\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ncontinue;\r\n} else if (sr & UART_SR_PAR_FRAME_ERR)\r\nport->icount.frame++;\r\ntty_insert_flip_string(tty, (char *) &c,\r\n(count > 4) ? 4 : count);\r\ncount -= 4;\r\n}\r\ntty_flip_buffer_push(tty);\r\nif (misr & (UART_IMR_RXSTALE))\r\nmsm_write(port, UART_CR_CMD_RESET_STALE_INT, UART_CR);\r\nmsm_write(port, 0xFFFFFF, UARTDM_DMRX);\r\nmsm_write(port, UART_CR_CMD_STALE_EVENT_ENABLE, UART_CR);\r\n}\r\nstatic void handle_rx(struct uart_port *port)\r\n{\r\nstruct tty_struct *tty = port->state->port.tty;\r\nunsigned int sr;\r\nif ((msm_read(port, UART_SR) & UART_SR_OVERRUN)) {\r\nport->icount.overrun++;\r\ntty_insert_flip_char(tty, 0, TTY_OVERRUN);\r\nmsm_write(port, UART_CR_CMD_RESET_ERR, UART_CR);\r\n}\r\nwhile ((sr = msm_read(port, UART_SR)) & UART_SR_RX_READY) {\r\nunsigned int c;\r\nchar flag = TTY_NORMAL;\r\nc = msm_read(port, UART_RF);\r\nif (sr & UART_SR_RX_BREAK) {\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ncontinue;\r\n} else if (sr & UART_SR_PAR_FRAME_ERR) {\r\nport->icount.frame++;\r\n} else {\r\nport->icount.rx++;\r\n}\r\nsr &= port->read_status_mask;\r\nif (sr & UART_SR_RX_BREAK) {\r\nflag = TTY_BREAK;\r\n} else if (sr & UART_SR_PAR_FRAME_ERR) {\r\nflag = TTY_FRAME;\r\n}\r\nif (!uart_handle_sysrq_char(port, c))\r\ntty_insert_flip_char(tty, c, flag);\r\n}\r\ntty_flip_buffer_push(tty);\r\n}\r\nstatic void reset_dm_count(struct uart_port *port)\r\n{\r\nwait_for_xmitr(port, UART_ISR_TX_READY);\r\nmsm_write(port, 1, UARTDM_NCF_TX);\r\n}\r\nstatic void handle_tx(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nint sent_tx;\r\nif (port->x_char) {\r\nif (msm_port->is_uartdm)\r\nreset_dm_count(port);\r\nmsm_write(port, port->x_char,\r\nmsm_port->is_uartdm ? UARTDM_TF : UART_TF);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\n}\r\nif (msm_port->is_uartdm)\r\nreset_dm_count(port);\r\nwhile (msm_read(port, UART_SR) & UART_SR_TX_READY) {\r\nif (uart_circ_empty(xmit)) {\r\nmsm_port->imr &= ~UART_IMR_TXLEV;\r\nmsm_write(port, msm_port->imr, UART_IMR);\r\nbreak;\r\n}\r\nmsm_write(port, xmit->buf[xmit->tail],\r\nmsm_port->is_uartdm ? UARTDM_TF : UART_TF);\r\nif (msm_port->is_uartdm)\r\nreset_dm_count(port);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\nsent_tx = 1;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\n}\r\nstatic void handle_delta_cts(struct uart_port *port)\r\n{\r\nmsm_write(port, UART_CR_CMD_RESET_CTS, UART_CR);\r\nport->icount.cts++;\r\nwake_up_interruptible(&port->state->port.delta_msr_wait);\r\n}\r\nstatic irqreturn_t msm_irq(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nunsigned int misr;\r\nspin_lock(&port->lock);\r\nmisr = msm_read(port, UART_MISR);\r\nmsm_write(port, 0, UART_IMR);\r\nif (misr & (UART_IMR_RXLEV | UART_IMR_RXSTALE)) {\r\nif (msm_port->is_uartdm)\r\nhandle_rx_dm(port, misr);\r\nelse\r\nhandle_rx(port);\r\n}\r\nif (misr & UART_IMR_TXLEV)\r\nhandle_tx(port);\r\nif (misr & UART_IMR_DELTA_CTS)\r\nhandle_delta_cts(port);\r\nmsm_write(port, msm_port->imr, UART_IMR);\r\nspin_unlock(&port->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int msm_tx_empty(struct uart_port *port)\r\n{\r\nreturn (msm_read(port, UART_SR) & UART_SR_TX_EMPTY) ? TIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int msm_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CAR | TIOCM_CTS | TIOCM_DSR | TIOCM_RTS;\r\n}\r\nstatic void msm_reset(struct uart_port *port)\r\n{\r\nmsm_write(port, UART_CR_CMD_RESET_RX, UART_CR);\r\nmsm_write(port, UART_CR_CMD_RESET_TX, UART_CR);\r\nmsm_write(port, UART_CR_CMD_RESET_ERR, UART_CR);\r\nmsm_write(port, UART_CR_CMD_RESET_BREAK_INT, UART_CR);\r\nmsm_write(port, UART_CR_CMD_RESET_CTS, UART_CR);\r\nmsm_write(port, UART_CR_CMD_SET_RFR, UART_CR);\r\n}\r\nvoid msm_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nunsigned int mr;\r\nmr = msm_read(port, UART_MR1);\r\nif (!(mctrl & TIOCM_RTS)) {\r\nmr &= ~UART_MR1_RX_RDY_CTL;\r\nmsm_write(port, mr, UART_MR1);\r\nmsm_write(port, UART_CR_CMD_RESET_RFR, UART_CR);\r\n} else {\r\nmr |= UART_MR1_RX_RDY_CTL;\r\nmsm_write(port, mr, UART_MR1);\r\n}\r\n}\r\nstatic void msm_break_ctl(struct uart_port *port, int break_ctl)\r\n{\r\nif (break_ctl)\r\nmsm_write(port, UART_CR_CMD_START_BREAK, UART_CR);\r\nelse\r\nmsm_write(port, UART_CR_CMD_STOP_BREAK, UART_CR);\r\n}\r\nstatic int msm_set_baud_rate(struct uart_port *port, unsigned int baud)\r\n{\r\nunsigned int baud_code, rxstale, watermark;\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nswitch (baud) {\r\ncase 300:\r\nbaud_code = UART_CSR_300;\r\nrxstale = 1;\r\nbreak;\r\ncase 600:\r\nbaud_code = UART_CSR_600;\r\nrxstale = 1;\r\nbreak;\r\ncase 1200:\r\nbaud_code = UART_CSR_1200;\r\nrxstale = 1;\r\nbreak;\r\ncase 2400:\r\nbaud_code = UART_CSR_2400;\r\nrxstale = 1;\r\nbreak;\r\ncase 4800:\r\nbaud_code = UART_CSR_4800;\r\nrxstale = 1;\r\nbreak;\r\ncase 9600:\r\nbaud_code = UART_CSR_9600;\r\nrxstale = 2;\r\nbreak;\r\ncase 14400:\r\nbaud_code = UART_CSR_14400;\r\nrxstale = 3;\r\nbreak;\r\ncase 19200:\r\nbaud_code = UART_CSR_19200;\r\nrxstale = 4;\r\nbreak;\r\ncase 28800:\r\nbaud_code = UART_CSR_28800;\r\nrxstale = 6;\r\nbreak;\r\ncase 38400:\r\nbaud_code = UART_CSR_38400;\r\nrxstale = 8;\r\nbreak;\r\ncase 57600:\r\nbaud_code = UART_CSR_57600;\r\nrxstale = 16;\r\nbreak;\r\ncase 115200:\r\ndefault:\r\nbaud_code = UART_CSR_115200;\r\nbaud = 115200;\r\nrxstale = 31;\r\nbreak;\r\n}\r\nif (msm_port->is_uartdm)\r\nmsm_write(port, UART_CR_CMD_RESET_RX, UART_CR);\r\nmsm_write(port, baud_code, UART_CSR);\r\nwatermark = UART_IPR_STALE_LSB & rxstale;\r\nwatermark |= UART_IPR_RXSTALE_LAST;\r\nwatermark |= UART_IPR_STALE_TIMEOUT_MSB & (rxstale << 2);\r\nmsm_write(port, watermark, UART_IPR);\r\nwatermark = (port->fifosize * 3) / 4;\r\nmsm_write(port, watermark, UART_RFWR);\r\nmsm_write(port, 10, UART_TFWR);\r\nif (msm_port->is_uartdm) {\r\nmsm_write(port, UART_CR_CMD_RESET_STALE_INT, UART_CR);\r\nmsm_write(port, 0xFFFFFF, UARTDM_DMRX);\r\nmsm_write(port, UART_CR_CMD_STALE_EVENT_ENABLE, UART_CR);\r\n}\r\nreturn baud;\r\n}\r\nstatic void msm_init_clock(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nclk_enable(msm_port->clk);\r\nif (!IS_ERR(msm_port->pclk))\r\nclk_enable(msm_port->pclk);\r\nmsm_serial_set_mnd_regs(port);\r\n}\r\nstatic int msm_startup(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nunsigned int data, rfr_level;\r\nint ret;\r\nsnprintf(msm_port->name, sizeof(msm_port->name),\r\n"msm_serial%d", port->line);\r\nret = request_irq(port->irq, msm_irq, IRQF_TRIGGER_HIGH,\r\nmsm_port->name, port);\r\nif (unlikely(ret))\r\nreturn ret;\r\nmsm_init_clock(port);\r\nif (likely(port->fifosize > 12))\r\nrfr_level = port->fifosize - 12;\r\nelse\r\nrfr_level = port->fifosize;\r\ndata = msm_read(port, UART_MR1);\r\ndata &= ~UART_MR1_AUTO_RFR_LEVEL1;\r\ndata &= ~UART_MR1_AUTO_RFR_LEVEL0;\r\ndata |= UART_MR1_AUTO_RFR_LEVEL1 & (rfr_level << 2);\r\ndata |= UART_MR1_AUTO_RFR_LEVEL0 & rfr_level;\r\nmsm_write(port, data, UART_MR1);\r\ndata = msm_read(port, UART_IPR);\r\nif (unlikely(!data)) {\r\ndata |= UART_IPR_RXSTALE_LAST;\r\ndata |= UART_IPR_STALE_LSB;\r\nmsm_write(port, data, UART_IPR);\r\n}\r\ndata = 0;\r\nif (!port->cons || (port->cons && !(port->cons->flags & CON_ENABLED))) {\r\nmsm_write(port, UART_CR_CMD_PROTECTION_EN, UART_CR);\r\nmsm_reset(port);\r\ndata = UART_CR_TX_ENABLE;\r\n}\r\ndata |= UART_CR_RX_ENABLE;\r\nmsm_write(port, data, UART_CR);\r\nif (msm_port->is_uartdm)\r\nmsm_write(port, UART_IPR_STALE_LSB, UART_IPR);\r\nmsm_port->imr = UART_IMR_RXLEV | UART_IMR_RXSTALE |\r\nUART_IMR_CURRENT_CTS;\r\nif (msm_port->is_uartdm) {\r\nmsm_write(port, 0xFFFFFF, UARTDM_DMRX);\r\nmsm_write(port, UART_CR_CMD_RESET_STALE_INT, UART_CR);\r\nmsm_write(port, UART_CR_CMD_STALE_EVENT_ENABLE, UART_CR);\r\n}\r\nmsm_write(port, msm_port->imr, UART_IMR);\r\nreturn 0;\r\n}\r\nstatic void msm_shutdown(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nmsm_port->imr = 0;\r\nmsm_write(port, 0, UART_IMR);\r\nclk_disable(msm_port->clk);\r\nfree_irq(port->irq, port);\r\n}\r\nstatic void msm_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned long flags;\r\nunsigned int baud, mr;\r\nspin_lock_irqsave(&port->lock, flags);\r\nbaud = uart_get_baud_rate(port, termios, old, 300, 115200);\r\nbaud = msm_set_baud_rate(port, baud);\r\nif (tty_termios_baud_rate(termios))\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\nmr = msm_read(port, UART_MR2);\r\nmr &= ~UART_MR2_PARITY_MODE;\r\nif (termios->c_cflag & PARENB) {\r\nif (termios->c_cflag & PARODD)\r\nmr |= UART_MR2_PARITY_MODE_ODD;\r\nelse if (termios->c_cflag & CMSPAR)\r\nmr |= UART_MR2_PARITY_MODE_SPACE;\r\nelse\r\nmr |= UART_MR2_PARITY_MODE_EVEN;\r\n}\r\nmr &= ~UART_MR2_BITS_PER_CHAR;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nmr |= UART_MR2_BITS_PER_CHAR_5;\r\nbreak;\r\ncase CS6:\r\nmr |= UART_MR2_BITS_PER_CHAR_6;\r\nbreak;\r\ncase CS7:\r\nmr |= UART_MR2_BITS_PER_CHAR_7;\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nmr |= UART_MR2_BITS_PER_CHAR_8;\r\nbreak;\r\n}\r\nmr &= ~(UART_MR2_STOP_BIT_LEN_ONE | UART_MR2_STOP_BIT_LEN_TWO);\r\nif (termios->c_cflag & CSTOPB)\r\nmr |= UART_MR2_STOP_BIT_LEN_TWO;\r\nelse\r\nmr |= UART_MR2_STOP_BIT_LEN_ONE;\r\nmsm_write(port, mr, UART_MR2);\r\nmr = msm_read(port, UART_MR1);\r\nmr &= ~(UART_MR1_CTS_CTL | UART_MR1_RX_RDY_CTL);\r\nif (termios->c_cflag & CRTSCTS) {\r\nmr |= UART_MR1_CTS_CTL;\r\nmr |= UART_MR1_RX_RDY_CTL;\r\n}\r\nmsm_write(port, mr, UART_MR1);\r\nport->read_status_mask = 0;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= UART_SR_PAR_FRAME_ERR;\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nport->read_status_mask |= UART_SR_RX_BREAK;\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *msm_type(struct uart_port *port)\r\n{\r\nreturn "MSM";\r\n}\r\nstatic void msm_release_port(struct uart_port *port)\r\n{\r\nstruct platform_device *pdev = to_platform_device(port->dev);\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nstruct resource *uart_resource;\r\nstruct resource *gsbi_resource;\r\nresource_size_t size;\r\nuart_resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(!uart_resource))\r\nreturn;\r\nsize = resource_size(uart_resource);\r\nrelease_mem_region(port->mapbase, size);\r\niounmap(port->membase);\r\nport->membase = NULL;\r\nif (msm_port->gsbi_base) {\r\niowrite32(GSBI_PROTOCOL_IDLE, msm_port->gsbi_base +\r\nGSBI_CONTROL);\r\ngsbi_resource = platform_get_resource(pdev,\r\nIORESOURCE_MEM, 1);\r\nif (unlikely(!gsbi_resource))\r\nreturn;\r\nsize = resource_size(gsbi_resource);\r\nrelease_mem_region(gsbi_resource->start, size);\r\niounmap(msm_port->gsbi_base);\r\nmsm_port->gsbi_base = NULL;\r\n}\r\n}\r\nstatic int msm_request_port(struct uart_port *port)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nstruct platform_device *pdev = to_platform_device(port->dev);\r\nstruct resource *uart_resource;\r\nstruct resource *gsbi_resource;\r\nresource_size_t size;\r\nint ret;\r\nuart_resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(!uart_resource))\r\nreturn -ENXIO;\r\nsize = resource_size(uart_resource);\r\nif (!request_mem_region(port->mapbase, size, "msm_serial"))\r\nreturn -EBUSY;\r\nport->membase = ioremap(port->mapbase, size);\r\nif (!port->membase) {\r\nret = -EBUSY;\r\ngoto fail_release_port;\r\n}\r\ngsbi_resource = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (gsbi_resource) {\r\nsize = resource_size(gsbi_resource);\r\nif (!request_mem_region(gsbi_resource->start, size,\r\n"msm_serial")) {\r\nret = -EBUSY;\r\ngoto fail_release_port;\r\n}\r\nmsm_port->gsbi_base = ioremap(gsbi_resource->start, size);\r\nif (!msm_port->gsbi_base) {\r\nret = -EBUSY;\r\ngoto fail_release_gsbi;\r\n}\r\n}\r\nreturn 0;\r\nfail_release_gsbi:\r\nrelease_mem_region(gsbi_resource->start, size);\r\nfail_release_port:\r\nrelease_mem_region(port->mapbase, size);\r\nreturn ret;\r\n}\r\nstatic void msm_config_port(struct uart_port *port, int flags)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nint ret;\r\nif (flags & UART_CONFIG_TYPE) {\r\nport->type = PORT_MSM;\r\nret = msm_request_port(port);\r\nif (ret)\r\nreturn;\r\n}\r\nif (msm_port->is_uartdm)\r\niowrite32(GSBI_PROTOCOL_UART, msm_port->gsbi_base +\r\nGSBI_CONTROL);\r\n}\r\nstatic int msm_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nif (unlikely(ser->type != PORT_UNKNOWN && ser->type != PORT_MSM))\r\nreturn -EINVAL;\r\nif (unlikely(port->irq != ser->irq))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void msm_power(struct uart_port *port, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nswitch (state) {\r\ncase 0:\r\nclk_enable(msm_port->clk);\r\nif (!IS_ERR(msm_port->pclk))\r\nclk_enable(msm_port->pclk);\r\nbreak;\r\ncase 3:\r\nclk_disable(msm_port->clk);\r\nif (!IS_ERR(msm_port->pclk))\r\nclk_disable(msm_port->pclk);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "msm_serial: Unknown PM state %d\n", state);\r\n}\r\n}\r\nstatic inline struct uart_port *get_port_from_line(unsigned int line)\r\n{\r\nreturn &msm_uart_ports[line].uart;\r\n}\r\nstatic void msm_console_putchar(struct uart_port *port, int c)\r\n{\r\nstruct msm_port *msm_port = UART_TO_MSM(port);\r\nif (msm_port->is_uartdm)\r\nreset_dm_count(port);\r\nwhile (!(msm_read(port, UART_SR) & UART_SR_TX_READY))\r\n;\r\nmsm_write(port, c, msm_port->is_uartdm ? UARTDM_TF : UART_TF);\r\n}\r\nstatic void msm_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nstruct uart_port *port;\r\nstruct msm_port *msm_port;\r\nBUG_ON(co->index < 0 || co->index >= UART_NR);\r\nport = get_port_from_line(co->index);\r\nmsm_port = UART_TO_MSM(port);\r\nspin_lock(&port->lock);\r\nuart_console_write(port, s, count, msm_console_putchar);\r\nspin_unlock(&port->lock);\r\n}\r\nstatic int __init msm_console_setup(struct console *co, char *options)\r\n{\r\nstruct uart_port *port;\r\nstruct msm_port *msm_port;\r\nint baud, flow, bits, parity;\r\nif (unlikely(co->index >= UART_NR || co->index < 0))\r\nreturn -ENXIO;\r\nport = get_port_from_line(co->index);\r\nmsm_port = UART_TO_MSM(port);\r\nif (unlikely(!port->membase))\r\nreturn -ENXIO;\r\nmsm_init_clock(port);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nbits = 8;\r\nparity = 'n';\r\nflow = 'n';\r\nmsm_write(port, UART_MR2_BITS_PER_CHAR_8 | UART_MR2_STOP_BIT_LEN_ONE,\r\nUART_MR2);\r\nif (baud < 300 || baud > 115200)\r\nbaud = 115200;\r\nmsm_set_baud_rate(port, baud);\r\nmsm_reset(port);\r\nif (msm_port->is_uartdm) {\r\nmsm_write(port, UART_CR_CMD_PROTECTION_EN, UART_CR);\r\nmsm_write(port, UART_CR_TX_ENABLE, UART_CR);\r\n}\r\nprintk(KERN_INFO "msm_serial: console setup on port #%d\n", port->line);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init msm_serial_probe(struct platform_device *pdev)\r\n{\r\nstruct msm_port *msm_port;\r\nstruct resource *resource;\r\nstruct uart_port *port;\r\nint irq;\r\nif (pdev->id == -1)\r\npdev->id = atomic_inc_return(&msm_uart_next_id) - 1;\r\nif (unlikely(pdev->id < 0 || pdev->id >= UART_NR))\r\nreturn -ENXIO;\r\nprintk(KERN_INFO "msm_serial: detected port #%d\n", pdev->id);\r\nport = get_port_from_line(pdev->id);\r\nport->dev = &pdev->dev;\r\nmsm_port = UART_TO_MSM(port);\r\nif (platform_get_resource(pdev, IORESOURCE_MEM, 1))\r\nmsm_port->is_uartdm = 1;\r\nelse\r\nmsm_port->is_uartdm = 0;\r\nif (msm_port->is_uartdm) {\r\nmsm_port->clk = clk_get(&pdev->dev, "gsbi_uart_clk");\r\nmsm_port->pclk = clk_get(&pdev->dev, "gsbi_pclk");\r\n} else {\r\nmsm_port->clk = clk_get(&pdev->dev, "uart_clk");\r\nmsm_port->pclk = ERR_PTR(-ENOENT);\r\n}\r\nif (unlikely(IS_ERR(msm_port->clk) || (IS_ERR(msm_port->pclk) &&\r\nmsm_port->is_uartdm)))\r\nreturn PTR_ERR(msm_port->clk);\r\nif (msm_port->is_uartdm)\r\nclk_set_rate(msm_port->clk, 7372800);\r\nport->uartclk = clk_get_rate(msm_port->clk);\r\nprintk(KERN_INFO "uartclk = %d\n", port->uartclk);\r\nresource = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(!resource))\r\nreturn -ENXIO;\r\nport->mapbase = resource->start;\r\nirq = platform_get_irq(pdev, 0);\r\nif (unlikely(irq < 0))\r\nreturn -ENXIO;\r\nport->irq = irq;\r\nplatform_set_drvdata(pdev, port);\r\nreturn uart_add_one_port(&msm_uart_driver, port);\r\n}\r\nstatic int __devexit msm_serial_remove(struct platform_device *pdev)\r\n{\r\nstruct msm_port *msm_port = platform_get_drvdata(pdev);\r\nclk_put(msm_port->clk);\r\nreturn 0;\r\n}\r\nstatic int __init msm_serial_init(void)\r\n{\r\nint ret;\r\nret = uart_register_driver(&msm_uart_driver);\r\nif (unlikely(ret))\r\nreturn ret;\r\nret = platform_driver_probe(&msm_platform_driver, msm_serial_probe);\r\nif (unlikely(ret))\r\nuart_unregister_driver(&msm_uart_driver);\r\nprintk(KERN_INFO "msm_serial: driver initialized\n");\r\nreturn ret;\r\n}\r\nstatic void __exit msm_serial_exit(void)\r\n{\r\n#ifdef CONFIG_SERIAL_MSM_CONSOLE\r\nunregister_console(&msm_console);\r\n#endif\r\nplatform_driver_unregister(&msm_platform_driver);\r\nuart_unregister_driver(&msm_uart_driver);\r\n}
