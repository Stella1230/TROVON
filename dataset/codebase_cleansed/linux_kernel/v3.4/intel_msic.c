int intel_msic_reg_read(unsigned short reg, u8 *val)\r\n{\r\nreturn intel_scu_ipc_ioread8(reg, val);\r\n}\r\nint intel_msic_reg_write(unsigned short reg, u8 val)\r\n{\r\nreturn intel_scu_ipc_iowrite8(reg, val);\r\n}\r\nint intel_msic_reg_update(unsigned short reg, u8 val, u8 mask)\r\n{\r\nreturn intel_scu_ipc_update_register(reg, val, mask);\r\n}\r\nint intel_msic_bulk_read(unsigned short *reg, u8 *buf, size_t count)\r\n{\r\nif (WARN_ON(count > SCU_IPC_RWBUF_LIMIT))\r\nreturn -EINVAL;\r\nreturn intel_scu_ipc_readv(reg, buf, count);\r\n}\r\nint intel_msic_bulk_write(unsigned short *reg, u8 *buf, size_t count)\r\n{\r\nif (WARN_ON(count > SCU_IPC_RWBUF_LIMIT))\r\nreturn -EINVAL;\r\nreturn intel_scu_ipc_writev(reg, buf, count);\r\n}\r\nint intel_msic_irq_read(struct intel_msic *msic, unsigned short reg, u8 *val)\r\n{\r\nif (WARN_ON(reg < INTEL_MSIC_IRQLVL1 || reg > INTEL_MSIC_RESETIRQ2))\r\nreturn -EINVAL;\r\n*val = readb(msic->irq_base + (reg - INTEL_MSIC_IRQLVL1));\r\nreturn 0;\r\n}\r\nstatic int __devinit intel_msic_init_devices(struct intel_msic *msic)\r\n{\r\nstruct platform_device *pdev = msic->pdev;\r\nstruct intel_msic_platform_data *pdata = pdev->dev.platform_data;\r\nint ret, i;\r\nif (pdata->gpio) {\r\nstruct mfd_cell *cell = &msic_devs[INTEL_MSIC_BLOCK_GPIO];\r\ncell->platform_data = pdata->gpio;\r\ncell->pdata_size = sizeof(*pdata->gpio);\r\n}\r\nif (pdata->ocd) {\r\nunsigned gpio = pdata->ocd->gpio;\r\nret = gpio_request_one(gpio, GPIOF_IN, "ocd_gpio");\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register OCD GPIO\n");\r\nreturn ret;\r\n}\r\nret = gpio_to_irq(gpio);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "no IRQ number for OCD GPIO\n");\r\ngpio_free(gpio);\r\nreturn ret;\r\n}\r\npdata->irq[INTEL_MSIC_BLOCK_OCD] = ret;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(msic_devs); i++) {\r\nif (!pdata->irq[i])\r\ncontinue;\r\nret = mfd_add_devices(&pdev->dev, -1, &msic_devs[i], 1, NULL,\r\npdata->irq[i]);\r\nif (ret)\r\ngoto fail;\r\n}\r\nret = mfd_add_devices(&pdev->dev, 0, msic_other_devs,\r\nARRAY_SIZE(msic_other_devs), NULL, 0);\r\nif (ret)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nmfd_remove_devices(&pdev->dev);\r\nif (pdata->ocd)\r\ngpio_free(pdata->ocd->gpio);\r\nreturn ret;\r\n}\r\nstatic void __devexit intel_msic_remove_devices(struct intel_msic *msic)\r\n{\r\nstruct platform_device *pdev = msic->pdev;\r\nstruct intel_msic_platform_data *pdata = pdev->dev.platform_data;\r\nmfd_remove_devices(&pdev->dev);\r\nif (pdata->ocd)\r\ngpio_free(pdata->ocd->gpio);\r\n}\r\nstatic int __devinit intel_msic_probe(struct platform_device *pdev)\r\n{\r\nstruct intel_msic_platform_data *pdata = pdev->dev.platform_data;\r\nstruct intel_msic *msic;\r\nstruct resource *res;\r\nu8 id0, id1;\r\nint ret;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data passed\n");\r\nreturn -EINVAL;\r\n}\r\nret = intel_scu_ipc_ioread8(INTEL_MSIC_ID0, &id0);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to identify the MSIC chip (ID0)\n");\r\nreturn -ENXIO;\r\n}\r\nret = intel_scu_ipc_ioread8(INTEL_MSIC_ID1, &id1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to identify the MSIC chip (ID1)\n");\r\nreturn -ENXIO;\r\n}\r\nif (MSIC_VENDOR(id0) != MSIC_VENDOR(id1)) {\r\ndev_err(&pdev->dev, "invalid vendor ID: %x, %x\n", id0, id1);\r\nreturn -ENXIO;\r\n}\r\nmsic = kzalloc(sizeof(*msic), GFP_KERNEL);\r\nif (!msic)\r\nreturn -ENOMEM;\r\nmsic->vendor = MSIC_VENDOR(id0);\r\nmsic->version = MSIC_VERSION(id0);\r\nmsic->pdev = pdev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "failed to get SRAM iomem resource\n");\r\nret = -ENODEV;\r\ngoto fail_free_msic;\r\n}\r\nres = request_mem_region(res->start, resource_size(res), pdev->name);\r\nif (!res) {\r\nret = -EBUSY;\r\ngoto fail_free_msic;\r\n}\r\nmsic->irq_base = ioremap_nocache(res->start, resource_size(res));\r\nif (!msic->irq_base) {\r\ndev_err(&pdev->dev, "failed to map SRAM memory\n");\r\nret = -ENOMEM;\r\ngoto fail_release_region;\r\n}\r\nplatform_set_drvdata(pdev, msic);\r\nret = intel_msic_init_devices(msic);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to initialize MSIC devices\n");\r\ngoto fail_unmap_mem;\r\n}\r\ndev_info(&pdev->dev, "Intel MSIC version %c%d (vendor %#x)\n",\r\nMSIC_MAJOR(msic->version), MSIC_MINOR(msic->version),\r\nmsic->vendor);\r\nreturn 0;\r\nfail_unmap_mem:\r\niounmap(msic->irq_base);\r\nfail_release_region:\r\nrelease_mem_region(res->start, resource_size(res));\r\nfail_free_msic:\r\nkfree(msic);\r\nreturn ret;\r\n}\r\nstatic int __devexit intel_msic_remove(struct platform_device *pdev)\r\n{\r\nstruct intel_msic *msic = platform_get_drvdata(pdev);\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nintel_msic_remove_devices(msic);\r\nplatform_set_drvdata(pdev, NULL);\r\niounmap(msic->irq_base);\r\nrelease_mem_region(res->start, resource_size(res));\r\nkfree(msic);\r\nreturn 0;\r\n}
