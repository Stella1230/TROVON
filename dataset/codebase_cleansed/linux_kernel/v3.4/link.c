static int\r\nsymlink_hash(unsigned int link_len, const char *link_str, u8 *md5_hash)\r\n{\r\nint rc;\r\nunsigned int size;\r\nstruct crypto_shash *md5;\r\nstruct sdesc *sdescmd5;\r\nmd5 = crypto_alloc_shash("md5", 0, 0);\r\nif (IS_ERR(md5)) {\r\nrc = PTR_ERR(md5);\r\ncERROR(1, "%s: Crypto md5 allocation error %d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nsize = sizeof(struct shash_desc) + crypto_shash_descsize(md5);\r\nsdescmd5 = kmalloc(size, GFP_KERNEL);\r\nif (!sdescmd5) {\r\nrc = -ENOMEM;\r\ncERROR(1, "%s: Memory allocation failure\n", __func__);\r\ngoto symlink_hash_err;\r\n}\r\nsdescmd5->shash.tfm = md5;\r\nsdescmd5->shash.flags = 0x0;\r\nrc = crypto_shash_init(&sdescmd5->shash);\r\nif (rc) {\r\ncERROR(1, "%s: Could not init md5 shash\n", __func__);\r\ngoto symlink_hash_err;\r\n}\r\nrc = crypto_shash_update(&sdescmd5->shash, link_str, link_len);\r\nif (rc) {\r\ncERROR(1, "%s: Could not update iwth link_str\n", __func__);\r\ngoto symlink_hash_err;\r\n}\r\nrc = crypto_shash_final(&sdescmd5->shash, md5_hash);\r\nif (rc)\r\ncERROR(1, "%s: Could not generate md5 hash\n", __func__);\r\nsymlink_hash_err:\r\ncrypto_free_shash(md5);\r\nkfree(sdescmd5);\r\nreturn rc;\r\n}\r\nstatic int\r\nCIFSParseMFSymlink(const u8 *buf,\r\nunsigned int buf_len,\r\nunsigned int *_link_len,\r\nchar **_link_str)\r\n{\r\nint rc;\r\nunsigned int link_len;\r\nconst char *md5_str1;\r\nconst char *link_str;\r\nu8 md5_hash[16];\r\nchar md5_str2[34];\r\nif (buf_len != CIFS_MF_SYMLINK_FILE_SIZE)\r\nreturn -EINVAL;\r\nmd5_str1 = (const char *)&buf[CIFS_MF_SYMLINK_MD5_OFFSET];\r\nlink_str = (const char *)&buf[CIFS_MF_SYMLINK_LINK_OFFSET];\r\nrc = sscanf(buf, CIFS_MF_SYMLINK_LEN_FORMAT, &link_len);\r\nif (rc != 1)\r\nreturn -EINVAL;\r\nrc = symlink_hash(link_len, link_str, md5_hash);\r\nif (rc) {\r\ncFYI(1, "%s: MD5 hash failure: %d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nsnprintf(md5_str2, sizeof(md5_str2),\r\nCIFS_MF_SYMLINK_MD5_FORMAT,\r\nCIFS_MF_SYMLINK_MD5_ARGS(md5_hash));\r\nif (strncmp(md5_str1, md5_str2, 17) != 0)\r\nreturn -EINVAL;\r\nif (_link_str) {\r\n*_link_str = kstrndup(link_str, link_len, GFP_KERNEL);\r\nif (!*_link_str)\r\nreturn -ENOMEM;\r\n}\r\n*_link_len = link_len;\r\nreturn 0;\r\n}\r\nstatic int\r\nCIFSFormatMFSymlink(u8 *buf, unsigned int buf_len, const char *link_str)\r\n{\r\nint rc;\r\nunsigned int link_len;\r\nunsigned int ofs;\r\nu8 md5_hash[16];\r\nif (buf_len != CIFS_MF_SYMLINK_FILE_SIZE)\r\nreturn -EINVAL;\r\nlink_len = strlen(link_str);\r\nif (link_len > CIFS_MF_SYMLINK_LINK_MAXLEN)\r\nreturn -ENAMETOOLONG;\r\nrc = symlink_hash(link_len, link_str, md5_hash);\r\nif (rc) {\r\ncFYI(1, "%s: MD5 hash failure: %d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nsnprintf(buf, buf_len,\r\nCIFS_MF_SYMLINK_LEN_FORMAT CIFS_MF_SYMLINK_MD5_FORMAT,\r\nlink_len,\r\nCIFS_MF_SYMLINK_MD5_ARGS(md5_hash));\r\nofs = CIFS_MF_SYMLINK_LINK_OFFSET;\r\nmemcpy(buf + ofs, link_str, link_len);\r\nofs += link_len;\r\nif (ofs < CIFS_MF_SYMLINK_FILE_SIZE) {\r\nbuf[ofs] = '\n';\r\nofs++;\r\n}\r\nwhile (ofs < CIFS_MF_SYMLINK_FILE_SIZE) {\r\nbuf[ofs] = ' ';\r\nofs++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nCIFSCreateMFSymLink(const int xid, struct cifs_tcon *tcon,\r\nconst char *fromName, const char *toName,\r\nstruct cifs_sb_info *cifs_sb)\r\n{\r\nint rc;\r\nint oplock = 0;\r\nint remap;\r\nint create_options = CREATE_NOT_DIR;\r\n__u16 netfid = 0;\r\nu8 *buf;\r\nunsigned int bytes_written = 0;\r\nstruct cifs_io_parms io_parms;\r\nstruct nls_table *nls_codepage;\r\nnls_codepage = cifs_sb->local_nls;\r\nremap = cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR;\r\nbuf = kmalloc(CIFS_MF_SYMLINK_FILE_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nrc = CIFSFormatMFSymlink(buf, CIFS_MF_SYMLINK_FILE_SIZE, toName);\r\nif (rc != 0) {\r\nkfree(buf);\r\nreturn rc;\r\n}\r\nif (backup_cred(cifs_sb))\r\ncreate_options |= CREATE_OPEN_BACKUP_INTENT;\r\nrc = CIFSSMBOpen(xid, tcon, fromName, FILE_CREATE, GENERIC_WRITE,\r\ncreate_options, &netfid, &oplock, NULL,\r\nnls_codepage, remap);\r\nif (rc != 0) {\r\nkfree(buf);\r\nreturn rc;\r\n}\r\nio_parms.netfid = netfid;\r\nio_parms.pid = current->tgid;\r\nio_parms.tcon = tcon;\r\nio_parms.offset = 0;\r\nio_parms.length = CIFS_MF_SYMLINK_FILE_SIZE;\r\nrc = CIFSSMBWrite(xid, &io_parms, &bytes_written, buf, NULL, 0);\r\nCIFSSMBClose(xid, tcon, netfid);\r\nkfree(buf);\r\nif (rc != 0)\r\nreturn rc;\r\nif (bytes_written != CIFS_MF_SYMLINK_FILE_SIZE)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int\r\nCIFSQueryMFSymLink(const int xid, struct cifs_tcon *tcon,\r\nconst unsigned char *searchName, char **symlinkinfo,\r\nconst struct nls_table *nls_codepage, int remap)\r\n{\r\nint rc;\r\nint oplock = 0;\r\n__u16 netfid = 0;\r\nu8 *buf;\r\nchar *pbuf;\r\nunsigned int bytes_read = 0;\r\nint buf_type = CIFS_NO_BUFFER;\r\nunsigned int link_len = 0;\r\nstruct cifs_io_parms io_parms;\r\nFILE_ALL_INFO file_info;\r\nrc = CIFSSMBOpen(xid, tcon, searchName, FILE_OPEN, GENERIC_READ,\r\nCREATE_NOT_DIR, &netfid, &oplock, &file_info,\r\nnls_codepage, remap);\r\nif (rc != 0)\r\nreturn rc;\r\nif (file_info.EndOfFile != cpu_to_le64(CIFS_MF_SYMLINK_FILE_SIZE)) {\r\nCIFSSMBClose(xid, tcon, netfid);\r\nreturn -EINVAL;\r\n}\r\nbuf = kmalloc(CIFS_MF_SYMLINK_FILE_SIZE, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\npbuf = buf;\r\nio_parms.netfid = netfid;\r\nio_parms.pid = current->tgid;\r\nio_parms.tcon = tcon;\r\nio_parms.offset = 0;\r\nio_parms.length = CIFS_MF_SYMLINK_FILE_SIZE;\r\nrc = CIFSSMBRead(xid, &io_parms, &bytes_read, &pbuf, &buf_type);\r\nCIFSSMBClose(xid, tcon, netfid);\r\nif (rc != 0) {\r\nkfree(buf);\r\nreturn rc;\r\n}\r\nrc = CIFSParseMFSymlink(buf, bytes_read, &link_len, symlinkinfo);\r\nkfree(buf);\r\nif (rc != 0)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nbool\r\nCIFSCouldBeMFSymlink(const struct cifs_fattr *fattr)\r\n{\r\nif (!(fattr->cf_mode & S_IFREG))\r\nreturn false;\r\nif (fattr->cf_eof != CIFS_MF_SYMLINK_FILE_SIZE)\r\nreturn false;\r\nreturn true;\r\n}\r\nint\r\nCIFSCheckMFSymlink(struct cifs_fattr *fattr,\r\nconst unsigned char *path,\r\nstruct cifs_sb_info *cifs_sb, int xid)\r\n{\r\nint rc;\r\nint oplock = 0;\r\n__u16 netfid = 0;\r\nstruct tcon_link *tlink;\r\nstruct cifs_tcon *pTcon;\r\nstruct cifs_io_parms io_parms;\r\nu8 *buf;\r\nchar *pbuf;\r\nunsigned int bytes_read = 0;\r\nint buf_type = CIFS_NO_BUFFER;\r\nunsigned int link_len = 0;\r\nFILE_ALL_INFO file_info;\r\nif (!CIFSCouldBeMFSymlink(fattr))\r\nreturn 0;\r\ntlink = cifs_sb_tlink(cifs_sb);\r\nif (IS_ERR(tlink))\r\nreturn PTR_ERR(tlink);\r\npTcon = tlink_tcon(tlink);\r\nrc = CIFSSMBOpen(xid, pTcon, path, FILE_OPEN, GENERIC_READ,\r\nCREATE_NOT_DIR, &netfid, &oplock, &file_info,\r\ncifs_sb->local_nls,\r\ncifs_sb->mnt_cifs_flags &\r\nCIFS_MOUNT_MAP_SPECIAL_CHR);\r\nif (rc != 0)\r\ngoto out;\r\nif (file_info.EndOfFile != cpu_to_le64(CIFS_MF_SYMLINK_FILE_SIZE)) {\r\nCIFSSMBClose(xid, pTcon, netfid);\r\ngoto out;\r\n}\r\nbuf = kmalloc(CIFS_MF_SYMLINK_FILE_SIZE, GFP_KERNEL);\r\nif (!buf) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\npbuf = buf;\r\nio_parms.netfid = netfid;\r\nio_parms.pid = current->tgid;\r\nio_parms.tcon = pTcon;\r\nio_parms.offset = 0;\r\nio_parms.length = CIFS_MF_SYMLINK_FILE_SIZE;\r\nrc = CIFSSMBRead(xid, &io_parms, &bytes_read, &pbuf, &buf_type);\r\nCIFSSMBClose(xid, pTcon, netfid);\r\nif (rc != 0) {\r\nkfree(buf);\r\ngoto out;\r\n}\r\nrc = CIFSParseMFSymlink(buf, bytes_read, &link_len, NULL);\r\nkfree(buf);\r\nif (rc == -EINVAL) {\r\nrc = 0;\r\ngoto out;\r\n}\r\nif (rc != 0)\r\ngoto out;\r\nfattr->cf_eof = link_len;\r\nfattr->cf_mode &= ~S_IFMT;\r\nfattr->cf_mode |= S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO;\r\nfattr->cf_dtype = DT_LNK;\r\nout:\r\ncifs_put_tlink(tlink);\r\nreturn rc;\r\n}\r\nint\r\ncifs_hardlink(struct dentry *old_file, struct inode *inode,\r\nstruct dentry *direntry)\r\n{\r\nint rc = -EACCES;\r\nint xid;\r\nchar *fromName = NULL;\r\nchar *toName = NULL;\r\nstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\r\nstruct tcon_link *tlink;\r\nstruct cifs_tcon *pTcon;\r\nstruct cifsInodeInfo *cifsInode;\r\ntlink = cifs_sb_tlink(cifs_sb);\r\nif (IS_ERR(tlink))\r\nreturn PTR_ERR(tlink);\r\npTcon = tlink_tcon(tlink);\r\nxid = GetXid();\r\nfromName = build_path_from_dentry(old_file);\r\ntoName = build_path_from_dentry(direntry);\r\nif ((fromName == NULL) || (toName == NULL)) {\r\nrc = -ENOMEM;\r\ngoto cifs_hl_exit;\r\n}\r\nif (pTcon->unix_ext)\r\nrc = CIFSUnixCreateHardLink(xid, pTcon, fromName, toName,\r\ncifs_sb->local_nls,\r\ncifs_sb->mnt_cifs_flags &\r\nCIFS_MOUNT_MAP_SPECIAL_CHR);\r\nelse {\r\nrc = CIFSCreateHardLink(xid, pTcon, fromName, toName,\r\ncifs_sb->local_nls,\r\ncifs_sb->mnt_cifs_flags &\r\nCIFS_MOUNT_MAP_SPECIAL_CHR);\r\nif ((rc == -EIO) || (rc == -EINVAL))\r\nrc = -EOPNOTSUPP;\r\n}\r\nd_drop(direntry);\r\nif (old_file->d_inode) {\r\ncifsInode = CIFS_I(old_file->d_inode);\r\nif (rc == 0) {\r\ninc_nlink(old_file->d_inode);\r\n}\r\ncifsInode->time = 0;\r\n}\r\ncifs_hl_exit:\r\nkfree(fromName);\r\nkfree(toName);\r\nFreeXid(xid);\r\ncifs_put_tlink(tlink);\r\nreturn rc;\r\n}\r\nvoid *\r\ncifs_follow_link(struct dentry *direntry, struct nameidata *nd)\r\n{\r\nstruct inode *inode = direntry->d_inode;\r\nint rc = -ENOMEM;\r\nint xid;\r\nchar *full_path = NULL;\r\nchar *target_path = NULL;\r\nstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\r\nstruct tcon_link *tlink = NULL;\r\nstruct cifs_tcon *tcon;\r\nxid = GetXid();\r\ntlink = cifs_sb_tlink(cifs_sb);\r\nif (IS_ERR(tlink)) {\r\nrc = PTR_ERR(tlink);\r\ntlink = NULL;\r\ngoto out;\r\n}\r\ntcon = tlink_tcon(tlink);\r\nif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS)\r\n&& !(tcon->ses->capabilities & CAP_UNIX)) {\r\nrc = -EACCES;\r\ngoto out;\r\n}\r\nfull_path = build_path_from_dentry(direntry);\r\nif (!full_path)\r\ngoto out;\r\ncFYI(1, "Full path: %s inode = 0x%p", full_path, inode);\r\nrc = -EACCES;\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS)\r\nrc = CIFSQueryMFSymLink(xid, tcon, full_path, &target_path,\r\ncifs_sb->local_nls,\r\ncifs_sb->mnt_cifs_flags &\r\nCIFS_MOUNT_MAP_SPECIAL_CHR);\r\nif ((rc != 0) && (tcon->ses->capabilities & CAP_UNIX))\r\nrc = CIFSSMBUnixQuerySymLink(xid, tcon, full_path, &target_path,\r\ncifs_sb->local_nls);\r\nkfree(full_path);\r\nout:\r\nif (rc != 0) {\r\nkfree(target_path);\r\ntarget_path = ERR_PTR(rc);\r\n}\r\nFreeXid(xid);\r\nif (tlink)\r\ncifs_put_tlink(tlink);\r\nnd_set_link(nd, target_path);\r\nreturn NULL;\r\n}\r\nint\r\ncifs_symlink(struct inode *inode, struct dentry *direntry, const char *symname)\r\n{\r\nint rc = -EOPNOTSUPP;\r\nint xid;\r\nstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\r\nstruct tcon_link *tlink;\r\nstruct cifs_tcon *pTcon;\r\nchar *full_path = NULL;\r\nstruct inode *newinode = NULL;\r\nxid = GetXid();\r\ntlink = cifs_sb_tlink(cifs_sb);\r\nif (IS_ERR(tlink)) {\r\nrc = PTR_ERR(tlink);\r\ngoto symlink_exit;\r\n}\r\npTcon = tlink_tcon(tlink);\r\nfull_path = build_path_from_dentry(direntry);\r\nif (full_path == NULL) {\r\nrc = -ENOMEM;\r\ngoto symlink_exit;\r\n}\r\ncFYI(1, "Full path: %s", full_path);\r\ncFYI(1, "symname is %s", symname);\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS)\r\nrc = CIFSCreateMFSymLink(xid, pTcon, full_path, symname,\r\ncifs_sb);\r\nelse if (pTcon->unix_ext)\r\nrc = CIFSUnixCreateSymLink(xid, pTcon, full_path, symname,\r\ncifs_sb->local_nls);\r\nif (rc == 0) {\r\nif (pTcon->unix_ext)\r\nrc = cifs_get_inode_info_unix(&newinode, full_path,\r\ninode->i_sb, xid);\r\nelse\r\nrc = cifs_get_inode_info(&newinode, full_path, NULL,\r\ninode->i_sb, xid, NULL);\r\nif (rc != 0) {\r\ncFYI(1, "Create symlink ok, getinodeinfo fail rc = %d",\r\nrc);\r\n} else {\r\nd_instantiate(direntry, newinode);\r\n}\r\n}\r\nsymlink_exit:\r\nkfree(full_path);\r\ncifs_put_tlink(tlink);\r\nFreeXid(xid);\r\nreturn rc;\r\n}\r\nvoid cifs_put_link(struct dentry *direntry, struct nameidata *nd, void *cookie)\r\n{\r\nchar *p = nd_get_link(nd);\r\nif (!IS_ERR(p))\r\nkfree(p);\r\n}
