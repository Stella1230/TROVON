static void __nmk_gpio_set_mode(struct nmk_gpio_chip *nmk_chip,\r\nunsigned offset, int gpio_mode)\r\n{\r\nu32 bit = 1 << offset;\r\nu32 afunc, bfunc;\r\nafunc = readl(nmk_chip->addr + NMK_GPIO_AFSLA) & ~bit;\r\nbfunc = readl(nmk_chip->addr + NMK_GPIO_AFSLB) & ~bit;\r\nif (gpio_mode & NMK_GPIO_ALT_A)\r\nafunc |= bit;\r\nif (gpio_mode & NMK_GPIO_ALT_B)\r\nbfunc |= bit;\r\nwritel(afunc, nmk_chip->addr + NMK_GPIO_AFSLA);\r\nwritel(bfunc, nmk_chip->addr + NMK_GPIO_AFSLB);\r\n}\r\nstatic void __nmk_gpio_set_slpm(struct nmk_gpio_chip *nmk_chip,\r\nunsigned offset, enum nmk_gpio_slpm mode)\r\n{\r\nu32 bit = 1 << offset;\r\nu32 slpm;\r\nslpm = readl(nmk_chip->addr + NMK_GPIO_SLPC);\r\nif (mode == NMK_GPIO_SLPM_NOCHANGE)\r\nslpm |= bit;\r\nelse\r\nslpm &= ~bit;\r\nwritel(slpm, nmk_chip->addr + NMK_GPIO_SLPC);\r\n}\r\nstatic void __nmk_gpio_set_pull(struct nmk_gpio_chip *nmk_chip,\r\nunsigned offset, enum nmk_gpio_pull pull)\r\n{\r\nu32 bit = 1 << offset;\r\nu32 pdis;\r\npdis = readl(nmk_chip->addr + NMK_GPIO_PDIS);\r\nif (pull == NMK_GPIO_PULL_NONE) {\r\npdis |= bit;\r\nnmk_chip->pull_up &= ~bit;\r\n} else {\r\npdis &= ~bit;\r\n}\r\nwritel(pdis, nmk_chip->addr + NMK_GPIO_PDIS);\r\nif (pull == NMK_GPIO_PULL_UP) {\r\nnmk_chip->pull_up |= bit;\r\nwritel(bit, nmk_chip->addr + NMK_GPIO_DATS);\r\n} else if (pull == NMK_GPIO_PULL_DOWN) {\r\nnmk_chip->pull_up &= ~bit;\r\nwritel(bit, nmk_chip->addr + NMK_GPIO_DATC);\r\n}\r\n}\r\nstatic void __nmk_gpio_make_input(struct nmk_gpio_chip *nmk_chip,\r\nunsigned offset)\r\n{\r\nwritel(1 << offset, nmk_chip->addr + NMK_GPIO_DIRC);\r\n}\r\nstatic void __nmk_gpio_set_output(struct nmk_gpio_chip *nmk_chip,\r\nunsigned offset, int val)\r\n{\r\nif (val)\r\nwritel(1 << offset, nmk_chip->addr + NMK_GPIO_DATS);\r\nelse\r\nwritel(1 << offset, nmk_chip->addr + NMK_GPIO_DATC);\r\n}\r\nstatic void __nmk_gpio_make_output(struct nmk_gpio_chip *nmk_chip,\r\nunsigned offset, int val)\r\n{\r\nwritel(1 << offset, nmk_chip->addr + NMK_GPIO_DIRS);\r\n__nmk_gpio_set_output(nmk_chip, offset, val);\r\n}\r\nstatic void __nmk_gpio_set_mode_safe(struct nmk_gpio_chip *nmk_chip,\r\nunsigned offset, int gpio_mode,\r\nbool glitch)\r\n{\r\nu32 rwimsc = readl(nmk_chip->addr + NMK_GPIO_RWIMSC);\r\nu32 fwimsc = readl(nmk_chip->addr + NMK_GPIO_FWIMSC);\r\nif (glitch && nmk_chip->set_ioforce) {\r\nu32 bit = BIT(offset);\r\nwritel(rwimsc & ~bit, nmk_chip->addr + NMK_GPIO_RWIMSC);\r\nwritel(fwimsc & ~bit, nmk_chip->addr + NMK_GPIO_FWIMSC);\r\nnmk_chip->set_ioforce(true);\r\n}\r\n__nmk_gpio_set_mode(nmk_chip, offset, gpio_mode);\r\nif (glitch && nmk_chip->set_ioforce) {\r\nnmk_chip->set_ioforce(false);\r\nwritel(rwimsc, nmk_chip->addr + NMK_GPIO_RWIMSC);\r\nwritel(fwimsc, nmk_chip->addr + NMK_GPIO_FWIMSC);\r\n}\r\n}\r\nstatic void __nmk_config_pin(struct nmk_gpio_chip *nmk_chip, unsigned offset,\r\npin_cfg_t cfg, bool sleep, unsigned int *slpmregs)\r\n{\r\nstatic const char *afnames[] = {\r\n[NMK_GPIO_ALT_GPIO] = "GPIO",\r\n[NMK_GPIO_ALT_A] = "A",\r\n[NMK_GPIO_ALT_B] = "B",\r\n[NMK_GPIO_ALT_C] = "C"\r\n};\r\nstatic const char *pullnames[] = {\r\n[NMK_GPIO_PULL_NONE] = "none",\r\n[NMK_GPIO_PULL_UP] = "up",\r\n[NMK_GPIO_PULL_DOWN] = "down",\r\n[3] = "??"\r\n};\r\nstatic const char *slpmnames[] = {\r\n[NMK_GPIO_SLPM_INPUT] = "input/wakeup",\r\n[NMK_GPIO_SLPM_NOCHANGE] = "no-change/no-wakeup",\r\n};\r\nint pin = PIN_NUM(cfg);\r\nint pull = PIN_PULL(cfg);\r\nint af = PIN_ALT(cfg);\r\nint slpm = PIN_SLPM(cfg);\r\nint output = PIN_DIR(cfg);\r\nint val = PIN_VAL(cfg);\r\nbool glitch = af == NMK_GPIO_ALT_C;\r\ndev_dbg(nmk_chip->chip.dev, "pin %d [%#lx]: af %s, pull %s, slpm %s (%s%s)\n",\r\npin, cfg, afnames[af], pullnames[pull], slpmnames[slpm],\r\noutput ? "output " : "input",\r\noutput ? (val ? "high" : "low") : "");\r\nif (sleep) {\r\nint slpm_pull = PIN_SLPM_PULL(cfg);\r\nint slpm_output = PIN_SLPM_DIR(cfg);\r\nint slpm_val = PIN_SLPM_VAL(cfg);\r\naf = NMK_GPIO_ALT_GPIO;\r\nif (slpm_pull)\r\npull = slpm_pull - 1;\r\nif (slpm_output)\r\noutput = slpm_output - 1;\r\nif (slpm_val)\r\nval = slpm_val - 1;\r\ndev_dbg(nmk_chip->chip.dev, "pin %d: sleep pull %s, dir %s, val %s\n",\r\npin,\r\nslpm_pull ? pullnames[pull] : "same",\r\nslpm_output ? (output ? "output" : "input") : "same",\r\nslpm_val ? (val ? "high" : "low") : "same");\r\n}\r\nif (output)\r\n__nmk_gpio_make_output(nmk_chip, offset, val);\r\nelse {\r\n__nmk_gpio_make_input(nmk_chip, offset);\r\n__nmk_gpio_set_pull(nmk_chip, offset, pull);\r\n}\r\nif (slpmregs) {\r\nif (slpm == NMK_GPIO_SLPM_NOCHANGE)\r\nslpmregs[nmk_chip->bank] |= BIT(offset);\r\nelse\r\nslpmregs[nmk_chip->bank] &= ~BIT(offset);\r\n} else\r\n__nmk_gpio_set_slpm(nmk_chip, offset, slpm);\r\n__nmk_gpio_set_mode_safe(nmk_chip, offset, af, glitch);\r\n}\r\nstatic void nmk_gpio_glitch_slpm_init(unsigned int *slpm)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_BANKS; i++) {\r\nstruct nmk_gpio_chip *chip = nmk_gpio_chips[i];\r\nunsigned int temp = slpm[i];\r\nif (!chip)\r\nbreak;\r\nclk_enable(chip->clk);\r\nslpm[i] = readl(chip->addr + NMK_GPIO_SLPC);\r\nwritel(temp, chip->addr + NMK_GPIO_SLPC);\r\n}\r\n}\r\nstatic void nmk_gpio_glitch_slpm_restore(unsigned int *slpm)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_BANKS; i++) {\r\nstruct nmk_gpio_chip *chip = nmk_gpio_chips[i];\r\nif (!chip)\r\nbreak;\r\nwritel(slpm[i], chip->addr + NMK_GPIO_SLPC);\r\nclk_disable(chip->clk);\r\n}\r\n}\r\nstatic int __nmk_config_pins(pin_cfg_t *cfgs, int num, bool sleep)\r\n{\r\nstatic unsigned int slpm[NUM_BANKS];\r\nunsigned long flags;\r\nbool glitch = false;\r\nint ret = 0;\r\nint i;\r\nfor (i = 0; i < num; i++) {\r\nif (PIN_ALT(cfgs[i]) == NMK_GPIO_ALT_C) {\r\nglitch = true;\r\nbreak;\r\n}\r\n}\r\nspin_lock_irqsave(&nmk_gpio_slpm_lock, flags);\r\nif (glitch) {\r\nmemset(slpm, 0xff, sizeof(slpm));\r\nfor (i = 0; i < num; i++) {\r\nint pin = PIN_NUM(cfgs[i]);\r\nint offset = pin % NMK_GPIO_PER_CHIP;\r\nif (PIN_ALT(cfgs[i]) == NMK_GPIO_ALT_C)\r\nslpm[pin / NMK_GPIO_PER_CHIP] &= ~BIT(offset);\r\n}\r\nnmk_gpio_glitch_slpm_init(slpm);\r\n}\r\nfor (i = 0; i < num; i++) {\r\nstruct nmk_gpio_chip *nmk_chip;\r\nint pin = PIN_NUM(cfgs[i]);\r\nnmk_chip = irq_get_chip_data(NOMADIK_GPIO_TO_IRQ(pin));\r\nif (!nmk_chip) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nclk_enable(nmk_chip->clk);\r\nspin_lock(&nmk_chip->lock);\r\n__nmk_config_pin(nmk_chip, pin - nmk_chip->chip.base,\r\ncfgs[i], sleep, glitch ? slpm : NULL);\r\nspin_unlock(&nmk_chip->lock);\r\nclk_disable(nmk_chip->clk);\r\n}\r\nif (glitch)\r\nnmk_gpio_glitch_slpm_restore(slpm);\r\nspin_unlock_irqrestore(&nmk_gpio_slpm_lock, flags);\r\nreturn ret;\r\n}\r\nint nmk_config_pin(pin_cfg_t cfg, bool sleep)\r\n{\r\nreturn __nmk_config_pins(&cfg, 1, sleep);\r\n}\r\nint nmk_config_pins(pin_cfg_t *cfgs, int num)\r\n{\r\nreturn __nmk_config_pins(cfgs, num, false);\r\n}\r\nint nmk_config_pins_sleep(pin_cfg_t *cfgs, int num)\r\n{\r\nreturn __nmk_config_pins(cfgs, num, true);\r\n}\r\nint nmk_gpio_set_slpm(int gpio, enum nmk_gpio_slpm mode)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip;\r\nunsigned long flags;\r\nnmk_chip = irq_get_chip_data(NOMADIK_GPIO_TO_IRQ(gpio));\r\nif (!nmk_chip)\r\nreturn -EINVAL;\r\nclk_enable(nmk_chip->clk);\r\nspin_lock_irqsave(&nmk_gpio_slpm_lock, flags);\r\nspin_lock(&nmk_chip->lock);\r\n__nmk_gpio_set_slpm(nmk_chip, gpio - nmk_chip->chip.base, mode);\r\nspin_unlock(&nmk_chip->lock);\r\nspin_unlock_irqrestore(&nmk_gpio_slpm_lock, flags);\r\nclk_disable(nmk_chip->clk);\r\nreturn 0;\r\n}\r\nint nmk_gpio_set_pull(int gpio, enum nmk_gpio_pull pull)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip;\r\nunsigned long flags;\r\nnmk_chip = irq_get_chip_data(NOMADIK_GPIO_TO_IRQ(gpio));\r\nif (!nmk_chip)\r\nreturn -EINVAL;\r\nclk_enable(nmk_chip->clk);\r\nspin_lock_irqsave(&nmk_chip->lock, flags);\r\n__nmk_gpio_set_pull(nmk_chip, gpio - nmk_chip->chip.base, pull);\r\nspin_unlock_irqrestore(&nmk_chip->lock, flags);\r\nclk_disable(nmk_chip->clk);\r\nreturn 0;\r\n}\r\nint nmk_gpio_set_mode(int gpio, int gpio_mode)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip;\r\nunsigned long flags;\r\nnmk_chip = irq_get_chip_data(NOMADIK_GPIO_TO_IRQ(gpio));\r\nif (!nmk_chip)\r\nreturn -EINVAL;\r\nclk_enable(nmk_chip->clk);\r\nspin_lock_irqsave(&nmk_chip->lock, flags);\r\n__nmk_gpio_set_mode(nmk_chip, gpio - nmk_chip->chip.base, gpio_mode);\r\nspin_unlock_irqrestore(&nmk_chip->lock, flags);\r\nclk_disable(nmk_chip->clk);\r\nreturn 0;\r\n}\r\nint nmk_gpio_get_mode(int gpio)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip;\r\nu32 afunc, bfunc, bit;\r\nnmk_chip = irq_get_chip_data(NOMADIK_GPIO_TO_IRQ(gpio));\r\nif (!nmk_chip)\r\nreturn -EINVAL;\r\nbit = 1 << (gpio - nmk_chip->chip.base);\r\nclk_enable(nmk_chip->clk);\r\nafunc = readl(nmk_chip->addr + NMK_GPIO_AFSLA) & bit;\r\nbfunc = readl(nmk_chip->addr + NMK_GPIO_AFSLB) & bit;\r\nclk_disable(nmk_chip->clk);\r\nreturn (afunc ? NMK_GPIO_ALT_A : 0) | (bfunc ? NMK_GPIO_ALT_B : 0);\r\n}\r\nstatic inline int nmk_gpio_get_bitmask(int gpio)\r\n{\r\nreturn 1 << (gpio % 32);\r\n}\r\nstatic void nmk_gpio_irq_ack(struct irq_data *d)\r\n{\r\nint gpio;\r\nstruct nmk_gpio_chip *nmk_chip;\r\ngpio = NOMADIK_IRQ_TO_GPIO(d->irq);\r\nnmk_chip = irq_data_get_irq_chip_data(d);\r\nif (!nmk_chip)\r\nreturn;\r\nclk_enable(nmk_chip->clk);\r\nwritel(nmk_gpio_get_bitmask(gpio), nmk_chip->addr + NMK_GPIO_IC);\r\nclk_disable(nmk_chip->clk);\r\n}\r\nstatic void __nmk_gpio_irq_modify(struct nmk_gpio_chip *nmk_chip,\r\nint gpio, enum nmk_gpio_irq_type which,\r\nbool enable)\r\n{\r\nu32 rimsc = which == WAKE ? NMK_GPIO_RWIMSC : NMK_GPIO_RIMSC;\r\nu32 fimsc = which == WAKE ? NMK_GPIO_FWIMSC : NMK_GPIO_FIMSC;\r\nu32 bitmask = nmk_gpio_get_bitmask(gpio);\r\nu32 reg;\r\nif (nmk_chip->edge_rising & bitmask) {\r\nreg = readl(nmk_chip->addr + rimsc);\r\nif (enable)\r\nreg |= bitmask;\r\nelse\r\nreg &= ~bitmask;\r\nwritel(reg, nmk_chip->addr + rimsc);\r\n}\r\nif (nmk_chip->edge_falling & bitmask) {\r\nreg = readl(nmk_chip->addr + fimsc);\r\nif (enable)\r\nreg |= bitmask;\r\nelse\r\nreg &= ~bitmask;\r\nwritel(reg, nmk_chip->addr + fimsc);\r\n}\r\n}\r\nstatic void __nmk_gpio_set_wake(struct nmk_gpio_chip *nmk_chip,\r\nint gpio, bool on)\r\n{\r\nif (nmk_chip->sleepmode) {\r\n__nmk_gpio_set_slpm(nmk_chip, gpio - nmk_chip->chip.base,\r\non ? NMK_GPIO_SLPM_WAKEUP_ENABLE\r\n: NMK_GPIO_SLPM_WAKEUP_DISABLE);\r\n}\r\n__nmk_gpio_irq_modify(nmk_chip, gpio, WAKE, on);\r\n}\r\nstatic int nmk_gpio_irq_maskunmask(struct irq_data *d, bool enable)\r\n{\r\nint gpio;\r\nstruct nmk_gpio_chip *nmk_chip;\r\nunsigned long flags;\r\nu32 bitmask;\r\ngpio = NOMADIK_IRQ_TO_GPIO(d->irq);\r\nnmk_chip = irq_data_get_irq_chip_data(d);\r\nbitmask = nmk_gpio_get_bitmask(gpio);\r\nif (!nmk_chip)\r\nreturn -EINVAL;\r\nclk_enable(nmk_chip->clk);\r\nspin_lock_irqsave(&nmk_gpio_slpm_lock, flags);\r\nspin_lock(&nmk_chip->lock);\r\n__nmk_gpio_irq_modify(nmk_chip, gpio, NORMAL, enable);\r\nif (!(nmk_chip->real_wake & bitmask))\r\n__nmk_gpio_set_wake(nmk_chip, gpio, enable);\r\nspin_unlock(&nmk_chip->lock);\r\nspin_unlock_irqrestore(&nmk_gpio_slpm_lock, flags);\r\nclk_disable(nmk_chip->clk);\r\nreturn 0;\r\n}\r\nstatic void nmk_gpio_irq_mask(struct irq_data *d)\r\n{\r\nnmk_gpio_irq_maskunmask(d, false);\r\n}\r\nstatic void nmk_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nnmk_gpio_irq_maskunmask(d, true);\r\n}\r\nstatic int nmk_gpio_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip;\r\nunsigned long flags;\r\nu32 bitmask;\r\nint gpio;\r\ngpio = NOMADIK_IRQ_TO_GPIO(d->irq);\r\nnmk_chip = irq_data_get_irq_chip_data(d);\r\nif (!nmk_chip)\r\nreturn -EINVAL;\r\nbitmask = nmk_gpio_get_bitmask(gpio);\r\nclk_enable(nmk_chip->clk);\r\nspin_lock_irqsave(&nmk_gpio_slpm_lock, flags);\r\nspin_lock(&nmk_chip->lock);\r\nif (irqd_irq_disabled(d))\r\n__nmk_gpio_set_wake(nmk_chip, gpio, on);\r\nif (on)\r\nnmk_chip->real_wake |= bitmask;\r\nelse\r\nnmk_chip->real_wake &= ~bitmask;\r\nspin_unlock(&nmk_chip->lock);\r\nspin_unlock_irqrestore(&nmk_gpio_slpm_lock, flags);\r\nclk_disable(nmk_chip->clk);\r\nreturn 0;\r\n}\r\nstatic int nmk_gpio_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nbool enabled = !irqd_irq_disabled(d);\r\nbool wake = irqd_is_wakeup_set(d);\r\nint gpio;\r\nstruct nmk_gpio_chip *nmk_chip;\r\nunsigned long flags;\r\nu32 bitmask;\r\ngpio = NOMADIK_IRQ_TO_GPIO(d->irq);\r\nnmk_chip = irq_data_get_irq_chip_data(d);\r\nbitmask = nmk_gpio_get_bitmask(gpio);\r\nif (!nmk_chip)\r\nreturn -EINVAL;\r\nif (type & IRQ_TYPE_LEVEL_HIGH)\r\nreturn -EINVAL;\r\nif (type & IRQ_TYPE_LEVEL_LOW)\r\nreturn -EINVAL;\r\nclk_enable(nmk_chip->clk);\r\nspin_lock_irqsave(&nmk_chip->lock, flags);\r\nif (enabled)\r\n__nmk_gpio_irq_modify(nmk_chip, gpio, NORMAL, false);\r\nif (enabled || wake)\r\n__nmk_gpio_irq_modify(nmk_chip, gpio, WAKE, false);\r\nnmk_chip->edge_rising &= ~bitmask;\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nnmk_chip->edge_rising |= bitmask;\r\nnmk_chip->edge_falling &= ~bitmask;\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nnmk_chip->edge_falling |= bitmask;\r\nif (enabled)\r\n__nmk_gpio_irq_modify(nmk_chip, gpio, NORMAL, true);\r\nif (enabled || wake)\r\n__nmk_gpio_irq_modify(nmk_chip, gpio, WAKE, true);\r\nspin_unlock_irqrestore(&nmk_chip->lock, flags);\r\nclk_disable(nmk_chip->clk);\r\nreturn 0;\r\n}\r\nstatic unsigned int nmk_gpio_irq_startup(struct irq_data *d)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip = irq_data_get_irq_chip_data(d);\r\nclk_enable(nmk_chip->clk);\r\nnmk_gpio_irq_unmask(d);\r\nreturn 0;\r\n}\r\nstatic void nmk_gpio_irq_shutdown(struct irq_data *d)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip = irq_data_get_irq_chip_data(d);\r\nnmk_gpio_irq_mask(d);\r\nclk_disable(nmk_chip->clk);\r\n}\r\nstatic void __nmk_gpio_irq_handler(unsigned int irq, struct irq_desc *desc,\r\nu32 status)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip;\r\nstruct irq_chip *host_chip = irq_get_chip(irq);\r\nunsigned int first_irq;\r\nchained_irq_enter(host_chip, desc);\r\nnmk_chip = irq_get_handler_data(irq);\r\nfirst_irq = NOMADIK_GPIO_TO_IRQ(nmk_chip->chip.base);\r\nwhile (status) {\r\nint bit = __ffs(status);\r\ngeneric_handle_irq(first_irq + bit);\r\nstatus &= ~BIT(bit);\r\n}\r\nchained_irq_exit(host_chip, desc);\r\n}\r\nstatic void nmk_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip = irq_get_handler_data(irq);\r\nu32 status;\r\nclk_enable(nmk_chip->clk);\r\nstatus = readl(nmk_chip->addr + NMK_GPIO_IS);\r\nclk_disable(nmk_chip->clk);\r\n__nmk_gpio_irq_handler(irq, desc, status);\r\n}\r\nstatic void nmk_gpio_secondary_irq_handler(unsigned int irq,\r\nstruct irq_desc *desc)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip = irq_get_handler_data(irq);\r\nu32 status = nmk_chip->get_secondary_status(nmk_chip->bank);\r\n__nmk_gpio_irq_handler(irq, desc, status);\r\n}\r\nstatic int nmk_gpio_init_irq(struct nmk_gpio_chip *nmk_chip)\r\n{\r\nunsigned int first_irq;\r\nint i;\r\nfirst_irq = NOMADIK_GPIO_TO_IRQ(nmk_chip->chip.base);\r\nfor (i = first_irq; i < first_irq + nmk_chip->chip.ngpio; i++) {\r\nirq_set_chip_and_handler(i, &nmk_gpio_irq_chip,\r\nhandle_edge_irq);\r\nset_irq_flags(i, IRQF_VALID);\r\nirq_set_chip_data(i, nmk_chip);\r\nirq_set_irq_type(i, IRQ_TYPE_EDGE_FALLING);\r\n}\r\nirq_set_chained_handler(nmk_chip->parent_irq, nmk_gpio_irq_handler);\r\nirq_set_handler_data(nmk_chip->parent_irq, nmk_chip);\r\nif (nmk_chip->secondary_parent_irq >= 0) {\r\nirq_set_chained_handler(nmk_chip->secondary_parent_irq,\r\nnmk_gpio_secondary_irq_handler);\r\nirq_set_handler_data(nmk_chip->secondary_parent_irq, nmk_chip);\r\n}\r\nreturn 0;\r\n}\r\nstatic int nmk_gpio_make_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip =\r\ncontainer_of(chip, struct nmk_gpio_chip, chip);\r\nclk_enable(nmk_chip->clk);\r\nwritel(1 << offset, nmk_chip->addr + NMK_GPIO_DIRC);\r\nclk_disable(nmk_chip->clk);\r\nreturn 0;\r\n}\r\nstatic int nmk_gpio_get_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip =\r\ncontainer_of(chip, struct nmk_gpio_chip, chip);\r\nu32 bit = 1 << offset;\r\nint value;\r\nclk_enable(nmk_chip->clk);\r\nvalue = (readl(nmk_chip->addr + NMK_GPIO_DAT) & bit) != 0;\r\nclk_disable(nmk_chip->clk);\r\nreturn value;\r\n}\r\nstatic void nmk_gpio_set_output(struct gpio_chip *chip, unsigned offset,\r\nint val)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip =\r\ncontainer_of(chip, struct nmk_gpio_chip, chip);\r\nclk_enable(nmk_chip->clk);\r\n__nmk_gpio_set_output(nmk_chip, offset, val);\r\nclk_disable(nmk_chip->clk);\r\n}\r\nstatic int nmk_gpio_make_output(struct gpio_chip *chip, unsigned offset,\r\nint val)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip =\r\ncontainer_of(chip, struct nmk_gpio_chip, chip);\r\nclk_enable(nmk_chip->clk);\r\n__nmk_gpio_make_output(nmk_chip, offset, val);\r\nclk_disable(nmk_chip->clk);\r\nreturn 0;\r\n}\r\nstatic int nmk_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip =\r\ncontainer_of(chip, struct nmk_gpio_chip, chip);\r\nreturn NOMADIK_GPIO_TO_IRQ(nmk_chip->chip.base) + offset;\r\n}\r\nstatic void nmk_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\r\n{\r\nint mode;\r\nunsigned i;\r\nunsigned gpio = chip->base;\r\nint is_out;\r\nstruct nmk_gpio_chip *nmk_chip =\r\ncontainer_of(chip, struct nmk_gpio_chip, chip);\r\nconst char *modes[] = {\r\n[NMK_GPIO_ALT_GPIO] = "gpio",\r\n[NMK_GPIO_ALT_A] = "altA",\r\n[NMK_GPIO_ALT_B] = "altB",\r\n[NMK_GPIO_ALT_C] = "altC",\r\n};\r\nclk_enable(nmk_chip->clk);\r\nfor (i = 0; i < chip->ngpio; i++, gpio++) {\r\nconst char *label = gpiochip_is_requested(chip, i);\r\nbool pull;\r\nu32 bit = 1 << i;\r\nis_out = readl(nmk_chip->addr + NMK_GPIO_DIR) & bit;\r\npull = !(readl(nmk_chip->addr + NMK_GPIO_PDIS) & bit);\r\nmode = nmk_gpio_get_mode(gpio);\r\nseq_printf(s, " gpio-%-3d (%-20.20s) %s %s %s %s",\r\ngpio, label ?: "(none)",\r\nis_out ? "out" : "in ",\r\nchip->get\r\n? (chip->get(chip, i) ? "hi" : "lo")\r\n: "? ",\r\n(mode < 0) ? "unknown" : modes[mode],\r\npull ? "pull" : "none");\r\nif (label && !is_out) {\r\nint irq = gpio_to_irq(gpio);\r\nstruct irq_desc *desc = irq_to_desc(irq);\r\nif (irq >= 0 && desc->action) {\r\nchar *trigger;\r\nu32 bitmask = nmk_gpio_get_bitmask(gpio);\r\nif (nmk_chip->edge_rising & bitmask)\r\ntrigger = "edge-rising";\r\nelse if (nmk_chip->edge_falling & bitmask)\r\ntrigger = "edge-falling";\r\nelse\r\ntrigger = "edge-undefined";\r\nseq_printf(s, " irq-%d %s%s",\r\nirq, trigger,\r\nirqd_is_wakeup_set(&desc->irq_data)\r\n? " wakeup" : "");\r\n}\r\n}\r\nseq_printf(s, "\n");\r\n}\r\nclk_disable(nmk_chip->clk);\r\n}\r\nvoid nmk_gpio_clocks_enable(void)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_BANKS; i++) {\r\nstruct nmk_gpio_chip *chip = nmk_gpio_chips[i];\r\nif (!chip)\r\ncontinue;\r\nclk_enable(chip->clk);\r\n}\r\n}\r\nvoid nmk_gpio_clocks_disable(void)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_BANKS; i++) {\r\nstruct nmk_gpio_chip *chip = nmk_gpio_chips[i];\r\nif (!chip)\r\ncontinue;\r\nclk_disable(chip->clk);\r\n}\r\n}\r\nvoid nmk_gpio_wakeups_suspend(void)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_BANKS; i++) {\r\nstruct nmk_gpio_chip *chip = nmk_gpio_chips[i];\r\nif (!chip)\r\nbreak;\r\nclk_enable(chip->clk);\r\nchip->rwimsc = readl(chip->addr + NMK_GPIO_RWIMSC);\r\nchip->fwimsc = readl(chip->addr + NMK_GPIO_FWIMSC);\r\nwritel(chip->rwimsc & chip->real_wake,\r\nchip->addr + NMK_GPIO_RWIMSC);\r\nwritel(chip->fwimsc & chip->real_wake,\r\nchip->addr + NMK_GPIO_FWIMSC);\r\nif (chip->sleepmode) {\r\nchip->slpm = readl(chip->addr + NMK_GPIO_SLPC);\r\nwritel(~chip->real_wake, chip->addr + NMK_GPIO_SLPC);\r\n}\r\nclk_disable(chip->clk);\r\n}\r\n}\r\nvoid nmk_gpio_wakeups_resume(void)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_BANKS; i++) {\r\nstruct nmk_gpio_chip *chip = nmk_gpio_chips[i];\r\nif (!chip)\r\nbreak;\r\nclk_enable(chip->clk);\r\nwritel(chip->rwimsc, chip->addr + NMK_GPIO_RWIMSC);\r\nwritel(chip->fwimsc, chip->addr + NMK_GPIO_FWIMSC);\r\nif (chip->sleepmode)\r\nwritel(chip->slpm, chip->addr + NMK_GPIO_SLPC);\r\nclk_disable(chip->clk);\r\n}\r\n}\r\nvoid nmk_gpio_read_pull(int gpio_bank, u32 *pull_up)\r\n{\r\nif (gpio_bank < NUM_BANKS) {\r\nstruct nmk_gpio_chip *chip = nmk_gpio_chips[gpio_bank];\r\nif (!chip)\r\nreturn;\r\n*pull_up = chip->pull_up;\r\n}\r\n}\r\nstatic int __devinit nmk_gpio_probe(struct platform_device *dev)\r\n{\r\nstruct nmk_gpio_platform_data *pdata = dev->dev.platform_data;\r\nstruct nmk_gpio_chip *nmk_chip;\r\nstruct gpio_chip *chip;\r\nstruct resource *res;\r\nstruct clk *clk;\r\nint secondary_irq;\r\nint irq;\r\nint ret;\r\nif (!pdata)\r\nreturn -ENODEV;\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nirq = platform_get_irq(dev, 0);\r\nif (irq < 0) {\r\nret = irq;\r\ngoto out;\r\n}\r\nsecondary_irq = platform_get_irq(dev, 1);\r\nif (secondary_irq >= 0 && !pdata->get_secondary_status) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (request_mem_region(res->start, resource_size(res),\r\ndev_name(&dev->dev)) == NULL) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nclk = clk_get(&dev->dev, NULL);\r\nif (IS_ERR(clk)) {\r\nret = PTR_ERR(clk);\r\ngoto out_release;\r\n}\r\nnmk_chip = kzalloc(sizeof(*nmk_chip), GFP_KERNEL);\r\nif (!nmk_chip) {\r\nret = -ENOMEM;\r\ngoto out_clk;\r\n}\r\nnmk_chip->bank = dev->id;\r\nnmk_chip->clk = clk;\r\nnmk_chip->addr = io_p2v(res->start);\r\nnmk_chip->chip = nmk_gpio_template;\r\nnmk_chip->parent_irq = irq;\r\nnmk_chip->secondary_parent_irq = secondary_irq;\r\nnmk_chip->get_secondary_status = pdata->get_secondary_status;\r\nnmk_chip->set_ioforce = pdata->set_ioforce;\r\nnmk_chip->sleepmode = pdata->supports_sleepmode;\r\nspin_lock_init(&nmk_chip->lock);\r\nchip = &nmk_chip->chip;\r\nchip->base = pdata->first_gpio;\r\nchip->ngpio = pdata->num_gpio;\r\nchip->label = pdata->name ?: dev_name(&dev->dev);\r\nchip->dev = &dev->dev;\r\nchip->owner = THIS_MODULE;\r\nret = gpiochip_add(&nmk_chip->chip);\r\nif (ret)\r\ngoto out_free;\r\nBUG_ON(nmk_chip->bank >= ARRAY_SIZE(nmk_gpio_chips));\r\nnmk_gpio_chips[nmk_chip->bank] = nmk_chip;\r\nplatform_set_drvdata(dev, nmk_chip);\r\nnmk_gpio_init_irq(nmk_chip);\r\ndev_info(&dev->dev, "at address %p\n",\r\nnmk_chip->addr);\r\nreturn 0;\r\nout_free:\r\nkfree(nmk_chip);\r\nout_clk:\r\nclk_disable(clk);\r\nclk_put(clk);\r\nout_release:\r\nrelease_mem_region(res->start, resource_size(res));\r\nout:\r\ndev_err(&dev->dev, "Failure %i for GPIO %i-%i\n", ret,\r\npdata->first_gpio, pdata->first_gpio+31);\r\nreturn ret;\r\n}\r\nstatic int __init nmk_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&nmk_gpio_driver);\r\n}
