struct acpi_namespace_node *acpi_ns_create_node(u32 name)\r\n{\r\nstruct acpi_namespace_node *node;\r\n#ifdef ACPI_DBG_TRACK_ALLOCATIONS\r\nu32 temp;\r\n#endif\r\nACPI_FUNCTION_TRACE(ns_create_node);\r\nnode = acpi_os_acquire_object(acpi_gbl_namespace_cache);\r\nif (!node) {\r\nreturn_PTR(NULL);\r\n}\r\nACPI_MEM_TRACKING(acpi_gbl_ns_node_list->total_allocated++);\r\n#ifdef ACPI_DBG_TRACK_ALLOCATIONS\r\ntemp = acpi_gbl_ns_node_list->total_allocated -\r\nacpi_gbl_ns_node_list->total_freed;\r\nif (temp > acpi_gbl_ns_node_list->max_occupied) {\r\nacpi_gbl_ns_node_list->max_occupied = temp;\r\n}\r\n#endif\r\nnode->name.integer = name;\r\nACPI_SET_DESCRIPTOR_TYPE(node, ACPI_DESC_TYPE_NAMED);\r\nreturn_PTR(node);\r\n}\r\nvoid acpi_ns_delete_node(struct acpi_namespace_node *node)\r\n{\r\nunion acpi_operand_object *obj_desc;\r\nACPI_FUNCTION_NAME(ns_delete_node);\r\nacpi_ns_detach_object(node);\r\nobj_desc = node->object;\r\nif (obj_desc && (obj_desc->common.type == ACPI_TYPE_LOCAL_DATA)) {\r\nif (obj_desc->data.handler) {\r\nobj_desc->data.handler(node, obj_desc->data.pointer);\r\n}\r\nacpi_ut_remove_reference(obj_desc);\r\n}\r\n(void)acpi_os_release_object(acpi_gbl_namespace_cache, node);\r\nACPI_MEM_TRACKING(acpi_gbl_ns_node_list->total_freed++);\r\nACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, "Node %p, Remaining %X\n",\r\nnode, acpi_gbl_current_node_count));\r\n}\r\nvoid acpi_ns_remove_node(struct acpi_namespace_node *node)\r\n{\r\nstruct acpi_namespace_node *parent_node;\r\nstruct acpi_namespace_node *prev_node;\r\nstruct acpi_namespace_node *next_node;\r\nACPI_FUNCTION_TRACE_PTR(ns_remove_node, node);\r\nparent_node = node->parent;\r\nprev_node = NULL;\r\nnext_node = parent_node->child;\r\nwhile (next_node != node) {\r\nprev_node = next_node;\r\nnext_node = next_node->peer;\r\n}\r\nif (prev_node) {\r\nprev_node->peer = node->peer;\r\n} else {\r\nparent_node->child = node->peer;\r\n}\r\nacpi_ns_delete_node(node);\r\nreturn_VOID;\r\n}\r\nvoid acpi_ns_install_node(struct acpi_walk_state *walk_state, struct acpi_namespace_node *parent_node,\r\nstruct acpi_namespace_node *node,\r\nacpi_object_type type)\r\n{\r\nacpi_owner_id owner_id = 0;\r\nstruct acpi_namespace_node *child_node;\r\nACPI_FUNCTION_TRACE(ns_install_node);\r\nif (walk_state) {\r\nowner_id = walk_state->owner_id;\r\nif ((walk_state->method_desc) &&\r\n(parent_node != walk_state->method_node)) {\r\nwalk_state->method_desc->method.info_flags |=\r\nACPI_METHOD_MODIFIED_NAMESPACE;\r\n}\r\n}\r\nnode->peer = NULL;\r\nnode->parent = parent_node;\r\nchild_node = parent_node->child;\r\nif (!child_node) {\r\nparent_node->child = node;\r\n} else {\r\nwhile (child_node->peer) {\r\nchild_node = child_node->peer;\r\n}\r\nchild_node->peer = node;\r\n}\r\nnode->owner_id = owner_id;\r\nnode->type = (u8) type;\r\nACPI_DEBUG_PRINT((ACPI_DB_NAMES,\r\n"%4.4s (%s) [Node %p Owner %X] added to %4.4s (%s) [Node %p]\n",\r\nacpi_ut_get_node_name(node),\r\nacpi_ut_get_type_name(node->type), node, owner_id,\r\nacpi_ut_get_node_name(parent_node),\r\nacpi_ut_get_type_name(parent_node->type),\r\nparent_node));\r\nreturn_VOID;\r\n}\r\nvoid acpi_ns_delete_children(struct acpi_namespace_node *parent_node)\r\n{\r\nstruct acpi_namespace_node *next_node;\r\nstruct acpi_namespace_node *node_to_delete;\r\nACPI_FUNCTION_TRACE_PTR(ns_delete_children, parent_node);\r\nif (!parent_node) {\r\nreturn_VOID;\r\n}\r\nnext_node = parent_node->child;\r\nwhile (next_node) {\r\nif (next_node->child) {\r\nACPI_ERROR((AE_INFO, "Found a grandchild! P=%p C=%p",\r\nparent_node, next_node));\r\n}\r\nnode_to_delete = next_node;\r\nnext_node = next_node->peer;\r\nacpi_ns_delete_node(node_to_delete);\r\n};\r\nparent_node->child = NULL;\r\nreturn_VOID;\r\n}\r\nvoid acpi_ns_delete_namespace_subtree(struct acpi_namespace_node *parent_node)\r\n{\r\nstruct acpi_namespace_node *child_node = NULL;\r\nu32 level = 1;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ns_delete_namespace_subtree);\r\nif (!parent_node) {\r\nreturn_VOID;\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_VOID;\r\n}\r\nwhile (level > 0) {\r\nchild_node = acpi_ns_get_next_node(parent_node, child_node);\r\nif (child_node) {\r\nacpi_ns_detach_object(child_node);\r\nif (child_node->child) {\r\nlevel++;\r\nparent_node = child_node;\r\nchild_node = NULL;\r\n}\r\n} else {\r\nlevel--;\r\nacpi_ns_delete_children(parent_node);\r\nchild_node = parent_node;\r\nparent_node = parent_node->parent;\r\n}\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nreturn_VOID;\r\n}\r\nvoid acpi_ns_delete_namespace_by_owner(acpi_owner_id owner_id)\r\n{\r\nstruct acpi_namespace_node *child_node;\r\nstruct acpi_namespace_node *deletion_node;\r\nstruct acpi_namespace_node *parent_node;\r\nu32 level;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE_U32(ns_delete_namespace_by_owner, owner_id);\r\nif (owner_id == 0) {\r\nreturn_VOID;\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_VOID;\r\n}\r\ndeletion_node = NULL;\r\nparent_node = acpi_gbl_root_node;\r\nchild_node = NULL;\r\nlevel = 1;\r\nwhile (level > 0) {\r\nchild_node = acpi_ns_get_next_node(parent_node, child_node);\r\nif (deletion_node) {\r\nacpi_ns_delete_children(deletion_node);\r\nacpi_ns_remove_node(deletion_node);\r\ndeletion_node = NULL;\r\n}\r\nif (child_node) {\r\nif (child_node->owner_id == owner_id) {\r\nacpi_ns_detach_object(child_node);\r\n}\r\nif (child_node->child) {\r\nlevel++;\r\nparent_node = child_node;\r\nchild_node = NULL;\r\n} else if (child_node->owner_id == owner_id) {\r\ndeletion_node = child_node;\r\n}\r\n} else {\r\nlevel--;\r\nif (level != 0) {\r\nif (parent_node->owner_id == owner_id) {\r\ndeletion_node = parent_node;\r\n}\r\n}\r\nchild_node = parent_node;\r\nparent_node = parent_node->parent;\r\n}\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nreturn_VOID;\r\n}
