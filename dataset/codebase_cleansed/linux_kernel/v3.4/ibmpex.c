static inline u16 extract_value(const char *data, int offset)\r\n{\r\nreturn be16_to_cpup((__be16 *)&data[offset]);\r\n}\r\nstatic int ibmpex_send_message(struct ibmpex_bmc_data *data)\r\n{\r\nint err;\r\nerr = ipmi_validate_addr(&data->address, sizeof(data->address));\r\nif (err)\r\ngoto out;\r\ndata->tx_msgid++;\r\nerr = ipmi_request_settime(data->user, &data->address, data->tx_msgid,\r\n&data->tx_message, data, 0, 0, 0);\r\nif (err)\r\ngoto out1;\r\nreturn 0;\r\nout1:\r\ndev_err(data->bmc_device, "request_settime=%x\n", err);\r\nreturn err;\r\nout:\r\ndev_err(data->bmc_device, "validate_addr=%x\n", err);\r\nreturn err;\r\n}\r\nstatic int ibmpex_ver_check(struct ibmpex_bmc_data *data)\r\n{\r\ndata->tx_msg_data[0] = PEX_GET_VERSION;\r\ndata->tx_message.data_len = 1;\r\nibmpex_send_message(data);\r\nwait_for_completion(&data->read_complete);\r\nif (data->rx_result || data->rx_msg_len != 6)\r\nreturn -ENOENT;\r\ndata->sensor_major = data->rx_msg_data[0];\r\ndata->sensor_minor = data->rx_msg_data[1];\r\ndev_info(data->bmc_device, "Found BMC with sensor interface "\r\n"v%d.%d %d-%02d-%02d on interface %d\n",\r\ndata->sensor_major,\r\ndata->sensor_minor,\r\nextract_value(data->rx_msg_data, 2),\r\ndata->rx_msg_data[4],\r\ndata->rx_msg_data[5],\r\ndata->interface);\r\nreturn 0;\r\n}\r\nstatic int ibmpex_query_sensor_count(struct ibmpex_bmc_data *data)\r\n{\r\ndata->tx_msg_data[0] = PEX_GET_SENSOR_COUNT;\r\ndata->tx_message.data_len = 1;\r\nibmpex_send_message(data);\r\nwait_for_completion(&data->read_complete);\r\nif (data->rx_result || data->rx_msg_len != 1)\r\nreturn -ENOENT;\r\nreturn data->rx_msg_data[0];\r\n}\r\nstatic int ibmpex_query_sensor_name(struct ibmpex_bmc_data *data, int sensor)\r\n{\r\ndata->tx_msg_data[0] = PEX_GET_SENSOR_NAME;\r\ndata->tx_msg_data[1] = sensor;\r\ndata->tx_message.data_len = 2;\r\nibmpex_send_message(data);\r\nwait_for_completion(&data->read_complete);\r\nif (data->rx_result || data->rx_msg_len < 1)\r\nreturn -ENOENT;\r\nreturn 0;\r\n}\r\nstatic int ibmpex_query_sensor_data(struct ibmpex_bmc_data *data, int sensor)\r\n{\r\ndata->tx_msg_data[0] = PEX_GET_SENSOR_DATA;\r\ndata->tx_msg_data[1] = sensor;\r\ndata->tx_message.data_len = 2;\r\nibmpex_send_message(data);\r\nwait_for_completion(&data->read_complete);\r\nif (data->rx_result || data->rx_msg_len < 26) {\r\ndev_err(data->bmc_device, "Error reading sensor %d.\n",\r\nsensor);\r\nreturn -ENOENT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ibmpex_reset_high_low_data(struct ibmpex_bmc_data *data)\r\n{\r\ndata->tx_msg_data[0] = PEX_RESET_HIGH_LOW;\r\ndata->tx_message.data_len = 1;\r\nibmpex_send_message(data);\r\nwait_for_completion(&data->read_complete);\r\nreturn 0;\r\n}\r\nstatic void ibmpex_update_device(struct ibmpex_bmc_data *data)\r\n{\r\nint i, err;\r\nmutex_lock(&data->lock);\r\nif (time_before(jiffies, data->last_updated + REFRESH_INTERVAL) &&\r\ndata->valid)\r\ngoto out;\r\nfor (i = 0; i < data->num_sensors; i++) {\r\nif (!data->sensors[i].in_use)\r\ncontinue;\r\nerr = ibmpex_query_sensor_data(data, i);\r\nif (err)\r\ncontinue;\r\ndata->sensors[i].values[0] =\r\nextract_value(data->rx_msg_data, 16);\r\ndata->sensors[i].values[1] =\r\nextract_value(data->rx_msg_data, 18);\r\ndata->sensors[i].values[2] =\r\nextract_value(data->rx_msg_data, 20);\r\n}\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\nout:\r\nmutex_unlock(&data->lock);\r\n}\r\nstatic struct ibmpex_bmc_data *get_bmc_data(int iface)\r\n{\r\nstruct ibmpex_bmc_data *p, *next;\r\nlist_for_each_entry_safe(p, next, &driver_data.bmc_data, list)\r\nif (p->interface == iface)\r\nreturn p;\r\nreturn NULL;\r\n}\r\nstatic ssize_t show_name(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%s\n", DRVNAME);\r\n}\r\nstatic ssize_t ibmpex_show_sensor(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nstruct ibmpex_bmc_data *data = dev_get_drvdata(dev);\r\nint mult = data->sensors[attr->index].multiplier;\r\nibmpex_update_device(data);\r\nreturn sprintf(buf, "%d\n",\r\ndata->sensors[attr->index].values[attr->nr] * mult);\r\n}\r\nstatic ssize_t ibmpex_reset_high_low(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct ibmpex_bmc_data *data = dev_get_drvdata(dev);\r\nibmpex_reset_high_low_data(data);\r\nreturn count;\r\n}\r\nstatic int is_power_sensor(const char *sensor_id, int len)\r\n{\r\nif (len < PEX_SENSOR_TYPE_LEN)\r\nreturn 0;\r\nif (!memcmp(sensor_id, power_sensor_sig, PEX_SENSOR_TYPE_LEN))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int is_temp_sensor(const char *sensor_id, int len)\r\n{\r\nif (len < PEX_SENSOR_TYPE_LEN)\r\nreturn 0;\r\nif (!memcmp(sensor_id, temp_sensor_sig, PEX_SENSOR_TYPE_LEN))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int power_sensor_multiplier(struct ibmpex_bmc_data *data,\r\nconst char *sensor_id, int len)\r\n{\r\nint i;\r\nif (data->sensor_major == 2)\r\nreturn 1000000;\r\nfor (i = PEX_SENSOR_TYPE_LEN; i < len - 1; i++)\r\nif (!memcmp(&sensor_id[i], watt_sensor_sig, PEX_MULT_LEN))\r\nreturn 1000000;\r\nreturn 100000;\r\n}\r\nstatic int create_sensor(struct ibmpex_bmc_data *data, int type,\r\nint counter, int sensor, int func)\r\n{\r\nint err;\r\nchar *n;\r\nn = kmalloc(32, GFP_KERNEL);\r\nif (!n)\r\nreturn -ENOMEM;\r\nif (type == TEMP_SENSOR)\r\nsprintf(n, temp_sensor_name_templates[func], "temp", counter);\r\nelse if (type == POWER_SENSOR)\r\nsprintf(n, power_sensor_name_templates[func], "power", counter);\r\nsysfs_attr_init(&data->sensors[sensor].attr[func].dev_attr.attr);\r\ndata->sensors[sensor].attr[func].dev_attr.attr.name = n;\r\ndata->sensors[sensor].attr[func].dev_attr.attr.mode = S_IRUGO;\r\ndata->sensors[sensor].attr[func].dev_attr.show = ibmpex_show_sensor;\r\ndata->sensors[sensor].attr[func].index = sensor;\r\ndata->sensors[sensor].attr[func].nr = func;\r\nerr = device_create_file(data->bmc_device,\r\n&data->sensors[sensor].attr[func].dev_attr);\r\nif (err) {\r\ndata->sensors[sensor].attr[func].dev_attr.attr.name = NULL;\r\nkfree(n);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ibmpex_find_sensors(struct ibmpex_bmc_data *data)\r\n{\r\nint i, j, err;\r\nint sensor_type;\r\nint sensor_counter;\r\nint num_power = 0;\r\nint num_temp = 0;\r\nerr = ibmpex_query_sensor_count(data);\r\nif (err <= 0)\r\nreturn -ENOENT;\r\ndata->num_sensors = err;\r\ndata->sensors = kzalloc(data->num_sensors * sizeof(*data->sensors),\r\nGFP_KERNEL);\r\nif (!data->sensors)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < data->num_sensors; i++) {\r\nerr = ibmpex_query_sensor_name(data, i);\r\nif (err)\r\ncontinue;\r\nif (is_power_sensor(data->rx_msg_data, data->rx_msg_len)) {\r\nsensor_type = POWER_SENSOR;\r\nnum_power++;\r\nsensor_counter = num_power;\r\ndata->sensors[i].multiplier =\r\npower_sensor_multiplier(data,\r\ndata->rx_msg_data,\r\ndata->rx_msg_len);\r\n} else if (is_temp_sensor(data->rx_msg_data,\r\ndata->rx_msg_len)) {\r\nsensor_type = TEMP_SENSOR;\r\nnum_temp++;\r\nsensor_counter = num_temp;\r\ndata->sensors[i].multiplier = 1000;\r\n} else\r\ncontinue;\r\ndata->sensors[i].in_use = 1;\r\nfor (j = 0; j < PEX_NUM_SENSOR_FUNCS; j++) {\r\nerr = create_sensor(data, sensor_type, sensor_counter,\r\ni, j);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\n}\r\nerr = device_create_file(data->bmc_device,\r\n&sensor_dev_attr_reset_high_low.dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\nerr = device_create_file(data->bmc_device,\r\n&sensor_dev_attr_name.dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\nreturn 0;\r\nexit_remove:\r\ndevice_remove_file(data->bmc_device,\r\n&sensor_dev_attr_reset_high_low.dev_attr);\r\ndevice_remove_file(data->bmc_device, &sensor_dev_attr_name.dev_attr);\r\nfor (i = 0; i < data->num_sensors; i++)\r\nfor (j = 0; j < PEX_NUM_SENSOR_FUNCS; j++) {\r\nif (!data->sensors[i].attr[j].dev_attr.attr.name)\r\ncontinue;\r\ndevice_remove_file(data->bmc_device,\r\n&data->sensors[i].attr[j].dev_attr);\r\nkfree(data->sensors[i].attr[j].dev_attr.attr.name);\r\n}\r\nkfree(data->sensors);\r\nreturn err;\r\n}\r\nstatic void ibmpex_register_bmc(int iface, struct device *dev)\r\n{\r\nstruct ibmpex_bmc_data *data;\r\nint err;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data) {\r\ndev_err(dev, "Insufficient memory for BMC interface.\n");\r\nreturn;\r\n}\r\ndata->address.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\r\ndata->address.channel = IPMI_BMC_CHANNEL;\r\ndata->address.data[0] = 0;\r\ndata->interface = iface;\r\ndata->bmc_device = dev;\r\nerr = ipmi_create_user(data->interface, &driver_data.ipmi_hndlrs,\r\ndata, &data->user);\r\nif (err < 0) {\r\ndev_err(dev, "Unable to register user with IPMI "\r\n"interface %d\n", data->interface);\r\ngoto out;\r\n}\r\nmutex_init(&data->lock);\r\ndata->tx_msgid = 0;\r\ninit_completion(&data->read_complete);\r\ndata->tx_message.netfn = PEX_NET_FUNCTION;\r\ndata->tx_message.cmd = PEX_COMMAND;\r\ndata->tx_message.data = data->tx_msg_data;\r\nerr = ibmpex_ver_check(data);\r\nif (err)\r\ngoto out_user;\r\ndata->hwmon_dev = hwmon_device_register(data->bmc_device);\r\nif (IS_ERR(data->hwmon_dev)) {\r\ndev_err(data->bmc_device, "Unable to register hwmon "\r\n"device for IPMI interface %d\n",\r\ndata->interface);\r\ngoto out_user;\r\n}\r\ndev_set_drvdata(dev, data);\r\nlist_add_tail(&data->list, &driver_data.bmc_data);\r\nerr = ibmpex_find_sensors(data);\r\nif (err) {\r\ndev_err(data->bmc_device, "Error %d finding sensors\n", err);\r\ngoto out_register;\r\n}\r\nreturn;\r\nout_register:\r\nhwmon_device_unregister(data->hwmon_dev);\r\nout_user:\r\nipmi_destroy_user(data->user);\r\nout:\r\nkfree(data);\r\n}\r\nstatic void ibmpex_bmc_delete(struct ibmpex_bmc_data *data)\r\n{\r\nint i, j;\r\ndevice_remove_file(data->bmc_device,\r\n&sensor_dev_attr_reset_high_low.dev_attr);\r\ndevice_remove_file(data->bmc_device, &sensor_dev_attr_name.dev_attr);\r\nfor (i = 0; i < data->num_sensors; i++)\r\nfor (j = 0; j < PEX_NUM_SENSOR_FUNCS; j++) {\r\nif (!data->sensors[i].attr[j].dev_attr.attr.name)\r\ncontinue;\r\ndevice_remove_file(data->bmc_device,\r\n&data->sensors[i].attr[j].dev_attr);\r\nkfree(data->sensors[i].attr[j].dev_attr.attr.name);\r\n}\r\nlist_del(&data->list);\r\ndev_set_drvdata(data->bmc_device, NULL);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nipmi_destroy_user(data->user);\r\nkfree(data->sensors);\r\nkfree(data);\r\n}\r\nstatic void ibmpex_bmc_gone(int iface)\r\n{\r\nstruct ibmpex_bmc_data *data = get_bmc_data(iface);\r\nif (!data)\r\nreturn;\r\nibmpex_bmc_delete(data);\r\n}\r\nstatic void ibmpex_msg_handler(struct ipmi_recv_msg *msg, void *user_msg_data)\r\n{\r\nstruct ibmpex_bmc_data *data = (struct ibmpex_bmc_data *)user_msg_data;\r\nif (msg->msgid != data->tx_msgid) {\r\ndev_err(data->bmc_device, "Mismatch between received msgid "\r\n"(%02x) and transmitted msgid (%02x)!\n",\r\n(int)msg->msgid,\r\n(int)data->tx_msgid);\r\nipmi_free_recv_msg(msg);\r\nreturn;\r\n}\r\ndata->rx_recv_type = msg->recv_type;\r\nif (msg->msg.data_len > 0)\r\ndata->rx_result = msg->msg.data[0];\r\nelse\r\ndata->rx_result = IPMI_UNKNOWN_ERR_COMPLETION_CODE;\r\nif (msg->msg.data_len > 1) {\r\ndata->rx_msg_len = msg->msg.data_len - 1;\r\nmemcpy(data->rx_msg_data, msg->msg.data + 1, data->rx_msg_len);\r\n} else\r\ndata->rx_msg_len = 0;\r\nipmi_free_recv_msg(msg);\r\ncomplete(&data->read_complete);\r\n}\r\nstatic int __init ibmpex_init(void)\r\n{\r\nreturn ipmi_smi_watcher_register(&driver_data.bmc_events);\r\n}\r\nstatic void __exit ibmpex_exit(void)\r\n{\r\nstruct ibmpex_bmc_data *p, *next;\r\nipmi_smi_watcher_unregister(&driver_data.bmc_events);\r\nlist_for_each_entry_safe(p, next, &driver_data.bmc_data, list)\r\nibmpex_bmc_delete(p);\r\n}
