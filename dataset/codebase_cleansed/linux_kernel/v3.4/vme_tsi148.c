static void reg_join(unsigned int high, unsigned int low,\r\nunsigned long long *variable)\r\n{\r\n*variable = (unsigned long long)high << 32;\r\n*variable |= (unsigned long long)low;\r\n}\r\nstatic void reg_split(unsigned long long variable, unsigned int *high,\r\nunsigned int *low)\r\n{\r\n*low = (unsigned int)variable & 0xFFFFFFFF;\r\n*high = (unsigned int)(variable >> 32);\r\n}\r\nstatic u32 tsi148_DMA_irqhandler(struct tsi148_driver *bridge,\r\nint channel_mask)\r\n{\r\nu32 serviced = 0;\r\nif (channel_mask & TSI148_LCSR_INTS_DMA0S) {\r\nwake_up(&bridge->dma_queue[0]);\r\nserviced |= TSI148_LCSR_INTC_DMA0C;\r\n}\r\nif (channel_mask & TSI148_LCSR_INTS_DMA1S) {\r\nwake_up(&bridge->dma_queue[1]);\r\nserviced |= TSI148_LCSR_INTC_DMA1C;\r\n}\r\nreturn serviced;\r\n}\r\nstatic u32 tsi148_LM_irqhandler(struct tsi148_driver *bridge, u32 stat)\r\n{\r\nint i;\r\nu32 serviced = 0;\r\nfor (i = 0; i < 4; i++) {\r\nif (stat & TSI148_LCSR_INTS_LMS[i]) {\r\nbridge->lm_callback[i](i);\r\nserviced |= TSI148_LCSR_INTC_LMC[i];\r\n}\r\n}\r\nreturn serviced;\r\n}\r\nstatic u32 tsi148_MB_irqhandler(struct vme_bridge *tsi148_bridge, u32 stat)\r\n{\r\nint i;\r\nu32 val;\r\nu32 serviced = 0;\r\nstruct tsi148_driver *bridge;\r\nbridge = tsi148_bridge->driver_priv;\r\nfor (i = 0; i < 4; i++) {\r\nif (stat & TSI148_LCSR_INTS_MBS[i]) {\r\nval = ioread32be(bridge->base + TSI148_GCSR_MBOX[i]);\r\ndev_err(tsi148_bridge->parent, "VME Mailbox %d received"\r\n": 0x%x\n", i, val);\r\nserviced |= TSI148_LCSR_INTC_MBC[i];\r\n}\r\n}\r\nreturn serviced;\r\n}\r\nstatic u32 tsi148_PERR_irqhandler(struct vme_bridge *tsi148_bridge)\r\n{\r\nstruct tsi148_driver *bridge;\r\nbridge = tsi148_bridge->driver_priv;\r\ndev_err(tsi148_bridge->parent, "PCI Exception at address: 0x%08x:%08x, "\r\n"attributes: %08x\n",\r\nioread32be(bridge->base + TSI148_LCSR_EDPAU),\r\nioread32be(bridge->base + TSI148_LCSR_EDPAL),\r\nioread32be(bridge->base + TSI148_LCSR_EDPAT));\r\ndev_err(tsi148_bridge->parent, "PCI-X attribute reg: %08x, PCI-X split "\r\n"completion reg: %08x\n",\r\nioread32be(bridge->base + TSI148_LCSR_EDPXA),\r\nioread32be(bridge->base + TSI148_LCSR_EDPXS));\r\niowrite32be(TSI148_LCSR_EDPAT_EDPCL, bridge->base + TSI148_LCSR_EDPAT);\r\nreturn TSI148_LCSR_INTC_PERRC;\r\n}\r\nstatic u32 tsi148_VERR_irqhandler(struct vme_bridge *tsi148_bridge)\r\n{\r\nunsigned int error_addr_high, error_addr_low;\r\nunsigned long long error_addr;\r\nu32 error_attrib;\r\nstruct vme_bus_error *error;\r\nstruct tsi148_driver *bridge;\r\nbridge = tsi148_bridge->driver_priv;\r\nerror_addr_high = ioread32be(bridge->base + TSI148_LCSR_VEAU);\r\nerror_addr_low = ioread32be(bridge->base + TSI148_LCSR_VEAL);\r\nerror_attrib = ioread32be(bridge->base + TSI148_LCSR_VEAT);\r\nreg_join(error_addr_high, error_addr_low, &error_addr);\r\nif (error_attrib & TSI148_LCSR_VEAT_VEOF) {\r\ndev_err(tsi148_bridge->parent, "VME Bus Exception Overflow "\r\n"Occurred\n");\r\n}\r\nerror = kmalloc(sizeof(struct vme_bus_error), GFP_ATOMIC);\r\nif (error) {\r\nerror->address = error_addr;\r\nerror->attributes = error_attrib;\r\nlist_add_tail(&error->list, &tsi148_bridge->vme_errors);\r\n} else {\r\ndev_err(tsi148_bridge->parent, "Unable to alloc memory for "\r\n"VMEbus Error reporting\n");\r\ndev_err(tsi148_bridge->parent, "VME Bus Error at address: "\r\n"0x%llx, attributes: %08x\n", error_addr, error_attrib);\r\n}\r\niowrite32be(TSI148_LCSR_VEAT_VESCL, bridge->base + TSI148_LCSR_VEAT);\r\nreturn TSI148_LCSR_INTC_VERRC;\r\n}\r\nstatic u32 tsi148_IACK_irqhandler(struct tsi148_driver *bridge)\r\n{\r\nwake_up(&bridge->iack_queue);\r\nreturn TSI148_LCSR_INTC_IACKC;\r\n}\r\nstatic u32 tsi148_VIRQ_irqhandler(struct vme_bridge *tsi148_bridge,\r\nu32 stat)\r\n{\r\nint vec, i, serviced = 0;\r\nstruct tsi148_driver *bridge;\r\nbridge = tsi148_bridge->driver_priv;\r\nfor (i = 7; i > 0; i--) {\r\nif (stat & (1 << i)) {\r\nvec = ioread8(bridge->base + TSI148_LCSR_VIACK[i] + 3);\r\nvme_irq_handler(tsi148_bridge, i, vec);\r\nserviced |= (1 << i);\r\n}\r\n}\r\nreturn serviced;\r\n}\r\nstatic irqreturn_t tsi148_irqhandler(int irq, void *ptr)\r\n{\r\nu32 stat, enable, serviced = 0;\r\nstruct vme_bridge *tsi148_bridge;\r\nstruct tsi148_driver *bridge;\r\ntsi148_bridge = ptr;\r\nbridge = tsi148_bridge->driver_priv;\r\nenable = ioread32be(bridge->base + TSI148_LCSR_INTEO);\r\nstat = ioread32be(bridge->base + TSI148_LCSR_INTS);\r\nstat &= enable;\r\nif (unlikely(!stat))\r\nreturn IRQ_NONE;\r\nif (stat & (TSI148_LCSR_INTS_DMA1S | TSI148_LCSR_INTS_DMA0S))\r\nserviced |= tsi148_DMA_irqhandler(bridge, stat);\r\nif (stat & (TSI148_LCSR_INTS_LM3S | TSI148_LCSR_INTS_LM2S |\r\nTSI148_LCSR_INTS_LM1S | TSI148_LCSR_INTS_LM0S))\r\nserviced |= tsi148_LM_irqhandler(bridge, stat);\r\nif (stat & (TSI148_LCSR_INTS_MB3S | TSI148_LCSR_INTS_MB2S |\r\nTSI148_LCSR_INTS_MB1S | TSI148_LCSR_INTS_MB0S))\r\nserviced |= tsi148_MB_irqhandler(tsi148_bridge, stat);\r\nif (stat & TSI148_LCSR_INTS_PERRS)\r\nserviced |= tsi148_PERR_irqhandler(tsi148_bridge);\r\nif (stat & TSI148_LCSR_INTS_VERRS)\r\nserviced |= tsi148_VERR_irqhandler(tsi148_bridge);\r\nif (stat & TSI148_LCSR_INTS_IACKS)\r\nserviced |= tsi148_IACK_irqhandler(bridge);\r\nif (stat & (TSI148_LCSR_INTS_IRQ7S | TSI148_LCSR_INTS_IRQ6S |\r\nTSI148_LCSR_INTS_IRQ5S | TSI148_LCSR_INTS_IRQ4S |\r\nTSI148_LCSR_INTS_IRQ3S | TSI148_LCSR_INTS_IRQ2S |\r\nTSI148_LCSR_INTS_IRQ1S))\r\nserviced |= tsi148_VIRQ_irqhandler(tsi148_bridge, stat);\r\niowrite32be(serviced, bridge->base + TSI148_LCSR_INTC);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tsi148_irq_init(struct vme_bridge *tsi148_bridge)\r\n{\r\nint result;\r\nunsigned int tmp;\r\nstruct pci_dev *pdev;\r\nstruct tsi148_driver *bridge;\r\npdev = container_of(tsi148_bridge->parent, struct pci_dev, dev);\r\nbridge = tsi148_bridge->driver_priv;\r\nINIT_LIST_HEAD(&tsi148_bridge->vme_errors);\r\nmutex_init(&tsi148_bridge->irq_mtx);\r\nresult = request_irq(pdev->irq,\r\ntsi148_irqhandler,\r\nIRQF_SHARED,\r\ndriver_name, tsi148_bridge);\r\nif (result) {\r\ndev_err(tsi148_bridge->parent, "Can't get assigned pci irq "\r\n"vector %02X\n", pdev->irq);\r\nreturn result;\r\n}\r\ntmp = TSI148_LCSR_INTEO_DMA1EO | TSI148_LCSR_INTEO_DMA0EO |\r\nTSI148_LCSR_INTEO_MB3EO | TSI148_LCSR_INTEO_MB2EO |\r\nTSI148_LCSR_INTEO_MB1EO | TSI148_LCSR_INTEO_MB0EO |\r\nTSI148_LCSR_INTEO_PERREO | TSI148_LCSR_INTEO_VERREO |\r\nTSI148_LCSR_INTEO_IACKEO;\r\niowrite32be(tmp, bridge->base + TSI148_LCSR_INTEO);\r\niowrite32be(tmp, bridge->base + TSI148_LCSR_INTEN);\r\nreturn 0;\r\n}\r\nstatic void tsi148_irq_exit(struct vme_bridge *tsi148_bridge,\r\nstruct pci_dev *pdev)\r\n{\r\nstruct tsi148_driver *bridge = tsi148_bridge->driver_priv;\r\niowrite32be(0x0, bridge->base + TSI148_LCSR_INTEO);\r\niowrite32be(0x0, bridge->base + TSI148_LCSR_INTEN);\r\niowrite32be(0xFFFFFFFF, bridge->base + TSI148_LCSR_INTC);\r\nfree_irq(pdev->irq, tsi148_bridge);\r\n}\r\nstatic int tsi148_iack_received(struct tsi148_driver *bridge)\r\n{\r\nu32 tmp;\r\ntmp = ioread32be(bridge->base + TSI148_LCSR_VICR);\r\nif (tmp & TSI148_LCSR_VICR_IRQS)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic void tsi148_irq_set(struct vme_bridge *tsi148_bridge, int level,\r\nint state, int sync)\r\n{\r\nstruct pci_dev *pdev;\r\nu32 tmp;\r\nstruct tsi148_driver *bridge;\r\nbridge = tsi148_bridge->driver_priv;\r\nif (state == 0) {\r\ntmp = ioread32be(bridge->base + TSI148_LCSR_INTEN);\r\ntmp &= ~TSI148_LCSR_INTEN_IRQEN[level - 1];\r\niowrite32be(tmp, bridge->base + TSI148_LCSR_INTEN);\r\ntmp = ioread32be(bridge->base + TSI148_LCSR_INTEO);\r\ntmp &= ~TSI148_LCSR_INTEO_IRQEO[level - 1];\r\niowrite32be(tmp, bridge->base + TSI148_LCSR_INTEO);\r\nif (sync != 0) {\r\npdev = container_of(tsi148_bridge->parent,\r\nstruct pci_dev, dev);\r\nsynchronize_irq(pdev->irq);\r\n}\r\n} else {\r\ntmp = ioread32be(bridge->base + TSI148_LCSR_INTEO);\r\ntmp |= TSI148_LCSR_INTEO_IRQEO[level - 1];\r\niowrite32be(tmp, bridge->base + TSI148_LCSR_INTEO);\r\ntmp = ioread32be(bridge->base + TSI148_LCSR_INTEN);\r\ntmp |= TSI148_LCSR_INTEN_IRQEN[level - 1];\r\niowrite32be(tmp, bridge->base + TSI148_LCSR_INTEN);\r\n}\r\n}\r\nstatic int tsi148_irq_generate(struct vme_bridge *tsi148_bridge, int level,\r\nint statid)\r\n{\r\nu32 tmp;\r\nstruct tsi148_driver *bridge;\r\nbridge = tsi148_bridge->driver_priv;\r\nmutex_lock(&bridge->vme_int);\r\ntmp = ioread32be(bridge->base + TSI148_LCSR_VICR);\r\ntmp = (tmp & ~TSI148_LCSR_VICR_STID_M) |\r\n(statid & TSI148_LCSR_VICR_STID_M);\r\niowrite32be(tmp, bridge->base + TSI148_LCSR_VICR);\r\ntmp = tmp | TSI148_LCSR_VICR_IRQL[level];\r\niowrite32be(tmp, bridge->base + TSI148_LCSR_VICR);\r\nwait_event_interruptible(bridge->iack_queue,\r\ntsi148_iack_received(bridge));\r\nmutex_unlock(&bridge->vme_int);\r\nreturn 0;\r\n}\r\nstatic struct vme_bus_error *tsi148_find_error(struct vme_bridge *tsi148_bridge,\r\nu32 aspace, unsigned long long address, size_t count)\r\n{\r\nstruct list_head *err_pos;\r\nstruct vme_bus_error *vme_err, *valid = NULL;\r\nunsigned long long bound;\r\nbound = address + count;\r\nerr_pos = NULL;\r\nlist_for_each(err_pos, &tsi148_bridge->vme_errors) {\r\nvme_err = list_entry(err_pos, struct vme_bus_error, list);\r\nif ((vme_err->address >= address) &&\r\n(vme_err->address < bound)) {\r\nvalid = vme_err;\r\nbreak;\r\n}\r\n}\r\nreturn valid;\r\n}\r\nstatic void tsi148_clear_errors(struct vme_bridge *tsi148_bridge,\r\nu32 aspace, unsigned long long address, size_t count)\r\n{\r\nstruct list_head *err_pos, *temp;\r\nstruct vme_bus_error *vme_err;\r\nunsigned long long bound;\r\nbound = address + count;\r\nerr_pos = NULL;\r\nlist_for_each_safe(err_pos, temp, &tsi148_bridge->vme_errors) {\r\nvme_err = list_entry(err_pos, struct vme_bus_error, list);\r\nif ((vme_err->address >= address) &&\r\n(vme_err->address < bound)) {\r\nlist_del(err_pos);\r\nkfree(vme_err);\r\n}\r\n}\r\n}\r\nstatic int tsi148_slave_set(struct vme_slave_resource *image, int enabled,\r\nunsigned long long vme_base, unsigned long long size,\r\ndma_addr_t pci_base, u32 aspace, u32 cycle)\r\n{\r\nunsigned int i, addr = 0, granularity = 0;\r\nunsigned int temp_ctl = 0;\r\nunsigned int vme_base_low, vme_base_high;\r\nunsigned int vme_bound_low, vme_bound_high;\r\nunsigned int pci_offset_low, pci_offset_high;\r\nunsigned long long vme_bound, pci_offset;\r\nstruct vme_bridge *tsi148_bridge;\r\nstruct tsi148_driver *bridge;\r\ntsi148_bridge = image->parent;\r\nbridge = tsi148_bridge->driver_priv;\r\ni = image->number;\r\nswitch (aspace) {\r\ncase VME_A16:\r\ngranularity = 0x10;\r\naddr |= TSI148_LCSR_ITAT_AS_A16;\r\nbreak;\r\ncase VME_A24:\r\ngranularity = 0x1000;\r\naddr |= TSI148_LCSR_ITAT_AS_A24;\r\nbreak;\r\ncase VME_A32:\r\ngranularity = 0x10000;\r\naddr |= TSI148_LCSR_ITAT_AS_A32;\r\nbreak;\r\ncase VME_A64:\r\ngranularity = 0x10000;\r\naddr |= TSI148_LCSR_ITAT_AS_A64;\r\nbreak;\r\ncase VME_CRCSR:\r\ncase VME_USER1:\r\ncase VME_USER2:\r\ncase VME_USER3:\r\ncase VME_USER4:\r\ndefault:\r\ndev_err(tsi148_bridge->parent, "Invalid address space\n");\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreg_split(vme_base, &vme_base_high, &vme_base_low);\r\nvme_bound = vme_base + size - granularity;\r\nreg_split(vme_bound, &vme_bound_high, &vme_bound_low);\r\npci_offset = (unsigned long long)pci_base - vme_base;\r\nreg_split(pci_offset, &pci_offset_high, &pci_offset_low);\r\nif (vme_base_low & (granularity - 1)) {\r\ndev_err(tsi148_bridge->parent, "Invalid VME base alignment\n");\r\nreturn -EINVAL;\r\n}\r\nif (vme_bound_low & (granularity - 1)) {\r\ndev_err(tsi148_bridge->parent, "Invalid VME bound alignment\n");\r\nreturn -EINVAL;\r\n}\r\nif (pci_offset_low & (granularity - 1)) {\r\ndev_err(tsi148_bridge->parent, "Invalid PCI Offset "\r\n"alignment\n");\r\nreturn -EINVAL;\r\n}\r\ntemp_ctl = ioread32be(bridge->base + TSI148_LCSR_IT[i] +\r\nTSI148_LCSR_OFFSET_ITAT);\r\ntemp_ctl &= ~TSI148_LCSR_ITAT_EN;\r\niowrite32be(temp_ctl, bridge->base + TSI148_LCSR_IT[i] +\r\nTSI148_LCSR_OFFSET_ITAT);\r\niowrite32be(vme_base_high, bridge->base + TSI148_LCSR_IT[i] +\r\nTSI148_LCSR_OFFSET_ITSAU);\r\niowrite32be(vme_base_low, bridge->base + TSI148_LCSR_IT[i] +\r\nTSI148_LCSR_OFFSET_ITSAL);\r\niowrite32be(vme_bound_high, bridge->base + TSI148_LCSR_IT[i] +\r\nTSI148_LCSR_OFFSET_ITEAU);\r\niowrite32be(vme_bound_low, bridge->base + TSI148_LCSR_IT[i] +\r\nTSI148_LCSR_OFFSET_ITEAL);\r\niowrite32be(pci_offset_high, bridge->base + TSI148_LCSR_IT[i] +\r\nTSI148_LCSR_OFFSET_ITOFU);\r\niowrite32be(pci_offset_low, bridge->base + TSI148_LCSR_IT[i] +\r\nTSI148_LCSR_OFFSET_ITOFL);\r\ntemp_ctl &= ~TSI148_LCSR_ITAT_2eSSTM_M;\r\nswitch (cycle & (VME_2eSST160 | VME_2eSST267 | VME_2eSST320)) {\r\ncase VME_2eSST160:\r\ntemp_ctl |= TSI148_LCSR_ITAT_2eSSTM_160;\r\nbreak;\r\ncase VME_2eSST267:\r\ntemp_ctl |= TSI148_LCSR_ITAT_2eSSTM_267;\r\nbreak;\r\ncase VME_2eSST320:\r\ntemp_ctl |= TSI148_LCSR_ITAT_2eSSTM_320;\r\nbreak;\r\n}\r\ntemp_ctl &= ~(0x1F << 7);\r\nif (cycle & VME_BLT)\r\ntemp_ctl |= TSI148_LCSR_ITAT_BLT;\r\nif (cycle & VME_MBLT)\r\ntemp_ctl |= TSI148_LCSR_ITAT_MBLT;\r\nif (cycle & VME_2eVME)\r\ntemp_ctl |= TSI148_LCSR_ITAT_2eVME;\r\nif (cycle & VME_2eSST)\r\ntemp_ctl |= TSI148_LCSR_ITAT_2eSST;\r\nif (cycle & VME_2eSSTB)\r\ntemp_ctl |= TSI148_LCSR_ITAT_2eSSTB;\r\ntemp_ctl &= ~TSI148_LCSR_ITAT_AS_M;\r\ntemp_ctl |= addr;\r\ntemp_ctl &= ~0xF;\r\nif (cycle & VME_SUPER)\r\ntemp_ctl |= TSI148_LCSR_ITAT_SUPR ;\r\nif (cycle & VME_USER)\r\ntemp_ctl |= TSI148_LCSR_ITAT_NPRIV;\r\nif (cycle & VME_PROG)\r\ntemp_ctl |= TSI148_LCSR_ITAT_PGM;\r\nif (cycle & VME_DATA)\r\ntemp_ctl |= TSI148_LCSR_ITAT_DATA;\r\niowrite32be(temp_ctl, bridge->base + TSI148_LCSR_IT[i] +\r\nTSI148_LCSR_OFFSET_ITAT);\r\nif (enabled)\r\ntemp_ctl |= TSI148_LCSR_ITAT_EN;\r\niowrite32be(temp_ctl, bridge->base + TSI148_LCSR_IT[i] +\r\nTSI148_LCSR_OFFSET_ITAT);\r\nreturn 0;\r\n}\r\nstatic int tsi148_slave_get(struct vme_slave_resource *image, int *enabled,\r\nunsigned long long *vme_base, unsigned long long *size,\r\ndma_addr_t *pci_base, u32 *aspace, u32 *cycle)\r\n{\r\nunsigned int i, granularity = 0, ctl = 0;\r\nunsigned int vme_base_low, vme_base_high;\r\nunsigned int vme_bound_low, vme_bound_high;\r\nunsigned int pci_offset_low, pci_offset_high;\r\nunsigned long long vme_bound, pci_offset;\r\nstruct tsi148_driver *bridge;\r\nbridge = image->parent->driver_priv;\r\ni = image->number;\r\nctl = ioread32be(bridge->base + TSI148_LCSR_IT[i] +\r\nTSI148_LCSR_OFFSET_ITAT);\r\nvme_base_high = ioread32be(bridge->base + TSI148_LCSR_IT[i] +\r\nTSI148_LCSR_OFFSET_ITSAU);\r\nvme_base_low = ioread32be(bridge->base + TSI148_LCSR_IT[i] +\r\nTSI148_LCSR_OFFSET_ITSAL);\r\nvme_bound_high = ioread32be(bridge->base + TSI148_LCSR_IT[i] +\r\nTSI148_LCSR_OFFSET_ITEAU);\r\nvme_bound_low = ioread32be(bridge->base + TSI148_LCSR_IT[i] +\r\nTSI148_LCSR_OFFSET_ITEAL);\r\npci_offset_high = ioread32be(bridge->base + TSI148_LCSR_IT[i] +\r\nTSI148_LCSR_OFFSET_ITOFU);\r\npci_offset_low = ioread32be(bridge->base + TSI148_LCSR_IT[i] +\r\nTSI148_LCSR_OFFSET_ITOFL);\r\nreg_join(vme_base_high, vme_base_low, vme_base);\r\nreg_join(vme_bound_high, vme_bound_low, &vme_bound);\r\nreg_join(pci_offset_high, pci_offset_low, &pci_offset);\r\n*pci_base = (dma_addr_t)vme_base + pci_offset;\r\n*enabled = 0;\r\n*aspace = 0;\r\n*cycle = 0;\r\nif (ctl & TSI148_LCSR_ITAT_EN)\r\n*enabled = 1;\r\nif ((ctl & TSI148_LCSR_ITAT_AS_M) == TSI148_LCSR_ITAT_AS_A16) {\r\ngranularity = 0x10;\r\n*aspace |= VME_A16;\r\n}\r\nif ((ctl & TSI148_LCSR_ITAT_AS_M) == TSI148_LCSR_ITAT_AS_A24) {\r\ngranularity = 0x1000;\r\n*aspace |= VME_A24;\r\n}\r\nif ((ctl & TSI148_LCSR_ITAT_AS_M) == TSI148_LCSR_ITAT_AS_A32) {\r\ngranularity = 0x10000;\r\n*aspace |= VME_A32;\r\n}\r\nif ((ctl & TSI148_LCSR_ITAT_AS_M) == TSI148_LCSR_ITAT_AS_A64) {\r\ngranularity = 0x10000;\r\n*aspace |= VME_A64;\r\n}\r\n*size = (unsigned long long)((vme_bound - *vme_base) + granularity);\r\nif ((ctl & TSI148_LCSR_ITAT_2eSSTM_M) == TSI148_LCSR_ITAT_2eSSTM_160)\r\n*cycle |= VME_2eSST160;\r\nif ((ctl & TSI148_LCSR_ITAT_2eSSTM_M) == TSI148_LCSR_ITAT_2eSSTM_267)\r\n*cycle |= VME_2eSST267;\r\nif ((ctl & TSI148_LCSR_ITAT_2eSSTM_M) == TSI148_LCSR_ITAT_2eSSTM_320)\r\n*cycle |= VME_2eSST320;\r\nif (ctl & TSI148_LCSR_ITAT_BLT)\r\n*cycle |= VME_BLT;\r\nif (ctl & TSI148_LCSR_ITAT_MBLT)\r\n*cycle |= VME_MBLT;\r\nif (ctl & TSI148_LCSR_ITAT_2eVME)\r\n*cycle |= VME_2eVME;\r\nif (ctl & TSI148_LCSR_ITAT_2eSST)\r\n*cycle |= VME_2eSST;\r\nif (ctl & TSI148_LCSR_ITAT_2eSSTB)\r\n*cycle |= VME_2eSSTB;\r\nif (ctl & TSI148_LCSR_ITAT_SUPR)\r\n*cycle |= VME_SUPER;\r\nif (ctl & TSI148_LCSR_ITAT_NPRIV)\r\n*cycle |= VME_USER;\r\nif (ctl & TSI148_LCSR_ITAT_PGM)\r\n*cycle |= VME_PROG;\r\nif (ctl & TSI148_LCSR_ITAT_DATA)\r\n*cycle |= VME_DATA;\r\nreturn 0;\r\n}\r\nstatic int tsi148_alloc_resource(struct vme_master_resource *image,\r\nunsigned long long size)\r\n{\r\nunsigned long long existing_size;\r\nint retval = 0;\r\nstruct pci_dev *pdev;\r\nstruct vme_bridge *tsi148_bridge;\r\ntsi148_bridge = image->parent;\r\npdev = container_of(tsi148_bridge->parent, struct pci_dev, dev);\r\nexisting_size = (unsigned long long)(image->bus_resource.end -\r\nimage->bus_resource.start);\r\nif ((size != 0) && (existing_size == (size - 1)))\r\nreturn 0;\r\nif (existing_size != 0) {\r\niounmap(image->kern_base);\r\nimage->kern_base = NULL;\r\nkfree(image->bus_resource.name);\r\nrelease_resource(&image->bus_resource);\r\nmemset(&image->bus_resource, 0, sizeof(struct resource));\r\n}\r\nif (size == 0)\r\nreturn 0;\r\nif (image->bus_resource.name == NULL) {\r\nimage->bus_resource.name = kmalloc(VMENAMSIZ+3, GFP_ATOMIC);\r\nif (image->bus_resource.name == NULL) {\r\ndev_err(tsi148_bridge->parent, "Unable to allocate "\r\n"memory for resource name\n");\r\nretval = -ENOMEM;\r\ngoto err_name;\r\n}\r\n}\r\nsprintf((char *)image->bus_resource.name, "%s.%d", tsi148_bridge->name,\r\nimage->number);\r\nimage->bus_resource.start = 0;\r\nimage->bus_resource.end = (unsigned long)size;\r\nimage->bus_resource.flags = IORESOURCE_MEM;\r\nretval = pci_bus_alloc_resource(pdev->bus,\r\n&image->bus_resource, size, size, PCIBIOS_MIN_MEM,\r\n0, NULL, NULL);\r\nif (retval) {\r\ndev_err(tsi148_bridge->parent, "Failed to allocate mem "\r\n"resource for window %d size 0x%lx start 0x%lx\n",\r\nimage->number, (unsigned long)size,\r\n(unsigned long)image->bus_resource.start);\r\ngoto err_resource;\r\n}\r\nimage->kern_base = ioremap_nocache(\r\nimage->bus_resource.start, size);\r\nif (image->kern_base == NULL) {\r\ndev_err(tsi148_bridge->parent, "Failed to remap resource\n");\r\nretval = -ENOMEM;\r\ngoto err_remap;\r\n}\r\nreturn 0;\r\nerr_remap:\r\nrelease_resource(&image->bus_resource);\r\nerr_resource:\r\nkfree(image->bus_resource.name);\r\nmemset(&image->bus_resource, 0, sizeof(struct resource));\r\nerr_name:\r\nreturn retval;\r\n}\r\nstatic void tsi148_free_resource(struct vme_master_resource *image)\r\n{\r\niounmap(image->kern_base);\r\nimage->kern_base = NULL;\r\nrelease_resource(&image->bus_resource);\r\nkfree(image->bus_resource.name);\r\nmemset(&image->bus_resource, 0, sizeof(struct resource));\r\n}\r\nstatic int tsi148_master_set(struct vme_master_resource *image, int enabled,\r\nunsigned long long vme_base, unsigned long long size, u32 aspace,\r\nu32 cycle, u32 dwidth)\r\n{\r\nint retval = 0;\r\nunsigned int i;\r\nunsigned int temp_ctl = 0;\r\nunsigned int pci_base_low, pci_base_high;\r\nunsigned int pci_bound_low, pci_bound_high;\r\nunsigned int vme_offset_low, vme_offset_high;\r\nunsigned long long pci_bound, vme_offset, pci_base;\r\nstruct vme_bridge *tsi148_bridge;\r\nstruct tsi148_driver *bridge;\r\ntsi148_bridge = image->parent;\r\nbridge = tsi148_bridge->driver_priv;\r\nif (vme_base & 0xFFFF) {\r\ndev_err(tsi148_bridge->parent, "Invalid VME Window "\r\n"alignment\n");\r\nretval = -EINVAL;\r\ngoto err_window;\r\n}\r\nif ((size == 0) && (enabled != 0)) {\r\ndev_err(tsi148_bridge->parent, "Size must be non-zero for "\r\n"enabled windows\n");\r\nretval = -EINVAL;\r\ngoto err_window;\r\n}\r\nspin_lock(&image->lock);\r\nretval = tsi148_alloc_resource(image, size);\r\nif (retval) {\r\nspin_unlock(&image->lock);\r\ndev_err(tsi148_bridge->parent, "Unable to allocate memory for "\r\n"resource\n");\r\ngoto err_res;\r\n}\r\nif (size == 0) {\r\npci_base = 0;\r\npci_bound = 0;\r\nvme_offset = 0;\r\n} else {\r\npci_base = (unsigned long long)image->bus_resource.start;\r\npci_bound = pci_base + (size - 0x10000);\r\nvme_offset = vme_base - pci_base;\r\n}\r\nreg_split(pci_base, &pci_base_high, &pci_base_low);\r\nreg_split(pci_bound, &pci_bound_high, &pci_bound_low);\r\nreg_split(vme_offset, &vme_offset_high, &vme_offset_low);\r\nif (pci_base_low & 0xFFFF) {\r\nspin_unlock(&image->lock);\r\ndev_err(tsi148_bridge->parent, "Invalid PCI base alignment\n");\r\nretval = -EINVAL;\r\ngoto err_gran;\r\n}\r\nif (pci_bound_low & 0xFFFF) {\r\nspin_unlock(&image->lock);\r\ndev_err(tsi148_bridge->parent, "Invalid PCI bound alignment\n");\r\nretval = -EINVAL;\r\ngoto err_gran;\r\n}\r\nif (vme_offset_low & 0xFFFF) {\r\nspin_unlock(&image->lock);\r\ndev_err(tsi148_bridge->parent, "Invalid VME Offset "\r\n"alignment\n");\r\nretval = -EINVAL;\r\ngoto err_gran;\r\n}\r\ni = image->number;\r\ntemp_ctl = ioread32be(bridge->base + TSI148_LCSR_OT[i] +\r\nTSI148_LCSR_OFFSET_OTAT);\r\ntemp_ctl &= ~TSI148_LCSR_OTAT_EN;\r\niowrite32be(temp_ctl, bridge->base + TSI148_LCSR_OT[i] +\r\nTSI148_LCSR_OFFSET_OTAT);\r\ntemp_ctl &= ~TSI148_LCSR_OTAT_2eSSTM_M;\r\nswitch (cycle & (VME_2eSST160 | VME_2eSST267 | VME_2eSST320)) {\r\ncase VME_2eSST160:\r\ntemp_ctl |= TSI148_LCSR_OTAT_2eSSTM_160;\r\nbreak;\r\ncase VME_2eSST267:\r\ntemp_ctl |= TSI148_LCSR_OTAT_2eSSTM_267;\r\nbreak;\r\ncase VME_2eSST320:\r\ntemp_ctl |= TSI148_LCSR_OTAT_2eSSTM_320;\r\nbreak;\r\n}\r\nif (cycle & VME_BLT) {\r\ntemp_ctl &= ~TSI148_LCSR_OTAT_TM_M;\r\ntemp_ctl |= TSI148_LCSR_OTAT_TM_BLT;\r\n}\r\nif (cycle & VME_MBLT) {\r\ntemp_ctl &= ~TSI148_LCSR_OTAT_TM_M;\r\ntemp_ctl |= TSI148_LCSR_OTAT_TM_MBLT;\r\n}\r\nif (cycle & VME_2eVME) {\r\ntemp_ctl &= ~TSI148_LCSR_OTAT_TM_M;\r\ntemp_ctl |= TSI148_LCSR_OTAT_TM_2eVME;\r\n}\r\nif (cycle & VME_2eSST) {\r\ntemp_ctl &= ~TSI148_LCSR_OTAT_TM_M;\r\ntemp_ctl |= TSI148_LCSR_OTAT_TM_2eSST;\r\n}\r\nif (cycle & VME_2eSSTB) {\r\ndev_warn(tsi148_bridge->parent, "Currently not setting "\r\n"Broadcast Select Registers\n");\r\ntemp_ctl &= ~TSI148_LCSR_OTAT_TM_M;\r\ntemp_ctl |= TSI148_LCSR_OTAT_TM_2eSSTB;\r\n}\r\ntemp_ctl &= ~TSI148_LCSR_OTAT_DBW_M;\r\nswitch (dwidth) {\r\ncase VME_D16:\r\ntemp_ctl |= TSI148_LCSR_OTAT_DBW_16;\r\nbreak;\r\ncase VME_D32:\r\ntemp_ctl |= TSI148_LCSR_OTAT_DBW_32;\r\nbreak;\r\ndefault:\r\nspin_unlock(&image->lock);\r\ndev_err(tsi148_bridge->parent, "Invalid data width\n");\r\nretval = -EINVAL;\r\ngoto err_dwidth;\r\n}\r\ntemp_ctl &= ~TSI148_LCSR_OTAT_AMODE_M;\r\nswitch (aspace) {\r\ncase VME_A16:\r\ntemp_ctl |= TSI148_LCSR_OTAT_AMODE_A16;\r\nbreak;\r\ncase VME_A24:\r\ntemp_ctl |= TSI148_LCSR_OTAT_AMODE_A24;\r\nbreak;\r\ncase VME_A32:\r\ntemp_ctl |= TSI148_LCSR_OTAT_AMODE_A32;\r\nbreak;\r\ncase VME_A64:\r\ntemp_ctl |= TSI148_LCSR_OTAT_AMODE_A64;\r\nbreak;\r\ncase VME_CRCSR:\r\ntemp_ctl |= TSI148_LCSR_OTAT_AMODE_CRCSR;\r\nbreak;\r\ncase VME_USER1:\r\ntemp_ctl |= TSI148_LCSR_OTAT_AMODE_USER1;\r\nbreak;\r\ncase VME_USER2:\r\ntemp_ctl |= TSI148_LCSR_OTAT_AMODE_USER2;\r\nbreak;\r\ncase VME_USER3:\r\ntemp_ctl |= TSI148_LCSR_OTAT_AMODE_USER3;\r\nbreak;\r\ncase VME_USER4:\r\ntemp_ctl |= TSI148_LCSR_OTAT_AMODE_USER4;\r\nbreak;\r\ndefault:\r\nspin_unlock(&image->lock);\r\ndev_err(tsi148_bridge->parent, "Invalid address space\n");\r\nretval = -EINVAL;\r\ngoto err_aspace;\r\nbreak;\r\n}\r\ntemp_ctl &= ~(3<<4);\r\nif (cycle & VME_SUPER)\r\ntemp_ctl |= TSI148_LCSR_OTAT_SUP;\r\nif (cycle & VME_PROG)\r\ntemp_ctl |= TSI148_LCSR_OTAT_PGM;\r\niowrite32be(pci_base_high, bridge->base + TSI148_LCSR_OT[i] +\r\nTSI148_LCSR_OFFSET_OTSAU);\r\niowrite32be(pci_base_low, bridge->base + TSI148_LCSR_OT[i] +\r\nTSI148_LCSR_OFFSET_OTSAL);\r\niowrite32be(pci_bound_high, bridge->base + TSI148_LCSR_OT[i] +\r\nTSI148_LCSR_OFFSET_OTEAU);\r\niowrite32be(pci_bound_low, bridge->base + TSI148_LCSR_OT[i] +\r\nTSI148_LCSR_OFFSET_OTEAL);\r\niowrite32be(vme_offset_high, bridge->base + TSI148_LCSR_OT[i] +\r\nTSI148_LCSR_OFFSET_OTOFU);\r\niowrite32be(vme_offset_low, bridge->base + TSI148_LCSR_OT[i] +\r\nTSI148_LCSR_OFFSET_OTOFL);\r\niowrite32be(temp_ctl, bridge->base + TSI148_LCSR_OT[i] +\r\nTSI148_LCSR_OFFSET_OTAT);\r\nif (enabled)\r\ntemp_ctl |= TSI148_LCSR_OTAT_EN;\r\niowrite32be(temp_ctl, bridge->base + TSI148_LCSR_OT[i] +\r\nTSI148_LCSR_OFFSET_OTAT);\r\nspin_unlock(&image->lock);\r\nreturn 0;\r\nerr_aspace:\r\nerr_dwidth:\r\nerr_gran:\r\ntsi148_free_resource(image);\r\nerr_res:\r\nerr_window:\r\nreturn retval;\r\n}\r\nstatic int __tsi148_master_get(struct vme_master_resource *image, int *enabled,\r\nunsigned long long *vme_base, unsigned long long *size, u32 *aspace,\r\nu32 *cycle, u32 *dwidth)\r\n{\r\nunsigned int i, ctl;\r\nunsigned int pci_base_low, pci_base_high;\r\nunsigned int pci_bound_low, pci_bound_high;\r\nunsigned int vme_offset_low, vme_offset_high;\r\nunsigned long long pci_base, pci_bound, vme_offset;\r\nstruct tsi148_driver *bridge;\r\nbridge = image->parent->driver_priv;\r\ni = image->number;\r\nctl = ioread32be(bridge->base + TSI148_LCSR_OT[i] +\r\nTSI148_LCSR_OFFSET_OTAT);\r\npci_base_high = ioread32be(bridge->base + TSI148_LCSR_OT[i] +\r\nTSI148_LCSR_OFFSET_OTSAU);\r\npci_base_low = ioread32be(bridge->base + TSI148_LCSR_OT[i] +\r\nTSI148_LCSR_OFFSET_OTSAL);\r\npci_bound_high = ioread32be(bridge->base + TSI148_LCSR_OT[i] +\r\nTSI148_LCSR_OFFSET_OTEAU);\r\npci_bound_low = ioread32be(bridge->base + TSI148_LCSR_OT[i] +\r\nTSI148_LCSR_OFFSET_OTEAL);\r\nvme_offset_high = ioread32be(bridge->base + TSI148_LCSR_OT[i] +\r\nTSI148_LCSR_OFFSET_OTOFU);\r\nvme_offset_low = ioread32be(bridge->base + TSI148_LCSR_OT[i] +\r\nTSI148_LCSR_OFFSET_OTOFL);\r\nreg_join(pci_base_high, pci_base_low, &pci_base);\r\nreg_join(pci_bound_high, pci_bound_low, &pci_bound);\r\nreg_join(vme_offset_high, vme_offset_low, &vme_offset);\r\n*vme_base = pci_base + vme_offset;\r\n*size = (unsigned long long)(pci_bound - pci_base) + 0x10000;\r\n*enabled = 0;\r\n*aspace = 0;\r\n*cycle = 0;\r\n*dwidth = 0;\r\nif (ctl & TSI148_LCSR_OTAT_EN)\r\n*enabled = 1;\r\nif ((ctl & TSI148_LCSR_OTAT_AMODE_M) == TSI148_LCSR_OTAT_AMODE_A16)\r\n*aspace |= VME_A16;\r\nif ((ctl & TSI148_LCSR_OTAT_AMODE_M) == TSI148_LCSR_OTAT_AMODE_A24)\r\n*aspace |= VME_A24;\r\nif ((ctl & TSI148_LCSR_OTAT_AMODE_M) == TSI148_LCSR_OTAT_AMODE_A32)\r\n*aspace |= VME_A32;\r\nif ((ctl & TSI148_LCSR_OTAT_AMODE_M) == TSI148_LCSR_OTAT_AMODE_A64)\r\n*aspace |= VME_A64;\r\nif ((ctl & TSI148_LCSR_OTAT_AMODE_M) == TSI148_LCSR_OTAT_AMODE_CRCSR)\r\n*aspace |= VME_CRCSR;\r\nif ((ctl & TSI148_LCSR_OTAT_AMODE_M) == TSI148_LCSR_OTAT_AMODE_USER1)\r\n*aspace |= VME_USER1;\r\nif ((ctl & TSI148_LCSR_OTAT_AMODE_M) == TSI148_LCSR_OTAT_AMODE_USER2)\r\n*aspace |= VME_USER2;\r\nif ((ctl & TSI148_LCSR_OTAT_AMODE_M) == TSI148_LCSR_OTAT_AMODE_USER3)\r\n*aspace |= VME_USER3;\r\nif ((ctl & TSI148_LCSR_OTAT_AMODE_M) == TSI148_LCSR_OTAT_AMODE_USER4)\r\n*aspace |= VME_USER4;\r\nif ((ctl & TSI148_LCSR_OTAT_2eSSTM_M) == TSI148_LCSR_OTAT_2eSSTM_160)\r\n*cycle |= VME_2eSST160;\r\nif ((ctl & TSI148_LCSR_OTAT_2eSSTM_M) == TSI148_LCSR_OTAT_2eSSTM_267)\r\n*cycle |= VME_2eSST267;\r\nif ((ctl & TSI148_LCSR_OTAT_2eSSTM_M) == TSI148_LCSR_OTAT_2eSSTM_320)\r\n*cycle |= VME_2eSST320;\r\nif ((ctl & TSI148_LCSR_OTAT_TM_M) == TSI148_LCSR_OTAT_TM_SCT)\r\n*cycle |= VME_SCT;\r\nif ((ctl & TSI148_LCSR_OTAT_TM_M) == TSI148_LCSR_OTAT_TM_BLT)\r\n*cycle |= VME_BLT;\r\nif ((ctl & TSI148_LCSR_OTAT_TM_M) == TSI148_LCSR_OTAT_TM_MBLT)\r\n*cycle |= VME_MBLT;\r\nif ((ctl & TSI148_LCSR_OTAT_TM_M) == TSI148_LCSR_OTAT_TM_2eVME)\r\n*cycle |= VME_2eVME;\r\nif ((ctl & TSI148_LCSR_OTAT_TM_M) == TSI148_LCSR_OTAT_TM_2eSST)\r\n*cycle |= VME_2eSST;\r\nif ((ctl & TSI148_LCSR_OTAT_TM_M) == TSI148_LCSR_OTAT_TM_2eSSTB)\r\n*cycle |= VME_2eSSTB;\r\nif (ctl & TSI148_LCSR_OTAT_SUP)\r\n*cycle |= VME_SUPER;\r\nelse\r\n*cycle |= VME_USER;\r\nif (ctl & TSI148_LCSR_OTAT_PGM)\r\n*cycle |= VME_PROG;\r\nelse\r\n*cycle |= VME_DATA;\r\nif ((ctl & TSI148_LCSR_OTAT_DBW_M) == TSI148_LCSR_OTAT_DBW_16)\r\n*dwidth = VME_D16;\r\nif ((ctl & TSI148_LCSR_OTAT_DBW_M) == TSI148_LCSR_OTAT_DBW_32)\r\n*dwidth = VME_D32;\r\nreturn 0;\r\n}\r\nstatic int tsi148_master_get(struct vme_master_resource *image, int *enabled,\r\nunsigned long long *vme_base, unsigned long long *size, u32 *aspace,\r\nu32 *cycle, u32 *dwidth)\r\n{\r\nint retval;\r\nspin_lock(&image->lock);\r\nretval = __tsi148_master_get(image, enabled, vme_base, size, aspace,\r\ncycle, dwidth);\r\nspin_unlock(&image->lock);\r\nreturn retval;\r\n}\r\nstatic ssize_t tsi148_master_read(struct vme_master_resource *image, void *buf,\r\nsize_t count, loff_t offset)\r\n{\r\nint retval, enabled;\r\nunsigned long long vme_base, size;\r\nu32 aspace, cycle, dwidth;\r\nstruct vme_bus_error *vme_err = NULL;\r\nstruct vme_bridge *tsi148_bridge;\r\ntsi148_bridge = image->parent;\r\nspin_lock(&image->lock);\r\nmemcpy_fromio(buf, image->kern_base + offset, (unsigned int)count);\r\nretval = count;\r\nif (!err_chk)\r\ngoto skip_chk;\r\n__tsi148_master_get(image, &enabled, &vme_base, &size, &aspace, &cycle,\r\n&dwidth);\r\nvme_err = tsi148_find_error(tsi148_bridge, aspace, vme_base + offset,\r\ncount);\r\nif (vme_err != NULL) {\r\ndev_err(image->parent->parent, "First VME read error detected "\r\n"an at address 0x%llx\n", vme_err->address);\r\nretval = vme_err->address - (vme_base + offset);\r\ntsi148_clear_errors(tsi148_bridge, aspace, vme_base + offset,\r\ncount);\r\n}\r\nskip_chk:\r\nspin_unlock(&image->lock);\r\nreturn retval;\r\n}\r\nstatic ssize_t tsi148_master_write(struct vme_master_resource *image, void *buf,\r\nsize_t count, loff_t offset)\r\n{\r\nint retval = 0, enabled;\r\nunsigned long long vme_base, size;\r\nu32 aspace, cycle, dwidth;\r\nstruct vme_bus_error *vme_err = NULL;\r\nstruct vme_bridge *tsi148_bridge;\r\nstruct tsi148_driver *bridge;\r\ntsi148_bridge = image->parent;\r\nbridge = tsi148_bridge->driver_priv;\r\nspin_lock(&image->lock);\r\nmemcpy_toio(image->kern_base + offset, buf, (unsigned int)count);\r\nretval = count;\r\nif (!err_chk)\r\ngoto skip_chk;\r\n__tsi148_master_get(image, &enabled, &vme_base, &size, &aspace, &cycle,\r\n&dwidth);\r\nioread16(bridge->flush_image->kern_base + 0x7F000);\r\nvme_err = tsi148_find_error(tsi148_bridge, aspace, vme_base + offset,\r\ncount);\r\nif (vme_err != NULL) {\r\ndev_warn(tsi148_bridge->parent, "First VME write error detected"\r\n" an at address 0x%llx\n", vme_err->address);\r\nretval = vme_err->address - (vme_base + offset);\r\ntsi148_clear_errors(tsi148_bridge, aspace, vme_base + offset,\r\ncount);\r\n}\r\nskip_chk:\r\nspin_unlock(&image->lock);\r\nreturn retval;\r\n}\r\nstatic unsigned int tsi148_master_rmw(struct vme_master_resource *image,\r\nunsigned int mask, unsigned int compare, unsigned int swap,\r\nloff_t offset)\r\n{\r\nunsigned long long pci_addr;\r\nunsigned int pci_addr_high, pci_addr_low;\r\nu32 tmp, result;\r\nint i;\r\nstruct tsi148_driver *bridge;\r\nbridge = image->parent->driver_priv;\r\ni = image->number;\r\nmutex_lock(&bridge->vme_rmw);\r\nspin_lock(&image->lock);\r\npci_addr_high = ioread32be(bridge->base + TSI148_LCSR_OT[i] +\r\nTSI148_LCSR_OFFSET_OTSAU);\r\npci_addr_low = ioread32be(bridge->base + TSI148_LCSR_OT[i] +\r\nTSI148_LCSR_OFFSET_OTSAL);\r\nreg_join(pci_addr_high, pci_addr_low, &pci_addr);\r\nreg_split(pci_addr + offset, &pci_addr_high, &pci_addr_low);\r\niowrite32be(mask, bridge->base + TSI148_LCSR_RMWEN);\r\niowrite32be(compare, bridge->base + TSI148_LCSR_RMWC);\r\niowrite32be(swap, bridge->base + TSI148_LCSR_RMWS);\r\niowrite32be(pci_addr_high, bridge->base + TSI148_LCSR_RMWAU);\r\niowrite32be(pci_addr_low, bridge->base + TSI148_LCSR_RMWAL);\r\ntmp = ioread32be(bridge->base + TSI148_LCSR_VMCTRL);\r\ntmp |= TSI148_LCSR_VMCTRL_RMWEN;\r\niowrite32be(tmp, bridge->base + TSI148_LCSR_VMCTRL);\r\nresult = ioread32be(image->kern_base + offset);\r\ntmp = ioread32be(bridge->base + TSI148_LCSR_VMCTRL);\r\ntmp &= ~TSI148_LCSR_VMCTRL_RMWEN;\r\niowrite32be(tmp, bridge->base + TSI148_LCSR_VMCTRL);\r\nspin_unlock(&image->lock);\r\nmutex_unlock(&bridge->vme_rmw);\r\nreturn result;\r\n}\r\nstatic int tsi148_dma_set_vme_src_attributes(struct device *dev, u32 *attr,\r\nu32 aspace, u32 cycle, u32 dwidth)\r\n{\r\nswitch (cycle & (VME_2eSST160 | VME_2eSST267 | VME_2eSST320)) {\r\ncase VME_2eSST160:\r\n*attr |= TSI148_LCSR_DSAT_2eSSTM_160;\r\nbreak;\r\ncase VME_2eSST267:\r\n*attr |= TSI148_LCSR_DSAT_2eSSTM_267;\r\nbreak;\r\ncase VME_2eSST320:\r\n*attr |= TSI148_LCSR_DSAT_2eSSTM_320;\r\nbreak;\r\n}\r\nif (cycle & VME_SCT)\r\n*attr |= TSI148_LCSR_DSAT_TM_SCT;\r\nif (cycle & VME_BLT)\r\n*attr |= TSI148_LCSR_DSAT_TM_BLT;\r\nif (cycle & VME_MBLT)\r\n*attr |= TSI148_LCSR_DSAT_TM_MBLT;\r\nif (cycle & VME_2eVME)\r\n*attr |= TSI148_LCSR_DSAT_TM_2eVME;\r\nif (cycle & VME_2eSST)\r\n*attr |= TSI148_LCSR_DSAT_TM_2eSST;\r\nif (cycle & VME_2eSSTB) {\r\ndev_err(dev, "Currently not setting Broadcast Select "\r\n"Registers\n");\r\n*attr |= TSI148_LCSR_DSAT_TM_2eSSTB;\r\n}\r\nswitch (dwidth) {\r\ncase VME_D16:\r\n*attr |= TSI148_LCSR_DSAT_DBW_16;\r\nbreak;\r\ncase VME_D32:\r\n*attr |= TSI148_LCSR_DSAT_DBW_32;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Invalid data width\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (aspace) {\r\ncase VME_A16:\r\n*attr |= TSI148_LCSR_DSAT_AMODE_A16;\r\nbreak;\r\ncase VME_A24:\r\n*attr |= TSI148_LCSR_DSAT_AMODE_A24;\r\nbreak;\r\ncase VME_A32:\r\n*attr |= TSI148_LCSR_DSAT_AMODE_A32;\r\nbreak;\r\ncase VME_A64:\r\n*attr |= TSI148_LCSR_DSAT_AMODE_A64;\r\nbreak;\r\ncase VME_CRCSR:\r\n*attr |= TSI148_LCSR_DSAT_AMODE_CRCSR;\r\nbreak;\r\ncase VME_USER1:\r\n*attr |= TSI148_LCSR_DSAT_AMODE_USER1;\r\nbreak;\r\ncase VME_USER2:\r\n*attr |= TSI148_LCSR_DSAT_AMODE_USER2;\r\nbreak;\r\ncase VME_USER3:\r\n*attr |= TSI148_LCSR_DSAT_AMODE_USER3;\r\nbreak;\r\ncase VME_USER4:\r\n*attr |= TSI148_LCSR_DSAT_AMODE_USER4;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Invalid address space\n");\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nif (cycle & VME_SUPER)\r\n*attr |= TSI148_LCSR_DSAT_SUP;\r\nif (cycle & VME_PROG)\r\n*attr |= TSI148_LCSR_DSAT_PGM;\r\nreturn 0;\r\n}\r\nstatic int tsi148_dma_set_vme_dest_attributes(struct device *dev, u32 *attr,\r\nu32 aspace, u32 cycle, u32 dwidth)\r\n{\r\nswitch (cycle & (VME_2eSST160 | VME_2eSST267 | VME_2eSST320)) {\r\ncase VME_2eSST160:\r\n*attr |= TSI148_LCSR_DDAT_2eSSTM_160;\r\nbreak;\r\ncase VME_2eSST267:\r\n*attr |= TSI148_LCSR_DDAT_2eSSTM_267;\r\nbreak;\r\ncase VME_2eSST320:\r\n*attr |= TSI148_LCSR_DDAT_2eSSTM_320;\r\nbreak;\r\n}\r\nif (cycle & VME_SCT)\r\n*attr |= TSI148_LCSR_DDAT_TM_SCT;\r\nif (cycle & VME_BLT)\r\n*attr |= TSI148_LCSR_DDAT_TM_BLT;\r\nif (cycle & VME_MBLT)\r\n*attr |= TSI148_LCSR_DDAT_TM_MBLT;\r\nif (cycle & VME_2eVME)\r\n*attr |= TSI148_LCSR_DDAT_TM_2eVME;\r\nif (cycle & VME_2eSST)\r\n*attr |= TSI148_LCSR_DDAT_TM_2eSST;\r\nif (cycle & VME_2eSSTB) {\r\ndev_err(dev, "Currently not setting Broadcast Select "\r\n"Registers\n");\r\n*attr |= TSI148_LCSR_DDAT_TM_2eSSTB;\r\n}\r\nswitch (dwidth) {\r\ncase VME_D16:\r\n*attr |= TSI148_LCSR_DDAT_DBW_16;\r\nbreak;\r\ncase VME_D32:\r\n*attr |= TSI148_LCSR_DDAT_DBW_32;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Invalid data width\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (aspace) {\r\ncase VME_A16:\r\n*attr |= TSI148_LCSR_DDAT_AMODE_A16;\r\nbreak;\r\ncase VME_A24:\r\n*attr |= TSI148_LCSR_DDAT_AMODE_A24;\r\nbreak;\r\ncase VME_A32:\r\n*attr |= TSI148_LCSR_DDAT_AMODE_A32;\r\nbreak;\r\ncase VME_A64:\r\n*attr |= TSI148_LCSR_DDAT_AMODE_A64;\r\nbreak;\r\ncase VME_CRCSR:\r\n*attr |= TSI148_LCSR_DDAT_AMODE_CRCSR;\r\nbreak;\r\ncase VME_USER1:\r\n*attr |= TSI148_LCSR_DDAT_AMODE_USER1;\r\nbreak;\r\ncase VME_USER2:\r\n*attr |= TSI148_LCSR_DDAT_AMODE_USER2;\r\nbreak;\r\ncase VME_USER3:\r\n*attr |= TSI148_LCSR_DDAT_AMODE_USER3;\r\nbreak;\r\ncase VME_USER4:\r\n*attr |= TSI148_LCSR_DDAT_AMODE_USER4;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Invalid address space\n");\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nif (cycle & VME_SUPER)\r\n*attr |= TSI148_LCSR_DDAT_SUP;\r\nif (cycle & VME_PROG)\r\n*attr |= TSI148_LCSR_DDAT_PGM;\r\nreturn 0;\r\n}\r\nstatic int tsi148_dma_list_add(struct vme_dma_list *list,\r\nstruct vme_dma_attr *src, struct vme_dma_attr *dest, size_t count)\r\n{\r\nstruct tsi148_dma_entry *entry, *prev;\r\nu32 address_high, address_low;\r\nstruct vme_dma_pattern *pattern_attr;\r\nstruct vme_dma_pci *pci_attr;\r\nstruct vme_dma_vme *vme_attr;\r\ndma_addr_t desc_ptr;\r\nint retval = 0;\r\nstruct vme_bridge *tsi148_bridge;\r\ntsi148_bridge = list->parent->parent;\r\nentry = kmalloc(sizeof(struct tsi148_dma_entry), GFP_KERNEL);\r\nif (entry == NULL) {\r\ndev_err(tsi148_bridge->parent, "Failed to allocate memory for "\r\n"dma resource structure\n");\r\nretval = -ENOMEM;\r\ngoto err_mem;\r\n}\r\nif ((unsigned long)&entry->descriptor & 0x7) {\r\ndev_err(tsi148_bridge->parent, "Descriptor not aligned to 8 "\r\n"byte boundary as required: %p\n",\r\n&entry->descriptor);\r\nretval = -EINVAL;\r\ngoto err_align;\r\n}\r\nmemset(&entry->descriptor, 0, sizeof(struct tsi148_dma_descriptor));\r\nswitch (src->type) {\r\ncase VME_DMA_PATTERN:\r\npattern_attr = src->private;\r\nentry->descriptor.dsal = pattern_attr->pattern;\r\nentry->descriptor.dsat = TSI148_LCSR_DSAT_TYP_PAT;\r\nif (pattern_attr->type & VME_DMA_PATTERN_BYTE)\r\nentry->descriptor.dsat |= TSI148_LCSR_DSAT_PSZ;\r\nif ((pattern_attr->type & VME_DMA_PATTERN_INCREMENT) == 0)\r\nentry->descriptor.dsat |= TSI148_LCSR_DSAT_NIN;\r\nbreak;\r\ncase VME_DMA_PCI:\r\npci_attr = src->private;\r\nreg_split((unsigned long long)pci_attr->address, &address_high,\r\n&address_low);\r\nentry->descriptor.dsau = address_high;\r\nentry->descriptor.dsal = address_low;\r\nentry->descriptor.dsat = TSI148_LCSR_DSAT_TYP_PCI;\r\nbreak;\r\ncase VME_DMA_VME:\r\nvme_attr = src->private;\r\nreg_split((unsigned long long)vme_attr->address, &address_high,\r\n&address_low);\r\nentry->descriptor.dsau = address_high;\r\nentry->descriptor.dsal = address_low;\r\nentry->descriptor.dsat = TSI148_LCSR_DSAT_TYP_VME;\r\nretval = tsi148_dma_set_vme_src_attributes(\r\ntsi148_bridge->parent, &entry->descriptor.dsat,\r\nvme_attr->aspace, vme_attr->cycle, vme_attr->dwidth);\r\nif (retval < 0)\r\ngoto err_source;\r\nbreak;\r\ndefault:\r\ndev_err(tsi148_bridge->parent, "Invalid source type\n");\r\nretval = -EINVAL;\r\ngoto err_source;\r\nbreak;\r\n}\r\nentry->descriptor.dnlau = 0;\r\nentry->descriptor.dnlal = TSI148_LCSR_DNLAL_LLA;\r\nswitch (dest->type) {\r\ncase VME_DMA_PCI:\r\npci_attr = dest->private;\r\nreg_split((unsigned long long)pci_attr->address, &address_high,\r\n&address_low);\r\nentry->descriptor.ddau = address_high;\r\nentry->descriptor.ddal = address_low;\r\nentry->descriptor.ddat = TSI148_LCSR_DDAT_TYP_PCI;\r\nbreak;\r\ncase VME_DMA_VME:\r\nvme_attr = dest->private;\r\nreg_split((unsigned long long)vme_attr->address, &address_high,\r\n&address_low);\r\nentry->descriptor.ddau = address_high;\r\nentry->descriptor.ddal = address_low;\r\nentry->descriptor.ddat = TSI148_LCSR_DDAT_TYP_VME;\r\nretval = tsi148_dma_set_vme_dest_attributes(\r\ntsi148_bridge->parent, &entry->descriptor.ddat,\r\nvme_attr->aspace, vme_attr->cycle, vme_attr->dwidth);\r\nif (retval < 0)\r\ngoto err_dest;\r\nbreak;\r\ndefault:\r\ndev_err(tsi148_bridge->parent, "Invalid destination type\n");\r\nretval = -EINVAL;\r\ngoto err_dest;\r\nbreak;\r\n}\r\nentry->descriptor.dcnt = (u32)count;\r\nlist_add_tail(&entry->list, &list->entries);\r\nif (entry->list.prev != &list->entries) {\r\nprev = list_entry(entry->list.prev, struct tsi148_dma_entry,\r\nlist);\r\ndesc_ptr = virt_to_bus(&entry->descriptor);\r\nreg_split(desc_ptr, &prev->descriptor.dnlau,\r\n&prev->descriptor.dnlal);\r\n}\r\nreturn 0;\r\nerr_dest:\r\nerr_source:\r\nerr_align:\r\nkfree(entry);\r\nerr_mem:\r\nreturn retval;\r\n}\r\nstatic int tsi148_dma_busy(struct vme_bridge *tsi148_bridge, int channel)\r\n{\r\nu32 tmp;\r\nstruct tsi148_driver *bridge;\r\nbridge = tsi148_bridge->driver_priv;\r\ntmp = ioread32be(bridge->base + TSI148_LCSR_DMA[channel] +\r\nTSI148_LCSR_OFFSET_DSTA);\r\nif (tmp & TSI148_LCSR_DSTA_BSY)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic int tsi148_dma_list_exec(struct vme_dma_list *list)\r\n{\r\nstruct vme_dma_resource *ctrlr;\r\nint channel, retval = 0;\r\nstruct tsi148_dma_entry *entry;\r\ndma_addr_t bus_addr;\r\nu32 bus_addr_high, bus_addr_low;\r\nu32 val, dctlreg = 0;\r\nstruct vme_bridge *tsi148_bridge;\r\nstruct tsi148_driver *bridge;\r\nctrlr = list->parent;\r\ntsi148_bridge = ctrlr->parent;\r\nbridge = tsi148_bridge->driver_priv;\r\nmutex_lock(&ctrlr->mtx);\r\nchannel = ctrlr->number;\r\nif (!list_empty(&ctrlr->running)) {\r\nmutex_unlock(&ctrlr->mtx);\r\nreturn -EBUSY;\r\n} else {\r\nlist_add(&list->list, &ctrlr->running);\r\n}\r\nentry = list_first_entry(&list->entries, struct tsi148_dma_entry,\r\nlist);\r\nbus_addr = virt_to_bus(&entry->descriptor);\r\nmutex_unlock(&ctrlr->mtx);\r\nreg_split(bus_addr, &bus_addr_high, &bus_addr_low);\r\niowrite32be(bus_addr_high, bridge->base +\r\nTSI148_LCSR_DMA[channel] + TSI148_LCSR_OFFSET_DNLAU);\r\niowrite32be(bus_addr_low, bridge->base +\r\nTSI148_LCSR_DMA[channel] + TSI148_LCSR_OFFSET_DNLAL);\r\niowrite32be(dctlreg | TSI148_LCSR_DCTL_DGO, bridge->base +\r\nTSI148_LCSR_DMA[channel] + TSI148_LCSR_OFFSET_DCTL);\r\nwait_event_interruptible(bridge->dma_queue[channel],\r\ntsi148_dma_busy(ctrlr->parent, channel));\r\nval = ioread32be(bridge->base + TSI148_LCSR_DMA[channel] +\r\nTSI148_LCSR_OFFSET_DSTA);\r\nif (val & TSI148_LCSR_DSTA_VBE) {\r\ndev_err(tsi148_bridge->parent, "DMA Error. DSTA=%08X\n", val);\r\nretval = -EIO;\r\n}\r\nmutex_lock(&ctrlr->mtx);\r\nlist_del(&list->list);\r\nmutex_unlock(&ctrlr->mtx);\r\nreturn retval;\r\n}\r\nstatic int tsi148_dma_list_empty(struct vme_dma_list *list)\r\n{\r\nstruct list_head *pos, *temp;\r\nstruct tsi148_dma_entry *entry;\r\nlist_for_each_safe(pos, temp, &list->entries) {\r\nlist_del(pos);\r\nentry = list_entry(pos, struct tsi148_dma_entry, list);\r\nkfree(entry);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tsi148_lm_set(struct vme_lm_resource *lm, unsigned long long lm_base,\r\nu32 aspace, u32 cycle)\r\n{\r\nu32 lm_base_high, lm_base_low, lm_ctl = 0;\r\nint i;\r\nstruct vme_bridge *tsi148_bridge;\r\nstruct tsi148_driver *bridge;\r\ntsi148_bridge = lm->parent;\r\nbridge = tsi148_bridge->driver_priv;\r\nmutex_lock(&lm->mtx);\r\nfor (i = 0; i < lm->monitors; i++) {\r\nif (bridge->lm_callback[i] != NULL) {\r\nmutex_unlock(&lm->mtx);\r\ndev_err(tsi148_bridge->parent, "Location monitor "\r\n"callback attached, can't reset\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nswitch (aspace) {\r\ncase VME_A16:\r\nlm_ctl |= TSI148_LCSR_LMAT_AS_A16;\r\nbreak;\r\ncase VME_A24:\r\nlm_ctl |= TSI148_LCSR_LMAT_AS_A24;\r\nbreak;\r\ncase VME_A32:\r\nlm_ctl |= TSI148_LCSR_LMAT_AS_A32;\r\nbreak;\r\ncase VME_A64:\r\nlm_ctl |= TSI148_LCSR_LMAT_AS_A64;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&lm->mtx);\r\ndev_err(tsi148_bridge->parent, "Invalid address space\n");\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nif (cycle & VME_SUPER)\r\nlm_ctl |= TSI148_LCSR_LMAT_SUPR ;\r\nif (cycle & VME_USER)\r\nlm_ctl |= TSI148_LCSR_LMAT_NPRIV;\r\nif (cycle & VME_PROG)\r\nlm_ctl |= TSI148_LCSR_LMAT_PGM;\r\nif (cycle & VME_DATA)\r\nlm_ctl |= TSI148_LCSR_LMAT_DATA;\r\nreg_split(lm_base, &lm_base_high, &lm_base_low);\r\niowrite32be(lm_base_high, bridge->base + TSI148_LCSR_LMBAU);\r\niowrite32be(lm_base_low, bridge->base + TSI148_LCSR_LMBAL);\r\niowrite32be(lm_ctl, bridge->base + TSI148_LCSR_LMAT);\r\nmutex_unlock(&lm->mtx);\r\nreturn 0;\r\n}\r\nstatic int tsi148_lm_get(struct vme_lm_resource *lm,\r\nunsigned long long *lm_base, u32 *aspace, u32 *cycle)\r\n{\r\nu32 lm_base_high, lm_base_low, lm_ctl, enabled = 0;\r\nstruct tsi148_driver *bridge;\r\nbridge = lm->parent->driver_priv;\r\nmutex_lock(&lm->mtx);\r\nlm_base_high = ioread32be(bridge->base + TSI148_LCSR_LMBAU);\r\nlm_base_low = ioread32be(bridge->base + TSI148_LCSR_LMBAL);\r\nlm_ctl = ioread32be(bridge->base + TSI148_LCSR_LMAT);\r\nreg_join(lm_base_high, lm_base_low, lm_base);\r\nif (lm_ctl & TSI148_LCSR_LMAT_EN)\r\nenabled = 1;\r\nif ((lm_ctl & TSI148_LCSR_LMAT_AS_M) == TSI148_LCSR_LMAT_AS_A16)\r\n*aspace |= VME_A16;\r\nif ((lm_ctl & TSI148_LCSR_LMAT_AS_M) == TSI148_LCSR_LMAT_AS_A24)\r\n*aspace |= VME_A24;\r\nif ((lm_ctl & TSI148_LCSR_LMAT_AS_M) == TSI148_LCSR_LMAT_AS_A32)\r\n*aspace |= VME_A32;\r\nif ((lm_ctl & TSI148_LCSR_LMAT_AS_M) == TSI148_LCSR_LMAT_AS_A64)\r\n*aspace |= VME_A64;\r\nif (lm_ctl & TSI148_LCSR_LMAT_SUPR)\r\n*cycle |= VME_SUPER;\r\nif (lm_ctl & TSI148_LCSR_LMAT_NPRIV)\r\n*cycle |= VME_USER;\r\nif (lm_ctl & TSI148_LCSR_LMAT_PGM)\r\n*cycle |= VME_PROG;\r\nif (lm_ctl & TSI148_LCSR_LMAT_DATA)\r\n*cycle |= VME_DATA;\r\nmutex_unlock(&lm->mtx);\r\nreturn enabled;\r\n}\r\nstatic int tsi148_lm_attach(struct vme_lm_resource *lm, int monitor,\r\nvoid (*callback)(int))\r\n{\r\nu32 lm_ctl, tmp;\r\nstruct vme_bridge *tsi148_bridge;\r\nstruct tsi148_driver *bridge;\r\ntsi148_bridge = lm->parent;\r\nbridge = tsi148_bridge->driver_priv;\r\nmutex_lock(&lm->mtx);\r\nlm_ctl = ioread32be(bridge->base + TSI148_LCSR_LMAT);\r\nif ((lm_ctl & (TSI148_LCSR_LMAT_PGM | TSI148_LCSR_LMAT_DATA)) == 0) {\r\nmutex_unlock(&lm->mtx);\r\ndev_err(tsi148_bridge->parent, "Location monitor not properly "\r\n"configured\n");\r\nreturn -EINVAL;\r\n}\r\nif (bridge->lm_callback[monitor] != NULL) {\r\nmutex_unlock(&lm->mtx);\r\ndev_err(tsi148_bridge->parent, "Existing callback attached\n");\r\nreturn -EBUSY;\r\n}\r\nbridge->lm_callback[monitor] = callback;\r\ntmp = ioread32be(bridge->base + TSI148_LCSR_INTEN);\r\ntmp |= TSI148_LCSR_INTEN_LMEN[monitor];\r\niowrite32be(tmp, bridge->base + TSI148_LCSR_INTEN);\r\ntmp = ioread32be(bridge->base + TSI148_LCSR_INTEO);\r\ntmp |= TSI148_LCSR_INTEO_LMEO[monitor];\r\niowrite32be(tmp, bridge->base + TSI148_LCSR_INTEO);\r\nif ((lm_ctl & TSI148_LCSR_LMAT_EN) == 0) {\r\nlm_ctl |= TSI148_LCSR_LMAT_EN;\r\niowrite32be(lm_ctl, bridge->base + TSI148_LCSR_LMAT);\r\n}\r\nmutex_unlock(&lm->mtx);\r\nreturn 0;\r\n}\r\nstatic int tsi148_lm_detach(struct vme_lm_resource *lm, int monitor)\r\n{\r\nu32 lm_en, tmp;\r\nstruct tsi148_driver *bridge;\r\nbridge = lm->parent->driver_priv;\r\nmutex_lock(&lm->mtx);\r\nlm_en = ioread32be(bridge->base + TSI148_LCSR_INTEN);\r\nlm_en &= ~TSI148_LCSR_INTEN_LMEN[monitor];\r\niowrite32be(lm_en, bridge->base + TSI148_LCSR_INTEN);\r\ntmp = ioread32be(bridge->base + TSI148_LCSR_INTEO);\r\ntmp &= ~TSI148_LCSR_INTEO_LMEO[monitor];\r\niowrite32be(tmp, bridge->base + TSI148_LCSR_INTEO);\r\niowrite32be(TSI148_LCSR_INTC_LMC[monitor],\r\nbridge->base + TSI148_LCSR_INTC);\r\nbridge->lm_callback[monitor] = NULL;\r\nif ((lm_en & (TSI148_LCSR_INTS_LM0S | TSI148_LCSR_INTS_LM1S |\r\nTSI148_LCSR_INTS_LM2S | TSI148_LCSR_INTS_LM3S)) == 0) {\r\ntmp = ioread32be(bridge->base + TSI148_LCSR_LMAT);\r\ntmp &= ~TSI148_LCSR_LMAT_EN;\r\niowrite32be(tmp, bridge->base + TSI148_LCSR_LMAT);\r\n}\r\nmutex_unlock(&lm->mtx);\r\nreturn 0;\r\n}\r\nstatic int tsi148_slot_get(struct vme_bridge *tsi148_bridge)\r\n{\r\nu32 slot = 0;\r\nstruct tsi148_driver *bridge;\r\nbridge = tsi148_bridge->driver_priv;\r\nif (!geoid) {\r\nslot = ioread32be(bridge->base + TSI148_LCSR_VSTAT);\r\nslot = slot & TSI148_LCSR_VSTAT_GA_M;\r\n} else\r\nslot = geoid;\r\nreturn (int)slot;\r\n}\r\nvoid *tsi148_alloc_consistent(struct device *parent, size_t size,\r\ndma_addr_t *dma)\r\n{\r\nstruct pci_dev *pdev;\r\npdev = container_of(parent, struct pci_dev, dev);\r\nreturn pci_alloc_consistent(pdev, size, dma);\r\n}\r\nvoid tsi148_free_consistent(struct device *parent, size_t size, void *vaddr,\r\ndma_addr_t dma)\r\n{\r\nstruct pci_dev *pdev;\r\npdev = container_of(parent, struct pci_dev, dev);\r\npci_free_consistent(pdev, size, vaddr, dma);\r\n}\r\nstatic int __init tsi148_init(void)\r\n{\r\nreturn pci_register_driver(&tsi148_driver);\r\n}\r\nstatic int tsi148_crcsr_init(struct vme_bridge *tsi148_bridge,\r\nstruct pci_dev *pdev)\r\n{\r\nu32 cbar, crat, vstat;\r\nu32 crcsr_bus_high, crcsr_bus_low;\r\nint retval;\r\nstruct tsi148_driver *bridge;\r\nbridge = tsi148_bridge->driver_priv;\r\nbridge->crcsr_kernel = pci_alloc_consistent(pdev, VME_CRCSR_BUF_SIZE,\r\n&bridge->crcsr_bus);\r\nif (bridge->crcsr_kernel == NULL) {\r\ndev_err(tsi148_bridge->parent, "Failed to allocate memory for "\r\n"CR/CSR image\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(bridge->crcsr_kernel, 0, VME_CRCSR_BUF_SIZE);\r\nreg_split(bridge->crcsr_bus, &crcsr_bus_high, &crcsr_bus_low);\r\niowrite32be(crcsr_bus_high, bridge->base + TSI148_LCSR_CROU);\r\niowrite32be(crcsr_bus_low, bridge->base + TSI148_LCSR_CROL);\r\ncbar = ioread32be(bridge->base + TSI148_CBAR);\r\ncbar = (cbar & TSI148_CRCSR_CBAR_M)>>3;\r\nvstat = tsi148_slot_get(tsi148_bridge);\r\nif (cbar != vstat) {\r\ncbar = vstat;\r\ndev_info(tsi148_bridge->parent, "Setting CR/CSR offset\n");\r\niowrite32be(cbar<<3, bridge->base + TSI148_CBAR);\r\n}\r\ndev_info(tsi148_bridge->parent, "CR/CSR Offset: %d\n", cbar);\r\ncrat = ioread32be(bridge->base + TSI148_LCSR_CRAT);\r\nif (crat & TSI148_LCSR_CRAT_EN) {\r\ndev_info(tsi148_bridge->parent, "Enabling CR/CSR space\n");\r\niowrite32be(crat | TSI148_LCSR_CRAT_EN,\r\nbridge->base + TSI148_LCSR_CRAT);\r\n} else\r\ndev_info(tsi148_bridge->parent, "CR/CSR already enabled\n");\r\nif (err_chk) {\r\nretval = tsi148_master_set(bridge->flush_image, 1,\r\n(vstat * 0x80000), 0x80000, VME_CRCSR, VME_SCT,\r\nVME_D16);\r\nif (retval)\r\ndev_err(tsi148_bridge->parent, "Configuring flush image"\r\n" failed\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void tsi148_crcsr_exit(struct vme_bridge *tsi148_bridge,\r\nstruct pci_dev *pdev)\r\n{\r\nu32 crat;\r\nstruct tsi148_driver *bridge;\r\nbridge = tsi148_bridge->driver_priv;\r\ncrat = ioread32be(bridge->base + TSI148_LCSR_CRAT);\r\niowrite32be(crat & ~TSI148_LCSR_CRAT_EN,\r\nbridge->base + TSI148_LCSR_CRAT);\r\niowrite32be(0, bridge->base + TSI148_LCSR_CROU);\r\niowrite32be(0, bridge->base + TSI148_LCSR_CROL);\r\npci_free_consistent(pdev, VME_CRCSR_BUF_SIZE, bridge->crcsr_kernel,\r\nbridge->crcsr_bus);\r\n}\r\nstatic int tsi148_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nint retval, i, master_num;\r\nu32 data;\r\nstruct list_head *pos = NULL;\r\nstruct vme_bridge *tsi148_bridge;\r\nstruct tsi148_driver *tsi148_device;\r\nstruct vme_master_resource *master_image;\r\nstruct vme_slave_resource *slave_image;\r\nstruct vme_dma_resource *dma_ctrlr;\r\nstruct vme_lm_resource *lm;\r\ntsi148_bridge = kzalloc(sizeof(struct vme_bridge), GFP_KERNEL);\r\nif (tsi148_bridge == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate memory for device "\r\n"structure\n");\r\nretval = -ENOMEM;\r\ngoto err_struct;\r\n}\r\ntsi148_device = kzalloc(sizeof(struct tsi148_driver), GFP_KERNEL);\r\nif (tsi148_device == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate memory for device "\r\n"structure\n");\r\nretval = -ENOMEM;\r\ngoto err_driver;\r\n}\r\ntsi148_bridge->driver_priv = tsi148_device;\r\nretval = pci_enable_device(pdev);\r\nif (retval) {\r\ndev_err(&pdev->dev, "Unable to enable device\n");\r\ngoto err_enable;\r\n}\r\nretval = pci_request_regions(pdev, driver_name);\r\nif (retval) {\r\ndev_err(&pdev->dev, "Unable to reserve resources\n");\r\ngoto err_resource;\r\n}\r\ntsi148_device->base = ioremap_nocache(pci_resource_start(pdev, 0),\r\n4096);\r\nif (!tsi148_device->base) {\r\ndev_err(&pdev->dev, "Unable to remap CRG region\n");\r\nretval = -EIO;\r\ngoto err_remap;\r\n}\r\ndata = ioread32(tsi148_device->base + TSI148_PCFS_ID) & 0x0000FFFF;\r\nif (data != PCI_VENDOR_ID_TUNDRA) {\r\ndev_err(&pdev->dev, "CRG region check failed\n");\r\nretval = -EIO;\r\ngoto err_test;\r\n}\r\ninit_waitqueue_head(&tsi148_device->dma_queue[0]);\r\ninit_waitqueue_head(&tsi148_device->dma_queue[1]);\r\ninit_waitqueue_head(&tsi148_device->iack_queue);\r\nmutex_init(&tsi148_device->vme_int);\r\nmutex_init(&tsi148_device->vme_rmw);\r\ntsi148_bridge->parent = &pdev->dev;\r\nstrcpy(tsi148_bridge->name, driver_name);\r\nretval = tsi148_irq_init(tsi148_bridge);\r\nif (retval != 0) {\r\ndev_err(&pdev->dev, "Chip Initialization failed.\n");\r\ngoto err_irq;\r\n}\r\nmaster_num = TSI148_MAX_MASTER;\r\nif (err_chk) {\r\nmaster_num--;\r\ntsi148_device->flush_image =\r\nkmalloc(sizeof(struct vme_master_resource), GFP_KERNEL);\r\nif (tsi148_device->flush_image == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate memory for "\r\n"flush resource structure\n");\r\nretval = -ENOMEM;\r\ngoto err_master;\r\n}\r\ntsi148_device->flush_image->parent = tsi148_bridge;\r\nspin_lock_init(&tsi148_device->flush_image->lock);\r\ntsi148_device->flush_image->locked = 1;\r\ntsi148_device->flush_image->number = master_num;\r\ntsi148_device->flush_image->address_attr = VME_A16 | VME_A24 |\r\nVME_A32 | VME_A64;\r\ntsi148_device->flush_image->cycle_attr = VME_SCT | VME_BLT |\r\nVME_MBLT | VME_2eVME | VME_2eSST | VME_2eSSTB |\r\nVME_2eSST160 | VME_2eSST267 | VME_2eSST320 | VME_SUPER |\r\nVME_USER | VME_PROG | VME_DATA;\r\ntsi148_device->flush_image->width_attr = VME_D16 | VME_D32;\r\nmemset(&tsi148_device->flush_image->bus_resource, 0,\r\nsizeof(struct resource));\r\ntsi148_device->flush_image->kern_base = NULL;\r\n}\r\nINIT_LIST_HEAD(&tsi148_bridge->master_resources);\r\nfor (i = 0; i < master_num; i++) {\r\nmaster_image = kmalloc(sizeof(struct vme_master_resource),\r\nGFP_KERNEL);\r\nif (master_image == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate memory for "\r\n"master resource structure\n");\r\nretval = -ENOMEM;\r\ngoto err_master;\r\n}\r\nmaster_image->parent = tsi148_bridge;\r\nspin_lock_init(&master_image->lock);\r\nmaster_image->locked = 0;\r\nmaster_image->number = i;\r\nmaster_image->address_attr = VME_A16 | VME_A24 | VME_A32 |\r\nVME_A64;\r\nmaster_image->cycle_attr = VME_SCT | VME_BLT | VME_MBLT |\r\nVME_2eVME | VME_2eSST | VME_2eSSTB | VME_2eSST160 |\r\nVME_2eSST267 | VME_2eSST320 | VME_SUPER | VME_USER |\r\nVME_PROG | VME_DATA;\r\nmaster_image->width_attr = VME_D16 | VME_D32;\r\nmemset(&master_image->bus_resource, 0,\r\nsizeof(struct resource));\r\nmaster_image->kern_base = NULL;\r\nlist_add_tail(&master_image->list,\r\n&tsi148_bridge->master_resources);\r\n}\r\nINIT_LIST_HEAD(&tsi148_bridge->slave_resources);\r\nfor (i = 0; i < TSI148_MAX_SLAVE; i++) {\r\nslave_image = kmalloc(sizeof(struct vme_slave_resource),\r\nGFP_KERNEL);\r\nif (slave_image == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate memory for "\r\n"slave resource structure\n");\r\nretval = -ENOMEM;\r\ngoto err_slave;\r\n}\r\nslave_image->parent = tsi148_bridge;\r\nmutex_init(&slave_image->mtx);\r\nslave_image->locked = 0;\r\nslave_image->number = i;\r\nslave_image->address_attr = VME_A16 | VME_A24 | VME_A32 |\r\nVME_A64 | VME_CRCSR | VME_USER1 | VME_USER2 |\r\nVME_USER3 | VME_USER4;\r\nslave_image->cycle_attr = VME_SCT | VME_BLT | VME_MBLT |\r\nVME_2eVME | VME_2eSST | VME_2eSSTB | VME_2eSST160 |\r\nVME_2eSST267 | VME_2eSST320 | VME_SUPER | VME_USER |\r\nVME_PROG | VME_DATA;\r\nlist_add_tail(&slave_image->list,\r\n&tsi148_bridge->slave_resources);\r\n}\r\nINIT_LIST_HEAD(&tsi148_bridge->dma_resources);\r\nfor (i = 0; i < TSI148_MAX_DMA; i++) {\r\ndma_ctrlr = kmalloc(sizeof(struct vme_dma_resource),\r\nGFP_KERNEL);\r\nif (dma_ctrlr == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate memory for "\r\n"dma resource structure\n");\r\nretval = -ENOMEM;\r\ngoto err_dma;\r\n}\r\ndma_ctrlr->parent = tsi148_bridge;\r\nmutex_init(&dma_ctrlr->mtx);\r\ndma_ctrlr->locked = 0;\r\ndma_ctrlr->number = i;\r\ndma_ctrlr->route_attr = VME_DMA_VME_TO_MEM |\r\nVME_DMA_MEM_TO_VME | VME_DMA_VME_TO_VME |\r\nVME_DMA_MEM_TO_MEM | VME_DMA_PATTERN_TO_VME |\r\nVME_DMA_PATTERN_TO_MEM;\r\nINIT_LIST_HEAD(&dma_ctrlr->pending);\r\nINIT_LIST_HEAD(&dma_ctrlr->running);\r\nlist_add_tail(&dma_ctrlr->list,\r\n&tsi148_bridge->dma_resources);\r\n}\r\nINIT_LIST_HEAD(&tsi148_bridge->lm_resources);\r\nlm = kmalloc(sizeof(struct vme_lm_resource), GFP_KERNEL);\r\nif (lm == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate memory for "\r\n"location monitor resource structure\n");\r\nretval = -ENOMEM;\r\ngoto err_lm;\r\n}\r\nlm->parent = tsi148_bridge;\r\nmutex_init(&lm->mtx);\r\nlm->locked = 0;\r\nlm->number = 1;\r\nlm->monitors = 4;\r\nlist_add_tail(&lm->list, &tsi148_bridge->lm_resources);\r\ntsi148_bridge->slave_get = tsi148_slave_get;\r\ntsi148_bridge->slave_set = tsi148_slave_set;\r\ntsi148_bridge->master_get = tsi148_master_get;\r\ntsi148_bridge->master_set = tsi148_master_set;\r\ntsi148_bridge->master_read = tsi148_master_read;\r\ntsi148_bridge->master_write = tsi148_master_write;\r\ntsi148_bridge->master_rmw = tsi148_master_rmw;\r\ntsi148_bridge->dma_list_add = tsi148_dma_list_add;\r\ntsi148_bridge->dma_list_exec = tsi148_dma_list_exec;\r\ntsi148_bridge->dma_list_empty = tsi148_dma_list_empty;\r\ntsi148_bridge->irq_set = tsi148_irq_set;\r\ntsi148_bridge->irq_generate = tsi148_irq_generate;\r\ntsi148_bridge->lm_set = tsi148_lm_set;\r\ntsi148_bridge->lm_get = tsi148_lm_get;\r\ntsi148_bridge->lm_attach = tsi148_lm_attach;\r\ntsi148_bridge->lm_detach = tsi148_lm_detach;\r\ntsi148_bridge->slot_get = tsi148_slot_get;\r\ntsi148_bridge->alloc_consistent = tsi148_alloc_consistent;\r\ntsi148_bridge->free_consistent = tsi148_free_consistent;\r\ndata = ioread32be(tsi148_device->base + TSI148_LCSR_VSTAT);\r\ndev_info(&pdev->dev, "Board is%s the VME system controller\n",\r\n(data & TSI148_LCSR_VSTAT_SCONS) ? "" : " not");\r\nif (!geoid)\r\ndev_info(&pdev->dev, "VME geographical address is %d\n",\r\ndata & TSI148_LCSR_VSTAT_GA_M);\r\nelse\r\ndev_info(&pdev->dev, "VME geographical address is set to %d\n",\r\ngeoid);\r\ndev_info(&pdev->dev, "VME Write and flush and error check is %s\n",\r\nerr_chk ? "enabled" : "disabled");\r\nif (tsi148_crcsr_init(tsi148_bridge, pdev)) {\r\ndev_err(&pdev->dev, "CR/CSR configuration failed.\n");\r\ngoto err_crcsr;\r\n}\r\nretval = vme_register_bridge(tsi148_bridge);\r\nif (retval != 0) {\r\ndev_err(&pdev->dev, "Chip Registration failed.\n");\r\ngoto err_reg;\r\n}\r\npci_set_drvdata(pdev, tsi148_bridge);\r\ndata = ioread32be(tsi148_device->base + TSI148_LCSR_VSTAT);\r\ndata &= ~TSI148_LCSR_VSTAT_BRDFL;\r\ndata |= TSI148_LCSR_VSTAT_CPURST;\r\niowrite32be(data, tsi148_device->base + TSI148_LCSR_VSTAT);\r\nreturn 0;\r\nerr_reg:\r\ntsi148_crcsr_exit(tsi148_bridge, pdev);\r\nerr_crcsr:\r\nerr_lm:\r\nlist_for_each(pos, &tsi148_bridge->lm_resources) {\r\nlm = list_entry(pos, struct vme_lm_resource, list);\r\nlist_del(pos);\r\nkfree(lm);\r\n}\r\nerr_dma:\r\nlist_for_each(pos, &tsi148_bridge->dma_resources) {\r\ndma_ctrlr = list_entry(pos, struct vme_dma_resource, list);\r\nlist_del(pos);\r\nkfree(dma_ctrlr);\r\n}\r\nerr_slave:\r\nlist_for_each(pos, &tsi148_bridge->slave_resources) {\r\nslave_image = list_entry(pos, struct vme_slave_resource, list);\r\nlist_del(pos);\r\nkfree(slave_image);\r\n}\r\nerr_master:\r\nlist_for_each(pos, &tsi148_bridge->master_resources) {\r\nmaster_image = list_entry(pos, struct vme_master_resource,\r\nlist);\r\nlist_del(pos);\r\nkfree(master_image);\r\n}\r\ntsi148_irq_exit(tsi148_bridge, pdev);\r\nerr_irq:\r\nerr_test:\r\niounmap(tsi148_device->base);\r\nerr_remap:\r\npci_release_regions(pdev);\r\nerr_resource:\r\npci_disable_device(pdev);\r\nerr_enable:\r\nkfree(tsi148_device);\r\nerr_driver:\r\nkfree(tsi148_bridge);\r\nerr_struct:\r\nreturn retval;\r\n}\r\nstatic void tsi148_remove(struct pci_dev *pdev)\r\n{\r\nstruct list_head *pos = NULL;\r\nstruct list_head *tmplist;\r\nstruct vme_master_resource *master_image;\r\nstruct vme_slave_resource *slave_image;\r\nstruct vme_dma_resource *dma_ctrlr;\r\nint i;\r\nstruct tsi148_driver *bridge;\r\nstruct vme_bridge *tsi148_bridge = pci_get_drvdata(pdev);\r\nbridge = tsi148_bridge->driver_priv;\r\ndev_dbg(&pdev->dev, "Driver is being unloaded.\n");\r\nfor (i = 0; i < 8; i++) {\r\niowrite32be(0, bridge->base + TSI148_LCSR_IT[i] +\r\nTSI148_LCSR_OFFSET_ITAT);\r\niowrite32be(0, bridge->base + TSI148_LCSR_OT[i] +\r\nTSI148_LCSR_OFFSET_OTAT);\r\n}\r\niowrite32be(0, bridge->base + TSI148_LCSR_LMAT);\r\niowrite32be(0, bridge->base + TSI148_LCSR_CSRAT);\r\niowrite32be(0xFFFFFFFF, bridge->base + TSI148_LCSR_EDPAT);\r\niowrite32be(0xFFFFFFFF, bridge->base + TSI148_LCSR_VEAT);\r\niowrite32be(0x07000700, bridge->base + TSI148_LCSR_PSTAT);\r\nif (ioread32be(bridge->base + TSI148_LCSR_VICR) & 0x800)\r\niowrite32be(0x8000, bridge->base + TSI148_LCSR_VICR);\r\niowrite32be(0x0, bridge->base + TSI148_LCSR_INTM1);\r\niowrite32be(0x0, bridge->base + TSI148_LCSR_INTM2);\r\ntsi148_irq_exit(tsi148_bridge, pdev);\r\nvme_unregister_bridge(tsi148_bridge);\r\ntsi148_crcsr_exit(tsi148_bridge, pdev);\r\nlist_for_each_safe(pos, tmplist, &tsi148_bridge->dma_resources) {\r\ndma_ctrlr = list_entry(pos, struct vme_dma_resource, list);\r\nlist_del(pos);\r\nkfree(dma_ctrlr);\r\n}\r\nlist_for_each_safe(pos, tmplist, &tsi148_bridge->slave_resources) {\r\nslave_image = list_entry(pos, struct vme_slave_resource, list);\r\nlist_del(pos);\r\nkfree(slave_image);\r\n}\r\nlist_for_each_safe(pos, tmplist, &tsi148_bridge->master_resources) {\r\nmaster_image = list_entry(pos, struct vme_master_resource,\r\nlist);\r\nlist_del(pos);\r\nkfree(master_image);\r\n}\r\niounmap(bridge->base);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nkfree(tsi148_bridge->driver_priv);\r\nkfree(tsi148_bridge);\r\n}\r\nstatic void __exit tsi148_exit(void)\r\n{\r\npci_unregister_driver(&tsi148_driver);\r\n}
