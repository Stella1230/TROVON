static struct s5p_mfc_fmt *find_format(struct v4l2_format *f, unsigned int t)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < NUM_FORMATS; i++) {\r\nif (formats[i].fourcc == f->fmt.pix_mp.pixelformat &&\r\nformats[i].type == t)\r\nreturn &formats[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic int s5p_mfc_ctx_ready(struct s5p_mfc_ctx *ctx)\r\n{\r\nif (ctx->src_queue_cnt >= 1 && ctx->state == MFCINST_GOT_INST)\r\nreturn 1;\r\nif (ctx->src_queue_cnt >= 1 &&\r\nctx->state == MFCINST_RUNNING &&\r\nctx->dst_queue_cnt >= ctx->dpb_count)\r\nreturn 1;\r\nif (ctx->state == MFCINST_FINISHING &&\r\nctx->dst_queue_cnt >= ctx->dpb_count)\r\nreturn 1;\r\nif (ctx->src_queue_cnt >= 1 &&\r\nctx->state == MFCINST_HEAD_PARSED &&\r\nctx->capture_state == QUEUE_BUFS_MMAPED)\r\nreturn 1;\r\nif ((ctx->state == MFCINST_RES_CHANGE_INIT ||\r\nctx->state == MFCINST_RES_CHANGE_FLUSH) &&\r\nctx->dst_queue_cnt >= ctx->dpb_count)\r\nreturn 1;\r\nif (ctx->state == MFCINST_RES_CHANGE_END &&\r\nctx->src_queue_cnt >= 1)\r\nreturn 1;\r\nmfc_debug(2, "ctx is not ready\n");\r\nreturn 0;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct s5p_mfc_dev *dev = video_drvdata(file);\r\nstrncpy(cap->driver, dev->plat_dev->name, sizeof(cap->driver) - 1);\r\nstrncpy(cap->card, dev->plat_dev->name, sizeof(cap->card) - 1);\r\ncap->bus_info[0] = 0;\r\ncap->version = KERNEL_VERSION(1, 0, 0);\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE_MPLANE |\r\nV4L2_CAP_VIDEO_OUTPUT_MPLANE | V4L2_CAP_STREAMING;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt(struct v4l2_fmtdesc *f, bool mplane, bool out)\r\n{\r\nstruct s5p_mfc_fmt *fmt;\r\nint i, j = 0;\r\nfor (i = 0; i < ARRAY_SIZE(formats); ++i) {\r\nif (mplane && formats[i].num_planes == 1)\r\ncontinue;\r\nelse if (!mplane && formats[i].num_planes > 1)\r\ncontinue;\r\nif (out && formats[i].type != MFC_FMT_DEC)\r\ncontinue;\r\nelse if (!out && formats[i].type != MFC_FMT_RAW)\r\ncontinue;\r\nif (j == f->index)\r\nbreak;\r\n++j;\r\n}\r\nif (i == ARRAY_SIZE(formats))\r\nreturn -EINVAL;\r\nfmt = &formats[i];\r\nstrlcpy(f->description, fmt->name, sizeof(f->description));\r\nf->pixelformat = fmt->fourcc;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *pirv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn vidioc_enum_fmt(f, false, false);\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap_mplane(struct file *file, void *pirv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn vidioc_enum_fmt(f, true, false);\r\n}\r\nstatic int vidioc_enum_fmt_vid_out(struct file *file, void *prov,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn vidioc_enum_fmt(f, false, true);\r\n}\r\nstatic int vidioc_enum_fmt_vid_out_mplane(struct file *file, void *prov,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn vidioc_enum_fmt(f, true, true);\r\n}\r\nstatic int vidioc_g_fmt(struct file *file, void *priv, struct v4l2_format *f)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nstruct v4l2_pix_format_mplane *pix_mp;\r\nmfc_debug_enter();\r\npix_mp = &f->fmt.pix_mp;\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE &&\r\n(ctx->state == MFCINST_GOT_INST || ctx->state ==\r\nMFCINST_RES_CHANGE_END)) {\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\ns5p_mfc_wait_for_done_ctx(ctx, S5P_FIMV_R2H_CMD_SEQ_DONE_RET,\r\n0);\r\n}\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE &&\r\nctx->state >= MFCINST_HEAD_PARSED &&\r\nctx->state < MFCINST_ABORT) {\r\npix_mp->width = ctx->buf_width;\r\npix_mp->height = ctx->buf_height;\r\npix_mp->field = V4L2_FIELD_NONE;\r\npix_mp->num_planes = 2;\r\npix_mp->pixelformat = V4L2_PIX_FMT_NV12MT;\r\npix_mp->plane_fmt[0].bytesperline = ctx->buf_width;\r\npix_mp->plane_fmt[0].sizeimage = ctx->luma_size;\r\npix_mp->plane_fmt[1].bytesperline = ctx->buf_width;\r\npix_mp->plane_fmt[1].sizeimage = ctx->chroma_size;\r\n} else if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\npix_mp->width = 0;\r\npix_mp->height = 0;\r\npix_mp->field = V4L2_FIELD_NONE;\r\npix_mp->plane_fmt[0].bytesperline = ctx->dec_src_buf_size;\r\npix_mp->plane_fmt[0].sizeimage = ctx->dec_src_buf_size;\r\npix_mp->pixelformat = ctx->src_fmt->fourcc;\r\npix_mp->num_planes = ctx->src_fmt->num_planes;\r\n} else {\r\nmfc_err("Format could not be read\n");\r\nmfc_debug(2, "%s-- with error\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nmfc_debug_leave();\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt(struct file *file, void *priv, struct v4l2_format *f)\r\n{\r\nstruct s5p_mfc_fmt *fmt;\r\nif (f->type != V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nmfc_err("This node supports decoding only\n");\r\nreturn -EINVAL;\r\n}\r\nfmt = find_format(f, MFC_FMT_DEC);\r\nif (!fmt) {\r\nmfc_err("Unsupported format\n");\r\nreturn -EINVAL;\r\n}\r\nif (fmt->type != MFC_FMT_DEC) {\r\nmfc_err("\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt(struct file *file, void *priv, struct v4l2_format *f)\r\n{\r\nstruct s5p_mfc_dev *dev = video_drvdata(file);\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nint ret = 0;\r\nstruct s5p_mfc_fmt *fmt;\r\nstruct v4l2_pix_format_mplane *pix_mp;\r\nmfc_debug_enter();\r\nret = vidioc_try_fmt(file, priv, f);\r\npix_mp = &f->fmt.pix_mp;\r\nif (ret)\r\nreturn ret;\r\nif (ctx->vq_src.streaming || ctx->vq_dst.streaming) {\r\nv4l2_err(&dev->v4l2_dev, "%s queue busy\n", __func__);\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nfmt = find_format(f, MFC_FMT_DEC);\r\nif (!fmt || fmt->codec_mode == S5P_FIMV_CODEC_NONE) {\r\nmfc_err("Unknown codec\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (fmt->type != MFC_FMT_DEC) {\r\nmfc_err("Wrong format selected, you should choose "\r\n"format for decoding\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nctx->src_fmt = fmt;\r\nctx->codec_mode = fmt->codec_mode;\r\nmfc_debug(2, "The codec number is: %d\n", ctx->codec_mode);\r\npix_mp->height = 0;\r\npix_mp->width = 0;\r\nif (pix_mp->plane_fmt[0].sizeimage)\r\nctx->dec_src_buf_size = pix_mp->plane_fmt[0].sizeimage;\r\nelse\r\npix_mp->plane_fmt[0].sizeimage = ctx->dec_src_buf_size =\r\nDEF_CPB_SIZE;\r\npix_mp->plane_fmt[0].bytesperline = 0;\r\nctx->state = MFCINST_INIT;\r\nout:\r\nmfc_debug_leave();\r\nreturn ret;\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *reqbufs)\r\n{\r\nstruct s5p_mfc_dev *dev = video_drvdata(file);\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nint ret = 0;\r\nunsigned long flags;\r\nif (reqbufs->memory != V4L2_MEMORY_MMAP) {\r\nmfc_err("Only V4L2_MEMORY_MAP is supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (reqbufs->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nif (ctx->state == MFCINST_INIT) {\r\nctx->src_bufs_cnt = 0;\r\nif (reqbufs->count == 0) {\r\nmfc_debug(2, "Freeing buffers\n");\r\ns5p_mfc_clock_on();\r\nret = vb2_reqbufs(&ctx->vq_src, reqbufs);\r\ns5p_mfc_clock_off();\r\nreturn ret;\r\n}\r\nif (ctx->output_state != QUEUE_FREE) {\r\nmfc_err("Bufs have already been requested\n");\r\nreturn -EINVAL;\r\n}\r\ns5p_mfc_clock_on();\r\nret = vb2_reqbufs(&ctx->vq_src, reqbufs);\r\ns5p_mfc_clock_off();\r\nif (ret) {\r\nmfc_err("vb2_reqbufs on output failed\n");\r\nreturn ret;\r\n}\r\nmfc_debug(2, "vb2_reqbufs: %d\n", ret);\r\nctx->output_state = QUEUE_BUFS_REQUESTED;\r\n}\r\n} else if (reqbufs->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nctx->dst_bufs_cnt = 0;\r\nif (reqbufs->count == 0) {\r\nmfc_debug(2, "Freeing buffers\n");\r\ns5p_mfc_clock_on();\r\nret = vb2_reqbufs(&ctx->vq_dst, reqbufs);\r\ns5p_mfc_clock_off();\r\nreturn ret;\r\n}\r\nif (ctx->capture_state != QUEUE_FREE) {\r\nmfc_err("Bufs have already been requested\n");\r\nreturn -EINVAL;\r\n}\r\nctx->capture_state = QUEUE_BUFS_REQUESTED;\r\ns5p_mfc_clock_on();\r\nret = vb2_reqbufs(&ctx->vq_dst, reqbufs);\r\ns5p_mfc_clock_off();\r\nif (ret) {\r\nmfc_err("vb2_reqbufs on capture failed\n");\r\nreturn ret;\r\n}\r\nif (reqbufs->count < ctx->dpb_count) {\r\nmfc_err("Not enough buffers allocated\n");\r\nreqbufs->count = 0;\r\ns5p_mfc_clock_on();\r\nret = vb2_reqbufs(&ctx->vq_dst, reqbufs);\r\ns5p_mfc_clock_off();\r\nreturn -ENOMEM;\r\n}\r\nctx->total_dpb_count = reqbufs->count;\r\nret = s5p_mfc_alloc_codec_buffers(ctx);\r\nif (ret) {\r\nmfc_err("Failed to allocate decoding buffers\n");\r\nreqbufs->count = 0;\r\ns5p_mfc_clock_on();\r\nret = vb2_reqbufs(&ctx->vq_dst, reqbufs);\r\ns5p_mfc_clock_off();\r\nreturn -ENOMEM;\r\n}\r\nif (ctx->dst_bufs_cnt == ctx->total_dpb_count) {\r\nctx->capture_state = QUEUE_BUFS_MMAPED;\r\n} else {\r\nmfc_err("Not all buffers passed to buf_init\n");\r\nreqbufs->count = 0;\r\ns5p_mfc_clock_on();\r\nret = vb2_reqbufs(&ctx->vq_dst, reqbufs);\r\ns5p_mfc_release_codec_buffers(ctx);\r\ns5p_mfc_clock_off();\r\nreturn -ENOMEM;\r\n}\r\nif (s5p_mfc_ctx_ready(ctx)) {\r\nspin_lock_irqsave(&dev->condlock, flags);\r\nset_bit(ctx->num, &dev->ctx_work_bits);\r\nspin_unlock_irqrestore(&dev->condlock, flags);\r\n}\r\ns5p_mfc_try_run(dev);\r\ns5p_mfc_wait_for_done_ctx(ctx,\r\nS5P_FIMV_R2H_CMD_INIT_BUFFERS_RET, 0);\r\n}\r\nreturn ret;\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nint ret;\r\nint i;\r\nif (buf->memory != V4L2_MEMORY_MMAP) {\r\nmfc_err("Only mmaped buffers can be used\n");\r\nreturn -EINVAL;\r\n}\r\nmfc_debug(2, "State: %d, buf->type: %d\n", ctx->state, buf->type);\r\nif (ctx->state == MFCINST_INIT &&\r\nbuf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nret = vb2_querybuf(&ctx->vq_src, buf);\r\n} else if (ctx->state == MFCINST_RUNNING &&\r\nbuf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nret = vb2_querybuf(&ctx->vq_dst, buf);\r\nfor (i = 0; i < buf->length; i++)\r\nbuf->m.planes[i].m.mem_offset += DST_QUEUE_OFF_BASE;\r\n} else {\r\nmfc_err("vidioc_querybuf called in an inappropriate state\n");\r\nret = -EINVAL;\r\n}\r\nmfc_debug_leave();\r\nreturn ret;\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nif (ctx->state == MFCINST_ERROR) {\r\nmfc_err("Call on QBUF after unrecoverable error\n");\r\nreturn -EIO;\r\n}\r\nif (buf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\nreturn vb2_qbuf(&ctx->vq_src, buf);\r\nelse if (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\nreturn vb2_qbuf(&ctx->vq_dst, buf);\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nif (ctx->state == MFCINST_ERROR) {\r\nmfc_err("Call on DQBUF after unrecoverable error\n");\r\nreturn -EIO;\r\n}\r\nif (buf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\nreturn vb2_dqbuf(&ctx->vq_src, buf, file->f_flags & O_NONBLOCK);\r\nelse if (buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\nreturn vb2_dqbuf(&ctx->vq_dst, buf, file->f_flags & O_NONBLOCK);\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned long flags;\r\nint ret = -EINVAL;\r\nmfc_debug_enter();\r\nif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nif (ctx->state == MFCINST_INIT) {\r\nctx->dst_bufs_cnt = 0;\r\nctx->src_bufs_cnt = 0;\r\nctx->capture_state = QUEUE_FREE;\r\nctx->output_state = QUEUE_FREE;\r\ns5p_mfc_alloc_instance_buffer(ctx);\r\ns5p_mfc_alloc_dec_temp_buffers(ctx);\r\nspin_lock_irqsave(&dev->condlock, flags);\r\nset_bit(ctx->num, &dev->ctx_work_bits);\r\nspin_unlock_irqrestore(&dev->condlock, flags);\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\ns5p_mfc_try_run(dev);\r\nif (s5p_mfc_wait_for_done_ctx(ctx,\r\nS5P_FIMV_R2H_CMD_OPEN_INSTANCE_RET, 0)) {\r\nmfc_err("Error getting instance from hardware\n");\r\ns5p_mfc_release_instance_buffer(ctx);\r\ns5p_mfc_release_dec_desc_buffer(ctx);\r\nreturn -EIO;\r\n}\r\nmfc_debug(2, "Got instance number: %d\n", ctx->inst_no);\r\n}\r\nret = vb2_streamon(&ctx->vq_src, type);\r\n}\r\nelse if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\nret = vb2_streamon(&ctx->vq_dst, type);\r\nmfc_debug_leave();\r\nreturn ret;\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\nreturn vb2_streamoff(&ctx->vq_src, type);\r\nelse if (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\nreturn vb2_streamoff(&ctx->vq_dst, type);\r\nreturn -EINVAL;\r\n}\r\nstatic int s5p_mfc_dec_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct s5p_mfc_ctx *ctx = ctrl_to_ctx(ctrl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY:\r\nctx->loop_filter_mpeg4 = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY_ENABLE:\r\nctx->display_delay_enable = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_DECODER_MPEG4_DEBLOCK_FILTER:\r\nctx->display_delay = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_DECODER_SLICE_INTERFACE:\r\nctx->slice_interface = ctrl->val;\r\nbreak;\r\ndefault:\r\nmfc_err("Invalid control 0x%08x\n", ctrl->id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_dec_g_v_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct s5p_mfc_ctx *ctx = ctrl_to_ctx(ctrl);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:\r\nif (ctx->state >= MFCINST_HEAD_PARSED &&\r\nctx->state < MFCINST_ABORT) {\r\nctrl->val = ctx->dpb_count;\r\nbreak;\r\n} else if (ctx->state != MFCINST_INIT) {\r\nv4l2_err(&dev->v4l2_dev, "Decoding not initialised\n");\r\nreturn -EINVAL;\r\n}\r\ns5p_mfc_clean_ctx_int_flags(ctx);\r\ns5p_mfc_wait_for_done_ctx(ctx,\r\nS5P_FIMV_R2H_CMD_SEQ_DONE_RET, 0);\r\nif (ctx->state >= MFCINST_HEAD_PARSED &&\r\nctx->state < MFCINST_ABORT) {\r\nctrl->val = ctx->dpb_count;\r\n} else {\r\nv4l2_err(&dev->v4l2_dev, "Decoding not initialised\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_crop(struct file *file, void *priv,\r\nstruct v4l2_crop *cr)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(priv);\r\nu32 left, right, top, bottom;\r\nif (ctx->state != MFCINST_HEAD_PARSED &&\r\nctx->state != MFCINST_RUNNING && ctx->state != MFCINST_FINISHING\r\n&& ctx->state != MFCINST_FINISHED) {\r\nmfc_err("Cannont set crop\n");\r\nreturn -EINVAL;\r\n}\r\nif (ctx->src_fmt->fourcc == V4L2_PIX_FMT_H264) {\r\nleft = s5p_mfc_read_shm(ctx, CROP_INFO_H);\r\nright = left >> S5P_FIMV_SHARED_CROP_RIGHT_SHIFT;\r\nleft = left & S5P_FIMV_SHARED_CROP_LEFT_MASK;\r\ntop = s5p_mfc_read_shm(ctx, CROP_INFO_V);\r\nbottom = top >> S5P_FIMV_SHARED_CROP_BOTTOM_SHIFT;\r\ntop = top & S5P_FIMV_SHARED_CROP_TOP_MASK;\r\ncr->c.left = left;\r\ncr->c.top = top;\r\ncr->c.width = ctx->img_width - left - right;\r\ncr->c.height = ctx->img_height - top - bottom;\r\nmfc_debug(2, "Cropping info [h264]: l=%d t=%d "\r\n"w=%d h=%d (r=%d b=%d fw=%d fh=%d\n", left, top,\r\ncr->c.width, cr->c.height, right, bottom,\r\nctx->buf_width, ctx->buf_height);\r\n} else {\r\ncr->c.left = 0;\r\ncr->c.top = 0;\r\ncr->c.width = ctx->img_width;\r\ncr->c.height = ctx->img_height;\r\nmfc_debug(2, "Cropping info: w=%d h=%d fw=%d "\r\n"fh=%d\n", cr->c.width, cr->c.height, ctx->buf_width,\r\nctx->buf_height);\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_queue_setup(struct vb2_queue *vq,\r\nconst struct v4l2_format *fmt, unsigned int *buf_count,\r\nunsigned int *plane_count, unsigned int psize[],\r\nvoid *allocators[])\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(vq->drv_priv);\r\nif (ctx->state == MFCINST_INIT &&\r\nvq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\n*plane_count = 1;\r\nif (*buf_count < 1)\r\n*buf_count = 1;\r\nif (*buf_count > MFC_MAX_BUFFERS)\r\n*buf_count = MFC_MAX_BUFFERS;\r\n} else if (ctx->state == MFCINST_HEAD_PARSED &&\r\nvq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\n*plane_count = 2;\r\nif (*buf_count < ctx->dpb_count)\r\n*buf_count = ctx->dpb_count;\r\nif (*buf_count > ctx->dpb_count + MFC_MAX_EXTRA_DPB)\r\n*buf_count = ctx->dpb_count + MFC_MAX_EXTRA_DPB;\r\nif (*buf_count > MFC_MAX_BUFFERS)\r\n*buf_count = MFC_MAX_BUFFERS;\r\n} else {\r\nmfc_err("State seems invalid. State = %d, vq->type = %d\n",\r\nctx->state, vq->type);\r\nreturn -EINVAL;\r\n}\r\nmfc_debug(2, "Buffer count=%d, plane count=%d\n",\r\n*buf_count, *plane_count);\r\nif (ctx->state == MFCINST_HEAD_PARSED &&\r\nvq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\npsize[0] = ctx->luma_size;\r\npsize[1] = ctx->chroma_size;\r\nallocators[0] = ctx->dev->alloc_ctx[MFC_BANK2_ALLOC_CTX];\r\nallocators[1] = ctx->dev->alloc_ctx[MFC_BANK1_ALLOC_CTX];\r\n} else if (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE &&\r\nctx->state == MFCINST_INIT) {\r\npsize[0] = ctx->dec_src_buf_size;\r\nallocators[0] = ctx->dev->alloc_ctx[MFC_BANK1_ALLOC_CTX];\r\n} else {\r\nmfc_err("This video node is dedicated to decoding. Decoding not initalised\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void s5p_mfc_unlock(struct vb2_queue *q)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(q->drv_priv);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nmutex_unlock(&dev->mfc_mutex);\r\n}\r\nstatic void s5p_mfc_lock(struct vb2_queue *q)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(q->drv_priv);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nmutex_lock(&dev->mfc_mutex);\r\n}\r\nstatic int s5p_mfc_buf_init(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *vq = vb->vb2_queue;\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(vq->drv_priv);\r\nunsigned int i;\r\nif (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nif (ctx->capture_state == QUEUE_BUFS_MMAPED)\r\nreturn 0;\r\nfor (i = 0; i <= ctx->src_fmt->num_planes ; i++) {\r\nif (IS_ERR_OR_NULL(ERR_PTR(\r\nvb2_dma_contig_plane_dma_addr(vb, i)))) {\r\nmfc_err("Plane mem not allocated\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (vb2_plane_size(vb, 0) < ctx->luma_size ||\r\nvb2_plane_size(vb, 1) < ctx->chroma_size) {\r\nmfc_err("Plane buffer (CAPTURE) is too small\n");\r\nreturn -EINVAL;\r\n}\r\ni = vb->v4l2_buf.index;\r\nctx->dst_bufs[i].b = vb;\r\nctx->dst_bufs[i].cookie.raw.luma =\r\nvb2_dma_contig_plane_dma_addr(vb, 0);\r\nctx->dst_bufs[i].cookie.raw.chroma =\r\nvb2_dma_contig_plane_dma_addr(vb, 1);\r\nctx->dst_bufs_cnt++;\r\n} else if (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nif (IS_ERR_OR_NULL(ERR_PTR(\r\nvb2_dma_contig_plane_dma_addr(vb, 0)))) {\r\nmfc_err("Plane memory not allocated\n");\r\nreturn -EINVAL;\r\n}\r\nif (vb2_plane_size(vb, 0) < ctx->dec_src_buf_size) {\r\nmfc_err("Plane buffer (OUTPUT) is too small\n");\r\nreturn -EINVAL;\r\n}\r\ni = vb->v4l2_buf.index;\r\nctx->src_bufs[i].b = vb;\r\nctx->src_bufs[i].cookie.stream =\r\nvb2_dma_contig_plane_dma_addr(vb, 0);\r\nctx->src_bufs_cnt++;\r\n} else {\r\nmfc_err("s5p_mfc_buf_init: unknown queue type\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(q->drv_priv);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned long flags;\r\nv4l2_ctrl_handler_setup(&ctx->ctrl_handler);\r\nif (ctx->state == MFCINST_FINISHING ||\r\nctx->state == MFCINST_FINISHED)\r\nctx->state = MFCINST_RUNNING;\r\nif (s5p_mfc_ctx_ready(ctx)) {\r\nspin_lock_irqsave(&dev->condlock, flags);\r\nset_bit(ctx->num, &dev->ctx_work_bits);\r\nspin_unlock_irqrestore(&dev->condlock, flags);\r\n}\r\ns5p_mfc_try_run(dev);\r\nreturn 0;\r\n}\r\nstatic int s5p_mfc_stop_streaming(struct vb2_queue *q)\r\n{\r\nunsigned long flags;\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(q->drv_priv);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nint aborted = 0;\r\nif ((ctx->state == MFCINST_FINISHING ||\r\nctx->state == MFCINST_RUNNING) &&\r\ndev->curr_ctx == ctx->num && dev->hw_lock) {\r\nctx->state = MFCINST_ABORT;\r\ns5p_mfc_wait_for_done_ctx(ctx,\r\nS5P_FIMV_R2H_CMD_FRAME_DONE_RET, 0);\r\naborted = 1;\r\n}\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nif (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\ns5p_mfc_cleanup_queue(&ctx->dst_queue, &ctx->vq_dst);\r\nINIT_LIST_HEAD(&ctx->dst_queue);\r\nctx->dst_queue_cnt = 0;\r\nctx->dpb_flush_flag = 1;\r\nctx->dec_dst_flag = 0;\r\n}\r\nif (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\ns5p_mfc_cleanup_queue(&ctx->src_queue, &ctx->vq_src);\r\nINIT_LIST_HEAD(&ctx->src_queue);\r\nctx->src_queue_cnt = 0;\r\n}\r\nif (aborted)\r\nctx->state = MFCINST_RUNNING;\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\nreturn 0;\r\n}\r\nstatic void s5p_mfc_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *vq = vb->vb2_queue;\r\nstruct s5p_mfc_ctx *ctx = fh_to_ctx(vq->drv_priv);\r\nstruct s5p_mfc_dev *dev = ctx->dev;\r\nunsigned long flags;\r\nstruct s5p_mfc_buf *mfc_buf;\r\nif (vq->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nmfc_buf = &ctx->src_bufs[vb->v4l2_buf.index];\r\nmfc_buf->used = 0;\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nlist_add_tail(&mfc_buf->list, &ctx->src_queue);\r\nctx->src_queue_cnt++;\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\n} else if (vq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nmfc_buf = &ctx->dst_bufs[vb->v4l2_buf.index];\r\nmfc_buf->used = 0;\r\nspin_lock_irqsave(&dev->irqlock, flags);\r\nset_bit(vb->v4l2_buf.index, &ctx->dec_dst_flag);\r\nlist_add_tail(&mfc_buf->list, &ctx->dst_queue);\r\nctx->dst_queue_cnt++;\r\nspin_unlock_irqrestore(&dev->irqlock, flags);\r\n} else {\r\nmfc_err("Unsupported buffer type (%d)\n", vq->type);\r\n}\r\nif (s5p_mfc_ctx_ready(ctx)) {\r\nspin_lock_irqsave(&dev->condlock, flags);\r\nset_bit(ctx->num, &dev->ctx_work_bits);\r\nspin_unlock_irqrestore(&dev->condlock, flags);\r\n}\r\ns5p_mfc_try_run(dev);\r\n}\r\nstruct s5p_mfc_codec_ops *get_dec_codec_ops(void)\r\n{\r\nreturn &decoder_codec_ops;\r\n}\r\nstruct vb2_ops *get_dec_queue_ops(void)\r\n{\r\nreturn &s5p_mfc_dec_qops;\r\n}\r\nconst struct v4l2_ioctl_ops *get_dec_v4l2_ioctl_ops(void)\r\n{\r\nreturn &s5p_mfc_dec_ioctl_ops;\r\n}\r\nint s5p_mfc_dec_ctrls_setup(struct s5p_mfc_ctx *ctx)\r\n{\r\nstruct v4l2_ctrl_config cfg;\r\nint i;\r\nv4l2_ctrl_handler_init(&ctx->ctrl_handler, NUM_CTRLS);\r\nif (ctx->ctrl_handler.error) {\r\nmfc_err("v4l2_ctrl_handler_init failed\n");\r\nreturn ctx->ctrl_handler.error;\r\n}\r\nfor (i = 0; i < NUM_CTRLS; i++) {\r\nif (IS_MFC51_PRIV(controls[i].id)) {\r\ncfg.ops = &s5p_mfc_dec_ctrl_ops;\r\ncfg.id = controls[i].id;\r\ncfg.min = controls[i].minimum;\r\ncfg.max = controls[i].maximum;\r\ncfg.def = controls[i].default_value;\r\ncfg.name = controls[i].name;\r\ncfg.type = controls[i].type;\r\ncfg.step = controls[i].step;\r\ncfg.menu_skip_mask = 0;\r\nctx->ctrls[i] = v4l2_ctrl_new_custom(&ctx->ctrl_handler,\r\n&cfg, NULL);\r\n} else {\r\nctx->ctrls[i] = v4l2_ctrl_new_std(&ctx->ctrl_handler,\r\n&s5p_mfc_dec_ctrl_ops,\r\ncontrols[i].id, controls[i].minimum,\r\ncontrols[i].maximum, controls[i].step,\r\ncontrols[i].default_value);\r\n}\r\nif (ctx->ctrl_handler.error) {\r\nmfc_err("Adding control (%d) failed\n", i);\r\nreturn ctx->ctrl_handler.error;\r\n}\r\nif (controls[i].is_volatile && ctx->ctrls[i])\r\nctx->ctrls[i]->flags |= V4L2_CTRL_FLAG_VOLATILE;\r\n}\r\nreturn 0;\r\n}\r\nvoid s5p_mfc_dec_ctrls_delete(struct s5p_mfc_ctx *ctx)\r\n{\r\nint i;\r\nv4l2_ctrl_handler_free(&ctx->ctrl_handler);\r\nfor (i = 0; i < NUM_CTRLS; i++)\r\nctx->ctrls[i] = NULL;\r\n}
