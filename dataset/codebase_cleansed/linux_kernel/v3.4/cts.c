static int crypto_cts_setkey(struct crypto_tfm *parent, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_cts_ctx *ctx = crypto_tfm_ctx(parent);\r\nstruct crypto_blkcipher *child = ctx->child;\r\nint err;\r\ncrypto_blkcipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);\r\ncrypto_blkcipher_set_flags(child, crypto_tfm_get_flags(parent) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_blkcipher_setkey(child, key, keylen);\r\ncrypto_tfm_set_flags(parent, crypto_blkcipher_get_flags(child) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic int cts_cbc_encrypt(struct crypto_cts_ctx *ctx,\r\nstruct blkcipher_desc *desc,\r\nstruct scatterlist *dst,\r\nstruct scatterlist *src,\r\nunsigned int offset,\r\nunsigned int nbytes)\r\n{\r\nint bsize = crypto_blkcipher_blocksize(desc->tfm);\r\nu8 tmp[bsize], tmp2[bsize];\r\nstruct blkcipher_desc lcldesc;\r\nstruct scatterlist sgsrc[1], sgdst[1];\r\nint lastn = nbytes - bsize;\r\nu8 iv[bsize];\r\nu8 s[bsize * 2], d[bsize * 2];\r\nint err;\r\nif (lastn < 0)\r\nreturn -EINVAL;\r\nsg_init_table(sgsrc, 1);\r\nsg_init_table(sgdst, 1);\r\nmemset(s, 0, sizeof(s));\r\nscatterwalk_map_and_copy(s, src, offset, nbytes, 0);\r\nmemcpy(iv, desc->info, bsize);\r\nlcldesc.tfm = ctx->child;\r\nlcldesc.info = iv;\r\nlcldesc.flags = desc->flags;\r\nsg_set_buf(&sgsrc[0], s, bsize);\r\nsg_set_buf(&sgdst[0], tmp, bsize);\r\nerr = crypto_blkcipher_encrypt_iv(&lcldesc, sgdst, sgsrc, bsize);\r\nmemcpy(d + bsize, tmp, lastn);\r\nlcldesc.info = tmp;\r\nsg_set_buf(&sgsrc[0], s + bsize, bsize);\r\nsg_set_buf(&sgdst[0], tmp2, bsize);\r\nerr = crypto_blkcipher_encrypt_iv(&lcldesc, sgdst, sgsrc, bsize);\r\nmemcpy(d, tmp2, bsize);\r\nscatterwalk_map_and_copy(d, dst, offset, nbytes, 1);\r\nmemcpy(desc->info, tmp2, bsize);\r\nreturn err;\r\n}\r\nstatic int crypto_cts_encrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct crypto_cts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nint bsize = crypto_blkcipher_blocksize(desc->tfm);\r\nint tot_blocks = (nbytes + bsize - 1) / bsize;\r\nint cbc_blocks = tot_blocks > 2 ? tot_blocks - 2 : 0;\r\nstruct blkcipher_desc lcldesc;\r\nint err;\r\nlcldesc.tfm = ctx->child;\r\nlcldesc.info = desc->info;\r\nlcldesc.flags = desc->flags;\r\nif (tot_blocks == 1) {\r\nerr = crypto_blkcipher_encrypt_iv(&lcldesc, dst, src, bsize);\r\n} else if (nbytes <= bsize * 2) {\r\nerr = cts_cbc_encrypt(ctx, desc, dst, src, 0, nbytes);\r\n} else {\r\nerr = crypto_blkcipher_encrypt_iv(&lcldesc, dst, src,\r\ncbc_blocks * bsize);\r\nif (err == 0) {\r\nerr = cts_cbc_encrypt(ctx, desc, dst, src,\r\ncbc_blocks * bsize,\r\nnbytes - (cbc_blocks * bsize));\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int cts_cbc_decrypt(struct crypto_cts_ctx *ctx,\r\nstruct blkcipher_desc *desc,\r\nstruct scatterlist *dst,\r\nstruct scatterlist *src,\r\nunsigned int offset,\r\nunsigned int nbytes)\r\n{\r\nint bsize = crypto_blkcipher_blocksize(desc->tfm);\r\nu8 tmp[bsize];\r\nstruct blkcipher_desc lcldesc;\r\nstruct scatterlist sgsrc[1], sgdst[1];\r\nint lastn = nbytes - bsize;\r\nu8 iv[bsize];\r\nu8 s[bsize * 2], d[bsize * 2];\r\nint err;\r\nif (lastn < 0)\r\nreturn -EINVAL;\r\nsg_init_table(sgsrc, 1);\r\nsg_init_table(sgdst, 1);\r\nscatterwalk_map_and_copy(s, src, offset, nbytes, 0);\r\nlcldesc.tfm = ctx->child;\r\nlcldesc.info = iv;\r\nlcldesc.flags = desc->flags;\r\nmemset(iv, 0, sizeof(iv));\r\nsg_set_buf(&sgsrc[0], s, bsize);\r\nsg_set_buf(&sgdst[0], tmp, bsize);\r\nerr = crypto_blkcipher_decrypt_iv(&lcldesc, sgdst, sgsrc, bsize);\r\nif (err)\r\nreturn err;\r\nmemset(iv, 0, sizeof(iv));\r\nmemcpy(iv, s + bsize, lastn);\r\ncrypto_xor(tmp, iv, bsize);\r\nmemcpy(d + bsize, tmp, lastn);\r\nmemcpy(s + bsize + lastn, tmp + lastn, bsize - lastn);\r\nmemset(iv, 0, sizeof(iv));\r\nsg_set_buf(&sgsrc[0], s + bsize, bsize);\r\nsg_set_buf(&sgdst[0], d, bsize);\r\nerr = crypto_blkcipher_decrypt_iv(&lcldesc, sgdst, sgsrc, bsize);\r\ncrypto_xor(d, desc->info, bsize);\r\nscatterwalk_map_and_copy(d, dst, offset, nbytes, 1);\r\nmemcpy(desc->info, s, bsize);\r\nreturn err;\r\n}\r\nstatic int crypto_cts_decrypt(struct blkcipher_desc *desc,\r\nstruct scatterlist *dst, struct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nstruct crypto_cts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nint bsize = crypto_blkcipher_blocksize(desc->tfm);\r\nint tot_blocks = (nbytes + bsize - 1) / bsize;\r\nint cbc_blocks = tot_blocks > 2 ? tot_blocks - 2 : 0;\r\nstruct blkcipher_desc lcldesc;\r\nint err;\r\nlcldesc.tfm = ctx->child;\r\nlcldesc.info = desc->info;\r\nlcldesc.flags = desc->flags;\r\nif (tot_blocks == 1) {\r\nerr = crypto_blkcipher_decrypt_iv(&lcldesc, dst, src, bsize);\r\n} else if (nbytes <= bsize * 2) {\r\nerr = cts_cbc_decrypt(ctx, desc, dst, src, 0, nbytes);\r\n} else {\r\nerr = crypto_blkcipher_decrypt_iv(&lcldesc, dst, src,\r\ncbc_blocks * bsize);\r\nif (err == 0) {\r\nerr = cts_cbc_decrypt(ctx, desc, dst, src,\r\ncbc_blocks * bsize,\r\nnbytes - (cbc_blocks * bsize));\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int crypto_cts_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_instance *inst = (void *)tfm->__crt_alg;\r\nstruct crypto_spawn *spawn = crypto_instance_ctx(inst);\r\nstruct crypto_cts_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct crypto_blkcipher *cipher;\r\ncipher = crypto_spawn_blkcipher(spawn);\r\nif (IS_ERR(cipher))\r\nreturn PTR_ERR(cipher);\r\nctx->child = cipher;\r\nreturn 0;\r\n}\r\nstatic void crypto_cts_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_cts_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_blkcipher(ctx->child);\r\n}\r\nstatic struct crypto_instance *crypto_cts_alloc(struct rtattr **tb)\r\n{\r\nstruct crypto_instance *inst;\r\nstruct crypto_alg *alg;\r\nint err;\r\nerr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_BLKCIPHER);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nalg = crypto_attr_alg(tb[1], CRYPTO_ALG_TYPE_BLKCIPHER,\r\nCRYPTO_ALG_TYPE_MASK);\r\nerr = PTR_ERR(alg);\r\nif (IS_ERR(alg))\r\nreturn ERR_PTR(err);\r\ninst = ERR_PTR(-EINVAL);\r\nif (!is_power_of_2(alg->cra_blocksize))\r\ngoto out_put_alg;\r\ninst = crypto_alloc_instance("cts", alg);\r\nif (IS_ERR(inst))\r\ngoto out_put_alg;\r\ninst->alg.cra_flags = CRYPTO_ALG_TYPE_BLKCIPHER;\r\ninst->alg.cra_priority = alg->cra_priority;\r\ninst->alg.cra_blocksize = alg->cra_blocksize;\r\ninst->alg.cra_alignmask = alg->cra_alignmask;\r\ninst->alg.cra_type = &crypto_blkcipher_type;\r\ninst->alg.cra_alignmask |= __alignof__(u32) - 1;\r\ninst->alg.cra_blkcipher.ivsize = alg->cra_blocksize;\r\ninst->alg.cra_blkcipher.min_keysize = alg->cra_blkcipher.min_keysize;\r\ninst->alg.cra_blkcipher.max_keysize = alg->cra_blkcipher.max_keysize;\r\ninst->alg.cra_blkcipher.geniv = "seqiv";\r\ninst->alg.cra_ctxsize = sizeof(struct crypto_cts_ctx);\r\ninst->alg.cra_init = crypto_cts_init_tfm;\r\ninst->alg.cra_exit = crypto_cts_exit_tfm;\r\ninst->alg.cra_blkcipher.setkey = crypto_cts_setkey;\r\ninst->alg.cra_blkcipher.encrypt = crypto_cts_encrypt;\r\ninst->alg.cra_blkcipher.decrypt = crypto_cts_decrypt;\r\nout_put_alg:\r\ncrypto_mod_put(alg);\r\nreturn inst;\r\n}\r\nstatic void crypto_cts_free(struct crypto_instance *inst)\r\n{\r\ncrypto_drop_spawn(crypto_instance_ctx(inst));\r\nkfree(inst);\r\n}\r\nstatic int __init crypto_cts_module_init(void)\r\n{\r\nreturn crypto_register_template(&crypto_cts_tmpl);\r\n}\r\nstatic void __exit crypto_cts_module_exit(void)\r\n{\r\ncrypto_unregister_template(&crypto_cts_tmpl);\r\n}
