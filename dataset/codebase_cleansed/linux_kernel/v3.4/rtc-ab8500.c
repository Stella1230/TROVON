static unsigned long get_elapsed_seconds(int year)\r\n{\r\nunsigned long secs;\r\nstruct rtc_time tm = {\r\n.tm_year = year - 1900,\r\n.tm_mday = 1,\r\n};\r\nrtc_tm_to_time(&tm, &secs);\r\nreturn secs;\r\n}\r\nstatic int ab8500_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nunsigned long timeout = jiffies + HZ;\r\nint retval, i;\r\nunsigned long mins, secs;\r\nunsigned char buf[ARRAY_SIZE(ab8500_rtc_time_regs)];\r\nu8 value;\r\nretval = abx500_set_register_interruptible(dev,\r\nAB8500_RTC, AB8500_RTC_READ_REQ_REG, RTC_READ_REQUEST);\r\nif (retval < 0)\r\nreturn retval;\r\nif (abx500_get_chip_id(dev) == 0) {\r\nusleep_range(1000, 1000);\r\n} else {\r\nwhile (time_before(jiffies, timeout)) {\r\nretval = abx500_get_register_interruptible(dev,\r\nAB8500_RTC, AB8500_RTC_READ_REQ_REG, &value);\r\nif (retval < 0)\r\nreturn retval;\r\nif (!(value & RTC_READ_REQUEST))\r\nbreak;\r\nusleep_range(1000, 5000);\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(ab8500_rtc_time_regs); i++) {\r\nretval = abx500_get_register_interruptible(dev,\r\nAB8500_RTC, ab8500_rtc_time_regs[i], &value);\r\nif (retval < 0)\r\nreturn retval;\r\nbuf[i] = value;\r\n}\r\nmins = (buf[0] << 16) | (buf[1] << 8) | buf[2];\r\nsecs = (buf[3] << 8) | buf[4];\r\nsecs = secs / COUNTS_PER_SEC;\r\nsecs = secs + (mins * 60);\r\nsecs += get_elapsed_seconds(AB8500_RTC_EPOCH);\r\nrtc_time_to_tm(secs, tm);\r\nreturn rtc_valid_tm(tm);\r\n}\r\nstatic int ab8500_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nint retval, i;\r\nunsigned char buf[ARRAY_SIZE(ab8500_rtc_time_regs)];\r\nunsigned long no_secs, no_mins, secs = 0;\r\nif (tm->tm_year < (AB8500_RTC_EPOCH - 1900)) {\r\ndev_dbg(dev, "year should be equal to or greater than %d\n",\r\nAB8500_RTC_EPOCH);\r\nreturn -EINVAL;\r\n}\r\nrtc_tm_to_time(tm, &secs);\r\nsecs -= get_elapsed_seconds(AB8500_RTC_EPOCH);\r\nno_mins = secs / 60;\r\nno_secs = secs % 60;\r\nno_secs = no_secs * COUNTS_PER_SEC;\r\nbuf[4] = no_secs & 0xFF;\r\nbuf[3] = (no_secs >> 8) & 0xFF;\r\nbuf[2] = no_mins & 0xFF;\r\nbuf[1] = (no_mins >> 8) & 0xFF;\r\nbuf[0] = (no_mins >> 16) & 0xFF;\r\nfor (i = 0; i < ARRAY_SIZE(ab8500_rtc_time_regs); i++) {\r\nretval = abx500_set_register_interruptible(dev, AB8500_RTC,\r\nab8500_rtc_time_regs[i], buf[i]);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nreturn abx500_set_register_interruptible(dev, AB8500_RTC,\r\nAB8500_RTC_READ_REQ_REG, RTC_WRITE_REQUEST);\r\n}\r\nstatic int ab8500_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nint retval, i;\r\nu8 rtc_ctrl, value;\r\nunsigned char buf[ARRAY_SIZE(ab8500_rtc_alarm_regs)];\r\nunsigned long secs, mins;\r\nretval = abx500_get_register_interruptible(dev, AB8500_RTC,\r\nAB8500_RTC_STAT_REG, &rtc_ctrl);\r\nif (retval < 0)\r\nreturn retval;\r\nif (rtc_ctrl & RTC_ALARM_ENA)\r\nalarm->enabled = 1;\r\nelse\r\nalarm->enabled = 0;\r\nalarm->pending = 0;\r\nfor (i = 0; i < ARRAY_SIZE(ab8500_rtc_alarm_regs); i++) {\r\nretval = abx500_get_register_interruptible(dev, AB8500_RTC,\r\nab8500_rtc_alarm_regs[i], &value);\r\nif (retval < 0)\r\nreturn retval;\r\nbuf[i] = value;\r\n}\r\nmins = (buf[0] << 16) | (buf[1] << 8) | (buf[2]);\r\nsecs = mins * 60;\r\nsecs += get_elapsed_seconds(AB8500_RTC_EPOCH);\r\nrtc_time_to_tm(secs, &alarm->time);\r\nreturn rtc_valid_tm(&alarm->time);\r\n}\r\nstatic int ab8500_rtc_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nreturn abx500_mask_and_set_register_interruptible(dev, AB8500_RTC,\r\nAB8500_RTC_STAT_REG, RTC_ALARM_ENA,\r\nenabled ? RTC_ALARM_ENA : 0);\r\n}\r\nstatic int ab8500_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nint retval, i;\r\nunsigned char buf[ARRAY_SIZE(ab8500_rtc_alarm_regs)];\r\nunsigned long mins, secs = 0;\r\nif (alarm->time.tm_year < (AB8500_RTC_EPOCH - 1900)) {\r\ndev_dbg(dev, "year should be equal to or greater than %d\n",\r\nAB8500_RTC_EPOCH);\r\nreturn -EINVAL;\r\n}\r\nrtc_tm_to_time(&alarm->time, &secs);\r\nsecs -= get_elapsed_seconds(AB8500_RTC_EPOCH);\r\nmins = secs / 60;\r\nbuf[2] = mins & 0xFF;\r\nbuf[1] = (mins >> 8) & 0xFF;\r\nbuf[0] = (mins >> 16) & 0xFF;\r\nfor (i = 0; i < ARRAY_SIZE(ab8500_rtc_alarm_regs); i++) {\r\nretval = abx500_set_register_interruptible(dev, AB8500_RTC,\r\nab8500_rtc_alarm_regs[i], buf[i]);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nreturn ab8500_rtc_irq_enable(dev, alarm->enabled);\r\n}\r\nstatic int ab8500_rtc_set_calibration(struct device *dev, int calibration)\r\n{\r\nint retval;\r\nu8 rtccal = 0;\r\nif ((calibration < -127) || (calibration > 127)) {\r\ndev_err(dev, "RtcCalibration value outside permitted range\n");\r\nreturn -EINVAL;\r\n}\r\nif (calibration >= 0)\r\nrtccal = 0x7F & calibration;\r\nelse\r\nrtccal = ~(calibration - 1) | 0x80;\r\nretval = abx500_set_register_interruptible(dev, AB8500_RTC,\r\nAB8500_RTC_CALIB_REG, rtccal);\r\nreturn retval;\r\n}\r\nstatic int ab8500_rtc_get_calibration(struct device *dev, int *calibration)\r\n{\r\nint retval;\r\nu8 rtccal = 0;\r\nretval = abx500_get_register_interruptible(dev, AB8500_RTC,\r\nAB8500_RTC_CALIB_REG, &rtccal);\r\nif (retval >= 0) {\r\nif (rtccal & 0x80)\r\n*calibration = 0 - (rtccal & 0x7F);\r\nelse\r\n*calibration = 0x7F & rtccal;\r\n}\r\nreturn retval;\r\n}\r\nstatic ssize_t ab8500_sysfs_store_rtc_calibration(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint retval;\r\nint calibration = 0;\r\nif (sscanf(buf, " %i ", &calibration) != 1) {\r\ndev_err(dev, "Failed to store RTC calibration attribute\n");\r\nreturn -EINVAL;\r\n}\r\nretval = ab8500_rtc_set_calibration(dev, calibration);\r\nreturn retval ? retval : count;\r\n}\r\nstatic ssize_t ab8500_sysfs_show_rtc_calibration(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint retval = 0;\r\nint calibration = 0;\r\nretval = ab8500_rtc_get_calibration(dev, &calibration);\r\nif (retval < 0) {\r\ndev_err(dev, "Failed to read RTC calibration attribute\n");\r\nsprintf(buf, "0\n");\r\nreturn retval;\r\n}\r\nreturn sprintf(buf, "%d\n", calibration);\r\n}\r\nstatic int ab8500_sysfs_rtc_register(struct device *dev)\r\n{\r\nreturn device_create_file(dev, &dev_attr_rtc_calibration);\r\n}\r\nstatic void ab8500_sysfs_rtc_unregister(struct device *dev)\r\n{\r\ndevice_remove_file(dev, &dev_attr_rtc_calibration);\r\n}\r\nstatic irqreturn_t rtc_alarm_handler(int irq, void *data)\r\n{\r\nstruct rtc_device *rtc = data;\r\nunsigned long events = RTC_IRQF | RTC_AF;\r\ndev_dbg(&rtc->dev, "%s\n", __func__);\r\nrtc_update_irq(rtc, 1, events);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit ab8500_rtc_probe(struct platform_device *pdev)\r\n{\r\nint err;\r\nstruct rtc_device *rtc;\r\nu8 rtc_ctrl;\r\nint irq;\r\nirq = platform_get_irq_byname(pdev, "ALARM");\r\nif (irq < 0)\r\nreturn irq;\r\nerr = abx500_mask_and_set_register_interruptible(&pdev->dev, AB8500_RTC,\r\nAB8500_RTC_STAT_REG, RTC_STATUS_DATA, RTC_STATUS_DATA);\r\nif (err < 0)\r\nreturn err;\r\nusleep_range(1000, 5000);\r\nerr = abx500_get_register_interruptible(&pdev->dev, AB8500_RTC,\r\nAB8500_RTC_STAT_REG, &rtc_ctrl);\r\nif (err < 0)\r\nreturn err;\r\nif (!(rtc_ctrl & RTC_STATUS_DATA)) {\r\ndev_err(&pdev->dev, "RTC supply failure\n");\r\nreturn -ENODEV;\r\n}\r\ndevice_init_wakeup(&pdev->dev, true);\r\nrtc = rtc_device_register("ab8500-rtc", &pdev->dev, &ab8500_rtc_ops,\r\nTHIS_MODULE);\r\nif (IS_ERR(rtc)) {\r\ndev_err(&pdev->dev, "Registration failed\n");\r\nerr = PTR_ERR(rtc);\r\nreturn err;\r\n}\r\nerr = request_threaded_irq(irq, NULL, rtc_alarm_handler,\r\nIRQF_NO_SUSPEND, "ab8500-rtc", rtc);\r\nif (err < 0) {\r\nrtc_device_unregister(rtc);\r\nreturn err;\r\n}\r\nplatform_set_drvdata(pdev, rtc);\r\nerr = ab8500_sysfs_rtc_register(&pdev->dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "sysfs RTC failed to register\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devexit ab8500_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct rtc_device *rtc = platform_get_drvdata(pdev);\r\nint irq = platform_get_irq_byname(pdev, "ALARM");\r\nab8500_sysfs_rtc_unregister(&pdev->dev);\r\nfree_irq(irq, rtc);\r\nrtc_device_unregister(rtc);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
