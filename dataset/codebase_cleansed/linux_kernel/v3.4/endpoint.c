static inline unsigned get_usb_full_speed_rate(unsigned int rate)\r\n{\r\nreturn ((rate << 13) + 62) / 125;\r\n}\r\nstatic inline unsigned get_usb_high_speed_rate(unsigned int rate)\r\n{\r\nreturn ((rate << 10) + 62) / 125;\r\n}\r\nstatic int deactivate_urbs(struct snd_usb_substream *subs, int force, int can_sleep)\r\n{\r\nstruct snd_usb_audio *chip = subs->stream->chip;\r\nunsigned int i;\r\nint async;\r\nsubs->running = 0;\r\nif (!force && subs->stream->chip->shutdown)\r\nreturn -EBADFD;\r\nasync = !can_sleep && chip->async_unlink;\r\nif (!async && in_interrupt())\r\nreturn 0;\r\nfor (i = 0; i < subs->nurbs; i++) {\r\nif (test_bit(i, &subs->active_mask)) {\r\nif (!test_and_set_bit(i, &subs->unlink_mask)) {\r\nstruct urb *u = subs->dataurb[i].urb;\r\nif (async)\r\nusb_unlink_urb(u);\r\nelse\r\nusb_kill_urb(u);\r\n}\r\n}\r\n}\r\nif (subs->syncpipe) {\r\nfor (i = 0; i < SYNC_URBS; i++) {\r\nif (test_bit(i+16, &subs->active_mask)) {\r\nif (!test_and_set_bit(i+16, &subs->unlink_mask)) {\r\nstruct urb *u = subs->syncurb[i].urb;\r\nif (async)\r\nusb_unlink_urb(u);\r\nelse\r\nusb_kill_urb(u);\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void release_urb_ctx(struct snd_urb_ctx *u)\r\n{\r\nif (u->urb) {\r\nif (u->buffer_size)\r\nusb_free_coherent(u->subs->dev, u->buffer_size,\r\nu->urb->transfer_buffer,\r\nu->urb->transfer_dma);\r\nusb_free_urb(u->urb);\r\nu->urb = NULL;\r\n}\r\n}\r\nstatic int wait_clear_urbs(struct snd_usb_substream *subs)\r\n{\r\nunsigned long end_time = jiffies + msecs_to_jiffies(1000);\r\nunsigned int i;\r\nint alive;\r\ndo {\r\nalive = 0;\r\nfor (i = 0; i < subs->nurbs; i++) {\r\nif (test_bit(i, &subs->active_mask))\r\nalive++;\r\n}\r\nif (subs->syncpipe) {\r\nfor (i = 0; i < SYNC_URBS; i++) {\r\nif (test_bit(i + 16, &subs->active_mask))\r\nalive++;\r\n}\r\n}\r\nif (! alive)\r\nbreak;\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_before(jiffies, end_time));\r\nif (alive)\r\nsnd_printk(KERN_ERR "timeout: still %d active urbs..\n", alive);\r\nreturn 0;\r\n}\r\nvoid snd_usb_release_substream_urbs(struct snd_usb_substream *subs, int force)\r\n{\r\nint i;\r\ndeactivate_urbs(subs, force, 1);\r\nwait_clear_urbs(subs);\r\nfor (i = 0; i < MAX_URBS; i++)\r\nrelease_urb_ctx(&subs->dataurb[i]);\r\nfor (i = 0; i < SYNC_URBS; i++)\r\nrelease_urb_ctx(&subs->syncurb[i]);\r\nusb_free_coherent(subs->dev, SYNC_URBS * 4,\r\nsubs->syncbuf, subs->sync_dma);\r\nsubs->syncbuf = NULL;\r\nsubs->nurbs = 0;\r\n}\r\nstatic void snd_complete_urb(struct urb *urb)\r\n{\r\nstruct snd_urb_ctx *ctx = urb->context;\r\nstruct snd_usb_substream *subs = ctx->subs;\r\nstruct snd_pcm_substream *substream = ctx->subs->pcm_substream;\r\nint err = 0;\r\nif ((subs->running && subs->ops.retire(subs, substream->runtime, urb)) ||\r\n!subs->running ||\r\n(err = subs->ops.prepare(subs, substream->runtime, urb)) < 0 ||\r\n(err = usb_submit_urb(urb, GFP_ATOMIC)) < 0) {\r\nclear_bit(ctx->index, &subs->active_mask);\r\nif (err < 0) {\r\nsnd_printd(KERN_ERR "cannot submit urb (err = %d)\n", err);\r\nsnd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);\r\n}\r\n}\r\n}\r\nstatic void snd_complete_sync_urb(struct urb *urb)\r\n{\r\nstruct snd_urb_ctx *ctx = urb->context;\r\nstruct snd_usb_substream *subs = ctx->subs;\r\nstruct snd_pcm_substream *substream = ctx->subs->pcm_substream;\r\nint err = 0;\r\nif ((subs->running && subs->ops.retire_sync(subs, substream->runtime, urb)) ||\r\n!subs->running ||\r\n(err = subs->ops.prepare_sync(subs, substream->runtime, urb)) < 0 ||\r\n(err = usb_submit_urb(urb, GFP_ATOMIC)) < 0) {\r\nclear_bit(ctx->index + 16, &subs->active_mask);\r\nif (err < 0) {\r\nsnd_printd(KERN_ERR "cannot submit sync urb (err = %d)\n", err);\r\nsnd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);\r\n}\r\n}\r\n}\r\nint snd_usb_init_substream_urbs(struct snd_usb_substream *subs,\r\nunsigned int period_bytes,\r\nunsigned int rate,\r\nunsigned int frame_bits)\r\n{\r\nunsigned int maxsize, i;\r\nint is_playback = subs->direction == SNDRV_PCM_STREAM_PLAYBACK;\r\nunsigned int urb_packs, total_packs, packs_per_ms;\r\nstruct snd_usb_audio *chip = subs->stream->chip;\r\nif (snd_usb_get_speed(subs->dev) == USB_SPEED_FULL)\r\nsubs->freqn = get_usb_full_speed_rate(rate);\r\nelse\r\nsubs->freqn = get_usb_high_speed_rate(rate);\r\nsubs->freqm = subs->freqn;\r\nsubs->freqshift = INT_MIN;\r\nif (subs->maxpacksize) {\r\nmaxsize = subs->maxpacksize;\r\nsubs->freqmax = (maxsize / (frame_bits >> 3))\r\n<< (16 - subs->datainterval);\r\n} else {\r\nsubs->freqmax = subs->freqn + (subs->freqn >> 2);\r\nmaxsize = ((subs->freqmax + 0xffff) * (frame_bits >> 3))\r\n>> (16 - subs->datainterval);\r\n}\r\nsubs->phase = 0;\r\nif (subs->fill_max)\r\nsubs->curpacksize = subs->maxpacksize;\r\nelse\r\nsubs->curpacksize = maxsize;\r\nif (snd_usb_get_speed(subs->dev) != USB_SPEED_FULL)\r\npacks_per_ms = 8 >> subs->datainterval;\r\nelse\r\npacks_per_ms = 1;\r\nif (is_playback) {\r\nurb_packs = max(chip->nrpacks, 1);\r\nurb_packs = min(urb_packs, (unsigned int)MAX_PACKS);\r\n} else\r\nurb_packs = 1;\r\nurb_packs *= packs_per_ms;\r\nif (subs->syncpipe)\r\nurb_packs = min(urb_packs, 1U << subs->syncinterval);\r\nif (is_playback) {\r\nunsigned int minsize, maxpacks;\r\nminsize = (subs->freqn >> (16 - subs->datainterval))\r\n* (frame_bits >> 3);\r\nif (subs->syncpipe)\r\nminsize -= minsize >> 3;\r\nminsize = max(minsize, 1u);\r\ntotal_packs = (period_bytes + minsize - 1) / minsize;\r\nif (total_packs < 2) {\r\ntotal_packs = 2;\r\n} else {\r\nmaxpacks = max(MAX_QUEUE * packs_per_ms, urb_packs * 2);\r\ntotal_packs = min(total_packs, maxpacks);\r\n}\r\n} else {\r\nwhile (urb_packs > 1 && urb_packs * maxsize >= period_bytes)\r\nurb_packs >>= 1;\r\ntotal_packs = MAX_URBS * urb_packs;\r\n}\r\nsubs->nurbs = (total_packs + urb_packs - 1) / urb_packs;\r\nif (subs->nurbs > MAX_URBS) {\r\nsubs->nurbs = MAX_URBS;\r\ntotal_packs = MAX_URBS * urb_packs;\r\n} else if (subs->nurbs < 2) {\r\nsubs->nurbs = 2;\r\n}\r\nfor (i = 0; i < subs->nurbs; i++) {\r\nstruct snd_urb_ctx *u = &subs->dataurb[i];\r\nu->index = i;\r\nu->subs = subs;\r\nu->packets = (i + 1) * total_packs / subs->nurbs\r\n- i * total_packs / subs->nurbs;\r\nu->buffer_size = maxsize * u->packets;\r\nif (subs->fmt_type == UAC_FORMAT_TYPE_II)\r\nu->packets++;\r\nu->urb = usb_alloc_urb(u->packets, GFP_KERNEL);\r\nif (!u->urb)\r\ngoto out_of_memory;\r\nu->urb->transfer_buffer =\r\nusb_alloc_coherent(subs->dev, u->buffer_size,\r\nGFP_KERNEL, &u->urb->transfer_dma);\r\nif (!u->urb->transfer_buffer)\r\ngoto out_of_memory;\r\nu->urb->pipe = subs->datapipe;\r\nu->urb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\r\nu->urb->interval = 1 << subs->datainterval;\r\nu->urb->context = u;\r\nu->urb->complete = snd_complete_urb;\r\n}\r\nif (subs->syncpipe) {\r\nsubs->syncbuf = usb_alloc_coherent(subs->dev, SYNC_URBS * 4,\r\nGFP_KERNEL, &subs->sync_dma);\r\nif (!subs->syncbuf)\r\ngoto out_of_memory;\r\nfor (i = 0; i < SYNC_URBS; i++) {\r\nstruct snd_urb_ctx *u = &subs->syncurb[i];\r\nu->index = i;\r\nu->subs = subs;\r\nu->packets = 1;\r\nu->urb = usb_alloc_urb(1, GFP_KERNEL);\r\nif (!u->urb)\r\ngoto out_of_memory;\r\nu->urb->transfer_buffer = subs->syncbuf + i * 4;\r\nu->urb->transfer_dma = subs->sync_dma + i * 4;\r\nu->urb->transfer_buffer_length = 4;\r\nu->urb->pipe = subs->syncpipe;\r\nu->urb->transfer_flags = URB_ISO_ASAP |\r\nURB_NO_TRANSFER_DMA_MAP;\r\nu->urb->number_of_packets = 1;\r\nu->urb->interval = 1 << subs->syncinterval;\r\nu->urb->context = u;\r\nu->urb->complete = snd_complete_sync_urb;\r\n}\r\n}\r\nreturn 0;\r\nout_of_memory:\r\nsnd_usb_release_substream_urbs(subs, 0);\r\nreturn -ENOMEM;\r\n}\r\nstatic int prepare_capture_sync_urb(struct snd_usb_substream *subs,\r\nstruct snd_pcm_runtime *runtime,\r\nstruct urb *urb)\r\n{\r\nunsigned char *cp = urb->transfer_buffer;\r\nstruct snd_urb_ctx *ctx = urb->context;\r\nurb->dev = ctx->subs->dev;\r\nurb->iso_frame_desc[0].length = 3;\r\nurb->iso_frame_desc[0].offset = 0;\r\ncp[0] = subs->freqn >> 2;\r\ncp[1] = subs->freqn >> 10;\r\ncp[2] = subs->freqn >> 18;\r\nreturn 0;\r\n}\r\nstatic int prepare_capture_sync_urb_hs(struct snd_usb_substream *subs,\r\nstruct snd_pcm_runtime *runtime,\r\nstruct urb *urb)\r\n{\r\nunsigned char *cp = urb->transfer_buffer;\r\nstruct snd_urb_ctx *ctx = urb->context;\r\nurb->dev = ctx->subs->dev;\r\nurb->iso_frame_desc[0].length = 4;\r\nurb->iso_frame_desc[0].offset = 0;\r\ncp[0] = subs->freqn;\r\ncp[1] = subs->freqn >> 8;\r\ncp[2] = subs->freqn >> 16;\r\ncp[3] = subs->freqn >> 24;\r\nreturn 0;\r\n}\r\nstatic int retire_capture_sync_urb(struct snd_usb_substream *subs,\r\nstruct snd_pcm_runtime *runtime,\r\nstruct urb *urb)\r\n{\r\nreturn 0;\r\n}\r\nstatic int prepare_capture_urb(struct snd_usb_substream *subs,\r\nstruct snd_pcm_runtime *runtime,\r\nstruct urb *urb)\r\n{\r\nint i, offs;\r\nstruct snd_urb_ctx *ctx = urb->context;\r\noffs = 0;\r\nurb->dev = ctx->subs->dev;\r\nfor (i = 0; i < ctx->packets; i++) {\r\nurb->iso_frame_desc[i].offset = offs;\r\nurb->iso_frame_desc[i].length = subs->curpacksize;\r\noffs += subs->curpacksize;\r\n}\r\nurb->transfer_buffer_length = offs;\r\nurb->number_of_packets = ctx->packets;\r\nreturn 0;\r\n}\r\nstatic int retire_capture_urb(struct snd_usb_substream *subs,\r\nstruct snd_pcm_runtime *runtime,\r\nstruct urb *urb)\r\n{\r\nunsigned long flags;\r\nunsigned char *cp;\r\nint i;\r\nunsigned int stride, frames, bytes, oldptr;\r\nint period_elapsed = 0;\r\nstride = runtime->frame_bits >> 3;\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\ncp = (unsigned char *)urb->transfer_buffer + urb->iso_frame_desc[i].offset;\r\nif (urb->iso_frame_desc[i].status && printk_ratelimit()) {\r\nsnd_printdd("frame %d active: %d\n", i, urb->iso_frame_desc[i].status);\r\n}\r\nbytes = urb->iso_frame_desc[i].actual_length;\r\nframes = bytes / stride;\r\nif (!subs->txfr_quirk)\r\nbytes = frames * stride;\r\nif (bytes % (runtime->sample_bits >> 3) != 0) {\r\n#ifdef CONFIG_SND_DEBUG_VERBOSE\r\nint oldbytes = bytes;\r\n#endif\r\nbytes = frames * stride;\r\nsnd_printdd(KERN_ERR "Corrected urb data len. %d->%d\n",\r\noldbytes, bytes);\r\n}\r\nspin_lock_irqsave(&subs->lock, flags);\r\noldptr = subs->hwptr_done;\r\nsubs->hwptr_done += bytes;\r\nif (subs->hwptr_done >= runtime->buffer_size * stride)\r\nsubs->hwptr_done -= runtime->buffer_size * stride;\r\nframes = (bytes + (oldptr % stride)) / stride;\r\nsubs->transfer_done += frames;\r\nif (subs->transfer_done >= runtime->period_size) {\r\nsubs->transfer_done -= runtime->period_size;\r\nperiod_elapsed = 1;\r\n}\r\nspin_unlock_irqrestore(&subs->lock, flags);\r\nif (oldptr + bytes > runtime->buffer_size * stride) {\r\nunsigned int bytes1 =\r\nruntime->buffer_size * stride - oldptr;\r\nmemcpy(runtime->dma_area + oldptr, cp, bytes1);\r\nmemcpy(runtime->dma_area, cp + bytes1, bytes - bytes1);\r\n} else {\r\nmemcpy(runtime->dma_area + oldptr, cp, bytes);\r\n}\r\n}\r\nif (period_elapsed)\r\nsnd_pcm_period_elapsed(subs->pcm_substream);\r\nreturn 0;\r\n}\r\nstatic int retire_paused_capture_urb(struct snd_usb_substream *subs,\r\nstruct snd_pcm_runtime *runtime,\r\nstruct urb *urb)\r\n{\r\nreturn 0;\r\n}\r\nstatic int prepare_playback_sync_urb(struct snd_usb_substream *subs,\r\nstruct snd_pcm_runtime *runtime,\r\nstruct urb *urb)\r\n{\r\nstruct snd_urb_ctx *ctx = urb->context;\r\nurb->dev = ctx->subs->dev;\r\nurb->iso_frame_desc[0].length = min(4u, ctx->subs->syncmaxsize);\r\nurb->iso_frame_desc[0].offset = 0;\r\nreturn 0;\r\n}\r\nstatic int retire_playback_sync_urb(struct snd_usb_substream *subs,\r\nstruct snd_pcm_runtime *runtime,\r\nstruct urb *urb)\r\n{\r\nunsigned int f;\r\nint shift;\r\nunsigned long flags;\r\nif (urb->iso_frame_desc[0].status != 0 ||\r\nurb->iso_frame_desc[0].actual_length < 3)\r\nreturn 0;\r\nf = le32_to_cpup(urb->transfer_buffer);\r\nif (urb->iso_frame_desc[0].actual_length == 3)\r\nf &= 0x00ffffff;\r\nelse\r\nf &= 0x0fffffff;\r\nif (f == 0)\r\nreturn 0;\r\nif (unlikely(subs->freqshift == INT_MIN)) {\r\nshift = 0;\r\nwhile (f < subs->freqn - subs->freqn / 4) {\r\nf <<= 1;\r\nshift++;\r\n}\r\nwhile (f > subs->freqn + subs->freqn / 2) {\r\nf >>= 1;\r\nshift--;\r\n}\r\nsubs->freqshift = shift;\r\n}\r\nelse if (subs->freqshift >= 0)\r\nf <<= subs->freqshift;\r\nelse\r\nf >>= -subs->freqshift;\r\nif (likely(f >= subs->freqn - subs->freqn / 8 && f <= subs->freqmax)) {\r\nspin_lock_irqsave(&subs->lock, flags);\r\nsubs->freqm = f;\r\nspin_unlock_irqrestore(&subs->lock, flags);\r\n} else {\r\nsubs->freqshift = INT_MIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_usb_audio_next_packet_size(struct snd_usb_substream *subs)\r\n{\r\nif (subs->fill_max)\r\nreturn subs->maxframesize;\r\nelse {\r\nsubs->phase = (subs->phase & 0xffff)\r\n+ (subs->freqm << subs->datainterval);\r\nreturn min(subs->phase >> 16, subs->maxframesize);\r\n}\r\n}\r\nstatic int prepare_nodata_playback_urb(struct snd_usb_substream *subs,\r\nstruct snd_pcm_runtime *runtime,\r\nstruct urb *urb)\r\n{\r\nunsigned int i, offs, counts;\r\nstruct snd_urb_ctx *ctx = urb->context;\r\nint stride = runtime->frame_bits >> 3;\r\noffs = 0;\r\nurb->dev = ctx->subs->dev;\r\nfor (i = 0; i < ctx->packets; ++i) {\r\ncounts = snd_usb_audio_next_packet_size(subs);\r\nurb->iso_frame_desc[i].offset = offs * stride;\r\nurb->iso_frame_desc[i].length = counts * stride;\r\noffs += counts;\r\n}\r\nurb->number_of_packets = ctx->packets;\r\nurb->transfer_buffer_length = offs * stride;\r\nmemset(urb->transfer_buffer,\r\nruntime->format == SNDRV_PCM_FORMAT_U8 ? 0x80 : 0,\r\noffs * stride);\r\nreturn 0;\r\n}\r\nstatic int prepare_playback_urb(struct snd_usb_substream *subs,\r\nstruct snd_pcm_runtime *runtime,\r\nstruct urb *urb)\r\n{\r\nint i, stride;\r\nunsigned int counts, frames, bytes;\r\nunsigned long flags;\r\nint period_elapsed = 0;\r\nstruct snd_urb_ctx *ctx = urb->context;\r\nstride = runtime->frame_bits >> 3;\r\nframes = 0;\r\nurb->dev = ctx->subs->dev;\r\nurb->number_of_packets = 0;\r\nspin_lock_irqsave(&subs->lock, flags);\r\nfor (i = 0; i < ctx->packets; i++) {\r\ncounts = snd_usb_audio_next_packet_size(subs);\r\nurb->iso_frame_desc[i].offset = frames * stride;\r\nurb->iso_frame_desc[i].length = counts * stride;\r\nframes += counts;\r\nurb->number_of_packets++;\r\nsubs->transfer_done += counts;\r\nif (subs->transfer_done >= runtime->period_size) {\r\nsubs->transfer_done -= runtime->period_size;\r\nperiod_elapsed = 1;\r\nif (subs->fmt_type == UAC_FORMAT_TYPE_II) {\r\nif (subs->transfer_done > 0) {\r\nframes -= subs->transfer_done;\r\ncounts -= subs->transfer_done;\r\nurb->iso_frame_desc[i].length =\r\ncounts * stride;\r\nsubs->transfer_done = 0;\r\n}\r\ni++;\r\nif (i < ctx->packets) {\r\nurb->iso_frame_desc[i].offset =\r\nframes * stride;\r\nurb->iso_frame_desc[i].length = 0;\r\nurb->number_of_packets++;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (period_elapsed)\r\nbreak;\r\n}\r\nbytes = frames * stride;\r\nif (subs->hwptr_done + bytes > runtime->buffer_size * stride) {\r\nunsigned int bytes1 =\r\nruntime->buffer_size * stride - subs->hwptr_done;\r\nmemcpy(urb->transfer_buffer,\r\nruntime->dma_area + subs->hwptr_done, bytes1);\r\nmemcpy(urb->transfer_buffer + bytes1,\r\nruntime->dma_area, bytes - bytes1);\r\n} else {\r\nmemcpy(urb->transfer_buffer,\r\nruntime->dma_area + subs->hwptr_done, bytes);\r\n}\r\nsubs->hwptr_done += bytes;\r\nif (subs->hwptr_done >= runtime->buffer_size * stride)\r\nsubs->hwptr_done -= runtime->buffer_size * stride;\r\nruntime->delay = subs->last_delay;\r\nruntime->delay += frames;\r\nsubs->last_delay = runtime->delay;\r\nsubs->last_frame_number = usb_get_current_frame_number(subs->dev);\r\nsubs->last_frame_number &= 0xFF;\r\nspin_unlock_irqrestore(&subs->lock, flags);\r\nurb->transfer_buffer_length = bytes;\r\nif (period_elapsed)\r\nsnd_pcm_period_elapsed(subs->pcm_substream);\r\nreturn 0;\r\n}\r\nstatic int retire_playback_urb(struct snd_usb_substream *subs,\r\nstruct snd_pcm_runtime *runtime,\r\nstruct urb *urb)\r\n{\r\nunsigned long flags;\r\nint stride = runtime->frame_bits >> 3;\r\nint processed = urb->transfer_buffer_length / stride;\r\nint est_delay;\r\nspin_lock_irqsave(&subs->lock, flags);\r\nest_delay = snd_usb_pcm_delay(subs, runtime->rate);\r\nif (processed > subs->last_delay)\r\nsubs->last_delay = 0;\r\nelse\r\nsubs->last_delay -= processed;\r\nruntime->delay = subs->last_delay;\r\nif (abs(est_delay - subs->last_delay) * 1000 > runtime->rate * 2)\r\nsnd_printk(KERN_DEBUG "delay: estimated %d, actual %d\n",\r\nest_delay, subs->last_delay);\r\nspin_unlock_irqrestore(&subs->lock, flags);\r\nreturn 0;\r\n}\r\nstatic const char *usb_error_string(int err)\r\n{\r\nswitch (err) {\r\ncase -ENODEV:\r\nreturn "no device";\r\ncase -ENOENT:\r\nreturn "endpoint not enabled";\r\ncase -EPIPE:\r\nreturn "endpoint stalled";\r\ncase -ENOSPC:\r\nreturn "not enough bandwidth";\r\ncase -ESHUTDOWN:\r\nreturn "device disabled";\r\ncase -EHOSTUNREACH:\r\nreturn "device suspended";\r\ncase -EINVAL:\r\ncase -EAGAIN:\r\ncase -EFBIG:\r\ncase -EMSGSIZE:\r\nreturn "internal error";\r\ndefault:\r\nreturn "unknown error";\r\n}\r\n}\r\nstatic int start_urbs(struct snd_usb_substream *subs, struct snd_pcm_runtime *runtime)\r\n{\r\nunsigned int i;\r\nint err;\r\nif (subs->stream->chip->shutdown)\r\nreturn -EBADFD;\r\nfor (i = 0; i < subs->nurbs; i++) {\r\nif (snd_BUG_ON(!subs->dataurb[i].urb))\r\nreturn -EINVAL;\r\nif (subs->ops.prepare(subs, runtime, subs->dataurb[i].urb) < 0) {\r\nsnd_printk(KERN_ERR "cannot prepare datapipe for urb %d\n", i);\r\ngoto __error;\r\n}\r\n}\r\nif (subs->syncpipe) {\r\nfor (i = 0; i < SYNC_URBS; i++) {\r\nif (snd_BUG_ON(!subs->syncurb[i].urb))\r\nreturn -EINVAL;\r\nif (subs->ops.prepare_sync(subs, runtime, subs->syncurb[i].urb) < 0) {\r\nsnd_printk(KERN_ERR "cannot prepare syncpipe for urb %d\n", i);\r\ngoto __error;\r\n}\r\n}\r\n}\r\nsubs->active_mask = 0;\r\nsubs->unlink_mask = 0;\r\nsubs->running = 1;\r\nfor (i = 0; i < subs->nurbs; i++) {\r\nerr = usb_submit_urb(subs->dataurb[i].urb, GFP_ATOMIC);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "cannot submit datapipe "\r\n"for urb %d, error %d: %s\n",\r\ni, err, usb_error_string(err));\r\ngoto __error;\r\n}\r\nset_bit(i, &subs->active_mask);\r\n}\r\nif (subs->syncpipe) {\r\nfor (i = 0; i < SYNC_URBS; i++) {\r\nerr = usb_submit_urb(subs->syncurb[i].urb, GFP_ATOMIC);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "cannot submit syncpipe "\r\n"for urb %d, error %d: %s\n",\r\ni, err, usb_error_string(err));\r\ngoto __error;\r\n}\r\nset_bit(i + 16, &subs->active_mask);\r\n}\r\n}\r\nreturn 0;\r\n__error:\r\ndeactivate_urbs(subs, 0, 0);\r\nreturn -EPIPE;\r\n}\r\nvoid snd_usb_init_substream(struct snd_usb_stream *as,\r\nint stream, struct audioformat *fp)\r\n{\r\nstruct snd_usb_substream *subs = &as->substream[stream];\r\nINIT_LIST_HEAD(&subs->fmt_list);\r\nspin_lock_init(&subs->lock);\r\nsubs->stream = as;\r\nsubs->direction = stream;\r\nsubs->dev = as->chip->dev;\r\nsubs->txfr_quirk = as->chip->txfr_quirk;\r\nsubs->ops = audio_urb_ops[stream];\r\nif (snd_usb_get_speed(subs->dev) >= USB_SPEED_HIGH)\r\nsubs->ops.prepare_sync = prepare_capture_sync_urb_hs;\r\nsnd_usb_set_pcm_ops(as->pcm, stream);\r\nlist_add_tail(&fp->list, &subs->fmt_list);\r\nsubs->formats |= fp->formats;\r\nsubs->endpoint = fp->endpoint;\r\nsubs->num_formats++;\r\nsubs->fmt_type = fp->fmt_type;\r\n}\r\nint snd_usb_substream_playback_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_usb_substream *subs = substream->runtime->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nsubs->ops.prepare = prepare_playback_urb;\r\nreturn 0;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nreturn deactivate_urbs(subs, 0, 0);\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nsubs->ops.prepare = prepare_nodata_playback_urb;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint snd_usb_substream_capture_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_usb_substream *subs = substream->runtime->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nsubs->ops.retire = retire_capture_urb;\r\nreturn start_urbs(subs, substream->runtime);\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nreturn deactivate_urbs(subs, 0, 0);\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nsubs->ops.retire = retire_paused_capture_urb;\r\nreturn 0;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nsubs->ops.retire = retire_capture_urb;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint snd_usb_substream_prepare(struct snd_usb_substream *subs,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\ndeactivate_urbs(subs, 0, 1);\r\nwait_clear_urbs(subs);\r\nif (subs->direction == SNDRV_PCM_STREAM_PLAYBACK) {\r\nsubs->ops.prepare = prepare_nodata_playback_urb;\r\nreturn start_urbs(subs, runtime);\r\n}\r\nreturn 0;\r\n}
