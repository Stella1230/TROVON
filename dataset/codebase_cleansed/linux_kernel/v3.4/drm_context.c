void drm_ctxbitmap_free(struct drm_device * dev, int ctx_handle)\r\n{\r\nmutex_lock(&dev->struct_mutex);\r\nidr_remove(&dev->ctx_idr, ctx_handle);\r\nmutex_unlock(&dev->struct_mutex);\r\n}\r\nstatic int drm_ctxbitmap_next(struct drm_device * dev)\r\n{\r\nint new_id;\r\nint ret;\r\nagain:\r\nif (idr_pre_get(&dev->ctx_idr, GFP_KERNEL) == 0) {\r\nDRM_ERROR("Out of memory expanding drawable idr\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_lock(&dev->struct_mutex);\r\nret = idr_get_new_above(&dev->ctx_idr, NULL,\r\nDRM_RESERVED_CONTEXTS, &new_id);\r\nif (ret == -EAGAIN) {\r\nmutex_unlock(&dev->struct_mutex);\r\ngoto again;\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn new_id;\r\n}\r\nint drm_ctxbitmap_init(struct drm_device * dev)\r\n{\r\nidr_init(&dev->ctx_idr);\r\nreturn 0;\r\n}\r\nvoid drm_ctxbitmap_cleanup(struct drm_device * dev)\r\n{\r\nmutex_lock(&dev->struct_mutex);\r\nidr_remove_all(&dev->ctx_idr);\r\nmutex_unlock(&dev->struct_mutex);\r\n}\r\nint drm_getsareactx(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_ctx_priv_map *request = data;\r\nstruct drm_local_map *map;\r\nstruct drm_map_list *_entry;\r\nmutex_lock(&dev->struct_mutex);\r\nmap = idr_find(&dev->ctx_idr, request->ctx_id);\r\nif (!map) {\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn -EINVAL;\r\n}\r\nrequest->handle = NULL;\r\nlist_for_each_entry(_entry, &dev->maplist, head) {\r\nif (_entry->map == map) {\r\nrequest->handle =\r\n(void *)(unsigned long)_entry->user_token;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\nif (request->handle == NULL)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint drm_setsareactx(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_ctx_priv_map *request = data;\r\nstruct drm_local_map *map = NULL;\r\nstruct drm_map_list *r_list = NULL;\r\nmutex_lock(&dev->struct_mutex);\r\nlist_for_each_entry(r_list, &dev->maplist, head) {\r\nif (r_list->map\r\n&& r_list->user_token == (unsigned long) request->handle)\r\ngoto found;\r\n}\r\nbad:\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn -EINVAL;\r\nfound:\r\nmap = r_list->map;\r\nif (!map)\r\ngoto bad;\r\nif (IS_ERR(idr_replace(&dev->ctx_idr, map, request->ctx_id)))\r\ngoto bad;\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn 0;\r\n}\r\nstatic int drm_context_switch(struct drm_device * dev, int old, int new)\r\n{\r\nif (test_and_set_bit(0, &dev->context_flag)) {\r\nDRM_ERROR("Reentering -- FIXME\n");\r\nreturn -EBUSY;\r\n}\r\nDRM_DEBUG("Context switch from %d to %d\n", old, new);\r\nif (new == dev->last_context) {\r\nclear_bit(0, &dev->context_flag);\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int drm_context_switch_complete(struct drm_device *dev,\r\nstruct drm_file *file_priv, int new)\r\n{\r\ndev->last_context = new;\r\ndev->last_switch = jiffies;\r\nif (!_DRM_LOCK_IS_HELD(file_priv->master->lock.hw_lock->lock)) {\r\nDRM_ERROR("Lock isn't held after context switch\n");\r\n}\r\nclear_bit(0, &dev->context_flag);\r\nwake_up(&dev->context_wait);\r\nreturn 0;\r\n}\r\nint drm_resctx(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_ctx_res *res = data;\r\nstruct drm_ctx ctx;\r\nint i;\r\nif (res->count >= DRM_RESERVED_CONTEXTS) {\r\nmemset(&ctx, 0, sizeof(ctx));\r\nfor (i = 0; i < DRM_RESERVED_CONTEXTS; i++) {\r\nctx.handle = i;\r\nif (copy_to_user(&res->contexts[i], &ctx, sizeof(ctx)))\r\nreturn -EFAULT;\r\n}\r\n}\r\nres->count = DRM_RESERVED_CONTEXTS;\r\nreturn 0;\r\n}\r\nint drm_addctx(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_ctx_list *ctx_entry;\r\nstruct drm_ctx *ctx = data;\r\nctx->handle = drm_ctxbitmap_next(dev);\r\nif (ctx->handle == DRM_KERNEL_CONTEXT) {\r\nctx->handle = drm_ctxbitmap_next(dev);\r\n}\r\nDRM_DEBUG("%d\n", ctx->handle);\r\nif (ctx->handle == -1) {\r\nDRM_DEBUG("Not enough free contexts.\n");\r\nreturn -ENOMEM;\r\n}\r\nctx_entry = kmalloc(sizeof(*ctx_entry), GFP_KERNEL);\r\nif (!ctx_entry) {\r\nDRM_DEBUG("out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&ctx_entry->head);\r\nctx_entry->handle = ctx->handle;\r\nctx_entry->tag = file_priv;\r\nmutex_lock(&dev->ctxlist_mutex);\r\nlist_add(&ctx_entry->head, &dev->ctxlist);\r\n++dev->ctx_count;\r\nmutex_unlock(&dev->ctxlist_mutex);\r\nreturn 0;\r\n}\r\nint drm_modctx(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\nreturn 0;\r\n}\r\nint drm_getctx(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\nstruct drm_ctx *ctx = data;\r\nctx->flags = 0;\r\nreturn 0;\r\n}\r\nint drm_switchctx(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_ctx *ctx = data;\r\nDRM_DEBUG("%d\n", ctx->handle);\r\nreturn drm_context_switch(dev, dev->last_context, ctx->handle);\r\n}\r\nint drm_newctx(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_ctx *ctx = data;\r\nDRM_DEBUG("%d\n", ctx->handle);\r\ndrm_context_switch_complete(dev, file_priv, ctx->handle);\r\nreturn 0;\r\n}\r\nint drm_rmctx(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_ctx *ctx = data;\r\nDRM_DEBUG("%d\n", ctx->handle);\r\nif (ctx->handle != DRM_KERNEL_CONTEXT) {\r\nif (dev->driver->context_dtor)\r\ndev->driver->context_dtor(dev, ctx->handle);\r\ndrm_ctxbitmap_free(dev, ctx->handle);\r\n}\r\nmutex_lock(&dev->ctxlist_mutex);\r\nif (!list_empty(&dev->ctxlist)) {\r\nstruct drm_ctx_list *pos, *n;\r\nlist_for_each_entry_safe(pos, n, &dev->ctxlist, head) {\r\nif (pos->handle == ctx->handle) {\r\nlist_del(&pos->head);\r\nkfree(pos);\r\n--dev->ctx_count;\r\n}\r\n}\r\n}\r\nmutex_unlock(&dev->ctxlist_mutex);\r\nreturn 0;\r\n}
