static long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nconst unsigned minor = iminor(file->f_dentry->d_inode);\r\nstruct comedi_device_file_info *dev_file_info =\r\ncomedi_get_device_file_info(minor);\r\nstruct comedi_device *dev;\r\nint rc;\r\nif (dev_file_info == NULL || dev_file_info->device == NULL)\r\nreturn -ENODEV;\r\ndev = dev_file_info->device;\r\nmutex_lock(&dev->mutex);\r\nif (cmd == COMEDI_DEVCONFIG) {\r\nrc = do_devconfig_ioctl(dev,\r\n(struct comedi_devconfig __user *)arg);\r\ngoto done;\r\n}\r\nif (!dev->attached) {\r\nDPRINTK("no driver configured on /dev/comedi%i\n", dev->minor);\r\nrc = -ENODEV;\r\ngoto done;\r\n}\r\nswitch (cmd) {\r\ncase COMEDI_BUFCONFIG:\r\nrc = do_bufconfig_ioctl(dev,\r\n(struct comedi_bufconfig __user *)arg);\r\nbreak;\r\ncase COMEDI_DEVINFO:\r\nrc = do_devinfo_ioctl(dev, (struct comedi_devinfo __user *)arg,\r\nfile);\r\nbreak;\r\ncase COMEDI_SUBDINFO:\r\nrc = do_subdinfo_ioctl(dev,\r\n(struct comedi_subdinfo __user *)arg,\r\nfile);\r\nbreak;\r\ncase COMEDI_CHANINFO:\r\nrc = do_chaninfo_ioctl(dev, (void __user *)arg);\r\nbreak;\r\ncase COMEDI_RANGEINFO:\r\nrc = do_rangeinfo_ioctl(dev, (void __user *)arg);\r\nbreak;\r\ncase COMEDI_BUFINFO:\r\nrc = do_bufinfo_ioctl(dev,\r\n(struct comedi_bufinfo __user *)arg,\r\nfile);\r\nbreak;\r\ncase COMEDI_LOCK:\r\nrc = do_lock_ioctl(dev, arg, file);\r\nbreak;\r\ncase COMEDI_UNLOCK:\r\nrc = do_unlock_ioctl(dev, arg, file);\r\nbreak;\r\ncase COMEDI_CANCEL:\r\nrc = do_cancel_ioctl(dev, arg, file);\r\nbreak;\r\ncase COMEDI_CMD:\r\nrc = do_cmd_ioctl(dev, (struct comedi_cmd __user *)arg, file);\r\nbreak;\r\ncase COMEDI_CMDTEST:\r\nrc = do_cmdtest_ioctl(dev, (struct comedi_cmd __user *)arg,\r\nfile);\r\nbreak;\r\ncase COMEDI_INSNLIST:\r\nrc = do_insnlist_ioctl(dev,\r\n(struct comedi_insnlist __user *)arg,\r\nfile);\r\nbreak;\r\ncase COMEDI_INSN:\r\nrc = do_insn_ioctl(dev, (struct comedi_insn __user *)arg,\r\nfile);\r\nbreak;\r\ncase COMEDI_POLL:\r\nrc = do_poll_ioctl(dev, arg, file);\r\nbreak;\r\ndefault:\r\nrc = -ENOTTY;\r\nbreak;\r\n}\r\ndone:\r\nmutex_unlock(&dev->mutex);\r\nreturn rc;\r\n}\r\nstatic int do_devconfig_ioctl(struct comedi_device *dev,\r\nstruct comedi_devconfig __user *arg)\r\n{\r\nstruct comedi_devconfig it;\r\nint ret;\r\nunsigned char *aux_data = NULL;\r\nint aux_len;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (arg == NULL) {\r\nif (is_device_busy(dev))\r\nreturn -EBUSY;\r\nif (dev->attached) {\r\nstruct module *driver_module = dev->driver->module;\r\ncomedi_device_detach(dev);\r\nmodule_put(driver_module);\r\n}\r\nreturn 0;\r\n}\r\nif (copy_from_user(&it, arg, sizeof(struct comedi_devconfig)))\r\nreturn -EFAULT;\r\nit.board_name[COMEDI_NAMELEN - 1] = 0;\r\nif (comedi_aux_data(it.options, 0) &&\r\nit.options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {\r\nint bit_shift;\r\naux_len = it.options[COMEDI_DEVCONF_AUX_DATA_LENGTH];\r\nif (aux_len < 0)\r\nreturn -EFAULT;\r\naux_data = vmalloc(aux_len);\r\nif (!aux_data)\r\nreturn -ENOMEM;\r\nif (copy_from_user(aux_data,\r\ncomedi_aux_data(it.options, 0), aux_len)) {\r\nvfree(aux_data);\r\nreturn -EFAULT;\r\n}\r\nit.options[COMEDI_DEVCONF_AUX_DATA_LO] =\r\n(unsigned long)aux_data;\r\nif (sizeof(void *) > sizeof(int)) {\r\nbit_shift = sizeof(int) * 8;\r\nit.options[COMEDI_DEVCONF_AUX_DATA_HI] =\r\n((unsigned long)aux_data) >> bit_shift;\r\n} else\r\nit.options[COMEDI_DEVCONF_AUX_DATA_HI] = 0;\r\n}\r\nret = comedi_device_attach(dev, &it);\r\nif (ret == 0) {\r\nif (!try_module_get(dev->driver->module)) {\r\ncomedi_device_detach(dev);\r\nreturn -ENOSYS;\r\n}\r\n}\r\nif (aux_data)\r\nvfree(aux_data);\r\nreturn ret;\r\n}\r\nstatic int do_bufconfig_ioctl(struct comedi_device *dev,\r\nstruct comedi_bufconfig __user *arg)\r\n{\r\nstruct comedi_bufconfig bc;\r\nstruct comedi_async *async;\r\nstruct comedi_subdevice *s;\r\nint retval = 0;\r\nif (copy_from_user(&bc, arg, sizeof(struct comedi_bufconfig)))\r\nreturn -EFAULT;\r\nif (bc.subdevice >= dev->n_subdevices || bc.subdevice < 0)\r\nreturn -EINVAL;\r\ns = dev->subdevices + bc.subdevice;\r\nasync = s->async;\r\nif (!async) {\r\nDPRINTK("subdevice does not have async capability\n");\r\nbc.size = 0;\r\nbc.maximum_size = 0;\r\ngoto copyback;\r\n}\r\nif (bc.maximum_size) {\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nasync->max_bufsize = bc.maximum_size;\r\n}\r\nif (bc.size) {\r\nretval = resize_async_buffer(dev, s, async, bc.size);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nbc.size = async->prealloc_bufsz;\r\nbc.maximum_size = async->max_bufsize;\r\ncopyback:\r\nif (copy_to_user(arg, &bc, sizeof(struct comedi_bufconfig)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int do_devinfo_ioctl(struct comedi_device *dev,\r\nstruct comedi_devinfo __user *arg,\r\nstruct file *file)\r\n{\r\nstruct comedi_devinfo devinfo;\r\nconst unsigned minor = iminor(file->f_dentry->d_inode);\r\nstruct comedi_device_file_info *dev_file_info =\r\ncomedi_get_device_file_info(minor);\r\nstruct comedi_subdevice *read_subdev =\r\ncomedi_get_read_subdevice(dev_file_info);\r\nstruct comedi_subdevice *write_subdev =\r\ncomedi_get_write_subdevice(dev_file_info);\r\nmemset(&devinfo, 0, sizeof(devinfo));\r\ndevinfo.version_code = COMEDI_VERSION_CODE;\r\ndevinfo.n_subdevs = dev->n_subdevices;\r\nstrlcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);\r\nstrlcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);\r\nif (read_subdev)\r\ndevinfo.read_subdevice = read_subdev - dev->subdevices;\r\nelse\r\ndevinfo.read_subdevice = -1;\r\nif (write_subdev)\r\ndevinfo.write_subdevice = write_subdev - dev->subdevices;\r\nelse\r\ndevinfo.write_subdevice = -1;\r\nif (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int do_subdinfo_ioctl(struct comedi_device *dev,\r\nstruct comedi_subdinfo __user *arg, void *file)\r\n{\r\nint ret, i;\r\nstruct comedi_subdinfo *tmp, *us;\r\nstruct comedi_subdevice *s;\r\ntmp =\r\nkcalloc(dev->n_subdevices, sizeof(struct comedi_subdinfo),\r\nGFP_KERNEL);\r\nif (!tmp)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < dev->n_subdevices; i++) {\r\ns = dev->subdevices + i;\r\nus = tmp + i;\r\nus->type = s->type;\r\nus->n_chan = s->n_chan;\r\nus->subd_flags = s->subdev_flags;\r\nif (comedi_get_subdevice_runflags(s) & SRF_RUNNING)\r\nus->subd_flags |= SDF_RUNNING;\r\n#define TIMER_nanosec 5\r\nus->timer_type = TIMER_nanosec;\r\nus->len_chanlist = s->len_chanlist;\r\nus->maxdata = s->maxdata;\r\nif (s->range_table) {\r\nus->range_type =\r\n(i << 24) | (0 << 16) | (s->range_table->length);\r\n} else {\r\nus->range_type = 0;\r\n}\r\nus->flags = s->flags;\r\nif (s->busy)\r\nus->subd_flags |= SDF_BUSY;\r\nif (s->busy == file)\r\nus->subd_flags |= SDF_BUSY_OWNER;\r\nif (s->lock)\r\nus->subd_flags |= SDF_LOCKED;\r\nif (s->lock == file)\r\nus->subd_flags |= SDF_LOCK_OWNER;\r\nif (!s->maxdata && s->maxdata_list)\r\nus->subd_flags |= SDF_MAXDATA;\r\nif (s->flaglist)\r\nus->subd_flags |= SDF_FLAGS;\r\nif (s->range_table_list)\r\nus->subd_flags |= SDF_RANGETYPE;\r\nif (s->do_cmd)\r\nus->subd_flags |= SDF_CMD;\r\nif (s->insn_bits != &insn_inval)\r\nus->insn_bits_support = COMEDI_SUPPORTED;\r\nelse\r\nus->insn_bits_support = COMEDI_UNSUPPORTED;\r\nus->settling_time_0 = s->settling_time_0;\r\n}\r\nret = copy_to_user(arg, tmp,\r\ndev->n_subdevices * sizeof(struct comedi_subdinfo));\r\nkfree(tmp);\r\nreturn ret ? -EFAULT : 0;\r\n}\r\nstatic int do_chaninfo_ioctl(struct comedi_device *dev,\r\nstruct comedi_chaninfo __user *arg)\r\n{\r\nstruct comedi_subdevice *s;\r\nstruct comedi_chaninfo it;\r\nif (copy_from_user(&it, arg, sizeof(struct comedi_chaninfo)))\r\nreturn -EFAULT;\r\nif (it.subdev >= dev->n_subdevices)\r\nreturn -EINVAL;\r\ns = dev->subdevices + it.subdev;\r\nif (it.maxdata_list) {\r\nif (s->maxdata || !s->maxdata_list)\r\nreturn -EINVAL;\r\nif (copy_to_user(it.maxdata_list, s->maxdata_list,\r\ns->n_chan * sizeof(unsigned int)))\r\nreturn -EFAULT;\r\n}\r\nif (it.flaglist) {\r\nif (!s->flaglist)\r\nreturn -EINVAL;\r\nif (copy_to_user(it.flaglist, s->flaglist,\r\ns->n_chan * sizeof(unsigned int)))\r\nreturn -EFAULT;\r\n}\r\nif (it.rangelist) {\r\nint i;\r\nif (!s->range_table_list)\r\nreturn -EINVAL;\r\nfor (i = 0; i < s->n_chan; i++) {\r\nint x;\r\nx = (dev->minor << 28) | (it.subdev << 24) | (i << 16) |\r\n(s->range_table_list[i]->length);\r\nif (put_user(x, it.rangelist + i))\r\nreturn -EFAULT;\r\n}\r\n#if 0\r\nif (copy_to_user(it.rangelist, s->range_type_list,\r\ns->n_chan * sizeof(unsigned int)))\r\nreturn -EFAULT;\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_bufinfo_ioctl(struct comedi_device *dev,\r\nstruct comedi_bufinfo __user *arg, void *file)\r\n{\r\nstruct comedi_bufinfo bi;\r\nstruct comedi_subdevice *s;\r\nstruct comedi_async *async;\r\nif (copy_from_user(&bi, arg, sizeof(struct comedi_bufinfo)))\r\nreturn -EFAULT;\r\nif (bi.subdevice >= dev->n_subdevices || bi.subdevice < 0)\r\nreturn -EINVAL;\r\ns = dev->subdevices + bi.subdevice;\r\nif (s->lock && s->lock != file)\r\nreturn -EACCES;\r\nasync = s->async;\r\nif (!async) {\r\nDPRINTK("subdevice does not have async capability\n");\r\nbi.buf_write_ptr = 0;\r\nbi.buf_read_ptr = 0;\r\nbi.buf_write_count = 0;\r\nbi.buf_read_count = 0;\r\nbi.bytes_read = 0;\r\nbi.bytes_written = 0;\r\ngoto copyback;\r\n}\r\nif (!s->busy) {\r\nbi.bytes_read = 0;\r\nbi.bytes_written = 0;\r\ngoto copyback_position;\r\n}\r\nif (s->busy != file)\r\nreturn -EACCES;\r\nif (bi.bytes_read && (s->subdev_flags & SDF_CMD_READ)) {\r\nbi.bytes_read = comedi_buf_read_alloc(async, bi.bytes_read);\r\ncomedi_buf_read_free(async, bi.bytes_read);\r\nif (!(comedi_get_subdevice_runflags(s) & (SRF_ERROR |\r\nSRF_RUNNING))\r\n&& async->buf_write_count == async->buf_read_count) {\r\ndo_become_nonbusy(dev, s);\r\n}\r\n}\r\nif (bi.bytes_written && (s->subdev_flags & SDF_CMD_WRITE)) {\r\nbi.bytes_written =\r\ncomedi_buf_write_alloc(async, bi.bytes_written);\r\ncomedi_buf_write_free(async, bi.bytes_written);\r\n}\r\ncopyback_position:\r\nbi.buf_write_count = async->buf_write_count;\r\nbi.buf_write_ptr = async->buf_write_ptr;\r\nbi.buf_read_count = async->buf_read_count;\r\nbi.buf_read_ptr = async->buf_read_ptr;\r\ncopyback:\r\nif (copy_to_user(arg, &bi, sizeof(struct comedi_bufinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int do_insnlist_ioctl(struct comedi_device *dev,\r\nstruct comedi_insnlist __user *arg, void *file)\r\n{\r\nstruct comedi_insnlist insnlist;\r\nstruct comedi_insn *insns = NULL;\r\nunsigned int *data = NULL;\r\nint i = 0;\r\nint ret = 0;\r\nif (copy_from_user(&insnlist, arg, sizeof(struct comedi_insnlist)))\r\nreturn -EFAULT;\r\ndata = kmalloc(sizeof(unsigned int) * MAX_SAMPLES, GFP_KERNEL);\r\nif (!data) {\r\nDPRINTK("kmalloc failed\n");\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\ninsns =\r\nkcalloc(insnlist.n_insns, sizeof(struct comedi_insn), GFP_KERNEL);\r\nif (!insns) {\r\nDPRINTK("kmalloc failed\n");\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (copy_from_user(insns, insnlist.insns,\r\nsizeof(struct comedi_insn) * insnlist.n_insns)) {\r\nDPRINTK("copy_from_user failed\n");\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\nfor (i = 0; i < insnlist.n_insns; i++) {\r\nif (insns[i].n > MAX_SAMPLES) {\r\nDPRINTK("number of samples too large\n");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nif (insns[i].insn & INSN_MASK_WRITE) {\r\nif (copy_from_user(data, insns[i].data,\r\ninsns[i].n * sizeof(unsigned int))) {\r\nDPRINTK("copy_from_user failed\n");\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\n}\r\nret = parse_insn(dev, insns + i, data, file);\r\nif (ret < 0)\r\ngoto error;\r\nif (insns[i].insn & INSN_MASK_READ) {\r\nif (copy_to_user(insns[i].data, data,\r\ninsns[i].n * sizeof(unsigned int))) {\r\nDPRINTK("copy_to_user failed\n");\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\n}\r\nif (need_resched())\r\nschedule();\r\n}\r\nerror:\r\nkfree(insns);\r\nkfree(data);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn i;\r\n}\r\nstatic int check_insn_config_length(struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (insn->n < 1)\r\nreturn -EINVAL;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIO_OUTPUT:\r\ncase INSN_CONFIG_DIO_INPUT:\r\ncase INSN_CONFIG_DISARM:\r\ncase INSN_CONFIG_RESET:\r\nif (insn->n == 1)\r\nreturn 0;\r\nbreak;\r\ncase INSN_CONFIG_ARM:\r\ncase INSN_CONFIG_DIO_QUERY:\r\ncase INSN_CONFIG_BLOCK_SIZE:\r\ncase INSN_CONFIG_FILTER:\r\ncase INSN_CONFIG_SERIAL_CLOCK:\r\ncase INSN_CONFIG_BIDIRECTIONAL_DATA:\r\ncase INSN_CONFIG_ALT_SOURCE:\r\ncase INSN_CONFIG_SET_COUNTER_MODE:\r\ncase INSN_CONFIG_8254_READ_STATUS:\r\ncase INSN_CONFIG_SET_ROUTING:\r\ncase INSN_CONFIG_GET_ROUTING:\r\ncase INSN_CONFIG_GET_PWM_STATUS:\r\ncase INSN_CONFIG_PWM_SET_PERIOD:\r\ncase INSN_CONFIG_PWM_GET_PERIOD:\r\nif (insn->n == 2)\r\nreturn 0;\r\nbreak;\r\ncase INSN_CONFIG_SET_GATE_SRC:\r\ncase INSN_CONFIG_GET_GATE_SRC:\r\ncase INSN_CONFIG_SET_CLOCK_SRC:\r\ncase INSN_CONFIG_GET_CLOCK_SRC:\r\ncase INSN_CONFIG_SET_OTHER_SRC:\r\ncase INSN_CONFIG_GET_COUNTER_STATUS:\r\ncase INSN_CONFIG_PWM_SET_H_BRIDGE:\r\ncase INSN_CONFIG_PWM_GET_H_BRIDGE:\r\ncase INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE:\r\nif (insn->n == 3)\r\nreturn 0;\r\nbreak;\r\ncase INSN_CONFIG_PWM_OUTPUT:\r\ncase INSN_CONFIG_ANALOG_TRIG:\r\nif (insn->n == 5)\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n"comedi: no check for data length of config insn id "\r\n"%i is implemented.\n"\r\n" Add a check to %s in %s.\n"\r\n" Assuming n=%i is correct.\n", data[0], __func__,\r\n__FILE__, insn->n);\r\nreturn 0;\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,\r\nunsigned int *data, void *file)\r\n{\r\nstruct comedi_subdevice *s;\r\nint ret = 0;\r\nint i;\r\nif (insn->insn & INSN_MASK_SPECIAL) {\r\nswitch (insn->insn) {\r\ncase INSN_GTOD:\r\n{\r\nstruct timeval tv;\r\nif (insn->n != 2) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ndo_gettimeofday(&tv);\r\ndata[0] = tv.tv_sec;\r\ndata[1] = tv.tv_usec;\r\nret = 2;\r\nbreak;\r\n}\r\ncase INSN_WAIT:\r\nif (insn->n != 1 || data[0] >= 100000) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nudelay(data[0] / 1000);\r\nret = 1;\r\nbreak;\r\ncase INSN_INTTRIG:\r\nif (insn->n != 1) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (insn->subdev >= dev->n_subdevices) {\r\nDPRINTK("%d not usable subdevice\n",\r\ninsn->subdev);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ns = dev->subdevices + insn->subdev;\r\nif (!s->async) {\r\nDPRINTK("no async\n");\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (!s->async->inttrig) {\r\nDPRINTK("no inttrig\n");\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nret = s->async->inttrig(dev, s, insn->data[0]);\r\nif (ret >= 0)\r\nret = 1;\r\nbreak;\r\ndefault:\r\nDPRINTK("invalid insn\n");\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n} else {\r\nunsigned int maxdata;\r\nif (insn->subdev >= dev->n_subdevices) {\r\nDPRINTK("subdevice %d out of range\n", insn->subdev);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ns = dev->subdevices + insn->subdev;\r\nif (s->type == COMEDI_SUBD_UNUSED) {\r\nDPRINTK("%d not usable subdevice\n", insn->subdev);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (s->lock && s->lock != file) {\r\nDPRINTK("device locked\n");\r\nret = -EACCES;\r\ngoto out;\r\n}\r\nret = comedi_check_chanlist(s, 1, &insn->chanspec);\r\nif (ret < 0) {\r\nret = -EINVAL;\r\nDPRINTK("bad chanspec\n");\r\ngoto out;\r\n}\r\nif (s->busy) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\ns->busy = &parse_insn;\r\nswitch (insn->insn) {\r\ncase INSN_READ:\r\nret = s->insn_read(dev, s, insn, data);\r\nbreak;\r\ncase INSN_WRITE:\r\nmaxdata = s->maxdata_list\r\n? s->maxdata_list[CR_CHAN(insn->chanspec)]\r\n: s->maxdata;\r\nfor (i = 0; i < insn->n; ++i) {\r\nif (data[i] > maxdata) {\r\nret = -EINVAL;\r\nDPRINTK("bad data value(s)\n");\r\nbreak;\r\n}\r\n}\r\nif (ret == 0)\r\nret = s->insn_write(dev, s, insn, data);\r\nbreak;\r\ncase INSN_BITS:\r\nif (insn->n != 2) {\r\nret = -EINVAL;\r\n} else {\r\nunsigned int shift;\r\nunsigned int orig_mask;\r\norig_mask = data[0];\r\nif (s->n_chan <= 32) {\r\nshift = CR_CHAN(insn->chanspec);\r\nif (shift > 0) {\r\ninsn->chanspec = 0;\r\ndata[0] <<= shift;\r\ndata[1] <<= shift;\r\n}\r\n} else\r\nshift = 0;\r\nret = s->insn_bits(dev, s, insn, data);\r\ndata[0] = orig_mask;\r\nif (shift > 0)\r\ndata[1] >>= shift;\r\n}\r\nbreak;\r\ncase INSN_CONFIG:\r\nret = check_insn_config_length(insn, data);\r\nif (ret)\r\nbreak;\r\nret = s->insn_config(dev, s, insn, data);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ns->busy = NULL;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int do_insn_ioctl(struct comedi_device *dev,\r\nstruct comedi_insn __user *arg, void *file)\r\n{\r\nstruct comedi_insn insn;\r\nunsigned int *data = NULL;\r\nint ret = 0;\r\ndata = kmalloc(sizeof(unsigned int) * MAX_SAMPLES, GFP_KERNEL);\r\nif (!data) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (copy_from_user(&insn, arg, sizeof(struct comedi_insn))) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\nif (insn.n > MAX_SAMPLES)\r\ninsn.n = MAX_SAMPLES;\r\nif (insn.insn & INSN_MASK_WRITE) {\r\nif (copy_from_user(data,\r\ninsn.data,\r\ninsn.n * sizeof(unsigned int))) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\n}\r\nret = parse_insn(dev, &insn, data, file);\r\nif (ret < 0)\r\ngoto error;\r\nif (insn.insn & INSN_MASK_READ) {\r\nif (copy_to_user(insn.data,\r\ndata,\r\ninsn.n * sizeof(unsigned int))) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\n}\r\nret = insn.n;\r\nerror:\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic void comedi_set_subdevice_runflags(struct comedi_subdevice *s,\r\nunsigned mask, unsigned bits)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&s->spin_lock, flags);\r\ns->runflags &= ~mask;\r\ns->runflags |= (bits & mask);\r\nspin_unlock_irqrestore(&s->spin_lock, flags);\r\n}\r\nstatic int do_cmd_ioctl(struct comedi_device *dev,\r\nstruct comedi_cmd __user *cmd, void *file)\r\n{\r\nstruct comedi_cmd user_cmd;\r\nstruct comedi_subdevice *s;\r\nstruct comedi_async *async;\r\nint ret = 0;\r\nunsigned int __user *chanlist_saver = NULL;\r\nif (copy_from_user(&user_cmd, cmd, sizeof(struct comedi_cmd))) {\r\nDPRINTK("bad cmd address\n");\r\nreturn -EFAULT;\r\n}\r\nchanlist_saver = user_cmd.chanlist;\r\nif (user_cmd.subdev >= dev->n_subdevices) {\r\nDPRINTK("%d no such subdevice\n", user_cmd.subdev);\r\nreturn -ENODEV;\r\n}\r\ns = dev->subdevices + user_cmd.subdev;\r\nasync = s->async;\r\nif (s->type == COMEDI_SUBD_UNUSED) {\r\nDPRINTK("%d not valid subdevice\n", user_cmd.subdev);\r\nreturn -EIO;\r\n}\r\nif (!s->do_cmd || !s->do_cmdtest || !s->async) {\r\nDPRINTK("subdevice %i does not support commands\n",\r\nuser_cmd.subdev);\r\nreturn -EIO;\r\n}\r\nif (s->lock && s->lock != file) {\r\nDPRINTK("subdevice locked\n");\r\nreturn -EACCES;\r\n}\r\nif (s->busy) {\r\nDPRINTK("subdevice busy\n");\r\nreturn -EBUSY;\r\n}\r\ns->busy = file;\r\nif (user_cmd.chanlist_len > s->len_chanlist) {\r\nDPRINTK("channel/gain list too long %u > %d\n",\r\nuser_cmd.chanlist_len, s->len_chanlist);\r\nret = -EINVAL;\r\ngoto cleanup;\r\n}\r\nif (user_cmd.chanlist_len < 1) {\r\nDPRINTK("channel/gain list too short %u < 1\n",\r\nuser_cmd.chanlist_len);\r\nret = -EINVAL;\r\ngoto cleanup;\r\n}\r\nkfree(async->cmd.chanlist);\r\nasync->cmd = user_cmd;\r\nasync->cmd.data = NULL;\r\nasync->cmd.chanlist =\r\nkmalloc(async->cmd.chanlist_len * sizeof(int), GFP_KERNEL);\r\nif (!async->cmd.chanlist) {\r\nDPRINTK("allocation failed\n");\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nif (copy_from_user(async->cmd.chanlist, user_cmd.chanlist,\r\nasync->cmd.chanlist_len * sizeof(int))) {\r\nDPRINTK("fault reading chanlist\n");\r\nret = -EFAULT;\r\ngoto cleanup;\r\n}\r\nret = comedi_check_chanlist(s,\r\nasync->cmd.chanlist_len,\r\nasync->cmd.chanlist);\r\nif (ret < 0) {\r\nDPRINTK("bad chanlist\n");\r\ngoto cleanup;\r\n}\r\nret = s->do_cmdtest(dev, s, &async->cmd);\r\nif (async->cmd.flags & TRIG_BOGUS || ret) {\r\nDPRINTK("test returned %d\n", ret);\r\nuser_cmd = async->cmd;\r\nuser_cmd.chanlist = chanlist_saver;\r\nuser_cmd.data = NULL;\r\nif (copy_to_user(cmd, &user_cmd, sizeof(struct comedi_cmd))) {\r\nDPRINTK("fault writing cmd\n");\r\nret = -EFAULT;\r\ngoto cleanup;\r\n}\r\nret = -EAGAIN;\r\ngoto cleanup;\r\n}\r\nif (!async->prealloc_bufsz) {\r\nret = -ENOMEM;\r\nDPRINTK("no buffer (?)\n");\r\ngoto cleanup;\r\n}\r\ncomedi_reset_async_buf(async);\r\nasync->cb_mask =\r\nCOMEDI_CB_EOA | COMEDI_CB_BLOCK | COMEDI_CB_ERROR |\r\nCOMEDI_CB_OVERFLOW;\r\nif (async->cmd.flags & TRIG_WAKE_EOS)\r\nasync->cb_mask |= COMEDI_CB_EOS;\r\ncomedi_set_subdevice_runflags(s, ~0, SRF_USER | SRF_RUNNING);\r\nret = s->do_cmd(dev, s);\r\nif (ret == 0)\r\nreturn 0;\r\ncleanup:\r\ndo_become_nonbusy(dev, s);\r\nreturn ret;\r\n}\r\nstatic int do_cmdtest_ioctl(struct comedi_device *dev,\r\nstruct comedi_cmd __user *arg, void *file)\r\n{\r\nstruct comedi_cmd user_cmd;\r\nstruct comedi_subdevice *s;\r\nint ret = 0;\r\nunsigned int *chanlist = NULL;\r\nunsigned int __user *chanlist_saver = NULL;\r\nif (copy_from_user(&user_cmd, arg, sizeof(struct comedi_cmd))) {\r\nDPRINTK("bad cmd address\n");\r\nreturn -EFAULT;\r\n}\r\nchanlist_saver = user_cmd.chanlist;\r\nif (user_cmd.subdev >= dev->n_subdevices) {\r\nDPRINTK("%d no such subdevice\n", user_cmd.subdev);\r\nreturn -ENODEV;\r\n}\r\ns = dev->subdevices + user_cmd.subdev;\r\nif (s->type == COMEDI_SUBD_UNUSED) {\r\nDPRINTK("%d not valid subdevice\n", user_cmd.subdev);\r\nreturn -EIO;\r\n}\r\nif (!s->do_cmd || !s->do_cmdtest) {\r\nDPRINTK("subdevice %i does not support commands\n",\r\nuser_cmd.subdev);\r\nreturn -EIO;\r\n}\r\nif (user_cmd.chanlist_len > s->len_chanlist) {\r\nDPRINTK("channel/gain list too long %d > %d\n",\r\nuser_cmd.chanlist_len, s->len_chanlist);\r\nret = -EINVAL;\r\ngoto cleanup;\r\n}\r\nif (user_cmd.chanlist) {\r\nchanlist =\r\nkmalloc(user_cmd.chanlist_len * sizeof(int), GFP_KERNEL);\r\nif (!chanlist) {\r\nDPRINTK("allocation failed\n");\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nif (copy_from_user(chanlist, user_cmd.chanlist,\r\nuser_cmd.chanlist_len * sizeof(int))) {\r\nDPRINTK("fault reading chanlist\n");\r\nret = -EFAULT;\r\ngoto cleanup;\r\n}\r\nret = comedi_check_chanlist(s, user_cmd.chanlist_len, chanlist);\r\nif (ret < 0) {\r\nDPRINTK("bad chanlist\n");\r\ngoto cleanup;\r\n}\r\nuser_cmd.chanlist = chanlist;\r\n}\r\nret = s->do_cmdtest(dev, s, &user_cmd);\r\nuser_cmd.chanlist = chanlist_saver;\r\nif (copy_to_user(arg, &user_cmd, sizeof(struct comedi_cmd))) {\r\nDPRINTK("bad cmd address\n");\r\nret = -EFAULT;\r\ngoto cleanup;\r\n}\r\ncleanup:\r\nkfree(chanlist);\r\nreturn ret;\r\n}\r\nstatic int do_lock_ioctl(struct comedi_device *dev, unsigned int arg,\r\nvoid *file)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nstruct comedi_subdevice *s;\r\nif (arg >= dev->n_subdevices)\r\nreturn -EINVAL;\r\ns = dev->subdevices + arg;\r\nspin_lock_irqsave(&s->spin_lock, flags);\r\nif (s->busy || s->lock)\r\nret = -EBUSY;\r\nelse\r\ns->lock = file;\r\nspin_unlock_irqrestore(&s->spin_lock, flags);\r\n#if 0\r\nif (ret < 0)\r\nreturn ret;\r\nif (s->lock_f)\r\nret = s->lock_f(dev, s);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int do_unlock_ioctl(struct comedi_device *dev, unsigned int arg,\r\nvoid *file)\r\n{\r\nstruct comedi_subdevice *s;\r\nif (arg >= dev->n_subdevices)\r\nreturn -EINVAL;\r\ns = dev->subdevices + arg;\r\nif (s->busy)\r\nreturn -EBUSY;\r\nif (s->lock && s->lock != file)\r\nreturn -EACCES;\r\nif (s->lock == file) {\r\n#if 0\r\nif (s->unlock)\r\ns->unlock(dev, s);\r\n#endif\r\ns->lock = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_cancel_ioctl(struct comedi_device *dev, unsigned int arg,\r\nvoid *file)\r\n{\r\nstruct comedi_subdevice *s;\r\nif (arg >= dev->n_subdevices)\r\nreturn -EINVAL;\r\ns = dev->subdevices + arg;\r\nif (s->async == NULL)\r\nreturn -EINVAL;\r\nif (s->lock && s->lock != file)\r\nreturn -EACCES;\r\nif (!s->busy)\r\nreturn 0;\r\nif (s->busy != file)\r\nreturn -EBUSY;\r\nreturn do_cancel(dev, s);\r\n}\r\nstatic int do_poll_ioctl(struct comedi_device *dev, unsigned int arg,\r\nvoid *file)\r\n{\r\nstruct comedi_subdevice *s;\r\nif (arg >= dev->n_subdevices)\r\nreturn -EINVAL;\r\ns = dev->subdevices + arg;\r\nif (s->lock && s->lock != file)\r\nreturn -EACCES;\r\nif (!s->busy)\r\nreturn 0;\r\nif (s->busy != file)\r\nreturn -EBUSY;\r\nif (s->poll)\r\nreturn s->poll(dev, s);\r\nreturn -EINVAL;\r\n}\r\nstatic int do_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nint ret = 0;\r\nif ((comedi_get_subdevice_runflags(s) & SRF_RUNNING) && s->cancel)\r\nret = s->cancel(dev, s);\r\ndo_become_nonbusy(dev, s);\r\nreturn ret;\r\n}\r\nstatic void comedi_vm_open(struct vm_area_struct *area)\r\n{\r\nstruct comedi_async *async;\r\nstruct comedi_device *dev;\r\nasync = area->vm_private_data;\r\ndev = async->subdevice->device;\r\nmutex_lock(&dev->mutex);\r\nasync->mmap_count++;\r\nmutex_unlock(&dev->mutex);\r\n}\r\nstatic void comedi_vm_close(struct vm_area_struct *area)\r\n{\r\nstruct comedi_async *async;\r\nstruct comedi_device *dev;\r\nasync = area->vm_private_data;\r\ndev = async->subdevice->device;\r\nmutex_lock(&dev->mutex);\r\nasync->mmap_count--;\r\nmutex_unlock(&dev->mutex);\r\n}\r\nstatic int comedi_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nconst unsigned minor = iminor(file->f_dentry->d_inode);\r\nstruct comedi_async *async = NULL;\r\nunsigned long start = vma->vm_start;\r\nunsigned long size;\r\nint n_pages;\r\nint i;\r\nint retval;\r\nstruct comedi_subdevice *s;\r\nstruct comedi_device_file_info *dev_file_info;\r\nstruct comedi_device *dev;\r\ndev_file_info = comedi_get_device_file_info(minor);\r\nif (dev_file_info == NULL)\r\nreturn -ENODEV;\r\ndev = dev_file_info->device;\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\nmutex_lock(&dev->mutex);\r\nif (!dev->attached) {\r\nDPRINTK("no driver configured on comedi%i\n", dev->minor);\r\nretval = -ENODEV;\r\ngoto done;\r\n}\r\nif (vma->vm_flags & VM_WRITE)\r\ns = comedi_get_write_subdevice(dev_file_info);\r\nelse\r\ns = comedi_get_read_subdevice(dev_file_info);\r\nif (s == NULL) {\r\nretval = -EINVAL;\r\ngoto done;\r\n}\r\nasync = s->async;\r\nif (async == NULL) {\r\nretval = -EINVAL;\r\ngoto done;\r\n}\r\nif (vma->vm_pgoff != 0) {\r\nDPRINTK("comedi: mmap() offset must be 0.\n");\r\nretval = -EINVAL;\r\ngoto done;\r\n}\r\nsize = vma->vm_end - vma->vm_start;\r\nif (size > async->prealloc_bufsz) {\r\nretval = -EFAULT;\r\ngoto done;\r\n}\r\nif (size & (~PAGE_MASK)) {\r\nretval = -EFAULT;\r\ngoto done;\r\n}\r\nn_pages = size >> PAGE_SHIFT;\r\nfor (i = 0; i < n_pages; ++i) {\r\nif (remap_pfn_range(vma, start,\r\npage_to_pfn(virt_to_page\r\n(async->buf_page_list\r\n[i].virt_addr)), PAGE_SIZE,\r\nPAGE_SHARED)) {\r\nretval = -EAGAIN;\r\ngoto done;\r\n}\r\nstart += PAGE_SIZE;\r\n}\r\nvma->vm_ops = &comedi_vm_ops;\r\nvma->vm_private_data = async;\r\nasync->mmap_count++;\r\nretval = 0;\r\ndone:\r\nmutex_unlock(&dev->mutex);\r\nreturn retval;\r\n}\r\nstatic unsigned int comedi_poll(struct file *file, poll_table * wait)\r\n{\r\nunsigned int mask = 0;\r\nconst unsigned minor = iminor(file->f_dentry->d_inode);\r\nstruct comedi_subdevice *read_subdev;\r\nstruct comedi_subdevice *write_subdev;\r\nstruct comedi_device_file_info *dev_file_info;\r\nstruct comedi_device *dev;\r\ndev_file_info = comedi_get_device_file_info(minor);\r\nif (dev_file_info == NULL)\r\nreturn -ENODEV;\r\ndev = dev_file_info->device;\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\nmutex_lock(&dev->mutex);\r\nif (!dev->attached) {\r\nDPRINTK("no driver configured on comedi%i\n", dev->minor);\r\nmutex_unlock(&dev->mutex);\r\nreturn 0;\r\n}\r\nmask = 0;\r\nread_subdev = comedi_get_read_subdevice(dev_file_info);\r\nif (read_subdev) {\r\npoll_wait(file, &read_subdev->async->wait_head, wait);\r\nif (!read_subdev->busy\r\n|| comedi_buf_read_n_available(read_subdev->async) > 0\r\n|| !(comedi_get_subdevice_runflags(read_subdev) &\r\nSRF_RUNNING)) {\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\n}\r\nwrite_subdev = comedi_get_write_subdevice(dev_file_info);\r\nif (write_subdev) {\r\npoll_wait(file, &write_subdev->async->wait_head, wait);\r\ncomedi_buf_write_alloc(write_subdev->async,\r\nwrite_subdev->async->prealloc_bufsz);\r\nif (!write_subdev->busy\r\n|| !(comedi_get_subdevice_runflags(write_subdev) &\r\nSRF_RUNNING)\r\n|| comedi_buf_write_n_allocated(write_subdev->async) >=\r\nbytes_per_sample(write_subdev->async->subdevice)) {\r\nmask |= POLLOUT | POLLWRNORM;\r\n}\r\n}\r\nmutex_unlock(&dev->mutex);\r\nreturn mask;\r\n}\r\nstatic ssize_t comedi_write(struct file *file, const char __user *buf,\r\nsize_t nbytes, loff_t *offset)\r\n{\r\nstruct comedi_subdevice *s;\r\nstruct comedi_async *async;\r\nint n, m, count = 0, retval = 0;\r\nDECLARE_WAITQUEUE(wait, current);\r\nconst unsigned minor = iminor(file->f_dentry->d_inode);\r\nstruct comedi_device_file_info *dev_file_info;\r\nstruct comedi_device *dev;\r\ndev_file_info = comedi_get_device_file_info(minor);\r\nif (dev_file_info == NULL)\r\nreturn -ENODEV;\r\ndev = dev_file_info->device;\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\nif (!dev->attached) {\r\nDPRINTK("no driver configured on comedi%i\n", dev->minor);\r\nretval = -ENODEV;\r\ngoto done;\r\n}\r\ns = comedi_get_write_subdevice(dev_file_info);\r\nif (s == NULL) {\r\nretval = -EIO;\r\ngoto done;\r\n}\r\nasync = s->async;\r\nif (!nbytes) {\r\nretval = 0;\r\ngoto done;\r\n}\r\nif (!s->busy) {\r\nretval = 0;\r\ngoto done;\r\n}\r\nif (s->busy != file) {\r\nretval = -EACCES;\r\ngoto done;\r\n}\r\nadd_wait_queue(&async->wait_head, &wait);\r\nwhile (nbytes > 0 && !retval) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (!(comedi_get_subdevice_runflags(s) & SRF_RUNNING)) {\r\nif (count == 0) {\r\nif (comedi_get_subdevice_runflags(s) &\r\nSRF_ERROR) {\r\nretval = -EPIPE;\r\n} else {\r\nretval = 0;\r\n}\r\ndo_become_nonbusy(dev, s);\r\n}\r\nbreak;\r\n}\r\nn = nbytes;\r\nm = n;\r\nif (async->buf_write_ptr + m > async->prealloc_bufsz)\r\nm = async->prealloc_bufsz - async->buf_write_ptr;\r\ncomedi_buf_write_alloc(async, async->prealloc_bufsz);\r\nif (m > comedi_buf_write_n_allocated(async))\r\nm = comedi_buf_write_n_allocated(async);\r\nif (m < n)\r\nn = m;\r\nif (n == 0) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\nbreak;\r\n}\r\nschedule();\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\nif (!s->busy)\r\nbreak;\r\nif (s->busy != file) {\r\nretval = -EACCES;\r\nbreak;\r\n}\r\ncontinue;\r\n}\r\nm = copy_from_user(async->prealloc_buf + async->buf_write_ptr,\r\nbuf, n);\r\nif (m) {\r\nn -= m;\r\nretval = -EFAULT;\r\n}\r\ncomedi_buf_write_free(async, n);\r\ncount += n;\r\nnbytes -= n;\r\nbuf += n;\r\nbreak;\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&async->wait_head, &wait);\r\ndone:\r\nreturn count ? count : retval;\r\n}\r\nstatic ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,\r\nloff_t *offset)\r\n{\r\nstruct comedi_subdevice *s;\r\nstruct comedi_async *async;\r\nint n, m, count = 0, retval = 0;\r\nDECLARE_WAITQUEUE(wait, current);\r\nconst unsigned minor = iminor(file->f_dentry->d_inode);\r\nstruct comedi_device_file_info *dev_file_info;\r\nstruct comedi_device *dev;\r\ndev_file_info = comedi_get_device_file_info(minor);\r\nif (dev_file_info == NULL)\r\nreturn -ENODEV;\r\ndev = dev_file_info->device;\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\nif (!dev->attached) {\r\nDPRINTK("no driver configured on comedi%i\n", dev->minor);\r\nretval = -ENODEV;\r\ngoto done;\r\n}\r\ns = comedi_get_read_subdevice(dev_file_info);\r\nif (s == NULL) {\r\nretval = -EIO;\r\ngoto done;\r\n}\r\nasync = s->async;\r\nif (!nbytes) {\r\nretval = 0;\r\ngoto done;\r\n}\r\nif (!s->busy) {\r\nretval = 0;\r\ngoto done;\r\n}\r\nif (s->busy != file) {\r\nretval = -EACCES;\r\ngoto done;\r\n}\r\nadd_wait_queue(&async->wait_head, &wait);\r\nwhile (nbytes > 0 && !retval) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nn = nbytes;\r\nm = comedi_buf_read_n_available(async);\r\nif (async->buf_read_ptr + m > async->prealloc_bufsz)\r\nm = async->prealloc_bufsz - async->buf_read_ptr;\r\nif (m < n)\r\nn = m;\r\nif (n == 0) {\r\nif (!(comedi_get_subdevice_runflags(s) & SRF_RUNNING)) {\r\ndo_become_nonbusy(dev, s);\r\nif (comedi_get_subdevice_runflags(s) &\r\nSRF_ERROR) {\r\nretval = -EPIPE;\r\n} else {\r\nretval = 0;\r\n}\r\nbreak;\r\n}\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\nbreak;\r\n}\r\nschedule();\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\nif (!s->busy) {\r\nretval = 0;\r\nbreak;\r\n}\r\nif (s->busy != file) {\r\nretval = -EACCES;\r\nbreak;\r\n}\r\ncontinue;\r\n}\r\nm = copy_to_user(buf, async->prealloc_buf +\r\nasync->buf_read_ptr, n);\r\nif (m) {\r\nn -= m;\r\nretval = -EFAULT;\r\n}\r\ncomedi_buf_read_alloc(async, n);\r\ncomedi_buf_read_free(async, n);\r\ncount += n;\r\nnbytes -= n;\r\nbuf += n;\r\nbreak;\r\n}\r\nif (!(comedi_get_subdevice_runflags(s) & (SRF_ERROR | SRF_RUNNING)) &&\r\nasync->buf_read_count - async->buf_write_count == 0) {\r\ndo_become_nonbusy(dev, s);\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&async->wait_head, &wait);\r\ndone:\r\nreturn count ? count : retval;\r\n}\r\nvoid do_become_nonbusy(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\ncomedi_set_subdevice_runflags(s, SRF_RUNNING, 0);\r\nif (async) {\r\ncomedi_reset_async_buf(async);\r\nasync->inttrig = NULL;\r\n} else {\r\nprintk(KERN_ERR\r\n"BUG: (?) do_become_nonbusy called with async=0\n");\r\n}\r\ns->busy = NULL;\r\n}\r\nstatic int comedi_open(struct inode *inode, struct file *file)\r\n{\r\nconst unsigned minor = iminor(inode);\r\nstruct comedi_device_file_info *dev_file_info =\r\ncomedi_get_device_file_info(minor);\r\nstruct comedi_device *dev =\r\ndev_file_info ? dev_file_info->device : NULL;\r\nif (dev == NULL) {\r\nDPRINTK("invalid minor number\n");\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&dev->mutex);\r\nif (dev->attached)\r\ngoto ok;\r\nif (!capable(CAP_NET_ADMIN) && dev->in_request_module) {\r\nDPRINTK("in request module\n");\r\nmutex_unlock(&dev->mutex);\r\nreturn -ENODEV;\r\n}\r\nif (capable(CAP_NET_ADMIN) && dev->in_request_module)\r\ngoto ok;\r\ndev->in_request_module = 1;\r\n#ifdef CONFIG_KMOD\r\nmutex_unlock(&dev->mutex);\r\nrequest_module("char-major-%i-%i", COMEDI_MAJOR, dev->minor);\r\nmutex_lock(&dev->mutex);\r\n#endif\r\ndev->in_request_module = 0;\r\nif (!dev->attached && !capable(CAP_NET_ADMIN)) {\r\nDPRINTK("not attached and not CAP_NET_ADMIN\n");\r\nmutex_unlock(&dev->mutex);\r\nreturn -ENODEV;\r\n}\r\nok:\r\n__module_get(THIS_MODULE);\r\nif (dev->attached) {\r\nif (!try_module_get(dev->driver->module)) {\r\nmodule_put(THIS_MODULE);\r\nmutex_unlock(&dev->mutex);\r\nreturn -ENOSYS;\r\n}\r\n}\r\nif (dev->attached && dev->use_count == 0 && dev->open) {\r\nint rc = dev->open(dev);\r\nif (rc < 0) {\r\nmodule_put(dev->driver->module);\r\nmodule_put(THIS_MODULE);\r\nmutex_unlock(&dev->mutex);\r\nreturn rc;\r\n}\r\n}\r\ndev->use_count++;\r\nmutex_unlock(&dev->mutex);\r\nreturn 0;\r\n}\r\nstatic int comedi_close(struct inode *inode, struct file *file)\r\n{\r\nconst unsigned minor = iminor(inode);\r\nstruct comedi_subdevice *s = NULL;\r\nint i;\r\nstruct comedi_device_file_info *dev_file_info;\r\nstruct comedi_device *dev;\r\ndev_file_info = comedi_get_device_file_info(minor);\r\nif (dev_file_info == NULL)\r\nreturn -ENODEV;\r\ndev = dev_file_info->device;\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\nmutex_lock(&dev->mutex);\r\nif (dev->subdevices) {\r\nfor (i = 0; i < dev->n_subdevices; i++) {\r\ns = dev->subdevices + i;\r\nif (s->busy == file)\r\ndo_cancel(dev, s);\r\nif (s->lock == file)\r\ns->lock = NULL;\r\n}\r\n}\r\nif (dev->attached && dev->use_count == 1 && dev->close)\r\ndev->close(dev);\r\nmodule_put(THIS_MODULE);\r\nif (dev->attached)\r\nmodule_put(dev->driver->module);\r\ndev->use_count--;\r\nmutex_unlock(&dev->mutex);\r\nif (file->f_flags & FASYNC)\r\ncomedi_fasync(-1, file, 0);\r\nreturn 0;\r\n}\r\nstatic int comedi_fasync(int fd, struct file *file, int on)\r\n{\r\nconst unsigned minor = iminor(file->f_dentry->d_inode);\r\nstruct comedi_device_file_info *dev_file_info;\r\nstruct comedi_device *dev;\r\ndev_file_info = comedi_get_device_file_info(minor);\r\nif (dev_file_info == NULL)\r\nreturn -ENODEV;\r\ndev = dev_file_info->device;\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\nreturn fasync_helper(fd, file, on, &dev->async_queue);\r\n}\r\nstatic void comedi_cleanup_legacy_minors(void)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < comedi_num_legacy_minors; i++)\r\ncomedi_free_board_minor(i);\r\n}\r\nstatic int __init comedi_init(void)\r\n{\r\nint i;\r\nint retval;\r\nprintk(KERN_INFO "comedi: version " COMEDI_RELEASE\r\n" - http://www.comedi.org\n");\r\nif (comedi_num_legacy_minors < 0 ||\r\ncomedi_num_legacy_minors > COMEDI_NUM_BOARD_MINORS) {\r\nprintk(KERN_ERR "comedi: error: invalid value for module "\r\n"parameter \"comedi_num_legacy_minors\". Valid values "\r\n"are 0 through %i.\n", COMEDI_NUM_BOARD_MINORS);\r\nreturn -EINVAL;\r\n}\r\nif (comedi_autoconfig == 0 && comedi_num_legacy_minors == 0)\r\ncomedi_num_legacy_minors = 16;\r\nmemset(comedi_file_info_table, 0,\r\nsizeof(struct comedi_device_file_info *) * COMEDI_NUM_MINORS);\r\nretval = register_chrdev_region(MKDEV(COMEDI_MAJOR, 0),\r\nCOMEDI_NUM_MINORS, "comedi");\r\nif (retval)\r\nreturn -EIO;\r\ncdev_init(&comedi_cdev, &comedi_fops);\r\ncomedi_cdev.owner = THIS_MODULE;\r\nkobject_set_name(&comedi_cdev.kobj, "comedi");\r\nif (cdev_add(&comedi_cdev, MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS)) {\r\nunregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),\r\nCOMEDI_NUM_MINORS);\r\nreturn -EIO;\r\n}\r\ncomedi_class = class_create(THIS_MODULE, "comedi");\r\nif (IS_ERR(comedi_class)) {\r\nprintk(KERN_ERR "comedi: failed to create class");\r\ncdev_del(&comedi_cdev);\r\nunregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),\r\nCOMEDI_NUM_MINORS);\r\nreturn PTR_ERR(comedi_class);\r\n}\r\ncomedi_proc_init();\r\nfor (i = 0; i < comedi_num_legacy_minors; i++) {\r\nint minor;\r\nminor = comedi_alloc_board_minor(NULL);\r\nif (minor < 0) {\r\ncomedi_cleanup_legacy_minors();\r\ncdev_del(&comedi_cdev);\r\nunregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0),\r\nCOMEDI_NUM_MINORS);\r\nreturn minor;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit comedi_cleanup(void)\r\n{\r\nint i;\r\ncomedi_cleanup_legacy_minors();\r\nfor (i = 0; i < COMEDI_NUM_MINORS; ++i)\r\nBUG_ON(comedi_file_info_table[i]);\r\nclass_destroy(comedi_class);\r\ncdev_del(&comedi_cdev);\r\nunregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS);\r\ncomedi_proc_cleanup();\r\n}\r\nvoid comedi_error(const struct comedi_device *dev, const char *s)\r\n{\r\nprintk(KERN_ERR "comedi%d: %s: %s\n", dev->minor,\r\ndev->driver->driver_name, s);\r\n}\r\nvoid comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nunsigned runflags = 0;\r\nunsigned runflags_mask = 0;\r\nif ((comedi_get_subdevice_runflags(s) & SRF_RUNNING) == 0)\r\nreturn;\r\nif (s->\r\nasync->events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |\r\nCOMEDI_CB_OVERFLOW)) {\r\nrunflags_mask |= SRF_RUNNING;\r\n}\r\nif (s->async->events & (COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW)) {\r\nrunflags_mask |= SRF_ERROR;\r\nrunflags |= SRF_ERROR;\r\n}\r\nif (runflags_mask) {\r\ncomedi_set_subdevice_runflags(s, runflags_mask, runflags);\r\n}\r\nif (async->cb_mask & s->async->events) {\r\nif (comedi_get_subdevice_runflags(s) & SRF_USER) {\r\nwake_up_interruptible(&async->wait_head);\r\nif (s->subdev_flags & SDF_CMD_READ)\r\nkill_fasync(&dev->async_queue, SIGIO, POLL_IN);\r\nif (s->subdev_flags & SDF_CMD_WRITE)\r\nkill_fasync(&dev->async_queue, SIGIO, POLL_OUT);\r\n} else {\r\nif (async->cb_func)\r\nasync->cb_func(s->async->events, async->cb_arg);\r\n}\r\n}\r\ns->async->events = 0;\r\n}\r\nunsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)\r\n{\r\nunsigned long flags;\r\nunsigned runflags;\r\nspin_lock_irqsave(&s->spin_lock, flags);\r\nrunflags = s->runflags;\r\nspin_unlock_irqrestore(&s->spin_lock, flags);\r\nreturn runflags;\r\n}\r\nstatic int is_device_busy(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s;\r\nint i;\r\nif (!dev->attached)\r\nreturn 0;\r\nfor (i = 0; i < dev->n_subdevices; i++) {\r\ns = dev->subdevices + i;\r\nif (s->busy)\r\nreturn 1;\r\nif (s->async && s->async->mmap_count)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void comedi_device_init(struct comedi_device *dev)\r\n{\r\nmemset(dev, 0, sizeof(struct comedi_device));\r\nspin_lock_init(&dev->spinlock);\r\nmutex_init(&dev->mutex);\r\ndev->minor = -1;\r\n}\r\nstatic void comedi_device_cleanup(struct comedi_device *dev)\r\n{\r\nif (dev == NULL)\r\nreturn;\r\nmutex_lock(&dev->mutex);\r\ncomedi_device_detach(dev);\r\nmutex_unlock(&dev->mutex);\r\nmutex_destroy(&dev->mutex);\r\n}\r\nint comedi_alloc_board_minor(struct device *hardware_device)\r\n{\r\nunsigned long flags;\r\nstruct comedi_device_file_info *info;\r\nstruct device *csdev;\r\nunsigned i;\r\nint retval;\r\ninfo = kzalloc(sizeof(struct comedi_device_file_info), GFP_KERNEL);\r\nif (info == NULL)\r\nreturn -ENOMEM;\r\ninfo->device = kzalloc(sizeof(struct comedi_device), GFP_KERNEL);\r\nif (info->device == NULL) {\r\nkfree(info);\r\nreturn -ENOMEM;\r\n}\r\ncomedi_device_init(info->device);\r\nspin_lock_irqsave(&comedi_file_info_table_lock, flags);\r\nfor (i = 0; i < COMEDI_NUM_BOARD_MINORS; ++i) {\r\nif (comedi_file_info_table[i] == NULL) {\r\ncomedi_file_info_table[i] = info;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&comedi_file_info_table_lock, flags);\r\nif (i == COMEDI_NUM_BOARD_MINORS) {\r\ncomedi_device_cleanup(info->device);\r\nkfree(info->device);\r\nkfree(info);\r\nprintk(KERN_ERR\r\n"comedi: error: "\r\n"ran out of minor numbers for board device files.\n");\r\nreturn -EBUSY;\r\n}\r\ninfo->device->minor = i;\r\ncsdev = device_create(comedi_class, hardware_device,\r\nMKDEV(COMEDI_MAJOR, i), NULL, "comedi%i", i);\r\nif (!IS_ERR(csdev))\r\ninfo->device->class_dev = csdev;\r\ndev_set_drvdata(csdev, info);\r\nretval = device_create_file(csdev, &dev_attr_max_read_buffer_kb);\r\nif (retval) {\r\nprintk(KERN_ERR\r\n"comedi: "\r\n"failed to create sysfs attribute file \"%s\".\n",\r\ndev_attr_max_read_buffer_kb.attr.name);\r\ncomedi_free_board_minor(i);\r\nreturn retval;\r\n}\r\nretval = device_create_file(csdev, &dev_attr_read_buffer_kb);\r\nif (retval) {\r\nprintk(KERN_ERR\r\n"comedi: "\r\n"failed to create sysfs attribute file \"%s\".\n",\r\ndev_attr_read_buffer_kb.attr.name);\r\ncomedi_free_board_minor(i);\r\nreturn retval;\r\n}\r\nretval = device_create_file(csdev, &dev_attr_max_write_buffer_kb);\r\nif (retval) {\r\nprintk(KERN_ERR\r\n"comedi: "\r\n"failed to create sysfs attribute file \"%s\".\n",\r\ndev_attr_max_write_buffer_kb.attr.name);\r\ncomedi_free_board_minor(i);\r\nreturn retval;\r\n}\r\nretval = device_create_file(csdev, &dev_attr_write_buffer_kb);\r\nif (retval) {\r\nprintk(KERN_ERR\r\n"comedi: "\r\n"failed to create sysfs attribute file \"%s\".\n",\r\ndev_attr_write_buffer_kb.attr.name);\r\ncomedi_free_board_minor(i);\r\nreturn retval;\r\n}\r\nreturn i;\r\n}\r\nvoid comedi_free_board_minor(unsigned minor)\r\n{\r\nunsigned long flags;\r\nstruct comedi_device_file_info *info;\r\nBUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);\r\nspin_lock_irqsave(&comedi_file_info_table_lock, flags);\r\ninfo = comedi_file_info_table[minor];\r\ncomedi_file_info_table[minor] = NULL;\r\nspin_unlock_irqrestore(&comedi_file_info_table_lock, flags);\r\nif (info) {\r\nstruct comedi_device *dev = info->device;\r\nif (dev) {\r\nif (dev->class_dev) {\r\ndevice_destroy(comedi_class,\r\nMKDEV(COMEDI_MAJOR, dev->minor));\r\n}\r\ncomedi_device_cleanup(dev);\r\nkfree(dev);\r\n}\r\nkfree(info);\r\n}\r\n}\r\nint comedi_alloc_subdevice_minor(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned long flags;\r\nstruct comedi_device_file_info *info;\r\nstruct device *csdev;\r\nunsigned i;\r\nint retval;\r\ninfo = kmalloc(sizeof(struct comedi_device_file_info), GFP_KERNEL);\r\nif (info == NULL)\r\nreturn -ENOMEM;\r\ninfo->device = dev;\r\ninfo->read_subdevice = s;\r\ninfo->write_subdevice = s;\r\nspin_lock_irqsave(&comedi_file_info_table_lock, flags);\r\nfor (i = COMEDI_FIRST_SUBDEVICE_MINOR; i < COMEDI_NUM_MINORS; ++i) {\r\nif (comedi_file_info_table[i] == NULL) {\r\ncomedi_file_info_table[i] = info;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&comedi_file_info_table_lock, flags);\r\nif (i == COMEDI_NUM_MINORS) {\r\nkfree(info);\r\nprintk(KERN_ERR\r\n"comedi: error: "\r\n"ran out of minor numbers for board device files.\n");\r\nreturn -EBUSY;\r\n}\r\ns->minor = i;\r\ncsdev = device_create(comedi_class, dev->class_dev,\r\nMKDEV(COMEDI_MAJOR, i), NULL, "comedi%i_subd%i",\r\ndev->minor, (int)(s - dev->subdevices));\r\nif (!IS_ERR(csdev))\r\ns->class_dev = csdev;\r\ndev_set_drvdata(csdev, info);\r\nretval = device_create_file(csdev, &dev_attr_max_read_buffer_kb);\r\nif (retval) {\r\nprintk(KERN_ERR\r\n"comedi: "\r\n"failed to create sysfs attribute file \"%s\".\n",\r\ndev_attr_max_read_buffer_kb.attr.name);\r\ncomedi_free_subdevice_minor(s);\r\nreturn retval;\r\n}\r\nretval = device_create_file(csdev, &dev_attr_read_buffer_kb);\r\nif (retval) {\r\nprintk(KERN_ERR\r\n"comedi: "\r\n"failed to create sysfs attribute file \"%s\".\n",\r\ndev_attr_read_buffer_kb.attr.name);\r\ncomedi_free_subdevice_minor(s);\r\nreturn retval;\r\n}\r\nretval = device_create_file(csdev, &dev_attr_max_write_buffer_kb);\r\nif (retval) {\r\nprintk(KERN_ERR\r\n"comedi: "\r\n"failed to create sysfs attribute file \"%s\".\n",\r\ndev_attr_max_write_buffer_kb.attr.name);\r\ncomedi_free_subdevice_minor(s);\r\nreturn retval;\r\n}\r\nretval = device_create_file(csdev, &dev_attr_write_buffer_kb);\r\nif (retval) {\r\nprintk(KERN_ERR\r\n"comedi: "\r\n"failed to create sysfs attribute file \"%s\".\n",\r\ndev_attr_write_buffer_kb.attr.name);\r\ncomedi_free_subdevice_minor(s);\r\nreturn retval;\r\n}\r\nreturn i;\r\n}\r\nvoid comedi_free_subdevice_minor(struct comedi_subdevice *s)\r\n{\r\nunsigned long flags;\r\nstruct comedi_device_file_info *info;\r\nif (s == NULL)\r\nreturn;\r\nif (s->minor < 0)\r\nreturn;\r\nBUG_ON(s->minor >= COMEDI_NUM_MINORS);\r\nBUG_ON(s->minor < COMEDI_FIRST_SUBDEVICE_MINOR);\r\nspin_lock_irqsave(&comedi_file_info_table_lock, flags);\r\ninfo = comedi_file_info_table[s->minor];\r\ncomedi_file_info_table[s->minor] = NULL;\r\nspin_unlock_irqrestore(&comedi_file_info_table_lock, flags);\r\nif (s->class_dev) {\r\ndevice_destroy(comedi_class, MKDEV(COMEDI_MAJOR, s->minor));\r\ns->class_dev = NULL;\r\n}\r\nkfree(info);\r\n}\r\nstruct comedi_device_file_info *comedi_get_device_file_info(unsigned minor)\r\n{\r\nunsigned long flags;\r\nstruct comedi_device_file_info *info;\r\nBUG_ON(minor >= COMEDI_NUM_MINORS);\r\nspin_lock_irqsave(&comedi_file_info_table_lock, flags);\r\ninfo = comedi_file_info_table[minor];\r\nspin_unlock_irqrestore(&comedi_file_info_table_lock, flags);\r\nreturn info;\r\n}\r\nstatic int resize_async_buffer(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_async *async, unsigned new_size)\r\n{\r\nint retval;\r\nif (new_size > async->max_bufsize)\r\nreturn -EPERM;\r\nif (s->busy) {\r\nDPRINTK("subdevice is busy, cannot resize buffer\n");\r\nreturn -EBUSY;\r\n}\r\nif (async->mmap_count) {\r\nDPRINTK("subdevice is mmapped, cannot resize buffer\n");\r\nreturn -EBUSY;\r\n}\r\nif (!async->prealloc_buf)\r\nreturn -EINVAL;\r\nnew_size = (new_size + PAGE_SIZE - 1) & PAGE_MASK;\r\nretval = comedi_buf_alloc(dev, s, new_size);\r\nif (retval < 0)\r\nreturn retval;\r\nif (s->buf_change) {\r\nretval = s->buf_change(dev, s, new_size);\r\nif (retval < 0)\r\nreturn retval;\r\n}\r\nDPRINTK("comedi%i subd %d buffer resized to %i bytes\n",\r\ndev->minor, (int)(s - dev->subdevices), async->prealloc_bufsz);\r\nreturn 0;\r\n}\r\nstatic ssize_t show_max_read_buffer_kb(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nssize_t retval;\r\nstruct comedi_device_file_info *info = dev_get_drvdata(dev);\r\nunsigned max_buffer_size_kb = 0;\r\nstruct comedi_subdevice *const read_subdevice =\r\ncomedi_get_read_subdevice(info);\r\nmutex_lock(&info->device->mutex);\r\nif (read_subdevice &&\r\n(read_subdevice->subdev_flags & SDF_CMD_READ) &&\r\nread_subdevice->async) {\r\nmax_buffer_size_kb = read_subdevice->async->max_bufsize /\r\nbytes_per_kibi;\r\n}\r\nretval = snprintf(buf, PAGE_SIZE, "%i\n", max_buffer_size_kb);\r\nmutex_unlock(&info->device->mutex);\r\nreturn retval;\r\n}\r\nstatic ssize_t store_max_read_buffer_kb(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct comedi_device_file_info *info = dev_get_drvdata(dev);\r\nunsigned int new_max_size_kb;\r\nunsigned int new_max_size;\r\nint ret;\r\nstruct comedi_subdevice *const read_subdevice =\r\ncomedi_get_read_subdevice(info);\r\nret = kstrtouint(buf, 10, &new_max_size_kb);\r\nif (ret)\r\nreturn ret;\r\nif (new_max_size_kb > (UINT_MAX / bytes_per_kibi))\r\nreturn -EINVAL;\r\nnew_max_size = new_max_size_kb * bytes_per_kibi;\r\nmutex_lock(&info->device->mutex);\r\nif (read_subdevice == NULL ||\r\n(read_subdevice->subdev_flags & SDF_CMD_READ) == 0 ||\r\nread_subdevice->async == NULL) {\r\nmutex_unlock(&info->device->mutex);\r\nreturn -EINVAL;\r\n}\r\nread_subdevice->async->max_bufsize = new_max_size;\r\nmutex_unlock(&info->device->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t show_read_buffer_kb(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nssize_t retval;\r\nstruct comedi_device_file_info *info = dev_get_drvdata(dev);\r\nunsigned buffer_size_kb = 0;\r\nstruct comedi_subdevice *const read_subdevice =\r\ncomedi_get_read_subdevice(info);\r\nmutex_lock(&info->device->mutex);\r\nif (read_subdevice &&\r\n(read_subdevice->subdev_flags & SDF_CMD_READ) &&\r\nread_subdevice->async) {\r\nbuffer_size_kb = read_subdevice->async->prealloc_bufsz /\r\nbytes_per_kibi;\r\n}\r\nretval = snprintf(buf, PAGE_SIZE, "%i\n", buffer_size_kb);\r\nmutex_unlock(&info->device->mutex);\r\nreturn retval;\r\n}\r\nstatic ssize_t store_read_buffer_kb(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct comedi_device_file_info *info = dev_get_drvdata(dev);\r\nunsigned int new_size_kb;\r\nunsigned int new_size;\r\nint retval;\r\nint ret;\r\nstruct comedi_subdevice *const read_subdevice =\r\ncomedi_get_read_subdevice(info);\r\nret = kstrtouint(buf, 10, &new_size_kb);\r\nif (ret)\r\nreturn ret;\r\nif (new_size_kb > (UINT_MAX / bytes_per_kibi))\r\nreturn -EINVAL;\r\nnew_size = new_size_kb * bytes_per_kibi;\r\nmutex_lock(&info->device->mutex);\r\nif (read_subdevice == NULL ||\r\n(read_subdevice->subdev_flags & SDF_CMD_READ) == 0 ||\r\nread_subdevice->async == NULL) {\r\nmutex_unlock(&info->device->mutex);\r\nreturn -EINVAL;\r\n}\r\nretval = resize_async_buffer(info->device, read_subdevice,\r\nread_subdevice->async, new_size);\r\nmutex_unlock(&info->device->mutex);\r\nif (retval < 0)\r\nreturn retval;\r\nreturn count;\r\n}\r\nstatic ssize_t show_max_write_buffer_kb(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nssize_t retval;\r\nstruct comedi_device_file_info *info = dev_get_drvdata(dev);\r\nunsigned max_buffer_size_kb = 0;\r\nstruct comedi_subdevice *const write_subdevice =\r\ncomedi_get_write_subdevice(info);\r\nmutex_lock(&info->device->mutex);\r\nif (write_subdevice &&\r\n(write_subdevice->subdev_flags & SDF_CMD_WRITE) &&\r\nwrite_subdevice->async) {\r\nmax_buffer_size_kb = write_subdevice->async->max_bufsize /\r\nbytes_per_kibi;\r\n}\r\nretval = snprintf(buf, PAGE_SIZE, "%i\n", max_buffer_size_kb);\r\nmutex_unlock(&info->device->mutex);\r\nreturn retval;\r\n}\r\nstatic ssize_t store_max_write_buffer_kb(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct comedi_device_file_info *info = dev_get_drvdata(dev);\r\nunsigned int new_max_size_kb;\r\nunsigned int new_max_size;\r\nint ret;\r\nstruct comedi_subdevice *const write_subdevice =\r\ncomedi_get_write_subdevice(info);\r\nret = kstrtouint(buf, 10, &new_max_size_kb);\r\nif (ret)\r\nreturn ret;\r\nif (new_max_size_kb > (UINT_MAX / bytes_per_kibi))\r\nreturn -EINVAL;\r\nnew_max_size = new_max_size_kb * bytes_per_kibi;\r\nmutex_lock(&info->device->mutex);\r\nif (write_subdevice == NULL ||\r\n(write_subdevice->subdev_flags & SDF_CMD_WRITE) == 0 ||\r\nwrite_subdevice->async == NULL) {\r\nmutex_unlock(&info->device->mutex);\r\nreturn -EINVAL;\r\n}\r\nwrite_subdevice->async->max_bufsize = new_max_size;\r\nmutex_unlock(&info->device->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t show_write_buffer_kb(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nssize_t retval;\r\nstruct comedi_device_file_info *info = dev_get_drvdata(dev);\r\nunsigned buffer_size_kb = 0;\r\nstruct comedi_subdevice *const write_subdevice =\r\ncomedi_get_write_subdevice(info);\r\nmutex_lock(&info->device->mutex);\r\nif (write_subdevice &&\r\n(write_subdevice->subdev_flags & SDF_CMD_WRITE) &&\r\nwrite_subdevice->async) {\r\nbuffer_size_kb = write_subdevice->async->prealloc_bufsz /\r\nbytes_per_kibi;\r\n}\r\nretval = snprintf(buf, PAGE_SIZE, "%i\n", buffer_size_kb);\r\nmutex_unlock(&info->device->mutex);\r\nreturn retval;\r\n}\r\nstatic ssize_t store_write_buffer_kb(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct comedi_device_file_info *info = dev_get_drvdata(dev);\r\nunsigned int new_size_kb;\r\nunsigned int new_size;\r\nint retval;\r\nint ret;\r\nstruct comedi_subdevice *const write_subdevice =\r\ncomedi_get_write_subdevice(info);\r\nret = kstrtouint(buf, 10, &new_size_kb);\r\nif (ret)\r\nreturn ret;\r\nif (new_size_kb > (UINT_MAX / bytes_per_kibi))\r\nreturn -EINVAL;\r\nnew_size = ((uint64_t) new_size_kb) * bytes_per_kibi;\r\nmutex_lock(&info->device->mutex);\r\nif (write_subdevice == NULL ||\r\n(write_subdevice->subdev_flags & SDF_CMD_WRITE) == 0 ||\r\nwrite_subdevice->async == NULL) {\r\nmutex_unlock(&info->device->mutex);\r\nreturn -EINVAL;\r\n}\r\nretval = resize_async_buffer(info->device, write_subdevice,\r\nwrite_subdevice->async, new_size);\r\nmutex_unlock(&info->device->mutex);\r\nif (retval < 0)\r\nreturn retval;\r\nreturn count;\r\n}
