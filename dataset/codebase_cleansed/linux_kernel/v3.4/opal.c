int __init early_init_dt_scan_opal(unsigned long node,\r\nconst char *uname, int depth, void *data)\r\n{\r\nconst void *basep, *entryp;\r\nunsigned long basesz, entrysz;\r\nu64 glue;\r\nif (depth != 1 || strcmp(uname, "ibm,opal") != 0)\r\nreturn 0;\r\nbasep = of_get_flat_dt_prop(node, "opal-base-address", &basesz);\r\nentryp = of_get_flat_dt_prop(node, "opal-entry-address", &entrysz);\r\nif (!basep || !entryp)\r\nreturn 1;\r\nopal.base = of_read_number(basep, basesz/4);\r\nopal.entry = of_read_number(entryp, entrysz/4);\r\npr_debug("OPAL Base = 0x%llx (basep=%p basesz=%ld)\n",\r\nopal.base, basep, basesz);\r\npr_debug("OPAL Entry = 0x%llx (entryp=%p basesz=%ld)\n",\r\nopal.entry, entryp, entrysz);\r\npowerpc_firmware_features |= FW_FEATURE_OPAL;\r\nif (of_flat_dt_is_compatible(node, "ibm,opal-v2")) {\r\npowerpc_firmware_features |= FW_FEATURE_OPALv2;\r\nprintk("OPAL V2 detected !\n");\r\n} else {\r\nprintk("OPAL V1 detected !\n");\r\n}\r\nglue = 0x7000;\r\nopal_register_exception_handler(OPAL_MACHINE_CHECK_HANDLER,\r\n__pa(opal_mc_secondary_handler[0]),\r\nglue);\r\nglue += 128;\r\nopal_register_exception_handler(OPAL_HYPERVISOR_MAINTENANCE_HANDLER,\r\n0, glue);\r\nglue += 128;\r\nopal_register_exception_handler(OPAL_SOFTPATCH_HANDLER, 0, glue);\r\nreturn 1;\r\n}\r\nint opal_get_chars(uint32_t vtermno, char *buf, int count)\r\n{\r\ns64 len, rc;\r\nu64 evt;\r\nif (!opal.entry)\r\nreturn -ENODEV;\r\nopal_poll_events(&evt);\r\nif ((evt & OPAL_EVENT_CONSOLE_INPUT) == 0)\r\nreturn 0;\r\nlen = count;\r\nrc = opal_console_read(vtermno, &len, buf);\r\nif (rc == OPAL_SUCCESS)\r\nreturn len;\r\nreturn 0;\r\n}\r\nint opal_put_chars(uint32_t vtermno, const char *data, int total_len)\r\n{\r\nint written = 0;\r\ns64 len, rc;\r\nunsigned long flags;\r\nu64 evt;\r\nif (!opal.entry)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&opal_write_lock, flags);\r\nif (firmware_has_feature(FW_FEATURE_OPALv2)) {\r\nrc = opal_console_write_buffer_space(vtermno, &len);\r\nif (rc || len < total_len) {\r\nspin_unlock_irqrestore(&opal_write_lock, flags);\r\nif (rc)\r\nreturn total_len;\r\nopal_poll_events(&evt);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nrc = OPAL_BUSY;\r\nwhile(total_len > 0 && (rc == OPAL_BUSY ||\r\nrc == OPAL_BUSY_EVENT || rc == OPAL_SUCCESS)) {\r\nlen = total_len;\r\nrc = opal_console_write(vtermno, &len, data);\r\nif (rc == OPAL_SUCCESS) {\r\ntotal_len -= len;\r\ndata += len;\r\nwritten += len;\r\n}\r\ndo\r\nopal_poll_events(&evt);\r\nwhile(rc == OPAL_SUCCESS && (evt & OPAL_EVENT_CONSOLE_OUTPUT));\r\n}\r\nspin_unlock_irqrestore(&opal_write_lock, flags);\r\nreturn written;\r\n}\r\nint opal_machine_check(struct pt_regs *regs)\r\n{\r\nstruct opal_machine_check_event *opal_evt = get_paca()->opal_mc_evt;\r\nstruct opal_machine_check_event evt;\r\nconst char *level, *sevstr, *subtype;\r\nstatic const char *opal_mc_ue_types[] = {\r\n"Indeterminate",\r\n"Instruction fetch",\r\n"Page table walk ifetch",\r\n"Load/Store",\r\n"Page table walk Load/Store",\r\n};\r\nstatic const char *opal_mc_slb_types[] = {\r\n"Indeterminate",\r\n"Parity",\r\n"Multihit",\r\n};\r\nstatic const char *opal_mc_erat_types[] = {\r\n"Indeterminate",\r\n"Parity",\r\n"Multihit",\r\n};\r\nstatic const char *opal_mc_tlb_types[] = {\r\n"Indeterminate",\r\n"Parity",\r\n"Multihit",\r\n};\r\nevt = *opal_evt;\r\nopal_evt->in_use = 0;\r\nif (evt.version != OpalMCE_V1) {\r\npr_err("Machine Check Exception, Unknown event version %d !\n",\r\nevt.version);\r\nreturn 0;\r\n}\r\nswitch(evt.severity) {\r\ncase OpalMCE_SEV_NO_ERROR:\r\nlevel = KERN_INFO;\r\nsevstr = "Harmless";\r\nbreak;\r\ncase OpalMCE_SEV_WARNING:\r\nlevel = KERN_WARNING;\r\nsevstr = "";\r\nbreak;\r\ncase OpalMCE_SEV_ERROR_SYNC:\r\nlevel = KERN_ERR;\r\nsevstr = "Severe";\r\nbreak;\r\ncase OpalMCE_SEV_FATAL:\r\ndefault:\r\nlevel = KERN_ERR;\r\nsevstr = "Fatal";\r\nbreak;\r\n}\r\nprintk("%s%s Machine check interrupt [%s]\n", level, sevstr,\r\nevt.disposition == OpalMCE_DISPOSITION_RECOVERED ?\r\n"Recovered" : "[Not recovered");\r\nprintk("%s Initiator: %s\n", level,\r\nevt.initiator == OpalMCE_INITIATOR_CPU ? "CPU" : "Unknown");\r\nswitch(evt.error_type) {\r\ncase OpalMCE_ERROR_TYPE_UE:\r\nsubtype = evt.u.ue_error.ue_error_type <\r\nARRAY_SIZE(opal_mc_ue_types) ?\r\nopal_mc_ue_types[evt.u.ue_error.ue_error_type]\r\n: "Unknown";\r\nprintk("%s Error type: UE [%s]\n", level, subtype);\r\nif (evt.u.ue_error.effective_address_provided)\r\nprintk("%s Effective address: %016llx\n",\r\nlevel, evt.u.ue_error.effective_address);\r\nif (evt.u.ue_error.physical_address_provided)\r\nprintk("%s Physial address: %016llx\n",\r\nlevel, evt.u.ue_error.physical_address);\r\nbreak;\r\ncase OpalMCE_ERROR_TYPE_SLB:\r\nsubtype = evt.u.slb_error.slb_error_type <\r\nARRAY_SIZE(opal_mc_slb_types) ?\r\nopal_mc_slb_types[evt.u.slb_error.slb_error_type]\r\n: "Unknown";\r\nprintk("%s Error type: SLB [%s]\n", level, subtype);\r\nif (evt.u.slb_error.effective_address_provided)\r\nprintk("%s Effective address: %016llx\n",\r\nlevel, evt.u.slb_error.effective_address);\r\nbreak;\r\ncase OpalMCE_ERROR_TYPE_ERAT:\r\nsubtype = evt.u.erat_error.erat_error_type <\r\nARRAY_SIZE(opal_mc_erat_types) ?\r\nopal_mc_erat_types[evt.u.erat_error.erat_error_type]\r\n: "Unknown";\r\nprintk("%s Error type: ERAT [%s]\n", level, subtype);\r\nif (evt.u.erat_error.effective_address_provided)\r\nprintk("%s Effective address: %016llx\n",\r\nlevel, evt.u.erat_error.effective_address);\r\nbreak;\r\ncase OpalMCE_ERROR_TYPE_TLB:\r\nsubtype = evt.u.tlb_error.tlb_error_type <\r\nARRAY_SIZE(opal_mc_tlb_types) ?\r\nopal_mc_tlb_types[evt.u.tlb_error.tlb_error_type]\r\n: "Unknown";\r\nprintk("%s Error type: TLB [%s]\n", level, subtype);\r\nif (evt.u.tlb_error.effective_address_provided)\r\nprintk("%s Effective address: %016llx\n",\r\nlevel, evt.u.tlb_error.effective_address);\r\nbreak;\r\ndefault:\r\ncase OpalMCE_ERROR_TYPE_UNKNOWN:\r\nprintk("%s Error type: Unknown\n", level);\r\nbreak;\r\n}\r\nreturn evt.severity == OpalMCE_SEV_FATAL ? 0 : 1;\r\n}\r\nstatic irqreturn_t opal_interrupt(int irq, void *data)\r\n{\r\nuint64_t events;\r\nopal_handle_interrupt(virq_to_hw(irq), &events);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init opal_init(void)\r\n{\r\nstruct device_node *np, *consoles;\r\nconst u32 *irqs;\r\nint rc, i, irqlen;\r\nopal_node = of_find_node_by_path("/ibm,opal");\r\nif (!opal_node) {\r\npr_warn("opal: Node not found\n");\r\nreturn -ENODEV;\r\n}\r\nif (firmware_has_feature(FW_FEATURE_OPALv2))\r\nconsoles = of_find_node_by_path("/ibm,opal/consoles");\r\nelse\r\nconsoles = of_node_get(opal_node);\r\nfor_each_child_of_node(consoles, np) {\r\nif (strcmp(np->name, "serial"))\r\ncontinue;\r\nof_platform_device_create(np, NULL, NULL);\r\n}\r\nof_node_put(consoles);\r\nirqs = of_get_property(opal_node, "opal-interrupts", &irqlen);\r\npr_debug("opal: Found %d interrupts reserved for OPAL\n",\r\nirqs ? (irqlen / 4) : 0);\r\nfor (i = 0; irqs && i < (irqlen / 4); i++, irqs++) {\r\nunsigned int hwirq = be32_to_cpup(irqs);\r\nunsigned int irq = irq_create_mapping(NULL, hwirq);\r\nif (irq == NO_IRQ) {\r\npr_warning("opal: Failed to map irq 0x%x\n", hwirq);\r\ncontinue;\r\n}\r\nrc = request_irq(irq, opal_interrupt, 0, "opal", NULL);\r\nif (rc)\r\npr_warning("opal: Error %d requesting irq %d"\r\n" (0x%x)\n", rc, irq, hwirq);\r\n}\r\nreturn 0;\r\n}
