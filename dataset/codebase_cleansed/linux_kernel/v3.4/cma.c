static int cma_comp(struct rdma_id_private *id_priv, enum rdma_cm_state comp)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&id_priv->lock, flags);\r\nret = (id_priv->state == comp);\r\nspin_unlock_irqrestore(&id_priv->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int cma_comp_exch(struct rdma_id_private *id_priv,\r\nenum rdma_cm_state comp, enum rdma_cm_state exch)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&id_priv->lock, flags);\r\nif ((ret = (id_priv->state == comp)))\r\nid_priv->state = exch;\r\nspin_unlock_irqrestore(&id_priv->lock, flags);\r\nreturn ret;\r\n}\r\nstatic enum rdma_cm_state cma_exch(struct rdma_id_private *id_priv,\r\nenum rdma_cm_state exch)\r\n{\r\nunsigned long flags;\r\nenum rdma_cm_state old;\r\nspin_lock_irqsave(&id_priv->lock, flags);\r\nold = id_priv->state;\r\nid_priv->state = exch;\r\nspin_unlock_irqrestore(&id_priv->lock, flags);\r\nreturn old;\r\n}\r\nstatic inline u8 cma_get_ip_ver(struct cma_hdr *hdr)\r\n{\r\nreturn hdr->ip_version >> 4;\r\n}\r\nstatic inline void cma_set_ip_ver(struct cma_hdr *hdr, u8 ip_ver)\r\n{\r\nhdr->ip_version = (ip_ver << 4) | (hdr->ip_version & 0xF);\r\n}\r\nstatic inline u8 sdp_get_majv(u8 sdp_version)\r\n{\r\nreturn sdp_version >> 4;\r\n}\r\nstatic inline u8 sdp_get_ip_ver(struct sdp_hh *hh)\r\n{\r\nreturn hh->ip_version >> 4;\r\n}\r\nstatic inline void sdp_set_ip_ver(struct sdp_hh *hh, u8 ip_ver)\r\n{\r\nhh->ip_version = (ip_ver << 4) | (hh->ip_version & 0xF);\r\n}\r\nstatic void cma_attach_to_dev(struct rdma_id_private *id_priv,\r\nstruct cma_device *cma_dev)\r\n{\r\natomic_inc(&cma_dev->refcount);\r\nid_priv->cma_dev = cma_dev;\r\nid_priv->id.device = cma_dev->device;\r\nid_priv->id.route.addr.dev_addr.transport =\r\nrdma_node_get_transport(cma_dev->device->node_type);\r\nlist_add_tail(&id_priv->list, &cma_dev->id_list);\r\n}\r\nstatic inline void cma_deref_dev(struct cma_device *cma_dev)\r\n{\r\nif (atomic_dec_and_test(&cma_dev->refcount))\r\ncomplete(&cma_dev->comp);\r\n}\r\nstatic inline void release_mc(struct kref *kref)\r\n{\r\nstruct cma_multicast *mc = container_of(kref, struct cma_multicast, mcref);\r\nkfree(mc->multicast.ib);\r\nkfree(mc);\r\n}\r\nstatic void cma_release_dev(struct rdma_id_private *id_priv)\r\n{\r\nmutex_lock(&lock);\r\nlist_del(&id_priv->list);\r\ncma_deref_dev(id_priv->cma_dev);\r\nid_priv->cma_dev = NULL;\r\nmutex_unlock(&lock);\r\n}\r\nstatic int cma_set_qkey(struct rdma_id_private *id_priv)\r\n{\r\nstruct ib_sa_mcmember_rec rec;\r\nint ret = 0;\r\nif (id_priv->qkey)\r\nreturn 0;\r\nswitch (id_priv->id.ps) {\r\ncase RDMA_PS_UDP:\r\nid_priv->qkey = RDMA_UDP_QKEY;\r\nbreak;\r\ncase RDMA_PS_IPOIB:\r\nib_addr_get_mgid(&id_priv->id.route.addr.dev_addr, &rec.mgid);\r\nret = ib_sa_get_mcmember_rec(id_priv->id.device,\r\nid_priv->id.port_num, &rec.mgid,\r\n&rec);\r\nif (!ret)\r\nid_priv->qkey = be32_to_cpu(rec.qkey);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int find_gid_port(struct ib_device *device, union ib_gid *gid, u8 port_num)\r\n{\r\nint i;\r\nint err;\r\nstruct ib_port_attr props;\r\nunion ib_gid tmp;\r\nerr = ib_query_port(device, port_num, &props);\r\nif (err)\r\nreturn 1;\r\nfor (i = 0; i < props.gid_tbl_len; ++i) {\r\nerr = ib_query_gid(device, port_num, i, &tmp);\r\nif (err)\r\nreturn 1;\r\nif (!memcmp(&tmp, gid, sizeof tmp))\r\nreturn 0;\r\n}\r\nreturn -EAGAIN;\r\n}\r\nstatic int cma_acquire_dev(struct rdma_id_private *id_priv)\r\n{\r\nstruct rdma_dev_addr *dev_addr = &id_priv->id.route.addr.dev_addr;\r\nstruct cma_device *cma_dev;\r\nunion ib_gid gid, iboe_gid;\r\nint ret = -ENODEV;\r\nu8 port;\r\nenum rdma_link_layer dev_ll = dev_addr->dev_type == ARPHRD_INFINIBAND ?\r\nIB_LINK_LAYER_INFINIBAND : IB_LINK_LAYER_ETHERNET;\r\nif (dev_ll != IB_LINK_LAYER_INFINIBAND &&\r\nid_priv->id.ps == RDMA_PS_IPOIB)\r\nreturn -EINVAL;\r\nmutex_lock(&lock);\r\niboe_addr_get_sgid(dev_addr, &iboe_gid);\r\nmemcpy(&gid, dev_addr->src_dev_addr +\r\nrdma_addr_gid_offset(dev_addr), sizeof gid);\r\nlist_for_each_entry(cma_dev, &dev_list, list) {\r\nfor (port = 1; port <= cma_dev->device->phys_port_cnt; ++port) {\r\nif (rdma_port_get_link_layer(cma_dev->device, port) == dev_ll) {\r\nif (rdma_node_get_transport(cma_dev->device->node_type) == RDMA_TRANSPORT_IB &&\r\nrdma_port_get_link_layer(cma_dev->device, port) == IB_LINK_LAYER_ETHERNET)\r\nret = find_gid_port(cma_dev->device, &iboe_gid, port);\r\nelse\r\nret = find_gid_port(cma_dev->device, &gid, port);\r\nif (!ret) {\r\nid_priv->id.port_num = port;\r\ngoto out;\r\n} else if (ret == 1)\r\nbreak;\r\n}\r\n}\r\n}\r\nout:\r\nif (!ret)\r\ncma_attach_to_dev(id_priv, cma_dev);\r\nmutex_unlock(&lock);\r\nreturn ret;\r\n}\r\nstatic void cma_deref_id(struct rdma_id_private *id_priv)\r\n{\r\nif (atomic_dec_and_test(&id_priv->refcount))\r\ncomplete(&id_priv->comp);\r\n}\r\nstatic int cma_disable_callback(struct rdma_id_private *id_priv,\r\nenum rdma_cm_state state)\r\n{\r\nmutex_lock(&id_priv->handler_mutex);\r\nif (id_priv->state != state) {\r\nmutex_unlock(&id_priv->handler_mutex);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstruct rdma_cm_id *rdma_create_id(rdma_cm_event_handler event_handler,\r\nvoid *context, enum rdma_port_space ps,\r\nenum ib_qp_type qp_type)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nid_priv = kzalloc(sizeof *id_priv, GFP_KERNEL);\r\nif (!id_priv)\r\nreturn ERR_PTR(-ENOMEM);\r\nid_priv->owner = task_pid_nr(current);\r\nid_priv->state = RDMA_CM_IDLE;\r\nid_priv->id.context = context;\r\nid_priv->id.event_handler = event_handler;\r\nid_priv->id.ps = ps;\r\nid_priv->id.qp_type = qp_type;\r\nspin_lock_init(&id_priv->lock);\r\nmutex_init(&id_priv->qp_mutex);\r\ninit_completion(&id_priv->comp);\r\natomic_set(&id_priv->refcount, 1);\r\nmutex_init(&id_priv->handler_mutex);\r\nINIT_LIST_HEAD(&id_priv->listen_list);\r\nINIT_LIST_HEAD(&id_priv->mc_list);\r\nget_random_bytes(&id_priv->seq_num, sizeof id_priv->seq_num);\r\nreturn &id_priv->id;\r\n}\r\nstatic int cma_init_ud_qp(struct rdma_id_private *id_priv, struct ib_qp *qp)\r\n{\r\nstruct ib_qp_attr qp_attr;\r\nint qp_attr_mask, ret;\r\nqp_attr.qp_state = IB_QPS_INIT;\r\nret = rdma_init_qp_attr(&id_priv->id, &qp_attr, &qp_attr_mask);\r\nif (ret)\r\nreturn ret;\r\nret = ib_modify_qp(qp, &qp_attr, qp_attr_mask);\r\nif (ret)\r\nreturn ret;\r\nqp_attr.qp_state = IB_QPS_RTR;\r\nret = ib_modify_qp(qp, &qp_attr, IB_QP_STATE);\r\nif (ret)\r\nreturn ret;\r\nqp_attr.qp_state = IB_QPS_RTS;\r\nqp_attr.sq_psn = 0;\r\nret = ib_modify_qp(qp, &qp_attr, IB_QP_STATE | IB_QP_SQ_PSN);\r\nreturn ret;\r\n}\r\nstatic int cma_init_conn_qp(struct rdma_id_private *id_priv, struct ib_qp *qp)\r\n{\r\nstruct ib_qp_attr qp_attr;\r\nint qp_attr_mask, ret;\r\nqp_attr.qp_state = IB_QPS_INIT;\r\nret = rdma_init_qp_attr(&id_priv->id, &qp_attr, &qp_attr_mask);\r\nif (ret)\r\nreturn ret;\r\nreturn ib_modify_qp(qp, &qp_attr, qp_attr_mask);\r\n}\r\nint rdma_create_qp(struct rdma_cm_id *id, struct ib_pd *pd,\r\nstruct ib_qp_init_attr *qp_init_attr)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nstruct ib_qp *qp;\r\nint ret;\r\nid_priv = container_of(id, struct rdma_id_private, id);\r\nif (id->device != pd->device)\r\nreturn -EINVAL;\r\nqp = ib_create_qp(pd, qp_init_attr);\r\nif (IS_ERR(qp))\r\nreturn PTR_ERR(qp);\r\nif (id->qp_type == IB_QPT_UD)\r\nret = cma_init_ud_qp(id_priv, qp);\r\nelse\r\nret = cma_init_conn_qp(id_priv, qp);\r\nif (ret)\r\ngoto err;\r\nid->qp = qp;\r\nid_priv->qp_num = qp->qp_num;\r\nid_priv->srq = (qp->srq != NULL);\r\nreturn 0;\r\nerr:\r\nib_destroy_qp(qp);\r\nreturn ret;\r\n}\r\nvoid rdma_destroy_qp(struct rdma_cm_id *id)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nid_priv = container_of(id, struct rdma_id_private, id);\r\nmutex_lock(&id_priv->qp_mutex);\r\nib_destroy_qp(id_priv->id.qp);\r\nid_priv->id.qp = NULL;\r\nmutex_unlock(&id_priv->qp_mutex);\r\n}\r\nstatic int cma_modify_qp_rtr(struct rdma_id_private *id_priv,\r\nstruct rdma_conn_param *conn_param)\r\n{\r\nstruct ib_qp_attr qp_attr;\r\nint qp_attr_mask, ret;\r\nmutex_lock(&id_priv->qp_mutex);\r\nif (!id_priv->id.qp) {\r\nret = 0;\r\ngoto out;\r\n}\r\nqp_attr.qp_state = IB_QPS_INIT;\r\nret = rdma_init_qp_attr(&id_priv->id, &qp_attr, &qp_attr_mask);\r\nif (ret)\r\ngoto out;\r\nret = ib_modify_qp(id_priv->id.qp, &qp_attr, qp_attr_mask);\r\nif (ret)\r\ngoto out;\r\nqp_attr.qp_state = IB_QPS_RTR;\r\nret = rdma_init_qp_attr(&id_priv->id, &qp_attr, &qp_attr_mask);\r\nif (ret)\r\ngoto out;\r\nif (conn_param)\r\nqp_attr.max_dest_rd_atomic = conn_param->responder_resources;\r\nret = ib_modify_qp(id_priv->id.qp, &qp_attr, qp_attr_mask);\r\nout:\r\nmutex_unlock(&id_priv->qp_mutex);\r\nreturn ret;\r\n}\r\nstatic int cma_modify_qp_rts(struct rdma_id_private *id_priv,\r\nstruct rdma_conn_param *conn_param)\r\n{\r\nstruct ib_qp_attr qp_attr;\r\nint qp_attr_mask, ret;\r\nmutex_lock(&id_priv->qp_mutex);\r\nif (!id_priv->id.qp) {\r\nret = 0;\r\ngoto out;\r\n}\r\nqp_attr.qp_state = IB_QPS_RTS;\r\nret = rdma_init_qp_attr(&id_priv->id, &qp_attr, &qp_attr_mask);\r\nif (ret)\r\ngoto out;\r\nif (conn_param)\r\nqp_attr.max_rd_atomic = conn_param->initiator_depth;\r\nret = ib_modify_qp(id_priv->id.qp, &qp_attr, qp_attr_mask);\r\nout:\r\nmutex_unlock(&id_priv->qp_mutex);\r\nreturn ret;\r\n}\r\nstatic int cma_modify_qp_err(struct rdma_id_private *id_priv)\r\n{\r\nstruct ib_qp_attr qp_attr;\r\nint ret;\r\nmutex_lock(&id_priv->qp_mutex);\r\nif (!id_priv->id.qp) {\r\nret = 0;\r\ngoto out;\r\n}\r\nqp_attr.qp_state = IB_QPS_ERR;\r\nret = ib_modify_qp(id_priv->id.qp, &qp_attr, IB_QP_STATE);\r\nout:\r\nmutex_unlock(&id_priv->qp_mutex);\r\nreturn ret;\r\n}\r\nstatic int cma_ib_init_qp_attr(struct rdma_id_private *id_priv,\r\nstruct ib_qp_attr *qp_attr, int *qp_attr_mask)\r\n{\r\nstruct rdma_dev_addr *dev_addr = &id_priv->id.route.addr.dev_addr;\r\nint ret;\r\nu16 pkey;\r\nif (rdma_port_get_link_layer(id_priv->id.device, id_priv->id.port_num) ==\r\nIB_LINK_LAYER_INFINIBAND)\r\npkey = ib_addr_get_pkey(dev_addr);\r\nelse\r\npkey = 0xffff;\r\nret = ib_find_cached_pkey(id_priv->id.device, id_priv->id.port_num,\r\npkey, &qp_attr->pkey_index);\r\nif (ret)\r\nreturn ret;\r\nqp_attr->port_num = id_priv->id.port_num;\r\n*qp_attr_mask = IB_QP_STATE | IB_QP_PKEY_INDEX | IB_QP_PORT;\r\nif (id_priv->id.qp_type == IB_QPT_UD) {\r\nret = cma_set_qkey(id_priv);\r\nif (ret)\r\nreturn ret;\r\nqp_attr->qkey = id_priv->qkey;\r\n*qp_attr_mask |= IB_QP_QKEY;\r\n} else {\r\nqp_attr->qp_access_flags = 0;\r\n*qp_attr_mask |= IB_QP_ACCESS_FLAGS;\r\n}\r\nreturn 0;\r\n}\r\nint rdma_init_qp_attr(struct rdma_cm_id *id, struct ib_qp_attr *qp_attr,\r\nint *qp_attr_mask)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nint ret = 0;\r\nid_priv = container_of(id, struct rdma_id_private, id);\r\nswitch (rdma_node_get_transport(id_priv->id.device->node_type)) {\r\ncase RDMA_TRANSPORT_IB:\r\nif (!id_priv->cm_id.ib || (id_priv->id.qp_type == IB_QPT_UD))\r\nret = cma_ib_init_qp_attr(id_priv, qp_attr, qp_attr_mask);\r\nelse\r\nret = ib_cm_init_qp_attr(id_priv->cm_id.ib, qp_attr,\r\nqp_attr_mask);\r\nif (qp_attr->qp_state == IB_QPS_RTR)\r\nqp_attr->rq_psn = id_priv->seq_num;\r\nbreak;\r\ncase RDMA_TRANSPORT_IWARP:\r\nif (!id_priv->cm_id.iw) {\r\nqp_attr->qp_access_flags = 0;\r\n*qp_attr_mask = IB_QP_STATE | IB_QP_ACCESS_FLAGS;\r\n} else\r\nret = iw_cm_init_qp_attr(id_priv->cm_id.iw, qp_attr,\r\nqp_attr_mask);\r\nbreak;\r\ndefault:\r\nret = -ENOSYS;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline int cma_zero_addr(struct sockaddr *addr)\r\n{\r\nstruct in6_addr *ip6;\r\nif (addr->sa_family == AF_INET)\r\nreturn ipv4_is_zeronet(\r\n((struct sockaddr_in *)addr)->sin_addr.s_addr);\r\nelse {\r\nip6 = &((struct sockaddr_in6 *) addr)->sin6_addr;\r\nreturn (ip6->s6_addr32[0] | ip6->s6_addr32[1] |\r\nip6->s6_addr32[2] | ip6->s6_addr32[3]) == 0;\r\n}\r\n}\r\nstatic inline int cma_loopback_addr(struct sockaddr *addr)\r\n{\r\nif (addr->sa_family == AF_INET)\r\nreturn ipv4_is_loopback(\r\n((struct sockaddr_in *) addr)->sin_addr.s_addr);\r\nelse\r\nreturn ipv6_addr_loopback(\r\n&((struct sockaddr_in6 *) addr)->sin6_addr);\r\n}\r\nstatic inline int cma_any_addr(struct sockaddr *addr)\r\n{\r\nreturn cma_zero_addr(addr) || cma_loopback_addr(addr);\r\n}\r\nstatic int cma_addr_cmp(struct sockaddr *src, struct sockaddr *dst)\r\n{\r\nif (src->sa_family != dst->sa_family)\r\nreturn -1;\r\nswitch (src->sa_family) {\r\ncase AF_INET:\r\nreturn ((struct sockaddr_in *) src)->sin_addr.s_addr !=\r\n((struct sockaddr_in *) dst)->sin_addr.s_addr;\r\ndefault:\r\nreturn ipv6_addr_cmp(&((struct sockaddr_in6 *) src)->sin6_addr,\r\n&((struct sockaddr_in6 *) dst)->sin6_addr);\r\n}\r\n}\r\nstatic inline __be16 cma_port(struct sockaddr *addr)\r\n{\r\nif (addr->sa_family == AF_INET)\r\nreturn ((struct sockaddr_in *) addr)->sin_port;\r\nelse\r\nreturn ((struct sockaddr_in6 *) addr)->sin6_port;\r\n}\r\nstatic inline int cma_any_port(struct sockaddr *addr)\r\n{\r\nreturn !cma_port(addr);\r\n}\r\nstatic int cma_get_net_info(void *hdr, enum rdma_port_space ps,\r\nu8 *ip_ver, __be16 *port,\r\nunion cma_ip_addr **src, union cma_ip_addr **dst)\r\n{\r\nswitch (ps) {\r\ncase RDMA_PS_SDP:\r\nif (sdp_get_majv(((struct sdp_hh *) hdr)->sdp_version) !=\r\nSDP_MAJ_VERSION)\r\nreturn -EINVAL;\r\n*ip_ver = sdp_get_ip_ver(hdr);\r\n*port = ((struct sdp_hh *) hdr)->port;\r\n*src = &((struct sdp_hh *) hdr)->src_addr;\r\n*dst = &((struct sdp_hh *) hdr)->dst_addr;\r\nbreak;\r\ndefault:\r\nif (((struct cma_hdr *) hdr)->cma_version != CMA_VERSION)\r\nreturn -EINVAL;\r\n*ip_ver = cma_get_ip_ver(hdr);\r\n*port = ((struct cma_hdr *) hdr)->port;\r\n*src = &((struct cma_hdr *) hdr)->src_addr;\r\n*dst = &((struct cma_hdr *) hdr)->dst_addr;\r\nbreak;\r\n}\r\nif (*ip_ver != 4 && *ip_ver != 6)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void cma_save_net_info(struct rdma_addr *addr,\r\nstruct rdma_addr *listen_addr,\r\nu8 ip_ver, __be16 port,\r\nunion cma_ip_addr *src, union cma_ip_addr *dst)\r\n{\r\nstruct sockaddr_in *listen4, *ip4;\r\nstruct sockaddr_in6 *listen6, *ip6;\r\nswitch (ip_ver) {\r\ncase 4:\r\nlisten4 = (struct sockaddr_in *) &listen_addr->src_addr;\r\nip4 = (struct sockaddr_in *) &addr->src_addr;\r\nip4->sin_family = listen4->sin_family;\r\nip4->sin_addr.s_addr = dst->ip4.addr;\r\nip4->sin_port = listen4->sin_port;\r\nip4 = (struct sockaddr_in *) &addr->dst_addr;\r\nip4->sin_family = listen4->sin_family;\r\nip4->sin_addr.s_addr = src->ip4.addr;\r\nip4->sin_port = port;\r\nbreak;\r\ncase 6:\r\nlisten6 = (struct sockaddr_in6 *) &listen_addr->src_addr;\r\nip6 = (struct sockaddr_in6 *) &addr->src_addr;\r\nip6->sin6_family = listen6->sin6_family;\r\nip6->sin6_addr = dst->ip6;\r\nip6->sin6_port = listen6->sin6_port;\r\nip6 = (struct sockaddr_in6 *) &addr->dst_addr;\r\nip6->sin6_family = listen6->sin6_family;\r\nip6->sin6_addr = src->ip6;\r\nip6->sin6_port = port;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic inline int cma_user_data_offset(enum rdma_port_space ps)\r\n{\r\nswitch (ps) {\r\ncase RDMA_PS_SDP:\r\nreturn 0;\r\ndefault:\r\nreturn sizeof(struct cma_hdr);\r\n}\r\n}\r\nstatic void cma_cancel_route(struct rdma_id_private *id_priv)\r\n{\r\nswitch (rdma_port_get_link_layer(id_priv->id.device, id_priv->id.port_num)) {\r\ncase IB_LINK_LAYER_INFINIBAND:\r\nif (id_priv->query)\r\nib_sa_cancel_query(id_priv->query_id, id_priv->query);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void cma_cancel_listens(struct rdma_id_private *id_priv)\r\n{\r\nstruct rdma_id_private *dev_id_priv;\r\nmutex_lock(&lock);\r\nlist_del(&id_priv->list);\r\nwhile (!list_empty(&id_priv->listen_list)) {\r\ndev_id_priv = list_entry(id_priv->listen_list.next,\r\nstruct rdma_id_private, listen_list);\r\nlist_del_init(&dev_id_priv->list);\r\nlist_del(&dev_id_priv->listen_list);\r\nmutex_unlock(&lock);\r\nrdma_destroy_id(&dev_id_priv->id);\r\nmutex_lock(&lock);\r\n}\r\nmutex_unlock(&lock);\r\n}\r\nstatic void cma_cancel_operation(struct rdma_id_private *id_priv,\r\nenum rdma_cm_state state)\r\n{\r\nswitch (state) {\r\ncase RDMA_CM_ADDR_QUERY:\r\nrdma_addr_cancel(&id_priv->id.route.addr.dev_addr);\r\nbreak;\r\ncase RDMA_CM_ROUTE_QUERY:\r\ncma_cancel_route(id_priv);\r\nbreak;\r\ncase RDMA_CM_LISTEN:\r\nif (cma_any_addr((struct sockaddr *) &id_priv->id.route.addr.src_addr)\r\n&& !id_priv->cma_dev)\r\ncma_cancel_listens(id_priv);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void cma_release_port(struct rdma_id_private *id_priv)\r\n{\r\nstruct rdma_bind_list *bind_list = id_priv->bind_list;\r\nif (!bind_list)\r\nreturn;\r\nmutex_lock(&lock);\r\nhlist_del(&id_priv->node);\r\nif (hlist_empty(&bind_list->owners)) {\r\nidr_remove(bind_list->ps, bind_list->port);\r\nkfree(bind_list);\r\n}\r\nmutex_unlock(&lock);\r\n}\r\nstatic void cma_leave_mc_groups(struct rdma_id_private *id_priv)\r\n{\r\nstruct cma_multicast *mc;\r\nwhile (!list_empty(&id_priv->mc_list)) {\r\nmc = container_of(id_priv->mc_list.next,\r\nstruct cma_multicast, list);\r\nlist_del(&mc->list);\r\nswitch (rdma_port_get_link_layer(id_priv->cma_dev->device, id_priv->id.port_num)) {\r\ncase IB_LINK_LAYER_INFINIBAND:\r\nib_sa_free_multicast(mc->multicast.ib);\r\nkfree(mc);\r\nbreak;\r\ncase IB_LINK_LAYER_ETHERNET:\r\nkref_put(&mc->mcref, release_mc);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid rdma_destroy_id(struct rdma_cm_id *id)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nenum rdma_cm_state state;\r\nid_priv = container_of(id, struct rdma_id_private, id);\r\nstate = cma_exch(id_priv, RDMA_CM_DESTROYING);\r\ncma_cancel_operation(id_priv, state);\r\nmutex_lock(&id_priv->handler_mutex);\r\nmutex_unlock(&id_priv->handler_mutex);\r\nif (id_priv->cma_dev) {\r\nswitch (rdma_node_get_transport(id_priv->id.device->node_type)) {\r\ncase RDMA_TRANSPORT_IB:\r\nif (id_priv->cm_id.ib)\r\nib_destroy_cm_id(id_priv->cm_id.ib);\r\nbreak;\r\ncase RDMA_TRANSPORT_IWARP:\r\nif (id_priv->cm_id.iw)\r\niw_destroy_cm_id(id_priv->cm_id.iw);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ncma_leave_mc_groups(id_priv);\r\ncma_release_dev(id_priv);\r\n}\r\ncma_release_port(id_priv);\r\ncma_deref_id(id_priv);\r\nwait_for_completion(&id_priv->comp);\r\nif (id_priv->internal_id)\r\ncma_deref_id(id_priv->id.context);\r\nkfree(id_priv->id.route.path_rec);\r\nkfree(id_priv);\r\n}\r\nstatic int cma_rep_recv(struct rdma_id_private *id_priv)\r\n{\r\nint ret;\r\nret = cma_modify_qp_rtr(id_priv, NULL);\r\nif (ret)\r\ngoto reject;\r\nret = cma_modify_qp_rts(id_priv, NULL);\r\nif (ret)\r\ngoto reject;\r\nret = ib_send_cm_rtu(id_priv->cm_id.ib, NULL, 0);\r\nif (ret)\r\ngoto reject;\r\nreturn 0;\r\nreject:\r\ncma_modify_qp_err(id_priv);\r\nib_send_cm_rej(id_priv->cm_id.ib, IB_CM_REJ_CONSUMER_DEFINED,\r\nNULL, 0, NULL, 0);\r\nreturn ret;\r\n}\r\nstatic int cma_verify_rep(struct rdma_id_private *id_priv, void *data)\r\n{\r\nif (id_priv->id.ps == RDMA_PS_SDP &&\r\nsdp_get_majv(((struct sdp_hah *) data)->sdp_version) !=\r\nSDP_MAJ_VERSION)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void cma_set_rep_event_data(struct rdma_cm_event *event,\r\nstruct ib_cm_rep_event_param *rep_data,\r\nvoid *private_data)\r\n{\r\nevent->param.conn.private_data = private_data;\r\nevent->param.conn.private_data_len = IB_CM_REP_PRIVATE_DATA_SIZE;\r\nevent->param.conn.responder_resources = rep_data->responder_resources;\r\nevent->param.conn.initiator_depth = rep_data->initiator_depth;\r\nevent->param.conn.flow_control = rep_data->flow_control;\r\nevent->param.conn.rnr_retry_count = rep_data->rnr_retry_count;\r\nevent->param.conn.srq = rep_data->srq;\r\nevent->param.conn.qp_num = rep_data->remote_qpn;\r\n}\r\nstatic int cma_ib_handler(struct ib_cm_id *cm_id, struct ib_cm_event *ib_event)\r\n{\r\nstruct rdma_id_private *id_priv = cm_id->context;\r\nstruct rdma_cm_event event;\r\nint ret = 0;\r\nif ((ib_event->event != IB_CM_TIMEWAIT_EXIT &&\r\ncma_disable_callback(id_priv, RDMA_CM_CONNECT)) ||\r\n(ib_event->event == IB_CM_TIMEWAIT_EXIT &&\r\ncma_disable_callback(id_priv, RDMA_CM_DISCONNECT)))\r\nreturn 0;\r\nmemset(&event, 0, sizeof event);\r\nswitch (ib_event->event) {\r\ncase IB_CM_REQ_ERROR:\r\ncase IB_CM_REP_ERROR:\r\nevent.event = RDMA_CM_EVENT_UNREACHABLE;\r\nevent.status = -ETIMEDOUT;\r\nbreak;\r\ncase IB_CM_REP_RECEIVED:\r\nevent.status = cma_verify_rep(id_priv, ib_event->private_data);\r\nif (event.status)\r\nevent.event = RDMA_CM_EVENT_CONNECT_ERROR;\r\nelse if (id_priv->id.qp && id_priv->id.ps != RDMA_PS_SDP) {\r\nevent.status = cma_rep_recv(id_priv);\r\nevent.event = event.status ? RDMA_CM_EVENT_CONNECT_ERROR :\r\nRDMA_CM_EVENT_ESTABLISHED;\r\n} else\r\nevent.event = RDMA_CM_EVENT_CONNECT_RESPONSE;\r\ncma_set_rep_event_data(&event, &ib_event->param.rep_rcvd,\r\nib_event->private_data);\r\nbreak;\r\ncase IB_CM_RTU_RECEIVED:\r\ncase IB_CM_USER_ESTABLISHED:\r\nevent.event = RDMA_CM_EVENT_ESTABLISHED;\r\nbreak;\r\ncase IB_CM_DREQ_ERROR:\r\nevent.status = -ETIMEDOUT;\r\ncase IB_CM_DREQ_RECEIVED:\r\ncase IB_CM_DREP_RECEIVED:\r\nif (!cma_comp_exch(id_priv, RDMA_CM_CONNECT,\r\nRDMA_CM_DISCONNECT))\r\ngoto out;\r\nevent.event = RDMA_CM_EVENT_DISCONNECTED;\r\nbreak;\r\ncase IB_CM_TIMEWAIT_EXIT:\r\nevent.event = RDMA_CM_EVENT_TIMEWAIT_EXIT;\r\nbreak;\r\ncase IB_CM_MRA_RECEIVED:\r\ngoto out;\r\ncase IB_CM_REJ_RECEIVED:\r\ncma_modify_qp_err(id_priv);\r\nevent.status = ib_event->param.rej_rcvd.reason;\r\nevent.event = RDMA_CM_EVENT_REJECTED;\r\nevent.param.conn.private_data = ib_event->private_data;\r\nevent.param.conn.private_data_len = IB_CM_REJ_PRIVATE_DATA_SIZE;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "RDMA CMA: unexpected IB CM event: %d\n",\r\nib_event->event);\r\ngoto out;\r\n}\r\nret = id_priv->id.event_handler(&id_priv->id, &event);\r\nif (ret) {\r\nid_priv->cm_id.ib = NULL;\r\ncma_exch(id_priv, RDMA_CM_DESTROYING);\r\nmutex_unlock(&id_priv->handler_mutex);\r\nrdma_destroy_id(&id_priv->id);\r\nreturn ret;\r\n}\r\nout:\r\nmutex_unlock(&id_priv->handler_mutex);\r\nreturn ret;\r\n}\r\nstatic struct rdma_id_private *cma_new_conn_id(struct rdma_cm_id *listen_id,\r\nstruct ib_cm_event *ib_event)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nstruct rdma_cm_id *id;\r\nstruct rdma_route *rt;\r\nunion cma_ip_addr *src, *dst;\r\n__be16 port;\r\nu8 ip_ver;\r\nint ret;\r\nif (cma_get_net_info(ib_event->private_data, listen_id->ps,\r\n&ip_ver, &port, &src, &dst))\r\nreturn NULL;\r\nid = rdma_create_id(listen_id->event_handler, listen_id->context,\r\nlisten_id->ps, ib_event->param.req_rcvd.qp_type);\r\nif (IS_ERR(id))\r\nreturn NULL;\r\ncma_save_net_info(&id->route.addr, &listen_id->route.addr,\r\nip_ver, port, src, dst);\r\nrt = &id->route;\r\nrt->num_paths = ib_event->param.req_rcvd.alternate_path ? 2 : 1;\r\nrt->path_rec = kmalloc(sizeof *rt->path_rec * rt->num_paths,\r\nGFP_KERNEL);\r\nif (!rt->path_rec)\r\ngoto err;\r\nrt->path_rec[0] = *ib_event->param.req_rcvd.primary_path;\r\nif (rt->num_paths == 2)\r\nrt->path_rec[1] = *ib_event->param.req_rcvd.alternate_path;\r\nif (cma_any_addr((struct sockaddr *) &rt->addr.src_addr)) {\r\nrt->addr.dev_addr.dev_type = ARPHRD_INFINIBAND;\r\nrdma_addr_set_sgid(&rt->addr.dev_addr, &rt->path_rec[0].sgid);\r\nib_addr_set_pkey(&rt->addr.dev_addr, be16_to_cpu(rt->path_rec[0].pkey));\r\n} else {\r\nret = rdma_translate_ip((struct sockaddr *) &rt->addr.src_addr,\r\n&rt->addr.dev_addr);\r\nif (ret)\r\ngoto err;\r\n}\r\nrdma_addr_set_dgid(&rt->addr.dev_addr, &rt->path_rec[0].dgid);\r\nid_priv = container_of(id, struct rdma_id_private, id);\r\nid_priv->state = RDMA_CM_CONNECT;\r\nreturn id_priv;\r\nerr:\r\nrdma_destroy_id(id);\r\nreturn NULL;\r\n}\r\nstatic struct rdma_id_private *cma_new_udp_id(struct rdma_cm_id *listen_id,\r\nstruct ib_cm_event *ib_event)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nstruct rdma_cm_id *id;\r\nunion cma_ip_addr *src, *dst;\r\n__be16 port;\r\nu8 ip_ver;\r\nint ret;\r\nid = rdma_create_id(listen_id->event_handler, listen_id->context,\r\nlisten_id->ps, IB_QPT_UD);\r\nif (IS_ERR(id))\r\nreturn NULL;\r\nif (cma_get_net_info(ib_event->private_data, listen_id->ps,\r\n&ip_ver, &port, &src, &dst))\r\ngoto err;\r\ncma_save_net_info(&id->route.addr, &listen_id->route.addr,\r\nip_ver, port, src, dst);\r\nif (!cma_any_addr((struct sockaddr *) &id->route.addr.src_addr)) {\r\nret = rdma_translate_ip((struct sockaddr *) &id->route.addr.src_addr,\r\n&id->route.addr.dev_addr);\r\nif (ret)\r\ngoto err;\r\n}\r\nid_priv = container_of(id, struct rdma_id_private, id);\r\nid_priv->state = RDMA_CM_CONNECT;\r\nreturn id_priv;\r\nerr:\r\nrdma_destroy_id(id);\r\nreturn NULL;\r\n}\r\nstatic void cma_set_req_event_data(struct rdma_cm_event *event,\r\nstruct ib_cm_req_event_param *req_data,\r\nvoid *private_data, int offset)\r\n{\r\nevent->param.conn.private_data = private_data + offset;\r\nevent->param.conn.private_data_len = IB_CM_REQ_PRIVATE_DATA_SIZE - offset;\r\nevent->param.conn.responder_resources = req_data->responder_resources;\r\nevent->param.conn.initiator_depth = req_data->initiator_depth;\r\nevent->param.conn.flow_control = req_data->flow_control;\r\nevent->param.conn.retry_count = req_data->retry_count;\r\nevent->param.conn.rnr_retry_count = req_data->rnr_retry_count;\r\nevent->param.conn.srq = req_data->srq;\r\nevent->param.conn.qp_num = req_data->remote_qpn;\r\n}\r\nstatic int cma_check_req_qp_type(struct rdma_cm_id *id, struct ib_cm_event *ib_event)\r\n{\r\nreturn (((ib_event->event == IB_CM_REQ_RECEIVED) ||\r\n(ib_event->param.req_rcvd.qp_type == id->qp_type)) ||\r\n((ib_event->event == IB_CM_SIDR_REQ_RECEIVED) &&\r\n(id->qp_type == IB_QPT_UD)) ||\r\n(!id->qp_type));\r\n}\r\nstatic int cma_req_handler(struct ib_cm_id *cm_id, struct ib_cm_event *ib_event)\r\n{\r\nstruct rdma_id_private *listen_id, *conn_id;\r\nstruct rdma_cm_event event;\r\nint offset, ret;\r\nlisten_id = cm_id->context;\r\nif (!cma_check_req_qp_type(&listen_id->id, ib_event))\r\nreturn -EINVAL;\r\nif (cma_disable_callback(listen_id, RDMA_CM_LISTEN))\r\nreturn -ECONNABORTED;\r\nmemset(&event, 0, sizeof event);\r\noffset = cma_user_data_offset(listen_id->id.ps);\r\nevent.event = RDMA_CM_EVENT_CONNECT_REQUEST;\r\nif (ib_event->event == IB_CM_SIDR_REQ_RECEIVED) {\r\nconn_id = cma_new_udp_id(&listen_id->id, ib_event);\r\nevent.param.ud.private_data = ib_event->private_data + offset;\r\nevent.param.ud.private_data_len =\r\nIB_CM_SIDR_REQ_PRIVATE_DATA_SIZE - offset;\r\n} else {\r\nconn_id = cma_new_conn_id(&listen_id->id, ib_event);\r\ncma_set_req_event_data(&event, &ib_event->param.req_rcvd,\r\nib_event->private_data, offset);\r\n}\r\nif (!conn_id) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmutex_lock_nested(&conn_id->handler_mutex, SINGLE_DEPTH_NESTING);\r\nret = cma_acquire_dev(conn_id);\r\nif (ret)\r\ngoto release_conn_id;\r\nconn_id->cm_id.ib = cm_id;\r\ncm_id->context = conn_id;\r\ncm_id->cm_handler = cma_ib_handler;\r\natomic_inc(&conn_id->refcount);\r\nret = conn_id->id.event_handler(&conn_id->id, &event);\r\nif (!ret) {\r\nmutex_lock(&lock);\r\nif (cma_comp(conn_id, RDMA_CM_CONNECT) && (conn_id->id.qp_type != IB_QPT_UD))\r\nib_send_cm_mra(cm_id, CMA_CM_MRA_SETTING, NULL, 0);\r\nmutex_unlock(&lock);\r\nmutex_unlock(&conn_id->handler_mutex);\r\ncma_deref_id(conn_id);\r\ngoto out;\r\n}\r\ncma_deref_id(conn_id);\r\nconn_id->cm_id.ib = NULL;\r\nrelease_conn_id:\r\ncma_exch(conn_id, RDMA_CM_DESTROYING);\r\nmutex_unlock(&conn_id->handler_mutex);\r\nrdma_destroy_id(&conn_id->id);\r\nout:\r\nmutex_unlock(&listen_id->handler_mutex);\r\nreturn ret;\r\n}\r\nstatic __be64 cma_get_service_id(enum rdma_port_space ps, struct sockaddr *addr)\r\n{\r\nreturn cpu_to_be64(((u64)ps << 16) + be16_to_cpu(cma_port(addr)));\r\n}\r\nstatic void cma_set_compare_data(enum rdma_port_space ps, struct sockaddr *addr,\r\nstruct ib_cm_compare_data *compare)\r\n{\r\nstruct cma_hdr *cma_data, *cma_mask;\r\nstruct sdp_hh *sdp_data, *sdp_mask;\r\n__be32 ip4_addr;\r\nstruct in6_addr ip6_addr;\r\nmemset(compare, 0, sizeof *compare);\r\ncma_data = (void *) compare->data;\r\ncma_mask = (void *) compare->mask;\r\nsdp_data = (void *) compare->data;\r\nsdp_mask = (void *) compare->mask;\r\nswitch (addr->sa_family) {\r\ncase AF_INET:\r\nip4_addr = ((struct sockaddr_in *) addr)->sin_addr.s_addr;\r\nif (ps == RDMA_PS_SDP) {\r\nsdp_set_ip_ver(sdp_data, 4);\r\nsdp_set_ip_ver(sdp_mask, 0xF);\r\nsdp_data->dst_addr.ip4.addr = ip4_addr;\r\nsdp_mask->dst_addr.ip4.addr = htonl(~0);\r\n} else {\r\ncma_set_ip_ver(cma_data, 4);\r\ncma_set_ip_ver(cma_mask, 0xF);\r\ncma_data->dst_addr.ip4.addr = ip4_addr;\r\ncma_mask->dst_addr.ip4.addr = htonl(~0);\r\n}\r\nbreak;\r\ncase AF_INET6:\r\nip6_addr = ((struct sockaddr_in6 *) addr)->sin6_addr;\r\nif (ps == RDMA_PS_SDP) {\r\nsdp_set_ip_ver(sdp_data, 6);\r\nsdp_set_ip_ver(sdp_mask, 0xF);\r\nsdp_data->dst_addr.ip6 = ip6_addr;\r\nmemset(&sdp_mask->dst_addr.ip6, 0xFF,\r\nsizeof sdp_mask->dst_addr.ip6);\r\n} else {\r\ncma_set_ip_ver(cma_data, 6);\r\ncma_set_ip_ver(cma_mask, 0xF);\r\ncma_data->dst_addr.ip6 = ip6_addr;\r\nmemset(&cma_mask->dst_addr.ip6, 0xFF,\r\nsizeof cma_mask->dst_addr.ip6);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int cma_iw_handler(struct iw_cm_id *iw_id, struct iw_cm_event *iw_event)\r\n{\r\nstruct rdma_id_private *id_priv = iw_id->context;\r\nstruct rdma_cm_event event;\r\nstruct sockaddr_in *sin;\r\nint ret = 0;\r\nif (cma_disable_callback(id_priv, RDMA_CM_CONNECT))\r\nreturn 0;\r\nmemset(&event, 0, sizeof event);\r\nswitch (iw_event->event) {\r\ncase IW_CM_EVENT_CLOSE:\r\nevent.event = RDMA_CM_EVENT_DISCONNECTED;\r\nbreak;\r\ncase IW_CM_EVENT_CONNECT_REPLY:\r\nsin = (struct sockaddr_in *) &id_priv->id.route.addr.src_addr;\r\n*sin = iw_event->local_addr;\r\nsin = (struct sockaddr_in *) &id_priv->id.route.addr.dst_addr;\r\n*sin = iw_event->remote_addr;\r\nswitch (iw_event->status) {\r\ncase 0:\r\nevent.event = RDMA_CM_EVENT_ESTABLISHED;\r\nevent.param.conn.initiator_depth = iw_event->ird;\r\nevent.param.conn.responder_resources = iw_event->ord;\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ECONNREFUSED:\r\nevent.event = RDMA_CM_EVENT_REJECTED;\r\nbreak;\r\ncase -ETIMEDOUT:\r\nevent.event = RDMA_CM_EVENT_UNREACHABLE;\r\nbreak;\r\ndefault:\r\nevent.event = RDMA_CM_EVENT_CONNECT_ERROR;\r\nbreak;\r\n}\r\nbreak;\r\ncase IW_CM_EVENT_ESTABLISHED:\r\nevent.event = RDMA_CM_EVENT_ESTABLISHED;\r\nevent.param.conn.initiator_depth = iw_event->ird;\r\nevent.param.conn.responder_resources = iw_event->ord;\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\n}\r\nevent.status = iw_event->status;\r\nevent.param.conn.private_data = iw_event->private_data;\r\nevent.param.conn.private_data_len = iw_event->private_data_len;\r\nret = id_priv->id.event_handler(&id_priv->id, &event);\r\nif (ret) {\r\nid_priv->cm_id.iw = NULL;\r\ncma_exch(id_priv, RDMA_CM_DESTROYING);\r\nmutex_unlock(&id_priv->handler_mutex);\r\nrdma_destroy_id(&id_priv->id);\r\nreturn ret;\r\n}\r\nmutex_unlock(&id_priv->handler_mutex);\r\nreturn ret;\r\n}\r\nstatic int iw_conn_req_handler(struct iw_cm_id *cm_id,\r\nstruct iw_cm_event *iw_event)\r\n{\r\nstruct rdma_cm_id *new_cm_id;\r\nstruct rdma_id_private *listen_id, *conn_id;\r\nstruct sockaddr_in *sin;\r\nstruct net_device *dev = NULL;\r\nstruct rdma_cm_event event;\r\nint ret;\r\nstruct ib_device_attr attr;\r\nlisten_id = cm_id->context;\r\nif (cma_disable_callback(listen_id, RDMA_CM_LISTEN))\r\nreturn -ECONNABORTED;\r\nnew_cm_id = rdma_create_id(listen_id->id.event_handler,\r\nlisten_id->id.context,\r\nRDMA_PS_TCP, IB_QPT_RC);\r\nif (IS_ERR(new_cm_id)) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nconn_id = container_of(new_cm_id, struct rdma_id_private, id);\r\nmutex_lock_nested(&conn_id->handler_mutex, SINGLE_DEPTH_NESTING);\r\nconn_id->state = RDMA_CM_CONNECT;\r\ndev = ip_dev_find(&init_net, iw_event->local_addr.sin_addr.s_addr);\r\nif (!dev) {\r\nret = -EADDRNOTAVAIL;\r\nmutex_unlock(&conn_id->handler_mutex);\r\nrdma_destroy_id(new_cm_id);\r\ngoto out;\r\n}\r\nret = rdma_copy_addr(&conn_id->id.route.addr.dev_addr, dev, NULL);\r\nif (ret) {\r\nmutex_unlock(&conn_id->handler_mutex);\r\nrdma_destroy_id(new_cm_id);\r\ngoto out;\r\n}\r\nret = cma_acquire_dev(conn_id);\r\nif (ret) {\r\nmutex_unlock(&conn_id->handler_mutex);\r\nrdma_destroy_id(new_cm_id);\r\ngoto out;\r\n}\r\nconn_id->cm_id.iw = cm_id;\r\ncm_id->context = conn_id;\r\ncm_id->cm_handler = cma_iw_handler;\r\nsin = (struct sockaddr_in *) &new_cm_id->route.addr.src_addr;\r\n*sin = iw_event->local_addr;\r\nsin = (struct sockaddr_in *) &new_cm_id->route.addr.dst_addr;\r\n*sin = iw_event->remote_addr;\r\nret = ib_query_device(conn_id->id.device, &attr);\r\nif (ret) {\r\nmutex_unlock(&conn_id->handler_mutex);\r\nrdma_destroy_id(new_cm_id);\r\ngoto out;\r\n}\r\nmemset(&event, 0, sizeof event);\r\nevent.event = RDMA_CM_EVENT_CONNECT_REQUEST;\r\nevent.param.conn.private_data = iw_event->private_data;\r\nevent.param.conn.private_data_len = iw_event->private_data_len;\r\nevent.param.conn.initiator_depth = iw_event->ird;\r\nevent.param.conn.responder_resources = iw_event->ord;\r\natomic_inc(&conn_id->refcount);\r\nret = conn_id->id.event_handler(&conn_id->id, &event);\r\nif (ret) {\r\nconn_id->cm_id.iw = NULL;\r\ncma_exch(conn_id, RDMA_CM_DESTROYING);\r\nmutex_unlock(&conn_id->handler_mutex);\r\ncma_deref_id(conn_id);\r\nrdma_destroy_id(&conn_id->id);\r\ngoto out;\r\n}\r\nmutex_unlock(&conn_id->handler_mutex);\r\ncma_deref_id(conn_id);\r\nout:\r\nif (dev)\r\ndev_put(dev);\r\nmutex_unlock(&listen_id->handler_mutex);\r\nreturn ret;\r\n}\r\nstatic int cma_ib_listen(struct rdma_id_private *id_priv)\r\n{\r\nstruct ib_cm_compare_data compare_data;\r\nstruct sockaddr *addr;\r\nstruct ib_cm_id *id;\r\n__be64 svc_id;\r\nint ret;\r\nid = ib_create_cm_id(id_priv->id.device, cma_req_handler, id_priv);\r\nif (IS_ERR(id))\r\nreturn PTR_ERR(id);\r\nid_priv->cm_id.ib = id;\r\naddr = (struct sockaddr *) &id_priv->id.route.addr.src_addr;\r\nsvc_id = cma_get_service_id(id_priv->id.ps, addr);\r\nif (cma_any_addr(addr))\r\nret = ib_cm_listen(id_priv->cm_id.ib, svc_id, 0, NULL);\r\nelse {\r\ncma_set_compare_data(id_priv->id.ps, addr, &compare_data);\r\nret = ib_cm_listen(id_priv->cm_id.ib, svc_id, 0, &compare_data);\r\n}\r\nif (ret) {\r\nib_destroy_cm_id(id_priv->cm_id.ib);\r\nid_priv->cm_id.ib = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cma_iw_listen(struct rdma_id_private *id_priv, int backlog)\r\n{\r\nint ret;\r\nstruct sockaddr_in *sin;\r\nstruct iw_cm_id *id;\r\nid = iw_create_cm_id(id_priv->id.device,\r\niw_conn_req_handler,\r\nid_priv);\r\nif (IS_ERR(id))\r\nreturn PTR_ERR(id);\r\nid_priv->cm_id.iw = id;\r\nsin = (struct sockaddr_in *) &id_priv->id.route.addr.src_addr;\r\nid_priv->cm_id.iw->local_addr = *sin;\r\nret = iw_cm_listen(id_priv->cm_id.iw, backlog);\r\nif (ret) {\r\niw_destroy_cm_id(id_priv->cm_id.iw);\r\nid_priv->cm_id.iw = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cma_listen_handler(struct rdma_cm_id *id,\r\nstruct rdma_cm_event *event)\r\n{\r\nstruct rdma_id_private *id_priv = id->context;\r\nid->context = id_priv->id.context;\r\nid->event_handler = id_priv->id.event_handler;\r\nreturn id_priv->id.event_handler(id, event);\r\n}\r\nstatic void cma_listen_on_dev(struct rdma_id_private *id_priv,\r\nstruct cma_device *cma_dev)\r\n{\r\nstruct rdma_id_private *dev_id_priv;\r\nstruct rdma_cm_id *id;\r\nint ret;\r\nid = rdma_create_id(cma_listen_handler, id_priv, id_priv->id.ps,\r\nid_priv->id.qp_type);\r\nif (IS_ERR(id))\r\nreturn;\r\ndev_id_priv = container_of(id, struct rdma_id_private, id);\r\ndev_id_priv->state = RDMA_CM_ADDR_BOUND;\r\nmemcpy(&id->route.addr.src_addr, &id_priv->id.route.addr.src_addr,\r\nip_addr_size((struct sockaddr *) &id_priv->id.route.addr.src_addr));\r\ncma_attach_to_dev(dev_id_priv, cma_dev);\r\nlist_add_tail(&dev_id_priv->listen_list, &id_priv->listen_list);\r\natomic_inc(&id_priv->refcount);\r\ndev_id_priv->internal_id = 1;\r\nret = rdma_listen(id, id_priv->backlog);\r\nif (ret)\r\nprintk(KERN_WARNING "RDMA CMA: cma_listen_on_dev, error %d, "\r\n"listening on device %s\n", ret, cma_dev->device->name);\r\n}\r\nstatic void cma_listen_on_all(struct rdma_id_private *id_priv)\r\n{\r\nstruct cma_device *cma_dev;\r\nmutex_lock(&lock);\r\nlist_add_tail(&id_priv->list, &listen_any_list);\r\nlist_for_each_entry(cma_dev, &dev_list, list)\r\ncma_listen_on_dev(id_priv, cma_dev);\r\nmutex_unlock(&lock);\r\n}\r\nvoid rdma_set_service_type(struct rdma_cm_id *id, int tos)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nid_priv = container_of(id, struct rdma_id_private, id);\r\nid_priv->tos = (u8) tos;\r\n}\r\nstatic void cma_query_handler(int status, struct ib_sa_path_rec *path_rec,\r\nvoid *context)\r\n{\r\nstruct cma_work *work = context;\r\nstruct rdma_route *route;\r\nroute = &work->id->id.route;\r\nif (!status) {\r\nroute->num_paths = 1;\r\n*route->path_rec = *path_rec;\r\n} else {\r\nwork->old_state = RDMA_CM_ROUTE_QUERY;\r\nwork->new_state = RDMA_CM_ADDR_RESOLVED;\r\nwork->event.event = RDMA_CM_EVENT_ROUTE_ERROR;\r\nwork->event.status = status;\r\n}\r\nqueue_work(cma_wq, &work->work);\r\n}\r\nstatic int cma_query_ib_route(struct rdma_id_private *id_priv, int timeout_ms,\r\nstruct cma_work *work)\r\n{\r\nstruct rdma_addr *addr = &id_priv->id.route.addr;\r\nstruct ib_sa_path_rec path_rec;\r\nib_sa_comp_mask comp_mask;\r\nstruct sockaddr_in6 *sin6;\r\nmemset(&path_rec, 0, sizeof path_rec);\r\nrdma_addr_get_sgid(&addr->dev_addr, &path_rec.sgid);\r\nrdma_addr_get_dgid(&addr->dev_addr, &path_rec.dgid);\r\npath_rec.pkey = cpu_to_be16(ib_addr_get_pkey(&addr->dev_addr));\r\npath_rec.numb_path = 1;\r\npath_rec.reversible = 1;\r\npath_rec.service_id = cma_get_service_id(id_priv->id.ps,\r\n(struct sockaddr *) &addr->dst_addr);\r\ncomp_mask = IB_SA_PATH_REC_DGID | IB_SA_PATH_REC_SGID |\r\nIB_SA_PATH_REC_PKEY | IB_SA_PATH_REC_NUMB_PATH |\r\nIB_SA_PATH_REC_REVERSIBLE | IB_SA_PATH_REC_SERVICE_ID;\r\nif (addr->src_addr.ss_family == AF_INET) {\r\npath_rec.qos_class = cpu_to_be16((u16) id_priv->tos);\r\ncomp_mask |= IB_SA_PATH_REC_QOS_CLASS;\r\n} else {\r\nsin6 = (struct sockaddr_in6 *) &addr->src_addr;\r\npath_rec.traffic_class = (u8) (be32_to_cpu(sin6->sin6_flowinfo) >> 20);\r\ncomp_mask |= IB_SA_PATH_REC_TRAFFIC_CLASS;\r\n}\r\nid_priv->query_id = ib_sa_path_rec_get(&sa_client, id_priv->id.device,\r\nid_priv->id.port_num, &path_rec,\r\ncomp_mask, timeout_ms,\r\nGFP_KERNEL, cma_query_handler,\r\nwork, &id_priv->query);\r\nreturn (id_priv->query_id < 0) ? id_priv->query_id : 0;\r\n}\r\nstatic void cma_work_handler(struct work_struct *_work)\r\n{\r\nstruct cma_work *work = container_of(_work, struct cma_work, work);\r\nstruct rdma_id_private *id_priv = work->id;\r\nint destroy = 0;\r\nmutex_lock(&id_priv->handler_mutex);\r\nif (!cma_comp_exch(id_priv, work->old_state, work->new_state))\r\ngoto out;\r\nif (id_priv->id.event_handler(&id_priv->id, &work->event)) {\r\ncma_exch(id_priv, RDMA_CM_DESTROYING);\r\ndestroy = 1;\r\n}\r\nout:\r\nmutex_unlock(&id_priv->handler_mutex);\r\ncma_deref_id(id_priv);\r\nif (destroy)\r\nrdma_destroy_id(&id_priv->id);\r\nkfree(work);\r\n}\r\nstatic void cma_ndev_work_handler(struct work_struct *_work)\r\n{\r\nstruct cma_ndev_work *work = container_of(_work, struct cma_ndev_work, work);\r\nstruct rdma_id_private *id_priv = work->id;\r\nint destroy = 0;\r\nmutex_lock(&id_priv->handler_mutex);\r\nif (id_priv->state == RDMA_CM_DESTROYING ||\r\nid_priv->state == RDMA_CM_DEVICE_REMOVAL)\r\ngoto out;\r\nif (id_priv->id.event_handler(&id_priv->id, &work->event)) {\r\ncma_exch(id_priv, RDMA_CM_DESTROYING);\r\ndestroy = 1;\r\n}\r\nout:\r\nmutex_unlock(&id_priv->handler_mutex);\r\ncma_deref_id(id_priv);\r\nif (destroy)\r\nrdma_destroy_id(&id_priv->id);\r\nkfree(work);\r\n}\r\nstatic int cma_resolve_ib_route(struct rdma_id_private *id_priv, int timeout_ms)\r\n{\r\nstruct rdma_route *route = &id_priv->id.route;\r\nstruct cma_work *work;\r\nint ret;\r\nwork = kzalloc(sizeof *work, GFP_KERNEL);\r\nif (!work)\r\nreturn -ENOMEM;\r\nwork->id = id_priv;\r\nINIT_WORK(&work->work, cma_work_handler);\r\nwork->old_state = RDMA_CM_ROUTE_QUERY;\r\nwork->new_state = RDMA_CM_ROUTE_RESOLVED;\r\nwork->event.event = RDMA_CM_EVENT_ROUTE_RESOLVED;\r\nroute->path_rec = kmalloc(sizeof *route->path_rec, GFP_KERNEL);\r\nif (!route->path_rec) {\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nret = cma_query_ib_route(id_priv, timeout_ms, work);\r\nif (ret)\r\ngoto err2;\r\nreturn 0;\r\nerr2:\r\nkfree(route->path_rec);\r\nroute->path_rec = NULL;\r\nerr1:\r\nkfree(work);\r\nreturn ret;\r\n}\r\nint rdma_set_ib_paths(struct rdma_cm_id *id,\r\nstruct ib_sa_path_rec *path_rec, int num_paths)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nint ret;\r\nid_priv = container_of(id, struct rdma_id_private, id);\r\nif (!cma_comp_exch(id_priv, RDMA_CM_ADDR_RESOLVED,\r\nRDMA_CM_ROUTE_RESOLVED))\r\nreturn -EINVAL;\r\nid->route.path_rec = kmemdup(path_rec, sizeof *path_rec * num_paths,\r\nGFP_KERNEL);\r\nif (!id->route.path_rec) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nid->route.num_paths = num_paths;\r\nreturn 0;\r\nerr:\r\ncma_comp_exch(id_priv, RDMA_CM_ROUTE_RESOLVED, RDMA_CM_ADDR_RESOLVED);\r\nreturn ret;\r\n}\r\nstatic int cma_resolve_iw_route(struct rdma_id_private *id_priv, int timeout_ms)\r\n{\r\nstruct cma_work *work;\r\nwork = kzalloc(sizeof *work, GFP_KERNEL);\r\nif (!work)\r\nreturn -ENOMEM;\r\nwork->id = id_priv;\r\nINIT_WORK(&work->work, cma_work_handler);\r\nwork->old_state = RDMA_CM_ROUTE_QUERY;\r\nwork->new_state = RDMA_CM_ROUTE_RESOLVED;\r\nwork->event.event = RDMA_CM_EVENT_ROUTE_RESOLVED;\r\nqueue_work(cma_wq, &work->work);\r\nreturn 0;\r\n}\r\nstatic int cma_resolve_iboe_route(struct rdma_id_private *id_priv)\r\n{\r\nstruct rdma_route *route = &id_priv->id.route;\r\nstruct rdma_addr *addr = &route->addr;\r\nstruct cma_work *work;\r\nint ret;\r\nstruct sockaddr_in *src_addr = (struct sockaddr_in *)&route->addr.src_addr;\r\nstruct sockaddr_in *dst_addr = (struct sockaddr_in *)&route->addr.dst_addr;\r\nstruct net_device *ndev = NULL;\r\nu16 vid;\r\nif (src_addr->sin_family != dst_addr->sin_family)\r\nreturn -EINVAL;\r\nwork = kzalloc(sizeof *work, GFP_KERNEL);\r\nif (!work)\r\nreturn -ENOMEM;\r\nwork->id = id_priv;\r\nINIT_WORK(&work->work, cma_work_handler);\r\nroute->path_rec = kzalloc(sizeof *route->path_rec, GFP_KERNEL);\r\nif (!route->path_rec) {\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\nroute->num_paths = 1;\r\nif (addr->dev_addr.bound_dev_if)\r\nndev = dev_get_by_index(&init_net, addr->dev_addr.bound_dev_if);\r\nif (!ndev) {\r\nret = -ENODEV;\r\ngoto err2;\r\n}\r\nvid = rdma_vlan_dev_vlan_id(ndev);\r\niboe_mac_vlan_to_ll(&route->path_rec->sgid, addr->dev_addr.src_dev_addr, vid);\r\niboe_mac_vlan_to_ll(&route->path_rec->dgid, addr->dev_addr.dst_dev_addr, vid);\r\nroute->path_rec->hop_limit = 1;\r\nroute->path_rec->reversible = 1;\r\nroute->path_rec->pkey = cpu_to_be16(0xffff);\r\nroute->path_rec->mtu_selector = IB_SA_EQ;\r\nroute->path_rec->sl = id_priv->tos >> 5;\r\nroute->path_rec->mtu = iboe_get_mtu(ndev->mtu);\r\nroute->path_rec->rate_selector = IB_SA_EQ;\r\nroute->path_rec->rate = iboe_get_rate(ndev);\r\ndev_put(ndev);\r\nroute->path_rec->packet_life_time_selector = IB_SA_EQ;\r\nroute->path_rec->packet_life_time = CMA_IBOE_PACKET_LIFETIME;\r\nif (!route->path_rec->mtu) {\r\nret = -EINVAL;\r\ngoto err2;\r\n}\r\nwork->old_state = RDMA_CM_ROUTE_QUERY;\r\nwork->new_state = RDMA_CM_ROUTE_RESOLVED;\r\nwork->event.event = RDMA_CM_EVENT_ROUTE_RESOLVED;\r\nwork->event.status = 0;\r\nqueue_work(cma_wq, &work->work);\r\nreturn 0;\r\nerr2:\r\nkfree(route->path_rec);\r\nroute->path_rec = NULL;\r\nerr1:\r\nkfree(work);\r\nreturn ret;\r\n}\r\nint rdma_resolve_route(struct rdma_cm_id *id, int timeout_ms)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nint ret;\r\nid_priv = container_of(id, struct rdma_id_private, id);\r\nif (!cma_comp_exch(id_priv, RDMA_CM_ADDR_RESOLVED, RDMA_CM_ROUTE_QUERY))\r\nreturn -EINVAL;\r\natomic_inc(&id_priv->refcount);\r\nswitch (rdma_node_get_transport(id->device->node_type)) {\r\ncase RDMA_TRANSPORT_IB:\r\nswitch (rdma_port_get_link_layer(id->device, id->port_num)) {\r\ncase IB_LINK_LAYER_INFINIBAND:\r\nret = cma_resolve_ib_route(id_priv, timeout_ms);\r\nbreak;\r\ncase IB_LINK_LAYER_ETHERNET:\r\nret = cma_resolve_iboe_route(id_priv);\r\nbreak;\r\ndefault:\r\nret = -ENOSYS;\r\n}\r\nbreak;\r\ncase RDMA_TRANSPORT_IWARP:\r\nret = cma_resolve_iw_route(id_priv, timeout_ms);\r\nbreak;\r\ndefault:\r\nret = -ENOSYS;\r\nbreak;\r\n}\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ncma_comp_exch(id_priv, RDMA_CM_ROUTE_QUERY, RDMA_CM_ADDR_RESOLVED);\r\ncma_deref_id(id_priv);\r\nreturn ret;\r\n}\r\nstatic int cma_bind_loopback(struct rdma_id_private *id_priv)\r\n{\r\nstruct cma_device *cma_dev;\r\nstruct ib_port_attr port_attr;\r\nunion ib_gid gid;\r\nu16 pkey;\r\nint ret;\r\nu8 p;\r\nmutex_lock(&lock);\r\nif (list_empty(&dev_list)) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nlist_for_each_entry(cma_dev, &dev_list, list)\r\nfor (p = 1; p <= cma_dev->device->phys_port_cnt; ++p)\r\nif (!ib_query_port(cma_dev->device, p, &port_attr) &&\r\nport_attr.state == IB_PORT_ACTIVE)\r\ngoto port_found;\r\np = 1;\r\ncma_dev = list_entry(dev_list.next, struct cma_device, list);\r\nport_found:\r\nret = ib_get_cached_gid(cma_dev->device, p, 0, &gid);\r\nif (ret)\r\ngoto out;\r\nret = ib_get_cached_pkey(cma_dev->device, p, 0, &pkey);\r\nif (ret)\r\ngoto out;\r\nid_priv->id.route.addr.dev_addr.dev_type =\r\n(rdma_port_get_link_layer(cma_dev->device, p) == IB_LINK_LAYER_INFINIBAND) ?\r\nARPHRD_INFINIBAND : ARPHRD_ETHER;\r\nrdma_addr_set_sgid(&id_priv->id.route.addr.dev_addr, &gid);\r\nib_addr_set_pkey(&id_priv->id.route.addr.dev_addr, pkey);\r\nid_priv->id.port_num = p;\r\ncma_attach_to_dev(id_priv, cma_dev);\r\nout:\r\nmutex_unlock(&lock);\r\nreturn ret;\r\n}\r\nstatic void addr_handler(int status, struct sockaddr *src_addr,\r\nstruct rdma_dev_addr *dev_addr, void *context)\r\n{\r\nstruct rdma_id_private *id_priv = context;\r\nstruct rdma_cm_event event;\r\nmemset(&event, 0, sizeof event);\r\nmutex_lock(&id_priv->handler_mutex);\r\nif (!cma_comp_exch(id_priv, RDMA_CM_ADDR_QUERY,\r\nRDMA_CM_ADDR_RESOLVED))\r\ngoto out;\r\nif (!status && !id_priv->cma_dev)\r\nstatus = cma_acquire_dev(id_priv);\r\nif (status) {\r\nif (!cma_comp_exch(id_priv, RDMA_CM_ADDR_RESOLVED,\r\nRDMA_CM_ADDR_BOUND))\r\ngoto out;\r\nevent.event = RDMA_CM_EVENT_ADDR_ERROR;\r\nevent.status = status;\r\n} else {\r\nmemcpy(&id_priv->id.route.addr.src_addr, src_addr,\r\nip_addr_size(src_addr));\r\nevent.event = RDMA_CM_EVENT_ADDR_RESOLVED;\r\n}\r\nif (id_priv->id.event_handler(&id_priv->id, &event)) {\r\ncma_exch(id_priv, RDMA_CM_DESTROYING);\r\nmutex_unlock(&id_priv->handler_mutex);\r\ncma_deref_id(id_priv);\r\nrdma_destroy_id(&id_priv->id);\r\nreturn;\r\n}\r\nout:\r\nmutex_unlock(&id_priv->handler_mutex);\r\ncma_deref_id(id_priv);\r\n}\r\nstatic int cma_resolve_loopback(struct rdma_id_private *id_priv)\r\n{\r\nstruct cma_work *work;\r\nstruct sockaddr *src, *dst;\r\nunion ib_gid gid;\r\nint ret;\r\nwork = kzalloc(sizeof *work, GFP_KERNEL);\r\nif (!work)\r\nreturn -ENOMEM;\r\nif (!id_priv->cma_dev) {\r\nret = cma_bind_loopback(id_priv);\r\nif (ret)\r\ngoto err;\r\n}\r\nrdma_addr_get_sgid(&id_priv->id.route.addr.dev_addr, &gid);\r\nrdma_addr_set_dgid(&id_priv->id.route.addr.dev_addr, &gid);\r\nsrc = (struct sockaddr *) &id_priv->id.route.addr.src_addr;\r\nif (cma_zero_addr(src)) {\r\ndst = (struct sockaddr *) &id_priv->id.route.addr.dst_addr;\r\nif ((src->sa_family = dst->sa_family) == AF_INET) {\r\n((struct sockaddr_in *)src)->sin_addr =\r\n((struct sockaddr_in *)dst)->sin_addr;\r\n} else {\r\n((struct sockaddr_in6 *)src)->sin6_addr =\r\n((struct sockaddr_in6 *)dst)->sin6_addr;\r\n}\r\n}\r\nwork->id = id_priv;\r\nINIT_WORK(&work->work, cma_work_handler);\r\nwork->old_state = RDMA_CM_ADDR_QUERY;\r\nwork->new_state = RDMA_CM_ADDR_RESOLVED;\r\nwork->event.event = RDMA_CM_EVENT_ADDR_RESOLVED;\r\nqueue_work(cma_wq, &work->work);\r\nreturn 0;\r\nerr:\r\nkfree(work);\r\nreturn ret;\r\n}\r\nstatic int cma_bind_addr(struct rdma_cm_id *id, struct sockaddr *src_addr,\r\nstruct sockaddr *dst_addr)\r\n{\r\nif (!src_addr || !src_addr->sa_family) {\r\nsrc_addr = (struct sockaddr *) &id->route.addr.src_addr;\r\nif ((src_addr->sa_family = dst_addr->sa_family) == AF_INET6) {\r\n((struct sockaddr_in6 *) src_addr)->sin6_scope_id =\r\n((struct sockaddr_in6 *) dst_addr)->sin6_scope_id;\r\n}\r\n}\r\nreturn rdma_bind_addr(id, src_addr);\r\n}\r\nint rdma_resolve_addr(struct rdma_cm_id *id, struct sockaddr *src_addr,\r\nstruct sockaddr *dst_addr, int timeout_ms)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nint ret;\r\nid_priv = container_of(id, struct rdma_id_private, id);\r\nif (id_priv->state == RDMA_CM_IDLE) {\r\nret = cma_bind_addr(id, src_addr, dst_addr);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (!cma_comp_exch(id_priv, RDMA_CM_ADDR_BOUND, RDMA_CM_ADDR_QUERY))\r\nreturn -EINVAL;\r\natomic_inc(&id_priv->refcount);\r\nmemcpy(&id->route.addr.dst_addr, dst_addr, ip_addr_size(dst_addr));\r\nif (cma_any_addr(dst_addr))\r\nret = cma_resolve_loopback(id_priv);\r\nelse\r\nret = rdma_resolve_ip(&addr_client, (struct sockaddr *) &id->route.addr.src_addr,\r\ndst_addr, &id->route.addr.dev_addr,\r\ntimeout_ms, addr_handler, id_priv);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ncma_comp_exch(id_priv, RDMA_CM_ADDR_QUERY, RDMA_CM_ADDR_BOUND);\r\ncma_deref_id(id_priv);\r\nreturn ret;\r\n}\r\nint rdma_set_reuseaddr(struct rdma_cm_id *id, int reuse)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nunsigned long flags;\r\nint ret;\r\nid_priv = container_of(id, struct rdma_id_private, id);\r\nspin_lock_irqsave(&id_priv->lock, flags);\r\nif (id_priv->state == RDMA_CM_IDLE) {\r\nid_priv->reuseaddr = reuse;\r\nret = 0;\r\n} else {\r\nret = -EINVAL;\r\n}\r\nspin_unlock_irqrestore(&id_priv->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void cma_bind_port(struct rdma_bind_list *bind_list,\r\nstruct rdma_id_private *id_priv)\r\n{\r\nstruct sockaddr_in *sin;\r\nsin = (struct sockaddr_in *) &id_priv->id.route.addr.src_addr;\r\nsin->sin_port = htons(bind_list->port);\r\nid_priv->bind_list = bind_list;\r\nhlist_add_head(&id_priv->node, &bind_list->owners);\r\n}\r\nstatic int cma_alloc_port(struct idr *ps, struct rdma_id_private *id_priv,\r\nunsigned short snum)\r\n{\r\nstruct rdma_bind_list *bind_list;\r\nint port, ret;\r\nbind_list = kzalloc(sizeof *bind_list, GFP_KERNEL);\r\nif (!bind_list)\r\nreturn -ENOMEM;\r\ndo {\r\nret = idr_get_new_above(ps, bind_list, snum, &port);\r\n} while ((ret == -EAGAIN) && idr_pre_get(ps, GFP_KERNEL));\r\nif (ret)\r\ngoto err1;\r\nif (port != snum) {\r\nret = -EADDRNOTAVAIL;\r\ngoto err2;\r\n}\r\nbind_list->ps = ps;\r\nbind_list->port = (unsigned short) port;\r\ncma_bind_port(bind_list, id_priv);\r\nreturn 0;\r\nerr2:\r\nidr_remove(ps, port);\r\nerr1:\r\nkfree(bind_list);\r\nreturn ret;\r\n}\r\nstatic int cma_alloc_any_port(struct idr *ps, struct rdma_id_private *id_priv)\r\n{\r\nstatic unsigned int last_used_port;\r\nint low, high, remaining;\r\nunsigned int rover;\r\ninet_get_local_port_range(&low, &high);\r\nremaining = (high - low) + 1;\r\nrover = net_random() % remaining + low;\r\nretry:\r\nif (last_used_port != rover &&\r\n!idr_find(ps, (unsigned short) rover)) {\r\nint ret = cma_alloc_port(ps, id_priv, rover);\r\nif (!ret)\r\nlast_used_port = rover;\r\nif (ret != -EADDRNOTAVAIL)\r\nreturn ret;\r\n}\r\nif (--remaining) {\r\nrover++;\r\nif ((rover < low) || (rover > high))\r\nrover = low;\r\ngoto retry;\r\n}\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nstatic int cma_check_port(struct rdma_bind_list *bind_list,\r\nstruct rdma_id_private *id_priv, uint8_t reuseaddr)\r\n{\r\nstruct rdma_id_private *cur_id;\r\nstruct sockaddr *addr, *cur_addr;\r\nstruct hlist_node *node;\r\naddr = (struct sockaddr *) &id_priv->id.route.addr.src_addr;\r\nif (cma_any_addr(addr) && !reuseaddr)\r\nreturn -EADDRNOTAVAIL;\r\nhlist_for_each_entry(cur_id, node, &bind_list->owners, node) {\r\nif (id_priv == cur_id)\r\ncontinue;\r\nif ((cur_id->state == RDMA_CM_LISTEN) ||\r\n!reuseaddr || !cur_id->reuseaddr) {\r\ncur_addr = (struct sockaddr *) &cur_id->id.route.addr.src_addr;\r\nif (cma_any_addr(cur_addr))\r\nreturn -EADDRNOTAVAIL;\r\nif (!cma_addr_cmp(addr, cur_addr))\r\nreturn -EADDRINUSE;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cma_use_port(struct idr *ps, struct rdma_id_private *id_priv)\r\n{\r\nstruct rdma_bind_list *bind_list;\r\nunsigned short snum;\r\nint ret;\r\nsnum = ntohs(cma_port((struct sockaddr *) &id_priv->id.route.addr.src_addr));\r\nif (snum < PROT_SOCK && !capable(CAP_NET_BIND_SERVICE))\r\nreturn -EACCES;\r\nbind_list = idr_find(ps, snum);\r\nif (!bind_list) {\r\nret = cma_alloc_port(ps, id_priv, snum);\r\n} else {\r\nret = cma_check_port(bind_list, id_priv, id_priv->reuseaddr);\r\nif (!ret)\r\ncma_bind_port(bind_list, id_priv);\r\n}\r\nreturn ret;\r\n}\r\nstatic int cma_bind_listen(struct rdma_id_private *id_priv)\r\n{\r\nstruct rdma_bind_list *bind_list = id_priv->bind_list;\r\nint ret = 0;\r\nmutex_lock(&lock);\r\nif (bind_list->owners.first->next)\r\nret = cma_check_port(bind_list, id_priv, 0);\r\nmutex_unlock(&lock);\r\nreturn ret;\r\n}\r\nstatic int cma_get_port(struct rdma_id_private *id_priv)\r\n{\r\nstruct idr *ps;\r\nint ret;\r\nswitch (id_priv->id.ps) {\r\ncase RDMA_PS_SDP:\r\nps = &sdp_ps;\r\nbreak;\r\ncase RDMA_PS_TCP:\r\nps = &tcp_ps;\r\nbreak;\r\ncase RDMA_PS_UDP:\r\nps = &udp_ps;\r\nbreak;\r\ncase RDMA_PS_IPOIB:\r\nps = &ipoib_ps;\r\nbreak;\r\ncase RDMA_PS_IB:\r\nps = &ib_ps;\r\nbreak;\r\ndefault:\r\nreturn -EPROTONOSUPPORT;\r\n}\r\nmutex_lock(&lock);\r\nif (cma_any_port((struct sockaddr *) &id_priv->id.route.addr.src_addr))\r\nret = cma_alloc_any_port(ps, id_priv);\r\nelse\r\nret = cma_use_port(ps, id_priv);\r\nmutex_unlock(&lock);\r\nreturn ret;\r\n}\r\nstatic int cma_check_linklocal(struct rdma_dev_addr *dev_addr,\r\nstruct sockaddr *addr)\r\n{\r\n#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)\r\nstruct sockaddr_in6 *sin6;\r\nif (addr->sa_family != AF_INET6)\r\nreturn 0;\r\nsin6 = (struct sockaddr_in6 *) addr;\r\nif ((ipv6_addr_type(&sin6->sin6_addr) & IPV6_ADDR_LINKLOCAL) &&\r\n!sin6->sin6_scope_id)\r\nreturn -EINVAL;\r\ndev_addr->bound_dev_if = sin6->sin6_scope_id;\r\n#endif\r\nreturn 0;\r\n}\r\nint rdma_listen(struct rdma_cm_id *id, int backlog)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nint ret;\r\nid_priv = container_of(id, struct rdma_id_private, id);\r\nif (id_priv->state == RDMA_CM_IDLE) {\r\n((struct sockaddr *) &id->route.addr.src_addr)->sa_family = AF_INET;\r\nret = rdma_bind_addr(id, (struct sockaddr *) &id->route.addr.src_addr);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (!cma_comp_exch(id_priv, RDMA_CM_ADDR_BOUND, RDMA_CM_LISTEN))\r\nreturn -EINVAL;\r\nif (id_priv->reuseaddr) {\r\nret = cma_bind_listen(id_priv);\r\nif (ret)\r\ngoto err;\r\n}\r\nid_priv->backlog = backlog;\r\nif (id->device) {\r\nswitch (rdma_node_get_transport(id->device->node_type)) {\r\ncase RDMA_TRANSPORT_IB:\r\nret = cma_ib_listen(id_priv);\r\nif (ret)\r\ngoto err;\r\nbreak;\r\ncase RDMA_TRANSPORT_IWARP:\r\nret = cma_iw_listen(id_priv, backlog);\r\nif (ret)\r\ngoto err;\r\nbreak;\r\ndefault:\r\nret = -ENOSYS;\r\ngoto err;\r\n}\r\n} else\r\ncma_listen_on_all(id_priv);\r\nreturn 0;\r\nerr:\r\nid_priv->backlog = 0;\r\ncma_comp_exch(id_priv, RDMA_CM_LISTEN, RDMA_CM_ADDR_BOUND);\r\nreturn ret;\r\n}\r\nint rdma_bind_addr(struct rdma_cm_id *id, struct sockaddr *addr)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nint ret;\r\nif (addr->sa_family != AF_INET && addr->sa_family != AF_INET6)\r\nreturn -EAFNOSUPPORT;\r\nid_priv = container_of(id, struct rdma_id_private, id);\r\nif (!cma_comp_exch(id_priv, RDMA_CM_IDLE, RDMA_CM_ADDR_BOUND))\r\nreturn -EINVAL;\r\nret = cma_check_linklocal(&id->route.addr.dev_addr, addr);\r\nif (ret)\r\ngoto err1;\r\nif (!cma_any_addr(addr)) {\r\nret = rdma_translate_ip(addr, &id->route.addr.dev_addr);\r\nif (ret)\r\ngoto err1;\r\nret = cma_acquire_dev(id_priv);\r\nif (ret)\r\ngoto err1;\r\n}\r\nmemcpy(&id->route.addr.src_addr, addr, ip_addr_size(addr));\r\nret = cma_get_port(id_priv);\r\nif (ret)\r\ngoto err2;\r\nreturn 0;\r\nerr2:\r\nif (id_priv->cma_dev)\r\ncma_release_dev(id_priv);\r\nerr1:\r\ncma_comp_exch(id_priv, RDMA_CM_ADDR_BOUND, RDMA_CM_IDLE);\r\nreturn ret;\r\n}\r\nstatic int cma_format_hdr(void *hdr, enum rdma_port_space ps,\r\nstruct rdma_route *route)\r\n{\r\nstruct cma_hdr *cma_hdr;\r\nstruct sdp_hh *sdp_hdr;\r\nif (route->addr.src_addr.ss_family == AF_INET) {\r\nstruct sockaddr_in *src4, *dst4;\r\nsrc4 = (struct sockaddr_in *) &route->addr.src_addr;\r\ndst4 = (struct sockaddr_in *) &route->addr.dst_addr;\r\nswitch (ps) {\r\ncase RDMA_PS_SDP:\r\nsdp_hdr = hdr;\r\nif (sdp_get_majv(sdp_hdr->sdp_version) != SDP_MAJ_VERSION)\r\nreturn -EINVAL;\r\nsdp_set_ip_ver(sdp_hdr, 4);\r\nsdp_hdr->src_addr.ip4.addr = src4->sin_addr.s_addr;\r\nsdp_hdr->dst_addr.ip4.addr = dst4->sin_addr.s_addr;\r\nsdp_hdr->port = src4->sin_port;\r\nbreak;\r\ndefault:\r\ncma_hdr = hdr;\r\ncma_hdr->cma_version = CMA_VERSION;\r\ncma_set_ip_ver(cma_hdr, 4);\r\ncma_hdr->src_addr.ip4.addr = src4->sin_addr.s_addr;\r\ncma_hdr->dst_addr.ip4.addr = dst4->sin_addr.s_addr;\r\ncma_hdr->port = src4->sin_port;\r\nbreak;\r\n}\r\n} else {\r\nstruct sockaddr_in6 *src6, *dst6;\r\nsrc6 = (struct sockaddr_in6 *) &route->addr.src_addr;\r\ndst6 = (struct sockaddr_in6 *) &route->addr.dst_addr;\r\nswitch (ps) {\r\ncase RDMA_PS_SDP:\r\nsdp_hdr = hdr;\r\nif (sdp_get_majv(sdp_hdr->sdp_version) != SDP_MAJ_VERSION)\r\nreturn -EINVAL;\r\nsdp_set_ip_ver(sdp_hdr, 6);\r\nsdp_hdr->src_addr.ip6 = src6->sin6_addr;\r\nsdp_hdr->dst_addr.ip6 = dst6->sin6_addr;\r\nsdp_hdr->port = src6->sin6_port;\r\nbreak;\r\ndefault:\r\ncma_hdr = hdr;\r\ncma_hdr->cma_version = CMA_VERSION;\r\ncma_set_ip_ver(cma_hdr, 6);\r\ncma_hdr->src_addr.ip6 = src6->sin6_addr;\r\ncma_hdr->dst_addr.ip6 = dst6->sin6_addr;\r\ncma_hdr->port = src6->sin6_port;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cma_sidr_rep_handler(struct ib_cm_id *cm_id,\r\nstruct ib_cm_event *ib_event)\r\n{\r\nstruct rdma_id_private *id_priv = cm_id->context;\r\nstruct rdma_cm_event event;\r\nstruct ib_cm_sidr_rep_event_param *rep = &ib_event->param.sidr_rep_rcvd;\r\nint ret = 0;\r\nif (cma_disable_callback(id_priv, RDMA_CM_CONNECT))\r\nreturn 0;\r\nmemset(&event, 0, sizeof event);\r\nswitch (ib_event->event) {\r\ncase IB_CM_SIDR_REQ_ERROR:\r\nevent.event = RDMA_CM_EVENT_UNREACHABLE;\r\nevent.status = -ETIMEDOUT;\r\nbreak;\r\ncase IB_CM_SIDR_REP_RECEIVED:\r\nevent.param.ud.private_data = ib_event->private_data;\r\nevent.param.ud.private_data_len = IB_CM_SIDR_REP_PRIVATE_DATA_SIZE;\r\nif (rep->status != IB_SIDR_SUCCESS) {\r\nevent.event = RDMA_CM_EVENT_UNREACHABLE;\r\nevent.status = ib_event->param.sidr_rep_rcvd.status;\r\nbreak;\r\n}\r\nret = cma_set_qkey(id_priv);\r\nif (ret) {\r\nevent.event = RDMA_CM_EVENT_ADDR_ERROR;\r\nevent.status = -EINVAL;\r\nbreak;\r\n}\r\nif (id_priv->qkey != rep->qkey) {\r\nevent.event = RDMA_CM_EVENT_UNREACHABLE;\r\nevent.status = -EINVAL;\r\nbreak;\r\n}\r\nib_init_ah_from_path(id_priv->id.device, id_priv->id.port_num,\r\nid_priv->id.route.path_rec,\r\n&event.param.ud.ah_attr);\r\nevent.param.ud.qp_num = rep->qpn;\r\nevent.param.ud.qkey = rep->qkey;\r\nevent.event = RDMA_CM_EVENT_ESTABLISHED;\r\nevent.status = 0;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "RDMA CMA: unexpected IB CM event: %d\n",\r\nib_event->event);\r\ngoto out;\r\n}\r\nret = id_priv->id.event_handler(&id_priv->id, &event);\r\nif (ret) {\r\nid_priv->cm_id.ib = NULL;\r\ncma_exch(id_priv, RDMA_CM_DESTROYING);\r\nmutex_unlock(&id_priv->handler_mutex);\r\nrdma_destroy_id(&id_priv->id);\r\nreturn ret;\r\n}\r\nout:\r\nmutex_unlock(&id_priv->handler_mutex);\r\nreturn ret;\r\n}\r\nstatic int cma_resolve_ib_udp(struct rdma_id_private *id_priv,\r\nstruct rdma_conn_param *conn_param)\r\n{\r\nstruct ib_cm_sidr_req_param req;\r\nstruct rdma_route *route;\r\nstruct ib_cm_id *id;\r\nint ret;\r\nreq.private_data_len = sizeof(struct cma_hdr) +\r\nconn_param->private_data_len;\r\nif (req.private_data_len < conn_param->private_data_len)\r\nreturn -EINVAL;\r\nreq.private_data = kzalloc(req.private_data_len, GFP_ATOMIC);\r\nif (!req.private_data)\r\nreturn -ENOMEM;\r\nif (conn_param->private_data && conn_param->private_data_len)\r\nmemcpy((void *) req.private_data + sizeof(struct cma_hdr),\r\nconn_param->private_data, conn_param->private_data_len);\r\nroute = &id_priv->id.route;\r\nret = cma_format_hdr((void *) req.private_data, id_priv->id.ps, route);\r\nif (ret)\r\ngoto out;\r\nid = ib_create_cm_id(id_priv->id.device, cma_sidr_rep_handler,\r\nid_priv);\r\nif (IS_ERR(id)) {\r\nret = PTR_ERR(id);\r\ngoto out;\r\n}\r\nid_priv->cm_id.ib = id;\r\nreq.path = route->path_rec;\r\nreq.service_id = cma_get_service_id(id_priv->id.ps,\r\n(struct sockaddr *) &route->addr.dst_addr);\r\nreq.timeout_ms = 1 << (CMA_CM_RESPONSE_TIMEOUT - 8);\r\nreq.max_cm_retries = CMA_MAX_CM_RETRIES;\r\nret = ib_send_cm_sidr_req(id_priv->cm_id.ib, &req);\r\nif (ret) {\r\nib_destroy_cm_id(id_priv->cm_id.ib);\r\nid_priv->cm_id.ib = NULL;\r\n}\r\nout:\r\nkfree(req.private_data);\r\nreturn ret;\r\n}\r\nstatic int cma_connect_ib(struct rdma_id_private *id_priv,\r\nstruct rdma_conn_param *conn_param)\r\n{\r\nstruct ib_cm_req_param req;\r\nstruct rdma_route *route;\r\nvoid *private_data;\r\nstruct ib_cm_id *id;\r\nint offset, ret;\r\nmemset(&req, 0, sizeof req);\r\noffset = cma_user_data_offset(id_priv->id.ps);\r\nreq.private_data_len = offset + conn_param->private_data_len;\r\nif (req.private_data_len < conn_param->private_data_len)\r\nreturn -EINVAL;\r\nprivate_data = kzalloc(req.private_data_len, GFP_ATOMIC);\r\nif (!private_data)\r\nreturn -ENOMEM;\r\nif (conn_param->private_data && conn_param->private_data_len)\r\nmemcpy(private_data + offset, conn_param->private_data,\r\nconn_param->private_data_len);\r\nid = ib_create_cm_id(id_priv->id.device, cma_ib_handler, id_priv);\r\nif (IS_ERR(id)) {\r\nret = PTR_ERR(id);\r\ngoto out;\r\n}\r\nid_priv->cm_id.ib = id;\r\nroute = &id_priv->id.route;\r\nret = cma_format_hdr(private_data, id_priv->id.ps, route);\r\nif (ret)\r\ngoto out;\r\nreq.private_data = private_data;\r\nreq.primary_path = &route->path_rec[0];\r\nif (route->num_paths == 2)\r\nreq.alternate_path = &route->path_rec[1];\r\nreq.service_id = cma_get_service_id(id_priv->id.ps,\r\n(struct sockaddr *) &route->addr.dst_addr);\r\nreq.qp_num = id_priv->qp_num;\r\nreq.qp_type = id_priv->id.qp_type;\r\nreq.starting_psn = id_priv->seq_num;\r\nreq.responder_resources = conn_param->responder_resources;\r\nreq.initiator_depth = conn_param->initiator_depth;\r\nreq.flow_control = conn_param->flow_control;\r\nreq.retry_count = conn_param->retry_count;\r\nreq.rnr_retry_count = conn_param->rnr_retry_count;\r\nreq.remote_cm_response_timeout = CMA_CM_RESPONSE_TIMEOUT;\r\nreq.local_cm_response_timeout = CMA_CM_RESPONSE_TIMEOUT;\r\nreq.max_cm_retries = CMA_MAX_CM_RETRIES;\r\nreq.srq = id_priv->srq ? 1 : 0;\r\nret = ib_send_cm_req(id_priv->cm_id.ib, &req);\r\nout:\r\nif (ret && !IS_ERR(id)) {\r\nib_destroy_cm_id(id);\r\nid_priv->cm_id.ib = NULL;\r\n}\r\nkfree(private_data);\r\nreturn ret;\r\n}\r\nstatic int cma_connect_iw(struct rdma_id_private *id_priv,\r\nstruct rdma_conn_param *conn_param)\r\n{\r\nstruct iw_cm_id *cm_id;\r\nstruct sockaddr_in* sin;\r\nint ret;\r\nstruct iw_cm_conn_param iw_param;\r\ncm_id = iw_create_cm_id(id_priv->id.device, cma_iw_handler, id_priv);\r\nif (IS_ERR(cm_id))\r\nreturn PTR_ERR(cm_id);\r\nid_priv->cm_id.iw = cm_id;\r\nsin = (struct sockaddr_in*) &id_priv->id.route.addr.src_addr;\r\ncm_id->local_addr = *sin;\r\nsin = (struct sockaddr_in*) &id_priv->id.route.addr.dst_addr;\r\ncm_id->remote_addr = *sin;\r\nret = cma_modify_qp_rtr(id_priv, conn_param);\r\nif (ret)\r\ngoto out;\r\nif (conn_param) {\r\niw_param.ord = conn_param->initiator_depth;\r\niw_param.ird = conn_param->responder_resources;\r\niw_param.private_data = conn_param->private_data;\r\niw_param.private_data_len = conn_param->private_data_len;\r\niw_param.qpn = id_priv->id.qp ? id_priv->qp_num : conn_param->qp_num;\r\n} else {\r\nmemset(&iw_param, 0, sizeof iw_param);\r\niw_param.qpn = id_priv->qp_num;\r\n}\r\nret = iw_cm_connect(cm_id, &iw_param);\r\nout:\r\nif (ret) {\r\niw_destroy_cm_id(cm_id);\r\nid_priv->cm_id.iw = NULL;\r\n}\r\nreturn ret;\r\n}\r\nint rdma_connect(struct rdma_cm_id *id, struct rdma_conn_param *conn_param)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nint ret;\r\nid_priv = container_of(id, struct rdma_id_private, id);\r\nif (!cma_comp_exch(id_priv, RDMA_CM_ROUTE_RESOLVED, RDMA_CM_CONNECT))\r\nreturn -EINVAL;\r\nif (!id->qp) {\r\nid_priv->qp_num = conn_param->qp_num;\r\nid_priv->srq = conn_param->srq;\r\n}\r\nswitch (rdma_node_get_transport(id->device->node_type)) {\r\ncase RDMA_TRANSPORT_IB:\r\nif (id->qp_type == IB_QPT_UD)\r\nret = cma_resolve_ib_udp(id_priv, conn_param);\r\nelse\r\nret = cma_connect_ib(id_priv, conn_param);\r\nbreak;\r\ncase RDMA_TRANSPORT_IWARP:\r\nret = cma_connect_iw(id_priv, conn_param);\r\nbreak;\r\ndefault:\r\nret = -ENOSYS;\r\nbreak;\r\n}\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ncma_comp_exch(id_priv, RDMA_CM_CONNECT, RDMA_CM_ROUTE_RESOLVED);\r\nreturn ret;\r\n}\r\nstatic int cma_accept_ib(struct rdma_id_private *id_priv,\r\nstruct rdma_conn_param *conn_param)\r\n{\r\nstruct ib_cm_rep_param rep;\r\nint ret;\r\nret = cma_modify_qp_rtr(id_priv, conn_param);\r\nif (ret)\r\ngoto out;\r\nret = cma_modify_qp_rts(id_priv, conn_param);\r\nif (ret)\r\ngoto out;\r\nmemset(&rep, 0, sizeof rep);\r\nrep.qp_num = id_priv->qp_num;\r\nrep.starting_psn = id_priv->seq_num;\r\nrep.private_data = conn_param->private_data;\r\nrep.private_data_len = conn_param->private_data_len;\r\nrep.responder_resources = conn_param->responder_resources;\r\nrep.initiator_depth = conn_param->initiator_depth;\r\nrep.failover_accepted = 0;\r\nrep.flow_control = conn_param->flow_control;\r\nrep.rnr_retry_count = conn_param->rnr_retry_count;\r\nrep.srq = id_priv->srq ? 1 : 0;\r\nret = ib_send_cm_rep(id_priv->cm_id.ib, &rep);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int cma_accept_iw(struct rdma_id_private *id_priv,\r\nstruct rdma_conn_param *conn_param)\r\n{\r\nstruct iw_cm_conn_param iw_param;\r\nint ret;\r\nret = cma_modify_qp_rtr(id_priv, conn_param);\r\nif (ret)\r\nreturn ret;\r\niw_param.ord = conn_param->initiator_depth;\r\niw_param.ird = conn_param->responder_resources;\r\niw_param.private_data = conn_param->private_data;\r\niw_param.private_data_len = conn_param->private_data_len;\r\nif (id_priv->id.qp) {\r\niw_param.qpn = id_priv->qp_num;\r\n} else\r\niw_param.qpn = conn_param->qp_num;\r\nreturn iw_cm_accept(id_priv->cm_id.iw, &iw_param);\r\n}\r\nstatic int cma_send_sidr_rep(struct rdma_id_private *id_priv,\r\nenum ib_cm_sidr_status status,\r\nconst void *private_data, int private_data_len)\r\n{\r\nstruct ib_cm_sidr_rep_param rep;\r\nint ret;\r\nmemset(&rep, 0, sizeof rep);\r\nrep.status = status;\r\nif (status == IB_SIDR_SUCCESS) {\r\nret = cma_set_qkey(id_priv);\r\nif (ret)\r\nreturn ret;\r\nrep.qp_num = id_priv->qp_num;\r\nrep.qkey = id_priv->qkey;\r\n}\r\nrep.private_data = private_data;\r\nrep.private_data_len = private_data_len;\r\nreturn ib_send_cm_sidr_rep(id_priv->cm_id.ib, &rep);\r\n}\r\nint rdma_accept(struct rdma_cm_id *id, struct rdma_conn_param *conn_param)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nint ret;\r\nid_priv = container_of(id, struct rdma_id_private, id);\r\nid_priv->owner = task_pid_nr(current);\r\nif (!cma_comp(id_priv, RDMA_CM_CONNECT))\r\nreturn -EINVAL;\r\nif (!id->qp && conn_param) {\r\nid_priv->qp_num = conn_param->qp_num;\r\nid_priv->srq = conn_param->srq;\r\n}\r\nswitch (rdma_node_get_transport(id->device->node_type)) {\r\ncase RDMA_TRANSPORT_IB:\r\nif (id->qp_type == IB_QPT_UD) {\r\nif (conn_param)\r\nret = cma_send_sidr_rep(id_priv, IB_SIDR_SUCCESS,\r\nconn_param->private_data,\r\nconn_param->private_data_len);\r\nelse\r\nret = cma_send_sidr_rep(id_priv, IB_SIDR_SUCCESS,\r\nNULL, 0);\r\n} else {\r\nif (conn_param)\r\nret = cma_accept_ib(id_priv, conn_param);\r\nelse\r\nret = cma_rep_recv(id_priv);\r\n}\r\nbreak;\r\ncase RDMA_TRANSPORT_IWARP:\r\nret = cma_accept_iw(id_priv, conn_param);\r\nbreak;\r\ndefault:\r\nret = -ENOSYS;\r\nbreak;\r\n}\r\nif (ret)\r\ngoto reject;\r\nreturn 0;\r\nreject:\r\ncma_modify_qp_err(id_priv);\r\nrdma_reject(id, NULL, 0);\r\nreturn ret;\r\n}\r\nint rdma_notify(struct rdma_cm_id *id, enum ib_event_type event)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nint ret;\r\nid_priv = container_of(id, struct rdma_id_private, id);\r\nif (!id_priv->cm_id.ib)\r\nreturn -EINVAL;\r\nswitch (id->device->node_type) {\r\ncase RDMA_NODE_IB_CA:\r\nret = ib_cm_notify(id_priv->cm_id.ib, event);\r\nbreak;\r\ndefault:\r\nret = 0;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint rdma_reject(struct rdma_cm_id *id, const void *private_data,\r\nu8 private_data_len)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nint ret;\r\nid_priv = container_of(id, struct rdma_id_private, id);\r\nif (!id_priv->cm_id.ib)\r\nreturn -EINVAL;\r\nswitch (rdma_node_get_transport(id->device->node_type)) {\r\ncase RDMA_TRANSPORT_IB:\r\nif (id->qp_type == IB_QPT_UD)\r\nret = cma_send_sidr_rep(id_priv, IB_SIDR_REJECT,\r\nprivate_data, private_data_len);\r\nelse\r\nret = ib_send_cm_rej(id_priv->cm_id.ib,\r\nIB_CM_REJ_CONSUMER_DEFINED, NULL,\r\n0, private_data, private_data_len);\r\nbreak;\r\ncase RDMA_TRANSPORT_IWARP:\r\nret = iw_cm_reject(id_priv->cm_id.iw,\r\nprivate_data, private_data_len);\r\nbreak;\r\ndefault:\r\nret = -ENOSYS;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint rdma_disconnect(struct rdma_cm_id *id)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nint ret;\r\nid_priv = container_of(id, struct rdma_id_private, id);\r\nif (!id_priv->cm_id.ib)\r\nreturn -EINVAL;\r\nswitch (rdma_node_get_transport(id->device->node_type)) {\r\ncase RDMA_TRANSPORT_IB:\r\nret = cma_modify_qp_err(id_priv);\r\nif (ret)\r\ngoto out;\r\nif (ib_send_cm_dreq(id_priv->cm_id.ib, NULL, 0))\r\nib_send_cm_drep(id_priv->cm_id.ib, NULL, 0);\r\nbreak;\r\ncase RDMA_TRANSPORT_IWARP:\r\nret = iw_cm_disconnect(id_priv->cm_id.iw, 0);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int cma_ib_mc_handler(int status, struct ib_sa_multicast *multicast)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nstruct cma_multicast *mc = multicast->context;\r\nstruct rdma_cm_event event;\r\nint ret;\r\nid_priv = mc->id_priv;\r\nif (cma_disable_callback(id_priv, RDMA_CM_ADDR_BOUND) &&\r\ncma_disable_callback(id_priv, RDMA_CM_ADDR_RESOLVED))\r\nreturn 0;\r\nmutex_lock(&id_priv->qp_mutex);\r\nif (!status && id_priv->id.qp)\r\nstatus = ib_attach_mcast(id_priv->id.qp, &multicast->rec.mgid,\r\nbe16_to_cpu(multicast->rec.mlid));\r\nmutex_unlock(&id_priv->qp_mutex);\r\nmemset(&event, 0, sizeof event);\r\nevent.status = status;\r\nevent.param.ud.private_data = mc->context;\r\nif (!status) {\r\nevent.event = RDMA_CM_EVENT_MULTICAST_JOIN;\r\nib_init_ah_from_mcmember(id_priv->id.device,\r\nid_priv->id.port_num, &multicast->rec,\r\n&event.param.ud.ah_attr);\r\nevent.param.ud.qp_num = 0xFFFFFF;\r\nevent.param.ud.qkey = be32_to_cpu(multicast->rec.qkey);\r\n} else\r\nevent.event = RDMA_CM_EVENT_MULTICAST_ERROR;\r\nret = id_priv->id.event_handler(&id_priv->id, &event);\r\nif (ret) {\r\ncma_exch(id_priv, RDMA_CM_DESTROYING);\r\nmutex_unlock(&id_priv->handler_mutex);\r\nrdma_destroy_id(&id_priv->id);\r\nreturn 0;\r\n}\r\nmutex_unlock(&id_priv->handler_mutex);\r\nreturn 0;\r\n}\r\nstatic void cma_set_mgid(struct rdma_id_private *id_priv,\r\nstruct sockaddr *addr, union ib_gid *mgid)\r\n{\r\nunsigned char mc_map[MAX_ADDR_LEN];\r\nstruct rdma_dev_addr *dev_addr = &id_priv->id.route.addr.dev_addr;\r\nstruct sockaddr_in *sin = (struct sockaddr_in *) addr;\r\nstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *) addr;\r\nif (cma_any_addr(addr)) {\r\nmemset(mgid, 0, sizeof *mgid);\r\n} else if ((addr->sa_family == AF_INET6) &&\r\n((be32_to_cpu(sin6->sin6_addr.s6_addr32[0]) & 0xFFF0FFFF) ==\r\n0xFF10A01B)) {\r\nmemcpy(mgid, &sin6->sin6_addr, sizeof *mgid);\r\n} else if ((addr->sa_family == AF_INET6)) {\r\nipv6_ib_mc_map(&sin6->sin6_addr, dev_addr->broadcast, mc_map);\r\nif (id_priv->id.ps == RDMA_PS_UDP)\r\nmc_map[7] = 0x01;\r\n*mgid = *(union ib_gid *) (mc_map + 4);\r\n} else {\r\nip_ib_mc_map(sin->sin_addr.s_addr, dev_addr->broadcast, mc_map);\r\nif (id_priv->id.ps == RDMA_PS_UDP)\r\nmc_map[7] = 0x01;\r\n*mgid = *(union ib_gid *) (mc_map + 4);\r\n}\r\n}\r\nstatic int cma_join_ib_multicast(struct rdma_id_private *id_priv,\r\nstruct cma_multicast *mc)\r\n{\r\nstruct ib_sa_mcmember_rec rec;\r\nstruct rdma_dev_addr *dev_addr = &id_priv->id.route.addr.dev_addr;\r\nib_sa_comp_mask comp_mask;\r\nint ret;\r\nib_addr_get_mgid(dev_addr, &rec.mgid);\r\nret = ib_sa_get_mcmember_rec(id_priv->id.device, id_priv->id.port_num,\r\n&rec.mgid, &rec);\r\nif (ret)\r\nreturn ret;\r\ncma_set_mgid(id_priv, (struct sockaddr *) &mc->addr, &rec.mgid);\r\nif (id_priv->id.ps == RDMA_PS_UDP)\r\nrec.qkey = cpu_to_be32(RDMA_UDP_QKEY);\r\nrdma_addr_get_sgid(dev_addr, &rec.port_gid);\r\nrec.pkey = cpu_to_be16(ib_addr_get_pkey(dev_addr));\r\nrec.join_state = 1;\r\ncomp_mask = IB_SA_MCMEMBER_REC_MGID | IB_SA_MCMEMBER_REC_PORT_GID |\r\nIB_SA_MCMEMBER_REC_PKEY | IB_SA_MCMEMBER_REC_JOIN_STATE |\r\nIB_SA_MCMEMBER_REC_QKEY | IB_SA_MCMEMBER_REC_SL |\r\nIB_SA_MCMEMBER_REC_FLOW_LABEL |\r\nIB_SA_MCMEMBER_REC_TRAFFIC_CLASS;\r\nif (id_priv->id.ps == RDMA_PS_IPOIB)\r\ncomp_mask |= IB_SA_MCMEMBER_REC_RATE |\r\nIB_SA_MCMEMBER_REC_RATE_SELECTOR;\r\nmc->multicast.ib = ib_sa_join_multicast(&sa_client, id_priv->id.device,\r\nid_priv->id.port_num, &rec,\r\ncomp_mask, GFP_KERNEL,\r\ncma_ib_mc_handler, mc);\r\nif (IS_ERR(mc->multicast.ib))\r\nreturn PTR_ERR(mc->multicast.ib);\r\nreturn 0;\r\n}\r\nstatic void iboe_mcast_work_handler(struct work_struct *work)\r\n{\r\nstruct iboe_mcast_work *mw = container_of(work, struct iboe_mcast_work, work);\r\nstruct cma_multicast *mc = mw->mc;\r\nstruct ib_sa_multicast *m = mc->multicast.ib;\r\nmc->multicast.ib->context = mc;\r\ncma_ib_mc_handler(0, m);\r\nkref_put(&mc->mcref, release_mc);\r\nkfree(mw);\r\n}\r\nstatic void cma_iboe_set_mgid(struct sockaddr *addr, union ib_gid *mgid)\r\n{\r\nstruct sockaddr_in *sin = (struct sockaddr_in *)addr;\r\nstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)addr;\r\nif (cma_any_addr(addr)) {\r\nmemset(mgid, 0, sizeof *mgid);\r\n} else if (addr->sa_family == AF_INET6) {\r\nmemcpy(mgid, &sin6->sin6_addr, sizeof *mgid);\r\n} else {\r\nmgid->raw[0] = 0xff;\r\nmgid->raw[1] = 0x0e;\r\nmgid->raw[2] = 0;\r\nmgid->raw[3] = 0;\r\nmgid->raw[4] = 0;\r\nmgid->raw[5] = 0;\r\nmgid->raw[6] = 0;\r\nmgid->raw[7] = 0;\r\nmgid->raw[8] = 0;\r\nmgid->raw[9] = 0;\r\nmgid->raw[10] = 0xff;\r\nmgid->raw[11] = 0xff;\r\n*(__be32 *)(&mgid->raw[12]) = sin->sin_addr.s_addr;\r\n}\r\n}\r\nstatic int cma_iboe_join_multicast(struct rdma_id_private *id_priv,\r\nstruct cma_multicast *mc)\r\n{\r\nstruct iboe_mcast_work *work;\r\nstruct rdma_dev_addr *dev_addr = &id_priv->id.route.addr.dev_addr;\r\nint err;\r\nstruct sockaddr *addr = (struct sockaddr *)&mc->addr;\r\nstruct net_device *ndev = NULL;\r\nif (cma_zero_addr((struct sockaddr *)&mc->addr))\r\nreturn -EINVAL;\r\nwork = kzalloc(sizeof *work, GFP_KERNEL);\r\nif (!work)\r\nreturn -ENOMEM;\r\nmc->multicast.ib = kzalloc(sizeof(struct ib_sa_multicast), GFP_KERNEL);\r\nif (!mc->multicast.ib) {\r\nerr = -ENOMEM;\r\ngoto out1;\r\n}\r\ncma_iboe_set_mgid(addr, &mc->multicast.ib->rec.mgid);\r\nmc->multicast.ib->rec.pkey = cpu_to_be16(0xffff);\r\nif (id_priv->id.ps == RDMA_PS_UDP)\r\nmc->multicast.ib->rec.qkey = cpu_to_be32(RDMA_UDP_QKEY);\r\nif (dev_addr->bound_dev_if)\r\nndev = dev_get_by_index(&init_net, dev_addr->bound_dev_if);\r\nif (!ndev) {\r\nerr = -ENODEV;\r\ngoto out2;\r\n}\r\nmc->multicast.ib->rec.rate = iboe_get_rate(ndev);\r\nmc->multicast.ib->rec.hop_limit = 1;\r\nmc->multicast.ib->rec.mtu = iboe_get_mtu(ndev->mtu);\r\ndev_put(ndev);\r\nif (!mc->multicast.ib->rec.mtu) {\r\nerr = -EINVAL;\r\ngoto out2;\r\n}\r\niboe_addr_get_sgid(dev_addr, &mc->multicast.ib->rec.port_gid);\r\nwork->id = id_priv;\r\nwork->mc = mc;\r\nINIT_WORK(&work->work, iboe_mcast_work_handler);\r\nkref_get(&mc->mcref);\r\nqueue_work(cma_wq, &work->work);\r\nreturn 0;\r\nout2:\r\nkfree(mc->multicast.ib);\r\nout1:\r\nkfree(work);\r\nreturn err;\r\n}\r\nint rdma_join_multicast(struct rdma_cm_id *id, struct sockaddr *addr,\r\nvoid *context)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nstruct cma_multicast *mc;\r\nint ret;\r\nid_priv = container_of(id, struct rdma_id_private, id);\r\nif (!cma_comp(id_priv, RDMA_CM_ADDR_BOUND) &&\r\n!cma_comp(id_priv, RDMA_CM_ADDR_RESOLVED))\r\nreturn -EINVAL;\r\nmc = kmalloc(sizeof *mc, GFP_KERNEL);\r\nif (!mc)\r\nreturn -ENOMEM;\r\nmemcpy(&mc->addr, addr, ip_addr_size(addr));\r\nmc->context = context;\r\nmc->id_priv = id_priv;\r\nspin_lock(&id_priv->lock);\r\nlist_add(&mc->list, &id_priv->mc_list);\r\nspin_unlock(&id_priv->lock);\r\nswitch (rdma_node_get_transport(id->device->node_type)) {\r\ncase RDMA_TRANSPORT_IB:\r\nswitch (rdma_port_get_link_layer(id->device, id->port_num)) {\r\ncase IB_LINK_LAYER_INFINIBAND:\r\nret = cma_join_ib_multicast(id_priv, mc);\r\nbreak;\r\ncase IB_LINK_LAYER_ETHERNET:\r\nkref_init(&mc->mcref);\r\nret = cma_iboe_join_multicast(id_priv, mc);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nret = -ENOSYS;\r\nbreak;\r\n}\r\nif (ret) {\r\nspin_lock_irq(&id_priv->lock);\r\nlist_del(&mc->list);\r\nspin_unlock_irq(&id_priv->lock);\r\nkfree(mc);\r\n}\r\nreturn ret;\r\n}\r\nvoid rdma_leave_multicast(struct rdma_cm_id *id, struct sockaddr *addr)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nstruct cma_multicast *mc;\r\nid_priv = container_of(id, struct rdma_id_private, id);\r\nspin_lock_irq(&id_priv->lock);\r\nlist_for_each_entry(mc, &id_priv->mc_list, list) {\r\nif (!memcmp(&mc->addr, addr, ip_addr_size(addr))) {\r\nlist_del(&mc->list);\r\nspin_unlock_irq(&id_priv->lock);\r\nif (id->qp)\r\nib_detach_mcast(id->qp,\r\n&mc->multicast.ib->rec.mgid,\r\nbe16_to_cpu(mc->multicast.ib->rec.mlid));\r\nif (rdma_node_get_transport(id_priv->cma_dev->device->node_type) == RDMA_TRANSPORT_IB) {\r\nswitch (rdma_port_get_link_layer(id->device, id->port_num)) {\r\ncase IB_LINK_LAYER_INFINIBAND:\r\nib_sa_free_multicast(mc->multicast.ib);\r\nkfree(mc);\r\nbreak;\r\ncase IB_LINK_LAYER_ETHERNET:\r\nkref_put(&mc->mcref, release_mc);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn;\r\n}\r\n}\r\nspin_unlock_irq(&id_priv->lock);\r\n}\r\nstatic int cma_netdev_change(struct net_device *ndev, struct rdma_id_private *id_priv)\r\n{\r\nstruct rdma_dev_addr *dev_addr;\r\nstruct cma_ndev_work *work;\r\ndev_addr = &id_priv->id.route.addr.dev_addr;\r\nif ((dev_addr->bound_dev_if == ndev->ifindex) &&\r\nmemcmp(dev_addr->src_dev_addr, ndev->dev_addr, ndev->addr_len)) {\r\nprintk(KERN_INFO "RDMA CM addr change for ndev %s used by id %p\n",\r\nndev->name, &id_priv->id);\r\nwork = kzalloc(sizeof *work, GFP_KERNEL);\r\nif (!work)\r\nreturn -ENOMEM;\r\nINIT_WORK(&work->work, cma_ndev_work_handler);\r\nwork->id = id_priv;\r\nwork->event.event = RDMA_CM_EVENT_ADDR_CHANGE;\r\natomic_inc(&id_priv->refcount);\r\nqueue_work(cma_wq, &work->work);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cma_netdev_callback(struct notifier_block *self, unsigned long event,\r\nvoid *ctx)\r\n{\r\nstruct net_device *ndev = (struct net_device *)ctx;\r\nstruct cma_device *cma_dev;\r\nstruct rdma_id_private *id_priv;\r\nint ret = NOTIFY_DONE;\r\nif (dev_net(ndev) != &init_net)\r\nreturn NOTIFY_DONE;\r\nif (event != NETDEV_BONDING_FAILOVER)\r\nreturn NOTIFY_DONE;\r\nif (!(ndev->flags & IFF_MASTER) || !(ndev->priv_flags & IFF_BONDING))\r\nreturn NOTIFY_DONE;\r\nmutex_lock(&lock);\r\nlist_for_each_entry(cma_dev, &dev_list, list)\r\nlist_for_each_entry(id_priv, &cma_dev->id_list, list) {\r\nret = cma_netdev_change(ndev, id_priv);\r\nif (ret)\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&lock);\r\nreturn ret;\r\n}\r\nstatic void cma_add_one(struct ib_device *device)\r\n{\r\nstruct cma_device *cma_dev;\r\nstruct rdma_id_private *id_priv;\r\ncma_dev = kmalloc(sizeof *cma_dev, GFP_KERNEL);\r\nif (!cma_dev)\r\nreturn;\r\ncma_dev->device = device;\r\ninit_completion(&cma_dev->comp);\r\natomic_set(&cma_dev->refcount, 1);\r\nINIT_LIST_HEAD(&cma_dev->id_list);\r\nib_set_client_data(device, &cma_client, cma_dev);\r\nmutex_lock(&lock);\r\nlist_add_tail(&cma_dev->list, &dev_list);\r\nlist_for_each_entry(id_priv, &listen_any_list, list)\r\ncma_listen_on_dev(id_priv, cma_dev);\r\nmutex_unlock(&lock);\r\n}\r\nstatic int cma_remove_id_dev(struct rdma_id_private *id_priv)\r\n{\r\nstruct rdma_cm_event event;\r\nenum rdma_cm_state state;\r\nint ret = 0;\r\nstate = cma_exch(id_priv, RDMA_CM_DEVICE_REMOVAL);\r\nif (state == RDMA_CM_DESTROYING)\r\nreturn 0;\r\ncma_cancel_operation(id_priv, state);\r\nmutex_lock(&id_priv->handler_mutex);\r\nif (!cma_comp(id_priv, RDMA_CM_DEVICE_REMOVAL))\r\ngoto out;\r\nmemset(&event, 0, sizeof event);\r\nevent.event = RDMA_CM_EVENT_DEVICE_REMOVAL;\r\nret = id_priv->id.event_handler(&id_priv->id, &event);\r\nout:\r\nmutex_unlock(&id_priv->handler_mutex);\r\nreturn ret;\r\n}\r\nstatic void cma_process_remove(struct cma_device *cma_dev)\r\n{\r\nstruct rdma_id_private *id_priv;\r\nint ret;\r\nmutex_lock(&lock);\r\nwhile (!list_empty(&cma_dev->id_list)) {\r\nid_priv = list_entry(cma_dev->id_list.next,\r\nstruct rdma_id_private, list);\r\nlist_del(&id_priv->listen_list);\r\nlist_del_init(&id_priv->list);\r\natomic_inc(&id_priv->refcount);\r\nmutex_unlock(&lock);\r\nret = id_priv->internal_id ? 1 : cma_remove_id_dev(id_priv);\r\ncma_deref_id(id_priv);\r\nif (ret)\r\nrdma_destroy_id(&id_priv->id);\r\nmutex_lock(&lock);\r\n}\r\nmutex_unlock(&lock);\r\ncma_deref_dev(cma_dev);\r\nwait_for_completion(&cma_dev->comp);\r\n}\r\nstatic void cma_remove_one(struct ib_device *device)\r\n{\r\nstruct cma_device *cma_dev;\r\ncma_dev = ib_get_client_data(device, &cma_client);\r\nif (!cma_dev)\r\nreturn;\r\nmutex_lock(&lock);\r\nlist_del(&cma_dev->list);\r\nmutex_unlock(&lock);\r\ncma_process_remove(cma_dev);\r\nkfree(cma_dev);\r\n}\r\nstatic int cma_get_id_stats(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct nlmsghdr *nlh;\r\nstruct rdma_cm_id_stats *id_stats;\r\nstruct rdma_id_private *id_priv;\r\nstruct rdma_cm_id *id = NULL;\r\nstruct cma_device *cma_dev;\r\nint i_dev = 0, i_id = 0;\r\nmutex_lock(&lock);\r\nlist_for_each_entry(cma_dev, &dev_list, list) {\r\nif (i_dev < cb->args[0]) {\r\ni_dev++;\r\ncontinue;\r\n}\r\ni_id = 0;\r\nlist_for_each_entry(id_priv, &cma_dev->id_list, list) {\r\nif (i_id < cb->args[1]) {\r\ni_id++;\r\ncontinue;\r\n}\r\nid_stats = ibnl_put_msg(skb, &nlh, cb->nlh->nlmsg_seq,\r\nsizeof *id_stats, RDMA_NL_RDMA_CM,\r\nRDMA_NL_RDMA_CM_ID_STATS);\r\nif (!id_stats)\r\ngoto out;\r\nmemset(id_stats, 0, sizeof *id_stats);\r\nid = &id_priv->id;\r\nid_stats->node_type = id->route.addr.dev_addr.dev_type;\r\nid_stats->port_num = id->port_num;\r\nid_stats->bound_dev_if =\r\nid->route.addr.dev_addr.bound_dev_if;\r\nif (id->route.addr.src_addr.ss_family == AF_INET) {\r\nif (ibnl_put_attr(skb, nlh,\r\nsizeof(struct sockaddr_in),\r\n&id->route.addr.src_addr,\r\nRDMA_NL_RDMA_CM_ATTR_SRC_ADDR)) {\r\ngoto out;\r\n}\r\nif (ibnl_put_attr(skb, nlh,\r\nsizeof(struct sockaddr_in),\r\n&id->route.addr.dst_addr,\r\nRDMA_NL_RDMA_CM_ATTR_DST_ADDR)) {\r\ngoto out;\r\n}\r\n} else if (id->route.addr.src_addr.ss_family == AF_INET6) {\r\nif (ibnl_put_attr(skb, nlh,\r\nsizeof(struct sockaddr_in6),\r\n&id->route.addr.src_addr,\r\nRDMA_NL_RDMA_CM_ATTR_SRC_ADDR)) {\r\ngoto out;\r\n}\r\nif (ibnl_put_attr(skb, nlh,\r\nsizeof(struct sockaddr_in6),\r\n&id->route.addr.dst_addr,\r\nRDMA_NL_RDMA_CM_ATTR_DST_ADDR)) {\r\ngoto out;\r\n}\r\n}\r\nid_stats->pid = id_priv->owner;\r\nid_stats->port_space = id->ps;\r\nid_stats->cm_state = id_priv->state;\r\nid_stats->qp_num = id_priv->qp_num;\r\nid_stats->qp_type = id->qp_type;\r\ni_id++;\r\n}\r\ncb->args[1] = 0;\r\ni_dev++;\r\n}\r\nout:\r\nmutex_unlock(&lock);\r\ncb->args[0] = i_dev;\r\ncb->args[1] = i_id;\r\nreturn skb->len;\r\n}\r\nstatic int __init cma_init(void)\r\n{\r\nint ret;\r\ncma_wq = create_singlethread_workqueue("rdma_cm");\r\nif (!cma_wq)\r\nreturn -ENOMEM;\r\nib_sa_register_client(&sa_client);\r\nrdma_addr_register_client(&addr_client);\r\nregister_netdevice_notifier(&cma_nb);\r\nret = ib_register_client(&cma_client);\r\nif (ret)\r\ngoto err;\r\nif (ibnl_add_client(RDMA_NL_RDMA_CM, RDMA_NL_RDMA_CM_NUM_OPS, cma_cb_table))\r\nprintk(KERN_WARNING "RDMA CMA: failed to add netlink callback\n");\r\nreturn 0;\r\nerr:\r\nunregister_netdevice_notifier(&cma_nb);\r\nrdma_addr_unregister_client(&addr_client);\r\nib_sa_unregister_client(&sa_client);\r\ndestroy_workqueue(cma_wq);\r\nreturn ret;\r\n}\r\nstatic void __exit cma_cleanup(void)\r\n{\r\nibnl_remove_client(RDMA_NL_RDMA_CM);\r\nib_unregister_client(&cma_client);\r\nunregister_netdevice_notifier(&cma_nb);\r\nrdma_addr_unregister_client(&addr_client);\r\nib_sa_unregister_client(&sa_client);\r\ndestroy_workqueue(cma_wq);\r\nidr_destroy(&sdp_ps);\r\nidr_destroy(&tcp_ps);\r\nidr_destroy(&udp_ps);\r\nidr_destroy(&ipoib_ps);\r\nidr_destroy(&ib_ps);\r\n}
