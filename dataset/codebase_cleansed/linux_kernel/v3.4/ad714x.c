static void ad714x_use_com_int(struct ad714x_chip *ad714x,\r\nint start_stage, int end_stage)\r\n{\r\nunsigned short data;\r\nunsigned short mask;\r\nmask = ((1 << (end_stage + 1)) - 1) - ((1 << start_stage) - 1);\r\nad714x->read(ad714x, STG_COM_INT_EN_REG, &data, 1);\r\ndata |= 1 << end_stage;\r\nad714x->write(ad714x, STG_COM_INT_EN_REG, data);\r\nad714x->read(ad714x, STG_HIGH_INT_EN_REG, &data, 1);\r\ndata &= ~mask;\r\nad714x->write(ad714x, STG_HIGH_INT_EN_REG, data);\r\n}\r\nstatic void ad714x_use_thr_int(struct ad714x_chip *ad714x,\r\nint start_stage, int end_stage)\r\n{\r\nunsigned short data;\r\nunsigned short mask;\r\nmask = ((1 << (end_stage + 1)) - 1) - ((1 << start_stage) - 1);\r\nad714x->read(ad714x, STG_COM_INT_EN_REG, &data, 1);\r\ndata &= ~(1 << end_stage);\r\nad714x->write(ad714x, STG_COM_INT_EN_REG, data);\r\nad714x->read(ad714x, STG_HIGH_INT_EN_REG, &data, 1);\r\ndata |= mask;\r\nad714x->write(ad714x, STG_HIGH_INT_EN_REG, data);\r\n}\r\nstatic int ad714x_cal_highest_stage(struct ad714x_chip *ad714x,\r\nint start_stage, int end_stage)\r\n{\r\nint max_res = 0;\r\nint max_idx = 0;\r\nint i;\r\nfor (i = start_stage; i <= end_stage; i++) {\r\nif (ad714x->sensor_val[i] > max_res) {\r\nmax_res = ad714x->sensor_val[i];\r\nmax_idx = i;\r\n}\r\n}\r\nreturn max_idx;\r\n}\r\nstatic int ad714x_cal_abs_pos(struct ad714x_chip *ad714x,\r\nint start_stage, int end_stage,\r\nint highest_stage, int max_coord)\r\n{\r\nint a_param, b_param;\r\nif (highest_stage == start_stage) {\r\na_param = ad714x->sensor_val[start_stage + 1];\r\nb_param = ad714x->sensor_val[start_stage] +\r\nad714x->sensor_val[start_stage + 1];\r\n} else if (highest_stage == end_stage) {\r\na_param = ad714x->sensor_val[end_stage] *\r\n(end_stage - start_stage) +\r\nad714x->sensor_val[end_stage - 1] *\r\n(end_stage - start_stage - 1);\r\nb_param = ad714x->sensor_val[end_stage] +\r\nad714x->sensor_val[end_stage - 1];\r\n} else {\r\na_param = ad714x->sensor_val[highest_stage] *\r\n(highest_stage - start_stage) +\r\nad714x->sensor_val[highest_stage - 1] *\r\n(highest_stage - start_stage - 1) +\r\nad714x->sensor_val[highest_stage + 1] *\r\n(highest_stage - start_stage + 1);\r\nb_param = ad714x->sensor_val[highest_stage] +\r\nad714x->sensor_val[highest_stage - 1] +\r\nad714x->sensor_val[highest_stage + 1];\r\n}\r\nreturn (max_coord / (end_stage - start_stage)) * a_param / b_param;\r\n}\r\nstatic void ad714x_button_state_machine(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_button_plat *hw = &ad714x->hw->button[idx];\r\nstruct ad714x_button_drv *sw = &ad714x->sw->button[idx];\r\nswitch (sw->state) {\r\ncase IDLE:\r\nif (((ad714x->h_state & hw->h_mask) == hw->h_mask) &&\r\n((ad714x->l_state & hw->l_mask) == hw->l_mask)) {\r\ndev_dbg(ad714x->dev, "button %d touched\n", idx);\r\ninput_report_key(sw->input, hw->keycode, 1);\r\ninput_sync(sw->input);\r\nsw->state = ACTIVE;\r\n}\r\nbreak;\r\ncase ACTIVE:\r\nif (((ad714x->h_state & hw->h_mask) != hw->h_mask) ||\r\n((ad714x->l_state & hw->l_mask) != hw->l_mask)) {\r\ndev_dbg(ad714x->dev, "button %d released\n", idx);\r\ninput_report_key(sw->input, hw->keycode, 0);\r\ninput_sync(sw->input);\r\nsw->state = IDLE;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void ad714x_slider_cal_sensor_val(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_slider_plat *hw = &ad714x->hw->slider[idx];\r\nint i;\r\nad714x->read(ad714x, CDC_RESULT_S0 + hw->start_stage,\r\n&ad714x->adc_reg[hw->start_stage],\r\nhw->end_stage - hw->start_stage + 1);\r\nfor (i = hw->start_stage; i <= hw->end_stage; i++) {\r\nad714x->read(ad714x, STAGE0_AMBIENT + i * PER_STAGE_REG_NUM,\r\n&ad714x->amb_reg[i], 1);\r\nad714x->sensor_val[i] =\r\nabs(ad714x->adc_reg[i] - ad714x->amb_reg[i]);\r\n}\r\n}\r\nstatic void ad714x_slider_cal_highest_stage(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_slider_plat *hw = &ad714x->hw->slider[idx];\r\nstruct ad714x_slider_drv *sw = &ad714x->sw->slider[idx];\r\nsw->highest_stage = ad714x_cal_highest_stage(ad714x, hw->start_stage,\r\nhw->end_stage);\r\ndev_dbg(ad714x->dev, "slider %d highest_stage:%d\n", idx,\r\nsw->highest_stage);\r\n}\r\nstatic void ad714x_slider_cal_abs_pos(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_slider_plat *hw = &ad714x->hw->slider[idx];\r\nstruct ad714x_slider_drv *sw = &ad714x->sw->slider[idx];\r\nsw->abs_pos = ad714x_cal_abs_pos(ad714x, hw->start_stage, hw->end_stage,\r\nsw->highest_stage, hw->max_coord);\r\ndev_dbg(ad714x->dev, "slider %d absolute position:%d\n", idx,\r\nsw->abs_pos);\r\n}\r\nstatic void ad714x_slider_cal_flt_pos(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_slider_drv *sw = &ad714x->sw->slider[idx];\r\nsw->flt_pos = (sw->flt_pos * (10 - 4) +\r\nsw->abs_pos * 4)/10;\r\ndev_dbg(ad714x->dev, "slider %d filter position:%d\n", idx,\r\nsw->flt_pos);\r\n}\r\nstatic void ad714x_slider_use_com_int(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_slider_plat *hw = &ad714x->hw->slider[idx];\r\nad714x_use_com_int(ad714x, hw->start_stage, hw->end_stage);\r\n}\r\nstatic void ad714x_slider_use_thr_int(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_slider_plat *hw = &ad714x->hw->slider[idx];\r\nad714x_use_thr_int(ad714x, hw->start_stage, hw->end_stage);\r\n}\r\nstatic void ad714x_slider_state_machine(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_slider_plat *hw = &ad714x->hw->slider[idx];\r\nstruct ad714x_slider_drv *sw = &ad714x->sw->slider[idx];\r\nunsigned short h_state, c_state;\r\nunsigned short mask;\r\nmask = ((1 << (hw->end_stage + 1)) - 1) - ((1 << hw->start_stage) - 1);\r\nh_state = ad714x->h_state & mask;\r\nc_state = ad714x->c_state & mask;\r\nswitch (sw->state) {\r\ncase IDLE:\r\nif (h_state) {\r\nsw->state = JITTER;\r\nad714x_slider_use_com_int(ad714x, idx);\r\ndev_dbg(ad714x->dev, "slider %d touched\n", idx);\r\n}\r\nbreak;\r\ncase JITTER:\r\nif (c_state == mask) {\r\nad714x_slider_cal_sensor_val(ad714x, idx);\r\nad714x_slider_cal_highest_stage(ad714x, idx);\r\nad714x_slider_cal_abs_pos(ad714x, idx);\r\nsw->flt_pos = sw->abs_pos;\r\nsw->state = ACTIVE;\r\n}\r\nbreak;\r\ncase ACTIVE:\r\nif (c_state == mask) {\r\nif (h_state) {\r\nad714x_slider_cal_sensor_val(ad714x, idx);\r\nad714x_slider_cal_highest_stage(ad714x, idx);\r\nad714x_slider_cal_abs_pos(ad714x, idx);\r\nad714x_slider_cal_flt_pos(ad714x, idx);\r\ninput_report_abs(sw->input, ABS_X, sw->flt_pos);\r\ninput_report_key(sw->input, BTN_TOUCH, 1);\r\n} else {\r\nad714x_slider_use_thr_int(ad714x, idx);\r\nsw->state = IDLE;\r\ninput_report_key(sw->input, BTN_TOUCH, 0);\r\ndev_dbg(ad714x->dev, "slider %d released\n",\r\nidx);\r\n}\r\ninput_sync(sw->input);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void ad714x_wheel_cal_highest_stage(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_wheel_plat *hw = &ad714x->hw->wheel[idx];\r\nstruct ad714x_wheel_drv *sw = &ad714x->sw->wheel[idx];\r\nsw->pre_highest_stage = sw->highest_stage;\r\nsw->highest_stage = ad714x_cal_highest_stage(ad714x, hw->start_stage,\r\nhw->end_stage);\r\ndev_dbg(ad714x->dev, "wheel %d highest_stage:%d\n", idx,\r\nsw->highest_stage);\r\n}\r\nstatic void ad714x_wheel_cal_sensor_val(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_wheel_plat *hw = &ad714x->hw->wheel[idx];\r\nint i;\r\nad714x->read(ad714x, CDC_RESULT_S0 + hw->start_stage,\r\n&ad714x->adc_reg[hw->start_stage],\r\nhw->end_stage - hw->start_stage + 1);\r\nfor (i = hw->start_stage; i <= hw->end_stage; i++) {\r\nad714x->read(ad714x, STAGE0_AMBIENT + i * PER_STAGE_REG_NUM,\r\n&ad714x->amb_reg[i], 1);\r\nif (ad714x->adc_reg[i] > ad714x->amb_reg[i])\r\nad714x->sensor_val[i] =\r\nad714x->adc_reg[i] - ad714x->amb_reg[i];\r\nelse\r\nad714x->sensor_val[i] = 0;\r\n}\r\n}\r\nstatic void ad714x_wheel_cal_abs_pos(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_wheel_plat *hw = &ad714x->hw->wheel[idx];\r\nstruct ad714x_wheel_drv *sw = &ad714x->sw->wheel[idx];\r\nint stage_num = hw->end_stage - hw->start_stage + 1;\r\nint first_before, highest, first_after;\r\nint a_param, b_param;\r\nfirst_before = (sw->highest_stage + stage_num - 1) % stage_num;\r\nhighest = sw->highest_stage;\r\nfirst_after = (sw->highest_stage + stage_num + 1) % stage_num;\r\na_param = ad714x->sensor_val[highest] *\r\n(highest - hw->start_stage) +\r\nad714x->sensor_val[first_before] *\r\n(highest - hw->start_stage - 1) +\r\nad714x->sensor_val[first_after] *\r\n(highest - hw->start_stage + 1);\r\nb_param = ad714x->sensor_val[highest] +\r\nad714x->sensor_val[first_before] +\r\nad714x->sensor_val[first_after];\r\nsw->abs_pos = ((hw->max_coord / (hw->end_stage - hw->start_stage)) *\r\na_param) / b_param;\r\nif (sw->abs_pos > hw->max_coord)\r\nsw->abs_pos = hw->max_coord;\r\nelse if (sw->abs_pos < 0)\r\nsw->abs_pos = 0;\r\n}\r\nstatic void ad714x_wheel_cal_flt_pos(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_wheel_plat *hw = &ad714x->hw->wheel[idx];\r\nstruct ad714x_wheel_drv *sw = &ad714x->sw->wheel[idx];\r\nif (((sw->pre_highest_stage == hw->end_stage) &&\r\n(sw->highest_stage == hw->start_stage)) ||\r\n((sw->pre_highest_stage == hw->start_stage) &&\r\n(sw->highest_stage == hw->end_stage)))\r\nsw->flt_pos = sw->abs_pos;\r\nelse\r\nsw->flt_pos = ((sw->flt_pos * 30) + (sw->abs_pos * 71)) / 100;\r\nif (sw->flt_pos > hw->max_coord)\r\nsw->flt_pos = hw->max_coord;\r\n}\r\nstatic void ad714x_wheel_use_com_int(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_wheel_plat *hw = &ad714x->hw->wheel[idx];\r\nad714x_use_com_int(ad714x, hw->start_stage, hw->end_stage);\r\n}\r\nstatic void ad714x_wheel_use_thr_int(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_wheel_plat *hw = &ad714x->hw->wheel[idx];\r\nad714x_use_thr_int(ad714x, hw->start_stage, hw->end_stage);\r\n}\r\nstatic void ad714x_wheel_state_machine(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_wheel_plat *hw = &ad714x->hw->wheel[idx];\r\nstruct ad714x_wheel_drv *sw = &ad714x->sw->wheel[idx];\r\nunsigned short h_state, c_state;\r\nunsigned short mask;\r\nmask = ((1 << (hw->end_stage + 1)) - 1) - ((1 << hw->start_stage) - 1);\r\nh_state = ad714x->h_state & mask;\r\nc_state = ad714x->c_state & mask;\r\nswitch (sw->state) {\r\ncase IDLE:\r\nif (h_state) {\r\nsw->state = JITTER;\r\nad714x_wheel_use_com_int(ad714x, idx);\r\ndev_dbg(ad714x->dev, "wheel %d touched\n", idx);\r\n}\r\nbreak;\r\ncase JITTER:\r\nif (c_state == mask) {\r\nad714x_wheel_cal_sensor_val(ad714x, idx);\r\nad714x_wheel_cal_highest_stage(ad714x, idx);\r\nad714x_wheel_cal_abs_pos(ad714x, idx);\r\nsw->flt_pos = sw->abs_pos;\r\nsw->state = ACTIVE;\r\n}\r\nbreak;\r\ncase ACTIVE:\r\nif (c_state == mask) {\r\nif (h_state) {\r\nad714x_wheel_cal_sensor_val(ad714x, idx);\r\nad714x_wheel_cal_highest_stage(ad714x, idx);\r\nad714x_wheel_cal_abs_pos(ad714x, idx);\r\nad714x_wheel_cal_flt_pos(ad714x, idx);\r\ninput_report_abs(sw->input, ABS_WHEEL,\r\nsw->flt_pos);\r\ninput_report_key(sw->input, BTN_TOUCH, 1);\r\n} else {\r\nad714x_wheel_use_thr_int(ad714x, idx);\r\nsw->state = IDLE;\r\ninput_report_key(sw->input, BTN_TOUCH, 0);\r\ndev_dbg(ad714x->dev, "wheel %d released\n",\r\nidx);\r\n}\r\ninput_sync(sw->input);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void touchpad_cal_sensor_val(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_touchpad_plat *hw = &ad714x->hw->touchpad[idx];\r\nint i;\r\nad714x->read(ad714x, CDC_RESULT_S0 + hw->x_start_stage,\r\n&ad714x->adc_reg[hw->x_start_stage],\r\nhw->x_end_stage - hw->x_start_stage + 1);\r\nfor (i = hw->x_start_stage; i <= hw->x_end_stage; i++) {\r\nad714x->read(ad714x, STAGE0_AMBIENT + i * PER_STAGE_REG_NUM,\r\n&ad714x->amb_reg[i], 1);\r\nif (ad714x->adc_reg[i] > ad714x->amb_reg[i])\r\nad714x->sensor_val[i] =\r\nad714x->adc_reg[i] - ad714x->amb_reg[i];\r\nelse\r\nad714x->sensor_val[i] = 0;\r\n}\r\n}\r\nstatic void touchpad_cal_highest_stage(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_touchpad_plat *hw = &ad714x->hw->touchpad[idx];\r\nstruct ad714x_touchpad_drv *sw = &ad714x->sw->touchpad[idx];\r\nsw->x_highest_stage = ad714x_cal_highest_stage(ad714x,\r\nhw->x_start_stage, hw->x_end_stage);\r\nsw->y_highest_stage = ad714x_cal_highest_stage(ad714x,\r\nhw->y_start_stage, hw->y_end_stage);\r\ndev_dbg(ad714x->dev,\r\n"touchpad %d x_highest_stage:%d, y_highest_stage:%d\n",\r\nidx, sw->x_highest_stage, sw->y_highest_stage);\r\n}\r\nstatic int touchpad_check_second_peak(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_touchpad_plat *hw = &ad714x->hw->touchpad[idx];\r\nstruct ad714x_touchpad_drv *sw = &ad714x->sw->touchpad[idx];\r\nint i;\r\nfor (i = hw->x_start_stage; i < sw->x_highest_stage; i++) {\r\nif ((ad714x->sensor_val[i] - ad714x->sensor_val[i + 1])\r\n> (ad714x->sensor_val[i + 1] / 10))\r\nreturn 1;\r\n}\r\nfor (i = sw->x_highest_stage; i < hw->x_end_stage; i++) {\r\nif ((ad714x->sensor_val[i + 1] - ad714x->sensor_val[i])\r\n> (ad714x->sensor_val[i] / 10))\r\nreturn 1;\r\n}\r\nfor (i = hw->y_start_stage; i < sw->y_highest_stage; i++) {\r\nif ((ad714x->sensor_val[i] - ad714x->sensor_val[i + 1])\r\n> (ad714x->sensor_val[i + 1] / 10))\r\nreturn 1;\r\n}\r\nfor (i = sw->y_highest_stage; i < hw->y_end_stage; i++) {\r\nif ((ad714x->sensor_val[i + 1] - ad714x->sensor_val[i])\r\n> (ad714x->sensor_val[i] / 10))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void touchpad_cal_abs_pos(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_touchpad_plat *hw = &ad714x->hw->touchpad[idx];\r\nstruct ad714x_touchpad_drv *sw = &ad714x->sw->touchpad[idx];\r\nsw->x_abs_pos = ad714x_cal_abs_pos(ad714x, hw->x_start_stage,\r\nhw->x_end_stage, sw->x_highest_stage, hw->x_max_coord);\r\nsw->y_abs_pos = ad714x_cal_abs_pos(ad714x, hw->y_start_stage,\r\nhw->y_end_stage, sw->y_highest_stage, hw->y_max_coord);\r\ndev_dbg(ad714x->dev, "touchpad %d absolute position:(%d, %d)\n", idx,\r\nsw->x_abs_pos, sw->y_abs_pos);\r\n}\r\nstatic void touchpad_cal_flt_pos(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_touchpad_drv *sw = &ad714x->sw->touchpad[idx];\r\nsw->x_flt_pos = (sw->x_flt_pos * (10 - 4) +\r\nsw->x_abs_pos * 4)/10;\r\nsw->y_flt_pos = (sw->y_flt_pos * (10 - 4) +\r\nsw->y_abs_pos * 4)/10;\r\ndev_dbg(ad714x->dev, "touchpad %d filter position:(%d, %d)\n",\r\nidx, sw->x_flt_pos, sw->y_flt_pos);\r\n}\r\nstatic int touchpad_check_endpoint(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_touchpad_plat *hw = &ad714x->hw->touchpad[idx];\r\nstruct ad714x_touchpad_drv *sw = &ad714x->sw->touchpad[idx];\r\nint percent_sensor_diff;\r\npercent_sensor_diff = (ad714x->sensor_val[hw->x_start_stage] -\r\nad714x->sensor_val[hw->x_start_stage + 1]) * 100 /\r\nad714x->sensor_val[hw->x_start_stage + 1];\r\nif (!sw->left_ep) {\r\nif (percent_sensor_diff >= LEFT_END_POINT_DETECTION_LEVEL) {\r\nsw->left_ep = 1;\r\nsw->left_ep_val =\r\nad714x->sensor_val[hw->x_start_stage + 1];\r\n}\r\n} else {\r\nif ((percent_sensor_diff < LEFT_END_POINT_DETECTION_LEVEL) &&\r\n(ad714x->sensor_val[hw->x_start_stage + 1] >\r\nLEFT_RIGHT_END_POINT_DEAVTIVALION_LEVEL + sw->left_ep_val))\r\nsw->left_ep = 0;\r\n}\r\npercent_sensor_diff = (ad714x->sensor_val[hw->x_end_stage] -\r\nad714x->sensor_val[hw->x_end_stage - 1]) * 100 /\r\nad714x->sensor_val[hw->x_end_stage - 1];\r\nif (!sw->right_ep) {\r\nif (percent_sensor_diff >= RIGHT_END_POINT_DETECTION_LEVEL) {\r\nsw->right_ep = 1;\r\nsw->right_ep_val =\r\nad714x->sensor_val[hw->x_end_stage - 1];\r\n}\r\n} else {\r\nif ((percent_sensor_diff < RIGHT_END_POINT_DETECTION_LEVEL) &&\r\n(ad714x->sensor_val[hw->x_end_stage - 1] >\r\nLEFT_RIGHT_END_POINT_DEAVTIVALION_LEVEL + sw->right_ep_val))\r\nsw->right_ep = 0;\r\n}\r\npercent_sensor_diff = (ad714x->sensor_val[hw->y_start_stage] -\r\nad714x->sensor_val[hw->y_start_stage + 1]) * 100 /\r\nad714x->sensor_val[hw->y_start_stage + 1];\r\nif (!sw->top_ep) {\r\nif (percent_sensor_diff >= TOP_END_POINT_DETECTION_LEVEL) {\r\nsw->top_ep = 1;\r\nsw->top_ep_val =\r\nad714x->sensor_val[hw->y_start_stage + 1];\r\n}\r\n} else {\r\nif ((percent_sensor_diff < TOP_END_POINT_DETECTION_LEVEL) &&\r\n(ad714x->sensor_val[hw->y_start_stage + 1] >\r\nTOP_BOTTOM_END_POINT_DEAVTIVALION_LEVEL + sw->top_ep_val))\r\nsw->top_ep = 0;\r\n}\r\npercent_sensor_diff = (ad714x->sensor_val[hw->y_end_stage] -\r\nad714x->sensor_val[hw->y_end_stage - 1]) * 100 /\r\nad714x->sensor_val[hw->y_end_stage - 1];\r\nif (!sw->bottom_ep) {\r\nif (percent_sensor_diff >= BOTTOM_END_POINT_DETECTION_LEVEL) {\r\nsw->bottom_ep = 1;\r\nsw->bottom_ep_val =\r\nad714x->sensor_val[hw->y_end_stage - 1];\r\n}\r\n} else {\r\nif ((percent_sensor_diff < BOTTOM_END_POINT_DETECTION_LEVEL) &&\r\n(ad714x->sensor_val[hw->y_end_stage - 1] >\r\nTOP_BOTTOM_END_POINT_DEAVTIVALION_LEVEL + sw->bottom_ep_val))\r\nsw->bottom_ep = 0;\r\n}\r\nreturn sw->left_ep || sw->right_ep || sw->top_ep || sw->bottom_ep;\r\n}\r\nstatic void touchpad_use_com_int(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_touchpad_plat *hw = &ad714x->hw->touchpad[idx];\r\nad714x_use_com_int(ad714x, hw->x_start_stage, hw->x_end_stage);\r\n}\r\nstatic void touchpad_use_thr_int(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_touchpad_plat *hw = &ad714x->hw->touchpad[idx];\r\nad714x_use_thr_int(ad714x, hw->x_start_stage, hw->x_end_stage);\r\nad714x_use_thr_int(ad714x, hw->y_start_stage, hw->y_end_stage);\r\n}\r\nstatic void ad714x_touchpad_state_machine(struct ad714x_chip *ad714x, int idx)\r\n{\r\nstruct ad714x_touchpad_plat *hw = &ad714x->hw->touchpad[idx];\r\nstruct ad714x_touchpad_drv *sw = &ad714x->sw->touchpad[idx];\r\nunsigned short h_state, c_state;\r\nunsigned short mask;\r\nmask = (((1 << (hw->x_end_stage + 1)) - 1) -\r\n((1 << hw->x_start_stage) - 1)) +\r\n(((1 << (hw->y_end_stage + 1)) - 1) -\r\n((1 << hw->y_start_stage) - 1));\r\nh_state = ad714x->h_state & mask;\r\nc_state = ad714x->c_state & mask;\r\nswitch (sw->state) {\r\ncase IDLE:\r\nif (h_state) {\r\nsw->state = JITTER;\r\ntouchpad_use_com_int(ad714x, idx);\r\ndev_dbg(ad714x->dev, "touchpad %d touched\n", idx);\r\n}\r\nbreak;\r\ncase JITTER:\r\nif (c_state == mask) {\r\ntouchpad_cal_sensor_val(ad714x, idx);\r\ntouchpad_cal_highest_stage(ad714x, idx);\r\nif ((!touchpad_check_second_peak(ad714x, idx)) &&\r\n(!touchpad_check_endpoint(ad714x, idx))) {\r\ndev_dbg(ad714x->dev,\r\n"touchpad%d, 2 fingers or endpoint\n",\r\nidx);\r\ntouchpad_cal_abs_pos(ad714x, idx);\r\nsw->x_flt_pos = sw->x_abs_pos;\r\nsw->y_flt_pos = sw->y_abs_pos;\r\nsw->state = ACTIVE;\r\n}\r\n}\r\nbreak;\r\ncase ACTIVE:\r\nif (c_state == mask) {\r\nif (h_state) {\r\ntouchpad_cal_sensor_val(ad714x, idx);\r\ntouchpad_cal_highest_stage(ad714x, idx);\r\nif ((!touchpad_check_second_peak(ad714x, idx))\r\n&& (!touchpad_check_endpoint(ad714x, idx))) {\r\ntouchpad_cal_abs_pos(ad714x, idx);\r\ntouchpad_cal_flt_pos(ad714x, idx);\r\ninput_report_abs(sw->input, ABS_X,\r\nsw->x_flt_pos);\r\ninput_report_abs(sw->input, ABS_Y,\r\nsw->y_flt_pos);\r\ninput_report_key(sw->input, BTN_TOUCH,\r\n1);\r\n}\r\n} else {\r\ntouchpad_use_thr_int(ad714x, idx);\r\nsw->state = IDLE;\r\ninput_report_key(sw->input, BTN_TOUCH, 0);\r\ndev_dbg(ad714x->dev, "touchpad %d released\n",\r\nidx);\r\n}\r\ninput_sync(sw->input);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int ad714x_hw_detect(struct ad714x_chip *ad714x)\r\n{\r\nunsigned short data;\r\nad714x->read(ad714x, AD714X_PARTID_REG, &data, 1);\r\nswitch (data & 0xFFF0) {\r\ncase AD7142_PARTID:\r\nad714x->product = 0x7142;\r\nad714x->version = data & 0xF;\r\ndev_info(ad714x->dev, "found AD7142 captouch, rev:%d\n",\r\nad714x->version);\r\nreturn 0;\r\ncase AD7143_PARTID:\r\nad714x->product = 0x7143;\r\nad714x->version = data & 0xF;\r\ndev_info(ad714x->dev, "found AD7143 captouch, rev:%d\n",\r\nad714x->version);\r\nreturn 0;\r\ncase AD7147_PARTID:\r\nad714x->product = 0x7147;\r\nad714x->version = data & 0xF;\r\ndev_info(ad714x->dev, "found AD7147(A) captouch, rev:%d\n",\r\nad714x->version);\r\nreturn 0;\r\ncase AD7148_PARTID:\r\nad714x->product = 0x7148;\r\nad714x->version = data & 0xF;\r\ndev_info(ad714x->dev, "found AD7148 captouch, rev:%d\n",\r\nad714x->version);\r\nreturn 0;\r\ndefault:\r\ndev_err(ad714x->dev,\r\n"fail to detect AD714X captouch, read ID is %04x\n",\r\ndata);\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic void ad714x_hw_init(struct ad714x_chip *ad714x)\r\n{\r\nint i, j;\r\nunsigned short reg_base;\r\nunsigned short data;\r\nfor (i = 0; i < STAGE_NUM; i++) {\r\nreg_base = AD714X_STAGECFG_REG + i * STAGE_CFGREG_NUM;\r\nfor (j = 0; j < STAGE_CFGREG_NUM; j++)\r\nad714x->write(ad714x, reg_base + j,\r\nad714x->hw->stage_cfg_reg[i][j]);\r\n}\r\nfor (i = 0; i < SYS_CFGREG_NUM; i++)\r\nad714x->write(ad714x, AD714X_SYSCFG_REG + i,\r\nad714x->hw->sys_cfg_reg[i]);\r\nfor (i = 0; i < SYS_CFGREG_NUM; i++)\r\nad714x->read(ad714x, AD714X_SYSCFG_REG + i, &data, 1);\r\nad714x->write(ad714x, AD714X_STG_CAL_EN_REG, 0xFFF);\r\nad714x->read(ad714x, STG_LOW_INT_STA_REG, &ad714x->l_state, 3);\r\n}\r\nstatic irqreturn_t ad714x_interrupt_thread(int irq, void *data)\r\n{\r\nstruct ad714x_chip *ad714x = data;\r\nint i;\r\nmutex_lock(&ad714x->mutex);\r\nad714x->read(ad714x, STG_LOW_INT_STA_REG, &ad714x->l_state, 3);\r\nfor (i = 0; i < ad714x->hw->button_num; i++)\r\nad714x_button_state_machine(ad714x, i);\r\nfor (i = 0; i < ad714x->hw->slider_num; i++)\r\nad714x_slider_state_machine(ad714x, i);\r\nfor (i = 0; i < ad714x->hw->wheel_num; i++)\r\nad714x_wheel_state_machine(ad714x, i);\r\nfor (i = 0; i < ad714x->hw->touchpad_num; i++)\r\nad714x_touchpad_state_machine(ad714x, i);\r\nmutex_unlock(&ad714x->mutex);\r\nreturn IRQ_HANDLED;\r\n}\r\nstruct ad714x_chip *ad714x_probe(struct device *dev, u16 bus_type, int irq,\r\nad714x_read_t read, ad714x_write_t write)\r\n{\r\nint i, alloc_idx;\r\nint error;\r\nstruct input_dev *input[MAX_DEVICE_NUM];\r\nstruct ad714x_platform_data *plat_data = dev->platform_data;\r\nstruct ad714x_chip *ad714x;\r\nvoid *drv_mem;\r\nstruct ad714x_button_drv *bt_drv;\r\nstruct ad714x_slider_drv *sd_drv;\r\nstruct ad714x_wheel_drv *wl_drv;\r\nstruct ad714x_touchpad_drv *tp_drv;\r\nif (irq <= 0) {\r\ndev_err(dev, "IRQ not configured!\n");\r\nerror = -EINVAL;\r\ngoto err_out;\r\n}\r\nif (dev->platform_data == NULL) {\r\ndev_err(dev, "platform data for ad714x doesn't exist\n");\r\nerror = -EINVAL;\r\ngoto err_out;\r\n}\r\nad714x = kzalloc(sizeof(*ad714x) + sizeof(*ad714x->sw) +\r\nsizeof(*sd_drv) * plat_data->slider_num +\r\nsizeof(*wl_drv) * plat_data->wheel_num +\r\nsizeof(*tp_drv) * plat_data->touchpad_num +\r\nsizeof(*bt_drv) * plat_data->button_num, GFP_KERNEL);\r\nif (!ad714x) {\r\nerror = -ENOMEM;\r\ngoto err_out;\r\n}\r\nad714x->hw = plat_data;\r\ndrv_mem = ad714x + 1;\r\nad714x->sw = drv_mem;\r\ndrv_mem += sizeof(*ad714x->sw);\r\nad714x->sw->slider = sd_drv = drv_mem;\r\ndrv_mem += sizeof(*sd_drv) * ad714x->hw->slider_num;\r\nad714x->sw->wheel = wl_drv = drv_mem;\r\ndrv_mem += sizeof(*wl_drv) * ad714x->hw->wheel_num;\r\nad714x->sw->touchpad = tp_drv = drv_mem;\r\ndrv_mem += sizeof(*tp_drv) * ad714x->hw->touchpad_num;\r\nad714x->sw->button = bt_drv = drv_mem;\r\ndrv_mem += sizeof(*bt_drv) * ad714x->hw->button_num;\r\nad714x->read = read;\r\nad714x->write = write;\r\nad714x->irq = irq;\r\nad714x->dev = dev;\r\nerror = ad714x_hw_detect(ad714x);\r\nif (error)\r\ngoto err_free_mem;\r\nad714x_hw_init(ad714x);\r\nmutex_init(&ad714x->mutex);\r\nalloc_idx = 0;\r\nif (ad714x->hw->slider_num > 0) {\r\nstruct ad714x_slider_plat *sd_plat = ad714x->hw->slider;\r\nfor (i = 0; i < ad714x->hw->slider_num; i++) {\r\nsd_drv[i].input = input[alloc_idx] = input_allocate_device();\r\nif (!input[alloc_idx]) {\r\nerror = -ENOMEM;\r\ngoto err_free_dev;\r\n}\r\n__set_bit(EV_ABS, input[alloc_idx]->evbit);\r\n__set_bit(EV_KEY, input[alloc_idx]->evbit);\r\n__set_bit(ABS_X, input[alloc_idx]->absbit);\r\n__set_bit(BTN_TOUCH, input[alloc_idx]->keybit);\r\ninput_set_abs_params(input[alloc_idx],\r\nABS_X, 0, sd_plat->max_coord, 0, 0);\r\ninput[alloc_idx]->id.bustype = bus_type;\r\ninput[alloc_idx]->id.product = ad714x->product;\r\ninput[alloc_idx]->id.version = ad714x->version;\r\ninput[alloc_idx]->name = "ad714x_captouch_slider";\r\ninput[alloc_idx]->dev.parent = dev;\r\nerror = input_register_device(input[alloc_idx]);\r\nif (error)\r\ngoto err_free_dev;\r\nalloc_idx++;\r\n}\r\n}\r\nif (ad714x->hw->wheel_num > 0) {\r\nstruct ad714x_wheel_plat *wl_plat = ad714x->hw->wheel;\r\nfor (i = 0; i < ad714x->hw->wheel_num; i++) {\r\nwl_drv[i].input = input[alloc_idx] = input_allocate_device();\r\nif (!input[alloc_idx]) {\r\nerror = -ENOMEM;\r\ngoto err_free_dev;\r\n}\r\n__set_bit(EV_KEY, input[alloc_idx]->evbit);\r\n__set_bit(EV_ABS, input[alloc_idx]->evbit);\r\n__set_bit(ABS_WHEEL, input[alloc_idx]->absbit);\r\n__set_bit(BTN_TOUCH, input[alloc_idx]->keybit);\r\ninput_set_abs_params(input[alloc_idx],\r\nABS_WHEEL, 0, wl_plat->max_coord, 0, 0);\r\ninput[alloc_idx]->id.bustype = bus_type;\r\ninput[alloc_idx]->id.product = ad714x->product;\r\ninput[alloc_idx]->id.version = ad714x->version;\r\ninput[alloc_idx]->name = "ad714x_captouch_wheel";\r\ninput[alloc_idx]->dev.parent = dev;\r\nerror = input_register_device(input[alloc_idx]);\r\nif (error)\r\ngoto err_free_dev;\r\nalloc_idx++;\r\n}\r\n}\r\nif (ad714x->hw->touchpad_num > 0) {\r\nstruct ad714x_touchpad_plat *tp_plat = ad714x->hw->touchpad;\r\nfor (i = 0; i < ad714x->hw->touchpad_num; i++) {\r\ntp_drv[i].input = input[alloc_idx] = input_allocate_device();\r\nif (!input[alloc_idx]) {\r\nerror = -ENOMEM;\r\ngoto err_free_dev;\r\n}\r\n__set_bit(EV_ABS, input[alloc_idx]->evbit);\r\n__set_bit(EV_KEY, input[alloc_idx]->evbit);\r\n__set_bit(ABS_X, input[alloc_idx]->absbit);\r\n__set_bit(ABS_Y, input[alloc_idx]->absbit);\r\n__set_bit(BTN_TOUCH, input[alloc_idx]->keybit);\r\ninput_set_abs_params(input[alloc_idx],\r\nABS_X, 0, tp_plat->x_max_coord, 0, 0);\r\ninput_set_abs_params(input[alloc_idx],\r\nABS_Y, 0, tp_plat->y_max_coord, 0, 0);\r\ninput[alloc_idx]->id.bustype = bus_type;\r\ninput[alloc_idx]->id.product = ad714x->product;\r\ninput[alloc_idx]->id.version = ad714x->version;\r\ninput[alloc_idx]->name = "ad714x_captouch_pad";\r\ninput[alloc_idx]->dev.parent = dev;\r\nerror = input_register_device(input[alloc_idx]);\r\nif (error)\r\ngoto err_free_dev;\r\nalloc_idx++;\r\n}\r\n}\r\nif (ad714x->hw->button_num > 0) {\r\nstruct ad714x_button_plat *bt_plat = ad714x->hw->button;\r\ninput[alloc_idx] = input_allocate_device();\r\nif (!input[alloc_idx]) {\r\nerror = -ENOMEM;\r\ngoto err_free_dev;\r\n}\r\n__set_bit(EV_KEY, input[alloc_idx]->evbit);\r\nfor (i = 0; i < ad714x->hw->button_num; i++) {\r\nbt_drv[i].input = input[alloc_idx];\r\n__set_bit(bt_plat[i].keycode, input[alloc_idx]->keybit);\r\n}\r\ninput[alloc_idx]->id.bustype = bus_type;\r\ninput[alloc_idx]->id.product = ad714x->product;\r\ninput[alloc_idx]->id.version = ad714x->version;\r\ninput[alloc_idx]->name = "ad714x_captouch_button";\r\ninput[alloc_idx]->dev.parent = dev;\r\nerror = input_register_device(input[alloc_idx]);\r\nif (error)\r\ngoto err_free_dev;\r\nalloc_idx++;\r\n}\r\nerror = request_threaded_irq(ad714x->irq, NULL, ad714x_interrupt_thread,\r\nplat_data->irqflags ?\r\nplat_data->irqflags : IRQF_TRIGGER_FALLING,\r\n"ad714x_captouch", ad714x);\r\nif (error) {\r\ndev_err(dev, "can't allocate irq %d\n", ad714x->irq);\r\ngoto err_unreg_dev;\r\n}\r\nreturn ad714x;\r\nerr_free_dev:\r\ndev_err(dev, "failed to setup AD714x input device %i\n", alloc_idx);\r\ninput_free_device(input[alloc_idx]);\r\nerr_unreg_dev:\r\nwhile (--alloc_idx >= 0)\r\ninput_unregister_device(input[alloc_idx]);\r\nerr_free_mem:\r\nkfree(ad714x);\r\nerr_out:\r\nreturn ERR_PTR(error);\r\n}\r\nvoid ad714x_remove(struct ad714x_chip *ad714x)\r\n{\r\nstruct ad714x_platform_data *hw = ad714x->hw;\r\nstruct ad714x_driver_data *sw = ad714x->sw;\r\nint i;\r\nfree_irq(ad714x->irq, ad714x);\r\nfor (i = 0; i < hw->slider_num; i++)\r\ninput_unregister_device(sw->slider[i].input);\r\nfor (i = 0; i < hw->wheel_num; i++)\r\ninput_unregister_device(sw->wheel[i].input);\r\nfor (i = 0; i < hw->touchpad_num; i++)\r\ninput_unregister_device(sw->touchpad[i].input);\r\nif (hw->button_num)\r\ninput_unregister_device(sw->button[0].input);\r\nkfree(ad714x);\r\n}\r\nint ad714x_disable(struct ad714x_chip *ad714x)\r\n{\r\nunsigned short data;\r\ndev_dbg(ad714x->dev, "%s enter\n", __func__);\r\nmutex_lock(&ad714x->mutex);\r\ndata = ad714x->hw->sys_cfg_reg[AD714X_PWR_CTRL] | 0x3;\r\nad714x->write(ad714x, AD714X_PWR_CTRL, data);\r\nmutex_unlock(&ad714x->mutex);\r\nreturn 0;\r\n}\r\nint ad714x_enable(struct ad714x_chip *ad714x)\r\n{\r\ndev_dbg(ad714x->dev, "%s enter\n", __func__);\r\nmutex_lock(&ad714x->mutex);\r\nad714x->write(ad714x, AD714X_PWR_CTRL,\r\nad714x->hw->sys_cfg_reg[AD714X_PWR_CTRL]);\r\nad714x->read(ad714x, STG_LOW_INT_STA_REG, &ad714x->l_state, 3);\r\nmutex_unlock(&ad714x->mutex);\r\nreturn 0;\r\n}
