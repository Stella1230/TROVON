static struct v4l2_mbus_framefmt *\r\n__resizer_get_format(struct isp_res_device *res, struct v4l2_subdev_fh *fh,\r\nunsigned int pad, enum v4l2_subdev_format_whence which)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn v4l2_subdev_get_try_format(fh, pad);\r\nelse\r\nreturn &res->formats[pad];\r\n}\r\nstatic struct v4l2_rect *\r\n__resizer_get_crop(struct isp_res_device *res, struct v4l2_subdev_fh *fh,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn v4l2_subdev_get_try_crop(fh, RESZ_PAD_SINK);\r\nelse\r\nreturn &res->crop.request;\r\n}\r\nstatic void resizer_set_filters(struct isp_res_device *res, const u16 *h_coeff,\r\nconst u16 *v_coeff)\r\n{\r\nstruct isp_device *isp = to_isp_device(res);\r\nu32 startaddr_h, startaddr_v, tmp_h, tmp_v;\r\nint i;\r\nstartaddr_h = ISPRSZ_HFILT10;\r\nstartaddr_v = ISPRSZ_VFILT10;\r\nfor (i = 0; i < COEFF_CNT; i += 2) {\r\ntmp_h = h_coeff[i] |\r\n(h_coeff[i + 1] << ISPRSZ_HFILT_COEF1_SHIFT);\r\ntmp_v = v_coeff[i] |\r\n(v_coeff[i + 1] << ISPRSZ_VFILT_COEF1_SHIFT);\r\nisp_reg_writel(isp, tmp_h, OMAP3_ISP_IOMEM_RESZ, startaddr_h);\r\nisp_reg_writel(isp, tmp_v, OMAP3_ISP_IOMEM_RESZ, startaddr_v);\r\nstartaddr_h += 4;\r\nstartaddr_v += 4;\r\n}\r\n}\r\nstatic void resizer_set_bilinear(struct isp_res_device *res,\r\nenum resizer_chroma_algo type)\r\n{\r\nstruct isp_device *isp = to_isp_device(res);\r\nif (type == RSZ_BILINEAR)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,\r\nISPRSZ_CNT_CBILIN);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,\r\nISPRSZ_CNT_CBILIN);\r\n}\r\nstatic void resizer_set_ycpos(struct isp_res_device *res,\r\nenum v4l2_mbus_pixelcode pixelcode)\r\n{\r\nstruct isp_device *isp = to_isp_device(res);\r\nswitch (pixelcode) {\r\ncase V4L2_MBUS_FMT_YUYV8_1X16:\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,\r\nISPRSZ_CNT_YCPOS);\r\nbreak;\r\ncase V4L2_MBUS_FMT_UYVY8_1X16:\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,\r\nISPRSZ_CNT_YCPOS);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\n}\r\nstatic void resizer_set_phase(struct isp_res_device *res, u32 h_phase,\r\nu32 v_phase)\r\n{\r\nstruct isp_device *isp = to_isp_device(res);\r\nu32 rgval = 0;\r\nrgval = isp_reg_readl(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT) &\r\n~(ISPRSZ_CNT_HSTPH_MASK | ISPRSZ_CNT_VSTPH_MASK);\r\nrgval |= (h_phase << ISPRSZ_CNT_HSTPH_SHIFT) & ISPRSZ_CNT_HSTPH_MASK;\r\nrgval |= (v_phase << ISPRSZ_CNT_VSTPH_SHIFT) & ISPRSZ_CNT_VSTPH_MASK;\r\nisp_reg_writel(isp, rgval, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT);\r\n}\r\nstatic void resizer_set_luma(struct isp_res_device *res,\r\nstruct resizer_luma_yenh *luma)\r\n{\r\nstruct isp_device *isp = to_isp_device(res);\r\nu32 rgval = 0;\r\nrgval = (luma->algo << ISPRSZ_YENH_ALGO_SHIFT)\r\n& ISPRSZ_YENH_ALGO_MASK;\r\nrgval |= (luma->gain << ISPRSZ_YENH_GAIN_SHIFT)\r\n& ISPRSZ_YENH_GAIN_MASK;\r\nrgval |= (luma->slope << ISPRSZ_YENH_SLOP_SHIFT)\r\n& ISPRSZ_YENH_SLOP_MASK;\r\nrgval |= (luma->core << ISPRSZ_YENH_CORE_SHIFT)\r\n& ISPRSZ_YENH_CORE_MASK;\r\nisp_reg_writel(isp, rgval, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_YENH);\r\n}\r\nstatic void resizer_set_source(struct isp_res_device *res,\r\nenum resizer_input_entity source)\r\n{\r\nstruct isp_device *isp = to_isp_device(res);\r\nif (source == RESIZER_INPUT_MEMORY)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,\r\nISPRSZ_CNT_INPSRC);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,\r\nISPRSZ_CNT_INPSRC);\r\n}\r\nstatic void resizer_set_ratio(struct isp_res_device *res,\r\nconst struct resizer_ratio *ratio)\r\n{\r\nstruct isp_device *isp = to_isp_device(res);\r\nconst u16 *h_filter, *v_filter;\r\nu32 rgval = 0;\r\nrgval = isp_reg_readl(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT) &\r\n~(ISPRSZ_CNT_HRSZ_MASK | ISPRSZ_CNT_VRSZ_MASK);\r\nrgval |= ((ratio->horz - 1) << ISPRSZ_CNT_HRSZ_SHIFT)\r\n& ISPRSZ_CNT_HRSZ_MASK;\r\nrgval |= ((ratio->vert - 1) << ISPRSZ_CNT_VRSZ_SHIFT)\r\n& ISPRSZ_CNT_VRSZ_MASK;\r\nisp_reg_writel(isp, rgval, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT);\r\nif (ratio->horz > MID_RESIZE_VALUE)\r\nh_filter = &filter_coefs.h_filter_coef_7tap[0];\r\nelse\r\nh_filter = &filter_coefs.h_filter_coef_4tap[0];\r\nif (ratio->vert > MID_RESIZE_VALUE)\r\nv_filter = &filter_coefs.v_filter_coef_7tap[0];\r\nelse\r\nv_filter = &filter_coefs.v_filter_coef_4tap[0];\r\nresizer_set_filters(res, h_filter, v_filter);\r\n}\r\nstatic void resizer_set_output_size(struct isp_res_device *res,\r\nu32 width, u32 height)\r\n{\r\nstruct isp_device *isp = to_isp_device(res);\r\nu32 rgval = 0;\r\ndev_dbg(isp->dev, "Output size[w/h]: %dx%d\n", width, height);\r\nrgval = (width << ISPRSZ_OUT_SIZE_HORZ_SHIFT)\r\n& ISPRSZ_OUT_SIZE_HORZ_MASK;\r\nrgval |= (height << ISPRSZ_OUT_SIZE_VERT_SHIFT)\r\n& ISPRSZ_OUT_SIZE_VERT_MASK;\r\nisp_reg_writel(isp, rgval, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_OUT_SIZE);\r\n}\r\nstatic void resizer_set_output_offset(struct isp_res_device *res, u32 offset)\r\n{\r\nstruct isp_device *isp = to_isp_device(res);\r\nisp_reg_writel(isp, offset, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_OUTOFF);\r\n}\r\nstatic void resizer_set_start(struct isp_res_device *res, u32 left, u32 top)\r\n{\r\nstruct isp_device *isp = to_isp_device(res);\r\nu32 rgval = 0;\r\nrgval = (left << ISPRSZ_IN_START_HORZ_ST_SHIFT)\r\n& ISPRSZ_IN_START_HORZ_ST_MASK;\r\nrgval |= (top << ISPRSZ_IN_START_VERT_ST_SHIFT)\r\n& ISPRSZ_IN_START_VERT_ST_MASK;\r\nisp_reg_writel(isp, rgval, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_IN_START);\r\n}\r\nstatic void resizer_set_input_size(struct isp_res_device *res,\r\nu32 width, u32 height)\r\n{\r\nstruct isp_device *isp = to_isp_device(res);\r\nu32 rgval = 0;\r\ndev_dbg(isp->dev, "Input size[w/h]: %dx%d\n", width, height);\r\nrgval = (width << ISPRSZ_IN_SIZE_HORZ_SHIFT)\r\n& ISPRSZ_IN_SIZE_HORZ_MASK;\r\nrgval |= (height << ISPRSZ_IN_SIZE_VERT_SHIFT)\r\n& ISPRSZ_IN_SIZE_VERT_MASK;\r\nisp_reg_writel(isp, rgval, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_IN_SIZE);\r\n}\r\nstatic void resizer_set_input_offset(struct isp_res_device *res, u32 offset)\r\n{\r\nstruct isp_device *isp = to_isp_device(res);\r\nisp_reg_writel(isp, offset, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_INOFF);\r\n}\r\nstatic void resizer_set_intype(struct isp_res_device *res,\r\nenum resizer_colors_type type)\r\n{\r\nstruct isp_device *isp = to_isp_device(res);\r\nif (type == RSZ_COLOR8)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,\r\nISPRSZ_CNT_INPTYP);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,\r\nISPRSZ_CNT_INPTYP);\r\n}\r\nstatic void __resizer_set_inaddr(struct isp_res_device *res, u32 addr)\r\n{\r\nstruct isp_device *isp = to_isp_device(res);\r\nisp_reg_writel(isp, addr, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_INADD);\r\n}\r\nvoid omap3isp_resizer_max_rate(struct isp_res_device *res,\r\nunsigned int *max_rate)\r\n{\r\nstruct isp_pipeline *pipe = to_isp_pipeline(&res->subdev.entity);\r\nconst struct v4l2_mbus_framefmt *ofmt = &res->formats[RESZ_PAD_SOURCE];\r\nunsigned long limit = min(pipe->l3_ick, 200000000UL);\r\nunsigned long clock;\r\nclock = div_u64((u64)limit * res->crop.active.height, ofmt->height);\r\nclock = min(clock, limit / 2);\r\n*max_rate = div_u64((u64)clock * res->crop.active.width, ofmt->width);\r\n}\r\nstatic void resizer_adjust_bandwidth(struct isp_res_device *res)\r\n{\r\nstruct isp_pipeline *pipe = to_isp_pipeline(&res->subdev.entity);\r\nstruct isp_device *isp = to_isp_device(res);\r\nunsigned long l3_ick = pipe->l3_ick;\r\nstruct v4l2_fract *timeperframe;\r\nunsigned int cycles_per_frame;\r\nunsigned int requests_per_frame;\r\nunsigned int cycles_per_request;\r\nunsigned int granularity;\r\nunsigned int minimum;\r\nunsigned int maximum;\r\nunsigned int value;\r\nif (res->input != RESIZER_INPUT_MEMORY) {\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_SDR_REQ_EXP,\r\nISPSBL_SDR_REQ_RSZ_EXP_MASK);\r\nreturn;\r\n}\r\nswitch (isp->revision) {\r\ncase ISP_REVISION_1_0:\r\ncase ISP_REVISION_2_0:\r\ndefault:\r\ngranularity = 1024;\r\nbreak;\r\ncase ISP_REVISION_15_0:\r\ngranularity = 32;\r\nbreak;\r\n}\r\ncycles_per_request = div_u64((u64)l3_ick / 2 * 256 + pipe->max_rate - 1,\r\npipe->max_rate);\r\nminimum = DIV_ROUND_UP(cycles_per_request, granularity);\r\ntimeperframe = &pipe->max_timeperframe;\r\nrequests_per_frame = DIV_ROUND_UP(res->crop.active.width * 2, 256)\r\n* res->crop.active.height;\r\ncycles_per_frame = div_u64((u64)l3_ick * timeperframe->numerator,\r\ntimeperframe->denominator);\r\ncycles_per_request = cycles_per_frame / requests_per_frame;\r\nmaximum = cycles_per_request / granularity;\r\nvalue = max(minimum, maximum);\r\ndev_dbg(isp->dev, "%s: cycles per request = %u\n", __func__, value);\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_SDR_REQ_EXP,\r\nISPSBL_SDR_REQ_RSZ_EXP_MASK,\r\nvalue << ISPSBL_SDR_REQ_RSZ_EXP_SHIFT);\r\n}\r\nint omap3isp_resizer_busy(struct isp_res_device *res)\r\n{\r\nstruct isp_device *isp = to_isp_device(res);\r\nreturn isp_reg_readl(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_PCR) &\r\nISPRSZ_PCR_BUSY;\r\n}\r\nstatic void resizer_set_inaddr(struct isp_res_device *res, u32 addr)\r\n{\r\nres->addr_base = addr;\r\nif (res->crop_offset)\r\naddr += res->crop_offset & ~0x1f;\r\n__resizer_set_inaddr(res, addr);\r\n}\r\nstatic void resizer_set_outaddr(struct isp_res_device *res, u32 addr)\r\n{\r\nstruct isp_device *isp = to_isp_device(res);\r\nisp_reg_writel(isp, addr << ISPRSZ_SDR_OUTADD_ADDR_SHIFT,\r\nOMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_OUTADD);\r\n}\r\nstatic void resizer_print_status(struct isp_res_device *res)\r\n{\r\nstruct isp_device *isp = to_isp_device(res);\r\ndev_dbg(isp->dev, "-------------Resizer Register dump----------\n");\r\nRSZ_PRINT_REGISTER(isp, PCR);\r\nRSZ_PRINT_REGISTER(isp, CNT);\r\nRSZ_PRINT_REGISTER(isp, OUT_SIZE);\r\nRSZ_PRINT_REGISTER(isp, IN_START);\r\nRSZ_PRINT_REGISTER(isp, IN_SIZE);\r\nRSZ_PRINT_REGISTER(isp, SDR_INADD);\r\nRSZ_PRINT_REGISTER(isp, SDR_INOFF);\r\nRSZ_PRINT_REGISTER(isp, SDR_OUTADD);\r\nRSZ_PRINT_REGISTER(isp, SDR_OUTOFF);\r\nRSZ_PRINT_REGISTER(isp, YENH);\r\ndev_dbg(isp->dev, "--------------------------------------------\n");\r\n}\r\nstatic void resizer_calc_ratios(struct isp_res_device *res,\r\nstruct v4l2_rect *input,\r\nstruct v4l2_mbus_framefmt *output,\r\nstruct resizer_ratio *ratio)\r\n{\r\nstruct isp_device *isp = to_isp_device(res);\r\nconst unsigned int spv = DEFAULT_PHASE;\r\nconst unsigned int sph = DEFAULT_PHASE;\r\nunsigned int upscaled_width;\r\nunsigned int upscaled_height;\r\nunsigned int min_width;\r\nunsigned int min_height;\r\nunsigned int max_width;\r\nunsigned int max_height;\r\nunsigned int width_alignment;\r\nunsigned int width;\r\nunsigned int height;\r\nmin_height = ((input->height - 7) * 256 - 32 - 64 * spv) / 1024 + 1;\r\nmin_height = max_t(unsigned int, min_height, MIN_OUT_HEIGHT);\r\nmax_height = ((input->height - 4) * 256 + 255 - 16 - 32 * spv) / 64 + 1;\r\nmax_height = min_t(unsigned int, max_height, MAX_OUT_HEIGHT);\r\noutput->height = clamp(output->height, min_height, max_height);\r\nratio->vert = ((input->height - 4) * 256 + 255 - 16 - 32 * spv)\r\n/ (output->height - 1);\r\nif (ratio->vert > MID_RESIZE_VALUE)\r\nratio->vert = ((input->height - 7) * 256 + 255 - 32 - 64 * spv)\r\n/ (output->height - 1);\r\nratio->vert = clamp_t(unsigned int, ratio->vert,\r\nMIN_RESIZE_VALUE, MAX_RESIZE_VALUE);\r\nif (ratio->vert <= MID_RESIZE_VALUE) {\r\nupscaled_height = (output->height - 1) * ratio->vert\r\n+ 32 * spv + 16;\r\nheight = (upscaled_height >> 8) + 4;\r\n} else {\r\nupscaled_height = (output->height - 1) * ratio->vert\r\n+ 64 * spv + 32;\r\nheight = (upscaled_height >> 8) + 7;\r\n}\r\nmin_width = ((input->width - 7) * 256 - 32 - 64 * sph) / 1024 + 1;\r\nmin_width = max_t(unsigned int, min_width, MIN_OUT_WIDTH);\r\nif (ratio->vert <= MID_RESIZE_VALUE) {\r\nswitch (isp->revision) {\r\ncase ISP_REVISION_1_0:\r\nmax_width = MAX_4TAP_OUT_WIDTH_ES1;\r\nbreak;\r\ncase ISP_REVISION_2_0:\r\ndefault:\r\nmax_width = MAX_4TAP_OUT_WIDTH_ES2;\r\nbreak;\r\ncase ISP_REVISION_15_0:\r\nmax_width = MAX_4TAP_OUT_WIDTH_3630;\r\nbreak;\r\n}\r\n} else {\r\nswitch (isp->revision) {\r\ncase ISP_REVISION_1_0:\r\nmax_width = MAX_7TAP_OUT_WIDTH_ES1;\r\nbreak;\r\ncase ISP_REVISION_2_0:\r\ndefault:\r\nmax_width = MAX_7TAP_OUT_WIDTH_ES2;\r\nbreak;\r\ncase ISP_REVISION_15_0:\r\nmax_width = MAX_7TAP_OUT_WIDTH_3630;\r\nbreak;\r\n}\r\n}\r\nmax_width = min(((input->width - 7) * 256 + 255 - 16 - 32 * sph) / 64\r\n+ 1, max_width);\r\nwidth_alignment = ratio->vert < 256 ? 8 : 2;\r\noutput->width = clamp(output->width, min_width,\r\nmax_width & ~(width_alignment - 1));\r\noutput->width = ALIGN(output->width, width_alignment);\r\nratio->horz = ((input->width - 7) * 256 + 255 - 16 - 32 * sph)\r\n/ (output->width - 1);\r\nif (ratio->horz > MID_RESIZE_VALUE)\r\nratio->horz = ((input->width - 7) * 256 + 255 - 32 - 64 * sph)\r\n/ (output->width - 1);\r\nratio->horz = clamp_t(unsigned int, ratio->horz,\r\nMIN_RESIZE_VALUE, MAX_RESIZE_VALUE);\r\nif (ratio->horz <= MID_RESIZE_VALUE) {\r\nupscaled_width = (output->width - 1) * ratio->horz\r\n+ 32 * sph + 16;\r\nwidth = (upscaled_width >> 8) + 7;\r\n} else {\r\nupscaled_width = (output->width - 1) * ratio->horz\r\n+ 64 * sph + 32;\r\nwidth = (upscaled_width >> 8) + 7;\r\n}\r\ninput->left += (input->width - width) / 2;\r\ninput->top += (input->height - height) / 2;\r\ninput->width = width;\r\ninput->height = height;\r\n}\r\nstatic void resizer_set_crop_params(struct isp_res_device *res,\r\nconst struct v4l2_mbus_framefmt *input,\r\nconst struct v4l2_mbus_framefmt *output)\r\n{\r\nresizer_set_ratio(res, &res->ratio);\r\nif (res->ratio.horz >= RESIZE_DIVISOR)\r\nresizer_set_bilinear(res, RSZ_THE_SAME);\r\nelse\r\nresizer_set_bilinear(res, RSZ_BILINEAR);\r\nresizer_adjust_bandwidth(res);\r\nif (res->input == RESIZER_INPUT_MEMORY) {\r\nres->crop_offset = (res->crop.active.top * input->width +\r\nres->crop.active.left) * 2;\r\nresizer_set_start(res, (res->crop_offset / 2) & 0xf, 0);\r\n__resizer_set_inaddr(res,\r\nres->addr_base + (res->crop_offset & ~0x1f));\r\n} else {\r\nresizer_set_start(res, res->crop.active.left * 2,\r\nres->crop.active.top);\r\n__resizer_set_inaddr(res, 0);\r\nresizer_set_input_offset(res, 0);\r\n}\r\nresizer_set_input_size(res, res->crop.active.width,\r\nres->crop.active.height);\r\n}\r\nstatic void resizer_configure(struct isp_res_device *res)\r\n{\r\nstruct v4l2_mbus_framefmt *informat, *outformat;\r\nstruct resizer_luma_yenh luma = {0, 0, 0, 0};\r\nresizer_set_source(res, res->input);\r\ninformat = &res->formats[RESZ_PAD_SINK];\r\noutformat = &res->formats[RESZ_PAD_SOURCE];\r\nif (res->input == RESIZER_INPUT_VP)\r\nresizer_set_input_offset(res, 0);\r\nelse\r\nresizer_set_input_offset(res, ALIGN(informat->width, 0x10) * 2);\r\nresizer_set_intype(res, RSZ_YUV422);\r\nresizer_set_ycpos(res, informat->code);\r\nresizer_set_phase(res, DEFAULT_PHASE, DEFAULT_PHASE);\r\nresizer_set_luma(res, &luma);\r\nresizer_set_output_offset(res, ALIGN(outformat->width * 2, 32));\r\nresizer_set_output_size(res, outformat->width, outformat->height);\r\nresizer_set_crop_params(res, informat, outformat);\r\n}\r\nstatic void resizer_enable_oneshot(struct isp_res_device *res)\r\n{\r\nstruct isp_device *isp = to_isp_device(res);\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_PCR,\r\nISPRSZ_PCR_ENABLE | ISPRSZ_PCR_ONESHOT);\r\n}\r\nvoid omap3isp_resizer_isr_frame_sync(struct isp_res_device *res)\r\n{\r\nif (res->state == ISP_PIPELINE_STREAM_CONTINUOUS &&\r\nres->video_out.dmaqueue_flags & ISP_VIDEO_DMAQUEUE_QUEUED) {\r\nresizer_enable_oneshot(res);\r\nisp_video_dmaqueue_flags_clr(&res->video_out);\r\n}\r\n}\r\nstatic void resizer_isr_buffer(struct isp_res_device *res)\r\n{\r\nstruct isp_pipeline *pipe = to_isp_pipeline(&res->subdev.entity);\r\nstruct isp_buffer *buffer;\r\nint restart = 0;\r\nif (res->state == ISP_PIPELINE_STREAM_STOPPED)\r\nreturn;\r\nbuffer = omap3isp_video_buffer_next(&res->video_out);\r\nif (buffer != NULL) {\r\nresizer_set_outaddr(res, buffer->isp_addr);\r\nrestart = 1;\r\n}\r\npipe->state |= ISP_PIPELINE_IDLE_OUTPUT;\r\nif (res->input == RESIZER_INPUT_MEMORY) {\r\nbuffer = omap3isp_video_buffer_next(&res->video_in);\r\nif (buffer != NULL)\r\nresizer_set_inaddr(res, buffer->isp_addr);\r\npipe->state |= ISP_PIPELINE_IDLE_INPUT;\r\n}\r\nif (res->state == ISP_PIPELINE_STREAM_SINGLESHOT) {\r\nif (isp_pipeline_ready(pipe))\r\nomap3isp_pipeline_set_stream(pipe,\r\nISP_PIPELINE_STREAM_SINGLESHOT);\r\n} else {\r\nif (restart)\r\nresizer_enable_oneshot(res);\r\n}\r\n}\r\nvoid omap3isp_resizer_isr(struct isp_res_device *res)\r\n{\r\nstruct v4l2_mbus_framefmt *informat, *outformat;\r\nif (omap3isp_module_sync_is_stopping(&res->wait, &res->stopping))\r\nreturn;\r\nif (res->applycrop) {\r\noutformat = __resizer_get_format(res, NULL, RESZ_PAD_SOURCE,\r\nV4L2_SUBDEV_FORMAT_ACTIVE);\r\ninformat = __resizer_get_format(res, NULL, RESZ_PAD_SINK,\r\nV4L2_SUBDEV_FORMAT_ACTIVE);\r\nresizer_set_crop_params(res, informat, outformat);\r\nres->applycrop = 0;\r\n}\r\nresizer_isr_buffer(res);\r\n}\r\nstatic int resizer_video_queue(struct isp_video *video,\r\nstruct isp_buffer *buffer)\r\n{\r\nstruct isp_res_device *res = &video->isp->isp_res;\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nresizer_set_inaddr(res, buffer->isp_addr);\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nresizer_set_outaddr(res, buffer->isp_addr);\r\nreturn 0;\r\n}\r\nstatic int resizer_set_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct isp_res_device *res = v4l2_get_subdevdata(sd);\r\nstruct isp_video *video_out = &res->video_out;\r\nstruct isp_device *isp = to_isp_device(res);\r\nstruct device *dev = to_device(res);\r\nif (res->state == ISP_PIPELINE_STREAM_STOPPED) {\r\nif (enable == ISP_PIPELINE_STREAM_STOPPED)\r\nreturn 0;\r\nomap3isp_subclk_enable(isp, OMAP3_ISP_SUBCLK_RESIZER);\r\nresizer_configure(res);\r\nresizer_print_status(res);\r\n}\r\nswitch (enable) {\r\ncase ISP_PIPELINE_STREAM_CONTINUOUS:\r\nomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_RESIZER_WRITE);\r\nif (video_out->dmaqueue_flags & ISP_VIDEO_DMAQUEUE_QUEUED) {\r\nresizer_enable_oneshot(res);\r\nisp_video_dmaqueue_flags_clr(video_out);\r\n}\r\nbreak;\r\ncase ISP_PIPELINE_STREAM_SINGLESHOT:\r\nif (res->input == RESIZER_INPUT_MEMORY)\r\nomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_RESIZER_READ);\r\nomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_RESIZER_WRITE);\r\nresizer_enable_oneshot(res);\r\nbreak;\r\ncase ISP_PIPELINE_STREAM_STOPPED:\r\nif (omap3isp_module_sync_idle(&sd->entity, &res->wait,\r\n&res->stopping))\r\ndev_dbg(dev, "%s: module stop timeout.\n", sd->name);\r\nomap3isp_sbl_disable(isp, OMAP3_ISP_SBL_RESIZER_READ |\r\nOMAP3_ISP_SBL_RESIZER_WRITE);\r\nomap3isp_subclk_disable(isp, OMAP3_ISP_SUBCLK_RESIZER);\r\nisp_video_dmaqueue_flags_clr(video_out);\r\nbreak;\r\n}\r\nres->state = enable;\r\nreturn 0;\r\n}\r\nstatic int resizer_g_crop(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_crop *crop)\r\n{\r\nstruct isp_res_device *res = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nstruct resizer_ratio ratio;\r\nif (crop->pad != RESZ_PAD_SINK)\r\nreturn -EINVAL;\r\nformat = __resizer_get_format(res, fh, RESZ_PAD_SOURCE, crop->which);\r\ncrop->rect = *__resizer_get_crop(res, fh, crop->which);\r\nresizer_calc_ratios(res, &crop->rect, format, &ratio);\r\nreturn 0;\r\n}\r\nstatic void resizer_try_crop(const struct v4l2_mbus_framefmt *sink,\r\nconst struct v4l2_mbus_framefmt *source,\r\nstruct v4l2_rect *crop)\r\n{\r\nconst unsigned int spv = DEFAULT_PHASE;\r\nconst unsigned int sph = DEFAULT_PHASE;\r\nunsigned int min_width =\r\n((32 * sph + (source->width - 1) * 64 + 16) >> 8) + 7;\r\nunsigned int min_height =\r\n((32 * spv + (source->height - 1) * 64 + 16) >> 8) + 4;\r\nunsigned int max_width =\r\n((64 * sph + (source->width - 1) * 1024 + 32) >> 8) + 7;\r\nunsigned int max_height =\r\n((64 * spv + (source->height - 1) * 1024 + 32) >> 8) + 7;\r\ncrop->width = clamp_t(u32, crop->width, min_width, max_width);\r\ncrop->height = clamp_t(u32, crop->height, min_height, max_height);\r\ncrop->left = clamp_t(u32, crop->left, 0, sink->width - MIN_IN_WIDTH);\r\ncrop->width = clamp_t(u32, crop->width, MIN_IN_WIDTH,\r\nsink->width - crop->left);\r\ncrop->top = clamp_t(u32, crop->top, 0, sink->height - MIN_IN_HEIGHT);\r\ncrop->height = clamp_t(u32, crop->height, MIN_IN_HEIGHT,\r\nsink->height - crop->top);\r\n}\r\nstatic int resizer_s_crop(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_crop *crop)\r\n{\r\nstruct isp_res_device *res = v4l2_get_subdevdata(sd);\r\nstruct isp_device *isp = to_isp_device(res);\r\nstruct v4l2_mbus_framefmt *format_sink, *format_source;\r\nstruct resizer_ratio ratio;\r\nif (crop->pad != RESZ_PAD_SINK)\r\nreturn -EINVAL;\r\nformat_sink = __resizer_get_format(res, fh, RESZ_PAD_SINK,\r\ncrop->which);\r\nformat_source = __resizer_get_format(res, fh, RESZ_PAD_SOURCE,\r\ncrop->which);\r\ndev_dbg(isp->dev, "%s: L=%d,T=%d,W=%d,H=%d,which=%d\n", __func__,\r\ncrop->rect.left, crop->rect.top, crop->rect.width,\r\ncrop->rect.height, crop->which);\r\ndev_dbg(isp->dev, "%s: input=%dx%d, output=%dx%d\n", __func__,\r\nformat_sink->width, format_sink->height,\r\nformat_source->width, format_source->height);\r\nresizer_try_crop(format_sink, format_source, &crop->rect);\r\n*__resizer_get_crop(res, fh, crop->which) = crop->rect;\r\nresizer_calc_ratios(res, &crop->rect, format_source, &ratio);\r\nif (crop->which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn 0;\r\nres->ratio = ratio;\r\nres->crop.active = crop->rect;\r\nif (res->state != ISP_PIPELINE_STREAM_STOPPED)\r\nres->applycrop = 1;\r\nreturn 0;\r\n}\r\nstatic unsigned int resizer_max_in_width(struct isp_res_device *res)\r\n{\r\nstruct isp_device *isp = to_isp_device(res);\r\nif (res->input == RESIZER_INPUT_MEMORY) {\r\nreturn MAX_IN_WIDTH_MEMORY_MODE;\r\n} else {\r\nif (isp->revision == ISP_REVISION_1_0)\r\nreturn MAX_IN_WIDTH_ONTHEFLY_MODE_ES1;\r\nelse\r\nreturn MAX_IN_WIDTH_ONTHEFLY_MODE_ES2;\r\n}\r\n}\r\nstatic void resizer_try_format(struct isp_res_device *res,\r\nstruct v4l2_subdev_fh *fh, unsigned int pad,\r\nstruct v4l2_mbus_framefmt *fmt,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nstruct v4l2_mbus_framefmt *format;\r\nstruct resizer_ratio ratio;\r\nstruct v4l2_rect crop;\r\nswitch (pad) {\r\ncase RESZ_PAD_SINK:\r\nif (fmt->code != V4L2_MBUS_FMT_YUYV8_1X16 &&\r\nfmt->code != V4L2_MBUS_FMT_UYVY8_1X16)\r\nfmt->code = V4L2_MBUS_FMT_YUYV8_1X16;\r\nfmt->width = clamp_t(u32, fmt->width, MIN_IN_WIDTH,\r\nresizer_max_in_width(res));\r\nfmt->height = clamp_t(u32, fmt->height, MIN_IN_HEIGHT,\r\nMAX_IN_HEIGHT);\r\nbreak;\r\ncase RESZ_PAD_SOURCE:\r\nformat = __resizer_get_format(res, fh, RESZ_PAD_SINK, which);\r\nfmt->code = format->code;\r\ncrop = *__resizer_get_crop(res, fh, which);\r\nresizer_calc_ratios(res, &crop, fmt, &ratio);\r\nbreak;\r\n}\r\nfmt->colorspace = V4L2_COLORSPACE_JPEG;\r\nfmt->field = V4L2_FIELD_NONE;\r\n}\r\nstatic int resizer_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nstruct isp_res_device *res = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nif (code->pad == RESZ_PAD_SINK) {\r\nif (code->index >= ARRAY_SIZE(resizer_formats))\r\nreturn -EINVAL;\r\ncode->code = resizer_formats[code->index];\r\n} else {\r\nif (code->index != 0)\r\nreturn -EINVAL;\r\nformat = __resizer_get_format(res, fh, RESZ_PAD_SINK,\r\nV4L2_SUBDEV_FORMAT_TRY);\r\ncode->code = format->code;\r\n}\r\nreturn 0;\r\n}\r\nstatic int resizer_enum_frame_size(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct isp_res_device *res = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt format;\r\nif (fse->index != 0)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = 1;\r\nformat.height = 1;\r\nresizer_try_format(res, fh, fse->pad, &format, V4L2_SUBDEV_FORMAT_TRY);\r\nfse->min_width = format.width;\r\nfse->min_height = format.height;\r\nif (format.code != fse->code)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = -1;\r\nformat.height = -1;\r\nresizer_try_format(res, fh, fse->pad, &format, V4L2_SUBDEV_FORMAT_TRY);\r\nfse->max_width = format.width;\r\nfse->max_height = format.height;\r\nreturn 0;\r\n}\r\nstatic int resizer_get_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct isp_res_device *res = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = __resizer_get_format(res, fh, fmt->pad, fmt->which);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nfmt->format = *format;\r\nreturn 0;\r\n}\r\nstatic int resizer_set_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct isp_res_device *res = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nstruct v4l2_rect *crop;\r\nformat = __resizer_get_format(res, fh, fmt->pad, fmt->which);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nresizer_try_format(res, fh, fmt->pad, &fmt->format, fmt->which);\r\n*format = fmt->format;\r\nif (fmt->pad == RESZ_PAD_SINK) {\r\ncrop = __resizer_get_crop(res, fh, fmt->which);\r\ncrop->left = 0;\r\ncrop->top = 0;\r\ncrop->width = fmt->format.width;\r\ncrop->height = fmt->format.height;\r\nformat = __resizer_get_format(res, fh, RESZ_PAD_SOURCE,\r\nfmt->which);\r\n*format = fmt->format;\r\nresizer_try_format(res, fh, RESZ_PAD_SOURCE, format,\r\nfmt->which);\r\n}\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nres->crop.active = res->crop.request;\r\nresizer_calc_ratios(res, &res->crop.active, format,\r\n&res->ratio);\r\n}\r\nreturn 0;\r\n}\r\nstatic int resizer_init_formats(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_subdev_format format;\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = RESZ_PAD_SINK;\r\nformat.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\r\nformat.format.code = V4L2_MBUS_FMT_YUYV8_1X16;\r\nformat.format.width = 4096;\r\nformat.format.height = 4096;\r\nresizer_set_format(sd, fh, &format);\r\nreturn 0;\r\n}\r\nstatic int resizer_link_setup(struct media_entity *entity,\r\nconst struct media_pad *local,\r\nconst struct media_pad *remote, u32 flags)\r\n{\r\nstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\r\nstruct isp_res_device *res = v4l2_get_subdevdata(sd);\r\nswitch (local->index | media_entity_type(remote->entity)) {\r\ncase RESZ_PAD_SINK | MEDIA_ENT_T_DEVNODE:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (res->input == RESIZER_INPUT_VP)\r\nreturn -EBUSY;\r\nres->input = RESIZER_INPUT_MEMORY;\r\n} else {\r\nif (res->input == RESIZER_INPUT_MEMORY)\r\nres->input = RESIZER_INPUT_NONE;\r\n}\r\nbreak;\r\ncase RESZ_PAD_SINK | MEDIA_ENT_T_V4L2_SUBDEV:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (res->input == RESIZER_INPUT_MEMORY)\r\nreturn -EBUSY;\r\nres->input = RESIZER_INPUT_VP;\r\n} else {\r\nif (res->input == RESIZER_INPUT_VP)\r\nres->input = RESIZER_INPUT_NONE;\r\n}\r\nbreak;\r\ncase RESZ_PAD_SOURCE | MEDIA_ENT_T_DEVNODE:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid omap3isp_resizer_unregister_entities(struct isp_res_device *res)\r\n{\r\nv4l2_device_unregister_subdev(&res->subdev);\r\nomap3isp_video_unregister(&res->video_in);\r\nomap3isp_video_unregister(&res->video_out);\r\n}\r\nint omap3isp_resizer_register_entities(struct isp_res_device *res,\r\nstruct v4l2_device *vdev)\r\n{\r\nint ret;\r\nret = v4l2_device_register_subdev(vdev, &res->subdev);\r\nif (ret < 0)\r\ngoto error;\r\nret = omap3isp_video_register(&res->video_in, vdev);\r\nif (ret < 0)\r\ngoto error;\r\nret = omap3isp_video_register(&res->video_out, vdev);\r\nif (ret < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nomap3isp_resizer_unregister_entities(res);\r\nreturn ret;\r\n}\r\nstatic int resizer_init_entities(struct isp_res_device *res)\r\n{\r\nstruct v4l2_subdev *sd = &res->subdev;\r\nstruct media_pad *pads = res->pads;\r\nstruct media_entity *me = &sd->entity;\r\nint ret;\r\nres->input = RESIZER_INPUT_NONE;\r\nv4l2_subdev_init(sd, &resizer_v4l2_ops);\r\nsd->internal_ops = &resizer_v4l2_internal_ops;\r\nstrlcpy(sd->name, "OMAP3 ISP resizer", sizeof(sd->name));\r\nsd->grp_id = 1 << 16;\r\nv4l2_set_subdevdata(sd, res);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\npads[RESZ_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\r\npads[RESZ_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\r\nme->ops = &resizer_media_ops;\r\nret = media_entity_init(me, RESZ_PADS_NUM, pads, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nresizer_init_formats(sd, NULL);\r\nres->video_in.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nres->video_in.ops = &resizer_video_ops;\r\nres->video_in.isp = to_isp_device(res);\r\nres->video_in.capture_mem = PAGE_ALIGN(4096 * 4096) * 2 * 3;\r\nres->video_in.bpl_alignment = 32;\r\nres->video_out.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nres->video_out.ops = &resizer_video_ops;\r\nres->video_out.isp = to_isp_device(res);\r\nres->video_out.capture_mem = PAGE_ALIGN(4096 * 4096) * 2 * 3;\r\nres->video_out.bpl_alignment = 32;\r\nret = omap3isp_video_init(&res->video_in, "resizer");\r\nif (ret < 0)\r\ngoto error_video_in;\r\nret = omap3isp_video_init(&res->video_out, "resizer");\r\nif (ret < 0)\r\ngoto error_video_out;\r\nret = media_entity_create_link(&res->video_in.video.entity, 0,\r\n&res->subdev.entity, RESZ_PAD_SINK, 0);\r\nif (ret < 0)\r\ngoto error_link;\r\nret = media_entity_create_link(&res->subdev.entity, RESZ_PAD_SOURCE,\r\n&res->video_out.video.entity, 0, 0);\r\nif (ret < 0)\r\ngoto error_link;\r\nreturn 0;\r\nerror_link:\r\nomap3isp_video_cleanup(&res->video_out);\r\nerror_video_out:\r\nomap3isp_video_cleanup(&res->video_in);\r\nerror_video_in:\r\nmedia_entity_cleanup(&res->subdev.entity);\r\nreturn ret;\r\n}\r\nint omap3isp_resizer_init(struct isp_device *isp)\r\n{\r\nstruct isp_res_device *res = &isp->isp_res;\r\ninit_waitqueue_head(&res->wait);\r\natomic_set(&res->stopping, 0);\r\nreturn resizer_init_entities(res);\r\n}\r\nvoid omap3isp_resizer_cleanup(struct isp_device *isp)\r\n{\r\nstruct isp_res_device *res = &isp->isp_res;\r\nomap3isp_video_cleanup(&res->video_in);\r\nomap3isp_video_cleanup(&res->video_out);\r\nmedia_entity_cleanup(&res->subdev.entity);\r\n}
