static void radeon_fence_write(struct radeon_device *rdev, u32 seq, int ring)\r\n{\r\nif (rdev->wb.enabled) {\r\n*rdev->fence_drv[ring].cpu_addr = cpu_to_le32(seq);\r\n} else {\r\nWREG32(rdev->fence_drv[ring].scratch_reg, seq);\r\n}\r\n}\r\nstatic u32 radeon_fence_read(struct radeon_device *rdev, int ring)\r\n{\r\nu32 seq = 0;\r\nif (rdev->wb.enabled) {\r\nseq = le32_to_cpu(*rdev->fence_drv[ring].cpu_addr);\r\n} else {\r\nseq = RREG32(rdev->fence_drv[ring].scratch_reg);\r\n}\r\nreturn seq;\r\n}\r\nint radeon_fence_emit(struct radeon_device *rdev, struct radeon_fence *fence)\r\n{\r\nunsigned long irq_flags;\r\nwrite_lock_irqsave(&rdev->fence_lock, irq_flags);\r\nif (fence->emitted) {\r\nwrite_unlock_irqrestore(&rdev->fence_lock, irq_flags);\r\nreturn 0;\r\n}\r\nfence->seq = atomic_add_return(1, &rdev->fence_drv[fence->ring].seq);\r\nif (!rdev->ring[fence->ring].ready)\r\nradeon_fence_write(rdev, fence->seq, fence->ring);\r\nelse\r\nradeon_fence_ring_emit(rdev, fence->ring, fence);\r\ntrace_radeon_fence_emit(rdev->ddev, fence->seq);\r\nfence->emitted = true;\r\nlist_move_tail(&fence->list, &rdev->fence_drv[fence->ring].emitted);\r\nwrite_unlock_irqrestore(&rdev->fence_lock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic bool radeon_fence_poll_locked(struct radeon_device *rdev, int ring)\r\n{\r\nstruct radeon_fence *fence;\r\nstruct list_head *i, *n;\r\nuint32_t seq;\r\nbool wake = false;\r\nunsigned long cjiffies;\r\nseq = radeon_fence_read(rdev, ring);\r\nif (seq != rdev->fence_drv[ring].last_seq) {\r\nrdev->fence_drv[ring].last_seq = seq;\r\nrdev->fence_drv[ring].last_jiffies = jiffies;\r\nrdev->fence_drv[ring].last_timeout = RADEON_FENCE_JIFFIES_TIMEOUT;\r\n} else {\r\ncjiffies = jiffies;\r\nif (time_after(cjiffies, rdev->fence_drv[ring].last_jiffies)) {\r\ncjiffies -= rdev->fence_drv[ring].last_jiffies;\r\nif (time_after(rdev->fence_drv[ring].last_timeout, cjiffies)) {\r\nrdev->fence_drv[ring].last_timeout -= cjiffies;\r\n} else {\r\nrdev->fence_drv[ring].last_timeout = 1;\r\n}\r\n} else {\r\nrdev->fence_drv[ring].last_jiffies = cjiffies;\r\n}\r\nreturn false;\r\n}\r\nn = NULL;\r\nlist_for_each(i, &rdev->fence_drv[ring].emitted) {\r\nfence = list_entry(i, struct radeon_fence, list);\r\nif (fence->seq == seq) {\r\nn = i;\r\nbreak;\r\n}\r\n}\r\nif (n) {\r\ni = n;\r\ndo {\r\nn = i->prev;\r\nlist_move_tail(i, &rdev->fence_drv[ring].signaled);\r\nfence = list_entry(i, struct radeon_fence, list);\r\nfence->signaled = true;\r\ni = n;\r\n} while (i != &rdev->fence_drv[ring].emitted);\r\nwake = true;\r\n}\r\nreturn wake;\r\n}\r\nstatic void radeon_fence_destroy(struct kref *kref)\r\n{\r\nunsigned long irq_flags;\r\nstruct radeon_fence *fence;\r\nfence = container_of(kref, struct radeon_fence, kref);\r\nwrite_lock_irqsave(&fence->rdev->fence_lock, irq_flags);\r\nlist_del(&fence->list);\r\nfence->emitted = false;\r\nwrite_unlock_irqrestore(&fence->rdev->fence_lock, irq_flags);\r\nif (fence->semaphore)\r\nradeon_semaphore_free(fence->rdev, fence->semaphore);\r\nkfree(fence);\r\n}\r\nint radeon_fence_create(struct radeon_device *rdev,\r\nstruct radeon_fence **fence,\r\nint ring)\r\n{\r\nunsigned long irq_flags;\r\n*fence = kmalloc(sizeof(struct radeon_fence), GFP_KERNEL);\r\nif ((*fence) == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nkref_init(&((*fence)->kref));\r\n(*fence)->rdev = rdev;\r\n(*fence)->emitted = false;\r\n(*fence)->signaled = false;\r\n(*fence)->seq = 0;\r\n(*fence)->ring = ring;\r\n(*fence)->semaphore = NULL;\r\nINIT_LIST_HEAD(&(*fence)->list);\r\nwrite_lock_irqsave(&rdev->fence_lock, irq_flags);\r\nlist_add_tail(&(*fence)->list, &rdev->fence_drv[ring].created);\r\nwrite_unlock_irqrestore(&rdev->fence_lock, irq_flags);\r\nreturn 0;\r\n}\r\nbool radeon_fence_signaled(struct radeon_fence *fence)\r\n{\r\nunsigned long irq_flags;\r\nbool signaled = false;\r\nif (!fence)\r\nreturn true;\r\nif (fence->rdev->gpu_lockup)\r\nreturn true;\r\nwrite_lock_irqsave(&fence->rdev->fence_lock, irq_flags);\r\nsignaled = fence->signaled;\r\nif (fence->rdev->shutdown) {\r\nsignaled = true;\r\n}\r\nif (!fence->emitted) {\r\nWARN(1, "Querying an unemitted fence : %p !\n", fence);\r\nsignaled = true;\r\n}\r\nif (!signaled) {\r\nradeon_fence_poll_locked(fence->rdev, fence->ring);\r\nsignaled = fence->signaled;\r\n}\r\nwrite_unlock_irqrestore(&fence->rdev->fence_lock, irq_flags);\r\nreturn signaled;\r\n}\r\nint radeon_fence_wait(struct radeon_fence *fence, bool intr)\r\n{\r\nstruct radeon_device *rdev;\r\nunsigned long irq_flags, timeout;\r\nu32 seq;\r\nint r;\r\nif (fence == NULL) {\r\nWARN(1, "Querying an invalid fence : %p !\n", fence);\r\nreturn 0;\r\n}\r\nrdev = fence->rdev;\r\nif (radeon_fence_signaled(fence)) {\r\nreturn 0;\r\n}\r\ntimeout = rdev->fence_drv[fence->ring].last_timeout;\r\nretry:\r\nseq = rdev->fence_drv[fence->ring].last_seq;\r\ntrace_radeon_fence_wait_begin(rdev->ddev, seq);\r\nif (intr) {\r\nradeon_irq_kms_sw_irq_get(rdev, fence->ring);\r\nr = wait_event_interruptible_timeout(rdev->fence_drv[fence->ring].queue,\r\nradeon_fence_signaled(fence), timeout);\r\nradeon_irq_kms_sw_irq_put(rdev, fence->ring);\r\nif (unlikely(r < 0)) {\r\nreturn r;\r\n}\r\n} else {\r\nradeon_irq_kms_sw_irq_get(rdev, fence->ring);\r\nr = wait_event_timeout(rdev->fence_drv[fence->ring].queue,\r\nradeon_fence_signaled(fence), timeout);\r\nradeon_irq_kms_sw_irq_put(rdev, fence->ring);\r\n}\r\ntrace_radeon_fence_wait_end(rdev->ddev, seq);\r\nif (unlikely(!radeon_fence_signaled(fence))) {\r\nif (r) {\r\ntimeout = r;\r\ngoto retry;\r\n}\r\nif (seq == rdev->fence_drv[fence->ring].last_seq &&\r\nradeon_gpu_is_lockup(rdev, &rdev->ring[fence->ring])) {\r\nprintk(KERN_WARNING "GPU lockup (waiting for 0x%08X last fence id 0x%08X)\n",\r\nfence->seq, seq);\r\nrdev->gpu_lockup = true;\r\nr = radeon_gpu_reset(rdev);\r\nif (r)\r\nreturn r;\r\nradeon_fence_write(rdev, fence->seq, fence->ring);\r\nrdev->gpu_lockup = false;\r\n}\r\ntimeout = RADEON_FENCE_JIFFIES_TIMEOUT;\r\nwrite_lock_irqsave(&rdev->fence_lock, irq_flags);\r\nrdev->fence_drv[fence->ring].last_timeout = RADEON_FENCE_JIFFIES_TIMEOUT;\r\nrdev->fence_drv[fence->ring].last_jiffies = jiffies;\r\nwrite_unlock_irqrestore(&rdev->fence_lock, irq_flags);\r\ngoto retry;\r\n}\r\nreturn 0;\r\n}\r\nint radeon_fence_wait_next(struct radeon_device *rdev, int ring)\r\n{\r\nunsigned long irq_flags;\r\nstruct radeon_fence *fence;\r\nint r;\r\nif (rdev->gpu_lockup) {\r\nreturn 0;\r\n}\r\nwrite_lock_irqsave(&rdev->fence_lock, irq_flags);\r\nif (list_empty(&rdev->fence_drv[ring].emitted)) {\r\nwrite_unlock_irqrestore(&rdev->fence_lock, irq_flags);\r\nreturn 0;\r\n}\r\nfence = list_entry(rdev->fence_drv[ring].emitted.next,\r\nstruct radeon_fence, list);\r\nradeon_fence_ref(fence);\r\nwrite_unlock_irqrestore(&rdev->fence_lock, irq_flags);\r\nr = radeon_fence_wait(fence, false);\r\nradeon_fence_unref(&fence);\r\nreturn r;\r\n}\r\nint radeon_fence_wait_last(struct radeon_device *rdev, int ring)\r\n{\r\nunsigned long irq_flags;\r\nstruct radeon_fence *fence;\r\nint r;\r\nif (rdev->gpu_lockup) {\r\nreturn 0;\r\n}\r\nwrite_lock_irqsave(&rdev->fence_lock, irq_flags);\r\nif (list_empty(&rdev->fence_drv[ring].emitted)) {\r\nwrite_unlock_irqrestore(&rdev->fence_lock, irq_flags);\r\nreturn 0;\r\n}\r\nfence = list_entry(rdev->fence_drv[ring].emitted.prev,\r\nstruct radeon_fence, list);\r\nradeon_fence_ref(fence);\r\nwrite_unlock_irqrestore(&rdev->fence_lock, irq_flags);\r\nr = radeon_fence_wait(fence, false);\r\nradeon_fence_unref(&fence);\r\nreturn r;\r\n}\r\nstruct radeon_fence *radeon_fence_ref(struct radeon_fence *fence)\r\n{\r\nkref_get(&fence->kref);\r\nreturn fence;\r\n}\r\nvoid radeon_fence_unref(struct radeon_fence **fence)\r\n{\r\nstruct radeon_fence *tmp = *fence;\r\n*fence = NULL;\r\nif (tmp) {\r\nkref_put(&tmp->kref, radeon_fence_destroy);\r\n}\r\n}\r\nvoid radeon_fence_process(struct radeon_device *rdev, int ring)\r\n{\r\nunsigned long irq_flags;\r\nbool wake;\r\nwrite_lock_irqsave(&rdev->fence_lock, irq_flags);\r\nwake = radeon_fence_poll_locked(rdev, ring);\r\nwrite_unlock_irqrestore(&rdev->fence_lock, irq_flags);\r\nif (wake) {\r\nwake_up_all(&rdev->fence_drv[ring].queue);\r\n}\r\n}\r\nint radeon_fence_count_emitted(struct radeon_device *rdev, int ring)\r\n{\r\nunsigned long irq_flags;\r\nint not_processed = 0;\r\nread_lock_irqsave(&rdev->fence_lock, irq_flags);\r\nif (!rdev->fence_drv[ring].initialized) {\r\nread_unlock_irqrestore(&rdev->fence_lock, irq_flags);\r\nreturn 0;\r\n}\r\nif (!list_empty(&rdev->fence_drv[ring].emitted)) {\r\nstruct list_head *ptr;\r\nlist_for_each(ptr, &rdev->fence_drv[ring].emitted) {\r\nif (++not_processed >= 3)\r\nbreak;\r\n}\r\n}\r\nread_unlock_irqrestore(&rdev->fence_lock, irq_flags);\r\nreturn not_processed;\r\n}\r\nint radeon_fence_driver_start_ring(struct radeon_device *rdev, int ring)\r\n{\r\nunsigned long irq_flags;\r\nuint64_t index;\r\nint r;\r\nwrite_lock_irqsave(&rdev->fence_lock, irq_flags);\r\nradeon_scratch_free(rdev, rdev->fence_drv[ring].scratch_reg);\r\nif (rdev->wb.use_event) {\r\nrdev->fence_drv[ring].scratch_reg = 0;\r\nindex = R600_WB_EVENT_OFFSET + ring * 4;\r\n} else {\r\nr = radeon_scratch_get(rdev, &rdev->fence_drv[ring].scratch_reg);\r\nif (r) {\r\ndev_err(rdev->dev, "fence failed to get scratch register\n");\r\nwrite_unlock_irqrestore(&rdev->fence_lock, irq_flags);\r\nreturn r;\r\n}\r\nindex = RADEON_WB_SCRATCH_OFFSET +\r\nrdev->fence_drv[ring].scratch_reg -\r\nrdev->scratch.reg_base;\r\n}\r\nrdev->fence_drv[ring].cpu_addr = &rdev->wb.wb[index/4];\r\nrdev->fence_drv[ring].gpu_addr = rdev->wb.gpu_addr + index;\r\nradeon_fence_write(rdev, atomic_read(&rdev->fence_drv[ring].seq), ring);\r\nrdev->fence_drv[ring].initialized = true;\r\nDRM_INFO("fence driver on ring %d use gpu addr 0x%08Lx and cpu addr 0x%p\n",\r\nring, rdev->fence_drv[ring].gpu_addr, rdev->fence_drv[ring].cpu_addr);\r\nwrite_unlock_irqrestore(&rdev->fence_lock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic void radeon_fence_driver_init_ring(struct radeon_device *rdev, int ring)\r\n{\r\nrdev->fence_drv[ring].scratch_reg = -1;\r\nrdev->fence_drv[ring].cpu_addr = NULL;\r\nrdev->fence_drv[ring].gpu_addr = 0;\r\natomic_set(&rdev->fence_drv[ring].seq, 0);\r\nINIT_LIST_HEAD(&rdev->fence_drv[ring].created);\r\nINIT_LIST_HEAD(&rdev->fence_drv[ring].emitted);\r\nINIT_LIST_HEAD(&rdev->fence_drv[ring].signaled);\r\ninit_waitqueue_head(&rdev->fence_drv[ring].queue);\r\nrdev->fence_drv[ring].initialized = false;\r\n}\r\nint radeon_fence_driver_init(struct radeon_device *rdev)\r\n{\r\nunsigned long irq_flags;\r\nint ring;\r\nwrite_lock_irqsave(&rdev->fence_lock, irq_flags);\r\nfor (ring = 0; ring < RADEON_NUM_RINGS; ring++) {\r\nradeon_fence_driver_init_ring(rdev, ring);\r\n}\r\nwrite_unlock_irqrestore(&rdev->fence_lock, irq_flags);\r\nif (radeon_debugfs_fence_init(rdev)) {\r\ndev_err(rdev->dev, "fence debugfs file creation failed\n");\r\n}\r\nreturn 0;\r\n}\r\nvoid radeon_fence_driver_fini(struct radeon_device *rdev)\r\n{\r\nunsigned long irq_flags;\r\nint ring;\r\nfor (ring = 0; ring < RADEON_NUM_RINGS; ring++) {\r\nif (!rdev->fence_drv[ring].initialized)\r\ncontinue;\r\nradeon_fence_wait_last(rdev, ring);\r\nwake_up_all(&rdev->fence_drv[ring].queue);\r\nwrite_lock_irqsave(&rdev->fence_lock, irq_flags);\r\nradeon_scratch_free(rdev, rdev->fence_drv[ring].scratch_reg);\r\nwrite_unlock_irqrestore(&rdev->fence_lock, irq_flags);\r\nrdev->fence_drv[ring].initialized = false;\r\n}\r\n}\r\nstatic int radeon_debugfs_fence_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *)m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_fence *fence;\r\nint i;\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\r\nif (!rdev->fence_drv[i].initialized)\r\ncontinue;\r\nseq_printf(m, "--- ring %d ---\n", i);\r\nseq_printf(m, "Last signaled fence 0x%08X\n",\r\nradeon_fence_read(rdev, i));\r\nif (!list_empty(&rdev->fence_drv[i].emitted)) {\r\nfence = list_entry(rdev->fence_drv[i].emitted.prev,\r\nstruct radeon_fence, list);\r\nseq_printf(m, "Last emitted fence %p with 0x%08X\n",\r\nfence, fence->seq);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint radeon_debugfs_fence_init(struct radeon_device *rdev)\r\n{\r\n#if defined(CONFIG_DEBUG_FS)\r\nreturn radeon_debugfs_add_files(rdev, radeon_debugfs_fence_list, 1);\r\n#else\r\nreturn 0;\r\n#endif\r\n}
