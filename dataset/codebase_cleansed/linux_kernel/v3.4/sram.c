int bcom_sram_init(struct device_node *sram_node, char *owner)\r\n{\r\nint rv;\r\nconst u32 *regaddr_p;\r\nu64 regaddr64, size64;\r\nunsigned int psize;\r\nif (bcom_sram) {\r\nprintk(KERN_ERR "%s: bcom_sram_init: "\r\n"Already initialized !\n", owner);\r\nreturn -EBUSY;\r\n}\r\nbcom_sram = kmalloc(sizeof(struct bcom_sram), GFP_KERNEL);\r\nif (!bcom_sram) {\r\nprintk(KERN_ERR "%s: bcom_sram_init: "\r\n"Couldn't allocate internal state !\n", owner);\r\nreturn -ENOMEM;\r\n}\r\nregaddr_p = of_get_address(sram_node, 0, &size64, NULL);\r\nif (!regaddr_p) {\r\nprintk(KERN_ERR "%s: bcom_sram_init: "\r\n"Invalid device node !\n", owner);\r\nrv = -EINVAL;\r\ngoto error_free;\r\n}\r\nregaddr64 = of_translate_address(sram_node, regaddr_p);\r\nbcom_sram->base_phys = (phys_addr_t) regaddr64;\r\nbcom_sram->size = (unsigned int) size64;\r\nif (!request_mem_region(bcom_sram->base_phys, bcom_sram->size, owner)) {\r\nprintk(KERN_ERR "%s: bcom_sram_init: "\r\n"Couldn't request region !\n", owner);\r\nrv = -EBUSY;\r\ngoto error_free;\r\n}\r\nbcom_sram->base_virt = (void*) ioremap(bcom_sram->base_phys, bcom_sram->size);\r\nif (!bcom_sram->base_virt) {\r\nprintk(KERN_ERR "%s: bcom_sram_init: "\r\n"Map error SRAM zone 0x%08lx (0x%0x)!\n",\r\nowner, (long)bcom_sram->base_phys, bcom_sram->size );\r\nrv = -ENOMEM;\r\ngoto error_release;\r\n}\r\nbcom_sram->rh = rh_create(4);\r\n#if 0\r\nreg_addr_p = of_get_property(sram_node, "available", &psize);\r\n#else\r\nregaddr_p = NULL;\r\npsize = 0;\r\n#endif\r\nif (!regaddr_p || !psize) {\r\nrh_attach_region(bcom_sram->rh, 0, bcom_sram->size);\r\n} else {\r\nwhile (psize >= 2 * sizeof(u32)) {\r\nphys_addr_t zbase = of_translate_address(sram_node, regaddr_p);\r\nrh_attach_region(bcom_sram->rh, zbase - bcom_sram->base_phys, regaddr_p[1]);\r\nregaddr_p += 2;\r\npsize -= 2 * sizeof(u32);\r\n}\r\n}\r\nspin_lock_init(&bcom_sram->lock);\r\nreturn 0;\r\nerror_release:\r\nrelease_mem_region(bcom_sram->base_phys, bcom_sram->size);\r\nerror_free:\r\nkfree(bcom_sram);\r\nbcom_sram = NULL;\r\nreturn rv;\r\n}\r\nvoid bcom_sram_cleanup(void)\r\n{\r\nif (bcom_sram) {\r\nrh_destroy(bcom_sram->rh);\r\niounmap((void __iomem *)bcom_sram->base_virt);\r\nrelease_mem_region(bcom_sram->base_phys, bcom_sram->size);\r\nkfree(bcom_sram);\r\nbcom_sram = NULL;\r\n}\r\n}\r\nvoid* bcom_sram_alloc(int size, int align, phys_addr_t *phys)\r\n{\r\nunsigned long offset;\r\nspin_lock(&bcom_sram->lock);\r\noffset = rh_alloc_align(bcom_sram->rh, size, align, NULL);\r\nspin_unlock(&bcom_sram->lock);\r\nif (IS_ERR_VALUE(offset))\r\nreturn NULL;\r\n*phys = bcom_sram->base_phys + offset;\r\nreturn bcom_sram->base_virt + offset;\r\n}\r\nvoid bcom_sram_free(void *ptr)\r\n{\r\nunsigned long offset;\r\nif (!ptr)\r\nreturn;\r\noffset = ptr - bcom_sram->base_virt;\r\nspin_lock(&bcom_sram->lock);\r\nrh_free(bcom_sram->rh, offset);\r\nspin_unlock(&bcom_sram->lock);\r\n}
