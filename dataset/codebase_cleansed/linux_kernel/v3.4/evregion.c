acpi_status acpi_ev_install_region_handlers(void)\r\n{\r\nacpi_status status;\r\nu32 i;\r\nACPI_FUNCTION_TRACE(ev_install_region_handlers);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nfor (i = 0; i < ACPI_NUM_DEFAULT_SPACES; i++) {\r\nstatus = acpi_ev_install_space_handler(acpi_gbl_root_node,\r\nacpi_gbl_default_address_spaces\r\n[i],\r\nACPI_DEFAULT_HANDLER,\r\nNULL, NULL);\r\nswitch (status) {\r\ncase AE_OK:\r\ncase AE_SAME_HANDLER:\r\ncase AE_ALREADY_EXISTS:\r\nstatus = AE_OK;\r\nbreak;\r\ndefault:\r\ngoto unlock_and_exit;\r\n}\r\n}\r\nunlock_and_exit:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatic u8\r\nacpi_ev_has_default_handler(struct acpi_namespace_node *node,\r\nacpi_adr_space_type space_id)\r\n{\r\nunion acpi_operand_object *obj_desc;\r\nunion acpi_operand_object *handler_obj;\r\nobj_desc = acpi_ns_get_attached_object(node);\r\nif (obj_desc) {\r\nhandler_obj = obj_desc->device.handler;\r\nwhile (handler_obj) {\r\nif (handler_obj->address_space.space_id == space_id) {\r\nif (handler_obj->address_space.handler_flags &\r\nACPI_ADDR_HANDLER_DEFAULT_INSTALLED) {\r\nreturn (TRUE);\r\n}\r\n}\r\nhandler_obj = handler_obj->address_space.next;\r\n}\r\n}\r\nreturn (FALSE);\r\n}\r\nacpi_status acpi_ev_initialize_op_regions(void)\r\n{\r\nacpi_status status;\r\nu32 i;\r\nACPI_FUNCTION_TRACE(ev_initialize_op_regions);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nfor (i = 0; i < ACPI_NUM_DEFAULT_SPACES; i++) {\r\nif (acpi_ev_has_default_handler(acpi_gbl_root_node,\r\nacpi_gbl_default_address_spaces\r\n[i])) {\r\nstatus =\r\nacpi_ev_execute_reg_methods(acpi_gbl_root_node,\r\nacpi_gbl_default_address_spaces\r\n[i]);\r\n}\r\n}\r\nacpi_gbl_reg_methods_executed = TRUE;\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_ev_execute_reg_method(union acpi_operand_object *region_obj, u32 function)\r\n{\r\nstruct acpi_evaluate_info *info;\r\nunion acpi_operand_object *args[3];\r\nunion acpi_operand_object *region_obj2;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ev_execute_reg_method);\r\nregion_obj2 = acpi_ns_get_secondary_object(region_obj);\r\nif (!region_obj2) {\r\nreturn_ACPI_STATUS(AE_NOT_EXIST);\r\n}\r\nif (region_obj2->extra.method_REG == NULL) {\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\ninfo = ACPI_ALLOCATE_ZEROED(sizeof(struct acpi_evaluate_info));\r\nif (!info) {\r\nreturn_ACPI_STATUS(AE_NO_MEMORY);\r\n}\r\ninfo->prefix_node = region_obj2->extra.method_REG;\r\ninfo->pathname = NULL;\r\ninfo->parameters = args;\r\ninfo->flags = ACPI_IGNORE_RETURN_VALUE;\r\nargs[0] =\r\nacpi_ut_create_integer_object((u64) region_obj->region.space_id);\r\nif (!args[0]) {\r\nstatus = AE_NO_MEMORY;\r\ngoto cleanup1;\r\n}\r\nargs[1] = acpi_ut_create_integer_object((u64) function);\r\nif (!args[1]) {\r\nstatus = AE_NO_MEMORY;\r\ngoto cleanup2;\r\n}\r\nargs[2] = NULL;\r\nACPI_DEBUG_EXEC(acpi_ut_display_init_pathname\r\n(ACPI_TYPE_METHOD, info->prefix_node, NULL));\r\nstatus = acpi_ns_evaluate(info);\r\nacpi_ut_remove_reference(args[1]);\r\ncleanup2:\r\nacpi_ut_remove_reference(args[0]);\r\ncleanup1:\r\nACPI_FREE(info);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_ev_address_space_dispatch(union acpi_operand_object *region_obj,\r\nunion acpi_operand_object *field_obj,\r\nu32 function,\r\nu32 region_offset, u32 bit_width, u64 *value)\r\n{\r\nacpi_status status;\r\nacpi_adr_space_handler handler;\r\nacpi_adr_space_setup region_setup;\r\nunion acpi_operand_object *handler_desc;\r\nunion acpi_operand_object *region_obj2;\r\nvoid *region_context = NULL;\r\nstruct acpi_connection_info *context;\r\nACPI_FUNCTION_TRACE(ev_address_space_dispatch);\r\nregion_obj2 = acpi_ns_get_secondary_object(region_obj);\r\nif (!region_obj2) {\r\nreturn_ACPI_STATUS(AE_NOT_EXIST);\r\n}\r\nhandler_desc = region_obj->region.handler;\r\nif (!handler_desc) {\r\nACPI_ERROR((AE_INFO,\r\n"No handler for Region [%4.4s] (%p) [%s]",\r\nacpi_ut_get_node_name(region_obj->region.node),\r\nregion_obj,\r\nacpi_ut_get_region_name(region_obj->region.\r\nspace_id)));\r\nreturn_ACPI_STATUS(AE_NOT_EXIST);\r\n}\r\ncontext = handler_desc->address_space.context;\r\nif (!(region_obj->region.flags & AOPOBJ_SETUP_COMPLETE)) {\r\nregion_setup = handler_desc->address_space.setup;\r\nif (!region_setup) {\r\nACPI_ERROR((AE_INFO,\r\n"No init routine for region(%p) [%s]",\r\nregion_obj,\r\nacpi_ut_get_region_name(region_obj->region.\r\nspace_id)));\r\nreturn_ACPI_STATUS(AE_NOT_EXIST);\r\n}\r\nacpi_ex_exit_interpreter();\r\nstatus = region_setup(region_obj, ACPI_REGION_ACTIVATE,\r\ncontext, &region_context);\r\nacpi_ex_enter_interpreter();\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"During region initialization: [%s]",\r\nacpi_ut_get_region_name(region_obj->\r\nregion.\r\nspace_id)));\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (!(region_obj->region.flags & AOPOBJ_SETUP_COMPLETE)) {\r\nregion_obj->region.flags |= AOPOBJ_SETUP_COMPLETE;\r\nif (region_obj2->extra.region_context) {\r\nACPI_FREE(region_context);\r\n} else {\r\nregion_obj2->extra.region_context =\r\nregion_context;\r\n}\r\n}\r\n}\r\nhandler = handler_desc->address_space.handler;\r\nACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\r\n"Handler %p (@%p) Address %8.8X%8.8X [%s]\n",\r\n&region_obj->region.handler->address_space, handler,\r\nACPI_FORMAT_NATIVE_UINT(region_obj->region.address +\r\nregion_offset),\r\nacpi_ut_get_region_name(region_obj->region.\r\nspace_id)));\r\nif (((region_obj->region.space_id == ACPI_ADR_SPACE_GSBUS) ||\r\n(region_obj->region.space_id == ACPI_ADR_SPACE_GPIO)) &&\r\ncontext && field_obj) {\r\ncontext->connection = field_obj->field.resource_buffer;\r\ncontext->length = field_obj->field.resource_length;\r\ncontext->access_length = field_obj->field.access_length;\r\n}\r\nif (!(handler_desc->address_space.handler_flags &\r\nACPI_ADDR_HANDLER_DEFAULT_INSTALLED)) {\r\nacpi_ex_exit_interpreter();\r\n}\r\nstatus = handler(function,\r\n(region_obj->region.address + region_offset),\r\nbit_width, value, context,\r\nregion_obj2->extra.region_context);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Returned by Handler for [%s]",\r\nacpi_ut_get_region_name(region_obj->region.\r\nspace_id)));\r\n}\r\nif (!(handler_desc->address_space.handler_flags &\r\nACPI_ADDR_HANDLER_DEFAULT_INSTALLED)) {\r\nacpi_ex_enter_interpreter();\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nvoid\r\nacpi_ev_detach_region(union acpi_operand_object *region_obj,\r\nu8 acpi_ns_is_locked)\r\n{\r\nunion acpi_operand_object *handler_obj;\r\nunion acpi_operand_object *obj_desc;\r\nunion acpi_operand_object **last_obj_ptr;\r\nacpi_adr_space_setup region_setup;\r\nvoid **region_context;\r\nunion acpi_operand_object *region_obj2;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ev_detach_region);\r\nregion_obj2 = acpi_ns_get_secondary_object(region_obj);\r\nif (!region_obj2) {\r\nreturn_VOID;\r\n}\r\nregion_context = &region_obj2->extra.region_context;\r\nhandler_obj = region_obj->region.handler;\r\nif (!handler_obj) {\r\nreturn_VOID;\r\n}\r\nobj_desc = handler_obj->address_space.region_list;\r\nlast_obj_ptr = &handler_obj->address_space.region_list;\r\nwhile (obj_desc) {\r\nif (obj_desc == region_obj) {\r\nACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\r\n"Removing Region %p from address handler %p\n",\r\nregion_obj, handler_obj));\r\n*last_obj_ptr = obj_desc->region.next;\r\nobj_desc->region.next = NULL;\r\nif (acpi_ns_is_locked) {\r\nstatus =\r\nacpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_VOID;\r\n}\r\n}\r\nstatus =\r\nacpi_ev_execute_reg_method(region_obj,\r\nACPI_REG_DISCONNECT);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"from region _REG, [%s]",\r\nacpi_ut_get_region_name\r\n(region_obj->region.space_id)));\r\n}\r\nif (acpi_ns_is_locked) {\r\nstatus =\r\nacpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_VOID;\r\n}\r\n}\r\nif (region_obj->region.flags & AOPOBJ_SETUP_COMPLETE) {\r\nregion_setup = handler_obj->address_space.setup;\r\nstatus =\r\nregion_setup(region_obj,\r\nACPI_REGION_DEACTIVATE,\r\nhandler_obj->address_space.\r\ncontext, region_context);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status,\r\n"from region handler - deactivate, [%s]",\r\nacpi_ut_get_region_name\r\n(region_obj->region.\r\nspace_id)));\r\n}\r\nregion_obj->region.flags &=\r\n~(AOPOBJ_SETUP_COMPLETE);\r\n}\r\nregion_obj->region.handler = NULL;\r\nacpi_ut_remove_reference(handler_obj);\r\nreturn_VOID;\r\n}\r\nlast_obj_ptr = &obj_desc->region.next;\r\nobj_desc = obj_desc->region.next;\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\r\n"Cannot remove region %p from address handler %p\n",\r\nregion_obj, handler_obj));\r\nreturn_VOID;\r\n}\r\nacpi_status\r\nacpi_ev_attach_region(union acpi_operand_object *handler_obj,\r\nunion acpi_operand_object *region_obj,\r\nu8 acpi_ns_is_locked)\r\n{\r\nACPI_FUNCTION_TRACE(ev_attach_region);\r\nACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\r\n"Adding Region [%4.4s] %p to address handler %p [%s]\n",\r\nacpi_ut_get_node_name(region_obj->region.node),\r\nregion_obj, handler_obj,\r\nacpi_ut_get_region_name(region_obj->region.\r\nspace_id)));\r\nregion_obj->region.next = handler_obj->address_space.region_list;\r\nhandler_obj->address_space.region_list = region_obj;\r\nif (region_obj->region.handler) {\r\nreturn_ACPI_STATUS(AE_ALREADY_EXISTS);\r\n}\r\nregion_obj->region.handler = handler_obj;\r\nacpi_ut_add_reference(handler_obj);\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nstatic acpi_status\r\nacpi_ev_install_handler(acpi_handle obj_handle,\r\nu32 level, void *context, void **return_value)\r\n{\r\nunion acpi_operand_object *handler_obj;\r\nunion acpi_operand_object *next_handler_obj;\r\nunion acpi_operand_object *obj_desc;\r\nstruct acpi_namespace_node *node;\r\nacpi_status status;\r\nACPI_FUNCTION_NAME(ev_install_handler);\r\nhandler_obj = (union acpi_operand_object *)context;\r\nif (!handler_obj) {\r\nreturn (AE_OK);\r\n}\r\nnode = acpi_ns_validate_handle(obj_handle);\r\nif (!node) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nif ((node->type != ACPI_TYPE_DEVICE) &&\r\n(node->type != ACPI_TYPE_REGION) && (node != acpi_gbl_root_node)) {\r\nreturn (AE_OK);\r\n}\r\nobj_desc = acpi_ns_get_attached_object(node);\r\nif (!obj_desc) {\r\nreturn (AE_OK);\r\n}\r\nif (obj_desc->common.type == ACPI_TYPE_DEVICE) {\r\nnext_handler_obj = obj_desc->device.handler;\r\nwhile (next_handler_obj) {\r\nif (next_handler_obj->address_space.space_id ==\r\nhandler_obj->address_space.space_id) {\r\nACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\r\n"Found handler for region [%s] in device %p(%p) "\r\n"handler %p\n",\r\nacpi_ut_get_region_name\r\n(handler_obj->address_space.\r\nspace_id), obj_desc,\r\nnext_handler_obj,\r\nhandler_obj));\r\nreturn (AE_CTRL_DEPTH);\r\n}\r\nnext_handler_obj = next_handler_obj->address_space.next;\r\n}\r\nreturn (AE_OK);\r\n}\r\nif (obj_desc->region.space_id != handler_obj->address_space.space_id) {\r\nreturn (AE_OK);\r\n}\r\nacpi_ev_detach_region(obj_desc, FALSE);\r\nstatus = acpi_ev_attach_region(handler_obj, obj_desc, FALSE);\r\nreturn (status);\r\n}\r\nacpi_status\r\nacpi_ev_install_space_handler(struct acpi_namespace_node * node,\r\nacpi_adr_space_type space_id,\r\nacpi_adr_space_handler handler,\r\nacpi_adr_space_setup setup, void *context)\r\n{\r\nunion acpi_operand_object *obj_desc;\r\nunion acpi_operand_object *handler_obj;\r\nacpi_status status;\r\nacpi_object_type type;\r\nu8 flags = 0;\r\nACPI_FUNCTION_TRACE(ev_install_space_handler);\r\nif ((node->type != ACPI_TYPE_DEVICE) &&\r\n(node->type != ACPI_TYPE_PROCESSOR) &&\r\n(node->type != ACPI_TYPE_THERMAL) && (node != acpi_gbl_root_node)) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nif (handler == ACPI_DEFAULT_HANDLER) {\r\nflags = ACPI_ADDR_HANDLER_DEFAULT_INSTALLED;\r\nswitch (space_id) {\r\ncase ACPI_ADR_SPACE_SYSTEM_MEMORY:\r\nhandler = acpi_ex_system_memory_space_handler;\r\nsetup = acpi_ev_system_memory_region_setup;\r\nbreak;\r\ncase ACPI_ADR_SPACE_SYSTEM_IO:\r\nhandler = acpi_ex_system_io_space_handler;\r\nsetup = acpi_ev_io_space_region_setup;\r\nbreak;\r\ncase ACPI_ADR_SPACE_PCI_CONFIG:\r\nhandler = acpi_ex_pci_config_space_handler;\r\nsetup = acpi_ev_pci_config_region_setup;\r\nbreak;\r\ncase ACPI_ADR_SPACE_CMOS:\r\nhandler = acpi_ex_cmos_space_handler;\r\nsetup = acpi_ev_cmos_region_setup;\r\nbreak;\r\ncase ACPI_ADR_SPACE_PCI_BAR_TARGET:\r\nhandler = acpi_ex_pci_bar_space_handler;\r\nsetup = acpi_ev_pci_bar_region_setup;\r\nbreak;\r\ncase ACPI_ADR_SPACE_DATA_TABLE:\r\nhandler = acpi_ex_data_table_space_handler;\r\nsetup = NULL;\r\nbreak;\r\ndefault:\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\n}\r\nif (!setup) {\r\nsetup = acpi_ev_default_region_setup;\r\n}\r\nobj_desc = acpi_ns_get_attached_object(node);\r\nif (obj_desc) {\r\nhandler_obj = obj_desc->device.handler;\r\nwhile (handler_obj) {\r\nif (handler_obj->address_space.space_id == space_id) {\r\nif (handler_obj->address_space.handler ==\r\nhandler) {\r\nstatus = AE_SAME_HANDLER;\r\ngoto unlock_and_exit;\r\n} else {\r\nstatus = AE_ALREADY_EXISTS;\r\n}\r\ngoto unlock_and_exit;\r\n}\r\nhandler_obj = handler_obj->address_space.next;\r\n}\r\n} else {\r\nACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\r\n"Creating object on Device %p while installing handler\n",\r\nnode));\r\nif (node->type == ACPI_TYPE_ANY) {\r\ntype = ACPI_TYPE_DEVICE;\r\n} else {\r\ntype = node->type;\r\n}\r\nobj_desc = acpi_ut_create_internal_object(type);\r\nif (!obj_desc) {\r\nstatus = AE_NO_MEMORY;\r\ngoto unlock_and_exit;\r\n}\r\nobj_desc->common.type = (u8) type;\r\nstatus = acpi_ns_attach_object(node, obj_desc, type);\r\nacpi_ut_remove_reference(obj_desc);\r\nif (ACPI_FAILURE(status)) {\r\ngoto unlock_and_exit;\r\n}\r\n}\r\nACPI_DEBUG_PRINT((ACPI_DB_OPREGION,\r\n"Installing address handler for region %s(%X) on Device %4.4s %p(%p)\n",\r\nacpi_ut_get_region_name(space_id), space_id,\r\nacpi_ut_get_node_name(node), node, obj_desc));\r\nhandler_obj =\r\nacpi_ut_create_internal_object(ACPI_TYPE_LOCAL_ADDRESS_HANDLER);\r\nif (!handler_obj) {\r\nstatus = AE_NO_MEMORY;\r\ngoto unlock_and_exit;\r\n}\r\nhandler_obj->address_space.space_id = (u8) space_id;\r\nhandler_obj->address_space.handler_flags = flags;\r\nhandler_obj->address_space.region_list = NULL;\r\nhandler_obj->address_space.node = node;\r\nhandler_obj->address_space.handler = handler;\r\nhandler_obj->address_space.context = context;\r\nhandler_obj->address_space.setup = setup;\r\nhandler_obj->address_space.next = obj_desc->device.handler;\r\nobj_desc->device.handler = handler_obj;\r\nstatus = acpi_ns_walk_namespace(ACPI_TYPE_ANY, node, ACPI_UINT32_MAX,\r\nACPI_NS_WALK_UNLOCK,\r\nacpi_ev_install_handler, NULL,\r\nhandler_obj, NULL);\r\nunlock_and_exit:\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_ev_execute_reg_methods(struct acpi_namespace_node *node,\r\nacpi_adr_space_type space_id)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(ev_execute_reg_methods);\r\nstatus = acpi_ns_walk_namespace(ACPI_TYPE_ANY, node, ACPI_UINT32_MAX,\r\nACPI_NS_WALK_UNLOCK, acpi_ev_reg_run,\r\nNULL, &space_id, NULL);\r\nif (space_id == ACPI_ADR_SPACE_EC) {\r\nacpi_ev_orphan_ec_reg_method();\r\n}\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatic acpi_status\r\nacpi_ev_reg_run(acpi_handle obj_handle,\r\nu32 level, void *context, void **return_value)\r\n{\r\nunion acpi_operand_object *obj_desc;\r\nstruct acpi_namespace_node *node;\r\nacpi_adr_space_type space_id;\r\nacpi_status status;\r\nspace_id = *ACPI_CAST_PTR(acpi_adr_space_type, context);\r\nnode = acpi_ns_validate_handle(obj_handle);\r\nif (!node) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nif ((node->type != ACPI_TYPE_REGION) && (node != acpi_gbl_root_node)) {\r\nreturn (AE_OK);\r\n}\r\nobj_desc = acpi_ns_get_attached_object(node);\r\nif (!obj_desc) {\r\nreturn (AE_OK);\r\n}\r\nif (obj_desc->region.space_id != space_id) {\r\nreturn (AE_OK);\r\n}\r\nstatus = acpi_ev_execute_reg_method(obj_desc, ACPI_REG_CONNECT);\r\nreturn (status);\r\n}\r\nstatic void acpi_ev_orphan_ec_reg_method(void)\r\n{\r\nstruct acpi_table_ecdt *table;\r\nacpi_status status;\r\nstruct acpi_object_list args;\r\nunion acpi_object objects[2];\r\nstruct acpi_namespace_node *ec_device_node;\r\nstruct acpi_namespace_node *reg_method;\r\nstruct acpi_namespace_node *next_node;\r\nACPI_FUNCTION_TRACE(ev_orphan_ec_reg_method);\r\nstatus = acpi_get_table(ACPI_SIG_ECDT, 0,\r\nACPI_CAST_INDIRECT_PTR(struct acpi_table_header,\r\n&table));\r\nif (ACPI_FAILURE(status)) {\r\nreturn_VOID;\r\n}\r\nif (!(*table->id)) {\r\nreturn_VOID;\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\r\nstatus = acpi_get_handle(NULL,\r\nACPI_CAST_PTR(char, table->id),\r\nACPI_CAST_PTR(acpi_handle, &ec_device_node));\r\nif (ACPI_FAILURE(status)) {\r\ngoto exit;\r\n}\r\nstatus = acpi_get_handle(ec_device_node,\r\nMETHOD_NAME__REG, ACPI_CAST_PTR(acpi_handle,\r\n&reg_method));\r\nif (ACPI_FAILURE(status)) {\r\ngoto exit;\r\n}\r\nnext_node = acpi_ns_get_next_node(ec_device_node, NULL);\r\nwhile (next_node) {\r\nif ((next_node->type == ACPI_TYPE_REGION) &&\r\n(next_node->object) &&\r\n(next_node->object->region.space_id == ACPI_ADR_SPACE_EC)) {\r\ngoto exit;\r\n}\r\nnext_node = acpi_ns_get_next_node(ec_device_node, next_node);\r\n}\r\nargs.count = 2;\r\nargs.pointer = objects;\r\nobjects[0].type = ACPI_TYPE_INTEGER;\r\nobjects[0].integer.value = ACPI_ADR_SPACE_EC;\r\nobjects[1].type = ACPI_TYPE_INTEGER;\r\nobjects[1].integer.value = ACPI_REG_CONNECT;\r\nstatus = acpi_evaluate_object(reg_method, NULL, &args, NULL);\r\nexit:\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\r\nreturn_VOID;\r\n}
