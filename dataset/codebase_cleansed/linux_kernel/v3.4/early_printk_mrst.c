static void dw_kmsg_dump(struct kmsg_dumper *dumper,\r\nenum kmsg_dump_reason reason,\r\nconst char *s1, unsigned long l1,\r\nconst char *s2, unsigned long l2)\r\n{\r\nint i;\r\nmrst_early_console_init();\r\nfor (i = 0; i < l1; i++)\r\nearly_mrst_console.write(&early_mrst_console, s1 + i, 1);\r\nfor (i = 0; i < l2; i++)\r\nearly_mrst_console.write(&early_mrst_console, s2 + i, 1);\r\n}\r\nstatic void max3110_write_config(void)\r\n{\r\nu16 config;\r\nconfig = 0xc001;\r\ndw_writel(pspi, dr, config);\r\n}\r\nstatic void max3110_write_data(char c)\r\n{\r\nu16 data;\r\ndata = 0x8000 | c;\r\ndw_writel(pspi, dr, data);\r\n}\r\nvoid mrst_early_console_init(void)\r\n{\r\nu32 ctrlr0 = 0;\r\nu32 spi0_cdiv;\r\nu32 freq;\r\npclk_spi0 = (void *)set_fixmap_offset_nocache(FIX_EARLYCON_MEM_BASE,\r\nMRST_CLK_SPI0_REG);\r\nspi0_cdiv = ((*pclk_spi0) & 0xe00) >> 9;\r\nfreq = 100000000 / (spi0_cdiv + 1);\r\nif (mrst_identify_cpu() == MRST_CPU_CHIP_PENWELL)\r\nmrst_spi_paddr = MRST_REGBASE_SPI1;\r\npspi = (void *)set_fixmap_offset_nocache(FIX_EARLYCON_MEM_BASE,\r\nmrst_spi_paddr);\r\ndw_writel(pspi, ssienr, 0);\r\nctrlr0 = dw_readl(pspi, ctrl0);\r\nctrlr0 &= 0xfcc0;\r\nctrlr0 |= 0xf | (SPI_FRF_SPI << SPI_FRF_OFFSET)\r\n| (SPI_TMOD_TO << SPI_TMOD_OFFSET);\r\ndw_writel(pspi, ctrl0, ctrlr0);\r\ndw_writel(pspi, baudr, freq/100000);\r\ndw_writel(pspi, imr, 0x0);\r\ndw_writel(pspi, ser, 0x2);\r\ndw_writel(pspi, ssienr, 0x1);\r\nmax3110_write_config();\r\nif (!dumper_registered) {\r\ndw_dumper.dump = dw_kmsg_dump;\r\nkmsg_dump_register(&dw_dumper);\r\ndumper_registered = 1;\r\n}\r\n}\r\nstatic void early_mrst_spi_putc(char c)\r\n{\r\nunsigned int timeout;\r\nu32 sr;\r\ntimeout = MRST_SPI_TIMEOUT;\r\nwhile (--timeout) {\r\nsr = dw_readl(pspi, sr);\r\nif (!(sr & SR_TF_NOT_FULL))\r\ncpu_relax();\r\nelse\r\nbreak;\r\n}\r\nif (!timeout)\r\npr_warning("MRST earlycon: timed out\n");\r\nelse\r\nmax3110_write_data(c);\r\n}\r\nstatic void early_mrst_spi_write(struct console *con, const char *str, unsigned n)\r\n{\r\nint i;\r\nfor (i = 0; i < n && *str; i++) {\r\nif (*str == '\n')\r\nearly_mrst_spi_putc('\r');\r\nearly_mrst_spi_putc(*str);\r\nstr++;\r\n}\r\n}\r\nvoid hsu_early_console_init(const char *s)\r\n{\r\nunsigned long paddr, port = 0;\r\nu8 lcr;\r\nif (*s && !kstrtoul(s, 10, &port))\r\nport = clamp_val(port, 0, 2);\r\npaddr = HSU_PORT_BASE + port * 0x80;\r\nphsu = (void *)set_fixmap_offset_nocache(FIX_EARLYCON_MEM_BASE, paddr);\r\nwriteb(0x0, phsu + UART_FCR);\r\nlcr = readb(phsu + UART_LCR);\r\nwriteb((0x80 | lcr), phsu + UART_LCR);\r\nwriteb(0x18, phsu + UART_DLL);\r\nwriteb(lcr, phsu + UART_LCR);\r\nwritel(0x3600, phsu + UART_MUL*4);\r\nwriteb(0x8, phsu + UART_MCR);\r\nwriteb(0x7, phsu + UART_FCR);\r\nwriteb(0x3, phsu + UART_LCR);\r\nreadb(phsu + UART_LSR);\r\nreadb(phsu + UART_RX);\r\nreadb(phsu + UART_IIR);\r\nreadb(phsu + UART_MSR);\r\nwriteb(0x7, phsu + UART_FCR);\r\n}\r\nstatic void early_hsu_putc(char ch)\r\n{\r\nunsigned int timeout = 10000;\r\nu8 status;\r\nwhile (--timeout) {\r\nstatus = readb(phsu + UART_LSR);\r\nif (status & BOTH_EMPTY)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (timeout)\r\nwriteb(ch, phsu + UART_TX);\r\n}\r\nstatic void early_hsu_write(struct console *con, const char *str, unsigned n)\r\n{\r\nint i;\r\nfor (i = 0; i < n && *str; i++) {\r\nif (*str == '\n')\r\nearly_hsu_putc('\r');\r\nearly_hsu_putc(*str);\r\nstr++;\r\n}\r\n}
