static const char *host_info(struct Scsi_Host *host)\r\n{\r\nreturn "SCSI emulation for USB Mass Storage devices";\r\n}\r\nstatic int slave_alloc(struct scsi_device *sdev)\r\n{\r\nstruct us_data *us = host_to_us(sdev->host);\r\nsdev->inquiry_len = 36;\r\nblk_queue_update_dma_alignment(sdev->request_queue, (512 - 1));\r\nif (us->subclass == USB_SC_UFI)\r\nsdev->sdev_target->pdt_1f_for_no_lun = 1;\r\nreturn 0;\r\n}\r\nstatic int slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct us_data *us = host_to_us(sdev->host);\r\nif (us->fflags & (US_FL_MAX_SECTORS_64 | US_FL_MAX_SECTORS_MIN)) {\r\nunsigned int max_sectors = 64;\r\nif (us->fflags & US_FL_MAX_SECTORS_MIN)\r\nmax_sectors = PAGE_CACHE_SIZE >> 9;\r\nif (queue_max_sectors(sdev->request_queue) > max_sectors)\r\nblk_queue_max_hw_sectors(sdev->request_queue,\r\nmax_sectors);\r\n}\r\nif (sdev->type == TYPE_DISK) {\r\nif (us->subclass != USB_SC_SCSI &&\r\nus->subclass != USB_SC_CYP_ATACB)\r\nsdev->use_10_for_ms = 1;\r\nsdev->use_192_bytes_for_3f = 1;\r\nif (us->fflags & US_FL_NO_WP_DETECT)\r\nsdev->skip_ms_page_3f = 1;\r\nsdev->skip_ms_page_8 = 1;\r\nif (us->fflags & US_FL_FIX_CAPACITY)\r\nsdev->fix_capacity = 1;\r\nif (us->fflags & US_FL_CAPACITY_HEURISTICS)\r\nsdev->guess_capacity = 1;\r\nif (sdev->scsi_level > SCSI_2)\r\nsdev->sdev_target->scsi_level = sdev->scsi_level = SCSI_2;\r\nsdev->retry_hwerror = 1;\r\nsdev->allow_restart = 1;\r\nsdev->last_sector_bug = 1;\r\n} else {\r\nsdev->use_10_for_ms = 1;\r\n}\r\nif ((us->protocol == USB_PR_CB || us->protocol == USB_PR_CBI) &&\r\nsdev->scsi_level == SCSI_UNKNOWN)\r\nus->max_lun = 0;\r\nif (us->fflags & US_FL_NOT_LOCKABLE)\r\nsdev->lockable = 0;\r\nreturn 0;\r\n}\r\nstatic int queuecommand_lck(struct scsi_cmnd *srb,\r\nvoid (*done)(struct scsi_cmnd *))\r\n{\r\nstruct us_data *us = host_to_us(srb->device->host);\r\nif (us->srb != NULL) {\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nif (test_bit(US_FLIDX_DISCONNECTING, &us->dflags)) {\r\npr_info("Fail command during disconnect\n");\r\nsrb->result = DID_NO_CONNECT << 16;\r\ndone(srb);\r\nreturn 0;\r\n}\r\nsrb->scsi_done = done;\r\nus->srb = srb;\r\ncomplete(&us->cmnd_ready);\r\nreturn 0;\r\n}\r\nint device_reset(struct scsi_cmnd *srb)\r\n{\r\nstruct us_data *us = host_to_us(srb->device->host);\r\nint result;\r\nmutex_lock(&(us->dev_mutex));\r\nresult = us->transport_reset(us);\r\nmutex_unlock(&us->dev_mutex);\r\nreturn result < 0 ? FAILED : SUCCESS;\r\n}\r\nstatic int bus_reset(struct scsi_cmnd *srb)\r\n{\r\nstruct us_data *us = host_to_us(srb->device->host);\r\nint result;\r\nresult = usb_stor_port_reset(us);\r\nreturn result < 0 ? FAILED : SUCCESS;\r\n}\r\nvoid usb_stor_report_device_reset(struct us_data *us)\r\n{\r\nint i;\r\nstruct Scsi_Host *host = us_to_host(us);\r\nscsi_report_device_reset(host, 0, 0);\r\nif (us->fflags & US_FL_SCM_MULT_TARG) {\r\nfor (i = 1; i < host->max_id; ++i)\r\nscsi_report_device_reset(host, 0, i);\r\n}\r\n}\r\nvoid usb_stor_report_bus_reset(struct us_data *us)\r\n{\r\nstruct Scsi_Host *host = us_to_host(us);\r\nscsi_lock(host);\r\nscsi_report_bus_reset(host, 0);\r\nscsi_unlock(host);\r\n}\r\nstatic int proc_info(struct Scsi_Host *host, char *buffer, char **start,\r\noff_t offset, int length, int inout)\r\n{\r\nstruct us_data *us = host_to_us(host);\r\nchar *pos = buffer;\r\nconst char *string;\r\nif (inout)\r\nreturn length;\r\nSPRINTF(" Host scsi%d: usb-storage\n", host->host_no);\r\nif (us->pusb_dev->manufacturer)\r\nstring = us->pusb_dev->manufacturer;\r\nelse if (us->unusual_dev->vendorName)\r\nstring = us->unusual_dev->vendorName;\r\nelse\r\nstring = "Unknown";\r\nSPRINTF(" Vendor: %s\n", string);\r\nif (us->pusb_dev->product)\r\nstring = us->pusb_dev->product;\r\nelse if (us->unusual_dev->productName)\r\nstring = us->unusual_dev->productName;\r\nelse\r\nstring = "Unknown";\r\nSPRINTF(" Product: %s\n", string);\r\nif (us->pusb_dev->serial)\r\nstring = us->pusb_dev->serial;\r\nelse\r\nstring = "None";\r\nSPRINTF("Serial Number: %s\n", string);\r\nSPRINTF(" Protocol: %s\n", us->protocol_name);\r\nSPRINTF(" Transport: %s\n", us->transport_name);\r\nif (pos < buffer + length) {\r\npos += sprintf(pos, " Quirks:");\r\n#define US_FLAG(name, value) \\r\nif (us->fflags & value)\\r\npos += sprintf(pos, " " #name);\r\nUS_DO_ALL_FLAGS\r\n#undef US_FLAG\r\n*(pos++) = '\n';\r\n}\r\n*start = buffer + offset;\r\nif ((pos - buffer) < offset)\r\nreturn 0;\r\nelse if ((pos - buffer - offset) < length)\r\nreturn pos - buffer - offset;\r\nelse\r\nreturn length;\r\n}\r\nstatic ssize_t show_max_sectors(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nreturn sprintf(buf, "%u\n", queue_max_sectors(sdev->request_queue));\r\n}\r\nstatic ssize_t store_max_sectors(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nunsigned short ms;\r\nif (sscanf(buf, "%hu", &ms) > 0 && ms <= SCSI_DEFAULT_MAX_SECTORS) {\r\nblk_queue_max_hw_sectors(sdev->request_queue, ms);\r\nreturn strlen(buf);\r\n}\r\nreturn -EINVAL;\r\n}\r\nunsigned int usb_stor_access_xfer_buf(struct us_data *us, unsigned char *buffer,\r\nunsigned int buflen, struct scsi_cmnd *srb, struct scatterlist **sgptr,\r\nunsigned int *offset, enum xfer_buf_dir dir)\r\n{\r\nunsigned int cnt;\r\nstruct scatterlist *sg = *sgptr;\r\nif (!sg)\r\nsg = scsi_sglist(srb);\r\ncnt = 0;\r\nwhile (cnt < buflen && sg) {\r\nstruct page *page = sg_page(sg) +\r\n((sg->offset + *offset) >> PAGE_SHIFT);\r\nunsigned int poff = (sg->offset + *offset) & (PAGE_SIZE-1);\r\nunsigned int sglen = sg->length - *offset;\r\nif (sglen > buflen - cnt) {\r\nsglen = buflen - cnt;\r\n*offset += sglen;\r\n} else {\r\n*offset = 0;\r\nsg = sg_next(sg);\r\n}\r\nwhile (sglen > 0) {\r\nunsigned int plen = min(sglen,\r\n(unsigned int)PAGE_SIZE - poff);\r\nunsigned char *ptr = kmap(page);\r\nif (dir == TO_XFER_BUF)\r\nmemcpy(ptr + poff, buffer + cnt, plen);\r\nelse\r\nmemcpy(buffer + cnt, ptr + poff, plen);\r\nkunmap(page);\r\npoff = 0;\r\n++page;\r\ncnt += plen;\r\nsglen -= plen;\r\n}\r\n}\r\n*sgptr = sg;\r\nreturn cnt;\r\n}\r\nvoid usb_stor_set_xfer_buf(struct us_data *us, unsigned char *buffer,\r\nunsigned int buflen, struct scsi_cmnd *srb, unsigned int dir)\r\n{\r\nunsigned int offset = 0;\r\nstruct scatterlist *sg = NULL;\r\nbuflen = min(buflen, scsi_bufflen(srb));\r\nbuflen = usb_stor_access_xfer_buf(us, buffer, buflen, srb,\r\n&sg, &offset, dir);\r\nif (buflen < scsi_bufflen(srb))\r\nscsi_set_resid(srb, scsi_bufflen(srb) - buflen);\r\n}
