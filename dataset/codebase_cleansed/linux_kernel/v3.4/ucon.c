static int netlink_send(int s, struct cn_msg *msg)\r\n{\r\nstruct nlmsghdr *nlh;\r\nunsigned int size;\r\nint err;\r\nchar buf[128];\r\nstruct cn_msg *m;\r\nsize = NLMSG_SPACE(sizeof(struct cn_msg) + msg->len);\r\nnlh = (struct nlmsghdr *)buf;\r\nnlh->nlmsg_seq = seq++;\r\nnlh->nlmsg_pid = getpid();\r\nnlh->nlmsg_type = NLMSG_DONE;\r\nnlh->nlmsg_len = NLMSG_LENGTH(size - sizeof(*nlh));\r\nnlh->nlmsg_flags = 0;\r\nm = NLMSG_DATA(nlh);\r\n#if 0\r\nulog("%s: [%08x.%08x] len=%u, seq=%u, ack=%u.\n",\r\n__func__, msg->id.idx, msg->id.val, msg->len, msg->seq, msg->ack);\r\n#endif\r\nmemcpy(m, msg, sizeof(*m) + msg->len);\r\nerr = send(s, nlh, size, 0);\r\nif (err == -1)\r\nulog("Failed to send: %s [%d].\n",\r\nstrerror(errno), errno);\r\nreturn err;\r\n}\r\nstatic void usage(void)\r\n{\r\nprintf(\r\n"Usage: ucon [options] [output file]\n"\r\n"\n"\r\n"\t-h\tthis help screen\n"\r\n"\t-s\tsend buffers to the test module\n"\r\n"\n"\r\n"The default behavior of ucon is to subscribe to the test module\n"\r\n"and wait for state messages. Any ones received are dumped to the\n"\r\n"specified output file (or stdout). The test module is assumed to\n"\r\n"have an id of {%u.%u}\n"\r\n"\n"\r\n"If you get no output, then verify the cn_test module id matches\n"\r\n"the expected id above.\n"\r\n, CN_TEST_IDX, CN_TEST_VAL\r\n);\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nint s;\r\nchar buf[1024];\r\nint len;\r\nstruct nlmsghdr *reply;\r\nstruct sockaddr_nl l_local;\r\nstruct cn_msg *data;\r\nFILE *out;\r\ntime_t tm;\r\nstruct pollfd pfd;\r\nbool send_msgs = false;\r\nwhile ((s = getopt(argc, argv, "hs")) != -1) {\r\nswitch (s) {\r\ncase 's':\r\nsend_msgs = true;\r\nbreak;\r\ncase 'h':\r\nusage();\r\nreturn 0;\r\ndefault:\r\nusage();\r\nreturn 1;\r\n}\r\n}\r\nif (argc != optind) {\r\nout = fopen(argv[optind], "a+");\r\nif (!out) {\r\nulog("Unable to open %s for writing: %s\n",\r\nargv[1], strerror(errno));\r\nout = stdout;\r\n}\r\n} else\r\nout = stdout;\r\nmemset(buf, 0, sizeof(buf));\r\ns = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);\r\nif (s == -1) {\r\nperror("socket");\r\nreturn -1;\r\n}\r\nl_local.nl_family = AF_NETLINK;\r\nl_local.nl_groups = -1;\r\nl_local.nl_pid = 0;\r\nulog("subscribing to %u.%u\n", CN_TEST_IDX, CN_TEST_VAL);\r\nif (bind(s, (struct sockaddr *)&l_local, sizeof(struct sockaddr_nl)) == -1) {\r\nperror("bind");\r\nclose(s);\r\nreturn -1;\r\n}\r\n#if 0\r\n{\r\nint on = 0x57;\r\nsetsockopt(s, SOL_NETLINK, NETLINK_ADD_MEMBERSHIP, &on, sizeof(on));\r\n}\r\n#endif\r\nif (send_msgs) {\r\nint i, j;\r\nmemset(buf, 0, sizeof(buf));\r\ndata = (struct cn_msg *)buf;\r\ndata->id.idx = CN_TEST_IDX;\r\ndata->id.val = CN_TEST_VAL;\r\ndata->seq = seq++;\r\ndata->ack = 0;\r\ndata->len = 0;\r\nfor (j=0; j<10; ++j) {\r\nfor (i=0; i<1000; ++i) {\r\nlen = netlink_send(s, data);\r\n}\r\nulog("%d messages have been sent to %08x.%08x.\n", i, data->id.idx, data->id.val);\r\n}\r\nreturn 0;\r\n}\r\npfd.fd = s;\r\nwhile (!need_exit) {\r\npfd.events = POLLIN;\r\npfd.revents = 0;\r\nswitch (poll(&pfd, 1, -1)) {\r\ncase 0:\r\nneed_exit = 1;\r\nbreak;\r\ncase -1:\r\nif (errno != EINTR) {\r\nneed_exit = 1;\r\nbreak;\r\n}\r\ncontinue;\r\n}\r\nif (need_exit)\r\nbreak;\r\nmemset(buf, 0, sizeof(buf));\r\nlen = recv(s, buf, sizeof(buf), 0);\r\nif (len == -1) {\r\nperror("recv buf");\r\nclose(s);\r\nreturn -1;\r\n}\r\nreply = (struct nlmsghdr *)buf;\r\nswitch (reply->nlmsg_type) {\r\ncase NLMSG_ERROR:\r\nfprintf(out, "Error message received.\n");\r\nfflush(out);\r\nbreak;\r\ncase NLMSG_DONE:\r\ndata = (struct cn_msg *)NLMSG_DATA(reply);\r\ntime(&tm);\r\nfprintf(out, "%.24s : [%x.%x] [%08u.%08u].\n",\r\nctime(&tm), data->id.idx, data->id.val, data->seq, data->ack);\r\nfflush(out);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nclose(s);\r\nreturn 0;\r\n}
