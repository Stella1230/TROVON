void t3e3_set_frame_type(struct channel *sc, u32 mode)\r\n{\r\nif (sc->p.frame_type == mode)\r\nreturn;\r\nif (sc->r.flags & SBE_2T3E3_FLAG_NETWORK_UP) {\r\ndev_err(&sc->pdev->dev, "SBE 2T3E3: changing frame type during active connection\n");\r\nreturn;\r\n}\r\nexar7300_set_frame_type(sc, mode);\r\nexar7250_set_frame_type(sc, mode);\r\ncpld_set_frame_type(sc, mode);\r\nsc->p.frame_type = mode;\r\n}\r\nvoid t3e3_set_loopback(struct channel *sc, u32 mode)\r\n{\r\nu32 tx, rx;\r\nif (sc->p.loopback == mode)\r\nreturn;\r\ntx = sc->p.transmitter_on;\r\nrx = sc->p.receiver_on;\r\nif (tx == SBE_2T3E3_ON)\r\ndc_transmitter_onoff(sc, SBE_2T3E3_OFF);\r\nif (rx == SBE_2T3E3_ON)\r\ndc_receiver_onoff(sc, SBE_2T3E3_OFF);\r\nswitch (sc->p.loopback) {\r\ncase SBE_2T3E3_LOOPBACK_NONE:\r\nbreak;\r\ncase SBE_2T3E3_LOOPBACK_ETHERNET:\r\ndc_set_loopback(sc, SBE_2T3E3_21143_VAL_LOOPBACK_OFF);\r\nbreak;\r\ncase SBE_2T3E3_LOOPBACK_FRAMER:\r\nexar7250_set_loopback(sc, SBE_2T3E3_FRAMER_VAL_LOOPBACK_OFF);\r\nbreak;\r\ncase SBE_2T3E3_LOOPBACK_LIU_DIGITAL:\r\ncase SBE_2T3E3_LOOPBACK_LIU_ANALOG:\r\ncase SBE_2T3E3_LOOPBACK_LIU_REMOTE:\r\nexar7300_set_loopback(sc, SBE_2T3E3_LIU_VAL_LOOPBACK_OFF);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nswitch (mode) {\r\ncase SBE_2T3E3_LOOPBACK_NONE:\r\nbreak;\r\ncase SBE_2T3E3_LOOPBACK_ETHERNET:\r\ndc_set_loopback(sc, SBE_2T3E3_21143_VAL_LOOPBACK_INTERNAL);\r\nbreak;\r\ncase SBE_2T3E3_LOOPBACK_FRAMER:\r\nexar7250_set_loopback(sc, SBE_2T3E3_FRAMER_VAL_LOOPBACK_ON);\r\nbreak;\r\ncase SBE_2T3E3_LOOPBACK_LIU_DIGITAL:\r\nexar7300_set_loopback(sc, SBE_2T3E3_LIU_VAL_LOOPBACK_DIGITAL);\r\nbreak;\r\ncase SBE_2T3E3_LOOPBACK_LIU_ANALOG:\r\nexar7300_set_loopback(sc, SBE_2T3E3_LIU_VAL_LOOPBACK_ANALOG);\r\nbreak;\r\ncase SBE_2T3E3_LOOPBACK_LIU_REMOTE:\r\nexar7300_set_loopback(sc, SBE_2T3E3_LIU_VAL_LOOPBACK_REMOTE);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nsc->p.loopback = mode;\r\nif (tx == SBE_2T3E3_ON)\r\ndc_transmitter_onoff(sc, SBE_2T3E3_ON);\r\nif (rx == SBE_2T3E3_ON)\r\ndc_receiver_onoff(sc, SBE_2T3E3_ON);\r\n}\r\nvoid t3e3_reg_read(struct channel *sc, u32 *reg, u32 *val)\r\n{\r\nu32 i;\r\n*val = 0;\r\nswitch (reg[0]) {\r\ncase SBE_2T3E3_CHIP_21143:\r\nif (!(reg[1] & 7))\r\n*val = dc_read(sc->addr, reg[1] / 8);\r\nbreak;\r\ncase SBE_2T3E3_CHIP_CPLD:\r\nfor (i = 0; i < SBE_2T3E3_CPLD_REG_MAX; i++)\r\nif (cpld_reg_map[i][sc->h.slot] == reg[1]) {\r\n*val = cpld_read(sc, i);\r\nbreak;\r\n}\r\nbreak;\r\ncase SBE_2T3E3_CHIP_FRAMER:\r\nfor (i = 0; i < SBE_2T3E3_FRAMER_REG_MAX; i++)\r\nif (t3e3_framer_reg_map[i] == reg[1]) {\r\n*val = exar7250_read(sc, i);\r\nbreak;\r\n}\r\nbreak;\r\ncase SBE_2T3E3_CHIP_LIU:\r\nfor (i = 0; i < SBE_2T3E3_LIU_REG_MAX; i++)\r\nif (t3e3_liu_reg_map[i] == reg[1]) {\r\n*val = exar7300_read(sc, i);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid t3e3_reg_write(struct channel *sc, u32 *reg)\r\n{\r\nu32 i;\r\nswitch (reg[0]) {\r\ncase SBE_2T3E3_CHIP_21143:\r\ndc_write(sc->addr, reg[1], reg[2]);\r\nbreak;\r\ncase SBE_2T3E3_CHIP_CPLD:\r\nfor (i = 0; i < SBE_2T3E3_CPLD_REG_MAX; i++)\r\nif (cpld_reg_map[i][sc->h.slot] == reg[1]) {\r\ncpld_write(sc, i, reg[2]);\r\nbreak;\r\n}\r\nbreak;\r\ncase SBE_2T3E3_CHIP_FRAMER:\r\nfor (i = 0; i < SBE_2T3E3_FRAMER_REG_MAX; i++)\r\nif (t3e3_framer_reg_map[i] == reg[1]) {\r\nexar7250_write(sc, i, reg[2]);\r\nbreak;\r\n}\r\nbreak;\r\ncase SBE_2T3E3_CHIP_LIU:\r\nfor (i = 0; i < SBE_2T3E3_LIU_REG_MAX; i++)\r\nif (t3e3_liu_reg_map[i] == reg[1]) {\r\nexar7300_write(sc, i, reg[2]);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\nvoid t3e3_port_get(struct channel *sc, t3e3_param_t *param)\r\n{\r\nmemcpy(param, &(sc->p), sizeof(t3e3_param_t));\r\n}\r\nvoid t3e3_port_set(struct channel *sc, t3e3_param_t *param)\r\n{\r\nif (param->frame_mode != 0xff)\r\ncpld_set_frame_mode(sc, param->frame_mode);\r\nif (param->fractional_mode != 0xff)\r\ncpld_set_fractional_mode(sc, param->fractional_mode,\r\nparam->bandwidth_start,\r\nparam->bandwidth_stop);\r\nif (param->pad_count != 0xff)\r\ncpld_set_pad_count(sc, param->pad_count);\r\nif (param->crc != 0xff)\r\ncpld_set_crc(sc, param->crc);\r\nif (param->receiver_on != 0xff)\r\ndc_receiver_onoff(sc, param->receiver_on);\r\nif (param->transmitter_on != 0xff)\r\ndc_transmitter_onoff(sc, param->transmitter_on);\r\nif (param->frame_type != 0xff)\r\nt3e3_set_frame_type(sc, param->frame_type);\r\nif (param->panel != 0xff)\r\ncpld_select_panel(sc, param->panel);\r\nif (param->line_build_out != 0xff)\r\nexar7300_line_build_out_onoff(sc, param->line_build_out);\r\nif (param->receive_equalization != 0xff)\r\nexar7300_receive_equalization_onoff(sc, param->receive_equalization);\r\nif (param->transmit_all_ones != 0xff)\r\nexar7300_transmit_all_ones_onoff(sc, param->transmit_all_ones);\r\nif (param->loopback != 0xff)\r\nt3e3_set_loopback(sc, param->loopback);\r\nif (param->clock_source != 0xff)\r\ncpld_set_clock(sc, param->clock_source);\r\nif (param->scrambler != 0xff)\r\ncpld_set_scrambler(sc, param->scrambler);\r\n}\r\nvoid t3e3_port_get_stats(struct channel *sc,\r\nt3e3_stats_t *stats)\r\n{\r\nu32 result;\r\nsc->s.LOC = exar7250_read(sc, SBE_2T3E3_FRAMER_REG_IO_CONTROL)\r\n& SBE_2T3E3_FRAMER_VAL_LOSS_OF_CLOCK_STATUS ? 1 : 0;\r\nswitch (sc->p.frame_type) {\r\ncase SBE_2T3E3_FRAME_TYPE_E3_G751:\r\ncase SBE_2T3E3_FRAME_TYPE_E3_G832:\r\nresult = exar7250_read(sc, SBE_2T3E3_FRAMER_REG_E3_RX_CONFIGURATION_STATUS_2);\r\nsc->s.LOF = result & SBE_2T3E3_FRAMER_VAL_E3_RX_LOF ? 1 : 0;\r\nsc->s.OOF = result & SBE_2T3E3_FRAMER_VAL_E3_RX_OOF ? 1 : 0;\r\n#if 0\r\nsc->s.LOS = result & SBE_2T3E3_FRAMER_VAL_E3_RX_LOS ? 1 : 0;\r\n#else\r\ncpld_LOS_update(sc);\r\n#endif\r\nsc->s.AIS = result & SBE_2T3E3_FRAMER_VAL_E3_RX_AIS ? 1 : 0;\r\nsc->s.FERF = result & SBE_2T3E3_FRAMER_VAL_E3_RX_FERF ? 1 : 0;\r\nbreak;\r\ncase SBE_2T3E3_FRAME_TYPE_T3_CBIT:\r\ncase SBE_2T3E3_FRAME_TYPE_T3_M13:\r\nresult = exar7250_read(sc, SBE_2T3E3_FRAMER_REG_T3_RX_CONFIGURATION_STATUS);\r\nsc->s.AIS = result & SBE_2T3E3_FRAMER_VAL_T3_RX_AIS ? 1 : 0;\r\n#if 0\r\nsc->s.LOS = result & SBE_2T3E3_FRAMER_VAL_T3_RX_LOS ? 1 : 0;\r\n#else\r\ncpld_LOS_update(sc);\r\n#endif\r\nsc->s.IDLE = result & SBE_2T3E3_FRAMER_VAL_T3_RX_IDLE ? 1 : 0;\r\nsc->s.OOF = result & SBE_2T3E3_FRAMER_VAL_T3_RX_OOF ? 1 : 0;\r\nresult = exar7250_read(sc, SBE_2T3E3_FRAMER_REG_T3_RX_STATUS);\r\nsc->s.FERF = result & SBE_2T3E3_FRAMER_VAL_T3_RX_FERF ? 1 : 0;\r\nsc->s.AIC = result & SBE_2T3E3_FRAMER_VAL_T3_RX_AIC ? 1 : 0;\r\nsc->s.FEBE_code = result & SBE_2T3E3_FRAMER_VAL_T3_RX_FEBE;\r\nsc->s.FEAC = exar7250_read(sc, SBE_2T3E3_FRAMER_REG_T3_RX_FEAC);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nresult = exar7250_read(sc, SBE_2T3E3_FRAMER_REG_PMON_LCV_EVENT_COUNT_MSB) << 8;\r\nresult += exar7250_read(sc, SBE_2T3E3_FRAMER_REG_PMON_HOLDING_REGISTER);\r\nsc->s.LCV += result;\r\nresult = exar7250_read(sc, SBE_2T3E3_FRAMER_REG_PMON_FRAMING_BIT_ERROR_EVENT_COUNT_MSB) << 8;\r\nresult += exar7250_read(sc, SBE_2T3E3_FRAMER_REG_PMON_HOLDING_REGISTER);\r\nsc->s.FRAMING_BIT += result;\r\nresult = exar7250_read(sc, SBE_2T3E3_FRAMER_REG_PMON_PARITY_ERROR_EVENT_COUNT_MSB) << 8;\r\nresult += exar7250_read(sc, SBE_2T3E3_FRAMER_REG_PMON_HOLDING_REGISTER);\r\nsc->s.PARITY_ERROR += result;\r\nresult = exar7250_read(sc, SBE_2T3E3_FRAMER_REG_PMON_FEBE_EVENT_COUNT_MSB) << 8;\r\nresult += exar7250_read(sc, SBE_2T3E3_FRAMER_REG_PMON_HOLDING_REGISTER);\r\nsc->s.FEBE_count += result;\r\nresult = exar7250_read(sc, SBE_2T3E3_FRAMER_REG_PMON_CP_BIT_ERROR_EVENT_COUNT_MSB) << 8;\r\nresult += exar7250_read(sc, SBE_2T3E3_FRAMER_REG_PMON_HOLDING_REGISTER);\r\nsc->s.CP_BIT += result;\r\nmemcpy(stats, &(sc->s), sizeof(t3e3_stats_t));\r\n}\r\nvoid t3e3_port_del_stats(struct channel *sc)\r\n{\r\nmemset(&(sc->s), 0, sizeof(t3e3_stats_t));\r\n}\r\nvoid t3e3_if_config(struct channel *sc, u32 cmd, char *set,\r\nt3e3_resp_t *ret, int *rlen)\r\n{\r\nt3e3_param_t *param = (t3e3_param_t *)set;\r\nu32 *data = (u32 *)set;\r\nswitch (cmd) {\r\ncase SBE_2T3E3_PORT_GET:\r\nt3e3_port_get(sc, &(ret->u.param));\r\n*rlen = sizeof(ret->u.param);\r\nbreak;\r\ncase SBE_2T3E3_PORT_SET:\r\nt3e3_port_set(sc, param);\r\n*rlen = 0;\r\nbreak;\r\ncase SBE_2T3E3_PORT_GET_STATS:\r\nt3e3_port_get_stats(sc, &(ret->u.stats));\r\n*rlen = sizeof(ret->u.stats);\r\nbreak;\r\ncase SBE_2T3E3_PORT_DEL_STATS:\r\nt3e3_port_del_stats(sc);\r\n*rlen = 0;\r\nbreak;\r\ncase SBE_2T3E3_PORT_READ_REGS:\r\nt3e3_reg_read(sc, data, &(ret->u.data));\r\n*rlen = sizeof(ret->u.data);\r\nbreak;\r\ncase SBE_2T3E3_PORT_WRITE_REGS:\r\n#if 0\r\nprintk(KERN_DEBUG "SBE_2T3E3_PORT_WRITE_REGS, 0x%x, 0x%x, 0x%x\n",\r\n((int*)data)[0], ((int*)data)[1], ((int*)data)[2]);\r\n#endif\r\nt3e3_reg_write(sc, data);\r\n*rlen = 0;\r\nbreak;\r\ncase SBE_2T3E3_LOG_LEVEL:\r\n*rlen = 0;\r\nbreak;\r\ndefault:\r\n*rlen = 0;\r\nbreak;\r\n}\r\n}\r\nvoid t3e3_sc_init(struct channel *sc)\r\n{\r\nmemset(sc, 0, sizeof(*sc));\r\nsc->p.frame_mode = SBE_2T3E3_FRAME_MODE_HDLC;\r\nsc->p.fractional_mode = SBE_2T3E3_FRACTIONAL_MODE_NONE;\r\nsc->p.crc = SBE_2T3E3_CRC_32;\r\nsc->p.receiver_on = SBE_2T3E3_OFF;\r\nsc->p.transmitter_on = SBE_2T3E3_OFF;\r\nsc->p.frame_type = SBE_2T3E3_FRAME_TYPE_T3_CBIT;\r\nsc->p.panel = SBE_2T3E3_PANEL_FRONT;\r\nsc->p.line_build_out = SBE_2T3E3_OFF;\r\nsc->p.receive_equalization = SBE_2T3E3_OFF;\r\nsc->p.transmit_all_ones = SBE_2T3E3_OFF;\r\nsc->p.loopback = SBE_2T3E3_LOOPBACK_NONE;\r\nsc->p.clock_source = SBE_2T3E3_TIMING_LOCAL;\r\nsc->p.scrambler = SBE_2T3E3_SCRAMBLER_OFF;\r\nsc->p.pad_count = SBE_2T3E3_PAD_COUNT_1;\r\n}
