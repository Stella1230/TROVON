static int rt2x00mac_tx_rts_cts(struct rt2x00_dev *rt2x00dev,\r\nstruct data_queue *queue,\r\nstruct sk_buff *frag_skb)\r\n{\r\nstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(frag_skb);\r\nstruct ieee80211_tx_info *rts_info;\r\nstruct sk_buff *skb;\r\nunsigned int data_length;\r\nint retval = 0;\r\nif (tx_info->control.rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT)\r\ndata_length = sizeof(struct ieee80211_cts);\r\nelse\r\ndata_length = sizeof(struct ieee80211_rts);\r\nskb = dev_alloc_skb(data_length + rt2x00dev->hw->extra_tx_headroom);\r\nif (unlikely(!skb)) {\r\nWARNING(rt2x00dev, "Failed to create RTS/CTS frame.\n");\r\nreturn -ENOMEM;\r\n}\r\nskb_reserve(skb, rt2x00dev->hw->extra_tx_headroom);\r\nskb_put(skb, data_length);\r\nmemcpy(skb->cb, frag_skb->cb, sizeof(skb->cb));\r\nrts_info = IEEE80211_SKB_CB(skb);\r\nrts_info->control.rates[0].flags &= ~IEEE80211_TX_RC_USE_RTS_CTS;\r\nrts_info->control.rates[0].flags &= ~IEEE80211_TX_RC_USE_CTS_PROTECT;\r\nif (tx_info->control.rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT)\r\nrts_info->flags |= IEEE80211_TX_CTL_NO_ACK;\r\nelse\r\nrts_info->flags &= ~IEEE80211_TX_CTL_NO_ACK;\r\nrts_info->control.hw_key = NULL;\r\ndata_length += rt2x00crypto_tx_overhead(rt2x00dev, skb);\r\nif (tx_info->control.rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT)\r\nieee80211_ctstoself_get(rt2x00dev->hw, tx_info->control.vif,\r\nfrag_skb->data, data_length, tx_info,\r\n(struct ieee80211_cts *)(skb->data));\r\nelse\r\nieee80211_rts_get(rt2x00dev->hw, tx_info->control.vif,\r\nfrag_skb->data, data_length, tx_info,\r\n(struct ieee80211_rts *)(skb->data));\r\nretval = rt2x00queue_write_tx_frame(queue, skb, true);\r\nif (retval) {\r\ndev_kfree_skb_any(skb);\r\nWARNING(rt2x00dev, "Failed to send RTS/CTS frame.\n");\r\n}\r\nreturn retval;\r\n}\r\nvoid rt2x00mac_tx(struct ieee80211_hw *hw, struct sk_buff *skb)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\r\nenum data_queue_qid qid = skb_get_queue_mapping(skb);\r\nstruct data_queue *queue = NULL;\r\nif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\r\ngoto exit_free_skb;\r\nif (tx_info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM &&\r\ntest_bit(REQUIRE_ATIM_QUEUE, &rt2x00dev->cap_flags))\r\nqid = QID_ATIM;\r\nqueue = rt2x00queue_get_tx_queue(rt2x00dev, qid);\r\nif (unlikely(!queue)) {\r\nERROR(rt2x00dev,\r\n"Attempt to send packet over invalid queue %d.\n"\r\n"Please file bug report to %s.\n", qid, DRV_PROJECT);\r\ngoto exit_free_skb;\r\n}\r\nif (!rt2x00dev->ops->hw->set_rts_threshold &&\r\n(tx_info->control.rates[0].flags & (IEEE80211_TX_RC_USE_RTS_CTS |\r\nIEEE80211_TX_RC_USE_CTS_PROTECT))) {\r\nif (rt2x00queue_available(queue) <= 1)\r\ngoto exit_fail;\r\nif (rt2x00mac_tx_rts_cts(rt2x00dev, queue, skb))\r\ngoto exit_fail;\r\n}\r\nif (unlikely(rt2x00queue_write_tx_frame(queue, skb, false)))\r\ngoto exit_fail;\r\nspin_lock(&queue->tx_lock);\r\nif (rt2x00queue_threshold(queue))\r\nrt2x00queue_pause_queue(queue);\r\nspin_unlock(&queue->tx_lock);\r\nreturn;\r\nexit_fail:\r\nspin_lock(&queue->tx_lock);\r\nrt2x00queue_pause_queue(queue);\r\nspin_unlock(&queue->tx_lock);\r\nexit_free_skb:\r\nieee80211_free_txskb(hw, skb);\r\n}\r\nint rt2x00mac_start(struct ieee80211_hw *hw)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\r\nreturn 0;\r\nreturn rt2x00lib_start(rt2x00dev);\r\n}\r\nvoid rt2x00mac_stop(struct ieee80211_hw *hw)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\r\nreturn;\r\nrt2x00lib_stop(rt2x00dev);\r\n}\r\nint rt2x00mac_add_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nstruct rt2x00_intf *intf = vif_to_intf(vif);\r\nstruct data_queue *queue = rt2x00dev->bcn;\r\nstruct queue_entry *entry = NULL;\r\nunsigned int i;\r\nif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags) ||\r\n!test_bit(DEVICE_STATE_STARTED, &rt2x00dev->flags))\r\nreturn -ENODEV;\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_AP:\r\nif (rt2x00dev->intf_sta_count)\r\nreturn -ENOBUFS;\r\nif (rt2x00dev->intf_ap_count >= rt2x00dev->ops->max_ap_intf)\r\nreturn -ENOBUFS;\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\ncase NL80211_IFTYPE_ADHOC:\r\ncase NL80211_IFTYPE_MESH_POINT:\r\ncase NL80211_IFTYPE_WDS:\r\nif (rt2x00dev->intf_ap_count)\r\nreturn -ENOBUFS;\r\nif (rt2x00dev->intf_sta_count >= rt2x00dev->ops->max_sta_intf)\r\nreturn -ENOBUFS;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < queue->limit; i++) {\r\nentry = &queue->entries[i];\r\nif (!test_and_set_bit(ENTRY_BCN_ASSIGNED, &entry->flags))\r\nbreak;\r\n}\r\nif (unlikely(i == queue->limit))\r\nreturn -ENOBUFS;\r\nif (vif->type == NL80211_IFTYPE_AP)\r\nrt2x00dev->intf_ap_count++;\r\nelse\r\nrt2x00dev->intf_sta_count++;\r\nspin_lock_init(&intf->seqlock);\r\nmutex_init(&intf->beacon_skb_mutex);\r\nintf->beacon = entry;\r\nrt2x00lib_config_intf(rt2x00dev, intf, vif->type,\r\nvif->addr, NULL);\r\nrt2x00dev->packet_filter = 0;\r\nreturn 0;\r\n}\r\nvoid rt2x00mac_remove_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nstruct rt2x00_intf *intf = vif_to_intf(vif);\r\nif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags) ||\r\n(vif->type == NL80211_IFTYPE_AP && !rt2x00dev->intf_ap_count) ||\r\n(vif->type != NL80211_IFTYPE_AP && !rt2x00dev->intf_sta_count))\r\nreturn;\r\nif (vif->type == NL80211_IFTYPE_AP)\r\nrt2x00dev->intf_ap_count--;\r\nelse\r\nrt2x00dev->intf_sta_count--;\r\nclear_bit(ENTRY_BCN_ASSIGNED, &intf->beacon->flags);\r\nrt2x00lib_config_intf(rt2x00dev, intf,\r\nNL80211_IFTYPE_UNSPECIFIED, NULL, NULL);\r\n}\r\nint rt2x00mac_config(struct ieee80211_hw *hw, u32 changed)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nstruct ieee80211_conf *conf = &hw->conf;\r\nif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\r\nreturn 0;\r\nrt2x00queue_stop_queue(rt2x00dev->rx);\r\nrt2x00lib_config(rt2x00dev, conf, changed);\r\nrt2x00lib_config_antenna(rt2x00dev, rt2x00dev->default_ant);\r\nrt2x00queue_start_queue(rt2x00dev->rx);\r\nreturn 0;\r\n}\r\nvoid rt2x00mac_configure_filter(struct ieee80211_hw *hw,\r\nunsigned int changed_flags,\r\nunsigned int *total_flags,\r\nu64 multicast)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\n*total_flags &=\r\nFIF_ALLMULTI |\r\nFIF_FCSFAIL |\r\nFIF_PLCPFAIL |\r\nFIF_CONTROL |\r\nFIF_PSPOLL |\r\nFIF_OTHER_BSS |\r\nFIF_PROMISC_IN_BSS;\r\n*total_flags |= FIF_ALLMULTI;\r\nif (*total_flags & FIF_OTHER_BSS ||\r\n*total_flags & FIF_PROMISC_IN_BSS)\r\n*total_flags |= FIF_PROMISC_IN_BSS | FIF_OTHER_BSS;\r\nif (!test_bit(CAPABILITY_CONTROL_FILTERS, &rt2x00dev->cap_flags)) {\r\nif (*total_flags & FIF_CONTROL || *total_flags & FIF_PSPOLL)\r\n*total_flags |= FIF_CONTROL | FIF_PSPOLL;\r\n}\r\nif (!test_bit(CAPABILITY_CONTROL_FILTER_PSPOLL, &rt2x00dev->cap_flags)) {\r\nif (*total_flags & FIF_CONTROL)\r\n*total_flags |= FIF_PSPOLL;\r\n}\r\nif (rt2x00dev->packet_filter == *total_flags)\r\nreturn;\r\nrt2x00dev->packet_filter = *total_flags;\r\nrt2x00dev->ops->lib->config_filter(rt2x00dev, *total_flags);\r\n}\r\nstatic void rt2x00mac_set_tim_iter(void *data, u8 *mac,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct rt2x00_intf *intf = vif_to_intf(vif);\r\nif (vif->type != NL80211_IFTYPE_AP &&\r\nvif->type != NL80211_IFTYPE_ADHOC &&\r\nvif->type != NL80211_IFTYPE_MESH_POINT &&\r\nvif->type != NL80211_IFTYPE_WDS)\r\nreturn;\r\nset_bit(DELAYED_UPDATE_BEACON, &intf->delayed_flags);\r\n}\r\nint rt2x00mac_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\r\nbool set)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nreturn 0;\r\nieee80211_iterate_active_interfaces_atomic(rt2x00dev->hw,\r\nrt2x00mac_set_tim_iter,\r\nrt2x00dev);\r\nieee80211_queue_work(rt2x00dev->hw, &rt2x00dev->intf_work);\r\nreturn 0;\r\n}\r\nstatic void memcpy_tkip(struct rt2x00lib_crypto *crypto, u8 *key, u8 key_len)\r\n{\r\nif (key_len > NL80211_TKIP_DATA_OFFSET_ENCR_KEY)\r\nmemcpy(crypto->key,\r\n&key[NL80211_TKIP_DATA_OFFSET_ENCR_KEY],\r\nsizeof(crypto->key));\r\nif (key_len > NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY)\r\nmemcpy(crypto->tx_mic,\r\n&key[NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY],\r\nsizeof(crypto->tx_mic));\r\nif (key_len > NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY)\r\nmemcpy(crypto->rx_mic,\r\n&key[NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY],\r\nsizeof(crypto->rx_mic));\r\n}\r\nint rt2x00mac_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\r\nstruct ieee80211_vif *vif, struct ieee80211_sta *sta,\r\nstruct ieee80211_key_conf *key)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nint (*set_key) (struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00lib_crypto *crypto,\r\nstruct ieee80211_key_conf *key);\r\nstruct rt2x00lib_crypto crypto;\r\nstatic const u8 bcast_addr[ETH_ALEN] =\r\n{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, };\r\nstruct rt2x00_sta *sta_priv = NULL;\r\nif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\r\nreturn 0;\r\nelse if (!test_bit(CAPABILITY_HW_CRYPTO, &rt2x00dev->cap_flags))\r\nreturn -EOPNOTSUPP;\r\nelse if (key->keylen > 32)\r\nreturn -ENOSPC;\r\nmemset(&crypto, 0, sizeof(crypto));\r\ncrypto.bssidx = rt2x00lib_get_bssidx(rt2x00dev, vif);\r\ncrypto.cipher = rt2x00crypto_key_to_cipher(key);\r\nif (crypto.cipher == CIPHER_NONE)\r\nreturn -EOPNOTSUPP;\r\ncrypto.cmd = cmd;\r\nif (sta) {\r\ncrypto.address = sta->addr;\r\nsta_priv = sta_to_rt2x00_sta(sta);\r\ncrypto.wcid = sta_priv->wcid;\r\n} else\r\ncrypto.address = bcast_addr;\r\nif (crypto.cipher == CIPHER_TKIP)\r\nmemcpy_tkip(&crypto, &key->key[0], key->keylen);\r\nelse\r\nmemcpy(crypto.key, &key->key[0], key->keylen);\r\nif (cmd == SET_KEY)\r\nkey->hw_key_idx = 0;\r\nif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\r\nset_key = rt2x00dev->ops->lib->config_pairwise_key;\r\nelse\r\nset_key = rt2x00dev->ops->lib->config_shared_key;\r\nif (!set_key)\r\nreturn -EOPNOTSUPP;\r\nreturn set_key(rt2x00dev, &crypto, key);\r\n}\r\nint rt2x00mac_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nstruct rt2x00_sta *sta_priv = sta_to_rt2x00_sta(sta);\r\nif (rt2x00dev->ops->lib->sta_add(rt2x00dev, vif, sta))\r\nsta_priv->wcid = -1;\r\nreturn 0;\r\n}\r\nint rt2x00mac_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nstruct rt2x00_sta *sta_priv = sta_to_rt2x00_sta(sta);\r\nif (sta_priv->wcid < 0)\r\nreturn 0;\r\nreturn rt2x00dev->ops->lib->sta_remove(rt2x00dev, sta_priv->wcid);\r\n}\r\nvoid rt2x00mac_sw_scan_start(struct ieee80211_hw *hw)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nset_bit(DEVICE_STATE_SCANNING, &rt2x00dev->flags);\r\nrt2x00link_stop_tuner(rt2x00dev);\r\n}\r\nvoid rt2x00mac_sw_scan_complete(struct ieee80211_hw *hw)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nclear_bit(DEVICE_STATE_SCANNING, &rt2x00dev->flags);\r\nrt2x00link_start_tuner(rt2x00dev);\r\n}\r\nint rt2x00mac_get_stats(struct ieee80211_hw *hw,\r\nstruct ieee80211_low_level_stats *stats)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nmemcpy(stats, &rt2x00dev->low_level_stats, sizeof(*stats));\r\nreturn 0;\r\n}\r\nvoid rt2x00mac_bss_info_changed(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_bss_conf *bss_conf,\r\nu32 changes)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nstruct rt2x00_intf *intf = vif_to_intf(vif);\r\nif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\r\nreturn;\r\nif (changes & BSS_CHANGED_BSSID)\r\nrt2x00lib_config_intf(rt2x00dev, intf, vif->type, NULL,\r\nbss_conf->bssid);\r\nif (changes & BSS_CHANGED_BEACON && rt2x00_is_usb(rt2x00dev))\r\nrt2x00queue_update_beacon(rt2x00dev, vif);\r\nif (changes & BSS_CHANGED_BEACON_ENABLED) {\r\nif (!bss_conf->enable_beacon && intf->enable_beacon) {\r\nrt2x00queue_clear_beacon(rt2x00dev, vif);\r\nrt2x00dev->intf_beaconing--;\r\nintf->enable_beacon = false;\r\nif (rt2x00dev->intf_beaconing == 0) {\r\nmutex_lock(&intf->beacon_skb_mutex);\r\nrt2x00queue_stop_queue(rt2x00dev->bcn);\r\nmutex_unlock(&intf->beacon_skb_mutex);\r\n}\r\n} else if (bss_conf->enable_beacon && !intf->enable_beacon) {\r\nrt2x00dev->intf_beaconing++;\r\nintf->enable_beacon = true;\r\nif (rt2x00dev->intf_beaconing == 1) {\r\nmutex_lock(&intf->beacon_skb_mutex);\r\nrt2x00queue_start_queue(rt2x00dev->bcn);\r\nmutex_unlock(&intf->beacon_skb_mutex);\r\n}\r\n}\r\n}\r\nif (changes & BSS_CHANGED_ASSOC) {\r\nrt2x00dev->link.count = 0;\r\nif (bss_conf->assoc)\r\nrt2x00dev->intf_associated++;\r\nelse\r\nrt2x00dev->intf_associated--;\r\nrt2x00leds_led_assoc(rt2x00dev, !!rt2x00dev->intf_associated);\r\n}\r\nif (changes & (BSS_CHANGED_ERP_CTS_PROT | BSS_CHANGED_ERP_PREAMBLE |\r\nBSS_CHANGED_ERP_SLOT | BSS_CHANGED_BASIC_RATES |\r\nBSS_CHANGED_BEACON_INT | BSS_CHANGED_HT))\r\nrt2x00lib_config_erp(rt2x00dev, intf, bss_conf, changes);\r\n}\r\nint rt2x00mac_conf_tx(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, u16 queue_idx,\r\nconst struct ieee80211_tx_queue_params *params)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nstruct data_queue *queue;\r\nqueue = rt2x00queue_get_tx_queue(rt2x00dev, queue_idx);\r\nif (unlikely(!queue))\r\nreturn -EINVAL;\r\nif (params->cw_min > 0)\r\nqueue->cw_min = fls(params->cw_min);\r\nelse\r\nqueue->cw_min = 5;\r\nif (params->cw_max > 0)\r\nqueue->cw_max = fls(params->cw_max);\r\nelse\r\nqueue->cw_max = 10;\r\nqueue->aifs = params->aifs;\r\nqueue->txop = params->txop;\r\nINFO(rt2x00dev,\r\n"Configured TX queue %d - CWmin: %d, CWmax: %d, Aifs: %d, TXop: %d.\n",\r\nqueue_idx, queue->cw_min, queue->cw_max, queue->aifs, queue->txop);\r\nreturn 0;\r\n}\r\nvoid rt2x00mac_rfkill_poll(struct ieee80211_hw *hw)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nbool active = !!rt2x00dev->ops->lib->rfkill_poll(rt2x00dev);\r\nwiphy_rfkill_set_hw_state(hw->wiphy, !active);\r\n}\r\nvoid rt2x00mac_flush(struct ieee80211_hw *hw, bool drop)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nstruct data_queue *queue;\r\ntx_queue_for_each(rt2x00dev, queue)\r\nrt2x00queue_flush_queue(queue, drop);\r\n}\r\nint rt2x00mac_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nstruct link_ant *ant = &rt2x00dev->link.ant;\r\nstruct antenna_setup *def = &rt2x00dev->default_ant;\r\nstruct antenna_setup setup;\r\nif (!tx_ant || (tx_ant & ~3) || !rx_ant || (rx_ant & ~3))\r\nreturn -EINVAL;\r\nif (ant->flags & ANTENNA_TX_DIVERSITY && tx_ant != 3)\r\nant->flags &= ~ANTENNA_TX_DIVERSITY;\r\nif (ant->flags & ANTENNA_RX_DIVERSITY && rx_ant != 3)\r\nant->flags &= ~ANTENNA_RX_DIVERSITY;\r\nif (tx_ant == 3 && def->tx == ANTENNA_SW_DIVERSITY) {\r\ntx_ant = ANTENNA_SW_DIVERSITY;\r\nant->flags |= ANTENNA_TX_DIVERSITY;\r\n}\r\nif (rx_ant == 3 && def->rx == ANTENNA_SW_DIVERSITY) {\r\nrx_ant = ANTENNA_SW_DIVERSITY;\r\nant->flags |= ANTENNA_RX_DIVERSITY;\r\n}\r\nsetup.tx = tx_ant;\r\nsetup.rx = rx_ant;\r\nrt2x00lib_config_antenna(rt2x00dev, setup);\r\nreturn 0;\r\n}\r\nint rt2x00mac_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nstruct link_ant *ant = &rt2x00dev->link.ant;\r\nstruct antenna_setup *active = &rt2x00dev->link.ant.active;\r\nif (ant->flags & ANTENNA_TX_DIVERSITY)\r\n*tx_ant = ANTENNA_HW_DIVERSITY;\r\nelse\r\n*tx_ant = active->tx;\r\nif (ant->flags & ANTENNA_RX_DIVERSITY)\r\n*rx_ant = ANTENNA_HW_DIVERSITY;\r\nelse\r\n*rx_ant = active->rx;\r\nreturn 0;\r\n}\r\nvoid rt2x00mac_get_ringparam(struct ieee80211_hw *hw,\r\nu32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nstruct data_queue *queue;\r\ntx_queue_for_each(rt2x00dev, queue) {\r\n*tx += queue->length;\r\n*tx_max += queue->limit;\r\n}\r\n*rx = rt2x00dev->rx->length;\r\n*rx_max = rt2x00dev->rx->limit;\r\n}\r\nbool rt2x00mac_tx_frames_pending(struct ieee80211_hw *hw)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nstruct data_queue *queue;\r\ntx_queue_for_each(rt2x00dev, queue) {\r\nif (!rt2x00queue_empty(queue))\r\nreturn true;\r\n}\r\nreturn false;\r\n}
