static void lm4550_regfile_init(void)\r\n{\r\nint i;\r\nfor (i = 0; i < 64; i++)\r\nif (lm4550_regfile[i].flag & LM4550_REG_FAKEPROBE)\r\nlm4550_regfile[i].value = lm4550_regfile[i].def;\r\n}\r\nstatic void lm4550_regfile_write_values_after_init(struct snd_ac97 *ac97)\r\n{\r\nint i;\r\nfor (i = 0; i < 64; i++)\r\nif ((lm4550_regfile[i].flag & LM4550_REG_FAKEPROBE) &&\r\n(lm4550_regfile[i].value != lm4550_regfile[i].def)) {\r\nPDEBUG(CODEC_FAKE, "lm4550_regfile_write_values_after_"\r\n"init(): reg=0x%x value=0x%x / %d is different "\r\n"from def=0x%x / %d\n",\r\ni, lm4550_regfile[i].value,\r\nlm4550_regfile[i].value, lm4550_regfile[i].def,\r\nlm4550_regfile[i].def);\r\nsnd_ac97_write(ac97, i * 2, lm4550_regfile[i].value);\r\nlm4550_regfile[i].flag |= LM4550_REG_DONEREAD;\r\n}\r\n}\r\nstatic size_t\r\nsnd_ml403_ac97cr_playback_ind2_zero(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_indirect2 *rec)\r\n{\r\nstruct snd_ml403_ac97cr *ml403_ac97cr;\r\nint copied_words = 0;\r\nu32 full = 0;\r\nml403_ac97cr = snd_pcm_substream_chip(substream);\r\nspin_lock(&ml403_ac97cr->reg_lock);\r\nwhile ((full = (in_be32(CR_REG(ml403_ac97cr, STATUS)) &\r\nCR_PLAYFULL)) != CR_PLAYFULL) {\r\nout_be32(CR_REG(ml403_ac97cr, PLAYFIFO), 0);\r\ncopied_words++;\r\n}\r\nrec->hw_ready = 0;\r\nspin_unlock(&ml403_ac97cr->reg_lock);\r\nreturn (size_t) (copied_words * 2);\r\n}\r\nstatic size_t\r\nsnd_ml403_ac97cr_playback_ind2_copy(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_indirect2 *rec,\r\nsize_t bytes)\r\n{\r\nstruct snd_ml403_ac97cr *ml403_ac97cr;\r\nu16 *src;\r\nint copied_words = 0;\r\nu32 full = 0;\r\nml403_ac97cr = snd_pcm_substream_chip(substream);\r\nsrc = (u16 *)(substream->runtime->dma_area + rec->sw_data);\r\nspin_lock(&ml403_ac97cr->reg_lock);\r\nwhile (((full = (in_be32(CR_REG(ml403_ac97cr, STATUS)) &\r\nCR_PLAYFULL)) != CR_PLAYFULL) && (bytes > 1)) {\r\nout_be32(CR_REG(ml403_ac97cr, PLAYFIFO),\r\nCR_PLAYDATA(src[copied_words]));\r\ncopied_words++;\r\nbytes = bytes - 2;\r\n}\r\nif (full != CR_PLAYFULL)\r\nrec->hw_ready = 1;\r\nelse\r\nrec->hw_ready = 0;\r\nspin_unlock(&ml403_ac97cr->reg_lock);\r\nreturn (size_t) (copied_words * 2);\r\n}\r\nstatic size_t\r\nsnd_ml403_ac97cr_capture_ind2_null(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_indirect2 *rec)\r\n{\r\nstruct snd_ml403_ac97cr *ml403_ac97cr;\r\nint copied_words = 0;\r\nu32 empty = 0;\r\nml403_ac97cr = snd_pcm_substream_chip(substream);\r\nspin_lock(&ml403_ac97cr->reg_lock);\r\nwhile ((empty = (in_be32(CR_REG(ml403_ac97cr, STATUS)) &\r\nCR_RECEMPTY)) != CR_RECEMPTY) {\r\nvolatile u32 trash;\r\ntrash = CR_RECDATA(in_be32(CR_REG(ml403_ac97cr, RECFIFO)));\r\ntrash++;\r\ncopied_words++;\r\n}\r\nrec->hw_ready = 0;\r\nspin_unlock(&ml403_ac97cr->reg_lock);\r\nreturn (size_t) (copied_words * 2);\r\n}\r\nstatic size_t\r\nsnd_ml403_ac97cr_capture_ind2_copy(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_indirect2 *rec, size_t bytes)\r\n{\r\nstruct snd_ml403_ac97cr *ml403_ac97cr;\r\nu16 *dst;\r\nint copied_words = 0;\r\nu32 empty = 0;\r\nml403_ac97cr = snd_pcm_substream_chip(substream);\r\ndst = (u16 *)(substream->runtime->dma_area + rec->sw_data);\r\nspin_lock(&ml403_ac97cr->reg_lock);\r\nwhile (((empty = (in_be32(CR_REG(ml403_ac97cr, STATUS)) &\r\nCR_RECEMPTY)) != CR_RECEMPTY) && (bytes > 1)) {\r\ndst[copied_words] = CR_RECDATA(in_be32(CR_REG(ml403_ac97cr,\r\nRECFIFO)));\r\ncopied_words++;\r\nbytes = bytes - 2;\r\n}\r\nif (empty != CR_RECEMPTY)\r\nrec->hw_ready = 1;\r\nelse\r\nrec->hw_ready = 0;\r\nspin_unlock(&ml403_ac97cr->reg_lock);\r\nreturn (size_t) (copied_words * 2);\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_ml403_ac97cr_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ml403_ac97cr *ml403_ac97cr;\r\nstruct snd_pcm_indirect2 *ind2_rec = NULL;\r\nml403_ac97cr = snd_pcm_substream_chip(substream);\r\nif (substream == ml403_ac97cr->playback_substream)\r\nind2_rec = &ml403_ac97cr->ind_rec;\r\nif (substream == ml403_ac97cr->capture_substream)\r\nind2_rec = &ml403_ac97cr->capture_ind2_rec;\r\nif (ind2_rec != NULL)\r\nreturn snd_pcm_indirect2_pointer(substream, ind2_rec);\r\nreturn (snd_pcm_uframes_t) 0;\r\n}\r\nstatic int\r\nsnd_ml403_ac97cr_pcm_playback_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_ml403_ac97cr *ml403_ac97cr;\r\nint err = 0;\r\nml403_ac97cr = snd_pcm_substream_chip(substream);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nPDEBUG(WORK_INFO, "trigger(playback): START\n");\r\nml403_ac97cr->ind_rec.hw_ready = 1;\r\nout_be32(CR_REG(ml403_ac97cr, RESETFIFO), CR_PLAYRESET);\r\nml403_ac97cr->enable_irq = 1;\r\nenable_irq(ml403_ac97cr->irq);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nPDEBUG(WORK_INFO, "trigger(playback): STOP\n");\r\nml403_ac97cr->ind_rec.hw_ready = 0;\r\n#ifdef SND_PCM_INDIRECT2_STAT\r\nsnd_pcm_indirect2_stat(substream, &ml403_ac97cr->ind_rec);\r\n#endif\r\ndisable_irq_nosync(ml403_ac97cr->irq);\r\nml403_ac97cr->enable_irq = 0;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nPDEBUG(WORK_INFO, "trigger(playback): (done)\n");\r\nreturn err;\r\n}\r\nstatic int\r\nsnd_ml403_ac97cr_pcm_capture_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_ml403_ac97cr *ml403_ac97cr;\r\nint err = 0;\r\nml403_ac97cr = snd_pcm_substream_chip(substream);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nPDEBUG(WORK_INFO, "trigger(capture): START\n");\r\nml403_ac97cr->capture_ind2_rec.hw_ready = 0;\r\nout_be32(CR_REG(ml403_ac97cr, RESETFIFO), CR_RECRESET);\r\nml403_ac97cr->enable_capture_irq = 1;\r\nenable_irq(ml403_ac97cr->capture_irq);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nPDEBUG(WORK_INFO, "trigger(capture): STOP\n");\r\nml403_ac97cr->capture_ind2_rec.hw_ready = 0;\r\n#ifdef SND_PCM_INDIRECT2_STAT\r\nsnd_pcm_indirect2_stat(substream,\r\n&ml403_ac97cr->capture_ind2_rec);\r\n#endif\r\ndisable_irq_nosync(ml403_ac97cr->capture_irq);\r\nml403_ac97cr->enable_capture_irq = 0;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nPDEBUG(WORK_INFO, "trigger(capture): (done)\n");\r\nreturn err;\r\n}\r\nstatic int\r\nsnd_ml403_ac97cr_pcm_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ml403_ac97cr *ml403_ac97cr;\r\nstruct snd_pcm_runtime *runtime;\r\nml403_ac97cr = snd_pcm_substream_chip(substream);\r\nruntime = substream->runtime;\r\nPDEBUG(WORK_INFO,\r\n"prepare(): period_bytes=%d, minperiod_bytes=%d\n",\r\nsnd_pcm_lib_period_bytes(substream), CR_FIFO_SIZE / 2);\r\nsnd_ac97_set_rate(ml403_ac97cr->ac97, AC97_PCM_FRONT_DAC_RATE,\r\nruntime->rate);\r\nPDEBUG(WORK_INFO, "prepare(): rate=%d\n", runtime->rate);\r\nmemset(&ml403_ac97cr->ind_rec, 0,\r\nsizeof(struct snd_pcm_indirect2));\r\nml403_ac97cr->ind_rec.hw_buffer_size = CR_FIFO_SIZE;\r\nml403_ac97cr->ind_rec.sw_buffer_size =\r\nsnd_pcm_lib_buffer_bytes(substream);\r\nml403_ac97cr->ind_rec.min_periods = -1;\r\nml403_ac97cr->ind_rec.min_multiple =\r\nsnd_pcm_lib_period_bytes(substream) / (CR_FIFO_SIZE / 2);\r\nPDEBUG(WORK_INFO, "prepare(): hw_buffer_size=%d, "\r\n"sw_buffer_size=%d, min_multiple=%d\n",\r\nCR_FIFO_SIZE, ml403_ac97cr->ind_rec.sw_buffer_size,\r\nml403_ac97cr->ind_rec.min_multiple);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_ml403_ac97cr_pcm_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ml403_ac97cr *ml403_ac97cr;\r\nstruct snd_pcm_runtime *runtime;\r\nml403_ac97cr = snd_pcm_substream_chip(substream);\r\nruntime = substream->runtime;\r\nPDEBUG(WORK_INFO,\r\n"prepare(capture): period_bytes=%d, minperiod_bytes=%d\n",\r\nsnd_pcm_lib_period_bytes(substream), CR_FIFO_SIZE / 2);\r\nsnd_ac97_set_rate(ml403_ac97cr->ac97, AC97_PCM_LR_ADC_RATE,\r\nruntime->rate);\r\nPDEBUG(WORK_INFO, "prepare(capture): rate=%d\n", runtime->rate);\r\nmemset(&ml403_ac97cr->capture_ind2_rec, 0,\r\nsizeof(struct snd_pcm_indirect2));\r\nml403_ac97cr->capture_ind2_rec.hw_buffer_size = CR_FIFO_SIZE;\r\nml403_ac97cr->capture_ind2_rec.sw_buffer_size =\r\nsnd_pcm_lib_buffer_bytes(substream);\r\nml403_ac97cr->capture_ind2_rec.min_multiple =\r\nsnd_pcm_lib_period_bytes(substream) / (CR_FIFO_SIZE / 2);\r\nPDEBUG(WORK_INFO, "prepare(capture): hw_buffer_size=%d, "\r\n"sw_buffer_size=%d, min_multiple=%d\n", CR_FIFO_SIZE,\r\nml403_ac97cr->capture_ind2_rec.sw_buffer_size,\r\nml403_ac97cr->capture_ind2_rec.min_multiple);\r\nreturn 0;\r\n}\r\nstatic int snd_ml403_ac97cr_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nPDEBUG(WORK_INFO, "hw_free()\n");\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int\r\nsnd_ml403_ac97cr_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nPDEBUG(WORK_INFO, "hw_params(): desired buffer bytes=%d, desired "\r\n"period bytes=%d\n",\r\nparams_buffer_bytes(hw_params), params_period_bytes(hw_params));\r\nreturn snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_ml403_ac97cr_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ml403_ac97cr *ml403_ac97cr;\r\nstruct snd_pcm_runtime *runtime;\r\nml403_ac97cr = snd_pcm_substream_chip(substream);\r\nruntime = substream->runtime;\r\nPDEBUG(WORK_INFO, "open(playback)\n");\r\nml403_ac97cr->playback_substream = substream;\r\nruntime->hw = snd_ml403_ac97cr_playback;\r\nsnd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_BYTES,\r\nCR_FIFO_SIZE / 2);\r\nreturn 0;\r\n}\r\nstatic int snd_ml403_ac97cr_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ml403_ac97cr *ml403_ac97cr;\r\nstruct snd_pcm_runtime *runtime;\r\nml403_ac97cr = snd_pcm_substream_chip(substream);\r\nruntime = substream->runtime;\r\nPDEBUG(WORK_INFO, "open(capture)\n");\r\nml403_ac97cr->capture_substream = substream;\r\nruntime->hw = snd_ml403_ac97cr_capture;\r\nsnd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_BYTES,\r\nCR_FIFO_SIZE / 2);\r\nreturn 0;\r\n}\r\nstatic int snd_ml403_ac97cr_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ml403_ac97cr *ml403_ac97cr;\r\nml403_ac97cr = snd_pcm_substream_chip(substream);\r\nPDEBUG(WORK_INFO, "close(playback)\n");\r\nml403_ac97cr->playback_substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_ml403_ac97cr_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ml403_ac97cr *ml403_ac97cr;\r\nml403_ac97cr = snd_pcm_substream_chip(substream);\r\nPDEBUG(WORK_INFO, "close(capture)\n");\r\nml403_ac97cr->capture_substream = NULL;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t snd_ml403_ac97cr_irq(int irq, void *dev_id)\r\n{\r\nstruct snd_ml403_ac97cr *ml403_ac97cr;\r\nstruct platform_device *pfdev;\r\nint cmp_irq;\r\nml403_ac97cr = (struct snd_ml403_ac97cr *)dev_id;\r\nif (ml403_ac97cr == NULL)\r\nreturn IRQ_NONE;\r\npfdev = ml403_ac97cr->pfdev;\r\ncmp_irq = platform_get_irq(pfdev, 0);\r\nif (irq == cmp_irq) {\r\nif (ml403_ac97cr->enable_irq)\r\nsnd_pcm_indirect2_playback_interrupt(\r\nml403_ac97cr->playback_substream,\r\n&ml403_ac97cr->ind_rec,\r\nsnd_ml403_ac97cr_playback_ind2_copy,\r\nsnd_ml403_ac97cr_playback_ind2_zero);\r\nelse\r\ngoto __disable_irq;\r\n} else {\r\ncmp_irq = platform_get_irq(pfdev, 1);\r\nif (irq == cmp_irq) {\r\nif (ml403_ac97cr->enable_capture_irq)\r\nsnd_pcm_indirect2_capture_interrupt(\r\nml403_ac97cr->capture_substream,\r\n&ml403_ac97cr->capture_ind2_rec,\r\nsnd_ml403_ac97cr_capture_ind2_copy,\r\nsnd_ml403_ac97cr_capture_ind2_null);\r\nelse\r\ngoto __disable_irq;\r\n} else\r\nreturn IRQ_NONE;\r\n}\r\nreturn IRQ_HANDLED;\r\n__disable_irq:\r\nPDEBUG(INIT_INFO, "irq(): irq %d is meant to be disabled! So, now try "\r\n"to disable it _really_!\n", irq);\r\ndisable_irq_nosync(irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned short\r\nsnd_ml403_ac97cr_codec_read(struct snd_ac97 *ac97, unsigned short reg)\r\n{\r\nstruct snd_ml403_ac97cr *ml403_ac97cr = ac97->private_data;\r\n#ifdef CODEC_STAT\r\nu32 stat;\r\nu32 rafaccess = 0;\r\n#endif\r\nunsigned long end_time;\r\nu16 value = 0;\r\nif (!LM4550_RF_OK(reg)) {\r\nsnd_printk(KERN_WARNING SND_ML403_AC97CR_DRIVER ": "\r\n"access to unknown/unused codec register 0x%x "\r\n"ignored!\n", reg);\r\nreturn 0;\r\n}\r\nif ((lm4550_regfile[reg / 2].flag &\r\n(LM4550_REG_DONEREAD | LM4550_REG_ALLFAKE)) &&\r\n!(lm4550_regfile[reg / 2].flag & LM4550_REG_NOSHADOW)) {\r\nif (lm4550_regfile[reg / 2].flag & LM4550_REG_FAKEREAD) {\r\nPDEBUG(CODEC_FAKE, "codec_read(): faking read from "\r\n"reg=0x%x, val=0x%x / %d\n",\r\nreg, lm4550_regfile[reg / 2].def,\r\nlm4550_regfile[reg / 2].def);\r\nreturn lm4550_regfile[reg / 2].def;\r\n} else if ((lm4550_regfile[reg / 2].flag &\r\nLM4550_REG_FAKEPROBE) &&\r\nml403_ac97cr->ac97_fake) {\r\nPDEBUG(CODEC_FAKE, "codec_read(): faking read from "\r\n"reg=0x%x, val=0x%x / %d (probe)\n",\r\nreg, lm4550_regfile[reg / 2].value,\r\nlm4550_regfile[reg / 2].value);\r\nreturn lm4550_regfile[reg / 2].value;\r\n} else {\r\n#ifdef CODEC_STAT\r\nPDEBUG(CODEC_FAKE, "codec_read(): read access "\r\n"answered by shadow register 0x%x (value=0x%x "\r\n"/ %d) (cw=%d cr=%d)\n",\r\nreg, lm4550_regfile[reg / 2].value,\r\nlm4550_regfile[reg / 2].value,\r\nml403_ac97cr->ac97_write,\r\nml403_ac97cr->ac97_read);\r\n#else\r\nPDEBUG(CODEC_FAKE, "codec_read(): read access "\r\n"answered by shadow register 0x%x (value=0x%x "\r\n"/ %d)\n",\r\nreg, lm4550_regfile[reg / 2].value,\r\nlm4550_regfile[reg / 2].value);\r\n#endif\r\nreturn lm4550_regfile[reg / 2].value;\r\n}\r\n}\r\nif (mutex_lock_interruptible(&ml403_ac97cr->cdc_mutex) != 0)\r\nreturn 0;\r\n#ifdef CODEC_STAT\r\nml403_ac97cr->ac97_read++;\r\n#endif\r\nspin_lock(&ml403_ac97cr->reg_lock);\r\nout_be32(CR_REG(ml403_ac97cr, CODEC_ADDR),\r\nCR_CODEC_ADDR(reg) | CR_CODEC_READ);\r\nspin_unlock(&ml403_ac97cr->reg_lock);\r\nend_time = jiffies + (HZ / CODEC_TIMEOUT_AFTER_READ);\r\ndo {\r\nspin_lock(&ml403_ac97cr->reg_lock);\r\n#ifdef CODEC_STAT\r\nrafaccess++;\r\nstat = in_be32(CR_REG(ml403_ac97cr, STATUS));\r\nif ((stat & CR_RAF) == CR_RAF) {\r\nvalue = CR_CODEC_DATAREAD(\r\nin_be32(CR_REG(ml403_ac97cr, CODEC_DATAREAD)));\r\nPDEBUG(CODEC_SUCCESS, "codec_read(): (done) reg=0x%x, "\r\n"value=0x%x / %d (STATUS=0x%x)\n",\r\nreg, value, value, stat);\r\n#else\r\nif ((in_be32(CR_REG(ml403_ac97cr, STATUS)) &\r\nCR_RAF) == CR_RAF) {\r\nvalue = CR_CODEC_DATAREAD(\r\nin_be32(CR_REG(ml403_ac97cr, CODEC_DATAREAD)));\r\nPDEBUG(CODEC_SUCCESS, "codec_read(): (done) "\r\n"reg=0x%x, value=0x%x / %d\n",\r\nreg, value, value);\r\n#endif\r\nlm4550_regfile[reg / 2].value = value;\r\nlm4550_regfile[reg / 2].flag |= LM4550_REG_DONEREAD;\r\nspin_unlock(&ml403_ac97cr->reg_lock);\r\nmutex_unlock(&ml403_ac97cr->cdc_mutex);\r\nreturn value;\r\n}\r\nspin_unlock(&ml403_ac97cr->reg_lock);\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_after(end_time, jiffies));\r\nspin_lock(&ml403_ac97cr->reg_lock);\r\nvalue =\r\nCR_CODEC_DATAREAD(in_be32(CR_REG(ml403_ac97cr, CODEC_DATAREAD)));\r\nspin_unlock(&ml403_ac97cr->reg_lock);\r\n#ifdef CODEC_STAT\r\nsnd_printk(KERN_WARNING SND_ML403_AC97CR_DRIVER ": "\r\n"timeout while codec read! "\r\n"(reg=0x%x, last STATUS=0x%x, DATAREAD=0x%x / %d, %d) "\r\n"(cw=%d, cr=%d)\n",\r\nreg, stat, value, value, rafaccess,\r\nml403_ac97cr->ac97_write, ml403_ac97cr->ac97_read);\r\n#else\r\nsnd_printk(KERN_WARNING SND_ML403_AC97CR_DRIVER ": "\r\n"timeout while codec read! "\r\n"(reg=0x%x, DATAREAD=0x%x / %d)\n",\r\nreg, value, value);\r\n#endif\r\nlm4550_regfile[reg / 2].value = value;\r\nlm4550_regfile[reg / 2].flag |= LM4550_REG_DONEREAD;\r\nmutex_unlock(&ml403_ac97cr->cdc_mutex);\r\nreturn value;\r\n}\r\nstatic void\r\nsnd_ml403_ac97cr_codec_write(struct snd_ac97 *ac97, unsigned short reg,\r\nunsigned short val)\r\n{\r\nstruct snd_ml403_ac97cr *ml403_ac97cr = ac97->private_data;\r\n#ifdef CODEC_STAT\r\nu32 stat;\r\nu32 rafaccess = 0;\r\n#endif\r\n#ifdef CODEC_WRITE_CHECK_RAF\r\nunsigned long end_time;\r\n#endif\r\nif (!LM4550_RF_OK(reg)) {\r\nsnd_printk(KERN_WARNING SND_ML403_AC97CR_DRIVER ": "\r\n"access to unknown/unused codec register 0x%x "\r\n"ignored!\n", reg);\r\nreturn;\r\n}\r\nif (lm4550_regfile[reg / 2].flag & LM4550_REG_READONLY) {\r\nsnd_printk(KERN_WARNING SND_ML403_AC97CR_DRIVER ": "\r\n"write access to read only codec register 0x%x "\r\n"ignored!\n", reg);\r\nreturn;\r\n}\r\nif ((val & lm4550_regfile[reg / 2].wmask) != val) {\r\nsnd_printk(KERN_WARNING SND_ML403_AC97CR_DRIVER ": "\r\n"write access to codec register 0x%x "\r\n"with bad value 0x%x / %d!\n",\r\nreg, val, val);\r\nval = val & lm4550_regfile[reg / 2].wmask;\r\n}\r\nif (((lm4550_regfile[reg / 2].flag & LM4550_REG_FAKEPROBE) &&\r\nml403_ac97cr->ac97_fake) &&\r\n!(lm4550_regfile[reg / 2].flag & LM4550_REG_NOSHADOW)) {\r\nPDEBUG(CODEC_FAKE, "codec_write(): faking write to reg=0x%x, "\r\n"val=0x%x / %d\n", reg, val, val);\r\nlm4550_regfile[reg / 2].value = (val &\r\nlm4550_regfile[reg / 2].wmask);\r\nreturn;\r\n}\r\nif (mutex_lock_interruptible(&ml403_ac97cr->cdc_mutex) != 0)\r\nreturn;\r\n#ifdef CODEC_STAT\r\nml403_ac97cr->ac97_write++;\r\n#endif\r\nspin_lock(&ml403_ac97cr->reg_lock);\r\nout_be32(CR_REG(ml403_ac97cr, CODEC_DATAWRITE),\r\nCR_CODEC_DATAWRITE(val));\r\nout_be32(CR_REG(ml403_ac97cr, CODEC_ADDR),\r\nCR_CODEC_ADDR(reg) | CR_CODEC_WRITE);\r\nspin_unlock(&ml403_ac97cr->reg_lock);\r\n#ifdef CODEC_WRITE_CHECK_RAF\r\nend_time = jiffies + HZ / CODEC_TIMEOUT_AFTER_WRITE;\r\ndo {\r\nspin_lock(&ml403_ac97cr->reg_lock);\r\n#ifdef CODEC_STAT\r\nrafaccess++;\r\nstat = in_be32(CR_REG(ml403_ac97cr, STATUS))\r\nif ((stat & CR_RAF) == CR_RAF) {\r\n#else\r\nif ((in_be32(CR_REG(ml403_ac97cr, STATUS)) &\r\nCR_RAF) == CR_RAF) {\r\n#endif\r\nPDEBUG(CODEC_SUCCESS, "codec_write(): (done) "\r\n"reg=0x%x, value=%d / 0x%x\n",\r\nreg, val, val);\r\nif (!(lm4550_regfile[reg / 2].flag &\r\nLM4550_REG_NOSHADOW) &&\r\n!(lm4550_regfile[reg / 2].flag &\r\nLM4550_REG_NOSAVE))\r\nlm4550_regfile[reg / 2].value = val;\r\nlm4550_regfile[reg / 2].flag |= LM4550_REG_DONEREAD;\r\nspin_unlock(&ml403_ac97cr->reg_lock);\r\nmutex_unlock(&ml403_ac97cr->cdc_mutex);\r\nreturn;\r\n}\r\nspin_unlock(&ml403_ac97cr->reg_lock);\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_after(end_time, jiffies));\r\n#ifdef CODEC_STAT\r\nsnd_printk(KERN_WARNING SND_ML403_AC97CR_DRIVER ": "\r\n"timeout while codec write "\r\n"(reg=0x%x, val=0x%x / %d, last STATUS=0x%x, %d) "\r\n"(cw=%d, cr=%d)\n",\r\nreg, val, val, stat, rafaccess, ml403_ac97cr->ac97_write,\r\nml403_ac97cr->ac97_read);\r\n#else\r\nsnd_printk(KERN_WARNING SND_ML403_AC97CR_DRIVER ": "\r\n"timeout while codec write (reg=0x%x, val=0x%x / %d)\n",\r\nreg, val, val);\r\n#endif\r\n#else\r\n#if CODEC_WAIT_AFTER_WRITE > 0\r\nschedule_timeout_uninterruptible(HZ / CODEC_WAIT_AFTER_WRITE);\r\n#endif\r\nPDEBUG(CODEC_SUCCESS, "codec_write(): (done) "\r\n"reg=0x%x, value=%d / 0x%x (no RAF check)\n",\r\nreg, val, val);\r\n#endif\r\nmutex_unlock(&ml403_ac97cr->cdc_mutex);\r\nreturn;\r\n}\r\nstatic int __devinit\r\nsnd_ml403_ac97cr_chip_init(struct snd_ml403_ac97cr *ml403_ac97cr)\r\n{\r\nunsigned long end_time;\r\nPDEBUG(INIT_INFO, "chip_init():\n");\r\nend_time = jiffies + HZ / CODEC_TIMEOUT_ON_INIT;\r\ndo {\r\nif (in_be32(CR_REG(ml403_ac97cr, STATUS)) & CR_CODECREADY) {\r\nout_be32(CR_REG(ml403_ac97cr, RESETFIFO),\r\nCR_RECRESET | CR_PLAYRESET);\r\nPDEBUG(INIT_INFO, "chip_init(): (done)\n");\r\nreturn 0;\r\n}\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_after(end_time, jiffies));\r\nsnd_printk(KERN_ERR SND_ML403_AC97CR_DRIVER ": "\r\n"timeout while waiting for codec, "\r\n"not ready!\n");\r\nreturn -EBUSY;\r\n}\r\nstatic int snd_ml403_ac97cr_free(struct snd_ml403_ac97cr *ml403_ac97cr\r\nstatic int snd_ml403_ac97cr_dev_free(struct snd_device *snddev)\r\n{\r\nstruct snd_ml403_ac97cr *ml403_ac97cr = snddev->device_data;\r\nPDEBUG(INIT_INFO, "dev_free():\n");\r\nreturn snd_ml403_ac97cr_free(ml403_ac97cr);\r\n}\r\nstatic int __devinit\r\nsnd_ml403_ac97cr_create(struct snd_card *card, struct platform_device *pfdev,\r\nstruct snd_ml403_ac97cr **rml403_ac97cr)\r\n{\r\nstruct snd_ml403_ac97cr *ml403_ac97cr;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_ml403_ac97cr_dev_free,\r\n};\r\nstruct resource *resource;\r\nint irq;\r\n*rml403_ac97cr = NULL;\r\nml403_ac97cr = kzalloc(sizeof(*ml403_ac97cr), GFP_KERNEL);\r\nif (ml403_ac97cr == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_init(&ml403_ac97cr->reg_lock);\r\nmutex_init(&ml403_ac97cr->cdc_mutex);\r\nml403_ac97cr->card = card;\r\nml403_ac97cr->pfdev = pfdev;\r\nml403_ac97cr->irq = -1;\r\nml403_ac97cr->enable_irq = 0;\r\nml403_ac97cr->capture_irq = -1;\r\nml403_ac97cr->enable_capture_irq = 0;\r\nml403_ac97cr->port = NULL;\r\nml403_ac97cr->res_port = NULL;\r\nPDEBUG(INIT_INFO, "Trying to reserve resources now ...\n");\r\nresource = platform_get_resource(pfdev, IORESOURCE_MEM, 0);\r\nml403_ac97cr->port = ioremap_nocache(resource->start,\r\n(resource->end) -\r\n(resource->start) + 1);\r\nif (ml403_ac97cr->port == NULL) {\r\nsnd_printk(KERN_ERR SND_ML403_AC97CR_DRIVER ": "\r\n"unable to remap memory region (%pR)\n",\r\nresource);\r\nsnd_ml403_ac97cr_free(ml403_ac97cr);\r\nreturn -EBUSY;\r\n}\r\nsnd_printk(KERN_INFO SND_ML403_AC97CR_DRIVER ": "\r\n"remap controller memory region to "\r\n"0x%x done\n", (unsigned int)ml403_ac97cr->port);\r\nirq = platform_get_irq(pfdev, 0);\r\nif (request_irq(irq, snd_ml403_ac97cr_irq, 0,\r\ndev_name(&pfdev->dev), (void *)ml403_ac97cr)) {\r\nsnd_printk(KERN_ERR SND_ML403_AC97CR_DRIVER ": "\r\n"unable to grab IRQ %d\n",\r\nirq);\r\nsnd_ml403_ac97cr_free(ml403_ac97cr);\r\nreturn -EBUSY;\r\n}\r\nml403_ac97cr->irq = irq;\r\nsnd_printk(KERN_INFO SND_ML403_AC97CR_DRIVER ": "\r\n"request (playback) irq %d done\n",\r\nml403_ac97cr->irq);\r\nirq = platform_get_irq(pfdev, 1);\r\nif (request_irq(irq, snd_ml403_ac97cr_irq, 0,\r\ndev_name(&pfdev->dev), (void *)ml403_ac97cr)) {\r\nsnd_printk(KERN_ERR SND_ML403_AC97CR_DRIVER ": "\r\n"unable to grab IRQ %d\n",\r\nirq);\r\nsnd_ml403_ac97cr_free(ml403_ac97cr);\r\nreturn -EBUSY;\r\n}\r\nml403_ac97cr->capture_irq = irq;\r\nsnd_printk(KERN_INFO SND_ML403_AC97CR_DRIVER ": "\r\n"request (capture) irq %d done\n",\r\nml403_ac97cr->capture_irq);\r\nerr = snd_ml403_ac97cr_chip_init(ml403_ac97cr);\r\nif (err < 0) {\r\nsnd_ml403_ac97cr_free(ml403_ac97cr);\r\nreturn err;\r\n}\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, ml403_ac97cr, &ops);\r\nif (err < 0) {\r\nPDEBUG(INIT_FAILURE, "probe(): snd_device_new() failed!\n");\r\nsnd_ml403_ac97cr_free(ml403_ac97cr);\r\nreturn err;\r\n}\r\n*rml403_ac97cr = ml403_ac97cr;\r\nreturn 0;\r\n}\r\nstatic void snd_ml403_ac97cr_mixer_free(struct snd_ac97 *ac97)\r\n{\r\nstruct snd_ml403_ac97cr *ml403_ac97cr = ac97->private_data;\r\nPDEBUG(INIT_INFO, "mixer_free():\n");\r\nml403_ac97cr->ac97 = NULL;\r\nPDEBUG(INIT_INFO, "mixer_free(): (done)\n");\r\n}\r\nstatic int __devinit\r\nsnd_ml403_ac97cr_mixer(struct snd_ml403_ac97cr *ml403_ac97cr)\r\n{\r\nstruct snd_ac97_bus *bus;\r\nstruct snd_ac97_template ac97;\r\nint err;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = snd_ml403_ac97cr_codec_write,\r\n.read = snd_ml403_ac97cr_codec_read,\r\n};\r\nPDEBUG(INIT_INFO, "mixer():\n");\r\nerr = snd_ac97_bus(ml403_ac97cr->card, 0, &ops, NULL, &bus);\r\nif (err < 0)\r\nreturn err;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nml403_ac97cr->ac97_fake = 1;\r\nlm4550_regfile_init();\r\n#ifdef CODEC_STAT\r\nml403_ac97cr->ac97_read = 0;\r\nml403_ac97cr->ac97_write = 0;\r\n#endif\r\nac97.private_data = ml403_ac97cr;\r\nac97.private_free = snd_ml403_ac97cr_mixer_free;\r\nac97.scaps = AC97_SCAP_AUDIO | AC97_SCAP_SKIP_MODEM |\r\nAC97_SCAP_NO_SPDIF;\r\nerr = snd_ac97_mixer(bus, &ac97, &ml403_ac97cr->ac97);\r\nml403_ac97cr->ac97_fake = 0;\r\nlm4550_regfile_write_values_after_init(ml403_ac97cr->ac97);\r\nPDEBUG(INIT_INFO, "mixer(): (done) snd_ac97_mixer()=%d\n", err);\r\nreturn err;\r\n}\r\nstatic int __devinit\r\nsnd_ml403_ac97cr_pcm(struct snd_ml403_ac97cr *ml403_ac97cr, int device,\r\nstruct snd_pcm **rpcm)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nerr = snd_pcm_new(ml403_ac97cr->card, "ML403AC97CR/1", device, 1, 1,\r\n&pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_ml403_ac97cr_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&snd_ml403_ac97cr_capture_ops);\r\npcm->private_data = ml403_ac97cr;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "ML403AC97CR DAC/ADC");\r\nml403_ac97cr->pcm = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL),\r\n64 * 1024,\r\n128 * 1024);\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nstatic int __devinit snd_ml403_ac97cr_probe(struct platform_device *pfdev)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_ml403_ac97cr *ml403_ac97cr = NULL;\r\nint err;\r\nint dev = pfdev->id;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev])\r\nreturn -ENOENT;\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ml403_ac97cr_create(card, pfdev, &ml403_ac97cr);\r\nif (err < 0) {\r\nPDEBUG(INIT_FAILURE, "probe(): create failed!\n");\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nPDEBUG(INIT_INFO, "probe(): create done\n");\r\ncard->private_data = ml403_ac97cr;\r\nerr = snd_ml403_ac97cr_mixer(ml403_ac97cr);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nPDEBUG(INIT_INFO, "probe(): mixer done\n");\r\nerr = snd_ml403_ac97cr_pcm(ml403_ac97cr, 0, NULL);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nPDEBUG(INIT_INFO, "probe(): PCM done\n");\r\nstrcpy(card->driver, SND_ML403_AC97CR_DRIVER);\r\nstrcpy(card->shortname, "ML403 AC97 Controller Reference");\r\nsprintf(card->longname, "%s %s at 0x%lx, irq %i & %i, device %i",\r\ncard->shortname, card->driver,\r\n(unsigned long)ml403_ac97cr->port, ml403_ac97cr->irq,\r\nml403_ac97cr->capture_irq, dev + 1);\r\nsnd_card_set_dev(card, &pfdev->dev);\r\nerr = snd_card_register(card);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nplatform_set_drvdata(pfdev, card);\r\nPDEBUG(INIT_INFO, "probe(): (done)\n");\r\nreturn 0;\r\n}\r\nstatic int snd_ml403_ac97cr_remove(struct platform_device *pfdev)\r\n{\r\nsnd_card_free(platform_get_drvdata(pfdev));\r\nplatform_set_drvdata(pfdev, NULL);\r\nreturn 0;\r\n}
