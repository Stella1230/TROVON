unsigned int lola_sample_rate_convert(unsigned int coded)\r\n{\r\nunsigned int freq;\r\nswitch (coded & 0x3) {\r\ncase 0: freq = 48000; break;\r\ncase 1: freq = 44100; break;\r\ncase 2: freq = 32000; break;\r\ndefault: return 0;\r\n}\r\nswitch (coded & 0x1c) {\r\ncase (0 << 2): break;\r\ncase (4 << 2): break;\r\ncase (1 << 2): freq *= 2; break;\r\ncase (2 << 2): freq *= 4; break;\r\ncase (5 << 2): freq /= 2; break;\r\ncase (6 << 2): freq /= 4; break;\r\ndefault: return 0;\r\n}\r\nswitch (coded & 0x60) {\r\ncase (0 << 5): break;\r\ncase (1 << 5): freq = (freq * 999) / 1000; break;\r\ncase (2 << 5): freq = (freq * 1001) / 1000; break;\r\ndefault: return 0;\r\n}\r\nreturn freq;\r\n}\r\nstatic bool check_gran_clock_compatibility(struct lola *chip,\r\nunsigned int val,\r\nunsigned int freq)\r\n{\r\nif (!chip->granularity)\r\nreturn true;\r\nif (val < LOLA_GRANULARITY_MIN || val > LOLA_GRANULARITY_MAX ||\r\n(val % LOLA_GRANULARITY_STEP) != 0)\r\nreturn false;\r\nif (val == LOLA_GRANULARITY_MIN) {\r\nif (freq > LOLA_MAXFREQ_AT_GRANULARITY_MIN)\r\nreturn false;\r\n} else if (val < LOLA_GRANULARITY_MAX) {\r\nif (freq > LOLA_MAXFREQ_AT_GRANULARITY_BELOW_MAX)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nint lola_set_granularity(struct lola *chip, unsigned int val, bool force)\r\n{\r\nint err;\r\nif (!force) {\r\nif (val == chip->granularity)\r\nreturn 0;\r\n#if 0\r\nif (chip->audio_in_alloc_mask || chip->audio_out_alloc_mask)\r\nreturn -EBUSY;\r\n#endif\r\nif (!check_gran_clock_compatibility(chip, val,\r\nchip->clock.cur_freq))\r\nreturn -EINVAL;\r\n}\r\nchip->granularity = val;\r\nval /= LOLA_GRANULARITY_STEP;\r\nerr = lola_codec_write(chip, 1, LOLA_VERB_SET_GRANULARITY_STEPS,\r\nval, 0);\r\nif (err < 0)\r\nreturn err;\r\nusleep_range(400 * val, 20000);\r\nreturn lola_codec_flush(chip);\r\n}\r\nint __devinit lola_init_clock_widget(struct lola *chip, int nid)\r\n{\r\nunsigned int val;\r\nint i, j, nitems, nb_verbs, idx, idx_list;\r\nint err;\r\nerr = lola_read_param(chip, nid, LOLA_PAR_AUDIO_WIDGET_CAP, &val);\r\nif (err < 0) {\r\nprintk(KERN_ERR SFX "Can't read wcaps for 0x%x\n", nid);\r\nreturn err;\r\n}\r\nif ((val & 0xfff00000) != 0x01f00000) {\r\nsnd_printdd("No valid clock widget\n");\r\nreturn 0;\r\n}\r\nchip->clock.nid = nid;\r\nchip->clock.items = val & 0xff;\r\nsnd_printdd("clock_list nid=%x, entries=%d\n", nid,\r\nchip->clock.items);\r\nif (chip->clock.items > MAX_SAMPLE_CLOCK_COUNT) {\r\nprintk(KERN_ERR SFX "CLOCK_LIST too big: %d\n",\r\nchip->clock.items);\r\nreturn -EINVAL;\r\n}\r\nnitems = chip->clock.items;\r\nnb_verbs = (nitems + 3) / 4;\r\nidx = 0;\r\nidx_list = 0;\r\nfor (i = 0; i < nb_verbs; i++) {\r\nunsigned int res_ex;\r\nunsigned short items[4];\r\nerr = lola_codec_read(chip, nid, LOLA_VERB_GET_CLOCK_LIST,\r\nidx, 0, &val, &res_ex);\r\nif (err < 0) {\r\nprintk(KERN_ERR SFX "Can't read CLOCK_LIST\n");\r\nreturn -EINVAL;\r\n}\r\nitems[0] = val & 0xfff;\r\nitems[1] = (val >> 16) & 0xfff;\r\nitems[2] = res_ex & 0xfff;\r\nitems[3] = (res_ex >> 16) & 0xfff;\r\nfor (j = 0; j < 4; j++) {\r\nunsigned char type = items[j] >> 8;\r\nunsigned int freq = items[j] & 0xff;\r\nint format = LOLA_CLOCK_FORMAT_NONE;\r\nbool add_clock = true;\r\nif (type == LOLA_CLOCK_TYPE_INTERNAL) {\r\nfreq = lola_sample_rate_convert(freq);\r\nif (freq < chip->sample_rate_min)\r\nadd_clock = false;\r\nelse if (freq == 48000) {\r\nchip->clock.cur_index = idx_list;\r\nchip->clock.cur_freq = 48000;\r\nchip->clock.cur_valid = true;\r\n}\r\n} else if (type == LOLA_CLOCK_TYPE_VIDEO) {\r\nfreq = lola_sample_rate_convert(freq);\r\nif (freq < chip->sample_rate_min)\r\nadd_clock = false;\r\nif (items[j] & 0x80)\r\nformat = LOLA_CLOCK_FORMAT_NTSC;\r\nelse\r\nformat = LOLA_CLOCK_FORMAT_PAL;\r\n}\r\nif (add_clock) {\r\nstruct lola_sample_clock *sc;\r\nsc = &chip->clock.sample_clock[idx_list];\r\nsc->type = type;\r\nsc->format = format;\r\nsc->freq = freq;\r\nchip->clock.idx_lookup[idx_list] = idx;\r\nidx_list++;\r\n} else {\r\nchip->clock.items--;\r\n}\r\nif (++idx >= nitems)\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint lola_enable_clock_events(struct lola *chip)\r\n{\r\nunsigned int res;\r\nint err;\r\nerr = lola_codec_read(chip, chip->clock.nid,\r\nLOLA_VERB_SET_UNSOLICITED_ENABLE,\r\nLOLA_UNSOLICITED_ENABLE | LOLA_UNSOLICITED_TAG,\r\n0, &res, NULL);\r\nif (err < 0)\r\nreturn err;\r\nif (res) {\r\nprintk(KERN_WARNING SFX "error in enable_clock_events %d\n",\r\nres);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint lola_set_clock_index(struct lola *chip, unsigned int idx)\r\n{\r\nunsigned int res;\r\nint err;\r\nerr = lola_codec_read(chip, chip->clock.nid,\r\nLOLA_VERB_SET_CLOCK_SELECT,\r\nchip->clock.idx_lookup[idx],\r\n0, &res, NULL);\r\nif (err < 0)\r\nreturn err;\r\nif (res) {\r\nprintk(KERN_WARNING SFX "error in set_clock %d\n", res);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nbool lola_update_ext_clock_freq(struct lola *chip, unsigned int val)\r\n{\r\nunsigned int tag;\r\nif (!val)\r\nreturn false;\r\ntag = (val >> LOLA_UNSOL_RESP_TAG_OFFSET) & LOLA_UNSOLICITED_TAG_MASK;\r\nif (tag != LOLA_UNSOLICITED_TAG)\r\nreturn false;\r\nif (chip->clock.sample_clock[chip->clock.cur_index].type !=\r\nLOLA_CLOCK_TYPE_INTERNAL) {\r\nchip->clock.cur_freq = lola_sample_rate_convert(val & 0x7f);\r\nchip->clock.cur_valid = (val & 0x100) != 0;\r\n}\r\nreturn true;\r\n}\r\nint lola_set_clock(struct lola *chip, int idx)\r\n{\r\nint freq = 0;\r\nbool valid = false;\r\nif (idx == chip->clock.cur_index) {\r\nfreq = chip->clock.cur_freq;\r\nvalid = chip->clock.cur_valid;\r\n} else if (chip->clock.sample_clock[idx].type ==\r\nLOLA_CLOCK_TYPE_INTERNAL) {\r\nfreq = chip->clock.sample_clock[idx].freq;\r\nvalid = true;\r\n}\r\nif (!freq || !valid)\r\nreturn -EINVAL;\r\nif (!check_gran_clock_compatibility(chip, chip->granularity, freq))\r\nreturn -EINVAL;\r\nif (idx != chip->clock.cur_index) {\r\nint err = lola_set_clock_index(chip, idx);\r\nif (err < 0)\r\nreturn err;\r\nchip->clock.cur_index = idx;\r\nchip->clock.cur_freq = freq;\r\nchip->clock.cur_valid = true;\r\n}\r\nreturn 0;\r\n}\r\nint lola_set_sample_rate(struct lola *chip, int rate)\r\n{\r\nint i;\r\nif (chip->clock.cur_freq == rate && chip->clock.cur_valid)\r\nreturn 0;\r\nfor (i = 0; i < chip->clock.items; i++) {\r\nif (chip->clock.sample_clock[i].type == LOLA_CLOCK_TYPE_INTERNAL &&\r\nchip->clock.sample_clock[i].freq == rate)\r\nbreak;\r\n}\r\nif (i >= chip->clock.items)\r\nreturn -EINVAL;\r\nreturn lola_set_clock(chip, i);\r\n}
