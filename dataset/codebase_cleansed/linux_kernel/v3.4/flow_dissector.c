static void iph_to_flow_copy_addrs(struct flow_keys *flow, const struct iphdr *iph)\r\n{\r\nBUILD_BUG_ON(offsetof(typeof(*flow), dst) !=\r\noffsetof(typeof(*flow), src) + sizeof(flow->src));\r\nmemcpy(&flow->src, &iph->saddr, sizeof(flow->src) + sizeof(flow->dst));\r\n}\r\nbool skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow)\r\n{\r\nint poff, nhoff = skb_network_offset(skb);\r\nu8 ip_proto;\r\n__be16 proto = skb->protocol;\r\nmemset(flow, 0, sizeof(*flow));\r\nagain:\r\nswitch (proto) {\r\ncase __constant_htons(ETH_P_IP): {\r\nconst struct iphdr *iph;\r\nstruct iphdr _iph;\r\nip:\r\niph = skb_header_pointer(skb, nhoff, sizeof(_iph), &_iph);\r\nif (!iph)\r\nreturn false;\r\nif (ip_is_fragment(iph))\r\nip_proto = 0;\r\nelse\r\nip_proto = iph->protocol;\r\niph_to_flow_copy_addrs(flow, iph);\r\nnhoff += iph->ihl * 4;\r\nbreak;\r\n}\r\ncase __constant_htons(ETH_P_IPV6): {\r\nconst struct ipv6hdr *iph;\r\nstruct ipv6hdr _iph;\r\nipv6:\r\niph = skb_header_pointer(skb, nhoff, sizeof(_iph), &_iph);\r\nif (!iph)\r\nreturn false;\r\nip_proto = iph->nexthdr;\r\nflow->src = iph->saddr.s6_addr32[3];\r\nflow->dst = iph->daddr.s6_addr32[3];\r\nnhoff += sizeof(struct ipv6hdr);\r\nbreak;\r\n}\r\ncase __constant_htons(ETH_P_8021Q): {\r\nconst struct vlan_hdr *vlan;\r\nstruct vlan_hdr _vlan;\r\nvlan = skb_header_pointer(skb, nhoff, sizeof(_vlan), &_vlan);\r\nif (!vlan)\r\nreturn false;\r\nproto = vlan->h_vlan_encapsulated_proto;\r\nnhoff += sizeof(*vlan);\r\ngoto again;\r\n}\r\ncase __constant_htons(ETH_P_PPP_SES): {\r\nstruct {\r\nstruct pppoe_hdr hdr;\r\n__be16 proto;\r\n} *hdr, _hdr;\r\nhdr = skb_header_pointer(skb, nhoff, sizeof(_hdr), &_hdr);\r\nif (!hdr)\r\nreturn false;\r\nproto = hdr->proto;\r\nnhoff += PPPOE_SES_HLEN;\r\nswitch (proto) {\r\ncase __constant_htons(PPP_IP):\r\ngoto ip;\r\ncase __constant_htons(PPP_IPV6):\r\ngoto ipv6;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\ndefault:\r\nreturn false;\r\n}\r\nswitch (ip_proto) {\r\ncase IPPROTO_GRE: {\r\nstruct gre_hdr {\r\n__be16 flags;\r\n__be16 proto;\r\n} *hdr, _hdr;\r\nhdr = skb_header_pointer(skb, nhoff, sizeof(_hdr), &_hdr);\r\nif (!hdr)\r\nreturn false;\r\nif (!(hdr->flags & (GRE_VERSION|GRE_ROUTING))) {\r\nproto = hdr->proto;\r\nnhoff += 4;\r\nif (hdr->flags & GRE_CSUM)\r\nnhoff += 4;\r\nif (hdr->flags & GRE_KEY)\r\nnhoff += 4;\r\nif (hdr->flags & GRE_SEQ)\r\nnhoff += 4;\r\ngoto again;\r\n}\r\nbreak;\r\n}\r\ncase IPPROTO_IPIP:\r\ngoto again;\r\ndefault:\r\nbreak;\r\n}\r\nflow->ip_proto = ip_proto;\r\npoff = proto_ports_offset(ip_proto);\r\nif (poff >= 0) {\r\n__be32 *ports, _ports;\r\nnhoff += poff;\r\nports = skb_header_pointer(skb, nhoff, sizeof(_ports), &_ports);\r\nif (ports)\r\nflow->ports = *ports;\r\n}\r\nreturn true;\r\n}
