static inline struct cfpkt_priv_data *cfpkt_priv(struct cfpkt *pkt)\r\n{\r\nreturn (struct cfpkt_priv_data *) pkt->skb.cb;\r\n}\r\nstatic inline bool is_erronous(struct cfpkt *pkt)\r\n{\r\nreturn cfpkt_priv(pkt)->erronous;\r\n}\r\nstatic inline struct sk_buff *pkt_to_skb(struct cfpkt *pkt)\r\n{\r\nreturn &pkt->skb;\r\n}\r\nstatic inline struct cfpkt *skb_to_pkt(struct sk_buff *skb)\r\n{\r\nreturn (struct cfpkt *) skb;\r\n}\r\nstruct cfpkt *cfpkt_fromnative(enum caif_direction dir, void *nativepkt)\r\n{\r\nstruct cfpkt *pkt = skb_to_pkt(nativepkt);\r\ncfpkt_priv(pkt)->erronous = false;\r\nreturn pkt;\r\n}\r\nvoid *cfpkt_tonative(struct cfpkt *pkt)\r\n{\r\nreturn (void *) pkt;\r\n}\r\nstatic struct cfpkt *cfpkt_create_pfx(u16 len, u16 pfx)\r\n{\r\nstruct sk_buff *skb;\r\nif (likely(in_interrupt()))\r\nskb = alloc_skb(len + pfx, GFP_ATOMIC);\r\nelse\r\nskb = alloc_skb(len + pfx, GFP_KERNEL);\r\nif (unlikely(skb == NULL))\r\nreturn NULL;\r\nskb_reserve(skb, pfx);\r\nreturn skb_to_pkt(skb);\r\n}\r\ninline struct cfpkt *cfpkt_create(u16 len)\r\n{\r\nreturn cfpkt_create_pfx(len + PKT_POSTFIX, PKT_PREFIX);\r\n}\r\nvoid cfpkt_destroy(struct cfpkt *pkt)\r\n{\r\nstruct sk_buff *skb = pkt_to_skb(pkt);\r\nkfree_skb(skb);\r\n}\r\ninline bool cfpkt_more(struct cfpkt *pkt)\r\n{\r\nstruct sk_buff *skb = pkt_to_skb(pkt);\r\nreturn skb->len > 0;\r\n}\r\nint cfpkt_peek_head(struct cfpkt *pkt, void *data, u16 len)\r\n{\r\nstruct sk_buff *skb = pkt_to_skb(pkt);\r\nif (skb_headlen(skb) >= len) {\r\nmemcpy(data, skb->data, len);\r\nreturn 0;\r\n}\r\nreturn !cfpkt_extr_head(pkt, data, len) &&\r\n!cfpkt_add_head(pkt, data, len);\r\n}\r\nint cfpkt_extr_head(struct cfpkt *pkt, void *data, u16 len)\r\n{\r\nstruct sk_buff *skb = pkt_to_skb(pkt);\r\nu8 *from;\r\nif (unlikely(is_erronous(pkt)))\r\nreturn -EPROTO;\r\nif (unlikely(len > skb->len)) {\r\nPKT_ERROR(pkt, "read beyond end of packet\n");\r\nreturn -EPROTO;\r\n}\r\nif (unlikely(len > skb_headlen(skb))) {\r\nif (unlikely(skb_linearize(skb) != 0)) {\r\nPKT_ERROR(pkt, "linearize failed\n");\r\nreturn -EPROTO;\r\n}\r\n}\r\nfrom = skb_pull(skb, len);\r\nfrom -= len;\r\nif (data)\r\nmemcpy(data, from, len);\r\nreturn 0;\r\n}\r\nint cfpkt_extr_trail(struct cfpkt *pkt, void *dta, u16 len)\r\n{\r\nstruct sk_buff *skb = pkt_to_skb(pkt);\r\nu8 *data = dta;\r\nu8 *from;\r\nif (unlikely(is_erronous(pkt)))\r\nreturn -EPROTO;\r\nif (unlikely(skb_linearize(skb) != 0)) {\r\nPKT_ERROR(pkt, "linearize failed\n");\r\nreturn -EPROTO;\r\n}\r\nif (unlikely(skb->data + len > skb_tail_pointer(skb))) {\r\nPKT_ERROR(pkt, "read beyond end of packet\n");\r\nreturn -EPROTO;\r\n}\r\nfrom = skb_tail_pointer(skb) - len;\r\nskb_trim(skb, skb->len - len);\r\nmemcpy(data, from, len);\r\nreturn 0;\r\n}\r\nint cfpkt_pad_trail(struct cfpkt *pkt, u16 len)\r\n{\r\nreturn cfpkt_add_body(pkt, NULL, len);\r\n}\r\nint cfpkt_add_body(struct cfpkt *pkt, const void *data, u16 len)\r\n{\r\nstruct sk_buff *skb = pkt_to_skb(pkt);\r\nstruct sk_buff *lastskb;\r\nu8 *to;\r\nu16 addlen = 0;\r\nif (unlikely(is_erronous(pkt)))\r\nreturn -EPROTO;\r\nlastskb = skb;\r\nif (unlikely(skb_tailroom(skb) < len)) {\r\nif (likely(len < PKT_LEN_WHEN_EXTENDING))\r\naddlen = PKT_LEN_WHEN_EXTENDING;\r\nelse\r\naddlen = len;\r\n}\r\nif (unlikely((addlen > 0) || skb_cloned(skb) || skb_shared(skb))) {\r\nif (unlikely(skb_cow_data(skb, addlen, &lastskb) < 0)) {\r\nPKT_ERROR(pkt, "cow failed\n");\r\nreturn -EPROTO;\r\n}\r\nif (lastskb != skb) {\r\npr_warn("Packet is non-linear\n");\r\nskb->len += len;\r\nskb->data_len += len;\r\n}\r\n}\r\nto = skb_put(lastskb, len);\r\nif (likely(data))\r\nmemcpy(to, data, len);\r\nreturn 0;\r\n}\r\ninline int cfpkt_addbdy(struct cfpkt *pkt, u8 data)\r\n{\r\nreturn cfpkt_add_body(pkt, &data, 1);\r\n}\r\nint cfpkt_add_head(struct cfpkt *pkt, const void *data2, u16 len)\r\n{\r\nstruct sk_buff *skb = pkt_to_skb(pkt);\r\nstruct sk_buff *lastskb;\r\nu8 *to;\r\nconst u8 *data = data2;\r\nint ret;\r\nif (unlikely(is_erronous(pkt)))\r\nreturn -EPROTO;\r\nif (unlikely(skb_headroom(skb) < len)) {\r\nPKT_ERROR(pkt, "no headroom\n");\r\nreturn -EPROTO;\r\n}\r\nret = skb_cow_data(skb, 0, &lastskb);\r\nif (unlikely(ret < 0)) {\r\nPKT_ERROR(pkt, "cow failed\n");\r\nreturn ret;\r\n}\r\nto = skb_push(skb, len);\r\nmemcpy(to, data, len);\r\nreturn 0;\r\n}\r\ninline int cfpkt_add_trail(struct cfpkt *pkt, const void *data, u16 len)\r\n{\r\nreturn cfpkt_add_body(pkt, data, len);\r\n}\r\ninline u16 cfpkt_getlen(struct cfpkt *pkt)\r\n{\r\nstruct sk_buff *skb = pkt_to_skb(pkt);\r\nreturn skb->len;\r\n}\r\ninline u16 cfpkt_iterate(struct cfpkt *pkt,\r\nu16 (*iter_func)(u16, void *, u16),\r\nu16 data)\r\n{\r\nif (unlikely(is_erronous(pkt)))\r\nreturn -EPROTO;\r\nif (unlikely(skb_linearize(&pkt->skb) != 0)) {\r\nPKT_ERROR(pkt, "linearize failed\n");\r\nreturn -EPROTO;\r\n}\r\nreturn iter_func(data, pkt->skb.data, cfpkt_getlen(pkt));\r\n}\r\nint cfpkt_setlen(struct cfpkt *pkt, u16 len)\r\n{\r\nstruct sk_buff *skb = pkt_to_skb(pkt);\r\nif (unlikely(is_erronous(pkt)))\r\nreturn -EPROTO;\r\nif (likely(len <= skb->len)) {\r\nif (unlikely(skb->data_len))\r\n___pskb_trim(skb, len);\r\nelse\r\nskb_trim(skb, len);\r\nreturn cfpkt_getlen(pkt);\r\n}\r\nif (unlikely(!cfpkt_pad_trail(pkt, len - skb->len)))\r\nPKT_ERROR(pkt, "skb_pad_trail failed\n");\r\nreturn cfpkt_getlen(pkt);\r\n}\r\nstruct cfpkt *cfpkt_append(struct cfpkt *dstpkt,\r\nstruct cfpkt *addpkt,\r\nu16 expectlen)\r\n{\r\nstruct sk_buff *dst = pkt_to_skb(dstpkt);\r\nstruct sk_buff *add = pkt_to_skb(addpkt);\r\nu16 addlen = skb_headlen(add);\r\nu16 neededtailspace;\r\nstruct sk_buff *tmp;\r\nu16 dstlen;\r\nu16 createlen;\r\nif (unlikely(is_erronous(dstpkt) || is_erronous(addpkt))) {\r\nreturn dstpkt;\r\n}\r\nif (expectlen > addlen)\r\nneededtailspace = expectlen;\r\nelse\r\nneededtailspace = addlen;\r\nif (dst->tail + neededtailspace > dst->end) {\r\nstruct cfpkt *tmppkt;\r\ndstlen = skb_headlen(dst);\r\ncreatelen = dstlen + neededtailspace;\r\ntmppkt = cfpkt_create(createlen + PKT_PREFIX + PKT_POSTFIX);\r\nif (tmppkt == NULL)\r\nreturn NULL;\r\ntmp = pkt_to_skb(tmppkt);\r\nskb_set_tail_pointer(tmp, dstlen);\r\ntmp->len = dstlen;\r\nmemcpy(tmp->data, dst->data, dstlen);\r\ncfpkt_destroy(dstpkt);\r\ndst = tmp;\r\n}\r\nmemcpy(skb_tail_pointer(dst), add->data, skb_headlen(add));\r\ncfpkt_destroy(addpkt);\r\ndst->tail += addlen;\r\ndst->len += addlen;\r\nreturn skb_to_pkt(dst);\r\n}\r\nstruct cfpkt *cfpkt_split(struct cfpkt *pkt, u16 pos)\r\n{\r\nstruct sk_buff *skb2;\r\nstruct sk_buff *skb = pkt_to_skb(pkt);\r\nstruct cfpkt *tmppkt;\r\nu8 *split = skb->data + pos;\r\nu16 len2nd = skb_tail_pointer(skb) - split;\r\nif (unlikely(is_erronous(pkt)))\r\nreturn NULL;\r\nif (skb->data + pos > skb_tail_pointer(skb)) {\r\nPKT_ERROR(pkt, "trying to split beyond end of packet\n");\r\nreturn NULL;\r\n}\r\ntmppkt = cfpkt_create_pfx(len2nd + PKT_PREFIX + PKT_POSTFIX,\r\nPKT_PREFIX);\r\nif (tmppkt == NULL)\r\nreturn NULL;\r\nskb2 = pkt_to_skb(tmppkt);\r\nif (skb2 == NULL)\r\nreturn NULL;\r\nskb_set_tail_pointer(skb, pos);\r\nskb->len = pos;\r\nmemcpy(skb2->data, split, len2nd);\r\nskb2->tail += len2nd;\r\nskb2->len += len2nd;\r\nreturn skb_to_pkt(skb2);\r\n}\r\nbool cfpkt_erroneous(struct cfpkt *pkt)\r\n{\r\nreturn cfpkt_priv(pkt)->erronous;\r\n}\r\nstruct caif_payload_info *cfpkt_info(struct cfpkt *pkt)\r\n{\r\nreturn (struct caif_payload_info *)&pkt_to_skb(pkt)->cb;\r\n}
