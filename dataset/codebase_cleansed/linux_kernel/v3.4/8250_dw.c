static void dw8250_serial_out(struct uart_port *p, int offset, int value)\r\n{\r\nstruct dw8250_data *d = p->private_data;\r\nif (offset == UART_LCR)\r\nd->last_lcr = value;\r\noffset <<= p->regshift;\r\nwriteb(value, p->membase + offset);\r\n}\r\nstatic unsigned int dw8250_serial_in(struct uart_port *p, int offset)\r\n{\r\noffset <<= p->regshift;\r\nreturn readb(p->membase + offset);\r\n}\r\nstatic void dw8250_serial_out32(struct uart_port *p, int offset, int value)\r\n{\r\nstruct dw8250_data *d = p->private_data;\r\nif (offset == UART_LCR)\r\nd->last_lcr = value;\r\noffset <<= p->regshift;\r\nwritel(value, p->membase + offset);\r\n}\r\nstatic unsigned int dw8250_serial_in32(struct uart_port *p, int offset)\r\n{\r\noffset <<= p->regshift;\r\nreturn readl(p->membase + offset);\r\n}\r\nstatic int dw8250_handle_irq(struct uart_port *p)\r\n{\r\nstruct dw8250_data *d = p->private_data;\r\nunsigned int iir = p->serial_in(p, UART_IIR);\r\nif (serial8250_handle_irq(p, iir)) {\r\nreturn 1;\r\n} else if ((iir & UART_IIR_BUSY) == UART_IIR_BUSY) {\r\n(void)p->serial_in(p, UART_USR);\r\np->serial_out(p, d->last_lcr, UART_LCR);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit dw8250_probe(struct platform_device *pdev)\r\n{\r\nstruct uart_port port = {};\r\nstruct resource *regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nstruct resource *irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nstruct device_node *np = pdev->dev.of_node;\r\nu32 val;\r\nstruct dw8250_data *data;\r\nif (!regs || !irq) {\r\ndev_err(&pdev->dev, "no registers/irq defined\n");\r\nreturn -EINVAL;\r\n}\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nport.private_data = data;\r\nspin_lock_init(&port.lock);\r\nport.mapbase = regs->start;\r\nport.irq = irq->start;\r\nport.handle_irq = dw8250_handle_irq;\r\nport.type = PORT_8250;\r\nport.flags = UPF_SHARE_IRQ | UPF_BOOT_AUTOCONF | UPF_IOREMAP |\r\nUPF_FIXED_PORT | UPF_FIXED_TYPE;\r\nport.dev = &pdev->dev;\r\nport.iotype = UPIO_MEM;\r\nport.serial_in = dw8250_serial_in;\r\nport.serial_out = dw8250_serial_out;\r\nif (!of_property_read_u32(np, "reg-io-width", &val)) {\r\nswitch (val) {\r\ncase 1:\r\nbreak;\r\ncase 4:\r\nport.iotype = UPIO_MEM32;\r\nport.serial_in = dw8250_serial_in32;\r\nport.serial_out = dw8250_serial_out32;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "unsupported reg-io-width (%u)\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!of_property_read_u32(np, "reg-shift", &val))\r\nport.regshift = val;\r\nif (of_property_read_u32(np, "clock-frequency", &val)) {\r\ndev_err(&pdev->dev, "no clock-frequency property set\n");\r\nreturn -EINVAL;\r\n}\r\nport.uartclk = val;\r\ndata->line = serial8250_register_port(&port);\r\nif (data->line < 0)\r\nreturn data->line;\r\nplatform_set_drvdata(pdev, data);\r\nreturn 0;\r\n}\r\nstatic int __devexit dw8250_remove(struct platform_device *pdev)\r\n{\r\nstruct dw8250_data *data = platform_get_drvdata(pdev);\r\nserial8250_unregister_port(data->line);\r\nreturn 0;\r\n}
