static void stmmac_ethtool_getdrvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nif (priv->plat->has_gmac)\r\nstrlcpy(info->driver, GMAC_ETHTOOL_NAME, sizeof(info->driver));\r\nelse\r\nstrlcpy(info->driver, MAC100_ETHTOOL_NAME,\r\nsizeof(info->driver));\r\nstrcpy(info->version, DRV_MODULE_VERSION);\r\ninfo->fw_version[0] = '\0';\r\n}\r\nstatic int stmmac_ethtool_getsettings(struct net_device *dev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nstruct phy_device *phy = priv->phydev;\r\nint rc;\r\nif (phy == NULL) {\r\npr_err("%s: %s: PHY is not registered\n",\r\n__func__, dev->name);\r\nreturn -ENODEV;\r\n}\r\nif (!netif_running(dev)) {\r\npr_err("%s: interface is disabled: we cannot track "\r\n"link speed / duplex setting\n", dev->name);\r\nreturn -EBUSY;\r\n}\r\ncmd->transceiver = XCVR_INTERNAL;\r\nspin_lock_irq(&priv->lock);\r\nrc = phy_ethtool_gset(phy, cmd);\r\nspin_unlock_irq(&priv->lock);\r\nreturn rc;\r\n}\r\nstatic int stmmac_ethtool_setsettings(struct net_device *dev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nstruct phy_device *phy = priv->phydev;\r\nint rc;\r\nspin_lock(&priv->lock);\r\nrc = phy_ethtool_sset(phy, cmd);\r\nspin_unlock(&priv->lock);\r\nreturn rc;\r\n}\r\nstatic u32 stmmac_ethtool_getmsglevel(struct net_device *dev)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nreturn priv->msg_enable;\r\n}\r\nstatic void stmmac_ethtool_setmsglevel(struct net_device *dev, u32 level)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\npriv->msg_enable = level;\r\n}\r\nstatic int stmmac_check_if_running(struct net_device *dev)\r\n{\r\nif (!netif_running(dev))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int stmmac_ethtool_get_regs_len(struct net_device *dev)\r\n{\r\nreturn REG_SPACE_SIZE;\r\n}\r\nstatic void stmmac_ethtool_gregs(struct net_device *dev,\r\nstruct ethtool_regs *regs, void *space)\r\n{\r\nint i;\r\nu32 *reg_space = (u32 *) space;\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nmemset(reg_space, 0x0, REG_SPACE_SIZE);\r\nif (!priv->plat->has_gmac) {\r\nfor (i = 0; i < 12; i++)\r\nreg_space[i] = readl(priv->ioaddr + (i * 4));\r\nfor (i = 0; i < 9; i++)\r\nreg_space[i + 12] =\r\nreadl(priv->ioaddr + (DMA_BUS_MODE + (i * 4)));\r\nreg_space[22] = readl(priv->ioaddr + DMA_CUR_TX_BUF_ADDR);\r\nreg_space[23] = readl(priv->ioaddr + DMA_CUR_RX_BUF_ADDR);\r\n} else {\r\nfor (i = 0; i < 55; i++)\r\nreg_space[i] = readl(priv->ioaddr + (i * 4));\r\nfor (i = 0; i < 22; i++)\r\nreg_space[i + 55] =\r\nreadl(priv->ioaddr + (DMA_BUS_MODE + (i * 4)));\r\n}\r\n}\r\nstatic void\r\nstmmac_get_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(netdev);\r\nspin_lock(&priv->lock);\r\npause->rx_pause = 0;\r\npause->tx_pause = 0;\r\npause->autoneg = priv->phydev->autoneg;\r\nif (priv->flow_ctrl & FLOW_RX)\r\npause->rx_pause = 1;\r\nif (priv->flow_ctrl & FLOW_TX)\r\npause->tx_pause = 1;\r\nspin_unlock(&priv->lock);\r\n}\r\nstatic int\r\nstmmac_set_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(netdev);\r\nstruct phy_device *phy = priv->phydev;\r\nint new_pause = FLOW_OFF;\r\nint ret = 0;\r\nspin_lock(&priv->lock);\r\nif (pause->rx_pause)\r\nnew_pause |= FLOW_RX;\r\nif (pause->tx_pause)\r\nnew_pause |= FLOW_TX;\r\npriv->flow_ctrl = new_pause;\r\nphy->autoneg = pause->autoneg;\r\nif (phy->autoneg) {\r\nif (netif_running(netdev))\r\nret = phy_start_aneg(phy);\r\n} else\r\npriv->hw->mac->flow_ctrl(priv->ioaddr, phy->duplex,\r\npriv->flow_ctrl, priv->pause);\r\nspin_unlock(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic void stmmac_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *dummy, u64 *data)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nint i, j = 0;\r\nif (!priv->plat->has_gmac)\r\npriv->hw->dma->dma_diagnostic_fr(&dev->stats,\r\n(void *) &priv->xstats,\r\npriv->ioaddr);\r\nelse {\r\nif (priv->dma_cap.rmon) {\r\ndwmac_mmc_read(priv->ioaddr, &priv->mmc);\r\nfor (i = 0; i < STMMAC_MMC_STATS_LEN; i++) {\r\nchar *p;\r\np = (char *)priv + stmmac_mmc[i].stat_offset;\r\ndata[j++] = (stmmac_mmc[i].sizeof_stat ==\r\nsizeof(u64)) ? (*(u64 *)p) :\r\n(*(u32 *)p);\r\n}\r\n}\r\n}\r\nfor (i = 0; i < STMMAC_STATS_LEN; i++) {\r\nchar *p = (char *)priv + stmmac_gstrings_stats[i].stat_offset;\r\ndata[j++] = (stmmac_gstrings_stats[i].sizeof_stat ==\r\nsizeof(u64)) ? (*(u64 *)p) : (*(u32 *)p);\r\n}\r\n}\r\nstatic int stmmac_get_sset_count(struct net_device *netdev, int sset)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(netdev);\r\nint len;\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nlen = STMMAC_STATS_LEN;\r\nif (priv->dma_cap.rmon)\r\nlen += STMMAC_MMC_STATS_LEN;\r\nreturn len;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void stmmac_get_strings(struct net_device *dev, u32 stringset, u8 *data)\r\n{\r\nint i;\r\nu8 *p = data;\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nif (priv->dma_cap.rmon)\r\nfor (i = 0; i < STMMAC_MMC_STATS_LEN; i++) {\r\nmemcpy(p, stmmac_mmc[i].stat_string,\r\nETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\n}\r\nfor (i = 0; i < STMMAC_STATS_LEN; i++) {\r\nmemcpy(p, stmmac_gstrings_stats[i].stat_string,\r\nETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\n}\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\n}\r\nstatic void stmmac_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nspin_lock_irq(&priv->lock);\r\nif (device_can_wakeup(priv->device)) {\r\nwol->supported = WAKE_MAGIC | WAKE_UCAST;\r\nwol->wolopts = priv->wolopts;\r\n}\r\nspin_unlock_irq(&priv->lock);\r\n}\r\nstatic int stmmac_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nu32 support = WAKE_MAGIC | WAKE_UCAST;\r\nif ((priv->hw_cap_support) && (!priv->dma_cap.pmt_magic_frame))\r\nwol->wolopts &= ~WAKE_MAGIC;\r\nif (!device_can_wakeup(priv->device))\r\nreturn -EINVAL;\r\nif (wol->wolopts & ~support)\r\nreturn -EINVAL;\r\nif (wol->wolopts) {\r\npr_info("stmmac: wakeup enable\n");\r\ndevice_set_wakeup_enable(priv->device, 1);\r\nenable_irq_wake(priv->wol_irq);\r\n} else {\r\ndevice_set_wakeup_enable(priv->device, 0);\r\ndisable_irq_wake(priv->wol_irq);\r\n}\r\nspin_lock_irq(&priv->lock);\r\npriv->wolopts = wol->wolopts;\r\nspin_unlock_irq(&priv->lock);\r\nreturn 0;\r\n}\r\nvoid stmmac_set_ethtool_ops(struct net_device *netdev)\r\n{\r\nSET_ETHTOOL_OPS(netdev, &stmmac_ethtool_ops);\r\n}
