static void dump_cifs_file_struct(struct file *file, char *label)\r\n{\r\nstruct cifsFileInfo *cf;\r\nif (file) {\r\ncf = file->private_data;\r\nif (cf == NULL) {\r\ncFYI(1, "empty cifs private file data");\r\nreturn;\r\n}\r\nif (cf->invalidHandle)\r\ncFYI(1, "invalid handle");\r\nif (cf->srch_inf.endOfSearch)\r\ncFYI(1, "end of search");\r\nif (cf->srch_inf.emptyDir)\r\ncFYI(1, "empty dir");\r\n}\r\n}\r\nstatic inline void dump_cifs_file_struct(struct file *file, char *label)\r\n{\r\n}\r\nstatic struct dentry *\r\ncifs_readdir_lookup(struct dentry *parent, struct qstr *name,\r\nstruct cifs_fattr *fattr)\r\n{\r\nstruct dentry *dentry, *alias;\r\nstruct inode *inode;\r\nstruct super_block *sb = parent->d_inode->i_sb;\r\ncFYI(1, "For %s", name->name);\r\nif (parent->d_op && parent->d_op->d_hash)\r\nparent->d_op->d_hash(parent, parent->d_inode, name);\r\nelse\r\nname->hash = full_name_hash(name->name, name->len);\r\ndentry = d_lookup(parent, name);\r\nif (dentry) {\r\nif (dentry->d_inode != NULL)\r\nreturn dentry;\r\nd_drop(dentry);\r\ndput(dentry);\r\n}\r\ndentry = d_alloc(parent, name);\r\nif (dentry == NULL)\r\nreturn NULL;\r\ninode = cifs_iget(sb, fattr);\r\nif (!inode) {\r\ndput(dentry);\r\nreturn NULL;\r\n}\r\nalias = d_materialise_unique(dentry, inode);\r\nif (alias != NULL) {\r\ndput(dentry);\r\nif (IS_ERR(alias))\r\nreturn NULL;\r\ndentry = alias;\r\n}\r\nreturn dentry;\r\n}\r\nstatic void\r\ncifs_fill_common_info(struct cifs_fattr *fattr, struct cifs_sb_info *cifs_sb)\r\n{\r\nfattr->cf_uid = cifs_sb->mnt_uid;\r\nfattr->cf_gid = cifs_sb->mnt_gid;\r\nif (fattr->cf_cifsattrs & ATTR_DIRECTORY) {\r\nfattr->cf_mode = S_IFDIR | cifs_sb->mnt_dir_mode;\r\nfattr->cf_dtype = DT_DIR;\r\n} else {\r\nfattr->cf_mode = S_IFREG | cifs_sb->mnt_file_mode;\r\nfattr->cf_dtype = DT_REG;\r\n}\r\nif (fattr->cf_cifsattrs & ATTR_READONLY)\r\nfattr->cf_mode &= ~S_IWUGO;\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL &&\r\nfattr->cf_cifsattrs & ATTR_SYSTEM) {\r\nif (fattr->cf_eof == 0) {\r\nfattr->cf_mode &= ~S_IFMT;\r\nfattr->cf_mode |= S_IFIFO;\r\nfattr->cf_dtype = DT_FIFO;\r\n} else {\r\nfattr->cf_flags |= CIFS_FATTR_NEED_REVAL;\r\n}\r\n}\r\n}\r\nstatic void\r\ncifs_dir_info_to_fattr(struct cifs_fattr *fattr, FILE_DIRECTORY_INFO *info,\r\nstruct cifs_sb_info *cifs_sb)\r\n{\r\nmemset(fattr, 0, sizeof(*fattr));\r\nfattr->cf_cifsattrs = le32_to_cpu(info->ExtFileAttributes);\r\nfattr->cf_eof = le64_to_cpu(info->EndOfFile);\r\nfattr->cf_bytes = le64_to_cpu(info->AllocationSize);\r\nfattr->cf_createtime = le64_to_cpu(info->CreationTime);\r\nfattr->cf_atime = cifs_NTtimeToUnix(info->LastAccessTime);\r\nfattr->cf_ctime = cifs_NTtimeToUnix(info->ChangeTime);\r\nfattr->cf_mtime = cifs_NTtimeToUnix(info->LastWriteTime);\r\ncifs_fill_common_info(fattr, cifs_sb);\r\n}\r\nstatic void\r\ncifs_std_info_to_fattr(struct cifs_fattr *fattr, FIND_FILE_STANDARD_INFO *info,\r\nstruct cifs_sb_info *cifs_sb)\r\n{\r\nint offset = cifs_sb_master_tcon(cifs_sb)->ses->server->timeAdj;\r\nmemset(fattr, 0, sizeof(*fattr));\r\nfattr->cf_atime = cnvrtDosUnixTm(info->LastAccessDate,\r\ninfo->LastAccessTime, offset);\r\nfattr->cf_ctime = cnvrtDosUnixTm(info->LastWriteDate,\r\ninfo->LastWriteTime, offset);\r\nfattr->cf_mtime = cnvrtDosUnixTm(info->LastWriteDate,\r\ninfo->LastWriteTime, offset);\r\nfattr->cf_cifsattrs = le16_to_cpu(info->Attributes);\r\nfattr->cf_bytes = le32_to_cpu(info->AllocationSize);\r\nfattr->cf_eof = le32_to_cpu(info->DataSize);\r\ncifs_fill_common_info(fattr, cifs_sb);\r\n}\r\nstatic int initiate_cifs_search(const int xid, struct file *file)\r\n{\r\nint rc = 0;\r\nchar *full_path = NULL;\r\nstruct cifsFileInfo *cifsFile;\r\nstruct cifs_sb_info *cifs_sb = CIFS_SB(file->f_path.dentry->d_sb);\r\nstruct tcon_link *tlink = NULL;\r\nstruct cifs_tcon *pTcon;\r\nif (file->private_data == NULL) {\r\ntlink = cifs_sb_tlink(cifs_sb);\r\nif (IS_ERR(tlink))\r\nreturn PTR_ERR(tlink);\r\ncifsFile = kzalloc(sizeof(struct cifsFileInfo), GFP_KERNEL);\r\nif (cifsFile == NULL) {\r\nrc = -ENOMEM;\r\ngoto error_exit;\r\n}\r\nfile->private_data = cifsFile;\r\ncifsFile->tlink = cifs_get_tlink(tlink);\r\npTcon = tlink_tcon(tlink);\r\n} else {\r\ncifsFile = file->private_data;\r\npTcon = tlink_tcon(cifsFile->tlink);\r\n}\r\ncifsFile->invalidHandle = true;\r\ncifsFile->srch_inf.endOfSearch = false;\r\nfull_path = build_path_from_dentry(file->f_path.dentry);\r\nif (full_path == NULL) {\r\nrc = -ENOMEM;\r\ngoto error_exit;\r\n}\r\ncFYI(1, "Full path: %s start at: %lld", full_path, file->f_pos);\r\nffirst_retry:\r\nif (pTcon->unix_ext)\r\ncifsFile->srch_inf.info_level = SMB_FIND_FILE_UNIX;\r\nelse if ((pTcon->ses->capabilities &\r\n(CAP_NT_SMBS | CAP_NT_FIND)) == 0) {\r\ncifsFile->srch_inf.info_level = SMB_FIND_FILE_INFO_STANDARD;\r\n} else if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\r\ncifsFile->srch_inf.info_level = SMB_FIND_FILE_ID_FULL_DIR_INFO;\r\n} else {\r\ncifsFile->srch_inf.info_level = SMB_FIND_FILE_DIRECTORY_INFO;\r\n}\r\nrc = CIFSFindFirst(xid, pTcon, full_path, cifs_sb->local_nls,\r\n&cifsFile->netfid, &cifsFile->srch_inf,\r\ncifs_sb->mnt_cifs_flags &\r\nCIFS_MOUNT_MAP_SPECIAL_CHR, CIFS_DIR_SEP(cifs_sb));\r\nif (rc == 0)\r\ncifsFile->invalidHandle = false;\r\nelse if ((rc == -EOPNOTSUPP) &&\r\n(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)) {\r\ncifs_sb->mnt_cifs_flags &= ~CIFS_MOUNT_SERVER_INUM;\r\ngoto ffirst_retry;\r\n}\r\nerror_exit:\r\nkfree(full_path);\r\ncifs_put_tlink(tlink);\r\nreturn rc;\r\n}\r\nstatic int cifs_unicode_bytelen(const char *str)\r\n{\r\nint len;\r\nconst __le16 *ustr = (const __le16 *)str;\r\nfor (len = 0; len <= PATH_MAX; len++) {\r\nif (ustr[len] == 0)\r\nreturn len << 1;\r\n}\r\ncFYI(1, "Unicode string longer than PATH_MAX found");\r\nreturn len << 1;\r\n}\r\nstatic char *nxt_dir_entry(char *old_entry, char *end_of_smb, int level)\r\n{\r\nchar *new_entry;\r\nFILE_DIRECTORY_INFO *pDirInfo = (FILE_DIRECTORY_INFO *)old_entry;\r\nif (level == SMB_FIND_FILE_INFO_STANDARD) {\r\nFIND_FILE_STANDARD_INFO *pfData;\r\npfData = (FIND_FILE_STANDARD_INFO *)pDirInfo;\r\nnew_entry = old_entry + sizeof(FIND_FILE_STANDARD_INFO) +\r\npfData->FileNameLength;\r\n} else\r\nnew_entry = old_entry + le32_to_cpu(pDirInfo->NextEntryOffset);\r\ncFYI(1, "new entry %p old entry %p", new_entry, old_entry);\r\nif (new_entry >= end_of_smb) {\r\ncERROR(1, "search entry %p began after end of SMB %p old entry %p",\r\nnew_entry, end_of_smb, old_entry);\r\nreturn NULL;\r\n} else if (((level == SMB_FIND_FILE_INFO_STANDARD) &&\r\n(new_entry + sizeof(FIND_FILE_STANDARD_INFO) > end_of_smb))\r\n|| ((level != SMB_FIND_FILE_INFO_STANDARD) &&\r\n(new_entry + sizeof(FILE_DIRECTORY_INFO) > end_of_smb))) {\r\ncERROR(1, "search entry %p extends after end of SMB %p",\r\nnew_entry, end_of_smb);\r\nreturn NULL;\r\n} else\r\nreturn new_entry;\r\n}\r\nstatic void cifs_fill_dirent_unix(struct cifs_dirent *de,\r\nconst FILE_UNIX_INFO *info, bool is_unicode)\r\n{\r\nde->name = &info->FileName[0];\r\nif (is_unicode)\r\nde->namelen = cifs_unicode_bytelen(de->name);\r\nelse\r\nde->namelen = strnlen(de->name, PATH_MAX);\r\nde->resume_key = info->ResumeKey;\r\nde->ino = le64_to_cpu(info->basic.UniqueId);\r\n}\r\nstatic void cifs_fill_dirent_dir(struct cifs_dirent *de,\r\nconst FILE_DIRECTORY_INFO *info)\r\n{\r\nde->name = &info->FileName[0];\r\nde->namelen = le32_to_cpu(info->FileNameLength);\r\nde->resume_key = info->FileIndex;\r\n}\r\nstatic void cifs_fill_dirent_full(struct cifs_dirent *de,\r\nconst FILE_FULL_DIRECTORY_INFO *info)\r\n{\r\nde->name = &info->FileName[0];\r\nde->namelen = le32_to_cpu(info->FileNameLength);\r\nde->resume_key = info->FileIndex;\r\n}\r\nstatic void cifs_fill_dirent_search(struct cifs_dirent *de,\r\nconst SEARCH_ID_FULL_DIR_INFO *info)\r\n{\r\nde->name = &info->FileName[0];\r\nde->namelen = le32_to_cpu(info->FileNameLength);\r\nde->resume_key = info->FileIndex;\r\nde->ino = le64_to_cpu(info->UniqueId);\r\n}\r\nstatic void cifs_fill_dirent_both(struct cifs_dirent *de,\r\nconst FILE_BOTH_DIRECTORY_INFO *info)\r\n{\r\nde->name = &info->FileName[0];\r\nde->namelen = le32_to_cpu(info->FileNameLength);\r\nde->resume_key = info->FileIndex;\r\n}\r\nstatic void cifs_fill_dirent_std(struct cifs_dirent *de,\r\nconst FIND_FILE_STANDARD_INFO *info)\r\n{\r\nde->name = &info->FileName[0];\r\nde->namelen = info->FileNameLength;\r\nde->resume_key = info->ResumeKey;\r\n}\r\nstatic int cifs_fill_dirent(struct cifs_dirent *de, const void *info,\r\nu16 level, bool is_unicode)\r\n{\r\nmemset(de, 0, sizeof(*de));\r\nswitch (level) {\r\ncase SMB_FIND_FILE_UNIX:\r\ncifs_fill_dirent_unix(de, info, is_unicode);\r\nbreak;\r\ncase SMB_FIND_FILE_DIRECTORY_INFO:\r\ncifs_fill_dirent_dir(de, info);\r\nbreak;\r\ncase SMB_FIND_FILE_FULL_DIRECTORY_INFO:\r\ncifs_fill_dirent_full(de, info);\r\nbreak;\r\ncase SMB_FIND_FILE_ID_FULL_DIR_INFO:\r\ncifs_fill_dirent_search(de, info);\r\nbreak;\r\ncase SMB_FIND_FILE_BOTH_DIRECTORY_INFO:\r\ncifs_fill_dirent_both(de, info);\r\nbreak;\r\ncase SMB_FIND_FILE_INFO_STANDARD:\r\ncifs_fill_dirent_std(de, info);\r\nbreak;\r\ndefault:\r\ncFYI(1, "Unknown findfirst level %d", level);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cifs_entry_is_dot(struct cifs_dirent *de, bool is_unicode)\r\n{\r\nint rc = 0;\r\nif (!de->name)\r\nreturn 0;\r\nif (is_unicode) {\r\n__le16 *ufilename = (__le16 *)de->name;\r\nif (de->namelen == 2) {\r\nif (ufilename[0] == UNICODE_DOT)\r\nrc = 1;\r\n} else if (de->namelen == 4) {\r\nif (ufilename[0] == UNICODE_DOT &&\r\nufilename[1] == UNICODE_DOT)\r\nrc = 2;\r\n}\r\n} else {\r\nif (de->namelen == 1) {\r\nif (de->name[0] == '.')\r\nrc = 1;\r\n} else if (de->namelen == 2) {\r\nif (de->name[0] == '.' && de->name[1] == '.')\r\nrc = 2;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int is_dir_changed(struct file *file)\r\n{\r\nstruct inode *inode = file->f_path.dentry->d_inode;\r\nstruct cifsInodeInfo *cifsInfo = CIFS_I(inode);\r\nif (cifsInfo->time == 0)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int cifs_save_resume_key(const char *current_entry,\r\nstruct cifsFileInfo *file_info)\r\n{\r\nstruct cifs_dirent de;\r\nint rc;\r\nrc = cifs_fill_dirent(&de, current_entry, file_info->srch_inf.info_level,\r\nfile_info->srch_inf.unicode);\r\nif (!rc) {\r\nfile_info->srch_inf.presume_name = de.name;\r\nfile_info->srch_inf.resume_name_len = de.namelen;\r\nfile_info->srch_inf.resume_key = de.resume_key;\r\n}\r\nreturn rc;\r\n}\r\nstatic int find_cifs_entry(const int xid, struct cifs_tcon *pTcon,\r\nstruct file *file, char **ppCurrentEntry, int *num_to_ret)\r\n{\r\nint rc = 0;\r\nint pos_in_buf = 0;\r\nloff_t first_entry_in_buffer;\r\nloff_t index_to_find = file->f_pos;\r\nstruct cifsFileInfo *cifsFile = file->private_data;\r\nif ((cifsFile == NULL) || (ppCurrentEntry == NULL) ||\r\n(num_to_ret == NULL))\r\nreturn -ENOENT;\r\n*ppCurrentEntry = NULL;\r\nfirst_entry_in_buffer =\r\ncifsFile->srch_inf.index_of_last_entry -\r\ncifsFile->srch_inf.entries_in_buffer;\r\ndump_cifs_file_struct(file, "In fce ");\r\nif (((index_to_find < cifsFile->srch_inf.index_of_last_entry) &&\r\nis_dir_changed(file)) ||\r\n(index_to_find < first_entry_in_buffer)) {\r\ncFYI(1, "search backing up - close and restart search");\r\nspin_lock(&cifs_file_list_lock);\r\nif (!cifsFile->srch_inf.endOfSearch &&\r\n!cifsFile->invalidHandle) {\r\ncifsFile->invalidHandle = true;\r\nspin_unlock(&cifs_file_list_lock);\r\nCIFSFindClose(xid, pTcon, cifsFile->netfid);\r\n} else\r\nspin_unlock(&cifs_file_list_lock);\r\nif (cifsFile->srch_inf.ntwrk_buf_start) {\r\ncFYI(1, "freeing SMB ff cache buf on search rewind");\r\nif (cifsFile->srch_inf.smallBuf)\r\ncifs_small_buf_release(cifsFile->srch_inf.\r\nntwrk_buf_start);\r\nelse\r\ncifs_buf_release(cifsFile->srch_inf.\r\nntwrk_buf_start);\r\ncifsFile->srch_inf.ntwrk_buf_start = NULL;\r\n}\r\nrc = initiate_cifs_search(xid, file);\r\nif (rc) {\r\ncFYI(1, "error %d reinitiating a search on rewind",\r\nrc);\r\nreturn rc;\r\n}\r\nif (cifsFile->srch_inf.last_entry)\r\ncifs_save_resume_key(cifsFile->srch_inf.last_entry,\r\ncifsFile);\r\n}\r\nwhile ((index_to_find >= cifsFile->srch_inf.index_of_last_entry) &&\r\n(rc == 0) && !cifsFile->srch_inf.endOfSearch) {\r\ncFYI(1, "calling findnext2");\r\nrc = CIFSFindNext(xid, pTcon, cifsFile->netfid,\r\n&cifsFile->srch_inf);\r\nif (cifsFile->srch_inf.last_entry)\r\ncifs_save_resume_key(cifsFile->srch_inf.last_entry,\r\ncifsFile);\r\nif (rc)\r\nreturn -ENOENT;\r\n}\r\nif (index_to_find < cifsFile->srch_inf.index_of_last_entry) {\r\nint i;\r\nchar *current_entry;\r\nchar *end_of_smb = cifsFile->srch_inf.ntwrk_buf_start +\r\nsmbCalcSize((struct smb_hdr *)\r\ncifsFile->srch_inf.ntwrk_buf_start);\r\ncurrent_entry = cifsFile->srch_inf.srch_entries_start;\r\nfirst_entry_in_buffer = cifsFile->srch_inf.index_of_last_entry\r\n- cifsFile->srch_inf.entries_in_buffer;\r\npos_in_buf = index_to_find - first_entry_in_buffer;\r\ncFYI(1, "found entry - pos_in_buf %d", pos_in_buf);\r\nfor (i = 0; (i < (pos_in_buf)) && (current_entry != NULL); i++) {\r\ncurrent_entry = nxt_dir_entry(current_entry, end_of_smb,\r\ncifsFile->srch_inf.info_level);\r\n}\r\nif ((current_entry == NULL) && (i < pos_in_buf)) {\r\ncERROR(1, "reached end of buf searching for pos in buf"\r\n" %d index to find %lld rc %d",\r\npos_in_buf, index_to_find, rc);\r\n}\r\nrc = 0;\r\n*ppCurrentEntry = current_entry;\r\n} else {\r\ncFYI(1, "index not in buffer - could not findnext into it");\r\nreturn 0;\r\n}\r\nif (pos_in_buf >= cifsFile->srch_inf.entries_in_buffer) {\r\ncFYI(1, "can not return entries pos_in_buf beyond last");\r\n*num_to_ret = 0;\r\n} else\r\n*num_to_ret = cifsFile->srch_inf.entries_in_buffer - pos_in_buf;\r\nreturn rc;\r\n}\r\nstatic int cifs_filldir(char *find_entry, struct file *file, filldir_t filldir,\r\nvoid *dirent, char *scratch_buf, unsigned int max_len)\r\n{\r\nstruct cifsFileInfo *file_info = file->private_data;\r\nstruct super_block *sb = file->f_path.dentry->d_sb;\r\nstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\r\nstruct cifs_dirent de = { NULL, };\r\nstruct cifs_fattr fattr;\r\nstruct dentry *dentry;\r\nstruct qstr name;\r\nint rc = 0;\r\nino_t ino;\r\nrc = cifs_fill_dirent(&de, find_entry, file_info->srch_inf.info_level,\r\nfile_info->srch_inf.unicode);\r\nif (rc)\r\nreturn rc;\r\nif (de.namelen > max_len) {\r\ncERROR(1, "bad search response length %zd past smb end",\r\nde.namelen);\r\nreturn -EINVAL;\r\n}\r\nif (cifs_entry_is_dot(&de, file_info->srch_inf.unicode))\r\nreturn 0;\r\nif (file_info->srch_inf.unicode) {\r\nstruct nls_table *nlt = cifs_sb->local_nls;\r\nname.name = scratch_buf;\r\nname.len =\r\ncifs_from_utf16((char *)name.name, (__le16 *)de.name,\r\nUNICODE_NAME_MAX,\r\nmin_t(size_t, de.namelen,\r\n(size_t)max_len), nlt,\r\ncifs_sb->mnt_cifs_flags &\r\nCIFS_MOUNT_MAP_SPECIAL_CHR);\r\nname.len -= nls_nullsize(nlt);\r\n} else {\r\nname.name = de.name;\r\nname.len = de.namelen;\r\n}\r\nswitch (file_info->srch_inf.info_level) {\r\ncase SMB_FIND_FILE_UNIX:\r\ncifs_unix_basic_to_fattr(&fattr,\r\n&((FILE_UNIX_INFO *)find_entry)->basic,\r\ncifs_sb);\r\nbreak;\r\ncase SMB_FIND_FILE_INFO_STANDARD:\r\ncifs_std_info_to_fattr(&fattr,\r\n(FIND_FILE_STANDARD_INFO *)find_entry,\r\ncifs_sb);\r\nbreak;\r\ndefault:\r\ncifs_dir_info_to_fattr(&fattr,\r\n(FILE_DIRECTORY_INFO *)find_entry,\r\ncifs_sb);\r\nbreak;\r\n}\r\nif (de.ino && (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)) {\r\nfattr.cf_uniqueid = de.ino;\r\n} else {\r\nfattr.cf_uniqueid = iunique(sb, ROOT_I);\r\ncifs_autodisable_serverino(cifs_sb);\r\n}\r\nif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS) &&\r\nCIFSCouldBeMFSymlink(&fattr))\r\nfattr.cf_flags |= CIFS_FATTR_NEED_REVAL;\r\nino = cifs_uniqueid_to_ino_t(fattr.cf_uniqueid);\r\ndentry = cifs_readdir_lookup(file->f_dentry, &name, &fattr);\r\nrc = filldir(dirent, name.name, name.len, file->f_pos, ino,\r\nfattr.cf_dtype);\r\ndput(dentry);\r\nreturn rc;\r\n}\r\nint cifs_readdir(struct file *file, void *direntry, filldir_t filldir)\r\n{\r\nint rc = 0;\r\nint xid, i;\r\nstruct cifs_tcon *pTcon;\r\nstruct cifsFileInfo *cifsFile = NULL;\r\nchar *current_entry;\r\nint num_to_fill = 0;\r\nchar *tmp_buf = NULL;\r\nchar *end_of_smb;\r\nunsigned int max_len;\r\nxid = GetXid();\r\nif (file->private_data == NULL) {\r\nrc = initiate_cifs_search(xid, file);\r\ncFYI(1, "initiate cifs search rc %d", rc);\r\nif (rc)\r\ngoto rddir2_exit;\r\n}\r\nswitch ((int) file->f_pos) {\r\ncase 0:\r\nif (filldir(direntry, ".", 1, file->f_pos,\r\nfile->f_path.dentry->d_inode->i_ino, DT_DIR) < 0) {\r\ncERROR(1, "Filldir for current dir failed");\r\nrc = -ENOMEM;\r\nbreak;\r\n}\r\nfile->f_pos++;\r\ncase 1:\r\nif (filldir(direntry, "..", 2, file->f_pos,\r\nparent_ino(file->f_path.dentry), DT_DIR) < 0) {\r\ncERROR(1, "Filldir for parent dir failed");\r\nrc = -ENOMEM;\r\nbreak;\r\n}\r\nfile->f_pos++;\r\ndefault:\r\nif (file->private_data == NULL) {\r\nrc = -EINVAL;\r\nFreeXid(xid);\r\nreturn rc;\r\n}\r\ncifsFile = file->private_data;\r\nif (cifsFile->srch_inf.endOfSearch) {\r\nif (cifsFile->srch_inf.emptyDir) {\r\ncFYI(1, "End of search, empty dir");\r\nrc = 0;\r\nbreak;\r\n}\r\n}\r\npTcon = tlink_tcon(cifsFile->tlink);\r\nrc = find_cifs_entry(xid, pTcon, file,\r\n&current_entry, &num_to_fill);\r\nif (rc) {\r\ncFYI(1, "fce error %d", rc);\r\ngoto rddir2_exit;\r\n} else if (current_entry != NULL) {\r\ncFYI(1, "entry %lld found", file->f_pos);\r\n} else {\r\ncFYI(1, "could not find entry");\r\ngoto rddir2_exit;\r\n}\r\ncFYI(1, "loop through %d times filling dir for net buf %p",\r\nnum_to_fill, cifsFile->srch_inf.ntwrk_buf_start);\r\nmax_len = smbCalcSize((struct smb_hdr *)\r\ncifsFile->srch_inf.ntwrk_buf_start);\r\nend_of_smb = cifsFile->srch_inf.ntwrk_buf_start + max_len;\r\ntmp_buf = kmalloc(UNICODE_NAME_MAX, GFP_KERNEL);\r\nif (tmp_buf == NULL) {\r\nrc = -ENOMEM;\r\nbreak;\r\n}\r\nfor (i = 0; (i < num_to_fill) && (rc == 0); i++) {\r\nif (current_entry == NULL) {\r\ncERROR(1, "past SMB end, num to fill %d i %d",\r\nnum_to_fill, i);\r\nbreak;\r\n}\r\nrc = cifs_filldir(current_entry, file,\r\nfilldir, direntry, tmp_buf, max_len);\r\nif (rc == -EOVERFLOW) {\r\nrc = 0;\r\nbreak;\r\n}\r\nfile->f_pos++;\r\nif (file->f_pos ==\r\ncifsFile->srch_inf.index_of_last_entry) {\r\ncFYI(1, "last entry in buf at pos %lld %s",\r\nfile->f_pos, tmp_buf);\r\ncifs_save_resume_key(current_entry, cifsFile);\r\nbreak;\r\n} else\r\ncurrent_entry =\r\nnxt_dir_entry(current_entry, end_of_smb,\r\ncifsFile->srch_inf.info_level);\r\n}\r\nkfree(tmp_buf);\r\nbreak;\r\n}\r\nrddir2_exit:\r\nFreeXid(xid);\r\nreturn rc;\r\n}
