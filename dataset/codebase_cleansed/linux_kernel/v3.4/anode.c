secno hpfs_bplus_lookup(struct super_block *s, struct inode *inode,\r\nstruct bplus_header *btree, unsigned sec,\r\nstruct buffer_head *bh)\r\n{\r\nanode_secno a = -1;\r\nstruct anode *anode;\r\nint i;\r\nint c1, c2 = 0;\r\ngo_down:\r\nif (hpfs_sb(s)->sb_chk) if (hpfs_stop_cycles(s, a, &c1, &c2, "hpfs_bplus_lookup")) return -1;\r\nif (btree->internal) {\r\nfor (i = 0; i < btree->n_used_nodes; i++)\r\nif (le32_to_cpu(btree->u.internal[i].file_secno) > sec) {\r\na = le32_to_cpu(btree->u.internal[i].down);\r\nbrelse(bh);\r\nif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\r\nbtree = &anode->btree;\r\ngoto go_down;\r\n}\r\nhpfs_error(s, "sector %08x not found in internal anode %08x", sec, a);\r\nbrelse(bh);\r\nreturn -1;\r\n}\r\nfor (i = 0; i < btree->n_used_nodes; i++)\r\nif (le32_to_cpu(btree->u.external[i].file_secno) <= sec &&\r\nle32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) > sec) {\r\na = le32_to_cpu(btree->u.external[i].disk_secno) + sec - le32_to_cpu(btree->u.external[i].file_secno);\r\nif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, a, 1, "data")) {\r\nbrelse(bh);\r\nreturn -1;\r\n}\r\nif (inode) {\r\nstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\r\nhpfs_inode->i_file_sec = le32_to_cpu(btree->u.external[i].file_secno);\r\nhpfs_inode->i_disk_sec = le32_to_cpu(btree->u.external[i].disk_secno);\r\nhpfs_inode->i_n_secs = le32_to_cpu(btree->u.external[i].length);\r\n}\r\nbrelse(bh);\r\nreturn a;\r\n}\r\nhpfs_error(s, "sector %08x not found in external anode %08x", sec, a);\r\nbrelse(bh);\r\nreturn -1;\r\n}\r\nsecno hpfs_add_sector_to_btree(struct super_block *s, secno node, int fnod, unsigned fsecno)\r\n{\r\nstruct bplus_header *btree;\r\nstruct anode *anode = NULL, *ranode = NULL;\r\nstruct fnode *fnode;\r\nanode_secno a, na = -1, ra, up = -1;\r\nsecno se;\r\nstruct buffer_head *bh, *bh1, *bh2;\r\nint n;\r\nunsigned fs;\r\nint c1, c2 = 0;\r\nif (fnod) {\r\nif (!(fnode = hpfs_map_fnode(s, node, &bh))) return -1;\r\nbtree = &fnode->btree;\r\n} else {\r\nif (!(anode = hpfs_map_anode(s, node, &bh))) return -1;\r\nbtree = &anode->btree;\r\n}\r\na = node;\r\ngo_down:\r\nif ((n = btree->n_used_nodes - 1) < -!!fnod) {\r\nhpfs_error(s, "anode %08x has no entries", a);\r\nbrelse(bh);\r\nreturn -1;\r\n}\r\nif (btree->internal) {\r\na = le32_to_cpu(btree->u.internal[n].down);\r\nbtree->u.internal[n].file_secno = cpu_to_le32(-1);\r\nmark_buffer_dirty(bh);\r\nbrelse(bh);\r\nif (hpfs_sb(s)->sb_chk)\r\nif (hpfs_stop_cycles(s, a, &c1, &c2, "hpfs_add_sector_to_btree #1")) return -1;\r\nif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\r\nbtree = &anode->btree;\r\ngoto go_down;\r\n}\r\nif (n >= 0) {\r\nif (le32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length) != fsecno) {\r\nhpfs_error(s, "allocated size %08x, trying to add sector %08x, %cnode %08x",\r\nle32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length), fsecno,\r\nfnod?'f':'a', node);\r\nbrelse(bh);\r\nreturn -1;\r\n}\r\nif (hpfs_alloc_if_possible(s, se = le32_to_cpu(btree->u.external[n].disk_secno) + le32_to_cpu(btree->u.external[n].length))) {\r\nbtree->u.external[n].length = cpu_to_le32(le32_to_cpu(btree->u.external[n].length) + 1);\r\nmark_buffer_dirty(bh);\r\nbrelse(bh);\r\nreturn se;\r\n}\r\n} else {\r\nif (fsecno) {\r\nhpfs_error(s, "empty file %08x, trying to add sector %08x", node, fsecno);\r\nbrelse(bh);\r\nreturn -1;\r\n}\r\nse = !fnod ? node : (node + 16384) & ~16383;\r\n}\r\nif (!(se = hpfs_alloc_sector(s, se, 1, fsecno*ALLOC_M>ALLOC_FWD_MAX ? ALLOC_FWD_MAX : fsecno*ALLOC_M<ALLOC_FWD_MIN ? ALLOC_FWD_MIN : fsecno*ALLOC_M))) {\r\nbrelse(bh);\r\nreturn -1;\r\n}\r\nfs = n < 0 ? 0 : le32_to_cpu(btree->u.external[n].file_secno) + le32_to_cpu(btree->u.external[n].length);\r\nif (!btree->n_free_nodes) {\r\nup = a != node ? le32_to_cpu(anode->up) : -1;\r\nif (!(anode = hpfs_alloc_anode(s, a, &na, &bh1))) {\r\nbrelse(bh);\r\nhpfs_free_sectors(s, se, 1);\r\nreturn -1;\r\n}\r\nif (a == node && fnod) {\r\nanode->up = cpu_to_le32(node);\r\nanode->btree.fnode_parent = 1;\r\nanode->btree.n_used_nodes = btree->n_used_nodes;\r\nanode->btree.first_free = btree->first_free;\r\nanode->btree.n_free_nodes = 40 - anode->btree.n_used_nodes;\r\nmemcpy(&anode->u, &btree->u, btree->n_used_nodes * 12);\r\nbtree->internal = 1;\r\nbtree->n_free_nodes = 11;\r\nbtree->n_used_nodes = 1;\r\nbtree->first_free = cpu_to_le16((char *)&(btree->u.internal[1]) - (char *)btree);\r\nbtree->u.internal[0].file_secno = cpu_to_le32(-1);\r\nbtree->u.internal[0].down = cpu_to_le32(na);\r\nmark_buffer_dirty(bh);\r\n} else if (!(ranode = hpfs_alloc_anode(s, 0, &ra, &bh2))) {\r\nbrelse(bh);\r\nbrelse(bh1);\r\nhpfs_free_sectors(s, se, 1);\r\nhpfs_free_sectors(s, na, 1);\r\nreturn -1;\r\n}\r\nbrelse(bh);\r\nbh = bh1;\r\nbtree = &anode->btree;\r\n}\r\nbtree->n_free_nodes--; n = btree->n_used_nodes++;\r\nbtree->first_free = cpu_to_le16(le16_to_cpu(btree->first_free) + 12);\r\nbtree->u.external[n].disk_secno = cpu_to_le32(se);\r\nbtree->u.external[n].file_secno = cpu_to_le32(fs);\r\nbtree->u.external[n].length = cpu_to_le32(1);\r\nmark_buffer_dirty(bh);\r\nbrelse(bh);\r\nif ((a == node && fnod) || na == -1) return se;\r\nc2 = 0;\r\nwhile (up != (anode_secno)-1) {\r\nstruct anode *new_anode;\r\nif (hpfs_sb(s)->sb_chk)\r\nif (hpfs_stop_cycles(s, up, &c1, &c2, "hpfs_add_sector_to_btree #2")) return -1;\r\nif (up != node || !fnod) {\r\nif (!(anode = hpfs_map_anode(s, up, &bh))) return -1;\r\nbtree = &anode->btree;\r\n} else {\r\nif (!(fnode = hpfs_map_fnode(s, up, &bh))) return -1;\r\nbtree = &fnode->btree;\r\n}\r\nif (btree->n_free_nodes) {\r\nbtree->n_free_nodes--; n = btree->n_used_nodes++;\r\nbtree->first_free = cpu_to_le16(le16_to_cpu(btree->first_free) + 8);\r\nbtree->u.internal[n].file_secno = cpu_to_le32(-1);\r\nbtree->u.internal[n].down = cpu_to_le32(na);\r\nbtree->u.internal[n-1].file_secno = cpu_to_le32(fs);\r\nmark_buffer_dirty(bh);\r\nbrelse(bh);\r\nbrelse(bh2);\r\nhpfs_free_sectors(s, ra, 1);\r\nif ((anode = hpfs_map_anode(s, na, &bh))) {\r\nanode->up = cpu_to_le32(up);\r\nanode->btree.fnode_parent = up == node && fnod;\r\nmark_buffer_dirty(bh);\r\nbrelse(bh);\r\n}\r\nreturn se;\r\n}\r\nup = up != node ? le32_to_cpu(anode->up) : -1;\r\nbtree->u.internal[btree->n_used_nodes - 1].file_secno = cpu_to_le32(-1);\r\nmark_buffer_dirty(bh);\r\nbrelse(bh);\r\na = na;\r\nif ((new_anode = hpfs_alloc_anode(s, a, &na, &bh))) {\r\nanode = new_anode;\r\nanode->btree.internal = 1;\r\nanode->btree.n_used_nodes = 1;\r\nanode->btree.n_free_nodes = 59;\r\nanode->btree.first_free = cpu_to_le16(16);\r\nanode->btree.u.internal[0].down = cpu_to_le32(a);\r\nanode->btree.u.internal[0].file_secno = cpu_to_le32(-1);\r\nmark_buffer_dirty(bh);\r\nbrelse(bh);\r\nif ((anode = hpfs_map_anode(s, a, &bh))) {\r\nanode->up = cpu_to_le32(na);\r\nmark_buffer_dirty(bh);\r\nbrelse(bh);\r\n}\r\n} else na = a;\r\n}\r\nif ((anode = hpfs_map_anode(s, na, &bh))) {\r\nanode->up = cpu_to_le32(node);\r\nif (fnod) anode->btree.fnode_parent = 1;\r\nmark_buffer_dirty(bh);\r\nbrelse(bh);\r\n}\r\nif (!fnod) {\r\nif (!(anode = hpfs_map_anode(s, node, &bh))) {\r\nbrelse(bh2);\r\nreturn -1;\r\n}\r\nbtree = &anode->btree;\r\n} else {\r\nif (!(fnode = hpfs_map_fnode(s, node, &bh))) {\r\nbrelse(bh2);\r\nreturn -1;\r\n}\r\nbtree = &fnode->btree;\r\n}\r\nranode->up = cpu_to_le32(node);\r\nmemcpy(&ranode->btree, btree, le16_to_cpu(btree->first_free));\r\nif (fnod) ranode->btree.fnode_parent = 1;\r\nranode->btree.n_free_nodes = (ranode->btree.internal ? 60 : 40) - ranode->btree.n_used_nodes;\r\nif (ranode->btree.internal) for (n = 0; n < ranode->btree.n_used_nodes; n++) {\r\nstruct anode *unode;\r\nif ((unode = hpfs_map_anode(s, le32_to_cpu(ranode->u.internal[n].down), &bh1))) {\r\nunode->up = cpu_to_le32(ra);\r\nunode->btree.fnode_parent = 0;\r\nmark_buffer_dirty(bh1);\r\nbrelse(bh1);\r\n}\r\n}\r\nbtree->internal = 1;\r\nbtree->n_free_nodes = fnod ? 10 : 58;\r\nbtree->n_used_nodes = 2;\r\nbtree->first_free = cpu_to_le16((char *)&btree->u.internal[2] - (char *)btree);\r\nbtree->u.internal[0].file_secno = cpu_to_le32(fs);\r\nbtree->u.internal[0].down = cpu_to_le32(ra);\r\nbtree->u.internal[1].file_secno = cpu_to_le32(-1);\r\nbtree->u.internal[1].down = cpu_to_le32(na);\r\nmark_buffer_dirty(bh);\r\nbrelse(bh);\r\nmark_buffer_dirty(bh2);\r\nbrelse(bh2);\r\nreturn se;\r\n}\r\nvoid hpfs_remove_btree(struct super_block *s, struct bplus_header *btree)\r\n{\r\nstruct bplus_header *btree1 = btree;\r\nstruct anode *anode = NULL;\r\nanode_secno ano = 0, oano;\r\nstruct buffer_head *bh;\r\nint level = 0;\r\nint pos = 0;\r\nint i;\r\nint c1, c2 = 0;\r\nint d1, d2;\r\ngo_down:\r\nd2 = 0;\r\nwhile (btree1->internal) {\r\nano = le32_to_cpu(btree1->u.internal[pos].down);\r\nif (level) brelse(bh);\r\nif (hpfs_sb(s)->sb_chk)\r\nif (hpfs_stop_cycles(s, ano, &d1, &d2, "hpfs_remove_btree #1"))\r\nreturn;\r\nif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\r\nbtree1 = &anode->btree;\r\nlevel++;\r\npos = 0;\r\n}\r\nfor (i = 0; i < btree1->n_used_nodes; i++)\r\nhpfs_free_sectors(s, le32_to_cpu(btree1->u.external[i].disk_secno), le32_to_cpu(btree1->u.external[i].length));\r\ngo_up:\r\nif (!level) return;\r\nbrelse(bh);\r\nif (hpfs_sb(s)->sb_chk)\r\nif (hpfs_stop_cycles(s, ano, &c1, &c2, "hpfs_remove_btree #2")) return;\r\nhpfs_free_sectors(s, ano, 1);\r\noano = ano;\r\nano = le32_to_cpu(anode->up);\r\nif (--level) {\r\nif (!(anode = hpfs_map_anode(s, ano, &bh))) return;\r\nbtree1 = &anode->btree;\r\n} else btree1 = btree;\r\nfor (i = 0; i < btree1->n_used_nodes; i++) {\r\nif (le32_to_cpu(btree1->u.internal[i].down) == oano) {\r\nif ((pos = i + 1) < btree1->n_used_nodes)\r\ngoto go_down;\r\nelse\r\ngoto go_up;\r\n}\r\n}\r\nhpfs_error(s,\r\n"reference to anode %08x not found in anode %08x "\r\n"(probably bad up pointer)",\r\noano, level ? ano : -1);\r\nif (level)\r\nbrelse(bh);\r\n}\r\nstatic secno anode_lookup(struct super_block *s, anode_secno a, unsigned sec)\r\n{\r\nstruct anode *anode;\r\nstruct buffer_head *bh;\r\nif (!(anode = hpfs_map_anode(s, a, &bh))) return -1;\r\nreturn hpfs_bplus_lookup(s, NULL, &anode->btree, sec, bh);\r\n}\r\nint hpfs_ea_read(struct super_block *s, secno a, int ano, unsigned pos,\r\nunsigned len, char *buf)\r\n{\r\nstruct buffer_head *bh;\r\nchar *data;\r\nsecno sec;\r\nunsigned l;\r\nwhile (len) {\r\nif (ano) {\r\nif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\r\nreturn -1;\r\n} else sec = a + (pos >> 9);\r\nif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, "ea #1")) return -1;\r\nif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\r\nreturn -1;\r\nl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\r\nmemcpy(buf, data + (pos & 0x1ff), l);\r\nbrelse(bh);\r\nbuf += l; pos += l; len -= l;\r\n}\r\nreturn 0;\r\n}\r\nint hpfs_ea_write(struct super_block *s, secno a, int ano, unsigned pos,\r\nunsigned len, const char *buf)\r\n{\r\nstruct buffer_head *bh;\r\nchar *data;\r\nsecno sec;\r\nunsigned l;\r\nwhile (len) {\r\nif (ano) {\r\nif ((sec = anode_lookup(s, a, pos >> 9)) == -1)\r\nreturn -1;\r\n} else sec = a + (pos >> 9);\r\nif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, sec, 1, "ea #2")) return -1;\r\nif (!(data = hpfs_map_sector(s, sec, &bh, (len - 1) >> 9)))\r\nreturn -1;\r\nl = 0x200 - (pos & 0x1ff); if (l > len) l = len;\r\nmemcpy(data + (pos & 0x1ff), buf, l);\r\nmark_buffer_dirty(bh);\r\nbrelse(bh);\r\nbuf += l; pos += l; len -= l;\r\n}\r\nreturn 0;\r\n}\r\nvoid hpfs_ea_remove(struct super_block *s, secno a, int ano, unsigned len)\r\n{\r\nstruct anode *anode;\r\nstruct buffer_head *bh;\r\nif (ano) {\r\nif (!(anode = hpfs_map_anode(s, a, &bh))) return;\r\nhpfs_remove_btree(s, &anode->btree);\r\nbrelse(bh);\r\nhpfs_free_sectors(s, a, 1);\r\n} else hpfs_free_sectors(s, a, (len + 511) >> 9);\r\n}\r\nvoid hpfs_truncate_btree(struct super_block *s, secno f, int fno, unsigned secs)\r\n{\r\nstruct fnode *fnode;\r\nstruct anode *anode;\r\nstruct buffer_head *bh;\r\nstruct bplus_header *btree;\r\nanode_secno node = f;\r\nint i, j, nodes;\r\nint c1, c2 = 0;\r\nif (fno) {\r\nif (!(fnode = hpfs_map_fnode(s, f, &bh))) return;\r\nbtree = &fnode->btree;\r\n} else {\r\nif (!(anode = hpfs_map_anode(s, f, &bh))) return;\r\nbtree = &anode->btree;\r\n}\r\nif (!secs) {\r\nhpfs_remove_btree(s, btree);\r\nif (fno) {\r\nbtree->n_free_nodes = 8;\r\nbtree->n_used_nodes = 0;\r\nbtree->first_free = cpu_to_le16(8);\r\nbtree->internal = 0;\r\nmark_buffer_dirty(bh);\r\n} else hpfs_free_sectors(s, f, 1);\r\nbrelse(bh);\r\nreturn;\r\n}\r\nwhile (btree->internal) {\r\nnodes = btree->n_used_nodes + btree->n_free_nodes;\r\nfor (i = 0; i < btree->n_used_nodes; i++)\r\nif (le32_to_cpu(btree->u.internal[i].file_secno) >= secs) goto f;\r\nbrelse(bh);\r\nhpfs_error(s, "internal btree %08x doesn't end with -1", node);\r\nreturn;\r\nf:\r\nfor (j = i + 1; j < btree->n_used_nodes; j++)\r\nhpfs_ea_remove(s, le32_to_cpu(btree->u.internal[j].down), 1, 0);\r\nbtree->n_used_nodes = i + 1;\r\nbtree->n_free_nodes = nodes - btree->n_used_nodes;\r\nbtree->first_free = cpu_to_le16(8 + 8 * btree->n_used_nodes);\r\nmark_buffer_dirty(bh);\r\nif (btree->u.internal[i].file_secno == cpu_to_le32(secs)) {\r\nbrelse(bh);\r\nreturn;\r\n}\r\nnode = le32_to_cpu(btree->u.internal[i].down);\r\nbrelse(bh);\r\nif (hpfs_sb(s)->sb_chk)\r\nif (hpfs_stop_cycles(s, node, &c1, &c2, "hpfs_truncate_btree"))\r\nreturn;\r\nif (!(anode = hpfs_map_anode(s, node, &bh))) return;\r\nbtree = &anode->btree;\r\n}\r\nnodes = btree->n_used_nodes + btree->n_free_nodes;\r\nfor (i = 0; i < btree->n_used_nodes; i++)\r\nif (le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) >= secs) goto ff;\r\nbrelse(bh);\r\nreturn;\r\nff:\r\nif (secs <= le32_to_cpu(btree->u.external[i].file_secno)) {\r\nhpfs_error(s, "there is an allocation error in file %08x, sector %08x", f, secs);\r\nif (i) i--;\r\n}\r\nelse if (le32_to_cpu(btree->u.external[i].file_secno) + le32_to_cpu(btree->u.external[i].length) > secs) {\r\nhpfs_free_sectors(s, le32_to_cpu(btree->u.external[i].disk_secno) + secs -\r\nle32_to_cpu(btree->u.external[i].file_secno), le32_to_cpu(btree->u.external[i].length)\r\n- secs + le32_to_cpu(btree->u.external[i].file_secno));\r\nbtree->u.external[i].length = cpu_to_le32(secs - le32_to_cpu(btree->u.external[i].file_secno));\r\n}\r\nfor (j = i + 1; j < btree->n_used_nodes; j++)\r\nhpfs_free_sectors(s, le32_to_cpu(btree->u.external[j].disk_secno), le32_to_cpu(btree->u.external[j].length));\r\nbtree->n_used_nodes = i + 1;\r\nbtree->n_free_nodes = nodes - btree->n_used_nodes;\r\nbtree->first_free = cpu_to_le16(8 + 12 * btree->n_used_nodes);\r\nmark_buffer_dirty(bh);\r\nbrelse(bh);\r\n}\r\nvoid hpfs_remove_fnode(struct super_block *s, fnode_secno fno)\r\n{\r\nstruct buffer_head *bh;\r\nstruct fnode *fnode;\r\nstruct extended_attribute *ea;\r\nstruct extended_attribute *ea_end;\r\nif (!(fnode = hpfs_map_fnode(s, fno, &bh))) return;\r\nif (!fnode->dirflag) hpfs_remove_btree(s, &fnode->btree);\r\nelse hpfs_remove_dtree(s, le32_to_cpu(fnode->u.external[0].disk_secno));\r\nea_end = fnode_end_ea(fnode);\r\nfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\r\nif (ea->indirect)\r\nhpfs_ea_remove(s, ea_sec(ea), ea->anode, ea_len(ea));\r\nhpfs_ea_ext_remove(s, le32_to_cpu(fnode->ea_secno), fnode->ea_anode, le32_to_cpu(fnode->ea_size_l));\r\nbrelse(bh);\r\nhpfs_free_sectors(s, fno, 1);\r\n}
