static void Set22K (struct budget *budget, int state)\r\n{\r\nstruct saa7146_dev *dev=budget->dev;\r\ndprintk(2, "budget: %p\n", budget);\r\nsaa7146_setgpio(dev, 3, (state ? SAA7146_GPIO_OUTHI : SAA7146_GPIO_OUTLO));\r\n}\r\nstatic void DiseqcSendBit (struct budget *budget, int data)\r\n{\r\nstruct saa7146_dev *dev=budget->dev;\r\ndprintk(2, "budget: %p\n", budget);\r\nsaa7146_setgpio(dev, 3, SAA7146_GPIO_OUTHI);\r\nudelay(data ? 500 : 1000);\r\nsaa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO);\r\nudelay(data ? 1000 : 500);\r\n}\r\nstatic void DiseqcSendByte (struct budget *budget, int data)\r\n{\r\nint i, par=1, d;\r\ndprintk(2, "budget: %p\n", budget);\r\nfor (i=7; i>=0; i--) {\r\nd = (data>>i)&1;\r\npar ^= d;\r\nDiseqcSendBit(budget, d);\r\n}\r\nDiseqcSendBit(budget, par);\r\n}\r\nstatic int SendDiSEqCMsg (struct budget *budget, int len, u8 *msg, unsigned long burst)\r\n{\r\nstruct saa7146_dev *dev=budget->dev;\r\nint i;\r\ndprintk(2, "budget: %p\n", budget);\r\nsaa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO);\r\nmdelay(16);\r\nfor (i=0; i<len; i++)\r\nDiseqcSendByte(budget, msg[i]);\r\nmdelay(16);\r\nif (burst!=-1) {\r\nif (burst)\r\nDiseqcSendByte(budget, 0xff);\r\nelse {\r\nsaa7146_setgpio(dev, 3, SAA7146_GPIO_OUTHI);\r\nmdelay(12);\r\nudelay(500);\r\nsaa7146_setgpio(dev, 3, SAA7146_GPIO_OUTLO);\r\n}\r\nmsleep(20);\r\n}\r\nreturn 0;\r\n}\r\nstatic int SetVoltage_Activy (struct budget *budget, fe_sec_voltage_t voltage)\r\n{\r\nstruct saa7146_dev *dev=budget->dev;\r\ndprintk(2, "budget: %p\n", budget);\r\nswitch (voltage) {\r\ncase SEC_VOLTAGE_13:\r\nsaa7146_setgpio(dev, 1, SAA7146_GPIO_OUTHI);\r\nsaa7146_setgpio(dev, 2, SAA7146_GPIO_OUTLO);\r\nbreak;\r\ncase SEC_VOLTAGE_18:\r\nsaa7146_setgpio(dev, 1, SAA7146_GPIO_OUTHI);\r\nsaa7146_setgpio(dev, 2, SAA7146_GPIO_OUTHI);\r\nbreak;\r\ncase SEC_VOLTAGE_OFF:\r\nsaa7146_setgpio(dev, 1, SAA7146_GPIO_OUTLO);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int siemens_budget_set_voltage(struct dvb_frontend* fe, fe_sec_voltage_t voltage)\r\n{\r\nstruct budget* budget = (struct budget*) fe->dvb->priv;\r\nreturn SetVoltage_Activy (budget, voltage);\r\n}\r\nstatic int budget_set_tone(struct dvb_frontend* fe, fe_sec_tone_mode_t tone)\r\n{\r\nstruct budget* budget = (struct budget*) fe->dvb->priv;\r\nswitch (tone) {\r\ncase SEC_TONE_ON:\r\nSet22K (budget, 1);\r\nbreak;\r\ncase SEC_TONE_OFF:\r\nSet22K (budget, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int budget_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd* cmd)\r\n{\r\nstruct budget* budget = (struct budget*) fe->dvb->priv;\r\nSendDiSEqCMsg (budget, cmd->msg_len, cmd->msg, 0);\r\nreturn 0;\r\n}\r\nstatic int budget_diseqc_send_burst(struct dvb_frontend* fe, fe_sec_mini_cmd_t minicmd)\r\n{\r\nstruct budget* budget = (struct budget*) fe->dvb->priv;\r\nSendDiSEqCMsg (budget, 0, NULL, minicmd);\r\nreturn 0;\r\n}\r\nstatic int alps_bsrv2_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct budget* budget = (struct budget*) fe->dvb->priv;\r\nu8 pwr = 0;\r\nu8 buf[4];\r\nstruct i2c_msg msg = { .addr = 0x61, .flags = 0, .buf = buf, .len = sizeof(buf) };\r\nu32 div = (c->frequency + 479500) / 125;\r\nif (c->frequency > 2000000)\r\npwr = 3;\r\nelse if (c->frequency > 1800000)\r\npwr = 2;\r\nelse if (c->frequency > 1600000)\r\npwr = 1;\r\nelse if (c->frequency > 1200000)\r\npwr = 0;\r\nelse if (c->frequency >= 1100000)\r\npwr = 1;\r\nelse pwr = 2;\r\nbuf[0] = (div >> 8) & 0x7f;\r\nbuf[1] = div & 0xff;\r\nbuf[2] = ((div & 0x18000) >> 10) | 0x95;\r\nbuf[3] = (pwr << 6) | 0x30;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer (&budget->i2c_adap, &msg, 1) != 1) return -EIO;\r\nreturn 0;\r\n}\r\nstatic int alps_tdbe2_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct budget* budget = (struct budget*) fe->dvb->priv;\r\nu32 div;\r\nu8 data[4];\r\nstruct i2c_msg msg = { .addr = 0x62, .flags = 0, .buf = data, .len = sizeof(data) };\r\ndiv = (c->frequency + 35937500 + 31250) / 62500;\r\ndata[0] = (div >> 8) & 0x7f;\r\ndata[1] = div & 0xff;\r\ndata[2] = 0x85 | ((div >> 10) & 0x60);\r\ndata[3] = (c->frequency < 174000000 ? 0x88 : c->frequency < 470000000 ? 0x84 : 0x81);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer (&budget->i2c_adap, &msg, 1) != 1) return -EIO;\r\nreturn 0;\r\n}\r\nstatic int grundig_29504_401_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct budget *budget = fe->dvb->priv;\r\nu8 *tuner_addr = fe->tuner_priv;\r\nu32 div;\r\nu8 cfg, cpump, band_select;\r\nu8 data[4];\r\nstruct i2c_msg msg = { .flags = 0, .buf = data, .len = sizeof(data) };\r\nif (tuner_addr)\r\nmsg.addr = *tuner_addr;\r\nelse\r\nmsg.addr = 0x61;\r\ndiv = (36125000 + c->frequency) / 166666;\r\ncfg = 0x88;\r\nif (c->frequency < 175000000)\r\ncpump = 2;\r\nelse if (c->frequency < 390000000)\r\ncpump = 1;\r\nelse if (c->frequency < 470000000)\r\ncpump = 2;\r\nelse if (c->frequency < 750000000)\r\ncpump = 1;\r\nelse\r\ncpump = 3;\r\nif (c->frequency < 175000000)\r\nband_select = 0x0e;\r\nelse if (c->frequency < 470000000)\r\nband_select = 0x05;\r\nelse\r\nband_select = 0x03;\r\ndata[0] = (div >> 8) & 0x7f;\r\ndata[1] = div & 0xff;\r\ndata[2] = ((div >> 10) & 0x60) | cfg;\r\ndata[3] = (cpump << 6) | band_select;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer (&budget->i2c_adap, &msg, 1) != 1) return -EIO;\r\nreturn 0;\r\n}\r\nstatic int grundig_29504_451_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct budget* budget = (struct budget*) fe->dvb->priv;\r\nu32 div;\r\nu8 data[4];\r\nstruct i2c_msg msg = { .addr = 0x61, .flags = 0, .buf = data, .len = sizeof(data) };\r\ndiv = c->frequency / 125;\r\ndata[0] = (div >> 8) & 0x7f;\r\ndata[1] = div & 0xff;\r\ndata[2] = 0x8e;\r\ndata[3] = 0x00;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer (&budget->i2c_adap, &msg, 1) != 1) return -EIO;\r\nreturn 0;\r\n}\r\nstatic int s5h1420_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct budget* budget = (struct budget*) fe->dvb->priv;\r\nu32 div;\r\nu8 data[4];\r\nstruct i2c_msg msg = { .addr = 0x61, .flags = 0, .buf = data, .len = sizeof(data) };\r\ndiv = c->frequency / 1000;\r\ndata[0] = (div >> 8) & 0x7f;\r\ndata[1] = div & 0xff;\r\ndata[2] = 0xc2;\r\nif (div < 1450)\r\ndata[3] = 0x00;\r\nelse if (div < 1850)\r\ndata[3] = 0x40;\r\nelse if (div < 2000)\r\ndata[3] = 0x80;\r\nelse\r\ndata[3] = 0xc0;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer (&budget->i2c_adap, &msg, 1) != 1) return -EIO;\r\nreturn 0;\r\n}\r\nstatic int alps_tdhd1_204_request_firmware(struct dvb_frontend *fe, const struct firmware **fw, char *name)\r\n{\r\nstruct budget *budget = (struct budget *)fe->dvb->priv;\r\nreturn request_firmware(fw, name, &budget->dev->pci->dev);\r\n}\r\nstatic int i2c_readreg(struct i2c_adapter *i2c, u8 adr, u8 reg)\r\n{\r\nu8 val;\r\nstruct i2c_msg msg[] = {\r\n{ .addr = adr, .flags = 0, .buf = &reg, .len = 1 },\r\n{ .addr = adr, .flags = I2C_M_RD, .buf = &val, .len = 1 }\r\n};\r\nreturn (i2c_transfer(i2c, msg, 2) != 2) ? -EIO : val;\r\n}\r\nstatic u8 read_pwm(struct budget* budget)\r\n{\r\nu8 b = 0xff;\r\nu8 pwm;\r\nstruct i2c_msg msg[] = { { .addr = 0x50,.flags = 0,.buf = &b,.len = 1 },\r\n{ .addr = 0x50,.flags = I2C_M_RD,.buf = &pwm,.len = 1} };\r\nif ((i2c_transfer(&budget->i2c_adap, msg, 2) != 2) || (pwm == 0xff))\r\npwm = 0x48;\r\nreturn pwm;\r\n}\r\nstatic void frontend_init(struct budget *budget)\r\n{\r\n(void)alps_bsbe1_config;\r\nswitch(budget->dev->pci->subsystem_device) {\r\ncase 0x1003:\r\ncase 0x1013:\r\nbudget->dvb_frontend = dvb_attach(ves1x93_attach, &alps_bsrv2_config, &budget->i2c_adap);\r\nif (budget->dvb_frontend) {\r\nbudget->dvb_frontend->ops.tuner_ops.set_params = alps_bsrv2_tuner_set_params;\r\nbudget->dvb_frontend->ops.diseqc_send_master_cmd = budget_diseqc_send_master_cmd;\r\nbudget->dvb_frontend->ops.diseqc_send_burst = budget_diseqc_send_burst;\r\nbudget->dvb_frontend->ops.set_tone = budget_set_tone;\r\nbreak;\r\n}\r\nbudget->dvb_frontend = dvb_attach(stv0299_attach, &alps_bsru6_config, &budget->i2c_adap);\r\nif (budget->dvb_frontend) {\r\nbudget->dvb_frontend->ops.tuner_ops.set_params = alps_bsru6_tuner_set_params;\r\nbudget->dvb_frontend->tuner_priv = &budget->i2c_adap;\r\nif (budget->dev->pci->subsystem_device == 0x1003 && diseqc_method == 0) {\r\nbudget->dvb_frontend->ops.diseqc_send_master_cmd = budget_diseqc_send_master_cmd;\r\nbudget->dvb_frontend->ops.diseqc_send_burst = budget_diseqc_send_burst;\r\nbudget->dvb_frontend->ops.set_tone = budget_set_tone;\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ncase 0x1004:\r\nbudget->dvb_frontend = dvb_attach(ves1820_attach, &alps_tdbe2_config, &budget->i2c_adap, read_pwm(budget));\r\nif (budget->dvb_frontend) {\r\nbudget->dvb_frontend->ops.tuner_ops.set_params = alps_tdbe2_tuner_set_params;\r\nbreak;\r\n}\r\nbreak;\r\ncase 0x1005:\r\nbudget->dvb_frontend = dvb_attach(l64781_attach, &grundig_29504_401_config, &budget->i2c_adap);\r\nif (budget->dvb_frontend) {\r\nbudget->dvb_frontend->ops.tuner_ops.set_params = grundig_29504_401_tuner_set_params;\r\nbudget->dvb_frontend->tuner_priv = NULL;\r\nbreak;\r\n}\r\nbreak;\r\ncase 0x4f60:\r\n{\r\nint subtype = i2c_readreg(&budget->i2c_adap, 0x50, 0x67);\r\nif (subtype < 0)\r\nbreak;\r\nif (subtype < 0x36) {\r\nbudget->dvb_frontend = dvb_attach(stv0299_attach, &alps_bsru6_config_activy, &budget->i2c_adap);\r\nif (budget->dvb_frontend) {\r\nprintk(KERN_INFO "budget: tuner ALPS BSRU6 detected\n");\r\nbudget->dvb_frontend->ops.tuner_ops.set_params = alps_bsru6_tuner_set_params;\r\nbudget->dvb_frontend->tuner_priv = &budget->i2c_adap;\r\nbudget->dvb_frontend->ops.set_voltage = siemens_budget_set_voltage;\r\nbudget->dvb_frontend->ops.dishnetwork_send_legacy_command = NULL;\r\nbreak;\r\n}\r\n} else {\r\nsaa7146_setgpio(budget->dev, 3, SAA7146_GPIO_OUTLO);\r\nmsleep(50);\r\nsaa7146_setgpio(budget->dev, 3, SAA7146_GPIO_OUTHI);\r\nmsleep(250);\r\nbudget->dvb_frontend = dvb_attach(stv0299_attach, &alps_bsbe1_config_activy, &budget->i2c_adap);\r\nif (budget->dvb_frontend) {\r\nprintk(KERN_INFO "budget: tuner ALPS BSBE1 detected\n");\r\nbudget->dvb_frontend->ops.tuner_ops.set_params = alps_bsbe1_tuner_set_params;\r\nbudget->dvb_frontend->tuner_priv = &budget->i2c_adap;\r\nbudget->dvb_frontend->ops.set_voltage = siemens_budget_set_voltage;\r\nbudget->dvb_frontend->ops.dishnetwork_send_legacy_command = NULL;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\ncase 0x4f61:\r\nbudget->dvb_frontend = dvb_attach(tda8083_attach, &grundig_29504_451_config, &budget->i2c_adap);\r\nif (budget->dvb_frontend) {\r\nbudget->dvb_frontend->ops.tuner_ops.set_params = grundig_29504_451_tuner_set_params;\r\nbudget->dvb_frontend->ops.set_voltage = siemens_budget_set_voltage;\r\nbudget->dvb_frontend->ops.dishnetwork_send_legacy_command = NULL;\r\n}\r\nbreak;\r\ncase 0x5f60:\r\nbudget->dvb_frontend = dvb_attach(tda10046_attach, &alps_tdhd1_204a_config, &budget->i2c_adap);\r\nif (budget->dvb_frontend) {\r\nbudget->dvb_frontend->ops.tuner_ops.set_params = alps_tdhd1_204a_tuner_set_params;\r\nbudget->dvb_frontend->tuner_priv = &budget->i2c_adap;\r\n}\r\nbreak;\r\ncase 0x5f61:\r\nbudget->dvb_frontend = dvb_attach(l64781_attach, &grundig_29504_401_config_activy, &budget->i2c_adap);\r\nif (budget->dvb_frontend) {\r\nbudget->dvb_frontend->tuner_priv = &tuner_address_grundig_29504_401_activy;\r\nbudget->dvb_frontend->ops.tuner_ops.set_params = grundig_29504_401_tuner_set_params;\r\n}\r\nbreak;\r\ncase 0x1016:\r\nbudget->dvb_frontend = dvb_attach(s5h1420_attach, &s5h1420_config, &budget->i2c_adap);\r\nif (budget->dvb_frontend) {\r\nbudget->dvb_frontend->ops.tuner_ops.set_params = s5h1420_tuner_set_params;\r\nif (dvb_attach(lnbp21_attach, budget->dvb_frontend, &budget->i2c_adap, 0, 0) == NULL) {\r\nprintk("%s: No LNBP21 found!\n", __func__);\r\ngoto error_out;\r\n}\r\nbreak;\r\n}\r\ncase 0x1018:\r\nsaa7146_setgpio(budget->dev, 2, SAA7146_GPIO_OUTLO);\r\nmsleep(1);\r\nsaa7146_setgpio(budget->dev, 2, SAA7146_GPIO_OUTHI);\r\nmsleep(1);\r\nbudget->dvb_frontend = dvb_attach(tda10086_attach, &tda10086_config, &budget->i2c_adap);\r\nif (budget->dvb_frontend) {\r\nif (dvb_attach(tda826x_attach, budget->dvb_frontend, 0x60, &budget->i2c_adap, 0) == NULL)\r\nprintk("%s: No tda826x found!\n", __func__);\r\nif (dvb_attach(lnbp21_attach, budget->dvb_frontend, &budget->i2c_adap, 0, 0) == NULL) {\r\nprintk("%s: No LNBP21 found!\n", __func__);\r\ngoto error_out;\r\n}\r\nbreak;\r\n}\r\ncase 0x101c: {\r\nstruct stv6110x_devctl *ctl;\r\nsaa7146_setgpio(budget->dev, 2, SAA7146_GPIO_OUTLO);\r\nmsleep(50);\r\nsaa7146_setgpio(budget->dev, 2, SAA7146_GPIO_OUTHI);\r\nmsleep(250);\r\nbudget->dvb_frontend = dvb_attach(stv090x_attach,\r\n&tt1600_stv090x_config,\r\n&budget->i2c_adap,\r\nSTV090x_DEMODULATOR_0);\r\nif (budget->dvb_frontend) {\r\nctl = dvb_attach(stv6110x_attach,\r\nbudget->dvb_frontend,\r\n&tt1600_stv6110x_config,\r\n&budget->i2c_adap);\r\nif (ctl) {\r\ntt1600_stv090x_config.tuner_init = ctl->tuner_init;\r\ntt1600_stv090x_config.tuner_sleep = ctl->tuner_sleep;\r\ntt1600_stv090x_config.tuner_set_mode = ctl->tuner_set_mode;\r\ntt1600_stv090x_config.tuner_set_frequency = ctl->tuner_set_frequency;\r\ntt1600_stv090x_config.tuner_get_frequency = ctl->tuner_get_frequency;\r\ntt1600_stv090x_config.tuner_set_bandwidth = ctl->tuner_set_bandwidth;\r\ntt1600_stv090x_config.tuner_get_bandwidth = ctl->tuner_get_bandwidth;\r\ntt1600_stv090x_config.tuner_set_bbgain = ctl->tuner_set_bbgain;\r\ntt1600_stv090x_config.tuner_get_bbgain = ctl->tuner_get_bbgain;\r\ntt1600_stv090x_config.tuner_set_refclk = ctl->tuner_set_refclk;\r\ntt1600_stv090x_config.tuner_get_status = ctl->tuner_get_status;\r\nif (budget->dvb_frontend->ops.init)\r\nbudget->dvb_frontend->ops.init(budget->dvb_frontend);\r\nif (dvb_attach(isl6423_attach,\r\nbudget->dvb_frontend,\r\n&budget->i2c_adap,\r\n&tt1600_isl6423_config) == NULL) {\r\nprintk(KERN_ERR "%s: No Intersil ISL6423 found!\n", __func__);\r\ngoto error_out;\r\n}\r\n} else {\r\nprintk(KERN_ERR "%s: No STV6110(A) Silicon Tuner found!\n", __func__);\r\ngoto error_out;\r\n}\r\n}\r\n}\r\nbreak;\r\n}\r\nif (budget->dvb_frontend == NULL) {\r\nprintk("budget: A frontend driver was not found for device [%04x:%04x] subsystem [%04x:%04x]\n",\r\nbudget->dev->pci->vendor,\r\nbudget->dev->pci->device,\r\nbudget->dev->pci->subsystem_vendor,\r\nbudget->dev->pci->subsystem_device);\r\n} else {\r\nif (dvb_register_frontend(&budget->dvb_adapter, budget->dvb_frontend))\r\ngoto error_out;\r\n}\r\nreturn;\r\nerror_out:\r\nprintk("budget: Frontend registration failed!\n");\r\ndvb_frontend_detach(budget->dvb_frontend);\r\nbudget->dvb_frontend = NULL;\r\nreturn;\r\n}\r\nstatic int budget_attach (struct saa7146_dev* dev, struct saa7146_pci_extension_data *info)\r\n{\r\nstruct budget *budget = NULL;\r\nint err;\r\nbudget = kmalloc(sizeof(struct budget), GFP_KERNEL);\r\nif( NULL == budget ) {\r\nreturn -ENOMEM;\r\n}\r\ndprintk(2, "dev:%p, info:%p, budget:%p\n", dev, info, budget);\r\ndev->ext_priv = budget;\r\nerr = ttpci_budget_init(budget, dev, info, THIS_MODULE, adapter_nr);\r\nif (err) {\r\nprintk("==> failed\n");\r\nkfree (budget);\r\nreturn err;\r\n}\r\nbudget->dvb_adapter.priv = budget;\r\nfrontend_init(budget);\r\nttpci_budget_init_hooks(budget);\r\nreturn 0;\r\n}\r\nstatic int budget_detach (struct saa7146_dev* dev)\r\n{\r\nstruct budget *budget = (struct budget*) dev->ext_priv;\r\nint err;\r\nif (budget->dvb_frontend) {\r\ndvb_unregister_frontend(budget->dvb_frontend);\r\ndvb_frontend_detach(budget->dvb_frontend);\r\n}\r\nerr = ttpci_budget_deinit (budget);\r\nkfree (budget);\r\ndev->ext_priv = NULL;\r\nreturn err;\r\n}\r\nstatic int __init budget_init(void)\r\n{\r\nreturn saa7146_register_extension(&budget_extension);\r\n}\r\nstatic void __exit budget_exit(void)\r\n{\r\nsaa7146_unregister_extension(&budget_extension);\r\n}
