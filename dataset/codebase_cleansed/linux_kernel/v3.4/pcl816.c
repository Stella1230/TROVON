static int __init driver_pcl816_init_module(void)\r\n{\r\nreturn comedi_driver_register(&driver_pcl816);\r\n}\r\nstatic void __exit driver_pcl816_cleanup_module(void)\r\n{\r\ncomedi_driver_unregister(&driver_pcl816);\r\n}\r\nstatic int pcl816_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n;\r\nint timeout;\r\nDPRINTK("mode 0 analog input\n");\r\noutb(0, dev->iobase + PCL816_CONTROL);\r\noutb(0, dev->iobase + PCL816_CLRINT);\r\noutb(CR_CHAN(insn->chanspec) & 0xf, dev->iobase + PCL816_MUX);\r\noutb(CR_RANGE(insn->chanspec), dev->iobase + PCL816_RANGE);\r\nfor (n = 0; n < insn->n; n++) {\r\noutb(0, dev->iobase + PCL816_AD_LO);\r\ntimeout = 100;\r\nwhile (timeout--) {\r\nif (!(inb(dev->iobase + PCL816_STATUS) &\r\nPCL816_STATUS_DRDY_MASK)) {\r\ndata[n] =\r\n((inb(dev->iobase +\r\nPCL816_AD_HI) << 8) |\r\n(inb(dev->iobase + PCL816_AD_LO)));\r\noutb(0, dev->iobase + PCL816_CLRINT);\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\nif (!timeout) {\r\ncomedi_error(dev, "A/D insn timeout\n");\r\ndata[0] = 0;\r\noutb(0, dev->iobase + PCL816_CLRINT);\r\nreturn -EIO;\r\n}\r\n}\r\nreturn n;\r\n}\r\nstatic irqreturn_t interrupt_pcl816_ai_mode13_int(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s = dev->subdevices + 0;\r\nint low, hi;\r\nint timeout = 50;\r\nwhile (timeout--) {\r\nif (!(inb(dev->iobase + PCL816_STATUS) &\r\nPCL816_STATUS_DRDY_MASK))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (!timeout) {\r\noutb(0, dev->iobase + PCL816_CLRINT);\r\ncomedi_error(dev, "A/D mode1/3 IRQ without DRDY!");\r\npcl816_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nlow = inb(dev->iobase + PCL816_AD_LO);\r\nhi = inb(dev->iobase + PCL816_AD_HI);\r\ncomedi_buf_put(s->async, (hi << 8) | low);\r\noutb(0, dev->iobase + PCL816_CLRINT);\r\nif (++devpriv->ai_act_chanlist_pos >= devpriv->ai_act_chanlist_len)\r\ndevpriv->ai_act_chanlist_pos = 0;\r\ns->async->cur_chan++;\r\nif (s->async->cur_chan >= devpriv->ai_n_chan) {\r\ns->async->cur_chan = 0;\r\ndevpriv->ai_act_scan++;\r\n}\r\nif (!devpriv->ai_neverending)\r\nif (devpriv->ai_act_scan >= devpriv->ai_scans) {\r\npcl816_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA;\r\n}\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void transfer_from_dma_buf(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, short *ptr,\r\nunsigned int bufptr, unsigned int len)\r\n{\r\nint i;\r\ns->async->events = 0;\r\nfor (i = 0; i < len; i++) {\r\ncomedi_buf_put(s->async, ptr[bufptr++]);\r\nif (++devpriv->ai_act_chanlist_pos >=\r\ndevpriv->ai_act_chanlist_len) {\r\ndevpriv->ai_act_chanlist_pos = 0;\r\n}\r\ns->async->cur_chan++;\r\nif (s->async->cur_chan >= devpriv->ai_n_chan) {\r\ns->async->cur_chan = 0;\r\ndevpriv->ai_act_scan++;\r\n}\r\nif (!devpriv->ai_neverending)\r\nif (devpriv->ai_act_scan >= devpriv->ai_scans) {\r\npcl816_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA;\r\ns->async->events |= COMEDI_CB_BLOCK;\r\nbreak;\r\n}\r\n}\r\ncomedi_event(dev, s);\r\n}\r\nstatic irqreturn_t interrupt_pcl816_ai_mode13_dma(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s = dev->subdevices + 0;\r\nint len, bufptr, this_dma_buf;\r\nunsigned long dma_flags;\r\nshort *ptr;\r\ndisable_dma(devpriv->dma);\r\nthis_dma_buf = devpriv->next_dma_buf;\r\nif ((devpriv->dma_runs_to_end > -1) || devpriv->ai_neverending) {\r\ndevpriv->next_dma_buf = 1 - devpriv->next_dma_buf;\r\nset_dma_mode(devpriv->dma, DMA_MODE_READ);\r\ndma_flags = claim_dma_lock();\r\nset_dma_addr(devpriv->dma,\r\ndevpriv->hwdmaptr[devpriv->next_dma_buf]);\r\nif (devpriv->dma_runs_to_end) {\r\nset_dma_count(devpriv->dma,\r\ndevpriv->hwdmasize[devpriv->\r\nnext_dma_buf]);\r\n} else {\r\nset_dma_count(devpriv->dma, devpriv->last_dma_run);\r\n}\r\nrelease_dma_lock(dma_flags);\r\nenable_dma(devpriv->dma);\r\n}\r\ndevpriv->dma_runs_to_end--;\r\noutb(0, dev->iobase + PCL816_CLRINT);\r\nptr = (short *)devpriv->dmabuf[this_dma_buf];\r\nlen = (devpriv->hwdmasize[0] >> 1) - devpriv->ai_poll_ptr;\r\nbufptr = devpriv->ai_poll_ptr;\r\ndevpriv->ai_poll_ptr = 0;\r\ntransfer_from_dma_buf(dev, s, ptr, bufptr, len);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t interrupt_pcl816(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nDPRINTK("<I>");\r\nif (!dev->attached) {\r\ncomedi_error(dev, "premature interrupt");\r\nreturn IRQ_HANDLED;\r\n}\r\nswitch (devpriv->int816_mode) {\r\ncase INT_TYPE_AI1_DMA:\r\ncase INT_TYPE_AI3_DMA:\r\nreturn interrupt_pcl816_ai_mode13_dma(irq, d);\r\ncase INT_TYPE_AI1_INT:\r\ncase INT_TYPE_AI3_INT:\r\nreturn interrupt_pcl816_ai_mode13_int(irq, d);\r\n}\r\noutb(0, dev->iobase + PCL816_CLRINT);\r\nif ((!dev->irq) | (!devpriv->irq_free) | (!devpriv->irq_blocked) |\r\n(!devpriv->int816_mode)) {\r\nif (devpriv->irq_was_now_closed) {\r\ndevpriv->irq_was_now_closed = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\ncomedi_error(dev, "bad IRQ!");\r\nreturn IRQ_NONE;\r\n}\r\ncomedi_error(dev, "IRQ from unknown source!");\r\nreturn IRQ_NONE;\r\n}\r\nstatic void pcl816_cmdtest_out(int e, struct comedi_cmd *cmd)\r\n{\r\nprintk(KERN_INFO "pcl816 e=%d startsrc=%x scansrc=%x convsrc=%x\n", e,\r\ncmd->start_src, cmd->scan_begin_src, cmd->convert_src);\r\nprintk(KERN_INFO "pcl816 e=%d startarg=%d scanarg=%d convarg=%d\n", e,\r\ncmd->start_arg, cmd->scan_begin_arg, cmd->convert_arg);\r\nprintk(KERN_INFO "pcl816 e=%d stopsrc=%x scanend=%x\n", e,\r\ncmd->stop_src, cmd->scan_end_src);\r\nprintk(KERN_INFO "pcl816 e=%d stoparg=%d scanendarg=%d chanlistlen=%d\n",\r\ne, cmd->stop_arg, cmd->scan_end_arg, cmd->chanlist_len);\r\n}\r\nstatic int pcl816_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp, divisor1 = 0, divisor2 = 0;\r\nDEBUG(printk(KERN_INFO "pcl816 pcl812_ai_cmdtest\n");\r\npcl816_cmdtest_out(-1, cmd);\r\n);\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_FOLLOW;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_EXT | TRIG_TIMER;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->start_src != TRIG_NOW) {\r\ncmd->start_src = TRIG_NOW;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_src != TRIG_FOLLOW) {\r\ncmd->scan_begin_src = TRIG_FOLLOW;\r\nerr++;\r\n}\r\nif (cmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_TIMER) {\r\ncmd->convert_src = TRIG_TIMER;\r\nerr++;\r\n}\r\nif (cmd->scan_end_src != TRIG_COUNT) {\r\ncmd->scan_end_src = TRIG_COUNT;\r\nerr++;\r\n}\r\nif (cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_COUNT)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_arg != 0) {\r\ncmd->scan_begin_arg = 0;\r\nerr++;\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (cmd->convert_arg < this_board->ai_ns_min) {\r\ncmd->convert_arg = this_board->ai_ns_min;\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->convert_arg != 0) {\r\ncmd->convert_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (!cmd->stop_arg) {\r\ncmd->stop_arg = 1;\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ntmp = cmd->convert_arg;\r\ni8253_cascade_ns_to_timer(this_board->i8254_osc_base,\r\n&divisor1, &divisor2,\r\n&cmd->convert_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (cmd->convert_arg < this_board->ai_ns_min)\r\ncmd->convert_arg = this_board->ai_ns_min;\r\nif (tmp != cmd->convert_arg)\r\nerr++;\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist) {\r\nif (!check_channel_list(dev, s, cmd->chanlist,\r\ncmd->chanlist_len))\r\nreturn 5;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nunsigned int divisor1 = 0, divisor2 = 0, dma_flags, bytes, dmairq;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int seglen;\r\nif (cmd->start_src != TRIG_NOW)\r\nreturn -EINVAL;\r\nif (cmd->scan_begin_src != TRIG_FOLLOW)\r\nreturn -EINVAL;\r\nif (cmd->scan_end_src != TRIG_COUNT)\r\nreturn -EINVAL;\r\nif (cmd->scan_end_arg != cmd->chanlist_len)\r\nreturn -EINVAL;\r\nif (devpriv->irq_blocked)\r\nreturn -EBUSY;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (cmd->convert_arg < this_board->ai_ns_min)\r\ncmd->convert_arg = this_board->ai_ns_min;\r\ni8253_cascade_ns_to_timer(this_board->i8254_osc_base, &divisor1,\r\n&divisor2, &cmd->convert_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (divisor1 == 1) {\r\ndivisor1 = 2;\r\ndivisor2 /= 2;\r\n}\r\nif (divisor2 == 1) {\r\ndivisor2 = 2;\r\ndivisor1 /= 2;\r\n}\r\n}\r\nstart_pacer(dev, -1, 0, 0);\r\nseglen = check_channel_list(dev, s, cmd->chanlist, cmd->chanlist_len);\r\nif (seglen < 1)\r\nreturn -EINVAL;\r\nsetup_channel_list(dev, s, cmd->chanlist, seglen);\r\nudelay(1);\r\ndevpriv->ai_n_chan = cmd->chanlist_len;\r\ndevpriv->ai_act_scan = 0;\r\ns->async->cur_chan = 0;\r\ndevpriv->irq_blocked = 1;\r\ndevpriv->ai_poll_ptr = 0;\r\ndevpriv->irq_was_now_closed = 0;\r\nif (cmd->stop_src == TRIG_COUNT) {\r\ndevpriv->ai_scans = cmd->stop_arg;\r\ndevpriv->ai_neverending = 0;\r\n} else {\r\ndevpriv->ai_scans = 0;\r\ndevpriv->ai_neverending = 1;\r\n}\r\nif ((cmd->flags & TRIG_WAKE_EOS)) {\r\nprintk(KERN_INFO\r\n"pl816: You wankt WAKE_EOS but I dont want handle it");\r\n}\r\nif (devpriv->dma) {\r\nbytes = devpriv->hwdmasize[0];\r\nif (!devpriv->ai_neverending) {\r\nbytes = s->async->cmd.chanlist_len *\r\ns->async->cmd.chanlist_len *\r\nsizeof(short);\r\ndevpriv->dma_runs_to_end = bytes /\r\ndevpriv->hwdmasize[0];\r\ndevpriv->last_dma_run = bytes % devpriv->hwdmasize[0];\r\ndevpriv->dma_runs_to_end--;\r\nif (devpriv->dma_runs_to_end >= 0)\r\nbytes = devpriv->hwdmasize[0];\r\n} else\r\ndevpriv->dma_runs_to_end = -1;\r\ndevpriv->next_dma_buf = 0;\r\nset_dma_mode(devpriv->dma, DMA_MODE_READ);\r\ndma_flags = claim_dma_lock();\r\nclear_dma_ff(devpriv->dma);\r\nset_dma_addr(devpriv->dma, devpriv->hwdmaptr[0]);\r\nset_dma_count(devpriv->dma, bytes);\r\nrelease_dma_lock(dma_flags);\r\nenable_dma(devpriv->dma);\r\n}\r\nstart_pacer(dev, 1, divisor1, divisor2);\r\ndmairq = ((devpriv->dma & 0x3) << 4) | (dev->irq & 0x7);\r\nswitch (cmd->convert_src) {\r\ncase TRIG_TIMER:\r\ndevpriv->int816_mode = INT_TYPE_AI1_DMA;\r\noutb(0x32, dev->iobase + PCL816_CONTROL);\r\noutb(dmairq, dev->iobase + PCL816_STATUS);\r\nbreak;\r\ndefault:\r\ndevpriv->int816_mode = INT_TYPE_AI3_DMA;\r\noutb(0x34, dev->iobase + PCL816_CONTROL);\r\noutb(dmairq, dev->iobase + PCL816_STATUS);\r\nbreak;\r\n}\r\nDPRINTK("pcl816 END: pcl812_ai_cmd()\n");\r\nreturn 0;\r\n}\r\nstatic int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nunsigned long flags;\r\nunsigned int top1, top2, i;\r\nif (!devpriv->dma)\r\nreturn 0;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nfor (i = 0; i < 20; i++) {\r\ntop1 = get_dma_residue(devpriv->dma);\r\ntop2 = get_dma_residue(devpriv->dma);\r\nif (top1 == top2)\r\nbreak;\r\n}\r\nif (top1 != top2) {\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn 0;\r\n}\r\ntop1 = devpriv->hwdmasize[0] - top1;\r\ntop1 >>= 1;\r\ntop2 = top1 - devpriv->ai_poll_ptr;\r\nif (top2 < 1) {\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn 0;\r\n}\r\ntransfer_from_dma_buf(dev, s,\r\n(short *)devpriv->dmabuf[devpriv->next_dma_buf],\r\ndevpriv->ai_poll_ptr, top2);\r\ndevpriv->ai_poll_ptr = top1;\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn s->async->buf_write_count - s->async->buf_read_count;\r\n}\r\nstatic int pcl816_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nif (devpriv->irq_blocked > 0) {\r\nswitch (devpriv->int816_mode) {\r\n#ifdef unused\r\ncase INT_TYPE_AI1_DMA_RTC:\r\ncase INT_TYPE_AI3_DMA_RTC:\r\nset_rtc_irq_bit(0);\r\ndel_timer(&devpriv->rtc_irq_timer);\r\n#endif\r\ncase INT_TYPE_AI1_DMA:\r\ncase INT_TYPE_AI3_DMA:\r\ndisable_dma(devpriv->dma);\r\ncase INT_TYPE_AI1_INT:\r\ncase INT_TYPE_AI3_INT:\r\noutb(inb(dev->iobase + PCL816_CONTROL) & 0x73,\r\ndev->iobase + PCL816_CONTROL);\r\nudelay(1);\r\noutb(0, dev->iobase + PCL816_CONTROL);\r\noutb(0xb0, dev->iobase + PCL816_CTRCTL);\r\noutb(0x70, dev->iobase + PCL816_CTRCTL);\r\noutb(0, dev->iobase + PCL816_AD_LO);\r\ninb(dev->iobase + PCL816_AD_LO);\r\ninb(dev->iobase + PCL816_AD_HI);\r\noutb(0, dev->iobase + PCL816_CLRINT);\r\noutb(0, dev->iobase + PCL816_CONTROL);\r\ndevpriv->irq_blocked = 0;\r\ndevpriv->irq_was_now_closed = devpriv->int816_mode;\r\ndevpriv->int816_mode = 0;\r\ndevpriv->last_int_sub = s;\r\nbreak;\r\n}\r\n}\r\nDEBUG(printk("comedi: pcl816_ai_cancel() successful\n");)\r\nreturn 0;\r\n}\r\nstatic int pcl816_check(unsigned long iobase)\r\n{\r\noutb(0x00, iobase + PCL816_MUX);\r\nudelay(1);\r\nif (inb(iobase + PCL816_MUX) != 0x00)\r\nreturn 1;\r\noutb(0x55, iobase + PCL816_MUX);\r\nudelay(1);\r\nif (inb(iobase + PCL816_MUX) != 0x55)\r\nreturn 1;\r\noutb(0x00, iobase + PCL816_MUX);\r\nudelay(1);\r\noutb(0x18, iobase + PCL816_CONTROL);\r\nudelay(1);\r\nif (inb(iobase + PCL816_CONTROL) != 0x18)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void pcl816_reset(struct comedi_device *dev)\r\n{\r\noutb(0, dev->iobase + PCL816_CONTROL);\r\noutb(0, dev->iobase + PCL816_MUX);\r\noutb(0, dev->iobase + PCL816_CLRINT);\r\noutb(0xb0, dev->iobase + PCL816_CTRCTL);\r\noutb(0x70, dev->iobase + PCL816_CTRCTL);\r\noutb(0x30, dev->iobase + PCL816_CTRCTL);\r\noutb(0, dev->iobase + PCL816_RANGE);\r\n}\r\nstatic void\r\nstart_pacer(struct comedi_device *dev, int mode, unsigned int divisor1,\r\nunsigned int divisor2)\r\n{\r\noutb(0x32, dev->iobase + PCL816_CTRCTL);\r\noutb(0xff, dev->iobase + PCL816_CTR0);\r\noutb(0x00, dev->iobase + PCL816_CTR0);\r\nudelay(1);\r\noutb(0xb4, dev->iobase + PCL816_CTRCTL);\r\noutb(0x74, dev->iobase + PCL816_CTRCTL);\r\nudelay(1);\r\nif (mode == 1) {\r\nDPRINTK("mode %d, divisor1 %d, divisor2 %d\n", mode, divisor1,\r\ndivisor2);\r\noutb(divisor2 & 0xff, dev->iobase + PCL816_CTR2);\r\noutb((divisor2 >> 8) & 0xff, dev->iobase + PCL816_CTR2);\r\noutb(divisor1 & 0xff, dev->iobase + PCL816_CTR1);\r\noutb((divisor1 >> 8) & 0xff, dev->iobase + PCL816_CTR1);\r\n}\r\n}\r\nstatic int\r\ncheck_channel_list(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, unsigned int *chanlist,\r\nunsigned int chanlen)\r\n{\r\nunsigned int chansegment[16];\r\nunsigned int i, nowmustbechan, seglen, segpos;\r\nif (chanlen < 1) {\r\ncomedi_error(dev, "range/channel list is empty!");\r\nreturn 0;\r\n}\r\nif (chanlen > 1) {\r\nchansegment[0] = chanlist[0];\r\nfor (i = 1, seglen = 1; i < chanlen; i++, seglen++) {\r\nDEBUG(printk(KERN_INFO "%d. %d %d\n", i,\r\nCR_CHAN(chanlist[i]),\r\nCR_RANGE(chanlist[i]));)\r\nif (chanlist[0] == chanlist[i])\r\nbreak;\r\nnowmustbechan =\r\n(CR_CHAN(chansegment[i - 1]) + 1) % chanlen;\r\nif (nowmustbechan != CR_CHAN(chanlist[i])) {\r\nprintk(KERN_WARNING\r\n"comedi%d: pcl816: channel list must "\r\n"be continuous! chanlist[%i]=%d but "\r\n"must be %d or %d!\n", dev->minor,\r\ni, CR_CHAN(chanlist[i]), nowmustbechan,\r\nCR_CHAN(chanlist[0]));\r\nreturn 0;\r\n}\r\nchansegment[i] = chanlist[i];\r\n}\r\nfor (i = 0, segpos = 0; i < chanlen; i++) {\r\nDEBUG(printk("%d %d=%d %d\n",\r\nCR_CHAN(chansegment[i % seglen]),\r\nCR_RANGE(chansegment[i % seglen]),\r\nCR_CHAN(chanlist[i]),\r\nCR_RANGE(chanlist[i]));)\r\nif (chanlist[i] != chansegment[i % seglen]) {\r\nprintk(KERN_WARNING\r\n"comedi%d: pcl816: bad channel or range"\r\n" number! chanlist[%i]=%d,%d,%d and not"\r\n" %d,%d,%d!\n", dev->minor, i,\r\nCR_CHAN(chansegment[i]),\r\nCR_RANGE(chansegment[i]),\r\nCR_AREF(chansegment[i]),\r\nCR_CHAN(chanlist[i % seglen]),\r\nCR_RANGE(chanlist[i % seglen]),\r\nCR_AREF(chansegment[i % seglen]));\r\nreturn 0;\r\n}\r\n}\r\n} else {\r\nseglen = 1;\r\n}\r\nreturn seglen;\r\n}\r\nstatic void\r\nsetup_channel_list(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, unsigned int *chanlist,\r\nunsigned int seglen)\r\n{\r\nunsigned int i;\r\ndevpriv->ai_act_chanlist_len = seglen;\r\ndevpriv->ai_act_chanlist_pos = 0;\r\nfor (i = 0; i < seglen; i++) {\r\ndevpriv->ai_act_chanlist[i] = CR_CHAN(chanlist[i]);\r\noutb(CR_CHAN(chanlist[0]) & 0xf, dev->iobase + PCL816_MUX);\r\noutb(CR_RANGE(chanlist[0]), dev->iobase + PCL816_RANGE);\r\n}\r\nudelay(1);\r\noutb(devpriv->ai_act_chanlist[0] |\r\n(devpriv->ai_act_chanlist[seglen - 1] << 4),\r\ndev->iobase + PCL816_MUX);\r\n}\r\nstatic int set_rtc_irq_bit(unsigned char bit)\r\n{\r\nunsigned char val;\r\nunsigned long flags;\r\nif (bit == 1) {\r\nRTC_timer_lock++;\r\nif (RTC_timer_lock > 1)\r\nreturn 0;\r\n} else {\r\nRTC_timer_lock--;\r\nif (RTC_timer_lock < 0)\r\nRTC_timer_lock = 0;\r\nif (RTC_timer_lock > 0)\r\nreturn 0;\r\n}\r\nsave_flags(flags);\r\ncli();\r\nval = CMOS_READ(RTC_CONTROL);\r\nif (bit)\r\nval |= RTC_PIE;\r\nelse\r\nval &= ~RTC_PIE;\r\nCMOS_WRITE(val, RTC_CONTROL);\r\nCMOS_READ(RTC_INTR_FLAGS);\r\nrestore_flags(flags);\r\nreturn 0;\r\n}\r\nstatic void free_resources(struct comedi_device *dev)\r\n{\r\nif (dev->private) {\r\npcl816_ai_cancel(dev, devpriv->sub_ai);\r\npcl816_reset(dev);\r\nif (devpriv->dma)\r\nfree_dma(devpriv->dma);\r\nif (devpriv->dmabuf[0])\r\nfree_pages(devpriv->dmabuf[0], devpriv->dmapages[0]);\r\nif (devpriv->dmabuf[1])\r\nfree_pages(devpriv->dmabuf[1], devpriv->dmapages[1]);\r\n#ifdef unused\r\nif (devpriv->rtc_irq)\r\nfree_irq(devpriv->rtc_irq, dev);\r\nif ((devpriv->dma_rtc) && (RTC_lock == 1)) {\r\nif (devpriv->rtc_iobase)\r\nrelease_region(devpriv->rtc_iobase,\r\ndevpriv->rtc_iosize);\r\n}\r\n#endif\r\n}\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (dev->iobase)\r\nrelease_region(dev->iobase, this_board->io_range);\r\n}\r\nstatic int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nint ret;\r\nunsigned long iobase;\r\nunsigned int irq, dma;\r\nunsigned long pages;\r\nstruct comedi_subdevice *s;\r\niobase = it->options[0];\r\nprintk("comedi%d: pcl816: board=%s, ioport=0x%03lx", dev->minor,\r\nthis_board->name, iobase);\r\nif (!request_region(iobase, this_board->io_range, "pcl816")) {\r\nprintk("I/O port conflict\n");\r\nreturn -EIO;\r\n}\r\ndev->iobase = iobase;\r\nif (pcl816_check(iobase)) {\r\nprintk(KERN_ERR ", I cann't detect board. FAIL!\n");\r\nreturn -EIO;\r\n}\r\nret = alloc_private(dev, sizeof(struct pcl816_private));\r\nif (ret < 0)\r\nreturn ret;\r\ndev->board_name = this_board->name;\r\nirq = 0;\r\nif (this_board->IRQbits != 0) {\r\nirq = it->options[1];\r\nif (irq) {\r\nif (((1 << irq) & this_board->IRQbits) == 0) {\r\nprintk\r\n(", IRQ %u is out of allowed range, "\r\n"DISABLING IT", irq);\r\nirq = 0;\r\n} else {\r\nif (request_irq\r\n(irq, interrupt_pcl816, 0, "pcl816", dev)) {\r\nprintk\r\n(", unable to allocate IRQ %u, "\r\n"DISABLING IT", irq);\r\nirq = 0;\r\n} else {\r\nprintk(KERN_INFO ", irq=%u", irq);\r\n}\r\n}\r\n}\r\n}\r\ndev->irq = irq;\r\nif (irq)\r\ndevpriv->irq_free = 1;\r\nelse\r\ndevpriv->irq_free = 0;\r\ndevpriv->irq_blocked = 0;\r\ndevpriv->int816_mode = 0;\r\n#ifdef unused\r\ndevpriv->dma_rtc = 0;\r\nif (it->options[2] > 0) {\r\nif (RTC_lock == 0) {\r\nif (!request_region(RTC_PORT(0), RTC_IO_EXTENT,\r\n"pcl816 (RTC)"))\r\ngoto no_rtc;\r\n}\r\ndevpriv->rtc_iobase = RTC_PORT(0);\r\ndevpriv->rtc_iosize = RTC_IO_EXTENT;\r\nRTC_lock++;\r\n#ifdef UNTESTED_CODE\r\nif (!request_irq(RTC_IRQ, interrupt_pcl816_ai_mode13_dma_rtc, 0,\r\n"pcl816 DMA (RTC)", dev)) {\r\ndevpriv->dma_rtc = 1;\r\ndevpriv->rtc_irq = RTC_IRQ;\r\nprintk(", dma_irq=%u", devpriv->rtc_irq);\r\n} else {\r\nRTC_lock--;\r\nif (RTC_lock == 0) {\r\nif (devpriv->rtc_iobase)\r\nrelease_region(devpriv->rtc_iobase,\r\ndevpriv->rtc_iosize);\r\n}\r\ndevpriv->rtc_iobase = 0;\r\ndevpriv->rtc_iosize = 0;\r\n}\r\n#else\r\nprintk("pcl816: RTC code missing");\r\n#endif\r\n}\r\nno_rtc:\r\n#endif\r\ndma = 0;\r\ndevpriv->dma = dma;\r\nif ((devpriv->irq_free == 0) && (devpriv->dma_rtc == 0))\r\ngoto no_dma;\r\nif (this_board->DMAbits != 0) {\r\ndma = it->options[2];\r\nif (dma < 1)\r\ngoto no_dma;\r\nif (((1 << dma) & this_board->DMAbits) == 0) {\r\nprintk(", DMA is out of allowed range, FAIL!\n");\r\nreturn -EINVAL;\r\n}\r\nret = request_dma(dma, "pcl816");\r\nif (ret) {\r\nprintk(KERN_ERR\r\n", unable to allocate DMA %u, FAIL!\n", dma);\r\nreturn -EBUSY;\r\n}\r\ndevpriv->dma = dma;\r\nprintk(KERN_INFO ", dma=%u", dma);\r\npages = 2;\r\ndevpriv->dmabuf[0] = __get_dma_pages(GFP_KERNEL, pages);\r\nif (!devpriv->dmabuf[0]) {\r\nprintk(", unable to allocate DMA buffer, FAIL!\n");\r\nreturn -EBUSY;\r\n}\r\ndevpriv->dmapages[0] = pages;\r\ndevpriv->hwdmaptr[0] = virt_to_bus((void *)devpriv->dmabuf[0]);\r\ndevpriv->hwdmasize[0] = (1 << pages) * PAGE_SIZE;\r\nif (devpriv->dma_rtc == 0) {\r\ndevpriv->dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);\r\nif (!devpriv->dmabuf[1]) {\r\nprintk(KERN_ERR\r\n", unable to allocate DMA buffer, "\r\n"FAIL!\n");\r\nreturn -EBUSY;\r\n}\r\ndevpriv->dmapages[1] = pages;\r\ndevpriv->hwdmaptr[1] =\r\nvirt_to_bus((void *)devpriv->dmabuf[1]);\r\ndevpriv->hwdmasize[1] = (1 << pages) * PAGE_SIZE;\r\n}\r\n}\r\nno_dma:\r\nret = alloc_subdevices(dev, 1);\r\nif (ret < 0)\r\nreturn ret;\r\ns = dev->subdevices + 0;\r\nif (this_board->n_aichan > 0) {\r\ns->type = COMEDI_SUBD_AI;\r\ndevpriv->sub_ai = s;\r\ndev->read_subdev = s;\r\ns->subdev_flags = SDF_READABLE | SDF_CMD_READ;\r\ns->n_chan = this_board->n_aichan;\r\ns->subdev_flags |= SDF_DIFF;\r\ns->maxdata = this_board->ai_maxdata;\r\ns->len_chanlist = this_board->ai_chanlist;\r\ns->range_table = this_board->ai_range_type;\r\ns->cancel = pcl816_ai_cancel;\r\ns->do_cmdtest = pcl816_ai_cmdtest;\r\ns->do_cmd = pcl816_ai_cmd;\r\ns->poll = pcl816_ai_poll;\r\ns->insn_read = pcl816_ai_insn_read;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\n#if 0\r\ncase COMEDI_SUBD_AO:\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND;\r\ns->n_chan = this_board->n_aochan;\r\ns->maxdata = this_board->ao_maxdata;\r\ns->len_chanlist = this_board->ao_chanlist;\r\ns->range_table = this_board->ao_range_type;\r\nbreak;\r\ncase COMEDI_SUBD_DI:\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = this_board->n_dichan;\r\ns->maxdata = 1;\r\ns->len_chanlist = this_board->n_dichan;\r\ns->range_table = &range_digital;\r\nbreak;\r\ncase COMEDI_SUBD_DO:\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = this_board->n_dochan;\r\ns->maxdata = 1;\r\ns->len_chanlist = this_board->n_dochan;\r\ns->range_table = &range_digital;\r\nbreak;\r\n#endif\r\npcl816_reset(dev);\r\nprintk("\n");\r\nreturn 0;\r\n}\r\nstatic int pcl816_detach(struct comedi_device *dev)\r\n{\r\nDEBUG(printk(KERN_INFO "comedi%d: pcl816: remove\n", dev->minor);)\r\nfree_resources(dev);\r\n#ifdef unused\r\nif (devpriv->dma_rtc)\r\nRTC_lock--;\r\n#endif\r\nreturn 0;\r\n}
