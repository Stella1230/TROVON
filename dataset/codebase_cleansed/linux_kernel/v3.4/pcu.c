int\r\nath5k_hw_get_frame_duration(struct ath5k_hw *ah,\r\nint len, struct ieee80211_rate *rate, bool shortpre)\r\n{\r\nint sifs, preamble, plcp_bits, sym_time;\r\nint bitrate, bits, symbols, symbol_bits;\r\nint dur;\r\nif (!ah->ah_bwmode) {\r\n__le16 raw_dur = ieee80211_generic_frame_duration(ah->hw,\r\nNULL, len, rate);\r\ndur = le16_to_cpu(raw_dur);\r\nif (shortpre)\r\ndur -= 96;\r\nreturn dur;\r\n}\r\nbitrate = rate->bitrate;\r\npreamble = AR5K_INIT_OFDM_PREAMPLE_TIME;\r\nplcp_bits = AR5K_INIT_OFDM_PLCP_BITS;\r\nsym_time = AR5K_INIT_OFDM_SYMBOL_TIME;\r\nswitch (ah->ah_bwmode) {\r\ncase AR5K_BWMODE_40MHZ:\r\nsifs = AR5K_INIT_SIFS_TURBO;\r\npreamble = AR5K_INIT_OFDM_PREAMBLE_TIME_MIN;\r\nbreak;\r\ncase AR5K_BWMODE_10MHZ:\r\nsifs = AR5K_INIT_SIFS_HALF_RATE;\r\npreamble *= 2;\r\nsym_time *= 2;\r\nbreak;\r\ncase AR5K_BWMODE_5MHZ:\r\nsifs = AR5K_INIT_SIFS_QUARTER_RATE;\r\npreamble *= 4;\r\nsym_time *= 4;\r\nbreak;\r\ndefault:\r\nsifs = AR5K_INIT_SIFS_DEFAULT_BG;\r\nbreak;\r\n}\r\nbits = plcp_bits + (len << 3);\r\nsymbol_bits = bitrate * sym_time;\r\nsymbols = DIV_ROUND_UP(bits * 10, symbol_bits);\r\ndur = sifs + preamble + (sym_time * symbols);\r\nreturn dur;\r\n}\r\nunsigned int\r\nath5k_hw_get_default_slottime(struct ath5k_hw *ah)\r\n{\r\nstruct ieee80211_channel *channel = ah->ah_current_channel;\r\nunsigned int slot_time;\r\nswitch (ah->ah_bwmode) {\r\ncase AR5K_BWMODE_40MHZ:\r\nslot_time = AR5K_INIT_SLOT_TIME_TURBO;\r\nbreak;\r\ncase AR5K_BWMODE_10MHZ:\r\nslot_time = AR5K_INIT_SLOT_TIME_HALF_RATE;\r\nbreak;\r\ncase AR5K_BWMODE_5MHZ:\r\nslot_time = AR5K_INIT_SLOT_TIME_QUARTER_RATE;\r\nbreak;\r\ncase AR5K_BWMODE_DEFAULT:\r\ndefault:\r\nslot_time = AR5K_INIT_SLOT_TIME_DEFAULT;\r\nif ((channel->hw_value == AR5K_MODE_11B) && !ah->ah_short_slot)\r\nslot_time = AR5K_INIT_SLOT_TIME_B;\r\nbreak;\r\n}\r\nreturn slot_time;\r\n}\r\nunsigned int\r\nath5k_hw_get_default_sifs(struct ath5k_hw *ah)\r\n{\r\nstruct ieee80211_channel *channel = ah->ah_current_channel;\r\nunsigned int sifs;\r\nswitch (ah->ah_bwmode) {\r\ncase AR5K_BWMODE_40MHZ:\r\nsifs = AR5K_INIT_SIFS_TURBO;\r\nbreak;\r\ncase AR5K_BWMODE_10MHZ:\r\nsifs = AR5K_INIT_SIFS_HALF_RATE;\r\nbreak;\r\ncase AR5K_BWMODE_5MHZ:\r\nsifs = AR5K_INIT_SIFS_QUARTER_RATE;\r\nbreak;\r\ncase AR5K_BWMODE_DEFAULT:\r\nsifs = AR5K_INIT_SIFS_DEFAULT_BG;\r\ndefault:\r\nif (channel->band == IEEE80211_BAND_5GHZ)\r\nsifs = AR5K_INIT_SIFS_DEFAULT_A;\r\nbreak;\r\n}\r\nreturn sifs;\r\n}\r\nvoid\r\nath5k_hw_update_mib_counters(struct ath5k_hw *ah)\r\n{\r\nstruct ath5k_statistics *stats = &ah->stats;\r\nstats->ack_fail += ath5k_hw_reg_read(ah, AR5K_ACK_FAIL);\r\nstats->rts_fail += ath5k_hw_reg_read(ah, AR5K_RTS_FAIL);\r\nstats->rts_ok += ath5k_hw_reg_read(ah, AR5K_RTS_OK);\r\nstats->fcs_error += ath5k_hw_reg_read(ah, AR5K_FCS_FAIL);\r\nstats->beacons += ath5k_hw_reg_read(ah, AR5K_BEACON_CNT);\r\n}\r\nstatic inline void\r\nath5k_hw_write_rate_duration(struct ath5k_hw *ah)\r\n{\r\nstruct ieee80211_rate *rate;\r\nunsigned int i;\r\nu8 band = IEEE80211_BAND_2GHZ;\r\nfor (i = 0; i < ah->sbands[band].n_bitrates; i++) {\r\nu32 reg;\r\nu16 tx_time;\r\nif (ah->ah_ack_bitrate_high)\r\nrate = &ah->sbands[band].bitrates[ack_rates_high[i]];\r\nelse if (i < 4)\r\nrate = &ah->sbands[band].bitrates[0];\r\nelse\r\nrate = &ah->sbands[band].bitrates[4];\r\nreg = AR5K_RATE_DUR(rate->hw_value);\r\ntx_time = ath5k_hw_get_frame_duration(ah, 10, rate, false);\r\nath5k_hw_reg_write(ah, tx_time, reg);\r\nif (!(rate->flags & IEEE80211_RATE_SHORT_PREAMBLE))\r\ncontinue;\r\ntx_time = ath5k_hw_get_frame_duration(ah, 10, rate, true);\r\nath5k_hw_reg_write(ah, tx_time,\r\nreg + (AR5K_SET_SHORT_PREAMBLE << 2));\r\n}\r\n}\r\nstatic int\r\nath5k_hw_set_ack_timeout(struct ath5k_hw *ah, unsigned int timeout)\r\n{\r\nif (ath5k_hw_clocktoh(ah, AR5K_REG_MS(0xffffffff, AR5K_TIME_OUT_ACK))\r\n<= timeout)\r\nreturn -EINVAL;\r\nAR5K_REG_WRITE_BITS(ah, AR5K_TIME_OUT, AR5K_TIME_OUT_ACK,\r\nath5k_hw_htoclock(ah, timeout));\r\nreturn 0;\r\n}\r\nstatic int\r\nath5k_hw_set_cts_timeout(struct ath5k_hw *ah, unsigned int timeout)\r\n{\r\nif (ath5k_hw_clocktoh(ah, AR5K_REG_MS(0xffffffff, AR5K_TIME_OUT_CTS))\r\n<= timeout)\r\nreturn -EINVAL;\r\nAR5K_REG_WRITE_BITS(ah, AR5K_TIME_OUT, AR5K_TIME_OUT_CTS,\r\nath5k_hw_htoclock(ah, timeout));\r\nreturn 0;\r\n}\r\nint\r\nath5k_hw_set_lladdr(struct ath5k_hw *ah, const u8 *mac)\r\n{\r\nstruct ath_common *common = ath5k_hw_common(ah);\r\nu32 low_id, high_id;\r\nu32 pcu_reg;\r\nmemcpy(common->macaddr, mac, ETH_ALEN);\r\npcu_reg = ath5k_hw_reg_read(ah, AR5K_STA_ID1) & 0xffff0000;\r\nlow_id = get_unaligned_le32(mac);\r\nhigh_id = get_unaligned_le16(mac + 4);\r\nath5k_hw_reg_write(ah, low_id, AR5K_STA_ID0);\r\nath5k_hw_reg_write(ah, pcu_reg | high_id, AR5K_STA_ID1);\r\nreturn 0;\r\n}\r\nvoid\r\nath5k_hw_set_bssid(struct ath5k_hw *ah)\r\n{\r\nstruct ath_common *common = ath5k_hw_common(ah);\r\nu16 tim_offset = 0;\r\nif (ah->ah_version == AR5K_AR5212)\r\nath_hw_setbssidmask(common);\r\nath5k_hw_reg_write(ah,\r\nget_unaligned_le32(common->curbssid),\r\nAR5K_BSS_ID0);\r\nath5k_hw_reg_write(ah,\r\nget_unaligned_le16(common->curbssid + 4) |\r\n((common->curaid & 0x3fff) << AR5K_BSS_ID1_AID_S),\r\nAR5K_BSS_ID1);\r\nif (common->curaid == 0) {\r\nath5k_hw_disable_pspoll(ah);\r\nreturn;\r\n}\r\nAR5K_REG_WRITE_BITS(ah, AR5K_BEACON, AR5K_BEACON_TIM,\r\ntim_offset ? tim_offset + 4 : 0);\r\nath5k_hw_enable_pspoll(ah, NULL, 0);\r\n}\r\nvoid\r\nath5k_hw_set_bssid_mask(struct ath5k_hw *ah, const u8 *mask)\r\n{\r\nstruct ath_common *common = ath5k_hw_common(ah);\r\nmemcpy(common->bssidmask, mask, ETH_ALEN);\r\nif (ah->ah_version == AR5K_AR5212)\r\nath_hw_setbssidmask(common);\r\n}\r\nvoid\r\nath5k_hw_set_mcast_filter(struct ath5k_hw *ah, u32 filter0, u32 filter1)\r\n{\r\nath5k_hw_reg_write(ah, filter0, AR5K_MCAST_FILTER0);\r\nath5k_hw_reg_write(ah, filter1, AR5K_MCAST_FILTER1);\r\n}\r\nu32\r\nath5k_hw_get_rx_filter(struct ath5k_hw *ah)\r\n{\r\nu32 data, filter = 0;\r\nfilter = ath5k_hw_reg_read(ah, AR5K_RX_FILTER);\r\nif (ah->ah_version == AR5K_AR5212) {\r\ndata = ath5k_hw_reg_read(ah, AR5K_PHY_ERR_FIL);\r\nif (data & AR5K_PHY_ERR_FIL_RADAR)\r\nfilter |= AR5K_RX_FILTER_RADARERR;\r\nif (data & (AR5K_PHY_ERR_FIL_OFDM | AR5K_PHY_ERR_FIL_CCK))\r\nfilter |= AR5K_RX_FILTER_PHYERR;\r\n}\r\nreturn filter;\r\n}\r\nvoid\r\nath5k_hw_set_rx_filter(struct ath5k_hw *ah, u32 filter)\r\n{\r\nu32 data = 0;\r\nif (ah->ah_version == AR5K_AR5212) {\r\nif (filter & AR5K_RX_FILTER_RADARERR)\r\ndata |= AR5K_PHY_ERR_FIL_RADAR;\r\nif (filter & AR5K_RX_FILTER_PHYERR)\r\ndata |= AR5K_PHY_ERR_FIL_OFDM | AR5K_PHY_ERR_FIL_CCK;\r\n}\r\nif (ah->ah_version == AR5K_AR5210 &&\r\n(filter & AR5K_RX_FILTER_RADARERR)) {\r\nfilter &= ~AR5K_RX_FILTER_RADARERR;\r\nfilter |= AR5K_RX_FILTER_PROM;\r\n}\r\nif (data)\r\nAR5K_REG_ENABLE_BITS(ah, AR5K_RXCFG, AR5K_RXCFG_ZLFDMA);\r\nelse\r\nAR5K_REG_DISABLE_BITS(ah, AR5K_RXCFG, AR5K_RXCFG_ZLFDMA);\r\nath5k_hw_reg_write(ah, filter & 0xff, AR5K_RX_FILTER);\r\nif (ah->ah_version == AR5K_AR5212)\r\nath5k_hw_reg_write(ah, data, AR5K_PHY_ERR_FIL);\r\n}\r\nu64\r\nath5k_hw_get_tsf64(struct ath5k_hw *ah)\r\n{\r\nu32 tsf_lower, tsf_upper1, tsf_upper2;\r\nint i;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\ntsf_upper1 = ath5k_hw_reg_read(ah, AR5K_TSF_U32);\r\nfor (i = 0; i < ATH5K_MAX_TSF_READ; i++) {\r\ntsf_lower = ath5k_hw_reg_read(ah, AR5K_TSF_L32);\r\ntsf_upper2 = ath5k_hw_reg_read(ah, AR5K_TSF_U32);\r\nif (tsf_upper2 == tsf_upper1)\r\nbreak;\r\ntsf_upper1 = tsf_upper2;\r\n}\r\nlocal_irq_restore(flags);\r\nWARN_ON(i == ATH5K_MAX_TSF_READ);\r\nreturn ((u64)tsf_upper1 << 32) | tsf_lower;\r\n}\r\nvoid\r\nath5k_hw_set_tsf64(struct ath5k_hw *ah, u64 tsf64)\r\n{\r\nath5k_hw_reg_write(ah, tsf64 & 0xffffffff, AR5K_TSF_L32);\r\nath5k_hw_reg_write(ah, (tsf64 >> 32) & 0xffffffff, AR5K_TSF_U32);\r\n}\r\nvoid\r\nath5k_hw_reset_tsf(struct ath5k_hw *ah)\r\n{\r\nu32 val;\r\nval = ath5k_hw_reg_read(ah, AR5K_BEACON) | AR5K_BEACON_RESET_TSF;\r\nath5k_hw_reg_write(ah, val, AR5K_BEACON);\r\nath5k_hw_reg_write(ah, val, AR5K_BEACON);\r\n}\r\nvoid\r\nath5k_hw_init_beacon_timers(struct ath5k_hw *ah, u32 next_beacon, u32 interval)\r\n{\r\nu32 timer1, timer2, timer3;\r\nswitch (ah->opmode) {\r\ncase NL80211_IFTYPE_MONITOR:\r\ncase NL80211_IFTYPE_STATION:\r\nif (ah->ah_version == AR5K_AR5210) {\r\ntimer1 = 0xffffffff;\r\ntimer2 = 0xffffffff;\r\n} else {\r\ntimer1 = 0x0000ffff;\r\ntimer2 = 0x0007ffff;\r\n}\r\nAR5K_REG_DISABLE_BITS(ah, AR5K_STA_ID1, AR5K_STA_ID1_PCF);\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nAR5K_REG_ENABLE_BITS(ah, AR5K_TXCFG, AR5K_TXCFG_ADHOC_BCN_ATIM);\r\ndefault:\r\ntimer1 = (next_beacon - AR5K_TUNE_DMA_BEACON_RESP) << 3;\r\ntimer2 = (next_beacon - AR5K_TUNE_SW_BEACON_RESP) << 3;\r\nbreak;\r\n}\r\ntimer3 = next_beacon + 1;\r\nif (ah->opmode == NL80211_IFTYPE_AP ||\r\nah->opmode == NL80211_IFTYPE_MESH_POINT)\r\nath5k_hw_reg_write(ah, 0, AR5K_TIMER0);\r\nath5k_hw_reg_write(ah, next_beacon, AR5K_TIMER0);\r\nath5k_hw_reg_write(ah, timer1, AR5K_TIMER1);\r\nath5k_hw_reg_write(ah, timer2, AR5K_TIMER2);\r\nath5k_hw_reg_write(ah, timer3, AR5K_TIMER3);\r\nif (interval & AR5K_BEACON_RESET_TSF)\r\nath5k_hw_reset_tsf(ah);\r\nath5k_hw_reg_write(ah, interval & (AR5K_BEACON_PERIOD |\r\nAR5K_BEACON_ENABLE),\r\nAR5K_BEACON);\r\nif (ah->ah_version == AR5K_AR5210)\r\nath5k_hw_reg_write(ah, AR5K_ISR_BMISS, AR5K_ISR);\r\nelse\r\nath5k_hw_reg_write(ah, AR5K_ISR_BMISS, AR5K_PISR);\r\nAR5K_REG_DISABLE_BITS(ah, AR5K_STA_ID1, AR5K_STA_ID1_PWR_SV);\r\n}\r\nstatic inline bool\r\nath5k_check_timer_win(int a, int b, int window, int intval)\r\n{\r\nif ((b - a == window) ||\r\n(a - b == intval - window) ||\r\n((a | 0x10000) - b == intval - window) ||\r\n((b | 0x10000) - a == window))\r\nreturn true;\r\nreturn false;\r\n}\r\nbool\r\nath5k_hw_check_beacon_timers(struct ath5k_hw *ah, int intval)\r\n{\r\nunsigned int nbtt, atim, dma;\r\nnbtt = ath5k_hw_reg_read(ah, AR5K_TIMER0);\r\natim = ath5k_hw_reg_read(ah, AR5K_TIMER3);\r\ndma = ath5k_hw_reg_read(ah, AR5K_TIMER1) >> 3;\r\nif (ath5k_check_timer_win(nbtt, atim, 1, intval) &&\r\nath5k_check_timer_win(dma, nbtt, AR5K_TUNE_DMA_BEACON_RESP,\r\nintval))\r\nreturn true;\r\nreturn false;\r\n}\r\nvoid\r\nath5k_hw_set_coverage_class(struct ath5k_hw *ah, u8 coverage_class)\r\n{\r\nint slot_time = ath5k_hw_get_default_slottime(ah) + 3 * coverage_class;\r\nint ack_timeout = ath5k_hw_get_default_sifs(ah) + slot_time;\r\nint cts_timeout = ack_timeout;\r\nath5k_hw_set_ifs_intervals(ah, slot_time);\r\nath5k_hw_set_ack_timeout(ah, ack_timeout);\r\nath5k_hw_set_cts_timeout(ah, cts_timeout);\r\nah->ah_coverage_class = coverage_class;\r\n}\r\nvoid\r\nath5k_hw_start_rx_pcu(struct ath5k_hw *ah)\r\n{\r\nAR5K_REG_DISABLE_BITS(ah, AR5K_DIAG_SW, AR5K_DIAG_SW_DIS_RX);\r\n}\r\nvoid\r\nath5k_hw_stop_rx_pcu(struct ath5k_hw *ah)\r\n{\r\nAR5K_REG_ENABLE_BITS(ah, AR5K_DIAG_SW, AR5K_DIAG_SW_DIS_RX);\r\n}\r\nint\r\nath5k_hw_set_opmode(struct ath5k_hw *ah, enum nl80211_iftype op_mode)\r\n{\r\nstruct ath_common *common = ath5k_hw_common(ah);\r\nu32 pcu_reg, beacon_reg, low_id, high_id;\r\nATH5K_DBG(ah, ATH5K_DEBUG_MODE, "mode %d\n", op_mode);\r\npcu_reg = ath5k_hw_reg_read(ah, AR5K_STA_ID1) & 0xffff0000;\r\npcu_reg &= ~(AR5K_STA_ID1_ADHOC | AR5K_STA_ID1_AP\r\n| AR5K_STA_ID1_KEYSRCH_MODE\r\n| (ah->ah_version == AR5K_AR5210 ?\r\n(AR5K_STA_ID1_PWR_SV | AR5K_STA_ID1_NO_PSPOLL) : 0));\r\nbeacon_reg = 0;\r\nswitch (op_mode) {\r\ncase NL80211_IFTYPE_ADHOC:\r\npcu_reg |= AR5K_STA_ID1_ADHOC | AR5K_STA_ID1_KEYSRCH_MODE;\r\nbeacon_reg |= AR5K_BCR_ADHOC;\r\nif (ah->ah_version == AR5K_AR5210)\r\npcu_reg |= AR5K_STA_ID1_NO_PSPOLL;\r\nelse\r\nAR5K_REG_ENABLE_BITS(ah, AR5K_CFG, AR5K_CFG_IBSS);\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\ncase NL80211_IFTYPE_MESH_POINT:\r\npcu_reg |= AR5K_STA_ID1_AP | AR5K_STA_ID1_KEYSRCH_MODE;\r\nbeacon_reg |= AR5K_BCR_AP;\r\nif (ah->ah_version == AR5K_AR5210)\r\npcu_reg |= AR5K_STA_ID1_NO_PSPOLL;\r\nelse\r\nAR5K_REG_DISABLE_BITS(ah, AR5K_CFG, AR5K_CFG_IBSS);\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\npcu_reg |= AR5K_STA_ID1_KEYSRCH_MODE\r\n| (ah->ah_version == AR5K_AR5210 ?\r\nAR5K_STA_ID1_PWR_SV : 0);\r\ncase NL80211_IFTYPE_MONITOR:\r\npcu_reg |= AR5K_STA_ID1_KEYSRCH_MODE\r\n| (ah->ah_version == AR5K_AR5210 ?\r\nAR5K_STA_ID1_NO_PSPOLL : 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nlow_id = get_unaligned_le32(common->macaddr);\r\nhigh_id = get_unaligned_le16(common->macaddr + 4);\r\nath5k_hw_reg_write(ah, low_id, AR5K_STA_ID0);\r\nath5k_hw_reg_write(ah, pcu_reg | high_id, AR5K_STA_ID1);\r\nif (ah->ah_version == AR5K_AR5210)\r\nath5k_hw_reg_write(ah, beacon_reg, AR5K_BCR);\r\nreturn 0;\r\n}\r\nvoid\r\nath5k_hw_pcu_init(struct ath5k_hw *ah, enum nl80211_iftype op_mode)\r\n{\r\nath5k_hw_set_bssid(ah);\r\nath5k_hw_set_opmode(ah, op_mode);\r\nif (ah->ah_version == AR5K_AR5212 &&\r\nah->nvifs)\r\nath5k_hw_write_rate_duration(ah);\r\nath5k_hw_reg_write(ah, (AR5K_TUNE_RSSI_THRES |\r\nAR5K_TUNE_BMISS_THRES <<\r\nAR5K_RSSI_THR_BMISS_S),\r\nAR5K_RSSI_THR);\r\nif (ah->ah_mac_srev >= AR5K_SREV_AR2413) {\r\nath5k_hw_reg_write(ah, 0x000100aa, AR5K_MIC_QOS_CTL);\r\nath5k_hw_reg_write(ah, 0x00003210, AR5K_MIC_QOS_SEL);\r\n}\r\nif (ah->ah_version == AR5K_AR5212) {\r\nath5k_hw_reg_write(ah,\r\nAR5K_REG_SM(2, AR5K_QOS_NOACK_2BIT_VALUES) |\r\nAR5K_REG_SM(5, AR5K_QOS_NOACK_BIT_OFFSET) |\r\nAR5K_REG_SM(0, AR5K_QOS_NOACK_BYTE_OFFSET),\r\nAR5K_QOS_NOACK);\r\n}\r\nif (ah->ah_coverage_class > 0)\r\nath5k_hw_set_coverage_class(ah, ah->ah_coverage_class);\r\nif (ah->ah_version == AR5K_AR5212) {\r\nu32 val = AR5K_STA_ID1_BASE_RATE_11B | AR5K_STA_ID1_ACKCTS_6MB;\r\nif (ah->ah_ack_bitrate_high)\r\nAR5K_REG_DISABLE_BITS(ah, AR5K_STA_ID1, val);\r\nelse\r\nAR5K_REG_ENABLE_BITS(ah, AR5K_STA_ID1, val);\r\n}\r\nreturn;\r\n}
