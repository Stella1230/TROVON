static void bit_via_setscl(void *data, int state)\r\n{\r\noutb(state ? inb(I2C_DIR) & ~I2C_SCL : inb(I2C_DIR) | I2C_SCL, I2C_DIR);\r\n}\r\nstatic void bit_via_setsda(void *data, int state)\r\n{\r\noutb(state ? inb(I2C_DIR) & ~I2C_SDA : inb(I2C_DIR) | I2C_SDA, I2C_DIR);\r\n}\r\nstatic int bit_via_getscl(void *data)\r\n{\r\nreturn (0 != (inb(I2C_IN) & I2C_SCL));\r\n}\r\nstatic int bit_via_getsda(void *data)\r\n{\r\nreturn (0 != (inb(I2C_IN) & I2C_SDA));\r\n}\r\nstatic int __devinit vt586b_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nu16 base;\r\nu8 rev;\r\nint res;\r\nif (pm_io_base) {\r\ndev_err(&dev->dev, "i2c-via: Will only support one host\n");\r\nreturn -ENODEV;\r\n}\r\npci_read_config_byte(dev, PM_CFG_REVID, &rev);\r\nswitch (rev) {\r\ncase 0x00:\r\nbase = PM_CFG_IOBASE0;\r\nbreak;\r\ncase 0x01:\r\ncase 0x10:\r\nbase = PM_CFG_IOBASE1;\r\nbreak;\r\ndefault:\r\nbase = PM_CFG_IOBASE1;\r\n}\r\npci_read_config_word(dev, base, &pm_io_base);\r\npm_io_base &= (0xff << 8);\r\nif (!request_region(I2C_DIR, IOSPACE, vt586b_driver.name)) {\r\ndev_err(&dev->dev, "IO 0x%x-0x%x already in use\n", I2C_DIR, I2C_DIR + IOSPACE);\r\nreturn -ENODEV;\r\n}\r\noutb(inb(I2C_DIR) & ~(I2C_SDA | I2C_SCL), I2C_DIR);\r\noutb(inb(I2C_OUT) & ~(I2C_SDA | I2C_SCL), I2C_OUT);\r\nvt586b_adapter.dev.parent = &dev->dev;\r\nres = i2c_bit_add_bus(&vt586b_adapter);\r\nif ( res < 0 ) {\r\nrelease_region(I2C_DIR, IOSPACE);\r\npm_io_base = 0;\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __devexit vt586b_remove(struct pci_dev *dev)\r\n{\r\ni2c_del_adapter(&vt586b_adapter);\r\nrelease_region(I2C_DIR, IOSPACE);\r\npm_io_base = 0;\r\n}\r\nstatic int __init i2c_vt586b_init(void)\r\n{\r\nreturn pci_register_driver(&vt586b_driver);\r\n}\r\nstatic void __exit i2c_vt586b_exit(void)\r\n{\r\npci_unregister_driver(&vt586b_driver);\r\n}
