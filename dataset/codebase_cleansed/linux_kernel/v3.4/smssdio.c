static int smssdio_sendrequest(void *context, void *buffer, size_t size)\r\n{\r\nint ret = 0;\r\nstruct smssdio_device *smsdev;\r\nsmsdev = context;\r\nsdio_claim_host(smsdev->func);\r\nwhile (size >= smsdev->func->cur_blksize) {\r\nret = sdio_memcpy_toio(smsdev->func, SMSSDIO_DATA,\r\nbuffer, smsdev->func->cur_blksize);\r\nif (ret)\r\ngoto out;\r\nbuffer += smsdev->func->cur_blksize;\r\nsize -= smsdev->func->cur_blksize;\r\n}\r\nif (size) {\r\nret = sdio_memcpy_toio(smsdev->func, SMSSDIO_DATA,\r\nbuffer, size);\r\n}\r\nout:\r\nsdio_release_host(smsdev->func);\r\nreturn ret;\r\n}\r\nstatic void smssdio_interrupt(struct sdio_func *func)\r\n{\r\nint ret, isr;\r\nstruct smssdio_device *smsdev;\r\nstruct smscore_buffer_t *cb;\r\nstruct SmsMsgHdr_ST *hdr;\r\nsize_t size;\r\nsmsdev = sdio_get_drvdata(func);\r\nisr = sdio_readb(func, SMSSDIO_INT, &ret);\r\nif (ret) {\r\nsms_err("Unable to read interrupt register!\n");\r\nreturn;\r\n}\r\nif (smsdev->split_cb == NULL) {\r\ncb = smscore_getbuffer(smsdev->coredev);\r\nif (!cb) {\r\nsms_err("Unable to allocate data buffer!\n");\r\nreturn;\r\n}\r\nret = sdio_memcpy_fromio(smsdev->func,\r\ncb->p,\r\nSMSSDIO_DATA,\r\nSMSSDIO_BLOCK_SIZE);\r\nif (ret) {\r\nsms_err("Error %d reading initial block!\n", ret);\r\nreturn;\r\n}\r\nhdr = cb->p;\r\nif (hdr->msgFlags & MSG_HDR_FLAG_SPLIT_MSG) {\r\nsmsdev->split_cb = cb;\r\nreturn;\r\n}\r\nif (hdr->msgLength > smsdev->func->cur_blksize)\r\nsize = hdr->msgLength - smsdev->func->cur_blksize;\r\nelse\r\nsize = 0;\r\n} else {\r\ncb = smsdev->split_cb;\r\nhdr = cb->p;\r\nsize = hdr->msgLength - sizeof(struct SmsMsgHdr_ST);\r\nsmsdev->split_cb = NULL;\r\n}\r\nif (size) {\r\nvoid *buffer;\r\nbuffer = cb->p + (hdr->msgLength - size);\r\nsize = ALIGN(size, SMSSDIO_BLOCK_SIZE);\r\nBUG_ON(smsdev->func->cur_blksize != SMSSDIO_BLOCK_SIZE);\r\nret = sdio_memcpy_fromio(smsdev->func,\r\nbuffer,\r\nSMSSDIO_DATA,\r\nsize);\r\nif (ret && ret != -EINVAL) {\r\nsmscore_putbuffer(smsdev->coredev, cb);\r\nsms_err("Error %d reading data from card!\n", ret);\r\nreturn;\r\n}\r\nif (ret == -EINVAL) {\r\nwhile (size) {\r\nret = sdio_memcpy_fromio(smsdev->func,\r\nbuffer, SMSSDIO_DATA,\r\nsmsdev->func->cur_blksize);\r\nif (ret) {\r\nsmscore_putbuffer(smsdev->coredev, cb);\r\nsms_err("Error %d reading "\r\n"data from card!\n", ret);\r\nreturn;\r\n}\r\nbuffer += smsdev->func->cur_blksize;\r\nif (size > smsdev->func->cur_blksize)\r\nsize -= smsdev->func->cur_blksize;\r\nelse\r\nsize = 0;\r\n}\r\n}\r\n}\r\ncb->size = hdr->msgLength;\r\ncb->offset = 0;\r\nsmscore_onresponse(smsdev->coredev, cb);\r\n}\r\nstatic int __devinit smssdio_probe(struct sdio_func *func,\r\nconst struct sdio_device_id *id)\r\n{\r\nint ret;\r\nint board_id;\r\nstruct smssdio_device *smsdev;\r\nstruct smsdevice_params_t params;\r\nboard_id = id->driver_data;\r\nsmsdev = kzalloc(sizeof(struct smssdio_device), GFP_KERNEL);\r\nif (!smsdev)\r\nreturn -ENOMEM;\r\nsmsdev->func = func;\r\nmemset(&params, 0, sizeof(struct smsdevice_params_t));\r\nparams.device = &func->dev;\r\nparams.buffer_size = 0x5000;\r\nparams.num_buffers = 22;\r\nparams.context = smsdev;\r\nsnprintf(params.devpath, sizeof(params.devpath),\r\n"sdio\\%s", sdio_func_id(func));\r\nparams.sendrequest_handler = smssdio_sendrequest;\r\nparams.device_type = sms_get_board(board_id)->type;\r\nif (params.device_type != SMS_STELLAR)\r\nparams.flags |= SMS_DEVICE_FAMILY2;\r\nelse {\r\nret = -ENODEV;\r\ngoto free;\r\n}\r\nret = smscore_register_device(&params, &smsdev->coredev);\r\nif (ret < 0)\r\ngoto free;\r\nsmscore_set_board_id(smsdev->coredev, board_id);\r\nsdio_claim_host(func);\r\nret = sdio_enable_func(func);\r\nif (ret)\r\ngoto release;\r\nret = sdio_set_block_size(func, SMSSDIO_BLOCK_SIZE);\r\nif (ret)\r\ngoto disable;\r\nret = sdio_claim_irq(func, smssdio_interrupt);\r\nif (ret)\r\ngoto disable;\r\nsdio_set_drvdata(func, smsdev);\r\nsdio_release_host(func);\r\nret = smscore_start_device(smsdev->coredev);\r\nif (ret < 0)\r\ngoto reclaim;\r\nreturn 0;\r\nreclaim:\r\nsdio_claim_host(func);\r\nsdio_release_irq(func);\r\ndisable:\r\nsdio_disable_func(func);\r\nrelease:\r\nsdio_release_host(func);\r\nsmscore_unregister_device(smsdev->coredev);\r\nfree:\r\nkfree(smsdev);\r\nreturn ret;\r\n}\r\nstatic void smssdio_remove(struct sdio_func *func)\r\n{\r\nstruct smssdio_device *smsdev;\r\nsmsdev = sdio_get_drvdata(func);\r\nif (smsdev->split_cb)\r\nsmscore_putbuffer(smsdev->coredev, smsdev->split_cb);\r\nsmscore_unregister_device(smsdev->coredev);\r\nsdio_claim_host(func);\r\nsdio_release_irq(func);\r\nsdio_disable_func(func);\r\nsdio_release_host(func);\r\nkfree(smsdev);\r\n}\r\nstatic int __init smssdio_module_init(void)\r\n{\r\nint ret = 0;\r\nprintk(KERN_INFO "smssdio: Siano SMS1xxx SDIO driver\n");\r\nprintk(KERN_INFO "smssdio: Copyright Pierre Ossman\n");\r\nret = sdio_register_driver(&smssdio_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit smssdio_module_exit(void)\r\n{\r\nsdio_unregister_driver(&smssdio_driver);\r\n}
