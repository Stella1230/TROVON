static u32 nof_pixels_dx(struct dum_ch_setup *ch_setup)\r\n{\r\nreturn (ch_setup->xmax - ch_setup->xmin + 1);\r\n}\r\nstatic u32 nof_pixels_dy(struct dum_ch_setup *ch_setup)\r\n{\r\nreturn (ch_setup->ymax - ch_setup->ymin + 1);\r\n}\r\nstatic u32 nof_pixels_dxy(struct dum_ch_setup *ch_setup)\r\n{\r\nreturn (nof_pixels_dx(ch_setup) * nof_pixels_dy(ch_setup));\r\n}\r\nstatic u32 nof_bytes(struct dum_ch_setup *ch_setup)\r\n{\r\nu32 r = nof_pixels_dxy(ch_setup);\r\nswitch (ch_setup->format) {\r\ncase RGB888:\r\ncase RGB666:\r\nr *= 4;\r\nbreak;\r\ndefault:\r\nr *= 2;\r\nbreak;\r\n}\r\nreturn r;\r\n}\r\nstatic u32 build_command(int disp_no, u32 reg, u32 val)\r\n{\r\nreturn ((disp_no << 26) | BIT(25) | (val << 16) | (disp_no << 10) |\r\n(reg << 0));\r\n}\r\nstatic u32 build_double_index(int disp_no, u32 val)\r\n{\r\nreturn ((disp_no << 26) | (val << 16) | (disp_no << 10) | (val << 0));\r\n}\r\nstatic void build_disp_window(struct dum_ch_setup * ch_setup, struct disp_window * dw)\r\n{\r\ndw->ymin = ch_setup->ymin;\r\ndw->ymax = ch_setup->ymax;\r\ndw->xmin_l = ch_setup->xmin & 0xFF;\r\ndw->xmin_h = (ch_setup->xmin & BIT(8)) >> 8;\r\ndw->xmax_l = ch_setup->xmax & 0xFF;\r\ndw->xmax_h = (ch_setup->xmax & BIT(8)) >> 8;\r\n}\r\nstatic int put_channel(struct dumchannel chan)\r\n{\r\nint i = chan.channelnr;\r\nif (i < 0 || i > MAX_DUM_CHANNELS)\r\nreturn -EINVAL;\r\nelse {\r\nDUM_CH_MIN(i) = chan.dum_ch_min;\r\nDUM_CH_MAX(i) = chan.dum_ch_max;\r\nDUM_CH_CONF(i) = chan.dum_ch_conf;\r\nDUM_CH_CTRL(i) = chan.dum_ch_ctrl;\r\n}\r\nreturn 0;\r\n}\r\nstatic void clear_channel(int channr)\r\n{\r\nstruct dumchannel chan;\r\nchan.channelnr = channr;\r\nchan.dum_ch_min = 0;\r\nchan.dum_ch_max = 0;\r\nchan.dum_ch_conf = 0;\r\nchan.dum_ch_ctrl = 0;\r\nput_channel(chan);\r\n}\r\nstatic int put_cmd_string(struct cmdstring cmds)\r\n{\r\nu16 *cmd_str_virtaddr;\r\nu32 *cmd_ptr0_virtaddr;\r\nu32 cmd_str_physaddr;\r\nint i = cmds.channelnr;\r\nif (i < 0 || i > MAX_DUM_CHANNELS)\r\nreturn -EINVAL;\r\nelse if ((cmd_ptr0_virtaddr =\r\n(int *)ioremap_nocache(DUM_COM_BASE,\r\nsizeof(int) * MAX_DUM_CHANNELS)) ==\r\nNULL)\r\nreturn -EIOREMAPFAILED;\r\nelse {\r\ncmd_str_physaddr = ioread32(&cmd_ptr0_virtaddr[cmds.channelnr]);\r\nif ((cmd_str_virtaddr =\r\n(u16 *) ioremap_nocache(cmd_str_physaddr,\r\nsizeof(cmds))) == NULL) {\r\niounmap(cmd_ptr0_virtaddr);\r\nreturn -EIOREMAPFAILED;\r\n} else {\r\nint t;\r\nfor (t = 0; t < 8; t++)\r\niowrite16(*((u16 *)&cmds.prestringlen + t),\r\ncmd_str_virtaddr + t);\r\nfor (t = 0; t < cmds.prestringlen / 2; t++)\r\niowrite16(*((u16 *)&cmds.precmd + t),\r\ncmd_str_virtaddr + t + 8);\r\nfor (t = 0; t < cmds.poststringlen / 2; t++)\r\niowrite16(*((u16 *)&cmds.postcmd + t),\r\ncmd_str_virtaddr + t + 8 +\r\ncmds.prestringlen / 2);\r\niounmap(cmd_ptr0_virtaddr);\r\niounmap(cmd_str_virtaddr);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 dum_ch_setup(int ch_no, struct dum_ch_setup * ch_setup)\r\n{\r\nstruct cmdstring cmds_c;\r\nstruct cmdstring *cmds = &cmds_c;\r\nstruct disp_window dw;\r\nint standard;\r\nu32 orientation = 0;\r\nstruct dumchannel chan = { 0 };\r\nint ret;\r\nif ((ch_setup->xmirror) || (ch_setup->ymirror) || (ch_setup->rotate)) {\r\nstandard = 0;\r\norientation = BIT(1);\r\nif (ch_setup->xmirror)\r\norientation |= BIT(4);\r\nif (ch_setup->ymirror)\r\norientation |= BIT(3);\r\nif (ch_setup->rotate)\r\norientation |= BIT(0);\r\n} else\r\nstandard = 1;\r\ncmds->channelnr = ch_no;\r\nif (standard) {\r\ncmds->prestringlen = 32;\r\ncmds->poststringlen = 0;\r\n} else {\r\ncmds->prestringlen = 48;\r\ncmds->poststringlen = 16;\r\n}\r\ncmds->format =\r\n(u16) ((ch_setup->disp_no << 4) | (BIT(3)) | (ch_setup->format));\r\ncmds->reserved = 0x0;\r\ncmds->startaddr_low = (ch_setup->minadr & 0xFFFF);\r\ncmds->startaddr_high = (ch_setup->minadr >> 16);\r\nif ((ch_setup->minadr == 0) && (ch_setup->maxadr == 0)\r\n&& (ch_setup->xmin == 0)\r\n&& (ch_setup->ymin == 0) && (ch_setup->xmax == 0)\r\n&& (ch_setup->ymax == 0)) {\r\ncmds->pixdatlen_low = 0;\r\ncmds->pixdatlen_high = 0;\r\n} else {\r\nu32 nbytes = nof_bytes(ch_setup);\r\ncmds->pixdatlen_low = (nbytes & 0xFFFF);\r\ncmds->pixdatlen_high = (nbytes >> 16);\r\n}\r\nif (ch_setup->slave_trans)\r\ncmds->pixdatlen_high |= BIT(15);\r\nbuild_disp_window(ch_setup, &dw);\r\nif (standard) {\r\ncmds->precmd[0] =\r\nbuild_command(ch_setup->disp_no, DISP_XMIN_L_REG, 0x99);\r\ncmds->precmd[1] =\r\nbuild_command(ch_setup->disp_no, DISP_XMIN_L_REG,\r\ndw.xmin_l);\r\ncmds->precmd[2] =\r\nbuild_command(ch_setup->disp_no, DISP_XMIN_H_REG,\r\ndw.xmin_h);\r\ncmds->precmd[3] =\r\nbuild_command(ch_setup->disp_no, DISP_YMIN_REG, dw.ymin);\r\ncmds->precmd[4] =\r\nbuild_command(ch_setup->disp_no, DISP_XMAX_L_REG,\r\ndw.xmax_l);\r\ncmds->precmd[5] =\r\nbuild_command(ch_setup->disp_no, DISP_XMAX_H_REG,\r\ndw.xmax_h);\r\ncmds->precmd[6] =\r\nbuild_command(ch_setup->disp_no, DISP_YMAX_REG, dw.ymax);\r\ncmds->precmd[7] =\r\nbuild_double_index(ch_setup->disp_no, DISP_PIXEL_REG);\r\n} else {\r\nif (dw.xmin_l == ch_no)\r\ncmds->precmd[0] =\r\nbuild_command(ch_setup->disp_no, DISP_XMIN_L_REG,\r\n0x99);\r\nelse\r\ncmds->precmd[0] =\r\nbuild_command(ch_setup->disp_no, DISP_XMIN_L_REG,\r\nch_no);\r\ncmds->precmd[1] =\r\nbuild_command(ch_setup->disp_no, DISP_XMIN_L_REG,\r\ndw.xmin_l);\r\ncmds->precmd[2] =\r\nbuild_command(ch_setup->disp_no, DISP_XMIN_H_REG,\r\ndw.xmin_h);\r\ncmds->precmd[3] =\r\nbuild_command(ch_setup->disp_no, DISP_YMIN_REG, dw.ymin);\r\ncmds->precmd[4] =\r\nbuild_command(ch_setup->disp_no, DISP_XMAX_L_REG,\r\ndw.xmax_l);\r\ncmds->precmd[5] =\r\nbuild_command(ch_setup->disp_no, DISP_XMAX_H_REG,\r\ndw.xmax_h);\r\ncmds->precmd[6] =\r\nbuild_command(ch_setup->disp_no, DISP_YMAX_REG, dw.ymax);\r\ncmds->precmd[7] =\r\nbuild_command(ch_setup->disp_no, DISP_1_REG, orientation);\r\ncmds->precmd[8] =\r\nbuild_double_index(ch_setup->disp_no, DISP_PIXEL_REG);\r\ncmds->precmd[9] =\r\nbuild_double_index(ch_setup->disp_no, DISP_PIXEL_REG);\r\ncmds->precmd[0xA] =\r\nbuild_double_index(ch_setup->disp_no, DISP_PIXEL_REG);\r\ncmds->precmd[0xB] =\r\nbuild_double_index(ch_setup->disp_no, DISP_PIXEL_REG);\r\ncmds->postcmd[0] =\r\nbuild_command(ch_setup->disp_no, DISP_1_REG, BIT(1));\r\ncmds->postcmd[1] =\r\nbuild_command(ch_setup->disp_no, DISP_DUMMY1_REG, 1);\r\ncmds->postcmd[2] =\r\nbuild_command(ch_setup->disp_no, DISP_DUMMY1_REG, 2);\r\ncmds->postcmd[3] =\r\nbuild_command(ch_setup->disp_no, DISP_DUMMY1_REG, 3);\r\n}\r\nif ((ret = put_cmd_string(cmds_c)) != 0) {\r\nreturn ret;\r\n}\r\nchan.channelnr = cmds->channelnr;\r\nchan.dum_ch_min = ch_setup->dirtybuffer + ch_setup->minadr;\r\nchan.dum_ch_max = ch_setup->dirtybuffer + ch_setup->maxadr;\r\nchan.dum_ch_conf = 0x002;\r\nchan.dum_ch_ctrl = 0x04;\r\nput_channel(chan);\r\nreturn 0;\r\n}\r\nstatic u32 display_open(int ch_no, int auto_update, u32 * dirty_buffer,\r\nu32 * frame_buffer, u32 xpos, u32 ypos, u32 w, u32 h)\r\n{\r\nstruct dum_ch_setup k;\r\nint ret;\r\nif ((xpos + w) > DISP_MAX_X_SIZE)\r\nw = DISP_MAX_X_SIZE - xpos;\r\nif ((ypos + h) > DISP_MAX_Y_SIZE)\r\nh = DISP_MAX_Y_SIZE - ypos;\r\nk.disp_no = 0;\r\nk.xmin = xpos;\r\nk.ymin = ypos;\r\nk.xmax = xpos + (w - 1);\r\nk.ymax = ypos + (h - 1);\r\nif (k.xmin > DISP_MAX_X_SIZE - 1)\r\nk.xmin = DISP_MAX_X_SIZE - 1;\r\nif (k.ymin > DISP_MAX_Y_SIZE - 1)\r\nk.ymin = DISP_MAX_Y_SIZE - 1;\r\nif (k.xmax > DISP_MAX_X_SIZE - 1)\r\nk.xmax = DISP_MAX_X_SIZE - 1;\r\nif (k.ymax > DISP_MAX_Y_SIZE - 1)\r\nk.ymax = DISP_MAX_Y_SIZE - 1;\r\nk.xmirror = 0;\r\nk.ymirror = 0;\r\nk.rotate = 0;\r\nk.minadr = (u32) frame_buffer;\r\nk.maxadr = (u32) frame_buffer + (((w - 1) << 10) | ((h << 2) - 2));\r\nk.pad = PAD_1024;\r\nk.dirtybuffer = (u32) dirty_buffer;\r\nk.format = RGB888;\r\nk.hwdirty = 0;\r\nk.slave_trans = 0;\r\nret = dum_ch_setup(ch_no, &k);\r\nreturn ret;\r\n}\r\nstatic void lcd_reset(void)\r\n{\r\nu32 *dum_pio_base = (u32 *)IO_ADDRESS(PNX4008_PIO_BASE);\r\nudelay(1);\r\niowrite32(BIT(19), &dum_pio_base[2]);\r\nudelay(1);\r\niowrite32(BIT(19), &dum_pio_base[1]);\r\nudelay(1);\r\n}\r\nstatic int dum_init(struct platform_device *pdev)\r\n{\r\nstruct clk *clk;\r\nclk = clk_get(&pdev->dev, "dum_ck");\r\nif (IS_ERR(clk)) {\r\nprintk(KERN_ERR "pnx4008_dum: Unable to access DUM clock\n");\r\nreturn PTR_ERR(clk);\r\n}\r\nclk_set_rate(clk, 1);\r\nclk_put(clk);\r\nDUM_CTRL = V_DUM_RESET;\r\nDUM_CONF = BIT(9);\r\nDUM_WTCFG1 = PNX4008_DUM_WT_CFG;\r\nDUM_RTCFG1 = PNX4008_DUM_RT_CFG;\r\nDUM_TCFG = PNX4008_DUM_T_CFG;\r\nreturn 0;\r\n}\r\nstatic void dum_chan_init(void)\r\n{\r\nint i = 0, ch = 0;\r\nu32 *cmdptrs;\r\nu32 *cmdstrings;\r\nDUM_COM_BASE =\r\nCMDSTRING_BASEADDR + BYTES_PER_CMDSTRING * NR_OF_CMDSTRINGS;\r\nif ((cmdptrs =\r\n(u32 *) ioremap_nocache(DUM_COM_BASE,\r\nsizeof(u32) * NR_OF_CMDSTRINGS)) == NULL)\r\nreturn;\r\nfor (ch = 0; ch < NR_OF_CMDSTRINGS; ch++)\r\niowrite32(CMDSTRING_BASEADDR + BYTES_PER_CMDSTRING * ch,\r\ncmdptrs + ch);\r\nfor (ch = 0; ch < MAX_DUM_CHANNELS; ch++)\r\nclear_channel(ch);\r\ncmdstrings =\r\n(u32 *)ioremap_nocache(*cmdptrs,\r\nBYTES_PER_CMDSTRING * NR_OF_CMDSTRINGS);\r\nif (!cmdstrings)\r\ngoto out;\r\nfor (i = 0; i < NR_OF_CMDSTRINGS * BYTES_PER_CMDSTRING / sizeof(u32);\r\ni++)\r\niowrite32(0, cmdstrings + i);\r\niounmap((u32 *)cmdstrings);\r\nout:\r\niounmap((u32 *)cmdptrs);\r\n}\r\nstatic void lcd_init(void)\r\n{\r\nlcd_reset();\r\nDUM_OUTP_FORMAT1 = 0;\r\nudelay(1);\r\niowrite32(V_LCD_STANDBY_OFF, dum_data.slave_virt_base);\r\nudelay(1);\r\niowrite32(V_LCD_USE_9BIT_BUS, dum_data.slave_virt_base);\r\nudelay(1);\r\niowrite32(V_LCD_SYNC_RISE_L, dum_data.slave_virt_base);\r\nudelay(1);\r\niowrite32(V_LCD_SYNC_RISE_H, dum_data.slave_virt_base);\r\nudelay(1);\r\niowrite32(V_LCD_SYNC_FALL_L, dum_data.slave_virt_base);\r\nudelay(1);\r\niowrite32(V_LCD_SYNC_FALL_H, dum_data.slave_virt_base);\r\nudelay(1);\r\niowrite32(V_LCD_SYNC_ENABLE, dum_data.slave_virt_base);\r\nudelay(1);\r\niowrite32(V_LCD_DISPLAY_ON, dum_data.slave_virt_base);\r\nudelay(1);\r\n}\r\nint pnx4008_get_fb_addresses(int fb_type, void **virt_addr,\r\ndma_addr_t *phys_addr, int *fb_length)\r\n{\r\nint i;\r\nint ret = -1;\r\nfor (i = 0; i < ARRAY_SIZE(fb_addr); i++)\r\nif (fb_addr[i].fb_type == fb_type) {\r\n*virt_addr = (void *)(dum_data.lcd_virt_start +\r\nfb_addr[i].addr_offset);\r\n*phys_addr =\r\ndum_data.lcd_phys_start + fb_addr[i].addr_offset;\r\n*fb_length = fb_addr[i].fb_length;\r\nret = 0;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint pnx4008_alloc_dum_channel(int dev_id)\r\n{\r\nint i = 0;\r\nwhile ((i < MAX_DUM_CHANNELS) && (dum_data.fb_owning_channel[i] != -1))\r\ni++;\r\nif (i == MAX_DUM_CHANNELS)\r\nreturn -ENORESOURCESLEFT;\r\nelse {\r\ndum_data.fb_owning_channel[i] = dev_id;\r\nreturn i;\r\n}\r\n}\r\nint pnx4008_free_dum_channel(int channr, int dev_id)\r\n{\r\nif (channr < 0 || channr > MAX_DUM_CHANNELS)\r\nreturn -EINVAL;\r\nelse if (dum_data.fb_owning_channel[channr] != dev_id)\r\nreturn -EFBNOTOWNER;\r\nelse {\r\nclear_channel(channr);\r\ndum_data.fb_owning_channel[channr] = -1;\r\n}\r\nreturn 0;\r\n}\r\nint pnx4008_put_dum_channel_uf(struct dumchannel_uf chan_uf, int dev_id)\r\n{\r\nint i = chan_uf.channelnr;\r\nint ret;\r\nif (i < 0 || i > MAX_DUM_CHANNELS)\r\nreturn -EINVAL;\r\nelse if (dum_data.fb_owning_channel[i] != dev_id)\r\nreturn -EFBNOTOWNER;\r\nelse if ((ret =\r\ndisplay_open(chan_uf.channelnr, 0, chan_uf.dirty,\r\nchan_uf.source, chan_uf.y_offset,\r\nchan_uf.x_offset, chan_uf.height,\r\nchan_uf.width)) != 0)\r\nreturn ret;\r\nelse {\r\ndum_data.chan_uf_store[i].dirty = chan_uf.dirty;\r\ndum_data.chan_uf_store[i].source = chan_uf.source;\r\ndum_data.chan_uf_store[i].x_offset = chan_uf.x_offset;\r\ndum_data.chan_uf_store[i].y_offset = chan_uf.y_offset;\r\ndum_data.chan_uf_store[i].width = chan_uf.width;\r\ndum_data.chan_uf_store[i].height = chan_uf.height;\r\n}\r\nreturn 0;\r\n}\r\nint pnx4008_set_dum_channel_sync(int channr, int val, int dev_id)\r\n{\r\nif (channr < 0 || channr > MAX_DUM_CHANNELS)\r\nreturn -EINVAL;\r\nelse if (dum_data.fb_owning_channel[channr] != dev_id)\r\nreturn -EFBNOTOWNER;\r\nelse {\r\nif (val == CONF_SYNC_ON) {\r\nDUM_CH_CONF(channr) |= CONF_SYNCENABLE;\r\nDUM_CH_CONF(channr) |= DUM_CHANNEL_CFG_SYNC_MASK |\r\nDUM_CHANNEL_CFG_SYNC_MASK_SET;\r\n} else if (val == CONF_SYNC_OFF)\r\nDUM_CH_CONF(channr) &= ~CONF_SYNCENABLE;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint pnx4008_set_dum_channel_dirty_detect(int channr, int val, int dev_id)\r\n{\r\nif (channr < 0 || channr > MAX_DUM_CHANNELS)\r\nreturn -EINVAL;\r\nelse if (dum_data.fb_owning_channel[channr] != dev_id)\r\nreturn -EFBNOTOWNER;\r\nelse {\r\nif (val == CONF_DIRTYDETECTION_ON)\r\nDUM_CH_CONF(channr) |= CONF_DIRTYENABLE;\r\nelse if (val == CONF_DIRTYDETECTION_OFF)\r\nDUM_CH_CONF(channr) &= ~CONF_DIRTYENABLE;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint pnx4008_sdum_mmap(struct fb_info *info, struct vm_area_struct *vma,\r\nstruct device *dev)\r\n{\r\nunsigned long off = vma->vm_pgoff << PAGE_SHIFT;\r\nif (off < info->fix.smem_len) {\r\nvma->vm_pgoff += 1;\r\nreturn dma_mmap_writecombine(dev, vma,\r\n(void *)dum_data.lcd_virt_start,\r\ndum_data.lcd_phys_start,\r\nFB_DMA_SIZE);\r\n}\r\nreturn -EINVAL;\r\n}\r\nint pnx4008_set_dum_exit_notification(int dev_id)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_DUM_CHANNELS; i++)\r\nif (dum_data.fb_owning_channel[i] == dev_id)\r\nreturn -ERESOURCESNOTFREED;\r\nreturn 0;\r\n}\r\nstatic int sdum_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nint retval = 0;\r\nstruct clk *clk;\r\nclk = clk_get(0, "dum_ck");\r\nif (!IS_ERR(clk)) {\r\nclk_set_rate(clk, 0);\r\nclk_put(clk);\r\n} else\r\nretval = PTR_ERR(clk);\r\nDUM_CTRL = V_BAC_DISABLE_IDLE;\r\nlcd_reset();\r\nreturn retval;\r\n}\r\nstatic int sdum_resume(struct platform_device *pdev)\r\n{\r\nint retval = 0;\r\nstruct clk *clk;\r\nclk = clk_get(0, "dum_ck");\r\nif (!IS_ERR(clk)) {\r\nclk_set_rate(clk, 1);\r\nclk_put(clk);\r\n} else\r\nretval = PTR_ERR(clk);\r\nDUM_CTRL = V_BAC_DISABLE_TRIG;\r\nwhile (DUM_CTRL & BAC_ENABLED)\r\nudelay(10);\r\nlcd_init();\r\nDUM_CTRL = V_BAC_ENABLE;\r\nudelay(1);\r\nDUM_CTRL = V_MUX_RESET;\r\nreturn 0;\r\n}\r\nstatic int __devinit sdum_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0, i = 0;\r\ndum_data.lcd_virt_start = (u32) dma_alloc_writecombine(&pdev->dev,\r\nFB_DMA_SIZE,\r\n&dum_data.lcd_phys_start,\r\nGFP_KERNEL);\r\nif (!dum_data.lcd_virt_start) {\r\nret = -ENOMEM;\r\ngoto out_3;\r\n}\r\ndum_data.slave_phys_base = PNX4008_DUM_SLAVE_BASE;\r\ndum_data.slave_virt_base =\r\n(u32 *) ioremap_nocache(dum_data.slave_phys_base, sizeof(u32));\r\nif (dum_data.slave_virt_base == NULL) {\r\nret = -ENOMEM;\r\ngoto out_2;\r\n}\r\nret = dum_init(pdev);\r\nif (ret)\r\ngoto out_1;\r\ndum_chan_init();\r\nlcd_init();\r\nDUM_CTRL = V_BAC_ENABLE;\r\nudelay(1);\r\nDUM_CTRL = V_MUX_RESET;\r\nDUM_DECODE = dum_data.lcd_phys_start & DUM_DECODE_MASK;\r\nDUM_CLK_DIV = PNX4008_DUM_CLK_DIV;\r\nfor (i = 0; i < MAX_DUM_CHANNELS; i++)\r\ndum_data.fb_owning_channel[i] = -1;\r\nstart_int_set_rising_edge(SE_DISP_SYNC_INT);\r\nstart_int_ack(SE_DISP_SYNC_INT);\r\nstart_int_umask(SE_DISP_SYNC_INT);\r\nreturn 0;\r\nout_1:\r\niounmap((void *)dum_data.slave_virt_base);\r\nout_2:\r\ndma_free_writecombine(&pdev->dev, FB_DMA_SIZE,\r\n(void *)dum_data.lcd_virt_start,\r\ndum_data.lcd_phys_start);\r\nout_3:\r\nreturn ret;\r\n}\r\nstatic int sdum_remove(struct platform_device *pdev)\r\n{\r\nstruct clk *clk;\r\nstart_int_mask(SE_DISP_SYNC_INT);\r\nclk = clk_get(0, "dum_ck");\r\nif (!IS_ERR(clk)) {\r\nclk_set_rate(clk, 0);\r\nclk_put(clk);\r\n}\r\niounmap((void *)dum_data.slave_virt_base);\r\ndma_free_writecombine(&pdev->dev, FB_DMA_SIZE,\r\n(void *)dum_data.lcd_virt_start,\r\ndum_data.lcd_phys_start);\r\nreturn 0;\r\n}
