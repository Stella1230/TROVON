static int tas5130d1b_init(struct et61x251_device* cam)\r\n{\r\nint err = 0;\r\nerr += et61x251_write_reg(cam, 0x14, 0x01);\r\nerr += et61x251_write_reg(cam, 0x1b, 0x02);\r\nerr += et61x251_write_reg(cam, 0x02, 0x12);\r\nerr += et61x251_write_reg(cam, 0x0e, 0x60);\r\nerr += et61x251_write_reg(cam, 0x80, 0x61);\r\nerr += et61x251_write_reg(cam, 0xf0, 0x62);\r\nerr += et61x251_write_reg(cam, 0x03, 0x63);\r\nerr += et61x251_write_reg(cam, 0x14, 0x64);\r\nerr += et61x251_write_reg(cam, 0xf4, 0x65);\r\nerr += et61x251_write_reg(cam, 0x01, 0x66);\r\nerr += et61x251_write_reg(cam, 0x05, 0x67);\r\nerr += et61x251_write_reg(cam, 0x8f, 0x68);\r\nerr += et61x251_write_reg(cam, 0x0f, 0x8d);\r\nerr += et61x251_write_reg(cam, 0x08, 0x8e);\r\nreturn err;\r\n}\r\nstatic int tas5130d1b_set_ctrl(struct et61x251_device* cam,\r\nconst struct v4l2_control* ctrl)\r\n{\r\nint err = 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_GAIN:\r\nerr += et61x251_i2c_raw_write(cam, 2, 0x20,\r\n0xf6-ctrl->value, 0, 0, 0,\r\n0, 0, 0, 0);\r\nbreak;\r\ncase V4L2_CID_EXPOSURE:\r\nerr += et61x251_i2c_raw_write(cam, 2, 0x40,\r\n0x47-ctrl->value, 0, 0, 0,\r\n0, 0, 0, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn err ? -EIO : 0;\r\n}\r\nint et61x251_probe_tas5130d1b(struct et61x251_device* cam)\r\n{\r\nconst struct usb_device_id tas5130d1b_id_table[] = {\r\n{ USB_DEVICE(0x102c, 0x6251), },\r\n{ }\r\n};\r\nif (!et61x251_match_id(cam, tas5130d1b_id_table))\r\nreturn -ENODEV;\r\net61x251_attach_sensor(cam, &tas5130d1b);\r\nreturn 0;\r\n}
