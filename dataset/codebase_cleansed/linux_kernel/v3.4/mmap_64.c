static inline int mmap_is_legacy(void)\r\n{\r\nif (current->personality & ADDR_COMPAT_LAYOUT)\r\nreturn 1;\r\nif (rlimit(RLIMIT_STACK) == RLIM_INFINITY)\r\nreturn 1;\r\nreturn sysctl_legacy_va_layout;\r\n}\r\nstatic unsigned long mmap_rnd(void)\r\n{\r\nunsigned long rnd = 0;\r\nif (current->flags & PF_RANDOMIZE) {\r\nif (is_32bit_task())\r\nrnd = (long)(get_random_int() % (1<<(23-PAGE_SHIFT)));\r\nelse\r\nrnd = (long)(get_random_int() % (1<<(30-PAGE_SHIFT)));\r\n}\r\nreturn rnd << PAGE_SHIFT;\r\n}\r\nstatic inline unsigned long mmap_base(void)\r\n{\r\nunsigned long gap = rlimit(RLIMIT_STACK);\r\nif (gap < MIN_GAP)\r\ngap = MIN_GAP;\r\nelse if (gap > MAX_GAP)\r\ngap = MAX_GAP;\r\nreturn PAGE_ALIGN(TASK_SIZE - gap - mmap_rnd());\r\n}\r\nvoid arch_pick_mmap_layout(struct mm_struct *mm)\r\n{\r\nif (mmap_is_legacy()) {\r\nmm->mmap_base = TASK_UNMAPPED_BASE;\r\nmm->get_unmapped_area = arch_get_unmapped_area;\r\nmm->unmap_area = arch_unmap_area;\r\n} else {\r\nmm->mmap_base = mmap_base();\r\nmm->get_unmapped_area = arch_get_unmapped_area_topdown;\r\nmm->unmap_area = arch_unmap_area_topdown;\r\n}\r\n}
