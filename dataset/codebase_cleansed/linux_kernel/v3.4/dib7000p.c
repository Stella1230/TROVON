static u16 dib7000p_read_word(struct dib7000p_state *state, u16 reg)\r\n{\r\nu16 ret;\r\nif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock");\r\nreturn 0;\r\n}\r\nstate->i2c_write_buffer[0] = reg >> 8;\r\nstate->i2c_write_buffer[1] = reg & 0xff;\r\nmemset(state->msg, 0, 2 * sizeof(struct i2c_msg));\r\nstate->msg[0].addr = state->i2c_addr >> 1;\r\nstate->msg[0].flags = 0;\r\nstate->msg[0].buf = state->i2c_write_buffer;\r\nstate->msg[0].len = 2;\r\nstate->msg[1].addr = state->i2c_addr >> 1;\r\nstate->msg[1].flags = I2C_M_RD;\r\nstate->msg[1].buf = state->i2c_read_buffer;\r\nstate->msg[1].len = 2;\r\nif (i2c_transfer(state->i2c_adap, state->msg, 2) != 2)\r\ndprintk("i2c read error on %d", reg);\r\nret = (state->i2c_read_buffer[0] << 8) | state->i2c_read_buffer[1];\r\nmutex_unlock(&state->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic int dib7000p_write_word(struct dib7000p_state *state, u16 reg, u16 val)\r\n{\r\nint ret;\r\nif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock");\r\nreturn -EINVAL;\r\n}\r\nstate->i2c_write_buffer[0] = (reg >> 8) & 0xff;\r\nstate->i2c_write_buffer[1] = reg & 0xff;\r\nstate->i2c_write_buffer[2] = (val >> 8) & 0xff;\r\nstate->i2c_write_buffer[3] = val & 0xff;\r\nmemset(&state->msg[0], 0, sizeof(struct i2c_msg));\r\nstate->msg[0].addr = state->i2c_addr >> 1;\r\nstate->msg[0].flags = 0;\r\nstate->msg[0].buf = state->i2c_write_buffer;\r\nstate->msg[0].len = 4;\r\nret = (i2c_transfer(state->i2c_adap, state->msg, 1) != 1 ?\r\n-EREMOTEIO : 0);\r\nmutex_unlock(&state->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic void dib7000p_write_tab(struct dib7000p_state *state, u16 * buf)\r\n{\r\nu16 l = 0, r, *n;\r\nn = buf;\r\nl = *n++;\r\nwhile (l) {\r\nr = *n++;\r\ndo {\r\ndib7000p_write_word(state, r, *n++);\r\nr++;\r\n} while (--l);\r\nl = *n++;\r\n}\r\n}\r\nstatic int dib7000p_set_output_mode(struct dib7000p_state *state, int mode)\r\n{\r\nint ret = 0;\r\nu16 outreg, fifo_threshold, smo_mode;\r\noutreg = 0;\r\nfifo_threshold = 1792;\r\nsmo_mode = (dib7000p_read_word(state, 235) & 0x0050) | (1 << 1);\r\ndprintk("setting output mode for demod %p to %d", &state->demod, mode);\r\nswitch (mode) {\r\ncase OUTMODE_MPEG2_PAR_GATED_CLK:\r\noutreg = (1 << 10);\r\nbreak;\r\ncase OUTMODE_MPEG2_PAR_CONT_CLK:\r\noutreg = (1 << 10) | (1 << 6);\r\nbreak;\r\ncase OUTMODE_MPEG2_SERIAL:\r\noutreg = (1 << 10) | (2 << 6) | (0 << 1);\r\nbreak;\r\ncase OUTMODE_DIVERSITY:\r\nif (state->cfg.hostbus_diversity)\r\noutreg = (1 << 10) | (4 << 6);\r\nelse\r\noutreg = (1 << 11);\r\nbreak;\r\ncase OUTMODE_MPEG2_FIFO:\r\nsmo_mode |= (3 << 1);\r\nfifo_threshold = 512;\r\noutreg = (1 << 10) | (5 << 6);\r\nbreak;\r\ncase OUTMODE_ANALOG_ADC:\r\noutreg = (1 << 10) | (3 << 6);\r\nbreak;\r\ncase OUTMODE_HIGH_Z:\r\noutreg = 0;\r\nbreak;\r\ndefault:\r\ndprintk("Unhandled output_mode passed to be set for demod %p", &state->demod);\r\nbreak;\r\n}\r\nif (state->cfg.output_mpeg2_in_188_bytes)\r\nsmo_mode |= (1 << 5);\r\nret |= dib7000p_write_word(state, 235, smo_mode);\r\nret |= dib7000p_write_word(state, 236, fifo_threshold);\r\nif (state->version != SOC7090)\r\nret |= dib7000p_write_word(state, 1286, outreg);\r\nreturn ret;\r\n}\r\nstatic int dib7000p_set_diversity_in(struct dvb_frontend *demod, int onoff)\r\n{\r\nstruct dib7000p_state *state = demod->demodulator_priv;\r\nif (state->div_force_off) {\r\ndprintk("diversity combination deactivated - forced by COFDM parameters");\r\nonoff = 0;\r\ndib7000p_write_word(state, 207, 0);\r\n} else\r\ndib7000p_write_word(state, 207, (state->div_sync_wait << 4) | (1 << 2) | (2 << 0));\r\nstate->div_state = (u8) onoff;\r\nif (onoff) {\r\ndib7000p_write_word(state, 204, 6);\r\ndib7000p_write_word(state, 205, 16);\r\n} else {\r\ndib7000p_write_word(state, 204, 1);\r\ndib7000p_write_word(state, 205, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib7000p_set_power_mode(struct dib7000p_state *state, enum dib7000p_power_mode mode)\r\n{\r\nu16 reg_774 = 0x3fff, reg_775 = 0xffff, reg_776 = 0x0007, reg_899 = 0x0003, reg_1280 = (0xfe00) | (dib7000p_read_word(state, 1280) & 0x01ff);\r\nswitch (mode) {\r\ncase DIB7000P_POWER_ALL:\r\nreg_774 = 0x0000;\r\nreg_775 = 0x0000;\r\nreg_776 = 0x0;\r\nreg_899 = 0x0;\r\nif (state->version == SOC7090)\r\nreg_1280 &= 0x001f;\r\nelse\r\nreg_1280 &= 0x01ff;\r\nbreak;\r\ncase DIB7000P_POWER_ANALOG_ADC:\r\nreg_774 &= ~((1 << 15) | (1 << 14) | (1 << 11) | (1 << 10) | (1 << 9));\r\nreg_776 &= ~((1 << 0));\r\nif (state->version != SOC7090)\r\nreg_1280 &= ~((1 << 11));\r\nreg_1280 &= ~(1 << 6);\r\ncase DIB7000P_POWER_INTERFACE_ONLY:\r\nif (state->version == SOC7090)\r\nreg_1280 &= ~((1 << 7) | (1 << 5));\r\nelse\r\nreg_1280 &= ~((1 << 14) | (1 << 13) | (1 << 12) | (1 << 10));\r\nbreak;\r\n}\r\ndib7000p_write_word(state, 774, reg_774);\r\ndib7000p_write_word(state, 775, reg_775);\r\ndib7000p_write_word(state, 776, reg_776);\r\ndib7000p_write_word(state, 1280, reg_1280);\r\nif (state->version != SOC7090)\r\ndib7000p_write_word(state, 899, reg_899);\r\nreturn 0;\r\n}\r\nstatic void dib7000p_set_adc_state(struct dib7000p_state *state, enum dibx000_adc_states no)\r\n{\r\nu16 reg_908 = 0, reg_909 = 0;\r\nu16 reg;\r\nif (state->version != SOC7090) {\r\nreg_908 = dib7000p_read_word(state, 908);\r\nreg_909 = dib7000p_read_word(state, 909);\r\n}\r\nswitch (no) {\r\ncase DIBX000_SLOW_ADC_ON:\r\nif (state->version == SOC7090) {\r\nreg = dib7000p_read_word(state, 1925);\r\ndib7000p_write_word(state, 1925, reg | (1 << 4) | (1 << 2));\r\nreg = dib7000p_read_word(state, 1925);\r\nmsleep(200);\r\ndib7000p_write_word(state, 1925, reg & ~(1 << 4));\r\nreg = dib7000p_read_word(state, 72) & ~((0x3 << 14) | (0x3 << 12));\r\ndib7000p_write_word(state, 72, reg | (1 << 14) | (3 << 12) | 524);\r\n} else {\r\nreg_909 |= (1 << 1) | (1 << 0);\r\ndib7000p_write_word(state, 909, reg_909);\r\nreg_909 &= ~(1 << 1);\r\n}\r\nbreak;\r\ncase DIBX000_SLOW_ADC_OFF:\r\nif (state->version == SOC7090) {\r\nreg = dib7000p_read_word(state, 1925);\r\ndib7000p_write_word(state, 1925, (reg & ~(1 << 2)) | (1 << 4));\r\n} else\r\nreg_909 |= (1 << 1) | (1 << 0);\r\nbreak;\r\ncase DIBX000_ADC_ON:\r\nreg_908 &= 0x0fff;\r\nreg_909 &= 0x0003;\r\nbreak;\r\ncase DIBX000_ADC_OFF:\r\nreg_908 |= (1 << 14) | (1 << 13) | (1 << 12);\r\nreg_909 |= (1 << 5) | (1 << 4) | (1 << 3) | (1 << 2);\r\nbreak;\r\ncase DIBX000_VBG_ENABLE:\r\nreg_908 &= ~(1 << 15);\r\nbreak;\r\ncase DIBX000_VBG_DISABLE:\r\nreg_908 |= (1 << 15);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreg_909 |= (state->cfg.disable_sample_and_hold & 1) << 4;\r\nreg_908 |= (state->cfg.enable_current_mirror & 1) << 7;\r\nif (state->version != SOC7090) {\r\ndib7000p_write_word(state, 908, reg_908);\r\ndib7000p_write_word(state, 909, reg_909);\r\n}\r\n}\r\nstatic int dib7000p_set_bandwidth(struct dib7000p_state *state, u32 bw)\r\n{\r\nu32 timf;\r\nstate->current_bandwidth = bw;\r\nif (state->timf == 0) {\r\ndprintk("using default timf");\r\ntimf = state->cfg.bw->timf;\r\n} else {\r\ndprintk("using updated timf");\r\ntimf = state->timf;\r\n}\r\ntimf = timf * (bw / 50) / 160;\r\ndib7000p_write_word(state, 23, (u16) ((timf >> 16) & 0xffff));\r\ndib7000p_write_word(state, 24, (u16) ((timf) & 0xffff));\r\nreturn 0;\r\n}\r\nstatic int dib7000p_sad_calib(struct dib7000p_state *state)\r\n{\r\ndib7000p_write_word(state, 73, (0 << 1) | (0 << 0));\r\nif (state->version == SOC7090)\r\ndib7000p_write_word(state, 74, 2048);\r\nelse\r\ndib7000p_write_word(state, 74, 776);\r\ndib7000p_write_word(state, 73, (1 << 0));\r\ndib7000p_write_word(state, 73, (0 << 0));\r\nmsleep(1);\r\nreturn 0;\r\n}\r\nint dib7000p_set_wbd_ref(struct dvb_frontend *demod, u16 value)\r\n{\r\nstruct dib7000p_state *state = demod->demodulator_priv;\r\nif (value > 4095)\r\nvalue = 4095;\r\nstate->wbd_ref = value;\r\nreturn dib7000p_write_word(state, 105, (dib7000p_read_word(state, 105) & 0xf000) | value);\r\n}\r\nint dib7000p_get_agc_values(struct dvb_frontend *fe,\r\nu16 *agc_global, u16 *agc1, u16 *agc2, u16 *wbd)\r\n{\r\nstruct dib7000p_state *state = fe->demodulator_priv;\r\nif (agc_global != NULL)\r\n*agc_global = dib7000p_read_word(state, 394);\r\nif (agc1 != NULL)\r\n*agc1 = dib7000p_read_word(state, 392);\r\nif (agc2 != NULL)\r\n*agc2 = dib7000p_read_word(state, 393);\r\nif (wbd != NULL)\r\n*wbd = dib7000p_read_word(state, 397);\r\nreturn 0;\r\n}\r\nstatic void dib7000p_reset_pll(struct dib7000p_state *state)\r\n{\r\nstruct dibx000_bandwidth_config *bw = &state->cfg.bw[0];\r\nu16 clk_cfg0;\r\nif (state->version == SOC7090) {\r\ndib7000p_write_word(state, 1856, (!bw->pll_reset << 13) | (bw->pll_range << 12) | (bw->pll_ratio << 6) | (bw->pll_prediv));\r\nwhile (((dib7000p_read_word(state, 1856) >> 15) & 0x1) != 1)\r\n;\r\ndib7000p_write_word(state, 1857, dib7000p_read_word(state, 1857) | (!bw->pll_bypass << 15));\r\n} else {\r\nclk_cfg0 = (1 << 15) | ((bw->pll_ratio & 0x3f) << 9) |\r\n(bw->modulo << 7) | (bw->ADClkSrc << 6) | (bw->IO_CLK_en_core << 5) | (bw->bypclk_div << 2) | (bw->enable_refdiv << 1) | (0 << 0);\r\ndib7000p_write_word(state, 900, clk_cfg0);\r\ndib7000p_write_word(state, 903, (bw->pll_prediv << 5) | (((bw->pll_ratio >> 6) & 0x3) << 3) | (bw->pll_range << 1) | bw->pll_reset);\r\nclk_cfg0 = (bw->pll_bypass << 15) | (clk_cfg0 & 0x7fff);\r\ndib7000p_write_word(state, 900, clk_cfg0);\r\n}\r\ndib7000p_write_word(state, 18, (u16) (((bw->internal * 1000) >> 16) & 0xffff));\r\ndib7000p_write_word(state, 19, (u16) ((bw->internal * 1000) & 0xffff));\r\ndib7000p_write_word(state, 21, (u16) ((bw->ifreq >> 16) & 0xffff));\r\ndib7000p_write_word(state, 22, (u16) ((bw->ifreq) & 0xffff));\r\ndib7000p_write_word(state, 72, bw->sad_cfg);\r\n}\r\nstatic u32 dib7000p_get_internal_freq(struct dib7000p_state *state)\r\n{\r\nu32 internal = (u32) dib7000p_read_word(state, 18) << 16;\r\ninternal |= (u32) dib7000p_read_word(state, 19);\r\ninternal /= 1000;\r\nreturn internal;\r\n}\r\nint dib7000p_update_pll(struct dvb_frontend *fe, struct dibx000_bandwidth_config *bw)\r\n{\r\nstruct dib7000p_state *state = fe->demodulator_priv;\r\nu16 reg_1857, reg_1856 = dib7000p_read_word(state, 1856);\r\nu8 loopdiv, prediv;\r\nu32 internal, xtal;\r\nprediv = reg_1856 & 0x3f;\r\nloopdiv = (reg_1856 >> 6) & 0x3f;\r\nif ((bw != NULL) && (bw->pll_prediv != prediv || bw->pll_ratio != loopdiv)) {\r\ndprintk("Updating pll (prediv: old = %d new = %d ; loopdiv : old = %d new = %d)", prediv, bw->pll_prediv, loopdiv, bw->pll_ratio);\r\nreg_1856 &= 0xf000;\r\nreg_1857 = dib7000p_read_word(state, 1857);\r\ndib7000p_write_word(state, 1857, reg_1857 & ~(1 << 15));\r\ndib7000p_write_word(state, 1856, reg_1856 | ((bw->pll_ratio & 0x3f) << 6) | (bw->pll_prediv & 0x3f));\r\ninternal = dib7000p_get_internal_freq(state);\r\nxtal = (internal / loopdiv) * prediv;\r\ninternal = 1000 * (xtal / bw->pll_prediv) * bw->pll_ratio;\r\ndib7000p_write_word(state, 18, (u16) ((internal >> 16) & 0xffff));\r\ndib7000p_write_word(state, 19, (u16) (internal & 0xffff));\r\ndib7000p_write_word(state, 1857, reg_1857 | (1 << 15));\r\nwhile (((dib7000p_read_word(state, 1856) >> 15) & 0x1) != 1)\r\ndprintk("Waiting for PLL to lock");\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int dib7000p_reset_gpio(struct dib7000p_state *st)\r\n{\r\ndprintk("gpio dir: %x: val: %x, pwm_pos: %x", st->gpio_dir, st->gpio_val, st->cfg.gpio_pwm_pos);\r\ndib7000p_write_word(st, 1029, st->gpio_dir);\r\ndib7000p_write_word(st, 1030, st->gpio_val);\r\ndib7000p_write_word(st, 1032, st->cfg.gpio_pwm_pos);\r\ndib7000p_write_word(st, 1037, st->cfg.pwm_freq_div);\r\nreturn 0;\r\n}\r\nstatic int dib7000p_cfg_gpio(struct dib7000p_state *st, u8 num, u8 dir, u8 val)\r\n{\r\nst->gpio_dir = dib7000p_read_word(st, 1029);\r\nst->gpio_dir &= ~(1 << num);\r\nst->gpio_dir |= (dir & 0x1) << num;\r\ndib7000p_write_word(st, 1029, st->gpio_dir);\r\nst->gpio_val = dib7000p_read_word(st, 1030);\r\nst->gpio_val &= ~(1 << num);\r\nst->gpio_val |= (val & 0x01) << num;\r\ndib7000p_write_word(st, 1030, st->gpio_val);\r\nreturn 0;\r\n}\r\nint dib7000p_set_gpio(struct dvb_frontend *demod, u8 num, u8 dir, u8 val)\r\n{\r\nstruct dib7000p_state *state = demod->demodulator_priv;\r\nreturn dib7000p_cfg_gpio(state, num, dir, val);\r\n}\r\nstatic int dib7000p_demod_reset(struct dib7000p_state *state)\r\n{\r\ndib7000p_set_power_mode(state, DIB7000P_POWER_ALL);\r\nif (state->version == SOC7090)\r\ndibx000_reset_i2c_master(&state->i2c_master);\r\ndib7000p_set_adc_state(state, DIBX000_VBG_ENABLE);\r\ndib7000p_write_word(state, 770, 0xffff);\r\ndib7000p_write_word(state, 771, 0xffff);\r\ndib7000p_write_word(state, 772, 0x001f);\r\ndib7000p_write_word(state, 1280, 0x001f - ((1 << 4) | (1 << 3)));\r\ndib7000p_write_word(state, 770, 0);\r\ndib7000p_write_word(state, 771, 0);\r\ndib7000p_write_word(state, 772, 0);\r\ndib7000p_write_word(state, 1280, 0);\r\nif (state->version != SOC7090) {\r\ndib7000p_write_word(state, 898, 0x0003);\r\ndib7000p_write_word(state, 898, 0);\r\n}\r\ndib7000p_reset_pll(state);\r\nif (dib7000p_reset_gpio(state) != 0)\r\ndprintk("GPIO reset was not successful.");\r\nif (state->version == SOC7090) {\r\ndib7000p_write_word(state, 899, 0);\r\ndib7000p_write_word(state, 42, (1<<5) | 3);\r\ndib7000p_write_word(state, 43, 0x2d4);\r\ndib7000p_write_word(state, 44, 300);\r\ndib7000p_write_word(state, 273, (0<<6) | 30);\r\n}\r\nif (dib7000p_set_output_mode(state, OUTMODE_HIGH_Z) != 0)\r\ndprintk("OUTPUT_MODE could not be reset.");\r\ndib7000p_set_adc_state(state, DIBX000_SLOW_ADC_ON);\r\ndib7000p_sad_calib(state);\r\ndib7000p_set_adc_state(state, DIBX000_SLOW_ADC_OFF);\r\ndib7000p_write_word(state, 1285, dib7000p_read_word(state, 1285) & ~(1 << 1));\r\ndib7000p_set_bandwidth(state, 8000);\r\nif (state->version == SOC7090) {\r\ndib7000p_write_word(state, 36, 0x0755);\r\n} else {\r\nif (state->cfg.tuner_is_baseband)\r\ndib7000p_write_word(state, 36, 0x0755);\r\nelse\r\ndib7000p_write_word(state, 36, 0x1f55);\r\n}\r\ndib7000p_write_tab(state, dib7000p_defaults);\r\nif (state->version != SOC7090) {\r\ndib7000p_write_word(state, 901, 0x0006);\r\ndib7000p_write_word(state, 902, (3 << 10) | (1 << 6));\r\ndib7000p_write_word(state, 905, 0x2c8e);\r\n}\r\ndib7000p_set_power_mode(state, DIB7000P_POWER_INTERFACE_ONLY);\r\nreturn 0;\r\n}\r\nstatic void dib7000p_pll_clk_cfg(struct dib7000p_state *state)\r\n{\r\nu16 tmp = 0;\r\ntmp = dib7000p_read_word(state, 903);\r\ndib7000p_write_word(state, 903, (tmp | 0x1));\r\ntmp = dib7000p_read_word(state, 900);\r\ndib7000p_write_word(state, 900, (tmp & 0x7fff) | (1 << 6));\r\n}\r\nstatic void dib7000p_restart_agc(struct dib7000p_state *state)\r\n{\r\ndib7000p_write_word(state, 770, (1 << 11) | (1 << 9));\r\ndib7000p_write_word(state, 770, 0x0000);\r\n}\r\nstatic int dib7000p_update_lna(struct dib7000p_state *state)\r\n{\r\nu16 dyn_gain;\r\nif (state->cfg.update_lna) {\r\ndyn_gain = dib7000p_read_word(state, 394);\r\nif (state->cfg.update_lna(&state->demod, dyn_gain)) {\r\ndib7000p_restart_agc(state);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib7000p_set_agc_config(struct dib7000p_state *state, u8 band)\r\n{\r\nstruct dibx000_agc_config *agc = NULL;\r\nint i;\r\nif (state->current_band == band && state->current_agc != NULL)\r\nreturn 0;\r\nstate->current_band = band;\r\nfor (i = 0; i < state->cfg.agc_config_count; i++)\r\nif (state->cfg.agc[i].band_caps & band) {\r\nagc = &state->cfg.agc[i];\r\nbreak;\r\n}\r\nif (agc == NULL) {\r\ndprintk("no valid AGC configuration found for band 0x%02x", band);\r\nreturn -EINVAL;\r\n}\r\nstate->current_agc = agc;\r\ndib7000p_write_word(state, 75, agc->setup);\r\ndib7000p_write_word(state, 76, agc->inv_gain);\r\ndib7000p_write_word(state, 77, agc->time_stabiliz);\r\ndib7000p_write_word(state, 100, (agc->alpha_level << 12) | agc->thlock);\r\ndib7000p_write_word(state, 101, (agc->alpha_mant << 5) | agc->alpha_exp);\r\ndib7000p_write_word(state, 102, (agc->beta_mant << 6) | agc->beta_exp);\r\ndprintk("WBD: ref: %d, sel: %d, active: %d, alpha: %d",\r\nstate->wbd_ref != 0 ? state->wbd_ref : agc->wbd_ref, agc->wbd_sel, !agc->perform_agc_softsplit, agc->wbd_sel);\r\nif (state->wbd_ref != 0)\r\ndib7000p_write_word(state, 105, (agc->wbd_inv << 12) | state->wbd_ref);\r\nelse\r\ndib7000p_write_word(state, 105, (agc->wbd_inv << 12) | agc->wbd_ref);\r\ndib7000p_write_word(state, 106, (agc->wbd_sel << 13) | (agc->wbd_alpha << 9) | (agc->perform_agc_softsplit << 8));\r\ndib7000p_write_word(state, 107, agc->agc1_max);\r\ndib7000p_write_word(state, 108, agc->agc1_min);\r\ndib7000p_write_word(state, 109, agc->agc2_max);\r\ndib7000p_write_word(state, 110, agc->agc2_min);\r\ndib7000p_write_word(state, 111, (agc->agc1_pt1 << 8) | agc->agc1_pt2);\r\ndib7000p_write_word(state, 112, agc->agc1_pt3);\r\ndib7000p_write_word(state, 113, (agc->agc1_slope1 << 8) | agc->agc1_slope2);\r\ndib7000p_write_word(state, 114, (agc->agc2_pt1 << 8) | agc->agc2_pt2);\r\ndib7000p_write_word(state, 115, (agc->agc2_slope1 << 8) | agc->agc2_slope2);\r\nreturn 0;\r\n}\r\nstatic void dib7000p_set_dds(struct dib7000p_state *state, s32 offset_khz)\r\n{\r\nu32 internal = dib7000p_get_internal_freq(state);\r\ns32 unit_khz_dds_val = 67108864 / (internal);\r\nu32 abs_offset_khz = ABS(offset_khz);\r\nu32 dds = state->cfg.bw->ifreq & 0x1ffffff;\r\nu8 invert = !!(state->cfg.bw->ifreq & (1 << 25));\r\ndprintk("setting a frequency offset of %dkHz internal freq = %d invert = %d", offset_khz, internal, invert);\r\nif (offset_khz < 0)\r\nunit_khz_dds_val *= -1;\r\nif (invert)\r\ndds -= (abs_offset_khz * unit_khz_dds_val);\r\nelse\r\ndds += (abs_offset_khz * unit_khz_dds_val);\r\nif (abs_offset_khz <= (internal / 2)) {\r\ndib7000p_write_word(state, 21, (u16) (((dds >> 16) & 0x1ff) | (0 << 10) | (invert << 9)));\r\ndib7000p_write_word(state, 22, (u16) (dds & 0xffff));\r\n}\r\n}\r\nstatic int dib7000p_agc_startup(struct dvb_frontend *demod)\r\n{\r\nstruct dtv_frontend_properties *ch = &demod->dtv_property_cache;\r\nstruct dib7000p_state *state = demod->demodulator_priv;\r\nint ret = -1;\r\nu8 *agc_state = &state->agc_state;\r\nu8 agc_split;\r\nu16 reg;\r\nu32 upd_demod_gain_period = 0x1000;\r\nswitch (state->agc_state) {\r\ncase 0:\r\ndib7000p_set_power_mode(state, DIB7000P_POWER_ALL);\r\nif (state->version == SOC7090) {\r\nreg = dib7000p_read_word(state, 0x79b) & 0xff00;\r\ndib7000p_write_word(state, 0x79a, upd_demod_gain_period & 0xFFFF);\r\ndib7000p_write_word(state, 0x79b, reg | (1 << 14) | ((upd_demod_gain_period >> 16) & 0xFF));\r\nreg = dib7000p_read_word(state, 0x780);\r\ndib7000p_write_word(state, 0x780, (reg | (0x3)) & (~(1 << 7)));\r\n} else {\r\ndib7000p_set_adc_state(state, DIBX000_ADC_ON);\r\ndib7000p_pll_clk_cfg(state);\r\n}\r\nif (dib7000p_set_agc_config(state, BAND_OF_FREQUENCY(ch->frequency / 1000)) != 0)\r\nreturn -1;\r\ndib7000p_set_dds(state, 0);\r\nret = 7;\r\n(*agc_state)++;\r\nbreak;\r\ncase 1:\r\nif (state->cfg.agc_control)\r\nstate->cfg.agc_control(&state->demod, 1);\r\ndib7000p_write_word(state, 78, 32768);\r\nif (!state->current_agc->perform_agc_softsplit) {\r\ndib7000p_write_word(state, 106, (state->current_agc->wbd_sel << 13) | (state->current_agc->wbd_alpha << 9) | (1 << 8));\r\n(*agc_state)++;\r\nret = 5;\r\n} else {\r\n(*agc_state) = 4;\r\nret = 7;\r\n}\r\ndib7000p_restart_agc(state);\r\nbreak;\r\ncase 2:\r\ndib7000p_write_word(state, 75, state->current_agc->setup | (1 << 4));\r\ndib7000p_write_word(state, 106, (state->current_agc->wbd_sel << 13) | (2 << 9) | (0 << 8));\r\n(*agc_state)++;\r\nret = 14;\r\nbreak;\r\ncase 3:\r\nagc_split = (u8) dib7000p_read_word(state, 396);\r\ndib7000p_write_word(state, 78, dib7000p_read_word(state, 394));\r\ndib7000p_write_word(state, 75, state->current_agc->setup);\r\ndib7000p_write_word(state, 106, (state->current_agc->wbd_sel << 13) | (state->current_agc->wbd_alpha << 9) | agc_split);\r\ndib7000p_restart_agc(state);\r\ndprintk("SPLIT %p: %hd", demod, agc_split);\r\n(*agc_state)++;\r\nret = 5;\r\nbreak;\r\ncase 4:\r\nret = 7;\r\nif (dib7000p_update_lna(state))\r\nret = 5;\r\nelse\r\n(*agc_state)++;\r\nbreak;\r\ncase 5:\r\nif (state->cfg.agc_control)\r\nstate->cfg.agc_control(&state->demod, 0);\r\n(*agc_state)++;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void dib7000p_update_timf(struct dib7000p_state *state)\r\n{\r\nu32 timf = (dib7000p_read_word(state, 427) << 16) | dib7000p_read_word(state, 428);\r\nstate->timf = timf * 160 / (state->current_bandwidth / 50);\r\ndib7000p_write_word(state, 23, (u16) (timf >> 16));\r\ndib7000p_write_word(state, 24, (u16) (timf & 0xffff));\r\ndprintk("updated timf_frequency: %d (default: %d)", state->timf, state->cfg.bw->timf);\r\n}\r\nu32 dib7000p_ctrl_timf(struct dvb_frontend *fe, u8 op, u32 timf)\r\n{\r\nstruct dib7000p_state *state = fe->demodulator_priv;\r\nswitch (op) {\r\ncase DEMOD_TIMF_SET:\r\nstate->timf = timf;\r\nbreak;\r\ncase DEMOD_TIMF_UPDATE:\r\ndib7000p_update_timf(state);\r\nbreak;\r\ncase DEMOD_TIMF_GET:\r\nbreak;\r\n}\r\ndib7000p_set_bandwidth(state, state->current_bandwidth);\r\nreturn state->timf;\r\n}\r\nstatic void dib7000p_set_channel(struct dib7000p_state *state,\r\nstruct dtv_frontend_properties *ch, u8 seq)\r\n{\r\nu16 value, est[4];\r\ndib7000p_set_bandwidth(state, BANDWIDTH_TO_KHZ(ch->bandwidth_hz));\r\nvalue = 0;\r\nswitch (ch->transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\nvalue |= (0 << 7);\r\nbreak;\r\ncase TRANSMISSION_MODE_4K:\r\nvalue |= (2 << 7);\r\nbreak;\r\ndefault:\r\ncase TRANSMISSION_MODE_8K:\r\nvalue |= (1 << 7);\r\nbreak;\r\n}\r\nswitch (ch->guard_interval) {\r\ncase GUARD_INTERVAL_1_32:\r\nvalue |= (0 << 5);\r\nbreak;\r\ncase GUARD_INTERVAL_1_16:\r\nvalue |= (1 << 5);\r\nbreak;\r\ncase GUARD_INTERVAL_1_4:\r\nvalue |= (3 << 5);\r\nbreak;\r\ndefault:\r\ncase GUARD_INTERVAL_1_8:\r\nvalue |= (2 << 5);\r\nbreak;\r\n}\r\nswitch (ch->modulation) {\r\ncase QPSK:\r\nvalue |= (0 << 3);\r\nbreak;\r\ncase QAM_16:\r\nvalue |= (1 << 3);\r\nbreak;\r\ndefault:\r\ncase QAM_64:\r\nvalue |= (2 << 3);\r\nbreak;\r\n}\r\nswitch (HIERARCHY_1) {\r\ncase HIERARCHY_2:\r\nvalue |= 2;\r\nbreak;\r\ncase HIERARCHY_4:\r\nvalue |= 4;\r\nbreak;\r\ndefault:\r\ncase HIERARCHY_1:\r\nvalue |= 1;\r\nbreak;\r\n}\r\ndib7000p_write_word(state, 0, value);\r\ndib7000p_write_word(state, 5, (seq << 4) | 1);\r\nvalue = 0;\r\nif (1 != 0)\r\nvalue |= (1 << 6);\r\nif (ch->hierarchy == 1)\r\nvalue |= (1 << 4);\r\nif (1 == 1)\r\nvalue |= 1;\r\nswitch ((ch->hierarchy == 0 || 1 == 1) ? ch->code_rate_HP : ch->code_rate_LP) {\r\ncase FEC_2_3:\r\nvalue |= (2 << 1);\r\nbreak;\r\ncase FEC_3_4:\r\nvalue |= (3 << 1);\r\nbreak;\r\ncase FEC_5_6:\r\nvalue |= (5 << 1);\r\nbreak;\r\ncase FEC_7_8:\r\nvalue |= (7 << 1);\r\nbreak;\r\ndefault:\r\ncase FEC_1_2:\r\nvalue |= (1 << 1);\r\nbreak;\r\n}\r\ndib7000p_write_word(state, 208, value);\r\ndib7000p_write_word(state, 26, 0x6680);\r\ndib7000p_write_word(state, 32, 0x0003);\r\ndib7000p_write_word(state, 29, 0x1273);\r\ndib7000p_write_word(state, 33, 0x0005);\r\nswitch (ch->transmission_mode) {\r\ncase TRANSMISSION_MODE_8K:\r\nvalue = 256;\r\nbreak;\r\ncase TRANSMISSION_MODE_4K:\r\nvalue = 128;\r\nbreak;\r\ncase TRANSMISSION_MODE_2K:\r\ndefault:\r\nvalue = 64;\r\nbreak;\r\n}\r\nswitch (ch->guard_interval) {\r\ncase GUARD_INTERVAL_1_16:\r\nvalue *= 2;\r\nbreak;\r\ncase GUARD_INTERVAL_1_8:\r\nvalue *= 4;\r\nbreak;\r\ncase GUARD_INTERVAL_1_4:\r\nvalue *= 8;\r\nbreak;\r\ndefault:\r\ncase GUARD_INTERVAL_1_32:\r\nvalue *= 1;\r\nbreak;\r\n}\r\nif (state->cfg.diversity_delay == 0)\r\nstate->div_sync_wait = (value * 3) / 2 + 48;\r\nelse\r\nstate->div_sync_wait = (value * 3) / 2 + state->cfg.diversity_delay;\r\nstate->div_force_off = !1 && ch->transmission_mode != TRANSMISSION_MODE_8K;\r\ndib7000p_set_diversity_in(&state->demod, state->div_state);\r\nswitch (ch->modulation) {\r\ncase QAM_64:\r\nest[0] = 0x0148;\r\nest[1] = 0xfff0;\r\nest[2] = 0x00a4;\r\nest[3] = 0xfff8;\r\nbreak;\r\ncase QAM_16:\r\nest[0] = 0x023d;\r\nest[1] = 0xffdf;\r\nest[2] = 0x00a4;\r\nest[3] = 0xfff0;\r\nbreak;\r\ndefault:\r\nest[0] = 0x099a;\r\nest[1] = 0xffae;\r\nest[2] = 0x0333;\r\nest[3] = 0xfff8;\r\nbreak;\r\n}\r\nfor (value = 0; value < 4; value++)\r\ndib7000p_write_word(state, 187 + value, est[value]);\r\n}\r\nstatic int dib7000p_autosearch_start(struct dvb_frontend *demod)\r\n{\r\nstruct dtv_frontend_properties *ch = &demod->dtv_property_cache;\r\nstruct dib7000p_state *state = demod->demodulator_priv;\r\nstruct dtv_frontend_properties schan;\r\nu32 value, factor;\r\nu32 internal = dib7000p_get_internal_freq(state);\r\nschan = *ch;\r\nschan.modulation = QAM_64;\r\nschan.guard_interval = GUARD_INTERVAL_1_32;\r\nschan.transmission_mode = TRANSMISSION_MODE_8K;\r\nschan.code_rate_HP = FEC_2_3;\r\nschan.code_rate_LP = FEC_3_4;\r\nschan.hierarchy = 0;\r\ndib7000p_set_channel(state, &schan, 7);\r\nfactor = BANDWIDTH_TO_KHZ(ch->bandwidth_hz);\r\nif (factor >= 5000) {\r\nif (state->version == SOC7090)\r\nfactor = 2;\r\nelse\r\nfactor = 1;\r\n} else\r\nfactor = 6;\r\nvalue = 30 * internal * factor;\r\ndib7000p_write_word(state, 6, (u16) ((value >> 16) & 0xffff));\r\ndib7000p_write_word(state, 7, (u16) (value & 0xffff));\r\nvalue = 100 * internal * factor;\r\ndib7000p_write_word(state, 8, (u16) ((value >> 16) & 0xffff));\r\ndib7000p_write_word(state, 9, (u16) (value & 0xffff));\r\nvalue = 500 * internal * factor;\r\ndib7000p_write_word(state, 10, (u16) ((value >> 16) & 0xffff));\r\ndib7000p_write_word(state, 11, (u16) (value & 0xffff));\r\nvalue = dib7000p_read_word(state, 0);\r\ndib7000p_write_word(state, 0, (u16) ((1 << 9) | value));\r\ndib7000p_read_word(state, 1284);\r\ndib7000p_write_word(state, 0, (u16) value);\r\nreturn 0;\r\n}\r\nstatic int dib7000p_autosearch_is_irq(struct dvb_frontend *demod)\r\n{\r\nstruct dib7000p_state *state = demod->demodulator_priv;\r\nu16 irq_pending = dib7000p_read_word(state, 1284);\r\nif (irq_pending & 0x1)\r\nreturn 1;\r\nif (irq_pending & 0x2)\r\nreturn 2;\r\nreturn 0;\r\n}\r\nstatic void dib7000p_spur_protect(struct dib7000p_state *state, u32 rf_khz, u32 bw)\r\n{\r\nstatic s16 notch[] = { 16143, 14402, 12238, 9713, 6902, 3888, 759, -2392 };\r\nstatic u8 sine[] = { 0, 2, 3, 5, 6, 8, 9, 11, 13, 14, 16, 17, 19, 20, 22,\r\n24, 25, 27, 28, 30, 31, 33, 34, 36, 38, 39, 41, 42, 44, 45, 47, 48, 50, 51,\r\n53, 55, 56, 58, 59, 61, 62, 64, 65, 67, 68, 70, 71, 73, 74, 76, 77, 79, 80,\r\n82, 83, 85, 86, 88, 89, 91, 92, 94, 95, 97, 98, 99, 101, 102, 104, 105,\r\n107, 108, 109, 111, 112, 114, 115, 117, 118, 119, 121, 122, 123, 125, 126,\r\n128, 129, 130, 132, 133, 134, 136, 137, 138, 140, 141, 142, 144, 145, 146,\r\n147, 149, 150, 151, 152, 154, 155, 156, 157, 159, 160, 161, 162, 164, 165,\r\n166, 167, 168, 170, 171, 172, 173, 174, 175, 177, 178, 179, 180, 181, 182,\r\n183, 184, 185, 186, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198,\r\n199, 200, 201, 202, 203, 204, 205, 206, 207, 207, 208, 209, 210, 211, 212,\r\n213, 214, 215, 215, 216, 217, 218, 219, 220, 220, 221, 222, 223, 224, 224,\r\n225, 226, 227, 227, 228, 229, 229, 230, 231, 231, 232, 233, 233, 234, 235,\r\n235, 236, 237, 237, 238, 238, 239, 239, 240, 241, 241, 242, 242, 243, 243,\r\n244, 244, 245, 245, 245, 246, 246, 247, 247, 248, 248, 248, 249, 249, 249,\r\n250, 250, 250, 251, 251, 251, 252, 252, 252, 252, 253, 253, 253, 253, 254,\r\n254, 254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n255, 255, 255, 255, 255, 255\r\n};\r\nu32 xtal = state->cfg.bw->xtal_hz / 1000;\r\nint f_rel = DIV_ROUND_CLOSEST(rf_khz, xtal) * xtal - rf_khz;\r\nint k;\r\nint coef_re[8], coef_im[8];\r\nint bw_khz = bw;\r\nu32 pha;\r\ndprintk("relative position of the Spur: %dk (RF: %dk, XTAL: %dk)", f_rel, rf_khz, xtal);\r\nif (f_rel < -bw_khz / 2 || f_rel > bw_khz / 2)\r\nreturn;\r\nbw_khz /= 100;\r\ndib7000p_write_word(state, 142, 0x0610);\r\nfor (k = 0; k < 8; k++) {\r\npha = ((f_rel * (k + 1) * 112 * 80 / bw_khz) / 1000) & 0x3ff;\r\nif (pha == 0) {\r\ncoef_re[k] = 256;\r\ncoef_im[k] = 0;\r\n} else if (pha < 256) {\r\ncoef_re[k] = sine[256 - (pha & 0xff)];\r\ncoef_im[k] = sine[pha & 0xff];\r\n} else if (pha == 256) {\r\ncoef_re[k] = 0;\r\ncoef_im[k] = 256;\r\n} else if (pha < 512) {\r\ncoef_re[k] = -sine[pha & 0xff];\r\ncoef_im[k] = sine[256 - (pha & 0xff)];\r\n} else if (pha == 512) {\r\ncoef_re[k] = -256;\r\ncoef_im[k] = 0;\r\n} else if (pha < 768) {\r\ncoef_re[k] = -sine[256 - (pha & 0xff)];\r\ncoef_im[k] = -sine[pha & 0xff];\r\n} else if (pha == 768) {\r\ncoef_re[k] = 0;\r\ncoef_im[k] = -256;\r\n} else {\r\ncoef_re[k] = sine[pha & 0xff];\r\ncoef_im[k] = -sine[256 - (pha & 0xff)];\r\n}\r\ncoef_re[k] *= notch[k];\r\ncoef_re[k] += (1 << 14);\r\nif (coef_re[k] >= (1 << 24))\r\ncoef_re[k] = (1 << 24) - 1;\r\ncoef_re[k] /= (1 << 15);\r\ncoef_im[k] *= notch[k];\r\ncoef_im[k] += (1 << 14);\r\nif (coef_im[k] >= (1 << 24))\r\ncoef_im[k] = (1 << 24) - 1;\r\ncoef_im[k] /= (1 << 15);\r\ndprintk("PALF COEF: %d re: %d im: %d", k, coef_re[k], coef_im[k]);\r\ndib7000p_write_word(state, 143, (0 << 14) | (k << 10) | (coef_re[k] & 0x3ff));\r\ndib7000p_write_word(state, 144, coef_im[k] & 0x3ff);\r\ndib7000p_write_word(state, 143, (1 << 14) | (k << 10) | (coef_re[k] & 0x3ff));\r\n}\r\ndib7000p_write_word(state, 143, 0);\r\n}\r\nstatic int dib7000p_tune(struct dvb_frontend *demod)\r\n{\r\nstruct dtv_frontend_properties *ch = &demod->dtv_property_cache;\r\nstruct dib7000p_state *state = demod->demodulator_priv;\r\nu16 tmp = 0;\r\nif (ch != NULL)\r\ndib7000p_set_channel(state, ch, 0);\r\nelse\r\nreturn -EINVAL;\r\ndib7000p_write_word(state, 770, 0x4000);\r\ndib7000p_write_word(state, 770, 0x0000);\r\nmsleep(45);\r\ntmp = (0 << 14) | (4 << 10) | (0 << 9) | (3 << 5) | (1 << 4) | (0x3);\r\nif (state->sfn_workaround_active) {\r\ndprintk("SFN workaround is active");\r\ntmp |= (1 << 9);\r\ndib7000p_write_word(state, 166, 0x4000);\r\n} else {\r\ndib7000p_write_word(state, 166, 0x0000);\r\n}\r\ndib7000p_write_word(state, 29, tmp);\r\nif (state->timf == 0)\r\nmsleep(200);\r\ntmp = (6 << 8) | 0x80;\r\nswitch (ch->transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\ntmp |= (2 << 12);\r\nbreak;\r\ncase TRANSMISSION_MODE_4K:\r\ntmp |= (3 << 12);\r\nbreak;\r\ndefault:\r\ncase TRANSMISSION_MODE_8K:\r\ntmp |= (4 << 12);\r\nbreak;\r\n}\r\ndib7000p_write_word(state, 26, tmp);\r\ntmp = (0 << 4);\r\nswitch (ch->transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\ntmp |= 0x6;\r\nbreak;\r\ncase TRANSMISSION_MODE_4K:\r\ntmp |= 0x7;\r\nbreak;\r\ndefault:\r\ncase TRANSMISSION_MODE_8K:\r\ntmp |= 0x8;\r\nbreak;\r\n}\r\ndib7000p_write_word(state, 32, tmp);\r\ntmp = (0 << 4);\r\nswitch (ch->transmission_mode) {\r\ncase TRANSMISSION_MODE_2K:\r\ntmp |= 0x6;\r\nbreak;\r\ncase TRANSMISSION_MODE_4K:\r\ntmp |= 0x7;\r\nbreak;\r\ndefault:\r\ncase TRANSMISSION_MODE_8K:\r\ntmp |= 0x8;\r\nbreak;\r\n}\r\ndib7000p_write_word(state, 33, tmp);\r\ntmp = dib7000p_read_word(state, 509);\r\nif (!((tmp >> 6) & 0x1)) {\r\ntmp = dib7000p_read_word(state, 771);\r\ndib7000p_write_word(state, 771, tmp | (1 << 1));\r\ndib7000p_write_word(state, 771, tmp);\r\nmsleep(40);\r\ntmp = dib7000p_read_word(state, 509);\r\n}\r\nif ((tmp >> 6) & 0x1) {\r\ndib7000p_update_timf(state);\r\ntmp = dib7000p_read_word(state, 26);\r\ndib7000p_write_word(state, 26, (tmp & ~(0xf << 12)) | ((((tmp >> 12) & 0xf) + 5) << 12));\r\n}\r\nif (state->cfg.spur_protect)\r\ndib7000p_spur_protect(state, ch->frequency / 1000, BANDWIDTH_TO_KHZ(ch->bandwidth_hz));\r\ndib7000p_set_bandwidth(state, BANDWIDTH_TO_KHZ(ch->bandwidth_hz));\r\nreturn 0;\r\n}\r\nstatic int dib7000p_wakeup(struct dvb_frontend *demod)\r\n{\r\nstruct dib7000p_state *state = demod->demodulator_priv;\r\ndib7000p_set_power_mode(state, DIB7000P_POWER_ALL);\r\ndib7000p_set_adc_state(state, DIBX000_SLOW_ADC_ON);\r\nif (state->version == SOC7090)\r\ndib7000p_sad_calib(state);\r\nreturn 0;\r\n}\r\nstatic int dib7000p_sleep(struct dvb_frontend *demod)\r\n{\r\nstruct dib7000p_state *state = demod->demodulator_priv;\r\nif (state->version == SOC7090)\r\nreturn dib7000p_set_power_mode(state, DIB7000P_POWER_INTERFACE_ONLY);\r\nreturn dib7000p_set_output_mode(state, OUTMODE_HIGH_Z) | dib7000p_set_power_mode(state, DIB7000P_POWER_INTERFACE_ONLY);\r\n}\r\nstatic int dib7000p_identify(struct dib7000p_state *st)\r\n{\r\nu16 value;\r\ndprintk("checking demod on I2C address: %d (%x)", st->i2c_addr, st->i2c_addr);\r\nif ((value = dib7000p_read_word(st, 768)) != 0x01b3) {\r\ndprintk("wrong Vendor ID (read=0x%x)", value);\r\nreturn -EREMOTEIO;\r\n}\r\nif ((value = dib7000p_read_word(st, 769)) != 0x4000) {\r\ndprintk("wrong Device ID (%x)", value);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib7000p_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *fep = &fe->dtv_property_cache;\r\nstruct dib7000p_state *state = fe->demodulator_priv;\r\nu16 tps = dib7000p_read_word(state, 463);\r\nfep->inversion = INVERSION_AUTO;\r\nfep->bandwidth_hz = BANDWIDTH_TO_HZ(state->current_bandwidth);\r\nswitch ((tps >> 8) & 0x3) {\r\ncase 0:\r\nfep->transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 1:\r\nfep->transmission_mode = TRANSMISSION_MODE_8K;\r\nbreak;\r\n}\r\nswitch (tps & 0x3) {\r\ncase 0:\r\nfep->guard_interval = GUARD_INTERVAL_1_32;\r\nbreak;\r\ncase 1:\r\nfep->guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\ncase 2:\r\nfep->guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\nfep->guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\n}\r\nswitch ((tps >> 14) & 0x3) {\r\ncase 0:\r\nfep->modulation = QPSK;\r\nbreak;\r\ncase 1:\r\nfep->modulation = QAM_16;\r\nbreak;\r\ncase 2:\r\ndefault:\r\nfep->modulation = QAM_64;\r\nbreak;\r\n}\r\nfep->hierarchy = HIERARCHY_NONE;\r\nswitch ((tps >> 5) & 0x7) {\r\ncase 1:\r\nfep->code_rate_HP = FEC_1_2;\r\nbreak;\r\ncase 2:\r\nfep->code_rate_HP = FEC_2_3;\r\nbreak;\r\ncase 3:\r\nfep->code_rate_HP = FEC_3_4;\r\nbreak;\r\ncase 5:\r\nfep->code_rate_HP = FEC_5_6;\r\nbreak;\r\ncase 7:\r\ndefault:\r\nfep->code_rate_HP = FEC_7_8;\r\nbreak;\r\n}\r\nswitch ((tps >> 2) & 0x7) {\r\ncase 1:\r\nfep->code_rate_LP = FEC_1_2;\r\nbreak;\r\ncase 2:\r\nfep->code_rate_LP = FEC_2_3;\r\nbreak;\r\ncase 3:\r\nfep->code_rate_LP = FEC_3_4;\r\nbreak;\r\ncase 5:\r\nfep->code_rate_LP = FEC_5_6;\r\nbreak;\r\ncase 7:\r\ndefault:\r\nfep->code_rate_LP = FEC_7_8;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib7000p_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *fep = &fe->dtv_property_cache;\r\nstruct dib7000p_state *state = fe->demodulator_priv;\r\nint time, ret;\r\nif (state->version == SOC7090)\r\ndib7090_set_diversity_in(fe, 0);\r\nelse\r\ndib7000p_set_output_mode(state, OUTMODE_HIGH_Z);\r\nstate->sfn_workaround_active = buggy_sfn_workaround;\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nstate->agc_state = 0;\r\ndo {\r\ntime = dib7000p_agc_startup(fe);\r\nif (time != -1)\r\nmsleep(time);\r\n} while (time != -1);\r\nif (fep->transmission_mode == TRANSMISSION_MODE_AUTO ||\r\nfep->guard_interval == GUARD_INTERVAL_AUTO || fep->modulation == QAM_AUTO || fep->code_rate_HP == FEC_AUTO) {\r\nint i = 800, found;\r\ndib7000p_autosearch_start(fe);\r\ndo {\r\nmsleep(1);\r\nfound = dib7000p_autosearch_is_irq(fe);\r\n} while (found == 0 && i--);\r\ndprintk("autosearch returns: %d", found);\r\nif (found == 0 || found == 1)\r\nreturn 0;\r\ndib7000p_get_frontend(fe);\r\n}\r\nret = dib7000p_tune(fe);\r\nif (state->version == SOC7090) {\r\ndib7090_set_output_mode(fe, state->cfg.output_mode);\r\nif (state->cfg.enMpegOutput == 0) {\r\ndib7090_setDibTxMux(state, MPEG_ON_DIBTX);\r\ndib7090_setHostBusMux(state, DIBTX_ON_HOSTBUS);\r\n}\r\n} else\r\ndib7000p_set_output_mode(state, state->cfg.output_mode);\r\nreturn ret;\r\n}\r\nstatic int dib7000p_read_status(struct dvb_frontend *fe, fe_status_t * stat)\r\n{\r\nstruct dib7000p_state *state = fe->demodulator_priv;\r\nu16 lock = dib7000p_read_word(state, 509);\r\n*stat = 0;\r\nif (lock & 0x8000)\r\n*stat |= FE_HAS_SIGNAL;\r\nif (lock & 0x3000)\r\n*stat |= FE_HAS_CARRIER;\r\nif (lock & 0x0100)\r\n*stat |= FE_HAS_VITERBI;\r\nif (lock & 0x0010)\r\n*stat |= FE_HAS_SYNC;\r\nif ((lock & 0x0038) == 0x38)\r\n*stat |= FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int dib7000p_read_ber(struct dvb_frontend *fe, u32 * ber)\r\n{\r\nstruct dib7000p_state *state = fe->demodulator_priv;\r\n*ber = (dib7000p_read_word(state, 500) << 16) | dib7000p_read_word(state, 501);\r\nreturn 0;\r\n}\r\nstatic int dib7000p_read_unc_blocks(struct dvb_frontend *fe, u32 * unc)\r\n{\r\nstruct dib7000p_state *state = fe->demodulator_priv;\r\n*unc = dib7000p_read_word(state, 506);\r\nreturn 0;\r\n}\r\nstatic int dib7000p_read_signal_strength(struct dvb_frontend *fe, u16 * strength)\r\n{\r\nstruct dib7000p_state *state = fe->demodulator_priv;\r\nu16 val = dib7000p_read_word(state, 394);\r\n*strength = 65535 - val;\r\nreturn 0;\r\n}\r\nstatic int dib7000p_read_snr(struct dvb_frontend *fe, u16 * snr)\r\n{\r\nstruct dib7000p_state *state = fe->demodulator_priv;\r\nu16 val;\r\ns32 signal_mant, signal_exp, noise_mant, noise_exp;\r\nu32 result = 0;\r\nval = dib7000p_read_word(state, 479);\r\nnoise_mant = (val >> 4) & 0xff;\r\nnoise_exp = ((val & 0xf) << 2);\r\nval = dib7000p_read_word(state, 480);\r\nnoise_exp += ((val >> 14) & 0x3);\r\nif ((noise_exp & 0x20) != 0)\r\nnoise_exp -= 0x40;\r\nsignal_mant = (val >> 6) & 0xFF;\r\nsignal_exp = (val & 0x3F);\r\nif ((signal_exp & 0x20) != 0)\r\nsignal_exp -= 0x40;\r\nif (signal_mant != 0)\r\nresult = intlog10(2) * 10 * signal_exp + 10 * intlog10(signal_mant);\r\nelse\r\nresult = intlog10(2) * 10 * signal_exp - 100;\r\nif (noise_mant != 0)\r\nresult -= intlog10(2) * 10 * noise_exp + 10 * intlog10(noise_mant);\r\nelse\r\nresult -= intlog10(2) * 10 * noise_exp - 100;\r\n*snr = result / ((1 << 24) / 10);\r\nreturn 0;\r\n}\r\nstatic int dib7000p_fe_get_tune_settings(struct dvb_frontend *fe, struct dvb_frontend_tune_settings *tune)\r\n{\r\ntune->min_delay_ms = 1000;\r\nreturn 0;\r\n}\r\nstatic void dib7000p_release(struct dvb_frontend *demod)\r\n{\r\nstruct dib7000p_state *st = demod->demodulator_priv;\r\ndibx000_exit_i2c_master(&st->i2c_master);\r\ni2c_del_adapter(&st->dib7090_tuner_adap);\r\nkfree(st);\r\n}\r\nint dib7000pc_detection(struct i2c_adapter *i2c_adap)\r\n{\r\nu8 *tx, *rx;\r\nstruct i2c_msg msg[2] = {\r\n{.addr = 18 >> 1, .flags = 0, .len = 2},\r\n{.addr = 18 >> 1, .flags = I2C_M_RD, .len = 2},\r\n};\r\nint ret = 0;\r\ntx = kzalloc(2*sizeof(u8), GFP_KERNEL);\r\nif (!tx)\r\nreturn -ENOMEM;\r\nrx = kzalloc(2*sizeof(u8), GFP_KERNEL);\r\nif (!rx) {\r\nret = -ENOMEM;\r\ngoto rx_memory_error;\r\n}\r\nmsg[0].buf = tx;\r\nmsg[1].buf = rx;\r\ntx[0] = 0x03;\r\ntx[1] = 0x00;\r\nif (i2c_transfer(i2c_adap, msg, 2) == 2)\r\nif (rx[0] == 0x01 && rx[1] == 0xb3) {\r\ndprintk("-D- DiB7000PC detected");\r\nreturn 1;\r\n}\r\nmsg[0].addr = msg[1].addr = 0x40;\r\nif (i2c_transfer(i2c_adap, msg, 2) == 2)\r\nif (rx[0] == 0x01 && rx[1] == 0xb3) {\r\ndprintk("-D- DiB7000PC detected");\r\nreturn 1;\r\n}\r\ndprintk("-D- DiB7000PC not detected");\r\nkfree(rx);\r\nrx_memory_error:\r\nkfree(tx);\r\nreturn ret;\r\n}\r\nstruct i2c_adapter *dib7000p_get_i2c_master(struct dvb_frontend *demod, enum dibx000_i2c_interface intf, int gating)\r\n{\r\nstruct dib7000p_state *st = demod->demodulator_priv;\r\nreturn dibx000_get_i2c_adapter(&st->i2c_master, intf, gating);\r\n}\r\nint dib7000p_pid_filter_ctrl(struct dvb_frontend *fe, u8 onoff)\r\n{\r\nstruct dib7000p_state *state = fe->demodulator_priv;\r\nu16 val = dib7000p_read_word(state, 235) & 0xffef;\r\nval |= (onoff & 0x1) << 4;\r\ndprintk("PID filter enabled %d", onoff);\r\nreturn dib7000p_write_word(state, 235, val);\r\n}\r\nint dib7000p_pid_filter(struct dvb_frontend *fe, u8 id, u16 pid, u8 onoff)\r\n{\r\nstruct dib7000p_state *state = fe->demodulator_priv;\r\ndprintk("PID filter: index %x, PID %d, OnOff %d", id, pid, onoff);\r\nreturn dib7000p_write_word(state, 241 + id, onoff ? (1 << 13) | pid : 0);\r\n}\r\nint dib7000p_i2c_enumeration(struct i2c_adapter *i2c, int no_of_demods, u8 default_addr, struct dib7000p_config cfg[])\r\n{\r\nstruct dib7000p_state *dpst;\r\nint k = 0;\r\nu8 new_addr = 0;\r\ndpst = kzalloc(sizeof(struct dib7000p_state), GFP_KERNEL);\r\nif (!dpst)\r\nreturn -ENOMEM;\r\ndpst->i2c_adap = i2c;\r\nmutex_init(&dpst->i2c_buffer_lock);\r\nfor (k = no_of_demods - 1; k >= 0; k--) {\r\ndpst->cfg = cfg[k];\r\nif (cfg[k].default_i2c_addr != 0)\r\nnew_addr = cfg[k].default_i2c_addr + (k << 1);\r\nelse\r\nnew_addr = (0x40 + k) << 1;\r\ndpst->i2c_addr = new_addr;\r\ndib7000p_write_word(dpst, 1287, 0x0003);\r\nif (dib7000p_identify(dpst) != 0) {\r\ndpst->i2c_addr = default_addr;\r\ndib7000p_write_word(dpst, 1287, 0x0003);\r\nif (dib7000p_identify(dpst) != 0) {\r\ndprintk("DiB7000P #%d: not identified\n", k);\r\nkfree(dpst);\r\nreturn -EIO;\r\n}\r\n}\r\ndib7000p_set_output_mode(dpst, OUTMODE_DIVERSITY);\r\ndib7000p_write_word(dpst, 1285, (new_addr << 2) | 0x2);\r\ndprintk("IC %d initialized (to i2c_address 0x%x)", k, new_addr);\r\n}\r\nfor (k = 0; k < no_of_demods; k++) {\r\ndpst->cfg = cfg[k];\r\nif (cfg[k].default_i2c_addr != 0)\r\ndpst->i2c_addr = (cfg[k].default_i2c_addr + k) << 1;\r\nelse\r\ndpst->i2c_addr = (0x40 + k) << 1;\r\ndib7000p_write_word(dpst, 1285, dpst->i2c_addr << 2);\r\ndib7000p_set_output_mode(dpst, OUTMODE_HIGH_Z);\r\n}\r\nkfree(dpst);\r\nreturn 0;\r\n}\r\nstatic s32 dib7000p_get_adc_power(struct dvb_frontend *fe)\r\n{\r\nstruct dib7000p_state *state = fe->demodulator_priv;\r\nu32 tmp_val = 0, exp = 0, mant = 0;\r\ns32 pow_i;\r\nu16 buf[2];\r\nu8 ix = 0;\r\nbuf[0] = dib7000p_read_word(state, 0x184);\r\nbuf[1] = dib7000p_read_word(state, 0x185);\r\npow_i = (buf[0] << 16) | buf[1];\r\ndprintk("raw pow_i = %d", pow_i);\r\ntmp_val = pow_i;\r\nwhile (tmp_val >>= 1)\r\nexp++;\r\nmant = (pow_i * 1000 / (1 << exp));\r\ndprintk(" mant = %d exp = %d", mant / 1000, exp);\r\nix = (u8) ((mant - 1000) / 100);\r\ndprintk(" ix = %d", ix);\r\npow_i = (lut_1000ln_mant[ix] + 693 * (exp - 20) - 6908);\r\npow_i = (pow_i << 8) / 1000;\r\ndprintk(" pow_i = %d", pow_i);\r\nreturn pow_i;\r\n}\r\nstatic int map_addr_to_serpar_number(struct i2c_msg *msg)\r\n{\r\nif ((msg->buf[0] <= 15))\r\nmsg->buf[0] -= 1;\r\nelse if (msg->buf[0] == 17)\r\nmsg->buf[0] = 15;\r\nelse if (msg->buf[0] == 16)\r\nmsg->buf[0] = 17;\r\nelse if (msg->buf[0] == 19)\r\nmsg->buf[0] = 16;\r\nelse if (msg->buf[0] >= 21 && msg->buf[0] <= 25)\r\nmsg->buf[0] -= 3;\r\nelse if (msg->buf[0] == 28)\r\nmsg->buf[0] = 23;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int w7090p_tuner_write_serpar(struct i2c_adapter *i2c_adap, struct i2c_msg msg[], int num)\r\n{\r\nstruct dib7000p_state *state = i2c_get_adapdata(i2c_adap);\r\nu8 n_overflow = 1;\r\nu16 i = 1000;\r\nu16 serpar_num = msg[0].buf[0];\r\nwhile (n_overflow == 1 && i) {\r\nn_overflow = (dib7000p_read_word(state, 1984) >> 1) & 0x1;\r\ni--;\r\nif (i == 0)\r\ndprintk("Tuner ITF: write busy (overflow)");\r\n}\r\ndib7000p_write_word(state, 1985, (1 << 6) | (serpar_num & 0x3f));\r\ndib7000p_write_word(state, 1986, (msg[0].buf[1] << 8) | msg[0].buf[2]);\r\nreturn num;\r\n}\r\nstatic int w7090p_tuner_read_serpar(struct i2c_adapter *i2c_adap, struct i2c_msg msg[], int num)\r\n{\r\nstruct dib7000p_state *state = i2c_get_adapdata(i2c_adap);\r\nu8 n_overflow = 1, n_empty = 1;\r\nu16 i = 1000;\r\nu16 serpar_num = msg[0].buf[0];\r\nu16 read_word;\r\nwhile (n_overflow == 1 && i) {\r\nn_overflow = (dib7000p_read_word(state, 1984) >> 1) & 0x1;\r\ni--;\r\nif (i == 0)\r\ndprintk("TunerITF: read busy (overflow)");\r\n}\r\ndib7000p_write_word(state, 1985, (0 << 6) | (serpar_num & 0x3f));\r\ni = 1000;\r\nwhile (n_empty == 1 && i) {\r\nn_empty = dib7000p_read_word(state, 1984) & 0x1;\r\ni--;\r\nif (i == 0)\r\ndprintk("TunerITF: read busy (empty)");\r\n}\r\nread_word = dib7000p_read_word(state, 1987);\r\nmsg[1].buf[0] = (read_word >> 8) & 0xff;\r\nmsg[1].buf[1] = (read_word) & 0xff;\r\nreturn num;\r\n}\r\nstatic int w7090p_tuner_rw_serpar(struct i2c_adapter *i2c_adap, struct i2c_msg msg[], int num)\r\n{\r\nif (map_addr_to_serpar_number(&msg[0]) == 0) {\r\nif (num == 1) {\r\nreturn w7090p_tuner_write_serpar(i2c_adap, msg, 1);\r\n} else {\r\nreturn w7090p_tuner_read_serpar(i2c_adap, msg, 2);\r\n}\r\n}\r\nreturn num;\r\n}\r\nstatic int dib7090p_rw_on_apb(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msg[], int num, u16 apb_address)\r\n{\r\nstruct dib7000p_state *state = i2c_get_adapdata(i2c_adap);\r\nu16 word;\r\nif (num == 1) {\r\ndib7000p_write_word(state, apb_address, ((msg[0].buf[1] << 8) | (msg[0].buf[2])));\r\n} else {\r\nword = dib7000p_read_word(state, apb_address);\r\nmsg[1].buf[0] = (word >> 8) & 0xff;\r\nmsg[1].buf[1] = (word) & 0xff;\r\n}\r\nreturn num;\r\n}\r\nstatic int dib7090_tuner_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msg[], int num)\r\n{\r\nstruct dib7000p_state *state = i2c_get_adapdata(i2c_adap);\r\nu16 apb_address = 0, word;\r\nint i = 0;\r\nswitch (msg[0].buf[0]) {\r\ncase 0x12:\r\napb_address = 1920;\r\nbreak;\r\ncase 0x14:\r\napb_address = 1921;\r\nbreak;\r\ncase 0x24:\r\napb_address = 1922;\r\nbreak;\r\ncase 0x1a:\r\napb_address = 1923;\r\nbreak;\r\ncase 0x22:\r\napb_address = 1924;\r\nbreak;\r\ncase 0x33:\r\napb_address = 1926;\r\nbreak;\r\ncase 0x34:\r\napb_address = 1927;\r\nbreak;\r\ncase 0x35:\r\napb_address = 1928;\r\nbreak;\r\ncase 0x36:\r\napb_address = 1929;\r\nbreak;\r\ncase 0x37:\r\napb_address = 1930;\r\nbreak;\r\ncase 0x38:\r\napb_address = 1931;\r\nbreak;\r\ncase 0x39:\r\napb_address = 1932;\r\nbreak;\r\ncase 0x2a:\r\napb_address = 1935;\r\nbreak;\r\ncase 0x2b:\r\napb_address = 1936;\r\nbreak;\r\ncase 0x2c:\r\napb_address = 1937;\r\nbreak;\r\ncase 0x2d:\r\napb_address = 1938;\r\nbreak;\r\ncase 0x2e:\r\napb_address = 1939;\r\nbreak;\r\ncase 0x2f:\r\napb_address = 1940;\r\nbreak;\r\ncase 0x30:\r\napb_address = 1941;\r\nbreak;\r\ncase 0x31:\r\napb_address = 1942;\r\nbreak;\r\ncase 0x32:\r\napb_address = 1943;\r\nbreak;\r\ncase 0x3e:\r\napb_address = 1944;\r\nbreak;\r\ncase 0x3f:\r\napb_address = 1945;\r\nbreak;\r\ncase 0x40:\r\napb_address = 1948;\r\nbreak;\r\ncase 0x25:\r\napb_address = 914;\r\nbreak;\r\ncase 0x26:\r\napb_address = 915;\r\nbreak;\r\ncase 0x27:\r\napb_address = 917;\r\nbreak;\r\ncase 0x28:\r\napb_address = 916;\r\nbreak;\r\ncase 0x1d:\r\ni = ((dib7000p_read_word(state, 72) >> 12) & 0x3);\r\nword = dib7000p_read_word(state, 384 + i);\r\nmsg[1].buf[0] = (word >> 8) & 0xff;\r\nmsg[1].buf[1] = (word) & 0xff;\r\nreturn num;\r\ncase 0x1f:\r\nif (num == 1) {\r\nword = (u16) ((msg[0].buf[1] << 8) | msg[0].buf[2]);\r\nword &= 0x3;\r\nword = (dib7000p_read_word(state, 72) & ~(3 << 12)) | (word << 12);\r\ndib7000p_write_word(state, 72, word);\r\nreturn num;\r\n}\r\n}\r\nif (apb_address != 0)\r\nreturn dib7090p_rw_on_apb(i2c_adap, msg, num, apb_address);\r\nelse\r\nreturn w7090p_tuner_rw_serpar(i2c_adap, msg, num);\r\nreturn 0;\r\n}\r\nstatic u32 dib7000p_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstruct i2c_adapter *dib7090_get_i2c_tuner(struct dvb_frontend *fe)\r\n{\r\nstruct dib7000p_state *st = fe->demodulator_priv;\r\nreturn &st->dib7090_tuner_adap;\r\n}\r\nstatic int dib7090_host_bus_drive(struct dib7000p_state *state, u8 drive)\r\n{\r\nu16 reg;\r\nreg = dib7000p_read_word(state, 1798) & ~((0x7) | (0x7 << 6) | (0x7 << 12));\r\nreg |= (drive << 12) | (drive << 6) | drive;\r\ndib7000p_write_word(state, 1798, reg);\r\nreg = dib7000p_read_word(state, 1799) & ~((0x7 << 2) | (0x7 << 8));\r\nreg |= (drive << 8) | (drive << 2);\r\ndib7000p_write_word(state, 1799, reg);\r\nreg = dib7000p_read_word(state, 1800) & ~((0x7) | (0x7 << 6) | (0x7 << 12));\r\nreg |= (drive << 12) | (drive << 6) | drive;\r\ndib7000p_write_word(state, 1800, reg);\r\nreg = dib7000p_read_word(state, 1801) & ~((0x7 << 2) | (0x7 << 8));\r\nreg |= (drive << 8) | (drive << 2);\r\ndib7000p_write_word(state, 1801, reg);\r\nreg = dib7000p_read_word(state, 1802) & ~((0x7) | (0x7 << 6) | (0x7 << 12));\r\nreg |= (drive << 12) | (drive << 6) | drive;\r\ndib7000p_write_word(state, 1802, reg);\r\nreturn 0;\r\n}\r\nstatic u32 dib7090_calcSyncFreq(u32 P_Kin, u32 P_Kout, u32 insertExtSynchro, u32 syncSize)\r\n{\r\nu32 quantif = 3;\r\nu32 nom = (insertExtSynchro * P_Kin + syncSize);\r\nu32 denom = P_Kout;\r\nu32 syncFreq = ((nom << quantif) / denom);\r\nif ((syncFreq & ((1 << quantif) - 1)) != 0)\r\nsyncFreq = (syncFreq >> quantif) + 1;\r\nelse\r\nsyncFreq = (syncFreq >> quantif);\r\nif (syncFreq != 0)\r\nsyncFreq = syncFreq - 1;\r\nreturn syncFreq;\r\n}\r\nstatic int dib7090_cfg_DibTx(struct dib7000p_state *state, u32 P_Kin, u32 P_Kout, u32 insertExtSynchro, u32 synchroMode, u32 syncWord, u32 syncSize)\r\n{\r\ndprintk("Configure DibStream Tx");\r\ndib7000p_write_word(state, 1615, 1);\r\ndib7000p_write_word(state, 1603, P_Kin);\r\ndib7000p_write_word(state, 1605, P_Kout);\r\ndib7000p_write_word(state, 1606, insertExtSynchro);\r\ndib7000p_write_word(state, 1608, synchroMode);\r\ndib7000p_write_word(state, 1609, (syncWord >> 16) & 0xffff);\r\ndib7000p_write_word(state, 1610, syncWord & 0xffff);\r\ndib7000p_write_word(state, 1612, syncSize);\r\ndib7000p_write_word(state, 1615, 0);\r\nreturn 0;\r\n}\r\nstatic int dib7090_cfg_DibRx(struct dib7000p_state *state, u32 P_Kin, u32 P_Kout, u32 synchroMode, u32 insertExtSynchro, u32 syncWord, u32 syncSize,\r\nu32 dataOutRate)\r\n{\r\nu32 syncFreq;\r\ndprintk("Configure DibStream Rx");\r\nif ((P_Kin != 0) && (P_Kout != 0)) {\r\nsyncFreq = dib7090_calcSyncFreq(P_Kin, P_Kout, insertExtSynchro, syncSize);\r\ndib7000p_write_word(state, 1542, syncFreq);\r\n}\r\ndib7000p_write_word(state, 1554, 1);\r\ndib7000p_write_word(state, 1536, P_Kin);\r\ndib7000p_write_word(state, 1537, P_Kout);\r\ndib7000p_write_word(state, 1539, synchroMode);\r\ndib7000p_write_word(state, 1540, (syncWord >> 16) & 0xffff);\r\ndib7000p_write_word(state, 1541, syncWord & 0xffff);\r\ndib7000p_write_word(state, 1543, syncSize);\r\ndib7000p_write_word(state, 1544, dataOutRate);\r\ndib7000p_write_word(state, 1554, 0);\r\nreturn 0;\r\n}\r\nstatic void dib7090_enMpegMux(struct dib7000p_state *state, int onoff)\r\n{\r\nu16 reg_1287 = dib7000p_read_word(state, 1287);\r\nswitch (onoff) {\r\ncase 1:\r\nreg_1287 &= ~(1<<7);\r\nbreak;\r\ncase 0:\r\nreg_1287 |= (1<<7);\r\nbreak;\r\n}\r\ndib7000p_write_word(state, 1287, reg_1287);\r\n}\r\nstatic void dib7090_configMpegMux(struct dib7000p_state *state,\r\nu16 pulseWidth, u16 enSerialMode, u16 enSerialClkDiv2)\r\n{\r\ndprintk("Enable Mpeg mux");\r\ndib7090_enMpegMux(state, 0);\r\nif ((enSerialMode == 1) && (state->input_mode_mpeg == 1))\r\nenSerialClkDiv2 = 0;\r\ndib7000p_write_word(state, 1287, ((pulseWidth & 0x1f) << 2)\r\n| ((enSerialMode & 0x1) << 1)\r\n| (enSerialClkDiv2 & 0x1));\r\ndib7090_enMpegMux(state, 1);\r\n}\r\nstatic void dib7090_setDibTxMux(struct dib7000p_state *state, int mode)\r\n{\r\nu16 reg_1288 = dib7000p_read_word(state, 1288) & ~(0x7 << 7);\r\nswitch (mode) {\r\ncase MPEG_ON_DIBTX:\r\ndprintk("SET MPEG ON DIBSTREAM TX");\r\ndib7090_cfg_DibTx(state, 8, 5, 0, 0, 0, 0);\r\nreg_1288 |= (1<<9);\r\nbreak;\r\ncase DIV_ON_DIBTX:\r\ndprintk("SET DIV_OUT ON DIBSTREAM TX");\r\ndib7090_cfg_DibTx(state, 5, 5, 0, 0, 0, 0);\r\nreg_1288 |= (1<<8);\r\nbreak;\r\ncase ADC_ON_DIBTX:\r\ndprintk("SET ADC_OUT ON DIBSTREAM TX");\r\ndib7090_cfg_DibTx(state, 20, 5, 10, 0, 0, 0);\r\nreg_1288 |= (1<<7);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndib7000p_write_word(state, 1288, reg_1288);\r\n}\r\nstatic void dib7090_setHostBusMux(struct dib7000p_state *state, int mode)\r\n{\r\nu16 reg_1288 = dib7000p_read_word(state, 1288) & ~(0x7 << 4);\r\nswitch (mode) {\r\ncase DEMOUT_ON_HOSTBUS:\r\ndprintk("SET DEM OUT OLD INTERF ON HOST BUS");\r\ndib7090_enMpegMux(state, 0);\r\nreg_1288 |= (1<<6);\r\nbreak;\r\ncase DIBTX_ON_HOSTBUS:\r\ndprintk("SET DIBSTREAM TX ON HOST BUS");\r\ndib7090_enMpegMux(state, 0);\r\nreg_1288 |= (1<<5);\r\nbreak;\r\ncase MPEG_ON_HOSTBUS:\r\ndprintk("SET MPEG MUX ON HOST BUS");\r\nreg_1288 |= (1<<4);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndib7000p_write_word(state, 1288, reg_1288);\r\n}\r\nint dib7090_set_diversity_in(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dib7000p_state *state = fe->demodulator_priv;\r\nu16 reg_1287;\r\nswitch (onoff) {\r\ncase 0:\r\ndprintk("%s mode OFF : by default Enable Mpeg INPUT", __func__);\r\ndib7090_cfg_DibRx(state, 8, 5, 0, 0, 0, 8, 0);\r\nreg_1287 = dib7000p_read_word(state, 1287);\r\nif ((reg_1287 & 0x1) == 1) {\r\nreg_1287 &= ~0x1;\r\ndib7000p_write_word(state, 1287, reg_1287);\r\n}\r\nstate->input_mode_mpeg = 1;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\ndprintk("%s ON : Enable diversity INPUT", __func__);\r\ndib7090_cfg_DibRx(state, 5, 5, 0, 0, 0, 0, 0);\r\nstate->input_mode_mpeg = 0;\r\nbreak;\r\n}\r\ndib7000p_set_diversity_in(&state->demod, onoff);\r\nreturn 0;\r\n}\r\nstatic int dib7090_set_output_mode(struct dvb_frontend *fe, int mode)\r\n{\r\nstruct dib7000p_state *state = fe->demodulator_priv;\r\nu16 outreg, smo_mode, fifo_threshold;\r\nu8 prefer_mpeg_mux_use = 1;\r\nint ret = 0;\r\ndib7090_host_bus_drive(state, 1);\r\nfifo_threshold = 1792;\r\nsmo_mode = (dib7000p_read_word(state, 235) & 0x0050) | (1 << 1);\r\noutreg = dib7000p_read_word(state, 1286) & ~((1 << 10) | (0x7 << 6) | (1 << 1));\r\nswitch (mode) {\r\ncase OUTMODE_HIGH_Z:\r\noutreg = 0;\r\nbreak;\r\ncase OUTMODE_MPEG2_SERIAL:\r\nif (prefer_mpeg_mux_use) {\r\ndprintk("setting output mode TS_SERIAL using Mpeg Mux");\r\ndib7090_configMpegMux(state, 3, 1, 1);\r\ndib7090_setHostBusMux(state, MPEG_ON_HOSTBUS);\r\n} else {\r\ndprintk("setting output mode TS_SERIAL using Smooth bloc");\r\ndib7090_setHostBusMux(state, DEMOUT_ON_HOSTBUS);\r\noutreg |= (2<<6) | (0 << 1);\r\n}\r\nbreak;\r\ncase OUTMODE_MPEG2_PAR_GATED_CLK:\r\nif (prefer_mpeg_mux_use) {\r\ndprintk("setting output mode TS_PARALLEL_GATED using Mpeg Mux");\r\ndib7090_configMpegMux(state, 2, 0, 0);\r\ndib7090_setHostBusMux(state, MPEG_ON_HOSTBUS);\r\n} else {\r\ndprintk("setting output mode TS_PARALLEL_GATED using Smooth block");\r\ndib7090_setHostBusMux(state, DEMOUT_ON_HOSTBUS);\r\noutreg |= (0<<6);\r\n}\r\nbreak;\r\ncase OUTMODE_MPEG2_PAR_CONT_CLK:\r\ndprintk("setting output mode TS_PARALLEL_CONT using Smooth block");\r\ndib7090_setHostBusMux(state, DEMOUT_ON_HOSTBUS);\r\noutreg |= (1<<6);\r\nbreak;\r\ncase OUTMODE_MPEG2_FIFO:\r\ndprintk("setting output mode TS_FIFO using Smooth block");\r\ndib7090_setHostBusMux(state, DEMOUT_ON_HOSTBUS);\r\noutreg |= (5<<6);\r\nsmo_mode |= (3 << 1);\r\nfifo_threshold = 512;\r\nbreak;\r\ncase OUTMODE_DIVERSITY:\r\ndprintk("setting output mode MODE_DIVERSITY");\r\ndib7090_setDibTxMux(state, DIV_ON_DIBTX);\r\ndib7090_setHostBusMux(state, DIBTX_ON_HOSTBUS);\r\nbreak;\r\ncase OUTMODE_ANALOG_ADC:\r\ndprintk("setting output mode MODE_ANALOG_ADC");\r\ndib7090_setDibTxMux(state, ADC_ON_DIBTX);\r\ndib7090_setHostBusMux(state, DIBTX_ON_HOSTBUS);\r\nbreak;\r\n}\r\nif (mode != OUTMODE_HIGH_Z)\r\noutreg |= (1 << 10);\r\nif (state->cfg.output_mpeg2_in_188_bytes)\r\nsmo_mode |= (1 << 5);\r\nret |= dib7000p_write_word(state, 235, smo_mode);\r\nret |= dib7000p_write_word(state, 236, fifo_threshold);\r\nret |= dib7000p_write_word(state, 1286, outreg);\r\nreturn ret;\r\n}\r\nint dib7090_tuner_sleep(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dib7000p_state *state = fe->demodulator_priv;\r\nu16 en_cur_state;\r\ndprintk("sleep dib7090: %d", onoff);\r\nen_cur_state = dib7000p_read_word(state, 1922);\r\nif (en_cur_state > 0xff)\r\nstate->tuner_enable = en_cur_state;\r\nif (onoff)\r\nen_cur_state &= 0x00ff;\r\nelse {\r\nif (state->tuner_enable != 0)\r\nen_cur_state = state->tuner_enable;\r\n}\r\ndib7000p_write_word(state, 1922, en_cur_state);\r\nreturn 0;\r\n}\r\nint dib7090_get_adc_power(struct dvb_frontend *fe)\r\n{\r\nreturn dib7000p_get_adc_power(fe);\r\n}\r\nint dib7090_slave_reset(struct dvb_frontend *fe)\r\n{\r\nstruct dib7000p_state *state = fe->demodulator_priv;\r\nu16 reg;\r\nreg = dib7000p_read_word(state, 1794);\r\ndib7000p_write_word(state, 1794, reg | (4 << 12));\r\ndib7000p_write_word(state, 1032, 0xffff);\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *dib7000p_attach(struct i2c_adapter *i2c_adap, u8 i2c_addr, struct dib7000p_config *cfg)\r\n{\r\nstruct dvb_frontend *demod;\r\nstruct dib7000p_state *st;\r\nst = kzalloc(sizeof(struct dib7000p_state), GFP_KERNEL);\r\nif (st == NULL)\r\nreturn NULL;\r\nmemcpy(&st->cfg, cfg, sizeof(struct dib7000p_config));\r\nst->i2c_adap = i2c_adap;\r\nst->i2c_addr = i2c_addr;\r\nst->gpio_val = cfg->gpio_val;\r\nst->gpio_dir = cfg->gpio_dir;\r\nif ((st->cfg.output_mode != OUTMODE_MPEG2_SERIAL) && (st->cfg.output_mode != OUTMODE_MPEG2_PAR_GATED_CLK))\r\nst->cfg.output_mode = OUTMODE_MPEG2_FIFO;\r\ndemod = &st->demod;\r\ndemod->demodulator_priv = st;\r\nmemcpy(&st->demod.ops, &dib7000p_ops, sizeof(struct dvb_frontend_ops));\r\nmutex_init(&st->i2c_buffer_lock);\r\ndib7000p_write_word(st, 1287, 0x0003);\r\nif (dib7000p_identify(st) != 0)\r\ngoto error;\r\nst->version = dib7000p_read_word(st, 897);\r\nst->i2c_master.gated_tuner_i2c_adap.dev.parent = i2c_adap->dev.parent;\r\nst->i2c_master.gated_tuner_i2c_adap.dev.parent = i2c_adap->dev.parent;\r\ndibx000_init_i2c_master(&st->i2c_master, DIB7000P, st->i2c_adap, st->i2c_addr);\r\nstrncpy(st->dib7090_tuner_adap.name, "DiB7090 tuner interface", sizeof(st->dib7090_tuner_adap.name));\r\nst->dib7090_tuner_adap.algo = &dib7090_tuner_xfer_algo;\r\nst->dib7090_tuner_adap.algo_data = NULL;\r\nst->dib7090_tuner_adap.dev.parent = st->i2c_adap->dev.parent;\r\ni2c_set_adapdata(&st->dib7090_tuner_adap, st);\r\ni2c_add_adapter(&st->dib7090_tuner_adap);\r\ndib7000p_demod_reset(st);\r\nif (st->version == SOC7090) {\r\ndib7090_set_output_mode(demod, st->cfg.output_mode);\r\ndib7090_set_diversity_in(demod, 0);\r\n}\r\nreturn demod;\r\nerror:\r\nkfree(st);\r\nreturn NULL;\r\n}
