static inline unsigned long\r\ngc_readl(struct pxa3xx_gcu_priv *priv, unsigned int off)\r\n{\r\nreturn __raw_readl(priv->mmio_base + off);\r\n}\r\nstatic inline void\r\ngc_writel(struct pxa3xx_gcu_priv *priv, unsigned int off, unsigned long val)\r\n{\r\n__raw_writel(val, priv->mmio_base + off);\r\n}\r\nstatic void\r\npxa3xx_gcu_reset(struct pxa3xx_gcu_priv *priv)\r\n{\r\nQDUMP("RESET");\r\ngc_writel(priv, REG_GCIECR, 0);\r\ngc_writel(priv, REG_GCCR, GCCR_ABORT);\r\ngc_writel(priv, REG_GCCR, 0);\r\nmemset(priv->shared, 0, SHARED_SIZE);\r\npriv->shared->buffer_phys = priv->shared_phys;\r\npriv->shared->magic = PXA3XX_GCU_SHARED_MAGIC;\r\ndo_gettimeofday(&priv->base_time);\r\ngc_writel(priv, REG_GCRBLR, 0);\r\ngc_writel(priv, REG_GCRBBR, priv->shared_phys);\r\ngc_writel(priv, REG_GCRBTR, priv->shared_phys);\r\ngc_writel(priv, REG_GCIECR, IE_ALL & ~IE_EOB);\r\n}\r\nstatic void\r\ndump_whole_state(struct pxa3xx_gcu_priv *priv)\r\n{\r\nstruct pxa3xx_gcu_shared *sh = priv->shared;\r\nu32 base = gc_readl(priv, REG_GCRBBR);\r\nQDUMP("DUMP");\r\nprintk(KERN_DEBUG "== PXA3XX-GCU DUMP ==\n"\r\n"%s, STATUS 0x%02lx, B 0x%08lx [%ld], E %5ld, H %5ld, T %5ld\n",\r\nsh->hw_running ? "running" : "idle ",\r\ngc_readl(priv, REG_GCISCR),\r\ngc_readl(priv, REG_GCRBBR),\r\ngc_readl(priv, REG_GCRBLR),\r\n(gc_readl(priv, REG_GCRBEXHR) - base) / 4,\r\n(gc_readl(priv, REG_GCRBHR) - base) / 4,\r\n(gc_readl(priv, REG_GCRBTR) - base) / 4);\r\n}\r\nstatic void\r\nflush_running(struct pxa3xx_gcu_priv *priv)\r\n{\r\nstruct pxa3xx_gcu_batch *running = priv->running;\r\nstruct pxa3xx_gcu_batch *next;\r\nwhile (running) {\r\nnext = running->next;\r\nrunning->next = priv->free;\r\npriv->free = running;\r\nrunning = next;\r\n}\r\npriv->running = NULL;\r\n}\r\nstatic void\r\nrun_ready(struct pxa3xx_gcu_priv *priv)\r\n{\r\nunsigned int num = 0;\r\nstruct pxa3xx_gcu_shared *shared = priv->shared;\r\nstruct pxa3xx_gcu_batch *ready = priv->ready;\r\nQDUMP("Start");\r\nBUG_ON(!ready);\r\nshared->buffer[num++] = 0x05000000;\r\nwhile (ready) {\r\nshared->buffer[num++] = 0x00000001;\r\nshared->buffer[num++] = ready->phys;\r\nready = ready->next;\r\n}\r\nshared->buffer[num++] = 0x05000000;\r\npriv->running = priv->ready;\r\npriv->ready = priv->ready_last = NULL;\r\ngc_writel(priv, REG_GCRBLR, 0);\r\nshared->hw_running = 1;\r\ngc_writel(priv, REG_GCRBBR, shared->buffer_phys);\r\ngc_writel(priv, REG_GCRBTR, shared->buffer_phys + num * 4);\r\ngc_writel(priv, REG_GCRBLR, ((num + 63) & ~63) * 4);\r\n}\r\nstatic irqreturn_t\r\npxa3xx_gcu_handle_irq(int irq, void *ctx)\r\n{\r\nstruct pxa3xx_gcu_priv *priv = ctx;\r\nstruct pxa3xx_gcu_shared *shared = priv->shared;\r\nu32 status = gc_readl(priv, REG_GCISCR) & IE_ALL;\r\nQDUMP("-Interrupt");\r\nif (!status)\r\nreturn IRQ_NONE;\r\nspin_lock(&priv->spinlock);\r\nshared->num_interrupts++;\r\nif (status & IE_EEOB) {\r\nQDUMP(" [EEOB]");\r\nflush_running(priv);\r\nwake_up_all(&priv->wait_free);\r\nif (priv->ready) {\r\nrun_ready(priv);\r\n} else {\r\nshared->num_idle++;\r\nshared->hw_running = 0;\r\nQDUMP(" '-> Idle.");\r\ngc_writel(priv, REG_GCRBLR, 0);\r\nwake_up_all(&priv->wait_idle);\r\n}\r\nshared->num_done++;\r\n} else {\r\nQERROR(" [???]");\r\ndump_whole_state(priv);\r\n}\r\ngc_writel(priv, REG_GCISCR, status);\r\nspin_unlock(&priv->spinlock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\npxa3xx_gcu_wait_idle(struct pxa3xx_gcu_priv *priv)\r\n{\r\nint ret = 0;\r\nQDUMP("Waiting for idle...");\r\npriv->shared->num_wait_idle++;\r\nwhile (priv->shared->hw_running) {\r\nint num = priv->shared->num_interrupts;\r\nu32 rbexhr = gc_readl(priv, REG_GCRBEXHR);\r\nret = wait_event_interruptible_timeout(priv->wait_idle,\r\n!priv->shared->hw_running, HZ*4);\r\nif (ret < 0)\r\nbreak;\r\nif (ret > 0)\r\ncontinue;\r\nif (gc_readl(priv, REG_GCRBEXHR) == rbexhr &&\r\npriv->shared->num_interrupts == num) {\r\nQERROR("TIMEOUT");\r\nret = -ETIMEDOUT;\r\nbreak;\r\n}\r\n}\r\nQDUMP("done");\r\nreturn ret;\r\n}\r\nstatic int\r\npxa3xx_gcu_wait_free(struct pxa3xx_gcu_priv *priv)\r\n{\r\nint ret = 0;\r\nQDUMP("Waiting for free...");\r\npriv->shared->num_wait_free++;\r\nwhile (!priv->free) {\r\nu32 rbexhr = gc_readl(priv, REG_GCRBEXHR);\r\nret = wait_event_interruptible_timeout(priv->wait_free,\r\npriv->free, HZ*4);\r\nif (ret < 0)\r\nbreak;\r\nif (ret > 0)\r\ncontinue;\r\nif (gc_readl(priv, REG_GCRBEXHR) == rbexhr) {\r\nQERROR("TIMEOUT");\r\nret = -ETIMEDOUT;\r\nbreak;\r\n}\r\n}\r\nQDUMP("done");\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\npxa3xx_gcu_misc_write(struct file *filp, const char *buff,\r\nsize_t count, loff_t *offp)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nstruct pxa3xx_gcu_batch *buffer;\r\nstruct pxa3xx_gcu_priv *priv =\r\ncontainer_of(filp->f_op, struct pxa3xx_gcu_priv, misc_fops);\r\nint words = count / 4;\r\npriv->shared->num_writes++;\r\npriv->shared->num_words += words;\r\nif (words >= PXA3XX_GCU_BATCH_WORDS)\r\nreturn -E2BIG;\r\nif (!priv->free) {\r\nret = pxa3xx_gcu_wait_free(priv);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&priv->spinlock, flags);\r\nbuffer = priv->free;\r\npriv->free = buffer->next;\r\nspin_unlock_irqrestore(&priv->spinlock, flags);\r\nret = copy_from_user(buffer->ptr, buff, words * 4);\r\nif (ret) {\r\nspin_lock_irqsave(&priv->spinlock, flags);\r\nbuffer->next = priv->free;\r\npriv->free = buffer;\r\nspin_unlock_irqrestore(&priv->spinlock, flags);\r\nreturn -EFAULT;\r\n}\r\nbuffer->length = words;\r\nbuffer->ptr[words] = 0x01000000;\r\nspin_lock_irqsave(&priv->spinlock, flags);\r\nbuffer->next = NULL;\r\nif (priv->ready) {\r\nBUG_ON(priv->ready_last == NULL);\r\npriv->ready_last->next = buffer;\r\n} else\r\npriv->ready = buffer;\r\npriv->ready_last = buffer;\r\nif (!priv->shared->hw_running)\r\nrun_ready(priv);\r\nspin_unlock_irqrestore(&priv->spinlock, flags);\r\nreturn words * 4;\r\n}\r\nstatic long\r\npxa3xx_gcu_misc_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nunsigned long flags;\r\nstruct pxa3xx_gcu_priv *priv =\r\ncontainer_of(filp->f_op, struct pxa3xx_gcu_priv, misc_fops);\r\nswitch (cmd) {\r\ncase PXA3XX_GCU_IOCTL_RESET:\r\nspin_lock_irqsave(&priv->spinlock, flags);\r\npxa3xx_gcu_reset(priv);\r\nspin_unlock_irqrestore(&priv->spinlock, flags);\r\nreturn 0;\r\ncase PXA3XX_GCU_IOCTL_WAIT_IDLE:\r\nreturn pxa3xx_gcu_wait_idle(priv);\r\n}\r\nreturn -ENOSYS;\r\n}\r\nstatic int\r\npxa3xx_gcu_misc_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nunsigned int size = vma->vm_end - vma->vm_start;\r\nstruct pxa3xx_gcu_priv *priv =\r\ncontainer_of(filp->f_op, struct pxa3xx_gcu_priv, misc_fops);\r\nswitch (vma->vm_pgoff) {\r\ncase 0:\r\nif (size != SHARED_SIZE)\r\nreturn -EINVAL;\r\nreturn dma_mmap_coherent(NULL, vma,\r\npriv->shared, priv->shared_phys, size);\r\ncase SHARED_SIZE >> PAGE_SHIFT:\r\nif (size != resource_size(priv->resource_mem))\r\nreturn -EINVAL;\r\nvma->vm_flags |= VM_IO;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nreturn io_remap_pfn_range(vma, vma->vm_start,\r\npriv->resource_mem->start >> PAGE_SHIFT,\r\nsize, vma->vm_page_prot);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void pxa3xx_gcu_debug_timedout(unsigned long ptr)\r\n{\r\nstruct pxa3xx_gcu_priv *priv = (struct pxa3xx_gcu_priv *) ptr;\r\nQERROR("Timer DUMP");\r\ninit_timer(&pxa3xx_gcu_debug_timer);\r\npxa3xx_gcu_debug_timer.function = pxa3xx_gcu_debug_timedout;\r\npxa3xx_gcu_debug_timer.data = ptr;\r\npxa3xx_gcu_debug_timer.expires = jiffies + 5*HZ;\r\nadd_timer(&pxa3xx_gcu_debug_timer);\r\n}\r\nstatic void pxa3xx_gcu_init_debug_timer(void)\r\n{\r\npxa3xx_gcu_debug_timedout((unsigned long) &pxa3xx_gcu_debug_timer);\r\n}\r\nstatic inline void pxa3xx_gcu_init_debug_timer(void) {}\r\nstatic int\r\nadd_buffer(struct platform_device *dev,\r\nstruct pxa3xx_gcu_priv *priv)\r\n{\r\nstruct pxa3xx_gcu_batch *buffer;\r\nbuffer = kzalloc(sizeof(struct pxa3xx_gcu_batch), GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nbuffer->ptr = dma_alloc_coherent(&dev->dev, PXA3XX_GCU_BATCH_WORDS * 4,\r\n&buffer->phys, GFP_KERNEL);\r\nif (!buffer->ptr) {\r\nkfree(buffer);\r\nreturn -ENOMEM;\r\n}\r\nbuffer->next = priv->free;\r\npriv->free = buffer;\r\nreturn 0;\r\n}\r\nstatic void\r\nfree_buffers(struct platform_device *dev,\r\nstruct pxa3xx_gcu_priv *priv)\r\n{\r\nstruct pxa3xx_gcu_batch *next, *buffer = priv->free;\r\nwhile (buffer) {\r\nnext = buffer->next;\r\ndma_free_coherent(&dev->dev, PXA3XX_GCU_BATCH_WORDS * 4,\r\nbuffer->ptr, buffer->phys);\r\nkfree(buffer);\r\nbuffer = next;\r\n}\r\npriv->free = NULL;\r\n}\r\nstatic int __devinit\r\npxa3xx_gcu_probe(struct platform_device *dev)\r\n{\r\nint i, ret, irq;\r\nstruct resource *r;\r\nstruct pxa3xx_gcu_priv *priv;\r\npriv = kzalloc(sizeof(struct pxa3xx_gcu_priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < 8; i++) {\r\nret = add_buffer(dev, priv);\r\nif (ret) {\r\ndev_err(&dev->dev, "failed to allocate DMA memory\n");\r\ngoto err_free_priv;\r\n}\r\n}\r\ninit_waitqueue_head(&priv->wait_idle);\r\ninit_waitqueue_head(&priv->wait_free);\r\nspin_lock_init(&priv->spinlock);\r\npriv->misc_fops.owner = THIS_MODULE;\r\npriv->misc_fops.write = pxa3xx_gcu_misc_write;\r\npriv->misc_fops.unlocked_ioctl = pxa3xx_gcu_misc_ioctl;\r\npriv->misc_fops.mmap = pxa3xx_gcu_misc_mmap;\r\npriv->misc_dev.minor = MISCDEV_MINOR,\r\npriv->misc_dev.name = DRV_NAME,\r\npriv->misc_dev.fops = &priv->misc_fops,\r\nret = misc_register(&priv->misc_dev);\r\nif (ret < 0) {\r\ndev_err(&dev->dev, "misc_register() for minor %d failed\n",\r\nMISCDEV_MINOR);\r\ngoto err_free_priv;\r\n}\r\nr = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (r == NULL) {\r\ndev_err(&dev->dev, "no I/O memory resource defined\n");\r\nret = -ENODEV;\r\ngoto err_misc_deregister;\r\n}\r\nif (!request_mem_region(r->start, resource_size(r), dev->name)) {\r\ndev_err(&dev->dev, "failed to request I/O memory\n");\r\nret = -EBUSY;\r\ngoto err_misc_deregister;\r\n}\r\npriv->mmio_base = ioremap_nocache(r->start, resource_size(r));\r\nif (!priv->mmio_base) {\r\ndev_err(&dev->dev, "failed to map I/O memory\n");\r\nret = -EBUSY;\r\ngoto err_free_mem_region;\r\n}\r\npriv->shared = dma_alloc_coherent(&dev->dev, SHARED_SIZE,\r\n&priv->shared_phys, GFP_KERNEL);\r\nif (!priv->shared) {\r\ndev_err(&dev->dev, "failed to allocate DMA memory\n");\r\nret = -ENOMEM;\r\ngoto err_free_io;\r\n}\r\npriv->clk = clk_get(&dev->dev, NULL);\r\nif (IS_ERR(priv->clk)) {\r\ndev_err(&dev->dev, "failed to get clock\n");\r\nret = -ENODEV;\r\ngoto err_free_dma;\r\n}\r\nret = clk_enable(priv->clk);\r\nif (ret < 0) {\r\ndev_err(&dev->dev, "failed to enable clock\n");\r\ngoto err_put_clk;\r\n}\r\nirq = platform_get_irq(dev, 0);\r\nif (irq < 0) {\r\ndev_err(&dev->dev, "no IRQ defined\n");\r\nret = -ENODEV;\r\ngoto err_put_clk;\r\n}\r\nret = request_irq(irq, pxa3xx_gcu_handle_irq,\r\n0, DRV_NAME, priv);\r\nif (ret) {\r\ndev_err(&dev->dev, "request_irq failed\n");\r\nret = -EBUSY;\r\ngoto err_put_clk;\r\n}\r\nplatform_set_drvdata(dev, priv);\r\npriv->resource_mem = r;\r\npxa3xx_gcu_reset(priv);\r\npxa3xx_gcu_init_debug_timer();\r\ndev_info(&dev->dev, "registered @0x%p, DMA 0x%p (%d bytes), IRQ %d\n",\r\n(void *) r->start, (void *) priv->shared_phys,\r\nSHARED_SIZE, irq);\r\nreturn 0;\r\nerr_put_clk:\r\nclk_disable(priv->clk);\r\nclk_put(priv->clk);\r\nerr_free_dma:\r\ndma_free_coherent(&dev->dev, SHARED_SIZE,\r\npriv->shared, priv->shared_phys);\r\nerr_free_io:\r\niounmap(priv->mmio_base);\r\nerr_free_mem_region:\r\nrelease_mem_region(r->start, resource_size(r));\r\nerr_misc_deregister:\r\nmisc_deregister(&priv->misc_dev);\r\nerr_free_priv:\r\nplatform_set_drvdata(dev, NULL);\r\nfree_buffers(dev, priv);\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nstatic int __devexit\r\npxa3xx_gcu_remove(struct platform_device *dev)\r\n{\r\nstruct pxa3xx_gcu_priv *priv = platform_get_drvdata(dev);\r\nstruct resource *r = priv->resource_mem;\r\npxa3xx_gcu_wait_idle(priv);\r\nmisc_deregister(&priv->misc_dev);\r\ndma_free_coherent(&dev->dev, SHARED_SIZE,\r\npriv->shared, priv->shared_phys);\r\niounmap(priv->mmio_base);\r\nrelease_mem_region(r->start, resource_size(r));\r\nplatform_set_drvdata(dev, NULL);\r\nclk_disable(priv->clk);\r\nfree_buffers(dev, priv);\r\nkfree(priv);\r\nreturn 0;\r\n}
