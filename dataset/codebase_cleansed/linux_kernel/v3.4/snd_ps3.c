static inline u32 read_reg(unsigned int reg)\r\n{\r\nreturn in_be32(the_card.mapped_mmio_vaddr + reg);\r\n}\r\nstatic inline void write_reg(unsigned int reg, u32 val)\r\n{\r\nout_be32(the_card.mapped_mmio_vaddr + reg, val);\r\n}\r\nstatic inline void update_reg(unsigned int reg, u32 or_val)\r\n{\r\nu32 newval = read_reg(reg) | or_val;\r\nwrite_reg(reg, newval);\r\n}\r\nstatic inline void update_mask_reg(unsigned int reg, u32 mask, u32 or_val)\r\n{\r\nu32 newval = (read_reg(reg) & mask) | or_val;\r\nwrite_reg(reg, newval);\r\n}\r\nstatic int snd_ps3_verify_dma_stop(struct snd_ps3_card_info *card,\r\nint count, int force_stop)\r\n{\r\nint dma_ch, done, retries, stop_forced = 0;\r\nuint32_t status;\r\nfor (dma_ch = 0; dma_ch < 8; dma_ch++) {\r\nretries = count;\r\ndo {\r\nstatus = read_reg(PS3_AUDIO_KICK(dma_ch)) &\r\nPS3_AUDIO_KICK_STATUS_MASK;\r\nswitch (status) {\r\ncase PS3_AUDIO_KICK_STATUS_DONE:\r\ncase PS3_AUDIO_KICK_STATUS_NOTIFY:\r\ncase PS3_AUDIO_KICK_STATUS_CLEAR:\r\ncase PS3_AUDIO_KICK_STATUS_ERROR:\r\ndone = 1;\r\nbreak;\r\ndefault:\r\ndone = 0;\r\nudelay(10);\r\n}\r\n} while (!done && --retries);\r\nif (!retries && force_stop) {\r\npr_info("%s: DMA ch %d is not stopped.",\r\n__func__, dma_ch);\r\nupdate_reg(PS3_AUDIO_CONFIG, PS3_AUDIO_CONFIG_CLEAR);\r\nstop_forced = 1;\r\n}\r\n}\r\nreturn stop_forced;\r\n}\r\nstatic void snd_ps3_wait_for_dma_stop(struct snd_ps3_card_info *card)\r\n{\r\nint stop_forced;\r\nstop_forced = snd_ps3_verify_dma_stop(card, 700, 1);\r\nupdate_reg(PS3_AUDIO_INTR_0, 0);\r\nupdate_reg(PS3_AUDIO_AX_IS, 0);\r\nif (stop_forced)\r\nupdate_mask_reg(PS3_AUDIO_CONFIG, ~PS3_AUDIO_CONFIG_CLEAR, 0);\r\nwmb();\r\n}\r\nstatic void snd_ps3_kick_dma(struct snd_ps3_card_info *card)\r\n{\r\nupdate_reg(PS3_AUDIO_KICK(0), PS3_AUDIO_KICK_REQUEST);\r\nwmb();\r\n}\r\nstatic dma_addr_t v_to_bus(struct snd_ps3_card_info *card, void *paddr, int ch)\r\n{\r\nreturn card->dma_start_bus_addr[ch] +\r\n(paddr - card->dma_start_vaddr[ch]);\r\n}\r\nstatic void snd_ps3_bump_buffer(struct snd_ps3_card_info *card,\r\nenum snd_ps3_ch ch, size_t byte_count,\r\nint stage)\r\n{\r\nif (!stage)\r\ncard->dma_last_transfer_vaddr[ch] =\r\ncard->dma_next_transfer_vaddr[ch];\r\ncard->dma_next_transfer_vaddr[ch] += byte_count;\r\nif ((card->dma_start_vaddr[ch] + (card->dma_buffer_size / 2)) <=\r\ncard->dma_next_transfer_vaddr[ch]) {\r\ncard->dma_next_transfer_vaddr[ch] = card->dma_start_vaddr[ch];\r\n}\r\n}\r\nstatic int snd_ps3_program_dma(struct snd_ps3_card_info *card,\r\nenum snd_ps3_dma_filltype filltype)\r\n{\r\nuint32_t dma_addr;\r\nint fill_stages, dma_ch, stage;\r\nenum snd_ps3_ch ch;\r\nuint32_t ch0_kick_event = 0;\r\nvoid *start_vaddr;\r\nunsigned long irqsave;\r\nint silent = 0;\r\nswitch (filltype) {\r\ncase SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL:\r\nsilent = 1;\r\ncase SND_PS3_DMA_FILLTYPE_FIRSTFILL:\r\nch0_kick_event = PS3_AUDIO_KICK_EVENT_ALWAYS;\r\nbreak;\r\ncase SND_PS3_DMA_FILLTYPE_SILENT_RUNNING:\r\nsilent = 1;\r\ncase SND_PS3_DMA_FILLTYPE_RUNNING:\r\nch0_kick_event = PS3_AUDIO_KICK_EVENT_SERIALOUT0_EMPTY;\r\nbreak;\r\n}\r\nsnd_ps3_verify_dma_stop(card, 700, 0);\r\nfill_stages = 4;\r\nspin_lock_irqsave(&card->dma_lock, irqsave);\r\nfor (ch = 0; ch < 2; ch++) {\r\nstart_vaddr = card->dma_next_transfer_vaddr[0];\r\nfor (stage = 0; stage < fill_stages; stage++) {\r\ndma_ch = stage * 2 + ch;\r\nif (silent)\r\ndma_addr = card->null_buffer_start_dma_addr;\r\nelse\r\ndma_addr =\r\nv_to_bus(card,\r\ncard->dma_next_transfer_vaddr[ch],\r\nch);\r\nwrite_reg(PS3_AUDIO_SOURCE(dma_ch),\r\n(PS3_AUDIO_SOURCE_TARGET_SYSTEM_MEMORY |\r\ndma_addr));\r\nif (ch == 0)\r\nwrite_reg(PS3_AUDIO_DEST(dma_ch),\r\n(PS3_AUDIO_DEST_TARGET_AUDIOFIFO |\r\nPS3_AUDIO_AO_3W_LDATA(0)));\r\nelse\r\nwrite_reg(PS3_AUDIO_DEST(dma_ch),\r\n(PS3_AUDIO_DEST_TARGET_AUDIOFIFO |\r\nPS3_AUDIO_AO_3W_RDATA(0)));\r\nwrite_reg(PS3_AUDIO_DMASIZE(dma_ch), 0);\r\nif (!silent)\r\nsnd_ps3_bump_buffer(card, ch,\r\nPS3_AUDIO_DMAC_BLOCK_SIZE,\r\nstage);\r\nif (dma_ch == 0)\r\nwrite_reg(PS3_AUDIO_KICK(dma_ch),\r\nch0_kick_event);\r\nelse\r\nwrite_reg(PS3_AUDIO_KICK(dma_ch),\r\nPS3_AUDIO_KICK_EVENT_AUDIO_DMA(dma_ch\r\n- 1) |\r\nPS3_AUDIO_KICK_REQUEST);\r\n}\r\n}\r\nwmb();\r\nspin_unlock_irqrestore(&card->dma_lock, irqsave);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t snd_ps3_interrupt(int irq, void *dev_id)\r\n{\r\nuint32_t port_intr;\r\nint underflow_occured = 0;\r\nstruct snd_ps3_card_info *card = dev_id;\r\nif (!card->running) {\r\nupdate_reg(PS3_AUDIO_AX_IS, 0);\r\nupdate_reg(PS3_AUDIO_INTR_0, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nport_intr = read_reg(PS3_AUDIO_AX_IS);\r\nif (port_intr & PS3_AUDIO_AX_IE_ASOBEIE(0)) {\r\nwrite_reg(PS3_AUDIO_AX_IS, PS3_AUDIO_AX_IE_ASOBEIE(0));\r\nif (port_intr & PS3_AUDIO_AX_IE_ASOBUIE(0)) {\r\nwrite_reg(PS3_AUDIO_AX_IS, port_intr);\r\nunderflow_occured = 1;\r\n}\r\nif (card->silent) {\r\nsnd_ps3_program_dma(card,\r\n(underflow_occured) ?\r\nSND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL :\r\nSND_PS3_DMA_FILLTYPE_SILENT_RUNNING);\r\nsnd_ps3_kick_dma(card);\r\ncard->silent--;\r\n} else {\r\nsnd_ps3_program_dma(card,\r\n(underflow_occured) ?\r\nSND_PS3_DMA_FILLTYPE_FIRSTFILL :\r\nSND_PS3_DMA_FILLTYPE_RUNNING);\r\nsnd_ps3_kick_dma(card);\r\nsnd_pcm_period_elapsed(card->substream);\r\n}\r\n} else if (port_intr & PS3_AUDIO_AX_IE_ASOBUIE(0)) {\r\nwrite_reg(PS3_AUDIO_AX_IS, PS3_AUDIO_AX_IE_ASOBUIE(0));\r\nsnd_ps3_program_dma(card,\r\nSND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL);\r\nsnd_ps3_kick_dma(card);\r\nsnd_ps3_program_dma(card,\r\nSND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL);\r\nsnd_ps3_kick_dma(card);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int snd_ps3_mute(int mute_on)\r\n{\r\nreturn ps3av_audio_mute(mute_on);\r\n}\r\nstatic int snd_ps3_change_avsetting(struct snd_ps3_card_info *card)\r\n{\r\nint ret, retries, i;\r\npr_debug("%s: start\n", __func__);\r\nret = ps3av_set_audio_mode(card->avs.avs_audio_ch,\r\ncard->avs.avs_audio_rate,\r\ncard->avs.avs_audio_width,\r\ncard->avs.avs_audio_format,\r\ncard->avs.avs_audio_source);\r\nupdate_mask_reg(PS3_AUDIO_AO_3WMCTRL,\r\n~(PS3_AUDIO_AO_3WMCTRL_ASOEN(0) |\r\nPS3_AUDIO_AO_3WMCTRL_ASOEN(1) |\r\nPS3_AUDIO_AO_3WMCTRL_ASOEN(2) |\r\nPS3_AUDIO_AO_3WMCTRL_ASOEN(3)),\r\n0);\r\nwmb();\r\nretries = 1000;\r\nwhile ((read_reg(PS3_AUDIO_AO_3WMCTRL) &\r\n(PS3_AUDIO_AO_3WMCTRL_ASORUN(0) |\r\nPS3_AUDIO_AO_3WMCTRL_ASORUN(1) |\r\nPS3_AUDIO_AO_3WMCTRL_ASORUN(2) |\r\nPS3_AUDIO_AO_3WMCTRL_ASORUN(3))) &&\r\n--retries) {\r\nudelay(1);\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nupdate_reg(PS3_AUDIO_AO_3WCTRL(i),\r\nPS3_AUDIO_AO_3WCTRL_ASOBRST_RESET);\r\nudelay(10);\r\n}\r\nwmb();\r\nupdate_reg(PS3_AUDIO_AO_3WMCTRL, PS3_AUDIO_AO_3WMCTRL_ASOEN(0));\r\nupdate_mask_reg(PS3_AUDIO_AO_3WCTRL(0),\r\n~PS3_AUDIO_AO_3WCTRL_ASODF,\r\nPS3_AUDIO_AO_3WCTRL_ASODF_LSB);\r\nupdate_mask_reg(PS3_AUDIO_AO_SPDCTRL(0),\r\n~PS3_AUDIO_AO_SPDCTRL_SPODF,\r\nPS3_AUDIO_AO_SPDCTRL_SPODF_LSB);\r\nwmb();\r\npr_debug("%s: end\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int snd_ps3_set_avsetting(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ps3_card_info *card = snd_pcm_substream_chip(substream);\r\nstruct snd_ps3_avsetting_info avs;\r\nint ret;\r\navs = card->avs;\r\npr_debug("%s: called freq=%d width=%d\n", __func__,\r\nsubstream->runtime->rate,\r\nsnd_pcm_format_width(substream->runtime->format));\r\npr_debug("%s: before freq=%d width=%d\n", __func__,\r\ncard->avs.avs_audio_rate, card->avs.avs_audio_width);\r\nswitch (substream->runtime->rate) {\r\ncase 44100:\r\navs.avs_audio_rate = PS3AV_CMD_AUDIO_FS_44K;\r\nbreak;\r\ncase 48000:\r\navs.avs_audio_rate = PS3AV_CMD_AUDIO_FS_48K;\r\nbreak;\r\ncase 88200:\r\navs.avs_audio_rate = PS3AV_CMD_AUDIO_FS_88K;\r\nbreak;\r\ncase 96000:\r\navs.avs_audio_rate = PS3AV_CMD_AUDIO_FS_96K;\r\nbreak;\r\ndefault:\r\npr_info("%s: invalid rate %d\n", __func__,\r\nsubstream->runtime->rate);\r\nreturn 1;\r\n}\r\nswitch (snd_pcm_format_width(substream->runtime->format)) {\r\ncase 16:\r\navs.avs_audio_width = PS3AV_CMD_AUDIO_WORD_BITS_16;\r\nbreak;\r\ncase 24:\r\navs.avs_audio_width = PS3AV_CMD_AUDIO_WORD_BITS_24;\r\nbreak;\r\ndefault:\r\npr_info("%s: invalid width %d\n", __func__,\r\nsnd_pcm_format_width(substream->runtime->format));\r\nreturn 1;\r\n}\r\nmemcpy(avs.avs_cs_info, ps3av_mode_cs_info, 8);\r\nif (memcmp(&card->avs, &avs, sizeof(avs))) {\r\npr_debug("%s: after freq=%d width=%d\n", __func__,\r\ncard->avs.avs_audio_rate, card->avs.avs_audio_width);\r\ncard->avs = avs;\r\nsnd_ps3_change_avsetting(card);\r\nret = 0;\r\n} else\r\nret = 1;\r\nif (avs.avs_cs_info[0] & 0x02)\r\nps3av_audio_mute_analog(1);\r\nelse\r\nps3av_audio_mute_analog(0);\r\nreturn ret;\r\n}\r\nstatic int snd_ps3_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ps3_card_info *card = snd_pcm_substream_chip(substream);\r\nint pcm_index;\r\npcm_index = substream->pcm->device;\r\ncard->substream = substream;\r\nruntime->hw = snd_ps3_pcm_hw;\r\ncard->start_delay = snd_ps3_start_delay;\r\nsnd_ps3_mute(0);\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\r\nPS3_AUDIO_FIFO_STAGE_SIZE * 4 * 2);\r\nreturn 0;\r\n}\r\nstatic int snd_ps3_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nsnd_ps3_mute(1);\r\nreturn 0;\r\n}\r\nstatic int snd_ps3_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nsize_t size;\r\nsize = params_buffer_bytes(hw_params);\r\nsnd_pcm_lib_malloc_pages(substream, size);\r\nreturn 0;\r\n}\r\nstatic int snd_ps3_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nint ret;\r\nret = snd_pcm_lib_free_pages(substream);\r\nreturn ret;\r\n}\r\nstatic int snd_ps3_delay_to_bytes(struct snd_pcm_substream *substream,\r\nunsigned int delay_ms)\r\n{\r\nint ret;\r\nint rate ;\r\nrate = substream->runtime->rate;\r\nret = snd_pcm_format_size(substream->runtime->format,\r\nrate * delay_ms / 1000)\r\n* substream->runtime->channels;\r\npr_debug("%s: time=%d rate=%d bytes=%ld, frames=%d, ret=%d\n",\r\n__func__,\r\ndelay_ms,\r\nrate,\r\nsnd_pcm_format_size(substream->runtime->format, rate),\r\nrate * delay_ms / 1000,\r\nret);\r\nreturn ret;\r\n}\r\nstatic int snd_ps3_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ps3_card_info *card = snd_pcm_substream_chip(substream);\r\nunsigned long irqsave;\r\nif (!snd_ps3_set_avsetting(substream)) {\r\nwrite_reg(PS3_AUDIO_AX_IE,\r\nPS3_AUDIO_AX_IE_ASOBEIE(0) |\r\nPS3_AUDIO_AX_IE_ASOBUIE(0));\r\ncard->silent = snd_ps3_delay_to_bytes(substream,\r\ncard->start_delay) /\r\n(PS3_AUDIO_FIFO_STAGE_SIZE * 4);\r\n}\r\nspin_lock_irqsave(&card->dma_lock, irqsave);\r\n{\r\ncard->dma_buffer_size = runtime->dma_bytes;\r\ncard->dma_last_transfer_vaddr[SND_PS3_CH_L] =\r\ncard->dma_next_transfer_vaddr[SND_PS3_CH_L] =\r\ncard->dma_start_vaddr[SND_PS3_CH_L] =\r\nruntime->dma_area;\r\ncard->dma_start_bus_addr[SND_PS3_CH_L] = runtime->dma_addr;\r\ncard->dma_last_transfer_vaddr[SND_PS3_CH_R] =\r\ncard->dma_next_transfer_vaddr[SND_PS3_CH_R] =\r\ncard->dma_start_vaddr[SND_PS3_CH_R] =\r\nruntime->dma_area + (runtime->dma_bytes / 2);\r\ncard->dma_start_bus_addr[SND_PS3_CH_R] =\r\nruntime->dma_addr + (runtime->dma_bytes / 2);\r\npr_debug("%s: vaddr=%p bus=%#llx\n", __func__,\r\ncard->dma_start_vaddr[SND_PS3_CH_L],\r\ncard->dma_start_bus_addr[SND_PS3_CH_L]);\r\n}\r\nspin_unlock_irqrestore(&card->dma_lock, irqsave);\r\nmb();\r\nreturn 0;\r\n}\r\nstatic int snd_ps3_pcm_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_ps3_card_info *card = snd_pcm_substream_chip(substream);\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nupdate_reg(PS3_AUDIO_AX_IS, 0);\r\nspin_lock(&card->dma_lock);\r\n{\r\ncard->running = 1;\r\n}\r\nspin_unlock(&card->dma_lock);\r\nsnd_ps3_program_dma(card,\r\nSND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL);\r\nsnd_ps3_kick_dma(card);\r\nwhile (read_reg(PS3_AUDIO_KICK(7)) &\r\nPS3_AUDIO_KICK_STATUS_MASK) {\r\nudelay(1);\r\n}\r\nsnd_ps3_program_dma(card, SND_PS3_DMA_FILLTYPE_SILENT_RUNNING);\r\nsnd_ps3_kick_dma(card);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nspin_lock(&card->dma_lock);\r\n{\r\ncard->running = 0;\r\n}\r\nspin_unlock(&card->dma_lock);\r\nsnd_ps3_wait_for_dma_stop(card);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic snd_pcm_uframes_t snd_ps3_pcm_pointer(\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ps3_card_info *card = snd_pcm_substream_chip(substream);\r\nsize_t bytes;\r\nsnd_pcm_uframes_t ret;\r\nspin_lock(&card->dma_lock);\r\n{\r\nbytes = (size_t)(card->dma_last_transfer_vaddr[SND_PS3_CH_L] -\r\ncard->dma_start_vaddr[SND_PS3_CH_L]);\r\n}\r\nspin_unlock(&card->dma_lock);\r\nret = bytes_to_frames(substream->runtime, bytes * 2);\r\nreturn ret;\r\n}\r\nstatic int snd_ps3_spdif_mask_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_ps3_spdif_cmask_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nmemset(ucontrol->value.iec958.status, 0xff, 8);\r\nreturn 0;\r\n}\r\nstatic int snd_ps3_spdif_pmask_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nreturn 0;\r\n}\r\nstatic int snd_ps3_spdif_default_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nmemcpy(ucontrol->value.iec958.status, ps3av_mode_cs_info, 8);\r\nreturn 0;\r\n}\r\nstatic int snd_ps3_spdif_default_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nif (memcmp(ps3av_mode_cs_info, ucontrol->value.iec958.status, 8)) {\r\nmemcpy(ps3av_mode_cs_info, ucontrol->value.iec958.status, 8);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit snd_ps3_map_mmio(void)\r\n{\r\nthe_card.mapped_mmio_vaddr =\r\nioremap(the_card.ps3_dev->m_region->bus_addr,\r\nthe_card.ps3_dev->m_region->len);\r\nif (!the_card.mapped_mmio_vaddr) {\r\npr_info("%s: ioremap 0 failed p=%#lx l=%#lx \n",\r\n__func__, the_card.ps3_dev->m_region->lpar_addr,\r\nthe_card.ps3_dev->m_region->len);\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_ps3_unmap_mmio(void)\r\n{\r\niounmap(the_card.mapped_mmio_vaddr);\r\nthe_card.mapped_mmio_vaddr = NULL;\r\n}\r\nstatic int __devinit snd_ps3_allocate_irq(void)\r\n{\r\nint ret;\r\nu64 lpar_addr, lpar_size;\r\nu64 __iomem *mapped;\r\nret = lv1_gpu_device_map(1, &lpar_addr, &lpar_size);\r\nif (ret) {\r\npr_info("%s: device map 1 failed %d\n", __func__,\r\nret);\r\nreturn -ENXIO;\r\n}\r\nmapped = ioremap(lpar_addr, lpar_size);\r\nif (!mapped) {\r\npr_info("%s: ioremap 1 failed \n", __func__);\r\nreturn -ENXIO;\r\n}\r\nthe_card.audio_irq_outlet = in_be64(mapped);\r\niounmap(mapped);\r\nret = lv1_gpu_device_unmap(1);\r\nif (ret)\r\npr_info("%s: unmap 1 failed\n", __func__);\r\nret = ps3_irq_plug_setup(PS3_BINDING_CPU_ANY,\r\nthe_card.audio_irq_outlet,\r\n&the_card.irq_no);\r\nif (ret) {\r\npr_info("%s:ps3_alloc_irq failed (%d)\n", __func__, ret);\r\nreturn ret;\r\n}\r\nret = request_irq(the_card.irq_no, snd_ps3_interrupt, 0,\r\nSND_PS3_DRIVER_NAME, &the_card);\r\nif (ret) {\r\npr_info("%s: request_irq failed (%d)\n", __func__, ret);\r\ngoto cleanup_irq;\r\n}\r\nreturn 0;\r\ncleanup_irq:\r\nps3_irq_plug_destroy(the_card.irq_no);\r\nreturn ret;\r\n}\r\nstatic void snd_ps3_free_irq(void)\r\n{\r\nfree_irq(the_card.irq_no, &the_card);\r\nps3_irq_plug_destroy(the_card.irq_no);\r\n}\r\nstatic void __devinit snd_ps3_audio_set_base_addr(uint64_t ioaddr_start)\r\n{\r\nuint64_t val;\r\nint ret;\r\nval = (ioaddr_start & (0x0fUL << 32)) >> (32 - 20) |\r\n(0x03UL << 24) |\r\n(0x0fUL << 12) |\r\n(PS3_AUDIO_IOID);\r\nret = lv1_gpu_attribute(0x100, 0x007, val);\r\nif (ret)\r\npr_info("%s: gpu_attribute failed %d\n", __func__,\r\nret);\r\n}\r\nstatic void __devinit snd_ps3_audio_fixup(struct snd_ps3_card_info *card)\r\n{\r\nwrite_reg(PS3_AUDIO_INTR_EN_0, 0);\r\nupdate_mask_reg(PS3_AUDIO_AX_IC,\r\nPS3_AUDIO_AX_IC_AASOIMD_MASK,\r\nPS3_AUDIO_AX_IC_AASOIMD_EVERY4);\r\nupdate_mask_reg(PS3_AUDIO_AO_3WMCTRL,\r\n~(PS3_AUDIO_AO_3WMCTRL_ASOBCLKD_DISABLED |\r\nPS3_AUDIO_AO_3WMCTRL_ASOLRCKD_DISABLED),\r\n0);\r\nupdate_reg(PS3_AUDIO_AO_3WMCTRL,\r\nPS3_AUDIO_AO_3WMCTRL_ASOPLRCK_DEFAULT);\r\n}\r\nstatic int __devinit snd_ps3_init_avsetting(struct snd_ps3_card_info *card)\r\n{\r\nint ret;\r\npr_debug("%s: start\n", __func__);\r\ncard->avs.avs_audio_ch = PS3AV_CMD_AUDIO_NUM_OF_CH_2;\r\ncard->avs.avs_audio_rate = PS3AV_CMD_AUDIO_FS_48K;\r\ncard->avs.avs_audio_width = PS3AV_CMD_AUDIO_WORD_BITS_16;\r\ncard->avs.avs_audio_format = PS3AV_CMD_AUDIO_FORMAT_PCM;\r\ncard->avs.avs_audio_source = PS3AV_CMD_AUDIO_SOURCE_SERIAL;\r\nmemcpy(card->avs.avs_cs_info, ps3av_mode_cs_info, 8);\r\nret = snd_ps3_change_avsetting(card);\r\nsnd_ps3_audio_fixup(card);\r\nsnd_ps3_program_dma(card, SND_PS3_DMA_FILLTYPE_SILENT_FIRSTFILL);\r\nsnd_ps3_kick_dma(card);\r\npr_debug("%s: end\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int __devinit snd_ps3_driver_probe(struct ps3_system_bus_device *dev)\r\n{\r\nint i, ret;\r\nu64 lpar_addr, lpar_size;\r\nBUG_ON(!firmware_has_feature(FW_FEATURE_PS3_LV1));\r\nBUG_ON(dev->match_id != PS3_MATCH_ID_SOUND);\r\nthe_card.ps3_dev = dev;\r\nret = ps3_open_hv_device(dev);\r\nif (ret)\r\nreturn -ENXIO;\r\nret = lv1_gpu_device_map(2, &lpar_addr, &lpar_size);\r\nif (ret) {\r\npr_info("%s: device map 2 failed %d\n", __func__, ret);\r\ngoto clean_open;\r\n}\r\nps3_mmio_region_init(dev, dev->m_region, lpar_addr, lpar_size,\r\nPAGE_SHIFT);\r\nret = snd_ps3_map_mmio();\r\nif (ret)\r\ngoto clean_dev_map;\r\nps3_dma_region_init(dev, dev->d_region,\r\nPAGE_SHIFT,\r\n0,\r\nNULL,\r\n_ALIGN_UP(SND_PS3_DMA_REGION_SIZE, PAGE_SIZE));\r\ndev->d_region->ioid = PS3_AUDIO_IOID;\r\nret = ps3_dma_region_create(dev->d_region);\r\nif (ret) {\r\npr_info("%s: region_create\n", __func__);\r\ngoto clean_mmio;\r\n}\r\nsnd_ps3_audio_set_base_addr(dev->d_region->bus_addr);\r\nthe_card.start_delay = snd_ps3_start_delay;\r\nif (snd_ps3_allocate_irq()) {\r\nret = -ENXIO;\r\ngoto clean_dma_region;\r\n}\r\nret = snd_card_create(index, id, THIS_MODULE, 0, &the_card.card);\r\nif (ret < 0)\r\ngoto clean_irq;\r\nstrcpy(the_card.card->driver, "PS3");\r\nstrcpy(the_card.card->shortname, "PS3");\r\nstrcpy(the_card.card->longname, "PS3 sound");\r\nfor (i = 0; i < ARRAY_SIZE(spdif_ctls); i++) {\r\nret = snd_ctl_add(the_card.card,\r\nsnd_ctl_new1(&spdif_ctls[i], &the_card));\r\nif (ret < 0)\r\ngoto clean_card;\r\n}\r\nret = snd_pcm_new(the_card.card,\r\n"SPDIF",\r\n0,\r\n1,\r\n0,\r\n&(the_card.pcm));\r\nif (ret)\r\ngoto clean_card;\r\nthe_card.pcm->private_data = &the_card;\r\nstrcpy(the_card.pcm->name, "SPDIF");\r\nsnd_pcm_set_ops(the_card.pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_ps3_pcm_spdif_ops);\r\nthe_card.pcm->info_flags = SNDRV_PCM_INFO_NONINTERLEAVED;\r\nret = snd_pcm_lib_preallocate_pages_for_all(the_card.pcm,\r\nSNDRV_DMA_TYPE_DEV,\r\n&dev->core,\r\nSND_PS3_PCM_PREALLOC_SIZE,\r\nSND_PS3_PCM_PREALLOC_SIZE);\r\nif (ret < 0) {\r\npr_info("%s: prealloc failed\n", __func__);\r\ngoto clean_card;\r\n}\r\nthe_card.null_buffer_start_vaddr =\r\ndma_alloc_coherent(&the_card.ps3_dev->core,\r\nPAGE_SIZE,\r\n&the_card.null_buffer_start_dma_addr,\r\nGFP_KERNEL);\r\nif (!the_card.null_buffer_start_vaddr) {\r\npr_info("%s: nullbuffer alloc failed\n", __func__);\r\ngoto clean_preallocate;\r\n}\r\npr_debug("%s: null vaddr=%p dma=%#llx\n", __func__,\r\nthe_card.null_buffer_start_vaddr,\r\nthe_card.null_buffer_start_dma_addr);\r\nsnd_ps3_init_avsetting(&the_card);\r\nsnd_card_set_dev(the_card.card, &dev->core);\r\nret = snd_card_register(the_card.card);\r\nif (ret < 0)\r\ngoto clean_dma_map;\r\npr_info("%s started. start_delay=%dms\n",\r\nthe_card.card->longname, the_card.start_delay);\r\nreturn 0;\r\nclean_dma_map:\r\ndma_free_coherent(&the_card.ps3_dev->core,\r\nPAGE_SIZE,\r\nthe_card.null_buffer_start_vaddr,\r\nthe_card.null_buffer_start_dma_addr);\r\nclean_preallocate:\r\nsnd_pcm_lib_preallocate_free_for_all(the_card.pcm);\r\nclean_card:\r\nsnd_card_free(the_card.card);\r\nclean_irq:\r\nsnd_ps3_free_irq();\r\nclean_dma_region:\r\nps3_dma_region_free(dev->d_region);\r\nclean_mmio:\r\nsnd_ps3_unmap_mmio();\r\nclean_dev_map:\r\nlv1_gpu_device_unmap(2);\r\nclean_open:\r\nps3_close_hv_device(dev);\r\nreturn ret;\r\n}\r\nstatic int snd_ps3_driver_remove(struct ps3_system_bus_device *dev)\r\n{\r\nint ret;\r\npr_info("%s:start id=%d\n", __func__, dev->match_id);\r\nif (dev->match_id != PS3_MATCH_ID_SOUND)\r\nreturn -ENXIO;\r\nret = snd_card_free(the_card.card);\r\nif (ret)\r\npr_info("%s: ctl freecard=%d\n", __func__, ret);\r\ndma_free_coherent(&dev->core,\r\nPAGE_SIZE,\r\nthe_card.null_buffer_start_vaddr,\r\nthe_card.null_buffer_start_dma_addr);\r\nps3_dma_region_free(dev->d_region);\r\nsnd_ps3_free_irq();\r\nsnd_ps3_unmap_mmio();\r\nlv1_gpu_device_unmap(2);\r\nps3_close_hv_device(dev);\r\npr_info("%s:end id=%d\n", __func__, dev->match_id);\r\nreturn 0;\r\n}\r\nstatic int __init snd_ps3_init(void)\r\n{\r\nint ret;\r\nif (!firmware_has_feature(FW_FEATURE_PS3_LV1))\r\nreturn -ENXIO;\r\nmemset(&the_card, 0, sizeof(the_card));\r\nspin_lock_init(&the_card.dma_lock);\r\nret = ps3_system_bus_driver_register(&snd_ps3_bus_driver_info);\r\nreturn ret;\r\n}\r\nstatic void __exit snd_ps3_exit(void)\r\n{\r\nps3_system_bus_driver_unregister(&snd_ps3_bus_driver_info);\r\n}
