static struct ab_priv *ab_priv(struct team *team)\r\n{\r\nreturn (struct ab_priv *) &team->mode_priv;\r\n}\r\nstatic rx_handler_result_t ab_receive(struct team *team, struct team_port *port,\r\nstruct sk_buff *skb) {\r\nstruct team_port *active_port;\r\nactive_port = rcu_dereference(ab_priv(team)->active_port);\r\nif (active_port != port)\r\nreturn RX_HANDLER_EXACT;\r\nreturn RX_HANDLER_ANOTHER;\r\n}\r\nstatic bool ab_transmit(struct team *team, struct sk_buff *skb)\r\n{\r\nstruct team_port *active_port;\r\nactive_port = rcu_dereference(ab_priv(team)->active_port);\r\nif (unlikely(!active_port))\r\ngoto drop;\r\nskb->dev = active_port->dev;\r\nif (dev_queue_xmit(skb))\r\nreturn false;\r\nreturn true;\r\ndrop:\r\ndev_kfree_skb_any(skb);\r\nreturn false;\r\n}\r\nstatic void ab_port_leave(struct team *team, struct team_port *port)\r\n{\r\nif (ab_priv(team)->active_port == port)\r\nRCU_INIT_POINTER(ab_priv(team)->active_port, NULL);\r\n}\r\nstatic int ab_active_port_get(struct team *team, void *arg)\r\n{\r\nu32 *ifindex = arg;\r\n*ifindex = 0;\r\nif (ab_priv(team)->active_port)\r\n*ifindex = ab_priv(team)->active_port->dev->ifindex;\r\nreturn 0;\r\n}\r\nstatic int ab_active_port_set(struct team *team, void *arg)\r\n{\r\nu32 *ifindex = arg;\r\nstruct team_port *port;\r\nlist_for_each_entry_rcu(port, &team->port_list, list) {\r\nif (port->dev->ifindex == *ifindex) {\r\nrcu_assign_pointer(ab_priv(team)->active_port, port);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nint ab_init(struct team *team)\r\n{\r\nreturn team_options_register(team, ab_options, ARRAY_SIZE(ab_options));\r\n}\r\nvoid ab_exit(struct team *team)\r\n{\r\nteam_options_unregister(team, ab_options, ARRAY_SIZE(ab_options));\r\n}\r\nstatic int __init ab_init_module(void)\r\n{\r\nreturn team_mode_register(&ab_mode);\r\n}\r\nstatic void __exit ab_cleanup_module(void)\r\n{\r\nteam_mode_unregister(&ab_mode);\r\n}
