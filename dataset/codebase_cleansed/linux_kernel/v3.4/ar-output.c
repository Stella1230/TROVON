static int rxrpc_sendmsg_cmsg(struct rxrpc_sock *rx, struct msghdr *msg,\r\nunsigned long *user_call_ID,\r\nenum rxrpc_command *command,\r\nu32 *abort_code,\r\nbool server)\r\n{\r\nstruct cmsghdr *cmsg;\r\nint len;\r\n*command = RXRPC_CMD_SEND_DATA;\r\nif (msg->msg_controllen == 0)\r\nreturn -EINVAL;\r\nfor (cmsg = CMSG_FIRSTHDR(msg); cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {\r\nif (!CMSG_OK(msg, cmsg))\r\nreturn -EINVAL;\r\nlen = cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr));\r\n_debug("CMSG %d, %d, %d",\r\ncmsg->cmsg_level, cmsg->cmsg_type, len);\r\nif (cmsg->cmsg_level != SOL_RXRPC)\r\ncontinue;\r\nswitch (cmsg->cmsg_type) {\r\ncase RXRPC_USER_CALL_ID:\r\nif (msg->msg_flags & MSG_CMSG_COMPAT) {\r\nif (len != sizeof(u32))\r\nreturn -EINVAL;\r\n*user_call_ID = *(u32 *) CMSG_DATA(cmsg);\r\n} else {\r\nif (len != sizeof(unsigned long))\r\nreturn -EINVAL;\r\n*user_call_ID = *(unsigned long *)\r\nCMSG_DATA(cmsg);\r\n}\r\n_debug("User Call ID %lx", *user_call_ID);\r\nbreak;\r\ncase RXRPC_ABORT:\r\nif (*command != RXRPC_CMD_SEND_DATA)\r\nreturn -EINVAL;\r\n*command = RXRPC_CMD_SEND_ABORT;\r\nif (len != sizeof(*abort_code))\r\nreturn -EINVAL;\r\n*abort_code = *(unsigned int *) CMSG_DATA(cmsg);\r\n_debug("Abort %x", *abort_code);\r\nif (*abort_code == 0)\r\nreturn -EINVAL;\r\nbreak;\r\ncase RXRPC_ACCEPT:\r\nif (*command != RXRPC_CMD_SEND_DATA)\r\nreturn -EINVAL;\r\n*command = RXRPC_CMD_ACCEPT;\r\nif (len != 0)\r\nreturn -EINVAL;\r\nif (!server)\r\nreturn -EISCONN;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\n_leave(" = 0");\r\nreturn 0;\r\n}\r\nstatic void rxrpc_send_abort(struct rxrpc_call *call, u32 abort_code)\r\n{\r\nwrite_lock_bh(&call->state_lock);\r\nif (call->state <= RXRPC_CALL_COMPLETE) {\r\ncall->state = RXRPC_CALL_LOCALLY_ABORTED;\r\ncall->abort_code = abort_code;\r\nset_bit(RXRPC_CALL_ABORT, &call->events);\r\ndel_timer_sync(&call->resend_timer);\r\ndel_timer_sync(&call->ack_timer);\r\nclear_bit(RXRPC_CALL_RESEND_TIMER, &call->events);\r\nclear_bit(RXRPC_CALL_ACK, &call->events);\r\nclear_bit(RXRPC_CALL_RUN_RTIMER, &call->flags);\r\nrxrpc_queue_call(call);\r\n}\r\nwrite_unlock_bh(&call->state_lock);\r\n}\r\nint rxrpc_client_sendmsg(struct kiocb *iocb, struct rxrpc_sock *rx,\r\nstruct rxrpc_transport *trans, struct msghdr *msg,\r\nsize_t len)\r\n{\r\nstruct rxrpc_conn_bundle *bundle;\r\nenum rxrpc_command cmd;\r\nstruct rxrpc_call *call;\r\nunsigned long user_call_ID = 0;\r\nstruct key *key;\r\n__be16 service_id;\r\nu32 abort_code = 0;\r\nint ret;\r\n_enter("");\r\nASSERT(trans != NULL);\r\nret = rxrpc_sendmsg_cmsg(rx, msg, &user_call_ID, &cmd, &abort_code,\r\nfalse);\r\nif (ret < 0)\r\nreturn ret;\r\nbundle = NULL;\r\nif (trans) {\r\nservice_id = rx->service_id;\r\nif (msg->msg_name) {\r\nstruct sockaddr_rxrpc *srx =\r\n(struct sockaddr_rxrpc *) msg->msg_name;\r\nservice_id = htons(srx->srx_service);\r\n}\r\nkey = rx->key;\r\nif (key && !rx->key->payload.data)\r\nkey = NULL;\r\nbundle = rxrpc_get_bundle(rx, trans, key, service_id,\r\nGFP_KERNEL);\r\nif (IS_ERR(bundle))\r\nreturn PTR_ERR(bundle);\r\n}\r\ncall = rxrpc_get_client_call(rx, trans, bundle, user_call_ID,\r\nabort_code == 0, GFP_KERNEL);\r\nif (trans)\r\nrxrpc_put_bundle(trans, bundle);\r\nif (IS_ERR(call)) {\r\n_leave(" = %ld", PTR_ERR(call));\r\nreturn PTR_ERR(call);\r\n}\r\n_debug("CALL %d USR %lx ST %d on CONN %p",\r\ncall->debug_id, call->user_call_ID, call->state, call->conn);\r\nif (call->state >= RXRPC_CALL_COMPLETE) {\r\nret = -ESHUTDOWN;\r\n} else if (cmd == RXRPC_CMD_SEND_ABORT) {\r\nrxrpc_send_abort(call, abort_code);\r\n} else if (cmd != RXRPC_CMD_SEND_DATA) {\r\nret = -EINVAL;\r\n} else if (call->state != RXRPC_CALL_CLIENT_SEND_REQUEST) {\r\nret = -EPROTO;\r\n} else {\r\nret = rxrpc_send_data(iocb, rx, call, msg, len);\r\n}\r\nrxrpc_put_call(call);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nint rxrpc_kernel_send_data(struct rxrpc_call *call, struct msghdr *msg,\r\nsize_t len)\r\n{\r\nint ret;\r\n_enter("{%d,%s},", call->debug_id, rxrpc_call_states[call->state]);\r\nASSERTCMP(msg->msg_name, ==, NULL);\r\nASSERTCMP(msg->msg_control, ==, NULL);\r\nlock_sock(&call->socket->sk);\r\n_debug("CALL %d USR %lx ST %d on CONN %p",\r\ncall->debug_id, call->user_call_ID, call->state, call->conn);\r\nif (call->state >= RXRPC_CALL_COMPLETE) {\r\nret = -ESHUTDOWN;\r\n} else if (call->state != RXRPC_CALL_CLIENT_SEND_REQUEST &&\r\ncall->state != RXRPC_CALL_SERVER_ACK_REQUEST &&\r\ncall->state != RXRPC_CALL_SERVER_SEND_REPLY) {\r\nret = -EPROTO;\r\n} else {\r\nmm_segment_t oldfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nret = rxrpc_send_data(NULL, call->socket, call, msg, len);\r\nset_fs(oldfs);\r\n}\r\nrelease_sock(&call->socket->sk);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nvoid rxrpc_kernel_abort_call(struct rxrpc_call *call, u32 abort_code)\r\n{\r\n_enter("{%d},%d", call->debug_id, abort_code);\r\nlock_sock(&call->socket->sk);\r\n_debug("CALL %d USR %lx ST %d on CONN %p",\r\ncall->debug_id, call->user_call_ID, call->state, call->conn);\r\nif (call->state < RXRPC_CALL_COMPLETE)\r\nrxrpc_send_abort(call, abort_code);\r\nrelease_sock(&call->socket->sk);\r\n_leave("");\r\n}\r\nint rxrpc_server_sendmsg(struct kiocb *iocb, struct rxrpc_sock *rx,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nenum rxrpc_command cmd;\r\nstruct rxrpc_call *call;\r\nunsigned long user_call_ID = 0;\r\nu32 abort_code = 0;\r\nint ret;\r\n_enter("");\r\nret = rxrpc_sendmsg_cmsg(rx, msg, &user_call_ID, &cmd, &abort_code,\r\ntrue);\r\nif (ret < 0)\r\nreturn ret;\r\nif (cmd == RXRPC_CMD_ACCEPT) {\r\ncall = rxrpc_accept_call(rx, user_call_ID);\r\nif (IS_ERR(call))\r\nreturn PTR_ERR(call);\r\nrxrpc_put_call(call);\r\nreturn 0;\r\n}\r\ncall = rxrpc_find_server_call(rx, user_call_ID);\r\nif (!call)\r\nreturn -EBADSLT;\r\nif (call->state >= RXRPC_CALL_COMPLETE) {\r\nret = -ESHUTDOWN;\r\ngoto out;\r\n}\r\nswitch (cmd) {\r\ncase RXRPC_CMD_SEND_DATA:\r\nif (call->state != RXRPC_CALL_CLIENT_SEND_REQUEST &&\r\ncall->state != RXRPC_CALL_SERVER_ACK_REQUEST &&\r\ncall->state != RXRPC_CALL_SERVER_SEND_REPLY) {\r\nret = -EPROTO;\r\nbreak;\r\n}\r\nret = rxrpc_send_data(iocb, rx, call, msg, len);\r\nbreak;\r\ncase RXRPC_CMD_SEND_ABORT:\r\nrxrpc_send_abort(call, abort_code);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nout:\r\nrxrpc_put_call(call);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nint rxrpc_send_packet(struct rxrpc_transport *trans, struct sk_buff *skb)\r\n{\r\nstruct kvec iov[1];\r\nstruct msghdr msg;\r\nint ret, opt;\r\n_enter(",{%d}", skb->len);\r\niov[0].iov_base = skb->head;\r\niov[0].iov_len = skb->len;\r\nmsg.msg_name = &trans->peer->srx.transport.sin;\r\nmsg.msg_namelen = sizeof(trans->peer->srx.transport.sin);\r\nmsg.msg_control = NULL;\r\nmsg.msg_controllen = 0;\r\nmsg.msg_flags = 0;\r\nif (skb->len - sizeof(struct rxrpc_header) < trans->peer->maxdata) {\r\ndown_read(&trans->local->defrag_sem);\r\nret = kernel_sendmsg(trans->local->socket, &msg, iov, 1,\r\niov[0].iov_len);\r\nup_read(&trans->local->defrag_sem);\r\nif (ret == -EMSGSIZE)\r\ngoto send_fragmentable;\r\n_leave(" = %d [%u]", ret, trans->peer->maxdata);\r\nreturn ret;\r\n}\r\nsend_fragmentable:\r\n_debug("send fragment");\r\ndown_write(&trans->local->defrag_sem);\r\nopt = IP_PMTUDISC_DONT;\r\nret = kernel_setsockopt(trans->local->socket, SOL_IP, IP_MTU_DISCOVER,\r\n(char *) &opt, sizeof(opt));\r\nif (ret == 0) {\r\nret = kernel_sendmsg(trans->local->socket, &msg, iov, 1,\r\niov[0].iov_len);\r\nopt = IP_PMTUDISC_DO;\r\nkernel_setsockopt(trans->local->socket, SOL_IP,\r\nIP_MTU_DISCOVER, (char *) &opt, sizeof(opt));\r\n}\r\nup_write(&trans->local->defrag_sem);\r\n_leave(" = %d [frag %u]", ret, trans->peer->maxdata);\r\nreturn ret;\r\n}\r\nstatic int rxrpc_wait_for_tx_window(struct rxrpc_sock *rx,\r\nstruct rxrpc_call *call,\r\nlong *timeo)\r\n{\r\nDECLARE_WAITQUEUE(myself, current);\r\nint ret;\r\n_enter(",{%d},%ld",\r\nCIRC_SPACE(call->acks_head, call->acks_tail, call->acks_winsz),\r\n*timeo);\r\nadd_wait_queue(&call->tx_waitq, &myself);\r\nfor (;;) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nret = 0;\r\nif (CIRC_SPACE(call->acks_head, call->acks_tail,\r\ncall->acks_winsz) > 0)\r\nbreak;\r\nif (signal_pending(current)) {\r\nret = sock_intr_errno(*timeo);\r\nbreak;\r\n}\r\nrelease_sock(&rx->sk);\r\n*timeo = schedule_timeout(*timeo);\r\nlock_sock(&rx->sk);\r\n}\r\nremove_wait_queue(&call->tx_waitq, &myself);\r\nset_current_state(TASK_RUNNING);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic inline void rxrpc_instant_resend(struct rxrpc_call *call)\r\n{\r\nread_lock_bh(&call->state_lock);\r\nif (try_to_del_timer_sync(&call->resend_timer) >= 0) {\r\nclear_bit(RXRPC_CALL_RUN_RTIMER, &call->flags);\r\nif (call->state < RXRPC_CALL_COMPLETE &&\r\n!test_and_set_bit(RXRPC_CALL_RESEND_TIMER, &call->events))\r\nrxrpc_queue_call(call);\r\n}\r\nread_unlock_bh(&call->state_lock);\r\n}\r\nstatic void rxrpc_queue_packet(struct rxrpc_call *call, struct sk_buff *skb,\r\nbool last)\r\n{\r\nstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\r\nint ret;\r\n_net("queue skb %p [%d]", skb, call->acks_head);\r\nASSERT(call->acks_window != NULL);\r\ncall->acks_window[call->acks_head] = (unsigned long) skb;\r\nsmp_wmb();\r\ncall->acks_head = (call->acks_head + 1) & (call->acks_winsz - 1);\r\nif (last || call->state == RXRPC_CALL_SERVER_ACK_REQUEST) {\r\n_debug("________awaiting reply/ACK__________");\r\nwrite_lock_bh(&call->state_lock);\r\nswitch (call->state) {\r\ncase RXRPC_CALL_CLIENT_SEND_REQUEST:\r\ncall->state = RXRPC_CALL_CLIENT_AWAIT_REPLY;\r\nbreak;\r\ncase RXRPC_CALL_SERVER_ACK_REQUEST:\r\ncall->state = RXRPC_CALL_SERVER_SEND_REPLY;\r\nif (!last)\r\nbreak;\r\ncase RXRPC_CALL_SERVER_SEND_REPLY:\r\ncall->state = RXRPC_CALL_SERVER_AWAIT_ACK;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwrite_unlock_bh(&call->state_lock);\r\n}\r\n_proto("Tx DATA %%%u { #%u }",\r\nntohl(sp->hdr.serial), ntohl(sp->hdr.seq));\r\nsp->need_resend = false;\r\nsp->resend_at = jiffies + rxrpc_resend_timeout * HZ;\r\nif (!test_and_set_bit(RXRPC_CALL_RUN_RTIMER, &call->flags)) {\r\n_debug("run timer");\r\ncall->resend_timer.expires = sp->resend_at;\r\nadd_timer(&call->resend_timer);\r\n}\r\nret = -EAGAIN;\r\nif (try_to_del_timer_sync(&call->ack_timer) >= 0) {\r\nret = rxrpc_send_packet(call->conn->trans, skb);\r\n_net("sent skb %p", skb);\r\n} else {\r\n_debug("failed to delete ACK timer");\r\n}\r\nif (ret < 0) {\r\n_debug("need instant resend %d", ret);\r\nsp->need_resend = true;\r\nrxrpc_instant_resend(call);\r\n}\r\n_leave("");\r\n}\r\nstatic int rxrpc_send_data(struct kiocb *iocb,\r\nstruct rxrpc_sock *rx,\r\nstruct rxrpc_call *call,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nstruct rxrpc_skb_priv *sp;\r\nunsigned char __user *from;\r\nstruct sk_buff *skb;\r\nstruct iovec *iov;\r\nstruct sock *sk = &rx->sk;\r\nlong timeo;\r\nbool more;\r\nint ret, ioc, segment, copied;\r\n_enter(",,,{%zu},%zu", msg->msg_iovlen, len);\r\ntimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\r\nclear_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);\r\nif (sk->sk_err || (sk->sk_shutdown & SEND_SHUTDOWN))\r\nreturn -EPIPE;\r\niov = msg->msg_iov;\r\nioc = msg->msg_iovlen - 1;\r\nfrom = iov->iov_base;\r\nsegment = iov->iov_len;\r\niov++;\r\nmore = msg->msg_flags & MSG_MORE;\r\nskb = call->tx_pending;\r\ncall->tx_pending = NULL;\r\ncopied = 0;\r\ndo {\r\nint copy;\r\nif (segment > len)\r\nsegment = len;\r\n_debug("SEGMENT %d @%p", segment, from);\r\nif (!skb) {\r\nsize_t size, chunk, max, space;\r\n_debug("alloc");\r\nif (CIRC_SPACE(call->acks_head, call->acks_tail,\r\ncall->acks_winsz) <= 0) {\r\nret = -EAGAIN;\r\nif (msg->msg_flags & MSG_DONTWAIT)\r\ngoto maybe_error;\r\nret = rxrpc_wait_for_tx_window(rx, call,\r\n&timeo);\r\nif (ret < 0)\r\ngoto maybe_error;\r\n}\r\nmax = call->conn->trans->peer->maxdata;\r\nmax -= call->conn->security_size;\r\nmax &= ~(call->conn->size_align - 1UL);\r\nchunk = max;\r\nif (chunk > len && !more)\r\nchunk = len;\r\nspace = chunk + call->conn->size_align;\r\nspace &= ~(call->conn->size_align - 1UL);\r\nsize = space + call->conn->header_size;\r\n_debug("SIZE: %zu/%zu/%zu", chunk, space, size);\r\nskb = sock_alloc_send_skb(\r\nsk, size, msg->msg_flags & MSG_DONTWAIT, &ret);\r\nif (!skb)\r\ngoto maybe_error;\r\nrxrpc_new_skb(skb);\r\n_debug("ALLOC SEND %p", skb);\r\nASSERTCMP(skb->mark, ==, 0);\r\n_debug("HS: %u", call->conn->header_size);\r\nskb_reserve(skb, call->conn->header_size);\r\nskb->len += call->conn->header_size;\r\nsp = rxrpc_skb(skb);\r\nsp->remain = chunk;\r\nif (sp->remain > skb_tailroom(skb))\r\nsp->remain = skb_tailroom(skb);\r\n_net("skb: hr %d, tr %d, hl %d, rm %d",\r\nskb_headroom(skb),\r\nskb_tailroom(skb),\r\nskb_headlen(skb),\r\nsp->remain);\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\n}\r\n_debug("append");\r\nsp = rxrpc_skb(skb);\r\ncopy = skb_tailroom(skb);\r\nASSERTCMP(copy, >, 0);\r\nif (copy > segment)\r\ncopy = segment;\r\nif (copy > sp->remain)\r\ncopy = sp->remain;\r\n_debug("add");\r\nret = skb_add_data(skb, from, copy);\r\n_debug("added");\r\nif (ret < 0)\r\ngoto efault;\r\nsp->remain -= copy;\r\nskb->mark += copy;\r\ncopied += copy;\r\nlen -= copy;\r\nsegment -= copy;\r\nfrom += copy;\r\nwhile (segment == 0 && ioc > 0) {\r\nfrom = iov->iov_base;\r\nsegment = iov->iov_len;\r\niov++;\r\nioc--;\r\n}\r\nif (len == 0) {\r\nsegment = 0;\r\nioc = 0;\r\n}\r\nif (call->state > RXRPC_CALL_COMPLETE)\r\ngoto call_aborted;\r\nif (sp->remain <= 0 || (segment == 0 && !more)) {\r\nstruct rxrpc_connection *conn = call->conn;\r\nsize_t pad;\r\nif (conn->security) {\r\npad = conn->security_size + skb->mark;\r\npad = conn->size_align - pad;\r\npad &= conn->size_align - 1;\r\n_debug("pad %zu", pad);\r\nif (pad)\r\nmemset(skb_put(skb, pad), 0, pad);\r\n}\r\nsp->hdr.epoch = conn->epoch;\r\nsp->hdr.cid = call->cid;\r\nsp->hdr.callNumber = call->call_id;\r\nsp->hdr.seq =\r\nhtonl(atomic_inc_return(&call->sequence));\r\nsp->hdr.serial =\r\nhtonl(atomic_inc_return(&conn->serial));\r\nsp->hdr.type = RXRPC_PACKET_TYPE_DATA;\r\nsp->hdr.userStatus = 0;\r\nsp->hdr.securityIndex = conn->security_ix;\r\nsp->hdr._rsvd = 0;\r\nsp->hdr.serviceId = conn->service_id;\r\nsp->hdr.flags = conn->out_clientflag;\r\nif (len == 0 && !more)\r\nsp->hdr.flags |= RXRPC_LAST_PACKET;\r\nelse if (CIRC_SPACE(call->acks_head, call->acks_tail,\r\ncall->acks_winsz) > 1)\r\nsp->hdr.flags |= RXRPC_MORE_PACKETS;\r\nret = rxrpc_secure_packet(\r\ncall, skb, skb->mark,\r\nskb->head + sizeof(struct rxrpc_header));\r\nif (ret < 0)\r\ngoto out;\r\nmemcpy(skb->head, &sp->hdr,\r\nsizeof(struct rxrpc_header));\r\nrxrpc_queue_packet(call, skb, segment == 0 && !more);\r\nskb = NULL;\r\n}\r\n} while (segment > 0);\r\nsuccess:\r\nret = copied;\r\nout:\r\ncall->tx_pending = skb;\r\n_leave(" = %d", ret);\r\nreturn ret;\r\ncall_aborted:\r\nrxrpc_free_skb(skb);\r\nif (call->state == RXRPC_CALL_NETWORK_ERROR)\r\nret = call->conn->trans->peer->net_error;\r\nelse\r\nret = -ECONNABORTED;\r\n_leave(" = %d", ret);\r\nreturn ret;\r\nmaybe_error:\r\nif (copied)\r\ngoto success;\r\ngoto out;\r\nefault:\r\nret = -EFAULT;\r\ngoto out;\r\n}
