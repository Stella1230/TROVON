int gelic_card_set_irq_mask(struct gelic_card *card, u64 mask)\r\n{\r\nint status;\r\nstatus = lv1_net_set_interrupt_mask(bus_id(card), dev_id(card),\r\nmask, 0);\r\nif (status)\r\ndev_info(ctodev(card),\r\n"%s failed %d\n", __func__, status);\r\nreturn status;\r\n}\r\nstatic inline void gelic_card_rx_irq_on(struct gelic_card *card)\r\n{\r\ncard->irq_mask |= GELIC_CARD_RXINT;\r\ngelic_card_set_irq_mask(card, card->irq_mask);\r\n}\r\nstatic inline void gelic_card_rx_irq_off(struct gelic_card *card)\r\n{\r\ncard->irq_mask &= ~GELIC_CARD_RXINT;\r\ngelic_card_set_irq_mask(card, card->irq_mask);\r\n}\r\nstatic void gelic_card_get_ether_port_status(struct gelic_card *card,\r\nint inform)\r\n{\r\nu64 v2;\r\nstruct net_device *ether_netdev;\r\nlv1_net_control(bus_id(card), dev_id(card),\r\nGELIC_LV1_GET_ETH_PORT_STATUS,\r\nGELIC_LV1_VLAN_TX_ETHERNET_0, 0, 0,\r\n&card->ether_port_status, &v2);\r\nif (inform) {\r\nether_netdev = card->netdev[GELIC_PORT_ETHERNET_0];\r\nif (card->ether_port_status & GELIC_LV1_ETHER_LINK_UP)\r\nnetif_carrier_on(ether_netdev);\r\nelse\r\nnetif_carrier_off(ether_netdev);\r\n}\r\n}\r\nstatic int gelic_card_set_link_mode(struct gelic_card *card, int mode)\r\n{\r\nint status;\r\nu64 v1, v2;\r\nstatus = lv1_net_control(bus_id(card), dev_id(card),\r\nGELIC_LV1_SET_NEGOTIATION_MODE,\r\nGELIC_LV1_PHY_ETHERNET_0, mode, 0, &v1, &v2);\r\nif (status) {\r\npr_info("%s: failed setting negotiation mode %d\n", __func__,\r\nstatus);\r\nreturn -EBUSY;\r\n}\r\ncard->link_mode = mode;\r\nreturn 0;\r\n}\r\nvoid gelic_card_up(struct gelic_card *card)\r\n{\r\npr_debug("%s: called\n", __func__);\r\nmutex_lock(&card->updown_lock);\r\nif (atomic_inc_return(&card->users) == 1) {\r\npr_debug("%s: real do\n", __func__);\r\ngelic_card_set_irq_mask(card, card->irq_mask);\r\ngelic_card_enable_rxdmac(card);\r\nnapi_enable(&card->napi);\r\n}\r\nmutex_unlock(&card->updown_lock);\r\npr_debug("%s: done\n", __func__);\r\n}\r\nvoid gelic_card_down(struct gelic_card *card)\r\n{\r\nu64 mask;\r\npr_debug("%s: called\n", __func__);\r\nmutex_lock(&card->updown_lock);\r\nif (atomic_dec_if_positive(&card->users) == 0) {\r\npr_debug("%s: real do\n", __func__);\r\nnapi_disable(&card->napi);\r\nmask = card->irq_mask & (GELIC_CARD_WLAN_EVENT_RECEIVED |\r\nGELIC_CARD_WLAN_COMMAND_COMPLETED);\r\ngelic_card_set_irq_mask(card, mask);\r\ngelic_card_disable_rxdmac(card);\r\ngelic_card_reset_chain(card, &card->rx_chain,\r\ncard->descr + GELIC_NET_TX_DESCRIPTORS);\r\ngelic_card_disable_txdmac(card);\r\n}\r\nmutex_unlock(&card->updown_lock);\r\npr_debug("%s: done\n", __func__);\r\n}\r\nstatic enum gelic_descr_dma_status\r\ngelic_descr_get_status(struct gelic_descr *descr)\r\n{\r\nreturn be32_to_cpu(descr->dmac_cmd_status) & GELIC_DESCR_DMA_STAT_MASK;\r\n}\r\nstatic void gelic_descr_set_status(struct gelic_descr *descr,\r\nenum gelic_descr_dma_status status)\r\n{\r\ndescr->dmac_cmd_status = cpu_to_be32(status |\r\n(be32_to_cpu(descr->dmac_cmd_status) &\r\n~GELIC_DESCR_DMA_STAT_MASK));\r\nwmb();\r\n}\r\nstatic void gelic_card_free_chain(struct gelic_card *card,\r\nstruct gelic_descr *descr_in)\r\n{\r\nstruct gelic_descr *descr;\r\nfor (descr = descr_in; descr && descr->bus_addr; descr = descr->next) {\r\ndma_unmap_single(ctodev(card), descr->bus_addr,\r\nGELIC_DESCR_SIZE, DMA_BIDIRECTIONAL);\r\ndescr->bus_addr = 0;\r\n}\r\n}\r\nstatic int __devinit gelic_card_init_chain(struct gelic_card *card,\r\nstruct gelic_descr_chain *chain,\r\nstruct gelic_descr *start_descr,\r\nint no)\r\n{\r\nint i;\r\nstruct gelic_descr *descr;\r\ndescr = start_descr;\r\nmemset(descr, 0, sizeof(*descr) * no);\r\nfor (i = 0; i < no; i++, descr++) {\r\ngelic_descr_set_status(descr, GELIC_DESCR_DMA_NOT_IN_USE);\r\ndescr->bus_addr =\r\ndma_map_single(ctodev(card), descr,\r\nGELIC_DESCR_SIZE,\r\nDMA_BIDIRECTIONAL);\r\nif (!descr->bus_addr)\r\ngoto iommu_error;\r\ndescr->next = descr + 1;\r\ndescr->prev = descr - 1;\r\n}\r\n(descr - 1)->next = start_descr;\r\nstart_descr->prev = (descr - 1);\r\ndescr = start_descr;\r\nfor (i = 0; i < no; i++, descr++) {\r\ndescr->next_descr_addr = cpu_to_be32(descr->next->bus_addr);\r\n}\r\nchain->head = start_descr;\r\nchain->tail = start_descr;\r\n(descr - 1)->next_descr_addr = 0;\r\nreturn 0;\r\niommu_error:\r\nfor (i--, descr--; 0 <= i; i--, descr--)\r\nif (descr->bus_addr)\r\ndma_unmap_single(ctodev(card), descr->bus_addr,\r\nGELIC_DESCR_SIZE,\r\nDMA_BIDIRECTIONAL);\r\nreturn -ENOMEM;\r\n}\r\nstatic void gelic_card_reset_chain(struct gelic_card *card,\r\nstruct gelic_descr_chain *chain,\r\nstruct gelic_descr *start_descr)\r\n{\r\nstruct gelic_descr *descr;\r\nfor (descr = start_descr; start_descr != descr->next; descr++) {\r\ngelic_descr_set_status(descr, GELIC_DESCR_DMA_CARDOWNED);\r\ndescr->next_descr_addr = cpu_to_be32(descr->next->bus_addr);\r\n}\r\nchain->head = start_descr;\r\nchain->tail = (descr - 1);\r\n(descr - 1)->next_descr_addr = 0;\r\n}\r\nstatic int gelic_descr_prepare_rx(struct gelic_card *card,\r\nstruct gelic_descr *descr)\r\n{\r\nint offset;\r\nunsigned int bufsize;\r\nif (gelic_descr_get_status(descr) != GELIC_DESCR_DMA_NOT_IN_USE)\r\ndev_info(ctodev(card), "%s: ERROR status\n", __func__);\r\nbufsize = ALIGN(GELIC_NET_MAX_MTU, GELIC_NET_RXBUF_ALIGN);\r\ndescr->skb = dev_alloc_skb(bufsize + GELIC_NET_RXBUF_ALIGN - 1);\r\nif (!descr->skb) {\r\ndescr->buf_addr = 0;\r\ndev_info(ctodev(card),\r\n"%s:allocate skb failed !!\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\ndescr->buf_size = cpu_to_be32(bufsize);\r\ndescr->dmac_cmd_status = 0;\r\ndescr->result_size = 0;\r\ndescr->valid_size = 0;\r\ndescr->data_error = 0;\r\noffset = ((unsigned long)descr->skb->data) &\r\n(GELIC_NET_RXBUF_ALIGN - 1);\r\nif (offset)\r\nskb_reserve(descr->skb, GELIC_NET_RXBUF_ALIGN - offset);\r\ndescr->buf_addr = cpu_to_be32(dma_map_single(ctodev(card),\r\ndescr->skb->data,\r\nGELIC_NET_MAX_MTU,\r\nDMA_FROM_DEVICE));\r\nif (!descr->buf_addr) {\r\ndev_kfree_skb_any(descr->skb);\r\ndescr->skb = NULL;\r\ndev_info(ctodev(card),\r\n"%s:Could not iommu-map rx buffer\n", __func__);\r\ngelic_descr_set_status(descr, GELIC_DESCR_DMA_NOT_IN_USE);\r\nreturn -ENOMEM;\r\n} else {\r\ngelic_descr_set_status(descr, GELIC_DESCR_DMA_CARDOWNED);\r\nreturn 0;\r\n}\r\n}\r\nstatic void gelic_card_release_rx_chain(struct gelic_card *card)\r\n{\r\nstruct gelic_descr *descr = card->rx_chain.head;\r\ndo {\r\nif (descr->skb) {\r\ndma_unmap_single(ctodev(card),\r\nbe32_to_cpu(descr->buf_addr),\r\ndescr->skb->len,\r\nDMA_FROM_DEVICE);\r\ndescr->buf_addr = 0;\r\ndev_kfree_skb_any(descr->skb);\r\ndescr->skb = NULL;\r\ngelic_descr_set_status(descr,\r\nGELIC_DESCR_DMA_NOT_IN_USE);\r\n}\r\ndescr = descr->next;\r\n} while (descr != card->rx_chain.head);\r\n}\r\nstatic int gelic_card_fill_rx_chain(struct gelic_card *card)\r\n{\r\nstruct gelic_descr *descr = card->rx_chain.head;\r\nint ret;\r\ndo {\r\nif (!descr->skb) {\r\nret = gelic_descr_prepare_rx(card, descr);\r\nif (ret)\r\ngoto rewind;\r\n}\r\ndescr = descr->next;\r\n} while (descr != card->rx_chain.head);\r\nreturn 0;\r\nrewind:\r\ngelic_card_release_rx_chain(card);\r\nreturn ret;\r\n}\r\nstatic int __devinit gelic_card_alloc_rx_skbs(struct gelic_card *card)\r\n{\r\nstruct gelic_descr_chain *chain;\r\nint ret;\r\nchain = &card->rx_chain;\r\nret = gelic_card_fill_rx_chain(card);\r\nchain->tail = card->rx_top->prev;\r\nreturn ret;\r\n}\r\nstatic void gelic_descr_release_tx(struct gelic_card *card,\r\nstruct gelic_descr *descr)\r\n{\r\nstruct sk_buff *skb = descr->skb;\r\nBUG_ON(!(be32_to_cpu(descr->data_status) & GELIC_DESCR_TX_TAIL));\r\ndma_unmap_single(ctodev(card), be32_to_cpu(descr->buf_addr), skb->len,\r\nDMA_TO_DEVICE);\r\ndev_kfree_skb_any(skb);\r\ndescr->buf_addr = 0;\r\ndescr->buf_size = 0;\r\ndescr->next_descr_addr = 0;\r\ndescr->result_size = 0;\r\ndescr->valid_size = 0;\r\ndescr->data_status = 0;\r\ndescr->data_error = 0;\r\ndescr->skb = NULL;\r\ngelic_descr_set_status(descr, GELIC_DESCR_DMA_NOT_IN_USE);\r\n}\r\nstatic void gelic_card_stop_queues(struct gelic_card *card)\r\n{\r\nnetif_stop_queue(card->netdev[GELIC_PORT_ETHERNET_0]);\r\nif (card->netdev[GELIC_PORT_WIRELESS])\r\nnetif_stop_queue(card->netdev[GELIC_PORT_WIRELESS]);\r\n}\r\nstatic void gelic_card_wake_queues(struct gelic_card *card)\r\n{\r\nnetif_wake_queue(card->netdev[GELIC_PORT_ETHERNET_0]);\r\nif (card->netdev[GELIC_PORT_WIRELESS])\r\nnetif_wake_queue(card->netdev[GELIC_PORT_WIRELESS]);\r\n}\r\nstatic void gelic_card_release_tx_chain(struct gelic_card *card, int stop)\r\n{\r\nstruct gelic_descr_chain *tx_chain;\r\nenum gelic_descr_dma_status status;\r\nstruct net_device *netdev;\r\nint release = 0;\r\nfor (tx_chain = &card->tx_chain;\r\ntx_chain->head != tx_chain->tail && tx_chain->tail;\r\ntx_chain->tail = tx_chain->tail->next) {\r\nstatus = gelic_descr_get_status(tx_chain->tail);\r\nnetdev = tx_chain->tail->skb->dev;\r\nswitch (status) {\r\ncase GELIC_DESCR_DMA_RESPONSE_ERROR:\r\ncase GELIC_DESCR_DMA_PROTECTION_ERROR:\r\ncase GELIC_DESCR_DMA_FORCE_END:\r\nif (printk_ratelimit())\r\ndev_info(ctodev(card),\r\n"%s: forcing end of tx descriptor " \\r\n"with status %x\n",\r\n__func__, status);\r\nnetdev->stats.tx_dropped++;\r\nbreak;\r\ncase GELIC_DESCR_DMA_COMPLETE:\r\nif (tx_chain->tail->skb) {\r\nnetdev->stats.tx_packets++;\r\nnetdev->stats.tx_bytes +=\r\ntx_chain->tail->skb->len;\r\n}\r\nbreak;\r\ncase GELIC_DESCR_DMA_CARDOWNED:\r\ndefault:\r\nif (!stop)\r\ngoto out;\r\n}\r\ngelic_descr_release_tx(card, tx_chain->tail);\r\nrelease ++;\r\n}\r\nout:\r\nif (!stop && release)\r\ngelic_card_wake_queues(card);\r\n}\r\nvoid gelic_net_set_multi(struct net_device *netdev)\r\n{\r\nstruct gelic_card *card = netdev_card(netdev);\r\nstruct netdev_hw_addr *ha;\r\nunsigned int i;\r\nuint8_t *p;\r\nu64 addr;\r\nint status;\r\nstatus = lv1_net_remove_multicast_address(bus_id(card), dev_id(card),\r\n0, 1);\r\nif (status)\r\ndev_err(ctodev(card),\r\n"lv1_net_remove_multicast_address failed %d\n",\r\nstatus);\r\nstatus = lv1_net_add_multicast_address(bus_id(card), dev_id(card),\r\nGELIC_NET_BROADCAST_ADDR, 0);\r\nif (status)\r\ndev_err(ctodev(card),\r\n"lv1_net_add_multicast_address failed, %d\n",\r\nstatus);\r\nif ((netdev->flags & IFF_ALLMULTI) ||\r\n(netdev_mc_count(netdev) > GELIC_NET_MC_COUNT_MAX)) {\r\nstatus = lv1_net_add_multicast_address(bus_id(card),\r\ndev_id(card),\r\n0, 1);\r\nif (status)\r\ndev_err(ctodev(card),\r\n"lv1_net_add_multicast_address failed, %d\n",\r\nstatus);\r\nreturn;\r\n}\r\nnetdev_for_each_mc_addr(ha, netdev) {\r\naddr = 0;\r\np = ha->addr;\r\nfor (i = 0; i < ETH_ALEN; i++) {\r\naddr <<= 8;\r\naddr |= *p++;\r\n}\r\nstatus = lv1_net_add_multicast_address(bus_id(card),\r\ndev_id(card),\r\naddr, 0);\r\nif (status)\r\ndev_err(ctodev(card),\r\n"lv1_net_add_multicast_address failed, %d\n",\r\nstatus);\r\n}\r\n}\r\nstatic inline void gelic_card_enable_rxdmac(struct gelic_card *card)\r\n{\r\nint status;\r\n#ifdef DEBUG\r\nif (gelic_descr_get_status(card->rx_chain.head) !=\r\nGELIC_DESCR_DMA_CARDOWNED) {\r\nprintk(KERN_ERR "%s: status=%x\n", __func__,\r\nbe32_to_cpu(card->rx_chain.head->dmac_cmd_status));\r\nprintk(KERN_ERR "%s: nextphy=%x\n", __func__,\r\nbe32_to_cpu(card->rx_chain.head->next_descr_addr));\r\nprintk(KERN_ERR "%s: head=%p\n", __func__,\r\ncard->rx_chain.head);\r\n}\r\n#endif\r\nstatus = lv1_net_start_rx_dma(bus_id(card), dev_id(card),\r\ncard->rx_chain.head->bus_addr, 0);\r\nif (status)\r\ndev_info(ctodev(card),\r\n"lv1_net_start_rx_dma failed, status=%d\n", status);\r\n}\r\nstatic inline void gelic_card_disable_rxdmac(struct gelic_card *card)\r\n{\r\nint status;\r\nstatus = lv1_net_stop_rx_dma(bus_id(card), dev_id(card));\r\nif (status)\r\ndev_err(ctodev(card),\r\n"lv1_net_stop_rx_dma failed, %d\n", status);\r\n}\r\nstatic inline void gelic_card_disable_txdmac(struct gelic_card *card)\r\n{\r\nint status;\r\nstatus = lv1_net_stop_tx_dma(bus_id(card), dev_id(card));\r\nif (status)\r\ndev_err(ctodev(card),\r\n"lv1_net_stop_tx_dma failed, status=%d\n", status);\r\n}\r\nint gelic_net_stop(struct net_device *netdev)\r\n{\r\nstruct gelic_card *card;\r\npr_debug("%s: start\n", __func__);\r\nnetif_stop_queue(netdev);\r\nnetif_carrier_off(netdev);\r\ncard = netdev_card(netdev);\r\ngelic_card_down(card);\r\npr_debug("%s: done\n", __func__);\r\nreturn 0;\r\n}\r\nstatic struct gelic_descr *\r\ngelic_card_get_next_tx_descr(struct gelic_card *card)\r\n{\r\nif (!card->tx_chain.head)\r\nreturn NULL;\r\nif (card->tx_chain.tail != card->tx_chain.head->next &&\r\ngelic_descr_get_status(card->tx_chain.head) ==\r\nGELIC_DESCR_DMA_NOT_IN_USE)\r\nreturn card->tx_chain.head;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic void gelic_descr_set_tx_cmdstat(struct gelic_descr *descr,\r\nstruct sk_buff *skb)\r\n{\r\nif (skb->ip_summed != CHECKSUM_PARTIAL)\r\ndescr->dmac_cmd_status =\r\ncpu_to_be32(GELIC_DESCR_DMA_CMD_NO_CHKSUM |\r\nGELIC_DESCR_TX_DMA_FRAME_TAIL);\r\nelse {\r\nif (skb->protocol == htons(ETH_P_IP)) {\r\nif (ip_hdr(skb)->protocol == IPPROTO_TCP)\r\ndescr->dmac_cmd_status =\r\ncpu_to_be32(GELIC_DESCR_DMA_CMD_TCP_CHKSUM |\r\nGELIC_DESCR_TX_DMA_FRAME_TAIL);\r\nelse if (ip_hdr(skb)->protocol == IPPROTO_UDP)\r\ndescr->dmac_cmd_status =\r\ncpu_to_be32(GELIC_DESCR_DMA_CMD_UDP_CHKSUM |\r\nGELIC_DESCR_TX_DMA_FRAME_TAIL);\r\nelse\r\ndescr->dmac_cmd_status =\r\ncpu_to_be32(GELIC_DESCR_DMA_CMD_NO_CHKSUM |\r\nGELIC_DESCR_TX_DMA_FRAME_TAIL);\r\n}\r\n}\r\n}\r\nstatic inline struct sk_buff *gelic_put_vlan_tag(struct sk_buff *skb,\r\nunsigned short tag)\r\n{\r\nstruct vlan_ethhdr *veth;\r\nstatic unsigned int c;\r\nif (skb_headroom(skb) < VLAN_HLEN) {\r\nstruct sk_buff *sk_tmp = skb;\r\npr_debug("%s: hd=%d c=%ud\n", __func__, skb_headroom(skb), c);\r\nskb = skb_realloc_headroom(sk_tmp, VLAN_HLEN);\r\nif (!skb)\r\nreturn NULL;\r\ndev_kfree_skb_any(sk_tmp);\r\n}\r\nveth = (struct vlan_ethhdr *)skb_push(skb, VLAN_HLEN);\r\nmemmove(skb->data, skb->data + VLAN_HLEN, 2 * ETH_ALEN);\r\nveth->h_vlan_proto = cpu_to_be16(ETH_P_8021Q);\r\nveth->h_vlan_TCI = htons(tag);\r\nreturn skb;\r\n}\r\nstatic int gelic_descr_prepare_tx(struct gelic_card *card,\r\nstruct gelic_descr *descr,\r\nstruct sk_buff *skb)\r\n{\r\ndma_addr_t buf;\r\nif (card->vlan_required) {\r\nstruct sk_buff *skb_tmp;\r\nenum gelic_port_type type;\r\ntype = netdev_port(skb->dev)->type;\r\nskb_tmp = gelic_put_vlan_tag(skb,\r\ncard->vlan[type].tx);\r\nif (!skb_tmp)\r\nreturn -ENOMEM;\r\nskb = skb_tmp;\r\n}\r\nbuf = dma_map_single(ctodev(card), skb->data, skb->len, DMA_TO_DEVICE);\r\nif (!buf) {\r\ndev_err(ctodev(card),\r\n"dma map 2 failed (%p, %i). Dropping packet\n",\r\nskb->data, skb->len);\r\nreturn -ENOMEM;\r\n}\r\ndescr->buf_addr = cpu_to_be32(buf);\r\ndescr->buf_size = cpu_to_be32(skb->len);\r\ndescr->skb = skb;\r\ndescr->data_status = 0;\r\ndescr->next_descr_addr = 0;\r\ngelic_descr_set_tx_cmdstat(descr, skb);\r\ncard->tx_chain.head = descr->next;\r\nreturn 0;\r\n}\r\nstatic int gelic_card_kick_txdma(struct gelic_card *card,\r\nstruct gelic_descr *descr)\r\n{\r\nint status = 0;\r\nif (card->tx_dma_progress)\r\nreturn 0;\r\nif (gelic_descr_get_status(descr) == GELIC_DESCR_DMA_CARDOWNED) {\r\ncard->tx_dma_progress = 1;\r\nstatus = lv1_net_start_tx_dma(bus_id(card), dev_id(card),\r\ndescr->bus_addr, 0);\r\nif (status) {\r\ncard->tx_dma_progress = 0;\r\ndev_info(ctodev(card), "lv1_net_start_txdma failed," \\r\n"status=%d\n", status);\r\n}\r\n}\r\nreturn status;\r\n}\r\nint gelic_net_xmit(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nstruct gelic_card *card = netdev_card(netdev);\r\nstruct gelic_descr *descr;\r\nint result;\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->tx_lock, flags);\r\ngelic_card_release_tx_chain(card, 0);\r\ndescr = gelic_card_get_next_tx_descr(card);\r\nif (!descr) {\r\ngelic_card_stop_queues(card);\r\nspin_unlock_irqrestore(&card->tx_lock, flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nresult = gelic_descr_prepare_tx(card, descr, skb);\r\nif (result) {\r\nnetdev->stats.tx_dropped++;\r\ndev_kfree_skb_any(skb);\r\nspin_unlock_irqrestore(&card->tx_lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\ndescr->prev->next_descr_addr = cpu_to_be32(descr->bus_addr);\r\nwmb();\r\nif (gelic_card_kick_txdma(card, descr)) {\r\nnetdev->stats.tx_dropped++;\r\ndescr->data_status = cpu_to_be32(GELIC_DESCR_TX_TAIL);\r\ngelic_descr_release_tx(card, descr);\r\ncard->tx_chain.head = descr;\r\ndescr->prev->next_descr_addr = 0;\r\ndev_info(ctodev(card), "%s: kick failure\n", __func__);\r\n}\r\nspin_unlock_irqrestore(&card->tx_lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void gelic_net_pass_skb_up(struct gelic_descr *descr,\r\nstruct gelic_card *card,\r\nstruct net_device *netdev)\r\n{\r\nstruct sk_buff *skb = descr->skb;\r\nu32 data_status, data_error;\r\ndata_status = be32_to_cpu(descr->data_status);\r\ndata_error = be32_to_cpu(descr->data_error);\r\ndma_unmap_single(ctodev(card), be32_to_cpu(descr->buf_addr),\r\nGELIC_NET_MAX_MTU,\r\nDMA_FROM_DEVICE);\r\nskb_put(skb, be32_to_cpu(descr->valid_size)?\r\nbe32_to_cpu(descr->valid_size) :\r\nbe32_to_cpu(descr->result_size));\r\nif (!descr->valid_size)\r\ndev_info(ctodev(card), "buffer full %x %x %x\n",\r\nbe32_to_cpu(descr->result_size),\r\nbe32_to_cpu(descr->buf_size),\r\nbe32_to_cpu(descr->dmac_cmd_status));\r\ndescr->skb = NULL;\r\nskb_pull(skb, 2);\r\nskb->protocol = eth_type_trans(skb, netdev);\r\nif (netdev->features & NETIF_F_RXCSUM) {\r\nif ((data_status & GELIC_DESCR_DATA_STATUS_CHK_MASK) &&\r\n(!(data_error & GELIC_DESCR_DATA_ERROR_CHK_MASK)))\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nelse\r\nskb_checksum_none_assert(skb);\r\n} else\r\nskb_checksum_none_assert(skb);\r\nnetdev->stats.rx_packets++;\r\nnetdev->stats.rx_bytes += skb->len;\r\nnetif_receive_skb(skb);\r\n}\r\nstatic int gelic_card_decode_one_descr(struct gelic_card *card)\r\n{\r\nenum gelic_descr_dma_status status;\r\nstruct gelic_descr_chain *chain = &card->rx_chain;\r\nstruct gelic_descr *descr = chain->head;\r\nstruct net_device *netdev = NULL;\r\nint dmac_chain_ended;\r\nstatus = gelic_descr_get_status(descr);\r\nif (status == GELIC_DESCR_DMA_CARDOWNED)\r\nreturn 0;\r\nif (status == GELIC_DESCR_DMA_NOT_IN_USE) {\r\ndev_dbg(ctodev(card), "dormant descr? %p\n", descr);\r\nreturn 0;\r\n}\r\nif (card->vlan_required) {\r\nunsigned int i;\r\nu16 vid;\r\nvid = *(u16 *)(descr->skb->data) & VLAN_VID_MASK;\r\nfor (i = 0; i < GELIC_PORT_MAX; i++) {\r\nif (card->vlan[i].rx == vid) {\r\nnetdev = card->netdev[i];\r\nbreak;\r\n}\r\n}\r\nif (GELIC_PORT_MAX <= i) {\r\npr_info("%s: unknown packet vid=%x\n", __func__, vid);\r\ngoto refill;\r\n}\r\n} else\r\nnetdev = card->netdev[GELIC_PORT_ETHERNET_0];\r\nif ((status == GELIC_DESCR_DMA_RESPONSE_ERROR) ||\r\n(status == GELIC_DESCR_DMA_PROTECTION_ERROR) ||\r\n(status == GELIC_DESCR_DMA_FORCE_END)) {\r\ndev_info(ctodev(card), "dropping RX descriptor with state %x\n",\r\nstatus);\r\nnetdev->stats.rx_dropped++;\r\ngoto refill;\r\n}\r\nif (status == GELIC_DESCR_DMA_BUFFER_FULL) {\r\ndev_info(ctodev(card), "overlength frame\n");\r\ngoto refill;\r\n}\r\nif (status != GELIC_DESCR_DMA_FRAME_END) {\r\ndev_dbg(ctodev(card), "RX descriptor with state %x\n",\r\nstatus);\r\ngoto refill;\r\n}\r\ngelic_net_pass_skb_up(descr, card, netdev);\r\nrefill:\r\ndmac_chain_ended =\r\nbe32_to_cpu(descr->dmac_cmd_status) &\r\nGELIC_DESCR_RX_DMA_CHAIN_END;\r\ndescr->next_descr_addr = 0;\r\ngelic_descr_set_status(descr, GELIC_DESCR_DMA_NOT_IN_USE);\r\ngelic_descr_prepare_rx(card, descr);\r\nchain->tail = descr;\r\nchain->head = descr->next;\r\ndescr->prev->next_descr_addr = cpu_to_be32(descr->bus_addr);\r\nif (dmac_chain_ended)\r\ngelic_card_enable_rxdmac(card);\r\nreturn 1;\r\n}\r\nstatic int gelic_net_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct gelic_card *card = container_of(napi, struct gelic_card, napi);\r\nint packets_done = 0;\r\nwhile (packets_done < budget) {\r\nif (!gelic_card_decode_one_descr(card))\r\nbreak;\r\npackets_done++;\r\n}\r\nif (packets_done < budget) {\r\nnapi_complete(napi);\r\ngelic_card_rx_irq_on(card);\r\n}\r\nreturn packets_done;\r\n}\r\nint gelic_net_change_mtu(struct net_device *netdev, int new_mtu)\r\n{\r\nif ((new_mtu < GELIC_NET_MIN_MTU) ||\r\n(new_mtu > GELIC_NET_MAX_MTU)) {\r\nreturn -EINVAL;\r\n}\r\nnetdev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t gelic_card_interrupt(int irq, void *ptr)\r\n{\r\nunsigned long flags;\r\nstruct gelic_card *card = ptr;\r\nu64 status;\r\nstatus = card->irq_status;\r\nif (!status)\r\nreturn IRQ_NONE;\r\nstatus &= card->irq_mask;\r\nif (status & GELIC_CARD_RXINT) {\r\ngelic_card_rx_irq_off(card);\r\nnapi_schedule(&card->napi);\r\n}\r\nif (status & GELIC_CARD_TXINT) {\r\nspin_lock_irqsave(&card->tx_lock, flags);\r\ncard->tx_dma_progress = 0;\r\ngelic_card_release_tx_chain(card, 0);\r\ngelic_card_kick_txdma(card, card->tx_chain.tail);\r\nspin_unlock_irqrestore(&card->tx_lock, flags);\r\n}\r\nif (status & GELIC_CARD_PORT_STATUS_CHANGED)\r\ngelic_card_get_ether_port_status(card, 1);\r\n#ifdef CONFIG_GELIC_WIRELESS\r\nif (status & (GELIC_CARD_WLAN_EVENT_RECEIVED |\r\nGELIC_CARD_WLAN_COMMAND_COMPLETED))\r\ngelic_wl_interrupt(card->netdev[GELIC_PORT_WIRELESS], status);\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid gelic_net_poll_controller(struct net_device *netdev)\r\n{\r\nstruct gelic_card *card = netdev_card(netdev);\r\ngelic_card_set_irq_mask(card, 0);\r\ngelic_card_interrupt(netdev->irq, netdev);\r\ngelic_card_set_irq_mask(card, card->irq_mask);\r\n}\r\nint gelic_net_open(struct net_device *netdev)\r\n{\r\nstruct gelic_card *card = netdev_card(netdev);\r\ndev_dbg(ctodev(card), " -> %s %p\n", __func__, netdev);\r\ngelic_card_up(card);\r\nnetif_start_queue(netdev);\r\ngelic_card_get_ether_port_status(card, 1);\r\ndev_dbg(ctodev(card), " <- %s\n", __func__);\r\nreturn 0;\r\n}\r\nvoid gelic_net_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrncpy(info->driver, DRV_NAME, sizeof(info->driver) - 1);\r\nstrncpy(info->version, DRV_VERSION, sizeof(info->version) - 1);\r\n}\r\nstatic int gelic_ether_get_settings(struct net_device *netdev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct gelic_card *card = netdev_card(netdev);\r\ngelic_card_get_ether_port_status(card, 0);\r\nif (card->ether_port_status & GELIC_LV1_ETHER_FULL_DUPLEX)\r\ncmd->duplex = DUPLEX_FULL;\r\nelse\r\ncmd->duplex = DUPLEX_HALF;\r\nswitch (card->ether_port_status & GELIC_LV1_ETHER_SPEED_MASK) {\r\ncase GELIC_LV1_ETHER_SPEED_10:\r\nethtool_cmd_speed_set(cmd, SPEED_10);\r\nbreak;\r\ncase GELIC_LV1_ETHER_SPEED_100:\r\nethtool_cmd_speed_set(cmd, SPEED_100);\r\nbreak;\r\ncase GELIC_LV1_ETHER_SPEED_1000:\r\nethtool_cmd_speed_set(cmd, SPEED_1000);\r\nbreak;\r\ndefault:\r\npr_info("%s: speed unknown\n", __func__);\r\nethtool_cmd_speed_set(cmd, SPEED_10);\r\nbreak;\r\n}\r\ncmd->supported = SUPPORTED_TP | SUPPORTED_Autoneg |\r\nSUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |\r\nSUPPORTED_1000baseT_Full;\r\ncmd->advertising = cmd->supported;\r\nif (card->link_mode & GELIC_LV1_ETHER_AUTO_NEG) {\r\ncmd->autoneg = AUTONEG_ENABLE;\r\n} else {\r\ncmd->autoneg = AUTONEG_DISABLE;\r\ncmd->advertising &= ~ADVERTISED_Autoneg;\r\n}\r\ncmd->port = PORT_TP;\r\nreturn 0;\r\n}\r\nstatic int gelic_ether_set_settings(struct net_device *netdev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct gelic_card *card = netdev_card(netdev);\r\nu64 mode;\r\nint ret;\r\nif (cmd->autoneg == AUTONEG_ENABLE) {\r\nmode = GELIC_LV1_ETHER_AUTO_NEG;\r\n} else {\r\nswitch (cmd->speed) {\r\ncase SPEED_10:\r\nmode = GELIC_LV1_ETHER_SPEED_10;\r\nbreak;\r\ncase SPEED_100:\r\nmode = GELIC_LV1_ETHER_SPEED_100;\r\nbreak;\r\ncase SPEED_1000:\r\nmode = GELIC_LV1_ETHER_SPEED_1000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (cmd->duplex == DUPLEX_FULL)\r\nmode |= GELIC_LV1_ETHER_FULL_DUPLEX;\r\nelse if (cmd->speed == SPEED_1000) {\r\npr_info("1000 half duplex is not supported.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nret = gelic_card_set_link_mode(card, mode);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void gelic_net_get_wol(struct net_device *netdev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nif (0 <= ps3_compare_firmware_version(2, 2, 0))\r\nwol->supported = WAKE_MAGIC;\r\nelse\r\nwol->supported = 0;\r\nwol->wolopts = ps3_sys_manager_get_wol() ? wol->supported : 0;\r\nmemset(&wol->sopass, 0, sizeof(wol->sopass));\r\n}\r\nstatic int gelic_net_set_wol(struct net_device *netdev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nint status;\r\nstruct gelic_card *card;\r\nu64 v1, v2;\r\nif (ps3_compare_firmware_version(2, 2, 0) < 0 ||\r\n!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (wol->wolopts & ~WAKE_MAGIC)\r\nreturn -EINVAL;\r\ncard = netdev_card(netdev);\r\nif (wol->wolopts & WAKE_MAGIC) {\r\nstatus = lv1_net_control(bus_id(card), dev_id(card),\r\nGELIC_LV1_SET_WOL,\r\nGELIC_LV1_WOL_MAGIC_PACKET,\r\n0, GELIC_LV1_WOL_MP_ENABLE,\r\n&v1, &v2);\r\nif (status) {\r\npr_info("%s: enabling WOL failed %d\n", __func__,\r\nstatus);\r\nstatus = -EIO;\r\ngoto done;\r\n}\r\nstatus = lv1_net_control(bus_id(card), dev_id(card),\r\nGELIC_LV1_SET_WOL,\r\nGELIC_LV1_WOL_ADD_MATCH_ADDR,\r\n0, GELIC_LV1_WOL_MATCH_ALL,\r\n&v1, &v2);\r\nif (!status)\r\nps3_sys_manager_set_wol(1);\r\nelse {\r\npr_info("%s: enabling WOL filter failed %d\n",\r\n__func__, status);\r\nstatus = -EIO;\r\n}\r\n} else {\r\nstatus = lv1_net_control(bus_id(card), dev_id(card),\r\nGELIC_LV1_SET_WOL,\r\nGELIC_LV1_WOL_MAGIC_PACKET,\r\n0, GELIC_LV1_WOL_MP_DISABLE,\r\n&v1, &v2);\r\nif (status) {\r\npr_info("%s: disabling WOL failed %d\n", __func__,\r\nstatus);\r\nstatus = -EIO;\r\ngoto done;\r\n}\r\nstatus = lv1_net_control(bus_id(card), dev_id(card),\r\nGELIC_LV1_SET_WOL,\r\nGELIC_LV1_WOL_DELETE_MATCH_ADDR,\r\n0, GELIC_LV1_WOL_MATCH_ALL,\r\n&v1, &v2);\r\nif (!status)\r\nps3_sys_manager_set_wol(0);\r\nelse {\r\npr_info("%s: removing WOL filter failed %d\n",\r\n__func__, status);\r\nstatus = -EIO;\r\n}\r\n}\r\ndone:\r\nreturn status;\r\n}\r\nstatic void gelic_net_tx_timeout_task(struct work_struct *work)\r\n{\r\nstruct gelic_card *card =\r\ncontainer_of(work, struct gelic_card, tx_timeout_task);\r\nstruct net_device *netdev = card->netdev[GELIC_PORT_ETHERNET_0];\r\ndev_info(ctodev(card), "%s:Timed out. Restarting...\n", __func__);\r\nif (!(netdev->flags & IFF_UP))\r\ngoto out;\r\nnetif_device_detach(netdev);\r\ngelic_net_stop(netdev);\r\ngelic_net_open(netdev);\r\nnetif_device_attach(netdev);\r\nout:\r\natomic_dec(&card->tx_timeout_task_counter);\r\n}\r\nvoid gelic_net_tx_timeout(struct net_device *netdev)\r\n{\r\nstruct gelic_card *card;\r\ncard = netdev_card(netdev);\r\natomic_inc(&card->tx_timeout_task_counter);\r\nif (netdev->flags & IFF_UP)\r\nschedule_work(&card->tx_timeout_task);\r\nelse\r\natomic_dec(&card->tx_timeout_task_counter);\r\n}\r\nstatic void __devinit gelic_ether_setup_netdev_ops(struct net_device *netdev,\r\nstruct napi_struct *napi)\r\n{\r\nnetdev->watchdog_timeo = GELIC_NET_WATCHDOG_TIMEOUT;\r\nnetif_napi_add(netdev, napi,\r\ngelic_net_poll, GELIC_NET_NAPI_WEIGHT);\r\nnetdev->ethtool_ops = &gelic_ether_ethtool_ops;\r\nnetdev->netdev_ops = &gelic_netdevice_ops;\r\n}\r\nint __devinit gelic_net_setup_netdev(struct net_device *netdev,\r\nstruct gelic_card *card)\r\n{\r\nint status;\r\nu64 v1, v2;\r\nnetdev->hw_features = NETIF_F_IP_CSUM | NETIF_F_RXCSUM;\r\nnetdev->features = NETIF_F_IP_CSUM;\r\nif (GELIC_CARD_RX_CSUM_DEFAULT)\r\nnetdev->features |= NETIF_F_RXCSUM;\r\nstatus = lv1_net_control(bus_id(card), dev_id(card),\r\nGELIC_LV1_GET_MAC_ADDRESS,\r\n0, 0, 0, &v1, &v2);\r\nv1 <<= 16;\r\nif (status || !is_valid_ether_addr((u8 *)&v1)) {\r\ndev_info(ctodev(card),\r\n"%s:lv1_net_control GET_MAC_ADDR failed %d\n",\r\n__func__, status);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(netdev->dev_addr, &v1, ETH_ALEN);\r\nif (card->vlan_required) {\r\nnetdev->hard_header_len += VLAN_HLEN;\r\nnetdev->features |= NETIF_F_VLAN_CHALLENGED;\r\n}\r\nstatus = register_netdev(netdev);\r\nif (status) {\r\ndev_err(ctodev(card), "%s:Couldn't register %s %d\n",\r\n__func__, netdev->name, status);\r\nreturn status;\r\n}\r\ndev_info(ctodev(card), "%s: MAC addr %pM\n",\r\nnetdev->name, netdev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic struct gelic_card * __devinit gelic_alloc_card_net(struct net_device **netdev)\r\n{\r\nstruct gelic_card *card;\r\nstruct gelic_port *port;\r\nvoid *p;\r\nsize_t alloc_size;\r\nBUILD_BUG_ON(offsetof(struct gelic_card, irq_status) % 8);\r\nBUILD_BUG_ON(offsetof(struct gelic_card, descr) % 32);\r\nalloc_size =\r\nsizeof(struct gelic_card) +\r\nsizeof(struct gelic_descr) * GELIC_NET_RX_DESCRIPTORS +\r\nsizeof(struct gelic_descr) * GELIC_NET_TX_DESCRIPTORS +\r\nGELIC_ALIGN - 1;\r\np = kzalloc(alloc_size, GFP_KERNEL);\r\nif (!p)\r\nreturn NULL;\r\ncard = PTR_ALIGN(p, GELIC_ALIGN);\r\ncard->unalign = p;\r\n*netdev = alloc_etherdev(sizeof(struct gelic_port));\r\nif (!netdev) {\r\nkfree(card->unalign);\r\nreturn NULL;\r\n}\r\nport = netdev_priv(*netdev);\r\nport->netdev = *netdev;\r\nport->card = card;\r\nport->type = GELIC_PORT_ETHERNET_0;\r\ncard->netdev[GELIC_PORT_ETHERNET_0] = *netdev;\r\nINIT_WORK(&card->tx_timeout_task, gelic_net_tx_timeout_task);\r\ninit_waitqueue_head(&card->waitq);\r\natomic_set(&card->tx_timeout_task_counter, 0);\r\nmutex_init(&card->updown_lock);\r\natomic_set(&card->users, 0);\r\nreturn card;\r\n}\r\nstatic void __devinit gelic_card_get_vlan_info(struct gelic_card *card)\r\n{\r\nu64 v1, v2;\r\nint status;\r\nunsigned int i;\r\nstruct {\r\nint tx;\r\nint rx;\r\n} vlan_id_ix[2] = {\r\n[GELIC_PORT_ETHERNET_0] = {\r\n.tx = GELIC_LV1_VLAN_TX_ETHERNET_0,\r\n.rx = GELIC_LV1_VLAN_RX_ETHERNET_0\r\n},\r\n[GELIC_PORT_WIRELESS] = {\r\n.tx = GELIC_LV1_VLAN_TX_WIRELESS,\r\n.rx = GELIC_LV1_VLAN_RX_WIRELESS\r\n}\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(vlan_id_ix); i++) {\r\nstatus = lv1_net_control(bus_id(card), dev_id(card),\r\nGELIC_LV1_GET_VLAN_ID,\r\nvlan_id_ix[i].tx,\r\n0, 0, &v1, &v2);\r\nif (status || !v1) {\r\nif (status != LV1_NO_ENTRY)\r\ndev_dbg(ctodev(card),\r\n"get vlan id for tx(%d) failed(%d)\n",\r\nvlan_id_ix[i].tx, status);\r\ncard->vlan[i].tx = 0;\r\ncard->vlan[i].rx = 0;\r\ncontinue;\r\n}\r\ncard->vlan[i].tx = (u16)v1;\r\nstatus = lv1_net_control(bus_id(card), dev_id(card),\r\nGELIC_LV1_GET_VLAN_ID,\r\nvlan_id_ix[i].rx,\r\n0, 0, &v1, &v2);\r\nif (status || !v1) {\r\nif (status != LV1_NO_ENTRY)\r\ndev_info(ctodev(card),\r\n"get vlan id for rx(%d) failed(%d)\n",\r\nvlan_id_ix[i].rx, status);\r\ncard->vlan[i].tx = 0;\r\ncard->vlan[i].rx = 0;\r\ncontinue;\r\n}\r\ncard->vlan[i].rx = (u16)v1;\r\ndev_dbg(ctodev(card), "vlan_id[%d] tx=%02x rx=%02x\n",\r\ni, card->vlan[i].tx, card->vlan[i].rx);\r\n}\r\nif (card->vlan[GELIC_PORT_ETHERNET_0].tx) {\r\nBUG_ON(!card->vlan[GELIC_PORT_WIRELESS].tx);\r\ncard->vlan_required = 1;\r\n} else\r\ncard->vlan_required = 0;\r\nif (ps3_compare_firmware_version(1, 6, 0) < 0) {\r\ncard->vlan[GELIC_PORT_WIRELESS].tx = 0;\r\ncard->vlan[GELIC_PORT_WIRELESS].rx = 0;\r\n}\r\ndev_info(ctodev(card), "internal vlan %s\n",\r\ncard->vlan_required? "enabled" : "disabled");\r\n}\r\nstatic int __devinit ps3_gelic_driver_probe(struct ps3_system_bus_device *dev)\r\n{\r\nstruct gelic_card *card;\r\nstruct net_device *netdev;\r\nint result;\r\npr_debug("%s: called\n", __func__);\r\nudbg_shutdown_ps3gelic();\r\nresult = ps3_open_hv_device(dev);\r\nif (result) {\r\ndev_dbg(&dev->core, "%s:ps3_open_hv_device failed\n",\r\n__func__);\r\ngoto fail_open;\r\n}\r\nresult = ps3_dma_region_create(dev->d_region);\r\nif (result) {\r\ndev_dbg(&dev->core, "%s:ps3_dma_region_create failed(%d)\n",\r\n__func__, result);\r\nBUG_ON("check region type");\r\ngoto fail_dma_region;\r\n}\r\ncard = gelic_alloc_card_net(&netdev);\r\nif (!card) {\r\ndev_info(&dev->core, "%s:gelic_net_alloc_card failed\n",\r\n__func__);\r\nresult = -ENOMEM;\r\ngoto fail_alloc_card;\r\n}\r\nps3_system_bus_set_drvdata(dev, card);\r\ncard->dev = dev;\r\ngelic_card_get_vlan_info(card);\r\ncard->link_mode = GELIC_LV1_ETHER_AUTO_NEG;\r\nresult = lv1_net_set_interrupt_status_indicator(bus_id(card),\r\ndev_id(card),\r\nps3_mm_phys_to_lpar(__pa(&card->irq_status)),\r\n0);\r\nif (result) {\r\ndev_dbg(&dev->core,\r\n"%s:set_interrupt_status_indicator failed: %s\n",\r\n__func__, ps3_result(result));\r\nresult = -EIO;\r\ngoto fail_status_indicator;\r\n}\r\nresult = ps3_sb_event_receive_port_setup(dev, PS3_BINDING_CPU_ANY,\r\n&card->irq);\r\nif (result) {\r\ndev_info(ctodev(card),\r\n"%s:gelic_net_open_device failed (%d)\n",\r\n__func__, result);\r\nresult = -EPERM;\r\ngoto fail_alloc_irq;\r\n}\r\nresult = request_irq(card->irq, gelic_card_interrupt,\r\nIRQF_DISABLED, netdev->name, card);\r\nif (result) {\r\ndev_info(ctodev(card), "%s:request_irq failed (%d)\n",\r\n__func__, result);\r\ngoto fail_request_irq;\r\n}\r\ncard->irq_mask = GELIC_CARD_RXINT | GELIC_CARD_TXINT |\r\nGELIC_CARD_PORT_STATUS_CHANGED;\r\nif (gelic_card_init_chain(card, &card->tx_chain,\r\ncard->descr, GELIC_NET_TX_DESCRIPTORS))\r\ngoto fail_alloc_tx;\r\nif (gelic_card_init_chain(card, &card->rx_chain,\r\ncard->descr + GELIC_NET_TX_DESCRIPTORS,\r\nGELIC_NET_RX_DESCRIPTORS))\r\ngoto fail_alloc_rx;\r\ncard->tx_top = card->tx_chain.head;\r\ncard->rx_top = card->rx_chain.head;\r\ndev_dbg(ctodev(card), "descr rx %p, tx %p, size %#lx, num %#x\n",\r\ncard->rx_top, card->tx_top, sizeof(struct gelic_descr),\r\nGELIC_NET_RX_DESCRIPTORS);\r\nif (gelic_card_alloc_rx_skbs(card))\r\ngoto fail_alloc_skbs;\r\nspin_lock_init(&card->tx_lock);\r\ncard->tx_dma_progress = 0;\r\nnetdev->irq = card->irq;\r\nSET_NETDEV_DEV(netdev, &card->dev->core);\r\ngelic_ether_setup_netdev_ops(netdev, &card->napi);\r\nresult = gelic_net_setup_netdev(netdev, card);\r\nif (result) {\r\ndev_dbg(&dev->core, "%s: setup_netdev failed %d",\r\n__func__, result);\r\ngoto fail_setup_netdev;\r\n}\r\n#ifdef CONFIG_GELIC_WIRELESS\r\nif (gelic_wl_driver_probe(card)) {\r\ndev_dbg(&dev->core, "%s: WL init failed\n", __func__);\r\ngoto fail_setup_netdev;\r\n}\r\n#endif\r\npr_debug("%s: done\n", __func__);\r\nreturn 0;\r\nfail_setup_netdev:\r\nfail_alloc_skbs:\r\ngelic_card_free_chain(card, card->rx_chain.head);\r\nfail_alloc_rx:\r\ngelic_card_free_chain(card, card->tx_chain.head);\r\nfail_alloc_tx:\r\nfree_irq(card->irq, card);\r\nnetdev->irq = NO_IRQ;\r\nfail_request_irq:\r\nps3_sb_event_receive_port_destroy(dev, card->irq);\r\nfail_alloc_irq:\r\nlv1_net_set_interrupt_status_indicator(bus_id(card),\r\nbus_id(card),\r\n0, 0);\r\nfail_status_indicator:\r\nps3_system_bus_set_drvdata(dev, NULL);\r\nkfree(netdev_card(netdev)->unalign);\r\nfree_netdev(netdev);\r\nfail_alloc_card:\r\nps3_dma_region_free(dev->d_region);\r\nfail_dma_region:\r\nps3_close_hv_device(dev);\r\nfail_open:\r\nreturn result;\r\n}\r\nstatic int ps3_gelic_driver_remove(struct ps3_system_bus_device *dev)\r\n{\r\nstruct gelic_card *card = ps3_system_bus_get_drvdata(dev);\r\nstruct net_device *netdev0;\r\npr_debug("%s: called\n", __func__);\r\ngelic_card_set_link_mode(card, GELIC_LV1_ETHER_AUTO_NEG);\r\n#ifdef CONFIG_GELIC_WIRELESS\r\ngelic_wl_driver_remove(card);\r\n#endif\r\ngelic_card_set_irq_mask(card, 0);\r\ngelic_card_disable_rxdmac(card);\r\ngelic_card_disable_txdmac(card);\r\ngelic_card_release_tx_chain(card, 1);\r\ngelic_card_release_rx_chain(card);\r\ngelic_card_free_chain(card, card->tx_top);\r\ngelic_card_free_chain(card, card->rx_top);\r\nnetdev0 = card->netdev[GELIC_PORT_ETHERNET_0];\r\nfree_irq(card->irq, card);\r\nnetdev0->irq = NO_IRQ;\r\nps3_sb_event_receive_port_destroy(card->dev, card->irq);\r\nwait_event(card->waitq,\r\natomic_read(&card->tx_timeout_task_counter) == 0);\r\nlv1_net_set_interrupt_status_indicator(bus_id(card), dev_id(card),\r\n0 , 0);\r\nunregister_netdev(netdev0);\r\nkfree(netdev_card(netdev0)->unalign);\r\nfree_netdev(netdev0);\r\nps3_system_bus_set_drvdata(dev, NULL);\r\nps3_dma_region_free(dev->d_region);\r\nps3_close_hv_device(dev);\r\npr_debug("%s: done\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int __init ps3_gelic_driver_init (void)\r\n{\r\nreturn firmware_has_feature(FW_FEATURE_PS3_LV1)\r\n? ps3_system_bus_driver_register(&ps3_gelic_driver)\r\n: -ENODEV;\r\n}\r\nstatic void __exit ps3_gelic_driver_exit (void)\r\n{\r\nps3_system_bus_driver_unregister(&ps3_gelic_driver);\r\n}
