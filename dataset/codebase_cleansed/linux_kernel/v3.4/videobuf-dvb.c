static int videobuf_dvb_thread(void *data)\r\n{\r\nstruct videobuf_dvb *dvb = data;\r\nstruct videobuf_buffer *buf;\r\nunsigned long flags;\r\nint err;\r\nvoid *outp;\r\ndprintk("dvb thread started\n");\r\nset_freezable();\r\nvideobuf_read_start(&dvb->dvbq);\r\nfor (;;) {\r\nbuf = list_entry(dvb->dvbq.stream.next,\r\nstruct videobuf_buffer, stream);\r\nlist_del(&buf->stream);\r\nerr = videobuf_waiton(&dvb->dvbq, buf, 0, 1);\r\nif (0 == dvb->nfeeds)\r\nbreak;\r\nif (kthread_should_stop())\r\nbreak;\r\ntry_to_freeze();\r\noutp = videobuf_queue_to_vaddr(&dvb->dvbq, buf);\r\nif (buf->state == VIDEOBUF_DONE)\r\ndvb_dmx_swfilter(&dvb->demux, outp,\r\nbuf->size);\r\nlist_add_tail(&buf->stream,&dvb->dvbq.stream);\r\nspin_lock_irqsave(dvb->dvbq.irqlock,flags);\r\ndvb->dvbq.ops->buf_queue(&dvb->dvbq,buf);\r\nspin_unlock_irqrestore(dvb->dvbq.irqlock,flags);\r\n}\r\nvideobuf_read_stop(&dvb->dvbq);\r\ndprintk("dvb thread stopped\n");\r\nwhile (!kthread_should_stop()) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule();\r\n}\r\nreturn 0;\r\n}\r\nstatic int videobuf_dvb_start_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct videobuf_dvb *dvb = demux->priv;\r\nint rc;\r\nif (!demux->dmx.frontend)\r\nreturn -EINVAL;\r\nmutex_lock(&dvb->lock);\r\ndvb->nfeeds++;\r\nrc = dvb->nfeeds;\r\nif (NULL != dvb->thread)\r\ngoto out;\r\ndvb->thread = kthread_run(videobuf_dvb_thread,\r\ndvb, "%s dvb", dvb->name);\r\nif (IS_ERR(dvb->thread)) {\r\nrc = PTR_ERR(dvb->thread);\r\ndvb->thread = NULL;\r\n}\r\nout:\r\nmutex_unlock(&dvb->lock);\r\nreturn rc;\r\n}\r\nstatic int videobuf_dvb_stop_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct videobuf_dvb *dvb = demux->priv;\r\nint err = 0;\r\nmutex_lock(&dvb->lock);\r\ndvb->nfeeds--;\r\nif (0 == dvb->nfeeds && NULL != dvb->thread) {\r\nerr = kthread_stop(dvb->thread);\r\ndvb->thread = NULL;\r\n}\r\nmutex_unlock(&dvb->lock);\r\nreturn err;\r\n}\r\nstatic int videobuf_dvb_register_adapter(struct videobuf_dvb_frontends *fe,\r\nstruct module *module,\r\nvoid *adapter_priv,\r\nstruct device *device,\r\nchar *adapter_name,\r\nshort *adapter_nr,\r\nint mfe_shared,\r\nint (*fe_ioctl_override)(struct dvb_frontend *,\r\nunsigned int, void *, unsigned int))\r\n{\r\nint result;\r\nmutex_init(&fe->lock);\r\nresult = dvb_register_adapter(&fe->adapter, adapter_name, module,\r\ndevice, adapter_nr);\r\nif (result < 0) {\r\nprintk(KERN_WARNING "%s: dvb_register_adapter failed (errno = %d)\n",\r\nadapter_name, result);\r\n}\r\nfe->adapter.priv = adapter_priv;\r\nfe->adapter.mfe_shared = mfe_shared;\r\nfe->adapter.fe_ioctl_override = fe_ioctl_override;\r\nreturn result;\r\n}\r\nstatic int videobuf_dvb_register_frontend(struct dvb_adapter *adapter,\r\nstruct videobuf_dvb *dvb)\r\n{\r\nint result;\r\nresult = dvb_register_frontend(adapter, dvb->frontend);\r\nif (result < 0) {\r\nprintk(KERN_WARNING "%s: dvb_register_frontend failed (errno = %d)\n",\r\ndvb->name, result);\r\ngoto fail_frontend;\r\n}\r\ndvb->demux.dmx.capabilities =\r\nDMX_TS_FILTERING | DMX_SECTION_FILTERING |\r\nDMX_MEMORY_BASED_FILTERING;\r\ndvb->demux.priv = dvb;\r\ndvb->demux.filternum = 256;\r\ndvb->demux.feednum = 256;\r\ndvb->demux.start_feed = videobuf_dvb_start_feed;\r\ndvb->demux.stop_feed = videobuf_dvb_stop_feed;\r\nresult = dvb_dmx_init(&dvb->demux);\r\nif (result < 0) {\r\nprintk(KERN_WARNING "%s: dvb_dmx_init failed (errno = %d)\n",\r\ndvb->name, result);\r\ngoto fail_dmx;\r\n}\r\ndvb->dmxdev.filternum = 256;\r\ndvb->dmxdev.demux = &dvb->demux.dmx;\r\ndvb->dmxdev.capabilities = 0;\r\nresult = dvb_dmxdev_init(&dvb->dmxdev, adapter);\r\nif (result < 0) {\r\nprintk(KERN_WARNING "%s: dvb_dmxdev_init failed (errno = %d)\n",\r\ndvb->name, result);\r\ngoto fail_dmxdev;\r\n}\r\ndvb->fe_hw.source = DMX_FRONTEND_0;\r\nresult = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_hw);\r\nif (result < 0) {\r\nprintk(KERN_WARNING "%s: add_frontend failed (DMX_FRONTEND_0, errno = %d)\n",\r\ndvb->name, result);\r\ngoto fail_fe_hw;\r\n}\r\ndvb->fe_mem.source = DMX_MEMORY_FE;\r\nresult = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_mem);\r\nif (result < 0) {\r\nprintk(KERN_WARNING "%s: add_frontend failed (DMX_MEMORY_FE, errno = %d)\n",\r\ndvb->name, result);\r\ngoto fail_fe_mem;\r\n}\r\nresult = dvb->demux.dmx.connect_frontend(&dvb->demux.dmx, &dvb->fe_hw);\r\nif (result < 0) {\r\nprintk(KERN_WARNING "%s: connect_frontend failed (errno = %d)\n",\r\ndvb->name, result);\r\ngoto fail_fe_conn;\r\n}\r\nresult = dvb_net_init(adapter, &dvb->net, &dvb->demux.dmx);\r\nif (result < 0) {\r\nprintk(KERN_WARNING "%s: dvb_net_init failed (errno = %d)\n",\r\ndvb->name, result);\r\ngoto fail_fe_conn;\r\n}\r\nreturn 0;\r\nfail_fe_conn:\r\ndvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_mem);\r\nfail_fe_mem:\r\ndvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_hw);\r\nfail_fe_hw:\r\ndvb_dmxdev_release(&dvb->dmxdev);\r\nfail_dmxdev:\r\ndvb_dmx_release(&dvb->demux);\r\nfail_dmx:\r\ndvb_unregister_frontend(dvb->frontend);\r\nfail_frontend:\r\ndvb_frontend_detach(dvb->frontend);\r\ndvb->frontend = NULL;\r\nreturn result;\r\n}\r\nint videobuf_dvb_register_bus(struct videobuf_dvb_frontends *f,\r\nstruct module *module,\r\nvoid *adapter_priv,\r\nstruct device *device,\r\nshort *adapter_nr,\r\nint mfe_shared,\r\nint (*fe_ioctl_override)(struct dvb_frontend *,\r\nunsigned int, void *, unsigned int))\r\n{\r\nstruct list_head *list, *q;\r\nstruct videobuf_dvb_frontend *fe;\r\nint res;\r\nfe = videobuf_dvb_get_frontend(f, 1);\r\nif (!fe) {\r\nprintk(KERN_WARNING "Unable to register the adapter which has no frontends\n");\r\nreturn -EINVAL;\r\n}\r\nres = videobuf_dvb_register_adapter(f, module, adapter_priv, device,\r\nfe->dvb.name, adapter_nr, mfe_shared, fe_ioctl_override);\r\nif (res < 0) {\r\nprintk(KERN_WARNING "videobuf_dvb_register_adapter failed (errno = %d)\n", res);\r\nreturn res;\r\n}\r\nmutex_lock(&f->lock);\r\nlist_for_each_safe(list, q, &f->felist) {\r\nfe = list_entry(list, struct videobuf_dvb_frontend, felist);\r\nres = videobuf_dvb_register_frontend(&f->adapter, &fe->dvb);\r\nif (res < 0) {\r\nprintk(KERN_WARNING "%s: videobuf_dvb_register_frontend failed (errno = %d)\n",\r\nfe->dvb.name, res);\r\ngoto err;\r\n}\r\n}\r\nmutex_unlock(&f->lock);\r\nreturn 0;\r\nerr:\r\nmutex_unlock(&f->lock);\r\nvideobuf_dvb_unregister_bus(f);\r\nreturn res;\r\n}\r\nvoid videobuf_dvb_unregister_bus(struct videobuf_dvb_frontends *f)\r\n{\r\nvideobuf_dvb_dealloc_frontends(f);\r\ndvb_unregister_adapter(&f->adapter);\r\n}\r\nstruct videobuf_dvb_frontend *videobuf_dvb_get_frontend(\r\nstruct videobuf_dvb_frontends *f, int id)\r\n{\r\nstruct list_head *list, *q;\r\nstruct videobuf_dvb_frontend *fe, *ret = NULL;\r\nmutex_lock(&f->lock);\r\nlist_for_each_safe(list, q, &f->felist) {\r\nfe = list_entry(list, struct videobuf_dvb_frontend, felist);\r\nif (fe->id == id) {\r\nret = fe;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&f->lock);\r\nreturn ret;\r\n}\r\nint videobuf_dvb_find_frontend(struct videobuf_dvb_frontends *f,\r\nstruct dvb_frontend *p)\r\n{\r\nstruct list_head *list, *q;\r\nstruct videobuf_dvb_frontend *fe = NULL;\r\nint ret = 0;\r\nmutex_lock(&f->lock);\r\nlist_for_each_safe(list, q, &f->felist) {\r\nfe = list_entry(list, struct videobuf_dvb_frontend, felist);\r\nif (fe->dvb.frontend == p) {\r\nret = fe->id;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&f->lock);\r\nreturn ret;\r\n}\r\nstruct videobuf_dvb_frontend *videobuf_dvb_alloc_frontend(\r\nstruct videobuf_dvb_frontends *f, int id)\r\n{\r\nstruct videobuf_dvb_frontend *fe;\r\nfe = kzalloc(sizeof(struct videobuf_dvb_frontend), GFP_KERNEL);\r\nif (fe == NULL)\r\ngoto fail_alloc;\r\nfe->id = id;\r\nmutex_init(&fe->dvb.lock);\r\nmutex_lock(&f->lock);\r\nlist_add_tail(&fe->felist, &f->felist);\r\nmutex_unlock(&f->lock);\r\nfail_alloc:\r\nreturn fe;\r\n}\r\nvoid videobuf_dvb_dealloc_frontends(struct videobuf_dvb_frontends *f)\r\n{\r\nstruct list_head *list, *q;\r\nstruct videobuf_dvb_frontend *fe;\r\nmutex_lock(&f->lock);\r\nlist_for_each_safe(list, q, &f->felist) {\r\nfe = list_entry(list, struct videobuf_dvb_frontend, felist);\r\nif (fe->dvb.net.dvbdev) {\r\ndvb_net_release(&fe->dvb.net);\r\nfe->dvb.demux.dmx.remove_frontend(&fe->dvb.demux.dmx,\r\n&fe->dvb.fe_mem);\r\nfe->dvb.demux.dmx.remove_frontend(&fe->dvb.demux.dmx,\r\n&fe->dvb.fe_hw);\r\ndvb_dmxdev_release(&fe->dvb.dmxdev);\r\ndvb_dmx_release(&fe->dvb.demux);\r\ndvb_unregister_frontend(fe->dvb.frontend);\r\n}\r\nif (fe->dvb.frontend)\r\ndvb_frontend_detach(fe->dvb.frontend);\r\nlist_del(list);\r\nkfree(fe);\r\n}\r\nmutex_unlock(&f->lock);\r\n}
