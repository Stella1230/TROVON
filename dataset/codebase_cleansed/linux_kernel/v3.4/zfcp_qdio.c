static int zfcp_qdio_buffers_enqueue(struct qdio_buffer **sbal)\r\n{\r\nint pos;\r\nfor (pos = 0; pos < QDIO_MAX_BUFFERS_PER_Q; pos += QBUFF_PER_PAGE) {\r\nsbal[pos] = (struct qdio_buffer *) get_zeroed_page(GFP_KERNEL);\r\nif (!sbal[pos])\r\nreturn -ENOMEM;\r\n}\r\nfor (pos = 0; pos < QDIO_MAX_BUFFERS_PER_Q; pos++)\r\nif (pos % QBUFF_PER_PAGE)\r\nsbal[pos] = sbal[pos - 1] + 1;\r\nreturn 0;\r\n}\r\nstatic void zfcp_qdio_handler_error(struct zfcp_qdio *qdio, char *id,\r\nunsigned int qdio_err)\r\n{\r\nstruct zfcp_adapter *adapter = qdio->adapter;\r\ndev_warn(&adapter->ccw_device->dev, "A QDIO problem occurred\n");\r\nif (qdio_err & QDIO_ERROR_SLSB_STATE) {\r\nzfcp_qdio_siosl(adapter);\r\nzfcp_erp_adapter_shutdown(adapter, 0, id);\r\nreturn;\r\n}\r\nzfcp_erp_adapter_reopen(adapter,\r\nZFCP_STATUS_ADAPTER_LINK_UNPLUGGED |\r\nZFCP_STATUS_COMMON_ERP_FAILED, id);\r\n}\r\nstatic void zfcp_qdio_zero_sbals(struct qdio_buffer *sbal[], int first, int cnt)\r\n{\r\nint i, sbal_idx;\r\nfor (i = first; i < first + cnt; i++) {\r\nsbal_idx = i % QDIO_MAX_BUFFERS_PER_Q;\r\nmemset(sbal[sbal_idx], 0, sizeof(struct qdio_buffer));\r\n}\r\n}\r\nstatic inline void zfcp_qdio_account(struct zfcp_qdio *qdio)\r\n{\r\nunsigned long long now, span;\r\nint used;\r\nnow = get_clock_monotonic();\r\nspan = (now - qdio->req_q_time) >> 12;\r\nused = QDIO_MAX_BUFFERS_PER_Q - atomic_read(&qdio->req_q_free);\r\nqdio->req_q_util += used * span;\r\nqdio->req_q_time = now;\r\n}\r\nstatic void zfcp_qdio_int_req(struct ccw_device *cdev, unsigned int qdio_err,\r\nint queue_no, int idx, int count,\r\nunsigned long parm)\r\n{\r\nstruct zfcp_qdio *qdio = (struct zfcp_qdio *) parm;\r\nif (unlikely(qdio_err)) {\r\nzfcp_qdio_handler_error(qdio, "qdireq1", qdio_err);\r\nreturn;\r\n}\r\nzfcp_qdio_zero_sbals(qdio->req_q, idx, count);\r\nspin_lock_irq(&qdio->stat_lock);\r\nzfcp_qdio_account(qdio);\r\nspin_unlock_irq(&qdio->stat_lock);\r\natomic_add(count, &qdio->req_q_free);\r\nwake_up(&qdio->req_q_wq);\r\n}\r\nstatic void zfcp_qdio_int_resp(struct ccw_device *cdev, unsigned int qdio_err,\r\nint queue_no, int idx, int count,\r\nunsigned long parm)\r\n{\r\nstruct zfcp_qdio *qdio = (struct zfcp_qdio *) parm;\r\nstruct zfcp_adapter *adapter = qdio->adapter;\r\nstruct qdio_buffer_element *sbale;\r\nint sbal_no, sbal_idx;\r\nvoid *pl[ZFCP_QDIO_MAX_SBALS_PER_REQ + 1];\r\nu64 req_id;\r\nu8 scount;\r\nif (unlikely(qdio_err)) {\r\nmemset(pl, 0, ZFCP_QDIO_MAX_SBALS_PER_REQ * sizeof(void *));\r\nif (zfcp_adapter_multi_buffer_active(adapter)) {\r\nsbale = qdio->res_q[idx]->element;\r\nreq_id = (u64) sbale->addr;\r\nscount = sbale->scount + 1;\r\nfor (sbal_no = 0; sbal_no < scount; sbal_no++) {\r\nsbal_idx = (idx + sbal_no) %\r\nQDIO_MAX_BUFFERS_PER_Q;\r\npl[sbal_no] = qdio->res_q[sbal_idx];\r\n}\r\nzfcp_dbf_hba_def_err(adapter, req_id, scount, pl);\r\n}\r\nzfcp_qdio_handler_error(qdio, "qdires1", qdio_err);\r\nreturn;\r\n}\r\nfor (sbal_no = 0; sbal_no < count; sbal_no++) {\r\nsbal_idx = (idx + sbal_no) % QDIO_MAX_BUFFERS_PER_Q;\r\nzfcp_fsf_reqid_check(qdio, sbal_idx);\r\n}\r\nif (do_QDIO(cdev, QDIO_FLAG_SYNC_INPUT, 0, idx, count))\r\nzfcp_erp_adapter_reopen(qdio->adapter, 0, "qdires2");\r\n}\r\nstatic struct qdio_buffer_element *\r\nzfcp_qdio_sbal_chain(struct zfcp_qdio *qdio, struct zfcp_qdio_req *q_req)\r\n{\r\nstruct qdio_buffer_element *sbale;\r\nsbale = zfcp_qdio_sbale_curr(qdio, q_req);\r\nsbale->eflags |= SBAL_EFLAGS_LAST_ENTRY;\r\nif (q_req->sbal_last == q_req->sbal_limit)\r\nreturn NULL;\r\nsbale = zfcp_qdio_sbale_req(qdio, q_req);\r\nsbale->sflags |= SBAL_SFLAGS0_MORE_SBALS;\r\nq_req->sbal_last++;\r\nq_req->sbal_last %= QDIO_MAX_BUFFERS_PER_Q;\r\nq_req->sbal_number++;\r\nBUG_ON(q_req->sbal_number > ZFCP_QDIO_MAX_SBALS_PER_REQ);\r\nq_req->sbale_curr = 0;\r\nsbale = zfcp_qdio_sbale_curr(qdio, q_req);\r\nsbale->sflags |= q_req->sbtype;\r\nreturn sbale;\r\n}\r\nstatic struct qdio_buffer_element *\r\nzfcp_qdio_sbale_next(struct zfcp_qdio *qdio, struct zfcp_qdio_req *q_req)\r\n{\r\nif (q_req->sbale_curr == qdio->max_sbale_per_sbal - 1)\r\nreturn zfcp_qdio_sbal_chain(qdio, q_req);\r\nq_req->sbale_curr++;\r\nreturn zfcp_qdio_sbale_curr(qdio, q_req);\r\n}\r\nint zfcp_qdio_sbals_from_sg(struct zfcp_qdio *qdio, struct zfcp_qdio_req *q_req,\r\nstruct scatterlist *sg)\r\n{\r\nstruct qdio_buffer_element *sbale;\r\nsbale = zfcp_qdio_sbale_req(qdio, q_req);\r\nsbale->sflags |= q_req->sbtype;\r\nfor (; sg; sg = sg_next(sg)) {\r\nsbale = zfcp_qdio_sbale_next(qdio, q_req);\r\nif (!sbale) {\r\natomic_inc(&qdio->req_q_full);\r\nzfcp_qdio_zero_sbals(qdio->req_q, q_req->sbal_first,\r\nq_req->sbal_number);\r\nreturn -EINVAL;\r\n}\r\nsbale->addr = sg_virt(sg);\r\nsbale->length = sg->length;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zfcp_qdio_sbal_check(struct zfcp_qdio *qdio)\r\n{\r\nspin_lock_irq(&qdio->req_q_lock);\r\nif (atomic_read(&qdio->req_q_free) ||\r\n!(atomic_read(&qdio->adapter->status) & ZFCP_STATUS_ADAPTER_QDIOUP))\r\nreturn 1;\r\nspin_unlock_irq(&qdio->req_q_lock);\r\nreturn 0;\r\n}\r\nint zfcp_qdio_sbal_get(struct zfcp_qdio *qdio)\r\n{\r\nlong ret;\r\nspin_unlock_irq(&qdio->req_q_lock);\r\nret = wait_event_interruptible_timeout(qdio->req_q_wq,\r\nzfcp_qdio_sbal_check(qdio), 5 * HZ);\r\nif (!(atomic_read(&qdio->adapter->status) & ZFCP_STATUS_ADAPTER_QDIOUP))\r\nreturn -EIO;\r\nif (ret > 0)\r\nreturn 0;\r\nif (!ret) {\r\natomic_inc(&qdio->req_q_full);\r\nzfcp_erp_adapter_reopen(qdio->adapter, 0, "qdsbg_1");\r\n}\r\nspin_lock_irq(&qdio->req_q_lock);\r\nreturn -EIO;\r\n}\r\nint zfcp_qdio_send(struct zfcp_qdio *qdio, struct zfcp_qdio_req *q_req)\r\n{\r\nint retval;\r\nu8 sbal_number = q_req->sbal_number;\r\nspin_lock(&qdio->stat_lock);\r\nzfcp_qdio_account(qdio);\r\nspin_unlock(&qdio->stat_lock);\r\nretval = do_QDIO(qdio->adapter->ccw_device, QDIO_FLAG_SYNC_OUTPUT, 0,\r\nq_req->sbal_first, sbal_number);\r\nif (unlikely(retval)) {\r\nzfcp_qdio_zero_sbals(qdio->req_q, q_req->sbal_first,\r\nsbal_number);\r\nreturn retval;\r\n}\r\natomic_sub(sbal_number, &qdio->req_q_free);\r\nqdio->req_q_idx += sbal_number;\r\nqdio->req_q_idx %= QDIO_MAX_BUFFERS_PER_Q;\r\nreturn 0;\r\n}\r\nstatic void zfcp_qdio_setup_init_data(struct qdio_initialize *id,\r\nstruct zfcp_qdio *qdio)\r\n{\r\nmemset(id, 0, sizeof(*id));\r\nid->cdev = qdio->adapter->ccw_device;\r\nid->q_format = QDIO_ZFCP_QFMT;\r\nmemcpy(id->adapter_name, dev_name(&id->cdev->dev), 8);\r\nASCEBC(id->adapter_name, 8);\r\nid->qib_rflags = QIB_RFLAGS_ENABLE_DATA_DIV;\r\nif (enable_multibuffer)\r\nid->qdr_ac |= QDR_AC_MULTI_BUFFER_ENABLE;\r\nid->no_input_qs = 1;\r\nid->no_output_qs = 1;\r\nid->input_handler = zfcp_qdio_int_resp;\r\nid->output_handler = zfcp_qdio_int_req;\r\nid->int_parm = (unsigned long) qdio;\r\nid->input_sbal_addr_array = (void **) (qdio->res_q);\r\nid->output_sbal_addr_array = (void **) (qdio->req_q);\r\nid->scan_threshold =\r\nQDIO_MAX_BUFFERS_PER_Q - ZFCP_QDIO_MAX_SBALS_PER_REQ * 2;\r\n}\r\nstatic int zfcp_qdio_allocate(struct zfcp_qdio *qdio)\r\n{\r\nstruct qdio_initialize init_data;\r\nif (zfcp_qdio_buffers_enqueue(qdio->req_q) ||\r\nzfcp_qdio_buffers_enqueue(qdio->res_q))\r\nreturn -ENOMEM;\r\nzfcp_qdio_setup_init_data(&init_data, qdio);\r\ninit_waitqueue_head(&qdio->req_q_wq);\r\nreturn qdio_allocate(&init_data);\r\n}\r\nvoid zfcp_qdio_close(struct zfcp_qdio *qdio)\r\n{\r\nstruct zfcp_adapter *adapter = qdio->adapter;\r\nint idx, count;\r\nif (!(atomic_read(&adapter->status) & ZFCP_STATUS_ADAPTER_QDIOUP))\r\nreturn;\r\nspin_lock_irq(&qdio->req_q_lock);\r\natomic_clear_mask(ZFCP_STATUS_ADAPTER_QDIOUP, &adapter->status);\r\nspin_unlock_irq(&qdio->req_q_lock);\r\nwake_up(&qdio->req_q_wq);\r\nqdio_shutdown(adapter->ccw_device, QDIO_FLAG_CLEANUP_USING_CLEAR);\r\ncount = atomic_read(&qdio->req_q_free);\r\nif (count < QDIO_MAX_BUFFERS_PER_Q) {\r\nidx = (qdio->req_q_idx + count) % QDIO_MAX_BUFFERS_PER_Q;\r\ncount = QDIO_MAX_BUFFERS_PER_Q - count;\r\nzfcp_qdio_zero_sbals(qdio->req_q, idx, count);\r\n}\r\nqdio->req_q_idx = 0;\r\natomic_set(&qdio->req_q_free, 0);\r\n}\r\nint zfcp_qdio_open(struct zfcp_qdio *qdio)\r\n{\r\nstruct qdio_buffer_element *sbale;\r\nstruct qdio_initialize init_data;\r\nstruct zfcp_adapter *adapter = qdio->adapter;\r\nstruct ccw_device *cdev = adapter->ccw_device;\r\nstruct qdio_ssqd_desc ssqd;\r\nint cc;\r\nif (atomic_read(&adapter->status) & ZFCP_STATUS_ADAPTER_QDIOUP)\r\nreturn -EIO;\r\natomic_clear_mask(ZFCP_STATUS_ADAPTER_SIOSL_ISSUED,\r\n&qdio->adapter->status);\r\nzfcp_qdio_setup_init_data(&init_data, qdio);\r\nif (qdio_establish(&init_data))\r\ngoto failed_establish;\r\nif (qdio_get_ssqd_desc(init_data.cdev, &ssqd))\r\ngoto failed_qdio;\r\nif (ssqd.qdioac2 & CHSC_AC2_DATA_DIV_ENABLED)\r\natomic_set_mask(ZFCP_STATUS_ADAPTER_DATA_DIV_ENABLED,\r\n&qdio->adapter->status);\r\nif (ssqd.qdioac2 & CHSC_AC2_MULTI_BUFFER_ENABLED) {\r\natomic_set_mask(ZFCP_STATUS_ADAPTER_MB_ACT, &adapter->status);\r\nqdio->max_sbale_per_sbal = QDIO_MAX_ELEMENTS_PER_BUFFER;\r\n} else {\r\natomic_clear_mask(ZFCP_STATUS_ADAPTER_MB_ACT, &adapter->status);\r\nqdio->max_sbale_per_sbal = QDIO_MAX_ELEMENTS_PER_BUFFER - 1;\r\n}\r\nqdio->max_sbale_per_req =\r\nZFCP_QDIO_MAX_SBALS_PER_REQ * qdio->max_sbale_per_sbal\r\n- 2;\r\nif (qdio_activate(cdev))\r\ngoto failed_qdio;\r\nfor (cc = 0; cc < QDIO_MAX_BUFFERS_PER_Q; cc++) {\r\nsbale = &(qdio->res_q[cc]->element[0]);\r\nsbale->length = 0;\r\nsbale->eflags = SBAL_EFLAGS_LAST_ENTRY;\r\nsbale->sflags = 0;\r\nsbale->addr = NULL;\r\n}\r\nif (do_QDIO(cdev, QDIO_FLAG_SYNC_INPUT, 0, 0, QDIO_MAX_BUFFERS_PER_Q))\r\ngoto failed_qdio;\r\nqdio->req_q_idx = 0;\r\natomic_set(&qdio->req_q_free, QDIO_MAX_BUFFERS_PER_Q);\r\natomic_set_mask(ZFCP_STATUS_ADAPTER_QDIOUP, &qdio->adapter->status);\r\nif (adapter->scsi_host) {\r\nadapter->scsi_host->sg_tablesize = qdio->max_sbale_per_req;\r\nadapter->scsi_host->max_sectors = qdio->max_sbale_per_req * 8;\r\n}\r\nreturn 0;\r\nfailed_qdio:\r\nqdio_shutdown(cdev, QDIO_FLAG_CLEANUP_USING_CLEAR);\r\nfailed_establish:\r\ndev_err(&cdev->dev,\r\n"Setting up the QDIO connection to the FCP adapter failed\n");\r\nreturn -EIO;\r\n}\r\nvoid zfcp_qdio_destroy(struct zfcp_qdio *qdio)\r\n{\r\nint p;\r\nif (!qdio)\r\nreturn;\r\nif (qdio->adapter->ccw_device)\r\nqdio_free(qdio->adapter->ccw_device);\r\nfor (p = 0; p < QDIO_MAX_BUFFERS_PER_Q; p += QBUFF_PER_PAGE) {\r\nfree_page((unsigned long) qdio->req_q[p]);\r\nfree_page((unsigned long) qdio->res_q[p]);\r\n}\r\nkfree(qdio);\r\n}\r\nint zfcp_qdio_setup(struct zfcp_adapter *adapter)\r\n{\r\nstruct zfcp_qdio *qdio;\r\nqdio = kzalloc(sizeof(struct zfcp_qdio), GFP_KERNEL);\r\nif (!qdio)\r\nreturn -ENOMEM;\r\nqdio->adapter = adapter;\r\nif (zfcp_qdio_allocate(qdio)) {\r\nzfcp_qdio_destroy(qdio);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&qdio->req_q_lock);\r\nspin_lock_init(&qdio->stat_lock);\r\nadapter->qdio = qdio;\r\nreturn 0;\r\n}\r\nvoid zfcp_qdio_siosl(struct zfcp_adapter *adapter)\r\n{\r\nint rc;\r\nif (atomic_read(&adapter->status) & ZFCP_STATUS_ADAPTER_SIOSL_ISSUED)\r\nreturn;\r\nrc = ccw_device_siosl(adapter->ccw_device);\r\nif (!rc)\r\natomic_set_mask(ZFCP_STATUS_ADAPTER_SIOSL_ISSUED,\r\n&adapter->status);\r\n}
