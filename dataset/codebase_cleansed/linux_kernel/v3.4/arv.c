static void wait_for_vsync(void)\r\n{\r\nwhile (ar_inl(ARVCR0) & ARVCR0_VDS)\r\ncpu_relax();\r\nwhile (!(ar_inl(ARVCR0) & ARVCR0_VDS))\r\ncpu_relax();\r\n}\r\nstatic void wait_acknowledge(void)\r\n{\r\nint i;\r\nfor (i = 0; i < 1000; i++)\r\ncpu_relax();\r\nwhile (ar_inl(PLDI2CSTS) & PLDI2CSTS_NOACK)\r\ncpu_relax();\r\n}\r\nstatic void iic(int n, unsigned long addr, unsigned long data1, unsigned long data2,\r\nunsigned long data3)\r\n{\r\nint i;\r\nar_outl(addr, PLDI2CDATA);\r\nwait_for_vsync();\r\nar_outl(1, PLDI2CCND);\r\nwait_acknowledge();\r\nar_outl(data1, PLDI2CDATA);\r\nwait_for_vsync();\r\nar_outl(PLDI2CSTEN_STEN, PLDI2CSTEN);\r\nwait_acknowledge();\r\nar_outl(data2, PLDI2CDATA);\r\nwait_for_vsync();\r\nar_outl(PLDI2CSTEN_STEN, PLDI2CSTEN);\r\nwait_acknowledge();\r\nif (n == 3) {\r\nar_outl(data3, PLDI2CDATA);\r\nwait_for_vsync();\r\nar_outl(PLDI2CSTEN_STEN, PLDI2CSTEN);\r\nwait_acknowledge();\r\n}\r\nfor (i = 0; i < 100; i++)\r\ncpu_relax();\r\nar_outl(2, PLDI2CCND);\r\nar_outl(2, PLDI2CCND);\r\nwhile (ar_inl(PLDI2CSTS) & PLDI2CSTS_BB)\r\ncpu_relax();\r\n}\r\nstatic void init_iic(void)\r\n{\r\nDEBUG(1, "init_iic:\n");\r\nar_outl(0x0, PLDI2CCR);\r\nar_outl(0x0300, PLDI2CMOD);\r\nar_outl(0x1, PLDI2CACK);\r\nif (freq == 75)\r\nar_outl(369, PLDI2CFREQ);\r\nelse if (freq == 50)\r\nar_outl(244, PLDI2CFREQ);\r\nelse\r\nar_outl(244, PLDI2CFREQ);\r\nar_outl(0x1, PLDI2CCR);\r\n}\r\nstatic inline void disable_dma(void)\r\n{\r\nar_outl(0x8000, M32R_DMAEN_PORTL);\r\n}\r\nstatic inline void enable_dma(void)\r\n{\r\nar_outl(0x8080, M32R_DMAEN_PORTL);\r\n}\r\nstatic inline void clear_dma_status(void)\r\n{\r\nar_outl(0x8000, M32R_DMAEDET_PORTL);\r\n}\r\nstatic void wait_for_vertical_sync(struct ar *ar, int exp_line)\r\n{\r\n#if CHECK_LOST\r\nint tmout = 10000;\r\nint l;\r\nfor (; tmout >= 0; tmout--) {\r\nl = ar_inl(ARVHCOUNT);\r\nif (l == exp_line)\r\nbreak;\r\n}\r\nif (tmout < 0)\r\nv4l2_err(&ar->v4l2_dev, "lost %d -> %d\n", exp_line, l);\r\n#else\r\nwhile (ar_inl(ARVHCOUNT) != exp_line)\r\ncpu_relax();\r\n#endif\r\n}\r\nstatic ssize_t ar_read(struct file *file, char *buf, size_t count, loff_t *ppos)\r\n{\r\nstruct ar *ar = video_drvdata(file);\r\nlong ret = ar->frame_bytes;\r\nunsigned long arvcr1 = 0;\r\nunsigned long flags;\r\nunsigned char *p;\r\nint h, w;\r\nunsigned char *py, *pu, *pv;\r\n#if !USE_INT\r\nint l;\r\n#endif\r\nDEBUG(1, "ar_read()\n");\r\nif (ar->size == AR_SIZE_QVGA)\r\narvcr1 |= ARVCR1_QVGA;\r\nif (ar->mode == AR_MODE_NORMAL)\r\narvcr1 |= ARVCR1_NORMAL;\r\nmutex_lock(&ar->lock);\r\n#if USE_INT\r\nlocal_irq_save(flags);\r\ndisable_dma();\r\nar_outl(0xa1871300, M32R_DMA0CR0_PORTL);\r\nar_outl(0x01000000, M32R_DMA0CR1_PORTL);\r\nar_outl(ARDATA32, M32R_DMA0CSA_PORTL);\r\nar_outl(ARDATA32, M32R_DMA0RSA_PORTL);\r\nar_outl(ar->line_buff, M32R_DMA0CDA_PORTL);\r\nar_outl(ar->line_buff, M32R_DMA0RDA_PORTL);\r\nar_outl(ar->line_bytes, M32R_DMA0CBCUT_PORTL);\r\nar_outl(ar->line_bytes, M32R_DMA0RBCUT_PORTL);\r\nar->start_capture = 0;\r\nar_outl(arvcr1 | ARVCR1_HIEN, ARVCR1);\r\nlocal_irq_restore(flags);\r\ninterruptible_sleep_on(&ar->wait);\r\nif (signal_pending(current)) {\r\nprintk(KERN_ERR "arv: interrupted while get frame data.\n");\r\nret = -EINTR;\r\ngoto out_up;\r\n}\r\n#else\r\nar_outl(arvcr1, ARVCR1);\r\ndisable_dma();\r\nar_outl(0x8000, M32R_DMAEDET_PORTL);\r\nar_outl(0xa0861300, M32R_DMA0CR0_PORTL);\r\nar_outl(0x01000000, M32R_DMA0CR1_PORTL);\r\nar_outl(ARDATA32, M32R_DMA0CSA_PORTL);\r\nar_outl(ARDATA32, M32R_DMA0RSA_PORTL);\r\nar_outl(ar->line_bytes, M32R_DMA0CBCUT_PORTL);\r\nar_outl(ar->line_bytes, M32R_DMA0RBCUT_PORTL);\r\nlocal_irq_save(flags);\r\nwhile (ar_inl(ARVHCOUNT) != 0)\r\ncpu_relax();\r\nif (ar->mode == AR_MODE_INTERLACE && ar->size == AR_SIZE_VGA) {\r\nfor (h = 0; h < ar->height; h++) {\r\nwait_for_vertical_sync(ar, h);\r\nif (h < (AR_HEIGHT_VGA/2))\r\nl = h << 1;\r\nelse\r\nl = (((h - (AR_HEIGHT_VGA/2)) << 1) + 1);\r\nar_outl(virt_to_phys(ar->frame[l]), M32R_DMA0CDA_PORTL);\r\nenable_dma();\r\nwhile (!(ar_inl(M32R_DMAEDET_PORTL) & 0x8000))\r\ncpu_relax();\r\ndisable_dma();\r\nclear_dma_status();\r\nar_outl(0xa0861300, M32R_DMA0CR0_PORTL);\r\n}\r\n} else {\r\nfor (h = 0; h < ar->height; h++) {\r\nwait_for_vertical_sync(ar, h);\r\nar_outl(virt_to_phys(ar->frame[h]), M32R_DMA0CDA_PORTL);\r\nenable_dma();\r\nwhile (!(ar_inl(M32R_DMAEDET_PORTL) & 0x8000))\r\ncpu_relax();\r\ndisable_dma();\r\nclear_dma_status();\r\nar_outl(0xa0861300, M32R_DMA0CR0_PORTL);\r\n}\r\n}\r\nlocal_irq_restore(flags);\r\n#endif\r\npy = yuv;\r\npu = py + (ar->frame_bytes / 2);\r\npv = pu + (ar->frame_bytes / 4);\r\nfor (h = 0; h < ar->height; h++) {\r\np = ar->frame[h];\r\nfor (w = 0; w < ar->line_bytes; w += 4) {\r\n*py++ = *p++;\r\n*pu++ = *p++;\r\n*py++ = *p++;\r\n*pv++ = *p++;\r\n}\r\n}\r\nif (copy_to_user(buf, yuv, ar->frame_bytes)) {\r\nv4l2_err(&ar->v4l2_dev, "failed while copy_to_user yuv.\n");\r\nret = -EFAULT;\r\ngoto out_up;\r\n}\r\nDEBUG(1, "ret = %d\n", ret);\r\nout_up:\r\nmutex_unlock(&ar->lock);\r\nreturn ret;\r\n}\r\nstatic int ar_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *vcap)\r\n{\r\nstruct ar *ar = video_drvdata(file);\r\nstrlcpy(vcap->driver, ar->vdev.name, sizeof(vcap->driver));\r\nstrlcpy(vcap->card, "Colour AR VGA", sizeof(vcap->card));\r\nstrlcpy(vcap->bus_info, "Platform", sizeof(vcap->bus_info));\r\nvcap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE;\r\nreturn 0;\r\n}\r\nstatic int ar_enum_input(struct file *file, void *fh, struct v4l2_input *vin)\r\n{\r\nif (vin->index > 0)\r\nreturn -EINVAL;\r\nstrlcpy(vin->name, "Camera", sizeof(vin->name));\r\nvin->type = V4L2_INPUT_TYPE_CAMERA;\r\nvin->audioset = 0;\r\nvin->tuner = 0;\r\nvin->std = V4L2_STD_ALL;\r\nvin->status = 0;\r\nreturn 0;\r\n}\r\nstatic int ar_g_input(struct file *file, void *fh, unsigned int *inp)\r\n{\r\n*inp = 0;\r\nreturn 0;\r\n}\r\nstatic int ar_s_input(struct file *file, void *fh, unsigned int inp)\r\n{\r\nreturn inp ? -EINVAL : 0;\r\n}\r\nstatic int ar_g_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct ar *ar = video_drvdata(file);\r\nstruct v4l2_pix_format *pix = &fmt->fmt.pix;\r\npix->width = ar->width;\r\npix->height = ar->height;\r\npix->pixelformat = V4L2_PIX_FMT_YUV422P;\r\npix->field = (ar->mode == AR_MODE_NORMAL) ? V4L2_FIELD_NONE : V4L2_FIELD_INTERLACED;\r\npix->bytesperline = ar->width;\r\npix->sizeimage = 2 * ar->width * ar->height;\r\npix->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int ar_try_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct ar *ar = video_drvdata(file);\r\nstruct v4l2_pix_format *pix = &fmt->fmt.pix;\r\nif (pix->height <= AR_HEIGHT_QVGA || pix->width <= AR_WIDTH_QVGA) {\r\npix->height = AR_HEIGHT_QVGA;\r\npix->width = AR_WIDTH_QVGA;\r\npix->field = V4L2_FIELD_INTERLACED;\r\n} else {\r\npix->height = AR_HEIGHT_VGA;\r\npix->width = AR_WIDTH_VGA;\r\npix->field = vga_interlace ? V4L2_FIELD_INTERLACED : V4L2_FIELD_NONE;\r\n}\r\npix->pixelformat = V4L2_PIX_FMT_YUV422P;\r\npix->bytesperline = ar->width;\r\npix->sizeimage = 2 * ar->width * ar->height;\r\npix->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int ar_s_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct ar *ar = video_drvdata(file);\r\nstruct v4l2_pix_format *pix = &fmt->fmt.pix;\r\nint ret = ar_try_fmt_vid_cap(file, fh, fmt);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&ar->lock);\r\nar->width = pix->width;\r\nar->height = pix->height;\r\nif (ar->width == AR_WIDTH_VGA) {\r\nar->size = AR_SIZE_VGA;\r\nar->frame_bytes = AR_FRAME_BYTES_VGA;\r\nar->line_bytes = AR_LINE_BYTES_VGA;\r\nif (vga_interlace)\r\nar->mode = AR_MODE_INTERLACE;\r\nelse\r\nar->mode = AR_MODE_NORMAL;\r\n} else {\r\nar->size = AR_SIZE_QVGA;\r\nar->frame_bytes = AR_FRAME_BYTES_QVGA;\r\nar->line_bytes = AR_LINE_BYTES_QVGA;\r\nar->mode = AR_MODE_INTERLACE;\r\n}\r\nmutex_unlock(&ar->lock);\r\nreturn 0;\r\n}\r\nstatic int ar_enum_fmt_vid_cap(struct file *file, void *fh, struct v4l2_fmtdesc *fmt)\r\n{\r\nstatic struct v4l2_fmtdesc formats[] = {\r\n{ 0, 0, 0,\r\n"YUV 4:2:2 Planar", V4L2_PIX_FMT_YUV422P,\r\n{ 0, 0, 0, 0 }\r\n},\r\n};\r\nenum v4l2_buf_type type = fmt->type;\r\nif (fmt->index > 0)\r\nreturn -EINVAL;\r\n*fmt = formats[fmt->index];\r\nfmt->type = type;\r\nreturn 0;\r\n}\r\nstatic void ar_interrupt(int irq, void *dev)\r\n{\r\nstruct ar *ar = dev;\r\nunsigned int line_count;\r\nunsigned int line_number;\r\nunsigned int arvcr1;\r\nline_count = ar_inl(ARVHCOUNT);\r\nif (ar->mode == AR_MODE_INTERLACE && ar->size == AR_SIZE_VGA) {\r\nif (line_count < (AR_HEIGHT_VGA / 2))\r\nline_number = (line_count << 1);\r\nelse\r\nline_number =\r\n(((line_count - (AR_HEIGHT_VGA / 2)) << 1) + 1);\r\n} else {\r\nline_number = line_count;\r\n}\r\nif (line_number == 0) {\r\ndisable_dma();\r\n#if 0\r\nar_outl(ar->line_buff, M32R_DMA0CDA_PORTL);\r\n#endif\r\nmemcpy(ar->frame[0], ar->line_buff, ar->line_bytes);\r\n#if 0\r\nar_outl(0xa1861300, M32R_DMA0CR0_PORTL);\r\n#endif\r\nenable_dma();\r\nar->start_capture = 1;\r\nreturn;\r\n}\r\nif (ar->start_capture == 1 && line_number <= (ar->height - 1)) {\r\ndisable_dma();\r\nmemcpy(ar->frame[line_number], ar->line_buff, ar->line_bytes);\r\nif (line_number == (ar->height - 1)) {\r\nar->start_capture = 0;\r\narvcr1 = ar_inl(ARVCR1);\r\narvcr1 &= ~ARVCR1_HIEN;\r\nar_outl(arvcr1, ARVCR1);\r\nwake_up_interruptible(&ar->wait);\r\n} else {\r\n#if 0\r\nar_outl(ar->line_buff, M32R_DMA0CDA_PORTL);\r\nar_outl(0xa1861300, M32R_DMA0CR0_PORTL);\r\n#endif\r\nenable_dma();\r\n}\r\n}\r\n}\r\nstatic int ar_initialize(struct ar *ar)\r\n{\r\nunsigned long cr = 0;\r\nint i, found = 0;\r\nDEBUG(1, "ar_initialize:\n");\r\nar_outl(0, ARVCR0);\r\nfor (i = 0; i < 0x18; i++)\r\ncpu_relax();\r\nar_outl(ARVCR0_RST, ARVCR0);\r\nfor (i = 0; i < 0x40d; i++)\r\ncpu_relax();\r\nar_outl(ARINTSEL_INT3, ARINTSEL);\r\nif (ar->size == AR_SIZE_QVGA)\r\ncr |= ARVCR1_QVGA;\r\nif (ar->mode == AR_MODE_NORMAL)\r\ncr |= ARVCR1_NORMAL;\r\nar_outl(cr, ARVCR1);\r\ninit_iic();\r\nfor (i = 0; i < 0x100000; i++) {\r\nif ((ar_inl(ARVCR0) & ARVCR0_VDS)) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (found == 0)\r\nreturn -ENODEV;\r\nv4l2_info(&ar->v4l2_dev, "Initializing ");\r\niic(2, 0x78, 0x11, 0x01, 0x00);\r\niic(3, 0x78, 0x12, 0x00, 0x06);\r\niic(3, 0x78, 0x12, 0x12, 0x30);\r\niic(3, 0x78, 0x12, 0x15, 0x58);\r\niic(3, 0x78, 0x12, 0x17, 0x30);\r\nprintk(KERN_CONT ".");\r\niic(3, 0x78, 0x12, 0x1a, 0x97);\r\niic(3, 0x78, 0x12, 0x1b, 0xff);\r\niic(3, 0x78, 0x12, 0x1c, 0xff);\r\niic(3, 0x78, 0x12, 0x26, 0x10);\r\niic(3, 0x78, 0x12, 0x27, 0x00);\r\nprintk(KERN_CONT ".");\r\niic(2, 0x78, 0x34, 0x02, 0x00);\r\niic(2, 0x78, 0x7a, 0x10, 0x00);\r\niic(2, 0x78, 0x80, 0x39, 0x00);\r\niic(2, 0x78, 0x81, 0xe6, 0x00);\r\niic(2, 0x78, 0x8d, 0x00, 0x00);\r\nprintk(KERN_CONT ".");\r\niic(2, 0x78, 0x8e, 0x0c, 0x00);\r\niic(2, 0x78, 0x8f, 0x00, 0x00);\r\n#if 0\r\niic(2, 0x78, 0x90, 0x00, 0x00);\r\n#endif\r\niic(2, 0x78, 0x93, 0x01, 0x00);\r\niic(2, 0x78, 0x94, 0xcd, 0x00);\r\niic(2, 0x78, 0x95, 0x00, 0x00);\r\nprintk(KERN_CONT ".");\r\niic(2, 0x78, 0x96, 0xa0, 0x00);\r\niic(2, 0x78, 0x97, 0x00, 0x00);\r\niic(2, 0x78, 0x98, 0x60, 0x00);\r\niic(2, 0x78, 0x99, 0x01, 0x00);\r\niic(2, 0x78, 0x9a, 0x19, 0x00);\r\nprintk(KERN_CONT ".");\r\niic(2, 0x78, 0x9b, 0x02, 0x00);\r\niic(2, 0x78, 0x9c, 0xe8, 0x00);\r\niic(2, 0x78, 0x9d, 0x02, 0x00);\r\niic(2, 0x78, 0x9e, 0x2e, 0x00);\r\niic(2, 0x78, 0xb8, 0x78, 0x00);\r\niic(2, 0x78, 0xba, 0x05, 0x00);\r\n#if 0\r\niic(2, 0x78, 0x83, 0x8c, 0x00);\r\n#endif\r\nprintk(KERN_CONT ".");\r\niic(3, 0x78, 0x49, 0x00, 0x95);\r\niic(3, 0x78, 0x49, 0x01, 0x96);\r\niic(3, 0x78, 0x49, 0x03, 0x85);\r\niic(3, 0x78, 0x49, 0x04, 0x97);\r\niic(3, 0x78, 0x49, 0x02, 0x7e);\r\niic(3, 0x78, 0x49, 0x05, 0xa4);\r\niic(3, 0x78, 0x49, 0x06, 0x04);\r\niic(3, 0x78, 0x49, 0x07, 0x04);\r\niic(2, 0x78, 0x48, 0x01, 0x00);\r\nprintk(KERN_CONT ".");\r\niic(2, 0x78, 0x11, 0x00, 0x00);\r\nprintk(KERN_CONT " done\n");\r\nreturn 0;\r\n}\r\nstatic int __init ar_init(void)\r\n{\r\nstruct ar *ar;\r\nstruct v4l2_device *v4l2_dev;\r\nint ret;\r\nint i;\r\nar = &ardev;\r\nv4l2_dev = &ar->v4l2_dev;\r\nstrlcpy(v4l2_dev->name, "arv", sizeof(v4l2_dev->name));\r\nv4l2_info(v4l2_dev, "Colour AR VGA driver %s\n", VERSION);\r\nret = v4l2_device_register(NULL, v4l2_dev);\r\nif (ret < 0) {\r\nv4l2_err(v4l2_dev, "Could not register v4l2_device\n");\r\nreturn ret;\r\n}\r\nret = -EIO;\r\n#if USE_INT\r\nar->line_buff = kmalloc(MAX_AR_LINE_BYTES, GFP_KERNEL | GFP_DMA);\r\nif (ar->line_buff == NULL || !ALIGN4(ar->line_buff)) {\r\nv4l2_err(v4l2_dev, "buffer allocation failed for DMA.\n");\r\nret = -ENOMEM;\r\ngoto out_end;\r\n}\r\n#endif\r\nfor (i = 0; i < MAX_AR_HEIGHT; i++) {\r\nar->frame[i] = kmalloc(MAX_AR_LINE_BYTES, GFP_KERNEL);\r\nif (ar->frame[i] == NULL || !ALIGN4(ar->frame[i])) {\r\nv4l2_err(v4l2_dev, "buffer allocation failed for frame.\n");\r\nret = -ENOMEM;\r\ngoto out_line_buff;\r\n}\r\n}\r\nstrlcpy(ar->vdev.name, "Colour AR VGA", sizeof(ar->vdev.name));\r\nar->vdev.v4l2_dev = v4l2_dev;\r\nar->vdev.fops = &ar_fops;\r\nar->vdev.ioctl_ops = &ar_ioctl_ops;\r\nar->vdev.release = video_device_release_empty;\r\nvideo_set_drvdata(&ar->vdev, ar);\r\nif (vga) {\r\nar->width = AR_WIDTH_VGA;\r\nar->height = AR_HEIGHT_VGA;\r\nar->size = AR_SIZE_VGA;\r\nar->frame_bytes = AR_FRAME_BYTES_VGA;\r\nar->line_bytes = AR_LINE_BYTES_VGA;\r\nif (vga_interlace)\r\nar->mode = AR_MODE_INTERLACE;\r\nelse\r\nar->mode = AR_MODE_NORMAL;\r\n} else {\r\nar->width = AR_WIDTH_QVGA;\r\nar->height = AR_HEIGHT_QVGA;\r\nar->size = AR_SIZE_QVGA;\r\nar->frame_bytes = AR_FRAME_BYTES_QVGA;\r\nar->line_bytes = AR_LINE_BYTES_QVGA;\r\nar->mode = AR_MODE_INTERLACE;\r\n}\r\nmutex_init(&ar->lock);\r\ninit_waitqueue_head(&ar->wait);\r\n#if USE_INT\r\nif (request_irq(M32R_IRQ_INT3, ar_interrupt, 0, "arv", ar)) {\r\nv4l2_err("request_irq(%d) failed.\n", M32R_IRQ_INT3);\r\nret = -EIO;\r\ngoto out_irq;\r\n}\r\n#endif\r\nif (ar_initialize(ar) != 0) {\r\nv4l2_err(v4l2_dev, "M64278 not found.\n");\r\nret = -ENODEV;\r\ngoto out_dev;\r\n}\r\nif (video_register_device(&ar->vdev, VFL_TYPE_GRABBER, video_nr) != 0) {\r\nv4l2_err(v4l2_dev, "register video (Colour AR) failed.\n");\r\nret = -ENODEV;\r\ngoto out_dev;\r\n}\r\nv4l2_info(v4l2_dev, "%s: Found M64278 VGA (IRQ %d, Freq %dMHz).\n",\r\nvideo_device_node_name(&ar->vdev), M32R_IRQ_INT3, freq);\r\nreturn 0;\r\nout_dev:\r\n#if USE_INT\r\nfree_irq(M32R_IRQ_INT3, ar);\r\nout_irq:\r\n#endif\r\nfor (i = 0; i < MAX_AR_HEIGHT; i++)\r\nkfree(ar->frame[i]);\r\nout_line_buff:\r\n#if USE_INT\r\nkfree(ar->line_buff);\r\nout_end:\r\n#endif\r\nv4l2_device_unregister(&ar->v4l2_dev);\r\nreturn ret;\r\n}\r\nstatic int __init ar_init_module(void)\r\n{\r\nfreq = (boot_cpu_data.bus_clock / 1000000);\r\nprintk(KERN_INFO "arv: Bus clock %d\n", freq);\r\nif (freq != 50 && freq != 75)\r\nfreq = DEFAULT_FREQ;\r\nreturn ar_init();\r\n}\r\nstatic void __exit ar_cleanup_module(void)\r\n{\r\nstruct ar *ar;\r\nint i;\r\nar = &ardev;\r\nvideo_unregister_device(&ar->vdev);\r\n#if USE_INT\r\nfree_irq(M32R_IRQ_INT3, ar);\r\n#endif\r\nfor (i = 0; i < MAX_AR_HEIGHT; i++)\r\nkfree(ar->frame[i]);\r\n#if USE_INT\r\nkfree(ar->line_buff);\r\n#endif\r\nv4l2_device_unregister(&ar->v4l2_dev);\r\n}
