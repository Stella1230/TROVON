static void do_catch_up(struct spk_synth *synth)\r\n{\r\nu_char ch;\r\nunsigned long flags;\r\nunsigned long jiff_max;\r\nstruct var_t *jiffy_delta;\r\nstruct var_t *delay_time;\r\nstruct var_t *full_time;\r\nint full_time_val = 0;\r\nint delay_time_val = 0;\r\nint jiffy_delta_val = 0;\r\njiffy_delta = get_var(JIFFY);\r\ndelay_time = get_var(DELAY);\r\nfull_time = get_var(FULL);\r\nspk_lock(flags);\r\njiffy_delta_val = jiffy_delta->u.n.value;\r\nspk_unlock(flags);\r\njiff_max = jiffies + jiffy_delta_val;\r\nwhile (!kthread_should_stop()) {\r\nspk_lock(flags);\r\njiffy_delta_val = jiffy_delta->u.n.value;\r\nfull_time_val = full_time->u.n.value;\r\ndelay_time_val = delay_time->u.n.value;\r\nif (speakup_info.flushing) {\r\nspeakup_info.flushing = 0;\r\nspk_unlock(flags);\r\nsynth->flush(synth);\r\ncontinue;\r\n}\r\nif (synth_buffer_empty()) {\r\nspk_unlock(flags);\r\nbreak;\r\n}\r\nch = synth_buffer_peek();\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nfull_time_val = full_time->u.n.value;\r\nspk_unlock(flags);\r\nif (!spk_serial_out(ch)) {\r\noutb(UART_MCR_DTR, speakup_info.port_tts + UART_MCR);\r\noutb(UART_MCR_DTR | UART_MCR_RTS,\r\nspeakup_info.port_tts + UART_MCR);\r\nschedule_timeout(msecs_to_jiffies(full_time_val));\r\ncontinue;\r\n}\r\nif ((jiffies >= jiff_max) && (ch == SPACE)) {\r\nspk_lock(flags);\r\njiffy_delta_val = jiffy_delta->u.n.value;\r\nfull_time_val = full_time->u.n.value;\r\ndelay_time_val = delay_time->u.n.value;\r\nspk_unlock(flags);\r\nif (spk_serial_out(synth->procspeech))\r\nschedule_timeout(msecs_to_jiffies\r\n(delay_time_val));\r\nelse\r\nschedule_timeout(msecs_to_jiffies\r\n(full_time_val));\r\njiff_max = jiffies + jiffy_delta_val;\r\n}\r\nset_current_state(TASK_RUNNING);\r\nspk_lock(flags);\r\nsynth_buffer_getc();\r\nspk_unlock(flags);\r\n}\r\nspk_serial_out(PROCSPEECH);\r\n}\r\nstatic int __init apollo_init(void)\r\n{\r\nreturn synth_add(&synth_apollo);\r\n}\r\nstatic void __exit apollo_exit(void)\r\n{\r\nsynth_remove(&synth_apollo);\r\n}
