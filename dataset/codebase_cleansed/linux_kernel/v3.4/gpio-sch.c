static int sch_gpio_core_direction_in(struct gpio_chip *gc, unsigned gpio_num)\r\n{\r\nu8 curr_dirs;\r\nunsigned short offset, bit;\r\nspin_lock(&gpio_lock);\r\noffset = CGIO + gpio_num / 8;\r\nbit = gpio_num % 8;\r\ncurr_dirs = inb(gpio_ba + offset);\r\nif (!(curr_dirs & (1 << bit)))\r\noutb(curr_dirs | (1 << bit), gpio_ba + offset);\r\nspin_unlock(&gpio_lock);\r\nreturn 0;\r\n}\r\nstatic int sch_gpio_core_get(struct gpio_chip *gc, unsigned gpio_num)\r\n{\r\nint res;\r\nunsigned short offset, bit;\r\noffset = CGLV + gpio_num / 8;\r\nbit = gpio_num % 8;\r\nres = !!(inb(gpio_ba + offset) & (1 << bit));\r\nreturn res;\r\n}\r\nstatic void sch_gpio_core_set(struct gpio_chip *gc, unsigned gpio_num, int val)\r\n{\r\nu8 curr_vals;\r\nunsigned short offset, bit;\r\nspin_lock(&gpio_lock);\r\noffset = CGLV + gpio_num / 8;\r\nbit = gpio_num % 8;\r\ncurr_vals = inb(gpio_ba + offset);\r\nif (val)\r\noutb(curr_vals | (1 << bit), gpio_ba + offset);\r\nelse\r\noutb((curr_vals & ~(1 << bit)), gpio_ba + offset);\r\nspin_unlock(&gpio_lock);\r\n}\r\nstatic int sch_gpio_core_direction_out(struct gpio_chip *gc,\r\nunsigned gpio_num, int val)\r\n{\r\nu8 curr_dirs;\r\nunsigned short offset, bit;\r\nsch_gpio_core_set(gc, gpio_num, val);\r\nspin_lock(&gpio_lock);\r\noffset = CGIO + gpio_num / 8;\r\nbit = gpio_num % 8;\r\ncurr_dirs = inb(gpio_ba + offset);\r\nif (curr_dirs & (1 << bit))\r\noutb(curr_dirs & ~(1 << bit), gpio_ba + offset);\r\nspin_unlock(&gpio_lock);\r\nreturn 0;\r\n}\r\nstatic int sch_gpio_resume_direction_in(struct gpio_chip *gc,\r\nunsigned gpio_num)\r\n{\r\nu8 curr_dirs;\r\nspin_lock(&gpio_lock);\r\ncurr_dirs = inb(gpio_ba + RGIO);\r\nif (!(curr_dirs & (1 << gpio_num)))\r\noutb(curr_dirs | (1 << gpio_num) , gpio_ba + RGIO);\r\nspin_unlock(&gpio_lock);\r\nreturn 0;\r\n}\r\nstatic int sch_gpio_resume_get(struct gpio_chip *gc, unsigned gpio_num)\r\n{\r\nreturn !!(inb(gpio_ba + RGLV) & (1 << gpio_num));\r\n}\r\nstatic void sch_gpio_resume_set(struct gpio_chip *gc,\r\nunsigned gpio_num, int val)\r\n{\r\nu8 curr_vals;\r\nspin_lock(&gpio_lock);\r\ncurr_vals = inb(gpio_ba + RGLV);\r\nif (val)\r\noutb(curr_vals | (1 << gpio_num), gpio_ba + RGLV);\r\nelse\r\noutb((curr_vals & ~(1 << gpio_num)), gpio_ba + RGLV);\r\nspin_unlock(&gpio_lock);\r\n}\r\nstatic int sch_gpio_resume_direction_out(struct gpio_chip *gc,\r\nunsigned gpio_num, int val)\r\n{\r\nu8 curr_dirs;\r\nsch_gpio_resume_set(gc, gpio_num, val);\r\nspin_lock(&gpio_lock);\r\ncurr_dirs = inb(gpio_ba + RGIO);\r\nif (curr_dirs & (1 << gpio_num))\r\noutb(curr_dirs & ~(1 << gpio_num), gpio_ba + RGIO);\r\nspin_unlock(&gpio_lock);\r\nreturn 0;\r\n}\r\nstatic int __devinit sch_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nint err, id;\r\nid = pdev->id;\r\nif (!id)\r\nreturn -ENODEV;\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (!res)\r\nreturn -EBUSY;\r\nif (!request_region(res->start, resource_size(res), pdev->name))\r\nreturn -EBUSY;\r\ngpio_ba = res->start;\r\nswitch (id) {\r\ncase PCI_DEVICE_ID_INTEL_SCH_LPC:\r\nsch_gpio_core.base = 0;\r\nsch_gpio_core.ngpio = 10;\r\nsch_gpio_resume.base = 10;\r\nsch_gpio_resume.ngpio = 4;\r\noutb(0x3, gpio_ba + CGEN + 1);\r\noutb(0x8, gpio_ba + RGEN);\r\nbreak;\r\ncase PCI_DEVICE_ID_INTEL_ITC_LPC:\r\nsch_gpio_core.base = 0;\r\nsch_gpio_core.ngpio = 5;\r\nsch_gpio_resume.base = 5;\r\nsch_gpio_resume.ngpio = 9;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nsch_gpio_core.dev = &pdev->dev;\r\nsch_gpio_resume.dev = &pdev->dev;\r\nerr = gpiochip_add(&sch_gpio_core);\r\nif (err < 0)\r\ngoto err_sch_gpio_core;\r\nerr = gpiochip_add(&sch_gpio_resume);\r\nif (err < 0)\r\ngoto err_sch_gpio_resume;\r\nreturn 0;\r\nerr_sch_gpio_resume:\r\nerr = gpiochip_remove(&sch_gpio_core);\r\nif (err)\r\ndev_err(&pdev->dev, "%s failed, %d\n",\r\n"gpiochip_remove()", err);\r\nerr_sch_gpio_core:\r\nrelease_region(res->start, resource_size(res));\r\ngpio_ba = 0;\r\nreturn err;\r\n}\r\nstatic int __devexit sch_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nif (gpio_ba) {\r\nint err;\r\nerr = gpiochip_remove(&sch_gpio_core);\r\nif (err)\r\ndev_err(&pdev->dev, "%s failed, %d\n",\r\n"gpiochip_remove()", err);\r\nerr = gpiochip_remove(&sch_gpio_resume);\r\nif (err)\r\ndev_err(&pdev->dev, "%s failed, %d\n",\r\n"gpiochip_remove()", err);\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nrelease_region(res->start, resource_size(res));\r\ngpio_ba = 0;\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
