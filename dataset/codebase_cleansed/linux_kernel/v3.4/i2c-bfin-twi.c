static void bfin_twi_handle_interrupt(struct bfin_twi_iface *iface,\r\nunsigned short twi_int_status)\r\n{\r\nunsigned short mast_stat = read_MASTER_STAT(iface);\r\nif (twi_int_status & XMTSERV) {\r\nif (iface->writeNum > 0) {\r\nSSYNC();\r\nwrite_XMT_DATA8(iface, *(iface->transPtr++));\r\niface->writeNum--;\r\n}\r\nelse if (iface->cur_mode == TWI_I2C_MODE_COMBINED)\r\nwrite_MASTER_CTL(iface,\r\nread_MASTER_CTL(iface) | MDIR | RSTART);\r\nelse if (iface->manual_stop)\r\nwrite_MASTER_CTL(iface,\r\nread_MASTER_CTL(iface) | STOP);\r\nelse if (iface->cur_mode == TWI_I2C_MODE_REPEAT &&\r\niface->cur_msg + 1 < iface->msg_num) {\r\nif (iface->pmsg[iface->cur_msg + 1].flags & I2C_M_RD)\r\nwrite_MASTER_CTL(iface,\r\nread_MASTER_CTL(iface) | RSTART | MDIR);\r\nelse\r\nwrite_MASTER_CTL(iface,\r\n(read_MASTER_CTL(iface) | RSTART) & ~MDIR);\r\n}\r\n}\r\nif (twi_int_status & RCVSERV) {\r\nif (iface->readNum > 0) {\r\n*(iface->transPtr) = read_RCV_DATA8(iface);\r\nif (iface->cur_mode == TWI_I2C_MODE_COMBINED) {\r\niface->cur_mode = TWI_I2C_MODE_STANDARDSUB;\r\nif (iface->readNum == 1 && iface->manual_stop)\r\niface->readNum = *iface->transPtr + 1;\r\n}\r\niface->transPtr++;\r\niface->readNum--;\r\n} else if (iface->manual_stop) {\r\nwrite_MASTER_CTL(iface,\r\nread_MASTER_CTL(iface) | STOP);\r\n} else if (iface->cur_mode == TWI_I2C_MODE_REPEAT &&\r\niface->cur_msg + 1 < iface->msg_num) {\r\nif (iface->pmsg[iface->cur_msg + 1].flags & I2C_M_RD)\r\nwrite_MASTER_CTL(iface,\r\nread_MASTER_CTL(iface) | RSTART | MDIR);\r\nelse\r\nwrite_MASTER_CTL(iface,\r\n(read_MASTER_CTL(iface) | RSTART) & ~MDIR);\r\n}\r\n}\r\nif (twi_int_status & MERR) {\r\nwrite_INT_MASK(iface, 0);\r\nwrite_MASTER_STAT(iface, 0x3e);\r\nwrite_MASTER_CTL(iface, 0);\r\niface->result = -EIO;\r\nif (mast_stat & LOSTARB)\r\ndev_dbg(&iface->adap.dev, "Lost Arbitration\n");\r\nif (mast_stat & ANAK)\r\ndev_dbg(&iface->adap.dev, "Address Not Acknowledged\n");\r\nif (mast_stat & DNAK)\r\ndev_dbg(&iface->adap.dev, "Data Not Acknowledged\n");\r\nif (mast_stat & BUFRDERR)\r\ndev_dbg(&iface->adap.dev, "Buffer Read Error\n");\r\nif (mast_stat & BUFWRERR)\r\ndev_dbg(&iface->adap.dev, "Buffer Write Error\n");\r\nif (read_MASTER_STAT(iface) & SDASEN) {\r\nint cnt = 9;\r\ndo {\r\nwrite_MASTER_CTL(iface, SCLOVR);\r\nudelay(6);\r\nwrite_MASTER_CTL(iface, 0);\r\nudelay(6);\r\n} while ((read_MASTER_STAT(iface) & SDASEN) && cnt--);\r\nwrite_MASTER_CTL(iface, SDAOVR | SCLOVR);\r\nudelay(6);\r\nwrite_MASTER_CTL(iface, SDAOVR);\r\nudelay(6);\r\nwrite_MASTER_CTL(iface, 0);\r\n}\r\nif (iface->cur_mode == TWI_I2C_MODE_STANDARD &&\r\niface->transPtr == NULL &&\r\n(twi_int_status & MCOMP) && (mast_stat & DNAK))\r\niface->result = 1;\r\ncomplete(&iface->complete);\r\nreturn;\r\n}\r\nif (twi_int_status & MCOMP) {\r\nif ((read_MASTER_CTL(iface) & MEN) == 0 &&\r\n(iface->cur_mode == TWI_I2C_MODE_REPEAT ||\r\niface->cur_mode == TWI_I2C_MODE_COMBINED)) {\r\niface->result = -1;\r\nwrite_INT_MASK(iface, 0);\r\nwrite_MASTER_CTL(iface, 0);\r\n} else if (iface->cur_mode == TWI_I2C_MODE_COMBINED) {\r\nif (iface->readNum == 0) {\r\niface->readNum = 1;\r\niface->manual_stop = 1;\r\nwrite_MASTER_CTL(iface,\r\nread_MASTER_CTL(iface) | (0xff << 6));\r\n} else {\r\nwrite_MASTER_CTL(iface,\r\n(read_MASTER_CTL(iface) &\r\n(~(0xff << 6))) |\r\n(iface->readNum << 6));\r\n}\r\nwrite_MASTER_CTL(iface,\r\nread_MASTER_CTL(iface) & ~RSTART);\r\n} else if (iface->cur_mode == TWI_I2C_MODE_REPEAT &&\r\niface->cur_msg+1 < iface->msg_num) {\r\niface->cur_msg++;\r\niface->transPtr = iface->pmsg[iface->cur_msg].buf;\r\niface->writeNum = iface->readNum =\r\niface->pmsg[iface->cur_msg].len;\r\nwrite_MASTER_ADDR(iface,\r\niface->pmsg[iface->cur_msg].addr);\r\nif (iface->pmsg[iface->cur_msg].flags & I2C_M_RD)\r\niface->read_write = I2C_SMBUS_READ;\r\nelse {\r\niface->read_write = I2C_SMBUS_WRITE;\r\nif (iface->writeNum > 0) {\r\nwrite_XMT_DATA8(iface,\r\n*(iface->transPtr++));\r\niface->writeNum--;\r\n}\r\n}\r\nif (iface->pmsg[iface->cur_msg].len <= 255)\r\nwrite_MASTER_CTL(iface,\r\n(read_MASTER_CTL(iface) &\r\n(~(0xff << 6))) |\r\n(iface->pmsg[iface->cur_msg].len << 6));\r\nelse {\r\nwrite_MASTER_CTL(iface,\r\n(read_MASTER_CTL(iface) |\r\n(0xff << 6)));\r\niface->manual_stop = 1;\r\n}\r\nwrite_MASTER_CTL(iface,\r\nread_MASTER_CTL(iface) & ~RSTART);\r\n} else {\r\niface->result = 1;\r\nwrite_INT_MASK(iface, 0);\r\nwrite_MASTER_CTL(iface, 0);\r\n}\r\n}\r\ncomplete(&iface->complete);\r\n}\r\nstatic irqreturn_t bfin_twi_interrupt_entry(int irq, void *dev_id)\r\n{\r\nstruct bfin_twi_iface *iface = dev_id;\r\nunsigned long flags;\r\nunsigned short twi_int_status;\r\nspin_lock_irqsave(&iface->lock, flags);\r\nwhile (1) {\r\ntwi_int_status = read_INT_STAT(iface);\r\nif (!twi_int_status)\r\nbreak;\r\nwrite_INT_STAT(iface, twi_int_status);\r\nbfin_twi_handle_interrupt(iface, twi_int_status);\r\nSSYNC();\r\n}\r\nspin_unlock_irqrestore(&iface->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bfin_twi_do_master_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct bfin_twi_iface *iface = adap->algo_data;\r\nstruct i2c_msg *pmsg;\r\nint rc = 0;\r\nif (!(read_CONTROL(iface) & TWI_ENA))\r\nreturn -ENXIO;\r\nwhile (read_MASTER_STAT(iface) & BUSBUSY)\r\nyield();\r\niface->pmsg = msgs;\r\niface->msg_num = num;\r\niface->cur_msg = 0;\r\npmsg = &msgs[0];\r\nif (pmsg->flags & I2C_M_TEN) {\r\ndev_err(&adap->dev, "10 bits addr not supported!\n");\r\nreturn -EINVAL;\r\n}\r\niface->cur_mode = TWI_I2C_MODE_REPEAT;\r\niface->manual_stop = 0;\r\niface->transPtr = pmsg->buf;\r\niface->writeNum = iface->readNum = pmsg->len;\r\niface->result = 0;\r\ninit_completion(&(iface->complete));\r\nwrite_MASTER_ADDR(iface, pmsg->addr);\r\nwrite_FIFO_CTL(iface, 0x3);\r\nSSYNC();\r\nwrite_FIFO_CTL(iface, 0);\r\nSSYNC();\r\nif (pmsg->flags & I2C_M_RD)\r\niface->read_write = I2C_SMBUS_READ;\r\nelse {\r\niface->read_write = I2C_SMBUS_WRITE;\r\nif (iface->writeNum > 0) {\r\nwrite_XMT_DATA8(iface, *(iface->transPtr++));\r\niface->writeNum--;\r\nSSYNC();\r\n}\r\n}\r\nwrite_INT_STAT(iface, MERR | MCOMP | XMTSERV | RCVSERV);\r\nwrite_INT_MASK(iface, MCOMP | MERR | RCVSERV | XMTSERV);\r\nSSYNC();\r\nif (pmsg->len <= 255)\r\nwrite_MASTER_CTL(iface, pmsg->len << 6);\r\nelse {\r\nwrite_MASTER_CTL(iface, 0xff << 6);\r\niface->manual_stop = 1;\r\n}\r\nwrite_MASTER_CTL(iface, read_MASTER_CTL(iface) | MEN |\r\n((iface->read_write == I2C_SMBUS_READ) ? MDIR : 0) |\r\n((CONFIG_I2C_BLACKFIN_TWI_CLK_KHZ > 100) ? FAST : 0));\r\nSSYNC();\r\nwhile (!iface->result) {\r\nif (!wait_for_completion_timeout(&iface->complete,\r\nadap->timeout)) {\r\niface->result = -1;\r\ndev_err(&adap->dev, "master transfer timeout\n");\r\n}\r\n}\r\nif (iface->result == 1)\r\nrc = iface->cur_msg + 1;\r\nelse\r\nrc = iface->result;\r\nreturn rc;\r\n}\r\nstatic int bfin_twi_master_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nreturn bfin_twi_do_master_xfer(adap, msgs, num);\r\n}\r\nint bfin_twi_do_smbus_xfer(struct i2c_adapter *adap, u16 addr,\r\nunsigned short flags, char read_write,\r\nu8 command, int size, union i2c_smbus_data *data)\r\n{\r\nstruct bfin_twi_iface *iface = adap->algo_data;\r\nint rc = 0;\r\nif (!(read_CONTROL(iface) & TWI_ENA))\r\nreturn -ENXIO;\r\nwhile (read_MASTER_STAT(iface) & BUSBUSY)\r\nyield();\r\niface->writeNum = 0;\r\niface->readNum = 0;\r\nswitch (size) {\r\ncase I2C_SMBUS_QUICK:\r\niface->transPtr = NULL;\r\niface->cur_mode = TWI_I2C_MODE_STANDARD;\r\nbreak;\r\ncase I2C_SMBUS_BYTE:\r\nif (data == NULL)\r\niface->transPtr = NULL;\r\nelse {\r\nif (read_write == I2C_SMBUS_READ)\r\niface->readNum = 1;\r\nelse\r\niface->writeNum = 1;\r\niface->transPtr = &data->byte;\r\n}\r\niface->cur_mode = TWI_I2C_MODE_STANDARD;\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\nif (read_write == I2C_SMBUS_READ) {\r\niface->readNum = 1;\r\niface->cur_mode = TWI_I2C_MODE_COMBINED;\r\n} else {\r\niface->writeNum = 1;\r\niface->cur_mode = TWI_I2C_MODE_STANDARDSUB;\r\n}\r\niface->transPtr = &data->byte;\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\nif (read_write == I2C_SMBUS_READ) {\r\niface->readNum = 2;\r\niface->cur_mode = TWI_I2C_MODE_COMBINED;\r\n} else {\r\niface->writeNum = 2;\r\niface->cur_mode = TWI_I2C_MODE_STANDARDSUB;\r\n}\r\niface->transPtr = (u8 *)&data->word;\r\nbreak;\r\ncase I2C_SMBUS_PROC_CALL:\r\niface->writeNum = 2;\r\niface->readNum = 2;\r\niface->cur_mode = TWI_I2C_MODE_COMBINED;\r\niface->transPtr = (u8 *)&data->word;\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\nif (read_write == I2C_SMBUS_READ) {\r\niface->readNum = 0;\r\niface->cur_mode = TWI_I2C_MODE_COMBINED;\r\n} else {\r\niface->writeNum = data->block[0] + 1;\r\niface->cur_mode = TWI_I2C_MODE_STANDARDSUB;\r\n}\r\niface->transPtr = data->block;\r\nbreak;\r\ncase I2C_SMBUS_I2C_BLOCK_DATA:\r\nif (read_write == I2C_SMBUS_READ) {\r\niface->readNum = data->block[0];\r\niface->cur_mode = TWI_I2C_MODE_COMBINED;\r\n} else {\r\niface->writeNum = data->block[0];\r\niface->cur_mode = TWI_I2C_MODE_STANDARDSUB;\r\n}\r\niface->transPtr = (u8 *)&data->block[1];\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\niface->result = 0;\r\niface->manual_stop = 0;\r\niface->read_write = read_write;\r\niface->command = command;\r\ninit_completion(&(iface->complete));\r\nwrite_FIFO_CTL(iface, 0x3);\r\nSSYNC();\r\nwrite_FIFO_CTL(iface, 0);\r\nwrite_INT_STAT(iface, MERR | MCOMP | XMTSERV | RCVSERV);\r\nwrite_MASTER_ADDR(iface, addr);\r\nSSYNC();\r\nswitch (iface->cur_mode) {\r\ncase TWI_I2C_MODE_STANDARDSUB:\r\nwrite_XMT_DATA8(iface, iface->command);\r\nwrite_INT_MASK(iface, MCOMP | MERR |\r\n((iface->read_write == I2C_SMBUS_READ) ?\r\nRCVSERV : XMTSERV));\r\nSSYNC();\r\nif (iface->writeNum + 1 <= 255)\r\nwrite_MASTER_CTL(iface, (iface->writeNum + 1) << 6);\r\nelse {\r\nwrite_MASTER_CTL(iface, 0xff << 6);\r\niface->manual_stop = 1;\r\n}\r\nwrite_MASTER_CTL(iface, read_MASTER_CTL(iface) | MEN |\r\n((CONFIG_I2C_BLACKFIN_TWI_CLK_KHZ>100) ? FAST : 0));\r\nbreak;\r\ncase TWI_I2C_MODE_COMBINED:\r\nwrite_XMT_DATA8(iface, iface->command);\r\nwrite_INT_MASK(iface, MCOMP | MERR | RCVSERV | XMTSERV);\r\nSSYNC();\r\nif (iface->writeNum > 0)\r\nwrite_MASTER_CTL(iface, (iface->writeNum + 1) << 6);\r\nelse\r\nwrite_MASTER_CTL(iface, 0x1 << 6);\r\nwrite_MASTER_CTL(iface, read_MASTER_CTL(iface) | MEN |\r\n((CONFIG_I2C_BLACKFIN_TWI_CLK_KHZ>100) ? FAST : 0));\r\nbreak;\r\ndefault:\r\nwrite_MASTER_CTL(iface, 0);\r\nif (size != I2C_SMBUS_QUICK) {\r\nif (iface->read_write != I2C_SMBUS_READ) {\r\nif (iface->writeNum > 0) {\r\nwrite_XMT_DATA8(iface,\r\n*(iface->transPtr++));\r\nif (iface->writeNum <= 255)\r\nwrite_MASTER_CTL(iface,\r\niface->writeNum << 6);\r\nelse {\r\nwrite_MASTER_CTL(iface,\r\n0xff << 6);\r\niface->manual_stop = 1;\r\n}\r\niface->writeNum--;\r\n} else {\r\nwrite_XMT_DATA8(iface, iface->command);\r\nwrite_MASTER_CTL(iface, 1 << 6);\r\n}\r\n} else {\r\nif (iface->readNum > 0 && iface->readNum <= 255)\r\nwrite_MASTER_CTL(iface,\r\niface->readNum << 6);\r\nelse if (iface->readNum > 255) {\r\nwrite_MASTER_CTL(iface, 0xff << 6);\r\niface->manual_stop = 1;\r\n} else\r\nbreak;\r\n}\r\n}\r\nwrite_INT_MASK(iface, MCOMP | MERR |\r\n((iface->read_write == I2C_SMBUS_READ) ?\r\nRCVSERV : XMTSERV));\r\nSSYNC();\r\nwrite_MASTER_CTL(iface, read_MASTER_CTL(iface) | MEN |\r\n((iface->read_write == I2C_SMBUS_READ) ? MDIR : 0) |\r\n((CONFIG_I2C_BLACKFIN_TWI_CLK_KHZ > 100) ? FAST : 0));\r\nbreak;\r\n}\r\nSSYNC();\r\nwhile (!iface->result) {\r\nif (!wait_for_completion_timeout(&iface->complete,\r\nadap->timeout)) {\r\niface->result = -1;\r\ndev_err(&adap->dev, "smbus transfer timeout\n");\r\n}\r\n}\r\nrc = (iface->result >= 0) ? 0 : -1;\r\nreturn rc;\r\n}\r\nint bfin_twi_smbus_xfer(struct i2c_adapter *adap, u16 addr,\r\nunsigned short flags, char read_write,\r\nu8 command, int size, union i2c_smbus_data *data)\r\n{\r\nreturn bfin_twi_do_smbus_xfer(adap, addr, flags,\r\nread_write, command, size, data);\r\n}\r\nstatic u32 bfin_twi_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\r\nI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\r\nI2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_SMBUS_PROC_CALL |\r\nI2C_FUNC_I2C | I2C_FUNC_SMBUS_I2C_BLOCK;\r\n}\r\nstatic int i2c_bfin_twi_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct bfin_twi_iface *iface = platform_get_drvdata(pdev);\r\niface->saved_clkdiv = read_CLKDIV(iface);\r\niface->saved_control = read_CONTROL(iface);\r\nfree_irq(iface->irq, iface);\r\nwrite_CONTROL(iface, iface->saved_control & ~TWI_ENA);\r\nreturn 0;\r\n}\r\nstatic int i2c_bfin_twi_resume(struct platform_device *pdev)\r\n{\r\nstruct bfin_twi_iface *iface = platform_get_drvdata(pdev);\r\nint rc = request_irq(iface->irq, bfin_twi_interrupt_entry,\r\n0, pdev->name, iface);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Can't get IRQ %d !\n", iface->irq);\r\nreturn -ENODEV;\r\n}\r\nwrite_CLKDIV(iface, iface->saved_clkdiv);\r\nwrite_CONTROL(iface, iface->saved_control);\r\nreturn 0;\r\n}\r\nstatic int i2c_bfin_twi_probe(struct platform_device *pdev)\r\n{\r\nstruct bfin_twi_iface *iface;\r\nstruct i2c_adapter *p_adap;\r\nstruct resource *res;\r\nint rc;\r\nunsigned int clkhilow;\r\niface = kzalloc(sizeof(struct bfin_twi_iface), GFP_KERNEL);\r\nif (!iface) {\r\ndev_err(&pdev->dev, "Cannot allocate memory\n");\r\nrc = -ENOMEM;\r\ngoto out_error_nomem;\r\n}\r\nspin_lock_init(&(iface->lock));\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "Cannot get IORESOURCE_MEM\n");\r\nrc = -ENOENT;\r\ngoto out_error_get_res;\r\n}\r\niface->regs_base = ioremap(res->start, resource_size(res));\r\nif (iface->regs_base == NULL) {\r\ndev_err(&pdev->dev, "Cannot map IO\n");\r\nrc = -ENXIO;\r\ngoto out_error_ioremap;\r\n}\r\niface->irq = platform_get_irq(pdev, 0);\r\nif (iface->irq < 0) {\r\ndev_err(&pdev->dev, "No IRQ specified\n");\r\nrc = -ENOENT;\r\ngoto out_error_no_irq;\r\n}\r\np_adap = &iface->adap;\r\np_adap->nr = pdev->id;\r\nstrlcpy(p_adap->name, pdev->name, sizeof(p_adap->name));\r\np_adap->algo = &bfin_twi_algorithm;\r\np_adap->algo_data = iface;\r\np_adap->class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\r\np_adap->dev.parent = &pdev->dev;\r\np_adap->timeout = 5 * HZ;\r\np_adap->retries = 3;\r\nrc = peripheral_request_list(pin_req[pdev->id], "i2c-bfin-twi");\r\nif (rc) {\r\ndev_err(&pdev->dev, "Can't setup pin mux!\n");\r\ngoto out_error_pin_mux;\r\n}\r\nrc = request_irq(iface->irq, bfin_twi_interrupt_entry,\r\n0, pdev->name, iface);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Can't get IRQ %d !\n", iface->irq);\r\nrc = -ENODEV;\r\ngoto out_error_req_irq;\r\n}\r\nwrite_CONTROL(iface, ((get_sclk() / 1000 / 1000 + 5) / 10) & 0x7F);\r\nclkhilow = ((10 * 1000 / CONFIG_I2C_BLACKFIN_TWI_CLK_KHZ) + 1) / 2;\r\nwrite_CLKDIV(iface, (clkhilow << 8) | clkhilow);\r\nwrite_CONTROL(iface, read_CONTROL(iface) | TWI_ENA);\r\nSSYNC();\r\nrc = i2c_add_numbered_adapter(p_adap);\r\nif (rc < 0) {\r\ndev_err(&pdev->dev, "Can't add i2c adapter!\n");\r\ngoto out_error_add_adapter;\r\n}\r\nplatform_set_drvdata(pdev, iface);\r\ndev_info(&pdev->dev, "Blackfin BF5xx on-chip I2C TWI Contoller, "\r\n"regs_base@%p\n", iface->regs_base);\r\nreturn 0;\r\nout_error_add_adapter:\r\nfree_irq(iface->irq, iface);\r\nout_error_req_irq:\r\nout_error_no_irq:\r\nperipheral_free_list(pin_req[pdev->id]);\r\nout_error_pin_mux:\r\niounmap(iface->regs_base);\r\nout_error_ioremap:\r\nout_error_get_res:\r\nkfree(iface);\r\nout_error_nomem:\r\nreturn rc;\r\n}\r\nstatic int i2c_bfin_twi_remove(struct platform_device *pdev)\r\n{\r\nstruct bfin_twi_iface *iface = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\ni2c_del_adapter(&(iface->adap));\r\nfree_irq(iface->irq, iface);\r\nperipheral_free_list(pin_req[pdev->id]);\r\niounmap(iface->regs_base);\r\nkfree(iface);\r\nreturn 0;\r\n}\r\nstatic int __init i2c_bfin_twi_init(void)\r\n{\r\nreturn platform_driver_register(&i2c_bfin_twi_driver);\r\n}\r\nstatic void __exit i2c_bfin_twi_exit(void)\r\n{\r\nplatform_driver_unregister(&i2c_bfin_twi_driver);\r\n}
