static inline int __query(const struct pci_dev *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int pci_frv_read_config(struct pci_bus *bus, unsigned int devfn, int where, int size,\r\nu32 *val)\r\n{\r\nu32 _value;\r\nif (bus->number == 0 && devfn == PCI_DEVFN(0, 0)) {\r\n_value = __get_PciBridgeDataL(where & ~3);\r\n}\r\nelse {\r\n__set_PciCfgAddr(CONFIG_CMD(bus, devfn, where));\r\n_value = __get_PciCfgDataL(where & ~3);\r\n}\r\nswitch (size) {\r\ncase 1:\r\n_value = _value >> ((where & 3) * 8);\r\nbreak;\r\ncase 2:\r\n_value = _value >> ((where & 2) * 8);\r\nbreak;\r\ncase 4:\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n*val = _value;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int pci_frv_write_config(struct pci_bus *bus, unsigned int devfn, int where, int size,\r\nu32 value)\r\n{\r\nswitch (size) {\r\ncase 1:\r\nif (bus->number == 0 && devfn == PCI_DEVFN(0, 0)) {\r\n__set_PciBridgeDataB(where, value);\r\n}\r\nelse {\r\n__set_PciCfgAddr(CONFIG_CMD(bus, devfn, where));\r\n__set_PciCfgDataB(where, value);\r\n}\r\nbreak;\r\ncase 2:\r\nif (bus->number == 0 && devfn == PCI_DEVFN(0, 0)) {\r\n__set_PciBridgeDataW(where, value);\r\n}\r\nelse {\r\n__set_PciCfgAddr(CONFIG_CMD(bus, devfn, where));\r\n__set_PciCfgDataW(where, value);\r\n}\r\nbreak;\r\ncase 4:\r\nif (bus->number == 0 && devfn == PCI_DEVFN(0, 0)) {\r\n__set_PciBridgeDataL(where, value);\r\n}\r\nelse {\r\n__set_PciCfgAddr(CONFIG_CMD(bus, devfn, where));\r\n__set_PciCfgDataL(where, value);\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int __init pci_sanity_check(struct pci_ops *o)\r\n{\r\nstruct pci_bus bus;\r\nu32 id;\r\nbus.number = 0;\r\nif (o->read(&bus, 0, PCI_VENDOR_ID, 4, &id) == PCIBIOS_SUCCESSFUL) {\r\nprintk("PCI: VDK Bridge device:vendor: %08x\n", id);\r\nif (id == 0x200e10cf)\r\nreturn 1;\r\n}\r\nprintk("PCI: VDK Bridge: Sanity check failed\n");\r\nreturn 0;\r\n}\r\nstatic struct pci_ops * __init pci_check_direct(void)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nif (pci_sanity_check(&pci_direct_frv)) {\r\nlocal_irq_restore(flags);\r\nprintk("PCI: Using configuration frv\n");\r\nreturn &pci_direct_frv;\r\n}\r\nlocal_irq_restore(flags);\r\nreturn NULL;\r\n}\r\nstatic void __init pcibios_fixup_peer_bridges(void)\r\n{\r\nstruct pci_bus bus;\r\nstruct pci_dev dev;\r\nint n;\r\nu16 l;\r\nif (pcibios_last_bus <= 0 || pcibios_last_bus >= 0xff)\r\nreturn;\r\nprintk("PCI: Peer bridge fixup\n");\r\nfor (n=0; n <= pcibios_last_bus; n++) {\r\nif (pci_find_bus(0, n))\r\ncontinue;\r\nbus.number = n;\r\nbus.ops = pci_root_ops;\r\ndev.bus = &bus;\r\nfor(dev.devfn=0; dev.devfn<256; dev.devfn += 8)\r\nif (!pci_read_config_word(&dev, PCI_VENDOR_ID, &l) &&\r\nl != 0x0000 && l != 0xffff) {\r\nprintk("Found device at %02x:%02x [%04x]\n", n, dev.devfn, l);\r\nprintk("PCI: Discovered peer bus %02x\n", n);\r\npci_scan_bus(n, pci_root_ops, NULL);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void __init pci_fixup_umc_ide(struct pci_dev *d)\r\n{\r\nint i;\r\nprintk("PCI: Fixing base address flags for device %s\n", pci_name(d));\r\nfor(i=0; i<4; i++)\r\nd->resource[i].flags |= PCI_BASE_ADDRESS_SPACE_IO;\r\n}\r\nstatic void __init pci_fixup_ide_bases(struct pci_dev *d)\r\n{\r\nint i;\r\nif ((d->class >> 8) != PCI_CLASS_STORAGE_IDE)\r\nreturn;\r\nprintk("PCI: IDE base address fixup for %s\n", pci_name(d));\r\nfor(i=0; i<4; i++) {\r\nstruct resource *r = &d->resource[i];\r\nif ((r->start & ~0x80) == 0x374) {\r\nr->start |= 2;\r\nr->end = r->start;\r\n}\r\n}\r\n}\r\nstatic void __init pci_fixup_ide_trash(struct pci_dev *d)\r\n{\r\nint i;\r\nprintk("PCI: IDE base address trash cleared for %s\n", pci_name(d));\r\nfor(i=0; i<4; i++)\r\nd->resource[i].start = d->resource[i].end = d->resource[i].flags = 0;\r\n}\r\nstatic void __devinit pci_fixup_latency(struct pci_dev *d)\r\n{\r\nDBG("PCI: Setting max latency to 32\n");\r\npcibios_max_latency = 32;\r\n}\r\nvoid __init pcibios_fixup_bus(struct pci_bus *bus)\r\n{\r\n#if 0\r\nprintk("### PCIBIOS_FIXUP_BUS(%d)\n",bus->number);\r\n#endif\r\npci_read_bridge_bases(bus);\r\nif (bus->number == 0) {\r\nstruct list_head *ln;\r\nstruct pci_dev *dev;\r\nfor (ln=bus->devices.next; ln != &bus->devices; ln=ln->next) {\r\ndev = pci_dev_b(ln);\r\nif (dev->devfn == 0) {\r\ndev->resource[0].start = 0;\r\ndev->resource[0].end = 0;\r\n}\r\n}\r\n}\r\n}\r\nint __init pcibios_init(void)\r\n{\r\nstruct pci_ops *dir = NULL;\r\nLIST_HEAD(resources);\r\nif (!mb93090_mb00_detected)\r\nreturn -ENXIO;\r\n__reg_MB86943_sl_ctl |= MB86943_SL_CTL_DRCT_MASTER_SWAP | MB86943_SL_CTL_DRCT_SLAVE_SWAP;\r\n__reg_MB86943_ecs_base(1) = ((__region_CS2 + 0x01000000) >> 9) | 0x08000000;\r\n__reg_MB86943_ecs_base(2) = ((__region_CS2 + 0x00000000) >> 9) | 0x08000000;\r\n*(volatile uint32_t *) (__region_CS1 + 0x848) = 0xe0000000;\r\n*(volatile uint32_t *) (__region_CS1 + 0x8b8) = 0x00000000;\r\n__reg_MB86943_sl_pci_io_base = (__region_CS2 + 0x04000000) >> 9;\r\n__reg_MB86943_sl_pci_mem_base = (__region_CS2 + 0x08000000) >> 9;\r\n__reg_MB86943_pci_sl_io_base = __region_CS2 + 0x04000000;\r\n__reg_MB86943_pci_sl_mem_base = __region_CS2 + 0x08000000;\r\nmb();\r\n__reg_MB86943_pci_arbiter = MB86943_PCIARB_EN;\r\npci_ioport_resource.start = (__reg_MB86943_sl_pci_io_base << 9) & 0xfffffc00;\r\npci_ioport_resource.end = (__reg_MB86943_sl_pci_io_range << 9) | 0x3ff;\r\npci_ioport_resource.end += pci_ioport_resource.start;\r\nprintk("PCI IO window: %08llx-%08llx\n",\r\n(unsigned long long) pci_ioport_resource.start,\r\n(unsigned long long) pci_ioport_resource.end);\r\npci_iomem_resource.start = (__reg_MB86943_sl_pci_mem_base << 9) & 0xfffffc00;\r\npci_iomem_resource.end = (__reg_MB86943_sl_pci_mem_range << 9) | 0x3ff;\r\npci_iomem_resource.end += pci_iomem_resource.start;\r\npci_iomem_resource.start += 0x400;\r\nprintk("PCI MEM window: %08llx-%08llx\n",\r\n(unsigned long long) pci_iomem_resource.start,\r\n(unsigned long long) pci_iomem_resource.end);\r\nprintk("PCI DMA memory: %08lx-%08lx\n",\r\ndma_coherent_mem_start, dma_coherent_mem_end);\r\nif (insert_resource(&iomem_resource, &pci_iomem_resource) < 0)\r\npanic("Unable to insert PCI IOMEM resource\n");\r\nif (insert_resource(&ioport_resource, &pci_ioport_resource) < 0)\r\npanic("Unable to insert PCI IOPORT resource\n");\r\nif (!pci_probe)\r\nreturn -ENXIO;\r\ndir = pci_check_direct();\r\nif (dir)\r\npci_root_ops = dir;\r\nelse {\r\nprintk("PCI: No PCI bus detected\n");\r\nreturn -ENXIO;\r\n}\r\nprintk("PCI: Probing PCI hardware\n");\r\npci_add_resource(&resources, &pci_ioport_resource);\r\npci_add_resource(&resources, &pci_iomem_resource);\r\npci_root_bus = pci_scan_root_bus(NULL, 0, pci_root_ops, NULL,\r\n&resources);\r\npcibios_irq_init();\r\npcibios_fixup_peer_bridges();\r\npcibios_fixup_irqs();\r\npcibios_resource_survey();\r\nreturn 0;\r\n}\r\nchar * __init pcibios_setup(char *str)\r\n{\r\nif (!strcmp(str, "off")) {\r\npci_probe = 0;\r\nreturn NULL;\r\n} else if (!strncmp(str, "lastbus=", 8)) {\r\npcibios_last_bus = simple_strtol(str+8, NULL, 0);\r\nreturn NULL;\r\n}\r\nreturn str;\r\n}\r\nint pcibios_enable_device(struct pci_dev *dev, int mask)\r\n{\r\nint err;\r\nif ((err = pci_enable_resources(dev, mask)) < 0)\r\nreturn err;\r\nif (!dev->msi_enabled)\r\npcibios_enable_irq(dev);\r\nreturn 0;\r\n}
