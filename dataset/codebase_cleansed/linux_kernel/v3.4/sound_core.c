static inline int init_oss_soundcore(void) { return 0; }\r\nstatic inline void cleanup_oss_soundcore(void) { }\r\nstatic char *sound_devnode(struct device *dev, umode_t *mode)\r\n{\r\nif (MAJOR(dev->devt) == SOUND_MAJOR)\r\nreturn NULL;\r\nreturn kasprintf(GFP_KERNEL, "snd/%s", dev_name(dev));\r\n}\r\nstatic int __init init_soundcore(void)\r\n{\r\nint rc;\r\nrc = init_oss_soundcore();\r\nif (rc)\r\nreturn rc;\r\nsound_class = class_create(THIS_MODULE, "sound");\r\nif (IS_ERR(sound_class)) {\r\ncleanup_oss_soundcore();\r\nreturn PTR_ERR(sound_class);\r\n}\r\nsound_class->devnode = sound_devnode;\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_soundcore(void)\r\n{\r\ncleanup_oss_soundcore();\r\nclass_destroy(sound_class);\r\n}\r\nstatic int __sound_insert_unit(struct sound_unit * s, struct sound_unit **list, const struct file_operations *fops, int index, int low, int top)\r\n{\r\nint n=low;\r\nif (index < 0) {\r\nwhile (*list && (*list)->unit_minor<n)\r\nlist=&((*list)->next);\r\nwhile(n<top)\r\n{\r\nif(*list==NULL || (*list)->unit_minor>n)\r\nbreak;\r\nlist=&((*list)->next);\r\nn+=SOUND_STEP;\r\n}\r\nif(n>=top)\r\nreturn -ENOENT;\r\n} else {\r\nn = low+(index*16);\r\nwhile (*list) {\r\nif ((*list)->unit_minor==n)\r\nreturn -EBUSY;\r\nif ((*list)->unit_minor>n)\r\nbreak;\r\nlist=&((*list)->next);\r\n}\r\n}\r\ns->unit_minor=n;\r\ns->unit_fops=fops;\r\ns->next=*list;\r\n*list=s;\r\nreturn n;\r\n}\r\nstatic struct sound_unit *__sound_remove_unit(struct sound_unit **list, int unit)\r\n{\r\nwhile(*list)\r\n{\r\nstruct sound_unit *p=*list;\r\nif(p->unit_minor==unit)\r\n{\r\n*list=p->next;\r\nreturn p;\r\n}\r\nlist=&(p->next);\r\n}\r\nprintk(KERN_ERR "Sound device %d went missing!\n", unit);\r\nreturn NULL;\r\n}\r\nstatic int sound_insert_unit(struct sound_unit **list, const struct file_operations *fops, int index, int low, int top, const char *name, umode_t mode, struct device *dev)\r\n{\r\nstruct sound_unit *s = kmalloc(sizeof(*s), GFP_KERNEL);\r\nint r;\r\nif (!s)\r\nreturn -ENOMEM;\r\nspin_lock(&sound_loader_lock);\r\nretry:\r\nr = __sound_insert_unit(s, list, fops, index, low, top);\r\nspin_unlock(&sound_loader_lock);\r\nif (r < 0)\r\ngoto fail;\r\nelse if (r < SOUND_STEP)\r\nsprintf(s->name, "sound/%s", name);\r\nelse\r\nsprintf(s->name, "sound/%s%d", name, r / SOUND_STEP);\r\nif (!preclaim_oss) {\r\nr = __register_chrdev(SOUND_MAJOR, s->unit_minor, 1, s->name,\r\n&soundcore_fops);\r\nif (r < 0) {\r\nspin_lock(&sound_loader_lock);\r\n__sound_remove_unit(list, s->unit_minor);\r\nif (index < 0) {\r\nlow = s->unit_minor + SOUND_STEP;\r\ngoto retry;\r\n}\r\nspin_unlock(&sound_loader_lock);\r\nreturn -EBUSY;\r\n}\r\n}\r\ndevice_create(sound_class, dev, MKDEV(SOUND_MAJOR, s->unit_minor),\r\nNULL, s->name+6);\r\nreturn s->unit_minor;\r\nfail:\r\nkfree(s);\r\nreturn r;\r\n}\r\nstatic void sound_remove_unit(struct sound_unit **list, int unit)\r\n{\r\nstruct sound_unit *p;\r\nspin_lock(&sound_loader_lock);\r\np = __sound_remove_unit(list, unit);\r\nspin_unlock(&sound_loader_lock);\r\nif (p) {\r\nif (!preclaim_oss)\r\n__unregister_chrdev(SOUND_MAJOR, p->unit_minor, 1,\r\np->name);\r\ndevice_destroy(sound_class, MKDEV(SOUND_MAJOR, p->unit_minor));\r\nkfree(p);\r\n}\r\n}\r\nint register_sound_special_device(const struct file_operations *fops, int unit,\r\nstruct device *dev)\r\n{\r\nconst int chain = unit % SOUND_STEP;\r\nint max_unit = 128 + chain;\r\nconst char *name;\r\nchar _name[16];\r\nswitch (chain) {\r\ncase 0:\r\nname = "mixer";\r\nbreak;\r\ncase 1:\r\nname = "sequencer";\r\nif (unit >= SOUND_STEP)\r\ngoto __unknown;\r\nmax_unit = unit + 1;\r\nbreak;\r\ncase 2:\r\nname = "midi";\r\nbreak;\r\ncase 3:\r\nname = "dsp";\r\nbreak;\r\ncase 4:\r\nname = "audio";\r\nbreak;\r\ncase 5:\r\nname = "dspW";\r\nbreak;\r\ncase 8:\r\nname = "sequencer2";\r\nif (unit >= SOUND_STEP)\r\ngoto __unknown;\r\nmax_unit = unit + 1;\r\nbreak;\r\ncase 9:\r\nname = "dmmidi";\r\nbreak;\r\ncase 10:\r\nname = "dmfm";\r\nbreak;\r\ncase 12:\r\nname = "adsp";\r\nbreak;\r\ncase 13:\r\nname = "amidi";\r\nbreak;\r\ncase 14:\r\nname = "admmidi";\r\nbreak;\r\ndefault:\r\n{\r\n__unknown:\r\nsprintf(_name, "unknown%d", chain);\r\nif (unit >= SOUND_STEP)\r\nstrcat(_name, "-");\r\nname = _name;\r\n}\r\nbreak;\r\n}\r\nreturn sound_insert_unit(&chains[chain], fops, -1, unit, max_unit,\r\nname, S_IRUSR | S_IWUSR, dev);\r\n}\r\nint register_sound_special(const struct file_operations *fops, int unit)\r\n{\r\nreturn register_sound_special_device(fops, unit, NULL);\r\n}\r\nint register_sound_mixer(const struct file_operations *fops, int dev)\r\n{\r\nreturn sound_insert_unit(&chains[0], fops, dev, 0, 128,\r\n"mixer", S_IRUSR | S_IWUSR, NULL);\r\n}\r\nint register_sound_midi(const struct file_operations *fops, int dev)\r\n{\r\nreturn sound_insert_unit(&chains[2], fops, dev, 2, 130,\r\n"midi", S_IRUSR | S_IWUSR, NULL);\r\n}\r\nint register_sound_dsp(const struct file_operations *fops, int dev)\r\n{\r\nreturn sound_insert_unit(&chains[3], fops, dev, 3, 131,\r\n"dsp", S_IWUSR | S_IRUSR, NULL);\r\n}\r\nvoid unregister_sound_special(int unit)\r\n{\r\nsound_remove_unit(&chains[unit % SOUND_STEP], unit);\r\n}\r\nvoid unregister_sound_mixer(int unit)\r\n{\r\nsound_remove_unit(&chains[0], unit);\r\n}\r\nvoid unregister_sound_midi(int unit)\r\n{\r\nsound_remove_unit(&chains[2], unit);\r\n}\r\nvoid unregister_sound_dsp(int unit)\r\n{\r\nsound_remove_unit(&chains[3], unit);\r\n}\r\nstatic struct sound_unit *__look_for_unit(int chain, int unit)\r\n{\r\nstruct sound_unit *s;\r\ns=chains[chain];\r\nwhile(s && s->unit_minor <= unit)\r\n{\r\nif(s->unit_minor==unit)\r\nreturn s;\r\ns=s->next;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int soundcore_open(struct inode *inode, struct file *file)\r\n{\r\nint chain;\r\nint unit = iminor(inode);\r\nstruct sound_unit *s;\r\nconst struct file_operations *new_fops = NULL;\r\nchain=unit&0x0F;\r\nif(chain==4 || chain==5)\r\n{\r\nunit&=0xF0;\r\nunit|=3;\r\nchain=3;\r\n}\r\nspin_lock(&sound_loader_lock);\r\ns = __look_for_unit(chain, unit);\r\nif (s)\r\nnew_fops = fops_get(s->unit_fops);\r\nif (preclaim_oss && !new_fops) {\r\nspin_unlock(&sound_loader_lock);\r\nrequest_module("sound-slot-%i", unit>>4);\r\nrequest_module("sound-service-%i-%i", unit>>4, chain);\r\nif (request_module("char-major-%d-%d", SOUND_MAJOR, unit) > 0)\r\nrequest_module("char-major-%d", SOUND_MAJOR);\r\nspin_lock(&sound_loader_lock);\r\ns = __look_for_unit(chain, unit);\r\nif (s)\r\nnew_fops = fops_get(s->unit_fops);\r\n}\r\nif (new_fops) {\r\nint err = 0;\r\nconst struct file_operations *old_fops = file->f_op;\r\nfile->f_op = new_fops;\r\nspin_unlock(&sound_loader_lock);\r\nif (file->f_op->open)\r\nerr = file->f_op->open(inode,file);\r\nif (err) {\r\nfops_put(file->f_op);\r\nfile->f_op = fops_get(old_fops);\r\n}\r\nfops_put(old_fops);\r\nreturn err;\r\n}\r\nspin_unlock(&sound_loader_lock);\r\nreturn -ENODEV;\r\n}\r\nstatic void cleanup_oss_soundcore(void)\r\n{\r\nunregister_chrdev(SOUND_MAJOR, "sound");\r\n}\r\nstatic int __init init_oss_soundcore(void)\r\n{\r\nif (preclaim_oss &&\r\nregister_chrdev(SOUND_MAJOR, "sound", &soundcore_fops) == -1) {\r\nprintk(KERN_ERR "soundcore: sound device already in use.\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}
