static bool atmel_spi_is_v2(void)\r\n{\r\nreturn !cpu_is_at91rm9200();\r\n}\r\nstatic void cs_activate(struct atmel_spi *as, struct spi_device *spi)\r\n{\r\nstruct atmel_spi_device *asd = spi->controller_state;\r\nunsigned active = spi->mode & SPI_CS_HIGH;\r\nu32 mr;\r\nif (atmel_spi_is_v2()) {\r\nspi_writel(as, CSR0, asd->csr);\r\nspi_writel(as, MR, SPI_BF(PCS, 0x0e) | SPI_BIT(MODFDIS)\r\n| SPI_BIT(MSTR));\r\nmr = spi_readl(as, MR);\r\ngpio_set_value(asd->npcs_pin, active);\r\n} else {\r\nu32 cpol = (spi->mode & SPI_CPOL) ? SPI_BIT(CPOL) : 0;\r\nint i;\r\nu32 csr;\r\nfor (i = 0; i < spi->master->num_chipselect; i++) {\r\ncsr = spi_readl(as, CSR0 + 4 * i);\r\nif ((csr ^ cpol) & SPI_BIT(CPOL))\r\nspi_writel(as, CSR0 + 4 * i,\r\ncsr ^ SPI_BIT(CPOL));\r\n}\r\nmr = spi_readl(as, MR);\r\nmr = SPI_BFINS(PCS, ~(1 << spi->chip_select), mr);\r\nif (spi->chip_select != 0)\r\ngpio_set_value(asd->npcs_pin, active);\r\nspi_writel(as, MR, mr);\r\n}\r\ndev_dbg(&spi->dev, "activate %u%s, mr %08x\n",\r\nasd->npcs_pin, active ? " (high)" : "",\r\nmr);\r\n}\r\nstatic void cs_deactivate(struct atmel_spi *as, struct spi_device *spi)\r\n{\r\nstruct atmel_spi_device *asd = spi->controller_state;\r\nunsigned active = spi->mode & SPI_CS_HIGH;\r\nu32 mr;\r\nmr = spi_readl(as, MR);\r\nif (~SPI_BFEXT(PCS, mr) & (1 << spi->chip_select)) {\r\nmr = SPI_BFINS(PCS, 0xf, mr);\r\nspi_writel(as, MR, mr);\r\n}\r\ndev_dbg(&spi->dev, "DEactivate %u%s, mr %08x\n",\r\nasd->npcs_pin, active ? " (low)" : "",\r\nmr);\r\nif (atmel_spi_is_v2() || spi->chip_select != 0)\r\ngpio_set_value(asd->npcs_pin, !active);\r\n}\r\nstatic inline int atmel_spi_xfer_is_last(struct spi_message *msg,\r\nstruct spi_transfer *xfer)\r\n{\r\nreturn msg->transfers.prev == &xfer->transfer_list;\r\n}\r\nstatic inline int atmel_spi_xfer_can_be_chained(struct spi_transfer *xfer)\r\n{\r\nreturn xfer->delay_usecs == 0 && !xfer->cs_change;\r\n}\r\nstatic void atmel_spi_next_xfer_data(struct spi_master *master,\r\nstruct spi_transfer *xfer,\r\ndma_addr_t *tx_dma,\r\ndma_addr_t *rx_dma,\r\nu32 *plen)\r\n{\r\nstruct atmel_spi *as = spi_master_get_devdata(master);\r\nu32 len = *plen;\r\nif (xfer->rx_buf)\r\n*rx_dma = xfer->rx_dma + xfer->len - *plen;\r\nelse {\r\n*rx_dma = as->buffer_dma;\r\nif (len > BUFFER_SIZE)\r\nlen = BUFFER_SIZE;\r\n}\r\nif (xfer->tx_buf)\r\n*tx_dma = xfer->tx_dma + xfer->len - *plen;\r\nelse {\r\n*tx_dma = as->buffer_dma;\r\nif (len > BUFFER_SIZE)\r\nlen = BUFFER_SIZE;\r\nmemset(as->buffer, 0, len);\r\ndma_sync_single_for_device(&as->pdev->dev,\r\nas->buffer_dma, len, DMA_TO_DEVICE);\r\n}\r\n*plen = len;\r\n}\r\nstatic void atmel_spi_next_xfer(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct atmel_spi *as = spi_master_get_devdata(master);\r\nstruct spi_transfer *xfer;\r\nu32 len, remaining;\r\nu32 ieval;\r\ndma_addr_t tx_dma, rx_dma;\r\nif (!as->current_transfer)\r\nxfer = list_entry(msg->transfers.next,\r\nstruct spi_transfer, transfer_list);\r\nelse if (!as->next_transfer)\r\nxfer = list_entry(as->current_transfer->transfer_list.next,\r\nstruct spi_transfer, transfer_list);\r\nelse\r\nxfer = NULL;\r\nif (xfer) {\r\nspi_writel(as, PTCR, SPI_BIT(RXTDIS) | SPI_BIT(TXTDIS));\r\nlen = xfer->len;\r\natmel_spi_next_xfer_data(master, xfer, &tx_dma, &rx_dma, &len);\r\nremaining = xfer->len - len;\r\nspi_writel(as, RPR, rx_dma);\r\nspi_writel(as, TPR, tx_dma);\r\nif (msg->spi->bits_per_word > 8)\r\nlen >>= 1;\r\nspi_writel(as, RCR, len);\r\nspi_writel(as, TCR, len);\r\ndev_dbg(&msg->spi->dev,\r\n" start xfer %p: len %u tx %p/%08x rx %p/%08x\n",\r\nxfer, xfer->len, xfer->tx_buf, xfer->tx_dma,\r\nxfer->rx_buf, xfer->rx_dma);\r\n} else {\r\nxfer = as->next_transfer;\r\nremaining = as->next_remaining_bytes;\r\n}\r\nas->current_transfer = xfer;\r\nas->current_remaining_bytes = remaining;\r\nif (remaining > 0)\r\nlen = remaining;\r\nelse if (!atmel_spi_xfer_is_last(msg, xfer)\r\n&& atmel_spi_xfer_can_be_chained(xfer)) {\r\nxfer = list_entry(xfer->transfer_list.next,\r\nstruct spi_transfer, transfer_list);\r\nlen = xfer->len;\r\n} else\r\nxfer = NULL;\r\nas->next_transfer = xfer;\r\nif (xfer) {\r\nu32 total;\r\ntotal = len;\r\natmel_spi_next_xfer_data(master, xfer, &tx_dma, &rx_dma, &len);\r\nas->next_remaining_bytes = total - len;\r\nspi_writel(as, RNPR, rx_dma);\r\nspi_writel(as, TNPR, tx_dma);\r\nif (msg->spi->bits_per_word > 8)\r\nlen >>= 1;\r\nspi_writel(as, RNCR, len);\r\nspi_writel(as, TNCR, len);\r\ndev_dbg(&msg->spi->dev,\r\n" next xfer %p: len %u tx %p/%08x rx %p/%08x\n",\r\nxfer, xfer->len, xfer->tx_buf, xfer->tx_dma,\r\nxfer->rx_buf, xfer->rx_dma);\r\nieval = SPI_BIT(ENDRX) | SPI_BIT(OVRES);\r\n} else {\r\nspi_writel(as, RNCR, 0);\r\nspi_writel(as, TNCR, 0);\r\nieval = SPI_BIT(RXBUFF) | SPI_BIT(ENDRX) | SPI_BIT(OVRES);\r\n}\r\nspi_writel(as, IER, ieval);\r\nspi_writel(as, PTCR, SPI_BIT(TXTEN) | SPI_BIT(RXTEN));\r\n}\r\nstatic void atmel_spi_next_message(struct spi_master *master)\r\n{\r\nstruct atmel_spi *as = spi_master_get_devdata(master);\r\nstruct spi_message *msg;\r\nstruct spi_device *spi;\r\nBUG_ON(as->current_transfer);\r\nmsg = list_entry(as->queue.next, struct spi_message, queue);\r\nspi = msg->spi;\r\ndev_dbg(master->dev.parent, "start message %p for %s\n",\r\nmsg, dev_name(&spi->dev));\r\nif (as->stay) {\r\nif (as->stay != spi) {\r\ncs_deactivate(as, as->stay);\r\ncs_activate(as, spi);\r\n}\r\nas->stay = NULL;\r\n} else\r\ncs_activate(as, spi);\r\natmel_spi_next_xfer(master, msg);\r\n}\r\nstatic int\r\natmel_spi_dma_map_xfer(struct atmel_spi *as, struct spi_transfer *xfer)\r\n{\r\nstruct device *dev = &as->pdev->dev;\r\nxfer->tx_dma = xfer->rx_dma = INVALID_DMA_ADDRESS;\r\nif (xfer->tx_buf) {\r\nvoid *nonconst_tx = (void *)xfer->tx_buf;\r\nxfer->tx_dma = dma_map_single(dev,\r\nnonconst_tx, xfer->len,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, xfer->tx_dma))\r\nreturn -ENOMEM;\r\n}\r\nif (xfer->rx_buf) {\r\nxfer->rx_dma = dma_map_single(dev,\r\nxfer->rx_buf, xfer->len,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(dev, xfer->rx_dma)) {\r\nif (xfer->tx_buf)\r\ndma_unmap_single(dev,\r\nxfer->tx_dma, xfer->len,\r\nDMA_TO_DEVICE);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void atmel_spi_dma_unmap_xfer(struct spi_master *master,\r\nstruct spi_transfer *xfer)\r\n{\r\nif (xfer->tx_dma != INVALID_DMA_ADDRESS)\r\ndma_unmap_single(master->dev.parent, xfer->tx_dma,\r\nxfer->len, DMA_TO_DEVICE);\r\nif (xfer->rx_dma != INVALID_DMA_ADDRESS)\r\ndma_unmap_single(master->dev.parent, xfer->rx_dma,\r\nxfer->len, DMA_FROM_DEVICE);\r\n}\r\nstatic void\r\natmel_spi_msg_done(struct spi_master *master, struct atmel_spi *as,\r\nstruct spi_message *msg, int status, int stay)\r\n{\r\nif (!stay || status < 0)\r\ncs_deactivate(as, msg->spi);\r\nelse\r\nas->stay = msg->spi;\r\nlist_del(&msg->queue);\r\nmsg->status = status;\r\ndev_dbg(master->dev.parent,\r\n"xfer complete: %u bytes transferred\n",\r\nmsg->actual_length);\r\nspin_unlock(&as->lock);\r\nmsg->complete(msg->context);\r\nspin_lock(&as->lock);\r\nas->current_transfer = NULL;\r\nas->next_transfer = NULL;\r\nif (list_empty(&as->queue) || as->stopping)\r\nspi_writel(as, PTCR, SPI_BIT(RXTDIS) | SPI_BIT(TXTDIS));\r\nelse\r\natmel_spi_next_message(master);\r\n}\r\nstatic irqreturn_t\r\natmel_spi_interrupt(int irq, void *dev_id)\r\n{\r\nstruct spi_master *master = dev_id;\r\nstruct atmel_spi *as = spi_master_get_devdata(master);\r\nstruct spi_message *msg;\r\nstruct spi_transfer *xfer;\r\nu32 status, pending, imr;\r\nint ret = IRQ_NONE;\r\nspin_lock(&as->lock);\r\nxfer = as->current_transfer;\r\nmsg = list_entry(as->queue.next, struct spi_message, queue);\r\nimr = spi_readl(as, IMR);\r\nstatus = spi_readl(as, SR);\r\npending = status & imr;\r\nif (pending & SPI_BIT(OVRES)) {\r\nint timeout;\r\nret = IRQ_HANDLED;\r\nspi_writel(as, IDR, (SPI_BIT(RXBUFF) | SPI_BIT(ENDRX)\r\n| SPI_BIT(OVRES)));\r\nspi_writel(as, PTCR, SPI_BIT(RXTDIS) | SPI_BIT(TXTDIS));\r\nif (!msg->is_dma_mapped)\r\natmel_spi_dma_unmap_xfer(master, xfer);\r\nif (xfer->delay_usecs)\r\nudelay(xfer->delay_usecs);\r\ndev_warn(master->dev.parent, "overrun (%u/%u remaining)\n",\r\nspi_readl(as, TCR), spi_readl(as, RCR));\r\nspi_writel(as, RNCR, 0);\r\nspi_writel(as, TNCR, 0);\r\nspi_writel(as, RCR, 0);\r\nspi_writel(as, TCR, 0);\r\nfor (timeout = 1000; timeout; timeout--)\r\nif (spi_readl(as, SR) & SPI_BIT(TXEMPTY))\r\nbreak;\r\nif (!timeout)\r\ndev_warn(master->dev.parent,\r\n"timeout waiting for TXEMPTY");\r\nwhile (spi_readl(as, SR) & SPI_BIT(RDRF))\r\nspi_readl(as, RDR);\r\nspi_readl(as, SR);\r\natmel_spi_msg_done(master, as, msg, -EIO, 0);\r\n} else if (pending & (SPI_BIT(RXBUFF) | SPI_BIT(ENDRX))) {\r\nret = IRQ_HANDLED;\r\nspi_writel(as, IDR, pending);\r\nif (as->current_remaining_bytes == 0) {\r\nmsg->actual_length += xfer->len;\r\nif (!msg->is_dma_mapped)\r\natmel_spi_dma_unmap_xfer(master, xfer);\r\nif (xfer->delay_usecs)\r\nudelay(xfer->delay_usecs);\r\nif (atmel_spi_xfer_is_last(msg, xfer)) {\r\natmel_spi_msg_done(master, as, msg, 0,\r\nxfer->cs_change);\r\n} else {\r\nif (xfer->cs_change) {\r\ncs_deactivate(as, msg->spi);\r\nudelay(1);\r\ncs_activate(as, msg->spi);\r\n}\r\natmel_spi_next_xfer(master, msg);\r\n}\r\n} else {\r\natmel_spi_next_xfer(master, msg);\r\n}\r\n}\r\nspin_unlock(&as->lock);\r\nreturn ret;\r\n}\r\nstatic int atmel_spi_setup(struct spi_device *spi)\r\n{\r\nstruct atmel_spi *as;\r\nstruct atmel_spi_device *asd;\r\nu32 scbr, csr;\r\nunsigned int bits = spi->bits_per_word;\r\nunsigned long bus_hz;\r\nunsigned int npcs_pin;\r\nint ret;\r\nas = spi_master_get_devdata(spi->master);\r\nif (as->stopping)\r\nreturn -ESHUTDOWN;\r\nif (spi->chip_select > spi->master->num_chipselect) {\r\ndev_dbg(&spi->dev,\r\n"setup: invalid chipselect %u (%u defined)\n",\r\nspi->chip_select, spi->master->num_chipselect);\r\nreturn -EINVAL;\r\n}\r\nif (bits < 8 || bits > 16) {\r\ndev_dbg(&spi->dev,\r\n"setup: invalid bits_per_word %u (8 to 16)\n",\r\nbits);\r\nreturn -EINVAL;\r\n}\r\nif (!atmel_spi_is_v2()\r\n&& spi->chip_select == 0\r\n&& (spi->mode & SPI_CS_HIGH)) {\r\ndev_dbg(&spi->dev, "setup: can't be active-high\n");\r\nreturn -EINVAL;\r\n}\r\nbus_hz = clk_get_rate(as->clk);\r\nif (!atmel_spi_is_v2())\r\nbus_hz /= 2;\r\nif (spi->max_speed_hz) {\r\nscbr = DIV_ROUND_UP(bus_hz, spi->max_speed_hz);\r\nif (scbr >= (1 << SPI_SCBR_SIZE)) {\r\ndev_dbg(&spi->dev,\r\n"setup: %d Hz too slow, scbr %u; min %ld Hz\n",\r\nspi->max_speed_hz, scbr, bus_hz/255);\r\nreturn -EINVAL;\r\n}\r\n} else\r\nscbr = 0xff;\r\ncsr = SPI_BF(SCBR, scbr) | SPI_BF(BITS, bits - 8);\r\nif (spi->mode & SPI_CPOL)\r\ncsr |= SPI_BIT(CPOL);\r\nif (!(spi->mode & SPI_CPHA))\r\ncsr |= SPI_BIT(NCPHA);\r\ncsr |= SPI_BF(DLYBS, 0);\r\ncsr |= SPI_BF(DLYBCT, 0);\r\nnpcs_pin = (unsigned int)spi->controller_data;\r\nasd = spi->controller_state;\r\nif (!asd) {\r\nasd = kzalloc(sizeof(struct atmel_spi_device), GFP_KERNEL);\r\nif (!asd)\r\nreturn -ENOMEM;\r\nret = gpio_request(npcs_pin, dev_name(&spi->dev));\r\nif (ret) {\r\nkfree(asd);\r\nreturn ret;\r\n}\r\nasd->npcs_pin = npcs_pin;\r\nspi->controller_state = asd;\r\ngpio_direction_output(npcs_pin, !(spi->mode & SPI_CS_HIGH));\r\n} else {\r\nunsigned long flags;\r\nspin_lock_irqsave(&as->lock, flags);\r\nif (as->stay == spi)\r\nas->stay = NULL;\r\ncs_deactivate(as, spi);\r\nspin_unlock_irqrestore(&as->lock, flags);\r\n}\r\nasd->csr = csr;\r\ndev_dbg(&spi->dev,\r\n"setup: %lu Hz bpw %u mode 0x%x -> csr%d %08x\n",\r\nbus_hz / scbr, bits, spi->mode, spi->chip_select, csr);\r\nif (!atmel_spi_is_v2())\r\nspi_writel(as, CSR0 + 4 * spi->chip_select, csr);\r\nreturn 0;\r\n}\r\nstatic int atmel_spi_transfer(struct spi_device *spi, struct spi_message *msg)\r\n{\r\nstruct atmel_spi *as;\r\nstruct spi_transfer *xfer;\r\nunsigned long flags;\r\nstruct device *controller = spi->master->dev.parent;\r\nu8 bits;\r\nstruct atmel_spi_device *asd;\r\nas = spi_master_get_devdata(spi->master);\r\ndev_dbg(controller, "new message %p submitted for %s\n",\r\nmsg, dev_name(&spi->dev));\r\nif (unlikely(list_empty(&msg->transfers)))\r\nreturn -EINVAL;\r\nif (as->stopping)\r\nreturn -ESHUTDOWN;\r\nlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\r\nif (!(xfer->tx_buf || xfer->rx_buf) && xfer->len) {\r\ndev_dbg(&spi->dev, "missing rx or tx buf\n");\r\nreturn -EINVAL;\r\n}\r\nif (xfer->bits_per_word) {\r\nasd = spi->controller_state;\r\nbits = (asd->csr >> 4) & 0xf;\r\nif (bits != xfer->bits_per_word - 8) {\r\ndev_dbg(&spi->dev, "you can't yet change "\r\n"bits_per_word in transfers\n");\r\nreturn -ENOPROTOOPT;\r\n}\r\n}\r\nif (xfer->speed_hz) {\r\ndev_dbg(&spi->dev, "no protocol options yet\n");\r\nreturn -ENOPROTOOPT;\r\n}\r\nif (!msg->is_dma_mapped) {\r\nif (atmel_spi_dma_map_xfer(as, xfer) < 0)\r\nreturn -ENOMEM;\r\n}\r\n}\r\n#ifdef VERBOSE\r\nlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\r\ndev_dbg(controller,\r\n" xfer %p: len %u tx %p/%08x rx %p/%08x\n",\r\nxfer, xfer->len,\r\nxfer->tx_buf, xfer->tx_dma,\r\nxfer->rx_buf, xfer->rx_dma);\r\n}\r\n#endif\r\nmsg->status = -EINPROGRESS;\r\nmsg->actual_length = 0;\r\nspin_lock_irqsave(&as->lock, flags);\r\nlist_add_tail(&msg->queue, &as->queue);\r\nif (!as->current_transfer)\r\natmel_spi_next_message(spi->master);\r\nspin_unlock_irqrestore(&as->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void atmel_spi_cleanup(struct spi_device *spi)\r\n{\r\nstruct atmel_spi *as = spi_master_get_devdata(spi->master);\r\nstruct atmel_spi_device *asd = spi->controller_state;\r\nunsigned gpio = (unsigned) spi->controller_data;\r\nunsigned long flags;\r\nif (!asd)\r\nreturn;\r\nspin_lock_irqsave(&as->lock, flags);\r\nif (as->stay == spi) {\r\nas->stay = NULL;\r\ncs_deactivate(as, spi);\r\n}\r\nspin_unlock_irqrestore(&as->lock, flags);\r\nspi->controller_state = NULL;\r\ngpio_free(gpio);\r\nkfree(asd);\r\n}\r\nstatic int __devinit atmel_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *regs;\r\nint irq;\r\nstruct clk *clk;\r\nint ret;\r\nstruct spi_master *master;\r\nstruct atmel_spi *as;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!regs)\r\nreturn -ENXIO;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nclk = clk_get(&pdev->dev, "spi_clk");\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nret = -ENOMEM;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof *as);\r\nif (!master)\r\ngoto out_free;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\r\nmaster->bus_num = pdev->id;\r\nmaster->num_chipselect = 4;\r\nmaster->setup = atmel_spi_setup;\r\nmaster->transfer = atmel_spi_transfer;\r\nmaster->cleanup = atmel_spi_cleanup;\r\nplatform_set_drvdata(pdev, master);\r\nas = spi_master_get_devdata(master);\r\nas->buffer = dma_alloc_coherent(&pdev->dev, BUFFER_SIZE,\r\n&as->buffer_dma, GFP_KERNEL);\r\nif (!as->buffer)\r\ngoto out_free;\r\nspin_lock_init(&as->lock);\r\nINIT_LIST_HEAD(&as->queue);\r\nas->pdev = pdev;\r\nas->regs = ioremap(regs->start, resource_size(regs));\r\nif (!as->regs)\r\ngoto out_free_buffer;\r\nas->irq = irq;\r\nas->clk = clk;\r\nret = request_irq(irq, atmel_spi_interrupt, 0,\r\ndev_name(&pdev->dev), master);\r\nif (ret)\r\ngoto out_unmap_regs;\r\nclk_enable(clk);\r\nspi_writel(as, CR, SPI_BIT(SWRST));\r\nspi_writel(as, CR, SPI_BIT(SWRST));\r\nspi_writel(as, MR, SPI_BIT(MSTR) | SPI_BIT(MODFDIS));\r\nspi_writel(as, PTCR, SPI_BIT(RXTDIS) | SPI_BIT(TXTDIS));\r\nspi_writel(as, CR, SPI_BIT(SPIEN));\r\ndev_info(&pdev->dev, "Atmel SPI Controller at 0x%08lx (irq %d)\n",\r\n(unsigned long)regs->start, irq);\r\nret = spi_register_master(master);\r\nif (ret)\r\ngoto out_reset_hw;\r\nreturn 0;\r\nout_reset_hw:\r\nspi_writel(as, CR, SPI_BIT(SWRST));\r\nspi_writel(as, CR, SPI_BIT(SWRST));\r\nclk_disable(clk);\r\nfree_irq(irq, master);\r\nout_unmap_regs:\r\niounmap(as->regs);\r\nout_free_buffer:\r\ndma_free_coherent(&pdev->dev, BUFFER_SIZE, as->buffer,\r\nas->buffer_dma);\r\nout_free:\r\nclk_put(clk);\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int __devexit atmel_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct atmel_spi *as = spi_master_get_devdata(master);\r\nstruct spi_message *msg;\r\nspin_lock_irq(&as->lock);\r\nas->stopping = 1;\r\nspi_writel(as, CR, SPI_BIT(SWRST));\r\nspi_writel(as, CR, SPI_BIT(SWRST));\r\nspi_readl(as, SR);\r\nspin_unlock_irq(&as->lock);\r\nlist_for_each_entry(msg, &as->queue, queue) {\r\nmsg->status = -ESHUTDOWN;\r\nmsg->complete(msg->context);\r\n}\r\ndma_free_coherent(&pdev->dev, BUFFER_SIZE, as->buffer,\r\nas->buffer_dma);\r\nclk_disable(as->clk);\r\nclk_put(as->clk);\r\nfree_irq(as->irq, master);\r\niounmap(as->regs);\r\nspi_unregister_master(master);\r\nreturn 0;\r\n}\r\nstatic int atmel_spi_suspend(struct platform_device *pdev, pm_message_t mesg)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct atmel_spi *as = spi_master_get_devdata(master);\r\nclk_disable(as->clk);\r\nreturn 0;\r\n}\r\nstatic int atmel_spi_resume(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct atmel_spi *as = spi_master_get_devdata(master);\r\nclk_enable(as->clk);\r\nreturn 0;\r\n}
