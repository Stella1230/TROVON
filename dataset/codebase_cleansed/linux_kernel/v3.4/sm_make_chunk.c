int sctp_chunk_iif(const struct sctp_chunk *chunk)\r\n{\r\nstruct sctp_af *af;\r\nint iif = 0;\r\naf = sctp_get_af_specific(ipver2af(ip_hdr(chunk->skb)->version));\r\nif (af)\r\niif = af->skb_iif(chunk->skb);\r\nreturn iif;\r\n}\r\nvoid sctp_init_cause(struct sctp_chunk *chunk, __be16 cause_code,\r\nsize_t paylen)\r\n{\r\nsctp_errhdr_t err;\r\n__u16 len;\r\nerr.cause = cause_code;\r\nlen = sizeof(sctp_errhdr_t) + paylen;\r\nerr.length = htons(len);\r\nchunk->subh.err_hdr = sctp_addto_chunk(chunk, sizeof(sctp_errhdr_t), &err);\r\n}\r\nint sctp_init_cause_fixed(struct sctp_chunk *chunk, __be16 cause_code,\r\nsize_t paylen)\r\n{\r\nsctp_errhdr_t err;\r\n__u16 len;\r\nerr.cause = cause_code;\r\nlen = sizeof(sctp_errhdr_t) + paylen;\r\nerr.length = htons(len);\r\nif (skb_tailroom(chunk->skb) < len)\r\nreturn -ENOSPC;\r\nchunk->subh.err_hdr = sctp_addto_chunk_fixed(chunk,\r\nsizeof(sctp_errhdr_t),\r\n&err);\r\nreturn 0;\r\n}\r\nstruct sctp_chunk *sctp_make_init(const struct sctp_association *asoc,\r\nconst struct sctp_bind_addr *bp,\r\ngfp_t gfp, int vparam_len)\r\n{\r\nsctp_inithdr_t init;\r\nunion sctp_params addrs;\r\nsize_t chunksize;\r\nstruct sctp_chunk *retval = NULL;\r\nint num_types, addrs_len = 0;\r\nstruct sctp_sock *sp;\r\nsctp_supported_addrs_param_t sat;\r\n__be16 types[2];\r\nsctp_adaptation_ind_param_t aiparam;\r\nsctp_supported_ext_param_t ext_param;\r\nint num_ext = 0;\r\n__u8 extensions[3];\r\nsctp_paramhdr_t *auth_chunks = NULL,\r\n*auth_hmacs = NULL;\r\nretval = NULL;\r\naddrs = sctp_bind_addrs_to_raw(bp, &addrs_len, gfp);\r\ninit.init_tag = htonl(asoc->c.my_vtag);\r\ninit.a_rwnd = htonl(asoc->rwnd);\r\ninit.num_outbound_streams = htons(asoc->c.sinit_num_ostreams);\r\ninit.num_inbound_streams = htons(asoc->c.sinit_max_instreams);\r\ninit.initial_tsn = htonl(asoc->c.initial_tsn);\r\nsp = sctp_sk(asoc->base.sk);\r\nnum_types = sp->pf->supported_addrs(sp, types);\r\nchunksize = sizeof(init) + addrs_len;\r\nchunksize += WORD_ROUND(SCTP_SAT_LEN(num_types));\r\nchunksize += sizeof(ecap_param);\r\nif (sctp_prsctp_enable)\r\nchunksize += sizeof(prsctp_param);\r\nif (sctp_addip_enable) {\r\nextensions[num_ext] = SCTP_CID_ASCONF;\r\nextensions[num_ext+1] = SCTP_CID_ASCONF_ACK;\r\nnum_ext += 2;\r\n}\r\nif (sp->adaptation_ind)\r\nchunksize += sizeof(aiparam);\r\nchunksize += vparam_len;\r\nif (sctp_auth_enable) {\r\nchunksize += sizeof(asoc->c.auth_random);\r\nauth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;\r\nif (auth_hmacs->length)\r\nchunksize += WORD_ROUND(ntohs(auth_hmacs->length));\r\nelse\r\nauth_hmacs = NULL;\r\nauth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;\r\nif (auth_chunks->length)\r\nchunksize += WORD_ROUND(ntohs(auth_chunks->length));\r\nelse\r\nauth_chunks = NULL;\r\nextensions[num_ext] = SCTP_CID_AUTH;\r\nnum_ext += 1;\r\n}\r\nif (num_ext)\r\nchunksize += WORD_ROUND(sizeof(sctp_supported_ext_param_t) +\r\nnum_ext);\r\nretval = sctp_make_chunk(asoc, SCTP_CID_INIT, 0, chunksize);\r\nif (!retval)\r\ngoto nodata;\r\nretval->subh.init_hdr =\r\nsctp_addto_chunk(retval, sizeof(init), &init);\r\nretval->param_hdr.v =\r\nsctp_addto_chunk(retval, addrs_len, addrs.v);\r\nsat.param_hdr.type = SCTP_PARAM_SUPPORTED_ADDRESS_TYPES;\r\nsat.param_hdr.length = htons(SCTP_SAT_LEN(num_types));\r\nsctp_addto_chunk(retval, sizeof(sat), &sat);\r\nsctp_addto_chunk(retval, num_types * sizeof(__u16), &types);\r\nsctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);\r\nif (num_ext) {\r\next_param.param_hdr.type = SCTP_PARAM_SUPPORTED_EXT;\r\next_param.param_hdr.length =\r\nhtons(sizeof(sctp_supported_ext_param_t) + num_ext);\r\nsctp_addto_chunk(retval, sizeof(sctp_supported_ext_param_t),\r\n&ext_param);\r\nsctp_addto_param(retval, num_ext, extensions);\r\n}\r\nif (sctp_prsctp_enable)\r\nsctp_addto_chunk(retval, sizeof(prsctp_param), &prsctp_param);\r\nif (sp->adaptation_ind) {\r\naiparam.param_hdr.type = SCTP_PARAM_ADAPTATION_LAYER_IND;\r\naiparam.param_hdr.length = htons(sizeof(aiparam));\r\naiparam.adaptation_ind = htonl(sp->adaptation_ind);\r\nsctp_addto_chunk(retval, sizeof(aiparam), &aiparam);\r\n}\r\nif (sctp_auth_enable) {\r\nsctp_addto_chunk(retval, sizeof(asoc->c.auth_random),\r\nasoc->c.auth_random);\r\nif (auth_hmacs)\r\nsctp_addto_chunk(retval, ntohs(auth_hmacs->length),\r\nauth_hmacs);\r\nif (auth_chunks)\r\nsctp_addto_chunk(retval, ntohs(auth_chunks->length),\r\nauth_chunks);\r\n}\r\nnodata:\r\nkfree(addrs.v);\r\nreturn retval;\r\n}\r\nstruct sctp_chunk *sctp_make_init_ack(const struct sctp_association *asoc,\r\nconst struct sctp_chunk *chunk,\r\ngfp_t gfp, int unkparam_len)\r\n{\r\nsctp_inithdr_t initack;\r\nstruct sctp_chunk *retval;\r\nunion sctp_params addrs;\r\nstruct sctp_sock *sp;\r\nint addrs_len;\r\nsctp_cookie_param_t *cookie;\r\nint cookie_len;\r\nsize_t chunksize;\r\nsctp_adaptation_ind_param_t aiparam;\r\nsctp_supported_ext_param_t ext_param;\r\nint num_ext = 0;\r\n__u8 extensions[3];\r\nsctp_paramhdr_t *auth_chunks = NULL,\r\n*auth_hmacs = NULL,\r\n*auth_random = NULL;\r\nretval = NULL;\r\naddrs = sctp_bind_addrs_to_raw(&asoc->base.bind_addr, &addrs_len, gfp);\r\ninitack.init_tag = htonl(asoc->c.my_vtag);\r\ninitack.a_rwnd = htonl(asoc->rwnd);\r\ninitack.num_outbound_streams = htons(asoc->c.sinit_num_ostreams);\r\ninitack.num_inbound_streams = htons(asoc->c.sinit_max_instreams);\r\ninitack.initial_tsn = htonl(asoc->c.initial_tsn);\r\ncookie = sctp_pack_cookie(asoc->ep, asoc, chunk, &cookie_len,\r\naddrs.v, addrs_len);\r\nif (!cookie)\r\ngoto nomem_cookie;\r\nsp = sctp_sk(asoc->base.sk);\r\nchunksize = sizeof(initack) + addrs_len + cookie_len + unkparam_len;\r\nif (asoc->peer.ecn_capable)\r\nchunksize += sizeof(ecap_param);\r\nif (asoc->peer.prsctp_capable)\r\nchunksize += sizeof(prsctp_param);\r\nif (asoc->peer.asconf_capable) {\r\nextensions[num_ext] = SCTP_CID_ASCONF;\r\nextensions[num_ext+1] = SCTP_CID_ASCONF_ACK;\r\nnum_ext += 2;\r\n}\r\nif (sp->adaptation_ind)\r\nchunksize += sizeof(aiparam);\r\nif (asoc->peer.auth_capable) {\r\nauth_random = (sctp_paramhdr_t *)asoc->c.auth_random;\r\nchunksize += ntohs(auth_random->length);\r\nauth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;\r\nif (auth_hmacs->length)\r\nchunksize += WORD_ROUND(ntohs(auth_hmacs->length));\r\nelse\r\nauth_hmacs = NULL;\r\nauth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;\r\nif (auth_chunks->length)\r\nchunksize += WORD_ROUND(ntohs(auth_chunks->length));\r\nelse\r\nauth_chunks = NULL;\r\nextensions[num_ext] = SCTP_CID_AUTH;\r\nnum_ext += 1;\r\n}\r\nif (num_ext)\r\nchunksize += WORD_ROUND(sizeof(sctp_supported_ext_param_t) +\r\nnum_ext);\r\nretval = sctp_make_chunk(asoc, SCTP_CID_INIT_ACK, 0, chunksize);\r\nif (!retval)\r\ngoto nomem_chunk;\r\nretval->transport = chunk->transport;\r\nretval->subh.init_hdr =\r\nsctp_addto_chunk(retval, sizeof(initack), &initack);\r\nretval->param_hdr.v = sctp_addto_chunk(retval, addrs_len, addrs.v);\r\nsctp_addto_chunk(retval, cookie_len, cookie);\r\nif (asoc->peer.ecn_capable)\r\nsctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);\r\nif (num_ext) {\r\next_param.param_hdr.type = SCTP_PARAM_SUPPORTED_EXT;\r\next_param.param_hdr.length =\r\nhtons(sizeof(sctp_supported_ext_param_t) + num_ext);\r\nsctp_addto_chunk(retval, sizeof(sctp_supported_ext_param_t),\r\n&ext_param);\r\nsctp_addto_param(retval, num_ext, extensions);\r\n}\r\nif (asoc->peer.prsctp_capable)\r\nsctp_addto_chunk(retval, sizeof(prsctp_param), &prsctp_param);\r\nif (sp->adaptation_ind) {\r\naiparam.param_hdr.type = SCTP_PARAM_ADAPTATION_LAYER_IND;\r\naiparam.param_hdr.length = htons(sizeof(aiparam));\r\naiparam.adaptation_ind = htonl(sp->adaptation_ind);\r\nsctp_addto_chunk(retval, sizeof(aiparam), &aiparam);\r\n}\r\nif (asoc->peer.auth_capable) {\r\nsctp_addto_chunk(retval, ntohs(auth_random->length),\r\nauth_random);\r\nif (auth_hmacs)\r\nsctp_addto_chunk(retval, ntohs(auth_hmacs->length),\r\nauth_hmacs);\r\nif (auth_chunks)\r\nsctp_addto_chunk(retval, ntohs(auth_chunks->length),\r\nauth_chunks);\r\n}\r\nretval->asoc = (struct sctp_association *) asoc;\r\nnomem_chunk:\r\nkfree(cookie);\r\nnomem_cookie:\r\nkfree(addrs.v);\r\nreturn retval;\r\n}\r\nstruct sctp_chunk *sctp_make_cookie_echo(const struct sctp_association *asoc,\r\nconst struct sctp_chunk *chunk)\r\n{\r\nstruct sctp_chunk *retval;\r\nvoid *cookie;\r\nint cookie_len;\r\ncookie = asoc->peer.cookie;\r\ncookie_len = asoc->peer.cookie_len;\r\nretval = sctp_make_chunk(asoc, SCTP_CID_COOKIE_ECHO, 0, cookie_len);\r\nif (!retval)\r\ngoto nodata;\r\nretval->subh.cookie_hdr =\r\nsctp_addto_chunk(retval, cookie_len, cookie);\r\nif (chunk)\r\nretval->transport = chunk->transport;\r\nnodata:\r\nreturn retval;\r\n}\r\nstruct sctp_chunk *sctp_make_cookie_ack(const struct sctp_association *asoc,\r\nconst struct sctp_chunk *chunk)\r\n{\r\nstruct sctp_chunk *retval;\r\nretval = sctp_make_chunk(asoc, SCTP_CID_COOKIE_ACK, 0, 0);\r\nif (retval && chunk)\r\nretval->transport = chunk->transport;\r\nreturn retval;\r\n}\r\nstruct sctp_chunk *sctp_make_cwr(const struct sctp_association *asoc,\r\nconst __u32 lowest_tsn,\r\nconst struct sctp_chunk *chunk)\r\n{\r\nstruct sctp_chunk *retval;\r\nsctp_cwrhdr_t cwr;\r\ncwr.lowest_tsn = htonl(lowest_tsn);\r\nretval = sctp_make_chunk(asoc, SCTP_CID_ECN_CWR, 0,\r\nsizeof(sctp_cwrhdr_t));\r\nif (!retval)\r\ngoto nodata;\r\nretval->subh.ecn_cwr_hdr =\r\nsctp_addto_chunk(retval, sizeof(cwr), &cwr);\r\nif (chunk)\r\nretval->transport = chunk->transport;\r\nnodata:\r\nreturn retval;\r\n}\r\nstruct sctp_chunk *sctp_make_ecne(const struct sctp_association *asoc,\r\nconst __u32 lowest_tsn)\r\n{\r\nstruct sctp_chunk *retval;\r\nsctp_ecnehdr_t ecne;\r\necne.lowest_tsn = htonl(lowest_tsn);\r\nretval = sctp_make_chunk(asoc, SCTP_CID_ECN_ECNE, 0,\r\nsizeof(sctp_ecnehdr_t));\r\nif (!retval)\r\ngoto nodata;\r\nretval->subh.ecne_hdr =\r\nsctp_addto_chunk(retval, sizeof(ecne), &ecne);\r\nnodata:\r\nreturn retval;\r\n}\r\nstruct sctp_chunk *sctp_make_datafrag_empty(struct sctp_association *asoc,\r\nconst struct sctp_sndrcvinfo *sinfo,\r\nint data_len, __u8 flags, __u16 ssn)\r\n{\r\nstruct sctp_chunk *retval;\r\nstruct sctp_datahdr dp;\r\nint chunk_len;\r\ndp.tsn = 0;\r\ndp.stream = htons(sinfo->sinfo_stream);\r\ndp.ppid = sinfo->sinfo_ppid;\r\nif (sinfo->sinfo_flags & SCTP_UNORDERED) {\r\nflags |= SCTP_DATA_UNORDERED;\r\ndp.ssn = 0;\r\n} else\r\ndp.ssn = htons(ssn);\r\nchunk_len = sizeof(dp) + data_len;\r\nretval = sctp_make_chunk(asoc, SCTP_CID_DATA, flags, chunk_len);\r\nif (!retval)\r\ngoto nodata;\r\nretval->subh.data_hdr = sctp_addto_chunk(retval, sizeof(dp), &dp);\r\nmemcpy(&retval->sinfo, sinfo, sizeof(struct sctp_sndrcvinfo));\r\nnodata:\r\nreturn retval;\r\n}\r\nstruct sctp_chunk *sctp_make_sack(const struct sctp_association *asoc)\r\n{\r\nstruct sctp_chunk *retval;\r\nstruct sctp_sackhdr sack;\r\nint len;\r\n__u32 ctsn;\r\n__u16 num_gabs, num_dup_tsns;\r\nstruct sctp_tsnmap *map = (struct sctp_tsnmap *)&asoc->peer.tsn_map;\r\nstruct sctp_gap_ack_block gabs[SCTP_MAX_GABS];\r\nmemset(gabs, 0, sizeof(gabs));\r\nctsn = sctp_tsnmap_get_ctsn(map);\r\nSCTP_DEBUG_PRINTK("sackCTSNAck sent: 0x%x.\n", ctsn);\r\nnum_gabs = sctp_tsnmap_num_gabs(map, gabs);\r\nnum_dup_tsns = sctp_tsnmap_num_dups(map);\r\nsack.cum_tsn_ack = htonl(ctsn);\r\nsack.a_rwnd = htonl(asoc->a_rwnd);\r\nsack.num_gap_ack_blocks = htons(num_gabs);\r\nsack.num_dup_tsns = htons(num_dup_tsns);\r\nlen = sizeof(sack)\r\n+ sizeof(struct sctp_gap_ack_block) * num_gabs\r\n+ sizeof(__u32) * num_dup_tsns;\r\nretval = sctp_make_chunk(asoc, SCTP_CID_SACK, 0, len);\r\nif (!retval)\r\ngoto nodata;\r\nretval->transport = asoc->peer.last_data_from;\r\nretval->subh.sack_hdr =\r\nsctp_addto_chunk(retval, sizeof(sack), &sack);\r\nif (num_gabs)\r\nsctp_addto_chunk(retval, sizeof(__u32) * num_gabs,\r\ngabs);\r\nif (num_dup_tsns)\r\nsctp_addto_chunk(retval, sizeof(__u32) * num_dup_tsns,\r\nsctp_tsnmap_get_dups(map));\r\nnodata:\r\nreturn retval;\r\n}\r\nstruct sctp_chunk *sctp_make_shutdown(const struct sctp_association *asoc,\r\nconst struct sctp_chunk *chunk)\r\n{\r\nstruct sctp_chunk *retval;\r\nsctp_shutdownhdr_t shut;\r\n__u32 ctsn;\r\nctsn = sctp_tsnmap_get_ctsn(&asoc->peer.tsn_map);\r\nshut.cum_tsn_ack = htonl(ctsn);\r\nretval = sctp_make_chunk(asoc, SCTP_CID_SHUTDOWN, 0,\r\nsizeof(sctp_shutdownhdr_t));\r\nif (!retval)\r\ngoto nodata;\r\nretval->subh.shutdown_hdr =\r\nsctp_addto_chunk(retval, sizeof(shut), &shut);\r\nif (chunk)\r\nretval->transport = chunk->transport;\r\nnodata:\r\nreturn retval;\r\n}\r\nstruct sctp_chunk *sctp_make_shutdown_ack(const struct sctp_association *asoc,\r\nconst struct sctp_chunk *chunk)\r\n{\r\nstruct sctp_chunk *retval;\r\nretval = sctp_make_chunk(asoc, SCTP_CID_SHUTDOWN_ACK, 0, 0);\r\nif (retval && chunk)\r\nretval->transport = chunk->transport;\r\nreturn retval;\r\n}\r\nstruct sctp_chunk *sctp_make_shutdown_complete(\r\nconst struct sctp_association *asoc,\r\nconst struct sctp_chunk *chunk)\r\n{\r\nstruct sctp_chunk *retval;\r\n__u8 flags = 0;\r\nflags |= asoc ? 0 : SCTP_CHUNK_FLAG_T;\r\nretval = sctp_make_chunk(asoc, SCTP_CID_SHUTDOWN_COMPLETE, flags, 0);\r\nif (retval && chunk)\r\nretval->transport = chunk->transport;\r\nreturn retval;\r\n}\r\nstruct sctp_chunk *sctp_make_abort(const struct sctp_association *asoc,\r\nconst struct sctp_chunk *chunk,\r\nconst size_t hint)\r\n{\r\nstruct sctp_chunk *retval;\r\n__u8 flags = 0;\r\nif (!asoc) {\r\nif (chunk && chunk->chunk_hdr &&\r\nchunk->chunk_hdr->type == SCTP_CID_INIT)\r\nflags = 0;\r\nelse\r\nflags = SCTP_CHUNK_FLAG_T;\r\n}\r\nretval = sctp_make_chunk(asoc, SCTP_CID_ABORT, flags, hint);\r\nif (retval && chunk)\r\nretval->transport = chunk->transport;\r\nreturn retval;\r\n}\r\nstruct sctp_chunk *sctp_make_abort_no_data(\r\nconst struct sctp_association *asoc,\r\nconst struct sctp_chunk *chunk, __u32 tsn)\r\n{\r\nstruct sctp_chunk *retval;\r\n__be32 payload;\r\nretval = sctp_make_abort(asoc, chunk, sizeof(sctp_errhdr_t)\r\n+ sizeof(tsn));\r\nif (!retval)\r\ngoto no_mem;\r\npayload = htonl(tsn);\r\nsctp_init_cause(retval, SCTP_ERROR_NO_DATA, sizeof(payload));\r\nsctp_addto_chunk(retval, sizeof(payload), (const void *)&payload);\r\nif (chunk)\r\nretval->transport = chunk->transport;\r\nno_mem:\r\nreturn retval;\r\n}\r\nstruct sctp_chunk *sctp_make_abort_user(const struct sctp_association *asoc,\r\nconst struct msghdr *msg,\r\nsize_t paylen)\r\n{\r\nstruct sctp_chunk *retval;\r\nvoid *payload = NULL;\r\nint err;\r\nretval = sctp_make_abort(asoc, NULL, sizeof(sctp_errhdr_t) + paylen);\r\nif (!retval)\r\ngoto err_chunk;\r\nif (paylen) {\r\npayload = kmalloc(paylen, GFP_KERNEL);\r\nif (!payload)\r\ngoto err_payload;\r\nerr = memcpy_fromiovec(payload, msg->msg_iov, paylen);\r\nif (err < 0)\r\ngoto err_copy;\r\n}\r\nsctp_init_cause(retval, SCTP_ERROR_USER_ABORT, paylen);\r\nsctp_addto_chunk(retval, paylen, payload);\r\nif (paylen)\r\nkfree(payload);\r\nreturn retval;\r\nerr_copy:\r\nkfree(payload);\r\nerr_payload:\r\nsctp_chunk_free(retval);\r\nretval = NULL;\r\nerr_chunk:\r\nreturn retval;\r\n}\r\nstatic void *sctp_addto_param(struct sctp_chunk *chunk, int len,\r\nconst void *data)\r\n{\r\nvoid *target;\r\nint chunklen = ntohs(chunk->chunk_hdr->length);\r\ntarget = skb_put(chunk->skb, len);\r\nif (data)\r\nmemcpy(target, data, len);\r\nelse\r\nmemset(target, 0, len);\r\nchunk->chunk_hdr->length = htons(chunklen + len);\r\nchunk->chunk_end = skb_tail_pointer(chunk->skb);\r\nreturn target;\r\n}\r\nstruct sctp_chunk *sctp_make_abort_violation(\r\nconst struct sctp_association *asoc,\r\nconst struct sctp_chunk *chunk,\r\nconst __u8 *payload,\r\nconst size_t paylen)\r\n{\r\nstruct sctp_chunk *retval;\r\nstruct sctp_paramhdr phdr;\r\nretval = sctp_make_abort(asoc, chunk, sizeof(sctp_errhdr_t) + paylen\r\n+ sizeof(sctp_paramhdr_t));\r\nif (!retval)\r\ngoto end;\r\nsctp_init_cause(retval, SCTP_ERROR_PROTO_VIOLATION, paylen\r\n+ sizeof(sctp_paramhdr_t));\r\nphdr.type = htons(chunk->chunk_hdr->type);\r\nphdr.length = chunk->chunk_hdr->length;\r\nsctp_addto_chunk(retval, paylen, payload);\r\nsctp_addto_param(retval, sizeof(sctp_paramhdr_t), &phdr);\r\nend:\r\nreturn retval;\r\n}\r\nstruct sctp_chunk *sctp_make_violation_paramlen(\r\nconst struct sctp_association *asoc,\r\nconst struct sctp_chunk *chunk,\r\nstruct sctp_paramhdr *param)\r\n{\r\nstruct sctp_chunk *retval;\r\nstatic const char error[] = "The following parameter had invalid length:";\r\nsize_t payload_len = sizeof(error) + sizeof(sctp_errhdr_t) +\r\nsizeof(sctp_paramhdr_t);\r\nretval = sctp_make_abort(asoc, chunk, payload_len);\r\nif (!retval)\r\ngoto nodata;\r\nsctp_init_cause(retval, SCTP_ERROR_PROTO_VIOLATION,\r\nsizeof(error) + sizeof(sctp_paramhdr_t));\r\nsctp_addto_chunk(retval, sizeof(error), error);\r\nsctp_addto_param(retval, sizeof(sctp_paramhdr_t), param);\r\nnodata:\r\nreturn retval;\r\n}\r\nstruct sctp_chunk *sctp_make_heartbeat(const struct sctp_association *asoc,\r\nconst struct sctp_transport *transport)\r\n{\r\nstruct sctp_chunk *retval;\r\nsctp_sender_hb_info_t hbinfo;\r\nretval = sctp_make_chunk(asoc, SCTP_CID_HEARTBEAT, 0, sizeof(hbinfo));\r\nif (!retval)\r\ngoto nodata;\r\nhbinfo.param_hdr.type = SCTP_PARAM_HEARTBEAT_INFO;\r\nhbinfo.param_hdr.length = htons(sizeof(sctp_sender_hb_info_t));\r\nhbinfo.daddr = transport->ipaddr;\r\nhbinfo.sent_at = jiffies;\r\nhbinfo.hb_nonce = transport->hb_nonce;\r\nretval->transport = (struct sctp_transport *) transport;\r\nretval->subh.hbs_hdr = sctp_addto_chunk(retval, sizeof(hbinfo),\r\n&hbinfo);\r\nnodata:\r\nreturn retval;\r\n}\r\nstruct sctp_chunk *sctp_make_heartbeat_ack(const struct sctp_association *asoc,\r\nconst struct sctp_chunk *chunk,\r\nconst void *payload, const size_t paylen)\r\n{\r\nstruct sctp_chunk *retval;\r\nretval = sctp_make_chunk(asoc, SCTP_CID_HEARTBEAT_ACK, 0, paylen);\r\nif (!retval)\r\ngoto nodata;\r\nretval->subh.hbs_hdr = sctp_addto_chunk(retval, paylen, payload);\r\nif (chunk)\r\nretval->transport = chunk->transport;\r\nnodata:\r\nreturn retval;\r\n}\r\nstatic struct sctp_chunk *sctp_make_op_error_space(\r\nconst struct sctp_association *asoc,\r\nconst struct sctp_chunk *chunk,\r\nsize_t size)\r\n{\r\nstruct sctp_chunk *retval;\r\nretval = sctp_make_chunk(asoc, SCTP_CID_ERROR, 0,\r\nsizeof(sctp_errhdr_t) + size);\r\nif (!retval)\r\ngoto nodata;\r\nif (chunk)\r\nretval->transport = chunk->transport;\r\nnodata:\r\nreturn retval;\r\n}\r\nstatic inline struct sctp_chunk *sctp_make_op_error_fixed(\r\nconst struct sctp_association *asoc,\r\nconst struct sctp_chunk *chunk)\r\n{\r\nsize_t size = asoc ? asoc->pathmtu : 0;\r\nif (!size)\r\nsize = SCTP_DEFAULT_MAXSEGMENT;\r\nreturn sctp_make_op_error_space(asoc, chunk, size);\r\n}\r\nstruct sctp_chunk *sctp_make_op_error(const struct sctp_association *asoc,\r\nconst struct sctp_chunk *chunk,\r\n__be16 cause_code, const void *payload,\r\nsize_t paylen, size_t reserve_tail)\r\n{\r\nstruct sctp_chunk *retval;\r\nretval = sctp_make_op_error_space(asoc, chunk, paylen + reserve_tail);\r\nif (!retval)\r\ngoto nodata;\r\nsctp_init_cause(retval, cause_code, paylen + reserve_tail);\r\nsctp_addto_chunk(retval, paylen, payload);\r\nif (reserve_tail)\r\nsctp_addto_param(retval, reserve_tail, NULL);\r\nnodata:\r\nreturn retval;\r\n}\r\nstruct sctp_chunk *sctp_make_auth(const struct sctp_association *asoc)\r\n{\r\nstruct sctp_chunk *retval;\r\nstruct sctp_hmac *hmac_desc;\r\nstruct sctp_authhdr auth_hdr;\r\n__u8 *hmac;\r\nhmac_desc = sctp_auth_asoc_get_hmac(asoc);\r\nif (unlikely(!hmac_desc))\r\nreturn NULL;\r\nretval = sctp_make_chunk(asoc, SCTP_CID_AUTH, 0,\r\nhmac_desc->hmac_len + sizeof(sctp_authhdr_t));\r\nif (!retval)\r\nreturn NULL;\r\nauth_hdr.hmac_id = htons(hmac_desc->hmac_id);\r\nauth_hdr.shkey_id = htons(asoc->active_key_id);\r\nretval->subh.auth_hdr = sctp_addto_chunk(retval, sizeof(sctp_authhdr_t),\r\n&auth_hdr);\r\nhmac = skb_put(retval->skb, hmac_desc->hmac_len);\r\nmemset(hmac, 0, hmac_desc->hmac_len);\r\nretval->chunk_hdr->length =\r\nhtons(ntohs(retval->chunk_hdr->length) + hmac_desc->hmac_len);\r\nretval->chunk_end = skb_tail_pointer(retval->skb);\r\nreturn retval;\r\n}\r\nstruct sctp_chunk *sctp_chunkify(struct sk_buff *skb,\r\nconst struct sctp_association *asoc,\r\nstruct sock *sk)\r\n{\r\nstruct sctp_chunk *retval;\r\nretval = kmem_cache_zalloc(sctp_chunk_cachep, GFP_ATOMIC);\r\nif (!retval)\r\ngoto nodata;\r\nif (!sk) {\r\nSCTP_DEBUG_PRINTK("chunkifying skb %p w/o an sk\n", skb);\r\n}\r\nINIT_LIST_HEAD(&retval->list);\r\nretval->skb = skb;\r\nretval->asoc = (struct sctp_association *)asoc;\r\nretval->has_tsn = 0;\r\nretval->has_ssn = 0;\r\nretval->rtt_in_progress = 0;\r\nretval->sent_at = 0;\r\nretval->singleton = 1;\r\nretval->end_of_packet = 0;\r\nretval->ecn_ce_done = 0;\r\nretval->pdiscard = 0;\r\nretval->tsn_missing_report = 0;\r\nretval->tsn_gap_acked = 0;\r\nretval->fast_retransmit = SCTP_CAN_FRTX;\r\nretval->msg = NULL;\r\nINIT_LIST_HEAD(&retval->transmitted_list);\r\nINIT_LIST_HEAD(&retval->frag_list);\r\nSCTP_DBG_OBJCNT_INC(chunk);\r\natomic_set(&retval->refcnt, 1);\r\nnodata:\r\nreturn retval;\r\n}\r\nvoid sctp_init_addrs(struct sctp_chunk *chunk, union sctp_addr *src,\r\nunion sctp_addr *dest)\r\n{\r\nmemcpy(&chunk->source, src, sizeof(union sctp_addr));\r\nmemcpy(&chunk->dest, dest, sizeof(union sctp_addr));\r\n}\r\nconst union sctp_addr *sctp_source(const struct sctp_chunk *chunk)\r\n{\r\nif (chunk->transport) {\r\nreturn &chunk->transport->ipaddr;\r\n} else {\r\nreturn &chunk->source;\r\n}\r\n}\r\nSCTP_STATIC\r\nstruct sctp_chunk *sctp_make_chunk(const struct sctp_association *asoc,\r\n__u8 type, __u8 flags, int paylen)\r\n{\r\nstruct sctp_chunk *retval;\r\nsctp_chunkhdr_t *chunk_hdr;\r\nstruct sk_buff *skb;\r\nstruct sock *sk;\r\nskb = alloc_skb(WORD_ROUND(sizeof(sctp_chunkhdr_t) + paylen),\r\nGFP_ATOMIC);\r\nif (!skb)\r\ngoto nodata;\r\nchunk_hdr = (sctp_chunkhdr_t *)skb_put(skb, sizeof(sctp_chunkhdr_t));\r\nchunk_hdr->type = type;\r\nchunk_hdr->flags = flags;\r\nchunk_hdr->length = htons(sizeof(sctp_chunkhdr_t));\r\nsk = asoc ? asoc->base.sk : NULL;\r\nretval = sctp_chunkify(skb, asoc, sk);\r\nif (!retval) {\r\nkfree_skb(skb);\r\ngoto nodata;\r\n}\r\nretval->chunk_hdr = chunk_hdr;\r\nretval->chunk_end = ((__u8 *)chunk_hdr) + sizeof(struct sctp_chunkhdr);\r\nif (sctp_auth_send_cid(type, asoc))\r\nretval->auth = 1;\r\nskb->sk = sk;\r\nreturn retval;\r\nnodata:\r\nreturn NULL;\r\n}\r\nstatic void sctp_chunk_destroy(struct sctp_chunk *chunk)\r\n{\r\nBUG_ON(!list_empty(&chunk->list));\r\nlist_del_init(&chunk->transmitted_list);\r\ndev_kfree_skb(chunk->skb);\r\nSCTP_DBG_OBJCNT_DEC(chunk);\r\nkmem_cache_free(sctp_chunk_cachep, chunk);\r\n}\r\nvoid sctp_chunk_free(struct sctp_chunk *chunk)\r\n{\r\nif (chunk->msg)\r\nsctp_datamsg_put(chunk->msg);\r\nsctp_chunk_put(chunk);\r\n}\r\nvoid sctp_chunk_hold(struct sctp_chunk *ch)\r\n{\r\natomic_inc(&ch->refcnt);\r\n}\r\nvoid sctp_chunk_put(struct sctp_chunk *ch)\r\n{\r\nif (atomic_dec_and_test(&ch->refcnt))\r\nsctp_chunk_destroy(ch);\r\n}\r\nvoid *sctp_addto_chunk(struct sctp_chunk *chunk, int len, const void *data)\r\n{\r\nvoid *target;\r\nvoid *padding;\r\nint chunklen = ntohs(chunk->chunk_hdr->length);\r\nint padlen = WORD_ROUND(chunklen) - chunklen;\r\npadding = skb_put(chunk->skb, padlen);\r\ntarget = skb_put(chunk->skb, len);\r\nmemset(padding, 0, padlen);\r\nmemcpy(target, data, len);\r\nchunk->chunk_hdr->length = htons(chunklen + padlen + len);\r\nchunk->chunk_end = skb_tail_pointer(chunk->skb);\r\nreturn target;\r\n}\r\nvoid *sctp_addto_chunk_fixed(struct sctp_chunk *chunk,\r\nint len, const void *data)\r\n{\r\nif (skb_tailroom(chunk->skb) >= len)\r\nreturn sctp_addto_chunk(chunk, len, data);\r\nelse\r\nreturn NULL;\r\n}\r\nint sctp_user_addto_chunk(struct sctp_chunk *chunk, int off, int len,\r\nstruct iovec *data)\r\n{\r\n__u8 *target;\r\nint err = 0;\r\ntarget = skb_put(chunk->skb, len);\r\nif ((err = memcpy_fromiovecend(target, data, off, len)))\r\ngoto out;\r\nchunk->chunk_hdr->length =\r\nhtons(ntohs(chunk->chunk_hdr->length) + len);\r\nchunk->chunk_end = skb_tail_pointer(chunk->skb);\r\nout:\r\nreturn err;\r\n}\r\nvoid sctp_chunk_assign_ssn(struct sctp_chunk *chunk)\r\n{\r\nstruct sctp_datamsg *msg;\r\nstruct sctp_chunk *lchunk;\r\nstruct sctp_stream *stream;\r\n__u16 ssn;\r\n__u16 sid;\r\nif (chunk->has_ssn)\r\nreturn;\r\nsid = ntohs(chunk->subh.data_hdr->stream);\r\nstream = &chunk->asoc->ssnmap->out;\r\nmsg = chunk->msg;\r\nlist_for_each_entry(lchunk, &msg->chunks, frag_list) {\r\nif (lchunk->chunk_hdr->flags & SCTP_DATA_UNORDERED) {\r\nssn = 0;\r\n} else {\r\nif (lchunk->chunk_hdr->flags & SCTP_DATA_LAST_FRAG)\r\nssn = sctp_ssn_next(stream, sid);\r\nelse\r\nssn = sctp_ssn_peek(stream, sid);\r\n}\r\nlchunk->subh.data_hdr->ssn = htons(ssn);\r\nlchunk->has_ssn = 1;\r\n}\r\n}\r\nvoid sctp_chunk_assign_tsn(struct sctp_chunk *chunk)\r\n{\r\nif (!chunk->has_tsn) {\r\nchunk->subh.data_hdr->tsn =\r\nhtonl(sctp_association_get_next_tsn(chunk->asoc));\r\nchunk->has_tsn = 1;\r\n}\r\n}\r\nstruct sctp_association *sctp_make_temp_asoc(const struct sctp_endpoint *ep,\r\nstruct sctp_chunk *chunk,\r\ngfp_t gfp)\r\n{\r\nstruct sctp_association *asoc;\r\nstruct sk_buff *skb;\r\nsctp_scope_t scope;\r\nstruct sctp_af *af;\r\nscope = sctp_scope(sctp_source(chunk));\r\nasoc = sctp_association_new(ep, ep->base.sk, scope, gfp);\r\nif (!asoc)\r\ngoto nodata;\r\nasoc->temp = 1;\r\nskb = chunk->skb;\r\naf = sctp_get_af_specific(ipver2af(ip_hdr(skb)->version));\r\nif (unlikely(!af))\r\ngoto fail;\r\naf->from_skb(&asoc->c.peer_addr, skb, 1);\r\nnodata:\r\nreturn asoc;\r\nfail:\r\nsctp_association_free(asoc);\r\nreturn NULL;\r\n}\r\nstatic sctp_cookie_param_t *sctp_pack_cookie(const struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nconst struct sctp_chunk *init_chunk,\r\nint *cookie_len,\r\nconst __u8 *raw_addrs, int addrs_len)\r\n{\r\nsctp_cookie_param_t *retval;\r\nstruct sctp_signed_cookie *cookie;\r\nstruct scatterlist sg;\r\nint headersize, bodysize;\r\nunsigned int keylen;\r\nchar *key;\r\nheadersize = sizeof(sctp_paramhdr_t) +\r\n(sizeof(struct sctp_signed_cookie) -\r\nsizeof(struct sctp_cookie));\r\nbodysize = sizeof(struct sctp_cookie)\r\n+ ntohs(init_chunk->chunk_hdr->length) + addrs_len;\r\nif (bodysize % SCTP_COOKIE_MULTIPLE)\r\nbodysize += SCTP_COOKIE_MULTIPLE\r\n- (bodysize % SCTP_COOKIE_MULTIPLE);\r\n*cookie_len = headersize + bodysize;\r\nretval = kzalloc(*cookie_len, GFP_ATOMIC);\r\nif (!retval)\r\ngoto nodata;\r\ncookie = (struct sctp_signed_cookie *) retval->body;\r\nretval->p.type = SCTP_PARAM_STATE_COOKIE;\r\nretval->p.length = htons(*cookie_len);\r\ncookie->c = asoc->c;\r\ncookie->c.raw_addr_list_len = addrs_len;\r\ncookie->c.prsctp_capable = asoc->peer.prsctp_capable;\r\ncookie->c.adaptation_ind = asoc->peer.adaptation_ind;\r\ndo_gettimeofday(&cookie->c.expiration);\r\nTIMEVAL_ADD(asoc->cookie_life, cookie->c.expiration);\r\nmemcpy(&cookie->c.peer_init[0], init_chunk->chunk_hdr,\r\nntohs(init_chunk->chunk_hdr->length));\r\nmemcpy((__u8 *)&cookie->c.peer_init[0] +\r\nntohs(init_chunk->chunk_hdr->length), raw_addrs, addrs_len);\r\nif (sctp_sk(ep->base.sk)->hmac) {\r\nstruct hash_desc desc;\r\nsg_init_one(&sg, &cookie->c, bodysize);\r\nkeylen = SCTP_SECRET_SIZE;\r\nkey = (char *)ep->secret_key[ep->current_key];\r\ndesc.tfm = sctp_sk(ep->base.sk)->hmac;\r\ndesc.flags = 0;\r\nif (crypto_hash_setkey(desc.tfm, key, keylen) ||\r\ncrypto_hash_digest(&desc, &sg, bodysize, cookie->signature))\r\ngoto free_cookie;\r\n}\r\nreturn retval;\r\nfree_cookie:\r\nkfree(retval);\r\nnodata:\r\n*cookie_len = 0;\r\nreturn NULL;\r\n}\r\nstruct sctp_association *sctp_unpack_cookie(\r\nconst struct sctp_endpoint *ep,\r\nconst struct sctp_association *asoc,\r\nstruct sctp_chunk *chunk, gfp_t gfp,\r\nint *error, struct sctp_chunk **errp)\r\n{\r\nstruct sctp_association *retval = NULL;\r\nstruct sctp_signed_cookie *cookie;\r\nstruct sctp_cookie *bear_cookie;\r\nint headersize, bodysize, fixed_size;\r\n__u8 *digest = ep->digest;\r\nstruct scatterlist sg;\r\nunsigned int keylen, len;\r\nchar *key;\r\nsctp_scope_t scope;\r\nstruct sk_buff *skb = chunk->skb;\r\nstruct timeval tv;\r\nstruct hash_desc desc;\r\nheadersize = sizeof(sctp_chunkhdr_t) +\r\n(sizeof(struct sctp_signed_cookie) -\r\nsizeof(struct sctp_cookie));\r\nbodysize = ntohs(chunk->chunk_hdr->length) - headersize;\r\nfixed_size = headersize + sizeof(struct sctp_cookie);\r\nlen = ntohs(chunk->chunk_hdr->length);\r\nif (len < fixed_size + sizeof(struct sctp_chunkhdr))\r\ngoto malformed;\r\nif (bodysize % SCTP_COOKIE_MULTIPLE)\r\ngoto malformed;\r\ncookie = chunk->subh.cookie_hdr;\r\nbear_cookie = &cookie->c;\r\nif (!sctp_sk(ep->base.sk)->hmac)\r\ngoto no_hmac;\r\nkeylen = SCTP_SECRET_SIZE;\r\nsg_init_one(&sg, bear_cookie, bodysize);\r\nkey = (char *)ep->secret_key[ep->current_key];\r\ndesc.tfm = sctp_sk(ep->base.sk)->hmac;\r\ndesc.flags = 0;\r\nmemset(digest, 0x00, SCTP_SIGNATURE_SIZE);\r\nif (crypto_hash_setkey(desc.tfm, key, keylen) ||\r\ncrypto_hash_digest(&desc, &sg, bodysize, digest)) {\r\n*error = -SCTP_IERROR_NOMEM;\r\ngoto fail;\r\n}\r\nif (memcmp(digest, cookie->signature, SCTP_SIGNATURE_SIZE)) {\r\nkey = (char *)ep->secret_key[ep->last_key];\r\nmemset(digest, 0x00, SCTP_SIGNATURE_SIZE);\r\nif (crypto_hash_setkey(desc.tfm, key, keylen) ||\r\ncrypto_hash_digest(&desc, &sg, bodysize, digest)) {\r\n*error = -SCTP_IERROR_NOMEM;\r\ngoto fail;\r\n}\r\nif (memcmp(digest, cookie->signature, SCTP_SIGNATURE_SIZE)) {\r\n*error = -SCTP_IERROR_BAD_SIG;\r\ngoto fail;\r\n}\r\n}\r\nno_hmac:\r\nif (ntohl(chunk->sctp_hdr->vtag) != bear_cookie->my_vtag) {\r\n*error = -SCTP_IERROR_BAD_TAG;\r\ngoto fail;\r\n}\r\nif (chunk->sctp_hdr->source != bear_cookie->peer_addr.v4.sin_port ||\r\nntohs(chunk->sctp_hdr->dest) != bear_cookie->my_port) {\r\n*error = -SCTP_IERROR_BAD_PORTS;\r\ngoto fail;\r\n}\r\nif (sock_flag(ep->base.sk, SOCK_TIMESTAMP))\r\nskb_get_timestamp(skb, &tv);\r\nelse\r\ndo_gettimeofday(&tv);\r\nif (!asoc && tv_lt(bear_cookie->expiration, tv)) {\r\nlen = ntohs(chunk->chunk_hdr->length);\r\n*errp = sctp_make_op_error_space(asoc, chunk, len);\r\nif (*errp) {\r\nsuseconds_t usecs = (tv.tv_sec -\r\nbear_cookie->expiration.tv_sec) * 1000000L +\r\ntv.tv_usec - bear_cookie->expiration.tv_usec;\r\n__be32 n = htonl(usecs);\r\nsctp_init_cause(*errp, SCTP_ERROR_STALE_COOKIE,\r\nsizeof(n));\r\nsctp_addto_chunk(*errp, sizeof(n), &n);\r\n*error = -SCTP_IERROR_STALE_COOKIE;\r\n} else\r\n*error = -SCTP_IERROR_NOMEM;\r\ngoto fail;\r\n}\r\nscope = sctp_scope(sctp_source(chunk));\r\nretval = sctp_association_new(ep, ep->base.sk, scope, gfp);\r\nif (!retval) {\r\n*error = -SCTP_IERROR_NOMEM;\r\ngoto fail;\r\n}\r\nretval->peer.port = ntohs(chunk->sctp_hdr->source);\r\nmemcpy(&retval->c, bear_cookie, sizeof(*bear_cookie));\r\nif (sctp_assoc_set_bind_addr_from_cookie(retval, bear_cookie,\r\nGFP_ATOMIC) < 0) {\r\n*error = -SCTP_IERROR_NOMEM;\r\ngoto fail;\r\n}\r\nif (list_empty(&retval->base.bind_addr.address_list)) {\r\nsctp_add_bind_addr(&retval->base.bind_addr, &chunk->dest,\r\nSCTP_ADDR_SRC, GFP_ATOMIC);\r\n}\r\nretval->next_tsn = retval->c.initial_tsn;\r\nretval->ctsn_ack_point = retval->next_tsn - 1;\r\nretval->addip_serial = retval->c.initial_tsn;\r\nretval->adv_peer_ack_point = retval->ctsn_ack_point;\r\nretval->peer.prsctp_capable = retval->c.prsctp_capable;\r\nretval->peer.adaptation_ind = retval->c.adaptation_ind;\r\nreturn retval;\r\nfail:\r\nif (retval)\r\nsctp_association_free(retval);\r\nreturn NULL;\r\nmalformed:\r\n*error = -SCTP_IERROR_MALFORMED;\r\ngoto fail;\r\n}\r\nstatic int sctp_process_missing_param(const struct sctp_association *asoc,\r\nsctp_param_t paramtype,\r\nstruct sctp_chunk *chunk,\r\nstruct sctp_chunk **errp)\r\n{\r\nstruct __sctp_missing report;\r\n__u16 len;\r\nlen = WORD_ROUND(sizeof(report));\r\nif (!*errp)\r\n*errp = sctp_make_op_error_space(asoc, chunk, len);\r\nif (*errp) {\r\nreport.num_missing = htonl(1);\r\nreport.type = paramtype;\r\nsctp_init_cause(*errp, SCTP_ERROR_MISS_PARAM,\r\nsizeof(report));\r\nsctp_addto_chunk(*errp, sizeof(report), &report);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sctp_process_inv_mandatory(const struct sctp_association *asoc,\r\nstruct sctp_chunk *chunk,\r\nstruct sctp_chunk **errp)\r\n{\r\nif (!*errp)\r\n*errp = sctp_make_op_error_space(asoc, chunk, 0);\r\nif (*errp)\r\nsctp_init_cause(*errp, SCTP_ERROR_INV_PARAM, 0);\r\nreturn 0;\r\n}\r\nstatic int sctp_process_inv_paramlength(const struct sctp_association *asoc,\r\nstruct sctp_paramhdr *param,\r\nconst struct sctp_chunk *chunk,\r\nstruct sctp_chunk **errp)\r\n{\r\nif (*errp)\r\nsctp_chunk_free(*errp);\r\n*errp = sctp_make_violation_paramlen(asoc, chunk, param);\r\nreturn 0;\r\n}\r\nstatic int sctp_process_hn_param(const struct sctp_association *asoc,\r\nunion sctp_params param,\r\nstruct sctp_chunk *chunk,\r\nstruct sctp_chunk **errp)\r\n{\r\n__u16 len = ntohs(param.p->length);\r\nif (*errp)\r\nsctp_chunk_free(*errp);\r\n*errp = sctp_make_op_error_space(asoc, chunk, len);\r\nif (*errp) {\r\nsctp_init_cause(*errp, SCTP_ERROR_DNS_FAILED, len);\r\nsctp_addto_chunk(*errp, len, param.v);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sctp_verify_ext_param(union sctp_params param)\r\n{\r\n__u16 num_ext = ntohs(param.p->length) - sizeof(sctp_paramhdr_t);\r\nint have_auth = 0;\r\nint have_asconf = 0;\r\nint i;\r\nfor (i = 0; i < num_ext; i++) {\r\nswitch (param.ext->chunks[i]) {\r\ncase SCTP_CID_AUTH:\r\nhave_auth = 1;\r\nbreak;\r\ncase SCTP_CID_ASCONF:\r\ncase SCTP_CID_ASCONF_ACK:\r\nhave_asconf = 1;\r\nbreak;\r\n}\r\n}\r\nif (sctp_addip_noauth)\r\nreturn 1;\r\nif (sctp_addip_enable && !have_auth && have_asconf)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void sctp_process_ext_param(struct sctp_association *asoc,\r\nunion sctp_params param)\r\n{\r\n__u16 num_ext = ntohs(param.p->length) - sizeof(sctp_paramhdr_t);\r\nint i;\r\nfor (i = 0; i < num_ext; i++) {\r\nswitch (param.ext->chunks[i]) {\r\ncase SCTP_CID_FWD_TSN:\r\nif (sctp_prsctp_enable &&\r\n!asoc->peer.prsctp_capable)\r\nasoc->peer.prsctp_capable = 1;\r\nbreak;\r\ncase SCTP_CID_AUTH:\r\nif (sctp_auth_enable)\r\nasoc->peer.auth_capable = 1;\r\nbreak;\r\ncase SCTP_CID_ASCONF:\r\ncase SCTP_CID_ASCONF_ACK:\r\nif (sctp_addip_enable)\r\nasoc->peer.asconf_capable = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic sctp_ierror_t sctp_process_unk_param(const struct sctp_association *asoc,\r\nunion sctp_params param,\r\nstruct sctp_chunk *chunk,\r\nstruct sctp_chunk **errp)\r\n{\r\nint retval = SCTP_IERROR_NO_ERROR;\r\nswitch (param.p->type & SCTP_PARAM_ACTION_MASK) {\r\ncase SCTP_PARAM_ACTION_DISCARD:\r\nretval = SCTP_IERROR_ERROR;\r\nbreak;\r\ncase SCTP_PARAM_ACTION_SKIP:\r\nbreak;\r\ncase SCTP_PARAM_ACTION_DISCARD_ERR:\r\nretval = SCTP_IERROR_ERROR;\r\ncase SCTP_PARAM_ACTION_SKIP_ERR:\r\nif (NULL == *errp)\r\n*errp = sctp_make_op_error_fixed(asoc, chunk);\r\nif (*errp) {\r\nif (!sctp_init_cause_fixed(*errp, SCTP_ERROR_UNKNOWN_PARAM,\r\nWORD_ROUND(ntohs(param.p->length))))\r\nsctp_addto_chunk_fixed(*errp,\r\nWORD_ROUND(ntohs(param.p->length)),\r\nparam.v);\r\n} else {\r\nretval = SCTP_IERROR_NOMEM;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstatic sctp_ierror_t sctp_verify_param(const struct sctp_association *asoc,\r\nunion sctp_params param,\r\nsctp_cid_t cid,\r\nstruct sctp_chunk *chunk,\r\nstruct sctp_chunk **err_chunk)\r\n{\r\nstruct sctp_hmac_algo_param *hmacs;\r\nint retval = SCTP_IERROR_NO_ERROR;\r\n__u16 n_elt, id = 0;\r\nint i;\r\nswitch (param.p->type) {\r\ncase SCTP_PARAM_IPV4_ADDRESS:\r\ncase SCTP_PARAM_IPV6_ADDRESS:\r\ncase SCTP_PARAM_COOKIE_PRESERVATIVE:\r\ncase SCTP_PARAM_SUPPORTED_ADDRESS_TYPES:\r\ncase SCTP_PARAM_STATE_COOKIE:\r\ncase SCTP_PARAM_HEARTBEAT_INFO:\r\ncase SCTP_PARAM_UNRECOGNIZED_PARAMETERS:\r\ncase SCTP_PARAM_ECN_CAPABLE:\r\ncase SCTP_PARAM_ADAPTATION_LAYER_IND:\r\nbreak;\r\ncase SCTP_PARAM_SUPPORTED_EXT:\r\nif (!sctp_verify_ext_param(param))\r\nreturn SCTP_IERROR_ABORT;\r\nbreak;\r\ncase SCTP_PARAM_SET_PRIMARY:\r\nif (sctp_addip_enable)\r\nbreak;\r\ngoto fallthrough;\r\ncase SCTP_PARAM_HOST_NAME_ADDRESS:\r\nsctp_process_hn_param(asoc, param, chunk, err_chunk);\r\nretval = SCTP_IERROR_ABORT;\r\nbreak;\r\ncase SCTP_PARAM_FWD_TSN_SUPPORT:\r\nif (sctp_prsctp_enable)\r\nbreak;\r\ngoto fallthrough;\r\ncase SCTP_PARAM_RANDOM:\r\nif (!sctp_auth_enable)\r\ngoto fallthrough;\r\nif (SCTP_AUTH_RANDOM_LENGTH !=\r\nntohs(param.p->length) - sizeof(sctp_paramhdr_t)) {\r\nsctp_process_inv_paramlength(asoc, param.p,\r\nchunk, err_chunk);\r\nretval = SCTP_IERROR_ABORT;\r\n}\r\nbreak;\r\ncase SCTP_PARAM_CHUNKS:\r\nif (!sctp_auth_enable)\r\ngoto fallthrough;\r\nif (260 < ntohs(param.p->length)) {\r\nsctp_process_inv_paramlength(asoc, param.p,\r\nchunk, err_chunk);\r\nretval = SCTP_IERROR_ABORT;\r\n}\r\nbreak;\r\ncase SCTP_PARAM_HMAC_ALGO:\r\nif (!sctp_auth_enable)\r\ngoto fallthrough;\r\nhmacs = (struct sctp_hmac_algo_param *)param.p;\r\nn_elt = (ntohs(param.p->length) - sizeof(sctp_paramhdr_t)) >> 1;\r\nfor (i = 0; i < n_elt; i++) {\r\nid = ntohs(hmacs->hmac_ids[i]);\r\nif (id == SCTP_AUTH_HMAC_ID_SHA1)\r\nbreak;\r\n}\r\nif (id != SCTP_AUTH_HMAC_ID_SHA1) {\r\nsctp_process_inv_paramlength(asoc, param.p, chunk,\r\nerr_chunk);\r\nretval = SCTP_IERROR_ABORT;\r\n}\r\nbreak;\r\nfallthrough:\r\ndefault:\r\nSCTP_DEBUG_PRINTK("Unrecognized param: %d for chunk %d.\n",\r\nntohs(param.p->type), cid);\r\nretval = sctp_process_unk_param(asoc, param, chunk, err_chunk);\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nint sctp_verify_init(const struct sctp_association *asoc,\r\nsctp_cid_t cid,\r\nsctp_init_chunk_t *peer_init,\r\nstruct sctp_chunk *chunk,\r\nstruct sctp_chunk **errp)\r\n{\r\nunion sctp_params param;\r\nint has_cookie = 0;\r\nint result;\r\nif ((0 == peer_init->init_hdr.num_outbound_streams) ||\r\n(0 == peer_init->init_hdr.num_inbound_streams) ||\r\n(0 == peer_init->init_hdr.init_tag) ||\r\n(SCTP_DEFAULT_MINWINDOW > ntohl(peer_init->init_hdr.a_rwnd))) {\r\nreturn sctp_process_inv_mandatory(asoc, chunk, errp);\r\n}\r\nsctp_walk_params(param, peer_init, init_hdr.params) {\r\nif (SCTP_PARAM_STATE_COOKIE == param.p->type)\r\nhas_cookie = 1;\r\n}\r\nif (param.v != (void*)chunk->chunk_end)\r\nreturn sctp_process_inv_paramlength(asoc, param.p, chunk, errp);\r\nif ((SCTP_CID_INIT_ACK == cid) && !has_cookie)\r\nreturn sctp_process_missing_param(asoc, SCTP_PARAM_STATE_COOKIE,\r\nchunk, errp);\r\nsctp_walk_params(param, peer_init, init_hdr.params) {\r\nresult = sctp_verify_param(asoc, param, cid, chunk, errp);\r\nswitch (result) {\r\ncase SCTP_IERROR_ABORT:\r\ncase SCTP_IERROR_NOMEM:\r\nreturn 0;\r\ncase SCTP_IERROR_ERROR:\r\nreturn 1;\r\ncase SCTP_IERROR_NO_ERROR:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nint sctp_process_init(struct sctp_association *asoc, struct sctp_chunk *chunk,\r\nconst union sctp_addr *peer_addr,\r\nsctp_init_chunk_t *peer_init, gfp_t gfp)\r\n{\r\nunion sctp_params param;\r\nstruct sctp_transport *transport;\r\nstruct list_head *pos, *temp;\r\nstruct sctp_af *af;\r\nunion sctp_addr addr;\r\nchar *cookie;\r\nint src_match = 0;\r\nif(!sctp_assoc_add_peer(asoc, peer_addr, gfp, SCTP_ACTIVE))\r\ngoto nomem;\r\nif (sctp_cmp_addr_exact(sctp_source(chunk), peer_addr))\r\nsrc_match = 1;\r\nsctp_walk_params(param, peer_init, init_hdr.params) {\r\nif (!src_match && (param.p->type == SCTP_PARAM_IPV4_ADDRESS ||\r\nparam.p->type == SCTP_PARAM_IPV6_ADDRESS)) {\r\naf = sctp_get_af_specific(param_type2af(param.p->type));\r\naf->from_addr_param(&addr, param.addr,\r\nchunk->sctp_hdr->source, 0);\r\nif (sctp_cmp_addr_exact(sctp_source(chunk), &addr))\r\nsrc_match = 1;\r\n}\r\nif (!sctp_process_param(asoc, param, peer_addr, gfp))\r\ngoto clean_up;\r\n}\r\nif (!src_match)\r\ngoto clean_up;\r\nif (asoc->peer.auth_capable && (!asoc->peer.peer_random ||\r\n!asoc->peer.peer_hmacs))\r\nasoc->peer.auth_capable = 0;\r\nif (!sctp_addip_noauth &&\r\n(asoc->peer.asconf_capable && !asoc->peer.auth_capable)) {\r\nasoc->peer.addip_disabled_mask |= (SCTP_PARAM_ADD_IP |\r\nSCTP_PARAM_DEL_IP |\r\nSCTP_PARAM_SET_PRIMARY);\r\nasoc->peer.asconf_capable = 0;\r\ngoto clean_up;\r\n}\r\nlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\r\ntransport = list_entry(pos, struct sctp_transport, transports);\r\nif (transport->state == SCTP_UNKNOWN) {\r\nsctp_assoc_rm_peer(asoc, transport);\r\n}\r\n}\r\nasoc->peer.i.init_tag =\r\nntohl(peer_init->init_hdr.init_tag);\r\nasoc->peer.i.a_rwnd =\r\nntohl(peer_init->init_hdr.a_rwnd);\r\nasoc->peer.i.num_outbound_streams =\r\nntohs(peer_init->init_hdr.num_outbound_streams);\r\nasoc->peer.i.num_inbound_streams =\r\nntohs(peer_init->init_hdr.num_inbound_streams);\r\nasoc->peer.i.initial_tsn =\r\nntohl(peer_init->init_hdr.initial_tsn);\r\nif (asoc->c.sinit_num_ostreams >\r\nntohs(peer_init->init_hdr.num_inbound_streams)) {\r\nasoc->c.sinit_num_ostreams =\r\nntohs(peer_init->init_hdr.num_inbound_streams);\r\n}\r\nif (asoc->c.sinit_max_instreams >\r\nntohs(peer_init->init_hdr.num_outbound_streams)) {\r\nasoc->c.sinit_max_instreams =\r\nntohs(peer_init->init_hdr.num_outbound_streams);\r\n}\r\nasoc->c.peer_vtag = asoc->peer.i.init_tag;\r\nasoc->peer.rwnd = asoc->peer.i.a_rwnd;\r\ncookie = asoc->peer.cookie;\r\nif (cookie) {\r\nasoc->peer.cookie = kmemdup(cookie, asoc->peer.cookie_len, gfp);\r\nif (!asoc->peer.cookie)\r\ngoto clean_up;\r\n}\r\nlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\r\ntransports) {\r\ntransport->ssthresh = asoc->peer.i.a_rwnd;\r\n}\r\nif (!sctp_tsnmap_init(&asoc->peer.tsn_map, SCTP_TSN_MAP_INITIAL,\r\nasoc->peer.i.initial_tsn, gfp))\r\ngoto clean_up;\r\nif (!asoc->temp) {\r\nint error;\r\nasoc->ssnmap = sctp_ssnmap_new(asoc->c.sinit_max_instreams,\r\nasoc->c.sinit_num_ostreams, gfp);\r\nif (!asoc->ssnmap)\r\ngoto clean_up;\r\nerror = sctp_assoc_set_id(asoc, gfp);\r\nif (error)\r\ngoto clean_up;\r\n}\r\nasoc->peer.addip_serial = asoc->peer.i.initial_tsn - 1;\r\nreturn 1;\r\nclean_up:\r\nlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\r\ntransport = list_entry(pos, struct sctp_transport, transports);\r\nif (transport->state != SCTP_ACTIVE)\r\nsctp_assoc_rm_peer(asoc, transport);\r\n}\r\nnomem:\r\nreturn 0;\r\n}\r\nstatic int sctp_process_param(struct sctp_association *asoc,\r\nunion sctp_params param,\r\nconst union sctp_addr *peer_addr,\r\ngfp_t gfp)\r\n{\r\nunion sctp_addr addr;\r\nint i;\r\n__u16 sat;\r\nint retval = 1;\r\nsctp_scope_t scope;\r\ntime_t stale;\r\nstruct sctp_af *af;\r\nunion sctp_addr_param *addr_param;\r\nstruct sctp_transport *t;\r\nswitch (param.p->type) {\r\ncase SCTP_PARAM_IPV6_ADDRESS:\r\nif (PF_INET6 != asoc->base.sk->sk_family)\r\nbreak;\r\ngoto do_addr_param;\r\ncase SCTP_PARAM_IPV4_ADDRESS:\r\nif (ipv6_only_sock(asoc->base.sk))\r\nbreak;\r\ndo_addr_param:\r\naf = sctp_get_af_specific(param_type2af(param.p->type));\r\naf->from_addr_param(&addr, param.addr, htons(asoc->peer.port), 0);\r\nscope = sctp_scope(peer_addr);\r\nif (sctp_in_scope(&addr, scope))\r\nif (!sctp_assoc_add_peer(asoc, &addr, gfp, SCTP_UNCONFIRMED))\r\nreturn 0;\r\nbreak;\r\ncase SCTP_PARAM_COOKIE_PRESERVATIVE:\r\nif (!sctp_cookie_preserve_enable)\r\nbreak;\r\nstale = ntohl(param.life->lifespan_increment);\r\nasoc->cookie_life.tv_sec += stale / 1000;\r\nasoc->cookie_life.tv_usec += (stale % 1000) * 1000;\r\nbreak;\r\ncase SCTP_PARAM_HOST_NAME_ADDRESS:\r\nSCTP_DEBUG_PRINTK("unimplemented SCTP_HOST_NAME_ADDRESS\n");\r\nbreak;\r\ncase SCTP_PARAM_SUPPORTED_ADDRESS_TYPES:\r\nasoc->peer.ipv4_address = 0;\r\nasoc->peer.ipv6_address = 0;\r\nif (peer_addr->sa.sa_family == AF_INET6)\r\nasoc->peer.ipv6_address = 1;\r\nelse if (peer_addr->sa.sa_family == AF_INET)\r\nasoc->peer.ipv4_address = 1;\r\nsat = ntohs(param.p->length) - sizeof(sctp_paramhdr_t);\r\nif (sat)\r\nsat /= sizeof(__u16);\r\nfor (i = 0; i < sat; ++i) {\r\nswitch (param.sat->types[i]) {\r\ncase SCTP_PARAM_IPV4_ADDRESS:\r\nasoc->peer.ipv4_address = 1;\r\nbreak;\r\ncase SCTP_PARAM_IPV6_ADDRESS:\r\nif (PF_INET6 == asoc->base.sk->sk_family)\r\nasoc->peer.ipv6_address = 1;\r\nbreak;\r\ncase SCTP_PARAM_HOST_NAME_ADDRESS:\r\nasoc->peer.hostname_address = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase SCTP_PARAM_STATE_COOKIE:\r\nasoc->peer.cookie_len =\r\nntohs(param.p->length) - sizeof(sctp_paramhdr_t);\r\nasoc->peer.cookie = param.cookie->body;\r\nbreak;\r\ncase SCTP_PARAM_HEARTBEAT_INFO:\r\nbreak;\r\ncase SCTP_PARAM_UNRECOGNIZED_PARAMETERS:\r\nbreak;\r\ncase SCTP_PARAM_ECN_CAPABLE:\r\nasoc->peer.ecn_capable = 1;\r\nbreak;\r\ncase SCTP_PARAM_ADAPTATION_LAYER_IND:\r\nasoc->peer.adaptation_ind = ntohl(param.aind->adaptation_ind);\r\nbreak;\r\ncase SCTP_PARAM_SET_PRIMARY:\r\nif (!sctp_addip_enable)\r\ngoto fall_through;\r\naddr_param = param.v + sizeof(sctp_addip_param_t);\r\naf = sctp_get_af_specific(param_type2af(param.p->type));\r\naf->from_addr_param(&addr, addr_param,\r\nhtons(asoc->peer.port), 0);\r\nif (!af->addr_valid(&addr, NULL, NULL))\r\nbreak;\r\nt = sctp_assoc_lookup_paddr(asoc, &addr);\r\nif (!t)\r\nbreak;\r\nsctp_assoc_set_primary(asoc, t);\r\nbreak;\r\ncase SCTP_PARAM_SUPPORTED_EXT:\r\nsctp_process_ext_param(asoc, param);\r\nbreak;\r\ncase SCTP_PARAM_FWD_TSN_SUPPORT:\r\nif (sctp_prsctp_enable) {\r\nasoc->peer.prsctp_capable = 1;\r\nbreak;\r\n}\r\ngoto fall_through;\r\ncase SCTP_PARAM_RANDOM:\r\nif (!sctp_auth_enable)\r\ngoto fall_through;\r\nasoc->peer.peer_random = kmemdup(param.p,\r\nntohs(param.p->length), gfp);\r\nif (!asoc->peer.peer_random) {\r\nretval = 0;\r\nbreak;\r\n}\r\nbreak;\r\ncase SCTP_PARAM_HMAC_ALGO:\r\nif (!sctp_auth_enable)\r\ngoto fall_through;\r\nasoc->peer.peer_hmacs = kmemdup(param.p,\r\nntohs(param.p->length), gfp);\r\nif (!asoc->peer.peer_hmacs) {\r\nretval = 0;\r\nbreak;\r\n}\r\nsctp_auth_asoc_set_default_hmac(asoc, param.hmac_algo);\r\nbreak;\r\ncase SCTP_PARAM_CHUNKS:\r\nif (!sctp_auth_enable)\r\ngoto fall_through;\r\nasoc->peer.peer_chunks = kmemdup(param.p,\r\nntohs(param.p->length), gfp);\r\nif (!asoc->peer.peer_chunks)\r\nretval = 0;\r\nbreak;\r\nfall_through:\r\ndefault:\r\nSCTP_DEBUG_PRINTK("Ignoring param: %d for association %p.\n",\r\nntohs(param.p->type), asoc);\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\n__u32 sctp_generate_tag(const struct sctp_endpoint *ep)\r\n{\r\n__u32 x;\r\ndo {\r\nget_random_bytes(&x, sizeof(__u32));\r\n} while (x == 0);\r\nreturn x;\r\n}\r\n__u32 sctp_generate_tsn(const struct sctp_endpoint *ep)\r\n{\r\n__u32 retval;\r\nget_random_bytes(&retval, sizeof(__u32));\r\nreturn retval;\r\n}\r\nstatic struct sctp_chunk *sctp_make_asconf(struct sctp_association *asoc,\r\nunion sctp_addr *addr,\r\nint vparam_len)\r\n{\r\nsctp_addiphdr_t asconf;\r\nstruct sctp_chunk *retval;\r\nint length = sizeof(asconf) + vparam_len;\r\nunion sctp_addr_param addrparam;\r\nint addrlen;\r\nstruct sctp_af *af = sctp_get_af_specific(addr->v4.sin_family);\r\naddrlen = af->to_addr_param(addr, &addrparam);\r\nif (!addrlen)\r\nreturn NULL;\r\nlength += addrlen;\r\nretval = sctp_make_chunk(asoc, SCTP_CID_ASCONF, 0, length);\r\nif (!retval)\r\nreturn NULL;\r\nasconf.serial = htonl(asoc->addip_serial++);\r\nretval->subh.addip_hdr =\r\nsctp_addto_chunk(retval, sizeof(asconf), &asconf);\r\nretval->param_hdr.v =\r\nsctp_addto_chunk(retval, addrlen, &addrparam);\r\nreturn retval;\r\n}\r\nstruct sctp_chunk *sctp_make_asconf_update_ip(struct sctp_association *asoc,\r\nunion sctp_addr *laddr,\r\nstruct sockaddr *addrs,\r\nint addrcnt,\r\n__be16 flags)\r\n{\r\nsctp_addip_param_t param;\r\nstruct sctp_chunk *retval;\r\nunion sctp_addr_param addr_param;\r\nunion sctp_addr *addr;\r\nvoid *addr_buf;\r\nstruct sctp_af *af;\r\nint paramlen = sizeof(param);\r\nint addr_param_len = 0;\r\nint totallen = 0;\r\nint i;\r\nint del_pickup = 0;\r\naddr_buf = addrs;\r\nfor (i = 0; i < addrcnt; i++) {\r\naddr = addr_buf;\r\naf = sctp_get_af_specific(addr->v4.sin_family);\r\naddr_param_len = af->to_addr_param(addr, &addr_param);\r\ntotallen += paramlen;\r\ntotallen += addr_param_len;\r\naddr_buf += af->sockaddr_len;\r\nif (asoc->asconf_addr_del_pending && !del_pickup) {\r\ntotallen += paramlen;\r\ntotallen += addr_param_len;\r\ndel_pickup = 1;\r\nSCTP_DEBUG_PRINTK("mkasconf_update_ip: picked same-scope del_pending addr, totallen for all addresses is %d\n", totallen);\r\n}\r\n}\r\nretval = sctp_make_asconf(asoc, laddr, totallen);\r\nif (!retval)\r\nreturn NULL;\r\naddr_buf = addrs;\r\nfor (i = 0; i < addrcnt; i++) {\r\naddr = addr_buf;\r\naf = sctp_get_af_specific(addr->v4.sin_family);\r\naddr_param_len = af->to_addr_param(addr, &addr_param);\r\nparam.param_hdr.type = flags;\r\nparam.param_hdr.length = htons(paramlen + addr_param_len);\r\nparam.crr_id = i;\r\nsctp_addto_chunk(retval, paramlen, &param);\r\nsctp_addto_chunk(retval, addr_param_len, &addr_param);\r\naddr_buf += af->sockaddr_len;\r\n}\r\nif (flags == SCTP_PARAM_ADD_IP && del_pickup) {\r\naddr = asoc->asconf_addr_del_pending;\r\naf = sctp_get_af_specific(addr->v4.sin_family);\r\naddr_param_len = af->to_addr_param(addr, &addr_param);\r\nparam.param_hdr.type = SCTP_PARAM_DEL_IP;\r\nparam.param_hdr.length = htons(paramlen + addr_param_len);\r\nparam.crr_id = i;\r\nsctp_addto_chunk(retval, paramlen, &param);\r\nsctp_addto_chunk(retval, addr_param_len, &addr_param);\r\n}\r\nreturn retval;\r\n}\r\nstruct sctp_chunk *sctp_make_asconf_set_prim(struct sctp_association *asoc,\r\nunion sctp_addr *addr)\r\n{\r\nsctp_addip_param_t param;\r\nstruct sctp_chunk *retval;\r\nint len = sizeof(param);\r\nunion sctp_addr_param addrparam;\r\nint addrlen;\r\nstruct sctp_af *af = sctp_get_af_specific(addr->v4.sin_family);\r\naddrlen = af->to_addr_param(addr, &addrparam);\r\nif (!addrlen)\r\nreturn NULL;\r\nlen += addrlen;\r\nretval = sctp_make_asconf(asoc, addr, len);\r\nif (!retval)\r\nreturn NULL;\r\nparam.param_hdr.type = SCTP_PARAM_SET_PRIMARY;\r\nparam.param_hdr.length = htons(len);\r\nparam.crr_id = 0;\r\nsctp_addto_chunk(retval, sizeof(param), &param);\r\nsctp_addto_chunk(retval, addrlen, &addrparam);\r\nreturn retval;\r\n}\r\nstatic struct sctp_chunk *sctp_make_asconf_ack(const struct sctp_association *asoc,\r\n__u32 serial, int vparam_len)\r\n{\r\nsctp_addiphdr_t asconf;\r\nstruct sctp_chunk *retval;\r\nint length = sizeof(asconf) + vparam_len;\r\nretval = sctp_make_chunk(asoc, SCTP_CID_ASCONF_ACK, 0, length);\r\nif (!retval)\r\nreturn NULL;\r\nasconf.serial = htonl(serial);\r\nretval->subh.addip_hdr =\r\nsctp_addto_chunk(retval, sizeof(asconf), &asconf);\r\nreturn retval;\r\n}\r\nstatic void sctp_add_asconf_response(struct sctp_chunk *chunk, __be32 crr_id,\r\n__be16 err_code, sctp_addip_param_t *asconf_param)\r\n{\r\nsctp_addip_param_t ack_param;\r\nsctp_errhdr_t err_param;\r\nint asconf_param_len = 0;\r\nint err_param_len = 0;\r\n__be16 response_type;\r\nif (SCTP_ERROR_NO_ERROR == err_code) {\r\nresponse_type = SCTP_PARAM_SUCCESS_REPORT;\r\n} else {\r\nresponse_type = SCTP_PARAM_ERR_CAUSE;\r\nerr_param_len = sizeof(err_param);\r\nif (asconf_param)\r\nasconf_param_len =\r\nntohs(asconf_param->param_hdr.length);\r\n}\r\nack_param.param_hdr.type = response_type;\r\nack_param.param_hdr.length = htons(sizeof(ack_param) +\r\nerr_param_len +\r\nasconf_param_len);\r\nack_param.crr_id = crr_id;\r\nsctp_addto_chunk(chunk, sizeof(ack_param), &ack_param);\r\nif (SCTP_ERROR_NO_ERROR == err_code)\r\nreturn;\r\nerr_param.cause = err_code;\r\nerr_param.length = htons(err_param_len + asconf_param_len);\r\nsctp_addto_chunk(chunk, err_param_len, &err_param);\r\nif (asconf_param)\r\nsctp_addto_chunk(chunk, asconf_param_len, asconf_param);\r\n}\r\nstatic __be16 sctp_process_asconf_param(struct sctp_association *asoc,\r\nstruct sctp_chunk *asconf,\r\nsctp_addip_param_t *asconf_param)\r\n{\r\nstruct sctp_transport *peer;\r\nstruct sctp_af *af;\r\nunion sctp_addr addr;\r\nunion sctp_addr_param *addr_param;\r\naddr_param = (void *)asconf_param + sizeof(sctp_addip_param_t);\r\nif (asconf_param->param_hdr.type != SCTP_PARAM_ADD_IP &&\r\nasconf_param->param_hdr.type != SCTP_PARAM_DEL_IP &&\r\nasconf_param->param_hdr.type != SCTP_PARAM_SET_PRIMARY)\r\nreturn SCTP_ERROR_UNKNOWN_PARAM;\r\nswitch (addr_param->p.type) {\r\ncase SCTP_PARAM_IPV6_ADDRESS:\r\nif (!asoc->peer.ipv6_address)\r\nreturn SCTP_ERROR_DNS_FAILED;\r\nbreak;\r\ncase SCTP_PARAM_IPV4_ADDRESS:\r\nif (!asoc->peer.ipv4_address)\r\nreturn SCTP_ERROR_DNS_FAILED;\r\nbreak;\r\ndefault:\r\nreturn SCTP_ERROR_DNS_FAILED;\r\n}\r\naf = sctp_get_af_specific(param_type2af(addr_param->p.type));\r\nif (unlikely(!af))\r\nreturn SCTP_ERROR_DNS_FAILED;\r\naf->from_addr_param(&addr, addr_param, htons(asoc->peer.port), 0);\r\nif (!af->is_any(&addr) && !af->addr_valid(&addr, NULL, asconf->skb))\r\nreturn SCTP_ERROR_DNS_FAILED;\r\nswitch (asconf_param->param_hdr.type) {\r\ncase SCTP_PARAM_ADD_IP:\r\nif (af->is_any(&addr))\r\nmemcpy(&addr, &asconf->source, sizeof(addr));\r\npeer = sctp_assoc_add_peer(asoc, &addr, GFP_ATOMIC, SCTP_UNCONFIRMED);\r\nif (!peer)\r\nreturn SCTP_ERROR_RSRC_LOW;\r\nif (!mod_timer(&peer->hb_timer, sctp_transport_timeout(peer)))\r\nsctp_transport_hold(peer);\r\nasoc->new_transport = peer;\r\nbreak;\r\ncase SCTP_PARAM_DEL_IP:\r\nif (asoc->peer.transport_count == 1)\r\nreturn SCTP_ERROR_DEL_LAST_IP;\r\nif (sctp_cmp_addr_exact(&asconf->source, &addr))\r\nreturn SCTP_ERROR_DEL_SRC_IP;\r\nif (af->is_any(&addr)) {\r\nsctp_assoc_set_primary(asoc, asconf->transport);\r\nsctp_assoc_del_nonprimary_peers(asoc,\r\nasconf->transport);\r\n} else\r\nsctp_assoc_del_peer(asoc, &addr);\r\nbreak;\r\ncase SCTP_PARAM_SET_PRIMARY:\r\nif (af->is_any(&addr))\r\nmemcpy(&addr.v4, sctp_source(asconf), sizeof(addr));\r\npeer = sctp_assoc_lookup_paddr(asoc, &addr);\r\nif (!peer)\r\nreturn SCTP_ERROR_DNS_FAILED;\r\nsctp_assoc_set_primary(asoc, peer);\r\nbreak;\r\n}\r\nreturn SCTP_ERROR_NO_ERROR;\r\n}\r\nint sctp_verify_asconf(const struct sctp_association *asoc,\r\nstruct sctp_paramhdr *param_hdr, void *chunk_end,\r\nstruct sctp_paramhdr **errp) {\r\nsctp_addip_param_t *asconf_param;\r\nunion sctp_params param;\r\nint length, plen;\r\nparam.v = (sctp_paramhdr_t *) param_hdr;\r\nwhile (param.v <= chunk_end - sizeof(sctp_paramhdr_t)) {\r\nlength = ntohs(param.p->length);\r\n*errp = param.p;\r\nif (param.v > chunk_end - length ||\r\nlength < sizeof(sctp_paramhdr_t))\r\nreturn 0;\r\nswitch (param.p->type) {\r\ncase SCTP_PARAM_ADD_IP:\r\ncase SCTP_PARAM_DEL_IP:\r\ncase SCTP_PARAM_SET_PRIMARY:\r\nasconf_param = (sctp_addip_param_t *)param.v;\r\nplen = ntohs(asconf_param->param_hdr.length);\r\nif (plen < sizeof(sctp_addip_param_t) +\r\nsizeof(sctp_paramhdr_t))\r\nreturn 0;\r\nbreak;\r\ncase SCTP_PARAM_SUCCESS_REPORT:\r\ncase SCTP_PARAM_ADAPTATION_LAYER_IND:\r\nif (length != sizeof(sctp_addip_param_t))\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nparam.v += WORD_ROUND(length);\r\n}\r\nif (param.v != chunk_end)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstruct sctp_chunk *sctp_process_asconf(struct sctp_association *asoc,\r\nstruct sctp_chunk *asconf)\r\n{\r\nsctp_addiphdr_t *hdr;\r\nunion sctp_addr_param *addr_param;\r\nsctp_addip_param_t *asconf_param;\r\nstruct sctp_chunk *asconf_ack;\r\n__be16 err_code;\r\nint length = 0;\r\nint chunk_len;\r\n__u32 serial;\r\nint all_param_pass = 1;\r\nchunk_len = ntohs(asconf->chunk_hdr->length) - sizeof(sctp_chunkhdr_t);\r\nhdr = (sctp_addiphdr_t *)asconf->skb->data;\r\nserial = ntohl(hdr->serial);\r\nlength = sizeof(sctp_addiphdr_t);\r\naddr_param = (union sctp_addr_param *)(asconf->skb->data + length);\r\nchunk_len -= length;\r\nlength = ntohs(addr_param->p.length);\r\nasconf_param = (void *)addr_param + length;\r\nchunk_len -= length;\r\nasconf_ack = sctp_make_asconf_ack(asoc, serial, chunk_len * 4);\r\nif (!asconf_ack)\r\ngoto done;\r\nwhile (chunk_len > 0) {\r\nerr_code = sctp_process_asconf_param(asoc, asconf,\r\nasconf_param);\r\nif (SCTP_ERROR_NO_ERROR != err_code)\r\nall_param_pass = 0;\r\nif (!all_param_pass)\r\nsctp_add_asconf_response(asconf_ack,\r\nasconf_param->crr_id, err_code,\r\nasconf_param);\r\nif (SCTP_ERROR_RSRC_LOW == err_code)\r\ngoto done;\r\nlength = ntohs(asconf_param->param_hdr.length);\r\nasconf_param = (void *)asconf_param + length;\r\nchunk_len -= length;\r\n}\r\ndone:\r\nasoc->peer.addip_serial++;\r\nif (asconf_ack) {\r\nsctp_chunk_hold(asconf_ack);\r\nlist_add_tail(&asconf_ack->transmitted_list,\r\n&asoc->asconf_ack_list);\r\n}\r\nreturn asconf_ack;\r\n}\r\nstatic void sctp_asconf_param_success(struct sctp_association *asoc,\r\nsctp_addip_param_t *asconf_param)\r\n{\r\nstruct sctp_af *af;\r\nunion sctp_addr addr;\r\nstruct sctp_bind_addr *bp = &asoc->base.bind_addr;\r\nunion sctp_addr_param *addr_param;\r\nstruct sctp_transport *transport;\r\nstruct sctp_sockaddr_entry *saddr;\r\naddr_param = (void *)asconf_param + sizeof(sctp_addip_param_t);\r\naf = sctp_get_af_specific(param_type2af(addr_param->p.type));\r\naf->from_addr_param(&addr, addr_param, htons(bp->port), 0);\r\nswitch (asconf_param->param_hdr.type) {\r\ncase SCTP_PARAM_ADD_IP:\r\nlocal_bh_disable();\r\nlist_for_each_entry(saddr, &bp->address_list, list) {\r\nif (sctp_cmp_addr_exact(&saddr->a, &addr))\r\nsaddr->state = SCTP_ADDR_SRC;\r\n}\r\nlocal_bh_enable();\r\nlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\r\ntransports) {\r\ndst_release(transport->dst);\r\ntransport->dst = NULL;\r\n}\r\nbreak;\r\ncase SCTP_PARAM_DEL_IP:\r\nlocal_bh_disable();\r\nsctp_del_bind_addr(bp, &addr);\r\nif (asoc->asconf_addr_del_pending != NULL &&\r\nsctp_cmp_addr_exact(asoc->asconf_addr_del_pending, &addr)) {\r\nkfree(asoc->asconf_addr_del_pending);\r\nasoc->asconf_addr_del_pending = NULL;\r\n}\r\nlocal_bh_enable();\r\nlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\r\ntransports) {\r\ndst_release(transport->dst);\r\ntransport->dst = NULL;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic __be16 sctp_get_asconf_response(struct sctp_chunk *asconf_ack,\r\nsctp_addip_param_t *asconf_param,\r\nint no_err)\r\n{\r\nsctp_addip_param_t *asconf_ack_param;\r\nsctp_errhdr_t *err_param;\r\nint length;\r\nint asconf_ack_len;\r\n__be16 err_code;\r\nif (no_err)\r\nerr_code = SCTP_ERROR_NO_ERROR;\r\nelse\r\nerr_code = SCTP_ERROR_REQ_REFUSED;\r\nasconf_ack_len = ntohs(asconf_ack->chunk_hdr->length) -\r\nsizeof(sctp_chunkhdr_t);\r\nlength = sizeof(sctp_addiphdr_t);\r\nasconf_ack_param = (sctp_addip_param_t *)(asconf_ack->skb->data +\r\nlength);\r\nasconf_ack_len -= length;\r\nwhile (asconf_ack_len > 0) {\r\nif (asconf_ack_param->crr_id == asconf_param->crr_id) {\r\nswitch(asconf_ack_param->param_hdr.type) {\r\ncase SCTP_PARAM_SUCCESS_REPORT:\r\nreturn SCTP_ERROR_NO_ERROR;\r\ncase SCTP_PARAM_ERR_CAUSE:\r\nlength = sizeof(sctp_addip_param_t);\r\nerr_param = (void *)asconf_ack_param + length;\r\nasconf_ack_len -= length;\r\nif (asconf_ack_len > 0)\r\nreturn err_param->cause;\r\nelse\r\nreturn SCTP_ERROR_INV_PARAM;\r\nbreak;\r\ndefault:\r\nreturn SCTP_ERROR_INV_PARAM;\r\n}\r\n}\r\nlength = ntohs(asconf_ack_param->param_hdr.length);\r\nasconf_ack_param = (void *)asconf_ack_param + length;\r\nasconf_ack_len -= length;\r\n}\r\nreturn err_code;\r\n}\r\nint sctp_process_asconf_ack(struct sctp_association *asoc,\r\nstruct sctp_chunk *asconf_ack)\r\n{\r\nstruct sctp_chunk *asconf = asoc->addip_last_asconf;\r\nunion sctp_addr_param *addr_param;\r\nsctp_addip_param_t *asconf_param;\r\nint length = 0;\r\nint asconf_len = asconf->skb->len;\r\nint all_param_pass = 0;\r\nint no_err = 1;\r\nint retval = 0;\r\n__be16 err_code = SCTP_ERROR_NO_ERROR;\r\nlength = sizeof(sctp_addip_chunk_t);\r\naddr_param = (union sctp_addr_param *)(asconf->skb->data + length);\r\nasconf_len -= length;\r\nlength = ntohs(addr_param->p.length);\r\nasconf_param = (void *)addr_param + length;\r\nasconf_len -= length;\r\nif (asconf_ack->skb->len == sizeof(sctp_addiphdr_t))\r\nall_param_pass = 1;\r\nwhile (asconf_len > 0) {\r\nif (all_param_pass)\r\nerr_code = SCTP_ERROR_NO_ERROR;\r\nelse {\r\nerr_code = sctp_get_asconf_response(asconf_ack,\r\nasconf_param,\r\nno_err);\r\nif (no_err && (SCTP_ERROR_NO_ERROR != err_code))\r\nno_err = 0;\r\n}\r\nswitch (err_code) {\r\ncase SCTP_ERROR_NO_ERROR:\r\nsctp_asconf_param_success(asoc, asconf_param);\r\nbreak;\r\ncase SCTP_ERROR_RSRC_LOW:\r\nretval = 1;\r\nbreak;\r\ncase SCTP_ERROR_UNKNOWN_PARAM:\r\nasoc->peer.addip_disabled_mask |=\r\nasconf_param->param_hdr.type;\r\nbreak;\r\ncase SCTP_ERROR_REQ_REFUSED:\r\ncase SCTP_ERROR_DEL_LAST_IP:\r\ncase SCTP_ERROR_DEL_SRC_IP:\r\ndefault:\r\nbreak;\r\n}\r\nlength = ntohs(asconf_param->param_hdr.length);\r\nasconf_param = (void *)asconf_param + length;\r\nasconf_len -= length;\r\n}\r\nif (no_err && asoc->src_out_of_asoc_ok) {\r\nasoc->src_out_of_asoc_ok = 0;\r\nsctp_transport_immediate_rtx(asoc->peer.primary_path);\r\n}\r\nlist_del_init(&asconf->transmitted_list);\r\nsctp_chunk_free(asconf);\r\nasoc->addip_last_asconf = NULL;\r\nreturn retval;\r\n}\r\nstruct sctp_chunk *sctp_make_fwdtsn(const struct sctp_association *asoc,\r\n__u32 new_cum_tsn, size_t nstreams,\r\nstruct sctp_fwdtsn_skip *skiplist)\r\n{\r\nstruct sctp_chunk *retval = NULL;\r\nstruct sctp_fwdtsn_hdr ftsn_hdr;\r\nstruct sctp_fwdtsn_skip skip;\r\nsize_t hint;\r\nint i;\r\nhint = (nstreams + 1) * sizeof(__u32);\r\nretval = sctp_make_chunk(asoc, SCTP_CID_FWD_TSN, 0, hint);\r\nif (!retval)\r\nreturn NULL;\r\nftsn_hdr.new_cum_tsn = htonl(new_cum_tsn);\r\nretval->subh.fwdtsn_hdr =\r\nsctp_addto_chunk(retval, sizeof(ftsn_hdr), &ftsn_hdr);\r\nfor (i = 0; i < nstreams; i++) {\r\nskip.stream = skiplist[i].stream;\r\nskip.ssn = skiplist[i].ssn;\r\nsctp_addto_chunk(retval, sizeof(skip), &skip);\r\n}\r\nreturn retval;\r\n}
