static int llc_stat_ev_enable_with_dup_addr_check(struct sk_buff *skb)\r\n{\r\nstruct llc_station_state_ev *ev = llc_station_ev(skb);\r\nreturn ev->type == LLC_STATION_EV_TYPE_SIMPLE &&\r\nev->prim_type ==\r\nLLC_STATION_EV_ENABLE_WITH_DUP_ADDR_CHECK ? 0 : 1;\r\n}\r\nstatic int llc_stat_ev_enable_without_dup_addr_check(struct sk_buff *skb)\r\n{\r\nstruct llc_station_state_ev *ev = llc_station_ev(skb);\r\nreturn ev->type == LLC_STATION_EV_TYPE_SIMPLE &&\r\nev->prim_type ==\r\nLLC_STATION_EV_ENABLE_WITHOUT_DUP_ADDR_CHECK ? 0 : 1;\r\n}\r\nstatic int llc_stat_ev_ack_tmr_exp_lt_retry_cnt_max_retry(struct sk_buff *skb)\r\n{\r\nstruct llc_station_state_ev *ev = llc_station_ev(skb);\r\nreturn ev->type == LLC_STATION_EV_TYPE_ACK_TMR &&\r\nllc_main_station.retry_count <\r\nllc_main_station.maximum_retry ? 0 : 1;\r\n}\r\nstatic int llc_stat_ev_ack_tmr_exp_eq_retry_cnt_max_retry(struct sk_buff *skb)\r\n{\r\nstruct llc_station_state_ev *ev = llc_station_ev(skb);\r\nreturn ev->type == LLC_STATION_EV_TYPE_ACK_TMR &&\r\nllc_main_station.retry_count ==\r\nllc_main_station.maximum_retry ? 0 : 1;\r\n}\r\nstatic int llc_stat_ev_rx_null_dsap_xid_c(struct sk_buff *skb)\r\n{\r\nstruct llc_station_state_ev *ev = llc_station_ev(skb);\r\nstruct llc_pdu_un *pdu = llc_pdu_un_hdr(skb);\r\nreturn ev->type == LLC_STATION_EV_TYPE_PDU &&\r\nLLC_PDU_IS_CMD(pdu) &&\r\nLLC_PDU_TYPE_IS_U(pdu) &&\r\nLLC_U_PDU_CMD(pdu) == LLC_1_PDU_CMD_XID &&\r\n!pdu->dsap ? 0 : 1;\r\n}\r\nstatic int llc_stat_ev_rx_null_dsap_0_xid_r_xid_r_cnt_eq(struct sk_buff *skb)\r\n{\r\nstruct llc_station_state_ev *ev = llc_station_ev(skb);\r\nstruct llc_pdu_un *pdu = llc_pdu_un_hdr(skb);\r\nreturn ev->type == LLC_STATION_EV_TYPE_PDU &&\r\nLLC_PDU_IS_RSP(pdu) &&\r\nLLC_PDU_TYPE_IS_U(pdu) &&\r\nLLC_U_PDU_RSP(pdu) == LLC_1_PDU_CMD_XID &&\r\n!pdu->dsap &&\r\n!llc_main_station.xid_r_count ? 0 : 1;\r\n}\r\nstatic int llc_stat_ev_rx_null_dsap_1_xid_r_xid_r_cnt_eq(struct sk_buff *skb)\r\n{\r\nstruct llc_station_state_ev *ev = llc_station_ev(skb);\r\nstruct llc_pdu_un *pdu = llc_pdu_un_hdr(skb);\r\nreturn ev->type == LLC_STATION_EV_TYPE_PDU &&\r\nLLC_PDU_IS_RSP(pdu) &&\r\nLLC_PDU_TYPE_IS_U(pdu) &&\r\nLLC_U_PDU_RSP(pdu) == LLC_1_PDU_CMD_XID &&\r\n!pdu->dsap &&\r\nllc_main_station.xid_r_count == 1 ? 0 : 1;\r\n}\r\nstatic int llc_stat_ev_rx_null_dsap_test_c(struct sk_buff *skb)\r\n{\r\nstruct llc_station_state_ev *ev = llc_station_ev(skb);\r\nstruct llc_pdu_un *pdu = llc_pdu_un_hdr(skb);\r\nreturn ev->type == LLC_STATION_EV_TYPE_PDU &&\r\nLLC_PDU_IS_CMD(pdu) &&\r\nLLC_PDU_TYPE_IS_U(pdu) &&\r\nLLC_U_PDU_CMD(pdu) == LLC_1_PDU_CMD_TEST &&\r\n!pdu->dsap ? 0 : 1;\r\n}\r\nstatic int llc_stat_ev_disable_req(struct sk_buff *skb)\r\n{\r\nstruct llc_station_state_ev *ev = llc_station_ev(skb);\r\nreturn ev->type == LLC_STATION_EV_TYPE_PRIM &&\r\nev->prim == LLC_DISABLE_PRIM &&\r\nev->prim_type == LLC_PRIM_TYPE_REQ ? 0 : 1;\r\n}\r\nstatic void llc_station_send_pdu(struct sk_buff *skb)\r\n{\r\nskb_queue_tail(&llc_main_station.mac_pdu_q, skb);\r\nwhile ((skb = skb_dequeue(&llc_main_station.mac_pdu_q)) != NULL)\r\nif (dev_queue_xmit(skb))\r\nbreak;\r\n}\r\nstatic int llc_station_ac_start_ack_timer(struct sk_buff *skb)\r\n{\r\nmod_timer(&llc_main_station.ack_timer,\r\njiffies + sysctl_llc_station_ack_timeout);\r\nreturn 0;\r\n}\r\nstatic int llc_station_ac_set_retry_cnt_0(struct sk_buff *skb)\r\n{\r\nllc_main_station.retry_count = 0;\r\nreturn 0;\r\n}\r\nstatic int llc_station_ac_inc_retry_cnt_by_1(struct sk_buff *skb)\r\n{\r\nllc_main_station.retry_count++;\r\nreturn 0;\r\n}\r\nstatic int llc_station_ac_set_xid_r_cnt_0(struct sk_buff *skb)\r\n{\r\nllc_main_station.xid_r_count = 0;\r\nreturn 0;\r\n}\r\nstatic int llc_station_ac_inc_xid_r_cnt_by_1(struct sk_buff *skb)\r\n{\r\nllc_main_station.xid_r_count++;\r\nreturn 0;\r\n}\r\nstatic int llc_station_ac_send_null_dsap_xid_c(struct sk_buff *skb)\r\n{\r\nint rc = 1;\r\nstruct sk_buff *nskb = llc_alloc_frame(NULL, skb->dev, LLC_PDU_TYPE_U,\r\nsizeof(struct llc_xid_info));\r\nif (!nskb)\r\ngoto out;\r\nllc_pdu_header_init(nskb, LLC_PDU_TYPE_U, 0, 0, LLC_PDU_CMD);\r\nllc_pdu_init_as_xid_cmd(nskb, LLC_XID_NULL_CLASS_2, 127);\r\nrc = llc_mac_hdr_init(nskb, skb->dev->dev_addr, skb->dev->dev_addr);\r\nif (unlikely(rc))\r\ngoto free;\r\nllc_station_send_pdu(nskb);\r\nout:\r\nreturn rc;\r\nfree:\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nstatic int llc_station_ac_send_xid_r(struct sk_buff *skb)\r\n{\r\nu8 mac_da[ETH_ALEN], dsap;\r\nint rc = 1;\r\nstruct sk_buff *nskb = llc_alloc_frame(NULL, skb->dev, LLC_PDU_TYPE_U,\r\nsizeof(struct llc_xid_info));\r\nif (!nskb)\r\ngoto out;\r\nrc = 0;\r\nllc_pdu_decode_sa(skb, mac_da);\r\nllc_pdu_decode_ssap(skb, &dsap);\r\nllc_pdu_header_init(nskb, LLC_PDU_TYPE_U, 0, dsap, LLC_PDU_RSP);\r\nllc_pdu_init_as_xid_rsp(nskb, LLC_XID_NULL_CLASS_2, 127);\r\nrc = llc_mac_hdr_init(nskb, skb->dev->dev_addr, mac_da);\r\nif (unlikely(rc))\r\ngoto free;\r\nllc_station_send_pdu(nskb);\r\nout:\r\nreturn rc;\r\nfree:\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nstatic int llc_station_ac_send_test_r(struct sk_buff *skb)\r\n{\r\nu8 mac_da[ETH_ALEN], dsap;\r\nint rc = 1;\r\nu32 data_size;\r\nstruct sk_buff *nskb;\r\ndata_size = ntohs(eth_hdr(skb)->h_proto) - 3;\r\nnskb = llc_alloc_frame(NULL, skb->dev, LLC_PDU_TYPE_U, data_size);\r\nif (!nskb)\r\ngoto out;\r\nrc = 0;\r\nllc_pdu_decode_sa(skb, mac_da);\r\nllc_pdu_decode_ssap(skb, &dsap);\r\nllc_pdu_header_init(nskb, LLC_PDU_TYPE_U, 0, dsap, LLC_PDU_RSP);\r\nllc_pdu_init_as_test_rsp(nskb, skb);\r\nrc = llc_mac_hdr_init(nskb, skb->dev->dev_addr, mac_da);\r\nif (unlikely(rc))\r\ngoto free;\r\nllc_station_send_pdu(nskb);\r\nout:\r\nreturn rc;\r\nfree:\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nstatic int llc_station_ac_report_status(struct sk_buff *skb)\r\n{\r\nreturn 0;\r\n}\r\nstatic u16 llc_exec_station_trans_actions(struct llc_station_state_trans *trans,\r\nstruct sk_buff *skb)\r\n{\r\nu16 rc = 0;\r\nllc_station_action_t *next_action = trans->ev_actions;\r\nfor (; next_action && *next_action; next_action++)\r\nif ((*next_action)(skb))\r\nrc = 1;\r\nreturn rc;\r\n}\r\nstatic struct llc_station_state_trans *\r\nllc_find_station_trans(struct sk_buff *skb)\r\n{\r\nint i = 0;\r\nstruct llc_station_state_trans *rc = NULL;\r\nstruct llc_station_state_trans **next_trans;\r\nstruct llc_station_state *curr_state =\r\n&llc_station_state_table[llc_main_station.state - 1];\r\nfor (next_trans = curr_state->transitions; next_trans[i]->ev; i++)\r\nif (!next_trans[i]->ev(skb)) {\r\nrc = next_trans[i];\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic void llc_station_free_ev(struct sk_buff *skb)\r\n{\r\nstruct llc_station_state_ev *ev = llc_station_ev(skb);\r\nif (ev->type == LLC_STATION_EV_TYPE_PDU)\r\nkfree_skb(skb);\r\n}\r\nstatic u16 llc_station_next_state(struct sk_buff *skb)\r\n{\r\nu16 rc = 1;\r\nstruct llc_station_state_trans *trans;\r\nif (llc_main_station.state > LLC_NBR_STATION_STATES)\r\ngoto out;\r\ntrans = llc_find_station_trans(skb);\r\nif (trans) {\r\nrc = llc_exec_station_trans_actions(trans, skb);\r\nif (!rc)\r\nllc_main_station.state = trans->next_state;\r\n} else\r\nrc = 0;\r\nout:\r\nllc_station_free_ev(skb);\r\nreturn rc;\r\n}\r\nstatic void llc_station_service_events(void)\r\n{\r\nstruct sk_buff *skb;\r\nwhile ((skb = skb_dequeue(&llc_main_station.ev_q.list)) != NULL)\r\nllc_station_next_state(skb);\r\n}\r\nstatic void llc_station_state_process(struct sk_buff *skb)\r\n{\r\nspin_lock_bh(&llc_main_station.ev_q.lock);\r\nskb_queue_tail(&llc_main_station.ev_q.list, skb);\r\nllc_station_service_events();\r\nspin_unlock_bh(&llc_main_station.ev_q.lock);\r\n}\r\nstatic void llc_station_ack_tmr_cb(unsigned long timeout_data)\r\n{\r\nstruct sk_buff *skb = alloc_skb(0, GFP_ATOMIC);\r\nif (skb) {\r\nstruct llc_station_state_ev *ev = llc_station_ev(skb);\r\nev->type = LLC_STATION_EV_TYPE_ACK_TMR;\r\nllc_station_state_process(skb);\r\n}\r\n}\r\nstatic void llc_station_rcv(struct sk_buff *skb)\r\n{\r\nstruct llc_station_state_ev *ev = llc_station_ev(skb);\r\nev->type = LLC_STATION_EV_TYPE_PDU;\r\nev->reason = 0;\r\nllc_station_state_process(skb);\r\n}\r\nint __init llc_station_init(void)\r\n{\r\nint rc = -ENOBUFS;\r\nstruct sk_buff *skb;\r\nstruct llc_station_state_ev *ev;\r\nskb_queue_head_init(&llc_main_station.mac_pdu_q);\r\nskb_queue_head_init(&llc_main_station.ev_q.list);\r\nspin_lock_init(&llc_main_station.ev_q.lock);\r\nsetup_timer(&llc_main_station.ack_timer, llc_station_ack_tmr_cb,\r\n(unsigned long)&llc_main_station);\r\nllc_main_station.ack_timer.expires = jiffies +\r\nsysctl_llc_station_ack_timeout;\r\nskb = alloc_skb(0, GFP_ATOMIC);\r\nif (!skb)\r\ngoto out;\r\nrc = 0;\r\nllc_set_station_handler(llc_station_rcv);\r\nev = llc_station_ev(skb);\r\nmemset(ev, 0, sizeof(*ev));\r\nllc_main_station.maximum_retry = 1;\r\nllc_main_station.state = LLC_STATION_STATE_DOWN;\r\nev->type = LLC_STATION_EV_TYPE_SIMPLE;\r\nev->prim_type = LLC_STATION_EV_ENABLE_WITHOUT_DUP_ADDR_CHECK;\r\nrc = llc_station_next_state(skb);\r\nout:\r\nreturn rc;\r\n}\r\nvoid __exit llc_station_exit(void)\r\n{\r\nllc_set_station_handler(NULL);\r\n}
