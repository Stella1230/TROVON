static inline u32\r\nCTX_PTR(struct drm_device *dev, u32 offset)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nif (dev_priv->chipset == 0x50)\r\noffset += 0x0260;\r\nelse\r\noffset += 0x0060;\r\nreturn offset;\r\n}\r\nstatic int\r\nnv50_mpeg_context_new(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpuobj *ramin = chan->ramin;\r\nstruct nouveau_gpuobj *ctx = NULL;\r\nint ret;\r\nNV_DEBUG(dev, "ch%d\n", chan->id);\r\nret = nouveau_gpuobj_new(dev, chan, 128 * 4, 0, NVOBJ_FLAG_ZERO_ALLOC |\r\nNVOBJ_FLAG_ZERO_FREE, &ctx);\r\nif (ret)\r\nreturn ret;\r\nnv_wo32(ramin, CTX_PTR(dev, 0x00), 0x80190002);\r\nnv_wo32(ramin, CTX_PTR(dev, 0x04), ctx->vinst + ctx->size - 1);\r\nnv_wo32(ramin, CTX_PTR(dev, 0x08), ctx->vinst);\r\nnv_wo32(ramin, CTX_PTR(dev, 0x0c), 0);\r\nnv_wo32(ramin, CTX_PTR(dev, 0x10), 0);\r\nnv_wo32(ramin, CTX_PTR(dev, 0x14), 0x00010000);\r\nnv_wo32(ctx, 0x70, 0x00801ec1);\r\nnv_wo32(ctx, 0x7c, 0x0000037c);\r\ndev_priv->engine.instmem.flush(dev);\r\nchan->engctx[engine] = ctx;\r\nreturn 0;\r\n}\r\nstatic void\r\nnv50_mpeg_context_del(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct drm_nouveau_private *dev_priv = chan->dev->dev_private;\r\nstruct nouveau_gpuobj *ctx = chan->engctx[engine];\r\nstruct drm_device *dev = chan->dev;\r\nunsigned long flags;\r\nu32 inst, i;\r\nif (!chan->ramin)\r\nreturn;\r\ninst = chan->ramin->vinst >> 12;\r\ninst |= 0x80000000;\r\nspin_lock_irqsave(&dev_priv->context_switch_lock, flags);\r\nnv_mask(dev, 0x00b32c, 0x00000001, 0x00000000);\r\nif (nv_rd32(dev, 0x00b318) == inst)\r\nnv_mask(dev, 0x00b318, 0x80000000, 0x00000000);\r\nnv_mask(dev, 0x00b32c, 0x00000001, 0x00000001);\r\nspin_unlock_irqrestore(&dev_priv->context_switch_lock, flags);\r\nfor (i = 0x00; i <= 0x14; i += 4)\r\nnv_wo32(chan->ramin, CTX_PTR(dev, i), 0x00000000);\r\nnouveau_gpuobj_ref(NULL, &ctx);\r\nchan->engctx[engine] = NULL;\r\n}\r\nstatic int\r\nnv50_mpeg_object_new(struct nouveau_channel *chan, int engine,\r\nu32 handle, u16 class)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpuobj *obj = NULL;\r\nint ret;\r\nret = nouveau_gpuobj_new(dev, chan, 16, 16, NVOBJ_FLAG_ZERO_FREE, &obj);\r\nif (ret)\r\nreturn ret;\r\nobj->engine = 2;\r\nobj->class = class;\r\nnv_wo32(obj, 0x00, class);\r\nnv_wo32(obj, 0x04, 0x00000000);\r\nnv_wo32(obj, 0x08, 0x00000000);\r\nnv_wo32(obj, 0x0c, 0x00000000);\r\ndev_priv->engine.instmem.flush(dev);\r\nret = nouveau_ramht_insert(chan, handle, obj);\r\nnouveau_gpuobj_ref(NULL, &obj);\r\nreturn ret;\r\n}\r\nstatic void\r\nnv50_mpeg_tlb_flush(struct drm_device *dev, int engine)\r\n{\r\nnv50_vm_flush_engine(dev, 0x08);\r\n}\r\nstatic int\r\nnv50_mpeg_init(struct drm_device *dev, int engine)\r\n{\r\nnv_wr32(dev, 0x00b32c, 0x00000000);\r\nnv_wr32(dev, 0x00b314, 0x00000100);\r\nnv_wr32(dev, 0x00b0e0, 0x0000001a);\r\nnv_wr32(dev, 0x00b220, 0x00000044);\r\nnv_wr32(dev, 0x00b300, 0x00801ec1);\r\nnv_wr32(dev, 0x00b390, 0x00000000);\r\nnv_wr32(dev, 0x00b394, 0x00000000);\r\nnv_wr32(dev, 0x00b398, 0x00000000);\r\nnv_mask(dev, 0x00b32c, 0x00000001, 0x00000001);\r\nnv_wr32(dev, 0x00b100, 0xffffffff);\r\nnv_wr32(dev, 0x00b140, 0xffffffff);\r\nif (!nv_wait(dev, 0x00b200, 0x00000001, 0x00000000)) {\r\nNV_ERROR(dev, "PMPEG init: 0x%08x\n", nv_rd32(dev, 0x00b200));\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_mpeg_fini(struct drm_device *dev, int engine, bool suspend)\r\n{\r\nnv_mask(dev, 0x00b32c, 0x00000001, 0x00000000);\r\nnv_wr32(dev, 0x00b140, 0x00000000);\r\nreturn 0;\r\n}\r\nstatic void\r\nnv50_mpeg_isr(struct drm_device *dev)\r\n{\r\nu32 stat = nv_rd32(dev, 0x00b100);\r\nu32 type = nv_rd32(dev, 0x00b230);\r\nu32 mthd = nv_rd32(dev, 0x00b234);\r\nu32 data = nv_rd32(dev, 0x00b238);\r\nu32 show = stat;\r\nif (stat & 0x01000000) {\r\nif (type == 0x00000020 && mthd == 0x0000) {\r\nnv_wr32(dev, 0x00b308, 0x00000100);\r\nshow &= ~0x01000000;\r\n}\r\n}\r\nif (show && nouveau_ratelimit()) {\r\nNV_INFO(dev, "PMPEG - 0x%08x 0x%08x 0x%08x 0x%08x\n",\r\nstat, type, mthd, data);\r\n}\r\nnv_wr32(dev, 0x00b100, stat);\r\nnv_wr32(dev, 0x00b230, 0x00000001);\r\nnv50_fb_vm_trap(dev, 1);\r\n}\r\nstatic void\r\nnv50_vpe_isr(struct drm_device *dev)\r\n{\r\nif (nv_rd32(dev, 0x00b100))\r\nnv50_mpeg_isr(dev);\r\nif (nv_rd32(dev, 0x00b800)) {\r\nu32 stat = nv_rd32(dev, 0x00b800);\r\nNV_INFO(dev, "PMSRCH: 0x%08x\n", stat);\r\nnv_wr32(dev, 0xb800, stat);\r\n}\r\n}\r\nstatic void\r\nnv50_mpeg_destroy(struct drm_device *dev, int engine)\r\n{\r\nstruct nv50_mpeg_engine *pmpeg = nv_engine(dev, engine);\r\nnouveau_irq_unregister(dev, 0);\r\nNVOBJ_ENGINE_DEL(dev, MPEG);\r\nkfree(pmpeg);\r\n}\r\nint\r\nnv50_mpeg_create(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv50_mpeg_engine *pmpeg;\r\npmpeg = kzalloc(sizeof(*pmpeg), GFP_KERNEL);\r\nif (!pmpeg)\r\nreturn -ENOMEM;\r\npmpeg->base.destroy = nv50_mpeg_destroy;\r\npmpeg->base.init = nv50_mpeg_init;\r\npmpeg->base.fini = nv50_mpeg_fini;\r\npmpeg->base.context_new = nv50_mpeg_context_new;\r\npmpeg->base.context_del = nv50_mpeg_context_del;\r\npmpeg->base.object_new = nv50_mpeg_object_new;\r\npmpeg->base.tlb_flush = nv50_mpeg_tlb_flush;\r\nif (dev_priv->chipset == 0x50) {\r\nnouveau_irq_register(dev, 0, nv50_vpe_isr);\r\nNVOBJ_ENGINE_ADD(dev, MPEG, &pmpeg->base);\r\nNVOBJ_CLASS(dev, 0x3174, MPEG);\r\n#if 0\r\nNVOBJ_ENGINE_ADD(dev, ME, &pme->base);\r\nNVOBJ_CLASS(dev, 0x4075, ME);\r\n#endif\r\n} else {\r\nnouveau_irq_register(dev, 0, nv50_mpeg_isr);\r\nNVOBJ_ENGINE_ADD(dev, MPEG, &pmpeg->base);\r\nNVOBJ_CLASS(dev, 0x8274, MPEG);\r\n}\r\nreturn 0;\r\n}
