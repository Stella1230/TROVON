unsigned int beiscsi_get_boot_target(struct beiscsi_hba *phba)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_mac_addr *req;\r\nunsigned int tag = 0;\r\nSE_DEBUG(DBG_LVL_8, "In bescsi_get_boot_target\n");\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nreq = embedded_payload(wrb);\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\r\nOPCODE_ISCSI_INI_BOOT_GET_BOOT_TARGET,\r\nsizeof(*req));\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nunsigned int beiscsi_get_session_info(struct beiscsi_hba *phba,\r\nu32 boot_session_handle,\r\nstruct be_dma_mem *nonemb_cmd)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nunsigned int tag = 0;\r\nstruct be_cmd_req_get_session *req;\r\nstruct be_cmd_resp_get_session *resp;\r\nstruct be_sge *sge;\r\nSE_DEBUG(DBG_LVL_8, "In beiscsi_get_session_info\n");\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nnonemb_cmd->size = sizeof(*resp);\r\nreq = nonemb_cmd->va;\r\nmemset(req, 0, sizeof(*req));\r\nwrb = wrb_from_mccq(phba);\r\nsge = nonembedded_sgl(wrb);\r\nwrb->tag0 |= tag;\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\r\nOPCODE_ISCSI_INI_SESSION_GET_A_SESSION,\r\nsizeof(*resp));\r\nreq->session_handle = boot_session_handle;\r\nsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));\r\nsge->pa_lo = cpu_to_le32(nonemb_cmd->dma & 0xFFFFFFFF);\r\nsge->len = cpu_to_le32(nonemb_cmd->size);\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nint mgmt_get_fw_config(struct be_ctrl_info *ctrl,\r\nstruct beiscsi_hba *phba)\r\n{\r\nstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nstruct be_fw_cfg *req = embedded_payload(wrb);\r\nint status = 0;\r\nspin_lock(&ctrl->mbox_lock);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_QUERY_FIRMWARE_CONFIG, sizeof(*req));\r\nstatus = be_mbox_notify(ctrl);\r\nif (!status) {\r\nstruct be_fw_cfg *pfw_cfg;\r\npfw_cfg = req;\r\nphba->fw_config.phys_port = pfw_cfg->phys_port;\r\nphba->fw_config.iscsi_icd_start =\r\npfw_cfg->ulp[0].icd_base;\r\nphba->fw_config.iscsi_icd_count =\r\npfw_cfg->ulp[0].icd_count;\r\nphba->fw_config.iscsi_cid_start =\r\npfw_cfg->ulp[0].sq_base;\r\nphba->fw_config.iscsi_cid_count =\r\npfw_cfg->ulp[0].sq_count;\r\nif (phba->fw_config.iscsi_cid_count > (BE2_MAX_SESSIONS / 2)) {\r\nSE_DEBUG(DBG_LVL_8,\r\n"FW reported MAX CXNS as %d\t"\r\n"Max Supported = %d.\n",\r\nphba->fw_config.iscsi_cid_count,\r\nBE2_MAX_SESSIONS);\r\nphba->fw_config.iscsi_cid_count = BE2_MAX_SESSIONS / 2;\r\n}\r\n} else {\r\nshost_printk(KERN_WARNING, phba->shost,\r\n"Failed in mgmt_get_fw_config\n");\r\n}\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn status;\r\n}\r\nint mgmt_check_supported_fw(struct be_ctrl_info *ctrl,\r\nstruct beiscsi_hba *phba)\r\n{\r\nstruct be_dma_mem nonemb_cmd;\r\nstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\r\nstruct be_mgmt_controller_attributes *req;\r\nstruct be_sge *sge = nonembedded_sgl(wrb);\r\nint status = 0;\r\nnonemb_cmd.va = pci_alloc_consistent(ctrl->pdev,\r\nsizeof(struct be_mgmt_controller_attributes),\r\n&nonemb_cmd.dma);\r\nif (nonemb_cmd.va == NULL) {\r\nSE_DEBUG(DBG_LVL_1,\r\n"Failed to allocate memory for mgmt_check_supported_fw"\r\n"\n");\r\nreturn -ENOMEM;\r\n}\r\nnonemb_cmd.size = sizeof(struct be_mgmt_controller_attributes);\r\nreq = nonemb_cmd.va;\r\nmemset(req, 0, sizeof(*req));\r\nspin_lock(&ctrl->mbox_lock);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\r\nOPCODE_COMMON_GET_CNTL_ATTRIBUTES, sizeof(*req));\r\nsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd.dma));\r\nsge->pa_lo = cpu_to_le32(nonemb_cmd.dma & 0xFFFFFFFF);\r\nsge->len = cpu_to_le32(nonemb_cmd.size);\r\nstatus = be_mbox_notify(ctrl);\r\nif (!status) {\r\nstruct be_mgmt_controller_attributes_resp *resp = nonemb_cmd.va;\r\nSE_DEBUG(DBG_LVL_8, "Firmware version of CMD: %s\n",\r\nresp->params.hba_attribs.flashrom_version_string);\r\nSE_DEBUG(DBG_LVL_8, "Firmware version is : %s\n",\r\nresp->params.hba_attribs.firmware_version_string);\r\nSE_DEBUG(DBG_LVL_8,\r\n"Developer Build, not performing version check...\n");\r\nphba->fw_config.iscsi_features =\r\nresp->params.hba_attribs.iscsi_features;\r\nSE_DEBUG(DBG_LVL_8, " phba->fw_config.iscsi_features = %d\n",\r\nphba->fw_config.iscsi_features);\r\n} else\r\nSE_DEBUG(DBG_LVL_1, " Failed in mgmt_check_supported_fw\n");\r\nspin_unlock(&ctrl->mbox_lock);\r\nif (nonemb_cmd.va)\r\npci_free_consistent(ctrl->pdev, nonemb_cmd.size,\r\nnonemb_cmd.va, nonemb_cmd.dma);\r\nreturn status;\r\n}\r\nint mgmt_epfw_cleanup(struct beiscsi_hba *phba, unsigned short chute)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb = wrb_from_mccq(phba);\r\nstruct iscsi_cleanup_req *req = embedded_payload(wrb);\r\nint status = 0;\r\nspin_lock(&ctrl->mbox_lock);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_ISCSI_CLEANUP, sizeof(*req));\r\nreq->chute = chute;\r\nreq->hdr_ring_id = cpu_to_le16(HWI_GET_DEF_HDRQ_ID(phba));\r\nreq->data_ring_id = cpu_to_le16(HWI_GET_DEF_BUFQ_ID(phba));\r\nstatus = be_mcc_notify_wait(phba);\r\nif (status)\r\nshost_printk(KERN_WARNING, phba->shost,\r\n" mgmt_epfw_cleanup , FAILED\n");\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn status;\r\n}\r\nunsigned int mgmt_invalidate_icds(struct beiscsi_hba *phba,\r\nstruct invalidate_command_table *inv_tbl,\r\nunsigned int num_invalidate, unsigned int cid,\r\nstruct be_dma_mem *nonemb_cmd)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_sge *sge;\r\nstruct invalidate_commands_params_in *req;\r\nunsigned int i, tag = 0;\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nreq = nonemb_cmd->va;\r\nmemset(req, 0, sizeof(*req));\r\nwrb = wrb_from_mccq(phba);\r\nsge = nonembedded_sgl(wrb);\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_ISCSI_ERROR_RECOVERY_INVALIDATE_COMMANDS,\r\nsizeof(*req));\r\nreq->ref_handle = 0;\r\nreq->cleanup_type = CMD_ISCSI_COMMAND_INVALIDATE;\r\nfor (i = 0; i < num_invalidate; i++) {\r\nreq->table[i].icd = inv_tbl->icd;\r\nreq->table[i].cid = inv_tbl->cid;\r\nreq->icd_count++;\r\ninv_tbl++;\r\n}\r\nsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));\r\nsge->pa_lo = cpu_to_le32(nonemb_cmd->dma & 0xFFFFFFFF);\r\nsge->len = cpu_to_le32(nonemb_cmd->size);\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nunsigned int mgmt_invalidate_connection(struct beiscsi_hba *phba,\r\nstruct beiscsi_endpoint *beiscsi_ep,\r\nunsigned short cid,\r\nunsigned short issue_reset,\r\nunsigned short savecfg_flag)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct iscsi_invalidate_connection_params_in *req;\r\nunsigned int tag = 0;\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nwrb->tag0 |= tag;\r\nreq = embedded_payload(wrb);\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\r\nOPCODE_ISCSI_INI_DRIVER_INVALIDATE_CONNECTION,\r\nsizeof(*req));\r\nreq->session_handle = beiscsi_ep->fw_handle;\r\nreq->cid = cid;\r\nif (issue_reset)\r\nreq->cleanup_type = CMD_ISCSI_CONNECTION_ISSUE_TCP_RST;\r\nelse\r\nreq->cleanup_type = CMD_ISCSI_CONNECTION_INVALIDATE;\r\nreq->save_cfg = savecfg_flag;\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nunsigned int mgmt_upload_connection(struct beiscsi_hba *phba,\r\nunsigned short cid, unsigned int upload_flag)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct tcp_upload_params_in *req;\r\nunsigned int tag = 0;\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nreq = embedded_payload(wrb);\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_COMMON_TCP_UPLOAD,\r\nOPCODE_COMMON_TCP_UPLOAD, sizeof(*req));\r\nreq->id = (unsigned short)cid;\r\nreq->upload_type = (unsigned char)upload_flag;\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nint mgmt_open_connection(struct beiscsi_hba *phba,\r\nstruct sockaddr *dst_addr,\r\nstruct beiscsi_endpoint *beiscsi_ep,\r\nstruct be_dma_mem *nonemb_cmd)\r\n{\r\nstruct hwi_controller *phwi_ctrlr;\r\nstruct hwi_context_memory *phwi_context;\r\nstruct sockaddr_in *daddr_in = (struct sockaddr_in *)dst_addr;\r\nstruct sockaddr_in6 *daddr_in6 = (struct sockaddr_in6 *)dst_addr;\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct tcp_connect_and_offload_in *req;\r\nunsigned short def_hdr_id;\r\nunsigned short def_data_id;\r\nstruct phys_addr template_address = { 0, 0 };\r\nstruct phys_addr *ptemplate_address;\r\nunsigned int tag = 0;\r\nunsigned int i;\r\nunsigned short cid = beiscsi_ep->ep_cid;\r\nstruct be_sge *sge;\r\nphwi_ctrlr = phba->phwi_ctrlr;\r\nphwi_context = phwi_ctrlr->phwi_ctxt;\r\ndef_hdr_id = (unsigned short)HWI_GET_DEF_HDRQ_ID(phba);\r\ndef_data_id = (unsigned short)HWI_GET_DEF_BUFQ_ID(phba);\r\nptemplate_address = &template_address;\r\nISCSI_GET_PDU_TEMPLATE_ADDRESS(phba, ptemplate_address);\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nmemset(wrb, 0, sizeof(*wrb));\r\nsge = nonembedded_sgl(wrb);\r\nreq = nonemb_cmd->va;\r\nmemset(req, 0, sizeof(*req));\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_ISCSI_TCP_CONNECT_AND_OFFLOAD,\r\nsizeof(*req));\r\nif (dst_addr->sa_family == PF_INET) {\r\n__be32 s_addr = daddr_in->sin_addr.s_addr;\r\nreq->ip_address.ip_type = BE2_IPV4;\r\nreq->ip_address.ip_address[0] = s_addr & 0x000000ff;\r\nreq->ip_address.ip_address[1] = (s_addr & 0x0000ff00) >> 8;\r\nreq->ip_address.ip_address[2] = (s_addr & 0x00ff0000) >> 16;\r\nreq->ip_address.ip_address[3] = (s_addr & 0xff000000) >> 24;\r\nreq->tcp_port = ntohs(daddr_in->sin_port);\r\nbeiscsi_ep->dst_addr = daddr_in->sin_addr.s_addr;\r\nbeiscsi_ep->dst_tcpport = ntohs(daddr_in->sin_port);\r\nbeiscsi_ep->ip_type = BE2_IPV4;\r\n} else if (dst_addr->sa_family == PF_INET6) {\r\nreq->ip_address.ip_type = BE2_IPV6;\r\nmemcpy(&req->ip_address.ip_address,\r\n&daddr_in6->sin6_addr.in6_u.u6_addr8, 16);\r\nreq->tcp_port = ntohs(daddr_in6->sin6_port);\r\nbeiscsi_ep->dst_tcpport = ntohs(daddr_in6->sin6_port);\r\nmemcpy(&beiscsi_ep->dst6_addr,\r\n&daddr_in6->sin6_addr.in6_u.u6_addr8, 16);\r\nbeiscsi_ep->ip_type = BE2_IPV6;\r\n} else{\r\nshost_printk(KERN_ERR, phba->shost, "unknown addr family %d\n",\r\ndst_addr->sa_family);\r\nspin_unlock(&ctrl->mbox_lock);\r\nfree_mcc_tag(&phba->ctrl, tag);\r\nreturn -EINVAL;\r\n}\r\nreq->cid = cid;\r\ni = phba->nxt_cqid++;\r\nif (phba->nxt_cqid == phba->num_cpus)\r\nphba->nxt_cqid = 0;\r\nreq->cq_id = phwi_context->be_cq[i].id;\r\nSE_DEBUG(DBG_LVL_8, "i=%d cq_id=%d\n", i, req->cq_id);\r\nreq->defq_id = def_hdr_id;\r\nreq->hdr_ring_id = def_hdr_id;\r\nreq->data_ring_id = def_data_id;\r\nreq->do_offload = 1;\r\nreq->dataout_template_pa.lo = ptemplate_address->lo;\r\nreq->dataout_template_pa.hi = ptemplate_address->hi;\r\nsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));\r\nsge->pa_lo = cpu_to_le32(nonemb_cmd->dma & 0xFFFFFFFF);\r\nsge->len = cpu_to_le32(nonemb_cmd->size);\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nunsigned int be_cmd_get_mac_addr(struct beiscsi_hba *phba)\r\n{\r\nstruct be_ctrl_info *ctrl = &phba->ctrl;\r\nstruct be_mcc_wrb *wrb;\r\nstruct be_cmd_req_get_mac_addr *req;\r\nunsigned int tag = 0;\r\nSE_DEBUG(DBG_LVL_8, "In be_cmd_get_mac_addr\n");\r\nspin_lock(&ctrl->mbox_lock);\r\ntag = alloc_mcc_tag(phba);\r\nif (!tag) {\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}\r\nwrb = wrb_from_mccq(phba);\r\nreq = embedded_payload(wrb);\r\nwrb->tag0 |= tag;\r\nbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\r\nbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\r\nOPCODE_COMMON_ISCSI_NTWK_GET_NIC_CONFIG,\r\nsizeof(*req));\r\nbe_mcc_notify(phba);\r\nspin_unlock(&ctrl->mbox_lock);\r\nreturn tag;\r\n}
