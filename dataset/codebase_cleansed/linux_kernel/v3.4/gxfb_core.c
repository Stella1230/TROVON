static void __devinit get_modedb(struct fb_videomode **modedb,\r\nunsigned int *size)\r\n{\r\nif (olpc_has_dcon()) {\r\n*modedb = (struct fb_videomode *) gx_dcon_modedb;\r\n*size = ARRAY_SIZE(gx_dcon_modedb);\r\n} else {\r\n*modedb = (struct fb_videomode *) gx_modedb;\r\n*size = ARRAY_SIZE(gx_modedb);\r\n}\r\n}\r\nstatic void __devinit get_modedb(struct fb_videomode **modedb,\r\nunsigned int *size)\r\n{\r\n*modedb = (struct fb_videomode *) gx_modedb;\r\n*size = ARRAY_SIZE(gx_modedb);\r\n}\r\nstatic int gxfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nif (var->xres > 1600 || var->yres > 1200)\r\nreturn -EINVAL;\r\nif ((var->xres > 1280 || var->yres > 1024) && var->bits_per_pixel > 16)\r\nreturn -EINVAL;\r\nif (var->bits_per_pixel == 32) {\r\nvar->red.offset = 16; var->red.length = 8;\r\nvar->green.offset = 8; var->green.length = 8;\r\nvar->blue.offset = 0; var->blue.length = 8;\r\n} else if (var->bits_per_pixel == 16) {\r\nvar->red.offset = 11; var->red.length = 5;\r\nvar->green.offset = 5; var->green.length = 6;\r\nvar->blue.offset = 0; var->blue.length = 5;\r\n} else if (var->bits_per_pixel == 8) {\r\nvar->red.offset = 0; var->red.length = 8;\r\nvar->green.offset = 0; var->green.length = 8;\r\nvar->blue.offset = 0; var->blue.length = 8;\r\n} else\r\nreturn -EINVAL;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nif (gx_line_delta(var->xres, var->bits_per_pixel) * var->yres > info->fix.smem_len)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int gxfb_set_par(struct fb_info *info)\r\n{\r\nif (info->var.bits_per_pixel > 8)\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nelse\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\ninfo->fix.line_length = gx_line_delta(info->var.xres, info->var.bits_per_pixel);\r\ngx_set_mode(info);\r\nreturn 0;\r\n}\r\nstatic inline u_int chan_to_field(u_int chan, struct fb_bitfield *bf)\r\n{\r\nchan &= 0xffff;\r\nchan >>= 16 - bf->length;\r\nreturn chan << bf->offset;\r\n}\r\nstatic int gxfb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nif (info->var.grayscale) {\r\nred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\r\n}\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\r\nu32 *pal = info->pseudo_palette;\r\nu32 v;\r\nif (regno >= 16)\r\nreturn -EINVAL;\r\nv = chan_to_field(red, &info->var.red);\r\nv |= chan_to_field(green, &info->var.green);\r\nv |= chan_to_field(blue, &info->var.blue);\r\npal[regno] = v;\r\n} else {\r\nif (regno >= 256)\r\nreturn -EINVAL;\r\ngx_set_hw_palette_reg(info, regno, red, green, blue);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gxfb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nreturn gx_blank_display(info, blank_mode);\r\n}\r\nstatic int __devinit gxfb_map_video_memory(struct fb_info *info,\r\nstruct pci_dev *dev)\r\n{\r\nstruct gxfb_par *par = info->par;\r\nint ret;\r\nret = pci_enable_device(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = pci_request_region(dev, 3, "gxfb (video processor)");\r\nif (ret < 0)\r\nreturn ret;\r\npar->vid_regs = pci_ioremap_bar(dev, 3);\r\nif (!par->vid_regs)\r\nreturn -ENOMEM;\r\nret = pci_request_region(dev, 2, "gxfb (display controller)");\r\nif (ret < 0)\r\nreturn ret;\r\npar->dc_regs = pci_ioremap_bar(dev, 2);\r\nif (!par->dc_regs)\r\nreturn -ENOMEM;\r\nret = pci_request_region(dev, 1, "gxfb (graphics processor)");\r\nif (ret < 0)\r\nreturn ret;\r\npar->gp_regs = pci_ioremap_bar(dev, 1);\r\nif (!par->gp_regs)\r\nreturn -ENOMEM;\r\nret = pci_request_region(dev, 0, "gxfb (framebuffer)");\r\nif (ret < 0)\r\nreturn ret;\r\ninfo->fix.smem_start = pci_resource_start(dev, 0);\r\ninfo->fix.smem_len = vram ? vram : gx_frame_buffer_size();\r\ninfo->screen_base = ioremap(info->fix.smem_start, info->fix.smem_len);\r\nif (!info->screen_base)\r\nreturn -ENOMEM;\r\nwrite_dc(par, DC_GLIU0_MEM_OFFSET, info->fix.smem_start & 0xFF000000);\r\ndev_info(&dev->dev, "%d KiB of video memory at 0x%lx\n",\r\ninfo->fix.smem_len / 1024, info->fix.smem_start);\r\nreturn 0;\r\n}\r\nstatic struct fb_info *__devinit gxfb_init_fbinfo(struct device *dev)\r\n{\r\nstruct gxfb_par *par;\r\nstruct fb_info *info;\r\ninfo = framebuffer_alloc(sizeof(struct gxfb_par) + sizeof(u32) * 16,\r\ndev);\r\nif (!info)\r\nreturn NULL;\r\npar = info->par;\r\nstrcpy(info->fix.id, "Geode GX");\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.type_aux = 0;\r\ninfo->fix.xpanstep = 0;\r\ninfo->fix.ypanstep = 0;\r\ninfo->fix.ywrapstep = 0;\r\ninfo->fix.accel = FB_ACCEL_NONE;\r\ninfo->var.nonstd = 0;\r\ninfo->var.activate = FB_ACTIVATE_NOW;\r\ninfo->var.height = -1;\r\ninfo->var.width = -1;\r\ninfo->var.accel_flags = 0;\r\ninfo->var.vmode = FB_VMODE_NONINTERLACED;\r\ninfo->fbops = &gxfb_ops;\r\ninfo->flags = FBINFO_DEFAULT;\r\ninfo->node = -1;\r\ninfo->pseudo_palette = (void *)par + sizeof(struct gxfb_par);\r\ninfo->var.grayscale = 0;\r\nif (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {\r\nframebuffer_release(info);\r\nreturn NULL;\r\n}\r\nreturn info;\r\n}\r\nstatic int gxfb_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(pdev);\r\nif (state.event == PM_EVENT_SUSPEND) {\r\nconsole_lock();\r\ngx_powerdown(info);\r\nfb_set_suspend(info, 1);\r\nconsole_unlock();\r\n}\r\nreturn 0;\r\n}\r\nstatic int gxfb_resume(struct pci_dev *pdev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(pdev);\r\nint ret;\r\nconsole_lock();\r\nret = gx_powerup(info);\r\nif (ret) {\r\nprintk(KERN_ERR "gxfb: power up failed!\n");\r\nreturn ret;\r\n}\r\nfb_set_suspend(info, 0);\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nstatic int __devinit gxfb_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct gxfb_par *par;\r\nstruct fb_info *info;\r\nint ret;\r\nunsigned long val;\r\nstruct fb_videomode *modedb_ptr;\r\nunsigned int modedb_size;\r\ninfo = gxfb_init_fbinfo(&pdev->dev);\r\nif (!info)\r\nreturn -ENOMEM;\r\npar = info->par;\r\nif ((ret = gxfb_map_video_memory(info, pdev)) < 0) {\r\ndev_err(&pdev->dev, "failed to map frame buffer or controller registers\n");\r\ngoto err;\r\n}\r\nrdmsrl(MSR_GX_GLD_MSR_CONFIG, val);\r\nif ((val & MSR_GX_GLD_MSR_CONFIG_FP) == MSR_GX_GLD_MSR_CONFIG_FP)\r\npar->enable_crt = 0;\r\nelse\r\npar->enable_crt = 1;\r\nget_modedb(&modedb_ptr, &modedb_size);\r\nret = fb_find_mode(&info->var, info, mode_option,\r\nmodedb_ptr, modedb_size, NULL, 16);\r\nif (ret == 0 || ret == 4) {\r\ndev_err(&pdev->dev, "could not find valid video mode\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nmemset_io(info->screen_base, 0, info->fix.smem_len);\r\ngxfb_check_var(&info->var, info);\r\ngxfb_set_par(info);\r\npm_set_vt_switch(vt_switch);\r\nif (register_framebuffer(info) < 0) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\npci_set_drvdata(pdev, info);\r\nprintk(KERN_INFO "fb%d: %s frame buffer device\n", info->node, info->fix.id);\r\nreturn 0;\r\nerr:\r\nif (info->screen_base) {\r\niounmap(info->screen_base);\r\npci_release_region(pdev, 0);\r\n}\r\nif (par->vid_regs) {\r\niounmap(par->vid_regs);\r\npci_release_region(pdev, 3);\r\n}\r\nif (par->dc_regs) {\r\niounmap(par->dc_regs);\r\npci_release_region(pdev, 2);\r\n}\r\nif (par->gp_regs) {\r\niounmap(par->gp_regs);\r\npci_release_region(pdev, 1);\r\n}\r\nif (info) {\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __devexit gxfb_remove(struct pci_dev *pdev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(pdev);\r\nstruct gxfb_par *par = info->par;\r\nunregister_framebuffer(info);\r\niounmap((void __iomem *)info->screen_base);\r\npci_release_region(pdev, 0);\r\niounmap(par->vid_regs);\r\npci_release_region(pdev, 3);\r\niounmap(par->dc_regs);\r\npci_release_region(pdev, 2);\r\niounmap(par->gp_regs);\r\npci_release_region(pdev, 1);\r\nfb_dealloc_cmap(&info->cmap);\r\npci_set_drvdata(pdev, NULL);\r\nframebuffer_release(info);\r\n}\r\nstatic int __init gxfb_setup(char *options)\r\n{\r\nchar *opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((opt = strsep(&options, ",")) != NULL) {\r\nif (!*opt)\r\ncontinue;\r\nmode_option = opt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init gxfb_init(void)\r\n{\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("gxfb", &option))\r\nreturn -ENODEV;\r\ngxfb_setup(option);\r\n#endif\r\nreturn pci_register_driver(&gxfb_driver);\r\n}\r\nstatic void __exit gxfb_cleanup(void)\r\n{\r\npci_unregister_driver(&gxfb_driver);\r\n}
