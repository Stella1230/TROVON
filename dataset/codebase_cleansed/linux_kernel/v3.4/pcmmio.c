static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nint sdev_no, chans_left, n_dio_subdevs, n_subdevs, port, asic,\r\nthisasic_chanct = 0;\r\nunsigned long iobase;\r\nunsigned int irq[MAX_ASICS];\r\niobase = it->options[0];\r\nirq[0] = it->options[1];\r\nprintk(KERN_INFO "comedi%d: %s: io: %lx attaching...\n", dev->minor,\r\ndriver.driver_name, iobase);\r\ndev->iobase = iobase;\r\nif (!iobase || !request_region(iobase,\r\nthisboard->total_iosize,\r\ndriver.driver_name)) {\r\nprintk(KERN_ERR "comedi%d: I/O port conflict\n", dev->minor);\r\nreturn -EIO;\r\n}\r\ndev->board_name = thisboard->name;\r\nif (alloc_private(dev, sizeof(struct pcmmio_private)) < 0) {\r\nprintk(KERN_ERR "comedi%d: cannot allocate private data structure\n",\r\ndev->minor);\r\nreturn -ENOMEM;\r\n}\r\nfor (asic = 0; asic < MAX_ASICS; ++asic) {\r\ndevpriv->asics[asic].num = asic;\r\ndevpriv->asics[asic].iobase =\r\ndev->iobase + 16 + asic * ASIC_IOSIZE;\r\ndevpriv->asics[asic].irq = 0;\r\nspin_lock_init(&devpriv->asics[asic].spinlock);\r\n}\r\nchans_left = CHANS_PER_ASIC * thisboard->dio_num_asics;\r\nn_dio_subdevs = CALC_N_DIO_SUBDEVS(chans_left);\r\nn_subdevs = n_dio_subdevs + 2;\r\ndevpriv->sprivs =\r\nkcalloc(n_subdevs, sizeof(struct pcmmio_subdev_private),\r\nGFP_KERNEL);\r\nif (!devpriv->sprivs) {\r\nprintk(KERN_ERR "comedi%d: cannot allocate subdevice private data structures\n",\r\ndev->minor);\r\nreturn -ENOMEM;\r\n}\r\nif (alloc_subdevices(dev, n_subdevs) < 0) {\r\nprintk(KERN_ERR "comedi%d: cannot allocate subdevice data structures\n",\r\ndev->minor);\r\nreturn -ENOMEM;\r\n}\r\nsdev_no = 0;\r\ns = dev->subdevices + sdev_no;\r\ns->private = devpriv->sprivs + sdev_no;\r\ns->maxdata = (1 << thisboard->ai_bits) - 1;\r\ns->range_table = thisboard->ai_range_table;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF;\r\ns->type = COMEDI_SUBD_AI;\r\ns->n_chan = thisboard->n_ai_chans;\r\ns->len_chanlist = s->n_chan;\r\ns->insn_read = thisboard->ai_rinsn;\r\nsubpriv->iobase = dev->iobase + 0;\r\noutb(0, subpriv->iobase + 3);\r\noutb(0, subpriv->iobase + 4 + 3);\r\n++sdev_no;\r\ns = dev->subdevices + sdev_no;\r\ns->private = devpriv->sprivs + sdev_no;\r\ns->maxdata = (1 << thisboard->ao_bits) - 1;\r\ns->range_table = thisboard->ao_range_table;\r\ns->subdev_flags = SDF_READABLE;\r\ns->type = COMEDI_SUBD_AO;\r\ns->n_chan = thisboard->n_ao_chans;\r\ns->len_chanlist = s->n_chan;\r\ns->insn_read = thisboard->ao_rinsn;\r\ns->insn_write = thisboard->ao_winsn;\r\nsubpriv->iobase = dev->iobase + 8;\r\noutb(0, subpriv->iobase + 3);\r\noutb(0, subpriv->iobase + 4 + 3);\r\n++sdev_no;\r\nport = 0;\r\nasic = 0;\r\nfor (; sdev_no < (int)dev->n_subdevices; ++sdev_no) {\r\nint byte_no;\r\ns = dev->subdevices + sdev_no;\r\ns->private = devpriv->sprivs + sdev_no;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->type = COMEDI_SUBD_DIO;\r\ns->insn_bits = pcmmio_dio_insn_bits;\r\ns->insn_config = pcmmio_dio_insn_config;\r\ns->n_chan = min(chans_left, MAX_CHANS_PER_SUBDEV);\r\nsubpriv->dio.intr.asic = -1;\r\nsubpriv->dio.intr.first_chan = -1;\r\nsubpriv->dio.intr.asic_chan = -1;\r\nsubpriv->dio.intr.num_asic_chans = -1;\r\nsubpriv->dio.intr.active = 0;\r\ns->len_chanlist = 1;\r\nfor (byte_no = 0; byte_no < PORTS_PER_SUBDEV; ++byte_no, ++port) {\r\nif (port >= PORTS_PER_ASIC) {\r\nport = 0;\r\n++asic;\r\nthisasic_chanct = 0;\r\n}\r\nsubpriv->iobases[byte_no] =\r\ndevpriv->asics[asic].iobase + port;\r\nif (thisasic_chanct <\r\nCHANS_PER_PORT * INTR_PORTS_PER_ASIC\r\n&& subpriv->dio.intr.asic < 0) {\r\nsubpriv->dio.intr.asic = asic;\r\nsubpriv->dio.intr.active = 0;\r\nsubpriv->dio.intr.stop_count = 0;\r\nsubpriv->dio.intr.first_chan = byte_no * 8;\r\nsubpriv->dio.intr.asic_chan = thisasic_chanct;\r\nsubpriv->dio.intr.num_asic_chans =\r\ns->n_chan - subpriv->dio.intr.first_chan;\r\ns->cancel = pcmmio_cancel;\r\ns->do_cmd = pcmmio_cmd;\r\ns->do_cmdtest = pcmmio_cmdtest;\r\ns->len_chanlist =\r\nsubpriv->dio.intr.num_asic_chans;\r\n}\r\nthisasic_chanct += CHANS_PER_PORT;\r\n}\r\nspin_lock_init(&subpriv->dio.intr.spinlock);\r\nchans_left -= s->n_chan;\r\nif (!chans_left) {\r\nasic = 0;\r\nport = 0;\r\n}\r\n}\r\ninit_asics(dev);\r\nfor (asic = 0; irq[0] && asic < MAX_ASICS; ++asic) {\r\nif (irq[asic]\r\n&& request_irq(irq[asic], interrupt_pcmmio,\r\nIRQF_SHARED, thisboard->name, dev)) {\r\nint i;\r\nfor (i = asic - 1; i >= 0; --i) {\r\nfree_irq(irq[i], dev);\r\ndevpriv->asics[i].irq = irq[i] = 0;\r\n}\r\nirq[asic] = 0;\r\n}\r\ndevpriv->asics[asic].irq = irq[asic];\r\n}\r\ndev->irq = irq[0];\r\nif (irq[0]) {\r\nprintk(KERN_DEBUG "comedi%d: irq: %u\n", dev->minor, irq[0]);\r\nif (thisboard->dio_num_asics == 2 && irq[1])\r\nprintk(KERN_DEBUG "comedi%d: second ASIC irq: %u\n",\r\ndev->minor, irq[1]);\r\n} else {\r\nprintk(KERN_INFO "comedi%d: (IRQ mode disabled)\n", dev->minor);\r\n}\r\nprintk(KERN_INFO "comedi%d: attached\n", dev->minor);\r\nreturn 1;\r\n}\r\nstatic int pcmmio_detach(struct comedi_device *dev)\r\n{\r\nint i;\r\nprintk(KERN_INFO "comedi%d: %s: remove\n", dev->minor, driver.driver_name);\r\nif (dev->iobase)\r\nrelease_region(dev->iobase, thisboard->total_iosize);\r\nfor (i = 0; i < MAX_ASICS; ++i) {\r\nif (devpriv && devpriv->asics[i].irq)\r\nfree_irq(devpriv->asics[i].irq, dev);\r\n}\r\nif (devpriv && devpriv->sprivs)\r\nkfree(devpriv->sprivs);\r\nreturn 0;\r\n}\r\nstatic int pcmmio_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint byte_no;\r\nif (insn->n != 2)\r\nreturn -EINVAL;\r\n#ifdef DAMMIT_ITS_BROKEN\r\nprintk(KERN_DEBUG "write mask: %08x data: %08x\n", data[0], data[1]);\r\n#endif\r\ns->state = 0;\r\nfor (byte_no = 0; byte_no < s->n_chan / CHANS_PER_PORT; ++byte_no) {\r\nunsigned long ioaddr = subpriv->iobases[byte_no],\r\noffset = byte_no * 8;\r\nunsigned char byte = 0,\r\nwrite_mask_byte = (data[0] >> offset) & 0xff,\r\ndata_byte = (data[1] >> offset) & 0xff;\r\nbyte = inb(ioaddr);\r\n#ifdef DAMMIT_ITS_BROKEN\r\nprintk\r\n(KERN_DEBUG "byte %d wmb %02x db %02x offset %02d io %04x,"\r\n" data_in %02x ", byte_no, (unsigned)write_mask_byte,\r\n(unsigned)data_byte, offset, ioaddr, (unsigned)byte);\r\n#endif\r\nif (write_mask_byte) {\r\nbyte &= ~write_mask_byte;\r\nbyte |= ~data_byte & write_mask_byte;\r\noutb(byte, ioaddr);\r\n}\r\n#ifdef DAMMIT_ITS_BROKEN\r\nprintk("data_out_byte %02x\n", (unsigned)byte);\r\n#endif\r\ns->state |= ((unsigned int)byte) << offset;\r\n}\r\ndata[1] = ~s->state;\r\n#ifdef DAMMIT_ITS_BROKEN\r\nprintk(KERN_DEBUG "s->state %08x data_out %08x\n", s->state, data[1]);\r\n#endif\r\nreturn 2;\r\n}\r\nstatic int pcmmio_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint chan = CR_CHAN(insn->chanspec), byte_no = chan / 8, bit_no =\r\nchan % 8;\r\nunsigned long ioaddr;\r\nunsigned char byte;\r\nioaddr = subpriv->iobases[byte_no];\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIO_OUTPUT:\r\ns->io_bits |= 1 << chan;\r\nbreak;\r\ncase INSN_CONFIG_DIO_INPUT:\r\nbyte = inb(ioaddr);\r\nbyte &= ~(1 << bit_no);\r\noutb(byte, ioaddr);\r\ns->io_bits &= ~(1 << chan);\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\ndata[1] =\r\n(s->io_bits & (1 << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;\r\nreturn insn->n;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic void init_asics(struct comedi_device *dev)\r\n{\r\nint asic;\r\nfor (asic = 0; asic < thisboard->dio_num_asics; ++asic) {\r\nint port, page;\r\nunsigned long baseaddr = devpriv->asics[asic].iobase;\r\nswitch_page(dev, asic, 0);\r\nfor (port = 0; port < PORTS_PER_ASIC; ++port)\r\noutb(0, baseaddr + REG_PORT0 + port);\r\nfor (page = 1; page < NUM_PAGES; ++page) {\r\nint reg;\r\nswitch_page(dev, asic, page);\r\nfor (reg = FIRST_PAGED_REG;\r\nreg < FIRST_PAGED_REG + NUM_PAGED_REGS; ++reg)\r\noutb(0, baseaddr + reg);\r\n}\r\nswitch_page(dev, asic, 0);\r\n}\r\n}\r\nstatic void switch_page(struct comedi_device *dev, int asic, int page)\r\n{\r\nif (asic < 0 || asic >= thisboard->dio_num_asics)\r\nreturn;\r\nif (page < 0 || page >= NUM_PAGES)\r\nreturn;\r\ndevpriv->asics[asic].pagelock &= ~REG_PAGE_MASK;\r\ndevpriv->asics[asic].pagelock |= page << REG_PAGE_BITOFFSET;\r\noutb(devpriv->asics[asic].pagelock,\r\ndevpriv->asics[asic].iobase + REG_PAGELOCK);\r\n}\r\nstatic void lock_port(struct comedi_device *dev, int asic, int port)\r\n{\r\nif (asic < 0 || asic >= thisboard->dio_num_asics)\r\nreturn;\r\nif (port < 0 || port >= PORTS_PER_ASIC)\r\nreturn;\r\ndevpriv->asics[asic].pagelock |= 0x1 << port;\r\noutb(devpriv->asics[asic].pagelock,\r\ndevpriv->asics[asic].iobase + REG_PAGELOCK);\r\nreturn;\r\n}\r\nstatic void unlock_port(struct comedi_device *dev, int asic, int port)\r\n{\r\nif (asic < 0 || asic >= thisboard->dio_num_asics)\r\nreturn;\r\nif (port < 0 || port >= PORTS_PER_ASIC)\r\nreturn;\r\ndevpriv->asics[asic].pagelock &= ~(0x1 << port) | REG_LOCK_MASK;\r\noutb(devpriv->asics[asic].pagelock,\r\ndevpriv->asics[asic].iobase + REG_PAGELOCK);\r\n}\r\nstatic irqreturn_t interrupt_pcmmio(int irq, void *d)\r\n{\r\nint asic, got1 = 0;\r\nstruct comedi_device *dev = (struct comedi_device *)d;\r\nfor (asic = 0; asic < MAX_ASICS; ++asic) {\r\nif (irq == devpriv->asics[asic].irq) {\r\nunsigned long flags;\r\nunsigned triggered = 0;\r\nunsigned long iobase = devpriv->asics[asic].iobase;\r\nunsigned char int_pend;\r\nspin_lock_irqsave(&devpriv->asics[asic].spinlock,\r\nflags);\r\nint_pend = inb(iobase + REG_INT_PENDING) & 0x07;\r\nif (int_pend) {\r\nint port;\r\nfor (port = 0; port < INTR_PORTS_PER_ASIC;\r\n++port) {\r\nif (int_pend & (0x1 << port)) {\r\nunsigned char\r\nio_lines_with_edges = 0;\r\nswitch_page(dev, asic,\r\nPAGE_INT_ID);\r\nio_lines_with_edges =\r\ninb(iobase +\r\nREG_INT_ID0 + port);\r\nif (io_lines_with_edges)\r\noutb(0, iobase +\r\nREG_INT_ID0 +\r\nport);\r\ntriggered |=\r\nio_lines_with_edges <<\r\nport * 8;\r\n}\r\n}\r\n++got1;\r\n}\r\nspin_unlock_irqrestore(&devpriv->asics[asic].spinlock,\r\nflags);\r\nif (triggered) {\r\nstruct comedi_subdevice *s;\r\nprintk\r\n(KERN_DEBUG "got edge detect interrupt %d asic %d which_chans: %06x\n",\r\nirq, asic, triggered);\r\nfor (s = dev->subdevices + 2;\r\ns < dev->subdevices + dev->n_subdevices;\r\n++s) {\r\nif (subpriv->dio.intr.asic == asic) {\r\nunsigned long flags;\r\nunsigned oldevents;\r\nspin_lock_irqsave(&subpriv->dio.\r\nintr.spinlock,\r\nflags);\r\noldevents = s->async->events;\r\nif (subpriv->dio.intr.active) {\r\nunsigned mytrig =\r\n((triggered >>\r\nsubpriv->dio.intr.asic_chan)\r\n&\r\n((0x1 << subpriv->\r\ndio.intr.\r\nnum_asic_chans) -\r\n1)) << subpriv->\r\ndio.intr.first_chan;\r\nif (mytrig &\r\nsubpriv->dio.\r\nintr.enabled_mask) {\r\nunsigned int val\r\n= 0;\r\nunsigned int n,\r\nch, len;\r\nlen =\r\ns->\r\nasync->cmd.chanlist_len;\r\nfor (n = 0;\r\nn < len;\r\nn++) {\r\nch = CR_CHAN(s->async->cmd.chanlist[n]);\r\nif (mytrig & (1U << ch))\r\nval |= (1U << n);\r\n}\r\nif (comedi_buf_put(s->async, ((short *)&val)[0])\r\n&&\r\ncomedi_buf_put\r\n(s->async,\r\n((short *)\r\n&val)[1])) {\r\ns->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);\r\n} else {\r\npcmmio_stop_intr\r\n(dev,\r\ns);\r\n}\r\nif (!subpriv->dio.intr.continuous) {\r\nif (subpriv->dio.intr.stop_count > 0) {\r\nsubpriv->dio.intr.stop_count--;\r\nif (subpriv->dio.intr.stop_count == 0) {\r\ns->async->events |= COMEDI_CB_EOA;\r\npcmmio_stop_intr\r\n(dev,\r\ns);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore\r\n(&subpriv->dio.intr.\r\nspinlock, flags);\r\nif (oldevents !=\r\ns->async->events) {\r\ncomedi_event(dev, s);\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif (!got1)\r\nreturn IRQ_NONE;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pcmmio_stop_intr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nint nports, firstport, asic, port;\r\nasic = subpriv->dio.intr.asic;\r\nif (asic < 0)\r\nreturn;\r\nsubpriv->dio.intr.enabled_mask = 0;\r\nsubpriv->dio.intr.active = 0;\r\ns->async->inttrig = 0;\r\nnports = subpriv->dio.intr.num_asic_chans / CHANS_PER_PORT;\r\nfirstport = subpriv->dio.intr.asic_chan / CHANS_PER_PORT;\r\nswitch_page(dev, asic, PAGE_ENAB);\r\nfor (port = firstport; port < firstport + nports; ++port) {\r\noutb(0, devpriv->asics[asic].iobase + REG_ENAB0 + port);\r\n}\r\n}\r\nstatic int pcmmio_start_intr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nif (!subpriv->dio.intr.continuous && subpriv->dio.intr.stop_count == 0) {\r\ns->async->events |= COMEDI_CB_EOA;\r\nsubpriv->dio.intr.active = 0;\r\nreturn 1;\r\n} else {\r\nunsigned bits = 0, pol_bits = 0, n;\r\nint nports, firstport, asic, port;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nasic = subpriv->dio.intr.asic;\r\nif (asic < 0)\r\nreturn 1;\r\nsubpriv->dio.intr.enabled_mask = 0;\r\nsubpriv->dio.intr.active = 1;\r\nnports = subpriv->dio.intr.num_asic_chans / CHANS_PER_PORT;\r\nfirstport = subpriv->dio.intr.asic_chan / CHANS_PER_PORT;\r\nif (cmd->chanlist) {\r\nfor (n = 0; n < cmd->chanlist_len; n++) {\r\nbits |= (1U << CR_CHAN(cmd->chanlist[n]));\r\npol_bits |= (CR_AREF(cmd->chanlist[n])\r\n|| CR_RANGE(cmd->\r\nchanlist[n]) ? 1U : 0U)\r\n<< CR_CHAN(cmd->chanlist[n]);\r\n}\r\n}\r\nbits &= ((0x1 << subpriv->dio.intr.num_asic_chans) -\r\n1) << subpriv->dio.intr.first_chan;\r\nsubpriv->dio.intr.enabled_mask = bits;\r\n{\r\nunsigned char b;\r\noutb(1 << 4, dev->iobase + 3);\r\nb = dev->irq & ((1 << 4) - 1);\r\noutb(b, dev->iobase + 2);\r\n}\r\nswitch_page(dev, asic, PAGE_ENAB);\r\nfor (port = firstport; port < firstport + nports; ++port) {\r\nunsigned enab =\r\nbits >> (subpriv->dio.intr.first_chan + (port -\r\nfirstport)\r\n* 8) & 0xff, pol =\r\npol_bits >> (subpriv->dio.intr.first_chan +\r\n(port - firstport) * 8) & 0xff;\r\noutb(enab,\r\ndevpriv->asics[asic].iobase + REG_ENAB0 + port);\r\nswitch_page(dev, asic, PAGE_POL);\r\noutb(pol,\r\ndevpriv->asics[asic].iobase + REG_ENAB0 + port);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcmmio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);\r\nif (subpriv->dio.intr.active)\r\npcmmio_stop_intr(dev, s);\r\nspin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\npcmmio_inttrig_start_intr(struct comedi_device *dev, struct comedi_subdevice *s,\r\nunsigned int trignum)\r\n{\r\nunsigned long flags;\r\nint event = 0;\r\nif (trignum != 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);\r\ns->async->inttrig = 0;\r\nif (subpriv->dio.intr.active)\r\nevent = pcmmio_start_intr(dev, s);\r\nspin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);\r\nif (event)\r\ncomedi_event(dev, s);\r\nreturn 1;\r\n}\r\nstatic int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned long flags;\r\nint event = 0;\r\nspin_lock_irqsave(&subpriv->dio.intr.spinlock, flags);\r\nsubpriv->dio.intr.active = 1;\r\nswitch (cmd->stop_src) {\r\ncase TRIG_COUNT:\r\nsubpriv->dio.intr.continuous = 0;\r\nsubpriv->dio.intr.stop_count = cmd->stop_arg;\r\nbreak;\r\ndefault:\r\nsubpriv->dio.intr.continuous = 1;\r\nsubpriv->dio.intr.stop_count = 0;\r\nbreak;\r\n}\r\nswitch (cmd->start_src) {\r\ncase TRIG_INT:\r\ns->async->inttrig = pcmmio_inttrig_start_intr;\r\nbreak;\r\ndefault:\r\nevent = pcmmio_start_intr(dev, s);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&subpriv->dio.intr.spinlock, flags);\r\nif (event)\r\ncomedi_event(dev, s);\r\nreturn 0;\r\n}\r\nstatic int\r\npcmmio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nreturn comedi_pcm_cmdtest(dev, s, cmd);\r\n}\r\nstatic int adc_wait_ready(unsigned long iobase)\r\n{\r\nunsigned long retry = 100000;\r\nwhile (retry--)\r\nif (inb(iobase + 3) & 0x80)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n;\r\nunsigned long iobase = subpriv->iobase;\r\nfor (n = 0; n < insn->n; n++) {\r\nunsigned chan = CR_CHAN(insn->chanspec), range =\r\nCR_RANGE(insn->chanspec), aref = CR_AREF(insn->chanspec);\r\nunsigned char command_byte = 0;\r\nunsigned iooffset = 0;\r\nshort sample, adc_adjust = 0;\r\nif (chan > 7)\r\nchan -= 8, iooffset = 4;\r\nif (aref != AREF_DIFF) {\r\naref = AREF_GROUND;\r\ncommand_byte |= 1 << 7;\r\n}\r\nif (range < 2)\r\nadc_adjust = 0x8000;\r\nif (chan % 2) {\r\ncommand_byte |= 1 << 6;\r\n}\r\ncommand_byte |= ((chan / 2) & 0x3) << 4;\r\ncommand_byte |= (range & 0x3) << 2;\r\noutb(command_byte, iobase + iooffset + 2);\r\nadc_wait_ready(iobase + iooffset);\r\noutb(command_byte, iobase + iooffset + 2);\r\nadc_wait_ready(iobase + iooffset);\r\nsample = inb(iobase + iooffset + 0);\r\nsample |= inb(iobase + iooffset + 1) << 8;\r\nsample += adc_adjust;\r\ndata[n] = sample;\r\n}\r\nreturn n;\r\n}\r\nstatic int ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n;\r\nfor (n = 0; n < insn->n; n++) {\r\nunsigned chan = CR_CHAN(insn->chanspec);\r\nif (chan < s->n_chan)\r\ndata[n] = subpriv->ao.shadow_samples[chan];\r\n}\r\nreturn n;\r\n}\r\nstatic int wait_dac_ready(unsigned long iobase)\r\n{\r\nunsigned long retry = 100000L;\r\nwhile (retry--) {\r\nif (inb(iobase + 3) & 0x80)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n;\r\nunsigned iobase = subpriv->iobase, iooffset = 0;\r\nfor (n = 0; n < insn->n; n++) {\r\nunsigned chan = CR_CHAN(insn->chanspec), range =\r\nCR_RANGE(insn->chanspec);\r\nif (chan < s->n_chan) {\r\nunsigned char command_byte = 0, range_byte =\r\nrange & ((1 << 4) - 1);\r\nif (chan >= 4)\r\nchan -= 4, iooffset += 4;\r\noutb(range_byte, iobase + iooffset + 0);\r\noutb(0, iobase + iooffset + 1);\r\ncommand_byte = (chan << 1) | 0x60;\r\noutb(command_byte, iobase + iooffset + 2);\r\nwait_dac_ready(iobase + iooffset);\r\noutb(data[n] & 0xff, iobase + iooffset + 0);\r\noutb((data[n] >> 8) & 0xff, iobase + iooffset + 1);\r\ncommand_byte = 0x70 | (chan << 1);\r\noutb(command_byte, iobase + iooffset + 2);\r\nwait_dac_ready(iobase + iooffset);\r\nsubpriv->ao.shadow_samples[chan] = data[n];\r\n}\r\n}\r\nreturn n;\r\n}\r\nstatic int __init driver_init_module(void)\r\n{\r\nreturn comedi_driver_register(&driver);\r\n}\r\nstatic void __exit driver_cleanup_module(void)\r\n{\r\ncomedi_driver_unregister(&driver);\r\n}
