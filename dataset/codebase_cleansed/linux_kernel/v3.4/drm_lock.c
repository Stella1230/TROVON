int drm_lock(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\nDECLARE_WAITQUEUE(entry, current);\r\nstruct drm_lock *lock = data;\r\nstruct drm_master *master = file_priv->master;\r\nint ret = 0;\r\n++file_priv->lock_count;\r\nif (lock->context == DRM_KERNEL_CONTEXT) {\r\nDRM_ERROR("Process %d using kernel context %d\n",\r\ntask_pid_nr(current), lock->context);\r\nreturn -EINVAL;\r\n}\r\nDRM_DEBUG("%d (pid %d) requests lock (0x%08x), flags = 0x%08x\n",\r\nlock->context, task_pid_nr(current),\r\nmaster->lock.hw_lock->lock, lock->flags);\r\nif (drm_core_check_feature(dev, DRIVER_DMA_QUEUE))\r\nif (lock->context < 0)\r\nreturn -EINVAL;\r\nadd_wait_queue(&master->lock.lock_queue, &entry);\r\nspin_lock_bh(&master->lock.spinlock);\r\nmaster->lock.user_waiters++;\r\nspin_unlock_bh(&master->lock.spinlock);\r\nfor (;;) {\r\n__set_current_state(TASK_INTERRUPTIBLE);\r\nif (!master->lock.hw_lock) {\r\nsend_sig(SIGTERM, current, 0);\r\nret = -EINTR;\r\nbreak;\r\n}\r\nif (drm_lock_take(&master->lock, lock->context)) {\r\nmaster->lock.file_priv = file_priv;\r\nmaster->lock.lock_time = jiffies;\r\natomic_inc(&dev->counts[_DRM_STAT_LOCKS]);\r\nbreak;\r\n}\r\nmutex_unlock(&drm_global_mutex);\r\nschedule();\r\nmutex_lock(&drm_global_mutex);\r\nif (signal_pending(current)) {\r\nret = -EINTR;\r\nbreak;\r\n}\r\n}\r\nspin_lock_bh(&master->lock.spinlock);\r\nmaster->lock.user_waiters--;\r\nspin_unlock_bh(&master->lock.spinlock);\r\n__set_current_state(TASK_RUNNING);\r\nremove_wait_queue(&master->lock.lock_queue, &entry);\r\nDRM_DEBUG("%d %s\n", lock->context,\r\nret ? "interrupted" : "has lock");\r\nif (ret) return ret;\r\nif (!file_priv->is_master) {\r\nsigemptyset(&dev->sigmask);\r\nsigaddset(&dev->sigmask, SIGSTOP);\r\nsigaddset(&dev->sigmask, SIGTSTP);\r\nsigaddset(&dev->sigmask, SIGTTIN);\r\nsigaddset(&dev->sigmask, SIGTTOU);\r\ndev->sigdata.context = lock->context;\r\ndev->sigdata.lock = master->lock.hw_lock;\r\nblock_all_signals(drm_notifier, &dev->sigdata, &dev->sigmask);\r\n}\r\nif (dev->driver->dma_quiescent && (lock->flags & _DRM_LOCK_QUIESCENT))\r\n{\r\nif (dev->driver->dma_quiescent(dev)) {\r\nDRM_DEBUG("%d waiting for DMA quiescent\n",\r\nlock->context);\r\nreturn -EBUSY;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint drm_unlock(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\nstruct drm_lock *lock = data;\r\nstruct drm_master *master = file_priv->master;\r\nif (lock->context == DRM_KERNEL_CONTEXT) {\r\nDRM_ERROR("Process %d using kernel context %d\n",\r\ntask_pid_nr(current), lock->context);\r\nreturn -EINVAL;\r\n}\r\natomic_inc(&dev->counts[_DRM_STAT_UNLOCKS]);\r\nif (drm_lock_free(&master->lock, lock->context)) {\r\n}\r\nunblock_all_signals();\r\nreturn 0;\r\n}\r\nstatic\r\nint drm_lock_take(struct drm_lock_data *lock_data,\r\nunsigned int context)\r\n{\r\nunsigned int old, new, prev;\r\nvolatile unsigned int *lock = &lock_data->hw_lock->lock;\r\nspin_lock_bh(&lock_data->spinlock);\r\ndo {\r\nold = *lock;\r\nif (old & _DRM_LOCK_HELD)\r\nnew = old | _DRM_LOCK_CONT;\r\nelse {\r\nnew = context | _DRM_LOCK_HELD |\r\n((lock_data->user_waiters + lock_data->kernel_waiters > 1) ?\r\n_DRM_LOCK_CONT : 0);\r\n}\r\nprev = cmpxchg(lock, old, new);\r\n} while (prev != old);\r\nspin_unlock_bh(&lock_data->spinlock);\r\nif (_DRM_LOCKING_CONTEXT(old) == context) {\r\nif (old & _DRM_LOCK_HELD) {\r\nif (context != DRM_KERNEL_CONTEXT) {\r\nDRM_ERROR("%d holds heavyweight lock\n",\r\ncontext);\r\n}\r\nreturn 0;\r\n}\r\n}\r\nif ((_DRM_LOCKING_CONTEXT(new)) == context && (new & _DRM_LOCK_HELD)) {\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int drm_lock_transfer(struct drm_lock_data *lock_data,\r\nunsigned int context)\r\n{\r\nunsigned int old, new, prev;\r\nvolatile unsigned int *lock = &lock_data->hw_lock->lock;\r\nlock_data->file_priv = NULL;\r\ndo {\r\nold = *lock;\r\nnew = context | _DRM_LOCK_HELD;\r\nprev = cmpxchg(lock, old, new);\r\n} while (prev != old);\r\nreturn 1;\r\n}\r\nint drm_lock_free(struct drm_lock_data *lock_data, unsigned int context)\r\n{\r\nunsigned int old, new, prev;\r\nvolatile unsigned int *lock = &lock_data->hw_lock->lock;\r\nspin_lock_bh(&lock_data->spinlock);\r\nif (lock_data->kernel_waiters != 0) {\r\ndrm_lock_transfer(lock_data, 0);\r\nlock_data->idle_has_lock = 1;\r\nspin_unlock_bh(&lock_data->spinlock);\r\nreturn 1;\r\n}\r\nspin_unlock_bh(&lock_data->spinlock);\r\ndo {\r\nold = *lock;\r\nnew = _DRM_LOCKING_CONTEXT(old);\r\nprev = cmpxchg(lock, old, new);\r\n} while (prev != old);\r\nif (_DRM_LOCK_IS_HELD(old) && _DRM_LOCKING_CONTEXT(old) != context) {\r\nDRM_ERROR("%d freed heavyweight lock held by %d\n",\r\ncontext, _DRM_LOCKING_CONTEXT(old));\r\nreturn 1;\r\n}\r\nwake_up_interruptible(&lock_data->lock_queue);\r\nreturn 0;\r\n}\r\nstatic int drm_notifier(void *priv)\r\n{\r\nstruct drm_sigdata *s = (struct drm_sigdata *) priv;\r\nunsigned int old, new, prev;\r\nif (!s->lock || !_DRM_LOCK_IS_HELD(s->lock->lock)\r\n|| _DRM_LOCKING_CONTEXT(s->lock->lock) != s->context)\r\nreturn 1;\r\ndo {\r\nold = s->lock->lock;\r\nnew = old | _DRM_LOCK_CONT;\r\nprev = cmpxchg(&s->lock->lock, old, new);\r\n} while (prev != old);\r\nreturn 0;\r\n}\r\nvoid drm_idlelock_take(struct drm_lock_data *lock_data)\r\n{\r\nint ret = 0;\r\nspin_lock_bh(&lock_data->spinlock);\r\nlock_data->kernel_waiters++;\r\nif (!lock_data->idle_has_lock) {\r\nspin_unlock_bh(&lock_data->spinlock);\r\nret = drm_lock_take(lock_data, DRM_KERNEL_CONTEXT);\r\nspin_lock_bh(&lock_data->spinlock);\r\nif (ret == 1)\r\nlock_data->idle_has_lock = 1;\r\n}\r\nspin_unlock_bh(&lock_data->spinlock);\r\n}\r\nvoid drm_idlelock_release(struct drm_lock_data *lock_data)\r\n{\r\nunsigned int old, prev;\r\nvolatile unsigned int *lock = &lock_data->hw_lock->lock;\r\nspin_lock_bh(&lock_data->spinlock);\r\nif (--lock_data->kernel_waiters == 0) {\r\nif (lock_data->idle_has_lock) {\r\ndo {\r\nold = *lock;\r\nprev = cmpxchg(lock, old, DRM_KERNEL_CONTEXT);\r\n} while (prev != old);\r\nwake_up_interruptible(&lock_data->lock_queue);\r\nlock_data->idle_has_lock = 0;\r\n}\r\n}\r\nspin_unlock_bh(&lock_data->spinlock);\r\n}\r\nint drm_i_have_hw_lock(struct drm_device *dev, struct drm_file *file_priv)\r\n{\r\nstruct drm_master *master = file_priv->master;\r\nreturn (file_priv->lock_count && master->lock.hw_lock &&\r\n_DRM_LOCK_IS_HELD(master->lock.hw_lock->lock) &&\r\nmaster->lock.file_priv == file_priv);\r\n}
