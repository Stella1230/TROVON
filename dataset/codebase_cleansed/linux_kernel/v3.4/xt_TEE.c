static struct net *pick_net(struct sk_buff *skb)\r\n{\r\n#ifdef CONFIG_NET_NS\r\nconst struct dst_entry *dst;\r\nif (skb->dev != NULL)\r\nreturn dev_net(skb->dev);\r\ndst = skb_dst(skb);\r\nif (dst != NULL && dst->dev != NULL)\r\nreturn dev_net(dst->dev);\r\n#endif\r\nreturn &init_net;\r\n}\r\nstatic bool\r\ntee_tg_route4(struct sk_buff *skb, const struct xt_tee_tginfo *info)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nstruct net *net = pick_net(skb);\r\nstruct rtable *rt;\r\nstruct flowi4 fl4;\r\nmemset(&fl4, 0, sizeof(fl4));\r\nif (info->priv) {\r\nif (info->priv->oif == -1)\r\nreturn false;\r\nfl4.flowi4_oif = info->priv->oif;\r\n}\r\nfl4.daddr = info->gw.ip;\r\nfl4.flowi4_tos = RT_TOS(iph->tos);\r\nfl4.flowi4_scope = RT_SCOPE_UNIVERSE;\r\nrt = ip_route_output_key(net, &fl4);\r\nif (IS_ERR(rt))\r\nreturn false;\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, &rt->dst);\r\nskb->dev = rt->dst.dev;\r\nskb->protocol = htons(ETH_P_IP);\r\nreturn true;\r\n}\r\nstatic unsigned int\r\ntee_tg4(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_tee_tginfo *info = par->targinfo;\r\nstruct iphdr *iph;\r\nif (percpu_read(tee_active))\r\nreturn XT_CONTINUE;\r\nskb = pskb_copy(skb, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn XT_CONTINUE;\r\n#ifdef WITH_CONNTRACK\r\nnf_conntrack_put(skb->nfct);\r\nskb->nfct = &nf_ct_untracked_get()->ct_general;\r\nskb->nfctinfo = IP_CT_NEW;\r\nnf_conntrack_get(skb->nfct);\r\n#endif\r\niph = ip_hdr(skb);\r\niph->frag_off |= htons(IP_DF);\r\nif (par->hooknum == NF_INET_PRE_ROUTING ||\r\npar->hooknum == NF_INET_LOCAL_IN)\r\n--iph->ttl;\r\nip_send_check(iph);\r\nif (tee_tg_route4(skb, info)) {\r\npercpu_write(tee_active, true);\r\nip_local_out(skb);\r\npercpu_write(tee_active, false);\r\n} else {\r\nkfree_skb(skb);\r\n}\r\nreturn XT_CONTINUE;\r\n}\r\nstatic bool\r\ntee_tg_route6(struct sk_buff *skb, const struct xt_tee_tginfo *info)\r\n{\r\nconst struct ipv6hdr *iph = ipv6_hdr(skb);\r\nstruct net *net = pick_net(skb);\r\nstruct dst_entry *dst;\r\nstruct flowi6 fl6;\r\nmemset(&fl6, 0, sizeof(fl6));\r\nif (info->priv) {\r\nif (info->priv->oif == -1)\r\nreturn false;\r\nfl6.flowi6_oif = info->priv->oif;\r\n}\r\nfl6.daddr = info->gw.in6;\r\nfl6.flowlabel = ((iph->flow_lbl[0] & 0xF) << 16) |\r\n(iph->flow_lbl[1] << 8) | iph->flow_lbl[2];\r\ndst = ip6_route_output(net, NULL, &fl6);\r\nif (dst->error) {\r\ndst_release(dst);\r\nreturn false;\r\n}\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, dst);\r\nskb->dev = dst->dev;\r\nskb->protocol = htons(ETH_P_IPV6);\r\nreturn true;\r\n}\r\nstatic unsigned int\r\ntee_tg6(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_tee_tginfo *info = par->targinfo;\r\nif (percpu_read(tee_active))\r\nreturn XT_CONTINUE;\r\nskb = pskb_copy(skb, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn XT_CONTINUE;\r\n#ifdef WITH_CONNTRACK\r\nnf_conntrack_put(skb->nfct);\r\nskb->nfct = &nf_ct_untracked_get()->ct_general;\r\nskb->nfctinfo = IP_CT_NEW;\r\nnf_conntrack_get(skb->nfct);\r\n#endif\r\nif (par->hooknum == NF_INET_PRE_ROUTING ||\r\npar->hooknum == NF_INET_LOCAL_IN) {\r\nstruct ipv6hdr *iph = ipv6_hdr(skb);\r\n--iph->hop_limit;\r\n}\r\nif (tee_tg_route6(skb, info)) {\r\npercpu_write(tee_active, true);\r\nip6_local_out(skb);\r\npercpu_write(tee_active, false);\r\n} else {\r\nkfree_skb(skb);\r\n}\r\nreturn XT_CONTINUE;\r\n}\r\nstatic int tee_netdev_event(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = ptr;\r\nstruct xt_tee_priv *priv;\r\npriv = container_of(this, struct xt_tee_priv, notifier);\r\nswitch (event) {\r\ncase NETDEV_REGISTER:\r\nif (!strcmp(dev->name, priv->tginfo->oif))\r\npriv->oif = dev->ifindex;\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\nif (dev->ifindex == priv->oif)\r\npriv->oif = -1;\r\nbreak;\r\ncase NETDEV_CHANGENAME:\r\nif (!strcmp(dev->name, priv->tginfo->oif))\r\npriv->oif = dev->ifindex;\r\nelse if (dev->ifindex == priv->oif)\r\npriv->oif = -1;\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int tee_tg_check(const struct xt_tgchk_param *par)\r\n{\r\nstruct xt_tee_tginfo *info = par->targinfo;\r\nstruct xt_tee_priv *priv;\r\nif (memcmp(&info->gw, &tee_zero_address,\r\nsizeof(tee_zero_address)) == 0)\r\nreturn -EINVAL;\r\nif (info->oif[0]) {\r\nif (info->oif[sizeof(info->oif)-1] != '\0')\r\nreturn -EINVAL;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn -ENOMEM;\r\npriv->tginfo = info;\r\npriv->oif = -1;\r\npriv->notifier.notifier_call = tee_netdev_event;\r\ninfo->priv = priv;\r\nregister_netdevice_notifier(&priv->notifier);\r\n} else\r\ninfo->priv = NULL;\r\nreturn 0;\r\n}\r\nstatic void tee_tg_destroy(const struct xt_tgdtor_param *par)\r\n{\r\nstruct xt_tee_tginfo *info = par->targinfo;\r\nif (info->priv) {\r\nunregister_netdevice_notifier(&info->priv->notifier);\r\nkfree(info->priv);\r\n}\r\n}\r\nstatic int __init tee_tg_init(void)\r\n{\r\nreturn xt_register_targets(tee_tg_reg, ARRAY_SIZE(tee_tg_reg));\r\n}\r\nstatic void __exit tee_tg_exit(void)\r\n{\r\nxt_unregister_targets(tee_tg_reg, ARRAY_SIZE(tee_tg_reg));\r\n}
