static inline void\r\n__ipq_enqueue_entry(struct nf_queue_entry *entry)\r\n{\r\nlist_add_tail(&entry->list, &queue_list);\r\nqueue_total++;\r\n}\r\nstatic inline int\r\n__ipq_set_mode(unsigned char mode, unsigned int range)\r\n{\r\nint status = 0;\r\nswitch(mode) {\r\ncase IPQ_COPY_NONE:\r\ncase IPQ_COPY_META:\r\ncopy_mode = mode;\r\ncopy_range = 0;\r\nbreak;\r\ncase IPQ_COPY_PACKET:\r\nif (range > 0xFFFF)\r\nrange = 0xFFFF;\r\ncopy_range = range;\r\ncopy_mode = mode;\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\n}\r\nreturn status;\r\n}\r\nstatic inline void\r\n__ipq_reset(void)\r\n{\r\npeer_pid = 0;\r\nnet_disable_timestamp();\r\n__ipq_set_mode(IPQ_COPY_NONE, 0);\r\n__ipq_flush(NULL, 0);\r\n}\r\nstatic struct nf_queue_entry *\r\nipq_find_dequeue_entry(unsigned long id)\r\n{\r\nstruct nf_queue_entry *entry = NULL, *i;\r\nspin_lock_bh(&queue_lock);\r\nlist_for_each_entry(i, &queue_list, list) {\r\nif ((unsigned long)i == id) {\r\nentry = i;\r\nbreak;\r\n}\r\n}\r\nif (entry) {\r\nlist_del(&entry->list);\r\nqueue_total--;\r\n}\r\nspin_unlock_bh(&queue_lock);\r\nreturn entry;\r\n}\r\nstatic void\r\n__ipq_flush(ipq_cmpfn cmpfn, unsigned long data)\r\n{\r\nstruct nf_queue_entry *entry, *next;\r\nlist_for_each_entry_safe(entry, next, &queue_list, list) {\r\nif (!cmpfn || cmpfn(entry, data)) {\r\nlist_del(&entry->list);\r\nqueue_total--;\r\nnf_reinject(entry, NF_DROP);\r\n}\r\n}\r\n}\r\nstatic void\r\nipq_flush(ipq_cmpfn cmpfn, unsigned long data)\r\n{\r\nspin_lock_bh(&queue_lock);\r\n__ipq_flush(cmpfn, data);\r\nspin_unlock_bh(&queue_lock);\r\n}\r\nstatic struct sk_buff *\r\nipq_build_packet_message(struct nf_queue_entry *entry, int *errp)\r\n{\r\nsk_buff_data_t old_tail;\r\nsize_t size = 0;\r\nsize_t data_len = 0;\r\nstruct sk_buff *skb;\r\nstruct ipq_packet_msg *pmsg;\r\nstruct nlmsghdr *nlh;\r\nstruct timeval tv;\r\nswitch (ACCESS_ONCE(copy_mode)) {\r\ncase IPQ_COPY_META:\r\ncase IPQ_COPY_NONE:\r\nsize = NLMSG_SPACE(sizeof(*pmsg));\r\nbreak;\r\ncase IPQ_COPY_PACKET:\r\nif (entry->skb->ip_summed == CHECKSUM_PARTIAL &&\r\n(*errp = skb_checksum_help(entry->skb)))\r\nreturn NULL;\r\ndata_len = ACCESS_ONCE(copy_range);\r\nif (data_len == 0 || data_len > entry->skb->len)\r\ndata_len = entry->skb->len;\r\nsize = NLMSG_SPACE(sizeof(*pmsg) + data_len);\r\nbreak;\r\ndefault:\r\n*errp = -EINVAL;\r\nreturn NULL;\r\n}\r\nskb = alloc_skb(size, GFP_ATOMIC);\r\nif (!skb)\r\ngoto nlmsg_failure;\r\nold_tail = skb->tail;\r\nnlh = NLMSG_PUT(skb, 0, 0, IPQM_PACKET, size - sizeof(*nlh));\r\npmsg = NLMSG_DATA(nlh);\r\nmemset(pmsg, 0, sizeof(*pmsg));\r\npmsg->packet_id = (unsigned long )entry;\r\npmsg->data_len = data_len;\r\ntv = ktime_to_timeval(entry->skb->tstamp);\r\npmsg->timestamp_sec = tv.tv_sec;\r\npmsg->timestamp_usec = tv.tv_usec;\r\npmsg->mark = entry->skb->mark;\r\npmsg->hook = entry->hook;\r\npmsg->hw_protocol = entry->skb->protocol;\r\nif (entry->indev)\r\nstrcpy(pmsg->indev_name, entry->indev->name);\r\nelse\r\npmsg->indev_name[0] = '\0';\r\nif (entry->outdev)\r\nstrcpy(pmsg->outdev_name, entry->outdev->name);\r\nelse\r\npmsg->outdev_name[0] = '\0';\r\nif (entry->indev && entry->skb->dev &&\r\nentry->skb->mac_header != entry->skb->network_header) {\r\npmsg->hw_type = entry->skb->dev->type;\r\npmsg->hw_addrlen = dev_parse_header(entry->skb, pmsg->hw_addr);\r\n}\r\nif (data_len)\r\nif (skb_copy_bits(entry->skb, 0, pmsg->payload, data_len))\r\nBUG();\r\nnlh->nlmsg_len = skb->tail - old_tail;\r\nreturn skb;\r\nnlmsg_failure:\r\nkfree_skb(skb);\r\n*errp = -EINVAL;\r\nprintk(KERN_ERR "ip6_queue: error creating packet message\n");\r\nreturn NULL;\r\n}\r\nstatic int\r\nipq_enqueue_packet(struct nf_queue_entry *entry, unsigned int queuenum)\r\n{\r\nint status = -EINVAL;\r\nstruct sk_buff *nskb;\r\nif (copy_mode == IPQ_COPY_NONE)\r\nreturn -EAGAIN;\r\nnskb = ipq_build_packet_message(entry, &status);\r\nif (nskb == NULL)\r\nreturn status;\r\nspin_lock_bh(&queue_lock);\r\nif (!peer_pid)\r\ngoto err_out_free_nskb;\r\nif (queue_total >= queue_maxlen) {\r\nqueue_dropped++;\r\nstatus = -ENOSPC;\r\nif (net_ratelimit())\r\nprintk (KERN_WARNING "ip6_queue: fill at %d entries, "\r\n"dropping packet(s). Dropped: %d\n", queue_total,\r\nqueue_dropped);\r\ngoto err_out_free_nskb;\r\n}\r\nstatus = netlink_unicast(ipqnl, nskb, peer_pid, MSG_DONTWAIT);\r\nif (status < 0) {\r\nqueue_user_dropped++;\r\ngoto err_out_unlock;\r\n}\r\n__ipq_enqueue_entry(entry);\r\nspin_unlock_bh(&queue_lock);\r\nreturn status;\r\nerr_out_free_nskb:\r\nkfree_skb(nskb);\r\nerr_out_unlock:\r\nspin_unlock_bh(&queue_lock);\r\nreturn status;\r\n}\r\nstatic int\r\nipq_mangle_ipv6(ipq_verdict_msg_t *v, struct nf_queue_entry *e)\r\n{\r\nint diff;\r\nstruct ipv6hdr *user_iph = (struct ipv6hdr *)v->payload;\r\nstruct sk_buff *nskb;\r\nif (v->data_len < sizeof(*user_iph))\r\nreturn 0;\r\ndiff = v->data_len - e->skb->len;\r\nif (diff < 0) {\r\nif (pskb_trim(e->skb, v->data_len))\r\nreturn -ENOMEM;\r\n} else if (diff > 0) {\r\nif (v->data_len > 0xFFFF)\r\nreturn -EINVAL;\r\nif (diff > skb_tailroom(e->skb)) {\r\nnskb = skb_copy_expand(e->skb, skb_headroom(e->skb),\r\ndiff, GFP_ATOMIC);\r\nif (!nskb) {\r\nprintk(KERN_WARNING "ip6_queue: OOM "\r\n"in mangle, dropping packet\n");\r\nreturn -ENOMEM;\r\n}\r\nkfree_skb(e->skb);\r\ne->skb = nskb;\r\n}\r\nskb_put(e->skb, diff);\r\n}\r\nif (!skb_make_writable(e->skb, v->data_len))\r\nreturn -ENOMEM;\r\nskb_copy_to_linear_data(e->skb, v->payload, v->data_len);\r\ne->skb->ip_summed = CHECKSUM_NONE;\r\nreturn 0;\r\n}\r\nstatic int\r\nipq_set_verdict(struct ipq_verdict_msg *vmsg, unsigned int len)\r\n{\r\nstruct nf_queue_entry *entry;\r\nif (vmsg->value > NF_MAX_VERDICT || vmsg->value == NF_STOLEN)\r\nreturn -EINVAL;\r\nentry = ipq_find_dequeue_entry(vmsg->id);\r\nif (entry == NULL)\r\nreturn -ENOENT;\r\nelse {\r\nint verdict = vmsg->value;\r\nif (vmsg->data_len && vmsg->data_len == len)\r\nif (ipq_mangle_ipv6(vmsg, entry) < 0)\r\nverdict = NF_DROP;\r\nnf_reinject(entry, verdict);\r\nreturn 0;\r\n}\r\n}\r\nstatic int\r\nipq_set_mode(unsigned char mode, unsigned int range)\r\n{\r\nint status;\r\nspin_lock_bh(&queue_lock);\r\nstatus = __ipq_set_mode(mode, range);\r\nspin_unlock_bh(&queue_lock);\r\nreturn status;\r\n}\r\nstatic int\r\nipq_receive_peer(struct ipq_peer_msg *pmsg,\r\nunsigned char type, unsigned int len)\r\n{\r\nint status = 0;\r\nif (len < sizeof(*pmsg))\r\nreturn -EINVAL;\r\nswitch (type) {\r\ncase IPQM_MODE:\r\nstatus = ipq_set_mode(pmsg->msg.mode.value,\r\npmsg->msg.mode.range);\r\nbreak;\r\ncase IPQM_VERDICT:\r\nstatus = ipq_set_verdict(&pmsg->msg.verdict,\r\nlen - sizeof(*pmsg));\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\n}\r\nreturn status;\r\n}\r\nstatic int\r\ndev_cmp(struct nf_queue_entry *entry, unsigned long ifindex)\r\n{\r\nif (entry->indev)\r\nif (entry->indev->ifindex == ifindex)\r\nreturn 1;\r\nif (entry->outdev)\r\nif (entry->outdev->ifindex == ifindex)\r\nreturn 1;\r\n#ifdef CONFIG_BRIDGE_NETFILTER\r\nif (entry->skb->nf_bridge) {\r\nif (entry->skb->nf_bridge->physindev &&\r\nentry->skb->nf_bridge->physindev->ifindex == ifindex)\r\nreturn 1;\r\nif (entry->skb->nf_bridge->physoutdev &&\r\nentry->skb->nf_bridge->physoutdev->ifindex == ifindex)\r\nreturn 1;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void\r\nipq_dev_drop(int ifindex)\r\n{\r\nipq_flush(dev_cmp, ifindex);\r\n}\r\nstatic inline void\r\n__ipq_rcv_skb(struct sk_buff *skb)\r\n{\r\nint status, type, pid, flags;\r\nunsigned int nlmsglen, skblen;\r\nstruct nlmsghdr *nlh;\r\nbool enable_timestamp = false;\r\nskblen = skb->len;\r\nif (skblen < sizeof(*nlh))\r\nreturn;\r\nnlh = nlmsg_hdr(skb);\r\nnlmsglen = nlh->nlmsg_len;\r\nif (nlmsglen < sizeof(*nlh) || skblen < nlmsglen)\r\nreturn;\r\npid = nlh->nlmsg_pid;\r\nflags = nlh->nlmsg_flags;\r\nif(pid <= 0 || !(flags & NLM_F_REQUEST) || flags & NLM_F_MULTI)\r\nRCV_SKB_FAIL(-EINVAL);\r\nif (flags & MSG_TRUNC)\r\nRCV_SKB_FAIL(-ECOMM);\r\ntype = nlh->nlmsg_type;\r\nif (type < NLMSG_NOOP || type >= IPQM_MAX)\r\nRCV_SKB_FAIL(-EINVAL);\r\nif (type <= IPQM_BASE)\r\nreturn;\r\nif (!capable(CAP_NET_ADMIN))\r\nRCV_SKB_FAIL(-EPERM);\r\nspin_lock_bh(&queue_lock);\r\nif (peer_pid) {\r\nif (peer_pid != pid) {\r\nspin_unlock_bh(&queue_lock);\r\nRCV_SKB_FAIL(-EBUSY);\r\n}\r\n} else {\r\nenable_timestamp = true;\r\npeer_pid = pid;\r\n}\r\nspin_unlock_bh(&queue_lock);\r\nif (enable_timestamp)\r\nnet_enable_timestamp();\r\nstatus = ipq_receive_peer(NLMSG_DATA(nlh), type,\r\nnlmsglen - NLMSG_LENGTH(0));\r\nif (status < 0)\r\nRCV_SKB_FAIL(status);\r\nif (flags & NLM_F_ACK)\r\nnetlink_ack(skb, nlh, 0);\r\n}\r\nstatic void\r\nipq_rcv_skb(struct sk_buff *skb)\r\n{\r\nmutex_lock(&ipqnl_mutex);\r\n__ipq_rcv_skb(skb);\r\nmutex_unlock(&ipqnl_mutex);\r\n}\r\nstatic int\r\nipq_rcv_dev_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = ptr;\r\nif (!net_eq(dev_net(dev), &init_net))\r\nreturn NOTIFY_DONE;\r\nif (event == NETDEV_DOWN)\r\nipq_dev_drop(dev->ifindex);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int\r\nipq_rcv_nl_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct netlink_notify *n = ptr;\r\nif (event == NETLINK_URELEASE && n->protocol == NETLINK_IP6_FW) {\r\nspin_lock_bh(&queue_lock);\r\nif ((net_eq(n->net, &init_net)) && (n->pid == peer_pid))\r\n__ipq_reset();\r\nspin_unlock_bh(&queue_lock);\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int ip6_queue_show(struct seq_file *m, void *v)\r\n{\r\nspin_lock_bh(&queue_lock);\r\nseq_printf(m,\r\n"Peer PID : %d\n"\r\n"Copy mode : %hu\n"\r\n"Copy range : %u\n"\r\n"Queue length : %u\n"\r\n"Queue max. length : %u\n"\r\n"Queue dropped : %u\n"\r\n"Netfilter dropped : %u\n",\r\npeer_pid,\r\ncopy_mode,\r\ncopy_range,\r\nqueue_total,\r\nqueue_maxlen,\r\nqueue_dropped,\r\nqueue_user_dropped);\r\nspin_unlock_bh(&queue_lock);\r\nreturn 0;\r\n}\r\nstatic int ip6_queue_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ip6_queue_show, NULL);\r\n}\r\nstatic int __init ip6_queue_init(void)\r\n{\r\nint status = -ENOMEM;\r\nstruct proc_dir_entry *proc __maybe_unused;\r\nnetlink_register_notifier(&ipq_nl_notifier);\r\nipqnl = netlink_kernel_create(&init_net, NETLINK_IP6_FW, 0,\r\nipq_rcv_skb, NULL, THIS_MODULE);\r\nif (ipqnl == NULL) {\r\nprintk(KERN_ERR "ip6_queue: failed to create netlink socket\n");\r\ngoto cleanup_netlink_notifier;\r\n}\r\n#ifdef CONFIG_PROC_FS\r\nproc = proc_create(IPQ_PROC_FS_NAME, 0, init_net.proc_net,\r\n&ip6_queue_proc_fops);\r\nif (!proc) {\r\nprintk(KERN_ERR "ip6_queue: failed to create proc entry\n");\r\ngoto cleanup_ipqnl;\r\n}\r\n#endif\r\nregister_netdevice_notifier(&ipq_dev_notifier);\r\n#ifdef CONFIG_SYSCTL\r\nipq_sysctl_header = register_sysctl_paths(net_ipv6_ctl_path, ipq_table);\r\n#endif\r\nstatus = nf_register_queue_handler(NFPROTO_IPV6, &nfqh);\r\nif (status < 0) {\r\nprintk(KERN_ERR "ip6_queue: failed to register queue handler\n");\r\ngoto cleanup_sysctl;\r\n}\r\nreturn status;\r\ncleanup_sysctl:\r\n#ifdef CONFIG_SYSCTL\r\nunregister_sysctl_table(ipq_sysctl_header);\r\n#endif\r\nunregister_netdevice_notifier(&ipq_dev_notifier);\r\nproc_net_remove(&init_net, IPQ_PROC_FS_NAME);\r\ncleanup_ipqnl: __maybe_unused\r\nnetlink_kernel_release(ipqnl);\r\nmutex_lock(&ipqnl_mutex);\r\nmutex_unlock(&ipqnl_mutex);\r\ncleanup_netlink_notifier:\r\nnetlink_unregister_notifier(&ipq_nl_notifier);\r\nreturn status;\r\n}\r\nstatic void __exit ip6_queue_fini(void)\r\n{\r\nnf_unregister_queue_handlers(&nfqh);\r\nipq_flush(NULL, 0);\r\n#ifdef CONFIG_SYSCTL\r\nunregister_sysctl_table(ipq_sysctl_header);\r\n#endif\r\nunregister_netdevice_notifier(&ipq_dev_notifier);\r\nproc_net_remove(&init_net, IPQ_PROC_FS_NAME);\r\nnetlink_kernel_release(ipqnl);\r\nmutex_lock(&ipqnl_mutex);\r\nmutex_unlock(&ipqnl_mutex);\r\nnetlink_unregister_notifier(&ipq_nl_notifier);\r\n}
