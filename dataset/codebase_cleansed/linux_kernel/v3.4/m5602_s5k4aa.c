int s5k4aa_probe(struct sd *sd)\r\n{\r\nu8 prod_id[6] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\r\nconst u8 expected_prod_id[6] = {0x00, 0x10, 0x00, 0x4b, 0x33, 0x75};\r\nint i, err = 0;\r\ns32 *sensor_settings;\r\nif (force_sensor) {\r\nif (force_sensor == S5K4AA_SENSOR) {\r\npr_info("Forcing a %s sensor\n", s5k4aa.name);\r\ngoto sensor_found;\r\n}\r\nreturn -ENODEV;\r\n}\r\nPDEBUG(D_PROBE, "Probing for a s5k4aa sensor");\r\nfor (i = 0; i < ARRAY_SIZE(preinit_s5k4aa) && !err; i++) {\r\nu8 data[2] = {0x00, 0x00};\r\nswitch (preinit_s5k4aa[i][0]) {\r\ncase BRIDGE:\r\nerr = m5602_write_bridge(sd,\r\npreinit_s5k4aa[i][1],\r\npreinit_s5k4aa[i][2]);\r\nbreak;\r\ncase SENSOR:\r\ndata[0] = preinit_s5k4aa[i][2];\r\nerr = m5602_write_sensor(sd,\r\npreinit_s5k4aa[i][1],\r\ndata, 1);\r\nbreak;\r\ncase SENSOR_LONG:\r\ndata[0] = preinit_s5k4aa[i][2];\r\ndata[1] = preinit_s5k4aa[i][3];\r\nerr = m5602_write_sensor(sd,\r\npreinit_s5k4aa[i][1],\r\ndata, 2);\r\nbreak;\r\ndefault:\r\npr_info("Invalid stream command, exiting init\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (m5602_read_sensor(sd, 0x00, prod_id, 2))\r\nreturn -ENODEV;\r\nif (m5602_read_sensor(sd, 0x02, prod_id+2, 2))\r\nreturn -ENODEV;\r\nif (m5602_read_sensor(sd, 0x04, prod_id+4, 2))\r\nreturn -ENODEV;\r\nif (memcmp(prod_id, expected_prod_id, sizeof(prod_id)))\r\nreturn -ENODEV;\r\nelse\r\npr_info("Detected a s5k4aa sensor\n");\r\nsensor_found:\r\nsensor_settings = kmalloc(\r\nARRAY_SIZE(s5k4aa_ctrls) * sizeof(s32), GFP_KERNEL);\r\nif (!sensor_settings)\r\nreturn -ENOMEM;\r\nsd->gspca_dev.cam.cam_mode = s5k4aa_modes;\r\nsd->gspca_dev.cam.nmodes = ARRAY_SIZE(s5k4aa_modes);\r\nsd->desc->ctrls = s5k4aa_ctrls;\r\nsd->desc->nctrls = ARRAY_SIZE(s5k4aa_ctrls);\r\nfor (i = 0; i < ARRAY_SIZE(s5k4aa_ctrls); i++)\r\nsensor_settings[i] = s5k4aa_ctrls[i].qctrl.default_value;\r\nsd->sensor_priv = sensor_settings;\r\nreturn 0;\r\n}\r\nint s5k4aa_start(struct sd *sd)\r\n{\r\nint i, err = 0;\r\nu8 data[2];\r\nstruct cam *cam = &sd->gspca_dev.cam;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nswitch (cam->cam_mode[sd->gspca_dev.curr_mode].width) {\r\ncase 1280:\r\nPDEBUG(D_V4L2, "Configuring camera for SXGA mode");\r\nfor (i = 0; i < ARRAY_SIZE(SXGA_s5k4aa); i++) {\r\nswitch (SXGA_s5k4aa[i][0]) {\r\ncase BRIDGE:\r\nerr = m5602_write_bridge(sd,\r\nSXGA_s5k4aa[i][1],\r\nSXGA_s5k4aa[i][2]);\r\nbreak;\r\ncase SENSOR:\r\ndata[0] = SXGA_s5k4aa[i][2];\r\nerr = m5602_write_sensor(sd,\r\nSXGA_s5k4aa[i][1],\r\ndata, 1);\r\nbreak;\r\ncase SENSOR_LONG:\r\ndata[0] = SXGA_s5k4aa[i][2];\r\ndata[1] = SXGA_s5k4aa[i][3];\r\nerr = m5602_write_sensor(sd,\r\nSXGA_s5k4aa[i][1],\r\ndata, 2);\r\nbreak;\r\ndefault:\r\npr_err("Invalid stream command, exiting init\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nerr = s5k4aa_set_noise(&sd->gspca_dev, 0);\r\nif (err < 0)\r\nreturn err;\r\nbreak;\r\ncase 640:\r\nPDEBUG(D_V4L2, "Configuring camera for VGA mode");\r\nfor (i = 0; i < ARRAY_SIZE(VGA_s5k4aa); i++) {\r\nswitch (VGA_s5k4aa[i][0]) {\r\ncase BRIDGE:\r\nerr = m5602_write_bridge(sd,\r\nVGA_s5k4aa[i][1],\r\nVGA_s5k4aa[i][2]);\r\nbreak;\r\ncase SENSOR:\r\ndata[0] = VGA_s5k4aa[i][2];\r\nerr = m5602_write_sensor(sd,\r\nVGA_s5k4aa[i][1],\r\ndata, 1);\r\nbreak;\r\ncase SENSOR_LONG:\r\ndata[0] = VGA_s5k4aa[i][2];\r\ndata[1] = VGA_s5k4aa[i][3];\r\nerr = m5602_write_sensor(sd,\r\nVGA_s5k4aa[i][1],\r\ndata, 2);\r\nbreak;\r\ndefault:\r\npr_err("Invalid stream command, exiting init\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nerr = s5k4aa_set_noise(&sd->gspca_dev, 1);\r\nif (err < 0)\r\nreturn err;\r\nbreak;\r\n}\r\nif (err < 0)\r\nreturn err;\r\nerr = s5k4aa_set_exposure(&sd->gspca_dev,\r\nsensor_settings[EXPOSURE_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nerr = s5k4aa_set_gain(&sd->gspca_dev, sensor_settings[GAIN_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nerr = s5k4aa_set_brightness(&sd->gspca_dev,\r\nsensor_settings[BRIGHTNESS_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nerr = s5k4aa_set_noise(&sd->gspca_dev, sensor_settings[NOISE_SUPP_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nerr = s5k4aa_set_vflip(&sd->gspca_dev, sensor_settings[VFLIP_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nreturn s5k4aa_set_hflip(&sd->gspca_dev, sensor_settings[HFLIP_IDX]);\r\n}\r\nint s5k4aa_init(struct sd *sd)\r\n{\r\nint i, err = 0;\r\nfor (i = 0; i < ARRAY_SIZE(init_s5k4aa) && !err; i++) {\r\nu8 data[2] = {0x00, 0x00};\r\nswitch (init_s5k4aa[i][0]) {\r\ncase BRIDGE:\r\nerr = m5602_write_bridge(sd,\r\ninit_s5k4aa[i][1],\r\ninit_s5k4aa[i][2]);\r\nbreak;\r\ncase SENSOR:\r\ndata[0] = init_s5k4aa[i][2];\r\nerr = m5602_write_sensor(sd,\r\ninit_s5k4aa[i][1], data, 1);\r\nbreak;\r\ncase SENSOR_LONG:\r\ndata[0] = init_s5k4aa[i][2];\r\ndata[1] = init_s5k4aa[i][3];\r\nerr = m5602_write_sensor(sd,\r\ninit_s5k4aa[i][1], data, 2);\r\nbreak;\r\ndefault:\r\npr_info("Invalid stream command, exiting init\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (dump_sensor)\r\ns5k4aa_dump_registers(sd);\r\nreturn err;\r\n}\r\nstatic int s5k4aa_get_exposure(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[EXPOSURE_IDX];\r\nPDEBUG(D_V4L2, "Read exposure %d", *val);\r\nreturn 0;\r\n}\r\nstatic int s5k4aa_set_exposure(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nu8 data = S5K4AA_PAGE_MAP_2;\r\nint err;\r\nsensor_settings[EXPOSURE_IDX] = val;\r\nPDEBUG(D_V4L2, "Set exposure to %d", val);\r\nerr = m5602_write_sensor(sd, S5K4AA_PAGE_MAP, &data, 1);\r\nif (err < 0)\r\nreturn err;\r\ndata = (val >> 8) & 0xff;\r\nerr = m5602_write_sensor(sd, S5K4AA_EXPOSURE_HI, &data, 1);\r\nif (err < 0)\r\nreturn err;\r\ndata = val & 0xff;\r\nerr = m5602_write_sensor(sd, S5K4AA_EXPOSURE_LO, &data, 1);\r\nreturn err;\r\n}\r\nstatic int s5k4aa_get_vflip(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[VFLIP_IDX];\r\nPDEBUG(D_V4L2, "Read vertical flip %d", *val);\r\nreturn 0;\r\n}\r\nstatic int s5k4aa_set_vflip(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nu8 data = S5K4AA_PAGE_MAP_2;\r\nint err;\r\nsensor_settings[VFLIP_IDX] = val;\r\nPDEBUG(D_V4L2, "Set vertical flip to %d", val);\r\nerr = m5602_write_sensor(sd, S5K4AA_PAGE_MAP, &data, 1);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_read_sensor(sd, S5K4AA_READ_MODE, &data, 1);\r\nif (err < 0)\r\nreturn err;\r\nif (dmi_check_system(s5k4aa_vflip_dmi_table))\r\nval = !val;\r\ndata = ((data & ~S5K4AA_RM_V_FLIP) | ((val & 0x01) << 7));\r\nerr = m5602_write_sensor(sd, S5K4AA_READ_MODE, &data, 1);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_read_sensor(sd, S5K4AA_ROWSTART_LO, &data, 1);\r\nif (err < 0)\r\nreturn err;\r\nif (val)\r\ndata &= 0xfe;\r\nelse\r\ndata |= 0x01;\r\nerr = m5602_write_sensor(sd, S5K4AA_ROWSTART_LO, &data, 1);\r\nreturn err;\r\n}\r\nstatic int s5k4aa_get_hflip(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[HFLIP_IDX];\r\nPDEBUG(D_V4L2, "Read horizontal flip %d", *val);\r\nreturn 0;\r\n}\r\nstatic int s5k4aa_set_hflip(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nu8 data = S5K4AA_PAGE_MAP_2;\r\nint err;\r\nsensor_settings[HFLIP_IDX] = val;\r\nPDEBUG(D_V4L2, "Set horizontal flip to %d", val);\r\nerr = m5602_write_sensor(sd, S5K4AA_PAGE_MAP, &data, 1);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_read_sensor(sd, S5K4AA_READ_MODE, &data, 1);\r\nif (err < 0)\r\nreturn err;\r\nif (dmi_check_system(s5k4aa_vflip_dmi_table))\r\nval = !val;\r\ndata = ((data & ~S5K4AA_RM_H_FLIP) | ((val & 0x01) << 6));\r\nerr = m5602_write_sensor(sd, S5K4AA_READ_MODE, &data, 1);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_read_sensor(sd, S5K4AA_COLSTART_LO, &data, 1);\r\nif (err < 0)\r\nreturn err;\r\nif (val)\r\ndata &= 0xfe;\r\nelse\r\ndata |= 0x01;\r\nerr = m5602_write_sensor(sd, S5K4AA_COLSTART_LO, &data, 1);\r\nreturn err;\r\n}\r\nstatic int s5k4aa_get_gain(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[GAIN_IDX];\r\nPDEBUG(D_V4L2, "Read gain %d", *val);\r\nreturn 0;\r\n}\r\nstatic int s5k4aa_set_gain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nu8 data = S5K4AA_PAGE_MAP_2;\r\nint err;\r\nsensor_settings[GAIN_IDX] = val;\r\nPDEBUG(D_V4L2, "Set gain to %d", val);\r\nerr = m5602_write_sensor(sd, S5K4AA_PAGE_MAP, &data, 1);\r\nif (err < 0)\r\nreturn err;\r\ndata = val & 0xff;\r\nerr = m5602_write_sensor(sd, S5K4AA_GAIN, &data, 1);\r\nreturn err;\r\n}\r\nstatic int s5k4aa_get_brightness(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[BRIGHTNESS_IDX];\r\nPDEBUG(D_V4L2, "Read brightness %d", *val);\r\nreturn 0;\r\n}\r\nstatic int s5k4aa_set_brightness(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nu8 data = S5K4AA_PAGE_MAP_2;\r\nint err;\r\nsensor_settings[BRIGHTNESS_IDX] = val;\r\nPDEBUG(D_V4L2, "Set brightness to %d", val);\r\nerr = m5602_write_sensor(sd, S5K4AA_PAGE_MAP, &data, 1);\r\nif (err < 0)\r\nreturn err;\r\ndata = val & 0xff;\r\nreturn m5602_write_sensor(sd, S5K4AA_BRIGHTNESS, &data, 1);\r\n}\r\nstatic int s5k4aa_get_noise(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[NOISE_SUPP_IDX];\r\nPDEBUG(D_V4L2, "Read noise %d", *val);\r\nreturn 0;\r\n}\r\nstatic int s5k4aa_set_noise(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nu8 data = S5K4AA_PAGE_MAP_2;\r\nint err;\r\nsensor_settings[NOISE_SUPP_IDX] = val;\r\nPDEBUG(D_V4L2, "Set noise to %d", val);\r\nerr = m5602_write_sensor(sd, S5K4AA_PAGE_MAP, &data, 1);\r\nif (err < 0)\r\nreturn err;\r\ndata = val & 0x01;\r\nreturn m5602_write_sensor(sd, S5K4AA_NOISE_SUPP, &data, 1);\r\n}\r\nvoid s5k4aa_disconnect(struct sd *sd)\r\n{\r\nsd->sensor = NULL;\r\nkfree(sd->sensor_priv);\r\n}\r\nstatic void s5k4aa_dump_registers(struct sd *sd)\r\n{\r\nint address;\r\nu8 page, old_page;\r\nm5602_read_sensor(sd, S5K4AA_PAGE_MAP, &old_page, 1);\r\nfor (page = 0; page < 16; page++) {\r\nm5602_write_sensor(sd, S5K4AA_PAGE_MAP, &page, 1);\r\npr_info("Dumping the s5k4aa register state for page 0x%x\n",\r\npage);\r\nfor (address = 0; address <= 0xff; address++) {\r\nu8 value = 0;\r\nm5602_read_sensor(sd, address, &value, 1);\r\npr_info("register 0x%x contains 0x%x\n",\r\naddress, value);\r\n}\r\n}\r\npr_info("s5k4aa register state dump complete\n");\r\nfor (page = 0; page < 16; page++) {\r\nm5602_write_sensor(sd, S5K4AA_PAGE_MAP, &page, 1);\r\npr_info("Probing for which registers that are read/write for page 0x%x\n",\r\npage);\r\nfor (address = 0; address <= 0xff; address++) {\r\nu8 old_value, ctrl_value, test_value = 0xff;\r\nm5602_read_sensor(sd, address, &old_value, 1);\r\nm5602_write_sensor(sd, address, &test_value, 1);\r\nm5602_read_sensor(sd, address, &ctrl_value, 1);\r\nif (ctrl_value == test_value)\r\npr_info("register 0x%x is writeable\n",\r\naddress);\r\nelse\r\npr_info("register 0x%x is read only\n",\r\naddress);\r\nm5602_write_sensor(sd, address, &old_value, 1);\r\n}\r\n}\r\npr_info("Read/write register probing complete\n");\r\nm5602_write_sensor(sd, S5K4AA_PAGE_MAP, &old_page, 1);\r\n}
