static inline unsigned int\r\nsnd_rme96_playback_ptr(struct rme96 *rme96)\r\n{\r\nreturn (readl(rme96->iobase + RME96_IO_GET_PLAY_POS)\r\n& RME96_RCR_AUDIO_ADDR_MASK) >> rme96->playback_frlog;\r\n}\r\nstatic inline unsigned int\r\nsnd_rme96_capture_ptr(struct rme96 *rme96)\r\n{\r\nreturn (readl(rme96->iobase + RME96_IO_GET_REC_POS)\r\n& RME96_RCR_AUDIO_ADDR_MASK) >> rme96->capture_frlog;\r\n}\r\nstatic int\r\nsnd_rme96_playback_silence(struct snd_pcm_substream *substream,\r\nint channel,\r\nsnd_pcm_uframes_t pos,\r\nsnd_pcm_uframes_t count)\r\n{\r\nstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\r\ncount <<= rme96->playback_frlog;\r\npos <<= rme96->playback_frlog;\r\nmemset_io(rme96->iobase + RME96_IO_PLAY_BUFFER + pos,\r\n0, count);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_playback_copy(struct snd_pcm_substream *substream,\r\nint channel,\r\nsnd_pcm_uframes_t pos,\r\nvoid __user *src,\r\nsnd_pcm_uframes_t count)\r\n{\r\nstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\r\ncount <<= rme96->playback_frlog;\r\npos <<= rme96->playback_frlog;\r\ncopy_from_user_toio(rme96->iobase + RME96_IO_PLAY_BUFFER + pos, src,\r\ncount);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_capture_copy(struct snd_pcm_substream *substream,\r\nint channel,\r\nsnd_pcm_uframes_t pos,\r\nvoid __user *dst,\r\nsnd_pcm_uframes_t count)\r\n{\r\nstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\r\ncount <<= rme96->capture_frlog;\r\npos <<= rme96->capture_frlog;\r\ncopy_to_user_fromio(dst, rme96->iobase + RME96_IO_REC_BUFFER + pos,\r\ncount);\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_rme96_write_SPI(struct rme96 *rme96, u16 val)\r\n{\r\nint i;\r\nfor (i = 0; i < 16; i++) {\r\nif (val & 0x8000) {\r\nrme96->areg |= RME96_AR_CDATA;\r\n} else {\r\nrme96->areg &= ~RME96_AR_CDATA;\r\n}\r\nrme96->areg &= ~(RME96_AR_CCLK | RME96_AR_CLATCH);\r\nwritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\r\nudelay(10);\r\nrme96->areg |= RME96_AR_CCLK;\r\nwritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\r\nudelay(10);\r\nval <<= 1;\r\n}\r\nrme96->areg &= ~(RME96_AR_CCLK | RME96_AR_CDATA);\r\nrme96->areg |= RME96_AR_CLATCH;\r\nwritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\r\nudelay(10);\r\nrme96->areg &= ~RME96_AR_CLATCH;\r\nwritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\r\n}\r\nstatic void\r\nsnd_rme96_apply_dac_volume(struct rme96 *rme96)\r\n{\r\nif (RME96_DAC_IS_1852(rme96)) {\r\nsnd_rme96_write_SPI(rme96, (rme96->vol[0] << 2) | 0x0);\r\nsnd_rme96_write_SPI(rme96, (rme96->vol[1] << 2) | 0x2);\r\n} else if (RME96_DAC_IS_1855(rme96)) {\r\nsnd_rme96_write_SPI(rme96, (rme96->vol[0] & 0x3FF) | 0x000);\r\nsnd_rme96_write_SPI(rme96, (rme96->vol[1] & 0x3FF) | 0x400);\r\n}\r\n}\r\nstatic void\r\nsnd_rme96_reset_dac(struct rme96 *rme96)\r\n{\r\nwritel(rme96->wcreg | RME96_WCR_PD,\r\nrme96->iobase + RME96_IO_CONTROL_REGISTER);\r\nwritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\n}\r\nstatic int\r\nsnd_rme96_getmontracks(struct rme96 *rme96)\r\n{\r\nreturn ((rme96->wcreg >> RME96_WCR_BITPOS_MONITOR_0) & 1) +\r\n(((rme96->wcreg >> RME96_WCR_BITPOS_MONITOR_1) & 1) << 1);\r\n}\r\nstatic int\r\nsnd_rme96_setmontracks(struct rme96 *rme96,\r\nint montracks)\r\n{\r\nif (montracks & 1) {\r\nrme96->wcreg |= RME96_WCR_MONITOR_0;\r\n} else {\r\nrme96->wcreg &= ~RME96_WCR_MONITOR_0;\r\n}\r\nif (montracks & 2) {\r\nrme96->wcreg |= RME96_WCR_MONITOR_1;\r\n} else {\r\nrme96->wcreg &= ~RME96_WCR_MONITOR_1;\r\n}\r\nwritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_getattenuation(struct rme96 *rme96)\r\n{\r\nreturn ((rme96->wcreg >> RME96_WCR_BITPOS_GAIN_0) & 1) +\r\n(((rme96->wcreg >> RME96_WCR_BITPOS_GAIN_1) & 1) << 1);\r\n}\r\nstatic int\r\nsnd_rme96_setattenuation(struct rme96 *rme96,\r\nint attenuation)\r\n{\r\nswitch (attenuation) {\r\ncase 0:\r\nrme96->wcreg = (rme96->wcreg & ~RME96_WCR_GAIN_0) &\r\n~RME96_WCR_GAIN_1;\r\nbreak;\r\ncase 1:\r\nrme96->wcreg = (rme96->wcreg | RME96_WCR_GAIN_0) &\r\n~RME96_WCR_GAIN_1;\r\nbreak;\r\ncase 2:\r\nrme96->wcreg = (rme96->wcreg & ~RME96_WCR_GAIN_0) |\r\nRME96_WCR_GAIN_1;\r\nbreak;\r\ncase 3:\r\nrme96->wcreg = (rme96->wcreg | RME96_WCR_GAIN_0) |\r\nRME96_WCR_GAIN_1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_capture_getrate(struct rme96 *rme96,\r\nint *is_adat)\r\n{\r\nint n, rate;\r\n*is_adat = 0;\r\nif (rme96->areg & RME96_AR_ANALOG) {\r\nn = ((rme96->areg >> RME96_AR_BITPOS_F0) & 1) +\r\n(((rme96->areg >> RME96_AR_BITPOS_F1) & 1) << 1);\r\nswitch (n) {\r\ncase 1:\r\nrate = 32000;\r\nbreak;\r\ncase 2:\r\nrate = 44100;\r\nbreak;\r\ncase 3:\r\nrate = 48000;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nreturn (rme96->areg & RME96_AR_BITPOS_F2) ? rate << 1 : rate;\r\n}\r\nrme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\nif (rme96->rcreg & RME96_RCR_LOCK) {\r\n*is_adat = 1;\r\nif (rme96->rcreg & RME96_RCR_T_OUT) {\r\nreturn 48000;\r\n}\r\nreturn 44100;\r\n}\r\nif (rme96->rcreg & RME96_RCR_VERF) {\r\nreturn -1;\r\n}\r\nn = ((rme96->rcreg >> RME96_RCR_BITPOS_F0) & 1) +\r\n(((rme96->rcreg >> RME96_RCR_BITPOS_F1) & 1) << 1) +\r\n(((rme96->rcreg >> RME96_RCR_BITPOS_F2) & 1) << 2);\r\nswitch (n) {\r\ncase 0:\r\nif (rme96->rcreg & RME96_RCR_T_OUT) {\r\nreturn 64000;\r\n}\r\nreturn -1;\r\ncase 3: return 96000;\r\ncase 4: return 88200;\r\ncase 5: return 48000;\r\ncase 6: return 44100;\r\ncase 7: return 32000;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -1;\r\n}\r\nstatic int\r\nsnd_rme96_playback_getrate(struct rme96 *rme96)\r\n{\r\nint rate, dummy;\r\nif (!(rme96->wcreg & RME96_WCR_MASTER) &&\r\nsnd_rme96_getinputtype(rme96) != RME96_INPUT_ANALOG &&\r\n(rate = snd_rme96_capture_getrate(rme96, &dummy)) > 0)\r\n{\r\nreturn rate;\r\n}\r\nrate = ((rme96->wcreg >> RME96_WCR_BITPOS_FREQ_0) & 1) +\r\n(((rme96->wcreg >> RME96_WCR_BITPOS_FREQ_1) & 1) << 1);\r\nswitch (rate) {\r\ncase 1:\r\nrate = 32000;\r\nbreak;\r\ncase 2:\r\nrate = 44100;\r\nbreak;\r\ncase 3:\r\nrate = 48000;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nreturn (rme96->wcreg & RME96_WCR_DS) ? rate << 1 : rate;\r\n}\r\nstatic int\r\nsnd_rme96_playback_setrate(struct rme96 *rme96,\r\nint rate)\r\n{\r\nint ds;\r\nds = rme96->wcreg & RME96_WCR_DS;\r\nswitch (rate) {\r\ncase 32000:\r\nrme96->wcreg &= ~RME96_WCR_DS;\r\nrme96->wcreg = (rme96->wcreg | RME96_WCR_FREQ_0) &\r\n~RME96_WCR_FREQ_1;\r\nbreak;\r\ncase 44100:\r\nrme96->wcreg &= ~RME96_WCR_DS;\r\nrme96->wcreg = (rme96->wcreg | RME96_WCR_FREQ_1) &\r\n~RME96_WCR_FREQ_0;\r\nbreak;\r\ncase 48000:\r\nrme96->wcreg &= ~RME96_WCR_DS;\r\nrme96->wcreg = (rme96->wcreg | RME96_WCR_FREQ_0) |\r\nRME96_WCR_FREQ_1;\r\nbreak;\r\ncase 64000:\r\nrme96->wcreg |= RME96_WCR_DS;\r\nrme96->wcreg = (rme96->wcreg | RME96_WCR_FREQ_0) &\r\n~RME96_WCR_FREQ_1;\r\nbreak;\r\ncase 88200:\r\nrme96->wcreg |= RME96_WCR_DS;\r\nrme96->wcreg = (rme96->wcreg | RME96_WCR_FREQ_1) &\r\n~RME96_WCR_FREQ_0;\r\nbreak;\r\ncase 96000:\r\nrme96->wcreg |= RME96_WCR_DS;\r\nrme96->wcreg = (rme96->wcreg | RME96_WCR_FREQ_0) |\r\nRME96_WCR_FREQ_1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((!ds && rme96->wcreg & RME96_WCR_DS) ||\r\n(ds && !(rme96->wcreg & RME96_WCR_DS)))\r\n{\r\nsnd_rme96_reset_dac(rme96);\r\n} else {\r\nwritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_capture_analog_setrate(struct rme96 *rme96,\r\nint rate)\r\n{\r\nswitch (rate) {\r\ncase 32000:\r\nrme96->areg = ((rme96->areg | RME96_AR_FREQPAD_0) &\r\n~RME96_AR_FREQPAD_1) & ~RME96_AR_FREQPAD_2;\r\nbreak;\r\ncase 44100:\r\nrme96->areg = ((rme96->areg & ~RME96_AR_FREQPAD_0) |\r\nRME96_AR_FREQPAD_1) & ~RME96_AR_FREQPAD_2;\r\nbreak;\r\ncase 48000:\r\nrme96->areg = ((rme96->areg | RME96_AR_FREQPAD_0) |\r\nRME96_AR_FREQPAD_1) & ~RME96_AR_FREQPAD_2;\r\nbreak;\r\ncase 64000:\r\nif (rme96->rev < 4) {\r\nreturn -EINVAL;\r\n}\r\nrme96->areg = ((rme96->areg | RME96_AR_FREQPAD_0) &\r\n~RME96_AR_FREQPAD_1) | RME96_AR_FREQPAD_2;\r\nbreak;\r\ncase 88200:\r\nif (rme96->rev < 4) {\r\nreturn -EINVAL;\r\n}\r\nrme96->areg = ((rme96->areg & ~RME96_AR_FREQPAD_0) |\r\nRME96_AR_FREQPAD_1) | RME96_AR_FREQPAD_2;\r\nbreak;\r\ncase 96000:\r\nrme96->areg = ((rme96->areg | RME96_AR_FREQPAD_0) |\r\nRME96_AR_FREQPAD_1) | RME96_AR_FREQPAD_2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_setclockmode(struct rme96 *rme96,\r\nint mode)\r\n{\r\nswitch (mode) {\r\ncase RME96_CLOCKMODE_SLAVE:\r\nrme96->wcreg &= ~RME96_WCR_MASTER;\r\nrme96->areg &= ~RME96_AR_WSEL;\r\nbreak;\r\ncase RME96_CLOCKMODE_MASTER:\r\nrme96->wcreg |= RME96_WCR_MASTER;\r\nrme96->areg &= ~RME96_AR_WSEL;\r\nbreak;\r\ncase RME96_CLOCKMODE_WORDCLOCK:\r\nrme96->wcreg |= RME96_WCR_MASTER;\r\nrme96->areg |= RME96_AR_WSEL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\nwritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_getclockmode(struct rme96 *rme96)\r\n{\r\nif (rme96->areg & RME96_AR_WSEL) {\r\nreturn RME96_CLOCKMODE_WORDCLOCK;\r\n}\r\nreturn (rme96->wcreg & RME96_WCR_MASTER) ? RME96_CLOCKMODE_MASTER :\r\nRME96_CLOCKMODE_SLAVE;\r\n}\r\nstatic int\r\nsnd_rme96_setinputtype(struct rme96 *rme96,\r\nint type)\r\n{\r\nint n;\r\nswitch (type) {\r\ncase RME96_INPUT_OPTICAL:\r\nrme96->wcreg = (rme96->wcreg & ~RME96_WCR_INP_0) &\r\n~RME96_WCR_INP_1;\r\nbreak;\r\ncase RME96_INPUT_COAXIAL:\r\nrme96->wcreg = (rme96->wcreg | RME96_WCR_INP_0) &\r\n~RME96_WCR_INP_1;\r\nbreak;\r\ncase RME96_INPUT_INTERNAL:\r\nrme96->wcreg = (rme96->wcreg & ~RME96_WCR_INP_0) |\r\nRME96_WCR_INP_1;\r\nbreak;\r\ncase RME96_INPUT_XLR:\r\nif ((rme96->pci->device != PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST &&\r\nrme96->pci->device != PCI_DEVICE_ID_RME_DIGI96_8_PRO) ||\r\n(rme96->pci->device == PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST &&\r\nrme96->rev > 4))\r\n{\r\nreturn -EINVAL;\r\n}\r\nrme96->wcreg = (rme96->wcreg | RME96_WCR_INP_0) |\r\nRME96_WCR_INP_1;\r\nbreak;\r\ncase RME96_INPUT_ANALOG:\r\nif (!RME96_HAS_ANALOG_IN(rme96)) {\r\nreturn -EINVAL;\r\n}\r\nrme96->areg |= RME96_AR_ANALOG;\r\nwritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\r\nif (rme96->rev < 4) {\r\nif (snd_rme96_capture_getrate(rme96, &n) == 88200) {\r\nsnd_rme96_capture_analog_setrate(rme96, 44100);\r\n}\r\nif (snd_rme96_capture_getrate(rme96, &n) == 64000) {\r\nsnd_rme96_capture_analog_setrate(rme96, 32000);\r\n}\r\n}\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (type != RME96_INPUT_ANALOG && RME96_HAS_ANALOG_IN(rme96)) {\r\nrme96->areg &= ~RME96_AR_ANALOG;\r\nwritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\r\n}\r\nwritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_getinputtype(struct rme96 *rme96)\r\n{\r\nif (rme96->areg & RME96_AR_ANALOG) {\r\nreturn RME96_INPUT_ANALOG;\r\n}\r\nreturn ((rme96->wcreg >> RME96_WCR_BITPOS_INP_0) & 1) +\r\n(((rme96->wcreg >> RME96_WCR_BITPOS_INP_1) & 1) << 1);\r\n}\r\nstatic void\r\nsnd_rme96_setframelog(struct rme96 *rme96,\r\nint n_channels,\r\nint is_playback)\r\n{\r\nint frlog;\r\nif (n_channels == 2) {\r\nfrlog = 1;\r\n} else {\r\nfrlog = 3;\r\n}\r\nif (is_playback) {\r\nfrlog += (rme96->wcreg & RME96_WCR_MODE24) ? 2 : 1;\r\nrme96->playback_frlog = frlog;\r\n} else {\r\nfrlog += (rme96->wcreg & RME96_WCR_MODE24_2) ? 2 : 1;\r\nrme96->capture_frlog = frlog;\r\n}\r\n}\r\nstatic int\r\nsnd_rme96_playback_setformat(struct rme96 *rme96,\r\nint format)\r\n{\r\nswitch (format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nrme96->wcreg &= ~RME96_WCR_MODE24;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nrme96->wcreg |= RME96_WCR_MODE24;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_capture_setformat(struct rme96 *rme96,\r\nint format)\r\n{\r\nswitch (format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nrme96->wcreg &= ~RME96_WCR_MODE24_2;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nrme96->wcreg |= RME96_WCR_MODE24_2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_rme96_set_period_properties(struct rme96 *rme96,\r\nsize_t period_bytes)\r\n{\r\nswitch (period_bytes) {\r\ncase RME96_LARGE_BLOCK_SIZE:\r\nrme96->wcreg &= ~RME96_WCR_ISEL;\r\nbreak;\r\ncase RME96_SMALL_BLOCK_SIZE:\r\nrme96->wcreg |= RME96_WCR_ISEL;\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nbreak;\r\n}\r\nrme96->wcreg &= ~RME96_WCR_IDIS;\r\nwritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\n}\r\nstatic int\r\nsnd_rme96_playback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err, rate, dummy;\r\nruntime->dma_area = (void __force *)(rme96->iobase +\r\nRME96_IO_PLAY_BUFFER);\r\nruntime->dma_addr = rme96->port + RME96_IO_PLAY_BUFFER;\r\nruntime->dma_bytes = RME96_BUFFER_SIZE;\r\nspin_lock_irq(&rme96->lock);\r\nif (!(rme96->wcreg & RME96_WCR_MASTER) &&\r\nsnd_rme96_getinputtype(rme96) != RME96_INPUT_ANALOG &&\r\n(rate = snd_rme96_capture_getrate(rme96, &dummy)) > 0)\r\n{\r\nif ((int)params_rate(params) != rate) {\r\nspin_unlock_irq(&rme96->lock);\r\nreturn -EIO;\r\n}\r\n} else if ((err = snd_rme96_playback_setrate(rme96, params_rate(params))) < 0) {\r\nspin_unlock_irq(&rme96->lock);\r\nreturn err;\r\n}\r\nif ((err = snd_rme96_playback_setformat(rme96, params_format(params))) < 0) {\r\nspin_unlock_irq(&rme96->lock);\r\nreturn err;\r\n}\r\nsnd_rme96_setframelog(rme96, params_channels(params), 1);\r\nif (rme96->capture_periodsize != 0) {\r\nif (params_period_size(params) << rme96->playback_frlog !=\r\nrme96->capture_periodsize)\r\n{\r\nspin_unlock_irq(&rme96->lock);\r\nreturn -EBUSY;\r\n}\r\n}\r\nrme96->playback_periodsize =\r\nparams_period_size(params) << rme96->playback_frlog;\r\nsnd_rme96_set_period_properties(rme96, rme96->playback_periodsize);\r\nif ((rme96->wcreg & RME96_WCR_ADAT) == 0) {\r\nrme96->wcreg &= ~(RME96_WCR_PRO | RME96_WCR_DOLBY | RME96_WCR_EMP);\r\nwritel(rme96->wcreg |= rme96->wcreg_spdif_stream, rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\n}\r\nspin_unlock_irq(&rme96->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_capture_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err, isadat, rate;\r\nruntime->dma_area = (void __force *)(rme96->iobase +\r\nRME96_IO_REC_BUFFER);\r\nruntime->dma_addr = rme96->port + RME96_IO_REC_BUFFER;\r\nruntime->dma_bytes = RME96_BUFFER_SIZE;\r\nspin_lock_irq(&rme96->lock);\r\nif ((err = snd_rme96_capture_setformat(rme96, params_format(params))) < 0) {\r\nspin_unlock_irq(&rme96->lock);\r\nreturn err;\r\n}\r\nif (snd_rme96_getinputtype(rme96) == RME96_INPUT_ANALOG) {\r\nif ((err = snd_rme96_capture_analog_setrate(rme96,\r\nparams_rate(params))) < 0)\r\n{\r\nspin_unlock_irq(&rme96->lock);\r\nreturn err;\r\n}\r\n} else if ((rate = snd_rme96_capture_getrate(rme96, &isadat)) > 0) {\r\nif ((int)params_rate(params) != rate) {\r\nspin_unlock_irq(&rme96->lock);\r\nreturn -EIO;\r\n}\r\nif ((isadat && runtime->hw.channels_min == 2) ||\r\n(!isadat && runtime->hw.channels_min == 8))\r\n{\r\nspin_unlock_irq(&rme96->lock);\r\nreturn -EIO;\r\n}\r\n}\r\nsnd_rme96_setframelog(rme96, params_channels(params), 0);\r\nif (rme96->playback_periodsize != 0) {\r\nif (params_period_size(params) << rme96->capture_frlog !=\r\nrme96->playback_periodsize)\r\n{\r\nspin_unlock_irq(&rme96->lock);\r\nreturn -EBUSY;\r\n}\r\n}\r\nrme96->capture_periodsize =\r\nparams_period_size(params) << rme96->capture_frlog;\r\nsnd_rme96_set_period_properties(rme96, rme96->capture_periodsize);\r\nspin_unlock_irq(&rme96->lock);\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_rme96_playback_start(struct rme96 *rme96,\r\nint from_pause)\r\n{\r\nif (!from_pause) {\r\nwritel(0, rme96->iobase + RME96_IO_RESET_PLAY_POS);\r\n}\r\nrme96->wcreg |= RME96_WCR_START;\r\nwritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\n}\r\nstatic void\r\nsnd_rme96_capture_start(struct rme96 *rme96,\r\nint from_pause)\r\n{\r\nif (!from_pause) {\r\nwritel(0, rme96->iobase + RME96_IO_RESET_REC_POS);\r\n}\r\nrme96->wcreg |= RME96_WCR_START_2;\r\nwritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\n}\r\nstatic void\r\nsnd_rme96_playback_stop(struct rme96 *rme96)\r\n{\r\nrme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\nif (rme96->rcreg & RME96_RCR_IRQ) {\r\nwritel(0, rme96->iobase + RME96_IO_CONFIRM_PLAY_IRQ);\r\n}\r\nrme96->wcreg &= ~RME96_WCR_START;\r\nwritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\n}\r\nstatic void\r\nsnd_rme96_capture_stop(struct rme96 *rme96)\r\n{\r\nrme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\nif (rme96->rcreg & RME96_RCR_IRQ_2) {\r\nwritel(0, rme96->iobase + RME96_IO_CONFIRM_REC_IRQ);\r\n}\r\nrme96->wcreg &= ~RME96_WCR_START_2;\r\nwritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\n}\r\nstatic irqreturn_t\r\nsnd_rme96_interrupt(int irq,\r\nvoid *dev_id)\r\n{\r\nstruct rme96 *rme96 = (struct rme96 *)dev_id;\r\nrme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\nif (!((rme96->rcreg & RME96_RCR_IRQ) ||\r\n(rme96->rcreg & RME96_RCR_IRQ_2)))\r\n{\r\nreturn IRQ_NONE;\r\n}\r\nif (rme96->rcreg & RME96_RCR_IRQ) {\r\nsnd_pcm_period_elapsed(rme96->playback_substream);\r\nwritel(0, rme96->iobase + RME96_IO_CONFIRM_PLAY_IRQ);\r\n}\r\nif (rme96->rcreg & RME96_RCR_IRQ_2) {\r\nsnd_pcm_period_elapsed(rme96->capture_substream);\r\nwritel(0, rme96->iobase + RME96_IO_CONFIRM_REC_IRQ);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nrme96_set_buffer_size_constraint(struct rme96 *rme96,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nunsigned int size;\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\r\nRME96_BUFFER_SIZE, RME96_BUFFER_SIZE);\r\nif ((size = rme96->playback_periodsize) != 0 ||\r\n(size = rme96->capture_periodsize) != 0)\r\nsnd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIOD_BYTES,\r\nsize, size);\r\nelse\r\nsnd_pcm_hw_constraint_list(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_BYTES,\r\n&hw_constraints_period_bytes);\r\n}\r\nstatic int\r\nsnd_rme96_playback_spdif_open(struct snd_pcm_substream *substream)\r\n{\r\nint rate, dummy;\r\nstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nspin_lock_irq(&rme96->lock);\r\nif (rme96->playback_substream != NULL) {\r\nspin_unlock_irq(&rme96->lock);\r\nreturn -EBUSY;\r\n}\r\nrme96->wcreg &= ~RME96_WCR_ADAT;\r\nwritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\nrme96->playback_substream = substream;\r\nspin_unlock_irq(&rme96->lock);\r\nruntime->hw = snd_rme96_playback_spdif_info;\r\nif (!(rme96->wcreg & RME96_WCR_MASTER) &&\r\nsnd_rme96_getinputtype(rme96) != RME96_INPUT_ANALOG &&\r\n(rate = snd_rme96_capture_getrate(rme96, &dummy)) > 0)\r\n{\r\nruntime->hw.rates = snd_pcm_rate_to_rate_bit(rate);\r\nruntime->hw.rate_min = rate;\r\nruntime->hw.rate_max = rate;\r\n}\r\nrme96_set_buffer_size_constraint(rme96, runtime);\r\nrme96->wcreg_spdif_stream = rme96->wcreg_spdif;\r\nrme96->spdif_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(rme96->card, SNDRV_CTL_EVENT_MASK_VALUE |\r\nSNDRV_CTL_EVENT_MASK_INFO, &rme96->spdif_ctl->id);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_capture_spdif_open(struct snd_pcm_substream *substream)\r\n{\r\nint isadat, rate;\r\nstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nruntime->hw = snd_rme96_capture_spdif_info;\r\nif (snd_rme96_getinputtype(rme96) != RME96_INPUT_ANALOG &&\r\n(rate = snd_rme96_capture_getrate(rme96, &isadat)) > 0)\r\n{\r\nif (isadat) {\r\nreturn -EIO;\r\n}\r\nruntime->hw.rates = snd_pcm_rate_to_rate_bit(rate);\r\nruntime->hw.rate_min = rate;\r\nruntime->hw.rate_max = rate;\r\n}\r\nspin_lock_irq(&rme96->lock);\r\nif (rme96->capture_substream != NULL) {\r\nspin_unlock_irq(&rme96->lock);\r\nreturn -EBUSY;\r\n}\r\nrme96->capture_substream = substream;\r\nspin_unlock_irq(&rme96->lock);\r\nrme96_set_buffer_size_constraint(rme96, runtime);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_playback_adat_open(struct snd_pcm_substream *substream)\r\n{\r\nint rate, dummy;\r\nstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nspin_lock_irq(&rme96->lock);\r\nif (rme96->playback_substream != NULL) {\r\nspin_unlock_irq(&rme96->lock);\r\nreturn -EBUSY;\r\n}\r\nrme96->wcreg |= RME96_WCR_ADAT;\r\nwritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\nrme96->playback_substream = substream;\r\nspin_unlock_irq(&rme96->lock);\r\nruntime->hw = snd_rme96_playback_adat_info;\r\nif (!(rme96->wcreg & RME96_WCR_MASTER) &&\r\nsnd_rme96_getinputtype(rme96) != RME96_INPUT_ANALOG &&\r\n(rate = snd_rme96_capture_getrate(rme96, &dummy)) > 0)\r\n{\r\nruntime->hw.rates = snd_pcm_rate_to_rate_bit(rate);\r\nruntime->hw.rate_min = rate;\r\nruntime->hw.rate_max = rate;\r\n}\r\nrme96_set_buffer_size_constraint(rme96, runtime);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_capture_adat_open(struct snd_pcm_substream *substream)\r\n{\r\nint isadat, rate;\r\nstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nruntime->hw = snd_rme96_capture_adat_info;\r\nif (snd_rme96_getinputtype(rme96) == RME96_INPUT_ANALOG) {\r\nreturn -EIO;\r\n}\r\nif ((rate = snd_rme96_capture_getrate(rme96, &isadat)) > 0) {\r\nif (!isadat) {\r\nreturn -EIO;\r\n}\r\nruntime->hw.rates = snd_pcm_rate_to_rate_bit(rate);\r\nruntime->hw.rate_min = rate;\r\nruntime->hw.rate_max = rate;\r\n}\r\nspin_lock_irq(&rme96->lock);\r\nif (rme96->capture_substream != NULL) {\r\nspin_unlock_irq(&rme96->lock);\r\nreturn -EBUSY;\r\n}\r\nrme96->capture_substream = substream;\r\nspin_unlock_irq(&rme96->lock);\r\nrme96_set_buffer_size_constraint(rme96, runtime);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\r\nint spdif = 0;\r\nspin_lock_irq(&rme96->lock);\r\nif (RME96_ISPLAYING(rme96)) {\r\nsnd_rme96_playback_stop(rme96);\r\n}\r\nrme96->playback_substream = NULL;\r\nrme96->playback_periodsize = 0;\r\nspdif = (rme96->wcreg & RME96_WCR_ADAT) == 0;\r\nspin_unlock_irq(&rme96->lock);\r\nif (spdif) {\r\nrme96->spdif_ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(rme96->card, SNDRV_CTL_EVENT_MASK_VALUE |\r\nSNDRV_CTL_EVENT_MASK_INFO, &rme96->spdif_ctl->id);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\r\nspin_lock_irq(&rme96->lock);\r\nif (RME96_ISRECORDING(rme96)) {\r\nsnd_rme96_capture_stop(rme96);\r\n}\r\nrme96->capture_substream = NULL;\r\nrme96->capture_periodsize = 0;\r\nspin_unlock_irq(&rme96->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\r\nspin_lock_irq(&rme96->lock);\r\nif (RME96_ISPLAYING(rme96)) {\r\nsnd_rme96_playback_stop(rme96);\r\n}\r\nwritel(0, rme96->iobase + RME96_IO_RESET_PLAY_POS);\r\nspin_unlock_irq(&rme96->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\r\nspin_lock_irq(&rme96->lock);\r\nif (RME96_ISRECORDING(rme96)) {\r\nsnd_rme96_capture_stop(rme96);\r\n}\r\nwritel(0, rme96->iobase + RME96_IO_RESET_REC_POS);\r\nspin_unlock_irq(&rme96->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_playback_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nif (!RME96_ISPLAYING(rme96)) {\r\nif (substream != rme96->playback_substream) {\r\nreturn -EBUSY;\r\n}\r\nsnd_rme96_playback_start(rme96, 0);\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nif (RME96_ISPLAYING(rme96)) {\r\nif (substream != rme96->playback_substream) {\r\nreturn -EBUSY;\r\n}\r\nsnd_rme96_playback_stop(rme96);\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (RME96_ISPLAYING(rme96)) {\r\nsnd_rme96_playback_stop(rme96);\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (!RME96_ISPLAYING(rme96)) {\r\nsnd_rme96_playback_start(rme96, 1);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_capture_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nif (!RME96_ISRECORDING(rme96)) {\r\nif (substream != rme96->capture_substream) {\r\nreturn -EBUSY;\r\n}\r\nsnd_rme96_capture_start(rme96, 0);\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nif (RME96_ISRECORDING(rme96)) {\r\nif (substream != rme96->capture_substream) {\r\nreturn -EBUSY;\r\n}\r\nsnd_rme96_capture_stop(rme96);\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (RME96_ISRECORDING(rme96)) {\r\nsnd_rme96_capture_stop(rme96);\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (!RME96_ISRECORDING(rme96)) {\r\nsnd_rme96_capture_start(rme96, 1);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_rme96_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\r\nreturn snd_rme96_playback_ptr(rme96);\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_rme96_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct rme96 *rme96 = snd_pcm_substream_chip(substream);\r\nreturn snd_rme96_capture_ptr(rme96);\r\n}\r\nstatic void\r\nsnd_rme96_free(void *private_data)\r\n{\r\nstruct rme96 *rme96 = (struct rme96 *)private_data;\r\nif (rme96 == NULL) {\r\nreturn;\r\n}\r\nif (rme96->irq >= 0) {\r\nsnd_rme96_playback_stop(rme96);\r\nsnd_rme96_capture_stop(rme96);\r\nrme96->areg &= ~RME96_AR_DAC_EN;\r\nwritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\r\nfree_irq(rme96->irq, (void *)rme96);\r\nrme96->irq = -1;\r\n}\r\nif (rme96->iobase) {\r\niounmap(rme96->iobase);\r\nrme96->iobase = NULL;\r\n}\r\nif (rme96->port) {\r\npci_release_regions(rme96->pci);\r\nrme96->port = 0;\r\n}\r\npci_disable_device(rme96->pci);\r\n}\r\nstatic void\r\nsnd_rme96_free_spdif_pcm(struct snd_pcm *pcm)\r\n{\r\nstruct rme96 *rme96 = pcm->private_data;\r\nrme96->spdif_pcm = NULL;\r\n}\r\nstatic void\r\nsnd_rme96_free_adat_pcm(struct snd_pcm *pcm)\r\n{\r\nstruct rme96 *rme96 = pcm->private_data;\r\nrme96->adat_pcm = NULL;\r\n}\r\nstatic int __devinit\r\nsnd_rme96_create(struct rme96 *rme96)\r\n{\r\nstruct pci_dev *pci = rme96->pci;\r\nint err;\r\nrme96->irq = -1;\r\nspin_lock_init(&rme96->lock);\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nif ((err = pci_request_regions(pci, "RME96")) < 0)\r\nreturn err;\r\nrme96->port = pci_resource_start(rme96->pci, 0);\r\nrme96->iobase = ioremap_nocache(rme96->port, RME96_IO_SIZE);\r\nif (!rme96->iobase) {\r\nsnd_printk(KERN_ERR "unable to remap memory region 0x%lx-0x%lx\n", rme96->port, rme96->port + RME96_IO_SIZE - 1);\r\nreturn -ENOMEM;\r\n}\r\nif (request_irq(pci->irq, snd_rme96_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, rme96)) {\r\nsnd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);\r\nreturn -EBUSY;\r\n}\r\nrme96->irq = pci->irq;\r\npci_read_config_byte(pci, 8, &rme96->rev);\r\nif ((err = snd_pcm_new(rme96->card, "Digi96 IEC958", 0,\r\n1, 1, &rme96->spdif_pcm)) < 0)\r\n{\r\nreturn err;\r\n}\r\nrme96->spdif_pcm->private_data = rme96;\r\nrme96->spdif_pcm->private_free = snd_rme96_free_spdif_pcm;\r\nstrcpy(rme96->spdif_pcm->name, "Digi96 IEC958");\r\nsnd_pcm_set_ops(rme96->spdif_pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_rme96_playback_spdif_ops);\r\nsnd_pcm_set_ops(rme96->spdif_pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_rme96_capture_spdif_ops);\r\nrme96->spdif_pcm->info_flags = 0;\r\nif (pci->device == PCI_DEVICE_ID_RME_DIGI96) {\r\nrme96->adat_pcm = NULL;\r\n} else {\r\nif ((err = snd_pcm_new(rme96->card, "Digi96 ADAT", 1,\r\n1, 1, &rme96->adat_pcm)) < 0)\r\n{\r\nreturn err;\r\n}\r\nrme96->adat_pcm->private_data = rme96;\r\nrme96->adat_pcm->private_free = snd_rme96_free_adat_pcm;\r\nstrcpy(rme96->adat_pcm->name, "Digi96 ADAT");\r\nsnd_pcm_set_ops(rme96->adat_pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_rme96_playback_adat_ops);\r\nsnd_pcm_set_ops(rme96->adat_pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_rme96_capture_adat_ops);\r\nrme96->adat_pcm->info_flags = 0;\r\n}\r\nrme96->playback_periodsize = 0;\r\nrme96->capture_periodsize = 0;\r\nsnd_rme96_playback_stop(rme96);\r\nsnd_rme96_capture_stop(rme96);\r\nrme96->wcreg =\r\nRME96_WCR_FREQ_1 |\r\nRME96_WCR_SEL |\r\nRME96_WCR_MASTER |\r\nRME96_WCR_INP_0;\r\nrme96->areg = RME96_AR_FREQPAD_1;\r\nwritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\nwritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\r\nwritel(rme96->areg | RME96_AR_PD2,\r\nrme96->iobase + RME96_IO_ADDITIONAL_REG);\r\nwritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\r\nsnd_rme96_reset_dac(rme96);\r\nrme96->areg |= RME96_AR_DAC_EN;\r\nwritel(rme96->areg, rme96->iobase + RME96_IO_ADDITIONAL_REG);\r\nwritel(0, rme96->iobase + RME96_IO_RESET_PLAY_POS);\r\nwritel(0, rme96->iobase + RME96_IO_RESET_REC_POS);\r\nrme96->vol[0] = rme96->vol[1] = 0;\r\nif (RME96_HAS_ANALOG_OUT(rme96)) {\r\nsnd_rme96_apply_dac_volume(rme96);\r\n}\r\nif ((err = snd_rme96_create_switches(rme96->card, rme96)) < 0) {\r\nreturn err;\r\n}\r\nsnd_rme96_proc_init(rme96);\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_rme96_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\r\n{\r\nint n;\r\nstruct rme96 *rme96 = entry->private_data;\r\nrme96->rcreg = readl(rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\nsnd_iprintf(buffer, rme96->card->longname);\r\nsnd_iprintf(buffer, " (index #%d)\n", rme96->card->number + 1);\r\nsnd_iprintf(buffer, "\nGeneral settings\n");\r\nif (rme96->wcreg & RME96_WCR_IDIS) {\r\nsnd_iprintf(buffer, " period size: N/A (interrupts "\r\n"disabled)\n");\r\n} else if (rme96->wcreg & RME96_WCR_ISEL) {\r\nsnd_iprintf(buffer, " period size: 2048 bytes\n");\r\n} else {\r\nsnd_iprintf(buffer, " period size: 8192 bytes\n");\r\n}\r\nsnd_iprintf(buffer, "\nInput settings\n");\r\nswitch (snd_rme96_getinputtype(rme96)) {\r\ncase RME96_INPUT_OPTICAL:\r\nsnd_iprintf(buffer, " input: optical");\r\nbreak;\r\ncase RME96_INPUT_COAXIAL:\r\nsnd_iprintf(buffer, " input: coaxial");\r\nbreak;\r\ncase RME96_INPUT_INTERNAL:\r\nsnd_iprintf(buffer, " input: internal");\r\nbreak;\r\ncase RME96_INPUT_XLR:\r\nsnd_iprintf(buffer, " input: XLR");\r\nbreak;\r\ncase RME96_INPUT_ANALOG:\r\nsnd_iprintf(buffer, " input: analog");\r\nbreak;\r\n}\r\nif (snd_rme96_capture_getrate(rme96, &n) < 0) {\r\nsnd_iprintf(buffer, "\n sample rate: no valid signal\n");\r\n} else {\r\nif (n) {\r\nsnd_iprintf(buffer, " (8 channels)\n");\r\n} else {\r\nsnd_iprintf(buffer, " (2 channels)\n");\r\n}\r\nsnd_iprintf(buffer, " sample rate: %d Hz\n",\r\nsnd_rme96_capture_getrate(rme96, &n));\r\n}\r\nif (rme96->wcreg & RME96_WCR_MODE24_2) {\r\nsnd_iprintf(buffer, " sample format: 24 bit\n");\r\n} else {\r\nsnd_iprintf(buffer, " sample format: 16 bit\n");\r\n}\r\nsnd_iprintf(buffer, "\nOutput settings\n");\r\nif (rme96->wcreg & RME96_WCR_SEL) {\r\nsnd_iprintf(buffer, " output signal: normal playback\n");\r\n} else {\r\nsnd_iprintf(buffer, " output signal: same as input\n");\r\n}\r\nsnd_iprintf(buffer, " sample rate: %d Hz\n",\r\nsnd_rme96_playback_getrate(rme96));\r\nif (rme96->wcreg & RME96_WCR_MODE24) {\r\nsnd_iprintf(buffer, " sample format: 24 bit\n");\r\n} else {\r\nsnd_iprintf(buffer, " sample format: 16 bit\n");\r\n}\r\nif (rme96->areg & RME96_AR_WSEL) {\r\nsnd_iprintf(buffer, " sample clock source: word clock\n");\r\n} else if (rme96->wcreg & RME96_WCR_MASTER) {\r\nsnd_iprintf(buffer, " sample clock source: internal\n");\r\n} else if (snd_rme96_getinputtype(rme96) == RME96_INPUT_ANALOG) {\r\nsnd_iprintf(buffer, " sample clock source: autosync (internal anyway due to analog input setting)\n");\r\n} else if (snd_rme96_capture_getrate(rme96, &n) < 0) {\r\nsnd_iprintf(buffer, " sample clock source: autosync (internal anyway due to no valid signal)\n");\r\n} else {\r\nsnd_iprintf(buffer, " sample clock source: autosync\n");\r\n}\r\nif (rme96->wcreg & RME96_WCR_PRO) {\r\nsnd_iprintf(buffer, " format: AES/EBU (professional)\n");\r\n} else {\r\nsnd_iprintf(buffer, " format: IEC958 (consumer)\n");\r\n}\r\nif (rme96->wcreg & RME96_WCR_EMP) {\r\nsnd_iprintf(buffer, " emphasis: on\n");\r\n} else {\r\nsnd_iprintf(buffer, " emphasis: off\n");\r\n}\r\nif (rme96->wcreg & RME96_WCR_DOLBY) {\r\nsnd_iprintf(buffer, " non-audio (dolby): on\n");\r\n} else {\r\nsnd_iprintf(buffer, " non-audio (dolby): off\n");\r\n}\r\nif (RME96_HAS_ANALOG_IN(rme96)) {\r\nsnd_iprintf(buffer, "\nAnalog output settings\n");\r\nswitch (snd_rme96_getmontracks(rme96)) {\r\ncase RME96_MONITOR_TRACKS_1_2:\r\nsnd_iprintf(buffer, " monitored ADAT tracks: 1+2\n");\r\nbreak;\r\ncase RME96_MONITOR_TRACKS_3_4:\r\nsnd_iprintf(buffer, " monitored ADAT tracks: 3+4\n");\r\nbreak;\r\ncase RME96_MONITOR_TRACKS_5_6:\r\nsnd_iprintf(buffer, " monitored ADAT tracks: 5+6\n");\r\nbreak;\r\ncase RME96_MONITOR_TRACKS_7_8:\r\nsnd_iprintf(buffer, " monitored ADAT tracks: 7+8\n");\r\nbreak;\r\n}\r\nswitch (snd_rme96_getattenuation(rme96)) {\r\ncase RME96_ATTENUATION_0:\r\nsnd_iprintf(buffer, " attenuation: 0 dB\n");\r\nbreak;\r\ncase RME96_ATTENUATION_6:\r\nsnd_iprintf(buffer, " attenuation: -6 dB\n");\r\nbreak;\r\ncase RME96_ATTENUATION_12:\r\nsnd_iprintf(buffer, " attenuation: -12 dB\n");\r\nbreak;\r\ncase RME96_ATTENUATION_18:\r\nsnd_iprintf(buffer, " attenuation: -18 dB\n");\r\nbreak;\r\n}\r\nsnd_iprintf(buffer, " volume left: %u\n", rme96->vol[0]);\r\nsnd_iprintf(buffer, " volume right: %u\n", rme96->vol[1]);\r\n}\r\n}\r\nstatic void __devinit\r\nsnd_rme96_proc_init(struct rme96 *rme96)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (! snd_card_proc_new(rme96->card, "rme96", &entry))\r\nsnd_info_set_text_ops(entry, rme96, snd_rme96_proc_read);\r\n}\r\nstatic int\r\nsnd_rme96_get_loopback_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&rme96->lock);\r\nucontrol->value.integer.value[0] = rme96->wcreg & RME96_WCR_SEL ? 0 : 1;\r\nspin_unlock_irq(&rme96->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_put_loopback_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint change;\r\nval = ucontrol->value.integer.value[0] ? 0 : RME96_WCR_SEL;\r\nspin_lock_irq(&rme96->lock);\r\nval = (rme96->wcreg & ~RME96_WCR_SEL) | val;\r\nchange = val != rme96->wcreg;\r\nrme96->wcreg = val;\r\nwritel(val, rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\nspin_unlock_irq(&rme96->lock);\r\nreturn change;\r\n}\r\nstatic int\r\nsnd_rme96_info_inputtype_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *_texts[5] = { "Optical", "Coaxial", "Internal", "XLR", "Analog" };\r\nstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\r\nchar *texts[5] = { _texts[0], _texts[1], _texts[2], _texts[3], _texts[4] };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nswitch (rme96->pci->device) {\r\ncase PCI_DEVICE_ID_RME_DIGI96:\r\ncase PCI_DEVICE_ID_RME_DIGI96_8:\r\nuinfo->value.enumerated.items = 3;\r\nbreak;\r\ncase PCI_DEVICE_ID_RME_DIGI96_8_PRO:\r\nuinfo->value.enumerated.items = 4;\r\nbreak;\r\ncase PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST:\r\nif (rme96->rev > 4) {\r\nuinfo->value.enumerated.items = 4;\r\ntexts[3] = _texts[4];\r\n} else {\r\nuinfo->value.enumerated.items = 5;\r\n}\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nbreak;\r\n}\r\nif (uinfo->value.enumerated.item > uinfo->value.enumerated.items - 1) {\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\n}\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_get_inputtype_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\r\nunsigned int items = 3;\r\nspin_lock_irq(&rme96->lock);\r\nucontrol->value.enumerated.item[0] = snd_rme96_getinputtype(rme96);\r\nswitch (rme96->pci->device) {\r\ncase PCI_DEVICE_ID_RME_DIGI96:\r\ncase PCI_DEVICE_ID_RME_DIGI96_8:\r\nitems = 3;\r\nbreak;\r\ncase PCI_DEVICE_ID_RME_DIGI96_8_PRO:\r\nitems = 4;\r\nbreak;\r\ncase PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST:\r\nif (rme96->rev > 4) {\r\nif (ucontrol->value.enumerated.item[0] == RME96_INPUT_ANALOG) {\r\nucontrol->value.enumerated.item[0] = RME96_INPUT_XLR;\r\n}\r\nitems = 4;\r\n} else {\r\nitems = 5;\r\n}\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nbreak;\r\n}\r\nif (ucontrol->value.enumerated.item[0] >= items) {\r\nucontrol->value.enumerated.item[0] = items - 1;\r\n}\r\nspin_unlock_irq(&rme96->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_put_inputtype_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint change, items = 3;\r\nswitch (rme96->pci->device) {\r\ncase PCI_DEVICE_ID_RME_DIGI96:\r\ncase PCI_DEVICE_ID_RME_DIGI96_8:\r\nitems = 3;\r\nbreak;\r\ncase PCI_DEVICE_ID_RME_DIGI96_8_PRO:\r\nitems = 4;\r\nbreak;\r\ncase PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST:\r\nif (rme96->rev > 4) {\r\nitems = 4;\r\n} else {\r\nitems = 5;\r\n}\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nbreak;\r\n}\r\nval = ucontrol->value.enumerated.item[0] % items;\r\nif (rme96->pci->device == PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST && rme96->rev > 4) {\r\nif (val == RME96_INPUT_XLR) {\r\nval = RME96_INPUT_ANALOG;\r\n}\r\n}\r\nspin_lock_irq(&rme96->lock);\r\nchange = (int)val != snd_rme96_getinputtype(rme96);\r\nsnd_rme96_setinputtype(rme96, val);\r\nspin_unlock_irq(&rme96->lock);\r\nreturn change;\r\n}\r\nstatic int\r\nsnd_rme96_info_clockmode_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[3] = { "AutoSync", "Internal", "Word" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 3;\r\nif (uinfo->value.enumerated.item > 2) {\r\nuinfo->value.enumerated.item = 2;\r\n}\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_get_clockmode_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&rme96->lock);\r\nucontrol->value.enumerated.item[0] = snd_rme96_getclockmode(rme96);\r\nspin_unlock_irq(&rme96->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_put_clockmode_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint change;\r\nval = ucontrol->value.enumerated.item[0] % 3;\r\nspin_lock_irq(&rme96->lock);\r\nchange = (int)val != snd_rme96_getclockmode(rme96);\r\nsnd_rme96_setclockmode(rme96, val);\r\nspin_unlock_irq(&rme96->lock);\r\nreturn change;\r\n}\r\nstatic int\r\nsnd_rme96_info_attenuation_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[4] = { "0 dB", "-6 dB", "-12 dB", "-18 dB" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 4;\r\nif (uinfo->value.enumerated.item > 3) {\r\nuinfo->value.enumerated.item = 3;\r\n}\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_get_attenuation_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&rme96->lock);\r\nucontrol->value.enumerated.item[0] = snd_rme96_getattenuation(rme96);\r\nspin_unlock_irq(&rme96->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_put_attenuation_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint change;\r\nval = ucontrol->value.enumerated.item[0] % 4;\r\nspin_lock_irq(&rme96->lock);\r\nchange = (int)val != snd_rme96_getattenuation(rme96);\r\nsnd_rme96_setattenuation(rme96, val);\r\nspin_unlock_irq(&rme96->lock);\r\nreturn change;\r\n}\r\nstatic int\r\nsnd_rme96_info_montracks_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[4] = { "1+2", "3+4", "5+6", "7+8" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 4;\r\nif (uinfo->value.enumerated.item > 3) {\r\nuinfo->value.enumerated.item = 3;\r\n}\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_get_montracks_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&rme96->lock);\r\nucontrol->value.enumerated.item[0] = snd_rme96_getmontracks(rme96);\r\nspin_unlock_irq(&rme96->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_put_montracks_control(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint change;\r\nval = ucontrol->value.enumerated.item[0] % 4;\r\nspin_lock_irq(&rme96->lock);\r\nchange = (int)val != snd_rme96_getmontracks(rme96);\r\nsnd_rme96_setmontracks(rme96, val);\r\nspin_unlock_irq(&rme96->lock);\r\nreturn change;\r\n}\r\nstatic u32 snd_rme96_convert_from_aes(struct snd_aes_iec958 *aes)\r\n{\r\nu32 val = 0;\r\nval |= (aes->status[0] & IEC958_AES0_PROFESSIONAL) ? RME96_WCR_PRO : 0;\r\nval |= (aes->status[0] & IEC958_AES0_NONAUDIO) ? RME96_WCR_DOLBY : 0;\r\nif (val & RME96_WCR_PRO)\r\nval |= (aes->status[0] & IEC958_AES0_PRO_EMPHASIS_5015) ? RME96_WCR_EMP : 0;\r\nelse\r\nval |= (aes->status[0] & IEC958_AES0_CON_EMPHASIS_5015) ? RME96_WCR_EMP : 0;\r\nreturn val;\r\n}\r\nstatic void snd_rme96_convert_to_aes(struct snd_aes_iec958 *aes, u32 val)\r\n{\r\naes->status[0] = ((val & RME96_WCR_PRO) ? IEC958_AES0_PROFESSIONAL : 0) |\r\n((val & RME96_WCR_DOLBY) ? IEC958_AES0_NONAUDIO : 0);\r\nif (val & RME96_WCR_PRO)\r\naes->status[0] |= (val & RME96_WCR_EMP) ? IEC958_AES0_PRO_EMPHASIS_5015 : 0;\r\nelse\r\naes->status[0] |= (val & RME96_WCR_EMP) ? IEC958_AES0_CON_EMPHASIS_5015 : 0;\r\n}\r\nstatic int snd_rme96_control_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_rme96_control_spdif_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\r\nsnd_rme96_convert_to_aes(&ucontrol->value.iec958, rme96->wcreg_spdif);\r\nreturn 0;\r\n}\r\nstatic int snd_rme96_control_spdif_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nu32 val;\r\nval = snd_rme96_convert_from_aes(&ucontrol->value.iec958);\r\nspin_lock_irq(&rme96->lock);\r\nchange = val != rme96->wcreg_spdif;\r\nrme96->wcreg_spdif = val;\r\nspin_unlock_irq(&rme96->lock);\r\nreturn change;\r\n}\r\nstatic int snd_rme96_control_spdif_stream_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_rme96_control_spdif_stream_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\r\nsnd_rme96_convert_to_aes(&ucontrol->value.iec958, rme96->wcreg_spdif_stream);\r\nreturn 0;\r\n}\r\nstatic int snd_rme96_control_spdif_stream_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nu32 val;\r\nval = snd_rme96_convert_from_aes(&ucontrol->value.iec958);\r\nspin_lock_irq(&rme96->lock);\r\nchange = val != rme96->wcreg_spdif_stream;\r\nrme96->wcreg_spdif_stream = val;\r\nrme96->wcreg &= ~(RME96_WCR_PRO | RME96_WCR_DOLBY | RME96_WCR_EMP);\r\nrme96->wcreg |= val;\r\nwritel(rme96->wcreg, rme96->iobase + RME96_IO_CONTROL_REGISTER);\r\nspin_unlock_irq(&rme96->lock);\r\nreturn change;\r\n}\r\nstatic int snd_rme96_control_spdif_mask_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_rme96_control_spdif_mask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = kcontrol->private_value;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_dac_volume_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = RME96_185X_MAX_OUT(rme96);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_dac_volume_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *u)\r\n{\r\nstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&rme96->lock);\r\nu->value.integer.value[0] = rme96->vol[0];\r\nu->value.integer.value[1] = rme96->vol[1];\r\nspin_unlock_irq(&rme96->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme96_dac_volume_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *u)\r\n{\r\nstruct rme96 *rme96 = snd_kcontrol_chip(kcontrol);\r\nint change = 0;\r\nunsigned int vol, maxvol;\r\nif (!RME96_HAS_ANALOG_OUT(rme96))\r\nreturn -EINVAL;\r\nmaxvol = RME96_185X_MAX_OUT(rme96);\r\nspin_lock_irq(&rme96->lock);\r\nvol = u->value.integer.value[0];\r\nif (vol != rme96->vol[0] && vol <= maxvol) {\r\nrme96->vol[0] = vol;\r\nchange = 1;\r\n}\r\nvol = u->value.integer.value[1];\r\nif (vol != rme96->vol[1] && vol <= maxvol) {\r\nrme96->vol[1] = vol;\r\nchange = 1;\r\n}\r\nif (change)\r\nsnd_rme96_apply_dac_volume(rme96);\r\nspin_unlock_irq(&rme96->lock);\r\nreturn change;\r\n}\r\nstatic int\r\nsnd_rme96_create_switches(struct snd_card *card,\r\nstruct rme96 *rme96)\r\n{\r\nint idx, err;\r\nstruct snd_kcontrol *kctl;\r\nfor (idx = 0; idx < 7; idx++) {\r\nif ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_rme96_controls[idx], rme96))) < 0)\r\nreturn err;\r\nif (idx == 1)\r\nrme96->spdif_ctl = kctl;\r\n}\r\nif (RME96_HAS_ANALOG_OUT(rme96)) {\r\nfor (idx = 7; idx < 10; idx++)\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_rme96_controls[idx], rme96))) < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_rme96_card_free(struct snd_card *card)\r\n{\r\nsnd_rme96_free(card->private_data);\r\n}\r\nstatic int __devinit\r\nsnd_rme96_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct rme96 *rme96;\r\nstruct snd_card *card;\r\nint err;\r\nu8 val;\r\nif (dev >= SNDRV_CARDS) {\r\nreturn -ENODEV;\r\n}\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE,\r\nsizeof(struct rme96), &card);\r\nif (err < 0)\r\nreturn err;\r\ncard->private_free = snd_rme96_card_free;\r\nrme96 = card->private_data;\r\nrme96->card = card;\r\nrme96->pci = pci;\r\nsnd_card_set_dev(card, &pci->dev);\r\nif ((err = snd_rme96_create(rme96)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstrcpy(card->driver, "Digi96");\r\nswitch (rme96->pci->device) {\r\ncase PCI_DEVICE_ID_RME_DIGI96:\r\nstrcpy(card->shortname, "RME Digi96");\r\nbreak;\r\ncase PCI_DEVICE_ID_RME_DIGI96_8:\r\nstrcpy(card->shortname, "RME Digi96/8");\r\nbreak;\r\ncase PCI_DEVICE_ID_RME_DIGI96_8_PRO:\r\nstrcpy(card->shortname, "RME Digi96/8 PRO");\r\nbreak;\r\ncase PCI_DEVICE_ID_RME_DIGI96_8_PAD_OR_PST:\r\npci_read_config_byte(rme96->pci, 8, &val);\r\nif (val < 5) {\r\nstrcpy(card->shortname, "RME Digi96/8 PAD");\r\n} else {\r\nstrcpy(card->shortname, "RME Digi96/8 PST");\r\n}\r\nbreak;\r\n}\r\nsprintf(card->longname, "%s at 0x%lx, irq %d", card->shortname,\r\nrme96->port, rme96->irq);\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void __devexit snd_rme96_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\npci_set_drvdata(pci, NULL);\r\n}\r\nstatic int __init alsa_card_rme96_init(void)\r\n{\r\nreturn pci_register_driver(&driver);\r\n}\r\nstatic void __exit alsa_card_rme96_exit(void)\r\n{\r\npci_unregister_driver(&driver);\r\n}
