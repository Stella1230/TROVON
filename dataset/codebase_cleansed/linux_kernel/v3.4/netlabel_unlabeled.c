static void netlbl_unlhsh_free_iface(struct rcu_head *entry)\r\n{\r\nstruct netlbl_unlhsh_iface *iface;\r\nstruct netlbl_af4list *iter4;\r\nstruct netlbl_af4list *tmp4;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nstruct netlbl_af6list *iter6;\r\nstruct netlbl_af6list *tmp6;\r\n#endif\r\niface = container_of(entry, struct netlbl_unlhsh_iface, rcu);\r\nnetlbl_af4list_foreach_safe(iter4, tmp4, &iface->addr4_list) {\r\nnetlbl_af4list_remove_entry(iter4);\r\nkfree(netlbl_unlhsh_addr4_entry(iter4));\r\n}\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nnetlbl_af6list_foreach_safe(iter6, tmp6, &iface->addr6_list) {\r\nnetlbl_af6list_remove_entry(iter6);\r\nkfree(netlbl_unlhsh_addr6_entry(iter6));\r\n}\r\n#endif\r\nkfree(iface);\r\n}\r\nstatic u32 netlbl_unlhsh_hash(int ifindex)\r\n{\r\nreturn ifindex & (netlbl_unlhsh_rcu_deref(netlbl_unlhsh)->size - 1);\r\n}\r\nstatic struct netlbl_unlhsh_iface *netlbl_unlhsh_search_iface(int ifindex)\r\n{\r\nu32 bkt;\r\nstruct list_head *bkt_list;\r\nstruct netlbl_unlhsh_iface *iter;\r\nbkt = netlbl_unlhsh_hash(ifindex);\r\nbkt_list = &netlbl_unlhsh_rcu_deref(netlbl_unlhsh)->tbl[bkt];\r\nlist_for_each_entry_rcu(iter, bkt_list, list)\r\nif (iter->valid && iter->ifindex == ifindex)\r\nreturn iter;\r\nreturn NULL;\r\n}\r\nstatic int netlbl_unlhsh_add_addr4(struct netlbl_unlhsh_iface *iface,\r\nconst struct in_addr *addr,\r\nconst struct in_addr *mask,\r\nu32 secid)\r\n{\r\nint ret_val;\r\nstruct netlbl_unlhsh_addr4 *entry;\r\nentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\r\nif (entry == NULL)\r\nreturn -ENOMEM;\r\nentry->list.addr = addr->s_addr & mask->s_addr;\r\nentry->list.mask = mask->s_addr;\r\nentry->list.valid = 1;\r\nentry->secid = secid;\r\nspin_lock(&netlbl_unlhsh_lock);\r\nret_val = netlbl_af4list_add(&entry->list, &iface->addr4_list);\r\nspin_unlock(&netlbl_unlhsh_lock);\r\nif (ret_val != 0)\r\nkfree(entry);\r\nreturn ret_val;\r\n}\r\nstatic int netlbl_unlhsh_add_addr6(struct netlbl_unlhsh_iface *iface,\r\nconst struct in6_addr *addr,\r\nconst struct in6_addr *mask,\r\nu32 secid)\r\n{\r\nint ret_val;\r\nstruct netlbl_unlhsh_addr6 *entry;\r\nentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\r\nif (entry == NULL)\r\nreturn -ENOMEM;\r\nentry->list.addr = *addr;\r\nentry->list.addr.s6_addr32[0] &= mask->s6_addr32[0];\r\nentry->list.addr.s6_addr32[1] &= mask->s6_addr32[1];\r\nentry->list.addr.s6_addr32[2] &= mask->s6_addr32[2];\r\nentry->list.addr.s6_addr32[3] &= mask->s6_addr32[3];\r\nentry->list.mask = *mask;\r\nentry->list.valid = 1;\r\nentry->secid = secid;\r\nspin_lock(&netlbl_unlhsh_lock);\r\nret_val = netlbl_af6list_add(&entry->list, &iface->addr6_list);\r\nspin_unlock(&netlbl_unlhsh_lock);\r\nif (ret_val != 0)\r\nkfree(entry);\r\nreturn 0;\r\n}\r\nstatic struct netlbl_unlhsh_iface *netlbl_unlhsh_add_iface(int ifindex)\r\n{\r\nu32 bkt;\r\nstruct netlbl_unlhsh_iface *iface;\r\niface = kzalloc(sizeof(*iface), GFP_ATOMIC);\r\nif (iface == NULL)\r\nreturn NULL;\r\niface->ifindex = ifindex;\r\nINIT_LIST_HEAD(&iface->addr4_list);\r\nINIT_LIST_HEAD(&iface->addr6_list);\r\niface->valid = 1;\r\nspin_lock(&netlbl_unlhsh_lock);\r\nif (ifindex > 0) {\r\nbkt = netlbl_unlhsh_hash(ifindex);\r\nif (netlbl_unlhsh_search_iface(ifindex) != NULL)\r\ngoto add_iface_failure;\r\nlist_add_tail_rcu(&iface->list,\r\n&netlbl_unlhsh_rcu_deref(netlbl_unlhsh)->tbl[bkt]);\r\n} else {\r\nINIT_LIST_HEAD(&iface->list);\r\nif (netlbl_unlhsh_rcu_deref(netlbl_unlhsh_def) != NULL)\r\ngoto add_iface_failure;\r\nrcu_assign_pointer(netlbl_unlhsh_def, iface);\r\n}\r\nspin_unlock(&netlbl_unlhsh_lock);\r\nreturn iface;\r\nadd_iface_failure:\r\nspin_unlock(&netlbl_unlhsh_lock);\r\nkfree(iface);\r\nreturn NULL;\r\n}\r\nint netlbl_unlhsh_add(struct net *net,\r\nconst char *dev_name,\r\nconst void *addr,\r\nconst void *mask,\r\nu32 addr_len,\r\nu32 secid,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nint ret_val;\r\nint ifindex;\r\nstruct net_device *dev;\r\nstruct netlbl_unlhsh_iface *iface;\r\nstruct audit_buffer *audit_buf = NULL;\r\nchar *secctx = NULL;\r\nu32 secctx_len;\r\nif (addr_len != sizeof(struct in_addr) &&\r\naddr_len != sizeof(struct in6_addr))\r\nreturn -EINVAL;\r\nrcu_read_lock();\r\nif (dev_name != NULL) {\r\ndev = dev_get_by_name_rcu(net, dev_name);\r\nif (dev == NULL) {\r\nret_val = -ENODEV;\r\ngoto unlhsh_add_return;\r\n}\r\nifindex = dev->ifindex;\r\niface = netlbl_unlhsh_search_iface(ifindex);\r\n} else {\r\nifindex = 0;\r\niface = rcu_dereference(netlbl_unlhsh_def);\r\n}\r\nif (iface == NULL) {\r\niface = netlbl_unlhsh_add_iface(ifindex);\r\nif (iface == NULL) {\r\nret_val = -ENOMEM;\r\ngoto unlhsh_add_return;\r\n}\r\n}\r\naudit_buf = netlbl_audit_start_common(AUDIT_MAC_UNLBL_STCADD,\r\naudit_info);\r\nswitch (addr_len) {\r\ncase sizeof(struct in_addr): {\r\nconst struct in_addr *addr4 = addr;\r\nconst struct in_addr *mask4 = mask;\r\nret_val = netlbl_unlhsh_add_addr4(iface, addr4, mask4, secid);\r\nif (audit_buf != NULL)\r\nnetlbl_af4list_audit_addr(audit_buf, 1,\r\ndev_name,\r\naddr4->s_addr,\r\nmask4->s_addr);\r\nbreak;\r\n}\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase sizeof(struct in6_addr): {\r\nconst struct in6_addr *addr6 = addr;\r\nconst struct in6_addr *mask6 = mask;\r\nret_val = netlbl_unlhsh_add_addr6(iface, addr6, mask6, secid);\r\nif (audit_buf != NULL)\r\nnetlbl_af6list_audit_addr(audit_buf, 1,\r\ndev_name,\r\naddr6, mask6);\r\nbreak;\r\n}\r\n#endif\r\ndefault:\r\nret_val = -EINVAL;\r\n}\r\nif (ret_val == 0)\r\natomic_inc(&netlabel_mgmt_protocount);\r\nunlhsh_add_return:\r\nrcu_read_unlock();\r\nif (audit_buf != NULL) {\r\nif (security_secid_to_secctx(secid,\r\n&secctx,\r\n&secctx_len) == 0) {\r\naudit_log_format(audit_buf, " sec_obj=%s", secctx);\r\nsecurity_release_secctx(secctx, secctx_len);\r\n}\r\naudit_log_format(audit_buf, " res=%u", ret_val == 0 ? 1 : 0);\r\naudit_log_end(audit_buf);\r\n}\r\nreturn ret_val;\r\n}\r\nstatic int netlbl_unlhsh_remove_addr4(struct net *net,\r\nstruct netlbl_unlhsh_iface *iface,\r\nconst struct in_addr *addr,\r\nconst struct in_addr *mask,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nstruct netlbl_af4list *list_entry;\r\nstruct netlbl_unlhsh_addr4 *entry;\r\nstruct audit_buffer *audit_buf;\r\nstruct net_device *dev;\r\nchar *secctx;\r\nu32 secctx_len;\r\nspin_lock(&netlbl_unlhsh_lock);\r\nlist_entry = netlbl_af4list_remove(addr->s_addr, mask->s_addr,\r\n&iface->addr4_list);\r\nspin_unlock(&netlbl_unlhsh_lock);\r\nif (list_entry != NULL)\r\nentry = netlbl_unlhsh_addr4_entry(list_entry);\r\nelse\r\nentry = NULL;\r\naudit_buf = netlbl_audit_start_common(AUDIT_MAC_UNLBL_STCDEL,\r\naudit_info);\r\nif (audit_buf != NULL) {\r\ndev = dev_get_by_index(net, iface->ifindex);\r\nnetlbl_af4list_audit_addr(audit_buf, 1,\r\n(dev != NULL ? dev->name : NULL),\r\naddr->s_addr, mask->s_addr);\r\nif (dev != NULL)\r\ndev_put(dev);\r\nif (entry != NULL &&\r\nsecurity_secid_to_secctx(entry->secid,\r\n&secctx, &secctx_len) == 0) {\r\naudit_log_format(audit_buf, " sec_obj=%s", secctx);\r\nsecurity_release_secctx(secctx, secctx_len);\r\n}\r\naudit_log_format(audit_buf, " res=%u", entry != NULL ? 1 : 0);\r\naudit_log_end(audit_buf);\r\n}\r\nif (entry == NULL)\r\nreturn -ENOENT;\r\nkfree_rcu(entry, rcu);\r\nreturn 0;\r\n}\r\nstatic int netlbl_unlhsh_remove_addr6(struct net *net,\r\nstruct netlbl_unlhsh_iface *iface,\r\nconst struct in6_addr *addr,\r\nconst struct in6_addr *mask,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nstruct netlbl_af6list *list_entry;\r\nstruct netlbl_unlhsh_addr6 *entry;\r\nstruct audit_buffer *audit_buf;\r\nstruct net_device *dev;\r\nchar *secctx;\r\nu32 secctx_len;\r\nspin_lock(&netlbl_unlhsh_lock);\r\nlist_entry = netlbl_af6list_remove(addr, mask, &iface->addr6_list);\r\nspin_unlock(&netlbl_unlhsh_lock);\r\nif (list_entry != NULL)\r\nentry = netlbl_unlhsh_addr6_entry(list_entry);\r\nelse\r\nentry = NULL;\r\naudit_buf = netlbl_audit_start_common(AUDIT_MAC_UNLBL_STCDEL,\r\naudit_info);\r\nif (audit_buf != NULL) {\r\ndev = dev_get_by_index(net, iface->ifindex);\r\nnetlbl_af6list_audit_addr(audit_buf, 1,\r\n(dev != NULL ? dev->name : NULL),\r\naddr, mask);\r\nif (dev != NULL)\r\ndev_put(dev);\r\nif (entry != NULL &&\r\nsecurity_secid_to_secctx(entry->secid,\r\n&secctx, &secctx_len) == 0) {\r\naudit_log_format(audit_buf, " sec_obj=%s", secctx);\r\nsecurity_release_secctx(secctx, secctx_len);\r\n}\r\naudit_log_format(audit_buf, " res=%u", entry != NULL ? 1 : 0);\r\naudit_log_end(audit_buf);\r\n}\r\nif (entry == NULL)\r\nreturn -ENOENT;\r\nkfree_rcu(entry, rcu);\r\nreturn 0;\r\n}\r\nstatic void netlbl_unlhsh_condremove_iface(struct netlbl_unlhsh_iface *iface)\r\n{\r\nstruct netlbl_af4list *iter4;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nstruct netlbl_af6list *iter6;\r\n#endif\r\nspin_lock(&netlbl_unlhsh_lock);\r\nnetlbl_af4list_foreach_rcu(iter4, &iface->addr4_list)\r\ngoto unlhsh_condremove_failure;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nnetlbl_af6list_foreach_rcu(iter6, &iface->addr6_list)\r\ngoto unlhsh_condremove_failure;\r\n#endif\r\niface->valid = 0;\r\nif (iface->ifindex > 0)\r\nlist_del_rcu(&iface->list);\r\nelse\r\nRCU_INIT_POINTER(netlbl_unlhsh_def, NULL);\r\nspin_unlock(&netlbl_unlhsh_lock);\r\ncall_rcu(&iface->rcu, netlbl_unlhsh_free_iface);\r\nreturn;\r\nunlhsh_condremove_failure:\r\nspin_unlock(&netlbl_unlhsh_lock);\r\n}\r\nint netlbl_unlhsh_remove(struct net *net,\r\nconst char *dev_name,\r\nconst void *addr,\r\nconst void *mask,\r\nu32 addr_len,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nint ret_val;\r\nstruct net_device *dev;\r\nstruct netlbl_unlhsh_iface *iface;\r\nif (addr_len != sizeof(struct in_addr) &&\r\naddr_len != sizeof(struct in6_addr))\r\nreturn -EINVAL;\r\nrcu_read_lock();\r\nif (dev_name != NULL) {\r\ndev = dev_get_by_name_rcu(net, dev_name);\r\nif (dev == NULL) {\r\nret_val = -ENODEV;\r\ngoto unlhsh_remove_return;\r\n}\r\niface = netlbl_unlhsh_search_iface(dev->ifindex);\r\n} else\r\niface = rcu_dereference(netlbl_unlhsh_def);\r\nif (iface == NULL) {\r\nret_val = -ENOENT;\r\ngoto unlhsh_remove_return;\r\n}\r\nswitch (addr_len) {\r\ncase sizeof(struct in_addr):\r\nret_val = netlbl_unlhsh_remove_addr4(net,\r\niface, addr, mask,\r\naudit_info);\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase sizeof(struct in6_addr):\r\nret_val = netlbl_unlhsh_remove_addr6(net,\r\niface, addr, mask,\r\naudit_info);\r\nbreak;\r\n#endif\r\ndefault:\r\nret_val = -EINVAL;\r\n}\r\nif (ret_val == 0) {\r\nnetlbl_unlhsh_condremove_iface(iface);\r\natomic_dec(&netlabel_mgmt_protocount);\r\n}\r\nunlhsh_remove_return:\r\nrcu_read_unlock();\r\nreturn ret_val;\r\n}\r\nstatic int netlbl_unlhsh_netdev_handler(struct notifier_block *this,\r\nunsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = ptr;\r\nstruct netlbl_unlhsh_iface *iface = NULL;\r\nif (!net_eq(dev_net(dev), &init_net))\r\nreturn NOTIFY_DONE;\r\nif (event == NETDEV_DOWN) {\r\nspin_lock(&netlbl_unlhsh_lock);\r\niface = netlbl_unlhsh_search_iface(dev->ifindex);\r\nif (iface != NULL && iface->valid) {\r\niface->valid = 0;\r\nlist_del_rcu(&iface->list);\r\n} else\r\niface = NULL;\r\nspin_unlock(&netlbl_unlhsh_lock);\r\n}\r\nif (iface != NULL)\r\ncall_rcu(&iface->rcu, netlbl_unlhsh_free_iface);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void netlbl_unlabel_acceptflg_set(u8 value,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nstruct audit_buffer *audit_buf;\r\nu8 old_val;\r\nold_val = netlabel_unlabel_acceptflg;\r\nnetlabel_unlabel_acceptflg = value;\r\naudit_buf = netlbl_audit_start_common(AUDIT_MAC_UNLBL_ALLOW,\r\naudit_info);\r\nif (audit_buf != NULL) {\r\naudit_log_format(audit_buf,\r\n" unlbl_accept=%u old=%u", value, old_val);\r\naudit_log_end(audit_buf);\r\n}\r\n}\r\nstatic int netlbl_unlabel_addrinfo_get(struct genl_info *info,\r\nvoid **addr,\r\nvoid **mask,\r\nu32 *len)\r\n{\r\nu32 addr_len;\r\nif (info->attrs[NLBL_UNLABEL_A_IPV4ADDR]) {\r\naddr_len = nla_len(info->attrs[NLBL_UNLABEL_A_IPV4ADDR]);\r\nif (addr_len != sizeof(struct in_addr) &&\r\naddr_len != nla_len(info->attrs[NLBL_UNLABEL_A_IPV4MASK]))\r\nreturn -EINVAL;\r\n*len = addr_len;\r\n*addr = nla_data(info->attrs[NLBL_UNLABEL_A_IPV4ADDR]);\r\n*mask = nla_data(info->attrs[NLBL_UNLABEL_A_IPV4MASK]);\r\nreturn 0;\r\n} else if (info->attrs[NLBL_UNLABEL_A_IPV6ADDR]) {\r\naddr_len = nla_len(info->attrs[NLBL_UNLABEL_A_IPV6ADDR]);\r\nif (addr_len != sizeof(struct in6_addr) &&\r\naddr_len != nla_len(info->attrs[NLBL_UNLABEL_A_IPV6MASK]))\r\nreturn -EINVAL;\r\n*len = addr_len;\r\n*addr = nla_data(info->attrs[NLBL_UNLABEL_A_IPV6ADDR]);\r\n*mask = nla_data(info->attrs[NLBL_UNLABEL_A_IPV6MASK]);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int netlbl_unlabel_accept(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nu8 value;\r\nstruct netlbl_audit audit_info;\r\nif (info->attrs[NLBL_UNLABEL_A_ACPTFLG]) {\r\nvalue = nla_get_u8(info->attrs[NLBL_UNLABEL_A_ACPTFLG]);\r\nif (value == 1 || value == 0) {\r\nnetlbl_netlink_auditinfo(skb, &audit_info);\r\nnetlbl_unlabel_acceptflg_set(value, &audit_info);\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int netlbl_unlabel_list(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nint ret_val = -EINVAL;\r\nstruct sk_buff *ans_skb;\r\nvoid *data;\r\nans_skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (ans_skb == NULL)\r\ngoto list_failure;\r\ndata = genlmsg_put_reply(ans_skb, info, &netlbl_unlabel_gnl_family,\r\n0, NLBL_UNLABEL_C_LIST);\r\nif (data == NULL) {\r\nret_val = -ENOMEM;\r\ngoto list_failure;\r\n}\r\nret_val = nla_put_u8(ans_skb,\r\nNLBL_UNLABEL_A_ACPTFLG,\r\nnetlabel_unlabel_acceptflg);\r\nif (ret_val != 0)\r\ngoto list_failure;\r\ngenlmsg_end(ans_skb, data);\r\nreturn genlmsg_reply(ans_skb, info);\r\nlist_failure:\r\nkfree_skb(ans_skb);\r\nreturn ret_val;\r\n}\r\nstatic int netlbl_unlabel_staticadd(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nint ret_val;\r\nchar *dev_name;\r\nvoid *addr;\r\nvoid *mask;\r\nu32 addr_len;\r\nu32 secid;\r\nstruct netlbl_audit audit_info;\r\nif (!info->attrs[NLBL_UNLABEL_A_SECCTX] ||\r\n!info->attrs[NLBL_UNLABEL_A_IFACE] ||\r\n!((!info->attrs[NLBL_UNLABEL_A_IPV4ADDR] ||\r\n!info->attrs[NLBL_UNLABEL_A_IPV4MASK]) ^\r\n(!info->attrs[NLBL_UNLABEL_A_IPV6ADDR] ||\r\n!info->attrs[NLBL_UNLABEL_A_IPV6MASK])))\r\nreturn -EINVAL;\r\nnetlbl_netlink_auditinfo(skb, &audit_info);\r\nret_val = netlbl_unlabel_addrinfo_get(info, &addr, &mask, &addr_len);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\ndev_name = nla_data(info->attrs[NLBL_UNLABEL_A_IFACE]);\r\nret_val = security_secctx_to_secid(\r\nnla_data(info->attrs[NLBL_UNLABEL_A_SECCTX]),\r\nnla_len(info->attrs[NLBL_UNLABEL_A_SECCTX]),\r\n&secid);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nreturn netlbl_unlhsh_add(&init_net,\r\ndev_name, addr, mask, addr_len, secid,\r\n&audit_info);\r\n}\r\nstatic int netlbl_unlabel_staticadddef(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nint ret_val;\r\nvoid *addr;\r\nvoid *mask;\r\nu32 addr_len;\r\nu32 secid;\r\nstruct netlbl_audit audit_info;\r\nif (!info->attrs[NLBL_UNLABEL_A_SECCTX] ||\r\n!((!info->attrs[NLBL_UNLABEL_A_IPV4ADDR] ||\r\n!info->attrs[NLBL_UNLABEL_A_IPV4MASK]) ^\r\n(!info->attrs[NLBL_UNLABEL_A_IPV6ADDR] ||\r\n!info->attrs[NLBL_UNLABEL_A_IPV6MASK])))\r\nreturn -EINVAL;\r\nnetlbl_netlink_auditinfo(skb, &audit_info);\r\nret_val = netlbl_unlabel_addrinfo_get(info, &addr, &mask, &addr_len);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nret_val = security_secctx_to_secid(\r\nnla_data(info->attrs[NLBL_UNLABEL_A_SECCTX]),\r\nnla_len(info->attrs[NLBL_UNLABEL_A_SECCTX]),\r\n&secid);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nreturn netlbl_unlhsh_add(&init_net,\r\nNULL, addr, mask, addr_len, secid,\r\n&audit_info);\r\n}\r\nstatic int netlbl_unlabel_staticremove(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nint ret_val;\r\nchar *dev_name;\r\nvoid *addr;\r\nvoid *mask;\r\nu32 addr_len;\r\nstruct netlbl_audit audit_info;\r\nif (!info->attrs[NLBL_UNLABEL_A_IFACE] ||\r\n!((!info->attrs[NLBL_UNLABEL_A_IPV4ADDR] ||\r\n!info->attrs[NLBL_UNLABEL_A_IPV4MASK]) ^\r\n(!info->attrs[NLBL_UNLABEL_A_IPV6ADDR] ||\r\n!info->attrs[NLBL_UNLABEL_A_IPV6MASK])))\r\nreturn -EINVAL;\r\nnetlbl_netlink_auditinfo(skb, &audit_info);\r\nret_val = netlbl_unlabel_addrinfo_get(info, &addr, &mask, &addr_len);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\ndev_name = nla_data(info->attrs[NLBL_UNLABEL_A_IFACE]);\r\nreturn netlbl_unlhsh_remove(&init_net,\r\ndev_name, addr, mask, addr_len,\r\n&audit_info);\r\n}\r\nstatic int netlbl_unlabel_staticremovedef(struct sk_buff *skb,\r\nstruct genl_info *info)\r\n{\r\nint ret_val;\r\nvoid *addr;\r\nvoid *mask;\r\nu32 addr_len;\r\nstruct netlbl_audit audit_info;\r\nif (!((!info->attrs[NLBL_UNLABEL_A_IPV4ADDR] ||\r\n!info->attrs[NLBL_UNLABEL_A_IPV4MASK]) ^\r\n(!info->attrs[NLBL_UNLABEL_A_IPV6ADDR] ||\r\n!info->attrs[NLBL_UNLABEL_A_IPV6MASK])))\r\nreturn -EINVAL;\r\nnetlbl_netlink_auditinfo(skb, &audit_info);\r\nret_val = netlbl_unlabel_addrinfo_get(info, &addr, &mask, &addr_len);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nreturn netlbl_unlhsh_remove(&init_net,\r\nNULL, addr, mask, addr_len,\r\n&audit_info);\r\n}\r\nstatic int netlbl_unlabel_staticlist_gen(u32 cmd,\r\nconst struct netlbl_unlhsh_iface *iface,\r\nconst struct netlbl_unlhsh_addr4 *addr4,\r\nconst struct netlbl_unlhsh_addr6 *addr6,\r\nvoid *arg)\r\n{\r\nint ret_val = -ENOMEM;\r\nstruct netlbl_unlhsh_walk_arg *cb_arg = arg;\r\nstruct net_device *dev;\r\nvoid *data;\r\nu32 secid;\r\nchar *secctx;\r\nu32 secctx_len;\r\ndata = genlmsg_put(cb_arg->skb, NETLINK_CB(cb_arg->nl_cb->skb).pid,\r\ncb_arg->seq, &netlbl_unlabel_gnl_family,\r\nNLM_F_MULTI, cmd);\r\nif (data == NULL)\r\ngoto list_cb_failure;\r\nif (iface->ifindex > 0) {\r\ndev = dev_get_by_index(&init_net, iface->ifindex);\r\nif (!dev) {\r\nret_val = -ENODEV;\r\ngoto list_cb_failure;\r\n}\r\nret_val = nla_put_string(cb_arg->skb,\r\nNLBL_UNLABEL_A_IFACE, dev->name);\r\ndev_put(dev);\r\nif (ret_val != 0)\r\ngoto list_cb_failure;\r\n}\r\nif (addr4) {\r\nstruct in_addr addr_struct;\r\naddr_struct.s_addr = addr4->list.addr;\r\nret_val = nla_put(cb_arg->skb,\r\nNLBL_UNLABEL_A_IPV4ADDR,\r\nsizeof(struct in_addr),\r\n&addr_struct);\r\nif (ret_val != 0)\r\ngoto list_cb_failure;\r\naddr_struct.s_addr = addr4->list.mask;\r\nret_val = nla_put(cb_arg->skb,\r\nNLBL_UNLABEL_A_IPV4MASK,\r\nsizeof(struct in_addr),\r\n&addr_struct);\r\nif (ret_val != 0)\r\ngoto list_cb_failure;\r\nsecid = addr4->secid;\r\n} else {\r\nret_val = nla_put(cb_arg->skb,\r\nNLBL_UNLABEL_A_IPV6ADDR,\r\nsizeof(struct in6_addr),\r\n&addr6->list.addr);\r\nif (ret_val != 0)\r\ngoto list_cb_failure;\r\nret_val = nla_put(cb_arg->skb,\r\nNLBL_UNLABEL_A_IPV6MASK,\r\nsizeof(struct in6_addr),\r\n&addr6->list.mask);\r\nif (ret_val != 0)\r\ngoto list_cb_failure;\r\nsecid = addr6->secid;\r\n}\r\nret_val = security_secid_to_secctx(secid, &secctx, &secctx_len);\r\nif (ret_val != 0)\r\ngoto list_cb_failure;\r\nret_val = nla_put(cb_arg->skb,\r\nNLBL_UNLABEL_A_SECCTX,\r\nsecctx_len,\r\nsecctx);\r\nsecurity_release_secctx(secctx, secctx_len);\r\nif (ret_val != 0)\r\ngoto list_cb_failure;\r\ncb_arg->seq++;\r\nreturn genlmsg_end(cb_arg->skb, data);\r\nlist_cb_failure:\r\ngenlmsg_cancel(cb_arg->skb, data);\r\nreturn ret_val;\r\n}\r\nstatic int netlbl_unlabel_staticlist(struct sk_buff *skb,\r\nstruct netlink_callback *cb)\r\n{\r\nstruct netlbl_unlhsh_walk_arg cb_arg;\r\nu32 skip_bkt = cb->args[0];\r\nu32 skip_chain = cb->args[1];\r\nu32 skip_addr4 = cb->args[2];\r\nu32 skip_addr6 = cb->args[3];\r\nu32 iter_bkt;\r\nu32 iter_chain = 0, iter_addr4 = 0, iter_addr6 = 0;\r\nstruct netlbl_unlhsh_iface *iface;\r\nstruct list_head *iter_list;\r\nstruct netlbl_af4list *addr4;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nstruct netlbl_af6list *addr6;\r\n#endif\r\ncb_arg.nl_cb = cb;\r\ncb_arg.skb = skb;\r\ncb_arg.seq = cb->nlh->nlmsg_seq;\r\nrcu_read_lock();\r\nfor (iter_bkt = skip_bkt;\r\niter_bkt < rcu_dereference(netlbl_unlhsh)->size;\r\niter_bkt++, iter_chain = 0, iter_addr4 = 0, iter_addr6 = 0) {\r\niter_list = &rcu_dereference(netlbl_unlhsh)->tbl[iter_bkt];\r\nlist_for_each_entry_rcu(iface, iter_list, list) {\r\nif (!iface->valid ||\r\niter_chain++ < skip_chain)\r\ncontinue;\r\nnetlbl_af4list_foreach_rcu(addr4,\r\n&iface->addr4_list) {\r\nif (iter_addr4++ < skip_addr4)\r\ncontinue;\r\nif (netlbl_unlabel_staticlist_gen(\r\nNLBL_UNLABEL_C_STATICLIST,\r\niface,\r\nnetlbl_unlhsh_addr4_entry(addr4),\r\nNULL,\r\n&cb_arg) < 0) {\r\niter_addr4--;\r\niter_chain--;\r\ngoto unlabel_staticlist_return;\r\n}\r\n}\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nnetlbl_af6list_foreach_rcu(addr6,\r\n&iface->addr6_list) {\r\nif (iter_addr6++ < skip_addr6)\r\ncontinue;\r\nif (netlbl_unlabel_staticlist_gen(\r\nNLBL_UNLABEL_C_STATICLIST,\r\niface,\r\nNULL,\r\nnetlbl_unlhsh_addr6_entry(addr6),\r\n&cb_arg) < 0) {\r\niter_addr6--;\r\niter_chain--;\r\ngoto unlabel_staticlist_return;\r\n}\r\n}\r\n#endif\r\n}\r\n}\r\nunlabel_staticlist_return:\r\nrcu_read_unlock();\r\ncb->args[0] = skip_bkt;\r\ncb->args[1] = skip_chain;\r\ncb->args[2] = skip_addr4;\r\ncb->args[3] = skip_addr6;\r\nreturn skb->len;\r\n}\r\nstatic int netlbl_unlabel_staticlistdef(struct sk_buff *skb,\r\nstruct netlink_callback *cb)\r\n{\r\nstruct netlbl_unlhsh_walk_arg cb_arg;\r\nstruct netlbl_unlhsh_iface *iface;\r\nu32 skip_addr4 = cb->args[0];\r\nu32 skip_addr6 = cb->args[1];\r\nu32 iter_addr4 = 0;\r\nstruct netlbl_af4list *addr4;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nu32 iter_addr6 = 0;\r\nstruct netlbl_af6list *addr6;\r\n#endif\r\ncb_arg.nl_cb = cb;\r\ncb_arg.skb = skb;\r\ncb_arg.seq = cb->nlh->nlmsg_seq;\r\nrcu_read_lock();\r\niface = rcu_dereference(netlbl_unlhsh_def);\r\nif (iface == NULL || !iface->valid)\r\ngoto unlabel_staticlistdef_return;\r\nnetlbl_af4list_foreach_rcu(addr4, &iface->addr4_list) {\r\nif (iter_addr4++ < skip_addr4)\r\ncontinue;\r\nif (netlbl_unlabel_staticlist_gen(NLBL_UNLABEL_C_STATICLISTDEF,\r\niface,\r\nnetlbl_unlhsh_addr4_entry(addr4),\r\nNULL,\r\n&cb_arg) < 0) {\r\niter_addr4--;\r\ngoto unlabel_staticlistdef_return;\r\n}\r\n}\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nnetlbl_af6list_foreach_rcu(addr6, &iface->addr6_list) {\r\nif (iter_addr6++ < skip_addr6)\r\ncontinue;\r\nif (netlbl_unlabel_staticlist_gen(NLBL_UNLABEL_C_STATICLISTDEF,\r\niface,\r\nNULL,\r\nnetlbl_unlhsh_addr6_entry(addr6),\r\n&cb_arg) < 0) {\r\niter_addr6--;\r\ngoto unlabel_staticlistdef_return;\r\n}\r\n}\r\n#endif\r\nunlabel_staticlistdef_return:\r\nrcu_read_unlock();\r\ncb->args[0] = skip_addr4;\r\ncb->args[1] = skip_addr6;\r\nreturn skb->len;\r\n}\r\nint __init netlbl_unlabel_genl_init(void)\r\n{\r\nreturn genl_register_family_with_ops(&netlbl_unlabel_gnl_family,\r\nnetlbl_unlabel_genl_ops, ARRAY_SIZE(netlbl_unlabel_genl_ops));\r\n}\r\nint __init netlbl_unlabel_init(u32 size)\r\n{\r\nu32 iter;\r\nstruct netlbl_unlhsh_tbl *hsh_tbl;\r\nif (size == 0)\r\nreturn -EINVAL;\r\nhsh_tbl = kmalloc(sizeof(*hsh_tbl), GFP_KERNEL);\r\nif (hsh_tbl == NULL)\r\nreturn -ENOMEM;\r\nhsh_tbl->size = 1 << size;\r\nhsh_tbl->tbl = kcalloc(hsh_tbl->size,\r\nsizeof(struct list_head),\r\nGFP_KERNEL);\r\nif (hsh_tbl->tbl == NULL) {\r\nkfree(hsh_tbl);\r\nreturn -ENOMEM;\r\n}\r\nfor (iter = 0; iter < hsh_tbl->size; iter++)\r\nINIT_LIST_HEAD(&hsh_tbl->tbl[iter]);\r\nspin_lock(&netlbl_unlhsh_lock);\r\nrcu_assign_pointer(netlbl_unlhsh, hsh_tbl);\r\nspin_unlock(&netlbl_unlhsh_lock);\r\nregister_netdevice_notifier(&netlbl_unlhsh_netdev_notifier);\r\nreturn 0;\r\n}\r\nint netlbl_unlabel_getattr(const struct sk_buff *skb,\r\nu16 family,\r\nstruct netlbl_lsm_secattr *secattr)\r\n{\r\nstruct netlbl_unlhsh_iface *iface;\r\nrcu_read_lock();\r\niface = netlbl_unlhsh_search_iface(skb->skb_iif);\r\nif (iface == NULL)\r\niface = rcu_dereference(netlbl_unlhsh_def);\r\nif (iface == NULL || !iface->valid)\r\ngoto unlabel_getattr_nolabel;\r\nswitch (family) {\r\ncase PF_INET: {\r\nstruct iphdr *hdr4;\r\nstruct netlbl_af4list *addr4;\r\nhdr4 = ip_hdr(skb);\r\naddr4 = netlbl_af4list_search(hdr4->saddr,\r\n&iface->addr4_list);\r\nif (addr4 == NULL)\r\ngoto unlabel_getattr_nolabel;\r\nsecattr->attr.secid = netlbl_unlhsh_addr4_entry(addr4)->secid;\r\nbreak;\r\n}\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase PF_INET6: {\r\nstruct ipv6hdr *hdr6;\r\nstruct netlbl_af6list *addr6;\r\nhdr6 = ipv6_hdr(skb);\r\naddr6 = netlbl_af6list_search(&hdr6->saddr,\r\n&iface->addr6_list);\r\nif (addr6 == NULL)\r\ngoto unlabel_getattr_nolabel;\r\nsecattr->attr.secid = netlbl_unlhsh_addr6_entry(addr6)->secid;\r\nbreak;\r\n}\r\n#endif\r\ndefault:\r\ngoto unlabel_getattr_nolabel;\r\n}\r\nrcu_read_unlock();\r\nsecattr->flags |= NETLBL_SECATTR_SECID;\r\nsecattr->type = NETLBL_NLTYPE_UNLABELED;\r\nreturn 0;\r\nunlabel_getattr_nolabel:\r\nrcu_read_unlock();\r\nif (netlabel_unlabel_acceptflg == 0)\r\nreturn -ENOMSG;\r\nsecattr->type = NETLBL_NLTYPE_UNLABELED;\r\nreturn 0;\r\n}\r\nint __init netlbl_unlabel_defconf(void)\r\n{\r\nint ret_val;\r\nstruct netlbl_dom_map *entry;\r\nstruct netlbl_audit audit_info;\r\nsecurity_task_getsecid(current, &audit_info.secid);\r\naudit_info.loginuid = 0;\r\naudit_info.sessionid = 0;\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (entry == NULL)\r\nreturn -ENOMEM;\r\nentry->type = NETLBL_NLTYPE_UNLABELED;\r\nret_val = netlbl_domhsh_add_default(entry, &audit_info);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nnetlbl_unlabel_acceptflg_set(1, &audit_info);\r\nreturn 0;\r\n}
