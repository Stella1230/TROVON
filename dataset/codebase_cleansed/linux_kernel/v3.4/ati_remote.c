static void ati_remote_dump(struct device *dev, unsigned char *data,\r\nunsigned int len)\r\n{\r\nif (len == 1) {\r\nif (data[0] != (unsigned char)0xff && data[0] != 0x00)\r\ndev_warn(dev, "Weird byte 0x%02x\n", data[0]);\r\n} else if (len == 4)\r\ndev_warn(dev, "Weird key %02x %02x %02x %02x\n",\r\ndata[0], data[1], data[2], data[3]);\r\nelse\r\ndev_warn(dev, "Weird data, len=%d %02x %02x %02x %02x %02x %02x ...\n",\r\nlen, data[0], data[1], data[2], data[3], data[4], data[5]);\r\n}\r\nstatic int ati_remote_open(struct ati_remote *ati_remote)\r\n{\r\nint err = 0;\r\nmutex_lock(&ati_remote->open_mutex);\r\nif (ati_remote->users++ != 0)\r\ngoto out;\r\nati_remote->irq_urb->dev = ati_remote->udev;\r\nif (usb_submit_urb(ati_remote->irq_urb, GFP_KERNEL)) {\r\ndev_err(&ati_remote->interface->dev,\r\n"%s: usb_submit_urb failed!\n", __func__);\r\nerr = -EIO;\r\n}\r\nout: mutex_unlock(&ati_remote->open_mutex);\r\nreturn err;\r\n}\r\nstatic void ati_remote_close(struct ati_remote *ati_remote)\r\n{\r\nmutex_lock(&ati_remote->open_mutex);\r\nif (--ati_remote->users == 0)\r\nusb_kill_urb(ati_remote->irq_urb);\r\nmutex_unlock(&ati_remote->open_mutex);\r\n}\r\nstatic int ati_remote_input_open(struct input_dev *inputdev)\r\n{\r\nstruct ati_remote *ati_remote = input_get_drvdata(inputdev);\r\nreturn ati_remote_open(ati_remote);\r\n}\r\nstatic void ati_remote_input_close(struct input_dev *inputdev)\r\n{\r\nstruct ati_remote *ati_remote = input_get_drvdata(inputdev);\r\nati_remote_close(ati_remote);\r\n}\r\nstatic int ati_remote_rc_open(struct rc_dev *rdev)\r\n{\r\nstruct ati_remote *ati_remote = rdev->priv;\r\nreturn ati_remote_open(ati_remote);\r\n}\r\nstatic void ati_remote_rc_close(struct rc_dev *rdev)\r\n{\r\nstruct ati_remote *ati_remote = rdev->priv;\r\nati_remote_close(ati_remote);\r\n}\r\nstatic void ati_remote_irq_out(struct urb *urb)\r\n{\r\nstruct ati_remote *ati_remote = urb->context;\r\nif (urb->status) {\r\ndev_dbg(&ati_remote->interface->dev, "%s: status %d\n",\r\n__func__, urb->status);\r\nreturn;\r\n}\r\nati_remote->send_flags |= SEND_FLAG_COMPLETE;\r\nwmb();\r\nwake_up(&ati_remote->wait);\r\n}\r\nstatic int ati_remote_sendpacket(struct ati_remote *ati_remote, u16 cmd, unsigned char *data)\r\n{\r\nint retval = 0;\r\nmemcpy(ati_remote->out_urb->transfer_buffer + 1, data, LO(cmd));\r\n((char *) ati_remote->out_urb->transfer_buffer)[0] = HI(cmd);\r\nati_remote->out_urb->transfer_buffer_length = LO(cmd) + 1;\r\nati_remote->out_urb->dev = ati_remote->udev;\r\nati_remote->send_flags = SEND_FLAG_IN_PROGRESS;\r\nretval = usb_submit_urb(ati_remote->out_urb, GFP_ATOMIC);\r\nif (retval) {\r\ndev_dbg(&ati_remote->interface->dev,\r\n"sendpacket: usb_submit_urb failed: %d\n", retval);\r\nreturn retval;\r\n}\r\nwait_event_timeout(ati_remote->wait,\r\n((ati_remote->out_urb->status != -EINPROGRESS) ||\r\n(ati_remote->send_flags & SEND_FLAG_COMPLETE)),\r\nHZ);\r\nusb_kill_urb(ati_remote->out_urb);\r\nreturn retval;\r\n}\r\nstatic int ati_remote_compute_accel(struct ati_remote *ati_remote)\r\n{\r\nstatic const char accel[] = { 1, 2, 4, 6, 9, 13, 20 };\r\nunsigned long now = jiffies;\r\nint acc;\r\nif (time_after(now, ati_remote->old_jiffies + msecs_to_jiffies(250))) {\r\nacc = 1;\r\nati_remote->acc_jiffies = now;\r\n}\r\nelse if (time_before(now, ati_remote->acc_jiffies + msecs_to_jiffies(125)))\r\nacc = accel[0];\r\nelse if (time_before(now, ati_remote->acc_jiffies + msecs_to_jiffies(250)))\r\nacc = accel[1];\r\nelse if (time_before(now, ati_remote->acc_jiffies + msecs_to_jiffies(500)))\r\nacc = accel[2];\r\nelse if (time_before(now, ati_remote->acc_jiffies + msecs_to_jiffies(1000)))\r\nacc = accel[3];\r\nelse if (time_before(now, ati_remote->acc_jiffies + msecs_to_jiffies(1500)))\r\nacc = accel[4];\r\nelse if (time_before(now, ati_remote->acc_jiffies + msecs_to_jiffies(2000)))\r\nacc = accel[5];\r\nelse\r\nacc = accel[6];\r\nreturn acc;\r\n}\r\nstatic void ati_remote_input_report(struct urb *urb)\r\n{\r\nstruct ati_remote *ati_remote = urb->context;\r\nunsigned char *data= ati_remote->inbuf;\r\nstruct input_dev *dev = ati_remote->idev;\r\nint index = -1;\r\nint acc;\r\nint remote_num;\r\nunsigned char scancode;\r\nint i;\r\nif ( (urb->actual_length != 4) || (data[0] != 0x14) ||\r\n((data[3] & 0x0f) != 0x00) ) {\r\nati_remote_dump(&urb->dev->dev, data, urb->actual_length);\r\nreturn;\r\n}\r\nif (data[1] != ((data[2] + data[3] + 0xd5) & 0xff)) {\r\ndbginfo(&ati_remote->interface->dev,\r\n"wrong checksum in input: %02x %02x %02x %02x\n",\r\ndata[0], data[1], data[2], data[3]);\r\nreturn;\r\n}\r\nremote_num = (data[3] >> 4) & 0x0f;\r\nif (channel_mask & (1 << (remote_num + 1))) {\r\ndbginfo(&ati_remote->interface->dev,\r\n"Masked input from channel 0x%02x: data %02x,%02x, mask= 0x%02lx\n",\r\nremote_num, data[1], data[2], channel_mask);\r\nreturn;\r\n}\r\nscancode = data[2] & 0x7f;\r\nfor (i = 0; ati_remote_tbl[i].kind != KIND_END; i++) {\r\nif (scancode == ati_remote_tbl[i].data) {\r\nindex = i;\r\nbreak;\r\n}\r\n}\r\nif (index >= 0) {\r\ndbginfo(&ati_remote->interface->dev,\r\n"channel 0x%02x; mouse data %02x; index %d; keycode %d\n",\r\nremote_num, data[2], index, ati_remote_tbl[index].code);\r\nif (!dev)\r\nreturn;\r\n} else\r\ndbginfo(&ati_remote->interface->dev,\r\n"channel 0x%02x; key data %02x, scancode %02x\n",\r\nremote_num, data[2], scancode);\r\nif (index >= 0 && ati_remote_tbl[index].kind == KIND_LITERAL) {\r\ninput_event(dev, ati_remote_tbl[index].type,\r\nati_remote_tbl[index].code,\r\nati_remote_tbl[index].value);\r\ninput_sync(dev);\r\nati_remote->old_jiffies = jiffies;\r\nreturn;\r\n}\r\nif (index < 0 || ati_remote_tbl[index].kind == KIND_FILTERED) {\r\nunsigned long now = jiffies;\r\nif (ati_remote->old_data == data[2] &&\r\ntime_before(now, ati_remote->old_jiffies +\r\nmsecs_to_jiffies(repeat_filter))) {\r\nati_remote->repeat_count++;\r\n} else {\r\nati_remote->repeat_count = 0;\r\nati_remote->first_jiffies = now;\r\n}\r\nati_remote->old_data = data[2];\r\nati_remote->old_jiffies = now;\r\nif (ati_remote->repeat_count > 0 &&\r\n(ati_remote->repeat_count < 5 ||\r\ntime_before(now, ati_remote->first_jiffies +\r\nmsecs_to_jiffies(repeat_delay))))\r\nreturn;\r\nif (index < 0) {\r\nrc_keydown_notimeout(ati_remote->rdev, scancode,\r\ndata[2]);\r\nrc_keyup(ati_remote->rdev);\r\nreturn;\r\n}\r\ninput_event(dev, ati_remote_tbl[index].type,\r\nati_remote_tbl[index].code, 1);\r\ninput_sync(dev);\r\ninput_event(dev, ati_remote_tbl[index].type,\r\nati_remote_tbl[index].code, 0);\r\ninput_sync(dev);\r\n} else {\r\nacc = ati_remote_compute_accel(ati_remote);\r\nswitch (ati_remote_tbl[index].kind) {\r\ncase KIND_ACCEL:\r\ninput_event(dev, ati_remote_tbl[index].type,\r\nati_remote_tbl[index].code,\r\nati_remote_tbl[index].value * acc);\r\nbreak;\r\ncase KIND_LU:\r\ninput_report_rel(dev, REL_X, -acc);\r\ninput_report_rel(dev, REL_Y, -acc);\r\nbreak;\r\ncase KIND_RU:\r\ninput_report_rel(dev, REL_X, acc);\r\ninput_report_rel(dev, REL_Y, -acc);\r\nbreak;\r\ncase KIND_LD:\r\ninput_report_rel(dev, REL_X, -acc);\r\ninput_report_rel(dev, REL_Y, acc);\r\nbreak;\r\ncase KIND_RD:\r\ninput_report_rel(dev, REL_X, acc);\r\ninput_report_rel(dev, REL_Y, acc);\r\nbreak;\r\ndefault:\r\ndev_dbg(&ati_remote->interface->dev, "ati_remote kind=%d\n",\r\nati_remote_tbl[index].kind);\r\n}\r\ninput_sync(dev);\r\nati_remote->old_jiffies = jiffies;\r\nati_remote->old_data = data[2];\r\n}\r\n}\r\nstatic void ati_remote_irq_in(struct urb *urb)\r\n{\r\nstruct ati_remote *ati_remote = urb->context;\r\nint retval;\r\nswitch (urb->status) {\r\ncase 0:\r\nati_remote_input_report(urb);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&ati_remote->interface->dev, "%s: urb error status, unlink? \n",\r\n__func__);\r\nreturn;\r\ndefault:\r\ndev_dbg(&ati_remote->interface->dev, "%s: Nonzero urb status %d\n",\r\n__func__, urb->status);\r\n}\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(&ati_remote->interface->dev, "%s: usb_submit_urb()=%d\n",\r\n__func__, retval);\r\n}\r\nstatic int ati_remote_alloc_buffers(struct usb_device *udev,\r\nstruct ati_remote *ati_remote)\r\n{\r\nati_remote->inbuf = usb_alloc_coherent(udev, DATA_BUFSIZE, GFP_ATOMIC,\r\n&ati_remote->inbuf_dma);\r\nif (!ati_remote->inbuf)\r\nreturn -1;\r\nati_remote->outbuf = usb_alloc_coherent(udev, DATA_BUFSIZE, GFP_ATOMIC,\r\n&ati_remote->outbuf_dma);\r\nif (!ati_remote->outbuf)\r\nreturn -1;\r\nati_remote->irq_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!ati_remote->irq_urb)\r\nreturn -1;\r\nati_remote->out_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!ati_remote->out_urb)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void ati_remote_free_buffers(struct ati_remote *ati_remote)\r\n{\r\nusb_free_urb(ati_remote->irq_urb);\r\nusb_free_urb(ati_remote->out_urb);\r\nusb_free_coherent(ati_remote->udev, DATA_BUFSIZE,\r\nati_remote->inbuf, ati_remote->inbuf_dma);\r\nusb_free_coherent(ati_remote->udev, DATA_BUFSIZE,\r\nati_remote->outbuf, ati_remote->outbuf_dma);\r\n}\r\nstatic void ati_remote_input_init(struct ati_remote *ati_remote)\r\n{\r\nstruct input_dev *idev = ati_remote->idev;\r\nint i;\r\nidev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\r\nidev->keybit[BIT_WORD(BTN_MOUSE)] = BIT_MASK(BTN_LEFT) |\r\nBIT_MASK(BTN_RIGHT) | BIT_MASK(BTN_SIDE) | BIT_MASK(BTN_EXTRA);\r\nidev->relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y);\r\nfor (i = 0; ati_remote_tbl[i].kind != KIND_END; i++)\r\nif (ati_remote_tbl[i].type == EV_KEY)\r\nset_bit(ati_remote_tbl[i].code, idev->keybit);\r\ninput_set_drvdata(idev, ati_remote);\r\nidev->open = ati_remote_input_open;\r\nidev->close = ati_remote_input_close;\r\nidev->name = ati_remote->mouse_name;\r\nidev->phys = ati_remote->mouse_phys;\r\nusb_to_input_id(ati_remote->udev, &idev->id);\r\nidev->dev.parent = &ati_remote->interface->dev;\r\n}\r\nstatic void ati_remote_rc_init(struct ati_remote *ati_remote)\r\n{\r\nstruct rc_dev *rdev = ati_remote->rdev;\r\nrdev->priv = ati_remote;\r\nrdev->driver_type = RC_DRIVER_SCANCODE;\r\nrdev->allowed_protos = RC_TYPE_OTHER;\r\nrdev->driver_name = "ati_remote";\r\nrdev->open = ati_remote_rc_open;\r\nrdev->close = ati_remote_rc_close;\r\nrdev->input_name = ati_remote->rc_name;\r\nrdev->input_phys = ati_remote->rc_phys;\r\nusb_to_input_id(ati_remote->udev, &rdev->input_id);\r\nrdev->dev.parent = &ati_remote->interface->dev;\r\n}\r\nstatic int ati_remote_initialize(struct ati_remote *ati_remote)\r\n{\r\nstruct usb_device *udev = ati_remote->udev;\r\nint pipe, maxp;\r\ninit_waitqueue_head(&ati_remote->wait);\r\npipe = usb_rcvintpipe(udev, ati_remote->endpoint_in->bEndpointAddress);\r\nmaxp = usb_maxpacket(udev, pipe, usb_pipeout(pipe));\r\nmaxp = (maxp > DATA_BUFSIZE) ? DATA_BUFSIZE : maxp;\r\nusb_fill_int_urb(ati_remote->irq_urb, udev, pipe, ati_remote->inbuf,\r\nmaxp, ati_remote_irq_in, ati_remote,\r\nati_remote->endpoint_in->bInterval);\r\nati_remote->irq_urb->transfer_dma = ati_remote->inbuf_dma;\r\nati_remote->irq_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\npipe = usb_sndintpipe(udev, ati_remote->endpoint_out->bEndpointAddress);\r\nmaxp = usb_maxpacket(udev, pipe, usb_pipeout(pipe));\r\nmaxp = (maxp > DATA_BUFSIZE) ? DATA_BUFSIZE : maxp;\r\nusb_fill_int_urb(ati_remote->out_urb, udev, pipe, ati_remote->outbuf,\r\nmaxp, ati_remote_irq_out, ati_remote,\r\nati_remote->endpoint_out->bInterval);\r\nati_remote->out_urb->transfer_dma = ati_remote->outbuf_dma;\r\nati_remote->out_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nif ((ati_remote_sendpacket(ati_remote, 0x8004, init1)) ||\r\n(ati_remote_sendpacket(ati_remote, 0x8007, init2))) {\r\ndev_err(&ati_remote->interface->dev,\r\n"Initializing ati_remote hardware failed.\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ati_remote_probe(struct usb_interface *interface, const struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nstruct usb_host_interface *iface_host = interface->cur_altsetting;\r\nstruct usb_endpoint_descriptor *endpoint_in, *endpoint_out;\r\nstruct ati_remote *ati_remote;\r\nstruct input_dev *input_dev;\r\nstruct rc_dev *rc_dev;\r\nint err = -ENOMEM;\r\nif (iface_host->desc.bNumEndpoints != 2) {\r\nerr("%s: Unexpected desc.bNumEndpoints\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nendpoint_in = &iface_host->endpoint[0].desc;\r\nendpoint_out = &iface_host->endpoint[1].desc;\r\nif (!usb_endpoint_is_int_in(endpoint_in)) {\r\nerr("%s: Unexpected endpoint_in\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nif (le16_to_cpu(endpoint_in->wMaxPacketSize) == 0) {\r\nerr("%s: endpoint_in message size==0? \n", __func__);\r\nreturn -ENODEV;\r\n}\r\nati_remote = kzalloc(sizeof (struct ati_remote), GFP_KERNEL);\r\nrc_dev = rc_allocate_device();\r\nif (!ati_remote || !rc_dev)\r\ngoto fail1;\r\nif (ati_remote_alloc_buffers(udev, ati_remote))\r\ngoto fail2;\r\nati_remote->endpoint_in = endpoint_in;\r\nati_remote->endpoint_out = endpoint_out;\r\nati_remote->udev = udev;\r\nati_remote->rdev = rc_dev;\r\nati_remote->interface = interface;\r\nusb_make_path(udev, ati_remote->rc_phys, sizeof(ati_remote->rc_phys));\r\nstrlcpy(ati_remote->mouse_phys, ati_remote->rc_phys,\r\nsizeof(ati_remote->mouse_phys));\r\nstrlcat(ati_remote->rc_phys, "/input0", sizeof(ati_remote->rc_phys));\r\nstrlcat(ati_remote->mouse_phys, "/input1", sizeof(ati_remote->mouse_phys));\r\nif (udev->manufacturer)\r\nstrlcpy(ati_remote->rc_name, udev->manufacturer,\r\nsizeof(ati_remote->rc_name));\r\nif (udev->product)\r\nsnprintf(ati_remote->rc_name, sizeof(ati_remote->rc_name),\r\n"%s %s", ati_remote->rc_name, udev->product);\r\nif (!strlen(ati_remote->rc_name))\r\nsnprintf(ati_remote->rc_name, sizeof(ati_remote->rc_name),\r\nDRIVER_DESC "(%04x,%04x)",\r\nle16_to_cpu(ati_remote->udev->descriptor.idVendor),\r\nle16_to_cpu(ati_remote->udev->descriptor.idProduct));\r\nsnprintf(ati_remote->mouse_name, sizeof(ati_remote->mouse_name),\r\n"%s mouse", ati_remote->rc_name);\r\nif (id->driver_info)\r\nrc_dev->map_name = (const char *)id->driver_info;\r\nelse\r\nrc_dev->map_name = RC_MAP_ATI_X10;\r\nati_remote_rc_init(ati_remote);\r\nmutex_init(&ati_remote->open_mutex);\r\nerr = ati_remote_initialize(ati_remote);\r\nif (err)\r\ngoto fail3;\r\nerr = rc_register_device(ati_remote->rdev);\r\nif (err)\r\ngoto fail3;\r\nati_remote->rdev->input_dev->rep[REP_DELAY] = repeat_delay;\r\nif (mouse) {\r\ninput_dev = input_allocate_device();\r\nif (!input_dev)\r\ngoto fail4;\r\nati_remote->idev = input_dev;\r\nati_remote_input_init(ati_remote);\r\nerr = input_register_device(input_dev);\r\nif (err)\r\ngoto fail5;\r\n}\r\nusb_set_intfdata(interface, ati_remote);\r\nreturn 0;\r\nfail5: input_free_device(input_dev);\r\nfail4: rc_unregister_device(rc_dev);\r\nrc_dev = NULL;\r\nfail3: usb_kill_urb(ati_remote->irq_urb);\r\nusb_kill_urb(ati_remote->out_urb);\r\nfail2: ati_remote_free_buffers(ati_remote);\r\nfail1: rc_free_device(rc_dev);\r\nkfree(ati_remote);\r\nreturn err;\r\n}\r\nstatic void ati_remote_disconnect(struct usb_interface *interface)\r\n{\r\nstruct ati_remote *ati_remote;\r\nati_remote = usb_get_intfdata(interface);\r\nusb_set_intfdata(interface, NULL);\r\nif (!ati_remote) {\r\ndev_warn(&interface->dev, "%s - null device?\n", __func__);\r\nreturn;\r\n}\r\nusb_kill_urb(ati_remote->irq_urb);\r\nusb_kill_urb(ati_remote->out_urb);\r\nif (ati_remote->idev)\r\ninput_unregister_device(ati_remote->idev);\r\nrc_unregister_device(ati_remote->rdev);\r\nati_remote_free_buffers(ati_remote);\r\nkfree(ati_remote);\r\n}
