static inline int __iwmct_tx(struct iwmct_priv *priv, void *src, int count)\r\n{\r\nreturn sdio_memcpy_toio(priv->func, IWMC_SDIO_DATA_ADDR, src, count);\r\n}\r\nint iwmct_tx(struct iwmct_priv *priv, void *src, int count)\r\n{\r\nint ret;\r\nsdio_claim_host(priv->func);\r\nret = __iwmct_tx(priv, src, count);\r\nsdio_release_host(priv->func);\r\nreturn ret;\r\n}\r\nstatic void iwmct_rescan_worker(struct work_struct *ws)\r\n{\r\nstruct iwmct_priv *priv;\r\nint ret;\r\npriv = container_of(ws, struct iwmct_priv, bus_rescan_worker);\r\nLOG_INFO(priv, FW_MSG, "Calling bus_rescan\n");\r\nret = bus_rescan_devices(priv->func->dev.bus);\r\nif (ret < 0)\r\nLOG_INFO(priv, INIT, "bus_rescan_devices FAILED!!!\n");\r\n}\r\nstatic void op_top_message(struct iwmct_priv *priv, struct top_msg *msg)\r\n{\r\nswitch (msg->hdr.opcode) {\r\ncase OP_OPR_ALIVE:\r\nLOG_INFO(priv, FW_MSG, "Got ALIVE from device, wake rescan\n");\r\nschedule_work(&priv->bus_rescan_worker);\r\nbreak;\r\ndefault:\r\nLOG_INFO(priv, FW_MSG, "Received msg opcode 0x%X\n",\r\nmsg->hdr.opcode);\r\nbreak;\r\n}\r\n}\r\nstatic void handle_top_message(struct iwmct_priv *priv, u8 *buf, int len)\r\n{\r\nstruct top_msg *msg;\r\nmsg = (struct top_msg *)buf;\r\nif (msg->hdr.type != COMM_TYPE_D2H) {\r\nLOG_ERROR(priv, FW_MSG,\r\n"Message from TOP with invalid message type 0x%X\n",\r\nmsg->hdr.type);\r\nreturn;\r\n}\r\nif (len < sizeof(msg->hdr)) {\r\nLOG_ERROR(priv, FW_MSG,\r\n"Message from TOP is too short for message header "\r\n"received %d bytes, expected at least %zd bytes\n",\r\nlen, sizeof(msg->hdr));\r\nreturn;\r\n}\r\nif (len < le16_to_cpu(msg->hdr.length) + sizeof(msg->hdr)) {\r\nLOG_ERROR(priv, FW_MSG,\r\n"Message length (%d bytes) is shorter than "\r\n"in header (%d bytes)\n",\r\nlen, le16_to_cpu(msg->hdr.length));\r\nreturn;\r\n}\r\nswitch (msg->hdr.category) {\r\ncase COMM_CATEGORY_OPERATIONAL:\r\nop_top_message(priv, (struct top_msg *)buf);\r\nbreak;\r\ncase COMM_CATEGORY_DEBUG:\r\ncase COMM_CATEGORY_TESTABILITY:\r\ncase COMM_CATEGORY_DIAGNOSTICS:\r\niwmct_log_top_message(priv, buf, len);\r\nbreak;\r\ndefault:\r\nLOG_ERROR(priv, FW_MSG,\r\n"Message from TOP with unknown category 0x%X\n",\r\nmsg->hdr.category);\r\nbreak;\r\n}\r\n}\r\nint iwmct_send_hcmd(struct iwmct_priv *priv, u8 *cmd, u16 len)\r\n{\r\nint ret;\r\nu8 *buf;\r\nLOG_TRACE(priv, FW_MSG, "Sending hcmd:\n");\r\n((struct top_msg *)cmd)->hdr.flags |= CMD_FLAG_PADDING_256;\r\nLOG_HEXDUMP(FW_MSG, cmd, len);\r\nif (len > FW_HCMD_BLOCK_SIZE) {\r\nLOG_ERROR(priv, FW_MSG, "size %d exceeded hcmd max size %d\n",\r\nlen, FW_HCMD_BLOCK_SIZE);\r\nreturn -1;\r\n}\r\nbuf = kzalloc(FW_HCMD_BLOCK_SIZE, GFP_KERNEL);\r\nif (!buf) {\r\nLOG_ERROR(priv, FW_MSG, "kzalloc error, buf size %d\n",\r\nFW_HCMD_BLOCK_SIZE);\r\nreturn -1;\r\n}\r\nmemcpy(buf, cmd, len);\r\nret = iwmct_tx(priv, buf, FW_HCMD_BLOCK_SIZE);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic void iwmct_irq_read_worker(struct work_struct *ws)\r\n{\r\nstruct iwmct_priv *priv;\r\nstruct iwmct_work_struct *read_req;\r\n__le32 *buf = NULL;\r\nint ret;\r\nint iosize;\r\nu32 barker;\r\nbool is_barker;\r\npriv = container_of(ws, struct iwmct_priv, isr_worker);\r\nLOG_TRACE(priv, IRQ, "enter iwmct_irq_read_worker %p\n", ws);\r\nsdio_claim_host(priv->func);\r\nif (list_empty(&priv->read_req_list)) {\r\nLOG_ERROR(priv, IRQ, "read_req_list empty in read worker\n");\r\ngoto exit_release;\r\n}\r\nread_req = list_entry(priv->read_req_list.next,\r\nstruct iwmct_work_struct, list);\r\nlist_del(&read_req->list);\r\niosize = read_req->iosize;\r\nkfree(read_req);\r\nbuf = kzalloc(iosize, GFP_KERNEL);\r\nif (!buf) {\r\nLOG_ERROR(priv, IRQ, "kzalloc error, buf size %d\n", iosize);\r\ngoto exit_release;\r\n}\r\nLOG_INFO(priv, IRQ, "iosize=%d, buf=%p, func=%d\n",\r\niosize, buf, priv->func->num);\r\nret = sdio_memcpy_fromio(priv->func, buf, IWMC_SDIO_DATA_ADDR, iosize);\r\nif (ret) {\r\nLOG_ERROR(priv, IRQ, "error %d reading buffer\n", ret);\r\ngoto exit_release;\r\n}\r\nLOG_HEXDUMP(IRQ, (u8 *)buf, iosize);\r\nbarker = le32_to_cpu(buf[0]);\r\nif (barker == IWMC_BARKER_ACK ||\r\n(barker & BARKER_DNLOAD_BARKER_MSK) == IWMC_BARKER_REBOOT) {\r\nis_barker = (buf[1] == buf[0]) &&\r\n(buf[2] == buf[0]) &&\r\n(buf[3] == buf[0]);\r\nif (!is_barker) {\r\nLOG_WARNING(priv, IRQ,\r\n"Potentially inconsistent barker "\r\n"%08X_%08X_%08X_%08X\n",\r\nle32_to_cpu(buf[0]), le32_to_cpu(buf[1]),\r\nle32_to_cpu(buf[2]), le32_to_cpu(buf[3]));\r\n}\r\n} else {\r\nis_barker = false;\r\n}\r\nif (!is_barker) {\r\nsdio_release_host(priv->func);\r\nhandle_top_message(priv, (u8 *)buf, iosize);\r\ngoto exit;\r\n} else if (barker == IWMC_BARKER_ACK) {\r\nif (atomic_read(&priv->dev_sync) == 0) {\r\nLOG_ERROR(priv, IRQ,\r\n"ACK barker arrived out-of-sync\n");\r\ngoto exit_release;\r\n}\r\natomic_set(&priv->dev_sync, 0);\r\nLOG_INFO(priv, IRQ, "ACK barker arrived "\r\n"- starting FW download\n");\r\n} else {\r\nLOG_INFO(priv, IRQ, "Received reboot barker: %x\n", barker);\r\npriv->barker = barker;\r\nif (barker & BARKER_DNLOAD_SYNC_MSK) {\r\nret = __iwmct_tx(priv, buf, iosize);\r\nif (ret) {\r\nLOG_ERROR(priv, IRQ,\r\n"error %d echoing barker\n", ret);\r\ngoto exit_release;\r\n}\r\nLOG_INFO(priv, IRQ, "Echoing barker to device\n");\r\natomic_set(&priv->dev_sync, 1);\r\ngoto exit_release;\r\n}\r\nLOG_INFO(priv, IRQ, "No sync requested "\r\n"- starting FW download\n");\r\n}\r\nsdio_release_host(priv->func);\r\nif (priv->dbg.fw_download)\r\niwmct_fw_load(priv);\r\nelse\r\nLOG_ERROR(priv, IRQ, "FW download not allowed\n");\r\ngoto exit;\r\nexit_release:\r\nsdio_release_host(priv->func);\r\nexit:\r\nkfree(buf);\r\nLOG_TRACE(priv, IRQ, "exit iwmct_irq_read_worker\n");\r\n}\r\nstatic void iwmct_irq(struct sdio_func *func)\r\n{\r\nstruct iwmct_priv *priv;\r\nint val, ret;\r\nint iosize;\r\nint addr = IWMC_SDIO_INTR_GET_SIZE_ADDR;\r\nstruct iwmct_work_struct *read_req;\r\npriv = sdio_get_drvdata(func);\r\nLOG_TRACE(priv, IRQ, "enter iwmct_irq\n");\r\nval = sdio_readb(func, IWMC_SDIO_INTR_STATUS_ADDR, &ret);\r\nLOG_TRACE(priv, IRQ, "iir value = %d, ret=%d\n", val, ret);\r\nif (!val) {\r\nLOG_ERROR(priv, IRQ, "iir = 0, exiting ISR\n");\r\ngoto exit_clear_intr;\r\n}\r\nval = sdio_readb(priv->func, addr++, &ret);\r\niosize = val;\r\nval = sdio_readb(priv->func, addr++, &ret);\r\niosize += val << 8;\r\nLOG_INFO(priv, IRQ, "READ size %d\n", iosize);\r\nif (iosize == 0) {\r\nLOG_ERROR(priv, IRQ, "READ size %d, exiting ISR\n", iosize);\r\ngoto exit_clear_intr;\r\n}\r\nread_req = kzalloc(sizeof(struct iwmct_work_struct), GFP_KERNEL);\r\nif (!read_req) {\r\nLOG_ERROR(priv, IRQ, "failed to allocate read_req, exit ISR\n");\r\ngoto exit_clear_intr;\r\n}\r\nINIT_LIST_HEAD(&read_req->list);\r\nread_req->iosize = iosize;\r\nlist_add_tail(&priv->read_req_list, &read_req->list);\r\nsdio_writeb(func, 1, IWMC_SDIO_INTR_CLEAR_ADDR, &ret);\r\nschedule_work(&priv->isr_worker);\r\nLOG_TRACE(priv, IRQ, "exit iwmct_irq\n");\r\nreturn;\r\nexit_clear_intr:\r\nsdio_writeb(func, 1, IWMC_SDIO_INTR_CLEAR_ADDR, &ret);\r\n}\r\nvoid iwmct_dbg_init_params(struct iwmct_priv *priv)\r\n{\r\n#ifdef CONFIG_IWMC3200TOP_DEBUG\r\nint i;\r\nfor (i = 0; i < log_level_argc; i++) {\r\ndev_notice(&priv->func->dev, "log_level[%d]=0x%X\n",\r\ni, log_level[i]);\r\niwmct_log_set_filter((log_level[i] >> 8) & 0xFF,\r\nlog_level[i] & 0xFF);\r\n}\r\nfor (i = 0; i < log_level_fw_argc; i++) {\r\ndev_notice(&priv->func->dev, "log_level_fw[%d]=0x%X\n",\r\ni, log_level_fw[i]);\r\niwmct_log_set_fw_filter((log_level_fw[i] >> 8) & 0xFF,\r\nlog_level_fw[i] & 0xFF);\r\n}\r\n#endif\r\npriv->dbg.blocks = blocks;\r\nLOG_INFO(priv, INIT, "blocks=%d\n", blocks);\r\npriv->dbg.dump = (bool)dump;\r\nLOG_INFO(priv, INIT, "dump=%d\n", dump);\r\npriv->dbg.jump = (bool)jump;\r\nLOG_INFO(priv, INIT, "jump=%d\n", jump);\r\npriv->dbg.direct = (bool)direct;\r\nLOG_INFO(priv, INIT, "direct=%d\n", direct);\r\npriv->dbg.checksum = (bool)checksum;\r\nLOG_INFO(priv, INIT, "checksum=%d\n", checksum);\r\npriv->dbg.fw_download = (bool)fw_download;\r\nLOG_INFO(priv, INIT, "fw_download=%d\n", fw_download);\r\npriv->dbg.block_size = block_size;\r\nLOG_INFO(priv, INIT, "block_size=%d\n", block_size);\r\npriv->dbg.download_trans_blks = download_trans_blks;\r\nLOG_INFO(priv, INIT, "download_trans_blks=%d\n", download_trans_blks);\r\n}\r\nstatic ssize_t show_iwmct_fw_version(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct iwmct_priv *priv = dev_get_drvdata(d);\r\nreturn sprintf(buf, "%s\n", priv->dbg.label_fw);\r\n}\r\nstatic int iwmct_probe(struct sdio_func *func,\r\nconst struct sdio_device_id *id)\r\n{\r\nstruct iwmct_priv *priv;\r\nint ret;\r\nint val = 1;\r\nint addr = IWMC_SDIO_INTR_ENABLE_ADDR;\r\ndev_dbg(&func->dev, "enter iwmct_probe\n");\r\ndev_dbg(&func->dev, "IRQ polling period id %u msecs, HZ is %d\n",\r\njiffies_to_msecs(2147483647), HZ);\r\npriv = kzalloc(sizeof(struct iwmct_priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&func->dev, "kzalloc error\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->func = func;\r\nsdio_set_drvdata(func, priv);\r\nINIT_WORK(&priv->bus_rescan_worker, iwmct_rescan_worker);\r\nINIT_WORK(&priv->isr_worker, iwmct_irq_read_worker);\r\ninit_waitqueue_head(&priv->wait_q);\r\nsdio_claim_host(func);\r\nfunc->enable_timeout = 10;\r\nret = sdio_set_block_size(func, priv->dbg.block_size);\r\nif (ret) {\r\nLOG_ERROR(priv, INIT,\r\n"sdio_set_block_size() failure: %d\n", ret);\r\ngoto error_sdio_enable;\r\n}\r\nret = sdio_enable_func(func);\r\nif (ret) {\r\nLOG_ERROR(priv, INIT, "sdio_enable_func() failure: %d\n", ret);\r\ngoto error_sdio_enable;\r\n}\r\natomic_set(&priv->reset, 0);\r\natomic_set(&priv->dev_sync, 0);\r\nINIT_LIST_HEAD(&priv->read_req_list);\r\niwmct_dbg_init_params(priv);\r\nret = sysfs_create_group(&func->dev.kobj, &iwmct_attribute_group);\r\nif (ret) {\r\nLOG_ERROR(priv, INIT, "Failed to register attributes and "\r\n"initialize module_params\n");\r\ngoto error_dev_attrs;\r\n}\r\niwmct_dbgfs_register(priv, DRV_NAME);\r\nif (!priv->dbg.direct && priv->dbg.download_trans_blks > 8) {\r\nLOG_INFO(priv, INIT,\r\n"Reducing transaction to 8 blocks = 2K (from %d)\n",\r\npriv->dbg.download_trans_blks);\r\npriv->dbg.download_trans_blks = 8;\r\n}\r\npriv->trans_len = priv->dbg.download_trans_blks * priv->dbg.block_size;\r\nLOG_INFO(priv, INIT, "Transaction length = %d\n", priv->trans_len);\r\nret = sdio_claim_irq(func, iwmct_irq);\r\nif (ret) {\r\nLOG_ERROR(priv, INIT, "sdio_claim_irq() failure: %d\n", ret);\r\ngoto error_claim_irq;\r\n}\r\nsdio_writeb(priv->func, val, addr, &ret);\r\nif (ret) {\r\nLOG_ERROR(priv, INIT, "Failure writing to "\r\n"Interrupt Enable Register (%d): %d\n", addr, ret);\r\ngoto error_enable_int;\r\n}\r\nsdio_release_host(func);\r\nLOG_INFO(priv, INIT, "exit iwmct_probe\n");\r\nreturn ret;\r\nerror_enable_int:\r\nsdio_release_irq(func);\r\nerror_claim_irq:\r\nsdio_disable_func(func);\r\nerror_dev_attrs:\r\niwmct_dbgfs_unregister(priv->dbgfs);\r\nsysfs_remove_group(&func->dev.kobj, &iwmct_attribute_group);\r\nerror_sdio_enable:\r\nsdio_release_host(func);\r\nreturn ret;\r\n}\r\nstatic void iwmct_remove(struct sdio_func *func)\r\n{\r\nstruct iwmct_work_struct *read_req;\r\nstruct iwmct_priv *priv = sdio_get_drvdata(func);\r\nLOG_INFO(priv, INIT, "enter\n");\r\nsdio_claim_host(func);\r\nsdio_release_irq(func);\r\nsdio_release_host(func);\r\nflush_work_sync(&priv->bus_rescan_worker);\r\nflush_work_sync(&priv->isr_worker);\r\nsdio_claim_host(func);\r\nsdio_disable_func(func);\r\nsysfs_remove_group(&func->dev.kobj, &iwmct_attribute_group);\r\niwmct_dbgfs_unregister(priv->dbgfs);\r\nsdio_release_host(func);\r\nwhile (!list_empty(&priv->read_req_list)) {\r\nread_req = list_entry(priv->read_req_list.next,\r\nstruct iwmct_work_struct, list);\r\nlist_del(&read_req->list);\r\nkfree(read_req);\r\n}\r\nkfree(priv);\r\n}\r\nstatic int __init iwmct_init(void)\r\n{\r\nint rc;\r\niwmct_log_set_filter(LOG_SRC_ALL, LOG_SEV_FILTER_RUNTIME);\r\niwmct_log_set_filter(LOG_SRC_FW_MSG, LOG_SEV_FW_FILTER_ALL);\r\niwmct_log_set_fw_filter(LOG_SRC_ALL, FW_LOG_SEV_FILTER_RUNTIME);\r\nrc = sdio_register_driver(&iwmct_driver);\r\nreturn rc;\r\n}\r\nstatic void __exit iwmct_exit(void)\r\n{\r\nsdio_unregister_driver(&iwmct_driver);\r\n}
