static int __enable_clocks(struct msm_iommu_drvdata *drvdata)\r\n{\r\nint ret;\r\nret = clk_enable(drvdata->pclk);\r\nif (ret)\r\ngoto fail;\r\nif (drvdata->clk) {\r\nret = clk_enable(drvdata->clk);\r\nif (ret)\r\nclk_disable(drvdata->pclk);\r\n}\r\nfail:\r\nreturn ret;\r\n}\r\nstatic void __disable_clocks(struct msm_iommu_drvdata *drvdata)\r\n{\r\nif (drvdata->clk)\r\nclk_disable(drvdata->clk);\r\nclk_disable(drvdata->pclk);\r\n}\r\nstatic int __flush_iotlb(struct iommu_domain *domain)\r\n{\r\nstruct msm_priv *priv = domain->priv;\r\nstruct msm_iommu_drvdata *iommu_drvdata;\r\nstruct msm_iommu_ctx_drvdata *ctx_drvdata;\r\nint ret = 0;\r\n#ifndef CONFIG_IOMMU_PGTABLES_L2\r\nunsigned long *fl_table = priv->pgtable;\r\nint i;\r\nif (!list_empty(&priv->list_attached)) {\r\ndmac_flush_range(fl_table, fl_table + SZ_16K);\r\nfor (i = 0; i < NUM_FL_PTE; i++)\r\nif ((fl_table[i] & 0x03) == FL_TYPE_TABLE) {\r\nvoid *sl_table = __va(fl_table[i] &\r\nFL_BASE_MASK);\r\ndmac_flush_range(sl_table, sl_table + SZ_4K);\r\n}\r\n}\r\n#endif\r\nlist_for_each_entry(ctx_drvdata, &priv->list_attached, attached_elm) {\r\nif (!ctx_drvdata->pdev || !ctx_drvdata->pdev->dev.parent)\r\nBUG();\r\niommu_drvdata = dev_get_drvdata(ctx_drvdata->pdev->dev.parent);\r\nBUG_ON(!iommu_drvdata);\r\nret = __enable_clocks(iommu_drvdata);\r\nif (ret)\r\ngoto fail;\r\nSET_CTX_TLBIALL(iommu_drvdata->base, ctx_drvdata->num, 0);\r\n__disable_clocks(iommu_drvdata);\r\n}\r\nfail:\r\nreturn ret;\r\n}\r\nstatic void __reset_context(void __iomem *base, int ctx)\r\n{\r\nSET_BPRCOSH(base, ctx, 0);\r\nSET_BPRCISH(base, ctx, 0);\r\nSET_BPRCNSH(base, ctx, 0);\r\nSET_BPSHCFG(base, ctx, 0);\r\nSET_BPMTCFG(base, ctx, 0);\r\nSET_ACTLR(base, ctx, 0);\r\nSET_SCTLR(base, ctx, 0);\r\nSET_FSRRESTORE(base, ctx, 0);\r\nSET_TTBR0(base, ctx, 0);\r\nSET_TTBR1(base, ctx, 0);\r\nSET_TTBCR(base, ctx, 0);\r\nSET_BFBCR(base, ctx, 0);\r\nSET_PAR(base, ctx, 0);\r\nSET_FAR(base, ctx, 0);\r\nSET_CTX_TLBIALL(base, ctx, 0);\r\nSET_TLBFLPTER(base, ctx, 0);\r\nSET_TLBSLPTER(base, ctx, 0);\r\nSET_TLBLKCR(base, ctx, 0);\r\nSET_PRRR(base, ctx, 0);\r\nSET_NMRR(base, ctx, 0);\r\n}\r\nstatic void __program_context(void __iomem *base, int ctx, phys_addr_t pgtable)\r\n{\r\nunsigned int prrr, nmrr;\r\n__reset_context(base, ctx);\r\nSET_TLBMCFG(base, ctx, 0x3);\r\nSET_V2PCFG(base, ctx, 0x3);\r\nSET_TTBCR(base, ctx, 0);\r\nSET_TTBR0_PA(base, ctx, (pgtable >> 14));\r\nSET_CTX_TLBIALL(base, ctx, 0);\r\nSET_IRPTNDX(base, ctx, 0);\r\nSET_CFEIE(base, ctx, 1);\r\nSET_CFCFG(base, ctx, 1);\r\nSET_RCISH(base, ctx, 1);\r\nSET_RCOSH(base, ctx, 1);\r\nSET_RCNSH(base, ctx, 1);\r\nSET_TRE(base, ctx, 1);\r\nRCP15_PRRR(prrr);\r\nRCP15_NMRR(nmrr);\r\nSET_PRRR(base, ctx, prrr);\r\nSET_NMRR(base, ctx, nmrr);\r\nSET_BFBDFE(base, ctx, 1);\r\n#ifdef CONFIG_IOMMU_PGTABLES_L2\r\nSET_TTBR0_SH(base, ctx, 1);\r\nSET_TTBR1_SH(base, ctx, 1);\r\nSET_TTBR0_NOS(base, ctx, 1);\r\nSET_TTBR1_NOS(base, ctx, 1);\r\nSET_TTBR0_IRGNH(base, ctx, 0);\r\nSET_TTBR0_IRGNL(base, ctx, 1);\r\nSET_TTBR1_IRGNH(base, ctx, 0);\r\nSET_TTBR1_IRGNL(base, ctx, 1);\r\nSET_TTBR0_ORGN(base, ctx, 1);\r\nSET_TTBR1_ORGN(base, ctx, 1);\r\n#endif\r\nSET_M(base, ctx, 1);\r\n}\r\nstatic int msm_iommu_domain_init(struct iommu_domain *domain)\r\n{\r\nstruct msm_priv *priv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\ngoto fail_nomem;\r\nINIT_LIST_HEAD(&priv->list_attached);\r\npriv->pgtable = (unsigned long *)__get_free_pages(GFP_KERNEL,\r\nget_order(SZ_16K));\r\nif (!priv->pgtable)\r\ngoto fail_nomem;\r\nmemset(priv->pgtable, 0, SZ_16K);\r\ndomain->priv = priv;\r\nreturn 0;\r\nfail_nomem:\r\nkfree(priv);\r\nreturn -ENOMEM;\r\n}\r\nstatic void msm_iommu_domain_destroy(struct iommu_domain *domain)\r\n{\r\nstruct msm_priv *priv;\r\nunsigned long flags;\r\nunsigned long *fl_table;\r\nint i;\r\nspin_lock_irqsave(&msm_iommu_lock, flags);\r\npriv = domain->priv;\r\ndomain->priv = NULL;\r\nif (priv) {\r\nfl_table = priv->pgtable;\r\nfor (i = 0; i < NUM_FL_PTE; i++)\r\nif ((fl_table[i] & 0x03) == FL_TYPE_TABLE)\r\nfree_page((unsigned long) __va(((fl_table[i]) &\r\nFL_BASE_MASK)));\r\nfree_pages((unsigned long)priv->pgtable, get_order(SZ_16K));\r\npriv->pgtable = NULL;\r\n}\r\nkfree(priv);\r\nspin_unlock_irqrestore(&msm_iommu_lock, flags);\r\n}\r\nstatic int msm_iommu_attach_dev(struct iommu_domain *domain, struct device *dev)\r\n{\r\nstruct msm_priv *priv;\r\nstruct msm_iommu_ctx_dev *ctx_dev;\r\nstruct msm_iommu_drvdata *iommu_drvdata;\r\nstruct msm_iommu_ctx_drvdata *ctx_drvdata;\r\nstruct msm_iommu_ctx_drvdata *tmp_drvdata;\r\nint ret = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&msm_iommu_lock, flags);\r\npriv = domain->priv;\r\nif (!priv || !dev) {\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\niommu_drvdata = dev_get_drvdata(dev->parent);\r\nctx_drvdata = dev_get_drvdata(dev);\r\nctx_dev = dev->platform_data;\r\nif (!iommu_drvdata || !ctx_drvdata || !ctx_dev) {\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nif (!list_empty(&ctx_drvdata->attached_elm)) {\r\nret = -EBUSY;\r\ngoto fail;\r\n}\r\nlist_for_each_entry(tmp_drvdata, &priv->list_attached, attached_elm)\r\nif (tmp_drvdata == ctx_drvdata) {\r\nret = -EBUSY;\r\ngoto fail;\r\n}\r\nret = __enable_clocks(iommu_drvdata);\r\nif (ret)\r\ngoto fail;\r\n__program_context(iommu_drvdata->base, ctx_dev->num,\r\n__pa(priv->pgtable));\r\n__disable_clocks(iommu_drvdata);\r\nlist_add(&(ctx_drvdata->attached_elm), &priv->list_attached);\r\nret = __flush_iotlb(domain);\r\nfail:\r\nspin_unlock_irqrestore(&msm_iommu_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void msm_iommu_detach_dev(struct iommu_domain *domain,\r\nstruct device *dev)\r\n{\r\nstruct msm_priv *priv;\r\nstruct msm_iommu_ctx_dev *ctx_dev;\r\nstruct msm_iommu_drvdata *iommu_drvdata;\r\nstruct msm_iommu_ctx_drvdata *ctx_drvdata;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&msm_iommu_lock, flags);\r\npriv = domain->priv;\r\nif (!priv || !dev)\r\ngoto fail;\r\niommu_drvdata = dev_get_drvdata(dev->parent);\r\nctx_drvdata = dev_get_drvdata(dev);\r\nctx_dev = dev->platform_data;\r\nif (!iommu_drvdata || !ctx_drvdata || !ctx_dev)\r\ngoto fail;\r\nret = __flush_iotlb(domain);\r\nif (ret)\r\ngoto fail;\r\nret = __enable_clocks(iommu_drvdata);\r\nif (ret)\r\ngoto fail;\r\n__reset_context(iommu_drvdata->base, ctx_dev->num);\r\n__disable_clocks(iommu_drvdata);\r\nlist_del_init(&ctx_drvdata->attached_elm);\r\nfail:\r\nspin_unlock_irqrestore(&msm_iommu_lock, flags);\r\n}\r\nstatic int msm_iommu_map(struct iommu_domain *domain, unsigned long va,\r\nphys_addr_t pa, size_t len, int prot)\r\n{\r\nstruct msm_priv *priv;\r\nunsigned long flags;\r\nunsigned long *fl_table;\r\nunsigned long *fl_pte;\r\nunsigned long fl_offset;\r\nunsigned long *sl_table;\r\nunsigned long *sl_pte;\r\nunsigned long sl_offset;\r\nunsigned int pgprot;\r\nint ret = 0, tex, sh;\r\nspin_lock_irqsave(&msm_iommu_lock, flags);\r\nsh = (prot & MSM_IOMMU_ATTR_SH) ? 1 : 0;\r\ntex = msm_iommu_tex_class[prot & MSM_IOMMU_CP_MASK];\r\nif (tex < 0 || tex > NUM_TEX_CLASS - 1) {\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\npriv = domain->priv;\r\nif (!priv) {\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nfl_table = priv->pgtable;\r\nif (len != SZ_16M && len != SZ_1M &&\r\nlen != SZ_64K && len != SZ_4K) {\r\npr_debug("Bad size: %d\n", len);\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nif (!fl_table) {\r\npr_debug("Null page table\n");\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nif (len == SZ_16M || len == SZ_1M) {\r\npgprot = sh ? FL_SHARED : 0;\r\npgprot |= tex & 0x01 ? FL_BUFFERABLE : 0;\r\npgprot |= tex & 0x02 ? FL_CACHEABLE : 0;\r\npgprot |= tex & 0x04 ? FL_TEX0 : 0;\r\n} else {\r\npgprot = sh ? SL_SHARED : 0;\r\npgprot |= tex & 0x01 ? SL_BUFFERABLE : 0;\r\npgprot |= tex & 0x02 ? SL_CACHEABLE : 0;\r\npgprot |= tex & 0x04 ? SL_TEX0 : 0;\r\n}\r\nfl_offset = FL_OFFSET(va);\r\nfl_pte = fl_table + fl_offset;\r\nif (len == SZ_16M) {\r\nint i = 0;\r\nfor (i = 0; i < 16; i++)\r\n*(fl_pte+i) = (pa & 0xFF000000) | FL_SUPERSECTION |\r\nFL_AP_READ | FL_AP_WRITE | FL_TYPE_SECT |\r\nFL_SHARED | FL_NG | pgprot;\r\n}\r\nif (len == SZ_1M)\r\n*fl_pte = (pa & 0xFFF00000) | FL_AP_READ | FL_AP_WRITE | FL_NG |\r\nFL_TYPE_SECT | FL_SHARED | pgprot;\r\nif ((len == SZ_4K || len == SZ_64K) && (*fl_pte) == 0) {\r\nunsigned long *sl;\r\nsl = (unsigned long *) __get_free_pages(GFP_ATOMIC,\r\nget_order(SZ_4K));\r\nif (!sl) {\r\npr_debug("Could not allocate second level table\n");\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nmemset(sl, 0, SZ_4K);\r\n*fl_pte = ((((int)__pa(sl)) & FL_BASE_MASK) | FL_TYPE_TABLE);\r\n}\r\nsl_table = (unsigned long *) __va(((*fl_pte) & FL_BASE_MASK));\r\nsl_offset = SL_OFFSET(va);\r\nsl_pte = sl_table + sl_offset;\r\nif (len == SZ_4K)\r\n*sl_pte = (pa & SL_BASE_MASK_SMALL) | SL_AP0 | SL_AP1 | SL_NG |\r\nSL_SHARED | SL_TYPE_SMALL | pgprot;\r\nif (len == SZ_64K) {\r\nint i;\r\nfor (i = 0; i < 16; i++)\r\n*(sl_pte+i) = (pa & SL_BASE_MASK_LARGE) | SL_AP0 |\r\nSL_NG | SL_AP1 | SL_SHARED | SL_TYPE_LARGE | pgprot;\r\n}\r\nret = __flush_iotlb(domain);\r\nfail:\r\nspin_unlock_irqrestore(&msm_iommu_lock, flags);\r\nreturn ret;\r\n}\r\nstatic size_t msm_iommu_unmap(struct iommu_domain *domain, unsigned long va,\r\nsize_t len)\r\n{\r\nstruct msm_priv *priv;\r\nunsigned long flags;\r\nunsigned long *fl_table;\r\nunsigned long *fl_pte;\r\nunsigned long fl_offset;\r\nunsigned long *sl_table;\r\nunsigned long *sl_pte;\r\nunsigned long sl_offset;\r\nint i, ret = 0;\r\nspin_lock_irqsave(&msm_iommu_lock, flags);\r\npriv = domain->priv;\r\nif (!priv)\r\ngoto fail;\r\nfl_table = priv->pgtable;\r\nif (len != SZ_16M && len != SZ_1M &&\r\nlen != SZ_64K && len != SZ_4K) {\r\npr_debug("Bad length: %d\n", len);\r\ngoto fail;\r\n}\r\nif (!fl_table) {\r\npr_debug("Null page table\n");\r\ngoto fail;\r\n}\r\nfl_offset = FL_OFFSET(va);\r\nfl_pte = fl_table + fl_offset;\r\nif (*fl_pte == 0) {\r\npr_debug("First level PTE is 0\n");\r\ngoto fail;\r\n}\r\nif (len == SZ_16M)\r\nfor (i = 0; i < 16; i++)\r\n*(fl_pte+i) = 0;\r\nif (len == SZ_1M)\r\n*fl_pte = 0;\r\nsl_table = (unsigned long *) __va(((*fl_pte) & FL_BASE_MASK));\r\nsl_offset = SL_OFFSET(va);\r\nsl_pte = sl_table + sl_offset;\r\nif (len == SZ_64K) {\r\nfor (i = 0; i < 16; i++)\r\n*(sl_pte+i) = 0;\r\n}\r\nif (len == SZ_4K)\r\n*sl_pte = 0;\r\nif (len == SZ_4K || len == SZ_64K) {\r\nint used = 0;\r\nfor (i = 0; i < NUM_SL_PTE; i++)\r\nif (sl_table[i])\r\nused = 1;\r\nif (!used) {\r\nfree_page((unsigned long)sl_table);\r\n*fl_pte = 0;\r\n}\r\n}\r\nret = __flush_iotlb(domain);\r\nfail:\r\nspin_unlock_irqrestore(&msm_iommu_lock, flags);\r\nlen = ret ? 0 : len;\r\nreturn len;\r\n}\r\nstatic phys_addr_t msm_iommu_iova_to_phys(struct iommu_domain *domain,\r\nunsigned long va)\r\n{\r\nstruct msm_priv *priv;\r\nstruct msm_iommu_drvdata *iommu_drvdata;\r\nstruct msm_iommu_ctx_drvdata *ctx_drvdata;\r\nunsigned int par;\r\nunsigned long flags;\r\nvoid __iomem *base;\r\nphys_addr_t ret = 0;\r\nint ctx;\r\nspin_lock_irqsave(&msm_iommu_lock, flags);\r\npriv = domain->priv;\r\nif (list_empty(&priv->list_attached))\r\ngoto fail;\r\nctx_drvdata = list_entry(priv->list_attached.next,\r\nstruct msm_iommu_ctx_drvdata, attached_elm);\r\niommu_drvdata = dev_get_drvdata(ctx_drvdata->pdev->dev.parent);\r\nbase = iommu_drvdata->base;\r\nctx = ctx_drvdata->num;\r\nret = __enable_clocks(iommu_drvdata);\r\nif (ret)\r\ngoto fail;\r\nSET_CTX_TLBIALL(base, ctx, 0);\r\nSET_V2PPR(base, ctx, va & V2Pxx_VA);\r\npar = GET_PAR(base, ctx);\r\nif (GET_NOFAULT_SS(base, ctx))\r\nret = (par & 0xFF000000) | (va & 0x00FFFFFF);\r\nelse\r\nret = (par & 0xFFFFF000) | (va & 0x00000FFF);\r\nif (GET_FAULT(base, ctx))\r\nret = 0;\r\n__disable_clocks(iommu_drvdata);\r\nfail:\r\nspin_unlock_irqrestore(&msm_iommu_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int msm_iommu_domain_has_cap(struct iommu_domain *domain,\r\nunsigned long cap)\r\n{\r\nreturn 0;\r\n}\r\nstatic void print_ctx_regs(void __iomem *base, int ctx)\r\n{\r\nunsigned int fsr = GET_FSR(base, ctx);\r\npr_err("FAR = %08x PAR = %08x\n",\r\nGET_FAR(base, ctx), GET_PAR(base, ctx));\r\npr_err("FSR = %08x [%s%s%s%s%s%s%s%s%s%s]\n", fsr,\r\n(fsr & 0x02) ? "TF " : "",\r\n(fsr & 0x04) ? "AFF " : "",\r\n(fsr & 0x08) ? "APF " : "",\r\n(fsr & 0x10) ? "TLBMF " : "",\r\n(fsr & 0x20) ? "HTWDEEF " : "",\r\n(fsr & 0x40) ? "HTWSEEF " : "",\r\n(fsr & 0x80) ? "MHF " : "",\r\n(fsr & 0x10000) ? "SL " : "",\r\n(fsr & 0x40000000) ? "SS " : "",\r\n(fsr & 0x80000000) ? "MULTI " : "");\r\npr_err("FSYNR0 = %08x FSYNR1 = %08x\n",\r\nGET_FSYNR0(base, ctx), GET_FSYNR1(base, ctx));\r\npr_err("TTBR0 = %08x TTBR1 = %08x\n",\r\nGET_TTBR0(base, ctx), GET_TTBR1(base, ctx));\r\npr_err("SCTLR = %08x ACTLR = %08x\n",\r\nGET_SCTLR(base, ctx), GET_ACTLR(base, ctx));\r\npr_err("PRRR = %08x NMRR = %08x\n",\r\nGET_PRRR(base, ctx), GET_NMRR(base, ctx));\r\n}\r\nirqreturn_t msm_iommu_fault_handler(int irq, void *dev_id)\r\n{\r\nstruct msm_iommu_drvdata *drvdata = dev_id;\r\nvoid __iomem *base;\r\nunsigned int fsr;\r\nint i, ret;\r\nspin_lock(&msm_iommu_lock);\r\nif (!drvdata) {\r\npr_err("Invalid device ID in context interrupt handler\n");\r\ngoto fail;\r\n}\r\nbase = drvdata->base;\r\npr_err("Unexpected IOMMU page fault!\n");\r\npr_err("base = %08x\n", (unsigned int) base);\r\nret = __enable_clocks(drvdata);\r\nif (ret)\r\ngoto fail;\r\nfor (i = 0; i < drvdata->ncb; i++) {\r\nfsr = GET_FSR(base, i);\r\nif (fsr) {\r\npr_err("Fault occurred in context %d.\n", i);\r\npr_err("Interesting registers:\n");\r\nprint_ctx_regs(base, i);\r\nSET_FSR(base, i, 0x4000000F);\r\n}\r\n}\r\n__disable_clocks(drvdata);\r\nfail:\r\nspin_unlock(&msm_iommu_lock);\r\nreturn 0;\r\n}\r\nstatic int __init get_tex_class(int icp, int ocp, int mt, int nos)\r\n{\r\nint i = 0;\r\nunsigned int prrr = 0;\r\nunsigned int nmrr = 0;\r\nint c_icp, c_ocp, c_mt, c_nos;\r\nRCP15_PRRR(prrr);\r\nRCP15_NMRR(nmrr);\r\nfor (i = 0; i < NUM_TEX_CLASS; i++) {\r\nc_nos = PRRR_NOS(prrr, i);\r\nc_mt = PRRR_MT(prrr, i);\r\nc_icp = NMRR_ICP(nmrr, i);\r\nc_ocp = NMRR_OCP(nmrr, i);\r\nif (icp == c_icp && ocp == c_ocp && c_mt == mt && c_nos == nos)\r\nreturn i;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void __init setup_iommu_tex_classes(void)\r\n{\r\nmsm_iommu_tex_class[MSM_IOMMU_ATTR_NONCACHED] =\r\nget_tex_class(CP_NONCACHED, CP_NONCACHED, MT_NORMAL, 1);\r\nmsm_iommu_tex_class[MSM_IOMMU_ATTR_CACHED_WB_WA] =\r\nget_tex_class(CP_WB_WA, CP_WB_WA, MT_NORMAL, 1);\r\nmsm_iommu_tex_class[MSM_IOMMU_ATTR_CACHED_WB_NWA] =\r\nget_tex_class(CP_WB_NWA, CP_WB_NWA, MT_NORMAL, 1);\r\nmsm_iommu_tex_class[MSM_IOMMU_ATTR_CACHED_WT] =\r\nget_tex_class(CP_WT, CP_WT, MT_NORMAL, 1);\r\n}\r\nstatic int __init msm_iommu_init(void)\r\n{\r\nsetup_iommu_tex_classes();\r\nbus_set_iommu(&platform_bus_type, &msm_iommu_ops);\r\nreturn 0;\r\n}
