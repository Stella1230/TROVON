static int uart401_status(uart401_devc * devc)\r\n{\r\nreturn inb(STATPORT);\r\n}\r\nstatic void uart401_cmd(uart401_devc * devc, unsigned char cmd)\r\n{\r\noutb((cmd), COMDPORT);\r\n}\r\nstatic int uart401_read(uart401_devc * devc)\r\n{\r\nreturn inb(DATAPORT);\r\n}\r\nstatic void uart401_write(uart401_devc * devc, unsigned char byte)\r\n{\r\noutb((byte), DATAPORT);\r\n}\r\nstatic void uart401_input_loop(uart401_devc * devc)\r\n{\r\nint work_limit=30000;\r\nwhile (input_avail(devc) && --work_limit)\r\n{\r\nunsigned char c = uart401_read(devc);\r\nif (c == MPU_ACK)\r\ndevc->input_byte = c;\r\nelse if (devc->opened & OPEN_READ && devc->midi_input_intr)\r\ndevc->midi_input_intr(devc->my_dev, c);\r\n}\r\nif(work_limit==0)\r\nprintk(KERN_WARNING "Too much work in interrupt on uart401 (0x%X). UART jabbering ??\n", devc->base);\r\n}\r\nirqreturn_t uart401intr(int irq, void *dev_id)\r\n{\r\nuart401_devc *devc = dev_id;\r\nif (devc == NULL)\r\n{\r\nprintk(KERN_ERR "uart401: bad devc\n");\r\nreturn IRQ_NONE;\r\n}\r\nif (input_avail(devc))\r\nuart401_input_loop(devc);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\nuart401_open(int dev, int mode,\r\nvoid (*input) (int dev, unsigned char data),\r\nvoid (*output) (int dev)\r\n)\r\n{\r\nuart401_devc *devc = (uart401_devc *) midi_devs[dev]->devc;\r\nif (devc->opened)\r\nreturn -EBUSY;\r\nwhile (input_avail(devc))\r\nuart401_read(devc);\r\ndevc->midi_input_intr = input;\r\ndevc->opened = mode;\r\nenter_uart_mode(devc);\r\ndevc->disabled = 0;\r\nreturn 0;\r\n}\r\nstatic void uart401_close(int dev)\r\n{\r\nuart401_devc *devc = (uart401_devc *) midi_devs[dev]->devc;\r\nreset_uart401(devc);\r\ndevc->opened = 0;\r\n}\r\nstatic int uart401_out(int dev, unsigned char midi_byte)\r\n{\r\nint timeout;\r\nunsigned long flags;\r\nuart401_devc *devc = (uart401_devc *) midi_devs[dev]->devc;\r\nif (devc->disabled)\r\nreturn 1;\r\nspin_lock_irqsave(&devc->lock,flags);\r\nif (input_avail(devc))\r\nuart401_input_loop(devc);\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\nfor (timeout = 30000; timeout > 0 && !output_ready(devc); timeout--);\r\nif (!output_ready(devc))\r\n{\r\nprintk(KERN_WARNING "uart401: Timeout - Device not responding\n");\r\ndevc->disabled = 1;\r\nreset_uart401(devc);\r\nenter_uart_mode(devc);\r\nreturn 1;\r\n}\r\nuart401_write(devc, midi_byte);\r\nreturn 1;\r\n}\r\nstatic inline int uart401_start_read(int dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int uart401_end_read(int dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void uart401_kick(int dev)\r\n{\r\n}\r\nstatic inline int uart401_buffer_status(int dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void enter_uart_mode(uart401_devc * devc)\r\n{\r\nint ok, timeout;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devc->lock,flags);\r\nfor (timeout = 30000; timeout > 0 && !output_ready(devc); timeout--);\r\ndevc->input_byte = 0;\r\nuart401_cmd(devc, UART_MODE_ON);\r\nok = 0;\r\nfor (timeout = 50000; timeout > 0 && !ok; timeout--)\r\nif (devc->input_byte == MPU_ACK)\r\nok = 1;\r\nelse if (input_avail(devc))\r\nif (uart401_read(devc) == MPU_ACK)\r\nok = 1;\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\n}\r\nstatic int reset_uart401(uart401_devc * devc)\r\n{\r\nint ok, timeout, n;\r\nok = 0;\r\nfor (n = 0; n < 2 && !ok; n++)\r\n{\r\nfor (timeout = 30000; timeout > 0 && !output_ready(devc); timeout--);\r\ndevc->input_byte = 0;\r\nuart401_cmd(devc, MPU_RESET);\r\nfor (timeout = 50000; timeout > 0 && !ok; timeout--)\r\n{\r\nif (devc->input_byte == MPU_ACK)\r\nok = 1;\r\nelse if (input_avail(devc))\r\n{\r\nif (uart401_read(devc) == MPU_ACK)\r\nok = 1;\r\n}\r\n}\r\n}\r\nif (ok)\r\n{\r\nDEB(printk("Reset UART401 OK\n"));\r\n}\r\nelse\r\nDDB(printk("Reset UART401 failed - No hardware detected.\n"));\r\nif (ok)\r\nuart401_input_loop(devc);\r\nreturn ok;\r\n}\r\nint probe_uart401(struct address_info *hw_config, struct module *owner)\r\n{\r\nuart401_devc *devc;\r\nchar *name = "MPU-401 (UART) MIDI";\r\nint ok = 0;\r\nunsigned long flags;\r\nDDB(printk("Entered probe_uart401()\n"));\r\nhw_config->slots[4] = -1;\r\nif (!request_region(hw_config->io_base, 4, "MPU-401 UART")) {\r\nprintk(KERN_INFO "uart401: could not request_region(%d, 4)\n", hw_config->io_base);\r\nreturn 0;\r\n}\r\ndevc = kmalloc(sizeof(uart401_devc), GFP_KERNEL);\r\nif (!devc) {\r\nprintk(KERN_WARNING "uart401: Can't allocate memory\n");\r\ngoto cleanup_region;\r\n}\r\ndevc->base = hw_config->io_base;\r\ndevc->irq = hw_config->irq;\r\ndevc->osp = hw_config->osp;\r\ndevc->midi_input_intr = NULL;\r\ndevc->opened = 0;\r\ndevc->input_byte = 0;\r\ndevc->my_dev = 0;\r\ndevc->share_irq = 0;\r\nspin_lock_init(&devc->lock);\r\nspin_lock_irqsave(&devc->lock,flags);\r\nok = reset_uart401(devc);\r\nspin_unlock_irqrestore(&devc->lock,flags);\r\nif (!ok)\r\ngoto cleanup_devc;\r\nif (hw_config->name)\r\nname = hw_config->name;\r\nif (devc->irq < 0) {\r\ndevc->share_irq = 1;\r\ndevc->irq *= -1;\r\n} else\r\ndevc->share_irq = 0;\r\nif (!devc->share_irq)\r\nif (request_irq(devc->irq, uart401intr, 0, "MPU-401 UART", devc) < 0) {\r\nprintk(KERN_WARNING "uart401: Failed to allocate IRQ%d\n", devc->irq);\r\ndevc->share_irq = 1;\r\n}\r\ndevc->my_dev = sound_alloc_mididev();\r\nenter_uart_mode(devc);\r\nif (devc->my_dev == -1) {\r\nprintk(KERN_INFO "uart401: Too many midi devices detected\n");\r\ngoto cleanup_irq;\r\n}\r\nconf_printf(name, hw_config);\r\nmidi_devs[devc->my_dev] = kmalloc(sizeof(struct midi_operations), GFP_KERNEL);\r\nif (!midi_devs[devc->my_dev]) {\r\nprintk(KERN_ERR "uart401: Failed to allocate memory\n");\r\ngoto cleanup_unload_mididev;\r\n}\r\nmemcpy(midi_devs[devc->my_dev], &uart401_operations, sizeof(struct midi_operations));\r\nif (owner)\r\nmidi_devs[devc->my_dev]->owner = owner;\r\nmidi_devs[devc->my_dev]->devc = devc;\r\nmidi_devs[devc->my_dev]->converter = kmalloc(sizeof(struct synth_operations), GFP_KERNEL);\r\nif (!midi_devs[devc->my_dev]->converter) {\r\nprintk(KERN_WARNING "uart401: Failed to allocate memory\n");\r\ngoto cleanup_midi_devs;\r\n}\r\nmemcpy(midi_devs[devc->my_dev]->converter, &std_midi_synth, sizeof(struct synth_operations));\r\nstrcpy(midi_devs[devc->my_dev]->info.name, name);\r\nmidi_devs[devc->my_dev]->converter->id = "UART401";\r\nmidi_devs[devc->my_dev]->converter->midi_dev = devc->my_dev;\r\nif (owner)\r\nmidi_devs[devc->my_dev]->converter->owner = owner;\r\nhw_config->slots[4] = devc->my_dev;\r\nsequencer_init();\r\ndevc->opened = 0;\r\nreturn 1;\r\ncleanup_midi_devs:\r\nkfree(midi_devs[devc->my_dev]);\r\ncleanup_unload_mididev:\r\nsound_unload_mididev(devc->my_dev);\r\ncleanup_irq:\r\nif (!devc->share_irq)\r\nfree_irq(devc->irq, devc);\r\ncleanup_devc:\r\nkfree(devc);\r\ncleanup_region:\r\nrelease_region(hw_config->io_base, 4);\r\nreturn 0;\r\n}\r\nvoid unload_uart401(struct address_info *hw_config)\r\n{\r\nuart401_devc *devc;\r\nint n=hw_config->slots[4];\r\nif(n==-1 || midi_devs[n]==NULL)\r\nreturn;\r\ndevc = midi_devs[hw_config->slots[4]]->devc;\r\nif (devc == NULL)\r\nreturn;\r\nreset_uart401(devc);\r\nrelease_region(hw_config->io_base, 4);\r\nif (!devc->share_irq)\r\nfree_irq(devc->irq, devc);\r\nif (devc)\r\n{\r\nkfree(midi_devs[devc->my_dev]->converter);\r\nkfree(midi_devs[devc->my_dev]);\r\nkfree(devc);\r\ndevc = NULL;\r\n}\r\nsound_unload_mididev(hw_config->slots[4]);\r\n}\r\nstatic int __init init_uart401(void)\r\n{\r\ncfg_mpu.irq = irq;\r\ncfg_mpu.io_base = io;\r\nif (cfg_mpu.io_base != -1 && cfg_mpu.irq != -1) {\r\nprintk(KERN_INFO "MPU-401 UART driver Copyright (C) Hannu Savolainen 1993-1997");\r\nif (!probe_uart401(&cfg_mpu, THIS_MODULE))\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_uart401(void)\r\n{\r\nif (cfg_mpu.io_base != -1 && cfg_mpu.irq != -1)\r\nunload_uart401(&cfg_mpu);\r\n}\r\nstatic int __init setup_uart401(char *str)\r\n{\r\nint ints[3];\r\nstr = get_options(str, ARRAY_SIZE(ints), ints);\r\nio = ints[1];\r\nirq = ints[2];\r\nreturn 1;\r\n}
