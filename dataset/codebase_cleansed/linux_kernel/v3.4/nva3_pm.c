static u32\r\nread_vco(struct drm_device *dev, int clk)\r\n{\r\nu32 sctl = nv_rd32(dev, 0x4120 + (clk * 4));\r\nif ((sctl & 0x00000030) != 0x00000030)\r\nreturn read_pll(dev, 0x41, 0x00e820);\r\nreturn read_pll(dev, 0x42, 0x00e8a0);\r\n}\r\nstatic u32\r\nread_clk(struct drm_device *dev, int clk, bool ignore_en)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nu32 sctl, sdiv, sclk;\r\nif (clk >= 0x40) {\r\nif (dev_priv->chipset == 0xaf) {\r\nreturn nv_rd32(dev, 0x00471c) * 1000;\r\n}\r\nreturn dev_priv->crystal;\r\n}\r\nsctl = nv_rd32(dev, 0x4120 + (clk * 4));\r\nif (!ignore_en && !(sctl & 0x00000100))\r\nreturn 0;\r\nswitch (sctl & 0x00003000) {\r\ncase 0x00000000:\r\nreturn dev_priv->crystal;\r\ncase 0x00002000:\r\nif (sctl & 0x00000040)\r\nreturn 108000;\r\nreturn 100000;\r\ncase 0x00003000:\r\nsclk = read_vco(dev, clk);\r\nsdiv = ((sctl & 0x003f0000) >> 16) + 2;\r\nreturn (sclk * 2) / sdiv;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic u32\r\nread_pll(struct drm_device *dev, int clk, u32 pll)\r\n{\r\nu32 ctrl = nv_rd32(dev, pll + 0);\r\nu32 sclk = 0, P = 1, N = 1, M = 1;\r\nif (!(ctrl & 0x00000008)) {\r\nif (ctrl & 0x00000001) {\r\nu32 coef = nv_rd32(dev, pll + 4);\r\nM = (coef & 0x000000ff) >> 0;\r\nN = (coef & 0x0000ff00) >> 8;\r\nP = (coef & 0x003f0000) >> 16;\r\nif ((pll & 0x00ff00) == 0x00e800)\r\nP = 1;\r\nsclk = read_clk(dev, 0x00 + clk, false);\r\n}\r\n} else {\r\nsclk = read_clk(dev, 0x10 + clk, false);\r\n}\r\nreturn sclk * N / (M * P);\r\n}\r\nstatic int\r\ncalc_clk(struct drm_device *dev, int clk, u32 pll, u32 khz, struct creg *reg)\r\n{\r\nstruct pll_lims limits;\r\nu32 oclk, sclk, sdiv;\r\nint P, N, M, diff;\r\nint ret;\r\nreg->pll = 0;\r\nreg->clk = 0;\r\nif (!khz) {\r\nNV_DEBUG(dev, "no clock for 0x%04x/0x%02x\n", pll, clk);\r\nreturn 0;\r\n}\r\nswitch (khz) {\r\ncase 27000:\r\nreg->clk = 0x00000100;\r\nreturn khz;\r\ncase 100000:\r\nreg->clk = 0x00002100;\r\nreturn khz;\r\ncase 108000:\r\nreg->clk = 0x00002140;\r\nreturn khz;\r\ndefault:\r\nsclk = read_vco(dev, clk);\r\nsdiv = min((sclk * 2) / (khz - 2999), (u32)65);\r\nif (sdiv > 4) {\r\noclk = (sclk * 2) / sdiv;\r\ndiff = khz - oclk;\r\nif (!pll || (diff >= -2000 && diff < 3000)) {\r\nreg->clk = (((sdiv - 2) << 16) | 0x00003100);\r\nreturn oclk;\r\n}\r\n}\r\nif (!pll) {\r\nNV_ERROR(dev, "bad freq %02x: %d %d\n", clk, khz, sclk);\r\nreturn -ERANGE;\r\n}\r\nbreak;\r\n}\r\nret = get_pll_limits(dev, pll, &limits);\r\nif (ret)\r\nreturn ret;\r\nlimits.refclk = read_clk(dev, clk - 0x10, true);\r\nif (!limits.refclk)\r\nreturn -EINVAL;\r\nret = nva3_calc_pll(dev, &limits, khz, &N, NULL, &M, &P);\r\nif (ret >= 0) {\r\nreg->clk = nv_rd32(dev, 0x4120 + (clk * 4));\r\nreg->pll = (P << 16) | (N << 8) | M;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nprog_pll(struct drm_device *dev, int clk, u32 pll, struct creg *reg)\r\n{\r\nconst u32 src0 = 0x004120 + (clk * 4);\r\nconst u32 src1 = 0x004160 + (clk * 4);\r\nconst u32 ctrl = pll + 0;\r\nconst u32 coef = pll + 4;\r\nu32 cntl;\r\nif (!reg->clk && !reg->pll) {\r\nNV_DEBUG(dev, "no clock for %02x\n", clk);\r\nreturn;\r\n}\r\ncntl = nv_rd32(dev, ctrl) & 0xfffffff2;\r\nif (reg->pll) {\r\nnv_mask(dev, src0, 0x00000101, 0x00000101);\r\nnv_wr32(dev, coef, reg->pll);\r\nnv_wr32(dev, ctrl, cntl | 0x00000015);\r\nnv_mask(dev, src1, 0x00000100, 0x00000000);\r\nnv_mask(dev, src1, 0x00000001, 0x00000000);\r\n} else {\r\nnv_mask(dev, src1, 0x003f3141, 0x00000101 | reg->clk);\r\nnv_wr32(dev, ctrl, cntl | 0x0000001d);\r\nnv_mask(dev, ctrl, 0x00000001, 0x00000000);\r\nnv_mask(dev, src0, 0x00000100, 0x00000000);\r\nnv_mask(dev, src0, 0x00000001, 0x00000000);\r\n}\r\n}\r\nstatic void\r\nprog_clk(struct drm_device *dev, int clk, struct creg *reg)\r\n{\r\nif (!reg->clk) {\r\nNV_DEBUG(dev, "no clock for %02x\n", clk);\r\nreturn;\r\n}\r\nnv_mask(dev, 0x004120 + (clk * 4), 0x003f3141, 0x00000101 | reg->clk);\r\n}\r\nint\r\nnva3_pm_clocks_get(struct drm_device *dev, struct nouveau_pm_level *perflvl)\r\n{\r\nperflvl->core = read_pll(dev, 0x00, 0x4200);\r\nperflvl->shader = read_pll(dev, 0x01, 0x4220);\r\nperflvl->memory = read_pll(dev, 0x02, 0x4000);\r\nperflvl->unka0 = read_clk(dev, 0x20, false);\r\nperflvl->vdec = read_clk(dev, 0x21, false);\r\nperflvl->daemon = read_clk(dev, 0x25, false);\r\nperflvl->copy = perflvl->core;\r\nreturn 0;\r\n}\r\nvoid *\r\nnva3_pm_clocks_pre(struct drm_device *dev, struct nouveau_pm_level *perflvl)\r\n{\r\nstruct nva3_pm_state *info;\r\nint ret;\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = calc_clk(dev, 0x10, 0x4200, perflvl->core, &info->nclk);\r\nif (ret < 0)\r\ngoto out;\r\nret = calc_clk(dev, 0x11, 0x4220, perflvl->shader, &info->sclk);\r\nif (ret < 0)\r\ngoto out;\r\nret = calc_clk(dev, 0x12, 0x4000, perflvl->memory, &info->mclk);\r\nif (ret < 0)\r\ngoto out;\r\nret = calc_clk(dev, 0x20, 0x0000, perflvl->unka0, &info->unka0);\r\nif (ret < 0)\r\ngoto out;\r\nret = calc_clk(dev, 0x21, 0x0000, perflvl->vdec, &info->vdec);\r\nif (ret < 0)\r\ngoto out;\r\nout:\r\nif (ret < 0) {\r\nkfree(info);\r\ninfo = ERR_PTR(ret);\r\n}\r\nreturn info;\r\n}\r\nstatic bool\r\nnva3_pm_grcp_idle(void *data)\r\n{\r\nstruct drm_device *dev = data;\r\nif (!(nv_rd32(dev, 0x400304) & 0x00000001))\r\nreturn true;\r\nif (nv_rd32(dev, 0x400308) == 0x0050001c)\r\nreturn true;\r\nreturn false;\r\n}\r\nint\r\nnva3_pm_clocks_set(struct drm_device *dev, void *pre_state)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nva3_pm_state *info = pre_state;\r\nunsigned long flags;\r\nint ret = -EAGAIN;\r\nspin_lock_irqsave(&dev_priv->context_switch_lock, flags);\r\nnv_wr32(dev, 0x400324, 0x00000000);\r\nnv_wr32(dev, 0x400328, 0x0050001c);\r\nif (!nv_wait_cb(dev, nva3_pm_grcp_idle, dev)) {\r\nNV_ERROR(dev, "pm: ctxprog didn't go idle\n");\r\ngoto cleanup;\r\n}\r\nnv_mask(dev, 0x002504, 0x00000001, 0x00000001);\r\nif (!nv_wait(dev, 0x002504, 0x00000010, 0x00000010)) {\r\nNV_ERROR(dev, "pm: fifo didn't go idle\n");\r\ngoto cleanup;\r\n}\r\nprog_pll(dev, 0x00, 0x004200, &info->nclk);\r\nprog_pll(dev, 0x01, 0x004220, &info->sclk);\r\nprog_clk(dev, 0x20, &info->unka0);\r\nprog_clk(dev, 0x21, &info->vdec);\r\nif (info->mclk.clk || info->mclk.pll) {\r\nnv_wr32(dev, 0x100210, 0);\r\nnv_wr32(dev, 0x1002dc, 1);\r\nnv_wr32(dev, 0x004018, 0x00001000);\r\nprog_pll(dev, 0x02, 0x004000, &info->mclk);\r\nif (nv_rd32(dev, 0x4000) & 0x00000008)\r\nnv_wr32(dev, 0x004018, 0x1000d000);\r\nelse\r\nnv_wr32(dev, 0x004018, 0x10005000);\r\nnv_wr32(dev, 0x1002dc, 0);\r\nnv_wr32(dev, 0x100210, 0x80000000);\r\n}\r\nret = 0;\r\ncleanup:\r\nnv_mask(dev, 0x002504, 0x00000001, 0x00000000);\r\nnv_wr32(dev, 0x400324, 0x00000000);\r\nnv_wr32(dev, 0x400328, 0x0070009c);\r\nif (nv_rd32(dev, 0x400308) == 0x0050001c)\r\nnv_mask(dev, 0x400824, 0x10000000, 0x10000000);\r\nspin_unlock_irqrestore(&dev_priv->context_switch_lock, flags);\r\nkfree(info);\r\nreturn ret;\r\n}
