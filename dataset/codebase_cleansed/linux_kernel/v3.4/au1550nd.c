static u_char au_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nu_char ret = readb(this->IO_ADDR_R);\r\nau_sync();\r\nreturn ret;\r\n}\r\nstatic void au_write_byte(struct mtd_info *mtd, u_char byte)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nwriteb(byte, this->IO_ADDR_W);\r\nau_sync();\r\n}\r\nstatic u_char au_read_byte16(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nu_char ret = (u_char) cpu_to_le16(readw(this->IO_ADDR_R));\r\nau_sync();\r\nreturn ret;\r\n}\r\nstatic void au_write_byte16(struct mtd_info *mtd, u_char byte)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nwritew(le16_to_cpu((u16) byte), this->IO_ADDR_W);\r\nau_sync();\r\n}\r\nstatic u16 au_read_word(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nu16 ret = readw(this->IO_ADDR_R);\r\nau_sync();\r\nreturn ret;\r\n}\r\nstatic void au_write_buf(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *this = mtd->priv;\r\nfor (i = 0; i < len; i++) {\r\nwriteb(buf[i], this->IO_ADDR_W);\r\nau_sync();\r\n}\r\n}\r\nstatic void au_read_buf(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *this = mtd->priv;\r\nfor (i = 0; i < len; i++) {\r\nbuf[i] = readb(this->IO_ADDR_R);\r\nau_sync();\r\n}\r\n}\r\nstatic int au_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *this = mtd->priv;\r\nfor (i = 0; i < len; i++) {\r\nif (buf[i] != readb(this->IO_ADDR_R))\r\nreturn -EFAULT;\r\nau_sync();\r\n}\r\nreturn 0;\r\n}\r\nstatic void au_write_buf16(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *this = mtd->priv;\r\nu16 *p = (u16 *) buf;\r\nlen >>= 1;\r\nfor (i = 0; i < len; i++) {\r\nwritew(p[i], this->IO_ADDR_W);\r\nau_sync();\r\n}\r\n}\r\nstatic void au_read_buf16(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *this = mtd->priv;\r\nu16 *p = (u16 *) buf;\r\nlen >>= 1;\r\nfor (i = 0; i < len; i++) {\r\np[i] = readw(this->IO_ADDR_R);\r\nau_sync();\r\n}\r\n}\r\nstatic int au_verify_buf16(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nint i;\r\nstruct nand_chip *this = mtd->priv;\r\nu16 *p = (u16 *) buf;\r\nlen >>= 1;\r\nfor (i = 0; i < len; i++) {\r\nif (p[i] != readw(this->IO_ADDR_R))\r\nreturn -EFAULT;\r\nau_sync();\r\n}\r\nreturn 0;\r\n}\r\nstatic void au1550_hwcontrol(struct mtd_info *mtd, int cmd)\r\n{\r\nstruct au1550nd_ctx *ctx = container_of(mtd, struct au1550nd_ctx, info);\r\nstruct nand_chip *this = mtd->priv;\r\nswitch (cmd) {\r\ncase NAND_CTL_SETCLE:\r\nthis->IO_ADDR_W = ctx->base + MEM_STNAND_CMD;\r\nbreak;\r\ncase NAND_CTL_CLRCLE:\r\nthis->IO_ADDR_W = ctx->base + MEM_STNAND_DATA;\r\nbreak;\r\ncase NAND_CTL_SETALE:\r\nthis->IO_ADDR_W = ctx->base + MEM_STNAND_ADDR;\r\nbreak;\r\ncase NAND_CTL_CLRALE:\r\nthis->IO_ADDR_W = ctx->base + MEM_STNAND_DATA;\r\nudelay(1);\r\nbreak;\r\ncase NAND_CTL_SETNCE:\r\nau_writel((1 << (4 + ctx->cs)), MEM_STNDCTL);\r\nbreak;\r\ncase NAND_CTL_CLRNCE:\r\nau_writel(0, MEM_STNDCTL);\r\nbreak;\r\n}\r\nthis->IO_ADDR_R = this->IO_ADDR_W;\r\nau_sync();\r\n}\r\nint au1550_device_ready(struct mtd_info *mtd)\r\n{\r\nint ret = (au_readl(MEM_STSTAT) & 0x1) ? 1 : 0;\r\nau_sync();\r\nreturn ret;\r\n}\r\nstatic void au1550_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\n}\r\nstatic void au1550_command(struct mtd_info *mtd, unsigned command, int column, int page_addr)\r\n{\r\nstruct au1550nd_ctx *ctx = container_of(mtd, struct au1550nd_ctx, info);\r\nstruct nand_chip *this = mtd->priv;\r\nint ce_override = 0, i;\r\nunsigned long flags = 0;\r\nau1550_hwcontrol(mtd, NAND_CTL_SETCLE);\r\nif (command == NAND_CMD_SEQIN) {\r\nint readcmd;\r\nif (column >= mtd->writesize) {\r\ncolumn -= mtd->writesize;\r\nreadcmd = NAND_CMD_READOOB;\r\n} else if (column < 256) {\r\nreadcmd = NAND_CMD_READ0;\r\n} else {\r\ncolumn -= 256;\r\nreadcmd = NAND_CMD_READ1;\r\n}\r\nctx->write_byte(mtd, readcmd);\r\n}\r\nctx->write_byte(mtd, command);\r\nau1550_hwcontrol(mtd, NAND_CTL_CLRCLE);\r\nif (column != -1 || page_addr != -1) {\r\nau1550_hwcontrol(mtd, NAND_CTL_SETALE);\r\nif (column != -1) {\r\nif (this->options & NAND_BUSWIDTH_16)\r\ncolumn >>= 1;\r\nctx->write_byte(mtd, column);\r\n}\r\nif (page_addr != -1) {\r\nctx->write_byte(mtd, (u8)(page_addr & 0xff));\r\nif (command == NAND_CMD_READ0 ||\r\ncommand == NAND_CMD_READ1 ||\r\ncommand == NAND_CMD_READOOB) {\r\nce_override = 1;\r\nlocal_irq_save(flags);\r\nau1550_hwcontrol(mtd, NAND_CTL_SETNCE);\r\n}\r\nctx->write_byte(mtd, (u8)(page_addr >> 8));\r\nif (this->chipsize > (32 << 20))\r\nctx->write_byte(mtd,\r\n((page_addr >> 16) & 0x0f));\r\n}\r\nau1550_hwcontrol(mtd, NAND_CTL_CLRALE);\r\n}\r\nswitch (command) {\r\ncase NAND_CMD_PAGEPROG:\r\ncase NAND_CMD_ERASE1:\r\ncase NAND_CMD_ERASE2:\r\ncase NAND_CMD_SEQIN:\r\ncase NAND_CMD_STATUS:\r\nreturn;\r\ncase NAND_CMD_RESET:\r\nbreak;\r\ncase NAND_CMD_READ0:\r\ncase NAND_CMD_READ1:\r\ncase NAND_CMD_READOOB:\r\nif (unlikely(!ce_override))\r\nbreak;\r\nndelay(100);\r\nfor (i = this->chip_delay; !this->dev_ready(mtd) && i > 0; --i)\r\nudelay(1);\r\nau1550_hwcontrol(mtd, NAND_CTL_CLRNCE);\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\nndelay(100);\r\nwhile(!this->dev_ready(mtd));\r\n}\r\nstatic int __devinit find_nand_cs(unsigned long nand_base)\r\n{\r\nvoid __iomem *base =\r\n(void __iomem *)KSEG1ADDR(AU1000_STATIC_MEM_PHYS_ADDR);\r\nunsigned long addr, staddr, start, mask, end;\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\naddr = 0x1000 + (i * 0x10);\r\nstaddr = __raw_readl(base + addr + 0x08);\r\nstart = (staddr << 4) & 0xfffc0000;\r\nmask = (staddr << 18) & 0xfffc0000;\r\nend = (start | (start - 1)) & ~(start ^ mask);\r\nif ((nand_base >= start) && (nand_base < end))\r\nreturn i;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int __devinit au1550nd_probe(struct platform_device *pdev)\r\n{\r\nstruct au1550nd_platdata *pd;\r\nstruct au1550nd_ctx *ctx;\r\nstruct nand_chip *this;\r\nstruct resource *r;\r\nint ret, cs;\r\npd = pdev->dev.platform_data;\r\nif (!pd) {\r\ndev_err(&pdev->dev, "missing platform data\n");\r\nreturn -ENODEV;\r\n}\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx) {\r\ndev_err(&pdev->dev, "no memory for NAND context\n");\r\nreturn -ENOMEM;\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\ndev_err(&pdev->dev, "no NAND memory resource\n");\r\nret = -ENODEV;\r\ngoto out1;\r\n}\r\nif (request_mem_region(r->start, resource_size(r), "au1550-nand")) {\r\ndev_err(&pdev->dev, "cannot claim NAND memory area\n");\r\nret = -ENOMEM;\r\ngoto out1;\r\n}\r\nctx->base = ioremap_nocache(r->start, 0x1000);\r\nif (!ctx->base) {\r\ndev_err(&pdev->dev, "cannot remap NAND memory area\n");\r\nret = -ENODEV;\r\ngoto out2;\r\n}\r\nthis = &ctx->chip;\r\nctx->info.priv = this;\r\nctx->info.owner = THIS_MODULE;\r\ncs = find_nand_cs(r->start);\r\nif (cs < 0) {\r\ndev_err(&pdev->dev, "cannot detect NAND chipselect\n");\r\nret = -ENODEV;\r\ngoto out3;\r\n}\r\nctx->cs = cs;\r\nthis->dev_ready = au1550_device_ready;\r\nthis->select_chip = au1550_select_chip;\r\nthis->cmdfunc = au1550_command;\r\nthis->chip_delay = 30;\r\nthis->ecc.mode = NAND_ECC_SOFT;\r\nthis->options = NAND_NO_AUTOINCR;\r\nif (pd->devwidth)\r\nthis->options |= NAND_BUSWIDTH_16;\r\nthis->read_byte = (pd->devwidth) ? au_read_byte16 : au_read_byte;\r\nctx->write_byte = (pd->devwidth) ? au_write_byte16 : au_write_byte;\r\nthis->read_word = au_read_word;\r\nthis->write_buf = (pd->devwidth) ? au_write_buf16 : au_write_buf;\r\nthis->read_buf = (pd->devwidth) ? au_read_buf16 : au_read_buf;\r\nthis->verify_buf = (pd->devwidth) ? au_verify_buf16 : au_verify_buf;\r\nret = nand_scan(&ctx->info, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "NAND scan failed with %d\n", ret);\r\ngoto out3;\r\n}\r\nmtd_device_register(&ctx->info, pd->parts, pd->num_parts);\r\nreturn 0;\r\nout3:\r\niounmap(ctx->base);\r\nout2:\r\nrelease_mem_region(r->start, resource_size(r));\r\nout1:\r\nkfree(ctx);\r\nreturn ret;\r\n}\r\nstatic int __devexit au1550nd_remove(struct platform_device *pdev)\r\n{\r\nstruct au1550nd_ctx *ctx = platform_get_drvdata(pdev);\r\nstruct resource *r = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nnand_release(&ctx->info);\r\niounmap(ctx->base);\r\nrelease_mem_region(r->start, 0x1000);\r\nkfree(ctx);\r\nreturn 0;\r\n}
