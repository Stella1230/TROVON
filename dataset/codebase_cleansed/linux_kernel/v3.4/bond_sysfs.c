static ssize_t bonding_show_bonds(struct class *cls,\r\nstruct class_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bond_net *bn =\r\ncontainer_of(attr, struct bond_net, class_attr_bonding_masters);\r\nint res = 0;\r\nstruct bonding *bond;\r\nrtnl_lock();\r\nlist_for_each_entry(bond, &bn->dev_list, bond_list) {\r\nif (res > (PAGE_SIZE - IFNAMSIZ)) {\r\nif ((PAGE_SIZE - res) > 10)\r\nres = PAGE_SIZE - 10;\r\nres += sprintf(buf + res, "++more++ ");\r\nbreak;\r\n}\r\nres += sprintf(buf + res, "%s ", bond->dev->name);\r\n}\r\nif (res)\r\nbuf[res-1] = '\n';\r\nrtnl_unlock();\r\nreturn res;\r\n}\r\nstatic struct net_device *bond_get_by_name(struct bond_net *bn, const char *ifname)\r\n{\r\nstruct bonding *bond;\r\nlist_for_each_entry(bond, &bn->dev_list, bond_list) {\r\nif (strncmp(bond->dev->name, ifname, IFNAMSIZ) == 0)\r\nreturn bond->dev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic ssize_t bonding_store_bonds(struct class *cls,\r\nstruct class_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nstruct bond_net *bn =\r\ncontainer_of(attr, struct bond_net, class_attr_bonding_masters);\r\nchar command[IFNAMSIZ + 1] = {0, };\r\nchar *ifname;\r\nint rv, res = count;\r\nsscanf(buffer, "%16s", command);\r\nifname = command + 1;\r\nif ((strlen(command) <= 1) ||\r\n!dev_valid_name(ifname))\r\ngoto err_no_cmd;\r\nif (command[0] == '+') {\r\npr_info("%s is being created...\n", ifname);\r\nrv = bond_create(bn->net, ifname);\r\nif (rv) {\r\nif (rv == -EEXIST)\r\npr_info("%s already exists.\n", ifname);\r\nelse\r\npr_info("%s creation failed.\n", ifname);\r\nres = rv;\r\n}\r\n} else if (command[0] == '-') {\r\nstruct net_device *bond_dev;\r\nrtnl_lock();\r\nbond_dev = bond_get_by_name(bn, ifname);\r\nif (bond_dev) {\r\npr_info("%s is being deleted...\n", ifname);\r\nunregister_netdevice(bond_dev);\r\n} else {\r\npr_err("unable to delete non-existent %s\n", ifname);\r\nres = -ENODEV;\r\n}\r\nrtnl_unlock();\r\n} else\r\ngoto err_no_cmd;\r\nreturn res;\r\nerr_no_cmd:\r\npr_err("no command found in bonding_masters. Use +ifname or -ifname.\n");\r\nreturn -EPERM;\r\n}\r\nstatic const void *bonding_namespace(struct class *cls,\r\nconst struct class_attribute *attr)\r\n{\r\nconst struct bond_net *bn =\r\ncontainer_of(attr, struct bond_net, class_attr_bonding_masters);\r\nreturn bn->net;\r\n}\r\nint bond_create_slave_symlinks(struct net_device *master,\r\nstruct net_device *slave)\r\n{\r\nchar linkname[IFNAMSIZ+7];\r\nint ret = 0;\r\nret = sysfs_create_link(&(slave->dev.kobj), &(master->dev.kobj),\r\n"master");\r\nif (ret)\r\nreturn ret;\r\nsprintf(linkname, "slave_%s", slave->name);\r\nret = sysfs_create_link(&(master->dev.kobj), &(slave->dev.kobj),\r\nlinkname);\r\nreturn ret;\r\n}\r\nvoid bond_destroy_slave_symlinks(struct net_device *master,\r\nstruct net_device *slave)\r\n{\r\nchar linkname[IFNAMSIZ+7];\r\nsysfs_remove_link(&(slave->dev.kobj), "master");\r\nsprintf(linkname, "slave_%s", slave->name);\r\nsysfs_remove_link(&(master->dev.kobj), linkname);\r\n}\r\nstatic ssize_t bonding_show_slaves(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct slave *slave;\r\nint i, res = 0;\r\nstruct bonding *bond = to_bond(d);\r\nread_lock(&bond->lock);\r\nbond_for_each_slave(bond, slave, i) {\r\nif (res > (PAGE_SIZE - IFNAMSIZ)) {\r\nif ((PAGE_SIZE - res) > 10)\r\nres = PAGE_SIZE - 10;\r\nres += sprintf(buf + res, "++more++ ");\r\nbreak;\r\n}\r\nres += sprintf(buf + res, "%s ", slave->dev->name);\r\n}\r\nread_unlock(&bond->lock);\r\nif (res)\r\nbuf[res-1] = '\n';\r\nreturn res;\r\n}\r\nstatic ssize_t bonding_store_slaves(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nchar command[IFNAMSIZ + 1] = { 0, };\r\nchar *ifname;\r\nint res, ret = count;\r\nstruct net_device *dev;\r\nstruct bonding *bond = to_bond(d);\r\nif (!rtnl_trylock())\r\nreturn restart_syscall();\r\nsscanf(buffer, "%16s", command);\r\nifname = command + 1;\r\nif ((strlen(command) <= 1) ||\r\n!dev_valid_name(ifname))\r\ngoto err_no_cmd;\r\ndev = __dev_get_by_name(dev_net(bond->dev), ifname);\r\nif (!dev) {\r\npr_info("%s: Interface %s does not exist!\n",\r\nbond->dev->name, ifname);\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nswitch (command[0]) {\r\ncase '+':\r\npr_info("%s: Adding slave %s.\n", bond->dev->name, dev->name);\r\nres = bond_enslave(bond->dev, dev);\r\nbreak;\r\ncase '-':\r\npr_info("%s: Removing slave %s.\n", bond->dev->name, dev->name);\r\nres = bond_release(bond->dev, dev);\r\nbreak;\r\ndefault:\r\ngoto err_no_cmd;\r\n}\r\nif (res)\r\nret = res;\r\ngoto out;\r\nerr_no_cmd:\r\npr_err("no command found in slaves file for bond %s. Use +ifname or -ifname.\n",\r\nbond->dev->name);\r\nret = -EPERM;\r\nout:\r\nrtnl_unlock();\r\nreturn ret;\r\n}\r\nstatic ssize_t bonding_show_mode(struct device *d,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%s %d\n",\r\nbond_mode_tbl[bond->params.mode].modename,\r\nbond->params.mode);\r\n}\r\nstatic ssize_t bonding_store_mode(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint new_value, ret = count;\r\nstruct bonding *bond = to_bond(d);\r\nif (bond->dev->flags & IFF_UP) {\r\npr_err("unable to update mode of %s because interface is up.\n",\r\nbond->dev->name);\r\nret = -EPERM;\r\ngoto out;\r\n}\r\nif (bond->slave_cnt > 0) {\r\npr_err("unable to update mode of %s because it has slaves.\n",\r\nbond->dev->name);\r\nret = -EPERM;\r\ngoto out;\r\n}\r\nnew_value = bond_parse_parm(buf, bond_mode_tbl);\r\nif (new_value < 0) {\r\npr_err("%s: Ignoring invalid mode value %.*s.\n",\r\nbond->dev->name, (int)strlen(buf) - 1, buf);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif ((new_value == BOND_MODE_ALB ||\r\nnew_value == BOND_MODE_TLB) &&\r\nbond->params.arp_interval) {\r\npr_err("%s: %s mode is incompatible with arp monitoring.\n",\r\nbond->dev->name, bond_mode_tbl[new_value].modename);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nbond->params.mode = new_value;\r\nbond_set_mode_ops(bond, bond->params.mode);\r\npr_info("%s: setting mode to %s (%d).\n",\r\nbond->dev->name, bond_mode_tbl[new_value].modename,\r\nnew_value);\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t bonding_show_xmit_hash(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%s %d\n",\r\nxmit_hashtype_tbl[bond->params.xmit_policy].modename,\r\nbond->params.xmit_policy);\r\n}\r\nstatic ssize_t bonding_store_xmit_hash(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint new_value, ret = count;\r\nstruct bonding *bond = to_bond(d);\r\nif (bond->dev->flags & IFF_UP) {\r\npr_err("%s: Interface is up. Unable to update xmit policy.\n",\r\nbond->dev->name);\r\nret = -EPERM;\r\ngoto out;\r\n}\r\nnew_value = bond_parse_parm(buf, xmit_hashtype_tbl);\r\nif (new_value < 0) {\r\npr_err("%s: Ignoring invalid xmit hash policy value %.*s.\n",\r\nbond->dev->name,\r\n(int)strlen(buf) - 1, buf);\r\nret = -EINVAL;\r\ngoto out;\r\n} else {\r\nbond->params.xmit_policy = new_value;\r\nbond_set_mode_ops(bond, bond->params.mode);\r\npr_info("%s: setting xmit hash policy to %s (%d).\n",\r\nbond->dev->name,\r\nxmit_hashtype_tbl[new_value].modename, new_value);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t bonding_show_arp_validate(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%s %d\n",\r\narp_validate_tbl[bond->params.arp_validate].modename,\r\nbond->params.arp_validate);\r\n}\r\nstatic ssize_t bonding_store_arp_validate(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint new_value;\r\nstruct bonding *bond = to_bond(d);\r\nnew_value = bond_parse_parm(buf, arp_validate_tbl);\r\nif (new_value < 0) {\r\npr_err("%s: Ignoring invalid arp_validate value %s\n",\r\nbond->dev->name, buf);\r\nreturn -EINVAL;\r\n}\r\nif (new_value && (bond->params.mode != BOND_MODE_ACTIVEBACKUP)) {\r\npr_err("%s: arp_validate only supported in active-backup mode.\n",\r\nbond->dev->name);\r\nreturn -EINVAL;\r\n}\r\npr_info("%s: setting arp_validate to %s (%d).\n",\r\nbond->dev->name, arp_validate_tbl[new_value].modename,\r\nnew_value);\r\nbond->params.arp_validate = new_value;\r\nreturn count;\r\n}\r\nstatic ssize_t bonding_show_fail_over_mac(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%s %d\n",\r\nfail_over_mac_tbl[bond->params.fail_over_mac].modename,\r\nbond->params.fail_over_mac);\r\n}\r\nstatic ssize_t bonding_store_fail_over_mac(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint new_value;\r\nstruct bonding *bond = to_bond(d);\r\nif (bond->slave_cnt != 0) {\r\npr_err("%s: Can't alter fail_over_mac with slaves in bond.\n",\r\nbond->dev->name);\r\nreturn -EPERM;\r\n}\r\nnew_value = bond_parse_parm(buf, fail_over_mac_tbl);\r\nif (new_value < 0) {\r\npr_err("%s: Ignoring invalid fail_over_mac value %s.\n",\r\nbond->dev->name, buf);\r\nreturn -EINVAL;\r\n}\r\nbond->params.fail_over_mac = new_value;\r\npr_info("%s: Setting fail_over_mac to %s (%d).\n",\r\nbond->dev->name, fail_over_mac_tbl[new_value].modename,\r\nnew_value);\r\nreturn count;\r\n}\r\nstatic ssize_t bonding_show_arp_interval(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%d\n", bond->params.arp_interval);\r\n}\r\nstatic ssize_t bonding_store_arp_interval(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint new_value, ret = count;\r\nstruct bonding *bond = to_bond(d);\r\nif (sscanf(buf, "%d", &new_value) != 1) {\r\npr_err("%s: no arp_interval value specified.\n",\r\nbond->dev->name);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (new_value < 0) {\r\npr_err("%s: Invalid arp_interval value %d not in range 1-%d; rejected.\n",\r\nbond->dev->name, new_value, INT_MAX);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (bond->params.mode == BOND_MODE_ALB ||\r\nbond->params.mode == BOND_MODE_TLB) {\r\npr_info("%s: ARP monitoring cannot be used with ALB/TLB. Only MII monitoring is supported on %s.\n",\r\nbond->dev->name, bond->dev->name);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\npr_info("%s: Setting ARP monitoring interval to %d.\n",\r\nbond->dev->name, new_value);\r\nbond->params.arp_interval = new_value;\r\nif (bond->params.miimon) {\r\npr_info("%s: ARP monitoring cannot be used with MII monitoring. %s Disabling MII monitoring.\n",\r\nbond->dev->name, bond->dev->name);\r\nbond->params.miimon = 0;\r\nif (delayed_work_pending(&bond->mii_work)) {\r\ncancel_delayed_work(&bond->mii_work);\r\nflush_workqueue(bond->wq);\r\n}\r\n}\r\nif (!bond->params.arp_targets[0]) {\r\npr_info("%s: ARP monitoring has been set up, but no ARP targets have been specified.\n",\r\nbond->dev->name);\r\n}\r\nif (bond->dev->flags & IFF_UP) {\r\nif (!delayed_work_pending(&bond->arp_work)) {\r\nif (bond->params.mode == BOND_MODE_ACTIVEBACKUP)\r\nINIT_DELAYED_WORK(&bond->arp_work,\r\nbond_activebackup_arp_mon);\r\nelse\r\nINIT_DELAYED_WORK(&bond->arp_work,\r\nbond_loadbalance_arp_mon);\r\nqueue_delayed_work(bond->wq, &bond->arp_work, 0);\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t bonding_show_arp_targets(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint i, res = 0;\r\nstruct bonding *bond = to_bond(d);\r\nfor (i = 0; i < BOND_MAX_ARP_TARGETS; i++) {\r\nif (bond->params.arp_targets[i])\r\nres += sprintf(buf + res, "%pI4 ",\r\n&bond->params.arp_targets[i]);\r\n}\r\nif (res)\r\nbuf[res-1] = '\n';\r\nreturn res;\r\n}\r\nstatic ssize_t bonding_store_arp_targets(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\n__be32 newtarget;\r\nint i = 0, done = 0, ret = count;\r\nstruct bonding *bond = to_bond(d);\r\n__be32 *targets;\r\ntargets = bond->params.arp_targets;\r\nnewtarget = in_aton(buf + 1);\r\nif (buf[0] == '+') {\r\nif ((newtarget == 0) || (newtarget == htonl(INADDR_BROADCAST))) {\r\npr_err("%s: invalid ARP target %pI4 specified for addition\n",\r\nbond->dev->name, &newtarget);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nfor (i = 0; (i < BOND_MAX_ARP_TARGETS) && !done; i++) {\r\nif (targets[i] == newtarget) {\r\npr_err("%s: ARP target %pI4 is already present\n",\r\nbond->dev->name, &newtarget);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (targets[i] == 0) {\r\npr_info("%s: adding ARP target %pI4.\n",\r\nbond->dev->name, &newtarget);\r\ndone = 1;\r\ntargets[i] = newtarget;\r\n}\r\n}\r\nif (!done) {\r\npr_err("%s: ARP target table is full!\n",\r\nbond->dev->name);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n} else if (buf[0] == '-') {\r\nif ((newtarget == 0) || (newtarget == htonl(INADDR_BROADCAST))) {\r\npr_err("%s: invalid ARP target %pI4 specified for removal\n",\r\nbond->dev->name, &newtarget);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nfor (i = 0; (i < BOND_MAX_ARP_TARGETS) && !done; i++) {\r\nif (targets[i] == newtarget) {\r\nint j;\r\npr_info("%s: removing ARP target %pI4.\n",\r\nbond->dev->name, &newtarget);\r\nfor (j = i; (j < (BOND_MAX_ARP_TARGETS-1)) && targets[j+1]; j++)\r\ntargets[j] = targets[j+1];\r\ntargets[j] = 0;\r\ndone = 1;\r\n}\r\n}\r\nif (!done) {\r\npr_info("%s: unable to remove nonexistent ARP target %pI4.\n",\r\nbond->dev->name, &newtarget);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n} else {\r\npr_err("no command found in arp_ip_targets file for bond %s. Use +<addr> or -<addr>.\n",\r\nbond->dev->name);\r\nret = -EPERM;\r\ngoto out;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t bonding_show_downdelay(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%d\n", bond->params.downdelay * bond->params.miimon);\r\n}\r\nstatic ssize_t bonding_store_downdelay(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint new_value, ret = count;\r\nstruct bonding *bond = to_bond(d);\r\nif (!(bond->params.miimon)) {\r\npr_err("%s: Unable to set down delay as MII monitoring is disabled\n",\r\nbond->dev->name);\r\nret = -EPERM;\r\ngoto out;\r\n}\r\nif (sscanf(buf, "%d", &new_value) != 1) {\r\npr_err("%s: no down delay value specified.\n", bond->dev->name);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (new_value < 0) {\r\npr_err("%s: Invalid down delay value %d not in range %d-%d; rejected.\n",\r\nbond->dev->name, new_value, 1, INT_MAX);\r\nret = -EINVAL;\r\ngoto out;\r\n} else {\r\nif ((new_value % bond->params.miimon) != 0) {\r\npr_warning("%s: Warning: down delay (%d) is not a multiple of miimon (%d), delay rounded to %d ms\n",\r\nbond->dev->name, new_value,\r\nbond->params.miimon,\r\n(new_value / bond->params.miimon) *\r\nbond->params.miimon);\r\n}\r\nbond->params.downdelay = new_value / bond->params.miimon;\r\npr_info("%s: Setting down delay to %d.\n",\r\nbond->dev->name,\r\nbond->params.downdelay * bond->params.miimon);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t bonding_show_updelay(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%d\n", bond->params.updelay * bond->params.miimon);\r\n}\r\nstatic ssize_t bonding_store_updelay(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint new_value, ret = count;\r\nstruct bonding *bond = to_bond(d);\r\nif (!(bond->params.miimon)) {\r\npr_err("%s: Unable to set up delay as MII monitoring is disabled\n",\r\nbond->dev->name);\r\nret = -EPERM;\r\ngoto out;\r\n}\r\nif (sscanf(buf, "%d", &new_value) != 1) {\r\npr_err("%s: no up delay value specified.\n",\r\nbond->dev->name);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (new_value < 0) {\r\npr_err("%s: Invalid down delay value %d not in range %d-%d; rejected.\n",\r\nbond->dev->name, new_value, 1, INT_MAX);\r\nret = -EINVAL;\r\ngoto out;\r\n} else {\r\nif ((new_value % bond->params.miimon) != 0) {\r\npr_warning("%s: Warning: up delay (%d) is not a multiple of miimon (%d), updelay rounded to %d ms\n",\r\nbond->dev->name, new_value,\r\nbond->params.miimon,\r\n(new_value / bond->params.miimon) *\r\nbond->params.miimon);\r\n}\r\nbond->params.updelay = new_value / bond->params.miimon;\r\npr_info("%s: Setting up delay to %d.\n",\r\nbond->dev->name,\r\nbond->params.updelay * bond->params.miimon);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t bonding_show_lacp(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%s %d\n",\r\nbond_lacp_tbl[bond->params.lacp_fast].modename,\r\nbond->params.lacp_fast);\r\n}\r\nstatic ssize_t bonding_store_lacp(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint new_value, ret = count;\r\nstruct bonding *bond = to_bond(d);\r\nif (bond->dev->flags & IFF_UP) {\r\npr_err("%s: Unable to update LACP rate because interface is up.\n",\r\nbond->dev->name);\r\nret = -EPERM;\r\ngoto out;\r\n}\r\nif (bond->params.mode != BOND_MODE_8023AD) {\r\npr_err("%s: Unable to update LACP rate because bond is not in 802.3ad mode.\n",\r\nbond->dev->name);\r\nret = -EPERM;\r\ngoto out;\r\n}\r\nnew_value = bond_parse_parm(buf, bond_lacp_tbl);\r\nif ((new_value == 1) || (new_value == 0)) {\r\nbond->params.lacp_fast = new_value;\r\nbond_3ad_update_lacp_rate(bond);\r\npr_info("%s: Setting LACP rate to %s (%d).\n",\r\nbond->dev->name, bond_lacp_tbl[new_value].modename,\r\nnew_value);\r\n} else {\r\npr_err("%s: Ignoring invalid LACP rate value %.*s.\n",\r\nbond->dev->name, (int)strlen(buf) - 1, buf);\r\nret = -EINVAL;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t bonding_show_min_links(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%d\n", bond->params.min_links);\r\n}\r\nstatic ssize_t bonding_store_min_links(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nint ret;\r\nunsigned int new_value;\r\nret = kstrtouint(buf, 0, &new_value);\r\nif (ret < 0) {\r\npr_err("%s: Ignoring invalid min links value %s.\n",\r\nbond->dev->name, buf);\r\nreturn ret;\r\n}\r\npr_info("%s: Setting min links value to %u\n",\r\nbond->dev->name, new_value);\r\nbond->params.min_links = new_value;\r\nreturn count;\r\n}\r\nstatic ssize_t bonding_show_ad_select(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%s %d\n",\r\nad_select_tbl[bond->params.ad_select].modename,\r\nbond->params.ad_select);\r\n}\r\nstatic ssize_t bonding_store_ad_select(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint new_value, ret = count;\r\nstruct bonding *bond = to_bond(d);\r\nif (bond->dev->flags & IFF_UP) {\r\npr_err("%s: Unable to update ad_select because interface is up.\n",\r\nbond->dev->name);\r\nret = -EPERM;\r\ngoto out;\r\n}\r\nnew_value = bond_parse_parm(buf, ad_select_tbl);\r\nif (new_value != -1) {\r\nbond->params.ad_select = new_value;\r\npr_info("%s: Setting ad_select to %s (%d).\n",\r\nbond->dev->name, ad_select_tbl[new_value].modename,\r\nnew_value);\r\n} else {\r\npr_err("%s: Ignoring invalid ad_select value %.*s.\n",\r\nbond->dev->name, (int)strlen(buf) - 1, buf);\r\nret = -EINVAL;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t bonding_show_num_peer_notif(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%d\n", bond->params.num_peer_notif);\r\n}\r\nstatic ssize_t bonding_store_num_peer_notif(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nint err = kstrtou8(buf, 10, &bond->params.num_peer_notif);\r\nreturn err ? err : count;\r\n}\r\nstatic ssize_t bonding_show_miimon(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%d\n", bond->params.miimon);\r\n}\r\nstatic ssize_t bonding_store_miimon(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint new_value, ret = count;\r\nstruct bonding *bond = to_bond(d);\r\nif (sscanf(buf, "%d", &new_value) != 1) {\r\npr_err("%s: no miimon value specified.\n",\r\nbond->dev->name);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (new_value < 0) {\r\npr_err("%s: Invalid miimon value %d not in range %d-%d; rejected.\n",\r\nbond->dev->name, new_value, 1, INT_MAX);\r\nret = -EINVAL;\r\ngoto out;\r\n} else {\r\npr_info("%s: Setting MII monitoring interval to %d.\n",\r\nbond->dev->name, new_value);\r\nbond->params.miimon = new_value;\r\nif (bond->params.updelay)\r\npr_info("%s: Note: Updating updelay (to %d) since it is a multiple of the miimon value.\n",\r\nbond->dev->name,\r\nbond->params.updelay * bond->params.miimon);\r\nif (bond->params.downdelay)\r\npr_info("%s: Note: Updating downdelay (to %d) since it is a multiple of the miimon value.\n",\r\nbond->dev->name,\r\nbond->params.downdelay * bond->params.miimon);\r\nif (bond->params.arp_interval) {\r\npr_info("%s: MII monitoring cannot be used with ARP monitoring. Disabling ARP monitoring...\n",\r\nbond->dev->name);\r\nbond->params.arp_interval = 0;\r\nif (bond->params.arp_validate) {\r\nbond->params.arp_validate =\r\nBOND_ARP_VALIDATE_NONE;\r\n}\r\nif (delayed_work_pending(&bond->arp_work)) {\r\ncancel_delayed_work(&bond->arp_work);\r\nflush_workqueue(bond->wq);\r\n}\r\n}\r\nif (bond->dev->flags & IFF_UP) {\r\nif (!delayed_work_pending(&bond->mii_work)) {\r\nINIT_DELAYED_WORK(&bond->mii_work,\r\nbond_mii_monitor);\r\nqueue_delayed_work(bond->wq,\r\n&bond->mii_work, 0);\r\n}\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t bonding_show_primary(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint count = 0;\r\nstruct bonding *bond = to_bond(d);\r\nif (bond->primary_slave)\r\ncount = sprintf(buf, "%s\n", bond->primary_slave->dev->name);\r\nreturn count;\r\n}\r\nstatic ssize_t bonding_store_primary(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint i;\r\nstruct slave *slave;\r\nstruct bonding *bond = to_bond(d);\r\nchar ifname[IFNAMSIZ];\r\nif (!rtnl_trylock())\r\nreturn restart_syscall();\r\nblock_netpoll_tx();\r\nread_lock(&bond->lock);\r\nwrite_lock_bh(&bond->curr_slave_lock);\r\nif (!USES_PRIMARY(bond->params.mode)) {\r\npr_info("%s: Unable to set primary slave; %s is in mode %d\n",\r\nbond->dev->name, bond->dev->name, bond->params.mode);\r\ngoto out;\r\n}\r\nsscanf(buf, "%16s", ifname);\r\nif (!strlen(ifname) || buf[0] == '\n') {\r\npr_info("%s: Setting primary slave to None.\n",\r\nbond->dev->name);\r\nbond->primary_slave = NULL;\r\nbond_select_active_slave(bond);\r\ngoto out;\r\n}\r\nbond_for_each_slave(bond, slave, i) {\r\nif (strncmp(slave->dev->name, ifname, IFNAMSIZ) == 0) {\r\npr_info("%s: Setting %s as primary slave.\n",\r\nbond->dev->name, slave->dev->name);\r\nbond->primary_slave = slave;\r\nstrcpy(bond->params.primary, slave->dev->name);\r\nbond_select_active_slave(bond);\r\ngoto out;\r\n}\r\n}\r\npr_info("%s: Unable to set %.*s as primary slave.\n",\r\nbond->dev->name, (int)strlen(buf) - 1, buf);\r\nout:\r\nwrite_unlock_bh(&bond->curr_slave_lock);\r\nread_unlock(&bond->lock);\r\nunblock_netpoll_tx();\r\nrtnl_unlock();\r\nreturn count;\r\n}\r\nstatic ssize_t bonding_show_primary_reselect(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%s %d\n",\r\npri_reselect_tbl[bond->params.primary_reselect].modename,\r\nbond->params.primary_reselect);\r\n}\r\nstatic ssize_t bonding_store_primary_reselect(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint new_value, ret = count;\r\nstruct bonding *bond = to_bond(d);\r\nif (!rtnl_trylock())\r\nreturn restart_syscall();\r\nnew_value = bond_parse_parm(buf, pri_reselect_tbl);\r\nif (new_value < 0) {\r\npr_err("%s: Ignoring invalid primary_reselect value %.*s.\n",\r\nbond->dev->name,\r\n(int) strlen(buf) - 1, buf);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nbond->params.primary_reselect = new_value;\r\npr_info("%s: setting primary_reselect to %s (%d).\n",\r\nbond->dev->name, pri_reselect_tbl[new_value].modename,\r\nnew_value);\r\nblock_netpoll_tx();\r\nread_lock(&bond->lock);\r\nwrite_lock_bh(&bond->curr_slave_lock);\r\nbond_select_active_slave(bond);\r\nwrite_unlock_bh(&bond->curr_slave_lock);\r\nread_unlock(&bond->lock);\r\nunblock_netpoll_tx();\r\nout:\r\nrtnl_unlock();\r\nreturn ret;\r\n}\r\nstatic ssize_t bonding_show_carrier(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%d\n", bond->params.use_carrier);\r\n}\r\nstatic ssize_t bonding_store_carrier(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint new_value, ret = count;\r\nstruct bonding *bond = to_bond(d);\r\nif (sscanf(buf, "%d", &new_value) != 1) {\r\npr_err("%s: no use_carrier value specified.\n",\r\nbond->dev->name);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif ((new_value == 0) || (new_value == 1)) {\r\nbond->params.use_carrier = new_value;\r\npr_info("%s: Setting use_carrier to %d.\n",\r\nbond->dev->name, new_value);\r\n} else {\r\npr_info("%s: Ignoring invalid use_carrier value %d.\n",\r\nbond->dev->name, new_value);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t bonding_show_active_slave(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct slave *curr;\r\nstruct bonding *bond = to_bond(d);\r\nint count = 0;\r\nread_lock(&bond->curr_slave_lock);\r\ncurr = bond->curr_active_slave;\r\nread_unlock(&bond->curr_slave_lock);\r\nif (USES_PRIMARY(bond->params.mode) && curr)\r\ncount = sprintf(buf, "%s\n", curr->dev->name);\r\nreturn count;\r\n}\r\nstatic ssize_t bonding_store_active_slave(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint i;\r\nstruct slave *slave;\r\nstruct slave *old_active = NULL;\r\nstruct slave *new_active = NULL;\r\nstruct bonding *bond = to_bond(d);\r\nchar ifname[IFNAMSIZ];\r\nif (!rtnl_trylock())\r\nreturn restart_syscall();\r\nblock_netpoll_tx();\r\nread_lock(&bond->lock);\r\nwrite_lock_bh(&bond->curr_slave_lock);\r\nif (!USES_PRIMARY(bond->params.mode)) {\r\npr_info("%s: Unable to change active slave; %s is in mode %d\n",\r\nbond->dev->name, bond->dev->name, bond->params.mode);\r\ngoto out;\r\n}\r\nsscanf(buf, "%16s", ifname);\r\nif (!strlen(ifname) || buf[0] == '\n') {\r\npr_info("%s: Clearing current active slave.\n",\r\nbond->dev->name);\r\nbond->curr_active_slave = NULL;\r\nbond_select_active_slave(bond);\r\ngoto out;\r\n}\r\nbond_for_each_slave(bond, slave, i) {\r\nif (strncmp(slave->dev->name, ifname, IFNAMSIZ) == 0) {\r\nold_active = bond->curr_active_slave;\r\nnew_active = slave;\r\nif (new_active == old_active) {\r\npr_info("%s: %s is already the current"\r\n" active slave.\n",\r\nbond->dev->name,\r\nslave->dev->name);\r\ngoto out;\r\n}\r\nelse {\r\nif ((new_active) &&\r\n(old_active) &&\r\n(new_active->link == BOND_LINK_UP) &&\r\nIS_UP(new_active->dev)) {\r\npr_info("%s: Setting %s as active"\r\n" slave.\n",\r\nbond->dev->name,\r\nslave->dev->name);\r\nbond_change_active_slave(bond,\r\nnew_active);\r\n}\r\nelse {\r\npr_info("%s: Could not set %s as"\r\n" active slave; either %s is"\r\n" down or the link is down.\n",\r\nbond->dev->name,\r\nslave->dev->name,\r\nslave->dev->name);\r\n}\r\ngoto out;\r\n}\r\n}\r\n}\r\npr_info("%s: Unable to set %.*s as active slave.\n",\r\nbond->dev->name, (int)strlen(buf) - 1, buf);\r\nout:\r\nwrite_unlock_bh(&bond->curr_slave_lock);\r\nread_unlock(&bond->lock);\r\nunblock_netpoll_tx();\r\nrtnl_unlock();\r\nreturn count;\r\n}\r\nstatic ssize_t bonding_show_mii_status(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct slave *curr;\r\nstruct bonding *bond = to_bond(d);\r\nread_lock(&bond->curr_slave_lock);\r\ncurr = bond->curr_active_slave;\r\nread_unlock(&bond->curr_slave_lock);\r\nreturn sprintf(buf, "%s\n", curr ? "up" : "down");\r\n}\r\nstatic ssize_t bonding_show_ad_aggregator(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint count = 0;\r\nstruct bonding *bond = to_bond(d);\r\nif (bond->params.mode == BOND_MODE_8023AD) {\r\nstruct ad_info ad_info;\r\ncount = sprintf(buf, "%d\n",\r\n(bond_3ad_get_active_agg_info(bond, &ad_info))\r\n? 0 : ad_info.aggregator_id);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t bonding_show_ad_num_ports(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint count = 0;\r\nstruct bonding *bond = to_bond(d);\r\nif (bond->params.mode == BOND_MODE_8023AD) {\r\nstruct ad_info ad_info;\r\ncount = sprintf(buf, "%d\n",\r\n(bond_3ad_get_active_agg_info(bond, &ad_info))\r\n? 0 : ad_info.ports);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t bonding_show_ad_actor_key(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint count = 0;\r\nstruct bonding *bond = to_bond(d);\r\nif (bond->params.mode == BOND_MODE_8023AD) {\r\nstruct ad_info ad_info;\r\ncount = sprintf(buf, "%d\n",\r\n(bond_3ad_get_active_agg_info(bond, &ad_info))\r\n? 0 : ad_info.actor_key);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t bonding_show_ad_partner_key(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint count = 0;\r\nstruct bonding *bond = to_bond(d);\r\nif (bond->params.mode == BOND_MODE_8023AD) {\r\nstruct ad_info ad_info;\r\ncount = sprintf(buf, "%d\n",\r\n(bond_3ad_get_active_agg_info(bond, &ad_info))\r\n? 0 : ad_info.partner_key);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t bonding_show_ad_partner_mac(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint count = 0;\r\nstruct bonding *bond = to_bond(d);\r\nif (bond->params.mode == BOND_MODE_8023AD) {\r\nstruct ad_info ad_info;\r\nif (!bond_3ad_get_active_agg_info(bond, &ad_info))\r\ncount = sprintf(buf, "%pM\n", ad_info.partner_system);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t bonding_show_queue_id(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct slave *slave;\r\nint i, res = 0;\r\nstruct bonding *bond = to_bond(d);\r\nif (!rtnl_trylock())\r\nreturn restart_syscall();\r\nread_lock(&bond->lock);\r\nbond_for_each_slave(bond, slave, i) {\r\nif (res > (PAGE_SIZE - IFNAMSIZ - 6)) {\r\nif ((PAGE_SIZE - res) > 10)\r\nres = PAGE_SIZE - 10;\r\nres += sprintf(buf + res, "++more++ ");\r\nbreak;\r\n}\r\nres += sprintf(buf + res, "%s:%d ",\r\nslave->dev->name, slave->queue_id);\r\n}\r\nread_unlock(&bond->lock);\r\nif (res)\r\nbuf[res-1] = '\n';\r\nrtnl_unlock();\r\nreturn res;\r\n}\r\nstatic ssize_t bonding_store_queue_id(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nstruct slave *slave, *update_slave;\r\nstruct bonding *bond = to_bond(d);\r\nu16 qid;\r\nint i, ret = count;\r\nchar *delim;\r\nstruct net_device *sdev = NULL;\r\nif (!rtnl_trylock())\r\nreturn restart_syscall();\r\ndelim = strchr(buffer, ':');\r\nif (!delim)\r\ngoto err_no_cmd;\r\n*delim = '\0';\r\nif (sscanf(++delim, "%hd\n", &qid) != 1)\r\ngoto err_no_cmd;\r\nif (strlen(buffer) > IFNAMSIZ ||\r\n!dev_valid_name(buffer) ||\r\nqid > bond->params.tx_queues)\r\ngoto err_no_cmd;\r\nsdev = __dev_get_by_name(dev_net(bond->dev), buffer);\r\nif (!sdev)\r\ngoto err_no_cmd;\r\nread_lock(&bond->lock);\r\nupdate_slave = NULL;\r\nbond_for_each_slave(bond, slave, i) {\r\nif (sdev == slave->dev)\r\nupdate_slave = slave;\r\nelse if (qid && qid == slave->queue_id) {\r\ngoto err_no_cmd_unlock;\r\n}\r\n}\r\nif (!update_slave)\r\ngoto err_no_cmd_unlock;\r\nupdate_slave->queue_id = qid;\r\nread_unlock(&bond->lock);\r\nout:\r\nrtnl_unlock();\r\nreturn ret;\r\nerr_no_cmd_unlock:\r\nread_unlock(&bond->lock);\r\nerr_no_cmd:\r\npr_info("invalid input for queue_id set for %s.\n",\r\nbond->dev->name);\r\nret = -EPERM;\r\ngoto out;\r\n}\r\nstatic ssize_t bonding_show_slaves_active(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%d\n", bond->params.all_slaves_active);\r\n}\r\nstatic ssize_t bonding_store_slaves_active(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint i, new_value, ret = count;\r\nstruct bonding *bond = to_bond(d);\r\nstruct slave *slave;\r\nif (sscanf(buf, "%d", &new_value) != 1) {\r\npr_err("%s: no all_slaves_active value specified.\n",\r\nbond->dev->name);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (new_value == bond->params.all_slaves_active)\r\ngoto out;\r\nif ((new_value == 0) || (new_value == 1)) {\r\nbond->params.all_slaves_active = new_value;\r\n} else {\r\npr_info("%s: Ignoring invalid all_slaves_active value %d.\n",\r\nbond->dev->name, new_value);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nbond_for_each_slave(bond, slave, i) {\r\nif (!bond_is_active_slave(slave)) {\r\nif (new_value)\r\nslave->inactive = 0;\r\nelse\r\nslave->inactive = 1;\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t bonding_show_resend_igmp(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bonding *bond = to_bond(d);\r\nreturn sprintf(buf, "%d\n", bond->params.resend_igmp);\r\n}\r\nstatic ssize_t bonding_store_resend_igmp(struct device *d,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint new_value, ret = count;\r\nstruct bonding *bond = to_bond(d);\r\nif (sscanf(buf, "%d", &new_value) != 1) {\r\npr_err("%s: no resend_igmp value specified.\n",\r\nbond->dev->name);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (new_value < 0 || new_value > 255) {\r\npr_err("%s: Invalid resend_igmp value %d not in range 0-255; rejected.\n",\r\nbond->dev->name, new_value);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\npr_info("%s: Setting resend_igmp to %d.\n",\r\nbond->dev->name, new_value);\r\nbond->params.resend_igmp = new_value;\r\nout:\r\nreturn ret;\r\n}\r\nint bond_create_sysfs(struct bond_net *bn)\r\n{\r\nint ret;\r\nbn->class_attr_bonding_masters = class_attr_bonding_masters;\r\nsysfs_attr_init(&bn->class_attr_bonding_masters.attr);\r\nret = netdev_class_create_file(&bn->class_attr_bonding_masters);\r\nif (ret == -EEXIST) {\r\nif (__dev_get_by_name(bn->net,\r\nclass_attr_bonding_masters.attr.name))\r\npr_err("network device named %s already exists in sysfs",\r\nclass_attr_bonding_masters.attr.name);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nvoid bond_destroy_sysfs(struct bond_net *bn)\r\n{\r\nnetdev_class_remove_file(&bn->class_attr_bonding_masters);\r\n}\r\nvoid bond_prepare_sysfs_group(struct bonding *bond)\r\n{\r\nbond->dev->sysfs_groups[0] = &bonding_group;\r\n}
