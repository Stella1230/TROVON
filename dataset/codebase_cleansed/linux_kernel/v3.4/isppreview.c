static void\r\npreview_enable_invalaw(struct isp_prev_device *prev, u8 enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nif (enable)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_WIDTH | ISPPRV_PCR_INVALAW);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_WIDTH | ISPPRV_PCR_INVALAW);\r\n}\r\nstatic void\r\npreview_enable_drkframe_capture(struct isp_prev_device *prev, u8 enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nif (enable)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_DRKFCAP);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_DRKFCAP);\r\n}\r\nstatic void\r\npreview_enable_drkframe(struct isp_prev_device *prev, u8 enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nif (enable)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_DRKFEN);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_DRKFEN);\r\n}\r\nstatic void\r\npreview_config_drkf_shadcomp(struct isp_prev_device *prev,\r\nconst void *scomp_shtval)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst u32 *shtval = scomp_shtval;\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_SCOMP_SFT_MASK,\r\n*shtval << ISPPRV_PCR_SCOMP_SFT_SHIFT);\r\n}\r\nstatic void\r\npreview_enable_hmed(struct isp_prev_device *prev, u8 enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nif (enable)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_HMEDEN);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_HMEDEN);\r\n}\r\nstatic void\r\npreview_config_hmed(struct isp_prev_device *prev, const void *prev_hmed)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_hmed *hmed = prev_hmed;\r\nisp_reg_writel(isp, (hmed->odddist == 1 ? 0 : ISPPRV_HMED_ODDDIST) |\r\n(hmed->evendist == 1 ? 0 : ISPPRV_HMED_EVENDIST) |\r\n(hmed->thres << ISPPRV_HMED_THRESHOLD_SHIFT),\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_HMED);\r\n}\r\nstatic void\r\npreview_config_noisefilter(struct isp_prev_device *prev, const void *prev_nf)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_nf *nf = prev_nf;\r\nunsigned int i;\r\nisp_reg_writel(isp, nf->spread, OMAP3_ISP_IOMEM_PREV, ISPPRV_NF);\r\nisp_reg_writel(isp, ISPPRV_NF_TABLE_ADDR,\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);\r\nfor (i = 0; i < OMAP3ISP_PREV_NF_TBL_SIZE; i++) {\r\nisp_reg_writel(isp, nf->table[i],\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_DATA);\r\n}\r\n}\r\nstatic void\r\npreview_config_dcor(struct isp_prev_device *prev, const void *prev_dcor)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_dcor *dcor = prev_dcor;\r\nisp_reg_writel(isp, dcor->detect_correct[0],\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR0);\r\nisp_reg_writel(isp, dcor->detect_correct[1],\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR1);\r\nisp_reg_writel(isp, dcor->detect_correct[2],\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR2);\r\nisp_reg_writel(isp, dcor->detect_correct[3],\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR3);\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_DCCOUP,\r\ndcor->couplet_mode_en ? ISPPRV_PCR_DCCOUP : 0);\r\n}\r\nstatic void\r\npreview_config_cfa(struct isp_prev_device *prev, const void *prev_cfa)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_cfa *cfa = prev_cfa;\r\nunsigned int i;\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_CFAFMT_MASK,\r\ncfa->format << ISPPRV_PCR_CFAFMT_SHIFT);\r\nisp_reg_writel(isp,\r\n(cfa->gradthrs_vert << ISPPRV_CFA_GRADTH_VER_SHIFT) |\r\n(cfa->gradthrs_horz << ISPPRV_CFA_GRADTH_HOR_SHIFT),\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_CFA);\r\nisp_reg_writel(isp, ISPPRV_CFA_TABLE_ADDR,\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);\r\nfor (i = 0; i < OMAP3ISP_PREV_CFA_TBL_SIZE; i++) {\r\nisp_reg_writel(isp, cfa->table[i],\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_DATA);\r\n}\r\n}\r\nstatic void\r\npreview_config_gammacorrn(struct isp_prev_device *prev, const void *gtable)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_gtables *gt = gtable;\r\nunsigned int i;\r\nisp_reg_writel(isp, ISPPRV_REDGAMMA_TABLE_ADDR,\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);\r\nfor (i = 0; i < OMAP3ISP_PREV_GAMMA_TBL_SIZE; i++)\r\nisp_reg_writel(isp, gt->red[i], OMAP3_ISP_IOMEM_PREV,\r\nISPPRV_SET_TBL_DATA);\r\nisp_reg_writel(isp, ISPPRV_GREENGAMMA_TABLE_ADDR,\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);\r\nfor (i = 0; i < OMAP3ISP_PREV_GAMMA_TBL_SIZE; i++)\r\nisp_reg_writel(isp, gt->green[i], OMAP3_ISP_IOMEM_PREV,\r\nISPPRV_SET_TBL_DATA);\r\nisp_reg_writel(isp, ISPPRV_BLUEGAMMA_TABLE_ADDR,\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);\r\nfor (i = 0; i < OMAP3ISP_PREV_GAMMA_TBL_SIZE; i++)\r\nisp_reg_writel(isp, gt->blue[i], OMAP3_ISP_IOMEM_PREV,\r\nISPPRV_SET_TBL_DATA);\r\n}\r\nstatic void\r\npreview_config_luma_enhancement(struct isp_prev_device *prev,\r\nconst void *ytable)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_luma *yt = ytable;\r\nunsigned int i;\r\nisp_reg_writel(isp, ISPPRV_YENH_TABLE_ADDR,\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);\r\nfor (i = 0; i < OMAP3ISP_PREV_YENH_TBL_SIZE; i++) {\r\nisp_reg_writel(isp, yt->table[i],\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_DATA);\r\n}\r\n}\r\nstatic void\r\npreview_config_chroma_suppression(struct isp_prev_device *prev,\r\nconst void *csup)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_csup *cs = csup;\r\nisp_reg_writel(isp,\r\ncs->gain | (cs->thres << ISPPRV_CSUP_THRES_SHIFT) |\r\n(cs->hypf_en << ISPPRV_CSUP_HPYF_SHIFT),\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_CSUP);\r\n}\r\nstatic void\r\npreview_enable_noisefilter(struct isp_prev_device *prev, u8 enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nif (enable)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_NFEN);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_NFEN);\r\n}\r\nstatic void\r\npreview_enable_dcor(struct isp_prev_device *prev, u8 enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nif (enable)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_DCOREN);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_DCOREN);\r\n}\r\nstatic void\r\npreview_enable_cfa(struct isp_prev_device *prev, u8 enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nif (enable)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_CFAEN);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_CFAEN);\r\n}\r\nstatic void\r\npreview_enable_gammabypass(struct isp_prev_device *prev, u8 enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nif (enable)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_GAMMA_BYPASS);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_GAMMA_BYPASS);\r\n}\r\nstatic void\r\npreview_enable_luma_enhancement(struct isp_prev_device *prev, u8 enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nif (enable)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_YNENHEN);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_YNENHEN);\r\n}\r\nstatic void\r\npreview_enable_chroma_suppression(struct isp_prev_device *prev, u8 enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nif (enable)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_SUPEN);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_SUPEN);\r\n}\r\nstatic void\r\npreview_config_whitebalance(struct isp_prev_device *prev, const void *prev_wbal)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_wbal *wbal = prev_wbal;\r\nu32 val;\r\nisp_reg_writel(isp, wbal->dgain, OMAP3_ISP_IOMEM_PREV, ISPPRV_WB_DGAIN);\r\nval = wbal->coef0 << ISPPRV_WBGAIN_COEF0_SHIFT;\r\nval |= wbal->coef1 << ISPPRV_WBGAIN_COEF1_SHIFT;\r\nval |= wbal->coef2 << ISPPRV_WBGAIN_COEF2_SHIFT;\r\nval |= wbal->coef3 << ISPPRV_WBGAIN_COEF3_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_WBGAIN);\r\nisp_reg_writel(isp,\r\nISPPRV_WBSEL_COEF0 << ISPPRV_WBSEL_N0_0_SHIFT |\r\nISPPRV_WBSEL_COEF1 << ISPPRV_WBSEL_N0_1_SHIFT |\r\nISPPRV_WBSEL_COEF0 << ISPPRV_WBSEL_N0_2_SHIFT |\r\nISPPRV_WBSEL_COEF1 << ISPPRV_WBSEL_N0_3_SHIFT |\r\nISPPRV_WBSEL_COEF2 << ISPPRV_WBSEL_N1_0_SHIFT |\r\nISPPRV_WBSEL_COEF3 << ISPPRV_WBSEL_N1_1_SHIFT |\r\nISPPRV_WBSEL_COEF2 << ISPPRV_WBSEL_N1_2_SHIFT |\r\nISPPRV_WBSEL_COEF3 << ISPPRV_WBSEL_N1_3_SHIFT |\r\nISPPRV_WBSEL_COEF0 << ISPPRV_WBSEL_N2_0_SHIFT |\r\nISPPRV_WBSEL_COEF1 << ISPPRV_WBSEL_N2_1_SHIFT |\r\nISPPRV_WBSEL_COEF0 << ISPPRV_WBSEL_N2_2_SHIFT |\r\nISPPRV_WBSEL_COEF1 << ISPPRV_WBSEL_N2_3_SHIFT |\r\nISPPRV_WBSEL_COEF2 << ISPPRV_WBSEL_N3_0_SHIFT |\r\nISPPRV_WBSEL_COEF3 << ISPPRV_WBSEL_N3_1_SHIFT |\r\nISPPRV_WBSEL_COEF2 << ISPPRV_WBSEL_N3_2_SHIFT |\r\nISPPRV_WBSEL_COEF3 << ISPPRV_WBSEL_N3_3_SHIFT,\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_WBSEL);\r\n}\r\nstatic void\r\npreview_config_blkadj(struct isp_prev_device *prev, const void *prev_blkadj)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_blkadj *blkadj = prev_blkadj;\r\nisp_reg_writel(isp, (blkadj->blue << ISPPRV_BLKADJOFF_B_SHIFT) |\r\n(blkadj->green << ISPPRV_BLKADJOFF_G_SHIFT) |\r\n(blkadj->red << ISPPRV_BLKADJOFF_R_SHIFT),\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_BLKADJOFF);\r\n}\r\nstatic void\r\npreview_config_rgb_blending(struct isp_prev_device *prev, const void *rgb2rgb)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_rgbtorgb *rgbrgb = rgb2rgb;\r\nu32 val;\r\nval = (rgbrgb->matrix[0][0] & 0xfff) << ISPPRV_RGB_MAT1_MTX_RR_SHIFT;\r\nval |= (rgbrgb->matrix[0][1] & 0xfff) << ISPPRV_RGB_MAT1_MTX_GR_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_MAT1);\r\nval = (rgbrgb->matrix[0][2] & 0xfff) << ISPPRV_RGB_MAT2_MTX_BR_SHIFT;\r\nval |= (rgbrgb->matrix[1][0] & 0xfff) << ISPPRV_RGB_MAT2_MTX_RG_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_MAT2);\r\nval = (rgbrgb->matrix[1][1] & 0xfff) << ISPPRV_RGB_MAT3_MTX_GG_SHIFT;\r\nval |= (rgbrgb->matrix[1][2] & 0xfff) << ISPPRV_RGB_MAT3_MTX_BG_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_MAT3);\r\nval = (rgbrgb->matrix[2][0] & 0xfff) << ISPPRV_RGB_MAT4_MTX_RB_SHIFT;\r\nval |= (rgbrgb->matrix[2][1] & 0xfff) << ISPPRV_RGB_MAT4_MTX_GB_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_MAT4);\r\nval = (rgbrgb->matrix[2][2] & 0xfff) << ISPPRV_RGB_MAT5_MTX_BB_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_MAT5);\r\nval = (rgbrgb->offset[0] & 0x3ff) << ISPPRV_RGB_OFF1_MTX_OFFR_SHIFT;\r\nval |= (rgbrgb->offset[1] & 0x3ff) << ISPPRV_RGB_OFF1_MTX_OFFG_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_OFF1);\r\nval = (rgbrgb->offset[2] & 0x3ff) << ISPPRV_RGB_OFF2_MTX_OFFB_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_OFF2);\r\n}\r\nstatic void\r\npreview_config_rgb_to_ycbcr(struct isp_prev_device *prev, const void *prev_csc)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_csc *csc = prev_csc;\r\nu32 val;\r\nval = (csc->matrix[0][0] & 0x3ff) << ISPPRV_CSC0_RY_SHIFT;\r\nval |= (csc->matrix[0][1] & 0x3ff) << ISPPRV_CSC0_GY_SHIFT;\r\nval |= (csc->matrix[0][2] & 0x3ff) << ISPPRV_CSC0_BY_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC0);\r\nval = (csc->matrix[1][0] & 0x3ff) << ISPPRV_CSC1_RCB_SHIFT;\r\nval |= (csc->matrix[1][1] & 0x3ff) << ISPPRV_CSC1_GCB_SHIFT;\r\nval |= (csc->matrix[1][2] & 0x3ff) << ISPPRV_CSC1_BCB_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC1);\r\nval = (csc->matrix[2][0] & 0x3ff) << ISPPRV_CSC2_RCR_SHIFT;\r\nval |= (csc->matrix[2][1] & 0x3ff) << ISPPRV_CSC2_GCR_SHIFT;\r\nval |= (csc->matrix[2][2] & 0x3ff) << ISPPRV_CSC2_BCR_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC2);\r\nval = (csc->offset[0] & 0xff) << ISPPRV_CSC_OFFSET_Y_SHIFT;\r\nval |= (csc->offset[1] & 0xff) << ISPPRV_CSC_OFFSET_CB_SHIFT;\r\nval |= (csc->offset[2] & 0xff) << ISPPRV_CSC_OFFSET_CR_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC_OFFSET);\r\n}\r\nstatic void\r\npreview_update_contrast(struct isp_prev_device *prev, u8 contrast)\r\n{\r\nstruct prev_params *params = &prev->params;\r\nif (params->contrast != (contrast * ISPPRV_CONTRAST_UNITS)) {\r\nparams->contrast = contrast * ISPPRV_CONTRAST_UNITS;\r\nprev->update |= PREV_CONTRAST;\r\n}\r\n}\r\nstatic void\r\npreview_config_contrast(struct isp_prev_device *prev, const void *params)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_CNT_BRT,\r\n0xff << ISPPRV_CNT_BRT_CNT_SHIFT,\r\n*(u8 *)params << ISPPRV_CNT_BRT_CNT_SHIFT);\r\n}\r\nstatic void\r\npreview_update_brightness(struct isp_prev_device *prev, u8 brightness)\r\n{\r\nstruct prev_params *params = &prev->params;\r\nif (params->brightness != (brightness * ISPPRV_BRIGHT_UNITS)) {\r\nparams->brightness = brightness * ISPPRV_BRIGHT_UNITS;\r\nprev->update |= PREV_BRIGHTNESS;\r\n}\r\n}\r\nstatic void\r\npreview_config_brightness(struct isp_prev_device *prev, const void *params)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_CNT_BRT,\r\n0xff << ISPPRV_CNT_BRT_BRT_SHIFT,\r\n*(u8 *)params << ISPPRV_CNT_BRT_BRT_SHIFT);\r\n}\r\nstatic void\r\npreview_config_yc_range(struct isp_prev_device *prev, const void *yclimit)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_yclimit *yc = yclimit;\r\nisp_reg_writel(isp,\r\nyc->maxC << ISPPRV_SETUP_YC_MAXC_SHIFT |\r\nyc->maxY << ISPPRV_SETUP_YC_MAXY_SHIFT |\r\nyc->minC << ISPPRV_SETUP_YC_MINC_SHIFT |\r\nyc->minY << ISPPRV_SETUP_YC_MINY_SHIFT,\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_SETUP_YC);\r\n}\r\nstatic u32\r\n__preview_get_ptrs(struct prev_params *params, void **param,\r\nstruct omap3isp_prev_update_config *configs,\r\nvoid __user **config, u32 bit)\r\n{\r\n#define CHKARG(cfgs, cfg, field) \\r\nif (cfgs && cfg) { \\r\n*(cfg) = (cfgs)->field; \\r\n}\r\nswitch (bit) {\r\ncase PREV_HORZ_MEDIAN_FILTER:\r\n*param = &params->hmed;\r\nCHKARG(configs, config, hmed)\r\nreturn sizeof(params->hmed);\r\ncase PREV_NOISE_FILTER:\r\n*param = &params->nf;\r\nCHKARG(configs, config, nf)\r\nreturn sizeof(params->nf);\r\nbreak;\r\ncase PREV_CFA:\r\n*param = &params->cfa;\r\nCHKARG(configs, config, cfa)\r\nreturn sizeof(params->cfa);\r\ncase PREV_LUMA_ENHANCE:\r\n*param = &params->luma;\r\nCHKARG(configs, config, luma)\r\nreturn sizeof(params->luma);\r\ncase PREV_CHROMA_SUPPRESS:\r\n*param = &params->csup;\r\nCHKARG(configs, config, csup)\r\nreturn sizeof(params->csup);\r\ncase PREV_DEFECT_COR:\r\n*param = &params->dcor;\r\nCHKARG(configs, config, dcor)\r\nreturn sizeof(params->dcor);\r\ncase PREV_BLKADJ:\r\n*param = &params->blk_adj;\r\nCHKARG(configs, config, blkadj)\r\nreturn sizeof(params->blk_adj);\r\ncase PREV_YCLIMITS:\r\n*param = &params->yclimit;\r\nCHKARG(configs, config, yclimit)\r\nreturn sizeof(params->yclimit);\r\ncase PREV_RGB2RGB:\r\n*param = &params->rgb2rgb;\r\nCHKARG(configs, config, rgb2rgb)\r\nreturn sizeof(params->rgb2rgb);\r\ncase PREV_COLOR_CONV:\r\n*param = &params->rgb2ycbcr;\r\nCHKARG(configs, config, csc)\r\nreturn sizeof(params->rgb2ycbcr);\r\ncase PREV_WB:\r\n*param = &params->wbal;\r\nCHKARG(configs, config, wbal)\r\nreturn sizeof(params->wbal);\r\ncase PREV_GAMMA:\r\n*param = &params->gamma;\r\nCHKARG(configs, config, gamma)\r\nreturn sizeof(params->gamma);\r\ncase PREV_CONTRAST:\r\n*param = &params->contrast;\r\nreturn 0;\r\ncase PREV_BRIGHTNESS:\r\n*param = &params->brightness;\r\nreturn 0;\r\ndefault:\r\n*param = NULL;\r\n*config = NULL;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int preview_config(struct isp_prev_device *prev,\r\nstruct omap3isp_prev_update_config *cfg)\r\n{\r\nstruct prev_params *params;\r\nstruct preview_update *attr;\r\nint i, bit, rval = 0;\r\nparams = &prev->params;\r\nif (prev->state != ISP_PIPELINE_STREAM_STOPPED) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&prev->lock, flags);\r\nprev->shadow_update = 1;\r\nspin_unlock_irqrestore(&prev->lock, flags);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(update_attrs); i++) {\r\nattr = &update_attrs[i];\r\nbit = 0;\r\nif (!(cfg->update & attr->cfg_bit))\r\ncontinue;\r\nbit = cfg->flag & attr->cfg_bit;\r\nif (bit) {\r\nvoid *to = NULL, __user *from = NULL;\r\nunsigned long sz = 0;\r\nsz = __preview_get_ptrs(params, &to, cfg, &from,\r\nbit);\r\nif (to && from && sz) {\r\nif (copy_from_user(to, from, sz)) {\r\nrval = -EFAULT;\r\nbreak;\r\n}\r\n}\r\nparams->features |= attr->feature_bit;\r\n} else {\r\nparams->features &= ~attr->feature_bit;\r\n}\r\nprev->update |= attr->feature_bit;\r\n}\r\nprev->shadow_update = 0;\r\nreturn rval;\r\n}\r\nstatic void preview_setup_hw(struct isp_prev_device *prev)\r\n{\r\nstruct prev_params *params = &prev->params;\r\nstruct preview_update *attr;\r\nint i, bit;\r\nvoid *param_ptr;\r\nfor (i = 0; i < ARRAY_SIZE(update_attrs); i++) {\r\nattr = &update_attrs[i];\r\nif (!(prev->update & attr->feature_bit))\r\ncontinue;\r\nbit = params->features & attr->feature_bit;\r\nif (bit) {\r\nif (attr->config) {\r\n__preview_get_ptrs(params, &param_ptr, NULL,\r\nNULL, bit);\r\nattr->config(prev, param_ptr);\r\n}\r\nif (attr->enable)\r\nattr->enable(prev, 1);\r\n} else\r\nif (attr->enable)\r\nattr->enable(prev, 0);\r\nprev->update &= ~attr->feature_bit;\r\n}\r\n}\r\nstatic void\r\npreview_config_ycpos(struct isp_prev_device *prev,\r\nenum v4l2_mbus_pixelcode pixelcode)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nenum preview_ycpos_mode mode;\r\nswitch (pixelcode) {\r\ncase V4L2_MBUS_FMT_YUYV8_1X16:\r\nmode = YCPOS_CrYCbY;\r\nbreak;\r\ncase V4L2_MBUS_FMT_UYVY8_1X16:\r\nmode = YCPOS_YCrYCb;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_YCPOS_CrYCbY,\r\nmode << ISPPRV_PCR_YCPOS_SHIFT);\r\n}\r\nstatic void preview_config_averager(struct isp_prev_device *prev, u8 average)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nint reg = 0;\r\nif (prev->params.cfa.format == OMAP3ISP_CFAFMT_BAYER)\r\nreg = ISPPRV_AVE_EVENDIST_2 << ISPPRV_AVE_EVENDIST_SHIFT |\r\nISPPRV_AVE_ODDDIST_2 << ISPPRV_AVE_ODDDIST_SHIFT |\r\naverage;\r\nelse if (prev->params.cfa.format == OMAP3ISP_CFAFMT_RGBFOVEON)\r\nreg = ISPPRV_AVE_EVENDIST_3 << ISPPRV_AVE_EVENDIST_SHIFT |\r\nISPPRV_AVE_ODDDIST_3 << ISPPRV_AVE_ODDDIST_SHIFT |\r\naverage;\r\nisp_reg_writel(isp, reg, OMAP3_ISP_IOMEM_PREV, ISPPRV_AVE);\r\n}\r\nstatic void preview_config_input_size(struct isp_prev_device *prev)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nstruct prev_params *params = &prev->params;\r\nunsigned int sph = prev->crop.left;\r\nunsigned int eph = prev->crop.left + prev->crop.width - 1;\r\nunsigned int slv = prev->crop.top;\r\nunsigned int elv = prev->crop.top + prev->crop.height - 1;\r\nif (params->features & PREV_CFA) {\r\nsph -= 2;\r\neph += 2;\r\nslv -= 2;\r\nelv += 2;\r\n}\r\nif (params->features & (PREV_DEFECT_COR | PREV_NOISE_FILTER)) {\r\nsph -= 2;\r\neph += 2;\r\nslv -= 2;\r\nelv += 2;\r\n}\r\nif (params->features & PREV_HORZ_MEDIAN_FILTER) {\r\nsph -= 2;\r\neph += 2;\r\n}\r\nif (params->features & (PREV_CHROMA_SUPPRESS | PREV_LUMA_ENHANCE))\r\nsph -= 2;\r\nisp_reg_writel(isp, (sph << ISPPRV_HORZ_INFO_SPH_SHIFT) | eph,\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_HORZ_INFO);\r\nisp_reg_writel(isp, (slv << ISPPRV_VERT_INFO_SLV_SHIFT) | elv,\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_VERT_INFO);\r\n}\r\nstatic void\r\npreview_config_inlineoffset(struct isp_prev_device *prev, u32 offset)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nisp_reg_writel(isp, offset & 0xffff, OMAP3_ISP_IOMEM_PREV,\r\nISPPRV_RADR_OFFSET);\r\n}\r\nstatic void preview_set_inaddr(struct isp_prev_device *prev, u32 addr)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nisp_reg_writel(isp, addr, OMAP3_ISP_IOMEM_PREV, ISPPRV_RSDR_ADDR);\r\n}\r\nstatic void preview_config_outlineoffset(struct isp_prev_device *prev,\r\nu32 offset)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nisp_reg_writel(isp, offset & 0xffff, OMAP3_ISP_IOMEM_PREV,\r\nISPPRV_WADD_OFFSET);\r\n}\r\nstatic void preview_set_outaddr(struct isp_prev_device *prev, u32 addr)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nisp_reg_writel(isp, addr, OMAP3_ISP_IOMEM_PREV, ISPPRV_WSDR_ADDR);\r\n}\r\nstatic void preview_adjust_bandwidth(struct isp_prev_device *prev)\r\n{\r\nstruct isp_pipeline *pipe = to_isp_pipeline(&prev->subdev.entity);\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct v4l2_mbus_framefmt *ifmt = &prev->formats[PREV_PAD_SINK];\r\nunsigned long l3_ick = pipe->l3_ick;\r\nstruct v4l2_fract *timeperframe;\r\nunsigned int cycles_per_frame;\r\nunsigned int requests_per_frame;\r\nunsigned int cycles_per_request;\r\nunsigned int minimum;\r\nunsigned int maximum;\r\nunsigned int value;\r\nif (prev->input != PREVIEW_INPUT_MEMORY) {\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_SDR_REQ_EXP,\r\nISPSBL_SDR_REQ_PRV_EXP_MASK);\r\nreturn;\r\n}\r\ncycles_per_request = div_u64((u64)l3_ick / 2 * 256 + pipe->max_rate - 1,\r\npipe->max_rate);\r\nminimum = DIV_ROUND_UP(cycles_per_request, 32);\r\ntimeperframe = &pipe->max_timeperframe;\r\nrequests_per_frame = DIV_ROUND_UP(ifmt->width * 2, 256) * ifmt->height;\r\ncycles_per_frame = div_u64((u64)l3_ick * timeperframe->numerator,\r\ntimeperframe->denominator);\r\ncycles_per_request = cycles_per_frame / requests_per_frame;\r\nmaximum = cycles_per_request / 32;\r\nvalue = max(minimum, maximum);\r\ndev_dbg(isp->dev, "%s: cycles per request = %u\n", __func__, value);\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_SDR_REQ_EXP,\r\nISPSBL_SDR_REQ_PRV_EXP_MASK,\r\nvalue << ISPSBL_SDR_REQ_PRV_EXP_SHIFT);\r\n}\r\nint omap3isp_preview_busy(struct isp_prev_device *prev)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nreturn isp_reg_readl(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR)\r\n& ISPPRV_PCR_BUSY;\r\n}\r\nvoid omap3isp_preview_restore_context(struct isp_device *isp)\r\n{\r\nisp->isp_prev.update = PREV_FEATURES_END - 1;\r\npreview_setup_hw(&isp->isp_prev);\r\n}\r\nstatic void preview_print_status(struct isp_prev_device *prev)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\ndev_dbg(isp->dev, "-------------Preview Register dump----------\n");\r\nPREV_PRINT_REGISTER(isp, PCR);\r\nPREV_PRINT_REGISTER(isp, HORZ_INFO);\r\nPREV_PRINT_REGISTER(isp, VERT_INFO);\r\nPREV_PRINT_REGISTER(isp, RSDR_ADDR);\r\nPREV_PRINT_REGISTER(isp, RADR_OFFSET);\r\nPREV_PRINT_REGISTER(isp, DSDR_ADDR);\r\nPREV_PRINT_REGISTER(isp, DRKF_OFFSET);\r\nPREV_PRINT_REGISTER(isp, WSDR_ADDR);\r\nPREV_PRINT_REGISTER(isp, WADD_OFFSET);\r\nPREV_PRINT_REGISTER(isp, AVE);\r\nPREV_PRINT_REGISTER(isp, HMED);\r\nPREV_PRINT_REGISTER(isp, NF);\r\nPREV_PRINT_REGISTER(isp, WB_DGAIN);\r\nPREV_PRINT_REGISTER(isp, WBGAIN);\r\nPREV_PRINT_REGISTER(isp, WBSEL);\r\nPREV_PRINT_REGISTER(isp, CFA);\r\nPREV_PRINT_REGISTER(isp, BLKADJOFF);\r\nPREV_PRINT_REGISTER(isp, RGB_MAT1);\r\nPREV_PRINT_REGISTER(isp, RGB_MAT2);\r\nPREV_PRINT_REGISTER(isp, RGB_MAT3);\r\nPREV_PRINT_REGISTER(isp, RGB_MAT4);\r\nPREV_PRINT_REGISTER(isp, RGB_MAT5);\r\nPREV_PRINT_REGISTER(isp, RGB_OFF1);\r\nPREV_PRINT_REGISTER(isp, RGB_OFF2);\r\nPREV_PRINT_REGISTER(isp, CSC0);\r\nPREV_PRINT_REGISTER(isp, CSC1);\r\nPREV_PRINT_REGISTER(isp, CSC2);\r\nPREV_PRINT_REGISTER(isp, CSC_OFFSET);\r\nPREV_PRINT_REGISTER(isp, CNT_BRT);\r\nPREV_PRINT_REGISTER(isp, CSUP);\r\nPREV_PRINT_REGISTER(isp, SETUP_YC);\r\nPREV_PRINT_REGISTER(isp, SET_TBL_ADDR);\r\nPREV_PRINT_REGISTER(isp, CDC_THR0);\r\nPREV_PRINT_REGISTER(isp, CDC_THR1);\r\nPREV_PRINT_REGISTER(isp, CDC_THR2);\r\nPREV_PRINT_REGISTER(isp, CDC_THR3);\r\ndev_dbg(isp->dev, "--------------------------------------------\n");\r\n}\r\nstatic void preview_init_params(struct isp_prev_device *prev)\r\n{\r\nstruct prev_params *params = &prev->params;\r\nint i = 0;\r\nparams->contrast = ISPPRV_CONTRAST_DEF * ISPPRV_CONTRAST_UNITS;\r\nparams->brightness = ISPPRV_BRIGHT_DEF * ISPPRV_BRIGHT_UNITS;\r\nparams->cfa.format = OMAP3ISP_CFAFMT_BAYER;\r\nmemcpy(params->cfa.table, cfa_coef_table,\r\nsizeof(params->cfa.table));\r\nparams->cfa.gradthrs_horz = FLR_CFA_GRADTHRS_HORZ;\r\nparams->cfa.gradthrs_vert = FLR_CFA_GRADTHRS_VERT;\r\nparams->csup.gain = FLR_CSUP_GAIN;\r\nparams->csup.thres = FLR_CSUP_THRES;\r\nparams->csup.hypf_en = 0;\r\nmemcpy(params->luma.table, luma_enhance_table,\r\nsizeof(params->luma.table));\r\nparams->nf.spread = FLR_NF_STRGTH;\r\nmemcpy(params->nf.table, noise_filter_table, sizeof(params->nf.table));\r\nparams->dcor.couplet_mode_en = 1;\r\nfor (i = 0; i < OMAP3ISP_PREV_DETECT_CORRECT_CHANNELS; i++)\r\nparams->dcor.detect_correct[i] = DEF_DETECT_CORRECT_VAL;\r\nmemcpy(params->gamma.blue, gamma_table, sizeof(params->gamma.blue));\r\nmemcpy(params->gamma.green, gamma_table, sizeof(params->gamma.green));\r\nmemcpy(params->gamma.red, gamma_table, sizeof(params->gamma.red));\r\nparams->wbal.dgain = FLR_WBAL_DGAIN;\r\nparams->wbal.coef0 = FLR_WBAL_COEF;\r\nparams->wbal.coef1 = FLR_WBAL_COEF;\r\nparams->wbal.coef2 = FLR_WBAL_COEF;\r\nparams->wbal.coef3 = FLR_WBAL_COEF;\r\nparams->blk_adj.red = FLR_BLKADJ_RED;\r\nparams->blk_adj.green = FLR_BLKADJ_GREEN;\r\nparams->blk_adj.blue = FLR_BLKADJ_BLUE;\r\nparams->rgb2rgb = flr_rgb2rgb;\r\nparams->rgb2ycbcr = flr_prev_csc;\r\nparams->yclimit.minC = ISPPRV_YC_MIN;\r\nparams->yclimit.maxC = ISPPRV_YC_MAX;\r\nparams->yclimit.minY = ISPPRV_YC_MIN;\r\nparams->yclimit.maxY = ISPPRV_YC_MAX;\r\nparams->features = PREV_CFA | PREV_DEFECT_COR | PREV_NOISE_FILTER\r\n| PREV_GAMMA | PREV_BLKADJ | PREV_YCLIMITS\r\n| PREV_RGB2RGB | PREV_COLOR_CONV | PREV_WB\r\n| PREV_BRIGHTNESS | PREV_CONTRAST;\r\nprev->update = PREV_FEATURES_END - 1;\r\n}\r\nstatic unsigned int preview_max_out_width(struct isp_prev_device *prev)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nswitch (isp->revision) {\r\ncase ISP_REVISION_1_0:\r\nreturn PREV_MAX_OUT_WIDTH_REV_1;\r\ncase ISP_REVISION_2_0:\r\ndefault:\r\nreturn PREV_MAX_OUT_WIDTH_REV_2;\r\ncase ISP_REVISION_15_0:\r\nreturn PREV_MAX_OUT_WIDTH_REV_15;\r\n}\r\n}\r\nstatic void preview_configure(struct isp_prev_device *prev)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nstruct v4l2_mbus_framefmt *format;\r\npreview_setup_hw(prev);\r\nif (prev->output & PREVIEW_OUTPUT_MEMORY)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_SDRPORT);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_SDRPORT);\r\nif (prev->output & PREVIEW_OUTPUT_RESIZER)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_RSZPORT);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_RSZPORT);\r\nformat = &prev->formats[PREV_PAD_SINK];\r\npreview_adjust_bandwidth(prev);\r\npreview_config_input_size(prev);\r\nif (prev->input == PREVIEW_INPUT_CCDC)\r\npreview_config_inlineoffset(prev, 0);\r\nelse\r\npreview_config_inlineoffset(prev,\r\nALIGN(format->width, 0x20) * 2);\r\nformat = &prev->formats[PREV_PAD_SOURCE];\r\nif (prev->output & PREVIEW_OUTPUT_MEMORY)\r\npreview_config_outlineoffset(prev,\r\nALIGN(format->width, 0x10) * 2);\r\npreview_config_averager(prev, 0);\r\npreview_config_ycpos(prev, format->code);\r\n}\r\nstatic void preview_enable_oneshot(struct isp_prev_device *prev)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nif (prev->input == PREVIEW_INPUT_MEMORY)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_SOURCE);\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_EN | ISPPRV_PCR_ONESHOT);\r\n}\r\nvoid omap3isp_preview_isr_frame_sync(struct isp_prev_device *prev)\r\n{\r\nif (prev->state == ISP_PIPELINE_STREAM_CONTINUOUS &&\r\nprev->video_out.dmaqueue_flags & ISP_VIDEO_DMAQUEUE_QUEUED) {\r\npreview_enable_oneshot(prev);\r\nisp_video_dmaqueue_flags_clr(&prev->video_out);\r\n}\r\n}\r\nstatic void preview_isr_buffer(struct isp_prev_device *prev)\r\n{\r\nstruct isp_pipeline *pipe = to_isp_pipeline(&prev->subdev.entity);\r\nstruct isp_buffer *buffer;\r\nint restart = 0;\r\nif (prev->input == PREVIEW_INPUT_MEMORY) {\r\nbuffer = omap3isp_video_buffer_next(&prev->video_in);\r\nif (buffer != NULL)\r\npreview_set_inaddr(prev, buffer->isp_addr);\r\npipe->state |= ISP_PIPELINE_IDLE_INPUT;\r\n}\r\nif (prev->output & PREVIEW_OUTPUT_MEMORY) {\r\nbuffer = omap3isp_video_buffer_next(&prev->video_out);\r\nif (buffer != NULL) {\r\npreview_set_outaddr(prev, buffer->isp_addr);\r\nrestart = 1;\r\n}\r\npipe->state |= ISP_PIPELINE_IDLE_OUTPUT;\r\n}\r\nswitch (prev->state) {\r\ncase ISP_PIPELINE_STREAM_SINGLESHOT:\r\nif (isp_pipeline_ready(pipe))\r\nomap3isp_pipeline_set_stream(pipe,\r\nISP_PIPELINE_STREAM_SINGLESHOT);\r\nbreak;\r\ncase ISP_PIPELINE_STREAM_CONTINUOUS:\r\nif (restart)\r\npreview_enable_oneshot(prev);\r\nbreak;\r\ncase ISP_PIPELINE_STREAM_STOPPED:\r\ndefault:\r\nreturn;\r\n}\r\n}\r\nvoid omap3isp_preview_isr(struct isp_prev_device *prev)\r\n{\r\nunsigned long flags;\r\nif (omap3isp_module_sync_is_stopping(&prev->wait, &prev->stopping))\r\nreturn;\r\nspin_lock_irqsave(&prev->lock, flags);\r\nif (prev->shadow_update)\r\ngoto done;\r\npreview_setup_hw(prev);\r\npreview_config_input_size(prev);\r\ndone:\r\nspin_unlock_irqrestore(&prev->lock, flags);\r\nif (prev->input == PREVIEW_INPUT_MEMORY ||\r\nprev->output & PREVIEW_OUTPUT_MEMORY)\r\npreview_isr_buffer(prev);\r\nelse if (prev->state == ISP_PIPELINE_STREAM_CONTINUOUS)\r\npreview_enable_oneshot(prev);\r\n}\r\nstatic int preview_video_queue(struct isp_video *video,\r\nstruct isp_buffer *buffer)\r\n{\r\nstruct isp_prev_device *prev = &video->isp->isp_prev;\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\npreview_set_inaddr(prev, buffer->isp_addr);\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\npreview_set_outaddr(prev, buffer->isp_addr);\r\nreturn 0;\r\n}\r\nstatic int preview_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct isp_prev_device *prev =\r\ncontainer_of(ctrl->handler, struct isp_prev_device, ctrls);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\npreview_update_brightness(prev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\npreview_update_contrast(prev, ctrl->val);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic long preview_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\r\n{\r\nstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\r\nswitch (cmd) {\r\ncase VIDIOC_OMAP3ISP_PRV_CFG:\r\nreturn preview_config(prev, arg);\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic int preview_set_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\r\nstruct isp_video *video_out = &prev->video_out;\r\nstruct isp_device *isp = to_isp_device(prev);\r\nstruct device *dev = to_device(prev);\r\nunsigned long flags;\r\nif (prev->state == ISP_PIPELINE_STREAM_STOPPED) {\r\nif (enable == ISP_PIPELINE_STREAM_STOPPED)\r\nreturn 0;\r\nomap3isp_subclk_enable(isp, OMAP3_ISP_SUBCLK_PREVIEW);\r\npreview_configure(prev);\r\natomic_set(&prev->stopping, 0);\r\npreview_print_status(prev);\r\n}\r\nswitch (enable) {\r\ncase ISP_PIPELINE_STREAM_CONTINUOUS:\r\nif (prev->output & PREVIEW_OUTPUT_MEMORY)\r\nomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_PREVIEW_WRITE);\r\nif (video_out->dmaqueue_flags & ISP_VIDEO_DMAQUEUE_QUEUED ||\r\n!(prev->output & PREVIEW_OUTPUT_MEMORY))\r\npreview_enable_oneshot(prev);\r\nisp_video_dmaqueue_flags_clr(video_out);\r\nbreak;\r\ncase ISP_PIPELINE_STREAM_SINGLESHOT:\r\nif (prev->input == PREVIEW_INPUT_MEMORY)\r\nomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_PREVIEW_READ);\r\nif (prev->output & PREVIEW_OUTPUT_MEMORY)\r\nomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_PREVIEW_WRITE);\r\npreview_enable_oneshot(prev);\r\nbreak;\r\ncase ISP_PIPELINE_STREAM_STOPPED:\r\nif (omap3isp_module_sync_idle(&sd->entity, &prev->wait,\r\n&prev->stopping))\r\ndev_dbg(dev, "%s: stop timeout.\n", sd->name);\r\nspin_lock_irqsave(&prev->lock, flags);\r\nomap3isp_sbl_disable(isp, OMAP3_ISP_SBL_PREVIEW_READ);\r\nomap3isp_sbl_disable(isp, OMAP3_ISP_SBL_PREVIEW_WRITE);\r\nomap3isp_subclk_disable(isp, OMAP3_ISP_SUBCLK_PREVIEW);\r\nspin_unlock_irqrestore(&prev->lock, flags);\r\nisp_video_dmaqueue_flags_clr(video_out);\r\nbreak;\r\n}\r\nprev->state = enable;\r\nreturn 0;\r\n}\r\nstatic struct v4l2_mbus_framefmt *\r\n__preview_get_format(struct isp_prev_device *prev, struct v4l2_subdev_fh *fh,\r\nunsigned int pad, enum v4l2_subdev_format_whence which)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn v4l2_subdev_get_try_format(fh, pad);\r\nelse\r\nreturn &prev->formats[pad];\r\n}\r\nstatic struct v4l2_rect *\r\n__preview_get_crop(struct isp_prev_device *prev, struct v4l2_subdev_fh *fh,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn v4l2_subdev_get_try_crop(fh, PREV_PAD_SINK);\r\nelse\r\nreturn &prev->crop;\r\n}\r\nstatic void preview_try_format(struct isp_prev_device *prev,\r\nstruct v4l2_subdev_fh *fh, unsigned int pad,\r\nstruct v4l2_mbus_framefmt *fmt,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nenum v4l2_mbus_pixelcode pixelcode;\r\nstruct v4l2_rect *crop;\r\nunsigned int i;\r\nswitch (pad) {\r\ncase PREV_PAD_SINK:\r\nif (prev->input == PREVIEW_INPUT_MEMORY) {\r\nfmt->width = clamp_t(u32, fmt->width, PREV_MIN_IN_WIDTH,\r\npreview_max_out_width(prev));\r\nfmt->height = clamp_t(u32, fmt->height,\r\nPREV_MIN_IN_HEIGHT,\r\nPREV_MAX_IN_HEIGHT);\r\n}\r\nfmt->colorspace = V4L2_COLORSPACE_SRGB;\r\nfor (i = 0; i < ARRAY_SIZE(preview_input_fmts); i++) {\r\nif (fmt->code == preview_input_fmts[i])\r\nbreak;\r\n}\r\nif (i >= ARRAY_SIZE(preview_input_fmts))\r\nfmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;\r\nbreak;\r\ncase PREV_PAD_SOURCE:\r\npixelcode = fmt->code;\r\n*fmt = *__preview_get_format(prev, fh, PREV_PAD_SINK, which);\r\nswitch (pixelcode) {\r\ncase V4L2_MBUS_FMT_YUYV8_1X16:\r\ncase V4L2_MBUS_FMT_UYVY8_1X16:\r\nfmt->code = pixelcode;\r\nbreak;\r\ndefault:\r\nfmt->code = V4L2_MBUS_FMT_YUYV8_1X16;\r\nbreak;\r\n}\r\ncrop = __preview_get_crop(prev, fh, which);\r\nfmt->width = crop->width;\r\nfmt->height = crop->height;\r\nfmt->colorspace = V4L2_COLORSPACE_JPEG;\r\nbreak;\r\n}\r\nfmt->field = V4L2_FIELD_NONE;\r\n}\r\nstatic void preview_try_crop(struct isp_prev_device *prev,\r\nconst struct v4l2_mbus_framefmt *sink,\r\nstruct v4l2_rect *crop)\r\n{\r\nunsigned int left = PREV_MARGIN_LEFT;\r\nunsigned int right = sink->width - PREV_MARGIN_RIGHT;\r\nunsigned int top = PREV_MARGIN_TOP;\r\nunsigned int bottom = sink->height - PREV_MARGIN_BOTTOM;\r\nif (prev->input == PREVIEW_INPUT_CCDC) {\r\nleft += 2;\r\nright -= 2;\r\n}\r\ncrop->left &= ~1;\r\ncrop->top &= ~1;\r\ncrop->left = clamp_t(u32, crop->left, left, right - PREV_MIN_OUT_WIDTH);\r\ncrop->top = clamp_t(u32, crop->top, top, bottom - PREV_MIN_OUT_HEIGHT);\r\ncrop->width = clamp_t(u32, crop->width, PREV_MIN_OUT_WIDTH,\r\nright - crop->left);\r\ncrop->height = clamp_t(u32, crop->height, PREV_MIN_OUT_HEIGHT,\r\nbottom - crop->top);\r\n}\r\nstatic int preview_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nswitch (code->pad) {\r\ncase PREV_PAD_SINK:\r\nif (code->index >= ARRAY_SIZE(preview_input_fmts))\r\nreturn -EINVAL;\r\ncode->code = preview_input_fmts[code->index];\r\nbreak;\r\ncase PREV_PAD_SOURCE:\r\nif (code->index >= ARRAY_SIZE(preview_output_fmts))\r\nreturn -EINVAL;\r\ncode->code = preview_output_fmts[code->index];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int preview_enum_frame_size(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt format;\r\nif (fse->index != 0)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = 1;\r\nformat.height = 1;\r\npreview_try_format(prev, fh, fse->pad, &format, V4L2_SUBDEV_FORMAT_TRY);\r\nfse->min_width = format.width;\r\nfse->min_height = format.height;\r\nif (format.code != fse->code)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = -1;\r\nformat.height = -1;\r\npreview_try_format(prev, fh, fse->pad, &format, V4L2_SUBDEV_FORMAT_TRY);\r\nfse->max_width = format.width;\r\nfse->max_height = format.height;\r\nreturn 0;\r\n}\r\nstatic int preview_get_crop(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_crop *crop)\r\n{\r\nstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\r\nif (crop->pad != PREV_PAD_SINK)\r\nreturn -EINVAL;\r\ncrop->rect = *__preview_get_crop(prev, fh, crop->which);\r\nreturn 0;\r\n}\r\nstatic int preview_set_crop(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_crop *crop)\r\n{\r\nstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nif (crop->pad != PREV_PAD_SINK)\r\nreturn -EINVAL;\r\nif (prev->state != ISP_PIPELINE_STREAM_STOPPED)\r\nreturn -EBUSY;\r\nformat = __preview_get_format(prev, fh, PREV_PAD_SINK, crop->which);\r\npreview_try_crop(prev, format, &crop->rect);\r\n*__preview_get_crop(prev, fh, crop->which) = crop->rect;\r\nformat = __preview_get_format(prev, fh, PREV_PAD_SOURCE, crop->which);\r\npreview_try_format(prev, fh, PREV_PAD_SOURCE, format, crop->which);\r\nreturn 0;\r\n}\r\nstatic int preview_get_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = __preview_get_format(prev, fh, fmt->pad, fmt->which);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nfmt->format = *format;\r\nreturn 0;\r\n}\r\nstatic int preview_set_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nstruct v4l2_rect *crop;\r\nformat = __preview_get_format(prev, fh, fmt->pad, fmt->which);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\npreview_try_format(prev, fh, fmt->pad, &fmt->format, fmt->which);\r\n*format = fmt->format;\r\nif (fmt->pad == PREV_PAD_SINK) {\r\ncrop = __preview_get_crop(prev, fh, fmt->which);\r\ncrop->left = 0;\r\ncrop->top = 0;\r\ncrop->width = fmt->format.width;\r\ncrop->height = fmt->format.height;\r\npreview_try_crop(prev, &fmt->format, crop);\r\nformat = __preview_get_format(prev, fh, PREV_PAD_SOURCE,\r\nfmt->which);\r\npreview_try_format(prev, fh, PREV_PAD_SOURCE, format,\r\nfmt->which);\r\n}\r\nreturn 0;\r\n}\r\nstatic int preview_init_formats(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_subdev_format format;\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = PREV_PAD_SINK;\r\nformat.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\r\nformat.format.code = V4L2_MBUS_FMT_SGRBG10_1X10;\r\nformat.format.width = 4096;\r\nformat.format.height = 4096;\r\npreview_set_format(sd, fh, &format);\r\nreturn 0;\r\n}\r\nstatic int preview_link_setup(struct media_entity *entity,\r\nconst struct media_pad *local,\r\nconst struct media_pad *remote, u32 flags)\r\n{\r\nstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\r\nstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\r\nswitch (local->index | media_entity_type(remote->entity)) {\r\ncase PREV_PAD_SINK | MEDIA_ENT_T_DEVNODE:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (prev->input == PREVIEW_INPUT_CCDC)\r\nreturn -EBUSY;\r\nprev->input = PREVIEW_INPUT_MEMORY;\r\n} else {\r\nif (prev->input == PREVIEW_INPUT_MEMORY)\r\nprev->input = PREVIEW_INPUT_NONE;\r\n}\r\nbreak;\r\ncase PREV_PAD_SINK | MEDIA_ENT_T_V4L2_SUBDEV:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (prev->input == PREVIEW_INPUT_MEMORY)\r\nreturn -EBUSY;\r\nprev->input = PREVIEW_INPUT_CCDC;\r\n} else {\r\nif (prev->input == PREVIEW_INPUT_CCDC)\r\nprev->input = PREVIEW_INPUT_NONE;\r\n}\r\nbreak;\r\ncase PREV_PAD_SOURCE | MEDIA_ENT_T_DEVNODE:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (prev->output & ~PREVIEW_OUTPUT_MEMORY)\r\nreturn -EBUSY;\r\nprev->output |= PREVIEW_OUTPUT_MEMORY;\r\n} else {\r\nprev->output &= ~PREVIEW_OUTPUT_MEMORY;\r\n}\r\nbreak;\r\ncase PREV_PAD_SOURCE | MEDIA_ENT_T_V4L2_SUBDEV:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (prev->output & ~PREVIEW_OUTPUT_RESIZER)\r\nreturn -EBUSY;\r\nprev->output |= PREVIEW_OUTPUT_RESIZER;\r\n} else {\r\nprev->output &= ~PREVIEW_OUTPUT_RESIZER;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid omap3isp_preview_unregister_entities(struct isp_prev_device *prev)\r\n{\r\nv4l2_device_unregister_subdev(&prev->subdev);\r\nomap3isp_video_unregister(&prev->video_in);\r\nomap3isp_video_unregister(&prev->video_out);\r\n}\r\nint omap3isp_preview_register_entities(struct isp_prev_device *prev,\r\nstruct v4l2_device *vdev)\r\n{\r\nint ret;\r\nret = v4l2_device_register_subdev(vdev, &prev->subdev);\r\nif (ret < 0)\r\ngoto error;\r\nret = omap3isp_video_register(&prev->video_in, vdev);\r\nif (ret < 0)\r\ngoto error;\r\nret = omap3isp_video_register(&prev->video_out, vdev);\r\nif (ret < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nomap3isp_preview_unregister_entities(prev);\r\nreturn ret;\r\n}\r\nstatic int preview_init_entities(struct isp_prev_device *prev)\r\n{\r\nstruct v4l2_subdev *sd = &prev->subdev;\r\nstruct media_pad *pads = prev->pads;\r\nstruct media_entity *me = &sd->entity;\r\nint ret;\r\nprev->input = PREVIEW_INPUT_NONE;\r\nv4l2_subdev_init(sd, &preview_v4l2_ops);\r\nsd->internal_ops = &preview_v4l2_internal_ops;\r\nstrlcpy(sd->name, "OMAP3 ISP preview", sizeof(sd->name));\r\nsd->grp_id = 1 << 16;\r\nv4l2_set_subdevdata(sd, prev);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nv4l2_ctrl_handler_init(&prev->ctrls, 2);\r\nv4l2_ctrl_new_std(&prev->ctrls, &preview_ctrl_ops, V4L2_CID_BRIGHTNESS,\r\nISPPRV_BRIGHT_LOW, ISPPRV_BRIGHT_HIGH,\r\nISPPRV_BRIGHT_STEP, ISPPRV_BRIGHT_DEF);\r\nv4l2_ctrl_new_std(&prev->ctrls, &preview_ctrl_ops, V4L2_CID_CONTRAST,\r\nISPPRV_CONTRAST_LOW, ISPPRV_CONTRAST_HIGH,\r\nISPPRV_CONTRAST_STEP, ISPPRV_CONTRAST_DEF);\r\nv4l2_ctrl_handler_setup(&prev->ctrls);\r\nsd->ctrl_handler = &prev->ctrls;\r\npads[PREV_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\r\npads[PREV_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\r\nme->ops = &preview_media_ops;\r\nret = media_entity_init(me, PREV_PADS_NUM, pads, 0);\r\nif (ret < 0)\r\nreturn ret;\r\npreview_init_formats(sd, NULL);\r\nprev->video_in.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nprev->video_in.ops = &preview_video_ops;\r\nprev->video_in.isp = to_isp_device(prev);\r\nprev->video_in.capture_mem = PAGE_ALIGN(4096 * 4096) * 2 * 3;\r\nprev->video_in.bpl_alignment = 64;\r\nprev->video_out.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nprev->video_out.ops = &preview_video_ops;\r\nprev->video_out.isp = to_isp_device(prev);\r\nprev->video_out.capture_mem = PAGE_ALIGN(4096 * 4096) * 2 * 3;\r\nprev->video_out.bpl_alignment = 32;\r\nret = omap3isp_video_init(&prev->video_in, "preview");\r\nif (ret < 0)\r\ngoto error_video_in;\r\nret = omap3isp_video_init(&prev->video_out, "preview");\r\nif (ret < 0)\r\ngoto error_video_out;\r\nret = media_entity_create_link(&prev->video_in.video.entity, 0,\r\n&prev->subdev.entity, PREV_PAD_SINK, 0);\r\nif (ret < 0)\r\ngoto error_link;\r\nret = media_entity_create_link(&prev->subdev.entity, PREV_PAD_SOURCE,\r\n&prev->video_out.video.entity, 0, 0);\r\nif (ret < 0)\r\ngoto error_link;\r\nreturn 0;\r\nerror_link:\r\nomap3isp_video_cleanup(&prev->video_out);\r\nerror_video_out:\r\nomap3isp_video_cleanup(&prev->video_in);\r\nerror_video_in:\r\nmedia_entity_cleanup(&prev->subdev.entity);\r\nreturn ret;\r\n}\r\nint omap3isp_preview_init(struct isp_device *isp)\r\n{\r\nstruct isp_prev_device *prev = &isp->isp_prev;\r\nspin_lock_init(&prev->lock);\r\ninit_waitqueue_head(&prev->wait);\r\npreview_init_params(prev);\r\nreturn preview_init_entities(prev);\r\n}\r\nvoid omap3isp_preview_cleanup(struct isp_device *isp)\r\n{\r\nstruct isp_prev_device *prev = &isp->isp_prev;\r\nv4l2_ctrl_handler_free(&prev->ctrls);\r\nomap3isp_video_cleanup(&prev->video_in);\r\nomap3isp_video_cleanup(&prev->video_out);\r\nmedia_entity_cleanup(&prev->subdev.entity);\r\n}
