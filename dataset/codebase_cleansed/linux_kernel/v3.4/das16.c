static inline int timer_period(void)\r\n{\r\nreturn HZ / 20;\r\n}\r\nstatic int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0, tmp;\r\nint gain, start_chan, i;\r\nint mask;\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\nmask = TRIG_FOLLOW;\r\nif (thisboard->size > 0x400)\r\nmask |= TRIG_TIMER | TRIG_EXT;\r\ncmd->scan_begin_src &= mask;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\nmask = TRIG_TIMER | TRIG_EXT;\r\nif (thisboard->size > 0x400)\r\nmask |= TRIG_NOW;\r\ncmd->convert_src &= mask;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->scan_begin_src != TRIG_TIMER &&\r\ncmd->scan_begin_src != TRIG_EXT &&\r\ncmd->scan_begin_src != TRIG_FOLLOW)\r\nerr++;\r\nif (cmd->convert_src != TRIG_TIMER &&\r\ncmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)\r\nerr++;\r\nif (cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_COUNT)\r\nerr++;\r\nif (cmd->scan_begin_src == TRIG_FOLLOW && cmd->convert_src == TRIG_NOW)\r\nerr++;\r\nif (cmd->scan_begin_src != TRIG_FOLLOW && cmd->convert_src != TRIG_NOW)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_src == TRIG_FOLLOW) {\r\nif (cmd->scan_begin_arg != 0) {\r\ncmd->scan_begin_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (cmd->scan_begin_arg <\r\nthisboard->ai_speed * cmd->chanlist_len) {\r\ncmd->scan_begin_arg =\r\nthisboard->ai_speed * cmd->chanlist_len;\r\nerr++;\r\n}\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (cmd->convert_arg < thisboard->ai_speed) {\r\ncmd->convert_arg = thisboard->ai_speed;\r\nerr++;\r\n}\r\n}\r\nif (cmd->stop_src == TRIG_NONE) {\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nunsigned int tmp = cmd->scan_begin_arg;\r\ni8253_cascade_ns_to_timer_2div(devpriv->clockbase,\r\n&(devpriv->divisor1),\r\n&(devpriv->divisor2),\r\n&(cmd->scan_begin_arg),\r\ncmd->flags & TRIG_ROUND_MASK);\r\nerr += (tmp != cmd->scan_begin_arg);\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nunsigned int tmp = cmd->convert_arg;\r\ni8253_cascade_ns_to_timer_2div(devpriv->clockbase,\r\n&(devpriv->divisor1),\r\n&(devpriv->divisor2),\r\n&(cmd->convert_arg),\r\ncmd->flags & TRIG_ROUND_MASK);\r\nerr += (tmp != cmd->convert_arg);\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist) {\r\ngain = CR_RANGE(cmd->chanlist[0]);\r\nstart_chan = CR_CHAN(cmd->chanlist[0]);\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nif (CR_CHAN(cmd->chanlist[i]) !=\r\n(start_chan + i) % s->n_chan) {\r\ncomedi_error(dev,\r\n"entries in chanlist must be "\r\n"consecutive channels, "\r\n"counting upwards\n");\r\nerr++;\r\n}\r\nif (CR_RANGE(cmd->chanlist[i]) != gain) {\r\ncomedi_error(dev,\r\n"entries in chanlist must all "\r\n"have the same gain\n");\r\nerr++;\r\n}\r\n}\r\n}\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int byte;\r\nunsigned long flags;\r\nint range;\r\nif (devpriv->dma_chan == 0 || (dev->irq == 0\r\n&& devpriv->timer_mode == 0)) {\r\ncomedi_error(dev,\r\n"irq (or use of 'timer mode') dma required to "\r\n"execute comedi_cmd");\r\nreturn -1;\r\n}\r\nif (cmd->flags & TRIG_RT) {\r\ncomedi_error(dev, "isa dma transfers cannot be performed with "\r\n"TRIG_RT, aborting");\r\nreturn -1;\r\n}\r\ndevpriv->adc_byte_count =\r\ncmd->stop_arg * cmd->chanlist_len * sizeof(uint16_t);\r\nif (thisboard->size > 0x400)\r\noutb(DAS1600_CONV_DISABLE, dev->iobase + DAS1600_CONV);\r\nbyte = CR_CHAN(cmd->chanlist[0]);\r\nbyte |= CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]) << 4;\r\noutb(byte, dev->iobase + DAS16_MUX);\r\nif (thisboard->ai_pg != das16_pg_none) {\r\nrange = CR_RANGE(cmd->chanlist[0]);\r\noutb((das16_gainlists[thisboard->ai_pg])[range],\r\ndev->iobase + DAS16_GAIN);\r\n}\r\ncmd->convert_arg =\r\ndas16_set_pacer(dev, cmd->convert_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nDEBUG_PRINT("pacer period: %d ns\n", cmd->convert_arg);\r\nbyte = 0;\r\nif (thisboard->size > 0x400) {\r\nif (cmd->convert_src == TRIG_NOW) {\r\noutb(DAS1600_BURST_VAL, dev->iobase + DAS1600_BURST);\r\nbyte |= BURST_LEN_BITS(cmd->chanlist_len - 1);\r\n} else {\r\noutb(0, dev->iobase + DAS1600_BURST);\r\n}\r\n}\r\noutb(byte, dev->iobase + DAS16_PACER);\r\nflags = claim_dma_lock();\r\ndisable_dma(devpriv->dma_chan);\r\nclear_dma_ff(devpriv->dma_chan);\r\ndevpriv->current_buffer = 0;\r\nset_dma_addr(devpriv->dma_chan,\r\ndevpriv->dma_buffer_addr[devpriv->current_buffer]);\r\ndevpriv->dma_transfer_size = das16_suggest_transfer_size(dev, *cmd);\r\nset_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);\r\nenable_dma(devpriv->dma_chan);\r\nrelease_dma_lock(flags);\r\nif (devpriv->timer_mode) {\r\ndevpriv->timer_running = 1;\r\ndevpriv->timer.expires = jiffies + timer_period();\r\nadd_timer(&devpriv->timer);\r\ndevpriv->control_state &= ~DAS16_INTE;\r\n} else {\r\noutb(0x00, dev->iobase + DAS16_STATUS);\r\ndevpriv->control_state |= DAS16_INTE;\r\n}\r\ndevpriv->control_state |= DMA_ENABLE;\r\ndevpriv->control_state &= ~PACING_MASK;\r\nif (cmd->convert_src == TRIG_EXT)\r\ndevpriv->control_state |= EXT_PACER;\r\nelse\r\ndevpriv->control_state |= INT_PACER;\r\noutb(devpriv->control_state, dev->iobase + DAS16_CONTROL);\r\nif (thisboard->size > 0x400)\r\noutb(0, dev->iobase + DAS1600_CONV);\r\nreturn 0;\r\n}\r\nstatic int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->control_state &= ~DAS16_INTE & ~PACING_MASK & ~DMA_ENABLE;\r\noutb(devpriv->control_state, dev->iobase + DAS16_CONTROL);\r\nif (devpriv->dma_chan)\r\ndisable_dma(devpriv->dma_chan);\r\nif (devpriv->timer_mode && devpriv->timer_running) {\r\ndevpriv->timer_running = 0;\r\ndel_timer(&devpriv->timer);\r\n}\r\nif (thisboard->size > 0x400)\r\noutb(0, dev->iobase + DAS1600_BURST);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic void das16_reset(struct comedi_device *dev)\r\n{\r\noutb(0, dev->iobase + DAS16_STATUS);\r\noutb(0, dev->iobase + DAS16_CONTROL);\r\noutb(0, dev->iobase + DAS16_PACER);\r\noutb(0, dev->iobase + DAS16_CNTR_CONTROL);\r\n}\r\nstatic int das16_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i, n;\r\nint range;\r\nint chan;\r\nint msb, lsb;\r\ndevpriv->control_state &= ~DAS16_INTE & ~DMA_ENABLE & ~PACING_MASK;\r\noutb(devpriv->control_state, dev->iobase + DAS16_CONTROL);\r\nchan = CR_CHAN(insn->chanspec);\r\nchan |= CR_CHAN(insn->chanspec) << 4;\r\noutb(chan, dev->iobase + DAS16_MUX);\r\nif (thisboard->ai_pg != das16_pg_none) {\r\nrange = CR_RANGE(insn->chanspec);\r\noutb((das16_gainlists[thisboard->ai_pg])[range],\r\ndev->iobase + DAS16_GAIN);\r\n}\r\nfor (n = 0; n < insn->n; n++) {\r\noutb_p(0, dev->iobase + DAS16_TRIG);\r\nfor (i = 0; i < DAS16_TIMEOUT; i++) {\r\nif (!(inb(dev->iobase + DAS16_STATUS) & BUSY))\r\nbreak;\r\n}\r\nif (i == DAS16_TIMEOUT) {\r\nprintk("das16: timeout\n");\r\nreturn -ETIME;\r\n}\r\nmsb = inb(dev->iobase + DAS16_AI_MSB);\r\nlsb = inb(dev->iobase + DAS16_AI_LSB);\r\nif (thisboard->ai_nbits == 12)\r\ndata[n] = ((lsb >> 4) & 0xf) | (msb << 4);\r\nelse\r\ndata[n] = lsb | (msb << 8);\r\n}\r\nreturn n;\r\n}\r\nstatic int das16_di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int bits;\r\nbits = inb(dev->iobase + DAS16_DIO) & 0xf;\r\ndata[1] = bits;\r\ndata[0] = 0;\r\nreturn 2;\r\n}\r\nstatic int das16_do_wbits(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int wbits;\r\ndata[0] &= 0xf;\r\nwbits = s->state;\r\nwbits &= ~data[0];\r\nwbits |= data[0] & data[1];\r\ns->state = wbits;\r\ndata[1] = wbits;\r\noutb(s->state, dev->iobase + DAS16_DIO);\r\nreturn 2;\r\n}\r\nstatic int das16_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i;\r\nint lsb, msb;\r\nint chan;\r\nchan = CR_CHAN(insn->chanspec);\r\nfor (i = 0; i < insn->n; i++) {\r\nif (thisboard->ao_nbits == 12) {\r\nlsb = (data[i] << 4) & 0xff;\r\nmsb = (data[i] >> 4) & 0xff;\r\n} else {\r\nlsb = data[i] & 0xff;\r\nmsb = (data[i] >> 8) & 0xff;\r\n}\r\noutb(lsb, dev->iobase + DAS16_AO_LSB(chan));\r\noutb(msb, dev->iobase + DAS16_AO_MSB(chan));\r\n}\r\nreturn i;\r\n}\r\nstatic irqreturn_t das16_dma_interrupt(int irq, void *d)\r\n{\r\nint status;\r\nstruct comedi_device *dev = d;\r\nstatus = inb(dev->iobase + DAS16_STATUS);\r\nif ((status & DAS16_INT) == 0) {\r\nDEBUG_PRINT("spurious interrupt\n");\r\nreturn IRQ_NONE;\r\n}\r\noutb(0x00, dev->iobase + DAS16_STATUS);\r\ndas16_interrupt(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void das16_timer_interrupt(unsigned long arg)\r\n{\r\nstruct comedi_device *dev = (struct comedi_device *)arg;\r\ndas16_interrupt(dev);\r\nif (devpriv->timer_running)\r\nmod_timer(&devpriv->timer, jiffies + timer_period());\r\n}\r\nstatic int disable_dma_on_even(struct comedi_device *dev)\r\n{\r\nint residue;\r\nint i;\r\nstatic const int disable_limit = 100;\r\nstatic const int enable_timeout = 100;\r\ndisable_dma(devpriv->dma_chan);\r\nresidue = get_dma_residue(devpriv->dma_chan);\r\nfor (i = 0; i < disable_limit && (residue % 2); ++i) {\r\nint j;\r\nenable_dma(devpriv->dma_chan);\r\nfor (j = 0; j < enable_timeout; ++j) {\r\nint new_residue;\r\nudelay(2);\r\nnew_residue = get_dma_residue(devpriv->dma_chan);\r\nif (new_residue != residue)\r\nbreak;\r\n}\r\ndisable_dma(devpriv->dma_chan);\r\nresidue = get_dma_residue(devpriv->dma_chan);\r\n}\r\nif (i == disable_limit) {\r\ncomedi_error(dev, "failed to get an even dma transfer, "\r\n"could be trouble.");\r\n}\r\nreturn residue;\r\n}\r\nstatic void das16_interrupt(struct comedi_device *dev)\r\n{\r\nunsigned long dma_flags, spin_flags;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async;\r\nstruct comedi_cmd *cmd;\r\nint num_bytes, residue;\r\nint buffer_index;\r\nif (dev->attached == 0) {\r\ncomedi_error(dev, "premature interrupt");\r\nreturn;\r\n}\r\nasync = s->async;\r\ncmd = &async->cmd;\r\nif (devpriv->dma_chan == 0) {\r\ncomedi_error(dev, "interrupt with no dma channel?");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&dev->spinlock, spin_flags);\r\nif ((devpriv->control_state & DMA_ENABLE) == 0) {\r\nspin_unlock_irqrestore(&dev->spinlock, spin_flags);\r\nDEBUG_PRINT("interrupt while dma disabled?\n");\r\nreturn;\r\n}\r\ndma_flags = claim_dma_lock();\r\nclear_dma_ff(devpriv->dma_chan);\r\nresidue = disable_dma_on_even(dev);\r\nif (residue > devpriv->dma_transfer_size) {\r\ncomedi_error(dev, "residue > transfer size!\n");\r\nasync->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;\r\nnum_bytes = 0;\r\n} else\r\nnum_bytes = devpriv->dma_transfer_size - residue;\r\nif (cmd->stop_src == TRIG_COUNT &&\r\nnum_bytes >= devpriv->adc_byte_count) {\r\nnum_bytes = devpriv->adc_byte_count;\r\nasync->events |= COMEDI_CB_EOA;\r\n}\r\nbuffer_index = devpriv->current_buffer;\r\ndevpriv->current_buffer = (devpriv->current_buffer + 1) % 2;\r\ndevpriv->adc_byte_count -= num_bytes;\r\nif (cmd->stop_src == TRIG_COUNT && devpriv->timer_mode == 0 &&\r\ndevpriv->dma_transfer_size > devpriv->adc_byte_count)\r\ndevpriv->dma_transfer_size = devpriv->adc_byte_count;\r\nif ((async->events & COMEDI_CB_EOA) == 0) {\r\nset_dma_addr(devpriv->dma_chan,\r\ndevpriv->dma_buffer_addr[devpriv->current_buffer]);\r\nset_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);\r\nenable_dma(devpriv->dma_chan);\r\nif (thisboard->size > 0x400 && devpriv->timer_mode == 0)\r\noutb(0x00, dev->iobase + DAS1600_CONV);\r\n}\r\nrelease_dma_lock(dma_flags);\r\nspin_unlock_irqrestore(&dev->spinlock, spin_flags);\r\ncfc_write_array_to_buffer(s,\r\ndevpriv->dma_buffer[buffer_index], num_bytes);\r\ncfc_handle_events(dev, s);\r\n}\r\nstatic unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,\r\nint rounding_flags)\r\n{\r\ni8253_cascade_ns_to_timer_2div(devpriv->clockbase, &(devpriv->divisor1),\r\n&(devpriv->divisor2), &ns,\r\nrounding_flags & TRIG_ROUND_MASK);\r\ni8254_load(dev->iobase + DAS16_CNTR0_DATA, 0, 1, devpriv->divisor1, 2);\r\ni8254_load(dev->iobase + DAS16_CNTR0_DATA, 0, 2, devpriv->divisor2, 2);\r\nreturn ns;\r\n}\r\nstatic void reg_dump(struct comedi_device *dev)\r\n{\r\nDEBUG_PRINT("********DAS1600 REGISTER DUMP********\n");\r\nDEBUG_PRINT("DAS16_MUX: %x\n", inb(dev->iobase + DAS16_MUX));\r\nDEBUG_PRINT("DAS16_DIO: %x\n", inb(dev->iobase + DAS16_DIO));\r\nDEBUG_PRINT("DAS16_STATUS: %x\n", inb(dev->iobase + DAS16_STATUS));\r\nDEBUG_PRINT("DAS16_CONTROL: %x\n", inb(dev->iobase + DAS16_CONTROL));\r\nDEBUG_PRINT("DAS16_PACER: %x\n", inb(dev->iobase + DAS16_PACER));\r\nDEBUG_PRINT("DAS16_GAIN: %x\n", inb(dev->iobase + DAS16_GAIN));\r\nDEBUG_PRINT("DAS16_CNTR_CONTROL: %x\n",\r\ninb(dev->iobase + DAS16_CNTR_CONTROL));\r\nDEBUG_PRINT("DAS1600_CONV: %x\n", inb(dev->iobase + DAS1600_CONV));\r\nDEBUG_PRINT("DAS1600_BURST: %x\n", inb(dev->iobase + DAS1600_BURST));\r\nDEBUG_PRINT("DAS1600_ENABLE: %x\n", inb(dev->iobase + DAS1600_ENABLE));\r\nDEBUG_PRINT("DAS1600_STATUS_B: %x\n",\r\ninb(dev->iobase + DAS1600_STATUS_B));\r\n}\r\nstatic int das16_probe(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nint status;\r\nint diobits;\r\nstatus = inb(dev->iobase + DAS16_STATUS);\r\nif ((status & UNIPOLAR))\r\ndevpriv->ai_unipolar = 1;\r\nelse\r\ndevpriv->ai_unipolar = 0;\r\nif ((status & DAS16_MUXBIT))\r\ndevpriv->ai_singleended = 1;\r\nelse\r\ndevpriv->ai_singleended = 0;\r\ndiobits = inb(dev->iobase + DAS16_DIO) & 0xf0;\r\nprintk(KERN_INFO " id bits are 0x%02x\n", diobits);\r\nif (thisboard->id != diobits) {\r\nprintk(KERN_INFO " requested board's id bits are 0x%x (ignore)\n",\r\nthisboard->id);\r\n}\r\nreturn 0;\r\n}\r\nstatic int das1600_mode_detect(struct comedi_device *dev)\r\n{\r\nint status = 0;\r\nstatus = inb(dev->iobase + DAS1600_STATUS_B);\r\nif (status & DAS1600_CLK_10MHZ) {\r\ndevpriv->clockbase = 100;\r\nprintk(KERN_INFO " 10MHz pacer clock\n");\r\n} else {\r\ndevpriv->clockbase = 1000;\r\nprintk(KERN_INFO " 1MHz pacer clock\n");\r\n}\r\nreg_dump(dev);\r\nreturn 0;\r\n}\r\nstatic int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nunsigned int irq;\r\nunsigned long iobase;\r\nunsigned int dma_chan;\r\nint timer_mode;\r\nunsigned long flags;\r\nstruct comedi_krange *user_ai_range, *user_ao_range;\r\niobase = it->options[0];\r\n#if 0\r\nirq = it->options[1];\r\ntimer_mode = it->options[8];\r\n#endif\r\nirq = 0;\r\ntimer_mode = 1;\r\nif (timer_mode)\r\nirq = 0;\r\nprintk(KERN_INFO "comedi%d: das16:", dev->minor);\r\nif (it->options[3]) {\r\nif (it->options[3] != 0 &&\r\nit->options[3] != 1 && it->options[3] != 10) {\r\nprintk\r\n("\n Invalid option. Master clock must be set "\r\n"to 1 or 10 (MHz)\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nret = alloc_private(dev, sizeof(struct das16_private_struct));\r\nif (ret < 0)\r\nreturn ret;\r\nif (thisboard->size < 0x400) {\r\nprintk(" 0x%04lx-0x%04lx\n", iobase, iobase + thisboard->size);\r\nif (!request_region(iobase, thisboard->size, "das16")) {\r\nprintk(KERN_ERR " I/O port conflict\n");\r\nreturn -EIO;\r\n}\r\n} else {\r\nprintk(KERN_INFO " 0x%04lx-0x%04lx 0x%04lx-0x%04lx\n",\r\niobase, iobase + 0x0f,\r\niobase + 0x400,\r\niobase + 0x400 + (thisboard->size & 0x3ff));\r\nif (!request_region(iobase, 0x10, "das16")) {\r\nprintk(KERN_ERR " I/O port conflict: 0x%04lx-0x%04lx\n",\r\niobase, iobase + 0x0f);\r\nreturn -EIO;\r\n}\r\nif (!request_region(iobase + 0x400, thisboard->size & 0x3ff,\r\n"das16")) {\r\nrelease_region(iobase, 0x10);\r\nprintk(KERN_ERR " I/O port conflict: 0x%04lx-0x%04lx\n",\r\niobase + 0x400,\r\niobase + 0x400 + (thisboard->size & 0x3ff));\r\nreturn -EIO;\r\n}\r\n}\r\ndev->iobase = iobase;\r\nif (das16_probe(dev, it)) {\r\nprintk(KERN_ERR " id bits do not match selected board, aborting\n");\r\nreturn -EINVAL;\r\n}\r\ndev->board_name = thisboard->name;\r\nif (thisboard->size < 0x400) {\r\nif (it->options[3])\r\ndevpriv->clockbase = 1000 / it->options[3];\r\nelse\r\ndevpriv->clockbase = 1000;\r\n} else {\r\ndas1600_mode_detect(dev);\r\n}\r\nif (irq > 1 && irq < 8) {\r\nret = request_irq(irq, das16_dma_interrupt, 0, "das16", dev);\r\nif (ret < 0)\r\nreturn ret;\r\ndev->irq = irq;\r\nprintk(KERN_INFO " ( irq = %u )", irq);\r\n} else if (irq == 0) {\r\nprintk(" ( no irq )");\r\n} else {\r\nprintk(" invalid irq\n");\r\nreturn -EINVAL;\r\n}\r\ndma_chan = it->options[2];\r\nif (dma_chan == 1 || dma_chan == 3) {\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\ndevpriv->dma_buffer[i] = pci_alloc_consistent(\r\nNULL, DAS16_DMA_SIZE,\r\n&devpriv->dma_buffer_addr[i]);\r\nif (devpriv->dma_buffer[i] == NULL)\r\nreturn -ENOMEM;\r\n}\r\nif (request_dma(dma_chan, "das16")) {\r\nprintk(KERN_ERR " failed to allocate dma channel %i\n",\r\ndma_chan);\r\nreturn -EINVAL;\r\n}\r\ndevpriv->dma_chan = dma_chan;\r\nflags = claim_dma_lock();\r\ndisable_dma(devpriv->dma_chan);\r\nset_dma_mode(devpriv->dma_chan, DMA_MODE_READ);\r\nrelease_dma_lock(flags);\r\nprintk(KERN_INFO " ( dma = %u)\n", dma_chan);\r\n} else if (dma_chan == 0) {\r\nprintk(KERN_INFO " ( no dma )\n");\r\n} else {\r\nprintk(KERN_ERR " invalid dma channel\n");\r\nreturn -EINVAL;\r\n}\r\nif (thisboard->ai_pg == das16_pg_none &&\r\n(it->options[4] || it->options[5])) {\r\ndevpriv->user_ai_range_table =\r\nkmalloc(sizeof(struct comedi_lrange) +\r\nsizeof(struct comedi_krange), GFP_KERNEL);\r\ndevpriv->user_ai_range_table->length = 1;\r\nuser_ai_range = devpriv->user_ai_range_table->range;\r\nuser_ai_range->min = it->options[4];\r\nuser_ai_range->max = it->options[5];\r\nuser_ai_range->flags = UNIT_volt;\r\n}\r\nif (it->options[6] || it->options[7]) {\r\ndevpriv->user_ao_range_table =\r\nkmalloc(sizeof(struct comedi_lrange) +\r\nsizeof(struct comedi_krange), GFP_KERNEL);\r\ndevpriv->user_ao_range_table->length = 1;\r\nuser_ao_range = devpriv->user_ao_range_table->range;\r\nuser_ao_range->min = it->options[6];\r\nuser_ao_range->max = it->options[7];\r\nuser_ao_range->flags = UNIT_volt;\r\n}\r\nif (timer_mode) {\r\ninit_timer(&(devpriv->timer));\r\ndevpriv->timer.function = das16_timer_interrupt;\r\ndevpriv->timer.data = (unsigned long)dev;\r\n}\r\ndevpriv->timer_mode = timer_mode ? 1 : 0;\r\nret = alloc_subdevices(dev, 5);\r\nif (ret < 0)\r\nreturn ret;\r\ns = dev->subdevices + 0;\r\ndev->read_subdev = s;\r\nif (thisboard->ai) {\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_CMD_READ;\r\nif (devpriv->ai_singleended) {\r\ns->n_chan = 16;\r\ns->len_chanlist = 16;\r\ns->subdev_flags |= SDF_GROUND;\r\n} else {\r\ns->n_chan = 8;\r\ns->len_chanlist = 8;\r\ns->subdev_flags |= SDF_DIFF;\r\n}\r\ns->maxdata = (1 << thisboard->ai_nbits) - 1;\r\nif (devpriv->user_ai_range_table) {\r\ns->range_table = devpriv->user_ai_range_table;\r\n} else if (devpriv->ai_unipolar) {\r\ns->range_table = das16_ai_uni_lranges[thisboard->ai_pg];\r\n} else {\r\ns->range_table = das16_ai_bip_lranges[thisboard->ai_pg];\r\n}\r\ns->insn_read = thisboard->ai;\r\ns->do_cmdtest = das16_cmd_test;\r\ns->do_cmd = das16_cmd_exec;\r\ns->cancel = das16_cancel;\r\ns->munge = das16_ai_munge;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = dev->subdevices + 1;\r\nif (thisboard->ao) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 2;\r\ns->maxdata = (1 << thisboard->ao_nbits) - 1;\r\nif (devpriv->user_ao_range_table)\r\ns->range_table = devpriv->user_ao_range_table;\r\nelse\r\ns->range_table = &range_unknown;\r\ns->insn_write = thisboard->ao;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = dev->subdevices + 2;\r\nif (thisboard->di) {\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 4;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = thisboard->di;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = dev->subdevices + 3;\r\nif (thisboard->do_) {\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = 4;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = thisboard->do_;\r\noutb(s->state, dev->iobase + DAS16_DIO);\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = dev->subdevices + 4;\r\nif (thisboard->i8255_offset != 0) {\r\nsubdev_8255_init(dev, s, NULL, (dev->iobase +\r\nthisboard->i8255_offset));\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ndas16_reset(dev);\r\ndevpriv->control_state = DAS16_IRQ(dev->irq);\r\noutb(devpriv->control_state, dev->iobase + DAS16_CONTROL);\r\nif (thisboard->size > 0x400) {\r\noutb(DAS1600_ENABLE_VAL, dev->iobase + DAS1600_ENABLE);\r\noutb(0, dev->iobase + DAS1600_CONV);\r\noutb(0, dev->iobase + DAS1600_BURST);\r\n}\r\nreturn 0;\r\n}\r\nstatic int das16_detach(struct comedi_device *dev)\r\n{\r\nprintk(KERN_INFO "comedi%d: das16: remove\n", dev->minor);\r\ndas16_reset(dev);\r\nif (dev->subdevices)\r\nsubdev_8255_cleanup(dev, dev->subdevices + 4);\r\nif (devpriv) {\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nif (devpriv->dma_buffer[i])\r\npci_free_consistent(NULL, DAS16_DMA_SIZE,\r\ndevpriv->dma_buffer[i],\r\ndevpriv->\r\ndma_buffer_addr[i]);\r\n}\r\nif (devpriv->dma_chan)\r\nfree_dma(devpriv->dma_chan);\r\nkfree(devpriv->user_ai_range_table);\r\nkfree(devpriv->user_ao_range_table);\r\n}\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (dev->iobase) {\r\nif (thisboard->size < 0x400) {\r\nrelease_region(dev->iobase, thisboard->size);\r\n} else {\r\nrelease_region(dev->iobase, 0x10);\r\nrelease_region(dev->iobase + 0x400,\r\nthisboard->size & 0x3ff);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init driver_das16_init_module(void)\r\n{\r\nreturn comedi_driver_register(&driver_das16);\r\n}\r\nstatic void __exit driver_das16_cleanup_module(void)\r\n{\r\ncomedi_driver_unregister(&driver_das16);\r\n}\r\nstatic unsigned int das16_suggest_transfer_size(struct comedi_device *dev,\r\nstruct comedi_cmd cmd)\r\n{\r\nunsigned int size;\r\nunsigned int freq;\r\nif (devpriv->timer_mode)\r\nreturn DAS16_DMA_SIZE;\r\nif (cmd.convert_src == TRIG_TIMER)\r\nfreq = 1000000000 / cmd.convert_arg;\r\nelse if (cmd.scan_begin_src == TRIG_TIMER)\r\nfreq = (1000000000 / cmd.scan_begin_arg) * cmd.chanlist_len;\r\nelse\r\nfreq = 0xffffffff;\r\nif (cmd.flags & TRIG_WAKE_EOS) {\r\nsize = sample_size * cmd.chanlist_len;\r\n} else {\r\nsize = (freq / 3) * sample_size;\r\n}\r\nif (size > DAS16_DMA_SIZE)\r\nsize = DAS16_DMA_SIZE - DAS16_DMA_SIZE % sample_size;\r\nelse if (size < sample_size)\r\nsize = sample_size;\r\nif (cmd.stop_src == TRIG_COUNT && size > devpriv->adc_byte_count)\r\nsize = devpriv->adc_byte_count;\r\nreturn size;\r\n}\r\nstatic void das16_ai_munge(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, void *array,\r\nunsigned int num_bytes,\r\nunsigned int start_chan_index)\r\n{\r\nunsigned int i, num_samples = num_bytes / sizeof(short);\r\nshort *data = array;\r\nfor (i = 0; i < num_samples; i++) {\r\ndata[i] = le16_to_cpu(data[i]);\r\nif (thisboard->ai_nbits == 12)\r\ndata[i] = (data[i] >> 4) & 0xfff;\r\n}\r\n}
