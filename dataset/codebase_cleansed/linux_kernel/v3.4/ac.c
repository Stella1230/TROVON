static int acpi_ac_get_state(struct acpi_ac *ac)\r\n{\r\nacpi_status status = AE_OK;\r\nif (!ac)\r\nreturn -EINVAL;\r\nstatus = acpi_evaluate_integer(ac->device->handle, "_PSR", NULL, &ac->state);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Error reading AC Adapter state"));\r\nac->state = ACPI_AC_STATUS_UNKNOWN;\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_ac_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct acpi_ac *ac = to_acpi_ac(psy);\r\nif (!ac)\r\nreturn -ENODEV;\r\nif (acpi_ac_get_state(ac))\r\nreturn -ENODEV;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = ac->state;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_ac_seq_show(struct seq_file *seq, void *offset)\r\n{\r\nstruct acpi_ac *ac = seq->private;\r\nif (!ac)\r\nreturn 0;\r\nif (acpi_ac_get_state(ac)) {\r\nseq_puts(seq, "ERROR: Unable to read AC Adapter state\n");\r\nreturn 0;\r\n}\r\nseq_puts(seq, "state: ");\r\nswitch (ac->state) {\r\ncase ACPI_AC_STATUS_OFFLINE:\r\nseq_puts(seq, "off-line\n");\r\nbreak;\r\ncase ACPI_AC_STATUS_ONLINE:\r\nseq_puts(seq, "on-line\n");\r\nbreak;\r\ndefault:\r\nseq_puts(seq, "unknown\n");\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_ac_open_fs(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, acpi_ac_seq_show, PDE(inode)->data);\r\n}\r\nstatic int acpi_ac_add_fs(struct acpi_device *device)\r\n{\r\nstruct proc_dir_entry *entry = NULL;\r\nprintk(KERN_WARNING PREFIX "Deprecated procfs I/F for AC is loaded,"\r\n" please retry with CONFIG_ACPI_PROCFS_POWER cleared\n");\r\nif (!acpi_device_dir(device)) {\r\nacpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),\r\nacpi_ac_dir);\r\nif (!acpi_device_dir(device))\r\nreturn -ENODEV;\r\n}\r\nentry = proc_create_data(ACPI_AC_FILE_STATE,\r\nS_IRUGO, acpi_device_dir(device),\r\n&acpi_ac_fops, acpi_driver_data(device));\r\nif (!entry)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int acpi_ac_remove_fs(struct acpi_device *device)\r\n{\r\nif (acpi_device_dir(device)) {\r\nremove_proc_entry(ACPI_AC_FILE_STATE, acpi_device_dir(device));\r\nremove_proc_entry(acpi_device_bid(device), acpi_ac_dir);\r\nacpi_device_dir(device) = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void acpi_ac_notify(struct acpi_device *device, u32 event)\r\n{\r\nstruct acpi_ac *ac = acpi_driver_data(device);\r\nif (!ac)\r\nreturn;\r\nswitch (event) {\r\ndefault:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Unsupported event [0x%x]\n", event));\r\ncase ACPI_AC_NOTIFY_STATUS:\r\ncase ACPI_NOTIFY_BUS_CHECK:\r\ncase ACPI_NOTIFY_DEVICE_CHECK:\r\nacpi_ac_get_state(ac);\r\nacpi_bus_generate_proc_event(device, event, (u32) ac->state);\r\nacpi_bus_generate_netlink_event(device->pnp.device_class,\r\ndev_name(&device->dev), event,\r\n(u32) ac->state);\r\nacpi_notifier_call_chain(device, event, (u32) ac->state);\r\nkobject_uevent(&ac->charger.dev->kobj, KOBJ_CHANGE);\r\n}\r\nreturn;\r\n}\r\nstatic int acpi_ac_add(struct acpi_device *device)\r\n{\r\nint result = 0;\r\nstruct acpi_ac *ac = NULL;\r\nif (!device)\r\nreturn -EINVAL;\r\nac = kzalloc(sizeof(struct acpi_ac), GFP_KERNEL);\r\nif (!ac)\r\nreturn -ENOMEM;\r\nac->device = device;\r\nstrcpy(acpi_device_name(device), ACPI_AC_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_AC_CLASS);\r\ndevice->driver_data = ac;\r\nresult = acpi_ac_get_state(ac);\r\nif (result)\r\ngoto end;\r\n#ifdef CONFIG_ACPI_PROCFS_POWER\r\nresult = acpi_ac_add_fs(device);\r\n#endif\r\nif (result)\r\ngoto end;\r\nac->charger.name = acpi_device_bid(device);\r\nac->charger.type = POWER_SUPPLY_TYPE_MAINS;\r\nac->charger.properties = ac_props;\r\nac->charger.num_properties = ARRAY_SIZE(ac_props);\r\nac->charger.get_property = get_ac_property;\r\npower_supply_register(&ac->device->dev, &ac->charger);\r\nprintk(KERN_INFO PREFIX "%s [%s] (%s)\n",\r\nacpi_device_name(device), acpi_device_bid(device),\r\nac->state ? "on-line" : "off-line");\r\nend:\r\nif (result) {\r\n#ifdef CONFIG_ACPI_PROCFS_POWER\r\nacpi_ac_remove_fs(device);\r\n#endif\r\nkfree(ac);\r\n}\r\nreturn result;\r\n}\r\nstatic int acpi_ac_resume(struct acpi_device *device)\r\n{\r\nstruct acpi_ac *ac;\r\nunsigned old_state;\r\nif (!device || !acpi_driver_data(device))\r\nreturn -EINVAL;\r\nac = acpi_driver_data(device);\r\nold_state = ac->state;\r\nif (acpi_ac_get_state(ac))\r\nreturn 0;\r\nif (old_state != ac->state)\r\nkobject_uevent(&ac->charger.dev->kobj, KOBJ_CHANGE);\r\nreturn 0;\r\n}\r\nstatic int acpi_ac_remove(struct acpi_device *device, int type)\r\n{\r\nstruct acpi_ac *ac = NULL;\r\nif (!device || !acpi_driver_data(device))\r\nreturn -EINVAL;\r\nac = acpi_driver_data(device);\r\nif (ac->charger.dev)\r\npower_supply_unregister(&ac->charger);\r\n#ifdef CONFIG_ACPI_PROCFS_POWER\r\nacpi_ac_remove_fs(device);\r\n#endif\r\nkfree(ac);\r\nreturn 0;\r\n}\r\nstatic int __init acpi_ac_init(void)\r\n{\r\nint result;\r\nif (acpi_disabled)\r\nreturn -ENODEV;\r\n#ifdef CONFIG_ACPI_PROCFS_POWER\r\nacpi_ac_dir = acpi_lock_ac_dir();\r\nif (!acpi_ac_dir)\r\nreturn -ENODEV;\r\n#endif\r\nresult = acpi_bus_register_driver(&acpi_ac_driver);\r\nif (result < 0) {\r\n#ifdef CONFIG_ACPI_PROCFS_POWER\r\nacpi_unlock_ac_dir(acpi_ac_dir);\r\n#endif\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit acpi_ac_exit(void)\r\n{\r\nacpi_bus_unregister_driver(&acpi_ac_driver);\r\n#ifdef CONFIG_ACPI_PROCFS_POWER\r\nacpi_unlock_ac_dir(acpi_ac_dir);\r\n#endif\r\nreturn;\r\n}
