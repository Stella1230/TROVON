static int flash_list_valid(struct flash_block_list *flist)\r\n{\r\nstruct flash_block_list *f;\r\nint i;\r\nunsigned long block_size, image_size;\r\nimage_size = 0;\r\nfor (f = flist; f; f = f->next) {\r\nfor (i = 0; i < f->num_blocks; i++) {\r\nif (f->blocks[i].data == NULL) {\r\nreturn FLASH_IMG_NULL_DATA;\r\n}\r\nblock_size = f->blocks[i].length;\r\nif (block_size <= 0 || block_size > RTAS_BLK_SIZE) {\r\nreturn FLASH_IMG_BAD_LEN;\r\n}\r\nimage_size += block_size;\r\n}\r\n}\r\nif (image_size < (256 << 10)) {\r\nif (image_size < 2)\r\nreturn FLASH_NO_OP;\r\n}\r\nprintk(KERN_INFO "FLASH: flash image with %ld bytes stored for hardware flash on reboot\n", image_size);\r\nreturn FLASH_IMG_READY;\r\n}\r\nstatic void free_flash_list(struct flash_block_list *f)\r\n{\r\nstruct flash_block_list *next;\r\nint i;\r\nwhile (f) {\r\nfor (i = 0; i < f->num_blocks; i++)\r\nkmem_cache_free(flash_block_cache, f->blocks[i].data);\r\nnext = f->next;\r\nkmem_cache_free(flash_block_cache, f);\r\nf = next;\r\n}\r\n}\r\nstatic int rtas_flash_release(struct inode *inode, struct file *file)\r\n{\r\nstruct proc_dir_entry *dp = PDE(file->f_path.dentry->d_inode);\r\nstruct rtas_update_flash_t *uf;\r\nuf = (struct rtas_update_flash_t *) dp->data;\r\nif (uf->flist) {\r\nif (rtas_firmware_flash_list) {\r\nfree_flash_list(rtas_firmware_flash_list);\r\nrtas_firmware_flash_list = NULL;\r\n}\r\nif (uf->status != FLASH_AUTH)\r\nuf->status = flash_list_valid(uf->flist);\r\nif (uf->status == FLASH_IMG_READY)\r\nrtas_firmware_flash_list = uf->flist;\r\nelse\r\nfree_flash_list(uf->flist);\r\nuf->flist = NULL;\r\n}\r\natomic_dec(&dp->count);\r\nreturn 0;\r\n}\r\nstatic void get_flash_status_msg(int status, char *buf)\r\n{\r\nchar *msg;\r\nswitch (status) {\r\ncase FLASH_AUTH:\r\nmsg = "error: this partition does not have service authority\n";\r\nbreak;\r\ncase FLASH_NO_OP:\r\nmsg = "info: no firmware image for flash\n";\r\nbreak;\r\ncase FLASH_IMG_SHORT:\r\nmsg = "error: flash image short\n";\r\nbreak;\r\ncase FLASH_IMG_BAD_LEN:\r\nmsg = "error: internal error bad length\n";\r\nbreak;\r\ncase FLASH_IMG_NULL_DATA:\r\nmsg = "error: internal error null data\n";\r\nbreak;\r\ncase FLASH_IMG_READY:\r\nmsg = "ready: firmware image ready for flash on reboot\n";\r\nbreak;\r\ndefault:\r\nsprintf(buf, "error: unexpected status value %d\n", status);\r\nreturn;\r\n}\r\nstrcpy(buf, msg);\r\n}\r\nstatic ssize_t rtas_flash_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct proc_dir_entry *dp = PDE(file->f_path.dentry->d_inode);\r\nstruct rtas_update_flash_t *uf;\r\nchar msg[RTAS_MSG_MAXLEN];\r\nuf = dp->data;\r\nif (!strcmp(dp->name, FIRMWARE_FLASH_NAME)) {\r\nget_flash_status_msg(uf->status, msg);\r\n} else {\r\nsprintf(msg, "%d\n", uf->status);\r\n}\r\nreturn simple_read_from_buffer(buf, count, ppos, msg, strlen(msg));\r\n}\r\nvoid rtas_block_ctor(void *ptr)\r\n{\r\nmemset(ptr, 0, RTAS_BLK_SIZE);\r\n}\r\nstatic ssize_t rtas_flash_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct proc_dir_entry *dp = PDE(file->f_path.dentry->d_inode);\r\nstruct rtas_update_flash_t *uf;\r\nchar *p;\r\nint next_free;\r\nstruct flash_block_list *fl;\r\nuf = (struct rtas_update_flash_t *) dp->data;\r\nif (uf->status == FLASH_AUTH || count == 0)\r\nreturn count;\r\nif (uf->flist == NULL) {\r\nuf->flist = kmem_cache_alloc(flash_block_cache, GFP_KERNEL);\r\nif (!uf->flist)\r\nreturn -ENOMEM;\r\n}\r\nfl = uf->flist;\r\nwhile (fl->next)\r\nfl = fl->next;\r\nnext_free = fl->num_blocks;\r\nif (next_free == FLASH_BLOCKS_PER_NODE) {\r\nfl->next = kmem_cache_alloc(flash_block_cache, GFP_KERNEL);\r\nif (!fl->next)\r\nreturn -ENOMEM;\r\nfl = fl->next;\r\nnext_free = 0;\r\n}\r\nif (count > RTAS_BLK_SIZE)\r\ncount = RTAS_BLK_SIZE;\r\np = kmem_cache_alloc(flash_block_cache, GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\nif(copy_from_user(p, buffer, count)) {\r\nkmem_cache_free(flash_block_cache, p);\r\nreturn -EFAULT;\r\n}\r\nfl->blocks[next_free].data = p;\r\nfl->blocks[next_free].length = count;\r\nfl->num_blocks++;\r\nreturn count;\r\n}\r\nstatic int rtas_excl_open(struct inode *inode, struct file *file)\r\n{\r\nstruct proc_dir_entry *dp = PDE(inode);\r\nspin_lock(&flash_file_open_lock);\r\nif (atomic_read(&dp->count) > 2) {\r\nspin_unlock(&flash_file_open_lock);\r\nreturn -EBUSY;\r\n}\r\natomic_inc(&dp->count);\r\nspin_unlock(&flash_file_open_lock);\r\nreturn 0;\r\n}\r\nstatic int rtas_excl_release(struct inode *inode, struct file *file)\r\n{\r\nstruct proc_dir_entry *dp = PDE(inode);\r\natomic_dec(&dp->count);\r\nreturn 0;\r\n}\r\nstatic void manage_flash(struct rtas_manage_flash_t *args_buf)\r\n{\r\ns32 rc;\r\ndo {\r\nrc = rtas_call(rtas_token("ibm,manage-flash-image"), 1,\r\n1, NULL, args_buf->op);\r\n} while (rtas_busy_delay(rc));\r\nargs_buf->status = rc;\r\n}\r\nstatic ssize_t manage_flash_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct proc_dir_entry *dp = PDE(file->f_path.dentry->d_inode);\r\nstruct rtas_manage_flash_t *args_buf;\r\nchar msg[RTAS_MSG_MAXLEN];\r\nint msglen;\r\nargs_buf = dp->data;\r\nif (args_buf == NULL)\r\nreturn 0;\r\nmsglen = sprintf(msg, "%d\n", args_buf->status);\r\nreturn simple_read_from_buffer(buf, count, ppos, msg, msglen);\r\n}\r\nstatic ssize_t manage_flash_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct proc_dir_entry *dp = PDE(file->f_path.dentry->d_inode);\r\nstruct rtas_manage_flash_t *args_buf;\r\nconst char reject_str[] = "0";\r\nconst char commit_str[] = "1";\r\nchar stkbuf[10];\r\nint op;\r\nargs_buf = (struct rtas_manage_flash_t *) dp->data;\r\nif ((args_buf->status == MANAGE_AUTH) || (count == 0))\r\nreturn count;\r\nop = -1;\r\nif (buf) {\r\nif (count > 9) count = 9;\r\nif (copy_from_user (stkbuf, buf, count)) {\r\nreturn -EFAULT;\r\n}\r\nif (strncmp(stkbuf, reject_str, strlen(reject_str)) == 0)\r\nop = RTAS_REJECT_TMP_IMG;\r\nelse if (strncmp(stkbuf, commit_str, strlen(commit_str)) == 0)\r\nop = RTAS_COMMIT_TMP_IMG;\r\n}\r\nif (op == -1)\r\nreturn -EINVAL;\r\nargs_buf->op = op;\r\nmanage_flash(args_buf);\r\nreturn count;\r\n}\r\nstatic void validate_flash(struct rtas_validate_flash_t *args_buf)\r\n{\r\nint token = rtas_token("ibm,validate-flash-image");\r\nint update_results;\r\ns32 rc;\r\nrc = 0;\r\ndo {\r\nspin_lock(&rtas_data_buf_lock);\r\nmemcpy(rtas_data_buf, args_buf->buf, VALIDATE_BUF_SIZE);\r\nrc = rtas_call(token, 2, 2, &update_results,\r\n(u32) __pa(rtas_data_buf), args_buf->buf_size);\r\nmemcpy(args_buf->buf, rtas_data_buf, VALIDATE_BUF_SIZE);\r\nspin_unlock(&rtas_data_buf_lock);\r\n} while (rtas_busy_delay(rc));\r\nargs_buf->status = rc;\r\nargs_buf->update_results = update_results;\r\n}\r\nstatic int get_validate_flash_msg(struct rtas_validate_flash_t *args_buf,\r\nchar *msg)\r\n{\r\nint n;\r\nif (args_buf->status >= VALIDATE_TMP_UPDATE) {\r\nn = sprintf(msg, "%d\n", args_buf->update_results);\r\nif ((args_buf->update_results >= VALIDATE_CUR_UNKNOWN) ||\r\n(args_buf->update_results == VALIDATE_TMP_UPDATE))\r\nn += sprintf(msg + n, "%s\n", args_buf->buf);\r\n} else {\r\nn = sprintf(msg, "%d\n", args_buf->status);\r\n}\r\nreturn n;\r\n}\r\nstatic ssize_t validate_flash_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct proc_dir_entry *dp = PDE(file->f_path.dentry->d_inode);\r\nstruct rtas_validate_flash_t *args_buf;\r\nchar msg[RTAS_MSG_MAXLEN];\r\nint msglen;\r\nargs_buf = dp->data;\r\nmsglen = get_validate_flash_msg(args_buf, msg);\r\nreturn simple_read_from_buffer(buf, count, ppos, msg, msglen);\r\n}\r\nstatic ssize_t validate_flash_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct proc_dir_entry *dp = PDE(file->f_path.dentry->d_inode);\r\nstruct rtas_validate_flash_t *args_buf;\r\nint rc;\r\nargs_buf = (struct rtas_validate_flash_t *) dp->data;\r\nif (dp->data == NULL) {\r\ndp->data = kmalloc(sizeof(struct rtas_validate_flash_t),\r\nGFP_KERNEL);\r\nif (dp->data == NULL)\r\nreturn -ENOMEM;\r\n}\r\nif ((*off >= VALIDATE_BUF_SIZE) ||\r\n(args_buf->status == VALIDATE_AUTH)) {\r\n*off += count;\r\nreturn count;\r\n}\r\nif (*off + count >= VALIDATE_BUF_SIZE) {\r\ncount = VALIDATE_BUF_SIZE - *off;\r\nargs_buf->status = VALIDATE_READY;\r\n} else {\r\nargs_buf->status = VALIDATE_INCOMPLETE;\r\n}\r\nif (!access_ok(VERIFY_READ, buf, count)) {\r\nrc = -EFAULT;\r\ngoto done;\r\n}\r\nif (copy_from_user(args_buf->buf + *off, buf, count)) {\r\nrc = -EFAULT;\r\ngoto done;\r\n}\r\n*off += count;\r\nrc = count;\r\ndone:\r\nif (rc < 0) {\r\nkfree(dp->data);\r\ndp->data = NULL;\r\n}\r\nreturn rc;\r\n}\r\nstatic int validate_flash_release(struct inode *inode, struct file *file)\r\n{\r\nstruct proc_dir_entry *dp = PDE(file->f_path.dentry->d_inode);\r\nstruct rtas_validate_flash_t *args_buf;\r\nargs_buf = (struct rtas_validate_flash_t *) dp->data;\r\nif (args_buf->status == VALIDATE_READY) {\r\nargs_buf->buf_size = VALIDATE_BUF_SIZE;\r\nvalidate_flash(args_buf);\r\n}\r\natomic_dec(&dp->count);\r\nreturn 0;\r\n}\r\nstatic void rtas_flash_firmware(int reboot_type)\r\n{\r\nunsigned long image_size;\r\nstruct flash_block_list *f, *next, *flist;\r\nunsigned long rtas_block_list;\r\nint i, status, update_token;\r\nif (rtas_firmware_flash_list == NULL)\r\nreturn;\r\nif (reboot_type != SYS_RESTART) {\r\nprintk(KERN_ALERT "FLASH: firmware flash requires a reboot\n");\r\nprintk(KERN_ALERT "FLASH: the firmware image will NOT be flashed\n");\r\nreturn;\r\n}\r\nupdate_token = rtas_token("ibm,update-flash-64-and-reboot");\r\nif (update_token == RTAS_UNKNOWN_SERVICE) {\r\nprintk(KERN_ALERT "FLASH: ibm,update-flash-64-and-reboot "\r\n"is not available -- not a service partition?\n");\r\nprintk(KERN_ALERT "FLASH: firmware will not be flashed\n");\r\nreturn;\r\n}\r\nrtas_cancel_event_scan();\r\nspin_lock(&rtas_data_buf_lock);\r\nflist = (struct flash_block_list *)&rtas_data_buf[0];\r\nflist->num_blocks = 0;\r\nflist->next = rtas_firmware_flash_list;\r\nrtas_block_list = virt_to_abs(flist);\r\nif (rtas_block_list >= 4UL*1024*1024*1024) {\r\nprintk(KERN_ALERT "FLASH: kernel bug...flash list header addr above 4GB\n");\r\nspin_unlock(&rtas_data_buf_lock);\r\nreturn;\r\n}\r\nprintk(KERN_ALERT "FLASH: preparing saved firmware image for flash\n");\r\nrtas_firmware_flash_list = NULL;\r\nimage_size = 0;\r\nfor (f = flist; f; f = next) {\r\nfor (i = 0; i < f->num_blocks; i++) {\r\nf->blocks[i].data = (char *)virt_to_abs(f->blocks[i].data);\r\nimage_size += f->blocks[i].length;\r\n}\r\nnext = f->next;\r\nif (f->next)\r\nf->next = (struct flash_block_list *)virt_to_abs(f->next);\r\nelse\r\nf->next = NULL;\r\nf->num_blocks = (FLASH_BLOCK_LIST_VERSION << 56) | ((f->num_blocks+1)*16);\r\n}\r\nprintk(KERN_ALERT "FLASH: flash image is %ld bytes\n", image_size);\r\nprintk(KERN_ALERT "FLASH: performing flash and reboot\n");\r\nrtas_progress("Flashing \n", 0x0);\r\nrtas_progress("Please Wait... ", 0x0);\r\nprintk(KERN_ALERT "FLASH: this will take several minutes. Do not power off!\n");\r\nstatus = rtas_call(update_token, 1, 1, NULL, rtas_block_list);\r\nswitch (status) {\r\ncase 0:\r\nprintk(KERN_ALERT "FLASH: success\n");\r\nbreak;\r\ncase -1:\r\nprintk(KERN_ALERT "FLASH: hardware error. Firmware may not be not flashed\n");\r\nbreak;\r\ncase -3:\r\nprintk(KERN_ALERT "FLASH: image is corrupt or not correct for this platform. Firmware not flashed\n");\r\nbreak;\r\ncase -4:\r\nprintk(KERN_ALERT "FLASH: flash failed when partially complete. System may not reboot\n");\r\nbreak;\r\ndefault:\r\nprintk(KERN_ALERT "FLASH: unknown flash return code %d\n", status);\r\nbreak;\r\n}\r\nspin_unlock(&rtas_data_buf_lock);\r\n}\r\nstatic void remove_flash_pde(struct proc_dir_entry *dp)\r\n{\r\nif (dp) {\r\nkfree(dp->data);\r\nremove_proc_entry(dp->name, dp->parent);\r\n}\r\n}\r\nstatic int initialize_flash_pde_data(const char *rtas_call_name,\r\nsize_t buf_size,\r\nstruct proc_dir_entry *dp)\r\n{\r\nint *status;\r\nint token;\r\ndp->data = kzalloc(buf_size, GFP_KERNEL);\r\nif (dp->data == NULL) {\r\nremove_flash_pde(dp);\r\nreturn -ENOMEM;\r\n}\r\nstatus = (int *) dp->data;\r\ntoken = rtas_token(rtas_call_name);\r\nif (token == RTAS_UNKNOWN_SERVICE)\r\n*status = FLASH_AUTH;\r\nelse\r\n*status = FLASH_NO_OP;\r\nreturn 0;\r\n}\r\nstatic struct proc_dir_entry *create_flash_pde(const char *filename,\r\nconst struct file_operations *fops)\r\n{\r\nreturn proc_create(filename, S_IRUSR | S_IWUSR, NULL, fops);\r\n}\r\nstatic int __init rtas_flash_init(void)\r\n{\r\nint rc;\r\nif (rtas_token("ibm,update-flash-64-and-reboot") ==\r\nRTAS_UNKNOWN_SERVICE) {\r\nprintk(KERN_ERR "rtas_flash: no firmware flash support\n");\r\nreturn 1;\r\n}\r\nfirmware_flash_pde = create_flash_pde("powerpc/rtas/"\r\nFIRMWARE_FLASH_NAME,\r\n&rtas_flash_operations);\r\nif (firmware_flash_pde == NULL) {\r\nrc = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nrc = initialize_flash_pde_data("ibm,update-flash-64-and-reboot",\r\nsizeof(struct rtas_update_flash_t),\r\nfirmware_flash_pde);\r\nif (rc != 0)\r\ngoto cleanup;\r\nfirmware_update_pde = create_flash_pde("powerpc/rtas/"\r\nFIRMWARE_UPDATE_NAME,\r\n&rtas_flash_operations);\r\nif (firmware_update_pde == NULL) {\r\nrc = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nrc = initialize_flash_pde_data("ibm,update-flash-64-and-reboot",\r\nsizeof(struct rtas_update_flash_t),\r\nfirmware_update_pde);\r\nif (rc != 0)\r\ngoto cleanup;\r\nvalidate_pde = create_flash_pde("powerpc/rtas/" VALIDATE_FLASH_NAME,\r\n&validate_flash_operations);\r\nif (validate_pde == NULL) {\r\nrc = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nrc = initialize_flash_pde_data("ibm,validate-flash-image",\r\nsizeof(struct rtas_validate_flash_t),\r\nvalidate_pde);\r\nif (rc != 0)\r\ngoto cleanup;\r\nmanage_pde = create_flash_pde("powerpc/rtas/" MANAGE_FLASH_NAME,\r\n&manage_flash_operations);\r\nif (manage_pde == NULL) {\r\nrc = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nrc = initialize_flash_pde_data("ibm,manage-flash-image",\r\nsizeof(struct rtas_manage_flash_t),\r\nmanage_pde);\r\nif (rc != 0)\r\ngoto cleanup;\r\nrtas_flash_term_hook = rtas_flash_firmware;\r\nflash_block_cache = kmem_cache_create("rtas_flash_cache",\r\nRTAS_BLK_SIZE, RTAS_BLK_SIZE, 0,\r\nrtas_block_ctor);\r\nif (!flash_block_cache) {\r\nprintk(KERN_ERR "%s: failed to create block cache\n",\r\n__func__);\r\nrc = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nreturn 0;\r\ncleanup:\r\nremove_flash_pde(firmware_flash_pde);\r\nremove_flash_pde(firmware_update_pde);\r\nremove_flash_pde(validate_pde);\r\nremove_flash_pde(manage_pde);\r\nreturn rc;\r\n}\r\nstatic void __exit rtas_flash_cleanup(void)\r\n{\r\nrtas_flash_term_hook = NULL;\r\nif (flash_block_cache)\r\nkmem_cache_destroy(flash_block_cache);\r\nremove_flash_pde(firmware_flash_pde);\r\nremove_flash_pde(firmware_update_pde);\r\nremove_flash_pde(validate_pde);\r\nremove_flash_pde(manage_pde);\r\n}
