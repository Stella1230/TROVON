static int __init hash_setup(char *str)\r\n{\r\nif (strncmp(str, "md5", 3) == 0)\r\nima_hash = "md5";\r\nreturn 1;\r\n}\r\nstatic void ima_rdwr_violation_check(struct file *file)\r\n{\r\nstruct dentry *dentry = file->f_path.dentry;\r\nstruct inode *inode = dentry->d_inode;\r\nfmode_t mode = file->f_mode;\r\nint rc;\r\nbool send_tomtou = false, send_writers = false;\r\nif (!S_ISREG(inode->i_mode) || !ima_initialized)\r\nreturn;\r\nmutex_lock(&inode->i_mutex);\r\nif (mode & FMODE_WRITE) {\r\nif (atomic_read(&inode->i_readcount) && IS_IMA(inode))\r\nsend_tomtou = true;\r\ngoto out;\r\n}\r\nrc = ima_must_measure(inode, MAY_READ, FILE_CHECK);\r\nif (rc < 0)\r\ngoto out;\r\nif (atomic_read(&inode->i_writecount) > 0)\r\nsend_writers = true;\r\nout:\r\nmutex_unlock(&inode->i_mutex);\r\nif (send_tomtou)\r\nima_add_violation(inode, dentry->d_name.name, "invalid_pcr",\r\n"ToMToU");\r\nif (send_writers)\r\nima_add_violation(inode, dentry->d_name.name, "invalid_pcr",\r\n"open_writers");\r\n}\r\nstatic void ima_check_last_writer(struct integrity_iint_cache *iint,\r\nstruct inode *inode,\r\nstruct file *file)\r\n{\r\nfmode_t mode = file->f_mode;\r\nmutex_lock(&iint->mutex);\r\nif (mode & FMODE_WRITE &&\r\natomic_read(&inode->i_writecount) == 1 &&\r\niint->version != inode->i_version)\r\niint->flags &= ~IMA_MEASURED;\r\nmutex_unlock(&iint->mutex);\r\n}\r\nvoid ima_file_free(struct file *file)\r\n{\r\nstruct inode *inode = file->f_dentry->d_inode;\r\nstruct integrity_iint_cache *iint;\r\nif (!iint_initialized || !S_ISREG(inode->i_mode))\r\nreturn;\r\niint = integrity_iint_find(inode);\r\nif (!iint)\r\nreturn;\r\nima_check_last_writer(iint, inode, file);\r\n}\r\nstatic int process_measurement(struct file *file, const unsigned char *filename,\r\nint mask, int function)\r\n{\r\nstruct inode *inode = file->f_dentry->d_inode;\r\nstruct integrity_iint_cache *iint;\r\nint rc = 0;\r\nif (!ima_initialized || !S_ISREG(inode->i_mode))\r\nreturn 0;\r\nrc = ima_must_measure(inode, mask, function);\r\nif (rc != 0)\r\nreturn rc;\r\nretry:\r\niint = integrity_iint_find(inode);\r\nif (!iint) {\r\nrc = integrity_inode_alloc(inode);\r\nif (!rc || rc == -EEXIST)\r\ngoto retry;\r\nreturn rc;\r\n}\r\nmutex_lock(&iint->mutex);\r\nrc = iint->flags & IMA_MEASURED ? 1 : 0;\r\nif (rc != 0)\r\ngoto out;\r\nrc = ima_collect_measurement(iint, file);\r\nif (!rc)\r\nima_store_measurement(iint, file, filename);\r\nout:\r\nmutex_unlock(&iint->mutex);\r\nreturn rc;\r\n}\r\nint ima_file_mmap(struct file *file, unsigned long prot)\r\n{\r\nint rc;\r\nif (!file)\r\nreturn 0;\r\nif (prot & PROT_EXEC)\r\nrc = process_measurement(file, file->f_dentry->d_name.name,\r\nMAY_EXEC, FILE_MMAP);\r\nreturn 0;\r\n}\r\nint ima_bprm_check(struct linux_binprm *bprm)\r\n{\r\nint rc;\r\nrc = process_measurement(bprm->file, bprm->filename,\r\nMAY_EXEC, BPRM_CHECK);\r\nreturn 0;\r\n}\r\nint ima_file_check(struct file *file, int mask)\r\n{\r\nint rc;\r\nima_rdwr_violation_check(file);\r\nrc = process_measurement(file, file->f_dentry->d_name.name,\r\nmask & (MAY_READ | MAY_WRITE | MAY_EXEC),\r\nFILE_CHECK);\r\nreturn 0;\r\n}\r\nstatic int __init init_ima(void)\r\n{\r\nint error;\r\nerror = ima_init();\r\nima_initialized = 1;\r\nreturn error;\r\n}\r\nstatic void __exit cleanup_ima(void)\r\n{\r\nima_cleanup();\r\n}
