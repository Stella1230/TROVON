static inline unsigned long spi_tegra_readl(struct spi_tegra_data *tspi,\r\nunsigned long reg)\r\n{\r\nreturn readl(tspi->base + reg);\r\n}\r\nstatic inline void spi_tegra_writel(struct spi_tegra_data *tspi,\r\nunsigned long val,\r\nunsigned long reg)\r\n{\r\nwritel(val, tspi->base + reg);\r\n}\r\nstatic void spi_tegra_go(struct spi_tegra_data *tspi)\r\n{\r\nunsigned long val;\r\nwmb();\r\nval = spi_tegra_readl(tspi, SLINK_DMA_CTL);\r\nval &= ~SLINK_DMA_BLOCK_SIZE(~0) & ~SLINK_DMA_EN;\r\nval |= SLINK_DMA_BLOCK_SIZE(tspi->rx_dma_req.size / 4 - 1);\r\nspi_tegra_writel(tspi, val, SLINK_DMA_CTL);\r\ntegra_dma_enqueue_req(tspi->rx_dma, &tspi->rx_dma_req);\r\nval |= SLINK_DMA_EN;\r\nspi_tegra_writel(tspi, val, SLINK_DMA_CTL);\r\n}\r\nstatic unsigned spi_tegra_fill_tx_fifo(struct spi_tegra_data *tspi,\r\nstruct spi_transfer *t)\r\n{\r\nunsigned len = min(t->len - tspi->cur_pos, BB_LEN *\r\ntspi->cur_bytes_per_word);\r\nu8 *tx_buf = (u8 *)t->tx_buf + tspi->cur_pos;\r\nint i, j;\r\nunsigned long val;\r\nval = spi_tegra_readl(tspi, SLINK_COMMAND);\r\nval &= ~SLINK_WORD_SIZE(~0);\r\nval |= SLINK_WORD_SIZE(len / tspi->cur_bytes_per_word - 1);\r\nspi_tegra_writel(tspi, val, SLINK_COMMAND);\r\nfor (i = 0; i < len; i += tspi->cur_bytes_per_word) {\r\nval = 0;\r\nfor (j = 0; j < tspi->cur_bytes_per_word; j++)\r\nval |= tx_buf[i + j] << j * 8;\r\nspi_tegra_writel(tspi, val, SLINK_TX_FIFO);\r\n}\r\ntspi->rx_dma_req.size = len / tspi->cur_bytes_per_word * 4;\r\nreturn len;\r\n}\r\nstatic unsigned spi_tegra_drain_rx_fifo(struct spi_tegra_data *tspi,\r\nstruct spi_transfer *t)\r\n{\r\nunsigned len = tspi->cur_len;\r\nu8 *rx_buf = (u8 *)t->rx_buf + tspi->cur_pos;\r\nint i, j;\r\nunsigned long val;\r\nfor (i = 0; i < len; i += tspi->cur_bytes_per_word) {\r\nval = tspi->rx_bb[i / tspi->cur_bytes_per_word];\r\nfor (j = 0; j < tspi->cur_bytes_per_word; j++)\r\nrx_buf[i + j] = (val >> (j * 8)) & 0xff;\r\n}\r\nreturn len;\r\n}\r\nstatic void spi_tegra_start_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct spi_tegra_data *tspi = spi_master_get_devdata(spi->master);\r\nu32 speed;\r\nu8 bits_per_word;\r\nunsigned long val;\r\nspeed = t->speed_hz ? t->speed_hz : spi->max_speed_hz;\r\nbits_per_word = t->bits_per_word ? t->bits_per_word :\r\nspi->bits_per_word;\r\ntspi->cur_bytes_per_word = (bits_per_word - 1) / 8 + 1;\r\nif (speed != tspi->cur_speed)\r\nclk_set_rate(tspi->clk, speed);\r\nif (tspi->cur_speed == 0)\r\nclk_enable(tspi->clk);\r\ntspi->cur_speed = speed;\r\nval = spi_tegra_readl(tspi, SLINK_COMMAND2);\r\nval &= ~SLINK_SS_EN_CS(~0) | SLINK_RXEN | SLINK_TXEN;\r\nif (t->rx_buf)\r\nval |= SLINK_RXEN;\r\nif (t->tx_buf)\r\nval |= SLINK_TXEN;\r\nval |= SLINK_SS_EN_CS(spi->chip_select);\r\nval |= SLINK_SPIE;\r\nspi_tegra_writel(tspi, val, SLINK_COMMAND2);\r\nval = spi_tegra_readl(tspi, SLINK_COMMAND);\r\nval &= ~SLINK_BIT_LENGTH(~0);\r\nval |= SLINK_BIT_LENGTH(bits_per_word - 1);\r\nval &= ~SLINK_IDLE_SCLK_MASK & ~SLINK_CK_SDA & ~SLINK_CS_SW;\r\nif (spi->mode & SPI_CPHA)\r\nval |= SLINK_CK_SDA;\r\nif (spi->mode & SPI_CPOL)\r\nval |= SLINK_IDLE_SCLK_DRIVE_HIGH;\r\nelse\r\nval |= SLINK_IDLE_SCLK_DRIVE_LOW;\r\nval |= SLINK_M_S;\r\nspi_tegra_writel(tspi, val, SLINK_COMMAND);\r\nspi_tegra_writel(tspi, SLINK_RX_FLUSH | SLINK_TX_FLUSH, SLINK_STATUS);\r\ntspi->cur = t;\r\ntspi->cur_pos = 0;\r\ntspi->cur_len = spi_tegra_fill_tx_fifo(tspi, t);\r\nspi_tegra_go(tspi);\r\n}\r\nstatic void spi_tegra_start_message(struct spi_device *spi,\r\nstruct spi_message *m)\r\n{\r\nstruct spi_transfer *t;\r\nm->actual_length = 0;\r\nm->status = 0;\r\nt = list_first_entry(&m->transfers, struct spi_transfer, transfer_list);\r\nspi_tegra_start_transfer(spi, t);\r\n}\r\nstatic void tegra_spi_rx_dma_complete(struct tegra_dma_req *req)\r\n{\r\nstruct spi_tegra_data *tspi = req->dev;\r\nunsigned long flags;\r\nstruct spi_message *m;\r\nstruct spi_device *spi;\r\nint timeout = 0;\r\nunsigned long val;\r\nwhile (timeout++ < 1000) {\r\nif (!(spi_tegra_readl(tspi, SLINK_STATUS) & SLINK_BSY))\r\nbreak;\r\n}\r\nspin_lock_irqsave(&tspi->lock, flags);\r\nval = spi_tegra_readl(tspi, SLINK_STATUS);\r\nval |= SLINK_RDY;\r\nspi_tegra_writel(tspi, val, SLINK_STATUS);\r\nm = list_first_entry(&tspi->queue, struct spi_message, queue);\r\nif (timeout >= 1000)\r\nm->status = -EIO;\r\nspi = m->state;\r\ntspi->cur_pos += spi_tegra_drain_rx_fifo(tspi, tspi->cur);\r\nm->actual_length += tspi->cur_pos;\r\nif (tspi->cur_pos < tspi->cur->len) {\r\ntspi->cur_len = spi_tegra_fill_tx_fifo(tspi, tspi->cur);\r\nspi_tegra_go(tspi);\r\n} else if (!list_is_last(&tspi->cur->transfer_list,\r\n&m->transfers)) {\r\ntspi->cur = list_first_entry(&tspi->cur->transfer_list,\r\nstruct spi_transfer,\r\ntransfer_list);\r\nspi_tegra_start_transfer(spi, tspi->cur);\r\n} else {\r\nlist_del(&m->queue);\r\nm->complete(m->context);\r\nif (!list_empty(&tspi->queue)) {\r\nm = list_first_entry(&tspi->queue, struct spi_message,\r\nqueue);\r\nspi = m->state;\r\nspi_tegra_start_message(spi, m);\r\n} else {\r\nclk_disable(tspi->clk);\r\ntspi->cur_speed = 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&tspi->lock, flags);\r\n}\r\nstatic int spi_tegra_setup(struct spi_device *spi)\r\n{\r\nstruct spi_tegra_data *tspi = spi_master_get_devdata(spi->master);\r\nunsigned long cs_bit;\r\nunsigned long val;\r\nunsigned long flags;\r\ndev_dbg(&spi->dev, "setup %d bpw, %scpol, %scpha, %dHz\n",\r\nspi->bits_per_word,\r\nspi->mode & SPI_CPOL ? "" : "~",\r\nspi->mode & SPI_CPHA ? "" : "~",\r\nspi->max_speed_hz);\r\nswitch (spi->chip_select) {\r\ncase 0:\r\ncs_bit = SLINK_CS_POLARITY;\r\nbreak;\r\ncase 1:\r\ncs_bit = SLINK_CS_POLARITY1;\r\nbreak;\r\ncase 2:\r\ncs_bit = SLINK_CS_POLARITY2;\r\nbreak;\r\ncase 4:\r\ncs_bit = SLINK_CS_POLARITY3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&tspi->lock, flags);\r\nval = spi_tegra_readl(tspi, SLINK_COMMAND);\r\nif (spi->mode & SPI_CS_HIGH)\r\nval |= cs_bit;\r\nelse\r\nval &= ~cs_bit;\r\nspi_tegra_writel(tspi, val, SLINK_COMMAND);\r\nspin_unlock_irqrestore(&tspi->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int spi_tegra_transfer(struct spi_device *spi, struct spi_message *m)\r\n{\r\nstruct spi_tegra_data *tspi = spi_master_get_devdata(spi->master);\r\nstruct spi_transfer *t;\r\nunsigned long flags;\r\nint was_empty;\r\nif (list_empty(&m->transfers) || !m->complete)\r\nreturn -EINVAL;\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nif (t->bits_per_word < 0 || t->bits_per_word > 32)\r\nreturn -EINVAL;\r\nif (t->len == 0)\r\nreturn -EINVAL;\r\nif (!t->rx_buf && !t->tx_buf)\r\nreturn -EINVAL;\r\n}\r\nm->state = spi;\r\nspin_lock_irqsave(&tspi->lock, flags);\r\nwas_empty = list_empty(&tspi->queue);\r\nlist_add_tail(&m->queue, &tspi->queue);\r\nif (was_empty)\r\nspi_tegra_start_message(spi, m);\r\nspin_unlock_irqrestore(&tspi->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int __devinit spi_tegra_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct spi_tegra_data *tspi;\r\nstruct resource *r;\r\nint ret;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof *tspi);\r\nif (master == NULL) {\r\ndev_err(&pdev->dev, "master allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\r\nmaster->bus_num = pdev->id;\r\nmaster->setup = spi_tegra_setup;\r\nmaster->transfer = spi_tegra_transfer;\r\nmaster->num_chipselect = 4;\r\ndev_set_drvdata(&pdev->dev, master);\r\ntspi = spi_master_get_devdata(master);\r\ntspi->master = master;\r\ntspi->pdev = pdev;\r\nspin_lock_init(&tspi->lock);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (r == NULL) {\r\nret = -ENODEV;\r\ngoto err0;\r\n}\r\nif (!request_mem_region(r->start, resource_size(r),\r\ndev_name(&pdev->dev))) {\r\nret = -EBUSY;\r\ngoto err0;\r\n}\r\ntspi->phys = r->start;\r\ntspi->base = ioremap(r->start, resource_size(r));\r\nif (!tspi->base) {\r\ndev_err(&pdev->dev, "can't ioremap iomem\n");\r\nret = -ENOMEM;\r\ngoto err1;\r\n}\r\ntspi->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(tspi->clk)) {\r\ndev_err(&pdev->dev, "can not get clock\n");\r\nret = PTR_ERR(tspi->clk);\r\ngoto err2;\r\n}\r\nINIT_LIST_HEAD(&tspi->queue);\r\ntspi->rx_dma = tegra_dma_allocate_channel(TEGRA_DMA_MODE_ONESHOT);\r\nif (!tspi->rx_dma) {\r\ndev_err(&pdev->dev, "can not allocate rx dma channel\n");\r\nret = -ENODEV;\r\ngoto err3;\r\n}\r\ntspi->rx_bb = dma_alloc_coherent(&pdev->dev, sizeof(u32) * BB_LEN,\r\n&tspi->rx_bb_phys, GFP_KERNEL);\r\nif (!tspi->rx_bb) {\r\ndev_err(&pdev->dev, "can not allocate rx bounce buffer\n");\r\nret = -ENOMEM;\r\ngoto err4;\r\n}\r\ntspi->rx_dma_req.complete = tegra_spi_rx_dma_complete;\r\ntspi->rx_dma_req.to_memory = 1;\r\ntspi->rx_dma_req.dest_addr = tspi->rx_bb_phys;\r\ntspi->rx_dma_req.dest_bus_width = 32;\r\ntspi->rx_dma_req.source_addr = tspi->phys + SLINK_RX_FIFO;\r\ntspi->rx_dma_req.source_bus_width = 32;\r\ntspi->rx_dma_req.source_wrap = 4;\r\ntspi->rx_dma_req.req_sel = spi_tegra_req_sels[pdev->id];\r\ntspi->rx_dma_req.dev = tspi;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nret = spi_register_master(master);\r\nif (ret < 0)\r\ngoto err5;\r\nreturn ret;\r\nerr5:\r\ndma_free_coherent(&pdev->dev, sizeof(u32) * BB_LEN,\r\ntspi->rx_bb, tspi->rx_bb_phys);\r\nerr4:\r\ntegra_dma_free_channel(tspi->rx_dma);\r\nerr3:\r\nclk_put(tspi->clk);\r\nerr2:\r\niounmap(tspi->base);\r\nerr1:\r\nrelease_mem_region(r->start, resource_size(r));\r\nerr0:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int __devexit spi_tegra_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct spi_tegra_data *tspi;\r\nstruct resource *r;\r\nmaster = dev_get_drvdata(&pdev->dev);\r\ntspi = spi_master_get_devdata(master);\r\nspi_unregister_master(master);\r\ntegra_dma_free_channel(tspi->rx_dma);\r\ndma_free_coherent(&pdev->dev, sizeof(u32) * BB_LEN,\r\ntspi->rx_bb, tspi->rx_bb_phys);\r\nclk_put(tspi->clk);\r\niounmap(tspi->base);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(r->start, resource_size(r));\r\nreturn 0;\r\n}
