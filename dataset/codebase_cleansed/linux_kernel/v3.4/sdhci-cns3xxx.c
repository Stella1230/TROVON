static unsigned int sdhci_cns3xxx_get_max_clk(struct sdhci_host *host)\r\n{\r\nreturn 150000000;\r\n}\r\nstatic void sdhci_cns3xxx_set_clock(struct sdhci_host *host, unsigned int clock)\r\n{\r\nstruct device *dev = mmc_dev(host->mmc);\r\nint div = 1;\r\nu16 clk;\r\nunsigned long timeout;\r\nif (clock == host->clock)\r\nreturn;\r\nsdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);\r\nif (clock == 0)\r\ngoto out;\r\nwhile (host->max_clk / div > clock) {\r\nif (div < 4)\r\ndiv += 1;\r\nelse if (div < 256)\r\ndiv *= 2;\r\nelse\r\nbreak;\r\n}\r\ndev_dbg(dev, "desired SD clock: %d, actual: %d\n",\r\nclock, host->max_clk / div);\r\nif (div != 3)\r\ndiv >>= 1;\r\nclk = div << SDHCI_DIVIDER_SHIFT;\r\nclk |= SDHCI_CLOCK_INT_EN;\r\nsdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);\r\ntimeout = 20;\r\nwhile (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))\r\n& SDHCI_CLOCK_INT_STABLE)) {\r\nif (timeout == 0) {\r\ndev_warn(dev, "clock is unstable");\r\nbreak;\r\n}\r\ntimeout--;\r\nmdelay(1);\r\n}\r\nclk |= SDHCI_CLOCK_CARD_EN;\r\nsdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);\r\nout:\r\nhost->clock = clock;\r\n}\r\nstatic int __devinit sdhci_cns3xxx_probe(struct platform_device *pdev)\r\n{\r\nreturn sdhci_pltfm_register(pdev, &sdhci_cns3xxx_pdata);\r\n}\r\nstatic int __devexit sdhci_cns3xxx_remove(struct platform_device *pdev)\r\n{\r\nreturn sdhci_pltfm_unregister(pdev);\r\n}
