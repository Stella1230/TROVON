static struct net_device_stats *ip6_get_stats(struct net_device *dev)\r\n{\r\nstruct pcpu_tstats sum = { 0 };\r\nint i;\r\nfor_each_possible_cpu(i) {\r\nconst struct pcpu_tstats *tstats = per_cpu_ptr(dev->tstats, i);\r\nsum.rx_packets += tstats->rx_packets;\r\nsum.rx_bytes += tstats->rx_bytes;\r\nsum.tx_packets += tstats->tx_packets;\r\nsum.tx_bytes += tstats->tx_bytes;\r\n}\r\ndev->stats.rx_packets = sum.rx_packets;\r\ndev->stats.rx_bytes = sum.rx_bytes;\r\ndev->stats.tx_packets = sum.tx_packets;\r\ndev->stats.tx_bytes = sum.tx_bytes;\r\nreturn &dev->stats;\r\n}\r\nstatic inline struct dst_entry *ip6_tnl_dst_check(struct ip6_tnl *t)\r\n{\r\nstruct dst_entry *dst = t->dst_cache;\r\nif (dst && dst->obsolete &&\r\ndst->ops->check(dst, t->dst_cookie) == NULL) {\r\nt->dst_cache = NULL;\r\ndst_release(dst);\r\nreturn NULL;\r\n}\r\nreturn dst;\r\n}\r\nstatic inline void ip6_tnl_dst_reset(struct ip6_tnl *t)\r\n{\r\ndst_release(t->dst_cache);\r\nt->dst_cache = NULL;\r\n}\r\nstatic inline void ip6_tnl_dst_store(struct ip6_tnl *t, struct dst_entry *dst)\r\n{\r\nstruct rt6_info *rt = (struct rt6_info *) dst;\r\nt->dst_cookie = rt->rt6i_node ? rt->rt6i_node->fn_sernum : 0;\r\ndst_release(t->dst_cache);\r\nt->dst_cache = dst;\r\n}\r\nstatic struct ip6_tnl *\r\nip6_tnl_lookup(struct net *net, const struct in6_addr *remote, const struct in6_addr *local)\r\n{\r\nunsigned int h0 = HASH(remote);\r\nunsigned int h1 = HASH(local);\r\nstruct ip6_tnl *t;\r\nstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\r\nfor_each_ip6_tunnel_rcu(ip6n->tnls_r_l[h0 ^ h1]) {\r\nif (ipv6_addr_equal(local, &t->parms.laddr) &&\r\nipv6_addr_equal(remote, &t->parms.raddr) &&\r\n(t->dev->flags & IFF_UP))\r\nreturn t;\r\n}\r\nt = rcu_dereference(ip6n->tnls_wc[0]);\r\nif (t && (t->dev->flags & IFF_UP))\r\nreturn t;\r\nreturn NULL;\r\n}\r\nstatic struct ip6_tnl __rcu **\r\nip6_tnl_bucket(struct ip6_tnl_net *ip6n, const struct ip6_tnl_parm *p)\r\n{\r\nconst struct in6_addr *remote = &p->raddr;\r\nconst struct in6_addr *local = &p->laddr;\r\nunsigned h = 0;\r\nint prio = 0;\r\nif (!ipv6_addr_any(remote) || !ipv6_addr_any(local)) {\r\nprio = 1;\r\nh = HASH(remote) ^ HASH(local);\r\n}\r\nreturn &ip6n->tnls[prio][h];\r\n}\r\nstatic void\r\nip6_tnl_link(struct ip6_tnl_net *ip6n, struct ip6_tnl *t)\r\n{\r\nstruct ip6_tnl __rcu **tp = ip6_tnl_bucket(ip6n, &t->parms);\r\nrcu_assign_pointer(t->next , rtnl_dereference(*tp));\r\nrcu_assign_pointer(*tp, t);\r\n}\r\nstatic void\r\nip6_tnl_unlink(struct ip6_tnl_net *ip6n, struct ip6_tnl *t)\r\n{\r\nstruct ip6_tnl __rcu **tp;\r\nstruct ip6_tnl *iter;\r\nfor (tp = ip6_tnl_bucket(ip6n, &t->parms);\r\n(iter = rtnl_dereference(*tp)) != NULL;\r\ntp = &iter->next) {\r\nif (t == iter) {\r\nrcu_assign_pointer(*tp, t->next);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void ip6_dev_free(struct net_device *dev)\r\n{\r\nfree_percpu(dev->tstats);\r\nfree_netdev(dev);\r\n}\r\nstatic struct ip6_tnl *ip6_tnl_create(struct net *net, struct ip6_tnl_parm *p)\r\n{\r\nstruct net_device *dev;\r\nstruct ip6_tnl *t;\r\nchar name[IFNAMSIZ];\r\nint err;\r\nstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\r\nif (p->name[0])\r\nstrlcpy(name, p->name, IFNAMSIZ);\r\nelse\r\nsprintf(name, "ip6tnl%%d");\r\ndev = alloc_netdev(sizeof (*t), name, ip6_tnl_dev_setup);\r\nif (dev == NULL)\r\ngoto failed;\r\ndev_net_set(dev, net);\r\nt = netdev_priv(dev);\r\nt->parms = *p;\r\nerr = ip6_tnl_dev_init(dev);\r\nif (err < 0)\r\ngoto failed_free;\r\nif ((err = register_netdevice(dev)) < 0)\r\ngoto failed_free;\r\nstrcpy(t->parms.name, dev->name);\r\ndev_hold(dev);\r\nip6_tnl_link(ip6n, t);\r\nreturn t;\r\nfailed_free:\r\nip6_dev_free(dev);\r\nfailed:\r\nreturn NULL;\r\n}\r\nstatic struct ip6_tnl *ip6_tnl_locate(struct net *net,\r\nstruct ip6_tnl_parm *p, int create)\r\n{\r\nconst struct in6_addr *remote = &p->raddr;\r\nconst struct in6_addr *local = &p->laddr;\r\nstruct ip6_tnl __rcu **tp;\r\nstruct ip6_tnl *t;\r\nstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\r\nfor (tp = ip6_tnl_bucket(ip6n, p);\r\n(t = rtnl_dereference(*tp)) != NULL;\r\ntp = &t->next) {\r\nif (ipv6_addr_equal(local, &t->parms.laddr) &&\r\nipv6_addr_equal(remote, &t->parms.raddr))\r\nreturn t;\r\n}\r\nif (!create)\r\nreturn NULL;\r\nreturn ip6_tnl_create(net, p);\r\n}\r\nstatic void\r\nip6_tnl_dev_uninit(struct net_device *dev)\r\n{\r\nstruct ip6_tnl *t = netdev_priv(dev);\r\nstruct net *net = dev_net(dev);\r\nstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\r\nif (dev == ip6n->fb_tnl_dev)\r\nRCU_INIT_POINTER(ip6n->tnls_wc[0], NULL);\r\nelse\r\nip6_tnl_unlink(ip6n, t);\r\nip6_tnl_dst_reset(t);\r\ndev_put(dev);\r\n}\r\nstatic __u16\r\nparse_tlv_tnl_enc_lim(struct sk_buff *skb, __u8 * raw)\r\n{\r\nconst struct ipv6hdr *ipv6h = (const struct ipv6hdr *) raw;\r\n__u8 nexthdr = ipv6h->nexthdr;\r\n__u16 off = sizeof (*ipv6h);\r\nwhile (ipv6_ext_hdr(nexthdr) && nexthdr != NEXTHDR_NONE) {\r\n__u16 optlen = 0;\r\nstruct ipv6_opt_hdr *hdr;\r\nif (raw + off + sizeof (*hdr) > skb->data &&\r\n!pskb_may_pull(skb, raw - skb->data + off + sizeof (*hdr)))\r\nbreak;\r\nhdr = (struct ipv6_opt_hdr *) (raw + off);\r\nif (nexthdr == NEXTHDR_FRAGMENT) {\r\nstruct frag_hdr *frag_hdr = (struct frag_hdr *) hdr;\r\nif (frag_hdr->frag_off)\r\nbreak;\r\noptlen = 8;\r\n} else if (nexthdr == NEXTHDR_AUTH) {\r\noptlen = (hdr->hdrlen + 2) << 2;\r\n} else {\r\noptlen = ipv6_optlen(hdr);\r\n}\r\nif (nexthdr == NEXTHDR_DEST) {\r\n__u16 i = off + 2;\r\nwhile (1) {\r\nstruct ipv6_tlv_tnl_enc_lim *tel;\r\nif (i + sizeof (*tel) > off + optlen)\r\nbreak;\r\ntel = (struct ipv6_tlv_tnl_enc_lim *) &raw[i];\r\nif (tel->type == IPV6_TLV_TNL_ENCAP_LIMIT &&\r\ntel->length == 1)\r\nreturn i;\r\nif (tel->type)\r\ni += tel->length + 2;\r\nelse\r\ni++;\r\n}\r\n}\r\nnexthdr = hdr->nexthdr;\r\noff += optlen;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nip6_tnl_err(struct sk_buff *skb, __u8 ipproto, struct inet6_skb_parm *opt,\r\nu8 *type, u8 *code, int *msg, __u32 *info, int offset)\r\n{\r\nconst struct ipv6hdr *ipv6h = (const struct ipv6hdr *) skb->data;\r\nstruct ip6_tnl *t;\r\nint rel_msg = 0;\r\nu8 rel_type = ICMPV6_DEST_UNREACH;\r\nu8 rel_code = ICMPV6_ADDR_UNREACH;\r\n__u32 rel_info = 0;\r\n__u16 len;\r\nint err = -ENOENT;\r\nrcu_read_lock();\r\nif ((t = ip6_tnl_lookup(dev_net(skb->dev), &ipv6h->daddr,\r\n&ipv6h->saddr)) == NULL)\r\ngoto out;\r\nif (t->parms.proto != ipproto && t->parms.proto != 0)\r\ngoto out;\r\nerr = 0;\r\nswitch (*type) {\r\n__u32 teli;\r\nstruct ipv6_tlv_tnl_enc_lim *tel;\r\n__u32 mtu;\r\ncase ICMPV6_DEST_UNREACH:\r\nif (net_ratelimit())\r\nprintk(KERN_WARNING\r\n"%s: Path to destination invalid "\r\n"or inactive!\n", t->parms.name);\r\nrel_msg = 1;\r\nbreak;\r\ncase ICMPV6_TIME_EXCEED:\r\nif ((*code) == ICMPV6_EXC_HOPLIMIT) {\r\nif (net_ratelimit())\r\nprintk(KERN_WARNING\r\n"%s: Too small hop limit or "\r\n"routing loop in tunnel!\n",\r\nt->parms.name);\r\nrel_msg = 1;\r\n}\r\nbreak;\r\ncase ICMPV6_PARAMPROB:\r\nteli = 0;\r\nif ((*code) == ICMPV6_HDR_FIELD)\r\nteli = parse_tlv_tnl_enc_lim(skb, skb->data);\r\nif (teli && teli == *info - 2) {\r\ntel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli];\r\nif (tel->encap_limit == 0) {\r\nif (net_ratelimit())\r\nprintk(KERN_WARNING\r\n"%s: Too small encapsulation "\r\n"limit or routing loop in "\r\n"tunnel!\n", t->parms.name);\r\nrel_msg = 1;\r\n}\r\n} else if (net_ratelimit()) {\r\nprintk(KERN_WARNING\r\n"%s: Recipient unable to parse tunneled "\r\n"packet!\n ", t->parms.name);\r\n}\r\nbreak;\r\ncase ICMPV6_PKT_TOOBIG:\r\nmtu = *info - offset;\r\nif (mtu < IPV6_MIN_MTU)\r\nmtu = IPV6_MIN_MTU;\r\nt->dev->mtu = mtu;\r\nif ((len = sizeof (*ipv6h) + ntohs(ipv6h->payload_len)) > mtu) {\r\nrel_type = ICMPV6_PKT_TOOBIG;\r\nrel_code = 0;\r\nrel_info = mtu;\r\nrel_msg = 1;\r\n}\r\nbreak;\r\n}\r\n*type = rel_type;\r\n*code = rel_code;\r\n*info = rel_info;\r\n*msg = rel_msg;\r\nout:\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nstatic int\r\nip4ip6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\r\nu8 type, u8 code, int offset, __be32 info)\r\n{\r\nint rel_msg = 0;\r\nu8 rel_type = type;\r\nu8 rel_code = code;\r\n__u32 rel_info = ntohl(info);\r\nint err;\r\nstruct sk_buff *skb2;\r\nconst struct iphdr *eiph;\r\nstruct rtable *rt;\r\nstruct flowi4 fl4;\r\nerr = ip6_tnl_err(skb, IPPROTO_IPIP, opt, &rel_type, &rel_code,\r\n&rel_msg, &rel_info, offset);\r\nif (err < 0)\r\nreturn err;\r\nif (rel_msg == 0)\r\nreturn 0;\r\nswitch (rel_type) {\r\ncase ICMPV6_DEST_UNREACH:\r\nif (rel_code != ICMPV6_ADDR_UNREACH)\r\nreturn 0;\r\nrel_type = ICMP_DEST_UNREACH;\r\nrel_code = ICMP_HOST_UNREACH;\r\nbreak;\r\ncase ICMPV6_PKT_TOOBIG:\r\nif (rel_code != 0)\r\nreturn 0;\r\nrel_type = ICMP_DEST_UNREACH;\r\nrel_code = ICMP_FRAG_NEEDED;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (!pskb_may_pull(skb, offset + sizeof(struct iphdr)))\r\nreturn 0;\r\nskb2 = skb_clone(skb, GFP_ATOMIC);\r\nif (!skb2)\r\nreturn 0;\r\nskb_dst_drop(skb2);\r\nskb_pull(skb2, offset);\r\nskb_reset_network_header(skb2);\r\neiph = ip_hdr(skb2);\r\nrt = ip_route_output_ports(dev_net(skb->dev), &fl4, NULL,\r\neiph->saddr, 0,\r\n0, 0,\r\nIPPROTO_IPIP, RT_TOS(eiph->tos), 0);\r\nif (IS_ERR(rt))\r\ngoto out;\r\nskb2->dev = rt->dst.dev;\r\nif (rt->rt_flags & RTCF_LOCAL) {\r\nip_rt_put(rt);\r\nrt = NULL;\r\nrt = ip_route_output_ports(dev_net(skb->dev), &fl4, NULL,\r\neiph->daddr, eiph->saddr,\r\n0, 0,\r\nIPPROTO_IPIP,\r\nRT_TOS(eiph->tos), 0);\r\nif (IS_ERR(rt) ||\r\nrt->dst.dev->type != ARPHRD_TUNNEL) {\r\nif (!IS_ERR(rt))\r\nip_rt_put(rt);\r\ngoto out;\r\n}\r\nskb_dst_set(skb2, &rt->dst);\r\n} else {\r\nip_rt_put(rt);\r\nif (ip_route_input(skb2, eiph->daddr, eiph->saddr, eiph->tos,\r\nskb2->dev) ||\r\nskb_dst(skb2)->dev->type != ARPHRD_TUNNEL)\r\ngoto out;\r\n}\r\nif (rel_type == ICMP_DEST_UNREACH && rel_code == ICMP_FRAG_NEEDED) {\r\nif (rel_info > dst_mtu(skb_dst(skb2)))\r\ngoto out;\r\nskb_dst(skb2)->ops->update_pmtu(skb_dst(skb2), rel_info);\r\n}\r\nicmp_send(skb2, rel_type, rel_code, htonl(rel_info));\r\nout:\r\nkfree_skb(skb2);\r\nreturn 0;\r\n}\r\nstatic int\r\nip6ip6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\r\nu8 type, u8 code, int offset, __be32 info)\r\n{\r\nint rel_msg = 0;\r\nu8 rel_type = type;\r\nu8 rel_code = code;\r\n__u32 rel_info = ntohl(info);\r\nint err;\r\nerr = ip6_tnl_err(skb, IPPROTO_IPV6, opt, &rel_type, &rel_code,\r\n&rel_msg, &rel_info, offset);\r\nif (err < 0)\r\nreturn err;\r\nif (rel_msg && pskb_may_pull(skb, offset + sizeof(struct ipv6hdr))) {\r\nstruct rt6_info *rt;\r\nstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\r\nif (!skb2)\r\nreturn 0;\r\nskb_dst_drop(skb2);\r\nskb_pull(skb2, offset);\r\nskb_reset_network_header(skb2);\r\nrt = rt6_lookup(dev_net(skb->dev), &ipv6_hdr(skb2)->saddr,\r\nNULL, 0, 0);\r\nif (rt && rt->dst.dev)\r\nskb2->dev = rt->dst.dev;\r\nicmpv6_send(skb2, rel_type, rel_code, rel_info);\r\nif (rt)\r\ndst_release(&rt->dst);\r\nkfree_skb(skb2);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ip4ip6_dscp_ecn_decapsulate(const struct ip6_tnl *t,\r\nconst struct ipv6hdr *ipv6h,\r\nstruct sk_buff *skb)\r\n{\r\n__u8 dsfield = ipv6_get_dsfield(ipv6h) & ~INET_ECN_MASK;\r\nif (t->parms.flags & IP6_TNL_F_RCV_DSCP_COPY)\r\nipv4_change_dsfield(ip_hdr(skb), INET_ECN_MASK, dsfield);\r\nif (INET_ECN_is_ce(dsfield))\r\nIP_ECN_set_ce(ip_hdr(skb));\r\n}\r\nstatic void ip6ip6_dscp_ecn_decapsulate(const struct ip6_tnl *t,\r\nconst struct ipv6hdr *ipv6h,\r\nstruct sk_buff *skb)\r\n{\r\nif (t->parms.flags & IP6_TNL_F_RCV_DSCP_COPY)\r\nipv6_copy_dscp(ipv6_get_dsfield(ipv6h), ipv6_hdr(skb));\r\nif (INET_ECN_is_ce(ipv6_get_dsfield(ipv6h)))\r\nIP6_ECN_set_ce(ipv6_hdr(skb));\r\n}\r\nstatic inline int ip6_tnl_rcv_ctl(struct ip6_tnl *t)\r\n{\r\nstruct ip6_tnl_parm *p = &t->parms;\r\nint ret = 0;\r\nstruct net *net = dev_net(t->dev);\r\nif (p->flags & IP6_TNL_F_CAP_RCV) {\r\nstruct net_device *ldev = NULL;\r\nif (p->link)\r\nldev = dev_get_by_index_rcu(net, p->link);\r\nif ((ipv6_addr_is_multicast(&p->laddr) ||\r\nlikely(ipv6_chk_addr(net, &p->laddr, ldev, 0))) &&\r\nlikely(!ipv6_chk_addr(net, &p->raddr, NULL, 0)))\r\nret = 1;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ip6_tnl_rcv(struct sk_buff *skb, __u16 protocol,\r\n__u8 ipproto,\r\nvoid (*dscp_ecn_decapsulate)(const struct ip6_tnl *t,\r\nconst struct ipv6hdr *ipv6h,\r\nstruct sk_buff *skb))\r\n{\r\nstruct ip6_tnl *t;\r\nconst struct ipv6hdr *ipv6h = ipv6_hdr(skb);\r\nrcu_read_lock();\r\nif ((t = ip6_tnl_lookup(dev_net(skb->dev), &ipv6h->saddr,\r\n&ipv6h->daddr)) != NULL) {\r\nstruct pcpu_tstats *tstats;\r\nif (t->parms.proto != ipproto && t->parms.proto != 0) {\r\nrcu_read_unlock();\r\ngoto discard;\r\n}\r\nif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {\r\nrcu_read_unlock();\r\ngoto discard;\r\n}\r\nif (!ip6_tnl_rcv_ctl(t)) {\r\nt->dev->stats.rx_dropped++;\r\nrcu_read_unlock();\r\ngoto discard;\r\n}\r\nsecpath_reset(skb);\r\nskb->mac_header = skb->network_header;\r\nskb_reset_network_header(skb);\r\nskb->protocol = htons(protocol);\r\nskb->pkt_type = PACKET_HOST;\r\nmemset(skb->cb, 0, sizeof(struct inet6_skb_parm));\r\ntstats = this_cpu_ptr(t->dev->tstats);\r\ntstats->rx_packets++;\r\ntstats->rx_bytes += skb->len;\r\n__skb_tunnel_rx(skb, t->dev);\r\ndscp_ecn_decapsulate(t, ipv6h, skb);\r\nnetif_rx(skb);\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nrcu_read_unlock();\r\nreturn 1;\r\ndiscard:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int ip4ip6_rcv(struct sk_buff *skb)\r\n{\r\nreturn ip6_tnl_rcv(skb, ETH_P_IP, IPPROTO_IPIP,\r\nip4ip6_dscp_ecn_decapsulate);\r\n}\r\nstatic int ip6ip6_rcv(struct sk_buff *skb)\r\n{\r\nreturn ip6_tnl_rcv(skb, ETH_P_IPV6, IPPROTO_IPV6,\r\nip6ip6_dscp_ecn_decapsulate);\r\n}\r\nstatic void init_tel_txopt(struct ipv6_tel_txoption *opt, __u8 encap_limit)\r\n{\r\nmemset(opt, 0, sizeof(struct ipv6_tel_txoption));\r\nopt->dst_opt[2] = IPV6_TLV_TNL_ENCAP_LIMIT;\r\nopt->dst_opt[3] = 1;\r\nopt->dst_opt[4] = encap_limit;\r\nopt->dst_opt[5] = IPV6_TLV_PADN;\r\nopt->dst_opt[6] = 1;\r\nopt->ops.dst0opt = (struct ipv6_opt_hdr *) opt->dst_opt;\r\nopt->ops.opt_nflen = 8;\r\n}\r\nstatic inline int\r\nip6_tnl_addr_conflict(const struct ip6_tnl *t, const struct ipv6hdr *hdr)\r\n{\r\nreturn ipv6_addr_equal(&t->parms.raddr, &hdr->saddr);\r\n}\r\nstatic inline int ip6_tnl_xmit_ctl(struct ip6_tnl *t)\r\n{\r\nstruct ip6_tnl_parm *p = &t->parms;\r\nint ret = 0;\r\nstruct net *net = dev_net(t->dev);\r\nif (p->flags & IP6_TNL_F_CAP_XMIT) {\r\nstruct net_device *ldev = NULL;\r\nrcu_read_lock();\r\nif (p->link)\r\nldev = dev_get_by_index_rcu(net, p->link);\r\nif (unlikely(!ipv6_chk_addr(net, &p->laddr, ldev, 0)))\r\nprintk(KERN_WARNING\r\n"%s xmit: Local address not yet configured!\n",\r\np->name);\r\nelse if (!ipv6_addr_is_multicast(&p->raddr) &&\r\nunlikely(ipv6_chk_addr(net, &p->raddr, NULL, 0)))\r\nprintk(KERN_WARNING\r\n"%s xmit: Routing loop! "\r\n"Remote address found on this node!\n",\r\np->name);\r\nelse\r\nret = 1;\r\nrcu_read_unlock();\r\n}\r\nreturn ret;\r\n}\r\nstatic int ip6_tnl_xmit2(struct sk_buff *skb,\r\nstruct net_device *dev,\r\n__u8 dsfield,\r\nstruct flowi6 *fl6,\r\nint encap_limit,\r\n__u32 *pmtu)\r\n{\r\nstruct net *net = dev_net(dev);\r\nstruct ip6_tnl *t = netdev_priv(dev);\r\nstruct net_device_stats *stats = &t->dev->stats;\r\nstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\r\nstruct ipv6_tel_txoption opt;\r\nstruct dst_entry *dst = NULL, *ndst = NULL;\r\nstruct net_device *tdev;\r\nint mtu;\r\nunsigned int max_headroom = sizeof(struct ipv6hdr);\r\nu8 proto;\r\nint err = -1;\r\nint pkt_len;\r\nif (!fl6->flowi6_mark)\r\ndst = ip6_tnl_dst_check(t);\r\nif (!dst) {\r\nndst = ip6_route_output(net, NULL, fl6);\r\nif (ndst->error)\r\ngoto tx_err_link_failure;\r\nndst = xfrm_lookup(net, ndst, flowi6_to_flowi(fl6), NULL, 0);\r\nif (IS_ERR(ndst)) {\r\nerr = PTR_ERR(ndst);\r\nndst = NULL;\r\ngoto tx_err_link_failure;\r\n}\r\ndst = ndst;\r\n}\r\ntdev = dst->dev;\r\nif (tdev == dev) {\r\nstats->collisions++;\r\nif (net_ratelimit())\r\nprintk(KERN_WARNING\r\n"%s: Local routing loop detected!\n",\r\nt->parms.name);\r\ngoto tx_err_dst_release;\r\n}\r\nmtu = dst_mtu(dst) - sizeof (*ipv6h);\r\nif (encap_limit >= 0) {\r\nmax_headroom += 8;\r\nmtu -= 8;\r\n}\r\nif (mtu < IPV6_MIN_MTU)\r\nmtu = IPV6_MIN_MTU;\r\nif (skb_dst(skb))\r\nskb_dst(skb)->ops->update_pmtu(skb_dst(skb), mtu);\r\nif (skb->len > mtu) {\r\n*pmtu = mtu;\r\nerr = -EMSGSIZE;\r\ngoto tx_err_dst_release;\r\n}\r\nmax_headroom += LL_RESERVED_SPACE(tdev);\r\nif (skb_headroom(skb) < max_headroom || skb_shared(skb) ||\r\n(skb_cloned(skb) && !skb_clone_writable(skb, 0))) {\r\nstruct sk_buff *new_skb;\r\nif (!(new_skb = skb_realloc_headroom(skb, max_headroom)))\r\ngoto tx_err_dst_release;\r\nif (skb->sk)\r\nskb_set_owner_w(new_skb, skb->sk);\r\nkfree_skb(skb);\r\nskb = new_skb;\r\n}\r\nskb_dst_drop(skb);\r\nif (fl6->flowi6_mark) {\r\nskb_dst_set(skb, dst);\r\nndst = NULL;\r\n} else {\r\nskb_dst_set_noref(skb, dst);\r\n}\r\nskb->transport_header = skb->network_header;\r\nproto = fl6->flowi6_proto;\r\nif (encap_limit >= 0) {\r\ninit_tel_txopt(&opt, encap_limit);\r\nipv6_push_nfrag_opts(skb, &opt.ops, &proto, NULL);\r\n}\r\nskb_push(skb, sizeof(struct ipv6hdr));\r\nskb_reset_network_header(skb);\r\nipv6h = ipv6_hdr(skb);\r\n*(__be32*)ipv6h = fl6->flowlabel | htonl(0x60000000);\r\ndsfield = INET_ECN_encapsulate(0, dsfield);\r\nipv6_change_dsfield(ipv6h, ~INET_ECN_MASK, dsfield);\r\nipv6h->hop_limit = t->parms.hop_limit;\r\nipv6h->nexthdr = proto;\r\nipv6h->saddr = fl6->saddr;\r\nipv6h->daddr = fl6->daddr;\r\nnf_reset(skb);\r\npkt_len = skb->len;\r\nerr = ip6_local_out(skb);\r\nif (net_xmit_eval(err) == 0) {\r\nstruct pcpu_tstats *tstats = this_cpu_ptr(t->dev->tstats);\r\ntstats->tx_bytes += pkt_len;\r\ntstats->tx_packets++;\r\n} else {\r\nstats->tx_errors++;\r\nstats->tx_aborted_errors++;\r\n}\r\nif (ndst)\r\nip6_tnl_dst_store(t, ndst);\r\nreturn 0;\r\ntx_err_link_failure:\r\nstats->tx_carrier_errors++;\r\ndst_link_failure(skb);\r\ntx_err_dst_release:\r\ndst_release(ndst);\r\nreturn err;\r\n}\r\nstatic inline int\r\nip4ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct ip6_tnl *t = netdev_priv(dev);\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nint encap_limit = -1;\r\nstruct flowi6 fl6;\r\n__u8 dsfield;\r\n__u32 mtu;\r\nint err;\r\nif ((t->parms.proto != IPPROTO_IPIP && t->parms.proto != 0) ||\r\n!ip6_tnl_xmit_ctl(t))\r\nreturn -1;\r\nif (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))\r\nencap_limit = t->parms.encap_limit;\r\nmemcpy(&fl6, &t->fl.u.ip6, sizeof (fl6));\r\nfl6.flowi6_proto = IPPROTO_IPIP;\r\ndsfield = ipv4_get_dsfield(iph);\r\nif (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)\r\nfl6.flowlabel |= htonl((__u32)iph->tos << IPV6_TCLASS_SHIFT)\r\n& IPV6_TCLASS_MASK;\r\nif (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)\r\nfl6.flowi6_mark = skb->mark;\r\nerr = ip6_tnl_xmit2(skb, dev, dsfield, &fl6, encap_limit, &mtu);\r\nif (err != 0) {\r\nif (err == -EMSGSIZE)\r\nicmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,\r\nhtonl(mtu));\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int\r\nip6ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct ip6_tnl *t = netdev_priv(dev);\r\nstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\r\nint encap_limit = -1;\r\n__u16 offset;\r\nstruct flowi6 fl6;\r\n__u8 dsfield;\r\n__u32 mtu;\r\nint err;\r\nif ((t->parms.proto != IPPROTO_IPV6 && t->parms.proto != 0) ||\r\n!ip6_tnl_xmit_ctl(t) || ip6_tnl_addr_conflict(t, ipv6h))\r\nreturn -1;\r\noffset = parse_tlv_tnl_enc_lim(skb, skb_network_header(skb));\r\nif (offset > 0) {\r\nstruct ipv6_tlv_tnl_enc_lim *tel;\r\ntel = (struct ipv6_tlv_tnl_enc_lim *)&skb_network_header(skb)[offset];\r\nif (tel->encap_limit == 0) {\r\nicmpv6_send(skb, ICMPV6_PARAMPROB,\r\nICMPV6_HDR_FIELD, offset + 2);\r\nreturn -1;\r\n}\r\nencap_limit = tel->encap_limit - 1;\r\n} else if (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))\r\nencap_limit = t->parms.encap_limit;\r\nmemcpy(&fl6, &t->fl.u.ip6, sizeof (fl6));\r\nfl6.flowi6_proto = IPPROTO_IPV6;\r\ndsfield = ipv6_get_dsfield(ipv6h);\r\nif (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)\r\nfl6.flowlabel |= (*(__be32 *) ipv6h & IPV6_TCLASS_MASK);\r\nif (t->parms.flags & IP6_TNL_F_USE_ORIG_FLOWLABEL)\r\nfl6.flowlabel |= (*(__be32 *) ipv6h & IPV6_FLOWLABEL_MASK);\r\nif (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)\r\nfl6.flowi6_mark = skb->mark;\r\nerr = ip6_tnl_xmit2(skb, dev, dsfield, &fl6, encap_limit, &mtu);\r\nif (err != 0) {\r\nif (err == -EMSGSIZE)\r\nicmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t\r\nip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct ip6_tnl *t = netdev_priv(dev);\r\nstruct net_device_stats *stats = &t->dev->stats;\r\nint ret;\r\nswitch (skb->protocol) {\r\ncase htons(ETH_P_IP):\r\nret = ip4ip6_tnl_xmit(skb, dev);\r\nbreak;\r\ncase htons(ETH_P_IPV6):\r\nret = ip6ip6_tnl_xmit(skb, dev);\r\nbreak;\r\ndefault:\r\ngoto tx_err;\r\n}\r\nif (ret < 0)\r\ngoto tx_err;\r\nreturn NETDEV_TX_OK;\r\ntx_err:\r\nstats->tx_errors++;\r\nstats->tx_dropped++;\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void ip6_tnl_set_cap(struct ip6_tnl *t)\r\n{\r\nstruct ip6_tnl_parm *p = &t->parms;\r\nint ltype = ipv6_addr_type(&p->laddr);\r\nint rtype = ipv6_addr_type(&p->raddr);\r\np->flags &= ~(IP6_TNL_F_CAP_XMIT|IP6_TNL_F_CAP_RCV);\r\nif (ltype & (IPV6_ADDR_UNICAST|IPV6_ADDR_MULTICAST) &&\r\nrtype & (IPV6_ADDR_UNICAST|IPV6_ADDR_MULTICAST) &&\r\n!((ltype|rtype) & IPV6_ADDR_LOOPBACK) &&\r\n(!((ltype|rtype) & IPV6_ADDR_LINKLOCAL) || p->link)) {\r\nif (ltype&IPV6_ADDR_UNICAST)\r\np->flags |= IP6_TNL_F_CAP_XMIT;\r\nif (rtype&IPV6_ADDR_UNICAST)\r\np->flags |= IP6_TNL_F_CAP_RCV;\r\n}\r\n}\r\nstatic void ip6_tnl_link_config(struct ip6_tnl *t)\r\n{\r\nstruct net_device *dev = t->dev;\r\nstruct ip6_tnl_parm *p = &t->parms;\r\nstruct flowi6 *fl6 = &t->fl.u.ip6;\r\nmemcpy(dev->dev_addr, &p->laddr, sizeof(struct in6_addr));\r\nmemcpy(dev->broadcast, &p->raddr, sizeof(struct in6_addr));\r\nfl6->saddr = p->laddr;\r\nfl6->daddr = p->raddr;\r\nfl6->flowi6_oif = p->link;\r\nfl6->flowlabel = 0;\r\nif (!(p->flags&IP6_TNL_F_USE_ORIG_TCLASS))\r\nfl6->flowlabel |= IPV6_TCLASS_MASK & p->flowinfo;\r\nif (!(p->flags&IP6_TNL_F_USE_ORIG_FLOWLABEL))\r\nfl6->flowlabel |= IPV6_FLOWLABEL_MASK & p->flowinfo;\r\nip6_tnl_set_cap(t);\r\nif (p->flags&IP6_TNL_F_CAP_XMIT && p->flags&IP6_TNL_F_CAP_RCV)\r\ndev->flags |= IFF_POINTOPOINT;\r\nelse\r\ndev->flags &= ~IFF_POINTOPOINT;\r\ndev->iflink = p->link;\r\nif (p->flags & IP6_TNL_F_CAP_XMIT) {\r\nint strict = (ipv6_addr_type(&p->raddr) &\r\n(IPV6_ADDR_MULTICAST|IPV6_ADDR_LINKLOCAL));\r\nstruct rt6_info *rt = rt6_lookup(dev_net(dev),\r\n&p->raddr, &p->laddr,\r\np->link, strict);\r\nif (rt == NULL)\r\nreturn;\r\nif (rt->dst.dev) {\r\ndev->hard_header_len = rt->dst.dev->hard_header_len +\r\nsizeof (struct ipv6hdr);\r\ndev->mtu = rt->dst.dev->mtu - sizeof (struct ipv6hdr);\r\nif (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))\r\ndev->mtu-=8;\r\nif (dev->mtu < IPV6_MIN_MTU)\r\ndev->mtu = IPV6_MIN_MTU;\r\n}\r\ndst_release(&rt->dst);\r\n}\r\n}\r\nstatic int\r\nip6_tnl_change(struct ip6_tnl *t, struct ip6_tnl_parm *p)\r\n{\r\nt->parms.laddr = p->laddr;\r\nt->parms.raddr = p->raddr;\r\nt->parms.flags = p->flags;\r\nt->parms.hop_limit = p->hop_limit;\r\nt->parms.encap_limit = p->encap_limit;\r\nt->parms.flowinfo = p->flowinfo;\r\nt->parms.link = p->link;\r\nt->parms.proto = p->proto;\r\nip6_tnl_dst_reset(t);\r\nip6_tnl_link_config(t);\r\nreturn 0;\r\n}\r\nstatic int\r\nip6_tnl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nint err = 0;\r\nstruct ip6_tnl_parm p;\r\nstruct ip6_tnl *t = NULL;\r\nstruct net *net = dev_net(dev);\r\nstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\r\nswitch (cmd) {\r\ncase SIOCGETTUNNEL:\r\nif (dev == ip6n->fb_tnl_dev) {\r\nif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof (p))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nt = ip6_tnl_locate(net, &p, 0);\r\n}\r\nif (t == NULL)\r\nt = netdev_priv(dev);\r\nmemcpy(&p, &t->parms, sizeof (p));\r\nif (copy_to_user(ifr->ifr_ifru.ifru_data, &p, sizeof (p))) {\r\nerr = -EFAULT;\r\n}\r\nbreak;\r\ncase SIOCADDTUNNEL:\r\ncase SIOCCHGTUNNEL:\r\nerr = -EPERM;\r\nif (!capable(CAP_NET_ADMIN))\r\nbreak;\r\nerr = -EFAULT;\r\nif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof (p)))\r\nbreak;\r\nerr = -EINVAL;\r\nif (p.proto != IPPROTO_IPV6 && p.proto != IPPROTO_IPIP &&\r\np.proto != 0)\r\nbreak;\r\nt = ip6_tnl_locate(net, &p, cmd == SIOCADDTUNNEL);\r\nif (dev != ip6n->fb_tnl_dev && cmd == SIOCCHGTUNNEL) {\r\nif (t != NULL) {\r\nif (t->dev != dev) {\r\nerr = -EEXIST;\r\nbreak;\r\n}\r\n} else\r\nt = netdev_priv(dev);\r\nip6_tnl_unlink(ip6n, t);\r\nsynchronize_net();\r\nerr = ip6_tnl_change(t, &p);\r\nip6_tnl_link(ip6n, t);\r\nnetdev_state_change(dev);\r\n}\r\nif (t) {\r\nerr = 0;\r\nif (copy_to_user(ifr->ifr_ifru.ifru_data, &t->parms, sizeof (p)))\r\nerr = -EFAULT;\r\n} else\r\nerr = (cmd == SIOCADDTUNNEL ? -ENOBUFS : -ENOENT);\r\nbreak;\r\ncase SIOCDELTUNNEL:\r\nerr = -EPERM;\r\nif (!capable(CAP_NET_ADMIN))\r\nbreak;\r\nif (dev == ip6n->fb_tnl_dev) {\r\nerr = -EFAULT;\r\nif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof (p)))\r\nbreak;\r\nerr = -ENOENT;\r\nif ((t = ip6_tnl_locate(net, &p, 0)) == NULL)\r\nbreak;\r\nerr = -EPERM;\r\nif (t->dev == ip6n->fb_tnl_dev)\r\nbreak;\r\ndev = t->dev;\r\n}\r\nerr = 0;\r\nunregister_netdevice(dev);\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\nip6_tnl_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif (new_mtu < IPV6_MIN_MTU) {\r\nreturn -EINVAL;\r\n}\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void ip6_tnl_dev_setup(struct net_device *dev)\r\n{\r\nstruct ip6_tnl *t;\r\ndev->netdev_ops = &ip6_tnl_netdev_ops;\r\ndev->destructor = ip6_dev_free;\r\ndev->type = ARPHRD_TUNNEL6;\r\ndev->hard_header_len = LL_MAX_HEADER + sizeof (struct ipv6hdr);\r\ndev->mtu = ETH_DATA_LEN - sizeof (struct ipv6hdr);\r\nt = netdev_priv(dev);\r\nif (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))\r\ndev->mtu-=8;\r\ndev->flags |= IFF_NOARP;\r\ndev->addr_len = sizeof(struct in6_addr);\r\ndev->features |= NETIF_F_NETNS_LOCAL;\r\ndev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\r\n}\r\nstatic inline int\r\nip6_tnl_dev_init_gen(struct net_device *dev)\r\n{\r\nstruct ip6_tnl *t = netdev_priv(dev);\r\nt->dev = dev;\r\ndev->tstats = alloc_percpu(struct pcpu_tstats);\r\nif (!dev->tstats)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int ip6_tnl_dev_init(struct net_device *dev)\r\n{\r\nstruct ip6_tnl *t = netdev_priv(dev);\r\nint err = ip6_tnl_dev_init_gen(dev);\r\nif (err)\r\nreturn err;\r\nip6_tnl_link_config(t);\r\nreturn 0;\r\n}\r\nstatic int __net_init ip6_fb_tnl_dev_init(struct net_device *dev)\r\n{\r\nstruct ip6_tnl *t = netdev_priv(dev);\r\nstruct net *net = dev_net(dev);\r\nstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\r\nint err = ip6_tnl_dev_init_gen(dev);\r\nif (err)\r\nreturn err;\r\nt->parms.proto = IPPROTO_IPV6;\r\ndev_hold(dev);\r\nrcu_assign_pointer(ip6n->tnls_wc[0], t);\r\nreturn 0;\r\n}\r\nstatic void __net_exit ip6_tnl_destroy_tunnels(struct ip6_tnl_net *ip6n)\r\n{\r\nint h;\r\nstruct ip6_tnl *t;\r\nLIST_HEAD(list);\r\nfor (h = 0; h < HASH_SIZE; h++) {\r\nt = rtnl_dereference(ip6n->tnls_r_l[h]);\r\nwhile (t != NULL) {\r\nunregister_netdevice_queue(t->dev, &list);\r\nt = rtnl_dereference(t->next);\r\n}\r\n}\r\nt = rtnl_dereference(ip6n->tnls_wc[0]);\r\nunregister_netdevice_queue(t->dev, &list);\r\nunregister_netdevice_many(&list);\r\n}\r\nstatic int __net_init ip6_tnl_init_net(struct net *net)\r\n{\r\nstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\r\nstruct ip6_tnl *t = NULL;\r\nint err;\r\nip6n->tnls[0] = ip6n->tnls_wc;\r\nip6n->tnls[1] = ip6n->tnls_r_l;\r\nerr = -ENOMEM;\r\nip6n->fb_tnl_dev = alloc_netdev(sizeof(struct ip6_tnl), "ip6tnl0",\r\nip6_tnl_dev_setup);\r\nif (!ip6n->fb_tnl_dev)\r\ngoto err_alloc_dev;\r\ndev_net_set(ip6n->fb_tnl_dev, net);\r\nerr = ip6_fb_tnl_dev_init(ip6n->fb_tnl_dev);\r\nif (err < 0)\r\ngoto err_register;\r\nerr = register_netdev(ip6n->fb_tnl_dev);\r\nif (err < 0)\r\ngoto err_register;\r\nt = netdev_priv(ip6n->fb_tnl_dev);\r\nstrcpy(t->parms.name, ip6n->fb_tnl_dev->name);\r\nreturn 0;\r\nerr_register:\r\nip6_dev_free(ip6n->fb_tnl_dev);\r\nerr_alloc_dev:\r\nreturn err;\r\n}\r\nstatic void __net_exit ip6_tnl_exit_net(struct net *net)\r\n{\r\nstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\r\nrtnl_lock();\r\nip6_tnl_destroy_tunnels(ip6n);\r\nrtnl_unlock();\r\n}\r\nstatic int __init ip6_tunnel_init(void)\r\n{\r\nint err;\r\nerr = register_pernet_device(&ip6_tnl_net_ops);\r\nif (err < 0)\r\ngoto out_pernet;\r\nerr = xfrm6_tunnel_register(&ip4ip6_handler, AF_INET);\r\nif (err < 0) {\r\nprintk(KERN_ERR "ip6_tunnel init: can't register ip4ip6\n");\r\ngoto out_ip4ip6;\r\n}\r\nerr = xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6);\r\nif (err < 0) {\r\nprintk(KERN_ERR "ip6_tunnel init: can't register ip6ip6\n");\r\ngoto out_ip6ip6;\r\n}\r\nreturn 0;\r\nout_ip6ip6:\r\nxfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET);\r\nout_ip4ip6:\r\nunregister_pernet_device(&ip6_tnl_net_ops);\r\nout_pernet:\r\nreturn err;\r\n}\r\nstatic void __exit ip6_tunnel_cleanup(void)\r\n{\r\nif (xfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET))\r\nprintk(KERN_INFO "ip6_tunnel close: can't deregister ip4ip6\n");\r\nif (xfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6))\r\nprintk(KERN_INFO "ip6_tunnel close: can't deregister ip6ip6\n");\r\nunregister_pernet_device(&ip6_tnl_net_ops);\r\n}
