static void mid_get_fuse_settings(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct pci_dev *pci_root = pci_get_bus_and_slot(0, 0);\r\nuint32_t fuse_value = 0;\r\nuint32_t fuse_value_tmp = 0;\r\n#define FB_REG06 0xD0810600\r\n#define FB_MIPI_DISABLE (1 << 11)\r\n#define FB_REG09 0xD0810900\r\n#define FB_REG09 0xD0810900\r\n#define FB_SKU_MASK 0x7000\r\n#define FB_SKU_SHIFT 12\r\n#define FB_SKU_100 0\r\n#define FB_SKU_100L 1\r\n#define FB_SKU_83 2\r\nif (pci_root == NULL) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\npci_write_config_dword(pci_root, 0xD0, FB_REG06);\r\npci_read_config_dword(pci_root, 0xD4, &fuse_value);\r\nif (IS_MRST(dev))\r\ndev_priv->iLVDS_enable = fuse_value & FB_MIPI_DISABLE;\r\nDRM_INFO("internal display is %s\n",\r\ndev_priv->iLVDS_enable ? "LVDS display" : "MIPI display");\r\nif (dev_priv->iLVDS_enable) {\r\ndev_priv->is_lvds_on = true;\r\ndev_priv->is_mipi_on = false;\r\n} else {\r\ndev_priv->is_mipi_on = true;\r\ndev_priv->is_lvds_on = false;\r\n}\r\ndev_priv->video_device_fuse = fuse_value;\r\npci_write_config_dword(pci_root, 0xD0, FB_REG09);\r\npci_read_config_dword(pci_root, 0xD4, &fuse_value);\r\ndev_dbg(dev->dev, "SKU values is 0x%x.\n", fuse_value);\r\nfuse_value_tmp = (fuse_value & FB_SKU_MASK) >> FB_SKU_SHIFT;\r\ndev_priv->fuse_reg_value = fuse_value;\r\nswitch (fuse_value_tmp) {\r\ncase FB_SKU_100:\r\ndev_priv->core_freq = 200;\r\nbreak;\r\ncase FB_SKU_100L:\r\ndev_priv->core_freq = 100;\r\nbreak;\r\ncase FB_SKU_83:\r\ndev_priv->core_freq = 166;\r\nbreak;\r\ndefault:\r\ndev_warn(dev->dev, "Invalid SKU values, SKU value = 0x%08x\n",\r\nfuse_value_tmp);\r\ndev_priv->core_freq = 0;\r\n}\r\ndev_dbg(dev->dev, "LNC core clk is %dMHz.\n", dev_priv->core_freq);\r\npci_dev_put(pci_root);\r\n}\r\nstatic void mid_get_pci_revID(struct drm_psb_private *dev_priv)\r\n{\r\nuint32_t platform_rev_id = 0;\r\nstruct pci_dev *pci_gfx_root = pci_get_bus_and_slot(0, PCI_DEVFN(2, 0));\r\nif (pci_gfx_root == NULL) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\npci_read_config_dword(pci_gfx_root, 0x08, &platform_rev_id);\r\ndev_priv->platform_rev_id = (uint8_t) platform_rev_id;\r\npci_dev_put(pci_gfx_root);\r\ndev_dbg(dev_priv->dev->dev, "platform_rev_id is %x\n",\r\ndev_priv->platform_rev_id);\r\n}\r\nstatic void mid_get_vbt_data(struct drm_psb_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct oaktrail_vbt *vbt = &dev_priv->vbt_data;\r\nu32 addr;\r\nu16 new_size;\r\nu8 *vbt_virtual;\r\nu8 bpi;\r\nu8 number_desc = 0;\r\nstruct oaktrail_timing_info *dp_ti = &dev_priv->gct_data.DTD;\r\nstruct gct_r10_timing_info ti;\r\nvoid *pGCT;\r\nstruct pci_dev *pci_gfx_root = pci_get_bus_and_slot(0, PCI_DEVFN(2, 0));\r\npci_read_config_dword(pci_gfx_root, 0xFC, &addr);\r\npci_dev_put(pci_gfx_root);\r\ndev_dbg(dev->dev, "drm platform config address is %x\n", addr);\r\nif (addr == 0) {\r\nvbt->size = 0;\r\nreturn;\r\n}\r\nvbt_virtual = ioremap(addr, sizeof(*vbt));\r\nif (vbt_virtual == NULL) {\r\nvbt->size = 0;\r\nreturn;\r\n}\r\nmemcpy(vbt, vbt_virtual, sizeof(*vbt));\r\niounmap(vbt_virtual);\r\nif (memcmp(vbt->signature, "$GCT", 4)) {\r\nvbt->size = 0;\r\nreturn;\r\n}\r\ndev_dbg(dev->dev, "GCT revision is %x\n", vbt->revision);\r\nswitch (vbt->revision) {\r\ncase 0:\r\nvbt->oaktrail_gct = ioremap(addr + sizeof(*vbt) - 4,\r\nvbt->size - sizeof(*vbt) + 4);\r\npGCT = vbt->oaktrail_gct;\r\nbpi = ((struct oaktrail_gct_v1 *)pGCT)->PD.BootPanelIndex;\r\ndev_priv->gct_data.bpi = bpi;\r\ndev_priv->gct_data.pt =\r\n((struct oaktrail_gct_v1 *)pGCT)->PD.PanelType;\r\nmemcpy(&dev_priv->gct_data.DTD,\r\n&((struct oaktrail_gct_v1 *)pGCT)->panel[bpi].DTD,\r\nsizeof(struct oaktrail_timing_info));\r\ndev_priv->gct_data.Panel_Port_Control =\r\n((struct oaktrail_gct_v1 *)pGCT)->panel[bpi].Panel_Port_Control;\r\ndev_priv->gct_data.Panel_MIPI_Display_Descriptor =\r\n((struct oaktrail_gct_v1 *)pGCT)->panel[bpi].Panel_MIPI_Display_Descriptor;\r\nbreak;\r\ncase 1:\r\nvbt->oaktrail_gct = ioremap(addr + sizeof(*vbt) - 4,\r\nvbt->size - sizeof(*vbt) + 4);\r\npGCT = vbt->oaktrail_gct;\r\nbpi = ((struct oaktrail_gct_v2 *)pGCT)->PD.BootPanelIndex;\r\ndev_priv->gct_data.bpi = bpi;\r\ndev_priv->gct_data.pt =\r\n((struct oaktrail_gct_v2 *)pGCT)->PD.PanelType;\r\nmemcpy(&dev_priv->gct_data.DTD,\r\n&((struct oaktrail_gct_v2 *)pGCT)->panel[bpi].DTD,\r\nsizeof(struct oaktrail_timing_info));\r\ndev_priv->gct_data.Panel_Port_Control =\r\n((struct oaktrail_gct_v2 *)pGCT)->panel[bpi].Panel_Port_Control;\r\ndev_priv->gct_data.Panel_MIPI_Display_Descriptor =\r\n((struct oaktrail_gct_v2 *)pGCT)->panel[bpi].Panel_MIPI_Display_Descriptor;\r\nbreak;\r\ncase 0x10:\r\nnew_size = vbt->checksum;\r\nnew_size |= ((0xff & (unsigned int)(long)vbt->oaktrail_gct)) << 8;\r\nvbt->checksum = vbt->size;\r\nif (new_size > 0xff)\r\nvbt->size = 0xff;\r\nelse\r\nvbt->size = new_size;\r\nnumber_desc = ((0xff00 & (unsigned int)(long)vbt->oaktrail_gct)) >> 8;\r\nbpi = ((0xff0000 & (unsigned int)(long)vbt->oaktrail_gct)) >> 16;\r\nvbt->oaktrail_gct = ioremap(addr + GCT_R10_HEADER_SIZE,\r\nGCT_R10_DISPLAY_DESC_SIZE * number_desc);\r\npGCT = vbt->oaktrail_gct;\r\npGCT = (u8 *)pGCT + (bpi*GCT_R10_DISPLAY_DESC_SIZE);\r\ndev_priv->gct_data.bpi = bpi;\r\nmemcpy(&ti, pGCT, sizeof(struct gct_r10_timing_info));\r\ndp_ti->pixel_clock = ti.pixel_clock;\r\ndp_ti->hactive_hi = ti.hactive_hi;\r\ndp_ti->hactive_lo = ti.hactive_lo;\r\ndp_ti->hblank_hi = ti.hblank_hi;\r\ndp_ti->hblank_lo = ti.hblank_lo;\r\ndp_ti->hsync_offset_hi = ti.hsync_offset_hi;\r\ndp_ti->hsync_offset_lo = ti.hsync_offset_lo;\r\ndp_ti->hsync_pulse_width_hi = ti.hsync_pulse_width_hi;\r\ndp_ti->hsync_pulse_width_lo = ti.hsync_pulse_width_lo;\r\ndp_ti->vactive_hi = ti.vactive_hi;\r\ndp_ti->vactive_lo = ti.vactive_lo;\r\ndp_ti->vblank_hi = ti.vblank_hi;\r\ndp_ti->vblank_lo = ti.vblank_lo;\r\ndp_ti->vsync_offset_hi = ti.vsync_offset_hi;\r\ndp_ti->vsync_offset_lo = ti.vsync_offset_lo;\r\ndp_ti->vsync_pulse_width_hi = ti.vsync_pulse_width_hi;\r\ndp_ti->vsync_pulse_width_lo = ti.vsync_pulse_width_lo;\r\ndev_priv->gct_data.Panel_MIPI_Display_Descriptor =\r\n*((u8 *)pGCT + 0x0d);\r\ndev_priv->gct_data.Panel_MIPI_Display_Descriptor |=\r\n(*((u8 *)pGCT + 0x0e)) << 8;\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "Unknown revision of GCT!\n");\r\nvbt->size = 0;\r\n}\r\n}\r\nint mid_chip_setup(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nmid_get_fuse_settings(dev);\r\nmid_get_vbt_data(dev_priv);\r\nmid_get_pci_revID(dev_priv);\r\nreturn 0;\r\n}
