static void __init fix_hypertransport_config(int num, int slot, int func)\r\n{\r\nu32 htcfg;\r\nhtcfg = read_pci_config(num, slot, func, 0x68);\r\nif (htcfg & (1 << 18)) {\r\nprintk(KERN_INFO "Detected use of extended apic ids "\r\n"on hypertransport bus\n");\r\nif ((htcfg & (1 << 17)) == 0) {\r\nprintk(KERN_INFO "Enabling hypertransport extended "\r\n"apic interrupt broadcast\n");\r\nprintk(KERN_INFO "Note this is a bios bug, "\r\n"please contact your hw vendor\n");\r\nhtcfg |= (1 << 17);\r\nwrite_pci_config(num, slot, func, 0x68, htcfg);\r\n}\r\n}\r\n}\r\nstatic void __init via_bugs(int num, int slot, int func)\r\n{\r\n#ifdef CONFIG_GART_IOMMU\r\nif ((max_pfn > MAX_DMA32_PFN || force_iommu) &&\r\n!gart_iommu_aperture_allowed) {\r\nprintk(KERN_INFO\r\n"Looks like a VIA chipset. Disabling IOMMU."\r\n" Override with iommu=allowed\n");\r\ngart_iommu_aperture_disabled = 1;\r\n}\r\n#endif\r\n}\r\nstatic int __init nvidia_hpet_check(struct acpi_table_header *header)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __init nvidia_bugs(int num, int slot, int func)\r\n{\r\n#ifdef CONFIG_ACPI\r\n#ifdef CONFIG_X86_IO_APIC\r\nif (acpi_use_timer_override)\r\nreturn;\r\nif (acpi_table_parse(ACPI_SIG_HPET, nvidia_hpet_check)) {\r\nacpi_skip_timer_override = 1;\r\nprintk(KERN_INFO "Nvidia board "\r\n"detected. Ignoring ACPI "\r\n"timer override.\n");\r\nprintk(KERN_INFO "If you got timer trouble "\r\n"try acpi_use_timer_override\n");\r\n}\r\n#endif\r\n#endif\r\n}\r\nstatic u32 __init ati_ixp4x0_rev(int num, int slot, int func)\r\n{\r\nu32 d;\r\nu8 b;\r\nb = read_pci_config_byte(num, slot, func, 0xac);\r\nb &= ~(1<<5);\r\nwrite_pci_config_byte(num, slot, func, 0xac, b);\r\nd = read_pci_config(num, slot, func, 0x70);\r\nd |= 1<<8;\r\nwrite_pci_config(num, slot, func, 0x70, d);\r\nd = read_pci_config(num, slot, func, 0x8);\r\nd &= 0xff;\r\nreturn d;\r\n}\r\nstatic void __init ati_bugs(int num, int slot, int func)\r\n{\r\nu32 d;\r\nu8 b;\r\nif (acpi_use_timer_override)\r\nreturn;\r\nd = ati_ixp4x0_rev(num, slot, func);\r\nif (d < 0x82)\r\nacpi_skip_timer_override = 1;\r\nelse {\r\noutb(0x72, 0xcd6); b = inb(0xcd7);\r\nif (!(b & 0x2))\r\nacpi_skip_timer_override = 1;\r\n}\r\nif (acpi_skip_timer_override) {\r\nprintk(KERN_INFO "SB4X0 revision 0x%x\n", d);\r\nprintk(KERN_INFO "Ignoring ACPI timer override.\n");\r\nprintk(KERN_INFO "If you got timer trouble "\r\n"try acpi_use_timer_override\n");\r\n}\r\n}\r\nstatic u32 __init ati_sbx00_rev(int num, int slot, int func)\r\n{\r\nu32 d;\r\nd = read_pci_config(num, slot, func, 0x8);\r\nd &= 0xff;\r\nreturn d;\r\n}\r\nstatic void __init ati_bugs_contd(int num, int slot, int func)\r\n{\r\nu32 d, rev;\r\nrev = ati_sbx00_rev(num, slot, func);\r\nif (rev >= 0x40)\r\nacpi_fix_pin2_polarity = 1;\r\nif (rev >= 0x39)\r\nreturn;\r\nif (acpi_use_timer_override)\r\nreturn;\r\nd = read_pci_config(num, slot, func, 0x64);\r\nif (!(d & (1<<14)))\r\nacpi_skip_timer_override = 1;\r\nif (acpi_skip_timer_override) {\r\nprintk(KERN_INFO "SB600 revision 0x%x\n", rev);\r\nprintk(KERN_INFO "Ignoring ACPI timer override.\n");\r\nprintk(KERN_INFO "If you got timer trouble "\r\n"try acpi_use_timer_override\n");\r\n}\r\n}\r\nstatic void __init ati_bugs(int num, int slot, int func)\r\n{\r\n}\r\nstatic void __init ati_bugs_contd(int num, int slot, int func)\r\n{\r\n}\r\nstatic int __init check_dev_quirk(int num, int slot, int func)\r\n{\r\nu16 class;\r\nu16 vendor;\r\nu16 device;\r\nu8 type;\r\nint i;\r\nclass = read_pci_config_16(num, slot, func, PCI_CLASS_DEVICE);\r\nif (class == 0xffff)\r\nreturn -1;\r\nvendor = read_pci_config_16(num, slot, func, PCI_VENDOR_ID);\r\ndevice = read_pci_config_16(num, slot, func, PCI_DEVICE_ID);\r\nfor (i = 0; early_qrk[i].f != NULL; i++) {\r\nif (((early_qrk[i].vendor == PCI_ANY_ID) ||\r\n(early_qrk[i].vendor == vendor)) &&\r\n((early_qrk[i].device == PCI_ANY_ID) ||\r\n(early_qrk[i].device == device)) &&\r\n(!((early_qrk[i].class ^ class) &\r\nearly_qrk[i].class_mask))) {\r\nif ((early_qrk[i].flags &\r\nQFLAG_DONE) != QFLAG_DONE)\r\nearly_qrk[i].f(num, slot, func);\r\nearly_qrk[i].flags |= QFLAG_APPLIED;\r\n}\r\n}\r\ntype = read_pci_config_byte(num, slot, func,\r\nPCI_HEADER_TYPE);\r\nif (!(type & 0x80))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nvoid __init early_quirks(void)\r\n{\r\nint slot, func;\r\nif (!early_pci_allowed())\r\nreturn;\r\nfor (slot = 0; slot < 32; slot++)\r\nfor (func = 0; func < 8; func++) {\r\nif (check_dev_quirk(0, slot, func))\r\nbreak;\r\n}\r\n}
