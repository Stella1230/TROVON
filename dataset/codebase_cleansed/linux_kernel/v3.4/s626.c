static int __devinit driver_s626_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nreturn comedi_pci_auto_config(dev, driver_s626.driver_name);\r\n}\r\nstatic void __devexit driver_s626_pci_remove(struct pci_dev *dev)\r\n{\r\ncomedi_pci_auto_unconfig(dev);\r\n}\r\nstatic int __init driver_s626_init_module(void)\r\n{\r\nint retval;\r\nretval = comedi_driver_register(&driver_s626);\r\nif (retval < 0)\r\nreturn retval;\r\ndriver_s626_pci_driver.name = (char *)driver_s626.driver_name;\r\nreturn pci_register_driver(&driver_s626_pci_driver);\r\n}\r\nstatic void __exit driver_s626_cleanup_module(void)\r\n{\r\npci_unregister_driver(&driver_s626_pci_driver);\r\ncomedi_driver_unregister(&driver_s626);\r\n}\r\nstatic int s626_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nint result;\r\nint i;\r\nint ret;\r\nresource_size_t resourceStart;\r\ndma_addr_t appdma;\r\nstruct comedi_subdevice *s;\r\nconst struct pci_device_id *ids;\r\nstruct pci_dev *pdev = NULL;\r\nif (alloc_private(dev, sizeof(struct s626_private)) < 0)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < (ARRAY_SIZE(s626_pci_table) - 1) && !pdev; i++) {\r\nids = &s626_pci_table[i];\r\ndo {\r\npdev = pci_get_subsys(ids->vendor, ids->device,\r\nids->subvendor, ids->subdevice,\r\npdev);\r\nif ((it->options[0] || it->options[1]) && pdev) {\r\nif (pdev->bus->number == it->options[0] &&\r\nPCI_SLOT(pdev->devfn) == it->options[1])\r\nbreak;\r\n} else\r\nbreak;\r\n} while (1);\r\n}\r\ndevpriv->pdev = pdev;\r\nif (pdev == NULL) {\r\nprintk(KERN_ERR "s626_attach: Board not present!!!\n");\r\nreturn -ENODEV;\r\n}\r\nresult = comedi_pci_enable(pdev, "s626");\r\nif (result < 0) {\r\nprintk(KERN_ERR "s626_attach: comedi_pci_enable fails\n");\r\nreturn -ENODEV;\r\n}\r\ndevpriv->got_regions = 1;\r\nresourceStart = pci_resource_start(devpriv->pdev, 0);\r\ndevpriv->base_addr = ioremap(resourceStart, SIZEOF_ADDRESS_SPACE);\r\nif (devpriv->base_addr == NULL) {\r\nprintk(KERN_ERR "s626_attach: IOREMAP failed\n");\r\nreturn -ENODEV;\r\n}\r\nif (devpriv->base_addr) {\r\nwritel(0, devpriv->base_addr + P_IER);\r\nwritel(MC1_SOFT_RESET, devpriv->base_addr + P_MC1);\r\nDEBUG("s626_attach: DMA ALLOCATION\n");\r\ndevpriv->allocatedBuf = 0;\r\ndevpriv->ANABuf.LogicalBase =\r\npci_alloc_consistent(devpriv->pdev, DMABUF_SIZE, &appdma);\r\nif (devpriv->ANABuf.LogicalBase == NULL) {\r\nprintk(KERN_ERR "s626_attach: DMA Memory mapping error\n");\r\nreturn -ENOMEM;\r\n}\r\ndevpriv->ANABuf.PhysicalBase = appdma;\r\nDEBUG\r\n("s626_attach: AllocDMAB ADC Logical=%p, bsize=%d, Physical=0x%x\n",\r\ndevpriv->ANABuf.LogicalBase, DMABUF_SIZE,\r\n(uint32_t) devpriv->ANABuf.PhysicalBase);\r\ndevpriv->allocatedBuf++;\r\ndevpriv->RPSBuf.LogicalBase =\r\npci_alloc_consistent(devpriv->pdev, DMABUF_SIZE, &appdma);\r\nif (devpriv->RPSBuf.LogicalBase == NULL) {\r\nprintk(KERN_ERR "s626_attach: DMA Memory mapping error\n");\r\nreturn -ENOMEM;\r\n}\r\ndevpriv->RPSBuf.PhysicalBase = appdma;\r\nDEBUG\r\n("s626_attach: AllocDMAB RPS Logical=%p, bsize=%d, Physical=0x%x\n",\r\ndevpriv->RPSBuf.LogicalBase, DMABUF_SIZE,\r\n(uint32_t) devpriv->RPSBuf.PhysicalBase);\r\ndevpriv->allocatedBuf++;\r\n}\r\ndev->board_ptr = s626_boards;\r\ndev->board_name = thisboard->name;\r\nif (alloc_subdevices(dev, 6) < 0)\r\nreturn -ENOMEM;\r\ndev->iobase = (unsigned long)devpriv->base_addr;\r\ndev->irq = devpriv->pdev->irq;\r\nif (dev->irq == 0) {\r\nprintk(KERN_ERR " unknown irq (bad)\n");\r\n} else {\r\nret = request_irq(dev->irq, s626_irq_handler, IRQF_SHARED,\r\n"s626", dev);\r\nif (ret < 0) {\r\nprintk(KERN_ERR " irq not available\n");\r\ndev->irq = 0;\r\n}\r\n}\r\nDEBUG("s626_attach: -- it opts %d,%d --\n",\r\nit->options[0], it->options[1]);\r\ns = dev->subdevices + 0;\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_CMD_READ;\r\ns->n_chan = thisboard->ai_chans;\r\ns->maxdata = (0xffff >> 2);\r\ns->range_table = &s626_range_table;\r\ns->len_chanlist = thisboard->ai_chans;\r\ns->insn_config = s626_ai_insn_config;\r\ns->insn_read = s626_ai_insn_read;\r\ns->do_cmd = s626_ai_cmd;\r\ns->do_cmdtest = s626_ai_cmdtest;\r\ns->cancel = s626_ai_cancel;\r\ns = dev->subdevices + 1;\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = thisboard->ao_chans;\r\ns->maxdata = (0x3fff);\r\ns->range_table = &range_bipolar10;\r\ns->insn_write = s626_ao_winsn;\r\ns->insn_read = s626_ao_rinsn;\r\ns = dev->subdevices + 2;\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = S626_DIO_CHANNELS;\r\ns->maxdata = 1;\r\ns->io_bits = 0xffff;\r\ns->private = &dio_private_A;\r\ns->range_table = &range_digital;\r\ns->insn_config = s626_dio_insn_config;\r\ns->insn_bits = s626_dio_insn_bits;\r\ns = dev->subdevices + 3;\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = 16;\r\ns->maxdata = 1;\r\ns->io_bits = 0xffff;\r\ns->private = &dio_private_B;\r\ns->range_table = &range_digital;\r\ns->insn_config = s626_dio_insn_config;\r\ns->insn_bits = s626_dio_insn_bits;\r\ns = dev->subdevices + 4;\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = 16;\r\ns->maxdata = 1;\r\ns->io_bits = 0xffff;\r\ns->private = &dio_private_C;\r\ns->range_table = &range_digital;\r\ns->insn_config = s626_dio_insn_config;\r\ns->insn_bits = s626_dio_insn_bits;\r\ns = dev->subdevices + 5;\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE | SDF_LSAMPL;\r\ns->n_chan = thisboard->enc_chans;\r\ns->private = enc_private_data;\r\ns->insn_config = s626_enc_insn_config;\r\ns->insn_read = s626_enc_insn_read;\r\ns->insn_write = s626_enc_insn_write;\r\ns->maxdata = 0xffffff;\r\ns->range_table = &range_unknown;\r\ndevpriv->ai_cmd_running = 0;\r\nif (devpriv->base_addr && (devpriv->allocatedBuf == 2)) {\r\ndma_addr_t pPhysBuf;\r\nuint16_t chan;\r\nMC_ENABLE(P_MC1, MC1_DEBI | MC1_AUDIO | MC1_I2C);\r\nWR7146(P_DEBICFG, DEBI_CFG_SLAVE16\r\n| (DEBI_TOUT << DEBI_CFG_TOUT_BIT)\r\n|DEBI_SWAP\r\n| DEBI_CFG_INTEL);\r\nDEBUG("s626_attach: %d debi init -- %d\n",\r\nDEBI_CFG_SLAVE16 | (DEBI_TOUT << DEBI_CFG_TOUT_BIT) |\r\nDEBI_SWAP | DEBI_CFG_INTEL,\r\nDEBI_CFG_INTEL | DEBI_CFG_TOQ | DEBI_CFG_INCQ |\r\nDEBI_CFG_16Q);\r\nWR7146(P_DEBIPAGE, DEBI_PAGE_DISABLE);\r\nWR7146(P_GPIO, GPIO_BASE | GPIO1_HI);\r\ndevpriv->I2CAdrs = 0xA0;\r\nWR7146(P_I2CSTAT, I2C_CLKSEL | I2C_ABORT);\r\nMC_ENABLE(P_MC2, MC2_UPLD_IIC);\r\nwhile ((RR7146(P_MC2) & MC2_UPLD_IIC) == 0)\r\n;\r\nfor (i = 0; i < 2; i++) {\r\nWR7146(P_I2CSTAT, I2C_CLKSEL);\r\nMC_ENABLE(P_MC2, MC2_UPLD_IIC);\r\nwhile (!MC_TEST(P_MC2, MC2_UPLD_IIC))\r\n;\r\n}\r\nWR7146(P_ACON2, ACON2_INIT);\r\nWR7146(P_TSL1, RSD1 | SIB_A1);\r\nWR7146(P_TSL1 + 4, RSD1 | SIB_A1 | EOS);\r\nWR7146(P_ACON1, ACON1_ADCSTART);\r\nWR7146(P_RPSADDR1, (uint32_t) devpriv->RPSBuf.PhysicalBase);\r\nWR7146(P_RPSPAGE1, 0);\r\nWR7146(P_RPS1_TOUT, 0);\r\nWR7146(P_PCI_BT_A, 0);\r\npPhysBuf =\r\ndevpriv->ANABuf.PhysicalBase +\r\n(DAC_WDMABUF_OS * sizeof(uint32_t));\r\nWR7146(P_BASEA2_OUT, (uint32_t) pPhysBuf);\r\nWR7146(P_PROTA2_OUT, (uint32_t) (pPhysBuf + sizeof(uint32_t)));\r\ndevpriv->pDacWBuf =\r\n(uint32_t *) devpriv->ANABuf.LogicalBase + DAC_WDMABUF_OS;\r\nWR7146(P_PAGEA2_OUT, 8);\r\nSETVECT(0, XSD2 | RSD3 | SIB_A2 | EOS);\r\nSETVECT(1, LF_A2);\r\nWR7146(P_ACON1, ACON1_DACSTART);\r\nLoadTrimDACs(dev);\r\nLoadTrimDACs(dev);\r\nfor (chan = 0; chan < S626_DAC_CHANNELS; chan++)\r\nSetDAC(dev, chan, 0);\r\ndevpriv->ChargeEnabled = 0;\r\ndevpriv->WDInterval = 0;\r\ndevpriv->CounterIntEnabs = 0;\r\nCountersInit(dev);\r\nWriteMISC2(dev, (uint16_t) (DEBIread(dev,\r\nLP_RDMISC2) &\r\nMISC2_BATT_ENABLE));\r\ns626_dio_init(dev);\r\n}\r\nDEBUG("s626_attach: comedi%d s626 attached %04x\n", dev->minor,\r\n(uint32_t) devpriv->base_addr);\r\nreturn 1;\r\n}\r\nstatic unsigned int s626_ai_reg_to_uint(int data)\r\n{\r\nunsigned int tempdata;\r\ntempdata = (data >> 18);\r\nif (tempdata & 0x2000)\r\ntempdata &= 0x1fff;\r\nelse\r\ntempdata += (1 << 13);\r\nreturn tempdata;\r\n}\r\nstatic irqreturn_t s626_irq_handler(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s;\r\nstruct comedi_cmd *cmd;\r\nstruct enc_private *k;\r\nunsigned long flags;\r\nint32_t *readaddr;\r\nuint32_t irqtype, irqstatus;\r\nint i = 0;\r\nshort tempdata;\r\nuint8_t group;\r\nuint16_t irqbit;\r\nDEBUG("s626_irq_handler: interrupt request received!!!\n");\r\nif (dev->attached == 0)\r\nreturn IRQ_NONE;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nirqstatus = readl(devpriv->base_addr + P_IER);\r\nirqtype = readl(devpriv->base_addr + P_ISR);\r\nwritel(0, devpriv->base_addr + P_IER);\r\nwritel(irqtype, devpriv->base_addr + P_ISR);\r\nDEBUG("s626_irq_handler: interrupt type %d\n", irqtype);\r\nswitch (irqtype) {\r\ncase IRQ_RPS1:\r\nDEBUG("s626_irq_handler: RPS1 irq detected\n");\r\ns = dev->subdevices;\r\ncmd = &(s->async->cmd);\r\nreadaddr = (int32_t *) devpriv->ANABuf.LogicalBase + 1;\r\nfor (i = 0; i < (s->async->cmd.chanlist_len); i++) {\r\ntempdata = s626_ai_reg_to_uint((int)*readaddr);\r\nreadaddr++;\r\nif (cfc_write_to_buffer(s, tempdata) == 0)\r\nprintk\r\n("s626_irq_handler: cfc_write_to_buffer error!\n");\r\nDEBUG("s626_irq_handler: ai channel %d acquired: %d\n",\r\ni, tempdata);\r\n}\r\ns->async->events |= COMEDI_CB_EOS;\r\nif (!(devpriv->ai_continous))\r\ndevpriv->ai_sample_count--;\r\nif (devpriv->ai_sample_count <= 0) {\r\ndevpriv->ai_cmd_running = 0;\r\nMC_DISABLE(P_MC1, MC1_ERPS1);\r\ns->async->events |= COMEDI_CB_EOA;\r\nirqstatus = 0;\r\n}\r\nif (devpriv->ai_cmd_running && cmd->scan_begin_src == TRIG_EXT) {\r\nDEBUG\r\n("s626_irq_handler: enable interrupt on dio channel %d\n",\r\ncmd->scan_begin_arg);\r\ns626_dio_set_irq(dev, cmd->scan_begin_arg);\r\nDEBUG("s626_irq_handler: External trigger is set!!!\n");\r\n}\r\nDEBUG("s626_irq_handler: events %d\n", s->async->events);\r\ncomedi_event(dev, s);\r\nbreak;\r\ncase IRQ_GPIO3:\r\nDEBUG("s626_irq_handler: GPIO3 irq detected\n");\r\ns = dev->subdevices;\r\ncmd = &(s->async->cmd);\r\nfor (group = 0; group < S626_DIO_BANKS; group++) {\r\nirqbit = 0;\r\nirqbit = DEBIread(dev,\r\n((struct dio_private *)(dev->\r\nsubdevices +\r\n2 +\r\ngroup)->\r\nprivate)->RDCapFlg);\r\nif (irqbit) {\r\ns626_dio_reset_irq(dev, group, irqbit);\r\nDEBUG\r\n("s626_irq_handler: check interrupt on dio group %d %d\n",\r\ngroup, i);\r\nif (devpriv->ai_cmd_running) {\r\nif ((irqbit >> (cmd->start_arg -\r\n(16 * group)))\r\n== 1 && cmd->start_src == TRIG_EXT) {\r\nDEBUG\r\n("s626_irq_handler: Edge capture interrupt received from channel %d\n",\r\ncmd->start_arg);\r\nMC_ENABLE(P_MC1, MC1_ERPS1);\r\nDEBUG\r\n("s626_irq_handler: acquisition start triggered!!!\n");\r\nif (cmd->scan_begin_src ==\r\nTRIG_EXT) {\r\nDEBUG\r\n("s626_ai_cmd: enable interrupt on dio channel %d\n",\r\ncmd->\r\nscan_begin_arg);\r\ns626_dio_set_irq(dev,\r\ncmd->scan_begin_arg);\r\nDEBUG\r\n("s626_irq_handler: External scan trigger is set!!!\n");\r\n}\r\n}\r\nif ((irqbit >> (cmd->scan_begin_arg -\r\n(16 * group)))\r\n== 1\r\n&& cmd->scan_begin_src ==\r\nTRIG_EXT) {\r\nDEBUG\r\n("s626_irq_handler: Edge capture interrupt received from channel %d\n",\r\ncmd->scan_begin_arg);\r\nMC_ENABLE(P_MC2, MC2_ADC_RPS);\r\nDEBUG\r\n("s626_irq_handler: scan triggered!!! %d\n",\r\ndevpriv->ai_sample_count);\r\nif (cmd->convert_src ==\r\nTRIG_EXT) {\r\nDEBUG\r\n("s626_ai_cmd: enable interrupt on dio channel %d group %d\n",\r\ncmd->convert_arg -\r\n(16 * group),\r\ngroup);\r\ndevpriv->ai_convert_count\r\n= cmd->chanlist_len;\r\ns626_dio_set_irq(dev,\r\ncmd->convert_arg);\r\nDEBUG\r\n("s626_irq_handler: External convert trigger is set!!!\n");\r\n}\r\nif (cmd->convert_src ==\r\nTRIG_TIMER) {\r\nk = &encpriv[5];\r\ndevpriv->ai_convert_count\r\n= cmd->chanlist_len;\r\nk->SetEnable(dev, k,\r\nCLKENAB_ALWAYS);\r\n}\r\n}\r\nif ((irqbit >> (cmd->convert_arg -\r\n(16 * group)))\r\n== 1\r\n&& cmd->convert_src == TRIG_EXT) {\r\nDEBUG\r\n("s626_irq_handler: Edge capture interrupt received from channel %d\n",\r\ncmd->convert_arg);\r\nMC_ENABLE(P_MC2, MC2_ADC_RPS);\r\nDEBUG\r\n("s626_irq_handler: adc convert triggered!!!\n");\r\ndevpriv->ai_convert_count--;\r\nif (devpriv->ai_convert_count >\r\n0) {\r\nDEBUG\r\n("s626_ai_cmd: enable interrupt on dio channel %d group %d\n",\r\ncmd->convert_arg -\r\n(16 * group),\r\ngroup);\r\ns626_dio_set_irq(dev,\r\ncmd->convert_arg);\r\nDEBUG\r\n("s626_irq_handler: External trigger is set!!!\n");\r\n}\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\nirqbit = DEBIread(dev, LP_RDMISC2);\r\nDEBUG("s626_irq_handler: check counters interrupt %d\n",\r\nirqbit);\r\nif (irqbit & IRQ_COINT1A) {\r\nDEBUG\r\n("s626_irq_handler: interrupt on counter 1A overflow\n");\r\nk = &encpriv[0];\r\nk->ResetCapFlags(dev, k);\r\n}\r\nif (irqbit & IRQ_COINT2A) {\r\nDEBUG\r\n("s626_irq_handler: interrupt on counter 2A overflow\n");\r\nk = &encpriv[1];\r\nk->ResetCapFlags(dev, k);\r\n}\r\nif (irqbit & IRQ_COINT3A) {\r\nDEBUG\r\n("s626_irq_handler: interrupt on counter 3A overflow\n");\r\nk = &encpriv[2];\r\nk->ResetCapFlags(dev, k);\r\n}\r\nif (irqbit & IRQ_COINT1B) {\r\nDEBUG\r\n("s626_irq_handler: interrupt on counter 1B overflow\n");\r\nk = &encpriv[3];\r\nk->ResetCapFlags(dev, k);\r\n}\r\nif (irqbit & IRQ_COINT2B) {\r\nDEBUG\r\n("s626_irq_handler: interrupt on counter 2B overflow\n");\r\nk = &encpriv[4];\r\nk->ResetCapFlags(dev, k);\r\nif (devpriv->ai_convert_count > 0) {\r\ndevpriv->ai_convert_count--;\r\nif (devpriv->ai_convert_count == 0)\r\nk->SetEnable(dev, k, CLKENAB_INDEX);\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nDEBUG\r\n("s626_irq_handler: conver timer trigger!!! %d\n",\r\ndevpriv->ai_convert_count);\r\nMC_ENABLE(P_MC2, MC2_ADC_RPS);\r\n}\r\n}\r\n}\r\nif (irqbit & IRQ_COINT3B) {\r\nDEBUG\r\n("s626_irq_handler: interrupt on counter 3B overflow\n");\r\nk = &encpriv[5];\r\nk->ResetCapFlags(dev, k);\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nDEBUG\r\n("s626_irq_handler: scan timer trigger!!!\n");\r\nMC_ENABLE(P_MC2, MC2_ADC_RPS);\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nDEBUG\r\n("s626_irq_handler: convert timer trigger is set\n");\r\nk = &encpriv[4];\r\ndevpriv->ai_convert_count = cmd->chanlist_len;\r\nk->SetEnable(dev, k, CLKENAB_ALWAYS);\r\n}\r\n}\r\n}\r\nwritel(irqstatus, devpriv->base_addr + P_IER);\r\nDEBUG("s626_irq_handler: exit interrupt service routine.\n");\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s626_detach(struct comedi_device *dev)\r\n{\r\nif (devpriv) {\r\ndevpriv->ai_cmd_running = 0;\r\nif (devpriv->base_addr) {\r\nWR7146(P_IER, 0);\r\nWR7146(P_ISR, IRQ_GPIO3 | IRQ_RPS1);\r\nWriteMISC2(dev, 0);\r\nWR7146(P_MC1, MC1_SHUTDOWN);\r\nWR7146(P_ACON1, ACON1_BASE);\r\nCloseDMAB(dev, &devpriv->RPSBuf, DMABUF_SIZE);\r\nCloseDMAB(dev, &devpriv->ANABuf, DMABUF_SIZE);\r\n}\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (devpriv->base_addr)\r\niounmap(devpriv->base_addr);\r\nif (devpriv->pdev) {\r\nif (devpriv->got_regions)\r\ncomedi_pci_disable(devpriv->pdev);\r\npci_dev_put(devpriv->pdev);\r\n}\r\n}\r\nDEBUG("s626_detach: S626 detached!\n");\r\nreturn 0;\r\n}\r\nvoid ResetADC(struct comedi_device *dev, uint8_t * ppl)\r\n{\r\nregister uint32_t *pRPS;\r\nuint32_t JmpAdrs;\r\nuint16_t i;\r\nuint16_t n;\r\nuint32_t LocalPPL;\r\nstruct comedi_cmd *cmd = &(dev->subdevices->async->cmd);\r\nMC_DISABLE(P_MC1, MC1_ERPS1);\r\npRPS = (uint32_t *) devpriv->RPSBuf.LogicalBase;\r\nWR7146(P_RPSADDR1, (uint32_t) devpriv->RPSBuf.PhysicalBase);\r\nif (cmd != NULL && cmd->scan_begin_src != TRIG_FOLLOW) {\r\nDEBUG("ResetADC: scan_begin pause inserted\n");\r\n*pRPS++ = RPS_PAUSE | RPS_SIGADC;\r\n*pRPS++ = RPS_CLRSIGNAL | RPS_SIGADC;\r\n}\r\n*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);\r\n*pRPS++ = DEBI_CMD_WRWORD | LP_GSEL;\r\n*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);\r\n*pRPS++ = GSEL_BIPOLAR5V;\r\n*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;\r\n*pRPS++ = RPS_UPLOAD | RPS_DEBI;\r\n*pRPS++ = RPS_PAUSE | RPS_DEBI;\r\nfor (devpriv->AdcItems = 0; devpriv->AdcItems < 16; devpriv->AdcItems++) {\r\nLocalPPL =\r\n(*ppl << 8) | (*ppl & 0x10 ? GSEL_BIPOLAR5V :\r\nGSEL_BIPOLAR10V);\r\n*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);\r\n*pRPS++ = DEBI_CMD_WRWORD | LP_GSEL;\r\n*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);\r\n*pRPS++ = LocalPPL;\r\n*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;\r\n*pRPS++ = RPS_UPLOAD | RPS_DEBI;\r\n*pRPS++ = RPS_PAUSE | RPS_DEBI;\r\n*pRPS++ = RPS_LDREG | (P_DEBICMD >> 2);\r\n*pRPS++ = DEBI_CMD_WRWORD | LP_ISEL;\r\n*pRPS++ = RPS_LDREG | (P_DEBIAD >> 2);\r\n*pRPS++ = LocalPPL;\r\n*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;\r\n*pRPS++ = RPS_UPLOAD | RPS_DEBI;\r\n*pRPS++ = RPS_PAUSE | RPS_DEBI;\r\nJmpAdrs =\r\n(uint32_t) devpriv->RPSBuf.PhysicalBase +\r\n(uint32_t) ((unsigned long)pRPS -\r\n(unsigned long)devpriv->RPSBuf.LogicalBase);\r\nfor (i = 0; i < (10 * RPSCLK_PER_US / 2); i++) {\r\nJmpAdrs += 8;\r\n*pRPS++ = RPS_JUMP;\r\n*pRPS++ = JmpAdrs;\r\n}\r\nif (cmd != NULL && cmd->convert_src != TRIG_NOW) {\r\nDEBUG("ResetADC: convert pause inserted\n");\r\n*pRPS++ = RPS_PAUSE | RPS_SIGADC;\r\n*pRPS++ = RPS_CLRSIGNAL | RPS_SIGADC;\r\n}\r\n*pRPS++ = RPS_LDREG | (P_GPIO >> 2);\r\n*pRPS++ = GPIO_BASE | GPIO1_LO;\r\n*pRPS++ = RPS_NOP;\r\n*pRPS++ = RPS_LDREG | (P_GPIO >> 2);\r\n*pRPS++ = GPIO_BASE | GPIO1_HI;\r\n*pRPS++ = RPS_PAUSE | RPS_GPIO2;\r\n*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);\r\n*pRPS++ =\r\n(uint32_t) devpriv->ANABuf.PhysicalBase +\r\n(devpriv->AdcItems << 2);\r\nif (*ppl++ & EOPL) {\r\ndevpriv->AdcItems++;\r\nbreak;\r\n}\r\n}\r\nDEBUG("ResetADC: ADC items %d\n", devpriv->AdcItems);\r\nfor (n = 0; n < (2 * RPSCLK_PER_US); n++)\r\n*pRPS++ = RPS_NOP;\r\n*pRPS++ = RPS_LDREG | (P_GPIO >> 2);\r\n*pRPS++ = GPIO_BASE | GPIO1_LO;\r\n*pRPS++ = RPS_NOP;\r\n*pRPS++ = RPS_LDREG | (P_GPIO >> 2);\r\n*pRPS++ = GPIO_BASE | GPIO1_HI;\r\n*pRPS++ = RPS_PAUSE | RPS_GPIO2;\r\n*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) >> 2);\r\n*pRPS++ =\r\n(uint32_t) devpriv->ANABuf.PhysicalBase + (devpriv->AdcItems << 2);\r\nif (devpriv->ai_cmd_running == 1) {\r\nDEBUG("ResetADC: insert irq in ADC RPS task\n");\r\n*pRPS++ = RPS_IRQ;\r\n}\r\n*pRPS++ = RPS_JUMP;\r\n*pRPS++ = (uint32_t) devpriv->RPSBuf.PhysicalBase;\r\n}\r\nstatic int s626_ai_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int s626_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nuint16_t chan = CR_CHAN(insn->chanspec);\r\nuint16_t range = CR_RANGE(insn->chanspec);\r\nuint16_t AdcSpec = 0;\r\nuint32_t GpioImage;\r\nint n;\r\nDEBUG("s626_ai_insn_read: entering\n");\r\nif (range == 0)\r\nAdcSpec = (chan << 8) | (GSEL_BIPOLAR5V);\r\nelse\r\nAdcSpec = (chan << 8) | (GSEL_BIPOLAR10V);\r\nDEBIwrite(dev, LP_GSEL, AdcSpec);\r\nDEBIwrite(dev, LP_ISEL, AdcSpec);\r\nfor (n = 0; n < insn->n; n++) {\r\nudelay(10);\r\nGpioImage = RR7146(P_GPIO);\r\nWR7146(P_GPIO, GpioImage & ~GPIO1_HI);\r\nWR7146(P_GPIO, GpioImage & ~GPIO1_HI);\r\nWR7146(P_GPIO, GpioImage & ~GPIO1_HI);\r\nWR7146(P_GPIO, GpioImage | GPIO1_HI);\r\nwhile (!(RR7146(P_PSR) & PSR_GPIO2))\r\n;\r\nif (n != 0)\r\ndata[n - 1] = s626_ai_reg_to_uint(RR7146(P_FB_BUFFER1));\r\nudelay(4);\r\n}\r\nGpioImage = RR7146(P_GPIO);\r\nWR7146(P_GPIO, GpioImage & ~GPIO1_HI);\r\nWR7146(P_GPIO, GpioImage & ~GPIO1_HI);\r\nWR7146(P_GPIO, GpioImage & ~GPIO1_HI);\r\nWR7146(P_GPIO, GpioImage | GPIO1_HI);\r\nwhile (!(RR7146(P_PSR) & PSR_GPIO2))\r\n;\r\nif (n != 0)\r\ndata[n - 1] = s626_ai_reg_to_uint(RR7146(P_FB_BUFFER1));\r\nDEBUG("s626_ai_insn_read: samples %d, data %d\n", n, data[n - 1]);\r\nreturn n;\r\n}\r\nstatic int s626_ai_load_polllist(uint8_t *ppl, struct comedi_cmd *cmd)\r\n{\r\nint n;\r\nfor (n = 0; n < cmd->chanlist_len; n++) {\r\nif (CR_RANGE((cmd->chanlist)[n]) == 0)\r\nppl[n] = (CR_CHAN((cmd->chanlist)[n])) | (RANGE_5V);\r\nelse\r\nppl[n] = (CR_CHAN((cmd->chanlist)[n])) | (RANGE_10V);\r\n}\r\nif (n != 0)\r\nppl[n - 1] |= EOPL;\r\nreturn n;\r\n}\r\nstatic int s626_ai_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, unsigned int trignum)\r\n{\r\nif (trignum != 0)\r\nreturn -EINVAL;\r\nDEBUG("s626_ai_inttrig: trigger adc start...");\r\nMC_ENABLE(P_MC1, MC1_ERPS1);\r\ns->async->inttrig = NULL;\r\nDEBUG(" done\n");\r\nreturn 1;\r\n}\r\nstatic int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nuint8_t ppl[16];\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nstruct enc_private *k;\r\nint tick;\r\nDEBUG("s626_ai_cmd: entering command function\n");\r\nif (devpriv->ai_cmd_running) {\r\nprintk(KERN_ERR "s626_ai_cmd: Another ai_cmd is running %d\n",\r\ndev->minor);\r\nreturn -EBUSY;\r\n}\r\nwritel(0, devpriv->base_addr + P_IER);\r\nwritel(IRQ_RPS1 | IRQ_GPIO3, devpriv->base_addr + P_ISR);\r\ns626_dio_clear_irq(dev);\r\ndevpriv->ai_cmd_running = 0;\r\nif (cmd == NULL) {\r\nDEBUG("s626_ai_cmd: NULL command\n");\r\nreturn -EINVAL;\r\n} else {\r\nDEBUG("s626_ai_cmd: command received!!!\n");\r\n}\r\nif (dev->irq == 0) {\r\ncomedi_error(dev,\r\n"s626_ai_cmd: cannot run command without an irq");\r\nreturn -EIO;\r\n}\r\ns626_ai_load_polllist(ppl, cmd);\r\ndevpriv->ai_cmd_running = 1;\r\ndevpriv->ai_convert_count = 0;\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_FOLLOW:\r\nbreak;\r\ncase TRIG_TIMER:\r\nk = &encpriv[5];\r\ntick = s626_ns_to_timer((int *)&cmd->scan_begin_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\ns626_timer_load(dev, k, tick);\r\nk->SetEnable(dev, k, CLKENAB_ALWAYS);\r\nDEBUG("s626_ai_cmd: scan trigger timer is set with value %d\n",\r\ntick);\r\nbreak;\r\ncase TRIG_EXT:\r\nif (cmd->start_src != TRIG_EXT)\r\ns626_dio_set_irq(dev, cmd->scan_begin_arg);\r\nDEBUG("s626_ai_cmd: External scan trigger is set!!!\n");\r\nbreak;\r\n}\r\nswitch (cmd->convert_src) {\r\ncase TRIG_NOW:\r\nbreak;\r\ncase TRIG_TIMER:\r\nk = &encpriv[4];\r\ntick = s626_ns_to_timer((int *)&cmd->convert_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\ns626_timer_load(dev, k, tick);\r\nk->SetEnable(dev, k, CLKENAB_INDEX);\r\nDEBUG\r\n("s626_ai_cmd: convert trigger timer is set with value %d\n",\r\ntick);\r\nbreak;\r\ncase TRIG_EXT:\r\nif (cmd->scan_begin_src != TRIG_EXT\r\n&& cmd->start_src == TRIG_EXT)\r\ns626_dio_set_irq(dev, cmd->convert_arg);\r\nDEBUG("s626_ai_cmd: External convert trigger is set!!!\n");\r\nbreak;\r\n}\r\nswitch (cmd->stop_src) {\r\ncase TRIG_COUNT:\r\ndevpriv->ai_sample_count = cmd->stop_arg;\r\ndevpriv->ai_continous = 0;\r\nbreak;\r\ncase TRIG_NONE:\r\ndevpriv->ai_continous = 1;\r\ndevpriv->ai_sample_count = 0;\r\nbreak;\r\n}\r\nResetADC(dev, ppl);\r\nswitch (cmd->start_src) {\r\ncase TRIG_NOW:\r\nMC_ENABLE(P_MC1, MC1_ERPS1);\r\nDEBUG("s626_ai_cmd: ADC triggered\n");\r\ns->async->inttrig = NULL;\r\nbreak;\r\ncase TRIG_EXT:\r\ns626_dio_set_irq(dev, cmd->start_arg);\r\nDEBUG("s626_ai_cmd: External start trigger is set!!!\n");\r\ns->async->inttrig = NULL;\r\nbreak;\r\ncase TRIG_INT:\r\ns->async->inttrig = s626_ai_inttrig;\r\nbreak;\r\n}\r\nwritel(IRQ_GPIO3 | IRQ_RPS1, devpriv->base_addr + P_IER);\r\nDEBUG("s626_ai_cmd: command function terminated\n");\r\nreturn 0;\r\n}\r\nstatic int s626_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp;\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW | TRIG_INT | TRIG_EXT;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_TIMER | TRIG_EXT | TRIG_FOLLOW;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_TIMER | TRIG_EXT | TRIG_NOW;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->scan_begin_src != TRIG_TIMER &&\r\ncmd->scan_begin_src != TRIG_EXT\r\n&& cmd->scan_begin_src != TRIG_FOLLOW)\r\nerr++;\r\nif (cmd->convert_src != TRIG_TIMER &&\r\ncmd->convert_src != TRIG_EXT && cmd->convert_src != TRIG_NOW)\r\nerr++;\r\nif (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_src != TRIG_EXT && cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\nif (cmd->start_src == TRIG_EXT && cmd->start_arg > 39) {\r\ncmd->start_arg = 39;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_src == TRIG_EXT && cmd->scan_begin_arg > 39) {\r\ncmd->scan_begin_arg = 39;\r\nerr++;\r\n}\r\nif (cmd->convert_src == TRIG_EXT && cmd->convert_arg > 39) {\r\ncmd->convert_arg = 39;\r\nerr++;\r\n}\r\n#define MAX_SPEED 200000\r\n#define MIN_SPEED 2000000000\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (cmd->scan_begin_arg < MAX_SPEED) {\r\ncmd->scan_begin_arg = MAX_SPEED;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_arg > MIN_SPEED) {\r\ncmd->scan_begin_arg = MIN_SPEED;\r\nerr++;\r\n}\r\n} else {\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (cmd->convert_arg < MAX_SPEED) {\r\ncmd->convert_arg = MAX_SPEED;\r\nerr++;\r\n}\r\nif (cmd->convert_arg > MIN_SPEED) {\r\ncmd->convert_arg = MIN_SPEED;\r\nerr++;\r\n}\r\n} else {\r\n}\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (cmd->stop_arg > 0x00ffffff) {\r\ncmd->stop_arg = 0x00ffffff;\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ntmp = cmd->scan_begin_arg;\r\ns626_ns_to_timer((int *)&cmd->scan_begin_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (tmp != cmd->scan_begin_arg)\r\nerr++;\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ntmp = cmd->convert_arg;\r\ns626_ns_to_timer((int *)&cmd->convert_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (tmp != cmd->convert_arg)\r\nerr++;\r\nif (cmd->scan_begin_src == TRIG_TIMER &&\r\ncmd->scan_begin_arg <\r\ncmd->convert_arg * cmd->scan_end_arg) {\r\ncmd->scan_begin_arg =\r\ncmd->convert_arg * cmd->scan_end_arg;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int s626_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nMC_DISABLE(P_MC1, MC1_ERPS1);\r\nwritel(0, devpriv->base_addr + P_IER);\r\ndevpriv->ai_cmd_running = 0;\r\nreturn 0;\r\n}\r\nstatic int s626_ns_to_timer(int *nanosec, int round_mode)\r\n{\r\nint divider, base;\r\nbase = 500;\r\nswitch (round_mode) {\r\ncase TRIG_ROUND_NEAREST:\r\ndefault:\r\ndivider = (*nanosec + base / 2) / base;\r\nbreak;\r\ncase TRIG_ROUND_DOWN:\r\ndivider = (*nanosec) / base;\r\nbreak;\r\ncase TRIG_ROUND_UP:\r\ndivider = (*nanosec + base - 1) / base;\r\nbreak;\r\n}\r\n*nanosec = base * divider;\r\nreturn divider - 1;\r\n}\r\nstatic int s626_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i;\r\nuint16_t chan = CR_CHAN(insn->chanspec);\r\nint16_t dacdata;\r\nfor (i = 0; i < insn->n; i++) {\r\ndacdata = (int16_t) data[i];\r\ndevpriv->ao_readback[CR_CHAN(insn->chanspec)] = data[i];\r\ndacdata -= (0x1fff);\r\nSetDAC(dev, chan, dacdata);\r\n}\r\nreturn i;\r\n}\r\nstatic int s626_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i;\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = devpriv->ao_readback[CR_CHAN(insn->chanspec)];\r\nreturn i;\r\n}\r\nstatic void s626_dio_init(struct comedi_device *dev)\r\n{\r\nuint16_t group;\r\nstruct comedi_subdevice *s;\r\nDEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);\r\nfor (group = 0; group < S626_DIO_BANKS; group++) {\r\ns = dev->subdevices + 2 + group;\r\nDEBIwrite(dev, diopriv->WRIntSel, 0);\r\nDEBIwrite(dev, diopriv->WRCapSel, 0xFFFF);\r\nDEBIwrite(dev, diopriv->WREdgSel, 0);\r\nDEBIwrite(dev, diopriv->WRDOut, 0);\r\n}\r\nDEBUG("s626_dio_init: DIO initialized\n");\r\n}\r\nstatic int s626_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nif (insn->n == 0)\r\nreturn 0;\r\nif (insn->n != 2) {\r\nprintk\r\n("comedi%d: s626: s626_dio_insn_bits(): Invalid instruction length\n",\r\ndev->minor);\r\nreturn -EINVAL;\r\n}\r\nif (data[0]) {\r\nif ((s->io_bits & data[0]) != data[0])\r\nreturn -EIO;\r\ns->state &= ~data[0];\r\ns->state |= data[0] & data[1];\r\nDEBIwrite(dev, diopriv->WRDOut, s->state);\r\n}\r\ndata[1] = DEBIread(dev, diopriv->RDDIn);\r\nreturn 2;\r\n}\r\nstatic int s626_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIO_QUERY:\r\ndata[1] =\r\n(s->\r\nio_bits & (1 << CR_CHAN(insn->chanspec))) ? COMEDI_OUTPUT :\r\nCOMEDI_INPUT;\r\nreturn insn->n;\r\nbreak;\r\ncase COMEDI_INPUT:\r\ns->io_bits &= ~(1 << CR_CHAN(insn->chanspec));\r\nbreak;\r\ncase COMEDI_OUTPUT:\r\ns->io_bits |= 1 << CR_CHAN(insn->chanspec);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nDEBIwrite(dev, diopriv->WRDOut, s->io_bits);\r\nreturn 1;\r\n}\r\nstatic int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan)\r\n{\r\nunsigned int group;\r\nunsigned int bitmask;\r\nunsigned int status;\r\ngroup = chan / 16;\r\nbitmask = 1 << (chan - (16 * group));\r\nDEBUG("s626_dio_set_irq: enable interrupt on dio channel %d group %d\n",\r\nchan - (16 * group), group);\r\nstatus = DEBIread(dev,\r\n((struct dio_private *)(dev->subdevices + 2 +\r\ngroup)->private)->RDEdgSel);\r\nDEBIwrite(dev,\r\n((struct dio_private *)(dev->subdevices + 2 +\r\ngroup)->private)->WREdgSel,\r\nbitmask | status);\r\nstatus = DEBIread(dev,\r\n((struct dio_private *)(dev->subdevices + 2 +\r\ngroup)->private)->RDIntSel);\r\nDEBIwrite(dev,\r\n((struct dio_private *)(dev->subdevices + 2 +\r\ngroup)->private)->WRIntSel,\r\nbitmask | status);\r\nDEBIwrite(dev, LP_MISC1, MISC1_EDCAP);\r\nstatus = DEBIread(dev,\r\n((struct dio_private *)(dev->subdevices + 2 +\r\ngroup)->private)->RDCapSel);\r\nDEBIwrite(dev,\r\n((struct dio_private *)(dev->subdevices + 2 +\r\ngroup)->private)->WRCapSel,\r\nbitmask | status);\r\nreturn 0;\r\n}\r\nstatic int s626_dio_reset_irq(struct comedi_device *dev, unsigned int group,\r\nunsigned int mask)\r\n{\r\nDEBUG\r\n("s626_dio_reset_irq: disable interrupt on dio channel %d group %d\n",\r\nmask, group);\r\nDEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);\r\nDEBIwrite(dev,\r\n((struct dio_private *)(dev->subdevices + 2 +\r\ngroup)->private)->WRCapSel, mask);\r\nreturn 0;\r\n}\r\nstatic int s626_dio_clear_irq(struct comedi_device *dev)\r\n{\r\nunsigned int group;\r\nDEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);\r\nfor (group = 0; group < S626_DIO_BANKS; group++) {\r\nDEBIwrite(dev,\r\n((struct dio_private *)(dev->subdevices + 2 +\r\ngroup)->private)->WRCapSel,\r\n0xffff);\r\n}\r\nreturn 0;\r\n}\r\nstatic int s626_enc_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nuint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |\r\n(INDXSRC_SOFT << BF_INDXSRC) |\r\n(CLKSRC_COUNTER << BF_CLKSRC) |\r\n(CLKPOL_POS << BF_CLKPOL) |\r\n(CLKMULT_1X << BF_CLKMULT) |\r\n(CLKENAB_INDEX << BF_CLKENAB);\r\nuint16_t valueSrclatch = LATCHSRC_AB_READ;\r\nuint16_t enab = CLKENAB_ALWAYS;\r\nstruct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];\r\nDEBUG("s626_enc_insn_config: encoder config\n");\r\nk->SetMode(dev, k, Setup, TRUE);\r\nPreload(dev, k, *(insn->data));\r\nk->PulseIndex(dev, k);\r\nSetLatchSource(dev, k, valueSrclatch);\r\nk->SetEnable(dev, k, (uint16_t) (enab != 0));\r\nreturn insn->n;\r\n}\r\nstatic int s626_enc_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint n;\r\nstruct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];\r\nDEBUG("s626_enc_insn_read: encoder read channel %d\n",\r\nCR_CHAN(insn->chanspec));\r\nfor (n = 0; n < insn->n; n++)\r\ndata[n] = ReadLatch(dev, k);\r\nDEBUG("s626_enc_insn_read: encoder sample %d\n", data[n]);\r\nreturn n;\r\n}\r\nstatic int s626_enc_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct enc_private *k = &encpriv[CR_CHAN(insn->chanspec)];\r\nDEBUG("s626_enc_insn_write: encoder write channel %d\n",\r\nCR_CHAN(insn->chanspec));\r\nPreload(dev, k, data[0]);\r\nk->SetLoadTrig(dev, k, 0);\r\nk->PulseIndex(dev, k);\r\nk->SetLoadTrig(dev, k, 2);\r\nDEBUG("s626_enc_insn_write: End encoder write\n");\r\nreturn 1;\r\n}\r\nstatic void s626_timer_load(struct comedi_device *dev, struct enc_private *k,\r\nint tick)\r\n{\r\nuint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |\r\n(INDXSRC_SOFT << BF_INDXSRC) |\r\n(CLKSRC_TIMER << BF_CLKSRC) |\r\n(CLKPOL_POS << BF_CLKPOL) |\r\n(CNTDIR_DOWN << BF_CLKPOL) |\r\n(CLKMULT_1X << BF_CLKMULT) |\r\n(CLKENAB_INDEX << BF_CLKENAB);\r\nuint16_t valueSrclatch = LATCHSRC_A_INDXA;\r\nk->SetMode(dev, k, Setup, FALSE);\r\nPreload(dev, k, tick);\r\nk->SetLoadTrig(dev, k, 0);\r\nk->PulseIndex(dev, k);\r\nk->SetLoadTrig(dev, k, 1);\r\nk->SetIntSrc(dev, k, INTSRC_OVER);\r\nSetLatchSource(dev, k, valueSrclatch);\r\n}\r\nstatic void LoadTrimDACs(struct comedi_device *dev)\r\n{\r\nregister uint8_t i;\r\nfor (i = 0; i < ARRAY_SIZE(trimchan); i++)\r\nWriteTrimDAC(dev, i, I2Cread(dev, trimadrs[i]));\r\n}\r\nstatic void WriteTrimDAC(struct comedi_device *dev, uint8_t LogicalChan,\r\nuint8_t DacData)\r\n{\r\nuint32_t chan;\r\ndevpriv->TrimSetpoint[LogicalChan] = (uint8_t) DacData;\r\nchan = (uint32_t) trimchan[LogicalChan];\r\nSETVECT(2, XSD2 | XFIFO_1 | WS3);\r\nSETVECT(3, XSD2 | XFIFO_0 | WS3);\r\nSETVECT(4, XSD2 | XFIFO_3 | WS1);\r\nSETVECT(5, XSD2 | XFIFO_2 | WS1 | EOS);\r\nSendDAC(dev, ((uint32_t) chan << 8)\r\n| (uint32_t) DacData);\r\n}\r\nstatic uint8_t I2Cread(struct comedi_device *dev, uint8_t addr)\r\n{\r\nuint8_t rtnval;\r\nif (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CW)\r\n| I2C_B1(I2C_ATTRSTOP, addr)\r\n| I2C_B0(I2C_ATTRNOP, 0))) {\r\nDEBUG("I2Cread: error handshake I2Cread a\n");\r\nreturn 0;\r\n}\r\nif (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CR)\r\n|I2C_B1(I2C_ATTRSTOP, 0)\r\n|I2C_B0(I2C_ATTRNOP, 0))) {\r\nDEBUG("I2Cread: error handshake I2Cread b\n");\r\nreturn 0;\r\n}\r\nrtnval = (uint8_t) (RR7146(P_I2CCTRL) >> 16);\r\nreturn rtnval;\r\n}\r\nstatic uint32_t I2Chandshake(struct comedi_device *dev, uint32_t val)\r\n{\r\nWR7146(P_I2CCTRL, val);\r\nMC_ENABLE(P_MC2, MC2_UPLD_IIC);\r\nwhile (!MC_TEST(P_MC2, MC2_UPLD_IIC))\r\n;\r\nwhile ((RR7146(P_I2CCTRL) & (I2C_BUSY | I2C_ERR)) == I2C_BUSY)\r\n;\r\nreturn RR7146(P_I2CCTRL) & I2C_ERR;\r\n}\r\nstatic void SetDAC(struct comedi_device *dev, uint16_t chan, short dacdata)\r\n{\r\nregister uint16_t signmask;\r\nregister uint32_t WSImage;\r\nsignmask = 1 << chan;\r\nif (dacdata < 0) {\r\ndacdata = -dacdata;\r\ndevpriv->Dacpol |= signmask;\r\n} else\r\ndevpriv->Dacpol &= ~signmask;\r\nif ((uint16_t) dacdata > 0x1FFF)\r\ndacdata = 0x1FFF;\r\nWSImage = (chan & 2) ? WS1 : WS2;\r\nSETVECT(2, XSD2 | XFIFO_1 | WSImage);\r\nSETVECT(3, XSD2 | XFIFO_0 | WSImage);\r\nSETVECT(4, XSD2 | XFIFO_3 | WS3);\r\nSETVECT(5, XSD2 | XFIFO_2 | WS3 | EOS);\r\nSendDAC(dev, 0x0F000000\r\n| 0x00004000\r\n| ((uint32_t) (chan & 1) << 15)\r\n| (uint32_t) dacdata);\r\n}\r\nstatic void SendDAC(struct comedi_device *dev, uint32_t val)\r\n{\r\nDEBIwrite(dev, LP_DACPOL, devpriv->Dacpol);\r\n*devpriv->pDacWBuf = val;\r\nMC_ENABLE(P_MC1, MC1_A2OUT);\r\nWR7146(P_ISR, ISR_AFOU);\r\nwhile ((RR7146(P_MC1) & MC1_A2OUT) != 0)\r\n;\r\nSETVECT(0, XSD2 | RSD3 | SIB_A2);\r\nwhile ((RR7146(P_SSR) & SSR_AF2_OUT) == 0)\r\n;\r\nSETVECT(0, XSD2 | XFIFO_2 | RSD2 | SIB_A2 | EOS);\r\nif ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0) {\r\nwhile ((RR7146(P_FB_BUFFER2) & 0xFF000000) != 0)\r\n;\r\n}\r\nSETVECT(0, RSD3 | SIB_A2 | EOS);\r\nwhile ((RR7146(P_FB_BUFFER2) & 0xFF000000) == 0)\r\n;\r\n}\r\nstatic void WriteMISC2(struct comedi_device *dev, uint16_t NewImage)\r\n{\r\nDEBIwrite(dev, LP_MISC1, MISC1_WENABLE);\r\nDEBIwrite(dev, LP_WRMISC2, NewImage);\r\nDEBIwrite(dev, LP_MISC1, MISC1_WDISABLE);\r\n}\r\nstatic uint16_t DEBIread(struct comedi_device *dev, uint16_t addr)\r\n{\r\nuint16_t retval;\r\nWR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);\r\nDEBItransfer(dev);\r\nretval = (uint16_t) RR7146(P_DEBIAD);\r\nreturn retval;\r\n}\r\nstatic void DEBItransfer(struct comedi_device *dev)\r\n{\r\nMC_ENABLE(P_MC2, MC2_UPLD_DEBI);\r\nwhile (!MC_TEST(P_MC2, MC2_UPLD_DEBI))\r\n;\r\nwhile (RR7146(P_PSR) & PSR_DEBI_S)\r\n;\r\n}\r\nstatic void DEBIwrite(struct comedi_device *dev, uint16_t addr, uint16_t wdata)\r\n{\r\nWR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);\r\nWR7146(P_DEBIAD, wdata);\r\nDEBItransfer(dev);\r\n}\r\nstatic void DEBIreplace(struct comedi_device *dev, uint16_t addr, uint16_t mask,\r\nuint16_t wdata)\r\n{\r\nWR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);\r\nDEBItransfer(dev);\r\nWR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);\r\nWR7146(P_DEBIAD, wdata | ((uint16_t) RR7146(P_DEBIAD) & mask));\r\nDEBItransfer(dev);\r\n}\r\nstatic void CloseDMAB(struct comedi_device *dev, struct bufferDMA *pdma,\r\nsize_t bsize)\r\n{\r\nvoid *vbptr;\r\ndma_addr_t vpptr;\r\nDEBUG("CloseDMAB: Entering S626DRV_CloseDMAB():\n");\r\nif (pdma == NULL)\r\nreturn;\r\nvbptr = pdma->LogicalBase;\r\nvpptr = pdma->PhysicalBase;\r\nif (vbptr) {\r\npci_free_consistent(devpriv->pdev, bsize, vbptr, vpptr);\r\npdma->LogicalBase = 0;\r\npdma->PhysicalBase = 0;\r\nDEBUG("CloseDMAB(): Logical=%p, bsize=%d, Physical=0x%x\n",\r\nvbptr, bsize, (uint32_t) vpptr);\r\n}\r\n}\r\nstatic uint32_t ReadLatch(struct comedi_device *dev, struct enc_private *k)\r\n{\r\nregister uint32_t value;\r\nvalue = (uint32_t) DEBIread(dev, k->MyLatchLsw);\r\nvalue |= ((uint32_t) DEBIread(dev, k->MyLatchLsw + 2) << 16);\r\nreturn value;\r\n}\r\nstatic void ResetCapFlags_A(struct comedi_device *dev, struct enc_private *k)\r\n{\r\nDEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),\r\nCRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);\r\n}\r\nstatic void ResetCapFlags_B(struct comedi_device *dev, struct enc_private *k)\r\n{\r\nDEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),\r\nCRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);\r\n}\r\nstatic uint16_t GetMode_A(struct comedi_device *dev, struct enc_private *k)\r\n{\r\nregister uint16_t cra;\r\nregister uint16_t crb;\r\nregister uint16_t setup;\r\ncra = DEBIread(dev, k->MyCRA);\r\ncrb = DEBIread(dev, k->MyCRB);\r\nsetup = ((cra & STDMSK_LOADSRC)\r\n|((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)\r\n|((cra << (STDBIT_INTSRC - CRABIT_INTSRC_A)) & STDMSK_INTSRC)\r\n|((cra << (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))) & STDMSK_INDXSRC)\r\n|((cra >> (CRABIT_INDXPOL_A - STDBIT_INDXPOL)) & STDMSK_INDXPOL)\r\n|((crb >> (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)) & STDMSK_CLKENAB));\r\nif (cra & (2 << CRABIT_CLKSRC_A))\r\nsetup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)\r\n|((cra << (STDBIT_CLKPOL - CRABIT_CLKSRC_A)) & STDMSK_CLKPOL)\r\n|(MULT_X1 << STDBIT_CLKMULT));\r\nelse\r\nsetup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)\r\n|((cra >> (CRABIT_CLKPOL_A - STDBIT_CLKPOL)) & STDMSK_CLKPOL)\r\n|(((cra & CRAMSK_CLKMULT_A) == (MULT_X0 << CRABIT_CLKMULT_A)) ?\r\n(MULT_X1 << STDBIT_CLKMULT) :\r\n((cra >> (CRABIT_CLKMULT_A -\r\nSTDBIT_CLKMULT)) & STDMSK_CLKMULT)));\r\nreturn setup;\r\n}\r\nstatic uint16_t GetMode_B(struct comedi_device *dev, struct enc_private *k)\r\n{\r\nregister uint16_t cra;\r\nregister uint16_t crb;\r\nregister uint16_t setup;\r\ncra = DEBIread(dev, k->MyCRA);\r\ncrb = DEBIread(dev, k->MyCRB);\r\nsetup = (((crb << (STDBIT_INTSRC - CRBBIT_INTSRC_B)) & STDMSK_INTSRC)\r\n|((crb << (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) & STDMSK_LATCHSRC)\r\n|((crb << (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)) & STDMSK_LOADSRC)\r\n|((crb << (STDBIT_INDXPOL - CRBBIT_INDXPOL_B)) & STDMSK_INDXPOL)\r\n|((crb >> (CRBBIT_CLKENAB_B - STDBIT_CLKENAB)) & STDMSK_CLKENAB)\r\n|((cra >> ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC)) & STDMSK_INDXSRC));\r\nif ((crb & CRBMSK_CLKMULT_B) == (MULT_X0 << CRBBIT_CLKMULT_B))\r\nsetup |= ((CLKSRC_EXTENDER << STDBIT_CLKSRC)\r\n|(MULT_X1 << STDBIT_CLKMULT)\r\n|((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));\r\nelse if (cra & (2 << CRABIT_CLKSRC_B))\r\nsetup |= ((CLKSRC_TIMER << STDBIT_CLKSRC)\r\n|(MULT_X1 << STDBIT_CLKMULT)\r\n|((cra >> (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) & STDMSK_CLKPOL));\r\nelse\r\nsetup |= ((CLKSRC_COUNTER << STDBIT_CLKSRC)\r\n|((crb >> (CRBBIT_CLKMULT_B - STDBIT_CLKMULT)) & STDMSK_CLKMULT)\r\n|((crb << (STDBIT_CLKPOL - CRBBIT_CLKPOL_B)) & STDMSK_CLKPOL));\r\nreturn setup;\r\n}\r\nstatic void SetMode_A(struct comedi_device *dev, struct enc_private *k,\r\nuint16_t Setup, uint16_t DisableIntSrc)\r\n{\r\nregister uint16_t cra;\r\nregister uint16_t crb;\r\nregister uint16_t setup = Setup;\r\ncra = ((setup & CRAMSK_LOADSRC_A)\r\n|((setup & STDMSK_INDXSRC) >> (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))));\r\ncrb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A\r\n| ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)));\r\nif (!DisableIntSrc)\r\ncra |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -\r\nCRABIT_INTSRC_A));\r\nswitch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {\r\ncase CLKSRC_EXTENDER:\r\ncase CLKSRC_TIMER:\r\ncra |= ((2 << CRABIT_CLKSRC_A)\r\n|((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRABIT_CLKSRC_A))\r\n|(1 << CRABIT_CLKPOL_A)\r\n|(MULT_X1 << CRABIT_CLKMULT_A));\r\nbreak;\r\ndefault:\r\ncra |= (CLKSRC_COUNTER\r\n| ((setup & STDMSK_CLKPOL) << (CRABIT_CLKPOL_A - STDBIT_CLKPOL))\r\n|(((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?\r\n(MULT_X1 << CRABIT_CLKMULT_A) :\r\n((setup & STDMSK_CLKMULT) << (CRABIT_CLKMULT_A -\r\nSTDBIT_CLKMULT))));\r\n}\r\nif (~setup & STDMSK_INDXSRC)\r\ncra |= ((setup & STDMSK_INDXPOL) << (CRABIT_INDXPOL_A -\r\nSTDBIT_INDXPOL));\r\nif (DisableIntSrc)\r\ndevpriv->CounterIntEnabs &= ~k->MyEventBits[3];\r\nDEBIreplace(dev, k->MyCRA, CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B, cra);\r\nDEBIreplace(dev, k->MyCRB,\r\n(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)), crb);\r\n}\r\nstatic void SetMode_B(struct comedi_device *dev, struct enc_private *k,\r\nuint16_t Setup, uint16_t DisableIntSrc)\r\n{\r\nregister uint16_t cra;\r\nregister uint16_t crb;\r\nregister uint16_t setup = Setup;\r\ncra = ((setup & STDMSK_INDXSRC) << ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC));\r\ncrb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B\r\n| ((setup & STDMSK_CLKENAB) << (CRBBIT_CLKENAB_B - STDBIT_CLKENAB))\r\n|((setup & STDMSK_LOADSRC) >> (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)));\r\nif (!DisableIntSrc)\r\ncrb |= ((setup & STDMSK_INTSRC) >> (STDBIT_INTSRC -\r\nCRBBIT_INTSRC_B));\r\nswitch ((setup & STDMSK_CLKSRC) >> STDBIT_CLKSRC) {\r\ncase CLKSRC_TIMER:\r\ncra |= ((2 << CRABIT_CLKSRC_B)\r\n|((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));\r\ncrb |= ((1 << CRBBIT_CLKPOL_B)\r\n|(MULT_X1 << CRBBIT_CLKMULT_B));\r\nbreak;\r\ncase CLKSRC_EXTENDER:\r\ncra |= ((2 << CRABIT_CLKSRC_B)\r\n|((setup & STDMSK_CLKPOL) << (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));\r\ncrb |= ((1 << CRBBIT_CLKPOL_B)\r\n|(MULT_X0 << CRBBIT_CLKMULT_B));\r\nbreak;\r\ndefault:\r\ncra |= (CLKSRC_COUNTER << CRABIT_CLKSRC_B);\r\ncrb |= (((setup & STDMSK_CLKPOL) >> (STDBIT_CLKPOL - CRBBIT_CLKPOL_B))\r\n|(((setup & STDMSK_CLKMULT) == (MULT_X0 << STDBIT_CLKMULT)) ?\r\n(MULT_X1 << CRBBIT_CLKMULT_B) :\r\n((setup & STDMSK_CLKMULT) << (CRBBIT_CLKMULT_B -\r\nSTDBIT_CLKMULT))));\r\n}\r\nif (~setup & STDMSK_INDXSRC)\r\ncrb |= ((setup & STDMSK_INDXPOL) >> (STDBIT_INDXPOL -\r\nCRBBIT_INDXPOL_B));\r\nif (DisableIntSrc)\r\ndevpriv->CounterIntEnabs &= ~k->MyEventBits[3];\r\nDEBIreplace(dev, k->MyCRA,\r\n(uint16_t) (~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B)), cra);\r\nDEBIreplace(dev, k->MyCRB, CRBMSK_CLKENAB_A | CRBMSK_LATCHSRC, crb);\r\n}\r\nstatic void SetEnable_A(struct comedi_device *dev, struct enc_private *k,\r\nuint16_t enab)\r\n{\r\nDEBUG("SetEnable_A: SetEnable_A enter 3541\n");\r\nDEBIreplace(dev, k->MyCRB,\r\n(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)),\r\n(uint16_t) (enab << CRBBIT_CLKENAB_A));\r\n}\r\nstatic void SetEnable_B(struct comedi_device *dev, struct enc_private *k,\r\nuint16_t enab)\r\n{\r\nDEBIreplace(dev, k->MyCRB,\r\n(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B)),\r\n(uint16_t) (enab << CRBBIT_CLKENAB_B));\r\n}\r\nstatic uint16_t GetEnable_A(struct comedi_device *dev, struct enc_private *k)\r\n{\r\nreturn (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_A) & 1;\r\n}\r\nstatic uint16_t GetEnable_B(struct comedi_device *dev, struct enc_private *k)\r\n{\r\nreturn (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_B) & 1;\r\n}\r\nstatic void SetLatchSource(struct comedi_device *dev, struct enc_private *k,\r\nuint16_t value)\r\n{\r\nDEBUG("SetLatchSource: SetLatchSource enter 3550\n");\r\nDEBIreplace(dev, k->MyCRB,\r\n(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_LATCHSRC)),\r\n(uint16_t) (value << CRBBIT_LATCHSRC));\r\nDEBUG("SetLatchSource: SetLatchSource exit\n");\r\n}\r\nstatic void SetLoadTrig_A(struct comedi_device *dev, struct enc_private *k,\r\nuint16_t Trig)\r\n{\r\nDEBIreplace(dev, k->MyCRA, (uint16_t) (~CRAMSK_LOADSRC_A),\r\n(uint16_t) (Trig << CRABIT_LOADSRC_A));\r\n}\r\nstatic void SetLoadTrig_B(struct comedi_device *dev, struct enc_private *k,\r\nuint16_t Trig)\r\n{\r\nDEBIreplace(dev, k->MyCRB,\r\n(uint16_t) (~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL)),\r\n(uint16_t) (Trig << CRBBIT_LOADSRC_B));\r\n}\r\nstatic uint16_t GetLoadTrig_A(struct comedi_device *dev, struct enc_private *k)\r\n{\r\nreturn (DEBIread(dev, k->MyCRA) >> CRABIT_LOADSRC_A) & 3;\r\n}\r\nstatic uint16_t GetLoadTrig_B(struct comedi_device *dev, struct enc_private *k)\r\n{\r\nreturn (DEBIread(dev, k->MyCRB) >> CRBBIT_LOADSRC_B) & 3;\r\n}\r\nstatic void SetIntSrc_A(struct comedi_device *dev, struct enc_private *k,\r\nuint16_t IntSource)\r\n{\r\nDEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),\r\nCRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);\r\nDEBIreplace(dev, k->MyCRA, ~CRAMSK_INTSRC_A,\r\n(uint16_t) (IntSource << CRABIT_INTSRC_A));\r\ndevpriv->CounterIntEnabs =\r\n(devpriv->CounterIntEnabs & ~k->\r\nMyEventBits[3]) | k->MyEventBits[IntSource];\r\n}\r\nstatic void SetIntSrc_B(struct comedi_device *dev, struct enc_private *k,\r\nuint16_t IntSource)\r\n{\r\nuint16_t crb;\r\ncrb = DEBIread(dev, k->MyCRB) & ~CRBMSK_INTCTRL;\r\nDEBIwrite(dev, k->MyCRB,\r\n(uint16_t) (crb | CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B));\r\nDEBIwrite(dev, k->MyCRB,\r\n(uint16_t) ((crb & ~CRBMSK_INTSRC_B) | (IntSource <<\r\nCRBBIT_INTSRC_B)));\r\ndevpriv->CounterIntEnabs =\r\n(devpriv->CounterIntEnabs & ~k->\r\nMyEventBits[3]) | k->MyEventBits[IntSource];\r\n}\r\nstatic uint16_t GetIntSrc_A(struct comedi_device *dev, struct enc_private *k)\r\n{\r\nreturn (DEBIread(dev, k->MyCRA) >> CRABIT_INTSRC_A) & 3;\r\n}\r\nstatic uint16_t GetIntSrc_B(struct comedi_device *dev, struct enc_private *k)\r\n{\r\nreturn (DEBIread(dev, k->MyCRB) >> CRBBIT_INTSRC_B) & 3;\r\n}\r\nstatic void PulseIndex_A(struct comedi_device *dev, struct enc_private *k)\r\n{\r\nregister uint16_t cra;\r\nDEBUG("PulseIndex_A: pulse index enter\n");\r\ncra = DEBIread(dev, k->MyCRA);\r\nDEBIwrite(dev, k->MyCRA, (uint16_t) (cra ^ CRAMSK_INDXPOL_A));\r\nDEBUG("PulseIndex_A: pulse index step1\n");\r\nDEBIwrite(dev, k->MyCRA, cra);\r\n}\r\nstatic void PulseIndex_B(struct comedi_device *dev, struct enc_private *k)\r\n{\r\nregister uint16_t crb;\r\ncrb = DEBIread(dev, k->MyCRB) & ~CRBMSK_INTCTRL;\r\nDEBIwrite(dev, k->MyCRB, (uint16_t) (crb ^ CRBMSK_INDXPOL_B));\r\nDEBIwrite(dev, k->MyCRB, crb);\r\n}\r\nstatic void Preload(struct comedi_device *dev, struct enc_private *k,\r\nuint32_t value)\r\n{\r\nDEBUG("Preload: preload enter\n");\r\nDEBIwrite(dev, (uint16_t) (k->MyLatchLsw), (uint16_t) value);\r\nDEBUG("Preload: preload step 1\n");\r\nDEBIwrite(dev, (uint16_t) (k->MyLatchLsw + 2),\r\n(uint16_t) (value >> 16));\r\n}\r\nstatic void CountersInit(struct comedi_device *dev)\r\n{\r\nint chan;\r\nstruct enc_private *k;\r\nuint16_t Setup = (LOADSRC_INDX << BF_LOADSRC) |\r\n(INDXSRC_SOFT << BF_INDXSRC) |\r\n(CLKSRC_COUNTER << BF_CLKSRC) |\r\n(CLKPOL_POS << BF_CLKPOL) |\r\n(CNTDIR_UP << BF_CLKPOL) |\r\n(CLKMULT_1X << BF_CLKMULT) |\r\n(CLKENAB_INDEX << BF_CLKENAB);\r\nfor (chan = 0; chan < S626_ENCODER_CHANNELS; chan++) {\r\nk = &encpriv[chan];\r\nk->SetMode(dev, k, Setup, TRUE);\r\nk->SetIntSrc(dev, k, 0);\r\nk->ResetCapFlags(dev, k);\r\nk->SetEnable(dev, k, CLKENAB_ALWAYS);\r\n}\r\nDEBUG("CountersInit: counters initialized\n");\r\n}
