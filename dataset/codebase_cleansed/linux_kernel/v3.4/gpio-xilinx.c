static int xgpio_get(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nreturn (in_be32(mm_gc->regs + XGPIO_DATA_OFFSET) >> gpio) & 1;\r\n}\r\nstatic void xgpio_set(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nunsigned long flags;\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct xgpio_instance *chip =\r\ncontainer_of(mm_gc, struct xgpio_instance, mmchip);\r\nspin_lock_irqsave(&chip->gpio_lock, flags);\r\nif (val)\r\nchip->gpio_state |= 1 << gpio;\r\nelse\r\nchip->gpio_state &= ~(1 << gpio);\r\nout_be32(mm_gc->regs + XGPIO_DATA_OFFSET, chip->gpio_state);\r\nspin_unlock_irqrestore(&chip->gpio_lock, flags);\r\n}\r\nstatic int xgpio_dir_in(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nunsigned long flags;\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct xgpio_instance *chip =\r\ncontainer_of(mm_gc, struct xgpio_instance, mmchip);\r\nspin_lock_irqsave(&chip->gpio_lock, flags);\r\nchip->gpio_dir |= (1 << gpio);\r\nout_be32(mm_gc->regs + XGPIO_TRI_OFFSET, chip->gpio_dir);\r\nspin_unlock_irqrestore(&chip->gpio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int xgpio_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nunsigned long flags;\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct xgpio_instance *chip =\r\ncontainer_of(mm_gc, struct xgpio_instance, mmchip);\r\nspin_lock_irqsave(&chip->gpio_lock, flags);\r\nif (val)\r\nchip->gpio_state |= 1 << gpio;\r\nelse\r\nchip->gpio_state &= ~(1 << gpio);\r\nout_be32(mm_gc->regs + XGPIO_DATA_OFFSET, chip->gpio_state);\r\nchip->gpio_dir &= (~(1 << gpio));\r\nout_be32(mm_gc->regs + XGPIO_TRI_OFFSET, chip->gpio_dir);\r\nspin_unlock_irqrestore(&chip->gpio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void xgpio_save_regs(struct of_mm_gpio_chip *mm_gc)\r\n{\r\nstruct xgpio_instance *chip =\r\ncontainer_of(mm_gc, struct xgpio_instance, mmchip);\r\nout_be32(mm_gc->regs + XGPIO_DATA_OFFSET, chip->gpio_state);\r\nout_be32(mm_gc->regs + XGPIO_TRI_OFFSET, chip->gpio_dir);\r\n}\r\nstatic int __devinit xgpio_of_probe(struct device_node *np)\r\n{\r\nstruct xgpio_instance *chip;\r\nint status = 0;\r\nconst u32 *tree_info;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\ntree_info = of_get_property(np, "xlnx,dout-default", NULL);\r\nif (tree_info)\r\nchip->gpio_state = be32_to_cpup(tree_info);\r\nchip->gpio_dir = 0xFFFFFFFF;\r\ntree_info = of_get_property(np, "xlnx,tri-default", NULL);\r\nif (tree_info)\r\nchip->gpio_dir = be32_to_cpup(tree_info);\r\nchip->mmchip.gc.ngpio = 32;\r\ntree_info = of_get_property(np, "xlnx,gpio-width", NULL);\r\nif (!tree_info)\r\ntree_info = of_get_property(np->parent,\r\n"xlnx,gpio-width", NULL);\r\nif (tree_info)\r\nchip->mmchip.gc.ngpio = be32_to_cpup(tree_info);\r\nspin_lock_init(&chip->gpio_lock);\r\nchip->mmchip.gc.direction_input = xgpio_dir_in;\r\nchip->mmchip.gc.direction_output = xgpio_dir_out;\r\nchip->mmchip.gc.get = xgpio_get;\r\nchip->mmchip.gc.set = xgpio_set;\r\nchip->mmchip.save_regs = xgpio_save_regs;\r\nstatus = of_mm_gpiochip_add(np, &chip->mmchip);\r\nif (status) {\r\nkfree(chip);\r\npr_err("%s: error in probe function with status %d\n",\r\nnp->full_name, status);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init xgpio_init(void)\r\n{\r\nstruct device_node *np;\r\nfor_each_matching_node(np, xgpio_of_match)\r\nxgpio_of_probe(np);\r\nreturn 0;\r\n}
