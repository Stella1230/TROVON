int ubi_change_vtbl_record(struct ubi_device *ubi, int idx,\r\nstruct ubi_vtbl_record *vtbl_rec)\r\n{\r\nint i, err;\r\nuint32_t crc;\r\nstruct ubi_volume *layout_vol;\r\nubi_assert(idx >= 0 && idx < ubi->vtbl_slots);\r\nlayout_vol = ubi->volumes[vol_id2idx(ubi, UBI_LAYOUT_VOLUME_ID)];\r\nif (!vtbl_rec)\r\nvtbl_rec = &empty_vtbl_record;\r\nelse {\r\ncrc = crc32(UBI_CRC32_INIT, vtbl_rec, UBI_VTBL_RECORD_SIZE_CRC);\r\nvtbl_rec->crc = cpu_to_be32(crc);\r\n}\r\nmemcpy(&ubi->vtbl[idx], vtbl_rec, sizeof(struct ubi_vtbl_record));\r\nfor (i = 0; i < UBI_LAYOUT_VOLUME_EBS; i++) {\r\nerr = ubi_eba_unmap_leb(ubi, layout_vol, i);\r\nif (err)\r\nreturn err;\r\nerr = ubi_eba_write_leb(ubi, layout_vol, i, ubi->vtbl, 0,\r\nubi->vtbl_size, UBI_LONGTERM);\r\nif (err)\r\nreturn err;\r\n}\r\nparanoid_vtbl_check(ubi);\r\nreturn 0;\r\n}\r\nint ubi_vtbl_rename_volumes(struct ubi_device *ubi,\r\nstruct list_head *rename_list)\r\n{\r\nint i, err;\r\nstruct ubi_rename_entry *re;\r\nstruct ubi_volume *layout_vol;\r\nlist_for_each_entry(re, rename_list, list) {\r\nuint32_t crc;\r\nstruct ubi_volume *vol = re->desc->vol;\r\nstruct ubi_vtbl_record *vtbl_rec = &ubi->vtbl[vol->vol_id];\r\nif (re->remove) {\r\nmemcpy(vtbl_rec, &empty_vtbl_record,\r\nsizeof(struct ubi_vtbl_record));\r\ncontinue;\r\n}\r\nvtbl_rec->name_len = cpu_to_be16(re->new_name_len);\r\nmemcpy(vtbl_rec->name, re->new_name, re->new_name_len);\r\nmemset(vtbl_rec->name + re->new_name_len, 0,\r\nUBI_VOL_NAME_MAX + 1 - re->new_name_len);\r\ncrc = crc32(UBI_CRC32_INIT, vtbl_rec,\r\nUBI_VTBL_RECORD_SIZE_CRC);\r\nvtbl_rec->crc = cpu_to_be32(crc);\r\n}\r\nlayout_vol = ubi->volumes[vol_id2idx(ubi, UBI_LAYOUT_VOLUME_ID)];\r\nfor (i = 0; i < UBI_LAYOUT_VOLUME_EBS; i++) {\r\nerr = ubi_eba_unmap_leb(ubi, layout_vol, i);\r\nif (err)\r\nreturn err;\r\nerr = ubi_eba_write_leb(ubi, layout_vol, i, ubi->vtbl, 0,\r\nubi->vtbl_size, UBI_LONGTERM);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vtbl_check(const struct ubi_device *ubi,\r\nconst struct ubi_vtbl_record *vtbl)\r\n{\r\nint i, n, reserved_pebs, alignment, data_pad, vol_type, name_len;\r\nint upd_marker, err;\r\nuint32_t crc;\r\nconst char *name;\r\nfor (i = 0; i < ubi->vtbl_slots; i++) {\r\ncond_resched();\r\nreserved_pebs = be32_to_cpu(vtbl[i].reserved_pebs);\r\nalignment = be32_to_cpu(vtbl[i].alignment);\r\ndata_pad = be32_to_cpu(vtbl[i].data_pad);\r\nupd_marker = vtbl[i].upd_marker;\r\nvol_type = vtbl[i].vol_type;\r\nname_len = be16_to_cpu(vtbl[i].name_len);\r\nname = &vtbl[i].name[0];\r\ncrc = crc32(UBI_CRC32_INIT, &vtbl[i], UBI_VTBL_RECORD_SIZE_CRC);\r\nif (be32_to_cpu(vtbl[i].crc) != crc) {\r\nubi_err("bad CRC at record %u: %#08x, not %#08x",\r\ni, crc, be32_to_cpu(vtbl[i].crc));\r\nubi_dbg_dump_vtbl_record(&vtbl[i], i);\r\nreturn 1;\r\n}\r\nif (reserved_pebs == 0) {\r\nif (memcmp(&vtbl[i], &empty_vtbl_record,\r\nUBI_VTBL_RECORD_SIZE)) {\r\nerr = 2;\r\ngoto bad;\r\n}\r\ncontinue;\r\n}\r\nif (reserved_pebs < 0 || alignment < 0 || data_pad < 0 ||\r\nname_len < 0) {\r\nerr = 3;\r\ngoto bad;\r\n}\r\nif (alignment > ubi->leb_size || alignment == 0) {\r\nerr = 4;\r\ngoto bad;\r\n}\r\nn = alignment & (ubi->min_io_size - 1);\r\nif (alignment != 1 && n) {\r\nerr = 5;\r\ngoto bad;\r\n}\r\nn = ubi->leb_size % alignment;\r\nif (data_pad != n) {\r\ndbg_err("bad data_pad, has to be %d", n);\r\nerr = 6;\r\ngoto bad;\r\n}\r\nif (vol_type != UBI_VID_DYNAMIC && vol_type != UBI_VID_STATIC) {\r\nerr = 7;\r\ngoto bad;\r\n}\r\nif (upd_marker != 0 && upd_marker != 1) {\r\nerr = 8;\r\ngoto bad;\r\n}\r\nif (reserved_pebs > ubi->good_peb_count) {\r\ndbg_err("too large reserved_pebs %d, good PEBs %d",\r\nreserved_pebs, ubi->good_peb_count);\r\nerr = 9;\r\ngoto bad;\r\n}\r\nif (name_len > UBI_VOL_NAME_MAX) {\r\nerr = 10;\r\ngoto bad;\r\n}\r\nif (name[0] == '\0') {\r\nerr = 11;\r\ngoto bad;\r\n}\r\nif (name_len != strnlen(name, name_len + 1)) {\r\nerr = 12;\r\ngoto bad;\r\n}\r\n}\r\nfor (i = 0; i < ubi->vtbl_slots - 1; i++) {\r\nfor (n = i + 1; n < ubi->vtbl_slots; n++) {\r\nint len1 = be16_to_cpu(vtbl[i].name_len);\r\nint len2 = be16_to_cpu(vtbl[n].name_len);\r\nif (len1 > 0 && len1 == len2 &&\r\n!strncmp(vtbl[i].name, vtbl[n].name, len1)) {\r\nubi_err("volumes %d and %d have the same name"\r\n" \"%s\"", i, n, vtbl[i].name);\r\nubi_dbg_dump_vtbl_record(&vtbl[i], i);\r\nubi_dbg_dump_vtbl_record(&vtbl[n], n);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nreturn 0;\r\nbad:\r\nubi_err("volume table check failed: record %d, error %d", i, err);\r\nubi_dbg_dump_vtbl_record(&vtbl[i], i);\r\nreturn -EINVAL;\r\n}\r\nstatic int create_vtbl(struct ubi_device *ubi, struct ubi_scan_info *si,\r\nint copy, void *vtbl)\r\n{\r\nint err, tries = 0;\r\nstruct ubi_vid_hdr *vid_hdr;\r\nstruct ubi_scan_leb *new_seb;\r\nubi_msg("create volume table (copy #%d)", copy + 1);\r\nvid_hdr = ubi_zalloc_vid_hdr(ubi, GFP_KERNEL);\r\nif (!vid_hdr)\r\nreturn -ENOMEM;\r\nretry:\r\nnew_seb = ubi_scan_get_free_peb(ubi, si);\r\nif (IS_ERR(new_seb)) {\r\nerr = PTR_ERR(new_seb);\r\ngoto out_free;\r\n}\r\nvid_hdr->vol_type = UBI_LAYOUT_VOLUME_TYPE;\r\nvid_hdr->vol_id = cpu_to_be32(UBI_LAYOUT_VOLUME_ID);\r\nvid_hdr->compat = UBI_LAYOUT_VOLUME_COMPAT;\r\nvid_hdr->data_size = vid_hdr->used_ebs =\r\nvid_hdr->data_pad = cpu_to_be32(0);\r\nvid_hdr->lnum = cpu_to_be32(copy);\r\nvid_hdr->sqnum = cpu_to_be64(++si->max_sqnum);\r\nerr = ubi_io_write_vid_hdr(ubi, new_seb->pnum, vid_hdr);\r\nif (err)\r\ngoto write_error;\r\nerr = ubi_io_write_data(ubi, vtbl, new_seb->pnum, 0, ubi->vtbl_size);\r\nif (err)\r\ngoto write_error;\r\nerr = ubi_scan_add_used(ubi, si, new_seb->pnum, new_seb->ec,\r\nvid_hdr, 0);\r\nkfree(new_seb);\r\nubi_free_vid_hdr(ubi, vid_hdr);\r\nreturn err;\r\nwrite_error:\r\nif (err == -EIO && ++tries <= 5) {\r\nlist_add(&new_seb->u.list, &si->erase);\r\ngoto retry;\r\n}\r\nkfree(new_seb);\r\nout_free:\r\nubi_free_vid_hdr(ubi, vid_hdr);\r\nreturn err;\r\n}\r\nstatic struct ubi_vtbl_record *process_lvol(struct ubi_device *ubi,\r\nstruct ubi_scan_info *si,\r\nstruct ubi_scan_volume *sv)\r\n{\r\nint err;\r\nstruct rb_node *rb;\r\nstruct ubi_scan_leb *seb;\r\nstruct ubi_vtbl_record *leb[UBI_LAYOUT_VOLUME_EBS] = { NULL, NULL };\r\nint leb_corrupted[UBI_LAYOUT_VOLUME_EBS] = {1, 1};\r\ndbg_gen("check layout volume");\r\nubi_rb_for_each_entry(rb, seb, &sv->root, u.rb) {\r\nleb[seb->lnum] = vzalloc(ubi->vtbl_size);\r\nif (!leb[seb->lnum]) {\r\nerr = -ENOMEM;\r\ngoto out_free;\r\n}\r\nerr = ubi_io_read_data(ubi, leb[seb->lnum], seb->pnum, 0,\r\nubi->vtbl_size);\r\nif (err == UBI_IO_BITFLIPS || mtd_is_eccerr(err))\r\nseb->scrub = 1;\r\nelse if (err)\r\ngoto out_free;\r\n}\r\nerr = -EINVAL;\r\nif (leb[0]) {\r\nleb_corrupted[0] = vtbl_check(ubi, leb[0]);\r\nif (leb_corrupted[0] < 0)\r\ngoto out_free;\r\n}\r\nif (!leb_corrupted[0]) {\r\nif (leb[1])\r\nleb_corrupted[1] = memcmp(leb[0], leb[1],\r\nubi->vtbl_size);\r\nif (leb_corrupted[1]) {\r\nubi_warn("volume table copy #2 is corrupted");\r\nerr = create_vtbl(ubi, si, 1, leb[0]);\r\nif (err)\r\ngoto out_free;\r\nubi_msg("volume table was restored");\r\n}\r\nvfree(leb[1]);\r\nreturn leb[0];\r\n} else {\r\nif (leb[1]) {\r\nleb_corrupted[1] = vtbl_check(ubi, leb[1]);\r\nif (leb_corrupted[1] < 0)\r\ngoto out_free;\r\n}\r\nif (leb_corrupted[1]) {\r\nubi_err("both volume tables are corrupted");\r\ngoto out_free;\r\n}\r\nubi_warn("volume table copy #1 is corrupted");\r\nerr = create_vtbl(ubi, si, 0, leb[1]);\r\nif (err)\r\ngoto out_free;\r\nubi_msg("volume table was restored");\r\nvfree(leb[0]);\r\nreturn leb[1];\r\n}\r\nout_free:\r\nvfree(leb[0]);\r\nvfree(leb[1]);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic struct ubi_vtbl_record *create_empty_lvol(struct ubi_device *ubi,\r\nstruct ubi_scan_info *si)\r\n{\r\nint i;\r\nstruct ubi_vtbl_record *vtbl;\r\nvtbl = vzalloc(ubi->vtbl_size);\r\nif (!vtbl)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; i < ubi->vtbl_slots; i++)\r\nmemcpy(&vtbl[i], &empty_vtbl_record, UBI_VTBL_RECORD_SIZE);\r\nfor (i = 0; i < UBI_LAYOUT_VOLUME_EBS; i++) {\r\nint err;\r\nerr = create_vtbl(ubi, si, i, vtbl);\r\nif (err) {\r\nvfree(vtbl);\r\nreturn ERR_PTR(err);\r\n}\r\n}\r\nreturn vtbl;\r\n}\r\nstatic int init_volumes(struct ubi_device *ubi, const struct ubi_scan_info *si,\r\nconst struct ubi_vtbl_record *vtbl)\r\n{\r\nint i, reserved_pebs = 0;\r\nstruct ubi_scan_volume *sv;\r\nstruct ubi_volume *vol;\r\nfor (i = 0; i < ubi->vtbl_slots; i++) {\r\ncond_resched();\r\nif (be32_to_cpu(vtbl[i].reserved_pebs) == 0)\r\ncontinue;\r\nvol = kzalloc(sizeof(struct ubi_volume), GFP_KERNEL);\r\nif (!vol)\r\nreturn -ENOMEM;\r\nvol->reserved_pebs = be32_to_cpu(vtbl[i].reserved_pebs);\r\nvol->alignment = be32_to_cpu(vtbl[i].alignment);\r\nvol->data_pad = be32_to_cpu(vtbl[i].data_pad);\r\nvol->upd_marker = vtbl[i].upd_marker;\r\nvol->vol_type = vtbl[i].vol_type == UBI_VID_DYNAMIC ?\r\nUBI_DYNAMIC_VOLUME : UBI_STATIC_VOLUME;\r\nvol->name_len = be16_to_cpu(vtbl[i].name_len);\r\nvol->usable_leb_size = ubi->leb_size - vol->data_pad;\r\nmemcpy(vol->name, vtbl[i].name, vol->name_len);\r\nvol->name[vol->name_len] = '\0';\r\nvol->vol_id = i;\r\nif (vtbl[i].flags & UBI_VTBL_AUTORESIZE_FLG) {\r\nif (ubi->autoresize_vol_id != -1) {\r\nubi_err("more than one auto-resize volume (%d "\r\n"and %d)", ubi->autoresize_vol_id, i);\r\nkfree(vol);\r\nreturn -EINVAL;\r\n}\r\nubi->autoresize_vol_id = i;\r\n}\r\nubi_assert(!ubi->volumes[i]);\r\nubi->volumes[i] = vol;\r\nubi->vol_count += 1;\r\nvol->ubi = ubi;\r\nreserved_pebs += vol->reserved_pebs;\r\nif (vol->vol_type == UBI_DYNAMIC_VOLUME) {\r\nvol->used_ebs = vol->reserved_pebs;\r\nvol->last_eb_bytes = vol->usable_leb_size;\r\nvol->used_bytes =\r\n(long long)vol->used_ebs * vol->usable_leb_size;\r\ncontinue;\r\n}\r\nsv = ubi_scan_find_sv(si, i);\r\nif (!sv) {\r\ncontinue;\r\n}\r\nif (sv->leb_count != sv->used_ebs) {\r\nubi_warn("static volume %d misses %d LEBs - corrupted",\r\nsv->vol_id, sv->used_ebs - sv->leb_count);\r\nvol->corrupted = 1;\r\ncontinue;\r\n}\r\nvol->used_ebs = sv->used_ebs;\r\nvol->used_bytes =\r\n(long long)(vol->used_ebs - 1) * vol->usable_leb_size;\r\nvol->used_bytes += sv->last_data_size;\r\nvol->last_eb_bytes = sv->last_data_size;\r\n}\r\nvol = kzalloc(sizeof(struct ubi_volume), GFP_KERNEL);\r\nif (!vol)\r\nreturn -ENOMEM;\r\nvol->reserved_pebs = UBI_LAYOUT_VOLUME_EBS;\r\nvol->alignment = UBI_LAYOUT_VOLUME_ALIGN;\r\nvol->vol_type = UBI_DYNAMIC_VOLUME;\r\nvol->name_len = sizeof(UBI_LAYOUT_VOLUME_NAME) - 1;\r\nmemcpy(vol->name, UBI_LAYOUT_VOLUME_NAME, vol->name_len + 1);\r\nvol->usable_leb_size = ubi->leb_size;\r\nvol->used_ebs = vol->reserved_pebs;\r\nvol->last_eb_bytes = vol->reserved_pebs;\r\nvol->used_bytes =\r\n(long long)vol->used_ebs * (ubi->leb_size - vol->data_pad);\r\nvol->vol_id = UBI_LAYOUT_VOLUME_ID;\r\nvol->ref_count = 1;\r\nubi_assert(!ubi->volumes[i]);\r\nubi->volumes[vol_id2idx(ubi, vol->vol_id)] = vol;\r\nreserved_pebs += vol->reserved_pebs;\r\nubi->vol_count += 1;\r\nvol->ubi = ubi;\r\nif (reserved_pebs > ubi->avail_pebs) {\r\nubi_err("not enough PEBs, required %d, available %d",\r\nreserved_pebs, ubi->avail_pebs);\r\nif (ubi->corr_peb_count)\r\nubi_err("%d PEBs are corrupted and not used",\r\nubi->corr_peb_count);\r\n}\r\nubi->rsvd_pebs += reserved_pebs;\r\nubi->avail_pebs -= reserved_pebs;\r\nreturn 0;\r\n}\r\nstatic int check_sv(const struct ubi_volume *vol,\r\nconst struct ubi_scan_volume *sv)\r\n{\r\nint err;\r\nif (sv->highest_lnum >= vol->reserved_pebs) {\r\nerr = 1;\r\ngoto bad;\r\n}\r\nif (sv->leb_count > vol->reserved_pebs) {\r\nerr = 2;\r\ngoto bad;\r\n}\r\nif (sv->vol_type != vol->vol_type) {\r\nerr = 3;\r\ngoto bad;\r\n}\r\nif (sv->used_ebs > vol->reserved_pebs) {\r\nerr = 4;\r\ngoto bad;\r\n}\r\nif (sv->data_pad != vol->data_pad) {\r\nerr = 5;\r\ngoto bad;\r\n}\r\nreturn 0;\r\nbad:\r\nubi_err("bad scanning information, error %d", err);\r\nubi_dbg_dump_sv(sv);\r\nubi_dbg_dump_vol_info(vol);\r\nreturn -EINVAL;\r\n}\r\nstatic int check_scanning_info(const struct ubi_device *ubi,\r\nstruct ubi_scan_info *si)\r\n{\r\nint err, i;\r\nstruct ubi_scan_volume *sv;\r\nstruct ubi_volume *vol;\r\nif (si->vols_found > UBI_INT_VOL_COUNT + ubi->vtbl_slots) {\r\nubi_err("scanning found %d volumes, maximum is %d + %d",\r\nsi->vols_found, UBI_INT_VOL_COUNT, ubi->vtbl_slots);\r\nreturn -EINVAL;\r\n}\r\nif (si->highest_vol_id >= ubi->vtbl_slots + UBI_INT_VOL_COUNT &&\r\nsi->highest_vol_id < UBI_INTERNAL_VOL_START) {\r\nubi_err("too large volume ID %d found by scanning",\r\nsi->highest_vol_id);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ubi->vtbl_slots + UBI_INT_VOL_COUNT; i++) {\r\ncond_resched();\r\nsv = ubi_scan_find_sv(si, i);\r\nvol = ubi->volumes[i];\r\nif (!vol) {\r\nif (sv)\r\nubi_scan_rm_volume(si, sv);\r\ncontinue;\r\n}\r\nif (vol->reserved_pebs == 0) {\r\nubi_assert(i < ubi->vtbl_slots);\r\nif (!sv)\r\ncontinue;\r\nubi_msg("finish volume %d removal", sv->vol_id);\r\nubi_scan_rm_volume(si, sv);\r\n} else if (sv) {\r\nerr = check_sv(vol, sv);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint ubi_read_volume_table(struct ubi_device *ubi, struct ubi_scan_info *si)\r\n{\r\nint i, err;\r\nstruct ubi_scan_volume *sv;\r\nempty_vtbl_record.crc = cpu_to_be32(0xf116c36b);\r\nubi->vtbl_slots = ubi->leb_size / UBI_VTBL_RECORD_SIZE;\r\nif (ubi->vtbl_slots > UBI_MAX_VOLUMES)\r\nubi->vtbl_slots = UBI_MAX_VOLUMES;\r\nubi->vtbl_size = ubi->vtbl_slots * UBI_VTBL_RECORD_SIZE;\r\nubi->vtbl_size = ALIGN(ubi->vtbl_size, ubi->min_io_size);\r\nsv = ubi_scan_find_sv(si, UBI_LAYOUT_VOLUME_ID);\r\nif (!sv) {\r\nif (si->is_empty) {\r\nubi->vtbl = create_empty_lvol(ubi, si);\r\nif (IS_ERR(ubi->vtbl))\r\nreturn PTR_ERR(ubi->vtbl);\r\n} else {\r\nubi_err("the layout volume was not found");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (sv->leb_count > UBI_LAYOUT_VOLUME_EBS) {\r\ndbg_err("too many LEBs (%d) in layout volume",\r\nsv->leb_count);\r\nreturn -EINVAL;\r\n}\r\nubi->vtbl = process_lvol(ubi, si, sv);\r\nif (IS_ERR(ubi->vtbl))\r\nreturn PTR_ERR(ubi->vtbl);\r\n}\r\nubi->avail_pebs = ubi->good_peb_count - ubi->corr_peb_count;\r\nerr = init_volumes(ubi, si, ubi->vtbl);\r\nif (err)\r\ngoto out_free;\r\nerr = check_scanning_info(ubi, si);\r\nif (err)\r\ngoto out_free;\r\nreturn 0;\r\nout_free:\r\nvfree(ubi->vtbl);\r\nfor (i = 0; i < ubi->vtbl_slots + UBI_INT_VOL_COUNT; i++) {\r\nkfree(ubi->volumes[i]);\r\nubi->volumes[i] = NULL;\r\n}\r\nreturn err;\r\n}\r\nstatic void paranoid_vtbl_check(const struct ubi_device *ubi)\r\n{\r\nif (!ubi->dbg->chk_gen)\r\nreturn;\r\nif (vtbl_check(ubi, ubi->vtbl)) {\r\nubi_err("paranoid check failed");\r\nBUG();\r\n}\r\n}
