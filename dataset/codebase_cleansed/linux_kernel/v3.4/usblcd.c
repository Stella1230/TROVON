static void lcd_delete(struct kref *kref)\r\n{\r\nstruct usb_lcd *dev = to_lcd_dev(kref);\r\nusb_put_dev(dev->udev);\r\nkfree(dev->bulk_in_buffer);\r\nkfree(dev);\r\n}\r\nstatic int lcd_open(struct inode *inode, struct file *file)\r\n{\r\nstruct usb_lcd *dev;\r\nstruct usb_interface *interface;\r\nint subminor, r;\r\nmutex_lock(&lcd_mutex);\r\nsubminor = iminor(inode);\r\ninterface = usb_find_interface(&lcd_driver, subminor);\r\nif (!interface) {\r\nmutex_unlock(&lcd_mutex);\r\nerr("USBLCD: %s - error, can't find device for minor %d",\r\n__func__, subminor);\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&open_disc_mutex);\r\ndev = usb_get_intfdata(interface);\r\nif (!dev) {\r\nmutex_unlock(&open_disc_mutex);\r\nmutex_unlock(&lcd_mutex);\r\nreturn -ENODEV;\r\n}\r\nkref_get(&dev->kref);\r\nmutex_unlock(&open_disc_mutex);\r\nr = usb_autopm_get_interface(interface);\r\nif (r < 0) {\r\nkref_put(&dev->kref, lcd_delete);\r\nmutex_unlock(&lcd_mutex);\r\nreturn r;\r\n}\r\nfile->private_data = dev;\r\nmutex_unlock(&lcd_mutex);\r\nreturn 0;\r\n}\r\nstatic int lcd_release(struct inode *inode, struct file *file)\r\n{\r\nstruct usb_lcd *dev;\r\ndev = file->private_data;\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\nusb_autopm_put_interface(dev->interface);\r\nkref_put(&dev->kref, lcd_delete);\r\nreturn 0;\r\n}\r\nstatic ssize_t lcd_read(struct file *file, char __user * buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct usb_lcd *dev;\r\nint retval = 0;\r\nint bytes_read;\r\ndev = file->private_data;\r\nretval = usb_bulk_msg(dev->udev,\r\nusb_rcvbulkpipe(dev->udev,\r\ndev->bulk_in_endpointAddr),\r\ndev->bulk_in_buffer,\r\nmin(dev->bulk_in_size, count),\r\n&bytes_read, 10000);\r\nif (!retval) {\r\nif (copy_to_user(buffer, dev->bulk_in_buffer, bytes_read))\r\nretval = -EFAULT;\r\nelse\r\nretval = bytes_read;\r\n}\r\nreturn retval;\r\n}\r\nstatic long lcd_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_lcd *dev;\r\nu16 bcdDevice;\r\nchar buf[30];\r\ndev = file->private_data;\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\nswitch (cmd) {\r\ncase IOCTL_GET_HARD_VERSION:\r\nmutex_lock(&lcd_mutex);\r\nbcdDevice = le16_to_cpu((dev->udev)->descriptor.bcdDevice);\r\nsprintf(buf, "%1d%1d.%1d%1d",\r\n(bcdDevice & 0xF000)>>12,\r\n(bcdDevice & 0xF00)>>8,\r\n(bcdDevice & 0xF0)>>4,\r\n(bcdDevice & 0xF));\r\nmutex_unlock(&lcd_mutex);\r\nif (copy_to_user((void __user *)arg, buf, strlen(buf)) != 0)\r\nreturn -EFAULT;\r\nbreak;\r\ncase IOCTL_GET_DRV_VERSION:\r\nsprintf(buf, DRIVER_VERSION);\r\nif (copy_to_user((void __user *)arg, buf, strlen(buf)) != 0)\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nreturn -ENOTTY;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void lcd_write_bulk_callback(struct urb *urb)\r\n{\r\nstruct usb_lcd *dev;\r\nint status = urb->status;\r\ndev = urb->context;\r\nif (status &&\r\n!(status == -ENOENT ||\r\nstatus == -ECONNRESET ||\r\nstatus == -ESHUTDOWN)) {\r\ndbg("USBLCD: %s - nonzero write bulk status received: %d",\r\n__func__, status);\r\n}\r\nusb_free_coherent(urb->dev, urb->transfer_buffer_length,\r\nurb->transfer_buffer, urb->transfer_dma);\r\nup(&dev->limit_sem);\r\n}\r\nstatic ssize_t lcd_write(struct file *file, const char __user * user_buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct usb_lcd *dev;\r\nint retval = 0, r;\r\nstruct urb *urb = NULL;\r\nchar *buf = NULL;\r\ndev = file->private_data;\r\nif (count == 0)\r\ngoto exit;\r\nr = down_interruptible(&dev->limit_sem);\r\nif (r < 0)\r\nreturn -EINTR;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\nretval = -ENOMEM;\r\ngoto err_no_buf;\r\n}\r\nbuf = usb_alloc_coherent(dev->udev, count, GFP_KERNEL,\r\n&urb->transfer_dma);\r\nif (!buf) {\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\nif (copy_from_user(buf, user_buffer, count)) {\r\nretval = -EFAULT;\r\ngoto error;\r\n}\r\nusb_fill_bulk_urb(urb, dev->udev,\r\nusb_sndbulkpipe(dev->udev,\r\ndev->bulk_out_endpointAddr),\r\nbuf, count, lcd_write_bulk_callback, dev);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_anchor_urb(urb, &dev->submitted);\r\nretval = usb_submit_urb(urb, GFP_KERNEL);\r\nif (retval) {\r\nerr("USBLCD: %s - failed submitting write urb, error %d",\r\n__func__, retval);\r\ngoto error_unanchor;\r\n}\r\nusb_free_urb(urb);\r\nexit:\r\nreturn count;\r\nerror_unanchor:\r\nusb_unanchor_urb(urb);\r\nerror:\r\nusb_free_coherent(dev->udev, count, buf, urb->transfer_dma);\r\nusb_free_urb(urb);\r\nerr_no_buf:\r\nup(&dev->limit_sem);\r\nreturn retval;\r\n}\r\nstatic int lcd_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_lcd *dev = NULL;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nsize_t buffer_size;\r\nint i;\r\nint retval = -ENOMEM;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\nerr("Out of memory");\r\ngoto error;\r\n}\r\nkref_init(&dev->kref);\r\nsema_init(&dev->limit_sem, USB_LCD_CONCURRENT_WRITES);\r\ninit_usb_anchor(&dev->submitted);\r\ndev->udev = usb_get_dev(interface_to_usbdev(interface));\r\ndev->interface = interface;\r\nif (le16_to_cpu(dev->udev->descriptor.idProduct) != 0x0001) {\r\ndev_warn(&interface->dev, "USBLCD model not supported.\n");\r\nretval = -ENODEV;\r\ngoto error;\r\n}\r\niface_desc = interface->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (!dev->bulk_in_endpointAddr &&\r\nusb_endpoint_is_bulk_in(endpoint)) {\r\nbuffer_size = usb_endpoint_maxp(endpoint);\r\ndev->bulk_in_size = buffer_size;\r\ndev->bulk_in_endpointAddr = endpoint->bEndpointAddress;\r\ndev->bulk_in_buffer = kmalloc(buffer_size, GFP_KERNEL);\r\nif (!dev->bulk_in_buffer) {\r\nerr("Could not allocate bulk_in_buffer");\r\ngoto error;\r\n}\r\n}\r\nif (!dev->bulk_out_endpointAddr &&\r\nusb_endpoint_is_bulk_out(endpoint)) {\r\ndev->bulk_out_endpointAddr = endpoint->bEndpointAddress;\r\n}\r\n}\r\nif (!(dev->bulk_in_endpointAddr && dev->bulk_out_endpointAddr)) {\r\nerr("Could not find both bulk-in and bulk-out endpoints");\r\ngoto error;\r\n}\r\nusb_set_intfdata(interface, dev);\r\nretval = usb_register_dev(interface, &lcd_class);\r\nif (retval) {\r\nerr("Not able to get a minor for this device.");\r\nusb_set_intfdata(interface, NULL);\r\ngoto error;\r\n}\r\ni = le16_to_cpu(dev->udev->descriptor.bcdDevice);\r\ndev_info(&interface->dev, "USBLCD Version %1d%1d.%1d%1d found "\r\n"at address %d\n", (i & 0xF000)>>12, (i & 0xF00)>>8,\r\n(i & 0xF0)>>4, (i & 0xF), dev->udev->devnum);\r\ndev_info(&interface->dev, "USB LCD device now attached to USBLCD-%d\n",\r\ninterface->minor);\r\nreturn 0;\r\nerror:\r\nif (dev)\r\nkref_put(&dev->kref, lcd_delete);\r\nreturn retval;\r\n}\r\nstatic void lcd_draw_down(struct usb_lcd *dev)\r\n{\r\nint time;\r\ntime = usb_wait_anchor_empty_timeout(&dev->submitted, 1000);\r\nif (!time)\r\nusb_kill_anchored_urbs(&dev->submitted);\r\n}\r\nstatic int lcd_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct usb_lcd *dev = usb_get_intfdata(intf);\r\nif (!dev)\r\nreturn 0;\r\nlcd_draw_down(dev);\r\nreturn 0;\r\n}\r\nstatic int lcd_resume(struct usb_interface *intf)\r\n{\r\nreturn 0;\r\n}\r\nstatic void lcd_disconnect(struct usb_interface *interface)\r\n{\r\nstruct usb_lcd *dev;\r\nint minor = interface->minor;\r\nmutex_lock(&open_disc_mutex);\r\ndev = usb_get_intfdata(interface);\r\nusb_set_intfdata(interface, NULL);\r\nmutex_unlock(&open_disc_mutex);\r\nusb_deregister_dev(interface, &lcd_class);\r\nkref_put(&dev->kref, lcd_delete);\r\ndev_info(&interface->dev, "USB LCD #%d now disconnected\n", minor);\r\n}
