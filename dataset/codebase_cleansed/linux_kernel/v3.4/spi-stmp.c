static int stmp_spi_init_hw(struct stmp_spi *ss)\r\n{\r\nint err = 0;\r\nvoid *pins = ss->master_dev->platform_data;\r\nerr = stmp3xxx_request_pin_group(pins, dev_name(ss->master_dev));\r\nif (err)\r\ngoto out;\r\nss->clk = clk_get(NULL, "ssp");\r\nif (IS_ERR(ss->clk)) {\r\nerr = PTR_ERR(ss->clk);\r\ngoto out_free_pins;\r\n}\r\nclk_enable(ss->clk);\r\nstmp3xxx_reset_block(ss->regs, false);\r\nstmp3xxx_dma_reset_channel(ss->dma);\r\nreturn 0;\r\nout_free_pins:\r\nstmp3xxx_release_pin_group(pins, dev_name(ss->master_dev));\r\nout:\r\nreturn err;\r\n}\r\nstatic void stmp_spi_release_hw(struct stmp_spi *ss)\r\n{\r\nvoid *pins = ss->master_dev->platform_data;\r\nif (ss->clk && !IS_ERR(ss->clk)) {\r\nclk_disable(ss->clk);\r\nclk_put(ss->clk);\r\n}\r\nstmp3xxx_release_pin_group(pins, dev_name(ss->master_dev));\r\n}\r\nstatic int stmp_spi_setup_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nu8 bits_per_word;\r\nu32 hz;\r\nstruct stmp_spi *ss = spi_master_get_devdata(spi->master);\r\nu16 rate;\r\nbits_per_word = spi->bits_per_word;\r\nif (t && t->bits_per_word)\r\nbits_per_word = t->bits_per_word;\r\nhz = 1000 * ss->speed_khz / ss->divider;\r\nif (spi->max_speed_hz)\r\nhz = min(hz, spi->max_speed_hz);\r\nif (t && t->speed_hz)\r\nhz = min(hz, t->speed_hz);\r\nif (hz == 0) {\r\ndev_err(&spi->dev, "Cannot continue with zero clock\n");\r\nreturn -EINVAL;\r\n}\r\nif (bits_per_word != 8) {\r\ndev_err(&spi->dev, "%s, unsupported bits_per_word=%d\n",\r\n__func__, bits_per_word);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&spi->dev, "Requested clk rate = %uHz, max = %uHz/%d = %uHz\n",\r\nhz, ss->speed_khz, ss->divider,\r\nss->speed_khz * 1000 / ss->divider);\r\nif (ss->speed_khz * 1000 / ss->divider < hz) {\r\ndev_err(&spi->dev, "%s, unsupported clock rate %uHz\n",\r\n__func__, hz);\r\nreturn -EINVAL;\r\n}\r\nrate = 1000 * ss->speed_khz/ss->divider/hz;\r\nwritel(BF(ss->divider, SSP_TIMING_CLOCK_DIVIDE) |\r\nBF(rate - 1, SSP_TIMING_CLOCK_RATE),\r\nHW_SSP_TIMING + ss->regs);\r\nwritel(BF(1 , SSP_CTRL1_SSP_MODE) |\r\nBF(4 , SSP_CTRL1_WORD_LENGTH) |\r\n((spi->mode & SPI_CPOL) ? BM_SSP_CTRL1_POLARITY : 0) |\r\n((spi->mode & SPI_CPHA) ? BM_SSP_CTRL1_PHASE : 0) |\r\n(pio ? 0 : BM_SSP_CTRL1_DMA_ENABLE),\r\nss->regs + HW_SSP_CTRL1);\r\nreturn 0;\r\n}\r\nstatic int stmp_spi_setup(struct spi_device *spi)\r\n{\r\nif (spi->bits_per_word != 8) {\r\ndev_err(&spi->dev, "%s, unsupported bits_per_word=%d\n",\r\n__func__, spi->bits_per_word);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline u32 stmp_spi_cs(unsigned cs)\r\n{\r\nreturn ((cs & 1) ? BM_SSP_CTRL0_WAIT_FOR_CMD : 0) |\r\n((cs & 2) ? BM_SSP_CTRL0_WAIT_FOR_IRQ : 0);\r\n}\r\nstatic int stmp_spi_txrx_dma(struct stmp_spi *ss, int cs,\r\nunsigned char *buf, dma_addr_t dma_buf, int len,\r\nint first, int last, bool write)\r\n{\r\nu32 c0 = 0;\r\ndma_addr_t spi_buf_dma = dma_buf;\r\nint status = 0;\r\nenum dma_data_direction dir = write ? DMA_TO_DEVICE : DMA_FROM_DEVICE;\r\nc0 |= (first ? BM_SSP_CTRL0_LOCK_CS : 0);\r\nc0 |= (last ? BM_SSP_CTRL0_IGNORE_CRC : 0);\r\nc0 |= (write ? 0 : BM_SSP_CTRL0_READ);\r\nc0 |= BM_SSP_CTRL0_DATA_XFER;\r\nc0 |= stmp_spi_cs(cs);\r\nc0 |= BF(len, SSP_CTRL0_XFER_COUNT);\r\nif (!dma_buf)\r\nspi_buf_dma = dma_map_single(ss->master_dev, buf, len, dir);\r\nss->d.command->cmd =\r\nBF(len, APBH_CHn_CMD_XFER_COUNT) |\r\nBF(1, APBH_CHn_CMD_CMDWORDS) |\r\nBM_APBH_CHn_CMD_WAIT4ENDCMD |\r\nBM_APBH_CHn_CMD_IRQONCMPLT |\r\nBF(write ? BV_APBH_CHn_CMD_COMMAND__DMA_READ :\r\nBV_APBH_CHn_CMD_COMMAND__DMA_WRITE,\r\nAPBH_CHn_CMD_COMMAND);\r\nss->d.command->pio_words[0] = c0;\r\nss->d.command->buf_ptr = spi_buf_dma;\r\nstmp3xxx_dma_reset_channel(ss->dma);\r\nstmp3xxx_dma_clear_interrupt(ss->dma);\r\nstmp3xxx_dma_enable_interrupt(ss->dma);\r\ninit_completion(&ss->done);\r\nstmp3xxx_dma_go(ss->dma, &ss->d, 1);\r\nwait_for_completion(&ss->done);\r\nif (!busy_wait(readl(ss->regs + HW_SSP_CTRL0) & BM_SSP_CTRL0_RUN))\r\nstatus = -ETIMEDOUT;\r\nif (!dma_buf)\r\ndma_unmap_single(ss->master_dev, spi_buf_dma, len, dir);\r\nreturn status;\r\n}\r\nstatic inline void stmp_spi_enable(struct stmp_spi *ss)\r\n{\r\nstmp3xxx_setl(BM_SSP_CTRL0_LOCK_CS, ss->regs + HW_SSP_CTRL0);\r\nstmp3xxx_clearl(BM_SSP_CTRL0_IGNORE_CRC, ss->regs + HW_SSP_CTRL0);\r\n}\r\nstatic inline void stmp_spi_disable(struct stmp_spi *ss)\r\n{\r\nstmp3xxx_clearl(BM_SSP_CTRL0_LOCK_CS, ss->regs + HW_SSP_CTRL0);\r\nstmp3xxx_setl(BM_SSP_CTRL0_IGNORE_CRC, ss->regs + HW_SSP_CTRL0);\r\n}\r\nstatic int stmp_spi_txrx_pio(struct stmp_spi *ss, int cs,\r\nunsigned char *buf, int len,\r\nbool first, bool last, bool write)\r\n{\r\nif (first)\r\nstmp_spi_enable(ss);\r\nstmp3xxx_setl(stmp_spi_cs(cs), ss->regs + HW_SSP_CTRL0);\r\nwhile (len--) {\r\nif (last && len <= 0)\r\nstmp_spi_disable(ss);\r\nstmp3xxx_clearl(BM_SSP_CTRL0_XFER_COUNT,\r\nss->regs + HW_SSP_CTRL0);\r\nstmp3xxx_setl(1, ss->regs + HW_SSP_CTRL0);\r\nif (write)\r\nstmp3xxx_clearl(BM_SSP_CTRL0_READ,\r\nss->regs + HW_SSP_CTRL0);\r\nelse\r\nstmp3xxx_setl(BM_SSP_CTRL0_READ,\r\nss->regs + HW_SSP_CTRL0);\r\nstmp3xxx_setl(BM_SSP_CTRL0_RUN, ss->regs + HW_SSP_CTRL0);\r\nif (!busy_wait(readl(ss->regs + HW_SSP_CTRL0) &\r\nBM_SSP_CTRL0_RUN))\r\nbreak;\r\nif (write)\r\nwritel(*buf, ss->regs + HW_SSP_DATA);\r\nstmp3xxx_setl(BM_SSP_CTRL0_DATA_XFER, ss->regs + HW_SSP_CTRL0);\r\nif (!write) {\r\nif (busy_wait((readl(ss->regs + HW_SSP_STATUS) &\r\nBM_SSP_STATUS_FIFO_EMPTY)))\r\nbreak;\r\n*buf = readl(ss->regs + HW_SSP_DATA) & 0xFF;\r\n}\r\nif (!busy_wait(readl(ss->regs + HW_SSP_CTRL0) &\r\nBM_SSP_CTRL0_RUN))\r\nbreak;\r\nbuf++;\r\n}\r\nreturn len < 0 ? 0 : -ETIMEDOUT;\r\n}\r\nstatic int stmp_spi_handle_message(struct stmp_spi *ss, struct spi_message *m)\r\n{\r\nbool first, last;\r\nstruct spi_transfer *t, *tmp_t;\r\nint status = 0;\r\nint cs;\r\ncs = m->spi->chip_select;\r\nlist_for_each_entry_safe(t, tmp_t, &m->transfers, transfer_list) {\r\nfirst = (&t->transfer_list == m->transfers.next);\r\nlast = (&t->transfer_list == m->transfers.prev);\r\nif (first || t->speed_hz || t->bits_per_word)\r\nstmp_spi_setup_transfer(m->spi, t);\r\nif (t->cs_change && !last) {\r\ndev_err(&m->spi->dev,\r\n"Message with t->cs_change has been skipped\n");\r\ncontinue;\r\n}\r\nif (t->tx_buf) {\r\nstatus = pio ?\r\nstmp_spi_txrx_pio(ss, cs, (void *)t->tx_buf,\r\nt->len, first, last, true) :\r\nstmp_spi_txrx_dma(ss, cs, (void *)t->tx_buf,\r\nt->tx_dma, t->len, first, last, true);\r\n#ifdef DEBUG\r\nif (t->len < 0x10)\r\nprint_hex_dump_bytes("Tx ",\r\nDUMP_PREFIX_OFFSET,\r\nt->tx_buf, t->len);\r\nelse\r\npr_debug("Tx: %d bytes\n", t->len);\r\n#endif\r\n}\r\nif (t->rx_buf) {\r\nstatus = pio ?\r\nstmp_spi_txrx_pio(ss, cs, t->rx_buf,\r\nt->len, first, last, false) :\r\nstmp_spi_txrx_dma(ss, cs, t->rx_buf,\r\nt->rx_dma, t->len, first, last, false);\r\n#ifdef DEBUG\r\nif (t->len < 0x10)\r\nprint_hex_dump_bytes("Rx ",\r\nDUMP_PREFIX_OFFSET,\r\nt->rx_buf, t->len);\r\nelse\r\npr_debug("Rx: %d bytes\n", t->len);\r\n#endif\r\n}\r\nif (t->delay_usecs)\r\nudelay(t->delay_usecs);\r\nif (status)\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic void stmp_spi_handle(struct work_struct *w)\r\n{\r\nstruct stmp_spi *ss = container_of(w, struct stmp_spi, work);\r\nunsigned long flags;\r\nstruct spi_message *m;\r\nspin_lock_irqsave(&ss->lock, flags);\r\nwhile (!list_empty(&ss->queue)) {\r\nm = list_entry(ss->queue.next, struct spi_message, queue);\r\nlist_del_init(&m->queue);\r\nspin_unlock_irqrestore(&ss->lock, flags);\r\nm->status = stmp_spi_handle_message(ss, m);\r\nm->complete(m->context);\r\nspin_lock_irqsave(&ss->lock, flags);\r\n}\r\nspin_unlock_irqrestore(&ss->lock, flags);\r\nreturn;\r\n}\r\nstatic int stmp_spi_transfer(struct spi_device *spi, struct spi_message *m)\r\n{\r\nstruct stmp_spi *ss = spi_master_get_devdata(spi->master);\r\nunsigned long flags;\r\nm->status = -EINPROGRESS;\r\nspin_lock_irqsave(&ss->lock, flags);\r\nlist_add_tail(&m->queue, &ss->queue);\r\nqueue_work(ss->workqueue, &ss->work);\r\nspin_unlock_irqrestore(&ss->lock, flags);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t stmp_spi_irq(int irq, void *dev_id)\r\n{\r\nstruct stmp_spi *ss = dev_id;\r\nstmp3xxx_dma_clear_interrupt(ss->dma);\r\ncomplete(&ss->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t stmp_spi_irq_err(int irq, void *dev_id)\r\n{\r\nstruct stmp_spi *ss = dev_id;\r\nu32 c1, st;\r\nc1 = readl(ss->regs + HW_SSP_CTRL1);\r\nst = readl(ss->regs + HW_SSP_STATUS);\r\ndev_err(ss->master_dev, "%s: status = 0x%08X, c1 = 0x%08X\n",\r\n__func__, st, c1);\r\nstmp3xxx_clearl(c1 & 0xCCCC0000, ss->regs + HW_SSP_CTRL1);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit stmp_spi_probe(struct platform_device *dev)\r\n{\r\nint err = 0;\r\nstruct spi_master *master;\r\nstruct stmp_spi *ss;\r\nstruct resource *r;\r\nmaster = spi_alloc_master(&dev->dev, sizeof(struct stmp_spi));\r\nif (master == NULL) {\r\nerr = -ENOMEM;\r\ngoto out0;\r\n}\r\nmaster->flags = SPI_MASTER_HALF_DUPLEX;\r\nss = spi_master_get_devdata(master);\r\nplatform_set_drvdata(dev, master);\r\nr = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (r == NULL) {\r\nerr = -ENODEV;\r\ngoto out_put_master;\r\n}\r\nss->regs = ioremap(r->start, resource_size(r));\r\nif (!ss->regs) {\r\nerr = -EINVAL;\r\ngoto out_put_master;\r\n}\r\nss->master_dev = &dev->dev;\r\nss->id = dev->id;\r\nINIT_WORK(&ss->work, stmp_spi_handle);\r\nINIT_LIST_HEAD(&ss->queue);\r\nspin_lock_init(&ss->lock);\r\nss->workqueue = create_singlethread_workqueue(dev_name(&dev->dev));\r\nif (!ss->workqueue) {\r\nerr = -ENXIO;\r\ngoto out_put_master;\r\n}\r\nmaster->transfer = stmp_spi_transfer;\r\nmaster->setup = stmp_spi_setup;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA;\r\nss->irq = platform_get_irq(dev, 0);\r\nif (ss->irq < 0) {\r\nerr = ss->irq;\r\ngoto out_put_master;\r\n}\r\nss->err_irq = platform_get_irq(dev, 1);\r\nif (ss->err_irq < 0) {\r\nerr = ss->err_irq;\r\ngoto out_put_master;\r\n}\r\nr = platform_get_resource(dev, IORESOURCE_DMA, 0);\r\nif (r == NULL) {\r\nerr = -ENODEV;\r\ngoto out_put_master;\r\n}\r\nss->dma = r->start;\r\nerr = stmp3xxx_dma_request(ss->dma, &dev->dev, dev_name(&dev->dev));\r\nif (err)\r\ngoto out_put_master;\r\nerr = stmp3xxx_dma_allocate_command(ss->dma, &ss->d);\r\nif (err)\r\ngoto out_free_dma;\r\nmaster->bus_num = dev->id;\r\nmaster->num_chipselect = 1;\r\nerr = stmp_spi_init_hw(ss);\r\nif (err) {\r\ndev_dbg(&dev->dev, "cannot initialize hardware\n");\r\ngoto out_free_dma_desc;\r\n}\r\nif (clock) {\r\ndev_info(&dev->dev, "clock rate forced to %d\n", clock);\r\nclk_set_rate(ss->clk, clock);\r\n}\r\nss->speed_khz = clk_get_rate(ss->clk);\r\nss->divider = 2;\r\ndev_info(&dev->dev, "max possible speed %d = %ld/%d kHz\n",\r\nss->speed_khz, clk_get_rate(ss->clk), ss->divider);\r\nerr = request_irq(ss->irq, stmp_spi_irq, 0,\r\ndev_name(&dev->dev), ss);\r\nif (err) {\r\ndev_dbg(&dev->dev, "request_irq failed, %d\n", err);\r\ngoto out_release_hw;\r\n}\r\nerr = request_irq(ss->err_irq, stmp_spi_irq_err, IRQF_SHARED,\r\ndev_name(&dev->dev), ss);\r\nif (err) {\r\ndev_dbg(&dev->dev, "request_irq(error) failed, %d\n", err);\r\ngoto out_free_irq;\r\n}\r\nerr = spi_register_master(master);\r\nif (err) {\r\ndev_dbg(&dev->dev, "cannot register spi master, %d\n", err);\r\ngoto out_free_irq_2;\r\n}\r\ndev_info(&dev->dev, "at (mapped) 0x%08X, irq=%d, bus %d, %s mode\n",\r\n(u32)ss->regs, ss->irq, master->bus_num,\r\npio ? "PIO" : "DMA");\r\nreturn 0;\r\nout_free_irq_2:\r\nfree_irq(ss->err_irq, ss);\r\nout_free_irq:\r\nfree_irq(ss->irq, ss);\r\nout_free_dma_desc:\r\nstmp3xxx_dma_free_command(ss->dma, &ss->d);\r\nout_free_dma:\r\nstmp3xxx_dma_release(ss->dma);\r\nout_release_hw:\r\nstmp_spi_release_hw(ss);\r\nout_put_master:\r\nif (ss->workqueue)\r\ndestroy_workqueue(ss->workqueue);\r\nif (ss->regs)\r\niounmap(ss->regs);\r\nplatform_set_drvdata(dev, NULL);\r\nspi_master_put(master);\r\nout0:\r\nreturn err;\r\n}\r\nstatic int __devexit stmp_spi_remove(struct platform_device *dev)\r\n{\r\nstruct stmp_spi *ss;\r\nstruct spi_master *master;\r\nmaster = platform_get_drvdata(dev);\r\nif (master == NULL)\r\ngoto out0;\r\nss = spi_master_get_devdata(master);\r\nspi_unregister_master(master);\r\nfree_irq(ss->err_irq, ss);\r\nfree_irq(ss->irq, ss);\r\nstmp3xxx_dma_free_command(ss->dma, &ss->d);\r\nstmp3xxx_dma_release(ss->dma);\r\nstmp_spi_release_hw(ss);\r\ndestroy_workqueue(ss->workqueue);\r\niounmap(ss->regs);\r\nspi_master_put(master);\r\nplatform_set_drvdata(dev, NULL);\r\nout0:\r\nreturn 0;\r\n}\r\nstatic int stmp_spi_suspend(struct platform_device *pdev, pm_message_t pmsg)\r\n{\r\nstruct stmp_spi *ss;\r\nstruct spi_master *master;\r\nmaster = platform_get_drvdata(pdev);\r\nss = spi_master_get_devdata(master);\r\nss->saved_timings = readl(HW_SSP_TIMING + ss->regs);\r\nclk_disable(ss->clk);\r\nreturn 0;\r\n}\r\nstatic int stmp_spi_resume(struct platform_device *pdev)\r\n{\r\nstruct stmp_spi *ss;\r\nstruct spi_master *master;\r\nmaster = platform_get_drvdata(pdev);\r\nss = spi_master_get_devdata(master);\r\nclk_enable(ss->clk);\r\nstmp3xxx_reset_block(ss->regs, false);\r\nwritel(ss->saved_timings, ss->regs + HW_SSP_TIMING);\r\nreturn 0;\r\n}
