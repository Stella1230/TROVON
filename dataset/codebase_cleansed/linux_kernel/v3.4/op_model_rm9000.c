static void rm9000_reg_setup(struct op_counter_config *ctr)\r\n{\r\nunsigned int control = 0;\r\nif (ctr[0].enabled)\r\ncontrol |= RM9K_COUNTER1_EVENT(ctr[0].event) |\r\nRM9K_COUNTER1_KERNEL |\r\nRM9K_COUNTER1_USER |\r\nRM9K_COUNTER1_ENABLE;\r\nif (ctr[1].enabled)\r\ncontrol |= RM9K_COUNTER2_EVENT(ctr[1].event) |\r\nRM9K_COUNTER2_KERNEL |\r\nRM9K_COUNTER2_USER |\r\nRM9K_COUNTER2_ENABLE;\r\nreg.control = control;\r\nreg.reset_counter1 = 0x80000000 - ctr[0].count;\r\nreg.reset_counter2 = 0x80000000 - ctr[1].count;\r\n}\r\nstatic void rm9000_cpu_setup(void *args)\r\n{\r\nuint64_t perfcount;\r\nperfcount = ((uint64_t) reg.reset_counter2 << 32) | reg.reset_counter1;\r\nwrite_c0_perfcount(perfcount);\r\n}\r\nstatic void rm9000_cpu_start(void *args)\r\n{\r\nwrite_c0_perfcontrol(reg.control);\r\n}\r\nstatic void rm9000_cpu_stop(void *args)\r\n{\r\nwrite_c0_perfcontrol(0);\r\n}\r\nstatic irqreturn_t rm9000_perfcount_handler(int irq, void *dev_id)\r\n{\r\nunsigned int control = read_c0_perfcontrol();\r\nstruct pt_regs *regs = get_irq_regs();\r\nuint32_t counter1, counter2;\r\nuint64_t counters;\r\nwrite_c0_perfcontrol(0);\r\ncounters = read_c0_perfcount();\r\ncounter1 = counters;\r\ncounter2 = counters >> 32;\r\nif (control & RM9K_COUNTER1_OVERFLOW) {\r\noprofile_add_sample(regs, 0);\r\ncounter1 = reg.reset_counter1;\r\n}\r\nif (control & RM9K_COUNTER2_OVERFLOW) {\r\noprofile_add_sample(regs, 1);\r\ncounter2 = reg.reset_counter2;\r\n}\r\ncounters = ((uint64_t)counter2 << 32) | counter1;\r\nwrite_c0_perfcount(counters);\r\nwrite_c0_perfcontrol(reg.control);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init rm9000_init(void)\r\n{\r\nreturn request_irq(rm9000_perfcount_irq, rm9000_perfcount_handler,\r\n0, "Perfcounter", NULL);\r\n}\r\nstatic void rm9000_exit(void)\r\n{\r\nfree_irq(rm9000_perfcount_irq, NULL);\r\n}
