static void dc_scan_kbd(struct dc_kbd *kbd)\r\n{\r\nstruct input_dev *dev = kbd->dev;\r\nvoid *ptr;\r\nint code, keycode;\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\ncode = i + 224;\r\nkeycode = kbd->keycode[code];\r\ninput_event(dev, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(dev, keycode, (kbd->new[0] >> i) & 1);\r\n}\r\nfor (i = 2; i < 8; i++) {\r\nptr = memchr(kbd->new + 2, kbd->old[i], 6);\r\ncode = kbd->old[i];\r\nif (code > 3 && ptr == NULL) {\r\nkeycode = kbd->keycode[code];\r\nif (keycode) {\r\ninput_event(dev, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(dev, keycode, 0);\r\n} else\r\ndev_dbg(&dev->dev,\r\n"Unknown key (scancode %#x) released.",\r\ncode);\r\n}\r\nptr = memchr(kbd->old + 2, kbd->new[i], 6);\r\ncode = kbd->new[i];\r\nif (code > 3 && ptr) {\r\nkeycode = kbd->keycode[code];\r\nif (keycode) {\r\ninput_event(dev, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(dev, keycode, 1);\r\n} else\r\ndev_dbg(&dev->dev,\r\n"Unknown key (scancode %#x) pressed.",\r\ncode);\r\n}\r\n}\r\ninput_sync(dev);\r\nmemcpy(kbd->old, kbd->new, 8);\r\n}\r\nstatic void dc_kbd_callback(struct mapleq *mq)\r\n{\r\nstruct maple_device *mapledev = mq->dev;\r\nstruct dc_kbd *kbd = maple_get_drvdata(mapledev);\r\nunsigned long *buf = (unsigned long *)(mq->recvbuf->buf);\r\nif (likely(mutex_trylock(&maple_keyb_mutex))) {\r\nif (buf[1] == mapledev->function) {\r\nmemcpy(kbd->new, buf + 2, 8);\r\ndc_scan_kbd(kbd);\r\n}\r\nmutex_unlock(&maple_keyb_mutex);\r\n}\r\n}\r\nstatic int probe_maple_kbd(struct device *dev)\r\n{\r\nstruct maple_device *mdev;\r\nstruct maple_driver *mdrv;\r\nint i, error;\r\nstruct dc_kbd *kbd;\r\nstruct input_dev *idev;\r\nmdev = to_maple_dev(dev);\r\nmdrv = to_maple_driver(dev->driver);\r\nkbd = kzalloc(sizeof(struct dc_kbd), GFP_KERNEL);\r\nif (!kbd) {\r\nerror = -ENOMEM;\r\ngoto fail;\r\n}\r\nidev = input_allocate_device();\r\nif (!idev) {\r\nerror = -ENOMEM;\r\ngoto fail_idev_alloc;\r\n}\r\nkbd->dev = idev;\r\nmemcpy(kbd->keycode, dc_kbd_keycode, sizeof(kbd->keycode));\r\nidev->name = mdev->product_name;\r\nidev->evbit[0] = BIT(EV_KEY) | BIT(EV_REP);\r\nidev->keycode = kbd->keycode;\r\nidev->keycodesize = sizeof(unsigned short);\r\nidev->keycodemax = ARRAY_SIZE(kbd->keycode);\r\nidev->id.bustype = BUS_HOST;\r\nidev->dev.parent = &mdev->dev;\r\nfor (i = 0; i < NR_SCANCODES; i++)\r\n__set_bit(dc_kbd_keycode[i], idev->keybit);\r\n__clear_bit(KEY_RESERVED, idev->keybit);\r\ninput_set_capability(idev, EV_MSC, MSC_SCAN);\r\ninput_set_drvdata(idev, kbd);\r\nerror = input_register_device(idev);\r\nif (error)\r\ngoto fail_register;\r\nmaple_getcond_callback(mdev, dc_kbd_callback, HZ/50,\r\nMAPLE_FUNC_KEYBOARD);\r\nmdev->driver = mdrv;\r\nmaple_set_drvdata(mdev, kbd);\r\nreturn error;\r\nfail_register:\r\nmaple_set_drvdata(mdev, NULL);\r\ninput_free_device(idev);\r\nfail_idev_alloc:\r\nkfree(kbd);\r\nfail:\r\nreturn error;\r\n}\r\nstatic int remove_maple_kbd(struct device *dev)\r\n{\r\nstruct maple_device *mdev = to_maple_dev(dev);\r\nstruct dc_kbd *kbd = maple_get_drvdata(mdev);\r\nmutex_lock(&maple_keyb_mutex);\r\ninput_unregister_device(kbd->dev);\r\nkfree(kbd);\r\nmaple_set_drvdata(mdev, NULL);\r\nmutex_unlock(&maple_keyb_mutex);\r\nreturn 0;\r\n}\r\nstatic int __init dc_kbd_init(void)\r\n{\r\nreturn maple_driver_register(&dc_kbd_driver);\r\n}\r\nstatic void __exit dc_kbd_exit(void)\r\n{\r\nmaple_driver_unregister(&dc_kbd_driver);\r\n}
