static void __init early_code_mapping_set_exec(int executable)\r\n{\r\nefi_memory_desc_t *md;\r\nvoid *p;\r\nif (!(__supported_pte_mask & _PAGE_NX))\r\nreturn;\r\nfor (p = memmap.map; p < memmap.map_end; p += memmap.desc_size) {\r\nmd = p;\r\nif (md->type == EFI_RUNTIME_SERVICES_CODE ||\r\nmd->type == EFI_BOOT_SERVICES_CODE)\r\nefi_set_executable(md, executable);\r\n}\r\n}\r\nvoid __init efi_call_phys_prelog(void)\r\n{\r\nunsigned long vaddress;\r\nearly_code_mapping_set_exec(1);\r\nlocal_irq_save(efi_flags);\r\nvaddress = (unsigned long)__va(0x0UL);\r\nsave_pgd = *pgd_offset_k(0x0UL);\r\nset_pgd(pgd_offset_k(0x0UL), *pgd_offset_k(vaddress));\r\n__flush_tlb_all();\r\n}\r\nvoid __init efi_call_phys_epilog(void)\r\n{\r\nset_pgd(pgd_offset_k(0x0UL), save_pgd);\r\n__flush_tlb_all();\r\nlocal_irq_restore(efi_flags);\r\nearly_code_mapping_set_exec(0);\r\n}\r\nvoid __iomem *__init efi_ioremap(unsigned long phys_addr, unsigned long size,\r\nu32 type)\r\n{\r\nunsigned long last_map_pfn;\r\nif (type == EFI_MEMORY_MAPPED_IO)\r\nreturn ioremap(phys_addr, size);\r\nlast_map_pfn = init_memory_mapping(phys_addr, phys_addr + size);\r\nif ((last_map_pfn << PAGE_SHIFT) < phys_addr + size) {\r\nunsigned long top = last_map_pfn << PAGE_SHIFT;\r\nefi_ioremap(top, size - (top - phys_addr), type);\r\n}\r\nreturn (void __iomem *)__va(phys_addr);\r\n}
