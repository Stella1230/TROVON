static struct kmem_cache * __init zfcp_cache_hw_align(const char *name,\r\nunsigned long size)\r\n{\r\nreturn kmem_cache_create(name, size, roundup_pow_of_two(size), 0, NULL);\r\n}\r\nstatic void __init zfcp_init_device_configure(char *busid, u64 wwpn, u64 lun)\r\n{\r\nstruct ccw_device *cdev;\r\nstruct zfcp_adapter *adapter;\r\nstruct zfcp_port *port;\r\ncdev = get_ccwdev_by_busid(&zfcp_ccw_driver, busid);\r\nif (!cdev)\r\nreturn;\r\nif (ccw_device_set_online(cdev))\r\ngoto out_ccw_device;\r\nadapter = zfcp_ccw_adapter_by_cdev(cdev);\r\nif (!adapter)\r\ngoto out_ccw_device;\r\nport = zfcp_get_port_by_wwpn(adapter, wwpn);\r\nif (!port)\r\ngoto out_port;\r\nflush_work(&port->rport_work);\r\nzfcp_unit_add(port, lun);\r\nput_device(&port->dev);\r\nout_port:\r\nzfcp_ccw_adapter_put(adapter);\r\nout_ccw_device:\r\nput_device(&cdev->dev);\r\nreturn;\r\n}\r\nstatic void __init zfcp_init_device_setup(char *devstr)\r\n{\r\nchar *token;\r\nchar *str, *str_saved;\r\nchar busid[ZFCP_BUS_ID_SIZE];\r\nu64 wwpn, lun;\r\nstr_saved = kstrdup(devstr, GFP_KERNEL);\r\nstr = str_saved;\r\nif (!str)\r\nreturn;\r\ntoken = strsep(&str, ",");\r\nif (!token || strlen(token) >= ZFCP_BUS_ID_SIZE)\r\ngoto err_out;\r\nstrncpy(busid, token, ZFCP_BUS_ID_SIZE);\r\ntoken = strsep(&str, ",");\r\nif (!token || strict_strtoull(token, 0, (unsigned long long *) &wwpn))\r\ngoto err_out;\r\ntoken = strsep(&str, ",");\r\nif (!token || strict_strtoull(token, 0, (unsigned long long *) &lun))\r\ngoto err_out;\r\nkfree(str_saved);\r\nzfcp_init_device_configure(busid, wwpn, lun);\r\nreturn;\r\nerr_out:\r\nkfree(str_saved);\r\npr_err("%s is not a valid SCSI device\n", devstr);\r\n}\r\nstatic int __init zfcp_module_init(void)\r\n{\r\nint retval = -ENOMEM;\r\nzfcp_fsf_qtcb_cache = zfcp_cache_hw_align("zfcp_fsf_qtcb",\r\nsizeof(struct fsf_qtcb));\r\nif (!zfcp_fsf_qtcb_cache)\r\ngoto out_qtcb_cache;\r\nzfcp_fc_req_cache = zfcp_cache_hw_align("zfcp_fc_req",\r\nsizeof(struct zfcp_fc_req));\r\nif (!zfcp_fc_req_cache)\r\ngoto out_fc_cache;\r\nzfcp_scsi_transport_template =\r\nfc_attach_transport(&zfcp_transport_functions);\r\nif (!zfcp_scsi_transport_template)\r\ngoto out_transport;\r\nscsi_transport_reserve_device(zfcp_scsi_transport_template,\r\nsizeof(struct zfcp_scsi_dev));\r\nretval = misc_register(&zfcp_cfdc_misc);\r\nif (retval) {\r\npr_err("Registering the misc device zfcp_cfdc failed\n");\r\ngoto out_misc;\r\n}\r\nretval = ccw_driver_register(&zfcp_ccw_driver);\r\nif (retval) {\r\npr_err("The zfcp device driver could not register with "\r\n"the common I/O layer\n");\r\ngoto out_ccw_register;\r\n}\r\nif (init_device)\r\nzfcp_init_device_setup(init_device);\r\nreturn 0;\r\nout_ccw_register:\r\nmisc_deregister(&zfcp_cfdc_misc);\r\nout_misc:\r\nfc_release_transport(zfcp_scsi_transport_template);\r\nout_transport:\r\nkmem_cache_destroy(zfcp_fc_req_cache);\r\nout_fc_cache:\r\nkmem_cache_destroy(zfcp_fsf_qtcb_cache);\r\nout_qtcb_cache:\r\nreturn retval;\r\n}\r\nstatic void __exit zfcp_module_exit(void)\r\n{\r\nccw_driver_unregister(&zfcp_ccw_driver);\r\nmisc_deregister(&zfcp_cfdc_misc);\r\nfc_release_transport(zfcp_scsi_transport_template);\r\nkmem_cache_destroy(zfcp_fc_req_cache);\r\nkmem_cache_destroy(zfcp_fsf_qtcb_cache);\r\n}\r\nstruct zfcp_port *zfcp_get_port_by_wwpn(struct zfcp_adapter *adapter,\r\nu64 wwpn)\r\n{\r\nunsigned long flags;\r\nstruct zfcp_port *port;\r\nread_lock_irqsave(&adapter->port_list_lock, flags);\r\nlist_for_each_entry(port, &adapter->port_list, list)\r\nif (port->wwpn == wwpn) {\r\nif (!get_device(&port->dev))\r\nport = NULL;\r\nread_unlock_irqrestore(&adapter->port_list_lock, flags);\r\nreturn port;\r\n}\r\nread_unlock_irqrestore(&adapter->port_list_lock, flags);\r\nreturn NULL;\r\n}\r\nstatic int zfcp_allocate_low_mem_buffers(struct zfcp_adapter *adapter)\r\n{\r\nadapter->pool.erp_req =\r\nmempool_create_kmalloc_pool(1, sizeof(struct zfcp_fsf_req));\r\nif (!adapter->pool.erp_req)\r\nreturn -ENOMEM;\r\nadapter->pool.gid_pn_req =\r\nmempool_create_kmalloc_pool(1, sizeof(struct zfcp_fsf_req));\r\nif (!adapter->pool.gid_pn_req)\r\nreturn -ENOMEM;\r\nadapter->pool.scsi_req =\r\nmempool_create_kmalloc_pool(1, sizeof(struct zfcp_fsf_req));\r\nif (!adapter->pool.scsi_req)\r\nreturn -ENOMEM;\r\nadapter->pool.scsi_abort =\r\nmempool_create_kmalloc_pool(1, sizeof(struct zfcp_fsf_req));\r\nif (!adapter->pool.scsi_abort)\r\nreturn -ENOMEM;\r\nadapter->pool.status_read_req =\r\nmempool_create_kmalloc_pool(FSF_STATUS_READS_RECOM,\r\nsizeof(struct zfcp_fsf_req));\r\nif (!adapter->pool.status_read_req)\r\nreturn -ENOMEM;\r\nadapter->pool.qtcb_pool =\r\nmempool_create_slab_pool(4, zfcp_fsf_qtcb_cache);\r\nif (!adapter->pool.qtcb_pool)\r\nreturn -ENOMEM;\r\nBUILD_BUG_ON(sizeof(struct fsf_status_read_buffer) > PAGE_SIZE);\r\nadapter->pool.sr_data =\r\nmempool_create_page_pool(FSF_STATUS_READS_RECOM, 0);\r\nif (!adapter->pool.sr_data)\r\nreturn -ENOMEM;\r\nadapter->pool.gid_pn =\r\nmempool_create_slab_pool(1, zfcp_fc_req_cache);\r\nif (!adapter->pool.gid_pn)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void zfcp_free_low_mem_buffers(struct zfcp_adapter *adapter)\r\n{\r\nif (adapter->pool.erp_req)\r\nmempool_destroy(adapter->pool.erp_req);\r\nif (adapter->pool.scsi_req)\r\nmempool_destroy(adapter->pool.scsi_req);\r\nif (adapter->pool.scsi_abort)\r\nmempool_destroy(adapter->pool.scsi_abort);\r\nif (adapter->pool.qtcb_pool)\r\nmempool_destroy(adapter->pool.qtcb_pool);\r\nif (adapter->pool.status_read_req)\r\nmempool_destroy(adapter->pool.status_read_req);\r\nif (adapter->pool.sr_data)\r\nmempool_destroy(adapter->pool.sr_data);\r\nif (adapter->pool.gid_pn)\r\nmempool_destroy(adapter->pool.gid_pn);\r\n}\r\nint zfcp_status_read_refill(struct zfcp_adapter *adapter)\r\n{\r\nwhile (atomic_read(&adapter->stat_miss) > 0)\r\nif (zfcp_fsf_status_read(adapter->qdio)) {\r\nif (atomic_read(&adapter->stat_miss) >=\r\nadapter->stat_read_buf_num) {\r\nzfcp_erp_adapter_reopen(adapter, 0, "axsref1");\r\nreturn 1;\r\n}\r\nbreak;\r\n} else\r\natomic_dec(&adapter->stat_miss);\r\nreturn 0;\r\n}\r\nstatic void _zfcp_status_read_scheduler(struct work_struct *work)\r\n{\r\nzfcp_status_read_refill(container_of(work, struct zfcp_adapter,\r\nstat_work));\r\n}\r\nstatic void zfcp_print_sl(struct seq_file *m, struct service_level *sl)\r\n{\r\nstruct zfcp_adapter *adapter =\r\ncontainer_of(sl, struct zfcp_adapter, service_level);\r\nseq_printf(m, "zfcp: %s microcode level %x\n",\r\ndev_name(&adapter->ccw_device->dev),\r\nadapter->fsf_lic_version);\r\n}\r\nstatic int zfcp_setup_adapter_work_queue(struct zfcp_adapter *adapter)\r\n{\r\nchar name[TASK_COMM_LEN];\r\nsnprintf(name, sizeof(name), "zfcp_q_%s",\r\ndev_name(&adapter->ccw_device->dev));\r\nadapter->work_queue = create_singlethread_workqueue(name);\r\nif (adapter->work_queue)\r\nreturn 0;\r\nreturn -ENOMEM;\r\n}\r\nstatic void zfcp_destroy_adapter_work_queue(struct zfcp_adapter *adapter)\r\n{\r\nif (adapter->work_queue)\r\ndestroy_workqueue(adapter->work_queue);\r\nadapter->work_queue = NULL;\r\n}\r\nstruct zfcp_adapter *zfcp_adapter_enqueue(struct ccw_device *ccw_device)\r\n{\r\nstruct zfcp_adapter *adapter;\r\nif (!get_device(&ccw_device->dev))\r\nreturn ERR_PTR(-ENODEV);\r\nadapter = kzalloc(sizeof(struct zfcp_adapter), GFP_KERNEL);\r\nif (!adapter) {\r\nput_device(&ccw_device->dev);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nkref_init(&adapter->ref);\r\nccw_device->handler = NULL;\r\nadapter->ccw_device = ccw_device;\r\nINIT_WORK(&adapter->stat_work, _zfcp_status_read_scheduler);\r\nINIT_WORK(&adapter->scan_work, zfcp_fc_scan_ports);\r\nINIT_WORK(&adapter->ns_up_work, zfcp_fc_sym_name_update);\r\nif (zfcp_qdio_setup(adapter))\r\ngoto failed;\r\nif (zfcp_allocate_low_mem_buffers(adapter))\r\ngoto failed;\r\nadapter->req_list = zfcp_reqlist_alloc();\r\nif (!adapter->req_list)\r\ngoto failed;\r\nif (zfcp_dbf_adapter_register(adapter))\r\ngoto failed;\r\nif (zfcp_setup_adapter_work_queue(adapter))\r\ngoto failed;\r\nif (zfcp_fc_gs_setup(adapter))\r\ngoto failed;\r\nrwlock_init(&adapter->port_list_lock);\r\nINIT_LIST_HEAD(&adapter->port_list);\r\nINIT_LIST_HEAD(&adapter->events.list);\r\nINIT_WORK(&adapter->events.work, zfcp_fc_post_event);\r\nspin_lock_init(&adapter->events.list_lock);\r\ninit_waitqueue_head(&adapter->erp_ready_wq);\r\ninit_waitqueue_head(&adapter->erp_done_wqh);\r\nINIT_LIST_HEAD(&adapter->erp_ready_head);\r\nINIT_LIST_HEAD(&adapter->erp_running_head);\r\nrwlock_init(&adapter->erp_lock);\r\nrwlock_init(&adapter->abort_lock);\r\nif (zfcp_erp_thread_setup(adapter))\r\ngoto failed;\r\nadapter->service_level.seq_print = zfcp_print_sl;\r\ndev_set_drvdata(&ccw_device->dev, adapter);\r\nif (sysfs_create_group(&ccw_device->dev.kobj,\r\n&zfcp_sysfs_adapter_attrs))\r\ngoto failed;\r\nadapter->dma_parms.max_segment_size = ZFCP_QDIO_SBALE_LEN;\r\nadapter->ccw_device->dev.dma_parms = &adapter->dma_parms;\r\nif (!zfcp_scsi_adapter_register(adapter))\r\nreturn adapter;\r\nfailed:\r\nzfcp_adapter_unregister(adapter);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nvoid zfcp_adapter_unregister(struct zfcp_adapter *adapter)\r\n{\r\nstruct ccw_device *cdev = adapter->ccw_device;\r\ncancel_work_sync(&adapter->scan_work);\r\ncancel_work_sync(&adapter->stat_work);\r\ncancel_work_sync(&adapter->ns_up_work);\r\nzfcp_destroy_adapter_work_queue(adapter);\r\nzfcp_fc_wka_ports_force_offline(adapter->gs);\r\nzfcp_scsi_adapter_unregister(adapter);\r\nsysfs_remove_group(&cdev->dev.kobj, &zfcp_sysfs_adapter_attrs);\r\nzfcp_erp_thread_kill(adapter);\r\nzfcp_dbf_adapter_unregister(adapter);\r\nzfcp_qdio_destroy(adapter->qdio);\r\nzfcp_ccw_adapter_put(adapter);\r\n}\r\nvoid zfcp_adapter_release(struct kref *ref)\r\n{\r\nstruct zfcp_adapter *adapter = container_of(ref, struct zfcp_adapter,\r\nref);\r\nstruct ccw_device *cdev = adapter->ccw_device;\r\ndev_set_drvdata(&adapter->ccw_device->dev, NULL);\r\nzfcp_fc_gs_destroy(adapter);\r\nzfcp_free_low_mem_buffers(adapter);\r\nkfree(adapter->req_list);\r\nkfree(adapter->fc_stats);\r\nkfree(adapter->stats_reset_data);\r\nkfree(adapter);\r\nput_device(&cdev->dev);\r\n}\r\nvoid zfcp_device_unregister(struct device *dev,\r\nconst struct attribute_group *grp)\r\n{\r\nsysfs_remove_group(&dev->kobj, grp);\r\ndevice_unregister(dev);\r\n}\r\nstatic void zfcp_port_release(struct device *dev)\r\n{\r\nstruct zfcp_port *port = container_of(dev, struct zfcp_port, dev);\r\nzfcp_ccw_adapter_put(port->adapter);\r\nkfree(port);\r\n}\r\nstruct zfcp_port *zfcp_port_enqueue(struct zfcp_adapter *adapter, u64 wwpn,\r\nu32 status, u32 d_id)\r\n{\r\nstruct zfcp_port *port;\r\nint retval = -ENOMEM;\r\nkref_get(&adapter->ref);\r\nport = zfcp_get_port_by_wwpn(adapter, wwpn);\r\nif (port) {\r\nput_device(&port->dev);\r\nretval = -EEXIST;\r\ngoto err_out;\r\n}\r\nport = kzalloc(sizeof(struct zfcp_port), GFP_KERNEL);\r\nif (!port)\r\ngoto err_out;\r\nrwlock_init(&port->unit_list_lock);\r\nINIT_LIST_HEAD(&port->unit_list);\r\nINIT_WORK(&port->gid_pn_work, zfcp_fc_port_did_lookup);\r\nINIT_WORK(&port->test_link_work, zfcp_fc_link_test_work);\r\nINIT_WORK(&port->rport_work, zfcp_scsi_rport_work);\r\nport->adapter = adapter;\r\nport->d_id = d_id;\r\nport->wwpn = wwpn;\r\nport->rport_task = RPORT_NONE;\r\nport->dev.parent = &adapter->ccw_device->dev;\r\nport->dev.release = zfcp_port_release;\r\nif (dev_set_name(&port->dev, "0x%016llx", (unsigned long long)wwpn)) {\r\nkfree(port);\r\ngoto err_out;\r\n}\r\nretval = -EINVAL;\r\nif (device_register(&port->dev)) {\r\nput_device(&port->dev);\r\ngoto err_out;\r\n}\r\nif (sysfs_create_group(&port->dev.kobj,\r\n&zfcp_sysfs_port_attrs))\r\ngoto err_out_put;\r\nwrite_lock_irq(&adapter->port_list_lock);\r\nlist_add_tail(&port->list, &adapter->port_list);\r\nwrite_unlock_irq(&adapter->port_list_lock);\r\natomic_set_mask(status | ZFCP_STATUS_COMMON_RUNNING, &port->status);\r\nreturn port;\r\nerr_out_put:\r\ndevice_unregister(&port->dev);\r\nerr_out:\r\nzfcp_ccw_adapter_put(adapter);\r\nreturn ERR_PTR(retval);\r\n}\r\nvoid zfcp_sg_free_table(struct scatterlist *sg, int count)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++, sg++)\r\nif (sg)\r\nfree_page((unsigned long) sg_virt(sg));\r\nelse\r\nbreak;\r\n}\r\nint zfcp_sg_setup_table(struct scatterlist *sg, int count)\r\n{\r\nvoid *addr;\r\nint i;\r\nsg_init_table(sg, count);\r\nfor (i = 0; i < count; i++, sg++) {\r\naddr = (void *) get_zeroed_page(GFP_KERNEL);\r\nif (!addr) {\r\nzfcp_sg_free_table(sg, i);\r\nreturn -ENOMEM;\r\n}\r\nsg_set_buf(sg, addr, PAGE_SIZE);\r\n}\r\nreturn 0;\r\n}
