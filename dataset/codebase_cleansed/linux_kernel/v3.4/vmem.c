static void __ref *vmem_alloc_pages(unsigned int order)\r\n{\r\nif (slab_is_available())\r\nreturn (void *)__get_free_pages(GFP_KERNEL, order);\r\nreturn alloc_bootmem_pages((1 << order) * PAGE_SIZE);\r\n}\r\nstatic inline pud_t *vmem_pud_alloc(void)\r\n{\r\npud_t *pud = NULL;\r\n#ifdef CONFIG_64BIT\r\npud = vmem_alloc_pages(2);\r\nif (!pud)\r\nreturn NULL;\r\nclear_table((unsigned long *) pud, _REGION3_ENTRY_EMPTY, PAGE_SIZE * 4);\r\n#endif\r\nreturn pud;\r\n}\r\nstatic inline pmd_t *vmem_pmd_alloc(void)\r\n{\r\npmd_t *pmd = NULL;\r\n#ifdef CONFIG_64BIT\r\npmd = vmem_alloc_pages(2);\r\nif (!pmd)\r\nreturn NULL;\r\nclear_table((unsigned long *) pmd, _SEGMENT_ENTRY_EMPTY, PAGE_SIZE * 4);\r\n#endif\r\nreturn pmd;\r\n}\r\nstatic pte_t __ref *vmem_pte_alloc(unsigned long address)\r\n{\r\npte_t *pte;\r\nif (slab_is_available())\r\npte = (pte_t *) page_table_alloc(&init_mm, address);\r\nelse\r\npte = alloc_bootmem(PTRS_PER_PTE * sizeof(pte_t));\r\nif (!pte)\r\nreturn NULL;\r\nclear_table((unsigned long *) pte, _PAGE_TYPE_EMPTY,\r\nPTRS_PER_PTE * sizeof(pte_t));\r\nreturn pte;\r\n}\r\nstatic int vmem_add_mem(unsigned long start, unsigned long size, int ro)\r\n{\r\nunsigned long address;\r\npgd_t *pg_dir;\r\npud_t *pu_dir;\r\npmd_t *pm_dir;\r\npte_t *pt_dir;\r\npte_t pte;\r\nint ret = -ENOMEM;\r\nfor (address = start; address < start + size; address += PAGE_SIZE) {\r\npg_dir = pgd_offset_k(address);\r\nif (pgd_none(*pg_dir)) {\r\npu_dir = vmem_pud_alloc();\r\nif (!pu_dir)\r\ngoto out;\r\npgd_populate(&init_mm, pg_dir, pu_dir);\r\n}\r\npu_dir = pud_offset(pg_dir, address);\r\nif (pud_none(*pu_dir)) {\r\npm_dir = vmem_pmd_alloc();\r\nif (!pm_dir)\r\ngoto out;\r\npud_populate(&init_mm, pu_dir, pm_dir);\r\n}\r\npte = mk_pte_phys(address, __pgprot(ro ? _PAGE_RO : 0));\r\npm_dir = pmd_offset(pu_dir, address);\r\n#ifdef __s390x__\r\nif (MACHINE_HAS_HPAGE && !(address & ~HPAGE_MASK) &&\r\n(address + HPAGE_SIZE <= start + size) &&\r\n(address >= HPAGE_SIZE)) {\r\npte_val(pte) |= _SEGMENT_ENTRY_LARGE;\r\npmd_val(*pm_dir) = pte_val(pte);\r\naddress += HPAGE_SIZE - PAGE_SIZE;\r\ncontinue;\r\n}\r\n#endif\r\nif (pmd_none(*pm_dir)) {\r\npt_dir = vmem_pte_alloc(address);\r\nif (!pt_dir)\r\ngoto out;\r\npmd_populate(&init_mm, pm_dir, pt_dir);\r\n}\r\npt_dir = pte_offset_kernel(pm_dir, address);\r\n*pt_dir = pte;\r\n}\r\nret = 0;\r\nout:\r\nflush_tlb_kernel_range(start, start + size);\r\nreturn ret;\r\n}\r\nstatic void vmem_remove_range(unsigned long start, unsigned long size)\r\n{\r\nunsigned long address;\r\npgd_t *pg_dir;\r\npud_t *pu_dir;\r\npmd_t *pm_dir;\r\npte_t *pt_dir;\r\npte_t pte;\r\npte_val(pte) = _PAGE_TYPE_EMPTY;\r\nfor (address = start; address < start + size; address += PAGE_SIZE) {\r\npg_dir = pgd_offset_k(address);\r\npu_dir = pud_offset(pg_dir, address);\r\nif (pud_none(*pu_dir))\r\ncontinue;\r\npm_dir = pmd_offset(pu_dir, address);\r\nif (pmd_none(*pm_dir))\r\ncontinue;\r\nif (pmd_huge(*pm_dir)) {\r\npmd_clear(pm_dir);\r\naddress += HPAGE_SIZE - PAGE_SIZE;\r\ncontinue;\r\n}\r\npt_dir = pte_offset_kernel(pm_dir, address);\r\n*pt_dir = pte;\r\n}\r\nflush_tlb_kernel_range(start, start + size);\r\n}\r\nint __meminit vmemmap_populate(struct page *start, unsigned long nr, int node)\r\n{\r\nunsigned long address, start_addr, end_addr;\r\npgd_t *pg_dir;\r\npud_t *pu_dir;\r\npmd_t *pm_dir;\r\npte_t *pt_dir;\r\npte_t pte;\r\nint ret = -ENOMEM;\r\nstart_addr = (unsigned long) start;\r\nend_addr = (unsigned long) (start + nr);\r\nfor (address = start_addr; address < end_addr; address += PAGE_SIZE) {\r\npg_dir = pgd_offset_k(address);\r\nif (pgd_none(*pg_dir)) {\r\npu_dir = vmem_pud_alloc();\r\nif (!pu_dir)\r\ngoto out;\r\npgd_populate(&init_mm, pg_dir, pu_dir);\r\n}\r\npu_dir = pud_offset(pg_dir, address);\r\nif (pud_none(*pu_dir)) {\r\npm_dir = vmem_pmd_alloc();\r\nif (!pm_dir)\r\ngoto out;\r\npud_populate(&init_mm, pu_dir, pm_dir);\r\n}\r\npm_dir = pmd_offset(pu_dir, address);\r\nif (pmd_none(*pm_dir)) {\r\npt_dir = vmem_pte_alloc(address);\r\nif (!pt_dir)\r\ngoto out;\r\npmd_populate(&init_mm, pm_dir, pt_dir);\r\n}\r\npt_dir = pte_offset_kernel(pm_dir, address);\r\nif (pte_none(*pt_dir)) {\r\nunsigned long new_page;\r\nnew_page =__pa(vmem_alloc_pages(0));\r\nif (!new_page)\r\ngoto out;\r\npte = pfn_pte(new_page >> PAGE_SHIFT, PAGE_KERNEL);\r\n*pt_dir = pte;\r\n}\r\n}\r\nmemset(start, 0, nr * sizeof(struct page));\r\nret = 0;\r\nout:\r\nflush_tlb_kernel_range(start_addr, end_addr);\r\nreturn ret;\r\n}\r\nstatic int insert_memory_segment(struct memory_segment *seg)\r\n{\r\nstruct memory_segment *tmp;\r\nif (seg->start + seg->size > VMEM_MAX_PHYS ||\r\nseg->start + seg->size < seg->start)\r\nreturn -ERANGE;\r\nlist_for_each_entry(tmp, &mem_segs, list) {\r\nif (seg->start >= tmp->start + tmp->size)\r\ncontinue;\r\nif (seg->start + seg->size <= tmp->start)\r\ncontinue;\r\nreturn -ENOSPC;\r\n}\r\nlist_add(&seg->list, &mem_segs);\r\nreturn 0;\r\n}\r\nstatic void remove_memory_segment(struct memory_segment *seg)\r\n{\r\nlist_del(&seg->list);\r\n}\r\nstatic void __remove_shared_memory(struct memory_segment *seg)\r\n{\r\nremove_memory_segment(seg);\r\nvmem_remove_range(seg->start, seg->size);\r\n}\r\nint vmem_remove_mapping(unsigned long start, unsigned long size)\r\n{\r\nstruct memory_segment *seg;\r\nint ret;\r\nmutex_lock(&vmem_mutex);\r\nret = -ENOENT;\r\nlist_for_each_entry(seg, &mem_segs, list) {\r\nif (seg->start == start && seg->size == size)\r\nbreak;\r\n}\r\nif (seg->start != start || seg->size != size)\r\ngoto out;\r\nret = 0;\r\n__remove_shared_memory(seg);\r\nkfree(seg);\r\nout:\r\nmutex_unlock(&vmem_mutex);\r\nreturn ret;\r\n}\r\nint vmem_add_mapping(unsigned long start, unsigned long size)\r\n{\r\nstruct memory_segment *seg;\r\nint ret;\r\nmutex_lock(&vmem_mutex);\r\nret = -ENOMEM;\r\nseg = kzalloc(sizeof(*seg), GFP_KERNEL);\r\nif (!seg)\r\ngoto out;\r\nseg->start = start;\r\nseg->size = size;\r\nret = insert_memory_segment(seg);\r\nif (ret)\r\ngoto out_free;\r\nret = vmem_add_mem(start, size, 0);\r\nif (ret)\r\ngoto out_remove;\r\ngoto out;\r\nout_remove:\r\n__remove_shared_memory(seg);\r\nout_free:\r\nkfree(seg);\r\nout:\r\nmutex_unlock(&vmem_mutex);\r\nreturn ret;\r\n}\r\nvoid __init vmem_map_init(void)\r\n{\r\nunsigned long ro_start, ro_end;\r\nunsigned long start, end;\r\nint i;\r\nro_start = ((unsigned long)&_stext) & PAGE_MASK;\r\nro_end = PFN_ALIGN((unsigned long)&_eshared);\r\nfor (i = 0; i < MEMORY_CHUNKS && memory_chunk[i].size > 0; i++) {\r\nif (memory_chunk[i].type == CHUNK_CRASHK ||\r\nmemory_chunk[i].type == CHUNK_OLDMEM)\r\ncontinue;\r\nstart = memory_chunk[i].addr;\r\nend = memory_chunk[i].addr + memory_chunk[i].size;\r\nif (start >= ro_end || end <= ro_start)\r\nvmem_add_mem(start, end - start, 0);\r\nelse if (start >= ro_start && end <= ro_end)\r\nvmem_add_mem(start, end - start, 1);\r\nelse if (start >= ro_start) {\r\nvmem_add_mem(start, ro_end - start, 1);\r\nvmem_add_mem(ro_end, end - ro_end, 0);\r\n} else if (end < ro_end) {\r\nvmem_add_mem(start, ro_start - start, 0);\r\nvmem_add_mem(ro_start, end - ro_start, 1);\r\n} else {\r\nvmem_add_mem(start, ro_start - start, 0);\r\nvmem_add_mem(ro_start, ro_end - ro_start, 1);\r\nvmem_add_mem(ro_end, end - ro_end, 0);\r\n}\r\n}\r\n}\r\nstatic int __init vmem_convert_memory_chunk(void)\r\n{\r\nstruct memory_segment *seg;\r\nint i;\r\nmutex_lock(&vmem_mutex);\r\nfor (i = 0; i < MEMORY_CHUNKS; i++) {\r\nif (!memory_chunk[i].size)\r\ncontinue;\r\nif (memory_chunk[i].type == CHUNK_CRASHK ||\r\nmemory_chunk[i].type == CHUNK_OLDMEM)\r\ncontinue;\r\nseg = kzalloc(sizeof(*seg), GFP_KERNEL);\r\nif (!seg)\r\npanic("Out of memory...\n");\r\nseg->start = memory_chunk[i].addr;\r\nseg->size = memory_chunk[i].size;\r\ninsert_memory_segment(seg);\r\n}\r\nmutex_unlock(&vmem_mutex);\r\nreturn 0;\r\n}
