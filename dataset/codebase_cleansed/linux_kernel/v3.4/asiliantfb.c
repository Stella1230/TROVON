static void mm_write_xr(struct fb_info *p, u8 reg, u8 data)\r\n{\r\nmm_write_ind(reg, data, 0x7ac, 0x7ad);\r\n}\r\nstatic void mm_write_fr(struct fb_info *p, u8 reg, u8 data)\r\n{\r\nmm_write_ind(reg, data, 0x7a0, 0x7a1);\r\n}\r\nstatic void mm_write_cr(struct fb_info *p, u8 reg, u8 data)\r\n{\r\nmm_write_ind(reg, data, 0x7a8, 0x7a9);\r\n}\r\nstatic void mm_write_gr(struct fb_info *p, u8 reg, u8 data)\r\n{\r\nmm_write_ind(reg, data, 0x79c, 0x79d);\r\n}\r\nstatic void mm_write_sr(struct fb_info *p, u8 reg, u8 data)\r\n{\r\nmm_write_ind(reg, data, 0x788, 0x789);\r\n}\r\nstatic void mm_write_ar(struct fb_info *p, u8 reg, u8 data)\r\n{\r\nreadb(mmio_base + 0x7b4);\r\nmm_write_ind(reg, data, 0x780, 0x780);\r\n}\r\nstatic void asiliant_calc_dclk2(u32 *ppixclock, u8 *dclk2_m, u8 *dclk2_n, u8 *dclk2_div)\r\n{\r\nunsigned pixclock = *ppixclock;\r\nunsigned Ftarget = 1000000 * (1000000 / pixclock);\r\nunsigned n;\r\nunsigned best_error = 0xffffffff;\r\nunsigned best_m = 0xffffffff,\r\nbest_n = 0xffffffff;\r\nunsigned ratio;\r\nunsigned remainder;\r\nunsigned char divisor = 0;\r\nratio = 1000000 / pixclock;\r\nremainder = 1000000 % pixclock;\r\nFtarget = 1000000 * ratio + (1000000 * remainder) / pixclock;\r\nwhile (Ftarget < 100000000) {\r\ndivisor += 0x10;\r\nFtarget <<= 1;\r\n}\r\nratio = Ftarget / Fref;\r\nremainder = Ftarget % Fref;\r\nfor (n = 3; n <= 257; n++) {\r\nunsigned m = n * ratio + (n * remainder) / Fref;\r\nif (m >= 3 && m <= 257) {\r\nunsigned new_error = Ftarget * n >= Fref * m ?\r\n((Ftarget * n) - (Fref * m)) : ((Fref * m) - (Ftarget * n));\r\nif (new_error < best_error) {\r\nbest_n = n;\r\nbest_m = m;\r\nbest_error = new_error;\r\n}\r\n}\r\nelse if (m <= 1028) {\r\nunsigned new_error = Ftarget * n >= Fref * (m & ~3) ?\r\n((Ftarget * n) - (Fref * (m & ~3))) : ((Fref * (m & ~3)) - (Ftarget * n));\r\nif (new_error < best_error) {\r\nbest_n = n;\r\nbest_m = m;\r\nbest_error = new_error;\r\n}\r\n}\r\n}\r\nif (best_m > 257)\r\nbest_m >>= 2;\r\nelse\r\ndivisor |= 4;\r\n*dclk2_m = best_m - 2;\r\n*dclk2_n = best_n - 2;\r\n*dclk2_div = divisor;\r\n*ppixclock = pixclock;\r\nreturn;\r\n}\r\nstatic void asiliant_set_timing(struct fb_info *p)\r\n{\r\nunsigned hd = p->var.xres / 8;\r\nunsigned hs = (p->var.xres + p->var.right_margin) / 8;\r\nunsigned he = (p->var.xres + p->var.right_margin + p->var.hsync_len) / 8;\r\nunsigned ht = (p->var.left_margin + p->var.xres + p->var.right_margin + p->var.hsync_len) / 8;\r\nunsigned vd = p->var.yres;\r\nunsigned vs = p->var.yres + p->var.lower_margin;\r\nunsigned ve = p->var.yres + p->var.lower_margin + p->var.vsync_len;\r\nunsigned vt = p->var.upper_margin + p->var.yres + p->var.lower_margin + p->var.vsync_len;\r\nunsigned wd = (p->var.xres_virtual * ((p->var.bits_per_pixel+7)/8)) / 8;\r\nif ((p->var.xres == 640) && (p->var.yres == 480) && (p->var.pixclock == 39722)) {\r\nwrite_fr(0x01, 0x02);\r\n} else {\r\nwrite_fr(0x01, 0x01);\r\n}\r\nwrite_cr(0x11, (ve - 1) & 0x0f);\r\nwrite_cr(0x00, (ht - 5) & 0xff);\r\nwrite_cr(0x01, hd - 1);\r\nwrite_cr(0x02, hd);\r\nwrite_cr(0x03, ((ht - 1) & 0x1f) | 0x80);\r\nwrite_cr(0x04, hs);\r\nwrite_cr(0x05, (((ht - 1) & 0x20) <<2) | (he & 0x1f));\r\nwrite_cr(0x3c, (ht - 1) & 0xc0);\r\nwrite_cr(0x06, (vt - 2) & 0xff);\r\nwrite_cr(0x30, (vt - 2) >> 8);\r\nwrite_cr(0x07, 0x00);\r\nwrite_cr(0x08, 0x00);\r\nwrite_cr(0x09, 0x00);\r\nwrite_cr(0x10, (vs - 1) & 0xff);\r\nwrite_cr(0x32, ((vs - 1) >> 8) & 0xf);\r\nwrite_cr(0x11, ((ve - 1) & 0x0f) | 0x80);\r\nwrite_cr(0x12, (vd - 1) & 0xff);\r\nwrite_cr(0x31, ((vd - 1) & 0xf00) >> 8);\r\nwrite_cr(0x13, wd & 0xff);\r\nwrite_cr(0x41, (wd & 0xf00) >> 8);\r\nwrite_cr(0x15, (vs - 1) & 0xff);\r\nwrite_cr(0x33, ((vs - 1) >> 8) & 0xf);\r\nwrite_cr(0x38, ((ht - 5) & 0x100) >> 8);\r\nwrite_cr(0x16, (vt - 1) & 0xff);\r\nwrite_cr(0x18, 0x00);\r\nif (p->var.xres == 640) {\r\nwriteb(0xc7, mmio_base + 0x784);\r\n} else {\r\nwriteb(0x07, mmio_base + 0x784);\r\n}\r\n}\r\nstatic int asiliantfb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *p)\r\n{\r\nunsigned long Ftarget, ratio, remainder;\r\nratio = 1000000 / var->pixclock;\r\nremainder = 1000000 % var->pixclock;\r\nFtarget = 1000000 * ratio + (1000000 * remainder) / var->pixclock;\r\nif (Ftarget > 220000000 || Ftarget < 3125000) {\r\nprintk(KERN_ERR "asiliantfb dotclock must be between 3.125 and 220MHz\n");\r\nreturn -ENXIO;\r\n}\r\nvar->xres_virtual = var->xres;\r\nvar->yres_virtual = var->yres;\r\nif (var->bits_per_pixel == 24) {\r\nvar->red.offset = 16;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 0;\r\nvar->red.length = var->blue.length = var->green.length = 8;\r\n} else if (var->bits_per_pixel == 16) {\r\nswitch (var->red.offset) {\r\ncase 11:\r\nvar->green.length = 6;\r\nbreak;\r\ncase 10:\r\nvar->green.length = 5;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nvar->green.offset = 5;\r\nvar->blue.offset = 0;\r\nvar->red.length = var->blue.length = 5;\r\n} else if (var->bits_per_pixel == 8) {\r\nvar->red.offset = var->green.offset = var->blue.offset = 0;\r\nvar->red.length = var->green.length = var->blue.length = 8;\r\n}\r\nreturn 0;\r\n}\r\nstatic int asiliantfb_set_par(struct fb_info *p)\r\n{\r\nu8 dclk2_m;\r\nu8 dclk2_n;\r\nu8 dclk2_div;\r\nasiliant_calc_dclk2(&p->var.pixclock, &dclk2_m, &dclk2_n, &dclk2_div);\r\nif (p->var.bits_per_pixel == 24) {\r\nwrite_xr(0x81, 0x16);\r\nwrite_xr(0x82, 0x00);\r\nwrite_xr(0x20, 0x20);\r\n} else if (p->var.bits_per_pixel == 16) {\r\nif (p->var.red.offset == 11)\r\nwrite_xr(0x81, 0x15);\r\nelse\r\nwrite_xr(0x81, 0x14);\r\nwrite_xr(0x82, 0x00);\r\nwrite_xr(0x20, 0x10);\r\n} else if (p->var.bits_per_pixel == 8) {\r\nwrite_xr(0x0a, 0x02);\r\nwrite_xr(0x81, 0x12);\r\nwrite_xr(0x82, 0x00);\r\nwrite_xr(0x20, 0x00);\r\n}\r\np->fix.line_length = p->var.xres * (p->var.bits_per_pixel >> 3);\r\np->fix.visual = (p->var.bits_per_pixel == 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\r\nwrite_xr(0xc4, dclk2_m);\r\nwrite_xr(0xc5, dclk2_n);\r\nwrite_xr(0xc7, dclk2_div);\r\nasiliant_set_timing(p);\r\nreturn 0;\r\n}\r\nstatic int asiliantfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *p)\r\n{\r\nif (regno > 255)\r\nreturn 1;\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\nwriteb(regno, mmio_base + 0x790);\r\nudelay(1);\r\nwriteb(red, mmio_base + 0x791);\r\nwriteb(green, mmio_base + 0x791);\r\nwriteb(blue, mmio_base + 0x791);\r\nif (regno < 16) {\r\nswitch(p->var.red.offset) {\r\ncase 10:\r\n((u32 *)(p->pseudo_palette))[regno] =\r\n((red & 0xf8) << 7) |\r\n((green & 0xf8) << 2) |\r\n((blue & 0xf8) >> 3);\r\nbreak;\r\ncase 11:\r\n((u32 *)(p->pseudo_palette))[regno] =\r\n((red & 0xf8) << 8) |\r\n((green & 0xfc) << 3) |\r\n((blue & 0xf8) >> 3);\r\nbreak;\r\ncase 16:\r\n((u32 *)(p->pseudo_palette))[regno] =\r\n(red << 16) |\r\n(green << 8) |\r\n(blue);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void __devinit chips_hw_init(struct fb_info *p)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(chips_init_xr); ++i)\r\nwrite_xr(chips_init_xr[i].addr, chips_init_xr[i].data);\r\nwrite_xr(0x81, 0x12);\r\nwrite_xr(0x82, 0x08);\r\nwrite_xr(0x20, 0x00);\r\nfor (i = 0; i < ARRAY_SIZE(chips_init_sr); ++i)\r\nwrite_sr(chips_init_sr[i].addr, chips_init_sr[i].data);\r\nfor (i = 0; i < ARRAY_SIZE(chips_init_gr); ++i)\r\nwrite_gr(chips_init_gr[i].addr, chips_init_gr[i].data);\r\nfor (i = 0; i < ARRAY_SIZE(chips_init_ar); ++i)\r\nwrite_ar(chips_init_ar[i].addr, chips_init_ar[i].data);\r\nwriteb(0x20, mmio_base + 0x780);\r\nfor (i = 0; i < ARRAY_SIZE(chips_init_cr); ++i)\r\nwrite_cr(chips_init_cr[i].addr, chips_init_cr[i].data);\r\nfor (i = 0; i < ARRAY_SIZE(chips_init_fr); ++i)\r\nwrite_fr(chips_init_fr[i].addr, chips_init_fr[i].data);\r\n}\r\nstatic int __devinit init_asiliant(struct fb_info *p, unsigned long addr)\r\n{\r\nint err;\r\np->fix = asiliantfb_fix;\r\np->fix.smem_start = addr;\r\np->var = asiliantfb_var;\r\np->fbops = &asiliantfb_ops;\r\np->flags = FBINFO_DEFAULT;\r\nerr = fb_alloc_cmap(&p->cmap, 256, 0);\r\nif (err) {\r\nprintk(KERN_ERR "C&T 69000 fb failed to alloc cmap memory\n");\r\nreturn err;\r\n}\r\nerr = register_framebuffer(p);\r\nif (err < 0) {\r\nprintk(KERN_ERR "C&T 69000 framebuffer failed to register\n");\r\nfb_dealloc_cmap(&p->cmap);\r\nreturn err;\r\n}\r\nprintk(KERN_INFO "fb%d: Asiliant 69000 frame buffer (%dK RAM detected)\n",\r\np->node, p->fix.smem_len / 1024);\r\nwriteb(0xff, mmio_base + 0x78c);\r\nchips_hw_init(p);\r\nreturn 0;\r\n}\r\nstatic int __devinit\r\nasiliantfb_pci_init(struct pci_dev *dp, const struct pci_device_id *ent)\r\n{\r\nunsigned long addr, size;\r\nstruct fb_info *p;\r\nint err;\r\nif ((dp->resource[0].flags & IORESOURCE_MEM) == 0)\r\nreturn -ENODEV;\r\naddr = pci_resource_start(dp, 0);\r\nsize = pci_resource_len(dp, 0);\r\nif (addr == 0)\r\nreturn -ENODEV;\r\nif (!request_mem_region(addr, size, "asiliantfb"))\r\nreturn -EBUSY;\r\np = framebuffer_alloc(sizeof(u32) * 16, &dp->dev);\r\nif (!p) {\r\nrelease_mem_region(addr, size);\r\nreturn -ENOMEM;\r\n}\r\np->pseudo_palette = p->par;\r\np->par = NULL;\r\np->screen_base = ioremap(addr, 0x800000);\r\nif (p->screen_base == NULL) {\r\nrelease_mem_region(addr, size);\r\nframebuffer_release(p);\r\nreturn -ENOMEM;\r\n}\r\npci_write_config_dword(dp, 4, 0x02800083);\r\nwriteb(3, p->screen_base + 0x400784);\r\nerr = init_asiliant(p, addr);\r\nif (err) {\r\niounmap(p->screen_base);\r\nrelease_mem_region(addr, size);\r\nframebuffer_release(p);\r\nreturn err;\r\n}\r\npci_set_drvdata(dp, p);\r\nreturn 0;\r\n}\r\nstatic void __devexit asiliantfb_remove(struct pci_dev *dp)\r\n{\r\nstruct fb_info *p = pci_get_drvdata(dp);\r\nunregister_framebuffer(p);\r\nfb_dealloc_cmap(&p->cmap);\r\niounmap(p->screen_base);\r\nrelease_mem_region(pci_resource_start(dp, 0), pci_resource_len(dp, 0));\r\npci_set_drvdata(dp, NULL);\r\nframebuffer_release(p);\r\n}\r\nstatic int __init asiliantfb_init(void)\r\n{\r\nif (fb_get_options("asiliantfb", NULL))\r\nreturn -ENODEV;\r\nreturn pci_register_driver(&asiliantfb_driver);\r\n}\r\nstatic void __exit asiliantfb_exit(void)\r\n{\r\npci_unregister_driver(&asiliantfb_driver);\r\n}
