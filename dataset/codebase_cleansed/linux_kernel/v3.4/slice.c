static void slice_print_mask(const char *label, struct slice_mask mask)\r\n{\r\nchar *p, buf[16 + 3 + 16 + 1];\r\nint i;\r\nif (!_slice_debug)\r\nreturn;\r\np = buf;\r\nfor (i = 0; i < SLICE_NUM_LOW; i++)\r\n*(p++) = (mask.low_slices & (1 << i)) ? '1' : '0';\r\n*(p++) = ' ';\r\n*(p++) = '-';\r\n*(p++) = ' ';\r\nfor (i = 0; i < SLICE_NUM_HIGH; i++)\r\n*(p++) = (mask.high_slices & (1 << i)) ? '1' : '0';\r\n*(p++) = 0;\r\nprintk(KERN_DEBUG "%s:%s\n", label, buf);\r\n}\r\nstatic void slice_print_mask(const char *label, struct slice_mask mask) {}\r\nstatic struct slice_mask slice_range_to_mask(unsigned long start,\r\nunsigned long len)\r\n{\r\nunsigned long end = start + len - 1;\r\nstruct slice_mask ret = { 0, 0 };\r\nif (start < SLICE_LOW_TOP) {\r\nunsigned long mend = min(end, SLICE_LOW_TOP);\r\nunsigned long mstart = min(start, SLICE_LOW_TOP);\r\nret.low_slices = (1u << (GET_LOW_SLICE_INDEX(mend) + 1))\r\n- (1u << GET_LOW_SLICE_INDEX(mstart));\r\n}\r\nif ((start + len) > SLICE_LOW_TOP)\r\nret.high_slices = (1u << (GET_HIGH_SLICE_INDEX(end) + 1))\r\n- (1u << GET_HIGH_SLICE_INDEX(start));\r\nreturn ret;\r\n}\r\nstatic int slice_area_is_free(struct mm_struct *mm, unsigned long addr,\r\nunsigned long len)\r\n{\r\nstruct vm_area_struct *vma;\r\nif ((mm->task_size - len) < addr)\r\nreturn 0;\r\nvma = find_vma(mm, addr);\r\nreturn (!vma || (addr + len) <= vma->vm_start);\r\n}\r\nstatic int slice_low_has_vma(struct mm_struct *mm, unsigned long slice)\r\n{\r\nreturn !slice_area_is_free(mm, slice << SLICE_LOW_SHIFT,\r\n1ul << SLICE_LOW_SHIFT);\r\n}\r\nstatic int slice_high_has_vma(struct mm_struct *mm, unsigned long slice)\r\n{\r\nunsigned long start = slice << SLICE_HIGH_SHIFT;\r\nunsigned long end = start + (1ul << SLICE_HIGH_SHIFT);\r\nif (start == 0)\r\nstart = SLICE_LOW_TOP;\r\nreturn !slice_area_is_free(mm, start, end - start);\r\n}\r\nstatic struct slice_mask slice_mask_for_free(struct mm_struct *mm)\r\n{\r\nstruct slice_mask ret = { 0, 0 };\r\nunsigned long i;\r\nfor (i = 0; i < SLICE_NUM_LOW; i++)\r\nif (!slice_low_has_vma(mm, i))\r\nret.low_slices |= 1u << i;\r\nif (mm->task_size <= SLICE_LOW_TOP)\r\nreturn ret;\r\nfor (i = 0; i < SLICE_NUM_HIGH; i++)\r\nif (!slice_high_has_vma(mm, i))\r\nret.high_slices |= 1u << i;\r\nreturn ret;\r\n}\r\nstatic struct slice_mask slice_mask_for_size(struct mm_struct *mm, int psize)\r\n{\r\nstruct slice_mask ret = { 0, 0 };\r\nunsigned long i;\r\nu64 psizes;\r\npsizes = mm->context.low_slices_psize;\r\nfor (i = 0; i < SLICE_NUM_LOW; i++)\r\nif (((psizes >> (i * 4)) & 0xf) == psize)\r\nret.low_slices |= 1u << i;\r\npsizes = mm->context.high_slices_psize;\r\nfor (i = 0; i < SLICE_NUM_HIGH; i++)\r\nif (((psizes >> (i * 4)) & 0xf) == psize)\r\nret.high_slices |= 1u << i;\r\nreturn ret;\r\n}\r\nstatic int slice_check_fit(struct slice_mask mask, struct slice_mask available)\r\n{\r\nreturn (mask.low_slices & available.low_slices) == mask.low_slices &&\r\n(mask.high_slices & available.high_slices) == mask.high_slices;\r\n}\r\nstatic void slice_flush_segments(void *parm)\r\n{\r\nstruct mm_struct *mm = parm;\r\nunsigned long flags;\r\nif (mm != current->active_mm)\r\nreturn;\r\nget_paca()->context = current->active_mm->context;\r\nlocal_irq_save(flags);\r\nslb_flush_and_rebolt();\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void slice_convert(struct mm_struct *mm, struct slice_mask mask, int psize)\r\n{\r\nu64 lpsizes, hpsizes;\r\nunsigned long i, flags;\r\nslice_dbg("slice_convert(mm=%p, psize=%d)\n", mm, psize);\r\nslice_print_mask(" mask", mask);\r\nspin_lock_irqsave(&slice_convert_lock, flags);\r\nlpsizes = mm->context.low_slices_psize;\r\nfor (i = 0; i < SLICE_NUM_LOW; i++)\r\nif (mask.low_slices & (1u << i))\r\nlpsizes = (lpsizes & ~(0xful << (i * 4))) |\r\n(((unsigned long)psize) << (i * 4));\r\nhpsizes = mm->context.high_slices_psize;\r\nfor (i = 0; i < SLICE_NUM_HIGH; i++)\r\nif (mask.high_slices & (1u << i))\r\nhpsizes = (hpsizes & ~(0xful << (i * 4))) |\r\n(((unsigned long)psize) << (i * 4));\r\nmm->context.low_slices_psize = lpsizes;\r\nmm->context.high_slices_psize = hpsizes;\r\nslice_dbg(" lsps=%lx, hsps=%lx\n",\r\nmm->context.low_slices_psize,\r\nmm->context.high_slices_psize);\r\nspin_unlock_irqrestore(&slice_convert_lock, flags);\r\n#ifdef CONFIG_SPU_BASE\r\nspu_flush_all_slbs(mm);\r\n#endif\r\n}\r\nstatic unsigned long slice_find_area_bottomup(struct mm_struct *mm,\r\nunsigned long len,\r\nstruct slice_mask available,\r\nint psize, int use_cache)\r\n{\r\nstruct vm_area_struct *vma;\r\nunsigned long start_addr, addr;\r\nstruct slice_mask mask;\r\nint pshift = max_t(int, mmu_psize_defs[psize].shift, PAGE_SHIFT);\r\nif (use_cache) {\r\nif (len <= mm->cached_hole_size) {\r\nstart_addr = addr = TASK_UNMAPPED_BASE;\r\nmm->cached_hole_size = 0;\r\n} else\r\nstart_addr = addr = mm->free_area_cache;\r\n} else\r\nstart_addr = addr = TASK_UNMAPPED_BASE;\r\nfull_search:\r\nfor (;;) {\r\naddr = _ALIGN_UP(addr, 1ul << pshift);\r\nif ((TASK_SIZE - len) < addr)\r\nbreak;\r\nvma = find_vma(mm, addr);\r\nBUG_ON(vma && (addr >= vma->vm_end));\r\nmask = slice_range_to_mask(addr, len);\r\nif (!slice_check_fit(mask, available)) {\r\nif (addr < SLICE_LOW_TOP)\r\naddr = _ALIGN_UP(addr + 1, 1ul << SLICE_LOW_SHIFT);\r\nelse\r\naddr = _ALIGN_UP(addr + 1, 1ul << SLICE_HIGH_SHIFT);\r\ncontinue;\r\n}\r\nif (!vma || addr + len <= vma->vm_start) {\r\nif (use_cache)\r\nmm->free_area_cache = addr + len;\r\nreturn addr;\r\n}\r\nif (use_cache && (addr + mm->cached_hole_size) < vma->vm_start)\r\nmm->cached_hole_size = vma->vm_start - addr;\r\naddr = vma->vm_end;\r\n}\r\nif (use_cache && start_addr != TASK_UNMAPPED_BASE) {\r\nstart_addr = addr = TASK_UNMAPPED_BASE;\r\nmm->cached_hole_size = 0;\r\ngoto full_search;\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic unsigned long slice_find_area_topdown(struct mm_struct *mm,\r\nunsigned long len,\r\nstruct slice_mask available,\r\nint psize, int use_cache)\r\n{\r\nstruct vm_area_struct *vma;\r\nunsigned long addr;\r\nstruct slice_mask mask;\r\nint pshift = max_t(int, mmu_psize_defs[psize].shift, PAGE_SHIFT);\r\nif (use_cache) {\r\nif (len <= mm->cached_hole_size) {\r\nmm->cached_hole_size = 0;\r\nmm->free_area_cache = mm->mmap_base;\r\n}\r\naddr = mm->free_area_cache;\r\nif (addr > len) {\r\naddr = _ALIGN_DOWN(addr - len, 1ul << pshift);\r\nmask = slice_range_to_mask(addr, len);\r\nif (slice_check_fit(mask, available) &&\r\nslice_area_is_free(mm, addr, len))\r\nreturn (mm->free_area_cache = addr);\r\n}\r\n}\r\naddr = mm->mmap_base;\r\nwhile (addr > len) {\r\naddr = _ALIGN_DOWN(addr - len, 1ul << pshift);\r\nmask = slice_range_to_mask(addr, len);\r\nif (!slice_check_fit(mask, available)) {\r\nif (addr < SLICE_LOW_TOP)\r\naddr = _ALIGN_DOWN(addr, 1ul << SLICE_LOW_SHIFT);\r\nelse if (addr < (1ul << SLICE_HIGH_SHIFT))\r\naddr = SLICE_LOW_TOP;\r\nelse\r\naddr = _ALIGN_DOWN(addr, 1ul << SLICE_HIGH_SHIFT);\r\ncontinue;\r\n}\r\nvma = find_vma(mm, addr);\r\nif (!vma || (addr + len) <= vma->vm_start) {\r\nif (use_cache)\r\nmm->free_area_cache = addr;\r\nreturn addr;\r\n}\r\nif (use_cache && (addr + mm->cached_hole_size) < vma->vm_start)\r\nmm->cached_hole_size = vma->vm_start - addr;\r\naddr = vma->vm_start;\r\n}\r\naddr = slice_find_area_bottomup(mm, len, available, psize, 0);\r\nif (use_cache) {\r\nmm->free_area_cache = mm->mmap_base;\r\nmm->cached_hole_size = ~0UL;\r\n}\r\nreturn addr;\r\n}\r\nstatic unsigned long slice_find_area(struct mm_struct *mm, unsigned long len,\r\nstruct slice_mask mask, int psize,\r\nint topdown, int use_cache)\r\n{\r\nif (topdown)\r\nreturn slice_find_area_topdown(mm, len, mask, psize, use_cache);\r\nelse\r\nreturn slice_find_area_bottomup(mm, len, mask, psize, use_cache);\r\n}\r\nunsigned long slice_get_unmapped_area(unsigned long addr, unsigned long len,\r\nunsigned long flags, unsigned int psize,\r\nint topdown, int use_cache)\r\n{\r\nstruct slice_mask mask = {0, 0};\r\nstruct slice_mask good_mask;\r\nstruct slice_mask potential_mask = {0,0} ;\r\nstruct slice_mask compat_mask = {0, 0};\r\nint fixed = (flags & MAP_FIXED);\r\nint pshift = max_t(int, mmu_psize_defs[psize].shift, PAGE_SHIFT);\r\nstruct mm_struct *mm = current->mm;\r\nunsigned long newaddr;\r\nBUG_ON(mm->task_size == 0);\r\nslice_dbg("slice_get_unmapped_area(mm=%p, psize=%d...\n", mm, psize);\r\nslice_dbg(" addr=%lx, len=%lx, flags=%lx, topdown=%d, use_cache=%d\n",\r\naddr, len, flags, topdown, use_cache);\r\nif (len > mm->task_size)\r\nreturn -ENOMEM;\r\nif (len & ((1ul << pshift) - 1))\r\nreturn -EINVAL;\r\nif (fixed && (addr & ((1ul << pshift) - 1)))\r\nreturn -EINVAL;\r\nif (fixed && addr > (mm->task_size - len))\r\nreturn -EINVAL;\r\nif (!fixed && addr) {\r\naddr = _ALIGN_UP(addr, 1ul << pshift);\r\nslice_dbg(" aligned addr=%lx\n", addr);\r\nif (addr > mm->task_size - len ||\r\n!slice_area_is_free(mm, addr, len))\r\naddr = 0;\r\n}\r\ngood_mask = slice_mask_for_size(mm, psize);\r\nslice_print_mask(" good_mask", good_mask);\r\n#ifdef CONFIG_PPC_64K_PAGES\r\nif (psize == MMU_PAGE_64K) {\r\ncompat_mask = slice_mask_for_size(mm, MMU_PAGE_4K);\r\nif (fixed)\r\nor_mask(good_mask, compat_mask);\r\n}\r\n#endif\r\nif (addr != 0 || fixed) {\r\nmask = slice_range_to_mask(addr, len);\r\nslice_print_mask(" mask", mask);\r\nif (slice_check_fit(mask, good_mask)) {\r\nslice_dbg(" fits good !\n");\r\nreturn addr;\r\n}\r\n} else {\r\nnewaddr = slice_find_area(mm, len, good_mask, psize, topdown,\r\nuse_cache);\r\nif (newaddr != -ENOMEM) {\r\nslice_dbg(" found area at 0x%lx\n", newaddr);\r\nreturn newaddr;\r\n}\r\n}\r\npotential_mask = slice_mask_for_free(mm);\r\nor_mask(potential_mask, good_mask);\r\nslice_print_mask(" potential", potential_mask);\r\nif ((addr != 0 || fixed) && slice_check_fit(mask, potential_mask)) {\r\nslice_dbg(" fits potential !\n");\r\ngoto convert;\r\n}\r\nif (fixed)\r\nreturn -EBUSY;\r\nslice_dbg(" search...\n");\r\nif (addr) {\r\naddr = slice_find_area(mm, len, good_mask, psize, topdown,\r\nuse_cache);\r\nif (addr != -ENOMEM) {\r\nslice_dbg(" found area at 0x%lx\n", addr);\r\nreturn addr;\r\n}\r\n}\r\naddr = slice_find_area(mm, len, potential_mask, psize, topdown,\r\nuse_cache);\r\n#ifdef CONFIG_PPC_64K_PAGES\r\nif (addr == -ENOMEM && psize == MMU_PAGE_64K) {\r\nor_mask(potential_mask, compat_mask);\r\naddr = slice_find_area(mm, len, potential_mask, psize,\r\ntopdown, use_cache);\r\n}\r\n#endif\r\nif (addr == -ENOMEM)\r\nreturn -ENOMEM;\r\nmask = slice_range_to_mask(addr, len);\r\nslice_dbg(" found potential area at 0x%lx\n", addr);\r\nslice_print_mask(" mask", mask);\r\nconvert:\r\nandnot_mask(mask, good_mask);\r\nandnot_mask(mask, compat_mask);\r\nif (mask.low_slices || mask.high_slices) {\r\nslice_convert(mm, mask, psize);\r\nif (psize > MMU_PAGE_BASE)\r\non_each_cpu(slice_flush_segments, mm, 1);\r\n}\r\nreturn addr;\r\n}\r\nunsigned long arch_get_unmapped_area(struct file *filp,\r\nunsigned long addr,\r\nunsigned long len,\r\nunsigned long pgoff,\r\nunsigned long flags)\r\n{\r\nreturn slice_get_unmapped_area(addr, len, flags,\r\ncurrent->mm->context.user_psize,\r\n0, 1);\r\n}\r\nunsigned long arch_get_unmapped_area_topdown(struct file *filp,\r\nconst unsigned long addr0,\r\nconst unsigned long len,\r\nconst unsigned long pgoff,\r\nconst unsigned long flags)\r\n{\r\nreturn slice_get_unmapped_area(addr0, len, flags,\r\ncurrent->mm->context.user_psize,\r\n1, 1);\r\n}\r\nunsigned int get_slice_psize(struct mm_struct *mm, unsigned long addr)\r\n{\r\nu64 psizes;\r\nint index;\r\nif (addr < SLICE_LOW_TOP) {\r\npsizes = mm->context.low_slices_psize;\r\nindex = GET_LOW_SLICE_INDEX(addr);\r\n} else {\r\npsizes = mm->context.high_slices_psize;\r\nindex = GET_HIGH_SLICE_INDEX(addr);\r\n}\r\nreturn (psizes >> (index * 4)) & 0xf;\r\n}\r\nvoid slice_set_user_psize(struct mm_struct *mm, unsigned int psize)\r\n{\r\nunsigned long flags, lpsizes, hpsizes;\r\nunsigned int old_psize;\r\nint i;\r\nslice_dbg("slice_set_user_psize(mm=%p, psize=%d)\n", mm, psize);\r\nspin_lock_irqsave(&slice_convert_lock, flags);\r\nold_psize = mm->context.user_psize;\r\nslice_dbg(" old_psize=%d\n", old_psize);\r\nif (old_psize == psize)\r\ngoto bail;\r\nmm->context.user_psize = psize;\r\nwmb();\r\nlpsizes = mm->context.low_slices_psize;\r\nfor (i = 0; i < SLICE_NUM_LOW; i++)\r\nif (((lpsizes >> (i * 4)) & 0xf) == old_psize)\r\nlpsizes = (lpsizes & ~(0xful << (i * 4))) |\r\n(((unsigned long)psize) << (i * 4));\r\nhpsizes = mm->context.high_slices_psize;\r\nfor (i = 0; i < SLICE_NUM_HIGH; i++)\r\nif (((hpsizes >> (i * 4)) & 0xf) == old_psize)\r\nhpsizes = (hpsizes & ~(0xful << (i * 4))) |\r\n(((unsigned long)psize) << (i * 4));\r\nmm->context.low_slices_psize = lpsizes;\r\nmm->context.high_slices_psize = hpsizes;\r\nslice_dbg(" lsps=%lx, hsps=%lx\n",\r\nmm->context.low_slices_psize,\r\nmm->context.high_slices_psize);\r\nbail:\r\nspin_unlock_irqrestore(&slice_convert_lock, flags);\r\n}\r\nvoid slice_set_psize(struct mm_struct *mm, unsigned long address,\r\nunsigned int psize)\r\n{\r\nunsigned long i, flags;\r\nu64 *p;\r\nspin_lock_irqsave(&slice_convert_lock, flags);\r\nif (address < SLICE_LOW_TOP) {\r\ni = GET_LOW_SLICE_INDEX(address);\r\np = &mm->context.low_slices_psize;\r\n} else {\r\ni = GET_HIGH_SLICE_INDEX(address);\r\np = &mm->context.high_slices_psize;\r\n}\r\n*p = (*p & ~(0xful << (i * 4))) | ((unsigned long) psize << (i * 4));\r\nspin_unlock_irqrestore(&slice_convert_lock, flags);\r\n#ifdef CONFIG_SPU_BASE\r\nspu_flush_all_slbs(mm);\r\n#endif\r\n}\r\nvoid slice_set_range_psize(struct mm_struct *mm, unsigned long start,\r\nunsigned long len, unsigned int psize)\r\n{\r\nstruct slice_mask mask = slice_range_to_mask(start, len);\r\nslice_convert(mm, mask, psize);\r\n}\r\nint is_hugepage_only_range(struct mm_struct *mm, unsigned long addr,\r\nunsigned long len)\r\n{\r\nstruct slice_mask mask, available;\r\nunsigned int psize = mm->context.user_psize;\r\nmask = slice_range_to_mask(addr, len);\r\navailable = slice_mask_for_size(mm, psize);\r\n#ifdef CONFIG_PPC_64K_PAGES\r\nif (psize == MMU_PAGE_64K) {\r\nstruct slice_mask compat_mask;\r\ncompat_mask = slice_mask_for_size(mm, MMU_PAGE_4K);\r\nor_mask(available, compat_mask);\r\n}\r\n#endif\r\n#if 0\r\nslice_dbg("is_hugepage_only_range(mm=%p, addr=%lx, len=%lx)\n",\r\nmm, addr, len);\r\nslice_print_mask(" mask", mask);\r\nslice_print_mask(" available", available);\r\n#endif\r\nreturn !slice_check_fit(mask, available);\r\n}
