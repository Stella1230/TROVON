static ssize_t __i2400ms_rx_get_size(struct i2400ms *i2400ms)\r\n{\r\nint ret, cnt, val;\r\nssize_t rx_size;\r\nunsigned xfer_size_addr;\r\nstruct sdio_func *func = i2400ms->func;\r\nstruct device *dev = &i2400ms->func->dev;\r\nd_fnstart(7, dev, "(i2400ms %p)\n", i2400ms);\r\nxfer_size_addr = I2400MS_INTR_GET_SIZE_ADDR;\r\nrx_size = 0;\r\nfor (cnt = 0; cnt < 3; cnt++) {\r\nval = sdio_readb(func, xfer_size_addr + cnt, &ret);\r\nif (ret < 0) {\r\ndev_err(dev, "RX: Can't read byte %d of RX size from "\r\n"0x%08x: %d\n", cnt, xfer_size_addr + cnt, ret);\r\nrx_size = ret;\r\ngoto error_read;\r\n}\r\nrx_size = rx_size << 8 | (val & 0xff);\r\n}\r\nd_printf(6, dev, "RX: rx_size is %ld\n", (long) rx_size);\r\nerror_read:\r\nd_fnend(7, dev, "(i2400ms %p) = %ld\n", i2400ms, (long) rx_size);\r\nreturn rx_size;\r\n}\r\nstatic\r\nvoid i2400ms_rx(struct i2400ms *i2400ms)\r\n{\r\nint ret;\r\nstruct sdio_func *func = i2400ms->func;\r\nstruct device *dev = &func->dev;\r\nstruct i2400m *i2400m = &i2400ms->i2400m;\r\nstruct sk_buff *skb;\r\nssize_t rx_size;\r\nd_fnstart(7, dev, "(i2400ms %p)\n", i2400ms);\r\nrx_size = __i2400ms_rx_get_size(i2400ms);\r\nif (rx_size < 0) {\r\nret = rx_size;\r\ngoto error_get_size;\r\n}\r\nsdio_writeb(func, 1, I2400MS_INTR_CLEAR_ADDR, &ret);\r\nret = -ENOMEM;\r\nskb = alloc_skb(rx_size, GFP_ATOMIC);\r\nif (NULL == skb) {\r\ndev_err(dev, "RX: unable to alloc skb\n");\r\ngoto error_alloc_skb;\r\n}\r\nret = sdio_memcpy_fromio(func, skb->data,\r\nI2400MS_DATA_ADDR, rx_size);\r\nif (ret < 0) {\r\ndev_err(dev, "RX: SDIO data read failed: %d\n", ret);\r\ngoto error_memcpy_fromio;\r\n}\r\nrmb();\r\nif (unlikely(i2400m->boot_mode == 1)) {\r\nspin_lock(&i2400m->rx_lock);\r\ni2400ms->bm_ack_size = rx_size;\r\nspin_unlock(&i2400m->rx_lock);\r\nmemcpy(i2400m->bm_ack_buf, skb->data, rx_size);\r\nwake_up(&i2400ms->bm_wfa_wq);\r\nd_printf(5, dev, "RX: SDIO boot mode message\n");\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nret = -EIO;\r\nif (unlikely(rx_size < sizeof(__le32))) {\r\ndev_err(dev, "HW BUG? only %zu bytes received\n", rx_size);\r\ngoto error_bad_size;\r\n}\r\nif (likely(i2400m_is_d2h_barker(skb->data))) {\r\nskb_put(skb, rx_size);\r\ni2400m_rx(i2400m, skb);\r\n} else if (unlikely(i2400m_is_boot_barker(i2400m,\r\nskb->data, rx_size))) {\r\nret = i2400m_dev_reset_handle(i2400m, "device rebooted");\r\ndev_err(dev, "RX: SDIO reboot barker\n");\r\nkfree_skb(skb);\r\n} else {\r\ni2400m_unknown_barker(i2400m, skb->data, rx_size);\r\nkfree_skb(skb);\r\n}\r\nout:\r\nd_fnend(7, dev, "(i2400ms %p) = void\n", i2400ms);\r\nreturn;\r\nerror_memcpy_fromio:\r\nkfree_skb(skb);\r\nerror_alloc_skb:\r\nerror_get_size:\r\nerror_bad_size:\r\nd_fnend(7, dev, "(i2400ms %p) = %d\n", i2400ms, ret);\r\n}\r\nstatic\r\nvoid i2400ms_irq(struct sdio_func *func)\r\n{\r\nint ret;\r\nstruct i2400ms *i2400ms = sdio_get_drvdata(func);\r\nstruct device *dev = &func->dev;\r\nint val;\r\nd_fnstart(6, dev, "(i2400ms %p)\n", i2400ms);\r\nval = sdio_readb(func, I2400MS_INTR_STATUS_ADDR, &ret);\r\nif (ret < 0) {\r\ndev_err(dev, "RX: Can't read interrupt status: %d\n", ret);\r\ngoto error_no_irq;\r\n}\r\nif (!val) {\r\ndev_err(dev, "RX: BUG? got IRQ but no interrupt ready?\n");\r\ngoto error_no_irq;\r\n}\r\ni2400ms_rx(i2400ms);\r\nerror_no_irq:\r\nd_fnend(6, dev, "(i2400ms %p) = void\n", i2400ms);\r\n}\r\nint i2400ms_rx_setup(struct i2400ms *i2400ms)\r\n{\r\nint result;\r\nstruct sdio_func *func = i2400ms->func;\r\nstruct device *dev = &func->dev;\r\nstruct i2400m *i2400m = &i2400ms->i2400m;\r\nd_fnstart(5, dev, "(i2400ms %p)\n", i2400ms);\r\ninit_waitqueue_head(&i2400ms->bm_wfa_wq);\r\nspin_lock(&i2400m->rx_lock);\r\ni2400ms->bm_wait_result = -EINPROGRESS;\r\ni2400ms->bm_ack_size = -EINPROGRESS;\r\nspin_unlock(&i2400m->rx_lock);\r\nsdio_claim_host(func);\r\nresult = sdio_claim_irq(func, i2400ms_irq);\r\nif (result < 0) {\r\ndev_err(dev, "Cannot claim IRQ: %d\n", result);\r\ngoto error_irq_claim;\r\n}\r\nresult = 0;\r\nsdio_writeb(func, 1, I2400MS_INTR_ENABLE_ADDR, &result);\r\nif (result < 0) {\r\nsdio_release_irq(func);\r\ndev_err(dev, "Failed to enable interrupts %d\n", result);\r\n}\r\nerror_irq_claim:\r\nsdio_release_host(func);\r\nd_fnend(5, dev, "(i2400ms %p) = %d\n", i2400ms, result);\r\nreturn result;\r\n}\r\nvoid i2400ms_rx_release(struct i2400ms *i2400ms)\r\n{\r\nint result;\r\nstruct sdio_func *func = i2400ms->func;\r\nstruct device *dev = &func->dev;\r\nstruct i2400m *i2400m = &i2400ms->i2400m;\r\nd_fnstart(5, dev, "(i2400ms %p)\n", i2400ms);\r\nspin_lock(&i2400m->rx_lock);\r\ni2400ms->bm_ack_size = -EINTR;\r\nspin_unlock(&i2400m->rx_lock);\r\nwake_up_all(&i2400ms->bm_wfa_wq);\r\nsdio_claim_host(func);\r\nsdio_writeb(func, 0, I2400MS_INTR_ENABLE_ADDR, &result);\r\nsdio_release_irq(func);\r\nsdio_release_host(func);\r\nd_fnend(5, dev, "(i2400ms %p) = %d\n", i2400ms, result);\r\n}
