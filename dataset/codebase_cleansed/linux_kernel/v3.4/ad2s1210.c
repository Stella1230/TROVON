static inline void ad2s1210_set_mode(enum ad2s1210_mode mode,\r\nstruct ad2s1210_state *st)\r\n{\r\ngpio_set_value(st->pdata->a[0], ad2s1210_mode_vals[mode][0]);\r\ngpio_set_value(st->pdata->a[1], ad2s1210_mode_vals[mode][1]);\r\nst->mode = mode;\r\n}\r\nstatic int ad2s1210_config_write(struct ad2s1210_state *st, u8 data)\r\n{\r\nint ret;\r\nad2s1210_set_mode(MOD_CONFIG, st);\r\nst->tx[0] = data;\r\nret = spi_write(st->sdev, st->tx, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nst->old_data = true;\r\nreturn 0;\r\n}\r\nstatic int ad2s1210_config_read(struct ad2s1210_state *st,\r\nunsigned char address)\r\n{\r\nstruct spi_transfer xfer = {\r\n.len = 2,\r\n.rx_buf = st->rx,\r\n.tx_buf = st->tx,\r\n};\r\nstruct spi_message msg;\r\nint ret = 0;\r\nad2s1210_set_mode(MOD_CONFIG, st);\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\nst->tx[0] = address | AD2S1210_MSB_IS_HIGH;\r\nst->tx[1] = AD2S1210_REG_FAULT;\r\nret = spi_sync(st->sdev, &msg);\r\nif (ret < 0)\r\nreturn ret;\r\nst->old_data = true;\r\nreturn st->rx[1];\r\n}\r\nstatic inline\r\nint ad2s1210_update_frequency_control_word(struct ad2s1210_state *st)\r\n{\r\nint ret;\r\nunsigned char fcw;\r\nfcw = (unsigned char)(st->fexcit * (1 << 15) / st->fclkin);\r\nif (fcw < AD2S1210_MIN_FCW || fcw > AD2S1210_MAX_FCW) {\r\npr_err("ad2s1210: FCW out of range\n");\r\nreturn -ERANGE;\r\n}\r\nret = ad2s1210_config_write(st, AD2S1210_REG_EXCIT_FREQ);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ad2s1210_config_write(st, fcw);\r\n}\r\nstatic unsigned char ad2s1210_read_resolution_pin(struct ad2s1210_state *st)\r\n{\r\nreturn ad2s1210_resolution_value[\r\n(gpio_get_value(st->pdata->res[0]) << 1) |\r\ngpio_get_value(st->pdata->res[1])];\r\n}\r\nstatic inline void ad2s1210_set_resolution_pin(struct ad2s1210_state *st)\r\n{\r\ngpio_set_value(st->pdata->res[0],\r\nad2s1210_res_pins[(st->resolution - 10)/2][0]);\r\ngpio_set_value(st->pdata->res[1],\r\nad2s1210_res_pins[(st->resolution - 10)/2][1]);\r\n}\r\nstatic inline int ad2s1210_soft_reset(struct ad2s1210_state *st)\r\n{\r\nint ret;\r\nret = ad2s1210_config_write(st, AD2S1210_REG_SOFT_RESET);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn ad2s1210_config_write(st, 0x0);\r\n}\r\nstatic ssize_t ad2s1210_store_softreset(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));\r\nint ret;\r\nmutex_lock(&st->lock);\r\nret = ad2s1210_soft_reset(st);\r\nmutex_unlock(&st->lock);\r\nreturn ret < 0 ? ret : len;\r\n}\r\nstatic ssize_t ad2s1210_show_fclkin(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));\r\nreturn sprintf(buf, "%d\n", st->fclkin);\r\n}\r\nstatic ssize_t ad2s1210_store_fclkin(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));\r\nunsigned long fclkin;\r\nint ret;\r\nret = strict_strtoul(buf, 10, &fclkin);\r\nif (ret)\r\nreturn ret;\r\nif (fclkin < AD2S1210_MIN_CLKIN || fclkin > AD2S1210_MAX_CLKIN) {\r\npr_err("ad2s1210: fclkin out of range\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&st->lock);\r\nst->fclkin = fclkin;\r\nret = ad2s1210_update_frequency_control_word(st);\r\nif (ret < 0)\r\ngoto error_ret;\r\nret = ad2s1210_soft_reset(st);\r\nerror_ret:\r\nmutex_unlock(&st->lock);\r\nreturn ret < 0 ? ret : len;\r\n}\r\nstatic ssize_t ad2s1210_show_fexcit(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));\r\nreturn sprintf(buf, "%d\n", st->fexcit);\r\n}\r\nstatic ssize_t ad2s1210_store_fexcit(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));\r\nunsigned long fexcit;\r\nint ret;\r\nret = strict_strtoul(buf, 10, &fexcit);\r\nif (ret < 0)\r\nreturn ret;\r\nif (fexcit < AD2S1210_MIN_EXCIT || fexcit > AD2S1210_MAX_EXCIT) {\r\npr_err("ad2s1210: excitation frequency out of range\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&st->lock);\r\nst->fexcit = fexcit;\r\nret = ad2s1210_update_frequency_control_word(st);\r\nif (ret < 0)\r\ngoto error_ret;\r\nret = ad2s1210_soft_reset(st);\r\nerror_ret:\r\nmutex_unlock(&st->lock);\r\nreturn ret < 0 ? ret : len;\r\n}\r\nstatic ssize_t ad2s1210_show_control(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));\r\nint ret;\r\nmutex_lock(&st->lock);\r\nret = ad2s1210_config_read(st, AD2S1210_REG_CONTROL);\r\nmutex_unlock(&st->lock);\r\nreturn ret < 0 ? ret : sprintf(buf, "0x%x\n", ret);\r\n}\r\nstatic ssize_t ad2s1210_store_control(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));\r\nunsigned long udata;\r\nunsigned char data;\r\nint ret;\r\nret = strict_strtoul(buf, 16, &udata);\r\nif (ret)\r\nreturn -EINVAL;\r\nmutex_lock(&st->lock);\r\nret = ad2s1210_config_write(st, AD2S1210_REG_CONTROL);\r\nif (ret < 0)\r\ngoto error_ret;\r\ndata = udata & AD2S1210_MSB_IS_LOW;\r\nret = ad2s1210_config_write(st, data);\r\nif (ret < 0)\r\ngoto error_ret;\r\nret = ad2s1210_config_read(st, AD2S1210_REG_CONTROL);\r\nif (ret < 0)\r\ngoto error_ret;\r\nif (ret & AD2S1210_MSB_IS_HIGH) {\r\nret = -EIO;\r\npr_err("ad2s1210: write control register fail\n");\r\ngoto error_ret;\r\n}\r\nst->resolution\r\n= ad2s1210_resolution_value[data & AD2S1210_SET_RESOLUTION];\r\nif (st->pdata->gpioin) {\r\ndata = ad2s1210_read_resolution_pin(st);\r\nif (data != st->resolution)\r\npr_warning("ad2s1210: resolution settings not match\n");\r\n} else\r\nad2s1210_set_resolution_pin(st);\r\nret = len;\r\nst->hysteresis = !!(data & AD2S1210_ENABLE_HYSTERESIS);\r\nerror_ret:\r\nmutex_unlock(&st->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t ad2s1210_show_resolution(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));\r\nreturn sprintf(buf, "%d\n", st->resolution);\r\n}\r\nstatic ssize_t ad2s1210_store_resolution(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));\r\nunsigned char data;\r\nunsigned long udata;\r\nint ret;\r\nret = strict_strtoul(buf, 10, &udata);\r\nif (ret || udata < 10 || udata > 16) {\r\npr_err("ad2s1210: resolution out of range\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&st->lock);\r\nret = ad2s1210_config_read(st, AD2S1210_REG_CONTROL);\r\nif (ret < 0)\r\ngoto error_ret;\r\ndata = ret;\r\ndata &= ~AD2S1210_SET_RESOLUTION;\r\ndata |= (udata - 10) >> 1;\r\nret = ad2s1210_config_write(st, AD2S1210_REG_CONTROL);\r\nif (ret < 0)\r\ngoto error_ret;\r\nret = ad2s1210_config_write(st, data & AD2S1210_MSB_IS_LOW);\r\nif (ret < 0)\r\ngoto error_ret;\r\nret = ad2s1210_config_read(st, AD2S1210_REG_CONTROL);\r\nif (ret < 0)\r\ngoto error_ret;\r\ndata = ret;\r\nif (data & AD2S1210_MSB_IS_HIGH) {\r\nret = -EIO;\r\npr_err("ad2s1210: setting resolution fail\n");\r\ngoto error_ret;\r\n}\r\nst->resolution\r\n= ad2s1210_resolution_value[data & AD2S1210_SET_RESOLUTION];\r\nif (st->pdata->gpioin) {\r\ndata = ad2s1210_read_resolution_pin(st);\r\nif (data != st->resolution)\r\npr_warning("ad2s1210: resolution settings not match\n");\r\n} else\r\nad2s1210_set_resolution_pin(st);\r\nret = len;\r\nerror_ret:\r\nmutex_unlock(&st->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t ad2s1210_show_fault(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));\r\nint ret;\r\nmutex_lock(&st->lock);\r\nret = ad2s1210_config_read(st, AD2S1210_REG_FAULT);\r\nmutex_unlock(&st->lock);\r\nreturn ret ? ret : sprintf(buf, "0x%x\n", ret);\r\n}\r\nstatic ssize_t ad2s1210_clear_fault(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));\r\nint ret;\r\nmutex_lock(&st->lock);\r\ngpio_set_value(st->pdata->sample, 0);\r\nudelay(1);\r\ngpio_set_value(st->pdata->sample, 1);\r\nret = ad2s1210_config_read(st, AD2S1210_REG_FAULT);\r\nif (ret < 0)\r\ngoto error_ret;\r\ngpio_set_value(st->pdata->sample, 0);\r\ngpio_set_value(st->pdata->sample, 1);\r\nerror_ret:\r\nmutex_unlock(&st->lock);\r\nreturn ret < 0 ? ret : len;\r\n}\r\nstatic ssize_t ad2s1210_show_reg(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));\r\nstruct iio_dev_attr *iattr = to_iio_dev_attr(attr);\r\nint ret;\r\nmutex_lock(&st->lock);\r\nret = ad2s1210_config_read(st, iattr->address);\r\nmutex_unlock(&st->lock);\r\nreturn ret < 0 ? ret : sprintf(buf, "%d\n", ret);\r\n}\r\nstatic ssize_t ad2s1210_store_reg(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));\r\nunsigned long data;\r\nint ret;\r\nstruct iio_dev_attr *iattr = to_iio_dev_attr(attr);\r\nret = strict_strtoul(buf, 10, &data);\r\nif (ret)\r\nreturn -EINVAL;\r\nmutex_lock(&st->lock);\r\nret = ad2s1210_config_write(st, iattr->address);\r\nif (ret < 0)\r\ngoto error_ret;\r\nret = ad2s1210_config_write(st, data & AD2S1210_MSB_IS_LOW);\r\nerror_ret:\r\nmutex_unlock(&st->lock);\r\nreturn ret < 0 ? ret : len;\r\n}\r\nstatic int ad2s1210_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong m)\r\n{\r\nstruct ad2s1210_state *st = iio_priv(indio_dev);\r\nbool negative;\r\nint ret = 0;\r\nu16 pos;\r\ns16 vel;\r\nmutex_lock(&st->lock);\r\ngpio_set_value(st->pdata->sample, 0);\r\nudelay(1);\r\nswitch (chan->type) {\r\ncase IIO_ANGL:\r\nad2s1210_set_mode(MOD_POS, st);\r\nbreak;\r\ncase IIO_ANGL_VEL:\r\nad2s1210_set_mode(MOD_VEL, st);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (ret < 0)\r\ngoto error_ret;\r\nret = spi_read(st->sdev, st->rx, 2);\r\nif (ret < 0)\r\ngoto error_ret;\r\nswitch (chan->type) {\r\ncase IIO_ANGL:\r\npos = be16_to_cpup((u16 *)st->rx);\r\nif (st->hysteresis)\r\npos >>= 16 - st->resolution;\r\n*val = pos;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_ANGL_VEL:\r\nnegative = st->rx[0] & 0x80;\r\nvel = be16_to_cpup((s16 *)st->rx);\r\nvel >>= 16 - st->resolution;\r\nif (vel & 0x8000) {\r\nnegative = (0xffff >> st->resolution) << st->resolution;\r\nvel |= negative;\r\n}\r\n*val = vel;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&st->lock);\r\nreturn -EINVAL;\r\n}\r\nerror_ret:\r\ngpio_set_value(st->pdata->sample, 1);\r\nudelay(1);\r\nmutex_unlock(&st->lock);\r\nreturn ret;\r\n}\r\nstatic int __devinit ad2s1210_initial(struct ad2s1210_state *st)\r\n{\r\nunsigned char data;\r\nint ret;\r\nmutex_lock(&st->lock);\r\nif (st->pdata->gpioin)\r\nst->resolution = ad2s1210_read_resolution_pin(st);\r\nelse\r\nad2s1210_set_resolution_pin(st);\r\nret = ad2s1210_config_write(st, AD2S1210_REG_CONTROL);\r\nif (ret < 0)\r\ngoto error_ret;\r\ndata = AD2S1210_DEF_CONTROL & ~(AD2S1210_SET_RESOLUTION);\r\ndata |= (st->resolution - 10) >> 1;\r\nret = ad2s1210_config_write(st, data);\r\nif (ret < 0)\r\ngoto error_ret;\r\nret = ad2s1210_config_read(st, AD2S1210_REG_CONTROL);\r\nif (ret < 0)\r\ngoto error_ret;\r\nif (ret & AD2S1210_MSB_IS_HIGH) {\r\nret = -EIO;\r\ngoto error_ret;\r\n}\r\nret = ad2s1210_update_frequency_control_word(st);\r\nif (ret < 0)\r\ngoto error_ret;\r\nret = ad2s1210_soft_reset(st);\r\nerror_ret:\r\nmutex_unlock(&st->lock);\r\nreturn ret;\r\n}\r\nstatic int ad2s1210_setup_gpios(struct ad2s1210_state *st)\r\n{\r\nunsigned long flags = st->pdata->gpioin ? GPIOF_DIR_IN : GPIOF_DIR_OUT;\r\nstruct gpio ad2s1210_gpios[] = {\r\n{ st->pdata->sample, GPIOF_DIR_IN, "sample" },\r\n{ st->pdata->a[0], flags, "a0" },\r\n{ st->pdata->a[1], flags, "a1" },\r\n{ st->pdata->res[0], flags, "res0" },\r\n{ st->pdata->res[0], flags, "res1" },\r\n};\r\nreturn gpio_request_array(ad2s1210_gpios, ARRAY_SIZE(ad2s1210_gpios));\r\n}\r\nstatic void ad2s1210_free_gpios(struct ad2s1210_state *st)\r\n{\r\nunsigned long flags = st->pdata->gpioin ? GPIOF_DIR_IN : GPIOF_DIR_OUT;\r\nstruct gpio ad2s1210_gpios[] = {\r\n{ st->pdata->sample, GPIOF_DIR_IN, "sample" },\r\n{ st->pdata->a[0], flags, "a0" },\r\n{ st->pdata->a[1], flags, "a1" },\r\n{ st->pdata->res[0], flags, "res0" },\r\n{ st->pdata->res[0], flags, "res1" },\r\n};\r\ngpio_free_array(ad2s1210_gpios, ARRAY_SIZE(ad2s1210_gpios));\r\n}\r\nstatic int __devinit ad2s1210_probe(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev;\r\nstruct ad2s1210_state *st;\r\nint ret;\r\nif (spi->dev.platform_data == NULL)\r\nreturn -EINVAL;\r\nindio_dev = iio_allocate_device(sizeof(*st));\r\nif (indio_dev == NULL) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\nst = iio_priv(indio_dev);\r\nst->pdata = spi->dev.platform_data;\r\nret = ad2s1210_setup_gpios(st);\r\nif (ret < 0)\r\ngoto error_free_dev;\r\nspi_set_drvdata(spi, indio_dev);\r\nmutex_init(&st->lock);\r\nst->sdev = spi;\r\nst->hysteresis = true;\r\nst->mode = MOD_CONFIG;\r\nst->resolution = 12;\r\nst->fexcit = AD2S1210_DEF_EXCIT;\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->info = &ad2s1210_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = ad2s1210_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(ad2s1210_channels);\r\nindio_dev->name = spi_get_device_id(spi)->name;\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_free_gpios;\r\nst->fclkin = spi->max_speed_hz;\r\nspi->mode = SPI_MODE_3;\r\nspi_setup(spi);\r\nad2s1210_initial(st);\r\nreturn 0;\r\nerror_free_gpios:\r\nad2s1210_free_gpios(st);\r\nerror_free_dev:\r\niio_free_device(indio_dev);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int __devexit ad2s1210_remove(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev = spi_get_drvdata(spi);\r\niio_device_unregister(indio_dev);\r\nad2s1210_free_gpios(iio_priv(indio_dev));\r\niio_free_device(indio_dev);\r\nreturn 0;\r\n}
