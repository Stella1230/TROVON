static int sil24_tag(int tag)\r\n{\r\nif (unlikely(ata_tag_internal(tag)))\r\nreturn 0;\r\nreturn tag;\r\n}\r\nstatic unsigned long sil24_port_offset(struct ata_port *ap)\r\n{\r\nreturn ap->port_no * PORT_REGS_SIZE;\r\n}\r\nstatic void __iomem *sil24_port_base(struct ata_port *ap)\r\n{\r\nreturn ap->host->iomap[SIL24_PORT_BAR] + sil24_port_offset(ap);\r\n}\r\nstatic void sil24_dev_config(struct ata_device *dev)\r\n{\r\nvoid __iomem *port = sil24_port_base(dev->link->ap);\r\nif (dev->cdb_len == 16)\r\nwritel(PORT_CS_CDB16, port + PORT_CTRL_STAT);\r\nelse\r\nwritel(PORT_CS_CDB16, port + PORT_CTRL_CLR);\r\n}\r\nstatic void sil24_read_tf(struct ata_port *ap, int tag, struct ata_taskfile *tf)\r\n{\r\nvoid __iomem *port = sil24_port_base(ap);\r\nstruct sil24_prb __iomem *prb;\r\nu8 fis[6 * 4];\r\nprb = port + PORT_LRAM + sil24_tag(tag) * PORT_LRAM_SLOT_SZ;\r\nmemcpy_fromio(fis, prb->fis, sizeof(fis));\r\nata_tf_from_fis(fis, tf);\r\n}\r\nstatic int sil24_scr_read(struct ata_link *link, unsigned sc_reg, u32 *val)\r\n{\r\nvoid __iomem *scr_addr = sil24_port_base(link->ap) + PORT_SCONTROL;\r\nif (sc_reg < ARRAY_SIZE(sil24_scr_map)) {\r\nvoid __iomem *addr;\r\naddr = scr_addr + sil24_scr_map[sc_reg] * 4;\r\n*val = readl(scr_addr + sil24_scr_map[sc_reg] * 4);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int sil24_scr_write(struct ata_link *link, unsigned sc_reg, u32 val)\r\n{\r\nvoid __iomem *scr_addr = sil24_port_base(link->ap) + PORT_SCONTROL;\r\nif (sc_reg < ARRAY_SIZE(sil24_scr_map)) {\r\nvoid __iomem *addr;\r\naddr = scr_addr + sil24_scr_map[sc_reg] * 4;\r\nwritel(val, scr_addr + sil24_scr_map[sc_reg] * 4);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void sil24_config_port(struct ata_port *ap)\r\n{\r\nvoid __iomem *port = sil24_port_base(ap);\r\nif (ap->flags & SIL24_FLAG_PCIX_IRQ_WOC)\r\nwritel(PORT_CS_IRQ_WOC, port + PORT_CTRL_STAT);\r\nelse\r\nwritel(PORT_CS_IRQ_WOC, port + PORT_CTRL_CLR);\r\nwritew(0x8000, port + PORT_DECODE_ERR_THRESH);\r\nwritew(0x8000, port + PORT_CRC_ERR_THRESH);\r\nwritew(0x8000, port + PORT_HSHK_ERR_THRESH);\r\nwritew(0x0000, port + PORT_DECODE_ERR_CNT);\r\nwritew(0x0000, port + PORT_CRC_ERR_CNT);\r\nwritew(0x0000, port + PORT_HSHK_ERR_CNT);\r\nwritel(PORT_CS_32BIT_ACTV, port + PORT_CTRL_CLR);\r\nwritel(PORT_CS_PMP_EN | PORT_CS_PMP_RESUME, port + PORT_CTRL_CLR);\r\n}\r\nstatic void sil24_config_pmp(struct ata_port *ap, int attached)\r\n{\r\nvoid __iomem *port = sil24_port_base(ap);\r\nif (attached)\r\nwritel(PORT_CS_PMP_EN, port + PORT_CTRL_STAT);\r\nelse\r\nwritel(PORT_CS_PMP_EN, port + PORT_CTRL_CLR);\r\n}\r\nstatic void sil24_clear_pmp(struct ata_port *ap)\r\n{\r\nvoid __iomem *port = sil24_port_base(ap);\r\nint i;\r\nwritel(PORT_CS_PMP_RESUME, port + PORT_CTRL_CLR);\r\nfor (i = 0; i < SATA_PMP_MAX_PORTS; i++) {\r\nvoid __iomem *pmp_base = port + PORT_PMP + i * PORT_PMP_SIZE;\r\nwritel(0, pmp_base + PORT_PMP_STATUS);\r\nwritel(0, pmp_base + PORT_PMP_QACTIVE);\r\n}\r\n}\r\nstatic int sil24_init_port(struct ata_port *ap)\r\n{\r\nvoid __iomem *port = sil24_port_base(ap);\r\nstruct sil24_port_priv *pp = ap->private_data;\r\nu32 tmp;\r\nif (sata_pmp_attached(ap))\r\nsil24_clear_pmp(ap);\r\nwritel(PORT_CS_INIT, port + PORT_CTRL_STAT);\r\nata_wait_register(ap, port + PORT_CTRL_STAT,\r\nPORT_CS_INIT, PORT_CS_INIT, 10, 100);\r\ntmp = ata_wait_register(ap, port + PORT_CTRL_STAT,\r\nPORT_CS_RDY, 0, 10, 100);\r\nif ((tmp & (PORT_CS_INIT | PORT_CS_RDY)) != PORT_CS_RDY) {\r\npp->do_port_rst = 1;\r\nap->link.eh_context.i.action |= ATA_EH_RESET;\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sil24_exec_polled_cmd(struct ata_port *ap, int pmp,\r\nconst struct ata_taskfile *tf,\r\nint is_cmd, u32 ctrl,\r\nunsigned long timeout_msec)\r\n{\r\nvoid __iomem *port = sil24_port_base(ap);\r\nstruct sil24_port_priv *pp = ap->private_data;\r\nstruct sil24_prb *prb = &pp->cmd_block[0].ata.prb;\r\ndma_addr_t paddr = pp->cmd_block_dma;\r\nu32 irq_enabled, irq_mask, irq_stat;\r\nint rc;\r\nprb->ctrl = cpu_to_le16(ctrl);\r\nata_tf_to_fis(tf, pmp, is_cmd, prb->fis);\r\nirq_enabled = readl(port + PORT_IRQ_ENABLE_SET);\r\nwritel(PORT_IRQ_COMPLETE | PORT_IRQ_ERROR, port + PORT_IRQ_ENABLE_CLR);\r\nwmb();\r\nwritel((u32)paddr, port + PORT_CMD_ACTIVATE);\r\nwritel((u64)paddr >> 32, port + PORT_CMD_ACTIVATE + 4);\r\nirq_mask = (PORT_IRQ_COMPLETE | PORT_IRQ_ERROR) << PORT_IRQ_RAW_SHIFT;\r\nirq_stat = ata_wait_register(ap, port + PORT_IRQ_STAT, irq_mask, 0x0,\r\n10, timeout_msec);\r\nwritel(irq_mask, port + PORT_IRQ_STAT);\r\nirq_stat >>= PORT_IRQ_RAW_SHIFT;\r\nif (irq_stat & PORT_IRQ_COMPLETE)\r\nrc = 0;\r\nelse {\r\nsil24_init_port(ap);\r\nif (irq_stat & PORT_IRQ_ERROR)\r\nrc = -EIO;\r\nelse\r\nrc = -EBUSY;\r\n}\r\nwritel(irq_enabled, port + PORT_IRQ_ENABLE_SET);\r\nreturn rc;\r\n}\r\nstatic int sil24_softreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nint pmp = sata_srst_pmp(link);\r\nunsigned long timeout_msec = 0;\r\nstruct ata_taskfile tf;\r\nconst char *reason;\r\nint rc;\r\nDPRINTK("ENTER\n");\r\nif (sil24_init_port(ap)) {\r\nreason = "port not ready";\r\ngoto err;\r\n}\r\nif (time_after(deadline, jiffies))\r\ntimeout_msec = jiffies_to_msecs(deadline - jiffies);\r\nata_tf_init(link->device, &tf);\r\nrc = sil24_exec_polled_cmd(ap, pmp, &tf, 0, PRB_CTRL_SRST,\r\ntimeout_msec);\r\nif (rc == -EBUSY) {\r\nreason = "timeout";\r\ngoto err;\r\n} else if (rc) {\r\nreason = "SRST command error";\r\ngoto err;\r\n}\r\nsil24_read_tf(ap, 0, &tf);\r\n*class = ata_dev_classify(&tf);\r\nDPRINTK("EXIT, class=%u\n", *class);\r\nreturn 0;\r\nerr:\r\nata_link_err(link, "softreset failed (%s)\n", reason);\r\nreturn -EIO;\r\n}\r\nstatic int sil24_hardreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nvoid __iomem *port = sil24_port_base(ap);\r\nstruct sil24_port_priv *pp = ap->private_data;\r\nint did_port_rst = 0;\r\nconst char *reason;\r\nint tout_msec, rc;\r\nu32 tmp;\r\nretry:\r\nif (pp->do_port_rst) {\r\nata_port_warn(ap,\r\n"controller in dubious state, performing PORT_RST\n");\r\nwritel(PORT_CS_PORT_RST, port + PORT_CTRL_STAT);\r\nata_msleep(ap, 10);\r\nwritel(PORT_CS_PORT_RST, port + PORT_CTRL_CLR);\r\nata_wait_register(ap, port + PORT_CTRL_STAT, PORT_CS_RDY, 0,\r\n10, 5000);\r\nsil24_config_port(ap);\r\nsil24_config_pmp(ap, ap->nr_pmp_links);\r\npp->do_port_rst = 0;\r\ndid_port_rst = 1;\r\n}\r\nsata_set_spd(link);\r\ntout_msec = 100;\r\nif (ata_link_online(link))\r\ntout_msec = 5000;\r\nwritel(PORT_CS_DEV_RST, port + PORT_CTRL_STAT);\r\ntmp = ata_wait_register(ap, port + PORT_CTRL_STAT,\r\nPORT_CS_DEV_RST, PORT_CS_DEV_RST, 10,\r\ntout_msec);\r\nrc = sata_link_debounce(link, sata_deb_timing_long, deadline);\r\nif (rc) {\r\nreason = "PHY debouncing failed";\r\ngoto err;\r\n}\r\nif (tmp & PORT_CS_DEV_RST) {\r\nif (ata_link_offline(link))\r\nreturn 0;\r\nreason = "link not ready";\r\ngoto err;\r\n}\r\nreturn -EAGAIN;\r\nerr:\r\nif (!did_port_rst) {\r\npp->do_port_rst = 1;\r\ngoto retry;\r\n}\r\nata_link_err(link, "hardreset failed (%s)\n", reason);\r\nreturn -EIO;\r\n}\r\nstatic inline void sil24_fill_sg(struct ata_queued_cmd *qc,\r\nstruct sil24_sge *sge)\r\n{\r\nstruct scatterlist *sg;\r\nstruct sil24_sge *last_sge = NULL;\r\nunsigned int si;\r\nfor_each_sg(qc->sg, sg, qc->n_elem, si) {\r\nsge->addr = cpu_to_le64(sg_dma_address(sg));\r\nsge->cnt = cpu_to_le32(sg_dma_len(sg));\r\nsge->flags = 0;\r\nlast_sge = sge;\r\nsge++;\r\n}\r\nlast_sge->flags = cpu_to_le32(SGE_TRM);\r\n}\r\nstatic int sil24_qc_defer(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_link *link = qc->dev->link;\r\nstruct ata_port *ap = link->ap;\r\nu8 prot = qc->tf.protocol;\r\nint is_excl = (ata_is_atapi(prot) ||\r\n(qc->flags & ATA_QCFLAG_RESULT_TF));\r\nif (unlikely(ap->excl_link)) {\r\nif (link == ap->excl_link) {\r\nif (ap->nr_active_links)\r\nreturn ATA_DEFER_PORT;\r\nqc->flags |= ATA_QCFLAG_CLEAR_EXCL;\r\n} else\r\nreturn ATA_DEFER_PORT;\r\n} else if (unlikely(is_excl)) {\r\nap->excl_link = link;\r\nif (ap->nr_active_links)\r\nreturn ATA_DEFER_PORT;\r\nqc->flags |= ATA_QCFLAG_CLEAR_EXCL;\r\n}\r\nreturn ata_std_qc_defer(qc);\r\n}\r\nstatic void sil24_qc_prep(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct sil24_port_priv *pp = ap->private_data;\r\nunion sil24_cmd_block *cb;\r\nstruct sil24_prb *prb;\r\nstruct sil24_sge *sge;\r\nu16 ctrl = 0;\r\ncb = &pp->cmd_block[sil24_tag(qc->tag)];\r\nif (!ata_is_atapi(qc->tf.protocol)) {\r\nprb = &cb->ata.prb;\r\nsge = cb->ata.sge;\r\nif (ata_is_data(qc->tf.protocol)) {\r\nu16 prot = 0;\r\nctrl = PRB_CTRL_PROTOCOL;\r\nif (ata_is_ncq(qc->tf.protocol))\r\nprot |= PRB_PROT_NCQ;\r\nif (qc->tf.flags & ATA_TFLAG_WRITE)\r\nprot |= PRB_PROT_WRITE;\r\nelse\r\nprot |= PRB_PROT_READ;\r\nprb->prot = cpu_to_le16(prot);\r\n}\r\n} else {\r\nprb = &cb->atapi.prb;\r\nsge = cb->atapi.sge;\r\nmemset(cb->atapi.cdb, 0, sizeof(cb->atapi.cdb));\r\nmemcpy(cb->atapi.cdb, qc->cdb, qc->dev->cdb_len);\r\nif (ata_is_data(qc->tf.protocol)) {\r\nif (qc->tf.flags & ATA_TFLAG_WRITE)\r\nctrl = PRB_CTRL_PACKET_WRITE;\r\nelse\r\nctrl = PRB_CTRL_PACKET_READ;\r\n}\r\n}\r\nprb->ctrl = cpu_to_le16(ctrl);\r\nata_tf_to_fis(&qc->tf, qc->dev->link->pmp, 1, prb->fis);\r\nif (qc->flags & ATA_QCFLAG_DMAMAP)\r\nsil24_fill_sg(qc, sge);\r\n}\r\nstatic unsigned int sil24_qc_issue(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct sil24_port_priv *pp = ap->private_data;\r\nvoid __iomem *port = sil24_port_base(ap);\r\nunsigned int tag = sil24_tag(qc->tag);\r\ndma_addr_t paddr;\r\nvoid __iomem *activate;\r\npaddr = pp->cmd_block_dma + tag * sizeof(*pp->cmd_block);\r\nactivate = port + PORT_CMD_ACTIVATE + tag * 8;\r\nwmb();\r\nwritel((u32)paddr, activate);\r\nwritel((u64)paddr >> 32, activate + 4);\r\nreturn 0;\r\n}\r\nstatic bool sil24_qc_fill_rtf(struct ata_queued_cmd *qc)\r\n{\r\nsil24_read_tf(qc->ap, qc->tag, &qc->result_tf);\r\nreturn true;\r\n}\r\nstatic void sil24_pmp_attach(struct ata_port *ap)\r\n{\r\nu32 *gscr = ap->link.device->gscr;\r\nsil24_config_pmp(ap, 1);\r\nsil24_init_port(ap);\r\nif (sata_pmp_gscr_vendor(gscr) == 0x11ab &&\r\nsata_pmp_gscr_devid(gscr) == 0x4140) {\r\nata_port_info(ap,\r\n"disabling NCQ support due to sil24-mv4140 quirk\n");\r\nap->flags &= ~ATA_FLAG_NCQ;\r\n}\r\n}\r\nstatic void sil24_pmp_detach(struct ata_port *ap)\r\n{\r\nsil24_init_port(ap);\r\nsil24_config_pmp(ap, 0);\r\nap->flags |= ATA_FLAG_NCQ;\r\n}\r\nstatic int sil24_pmp_hardreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nint rc;\r\nrc = sil24_init_port(link->ap);\r\nif (rc) {\r\nata_link_err(link, "hardreset failed (port not ready)\n");\r\nreturn rc;\r\n}\r\nreturn sata_std_hardreset(link, class, deadline);\r\n}\r\nstatic void sil24_freeze(struct ata_port *ap)\r\n{\r\nvoid __iomem *port = sil24_port_base(ap);\r\nwritel(0xffff, port + PORT_IRQ_ENABLE_CLR);\r\n}\r\nstatic void sil24_thaw(struct ata_port *ap)\r\n{\r\nvoid __iomem *port = sil24_port_base(ap);\r\nu32 tmp;\r\ntmp = readl(port + PORT_IRQ_STAT);\r\nwritel(tmp, port + PORT_IRQ_STAT);\r\nwritel(DEF_PORT_IRQ, port + PORT_IRQ_ENABLE_SET);\r\n}\r\nstatic void sil24_error_intr(struct ata_port *ap)\r\n{\r\nvoid __iomem *port = sil24_port_base(ap);\r\nstruct sil24_port_priv *pp = ap->private_data;\r\nstruct ata_queued_cmd *qc = NULL;\r\nstruct ata_link *link;\r\nstruct ata_eh_info *ehi;\r\nint abort = 0, freeze = 0;\r\nu32 irq_stat;\r\nirq_stat = readl(port + PORT_IRQ_STAT);\r\nwritel(irq_stat, port + PORT_IRQ_STAT);\r\nlink = &ap->link;\r\nehi = &link->eh_info;\r\nata_ehi_clear_desc(ehi);\r\nata_ehi_push_desc(ehi, "irq_stat 0x%08x", irq_stat);\r\nif (irq_stat & PORT_IRQ_SDB_NOTIFY) {\r\nata_ehi_push_desc(ehi, "SDB notify");\r\nsata_async_notification(ap);\r\n}\r\nif (irq_stat & (PORT_IRQ_PHYRDY_CHG | PORT_IRQ_DEV_XCHG)) {\r\nata_ehi_hotplugged(ehi);\r\nata_ehi_push_desc(ehi, "%s",\r\nirq_stat & PORT_IRQ_PHYRDY_CHG ?\r\n"PHY RDY changed" : "device exchanged");\r\nfreeze = 1;\r\n}\r\nif (irq_stat & PORT_IRQ_UNK_FIS) {\r\nehi->err_mask |= AC_ERR_HSM;\r\nehi->action |= ATA_EH_RESET;\r\nata_ehi_push_desc(ehi, "unknown FIS");\r\nfreeze = 1;\r\n}\r\nif (irq_stat & PORT_IRQ_ERROR) {\r\nconst struct sil24_cerr_info *ci = NULL;\r\nunsigned int err_mask = 0, action = 0;\r\nu32 context, cerr;\r\nint pmp;\r\nabort = 1;\r\nif (ap->nr_active_links >= 3) {\r\nehi->err_mask |= AC_ERR_OTHER;\r\nehi->action |= ATA_EH_RESET;\r\nata_ehi_push_desc(ehi, "PMP DMA CS errata");\r\npp->do_port_rst = 1;\r\nfreeze = 1;\r\n}\r\nif (sata_pmp_attached(ap)) {\r\ncontext = readl(port + PORT_CONTEXT);\r\npmp = (context >> 5) & 0xf;\r\nif (pmp < ap->nr_pmp_links) {\r\nlink = &ap->pmp_link[pmp];\r\nehi = &link->eh_info;\r\nqc = ata_qc_from_tag(ap, link->active_tag);\r\nata_ehi_clear_desc(ehi);\r\nata_ehi_push_desc(ehi, "irq_stat 0x%08x",\r\nirq_stat);\r\n} else {\r\nerr_mask |= AC_ERR_HSM;\r\naction |= ATA_EH_RESET;\r\nfreeze = 1;\r\n}\r\n} else\r\nqc = ata_qc_from_tag(ap, link->active_tag);\r\ncerr = readl(port + PORT_CMD_ERR);\r\nif (cerr < ARRAY_SIZE(sil24_cerr_db))\r\nci = &sil24_cerr_db[cerr];\r\nif (ci && ci->desc) {\r\nerr_mask |= ci->err_mask;\r\naction |= ci->action;\r\nif (action & ATA_EH_RESET)\r\nfreeze = 1;\r\nata_ehi_push_desc(ehi, "%s", ci->desc);\r\n} else {\r\nerr_mask |= AC_ERR_OTHER;\r\naction |= ATA_EH_RESET;\r\nfreeze = 1;\r\nata_ehi_push_desc(ehi, "unknown command error %d",\r\ncerr);\r\n}\r\nif (qc)\r\nqc->err_mask |= err_mask;\r\nelse\r\nehi->err_mask |= err_mask;\r\nehi->action |= action;\r\nif (sata_pmp_attached(ap))\r\nwritel(PORT_CS_PMP_RESUME, port + PORT_CTRL_STAT);\r\n}\r\nif (freeze)\r\nata_port_freeze(ap);\r\nelse if (abort) {\r\nif (qc)\r\nata_link_abort(qc->dev->link);\r\nelse\r\nata_port_abort(ap);\r\n}\r\n}\r\nstatic inline void sil24_host_intr(struct ata_port *ap)\r\n{\r\nvoid __iomem *port = sil24_port_base(ap);\r\nu32 slot_stat, qc_active;\r\nint rc;\r\nif (ap->flags & SIL24_FLAG_PCIX_IRQ_WOC)\r\nwritel(PORT_IRQ_COMPLETE, port + PORT_IRQ_STAT);\r\nslot_stat = readl(port + PORT_SLOT_STAT);\r\nif (unlikely(slot_stat & HOST_SSTAT_ATTN)) {\r\nsil24_error_intr(ap);\r\nreturn;\r\n}\r\nqc_active = slot_stat & ~HOST_SSTAT_ATTN;\r\nrc = ata_qc_complete_multiple(ap, qc_active);\r\nif (rc > 0)\r\nreturn;\r\nif (rc < 0) {\r\nstruct ata_eh_info *ehi = &ap->link.eh_info;\r\nehi->err_mask |= AC_ERR_HSM;\r\nehi->action |= ATA_EH_RESET;\r\nata_port_freeze(ap);\r\nreturn;\r\n}\r\nif (!(ap->flags & SIL24_FLAG_PCIX_IRQ_WOC) && ata_ratelimit())\r\nata_port_info(ap,\r\n"spurious interrupt (slot_stat 0x%x active_tag %d sactive 0x%x)\n",\r\nslot_stat, ap->link.active_tag, ap->link.sactive);\r\n}\r\nstatic irqreturn_t sil24_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct ata_host *host = dev_instance;\r\nvoid __iomem *host_base = host->iomap[SIL24_HOST_BAR];\r\nunsigned handled = 0;\r\nu32 status;\r\nint i;\r\nstatus = readl(host_base + HOST_IRQ_STAT);\r\nif (status == 0xffffffff) {\r\nprintk(KERN_ERR DRV_NAME ": IRQ status == 0xffffffff, "\r\n"PCI fault or device removal?\n");\r\ngoto out;\r\n}\r\nif (!(status & IRQ_STAT_4PORTS))\r\ngoto out;\r\nspin_lock(&host->lock);\r\nfor (i = 0; i < host->n_ports; i++)\r\nif (status & (1 << i)) {\r\nsil24_host_intr(host->ports[i]);\r\nhandled++;\r\n}\r\nspin_unlock(&host->lock);\r\nout:\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void sil24_error_handler(struct ata_port *ap)\r\n{\r\nstruct sil24_port_priv *pp = ap->private_data;\r\nif (sil24_init_port(ap))\r\nata_eh_freeze_port(ap);\r\nsata_pmp_error_handler(ap);\r\npp->do_port_rst = 0;\r\n}\r\nstatic void sil24_post_internal_cmd(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nif ((qc->flags & ATA_QCFLAG_FAILED) && sil24_init_port(ap))\r\nata_eh_freeze_port(ap);\r\n}\r\nstatic int sil24_port_start(struct ata_port *ap)\r\n{\r\nstruct device *dev = ap->host->dev;\r\nstruct sil24_port_priv *pp;\r\nunion sil24_cmd_block *cb;\r\nsize_t cb_size = sizeof(*cb) * SIL24_MAX_CMDS;\r\ndma_addr_t cb_dma;\r\npp = devm_kzalloc(dev, sizeof(*pp), GFP_KERNEL);\r\nif (!pp)\r\nreturn -ENOMEM;\r\ncb = dmam_alloc_coherent(dev, cb_size, &cb_dma, GFP_KERNEL);\r\nif (!cb)\r\nreturn -ENOMEM;\r\nmemset(cb, 0, cb_size);\r\npp->cmd_block = cb;\r\npp->cmd_block_dma = cb_dma;\r\nap->private_data = pp;\r\nata_port_pbar_desc(ap, SIL24_HOST_BAR, -1, "host");\r\nata_port_pbar_desc(ap, SIL24_PORT_BAR, sil24_port_offset(ap), "port");\r\nreturn 0;\r\n}\r\nstatic void sil24_init_controller(struct ata_host *host)\r\n{\r\nvoid __iomem *host_base = host->iomap[SIL24_HOST_BAR];\r\nu32 tmp;\r\nint i;\r\nwritel(0, host_base + HOST_FLASH_CMD);\r\nwritel(0, host_base + HOST_CTRL);\r\nfor (i = 0; i < host->n_ports; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nvoid __iomem *port = sil24_port_base(ap);\r\nwritel(0x20c, port + PORT_PHY_CFG);\r\ntmp = readl(port + PORT_CTRL_STAT);\r\nif (tmp & PORT_CS_PORT_RST) {\r\nwritel(PORT_CS_PORT_RST, port + PORT_CTRL_CLR);\r\ntmp = ata_wait_register(NULL, port + PORT_CTRL_STAT,\r\nPORT_CS_PORT_RST,\r\nPORT_CS_PORT_RST, 10, 100);\r\nif (tmp & PORT_CS_PORT_RST)\r\ndev_err(host->dev,\r\n"failed to clear port RST\n");\r\n}\r\nsil24_config_port(ap);\r\n}\r\nwritel(IRQ_STAT_4PORTS, host_base + HOST_CTRL);\r\n}\r\nstatic int sil24_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nextern int __MARKER__sil24_cmd_block_is_sized_wrongly;\r\nstruct ata_port_info pi = sil24_port_info[ent->driver_data];\r\nconst struct ata_port_info *ppi[] = { &pi, NULL };\r\nvoid __iomem * const *iomap;\r\nstruct ata_host *host;\r\nint rc;\r\nu32 tmp;\r\nif (sizeof(union sil24_cmd_block) != PAGE_SIZE)\r\n__MARKER__sil24_cmd_block_is_sized_wrongly = 1;\r\nata_print_version_once(&pdev->dev, DRV_VERSION);\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nrc = pcim_iomap_regions(pdev,\r\n(1 << SIL24_HOST_BAR) | (1 << SIL24_PORT_BAR),\r\nDRV_NAME);\r\nif (rc)\r\nreturn rc;\r\niomap = pcim_iomap_table(pdev);\r\nif (pi.flags & SIL24_FLAG_PCIX_IRQ_WOC) {\r\ntmp = readl(iomap[SIL24_HOST_BAR] + HOST_CTRL);\r\nif (tmp & (HOST_CTRL_TRDY | HOST_CTRL_STOP | HOST_CTRL_DEVSEL))\r\ndev_info(&pdev->dev,\r\n"Applying completion IRQ loss on PCI-X errata fix\n");\r\nelse\r\npi.flags &= ~SIL24_FLAG_PCIX_IRQ_WOC;\r\n}\r\nhost = ata_host_alloc_pinfo(&pdev->dev, ppi,\r\nSIL24_FLAG2NPORTS(ppi[0]->flags));\r\nif (!host)\r\nreturn -ENOMEM;\r\nhost->iomap = iomap;\r\nif (!pci_set_dma_mask(pdev, DMA_BIT_MASK(64))) {\r\nrc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (rc) {\r\nrc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_err(&pdev->dev,\r\n"64-bit DMA enable failed\n");\r\nreturn rc;\r\n}\r\n}\r\n} else {\r\nrc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_err(&pdev->dev, "32-bit DMA enable failed\n");\r\nreturn rc;\r\n}\r\nrc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_err(&pdev->dev,\r\n"32-bit consistent DMA enable failed\n");\r\nreturn rc;\r\n}\r\n}\r\npcie_set_readrq(pdev, 4096);\r\nsil24_init_controller(host);\r\nif (sata_sil24_msi && !pci_enable_msi(pdev)) {\r\ndev_info(&pdev->dev, "Using MSI\n");\r\npci_intx(pdev, 0);\r\n}\r\npci_set_master(pdev);\r\nreturn ata_host_activate(host, pdev->irq, sil24_interrupt, IRQF_SHARED,\r\n&sil24_sht);\r\n}\r\nstatic int sil24_pci_device_resume(struct pci_dev *pdev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(&pdev->dev);\r\nvoid __iomem *host_base = host->iomap[SIL24_HOST_BAR];\r\nint rc;\r\nrc = ata_pci_device_do_resume(pdev);\r\nif (rc)\r\nreturn rc;\r\nif (pdev->dev.power.power_state.event == PM_EVENT_SUSPEND)\r\nwritel(HOST_CTRL_GLOBAL_RST, host_base + HOST_CTRL);\r\nsil24_init_controller(host);\r\nata_host_resume(host);\r\nreturn 0;\r\n}\r\nstatic int sil24_port_resume(struct ata_port *ap)\r\n{\r\nsil24_config_pmp(ap, ap->nr_pmp_links);\r\nreturn 0;\r\n}\r\nstatic int __init sil24_init(void)\r\n{\r\nreturn pci_register_driver(&sil24_pci_driver);\r\n}\r\nstatic void __exit sil24_exit(void)\r\n{\r\npci_unregister_driver(&sil24_pci_driver);\r\n}
