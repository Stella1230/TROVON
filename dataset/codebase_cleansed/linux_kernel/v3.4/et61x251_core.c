static u32\r\net61x251_request_buffers(struct et61x251_device* cam, u32 count,\r\nenum et61x251_io_method io)\r\n{\r\nstruct v4l2_pix_format* p = &(cam->sensor.pix_format);\r\nstruct v4l2_rect* r = &(cam->sensor.cropcap.bounds);\r\nconst size_t imagesize = cam->module_param.force_munmap ||\r\nio == IO_READ ?\r\n(p->width * p->height * p->priv) / 8 :\r\n(r->width * r->height * p->priv) / 8;\r\nvoid* buff = NULL;\r\nu32 i;\r\nif (count > ET61X251_MAX_FRAMES)\r\ncount = ET61X251_MAX_FRAMES;\r\ncam->nbuffers = count;\r\nwhile (cam->nbuffers > 0) {\r\nif ((buff = vmalloc_32_user(cam->nbuffers *\r\nPAGE_ALIGN(imagesize))))\r\nbreak;\r\ncam->nbuffers--;\r\n}\r\nfor (i = 0; i < cam->nbuffers; i++) {\r\ncam->frame[i].bufmem = buff + i*PAGE_ALIGN(imagesize);\r\ncam->frame[i].buf.index = i;\r\ncam->frame[i].buf.m.offset = i*PAGE_ALIGN(imagesize);\r\ncam->frame[i].buf.length = imagesize;\r\ncam->frame[i].buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ncam->frame[i].buf.sequence = 0;\r\ncam->frame[i].buf.field = V4L2_FIELD_NONE;\r\ncam->frame[i].buf.memory = V4L2_MEMORY_MMAP;\r\ncam->frame[i].buf.flags = 0;\r\n}\r\nreturn cam->nbuffers;\r\n}\r\nstatic void et61x251_release_buffers(struct et61x251_device* cam)\r\n{\r\nif (cam->nbuffers) {\r\nvfree(cam->frame[0].bufmem);\r\ncam->nbuffers = 0;\r\n}\r\ncam->frame_current = NULL;\r\n}\r\nstatic void et61x251_empty_framequeues(struct et61x251_device* cam)\r\n{\r\nu32 i;\r\nINIT_LIST_HEAD(&cam->inqueue);\r\nINIT_LIST_HEAD(&cam->outqueue);\r\nfor (i = 0; i < ET61X251_MAX_FRAMES; i++) {\r\ncam->frame[i].state = F_UNUSED;\r\ncam->frame[i].buf.bytesused = 0;\r\n}\r\n}\r\nstatic void et61x251_requeue_outqueue(struct et61x251_device* cam)\r\n{\r\nstruct et61x251_frame_t *i;\r\nlist_for_each_entry(i, &cam->outqueue, frame) {\r\ni->state = F_QUEUED;\r\nlist_add(&i->frame, &cam->inqueue);\r\n}\r\nINIT_LIST_HEAD(&cam->outqueue);\r\n}\r\nstatic void et61x251_queue_unusedframes(struct et61x251_device* cam)\r\n{\r\nunsigned long lock_flags;\r\nu32 i;\r\nfor (i = 0; i < cam->nbuffers; i++)\r\nif (cam->frame[i].state == F_UNUSED) {\r\ncam->frame[i].state = F_QUEUED;\r\nspin_lock_irqsave(&cam->queue_lock, lock_flags);\r\nlist_add_tail(&cam->frame[i].frame, &cam->inqueue);\r\nspin_unlock_irqrestore(&cam->queue_lock, lock_flags);\r\n}\r\n}\r\nint et61x251_write_reg(struct et61x251_device* cam, u8 value, u16 index)\r\n{\r\nstruct usb_device* udev = cam->usbdev;\r\nu8* buff = cam->control_buffer;\r\nint res;\r\n*buff = value;\r\nres = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x00, 0x41,\r\n0, index, buff, 1, ET61X251_CTRL_TIMEOUT);\r\nif (res < 0) {\r\nDBG(3, "Failed to write a register (value 0x%02X, index "\r\n"0x%02X, error %d)", value, index, res);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int et61x251_read_reg(struct et61x251_device* cam, u16 index)\r\n{\r\nstruct usb_device* udev = cam->usbdev;\r\nu8* buff = cam->control_buffer;\r\nint res;\r\nres = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), 0x00, 0xc1,\r\n0, index, buff, 1, ET61X251_CTRL_TIMEOUT);\r\nif (res < 0)\r\nDBG(3, "Failed to read a register (index 0x%02X, error %d)",\r\nindex, res);\r\nreturn (res >= 0) ? (int)(*buff) : -1;\r\n}\r\nstatic int\r\net61x251_i2c_wait(struct et61x251_device* cam,\r\nconst struct et61x251_sensor* sensor)\r\n{\r\nint i, r;\r\nfor (i = 1; i <= 8; i++) {\r\nif (sensor->interface == ET61X251_I2C_3WIRES) {\r\nr = et61x251_read_reg(cam, 0x8e);\r\nif (!(r & 0x02) && (r >= 0))\r\nreturn 0;\r\n} else {\r\nr = et61x251_read_reg(cam, 0x8b);\r\nif (!(r & 0x01) && (r >= 0))\r\nreturn 0;\r\n}\r\nif (r < 0)\r\nreturn -EIO;\r\nudelay(8*8);\r\n}\r\nreturn -EBUSY;\r\n}\r\nint\r\net61x251_i2c_raw_write(struct et61x251_device* cam, u8 n, u8 data1, u8 data2,\r\nu8 data3, u8 data4, u8 data5, u8 data6, u8 data7,\r\nu8 data8, u8 address)\r\n{\r\nstruct usb_device* udev = cam->usbdev;\r\nu8* data = cam->control_buffer;\r\nint err = 0, res;\r\ndata[0] = data2;\r\ndata[1] = data3;\r\ndata[2] = data4;\r\ndata[3] = data5;\r\ndata[4] = data6;\r\ndata[5] = data7;\r\ndata[6] = data8;\r\nres = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x00, 0x41,\r\n0, 0x81, data, n-1, ET61X251_CTRL_TIMEOUT);\r\nif (res < 0)\r\nerr += res;\r\ndata[0] = address;\r\ndata[1] = cam->sensor.i2c_slave_id;\r\ndata[2] = cam->sensor.rsta | 0x02 | (n << 4);\r\nres = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x00, 0x41,\r\n0, 0x88, data, 3, ET61X251_CTRL_TIMEOUT);\r\nif (res < 0)\r\nerr += res;\r\ndata[0] = data1;\r\nres = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x00, 0x41,\r\n0, 0x80, data, 1, ET61X251_CTRL_TIMEOUT);\r\nif (res < 0)\r\nerr += res;\r\nerr += et61x251_i2c_wait(cam, &cam->sensor);\r\nif (err)\r\nDBG(3, "I2C raw write failed for %s image sensor",\r\ncam->sensor.name);\r\nPDBGG("I2C raw write: %u bytes, address = 0x%02X, data1 = 0x%02X, "\r\n"data2 = 0x%02X, data3 = 0x%02X, data4 = 0x%02X, data5 = 0x%02X,"\r\n" data6 = 0x%02X, data7 = 0x%02X, data8 = 0x%02X", n, address,\r\ndata1, data2, data3, data4, data5, data6, data7, data8);\r\nreturn err ? -1 : 0;\r\n}\r\nstatic void et61x251_urb_complete(struct urb *urb)\r\n{\r\nstruct et61x251_device* cam = urb->context;\r\nstruct et61x251_frame_t** f;\r\nsize_t imagesize;\r\nu8 i;\r\nint err = 0;\r\nif (urb->status == -ENOENT)\r\nreturn;\r\nf = &cam->frame_current;\r\nif (cam->stream == STREAM_INTERRUPT) {\r\ncam->stream = STREAM_OFF;\r\nif ((*f))\r\n(*f)->state = F_QUEUED;\r\nDBG(3, "Stream interrupted");\r\nwake_up(&cam->wait_stream);\r\n}\r\nif (cam->state & DEV_DISCONNECTED)\r\nreturn;\r\nif (cam->state & DEV_MISCONFIGURED) {\r\nwake_up_interruptible(&cam->wait_frame);\r\nreturn;\r\n}\r\nif (cam->stream == STREAM_OFF || list_empty(&cam->inqueue))\r\ngoto resubmit_urb;\r\nif (!(*f))\r\n(*f) = list_entry(cam->inqueue.next, struct et61x251_frame_t,\r\nframe);\r\nimagesize = (cam->sensor.pix_format.width *\r\ncam->sensor.pix_format.height *\r\ncam->sensor.pix_format.priv) / 8;\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nunsigned int len, status;\r\nvoid *pos;\r\nu8* b1, * b2, sof;\r\nconst u8 VOID_BYTES = 6;\r\nsize_t imglen;\r\nlen = urb->iso_frame_desc[i].actual_length;\r\nstatus = urb->iso_frame_desc[i].status;\r\npos = urb->iso_frame_desc[i].offset + urb->transfer_buffer;\r\nif (status) {\r\nDBG(3, "Error in isochronous frame");\r\n(*f)->state = F_ERROR;\r\ncontinue;\r\n}\r\nb1 = pos++;\r\nb2 = pos++;\r\nsof = ((*b1 & 0x3f) == 63);\r\nimglen = ((*b1 & 0xc0) << 2) | *b2;\r\nPDBGG("Isochrnous frame: length %u, #%u i, image length %zu",\r\nlen, i, imglen);\r\nif ((*f)->state == F_QUEUED || (*f)->state == F_ERROR)\r\nstart_of_frame:\r\nif (sof) {\r\n(*f)->state = F_GRABBING;\r\n(*f)->buf.bytesused = 0;\r\ndo_gettimeofday(&(*f)->buf.timestamp);\r\npos += 22;\r\nDBG(3, "SOF detected: new video frame");\r\n}\r\nif ((*f)->state == F_GRABBING) {\r\nif (sof && (*f)->buf.bytesused) {\r\nif (cam->sensor.pix_format.pixelformat ==\r\nV4L2_PIX_FMT_ET61X251)\r\ngoto end_of_frame;\r\nelse {\r\nDBG(3, "Not expected SOF detected "\r\n"after %lu bytes",\r\n(unsigned long)(*f)->buf.bytesused);\r\n(*f)->state = F_ERROR;\r\ncontinue;\r\n}\r\n}\r\nif ((*f)->buf.bytesused + imglen > imagesize) {\r\nDBG(3, "Video frame size exceeded");\r\n(*f)->state = F_ERROR;\r\ncontinue;\r\n}\r\npos += VOID_BYTES;\r\nmemcpy((*f)->bufmem+(*f)->buf.bytesused, pos, imglen);\r\n(*f)->buf.bytesused += imglen;\r\nif ((*f)->buf.bytesused == imagesize) {\r\nu32 b;\r\nend_of_frame:\r\nb = (*f)->buf.bytesused;\r\n(*f)->state = F_DONE;\r\n(*f)->buf.sequence= ++cam->frame_count;\r\nspin_lock(&cam->queue_lock);\r\nlist_move_tail(&(*f)->frame, &cam->outqueue);\r\nif (!list_empty(&cam->inqueue))\r\n(*f) = list_entry(cam->inqueue.next,\r\nstruct et61x251_frame_t,\r\nframe);\r\nelse\r\n(*f) = NULL;\r\nspin_unlock(&cam->queue_lock);\r\nDBG(3, "Video frame captured: : %lu bytes",\r\n(unsigned long)(b));\r\nif (!(*f))\r\ngoto resubmit_urb;\r\nif (sof &&\r\ncam->sensor.pix_format.pixelformat ==\r\nV4L2_PIX_FMT_ET61X251)\r\ngoto start_of_frame;\r\n}\r\n}\r\n}\r\nresubmit_urb:\r\nurb->dev = cam->usbdev;\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err < 0 && err != -EPERM) {\r\ncam->state |= DEV_MISCONFIGURED;\r\nDBG(1, "usb_submit_urb() failed");\r\n}\r\nwake_up_interruptible(&cam->wait_frame);\r\n}\r\nstatic int et61x251_start_transfer(struct et61x251_device* cam)\r\n{\r\nstruct usb_device *udev = cam->usbdev;\r\nstruct urb* urb;\r\nstruct usb_host_interface* altsetting = usb_altnum_to_altsetting(\r\nusb_ifnum_to_if(udev, 0),\r\nET61X251_ALTERNATE_SETTING);\r\nconst unsigned int psz = le16_to_cpu(altsetting->\r\nendpoint[0].desc.wMaxPacketSize);\r\ns8 i, j;\r\nint err = 0;\r\nfor (i = 0; i < ET61X251_URBS; i++) {\r\ncam->transfer_buffer[i] = kzalloc(ET61X251_ISO_PACKETS * psz,\r\nGFP_KERNEL);\r\nif (!cam->transfer_buffer[i]) {\r\nerr = -ENOMEM;\r\nDBG(1, "Not enough memory");\r\ngoto free_buffers;\r\n}\r\n}\r\nfor (i = 0; i < ET61X251_URBS; i++) {\r\nurb = usb_alloc_urb(ET61X251_ISO_PACKETS, GFP_KERNEL);\r\ncam->urb[i] = urb;\r\nif (!urb) {\r\nerr = -ENOMEM;\r\nDBG(1, "usb_alloc_urb() failed");\r\ngoto free_urbs;\r\n}\r\nurb->dev = udev;\r\nurb->context = cam;\r\nurb->pipe = usb_rcvisocpipe(udev, 1);\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nurb->number_of_packets = ET61X251_ISO_PACKETS;\r\nurb->complete = et61x251_urb_complete;\r\nurb->transfer_buffer = cam->transfer_buffer[i];\r\nurb->transfer_buffer_length = psz * ET61X251_ISO_PACKETS;\r\nurb->interval = 1;\r\nfor (j = 0; j < ET61X251_ISO_PACKETS; j++) {\r\nurb->iso_frame_desc[j].offset = psz * j;\r\nurb->iso_frame_desc[j].length = psz;\r\n}\r\n}\r\nerr = et61x251_write_reg(cam, 0x01, 0x03);\r\nerr = et61x251_write_reg(cam, 0x00, 0x03);\r\nerr = et61x251_write_reg(cam, 0x08, 0x03);\r\nif (err) {\r\nerr = -EIO;\r\nDBG(1, "I/O hardware error");\r\ngoto free_urbs;\r\n}\r\nerr = usb_set_interface(udev, 0, ET61X251_ALTERNATE_SETTING);\r\nif (err) {\r\nDBG(1, "usb_set_interface() failed");\r\ngoto free_urbs;\r\n}\r\ncam->frame_current = NULL;\r\nfor (i = 0; i < ET61X251_URBS; i++) {\r\nerr = usb_submit_urb(cam->urb[i], GFP_KERNEL);\r\nif (err) {\r\nfor (j = i-1; j >= 0; j--)\r\nusb_kill_urb(cam->urb[j]);\r\nDBG(1, "usb_submit_urb() failed, error %d", err);\r\ngoto free_urbs;\r\n}\r\n}\r\nreturn 0;\r\nfree_urbs:\r\nfor (i = 0; (i < ET61X251_URBS) && cam->urb[i]; i++)\r\nusb_free_urb(cam->urb[i]);\r\nfree_buffers:\r\nfor (i = 0; (i < ET61X251_URBS) && cam->transfer_buffer[i]; i++)\r\nkfree(cam->transfer_buffer[i]);\r\nreturn err;\r\n}\r\nstatic int et61x251_stop_transfer(struct et61x251_device* cam)\r\n{\r\nstruct usb_device *udev = cam->usbdev;\r\ns8 i;\r\nint err = 0;\r\nif (cam->state & DEV_DISCONNECTED)\r\nreturn 0;\r\nfor (i = ET61X251_URBS-1; i >= 0; i--) {\r\nusb_kill_urb(cam->urb[i]);\r\nusb_free_urb(cam->urb[i]);\r\nkfree(cam->transfer_buffer[i]);\r\n}\r\nerr = usb_set_interface(udev, 0, 0);\r\nif (err)\r\nDBG(3, "usb_set_interface() failed");\r\nreturn err;\r\n}\r\nstatic int et61x251_stream_interrupt(struct et61x251_device* cam)\r\n{\r\nlong timeout;\r\ncam->stream = STREAM_INTERRUPT;\r\ntimeout = wait_event_timeout(cam->wait_stream,\r\n(cam->stream == STREAM_OFF) ||\r\n(cam->state & DEV_DISCONNECTED),\r\nET61X251_URB_TIMEOUT);\r\nif (cam->state & DEV_DISCONNECTED)\r\nreturn -ENODEV;\r\nelse if (cam->stream != STREAM_OFF) {\r\ncam->state |= DEV_MISCONFIGURED;\r\nDBG(1, "URB timeout reached. The camera is misconfigured. To "\r\n"use it, close and open %s again.",\r\nvideo_device_node_name(cam->v4ldev));\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int et61x251_i2c_try_read(struct et61x251_device* cam,\r\nconst struct et61x251_sensor* sensor,\r\nu8 address)\r\n{\r\nstruct usb_device* udev = cam->usbdev;\r\nu8* data = cam->control_buffer;\r\nint err = 0, res;\r\ndata[0] = address;\r\ndata[1] = cam->sensor.i2c_slave_id;\r\ndata[2] = cam->sensor.rsta | 0x10;\r\ndata[3] = !(et61x251_read_reg(cam, 0x8b) & 0x02);\r\nres = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x00, 0x41,\r\n0, 0x88, data, 4, ET61X251_CTRL_TIMEOUT);\r\nif (res < 0)\r\nerr += res;\r\nerr += et61x251_i2c_wait(cam, sensor);\r\nres = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), 0x00, 0xc1,\r\n0, 0x80, data, 8, ET61X251_CTRL_TIMEOUT);\r\nif (res < 0)\r\nerr += res;\r\nif (err)\r\nDBG(3, "I2C read failed for %s image sensor", sensor->name);\r\nPDBGG("I2C read: address 0x%02X, value: 0x%02X", address, data[0]);\r\nreturn err ? -1 : (int)data[0];\r\n}\r\nstatic int et61x251_i2c_try_write(struct et61x251_device* cam,\r\nconst struct et61x251_sensor* sensor,\r\nu8 address, u8 value)\r\n{\r\nstruct usb_device* udev = cam->usbdev;\r\nu8* data = cam->control_buffer;\r\nint err = 0, res;\r\ndata[0] = address;\r\ndata[1] = cam->sensor.i2c_slave_id;\r\ndata[2] = cam->sensor.rsta | 0x12;\r\nres = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x00, 0x41,\r\n0, 0x88, data, 3, ET61X251_CTRL_TIMEOUT);\r\nif (res < 0)\r\nerr += res;\r\ndata[0] = value;\r\nres = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x00, 0x41,\r\n0, 0x80, data, 1, ET61X251_CTRL_TIMEOUT);\r\nif (res < 0)\r\nerr += res;\r\nerr += et61x251_i2c_wait(cam, sensor);\r\nif (err)\r\nDBG(3, "I2C write failed for %s image sensor", sensor->name);\r\nPDBGG("I2C write: address 0x%02X, value: 0x%02X", address, value);\r\nreturn err ? -1 : 0;\r\n}\r\nstatic int et61x251_i2c_read(struct et61x251_device* cam, u8 address)\r\n{\r\nreturn et61x251_i2c_try_read(cam, &cam->sensor, address);\r\n}\r\nstatic int et61x251_i2c_write(struct et61x251_device* cam,\r\nu8 address, u8 value)\r\n{\r\nreturn et61x251_i2c_try_write(cam, &cam->sensor, address, value);\r\n}\r\nstatic u8 et61x251_strtou8(const char* buff, size_t len, ssize_t* count)\r\n{\r\nchar str[5];\r\nchar* endp;\r\nunsigned long val;\r\nif (len < 4) {\r\nstrncpy(str, buff, len);\r\nstr[len] = '\0';\r\n} else {\r\nstrncpy(str, buff, 4);\r\nstr[4] = '\0';\r\n}\r\nval = simple_strtoul(str, &endp, 0);\r\n*count = 0;\r\nif (val <= 0xff)\r\n*count = (ssize_t)(endp - str);\r\nif ((*count) && (len == *count+1) && (buff[*count] == '\n'))\r\n*count += 1;\r\nreturn (u8)val;\r\n}\r\nstatic ssize_t et61x251_show_reg(struct device* cd,\r\nstruct device_attribute *attr, char* buf)\r\n{\r\nstruct et61x251_device* cam;\r\nssize_t count;\r\nif (mutex_lock_interruptible(&et61x251_sysfs_lock))\r\nreturn -ERESTARTSYS;\r\ncam = video_get_drvdata(to_video_device(cd));\r\nif (!cam) {\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn -ENODEV;\r\n}\r\ncount = sprintf(buf, "%u\n", cam->sysfs.reg);\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\net61x251_store_reg(struct device* cd,\r\nstruct device_attribute *attr, const char* buf, size_t len)\r\n{\r\nstruct et61x251_device* cam;\r\nu8 index;\r\nssize_t count;\r\nif (mutex_lock_interruptible(&et61x251_sysfs_lock))\r\nreturn -ERESTARTSYS;\r\ncam = video_get_drvdata(to_video_device(cd));\r\nif (!cam) {\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn -ENODEV;\r\n}\r\nindex = et61x251_strtou8(buf, len, &count);\r\nif (index > 0x8e || !count) {\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn -EINVAL;\r\n}\r\ncam->sysfs.reg = index;\r\nDBG(2, "Moved ET61X[12]51 register index to 0x%02X", cam->sysfs.reg);\r\nDBG(3, "Written bytes: %zd", count);\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t et61x251_show_val(struct device* cd,\r\nstruct device_attribute *attr, char* buf)\r\n{\r\nstruct et61x251_device* cam;\r\nssize_t count;\r\nint val;\r\nif (mutex_lock_interruptible(&et61x251_sysfs_lock))\r\nreturn -ERESTARTSYS;\r\ncam = video_get_drvdata(to_video_device(cd));\r\nif (!cam) {\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn -ENODEV;\r\n}\r\nif ((val = et61x251_read_reg(cam, cam->sysfs.reg)) < 0) {\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn -EIO;\r\n}\r\ncount = sprintf(buf, "%d\n", val);\r\nDBG(3, "Read bytes: %zd", count);\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\net61x251_store_val(struct device* cd, struct device_attribute *attr,\r\nconst char* buf, size_t len)\r\n{\r\nstruct et61x251_device* cam;\r\nu8 value;\r\nssize_t count;\r\nint err;\r\nif (mutex_lock_interruptible(&et61x251_sysfs_lock))\r\nreturn -ERESTARTSYS;\r\ncam = video_get_drvdata(to_video_device(cd));\r\nif (!cam) {\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn -ENODEV;\r\n}\r\nvalue = et61x251_strtou8(buf, len, &count);\r\nif (!count) {\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn -EINVAL;\r\n}\r\nerr = et61x251_write_reg(cam, value, cam->sysfs.reg);\r\nif (err) {\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn -EIO;\r\n}\r\nDBG(2, "Written ET61X[12]51 reg. 0x%02X, val. 0x%02X",\r\ncam->sysfs.reg, value);\r\nDBG(3, "Written bytes: %zd", count);\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t et61x251_show_i2c_reg(struct device* cd,\r\nstruct device_attribute *attr, char* buf)\r\n{\r\nstruct et61x251_device* cam;\r\nssize_t count;\r\nif (mutex_lock_interruptible(&et61x251_sysfs_lock))\r\nreturn -ERESTARTSYS;\r\ncam = video_get_drvdata(to_video_device(cd));\r\nif (!cam) {\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn -ENODEV;\r\n}\r\ncount = sprintf(buf, "%u\n", cam->sysfs.i2c_reg);\r\nDBG(3, "Read bytes: %zd", count);\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\net61x251_store_i2c_reg(struct device* cd, struct device_attribute *attr,\r\nconst char* buf, size_t len)\r\n{\r\nstruct et61x251_device* cam;\r\nu8 index;\r\nssize_t count;\r\nif (mutex_lock_interruptible(&et61x251_sysfs_lock))\r\nreturn -ERESTARTSYS;\r\ncam = video_get_drvdata(to_video_device(cd));\r\nif (!cam) {\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn -ENODEV;\r\n}\r\nindex = et61x251_strtou8(buf, len, &count);\r\nif (!count) {\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn -EINVAL;\r\n}\r\ncam->sysfs.i2c_reg = index;\r\nDBG(2, "Moved sensor register index to 0x%02X", cam->sysfs.i2c_reg);\r\nDBG(3, "Written bytes: %zd", count);\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t et61x251_show_i2c_val(struct device* cd,\r\nstruct device_attribute *attr, char* buf)\r\n{\r\nstruct et61x251_device* cam;\r\nssize_t count;\r\nint val;\r\nif (mutex_lock_interruptible(&et61x251_sysfs_lock))\r\nreturn -ERESTARTSYS;\r\ncam = video_get_drvdata(to_video_device(cd));\r\nif (!cam) {\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn -ENODEV;\r\n}\r\nif (!(cam->sensor.sysfs_ops & ET61X251_I2C_READ)) {\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn -ENOSYS;\r\n}\r\nif ((val = et61x251_i2c_read(cam, cam->sysfs.i2c_reg)) < 0) {\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn -EIO;\r\n}\r\ncount = sprintf(buf, "%d\n", val);\r\nDBG(3, "Read bytes: %zd", count);\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\net61x251_store_i2c_val(struct device* cd, struct device_attribute *attr,\r\nconst char* buf, size_t len)\r\n{\r\nstruct et61x251_device* cam;\r\nu8 value;\r\nssize_t count;\r\nint err;\r\nif (mutex_lock_interruptible(&et61x251_sysfs_lock))\r\nreturn -ERESTARTSYS;\r\ncam = video_get_drvdata(to_video_device(cd));\r\nif (!cam) {\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn -ENODEV;\r\n}\r\nif (!(cam->sensor.sysfs_ops & ET61X251_I2C_READ)) {\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn -ENOSYS;\r\n}\r\nvalue = et61x251_strtou8(buf, len, &count);\r\nif (!count) {\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn -EINVAL;\r\n}\r\nerr = et61x251_i2c_write(cam, cam->sysfs.i2c_reg, value);\r\nif (err) {\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn -EIO;\r\n}\r\nDBG(2, "Written sensor reg. 0x%02X, val. 0x%02X",\r\ncam->sysfs.i2c_reg, value);\r\nDBG(3, "Written bytes: %zd", count);\r\nmutex_unlock(&et61x251_sysfs_lock);\r\nreturn count;\r\n}\r\nstatic int et61x251_create_sysfs(struct et61x251_device* cam)\r\n{\r\nstruct device *classdev = &(cam->v4ldev->dev);\r\nint err = 0;\r\nif ((err = device_create_file(classdev, &dev_attr_reg)))\r\ngoto err_out;\r\nif ((err = device_create_file(classdev, &dev_attr_val)))\r\ngoto err_reg;\r\nif (cam->sensor.sysfs_ops) {\r\nif ((err = device_create_file(classdev, &dev_attr_i2c_reg)))\r\ngoto err_val;\r\nif ((err = device_create_file(classdev, &dev_attr_i2c_val)))\r\ngoto err_i2c_reg;\r\n}\r\nerr_i2c_reg:\r\nif (cam->sensor.sysfs_ops)\r\ndevice_remove_file(classdev, &dev_attr_i2c_reg);\r\nerr_val:\r\ndevice_remove_file(classdev, &dev_attr_val);\r\nerr_reg:\r\ndevice_remove_file(classdev, &dev_attr_reg);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic int\r\net61x251_set_pix_format(struct et61x251_device* cam,\r\nstruct v4l2_pix_format* pix)\r\n{\r\nint r, err = 0;\r\nif ((r = et61x251_read_reg(cam, 0x12)) < 0)\r\nerr += r;\r\nif (pix->pixelformat == V4L2_PIX_FMT_ET61X251)\r\nerr += et61x251_write_reg(cam, r & 0xfd, 0x12);\r\nelse\r\nerr += et61x251_write_reg(cam, r | 0x02, 0x12);\r\nreturn err ? -EIO : 0;\r\n}\r\nstatic int\r\net61x251_set_compression(struct et61x251_device* cam,\r\nstruct v4l2_jpegcompression* compression)\r\n{\r\nint r, err = 0;\r\nif ((r = et61x251_read_reg(cam, 0x12)) < 0)\r\nerr += r;\r\nif (compression->quality == 0)\r\nerr += et61x251_write_reg(cam, r & 0xfb, 0x12);\r\nelse\r\nerr += et61x251_write_reg(cam, r | 0x04, 0x12);\r\nreturn err ? -EIO : 0;\r\n}\r\nstatic int et61x251_set_scale(struct et61x251_device* cam, u8 scale)\r\n{\r\nint r = 0, err = 0;\r\nr = et61x251_read_reg(cam, 0x12);\r\nif (r < 0)\r\nerr += r;\r\nif (scale == 1)\r\nerr += et61x251_write_reg(cam, r & ~0x01, 0x12);\r\nelse if (scale == 2)\r\nerr += et61x251_write_reg(cam, r | 0x01, 0x12);\r\nif (err)\r\nreturn -EIO;\r\nPDBGG("Scaling factor: %u", scale);\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_set_crop(struct et61x251_device* cam, struct v4l2_rect* rect)\r\n{\r\nstruct et61x251_sensor* s = &cam->sensor;\r\nu16 fmw_sx = (u16)(rect->left - s->cropcap.bounds.left +\r\ns->active_pixel.left),\r\nfmw_sy = (u16)(rect->top - s->cropcap.bounds.top +\r\ns->active_pixel.top),\r\nfmw_length = (u16)(rect->width),\r\nfmw_height = (u16)(rect->height);\r\nint err = 0;\r\nerr += et61x251_write_reg(cam, fmw_sx & 0xff, 0x69);\r\nerr += et61x251_write_reg(cam, fmw_sy & 0xff, 0x6a);\r\nerr += et61x251_write_reg(cam, fmw_length & 0xff, 0x6b);\r\nerr += et61x251_write_reg(cam, fmw_height & 0xff, 0x6c);\r\nerr += et61x251_write_reg(cam, (fmw_sx >> 8) | ((fmw_sy & 0x300) >> 6)\r\n| ((fmw_length & 0x300) >> 4)\r\n| ((fmw_height & 0x300) >> 2), 0x6d);\r\nif (err)\r\nreturn -EIO;\r\nPDBGG("fmw_sx, fmw_sy, fmw_length, fmw_height: %u %u %u %u",\r\nfmw_sx, fmw_sy, fmw_length, fmw_height);\r\nreturn 0;\r\n}\r\nstatic int et61x251_init(struct et61x251_device* cam)\r\n{\r\nstruct et61x251_sensor* s = &cam->sensor;\r\nstruct v4l2_control ctrl;\r\nstruct v4l2_queryctrl *qctrl;\r\nstruct v4l2_rect* rect;\r\nu8 i = 0;\r\nint err = 0;\r\nif (!(cam->state & DEV_INITIALIZED)) {\r\nmutex_init(&cam->open_mutex);\r\ninit_waitqueue_head(&cam->wait_open);\r\nqctrl = s->qctrl;\r\nrect = &(s->cropcap.defrect);\r\ncam->compression.quality = ET61X251_COMPRESSION_QUALITY;\r\n} else {\r\nqctrl = s->_qctrl;\r\nrect = &(s->_rect);\r\n}\r\nerr += et61x251_set_scale(cam, rect->width / s->pix_format.width);\r\nerr += et61x251_set_crop(cam, rect);\r\nif (err)\r\nreturn err;\r\nif (s->init) {\r\nerr = s->init(cam);\r\nif (err) {\r\nDBG(3, "Sensor initialization failed");\r\nreturn err;\r\n}\r\n}\r\nerr += et61x251_set_compression(cam, &cam->compression);\r\nerr += et61x251_set_pix_format(cam, &s->pix_format);\r\nif (s->set_pix_format)\r\nerr += s->set_pix_format(cam, &s->pix_format);\r\nif (err)\r\nreturn err;\r\nif (s->pix_format.pixelformat == V4L2_PIX_FMT_ET61X251)\r\nDBG(3, "Compressed video format is active, quality %d",\r\ncam->compression.quality);\r\nelse\r\nDBG(3, "Uncompressed video format is active");\r\nif (s->set_crop)\r\nif ((err = s->set_crop(cam, rect))) {\r\nDBG(3, "set_crop() failed");\r\nreturn err;\r\n}\r\nif (s->set_ctrl) {\r\nfor (i = 0; i < ARRAY_SIZE(s->qctrl); i++)\r\nif (s->qctrl[i].id != 0 &&\r\n!(s->qctrl[i].flags & V4L2_CTRL_FLAG_DISABLED)) {\r\nctrl.id = s->qctrl[i].id;\r\nctrl.value = qctrl[i].default_value;\r\nerr = s->set_ctrl(cam, &ctrl);\r\nif (err) {\r\nDBG(3, "Set %s control failed",\r\ns->qctrl[i].name);\r\nreturn err;\r\n}\r\nDBG(3, "Image sensor supports '%s' control",\r\ns->qctrl[i].name);\r\n}\r\n}\r\nif (!(cam->state & DEV_INITIALIZED)) {\r\nmutex_init(&cam->fileop_mutex);\r\nspin_lock_init(&cam->queue_lock);\r\ninit_waitqueue_head(&cam->wait_frame);\r\ninit_waitqueue_head(&cam->wait_stream);\r\ncam->nreadbuffers = 2;\r\nmemcpy(s->_qctrl, s->qctrl, sizeof(s->qctrl));\r\nmemcpy(&(s->_rect), &(s->cropcap.defrect),\r\nsizeof(struct v4l2_rect));\r\ncam->state |= DEV_INITIALIZED;\r\n}\r\nDBG(2, "Initialization succeeded");\r\nreturn 0;\r\n}\r\nstatic void et61x251_release_resources(struct kref *kref)\r\n{\r\nstruct et61x251_device *cam;\r\nmutex_lock(&et61x251_sysfs_lock);\r\ncam = container_of(kref, struct et61x251_device, kref);\r\nDBG(2, "V4L2 device %s deregistered",\r\nvideo_device_node_name(cam->v4ldev));\r\nvideo_set_drvdata(cam->v4ldev, NULL);\r\nvideo_unregister_device(cam->v4ldev);\r\nusb_put_dev(cam->usbdev);\r\nkfree(cam->control_buffer);\r\nkfree(cam);\r\nmutex_unlock(&et61x251_sysfs_lock);\r\n}\r\nstatic int et61x251_open(struct file *filp)\r\n{\r\nstruct et61x251_device* cam;\r\nint err = 0;\r\nif (!down_read_trylock(&et61x251_dev_lock))\r\nreturn -ERESTARTSYS;\r\ncam = video_drvdata(filp);\r\nif (wait_for_completion_interruptible(&cam->probe)) {\r\nup_read(&et61x251_dev_lock);\r\nreturn -ERESTARTSYS;\r\n}\r\nkref_get(&cam->kref);\r\nif (mutex_lock_interruptible(&cam->open_mutex)) {\r\nkref_put(&cam->kref, et61x251_release_resources);\r\nup_read(&et61x251_dev_lock);\r\nreturn -ERESTARTSYS;\r\n}\r\nif (cam->state & DEV_DISCONNECTED) {\r\nDBG(1, "Device not present");\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nif (cam->users) {\r\nDBG(2, "Device %s is already in use",\r\nvideo_device_node_name(cam->v4ldev));\r\nDBG(3, "Simultaneous opens are not supported");\r\nif ((filp->f_flags & O_NONBLOCK) ||\r\n(filp->f_flags & O_NDELAY)) {\r\nerr = -EWOULDBLOCK;\r\ngoto out;\r\n}\r\nDBG(2, "A blocking open() has been requested. Wait for the "\r\n"device to be released...");\r\nup_read(&et61x251_dev_lock);\r\nerr = wait_event_interruptible_exclusive(cam->wait_open,\r\n(cam->state & DEV_DISCONNECTED)\r\n|| !cam->users);\r\ndown_read(&et61x251_dev_lock);\r\nif (err)\r\ngoto out;\r\nif (cam->state & DEV_DISCONNECTED) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\n}\r\nif (cam->state & DEV_MISCONFIGURED) {\r\nerr = et61x251_init(cam);\r\nif (err) {\r\nDBG(1, "Initialization failed again. "\r\n"I will retry on next open().");\r\ngoto out;\r\n}\r\ncam->state &= ~DEV_MISCONFIGURED;\r\n}\r\nif ((err = et61x251_start_transfer(cam)))\r\ngoto out;\r\nfilp->private_data = cam;\r\ncam->users++;\r\ncam->io = IO_NONE;\r\ncam->stream = STREAM_OFF;\r\ncam->nbuffers = 0;\r\ncam->frame_count = 0;\r\net61x251_empty_framequeues(cam);\r\nDBG(3, "Video device %s is open",\r\nvideo_device_node_name(cam->v4ldev));\r\nout:\r\nmutex_unlock(&cam->open_mutex);\r\nif (err)\r\nkref_put(&cam->kref, et61x251_release_resources);\r\nup_read(&et61x251_dev_lock);\r\nreturn err;\r\n}\r\nstatic int et61x251_release(struct file *filp)\r\n{\r\nstruct et61x251_device* cam;\r\ndown_write(&et61x251_dev_lock);\r\ncam = video_drvdata(filp);\r\net61x251_stop_transfer(cam);\r\net61x251_release_buffers(cam);\r\ncam->users--;\r\nwake_up_interruptible_nr(&cam->wait_open, 1);\r\nDBG(3, "Video device %s closed",\r\nvideo_device_node_name(cam->v4ldev));\r\nkref_put(&cam->kref, et61x251_release_resources);\r\nup_write(&et61x251_dev_lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\net61x251_read(struct file* filp, char __user * buf,\r\nsize_t count, loff_t* f_pos)\r\n{\r\nstruct et61x251_device *cam = video_drvdata(filp);\r\nstruct et61x251_frame_t* f, * i;\r\nunsigned long lock_flags;\r\nlong timeout;\r\nint err = 0;\r\nif (mutex_lock_interruptible(&cam->fileop_mutex))\r\nreturn -ERESTARTSYS;\r\nif (cam->state & DEV_DISCONNECTED) {\r\nDBG(1, "Device not present");\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -ENODEV;\r\n}\r\nif (cam->state & DEV_MISCONFIGURED) {\r\nDBG(1, "The camera is misconfigured. Close and open it "\r\n"again.");\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -EIO;\r\n}\r\nif (cam->io == IO_MMAP) {\r\nDBG(3, "Close and open the device again to choose the read "\r\n"method");\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -EBUSY;\r\n}\r\nif (cam->io == IO_NONE) {\r\nif (!et61x251_request_buffers(cam, cam->nreadbuffers,\r\nIO_READ)) {\r\nDBG(1, "read() failed, not enough memory");\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -ENOMEM;\r\n}\r\ncam->io = IO_READ;\r\ncam->stream = STREAM_ON;\r\n}\r\nif (list_empty(&cam->inqueue)) {\r\nif (!list_empty(&cam->outqueue))\r\net61x251_empty_framequeues(cam);\r\net61x251_queue_unusedframes(cam);\r\n}\r\nif (!count) {\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn 0;\r\n}\r\nif (list_empty(&cam->outqueue)) {\r\nif (filp->f_flags & O_NONBLOCK) {\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -EAGAIN;\r\n}\r\ntimeout = wait_event_interruptible_timeout\r\n( cam->wait_frame,\r\n(!list_empty(&cam->outqueue)) ||\r\n(cam->state & DEV_DISCONNECTED) ||\r\n(cam->state & DEV_MISCONFIGURED),\r\nmsecs_to_jiffies(\r\ncam->module_param.frame_timeout * 1000\r\n)\r\n);\r\nif (timeout < 0) {\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn timeout;\r\n}\r\nif (cam->state & DEV_DISCONNECTED) {\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -ENODEV;\r\n}\r\nif (!timeout || (cam->state & DEV_MISCONFIGURED)) {\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -EIO;\r\n}\r\n}\r\nf = list_entry(cam->outqueue.prev, struct et61x251_frame_t, frame);\r\nif (count > f->buf.bytesused)\r\ncount = f->buf.bytesused;\r\nif (copy_to_user(buf, f->bufmem, count)) {\r\nerr = -EFAULT;\r\ngoto exit;\r\n}\r\n*f_pos += count;\r\nexit:\r\nspin_lock_irqsave(&cam->queue_lock, lock_flags);\r\nlist_for_each_entry(i, &cam->outqueue, frame)\r\ni->state = F_UNUSED;\r\nINIT_LIST_HEAD(&cam->outqueue);\r\nspin_unlock_irqrestore(&cam->queue_lock, lock_flags);\r\net61x251_queue_unusedframes(cam);\r\nPDBGG("Frame #%lu, bytes read: %zu",\r\n(unsigned long)f->buf.index, count);\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn err ? err : count;\r\n}\r\nstatic unsigned int et61x251_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct et61x251_device *cam = video_drvdata(filp);\r\nstruct et61x251_frame_t* f;\r\nunsigned long lock_flags;\r\nunsigned int mask = 0;\r\nif (mutex_lock_interruptible(&cam->fileop_mutex))\r\nreturn POLLERR;\r\nif (cam->state & DEV_DISCONNECTED) {\r\nDBG(1, "Device not present");\r\ngoto error;\r\n}\r\nif (cam->state & DEV_MISCONFIGURED) {\r\nDBG(1, "The camera is misconfigured. Close and open it "\r\n"again.");\r\ngoto error;\r\n}\r\nif (cam->io == IO_NONE) {\r\nif (!et61x251_request_buffers(cam, cam->nreadbuffers,\r\nIO_READ)) {\r\nDBG(1, "poll() failed, not enough memory");\r\ngoto error;\r\n}\r\ncam->io = IO_READ;\r\ncam->stream = STREAM_ON;\r\n}\r\nif (cam->io == IO_READ) {\r\nspin_lock_irqsave(&cam->queue_lock, lock_flags);\r\nlist_for_each_entry(f, &cam->outqueue, frame)\r\nf->state = F_UNUSED;\r\nINIT_LIST_HEAD(&cam->outqueue);\r\nspin_unlock_irqrestore(&cam->queue_lock, lock_flags);\r\net61x251_queue_unusedframes(cam);\r\n}\r\npoll_wait(filp, &cam->wait_frame, wait);\r\nif (!list_empty(&cam->outqueue))\r\nmask |= POLLIN | POLLRDNORM;\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn mask;\r\nerror:\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn POLLERR;\r\n}\r\nstatic void et61x251_vm_open(struct vm_area_struct* vma)\r\n{\r\nstruct et61x251_frame_t* f = vma->vm_private_data;\r\nf->vma_use_count++;\r\n}\r\nstatic void et61x251_vm_close(struct vm_area_struct* vma)\r\n{\r\nstruct et61x251_frame_t* f = vma->vm_private_data;\r\nf->vma_use_count--;\r\n}\r\nstatic int et61x251_mmap(struct file* filp, struct vm_area_struct *vma)\r\n{\r\nstruct et61x251_device *cam = video_drvdata(filp);\r\nunsigned long size = vma->vm_end - vma->vm_start,\r\nstart = vma->vm_start;\r\nvoid *pos;\r\nu32 i;\r\nif (mutex_lock_interruptible(&cam->fileop_mutex))\r\nreturn -ERESTARTSYS;\r\nif (cam->state & DEV_DISCONNECTED) {\r\nDBG(1, "Device not present");\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -ENODEV;\r\n}\r\nif (cam->state & DEV_MISCONFIGURED) {\r\nDBG(1, "The camera is misconfigured. Close and open it "\r\n"again.");\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -EIO;\r\n}\r\nif (!(vma->vm_flags & (VM_WRITE | VM_READ))) {\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -EACCES;\r\n}\r\nif (cam->io != IO_MMAP ||\r\nsize != PAGE_ALIGN(cam->frame[0].buf.length)) {\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < cam->nbuffers; i++) {\r\nif ((cam->frame[i].buf.m.offset>>PAGE_SHIFT) == vma->vm_pgoff)\r\nbreak;\r\n}\r\nif (i == cam->nbuffers) {\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -EINVAL;\r\n}\r\nvma->vm_flags |= VM_IO;\r\nvma->vm_flags |= VM_RESERVED;\r\npos = cam->frame[i].bufmem;\r\nwhile (size > 0) {\r\nif (vm_insert_page(vma, start, vmalloc_to_page(pos))) {\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -EAGAIN;\r\n}\r\nstart += PAGE_SIZE;\r\npos += PAGE_SIZE;\r\nsize -= PAGE_SIZE;\r\n}\r\nvma->vm_ops = &et61x251_vm_ops;\r\nvma->vm_private_data = &cam->frame[i];\r\net61x251_vm_open(vma);\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_querycap(struct et61x251_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_capability cap = {\r\n.driver = "et61x251",\r\n.version = LINUX_VERSION_CODE,\r\n.capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING,\r\n};\r\nstrlcpy(cap.card, cam->v4ldev->name, sizeof(cap.card));\r\nif (usb_make_path(cam->usbdev, cap.bus_info, sizeof(cap.bus_info)) < 0)\r\nstrlcpy(cap.bus_info, dev_name(&cam->usbdev->dev),\r\nsizeof(cap.bus_info));\r\nif (copy_to_user(arg, &cap, sizeof(cap)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_enuminput(struct et61x251_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_input i;\r\nif (copy_from_user(&i, arg, sizeof(i)))\r\nreturn -EFAULT;\r\nif (i.index)\r\nreturn -EINVAL;\r\nmemset(&i, 0, sizeof(i));\r\nstrcpy(i.name, "Camera");\r\ni.type = V4L2_INPUT_TYPE_CAMERA;\r\ni.capabilities = V4L2_IN_CAP_STD;\r\nif (copy_to_user(arg, &i, sizeof(i)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_g_input(struct et61x251_device* cam, void __user * arg)\r\n{\r\nint index = 0;\r\nif (copy_to_user(arg, &index, sizeof(index)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_s_input(struct et61x251_device* cam, void __user * arg)\r\n{\r\nint index;\r\nif (copy_from_user(&index, arg, sizeof(index)))\r\nreturn -EFAULT;\r\nif (index != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_query_ctrl(struct et61x251_device* cam, void __user * arg)\r\n{\r\nstruct et61x251_sensor* s = &cam->sensor;\r\nstruct v4l2_queryctrl qc;\r\nu8 i;\r\nif (copy_from_user(&qc, arg, sizeof(qc)))\r\nreturn -EFAULT;\r\nfor (i = 0; i < ARRAY_SIZE(s->qctrl); i++)\r\nif (qc.id && qc.id == s->qctrl[i].id) {\r\nmemcpy(&qc, &(s->qctrl[i]), sizeof(qc));\r\nif (copy_to_user(arg, &qc, sizeof(qc)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\net61x251_vidioc_g_ctrl(struct et61x251_device* cam, void __user * arg)\r\n{\r\nstruct et61x251_sensor* s = &cam->sensor;\r\nstruct v4l2_control ctrl;\r\nint err = 0;\r\nu8 i;\r\nif (!s->get_ctrl && !s->set_ctrl)\r\nreturn -EINVAL;\r\nif (copy_from_user(&ctrl, arg, sizeof(ctrl)))\r\nreturn -EFAULT;\r\nif (!s->get_ctrl) {\r\nfor (i = 0; i < ARRAY_SIZE(s->qctrl); i++)\r\nif (ctrl.id == s->qctrl[i].id) {\r\nctrl.value = s->_qctrl[i].default_value;\r\ngoto exit;\r\n}\r\nreturn -EINVAL;\r\n} else\r\nerr = s->get_ctrl(cam, &ctrl);\r\nexit:\r\nif (copy_to_user(arg, &ctrl, sizeof(ctrl)))\r\nreturn -EFAULT;\r\nreturn err;\r\n}\r\nstatic int\r\net61x251_vidioc_s_ctrl(struct et61x251_device* cam, void __user * arg)\r\n{\r\nstruct et61x251_sensor* s = &cam->sensor;\r\nstruct v4l2_control ctrl;\r\nu8 i;\r\nint err = 0;\r\nif (!s->set_ctrl)\r\nreturn -EINVAL;\r\nif (copy_from_user(&ctrl, arg, sizeof(ctrl)))\r\nreturn -EFAULT;\r\nfor (i = 0; i < ARRAY_SIZE(s->qctrl); i++) {\r\nif (ctrl.id == s->qctrl[i].id) {\r\nif (s->qctrl[i].flags & V4L2_CTRL_FLAG_DISABLED)\r\nreturn -EINVAL;\r\nif (ctrl.value < s->qctrl[i].minimum ||\r\nctrl.value > s->qctrl[i].maximum)\r\nreturn -ERANGE;\r\nctrl.value -= ctrl.value % s->qctrl[i].step;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(s->qctrl))\r\nreturn -EINVAL;\r\nif ((err = s->set_ctrl(cam, &ctrl)))\r\nreturn err;\r\ns->_qctrl[i].default_value = ctrl.value;\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_cropcap(struct et61x251_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_cropcap* cc = &(cam->sensor.cropcap);\r\ncc->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ncc->pixelaspect.numerator = 1;\r\ncc->pixelaspect.denominator = 1;\r\nif (copy_to_user(arg, cc, sizeof(*cc)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_g_crop(struct et61x251_device* cam, void __user * arg)\r\n{\r\nstruct et61x251_sensor* s = &cam->sensor;\r\nstruct v4l2_crop crop = {\r\n.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\r\n};\r\nmemcpy(&(crop.c), &(s->_rect), sizeof(struct v4l2_rect));\r\nif (copy_to_user(arg, &crop, sizeof(crop)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_s_crop(struct et61x251_device* cam, void __user * arg)\r\n{\r\nstruct et61x251_sensor* s = &cam->sensor;\r\nstruct v4l2_crop crop;\r\nstruct v4l2_rect* rect;\r\nstruct v4l2_rect* bounds = &(s->cropcap.bounds);\r\nstruct v4l2_pix_format* pix_format = &(s->pix_format);\r\nu8 scale;\r\nconst enum et61x251_stream_state stream = cam->stream;\r\nconst u32 nbuffers = cam->nbuffers;\r\nu32 i;\r\nint err = 0;\r\nif (copy_from_user(&crop, arg, sizeof(crop)))\r\nreturn -EFAULT;\r\nrect = &(crop.c);\r\nif (crop.type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (cam->module_param.force_munmap)\r\nfor (i = 0; i < cam->nbuffers; i++)\r\nif (cam->frame[i].vma_use_count) {\r\nDBG(3, "VIDIOC_S_CROP failed. "\r\n"Unmap the buffers first.");\r\nreturn -EBUSY;\r\n}\r\nrect->left = (s->_rect.left & 1L) ? rect->left | 1L : rect->left & ~1L;\r\nrect->top = (s->_rect.top & 1L) ? rect->top | 1L : rect->top & ~1L;\r\nif (rect->width < 16)\r\nrect->width = 16;\r\nif (rect->height < 16)\r\nrect->height = 16;\r\nif (rect->width > bounds->width)\r\nrect->width = bounds->width;\r\nif (rect->height > bounds->height)\r\nrect->height = bounds->height;\r\nif (rect->left < bounds->left)\r\nrect->left = bounds->left;\r\nif (rect->top < bounds->top)\r\nrect->top = bounds->top;\r\nif (rect->left + rect->width > bounds->left + bounds->width)\r\nrect->left = bounds->left+bounds->width - rect->width;\r\nif (rect->top + rect->height > bounds->top + bounds->height)\r\nrect->top = bounds->top+bounds->height - rect->height;\r\nrect->width &= ~15L;\r\nrect->height &= ~15L;\r\nif (ET61X251_PRESERVE_IMGSCALE) {\r\nu32 a, b;\r\na = rect->width * rect->height;\r\nb = pix_format->width * pix_format->height;\r\nscale = b ? (u8)((a / b) < 4 ? 1 : 2) : 1;\r\n} else\r\nscale = 1;\r\nif (cam->stream == STREAM_ON)\r\nif ((err = et61x251_stream_interrupt(cam)))\r\nreturn err;\r\nif (copy_to_user(arg, &crop, sizeof(crop))) {\r\ncam->stream = stream;\r\nreturn -EFAULT;\r\n}\r\nif (cam->module_param.force_munmap || cam->io == IO_READ)\r\net61x251_release_buffers(cam);\r\nerr = et61x251_set_crop(cam, rect);\r\nif (s->set_crop)\r\nerr += s->set_crop(cam, rect);\r\nerr += et61x251_set_scale(cam, scale);\r\nif (err) {\r\ncam->state |= DEV_MISCONFIGURED;\r\nDBG(1, "VIDIOC_S_CROP failed because of hardware problems. To "\r\n"use the camera, close and open %s again.",\r\nvideo_device_node_name(cam->v4ldev));\r\nreturn -EIO;\r\n}\r\ns->pix_format.width = rect->width/scale;\r\ns->pix_format.height = rect->height/scale;\r\nmemcpy(&(s->_rect), rect, sizeof(*rect));\r\nif ((cam->module_param.force_munmap || cam->io == IO_READ) &&\r\nnbuffers != et61x251_request_buffers(cam, nbuffers, cam->io)) {\r\ncam->state |= DEV_MISCONFIGURED;\r\nDBG(1, "VIDIOC_S_CROP failed because of not enough memory. To "\r\n"use the camera, close and open %s again.",\r\nvideo_device_node_name(cam->v4ldev));\r\nreturn -ENOMEM;\r\n}\r\nif (cam->io == IO_READ)\r\net61x251_empty_framequeues(cam);\r\nelse if (cam->module_param.force_munmap)\r\net61x251_requeue_outqueue(cam);\r\ncam->stream = stream;\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_enum_framesizes(struct et61x251_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_frmsizeenum frmsize;\r\nif (copy_from_user(&frmsize, arg, sizeof(frmsize)))\r\nreturn -EFAULT;\r\nif (frmsize.index != 0)\r\nreturn -EINVAL;\r\nif (frmsize.pixel_format != V4L2_PIX_FMT_ET61X251 &&\r\nfrmsize.pixel_format != V4L2_PIX_FMT_SBGGR8)\r\nreturn -EINVAL;\r\nfrmsize.type = V4L2_FRMSIZE_TYPE_STEPWISE;\r\nfrmsize.stepwise.min_width = frmsize.stepwise.step_width = 16;\r\nfrmsize.stepwise.min_height = frmsize.stepwise.step_height = 16;\r\nfrmsize.stepwise.max_width = cam->sensor.cropcap.bounds.width;\r\nfrmsize.stepwise.max_height = cam->sensor.cropcap.bounds.height;\r\nmemset(&frmsize.reserved, 0, sizeof(frmsize.reserved));\r\nif (copy_to_user(arg, &frmsize, sizeof(frmsize)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_enum_fmt(struct et61x251_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_fmtdesc fmtd;\r\nif (copy_from_user(&fmtd, arg, sizeof(fmtd)))\r\nreturn -EFAULT;\r\nif (fmtd.type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (fmtd.index == 0) {\r\nstrcpy(fmtd.description, "bayer rgb");\r\nfmtd.pixelformat = V4L2_PIX_FMT_SBGGR8;\r\n} else if (fmtd.index == 1) {\r\nstrcpy(fmtd.description, "compressed");\r\nfmtd.pixelformat = V4L2_PIX_FMT_ET61X251;\r\nfmtd.flags = V4L2_FMT_FLAG_COMPRESSED;\r\n} else\r\nreturn -EINVAL;\r\nfmtd.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nmemset(&fmtd.reserved, 0, sizeof(fmtd.reserved));\r\nif (copy_to_user(arg, &fmtd, sizeof(fmtd)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_g_fmt(struct et61x251_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_format format;\r\nstruct v4l2_pix_format* pfmt = &(cam->sensor.pix_format);\r\nif (copy_from_user(&format, arg, sizeof(format)))\r\nreturn -EFAULT;\r\nif (format.type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\npfmt->colorspace = (pfmt->pixelformat == V4L2_PIX_FMT_ET61X251) ?\r\n0 : V4L2_COLORSPACE_SRGB;\r\npfmt->bytesperline = (pfmt->pixelformat==V4L2_PIX_FMT_ET61X251)\r\n? 0 : (pfmt->width * pfmt->priv) / 8;\r\npfmt->sizeimage = pfmt->height * ((pfmt->width*pfmt->priv)/8);\r\npfmt->field = V4L2_FIELD_NONE;\r\nmemcpy(&(format.fmt.pix), pfmt, sizeof(*pfmt));\r\nif (copy_to_user(arg, &format, sizeof(format)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_try_s_fmt(struct et61x251_device* cam, unsigned int cmd,\r\nvoid __user * arg)\r\n{\r\nstruct et61x251_sensor* s = &cam->sensor;\r\nstruct v4l2_format format;\r\nstruct v4l2_pix_format* pix;\r\nstruct v4l2_pix_format* pfmt = &(s->pix_format);\r\nstruct v4l2_rect* bounds = &(s->cropcap.bounds);\r\nstruct v4l2_rect rect;\r\nu8 scale;\r\nconst enum et61x251_stream_state stream = cam->stream;\r\nconst u32 nbuffers = cam->nbuffers;\r\nu32 i;\r\nint err = 0;\r\nif (copy_from_user(&format, arg, sizeof(format)))\r\nreturn -EFAULT;\r\npix = &(format.fmt.pix);\r\nif (format.type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nmemcpy(&rect, &(s->_rect), sizeof(rect));\r\n{\r\nu32 a, b;\r\na = rect.width * rect.height;\r\nb = pix->width * pix->height;\r\nscale = b ? (u8)((a / b) < 4 ? 1 : 2) : 1;\r\n}\r\nrect.width = scale * pix->width;\r\nrect.height = scale * pix->height;\r\nif (rect.width < 16)\r\nrect.width = 16;\r\nif (rect.height < 16)\r\nrect.height = 16;\r\nif (rect.width > bounds->left + bounds->width - rect.left)\r\nrect.width = bounds->left + bounds->width - rect.left;\r\nif (rect.height > bounds->top + bounds->height - rect.top)\r\nrect.height = bounds->top + bounds->height - rect.top;\r\nrect.width &= ~15L;\r\nrect.height &= ~15L;\r\n{\r\nu32 a, b;\r\na = rect.width * rect.height;\r\nb = pix->width * pix->height;\r\nscale = b ? (u8)((a / b) < 4 ? 1 : 2) : 1;\r\n}\r\npix->width = rect.width / scale;\r\npix->height = rect.height / scale;\r\nif (pix->pixelformat != V4L2_PIX_FMT_ET61X251 &&\r\npix->pixelformat != V4L2_PIX_FMT_SBGGR8)\r\npix->pixelformat = pfmt->pixelformat;\r\npix->priv = pfmt->priv;\r\npix->colorspace = (pix->pixelformat == V4L2_PIX_FMT_ET61X251) ?\r\n0 : V4L2_COLORSPACE_SRGB;\r\npix->colorspace = pfmt->colorspace;\r\npix->bytesperline = (pix->pixelformat == V4L2_PIX_FMT_ET61X251)\r\n? 0 : (pix->width * pix->priv) / 8;\r\npix->sizeimage = pix->height * ((pix->width * pix->priv) / 8);\r\npix->field = V4L2_FIELD_NONE;\r\nif (cmd == VIDIOC_TRY_FMT) {\r\nif (copy_to_user(arg, &format, sizeof(format)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nif (cam->module_param.force_munmap)\r\nfor (i = 0; i < cam->nbuffers; i++)\r\nif (cam->frame[i].vma_use_count) {\r\nDBG(3, "VIDIOC_S_FMT failed. "\r\n"Unmap the buffers first.");\r\nreturn -EBUSY;\r\n}\r\nif (cam->stream == STREAM_ON)\r\nif ((err = et61x251_stream_interrupt(cam)))\r\nreturn err;\r\nif (copy_to_user(arg, &format, sizeof(format))) {\r\ncam->stream = stream;\r\nreturn -EFAULT;\r\n}\r\nif (cam->module_param.force_munmap || cam->io == IO_READ)\r\net61x251_release_buffers(cam);\r\nerr += et61x251_set_pix_format(cam, pix);\r\nerr += et61x251_set_crop(cam, &rect);\r\nif (s->set_pix_format)\r\nerr += s->set_pix_format(cam, pix);\r\nif (s->set_crop)\r\nerr += s->set_crop(cam, &rect);\r\nerr += et61x251_set_scale(cam, scale);\r\nif (err) {\r\ncam->state |= DEV_MISCONFIGURED;\r\nDBG(1, "VIDIOC_S_FMT failed because of hardware problems. To "\r\n"use the camera, close and open %s again.",\r\nvideo_device_node_name(cam->v4ldev));\r\nreturn -EIO;\r\n}\r\nmemcpy(pfmt, pix, sizeof(*pix));\r\nmemcpy(&(s->_rect), &rect, sizeof(rect));\r\nif ((cam->module_param.force_munmap || cam->io == IO_READ) &&\r\nnbuffers != et61x251_request_buffers(cam, nbuffers, cam->io)) {\r\ncam->state |= DEV_MISCONFIGURED;\r\nDBG(1, "VIDIOC_S_FMT failed because of not enough memory. To "\r\n"use the camera, close and open %s again.",\r\nvideo_device_node_name(cam->v4ldev));\r\nreturn -ENOMEM;\r\n}\r\nif (cam->io == IO_READ)\r\net61x251_empty_framequeues(cam);\r\nelse if (cam->module_param.force_munmap)\r\net61x251_requeue_outqueue(cam);\r\ncam->stream = stream;\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_g_jpegcomp(struct et61x251_device* cam, void __user * arg)\r\n{\r\nif (copy_to_user(arg, &cam->compression,\r\nsizeof(cam->compression)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_s_jpegcomp(struct et61x251_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_jpegcompression jc;\r\nconst enum et61x251_stream_state stream = cam->stream;\r\nint err = 0;\r\nif (copy_from_user(&jc, arg, sizeof(jc)))\r\nreturn -EFAULT;\r\nif (jc.quality != 0 && jc.quality != 1)\r\nreturn -EINVAL;\r\nif (cam->stream == STREAM_ON)\r\nif ((err = et61x251_stream_interrupt(cam)))\r\nreturn err;\r\nerr += et61x251_set_compression(cam, &jc);\r\nif (err) {\r\ncam->state |= DEV_MISCONFIGURED;\r\nDBG(1, "VIDIOC_S_JPEGCOMP failed because of hardware "\r\n"problems. To use the camera, close and open "\r\n"%s again.", video_device_node_name(cam->v4ldev));\r\nreturn -EIO;\r\n}\r\ncam->compression.quality = jc.quality;\r\ncam->stream = stream;\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_reqbufs(struct et61x251_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_requestbuffers rb;\r\nu32 i;\r\nint err;\r\nif (copy_from_user(&rb, arg, sizeof(rb)))\r\nreturn -EFAULT;\r\nif (rb.type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\r\nrb.memory != V4L2_MEMORY_MMAP)\r\nreturn -EINVAL;\r\nif (cam->io == IO_READ) {\r\nDBG(3, "Close and open the device again to choose the mmap "\r\n"I/O method");\r\nreturn -EBUSY;\r\n}\r\nfor (i = 0; i < cam->nbuffers; i++)\r\nif (cam->frame[i].vma_use_count) {\r\nDBG(3, "VIDIOC_REQBUFS failed. "\r\n"Previous buffers are still mapped.");\r\nreturn -EBUSY;\r\n}\r\nif (cam->stream == STREAM_ON)\r\nif ((err = et61x251_stream_interrupt(cam)))\r\nreturn err;\r\net61x251_empty_framequeues(cam);\r\net61x251_release_buffers(cam);\r\nif (rb.count)\r\nrb.count = et61x251_request_buffers(cam, rb.count, IO_MMAP);\r\nif (copy_to_user(arg, &rb, sizeof(rb))) {\r\net61x251_release_buffers(cam);\r\ncam->io = IO_NONE;\r\nreturn -EFAULT;\r\n}\r\ncam->io = rb.count ? IO_MMAP : IO_NONE;\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_querybuf(struct et61x251_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_buffer b;\r\nif (copy_from_user(&b, arg, sizeof(b)))\r\nreturn -EFAULT;\r\nif (b.type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\r\nb.index >= cam->nbuffers || cam->io != IO_MMAP)\r\nreturn -EINVAL;\r\nmemcpy(&b, &cam->frame[b.index].buf, sizeof(b));\r\nif (cam->frame[b.index].vma_use_count)\r\nb.flags |= V4L2_BUF_FLAG_MAPPED;\r\nif (cam->frame[b.index].state == F_DONE)\r\nb.flags |= V4L2_BUF_FLAG_DONE;\r\nelse if (cam->frame[b.index].state != F_UNUSED)\r\nb.flags |= V4L2_BUF_FLAG_QUEUED;\r\nif (copy_to_user(arg, &b, sizeof(b)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_qbuf(struct et61x251_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_buffer b;\r\nunsigned long lock_flags;\r\nif (copy_from_user(&b, arg, sizeof(b)))\r\nreturn -EFAULT;\r\nif (b.type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\r\nb.index >= cam->nbuffers || cam->io != IO_MMAP)\r\nreturn -EINVAL;\r\nif (cam->frame[b.index].state != F_UNUSED)\r\nreturn -EINVAL;\r\ncam->frame[b.index].state = F_QUEUED;\r\nspin_lock_irqsave(&cam->queue_lock, lock_flags);\r\nlist_add_tail(&cam->frame[b.index].frame, &cam->inqueue);\r\nspin_unlock_irqrestore(&cam->queue_lock, lock_flags);\r\nPDBGG("Frame #%lu queued", (unsigned long)b.index);\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_dqbuf(struct et61x251_device* cam, struct file* filp,\r\nvoid __user * arg)\r\n{\r\nstruct v4l2_buffer b;\r\nstruct et61x251_frame_t *f;\r\nunsigned long lock_flags;\r\nlong timeout;\r\nif (copy_from_user(&b, arg, sizeof(b)))\r\nreturn -EFAULT;\r\nif (b.type != V4L2_BUF_TYPE_VIDEO_CAPTURE || cam->io!= IO_MMAP)\r\nreturn -EINVAL;\r\nif (list_empty(&cam->outqueue)) {\r\nif (cam->stream == STREAM_OFF)\r\nreturn -EINVAL;\r\nif (filp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\ntimeout = wait_event_interruptible_timeout\r\n( cam->wait_frame,\r\n(!list_empty(&cam->outqueue)) ||\r\n(cam->state & DEV_DISCONNECTED) ||\r\n(cam->state & DEV_MISCONFIGURED),\r\ncam->module_param.frame_timeout *\r\n1000 * msecs_to_jiffies(1) );\r\nif (timeout < 0)\r\nreturn timeout;\r\nif (cam->state & DEV_DISCONNECTED)\r\nreturn -ENODEV;\r\nif (!timeout || (cam->state & DEV_MISCONFIGURED))\r\nreturn -EIO;\r\n}\r\nspin_lock_irqsave(&cam->queue_lock, lock_flags);\r\nf = list_entry(cam->outqueue.next, struct et61x251_frame_t, frame);\r\nlist_del(cam->outqueue.next);\r\nspin_unlock_irqrestore(&cam->queue_lock, lock_flags);\r\nf->state = F_UNUSED;\r\nmemcpy(&b, &f->buf, sizeof(b));\r\nif (f->vma_use_count)\r\nb.flags |= V4L2_BUF_FLAG_MAPPED;\r\nif (copy_to_user(arg, &b, sizeof(b)))\r\nreturn -EFAULT;\r\nPDBGG("Frame #%lu dequeued", (unsigned long)f->buf.index);\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_streamon(struct et61x251_device* cam, void __user * arg)\r\n{\r\nint type;\r\nif (copy_from_user(&type, arg, sizeof(type)))\r\nreturn -EFAULT;\r\nif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE || cam->io != IO_MMAP)\r\nreturn -EINVAL;\r\ncam->stream = STREAM_ON;\r\nDBG(3, "Stream on");\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_streamoff(struct et61x251_device* cam, void __user * arg)\r\n{\r\nint type, err;\r\nif (copy_from_user(&type, arg, sizeof(type)))\r\nreturn -EFAULT;\r\nif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE || cam->io != IO_MMAP)\r\nreturn -EINVAL;\r\nif (cam->stream == STREAM_ON)\r\nif ((err = et61x251_stream_interrupt(cam)))\r\nreturn err;\r\net61x251_empty_framequeues(cam);\r\nDBG(3, "Stream off");\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_g_parm(struct et61x251_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_streamparm sp;\r\nif (copy_from_user(&sp, arg, sizeof(sp)))\r\nreturn -EFAULT;\r\nif (sp.type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nsp.parm.capture.extendedmode = 0;\r\nsp.parm.capture.readbuffers = cam->nreadbuffers;\r\nif (copy_to_user(arg, &sp, sizeof(sp)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\net61x251_vidioc_s_parm(struct et61x251_device* cam, void __user * arg)\r\n{\r\nstruct v4l2_streamparm sp;\r\nif (copy_from_user(&sp, arg, sizeof(sp)))\r\nreturn -EFAULT;\r\nif (sp.type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nsp.parm.capture.extendedmode = 0;\r\nif (sp.parm.capture.readbuffers == 0)\r\nsp.parm.capture.readbuffers = cam->nreadbuffers;\r\nif (sp.parm.capture.readbuffers > ET61X251_MAX_FRAMES)\r\nsp.parm.capture.readbuffers = ET61X251_MAX_FRAMES;\r\nif (copy_to_user(arg, &sp, sizeof(sp)))\r\nreturn -EFAULT;\r\ncam->nreadbuffers = sp.parm.capture.readbuffers;\r\nreturn 0;\r\n}\r\nstatic long et61x251_ioctl_v4l2(struct file *filp,\r\nunsigned int cmd, void __user *arg)\r\n{\r\nstruct et61x251_device *cam = video_drvdata(filp);\r\nswitch (cmd) {\r\ncase VIDIOC_QUERYCAP:\r\nreturn et61x251_vidioc_querycap(cam, arg);\r\ncase VIDIOC_ENUMINPUT:\r\nreturn et61x251_vidioc_enuminput(cam, arg);\r\ncase VIDIOC_G_INPUT:\r\nreturn et61x251_vidioc_g_input(cam, arg);\r\ncase VIDIOC_S_INPUT:\r\nreturn et61x251_vidioc_s_input(cam, arg);\r\ncase VIDIOC_QUERYCTRL:\r\nreturn et61x251_vidioc_query_ctrl(cam, arg);\r\ncase VIDIOC_G_CTRL:\r\nreturn et61x251_vidioc_g_ctrl(cam, arg);\r\ncase VIDIOC_S_CTRL:\r\nreturn et61x251_vidioc_s_ctrl(cam, arg);\r\ncase VIDIOC_CROPCAP:\r\nreturn et61x251_vidioc_cropcap(cam, arg);\r\ncase VIDIOC_G_CROP:\r\nreturn et61x251_vidioc_g_crop(cam, arg);\r\ncase VIDIOC_S_CROP:\r\nreturn et61x251_vidioc_s_crop(cam, arg);\r\ncase VIDIOC_ENUM_FMT:\r\nreturn et61x251_vidioc_enum_fmt(cam, arg);\r\ncase VIDIOC_G_FMT:\r\nreturn et61x251_vidioc_g_fmt(cam, arg);\r\ncase VIDIOC_TRY_FMT:\r\ncase VIDIOC_S_FMT:\r\nreturn et61x251_vidioc_try_s_fmt(cam, cmd, arg);\r\ncase VIDIOC_ENUM_FRAMESIZES:\r\nreturn et61x251_vidioc_enum_framesizes(cam, arg);\r\ncase VIDIOC_G_JPEGCOMP:\r\nreturn et61x251_vidioc_g_jpegcomp(cam, arg);\r\ncase VIDIOC_S_JPEGCOMP:\r\nreturn et61x251_vidioc_s_jpegcomp(cam, arg);\r\ncase VIDIOC_REQBUFS:\r\nreturn et61x251_vidioc_reqbufs(cam, arg);\r\ncase VIDIOC_QUERYBUF:\r\nreturn et61x251_vidioc_querybuf(cam, arg);\r\ncase VIDIOC_QBUF:\r\nreturn et61x251_vidioc_qbuf(cam, arg);\r\ncase VIDIOC_DQBUF:\r\nreturn et61x251_vidioc_dqbuf(cam, filp, arg);\r\ncase VIDIOC_STREAMON:\r\nreturn et61x251_vidioc_streamon(cam, arg);\r\ncase VIDIOC_STREAMOFF:\r\nreturn et61x251_vidioc_streamoff(cam, arg);\r\ncase VIDIOC_G_PARM:\r\nreturn et61x251_vidioc_g_parm(cam, arg);\r\ncase VIDIOC_S_PARM:\r\nreturn et61x251_vidioc_s_parm(cam, arg);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic long et61x251_ioctl(struct file *filp,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct et61x251_device *cam = video_drvdata(filp);\r\nlong err = 0;\r\nif (mutex_lock_interruptible(&cam->fileop_mutex))\r\nreturn -ERESTARTSYS;\r\nif (cam->state & DEV_DISCONNECTED) {\r\nDBG(1, "Device not present");\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -ENODEV;\r\n}\r\nif (cam->state & DEV_MISCONFIGURED) {\r\nDBG(1, "The camera is misconfigured. Close and open it "\r\n"again.");\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn -EIO;\r\n}\r\nV4LDBG(3, "et61x251", cmd);\r\nerr = et61x251_ioctl_v4l2(filp, cmd, (void __user *)arg);\r\nmutex_unlock(&cam->fileop_mutex);\r\nreturn err;\r\n}\r\nstatic int\r\net61x251_usb_probe(struct usb_interface* intf, const struct usb_device_id* id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct et61x251_device* cam;\r\nstatic unsigned int dev_nr;\r\nunsigned int i;\r\nint err = 0;\r\nif (!(cam = kzalloc(sizeof(struct et61x251_device), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\ncam->usbdev = udev;\r\nif (!(cam->control_buffer = kzalloc(8, GFP_KERNEL))) {\r\nDBG(1, "kmalloc() failed");\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nif (!(cam->v4ldev = video_device_alloc())) {\r\nDBG(1, "video_device_alloc() failed");\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nDBG(2, "ET61X[12]51 PC Camera Controller detected "\r\n"(vid/pid 0x%04X:0x%04X)",id->idVendor, id->idProduct);\r\nfor (i = 0; et61x251_sensor_table[i]; i++) {\r\nerr = et61x251_sensor_table[i](cam);\r\nif (!err)\r\nbreak;\r\n}\r\nif (!err)\r\nDBG(2, "%s image sensor detected", cam->sensor.name);\r\nelse {\r\nDBG(1, "No supported image sensor detected");\r\nerr = -ENODEV;\r\ngoto fail;\r\n}\r\nif (et61x251_init(cam)) {\r\nDBG(1, "Initialization failed. I will retry on open().");\r\ncam->state |= DEV_MISCONFIGURED;\r\n}\r\nstrcpy(cam->v4ldev->name, "ET61X[12]51 PC Camera");\r\ncam->v4ldev->fops = &et61x251_fops;\r\ncam->v4ldev->release = video_device_release;\r\ncam->v4ldev->parent = &udev->dev;\r\nvideo_set_drvdata(cam->v4ldev, cam);\r\ninit_completion(&cam->probe);\r\nerr = video_register_device(cam->v4ldev, VFL_TYPE_GRABBER,\r\nvideo_nr[dev_nr]);\r\nif (err) {\r\nDBG(1, "V4L2 device registration failed");\r\nif (err == -ENFILE && video_nr[dev_nr] == -1)\r\nDBG(1, "Free /dev/videoX node not found");\r\nvideo_nr[dev_nr] = -1;\r\ndev_nr = (dev_nr < ET61X251_MAX_DEVICES-1) ? dev_nr+1 : 0;\r\ncomplete_all(&cam->probe);\r\ngoto fail;\r\n}\r\nDBG(2, "V4L2 device registered as %s",\r\nvideo_device_node_name(cam->v4ldev));\r\ncam->module_param.force_munmap = force_munmap[dev_nr];\r\ncam->module_param.frame_timeout = frame_timeout[dev_nr];\r\ndev_nr = (dev_nr < ET61X251_MAX_DEVICES-1) ? dev_nr+1 : 0;\r\n#ifdef CONFIG_VIDEO_ADV_DEBUG\r\nerr = et61x251_create_sysfs(cam);\r\nif (!err)\r\nDBG(2, "Optional device control through 'sysfs' "\r\n"interface ready");\r\nelse\r\nDBG(2, "Failed to create 'sysfs' interface for optional "\r\n"device controlling. Error #%d", err);\r\n#else\r\nDBG(2, "Optional device control through 'sysfs' interface disabled");\r\nDBG(3, "Compile the kernel with the 'CONFIG_VIDEO_ADV_DEBUG' "\r\n"configuration option to enable it.");\r\n#endif\r\nusb_set_intfdata(intf, cam);\r\nkref_init(&cam->kref);\r\nusb_get_dev(cam->usbdev);\r\ncomplete_all(&cam->probe);\r\nreturn 0;\r\nfail:\r\nif (cam) {\r\nkfree(cam->control_buffer);\r\nif (cam->v4ldev)\r\nvideo_device_release(cam->v4ldev);\r\nkfree(cam);\r\n}\r\nreturn err;\r\n}\r\nstatic void et61x251_usb_disconnect(struct usb_interface* intf)\r\n{\r\nstruct et61x251_device* cam;\r\ndown_write(&et61x251_dev_lock);\r\ncam = usb_get_intfdata(intf);\r\nDBG(2, "Disconnecting %s...", cam->v4ldev->name);\r\nif (cam->users) {\r\nDBG(2, "Device %s is open! Deregistration and memory "\r\n"deallocation are deferred.",\r\nvideo_device_node_name(cam->v4ldev));\r\ncam->state |= DEV_MISCONFIGURED;\r\net61x251_stop_transfer(cam);\r\ncam->state |= DEV_DISCONNECTED;\r\nwake_up_interruptible(&cam->wait_frame);\r\nwake_up(&cam->wait_stream);\r\n} else\r\ncam->state |= DEV_DISCONNECTED;\r\nwake_up_interruptible_all(&cam->wait_open);\r\nkref_put(&cam->kref, et61x251_release_resources);\r\nup_write(&et61x251_dev_lock);\r\n}
