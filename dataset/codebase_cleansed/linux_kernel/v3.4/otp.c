static u16\r\nipxotp_otpr(struct otpinfo *oi, uint wn)\r\n{\r\nreturn bcma_read16(oi->core,\r\nCHIPCREGOFFS(sromotp[wn]));\r\n}\r\nstatic int ipxotp_max_rgnsz(struct si_pub *sih, int osizew)\r\n{\r\nint ret = 0;\r\nswitch (ai_get_chip_id(sih)) {\r\ncase BCM43224_CHIP_ID:\r\ncase BCM43225_CHIP_ID:\r\nret = osizew * 2 - OTP_SZ_FU_72 - OTP_SZ_CHECKSUM;\r\nbreak;\r\ncase BCM4313_CHIP_ID:\r\nret = osizew * 2 - OTP_SZ_FU_72 - OTP_SZ_CHECKSUM;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void _ipxotp_init(struct otpinfo *oi)\r\n{\r\nuint k;\r\nu32 otpp, st;\r\nint ccrev = ai_get_ccrev(oi->sih);\r\nif (ccrev == 21 || ccrev == 24\r\n|| ccrev == 27) {\r\noi->otpgu_base = REVA4_OTPGU_BASE;\r\n} else if (ccrev == 36) {\r\nif (oi->wsize >= 128)\r\noi->otpgu_base = REVB8_OTPGU_BASE;\r\nelse\r\noi->otpgu_base = REV36_OTPGU_BASE;\r\n} else if (ccrev == 23 || ccrev >= 25) {\r\noi->otpgu_base = REVB8_OTPGU_BASE;\r\n}\r\notpp =\r\nOTPP_START_BUSY | ((OTPPOC_INIT << OTPP_OC_SHIFT) & OTPP_OC_MASK);\r\nbcma_write32(oi->core, CHIPCREGOFFS(otpprog), otpp);\r\nst = bcma_read32(oi->core, CHIPCREGOFFS(otpprog));\r\nfor (k = 0; (st & OTPP_START_BUSY) && (k < OTPP_TRIES); k++)\r\nst = bcma_read32(oi->core, CHIPCREGOFFS(otpprog));\r\nif (k >= OTPP_TRIES)\r\nreturn;\r\noi->status = bcma_read32(oi->core, CHIPCREGOFFS(otpstatus));\r\nif ((ai_get_chip_id(oi->sih) == BCM43224_CHIP_ID)\r\n|| (ai_get_chip_id(oi->sih) == BCM43225_CHIP_ID)) {\r\nu32 p_bits;\r\np_bits = (ipxotp_otpr(oi, oi->otpgu_base + OTPGU_P_OFF) &\r\nOTPGU_P_MSK) >> OTPGU_P_SHIFT;\r\noi->status |= (p_bits << OTPS_GUP_SHIFT);\r\n}\r\noi->hwbase = oi->otpgu_base + OTPGU_SROM_OFF;\r\noi->hwlim = oi->wsize;\r\nif (oi->status & OTPS_GUP_HW) {\r\noi->hwlim =\r\nipxotp_otpr(oi, oi->otpgu_base + OTPGU_HSB_OFF) / 16;\r\noi->swbase = oi->hwlim;\r\n} else\r\noi->swbase = oi->hwbase;\r\noi->swlim = ipxotp_max_rgnsz(oi->sih, oi->wsize) / 2;\r\nif (oi->status & OTPS_GUP_SW) {\r\noi->swlim =\r\nipxotp_otpr(oi, oi->otpgu_base + OTPGU_SFB_OFF) / 16;\r\noi->fbase = oi->swlim;\r\n} else\r\noi->fbase = oi->swbase;\r\noi->flim = oi->wsize;\r\n}\r\nstatic int ipxotp_init(struct si_pub *sih, struct otpinfo *oi)\r\n{\r\nif (!OTPTYPE_IPX(ai_get_ccrev(sih)))\r\nreturn -EBADE;\r\nif (ai_is_otp_disabled(sih))\r\nreturn -EBADE;\r\nswitch ((ai_get_cccaps(sih) & CC_CAP_OTPSIZE) >> CC_CAP_OTPSIZE_SHIFT) {\r\ncase 0:\r\nreturn -EBADE;\r\ncase 1:\r\noi->rows = 32;\r\noi->cols = 64;\r\noi->wsize = 128;\r\nbreak;\r\ncase 2:\r\noi->rows = 64;\r\noi->cols = 64;\r\noi->wsize = 256;\r\nbreak;\r\ncase 5:\r\noi->rows = 96;\r\noi->cols = 64;\r\noi->wsize = 384;\r\nbreak;\r\ncase 7:\r\noi->rows = 16;\r\noi->cols = 64;\r\noi->wsize = 64;\r\nbreak;\r\ndefault:\r\nreturn -EBADE;\r\n}\r\n_ipxotp_init(oi);\r\nreturn 0;\r\n}\r\nstatic int\r\nipxotp_read_region(struct otpinfo *oi, int region, u16 *data, uint *wlen)\r\n{\r\nuint base, i, sz;\r\nswitch (region) {\r\ncase OTP_HW_RGN:\r\nsz = (uint) oi->hwlim - oi->hwbase;\r\nif (!(oi->status & OTPS_GUP_HW)) {\r\n*wlen = sz;\r\nreturn -ENODATA;\r\n}\r\nif (*wlen < sz) {\r\n*wlen = sz;\r\nreturn -EOVERFLOW;\r\n}\r\nbase = oi->hwbase;\r\nbreak;\r\ncase OTP_SW_RGN:\r\nsz = ((uint) oi->swlim - oi->swbase);\r\nif (!(oi->status & OTPS_GUP_SW)) {\r\n*wlen = sz;\r\nreturn -ENODATA;\r\n}\r\nif (*wlen < sz) {\r\n*wlen = sz;\r\nreturn -EOVERFLOW;\r\n}\r\nbase = oi->swbase;\r\nbreak;\r\ncase OTP_CI_RGN:\r\nsz = OTPGU_CI_SZ;\r\nif (!(oi->status & OTPS_GUP_CI)) {\r\n*wlen = sz;\r\nreturn -ENODATA;\r\n}\r\nif (*wlen < sz) {\r\n*wlen = sz;\r\nreturn -EOVERFLOW;\r\n}\r\nbase = oi->otpgu_base + OTPGU_CI_OFF;\r\nbreak;\r\ncase OTP_FUSE_RGN:\r\nsz = (uint) oi->flim - oi->fbase;\r\nif (!(oi->status & OTPS_GUP_FUSE)) {\r\n*wlen = sz;\r\nreturn -ENODATA;\r\n}\r\nif (*wlen < sz) {\r\n*wlen = sz;\r\nreturn -EOVERFLOW;\r\n}\r\nbase = oi->fbase;\r\nbreak;\r\ncase OTP_ALL_RGN:\r\nsz = ((uint) oi->flim - oi->hwbase);\r\nif (!(oi->status & (OTPS_GUP_HW | OTPS_GUP_SW))) {\r\n*wlen = sz;\r\nreturn -ENODATA;\r\n}\r\nif (*wlen < sz) {\r\n*wlen = sz;\r\nreturn -EOVERFLOW;\r\n}\r\nbase = oi->hwbase;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < sz; i++)\r\ndata[i] = ipxotp_otpr(oi, base + i);\r\n*wlen = sz;\r\nreturn 0;\r\n}\r\nstatic int otp_init(struct si_pub *sih, struct otpinfo *oi)\r\n{\r\nint ret;\r\nmemset(oi, 0, sizeof(struct otpinfo));\r\noi->core = ai_findcore(sih, BCMA_CORE_CHIPCOMMON, 0);\r\nif (OTPTYPE_IPX(ai_get_ccrev(sih)))\r\noi->fn = &ipxotp_fn;\r\nif (oi->fn == NULL)\r\nreturn -EBADE;\r\noi->sih = sih;\r\nret = (oi->fn->init)(sih, oi);\r\nreturn ret;\r\n}\r\nint\r\notp_read_region(struct si_pub *sih, int region, u16 *data, uint *wlen) {\r\nstruct otpinfo otpinfo;\r\nstruct otpinfo *oi = &otpinfo;\r\nint err = 0;\r\nif (ai_is_otp_disabled(sih)) {\r\nerr = -EPERM;\r\ngoto out;\r\n}\r\nerr = otp_init(sih, oi);\r\nif (err)\r\ngoto out;\r\nerr = ((oi)->fn->read_region)(oi, region, data, wlen);\r\nout:\r\nreturn err;\r\n}
