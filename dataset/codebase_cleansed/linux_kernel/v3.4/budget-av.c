static u8 i2c_readreg(struct i2c_adapter *i2c, u8 id, u8 reg)\r\n{\r\nu8 mm1[] = { 0x00 };\r\nu8 mm2[] = { 0x00 };\r\nstruct i2c_msg msgs[2];\r\nmsgs[0].flags = 0;\r\nmsgs[1].flags = I2C_M_RD;\r\nmsgs[0].addr = msgs[1].addr = id / 2;\r\nmm1[0] = reg;\r\nmsgs[0].len = 1;\r\nmsgs[1].len = 1;\r\nmsgs[0].buf = mm1;\r\nmsgs[1].buf = mm2;\r\ni2c_transfer(i2c, msgs, 2);\r\nreturn mm2[0];\r\n}\r\nstatic int i2c_readregs(struct i2c_adapter *i2c, u8 id, u8 reg, u8 * buf, u8 len)\r\n{\r\nu8 mm1[] = { reg };\r\nstruct i2c_msg msgs[2] = {\r\n{.addr = id / 2,.flags = 0,.buf = mm1,.len = 1},\r\n{.addr = id / 2,.flags = I2C_M_RD,.buf = buf,.len = len}\r\n};\r\nif (i2c_transfer(i2c, msgs, 2) != 2)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int i2c_writereg(struct i2c_adapter *i2c, u8 id, u8 reg, u8 val)\r\n{\r\nu8 msg[2] = { reg, val };\r\nstruct i2c_msg msgs;\r\nmsgs.flags = 0;\r\nmsgs.addr = id / 2;\r\nmsgs.len = 2;\r\nmsgs.buf = msg;\r\nreturn i2c_transfer(i2c, &msgs, 1);\r\n}\r\nstatic int ciintf_read_attribute_mem(struct dvb_ca_en50221 *ca, int slot, int address)\r\n{\r\nstruct budget_av *budget_av = (struct budget_av *) ca->data;\r\nint result;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nsaa7146_setgpio(budget_av->budget.dev, 1, SAA7146_GPIO_OUTHI);\r\nudelay(1);\r\nresult = ttpci_budget_debiread(&budget_av->budget, DEBICICAM, address & 0xfff, 1, 0, 1);\r\nif (result == -ETIMEDOUT) {\r\nciintf_slot_shutdown(ca, slot);\r\npr_info("cam ejected 1\n");\r\n}\r\nreturn result;\r\n}\r\nstatic int ciintf_write_attribute_mem(struct dvb_ca_en50221 *ca, int slot, int address, u8 value)\r\n{\r\nstruct budget_av *budget_av = (struct budget_av *) ca->data;\r\nint result;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nsaa7146_setgpio(budget_av->budget.dev, 1, SAA7146_GPIO_OUTHI);\r\nudelay(1);\r\nresult = ttpci_budget_debiwrite(&budget_av->budget, DEBICICAM, address & 0xfff, 1, value, 0, 1);\r\nif (result == -ETIMEDOUT) {\r\nciintf_slot_shutdown(ca, slot);\r\npr_info("cam ejected 2\n");\r\n}\r\nreturn result;\r\n}\r\nstatic int ciintf_read_cam_control(struct dvb_ca_en50221 *ca, int slot, u8 address)\r\n{\r\nstruct budget_av *budget_av = (struct budget_av *) ca->data;\r\nint result;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nsaa7146_setgpio(budget_av->budget.dev, 1, SAA7146_GPIO_OUTLO);\r\nudelay(1);\r\nresult = ttpci_budget_debiread(&budget_av->budget, DEBICICAM, address & 3, 1, 0, 0);\r\nif (result == -ETIMEDOUT) {\r\nciintf_slot_shutdown(ca, slot);\r\npr_info("cam ejected 3\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn result;\r\n}\r\nstatic int ciintf_write_cam_control(struct dvb_ca_en50221 *ca, int slot, u8 address, u8 value)\r\n{\r\nstruct budget_av *budget_av = (struct budget_av *) ca->data;\r\nint result;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nsaa7146_setgpio(budget_av->budget.dev, 1, SAA7146_GPIO_OUTLO);\r\nudelay(1);\r\nresult = ttpci_budget_debiwrite(&budget_av->budget, DEBICICAM, address & 3, 1, value, 0, 0);\r\nif (result == -ETIMEDOUT) {\r\nciintf_slot_shutdown(ca, slot);\r\npr_info("cam ejected 5\n");\r\n}\r\nreturn result;\r\n}\r\nstatic int ciintf_slot_reset(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nstruct budget_av *budget_av = (struct budget_av *) ca->data;\r\nstruct saa7146_dev *saa = budget_av->budget.dev;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\ndprintk(1, "ciintf_slot_reset\n");\r\nbudget_av->slot_status = SLOTSTATUS_RESET;\r\nsaa7146_setgpio(saa, 2, SAA7146_GPIO_OUTHI);\r\nsaa7146_setgpio(saa, 0, SAA7146_GPIO_OUTHI);\r\nmsleep(2);\r\nsaa7146_setgpio(saa, 0, SAA7146_GPIO_OUTLO);\r\nmsleep(20);\r\nsaa7146_setgpio(saa, 2, SAA7146_GPIO_OUTLO);\r\nttpci_budget_set_video_port(saa, BUDGET_VIDEO_PORTB);\r\nmsleep(20);\r\nif (budget_av->reinitialise_demod)\r\ndvb_frontend_reinitialise(budget_av->budget.dvb_frontend);\r\nreturn 0;\r\n}\r\nstatic int ciintf_slot_shutdown(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nstruct budget_av *budget_av = (struct budget_av *) ca->data;\r\nstruct saa7146_dev *saa = budget_av->budget.dev;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\ndprintk(1, "ciintf_slot_shutdown\n");\r\nttpci_budget_set_video_port(saa, BUDGET_VIDEO_PORTB);\r\nbudget_av->slot_status = SLOTSTATUS_NONE;\r\nreturn 0;\r\n}\r\nstatic int ciintf_slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)\r\n{\r\nstruct budget_av *budget_av = (struct budget_av *) ca->data;\r\nstruct saa7146_dev *saa = budget_av->budget.dev;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\ndprintk(1, "ciintf_slot_ts_enable: %d\n", budget_av->slot_status);\r\nttpci_budget_set_video_port(saa, BUDGET_VIDEO_PORTA);\r\nreturn 0;\r\n}\r\nstatic int ciintf_poll_slot_status(struct dvb_ca_en50221 *ca, int slot, int open)\r\n{\r\nstruct budget_av *budget_av = (struct budget_av *) ca->data;\r\nstruct saa7146_dev *saa = budget_av->budget.dev;\r\nint result;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nif (budget_av->slot_status == SLOTSTATUS_NONE) {\r\nsaa7146_setgpio(saa, 3, SAA7146_GPIO_INPUT);\r\nudelay(1);\r\nif (saa7146_read(saa, PSR) & MASK_06) {\r\nif (budget_av->slot_status == SLOTSTATUS_NONE) {\r\nbudget_av->slot_status = SLOTSTATUS_PRESENT;\r\npr_info("cam inserted A\n");\r\n}\r\n}\r\nsaa7146_setgpio(saa, 3, SAA7146_GPIO_OUTLO);\r\n}\r\nif ((budget_av->slot_status == SLOTSTATUS_NONE) || (!open)) {\r\nsaa7146_setgpio(budget_av->budget.dev, 1, SAA7146_GPIO_OUTLO);\r\nresult = ttpci_budget_debiread(&budget_av->budget, DEBICICAM, 0, 1, 0, 1);\r\nif ((result >= 0) && (budget_av->slot_status == SLOTSTATUS_NONE)) {\r\nbudget_av->slot_status = SLOTSTATUS_PRESENT;\r\npr_info("cam inserted B\n");\r\n} else if (result < 0) {\r\nif (budget_av->slot_status != SLOTSTATUS_NONE) {\r\nciintf_slot_shutdown(ca, slot);\r\npr_info("cam ejected 5\n");\r\nreturn 0;\r\n}\r\n}\r\n}\r\nif (budget_av->slot_status == SLOTSTATUS_RESET) {\r\nresult = ciintf_read_attribute_mem(ca, slot, 0);\r\nif (result == 0x1d) {\r\nbudget_av->slot_status = SLOTSTATUS_READY;\r\n}\r\n}\r\nif (budget_av->slot_status != SLOTSTATUS_NONE) {\r\nif (budget_av->slot_status & SLOTSTATUS_READY) {\r\nreturn DVB_CA_EN50221_POLL_CAM_PRESENT | DVB_CA_EN50221_POLL_CAM_READY;\r\n}\r\nreturn DVB_CA_EN50221_POLL_CAM_PRESENT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ciintf_init(struct budget_av *budget_av)\r\n{\r\nstruct saa7146_dev *saa = budget_av->budget.dev;\r\nint result;\r\nmemset(&budget_av->ca, 0, sizeof(struct dvb_ca_en50221));\r\nsaa7146_setgpio(saa, 0, SAA7146_GPIO_OUTLO);\r\nsaa7146_setgpio(saa, 1, SAA7146_GPIO_OUTLO);\r\nsaa7146_setgpio(saa, 2, SAA7146_GPIO_OUTLO);\r\nsaa7146_setgpio(saa, 3, SAA7146_GPIO_OUTLO);\r\nsaa7146_write(saa, MC1, MASK_27 | MASK_11);\r\nbudget_av->ca.owner = THIS_MODULE;\r\nbudget_av->ca.read_attribute_mem = ciintf_read_attribute_mem;\r\nbudget_av->ca.write_attribute_mem = ciintf_write_attribute_mem;\r\nbudget_av->ca.read_cam_control = ciintf_read_cam_control;\r\nbudget_av->ca.write_cam_control = ciintf_write_cam_control;\r\nbudget_av->ca.slot_reset = ciintf_slot_reset;\r\nbudget_av->ca.slot_shutdown = ciintf_slot_shutdown;\r\nbudget_av->ca.slot_ts_enable = ciintf_slot_ts_enable;\r\nbudget_av->ca.poll_slot_status = ciintf_poll_slot_status;\r\nbudget_av->ca.data = budget_av;\r\nbudget_av->budget.ci_present = 1;\r\nbudget_av->slot_status = SLOTSTATUS_NONE;\r\nif ((result = dvb_ca_en50221_init(&budget_av->budget.dvb_adapter,\r\n&budget_av->ca, 0, 1)) != 0) {\r\npr_err("ci initialisation failed\n");\r\ngoto error;\r\n}\r\npr_info("ci interface initialised\n");\r\nreturn 0;\r\nerror:\r\nsaa7146_write(saa, MC1, MASK_27);\r\nreturn result;\r\n}\r\nstatic void ciintf_deinit(struct budget_av *budget_av)\r\n{\r\nstruct saa7146_dev *saa = budget_av->budget.dev;\r\nsaa7146_setgpio(saa, 0, SAA7146_GPIO_INPUT);\r\nsaa7146_setgpio(saa, 1, SAA7146_GPIO_INPUT);\r\nsaa7146_setgpio(saa, 2, SAA7146_GPIO_INPUT);\r\nsaa7146_setgpio(saa, 3, SAA7146_GPIO_INPUT);\r\ndvb_ca_en50221_release(&budget_av->ca);\r\nsaa7146_write(saa, MC1, MASK_27);\r\n}\r\nstatic int saa7113_init(struct budget_av *budget_av)\r\n{\r\nstruct budget *budget = &budget_av->budget;\r\nstruct saa7146_dev *saa = budget->dev;\r\nconst u8 *data = saa7113_tab;\r\nsaa7146_setgpio(saa, 0, SAA7146_GPIO_OUTHI);\r\nmsleep(200);\r\nif (i2c_writereg(&budget->i2c_adap, 0x4a, 0x01, 0x08) != 1) {\r\ndprintk(1, "saa7113 not found on KNC card\n");\r\nreturn -ENODEV;\r\n}\r\ndprintk(1, "saa7113 detected and initializing\n");\r\nwhile (*data != 0xff) {\r\ni2c_writereg(&budget->i2c_adap, 0x4a, *data, *(data + 1));\r\ndata += 2;\r\n}\r\ndprintk(1, "saa7113 status=%02x\n", i2c_readreg(&budget->i2c_adap, 0x4a, 0x1f));\r\nreturn 0;\r\n}\r\nstatic int saa7113_setinput(struct budget_av *budget_av, int input)\r\n{\r\nstruct budget *budget = &budget_av->budget;\r\nif (1 != budget_av->has_saa7113)\r\nreturn -ENODEV;\r\nif (input == 1) {\r\ni2c_writereg(&budget->i2c_adap, 0x4a, 0x02, 0xc7);\r\ni2c_writereg(&budget->i2c_adap, 0x4a, 0x09, 0x80);\r\n} else if (input == 0) {\r\ni2c_writereg(&budget->i2c_adap, 0x4a, 0x02, 0xc0);\r\ni2c_writereg(&budget->i2c_adap, 0x4a, 0x09, 0x00);\r\n} else\r\nreturn -EINVAL;\r\nbudget_av->cur_input = input;\r\nreturn 0;\r\n}\r\nstatic int philips_su1278_ty_ci_set_symbol_rate(struct dvb_frontend *fe, u32 srate, u32 ratio)\r\n{\r\nu8 aclk = 0;\r\nu8 bclk = 0;\r\nu8 m1;\r\naclk = 0xb5;\r\nif (srate < 2000000)\r\nbclk = 0x86;\r\nelse if (srate < 5000000)\r\nbclk = 0x89;\r\nelse if (srate < 15000000)\r\nbclk = 0x8f;\r\nelse if (srate < 45000000)\r\nbclk = 0x95;\r\nm1 = 0x14;\r\nif (srate < 4000000)\r\nm1 = 0x10;\r\nstv0299_writereg(fe, 0x13, aclk);\r\nstv0299_writereg(fe, 0x14, bclk);\r\nstv0299_writereg(fe, 0x1f, (ratio >> 16) & 0xff);\r\nstv0299_writereg(fe, 0x20, (ratio >> 8) & 0xff);\r\nstv0299_writereg(fe, 0x21, (ratio) & 0xf0);\r\nstv0299_writereg(fe, 0x0f, 0x80 | m1);\r\nreturn 0;\r\n}\r\nstatic int philips_su1278_ty_ci_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu32 div;\r\nu8 buf[4];\r\nstruct budget *budget = (struct budget *) fe->dvb->priv;\r\nstruct i2c_msg msg = {.addr = 0x61,.flags = 0,.buf = buf,.len = sizeof(buf) };\r\nif ((c->frequency < 950000) || (c->frequency > 2150000))\r\nreturn -EINVAL;\r\ndiv = (c->frequency + (125 - 1)) / 125;\r\nbuf[0] = (div >> 8) & 0x7f;\r\nbuf[1] = div & 0xff;\r\nbuf[2] = 0x80 | ((div & 0x18000) >> 10) | 4;\r\nbuf[3] = 0x20;\r\nif (c->symbol_rate < 4000000)\r\nbuf[3] |= 1;\r\nif (c->frequency < 1250000)\r\nbuf[3] |= 0;\r\nelse if (c->frequency < 1550000)\r\nbuf[3] |= 0x40;\r\nelse if (c->frequency < 2050000)\r\nbuf[3] |= 0x80;\r\nelse if (c->frequency < 2150000)\r\nbuf[3] |= 0xC0;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&budget->i2c_adap, &msg, 1) != 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int philips_cu1216_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct budget *budget = (struct budget *) fe->dvb->priv;\r\nu8 buf[6];\r\nstruct i2c_msg msg = {.addr = 0x60,.flags = 0,.buf = buf,.len = sizeof(buf) };\r\nint i;\r\n#define CU1216_IF 36125000\r\n#define TUNER_MUL 62500\r\nu32 div = (c->frequency + CU1216_IF + TUNER_MUL / 2) / TUNER_MUL;\r\nbuf[0] = (div >> 8) & 0x7f;\r\nbuf[1] = div & 0xff;\r\nbuf[2] = 0xce;\r\nbuf[3] = (c->frequency < 150000000 ? 0x01 :\r\nc->frequency < 445000000 ? 0x02 : 0x04);\r\nbuf[4] = 0xde;\r\nbuf[5] = 0x20;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&budget->i2c_adap, &msg, 1) != 1)\r\nreturn -EIO;\r\nmsg.flags = I2C_M_RD;\r\nmsg.len = 1;\r\nfor (i = 0; i < 20; i++) {\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&budget->i2c_adap, &msg, 1) == 1 && (buf[0] & 0x40))\r\nbreak;\r\nmsleep(10);\r\n}\r\nmsg.flags = 0;\r\nmsg.len = 2;\r\nmsg.buf = &buf[2];\r\nbuf[2] &= ~0x40;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&budget->i2c_adap, &msg, 1) != 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int philips_tu1216_tuner_init(struct dvb_frontend *fe)\r\n{\r\nstruct budget *budget = (struct budget *) fe->dvb->priv;\r\nstatic u8 tu1216_init[] = { 0x0b, 0xf5, 0x85, 0xab };\r\nstruct i2c_msg tuner_msg = {.addr = 0x60,.flags = 0,.buf = tu1216_init,.len = sizeof(tu1216_init) };\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&budget->i2c_adap, &tuner_msg, 1) != 1)\r\nreturn -EIO;\r\nmsleep(1);\r\nreturn 0;\r\n}\r\nstatic int philips_tu1216_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct budget *budget = (struct budget *) fe->dvb->priv;\r\nu8 tuner_buf[4];\r\nstruct i2c_msg tuner_msg = {.addr = 0x60,.flags = 0,.buf = tuner_buf,.len =\r\nsizeof(tuner_buf) };\r\nint tuner_frequency = 0;\r\nu8 band, cp, filter;\r\ntuner_frequency = c->frequency + 36166000;\r\nif (tuner_frequency < 87000000)\r\nreturn -EINVAL;\r\nelse if (tuner_frequency < 130000000)\r\ncp = 3;\r\nelse if (tuner_frequency < 160000000)\r\ncp = 5;\r\nelse if (tuner_frequency < 200000000)\r\ncp = 6;\r\nelse if (tuner_frequency < 290000000)\r\ncp = 3;\r\nelse if (tuner_frequency < 420000000)\r\ncp = 5;\r\nelse if (tuner_frequency < 480000000)\r\ncp = 6;\r\nelse if (tuner_frequency < 620000000)\r\ncp = 3;\r\nelse if (tuner_frequency < 830000000)\r\ncp = 5;\r\nelse if (tuner_frequency < 895000000)\r\ncp = 7;\r\nelse\r\nreturn -EINVAL;\r\nif (c->frequency < 49000000)\r\nreturn -EINVAL;\r\nelse if (c->frequency < 161000000)\r\nband = 1;\r\nelse if (c->frequency < 444000000)\r\nband = 2;\r\nelse if (c->frequency < 861000000)\r\nband = 4;\r\nelse\r\nreturn -EINVAL;\r\nswitch (c->bandwidth_hz) {\r\ncase 6000000:\r\nfilter = 0;\r\nbreak;\r\ncase 7000000:\r\nfilter = 0;\r\nbreak;\r\ncase 8000000:\r\nfilter = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ntuner_frequency = (((c->frequency / 1000) * 6) + 217496) / 1000;\r\ntuner_buf[0] = (tuner_frequency >> 8) & 0x7f;\r\ntuner_buf[1] = tuner_frequency & 0xff;\r\ntuner_buf[2] = 0xca;\r\ntuner_buf[3] = (cp << 5) | (filter << 3) | band;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (i2c_transfer(&budget->i2c_adap, &tuner_msg, 1) != 1)\r\nreturn -EIO;\r\nmsleep(1);\r\nreturn 0;\r\n}\r\nstatic int philips_tu1216_request_firmware(struct dvb_frontend *fe,\r\nconst struct firmware **fw, char *name)\r\n{\r\nstruct budget *budget = (struct budget *) fe->dvb->priv;\r\nreturn request_firmware(fw, name, &budget->dev->pci->dev);\r\n}\r\nstatic int philips_sd1878_ci_set_symbol_rate(struct dvb_frontend *fe,\r\nu32 srate, u32 ratio)\r\n{\r\nu8 aclk = 0;\r\nu8 bclk = 0;\r\nu8 m1;\r\naclk = 0xb5;\r\nif (srate < 2000000)\r\nbclk = 0x86;\r\nelse if (srate < 5000000)\r\nbclk = 0x89;\r\nelse if (srate < 15000000)\r\nbclk = 0x8f;\r\nelse if (srate < 45000000)\r\nbclk = 0x95;\r\nm1 = 0x14;\r\nif (srate < 4000000)\r\nm1 = 0x10;\r\nstv0299_writereg(fe, 0x0e, 0x23);\r\nstv0299_writereg(fe, 0x0f, 0x94);\r\nstv0299_writereg(fe, 0x10, 0x39);\r\nstv0299_writereg(fe, 0x13, aclk);\r\nstv0299_writereg(fe, 0x14, bclk);\r\nstv0299_writereg(fe, 0x15, 0xc9);\r\nstv0299_writereg(fe, 0x1f, (ratio >> 16) & 0xff);\r\nstv0299_writereg(fe, 0x20, (ratio >> 8) & 0xff);\r\nstv0299_writereg(fe, 0x21, (ratio) & 0xf0);\r\nstv0299_writereg(fe, 0x0f, 0x80 | m1);\r\nreturn 0;\r\n}\r\nstatic u8 read_pwm(struct budget_av *budget_av)\r\n{\r\nu8 b = 0xff;\r\nu8 pwm;\r\nstruct i2c_msg msg[] = { {.addr = 0x50,.flags = 0,.buf = &b,.len = 1},\r\n{.addr = 0x50,.flags = I2C_M_RD,.buf = &pwm,.len = 1}\r\n};\r\nif ((i2c_transfer(&budget_av->budget.i2c_adap, msg, 2) != 2)\r\n|| (pwm == 0xff))\r\npwm = 0x48;\r\nreturn pwm;\r\n}\r\nstatic void frontend_init(struct budget_av *budget_av)\r\n{\r\nstruct saa7146_dev * saa = budget_av->budget.dev;\r\nstruct dvb_frontend * fe = NULL;\r\nsaa7146_setgpio(saa, 0, SAA7146_GPIO_OUTLO);\r\nmsleep(100);\r\nswitch (saa->pci->subsystem_device) {\r\ncase SUBID_DVBS_KNC1_PLUS:\r\ncase SUBID_DVBC_KNC1_PLUS:\r\ncase SUBID_DVBT_KNC1_PLUS:\r\ncase SUBID_DVBC_EASYWATCH:\r\ncase SUBID_DVBC_KNC1_PLUS_MK3:\r\ncase SUBID_DVBS2_KNC1:\r\ncase SUBID_DVBS2_KNC1_OEM:\r\ncase SUBID_DVBS2_EASYWATCH:\r\nsaa7146_setgpio(saa, 3, SAA7146_GPIO_OUTHI);\r\nbreak;\r\n}\r\nswitch (saa->pci->subsystem_device) {\r\ncase SUBID_DVBS_KNC1:\r\nbudget_av->reinitialise_demod = 1;\r\ncase SUBID_DVBS_KNC1_PLUS:\r\ncase SUBID_DVBS_EASYWATCH_1:\r\nif (saa->pci->subsystem_vendor == 0x1894) {\r\nfe = dvb_attach(stv0299_attach, &cinergy_1200s_1894_0010_config,\r\n&budget_av->budget.i2c_adap);\r\nif (fe) {\r\ndvb_attach(tua6100_attach, fe, 0x60, &budget_av->budget.i2c_adap);\r\n}\r\n} else {\r\nfe = dvb_attach(stv0299_attach, &typhoon_config,\r\n&budget_av->budget.i2c_adap);\r\nif (fe) {\r\nfe->ops.tuner_ops.set_params = philips_su1278_ty_ci_tuner_set_params;\r\n}\r\n}\r\nbreak;\r\ncase SUBID_DVBS_TV_STAR:\r\ncase SUBID_DVBS_TV_STAR_PLUS_X4:\r\ncase SUBID_DVBS_TV_STAR_CI:\r\ncase SUBID_DVBS_CYNERGY1200N:\r\ncase SUBID_DVBS_EASYWATCH:\r\ncase SUBID_DVBS_EASYWATCH_2:\r\nfe = dvb_attach(stv0299_attach, &philips_sd1878_config,\r\n&budget_av->budget.i2c_adap);\r\nif (fe) {\r\ndvb_attach(dvb_pll_attach, fe, 0x60,\r\n&budget_av->budget.i2c_adap,\r\nDVB_PLL_PHILIPS_SD1878_TDA8261);\r\n}\r\nbreak;\r\ncase SUBID_DVBS_TYPHOON:\r\nfe = dvb_attach(stv0299_attach, &typhoon_config,\r\n&budget_av->budget.i2c_adap);\r\nif (fe) {\r\nfe->ops.tuner_ops.set_params = philips_su1278_ty_ci_tuner_set_params;\r\n}\r\nbreak;\r\ncase SUBID_DVBS2_KNC1:\r\ncase SUBID_DVBS2_KNC1_OEM:\r\ncase SUBID_DVBS2_EASYWATCH:\r\nbudget_av->reinitialise_demod = 1;\r\nif ((fe = dvb_attach(stb0899_attach, &knc1_dvbs2_config, &budget_av->budget.i2c_adap)))\r\ndvb_attach(tda8261_attach, fe, &sd1878c_config, &budget_av->budget.i2c_adap);\r\nbreak;\r\ncase SUBID_DVBS_CINERGY1200:\r\nfe = dvb_attach(stv0299_attach, &cinergy_1200s_config,\r\n&budget_av->budget.i2c_adap);\r\nif (fe) {\r\nfe->ops.tuner_ops.set_params = philips_su1278_ty_ci_tuner_set_params;\r\n}\r\nbreak;\r\ncase SUBID_DVBC_KNC1:\r\ncase SUBID_DVBC_KNC1_PLUS:\r\ncase SUBID_DVBC_CINERGY1200:\r\ncase SUBID_DVBC_EASYWATCH:\r\nbudget_av->reinitialise_demod = 1;\r\nbudget_av->budget.dev->i2c_bitrate = SAA7146_I2C_BUS_BIT_RATE_240;\r\nfe = dvb_attach(tda10021_attach, &philips_cu1216_config,\r\n&budget_av->budget.i2c_adap,\r\nread_pwm(budget_av));\r\nif (fe == NULL)\r\nfe = dvb_attach(tda10021_attach, &philips_cu1216_config_altaddress,\r\n&budget_av->budget.i2c_adap,\r\nread_pwm(budget_av));\r\nif (fe) {\r\nfe->ops.tuner_ops.set_params = philips_cu1216_tuner_set_params;\r\n}\r\nbreak;\r\ncase SUBID_DVBC_EASYWATCH_MK3:\r\ncase SUBID_DVBC_CINERGY1200_MK3:\r\ncase SUBID_DVBC_KNC1_MK3:\r\ncase SUBID_DVBC_KNC1_TDA10024:\r\ncase SUBID_DVBC_KNC1_PLUS_MK3:\r\nbudget_av->reinitialise_demod = 1;\r\nbudget_av->budget.dev->i2c_bitrate = SAA7146_I2C_BUS_BIT_RATE_240;\r\nfe = dvb_attach(tda10023_attach,\r\n&philips_cu1216_tda10023_config,\r\n&budget_av->budget.i2c_adap,\r\nread_pwm(budget_av));\r\nif (fe) {\r\nfe->ops.tuner_ops.set_params = philips_cu1216_tuner_set_params;\r\n}\r\nbreak;\r\ncase SUBID_DVBT_EASYWATCH:\r\ncase SUBID_DVBT_KNC1:\r\ncase SUBID_DVBT_KNC1_PLUS:\r\ncase SUBID_DVBT_CINERGY1200:\r\nbudget_av->reinitialise_demod = 1;\r\nfe = dvb_attach(tda10046_attach, &philips_tu1216_config,\r\n&budget_av->budget.i2c_adap);\r\nif (fe) {\r\nfe->ops.tuner_ops.init = philips_tu1216_tuner_init;\r\nfe->ops.tuner_ops.set_params = philips_tu1216_tuner_set_params;\r\n}\r\nbreak;\r\n}\r\nif (fe == NULL) {\r\npr_err("A frontend driver was not found for device [%04x:%04x] subsystem [%04x:%04x]\n",\r\nsaa->pci->vendor,\r\nsaa->pci->device,\r\nsaa->pci->subsystem_vendor,\r\nsaa->pci->subsystem_device);\r\nreturn;\r\n}\r\nbudget_av->budget.dvb_frontend = fe;\r\nif (dvb_register_frontend(&budget_av->budget.dvb_adapter,\r\nbudget_av->budget.dvb_frontend)) {\r\npr_err("Frontend registration failed!\n");\r\ndvb_frontend_detach(budget_av->budget.dvb_frontend);\r\nbudget_av->budget.dvb_frontend = NULL;\r\n}\r\n}\r\nstatic void budget_av_irq(struct saa7146_dev *dev, u32 * isr)\r\n{\r\nstruct budget_av *budget_av = (struct budget_av *) dev->ext_priv;\r\ndprintk(8, "dev: %p, budget_av: %p\n", dev, budget_av);\r\nif (*isr & MASK_10)\r\nttpci_budget_irq10_handler(dev, isr);\r\n}\r\nstatic int budget_av_detach(struct saa7146_dev *dev)\r\n{\r\nstruct budget_av *budget_av = (struct budget_av *) dev->ext_priv;\r\nint err;\r\ndprintk(2, "dev: %p\n", dev);\r\nif (1 == budget_av->has_saa7113) {\r\nsaa7146_setgpio(dev, 0, SAA7146_GPIO_OUTLO);\r\nmsleep(200);\r\nsaa7146_unregister_device(&budget_av->vd, dev);\r\nsaa7146_vv_release(dev);\r\n}\r\nif (budget_av->budget.ci_present)\r\nciintf_deinit(budget_av);\r\nif (budget_av->budget.dvb_frontend != NULL) {\r\ndvb_unregister_frontend(budget_av->budget.dvb_frontend);\r\ndvb_frontend_detach(budget_av->budget.dvb_frontend);\r\n}\r\nerr = ttpci_budget_deinit(&budget_av->budget);\r\nkfree(budget_av);\r\nreturn err;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *fh, struct v4l2_input *i)\r\n{\r\ndprintk(1, "VIDIOC_ENUMINPUT %d\n", i->index);\r\nif (i->index >= KNC1_INPUTS)\r\nreturn -EINVAL;\r\nmemcpy(i, &knc1_inputs[i->index], sizeof(struct v4l2_input));\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *fh, unsigned int *i)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct budget_av *budget_av = (struct budget_av *)dev->ext_priv;\r\n*i = budget_av->cur_input;\r\ndprintk(1, "VIDIOC_G_INPUT %d\n", *i);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *fh, unsigned int input)\r\n{\r\nstruct saa7146_dev *dev = ((struct saa7146_fh *)fh)->dev;\r\nstruct budget_av *budget_av = (struct budget_av *)dev->ext_priv;\r\ndprintk(1, "VIDIOC_S_INPUT %d\n", input);\r\nreturn saa7113_setinput(budget_av, input);\r\n}\r\nstatic int budget_av_attach(struct saa7146_dev *dev, struct saa7146_pci_extension_data *info)\r\n{\r\nstruct budget_av *budget_av;\r\nu8 *mac;\r\nint err;\r\ndprintk(2, "dev: %p\n", dev);\r\nif (!(budget_av = kzalloc(sizeof(struct budget_av), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nbudget_av->has_saa7113 = 0;\r\nbudget_av->budget.ci_present = 0;\r\ndev->ext_priv = budget_av;\r\nerr = ttpci_budget_init(&budget_av->budget, dev, info, THIS_MODULE,\r\nadapter_nr);\r\nif (err) {\r\nkfree(budget_av);\r\nreturn err;\r\n}\r\nsaa7146_write(dev, DD1_STREAM_B, 0x04000000);\r\nsaa7146_write(dev, DD1_INIT, 0x07000600);\r\nsaa7146_write(dev, MC2, MASK_09 | MASK_25 | MASK_10 | MASK_26);\r\nif (saa7113_init(budget_av) == 0) {\r\nbudget_av->has_saa7113 = 1;\r\nif (0 != saa7146_vv_init(dev, &vv_data)) {\r\nERR("cannot init vv subsystem\n");\r\nreturn err;\r\n}\r\nvv_data.ops.vidioc_enum_input = vidioc_enum_input;\r\nvv_data.ops.vidioc_g_input = vidioc_g_input;\r\nvv_data.ops.vidioc_s_input = vidioc_s_input;\r\nif ((err = saa7146_register_device(&budget_av->vd, dev, "knc1", VFL_TYPE_GRABBER))) {\r\nERR("cannot register capture v4l2 device\n");\r\nsaa7146_vv_release(dev);\r\nreturn err;\r\n}\r\nsaa7146_set_hps_source_and_sync(dev, SAA7146_HPS_SOURCE_PORT_A,\r\nSAA7146_HPS_SYNC_PORT_A);\r\nsaa7113_setinput(budget_av, 0);\r\n}\r\nsaa7146_write(dev, PCI_BT_V1, 0x1c00101f);\r\nmac = budget_av->budget.dvb_adapter.proposed_mac;\r\nif (i2c_readregs(&budget_av->budget.i2c_adap, 0xa0, 0x30, mac, 6)) {\r\npr_err("KNC1-%d: Could not read MAC from KNC1 card\n",\r\nbudget_av->budget.dvb_adapter.num);\r\nmemset(mac, 0, 6);\r\n} else {\r\npr_info("KNC1-%d: MAC addr = %pM\n",\r\nbudget_av->budget.dvb_adapter.num, mac);\r\n}\r\nbudget_av->budget.dvb_adapter.priv = budget_av;\r\nfrontend_init(budget_av);\r\nciintf_init(budget_av);\r\nttpci_budget_init_hooks(&budget_av->budget);\r\nreturn 0;\r\n}\r\nstatic int __init budget_av_init(void)\r\n{\r\nreturn saa7146_register_extension(&budget_extension);\r\n}\r\nstatic void __exit budget_av_exit(void)\r\n{\r\nsaa7146_unregister_extension(&budget_extension);\r\n}
