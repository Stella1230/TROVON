static int pdc2026x_cable_detect(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nu16 cis;\r\npci_read_config_word(pdev, 0x50, &cis);\r\nif (cis & (1 << (10 + ap->port_no)))\r\nreturn ATA_CBL_PATA40;\r\nreturn ATA_CBL_PATA80;\r\n}\r\nstatic void pdc202xx_exec_command(struct ata_port *ap,\r\nconst struct ata_taskfile *tf)\r\n{\r\nDPRINTK("ata%u: cmd 0x%X\n", ap->print_id, tf->command);\r\niowrite8(tf->command, ap->ioaddr.command_addr);\r\nndelay(400);\r\n}\r\nstatic bool pdc202xx_irq_check(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nunsigned long master = pci_resource_start(pdev, 4);\r\nu8 sc1d = inb(master + 0x1d);\r\nif (ap->port_no) {\r\nreturn sc1d & 0x40;\r\n} else {\r\nreturn sc1d & 0x04;\r\n}\r\n}\r\nstatic void pdc202xx_configure_piomode(struct ata_port *ap, struct ata_device *adev, int pio)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nint port = 0x60 + 8 * ap->port_no + 4 * adev->devno;\r\nstatic u16 pio_timing[5] = {\r\n0x0913, 0x050C , 0x0308, 0x0206, 0x0104\r\n};\r\nu8 r_ap, r_bp;\r\npci_read_config_byte(pdev, port, &r_ap);\r\npci_read_config_byte(pdev, port + 1, &r_bp);\r\nr_ap &= ~0x3F;\r\nr_bp &= ~0x1F;\r\nr_ap |= (pio_timing[pio] >> 8);\r\nr_bp |= (pio_timing[pio] & 0xFF);\r\nif (ata_pio_need_iordy(adev))\r\nr_ap |= 0x20;\r\nif (adev->class == ATA_DEV_ATA)\r\nr_ap |= 0x10;\r\npci_write_config_byte(pdev, port, r_ap);\r\npci_write_config_byte(pdev, port + 1, r_bp);\r\n}\r\nstatic void pdc202xx_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\npdc202xx_configure_piomode(ap, adev, adev->pio_mode - XFER_PIO_0);\r\n}\r\nstatic void pdc202xx_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nint port = 0x60 + 8 * ap->port_no + 4 * adev->devno;\r\nstatic u8 udma_timing[6][2] = {\r\n{ 0x60, 0x03 },\r\n{ 0x40, 0x02 },\r\n{ 0x20, 0x01 },\r\n{ 0x40, 0x02 },\r\n{ 0x20, 0x01 },\r\n{ 0x20, 0x01 }\r\n};\r\nstatic u8 mdma_timing[3][2] = {\r\n{ 0xe0, 0x0f },\r\n{ 0x60, 0x04 },\r\n{ 0x60, 0x03 },\r\n};\r\nu8 r_bp, r_cp;\r\npci_read_config_byte(pdev, port + 1, &r_bp);\r\npci_read_config_byte(pdev, port + 2, &r_cp);\r\nr_bp &= ~0xE0;\r\nr_cp &= ~0x0F;\r\nif (adev->dma_mode >= XFER_UDMA_0) {\r\nint speed = adev->dma_mode - XFER_UDMA_0;\r\nr_bp |= udma_timing[speed][0];\r\nr_cp |= udma_timing[speed][1];\r\n} else {\r\nint speed = adev->dma_mode - XFER_MW_DMA_0;\r\nr_bp |= mdma_timing[speed][0];\r\nr_cp |= mdma_timing[speed][1];\r\n}\r\npci_write_config_byte(pdev, port + 1, r_bp);\r\npci_write_config_byte(pdev, port + 2, r_cp);\r\n}\r\nstatic void pdc2026x_bmdma_start(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct ata_device *adev = qc->dev;\r\nstruct ata_taskfile *tf = &qc->tf;\r\nint sel66 = ap->port_no ? 0x08: 0x02;\r\nvoid __iomem *master = ap->host->ports[0]->ioaddr.bmdma_addr;\r\nvoid __iomem *clock = master + 0x11;\r\nvoid __iomem *atapi_reg = master + 0x20 + (4 * ap->port_no);\r\nu32 len;\r\nif (adev->dma_mode > XFER_UDMA_2)\r\niowrite8(ioread8(clock) | sel66, clock);\r\nelse\r\niowrite8(ioread8(clock) & ~sel66, clock);\r\npdc202xx_set_dmamode(ap, qc->dev);\r\nif ((tf->flags & ATA_TFLAG_LBA48) || tf->protocol == ATAPI_PROT_DMA) {\r\nlen = qc->nbytes / 2;\r\nif (tf->flags & ATA_TFLAG_WRITE)\r\nlen |= 0x06000000;\r\nelse\r\nlen |= 0x05000000;\r\niowrite32(len, atapi_reg);\r\n}\r\nata_bmdma_start(qc);\r\n}\r\nstatic void pdc2026x_bmdma_stop(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct ata_device *adev = qc->dev;\r\nstruct ata_taskfile *tf = &qc->tf;\r\nint sel66 = ap->port_no ? 0x08: 0x02;\r\nvoid __iomem *master = ap->host->ports[0]->ioaddr.bmdma_addr;\r\nvoid __iomem *clock = master + 0x11;\r\nvoid __iomem *atapi_reg = master + 0x20 + (4 * ap->port_no);\r\nif (tf->protocol == ATAPI_PROT_DMA || (tf->flags & ATA_TFLAG_LBA48)) {\r\niowrite32(0, atapi_reg);\r\niowrite8(ioread8(clock) & ~sel66, clock);\r\n}\r\nif (adev->dma_mode > XFER_UDMA_2)\r\niowrite8(ioread8(clock) & ~sel66, clock);\r\nata_bmdma_stop(qc);\r\npdc202xx_set_piomode(ap, adev);\r\n}\r\nstatic void pdc2026x_dev_config(struct ata_device *adev)\r\n{\r\nadev->max_sectors = 256;\r\n}\r\nstatic int pdc2026x_port_start(struct ata_port *ap)\r\n{\r\nvoid __iomem *bmdma = ap->ioaddr.bmdma_addr;\r\nif (bmdma) {\r\nu8 burst = ioread8(bmdma + 0x1f);\r\niowrite8(burst | 0x01, bmdma + 0x1f);\r\n}\r\nreturn ata_bmdma_port_start(ap);\r\n}\r\nstatic int pdc2026x_check_atapi_dma(struct ata_queued_cmd *qc)\r\n{\r\nreturn 1;\r\n}\r\nstatic int pdc202xx_init_one(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nstatic const struct ata_port_info info[3] = {\r\n{\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA2,\r\n.port_ops = &pdc2024x_port_ops\r\n},\r\n{\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA4,\r\n.port_ops = &pdc2026x_port_ops\r\n},\r\n{\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA5,\r\n.port_ops = &pdc2026x_port_ops\r\n}\r\n};\r\nconst struct ata_port_info *ppi[] = { &info[id->driver_data], NULL };\r\nif (dev->device == PCI_DEVICE_ID_PROMISE_20265) {\r\nstruct pci_dev *bridge = dev->bus->self;\r\nif (bridge && bridge->vendor == PCI_VENDOR_ID_INTEL) {\r\nif (bridge->device == PCI_DEVICE_ID_INTEL_I960)\r\nreturn -ENODEV;\r\nif (bridge->device == PCI_DEVICE_ID_INTEL_I960RM)\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn ata_pci_bmdma_init_one(dev, ppi, &pdc202xx_sht, NULL, 0);\r\n}\r\nstatic int __init pdc202xx_init(void)\r\n{\r\nreturn pci_register_driver(&pdc202xx_pci_driver);\r\n}\r\nstatic void __exit pdc202xx_exit(void)\r\n{\r\npci_unregister_driver(&pdc202xx_pci_driver);\r\n}
