static const char *board_type_str(void)\r\n{\r\nswitch (BCSR_WHOAMI_BOARD(bcsr_read(BCSR_WHOAMI))) {\r\ncase BCSR_WHOAMI_PB1200_DDR1:\r\ncase BCSR_WHOAMI_PB1200_DDR2:\r\nreturn "PB1200";\r\ncase BCSR_WHOAMI_DB1200:\r\nreturn "DB1200";\r\ndefault:\r\nreturn "(unknown)";\r\n}\r\n}\r\nconst char *get_system_type(void)\r\n{\r\nreturn board_type_str();\r\n}\r\nstatic int __init detect_board(void)\r\n{\r\nint bid;\r\nbcsr_init(DB1200_BCSR_PHYS_ADDR,\r\nDB1200_BCSR_PHYS_ADDR + DB1200_BCSR_HEXLED_OFS);\r\nif (BCSR_WHOAMI_DB1200 == BCSR_WHOAMI_BOARD(bcsr_read(BCSR_WHOAMI))) {\r\nunsigned short t = bcsr_read(BCSR_HEXLEDS);\r\nbcsr_write(BCSR_HEXLEDS, ~t);\r\nif (bcsr_read(BCSR_HEXLEDS) != t) {\r\nbcsr_write(BCSR_HEXLEDS, t);\r\nreturn 0;\r\n}\r\n}\r\nbcsr_init(PB1200_BCSR_PHYS_ADDR,\r\nPB1200_BCSR_PHYS_ADDR + PB1200_BCSR_HEXLED_OFS);\r\nbid = BCSR_WHOAMI_BOARD(bcsr_read(BCSR_WHOAMI));\r\nif ((bid == BCSR_WHOAMI_PB1200_DDR1) ||\r\n(bid == BCSR_WHOAMI_PB1200_DDR2)) {\r\nunsigned short t = bcsr_read(BCSR_HEXLEDS);\r\nbcsr_write(BCSR_HEXLEDS, ~t);\r\nif (bcsr_read(BCSR_HEXLEDS) != t) {\r\nbcsr_write(BCSR_HEXLEDS, t);\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nvoid __init board_setup(void)\r\n{\r\nunsigned long freq0, clksrc, div, pfc;\r\nunsigned short whoami;\r\nif (detect_board()) {\r\nprintk(KERN_ERR "NOT running on a DB1200/PB1200 board!\n");\r\nreturn;\r\n}\r\nwhoami = bcsr_read(BCSR_WHOAMI);\r\nprintk(KERN_INFO "Alchemy/AMD/RMI %s Board, CPLD Rev %d"\r\n" Board-ID %d Daughtercard ID %d\n", board_type_str(),\r\n(whoami >> 4) & 0xf, (whoami >> 8) & 0xf, whoami & 0xf);\r\npfc = __raw_readl((void __iomem *)SYS_PINFUNC);\r\npfc &= ~(SYS_PINFUNC_P0A | SYS_PINFUNC_P0B);\r\npfc &= ~(SYS_PINFUNC_P1A | SYS_PINFUNC_P1B | SYS_PINFUNC_FS3);\r\npfc |= SYS_PINFUNC_P1C;\r\n__raw_writel(pfc, (void __iomem *)SYS_PINFUNC);\r\nwmb();\r\ndiv = (get_au1x00_speed() + 25000000) / 50000000;\r\nif (div & 1)\r\ndiv++;\r\ndiv = ((div >> 1) - 1) & 0xff;\r\nfreq0 = div << SYS_FC_FRDIV0_BIT;\r\n__raw_writel(freq0, (void __iomem *)SYS_FREQCTRL0);\r\nwmb();\r\nfreq0 |= SYS_FC_FE0;\r\n__raw_writel(freq0, (void __iomem *)SYS_FREQCTRL0);\r\nwmb();\r\nclksrc = SYS_CS_MUX_FQ0 << SYS_CS_ME0_BIT;\r\n__raw_writel(clksrc, (void __iomem *)SYS_CLKSRC);\r\nwmb();\r\n}\r\nstatic void au1200_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nunsigned long ioaddr = (unsigned long)this->IO_ADDR_W;\r\nioaddr &= 0xffffff00;\r\nif (ctrl & NAND_CLE) {\r\nioaddr += MEM_STNAND_CMD;\r\n} else if (ctrl & NAND_ALE) {\r\nioaddr += MEM_STNAND_ADDR;\r\n} else {\r\nioaddr += MEM_STNAND_DATA;\r\n}\r\nthis->IO_ADDR_R = this->IO_ADDR_W = (void __iomem *)ioaddr;\r\nif (cmd != NAND_CMD_NONE) {\r\n__raw_writeb(cmd, this->IO_ADDR_W);\r\nwmb();\r\n}\r\n}\r\nstatic int au1200_nand_device_ready(struct mtd_info *mtd)\r\n{\r\nreturn __raw_readl((void __iomem *)MEM_STSTAT) & 1;\r\n}\r\nstatic irqreturn_t db1200_mmc_cd(int irq, void *ptr)\r\n{\r\nvoid(*mmc_cd)(struct mmc_host *, unsigned long);\r\nif (irq == DB1200_SD0_INSERT_INT) {\r\ndisable_irq_nosync(DB1200_SD0_INSERT_INT);\r\nenable_irq(DB1200_SD0_EJECT_INT);\r\n} else {\r\ndisable_irq_nosync(DB1200_SD0_EJECT_INT);\r\nenable_irq(DB1200_SD0_INSERT_INT);\r\n}\r\nmmc_cd = symbol_get(mmc_detect_change);\r\nif (mmc_cd) {\r\nmmc_cd(ptr, msecs_to_jiffies(500));\r\nsymbol_put(mmc_detect_change);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int db1200_mmc_cd_setup(void *mmc_host, int en)\r\n{\r\nint ret;\r\nif (en) {\r\nret = request_irq(DB1200_SD0_INSERT_INT, db1200_mmc_cd,\r\n0, "sd_insert", mmc_host);\r\nif (ret)\r\ngoto out;\r\nret = request_irq(DB1200_SD0_EJECT_INT, db1200_mmc_cd,\r\n0, "sd_eject", mmc_host);\r\nif (ret) {\r\nfree_irq(DB1200_SD0_INSERT_INT, mmc_host);\r\ngoto out;\r\n}\r\nif (bcsr_read(BCSR_SIGSTAT) & BCSR_INT_SD0INSERT)\r\nenable_irq(DB1200_SD0_EJECT_INT);\r\nelse\r\nenable_irq(DB1200_SD0_INSERT_INT);\r\n} else {\r\nfree_irq(DB1200_SD0_INSERT_INT, mmc_host);\r\nfree_irq(DB1200_SD0_EJECT_INT, mmc_host);\r\n}\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic void db1200_mmc_set_power(void *mmc_host, int state)\r\n{\r\nif (state) {\r\nbcsr_mod(BCSR_BOARD, 0, BCSR_BOARD_SD0PWR);\r\nmsleep(400);\r\n} else\r\nbcsr_mod(BCSR_BOARD, BCSR_BOARD_SD0PWR, 0);\r\n}\r\nstatic int db1200_mmc_card_readonly(void *mmc_host)\r\n{\r\nreturn (bcsr_read(BCSR_STATUS) & BCSR_STATUS_SD0WP) ? 1 : 0;\r\n}\r\nstatic int db1200_mmc_card_inserted(void *mmc_host)\r\n{\r\nreturn (bcsr_read(BCSR_SIGSTAT) & BCSR_INT_SD0INSERT) ? 1 : 0;\r\n}\r\nstatic void db1200_mmcled_set(struct led_classdev *led,\r\nenum led_brightness brightness)\r\n{\r\nif (brightness != LED_OFF)\r\nbcsr_mod(BCSR_LEDS, BCSR_LEDS_LED0, 0);\r\nelse\r\nbcsr_mod(BCSR_LEDS, 0, BCSR_LEDS_LED0);\r\n}\r\nstatic irqreturn_t pb1200_mmc1_cd(int irq, void *ptr)\r\n{\r\nvoid(*mmc_cd)(struct mmc_host *, unsigned long);\r\nif (irq == PB1200_SD1_INSERT_INT) {\r\ndisable_irq_nosync(PB1200_SD1_INSERT_INT);\r\nenable_irq(PB1200_SD1_EJECT_INT);\r\n} else {\r\ndisable_irq_nosync(PB1200_SD1_EJECT_INT);\r\nenable_irq(PB1200_SD1_INSERT_INT);\r\n}\r\nmmc_cd = symbol_get(mmc_detect_change);\r\nif (mmc_cd) {\r\nmmc_cd(ptr, msecs_to_jiffies(500));\r\nsymbol_put(mmc_detect_change);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pb1200_mmc1_cd_setup(void *mmc_host, int en)\r\n{\r\nint ret;\r\nif (en) {\r\nret = request_irq(PB1200_SD1_INSERT_INT, pb1200_mmc1_cd, 0,\r\n"sd1_insert", mmc_host);\r\nif (ret)\r\ngoto out;\r\nret = request_irq(PB1200_SD1_EJECT_INT, pb1200_mmc1_cd, 0,\r\n"sd1_eject", mmc_host);\r\nif (ret) {\r\nfree_irq(PB1200_SD1_INSERT_INT, mmc_host);\r\ngoto out;\r\n}\r\nif (bcsr_read(BCSR_SIGSTAT) & BCSR_INT_SD1INSERT)\r\nenable_irq(PB1200_SD1_EJECT_INT);\r\nelse\r\nenable_irq(PB1200_SD1_INSERT_INT);\r\n} else {\r\nfree_irq(PB1200_SD1_INSERT_INT, mmc_host);\r\nfree_irq(PB1200_SD1_EJECT_INT, mmc_host);\r\n}\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic void pb1200_mmc1led_set(struct led_classdev *led,\r\nenum led_brightness brightness)\r\n{\r\nif (brightness != LED_OFF)\r\nbcsr_mod(BCSR_LEDS, BCSR_LEDS_LED1, 0);\r\nelse\r\nbcsr_mod(BCSR_LEDS, 0, BCSR_LEDS_LED1);\r\n}\r\nstatic void pb1200_mmc1_set_power(void *mmc_host, int state)\r\n{\r\nif (state) {\r\nbcsr_mod(BCSR_BOARD, 0, BCSR_BOARD_SD1PWR);\r\nmsleep(400);\r\n} else\r\nbcsr_mod(BCSR_BOARD, BCSR_BOARD_SD1PWR, 0);\r\n}\r\nstatic int pb1200_mmc1_card_readonly(void *mmc_host)\r\n{\r\nreturn (bcsr_read(BCSR_STATUS) & BCSR_STATUS_SD1WP) ? 1 : 0;\r\n}\r\nstatic int pb1200_mmc1_card_inserted(void *mmc_host)\r\n{\r\nreturn (bcsr_read(BCSR_SIGSTAT) & BCSR_INT_SD1INSERT) ? 1 : 0;\r\n}\r\nstatic int db1200fb_panel_index(void)\r\n{\r\nreturn (bcsr_read(BCSR_SWITCHES) >> 8) & 0x0f;\r\n}\r\nstatic int db1200fb_panel_init(void)\r\n{\r\nbcsr_mod(BCSR_BOARD, 0, BCSR_BOARD_LCDVEE | BCSR_BOARD_LCDVDD |\r\nBCSR_BOARD_LCDBL);\r\nreturn 0;\r\n}\r\nstatic int db1200fb_panel_shutdown(void)\r\n{\r\nbcsr_mod(BCSR_BOARD, BCSR_BOARD_LCDVEE | BCSR_BOARD_LCDVDD |\r\nBCSR_BOARD_LCDBL, 0);\r\nreturn 0;\r\n}\r\nstatic void db1200_spi_cs_en(struct au1550_spi_info *spi, int cs, int pol)\r\n{\r\nif (cs)\r\nbcsr_mod(BCSR_RESETS, 0, BCSR_RESETS_SPISEL);\r\nelse\r\nbcsr_mod(BCSR_RESETS, BCSR_RESETS_SPISEL, 0);\r\n}\r\nstatic int __init pb1200_res_fixup(void)\r\n{\r\nif (BCSR_WHOAMI_CPLD(bcsr_read(BCSR_WHOAMI)) <= 3) {\r\nprintk(KERN_ERR "WARNING!!!\n");\r\nprintk(KERN_ERR "WARNING!!!\n");\r\nprintk(KERN_ERR "PB1200 must be at CPLD rev 4. Please have\n");\r\nprintk(KERN_ERR "the board updated to latest revisions.\n");\r\nprintk(KERN_ERR "This software will not work reliably\n");\r\nprintk(KERN_ERR "on anything older than CPLD rev 4.!\n");\r\nprintk(KERN_ERR "WARNING!!!\n");\r\nprintk(KERN_ERR "WARNING!!!\n");\r\nreturn 1;\r\n}\r\ndb1200_nand_res[0].start = PB1200_NAND_PHYS_ADDR;\r\ndb1200_nand_res[0].end = PB1200_NAND_PHYS_ADDR + 0xff;\r\ndb1200_ide_res[0].start = PB1200_IDE_PHYS_ADDR;\r\ndb1200_ide_res[0].end = PB1200_IDE_PHYS_ADDR + DB1200_IDE_PHYS_LEN - 1;\r\ndb1200_eth_res[0].start = PB1200_ETH_PHYS_ADDR;\r\ndb1200_eth_res[0].end = PB1200_ETH_PHYS_ADDR + 0xff;\r\nreturn 0;\r\n}\r\nstatic int __init db1200_dev_init(void)\r\n{\r\nunsigned long pfc;\r\nunsigned short sw;\r\nint swapped, bid;\r\nbid = BCSR_WHOAMI_BOARD(bcsr_read(BCSR_WHOAMI));\r\nif ((bid == BCSR_WHOAMI_PB1200_DDR1) ||\r\n(bid == BCSR_WHOAMI_PB1200_DDR2)) {\r\nif (pb1200_res_fixup())\r\nreturn -ENODEV;\r\n}\r\nirq_set_irq_type(AU1200_GPIO7_INT, IRQ_TYPE_LEVEL_LOW);\r\nbcsr_init_irq(DB1200_INT_BEGIN, DB1200_INT_END, AU1200_GPIO7_INT);\r\nirq_set_status_flags(DB1200_SD0_INSERT_INT, IRQ_NOAUTOEN);\r\nirq_set_status_flags(DB1200_SD0_EJECT_INT, IRQ_NOAUTOEN);\r\nirq_set_status_flags(DB1200_PC0_INSERT_INT, IRQ_NOAUTOEN);\r\nirq_set_status_flags(DB1200_PC0_EJECT_INT, IRQ_NOAUTOEN);\r\nirq_set_status_flags(DB1200_PC1_INSERT_INT, IRQ_NOAUTOEN);\r\nirq_set_status_flags(DB1200_PC1_EJECT_INT, IRQ_NOAUTOEN);\r\ni2c_register_board_info(0, db1200_i2c_devs,\r\nARRAY_SIZE(db1200_i2c_devs));\r\nspi_register_board_info(db1200_spi_devs,\r\nARRAY_SIZE(db1200_i2c_devs));\r\npfc = __raw_readl((void __iomem *)SYS_PINFUNC) & ~SYS_PINFUNC_P0A;\r\ngpio_request(215, "otg-vbus");\r\ngpio_direction_output(215, 1);\r\nprintk(KERN_INFO "%s device configuration:\n", board_type_str());\r\nsw = bcsr_read(BCSR_SWITCHES);\r\nif (sw & BCSR_SWITCHES_DIP_8) {\r\ndb1200_devs[0] = &db1200_i2c_dev;\r\nbcsr_mod(BCSR_RESETS, BCSR_RESETS_PSC0MUX, 0);\r\npfc |= (2 << 17);\r\nprintk(KERN_INFO " S6.8 OFF: PSC0 mode I2C\n");\r\nprintk(KERN_INFO " OTG port VBUS supply available!\n");\r\n} else {\r\ndb1200_devs[0] = &db1200_spi_dev;\r\nbcsr_mod(BCSR_RESETS, 0, BCSR_RESETS_PSC0MUX);\r\npfc |= (1 << 17);\r\nprintk(KERN_INFO " S6.8 ON : PSC0 mode SPI\n");\r\nprintk(KERN_INFO " OTG port VBUS supply disabled\n");\r\n}\r\n__raw_writel(pfc, (void __iomem *)SYS_PINFUNC);\r\nwmb();\r\nsw &= BCSR_SWITCHES_DIP_8 | BCSR_SWITCHES_DIP_7;\r\nif (sw == BCSR_SWITCHES_DIP_8) {\r\nbcsr_mod(BCSR_RESETS, 0, BCSR_RESETS_PSC1MUX);\r\ndb1200_audio_dev.name = "au1xpsc_i2s";\r\ndb1200_sound_dev.name = "db1200-i2s";\r\nprintk(KERN_INFO " S6.7 ON : PSC1 mode I2S\n");\r\n} else {\r\nbcsr_mod(BCSR_RESETS, BCSR_RESETS_PSC1MUX, 0);\r\ndb1200_audio_dev.name = "au1xpsc_ac97";\r\ndb1200_sound_dev.name = "db1200-ac97";\r\nprintk(KERN_INFO " S6.7 OFF: PSC1 mode AC97\n");\r\n}\r\n__raw_writel(PSC_SEL_CLK_SERCLK,\r\n(void __iomem *)KSEG1ADDR(AU1550_PSC1_PHYS_ADDR) + PSC_SEL_OFFSET);\r\nwmb();\r\ndb1x_register_pcmcia_socket(\r\nAU1000_PCMCIA_ATTR_PHYS_ADDR,\r\nAU1000_PCMCIA_ATTR_PHYS_ADDR + 0x000400000 - 1,\r\nAU1000_PCMCIA_MEM_PHYS_ADDR,\r\nAU1000_PCMCIA_MEM_PHYS_ADDR + 0x000400000 - 1,\r\nAU1000_PCMCIA_IO_PHYS_ADDR,\r\nAU1000_PCMCIA_IO_PHYS_ADDR + 0x000010000 - 1,\r\nDB1200_PC0_INT, DB1200_PC0_INSERT_INT,\r\n0, DB1200_PC0_EJECT_INT, 0);\r\ndb1x_register_pcmcia_socket(\r\nAU1000_PCMCIA_ATTR_PHYS_ADDR + 0x004000000,\r\nAU1000_PCMCIA_ATTR_PHYS_ADDR + 0x004400000 - 1,\r\nAU1000_PCMCIA_MEM_PHYS_ADDR + 0x004000000,\r\nAU1000_PCMCIA_MEM_PHYS_ADDR + 0x004400000 - 1,\r\nAU1000_PCMCIA_IO_PHYS_ADDR + 0x004000000,\r\nAU1000_PCMCIA_IO_PHYS_ADDR + 0x004010000 - 1,\r\nDB1200_PC1_INT, DB1200_PC1_INSERT_INT,\r\n0, DB1200_PC1_EJECT_INT, 1);\r\nswapped = bcsr_read(BCSR_STATUS) & BCSR_STATUS_DB1200_SWAPBOOT;\r\ndb1x_register_norflash(64 << 20, 2, swapped);\r\nplatform_add_devices(db1200_devs, ARRAY_SIZE(db1200_devs));\r\nif ((bid == BCSR_WHOAMI_PB1200_DDR1) ||\r\n(bid == BCSR_WHOAMI_PB1200_DDR2))\r\nplatform_add_devices(pb1200_devs, ARRAY_SIZE(pb1200_devs));\r\nreturn 0;\r\n}
