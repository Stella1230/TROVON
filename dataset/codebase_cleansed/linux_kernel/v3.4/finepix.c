static int command(struct gspca_dev *gspca_dev,\r\nint order)\r\n{\r\nstatic u8 order_values[2][12] = {\r\n{0xc6, 0, 0, 0, 0, 0, 0, 0, 0x20, 0, 0, 0},\r\n{0xd3, 0, 0, 0, 0, 0, 0, 0x01, 0, 0, 0, 0},\r\n};\r\nmemcpy(gspca_dev->usb_buf, order_values[order], 12);\r\nreturn usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\nUSB_REQ_GET_STATUS,\r\nUSB_DIR_OUT | USB_TYPE_CLASS |\r\nUSB_RECIP_INTERFACE, 0, 0, gspca_dev->usb_buf,\r\n12, FPIX_TIMEOUT);\r\n}\r\nstatic void dostream(struct work_struct *work)\r\n{\r\nstruct usb_fpix *dev = container_of(work, struct usb_fpix, work_struct);\r\nstruct gspca_dev *gspca_dev = &dev->gspca_dev;\r\nstruct urb *urb = gspca_dev->urb[0];\r\nu8 *data = urb->transfer_buffer;\r\nint ret = 0;\r\nint len;\r\nmutex_lock(&gspca_dev->usb_lock);\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nPDEBUG(D_STREAM, "dostream started");\r\nagain:\r\nwhile (gspca_dev->present && gspca_dev->streaming) {\r\nmutex_lock(&gspca_dev->usb_lock);\r\nret = command(gspca_dev, 1);\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nif (ret < 0)\r\nbreak;\r\nif (!gspca_dev->present || !gspca_dev->streaming)\r\nbreak;\r\nfor (;;) {\r\nret = usb_bulk_msg(gspca_dev->dev,\r\nurb->pipe,\r\ndata,\r\nFPIX_MAX_TRANSFER,\r\n&len, FPIX_TIMEOUT);\r\nif (ret < 0) {\r\ngoto again;\r\n}\r\nif (!gspca_dev->present || !gspca_dev->streaming)\r\ngoto out;\r\nif (len < FPIX_MAX_TRANSFER ||\r\n(data[len - 2] == 0xff &&\r\ndata[len - 1] == 0xd9)) {\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\ndata, len);\r\nbreak;\r\n}\r\ngspca_frame_add(gspca_dev,\r\ngspca_dev->last_packet_type\r\n== LAST_PACKET\r\n? FIRST_PACKET : INTER_PACKET,\r\ndata, len);\r\n}\r\nmsleep(NEXT_FRAME_DELAY);\r\n}\r\nout:\r\nPDEBUG(D_STREAM, "dostream stopped");\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_fpix *dev = (struct usb_fpix *) gspca_dev;\r\nstruct cam *cam = &gspca_dev->cam;\r\ncam->cam_mode = fpix_mode;\r\ncam->nmodes = 1;\r\ncam->bulk = 1;\r\ncam->bulk_size = FPIX_MAX_TRANSFER;\r\nINIT_WORK(&dev->work_struct, dostream);\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct usb_fpix *dev = (struct usb_fpix *) gspca_dev;\r\nint ret, len;\r\nret = command(gspca_dev, 0);\r\nif (ret < 0) {\r\npr_err("init failed %d\n", ret);\r\nreturn ret;\r\n}\r\nret = usb_bulk_msg(gspca_dev->dev,\r\ngspca_dev->urb[0]->pipe,\r\ngspca_dev->urb[0]->transfer_buffer,\r\nFPIX_MAX_TRANSFER, &len,\r\nFPIX_TIMEOUT);\r\nif (ret < 0) {\r\npr_err("usb_bulk_msg failed %d\n", ret);\r\nreturn ret;\r\n}\r\nret = command(gspca_dev, 1);\r\nif (ret < 0) {\r\npr_err("frame request failed %d\n", ret);\r\nreturn ret;\r\n}\r\nusb_clear_halt(gspca_dev->dev, gspca_dev->urb[0]->pipe);\r\ndev->work_thread = create_singlethread_workqueue(MODULE_NAME);\r\nqueue_work(dev->work_thread, &dev->work_struct);\r\nreturn 0;\r\n}\r\nstatic void sd_stop0(struct gspca_dev *gspca_dev)\r\n{\r\nstruct usb_fpix *dev = (struct usb_fpix *) gspca_dev;\r\nmutex_unlock(&gspca_dev->usb_lock);\r\ndestroy_workqueue(dev->work_thread);\r\nmutex_lock(&gspca_dev->usb_lock);\r\ndev->work_thread = NULL;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id,\r\n&sd_desc,\r\nsizeof(struct usb_fpix),\r\nTHIS_MODULE);\r\n}
