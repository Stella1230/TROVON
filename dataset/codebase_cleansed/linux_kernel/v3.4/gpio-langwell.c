static void __iomem *gpio_reg(struct gpio_chip *chip, unsigned offset,\r\nenum GPIO_REG reg_type)\r\n{\r\nstruct lnw_gpio *lnw = container_of(chip, struct lnw_gpio, chip);\r\nunsigned nreg = chip->ngpio / 32;\r\nu8 reg = offset / 32;\r\nvoid __iomem *ptr;\r\nptr = (void __iomem *)(lnw->reg_base + reg_type * nreg * 4 + reg * 4);\r\nreturn ptr;\r\n}\r\nstatic void __iomem *gpio_reg_2bit(struct gpio_chip *chip, unsigned offset,\r\nenum GPIO_REG reg_type)\r\n{\r\nstruct lnw_gpio *lnw = container_of(chip, struct lnw_gpio, chip);\r\nunsigned nreg = chip->ngpio / 32;\r\nu8 reg = offset / 16;\r\nvoid __iomem *ptr;\r\nptr = (void __iomem *)(lnw->reg_base + reg_type * nreg * 4 + reg * 4);\r\nreturn ptr;\r\n}\r\nstatic int lnw_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nvoid __iomem *gafr = gpio_reg_2bit(chip, offset, GAFR);\r\nu32 value = readl(gafr);\r\nint shift = (offset % 16) << 1, af = (value >> shift) & 3;\r\nif (af) {\r\nvalue &= ~(3 << shift);\r\nwritel(value, gafr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lnw_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nvoid __iomem *gplr = gpio_reg(chip, offset, GPLR);\r\nreturn readl(gplr) & BIT(offset % 32);\r\n}\r\nstatic void lnw_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nvoid __iomem *gpsr, *gpcr;\r\nif (value) {\r\ngpsr = gpio_reg(chip, offset, GPSR);\r\nwritel(BIT(offset % 32), gpsr);\r\n} else {\r\ngpcr = gpio_reg(chip, offset, GPCR);\r\nwritel(BIT(offset % 32), gpcr);\r\n}\r\n}\r\nstatic int lnw_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct lnw_gpio *lnw = container_of(chip, struct lnw_gpio, chip);\r\nvoid __iomem *gpdr = gpio_reg(chip, offset, GPDR);\r\nu32 value;\r\nunsigned long flags;\r\nif (lnw->pdev)\r\npm_runtime_get(&lnw->pdev->dev);\r\nspin_lock_irqsave(&lnw->lock, flags);\r\nvalue = readl(gpdr);\r\nvalue &= ~BIT(offset % 32);\r\nwritel(value, gpdr);\r\nspin_unlock_irqrestore(&lnw->lock, flags);\r\nif (lnw->pdev)\r\npm_runtime_put(&lnw->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int lnw_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct lnw_gpio *lnw = container_of(chip, struct lnw_gpio, chip);\r\nvoid __iomem *gpdr = gpio_reg(chip, offset, GPDR);\r\nunsigned long flags;\r\nlnw_gpio_set(chip, offset, value);\r\nif (lnw->pdev)\r\npm_runtime_get(&lnw->pdev->dev);\r\nspin_lock_irqsave(&lnw->lock, flags);\r\nvalue = readl(gpdr);\r\nvalue |= BIT(offset % 32);\r\nwritel(value, gpdr);\r\nspin_unlock_irqrestore(&lnw->lock, flags);\r\nif (lnw->pdev)\r\npm_runtime_put(&lnw->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int lnw_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct lnw_gpio *lnw = container_of(chip, struct lnw_gpio, chip);\r\nreturn lnw->irq_base + offset;\r\n}\r\nstatic int lnw_irq_type(struct irq_data *d, unsigned type)\r\n{\r\nstruct lnw_gpio *lnw = irq_data_get_irq_chip_data(d);\r\nu32 gpio = d->irq - lnw->irq_base;\r\nunsigned long flags;\r\nu32 value;\r\nvoid __iomem *grer = gpio_reg(&lnw->chip, gpio, GRER);\r\nvoid __iomem *gfer = gpio_reg(&lnw->chip, gpio, GFER);\r\nif (gpio >= lnw->chip.ngpio)\r\nreturn -EINVAL;\r\nif (lnw->pdev)\r\npm_runtime_get(&lnw->pdev->dev);\r\nspin_lock_irqsave(&lnw->lock, flags);\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nvalue = readl(grer) | BIT(gpio % 32);\r\nelse\r\nvalue = readl(grer) & (~BIT(gpio % 32));\r\nwritel(value, grer);\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nvalue = readl(gfer) | BIT(gpio % 32);\r\nelse\r\nvalue = readl(gfer) & (~BIT(gpio % 32));\r\nwritel(value, gfer);\r\nspin_unlock_irqrestore(&lnw->lock, flags);\r\nif (lnw->pdev)\r\npm_runtime_put(&lnw->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic void lnw_irq_unmask(struct irq_data *d)\r\n{\r\n}\r\nstatic void lnw_irq_mask(struct irq_data *d)\r\n{\r\n}\r\nstatic void lnw_irq_handler(unsigned irq, struct irq_desc *desc)\r\n{\r\nstruct irq_data *data = irq_desc_get_irq_data(desc);\r\nstruct lnw_gpio *lnw = irq_data_get_irq_handler_data(data);\r\nstruct irq_chip *chip = irq_data_get_irq_chip(data);\r\nu32 base, gpio, mask;\r\nunsigned long pending;\r\nvoid __iomem *gedr;\r\nfor (base = 0; base < lnw->chip.ngpio; base += 32) {\r\ngedr = gpio_reg(&lnw->chip, base, GEDR);\r\npending = readl(gedr);\r\nwhile (pending) {\r\ngpio = __ffs(pending);\r\nmask = BIT(gpio);\r\npending &= ~mask;\r\nwritel(mask, gedr);\r\ngeneric_handle_irq(lnw->irq_base + base + gpio);\r\n}\r\n}\r\nchip->irq_eoi(data);\r\n}\r\nstatic int lnw_gpio_runtime_resume(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int lnw_gpio_runtime_suspend(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int lnw_gpio_runtime_idle(struct device *dev)\r\n{\r\nint err = pm_schedule_suspend(dev, 500);\r\nif (!err)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int __devinit lnw_gpio_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nvoid *base;\r\nint i;\r\nresource_size_t start, len;\r\nstruct lnw_gpio *lnw;\r\nu32 irq_base;\r\nu32 gpio_base;\r\nint retval = 0;\r\nretval = pci_enable_device(pdev);\r\nif (retval)\r\ngoto done;\r\nretval = pci_request_regions(pdev, "langwell_gpio");\r\nif (retval) {\r\ndev_err(&pdev->dev, "error requesting resources\n");\r\ngoto err2;\r\n}\r\nstart = pci_resource_start(pdev, 1);\r\nlen = pci_resource_len(pdev, 1);\r\nbase = ioremap_nocache(start, len);\r\nif (!base) {\r\ndev_err(&pdev->dev, "error mapping bar1\n");\r\ngoto err3;\r\n}\r\nirq_base = *(u32 *)base;\r\ngpio_base = *((u32 *)base + 1);\r\niounmap(base);\r\nstart = pci_resource_start(pdev, 0);\r\nlen = pci_resource_len(pdev, 0);\r\nbase = ioremap_nocache(start, len);\r\nif (!base) {\r\ndev_err(&pdev->dev, "error mapping bar0\n");\r\nretval = -EFAULT;\r\ngoto err3;\r\n}\r\nlnw = kzalloc(sizeof(struct lnw_gpio), GFP_KERNEL);\r\nif (!lnw) {\r\ndev_err(&pdev->dev, "can't allocate langwell_gpio chip data\n");\r\nretval = -ENOMEM;\r\ngoto err4;\r\n}\r\nlnw->reg_base = base;\r\nlnw->irq_base = irq_base;\r\nlnw->chip.label = dev_name(&pdev->dev);\r\nlnw->chip.request = lnw_gpio_request;\r\nlnw->chip.direction_input = lnw_gpio_direction_input;\r\nlnw->chip.direction_output = lnw_gpio_direction_output;\r\nlnw->chip.get = lnw_gpio_get;\r\nlnw->chip.set = lnw_gpio_set;\r\nlnw->chip.to_irq = lnw_gpio_to_irq;\r\nlnw->chip.base = gpio_base;\r\nlnw->chip.ngpio = id->driver_data;\r\nlnw->chip.can_sleep = 0;\r\nlnw->pdev = pdev;\r\npci_set_drvdata(pdev, lnw);\r\nretval = gpiochip_add(&lnw->chip);\r\nif (retval) {\r\ndev_err(&pdev->dev, "langwell gpiochip_add error %d\n", retval);\r\ngoto err5;\r\n}\r\nirq_set_handler_data(pdev->irq, lnw);\r\nirq_set_chained_handler(pdev->irq, lnw_irq_handler);\r\nfor (i = 0; i < lnw->chip.ngpio; i++) {\r\nirq_set_chip_and_handler_name(i + lnw->irq_base, &lnw_irqchip,\r\nhandle_simple_irq, "demux");\r\nirq_set_chip_data(i + lnw->irq_base, lnw);\r\n}\r\nspin_lock_init(&lnw->lock);\r\npm_runtime_put_noidle(&pdev->dev);\r\npm_runtime_allow(&pdev->dev);\r\ngoto done;\r\nerr5:\r\nkfree(lnw);\r\nerr4:\r\niounmap(base);\r\nerr3:\r\npci_release_regions(pdev);\r\nerr2:\r\npci_disable_device(pdev);\r\ndone:\r\nreturn retval;\r\n}\r\nstatic int __devinit wp_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct lnw_gpio *lnw;\r\nstruct gpio_chip *gc;\r\nstruct resource *rc;\r\nint retval = 0;\r\nrc = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!rc)\r\nreturn -EINVAL;\r\nlnw = kzalloc(sizeof(struct lnw_gpio), GFP_KERNEL);\r\nif (!lnw) {\r\ndev_err(&pdev->dev,\r\n"can't allocate whitneypoint_gpio chip data\n");\r\nreturn -ENOMEM;\r\n}\r\nlnw->reg_base = ioremap_nocache(rc->start, resource_size(rc));\r\nif (lnw->reg_base == NULL) {\r\nretval = -EINVAL;\r\ngoto err_kmalloc;\r\n}\r\nspin_lock_init(&lnw->lock);\r\ngc = &lnw->chip;\r\ngc->label = dev_name(&pdev->dev);\r\ngc->owner = THIS_MODULE;\r\ngc->direction_input = lnw_gpio_direction_input;\r\ngc->direction_output = lnw_gpio_direction_output;\r\ngc->get = lnw_gpio_get;\r\ngc->set = lnw_gpio_set;\r\ngc->to_irq = NULL;\r\ngc->base = 0;\r\ngc->ngpio = 64;\r\ngc->can_sleep = 0;\r\nretval = gpiochip_add(gc);\r\nif (retval) {\r\ndev_err(&pdev->dev, "whitneypoint gpiochip_add error %d\n",\r\nretval);\r\ngoto err_ioremap;\r\n}\r\nplatform_set_drvdata(pdev, lnw);\r\nreturn 0;\r\nerr_ioremap:\r\niounmap(lnw->reg_base);\r\nerr_kmalloc:\r\nkfree(lnw);\r\nreturn retval;\r\n}\r\nstatic int __devexit wp_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct lnw_gpio *lnw = platform_get_drvdata(pdev);\r\nint err;\r\nerr = gpiochip_remove(&lnw->chip);\r\nif (err)\r\ndev_err(&pdev->dev, "failed to remove gpio_chip.\n");\r\niounmap(lnw->reg_base);\r\nkfree(lnw);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init lnw_gpio_init(void)\r\n{\r\nint ret;\r\nret = pci_register_driver(&lnw_gpio_driver);\r\nif (ret < 0)\r\nreturn ret;\r\nret = platform_driver_register(&wp_gpio_driver);\r\nif (ret < 0)\r\npci_unregister_driver(&lnw_gpio_driver);\r\nreturn ret;\r\n}
