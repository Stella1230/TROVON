const char *crush_bucket_alg_name(int alg)\r\n{\r\nswitch (alg) {\r\ncase CRUSH_BUCKET_UNIFORM: return "uniform";\r\ncase CRUSH_BUCKET_LIST: return "list";\r\ncase CRUSH_BUCKET_TREE: return "tree";\r\ncase CRUSH_BUCKET_STRAW: return "straw";\r\ndefault: return "unknown";\r\n}\r\n}\r\nint crush_get_bucket_item_weight(struct crush_bucket *b, int p)\r\n{\r\nif (p >= b->size)\r\nreturn 0;\r\nswitch (b->alg) {\r\ncase CRUSH_BUCKET_UNIFORM:\r\nreturn ((struct crush_bucket_uniform *)b)->item_weight;\r\ncase CRUSH_BUCKET_LIST:\r\nreturn ((struct crush_bucket_list *)b)->item_weights[p];\r\ncase CRUSH_BUCKET_TREE:\r\nif (p & 1)\r\nreturn ((struct crush_bucket_tree *)b)->node_weights[p];\r\nreturn 0;\r\ncase CRUSH_BUCKET_STRAW:\r\nreturn ((struct crush_bucket_straw *)b)->item_weights[p];\r\n}\r\nreturn 0;\r\n}\r\nvoid crush_calc_parents(struct crush_map *map)\r\n{\r\nint i, b, c;\r\nfor (b = 0; b < map->max_buckets; b++) {\r\nif (map->buckets[b] == NULL)\r\ncontinue;\r\nfor (i = 0; i < map->buckets[b]->size; i++) {\r\nc = map->buckets[b]->items[i];\r\nBUG_ON(c >= map->max_devices ||\r\nc < -map->max_buckets);\r\nif (c >= 0)\r\nmap->device_parents[c] = map->buckets[b]->id;\r\nelse\r\nmap->bucket_parents[-1-c] = map->buckets[b]->id;\r\n}\r\n}\r\n}\r\nvoid crush_destroy_bucket_uniform(struct crush_bucket_uniform *b)\r\n{\r\nkfree(b->h.perm);\r\nkfree(b->h.items);\r\nkfree(b);\r\n}\r\nvoid crush_destroy_bucket_list(struct crush_bucket_list *b)\r\n{\r\nkfree(b->item_weights);\r\nkfree(b->sum_weights);\r\nkfree(b->h.perm);\r\nkfree(b->h.items);\r\nkfree(b);\r\n}\r\nvoid crush_destroy_bucket_tree(struct crush_bucket_tree *b)\r\n{\r\nkfree(b->node_weights);\r\nkfree(b);\r\n}\r\nvoid crush_destroy_bucket_straw(struct crush_bucket_straw *b)\r\n{\r\nkfree(b->straws);\r\nkfree(b->item_weights);\r\nkfree(b->h.perm);\r\nkfree(b->h.items);\r\nkfree(b);\r\n}\r\nvoid crush_destroy_bucket(struct crush_bucket *b)\r\n{\r\nswitch (b->alg) {\r\ncase CRUSH_BUCKET_UNIFORM:\r\ncrush_destroy_bucket_uniform((struct crush_bucket_uniform *)b);\r\nbreak;\r\ncase CRUSH_BUCKET_LIST:\r\ncrush_destroy_bucket_list((struct crush_bucket_list *)b);\r\nbreak;\r\ncase CRUSH_BUCKET_TREE:\r\ncrush_destroy_bucket_tree((struct crush_bucket_tree *)b);\r\nbreak;\r\ncase CRUSH_BUCKET_STRAW:\r\ncrush_destroy_bucket_straw((struct crush_bucket_straw *)b);\r\nbreak;\r\n}\r\n}\r\nvoid crush_destroy(struct crush_map *map)\r\n{\r\nint b;\r\nif (map->buckets) {\r\nfor (b = 0; b < map->max_buckets; b++) {\r\nif (map->buckets[b] == NULL)\r\ncontinue;\r\ncrush_destroy_bucket(map->buckets[b]);\r\n}\r\nkfree(map->buckets);\r\n}\r\nif (map->rules) {\r\nfor (b = 0; b < map->max_rules; b++)\r\nkfree(map->rules[b]);\r\nkfree(map->rules);\r\n}\r\nkfree(map->bucket_parents);\r\nkfree(map->device_parents);\r\nkfree(map);\r\n}
