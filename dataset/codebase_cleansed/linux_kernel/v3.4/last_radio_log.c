static ssize_t last_radio_log_read(struct file *file, char __user *buf,\r\nsize_t len, loff_t *offset)\r\n{\r\nloff_t pos = *offset;\r\nssize_t count;\r\nif (pos >= radio_log_size)\r\nreturn 0;\r\ncount = min(len, (size_t)(radio_log_size - pos));\r\nif (copy_to_user(buf, radio_log_base + pos, count)) {\r\npr_err("%s: copy to user failed\n", __func__);\r\nreturn -EFAULT;\r\n}\r\n*offset += count;\r\nreturn count;\r\n}\r\nvoid msm_init_last_radio_log(struct module *owner)\r\n{\r\nstruct proc_dir_entry *entry;\r\nif (last_radio_log_fops.owner) {\r\npr_err("%s: already claimed\n", __func__);\r\nreturn;\r\n}\r\nradio_log_base = smem_item(SMEM_CLKREGIM_BSP, &radio_log_size);\r\nif (!radio_log_base) {\r\npr_err("%s: could not retrieve SMEM_CLKREGIM_BSP\n", __func__);\r\nreturn;\r\n}\r\nentry = create_proc_entry("last_radio_log", S_IFREG | S_IRUGO, NULL);\r\nif (!entry) {\r\npr_err("%s: could not create proc entry for radio log\n",\r\n__func__);\r\nreturn;\r\n}\r\npr_err("%s: last radio log is %d bytes long\n", __func__,\r\nradio_log_size);\r\nlast_radio_log_fops.owner = owner;\r\nentry->proc_fops = &last_radio_log_fops;\r\nentry->size = radio_log_size;\r\n}
