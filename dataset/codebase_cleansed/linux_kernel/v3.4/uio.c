static ssize_t map_name_show(struct uio_mem *mem, char *buf)\r\n{\r\nif (unlikely(!mem->name))\r\nmem->name = "";\r\nreturn sprintf(buf, "%s\n", mem->name);\r\n}\r\nstatic ssize_t map_addr_show(struct uio_mem *mem, char *buf)\r\n{\r\nreturn sprintf(buf, "0x%llx\n", (unsigned long long)mem->addr);\r\n}\r\nstatic ssize_t map_size_show(struct uio_mem *mem, char *buf)\r\n{\r\nreturn sprintf(buf, "0x%lx\n", mem->size);\r\n}\r\nstatic ssize_t map_offset_show(struct uio_mem *mem, char *buf)\r\n{\r\nreturn sprintf(buf, "0x%llx\n", (unsigned long long)mem->addr & ~PAGE_MASK);\r\n}\r\nstatic void map_release(struct kobject *kobj)\r\n{\r\nstruct uio_map *map = to_map(kobj);\r\nkfree(map);\r\n}\r\nstatic ssize_t map_type_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct uio_map *map = to_map(kobj);\r\nstruct uio_mem *mem = map->mem;\r\nstruct map_sysfs_entry *entry;\r\nentry = container_of(attr, struct map_sysfs_entry, attr);\r\nif (!entry->show)\r\nreturn -EIO;\r\nreturn entry->show(mem, buf);\r\n}\r\nstatic ssize_t portio_name_show(struct uio_port *port, char *buf)\r\n{\r\nif (unlikely(!port->name))\r\nport->name = "";\r\nreturn sprintf(buf, "%s\n", port->name);\r\n}\r\nstatic ssize_t portio_start_show(struct uio_port *port, char *buf)\r\n{\r\nreturn sprintf(buf, "0x%lx\n", port->start);\r\n}\r\nstatic ssize_t portio_size_show(struct uio_port *port, char *buf)\r\n{\r\nreturn sprintf(buf, "0x%lx\n", port->size);\r\n}\r\nstatic ssize_t portio_porttype_show(struct uio_port *port, char *buf)\r\n{\r\nconst char *porttypes[] = {"none", "x86", "gpio", "other"};\r\nif ((port->porttype < 0) || (port->porttype > UIO_PORT_OTHER))\r\nreturn -EINVAL;\r\nreturn sprintf(buf, "port_%s\n", porttypes[port->porttype]);\r\n}\r\nstatic void portio_release(struct kobject *kobj)\r\n{\r\nstruct uio_portio *portio = to_portio(kobj);\r\nkfree(portio);\r\n}\r\nstatic ssize_t portio_type_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct uio_portio *portio = to_portio(kobj);\r\nstruct uio_port *port = portio->port;\r\nstruct portio_sysfs_entry *entry;\r\nentry = container_of(attr, struct portio_sysfs_entry, attr);\r\nif (!entry->show)\r\nreturn -EIO;\r\nreturn entry->show(port, buf);\r\n}\r\nstatic ssize_t show_name(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct uio_device *idev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", idev->info->name);\r\n}\r\nstatic ssize_t show_version(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct uio_device *idev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", idev->info->version);\r\n}\r\nstatic ssize_t show_event(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct uio_device *idev = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", (unsigned int)atomic_read(&idev->event));\r\n}\r\nstatic int uio_dev_add_attributes(struct uio_device *idev)\r\n{\r\nint ret;\r\nint mi, pi;\r\nint map_found = 0;\r\nint portio_found = 0;\r\nstruct uio_mem *mem;\r\nstruct uio_map *map;\r\nstruct uio_port *port;\r\nstruct uio_portio *portio;\r\nfor (mi = 0; mi < MAX_UIO_MAPS; mi++) {\r\nmem = &idev->info->mem[mi];\r\nif (mem->size == 0)\r\nbreak;\r\nif (!map_found) {\r\nmap_found = 1;\r\nidev->map_dir = kobject_create_and_add("maps",\r\n&idev->dev->kobj);\r\nif (!idev->map_dir)\r\ngoto err_map;\r\n}\r\nmap = kzalloc(sizeof(*map), GFP_KERNEL);\r\nif (!map)\r\ngoto err_map;\r\nkobject_init(&map->kobj, &map_attr_type);\r\nmap->mem = mem;\r\nmem->map = map;\r\nret = kobject_add(&map->kobj, idev->map_dir, "map%d", mi);\r\nif (ret)\r\ngoto err_map;\r\nret = kobject_uevent(&map->kobj, KOBJ_ADD);\r\nif (ret)\r\ngoto err_map;\r\n}\r\nfor (pi = 0; pi < MAX_UIO_PORT_REGIONS; pi++) {\r\nport = &idev->info->port[pi];\r\nif (port->size == 0)\r\nbreak;\r\nif (!portio_found) {\r\nportio_found = 1;\r\nidev->portio_dir = kobject_create_and_add("portio",\r\n&idev->dev->kobj);\r\nif (!idev->portio_dir)\r\ngoto err_portio;\r\n}\r\nportio = kzalloc(sizeof(*portio), GFP_KERNEL);\r\nif (!portio)\r\ngoto err_portio;\r\nkobject_init(&portio->kobj, &portio_attr_type);\r\nportio->port = port;\r\nport->portio = portio;\r\nret = kobject_add(&portio->kobj, idev->portio_dir,\r\n"port%d", pi);\r\nif (ret)\r\ngoto err_portio;\r\nret = kobject_uevent(&portio->kobj, KOBJ_ADD);\r\nif (ret)\r\ngoto err_portio;\r\n}\r\nreturn 0;\r\nerr_portio:\r\nfor (pi--; pi >= 0; pi--) {\r\nport = &idev->info->port[pi];\r\nportio = port->portio;\r\nkobject_put(&portio->kobj);\r\n}\r\nkobject_put(idev->portio_dir);\r\nerr_map:\r\nfor (mi--; mi>=0; mi--) {\r\nmem = &idev->info->mem[mi];\r\nmap = mem->map;\r\nkobject_put(&map->kobj);\r\n}\r\nkobject_put(idev->map_dir);\r\ndev_err(idev->dev, "error creating sysfs files (%d)\n", ret);\r\nreturn ret;\r\n}\r\nstatic void uio_dev_del_attributes(struct uio_device *idev)\r\n{\r\nint i;\r\nstruct uio_mem *mem;\r\nstruct uio_port *port;\r\nfor (i = 0; i < MAX_UIO_MAPS; i++) {\r\nmem = &idev->info->mem[i];\r\nif (mem->size == 0)\r\nbreak;\r\nkobject_put(&mem->map->kobj);\r\n}\r\nkobject_put(idev->map_dir);\r\nfor (i = 0; i < MAX_UIO_PORT_REGIONS; i++) {\r\nport = &idev->info->port[i];\r\nif (port->size == 0)\r\nbreak;\r\nkobject_put(&port->portio->kobj);\r\n}\r\nkobject_put(idev->portio_dir);\r\n}\r\nstatic int uio_get_minor(struct uio_device *idev)\r\n{\r\nint retval = -ENOMEM;\r\nint id;\r\nmutex_lock(&minor_lock);\r\nif (idr_pre_get(&uio_idr, GFP_KERNEL) == 0)\r\ngoto exit;\r\nretval = idr_get_new(&uio_idr, idev, &id);\r\nif (retval < 0) {\r\nif (retval == -EAGAIN)\r\nretval = -ENOMEM;\r\ngoto exit;\r\n}\r\nif (id < UIO_MAX_DEVICES) {\r\nidev->minor = id;\r\n} else {\r\ndev_err(idev->dev, "too many uio devices\n");\r\nretval = -EINVAL;\r\nidr_remove(&uio_idr, id);\r\n}\r\nexit:\r\nmutex_unlock(&minor_lock);\r\nreturn retval;\r\n}\r\nstatic void uio_free_minor(struct uio_device *idev)\r\n{\r\nmutex_lock(&minor_lock);\r\nidr_remove(&uio_idr, idev->minor);\r\nmutex_unlock(&minor_lock);\r\n}\r\nvoid uio_event_notify(struct uio_info *info)\r\n{\r\nstruct uio_device *idev = info->uio_dev;\r\natomic_inc(&idev->event);\r\nwake_up_interruptible(&idev->wait);\r\nkill_fasync(&idev->async_queue, SIGIO, POLL_IN);\r\n}\r\nstatic irqreturn_t uio_interrupt(int irq, void *dev_id)\r\n{\r\nstruct uio_device *idev = (struct uio_device *)dev_id;\r\nirqreturn_t ret = idev->info->handler(irq, idev->info);\r\nif (ret == IRQ_HANDLED)\r\nuio_event_notify(idev->info);\r\nreturn ret;\r\n}\r\nstatic int uio_open(struct inode *inode, struct file *filep)\r\n{\r\nstruct uio_device *idev;\r\nstruct uio_listener *listener;\r\nint ret = 0;\r\nmutex_lock(&minor_lock);\r\nidev = idr_find(&uio_idr, iminor(inode));\r\nmutex_unlock(&minor_lock);\r\nif (!idev) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (!try_module_get(idev->owner)) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nlistener = kmalloc(sizeof(*listener), GFP_KERNEL);\r\nif (!listener) {\r\nret = -ENOMEM;\r\ngoto err_alloc_listener;\r\n}\r\nlistener->dev = idev;\r\nlistener->event_count = atomic_read(&idev->event);\r\nfilep->private_data = listener;\r\nif (idev->info->open) {\r\nret = idev->info->open(idev->info, inode);\r\nif (ret)\r\ngoto err_infoopen;\r\n}\r\nreturn 0;\r\nerr_infoopen:\r\nkfree(listener);\r\nerr_alloc_listener:\r\nmodule_put(idev->owner);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int uio_fasync(int fd, struct file *filep, int on)\r\n{\r\nstruct uio_listener *listener = filep->private_data;\r\nstruct uio_device *idev = listener->dev;\r\nreturn fasync_helper(fd, filep, on, &idev->async_queue);\r\n}\r\nstatic int uio_release(struct inode *inode, struct file *filep)\r\n{\r\nint ret = 0;\r\nstruct uio_listener *listener = filep->private_data;\r\nstruct uio_device *idev = listener->dev;\r\nif (idev->info->release)\r\nret = idev->info->release(idev->info, inode);\r\nmodule_put(idev->owner);\r\nkfree(listener);\r\nreturn ret;\r\n}\r\nstatic unsigned int uio_poll(struct file *filep, poll_table *wait)\r\n{\r\nstruct uio_listener *listener = filep->private_data;\r\nstruct uio_device *idev = listener->dev;\r\nif (!idev->info->irq)\r\nreturn -EIO;\r\npoll_wait(filep, &idev->wait, wait);\r\nif (listener->event_count != atomic_read(&idev->event))\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic ssize_t uio_read(struct file *filep, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct uio_listener *listener = filep->private_data;\r\nstruct uio_device *idev = listener->dev;\r\nDECLARE_WAITQUEUE(wait, current);\r\nssize_t retval;\r\ns32 event_count;\r\nif (!idev->info->irq)\r\nreturn -EIO;\r\nif (count != sizeof(s32))\r\nreturn -EINVAL;\r\nadd_wait_queue(&idev->wait, &wait);\r\ndo {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nevent_count = atomic_read(&idev->event);\r\nif (event_count != listener->event_count) {\r\nif (copy_to_user(buf, &event_count, count))\r\nretval = -EFAULT;\r\nelse {\r\nlistener->event_count = event_count;\r\nretval = count;\r\n}\r\nbreak;\r\n}\r\nif (filep->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\nschedule();\r\n} while (1);\r\n__set_current_state(TASK_RUNNING);\r\nremove_wait_queue(&idev->wait, &wait);\r\nreturn retval;\r\n}\r\nstatic ssize_t uio_write(struct file *filep, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct uio_listener *listener = filep->private_data;\r\nstruct uio_device *idev = listener->dev;\r\nssize_t retval;\r\ns32 irq_on;\r\nif (!idev->info->irq)\r\nreturn -EIO;\r\nif (count != sizeof(s32))\r\nreturn -EINVAL;\r\nif (!idev->info->irqcontrol)\r\nreturn -ENOSYS;\r\nif (copy_from_user(&irq_on, buf, count))\r\nreturn -EFAULT;\r\nretval = idev->info->irqcontrol(idev->info, irq_on);\r\nreturn retval ? retval : sizeof(s32);\r\n}\r\nstatic int uio_find_mem_index(struct vm_area_struct *vma)\r\n{\r\nstruct uio_device *idev = vma->vm_private_data;\r\nif (vma->vm_pgoff < MAX_UIO_MAPS) {\r\nif (idev->info->mem[vma->vm_pgoff].size == 0)\r\nreturn -1;\r\nreturn (int)vma->vm_pgoff;\r\n}\r\nreturn -1;\r\n}\r\nstatic void uio_vma_open(struct vm_area_struct *vma)\r\n{\r\nstruct uio_device *idev = vma->vm_private_data;\r\nidev->vma_count++;\r\n}\r\nstatic void uio_vma_close(struct vm_area_struct *vma)\r\n{\r\nstruct uio_device *idev = vma->vm_private_data;\r\nidev->vma_count--;\r\n}\r\nstatic int uio_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct uio_device *idev = vma->vm_private_data;\r\nstruct page *page;\r\nunsigned long offset;\r\nint mi = uio_find_mem_index(vma);\r\nif (mi < 0)\r\nreturn VM_FAULT_SIGBUS;\r\noffset = (vmf->pgoff - mi) << PAGE_SHIFT;\r\nif (idev->info->mem[mi].memtype == UIO_MEM_LOGICAL)\r\npage = virt_to_page(idev->info->mem[mi].addr + offset);\r\nelse\r\npage = vmalloc_to_page((void *)(unsigned long)idev->info->mem[mi].addr + offset);\r\nget_page(page);\r\nvmf->page = page;\r\nreturn 0;\r\n}\r\nstatic int uio_mmap_physical(struct vm_area_struct *vma)\r\n{\r\nstruct uio_device *idev = vma->vm_private_data;\r\nint mi = uio_find_mem_index(vma);\r\nif (mi < 0)\r\nreturn -EINVAL;\r\nvma->vm_flags |= VM_IO | VM_RESERVED;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nreturn remap_pfn_range(vma,\r\nvma->vm_start,\r\nidev->info->mem[mi].addr >> PAGE_SHIFT,\r\nvma->vm_end - vma->vm_start,\r\nvma->vm_page_prot);\r\n}\r\nstatic int uio_mmap_logical(struct vm_area_struct *vma)\r\n{\r\nvma->vm_flags |= VM_RESERVED;\r\nvma->vm_ops = &uio_vm_ops;\r\nuio_vma_open(vma);\r\nreturn 0;\r\n}\r\nstatic int uio_mmap(struct file *filep, struct vm_area_struct *vma)\r\n{\r\nstruct uio_listener *listener = filep->private_data;\r\nstruct uio_device *idev = listener->dev;\r\nint mi;\r\nunsigned long requested_pages, actual_pages;\r\nint ret = 0;\r\nif (vma->vm_end < vma->vm_start)\r\nreturn -EINVAL;\r\nvma->vm_private_data = idev;\r\nmi = uio_find_mem_index(vma);\r\nif (mi < 0)\r\nreturn -EINVAL;\r\nrequested_pages = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;\r\nactual_pages = ((idev->info->mem[mi].addr & ~PAGE_MASK)\r\n+ idev->info->mem[mi].size + PAGE_SIZE -1) >> PAGE_SHIFT;\r\nif (requested_pages > actual_pages)\r\nreturn -EINVAL;\r\nif (idev->info->mmap) {\r\nret = idev->info->mmap(idev->info, vma);\r\nreturn ret;\r\n}\r\nswitch (idev->info->mem[mi].memtype) {\r\ncase UIO_MEM_PHYS:\r\nreturn uio_mmap_physical(vma);\r\ncase UIO_MEM_LOGICAL:\r\ncase UIO_MEM_VIRTUAL:\r\nreturn uio_mmap_logical(vma);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int uio_major_init(void)\r\n{\r\nstatic const char name[] = "uio";\r\nstruct cdev *cdev = NULL;\r\ndev_t uio_dev = 0;\r\nint result;\r\nresult = alloc_chrdev_region(&uio_dev, 0, UIO_MAX_DEVICES, name);\r\nif (result)\r\ngoto out;\r\nresult = -ENOMEM;\r\ncdev = cdev_alloc();\r\nif (!cdev)\r\ngoto out_unregister;\r\ncdev->owner = THIS_MODULE;\r\ncdev->ops = &uio_fops;\r\nkobject_set_name(&cdev->kobj, "%s", name);\r\nresult = cdev_add(cdev, uio_dev, UIO_MAX_DEVICES);\r\nif (result)\r\ngoto out_put;\r\nuio_major = MAJOR(uio_dev);\r\nuio_cdev = cdev;\r\nreturn 0;\r\nout_put:\r\nkobject_put(&cdev->kobj);\r\nout_unregister:\r\nunregister_chrdev_region(uio_dev, UIO_MAX_DEVICES);\r\nout:\r\nreturn result;\r\n}\r\nstatic void uio_major_cleanup(void)\r\n{\r\nunregister_chrdev_region(MKDEV(uio_major, 0), UIO_MAX_DEVICES);\r\ncdev_del(uio_cdev);\r\n}\r\nstatic int init_uio_class(void)\r\n{\r\nint ret;\r\nret = uio_major_init();\r\nif (ret)\r\ngoto exit;\r\nret = class_register(&uio_class);\r\nif (ret) {\r\nprintk(KERN_ERR "class_register failed for uio\n");\r\ngoto err_class_register;\r\n}\r\nreturn 0;\r\nerr_class_register:\r\nuio_major_cleanup();\r\nexit:\r\nreturn ret;\r\n}\r\nstatic void release_uio_class(void)\r\n{\r\nclass_unregister(&uio_class);\r\nuio_major_cleanup();\r\n}\r\nint __uio_register_device(struct module *owner,\r\nstruct device *parent,\r\nstruct uio_info *info)\r\n{\r\nstruct uio_device *idev;\r\nint ret = 0;\r\nif (!parent || !info || !info->name || !info->version)\r\nreturn -EINVAL;\r\ninfo->uio_dev = NULL;\r\nidev = kzalloc(sizeof(*idev), GFP_KERNEL);\r\nif (!idev) {\r\nret = -ENOMEM;\r\ngoto err_kzalloc;\r\n}\r\nidev->owner = owner;\r\nidev->info = info;\r\ninit_waitqueue_head(&idev->wait);\r\natomic_set(&idev->event, 0);\r\nret = uio_get_minor(idev);\r\nif (ret)\r\ngoto err_get_minor;\r\nidev->dev = device_create(&uio_class, parent,\r\nMKDEV(uio_major, idev->minor), idev,\r\n"uio%d", idev->minor);\r\nif (IS_ERR(idev->dev)) {\r\nprintk(KERN_ERR "UIO: device register failed\n");\r\nret = PTR_ERR(idev->dev);\r\ngoto err_device_create;\r\n}\r\nret = uio_dev_add_attributes(idev);\r\nif (ret)\r\ngoto err_uio_dev_add_attributes;\r\ninfo->uio_dev = idev;\r\nif (info->irq && (info->irq != UIO_IRQ_CUSTOM)) {\r\nret = request_irq(info->irq, uio_interrupt,\r\ninfo->irq_flags, info->name, idev);\r\nif (ret)\r\ngoto err_request_irq;\r\n}\r\nreturn 0;\r\nerr_request_irq:\r\nuio_dev_del_attributes(idev);\r\nerr_uio_dev_add_attributes:\r\ndevice_destroy(&uio_class, MKDEV(uio_major, idev->minor));\r\nerr_device_create:\r\nuio_free_minor(idev);\r\nerr_get_minor:\r\nkfree(idev);\r\nerr_kzalloc:\r\nreturn ret;\r\n}\r\nvoid uio_unregister_device(struct uio_info *info)\r\n{\r\nstruct uio_device *idev;\r\nif (!info || !info->uio_dev)\r\nreturn;\r\nidev = info->uio_dev;\r\nuio_free_minor(idev);\r\nif (info->irq && (info->irq != UIO_IRQ_CUSTOM))\r\nfree_irq(info->irq, idev);\r\nuio_dev_del_attributes(idev);\r\ndevice_destroy(&uio_class, MKDEV(uio_major, idev->minor));\r\nkfree(idev);\r\nreturn;\r\n}\r\nstatic int __init uio_init(void)\r\n{\r\nreturn init_uio_class();\r\n}\r\nstatic void __exit uio_exit(void)\r\n{\r\nrelease_uio_class();\r\n}
