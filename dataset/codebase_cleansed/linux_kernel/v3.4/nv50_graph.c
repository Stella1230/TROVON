static void\r\nnv50_graph_fifo_access(struct drm_device *dev, bool enabled)\r\n{\r\nconst uint32_t mask = 0x00010001;\r\nif (enabled)\r\nnv_wr32(dev, 0x400500, nv_rd32(dev, 0x400500) | mask);\r\nelse\r\nnv_wr32(dev, 0x400500, nv_rd32(dev, 0x400500) & ~mask);\r\n}\r\nstatic struct nouveau_channel *\r\nnv50_graph_channel(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nuint32_t inst;\r\nint i;\r\nif (!nv_wait(dev, 0x400300, 0x00000001, 0x00000000))\r\nNV_ERROR(dev, "Ctxprog is still running\n");\r\ninst = nv_rd32(dev, NV50_PGRAPH_CTXCTL_CUR);\r\nif (!(inst & NV50_PGRAPH_CTXCTL_CUR_LOADED))\r\nreturn NULL;\r\ninst = (inst & NV50_PGRAPH_CTXCTL_CUR_INSTANCE) << 12;\r\nfor (i = 0; i < dev_priv->engine.fifo.channels; i++) {\r\nstruct nouveau_channel *chan = dev_priv->channels.ptr[i];\r\nif (chan && chan->ramin && chan->ramin->vinst == inst)\r\nreturn chan;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nnv50_graph_do_load_context(struct drm_device *dev, uint32_t inst)\r\n{\r\nuint32_t fifo = nv_rd32(dev, 0x400500);\r\nnv_wr32(dev, 0x400500, fifo & ~1);\r\nnv_wr32(dev, 0x400784, inst);\r\nnv_wr32(dev, 0x400824, nv_rd32(dev, 0x400824) | 0x40);\r\nnv_wr32(dev, 0x400320, nv_rd32(dev, 0x400320) | 0x11);\r\nnv_wr32(dev, 0x400040, 0xffffffff);\r\n(void)nv_rd32(dev, 0x400040);\r\nnv_wr32(dev, 0x400040, 0x00000000);\r\nnv_wr32(dev, 0x400304, nv_rd32(dev, 0x400304) | 1);\r\nif (nouveau_wait_for_idle(dev))\r\nnv_wr32(dev, 0x40032c, inst | (1<<31));\r\nnv_wr32(dev, 0x400500, fifo);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_graph_unload_context(struct drm_device *dev)\r\n{\r\nuint32_t inst;\r\ninst = nv_rd32(dev, NV50_PGRAPH_CTXCTL_CUR);\r\nif (!(inst & NV50_PGRAPH_CTXCTL_CUR_LOADED))\r\nreturn 0;\r\ninst &= NV50_PGRAPH_CTXCTL_CUR_INSTANCE;\r\nnouveau_wait_for_idle(dev);\r\nnv_wr32(dev, 0x400784, inst);\r\nnv_wr32(dev, 0x400824, nv_rd32(dev, 0x400824) | 0x20);\r\nnv_wr32(dev, 0x400304, nv_rd32(dev, 0x400304) | 0x01);\r\nnouveau_wait_for_idle(dev);\r\nnv_wr32(dev, NV50_PGRAPH_CTXCTL_CUR, inst);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_graph_init(struct drm_device *dev, int engine)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv50_graph_engine *pgraph = nv_engine(dev, engine);\r\nu32 units = nv_rd32(dev, 0x001540);\r\nint i;\r\nNV_DEBUG(dev, "\n");\r\nnv_mask(dev, 0x000200, 0x00201000, 0x00000000);\r\nnv_mask(dev, 0x000200, 0x00201000, 0x00201000);\r\nnv_wr32(dev, 0x40008c, 0x00000004);\r\nnv_wr32(dev, 0x400804, 0xc0000000);\r\nnv_wr32(dev, 0x406800, 0xc0000000);\r\nnv_wr32(dev, 0x400c04, 0xc0000000);\r\nnv_wr32(dev, 0x401800, 0xc0000000);\r\nnv_wr32(dev, 0x405018, 0xc0000000);\r\nnv_wr32(dev, 0x402000, 0xc0000000);\r\nfor (i = 0; i < 16; i++) {\r\nif (!(units & (1 << i)))\r\ncontinue;\r\nif (dev_priv->chipset < 0xa0) {\r\nnv_wr32(dev, 0x408900 + (i << 12), 0xc0000000);\r\nnv_wr32(dev, 0x408e08 + (i << 12), 0xc0000000);\r\nnv_wr32(dev, 0x408314 + (i << 12), 0xc0000000);\r\n} else {\r\nnv_wr32(dev, 0x408600 + (i << 11), 0xc0000000);\r\nnv_wr32(dev, 0x408708 + (i << 11), 0xc0000000);\r\nnv_wr32(dev, 0x40831c + (i << 11), 0xc0000000);\r\n}\r\n}\r\nnv_wr32(dev, 0x400108, 0xffffffff);\r\nnv_wr32(dev, 0x400138, 0xffffffff);\r\nnv_wr32(dev, 0x400100, 0xffffffff);\r\nnv_wr32(dev, 0x40013c, 0xffffffff);\r\nnv_wr32(dev, 0x400500, 0x00010001);\r\nnv_wr32(dev, 0x400324, 0x00000000);\r\nfor (i = 0; i < pgraph->ctxprog_size; i++)\r\nnv_wr32(dev, 0x400328, pgraph->ctxprog[i]);\r\nnv_wr32(dev, 0x400824, 0x00000000);\r\nnv_wr32(dev, 0x400828, 0x00000000);\r\nnv_wr32(dev, 0x40082c, 0x00000000);\r\nnv_wr32(dev, 0x400830, 0x00000000);\r\nnv_wr32(dev, 0x400724, 0x00000000);\r\nnv_wr32(dev, 0x40032c, 0x00000000);\r\nnv_wr32(dev, 0x400320, 4);\r\nswitch (dev_priv->chipset & 0xf0) {\r\ncase 0x50:\r\ncase 0x80:\r\ncase 0x90:\r\nnv_wr32(dev, 0x402ca8, 0x00000800);\r\nbreak;\r\ncase 0xa0:\r\ndefault:\r\nnv_wr32(dev, 0x402cc0, 0x00000000);\r\nif (dev_priv->chipset == 0xa0 ||\r\ndev_priv->chipset == 0xaa ||\r\ndev_priv->chipset == 0xac) {\r\nnv_wr32(dev, 0x402ca8, 0x00000802);\r\n} else {\r\nnv_wr32(dev, 0x402cc0, 0x00000000);\r\nnv_wr32(dev, 0x402ca8, 0x00000002);\r\n}\r\nbreak;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nnv_wr32(dev, 0x402c20 + (i * 8), 0x00000000);\r\nnv_wr32(dev, 0x402c24 + (i * 8), 0x00000000);\r\nnv_wr32(dev, 0x402c28 + (i * 8), 0x00000000);\r\nnv_wr32(dev, 0x402c2c + (i * 8), 0x00000000);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_graph_fini(struct drm_device *dev, int engine, bool suspend)\r\n{\r\nnv_mask(dev, 0x400500, 0x00010001, 0x00000000);\r\nif (!nv_wait(dev, 0x400700, ~0, 0) && suspend) {\r\nnv_mask(dev, 0x400500, 0x00010001, 0x00010001);\r\nreturn -EBUSY;\r\n}\r\nnv50_graph_unload_context(dev);\r\nnv_wr32(dev, 0x40013c, 0x00000000);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_graph_context_new(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpuobj *ramin = chan->ramin;\r\nstruct nouveau_gpuobj *grctx = NULL;\r\nstruct nv50_graph_engine *pgraph = nv_engine(dev, engine);\r\nstruct nouveau_grctx ctx = {};\r\nint hdr, ret;\r\nNV_DEBUG(dev, "ch%d\n", chan->id);\r\nret = nouveau_gpuobj_new(dev, NULL, pgraph->grctx_size, 0,\r\nNVOBJ_FLAG_ZERO_ALLOC |\r\nNVOBJ_FLAG_ZERO_FREE, &grctx);\r\nif (ret)\r\nreturn ret;\r\nhdr = (dev_priv->chipset == 0x50) ? 0x200 : 0x20;\r\nnv_wo32(ramin, hdr + 0x00, 0x00190002);\r\nnv_wo32(ramin, hdr + 0x04, grctx->vinst + grctx->size - 1);\r\nnv_wo32(ramin, hdr + 0x08, grctx->vinst);\r\nnv_wo32(ramin, hdr + 0x0c, 0);\r\nnv_wo32(ramin, hdr + 0x10, 0);\r\nnv_wo32(ramin, hdr + 0x14, 0x00010000);\r\nctx.dev = chan->dev;\r\nctx.mode = NOUVEAU_GRCTX_VALS;\r\nctx.data = grctx;\r\nnv50_grctx_init(&ctx);\r\nnv_wo32(grctx, 0x00000, chan->ramin->vinst >> 12);\r\ndev_priv->engine.instmem.flush(dev);\r\natomic_inc(&chan->vm->engref[NVOBJ_ENGINE_GR]);\r\nchan->engctx[NVOBJ_ENGINE_GR] = grctx;\r\nreturn 0;\r\n}\r\nstatic void\r\nnv50_graph_context_del(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct nouveau_gpuobj *grctx = chan->engctx[engine];\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_fifo_engine *pfifo = &dev_priv->engine.fifo;\r\nint i, hdr = (dev_priv->chipset == 0x50) ? 0x200 : 0x20;\r\nunsigned long flags;\r\nNV_DEBUG(dev, "ch%d\n", chan->id);\r\nif (!chan->ramin)\r\nreturn;\r\nspin_lock_irqsave(&dev_priv->context_switch_lock, flags);\r\npfifo->reassign(dev, false);\r\nnv50_graph_fifo_access(dev, false);\r\nif (nv50_graph_channel(dev) == chan)\r\nnv50_graph_unload_context(dev);\r\nfor (i = hdr; i < hdr + 24; i += 4)\r\nnv_wo32(chan->ramin, i, 0);\r\ndev_priv->engine.instmem.flush(dev);\r\nnv50_graph_fifo_access(dev, true);\r\npfifo->reassign(dev, true);\r\nspin_unlock_irqrestore(&dev_priv->context_switch_lock, flags);\r\nnouveau_gpuobj_ref(NULL, &grctx);\r\natomic_dec(&chan->vm->engref[engine]);\r\nchan->engctx[engine] = NULL;\r\n}\r\nstatic int\r\nnv50_graph_object_new(struct nouveau_channel *chan, int engine,\r\nu32 handle, u16 class)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpuobj *obj = NULL;\r\nint ret;\r\nret = nouveau_gpuobj_new(dev, chan, 16, 16, NVOBJ_FLAG_ZERO_FREE, &obj);\r\nif (ret)\r\nreturn ret;\r\nobj->engine = 1;\r\nobj->class = class;\r\nnv_wo32(obj, 0x00, class);\r\nnv_wo32(obj, 0x04, 0x00000000);\r\nnv_wo32(obj, 0x08, 0x00000000);\r\nnv_wo32(obj, 0x0c, 0x00000000);\r\ndev_priv->engine.instmem.flush(dev);\r\nret = nouveau_ramht_insert(chan, handle, obj);\r\nnouveau_gpuobj_ref(NULL, &obj);\r\nreturn ret;\r\n}\r\nstatic void\r\nnv50_graph_context_switch(struct drm_device *dev)\r\n{\r\nuint32_t inst;\r\nnv50_graph_unload_context(dev);\r\ninst = nv_rd32(dev, NV50_PGRAPH_CTXCTL_NEXT);\r\ninst &= NV50_PGRAPH_CTXCTL_NEXT_INSTANCE;\r\nnv50_graph_do_load_context(dev, inst);\r\nnv_wr32(dev, NV40_PGRAPH_INTR_EN, nv_rd32(dev,\r\nNV40_PGRAPH_INTR_EN) | NV_PGRAPH_INTR_CONTEXT_SWITCH);\r\n}\r\nstatic int\r\nnv50_graph_nvsw_dma_vblsem(struct nouveau_channel *chan,\r\nu32 class, u32 mthd, u32 data)\r\n{\r\nstruct nouveau_gpuobj *gpuobj;\r\ngpuobj = nouveau_ramht_find(chan, data);\r\nif (!gpuobj)\r\nreturn -ENOENT;\r\nif (nouveau_notifier_offset(gpuobj, NULL))\r\nreturn -EINVAL;\r\nchan->nvsw.vblsem = gpuobj;\r\nchan->nvsw.vblsem_offset = ~0;\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_graph_nvsw_vblsem_offset(struct nouveau_channel *chan,\r\nu32 class, u32 mthd, u32 data)\r\n{\r\nif (nouveau_notifier_offset(chan->nvsw.vblsem, &data))\r\nreturn -ERANGE;\r\nchan->nvsw.vblsem_offset = data >> 2;\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_graph_nvsw_vblsem_release_val(struct nouveau_channel *chan,\r\nu32 class, u32 mthd, u32 data)\r\n{\r\nchan->nvsw.vblsem_rval = data;\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_graph_nvsw_vblsem_release(struct nouveau_channel *chan,\r\nu32 class, u32 mthd, u32 data)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nif (!chan->nvsw.vblsem || chan->nvsw.vblsem_offset == ~0 || data > 1)\r\nreturn -EINVAL;\r\ndrm_vblank_get(dev, data);\r\nchan->nvsw.vblsem_head = data;\r\nlist_add(&chan->nvsw.vbl_wait, &dev_priv->vbl_waiting);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_graph_nvsw_mthd_page_flip(struct nouveau_channel *chan,\r\nu32 class, u32 mthd, u32 data)\r\n{\r\nnouveau_finish_page_flip(chan, NULL);\r\nreturn 0;\r\n}\r\nstatic void\r\nnv50_graph_tlb_flush(struct drm_device *dev, int engine)\r\n{\r\nnv50_vm_flush_engine(dev, 0);\r\n}\r\nstatic void\r\nnv84_graph_tlb_flush(struct drm_device *dev, int engine)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_timer_engine *ptimer = &dev_priv->engine.timer;\r\nbool idle, timeout = false;\r\nunsigned long flags;\r\nu64 start;\r\nu32 tmp;\r\nspin_lock_irqsave(&dev_priv->context_switch_lock, flags);\r\nnv_mask(dev, 0x400500, 0x00000001, 0x00000000);\r\nstart = ptimer->read(dev);\r\ndo {\r\nidle = true;\r\nfor (tmp = nv_rd32(dev, 0x400380); tmp && idle; tmp >>= 3) {\r\nif ((tmp & 7) == 1)\r\nidle = false;\r\n}\r\nfor (tmp = nv_rd32(dev, 0x400384); tmp && idle; tmp >>= 3) {\r\nif ((tmp & 7) == 1)\r\nidle = false;\r\n}\r\nfor (tmp = nv_rd32(dev, 0x400388); tmp && idle; tmp >>= 3) {\r\nif ((tmp & 7) == 1)\r\nidle = false;\r\n}\r\n} while (!idle && !(timeout = ptimer->read(dev) - start > 2000000000));\r\nif (timeout) {\r\nNV_ERROR(dev, "PGRAPH TLB flush idle timeout fail: "\r\n"0x%08x 0x%08x 0x%08x 0x%08x\n",\r\nnv_rd32(dev, 0x400700), nv_rd32(dev, 0x400380),\r\nnv_rd32(dev, 0x400384), nv_rd32(dev, 0x400388));\r\n}\r\nnv50_vm_flush_engine(dev, 0);\r\nnv_mask(dev, 0x400500, 0x00000001, 0x00000001);\r\nspin_unlock_irqrestore(&dev_priv->context_switch_lock, flags);\r\n}\r\nstatic void\r\nnv50_pgraph_mp_trap(struct drm_device *dev, int tpid, int display)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nuint32_t units = nv_rd32(dev, 0x1540);\r\nuint32_t addr, mp10, status, pc, oplow, ophigh;\r\nint i;\r\nint mps = 0;\r\nfor (i = 0; i < 4; i++) {\r\nif (!(units & 1 << (i+24)))\r\ncontinue;\r\nif (dev_priv->chipset < 0xa0)\r\naddr = 0x408200 + (tpid << 12) + (i << 7);\r\nelse\r\naddr = 0x408100 + (tpid << 11) + (i << 7);\r\nmp10 = nv_rd32(dev, addr + 0x10);\r\nstatus = nv_rd32(dev, addr + 0x14);\r\nif (!status)\r\ncontinue;\r\nif (display) {\r\nnv_rd32(dev, addr + 0x20);\r\npc = nv_rd32(dev, addr + 0x24);\r\noplow = nv_rd32(dev, addr + 0x70);\r\nophigh = nv_rd32(dev, addr + 0x74);\r\nNV_INFO(dev, "PGRAPH_TRAP_MP_EXEC - "\r\n"TP %d MP %d: ", tpid, i);\r\nnouveau_enum_print(nv50_mp_exec_error_names, status);\r\nprintk(" at %06x warp %d, opcode %08x %08x\n",\r\npc&0xffffff, pc >> 24,\r\noplow, ophigh);\r\n}\r\nnv_wr32(dev, addr + 0x10, mp10);\r\nnv_wr32(dev, addr + 0x14, 0);\r\nmps++;\r\n}\r\nif (!mps && display)\r\nNV_INFO(dev, "PGRAPH_TRAP_MP_EXEC - TP %d: "\r\n"No MPs claiming errors?\n", tpid);\r\n}\r\nstatic void\r\nnv50_pgraph_tp_trap(struct drm_device *dev, int type, uint32_t ustatus_old,\r\nuint32_t ustatus_new, int display, const char *name)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nint tps = 0;\r\nuint32_t units = nv_rd32(dev, 0x1540);\r\nint i, r;\r\nuint32_t ustatus_addr, ustatus;\r\nfor (i = 0; i < 16; i++) {\r\nif (!(units & (1 << i)))\r\ncontinue;\r\nif (dev_priv->chipset < 0xa0)\r\nustatus_addr = ustatus_old + (i << 12);\r\nelse\r\nustatus_addr = ustatus_new + (i << 11);\r\nustatus = nv_rd32(dev, ustatus_addr) & 0x7fffffff;\r\nif (!ustatus)\r\ncontinue;\r\ntps++;\r\nswitch (type) {\r\ncase 6:\r\nif (display) {\r\nNV_ERROR(dev, "magic set %d:\n", i);\r\nfor (r = ustatus_addr + 4; r <= ustatus_addr + 0x10; r += 4)\r\nNV_ERROR(dev, "\t0x%08x: 0x%08x\n", r,\r\nnv_rd32(dev, r));\r\n}\r\nbreak;\r\ncase 7:\r\nif (ustatus & 0x04030000) {\r\nnv50_pgraph_mp_trap(dev, i, display);\r\nustatus &= ~0x04030000;\r\n}\r\nbreak;\r\ncase 8:\r\n{\r\nuint32_t e0c = nv_rd32(dev, ustatus_addr + 4);\r\nuint32_t e10 = nv_rd32(dev, ustatus_addr + 8);\r\nuint32_t e14 = nv_rd32(dev, ustatus_addr + 0xc);\r\nuint32_t e18 = nv_rd32(dev, ustatus_addr + 0x10);\r\nuint32_t e1c = nv_rd32(dev, ustatus_addr + 0x14);\r\nuint32_t e20 = nv_rd32(dev, ustatus_addr + 0x18);\r\nuint32_t e24 = nv_rd32(dev, ustatus_addr + 0x1c);\r\nif (ustatus & 0x00000010) {\r\nif (display) {\r\nNV_INFO(dev, "PGRAPH_TRAP_TPDMA_2D - TP %d - Unknown fault at address %02x%08x\n",\r\ni, e14, e10);\r\nNV_INFO(dev, "PGRAPH_TRAP_TPDMA_2D - TP %d - e0c: %08x, e18: %08x, e1c: %08x, e20: %08x, e24: %08x\n",\r\ni, e0c, e18, e1c, e20, e24);\r\n}\r\nustatus &= ~0x00000010;\r\n}\r\nif (ustatus & 0x00000040) {\r\nif (display) {\r\nNV_INFO(dev, "PGRAPH_TRAP_TPDMA_RT - TP %d - Unknown fault at address %02x%08x\n",\r\ni, e14, e10);\r\nNV_INFO(dev, "PGRAPH_TRAP_TPDMA_RT - TP %d - e0c: %08x, e18: %08x, e1c: %08x, e20: %08x, e24: %08x\n",\r\ni, e0c, e18, e1c, e20, e24);\r\n}\r\nustatus &= ~0x00000040;\r\n}\r\nif (ustatus & 0x00000080) {\r\nif (display) {\r\nif (e18 & 0x80000000) {\r\nNV_INFO(dev, "PGRAPH_TRAP_TPDMA - TP %d - Global read fault at address %02x%08x\n",\r\ni, e14, e10 | ((e18 >> 24) & 0x1f));\r\ne18 &= ~0x1f000000;\r\n} else if (e18 & 0xc) {\r\nNV_INFO(dev, "PGRAPH_TRAP_TPDMA - TP %d - Global write fault at address %02x%08x\n",\r\ni, e14, e10 | ((e18 >> 7) & 0x1f));\r\ne18 &= ~0x00000f80;\r\n} else {\r\nNV_INFO(dev, "PGRAPH_TRAP_TPDMA - TP %d - Unknown CUDA fault at address %02x%08x\n",\r\ni, e14, e10);\r\n}\r\nNV_INFO(dev, "PGRAPH_TRAP_TPDMA - TP %d - e0c: %08x, e18: %08x, e1c: %08x, e20: %08x, e24: %08x\n",\r\ni, e0c, e18, e1c, e20, e24);\r\n}\r\nustatus &= ~0x00000080;\r\n}\r\n}\r\nbreak;\r\n}\r\nif (ustatus) {\r\nif (display)\r\nNV_INFO(dev, "%s - TP%d: Unhandled ustatus 0x%08x\n", name, i, ustatus);\r\n}\r\nnv_wr32(dev, ustatus_addr, 0xc0000000);\r\n}\r\nif (!tps && display)\r\nNV_INFO(dev, "%s - No TPs claiming errors?\n", name);\r\n}\r\nstatic int\r\nnv50_pgraph_trap_handler(struct drm_device *dev, u32 display, u64 inst, u32 chid)\r\n{\r\nu32 status = nv_rd32(dev, 0x400108);\r\nu32 ustatus;\r\nif (!status && display) {\r\nNV_INFO(dev, "PGRAPH - TRAP: no units reporting traps?\n");\r\nreturn 1;\r\n}\r\nif (status & 0x001) {\r\nustatus = nv_rd32(dev, 0x400804) & 0x7fffffff;\r\nif (!ustatus && display) {\r\nNV_INFO(dev, "PGRAPH_TRAP_DISPATCH - no ustatus?\n");\r\n}\r\nnv_wr32(dev, 0x400500, 0x00000000);\r\nif (ustatus & 0x00000001) {\r\nu32 addr = nv_rd32(dev, 0x400808);\r\nu32 subc = (addr & 0x00070000) >> 16;\r\nu32 mthd = (addr & 0x00001ffc);\r\nu32 datal = nv_rd32(dev, 0x40080c);\r\nu32 datah = nv_rd32(dev, 0x400810);\r\nu32 class = nv_rd32(dev, 0x400814);\r\nu32 r848 = nv_rd32(dev, 0x400848);\r\nNV_INFO(dev, "PGRAPH - TRAP DISPATCH_FAULT\n");\r\nif (display && (addr & 0x80000000)) {\r\nNV_INFO(dev, "PGRAPH - ch %d (0x%010llx) "\r\n"subc %d class 0x%04x mthd 0x%04x "\r\n"data 0x%08x%08x "\r\n"400808 0x%08x 400848 0x%08x\n",\r\nchid, inst, subc, class, mthd, datah,\r\ndatal, addr, r848);\r\n} else\r\nif (display) {\r\nNV_INFO(dev, "PGRAPH - no stuck command?\n");\r\n}\r\nnv_wr32(dev, 0x400808, 0);\r\nnv_wr32(dev, 0x4008e8, nv_rd32(dev, 0x4008e8) & 3);\r\nnv_wr32(dev, 0x400848, 0);\r\nustatus &= ~0x00000001;\r\n}\r\nif (ustatus & 0x00000002) {\r\nu32 addr = nv_rd32(dev, 0x40084c);\r\nu32 subc = (addr & 0x00070000) >> 16;\r\nu32 mthd = (addr & 0x00001ffc);\r\nu32 data = nv_rd32(dev, 0x40085c);\r\nu32 class = nv_rd32(dev, 0x400814);\r\nNV_INFO(dev, "PGRAPH - TRAP DISPATCH_QUERY\n");\r\nif (display && (addr & 0x80000000)) {\r\nNV_INFO(dev, "PGRAPH - ch %d (0x%010llx) "\r\n"subc %d class 0x%04x mthd 0x%04x "\r\n"data 0x%08x 40084c 0x%08x\n",\r\nchid, inst, subc, class, mthd,\r\ndata, addr);\r\n} else\r\nif (display) {\r\nNV_INFO(dev, "PGRAPH - no stuck command?\n");\r\n}\r\nnv_wr32(dev, 0x40084c, 0);\r\nustatus &= ~0x00000002;\r\n}\r\nif (ustatus && display) {\r\nNV_INFO(dev, "PGRAPH - TRAP_DISPATCH (unknown "\r\n"0x%08x)\n", ustatus);\r\n}\r\nnv_wr32(dev, 0x400804, 0xc0000000);\r\nnv_wr32(dev, 0x400108, 0x001);\r\nstatus &= ~0x001;\r\nif (!status)\r\nreturn 0;\r\n}\r\nif (status & 0x002) {\r\nu32 ustatus = nv_rd32(dev, 0x406800) & 0x7fffffff;\r\nif (display) {\r\nNV_INFO(dev, "PGRAPH - TRAP_M2MF");\r\nnouveau_bitfield_print(nv50_graph_trap_m2mf, ustatus);\r\nprintk("\n");\r\nNV_INFO(dev, "PGRAPH - TRAP_M2MF %08x %08x %08x %08x\n",\r\nnv_rd32(dev, 0x406804), nv_rd32(dev, 0x406808),\r\nnv_rd32(dev, 0x40680c), nv_rd32(dev, 0x406810));\r\n}\r\nnv_wr32(dev, 0x400040, 2);\r\nnv_wr32(dev, 0x400040, 0);\r\nnv_wr32(dev, 0x406800, 0xc0000000);\r\nnv_wr32(dev, 0x400108, 0x002);\r\nstatus &= ~0x002;\r\n}\r\nif (status & 0x004) {\r\nu32 ustatus = nv_rd32(dev, 0x400c04) & 0x7fffffff;\r\nif (display) {\r\nNV_INFO(dev, "PGRAPH - TRAP_VFETCH");\r\nnouveau_bitfield_print(nv50_graph_trap_vfetch, ustatus);\r\nprintk("\n");\r\nNV_INFO(dev, "PGRAPH - TRAP_VFETCH %08x %08x %08x %08x\n",\r\nnv_rd32(dev, 0x400c00), nv_rd32(dev, 0x400c08),\r\nnv_rd32(dev, 0x400c0c), nv_rd32(dev, 0x400c10));\r\n}\r\nnv_wr32(dev, 0x400c04, 0xc0000000);\r\nnv_wr32(dev, 0x400108, 0x004);\r\nstatus &= ~0x004;\r\n}\r\nif (status & 0x008) {\r\nustatus = nv_rd32(dev, 0x401800) & 0x7fffffff;\r\nif (display) {\r\nNV_INFO(dev, "PGRAPH - TRAP_STRMOUT");\r\nnouveau_bitfield_print(nv50_graph_trap_strmout, ustatus);\r\nprintk("\n");\r\nNV_INFO(dev, "PGRAPH - TRAP_STRMOUT %08x %08x %08x %08x\n",\r\nnv_rd32(dev, 0x401804), nv_rd32(dev, 0x401808),\r\nnv_rd32(dev, 0x40180c), nv_rd32(dev, 0x401810));\r\n}\r\nnv_wr32(dev, 0x400040, 0x80);\r\nnv_wr32(dev, 0x400040, 0);\r\nnv_wr32(dev, 0x401800, 0xc0000000);\r\nnv_wr32(dev, 0x400108, 0x008);\r\nstatus &= ~0x008;\r\n}\r\nif (status & 0x010) {\r\nustatus = nv_rd32(dev, 0x405018) & 0x7fffffff;\r\nif (display) {\r\nNV_INFO(dev, "PGRAPH - TRAP_CCACHE");\r\nnouveau_bitfield_print(nv50_graph_trap_ccache, ustatus);\r\nprintk("\n");\r\nNV_INFO(dev, "PGRAPH - TRAP_CCACHE %08x %08x %08x %08x"\r\n" %08x %08x %08x\n",\r\nnv_rd32(dev, 0x405000), nv_rd32(dev, 0x405004),\r\nnv_rd32(dev, 0x405008), nv_rd32(dev, 0x40500c),\r\nnv_rd32(dev, 0x405010), nv_rd32(dev, 0x405014),\r\nnv_rd32(dev, 0x40501c));\r\n}\r\nnv_wr32(dev, 0x405018, 0xc0000000);\r\nnv_wr32(dev, 0x400108, 0x010);\r\nstatus &= ~0x010;\r\n}\r\nif (status & 0x20) {\r\nustatus = nv_rd32(dev, 0x402000) & 0x7fffffff;\r\nif (display)\r\nNV_INFO(dev, "PGRAPH - TRAP_UNKC04 0x%08x\n", ustatus);\r\nnv_wr32(dev, 0x402000, 0xc0000000);\r\n}\r\nif (status & 0x040) {\r\nnv50_pgraph_tp_trap(dev, 6, 0x408900, 0x408600, display,\r\n"PGRAPH - TRAP_TEXTURE");\r\nnv_wr32(dev, 0x400108, 0x040);\r\nstatus &= ~0x040;\r\n}\r\nif (status & 0x080) {\r\nnv50_pgraph_tp_trap(dev, 7, 0x408314, 0x40831c, display,\r\n"PGRAPH - TRAP_MP");\r\nnv_wr32(dev, 0x400108, 0x080);\r\nstatus &= ~0x080;\r\n}\r\nif (status & 0x100) {\r\nnv50_pgraph_tp_trap(dev, 8, 0x408e08, 0x408708, display,\r\n"PGRAPH - TRAP_TPDMA");\r\nnv_wr32(dev, 0x400108, 0x100);\r\nstatus &= ~0x100;\r\n}\r\nif (status) {\r\nif (display)\r\nNV_INFO(dev, "PGRAPH - TRAP: unknown 0x%08x\n", status);\r\nnv_wr32(dev, 0x400108, status);\r\n}\r\nreturn 1;\r\n}\r\nint\r\nnv50_graph_isr_chid(struct drm_device *dev, u64 inst)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_channel *chan;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&dev_priv->channels.lock, flags);\r\nfor (i = 0; i < dev_priv->engine.fifo.channels; i++) {\r\nchan = dev_priv->channels.ptr[i];\r\nif (!chan || !chan->ramin)\r\ncontinue;\r\nif (inst == chan->ramin->vinst)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&dev_priv->channels.lock, flags);\r\nreturn i;\r\n}\r\nstatic void\r\nnv50_graph_isr(struct drm_device *dev)\r\n{\r\nu32 stat;\r\nwhile ((stat = nv_rd32(dev, 0x400100))) {\r\nu64 inst = (u64)(nv_rd32(dev, 0x40032c) & 0x0fffffff) << 12;\r\nu32 chid = nv50_graph_isr_chid(dev, inst);\r\nu32 addr = nv_rd32(dev, NV04_PGRAPH_TRAPPED_ADDR);\r\nu32 subc = (addr & 0x00070000) >> 16;\r\nu32 mthd = (addr & 0x00001ffc);\r\nu32 data = nv_rd32(dev, NV04_PGRAPH_TRAPPED_DATA);\r\nu32 class = nv_rd32(dev, 0x400814);\r\nu32 show = stat;\r\nif (stat & 0x00000010) {\r\nif (!nouveau_gpuobj_mthd_call2(dev, chid, class,\r\nmthd, data))\r\nshow &= ~0x00000010;\r\n}\r\nif (stat & 0x00001000) {\r\nnv_wr32(dev, 0x400500, 0x00000000);\r\nnv_wr32(dev, 0x400100, 0x00001000);\r\nnv_mask(dev, 0x40013c, 0x00001000, 0x00000000);\r\nnv50_graph_context_switch(dev);\r\nstat &= ~0x00001000;\r\nshow &= ~0x00001000;\r\n}\r\nshow = (show && nouveau_ratelimit()) ? show : 0;\r\nif (show & 0x00100000) {\r\nu32 ecode = nv_rd32(dev, 0x400110);\r\nNV_INFO(dev, "PGRAPH - DATA_ERROR ");\r\nnouveau_enum_print(nv50_data_error_names, ecode);\r\nprintk("\n");\r\n}\r\nif (stat & 0x00200000) {\r\nif (!nv50_pgraph_trap_handler(dev, show, inst, chid))\r\nshow &= ~0x00200000;\r\n}\r\nnv_wr32(dev, 0x400100, stat);\r\nnv_wr32(dev, 0x400500, 0x00010001);\r\nif (show) {\r\nNV_INFO(dev, "PGRAPH -");\r\nnouveau_bitfield_print(nv50_graph_intr, show);\r\nprintk("\n");\r\nNV_INFO(dev, "PGRAPH - ch %d (0x%010llx) subc %d "\r\n"class 0x%04x mthd 0x%04x data 0x%08x\n",\r\nchid, inst, subc, class, mthd, data);\r\nnv50_fb_vm_trap(dev, 1);\r\n}\r\n}\r\nif (nv_rd32(dev, 0x400824) & (1 << 31))\r\nnv_wr32(dev, 0x400824, nv_rd32(dev, 0x400824) & ~(1 << 31));\r\n}\r\nstatic void\r\nnv50_graph_destroy(struct drm_device *dev, int engine)\r\n{\r\nstruct nv50_graph_engine *pgraph = nv_engine(dev, engine);\r\nNVOBJ_ENGINE_DEL(dev, GR);\r\nnouveau_irq_unregister(dev, 12);\r\nkfree(pgraph);\r\n}\r\nint\r\nnv50_graph_create(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nv50_graph_engine *pgraph;\r\nstruct nouveau_grctx ctx = {};\r\nint ret;\r\npgraph = kzalloc(sizeof(*pgraph),GFP_KERNEL);\r\nif (!pgraph)\r\nreturn -ENOMEM;\r\nctx.dev = dev;\r\nctx.mode = NOUVEAU_GRCTX_PROG;\r\nctx.data = pgraph->ctxprog;\r\nctx.ctxprog_max = ARRAY_SIZE(pgraph->ctxprog);\r\nret = nv50_grctx_init(&ctx);\r\nif (ret) {\r\nNV_ERROR(dev, "PGRAPH: ctxprog build failed\n");\r\nkfree(pgraph);\r\nreturn 0;\r\n}\r\npgraph->grctx_size = ctx.ctxvals_pos * 4;\r\npgraph->ctxprog_size = ctx.ctxprog_len;\r\npgraph->base.destroy = nv50_graph_destroy;\r\npgraph->base.init = nv50_graph_init;\r\npgraph->base.fini = nv50_graph_fini;\r\npgraph->base.context_new = nv50_graph_context_new;\r\npgraph->base.context_del = nv50_graph_context_del;\r\npgraph->base.object_new = nv50_graph_object_new;\r\nif (dev_priv->chipset == 0x50 || dev_priv->chipset == 0xac)\r\npgraph->base.tlb_flush = nv50_graph_tlb_flush;\r\nelse\r\npgraph->base.tlb_flush = nv84_graph_tlb_flush;\r\nnouveau_irq_register(dev, 12, nv50_graph_isr);\r\nNVOBJ_CLASS(dev, 0x506e, SW);\r\nNVOBJ_MTHD (dev, 0x506e, 0x018c, nv50_graph_nvsw_dma_vblsem);\r\nNVOBJ_MTHD (dev, 0x506e, 0x0400, nv50_graph_nvsw_vblsem_offset);\r\nNVOBJ_MTHD (dev, 0x506e, 0x0404, nv50_graph_nvsw_vblsem_release_val);\r\nNVOBJ_MTHD (dev, 0x506e, 0x0408, nv50_graph_nvsw_vblsem_release);\r\nNVOBJ_MTHD (dev, 0x506e, 0x0500, nv50_graph_nvsw_mthd_page_flip);\r\nNVOBJ_ENGINE_ADD(dev, GR, &pgraph->base);\r\nNVOBJ_CLASS(dev, 0x0030, GR);\r\nNVOBJ_CLASS(dev, 0x5039, GR);\r\nNVOBJ_CLASS(dev, 0x502d, GR);\r\nif (dev_priv->chipset == 0x50)\r\nNVOBJ_CLASS(dev, 0x5097, GR);\r\nelse\r\nif (dev_priv->chipset < 0xa0)\r\nNVOBJ_CLASS(dev, 0x8297, GR);\r\nelse {\r\nswitch (dev_priv->chipset) {\r\ncase 0xa0:\r\ncase 0xaa:\r\ncase 0xac:\r\nNVOBJ_CLASS(dev, 0x8397, GR);\r\nbreak;\r\ncase 0xa3:\r\ncase 0xa5:\r\ncase 0xa8:\r\nNVOBJ_CLASS(dev, 0x8597, GR);\r\nbreak;\r\ncase 0xaf:\r\nNVOBJ_CLASS(dev, 0x8697, GR);\r\nbreak;\r\n}\r\n}\r\nNVOBJ_CLASS(dev, 0x50c0, GR);\r\nif (dev_priv->chipset > 0xa0 &&\r\ndev_priv->chipset != 0xaa &&\r\ndev_priv->chipset != 0xac)\r\nNVOBJ_CLASS(dev, 0x85c0, GR);\r\nreturn 0;\r\n}
