static struct platform_device *dpi_get_dsidev(enum omap_dss_clk_source clk)\r\n{\r\nint dsi_module;\r\ndsi_module = clk == OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC ? 0 : 1;\r\nreturn dsi_get_dsidev_from_id(dsi_module);\r\n}\r\nstatic bool dpi_use_dsi_pll(struct omap_dss_device *dssdev)\r\n{\r\nif (dssdev->clocks.dispc.dispc_fclk_src ==\r\nOMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC ||\r\ndssdev->clocks.dispc.dispc_fclk_src ==\r\nOMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC ||\r\ndssdev->clocks.dispc.channel.lcd_clk_src ==\r\nOMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC ||\r\ndssdev->clocks.dispc.channel.lcd_clk_src ==\r\nOMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic int dpi_set_dsi_clk(struct omap_dss_device *dssdev, bool is_tft,\r\nunsigned long pck_req, unsigned long *fck, int *lck_div,\r\nint *pck_div)\r\n{\r\nstruct dsi_clock_info dsi_cinfo;\r\nstruct dispc_clock_info dispc_cinfo;\r\nint r;\r\nr = dsi_pll_calc_clock_div_pck(dpi.dsidev, is_tft, pck_req,\r\n&dsi_cinfo, &dispc_cinfo);\r\nif (r)\r\nreturn r;\r\nr = dsi_pll_set_clock_div(dpi.dsidev, &dsi_cinfo);\r\nif (r)\r\nreturn r;\r\ndss_select_dispc_clk_source(dssdev->clocks.dispc.dispc_fclk_src);\r\nr = dispc_mgr_set_clock_div(dssdev->manager->id, &dispc_cinfo);\r\nif (r) {\r\ndss_select_dispc_clk_source(OMAP_DSS_CLK_SRC_FCK);\r\nreturn r;\r\n}\r\n*fck = dsi_cinfo.dsi_pll_hsdiv_dispc_clk;\r\n*lck_div = dispc_cinfo.lck_div;\r\n*pck_div = dispc_cinfo.pck_div;\r\nreturn 0;\r\n}\r\nstatic int dpi_set_dispc_clk(struct omap_dss_device *dssdev, bool is_tft,\r\nunsigned long pck_req, unsigned long *fck, int *lck_div,\r\nint *pck_div)\r\n{\r\nstruct dss_clock_info dss_cinfo;\r\nstruct dispc_clock_info dispc_cinfo;\r\nint r;\r\nr = dss_calc_clock_div(is_tft, pck_req, &dss_cinfo, &dispc_cinfo);\r\nif (r)\r\nreturn r;\r\nr = dss_set_clock_div(&dss_cinfo);\r\nif (r)\r\nreturn r;\r\nr = dispc_mgr_set_clock_div(dssdev->manager->id, &dispc_cinfo);\r\nif (r)\r\nreturn r;\r\n*fck = dss_cinfo.fck;\r\n*lck_div = dispc_cinfo.lck_div;\r\n*pck_div = dispc_cinfo.pck_div;\r\nreturn 0;\r\n}\r\nstatic int dpi_set_mode(struct omap_dss_device *dssdev)\r\n{\r\nstruct omap_video_timings *t = &dssdev->panel.timings;\r\nint lck_div = 0, pck_div = 0;\r\nunsigned long fck = 0;\r\nunsigned long pck;\r\nbool is_tft;\r\nint r = 0;\r\ndispc_mgr_set_pol_freq(dssdev->manager->id, dssdev->panel.config,\r\ndssdev->panel.acbi, dssdev->panel.acb);\r\nis_tft = (dssdev->panel.config & OMAP_DSS_LCD_TFT) != 0;\r\nif (dpi_use_dsi_pll(dssdev))\r\nr = dpi_set_dsi_clk(dssdev, is_tft, t->pixel_clock * 1000,\r\n&fck, &lck_div, &pck_div);\r\nelse\r\nr = dpi_set_dispc_clk(dssdev, is_tft, t->pixel_clock * 1000,\r\n&fck, &lck_div, &pck_div);\r\nif (r)\r\nreturn r;\r\npck = fck / lck_div / pck_div / 1000;\r\nif (pck != t->pixel_clock) {\r\nDSSWARN("Could not find exact pixel clock. "\r\n"Requested %d kHz, got %lu kHz\n",\r\nt->pixel_clock, pck);\r\nt->pixel_clock = pck;\r\n}\r\ndispc_mgr_set_lcd_timings(dssdev->manager->id, t);\r\nreturn 0;\r\n}\r\nstatic void dpi_basic_init(struct omap_dss_device *dssdev)\r\n{\r\nbool is_tft;\r\nis_tft = (dssdev->panel.config & OMAP_DSS_LCD_TFT) != 0;\r\ndispc_mgr_set_io_pad_mode(DSS_IO_PAD_MODE_BYPASS);\r\ndispc_mgr_enable_stallmode(dssdev->manager->id, false);\r\ndispc_mgr_set_lcd_display_type(dssdev->manager->id, is_tft ?\r\nOMAP_DSS_LCD_DISPLAY_TFT : OMAP_DSS_LCD_DISPLAY_STN);\r\ndispc_mgr_set_tft_data_lines(dssdev->manager->id,\r\ndssdev->phy.dpi.data_lines);\r\n}\r\nint omapdss_dpi_display_enable(struct omap_dss_device *dssdev)\r\n{\r\nint r;\r\nif (cpu_is_omap34xx() && !dpi.vdds_dsi_reg) {\r\nDSSERR("no VDSS_DSI regulator\n");\r\nreturn -ENODEV;\r\n}\r\nif (dssdev->manager == NULL) {\r\nDSSERR("failed to enable display: no manager\n");\r\nreturn -ENODEV;\r\n}\r\nr = omap_dss_start_device(dssdev);\r\nif (r) {\r\nDSSERR("failed to start device\n");\r\ngoto err_start_dev;\r\n}\r\nif (cpu_is_omap34xx()) {\r\nr = regulator_enable(dpi.vdds_dsi_reg);\r\nif (r)\r\ngoto err_reg_enable;\r\n}\r\nr = dss_runtime_get();\r\nif (r)\r\ngoto err_get_dss;\r\nr = dispc_runtime_get();\r\nif (r)\r\ngoto err_get_dispc;\r\ndpi_basic_init(dssdev);\r\nif (dpi_use_dsi_pll(dssdev)) {\r\nr = dsi_runtime_get(dpi.dsidev);\r\nif (r)\r\ngoto err_get_dsi;\r\nr = dsi_pll_init(dpi.dsidev, 0, 1);\r\nif (r)\r\ngoto err_dsi_pll_init;\r\n}\r\nr = dpi_set_mode(dssdev);\r\nif (r)\r\ngoto err_set_mode;\r\nmdelay(2);\r\nr = dss_mgr_enable(dssdev->manager);\r\nif (r)\r\ngoto err_mgr_enable;\r\nreturn 0;\r\nerr_mgr_enable:\r\nerr_set_mode:\r\nif (dpi_use_dsi_pll(dssdev))\r\ndsi_pll_uninit(dpi.dsidev, true);\r\nerr_dsi_pll_init:\r\nif (dpi_use_dsi_pll(dssdev))\r\ndsi_runtime_put(dpi.dsidev);\r\nerr_get_dsi:\r\ndispc_runtime_put();\r\nerr_get_dispc:\r\ndss_runtime_put();\r\nerr_get_dss:\r\nif (cpu_is_omap34xx())\r\nregulator_disable(dpi.vdds_dsi_reg);\r\nerr_reg_enable:\r\nomap_dss_stop_device(dssdev);\r\nerr_start_dev:\r\nreturn r;\r\n}\r\nvoid omapdss_dpi_display_disable(struct omap_dss_device *dssdev)\r\n{\r\ndss_mgr_disable(dssdev->manager);\r\nif (dpi_use_dsi_pll(dssdev)) {\r\ndss_select_dispc_clk_source(OMAP_DSS_CLK_SRC_FCK);\r\ndsi_pll_uninit(dpi.dsidev, true);\r\ndsi_runtime_put(dpi.dsidev);\r\n}\r\ndispc_runtime_put();\r\ndss_runtime_put();\r\nif (cpu_is_omap34xx())\r\nregulator_disable(dpi.vdds_dsi_reg);\r\nomap_dss_stop_device(dssdev);\r\n}\r\nvoid dpi_set_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\nint r;\r\nDSSDBG("dpi_set_timings\n");\r\ndssdev->panel.timings = *timings;\r\nif (dssdev->state == OMAP_DSS_DISPLAY_ACTIVE) {\r\nr = dss_runtime_get();\r\nif (r)\r\nreturn;\r\nr = dispc_runtime_get();\r\nif (r) {\r\ndss_runtime_put();\r\nreturn;\r\n}\r\ndpi_set_mode(dssdev);\r\ndispc_mgr_go(dssdev->manager->id);\r\ndispc_runtime_put();\r\ndss_runtime_put();\r\n}\r\n}\r\nint dpi_check_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\nbool is_tft;\r\nint r;\r\nint lck_div, pck_div;\r\nunsigned long fck;\r\nunsigned long pck;\r\nstruct dispc_clock_info dispc_cinfo;\r\nif (!dispc_lcd_timings_ok(timings))\r\nreturn -EINVAL;\r\nif (timings->pixel_clock == 0)\r\nreturn -EINVAL;\r\nis_tft = (dssdev->panel.config & OMAP_DSS_LCD_TFT) != 0;\r\nif (dpi_use_dsi_pll(dssdev)) {\r\nstruct dsi_clock_info dsi_cinfo;\r\nr = dsi_pll_calc_clock_div_pck(dpi.dsidev, is_tft,\r\ntimings->pixel_clock * 1000,\r\n&dsi_cinfo, &dispc_cinfo);\r\nif (r)\r\nreturn r;\r\nfck = dsi_cinfo.dsi_pll_hsdiv_dispc_clk;\r\n} else {\r\nstruct dss_clock_info dss_cinfo;\r\nr = dss_calc_clock_div(is_tft, timings->pixel_clock * 1000,\r\n&dss_cinfo, &dispc_cinfo);\r\nif (r)\r\nreturn r;\r\nfck = dss_cinfo.fck;\r\n}\r\nlck_div = dispc_cinfo.lck_div;\r\npck_div = dispc_cinfo.pck_div;\r\npck = fck / lck_div / pck_div / 1000;\r\ntimings->pixel_clock = pck;\r\nreturn 0;\r\n}\r\nint dpi_init_display(struct omap_dss_device *dssdev)\r\n{\r\nDSSDBG("init_display\n");\r\nif (cpu_is_omap34xx() && dpi.vdds_dsi_reg == NULL) {\r\nstruct regulator *vdds_dsi;\r\nvdds_dsi = dss_get_vdds_dsi();\r\nif (IS_ERR(vdds_dsi)) {\r\nDSSERR("can't get VDDS_DSI regulator\n");\r\nreturn PTR_ERR(vdds_dsi);\r\n}\r\ndpi.vdds_dsi_reg = vdds_dsi;\r\n}\r\nif (dpi_use_dsi_pll(dssdev)) {\r\nenum omap_dss_clk_source dispc_fclk_src =\r\ndssdev->clocks.dispc.dispc_fclk_src;\r\ndpi.dsidev = dpi_get_dsidev(dispc_fclk_src);\r\n}\r\nreturn 0;\r\n}\r\nint dpi_init(void)\r\n{\r\nreturn 0;\r\n}\r\nvoid dpi_exit(void)\r\n{\r\n}
