static u8 fujitsu_ack(void)\r\n{\r\nreturn inb(fujitsu.io_base + 2);\r\n}\r\nstatic u8 fujitsu_status(void)\r\n{\r\nreturn inb(fujitsu.io_base + 6);\r\n}\r\nstatic u8 fujitsu_read_register(const u8 addr)\r\n{\r\noutb(addr, fujitsu.io_base);\r\nreturn inb(fujitsu.io_base + 4);\r\n}\r\nstatic void fujitsu_send_state(void)\r\n{\r\nint state;\r\nint dock, tablet_mode;\r\nstate = fujitsu_read_register(0xdd);\r\ndock = state & 0x02;\r\nif ((fujitsu.config.quirks & FORCE_TABLET_MODE_IF_UNDOCK) && (!dock)) {\r\ntablet_mode = 1;\r\n} else{\r\ntablet_mode = state & 0x01;\r\nif (fujitsu.config.quirks & INVERT_TABLET_MODE_BIT)\r\ntablet_mode = !tablet_mode;\r\n}\r\ninput_report_switch(fujitsu.idev, SW_DOCK, dock);\r\ninput_report_switch(fujitsu.idev, SW_TABLET_MODE, tablet_mode);\r\ninput_sync(fujitsu.idev);\r\n}\r\nstatic void fujitsu_reset(void)\r\n{\r\nint timeout = 50;\r\nfujitsu_ack();\r\nwhile ((fujitsu_status() & 0x02) && (--timeout))\r\nmsleep(20);\r\nfujitsu_send_state();\r\n}\r\nstatic int __devinit input_fujitsu_setup(struct device *parent,\r\nconst char *name, const char *phys)\r\n{\r\nstruct input_dev *idev;\r\nint error;\r\nint i;\r\nidev = input_allocate_device();\r\nif (!idev)\r\nreturn -ENOMEM;\r\nidev->dev.parent = parent;\r\nidev->phys = phys;\r\nidev->name = name;\r\nidev->id.bustype = BUS_HOST;\r\nidev->id.vendor = 0x1734;\r\nidev->id.product = 0x0001;\r\nidev->id.version = 0x0101;\r\nidev->keycode = fujitsu.config.keymap;\r\nidev->keycodesize = sizeof(fujitsu.config.keymap[0]);\r\nidev->keycodemax = ARRAY_SIZE(fujitsu.config.keymap);\r\n__set_bit(EV_REP, idev->evbit);\r\nfor (i = 0; i < ARRAY_SIZE(fujitsu.config.keymap); i++)\r\nif (fujitsu.config.keymap[i])\r\ninput_set_capability(idev, EV_KEY, fujitsu.config.keymap[i]);\r\ninput_set_capability(idev, EV_MSC, MSC_SCAN);\r\ninput_set_capability(idev, EV_SW, SW_DOCK);\r\ninput_set_capability(idev, EV_SW, SW_TABLET_MODE);\r\ninput_set_capability(idev, EV_SW, SW_DOCK);\r\ninput_set_capability(idev, EV_SW, SW_TABLET_MODE);\r\nerror = input_register_device(idev);\r\nif (error) {\r\ninput_free_device(idev);\r\nreturn error;\r\n}\r\nfujitsu.idev = idev;\r\nreturn 0;\r\n}\r\nstatic void input_fujitsu_remove(void)\r\n{\r\ninput_unregister_device(fujitsu.idev);\r\n}\r\nstatic irqreturn_t fujitsu_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned long keymask, changed;\r\nunsigned int keycode;\r\nint pressed;\r\nint i;\r\nif (unlikely(!(fujitsu_status() & 0x01)))\r\nreturn IRQ_NONE;\r\nfujitsu_send_state();\r\nkeymask = fujitsu_read_register(0xde);\r\nkeymask |= fujitsu_read_register(0xdf) << 8;\r\nkeymask ^= 0xffff;\r\nchanged = keymask ^ fujitsu.prev_keymask;\r\nif (changed) {\r\nfujitsu.prev_keymask = keymask;\r\nfor_each_set_bit(i, &changed, KEYMAP_LEN) {\r\nkeycode = fujitsu.config.keymap[i];\r\npressed = keymask & changed & BIT(i);\r\nif (pressed)\r\ninput_event(fujitsu.idev, EV_MSC, MSC_SCAN, i);\r\ninput_report_key(fujitsu.idev, keycode, pressed);\r\ninput_sync(fujitsu.idev);\r\n}\r\n}\r\nfujitsu_ack();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit fujitsu_dmi_default(const struct dmi_system_id *dmi)\r\n{\r\nprintk(KERN_INFO MODULENAME ": %s\n", dmi->ident);\r\nmemcpy(fujitsu.config.keymap, dmi->driver_data,\r\nsizeof(fujitsu.config.keymap));\r\nreturn 1;\r\n}\r\nstatic int __devinit fujitsu_dmi_stylistic(const struct dmi_system_id *dmi)\r\n{\r\nfujitsu_dmi_default(dmi);\r\nfujitsu.config.quirks |= FORCE_TABLET_MODE_IF_UNDOCK;\r\nfujitsu.config.quirks |= INVERT_TABLET_MODE_BIT;\r\nreturn 1;\r\n}\r\nstatic acpi_status __devinit\r\nfujitsu_walk_resources(struct acpi_resource *res, void *data)\r\n{\r\nswitch (res->type) {\r\ncase ACPI_RESOURCE_TYPE_IRQ:\r\nfujitsu.irq = res->data.irq.interrupts[0];\r\nreturn AE_OK;\r\ncase ACPI_RESOURCE_TYPE_IO:\r\nfujitsu.io_base = res->data.io.minimum;\r\nfujitsu.io_length = res->data.io.address_length;\r\nreturn AE_OK;\r\ncase ACPI_RESOURCE_TYPE_END_TAG:\r\nif (fujitsu.irq && fujitsu.io_base)\r\nreturn AE_OK;\r\nelse\r\nreturn AE_NOT_FOUND;\r\ndefault:\r\nreturn AE_ERROR;\r\n}\r\n}\r\nstatic int __devinit acpi_fujitsu_add(struct acpi_device *adev)\r\n{\r\nacpi_status status;\r\nint error;\r\nif (!adev)\r\nreturn -EINVAL;\r\nstatus = acpi_walk_resources(adev->handle, METHOD_NAME__CRS,\r\nfujitsu_walk_resources, NULL);\r\nif (ACPI_FAILURE(status) || !fujitsu.irq || !fujitsu.io_base)\r\nreturn -ENODEV;\r\nsprintf(acpi_device_name(adev), "Fujitsu %s", acpi_device_hid(adev));\r\nsprintf(acpi_device_class(adev), "%s", ACPI_FUJITSU_CLASS);\r\nsnprintf(fujitsu.phys, sizeof(fujitsu.phys),\r\n"%s/input0", acpi_device_hid(adev));\r\nerror = input_fujitsu_setup(&adev->dev,\r\nacpi_device_name(adev), fujitsu.phys);\r\nif (error)\r\nreturn error;\r\nif (!request_region(fujitsu.io_base, fujitsu.io_length, MODULENAME)) {\r\ninput_fujitsu_remove();\r\nreturn -EBUSY;\r\n}\r\nfujitsu_reset();\r\nerror = request_irq(fujitsu.irq, fujitsu_interrupt,\r\nIRQF_SHARED, MODULENAME, fujitsu_interrupt);\r\nif (error) {\r\nrelease_region(fujitsu.io_base, fujitsu.io_length);\r\ninput_fujitsu_remove();\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devexit acpi_fujitsu_remove(struct acpi_device *adev, int type)\r\n{\r\nfree_irq(fujitsu.irq, fujitsu_interrupt);\r\nrelease_region(fujitsu.io_base, fujitsu.io_length);\r\ninput_fujitsu_remove();\r\nreturn 0;\r\n}\r\nstatic int acpi_fujitsu_resume(struct acpi_device *adev)\r\n{\r\nfujitsu_reset();\r\nreturn 0;\r\n}\r\nstatic int __init fujitsu_module_init(void)\r\n{\r\nint error;\r\ndmi_check_system(dmi_ids);\r\nerror = acpi_bus_register_driver(&acpi_fujitsu_driver);\r\nif (error)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic void __exit fujitsu_module_exit(void)\r\n{\r\nacpi_bus_unregister_driver(&acpi_fujitsu_driver);\r\n}
