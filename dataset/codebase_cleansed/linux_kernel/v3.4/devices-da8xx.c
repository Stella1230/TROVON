int __init da830_register_edma(struct edma_rsv_info *rsv)\r\n{\r\nda830_edma_cc0_info.rsv = rsv;\r\nreturn platform_device_register(&da830_edma_device);\r\n}\r\nint __init da850_register_edma(struct edma_rsv_info *rsv[2])\r\n{\r\nif (rsv) {\r\nda850_edma_cc_info[0].rsv = rsv[0];\r\nda850_edma_cc_info[1].rsv = rsv[1];\r\n}\r\nreturn platform_device_register(&da850_edma_device);\r\n}\r\nint __init da8xx_register_i2c(int instance,\r\nstruct davinci_i2c_platform_data *pdata)\r\n{\r\nstruct platform_device *pdev;\r\nif (instance == 0)\r\npdev = &da8xx_i2c_device0;\r\nelse if (instance == 1)\r\npdev = &da8xx_i2c_device1;\r\nelse\r\nreturn -EINVAL;\r\npdev->dev.platform_data = pdata;\r\nreturn platform_device_register(pdev);\r\n}\r\nvoid da8xx_restart(char mode, const char *cmd)\r\n{\r\ndavinci_watchdog_reset(&da8xx_wdt_device);\r\n}\r\nint __init da8xx_register_watchdog(void)\r\n{\r\nreturn platform_device_register(&da8xx_wdt_device);\r\n}\r\nint __init da8xx_register_emac(void)\r\n{\r\nint ret;\r\nret = platform_device_register(&da8xx_mdio_device);\r\nif (ret < 0)\r\nreturn ret;\r\nret = platform_device_register(&da8xx_emac_device);\r\nif (ret < 0)\r\nreturn ret;\r\nret = clk_add_alias(NULL, dev_name(&da8xx_mdio_device.dev),\r\nNULL, &da8xx_emac_device.dev);\r\nreturn ret;\r\n}\r\nvoid __init da8xx_register_mcasp(int id, struct snd_platform_data *pdata)\r\n{\r\nplatform_device_register(&davinci_pcm_device);\r\nif (cpu_is_davinci_da830() && id == 1) {\r\nda830_mcasp1_device.dev.platform_data = pdata;\r\nplatform_device_register(&da830_mcasp1_device);\r\n} else if (cpu_is_davinci_da850()) {\r\nda850_mcasp_device.dev.platform_data = pdata;\r\nplatform_device_register(&da850_mcasp_device);\r\n}\r\n}\r\nint __init da8xx_register_lcdc(struct da8xx_lcdc_platform_data *pdata)\r\n{\r\nda8xx_lcdc_device.dev.platform_data = pdata;\r\nreturn platform_device_register(&da8xx_lcdc_device);\r\n}\r\nint __init da8xx_register_mmcsd0(struct davinci_mmc_config *config)\r\n{\r\nda8xx_mmcsd0_device.dev.platform_data = config;\r\nreturn platform_device_register(&da8xx_mmcsd0_device);\r\n}\r\nint __init da850_register_mmcsd1(struct davinci_mmc_config *config)\r\n{\r\nda850_mmcsd1_device.dev.platform_data = config;\r\nreturn platform_device_register(&da850_mmcsd1_device);\r\n}\r\nint da8xx_register_rtc(void)\r\n{\r\nint ret;\r\nvoid __iomem *base;\r\nbase = ioremap(DA8XX_RTC_BASE, SZ_4K);\r\nif (WARN_ON(!base))\r\nreturn -ENOMEM;\r\n__raw_writel(0x83e70b13, base + 0x6c);\r\n__raw_writel(0x95a4f1e0, base + 0x70);\r\niounmap(base);\r\nret = platform_device_register(&da8xx_rtc_device);\r\nif (!ret)\r\ndevice_init_wakeup(&da8xx_rtc_device.dev, true);\r\nreturn ret;\r\n}\r\nvoid __iomem * __init da8xx_get_mem_ctlr(void)\r\n{\r\nif (da8xx_ddr2_ctlr_base)\r\nreturn da8xx_ddr2_ctlr_base;\r\nda8xx_ddr2_ctlr_base = ioremap(DA8XX_DDR2_CTL_BASE, SZ_32K);\r\nif (!da8xx_ddr2_ctlr_base)\r\npr_warning("%s: Unable to map DDR2 controller", __func__);\r\nreturn da8xx_ddr2_ctlr_base;\r\n}\r\nint __init da8xx_register_cpuidle(void)\r\n{\r\nda8xx_cpuidle_pdata.ddr2_ctlr_base = da8xx_get_mem_ctlr();\r\nreturn platform_device_register(&da8xx_cpuidle_device);\r\n}\r\nint __init da8xx_register_spi(int instance, struct spi_board_info *info,\r\nunsigned len)\r\n{\r\nint ret;\r\nif (instance < 0 || instance > 1)\r\nreturn -EINVAL;\r\nret = spi_register_board_info(info, len);\r\nif (ret)\r\npr_warning("%s: failed to register board info for spi %d :"\r\n" %d\n", __func__, instance, ret);\r\nda8xx_spi_pdata[instance].num_chipselect = len;\r\nif (instance == 1 && cpu_is_davinci_da850()) {\r\nda8xx_spi1_resources[0].start = DA850_SPI1_BASE;\r\nda8xx_spi1_resources[0].end = DA850_SPI1_BASE + SZ_4K - 1;\r\n}\r\nreturn platform_device_register(&da8xx_spi_device[instance]);\r\n}\r\nstatic int da850_sata_init(struct device *dev, void __iomem *addr)\r\n{\r\nint i, ret;\r\nunsigned int val;\r\nda850_sata_clk = clk_get(dev, NULL);\r\nif (IS_ERR(da850_sata_clk))\r\nreturn PTR_ERR(da850_sata_clk);\r\nret = clk_enable(da850_sata_clk);\r\nif (ret)\r\ngoto err0;\r\nval = __raw_readl(DA8XX_SYSCFG1_VIRT(DA8XX_PWRDN_REG));\r\nval &= ~BIT(0);\r\n__raw_writel(val, DA8XX_SYSCFG1_VIRT(DA8XX_PWRDN_REG));\r\nfor (i = 0; i < ARRAY_SIZE(da850_sata_xtal); i++)\r\nif (da850_sata_xtal[i] == da850_sata_refclkpn)\r\nbreak;\r\nif (i == ARRAY_SIZE(da850_sata_xtal)) {\r\nret = -EINVAL;\r\ngoto err1;\r\n}\r\nval = SATA_PHY_MPY(i + 1) |\r\nSATA_PHY_LOS(1) |\r\nSATA_PHY_RXCDR(4) |\r\nSATA_PHY_RXEQ(1) |\r\nSATA_PHY_TXSWING(3) |\r\nSATA_PHY_ENPLL(1);\r\n__raw_writel(val, addr + SATA_P0PHYCR_REG);\r\nreturn 0;\r\nerr1:\r\nclk_disable(da850_sata_clk);\r\nerr0:\r\nclk_put(da850_sata_clk);\r\nreturn ret;\r\n}\r\nstatic void da850_sata_exit(struct device *dev)\r\n{\r\nclk_disable(da850_sata_clk);\r\nclk_put(da850_sata_clk);\r\n}\r\nint __init da850_register_sata(unsigned long refclkpn)\r\n{\r\nda850_sata_refclkpn = refclkpn;\r\nif (!da850_sata_refclkpn)\r\nreturn -EINVAL;\r\nreturn platform_device_register(&da850_sata_device);\r\n}
