static u8 cc770_platform_read_reg(const struct cc770_priv *priv, int reg)\r\n{\r\nreturn ioread8(priv->reg_base + reg);\r\n}\r\nstatic void cc770_platform_write_reg(const struct cc770_priv *priv, int reg,\r\nu8 val)\r\n{\r\niowrite8(val, priv->reg_base + reg);\r\n}\r\nstatic int __devinit cc770_get_of_node_data(struct platform_device *pdev,\r\nstruct cc770_priv *priv)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst u32 *prop;\r\nint prop_size;\r\nu32 clkext;\r\nprop = of_get_property(np, "bosch,external-clock-frequency",\r\n&prop_size);\r\nif (prop && (prop_size == sizeof(u32)))\r\nclkext = *prop;\r\nelse\r\nclkext = CC770_PLATFORM_CAN_CLOCK;\r\npriv->can.clock.freq = clkext;\r\nif (priv->can.clock.freq > 10000000) {\r\npriv->cpu_interface |= CPUIF_DSC;\r\npriv->can.clock.freq /= 2;\r\n}\r\nif (priv->can.clock.freq > 8000000)\r\npriv->cpu_interface |= CPUIF_DMC;\r\nif (of_get_property(np, "bosch,divide-memory-clock", NULL))\r\npriv->cpu_interface |= CPUIF_DMC;\r\nif (of_get_property(np, "bosch,iso-low-speed-mux", NULL))\r\npriv->cpu_interface |= CPUIF_MUX;\r\nif (!of_get_property(np, "bosch,no-comperator-bypass", NULL))\r\npriv->bus_config |= BUSCFG_CBY;\r\nif (of_get_property(np, "bosch,disconnect-rx0-input", NULL))\r\npriv->bus_config |= BUSCFG_DR0;\r\nif (of_get_property(np, "bosch,disconnect-rx1-input", NULL))\r\npriv->bus_config |= BUSCFG_DR1;\r\nif (of_get_property(np, "bosch,disconnect-tx1-output", NULL))\r\npriv->bus_config |= BUSCFG_DT1;\r\nif (of_get_property(np, "bosch,polarity-dominant", NULL))\r\npriv->bus_config |= BUSCFG_POL;\r\nprop = of_get_property(np, "bosch,clock-out-frequency", &prop_size);\r\nif (prop && (prop_size == sizeof(u32)) && *prop > 0) {\r\nu32 cdv = clkext / *prop;\r\nint slew;\r\nif (cdv > 0 && cdv < 16) {\r\npriv->cpu_interface |= CPUIF_CEN;\r\npriv->clkout |= (cdv - 1) & CLKOUT_CD_MASK;\r\nprop = of_get_property(np, "bosch,slew-rate",\r\n&prop_size);\r\nif (prop && (prop_size == sizeof(u32))) {\r\nslew = *prop;\r\n} else {\r\nslew = (CLKOUT_SL_MASK >>\r\nCLKOUT_SL_SHIFT) -\r\n((cdv * clkext - 1) / 8000000);\r\nif (slew < 0)\r\nslew = 0;\r\n}\r\npriv->clkout |= (slew << CLKOUT_SL_SHIFT) &\r\nCLKOUT_SL_MASK;\r\n} else {\r\ndev_dbg(&pdev->dev, "invalid clock-out-frequency\n");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit cc770_get_platform_data(struct platform_device *pdev,\r\nstruct cc770_priv *priv)\r\n{\r\nstruct cc770_platform_data *pdata = pdev->dev.platform_data;\r\npriv->can.clock.freq = pdata->osc_freq;\r\nif (priv->cpu_interface | CPUIF_DSC)\r\npriv->can.clock.freq /= 2;\r\npriv->clkout = pdata->cor;\r\npriv->bus_config = pdata->bcr;\r\npriv->cpu_interface = pdata->cir;\r\nreturn 0;\r\n}\r\nstatic int __devinit cc770_platform_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct cc770_priv *priv;\r\nstruct resource *mem;\r\nresource_size_t mem_size;\r\nvoid __iomem *base;\r\nint err, irq;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!mem || irq <= 0)\r\nreturn -ENODEV;\r\nmem_size = resource_size(mem);\r\nif (!request_mem_region(mem->start, mem_size, pdev->name))\r\nreturn -EBUSY;\r\nbase = ioremap(mem->start, mem_size);\r\nif (!base) {\r\nerr = -ENOMEM;\r\ngoto exit_release_mem;\r\n}\r\ndev = alloc_cc770dev(0);\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto exit_unmap_mem;\r\n}\r\ndev->irq = irq;\r\npriv = netdev_priv(dev);\r\npriv->read_reg = cc770_platform_read_reg;\r\npriv->write_reg = cc770_platform_write_reg;\r\npriv->irq_flags = IRQF_SHARED;\r\npriv->reg_base = base;\r\nif (pdev->dev.of_node)\r\nerr = cc770_get_of_node_data(pdev, priv);\r\nelse if (pdev->dev.platform_data)\r\nerr = cc770_get_platform_data(pdev, priv);\r\nelse\r\nerr = -ENODEV;\r\nif (err)\r\ngoto exit_free_cc770;\r\ndev_dbg(&pdev->dev,\r\n"reg_base=0x%p irq=%d clock=%d cpu_interface=0x%02x "\r\n"bus_config=0x%02x clkout=0x%02x\n",\r\npriv->reg_base, dev->irq, priv->can.clock.freq,\r\npriv->cpu_interface, priv->bus_config, priv->clkout);\r\ndev_set_drvdata(&pdev->dev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nerr = register_cc770dev(dev);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"couldn't register CC700 device (err=%d)\n", err);\r\ngoto exit_free_cc770;\r\n}\r\nreturn 0;\r\nexit_free_cc770:\r\nfree_cc770dev(dev);\r\nexit_unmap_mem:\r\niounmap(base);\r\nexit_release_mem:\r\nrelease_mem_region(mem->start, mem_size);\r\nreturn err;\r\n}\r\nstatic int __devexit cc770_platform_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = dev_get_drvdata(&pdev->dev);\r\nstruct cc770_priv *priv = netdev_priv(dev);\r\nstruct resource *mem;\r\nunregister_cc770dev(dev);\r\niounmap(priv->reg_base);\r\nfree_cc770dev(dev);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nreturn 0;\r\n}
