struct iscsi_cls_session *beiscsi_session_create(struct iscsi_endpoint *ep,\r\nu16 cmds_max,\r\nu16 qdepth,\r\nu32 initial_cmdsn)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct beiscsi_endpoint *beiscsi_ep;\r\nstruct iscsi_cls_session *cls_session;\r\nstruct beiscsi_hba *phba;\r\nstruct iscsi_session *sess;\r\nstruct beiscsi_session *beiscsi_sess;\r\nstruct beiscsi_io_task *io_task;\r\nSE_DEBUG(DBG_LVL_8, "In beiscsi_session_create\n");\r\nif (!ep) {\r\nSE_DEBUG(DBG_LVL_1, "beiscsi_session_create: invalid ep\n");\r\nreturn NULL;\r\n}\r\nbeiscsi_ep = ep->dd_data;\r\nphba = beiscsi_ep->phba;\r\nshost = phba->shost;\r\nif (cmds_max > beiscsi_ep->phba->params.wrbs_per_cxn) {\r\nshost_printk(KERN_ERR, shost, "Cannot handle %d cmds."\r\n"Max cmds per session supported is %d. Using %d. "\r\n"\n", cmds_max,\r\nbeiscsi_ep->phba->params.wrbs_per_cxn,\r\nbeiscsi_ep->phba->params.wrbs_per_cxn);\r\ncmds_max = beiscsi_ep->phba->params.wrbs_per_cxn;\r\n}\r\ncls_session = iscsi_session_setup(&beiscsi_iscsi_transport,\r\nshost, cmds_max,\r\nsizeof(*beiscsi_sess),\r\nsizeof(*io_task),\r\ninitial_cmdsn, ISCSI_MAX_TARGET);\r\nif (!cls_session)\r\nreturn NULL;\r\nsess = cls_session->dd_data;\r\nbeiscsi_sess = sess->dd_data;\r\nbeiscsi_sess->bhs_pool = pci_pool_create("beiscsi_bhs_pool",\r\nphba->pcidev,\r\nsizeof(struct be_cmd_bhs),\r\n64, 0);\r\nif (!beiscsi_sess->bhs_pool)\r\ngoto destroy_sess;\r\nreturn cls_session;\r\ndestroy_sess:\r\niscsi_session_teardown(cls_session);\r\nreturn NULL;\r\n}\r\nvoid beiscsi_session_destroy(struct iscsi_cls_session *cls_session)\r\n{\r\nstruct iscsi_session *sess = cls_session->dd_data;\r\nstruct beiscsi_session *beiscsi_sess = sess->dd_data;\r\nSE_DEBUG(DBG_LVL_8, "In beiscsi_session_destroy\n");\r\npci_pool_destroy(beiscsi_sess->bhs_pool);\r\niscsi_session_teardown(cls_session);\r\n}\r\nstruct iscsi_cls_conn *\r\nbeiscsi_conn_create(struct iscsi_cls_session *cls_session, u32 cid)\r\n{\r\nstruct beiscsi_hba *phba;\r\nstruct Scsi_Host *shost;\r\nstruct iscsi_cls_conn *cls_conn;\r\nstruct beiscsi_conn *beiscsi_conn;\r\nstruct iscsi_conn *conn;\r\nstruct iscsi_session *sess;\r\nstruct beiscsi_session *beiscsi_sess;\r\nSE_DEBUG(DBG_LVL_8, "In beiscsi_conn_create ,cid"\r\n"from iscsi layer=%d\n", cid);\r\nshost = iscsi_session_to_shost(cls_session);\r\nphba = iscsi_host_priv(shost);\r\ncls_conn = iscsi_conn_setup(cls_session, sizeof(*beiscsi_conn), cid);\r\nif (!cls_conn)\r\nreturn NULL;\r\nconn = cls_conn->dd_data;\r\nbeiscsi_conn = conn->dd_data;\r\nbeiscsi_conn->ep = NULL;\r\nbeiscsi_conn->phba = phba;\r\nbeiscsi_conn->conn = conn;\r\nsess = cls_session->dd_data;\r\nbeiscsi_sess = sess->dd_data;\r\nbeiscsi_conn->beiscsi_sess = beiscsi_sess;\r\nreturn cls_conn;\r\n}\r\nstatic int beiscsi_bindconn_cid(struct beiscsi_hba *phba,\r\nstruct beiscsi_conn *beiscsi_conn,\r\nunsigned int cid)\r\n{\r\nif (phba->conn_table[cid]) {\r\nSE_DEBUG(DBG_LVL_1,\r\n"Connection table already occupied. Detected clash\n");\r\nreturn -EINVAL;\r\n} else {\r\nSE_DEBUG(DBG_LVL_8, "phba->conn_table[%d]=%p(beiscsi_conn)\n",\r\ncid, beiscsi_conn);\r\nphba->conn_table[cid] = beiscsi_conn;\r\n}\r\nreturn 0;\r\n}\r\nint beiscsi_conn_bind(struct iscsi_cls_session *cls_session,\r\nstruct iscsi_cls_conn *cls_conn,\r\nu64 transport_fd, int is_leading)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct beiscsi_conn *beiscsi_conn = conn->dd_data;\r\nstruct Scsi_Host *shost = iscsi_session_to_shost(cls_session);\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\nstruct beiscsi_endpoint *beiscsi_ep;\r\nstruct iscsi_endpoint *ep;\r\nSE_DEBUG(DBG_LVL_8, "In beiscsi_conn_bind\n");\r\nep = iscsi_lookup_endpoint(transport_fd);\r\nif (!ep)\r\nreturn -EINVAL;\r\nbeiscsi_ep = ep->dd_data;\r\nif (iscsi_conn_bind(cls_session, cls_conn, is_leading))\r\nreturn -EINVAL;\r\nif (beiscsi_ep->phba != phba) {\r\nSE_DEBUG(DBG_LVL_8,\r\n"beiscsi_ep->hba=%p not equal to phba=%p\n",\r\nbeiscsi_ep->phba, phba);\r\nreturn -EEXIST;\r\n}\r\nbeiscsi_conn->beiscsi_conn_cid = beiscsi_ep->ep_cid;\r\nbeiscsi_conn->ep = beiscsi_ep;\r\nbeiscsi_ep->conn = beiscsi_conn;\r\nSE_DEBUG(DBG_LVL_8, "beiscsi_conn=%p conn=%p ep_cid=%d\n",\r\nbeiscsi_conn, conn, beiscsi_ep->ep_cid);\r\nreturn beiscsi_bindconn_cid(phba, beiscsi_conn, beiscsi_ep->ep_cid);\r\n}\r\nint beiscsi_ep_get_param(struct iscsi_endpoint *ep,\r\nenum iscsi_param param, char *buf)\r\n{\r\nstruct beiscsi_endpoint *beiscsi_ep = ep->dd_data;\r\nint len = 0;\r\nSE_DEBUG(DBG_LVL_8, "In beiscsi_conn_get_param, param= %d\n", param);\r\nswitch (param) {\r\ncase ISCSI_PARAM_CONN_PORT:\r\nlen = sprintf(buf, "%hu\n", beiscsi_ep->dst_tcpport);\r\nbreak;\r\ncase ISCSI_PARAM_CONN_ADDRESS:\r\nif (beiscsi_ep->ip_type == BE2_IPV4)\r\nlen = sprintf(buf, "%pI4\n", &beiscsi_ep->dst_addr);\r\nelse\r\nlen = sprintf(buf, "%pI6\n", &beiscsi_ep->dst6_addr);\r\nbreak;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn len;\r\n}\r\nint beiscsi_set_param(struct iscsi_cls_conn *cls_conn,\r\nenum iscsi_param param, char *buf, int buflen)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct iscsi_session *session = conn->session;\r\nint ret;\r\nSE_DEBUG(DBG_LVL_8, "In beiscsi_conn_set_param, param= %d\n", param);\r\nret = iscsi_set_param(cls_conn, param, buf, buflen);\r\nif (ret)\r\nreturn ret;\r\nswitch (param) {\r\ncase ISCSI_PARAM_FIRST_BURST:\r\nif (session->first_burst > 8192)\r\nsession->first_burst = 8192;\r\nbreak;\r\ncase ISCSI_PARAM_MAX_RECV_DLENGTH:\r\nif (conn->max_recv_dlength > 65536)\r\nconn->max_recv_dlength = 65536;\r\nbreak;\r\ncase ISCSI_PARAM_MAX_BURST:\r\nif (session->max_burst > 262144)\r\nsession->max_burst = 262144;\r\nbreak;\r\ncase ISCSI_PARAM_MAX_XMIT_DLENGTH:\r\nif ((conn->max_xmit_dlength > 65536) ||\r\n(conn->max_xmit_dlength == 0))\r\nconn->max_xmit_dlength = 65536;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nint beiscsi_get_host_param(struct Scsi_Host *shost,\r\nenum iscsi_host_param param, char *buf)\r\n{\r\nstruct beiscsi_hba *phba = iscsi_host_priv(shost);\r\nint status = 0;\r\nSE_DEBUG(DBG_LVL_8, "In beiscsi_get_host_param, param= %d\n", param);\r\nswitch (param) {\r\ncase ISCSI_HOST_PARAM_HWADDRESS:\r\nstatus = beiscsi_get_macaddr(buf, phba);\r\nif (status < 0) {\r\nSE_DEBUG(DBG_LVL_1, "beiscsi_get_macaddr Failed\n");\r\nreturn status;\r\n}\r\nbreak;\r\ndefault:\r\nreturn iscsi_host_get_param(shost, param, buf);\r\n}\r\nreturn status;\r\n}\r\nint beiscsi_get_macaddr(char *buf, struct beiscsi_hba *phba)\r\n{\r\nstruct be_cmd_resp_get_mac_addr *resp;\r\nstruct be_mcc_wrb *wrb;\r\nunsigned int tag, wrb_num;\r\nunsigned short status, extd_status;\r\nstruct be_queue_info *mccq = &phba->ctrl.mcc_obj.q;\r\nint rc;\r\nif (phba->read_mac_address)\r\nreturn sysfs_format_mac(buf, phba->mac_address,\r\nETH_ALEN);\r\ntag = be_cmd_get_mac_addr(phba);\r\nif (!tag) {\r\nSE_DEBUG(DBG_LVL_1, "be_cmd_get_mac_addr Failed\n");\r\nreturn -EBUSY;\r\n} else\r\nwait_event_interruptible(phba->ctrl.mcc_wait[tag],\r\nphba->ctrl.mcc_numtag[tag]);\r\nwrb_num = (phba->ctrl.mcc_numtag[tag] & 0x00FF0000) >> 16;\r\nextd_status = (phba->ctrl.mcc_numtag[tag] & 0x0000FF00) >> 8;\r\nstatus = phba->ctrl.mcc_numtag[tag] & 0x000000FF;\r\nif (status || extd_status) {\r\nSE_DEBUG(DBG_LVL_1, "Failed to get be_cmd_get_mac_addr"\r\n" status = %d extd_status = %d\n",\r\nstatus, extd_status);\r\nfree_mcc_tag(&phba->ctrl, tag);\r\nreturn -EAGAIN;\r\n}\r\nwrb = queue_get_wrb(mccq, wrb_num);\r\nfree_mcc_tag(&phba->ctrl, tag);\r\nresp = embedded_payload(wrb);\r\nmemcpy(phba->mac_address, resp->mac_address, ETH_ALEN);\r\nrc = sysfs_format_mac(buf, phba->mac_address,\r\nETH_ALEN);\r\nphba->read_mac_address = 1;\r\nreturn rc;\r\n}\r\nvoid beiscsi_conn_get_stats(struct iscsi_cls_conn *cls_conn,\r\nstruct iscsi_stats *stats)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nSE_DEBUG(DBG_LVL_8, "In beiscsi_conn_get_stats\n");\r\nstats->txdata_octets = conn->txdata_octets;\r\nstats->rxdata_octets = conn->rxdata_octets;\r\nstats->dataout_pdus = conn->dataout_pdus_cnt;\r\nstats->scsirsp_pdus = conn->scsirsp_pdus_cnt;\r\nstats->scsicmd_pdus = conn->scsicmd_pdus_cnt;\r\nstats->datain_pdus = conn->datain_pdus_cnt;\r\nstats->tmfrsp_pdus = conn->tmfrsp_pdus_cnt;\r\nstats->tmfcmd_pdus = conn->tmfcmd_pdus_cnt;\r\nstats->r2t_pdus = conn->r2t_pdus_cnt;\r\nstats->digest_err = 0;\r\nstats->timeout_err = 0;\r\nstats->custom_length = 0;\r\nstrcpy(stats->custom[0].desc, "eh_abort_cnt");\r\nstats->custom[0].value = conn->eh_abort_cnt;\r\n}\r\nstatic void beiscsi_set_params_for_offld(struct beiscsi_conn *beiscsi_conn,\r\nstruct beiscsi_offload_params *params)\r\n{\r\nstruct iscsi_conn *conn = beiscsi_conn->conn;\r\nstruct iscsi_session *session = conn->session;\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params, max_burst_length,\r\nparams, session->max_burst);\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params,\r\nmax_send_data_segment_length, params,\r\nconn->max_xmit_dlength);\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params, first_burst_length,\r\nparams, session->first_burst);\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params, erl, params,\r\nsession->erl);\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params, dde, params,\r\nconn->datadgst_en);\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params, hde, params,\r\nconn->hdrdgst_en);\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params, ir2t, params,\r\nsession->initial_r2t_en);\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params, imd, params,\r\nsession->imm_data_en);\r\nAMAP_SET_BITS(struct amap_beiscsi_offload_params, exp_statsn, params,\r\n(conn->exp_statsn - 1));\r\n}\r\nint beiscsi_conn_start(struct iscsi_cls_conn *cls_conn)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct beiscsi_conn *beiscsi_conn = conn->dd_data;\r\nstruct beiscsi_endpoint *beiscsi_ep;\r\nstruct beiscsi_offload_params params;\r\nSE_DEBUG(DBG_LVL_8, "In beiscsi_conn_start\n");\r\nmemset(&params, 0, sizeof(struct beiscsi_offload_params));\r\nbeiscsi_ep = beiscsi_conn->ep;\r\nif (!beiscsi_ep)\r\nSE_DEBUG(DBG_LVL_1, "In beiscsi_conn_start , no beiscsi_ep\n");\r\nbeiscsi_conn->login_in_progress = 0;\r\nbeiscsi_set_params_for_offld(beiscsi_conn, &params);\r\nbeiscsi_offload_connection(beiscsi_conn, &params);\r\niscsi_conn_start(cls_conn);\r\nreturn 0;\r\n}\r\nstatic int beiscsi_get_cid(struct beiscsi_hba *phba)\r\n{\r\nunsigned short cid = 0xFFFF;\r\nif (!phba->avlbl_cids)\r\nreturn cid;\r\ncid = phba->cid_array[phba->cid_alloc++];\r\nif (phba->cid_alloc == phba->params.cxns_per_ctrl)\r\nphba->cid_alloc = 0;\r\nphba->avlbl_cids--;\r\nreturn cid;\r\n}\r\nstatic void beiscsi_put_cid(struct beiscsi_hba *phba, unsigned short cid)\r\n{\r\nphba->avlbl_cids++;\r\nphba->cid_array[phba->cid_free++] = cid;\r\nif (phba->cid_free == phba->params.cxns_per_ctrl)\r\nphba->cid_free = 0;\r\n}\r\nstatic void beiscsi_free_ep(struct beiscsi_endpoint *beiscsi_ep)\r\n{\r\nstruct beiscsi_hba *phba = beiscsi_ep->phba;\r\nbeiscsi_put_cid(phba, beiscsi_ep->ep_cid);\r\nbeiscsi_ep->phba = NULL;\r\n}\r\nstatic int beiscsi_open_conn(struct iscsi_endpoint *ep,\r\nstruct sockaddr *src_addr,\r\nstruct sockaddr *dst_addr, int non_blocking)\r\n{\r\nstruct beiscsi_endpoint *beiscsi_ep = ep->dd_data;\r\nstruct beiscsi_hba *phba = beiscsi_ep->phba;\r\nstruct be_queue_info *mccq = &phba->ctrl.mcc_obj.q;\r\nstruct be_mcc_wrb *wrb;\r\nstruct tcp_connect_and_offload_out *ptcpcnct_out;\r\nunsigned short status, extd_status;\r\nstruct be_dma_mem nonemb_cmd;\r\nunsigned int tag, wrb_num;\r\nint ret = -ENOMEM;\r\nSE_DEBUG(DBG_LVL_8, "In beiscsi_open_conn\n");\r\nbeiscsi_ep->ep_cid = beiscsi_get_cid(phba);\r\nif (beiscsi_ep->ep_cid == 0xFFFF) {\r\nSE_DEBUG(DBG_LVL_1, "No free cid available\n");\r\nreturn ret;\r\n}\r\nSE_DEBUG(DBG_LVL_8, "In beiscsi_open_conn, ep_cid=%d\n",\r\nbeiscsi_ep->ep_cid);\r\nphba->ep_array[beiscsi_ep->ep_cid -\r\nphba->fw_config.iscsi_cid_start] = ep;\r\nif (beiscsi_ep->ep_cid > (phba->fw_config.iscsi_cid_start +\r\nphba->params.cxns_per_ctrl * 2)) {\r\nSE_DEBUG(DBG_LVL_1, "Failed in allocate iscsi cid\n");\r\ngoto free_ep;\r\n}\r\nbeiscsi_ep->cid_vld = 0;\r\nnonemb_cmd.va = pci_alloc_consistent(phba->ctrl.pdev,\r\nsizeof(struct tcp_connect_and_offload_in),\r\n&nonemb_cmd.dma);\r\nif (nonemb_cmd.va == NULL) {\r\nSE_DEBUG(DBG_LVL_1,\r\n"Failed to allocate memory for mgmt_open_connection"\r\n"\n");\r\nbeiscsi_put_cid(phba, beiscsi_ep->ep_cid);\r\nreturn -ENOMEM;\r\n}\r\nnonemb_cmd.size = sizeof(struct tcp_connect_and_offload_in);\r\nmemset(nonemb_cmd.va, 0, nonemb_cmd.size);\r\ntag = mgmt_open_connection(phba, dst_addr, beiscsi_ep, &nonemb_cmd);\r\nif (!tag) {\r\nSE_DEBUG(DBG_LVL_1,\r\n"mgmt_open_connection Failed for cid=%d\n",\r\nbeiscsi_ep->ep_cid);\r\nbeiscsi_put_cid(phba, beiscsi_ep->ep_cid);\r\npci_free_consistent(phba->ctrl.pdev, nonemb_cmd.size,\r\nnonemb_cmd.va, nonemb_cmd.dma);\r\nreturn -EAGAIN;\r\n} else {\r\nwait_event_interruptible(phba->ctrl.mcc_wait[tag],\r\nphba->ctrl.mcc_numtag[tag]);\r\n}\r\nwrb_num = (phba->ctrl.mcc_numtag[tag] & 0x00FF0000) >> 16;\r\nextd_status = (phba->ctrl.mcc_numtag[tag] & 0x0000FF00) >> 8;\r\nstatus = phba->ctrl.mcc_numtag[tag] & 0x000000FF;\r\nif (status || extd_status) {\r\nSE_DEBUG(DBG_LVL_1, "mgmt_open_connection Failed"\r\n" status = %d extd_status = %d\n",\r\nstatus, extd_status);\r\nfree_mcc_tag(&phba->ctrl, tag);\r\npci_free_consistent(phba->ctrl.pdev, nonemb_cmd.size,\r\nnonemb_cmd.va, nonemb_cmd.dma);\r\ngoto free_ep;\r\n} else {\r\nwrb = queue_get_wrb(mccq, wrb_num);\r\nfree_mcc_tag(&phba->ctrl, tag);\r\nptcpcnct_out = embedded_payload(wrb);\r\nbeiscsi_ep = ep->dd_data;\r\nbeiscsi_ep->fw_handle = ptcpcnct_out->connection_handle;\r\nbeiscsi_ep->cid_vld = 1;\r\nSE_DEBUG(DBG_LVL_8, "mgmt_open_connection Success\n");\r\n}\r\npci_free_consistent(phba->ctrl.pdev, nonemb_cmd.size,\r\nnonemb_cmd.va, nonemb_cmd.dma);\r\nreturn 0;\r\nfree_ep:\r\nbeiscsi_free_ep(beiscsi_ep);\r\nreturn -EBUSY;\r\n}\r\nstruct iscsi_endpoint *\r\nbeiscsi_ep_connect(struct Scsi_Host *shost, struct sockaddr *dst_addr,\r\nint non_blocking)\r\n{\r\nstruct beiscsi_hba *phba;\r\nstruct beiscsi_endpoint *beiscsi_ep;\r\nstruct iscsi_endpoint *ep;\r\nint ret;\r\nSE_DEBUG(DBG_LVL_8, "In beiscsi_ep_connect\n");\r\nif (shost)\r\nphba = iscsi_host_priv(shost);\r\nelse {\r\nret = -ENXIO;\r\nSE_DEBUG(DBG_LVL_1, "shost is NULL\n");\r\nreturn ERR_PTR(ret);\r\n}\r\nif (phba->state != BE_ADAPTER_UP) {\r\nret = -EBUSY;\r\nSE_DEBUG(DBG_LVL_1, "The Adapter state is Not UP\n");\r\nreturn ERR_PTR(ret);\r\n}\r\nep = iscsi_create_endpoint(sizeof(struct beiscsi_endpoint));\r\nif (!ep) {\r\nret = -ENOMEM;\r\nreturn ERR_PTR(ret);\r\n}\r\nbeiscsi_ep = ep->dd_data;\r\nbeiscsi_ep->phba = phba;\r\nbeiscsi_ep->openiscsi_ep = ep;\r\nret = beiscsi_open_conn(ep, NULL, dst_addr, non_blocking);\r\nif (ret) {\r\nSE_DEBUG(DBG_LVL_1, "Failed in beiscsi_open_conn\n");\r\ngoto free_ep;\r\n}\r\nreturn ep;\r\nfree_ep:\r\niscsi_destroy_endpoint(ep);\r\nreturn ERR_PTR(ret);\r\n}\r\nint beiscsi_ep_poll(struct iscsi_endpoint *ep, int timeout_ms)\r\n{\r\nstruct beiscsi_endpoint *beiscsi_ep = ep->dd_data;\r\nSE_DEBUG(DBG_LVL_8, "In beiscsi_ep_poll\n");\r\nif (beiscsi_ep->cid_vld == 1)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int beiscsi_close_conn(struct beiscsi_endpoint *beiscsi_ep, int flag)\r\n{\r\nint ret = 0;\r\nunsigned int tag;\r\nstruct beiscsi_hba *phba = beiscsi_ep->phba;\r\ntag = mgmt_upload_connection(phba, beiscsi_ep->ep_cid, flag);\r\nif (!tag) {\r\nSE_DEBUG(DBG_LVL_8, "upload failed for cid 0x%x\n",\r\nbeiscsi_ep->ep_cid);\r\nret = -EAGAIN;\r\n} else {\r\nwait_event_interruptible(phba->ctrl.mcc_wait[tag],\r\nphba->ctrl.mcc_numtag[tag]);\r\nfree_mcc_tag(&phba->ctrl, tag);\r\n}\r\nreturn ret;\r\n}\r\nstatic int beiscsi_unbind_conn_to_cid(struct beiscsi_hba *phba,\r\nunsigned int cid)\r\n{\r\nif (phba->conn_table[cid])\r\nphba->conn_table[cid] = NULL;\r\nelse {\r\nSE_DEBUG(DBG_LVL_8, "Connection table Not occupied.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid beiscsi_ep_disconnect(struct iscsi_endpoint *ep)\r\n{\r\nstruct beiscsi_conn *beiscsi_conn;\r\nstruct beiscsi_endpoint *beiscsi_ep;\r\nstruct beiscsi_hba *phba;\r\nunsigned int tag;\r\nunsigned short savecfg_flag = CMD_ISCSI_SESSION_SAVE_CFG_ON_FLASH;\r\nbeiscsi_ep = ep->dd_data;\r\nphba = beiscsi_ep->phba;\r\nSE_DEBUG(DBG_LVL_8, "In beiscsi_ep_disconnect for ep_cid = %d\n",\r\nbeiscsi_ep->ep_cid);\r\nif (!beiscsi_ep->conn) {\r\nSE_DEBUG(DBG_LVL_8, "In beiscsi_ep_disconnect, no "\r\n"beiscsi_ep\n");\r\nreturn;\r\n}\r\nbeiscsi_conn = beiscsi_ep->conn;\r\niscsi_suspend_queue(beiscsi_conn->conn);\r\nSE_DEBUG(DBG_LVL_8, "In beiscsi_ep_disconnect ep_cid = %d\n",\r\nbeiscsi_ep->ep_cid);\r\ntag = mgmt_invalidate_connection(phba, beiscsi_ep,\r\nbeiscsi_ep->ep_cid, 1,\r\nsavecfg_flag);\r\nif (!tag) {\r\nSE_DEBUG(DBG_LVL_1,\r\n"mgmt_invalidate_connection Failed for cid=%d\n",\r\nbeiscsi_ep->ep_cid);\r\n} else {\r\nwait_event_interruptible(phba->ctrl.mcc_wait[tag],\r\nphba->ctrl.mcc_numtag[tag]);\r\nfree_mcc_tag(&phba->ctrl, tag);\r\n}\r\nbeiscsi_close_conn(beiscsi_ep, CONNECTION_UPLOAD_GRACEFUL);\r\nbeiscsi_free_ep(beiscsi_ep);\r\nbeiscsi_unbind_conn_to_cid(phba, beiscsi_ep->ep_cid);\r\niscsi_destroy_endpoint(beiscsi_ep->openiscsi_ep);\r\n}\r\numode_t be2iscsi_attr_is_visible(int param_type, int param)\r\n{\r\nswitch (param_type) {\r\ncase ISCSI_HOST_PARAM:\r\nswitch (param) {\r\ncase ISCSI_HOST_PARAM_HWADDRESS:\r\ncase ISCSI_HOST_PARAM_IPADDRESS:\r\ncase ISCSI_HOST_PARAM_INITIATOR_NAME:\r\nreturn S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\ncase ISCSI_PARAM:\r\nswitch (param) {\r\ncase ISCSI_PARAM_MAX_RECV_DLENGTH:\r\ncase ISCSI_PARAM_MAX_XMIT_DLENGTH:\r\ncase ISCSI_PARAM_HDRDGST_EN:\r\ncase ISCSI_PARAM_DATADGST_EN:\r\ncase ISCSI_PARAM_CONN_ADDRESS:\r\ncase ISCSI_PARAM_CONN_PORT:\r\ncase ISCSI_PARAM_EXP_STATSN:\r\ncase ISCSI_PARAM_PERSISTENT_ADDRESS:\r\ncase ISCSI_PARAM_PERSISTENT_PORT:\r\ncase ISCSI_PARAM_PING_TMO:\r\ncase ISCSI_PARAM_RECV_TMO:\r\ncase ISCSI_PARAM_INITIAL_R2T_EN:\r\ncase ISCSI_PARAM_MAX_R2T:\r\ncase ISCSI_PARAM_IMM_DATA_EN:\r\ncase ISCSI_PARAM_FIRST_BURST:\r\ncase ISCSI_PARAM_MAX_BURST:\r\ncase ISCSI_PARAM_PDU_INORDER_EN:\r\ncase ISCSI_PARAM_DATASEQ_INORDER_EN:\r\ncase ISCSI_PARAM_ERL:\r\ncase ISCSI_PARAM_TARGET_NAME:\r\ncase ISCSI_PARAM_TPGT:\r\ncase ISCSI_PARAM_USERNAME:\r\ncase ISCSI_PARAM_PASSWORD:\r\ncase ISCSI_PARAM_USERNAME_IN:\r\ncase ISCSI_PARAM_PASSWORD_IN:\r\ncase ISCSI_PARAM_FAST_ABORT:\r\ncase ISCSI_PARAM_ABORT_TMO:\r\ncase ISCSI_PARAM_LU_RESET_TMO:\r\ncase ISCSI_PARAM_IFACE_NAME:\r\ncase ISCSI_PARAM_INITIATOR_NAME:\r\nreturn S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}
