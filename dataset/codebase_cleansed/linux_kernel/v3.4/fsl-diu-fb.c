static enum fsl_diu_monitor_port fsl_diu_name_to_port(const char *s)\r\n{\r\nenum fsl_diu_monitor_port port = FSL_DIU_PORT_DVI;\r\nunsigned long val;\r\nif (s) {\r\nif (!strict_strtoul(s, 10, &val) && (val <= 2))\r\nport = (enum fsl_diu_monitor_port) val;\r\nelse if (strncmp(s, "lvds", 4) == 0)\r\nport = FSL_DIU_PORT_LVDS;\r\nelse if (strncmp(s, "dlvds", 5) == 0)\r\nport = FSL_DIU_PORT_DLVDS;\r\n}\r\nreturn diu_ops.valid_monitor_port(port);\r\n}\r\nvoid wr_reg_wa(u32 *reg, u32 val)\r\n{\r\ndo {\r\nout_be32(reg, val);\r\n} while (in_be32(reg) != val);\r\n}\r\nstatic void fsl_diu_enable_panel(struct fb_info *info)\r\n{\r\nstruct mfb_info *pmfbi, *cmfbi, *mfbi = info->par;\r\nstruct diu_ad *ad = mfbi->ad;\r\nstruct fsl_diu_data *data = mfbi->parent;\r\nstruct diu __iomem *hw = data->diu_reg;\r\nswitch (mfbi->index) {\r\ncase PLANE0:\r\nif (hw->desc[0] != ad->paddr)\r\nwr_reg_wa(&hw->desc[0], ad->paddr);\r\nbreak;\r\ncase PLANE1_AOI0:\r\ncmfbi = &data->mfb[2];\r\nif (hw->desc[1] != ad->paddr) {\r\nif (cmfbi->count > 0)\r\nad->next_ad =\r\ncpu_to_le32(cmfbi->ad->paddr);\r\nelse\r\nad->next_ad = 0;\r\nwr_reg_wa(&hw->desc[1], ad->paddr);\r\n}\r\nbreak;\r\ncase PLANE2_AOI0:\r\ncmfbi = &data->mfb[4];\r\nif (hw->desc[2] != ad->paddr) {\r\nif (cmfbi->count > 0)\r\nad->next_ad =\r\ncpu_to_le32(cmfbi->ad->paddr);\r\nelse\r\nad->next_ad = 0;\r\nwr_reg_wa(&hw->desc[2], ad->paddr);\r\n}\r\nbreak;\r\ncase PLANE1_AOI1:\r\npmfbi = &data->mfb[1];\r\nad->next_ad = 0;\r\nif (hw->desc[1] == data->dummy_ad.paddr)\r\nwr_reg_wa(&hw->desc[1], ad->paddr);\r\nelse\r\npmfbi->ad->next_ad = cpu_to_le32(ad->paddr);\r\nbreak;\r\ncase PLANE2_AOI1:\r\npmfbi = &data->mfb[3];\r\nad->next_ad = 0;\r\nif (hw->desc[2] == data->dummy_ad.paddr)\r\nwr_reg_wa(&hw->desc[2], ad->paddr);\r\nelse\r\npmfbi->ad->next_ad = cpu_to_le32(ad->paddr);\r\nbreak;\r\n}\r\n}\r\nstatic void fsl_diu_disable_panel(struct fb_info *info)\r\n{\r\nstruct mfb_info *pmfbi, *cmfbi, *mfbi = info->par;\r\nstruct diu_ad *ad = mfbi->ad;\r\nstruct fsl_diu_data *data = mfbi->parent;\r\nstruct diu __iomem *hw = data->diu_reg;\r\nswitch (mfbi->index) {\r\ncase PLANE0:\r\nif (hw->desc[0] != data->dummy_ad.paddr)\r\nwr_reg_wa(&hw->desc[0], data->dummy_ad.paddr);\r\nbreak;\r\ncase PLANE1_AOI0:\r\ncmfbi = &data->mfb[2];\r\nif (cmfbi->count > 0)\r\nwr_reg_wa(&hw->desc[1], cmfbi->ad->paddr);\r\nelse\r\nwr_reg_wa(&hw->desc[1], data->dummy_ad.paddr);\r\nbreak;\r\ncase PLANE2_AOI0:\r\ncmfbi = &data->mfb[4];\r\nif (cmfbi->count > 0)\r\nwr_reg_wa(&hw->desc[2], cmfbi->ad->paddr);\r\nelse\r\nwr_reg_wa(&hw->desc[2], data->dummy_ad.paddr);\r\nbreak;\r\ncase PLANE1_AOI1:\r\npmfbi = &data->mfb[1];\r\nif (hw->desc[1] != ad->paddr) {\r\nif (pmfbi->count > 0)\r\npmfbi->ad->next_ad = 0;\r\n} else\r\nwr_reg_wa(&hw->desc[1], data->dummy_ad.paddr);\r\nbreak;\r\ncase PLANE2_AOI1:\r\npmfbi = &data->mfb[3];\r\nif (hw->desc[2] != ad->paddr) {\r\nif (pmfbi->count > 0)\r\npmfbi->ad->next_ad = 0;\r\n} else\r\nwr_reg_wa(&hw->desc[2], data->dummy_ad.paddr);\r\nbreak;\r\n}\r\n}\r\nstatic void enable_lcdc(struct fb_info *info)\r\n{\r\nstruct mfb_info *mfbi = info->par;\r\nstruct fsl_diu_data *data = mfbi->parent;\r\nstruct diu __iomem *hw = data->diu_reg;\r\nout_be32(&hw->diu_mode, MFB_MODE1);\r\n}\r\nstatic void disable_lcdc(struct fb_info *info)\r\n{\r\nstruct mfb_info *mfbi = info->par;\r\nstruct fsl_diu_data *data = mfbi->parent;\r\nstruct diu __iomem *hw = data->diu_reg;\r\nout_be32(&hw->diu_mode, 0);\r\n}\r\nstatic void adjust_aoi_size_position(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct mfb_info *lower_aoi_mfbi, *upper_aoi_mfbi, *mfbi = info->par;\r\nstruct fsl_diu_data *data = mfbi->parent;\r\nint available_height, upper_aoi_bottom;\r\nenum mfb_index index = mfbi->index;\r\nint lower_aoi_is_open, upper_aoi_is_open;\r\n__u32 base_plane_width, base_plane_height, upper_aoi_height;\r\nbase_plane_width = data->fsl_diu_info[0].var.xres;\r\nbase_plane_height = data->fsl_diu_info[0].var.yres;\r\nif (mfbi->x_aoi_d < 0)\r\nmfbi->x_aoi_d = 0;\r\nif (mfbi->y_aoi_d < 0)\r\nmfbi->y_aoi_d = 0;\r\nswitch (index) {\r\ncase PLANE0:\r\nif (mfbi->x_aoi_d != 0)\r\nmfbi->x_aoi_d = 0;\r\nif (mfbi->y_aoi_d != 0)\r\nmfbi->y_aoi_d = 0;\r\nbreak;\r\ncase PLANE1_AOI0:\r\ncase PLANE2_AOI0:\r\nlower_aoi_mfbi = data->fsl_diu_info[index+1].par;\r\nlower_aoi_is_open = lower_aoi_mfbi->count > 0 ? 1 : 0;\r\nif (var->xres > base_plane_width)\r\nvar->xres = base_plane_width;\r\nif ((mfbi->x_aoi_d + var->xres) > base_plane_width)\r\nmfbi->x_aoi_d = base_plane_width - var->xres;\r\nif (lower_aoi_is_open)\r\navailable_height = lower_aoi_mfbi->y_aoi_d;\r\nelse\r\navailable_height = base_plane_height;\r\nif (var->yres > available_height)\r\nvar->yres = available_height;\r\nif ((mfbi->y_aoi_d + var->yres) > available_height)\r\nmfbi->y_aoi_d = available_height - var->yres;\r\nbreak;\r\ncase PLANE1_AOI1:\r\ncase PLANE2_AOI1:\r\nupper_aoi_mfbi = data->fsl_diu_info[index-1].par;\r\nupper_aoi_height = data->fsl_diu_info[index-1].var.yres;\r\nupper_aoi_bottom = upper_aoi_mfbi->y_aoi_d + upper_aoi_height;\r\nupper_aoi_is_open = upper_aoi_mfbi->count > 0 ? 1 : 0;\r\nif (var->xres > base_plane_width)\r\nvar->xres = base_plane_width;\r\nif ((mfbi->x_aoi_d + var->xres) > base_plane_width)\r\nmfbi->x_aoi_d = base_plane_width - var->xres;\r\nif (mfbi->y_aoi_d < 0)\r\nmfbi->y_aoi_d = 0;\r\nif (upper_aoi_is_open) {\r\nif (mfbi->y_aoi_d < upper_aoi_bottom)\r\nmfbi->y_aoi_d = upper_aoi_bottom;\r\navailable_height = base_plane_height\r\n- upper_aoi_bottom;\r\n} else\r\navailable_height = base_plane_height;\r\nif (var->yres > available_height)\r\nvar->yres = available_height;\r\nif ((mfbi->y_aoi_d + var->yres) > base_plane_height)\r\nmfbi->y_aoi_d = base_plane_height - var->yres;\r\nbreak;\r\n}\r\n}\r\nstatic int fsl_diu_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nif (var->xres_virtual < var->xres)\r\nvar->xres_virtual = var->xres;\r\nif (var->yres_virtual < var->yres)\r\nvar->yres_virtual = var->yres;\r\nif (var->xoffset < 0)\r\nvar->xoffset = 0;\r\nif (var->yoffset < 0)\r\nvar->yoffset = 0;\r\nif (var->xoffset + info->var.xres > info->var.xres_virtual)\r\nvar->xoffset = info->var.xres_virtual - info->var.xres;\r\nif (var->yoffset + info->var.yres > info->var.yres_virtual)\r\nvar->yoffset = info->var.yres_virtual - info->var.yres;\r\nif ((var->bits_per_pixel != 32) && (var->bits_per_pixel != 24) &&\r\n(var->bits_per_pixel != 16))\r\nvar->bits_per_pixel = default_bpp;\r\nswitch (var->bits_per_pixel) {\r\ncase 16:\r\nvar->red.length = 5;\r\nvar->red.offset = 11;\r\nvar->red.msb_right = 0;\r\nvar->green.length = 6;\r\nvar->green.offset = 5;\r\nvar->green.msb_right = 0;\r\nvar->blue.length = 5;\r\nvar->blue.offset = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.length = 0;\r\nvar->transp.offset = 0;\r\nvar->transp.msb_right = 0;\r\nbreak;\r\ncase 24:\r\nvar->red.length = 8;\r\nvar->red.offset = 0;\r\nvar->red.msb_right = 0;\r\nvar->green.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.msb_right = 0;\r\nvar->blue.length = 8;\r\nvar->blue.offset = 16;\r\nvar->blue.msb_right = 0;\r\nvar->transp.length = 0;\r\nvar->transp.offset = 0;\r\nvar->transp.msb_right = 0;\r\nbreak;\r\ncase 32:\r\nvar->red.length = 8;\r\nvar->red.offset = 16;\r\nvar->red.msb_right = 0;\r\nvar->green.length = 8;\r\nvar->green.offset = 8;\r\nvar->green.msb_right = 0;\r\nvar->blue.length = 8;\r\nvar->blue.offset = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.length = 8;\r\nvar->transp.offset = 24;\r\nvar->transp.msb_right = 0;\r\nbreak;\r\n}\r\nvar->height = -1;\r\nvar->width = -1;\r\nvar->grayscale = 0;\r\nvar->sync |= var->nonstd;\r\nvar->nonstd |= var->sync;\r\nadjust_aoi_size_position(var, info);\r\nreturn 0;\r\n}\r\nstatic void set_fix(struct fb_info *info)\r\n{\r\nstruct fb_fix_screeninfo *fix = &info->fix;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct mfb_info *mfbi = info->par;\r\nstrncpy(fix->id, mfbi->id, sizeof(fix->id));\r\nfix->line_length = var->xres_virtual * var->bits_per_pixel / 8;\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nfix->accel = FB_ACCEL_NONE;\r\nfix->visual = FB_VISUAL_TRUECOLOR;\r\nfix->xpanstep = 1;\r\nfix->ypanstep = 1;\r\n}\r\nstatic void update_lcdc(struct fb_info *info)\r\n{\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct mfb_info *mfbi = info->par;\r\nstruct fsl_diu_data *data = mfbi->parent;\r\nstruct diu __iomem *hw;\r\nint i, j;\r\nu8 *gamma_table_base;\r\nu32 temp;\r\nhw = data->diu_reg;\r\ndiu_ops.set_monitor_port(data->monitor_port);\r\ngamma_table_base = data->gamma;\r\nfor (i = 0; i <= 2; i++)\r\nfor (j = 0; j <= 255; j++)\r\n*gamma_table_base++ = j;\r\nif (diu_ops.set_gamma_table)\r\ndiu_ops.set_gamma_table(data->monitor_port, data->gamma);\r\ndisable_lcdc(info);\r\nout_be32(&hw->gamma, DMA_ADDR(data, gamma));\r\nout_be32(&hw->cursor, DMA_ADDR(data, cursor));\r\nout_be32(&hw->bgnd, 0x007F7F7F);\r\nout_be32(&hw->bgnd_wb, 0);\r\nout_be32(&hw->disp_size, (var->yres << 16 | var->xres));\r\nout_be32(&hw->wb_size, 0);\r\nout_be32(&hw->wb_mem_addr, 0);\r\ntemp = var->left_margin << 22 |\r\nvar->hsync_len << 11 |\r\nvar->right_margin;\r\nout_be32(&hw->hsyn_para, temp);\r\ntemp = var->upper_margin << 22 |\r\nvar->vsync_len << 11 |\r\nvar->lower_margin;\r\nout_be32(&hw->vsyn_para, temp);\r\ndiu_ops.set_pixel_clock(var->pixclock);\r\nout_be32(&hw->syn_pol, 0);\r\nout_be32(&hw->thresholds, 0x00037800);\r\nout_be32(&hw->int_status, 0);\r\nout_be32(&hw->plut, 0x01F5F666);\r\nenable_lcdc(info);\r\n}\r\nstatic int map_video_memory(struct fb_info *info)\r\n{\r\nu32 smem_len = info->fix.line_length * info->var.yres_virtual;\r\nvoid *p;\r\np = alloc_pages_exact(smem_len, GFP_DMA | __GFP_ZERO);\r\nif (!p) {\r\ndev_err(info->dev, "unable to allocate fb memory\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_lock(&info->mm_lock);\r\ninfo->screen_base = p;\r\ninfo->fix.smem_start = virt_to_phys(info->screen_base);\r\ninfo->fix.smem_len = smem_len;\r\nmutex_unlock(&info->mm_lock);\r\ninfo->screen_size = info->fix.smem_len;\r\nreturn 0;\r\n}\r\nstatic void unmap_video_memory(struct fb_info *info)\r\n{\r\nvoid *p = info->screen_base;\r\nsize_t l = info->fix.smem_len;\r\nmutex_lock(&info->mm_lock);\r\ninfo->screen_base = NULL;\r\ninfo->fix.smem_start = 0;\r\ninfo->fix.smem_len = 0;\r\nmutex_unlock(&info->mm_lock);\r\nif (p)\r\nfree_pages_exact(p, l);\r\n}\r\nstatic int fsl_diu_set_aoi(struct fb_info *info)\r\n{\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct mfb_info *mfbi = info->par;\r\nstruct diu_ad *ad = mfbi->ad;\r\nad->offset_xyi = cpu_to_le32((var->yoffset << 16) | var->xoffset);\r\nad->offset_xyd = cpu_to_le32((mfbi->y_aoi_d << 16) | mfbi->x_aoi_d);\r\nreturn 0;\r\n}\r\nstatic u32 fsl_diu_get_pixel_format(unsigned int bits_per_pixel)\r\n{\r\n#define PF_BYTE_F 0x10000000\r\n#define PF_ALPHA_C_MASK 0x0E000000\r\n#define PF_ALPHA_C_SHIFT 25\r\n#define PF_BLUE_C_MASK 0x01800000\r\n#define PF_BLUE_C_SHIFT 23\r\n#define PF_GREEN_C_MASK 0x00600000\r\n#define PF_GREEN_C_SHIFT 21\r\n#define PF_RED_C_MASK 0x00180000\r\n#define PF_RED_C_SHIFT 19\r\n#define PF_PALETTE 0x00040000\r\n#define PF_PIXEL_S_MASK 0x00030000\r\n#define PF_PIXEL_S_SHIFT 16\r\n#define PF_COMP_3_MASK 0x0000F000\r\n#define PF_COMP_3_SHIFT 12\r\n#define PF_COMP_2_MASK 0x00000F00\r\n#define PF_COMP_2_SHIFT 8\r\n#define PF_COMP_1_MASK 0x000000F0\r\n#define PF_COMP_1_SHIFT 4\r\n#define PF_COMP_0_MASK 0x0000000F\r\n#define PF_COMP_0_SHIFT 0\r\n#define MAKE_PF(alpha, red, blue, green, size, c0, c1, c2, c3) \\r\ncpu_to_le32(PF_BYTE_F | (alpha << PF_ALPHA_C_SHIFT) | \\r\n(blue << PF_BLUE_C_SHIFT) | (green << PF_GREEN_C_SHIFT) | \\r\n(red << PF_RED_C_SHIFT) | (c3 << PF_COMP_3_SHIFT) | \\r\n(c2 << PF_COMP_2_SHIFT) | (c1 << PF_COMP_1_SHIFT) | \\r\n(c0 << PF_COMP_0_SHIFT) | (size << PF_PIXEL_S_SHIFT))\r\nswitch (bits_per_pixel) {\r\ncase 32:\r\nreturn MAKE_PF(3, 2, 0, 1, 3, 8, 8, 8, 8);\r\ncase 24:\r\nreturn MAKE_PF(4, 0, 1, 2, 2, 0, 8, 8, 8);\r\ncase 16:\r\nreturn MAKE_PF(4, 2, 1, 0, 1, 5, 6, 5, 0);\r\ndefault:\r\npr_err("fsl-diu: unsupported color depth %u\n", bits_per_pixel);\r\nreturn 0;\r\n}\r\n}\r\nstatic int fsl_diu_set_par(struct fb_info *info)\r\n{\r\nunsigned long len;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct mfb_info *mfbi = info->par;\r\nstruct fsl_diu_data *data = mfbi->parent;\r\nstruct diu_ad *ad = mfbi->ad;\r\nstruct diu __iomem *hw;\r\nhw = data->diu_reg;\r\nset_fix(info);\r\nmfbi->cursor_reset = 1;\r\nlen = info->var.yres_virtual * info->fix.line_length;\r\nif (len != info->fix.smem_len) {\r\nif (info->fix.smem_start)\r\nunmap_video_memory(info);\r\nif (map_video_memory(info)) {\r\ndev_err(info->dev, "unable to allocate fb memory 1\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (diu_ops.get_pixel_format)\r\nad->pix_fmt = diu_ops.get_pixel_format(data->monitor_port,\r\nvar->bits_per_pixel);\r\nelse\r\nad->pix_fmt = fsl_diu_get_pixel_format(var->bits_per_pixel);\r\nad->addr = cpu_to_le32(info->fix.smem_start);\r\nad->src_size_g_alpha = cpu_to_le32((var->yres_virtual << 12) |\r\nvar->xres_virtual) | mfbi->g_alpha;\r\nad->aoi_size = cpu_to_le32((var->yres << 16) | var->xres);\r\nad->offset_xyi = cpu_to_le32((var->yoffset << 16) | var->xoffset);\r\nad->offset_xyd = cpu_to_le32((mfbi->y_aoi_d << 16) | mfbi->x_aoi_d);\r\nad->ckmax_r = 0;\r\nad->ckmax_g = 0;\r\nad->ckmax_b = 0;\r\nad->ckmin_r = 255;\r\nad->ckmin_g = 255;\r\nad->ckmin_b = 255;\r\nif (mfbi->index == PLANE0)\r\nupdate_lcdc(info);\r\nreturn 0;\r\n}\r\nstatic inline __u32 CNVT_TOHW(__u32 val, __u32 width)\r\n{\r\nreturn ((val << width) + 0x7FFF - val) >> 16;\r\n}\r\nstatic int fsl_diu_setcolreg(unsigned int regno, unsigned int red,\r\nunsigned int green, unsigned int blue,\r\nunsigned int transp, struct fb_info *info)\r\n{\r\nint ret = 1;\r\nif (info->var.grayscale)\r\nred = green = blue = (19595 * red + 38470 * green +\r\n7471 * blue) >> 16;\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno < 16) {\r\nu32 *pal = info->pseudo_palette;\r\nu32 v;\r\nred = CNVT_TOHW(red, info->var.red.length);\r\ngreen = CNVT_TOHW(green, info->var.green.length);\r\nblue = CNVT_TOHW(blue, info->var.blue.length);\r\ntransp = CNVT_TOHW(transp, info->var.transp.length);\r\nv = (red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset) |\r\n(transp << info->var.transp.offset);\r\npal[regno] = v;\r\nret = 0;\r\n}\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int fsl_diu_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nif ((info->var.xoffset == var->xoffset) &&\r\n(info->var.yoffset == var->yoffset))\r\nreturn 0;\r\nif (var->xoffset < 0 || var->yoffset < 0\r\n|| var->xoffset + info->var.xres > info->var.xres_virtual\r\n|| var->yoffset + info->var.yres > info->var.yres_virtual)\r\nreturn -EINVAL;\r\ninfo->var.xoffset = var->xoffset;\r\ninfo->var.yoffset = var->yoffset;\r\nif (var->vmode & FB_VMODE_YWRAP)\r\ninfo->var.vmode |= FB_VMODE_YWRAP;\r\nelse\r\ninfo->var.vmode &= ~FB_VMODE_YWRAP;\r\nfsl_diu_set_aoi(info);\r\nreturn 0;\r\n}\r\nstatic int fsl_diu_ioctl(struct fb_info *info, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct mfb_info *mfbi = info->par;\r\nstruct diu_ad *ad = mfbi->ad;\r\nstruct mfb_chroma_key ck;\r\nunsigned char global_alpha;\r\nstruct aoi_display_offset aoi_d;\r\n__u32 pix_fmt;\r\nvoid __user *buf = (void __user *)arg;\r\nif (!arg)\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase MFB_SET_PIXFMT_OLD:\r\ndev_warn(info->dev,\r\n"MFB_SET_PIXFMT value of 0x%08x is deprecated.\n",\r\nMFB_SET_PIXFMT_OLD);\r\ncase MFB_SET_PIXFMT:\r\nif (copy_from_user(&pix_fmt, buf, sizeof(pix_fmt)))\r\nreturn -EFAULT;\r\nad->pix_fmt = pix_fmt;\r\nbreak;\r\ncase MFB_GET_PIXFMT_OLD:\r\ndev_warn(info->dev,\r\n"MFB_GET_PIXFMT value of 0x%08x is deprecated.\n",\r\nMFB_GET_PIXFMT_OLD);\r\ncase MFB_GET_PIXFMT:\r\npix_fmt = ad->pix_fmt;\r\nif (copy_to_user(buf, &pix_fmt, sizeof(pix_fmt)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase MFB_SET_AOID:\r\nif (copy_from_user(&aoi_d, buf, sizeof(aoi_d)))\r\nreturn -EFAULT;\r\nmfbi->x_aoi_d = aoi_d.x_aoi_d;\r\nmfbi->y_aoi_d = aoi_d.y_aoi_d;\r\nfsl_diu_check_var(&info->var, info);\r\nfsl_diu_set_aoi(info);\r\nbreak;\r\ncase MFB_GET_AOID:\r\naoi_d.x_aoi_d = mfbi->x_aoi_d;\r\naoi_d.y_aoi_d = mfbi->y_aoi_d;\r\nif (copy_to_user(buf, &aoi_d, sizeof(aoi_d)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase MFB_GET_ALPHA:\r\nglobal_alpha = mfbi->g_alpha;\r\nif (copy_to_user(buf, &global_alpha, sizeof(global_alpha)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase MFB_SET_ALPHA:\r\nif (copy_from_user(&global_alpha, buf, sizeof(global_alpha)))\r\nreturn -EFAULT;\r\nad->src_size_g_alpha = (ad->src_size_g_alpha & (~0xff)) |\r\n(global_alpha & 0xff);\r\nmfbi->g_alpha = global_alpha;\r\nbreak;\r\ncase MFB_SET_CHROMA_KEY:\r\nif (copy_from_user(&ck, buf, sizeof(ck)))\r\nreturn -EFAULT;\r\nif (ck.enable &&\r\n(ck.red_max < ck.red_min ||\r\nck.green_max < ck.green_min ||\r\nck.blue_max < ck.blue_min))\r\nreturn -EINVAL;\r\nif (!ck.enable) {\r\nad->ckmax_r = 0;\r\nad->ckmax_g = 0;\r\nad->ckmax_b = 0;\r\nad->ckmin_r = 255;\r\nad->ckmin_g = 255;\r\nad->ckmin_b = 255;\r\n} else {\r\nad->ckmax_r = ck.red_max;\r\nad->ckmax_g = ck.green_max;\r\nad->ckmax_b = ck.blue_max;\r\nad->ckmin_r = ck.red_min;\r\nad->ckmin_g = ck.green_min;\r\nad->ckmin_b = ck.blue_min;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(info->dev, "unknown ioctl command (0x%08X)\n", cmd);\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_diu_open(struct fb_info *info, int user)\r\n{\r\nstruct mfb_info *mfbi = info->par;\r\nint res = 0;\r\nif ((mfbi->index == PLANE0) && diu_ops.release_bootmem)\r\ndiu_ops.release_bootmem();\r\nspin_lock(&diu_lock);\r\nmfbi->count++;\r\nif (mfbi->count == 1) {\r\nfsl_diu_check_var(&info->var, info);\r\nres = fsl_diu_set_par(info);\r\nif (res < 0)\r\nmfbi->count--;\r\nelse\r\nfsl_diu_enable_panel(info);\r\n}\r\nspin_unlock(&diu_lock);\r\nreturn res;\r\n}\r\nstatic int fsl_diu_release(struct fb_info *info, int user)\r\n{\r\nstruct mfb_info *mfbi = info->par;\r\nint res = 0;\r\nspin_lock(&diu_lock);\r\nmfbi->count--;\r\nif (mfbi->count == 0)\r\nfsl_diu_disable_panel(info);\r\nspin_unlock(&diu_lock);\r\nreturn res;\r\n}\r\nstatic int __devinit install_fb(struct fb_info *info)\r\n{\r\nint rc;\r\nstruct mfb_info *mfbi = info->par;\r\nconst char *aoi_mode, *init_aoi_mode = "320x240";\r\nstruct fb_videomode *db = fsl_diu_mode_db;\r\nunsigned int dbsize = ARRAY_SIZE(fsl_diu_mode_db);\r\nint has_default_mode = 1;\r\ninfo->var.activate = FB_ACTIVATE_NOW;\r\ninfo->fbops = &fsl_diu_ops;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_VIRTFB | FBINFO_PARTIAL_PAN_OK |\r\nFBINFO_READS_FAST;\r\ninfo->pseudo_palette = mfbi->pseudo_palette;\r\nrc = fb_alloc_cmap(&info->cmap, 16, 0);\r\nif (rc)\r\nreturn rc;\r\nif (mfbi->index == PLANE0) {\r\nif (mfbi->edid_data) {\r\nfb_edid_to_monspecs(mfbi->edid_data, &info->monspecs);\r\nfb_videomode_to_modelist(info->monspecs.modedb,\r\ninfo->monspecs.modedb_len,\r\n&info->modelist);\r\ndb = info->monspecs.modedb;\r\ndbsize = info->monspecs.modedb_len;\r\n}\r\naoi_mode = fb_mode;\r\n} else {\r\naoi_mode = init_aoi_mode;\r\n}\r\nrc = fb_find_mode(&info->var, info, aoi_mode, db, dbsize, NULL,\r\ndefault_bpp);\r\nif (!rc) {\r\nif ((mfbi->index == PLANE0) && mfbi->edid_data)\r\nhas_default_mode = 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nif (!has_default_mode) {\r\nrc = fb_find_mode(&info->var, info, aoi_mode, fsl_diu_mode_db,\r\nARRAY_SIZE(fsl_diu_mode_db), NULL, default_bpp);\r\nif (rc)\r\nhas_default_mode = 1;\r\n}\r\nif (!has_default_mode && info->monspecs.modedb) {\r\nstruct fb_monspecs *specs = &info->monspecs;\r\nstruct fb_videomode *modedb = &specs->modedb[0];\r\nif (specs->misc & FB_MISC_1ST_DETAIL) {\r\nint i;\r\nfor (i = 0; i < specs->modedb_len; i++) {\r\nif (specs->modedb[i].flag & FB_MODE_IS_FIRST) {\r\nmodedb = &specs->modedb[i];\r\nbreak;\r\n}\r\n}\r\n}\r\ninfo->var.bits_per_pixel = default_bpp;\r\nfb_videomode_to_var(&info->var, modedb);\r\n}\r\nif (fsl_diu_check_var(&info->var, info)) {\r\ndev_err(info->dev, "fsl_diu_check_var failed\n");\r\nunmap_video_memory(info);\r\nfb_dealloc_cmap(&info->cmap);\r\nreturn -EINVAL;\r\n}\r\nif (register_framebuffer(info) < 0) {\r\ndev_err(info->dev, "register_framebuffer failed\n");\r\nunmap_video_memory(info);\r\nfb_dealloc_cmap(&info->cmap);\r\nreturn -EINVAL;\r\n}\r\nmfbi->registered = 1;\r\ndev_info(info->dev, "%s registered successfully\n", mfbi->id);\r\nreturn 0;\r\n}\r\nstatic void uninstall_fb(struct fb_info *info)\r\n{\r\nstruct mfb_info *mfbi = info->par;\r\nif (!mfbi->registered)\r\nreturn;\r\nif (mfbi->index == PLANE0)\r\nkfree(mfbi->edid_data);\r\nunregister_framebuffer(info);\r\nunmap_video_memory(info);\r\nif (&info->cmap)\r\nfb_dealloc_cmap(&info->cmap);\r\nmfbi->registered = 0;\r\n}\r\nstatic irqreturn_t fsl_diu_isr(int irq, void *dev_id)\r\n{\r\nstruct diu __iomem *hw = dev_id;\r\nunsigned int status = in_be32(&hw->int_status);\r\nif (status) {\r\nif (status & INT_UNDRUN) {\r\nout_be32(&hw->diu_mode, 0);\r\nudelay(1);\r\nout_be32(&hw->diu_mode, 1);\r\n}\r\n#if defined(CONFIG_NOT_COHERENT_CACHE)\r\nelse if (status & INT_VSYNC) {\r\nunsigned int i;\r\nfor (i = 0; i < coherence_data_size;\r\ni += d_cache_line_size)\r\n__asm__ __volatile__ (\r\n"dcbz 0, %[input]"\r\n::[input]"r"(&coherence_data[i]));\r\n}\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int request_irq_local(struct fsl_diu_data *data)\r\n{\r\nstruct diu __iomem *hw = data->diu_reg;\r\nu32 ints;\r\nint ret;\r\nin_be32(&hw->int_status);\r\nret = request_irq(data->irq, fsl_diu_isr, 0, "fsl-diu-fb", hw);\r\nif (!ret) {\r\nints = INT_PARERR | INT_LS_BF_VS;\r\n#if !defined(CONFIG_NOT_COHERENT_CACHE)\r\nints |= INT_VSYNC;\r\n#endif\r\nin_be32(&hw->int_status);\r\nout_be32(&hw->int_mask, ints);\r\n}\r\nreturn ret;\r\n}\r\nstatic void free_irq_local(struct fsl_diu_data *data)\r\n{\r\nstruct diu __iomem *hw = data->diu_reg;\r\nout_be32(&hw->int_mask, 0x1f);\r\nfree_irq(data->irq, NULL);\r\n}\r\nstatic int fsl_diu_suspend(struct platform_device *ofdev, pm_message_t state)\r\n{\r\nstruct fsl_diu_data *data;\r\ndata = dev_get_drvdata(&ofdev->dev);\r\ndisable_lcdc(data->fsl_diu_info);\r\nreturn 0;\r\n}\r\nstatic int fsl_diu_resume(struct platform_device *ofdev)\r\n{\r\nstruct fsl_diu_data *data;\r\ndata = dev_get_drvdata(&ofdev->dev);\r\nenable_lcdc(data->fsl_diu_info);\r\nreturn 0;\r\n}\r\nstatic ssize_t store_monitor(struct device *device,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nenum fsl_diu_monitor_port old_monitor_port;\r\nstruct fsl_diu_data *data =\r\ncontainer_of(attr, struct fsl_diu_data, dev_attr);\r\nold_monitor_port = data->monitor_port;\r\ndata->monitor_port = fsl_diu_name_to_port(buf);\r\nif (old_monitor_port != data->monitor_port) {\r\nunsigned int i;\r\nfor (i=0; i < NUM_AOIS; i++)\r\nfsl_diu_set_par(&data->fsl_diu_info[i]);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t show_monitor(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fsl_diu_data *data =\r\ncontainer_of(attr, struct fsl_diu_data, dev_attr);\r\nswitch (data->monitor_port) {\r\ncase FSL_DIU_PORT_DVI:\r\nreturn sprintf(buf, "DVI\n");\r\ncase FSL_DIU_PORT_LVDS:\r\nreturn sprintf(buf, "Single-link LVDS\n");\r\ncase FSL_DIU_PORT_DLVDS:\r\nreturn sprintf(buf, "Dual-link LVDS\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit fsl_diu_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct mfb_info *mfbi;\r\nstruct fsl_diu_data *data;\r\nint diu_mode;\r\ndma_addr_t dma_addr;\r\nunsigned int i;\r\nint ret;\r\ndata = dma_alloc_coherent(&pdev->dev, sizeof(struct fsl_diu_data),\r\n&dma_addr, GFP_DMA | __GFP_ZERO);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->dma_addr = dma_addr;\r\nif ((unsigned long)data & 31) {\r\ndev_err(&pdev->dev, "misaligned allocation");\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nspin_lock_init(&data->reg_lock);\r\nfor (i = 0; i < NUM_AOIS; i++) {\r\nstruct fb_info *info = &data->fsl_diu_info[i];\r\ninfo->device = &pdev->dev;\r\ninfo->par = &data->mfb[i];\r\ndata->ad[i].paddr = DMA_ADDR(data, ad[i]);\r\ninfo->fix.smem_start = 0;\r\nmfbi = info->par;\r\nmemcpy(mfbi, &mfb_template[i], sizeof(struct mfb_info));\r\nmfbi->parent = data;\r\nmfbi->ad = &data->ad[i];\r\nif (mfbi->index == PLANE0) {\r\nconst u8 *prop;\r\nint len;\r\nprop = of_get_property(np, "edid", &len);\r\nif (prop && len == EDID_LENGTH)\r\nmfbi->edid_data = kmemdup(prop, EDID_LENGTH,\r\nGFP_KERNEL);\r\n}\r\n}\r\ndata->diu_reg = of_iomap(np, 0);\r\nif (!data->diu_reg) {\r\ndev_err(&pdev->dev, "cannot map DIU registers\n");\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\ndiu_mode = in_be32(&data->diu_reg->diu_mode);\r\nif (diu_mode == MFB_MODE0)\r\nout_be32(&data->diu_reg->diu_mode, 0);\r\ndata->irq = irq_of_parse_and_map(np, 0);\r\nif (!data->irq) {\r\ndev_err(&pdev->dev, "could not get DIU IRQ\n");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\ndata->monitor_port = monitor_port;\r\ndata->dummy_ad.addr = cpu_to_le32(DMA_ADDR(data, dummy_aoi));\r\ndata->dummy_ad.pix_fmt = 0x88882317;\r\ndata->dummy_ad.src_size_g_alpha = cpu_to_le32((4 << 12) | 4);\r\ndata->dummy_ad.aoi_size = cpu_to_le32((4 << 16) | 2);\r\ndata->dummy_ad.offset_xyi = 0;\r\ndata->dummy_ad.offset_xyd = 0;\r\ndata->dummy_ad.next_ad = 0;\r\ndata->dummy_ad.paddr = DMA_ADDR(data, dummy_ad);\r\nif (diu_mode == MFB_MODE0)\r\nout_be32(&data->diu_reg->desc[0], data->dummy_ad.paddr);\r\nout_be32(&data->diu_reg->desc[1], data->dummy_ad.paddr);\r\nout_be32(&data->diu_reg->desc[2], data->dummy_ad.paddr);\r\nfor (i = 0; i < NUM_AOIS; i++) {\r\nret = install_fb(&data->fsl_diu_info[i]);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not register fb %d\n", i);\r\ngoto error;\r\n}\r\n}\r\nif (request_irq_local(data)) {\r\ndev_err(&pdev->dev, "could not claim irq\n");\r\ngoto error;\r\n}\r\nsysfs_attr_init(&data->dev_attr.attr);\r\ndata->dev_attr.attr.name = "monitor";\r\ndata->dev_attr.attr.mode = S_IRUGO|S_IWUSR;\r\ndata->dev_attr.show = show_monitor;\r\ndata->dev_attr.store = store_monitor;\r\nret = device_create_file(&pdev->dev, &data->dev_attr);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not create sysfs file %s\n",\r\ndata->dev_attr.attr.name);\r\n}\r\ndev_set_drvdata(&pdev->dev, data);\r\nreturn 0;\r\nerror:\r\nfor (i = 0; i < NUM_AOIS; i++)\r\nuninstall_fb(&data->fsl_diu_info[i]);\r\niounmap(data->diu_reg);\r\ndma_free_coherent(&pdev->dev, sizeof(struct fsl_diu_data), data,\r\ndata->dma_addr);\r\nreturn ret;\r\n}\r\nstatic int fsl_diu_remove(struct platform_device *pdev)\r\n{\r\nstruct fsl_diu_data *data;\r\nint i;\r\ndata = dev_get_drvdata(&pdev->dev);\r\ndisable_lcdc(&data->fsl_diu_info[0]);\r\nfree_irq_local(data);\r\nfor (i = 0; i < NUM_AOIS; i++)\r\nuninstall_fb(&data->fsl_diu_info[i]);\r\niounmap(data->diu_reg);\r\ndma_free_coherent(&pdev->dev, sizeof(struct fsl_diu_data), data,\r\ndata->dma_addr);\r\nreturn 0;\r\n}\r\nstatic int __init fsl_diu_setup(char *options)\r\n{\r\nchar *opt;\r\nunsigned long val;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((opt = strsep(&options, ",")) != NULL) {\r\nif (!*opt)\r\ncontinue;\r\nif (!strncmp(opt, "monitor=", 8)) {\r\nmonitor_port = fsl_diu_name_to_port(opt + 8);\r\n} else if (!strncmp(opt, "bpp=", 4)) {\r\nif (!strict_strtoul(opt + 4, 10, &val))\r\ndefault_bpp = val;\r\n} else\r\nfb_mode = opt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init fsl_diu_init(void)\r\n{\r\n#ifdef CONFIG_NOT_COHERENT_CACHE\r\nstruct device_node *np;\r\nconst u32 *prop;\r\n#endif\r\nint ret;\r\n#ifndef MODULE\r\nchar *option;\r\nif (fb_get_options("fslfb", &option))\r\nreturn -ENODEV;\r\nfsl_diu_setup(option);\r\n#else\r\nmonitor_port = fsl_diu_name_to_port(monitor_string);\r\n#endif\r\npr_info("Freescale Display Interface Unit (DIU) framebuffer driver\n");\r\n#ifdef CONFIG_NOT_COHERENT_CACHE\r\nnp = of_find_node_by_type(NULL, "cpu");\r\nif (!np) {\r\npr_err("fsl-diu-fb: can't find 'cpu' device node\n");\r\nreturn -ENODEV;\r\n}\r\nprop = of_get_property(np, "d-cache-size", NULL);\r\nif (prop == NULL) {\r\npr_err("fsl-diu-fb: missing 'd-cache-size' property' "\r\n"in 'cpu' node\n");\r\nof_node_put(np);\r\nreturn -ENODEV;\r\n}\r\ncoherence_data_size = be32_to_cpup(prop) * 13;\r\ncoherence_data_size /= 8;\r\nprop = of_get_property(np, "d-cache-line-size", NULL);\r\nif (prop == NULL) {\r\npr_err("fsl-diu-fb: missing 'd-cache-line-size' property' "\r\n"in 'cpu' node\n");\r\nof_node_put(np);\r\nreturn -ENODEV;\r\n}\r\nd_cache_line_size = be32_to_cpup(prop);\r\nof_node_put(np);\r\ncoherence_data = vmalloc(coherence_data_size);\r\nif (!coherence_data)\r\nreturn -ENOMEM;\r\n#endif\r\nret = platform_driver_register(&fsl_diu_driver);\r\nif (ret) {\r\npr_err("fsl-diu-fb: failed to register platform driver\n");\r\n#if defined(CONFIG_NOT_COHERENT_CACHE)\r\nvfree(coherence_data);\r\n#endif\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit fsl_diu_exit(void)\r\n{\r\nplatform_driver_unregister(&fsl_diu_driver);\r\n#if defined(CONFIG_NOT_COHERENT_CACHE)\r\nvfree(coherence_data);\r\n#endif\r\n}
