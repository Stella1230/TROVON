static inline void nlm_debug_print_fh(char *msg, struct nfs_fh *f)\r\n{\r\nu32 *fhp = (u32*)f->data;\r\ndprintk("lockd: %s (%08x %08x %08x %08x %08x %08x %08x %08x)\n",\r\nmsg, fhp[0], fhp[1], fhp[2], fhp[3],\r\nfhp[4], fhp[5], fhp[6], fhp[7]);\r\n}\r\nstatic inline void nlm_debug_print_file(char *msg, struct nlm_file *file)\r\n{\r\nstruct inode *inode = file->f_file->f_path.dentry->d_inode;\r\ndprintk("lockd: %s %s/%ld\n",\r\nmsg, inode->i_sb->s_id, inode->i_ino);\r\n}\r\nstatic inline void nlm_debug_print_fh(char *msg, struct nfs_fh *f)\r\n{\r\nreturn;\r\n}\r\nstatic inline void nlm_debug_print_file(char *msg, struct nlm_file *file)\r\n{\r\nreturn;\r\n}\r\nstatic inline unsigned int file_hash(struct nfs_fh *f)\r\n{\r\nunsigned int tmp=0;\r\nint i;\r\nfor (i=0; i<NFS2_FHSIZE;i++)\r\ntmp += f->data[i];\r\nreturn tmp & (FILE_NRHASH - 1);\r\n}\r\n__be32\r\nnlm_lookup_file(struct svc_rqst *rqstp, struct nlm_file **result,\r\nstruct nfs_fh *f)\r\n{\r\nstruct hlist_node *pos;\r\nstruct nlm_file *file;\r\nunsigned int hash;\r\n__be32 nfserr;\r\nnlm_debug_print_fh("nlm_lookup_file", f);\r\nhash = file_hash(f);\r\nmutex_lock(&nlm_file_mutex);\r\nhlist_for_each_entry(file, pos, &nlm_files[hash], f_list)\r\nif (!nfs_compare_fh(&file->f_handle, f))\r\ngoto found;\r\nnlm_debug_print_fh("creating file for", f);\r\nnfserr = nlm_lck_denied_nolocks;\r\nfile = kzalloc(sizeof(*file), GFP_KERNEL);\r\nif (!file)\r\ngoto out_unlock;\r\nmemcpy(&file->f_handle, f, sizeof(struct nfs_fh));\r\nmutex_init(&file->f_mutex);\r\nINIT_HLIST_NODE(&file->f_list);\r\nINIT_LIST_HEAD(&file->f_blocks);\r\nif ((nfserr = nlmsvc_ops->fopen(rqstp, f, &file->f_file)) != 0) {\r\ndprintk("lockd: open failed (error %d)\n", nfserr);\r\ngoto out_free;\r\n}\r\nhlist_add_head(&file->f_list, &nlm_files[hash]);\r\nfound:\r\ndprintk("lockd: found file %p (count %d)\n", file, file->f_count);\r\n*result = file;\r\nfile->f_count++;\r\nnfserr = 0;\r\nout_unlock:\r\nmutex_unlock(&nlm_file_mutex);\r\nreturn nfserr;\r\nout_free:\r\nkfree(file);\r\ngoto out_unlock;\r\n}\r\nstatic inline void\r\nnlm_delete_file(struct nlm_file *file)\r\n{\r\nnlm_debug_print_file("closing file", file);\r\nif (!hlist_unhashed(&file->f_list)) {\r\nhlist_del(&file->f_list);\r\nnlmsvc_ops->fclose(file->f_file);\r\nkfree(file);\r\n} else {\r\nprintk(KERN_WARNING "lockd: attempt to release unknown file!\n");\r\n}\r\n}\r\nstatic int\r\nnlm_traverse_locks(struct nlm_host *host, struct nlm_file *file,\r\nnlm_host_match_fn_t match)\r\n{\r\nstruct inode *inode = nlmsvc_file_inode(file);\r\nstruct file_lock *fl;\r\nstruct nlm_host *lockhost;\r\nagain:\r\nfile->f_locks = 0;\r\nlock_flocks();\r\nfor (fl = inode->i_flock; fl; fl = fl->fl_next) {\r\nif (fl->fl_lmops != &nlmsvc_lock_operations)\r\ncontinue;\r\nfile->f_locks++;\r\nlockhost = (struct nlm_host *) fl->fl_owner;\r\nif (match(lockhost, host)) {\r\nstruct file_lock lock = *fl;\r\nunlock_flocks();\r\nlock.fl_type = F_UNLCK;\r\nlock.fl_start = 0;\r\nlock.fl_end = OFFSET_MAX;\r\nif (vfs_lock_file(file->f_file, F_SETLK, &lock, NULL) < 0) {\r\nprintk("lockd: unlock failure in %s:%d\n",\r\n__FILE__, __LINE__);\r\nreturn 1;\r\n}\r\ngoto again;\r\n}\r\n}\r\nunlock_flocks();\r\nreturn 0;\r\n}\r\nstatic int\r\nnlmsvc_always_match(void *dummy1, struct nlm_host *dummy2)\r\n{\r\nreturn 1;\r\n}\r\nstatic inline int\r\nnlm_inspect_file(struct nlm_host *host, struct nlm_file *file, nlm_host_match_fn_t match)\r\n{\r\nnlmsvc_traverse_blocks(host, file, match);\r\nnlmsvc_traverse_shares(host, file, match);\r\nreturn nlm_traverse_locks(host, file, match);\r\n}\r\nstatic inline int\r\nnlm_file_inuse(struct nlm_file *file)\r\n{\r\nstruct inode *inode = nlmsvc_file_inode(file);\r\nstruct file_lock *fl;\r\nif (file->f_count || !list_empty(&file->f_blocks) || file->f_shares)\r\nreturn 1;\r\nlock_flocks();\r\nfor (fl = inode->i_flock; fl; fl = fl->fl_next) {\r\nif (fl->fl_lmops == &nlmsvc_lock_operations) {\r\nunlock_flocks();\r\nreturn 1;\r\n}\r\n}\r\nunlock_flocks();\r\nfile->f_locks = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nnlm_traverse_files(void *data, nlm_host_match_fn_t match,\r\nint (*is_failover_file)(void *data, struct nlm_file *file))\r\n{\r\nstruct hlist_node *pos, *next;\r\nstruct nlm_file *file;\r\nint i, ret = 0;\r\nmutex_lock(&nlm_file_mutex);\r\nfor (i = 0; i < FILE_NRHASH; i++) {\r\nhlist_for_each_entry_safe(file, pos, next, &nlm_files[i], f_list) {\r\nif (is_failover_file && !is_failover_file(data, file))\r\ncontinue;\r\nfile->f_count++;\r\nmutex_unlock(&nlm_file_mutex);\r\nif (nlm_inspect_file(data, file, match))\r\nret = 1;\r\nmutex_lock(&nlm_file_mutex);\r\nfile->f_count--;\r\nif (list_empty(&file->f_blocks) && !file->f_locks\r\n&& !file->f_shares && !file->f_count) {\r\nhlist_del(&file->f_list);\r\nnlmsvc_ops->fclose(file->f_file);\r\nkfree(file);\r\n}\r\n}\r\n}\r\nmutex_unlock(&nlm_file_mutex);\r\nreturn ret;\r\n}\r\nvoid\r\nnlm_release_file(struct nlm_file *file)\r\n{\r\ndprintk("lockd: nlm_release_file(%p, ct = %d)\n",\r\nfile, file->f_count);\r\nmutex_lock(&nlm_file_mutex);\r\nif (--file->f_count == 0 && !nlm_file_inuse(file))\r\nnlm_delete_file(file);\r\nmutex_unlock(&nlm_file_mutex);\r\n}\r\nstatic int\r\nnlmsvc_mark_host(void *data, struct nlm_host *dummy)\r\n{\r\nstruct nlm_host *host = data;\r\nhost->h_inuse = 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nnlmsvc_same_host(void *data, struct nlm_host *other)\r\n{\r\nstruct nlm_host *host = data;\r\nreturn host == other;\r\n}\r\nstatic int\r\nnlmsvc_is_client(void *data, struct nlm_host *dummy)\r\n{\r\nstruct nlm_host *host = data;\r\nif (host->h_server) {\r\nif (host->h_nsmhandle)\r\nhost->h_nsmhandle->sm_sticky = 1;\r\nreturn 1;\r\n} else\r\nreturn 0;\r\n}\r\nvoid\r\nnlmsvc_mark_resources(void)\r\n{\r\ndprintk("lockd: nlmsvc_mark_resources\n");\r\nnlm_traverse_files(NULL, nlmsvc_mark_host, NULL);\r\n}\r\nvoid\r\nnlmsvc_free_host_resources(struct nlm_host *host)\r\n{\r\ndprintk("lockd: nlmsvc_free_host_resources\n");\r\nif (nlm_traverse_files(host, nlmsvc_same_host, NULL)) {\r\nprintk(KERN_WARNING\r\n"lockd: couldn't remove all locks held by %s\n",\r\nhost->h_name);\r\nBUG();\r\n}\r\n}\r\nvoid\r\nnlmsvc_invalidate_all(void)\r\n{\r\nnlm_traverse_files(NULL, nlmsvc_is_client, NULL);\r\n}\r\nstatic int\r\nnlmsvc_match_sb(void *datap, struct nlm_file *file)\r\n{\r\nstruct super_block *sb = datap;\r\nreturn sb == file->f_file->f_path.dentry->d_sb;\r\n}\r\nint\r\nnlmsvc_unlock_all_by_sb(struct super_block *sb)\r\n{\r\nint ret;\r\nret = nlm_traverse_files(sb, nlmsvc_always_match, nlmsvc_match_sb);\r\nreturn ret ? -EIO : 0;\r\n}\r\nstatic int\r\nnlmsvc_match_ip(void *datap, struct nlm_host *host)\r\n{\r\nreturn rpc_cmp_addr(nlm_srcaddr(host), datap);\r\n}\r\nint\r\nnlmsvc_unlock_all_by_ip(struct sockaddr *server_addr)\r\n{\r\nint ret;\r\nret = nlm_traverse_files(server_addr, nlmsvc_match_ip, NULL);\r\nreturn ret ? -EIO : 0;\r\n}
