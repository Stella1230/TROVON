static int\r\nbefs_bt_read_super(struct super_block *sb, befs_data_stream * ds,\r\nbefs_btree_super * sup)\r\n{\r\nstruct buffer_head *bh = NULL;\r\nbefs_disk_btree_super *od_sup = NULL;\r\nbefs_debug(sb, "---> befs_btree_read_super()");\r\nbh = befs_read_datastream(sb, ds, 0, NULL);\r\nif (!bh) {\r\nbefs_error(sb, "Couldn't read index header.");\r\ngoto error;\r\n}\r\nod_sup = (befs_disk_btree_super *) bh->b_data;\r\nbefs_dump_index_entry(sb, od_sup);\r\nsup->magic = fs32_to_cpu(sb, od_sup->magic);\r\nsup->node_size = fs32_to_cpu(sb, od_sup->node_size);\r\nsup->max_depth = fs32_to_cpu(sb, od_sup->max_depth);\r\nsup->data_type = fs32_to_cpu(sb, od_sup->data_type);\r\nsup->root_node_ptr = fs64_to_cpu(sb, od_sup->root_node_ptr);\r\nsup->free_node_ptr = fs64_to_cpu(sb, od_sup->free_node_ptr);\r\nsup->max_size = fs64_to_cpu(sb, od_sup->max_size);\r\nbrelse(bh);\r\nif (sup->magic != BEFS_BTREE_MAGIC) {\r\nbefs_error(sb, "Index header has bad magic.");\r\ngoto error;\r\n}\r\nbefs_debug(sb, "<--- befs_btree_read_super()");\r\nreturn BEFS_OK;\r\nerror:\r\nbefs_debug(sb, "<--- befs_btree_read_super() ERROR");\r\nreturn BEFS_ERR;\r\n}\r\nstatic int\r\nbefs_bt_read_node(struct super_block *sb, befs_data_stream * ds,\r\nbefs_btree_node * node, befs_off_t node_off)\r\n{\r\nuint off = 0;\r\nbefs_debug(sb, "---> befs_bt_read_node()");\r\nif (node->bh)\r\nbrelse(node->bh);\r\nnode->bh = befs_read_datastream(sb, ds, node_off, &off);\r\nif (!node->bh) {\r\nbefs_error(sb, "befs_bt_read_node() failed to read "\r\n"node at %Lu", node_off);\r\nbefs_debug(sb, "<--- befs_bt_read_node() ERROR");\r\nreturn BEFS_ERR;\r\n}\r\nnode->od_node =\r\n(befs_btree_nodehead *) ((void *) node->bh->b_data + off);\r\nbefs_dump_index_node(sb, node->od_node);\r\nnode->head.left = fs64_to_cpu(sb, node->od_node->left);\r\nnode->head.right = fs64_to_cpu(sb, node->od_node->right);\r\nnode->head.overflow = fs64_to_cpu(sb, node->od_node->overflow);\r\nnode->head.all_key_count =\r\nfs16_to_cpu(sb, node->od_node->all_key_count);\r\nnode->head.all_key_length =\r\nfs16_to_cpu(sb, node->od_node->all_key_length);\r\nbefs_debug(sb, "<--- befs_btree_read_node()");\r\nreturn BEFS_OK;\r\n}\r\nint\r\nbefs_btree_find(struct super_block *sb, befs_data_stream * ds,\r\nconst char *key, befs_off_t * value)\r\n{\r\nbefs_btree_node *this_node = NULL;\r\nbefs_btree_super bt_super;\r\nbefs_off_t node_off;\r\nint res;\r\nbefs_debug(sb, "---> befs_btree_find() Key: %s", key);\r\nif (befs_bt_read_super(sb, ds, &bt_super) != BEFS_OK) {\r\nbefs_error(sb,\r\n"befs_btree_find() failed to read index superblock");\r\ngoto error;\r\n}\r\nthis_node = kmalloc(sizeof (befs_btree_node),\r\nGFP_NOFS);\r\nif (!this_node) {\r\nbefs_error(sb, "befs_btree_find() failed to allocate %u "\r\n"bytes of memory", sizeof (befs_btree_node));\r\ngoto error;\r\n}\r\nthis_node->bh = NULL;\r\nnode_off = bt_super.root_node_ptr;\r\nif (befs_bt_read_node(sb, ds, this_node, node_off) != BEFS_OK) {\r\nbefs_error(sb, "befs_btree_find() failed to read "\r\n"node at %Lu", node_off);\r\ngoto error_alloc;\r\n}\r\nwhile (!befs_leafnode(this_node)) {\r\nres = befs_find_key(sb, this_node, key, &node_off);\r\nif (res == BEFS_BT_NOT_FOUND)\r\nnode_off = this_node->head.overflow;\r\nif (befs_bt_read_node(sb, ds, this_node, node_off) != BEFS_OK) {\r\nbefs_error(sb, "befs_btree_find() failed to read "\r\n"node at %Lu", node_off);\r\ngoto error_alloc;\r\n}\r\n}\r\nres = befs_find_key(sb, this_node, key, value);\r\nbrelse(this_node->bh);\r\nkfree(this_node);\r\nif (res != BEFS_BT_MATCH) {\r\nbefs_debug(sb, "<--- befs_btree_find() Key %s not found", key);\r\n*value = 0;\r\nreturn BEFS_BT_NOT_FOUND;\r\n}\r\nbefs_debug(sb, "<--- befs_btree_find() Found key %s, value %Lu",\r\nkey, *value);\r\nreturn BEFS_OK;\r\nerror_alloc:\r\nkfree(this_node);\r\nerror:\r\n*value = 0;\r\nbefs_debug(sb, "<--- befs_btree_find() ERROR");\r\nreturn BEFS_ERR;\r\n}\r\nstatic int\r\nbefs_find_key(struct super_block *sb, befs_btree_node * node,\r\nconst char *findkey, befs_off_t * value)\r\n{\r\nint first, last, mid;\r\nint eq;\r\nu16 keylen;\r\nint findkey_len;\r\nchar *thiskey;\r\nfs64 *valarray;\r\nbefs_debug(sb, "---> befs_find_key() %s", findkey);\r\n*value = 0;\r\nfindkey_len = strlen(findkey);\r\nlast = node->head.all_key_count - 1;\r\nthiskey = befs_bt_get_key(sb, node, last, &keylen);\r\neq = befs_compare_strings(thiskey, keylen, findkey, findkey_len);\r\nif (eq < 0) {\r\nbefs_debug(sb, "<--- befs_find_key() %s not found", findkey);\r\nreturn BEFS_BT_NOT_FOUND;\r\n}\r\nvalarray = befs_bt_valarray(node);\r\nfirst = 0;\r\nmid = 0;\r\nwhile (last >= first) {\r\nmid = (last + first) / 2;\r\nbefs_debug(sb, "first: %d, last: %d, mid: %d", first, last,\r\nmid);\r\nthiskey = befs_bt_get_key(sb, node, mid, &keylen);\r\neq = befs_compare_strings(thiskey, keylen, findkey,\r\nfindkey_len);\r\nif (eq == 0) {\r\nbefs_debug(sb, "<--- befs_find_key() found %s at %d",\r\nthiskey, mid);\r\n*value = fs64_to_cpu(sb, valarray[mid]);\r\nreturn BEFS_BT_MATCH;\r\n}\r\nif (eq > 0)\r\nlast = mid - 1;\r\nelse\r\nfirst = mid + 1;\r\n}\r\nif (eq < 0)\r\n*value = fs64_to_cpu(sb, valarray[mid + 1]);\r\nelse\r\n*value = fs64_to_cpu(sb, valarray[mid]);\r\nbefs_debug(sb, "<--- befs_find_key() found %s at %d", thiskey, mid);\r\nreturn BEFS_BT_PARMATCH;\r\n}\r\nint\r\nbefs_btree_read(struct super_block *sb, befs_data_stream * ds,\r\nloff_t key_no, size_t bufsize, char *keybuf, size_t * keysize,\r\nbefs_off_t * value)\r\n{\r\nbefs_btree_node *this_node;\r\nbefs_btree_super bt_super;\r\nbefs_off_t node_off = 0;\r\nint cur_key;\r\nfs64 *valarray;\r\nchar *keystart;\r\nu16 keylen;\r\nint res;\r\nuint key_sum = 0;\r\nbefs_debug(sb, "---> befs_btree_read()");\r\nif (befs_bt_read_super(sb, ds, &bt_super) != BEFS_OK) {\r\nbefs_error(sb,\r\n"befs_btree_read() failed to read index superblock");\r\ngoto error;\r\n}\r\nif ((this_node = (befs_btree_node *)\r\nkmalloc(sizeof (befs_btree_node), GFP_NOFS)) == NULL) {\r\nbefs_error(sb, "befs_btree_read() failed to allocate %u "\r\n"bytes of memory", sizeof (befs_btree_node));\r\ngoto error;\r\n}\r\nnode_off = bt_super.root_node_ptr;\r\nthis_node->bh = NULL;\r\nres = befs_btree_seekleaf(sb, ds, &bt_super, this_node, &node_off);\r\nif (res == BEFS_BT_EMPTY) {\r\nbrelse(this_node->bh);\r\nkfree(this_node);\r\n*value = 0;\r\n*keysize = 0;\r\nbefs_debug(sb, "<--- befs_btree_read() Tree is EMPTY");\r\nreturn BEFS_BT_EMPTY;\r\n} else if (res == BEFS_ERR) {\r\ngoto error_alloc;\r\n}\r\nwhile (key_sum + this_node->head.all_key_count <= key_no) {\r\nif (this_node->head.right == befs_bt_inval) {\r\n*keysize = 0;\r\n*value = 0;\r\nbefs_debug(sb,\r\n"<--- befs_btree_read() END of keys at %Lu",\r\nkey_sum + this_node->head.all_key_count);\r\nbrelse(this_node->bh);\r\nkfree(this_node);\r\nreturn BEFS_BT_END;\r\n}\r\nkey_sum += this_node->head.all_key_count;\r\nnode_off = this_node->head.right;\r\nif (befs_bt_read_node(sb, ds, this_node, node_off) != BEFS_OK) {\r\nbefs_error(sb, "befs_btree_read() failed to read "\r\n"node at %Lu", node_off);\r\ngoto error_alloc;\r\n}\r\n}\r\ncur_key = key_no - key_sum;\r\nvalarray = befs_bt_valarray(this_node);\r\nkeystart = befs_bt_get_key(sb, this_node, cur_key, &keylen);\r\nbefs_debug(sb, "Read [%Lu,%d]: keysize %d", node_off, cur_key, keylen);\r\nif (bufsize < keylen + 1) {\r\nbefs_error(sb, "befs_btree_read() keybuf too small (%u) "\r\n"for key of size %d", bufsize, keylen);\r\nbrelse(this_node->bh);\r\ngoto error_alloc;\r\n};\r\nstrncpy(keybuf, keystart, keylen);\r\n*value = fs64_to_cpu(sb, valarray[cur_key]);\r\n*keysize = keylen;\r\nkeybuf[keylen] = '\0';\r\nbefs_debug(sb, "Read [%Lu,%d]: Key \"%.*s\", Value %Lu", node_off,\r\ncur_key, keylen, keybuf, *value);\r\nbrelse(this_node->bh);\r\nkfree(this_node);\r\nbefs_debug(sb, "<--- befs_btree_read()");\r\nreturn BEFS_OK;\r\nerror_alloc:\r\nkfree(this_node);\r\nerror:\r\n*keysize = 0;\r\n*value = 0;\r\nbefs_debug(sb, "<--- befs_btree_read() ERROR");\r\nreturn BEFS_ERR;\r\n}\r\nstatic int\r\nbefs_btree_seekleaf(struct super_block *sb, befs_data_stream * ds,\r\nbefs_btree_super * bt_super, befs_btree_node * this_node,\r\nbefs_off_t * node_off)\r\n{\r\nbefs_debug(sb, "---> befs_btree_seekleaf()");\r\nif (befs_bt_read_node(sb, ds, this_node, *node_off) != BEFS_OK) {\r\nbefs_error(sb, "befs_btree_seekleaf() failed to read "\r\n"node at %Lu", *node_off);\r\ngoto error;\r\n}\r\nbefs_debug(sb, "Seekleaf to root node %Lu", *node_off);\r\nif (this_node->head.all_key_count == 0 && befs_leafnode(this_node)) {\r\nbefs_debug(sb, "<--- befs_btree_seekleaf() Tree is EMPTY");\r\nreturn BEFS_BT_EMPTY;\r\n}\r\nwhile (!befs_leafnode(this_node)) {\r\nif (this_node->head.all_key_count == 0) {\r\nbefs_debug(sb, "befs_btree_seekleaf() encountered "\r\n"an empty interior node: %Lu. Using Overflow "\r\n"node: %Lu", *node_off,\r\nthis_node->head.overflow);\r\n*node_off = this_node->head.overflow;\r\n} else {\r\nfs64 *valarray = befs_bt_valarray(this_node);\r\n*node_off = fs64_to_cpu(sb, valarray[0]);\r\n}\r\nif (befs_bt_read_node(sb, ds, this_node, *node_off) != BEFS_OK) {\r\nbefs_error(sb, "befs_btree_seekleaf() failed to read "\r\n"node at %Lu", *node_off);\r\ngoto error;\r\n}\r\nbefs_debug(sb, "Seekleaf to child node %Lu", *node_off);\r\n}\r\nbefs_debug(sb, "Node %Lu is a leaf node", *node_off);\r\nreturn BEFS_OK;\r\nerror:\r\nbefs_debug(sb, "<--- befs_btree_seekleaf() ERROR");\r\nreturn BEFS_ERR;\r\n}\r\nstatic int\r\nbefs_leafnode(befs_btree_node * node)\r\n{\r\nif (node->head.overflow == befs_bt_inval)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic fs16 *\r\nbefs_bt_keylen_index(befs_btree_node * node)\r\n{\r\nconst int keylen_align = 8;\r\nunsigned long int off =\r\n(sizeof (befs_btree_nodehead) + node->head.all_key_length);\r\nulong tmp = off % keylen_align;\r\nif (tmp)\r\noff += keylen_align - tmp;\r\nreturn (fs16 *) ((void *) node->od_node + off);\r\n}\r\nstatic fs64 *\r\nbefs_bt_valarray(befs_btree_node * node)\r\n{\r\nvoid *keylen_index_start = (void *) befs_bt_keylen_index(node);\r\nsize_t keylen_index_size = node->head.all_key_count * sizeof (fs16);\r\nreturn (fs64 *) (keylen_index_start + keylen_index_size);\r\n}\r\nstatic char *\r\nbefs_bt_keydata(befs_btree_node * node)\r\n{\r\nreturn (char *) ((void *) node->od_node + sizeof (befs_btree_nodehead));\r\n}\r\nstatic char *\r\nbefs_bt_get_key(struct super_block *sb, befs_btree_node * node,\r\nint index, u16 * keylen)\r\n{\r\nint prev_key_end;\r\nchar *keystart;\r\nfs16 *keylen_index;\r\nif (index < 0 || index > node->head.all_key_count) {\r\n*keylen = 0;\r\nreturn NULL;\r\n}\r\nkeystart = befs_bt_keydata(node);\r\nkeylen_index = befs_bt_keylen_index(node);\r\nif (index == 0)\r\nprev_key_end = 0;\r\nelse\r\nprev_key_end = fs16_to_cpu(sb, keylen_index[index - 1]);\r\n*keylen = fs16_to_cpu(sb, keylen_index[index]) - prev_key_end;\r\nreturn keystart + prev_key_end;\r\n}\r\nstatic int\r\nbefs_compare_strings(const void *key1, int keylen1,\r\nconst void *key2, int keylen2)\r\n{\r\nint len = min_t(int, keylen1, keylen2);\r\nint result = strncmp(key1, key2, len);\r\nif (result == 0)\r\nresult = keylen1 - keylen2;\r\nreturn result;\r\n}
