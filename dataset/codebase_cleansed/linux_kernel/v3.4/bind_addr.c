int sctp_bind_addr_copy(struct sctp_bind_addr *dest,\r\nconst struct sctp_bind_addr *src,\r\nsctp_scope_t scope, gfp_t gfp,\r\nint flags)\r\n{\r\nstruct sctp_sockaddr_entry *addr;\r\nint error = 0;\r\ndest->port = src->port;\r\nlist_for_each_entry(addr, &src->address_list, list) {\r\nerror = sctp_copy_one_addr(dest, &addr->a, scope,\r\ngfp, flags);\r\nif (error < 0)\r\ngoto out;\r\n}\r\nif (list_empty(&dest->address_list) && (SCTP_SCOPE_GLOBAL == scope)) {\r\nlist_for_each_entry(addr, &src->address_list, list) {\r\nerror = sctp_copy_one_addr(dest, &addr->a,\r\nSCTP_SCOPE_LINK, gfp,\r\nflags);\r\nif (error < 0)\r\ngoto out;\r\n}\r\n}\r\nout:\r\nif (error)\r\nsctp_bind_addr_clean(dest);\r\nreturn error;\r\n}\r\nint sctp_bind_addr_dup(struct sctp_bind_addr *dest,\r\nconst struct sctp_bind_addr *src,\r\ngfp_t gfp)\r\n{\r\nstruct sctp_sockaddr_entry *addr;\r\nint error = 0;\r\ndest->port = src->port;\r\nlist_for_each_entry(addr, &src->address_list, list) {\r\nerror = sctp_add_bind_addr(dest, &addr->a, 1, gfp);\r\nif (error < 0)\r\nbreak;\r\n}\r\nreturn error;\r\n}\r\nvoid sctp_bind_addr_init(struct sctp_bind_addr *bp, __u16 port)\r\n{\r\nbp->malloced = 0;\r\nINIT_LIST_HEAD(&bp->address_list);\r\nbp->port = port;\r\n}\r\nstatic void sctp_bind_addr_clean(struct sctp_bind_addr *bp)\r\n{\r\nstruct sctp_sockaddr_entry *addr, *temp;\r\nlist_for_each_entry_safe(addr, temp, &bp->address_list, list) {\r\nlist_del_rcu(&addr->list);\r\nkfree_rcu(addr, rcu);\r\nSCTP_DBG_OBJCNT_DEC(addr);\r\n}\r\n}\r\nvoid sctp_bind_addr_free(struct sctp_bind_addr *bp)\r\n{\r\nsctp_bind_addr_clean(bp);\r\nif (bp->malloced) {\r\nkfree(bp);\r\nSCTP_DBG_OBJCNT_DEC(bind_addr);\r\n}\r\n}\r\nint sctp_add_bind_addr(struct sctp_bind_addr *bp, union sctp_addr *new,\r\n__u8 addr_state, gfp_t gfp)\r\n{\r\nstruct sctp_sockaddr_entry *addr;\r\naddr = t_new(struct sctp_sockaddr_entry, gfp);\r\nif (!addr)\r\nreturn -ENOMEM;\r\nmemcpy(&addr->a, new, sizeof(*new));\r\nif (!addr->a.v4.sin_port)\r\naddr->a.v4.sin_port = htons(bp->port);\r\naddr->state = addr_state;\r\naddr->valid = 1;\r\nINIT_LIST_HEAD(&addr->list);\r\nlist_add_tail_rcu(&addr->list, &bp->address_list);\r\nSCTP_DBG_OBJCNT_INC(addr);\r\nreturn 0;\r\n}\r\nint sctp_del_bind_addr(struct sctp_bind_addr *bp, union sctp_addr *del_addr)\r\n{\r\nstruct sctp_sockaddr_entry *addr, *temp;\r\nint found = 0;\r\nlist_for_each_entry_safe(addr, temp, &bp->address_list, list) {\r\nif (sctp_cmp_addr_exact(&addr->a, del_addr)) {\r\nfound = 1;\r\naddr->valid = 0;\r\nlist_del_rcu(&addr->list);\r\nbreak;\r\n}\r\n}\r\nif (found) {\r\nkfree_rcu(addr, rcu);\r\nSCTP_DBG_OBJCNT_DEC(addr);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nunion sctp_params sctp_bind_addrs_to_raw(const struct sctp_bind_addr *bp,\r\nint *addrs_len,\r\ngfp_t gfp)\r\n{\r\nunion sctp_params addrparms;\r\nunion sctp_params retval;\r\nint addrparms_len;\r\nunion sctp_addr_param rawaddr;\r\nint len;\r\nstruct sctp_sockaddr_entry *addr;\r\nstruct list_head *pos;\r\nstruct sctp_af *af;\r\naddrparms_len = 0;\r\nlen = 0;\r\nlist_for_each(pos, &bp->address_list) {\r\nlen += sizeof(union sctp_addr_param);\r\n}\r\nif (len == sizeof(union sctp_addr_param)) {\r\nretval.v = NULL;\r\ngoto end_raw;\r\n}\r\nretval.v = kmalloc(len, gfp);\r\nif (!retval.v)\r\ngoto end_raw;\r\naddrparms = retval;\r\nlist_for_each_entry(addr, &bp->address_list, list) {\r\naf = sctp_get_af_specific(addr->a.v4.sin_family);\r\nlen = af->to_addr_param(&addr->a, &rawaddr);\r\nmemcpy(addrparms.v, &rawaddr, len);\r\naddrparms.v += len;\r\naddrparms_len += len;\r\n}\r\nend_raw:\r\n*addrs_len = addrparms_len;\r\nreturn retval;\r\n}\r\nint sctp_raw_to_bind_addrs(struct sctp_bind_addr *bp, __u8 *raw_addr_list,\r\nint addrs_len, __u16 port, gfp_t gfp)\r\n{\r\nunion sctp_addr_param *rawaddr;\r\nstruct sctp_paramhdr *param;\r\nunion sctp_addr addr;\r\nint retval = 0;\r\nint len;\r\nstruct sctp_af *af;\r\nwhile (addrs_len) {\r\nparam = (struct sctp_paramhdr *)raw_addr_list;\r\nrawaddr = (union sctp_addr_param *)raw_addr_list;\r\naf = sctp_get_af_specific(param_type2af(param->type));\r\nif (unlikely(!af)) {\r\nretval = -EINVAL;\r\nsctp_bind_addr_clean(bp);\r\nbreak;\r\n}\r\naf->from_addr_param(&addr, rawaddr, htons(port), 0);\r\nretval = sctp_add_bind_addr(bp, &addr, SCTP_ADDR_SRC, gfp);\r\nif (retval) {\r\nsctp_bind_addr_clean(bp);\r\nbreak;\r\n}\r\nlen = ntohs(param->length);\r\naddrs_len -= len;\r\nraw_addr_list += len;\r\n}\r\nreturn retval;\r\n}\r\nint sctp_bind_addr_match(struct sctp_bind_addr *bp,\r\nconst union sctp_addr *addr,\r\nstruct sctp_sock *opt)\r\n{\r\nstruct sctp_sockaddr_entry *laddr;\r\nint match = 0;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(laddr, &bp->address_list, list) {\r\nif (!laddr->valid)\r\ncontinue;\r\nif (opt->pf->cmp_addr(&laddr->a, addr, opt)) {\r\nmatch = 1;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn match;\r\n}\r\nint sctp_bind_addr_conflict(struct sctp_bind_addr *bp,\r\nconst union sctp_addr *addr,\r\nstruct sctp_sock *bp_sp,\r\nstruct sctp_sock *addr_sp)\r\n{\r\nstruct sctp_sockaddr_entry *laddr;\r\nint conflict = 0;\r\nstruct sctp_sock *sp;\r\nif (sctp_opt2sk(bp_sp)->sk_family == AF_INET6)\r\nsp = bp_sp;\r\nelse if (sctp_opt2sk(addr_sp)->sk_family == AF_INET6)\r\nsp = addr_sp;\r\nelse\r\nsp = bp_sp;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(laddr, &bp->address_list, list) {\r\nif (!laddr->valid)\r\ncontinue;\r\nconflict = sp->pf->cmp_addr(&laddr->a, addr, sp);\r\nif (conflict)\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn conflict;\r\n}\r\nint sctp_bind_addr_state(const struct sctp_bind_addr *bp,\r\nconst union sctp_addr *addr)\r\n{\r\nstruct sctp_sockaddr_entry *laddr;\r\nstruct sctp_af *af;\r\nint state = -1;\r\naf = sctp_get_af_specific(addr->sa.sa_family);\r\nif (unlikely(!af))\r\nreturn state;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(laddr, &bp->address_list, list) {\r\nif (!laddr->valid)\r\ncontinue;\r\nif (af->cmp_addr(&laddr->a, addr)) {\r\nstate = laddr->state;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn state;\r\n}\r\nunion sctp_addr *sctp_find_unmatch_addr(struct sctp_bind_addr *bp,\r\nconst union sctp_addr *addrs,\r\nint addrcnt,\r\nstruct sctp_sock *opt)\r\n{\r\nstruct sctp_sockaddr_entry *laddr;\r\nunion sctp_addr *addr;\r\nvoid *addr_buf;\r\nstruct sctp_af *af;\r\nint i;\r\nlist_for_each_entry(laddr, &bp->address_list, list) {\r\naddr_buf = (union sctp_addr *)addrs;\r\nfor (i = 0; i < addrcnt; i++) {\r\naddr = addr_buf;\r\naf = sctp_get_af_specific(addr->v4.sin_family);\r\nif (!af)\r\nbreak;\r\nif (opt->pf->cmp_addr(&laddr->a, addr, opt))\r\nbreak;\r\naddr_buf += af->sockaddr_len;\r\n}\r\nif (i == addrcnt)\r\nreturn &laddr->a;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int sctp_copy_one_addr(struct sctp_bind_addr *dest,\r\nunion sctp_addr *addr,\r\nsctp_scope_t scope, gfp_t gfp,\r\nint flags)\r\n{\r\nint error = 0;\r\nif (sctp_is_any(NULL, addr)) {\r\nerror = sctp_copy_local_addr_list(dest, scope, gfp, flags);\r\n} else if (sctp_in_scope(addr, scope)) {\r\nif ((((AF_INET == addr->sa.sa_family) &&\r\n(flags & SCTP_ADDR4_PEERSUPP))) ||\r\n(((AF_INET6 == addr->sa.sa_family) &&\r\n(flags & SCTP_ADDR6_ALLOWED) &&\r\n(flags & SCTP_ADDR6_PEERSUPP))))\r\nerror = sctp_add_bind_addr(dest, addr, SCTP_ADDR_SRC,\r\ngfp);\r\n}\r\nreturn error;\r\n}\r\nint sctp_is_any(struct sock *sk, const union sctp_addr *addr)\r\n{\r\nunsigned short fam = 0;\r\nstruct sctp_af *af;\r\nif (addr->sa.sa_family != AF_UNSPEC)\r\nfam = addr->sa.sa_family;\r\nelse if (sk)\r\nfam = sk->sk_family;\r\naf = sctp_get_af_specific(fam);\r\nif (!af)\r\nreturn 0;\r\nreturn af->is_any(addr);\r\n}\r\nint sctp_in_scope(const union sctp_addr *addr, sctp_scope_t scope)\r\n{\r\nsctp_scope_t addr_scope = sctp_scope(addr);\r\nif (SCTP_SCOPE_UNUSABLE == addr_scope)\r\nreturn 0;\r\nswitch (sctp_scope_policy) {\r\ncase SCTP_SCOPE_POLICY_DISABLE:\r\nreturn 1;\r\ncase SCTP_SCOPE_POLICY_ENABLE:\r\nif (addr_scope <= scope)\r\nreturn 1;\r\nbreak;\r\ncase SCTP_SCOPE_POLICY_PRIVATE:\r\nif (addr_scope <= scope || SCTP_SCOPE_PRIVATE == addr_scope)\r\nreturn 1;\r\nbreak;\r\ncase SCTP_SCOPE_POLICY_LINK:\r\nif (addr_scope <= scope || SCTP_SCOPE_LINK == addr_scope)\r\nreturn 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint sctp_is_ep_boundall(struct sock *sk)\r\n{\r\nstruct sctp_bind_addr *bp;\r\nstruct sctp_sockaddr_entry *addr;\r\nbp = &sctp_sk(sk)->ep->base.bind_addr;\r\nif (sctp_list_single_entry(&bp->address_list)) {\r\naddr = list_entry(bp->address_list.next,\r\nstruct sctp_sockaddr_entry, list);\r\nif (sctp_is_any(sk, &addr->a))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nsctp_scope_t sctp_scope(const union sctp_addr *addr)\r\n{\r\nstruct sctp_af *af;\r\naf = sctp_get_af_specific(addr->sa.sa_family);\r\nif (!af)\r\nreturn SCTP_SCOPE_UNUSABLE;\r\nreturn af->scope((union sctp_addr *)addr);\r\n}
