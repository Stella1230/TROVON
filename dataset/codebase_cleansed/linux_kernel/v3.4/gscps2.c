static int wait_TBE(char *addr)\r\n{\r\nint timeout = 25000;\r\nwhile (gscps2_readb_status(addr) & GSC_STAT_TBNE) {\r\nif (!--timeout)\r\nreturn 0;\r\nudelay(10);\r\n}\r\nreturn 1;\r\n}\r\nstatic void gscps2_flush(struct gscps2port *ps2port)\r\n{\r\nwhile (gscps2_readb_status(ps2port->addr) & GSC_STAT_RBNE)\r\ngscps2_readb_input(ps2port->addr);\r\nps2port->act = ps2port->append = 0;\r\n}\r\nstatic inline int gscps2_writeb_output(struct gscps2port *ps2port, u8 data)\r\n{\r\nunsigned long flags;\r\nchar *addr = ps2port->addr;\r\nif (!wait_TBE(addr)) {\r\nprintk(KERN_DEBUG PFX "timeout - could not write byte %#x\n", data);\r\nreturn 0;\r\n}\r\nwhile (gscps2_readb_status(ps2port->addr) & GSC_STAT_RBNE)\r\n;\r\nspin_lock_irqsave(&ps2port->lock, flags);\r\nwriteb(data, addr+GSC_XMTDATA);\r\nspin_unlock_irqrestore(&ps2port->lock, flags);\r\nmdelay(6);\r\ngscps2_interrupt(0, NULL);\r\nreturn 1;\r\n}\r\nstatic void gscps2_enable(struct gscps2port *ps2port, int enable)\r\n{\r\nunsigned long flags;\r\nu8 data;\r\nspin_lock_irqsave(&ps2port->lock, flags);\r\ngscps2_flush(ps2port);\r\ndata = gscps2_readb_control(ps2port->addr);\r\nif (enable)\r\ndata |= GSC_CTRL_ENBL;\r\nelse\r\ndata &= ~GSC_CTRL_ENBL;\r\ngscps2_writeb_control(data, ps2port->addr);\r\nspin_unlock_irqrestore(&ps2port->lock, flags);\r\nwait_TBE(ps2port->addr);\r\ngscps2_flush(ps2port);\r\n}\r\nstatic void gscps2_reset(struct gscps2port *ps2port)\r\n{\r\nchar *addr = ps2port->addr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ps2port->lock, flags);\r\ngscps2_flush(ps2port);\r\nwriteb(0xff, addr+GSC_RESET);\r\ngscps2_flush(ps2port);\r\nspin_unlock_irqrestore(&ps2port->lock, flags);\r\n}\r\nstatic irqreturn_t gscps2_interrupt(int irq, void *dev)\r\n{\r\nstruct gscps2port *ps2port;\r\nlist_for_each_entry(ps2port, &ps2port_list, node) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&ps2port->lock, flags);\r\nwhile ( (ps2port->buffer[ps2port->append].str =\r\ngscps2_readb_status(ps2port->addr)) & GSC_STAT_RBNE ) {\r\nps2port->buffer[ps2port->append].data =\r\ngscps2_readb_input(ps2port->addr);\r\nps2port->append = ((ps2port->append+1) & BUFFER_SIZE);\r\n}\r\nspin_unlock_irqrestore(&ps2port->lock, flags);\r\n}\r\nlist_for_each_entry(ps2port, &ps2port_list, node) {\r\nwhile (ps2port->act != ps2port->append) {\r\nunsigned int rxflags;\r\nu8 data, status;\r\nif (gscps2_readb_status(ps2port->addr) & GSC_STAT_CMPINTR)\r\nreturn IRQ_HANDLED;\r\nstatus = ps2port->buffer[ps2port->act].str;\r\ndata = ps2port->buffer[ps2port->act].data;\r\nps2port->act = ((ps2port->act+1) & BUFFER_SIZE);\r\nrxflags = ((status & GSC_STAT_TERR) ? SERIO_TIMEOUT : 0 ) |\r\n((status & GSC_STAT_PERR) ? SERIO_PARITY : 0 );\r\nserio_interrupt(ps2port->port, data, rxflags);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int gscps2_write(struct serio *port, unsigned char data)\r\n{\r\nstruct gscps2port *ps2port = port->port_data;\r\nif (!gscps2_writeb_output(ps2port, data)) {\r\nprintk(KERN_DEBUG PFX "sending byte %#x failed.\n", data);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gscps2_open(struct serio *port)\r\n{\r\nstruct gscps2port *ps2port = port->port_data;\r\ngscps2_reset(ps2port);\r\ngscps2_enable(ps2port, ENABLE);\r\ngscps2_interrupt(0, NULL);\r\nreturn 0;\r\n}\r\nstatic void gscps2_close(struct serio *port)\r\n{\r\nstruct gscps2port *ps2port = port->port_data;\r\ngscps2_enable(ps2port, DISABLE);\r\n}\r\nstatic int __devinit gscps2_probe(struct parisc_device *dev)\r\n{\r\nstruct gscps2port *ps2port;\r\nstruct serio *serio;\r\nunsigned long hpa = dev->hpa.start;\r\nint ret;\r\nif (!dev->irq)\r\nreturn -ENODEV;\r\nif (dev->id.sversion == 0x96)\r\nhpa += GSC_DINO_OFFSET;\r\nps2port = kzalloc(sizeof(struct gscps2port), GFP_KERNEL);\r\nserio = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (!ps2port || !serio) {\r\nret = -ENOMEM;\r\ngoto fail_nomem;\r\n}\r\ndev_set_drvdata(&dev->dev, ps2port);\r\nps2port->port = serio;\r\nps2port->padev = dev;\r\nps2port->addr = ioremap_nocache(hpa, GSC_STATUS + 4);\r\nspin_lock_init(&ps2port->lock);\r\ngscps2_reset(ps2port);\r\nps2port->id = readb(ps2port->addr + GSC_ID) & 0x0f;\r\nsnprintf(serio->name, sizeof(serio->name), "gsc-ps2-%s",\r\n(ps2port->id == GSC_ID_KEYBOARD) ? "keyboard" : "mouse");\r\nstrlcpy(serio->phys, dev_name(&dev->dev), sizeof(serio->phys));\r\nserio->id.type = SERIO_8042;\r\nserio->write = gscps2_write;\r\nserio->open = gscps2_open;\r\nserio->close = gscps2_close;\r\nserio->port_data = ps2port;\r\nserio->dev.parent = &dev->dev;\r\nret = -EBUSY;\r\nif (request_irq(dev->irq, gscps2_interrupt, IRQF_SHARED, ps2port->port->name, ps2port))\r\ngoto fail_miserably;\r\nif (ps2port->id != GSC_ID_KEYBOARD && ps2port->id != GSC_ID_MOUSE) {\r\nprintk(KERN_WARNING PFX "Unsupported PS/2 port at 0x%08lx (id=%d) ignored\n",\r\nhpa, ps2port->id);\r\nret = -ENODEV;\r\ngoto fail;\r\n}\r\n#if 0\r\nif (!request_mem_region(hpa, GSC_STATUS + 4, ps2port->port.name))\r\ngoto fail;\r\n#endif\r\nprintk(KERN_INFO "serio: %s port at 0x%p irq %d @ %s\n",\r\nps2port->port->name,\r\nps2port->addr,\r\nps2port->padev->irq,\r\nps2port->port->phys);\r\nserio_register_port(ps2port->port);\r\nlist_add_tail(&ps2port->node, &ps2port_list);\r\nreturn 0;\r\nfail:\r\nfree_irq(dev->irq, ps2port);\r\nfail_miserably:\r\niounmap(ps2port->addr);\r\nrelease_mem_region(dev->hpa.start, GSC_STATUS + 4);\r\nfail_nomem:\r\nkfree(ps2port);\r\nkfree(serio);\r\nreturn ret;\r\n}\r\nstatic int __devexit gscps2_remove(struct parisc_device *dev)\r\n{\r\nstruct gscps2port *ps2port = dev_get_drvdata(&dev->dev);\r\nserio_unregister_port(ps2port->port);\r\nfree_irq(dev->irq, ps2port);\r\ngscps2_flush(ps2port);\r\nlist_del(&ps2port->node);\r\niounmap(ps2port->addr);\r\n#if 0\r\nrelease_mem_region(dev->hpa, GSC_STATUS + 4);\r\n#endif\r\ndev_set_drvdata(&dev->dev, NULL);\r\nkfree(ps2port);\r\nreturn 0;\r\n}\r\nstatic int __init gscps2_init(void)\r\n{\r\nregister_parisc_driver(&parisc_ps2_driver);\r\nreturn 0;\r\n}\r\nstatic void __exit gscps2_exit(void)\r\n{\r\nunregister_parisc_driver(&parisc_ps2_driver);\r\n}
