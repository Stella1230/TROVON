static int qib_parse_ushort(const char *str, unsigned short *valp)\r\n{\r\nunsigned long val;\r\nchar *end;\r\nint ret;\r\nif (!isdigit(str[0])) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nval = simple_strtoul(str, &end, 0);\r\nif (val > 0xffff) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\n*valp = val;\r\nret = end + 1 - str;\r\nif (ret == 0)\r\nret = -EINVAL;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t show_hrtbt_enb(struct qib_pportdata *ppd, char *buf)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nint ret;\r\nret = dd->f_get_ib_cfg(ppd, QIB_IB_CFG_HRTBT);\r\nret = scnprintf(buf, PAGE_SIZE, "%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic ssize_t store_hrtbt_enb(struct qib_pportdata *ppd, const char *buf,\r\nsize_t count)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nint ret;\r\nu16 val;\r\nret = qib_parse_ushort(buf, &val);\r\nif (ret >= 0)\r\nret = dd->f_set_ib_cfg(ppd, QIB_IB_CFG_HRTBT, val);\r\nif (ret < 0)\r\nqib_dev_err(dd, "attempt to set invalid Heartbeat enable\n");\r\nreturn ret < 0 ? ret : count;\r\n}\r\nstatic ssize_t store_loopback(struct qib_pportdata *ppd, const char *buf,\r\nsize_t count)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nint ret = count, r;\r\nr = dd->f_set_ib_loopback(ppd, buf);\r\nif (r < 0)\r\nret = r;\r\nreturn ret;\r\n}\r\nstatic ssize_t store_led_override(struct qib_pportdata *ppd, const char *buf,\r\nsize_t count)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nint ret;\r\nu16 val;\r\nret = qib_parse_ushort(buf, &val);\r\nif (ret > 0)\r\nqib_set_led_override(ppd, val);\r\nelse\r\nqib_dev_err(dd, "attempt to set invalid LED override\n");\r\nreturn ret < 0 ? ret : count;\r\n}\r\nstatic ssize_t show_status(struct qib_pportdata *ppd, char *buf)\r\n{\r\nssize_t ret;\r\nif (!ppd->statusp)\r\nret = -EINVAL;\r\nelse\r\nret = scnprintf(buf, PAGE_SIZE, "0x%llx\n",\r\n(unsigned long long) *(ppd->statusp));\r\nreturn ret;\r\n}\r\nstatic ssize_t show_status_str(struct qib_pportdata *ppd, char *buf)\r\n{\r\nint i, any;\r\nu64 s;\r\nssize_t ret;\r\nif (!ppd->statusp) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\ns = *(ppd->statusp);\r\n*buf = '\0';\r\nfor (any = i = 0; s && qib_status_str[i]; i++) {\r\nif (s & 1) {\r\nif (any && strlcat(buf, " ", PAGE_SIZE) >= PAGE_SIZE)\r\nbreak;\r\nif (strlcat(buf, qib_status_str[i], PAGE_SIZE) >=\r\nPAGE_SIZE)\r\nbreak;\r\nany = 1;\r\n}\r\ns >>= 1;\r\n}\r\nif (any)\r\nstrlcat(buf, "\n", PAGE_SIZE);\r\nret = strlen(buf);\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t qib_portattr_show(struct kobject *kobj,\r\nstruct attribute *attr, char *buf)\r\n{\r\nstruct qib_port_attr *pattr =\r\ncontainer_of(attr, struct qib_port_attr, attr);\r\nstruct qib_pportdata *ppd =\r\ncontainer_of(kobj, struct qib_pportdata, pport_kobj);\r\nreturn pattr->show(ppd, buf);\r\n}\r\nstatic ssize_t qib_portattr_store(struct kobject *kobj,\r\nstruct attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct qib_port_attr *pattr =\r\ncontainer_of(attr, struct qib_port_attr, attr);\r\nstruct qib_pportdata *ppd =\r\ncontainer_of(kobj, struct qib_pportdata, pport_kobj);\r\nreturn pattr->store(ppd, buf, len);\r\n}\r\nstatic void qib_port_release(struct kobject *kobj)\r\n{\r\n}\r\nstatic ssize_t sl2vl_attr_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct qib_sl2vl_attr *sattr =\r\ncontainer_of(attr, struct qib_sl2vl_attr, attr);\r\nstruct qib_pportdata *ppd =\r\ncontainer_of(kobj, struct qib_pportdata, sl2vl_kobj);\r\nstruct qib_ibport *qibp = &ppd->ibport_data;\r\nreturn sprintf(buf, "%u\n", qibp->sl_to_vl[sattr->sl]);\r\n}\r\nstatic ssize_t diagc_attr_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct qib_diagc_attr *dattr =\r\ncontainer_of(attr, struct qib_diagc_attr, attr);\r\nstruct qib_pportdata *ppd =\r\ncontainer_of(kobj, struct qib_pportdata, diagc_kobj);\r\nstruct qib_ibport *qibp = &ppd->ibport_data;\r\nreturn sprintf(buf, "%u\n", *(u32 *)((char *)qibp + dattr->counter));\r\n}\r\nstatic ssize_t diagc_attr_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct qib_diagc_attr *dattr =\r\ncontainer_of(attr, struct qib_diagc_attr, attr);\r\nstruct qib_pportdata *ppd =\r\ncontainer_of(kobj, struct qib_pportdata, diagc_kobj);\r\nstruct qib_ibport *qibp = &ppd->ibport_data;\r\nchar *endp;\r\nlong val = simple_strtol(buf, &endp, 0);\r\nif (val < 0 || endp == buf)\r\nreturn -EINVAL;\r\n*(u32 *)((char *) qibp + dattr->counter) = val;\r\nreturn size;\r\n}\r\nstatic ssize_t show_rev(struct device *device, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct qib_ibdev *dev =\r\ncontainer_of(device, struct qib_ibdev, ibdev.dev);\r\nreturn sprintf(buf, "%x\n", dd_from_dev(dev)->minrev);\r\n}\r\nstatic ssize_t show_hca(struct device *device, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct qib_ibdev *dev =\r\ncontainer_of(device, struct qib_ibdev, ibdev.dev);\r\nstruct qib_devdata *dd = dd_from_dev(dev);\r\nint ret;\r\nif (!dd->boardname)\r\nret = -EINVAL;\r\nelse\r\nret = scnprintf(buf, PAGE_SIZE, "%s\n", dd->boardname);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_version(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%s", (char *)ib_qib_version);\r\n}\r\nstatic ssize_t show_boardversion(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qib_ibdev *dev =\r\ncontainer_of(device, struct qib_ibdev, ibdev.dev);\r\nstruct qib_devdata *dd = dd_from_dev(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%s", dd->boardversion);\r\n}\r\nstatic ssize_t show_localbus_info(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qib_ibdev *dev =\r\ncontainer_of(device, struct qib_ibdev, ibdev.dev);\r\nstruct qib_devdata *dd = dd_from_dev(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%s", dd->lbus_info);\r\n}\r\nstatic ssize_t show_nctxts(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qib_ibdev *dev =\r\ncontainer_of(device, struct qib_ibdev, ibdev.dev);\r\nstruct qib_devdata *dd = dd_from_dev(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", dd->cfgctxts -\r\ndd->first_user_ctxt);\r\n}\r\nstatic ssize_t show_nfreectxts(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qib_ibdev *dev =\r\ncontainer_of(device, struct qib_ibdev, ibdev.dev);\r\nstruct qib_devdata *dd = dd_from_dev(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", dd->freectxts);\r\n}\r\nstatic ssize_t show_serial(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qib_ibdev *dev =\r\ncontainer_of(device, struct qib_ibdev, ibdev.dev);\r\nstruct qib_devdata *dd = dd_from_dev(dev);\r\nbuf[sizeof dd->serial] = '\0';\r\nmemcpy(buf, dd->serial, sizeof dd->serial);\r\nstrcat(buf, "\n");\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t store_chip_reset(struct device *device,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct qib_ibdev *dev =\r\ncontainer_of(device, struct qib_ibdev, ibdev.dev);\r\nstruct qib_devdata *dd = dd_from_dev(dev);\r\nint ret;\r\nif (count < 5 || memcmp(buf, "reset", 5) || !dd->diag_client) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nret = qib_reset_device(dd->unit);\r\nbail:\r\nreturn ret < 0 ? ret : count;\r\n}\r\nstatic ssize_t show_logged_errs(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qib_ibdev *dev =\r\ncontainer_of(device, struct qib_ibdev, ibdev.dev);\r\nstruct qib_devdata *dd = dd_from_dev(dev);\r\nint idx, count;\r\nif (qib_update_eeprom_log(dd) != 0)\r\nreturn -ENXIO;\r\ncount = 0;\r\nfor (idx = 0; idx < QIB_EEP_LOG_CNT; ++idx) {\r\ncount += scnprintf(buf + count, PAGE_SIZE - count, "%d%c",\r\ndd->eep_st_errs[idx],\r\nidx == (QIB_EEP_LOG_CNT - 1) ? '\n' : ' ');\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t show_tempsense(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qib_ibdev *dev =\r\ncontainer_of(device, struct qib_ibdev, ibdev.dev);\r\nstruct qib_devdata *dd = dd_from_dev(dev);\r\nint ret;\r\nint idx;\r\nu8 regvals[8];\r\nret = -ENXIO;\r\nfor (idx = 0; idx < 8; ++idx) {\r\nif (idx == 6)\r\ncontinue;\r\nret = dd->f_tempsense_rd(dd, idx);\r\nif (ret < 0)\r\nbreak;\r\nregvals[idx] = ret;\r\n}\r\nif (idx == 8)\r\nret = scnprintf(buf, PAGE_SIZE, "%d %d %02X %02X %d %d\n",\r\n*(signed char *)(regvals),\r\n*(signed char *)(regvals + 1),\r\nregvals[2], regvals[3],\r\n*(signed char *)(regvals + 5),\r\n*(signed char *)(regvals + 7));\r\nreturn ret;\r\n}\r\nint qib_create_port_files(struct ib_device *ibdev, u8 port_num,\r\nstruct kobject *kobj)\r\n{\r\nstruct qib_pportdata *ppd;\r\nstruct qib_devdata *dd = dd_from_ibdev(ibdev);\r\nint ret;\r\nif (!port_num || port_num > dd->num_pports) {\r\nqib_dev_err(dd, "Skipping infiniband class with "\r\n"invalid port %u\n", port_num);\r\nret = -ENODEV;\r\ngoto bail;\r\n}\r\nppd = &dd->pport[port_num - 1];\r\nret = kobject_init_and_add(&ppd->pport_kobj, &qib_port_ktype, kobj,\r\n"linkcontrol");\r\nif (ret) {\r\nqib_dev_err(dd, "Skipping linkcontrol sysfs info, "\r\n"(err %d) port %u\n", ret, port_num);\r\ngoto bail;\r\n}\r\nkobject_uevent(&ppd->pport_kobj, KOBJ_ADD);\r\nret = kobject_init_and_add(&ppd->sl2vl_kobj, &qib_sl2vl_ktype, kobj,\r\n"sl2vl");\r\nif (ret) {\r\nqib_dev_err(dd, "Skipping sl2vl sysfs info, "\r\n"(err %d) port %u\n", ret, port_num);\r\ngoto bail_sl;\r\n}\r\nkobject_uevent(&ppd->sl2vl_kobj, KOBJ_ADD);\r\nret = kobject_init_and_add(&ppd->diagc_kobj, &qib_diagc_ktype, kobj,\r\n"diag_counters");\r\nif (ret) {\r\nqib_dev_err(dd, "Skipping diag_counters sysfs info, "\r\n"(err %d) port %u\n", ret, port_num);\r\ngoto bail_diagc;\r\n}\r\nkobject_uevent(&ppd->diagc_kobj, KOBJ_ADD);\r\nreturn 0;\r\nbail_diagc:\r\nkobject_put(&ppd->sl2vl_kobj);\r\nbail_sl:\r\nkobject_put(&ppd->pport_kobj);\r\nbail:\r\nreturn ret;\r\n}\r\nint qib_verbs_register_sysfs(struct qib_devdata *dd)\r\n{\r\nstruct ib_device *dev = &dd->verbs_dev.ibdev;\r\nint i, ret;\r\nfor (i = 0; i < ARRAY_SIZE(qib_attributes); ++i) {\r\nret = device_create_file(&dev->dev, qib_attributes[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid qib_verbs_unregister_sysfs(struct qib_devdata *dd)\r\n{\r\nstruct qib_pportdata *ppd;\r\nint i;\r\nfor (i = 0; i < dd->num_pports; i++) {\r\nppd = &dd->pport[i];\r\nkobject_put(&ppd->pport_kobj);\r\nkobject_put(&ppd->sl2vl_kobj);\r\n}\r\n}
