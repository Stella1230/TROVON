static inline int is_slot64bit(struct slot *slot)\r\n{\r\nreturn (readb(slot->p_sm_slot + SMBIOS_SLOT_WIDTH) == 0x06) ? 1 : 0;\r\n}\r\nstatic inline int is_slot66mhz(struct slot *slot)\r\n{\r\nreturn (readb(slot->p_sm_slot + SMBIOS_SLOT_TYPE) == 0x0E) ? 1 : 0;\r\n}\r\nstatic void __iomem * detect_SMBIOS_pointer(void __iomem *begin, void __iomem *end)\r\n{\r\nvoid __iomem *fp;\r\nvoid __iomem *endp;\r\nu8 temp1, temp2, temp3, temp4;\r\nint status = 0;\r\nendp = (end - sizeof(u32) + 1);\r\nfor (fp = begin; fp <= endp; fp += 16) {\r\ntemp1 = readb(fp);\r\ntemp2 = readb(fp+1);\r\ntemp3 = readb(fp+2);\r\ntemp4 = readb(fp+3);\r\nif (temp1 == '_' &&\r\ntemp2 == 'S' &&\r\ntemp3 == 'M' &&\r\ntemp4 == '_') {\r\nstatus = 1;\r\nbreak;\r\n}\r\n}\r\nif (!status)\r\nfp = NULL;\r\ndbg("Discovered SMBIOS Entry point at %p\n", fp);\r\nreturn fp;\r\n}\r\nstatic int init_SERR(struct controller * ctrl)\r\n{\r\nu32 tempdword;\r\nu32 number_of_slots;\r\nu8 physical_slot;\r\nif (!ctrl)\r\nreturn 1;\r\ntempdword = ctrl->first_slot;\r\nnumber_of_slots = readb(ctrl->hpc_reg + SLOT_MASK) & 0x0F;\r\nwhile (number_of_slots) {\r\nphysical_slot = tempdword;\r\nwriteb(0, ctrl->hpc_reg + SLOT_SERR);\r\ntempdword++;\r\nnumber_of_slots--;\r\n}\r\nreturn 0;\r\n}\r\nstatic int init_cpqhp_routing_table(void)\r\n{\r\nint len;\r\ncpqhp_routing_table = pcibios_get_irq_routing_table();\r\nif (cpqhp_routing_table == NULL)\r\nreturn -ENOMEM;\r\nlen = cpqhp_routing_table_length();\r\nif (len == 0) {\r\nkfree(cpqhp_routing_table);\r\ncpqhp_routing_table = NULL;\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pci_print_IRQ_route(void)\r\n{\r\nint len;\r\nint loop;\r\nu8 tbus, tdevice, tslot;\r\nlen = cpqhp_routing_table_length();\r\ndbg("bus dev func slot\n");\r\nfor (loop = 0; loop < len; ++loop) {\r\ntbus = cpqhp_routing_table->slots[loop].bus;\r\ntdevice = cpqhp_routing_table->slots[loop].devfn;\r\ntslot = cpqhp_routing_table->slots[loop].slot;\r\ndbg("%d %d %d %d\n", tbus, tdevice >> 3, tdevice & 0x7, tslot);\r\n}\r\nreturn;\r\n}\r\nstatic void __iomem *get_subsequent_smbios_entry(void __iomem *smbios_start,\r\nvoid __iomem *smbios_table,\r\nvoid __iomem *curr)\r\n{\r\nu8 bail = 0;\r\nu8 previous_byte = 1;\r\nvoid __iomem *p_temp;\r\nvoid __iomem *p_max;\r\nif (!smbios_table || !curr)\r\nreturn NULL;\r\np_max = smbios_start + readw(smbios_table + ST_LENGTH);\r\np_temp = curr;\r\np_temp += readb(curr + SMBIOS_GENERIC_LENGTH);\r\nwhile ((p_temp < p_max) && !bail) {\r\nif (!previous_byte && !(readb(p_temp)))\r\nbail = 1;\r\nprevious_byte = readb(p_temp);\r\np_temp++;\r\n}\r\nif (p_temp < p_max)\r\nreturn p_temp;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic void __iomem *get_SMBIOS_entry(void __iomem *smbios_start,\r\nvoid __iomem *smbios_table,\r\nu8 type,\r\nvoid __iomem *previous)\r\n{\r\nif (!smbios_table)\r\nreturn NULL;\r\nif (!previous)\r\nprevious = smbios_start;\r\nelse\r\nprevious = get_subsequent_smbios_entry(smbios_start,\r\nsmbios_table, previous);\r\nwhile (previous)\r\nif (readb(previous + SMBIOS_GENERIC_TYPE) != type)\r\nprevious = get_subsequent_smbios_entry(smbios_start,\r\nsmbios_table, previous);\r\nelse\r\nbreak;\r\nreturn previous;\r\n}\r\nstatic void release_slot(struct hotplug_slot *hotplug_slot)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\ndbg("%s - physical_slot = %s\n", __func__, slot_name(slot));\r\nkfree(slot->hotplug_slot->info);\r\nkfree(slot->hotplug_slot);\r\nkfree(slot);\r\n}\r\nstatic int ctrl_slot_cleanup (struct controller * ctrl)\r\n{\r\nstruct slot *old_slot, *next_slot;\r\nold_slot = ctrl->slot;\r\nctrl->slot = NULL;\r\nwhile (old_slot) {\r\nnext_slot = old_slot->next;\r\npci_hp_deregister (old_slot->hotplug_slot);\r\nold_slot = next_slot;\r\n}\r\ncpqhp_remove_debugfs_files(ctrl);\r\nfree_irq(ctrl->interrupt, ctrl);\r\niounmap(ctrl->hpc_reg);\r\nrelease_mem_region(pci_resource_start(ctrl->pci_dev, 0),\r\npci_resource_len(ctrl->pci_dev, 0));\r\nreturn 0;\r\n}\r\nstatic int\r\nget_slot_mapping(struct pci_bus *bus, u8 bus_num, u8 dev_num, u8 *slot)\r\n{\r\nu32 work;\r\nlong len;\r\nlong loop;\r\nu8 tbus, tdevice, tslot, bridgeSlot;\r\ndbg("%s: %p, %d, %d, %p\n", __func__, bus, bus_num, dev_num, slot);\r\nbridgeSlot = 0xFF;\r\nlen = cpqhp_routing_table_length();\r\nfor (loop = 0; loop < len; ++loop) {\r\ntbus = cpqhp_routing_table->slots[loop].bus;\r\ntdevice = cpqhp_routing_table->slots[loop].devfn >> 3;\r\ntslot = cpqhp_routing_table->slots[loop].slot;\r\nif ((tbus == bus_num) && (tdevice == dev_num)) {\r\n*slot = tslot;\r\nreturn 0;\r\n} else {\r\nbus->number = tbus;\r\npci_bus_read_config_dword(bus, PCI_DEVFN(tdevice, 0),\r\nPCI_CLASS_REVISION, &work);\r\nif ((work >> 8) == PCI_TO_PCI_BRIDGE_CLASS) {\r\npci_bus_read_config_dword(bus,\r\nPCI_DEVFN(tdevice, 0),\r\nPCI_PRIMARY_BUS, &work);\r\nif (((work >> 8) & 0x000000FF) == (long) bus_num)\r\nbridgeSlot = tslot;\r\n}\r\n}\r\n}\r\nif (bridgeSlot != 0xFF) {\r\n*slot = bridgeSlot;\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int\r\ncpqhp_set_attention_status(struct controller *ctrl, struct pci_func *func,\r\nu32 status)\r\n{\r\nu8 hp_slot;\r\nif (func == NULL)\r\nreturn 1;\r\nhp_slot = func->device - ctrl->slot_device_offset;\r\nmutex_lock(&ctrl->crit_sect);\r\nif (status == 1)\r\namber_LED_on (ctrl, hp_slot);\r\nelse if (status == 0)\r\namber_LED_off (ctrl, hp_slot);\r\nelse {\r\nmutex_unlock(&ctrl->crit_sect);\r\nreturn 1;\r\n}\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq (ctrl);\r\nmutex_unlock(&ctrl->crit_sect);\r\nreturn 0;\r\n}\r\nstatic int set_attention_status (struct hotplug_slot *hotplug_slot, u8 status)\r\n{\r\nstruct pci_func *slot_func;\r\nstruct slot *slot = hotplug_slot->private;\r\nstruct controller *ctrl = slot->ctrl;\r\nu8 bus;\r\nu8 devfn;\r\nu8 device;\r\nu8 function;\r\ndbg("%s - physical_slot = %s\n", __func__, slot_name(slot));\r\nif (cpqhp_get_bus_dev(ctrl, &bus, &devfn, slot->number) == -1)\r\nreturn -ENODEV;\r\ndevice = devfn >> 3;\r\nfunction = devfn & 0x7;\r\ndbg("bus, dev, fn = %d, %d, %d\n", bus, device, function);\r\nslot_func = cpqhp_slot_find(bus, device, function);\r\nif (!slot_func)\r\nreturn -ENODEV;\r\nreturn cpqhp_set_attention_status(ctrl, slot_func, status);\r\n}\r\nstatic int process_SI(struct hotplug_slot *hotplug_slot)\r\n{\r\nstruct pci_func *slot_func;\r\nstruct slot *slot = hotplug_slot->private;\r\nstruct controller *ctrl = slot->ctrl;\r\nu8 bus;\r\nu8 devfn;\r\nu8 device;\r\nu8 function;\r\ndbg("%s - physical_slot = %s\n", __func__, slot_name(slot));\r\nif (cpqhp_get_bus_dev(ctrl, &bus, &devfn, slot->number) == -1)\r\nreturn -ENODEV;\r\ndevice = devfn >> 3;\r\nfunction = devfn & 0x7;\r\ndbg("bus, dev, fn = %d, %d, %d\n", bus, device, function);\r\nslot_func = cpqhp_slot_find(bus, device, function);\r\nif (!slot_func)\r\nreturn -ENODEV;\r\nslot_func->bus = bus;\r\nslot_func->device = device;\r\nslot_func->function = function;\r\nslot_func->configured = 0;\r\ndbg("board_added(%p, %p)\n", slot_func, ctrl);\r\nreturn cpqhp_process_SI(ctrl, slot_func);\r\n}\r\nstatic int process_SS(struct hotplug_slot *hotplug_slot)\r\n{\r\nstruct pci_func *slot_func;\r\nstruct slot *slot = hotplug_slot->private;\r\nstruct controller *ctrl = slot->ctrl;\r\nu8 bus;\r\nu8 devfn;\r\nu8 device;\r\nu8 function;\r\ndbg("%s - physical_slot = %s\n", __func__, slot_name(slot));\r\nif (cpqhp_get_bus_dev(ctrl, &bus, &devfn, slot->number) == -1)\r\nreturn -ENODEV;\r\ndevice = devfn >> 3;\r\nfunction = devfn & 0x7;\r\ndbg("bus, dev, fn = %d, %d, %d\n", bus, device, function);\r\nslot_func = cpqhp_slot_find(bus, device, function);\r\nif (!slot_func)\r\nreturn -ENODEV;\r\ndbg("In %s, slot_func = %p, ctrl = %p\n", __func__, slot_func, ctrl);\r\nreturn cpqhp_process_SS(ctrl, slot_func);\r\n}\r\nstatic int hardware_test(struct hotplug_slot *hotplug_slot, u32 value)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nstruct controller *ctrl = slot->ctrl;\r\ndbg("%s - physical_slot = %s\n", __func__, slot_name(slot));\r\nreturn cpqhp_hardware_test(ctrl, value);\r\n}\r\nstatic int get_power_status(struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nstruct controller *ctrl = slot->ctrl;\r\ndbg("%s - physical_slot = %s\n", __func__, slot_name(slot));\r\n*value = get_slot_enabled(ctrl, slot);\r\nreturn 0;\r\n}\r\nstatic int get_attention_status(struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nstruct controller *ctrl = slot->ctrl;\r\ndbg("%s - physical_slot = %s\n", __func__, slot_name(slot));\r\n*value = cpq_get_attention_status(ctrl, slot);\r\nreturn 0;\r\n}\r\nstatic int get_latch_status(struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nstruct controller *ctrl = slot->ctrl;\r\ndbg("%s - physical_slot = %s\n", __func__, slot_name(slot));\r\n*value = cpq_get_latch_status(ctrl, slot);\r\nreturn 0;\r\n}\r\nstatic int get_adapter_status(struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nstruct controller *ctrl = slot->ctrl;\r\ndbg("%s - physical_slot = %s\n", __func__, slot_name(slot));\r\n*value = get_presence_status(ctrl, slot);\r\nreturn 0;\r\n}\r\nstatic int ctrl_slot_setup(struct controller *ctrl,\r\nvoid __iomem *smbios_start,\r\nvoid __iomem *smbios_table)\r\n{\r\nstruct slot *slot;\r\nstruct hotplug_slot *hotplug_slot;\r\nstruct hotplug_slot_info *hotplug_slot_info;\r\nstruct pci_bus *bus = ctrl->pci_bus;\r\nu8 number_of_slots;\r\nu8 slot_device;\r\nu8 slot_number;\r\nu8 ctrl_slot;\r\nu32 tempdword;\r\nchar name[SLOT_NAME_SIZE];\r\nvoid __iomem *slot_entry= NULL;\r\nint result = -ENOMEM;\r\ndbg("%s\n", __func__);\r\ntempdword = readl(ctrl->hpc_reg + INT_INPUT_CLEAR);\r\nnumber_of_slots = readb(ctrl->hpc_reg + SLOT_MASK) & 0x0F;\r\nslot_device = readb(ctrl->hpc_reg + SLOT_MASK) >> 4;\r\nslot_number = ctrl->first_slot;\r\nwhile (number_of_slots) {\r\nslot = kzalloc(sizeof(*slot), GFP_KERNEL);\r\nif (!slot)\r\ngoto error;\r\nslot->hotplug_slot = kzalloc(sizeof(*(slot->hotplug_slot)),\r\nGFP_KERNEL);\r\nif (!slot->hotplug_slot)\r\ngoto error_slot;\r\nhotplug_slot = slot->hotplug_slot;\r\nhotplug_slot->info = kzalloc(sizeof(*(hotplug_slot->info)),\r\nGFP_KERNEL);\r\nif (!hotplug_slot->info)\r\ngoto error_hpslot;\r\nhotplug_slot_info = hotplug_slot->info;\r\nslot->ctrl = ctrl;\r\nslot->bus = ctrl->bus;\r\nslot->device = slot_device;\r\nslot->number = slot_number;\r\ndbg("slot->number = %u\n", slot->number);\r\nslot_entry = get_SMBIOS_entry(smbios_start, smbios_table, 9,\r\nslot_entry);\r\nwhile (slot_entry && (readw(slot_entry + SMBIOS_SLOT_NUMBER) !=\r\nslot->number)) {\r\nslot_entry = get_SMBIOS_entry(smbios_start,\r\nsmbios_table, 9, slot_entry);\r\n}\r\nslot->p_sm_slot = slot_entry;\r\ninit_timer(&slot->task_event);\r\nslot->task_event.expires = jiffies + 5 * HZ;\r\nslot->task_event.function = cpqhp_pushbutton_thread;\r\nslot->capabilities |= PCISLOT_REPLACE_SUPPORTED;\r\nslot->capabilities |= PCISLOT_INTERLOCK_SUPPORTED;\r\nif (is_slot64bit(slot))\r\nslot->capabilities |= PCISLOT_64_BIT_SUPPORTED;\r\nif (is_slot66mhz(slot))\r\nslot->capabilities |= PCISLOT_66_MHZ_SUPPORTED;\r\nif (bus->cur_bus_speed == PCI_SPEED_66MHz)\r\nslot->capabilities |= PCISLOT_66_MHZ_OPERATION;\r\nctrl_slot =\r\nslot_device - (readb(ctrl->hpc_reg + SLOT_MASK) >> 4);\r\nslot->capabilities |=\r\n((((~tempdword) >> 23) |\r\n((~tempdword) >> 15)) >> ctrl_slot) & 0x02;\r\nslot->capabilities |=\r\n((~tempdword & 0xFF) >> ctrl_slot) & 0x01;\r\nslot->capabilities |=\r\n((read_slot_enable(ctrl) << 2) >> ctrl_slot) & 0x04;\r\nhotplug_slot->release = &release_slot;\r\nhotplug_slot->private = slot;\r\nsnprintf(name, SLOT_NAME_SIZE, "%u", slot->number);\r\nhotplug_slot->ops = &cpqphp_hotplug_slot_ops;\r\nhotplug_slot_info->power_status = get_slot_enabled(ctrl, slot);\r\nhotplug_slot_info->attention_status =\r\ncpq_get_attention_status(ctrl, slot);\r\nhotplug_slot_info->latch_status =\r\ncpq_get_latch_status(ctrl, slot);\r\nhotplug_slot_info->adapter_status =\r\nget_presence_status(ctrl, slot);\r\ndbg("registering bus %d, dev %d, number %d, "\r\n"ctrl->slot_device_offset %d, slot %d\n",\r\nslot->bus, slot->device,\r\nslot->number, ctrl->slot_device_offset,\r\nslot_number);\r\nresult = pci_hp_register(hotplug_slot,\r\nctrl->pci_dev->bus,\r\nslot->device,\r\nname);\r\nif (result) {\r\nerr("pci_hp_register failed with error %d\n", result);\r\ngoto error_info;\r\n}\r\nslot->next = ctrl->slot;\r\nctrl->slot = slot;\r\nnumber_of_slots--;\r\nslot_device++;\r\nslot_number++;\r\n}\r\nreturn 0;\r\nerror_info:\r\nkfree(hotplug_slot_info);\r\nerror_hpslot:\r\nkfree(hotplug_slot);\r\nerror_slot:\r\nkfree(slot);\r\nerror:\r\nreturn result;\r\n}\r\nstatic int one_time_init(void)\r\n{\r\nint loop;\r\nint retval = 0;\r\nif (initialized)\r\nreturn 0;\r\npower_mode = 0;\r\nretval = init_cpqhp_routing_table();\r\nif (retval)\r\ngoto error;\r\nif (cpqhp_debug)\r\npci_print_IRQ_route();\r\ndbg("Initialize + Start the notification mechanism \n");\r\nretval = cpqhp_event_start_thread();\r\nif (retval)\r\ngoto error;\r\ndbg("Initialize slot lists\n");\r\nfor (loop = 0; loop < 256; loop++)\r\ncpqhp_slot_list[loop] = NULL;\r\ncpqhp_rom_start = ioremap(ROM_PHY_ADDR, ROM_PHY_LEN);\r\nif (!cpqhp_rom_start) {\r\nerr ("Could not ioremap memory region for ROM\n");\r\nretval = -EIO;\r\ngoto error;\r\n}\r\ncompaq_nvram_init(cpqhp_rom_start);\r\nsmbios_table = detect_SMBIOS_pointer(cpqhp_rom_start,\r\ncpqhp_rom_start + ROM_PHY_LEN);\r\nif (!smbios_table) {\r\nerr ("Could not find the SMBIOS pointer in memory\n");\r\nretval = -EIO;\r\ngoto error_rom_start;\r\n}\r\nsmbios_start = ioremap(readl(smbios_table + ST_ADDRESS),\r\nreadw(smbios_table + ST_LENGTH));\r\nif (!smbios_start) {\r\nerr ("Could not ioremap memory region taken from SMBIOS values\n");\r\nretval = -EIO;\r\ngoto error_smbios_start;\r\n}\r\ninitialized = 1;\r\nreturn retval;\r\nerror_smbios_start:\r\niounmap(smbios_start);\r\nerror_rom_start:\r\niounmap(cpqhp_rom_start);\r\nerror:\r\nreturn retval;\r\n}\r\nstatic int cpqhpc_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nu8 num_of_slots = 0;\r\nu8 hp_slot = 0;\r\nu8 device;\r\nu8 bus_cap;\r\nu16 temp_word;\r\nu16 vendor_id;\r\nu16 subsystem_vid;\r\nu16 subsystem_deviceid;\r\nu32 rc;\r\nstruct controller *ctrl;\r\nstruct pci_func *func;\r\nstruct pci_bus *bus;\r\nint err;\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\nprintk(KERN_ERR MY_NAME ": cannot enable PCI device %s (%d)\n",\r\npci_name(pdev), err);\r\nreturn err;\r\n}\r\nbus = pdev->subordinate;\r\nif (!bus) {\r\ndev_notice(&pdev->dev, "the device is not a bridge, "\r\n"skipping\n");\r\nrc = -ENODEV;\r\ngoto err_disable_device;\r\n}\r\nvendor_id = pdev->vendor;\r\nif ((vendor_id != PCI_VENDOR_ID_COMPAQ) &&\r\n(vendor_id != PCI_VENDOR_ID_INTEL)) {\r\nerr(msg_HPC_non_compaq_or_intel);\r\nrc = -ENODEV;\r\ngoto err_disable_device;\r\n}\r\ndbg("Vendor ID: %x\n", vendor_id);\r\ndbg("revision: %d\n", pdev->revision);\r\nif ((vendor_id == PCI_VENDOR_ID_COMPAQ) && (!pdev->revision)) {\r\nerr(msg_HPC_rev_error);\r\nrc = -ENODEV;\r\ngoto err_disable_device;\r\n}\r\nif ((pdev->revision <= 2) && (vendor_id != PCI_VENDOR_ID_INTEL)) {\r\nerr(msg_HPC_not_supported);\r\nreturn -ENODEV;\r\n}\r\nsubsystem_vid = pdev->subsystem_vendor;\r\ndbg("Subsystem Vendor ID: %x\n", subsystem_vid);\r\nif ((subsystem_vid != PCI_VENDOR_ID_COMPAQ) && (subsystem_vid != PCI_VENDOR_ID_INTEL)) {\r\nerr(msg_HPC_non_compaq_or_intel);\r\nrc = -ENODEV;\r\ngoto err_disable_device;\r\n}\r\nctrl = kzalloc(sizeof(struct controller), GFP_KERNEL);\r\nif (!ctrl) {\r\nerr("%s : out of memory\n", __func__);\r\nrc = -ENOMEM;\r\ngoto err_disable_device;\r\n}\r\nsubsystem_deviceid = pdev->subsystem_device;\r\ninfo("Hot Plug Subsystem Device ID: %x\n", subsystem_deviceid);\r\nctrl->vendor_id = vendor_id;\r\nswitch (subsystem_vid) {\r\ncase PCI_VENDOR_ID_COMPAQ:\r\nif (pdev->revision >= 0x13) {\r\nctrl->push_flag = 1;\r\nctrl->slot_switch_type = 1;\r\nctrl->push_button = 1;\r\nctrl->pci_config_space = 1;\r\nctrl->defeature_PHP = 1;\r\nctrl->pcix_support = 1;\r\nctrl->pcix_speed_capability = 1;\r\npci_read_config_byte(pdev, 0x41, &bus_cap);\r\nif (bus_cap & 0x80) {\r\ndbg("bus max supports 133MHz PCI-X\n");\r\nbus->max_bus_speed = PCI_SPEED_133MHz_PCIX;\r\nbreak;\r\n}\r\nif (bus_cap & 0x40) {\r\ndbg("bus max supports 100MHz PCI-X\n");\r\nbus->max_bus_speed = PCI_SPEED_100MHz_PCIX;\r\nbreak;\r\n}\r\nif (bus_cap & 20) {\r\ndbg("bus max supports 66MHz PCI-X\n");\r\nbus->max_bus_speed = PCI_SPEED_66MHz_PCIX;\r\nbreak;\r\n}\r\nif (bus_cap & 10) {\r\ndbg("bus max supports 66MHz PCI\n");\r\nbus->max_bus_speed = PCI_SPEED_66MHz;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nswitch (subsystem_deviceid) {\r\ncase PCI_SUB_HPC_ID:\r\nctrl->slot_switch_type = 1;\r\nbus->max_bus_speed = PCI_SPEED_33MHz;\r\nctrl->push_button = 0;\r\nctrl->pci_config_space = 1;\r\nctrl->defeature_PHP = 1;\r\nctrl->pcix_support = 0;\r\nctrl->pcix_speed_capability = 0;\r\nbreak;\r\ncase PCI_SUB_HPC_ID2:\r\nctrl->push_flag = 1;\r\nctrl->slot_switch_type = 1;\r\nbus->max_bus_speed = PCI_SPEED_33MHz;\r\nctrl->push_button = 1;\r\nctrl->pci_config_space = 1;\r\nctrl->defeature_PHP = 1;\r\nctrl->pcix_support = 0;\r\nctrl->pcix_speed_capability = 0;\r\nbreak;\r\ncase PCI_SUB_HPC_ID_INTC:\r\nctrl->slot_switch_type = 1;\r\nbus->max_bus_speed = PCI_SPEED_33MHz;\r\nctrl->push_button = 0;\r\nctrl->pci_config_space = 1;\r\nctrl->defeature_PHP = 1;\r\nctrl->pcix_support = 0;\r\nctrl->pcix_speed_capability = 0;\r\nbreak;\r\ncase PCI_SUB_HPC_ID3:\r\nctrl->push_flag = 1;\r\nctrl->slot_switch_type = 1;\r\nbus->max_bus_speed = PCI_SPEED_66MHz;\r\nctrl->push_button = 1;\r\nctrl->pci_config_space = 1;\r\nctrl->defeature_PHP = 1;\r\nctrl->pcix_support = 0;\r\nctrl->pcix_speed_capability = 0;\r\nbreak;\r\ncase PCI_SUB_HPC_ID4:\r\nctrl->push_flag = 1;\r\nctrl->slot_switch_type = 1;\r\nbus->max_bus_speed = PCI_SPEED_100MHz_PCIX;\r\nctrl->push_button = 1;\r\nctrl->pci_config_space = 1;\r\nctrl->defeature_PHP = 1;\r\nctrl->pcix_support = 1;\r\nctrl->pcix_speed_capability = 0;\r\nbreak;\r\ndefault:\r\nerr(msg_HPC_not_supported);\r\nrc = -ENODEV;\r\ngoto err_free_ctrl;\r\n}\r\nbreak;\r\ncase PCI_VENDOR_ID_INTEL:\r\nif (subsystem_deviceid & 0x0001)\r\nbus->max_bus_speed = PCI_SPEED_66MHz;\r\nelse\r\nbus->max_bus_speed = PCI_SPEED_33MHz;\r\nif (subsystem_deviceid & 0x0002)\r\nctrl->push_button = 0;\r\nelse\r\nctrl->push_button = 1;\r\nif (subsystem_deviceid & 0x0004)\r\nctrl->slot_switch_type = 0;\r\nelse\r\nctrl->slot_switch_type = 1;\r\nif (subsystem_deviceid & 0x0008)\r\nctrl->defeature_PHP = 1;\r\nelse\r\nctrl->defeature_PHP = 0;\r\nif (subsystem_deviceid & 0x0010)\r\nctrl->alternate_base_address = 1;\r\nelse\r\nctrl->alternate_base_address = 0;\r\nif (subsystem_deviceid & 0x0020)\r\nctrl->pci_config_space = 1;\r\nelse\r\nctrl->pci_config_space = 0;\r\nif (subsystem_deviceid & 0x0080) {\r\nctrl->pcix_support = 1;\r\nif (subsystem_deviceid & 0x0040)\r\nctrl->pcix_speed_capability = 1;\r\nelse\r\nctrl->pcix_speed_capability = 0;\r\n} else {\r\nctrl->pcix_support = 0;\r\nctrl->pcix_speed_capability = 0;\r\n}\r\nbreak;\r\ndefault:\r\nerr(msg_HPC_not_supported);\r\nrc = -ENODEV;\r\ngoto err_free_ctrl;\r\n}\r\ninfo("Initializing the PCI hot plug controller residing on PCI bus %d\n",\r\npdev->bus->number);\r\ndbg("Hotplug controller capabilities:\n");\r\ndbg(" speed_capability %d\n", bus->max_bus_speed);\r\ndbg(" slot_switch_type %s\n", ctrl->slot_switch_type ?\r\n"switch present" : "no switch");\r\ndbg(" defeature_PHP %s\n", ctrl->defeature_PHP ?\r\n"PHP supported" : "PHP not supported");\r\ndbg(" alternate_base_address %s\n", ctrl->alternate_base_address ?\r\n"supported" : "not supported");\r\ndbg(" pci_config_space %s\n", ctrl->pci_config_space ?\r\n"supported" : "not supported");\r\ndbg(" pcix_speed_capability %s\n", ctrl->pcix_speed_capability ?\r\n"supported" : "not supported");\r\ndbg(" pcix_support %s\n", ctrl->pcix_support ?\r\n"supported" : "not supported");\r\nctrl->pci_dev = pdev;\r\npci_set_drvdata(pdev, ctrl);\r\nctrl->pci_bus = kmemdup(pdev->bus, sizeof(*ctrl->pci_bus), GFP_KERNEL);\r\nif (!ctrl->pci_bus) {\r\nerr("out of memory\n");\r\nrc = -ENOMEM;\r\ngoto err_free_ctrl;\r\n}\r\nctrl->bus = pdev->bus->number;\r\nctrl->rev = pdev->revision;\r\ndbg("bus device function rev: %d %d %d %d\n", ctrl->bus,\r\nPCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn), ctrl->rev);\r\nmutex_init(&ctrl->crit_sect);\r\ninit_waitqueue_head(&ctrl->queue);\r\nrc = one_time_init();\r\nif (rc) {\r\ngoto err_free_bus;\r\n}\r\ndbg("pdev = %p\n", pdev);\r\ndbg("pci resource start %llx\n", (unsigned long long)pci_resource_start(pdev, 0));\r\ndbg("pci resource len %llx\n", (unsigned long long)pci_resource_len(pdev, 0));\r\nif (!request_mem_region(pci_resource_start(pdev, 0),\r\npci_resource_len(pdev, 0), MY_NAME)) {\r\nerr("cannot reserve MMIO region\n");\r\nrc = -ENOMEM;\r\ngoto err_free_bus;\r\n}\r\nctrl->hpc_reg = ioremap(pci_resource_start(pdev, 0),\r\npci_resource_len(pdev, 0));\r\nif (!ctrl->hpc_reg) {\r\nerr("cannot remap MMIO region %llx @ %llx\n",\r\n(unsigned long long)pci_resource_len(pdev, 0),\r\n(unsigned long long)pci_resource_start(pdev, 0));\r\nrc = -ENODEV;\r\ngoto err_free_mem_region;\r\n}\r\nbus->cur_bus_speed = get_controller_speed(ctrl);\r\nrc = get_slot_mapping(ctrl->pci_bus, pdev->bus->number,\r\n(readb(ctrl->hpc_reg + SLOT_MASK) >> 4),\r\n&(ctrl->first_slot));\r\ndbg("get_slot_mapping: first_slot = %d, returned = %d\n",\r\nctrl->first_slot, rc);\r\nif (rc) {\r\nerr(msg_initialization_err, rc);\r\ngoto err_iounmap;\r\n}\r\nrc = cpqhp_save_config(ctrl, ctrl->bus, readb(ctrl->hpc_reg + SLOT_MASK));\r\nif (rc) {\r\nerr("%s: unable to save PCI configuration data, error %d\n",\r\n__func__, rc);\r\ngoto err_iounmap;\r\n}\r\nctrl->interrupt = pdev->irq;\r\nif (ctrl->interrupt < 0x10) {\r\ncpqhp_legacy_mode = 1;\r\ndbg("System seems to be configured for Full Table Mapped MPS mode\n");\r\n}\r\nctrl->cfgspc_irq = 0;\r\npci_read_config_byte(pdev, PCI_INTERRUPT_LINE, &ctrl->cfgspc_irq);\r\nrc = cpqhp_find_available_resources(ctrl, cpqhp_rom_start);\r\nctrl->add_support = !rc;\r\nif (rc) {\r\ndbg("cpqhp_find_available_resources = 0x%x\n", rc);\r\nerr("unable to locate PCI configuration resources for hot plug add.\n");\r\ngoto err_iounmap;\r\n}\r\nctrl->slot_device_offset = readb(ctrl->hpc_reg + SLOT_MASK) >> 4;\r\ndbg("NumSlots %d \n", ctrl->slot_device_offset);\r\nctrl->next_event = 0;\r\nrc = ctrl_slot_setup(ctrl, smbios_start, smbios_table);\r\nif (rc) {\r\nerr(msg_initialization_err, 6);\r\nerr("%s: unable to save PCI configuration data, error %d\n",\r\n__func__, rc);\r\ngoto err_iounmap;\r\n}\r\nwritel(0xFFFFFFFFL, ctrl->hpc_reg + INT_MASK);\r\ndbg("HPC interrupt = %d \n", ctrl->interrupt);\r\nif (request_irq(ctrl->interrupt, cpqhp_ctrl_intr,\r\nIRQF_SHARED, MY_NAME, ctrl)) {\r\nerr("Can't get irq %d for the hotplug pci controller\n",\r\nctrl->interrupt);\r\nrc = -ENODEV;\r\ngoto err_iounmap;\r\n}\r\ntemp_word = readw(ctrl->hpc_reg + MISC);\r\ntemp_word |= 0x4006;\r\nwritew(temp_word, ctrl->hpc_reg + MISC);\r\nwritel(0xFFFFFFFFL, ctrl->hpc_reg + INT_INPUT_CLEAR);\r\nctrl->ctrl_int_comp = readl(ctrl->hpc_reg + INT_INPUT_CLEAR);\r\nwritel(0x0L, ctrl->hpc_reg + INT_MASK);\r\nif (!cpqhp_ctrl_list) {\r\ncpqhp_ctrl_list = ctrl;\r\nctrl->next = NULL;\r\n} else {\r\nctrl->next = cpqhp_ctrl_list;\r\ncpqhp_ctrl_list = ctrl;\r\n}\r\nmutex_lock(&ctrl->crit_sect);\r\nnum_of_slots = readb(ctrl->hpc_reg + SLOT_MASK) & 0x0F;\r\ndevice = readb(ctrl->hpc_reg + SLOT_MASK) >> 4;\r\nwhile (num_of_slots) {\r\ndbg("num_of_slots: %d\n", num_of_slots);\r\nfunc = cpqhp_slot_find(ctrl->bus, device, 0);\r\nif (!func)\r\nbreak;\r\nhp_slot = func->device - ctrl->slot_device_offset;\r\ndbg("hp_slot: %d\n", hp_slot);\r\ntemp_word = ctrl->ctrl_int_comp >> 16;\r\nfunc->presence_save = (temp_word >> hp_slot) & 0x01;\r\nfunc->presence_save |= (temp_word >> (hp_slot + 7)) & 0x02;\r\nif (ctrl->ctrl_int_comp & (0x1L << hp_slot))\r\nfunc->switch_save = 0;\r\nelse\r\nfunc->switch_save = 0x10;\r\nif (!power_mode)\r\nif (!func->is_a_board) {\r\ngreen_LED_off(ctrl, hp_slot);\r\nslot_disable(ctrl, hp_slot);\r\n}\r\ndevice++;\r\nnum_of_slots--;\r\n}\r\nif (!power_mode) {\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq(ctrl);\r\n}\r\nrc = init_SERR(ctrl);\r\nif (rc) {\r\nerr("init_SERR failed\n");\r\nmutex_unlock(&ctrl->crit_sect);\r\ngoto err_free_irq;\r\n}\r\nmutex_unlock(&ctrl->crit_sect);\r\ncpqhp_create_debugfs_files(ctrl);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(ctrl->interrupt, ctrl);\r\nerr_iounmap:\r\niounmap(ctrl->hpc_reg);\r\nerr_free_mem_region:\r\nrelease_mem_region(pci_resource_start(pdev, 0), pci_resource_len(pdev, 0));\r\nerr_free_bus:\r\nkfree(ctrl->pci_bus);\r\nerr_free_ctrl:\r\nkfree(ctrl);\r\nerr_disable_device:\r\npci_disable_device(pdev);\r\nreturn rc;\r\n}\r\nstatic void __exit unload_cpqphpd(void)\r\n{\r\nstruct pci_func *next;\r\nstruct pci_func *TempSlot;\r\nint loop;\r\nu32 rc;\r\nstruct controller *ctrl;\r\nstruct controller *tctrl;\r\nstruct pci_resource *res;\r\nstruct pci_resource *tres;\r\nrc = compaq_nvram_store(cpqhp_rom_start);\r\nctrl = cpqhp_ctrl_list;\r\nwhile (ctrl) {\r\nif (ctrl->hpc_reg) {\r\nu16 misc;\r\nrc = read_slot_enable (ctrl);\r\nwriteb(0, ctrl->hpc_reg + SLOT_SERR);\r\nwritel(0xFFFFFFC0L | ~rc, ctrl->hpc_reg + INT_MASK);\r\nmisc = readw(ctrl->hpc_reg + MISC);\r\nmisc &= 0xFFFD;\r\nwritew(misc, ctrl->hpc_reg + MISC);\r\n}\r\nctrl_slot_cleanup(ctrl);\r\nres = ctrl->io_head;\r\nwhile (res) {\r\ntres = res;\r\nres = res->next;\r\nkfree(tres);\r\n}\r\nres = ctrl->mem_head;\r\nwhile (res) {\r\ntres = res;\r\nres = res->next;\r\nkfree(tres);\r\n}\r\nres = ctrl->p_mem_head;\r\nwhile (res) {\r\ntres = res;\r\nres = res->next;\r\nkfree(tres);\r\n}\r\nres = ctrl->bus_head;\r\nwhile (res) {\r\ntres = res;\r\nres = res->next;\r\nkfree(tres);\r\n}\r\nkfree (ctrl->pci_bus);\r\ntctrl = ctrl;\r\nctrl = ctrl->next;\r\nkfree(tctrl);\r\n}\r\nfor (loop = 0; loop < 256; loop++) {\r\nnext = cpqhp_slot_list[loop];\r\nwhile (next != NULL) {\r\nres = next->io_head;\r\nwhile (res) {\r\ntres = res;\r\nres = res->next;\r\nkfree(tres);\r\n}\r\nres = next->mem_head;\r\nwhile (res) {\r\ntres = res;\r\nres = res->next;\r\nkfree(tres);\r\n}\r\nres = next->p_mem_head;\r\nwhile (res) {\r\ntres = res;\r\nres = res->next;\r\nkfree(tres);\r\n}\r\nres = next->bus_head;\r\nwhile (res) {\r\ntres = res;\r\nres = res->next;\r\nkfree(tres);\r\n}\r\nTempSlot = next;\r\nnext = next->next;\r\nkfree(TempSlot);\r\n}\r\n}\r\nif (initialized)\r\ncpqhp_event_stop_thread();\r\nif (cpqhp_rom_start)\r\niounmap(cpqhp_rom_start);\r\nif (smbios_start)\r\niounmap(smbios_start);\r\n}\r\nstatic int __init cpqhpc_init(void)\r\n{\r\nint result;\r\ncpqhp_debug = debug;\r\ninfo (DRIVER_DESC " version: " DRIVER_VERSION "\n");\r\ncpqhp_initialize_debugfs();\r\nresult = pci_register_driver(&cpqhpc_driver);\r\ndbg("pci_register_driver = %d\n", result);\r\nreturn result;\r\n}\r\nstatic void __exit cpqhpc_cleanup(void)\r\n{\r\ndbg("unload_cpqphpd()\n");\r\nunload_cpqphpd();\r\ndbg("pci_unregister_driver\n");\r\npci_unregister_driver(&cpqhpc_driver);\r\ncpqhp_shutdown_debugfs();\r\n}
