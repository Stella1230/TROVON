static void ad7280_crc8_build_table(unsigned char *crc_tab)\r\n{\r\nunsigned char bit, crc;\r\nint cnt, i;\r\nfor (cnt = 0; cnt < 256; cnt++) {\r\ncrc = cnt;\r\nfor (i = 0; i < 8; i++) {\r\nbit = crc & HIGHBIT;\r\ncrc <<= 1;\r\nif (bit)\r\ncrc ^= POLYNOM;\r\n}\r\ncrc_tab[cnt] = crc;\r\n}\r\n}\r\nstatic unsigned char ad7280_calc_crc8(unsigned char *crc_tab, unsigned val)\r\n{\r\nunsigned char crc;\r\ncrc = crc_tab[val >> 16 & 0xFF];\r\ncrc = crc_tab[crc ^ (val >> 8 & 0xFF)];\r\nreturn crc ^ (val & 0xFF);\r\n}\r\nstatic int ad7280_check_crc(struct ad7280_state *st, unsigned val)\r\n{\r\nunsigned char crc = ad7280_calc_crc8(st->crc_tab, val >> 10);\r\nif (crc != ((val >> 2) & 0xFF))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void ad7280_delay(struct ad7280_state *st)\r\n{\r\nif (st->readback_delay_us < 50)\r\nudelay(st->readback_delay_us);\r\nelse\r\nmsleep(1);\r\n}\r\nstatic int __ad7280_read32(struct spi_device *spi, unsigned *val)\r\n{\r\nunsigned rx_buf, tx_buf = cpu_to_be32(AD7280A_READ_TXVAL);\r\nint ret;\r\nstruct spi_transfer t = {\r\n.tx_buf = &tx_buf,\r\n.rx_buf = &rx_buf,\r\n.len = 4,\r\n};\r\nstruct spi_message m;\r\nspi_message_init(&m);\r\nspi_message_add_tail(&t, &m);\r\nret = spi_sync(spi, &m);\r\nif (ret)\r\nreturn ret;\r\n*val = be32_to_cpu(rx_buf);\r\nreturn 0;\r\n}\r\nstatic int ad7280_write(struct ad7280_state *st, unsigned devaddr,\r\nunsigned addr, bool all, unsigned val)\r\n{\r\nunsigned reg = (devaddr << 27 | addr << 21 |\r\n(val & 0xFF) << 13 | all << 12);\r\nreg |= ad7280_calc_crc8(st->crc_tab, reg >> 11) << 3 | 0x2;\r\nreg = cpu_to_be32(reg);\r\nreturn spi_write(st->spi, &reg, 4);\r\n}\r\nstatic int ad7280_read(struct ad7280_state *st, unsigned devaddr,\r\nunsigned addr)\r\n{\r\nint ret;\r\nunsigned tmp;\r\nret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_HB, 1,\r\nAD7280A_CTRL_HB_CONV_INPUT_ALL |\r\nAD7280A_CTRL_HB_CONV_RES_READ_NO |\r\nst->ctrl_hb);\r\nif (ret)\r\nreturn ret;\r\nret = ad7280_write(st, devaddr, AD7280A_CONTROL_HB, 0,\r\nAD7280A_CTRL_HB_CONV_INPUT_ALL |\r\nAD7280A_CTRL_HB_CONV_RES_READ_ALL |\r\nst->ctrl_hb);\r\nif (ret)\r\nreturn ret;\r\nret = ad7280_write(st, devaddr, AD7280A_READ, 0, addr << 2);\r\nif (ret)\r\nreturn ret;\r\n__ad7280_read32(st->spi, &tmp);\r\nif (ad7280_check_crc(st, tmp))\r\nreturn -EIO;\r\nif (((tmp >> 27) != devaddr) || (((tmp >> 21) & 0x3F) != addr))\r\nreturn -EFAULT;\r\nreturn (tmp >> 13) & 0xFF;\r\n}\r\nstatic int ad7280_read_channel(struct ad7280_state *st, unsigned devaddr,\r\nunsigned addr)\r\n{\r\nint ret;\r\nunsigned tmp;\r\nret = ad7280_write(st, devaddr, AD7280A_READ, 0, addr << 2);\r\nif (ret)\r\nreturn ret;\r\nret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_HB, 1,\r\nAD7280A_CTRL_HB_CONV_INPUT_ALL |\r\nAD7280A_CTRL_HB_CONV_RES_READ_NO |\r\nst->ctrl_hb);\r\nif (ret)\r\nreturn ret;\r\nret = ad7280_write(st, devaddr, AD7280A_CONTROL_HB, 0,\r\nAD7280A_CTRL_HB_CONV_INPUT_ALL |\r\nAD7280A_CTRL_HB_CONV_RES_READ_ALL |\r\nAD7280A_CTRL_HB_CONV_START_CS |\r\nst->ctrl_hb);\r\nif (ret)\r\nreturn ret;\r\nad7280_delay(st);\r\n__ad7280_read32(st->spi, &tmp);\r\nif (ad7280_check_crc(st, tmp))\r\nreturn -EIO;\r\nif (((tmp >> 27) != devaddr) || (((tmp >> 23) & 0xF) != addr))\r\nreturn -EFAULT;\r\nreturn (tmp >> 11) & 0xFFF;\r\n}\r\nstatic int ad7280_read_all_channels(struct ad7280_state *st, unsigned cnt,\r\nunsigned *array)\r\n{\r\nint i, ret;\r\nunsigned tmp, sum = 0;\r\nret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_READ, 1,\r\nAD7280A_CELL_VOLTAGE_1 << 2);\r\nif (ret)\r\nreturn ret;\r\nret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_HB, 1,\r\nAD7280A_CTRL_HB_CONV_INPUT_ALL |\r\nAD7280A_CTRL_HB_CONV_RES_READ_ALL |\r\nAD7280A_CTRL_HB_CONV_START_CS |\r\nst->ctrl_hb);\r\nif (ret)\r\nreturn ret;\r\nad7280_delay(st);\r\nfor (i = 0; i < cnt; i++) {\r\n__ad7280_read32(st->spi, &tmp);\r\nif (ad7280_check_crc(st, tmp))\r\nreturn -EIO;\r\nif (array)\r\narray[i] = tmp;\r\nif (((tmp >> 23) & 0xF) <= AD7280A_CELL_VOLTAGE_6)\r\nsum += ((tmp >> 11) & 0xFFF);\r\n}\r\nreturn sum;\r\n}\r\nstatic int ad7280_chain_setup(struct ad7280_state *st)\r\n{\r\nunsigned val, n;\r\nint ret;\r\nret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_LB, 1,\r\nAD7280A_CTRL_LB_DAISY_CHAIN_RB_EN |\r\nAD7280A_CTRL_LB_LOCK_DEV_ADDR |\r\nAD7280A_CTRL_LB_MUST_SET |\r\nAD7280A_CTRL_LB_SWRST |\r\nst->ctrl_lb);\r\nif (ret)\r\nreturn ret;\r\nret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_LB, 1,\r\nAD7280A_CTRL_LB_DAISY_CHAIN_RB_EN |\r\nAD7280A_CTRL_LB_LOCK_DEV_ADDR |\r\nAD7280A_CTRL_LB_MUST_SET |\r\nst->ctrl_lb);\r\nif (ret)\r\nreturn ret;\r\nret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_READ, 1,\r\nAD7280A_CONTROL_LB << 2);\r\nif (ret)\r\nreturn ret;\r\nfor (n = 0; n <= AD7280A_MAX_CHAIN; n++) {\r\n__ad7280_read32(st->spi, &val);\r\nif (val == 0)\r\nreturn n - 1;\r\nif (ad7280_check_crc(st, val))\r\nreturn -EIO;\r\nif (n != AD7280A_DEVADDR(val >> 27))\r\nreturn -EIO;\r\n}\r\nreturn -EFAULT;\r\n}\r\nstatic ssize_t ad7280_show_balance_sw(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct ad7280_state *st = iio_priv(indio_dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nreturn sprintf(buf, "%d\n",\r\n!!(st->cb_mask[this_attr->address >> 8] &\r\n(1 << ((this_attr->address & 0xFF) + 2))));\r\n}\r\nstatic ssize_t ad7280_store_balance_sw(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct ad7280_state *st = iio_priv(indio_dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nbool readin;\r\nint ret;\r\nunsigned devaddr, ch;\r\nret = strtobool(buf, &readin);\r\nif (ret)\r\nreturn ret;\r\ndevaddr = this_attr->address >> 8;\r\nch = this_attr->address & 0xFF;\r\nmutex_lock(&indio_dev->mlock);\r\nif (readin)\r\nst->cb_mask[devaddr] |= 1 << (ch + 2);\r\nelse\r\nst->cb_mask[devaddr] &= ~(1 << (ch + 2));\r\nret = ad7280_write(st, devaddr, AD7280A_CELL_BALANCE,\r\n0, st->cb_mask[devaddr]);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret ? ret : len;\r\n}\r\nstatic ssize_t ad7280_show_balance_timer(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct ad7280_state *st = iio_priv(indio_dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nint ret;\r\nunsigned msecs;\r\nmutex_lock(&indio_dev->mlock);\r\nret = ad7280_read(st, this_attr->address >> 8,\r\nthis_attr->address & 0xFF);\r\nmutex_unlock(&indio_dev->mlock);\r\nif (ret < 0)\r\nreturn ret;\r\nmsecs = (ret >> 3) * 71500;\r\nreturn sprintf(buf, "%d\n", msecs);\r\n}\r\nstatic ssize_t ad7280_store_balance_timer(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct ad7280_state *st = iio_priv(indio_dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nunsigned long val;\r\nint ret;\r\nret = kstrtoul(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nval /= 71500;\r\nif (val > 31)\r\nreturn -EINVAL;\r\nmutex_lock(&indio_dev->mlock);\r\nret = ad7280_write(st, this_attr->address >> 8,\r\nthis_attr->address & 0xFF,\r\n0, (val & 0x1F) << 3);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret ? ret : len;\r\n}\r\nstatic int ad7280_channel_init(struct ad7280_state *st)\r\n{\r\nint dev, ch, cnt;\r\nst->channels = kcalloc((st->slave_num + 1) * 12 + 2,\r\nsizeof(*st->channels), GFP_KERNEL);\r\nif (st->channels == NULL)\r\nreturn -ENOMEM;\r\nfor (dev = 0, cnt = 0; dev <= st->slave_num; dev++)\r\nfor (ch = AD7280A_CELL_VOLTAGE_1; ch <= AD7280A_AUX_ADC_6; ch++,\r\ncnt++) {\r\nif (ch < AD7280A_AUX_ADC_1) {\r\nst->channels[cnt].type = IIO_VOLTAGE;\r\nst->channels[cnt].differential = 1;\r\nst->channels[cnt].channel = (dev * 6) + ch;\r\nst->channels[cnt].channel2 =\r\nst->channels[cnt].channel + 1;\r\n} else {\r\nst->channels[cnt].type = IIO_TEMP;\r\nst->channels[cnt].channel = (dev * 6) + ch - 6;\r\n}\r\nst->channels[cnt].indexed = 1;\r\nst->channels[cnt].info_mask =\r\nIIO_CHAN_INFO_SCALE_SHARED_BIT;\r\nst->channels[cnt].address =\r\nAD7280A_DEVADDR(dev) << 8 | ch;\r\nst->channels[cnt].scan_index = cnt;\r\nst->channels[cnt].scan_type.sign = 'u';\r\nst->channels[cnt].scan_type.realbits = 12;\r\nst->channels[cnt].scan_type.storagebits = 32;\r\nst->channels[cnt].scan_type.shift = 0;\r\n}\r\nst->channels[cnt].type = IIO_VOLTAGE;\r\nst->channels[cnt].differential = 1;\r\nst->channels[cnt].channel = 0;\r\nst->channels[cnt].channel2 = dev * 6;\r\nst->channels[cnt].address = AD7280A_ALL_CELLS;\r\nst->channels[cnt].indexed = 1;\r\nst->channels[cnt].info_mask = IIO_CHAN_INFO_SCALE_SHARED_BIT;\r\nst->channels[cnt].scan_index = cnt;\r\nst->channels[cnt].scan_type.sign = 'u';\r\nst->channels[cnt].scan_type.realbits = 32;\r\nst->channels[cnt].scan_type.storagebits = 32;\r\nst->channels[cnt].scan_type.shift = 0;\r\ncnt++;\r\nst->channels[cnt].type = IIO_TIMESTAMP;\r\nst->channels[cnt].channel = -1;\r\nst->channels[cnt].scan_index = cnt;\r\nst->channels[cnt].scan_type.sign = 's';\r\nst->channels[cnt].scan_type.realbits = 64;\r\nst->channels[cnt].scan_type.storagebits = 64;\r\nst->channels[cnt].scan_type.shift = 0;\r\nreturn cnt + 1;\r\n}\r\nstatic int ad7280_attr_init(struct ad7280_state *st)\r\n{\r\nint dev, ch, cnt;\r\nst->iio_attr = kzalloc(sizeof(*st->iio_attr) * (st->slave_num + 1) *\r\nAD7280A_CELLS_PER_DEV * 2, GFP_KERNEL);\r\nif (st->iio_attr == NULL)\r\nreturn -ENOMEM;\r\nfor (dev = 0, cnt = 0; dev <= st->slave_num; dev++)\r\nfor (ch = AD7280A_CELL_VOLTAGE_1; ch <= AD7280A_CELL_VOLTAGE_6;\r\nch++, cnt++) {\r\nst->iio_attr[cnt].address =\r\nAD7280A_DEVADDR(dev) << 8 | ch;\r\nst->iio_attr[cnt].dev_attr.attr.mode =\r\nS_IWUSR | S_IRUGO;\r\nst->iio_attr[cnt].dev_attr.show =\r\nad7280_show_balance_sw;\r\nst->iio_attr[cnt].dev_attr.store =\r\nad7280_store_balance_sw;\r\nst->iio_attr[cnt].dev_attr.attr.name =\r\nkasprintf(GFP_KERNEL,\r\n"in%d-in%d_balance_switch_en",\r\n(dev * AD7280A_CELLS_PER_DEV) + ch,\r\n(dev * AD7280A_CELLS_PER_DEV) + ch + 1);\r\nad7280_attributes[cnt] =\r\n&st->iio_attr[cnt].dev_attr.attr;\r\ncnt++;\r\nst->iio_attr[cnt].address =\r\nAD7280A_DEVADDR(dev) << 8 |\r\n(AD7280A_CB1_TIMER + ch);\r\nst->iio_attr[cnt].dev_attr.attr.mode =\r\nS_IWUSR | S_IRUGO;\r\nst->iio_attr[cnt].dev_attr.show =\r\nad7280_show_balance_timer;\r\nst->iio_attr[cnt].dev_attr.store =\r\nad7280_store_balance_timer;\r\nst->iio_attr[cnt].dev_attr.attr.name =\r\nkasprintf(GFP_KERNEL, "in%d-in%d_balance_timer",\r\n(dev * AD7280A_CELLS_PER_DEV) + ch,\r\n(dev * AD7280A_CELLS_PER_DEV) + ch + 1);\r\nad7280_attributes[cnt] =\r\n&st->iio_attr[cnt].dev_attr.attr;\r\n}\r\nad7280_attributes[cnt] = NULL;\r\nreturn 0;\r\n}\r\nstatic ssize_t ad7280_read_channel_config(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct ad7280_state *st = iio_priv(indio_dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nunsigned val;\r\nswitch ((u32) this_attr->address) {\r\ncase AD7280A_CELL_OVERVOLTAGE:\r\nval = 1000 + (st->cell_threshhigh * 1568) / 100;\r\nbreak;\r\ncase AD7280A_CELL_UNDERVOLTAGE:\r\nval = 1000 + (st->cell_threshlow * 1568) / 100;\r\nbreak;\r\ncase AD7280A_AUX_ADC_OVERVOLTAGE:\r\nval = (st->aux_threshhigh * 196) / 10;\r\nbreak;\r\ncase AD7280A_AUX_ADC_UNDERVOLTAGE:\r\nval = (st->aux_threshlow * 196) / 10;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t ad7280_write_channel_config(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct ad7280_state *st = iio_priv(indio_dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nlong val;\r\nint ret;\r\nret = strict_strtol(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nswitch ((u32) this_attr->address) {\r\ncase AD7280A_CELL_OVERVOLTAGE:\r\ncase AD7280A_CELL_UNDERVOLTAGE:\r\nval = ((val - 1000) * 100) / 1568;\r\nbreak;\r\ncase AD7280A_AUX_ADC_OVERVOLTAGE:\r\ncase AD7280A_AUX_ADC_UNDERVOLTAGE:\r\nval = (val * 10) / 196;\r\nbreak;\r\ndefault:\r\nreturn -EFAULT;\r\n}\r\nval = clamp(val, 0L, 0xFFL);\r\nmutex_lock(&indio_dev->mlock);\r\nswitch ((u32) this_attr->address) {\r\ncase AD7280A_CELL_OVERVOLTAGE:\r\nst->cell_threshhigh = val;\r\nbreak;\r\ncase AD7280A_CELL_UNDERVOLTAGE:\r\nst->cell_threshlow = val;\r\nbreak;\r\ncase AD7280A_AUX_ADC_OVERVOLTAGE:\r\nst->aux_threshhigh = val;\r\nbreak;\r\ncase AD7280A_AUX_ADC_UNDERVOLTAGE:\r\nst->aux_threshlow = val;\r\nbreak;\r\n}\r\nret = ad7280_write(st, AD7280A_DEVADDR_MASTER,\r\nthis_attr->address, 1, val);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret ? ret : len;\r\n}\r\nstatic irqreturn_t ad7280_event_handler(int irq, void *private)\r\n{\r\nstruct iio_dev *indio_dev = private;\r\nstruct ad7280_state *st = iio_priv(indio_dev);\r\nunsigned *channels;\r\nint i, ret;\r\nchannels = kcalloc(st->scan_cnt, sizeof(*channels), GFP_KERNEL);\r\nif (channels == NULL)\r\nreturn IRQ_HANDLED;\r\nret = ad7280_read_all_channels(st, st->scan_cnt, channels);\r\nif (ret < 0)\r\ngoto out;\r\nfor (i = 0; i < st->scan_cnt; i++) {\r\nif (((channels[i] >> 23) & 0xF) <= AD7280A_CELL_VOLTAGE_6) {\r\nif (((channels[i] >> 11) & 0xFFF) >=\r\nst->cell_threshhigh)\r\niio_push_event(indio_dev,\r\nIIO_EVENT_CODE(IIO_VOLTAGE,\r\n1,\r\n0,\r\nIIO_EV_DIR_RISING,\r\nIIO_EV_TYPE_THRESH,\r\n0, 0, 0),\r\niio_get_time_ns());\r\nelse if (((channels[i] >> 11) & 0xFFF) <=\r\nst->cell_threshlow)\r\niio_push_event(indio_dev,\r\nIIO_EVENT_CODE(IIO_VOLTAGE,\r\n1,\r\n0,\r\nIIO_EV_DIR_FALLING,\r\nIIO_EV_TYPE_THRESH,\r\n0, 0, 0),\r\niio_get_time_ns());\r\n} else {\r\nif (((channels[i] >> 11) & 0xFFF) >= st->aux_threshhigh)\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(IIO_TEMP,\r\n0,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_RISING),\r\niio_get_time_ns());\r\nelse if (((channels[i] >> 11) & 0xFFF) <=\r\nst->aux_threshlow)\r\niio_push_event(indio_dev,\r\nIIO_UNMOD_EVENT_CODE(IIO_TEMP,\r\n0,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_FALLING),\r\niio_get_time_ns());\r\n}\r\n}\r\nout:\r\nkfree(channels);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ad7280_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong m)\r\n{\r\nstruct ad7280_state *st = iio_priv(indio_dev);\r\nunsigned int scale_uv;\r\nint ret;\r\nswitch (m) {\r\ncase 0:\r\nmutex_lock(&indio_dev->mlock);\r\nif (chan->address == AD7280A_ALL_CELLS)\r\nret = ad7280_read_all_channels(st, st->scan_cnt, NULL);\r\nelse\r\nret = ad7280_read_channel(st, chan->address >> 8,\r\nchan->address & 0xFF);\r\nmutex_unlock(&indio_dev->mlock);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nif ((chan->address & 0xFF) <= AD7280A_CELL_VOLTAGE_6)\r\nscale_uv = (4000 * 1000) >> AD7280A_BITS;\r\nelse\r\nscale_uv = (5000 * 1000) >> AD7280A_BITS;\r\n*val = scale_uv / 1000;\r\n*val2 = (scale_uv % 1000) * 1000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int __devinit ad7280_probe(struct spi_device *spi)\r\n{\r\nconst struct ad7280_platform_data *pdata = spi->dev.platform_data;\r\nstruct ad7280_state *st;\r\nint ret;\r\nconst unsigned short tACQ_ns[4] = {465, 1010, 1460, 1890};\r\nconst unsigned short nAVG[4] = {1, 2, 4, 8};\r\nstruct iio_dev *indio_dev = iio_allocate_device(sizeof(*st));\r\nif (indio_dev == NULL)\r\nreturn -ENOMEM;\r\nst = iio_priv(indio_dev);\r\nspi_set_drvdata(spi, indio_dev);\r\nst->spi = spi;\r\nif (!pdata)\r\npdata = &ad7793_default_pdata;\r\nad7280_crc8_build_table(st->crc_tab);\r\nst->spi->max_speed_hz = AD7280A_MAX_SPI_CLK_Hz;\r\nst->spi->mode = SPI_MODE_1;\r\nspi_setup(st->spi);\r\nst->ctrl_lb = AD7280A_CTRL_LB_ACQ_TIME(pdata->acquisition_time & 0x3);\r\nst->ctrl_hb = AD7280A_CTRL_HB_CONV_AVG(pdata->conversion_averaging\r\n& 0x3) | (pdata->thermistor_term_en ?\r\nAD7280A_CTRL_LB_THERMISTOR_EN : 0);\r\nret = ad7280_chain_setup(st);\r\nif (ret < 0)\r\ngoto error_free_device;\r\nst->slave_num = ret;\r\nst->scan_cnt = (st->slave_num + 1) * AD7280A_NUM_CH;\r\nst->cell_threshhigh = 0xFF;\r\nst->aux_threshhigh = 0xFF;\r\nst->readback_delay_us =\r\n((tACQ_ns[pdata->acquisition_time & 0x3] + 695) *\r\n(AD7280A_NUM_CH * nAVG[pdata->conversion_averaging & 0x3]))\r\n- tACQ_ns[pdata->acquisition_time & 0x3] +\r\nst->slave_num * 250;\r\nst->readback_delay_us = DIV_ROUND_UP(st->readback_delay_us, 1000);\r\nst->readback_delay_us += 5;\r\nindio_dev->name = spi_get_device_id(spi)->name;\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nret = ad7280_channel_init(st);\r\nif (ret < 0)\r\ngoto error_free_device;\r\nindio_dev->num_channels = ret;\r\nindio_dev->channels = st->channels;\r\nindio_dev->info = &ad7280_info;\r\nret = ad7280_attr_init(st);\r\nif (ret < 0)\r\ngoto error_free_channels;\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_free_attr;\r\nif (spi->irq > 0) {\r\nret = ad7280_write(st, AD7280A_DEVADDR_MASTER,\r\nAD7280A_ALERT, 1,\r\nAD7280A_ALERT_RELAY_SIG_CHAIN_DOWN);\r\nif (ret)\r\ngoto error_unregister;\r\nret = ad7280_write(st, AD7280A_DEVADDR(st->slave_num),\r\nAD7280A_ALERT, 0,\r\nAD7280A_ALERT_GEN_STATIC_HIGH |\r\n(pdata->chain_last_alert_ignore & 0xF));\r\nif (ret)\r\ngoto error_unregister;\r\nret = request_threaded_irq(spi->irq,\r\nNULL,\r\nad7280_event_handler,\r\nIRQF_TRIGGER_FALLING |\r\nIRQF_ONESHOT,\r\nindio_dev->name,\r\nindio_dev);\r\nif (ret)\r\ngoto error_unregister;\r\n}\r\nreturn 0;\r\nerror_unregister:\r\niio_device_unregister(indio_dev);\r\nerror_free_attr:\r\nkfree(st->iio_attr);\r\nerror_free_channels:\r\nkfree(st->channels);\r\nerror_free_device:\r\niio_free_device(indio_dev);\r\nreturn ret;\r\n}\r\nstatic int __devexit ad7280_remove(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev = spi_get_drvdata(spi);\r\nstruct ad7280_state *st = iio_priv(indio_dev);\r\nif (spi->irq > 0)\r\nfree_irq(spi->irq, indio_dev);\r\niio_device_unregister(indio_dev);\r\nad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_HB, 1,\r\nAD7280A_CTRL_HB_PWRDN_SW | st->ctrl_hb);\r\nkfree(st->channels);\r\nkfree(st->iio_attr);\r\niio_free_device(indio_dev);\r\nreturn 0;\r\n}
