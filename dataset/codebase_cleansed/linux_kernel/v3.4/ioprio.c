int set_task_ioprio(struct task_struct *task, int ioprio)\r\n{\r\nint err;\r\nstruct io_context *ioc;\r\nconst struct cred *cred = current_cred(), *tcred;\r\nrcu_read_lock();\r\ntcred = __task_cred(task);\r\nif (tcred->uid != cred->euid &&\r\ntcred->uid != cred->uid && !capable(CAP_SYS_NICE)) {\r\nrcu_read_unlock();\r\nreturn -EPERM;\r\n}\r\nrcu_read_unlock();\r\nerr = security_task_setioprio(task, ioprio);\r\nif (err)\r\nreturn err;\r\nioc = get_task_io_context(task, GFP_ATOMIC, NUMA_NO_NODE);\r\nif (ioc) {\r\nioc_ioprio_changed(ioc, ioprio);\r\nput_io_context(ioc);\r\n}\r\nreturn err;\r\n}\r\nstatic int get_task_ioprio(struct task_struct *p)\r\n{\r\nint ret;\r\nret = security_task_getioprio(p);\r\nif (ret)\r\ngoto out;\r\nret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM);\r\nif (p->io_context)\r\nret = p->io_context->ioprio;\r\nout:\r\nreturn ret;\r\n}\r\nint ioprio_best(unsigned short aprio, unsigned short bprio)\r\n{\r\nunsigned short aclass = IOPRIO_PRIO_CLASS(aprio);\r\nunsigned short bclass = IOPRIO_PRIO_CLASS(bprio);\r\nif (aclass == IOPRIO_CLASS_NONE)\r\naclass = IOPRIO_CLASS_BE;\r\nif (bclass == IOPRIO_CLASS_NONE)\r\nbclass = IOPRIO_CLASS_BE;\r\nif (aclass == bclass)\r\nreturn min(aprio, bprio);\r\nif (aclass > bclass)\r\nreturn bprio;\r\nelse\r\nreturn aprio;\r\n}
