static inline u32 pm2_RD(struct pm2fb_par *p, s32 off)\r\n{\r\nreturn fb_readl(p->v_regs + off);\r\n}\r\nstatic inline void pm2_WR(struct pm2fb_par *p, s32 off, u32 v)\r\n{\r\nfb_writel(v, p->v_regs + off);\r\n}\r\nstatic inline u32 pm2_RDAC_RD(struct pm2fb_par *p, s32 idx)\r\n{\r\npm2_WR(p, PM2R_RD_PALETTE_WRITE_ADDRESS, idx);\r\nmb();\r\nreturn pm2_RD(p, PM2R_RD_INDEXED_DATA);\r\n}\r\nstatic inline u32 pm2v_RDAC_RD(struct pm2fb_par *p, s32 idx)\r\n{\r\npm2_WR(p, PM2VR_RD_INDEX_LOW, idx & 0xff);\r\nmb();\r\nreturn pm2_RD(p, PM2VR_RD_INDEXED_DATA);\r\n}\r\nstatic inline void pm2_RDAC_WR(struct pm2fb_par *p, s32 idx, u32 v)\r\n{\r\npm2_WR(p, PM2R_RD_PALETTE_WRITE_ADDRESS, idx);\r\nwmb();\r\npm2_WR(p, PM2R_RD_INDEXED_DATA, v);\r\nwmb();\r\n}\r\nstatic inline void pm2v_RDAC_WR(struct pm2fb_par *p, s32 idx, u32 v)\r\n{\r\npm2_WR(p, PM2VR_RD_INDEX_LOW, idx & 0xff);\r\nwmb();\r\npm2_WR(p, PM2VR_RD_INDEXED_DATA, v);\r\nwmb();\r\n}\r\nstatic inline void WAIT_FIFO(struct pm2fb_par *p, u32 a)\r\n{\r\nwhile (pm2_RD(p, PM2R_IN_FIFO_SPACE) < a)\r\ncpu_relax();\r\n}\r\nstatic u32 partprod(u32 xres)\r\n{\r\nint i;\r\nfor (i = 0; pp_table[i].width && pp_table[i].width != xres; i++)\r\n;\r\nif (pp_table[i].width == 0)\r\nDPRINTK("invalid width %u\n", xres);\r\nreturn pp_table[i].pp;\r\n}\r\nstatic u32 to3264(u32 timing, int bpp, int is64)\r\n{\r\nswitch (bpp) {\r\ncase 24:\r\ntiming *= 3;\r\ncase 8:\r\ntiming >>= 1;\r\ncase 16:\r\ntiming >>= 1;\r\ncase 32:\r\nbreak;\r\n}\r\nif (is64)\r\ntiming >>= 1;\r\nreturn timing;\r\n}\r\nstatic void pm2_mnp(u32 clk, unsigned char *mm, unsigned char *nn,\r\nunsigned char *pp)\r\n{\r\nunsigned char m;\r\nunsigned char n;\r\nunsigned char p;\r\nu32 f;\r\ns32 curr;\r\ns32 delta = 100000;\r\n*mm = *nn = *pp = 0;\r\nfor (n = 2; n < 15; n++) {\r\nfor (m = 2; m; m++) {\r\nf = PM2_REFERENCE_CLOCK * m / n;\r\nif (f >= 150000 && f <= 300000) {\r\nfor (p = 0; p < 5; p++, f >>= 1) {\r\ncurr = (clk > f) ? clk - f : f - clk;\r\nif (curr < delta) {\r\ndelta = curr;\r\n*mm = m;\r\n*nn = n;\r\n*pp = p;\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void pm2v_mnp(u32 clk, unsigned char *mm, unsigned char *nn,\r\nunsigned char *pp)\r\n{\r\nunsigned char m;\r\nunsigned char n;\r\nunsigned char p;\r\nu32 f;\r\ns32 delta = 1000;\r\n*mm = *nn = *pp = 0;\r\nfor (m = 1; m < 128; m++) {\r\nfor (n = 2 * m + 1; n; n++) {\r\nfor (p = 0; p < 2; p++) {\r\nf = (PM2_REFERENCE_CLOCK >> (p + 1)) * n / m;\r\nif (clk > f - delta && clk < f + delta) {\r\ndelta = (clk > f) ? clk - f : f - clk;\r\n*mm = m;\r\n*nn = n;\r\n*pp = p;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void clear_palette(struct pm2fb_par *p)\r\n{\r\nint i = 256;\r\nWAIT_FIFO(p, 1);\r\npm2_WR(p, PM2R_RD_PALETTE_WRITE_ADDRESS, 0);\r\nwmb();\r\nwhile (i--) {\r\nWAIT_FIFO(p, 3);\r\npm2_WR(p, PM2R_RD_PALETTE_DATA, 0);\r\npm2_WR(p, PM2R_RD_PALETTE_DATA, 0);\r\npm2_WR(p, PM2R_RD_PALETTE_DATA, 0);\r\n}\r\n}\r\nstatic void reset_card(struct pm2fb_par *p)\r\n{\r\nif (p->type == PM2_TYPE_PERMEDIA2V)\r\npm2_WR(p, PM2VR_RD_INDEX_HIGH, 0);\r\npm2_WR(p, PM2R_RESET_STATUS, 0);\r\nmb();\r\nwhile (pm2_RD(p, PM2R_RESET_STATUS) & PM2F_BEING_RESET)\r\ncpu_relax();\r\nmb();\r\n#ifdef CONFIG_FB_PM2_FIFO_DISCONNECT\r\nDPRINTK("FIFO disconnect enabled\n");\r\npm2_WR(p, PM2R_FIFO_DISCON, 1);\r\nmb();\r\n#endif\r\nWAIT_FIFO(p, 3);\r\npm2_WR(p, PM2R_MEM_CONTROL, p->mem_control);\r\npm2_WR(p, PM2R_BOOT_ADDRESS, p->boot_address);\r\nwmb();\r\npm2_WR(p, PM2R_MEM_CONFIG, p->mem_config);\r\n}\r\nstatic void reset_config(struct pm2fb_par *p)\r\n{\r\nWAIT_FIFO(p, 53);\r\npm2_WR(p, PM2R_CHIP_CONFIG, pm2_RD(p, PM2R_CHIP_CONFIG) &\r\n~(PM2F_VGA_ENABLE | PM2F_VGA_FIXED));\r\npm2_WR(p, PM2R_BYPASS_WRITE_MASK, ~(0L));\r\npm2_WR(p, PM2R_FRAMEBUFFER_WRITE_MASK, ~(0L));\r\npm2_WR(p, PM2R_FIFO_CONTROL, 0);\r\npm2_WR(p, PM2R_APERTURE_ONE, 0);\r\npm2_WR(p, PM2R_APERTURE_TWO, 0);\r\npm2_WR(p, PM2R_RASTERIZER_MODE, 0);\r\npm2_WR(p, PM2R_DELTA_MODE, PM2F_DELTA_ORDER_RGB);\r\npm2_WR(p, PM2R_LB_READ_FORMAT, 0);\r\npm2_WR(p, PM2R_LB_WRITE_FORMAT, 0);\r\npm2_WR(p, PM2R_LB_READ_MODE, 0);\r\npm2_WR(p, PM2R_LB_SOURCE_OFFSET, 0);\r\npm2_WR(p, PM2R_FB_SOURCE_OFFSET, 0);\r\npm2_WR(p, PM2R_FB_PIXEL_OFFSET, 0);\r\npm2_WR(p, PM2R_FB_WINDOW_BASE, 0);\r\npm2_WR(p, PM2R_LB_WINDOW_BASE, 0);\r\npm2_WR(p, PM2R_FB_SOFT_WRITE_MASK, ~(0L));\r\npm2_WR(p, PM2R_FB_HARD_WRITE_MASK, ~(0L));\r\npm2_WR(p, PM2R_FB_READ_PIXEL, 0);\r\npm2_WR(p, PM2R_DITHER_MODE, 0);\r\npm2_WR(p, PM2R_AREA_STIPPLE_MODE, 0);\r\npm2_WR(p, PM2R_DEPTH_MODE, 0);\r\npm2_WR(p, PM2R_STENCIL_MODE, 0);\r\npm2_WR(p, PM2R_TEXTURE_ADDRESS_MODE, 0);\r\npm2_WR(p, PM2R_TEXTURE_READ_MODE, 0);\r\npm2_WR(p, PM2R_TEXEL_LUT_MODE, 0);\r\npm2_WR(p, PM2R_YUV_MODE, 0);\r\npm2_WR(p, PM2R_COLOR_DDA_MODE, 0);\r\npm2_WR(p, PM2R_TEXTURE_COLOR_MODE, 0);\r\npm2_WR(p, PM2R_FOG_MODE, 0);\r\npm2_WR(p, PM2R_ALPHA_BLEND_MODE, 0);\r\npm2_WR(p, PM2R_LOGICAL_OP_MODE, 0);\r\npm2_WR(p, PM2R_STATISTICS_MODE, 0);\r\npm2_WR(p, PM2R_SCISSOR_MODE, 0);\r\npm2_WR(p, PM2R_FILTER_MODE, PM2F_SYNCHRONIZATION);\r\npm2_WR(p, PM2R_RD_PIXEL_MASK, 0xff);\r\nswitch (p->type) {\r\ncase PM2_TYPE_PERMEDIA2:\r\npm2_RDAC_WR(p, PM2I_RD_MODE_CONTROL, 0);\r\npm2_RDAC_WR(p, PM2I_RD_CURSOR_CONTROL, 0);\r\npm2_RDAC_WR(p, PM2I_RD_MISC_CONTROL, PM2F_RD_PALETTE_WIDTH_8);\r\npm2_RDAC_WR(p, PM2I_RD_COLOR_KEY_CONTROL, 0);\r\npm2_RDAC_WR(p, PM2I_RD_OVERLAY_KEY, 0);\r\npm2_RDAC_WR(p, PM2I_RD_RED_KEY, 0);\r\npm2_RDAC_WR(p, PM2I_RD_GREEN_KEY, 0);\r\npm2_RDAC_WR(p, PM2I_RD_BLUE_KEY, 0);\r\nbreak;\r\ncase PM2_TYPE_PERMEDIA2V:\r\npm2v_RDAC_WR(p, PM2VI_RD_MISC_CONTROL, 1);\r\nbreak;\r\n}\r\n}\r\nstatic void set_aperture(struct pm2fb_par *p, u32 depth)\r\n{\r\nWAIT_FIFO(p, 2);\r\n#ifdef __LITTLE_ENDIAN\r\npm2_WR(p, PM2R_APERTURE_ONE, PM2F_APERTURE_STANDARD);\r\n#else\r\nswitch (depth) {\r\ncase 24:\r\ncase 8:\r\npm2_WR(p, PM2R_APERTURE_ONE, PM2F_APERTURE_STANDARD);\r\nbreak;\r\ncase 16:\r\npm2_WR(p, PM2R_APERTURE_ONE, PM2F_APERTURE_HALFWORDSWAP);\r\nbreak;\r\ncase 32:\r\npm2_WR(p, PM2R_APERTURE_ONE, PM2F_APERTURE_BYTESWAP);\r\nbreak;\r\n}\r\n#endif\r\npm2_WR(p, PM2R_APERTURE_TWO, PM2F_APERTURE_STANDARD);\r\n}\r\nstatic void set_color(struct pm2fb_par *p, unsigned char regno,\r\nunsigned char r, unsigned char g, unsigned char b)\r\n{\r\nWAIT_FIFO(p, 4);\r\npm2_WR(p, PM2R_RD_PALETTE_WRITE_ADDRESS, regno);\r\nwmb();\r\npm2_WR(p, PM2R_RD_PALETTE_DATA, r);\r\nwmb();\r\npm2_WR(p, PM2R_RD_PALETTE_DATA, g);\r\nwmb();\r\npm2_WR(p, PM2R_RD_PALETTE_DATA, b);\r\n}\r\nstatic void set_memclock(struct pm2fb_par *par, u32 clk)\r\n{\r\nint i;\r\nunsigned char m, n, p;\r\nswitch (par->type) {\r\ncase PM2_TYPE_PERMEDIA2V:\r\npm2v_mnp(clk/2, &m, &n, &p);\r\nWAIT_FIFO(par, 12);\r\npm2_WR(par, PM2VR_RD_INDEX_HIGH, PM2VI_RD_MCLK_CONTROL >> 8);\r\npm2v_RDAC_WR(par, PM2VI_RD_MCLK_CONTROL, 0);\r\npm2v_RDAC_WR(par, PM2VI_RD_MCLK_PRESCALE, m);\r\npm2v_RDAC_WR(par, PM2VI_RD_MCLK_FEEDBACK, n);\r\npm2v_RDAC_WR(par, PM2VI_RD_MCLK_POSTSCALE, p);\r\npm2v_RDAC_WR(par, PM2VI_RD_MCLK_CONTROL, 1);\r\nrmb();\r\nfor (i = 256; i; i--)\r\nif (pm2v_RDAC_RD(par, PM2VI_RD_MCLK_CONTROL) & 2)\r\nbreak;\r\npm2_WR(par, PM2VR_RD_INDEX_HIGH, 0);\r\nbreak;\r\ncase PM2_TYPE_PERMEDIA2:\r\npm2_mnp(clk, &m, &n, &p);\r\nWAIT_FIFO(par, 10);\r\npm2_RDAC_WR(par, PM2I_RD_MEMORY_CLOCK_3, 6);\r\npm2_RDAC_WR(par, PM2I_RD_MEMORY_CLOCK_1, m);\r\npm2_RDAC_WR(par, PM2I_RD_MEMORY_CLOCK_2, n);\r\npm2_RDAC_WR(par, PM2I_RD_MEMORY_CLOCK_3, 8|p);\r\npm2_RDAC_RD(par, PM2I_RD_MEMORY_CLOCK_STATUS);\r\nrmb();\r\nfor (i = 256; i; i--)\r\nif (pm2_RD(par, PM2R_RD_INDEXED_DATA) & PM2F_PLL_LOCKED)\r\nbreak;\r\nbreak;\r\n}\r\n}\r\nstatic void set_pixclock(struct pm2fb_par *par, u32 clk)\r\n{\r\nint i;\r\nunsigned char m, n, p;\r\nswitch (par->type) {\r\ncase PM2_TYPE_PERMEDIA2:\r\npm2_mnp(clk, &m, &n, &p);\r\nWAIT_FIFO(par, 10);\r\npm2_RDAC_WR(par, PM2I_RD_PIXEL_CLOCK_A3, 0);\r\npm2_RDAC_WR(par, PM2I_RD_PIXEL_CLOCK_A1, m);\r\npm2_RDAC_WR(par, PM2I_RD_PIXEL_CLOCK_A2, n);\r\npm2_RDAC_WR(par, PM2I_RD_PIXEL_CLOCK_A3, 8|p);\r\npm2_RDAC_RD(par, PM2I_RD_PIXEL_CLOCK_STATUS);\r\nrmb();\r\nfor (i = 256; i; i--)\r\nif (pm2_RD(par, PM2R_RD_INDEXED_DATA) & PM2F_PLL_LOCKED)\r\nbreak;\r\nbreak;\r\ncase PM2_TYPE_PERMEDIA2V:\r\npm2v_mnp(clk/2, &m, &n, &p);\r\nWAIT_FIFO(par, 8);\r\npm2_WR(par, PM2VR_RD_INDEX_HIGH, PM2VI_RD_CLK0_PRESCALE >> 8);\r\npm2v_RDAC_WR(par, PM2VI_RD_CLK0_PRESCALE, m);\r\npm2v_RDAC_WR(par, PM2VI_RD_CLK0_FEEDBACK, n);\r\npm2v_RDAC_WR(par, PM2VI_RD_CLK0_POSTSCALE, p);\r\npm2_WR(par, PM2VR_RD_INDEX_HIGH, 0);\r\nbreak;\r\n}\r\n}\r\nstatic void set_video(struct pm2fb_par *p, u32 video)\r\n{\r\nu32 tmp;\r\nu32 vsync = video;\r\nDPRINTK("video = 0x%x\n", video);\r\nvsync &= ~(PM2F_HSYNC_MASK | PM2F_VSYNC_MASK);\r\nvsync |= PM2F_HSYNC_ACT_HIGH | PM2F_VSYNC_ACT_HIGH;\r\nWAIT_FIFO(p, 3);\r\npm2_WR(p, PM2R_VIDEO_CONTROL, vsync);\r\nswitch (p->type) {\r\ncase PM2_TYPE_PERMEDIA2:\r\ntmp = PM2F_RD_PALETTE_WIDTH_8;\r\nif ((video & PM2F_HSYNC_MASK) == PM2F_HSYNC_ACT_LOW)\r\ntmp |= 4;\r\nif ((video & PM2F_VSYNC_MASK) == PM2F_VSYNC_ACT_LOW)\r\ntmp |= 8;\r\npm2_RDAC_WR(p, PM2I_RD_MISC_CONTROL, tmp);\r\nbreak;\r\ncase PM2_TYPE_PERMEDIA2V:\r\ntmp = 0;\r\nif ((video & PM2F_HSYNC_MASK) == PM2F_HSYNC_ACT_LOW)\r\ntmp |= 1;\r\nif ((video & PM2F_VSYNC_MASK) == PM2F_VSYNC_ACT_LOW)\r\ntmp |= 4;\r\npm2v_RDAC_WR(p, PM2VI_RD_SYNC_CONTROL, tmp);\r\nbreak;\r\n}\r\n}\r\nstatic int pm2fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nu32 lpitch;\r\nif (var->bits_per_pixel != 8 && var->bits_per_pixel != 16 &&\r\nvar->bits_per_pixel != 24 && var->bits_per_pixel != 32) {\r\nDPRINTK("depth not supported: %u\n", var->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nif (var->xres != var->xres_virtual) {\r\nDPRINTK("virtual x resolution != "\r\n"physical x resolution not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (var->yres > var->yres_virtual) {\r\nDPRINTK("virtual y resolution < "\r\n"physical y resolution not possible\n");\r\nreturn -EINVAL;\r\n}\r\nif (var->yres_virtual > 2047) {\r\nvar->yres_virtual = 2047;\r\n}\r\nif (var->xoffset) {\r\nDPRINTK("xoffset not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif ((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {\r\nDPRINTK("interlace not supported\n");\r\nreturn -EINVAL;\r\n}\r\nvar->xres = (var->xres + 15) & ~15;\r\nlpitch = var->xres * ((var->bits_per_pixel + 7) >> 3);\r\nif (var->xres < 320 || var->xres > 1600) {\r\nDPRINTK("width not supported: %u\n", var->xres);\r\nreturn -EINVAL;\r\n}\r\nif (var->yres < 200 || var->yres > 1200) {\r\nDPRINTK("height not supported: %u\n", var->yres);\r\nreturn -EINVAL;\r\n}\r\nif (lpitch * var->yres_virtual > info->fix.smem_len) {\r\nDPRINTK("no memory for screen (%ux%ux%u)\n",\r\nvar->xres, var->yres_virtual, var->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nif (PICOS2KHZ(var->pixclock) > PM2_MAX_PIXCLOCK) {\r\nDPRINTK("pixclock too high (%ldKHz)\n",\r\nPICOS2KHZ(var->pixclock));\r\nreturn -EINVAL;\r\n}\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nbreak;\r\ncase 16:\r\nvar->red.offset = 11;\r\nvar->red.length = 5;\r\nvar->green.offset = 5;\r\nvar->green.length = 6;\r\nvar->blue.offset = 0;\r\nvar->blue.length = 5;\r\nbreak;\r\ncase 32:\r\nvar->transp.offset = 24;\r\nvar->transp.length = 8;\r\nvar->red.offset = 16;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 0;\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nbreak;\r\ncase 24:\r\n#ifdef __BIG_ENDIAN\r\nvar->red.offset = 0;\r\nvar->blue.offset = 16;\r\n#else\r\nvar->red.offset = 16;\r\nvar->blue.offset = 0;\r\n#endif\r\nvar->green.offset = 8;\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nbreak;\r\n}\r\nvar->height = -1;\r\nvar->width = -1;\r\nvar->accel_flags = 0;\r\nDPRINTK("Checking graphics mode at %dx%d depth %d\n",\r\nvar->xres, var->yres, var->bits_per_pixel);\r\nreturn 0;\r\n}\r\nstatic int pm2fb_set_par(struct fb_info *info)\r\n{\r\nstruct pm2fb_par *par = info->par;\r\nu32 pixclock;\r\nu32 width = (info->var.xres_virtual + 7) & ~7;\r\nu32 height = info->var.yres_virtual;\r\nu32 depth = (info->var.bits_per_pixel + 7) & ~7;\r\nu32 hsstart, hsend, hbend, htotal;\r\nu32 vsstart, vsend, vbend, vtotal;\r\nu32 stride;\r\nu32 base;\r\nu32 video = 0;\r\nu32 clrmode = PM2F_RD_COLOR_MODE_RGB | PM2F_RD_GUI_ACTIVE;\r\nu32 txtmap = 0;\r\nu32 pixsize = 0;\r\nu32 clrformat = 0;\r\nu32 misc = 1;\r\nu32 xres = (info->var.xres + 31) & ~31;\r\nint data64;\r\nreset_card(par);\r\nreset_config(par);\r\nclear_palette(par);\r\nif (par->memclock)\r\nset_memclock(par, par->memclock);\r\ndepth = (depth > 32) ? 32 : depth;\r\ndata64 = depth > 8 || par->type == PM2_TYPE_PERMEDIA2V;\r\npixclock = PICOS2KHZ(info->var.pixclock);\r\nif (pixclock > PM2_MAX_PIXCLOCK) {\r\nDPRINTK("pixclock too high (%uKHz)\n", pixclock);\r\nreturn -EINVAL;\r\n}\r\nhsstart = to3264(info->var.right_margin, depth, data64);\r\nhsend = hsstart + to3264(info->var.hsync_len, depth, data64);\r\nhbend = hsend + to3264(info->var.left_margin, depth, data64);\r\nhtotal = to3264(xres, depth, data64) + hbend - 1;\r\nvsstart = (info->var.lower_margin)\r\n? info->var.lower_margin - 1\r\n: 0;\r\nvsend = info->var.lower_margin + info->var.vsync_len - 1;\r\nvbend = info->var.lower_margin + info->var.vsync_len +\r\ninfo->var.upper_margin;\r\nvtotal = info->var.yres + vbend - 1;\r\nstride = to3264(width, depth, 1);\r\nbase = to3264(info->var.yoffset * xres + info->var.xoffset, depth, 1);\r\nif (data64)\r\nvideo |= PM2F_DATA_64_ENABLE;\r\nif (info->var.sync & FB_SYNC_HOR_HIGH_ACT) {\r\nif (lowhsync) {\r\nDPRINTK("ignoring +hsync, using -hsync.\n");\r\nvideo |= PM2F_HSYNC_ACT_LOW;\r\n} else\r\nvideo |= PM2F_HSYNC_ACT_HIGH;\r\n} else\r\nvideo |= PM2F_HSYNC_ACT_LOW;\r\nif (info->var.sync & FB_SYNC_VERT_HIGH_ACT) {\r\nif (lowvsync) {\r\nDPRINTK("ignoring +vsync, using -vsync.\n");\r\nvideo |= PM2F_VSYNC_ACT_LOW;\r\n} else\r\nvideo |= PM2F_VSYNC_ACT_HIGH;\r\n} else\r\nvideo |= PM2F_VSYNC_ACT_LOW;\r\nif ((info->var.vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {\r\nDPRINTK("interlaced not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif ((info->var.vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE)\r\nvideo |= PM2F_LINE_DOUBLE;\r\nif ((info->var.activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW)\r\nvideo |= PM2F_VIDEO_ENABLE;\r\npar->video = video;\r\ninfo->fix.visual =\r\n(depth == 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\r\ninfo->fix.line_length = info->var.xres * depth / 8;\r\ninfo->cmap.len = 256;\r\nif (par->type == PM2_TYPE_PERMEDIA2V) {\r\nWAIT_FIFO(par, 1);\r\npm2_WR(par, PM2VR_RD_INDEX_HIGH, 0);\r\n}\r\nset_aperture(par, depth);\r\nmb();\r\nWAIT_FIFO(par, 19);\r\nswitch (depth) {\r\ncase 8:\r\npm2_WR(par, PM2R_FB_READ_PIXEL, 0);\r\nclrformat = 0x2e;\r\nbreak;\r\ncase 16:\r\npm2_WR(par, PM2R_FB_READ_PIXEL, 1);\r\nclrmode |= PM2F_RD_TRUECOLOR | PM2F_RD_PIXELFORMAT_RGB565;\r\ntxtmap = PM2F_TEXTEL_SIZE_16;\r\npixsize = 1;\r\nclrformat = 0x70;\r\nmisc |= 8;\r\nbreak;\r\ncase 32:\r\npm2_WR(par, PM2R_FB_READ_PIXEL, 2);\r\nclrmode |= PM2F_RD_TRUECOLOR | PM2F_RD_PIXELFORMAT_RGBA8888;\r\ntxtmap = PM2F_TEXTEL_SIZE_32;\r\npixsize = 2;\r\nclrformat = 0x20;\r\nmisc |= 8;\r\nbreak;\r\ncase 24:\r\npm2_WR(par, PM2R_FB_READ_PIXEL, 4);\r\nclrmode |= PM2F_RD_TRUECOLOR | PM2F_RD_PIXELFORMAT_RGB888;\r\ntxtmap = PM2F_TEXTEL_SIZE_24;\r\npixsize = 4;\r\nclrformat = 0x20;\r\nmisc |= 8;\r\nbreak;\r\n}\r\npm2_WR(par, PM2R_FB_WRITE_MODE, PM2F_FB_WRITE_ENABLE);\r\npm2_WR(par, PM2R_FB_READ_MODE, partprod(xres));\r\npm2_WR(par, PM2R_LB_READ_MODE, partprod(xres));\r\npm2_WR(par, PM2R_TEXTURE_MAP_FORMAT, txtmap | partprod(xres));\r\npm2_WR(par, PM2R_H_TOTAL, htotal);\r\npm2_WR(par, PM2R_HS_START, hsstart);\r\npm2_WR(par, PM2R_HS_END, hsend);\r\npm2_WR(par, PM2R_HG_END, hbend);\r\npm2_WR(par, PM2R_HB_END, hbend);\r\npm2_WR(par, PM2R_V_TOTAL, vtotal);\r\npm2_WR(par, PM2R_VS_START, vsstart);\r\npm2_WR(par, PM2R_VS_END, vsend);\r\npm2_WR(par, PM2R_VB_END, vbend);\r\npm2_WR(par, PM2R_SCREEN_STRIDE, stride);\r\nwmb();\r\npm2_WR(par, PM2R_WINDOW_ORIGIN, 0);\r\npm2_WR(par, PM2R_SCREEN_SIZE, (height << 16) | width);\r\npm2_WR(par, PM2R_SCISSOR_MODE, PM2F_SCREEN_SCISSOR_ENABLE);\r\nwmb();\r\npm2_WR(par, PM2R_SCREEN_BASE, base);\r\nwmb();\r\nset_video(par, video);\r\nWAIT_FIFO(par, 10);\r\nswitch (par->type) {\r\ncase PM2_TYPE_PERMEDIA2:\r\npm2_RDAC_WR(par, PM2I_RD_COLOR_MODE, clrmode);\r\npm2_RDAC_WR(par, PM2I_RD_COLOR_KEY_CONTROL,\r\n(depth == 8) ? 0 : PM2F_COLOR_KEY_TEST_OFF);\r\nbreak;\r\ncase PM2_TYPE_PERMEDIA2V:\r\npm2v_RDAC_WR(par, PM2VI_RD_DAC_CONTROL, 0);\r\npm2v_RDAC_WR(par, PM2VI_RD_PIXEL_SIZE, pixsize);\r\npm2v_RDAC_WR(par, PM2VI_RD_COLOR_FORMAT, clrformat);\r\npm2v_RDAC_WR(par, PM2VI_RD_MISC_CONTROL, misc);\r\npm2v_RDAC_WR(par, PM2VI_RD_OVERLAY_KEY, 0);\r\nbreak;\r\n}\r\nset_pixclock(par, pixclock);\r\nDPRINTK("Setting graphics mode at %dx%d depth %d\n",\r\ninfo->var.xres, info->var.yres, info->var.bits_per_pixel);\r\nreturn 0;\r\n}\r\nstatic int pm2fb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nstruct pm2fb_par *par = info->par;\r\nif (regno >= info->cmap.len)\r\nreturn -EINVAL;\r\nif (info->var.grayscale)\r\nred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\r\n#define CNVT_TOHW(val, width) ((((val) << (width)) + 0x7FFF -(val)) >> 16)\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nred = CNVT_TOHW(red, info->var.red.length);\r\ngreen = CNVT_TOHW(green, info->var.green.length);\r\nblue = CNVT_TOHW(blue, info->var.blue.length);\r\ntransp = CNVT_TOHW(transp, info->var.transp.length);\r\nbreak;\r\ncase FB_VISUAL_DIRECTCOLOR:\r\nred = CNVT_TOHW(red, 8);\r\ngreen = CNVT_TOHW(green, 8);\r\nblue = CNVT_TOHW(blue, 8);\r\ntransp = CNVT_TOHW(transp, 8);\r\nbreak;\r\n}\r\n#undef CNVT_TOHW\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\r\nu32 v;\r\nif (regno >= 16)\r\nreturn -EINVAL;\r\nv = (red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset) |\r\n(transp << info->var.transp.offset);\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\nbreak;\r\ncase 16:\r\ncase 24:\r\ncase 32:\r\npar->palette[regno] = v;\r\nbreak;\r\n}\r\nreturn 0;\r\n} else if (info->fix.visual == FB_VISUAL_PSEUDOCOLOR)\r\nset_color(par, regno, red, green, blue);\r\nreturn 0;\r\n}\r\nstatic int pm2fb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct pm2fb_par *p = info->par;\r\nu32 base;\r\nu32 depth = (info->var.bits_per_pixel + 7) & ~7;\r\nu32 xres = (info->var.xres + 31) & ~31;\r\ndepth = (depth > 32) ? 32 : depth;\r\nbase = to3264(var->yoffset * xres + var->xoffset, depth, 1);\r\nWAIT_FIFO(p, 1);\r\npm2_WR(p, PM2R_SCREEN_BASE, base);\r\nreturn 0;\r\n}\r\nstatic int pm2fb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct pm2fb_par *par = info->par;\r\nu32 video = par->video;\r\nDPRINTK("blank_mode %d\n", blank_mode);\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\nvideo |= PM2F_VIDEO_ENABLE;\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\nvideo &= ~PM2F_VIDEO_ENABLE;\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nvideo &= ~(PM2F_VSYNC_MASK | PM2F_BLANK_LOW);\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nvideo &= ~(PM2F_HSYNC_MASK | PM2F_BLANK_LOW);\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nvideo &= ~(PM2F_VSYNC_MASK | PM2F_HSYNC_MASK | PM2F_BLANK_LOW);\r\nbreak;\r\n}\r\nset_video(par, video);\r\nreturn 0;\r\n}\r\nstatic int pm2fb_sync(struct fb_info *info)\r\n{\r\nstruct pm2fb_par *par = info->par;\r\nWAIT_FIFO(par, 1);\r\npm2_WR(par, PM2R_SYNC, 0);\r\nmb();\r\ndo {\r\nwhile (pm2_RD(par, PM2R_OUT_FIFO_WORDS) == 0)\r\ncpu_relax();\r\n} while (pm2_RD(par, PM2R_OUT_FIFO) != PM2TAG(PM2R_SYNC));\r\nreturn 0;\r\n}\r\nstatic void pm2fb_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *region)\r\n{\r\nstruct pm2fb_par *par = info->par;\r\nstruct fb_fillrect modded;\r\nint vxres, vyres;\r\nu32 color = (info->fix.visual == FB_VISUAL_TRUECOLOR) ?\r\n((u32 *)info->pseudo_palette)[region->color] : region->color;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nif ((info->flags & FBINFO_HWACCEL_DISABLED) ||\r\nregion->rop != ROP_COPY ) {\r\ncfb_fillrect(info, region);\r\nreturn;\r\n}\r\nvxres = info->var.xres_virtual;\r\nvyres = info->var.yres_virtual;\r\nmemcpy(&modded, region, sizeof(struct fb_fillrect));\r\nif (!modded.width || !modded.height ||\r\nmodded.dx >= vxres || modded.dy >= vyres)\r\nreturn;\r\nif (modded.dx + modded.width > vxres)\r\nmodded.width = vxres - modded.dx;\r\nif (modded.dy + modded.height > vyres)\r\nmodded.height = vyres - modded.dy;\r\nif (info->var.bits_per_pixel == 8)\r\ncolor |= color << 8;\r\nif (info->var.bits_per_pixel <= 16)\r\ncolor |= color << 16;\r\nWAIT_FIFO(par, 3);\r\npm2_WR(par, PM2R_CONFIG, PM2F_CONFIG_FB_WRITE_ENABLE);\r\npm2_WR(par, PM2R_RECTANGLE_ORIGIN, (modded.dy << 16) | modded.dx);\r\npm2_WR(par, PM2R_RECTANGLE_SIZE, (modded.height << 16) | modded.width);\r\nif (info->var.bits_per_pixel != 24) {\r\nWAIT_FIFO(par, 2);\r\npm2_WR(par, PM2R_FB_BLOCK_COLOR, color);\r\nwmb();\r\npm2_WR(par, PM2R_RENDER,\r\nPM2F_RENDER_RECTANGLE | PM2F_RENDER_FASTFILL);\r\n} else {\r\nWAIT_FIFO(par, 4);\r\npm2_WR(par, PM2R_COLOR_DDA_MODE, 1);\r\npm2_WR(par, PM2R_CONSTANT_COLOR, color);\r\nwmb();\r\npm2_WR(par, PM2R_RENDER,\r\nPM2F_RENDER_RECTANGLE |\r\nPM2F_INCREASE_X | PM2F_INCREASE_Y );\r\npm2_WR(par, PM2R_COLOR_DDA_MODE, 0);\r\n}\r\n}\r\nstatic void pm2fb_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\nstruct pm2fb_par *par = info->par;\r\nstruct fb_copyarea modded;\r\nu32 vxres, vyres;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nif (info->flags & FBINFO_HWACCEL_DISABLED) {\r\ncfb_copyarea(info, area);\r\nreturn;\r\n}\r\nmemcpy(&modded, area, sizeof(struct fb_copyarea));\r\nvxres = info->var.xres_virtual;\r\nvyres = info->var.yres_virtual;\r\nif (!modded.width || !modded.height ||\r\nmodded.sx >= vxres || modded.sy >= vyres ||\r\nmodded.dx >= vxres || modded.dy >= vyres)\r\nreturn;\r\nif (modded.sx + modded.width > vxres)\r\nmodded.width = vxres - modded.sx;\r\nif (modded.dx + modded.width > vxres)\r\nmodded.width = vxres - modded.dx;\r\nif (modded.sy + modded.height > vyres)\r\nmodded.height = vyres - modded.sy;\r\nif (modded.dy + modded.height > vyres)\r\nmodded.height = vyres - modded.dy;\r\nWAIT_FIFO(par, 5);\r\npm2_WR(par, PM2R_CONFIG, PM2F_CONFIG_FB_WRITE_ENABLE |\r\nPM2F_CONFIG_FB_READ_SOURCE_ENABLE);\r\npm2_WR(par, PM2R_FB_SOURCE_DELTA,\r\n((modded.sy - modded.dy) & 0xfff) << 16 |\r\n((modded.sx - modded.dx) & 0xfff));\r\npm2_WR(par, PM2R_RECTANGLE_ORIGIN, (modded.dy << 16) | modded.dx);\r\npm2_WR(par, PM2R_RECTANGLE_SIZE, (modded.height << 16) | modded.width);\r\nwmb();\r\npm2_WR(par, PM2R_RENDER, PM2F_RENDER_RECTANGLE |\r\n(modded.dx < modded.sx ? PM2F_INCREASE_X : 0) |\r\n(modded.dy < modded.sy ? PM2F_INCREASE_Y : 0));\r\n}\r\nstatic void pm2fb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nstruct pm2fb_par *par = info->par;\r\nu32 height = image->height;\r\nu32 fgx, bgx;\r\nconst u32 *src = (const u32 *)image->data;\r\nu32 xres = (info->var.xres + 31) & ~31;\r\nint raster_mode = 1;\r\n#ifdef __LITTLE_ENDIAN\r\nraster_mode |= 3 << 7;\r\n#endif\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nif (info->flags & FBINFO_HWACCEL_DISABLED || image->depth != 1) {\r\ncfb_imageblit(info, image);\r\nreturn;\r\n}\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nfgx = image->fg_color;\r\nbgx = image->bg_color;\r\nbreak;\r\ncase FB_VISUAL_TRUECOLOR:\r\ndefault:\r\nfgx = par->palette[image->fg_color];\r\nbgx = par->palette[image->bg_color];\r\nbreak;\r\n}\r\nif (info->var.bits_per_pixel == 8) {\r\nfgx |= fgx << 8;\r\nbgx |= bgx << 8;\r\n}\r\nif (info->var.bits_per_pixel <= 16) {\r\nfgx |= fgx << 16;\r\nbgx |= bgx << 16;\r\n}\r\nWAIT_FIFO(par, 13);\r\npm2_WR(par, PM2R_FB_READ_MODE, partprod(xres));\r\npm2_WR(par, PM2R_SCISSOR_MIN_XY,\r\n((image->dy & 0xfff) << 16) | (image->dx & 0x0fff));\r\npm2_WR(par, PM2R_SCISSOR_MAX_XY,\r\n(((image->dy + image->height) & 0x0fff) << 16) |\r\n((image->dx + image->width) & 0x0fff));\r\npm2_WR(par, PM2R_SCISSOR_MODE, 1);\r\npm2_WR(par, PM2R_LOGICAL_OP_MODE, (0x3 << 1) | 1);\r\npm2_WR(par, PM2R_RECTANGLE_ORIGIN,\r\n((image->dy & 0xfff) << 16) | (image->dx & 0x0fff));\r\npm2_WR(par, PM2R_RECTANGLE_SIZE,\r\n((image->height & 0x0fff) << 16) |\r\n((image->width) & 0x0fff));\r\nif (info->var.bits_per_pixel == 24) {\r\npm2_WR(par, PM2R_COLOR_DDA_MODE, 1);\r\npm2_WR(par, PM2R_CONSTANT_COLOR, bgx);\r\npm2_WR(par, PM2R_RENDER,\r\nPM2F_RENDER_RECTANGLE |\r\nPM2F_INCREASE_X | PM2F_INCREASE_Y);\r\npm2_WR(par, PM2R_RASTERIZER_MODE, raster_mode | (1 << 9));\r\npm2_WR(par, PM2R_CONSTANT_COLOR, fgx);\r\npm2_WR(par, PM2R_RENDER,\r\nPM2F_RENDER_RECTANGLE |\r\nPM2F_INCREASE_X | PM2F_INCREASE_Y |\r\nPM2F_RENDER_SYNC_ON_BIT_MASK);\r\n} else {\r\npm2_WR(par, PM2R_COLOR_DDA_MODE, 0);\r\npm2_WR(par, PM2R_FB_BLOCK_COLOR, bgx);\r\npm2_WR(par, PM2R_RENDER,\r\nPM2F_RENDER_RECTANGLE |\r\nPM2F_RENDER_FASTFILL |\r\nPM2F_INCREASE_X | PM2F_INCREASE_Y);\r\npm2_WR(par, PM2R_RASTERIZER_MODE, raster_mode);\r\npm2_WR(par, PM2R_FB_BLOCK_COLOR, fgx);\r\npm2_WR(par, PM2R_RENDER,\r\nPM2F_RENDER_RECTANGLE |\r\nPM2F_INCREASE_X | PM2F_INCREASE_Y |\r\nPM2F_RENDER_FASTFILL |\r\nPM2F_RENDER_SYNC_ON_BIT_MASK);\r\n}\r\nwhile (height--) {\r\nint width = ((image->width + 7) >> 3)\r\n+ info->pixmap.scan_align - 1;\r\nwidth >>= 2;\r\nWAIT_FIFO(par, width);\r\nwhile (width--) {\r\npm2_WR(par, PM2R_BIT_MASK_PATTERN, *src);\r\nsrc++;\r\n}\r\n}\r\nWAIT_FIFO(par, 3);\r\npm2_WR(par, PM2R_RASTERIZER_MODE, 0);\r\npm2_WR(par, PM2R_COLOR_DDA_MODE, 0);\r\npm2_WR(par, PM2R_SCISSOR_MODE, 0);\r\n}\r\nstatic int pm2vfb_cursor(struct fb_info *info, struct fb_cursor *cursor)\r\n{\r\nstruct pm2fb_par *par = info->par;\r\nu8 mode = PM2F_CURSORMODE_TYPE_X;\r\nint x = cursor->image.dx - info->var.xoffset;\r\nint y = cursor->image.dy - info->var.yoffset;\r\nif (cursor->enable)\r\nmode |= PM2F_CURSORMODE_CURSOR_ENABLE;\r\npm2v_RDAC_WR(par, PM2VI_RD_CURSOR_MODE, mode);\r\nif (!cursor->enable)\r\nx = 2047;\r\npm2v_RDAC_WR(par, PM2VI_RD_CURSOR_X_LOW, x & 0xff);\r\npm2v_RDAC_WR(par, PM2VI_RD_CURSOR_X_HIGH, (x >> 8) & 0xf);\r\npm2v_RDAC_WR(par, PM2VI_RD_CURSOR_Y_LOW, y & 0xff);\r\npm2v_RDAC_WR(par, PM2VI_RD_CURSOR_Y_HIGH, (y >> 8) & 0xf);\r\nif (!cursor->set)\r\nreturn 0;\r\nif (cursor->set & FB_CUR_SETHOT) {\r\npm2v_RDAC_WR(par, PM2VI_RD_CURSOR_X_HOT,\r\ncursor->hot.x & 0x3f);\r\npm2v_RDAC_WR(par, PM2VI_RD_CURSOR_Y_HOT,\r\ncursor->hot.y & 0x3f);\r\n}\r\nif (cursor->set & FB_CUR_SETCMAP) {\r\nu32 fg_idx = cursor->image.fg_color;\r\nu32 bg_idx = cursor->image.bg_color;\r\nstruct fb_cmap cmap = info->cmap;\r\npm2_WR(par, PM2VR_RD_INDEX_HIGH, PM2VI_RD_CURSOR_PALETTE >> 8);\r\npm2v_RDAC_WR(par, PM2VI_RD_CURSOR_PALETTE + 0,\r\ncmap.red[bg_idx] >> 8 );\r\npm2v_RDAC_WR(par, PM2VI_RD_CURSOR_PALETTE + 1,\r\ncmap.green[bg_idx] >> 8 );\r\npm2v_RDAC_WR(par, PM2VI_RD_CURSOR_PALETTE + 2,\r\ncmap.blue[bg_idx] >> 8 );\r\npm2v_RDAC_WR(par, PM2VI_RD_CURSOR_PALETTE + 3,\r\ncmap.red[fg_idx] >> 8 );\r\npm2v_RDAC_WR(par, PM2VI_RD_CURSOR_PALETTE + 4,\r\ncmap.green[fg_idx] >> 8 );\r\npm2v_RDAC_WR(par, PM2VI_RD_CURSOR_PALETTE + 5,\r\ncmap.blue[fg_idx] >> 8 );\r\npm2_WR(par, PM2VR_RD_INDEX_HIGH, 0);\r\n}\r\nif (cursor->set & (FB_CUR_SETSHAPE | FB_CUR_SETIMAGE)) {\r\nu8 *bitmap = (u8 *)cursor->image.data;\r\nu8 *mask = (u8 *)cursor->mask;\r\nint i;\r\nint pos = PM2VI_RD_CURSOR_PATTERN;\r\nfor (i = 0; i < cursor->image.height; i++) {\r\nint j = (cursor->image.width + 7) >> 3;\r\nint k = 8 - j;\r\npm2_WR(par, PM2VR_RD_INDEX_HIGH, pos >> 8);\r\nfor (; j > 0; j--) {\r\nu8 data = *bitmap ^ *mask;\r\nif (cursor->rop == ROP_COPY)\r\ndata = *mask & *bitmap;\r\npm2v_RDAC_WR(par, pos++,\r\ncursor_bits_lookup[data >> 4] |\r\n(cursor_bits_lookup[*mask >> 4] << 1));\r\npm2v_RDAC_WR(par, pos++,\r\ncursor_bits_lookup[data & 0xf] |\r\n(cursor_bits_lookup[*mask & 0xf] << 1));\r\nbitmap++;\r\nmask++;\r\n}\r\nfor (; k > 0; k--) {\r\npm2v_RDAC_WR(par, pos++, 0);\r\npm2v_RDAC_WR(par, pos++, 0);\r\n}\r\n}\r\nwhile (pos < (1024 + PM2VI_RD_CURSOR_PATTERN)) {\r\npm2_WR(par, PM2VR_RD_INDEX_HIGH, pos >> 8);\r\npm2v_RDAC_WR(par, pos++, 0);\r\n}\r\npm2_WR(par, PM2VR_RD_INDEX_HIGH, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm2fb_cursor(struct fb_info *info, struct fb_cursor *cursor)\r\n{\r\nstruct pm2fb_par *par = info->par;\r\nu8 mode;\r\nif (!hwcursor)\r\nreturn -EINVAL;\r\nif (cursor->image.width > 64 ||\r\ncursor->image.height > 64 ||\r\ncursor->image.depth > 1)\r\nreturn -EINVAL;\r\nif (par->type == PM2_TYPE_PERMEDIA2V)\r\nreturn pm2vfb_cursor(info, cursor);\r\nmode = 0x40;\r\nif (cursor->enable)\r\nmode = 0x43;\r\npm2_RDAC_WR(par, PM2I_RD_CURSOR_CONTROL, mode);\r\nif (!cursor->set)\r\nreturn 0;\r\nif (cursor->set & FB_CUR_SETPOS) {\r\nint x = cursor->image.dx - info->var.xoffset + 63;\r\nint y = cursor->image.dy - info->var.yoffset + 63;\r\nWAIT_FIFO(par, 4);\r\npm2_WR(par, PM2R_RD_CURSOR_X_LSB, x & 0xff);\r\npm2_WR(par, PM2R_RD_CURSOR_X_MSB, (x >> 8) & 0x7);\r\npm2_WR(par, PM2R_RD_CURSOR_Y_LSB, y & 0xff);\r\npm2_WR(par, PM2R_RD_CURSOR_Y_MSB, (y >> 8) & 0x7);\r\n}\r\nif (cursor->set & FB_CUR_SETCMAP) {\r\nu32 fg_idx = cursor->image.fg_color;\r\nu32 bg_idx = cursor->image.bg_color;\r\nWAIT_FIFO(par, 7);\r\npm2_WR(par, PM2R_RD_CURSOR_COLOR_ADDRESS, 1);\r\npm2_WR(par, PM2R_RD_CURSOR_COLOR_DATA,\r\ninfo->cmap.red[bg_idx] >> 8);\r\npm2_WR(par, PM2R_RD_CURSOR_COLOR_DATA,\r\ninfo->cmap.green[bg_idx] >> 8);\r\npm2_WR(par, PM2R_RD_CURSOR_COLOR_DATA,\r\ninfo->cmap.blue[bg_idx] >> 8);\r\npm2_WR(par, PM2R_RD_CURSOR_COLOR_DATA,\r\ninfo->cmap.red[fg_idx] >> 8);\r\npm2_WR(par, PM2R_RD_CURSOR_COLOR_DATA,\r\ninfo->cmap.green[fg_idx] >> 8);\r\npm2_WR(par, PM2R_RD_CURSOR_COLOR_DATA,\r\ninfo->cmap.blue[fg_idx] >> 8);\r\n}\r\nif (cursor->set & (FB_CUR_SETSHAPE | FB_CUR_SETIMAGE)) {\r\nu8 *bitmap = (u8 *)cursor->image.data;\r\nu8 *mask = (u8 *)cursor->mask;\r\nint i;\r\nWAIT_FIFO(par, 1);\r\npm2_WR(par, PM2R_RD_PALETTE_WRITE_ADDRESS, 0);\r\nfor (i = 0; i < cursor->image.height; i++) {\r\nint j = (cursor->image.width + 7) >> 3;\r\nint k = 8 - j;\r\nWAIT_FIFO(par, 8);\r\nfor (; j > 0; j--) {\r\nu8 data = *bitmap ^ *mask;\r\nif (cursor->rop == ROP_COPY)\r\ndata = *mask & *bitmap;\r\npm2_WR(par, PM2R_RD_CURSOR_DATA, data);\r\nbitmap++;\r\nmask++;\r\n}\r\nfor (; k > 0; k--)\r\npm2_WR(par, PM2R_RD_CURSOR_DATA, 0);\r\n}\r\nfor (; i < 64; i++) {\r\nint j = 8;\r\nWAIT_FIFO(par, 8);\r\nwhile (j-- > 0)\r\npm2_WR(par, PM2R_RD_CURSOR_DATA, 0);\r\n}\r\nmask = (u8 *)cursor->mask;\r\nfor (i = 0; i < cursor->image.height; i++) {\r\nint j = (cursor->image.width + 7) >> 3;\r\nint k = 8 - j;\r\nWAIT_FIFO(par, 8);\r\nfor (; j > 0; j--) {\r\npm2_WR(par, PM2R_RD_CURSOR_DATA, *mask);\r\nmask++;\r\n}\r\nfor (; k > 0; k--)\r\npm2_WR(par, PM2R_RD_CURSOR_DATA, 0);\r\n}\r\nfor (; i < 64; i++) {\r\nint j = 8;\r\nWAIT_FIFO(par, 8);\r\nwhile (j-- > 0)\r\npm2_WR(par, PM2R_RD_CURSOR_DATA, 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit pm2fb_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct pm2fb_par *default_par;\r\nstruct fb_info *info;\r\nint err;\r\nint retval = -ENXIO;\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\nprintk(KERN_WARNING "pm2fb: Can't enable pdev: %d\n", err);\r\nreturn err;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct pm2fb_par), &pdev->dev);\r\nif (!info)\r\nreturn -ENOMEM;\r\ndefault_par = info->par;\r\nswitch (pdev->device) {\r\ncase PCI_DEVICE_ID_TI_TVP4020:\r\nstrcpy(pm2fb_fix.id, "TVP4020");\r\ndefault_par->type = PM2_TYPE_PERMEDIA2;\r\nbreak;\r\ncase PCI_DEVICE_ID_3DLABS_PERMEDIA2:\r\nstrcpy(pm2fb_fix.id, "Permedia2");\r\ndefault_par->type = PM2_TYPE_PERMEDIA2;\r\nbreak;\r\ncase PCI_DEVICE_ID_3DLABS_PERMEDIA2V:\r\nstrcpy(pm2fb_fix.id, "Permedia2v");\r\ndefault_par->type = PM2_TYPE_PERMEDIA2V;\r\nbreak;\r\n}\r\npm2fb_fix.mmio_start = pci_resource_start(pdev, 0);\r\npm2fb_fix.mmio_len = PM2_REGS_SIZE;\r\n#if defined(__BIG_ENDIAN)\r\npm2fb_fix.mmio_start += PM2_REGS_SIZE;\r\nDPRINTK("Adjusting register base for big-endian.\n");\r\n#endif\r\nDPRINTK("Register base at 0x%lx\n", pm2fb_fix.mmio_start);\r\nif (!request_mem_region(pm2fb_fix.mmio_start, pm2fb_fix.mmio_len,\r\n"pm2fb regbase")) {\r\nprintk(KERN_WARNING "pm2fb: Can't reserve regbase.\n");\r\ngoto err_exit_neither;\r\n}\r\ndefault_par->v_regs =\r\nioremap_nocache(pm2fb_fix.mmio_start, pm2fb_fix.mmio_len);\r\nif (!default_par->v_regs) {\r\nprintk(KERN_WARNING "pm2fb: Can't remap %s register area.\n",\r\npm2fb_fix.id);\r\nrelease_mem_region(pm2fb_fix.mmio_start, pm2fb_fix.mmio_len);\r\ngoto err_exit_neither;\r\n}\r\ndefault_par->mem_control = pm2_RD(default_par, PM2R_MEM_CONTROL);\r\ndefault_par->boot_address = pm2_RD(default_par, PM2R_BOOT_ADDRESS);\r\ndefault_par->mem_config = pm2_RD(default_par, PM2R_MEM_CONFIG);\r\nDPRINTK("MemControl 0x%x BootAddress 0x%x MemConfig 0x%x\n",\r\ndefault_par->mem_control, default_par->boot_address,\r\ndefault_par->mem_config);\r\nif (default_par->mem_control == 0 &&\r\ndefault_par->boot_address == 0x31 &&\r\ndefault_par->mem_config == 0x259fffff) {\r\ndefault_par->memclock = CVPPC_MEMCLOCK;\r\ndefault_par->mem_control = 0;\r\ndefault_par->boot_address = 0x20;\r\ndefault_par->mem_config = 0xe6002021;\r\nif (pdev->subsystem_vendor == 0x1048 &&\r\npdev->subsystem_device == 0x0a31) {\r\nDPRINTK("subsystem_vendor: %04x, "\r\n"subsystem_device: %04x\n",\r\npdev->subsystem_vendor, pdev->subsystem_device);\r\nDPRINTK("We have not been initialized by VGA BIOS and "\r\n"are running on an Elsa Winner 2000 Office\n");\r\nDPRINTK("Initializing card timings manually...\n");\r\ndefault_par->memclock = 100000;\r\n}\r\nif (pdev->subsystem_vendor == 0x3d3d &&\r\npdev->subsystem_device == 0x0100) {\r\nDPRINTK("subsystem_vendor: %04x, "\r\n"subsystem_device: %04x\n",\r\npdev->subsystem_vendor, pdev->subsystem_device);\r\nDPRINTK("We have not been initialized by VGA BIOS and "\r\n"are running on an 3dlabs reference board\n");\r\nDPRINTK("Initializing card timings manually...\n");\r\ndefault_par->memclock = 74894;\r\n}\r\n}\r\nswitch (default_par->mem_config & PM2F_MEM_CONFIG_RAM_MASK) {\r\ncase PM2F_MEM_BANKS_1:\r\npm2fb_fix.smem_len = 0x200000;\r\nbreak;\r\ncase PM2F_MEM_BANKS_2:\r\npm2fb_fix.smem_len = 0x400000;\r\nbreak;\r\ncase PM2F_MEM_BANKS_3:\r\npm2fb_fix.smem_len = 0x600000;\r\nbreak;\r\ncase PM2F_MEM_BANKS_4:\r\npm2fb_fix.smem_len = 0x800000;\r\nbreak;\r\n}\r\npm2fb_fix.smem_start = pci_resource_start(pdev, 1);\r\nif (!request_mem_region(pm2fb_fix.smem_start, pm2fb_fix.smem_len,\r\n"pm2fb smem")) {\r\nprintk(KERN_WARNING "pm2fb: Can't reserve smem.\n");\r\ngoto err_exit_mmio;\r\n}\r\ninfo->screen_base =\r\nioremap_nocache(pm2fb_fix.smem_start, pm2fb_fix.smem_len);\r\nif (!info->screen_base) {\r\nprintk(KERN_WARNING "pm2fb: Can't ioremap smem area.\n");\r\nrelease_mem_region(pm2fb_fix.smem_start, pm2fb_fix.smem_len);\r\ngoto err_exit_mmio;\r\n}\r\n#ifdef CONFIG_MTRR\r\ndefault_par->mtrr_handle = -1;\r\nif (!nomtrr)\r\ndefault_par->mtrr_handle =\r\nmtrr_add(pm2fb_fix.smem_start,\r\npm2fb_fix.smem_len,\r\nMTRR_TYPE_WRCOMB, 1);\r\n#endif\r\ninfo->fbops = &pm2fb_ops;\r\ninfo->fix = pm2fb_fix;\r\ninfo->pseudo_palette = default_par->palette;\r\ninfo->flags = FBINFO_DEFAULT |\r\nFBINFO_HWACCEL_YPAN |\r\nFBINFO_HWACCEL_COPYAREA |\r\nFBINFO_HWACCEL_IMAGEBLIT |\r\nFBINFO_HWACCEL_FILLRECT;\r\ninfo->pixmap.addr = kmalloc(PM2_PIXMAP_SIZE, GFP_KERNEL);\r\nif (!info->pixmap.addr) {\r\nretval = -ENOMEM;\r\ngoto err_exit_pixmap;\r\n}\r\ninfo->pixmap.size = PM2_PIXMAP_SIZE;\r\ninfo->pixmap.buf_align = 4;\r\ninfo->pixmap.scan_align = 4;\r\ninfo->pixmap.access_align = 32;\r\ninfo->pixmap.flags = FB_PIXMAP_SYSTEM;\r\nif (noaccel) {\r\nprintk(KERN_DEBUG "disabling acceleration\n");\r\ninfo->flags |= FBINFO_HWACCEL_DISABLED;\r\ninfo->pixmap.scan_align = 1;\r\n}\r\nif (!mode_option)\r\nmode_option = "640x480@60";\r\nerr = fb_find_mode(&info->var, info, mode_option, NULL, 0, NULL, 8);\r\nif (!err || err == 4)\r\ninfo->var = pm2fb_var;\r\nretval = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (retval < 0)\r\ngoto err_exit_both;\r\nretval = register_framebuffer(info);\r\nif (retval < 0)\r\ngoto err_exit_all;\r\nprintk(KERN_INFO "fb%d: %s frame buffer device, memory = %dK.\n",\r\ninfo->node, info->fix.id, pm2fb_fix.smem_len / 1024);\r\npci_set_drvdata(pdev, info);\r\nreturn 0;\r\nerr_exit_all:\r\nfb_dealloc_cmap(&info->cmap);\r\nerr_exit_both:\r\nkfree(info->pixmap.addr);\r\nerr_exit_pixmap:\r\niounmap(info->screen_base);\r\nrelease_mem_region(pm2fb_fix.smem_start, pm2fb_fix.smem_len);\r\nerr_exit_mmio:\r\niounmap(default_par->v_regs);\r\nrelease_mem_region(pm2fb_fix.mmio_start, pm2fb_fix.mmio_len);\r\nerr_exit_neither:\r\nframebuffer_release(info);\r\nreturn retval;\r\n}\r\nstatic void __devexit pm2fb_remove(struct pci_dev *pdev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(pdev);\r\nstruct fb_fix_screeninfo *fix = &info->fix;\r\nstruct pm2fb_par *par = info->par;\r\nunregister_framebuffer(info);\r\n#ifdef CONFIG_MTRR\r\nif (par->mtrr_handle >= 0)\r\nmtrr_del(par->mtrr_handle, info->fix.smem_start,\r\ninfo->fix.smem_len);\r\n#endif\r\niounmap(info->screen_base);\r\nrelease_mem_region(fix->smem_start, fix->smem_len);\r\niounmap(par->v_regs);\r\nrelease_mem_region(fix->mmio_start, fix->mmio_len);\r\npci_set_drvdata(pdev, NULL);\r\nfb_dealloc_cmap(&info->cmap);\r\nkfree(info->pixmap.addr);\r\nframebuffer_release(info);\r\n}\r\nstatic int __init pm2fb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!*this_opt)\r\ncontinue;\r\nif (!strcmp(this_opt, "lowhsync"))\r\nlowhsync = 1;\r\nelse if (!strcmp(this_opt, "lowvsync"))\r\nlowvsync = 1;\r\nelse if (!strncmp(this_opt, "hwcursor=", 9))\r\nhwcursor = simple_strtoul(this_opt + 9, NULL, 0);\r\n#ifdef CONFIG_MTRR\r\nelse if (!strncmp(this_opt, "nomtrr", 6))\r\nnomtrr = 1;\r\n#endif\r\nelse if (!strncmp(this_opt, "noaccel", 7))\r\nnoaccel = 1;\r\nelse\r\nmode_option = this_opt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init pm2fb_init(void)\r\n{\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("pm2fb", &option))\r\nreturn -ENODEV;\r\npm2fb_setup(option);\r\n#endif\r\nreturn pci_register_driver(&pm2fb_driver);\r\n}\r\nstatic void __exit pm2fb_exit(void)\r\n{\r\npci_unregister_driver(&pm2fb_driver);\r\n}
