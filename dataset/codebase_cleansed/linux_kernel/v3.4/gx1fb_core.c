static int gx1_line_delta(int xres, int bpp)\r\n{\r\nint line_delta = xres * (bpp >> 3);\r\nif (line_delta > 2048)\r\nline_delta = 4096;\r\nelse if (line_delta > 1024)\r\nline_delta = 2048;\r\nelse\r\nline_delta = 1024;\r\nreturn line_delta;\r\n}\r\nstatic int gx1fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct geodefb_par *par = info->par;\r\nif (var->xres > 1280 || var->yres > 1024)\r\nreturn -EINVAL;\r\nif (par->panel_x && (var->xres > par->panel_x || var->yres > par->panel_y))\r\nreturn -EINVAL;\r\nif (var->bits_per_pixel == 16) {\r\nvar->red.offset = 11; var->red.length = 5;\r\nvar->green.offset = 5; var->green.length = 6;\r\nvar->blue.offset = 0; var->blue.length = 5;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\n} else if (var->bits_per_pixel == 8) {\r\nvar->red.offset = 0; var->red.length = 8;\r\nvar->green.offset = 0; var->green.length = 8;\r\nvar->blue.offset = 0; var->blue.length = 8;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\n} else\r\nreturn -EINVAL;\r\nif (gx1_line_delta(var->xres, var->bits_per_pixel) * var->yres > info->fix.smem_len)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int gx1fb_set_par(struct fb_info *info)\r\n{\r\nstruct geodefb_par *par = info->par;\r\nif (info->var.bits_per_pixel == 16)\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nelse\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\ninfo->fix.line_length = gx1_line_delta(info->var.xres, info->var.bits_per_pixel);\r\npar->dc_ops->set_mode(info);\r\nreturn 0;\r\n}\r\nstatic inline u_int chan_to_field(u_int chan, struct fb_bitfield *bf)\r\n{\r\nchan &= 0xffff;\r\nchan >>= 16 - bf->length;\r\nreturn chan << bf->offset;\r\n}\r\nstatic int gx1fb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nstruct geodefb_par *par = info->par;\r\nif (info->var.grayscale) {\r\nred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\r\n}\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\r\nu32 *pal = info->pseudo_palette;\r\nu32 v;\r\nif (regno >= 16)\r\nreturn -EINVAL;\r\nv = chan_to_field(red, &info->var.red);\r\nv |= chan_to_field(green, &info->var.green);\r\nv |= chan_to_field(blue, &info->var.blue);\r\npal[regno] = v;\r\n} else {\r\nif (regno >= 256)\r\nreturn -EINVAL;\r\npar->dc_ops->set_palette_reg(info, regno, red, green, blue);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gx1fb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct geodefb_par *par = info->par;\r\nreturn par->vid_ops->blank_display(info, blank_mode);\r\n}\r\nstatic int __devinit gx1fb_map_video_memory(struct fb_info *info, struct pci_dev *dev)\r\n{\r\nstruct geodefb_par *par = info->par;\r\nunsigned gx_base;\r\nint fb_len;\r\nint ret;\r\ngx_base = gx1_gx_base();\r\nif (!gx_base)\r\nreturn -ENODEV;\r\nret = pci_enable_device(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = pci_request_region(dev, 0, "gx1fb (video)");\r\nif (ret < 0)\r\nreturn ret;\r\npar->vid_regs = pci_ioremap_bar(dev, 0);\r\nif (!par->vid_regs)\r\nreturn -ENOMEM;\r\nif (!request_mem_region(gx_base + 0x8300, 0x100, "gx1fb (display controller)"))\r\nreturn -EBUSY;\r\npar->dc_regs = ioremap(gx_base + 0x8300, 0x100);\r\nif (!par->dc_regs)\r\nreturn -ENOMEM;\r\nif ((fb_len = gx1_frame_buffer_size()) < 0)\r\nreturn -ENOMEM;\r\ninfo->fix.smem_start = gx_base + 0x800000;\r\ninfo->fix.smem_len = fb_len;\r\ninfo->screen_base = ioremap(info->fix.smem_start, info->fix.smem_len);\r\nif (!info->screen_base)\r\nreturn -ENOMEM;\r\ndev_info(&dev->dev, "%d Kibyte of video memory at 0x%lx\n",\r\ninfo->fix.smem_len / 1024, info->fix.smem_start);\r\nreturn 0;\r\n}\r\nstatic int parse_panel_option(struct fb_info *info)\r\n{\r\nstruct geodefb_par *par = info->par;\r\nif (strcmp(panel_option, "") != 0) {\r\nint x, y;\r\nchar *s;\r\nx = simple_strtol(panel_option, &s, 10);\r\nif (!x)\r\nreturn -EINVAL;\r\ny = simple_strtol(s + 1, NULL, 10);\r\nif (!y)\r\nreturn -EINVAL;\r\npar->panel_x = x;\r\npar->panel_y = y;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct fb_info * __devinit gx1fb_init_fbinfo(struct device *dev)\r\n{\r\nstruct geodefb_par *par;\r\nstruct fb_info *info;\r\ninfo = framebuffer_alloc(sizeof(struct geodefb_par) + sizeof(u32) * 16, dev);\r\nif (!info)\r\nreturn NULL;\r\npar = info->par;\r\nstrcpy(info->fix.id, "GX1");\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.type_aux = 0;\r\ninfo->fix.xpanstep = 0;\r\ninfo->fix.ypanstep = 0;\r\ninfo->fix.ywrapstep = 0;\r\ninfo->fix.accel = FB_ACCEL_NONE;\r\ninfo->var.nonstd = 0;\r\ninfo->var.activate = FB_ACTIVATE_NOW;\r\ninfo->var.height = -1;\r\ninfo->var.width = -1;\r\ninfo->var.accel_flags = 0;\r\ninfo->var.vmode = FB_VMODE_NONINTERLACED;\r\ninfo->fbops = &gx1fb_ops;\r\ninfo->flags = FBINFO_DEFAULT;\r\ninfo->node = -1;\r\ninfo->pseudo_palette = (void *)par + sizeof(struct geodefb_par);\r\ninfo->var.grayscale = 0;\r\npar->enable_crt = crt_option;\r\nif (parse_panel_option(info) < 0)\r\nprintk(KERN_WARNING "gx1fb: invalid 'panel' option -- disabling flat panel\n");\r\nif (!par->panel_x)\r\npar->enable_crt = 1;\r\nif (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {\r\nframebuffer_release(info);\r\nreturn NULL;\r\n}\r\nreturn info;\r\n}\r\nstatic int __devinit gx1fb_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct geodefb_par *par;\r\nstruct fb_info *info;\r\nint ret;\r\ninfo = gx1fb_init_fbinfo(&pdev->dev);\r\nif (!info)\r\nreturn -ENOMEM;\r\npar = info->par;\r\npar->dc_ops = &gx1_dc_ops;\r\npar->vid_ops = &cs5530_vid_ops;\r\nif ((ret = gx1fb_map_video_memory(info, pdev)) < 0) {\r\ndev_err(&pdev->dev, "failed to map frame buffer or controller registers\n");\r\ngoto err;\r\n}\r\nret = fb_find_mode(&info->var, info, mode_option,\r\ngx1_modedb, ARRAY_SIZE(gx1_modedb), NULL, 16);\r\nif (ret == 0 || ret == 4) {\r\ndev_err(&pdev->dev, "could not find valid video mode\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nmemset_io(info->screen_base, 0, info->fix.smem_len);\r\ngx1fb_check_var(&info->var, info);\r\ngx1fb_set_par(info);\r\nif (register_framebuffer(info) < 0) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\npci_set_drvdata(pdev, info);\r\nprintk(KERN_INFO "fb%d: %s frame buffer device\n", info->node, info->fix.id);\r\nreturn 0;\r\nerr:\r\nif (info->screen_base) {\r\niounmap(info->screen_base);\r\npci_release_region(pdev, 0);\r\n}\r\nif (par->vid_regs) {\r\niounmap(par->vid_regs);\r\npci_release_region(pdev, 1);\r\n}\r\nif (par->dc_regs) {\r\niounmap(par->dc_regs);\r\nrelease_mem_region(gx1_gx_base() + 0x8300, 0x100);\r\n}\r\nif (info) {\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __devexit gx1fb_remove(struct pci_dev *pdev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(pdev);\r\nstruct geodefb_par *par = info->par;\r\nunregister_framebuffer(info);\r\niounmap((void __iomem *)info->screen_base);\r\npci_release_region(pdev, 0);\r\niounmap(par->vid_regs);\r\npci_release_region(pdev, 1);\r\niounmap(par->dc_regs);\r\nrelease_mem_region(gx1_gx_base() + 0x8300, 0x100);\r\nfb_dealloc_cmap(&info->cmap);\r\npci_set_drvdata(pdev, NULL);\r\nframebuffer_release(info);\r\n}\r\nstatic void __init gx1fb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn;\r\nwhile ((this_opt = strsep(&options, ","))) {\r\nif (!*this_opt)\r\ncontinue;\r\nif (!strncmp(this_opt, "mode:", 5))\r\nstrlcpy(mode_option, this_opt + 5, sizeof(mode_option));\r\nelse if (!strncmp(this_opt, "crt:", 4))\r\ncrt_option = !!simple_strtoul(this_opt + 4, NULL, 0);\r\nelse if (!strncmp(this_opt, "panel:", 6))\r\nstrlcpy(panel_option, this_opt + 6, sizeof(panel_option));\r\nelse\r\nstrlcpy(mode_option, this_opt, sizeof(mode_option));\r\n}\r\n}\r\nstatic int __init gx1fb_init(void)\r\n{\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("gx1fb", &option))\r\nreturn -ENODEV;\r\ngx1fb_setup(option);\r\n#endif\r\nreturn pci_register_driver(&gx1fb_driver);\r\n}\r\nstatic void __devexit gx1fb_cleanup(void)\r\n{\r\npci_unregister_driver(&gx1fb_driver);\r\n}
