static struct hid_report *\r\nhiddev_lookup_report(struct hid_device *hid, struct hiddev_report_info *rinfo)\r\n{\r\nunsigned int flags = rinfo->report_id & ~HID_REPORT_ID_MASK;\r\nunsigned int rid = rinfo->report_id & HID_REPORT_ID_MASK;\r\nstruct hid_report_enum *report_enum;\r\nstruct hid_report *report;\r\nstruct list_head *list;\r\nif (rinfo->report_type < HID_REPORT_TYPE_MIN ||\r\nrinfo->report_type > HID_REPORT_TYPE_MAX)\r\nreturn NULL;\r\nreport_enum = hid->report_enum +\r\n(rinfo->report_type - HID_REPORT_TYPE_MIN);\r\nswitch (flags) {\r\ncase 0:\r\nbreak;\r\ncase HID_REPORT_ID_FIRST:\r\nif (list_empty(&report_enum->report_list))\r\nreturn NULL;\r\nlist = report_enum->report_list.next;\r\nreport = list_entry(list, struct hid_report, list);\r\nrinfo->report_id = report->id;\r\nbreak;\r\ncase HID_REPORT_ID_NEXT:\r\nreport = report_enum->report_id_hash[rid];\r\nif (!report)\r\nreturn NULL;\r\nlist = report->list.next;\r\nif (list == &report_enum->report_list)\r\nreturn NULL;\r\nreport = list_entry(list, struct hid_report, list);\r\nrinfo->report_id = report->id;\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nreturn report_enum->report_id_hash[rinfo->report_id];\r\n}\r\nstatic struct hid_field *\r\nhiddev_lookup_usage(struct hid_device *hid, struct hiddev_usage_ref *uref)\r\n{\r\nint i, j;\r\nstruct hid_report *report;\r\nstruct hid_report_enum *report_enum;\r\nstruct hid_field *field;\r\nif (uref->report_type < HID_REPORT_TYPE_MIN ||\r\nuref->report_type > HID_REPORT_TYPE_MAX)\r\nreturn NULL;\r\nreport_enum = hid->report_enum +\r\n(uref->report_type - HID_REPORT_TYPE_MIN);\r\nlist_for_each_entry(report, &report_enum->report_list, list) {\r\nfor (i = 0; i < report->maxfield; i++) {\r\nfield = report->field[i];\r\nfor (j = 0; j < field->maxusage; j++) {\r\nif (field->usage[j].hid == uref->usage_code) {\r\nuref->report_id = report->id;\r\nuref->field_index = i;\r\nuref->usage_index = j;\r\nreturn field;\r\n}\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void hiddev_send_event(struct hid_device *hid,\r\nstruct hiddev_usage_ref *uref)\r\n{\r\nstruct hiddev *hiddev = hid->hiddev;\r\nstruct hiddev_list *list;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hiddev->list_lock, flags);\r\nlist_for_each_entry(list, &hiddev->list, node) {\r\nif (uref->field_index != HID_FIELD_INDEX_NONE ||\r\n(list->flags & HIDDEV_FLAG_REPORT) != 0) {\r\nlist->buffer[list->head] = *uref;\r\nlist->head = (list->head + 1) &\r\n(HIDDEV_BUFFER_SIZE - 1);\r\nkill_fasync(&list->fasync, SIGIO, POLL_IN);\r\n}\r\n}\r\nspin_unlock_irqrestore(&hiddev->list_lock, flags);\r\nwake_up_interruptible(&hiddev->wait);\r\n}\r\nvoid hiddev_hid_event(struct hid_device *hid, struct hid_field *field,\r\nstruct hid_usage *usage, __s32 value)\r\n{\r\nunsigned type = field->report_type;\r\nstruct hiddev_usage_ref uref;\r\nuref.report_type =\r\n(type == HID_INPUT_REPORT) ? HID_REPORT_TYPE_INPUT :\r\n((type == HID_OUTPUT_REPORT) ? HID_REPORT_TYPE_OUTPUT :\r\n((type == HID_FEATURE_REPORT) ? HID_REPORT_TYPE_FEATURE : 0));\r\nuref.report_id = field->report->id;\r\nuref.field_index = field->index;\r\nuref.usage_index = (usage - field->usage);\r\nuref.usage_code = usage->hid;\r\nuref.value = value;\r\nhiddev_send_event(hid, &uref);\r\n}\r\nvoid hiddev_report_event(struct hid_device *hid, struct hid_report *report)\r\n{\r\nunsigned type = report->type;\r\nstruct hiddev_usage_ref uref;\r\nmemset(&uref, 0, sizeof(uref));\r\nuref.report_type =\r\n(type == HID_INPUT_REPORT) ? HID_REPORT_TYPE_INPUT :\r\n((type == HID_OUTPUT_REPORT) ? HID_REPORT_TYPE_OUTPUT :\r\n((type == HID_FEATURE_REPORT) ? HID_REPORT_TYPE_FEATURE : 0));\r\nuref.report_id = report->id;\r\nuref.field_index = HID_FIELD_INDEX_NONE;\r\nhiddev_send_event(hid, &uref);\r\n}\r\nstatic int hiddev_fasync(int fd, struct file *file, int on)\r\n{\r\nstruct hiddev_list *list = file->private_data;\r\nreturn fasync_helper(fd, file, on, &list->fasync);\r\n}\r\nstatic int hiddev_release(struct inode * inode, struct file * file)\r\n{\r\nstruct hiddev_list *list = file->private_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&list->hiddev->list_lock, flags);\r\nlist_del(&list->node);\r\nspin_unlock_irqrestore(&list->hiddev->list_lock, flags);\r\nmutex_lock(&list->hiddev->existancelock);\r\nif (!--list->hiddev->open) {\r\nif (list->hiddev->exist) {\r\nusbhid_close(list->hiddev->hid);\r\nusbhid_put_power(list->hiddev->hid);\r\n} else {\r\nmutex_unlock(&list->hiddev->existancelock);\r\nkfree(list->hiddev);\r\nkfree(list);\r\nreturn 0;\r\n}\r\n}\r\nmutex_unlock(&list->hiddev->existancelock);\r\nkfree(list);\r\nreturn 0;\r\n}\r\nstatic int hiddev_open(struct inode *inode, struct file *file)\r\n{\r\nstruct hiddev_list *list;\r\nstruct usb_interface *intf;\r\nstruct hid_device *hid;\r\nstruct hiddev *hiddev;\r\nint res;\r\nintf = usbhid_find_interface(iminor(inode));\r\nif (!intf)\r\nreturn -ENODEV;\r\nhid = usb_get_intfdata(intf);\r\nhiddev = hid->hiddev;\r\nif (!(list = kzalloc(sizeof(struct hiddev_list), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nmutex_init(&list->thread_lock);\r\nlist->hiddev = hiddev;\r\nfile->private_data = list;\r\nif (list->hiddev->exist) {\r\nif (!list->hiddev->open++) {\r\nres = usbhid_open(hiddev->hid);\r\nif (res < 0) {\r\nres = -EIO;\r\ngoto bail;\r\n}\r\n}\r\n} else {\r\nres = -ENODEV;\r\ngoto bail;\r\n}\r\nspin_lock_irq(&list->hiddev->list_lock);\r\nlist_add_tail(&list->node, &hiddev->list);\r\nspin_unlock_irq(&list->hiddev->list_lock);\r\nmutex_lock(&hiddev->existancelock);\r\nif (!list->hiddev->open++)\r\nif (list->hiddev->exist) {\r\nstruct hid_device *hid = hiddev->hid;\r\nres = usbhid_get_power(hid);\r\nif (res < 0) {\r\nres = -EIO;\r\ngoto bail_unlock;\r\n}\r\nusbhid_open(hid);\r\n}\r\nmutex_unlock(&hiddev->existancelock);\r\nreturn 0;\r\nbail_unlock:\r\nmutex_unlock(&hiddev->existancelock);\r\nbail:\r\nfile->private_data = NULL;\r\nkfree(list);\r\nreturn res;\r\n}\r\nstatic ssize_t hiddev_write(struct file * file, const char __user * buffer, size_t count, loff_t *ppos)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t hiddev_read(struct file * file, char __user * buffer, size_t count, loff_t *ppos)\r\n{\r\nDEFINE_WAIT(wait);\r\nstruct hiddev_list *list = file->private_data;\r\nint event_size;\r\nint retval;\r\nevent_size = ((list->flags & HIDDEV_FLAG_UREF) != 0) ?\r\nsizeof(struct hiddev_usage_ref) : sizeof(struct hiddev_event);\r\nif (count < event_size)\r\nreturn 0;\r\nretval = mutex_lock_interruptible(&list->thread_lock);\r\nif (retval)\r\nreturn -ERESTARTSYS;\r\nwhile (retval == 0) {\r\nif (list->head == list->tail) {\r\nprepare_to_wait(&list->hiddev->wait, &wait, TASK_INTERRUPTIBLE);\r\nwhile (list->head == list->tail) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\nif (!list->hiddev->exist) {\r\nretval = -EIO;\r\nbreak;\r\n}\r\nmutex_unlock(&list->thread_lock);\r\nschedule();\r\nif (mutex_lock_interruptible(&list->thread_lock)) {\r\nfinish_wait(&list->hiddev->wait, &wait);\r\nreturn -EINTR;\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\n}\r\nfinish_wait(&list->hiddev->wait, &wait);\r\n}\r\nif (retval) {\r\nmutex_unlock(&list->thread_lock);\r\nreturn retval;\r\n}\r\nwhile (list->head != list->tail &&\r\nretval + event_size <= count) {\r\nif ((list->flags & HIDDEV_FLAG_UREF) == 0) {\r\nif (list->buffer[list->tail].field_index != HID_FIELD_INDEX_NONE) {\r\nstruct hiddev_event event;\r\nevent.hid = list->buffer[list->tail].usage_code;\r\nevent.value = list->buffer[list->tail].value;\r\nif (copy_to_user(buffer + retval, &event, sizeof(struct hiddev_event))) {\r\nmutex_unlock(&list->thread_lock);\r\nreturn -EFAULT;\r\n}\r\nretval += sizeof(struct hiddev_event);\r\n}\r\n} else {\r\nif (list->buffer[list->tail].field_index != HID_FIELD_INDEX_NONE ||\r\n(list->flags & HIDDEV_FLAG_REPORT) != 0) {\r\nif (copy_to_user(buffer + retval, list->buffer + list->tail, sizeof(struct hiddev_usage_ref))) {\r\nmutex_unlock(&list->thread_lock);\r\nreturn -EFAULT;\r\n}\r\nretval += sizeof(struct hiddev_usage_ref);\r\n}\r\n}\r\nlist->tail = (list->tail + 1) & (HIDDEV_BUFFER_SIZE - 1);\r\n}\r\n}\r\nmutex_unlock(&list->thread_lock);\r\nreturn retval;\r\n}\r\nstatic unsigned int hiddev_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct hiddev_list *list = file->private_data;\r\npoll_wait(file, &list->hiddev->wait, wait);\r\nif (list->head != list->tail)\r\nreturn POLLIN | POLLRDNORM;\r\nif (!list->hiddev->exist)\r\nreturn POLLERR | POLLHUP;\r\nreturn 0;\r\n}\r\nstatic noinline int hiddev_ioctl_usage(struct hiddev *hiddev, unsigned int cmd, void __user *user_arg)\r\n{\r\nstruct hid_device *hid = hiddev->hid;\r\nstruct hiddev_report_info rinfo;\r\nstruct hiddev_usage_ref_multi *uref_multi = NULL;\r\nstruct hiddev_usage_ref *uref;\r\nstruct hid_report *report;\r\nstruct hid_field *field;\r\nint i;\r\nuref_multi = kmalloc(sizeof(struct hiddev_usage_ref_multi), GFP_KERNEL);\r\nif (!uref_multi)\r\nreturn -ENOMEM;\r\nuref = &uref_multi->uref;\r\nif (cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) {\r\nif (copy_from_user(uref_multi, user_arg,\r\nsizeof(*uref_multi)))\r\ngoto fault;\r\n} else {\r\nif (copy_from_user(uref, user_arg, sizeof(*uref)))\r\ngoto fault;\r\n}\r\nswitch (cmd) {\r\ncase HIDIOCGUCODE:\r\nrinfo.report_type = uref->report_type;\r\nrinfo.report_id = uref->report_id;\r\nif ((report = hiddev_lookup_report(hid, &rinfo)) == NULL)\r\ngoto inval;\r\nif (uref->field_index >= report->maxfield)\r\ngoto inval;\r\nfield = report->field[uref->field_index];\r\nif (uref->usage_index >= field->maxusage)\r\ngoto inval;\r\nuref->usage_code = field->usage[uref->usage_index].hid;\r\nif (copy_to_user(user_arg, uref, sizeof(*uref)))\r\ngoto fault;\r\ngoto goodreturn;\r\ndefault:\r\nif (cmd != HIDIOCGUSAGE &&\r\ncmd != HIDIOCGUSAGES &&\r\nuref->report_type == HID_REPORT_TYPE_INPUT)\r\ngoto inval;\r\nif (uref->report_id == HID_REPORT_ID_UNKNOWN) {\r\nfield = hiddev_lookup_usage(hid, uref);\r\nif (field == NULL)\r\ngoto inval;\r\n} else {\r\nrinfo.report_type = uref->report_type;\r\nrinfo.report_id = uref->report_id;\r\nif ((report = hiddev_lookup_report(hid, &rinfo)) == NULL)\r\ngoto inval;\r\nif (uref->field_index >= report->maxfield)\r\ngoto inval;\r\nfield = report->field[uref->field_index];\r\nif (cmd == HIDIOCGCOLLECTIONINDEX) {\r\nif (uref->usage_index >= field->maxusage)\r\ngoto inval;\r\n} else if (uref->usage_index >= field->report_count)\r\ngoto inval;\r\nelse if ((cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) &&\r\n(uref_multi->num_values > HID_MAX_MULTI_USAGES ||\r\nuref->usage_index + uref_multi->num_values > field->report_count))\r\ngoto inval;\r\n}\r\nswitch (cmd) {\r\ncase HIDIOCGUSAGE:\r\nuref->value = field->value[uref->usage_index];\r\nif (copy_to_user(user_arg, uref, sizeof(*uref)))\r\ngoto fault;\r\ngoto goodreturn;\r\ncase HIDIOCSUSAGE:\r\nfield->value[uref->usage_index] = uref->value;\r\ngoto goodreturn;\r\ncase HIDIOCGCOLLECTIONINDEX:\r\ni = field->usage[uref->usage_index].collection_index;\r\nkfree(uref_multi);\r\nreturn i;\r\ncase HIDIOCGUSAGES:\r\nfor (i = 0; i < uref_multi->num_values; i++)\r\nuref_multi->values[i] =\r\nfield->value[uref->usage_index + i];\r\nif (copy_to_user(user_arg, uref_multi,\r\nsizeof(*uref_multi)))\r\ngoto fault;\r\ngoto goodreturn;\r\ncase HIDIOCSUSAGES:\r\nfor (i = 0; i < uref_multi->num_values; i++)\r\nfield->value[uref->usage_index + i] =\r\nuref_multi->values[i];\r\ngoto goodreturn;\r\n}\r\ngoodreturn:\r\nkfree(uref_multi);\r\nreturn 0;\r\nfault:\r\nkfree(uref_multi);\r\nreturn -EFAULT;\r\ninval:\r\nkfree(uref_multi);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic noinline int hiddev_ioctl_string(struct hiddev *hiddev, unsigned int cmd, void __user *user_arg)\r\n{\r\nstruct hid_device *hid = hiddev->hid;\r\nstruct usb_device *dev = hid_to_usb_dev(hid);\r\nint idx, len;\r\nchar *buf;\r\nif (get_user(idx, (int __user *)user_arg))\r\nreturn -EFAULT;\r\nif ((buf = kmalloc(HID_STRING_SIZE, GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\nif ((len = usb_string(dev, idx, buf, HID_STRING_SIZE-1)) < 0) {\r\nkfree(buf);\r\nreturn -EINVAL;\r\n}\r\nif (copy_to_user(user_arg+sizeof(int), buf, len+1)) {\r\nkfree(buf);\r\nreturn -EFAULT;\r\n}\r\nkfree(buf);\r\nreturn len;\r\n}\r\nstatic long hiddev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct hiddev_list *list = file->private_data;\r\nstruct hiddev *hiddev = list->hiddev;\r\nstruct hid_device *hid;\r\nstruct hiddev_collection_info cinfo;\r\nstruct hiddev_report_info rinfo;\r\nstruct hiddev_field_info finfo;\r\nstruct hiddev_devinfo dinfo;\r\nstruct hid_report *report;\r\nstruct hid_field *field;\r\nvoid __user *user_arg = (void __user *)arg;\r\nint i, r = -EINVAL;\r\nmutex_lock(&hiddev->existancelock);\r\nif (!hiddev->exist) {\r\nr = -ENODEV;\r\ngoto ret_unlock;\r\n}\r\nhid = hiddev->hid;\r\nswitch (cmd) {\r\ncase HIDIOCGVERSION:\r\nr = put_user(HID_VERSION, (int __user *)arg) ?\r\n-EFAULT : 0;\r\nbreak;\r\ncase HIDIOCAPPLICATION:\r\nif (arg < 0 || arg >= hid->maxapplication)\r\nbreak;\r\nfor (i = 0; i < hid->maxcollection; i++)\r\nif (hid->collection[i].type ==\r\nHID_COLLECTION_APPLICATION && arg-- == 0)\r\nbreak;\r\nif (i < hid->maxcollection)\r\nr = hid->collection[i].usage;\r\nbreak;\r\ncase HIDIOCGDEVINFO:\r\n{\r\nstruct usb_device *dev = hid_to_usb_dev(hid);\r\nstruct usbhid_device *usbhid = hid->driver_data;\r\nmemset(&dinfo, 0, sizeof(dinfo));\r\ndinfo.bustype = BUS_USB;\r\ndinfo.busnum = dev->bus->busnum;\r\ndinfo.devnum = dev->devnum;\r\ndinfo.ifnum = usbhid->ifnum;\r\ndinfo.vendor = le16_to_cpu(dev->descriptor.idVendor);\r\ndinfo.product = le16_to_cpu(dev->descriptor.idProduct);\r\ndinfo.version = le16_to_cpu(dev->descriptor.bcdDevice);\r\ndinfo.num_applications = hid->maxapplication;\r\nr = copy_to_user(user_arg, &dinfo, sizeof(dinfo)) ?\r\n-EFAULT : 0;\r\nbreak;\r\n}\r\ncase HIDIOCGFLAG:\r\nr = put_user(list->flags, (int __user *)arg) ?\r\n-EFAULT : 0;\r\nbreak;\r\ncase HIDIOCSFLAG:\r\n{\r\nint newflags;\r\nif (get_user(newflags, (int __user *)arg)) {\r\nr = -EFAULT;\r\nbreak;\r\n}\r\nif ((newflags & ~HIDDEV_FLAGS) != 0 ||\r\n((newflags & HIDDEV_FLAG_REPORT) != 0 &&\r\n(newflags & HIDDEV_FLAG_UREF) == 0))\r\nbreak;\r\nlist->flags = newflags;\r\nr = 0;\r\nbreak;\r\n}\r\ncase HIDIOCGSTRING:\r\nr = hiddev_ioctl_string(hiddev, cmd, user_arg);\r\nbreak;\r\ncase HIDIOCINITREPORT:\r\nusbhid_init_reports(hid);\r\nr = 0;\r\nbreak;\r\ncase HIDIOCGREPORT:\r\nif (copy_from_user(&rinfo, user_arg, sizeof(rinfo))) {\r\nr = -EFAULT;\r\nbreak;\r\n}\r\nif (rinfo.report_type == HID_REPORT_TYPE_OUTPUT)\r\nbreak;\r\nreport = hiddev_lookup_report(hid, &rinfo);\r\nif (report == NULL)\r\nbreak;\r\nusbhid_submit_report(hid, report, USB_DIR_IN);\r\nusbhid_wait_io(hid);\r\nr = 0;\r\nbreak;\r\ncase HIDIOCSREPORT:\r\nif (copy_from_user(&rinfo, user_arg, sizeof(rinfo))) {\r\nr = -EFAULT;\r\nbreak;\r\n}\r\nif (rinfo.report_type == HID_REPORT_TYPE_INPUT)\r\nbreak;\r\nreport = hiddev_lookup_report(hid, &rinfo);\r\nif (report == NULL)\r\nbreak;\r\nusbhid_submit_report(hid, report, USB_DIR_OUT);\r\nusbhid_wait_io(hid);\r\nr = 0;\r\nbreak;\r\ncase HIDIOCGREPORTINFO:\r\nif (copy_from_user(&rinfo, user_arg, sizeof(rinfo))) {\r\nr = -EFAULT;\r\nbreak;\r\n}\r\nreport = hiddev_lookup_report(hid, &rinfo);\r\nif (report == NULL)\r\nbreak;\r\nrinfo.num_fields = report->maxfield;\r\nr = copy_to_user(user_arg, &rinfo, sizeof(rinfo)) ?\r\n-EFAULT : 0;\r\nbreak;\r\ncase HIDIOCGFIELDINFO:\r\nif (copy_from_user(&finfo, user_arg, sizeof(finfo))) {\r\nr = -EFAULT;\r\nbreak;\r\n}\r\nrinfo.report_type = finfo.report_type;\r\nrinfo.report_id = finfo.report_id;\r\nreport = hiddev_lookup_report(hid, &rinfo);\r\nif (report == NULL)\r\nbreak;\r\nif (finfo.field_index >= report->maxfield)\r\nbreak;\r\nfield = report->field[finfo.field_index];\r\nmemset(&finfo, 0, sizeof(finfo));\r\nfinfo.report_type = rinfo.report_type;\r\nfinfo.report_id = rinfo.report_id;\r\nfinfo.field_index = field->report_count - 1;\r\nfinfo.maxusage = field->maxusage;\r\nfinfo.flags = field->flags;\r\nfinfo.physical = field->physical;\r\nfinfo.logical = field->logical;\r\nfinfo.application = field->application;\r\nfinfo.logical_minimum = field->logical_minimum;\r\nfinfo.logical_maximum = field->logical_maximum;\r\nfinfo.physical_minimum = field->physical_minimum;\r\nfinfo.physical_maximum = field->physical_maximum;\r\nfinfo.unit_exponent = field->unit_exponent;\r\nfinfo.unit = field->unit;\r\nr = copy_to_user(user_arg, &finfo, sizeof(finfo)) ?\r\n-EFAULT : 0;\r\nbreak;\r\ncase HIDIOCGUCODE:\r\ncase HIDIOCGUSAGE:\r\ncase HIDIOCSUSAGE:\r\ncase HIDIOCGUSAGES:\r\ncase HIDIOCSUSAGES:\r\ncase HIDIOCGCOLLECTIONINDEX:\r\nr = hiddev_ioctl_usage(hiddev, cmd, user_arg);\r\nbreak;\r\ncase HIDIOCGCOLLECTIONINFO:\r\nif (copy_from_user(&cinfo, user_arg, sizeof(cinfo))) {\r\nr = -EFAULT;\r\nbreak;\r\n}\r\nif (cinfo.index >= hid->maxcollection)\r\nbreak;\r\ncinfo.type = hid->collection[cinfo.index].type;\r\ncinfo.usage = hid->collection[cinfo.index].usage;\r\ncinfo.level = hid->collection[cinfo.index].level;\r\nr = copy_to_user(user_arg, &cinfo, sizeof(cinfo)) ?\r\n-EFAULT : 0;\r\nbreak;\r\ndefault:\r\nif (_IOC_TYPE(cmd) != 'H' || _IOC_DIR(cmd) != _IOC_READ)\r\nbreak;\r\nif (_IOC_NR(cmd) == _IOC_NR(HIDIOCGNAME(0))) {\r\nint len = strlen(hid->name) + 1;\r\nif (len > _IOC_SIZE(cmd))\r\nlen = _IOC_SIZE(cmd);\r\nr = copy_to_user(user_arg, hid->name, len) ?\r\n-EFAULT : len;\r\nbreak;\r\n}\r\nif (_IOC_NR(cmd) == _IOC_NR(HIDIOCGPHYS(0))) {\r\nint len = strlen(hid->phys) + 1;\r\nif (len > _IOC_SIZE(cmd))\r\nlen = _IOC_SIZE(cmd);\r\nr = copy_to_user(user_arg, hid->phys, len) ?\r\n-EFAULT : len;\r\nbreak;\r\n}\r\n}\r\nret_unlock:\r\nmutex_unlock(&hiddev->existancelock);\r\nreturn r;\r\n}\r\nstatic long hiddev_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nreturn hiddev_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\r\n}\r\nstatic char *hiddev_devnode(struct device *dev, umode_t *mode)\r\n{\r\nreturn kasprintf(GFP_KERNEL, "usb/%s", dev_name(dev));\r\n}\r\nint hiddev_connect(struct hid_device *hid, unsigned int force)\r\n{\r\nstruct hiddev *hiddev;\r\nstruct usbhid_device *usbhid = hid->driver_data;\r\nint retval;\r\nif (!force) {\r\nunsigned int i;\r\nfor (i = 0; i < hid->maxcollection; i++)\r\nif (hid->collection[i].type ==\r\nHID_COLLECTION_APPLICATION &&\r\n!IS_INPUT_APPLICATION(hid->collection[i].usage))\r\nbreak;\r\nif (i == hid->maxcollection)\r\nreturn -1;\r\n}\r\nif (!(hiddev = kzalloc(sizeof(struct hiddev), GFP_KERNEL)))\r\nreturn -1;\r\ninit_waitqueue_head(&hiddev->wait);\r\nINIT_LIST_HEAD(&hiddev->list);\r\nspin_lock_init(&hiddev->list_lock);\r\nmutex_init(&hiddev->existancelock);\r\nhid->hiddev = hiddev;\r\nhiddev->hid = hid;\r\nhiddev->exist = 1;\r\nretval = usb_register_dev(usbhid->intf, &hiddev_class);\r\nif (retval) {\r\nhid_err(hid, "Not able to get a minor for this device\n");\r\nhid->hiddev = NULL;\r\nkfree(hiddev);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid hiddev_disconnect(struct hid_device *hid)\r\n{\r\nstruct hiddev *hiddev = hid->hiddev;\r\nstruct usbhid_device *usbhid = hid->driver_data;\r\nusb_deregister_dev(usbhid->intf, &hiddev_class);\r\nmutex_lock(&hiddev->existancelock);\r\nhiddev->exist = 0;\r\nif (hiddev->open) {\r\nmutex_unlock(&hiddev->existancelock);\r\nusbhid_close(hiddev->hid);\r\nwake_up_interruptible(&hiddev->wait);\r\n} else {\r\nmutex_unlock(&hiddev->existancelock);\r\nkfree(hiddev);\r\n}\r\n}
