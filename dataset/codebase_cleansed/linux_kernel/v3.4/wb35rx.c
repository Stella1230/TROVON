static void packet_came(struct ieee80211_hw *hw, char *pRxBufferAddress, int PacketSize)\r\n{\r\nstruct wbsoft_priv *priv = hw->priv;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_rx_status rx_status = {0};\r\nif (!priv->enabled)\r\nreturn;\r\nskb = dev_alloc_skb(PacketSize);\r\nif (!skb) {\r\nprintk("Not enough memory for packet, FIXME\n");\r\nreturn;\r\n}\r\nmemcpy(skb_put(skb, PacketSize), pRxBufferAddress, PacketSize);\r\nmemcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));\r\nieee80211_rx_irqsafe(hw, skb);\r\n}\r\nstatic void Wb35Rx_adjust(struct wb35_descriptor *pRxDes)\r\n{\r\nu32 *pRxBufferAddress;\r\nu32 DecryptionMethod;\r\nu32 i;\r\nu16 BufferSize;\r\nDecryptionMethod = pRxDes->R01.R01_decryption_method;\r\npRxBufferAddress = pRxDes->buffer_address[0];\r\nBufferSize = pRxDes->buffer_size[0];\r\nBufferSize -= 4;\r\nif (DecryptionMethod)\r\nBufferSize -= 4;\r\nif (DecryptionMethod == 3)\r\nBufferSize -= 4;\r\nif (DecryptionMethod == 1) {\r\nfor (i = 6; i > 0; i--)\r\npRxBufferAddress[i] = pRxBufferAddress[i - 1];\r\npRxDes->buffer_address[0] = pRxBufferAddress + 1;\r\nBufferSize -= 4;\r\n} else if (DecryptionMethod) {\r\nfor (i = 7; i > 1; i--)\r\npRxBufferAddress[i] = pRxBufferAddress[i - 2];\r\npRxDes->buffer_address[0] = pRxBufferAddress + 2;\r\nBufferSize -= 8;\r\n}\r\npRxDes->buffer_size[0] = BufferSize;\r\n}\r\nstatic u16 Wb35Rx_indicate(struct ieee80211_hw *hw)\r\n{\r\nstruct wbsoft_priv *priv = hw->priv;\r\nstruct hw_data *pHwData = &priv->sHwData;\r\nstruct wb35_descriptor RxDes;\r\nstruct wb35_rx *pWb35Rx = &pHwData->Wb35Rx;\r\nu8 *pRxBufferAddress;\r\nu16 PacketSize;\r\nu16 stmp, BufferSize, stmp2 = 0;\r\nu32 RxBufferId;\r\ndo {\r\nRxBufferId = pWb35Rx->RxProcessIndex;\r\nif (pWb35Rx->RxOwner[RxBufferId])\r\nbreak;\r\npWb35Rx->RxProcessIndex++;\r\npWb35Rx->RxProcessIndex %= MAX_USB_RX_BUFFER_NUMBER;\r\npRxBufferAddress = pWb35Rx->pDRx;\r\nBufferSize = pWb35Rx->RxBufferSize[RxBufferId];\r\nwhile (BufferSize >= 4) {\r\nif ((cpu_to_le32(*(u32 *)pRxBufferAddress) & 0x0fffffff) == RX_END_TAG)\r\nbreak;\r\nRxDes.R00.value = le32_to_cpu(*(u32 *)pRxBufferAddress);\r\nPacketSize = (u16)RxDes.R00.R00_receive_byte_count;\r\nRxDes.R01.value = le32_to_cpu(*((u32 *)(pRxBufferAddress + 4)));\r\nif ((PacketSize & 0x03) > 0)\r\nPacketSize -= 4;\r\nif (PacketSize > MAX_PACKET_SIZE) {\r\npr_debug("Serious ERROR : Rx data size too long, size =%d\n", PacketSize);\r\npWb35Rx->EP3vm_state = VM_STOP;\r\npWb35Rx->Ep3ErrorCount2++;\r\nbreak;\r\n}\r\nBufferSize -= 8;\r\npRxBufferAddress += 8;\r\nRxDes.buffer_address[0] = pRxBufferAddress;\r\nRxDes.buffer_size[0] = PacketSize;\r\nRxDes.buffer_number = 1;\r\nRxDes.buffer_start_index = 0;\r\nRxDes.buffer_total_size = RxDes.buffer_size[0];\r\nWb35Rx_adjust(&RxDes);\r\npacket_came(hw, pRxBufferAddress, PacketSize);\r\nstmp = PacketSize + 3;\r\nstmp &= ~0x03;\r\npRxBufferAddress += stmp;\r\nBufferSize -= stmp;\r\nstmp2 += stmp;\r\n}\r\npWb35Rx->RxOwner[RxBufferId] = 1;\r\n} while (true);\r\nreturn stmp2;\r\n}\r\nstatic void Wb35Rx_Complete(struct urb *urb)\r\n{\r\nstruct ieee80211_hw *hw = urb->context;\r\nstruct wbsoft_priv *priv = hw->priv;\r\nstruct hw_data *pHwData = &priv->sHwData;\r\nstruct wb35_rx *pWb35Rx = &pHwData->Wb35Rx;\r\nu8 *pRxBufferAddress;\r\nu32 SizeCheck;\r\nu16 BulkLength;\r\nu32 RxBufferId;\r\nstruct R00_descriptor R00;\r\npWb35Rx->EP3vm_state = VM_COMPLETED;\r\npWb35Rx->EP3VM_status = urb->status;\r\nRxBufferId = pWb35Rx->CurrentRxBufferId;\r\npRxBufferAddress = pWb35Rx->pDRx;\r\nBulkLength = (u16)urb->actual_length;\r\npWb35Rx->EP3vm_state = VM_COMPLETED;\r\nif (pHwData->SurpriseRemove)\r\ngoto error;\r\nif (pWb35Rx->rx_halt)\r\ngoto error;\r\npWb35Rx->RxOwner[RxBufferId] = 0;\r\nR00.value = le32_to_cpu(*(u32 *)pRxBufferAddress);\r\nif (pWb35Rx->EP3VM_status != 0) {\r\npr_debug("EP3 IoCompleteRoutine return error\n");\r\npWb35Rx->EP3vm_state = VM_STOP;\r\ngoto error;\r\n}\r\nif (!HAL_USB_MODE_BURST(pHwData)) {\r\nSizeCheck = R00.R00_receive_byte_count;\r\nif ((SizeCheck & 0x03) > 0)\r\nSizeCheck -= 4;\r\nSizeCheck = (SizeCheck + 3) & ~0x03;\r\nSizeCheck += 12;\r\nif ((BulkLength > 1600) ||\r\n(SizeCheck > 1600) ||\r\n(BulkLength != SizeCheck) ||\r\n(BulkLength == 0)) {\r\npWb35Rx->EP3vm_state = VM_STOP;\r\npWb35Rx->Ep3ErrorCount2++;\r\n}\r\n}\r\npWb35Rx->ByteReceived += BulkLength;\r\npWb35Rx->RxBufferSize[RxBufferId] = BulkLength;\r\nif (!pWb35Rx->RxOwner[RxBufferId])\r\nWb35Rx_indicate(hw);\r\nkfree(pWb35Rx->pDRx);\r\nWb35Rx(hw);\r\nreturn;\r\nerror:\r\npWb35Rx->RxOwner[RxBufferId] = 1;\r\natomic_dec(&pWb35Rx->RxFireCounter);\r\npWb35Rx->EP3vm_state = VM_STOP;\r\n}\r\nstatic void Wb35Rx(struct ieee80211_hw *hw)\r\n{\r\nstruct wbsoft_priv *priv = hw->priv;\r\nstruct hw_data *pHwData = &priv->sHwData;\r\nstruct wb35_rx *pWb35Rx = &pHwData->Wb35Rx;\r\nu8 *pRxBufferAddress;\r\nstruct urb *urb = pWb35Rx->RxUrb;\r\nint retv;\r\nu32 RxBufferId;\r\nif (pHwData->SurpriseRemove)\r\ngoto error;\r\nif (pWb35Rx->rx_halt)\r\ngoto error;\r\nRxBufferId = pWb35Rx->RxBufferId;\r\nif (!pWb35Rx->RxOwner[RxBufferId]) {\r\npr_debug("Rx driver fifo unavailable\n");\r\ngoto error;\r\n}\r\npWb35Rx->RxBufferId++;\r\npWb35Rx->RxBufferId %= MAX_USB_RX_BUFFER_NUMBER;\r\npWb35Rx->CurrentRxBufferId = RxBufferId;\r\npWb35Rx->pDRx = kzalloc(MAX_USB_RX_BUFFER, GFP_ATOMIC);\r\nif (!pWb35Rx->pDRx) {\r\nprintk("w35und: Rx memory alloc failed\n");\r\ngoto error;\r\n}\r\npRxBufferAddress = pWb35Rx->pDRx;\r\nusb_fill_bulk_urb(urb, pHwData->udev,\r\nusb_rcvbulkpipe(pHwData->udev, 3),\r\npRxBufferAddress, MAX_USB_RX_BUFFER,\r\nWb35Rx_Complete, hw);\r\npWb35Rx->EP3vm_state = VM_RUNNING;\r\nretv = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retv != 0) {\r\nprintk("Rx URB sending error\n");\r\ngoto error;\r\n}\r\nreturn;\r\nerror:\r\npWb35Rx->EP3vm_state = VM_STOP;\r\natomic_dec(&pWb35Rx->RxFireCounter);\r\n}\r\nvoid Wb35Rx_start(struct ieee80211_hw *hw)\r\n{\r\nstruct wbsoft_priv *priv = hw->priv;\r\nstruct hw_data *pHwData = &priv->sHwData;\r\nstruct wb35_rx *pWb35Rx = &pHwData->Wb35Rx;\r\nif (atomic_inc_return(&pWb35Rx->RxFireCounter) == 1) {\r\npWb35Rx->EP3vm_state = VM_RUNNING;\r\nWb35Rx(hw);\r\n} else\r\natomic_dec(&pWb35Rx->RxFireCounter);\r\n}\r\nstatic void Wb35Rx_reset_descriptor(struct hw_data *pHwData)\r\n{\r\nstruct wb35_rx *pWb35Rx = &pHwData->Wb35Rx;\r\nu32 i;\r\npWb35Rx->ByteReceived = 0;\r\npWb35Rx->RxProcessIndex = 0;\r\npWb35Rx->RxBufferId = 0;\r\npWb35Rx->EP3vm_state = VM_STOP;\r\npWb35Rx->rx_halt = 0;\r\nfor (i = 0; i < MAX_USB_RX_BUFFER_NUMBER; i++)\r\npWb35Rx->RxOwner[i] = 1;\r\n}\r\nunsigned char Wb35Rx_initial(struct hw_data *pHwData)\r\n{\r\nstruct wb35_rx *pWb35Rx = &pHwData->Wb35Rx;\r\nWb35Rx_reset_descriptor(pHwData);\r\npWb35Rx->RxUrb = usb_alloc_urb(0, GFP_ATOMIC);\r\nreturn !!pWb35Rx->RxUrb;\r\n}\r\nvoid Wb35Rx_stop(struct hw_data *pHwData)\r\n{\r\nstruct wb35_rx *pWb35Rx = &pHwData->Wb35Rx;\r\nif (pWb35Rx->EP3vm_state == VM_RUNNING) {\r\nusb_unlink_urb(pWb35Rx->RxUrb);\r\npr_debug("EP3 Rx stop\n");\r\n}\r\n}\r\nvoid Wb35Rx_destroy(struct hw_data *pHwData)\r\n{\r\nstruct wb35_rx *pWb35Rx = &pHwData->Wb35Rx;\r\ndo {\r\nmsleep(10);\r\n} while (pWb35Rx->EP3vm_state != VM_STOP);\r\nmsleep(10);\r\nif (pWb35Rx->RxUrb)\r\nusb_free_urb(pWb35Rx->RxUrb);\r\npr_debug("Wb35Rx_destroy OK\n");\r\n}
