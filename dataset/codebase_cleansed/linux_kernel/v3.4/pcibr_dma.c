static dma_addr_t\r\npcibr_dmamap_ate32(struct pcidev_info *info,\r\nu64 paddr, size_t req_size, u64 flags, int dma_flags)\r\n{\r\nstruct pcidev_info *pcidev_info = info->pdi_host_pcidev_info;\r\nstruct pcibus_info *pcibus_info = (struct pcibus_info *)pcidev_info->\r\npdi_pcibus_info;\r\nu8 internal_device = (PCI_SLOT(pcidev_info->pdi_host_pcidev_info->\r\npdi_linux_pcidev->devfn)) - 1;\r\nint ate_count;\r\nint ate_index;\r\nu64 ate_flags = flags | PCI32_ATE_V;\r\nu64 ate;\r\nu64 pci_addr;\r\nu64 xio_addr;\r\nu64 offset;\r\nif (IS_PIC_SOFT(pcibus_info) && IS_PCIX(pcibus_info)) {\r\nreturn 0;\r\n}\r\nif (!(MINIMAL_ATE_FLAG(paddr, req_size))) {\r\nate_count = IOPG((IOPGSIZE - 1)\r\n+req_size\r\n- 1) + 1;\r\n} else {\r\nate_count = IOPG(req_size\r\n- 1) + 1;\r\n}\r\nate_index = pcibr_ate_alloc(pcibus_info, ate_count);\r\nif (ate_index < 0)\r\nreturn 0;\r\nif (IS_PCIX(pcibus_info))\r\nate_flags &= ~(PCI32_ATE_PREF);\r\nif (SN_DMA_ADDRTYPE(dma_flags == SN_DMA_ADDR_PHYS))\r\nxio_addr = IS_PIC_SOFT(pcibus_info) ? PHYS_TO_DMA(paddr) :\r\nPHYS_TO_TIODMA(paddr);\r\nelse\r\nxio_addr = paddr;\r\noffset = IOPGOFF(xio_addr);\r\nate = ate_flags | (xio_addr - offset);\r\nif (IS_PIC_SOFT(pcibus_info)) {\r\nate |= (pcibus_info->pbi_hub_xid << PIC_ATE_TARGETID_SHFT);\r\n}\r\nif (dma_flags & SN_DMA_MSI) {\r\nate |= PCI32_ATE_MSI;\r\nif (IS_TIOCP_SOFT(pcibus_info))\r\nate |= PCI32_ATE_PIO;\r\n}\r\nate_write(pcibus_info, ate_index, ate_count, ate);\r\npci_addr = PCI32_MAPPED_BASE + offset + IOPGSIZE * ate_index;\r\nif (pcibus_info->pbi_devreg[internal_device] & PCIBR_DEV_SWAP_DIR)\r\nATE_SWAP_ON(pci_addr);\r\nreturn pci_addr;\r\n}\r\nstatic dma_addr_t\r\npcibr_dmatrans_direct64(struct pcidev_info * info, u64 paddr,\r\nu64 dma_attributes, int dma_flags)\r\n{\r\nstruct pcibus_info *pcibus_info = (struct pcibus_info *)\r\n((info->pdi_host_pcidev_info)->pdi_pcibus_info);\r\nu64 pci_addr;\r\nif (SN_DMA_ADDRTYPE(dma_flags) == SN_DMA_ADDR_PHYS)\r\npci_addr = IS_PIC_SOFT(pcibus_info) ?\r\nPHYS_TO_DMA(paddr) :\r\nPHYS_TO_TIODMA(paddr);\r\nelse\r\npci_addr = paddr;\r\npci_addr |= dma_attributes;\r\nif (IS_PCIX(pcibus_info))\r\npci_addr &= ~PCI64_ATTR_PREF;\r\nif (IS_PIC_SOFT(pcibus_info)) {\r\npci_addr |=\r\n((u64) pcibus_info->\r\npbi_hub_xid << PIC_PCI64_ATTR_TARG_SHFT);\r\n} else\r\npci_addr |= (dma_flags & SN_DMA_MSI) ?\r\nTIOCP_PCI64_CMDTYPE_MSI :\r\nTIOCP_PCI64_CMDTYPE_MEM;\r\nif (!IS_PCIX(pcibus_info) && PCI_FUNC(info->pdi_linux_pcidev->devfn))\r\npci_addr |= PCI64_ATTR_VIRTUAL;\r\nreturn pci_addr;\r\n}\r\nstatic dma_addr_t\r\npcibr_dmatrans_direct32(struct pcidev_info * info,\r\nu64 paddr, size_t req_size, u64 flags, int dma_flags)\r\n{\r\nstruct pcidev_info *pcidev_info = info->pdi_host_pcidev_info;\r\nstruct pcibus_info *pcibus_info = (struct pcibus_info *)pcidev_info->\r\npdi_pcibus_info;\r\nu64 xio_addr;\r\nu64 xio_base;\r\nu64 offset;\r\nu64 endoff;\r\nif (IS_PCIX(pcibus_info)) {\r\nreturn 0;\r\n}\r\nif (dma_flags & SN_DMA_MSI)\r\nreturn 0;\r\nif (SN_DMA_ADDRTYPE(dma_flags) == SN_DMA_ADDR_PHYS)\r\nxio_addr = IS_PIC_SOFT(pcibus_info) ? PHYS_TO_DMA(paddr) :\r\nPHYS_TO_TIODMA(paddr);\r\nelse\r\nxio_addr = paddr;\r\nxio_base = pcibus_info->pbi_dir_xbase;\r\noffset = xio_addr - xio_base;\r\nendoff = req_size + offset;\r\nif ((req_size > (1ULL << 31)) ||\r\n(xio_addr < xio_base) ||\r\n(endoff > (1ULL << 31))) {\r\nreturn 0;\r\n}\r\nreturn PCI32_DIRECT_BASE | offset;\r\n}\r\nvoid\r\npcibr_dma_unmap(struct pci_dev *hwdev, dma_addr_t dma_handle, int direction)\r\n{\r\nstruct pcidev_info *pcidev_info = SN_PCIDEV_INFO(hwdev);\r\nstruct pcibus_info *pcibus_info =\r\n(struct pcibus_info *)pcidev_info->pdi_pcibus_info;\r\nif (IS_PCI32_MAPPED(dma_handle)) {\r\nint ate_index;\r\nate_index =\r\nIOPG((ATE_SWAP_OFF(dma_handle) - PCI32_MAPPED_BASE));\r\npcibr_ate_free(pcibus_info, ate_index);\r\n}\r\n}\r\nvoid sn_dma_flush(u64 addr)\r\n{\r\nnasid_t nasid;\r\nint is_tio;\r\nint wid_num;\r\nint i, j;\r\nunsigned long flags;\r\nu64 itte;\r\nstruct hubdev_info *hubinfo;\r\nstruct sn_flush_device_kernel *p;\r\nstruct sn_flush_device_common *common;\r\nstruct sn_flush_nasid_entry *flush_nasid_list;\r\nif (!sn_ioif_inited)\r\nreturn;\r\nnasid = NASID_GET(addr);\r\nif (-1 == nasid_to_cnodeid(nasid))\r\nreturn;\r\nhubinfo = (NODEPDA(nasid_to_cnodeid(nasid)))->pdinfo;\r\nBUG_ON(!hubinfo);\r\nflush_nasid_list = &hubinfo->hdi_flush_nasid_list;\r\nif (flush_nasid_list->widget_p == NULL)\r\nreturn;\r\nis_tio = (nasid & 1);\r\nif (is_tio) {\r\nint itte_index;\r\nif (TIO_HWIN(addr))\r\nitte_index = 0;\r\nelse if (TIO_BWIN_WINDOWNUM(addr))\r\nitte_index = TIO_BWIN_WINDOWNUM(addr);\r\nelse\r\nitte_index = -1;\r\nif (itte_index >= 0) {\r\nitte = flush_nasid_list->iio_itte[itte_index];\r\nif (! TIO_ITTE_VALID(itte))\r\nreturn;\r\nwid_num = TIO_ITTE_WIDGET(itte);\r\n} else\r\nwid_num = TIO_SWIN_WIDGETNUM(addr);\r\n} else {\r\nif (BWIN_WINDOWNUM(addr)) {\r\nitte = flush_nasid_list->iio_itte[BWIN_WINDOWNUM(addr)];\r\nwid_num = IIO_ITTE_WIDGET(itte);\r\n} else\r\nwid_num = SWIN_WIDGETNUM(addr);\r\n}\r\nif (flush_nasid_list->widget_p[wid_num] == NULL)\r\nreturn;\r\np = &flush_nasid_list->widget_p[wid_num][0];\r\nfor (i = 0; i < DEV_PER_WIDGET; i++,p++) {\r\ncommon = p->common;\r\nfor (j = 0; j < PCI_ROM_RESOURCE; j++) {\r\nif (common->sfdl_bar_list[j].start == 0)\r\nbreak;\r\nif (addr >= common->sfdl_bar_list[j].start\r\n&& addr <= common->sfdl_bar_list[j].end)\r\nbreak;\r\n}\r\nif (j < PCI_ROM_RESOURCE && common->sfdl_bar_list[j].start != 0)\r\nbreak;\r\n}\r\nif (i == DEV_PER_WIDGET)\r\nreturn;\r\nif (is_tio) {\r\nu32 tio_id = HUB_L(TIO_IOSPACE_ADDR(nasid, TIO_NODE_ID));\r\nu32 revnum = XWIDGET_PART_REV_NUM(tio_id);\r\nif ((1 << XWIDGET_PART_REV_NUM_REV(revnum)) & PV907516) {\r\nreturn;\r\n} else {\r\npcireg_wrb_flush_get(common->sfdl_pcibus_info,\r\n(common->sfdl_slot - 1));\r\n}\r\n} else {\r\nspin_lock_irqsave(&p->sfdl_flush_lock, flags);\r\n*common->sfdl_flush_addr = 0;\r\n*(volatile u32 *)(common->sfdl_force_int_addr) = 1;\r\nwhile (*(common->sfdl_flush_addr) != 0x10f)\r\ncpu_relax();\r\nspin_unlock_irqrestore(&p->sfdl_flush_lock, flags);\r\n}\r\nreturn;\r\n}\r\ndma_addr_t\r\npcibr_dma_map(struct pci_dev * hwdev, unsigned long phys_addr, size_t size, int dma_flags)\r\n{\r\ndma_addr_t dma_handle;\r\nstruct pcidev_info *pcidev_info = SN_PCIDEV_INFO(hwdev);\r\nif (hwdev->dma_mask < 0x7fffffff) {\r\nreturn 0;\r\n}\r\nif (hwdev->dma_mask == ~0UL) {\r\ndma_handle = pcibr_dmatrans_direct64(pcidev_info, phys_addr,\r\nPCI64_ATTR_PREF, dma_flags);\r\n} else {\r\ndma_handle = pcibr_dmatrans_direct32(pcidev_info, phys_addr,\r\nsize, 0, dma_flags);\r\nif (!dma_handle) {\r\ndma_handle = pcibr_dmamap_ate32(pcidev_info, phys_addr,\r\nsize, PCI32_ATE_PREF,\r\ndma_flags);\r\n}\r\n}\r\nreturn dma_handle;\r\n}\r\ndma_addr_t\r\npcibr_dma_map_consistent(struct pci_dev * hwdev, unsigned long phys_addr,\r\nsize_t size, int dma_flags)\r\n{\r\ndma_addr_t dma_handle;\r\nstruct pcidev_info *pcidev_info = SN_PCIDEV_INFO(hwdev);\r\nif (hwdev->dev.coherent_dma_mask == ~0UL) {\r\ndma_handle = pcibr_dmatrans_direct64(pcidev_info, phys_addr,\r\nPCI64_ATTR_BAR, dma_flags);\r\n} else {\r\ndma_handle = (dma_addr_t) pcibr_dmamap_ate32(pcidev_info,\r\nphys_addr, size,\r\nPCI32_ATE_BAR, dma_flags);\r\n}\r\nreturn dma_handle;\r\n}
