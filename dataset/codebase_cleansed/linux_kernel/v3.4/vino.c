static void vino_free_buffer_with_count(struct vino_framebuffer *fb,\r\nunsigned int count)\r\n{\r\nunsigned int i;\r\ndprintk("vino_free_buffer_with_count(): count = %d\n", count);\r\nfor (i = 0; i < count; i++) {\r\nClearPageReserved(virt_to_page((void *)fb->desc_table.virtual[i]));\r\ndma_unmap_single(NULL,\r\nfb->desc_table.dma_cpu[VINO_PAGE_RATIO * i],\r\nPAGE_SIZE, DMA_FROM_DEVICE);\r\nfree_page(fb->desc_table.virtual[i]);\r\n}\r\ndma_free_coherent(NULL,\r\nVINO_PAGE_RATIO * (fb->desc_table.page_count + 4) *\r\nsizeof(dma_addr_t), (void *)fb->desc_table.dma_cpu,\r\nfb->desc_table.dma);\r\nkfree(fb->desc_table.virtual);\r\nmemset(fb, 0, sizeof(struct vino_framebuffer));\r\n}\r\nstatic void vino_free_buffer(struct vino_framebuffer *fb)\r\n{\r\nvino_free_buffer_with_count(fb, fb->desc_table.page_count);\r\n}\r\nstatic int vino_allocate_buffer(struct vino_framebuffer *fb,\r\nunsigned int size)\r\n{\r\nunsigned int count, i, j;\r\nint ret = 0;\r\ndprintk("vino_allocate_buffer():\n");\r\nif (size < 1)\r\nreturn -EINVAL;\r\nmemset(fb, 0, sizeof(struct vino_framebuffer));\r\ncount = ((size / PAGE_SIZE) + 4) & ~3;\r\ndprintk("vino_allocate_buffer(): size = %d, count = %d\n",\r\nsize, count);\r\nfb->desc_table.virtual =\r\nkmalloc(count * sizeof(unsigned long), GFP_KERNEL);\r\nif (!fb->desc_table.virtual)\r\nreturn -ENOMEM;\r\nfb->desc_table.dma_cpu =\r\ndma_alloc_coherent(NULL, VINO_PAGE_RATIO * (count + 4) *\r\nsizeof(dma_addr_t), &fb->desc_table.dma,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!fb->desc_table.dma_cpu) {\r\nret = -ENOMEM;\r\ngoto out_free_virtual;\r\n}\r\nfor (i = 0; i < count; i++) {\r\ndma_addr_t dma_data_addr;\r\nfb->desc_table.virtual[i] =\r\nget_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!fb->desc_table.virtual[i]) {\r\nret = -ENOBUFS;\r\nbreak;\r\n}\r\ndma_data_addr =\r\ndma_map_single(NULL,\r\n(void *)fb->desc_table.virtual[i],\r\nPAGE_SIZE, DMA_FROM_DEVICE);\r\nfor (j = 0; j < VINO_PAGE_RATIO; j++) {\r\nfb->desc_table.dma_cpu[VINO_PAGE_RATIO * i + j] =\r\ndma_data_addr + VINO_PAGE_SIZE * j;\r\n}\r\nSetPageReserved(virt_to_page((void *)fb->desc_table.virtual[i]));\r\n}\r\nfb->desc_table.page_count = count;\r\nif (ret) {\r\nvino_free_buffer_with_count(fb, i);\r\nreturn ret;\r\n}\r\nfb->size = count * PAGE_SIZE;\r\nfb->data_format = VINO_DATA_FMT_NONE;\r\nfb->desc_table.dma_cpu[VINO_PAGE_RATIO * count] = VINO_DESC_STOP;\r\nreturn 0;\r\nout_free_virtual:\r\nkfree(fb->desc_table.virtual);\r\nreturn ret;\r\n}\r\nstatic void vino_sync_buffer(struct vino_framebuffer *fb)\r\n{\r\nint i;\r\ndprintk("vino_sync_buffer():\n");\r\nfor (i = 0; i < fb->desc_table.page_count; i++)\r\ndma_sync_single_for_cpu(NULL,\r\nfb->desc_table.dma_cpu[VINO_PAGE_RATIO * i],\r\nPAGE_SIZE, DMA_FROM_DEVICE);\r\n}\r\nstatic inline void vino_fifo_init(struct vino_framebuffer_fifo *f,\r\nunsigned int length)\r\n{\r\nf->length = 0;\r\nf->used = 0;\r\nf->head = 0;\r\nf->tail = 0;\r\nif (length > VINO_FRAMEBUFFER_COUNT_MAX)\r\nlength = VINO_FRAMEBUFFER_COUNT_MAX;\r\nf->length = length;\r\n}\r\nstatic inline int vino_fifo_has_id(struct vino_framebuffer_fifo *f,\r\nunsigned int id)\r\n{\r\nunsigned int i;\r\nfor (i = f->head; i == (f->tail - 1); i = (i + 1) % f->length) {\r\nif (f->data[i] == id)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline unsigned int vino_fifo_get_used(struct vino_framebuffer_fifo *f)\r\n{\r\nreturn f->used;\r\n}\r\nstatic int vino_fifo_enqueue(struct vino_framebuffer_fifo *f, unsigned int id)\r\n{\r\nif (id >= f->length) {\r\nreturn VINO_QUEUE_ERROR;\r\n}\r\nif (vino_fifo_has_id(f, id)) {\r\nreturn VINO_QUEUE_ERROR;\r\n}\r\nif (f->used < f->length) {\r\nf->data[f->tail] = id;\r\nf->tail = (f->tail + 1) % f->length;\r\nf->used++;\r\n} else {\r\nreturn VINO_QUEUE_ERROR;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vino_fifo_peek(struct vino_framebuffer_fifo *f, unsigned int *id)\r\n{\r\nif (f->used > 0) {\r\n*id = f->data[f->head];\r\n} else {\r\nreturn VINO_QUEUE_ERROR;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vino_fifo_dequeue(struct vino_framebuffer_fifo *f, unsigned int *id)\r\n{\r\nif (f->used > 0) {\r\n*id = f->data[f->head];\r\nf->head = (f->head + 1) % f->length;\r\nf->used--;\r\n} else {\r\nreturn VINO_QUEUE_ERROR;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vino_queue_free_with_count(struct vino_framebuffer_queue *q,\r\nunsigned int length)\r\n{\r\nunsigned int i;\r\nq->length = 0;\r\nmemset(&q->in, 0, sizeof(struct vino_framebuffer_fifo));\r\nmemset(&q->out, 0, sizeof(struct vino_framebuffer_fifo));\r\nfor (i = 0; i < length; i++) {\r\ndprintk("vino_queue_free_with_count(): freeing buffer %d\n",\r\ni);\r\nvino_free_buffer(q->buffer[i]);\r\nkfree(q->buffer[i]);\r\n}\r\nq->type = VINO_MEMORY_NONE;\r\nq->magic = 0;\r\n}\r\nstatic void vino_queue_free(struct vino_framebuffer_queue *q)\r\n{\r\ndprintk("vino_queue_free():\n");\r\nif (q->magic != VINO_QUEUE_MAGIC)\r\nreturn;\r\nif (q->type != VINO_MEMORY_MMAP)\r\nreturn;\r\nmutex_lock(&q->queue_mutex);\r\nvino_queue_free_with_count(q, q->length);\r\nmutex_unlock(&q->queue_mutex);\r\n}\r\nstatic int vino_queue_init(struct vino_framebuffer_queue *q,\r\nunsigned int *length)\r\n{\r\nunsigned int i;\r\nint ret = 0;\r\ndprintk("vino_queue_init(): length = %d\n", *length);\r\nif (q->magic == VINO_QUEUE_MAGIC) {\r\ndprintk("vino_queue_init(): queue already initialized!\n");\r\nreturn -EINVAL;\r\n}\r\nif (q->type != VINO_MEMORY_NONE) {\r\ndprintk("vino_queue_init(): queue already initialized!\n");\r\nreturn -EINVAL;\r\n}\r\nif (*length < 1)\r\nreturn -EINVAL;\r\nmutex_lock(&q->queue_mutex);\r\nif (*length > VINO_FRAMEBUFFER_COUNT_MAX)\r\n*length = VINO_FRAMEBUFFER_COUNT_MAX;\r\nq->length = 0;\r\nfor (i = 0; i < *length; i++) {\r\ndprintk("vino_queue_init(): allocating buffer %d\n", i);\r\nq->buffer[i] = kmalloc(sizeof(struct vino_framebuffer),\r\nGFP_KERNEL);\r\nif (!q->buffer[i]) {\r\ndprintk("vino_queue_init(): kmalloc() failed\n");\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nret = vino_allocate_buffer(q->buffer[i],\r\nVINO_FRAMEBUFFER_SIZE);\r\nif (ret) {\r\nkfree(q->buffer[i]);\r\ndprintk("vino_queue_init(): "\r\n"vino_allocate_buffer() failed\n");\r\nbreak;\r\n}\r\nq->buffer[i]->id = i;\r\nif (i > 0) {\r\nq->buffer[i]->offset = q->buffer[i - 1]->offset +\r\nq->buffer[i - 1]->size;\r\n} else {\r\nq->buffer[i]->offset = 0;\r\n}\r\nspin_lock_init(&q->buffer[i]->state_lock);\r\ndprintk("vino_queue_init(): buffer = %d, offset = %d, "\r\n"size = %d\n", i, q->buffer[i]->offset,\r\nq->buffer[i]->size);\r\n}\r\nif (ret) {\r\nvino_queue_free_with_count(q, i);\r\n*length = 0;\r\n} else {\r\nq->length = *length;\r\nvino_fifo_init(&q->in, q->length);\r\nvino_fifo_init(&q->out, q->length);\r\nq->type = VINO_MEMORY_MMAP;\r\nq->magic = VINO_QUEUE_MAGIC;\r\n}\r\nmutex_unlock(&q->queue_mutex);\r\nreturn ret;\r\n}\r\nstatic struct vino_framebuffer *vino_queue_add(struct\r\nvino_framebuffer_queue *q,\r\nunsigned int id)\r\n{\r\nstruct vino_framebuffer *ret = NULL;\r\nunsigned int total;\r\nunsigned long flags;\r\ndprintk("vino_queue_add(): id = %d\n", id);\r\nif (q->magic != VINO_QUEUE_MAGIC) {\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&q->queue_lock, flags);\r\nif (q->length == 0)\r\ngoto out;\r\nif (id >= q->length)\r\ngoto out;\r\ntotal = vino_fifo_get_used(&q->in) +\r\nvino_fifo_get_used(&q->out);\r\nif (total >= q->length)\r\ngoto out;\r\nif (vino_fifo_enqueue(&q->in, id))\r\ngoto out;\r\nret = q->buffer[id];\r\nout:\r\nspin_unlock_irqrestore(&q->queue_lock, flags);\r\nreturn ret;\r\n}\r\nstatic struct vino_framebuffer *vino_queue_transfer(struct\r\nvino_framebuffer_queue *q)\r\n{\r\nstruct vino_framebuffer *ret = NULL;\r\nstruct vino_framebuffer *fb;\r\nint id;\r\nunsigned long flags;\r\ndprintk("vino_queue_transfer():\n");\r\nif (q->magic != VINO_QUEUE_MAGIC) {\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&q->queue_lock, flags);\r\nif (q->length == 0)\r\ngoto out;\r\nif (vino_fifo_dequeue(&q->in, &id)) {\r\ngoto out;\r\n}\r\ndprintk("vino_queue_transfer(): id = %d\n", id);\r\nfb = q->buffer[id];\r\nif (vino_fifo_enqueue(&q->out, id)) {\r\nprintk(KERN_ERR "vino_queue_transfer(): "\r\n"outgoing queue is full, this shouldn't happen!\n");\r\ngoto out;\r\n}\r\nret = fb;\r\nout:\r\nspin_unlock_irqrestore(&q->queue_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int vino_queue_incoming_contains(struct vino_framebuffer_queue *q,\r\nunsigned int id)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nif (q->magic != VINO_QUEUE_MAGIC) {\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&q->queue_lock, flags);\r\nif (q->length == 0)\r\ngoto out;\r\nret = vino_fifo_has_id(&q->in, id);\r\nout:\r\nspin_unlock_irqrestore(&q->queue_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int vino_queue_outgoing_contains(struct vino_framebuffer_queue *q,\r\nunsigned int id)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nif (q->magic != VINO_QUEUE_MAGIC) {\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&q->queue_lock, flags);\r\nif (q->length == 0)\r\ngoto out;\r\nret = vino_fifo_has_id(&q->out, id);\r\nout:\r\nspin_unlock_irqrestore(&q->queue_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int vino_queue_get_incoming(struct vino_framebuffer_queue *q,\r\nunsigned int *used)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nif (q->magic != VINO_QUEUE_MAGIC) {\r\nreturn VINO_QUEUE_ERROR;\r\n}\r\nspin_lock_irqsave(&q->queue_lock, flags);\r\nif (q->length == 0) {\r\nret = VINO_QUEUE_ERROR;\r\ngoto out;\r\n}\r\n*used = vino_fifo_get_used(&q->in);\r\nout:\r\nspin_unlock_irqrestore(&q->queue_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int vino_queue_get_outgoing(struct vino_framebuffer_queue *q,\r\nunsigned int *used)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nif (q->magic != VINO_QUEUE_MAGIC) {\r\nreturn VINO_QUEUE_ERROR;\r\n}\r\nspin_lock_irqsave(&q->queue_lock, flags);\r\nif (q->length == 0) {\r\nret = VINO_QUEUE_ERROR;\r\ngoto out;\r\n}\r\n*used = vino_fifo_get_used(&q->out);\r\nout:\r\nspin_unlock_irqrestore(&q->queue_lock, flags);\r\nreturn ret;\r\n}\r\nstatic struct vino_framebuffer *vino_queue_peek(struct\r\nvino_framebuffer_queue *q,\r\nunsigned int *id)\r\n{\r\nstruct vino_framebuffer *ret = NULL;\r\nunsigned long flags;\r\nif (q->magic != VINO_QUEUE_MAGIC) {\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&q->queue_lock, flags);\r\nif (q->length == 0)\r\ngoto out;\r\nif (vino_fifo_peek(&q->in, id)) {\r\ngoto out;\r\n}\r\nret = q->buffer[*id];\r\nout:\r\nspin_unlock_irqrestore(&q->queue_lock, flags);\r\nreturn ret;\r\n}\r\nstatic struct vino_framebuffer *vino_queue_remove(struct\r\nvino_framebuffer_queue *q,\r\nunsigned int *id)\r\n{\r\nstruct vino_framebuffer *ret = NULL;\r\nunsigned long flags;\r\ndprintk("vino_queue_remove():\n");\r\nif (q->magic != VINO_QUEUE_MAGIC) {\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&q->queue_lock, flags);\r\nif (q->length == 0)\r\ngoto out;\r\nif (vino_fifo_dequeue(&q->out, id)) {\r\ngoto out;\r\n}\r\ndprintk("vino_queue_remove(): id = %d\n", *id);\r\nret = q->buffer[*id];\r\nout:\r\nspin_unlock_irqrestore(&q->queue_lock, flags);\r\nreturn ret;\r\n}\r\nstatic struct\r\nvino_framebuffer *vino_queue_get_buffer(struct vino_framebuffer_queue *q,\r\nunsigned int id)\r\n{\r\nstruct vino_framebuffer *ret = NULL;\r\nunsigned long flags;\r\nif (q->magic != VINO_QUEUE_MAGIC) {\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&q->queue_lock, flags);\r\nif (q->length == 0)\r\ngoto out;\r\nif (id >= q->length)\r\ngoto out;\r\nret = q->buffer[id];\r\nout:\r\nspin_unlock_irqrestore(&q->queue_lock, flags);\r\nreturn ret;\r\n}\r\nstatic unsigned int vino_queue_get_length(struct vino_framebuffer_queue *q)\r\n{\r\nunsigned int length = 0;\r\nunsigned long flags;\r\nif (q->magic != VINO_QUEUE_MAGIC) {\r\nreturn length;\r\n}\r\nspin_lock_irqsave(&q->queue_lock, flags);\r\nlength = q->length;\r\nspin_unlock_irqrestore(&q->queue_lock, flags);\r\nreturn length;\r\n}\r\nstatic int vino_queue_has_mapped_buffers(struct vino_framebuffer_queue *q)\r\n{\r\nunsigned int i;\r\nint ret = 0;\r\nunsigned long flags;\r\nif (q->magic != VINO_QUEUE_MAGIC) {\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&q->queue_lock, flags);\r\nfor (i = 0; i < q->length; i++) {\r\nif (q->buffer[i]->map_count > 0) {\r\nret = 1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&q->queue_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void vino_update_line_size(struct vino_channel_settings *vcs)\r\n{\r\nunsigned int w = vcs->clipping.right - vcs->clipping.left;\r\nunsigned int d = vcs->decimation;\r\nunsigned int bpp = vino_data_formats[vcs->data_format].bpp;\r\nunsigned int lsize;\r\ndprintk("update_line_size(): before: w = %d, d = %d, "\r\n"line_size = %d\n", w, d, vcs->line_size);\r\nlsize = (bpp * (w / d)) & ~7;\r\nw = (lsize / bpp) * d;\r\nvcs->clipping.right = vcs->clipping.left + w;\r\nvcs->line_size = lsize;\r\ndprintk("update_line_size(): after: w = %d, d = %d, "\r\n"line_size = %d\n", w, d, vcs->line_size);\r\n}\r\nstatic void vino_set_clipping(struct vino_channel_settings *vcs,\r\nunsigned int x, unsigned int y,\r\nunsigned int w, unsigned int h)\r\n{\r\nunsigned int maxwidth, maxheight;\r\nunsigned int d;\r\nmaxwidth = vino_data_norms[vcs->data_norm].width;\r\nmaxheight = vino_data_norms[vcs->data_norm].height;\r\nd = vcs->decimation;\r\ny &= ~1;\r\nif (x > maxwidth) {\r\nx = 0;\r\n}\r\nif (y > maxheight) {\r\ny = 0;\r\n}\r\nif (((w / d) < VINO_MIN_WIDTH)\r\n|| ((h / d) < VINO_MIN_HEIGHT)) {\r\nw = VINO_MIN_WIDTH * d;\r\nh = VINO_MIN_HEIGHT * d;\r\n}\r\nif ((x + w) > maxwidth) {\r\nw = maxwidth - x;\r\nif ((w / d) < VINO_MIN_WIDTH)\r\nx = maxwidth - VINO_MIN_WIDTH * d;\r\n}\r\nif ((y + h) > maxheight) {\r\nh = maxheight - y;\r\nif ((h / d) < VINO_MIN_HEIGHT)\r\ny = maxheight - VINO_MIN_HEIGHT * d;\r\n}\r\nvcs->clipping.left = x;\r\nvcs->clipping.top = y;\r\nvcs->clipping.right = x + w;\r\nvcs->clipping.bottom = y + h;\r\nvino_update_line_size(vcs);\r\ndprintk("clipping %d, %d, %d, %d / %d - %d\n",\r\nvcs->clipping.left, vcs->clipping.top, vcs->clipping.right,\r\nvcs->clipping.bottom, vcs->decimation, vcs->line_size);\r\n}\r\nstatic inline void vino_set_default_clipping(struct vino_channel_settings *vcs)\r\n{\r\nvino_set_clipping(vcs, 0, 0, vino_data_norms[vcs->data_norm].width,\r\nvino_data_norms[vcs->data_norm].height);\r\n}\r\nstatic void vino_set_scaling(struct vino_channel_settings *vcs,\r\nunsigned int w, unsigned int h)\r\n{\r\nunsigned int x, y, curw, curh, d;\r\nx = vcs->clipping.left;\r\ny = vcs->clipping.top;\r\ncurw = vcs->clipping.right - vcs->clipping.left;\r\ncurh = vcs->clipping.bottom - vcs->clipping.top;\r\nd = max(curw / w, curh / h);\r\ndprintk("scaling w: %d, h: %d, curw: %d, curh: %d, d: %d\n",\r\nw, h, curw, curh, d);\r\nif (d < 1) {\r\nd = 1;\r\n} else if (d > 8) {\r\nd = 8;\r\n}\r\nvcs->decimation = d;\r\nvino_set_clipping(vcs, x, y, w * d, h * d);\r\ndprintk("scaling %d, %d, %d, %d / %d - %d\n", vcs->clipping.left,\r\nvcs->clipping.top, vcs->clipping.right, vcs->clipping.bottom,\r\nvcs->decimation, vcs->line_size);\r\n}\r\nstatic inline void vino_set_default_scaling(struct vino_channel_settings *vcs)\r\n{\r\nvino_set_scaling(vcs, vcs->clipping.right - vcs->clipping.left,\r\nvcs->clipping.bottom - vcs->clipping.top);\r\n}\r\nstatic void vino_set_framerate(struct vino_channel_settings *vcs,\r\nunsigned int fps)\r\n{\r\nunsigned int mask;\r\nswitch (vcs->data_norm) {\r\ncase VINO_DATA_NORM_NTSC:\r\ncase VINO_DATA_NORM_D1:\r\nfps = (unsigned int)(fps / 6) * 6;\r\nif (fps < vino_data_norms[vcs->data_norm].fps_min)\r\nfps = vino_data_norms[vcs->data_norm].fps_min;\r\nif (fps > vino_data_norms[vcs->data_norm].fps_max)\r\nfps = vino_data_norms[vcs->data_norm].fps_max;\r\nswitch (fps) {\r\ncase 6:\r\nmask = 0x003;\r\nbreak;\r\ncase 12:\r\nmask = 0x0c3;\r\nbreak;\r\ncase 18:\r\nmask = 0x333;\r\nbreak;\r\ncase 24:\r\nmask = 0x3ff;\r\nbreak;\r\ncase 30:\r\nmask = 0xfff;\r\nbreak;\r\ndefault:\r\nmask = VINO_FRAMERT_FULL;\r\n}\r\nvcs->framert_reg = VINO_FRAMERT_RT(mask);\r\nbreak;\r\ncase VINO_DATA_NORM_PAL:\r\ncase VINO_DATA_NORM_SECAM:\r\nfps = (unsigned int)(fps / 5) * 5;\r\nif (fps < vino_data_norms[vcs->data_norm].fps_min)\r\nfps = vino_data_norms[vcs->data_norm].fps_min;\r\nif (fps > vino_data_norms[vcs->data_norm].fps_max)\r\nfps = vino_data_norms[vcs->data_norm].fps_max;\r\nswitch (fps) {\r\ncase 5:\r\nmask = 0x003;\r\nbreak;\r\ncase 10:\r\nmask = 0x0c3;\r\nbreak;\r\ncase 15:\r\nmask = 0x333;\r\nbreak;\r\ncase 20:\r\nmask = 0x0ff;\r\nbreak;\r\ncase 25:\r\nmask = 0x3ff;\r\nbreak;\r\ndefault:\r\nmask = VINO_FRAMERT_FULL;\r\n}\r\nvcs->framert_reg = VINO_FRAMERT_RT(mask) | VINO_FRAMERT_PAL;\r\nbreak;\r\n}\r\nvcs->fps = fps;\r\n}\r\nstatic inline void vino_set_default_framerate(struct\r\nvino_channel_settings *vcs)\r\n{\r\nvino_set_framerate(vcs, vino_data_norms[vcs->data_norm].fps_max);\r\n}\r\nstatic int wait_xfer_done(struct i2c_algo_sgi_data *adap)\r\n{\r\nint i;\r\nfor (i = 0; i < adap->xfer_timeout; i++) {\r\nif ((adap->getctrl(adap->data) & SGI_I2C_XFER_BUSY) == 0)\r\nreturn 0;\r\nudelay(1);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int wait_ack(struct i2c_algo_sgi_data *adap)\r\n{\r\nint i;\r\nif (wait_xfer_done(adap))\r\nreturn -ETIMEDOUT;\r\nfor (i = 0; i < adap->ack_timeout; i++) {\r\nif ((adap->getctrl(adap->data) & SGI_I2C_NACK) == 0)\r\nreturn 0;\r\nudelay(1);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int force_idle(struct i2c_algo_sgi_data *adap)\r\n{\r\nint i;\r\nadap->setctrl(adap->data, SGI_I2C_FORCE_IDLE);\r\nfor (i = 0; i < adap->xfer_timeout; i++) {\r\nif ((adap->getctrl(adap->data) & SGI_I2C_NOT_IDLE) == 0)\r\ngoto out;\r\nudelay(1);\r\n}\r\nreturn -ETIMEDOUT;\r\nout:\r\nif (adap->getctrl(adap->data) & SGI_I2C_BUS_ERR)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int do_address(struct i2c_algo_sgi_data *adap, unsigned int addr,\r\nint rd)\r\n{\r\nif (rd)\r\nadap->setctrl(adap->data, SGI_I2C_NOT_IDLE);\r\nif (adap->getctrl(adap->data) & SGI_I2C_NOT_IDLE)\r\nif (force_idle(adap))\r\nreturn -EIO;\r\nadap->setctrl(adap->data,\r\nSGI_I2C_HOLD_BUS | SGI_I2C_WRITE | SGI_I2C_NOT_IDLE);\r\nif (rd)\r\naddr |= 1;\r\nadap->wdata(adap->data, addr);\r\nif (wait_ack(adap))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int i2c_read(struct i2c_algo_sgi_data *adap, unsigned char *buf,\r\nunsigned int len)\r\n{\r\nint i;\r\nadap->setctrl(adap->data,\r\nSGI_I2C_HOLD_BUS | SGI_I2C_READ | SGI_I2C_NOT_IDLE);\r\nfor (i = 0; i < len; i++) {\r\nif (wait_xfer_done(adap))\r\nreturn -EIO;\r\nbuf[i] = adap->rdata(adap->data);\r\n}\r\nadap->setctrl(adap->data, SGI_I2C_RELEASE_BUS | SGI_I2C_FORCE_IDLE);\r\nreturn 0;\r\n}\r\nstatic int i2c_write(struct i2c_algo_sgi_data *adap, unsigned char *buf,\r\nunsigned int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++) {\r\nadap->wdata(adap->data, buf[i]);\r\nif (wait_ack(adap))\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sgi_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct i2c_algo_sgi_data *adap = i2c_adap->algo_data;\r\nstruct i2c_msg *p;\r\nint i, err = 0;\r\nfor (i = 0; !err && i < num; i++) {\r\np = &msgs[i];\r\nerr = do_address(adap, p->addr, p->flags & I2C_M_RD);\r\nif (err || !p->len)\r\ncontinue;\r\nif (p->flags & I2C_M_RD)\r\nerr = i2c_read(adap, p->buf, p->len);\r\nelse\r\nerr = i2c_write(adap, p->buf, p->len);\r\n}\r\nreturn (err < 0) ? err : i;\r\n}\r\nstatic u32 sgi_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic unsigned i2c_vino_getctrl(void *data)\r\n{\r\nreturn vino->i2c_control;\r\n}\r\nstatic void i2c_vino_setctrl(void *data, unsigned val)\r\n{\r\nvino->i2c_control = val;\r\n}\r\nstatic unsigned i2c_vino_rdata(void *data)\r\n{\r\nreturn vino->i2c_data;\r\n}\r\nstatic void i2c_vino_wdata(void *data, unsigned val)\r\n{\r\nvino->i2c_data = val;\r\n}\r\nstatic int vino_dma_setup(struct vino_channel_settings *vcs,\r\nstruct vino_framebuffer *fb)\r\n{\r\nu32 ctrl, intr;\r\nstruct sgi_vino_channel *ch;\r\nconst struct vino_data_norm *norm;\r\ndprintk("vino_dma_setup():\n");\r\nvcs->field = 0;\r\nfb->frame_counter = 0;\r\nch = (vcs->channel == VINO_CHANNEL_A) ? &vino->a : &vino->b;\r\nnorm = &vino_data_norms[vcs->data_norm];\r\nch->page_index = 0;\r\nch->line_count = 0;\r\nch->line_size = vcs->line_size - 8;\r\nch->start_desc_tbl = fb->desc_table.dma;\r\nch->next_4_desc = fb->desc_table.dma;\r\nudelay(VINO_DESC_FETCH_DELAY);\r\ndprintk("vino_dma_setup(): start desc = %08x, next 4 desc = %08x\n",\r\nch->start_desc_tbl, ch->next_4_desc);\r\nch->alpha = vcs->alpha;\r\nch->clip_start = VINO_CLIP_ODD(norm->odd.top + vcs->clipping.top / 2) |\r\nVINO_CLIP_EVEN(norm->even.top +\r\nvcs->clipping.top / 2) |\r\nVINO_CLIP_X(vcs->clipping.left);\r\nch->clip_end = VINO_CLIP_ODD(norm->odd.top +\r\nvcs->clipping.bottom / 2 - 1) |\r\nVINO_CLIP_EVEN(norm->even.top +\r\nvcs->clipping.bottom / 2 - 1) |\r\nVINO_CLIP_X(vcs->clipping.right);\r\nfb->data_size = ((vcs->clipping.right - vcs->clipping.left) /\r\nvcs->decimation) *\r\n((vcs->clipping.bottom - vcs->clipping.top) /\r\nvcs->decimation) *\r\nvino_data_formats[vcs->data_format].bpp;\r\nch->frame_rate = vcs->framert_reg;\r\nctrl = vino->control;\r\nintr = vino->intr_status;\r\nif (vcs->channel == VINO_CHANNEL_A) {\r\nintr &= ~VINO_INTSTAT_A;\r\nctrl |= VINO_CTRL_A_INT;\r\nctrl |= VINO_CTRL_A_SYNC_ENBL;\r\nctrl |= VINO_CTRL_A_INTERLEAVE_ENBL;\r\nif (vcs->decimation < 2)\r\nctrl &= ~VINO_CTRL_A_DEC_ENBL;\r\nelse {\r\nctrl |= VINO_CTRL_A_DEC_ENBL;\r\nctrl &= ~VINO_CTRL_A_DEC_SCALE_MASK;\r\nctrl |= (vcs->decimation - 1) <<\r\nVINO_CTRL_A_DEC_SCALE_SHIFT;\r\n}\r\nif (vcs->input == VINO_INPUT_D1)\r\nctrl |= VINO_CTRL_A_SELECT;\r\nelse\r\nctrl &= ~VINO_CTRL_A_SELECT;\r\nctrl &= ~(VINO_CTRL_A_LUMA_ONLY | VINO_CTRL_A_RGB |\r\nVINO_CTRL_A_DITHER);\r\n} else {\r\nintr &= ~VINO_INTSTAT_B;\r\nctrl |= VINO_CTRL_B_INT;\r\nctrl |= VINO_CTRL_B_SYNC_ENBL;\r\nctrl |= VINO_CTRL_B_INTERLEAVE_ENBL;\r\nif (vcs->decimation < 2)\r\nctrl &= ~VINO_CTRL_B_DEC_ENBL;\r\nelse {\r\nctrl |= VINO_CTRL_B_DEC_ENBL;\r\nctrl &= ~VINO_CTRL_B_DEC_SCALE_MASK;\r\nctrl |= (vcs->decimation - 1) <<\r\nVINO_CTRL_B_DEC_SCALE_SHIFT;\r\n}\r\nif (vcs->input == VINO_INPUT_D1)\r\nctrl |= VINO_CTRL_B_SELECT;\r\nelse\r\nctrl &= ~VINO_CTRL_B_SELECT;\r\nctrl &= ~(VINO_CTRL_B_LUMA_ONLY | VINO_CTRL_B_RGB |\r\nVINO_CTRL_B_DITHER);\r\n}\r\nfb->data_format = vcs->data_format;\r\nswitch (vcs->data_format) {\r\ncase VINO_DATA_FMT_GREY:\r\nctrl |= (vcs->channel == VINO_CHANNEL_A) ?\r\nVINO_CTRL_A_LUMA_ONLY : VINO_CTRL_B_LUMA_ONLY;\r\nbreak;\r\ncase VINO_DATA_FMT_RGB32:\r\nctrl |= (vcs->channel == VINO_CHANNEL_A) ?\r\nVINO_CTRL_A_RGB : VINO_CTRL_B_RGB;\r\nbreak;\r\ncase VINO_DATA_FMT_YUV:\r\nbreak;\r\ncase VINO_DATA_FMT_RGB332:\r\nctrl |= (vcs->channel == VINO_CHANNEL_A) ?\r\nVINO_CTRL_A_RGB | VINO_CTRL_A_DITHER :\r\nVINO_CTRL_B_RGB | VINO_CTRL_B_DITHER;\r\nbreak;\r\n}\r\nvino->intr_status = intr;\r\nvino->control = ctrl;\r\nreturn 0;\r\n}\r\nstatic inline void vino_dma_start(struct vino_channel_settings *vcs)\r\n{\r\nu32 ctrl = vino->control;\r\ndprintk("vino_dma_start():\n");\r\nctrl |= (vcs->channel == VINO_CHANNEL_A) ?\r\nVINO_CTRL_A_DMA_ENBL : VINO_CTRL_B_DMA_ENBL;\r\nvino->control = ctrl;\r\n}\r\nstatic inline void vino_dma_stop(struct vino_channel_settings *vcs)\r\n{\r\nu32 ctrl = vino->control;\r\nctrl &= (vcs->channel == VINO_CHANNEL_A) ?\r\n~VINO_CTRL_A_DMA_ENBL : ~VINO_CTRL_B_DMA_ENBL;\r\nctrl &= (vcs->channel == VINO_CHANNEL_A) ?\r\n~VINO_CTRL_A_INT : ~VINO_CTRL_B_INT;\r\nvino->control = ctrl;\r\ndprintk("vino_dma_stop():\n");\r\n}\r\nstatic void vino_clear_interrupt(struct vino_channel_settings *vcs)\r\n{\r\nstruct sgi_vino_channel *ch;\r\nch = (vcs->channel == VINO_CHANNEL_A) ? &vino->a : &vino->b;\r\nch->page_index = 0;\r\nch->line_count = 0;\r\nch->start_desc_tbl = vino_drvdata->dummy_desc_table.dma;\r\nch->next_4_desc = vino_drvdata->dummy_desc_table.dma;\r\nudelay(VINO_DESC_FETCH_DELAY);\r\ndprintk("channel %c clear interrupt condition\n",\r\n(vcs->channel == VINO_CHANNEL_A) ? 'A':'B');\r\n}\r\nstatic int vino_capture(struct vino_channel_settings *vcs,\r\nstruct vino_framebuffer *fb)\r\n{\r\nint err = 0;\r\nunsigned long flags, flags2;\r\nspin_lock_irqsave(&fb->state_lock, flags);\r\nif (fb->state == VINO_FRAMEBUFFER_IN_USE)\r\nerr = -EBUSY;\r\nfb->state = VINO_FRAMEBUFFER_IN_USE;\r\nspin_unlock_irqrestore(&fb->state_lock, flags);\r\nif (err)\r\nreturn err;\r\nspin_lock_irqsave(&vino_drvdata->vino_lock, flags);\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags2);\r\nvino_dma_setup(vcs, fb);\r\nvino_dma_start(vcs);\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags2);\r\nspin_unlock_irqrestore(&vino_drvdata->vino_lock, flags);\r\nreturn err;\r\n}\r\nstatic\r\nstruct vino_framebuffer *vino_capture_enqueue(struct\r\nvino_channel_settings *vcs,\r\nunsigned int index)\r\n{\r\nstruct vino_framebuffer *fb;\r\nunsigned long flags;\r\ndprintk("vino_capture_enqueue():\n");\r\nspin_lock_irqsave(&vcs->capture_lock, flags);\r\nfb = vino_queue_add(&vcs->fb_queue, index);\r\nif (fb == NULL) {\r\ndprintk("vino_capture_enqueue(): vino_queue_add() failed, "\r\n"queue full?\n");\r\ngoto out;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&vcs->capture_lock, flags);\r\nreturn fb;\r\n}\r\nstatic int vino_capture_next(struct vino_channel_settings *vcs, int start)\r\n{\r\nstruct vino_framebuffer *fb;\r\nunsigned int incoming, id;\r\nint err = 0;\r\nunsigned long flags;\r\ndprintk("vino_capture_next():\n");\r\nspin_lock_irqsave(&vcs->capture_lock, flags);\r\nif (start) {\r\nif (vcs->capturing) {\r\nspin_unlock_irqrestore(&vcs->capture_lock, flags);\r\nreturn 0;\r\n}\r\n} else {\r\nif (!vcs->capturing) {\r\nspin_unlock_irqrestore(&vcs->capture_lock, flags);\r\nreturn 0;\r\n}\r\n}\r\nerr = vino_queue_get_incoming(&vcs->fb_queue, &incoming);\r\nif (err) {\r\ndprintk("vino_capture_next(): vino_queue_get_incoming() "\r\n"failed\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (incoming == 0) {\r\ndprintk("vino_capture_next(): no buffers available\n");\r\ngoto out;\r\n}\r\nfb = vino_queue_peek(&vcs->fb_queue, &id);\r\nif (fb == NULL) {\r\ndprintk("vino_capture_next(): vino_queue_peek() failed\n");\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (start) {\r\nvcs->capturing = 1;\r\n}\r\nspin_unlock_irqrestore(&vcs->capture_lock, flags);\r\nerr = vino_capture(vcs, fb);\r\nreturn err;\r\nout:\r\nvcs->capturing = 0;\r\nspin_unlock_irqrestore(&vcs->capture_lock, flags);\r\nreturn err;\r\n}\r\nstatic inline int vino_is_capturing(struct vino_channel_settings *vcs)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nspin_lock_irqsave(&vcs->capture_lock, flags);\r\nret = vcs->capturing;\r\nspin_unlock_irqrestore(&vcs->capture_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int vino_wait_for_frame(struct vino_channel_settings *vcs)\r\n{\r\nwait_queue_t wait;\r\nint err = 0;\r\ndprintk("vino_wait_for_frame():\n");\r\ninit_waitqueue_entry(&wait, current);\r\nadd_wait_queue(&vcs->fb_queue.frame_wait_queue, &wait);\r\nschedule_timeout_interruptible(msecs_to_jiffies(100));\r\nif (signal_pending(current))\r\nerr = -EINTR;\r\nremove_wait_queue(&vcs->fb_queue.frame_wait_queue, &wait);\r\ndprintk("vino_wait_for_frame(): waiting for frame %s\n",\r\nerr ? "failed" : "ok");\r\nreturn err;\r\n}\r\nstatic void vino_convert_to_rgba(struct vino_framebuffer *fb) {\r\nunsigned char *pageptr;\r\nunsigned int page, i;\r\nunsigned char a;\r\nfor (page = 0; page < fb->desc_table.page_count; page++) {\r\npageptr = (unsigned char *)fb->desc_table.virtual[page];\r\nfor (i = 0; i < PAGE_SIZE; i += 4) {\r\na = pageptr[0];\r\npageptr[0] = pageptr[3];\r\npageptr[1] = pageptr[2];\r\npageptr[2] = pageptr[1];\r\npageptr[3] = a;\r\npageptr += 4;\r\n}\r\n}\r\n}\r\nstatic int vino_check_buffer(struct vino_channel_settings *vcs,\r\nstruct vino_framebuffer *fb)\r\n{\r\nint err = 0;\r\nunsigned long flags;\r\ndprintk("vino_check_buffer():\n");\r\nspin_lock_irqsave(&fb->state_lock, flags);\r\nswitch (fb->state) {\r\ncase VINO_FRAMEBUFFER_IN_USE:\r\nerr = -EIO;\r\nbreak;\r\ncase VINO_FRAMEBUFFER_READY:\r\nvino_sync_buffer(fb);\r\nfb->state = VINO_FRAMEBUFFER_UNUSED;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nspin_unlock_irqrestore(&fb->state_lock, flags);\r\nif (!err) {\r\nif (vino_pixel_conversion\r\n&& (fb->data_format == VINO_DATA_FMT_RGB32)) {\r\nvino_convert_to_rgba(fb);\r\n}\r\n} else if (err && (err != -EINVAL)) {\r\ndprintk("vino_check_buffer(): buffer not ready\n");\r\nspin_lock_irqsave(&vino_drvdata->vino_lock, flags);\r\nvino_dma_stop(vcs);\r\nvino_clear_interrupt(vcs);\r\nspin_unlock_irqrestore(&vino_drvdata->vino_lock, flags);\r\n}\r\nreturn err;\r\n}\r\nstatic void vino_capture_stop(struct vino_channel_settings *vcs)\r\n{\r\nunsigned int incoming = 0, outgoing = 0, id;\r\nunsigned long flags, flags2;\r\ndprintk("vino_capture_stop():\n");\r\nspin_lock_irqsave(&vcs->capture_lock, flags);\r\nvcs->capturing = 0;\r\nspin_lock_irqsave(&vino_drvdata->vino_lock, flags2);\r\nvino_dma_stop(vcs);\r\nvino_clear_interrupt(vcs);\r\nspin_unlock_irqrestore(&vino_drvdata->vino_lock, flags2);\r\nif (vino_queue_get_incoming(&vcs->fb_queue, &incoming)) {\r\ndprintk("vino_capture_stop(): "\r\n"vino_queue_get_incoming() failed\n");\r\ngoto out;\r\n}\r\nwhile (incoming > 0) {\r\nvino_queue_transfer(&vcs->fb_queue);\r\nif (vino_queue_get_incoming(&vcs->fb_queue, &incoming)) {\r\ndprintk("vino_capture_stop(): "\r\n"vino_queue_get_incoming() failed\n");\r\ngoto out;\r\n}\r\n}\r\nif (vino_queue_get_outgoing(&vcs->fb_queue, &outgoing)) {\r\ndprintk("vino_capture_stop(): "\r\n"vino_queue_get_outgoing() failed\n");\r\ngoto out;\r\n}\r\nwhile (outgoing > 0) {\r\nvino_queue_remove(&vcs->fb_queue, &id);\r\nif (vino_queue_get_outgoing(&vcs->fb_queue, &outgoing)) {\r\ndprintk("vino_capture_stop(): "\r\n"vino_queue_get_outgoing() failed\n");\r\ngoto out;\r\n}\r\n}\r\nout:\r\nspin_unlock_irqrestore(&vcs->capture_lock, flags);\r\n}\r\nstatic void vino_skip_frame(struct vino_channel_settings *vcs)\r\n{\r\nstruct vino_framebuffer *fb;\r\nunsigned long flags;\r\nunsigned int id;\r\nspin_lock_irqsave(&vcs->capture_lock, flags);\r\nfb = vino_queue_peek(&vcs->fb_queue, &id);\r\nif (!fb) {\r\nspin_unlock_irqrestore(&vcs->capture_lock, flags);\r\ndprintk("vino_skip_frame(): vino_queue_peek() failed!\n");\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&vcs->capture_lock, flags);\r\nspin_lock_irqsave(&fb->state_lock, flags);\r\nfb->state = VINO_FRAMEBUFFER_UNUSED;\r\nspin_unlock_irqrestore(&fb->state_lock, flags);\r\nvino_capture_next(vcs, 0);\r\n}\r\nstatic void vino_frame_done(struct vino_channel_settings *vcs)\r\n{\r\nstruct vino_framebuffer *fb;\r\nunsigned long flags;\r\nspin_lock_irqsave(&vcs->capture_lock, flags);\r\nfb = vino_queue_transfer(&vcs->fb_queue);\r\nif (!fb) {\r\nspin_unlock_irqrestore(&vcs->capture_lock, flags);\r\ndprintk("vino_frame_done(): vino_queue_transfer() failed!\n");\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&vcs->capture_lock, flags);\r\nfb->frame_counter = vcs->int_data.frame_counter;\r\nmemcpy(&fb->timestamp, &vcs->int_data.timestamp,\r\nsizeof(struct timeval));\r\nspin_lock_irqsave(&fb->state_lock, flags);\r\nif (fb->state == VINO_FRAMEBUFFER_IN_USE)\r\nfb->state = VINO_FRAMEBUFFER_READY;\r\nspin_unlock_irqrestore(&fb->state_lock, flags);\r\nwake_up(&vcs->fb_queue.frame_wait_queue);\r\nvino_capture_next(vcs, 0);\r\n}\r\nstatic void vino_capture_tasklet(unsigned long channel) {\r\nstruct vino_channel_settings *vcs;\r\nvcs = (channel == VINO_CHANNEL_A)\r\n? &vino_drvdata->a : &vino_drvdata->b;\r\nif (vcs->int_data.skip)\r\nvcs->int_data.skip_count++;\r\nif (vcs->int_data.skip && (vcs->int_data.skip_count\r\n<= VINO_MAX_FRAME_SKIP_COUNT)) {\r\nvino_skip_frame(vcs);\r\n} else {\r\nvcs->int_data.skip_count = 0;\r\nvino_frame_done(vcs);\r\n}\r\n}\r\nstatic irqreturn_t vino_interrupt(int irq, void *dev_id)\r\n{\r\nu32 ctrl, intr;\r\nunsigned int fc_a, fc_b;\r\nint handled_a = 0, skip_a = 0, done_a = 0;\r\nint handled_b = 0, skip_b = 0, done_b = 0;\r\n#ifdef VINO_DEBUG_INT\r\nint loop = 0;\r\nunsigned int line_count = vino->a.line_count,\r\npage_index = vino->a.page_index,\r\nfield_counter = vino->a.field_counter,\r\nstart_desc_tbl = vino->a.start_desc_tbl,\r\nnext_4_desc = vino->a.next_4_desc;\r\nunsigned int line_count_2,\r\npage_index_2,\r\nfield_counter_2,\r\nstart_desc_tbl_2,\r\nnext_4_desc_2;\r\n#endif\r\nspin_lock(&vino_drvdata->vino_lock);\r\nwhile ((intr = vino->intr_status)) {\r\nfc_a = vino->a.field_counter >> 1;\r\nfc_b = vino->b.field_counter >> 1;\r\nif (intr & VINO_INTSTAT_A) {\r\nif (intr & VINO_INTSTAT_A_EOF) {\r\nvino_drvdata->a.field++;\r\nif (vino_drvdata->a.field > 1) {\r\nvino_dma_stop(&vino_drvdata->a);\r\nvino_clear_interrupt(&vino_drvdata->a);\r\nvino_drvdata->a.field = 0;\r\ndone_a = 1;\r\n} else {\r\nif (vino->a.page_index\r\n!= vino_drvdata->a.line_size) {\r\nvino->a.line_count = 0;\r\nvino->a.page_index =\r\nvino_drvdata->\r\na.line_size;\r\nvino->a.next_4_desc =\r\nvino->a.start_desc_tbl;\r\n}\r\n}\r\ndprintk("channel A end-of-field "\r\n"interrupt: %04x\n", intr);\r\n} else {\r\nvino_dma_stop(&vino_drvdata->a);\r\nvino_clear_interrupt(&vino_drvdata->a);\r\nvino_drvdata->a.field = 0;\r\nskip_a = 1;\r\ndprintk("channel A error interrupt: %04x\n",\r\nintr);\r\n}\r\n#ifdef VINO_DEBUG_INT\r\nline_count_2 = vino->a.line_count;\r\npage_index_2 = vino->a.page_index;\r\nfield_counter_2 = vino->a.field_counter;\r\nstart_desc_tbl_2 = vino->a.start_desc_tbl;\r\nnext_4_desc_2 = vino->a.next_4_desc;\r\nprintk("intr = %04x, loop = %d, field = %d\n",\r\nintr, loop, vino_drvdata->a.field);\r\nprintk("1- line count = %04d, page index = %04d, "\r\n"start = %08x, next = %08x\n"\r\n" fieldc = %d, framec = %d\n",\r\nline_count, page_index, start_desc_tbl,\r\nnext_4_desc, field_counter, fc_a);\r\nprintk("12-line count = %04d, page index = %04d, "\r\n" start = %08x, next = %08x\n",\r\nline_count_2, page_index_2, start_desc_tbl_2,\r\nnext_4_desc_2);\r\nif (done_a)\r\nprintk("\n");\r\n#endif\r\n}\r\nif (intr & VINO_INTSTAT_B) {\r\nif (intr & VINO_INTSTAT_B_EOF) {\r\nvino_drvdata->b.field++;\r\nif (vino_drvdata->b.field > 1) {\r\nvino_dma_stop(&vino_drvdata->b);\r\nvino_clear_interrupt(&vino_drvdata->b);\r\nvino_drvdata->b.field = 0;\r\ndone_b = 1;\r\n}\r\ndprintk("channel B end-of-field "\r\n"interrupt: %04x\n", intr);\r\n} else {\r\nvino_dma_stop(&vino_drvdata->b);\r\nvino_clear_interrupt(&vino_drvdata->b);\r\nvino_drvdata->b.field = 0;\r\nskip_b = 1;\r\ndprintk("channel B error interrupt: %04x\n",\r\nintr);\r\n}\r\n}\r\nctrl = vino->control;\r\nvino->control = ctrl & ~(VINO_CTRL_A_INT | VINO_CTRL_B_INT);\r\nvino->intr_status = ~intr;\r\nvino->control = ctrl;\r\nspin_unlock(&vino_drvdata->vino_lock);\r\nif ((!handled_a) && (done_a || skip_a)) {\r\nif (!skip_a) {\r\ndo_gettimeofday(&vino_drvdata->\r\na.int_data.timestamp);\r\nvino_drvdata->a.int_data.frame_counter = fc_a;\r\n}\r\nvino_drvdata->a.int_data.skip = skip_a;\r\ndprintk("channel A %s, interrupt: %d\n",\r\nskip_a ? "skipping frame" : "frame done",\r\nintr);\r\ntasklet_hi_schedule(&vino_tasklet_a);\r\nhandled_a = 1;\r\n}\r\nif ((!handled_b) && (done_b || skip_b)) {\r\nif (!skip_b) {\r\ndo_gettimeofday(&vino_drvdata->\r\nb.int_data.timestamp);\r\nvino_drvdata->b.int_data.frame_counter = fc_b;\r\n}\r\nvino_drvdata->b.int_data.skip = skip_b;\r\ndprintk("channel B %s, interrupt: %d\n",\r\nskip_b ? "skipping frame" : "frame done",\r\nintr);\r\ntasklet_hi_schedule(&vino_tasklet_b);\r\nhandled_b = 1;\r\n}\r\n#ifdef VINO_DEBUG_INT\r\nloop++;\r\n#endif\r\nspin_lock(&vino_drvdata->vino_lock);\r\n}\r\nspin_unlock(&vino_drvdata->vino_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int vino_get_saa7191_input(int input)\r\n{\r\nswitch (input) {\r\ncase VINO_INPUT_COMPOSITE:\r\nreturn SAA7191_INPUT_COMPOSITE;\r\ncase VINO_INPUT_SVIDEO:\r\nreturn SAA7191_INPUT_SVIDEO;\r\ndefault:\r\nprintk(KERN_ERR "VINO: vino_get_saa7191_input(): "\r\n"invalid input!\n");\r\nreturn -1;\r\n}\r\n}\r\nstatic int vino_is_input_owner(struct vino_channel_settings *vcs)\r\n{\r\nswitch(vcs->input) {\r\ncase VINO_INPUT_COMPOSITE:\r\ncase VINO_INPUT_SVIDEO:\r\nreturn vino_drvdata->decoder_owner == vcs->channel;\r\ncase VINO_INPUT_D1:\r\nreturn vino_drvdata->camera_owner == vcs->channel;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int vino_acquire_input(struct vino_channel_settings *vcs)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\ndprintk("vino_acquire_input():\n");\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags);\r\nif (vino_drvdata->camera\r\n&& (vino_drvdata->camera_owner == VINO_NO_CHANNEL)) {\r\nvino_drvdata->camera_owner = vcs->channel;\r\nvcs->input = VINO_INPUT_D1;\r\nvcs->data_norm = VINO_DATA_NORM_D1;\r\n} else if (vino_drvdata->decoder\r\n&& (vino_drvdata->decoder_owner == VINO_NO_CHANNEL)) {\r\nint input;\r\nint data_norm;\r\nv4l2_std_id norm;\r\ninput = VINO_INPUT_COMPOSITE;\r\nret = decoder_call(video, s_routing,\r\nvino_get_saa7191_input(input), 0, 0);\r\nif (ret) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags);\r\nret = decoder_call(video, querystd, &norm);\r\nif (!ret) {\r\nfor (data_norm = 0; data_norm < 3; data_norm++) {\r\nif (vino_data_norms[data_norm].std & norm)\r\nbreak;\r\n}\r\nif (data_norm == 3)\r\ndata_norm = VINO_DATA_NORM_PAL;\r\nret = decoder_call(core, s_std, norm);\r\n}\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags);\r\nif (ret) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nvino_drvdata->decoder_owner = vcs->channel;\r\nvcs->input = input;\r\nvcs->data_norm = data_norm;\r\n} else {\r\nvcs->input = (vcs->channel == VINO_CHANNEL_A) ?\r\nvino_drvdata->b.input : vino_drvdata->a.input;\r\nvcs->data_norm = (vcs->channel == VINO_CHANNEL_A) ?\r\nvino_drvdata->b.data_norm : vino_drvdata->a.data_norm;\r\n}\r\nif (vcs->input == VINO_INPUT_NONE) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nvino_set_default_clipping(vcs);\r\nvino_set_default_scaling(vcs);\r\nvino_set_default_framerate(vcs);\r\ndprintk("vino_acquire_input(): %s\n", vino_inputs[vcs->input].name);\r\nout:\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int vino_set_input(struct vino_channel_settings *vcs, int input)\r\n{\r\nstruct vino_channel_settings *vcs2 = (vcs->channel == VINO_CHANNEL_A) ?\r\n&vino_drvdata->b : &vino_drvdata->a;\r\nunsigned long flags;\r\nint ret = 0;\r\ndprintk("vino_set_input():\n");\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags);\r\nif (vcs->input == input)\r\ngoto out;\r\nswitch (input) {\r\ncase VINO_INPUT_COMPOSITE:\r\ncase VINO_INPUT_SVIDEO:\r\nif (!vino_drvdata->decoder) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (vino_drvdata->decoder_owner == VINO_NO_CHANNEL) {\r\nvino_drvdata->decoder_owner = vcs->channel;\r\n}\r\nif (vino_drvdata->decoder_owner == vcs->channel) {\r\nint data_norm;\r\nv4l2_std_id norm;\r\nret = decoder_call(video, s_routing,\r\nvino_get_saa7191_input(input), 0, 0);\r\nif (ret) {\r\nvino_drvdata->decoder_owner = VINO_NO_CHANNEL;\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags);\r\nret = decoder_call(video, querystd, &norm);\r\nif (!ret) {\r\nfor (data_norm = 0; data_norm < 3; data_norm++) {\r\nif (vino_data_norms[data_norm].std & norm)\r\nbreak;\r\n}\r\nif (data_norm == 3)\r\ndata_norm = VINO_DATA_NORM_PAL;\r\nret = decoder_call(core, s_std, norm);\r\n}\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags);\r\nif (ret) {\r\nvino_drvdata->decoder_owner = VINO_NO_CHANNEL;\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nvcs->input = input;\r\nvcs->data_norm = data_norm;\r\n} else {\r\nif (input != vcs2->input) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nvcs->input = input;\r\nvcs->data_norm = vcs2->data_norm;\r\n}\r\nif (vino_drvdata->camera_owner == vcs->channel) {\r\nif (vcs2->input == VINO_INPUT_D1) {\r\nvino_drvdata->camera_owner = vcs2->channel;\r\n} else {\r\nvino_drvdata->camera_owner = VINO_NO_CHANNEL;\r\n}\r\n}\r\nbreak;\r\ncase VINO_INPUT_D1:\r\nif (!vino_drvdata->camera) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (vino_drvdata->camera_owner == VINO_NO_CHANNEL)\r\nvino_drvdata->camera_owner = vcs->channel;\r\nif (vino_drvdata->decoder_owner == vcs->channel) {\r\nif ((vcs2->input == VINO_INPUT_COMPOSITE) ||\r\n(vcs2->input == VINO_INPUT_SVIDEO)) {\r\nvino_drvdata->decoder_owner = vcs2->channel;\r\n} else {\r\nvino_drvdata->decoder_owner = VINO_NO_CHANNEL;\r\n}\r\n}\r\nvcs->input = input;\r\nvcs->data_norm = VINO_DATA_NORM_D1;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nvino_set_default_clipping(vcs);\r\nvino_set_default_scaling(vcs);\r\nvino_set_default_framerate(vcs);\r\ndprintk("vino_set_input(): %s\n", vino_inputs[vcs->input].name);\r\nout:\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void vino_release_input(struct vino_channel_settings *vcs)\r\n{\r\nstruct vino_channel_settings *vcs2 = (vcs->channel == VINO_CHANNEL_A) ?\r\n&vino_drvdata->b : &vino_drvdata->a;\r\nunsigned long flags;\r\ndprintk("vino_release_input():\n");\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags);\r\nif (vino_drvdata->camera_owner == vcs->channel) {\r\nif (vcs2->input == VINO_INPUT_D1) {\r\nvino_drvdata->camera_owner = vcs2->channel;\r\n} else {\r\nvino_drvdata->camera_owner = VINO_NO_CHANNEL;\r\n}\r\n} else if (vino_drvdata->decoder_owner == vcs->channel) {\r\nif ((vcs2->input == VINO_INPUT_COMPOSITE) ||\r\n(vcs2->input == VINO_INPUT_SVIDEO)) {\r\nvino_drvdata->decoder_owner = vcs2->channel;\r\n} else {\r\nvino_drvdata->decoder_owner = VINO_NO_CHANNEL;\r\n}\r\n}\r\nvcs->input = VINO_INPUT_NONE;\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags);\r\n}\r\nstatic int vino_set_data_norm(struct vino_channel_settings *vcs,\r\nunsigned int data_norm,\r\nunsigned long *flags)\r\n{\r\nint err = 0;\r\nif (data_norm == vcs->data_norm)\r\nreturn 0;\r\nswitch (vcs->input) {\r\ncase VINO_INPUT_D1:\r\nif (data_norm != VINO_DATA_NORM_D1)\r\nreturn -EINVAL;\r\nbreak;\r\ncase VINO_INPUT_COMPOSITE:\r\ncase VINO_INPUT_SVIDEO: {\r\nv4l2_std_id norm;\r\nif ((data_norm != VINO_DATA_NORM_PAL)\r\n&& (data_norm != VINO_DATA_NORM_NTSC)\r\n&& (data_norm != VINO_DATA_NORM_SECAM))\r\nreturn -EINVAL;\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, *flags);\r\nnorm = vino_data_norms[data_norm].std;\r\nerr = decoder_call(core, s_std, norm);\r\nspin_lock_irqsave(&vino_drvdata->input_lock, *flags);\r\nif (err)\r\ngoto out;\r\nvcs->data_norm = data_norm;\r\nvino_set_default_clipping(vcs);\r\nvino_set_default_scaling(vcs);\r\nvino_set_default_framerate(vcs);\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic int vino_find_data_format(__u32 pixelformat)\r\n{\r\nint i;\r\nfor (i = 0; i < VINO_DATA_FMT_COUNT; i++) {\r\nif (vino_data_formats[i].pixelformat == pixelformat)\r\nreturn i;\r\n}\r\nreturn VINO_DATA_FMT_NONE;\r\n}\r\nstatic int vino_int_enum_input(struct vino_channel_settings *vcs, __u32 index)\r\n{\r\nint input = VINO_INPUT_NONE;\r\nunsigned long flags;\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags);\r\nif (vino_drvdata->decoder && vino_drvdata->camera) {\r\nswitch (index) {\r\ncase 0:\r\ninput = VINO_INPUT_COMPOSITE;\r\nbreak;\r\ncase 1:\r\ninput = VINO_INPUT_SVIDEO;\r\nbreak;\r\ncase 2:\r\ninput = VINO_INPUT_D1;\r\nbreak;\r\n}\r\n} else if (vino_drvdata->decoder) {\r\nswitch (index) {\r\ncase 0:\r\ninput = VINO_INPUT_COMPOSITE;\r\nbreak;\r\ncase 1:\r\ninput = VINO_INPUT_SVIDEO;\r\nbreak;\r\n}\r\n} else if (vino_drvdata->camera) {\r\nswitch (index) {\r\ncase 0:\r\ninput = VINO_INPUT_D1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags);\r\nreturn input;\r\n}\r\nstatic __u32 vino_find_input_index(struct vino_channel_settings *vcs)\r\n{\r\n__u32 index = 0;\r\nif (vino_drvdata->decoder && vino_drvdata->camera) {\r\nswitch (vcs->input) {\r\ncase VINO_INPUT_COMPOSITE:\r\nindex = 0;\r\nbreak;\r\ncase VINO_INPUT_SVIDEO:\r\nindex = 1;\r\nbreak;\r\ncase VINO_INPUT_D1:\r\nindex = 2;\r\nbreak;\r\n}\r\n} else if (vino_drvdata->decoder) {\r\nswitch (vcs->input) {\r\ncase VINO_INPUT_COMPOSITE:\r\nindex = 0;\r\nbreak;\r\ncase VINO_INPUT_SVIDEO:\r\nindex = 1;\r\nbreak;\r\n}\r\n} else if (vino_drvdata->camera) {\r\nswitch (vcs->input) {\r\ncase VINO_INPUT_D1:\r\nindex = 0;\r\nbreak;\r\n}\r\n}\r\nreturn index;\r\n}\r\nstatic int vino_querycap(struct file *file, void *__fh,\r\nstruct v4l2_capability *cap)\r\n{\r\nmemset(cap, 0, sizeof(struct v4l2_capability));\r\nstrcpy(cap->driver, vino_driver_name);\r\nstrcpy(cap->card, vino_driver_description);\r\nstrcpy(cap->bus_info, vino_bus_name);\r\ncap->capabilities =\r\nV4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_STREAMING;\r\nreturn 0;\r\n}\r\nstatic int vino_enum_input(struct file *file, void *__fh,\r\nstruct v4l2_input *i)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\n__u32 index = i->index;\r\nint input;\r\ndprintk("requested index = %d\n", index);\r\ninput = vino_int_enum_input(vcs, index);\r\nif (input == VINO_INPUT_NONE)\r\nreturn -EINVAL;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\ni->std = vino_inputs[input].std;\r\nstrcpy(i->name, vino_inputs[input].name);\r\nif (input == VINO_INPUT_COMPOSITE || input == VINO_INPUT_SVIDEO)\r\ndecoder_call(video, g_input_status, &i->status);\r\nreturn 0;\r\n}\r\nstatic int vino_g_input(struct file *file, void *__fh,\r\nunsigned int *i)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\n__u32 index;\r\nint input;\r\nunsigned long flags;\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags);\r\ninput = vcs->input;\r\nindex = vino_find_input_index(vcs);\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags);\r\ndprintk("input = %d\n", input);\r\nif (input == VINO_INPUT_NONE) {\r\nreturn -EINVAL;\r\n}\r\n*i = index;\r\nreturn 0;\r\n}\r\nstatic int vino_s_input(struct file *file, void *__fh,\r\nunsigned int i)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nint input;\r\ndprintk("requested input = %d\n", i);\r\ninput = vino_int_enum_input(vcs, i);\r\nif (input == VINO_INPUT_NONE)\r\nreturn -EINVAL;\r\nreturn vino_set_input(vcs, input);\r\n}\r\nstatic int vino_querystd(struct file *file, void *__fh,\r\nv4l2_std_id *std)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nunsigned long flags;\r\nint err = 0;\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags);\r\nswitch (vcs->input) {\r\ncase VINO_INPUT_D1:\r\n*std = vino_inputs[vcs->input].std;\r\nbreak;\r\ncase VINO_INPUT_COMPOSITE:\r\ncase VINO_INPUT_SVIDEO: {\r\ndecoder_call(video, querystd, std);\r\nbreak;\r\n}\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags);\r\nreturn err;\r\n}\r\nstatic int vino_g_std(struct file *file, void *__fh,\r\nv4l2_std_id *std)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nunsigned long flags;\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags);\r\n*std = vino_data_norms[vcs->data_norm].std;\r\ndprintk("current standard = %d\n", vcs->data_norm);\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int vino_s_std(struct file *file, void *__fh,\r\nv4l2_std_id *std)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags);\r\nif (!vino_is_input_owner(vcs)) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif ((*std) & vino_inputs[vcs->input].std) {\r\ndprintk("standard accepted\n");\r\nif (vcs->input == VINO_INPUT_D1)\r\ngoto out;\r\nif ((*std) & V4L2_STD_PAL) {\r\nret = vino_set_data_norm(vcs, VINO_DATA_NORM_PAL,\r\n&flags);\r\n} else if ((*std) & V4L2_STD_NTSC) {\r\nret = vino_set_data_norm(vcs, VINO_DATA_NORM_NTSC,\r\n&flags);\r\n} else if ((*std) & V4L2_STD_SECAM) {\r\nret = vino_set_data_norm(vcs, VINO_DATA_NORM_SECAM,\r\n&flags);\r\n} else {\r\nret = -EINVAL;\r\n}\r\nif (ret) {\r\nret = -EINVAL;\r\n}\r\n} else {\r\nret = -EINVAL;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int vino_enum_fmt_vid_cap(struct file *file, void *__fh,\r\nstruct v4l2_fmtdesc *fd)\r\n{\r\ndprintk("format index = %d\n", fd->index);\r\nif (fd->index >= VINO_DATA_FMT_COUNT)\r\nreturn -EINVAL;\r\ndprintk("format name = %s\n", vino_data_formats[fd->index].description);\r\nfd->pixelformat = vino_data_formats[fd->index].pixelformat;\r\nstrcpy(fd->description, vino_data_formats[fd->index].description);\r\nreturn 0;\r\n}\r\nstatic int vino_try_fmt_vid_cap(struct file *file, void *__fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nstruct vino_channel_settings tempvcs;\r\nunsigned long flags;\r\nstruct v4l2_pix_format *pf = &f->fmt.pix;\r\ndprintk("requested: w = %d, h = %d\n",\r\npf->width, pf->height);\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags);\r\nmemcpy(&tempvcs, vcs, sizeof(struct vino_channel_settings));\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags);\r\ntempvcs.data_format = vino_find_data_format(pf->pixelformat);\r\nif (tempvcs.data_format == VINO_DATA_FMT_NONE) {\r\ntempvcs.data_format = VINO_DATA_FMT_GREY;\r\npf->pixelformat =\r\nvino_data_formats[tempvcs.data_format].\r\npixelformat;\r\n}\r\nvino_set_scaling(&tempvcs, pf->width, pf->height);\r\ndprintk("data format = %s\n",\r\nvino_data_formats[tempvcs.data_format].description);\r\npf->width = (tempvcs.clipping.right - tempvcs.clipping.left) /\r\ntempvcs.decimation;\r\npf->height = (tempvcs.clipping.bottom - tempvcs.clipping.top) /\r\ntempvcs.decimation;\r\npf->field = V4L2_FIELD_INTERLACED;\r\npf->bytesperline = tempvcs.line_size;\r\npf->sizeimage = tempvcs.line_size *\r\n(tempvcs.clipping.bottom - tempvcs.clipping.top) /\r\ntempvcs.decimation;\r\npf->colorspace =\r\nvino_data_formats[tempvcs.data_format].colorspace;\r\npf->priv = 0;\r\nreturn 0;\r\n}\r\nstatic int vino_g_fmt_vid_cap(struct file *file, void *__fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nunsigned long flags;\r\nstruct v4l2_pix_format *pf = &f->fmt.pix;\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags);\r\npf->width = (vcs->clipping.right - vcs->clipping.left) /\r\nvcs->decimation;\r\npf->height = (vcs->clipping.bottom - vcs->clipping.top) /\r\nvcs->decimation;\r\npf->pixelformat =\r\nvino_data_formats[vcs->data_format].pixelformat;\r\npf->field = V4L2_FIELD_INTERLACED;\r\npf->bytesperline = vcs->line_size;\r\npf->sizeimage = vcs->line_size *\r\n(vcs->clipping.bottom - vcs->clipping.top) /\r\nvcs->decimation;\r\npf->colorspace =\r\nvino_data_formats[vcs->data_format].colorspace;\r\npf->priv = 0;\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int vino_s_fmt_vid_cap(struct file *file, void *__fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nint data_format;\r\nunsigned long flags;\r\nstruct v4l2_pix_format *pf = &f->fmt.pix;\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags);\r\ndata_format = vino_find_data_format(pf->pixelformat);\r\nif (data_format == VINO_DATA_FMT_NONE) {\r\nvcs->data_format = VINO_DATA_FMT_GREY;\r\npf->pixelformat =\r\nvino_data_formats[vcs->data_format].\r\npixelformat;\r\n} else {\r\nvcs->data_format = data_format;\r\n}\r\nvino_set_scaling(vcs, pf->width, pf->height);\r\ndprintk("data format = %s\n",\r\nvino_data_formats[vcs->data_format].description);\r\npf->width = vcs->clipping.right - vcs->clipping.left;\r\npf->height = vcs->clipping.bottom - vcs->clipping.top;\r\npf->field = V4L2_FIELD_INTERLACED;\r\npf->bytesperline = vcs->line_size;\r\npf->sizeimage = vcs->line_size *\r\n(vcs->clipping.bottom - vcs->clipping.top) /\r\nvcs->decimation;\r\npf->colorspace =\r\nvino_data_formats[vcs->data_format].colorspace;\r\npf->priv = 0;\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int vino_cropcap(struct file *file, void *__fh,\r\nstruct v4l2_cropcap *ccap)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nconst struct vino_data_norm *norm;\r\nunsigned long flags;\r\nswitch (ccap->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags);\r\nnorm = &vino_data_norms[vcs->data_norm];\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags);\r\nccap->bounds.left = 0;\r\nccap->bounds.top = 0;\r\nccap->bounds.width = norm->width;\r\nccap->bounds.height = norm->height;\r\nmemcpy(&ccap->defrect, &ccap->bounds,\r\nsizeof(struct v4l2_rect));\r\nccap->pixelaspect.numerator = 1;\r\nccap->pixelaspect.denominator = 1;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_OVERLAY:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vino_g_crop(struct file *file, void *__fh,\r\nstruct v4l2_crop *c)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nunsigned long flags;\r\nswitch (c->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags);\r\nc->c.left = vcs->clipping.left;\r\nc->c.top = vcs->clipping.top;\r\nc->c.width = vcs->clipping.right - vcs->clipping.left;\r\nc->c.height = vcs->clipping.bottom - vcs->clipping.top;\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags);\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_OVERLAY:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vino_s_crop(struct file *file, void *__fh,\r\nstruct v4l2_crop *c)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nunsigned long flags;\r\nswitch (c->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags);\r\nvino_set_clipping(vcs, c->c.left, c->c.top,\r\nc->c.width, c->c.height);\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags);\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_OVERLAY:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vino_g_parm(struct file *file, void *__fh,\r\nstruct v4l2_streamparm *sp)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nunsigned long flags;\r\nstruct v4l2_captureparm *cp = &sp->parm.capture;\r\ncp->capability = V4L2_CAP_TIMEPERFRAME;\r\ncp->timeperframe.numerator = 1;\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags);\r\ncp->timeperframe.denominator = vcs->fps;\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int vino_s_parm(struct file *file, void *__fh,\r\nstruct v4l2_streamparm *sp)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nunsigned long flags;\r\nstruct v4l2_captureparm *cp = &sp->parm.capture;\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags);\r\nif ((cp->timeperframe.numerator == 0) ||\r\n(cp->timeperframe.denominator == 0)) {\r\nvino_set_default_framerate(vcs);\r\n} else {\r\nvino_set_framerate(vcs, cp->timeperframe.denominator /\r\ncp->timeperframe.numerator);\r\n}\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int vino_reqbufs(struct file *file, void *__fh,\r\nstruct v4l2_requestbuffers *rb)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nif (vcs->reading)\r\nreturn -EBUSY;\r\nif (rb->memory != V4L2_MEMORY_MMAP) {\r\ndprintk("type not mmap\n");\r\nreturn -EINVAL;\r\n}\r\ndprintk("count = %d\n", rb->count);\r\nif (rb->count > 0) {\r\nif (vino_is_capturing(vcs)) {\r\ndprintk("busy, capturing\n");\r\nreturn -EBUSY;\r\n}\r\nif (vino_queue_has_mapped_buffers(&vcs->fb_queue)) {\r\ndprintk("busy, buffers still mapped\n");\r\nreturn -EBUSY;\r\n} else {\r\nvcs->streaming = 0;\r\nvino_queue_free(&vcs->fb_queue);\r\nvino_queue_init(&vcs->fb_queue, &rb->count);\r\n}\r\n} else {\r\nvcs->streaming = 0;\r\nvino_capture_stop(vcs);\r\nvino_queue_free(&vcs->fb_queue);\r\n}\r\nreturn 0;\r\n}\r\nstatic void vino_v4l2_get_buffer_status(struct vino_channel_settings *vcs,\r\nstruct vino_framebuffer *fb,\r\nstruct v4l2_buffer *b)\r\n{\r\nif (vino_queue_outgoing_contains(&vcs->fb_queue,\r\nfb->id)) {\r\nb->flags &= ~V4L2_BUF_FLAG_QUEUED;\r\nb->flags |= V4L2_BUF_FLAG_DONE;\r\n} else if (vino_queue_incoming_contains(&vcs->fb_queue,\r\nfb->id)) {\r\nb->flags &= ~V4L2_BUF_FLAG_DONE;\r\nb->flags |= V4L2_BUF_FLAG_QUEUED;\r\n} else {\r\nb->flags &= ~(V4L2_BUF_FLAG_DONE |\r\nV4L2_BUF_FLAG_QUEUED);\r\n}\r\nb->flags &= ~(V4L2_BUF_FLAG_TIMECODE);\r\nif (fb->map_count > 0)\r\nb->flags |= V4L2_BUF_FLAG_MAPPED;\r\nb->index = fb->id;\r\nb->memory = (vcs->fb_queue.type == VINO_MEMORY_MMAP) ?\r\nV4L2_MEMORY_MMAP : V4L2_MEMORY_USERPTR;\r\nb->m.offset = fb->offset;\r\nb->bytesused = fb->data_size;\r\nb->length = fb->size;\r\nb->field = V4L2_FIELD_INTERLACED;\r\nb->sequence = fb->frame_counter;\r\nmemcpy(&b->timestamp, &fb->timestamp,\r\nsizeof(struct timeval));\r\ndprintk("buffer %d: length = %d, bytesused = %d, offset = %d\n",\r\nfb->id, fb->size, fb->data_size, fb->offset);\r\n}\r\nstatic int vino_querybuf(struct file *file, void *__fh,\r\nstruct v4l2_buffer *b)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nstruct vino_framebuffer *fb;\r\nif (vcs->reading)\r\nreturn -EBUSY;\r\nif (b->index >= vino_queue_get_length(&vcs->fb_queue)) {\r\ndprintk("invalid index = %d\n",\r\nb->index);\r\nreturn -EINVAL;\r\n}\r\nfb = vino_queue_get_buffer(&vcs->fb_queue,\r\nb->index);\r\nif (fb == NULL) {\r\ndprintk("vino_queue_get_buffer() failed");\r\nreturn -EINVAL;\r\n}\r\nvino_v4l2_get_buffer_status(vcs, fb, b);\r\nreturn 0;\r\n}\r\nstatic int vino_qbuf(struct file *file, void *__fh,\r\nstruct v4l2_buffer *b)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nstruct vino_framebuffer *fb;\r\nint ret;\r\nif (vcs->reading)\r\nreturn -EBUSY;\r\nif (b->memory != V4L2_MEMORY_MMAP) {\r\ndprintk("type not mmap\n");\r\nreturn -EINVAL;\r\n}\r\nfb = vino_capture_enqueue(vcs, b->index);\r\nif (fb == NULL)\r\nreturn -EINVAL;\r\nvino_v4l2_get_buffer_status(vcs, fb, b);\r\nif (vcs->streaming) {\r\nret = vino_capture_next(vcs, 1);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vino_dqbuf(struct file *file, void *__fh,\r\nstruct v4l2_buffer *b)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nunsigned int nonblocking = file->f_flags & O_NONBLOCK;\r\nstruct vino_framebuffer *fb;\r\nunsigned int incoming, outgoing;\r\nint err;\r\nif (vcs->reading)\r\nreturn -EBUSY;\r\nerr = vino_queue_get_incoming(&vcs->fb_queue, &incoming);\r\nif (err) {\r\ndprintk("vino_queue_get_incoming() failed\n");\r\nreturn -EINVAL;\r\n}\r\nerr = vino_queue_get_outgoing(&vcs->fb_queue, &outgoing);\r\nif (err) {\r\ndprintk("vino_queue_get_outgoing() failed\n");\r\nreturn -EINVAL;\r\n}\r\ndprintk("incoming = %d, outgoing = %d\n", incoming, outgoing);\r\nif (outgoing == 0) {\r\nif (incoming == 0) {\r\ndprintk("no incoming or outgoing buffers\n");\r\nreturn -EINVAL;\r\n}\r\nif (nonblocking) {\r\ndprintk("non-blocking I/O was selected and "\r\n"there are no buffers to dequeue\n");\r\nreturn -EAGAIN;\r\n}\r\nerr = vino_wait_for_frame(vcs);\r\nif (err) {\r\nerr = vino_wait_for_frame(vcs);\r\nif (err) {\r\nreturn -EIO;\r\n}\r\n}\r\n}\r\nfb = vino_queue_remove(&vcs->fb_queue, &b->index);\r\nif (fb == NULL) {\r\ndprintk("vino_queue_remove() failed\n");\r\nreturn -EINVAL;\r\n}\r\nerr = vino_check_buffer(vcs, fb);\r\nvino_v4l2_get_buffer_status(vcs, fb, b);\r\nif (err)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int vino_streamon(struct file *file, void *__fh,\r\nenum v4l2_buf_type i)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nunsigned int incoming;\r\nint ret;\r\nif (vcs->reading)\r\nreturn -EBUSY;\r\nif (vcs->streaming)\r\nreturn 0;\r\nif (vino_queue_get_length(&vcs->fb_queue) < 1) {\r\ndprintk("no buffers allocated\n");\r\nreturn -EINVAL;\r\n}\r\nret = vino_queue_get_incoming(&vcs->fb_queue, &incoming);\r\nif (ret) {\r\ndprintk("vino_queue_get_incoming() failed\n");\r\nreturn -EINVAL;\r\n}\r\nvcs->streaming = 1;\r\nif (incoming > 0) {\r\nret = vino_capture_next(vcs, 1);\r\nif (ret) {\r\nvcs->streaming = 0;\r\ndprintk("couldn't start capture\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int vino_streamoff(struct file *file, void *__fh,\r\nenum v4l2_buf_type i)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nif (vcs->reading)\r\nreturn -EBUSY;\r\nif (!vcs->streaming)\r\nreturn 0;\r\nvcs->streaming = 0;\r\nvino_capture_stop(vcs);\r\nreturn 0;\r\n}\r\nstatic int vino_queryctrl(struct file *file, void *__fh,\r\nstruct v4l2_queryctrl *queryctrl)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nunsigned long flags;\r\nint i;\r\nint err = 0;\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags);\r\nswitch (vcs->input) {\r\ncase VINO_INPUT_D1:\r\nfor (i = 0; i < VINO_INDYCAM_V4L2_CONTROL_COUNT; i++) {\r\nif (vino_indycam_v4l2_controls[i].id ==\r\nqueryctrl->id) {\r\nmemcpy(queryctrl,\r\n&vino_indycam_v4l2_controls[i],\r\nsizeof(struct v4l2_queryctrl));\r\nqueryctrl->reserved[0] = 0;\r\ngoto found;\r\n}\r\n}\r\nerr = -EINVAL;\r\nbreak;\r\ncase VINO_INPUT_COMPOSITE:\r\ncase VINO_INPUT_SVIDEO:\r\nfor (i = 0; i < VINO_SAA7191_V4L2_CONTROL_COUNT; i++) {\r\nif (vino_saa7191_v4l2_controls[i].id ==\r\nqueryctrl->id) {\r\nmemcpy(queryctrl,\r\n&vino_saa7191_v4l2_controls[i],\r\nsizeof(struct v4l2_queryctrl));\r\nqueryctrl->reserved[0] = 0;\r\ngoto found;\r\n}\r\n}\r\nerr = -EINVAL;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nfound:\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags);\r\nreturn err;\r\n}\r\nstatic int vino_g_ctrl(struct file *file, void *__fh,\r\nstruct v4l2_control *control)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nunsigned long flags;\r\nint i;\r\nint err = 0;\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags);\r\nswitch (vcs->input) {\r\ncase VINO_INPUT_D1: {\r\nerr = -EINVAL;\r\nfor (i = 0; i < VINO_INDYCAM_V4L2_CONTROL_COUNT; i++) {\r\nif (vino_indycam_v4l2_controls[i].id == control->id) {\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nif (err)\r\ngoto out;\r\nerr = camera_call(core, g_ctrl, control);\r\nif (err)\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\ncase VINO_INPUT_COMPOSITE:\r\ncase VINO_INPUT_SVIDEO: {\r\nerr = -EINVAL;\r\nfor (i = 0; i < VINO_SAA7191_V4L2_CONTROL_COUNT; i++) {\r\nif (vino_saa7191_v4l2_controls[i].id == control->id) {\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nif (err)\r\ngoto out;\r\nerr = decoder_call(core, g_ctrl, control);\r\nif (err)\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags);\r\nreturn err;\r\n}\r\nstatic int vino_s_ctrl(struct file *file, void *__fh,\r\nstruct v4l2_control *control)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nunsigned long flags;\r\nint i;\r\nint err = 0;\r\nspin_lock_irqsave(&vino_drvdata->input_lock, flags);\r\nif (!vino_is_input_owner(vcs)) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nswitch (vcs->input) {\r\ncase VINO_INPUT_D1: {\r\nerr = -EINVAL;\r\nfor (i = 0; i < VINO_INDYCAM_V4L2_CONTROL_COUNT; i++) {\r\nif (vino_indycam_v4l2_controls[i].id == control->id) {\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nif (err)\r\ngoto out;\r\nif (control->value < vino_indycam_v4l2_controls[i].minimum ||\r\ncontrol->value > vino_indycam_v4l2_controls[i].maximum) {\r\nerr = -ERANGE;\r\ngoto out;\r\n}\r\nerr = camera_call(core, s_ctrl, control);\r\nif (err)\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\ncase VINO_INPUT_COMPOSITE:\r\ncase VINO_INPUT_SVIDEO: {\r\nerr = -EINVAL;\r\nfor (i = 0; i < VINO_SAA7191_V4L2_CONTROL_COUNT; i++) {\r\nif (vino_saa7191_v4l2_controls[i].id == control->id) {\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nif (err)\r\ngoto out;\r\nif (control->value < vino_saa7191_v4l2_controls[i].minimum ||\r\ncontrol->value > vino_saa7191_v4l2_controls[i].maximum) {\r\nerr = -ERANGE;\r\ngoto out;\r\n}\r\nerr = decoder_call(core, s_ctrl, control);\r\nif (err)\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&vino_drvdata->input_lock, flags);\r\nreturn err;\r\n}\r\nstatic int vino_open(struct file *file)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nint ret = 0;\r\ndprintk("open(): channel = %c\n",\r\n(vcs->channel == VINO_CHANNEL_A) ? 'A' : 'B');\r\nmutex_lock(&vcs->mutex);\r\nif (vcs->users) {\r\ndprintk("open(): driver busy\n");\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nret = vino_acquire_input(vcs);\r\nif (ret) {\r\ndprintk("open(): vino_acquire_input() failed\n");\r\ngoto out;\r\n}\r\nvcs->users++;\r\nout:\r\nmutex_unlock(&vcs->mutex);\r\ndprintk("open(): %s!\n", ret ? "failed" : "complete");\r\nreturn ret;\r\n}\r\nstatic int vino_close(struct file *file)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\ndprintk("close():\n");\r\nmutex_lock(&vcs->mutex);\r\nvcs->users--;\r\nif (!vcs->users) {\r\nvino_release_input(vcs);\r\nvino_capture_stop(vcs);\r\nvino_queue_free(&vcs->fb_queue);\r\n}\r\nmutex_unlock(&vcs->mutex);\r\nreturn 0;\r\n}\r\nstatic void vino_vm_open(struct vm_area_struct *vma)\r\n{\r\nstruct vino_framebuffer *fb = vma->vm_private_data;\r\nfb->map_count++;\r\ndprintk("vino_vm_open(): count = %d\n", fb->map_count);\r\n}\r\nstatic void vino_vm_close(struct vm_area_struct *vma)\r\n{\r\nstruct vino_framebuffer *fb = vma->vm_private_data;\r\nfb->map_count--;\r\ndprintk("vino_vm_close(): count = %d\n", fb->map_count);\r\n}\r\nstatic int vino_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nunsigned long start = vma->vm_start;\r\nunsigned long size = vma->vm_end - vma->vm_start;\r\nunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\r\nstruct vino_framebuffer *fb = NULL;\r\nunsigned int i, length;\r\nint ret = 0;\r\ndprintk("mmap():\n");\r\nif (mutex_lock_interruptible(&vcs->mutex))\r\nreturn -EINTR;\r\nif (vcs->reading) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (!(vma->vm_flags & VM_WRITE)) {\r\ndprintk("mmap(): app bug: PROT_WRITE please\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (!(vma->vm_flags & VM_SHARED)) {\r\ndprintk("mmap(): app bug: MAP_SHARED please\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nlength = vino_queue_get_length(&vcs->fb_queue);\r\nif (length == 0) {\r\ndprintk("mmap(): queue not initialized\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nfor (i = 0; i < length; i++) {\r\nfb = vino_queue_get_buffer(&vcs->fb_queue, i);\r\nif (fb == NULL) {\r\ndprintk("mmap(): vino_queue_get_buffer() failed\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (fb->offset == offset)\r\ngoto found;\r\n}\r\ndprintk("mmap(): invalid offset = %lu\n", offset);\r\nret = -EINVAL;\r\ngoto out;\r\nfound:\r\ndprintk("mmap(): buffer = %d\n", i);\r\nif (size > (fb->desc_table.page_count * PAGE_SIZE)) {\r\ndprintk("mmap(): failed: size = %lu > %lu\n",\r\nsize, fb->desc_table.page_count * PAGE_SIZE);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nfor (i = 0; i < fb->desc_table.page_count; i++) {\r\nunsigned long pfn =\r\nvirt_to_phys((void *)fb->desc_table.virtual[i]) >>\r\nPAGE_SHIFT;\r\nif (size < PAGE_SIZE)\r\nbreak;\r\nif (remap_pfn_range(vma, start, pfn, PAGE_SIZE,\r\nvma->vm_page_prot)) {\r\ndprintk("mmap(): remap_pfn_range() failed\n");\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\nstart += PAGE_SIZE;\r\nsize -= PAGE_SIZE;\r\n}\r\nfb->map_count = 1;\r\nvma->vm_flags |= VM_DONTEXPAND | VM_RESERVED;\r\nvma->vm_flags &= ~VM_IO;\r\nvma->vm_private_data = fb;\r\nvma->vm_file = file;\r\nvma->vm_ops = &vino_vm_ops;\r\nout:\r\nmutex_unlock(&vcs->mutex);\r\nreturn ret;\r\n}\r\nstatic unsigned int vino_poll(struct file *file, poll_table *pt)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nunsigned int outgoing;\r\nunsigned int ret = 0;\r\ndprintk("poll():\n");\r\nif (vino_queue_get_outgoing(&vcs->fb_queue, &outgoing)) {\r\ndprintk("poll(): vino_queue_get_outgoing() failed\n");\r\nret = POLLERR;\r\ngoto error;\r\n}\r\nif (outgoing > 0)\r\ngoto over;\r\npoll_wait(file, &vcs->fb_queue.frame_wait_queue, pt);\r\nif (vino_queue_get_outgoing(&vcs->fb_queue, &outgoing)) {\r\ndprintk("poll(): vino_queue_get_outgoing() failed\n");\r\nret = POLLERR;\r\ngoto error;\r\n}\r\nover:\r\ndprintk("poll(): data %savailable\n",\r\n(outgoing > 0) ? "" : "not ");\r\nif (outgoing > 0)\r\nret = POLLIN | POLLRDNORM;\r\nerror:\r\nreturn ret;\r\n}\r\nstatic long vino_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct vino_channel_settings *vcs = video_drvdata(file);\r\nlong ret;\r\nif (mutex_lock_interruptible(&vcs->mutex))\r\nreturn -EINTR;\r\nret = video_ioctl2(file, cmd, arg);\r\nmutex_unlock(&vcs->mutex);\r\nreturn ret;\r\n}\r\nstatic void vino_module_cleanup(int stage)\r\n{\r\nswitch(stage) {\r\ncase 11:\r\nvideo_unregister_device(vino_drvdata->b.vdev);\r\nvino_drvdata->b.vdev = NULL;\r\ncase 10:\r\nvideo_unregister_device(vino_drvdata->a.vdev);\r\nvino_drvdata->a.vdev = NULL;\r\ncase 9:\r\ni2c_del_adapter(&vino_i2c_adapter);\r\ncase 8:\r\nfree_irq(SGI_VINO_IRQ, NULL);\r\ncase 7:\r\nif (vino_drvdata->b.vdev) {\r\nvideo_device_release(vino_drvdata->b.vdev);\r\nvino_drvdata->b.vdev = NULL;\r\n}\r\ncase 6:\r\nif (vino_drvdata->a.vdev) {\r\nvideo_device_release(vino_drvdata->a.vdev);\r\nvino_drvdata->a.vdev = NULL;\r\n}\r\ncase 5:\r\ndma_unmap_single(NULL,\r\nvino_drvdata->dummy_desc_table.dma_cpu[0],\r\nPAGE_SIZE, DMA_FROM_DEVICE);\r\ndma_free_coherent(NULL, VINO_DUMMY_DESC_COUNT\r\n* sizeof(dma_addr_t),\r\n(void *)vino_drvdata->\r\ndummy_desc_table.dma_cpu,\r\nvino_drvdata->dummy_desc_table.dma);\r\ncase 4:\r\nfree_page(vino_drvdata->dummy_page);\r\ncase 3:\r\nv4l2_device_unregister(&vino_drvdata->v4l2_dev);\r\ncase 2:\r\nkfree(vino_drvdata);\r\ncase 1:\r\niounmap(vino);\r\ncase 0:\r\nbreak;\r\ndefault:\r\ndprintk("vino_module_cleanup(): invalid cleanup stage = %d\n",\r\nstage);\r\n}\r\n}\r\nstatic int vino_probe(void)\r\n{\r\nunsigned long rev_id;\r\nif (ip22_is_fullhouse()) {\r\nprintk(KERN_ERR "VINO doesn't exist in IP22 Fullhouse\n");\r\nreturn -ENODEV;\r\n}\r\nif (!(sgimc->systemid & SGIMC_SYSID_EPRESENT)) {\r\nprintk(KERN_ERR "VINO is not found (EISA BUS not present)\n");\r\nreturn -ENODEV;\r\n}\r\nvino = (struct sgi_vino *)ioremap(VINO_BASE, sizeof(struct sgi_vino));\r\nif (!vino) {\r\nprintk(KERN_ERR "VINO: ioremap() failed\n");\r\nreturn -EIO;\r\n}\r\nvino_init_stage++;\r\nif (get_dbe(rev_id, &(vino->rev_id))) {\r\nprintk(KERN_ERR "Failed to read VINO revision register\n");\r\nvino_module_cleanup(vino_init_stage);\r\nreturn -ENODEV;\r\n}\r\nif (VINO_ID_VALUE(rev_id) != VINO_CHIP_ID) {\r\nprintk(KERN_ERR "Unknown VINO chip ID (Rev/ID: 0x%02lx)\n",\r\nrev_id);\r\nvino_module_cleanup(vino_init_stage);\r\nreturn -ENODEV;\r\n}\r\nprintk(KERN_INFO "VINO revision %ld found\n", VINO_REV_NUM(rev_id));\r\nreturn 0;\r\n}\r\nstatic int vino_init(void)\r\n{\r\ndma_addr_t dma_dummy_address;\r\nint err;\r\nint i;\r\nvino_drvdata = kzalloc(sizeof(struct vino_settings), GFP_KERNEL);\r\nif (!vino_drvdata) {\r\nvino_module_cleanup(vino_init_stage);\r\nreturn -ENOMEM;\r\n}\r\nvino_init_stage++;\r\nstrlcpy(vino_drvdata->v4l2_dev.name, "vino",\r\nsizeof(vino_drvdata->v4l2_dev.name));\r\nerr = v4l2_device_register(NULL, &vino_drvdata->v4l2_dev);\r\nif (err)\r\nreturn err;\r\nvino_init_stage++;\r\nvino_drvdata->dummy_page = get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!vino_drvdata->dummy_page) {\r\nvino_module_cleanup(vino_init_stage);\r\nreturn -ENOMEM;\r\n}\r\nvino_init_stage++;\r\nvino_drvdata->dummy_desc_table.dma_cpu =\r\ndma_alloc_coherent(NULL,\r\nVINO_DUMMY_DESC_COUNT * sizeof(dma_addr_t),\r\n&vino_drvdata->dummy_desc_table.dma,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!vino_drvdata->dummy_desc_table.dma_cpu) {\r\nvino_module_cleanup(vino_init_stage);\r\nreturn -ENOMEM;\r\n}\r\nvino_init_stage++;\r\ndma_dummy_address = dma_map_single(NULL,\r\n(void *)vino_drvdata->dummy_page,\r\nPAGE_SIZE, DMA_FROM_DEVICE);\r\nfor (i = 0; i < VINO_DUMMY_DESC_COUNT; i++) {\r\nvino_drvdata->dummy_desc_table.dma_cpu[i] = dma_dummy_address;\r\n}\r\nvino->control = 0;\r\nvino->a.next_4_desc = vino_drvdata->dummy_desc_table.dma;\r\nvino->b.next_4_desc = vino_drvdata->dummy_desc_table.dma;\r\nudelay(VINO_DESC_FETCH_DELAY);\r\nvino->intr_status = 0;\r\nvino->a.fifo_thres = VINO_FIFO_THRESHOLD_DEFAULT;\r\nvino->b.fifo_thres = VINO_FIFO_THRESHOLD_DEFAULT;\r\nreturn 0;\r\n}\r\nstatic int vino_init_channel_settings(struct vino_channel_settings *vcs,\r\nunsigned int channel, const char *name)\r\n{\r\nvcs->channel = channel;\r\nvcs->input = VINO_INPUT_NONE;\r\nvcs->alpha = 0;\r\nvcs->users = 0;\r\nvcs->data_format = VINO_DATA_FMT_GREY;\r\nvcs->data_norm = VINO_DATA_NORM_NTSC;\r\nvcs->decimation = 1;\r\nvino_set_default_clipping(vcs);\r\nvino_set_default_framerate(vcs);\r\nvcs->capturing = 0;\r\nmutex_init(&vcs->mutex);\r\nspin_lock_init(&vcs->capture_lock);\r\nmutex_init(&vcs->fb_queue.queue_mutex);\r\nspin_lock_init(&vcs->fb_queue.queue_lock);\r\ninit_waitqueue_head(&vcs->fb_queue.frame_wait_queue);\r\nvcs->vdev = video_device_alloc();\r\nif (!vcs->vdev) {\r\nvino_module_cleanup(vino_init_stage);\r\nreturn -ENOMEM;\r\n}\r\nvino_init_stage++;\r\nmemcpy(vcs->vdev, &vdev_template,\r\nsizeof(struct video_device));\r\nstrcpy(vcs->vdev->name, name);\r\nvcs->vdev->release = video_device_release;\r\nvcs->vdev->v4l2_dev = &vino_drvdata->v4l2_dev;\r\nvideo_set_drvdata(vcs->vdev, vcs);\r\nreturn 0;\r\n}\r\nstatic int __init vino_module_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "SGI VINO driver version %s\n",\r\nVINO_MODULE_VERSION);\r\nret = vino_probe();\r\nif (ret)\r\nreturn ret;\r\nret = vino_init();\r\nif (ret)\r\nreturn ret;\r\nspin_lock_init(&vino_drvdata->vino_lock);\r\nspin_lock_init(&vino_drvdata->input_lock);\r\nret = vino_init_channel_settings(&vino_drvdata->a, VINO_CHANNEL_A,\r\nvino_vdev_name_a);\r\nif (ret)\r\nreturn ret;\r\nret = vino_init_channel_settings(&vino_drvdata->b, VINO_CHANNEL_B,\r\nvino_vdev_name_b);\r\nif (ret)\r\nreturn ret;\r\nret = request_irq(SGI_VINO_IRQ, vino_interrupt, 0,\r\nvino_driver_description, NULL);\r\nif (ret) {\r\nprintk(KERN_ERR "VINO: requesting IRQ %02d failed\n",\r\nSGI_VINO_IRQ);\r\nvino_module_cleanup(vino_init_stage);\r\nreturn -EAGAIN;\r\n}\r\nvino_init_stage++;\r\nret = i2c_add_adapter(&vino_i2c_adapter);\r\nif (ret) {\r\nprintk(KERN_ERR "VINO I2C bus registration failed\n");\r\nvino_module_cleanup(vino_init_stage);\r\nreturn ret;\r\n}\r\ni2c_set_adapdata(&vino_i2c_adapter, &vino_drvdata->v4l2_dev);\r\nvino_init_stage++;\r\nret = video_register_device(vino_drvdata->a.vdev,\r\nVFL_TYPE_GRABBER, -1);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "VINO channel A Video4Linux-device "\r\n"registration failed\n");\r\nvino_module_cleanup(vino_init_stage);\r\nreturn -EINVAL;\r\n}\r\nvino_init_stage++;\r\nret = video_register_device(vino_drvdata->b.vdev,\r\nVFL_TYPE_GRABBER, -1);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "VINO channel B Video4Linux-device "\r\n"registration failed\n");\r\nvino_module_cleanup(vino_init_stage);\r\nreturn -EINVAL;\r\n}\r\nvino_init_stage++;\r\nvino_drvdata->decoder =\r\nv4l2_i2c_new_subdev(&vino_drvdata->v4l2_dev, &vino_i2c_adapter,\r\n"saa7191", 0, I2C_ADDRS(0x45));\r\nvino_drvdata->camera =\r\nv4l2_i2c_new_subdev(&vino_drvdata->v4l2_dev, &vino_i2c_adapter,\r\n"indycam", 0, I2C_ADDRS(0x2b));\r\ndprintk("init complete!\n");\r\nreturn 0;\r\n}\r\nstatic void __exit vino_module_exit(void)\r\n{\r\ndprintk("exiting, stage = %d ...\n", vino_init_stage);\r\nvino_module_cleanup(vino_init_stage);\r\ndprintk("cleanup complete, exit!\n");\r\n}
