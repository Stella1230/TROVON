static inline struct ip6_flowlabel *__fl_lookup(struct net *net, __be32 label)\r\n{\r\nstruct ip6_flowlabel *fl;\r\nfor (fl=fl_ht[FL_HASH(label)]; fl; fl = fl->next) {\r\nif (fl->label == label && net_eq(fl->fl_net, net))\r\nreturn fl;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct ip6_flowlabel *fl_lookup(struct net *net, __be32 label)\r\n{\r\nstruct ip6_flowlabel *fl;\r\nread_lock_bh(&ip6_fl_lock);\r\nfl = __fl_lookup(net, label);\r\nif (fl)\r\natomic_inc(&fl->users);\r\nread_unlock_bh(&ip6_fl_lock);\r\nreturn fl;\r\n}\r\nstatic void fl_free(struct ip6_flowlabel *fl)\r\n{\r\nif (fl) {\r\nrelease_net(fl->fl_net);\r\nkfree(fl->opt);\r\n}\r\nkfree(fl);\r\n}\r\nstatic void fl_release(struct ip6_flowlabel *fl)\r\n{\r\nwrite_lock_bh(&ip6_fl_lock);\r\nfl->lastuse = jiffies;\r\nif (atomic_dec_and_test(&fl->users)) {\r\nunsigned long ttd = fl->lastuse + fl->linger;\r\nif (time_after(ttd, fl->expires))\r\nfl->expires = ttd;\r\nttd = fl->expires;\r\nif (fl->opt && fl->share == IPV6_FL_S_EXCL) {\r\nstruct ipv6_txoptions *opt = fl->opt;\r\nfl->opt = NULL;\r\nkfree(opt);\r\n}\r\nif (!timer_pending(&ip6_fl_gc_timer) ||\r\ntime_after(ip6_fl_gc_timer.expires, ttd))\r\nmod_timer(&ip6_fl_gc_timer, ttd);\r\n}\r\nwrite_unlock_bh(&ip6_fl_lock);\r\n}\r\nstatic void ip6_fl_gc(unsigned long dummy)\r\n{\r\nint i;\r\nunsigned long now = jiffies;\r\nunsigned long sched = 0;\r\nwrite_lock(&ip6_fl_lock);\r\nfor (i=0; i<=FL_HASH_MASK; i++) {\r\nstruct ip6_flowlabel *fl, **flp;\r\nflp = &fl_ht[i];\r\nwhile ((fl=*flp) != NULL) {\r\nif (atomic_read(&fl->users) == 0) {\r\nunsigned long ttd = fl->lastuse + fl->linger;\r\nif (time_after(ttd, fl->expires))\r\nfl->expires = ttd;\r\nttd = fl->expires;\r\nif (time_after_eq(now, ttd)) {\r\n*flp = fl->next;\r\nfl_free(fl);\r\natomic_dec(&fl_size);\r\ncontinue;\r\n}\r\nif (!sched || time_before(ttd, sched))\r\nsched = ttd;\r\n}\r\nflp = &fl->next;\r\n}\r\n}\r\nif (!sched && atomic_read(&fl_size))\r\nsched = now + FL_MAX_LINGER;\r\nif (sched) {\r\nmod_timer(&ip6_fl_gc_timer, sched);\r\n}\r\nwrite_unlock(&ip6_fl_lock);\r\n}\r\nstatic void __net_exit ip6_fl_purge(struct net *net)\r\n{\r\nint i;\r\nwrite_lock(&ip6_fl_lock);\r\nfor (i = 0; i <= FL_HASH_MASK; i++) {\r\nstruct ip6_flowlabel *fl, **flp;\r\nflp = &fl_ht[i];\r\nwhile ((fl = *flp) != NULL) {\r\nif (net_eq(fl->fl_net, net) &&\r\natomic_read(&fl->users) == 0) {\r\n*flp = fl->next;\r\nfl_free(fl);\r\natomic_dec(&fl_size);\r\ncontinue;\r\n}\r\nflp = &fl->next;\r\n}\r\n}\r\nwrite_unlock(&ip6_fl_lock);\r\n}\r\nstatic struct ip6_flowlabel *fl_intern(struct net *net,\r\nstruct ip6_flowlabel *fl, __be32 label)\r\n{\r\nstruct ip6_flowlabel *lfl;\r\nfl->label = label & IPV6_FLOWLABEL_MASK;\r\nwrite_lock_bh(&ip6_fl_lock);\r\nif (label == 0) {\r\nfor (;;) {\r\nfl->label = htonl(net_random())&IPV6_FLOWLABEL_MASK;\r\nif (fl->label) {\r\nlfl = __fl_lookup(net, fl->label);\r\nif (lfl == NULL)\r\nbreak;\r\n}\r\n}\r\n} else {\r\nlfl = __fl_lookup(net, fl->label);\r\nif (lfl != NULL) {\r\natomic_inc(&lfl->users);\r\nwrite_unlock_bh(&ip6_fl_lock);\r\nreturn lfl;\r\n}\r\n}\r\nfl->lastuse = jiffies;\r\nfl->next = fl_ht[FL_HASH(fl->label)];\r\nfl_ht[FL_HASH(fl->label)] = fl;\r\natomic_inc(&fl_size);\r\nwrite_unlock_bh(&ip6_fl_lock);\r\nreturn NULL;\r\n}\r\nstruct ip6_flowlabel * fl6_sock_lookup(struct sock *sk, __be32 label)\r\n{\r\nstruct ipv6_fl_socklist *sfl;\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nlabel &= IPV6_FLOWLABEL_MASK;\r\nread_lock_bh(&ip6_sk_fl_lock);\r\nfor (sfl=np->ipv6_fl_list; sfl; sfl = sfl->next) {\r\nstruct ip6_flowlabel *fl = sfl->fl;\r\nif (fl->label == label) {\r\nfl->lastuse = jiffies;\r\natomic_inc(&fl->users);\r\nread_unlock_bh(&ip6_sk_fl_lock);\r\nreturn fl;\r\n}\r\n}\r\nread_unlock_bh(&ip6_sk_fl_lock);\r\nreturn NULL;\r\n}\r\nvoid fl6_free_socklist(struct sock *sk)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct ipv6_fl_socklist *sfl;\r\nwhile ((sfl = np->ipv6_fl_list) != NULL) {\r\nnp->ipv6_fl_list = sfl->next;\r\nfl_release(sfl->fl);\r\nkfree(sfl);\r\n}\r\n}\r\nstruct ipv6_txoptions *fl6_merge_options(struct ipv6_txoptions * opt_space,\r\nstruct ip6_flowlabel * fl,\r\nstruct ipv6_txoptions * fopt)\r\n{\r\nstruct ipv6_txoptions * fl_opt = fl->opt;\r\nif (fopt == NULL || fopt->opt_flen == 0)\r\nreturn fl_opt;\r\nif (fl_opt != NULL) {\r\nopt_space->hopopt = fl_opt->hopopt;\r\nopt_space->dst0opt = fl_opt->dst0opt;\r\nopt_space->srcrt = fl_opt->srcrt;\r\nopt_space->opt_nflen = fl_opt->opt_nflen;\r\n} else {\r\nif (fopt->opt_nflen == 0)\r\nreturn fopt;\r\nopt_space->hopopt = NULL;\r\nopt_space->dst0opt = NULL;\r\nopt_space->srcrt = NULL;\r\nopt_space->opt_nflen = 0;\r\n}\r\nopt_space->dst1opt = fopt->dst1opt;\r\nopt_space->opt_flen = fopt->opt_flen;\r\nreturn opt_space;\r\n}\r\nstatic unsigned long check_linger(unsigned long ttl)\r\n{\r\nif (ttl < FL_MIN_LINGER)\r\nreturn FL_MIN_LINGER*HZ;\r\nif (ttl > FL_MAX_LINGER && !capable(CAP_NET_ADMIN))\r\nreturn 0;\r\nreturn ttl*HZ;\r\n}\r\nstatic int fl6_renew(struct ip6_flowlabel *fl, unsigned long linger, unsigned long expires)\r\n{\r\nlinger = check_linger(linger);\r\nif (!linger)\r\nreturn -EPERM;\r\nexpires = check_linger(expires);\r\nif (!expires)\r\nreturn -EPERM;\r\nfl->lastuse = jiffies;\r\nif (time_before(fl->linger, linger))\r\nfl->linger = linger;\r\nif (time_before(expires, fl->linger))\r\nexpires = fl->linger;\r\nif (time_before(fl->expires, fl->lastuse + expires))\r\nfl->expires = fl->lastuse + expires;\r\nreturn 0;\r\n}\r\nstatic struct ip6_flowlabel *\r\nfl_create(struct net *net, struct sock *sk, struct in6_flowlabel_req *freq,\r\nchar __user *optval, int optlen, int *err_p)\r\n{\r\nstruct ip6_flowlabel *fl = NULL;\r\nint olen;\r\nint addr_type;\r\nint err;\r\nolen = optlen - CMSG_ALIGN(sizeof(*freq));\r\nerr = -EINVAL;\r\nif (olen > 64 * 1024)\r\ngoto done;\r\nerr = -ENOMEM;\r\nfl = kzalloc(sizeof(*fl), GFP_KERNEL);\r\nif (fl == NULL)\r\ngoto done;\r\nif (olen > 0) {\r\nstruct msghdr msg;\r\nstruct flowi6 flowi6;\r\nint junk;\r\nerr = -ENOMEM;\r\nfl->opt = kmalloc(sizeof(*fl->opt) + olen, GFP_KERNEL);\r\nif (fl->opt == NULL)\r\ngoto done;\r\nmemset(fl->opt, 0, sizeof(*fl->opt));\r\nfl->opt->tot_len = sizeof(*fl->opt) + olen;\r\nerr = -EFAULT;\r\nif (copy_from_user(fl->opt+1, optval+CMSG_ALIGN(sizeof(*freq)), olen))\r\ngoto done;\r\nmsg.msg_controllen = olen;\r\nmsg.msg_control = (void*)(fl->opt+1);\r\nmemset(&flowi6, 0, sizeof(flowi6));\r\nerr = datagram_send_ctl(net, sk, &msg, &flowi6, fl->opt, &junk,\r\n&junk, &junk);\r\nif (err)\r\ngoto done;\r\nerr = -EINVAL;\r\nif (fl->opt->opt_flen)\r\ngoto done;\r\nif (fl->opt->opt_nflen == 0) {\r\nkfree(fl->opt);\r\nfl->opt = NULL;\r\n}\r\n}\r\nfl->fl_net = hold_net(net);\r\nfl->expires = jiffies;\r\nerr = fl6_renew(fl, freq->flr_linger, freq->flr_expires);\r\nif (err)\r\ngoto done;\r\nfl->share = freq->flr_share;\r\naddr_type = ipv6_addr_type(&freq->flr_dst);\r\nif ((addr_type & IPV6_ADDR_MAPPED) ||\r\naddr_type == IPV6_ADDR_ANY) {\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nfl->dst = freq->flr_dst;\r\natomic_set(&fl->users, 1);\r\nswitch (fl->share) {\r\ncase IPV6_FL_S_EXCL:\r\ncase IPV6_FL_S_ANY:\r\nbreak;\r\ncase IPV6_FL_S_PROCESS:\r\nfl->owner = current->pid;\r\nbreak;\r\ncase IPV6_FL_S_USER:\r\nfl->owner = current_euid();\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nreturn fl;\r\ndone:\r\nfl_free(fl);\r\n*err_p = err;\r\nreturn NULL;\r\n}\r\nstatic int mem_check(struct sock *sk)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct ipv6_fl_socklist *sfl;\r\nint room = FL_MAX_SIZE - atomic_read(&fl_size);\r\nint count = 0;\r\nif (room > FL_MAX_SIZE - FL_MAX_PER_SOCK)\r\nreturn 0;\r\nfor (sfl = np->ipv6_fl_list; sfl; sfl = sfl->next)\r\ncount++;\r\nif (room <= 0 ||\r\n((count >= FL_MAX_PER_SOCK ||\r\n(count > 0 && room < FL_MAX_SIZE/2) || room < FL_MAX_SIZE/4) &&\r\n!capable(CAP_NET_ADMIN)))\r\nreturn -ENOBUFS;\r\nreturn 0;\r\n}\r\nstatic int ipv6_hdr_cmp(struct ipv6_opt_hdr *h1, struct ipv6_opt_hdr *h2)\r\n{\r\nif (h1 == h2)\r\nreturn 0;\r\nif (h1 == NULL || h2 == NULL)\r\nreturn 1;\r\nif (h1->hdrlen != h2->hdrlen)\r\nreturn 1;\r\nreturn memcmp(h1+1, h2+1, ((h1->hdrlen+1)<<3) - sizeof(*h1));\r\n}\r\nstatic int ipv6_opt_cmp(struct ipv6_txoptions *o1, struct ipv6_txoptions *o2)\r\n{\r\nif (o1 == o2)\r\nreturn 0;\r\nif (o1 == NULL || o2 == NULL)\r\nreturn 1;\r\nif (o1->opt_nflen != o2->opt_nflen)\r\nreturn 1;\r\nif (ipv6_hdr_cmp(o1->hopopt, o2->hopopt))\r\nreturn 1;\r\nif (ipv6_hdr_cmp(o1->dst0opt, o2->dst0opt))\r\nreturn 1;\r\nif (ipv6_hdr_cmp((struct ipv6_opt_hdr *)o1->srcrt, (struct ipv6_opt_hdr *)o2->srcrt))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline void fl_link(struct ipv6_pinfo *np, struct ipv6_fl_socklist *sfl,\r\nstruct ip6_flowlabel *fl)\r\n{\r\nwrite_lock_bh(&ip6_sk_fl_lock);\r\nsfl->fl = fl;\r\nsfl->next = np->ipv6_fl_list;\r\nnp->ipv6_fl_list = sfl;\r\nwrite_unlock_bh(&ip6_sk_fl_lock);\r\n}\r\nint ipv6_flowlabel_opt(struct sock *sk, char __user *optval, int optlen)\r\n{\r\nint uninitialized_var(err);\r\nstruct net *net = sock_net(sk);\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct in6_flowlabel_req freq;\r\nstruct ipv6_fl_socklist *sfl1=NULL;\r\nstruct ipv6_fl_socklist *sfl, **sflp;\r\nstruct ip6_flowlabel *fl, *fl1 = NULL;\r\nif (optlen < sizeof(freq))\r\nreturn -EINVAL;\r\nif (copy_from_user(&freq, optval, sizeof(freq)))\r\nreturn -EFAULT;\r\nswitch (freq.flr_action) {\r\ncase IPV6_FL_A_PUT:\r\nwrite_lock_bh(&ip6_sk_fl_lock);\r\nfor (sflp = &np->ipv6_fl_list; (sfl=*sflp)!=NULL; sflp = &sfl->next) {\r\nif (sfl->fl->label == freq.flr_label) {\r\nif (freq.flr_label == (np->flow_label&IPV6_FLOWLABEL_MASK))\r\nnp->flow_label &= ~IPV6_FLOWLABEL_MASK;\r\n*sflp = sfl->next;\r\nwrite_unlock_bh(&ip6_sk_fl_lock);\r\nfl_release(sfl->fl);\r\nkfree(sfl);\r\nreturn 0;\r\n}\r\n}\r\nwrite_unlock_bh(&ip6_sk_fl_lock);\r\nreturn -ESRCH;\r\ncase IPV6_FL_A_RENEW:\r\nread_lock_bh(&ip6_sk_fl_lock);\r\nfor (sfl = np->ipv6_fl_list; sfl; sfl = sfl->next) {\r\nif (sfl->fl->label == freq.flr_label) {\r\nerr = fl6_renew(sfl->fl, freq.flr_linger, freq.flr_expires);\r\nread_unlock_bh(&ip6_sk_fl_lock);\r\nreturn err;\r\n}\r\n}\r\nread_unlock_bh(&ip6_sk_fl_lock);\r\nif (freq.flr_share == IPV6_FL_S_NONE && capable(CAP_NET_ADMIN)) {\r\nfl = fl_lookup(net, freq.flr_label);\r\nif (fl) {\r\nerr = fl6_renew(fl, freq.flr_linger, freq.flr_expires);\r\nfl_release(fl);\r\nreturn err;\r\n}\r\n}\r\nreturn -ESRCH;\r\ncase IPV6_FL_A_GET:\r\nif (freq.flr_label & ~IPV6_FLOWLABEL_MASK)\r\nreturn -EINVAL;\r\nfl = fl_create(net, sk, &freq, optval, optlen, &err);\r\nif (fl == NULL)\r\nreturn err;\r\nsfl1 = kmalloc(sizeof(*sfl1), GFP_KERNEL);\r\nif (freq.flr_label) {\r\nerr = -EEXIST;\r\nread_lock_bh(&ip6_sk_fl_lock);\r\nfor (sfl = np->ipv6_fl_list; sfl; sfl = sfl->next) {\r\nif (sfl->fl->label == freq.flr_label) {\r\nif (freq.flr_flags&IPV6_FL_F_EXCL) {\r\nread_unlock_bh(&ip6_sk_fl_lock);\r\ngoto done;\r\n}\r\nfl1 = sfl->fl;\r\natomic_inc(&fl1->users);\r\nbreak;\r\n}\r\n}\r\nread_unlock_bh(&ip6_sk_fl_lock);\r\nif (fl1 == NULL)\r\nfl1 = fl_lookup(net, freq.flr_label);\r\nif (fl1) {\r\nrecheck:\r\nerr = -EEXIST;\r\nif (freq.flr_flags&IPV6_FL_F_EXCL)\r\ngoto release;\r\nerr = -EPERM;\r\nif (fl1->share == IPV6_FL_S_EXCL ||\r\nfl1->share != fl->share ||\r\nfl1->owner != fl->owner)\r\ngoto release;\r\nerr = -EINVAL;\r\nif (!ipv6_addr_equal(&fl1->dst, &fl->dst) ||\r\nipv6_opt_cmp(fl1->opt, fl->opt))\r\ngoto release;\r\nerr = -ENOMEM;\r\nif (sfl1 == NULL)\r\ngoto release;\r\nif (fl->linger > fl1->linger)\r\nfl1->linger = fl->linger;\r\nif ((long)(fl->expires - fl1->expires) > 0)\r\nfl1->expires = fl->expires;\r\nfl_link(np, sfl1, fl1);\r\nfl_free(fl);\r\nreturn 0;\r\nrelease:\r\nfl_release(fl1);\r\ngoto done;\r\n}\r\n}\r\nerr = -ENOENT;\r\nif (!(freq.flr_flags&IPV6_FL_F_CREATE))\r\ngoto done;\r\nerr = -ENOMEM;\r\nif (sfl1 == NULL || (err = mem_check(sk)) != 0)\r\ngoto done;\r\nfl1 = fl_intern(net, fl, freq.flr_label);\r\nif (fl1 != NULL)\r\ngoto recheck;\r\nif (!freq.flr_label) {\r\nif (copy_to_user(&((struct in6_flowlabel_req __user *) optval)->flr_label,\r\n&fl->label, sizeof(fl->label))) {\r\n}\r\n}\r\nfl_link(np, sfl1, fl);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndone:\r\nfl_free(fl);\r\nkfree(sfl1);\r\nreturn err;\r\n}\r\nstatic struct ip6_flowlabel *ip6fl_get_first(struct seq_file *seq)\r\n{\r\nstruct ip6_flowlabel *fl = NULL;\r\nstruct ip6fl_iter_state *state = ip6fl_seq_private(seq);\r\nstruct net *net = seq_file_net(seq);\r\nfor (state->bucket = 0; state->bucket <= FL_HASH_MASK; ++state->bucket) {\r\nfl = fl_ht[state->bucket];\r\nwhile (fl && !net_eq(fl->fl_net, net))\r\nfl = fl->next;\r\nif (fl)\r\nbreak;\r\n}\r\nreturn fl;\r\n}\r\nstatic struct ip6_flowlabel *ip6fl_get_next(struct seq_file *seq, struct ip6_flowlabel *fl)\r\n{\r\nstruct ip6fl_iter_state *state = ip6fl_seq_private(seq);\r\nstruct net *net = seq_file_net(seq);\r\nfl = fl->next;\r\ntry_again:\r\nwhile (fl && !net_eq(fl->fl_net, net))\r\nfl = fl->next;\r\nwhile (!fl) {\r\nif (++state->bucket <= FL_HASH_MASK) {\r\nfl = fl_ht[state->bucket];\r\ngoto try_again;\r\n} else\r\nbreak;\r\n}\r\nreturn fl;\r\n}\r\nstatic struct ip6_flowlabel *ip6fl_get_idx(struct seq_file *seq, loff_t pos)\r\n{\r\nstruct ip6_flowlabel *fl = ip6fl_get_first(seq);\r\nif (fl)\r\nwhile (pos && (fl = ip6fl_get_next(seq, fl)) != NULL)\r\n--pos;\r\nreturn pos ? NULL : fl;\r\n}\r\nstatic void *ip6fl_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(ip6_fl_lock)\r\n{\r\nread_lock_bh(&ip6_fl_lock);\r\nreturn *pos ? ip6fl_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\r\n}\r\nstatic void *ip6fl_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct ip6_flowlabel *fl;\r\nif (v == SEQ_START_TOKEN)\r\nfl = ip6fl_get_first(seq);\r\nelse\r\nfl = ip6fl_get_next(seq, v);\r\n++*pos;\r\nreturn fl;\r\n}\r\nstatic void ip6fl_seq_stop(struct seq_file *seq, void *v)\r\n__releases(ip6_fl_lock)\r\n{\r\nread_unlock_bh(&ip6_fl_lock);\r\n}\r\nstatic int ip6fl_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN)\r\nseq_printf(seq, "%-5s %-1s %-6s %-6s %-6s %-8s %-32s %s\n",\r\n"Label", "S", "Owner", "Users", "Linger", "Expires", "Dst", "Opt");\r\nelse {\r\nstruct ip6_flowlabel *fl = v;\r\nseq_printf(seq,\r\n"%05X %-1d %-6d %-6d %-6ld %-8ld %pi6 %-4d\n",\r\n(unsigned)ntohl(fl->label),\r\nfl->share,\r\n(unsigned)fl->owner,\r\natomic_read(&fl->users),\r\nfl->linger/HZ,\r\n(long)(fl->expires - jiffies)/HZ,\r\n&fl->dst,\r\nfl->opt ? fl->opt->opt_nflen : 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ip6fl_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &ip6fl_seq_ops,\r\nsizeof(struct ip6fl_iter_state));\r\n}\r\nstatic int __net_init ip6_flowlabel_proc_init(struct net *net)\r\n{\r\nif (!proc_net_fops_create(net, "ip6_flowlabel",\r\nS_IRUGO, &ip6fl_seq_fops))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __net_exit ip6_flowlabel_proc_fini(struct net *net)\r\n{\r\nproc_net_remove(net, "ip6_flowlabel");\r\n}\r\nstatic inline int ip6_flowlabel_proc_init(struct net *net)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void ip6_flowlabel_proc_fini(struct net *net)\r\n{\r\n}\r\nstatic void __net_exit ip6_flowlabel_net_exit(struct net *net)\r\n{\r\nip6_fl_purge(net);\r\nip6_flowlabel_proc_fini(net);\r\n}\r\nint ip6_flowlabel_init(void)\r\n{\r\nreturn register_pernet_subsys(&ip6_flowlabel_net_ops);\r\n}\r\nvoid ip6_flowlabel_cleanup(void)\r\n{\r\ndel_timer(&ip6_fl_gc_timer);\r\nunregister_pernet_subsys(&ip6_flowlabel_net_ops);\r\n}
