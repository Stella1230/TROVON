static void __init error(char *x)\r\n{\r\nif (!message)\r\nmessage = x;\r\n}\r\nstatic inline int hash(int major, int minor, int ino)\r\n{\r\nunsigned long tmp = ino + minor + (major << 3);\r\ntmp += tmp >> 5;\r\nreturn tmp & 31;\r\n}\r\nstatic char __init *find_link(int major, int minor, int ino,\r\numode_t mode, char *name)\r\n{\r\nstruct hash **p, *q;\r\nfor (p = head + hash(major, minor, ino); *p; p = &(*p)->next) {\r\nif ((*p)->ino != ino)\r\ncontinue;\r\nif ((*p)->minor != minor)\r\ncontinue;\r\nif ((*p)->major != major)\r\ncontinue;\r\nif (((*p)->mode ^ mode) & S_IFMT)\r\ncontinue;\r\nreturn (*p)->name;\r\n}\r\nq = kmalloc(sizeof(struct hash), GFP_KERNEL);\r\nif (!q)\r\npanic("can't allocate link hash entry");\r\nq->major = major;\r\nq->minor = minor;\r\nq->ino = ino;\r\nq->mode = mode;\r\nstrcpy(q->name, name);\r\nq->next = NULL;\r\n*p = q;\r\nreturn NULL;\r\n}\r\nstatic void __init free_hash(void)\r\n{\r\nstruct hash **p, *q;\r\nfor (p = head; p < head + 32; p++) {\r\nwhile (*p) {\r\nq = *p;\r\n*p = q->next;\r\nkfree(q);\r\n}\r\n}\r\n}\r\nstatic long __init do_utime(char __user *filename, time_t mtime)\r\n{\r\nstruct timespec t[2];\r\nt[0].tv_sec = mtime;\r\nt[0].tv_nsec = 0;\r\nt[1].tv_sec = mtime;\r\nt[1].tv_nsec = 0;\r\nreturn do_utimes(AT_FDCWD, filename, t, AT_SYMLINK_NOFOLLOW);\r\n}\r\nstatic void __init dir_add(const char *name, time_t mtime)\r\n{\r\nstruct dir_entry *de = kmalloc(sizeof(struct dir_entry), GFP_KERNEL);\r\nif (!de)\r\npanic("can't allocate dir_entry buffer");\r\nINIT_LIST_HEAD(&de->list);\r\nde->name = kstrdup(name, GFP_KERNEL);\r\nde->mtime = mtime;\r\nlist_add(&de->list, &dir_list);\r\n}\r\nstatic void __init dir_utime(void)\r\n{\r\nstruct dir_entry *de, *tmp;\r\nlist_for_each_entry_safe(de, tmp, &dir_list, list) {\r\nlist_del(&de->list);\r\ndo_utime(de->name, de->mtime);\r\nkfree(de->name);\r\nkfree(de);\r\n}\r\n}\r\nstatic void __init parse_header(char *s)\r\n{\r\nunsigned long parsed[12];\r\nchar buf[9];\r\nint i;\r\nbuf[8] = '\0';\r\nfor (i = 0, s += 6; i < 12; i++, s += 8) {\r\nmemcpy(buf, s, 8);\r\nparsed[i] = simple_strtoul(buf, NULL, 16);\r\n}\r\nino = parsed[0];\r\nmode = parsed[1];\r\nuid = parsed[2];\r\ngid = parsed[3];\r\nnlink = parsed[4];\r\nmtime = parsed[5];\r\nbody_len = parsed[6];\r\nmajor = parsed[7];\r\nminor = parsed[8];\r\nrdev = new_encode_dev(MKDEV(parsed[9], parsed[10]));\r\nname_len = parsed[11];\r\n}\r\nstatic inline void __init eat(unsigned n)\r\n{\r\nvictim += n;\r\nthis_header += n;\r\ncount -= n;\r\n}\r\nstatic void __init read_into(char *buf, unsigned size, enum state next)\r\n{\r\nif (count >= size) {\r\ncollected = victim;\r\neat(size);\r\nstate = next;\r\n} else {\r\ncollect = collected = buf;\r\nremains = size;\r\nnext_state = next;\r\nstate = Collect;\r\n}\r\n}\r\nstatic int __init do_start(void)\r\n{\r\nread_into(header_buf, 110, GotHeader);\r\nreturn 0;\r\n}\r\nstatic int __init do_collect(void)\r\n{\r\nunsigned n = remains;\r\nif (count < n)\r\nn = count;\r\nmemcpy(collect, victim, n);\r\neat(n);\r\ncollect += n;\r\nif ((remains -= n) != 0)\r\nreturn 1;\r\nstate = next_state;\r\nreturn 0;\r\n}\r\nstatic int __init do_header(void)\r\n{\r\nif (memcmp(collected, "070707", 6)==0) {\r\nerror("incorrect cpio method used: use -H newc option");\r\nreturn 1;\r\n}\r\nif (memcmp(collected, "070701", 6)) {\r\nerror("no cpio magic");\r\nreturn 1;\r\n}\r\nparse_header(collected);\r\nnext_header = this_header + N_ALIGN(name_len) + body_len;\r\nnext_header = (next_header + 3) & ~3;\r\nstate = SkipIt;\r\nif (name_len <= 0 || name_len > PATH_MAX)\r\nreturn 0;\r\nif (S_ISLNK(mode)) {\r\nif (body_len > PATH_MAX)\r\nreturn 0;\r\ncollect = collected = symlink_buf;\r\nremains = N_ALIGN(name_len) + body_len;\r\nnext_state = GotSymlink;\r\nstate = Collect;\r\nreturn 0;\r\n}\r\nif (S_ISREG(mode) || !body_len)\r\nread_into(name_buf, N_ALIGN(name_len), GotName);\r\nreturn 0;\r\n}\r\nstatic int __init do_skip(void)\r\n{\r\nif (this_header + count < next_header) {\r\neat(count);\r\nreturn 1;\r\n} else {\r\neat(next_header - this_header);\r\nstate = next_state;\r\nreturn 0;\r\n}\r\n}\r\nstatic int __init do_reset(void)\r\n{\r\nwhile(count && *victim == '\0')\r\neat(1);\r\nif (count && (this_header & 3))\r\nerror("broken padding");\r\nreturn 1;\r\n}\r\nstatic int __init maybe_link(void)\r\n{\r\nif (nlink >= 2) {\r\nchar *old = find_link(major, minor, ino, mode, collected);\r\nif (old)\r\nreturn (sys_link(old, collected) < 0) ? -1 : 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init clean_path(char *path, umode_t mode)\r\n{\r\nstruct stat st;\r\nif (!sys_newlstat(path, &st) && (st.st_mode^mode) & S_IFMT) {\r\nif (S_ISDIR(st.st_mode))\r\nsys_rmdir(path);\r\nelse\r\nsys_unlink(path);\r\n}\r\n}\r\nstatic int __init do_name(void)\r\n{\r\nstate = SkipIt;\r\nnext_state = Reset;\r\nif (strcmp(collected, "TRAILER!!!") == 0) {\r\nfree_hash();\r\nreturn 0;\r\n}\r\nclean_path(collected, mode);\r\nif (S_ISREG(mode)) {\r\nint ml = maybe_link();\r\nif (ml >= 0) {\r\nint openflags = O_WRONLY|O_CREAT;\r\nif (ml != 1)\r\nopenflags |= O_TRUNC;\r\nwfd = sys_open(collected, openflags, mode);\r\nif (wfd >= 0) {\r\nsys_fchown(wfd, uid, gid);\r\nsys_fchmod(wfd, mode);\r\nif (body_len)\r\nsys_ftruncate(wfd, body_len);\r\nvcollected = kstrdup(collected, GFP_KERNEL);\r\nstate = CopyFile;\r\n}\r\n}\r\n} else if (S_ISDIR(mode)) {\r\nsys_mkdir(collected, mode);\r\nsys_chown(collected, uid, gid);\r\nsys_chmod(collected, mode);\r\ndir_add(collected, mtime);\r\n} else if (S_ISBLK(mode) || S_ISCHR(mode) ||\r\nS_ISFIFO(mode) || S_ISSOCK(mode)) {\r\nif (maybe_link() == 0) {\r\nsys_mknod(collected, mode, rdev);\r\nsys_chown(collected, uid, gid);\r\nsys_chmod(collected, mode);\r\ndo_utime(collected, mtime);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init do_copy(void)\r\n{\r\nif (count >= body_len) {\r\nsys_write(wfd, victim, body_len);\r\nsys_close(wfd);\r\ndo_utime(vcollected, mtime);\r\nkfree(vcollected);\r\neat(body_len);\r\nstate = SkipIt;\r\nreturn 0;\r\n} else {\r\nsys_write(wfd, victim, count);\r\nbody_len -= count;\r\neat(count);\r\nreturn 1;\r\n}\r\n}\r\nstatic int __init do_symlink(void)\r\n{\r\ncollected[N_ALIGN(name_len) + body_len] = '\0';\r\nclean_path(collected, 0);\r\nsys_symlink(collected + N_ALIGN(name_len), collected);\r\nsys_lchown(collected, uid, gid);\r\ndo_utime(collected, mtime);\r\nstate = SkipIt;\r\nnext_state = Reset;\r\nreturn 0;\r\n}\r\nstatic int __init write_buffer(char *buf, unsigned len)\r\n{\r\ncount = len;\r\nvictim = buf;\r\nwhile (!actions[state]())\r\n;\r\nreturn len - count;\r\n}\r\nstatic int __init flush_buffer(void *bufv, unsigned len)\r\n{\r\nchar *buf = (char *) bufv;\r\nint written;\r\nint origLen = len;\r\nif (message)\r\nreturn -1;\r\nwhile ((written = write_buffer(buf, len)) < len && !message) {\r\nchar c = buf[written];\r\nif (c == '0') {\r\nbuf += written;\r\nlen -= written;\r\nstate = Start;\r\n} else if (c == 0) {\r\nbuf += written;\r\nlen -= written;\r\nstate = Reset;\r\n} else\r\nerror("junk in compressed archive");\r\n}\r\nreturn origLen;\r\n}\r\nstatic char * __init unpack_to_rootfs(char *buf, unsigned len)\r\n{\r\nint written, res;\r\ndecompress_fn decompress;\r\nconst char *compress_name;\r\nstatic __initdata char msg_buf[64];\r\nheader_buf = kmalloc(110, GFP_KERNEL);\r\nsymlink_buf = kmalloc(PATH_MAX + N_ALIGN(PATH_MAX) + 1, GFP_KERNEL);\r\nname_buf = kmalloc(N_ALIGN(PATH_MAX), GFP_KERNEL);\r\nif (!header_buf || !symlink_buf || !name_buf)\r\npanic("can't allocate buffers");\r\nstate = Start;\r\nthis_header = 0;\r\nmessage = NULL;\r\nwhile (!message && len) {\r\nloff_t saved_offset = this_header;\r\nif (*buf == '0' && !(this_header & 3)) {\r\nstate = Start;\r\nwritten = write_buffer(buf, len);\r\nbuf += written;\r\nlen -= written;\r\ncontinue;\r\n}\r\nif (!*buf) {\r\nbuf++;\r\nlen--;\r\nthis_header++;\r\ncontinue;\r\n}\r\nthis_header = 0;\r\ndecompress = decompress_method(buf, len, &compress_name);\r\nif (decompress) {\r\nres = decompress(buf, len, NULL, flush_buffer, NULL,\r\n&my_inptr, error);\r\nif (res)\r\nerror("decompressor failed");\r\n} else if (compress_name) {\r\nif (!message) {\r\nsnprintf(msg_buf, sizeof msg_buf,\r\n"compression method %s not configured",\r\ncompress_name);\r\nmessage = msg_buf;\r\n}\r\n} else\r\nerror("junk in compressed archive");\r\nif (state != Reset)\r\nerror("junk in compressed archive");\r\nthis_header = saved_offset + my_inptr;\r\nbuf += my_inptr;\r\nlen -= my_inptr;\r\n}\r\ndir_utime();\r\nkfree(name_buf);\r\nkfree(symlink_buf);\r\nkfree(header_buf);\r\nreturn message;\r\n}\r\nstatic int __init retain_initrd_param(char *str)\r\n{\r\nif (*str)\r\nreturn 0;\r\ndo_retain_initrd = 1;\r\nreturn 1;\r\n}\r\nstatic void __init free_initrd(void)\r\n{\r\n#ifdef CONFIG_KEXEC\r\nunsigned long crashk_start = (unsigned long)__va(crashk_res.start);\r\nunsigned long crashk_end = (unsigned long)__va(crashk_res.end);\r\n#endif\r\nif (do_retain_initrd)\r\ngoto skip;\r\n#ifdef CONFIG_KEXEC\r\nif (initrd_start < crashk_end && initrd_end > crashk_start) {\r\nmemset((void *)initrd_start, 0, initrd_end - initrd_start);\r\nif (initrd_start < crashk_start)\r\nfree_initrd_mem(initrd_start, crashk_start);\r\nif (initrd_end > crashk_end)\r\nfree_initrd_mem(crashk_end, initrd_end);\r\n} else\r\n#endif\r\nfree_initrd_mem(initrd_start, initrd_end);\r\nskip:\r\ninitrd_start = 0;\r\ninitrd_end = 0;\r\n}\r\nstatic void __init clean_rootfs(void)\r\n{\r\nint fd;\r\nvoid *buf;\r\nstruct linux_dirent64 *dirp;\r\nint num;\r\nfd = sys_open((const char __user __force *) "/", O_RDONLY, 0);\r\nWARN_ON(fd < 0);\r\nif (fd < 0)\r\nreturn;\r\nbuf = kzalloc(BUF_SIZE, GFP_KERNEL);\r\nWARN_ON(!buf);\r\nif (!buf) {\r\nsys_close(fd);\r\nreturn;\r\n}\r\ndirp = buf;\r\nnum = sys_getdents64(fd, dirp, BUF_SIZE);\r\nwhile (num > 0) {\r\nwhile (num > 0) {\r\nstruct stat st;\r\nint ret;\r\nret = sys_newlstat(dirp->d_name, &st);\r\nWARN_ON_ONCE(ret);\r\nif (!ret) {\r\nif (S_ISDIR(st.st_mode))\r\nsys_rmdir(dirp->d_name);\r\nelse\r\nsys_unlink(dirp->d_name);\r\n}\r\nnum -= dirp->d_reclen;\r\ndirp = (void *)dirp + dirp->d_reclen;\r\n}\r\ndirp = buf;\r\nmemset(buf, 0, BUF_SIZE);\r\nnum = sys_getdents64(fd, dirp, BUF_SIZE);\r\n}\r\nsys_close(fd);\r\nkfree(buf);\r\n}\r\nstatic int __init populate_rootfs(void)\r\n{\r\nchar *err = unpack_to_rootfs(__initramfs_start, __initramfs_size);\r\nif (err)\r\npanic(err);\r\nif (initrd_start) {\r\n#ifdef CONFIG_BLK_DEV_RAM\r\nint fd;\r\nprintk(KERN_INFO "Trying to unpack rootfs image as initramfs...\n");\r\nerr = unpack_to_rootfs((char *)initrd_start,\r\ninitrd_end - initrd_start);\r\nif (!err) {\r\nfree_initrd();\r\nreturn 0;\r\n} else {\r\nclean_rootfs();\r\nunpack_to_rootfs(__initramfs_start, __initramfs_size);\r\n}\r\nprintk(KERN_INFO "rootfs image is not initramfs (%s)"\r\n"; looks like an initrd\n", err);\r\nfd = sys_open((const char __user __force *) "/initrd.image",\r\nO_WRONLY|O_CREAT, 0700);\r\nif (fd >= 0) {\r\nsys_write(fd, (char *)initrd_start,\r\ninitrd_end - initrd_start);\r\nsys_close(fd);\r\nfree_initrd();\r\n}\r\n#else\r\nprintk(KERN_INFO "Unpacking initramfs...\n");\r\nerr = unpack_to_rootfs((char *)initrd_start,\r\ninitrd_end - initrd_start);\r\nif (err)\r\nprintk(KERN_EMERG "Initramfs unpacking failed: %s\n", err);\r\nfree_initrd();\r\n#endif\r\n}\r\nreturn 0;\r\n}
