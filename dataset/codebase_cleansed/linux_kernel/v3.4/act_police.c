static int tcf_act_police_walker(struct sk_buff *skb, struct netlink_callback *cb,\r\nint type, struct tc_action *a)\r\n{\r\nstruct tcf_common *p;\r\nint err = 0, index = -1, i = 0, s_i = 0, n_i = 0;\r\nstruct nlattr *nest;\r\nread_lock_bh(&police_lock);\r\ns_i = cb->args[0];\r\nfor (i = 0; i < (POL_TAB_MASK + 1); i++) {\r\np = tcf_police_ht[tcf_hash(i, POL_TAB_MASK)];\r\nfor (; p; p = p->tcfc_next) {\r\nindex++;\r\nif (index < s_i)\r\ncontinue;\r\na->priv = p;\r\na->order = index;\r\nnest = nla_nest_start(skb, a->order);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nif (type == RTM_DELACTION)\r\nerr = tcf_action_dump_1(skb, a, 0, 1);\r\nelse\r\nerr = tcf_action_dump_1(skb, a, 0, 0);\r\nif (err < 0) {\r\nindex--;\r\nnla_nest_cancel(skb, nest);\r\ngoto done;\r\n}\r\nnla_nest_end(skb, nest);\r\nn_i++;\r\n}\r\n}\r\ndone:\r\nread_unlock_bh(&police_lock);\r\nif (n_i)\r\ncb->args[0] += n_i;\r\nreturn n_i;\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nest);\r\ngoto done;\r\n}\r\nstatic void tcf_police_destroy(struct tcf_police *p)\r\n{\r\nunsigned int h = tcf_hash(p->tcf_index, POL_TAB_MASK);\r\nstruct tcf_common **p1p;\r\nfor (p1p = &tcf_police_ht[h]; *p1p; p1p = &(*p1p)->tcfc_next) {\r\nif (*p1p == &p->common) {\r\nwrite_lock_bh(&police_lock);\r\n*p1p = p->tcf_next;\r\nwrite_unlock_bh(&police_lock);\r\ngen_kill_estimator(&p->tcf_bstats,\r\n&p->tcf_rate_est);\r\nif (p->tcfp_R_tab)\r\nqdisc_put_rtab(p->tcfp_R_tab);\r\nif (p->tcfp_P_tab)\r\nqdisc_put_rtab(p->tcfp_P_tab);\r\nkfree_rcu(p, tcf_rcu);\r\nreturn;\r\n}\r\n}\r\nWARN_ON(1);\r\n}\r\nstatic int tcf_act_police_locate(struct nlattr *nla, struct nlattr *est,\r\nstruct tc_action *a, int ovr, int bind)\r\n{\r\nunsigned int h;\r\nint ret = 0, err;\r\nstruct nlattr *tb[TCA_POLICE_MAX + 1];\r\nstruct tc_police *parm;\r\nstruct tcf_police *police;\r\nstruct qdisc_rate_table *R_tab = NULL, *P_tab = NULL;\r\nint size;\r\nif (nla == NULL)\r\nreturn -EINVAL;\r\nerr = nla_parse_nested(tb, TCA_POLICE_MAX, nla, police_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[TCA_POLICE_TBF] == NULL)\r\nreturn -EINVAL;\r\nsize = nla_len(tb[TCA_POLICE_TBF]);\r\nif (size != sizeof(*parm) && size != sizeof(struct tc_police_compat))\r\nreturn -EINVAL;\r\nparm = nla_data(tb[TCA_POLICE_TBF]);\r\nif (parm->index) {\r\nstruct tcf_common *pc;\r\npc = tcf_hash_lookup(parm->index, &police_hash_info);\r\nif (pc != NULL) {\r\na->priv = pc;\r\npolice = to_police(pc);\r\nif (bind) {\r\npolice->tcf_bindcnt += 1;\r\npolice->tcf_refcnt += 1;\r\n}\r\nif (ovr)\r\ngoto override;\r\nreturn ret;\r\n}\r\n}\r\npolice = kzalloc(sizeof(*police), GFP_KERNEL);\r\nif (police == NULL)\r\nreturn -ENOMEM;\r\nret = ACT_P_CREATED;\r\npolice->tcf_refcnt = 1;\r\nspin_lock_init(&police->tcf_lock);\r\nif (bind)\r\npolice->tcf_bindcnt = 1;\r\noverride:\r\nif (parm->rate.rate) {\r\nerr = -ENOMEM;\r\nR_tab = qdisc_get_rtab(&parm->rate, tb[TCA_POLICE_RATE]);\r\nif (R_tab == NULL)\r\ngoto failure;\r\nif (parm->peakrate.rate) {\r\nP_tab = qdisc_get_rtab(&parm->peakrate,\r\ntb[TCA_POLICE_PEAKRATE]);\r\nif (P_tab == NULL)\r\ngoto failure;\r\n}\r\n}\r\nspin_lock_bh(&police->tcf_lock);\r\nif (est) {\r\nerr = gen_replace_estimator(&police->tcf_bstats,\r\n&police->tcf_rate_est,\r\n&police->tcf_lock, est);\r\nif (err)\r\ngoto failure_unlock;\r\n} else if (tb[TCA_POLICE_AVRATE] &&\r\n(ret == ACT_P_CREATED ||\r\n!gen_estimator_active(&police->tcf_bstats,\r\n&police->tcf_rate_est))) {\r\nerr = -EINVAL;\r\ngoto failure_unlock;\r\n}\r\nif (R_tab != NULL) {\r\nqdisc_put_rtab(police->tcfp_R_tab);\r\npolice->tcfp_R_tab = R_tab;\r\n}\r\nif (P_tab != NULL) {\r\nqdisc_put_rtab(police->tcfp_P_tab);\r\npolice->tcfp_P_tab = P_tab;\r\n}\r\nif (tb[TCA_POLICE_RESULT])\r\npolice->tcfp_result = nla_get_u32(tb[TCA_POLICE_RESULT]);\r\npolice->tcfp_toks = police->tcfp_burst = parm->burst;\r\npolice->tcfp_mtu = parm->mtu;\r\nif (police->tcfp_mtu == 0) {\r\npolice->tcfp_mtu = ~0;\r\nif (police->tcfp_R_tab)\r\npolice->tcfp_mtu = 255<<police->tcfp_R_tab->rate.cell_log;\r\n}\r\nif (police->tcfp_P_tab)\r\npolice->tcfp_ptoks = L2T_P(police, police->tcfp_mtu);\r\npolice->tcf_action = parm->action;\r\nif (tb[TCA_POLICE_AVRATE])\r\npolice->tcfp_ewma_rate = nla_get_u32(tb[TCA_POLICE_AVRATE]);\r\nspin_unlock_bh(&police->tcf_lock);\r\nif (ret != ACT_P_CREATED)\r\nreturn ret;\r\npolice->tcfp_t_c = psched_get_time();\r\npolice->tcf_index = parm->index ? parm->index :\r\ntcf_hash_new_index(&police_idx_gen, &police_hash_info);\r\nh = tcf_hash(police->tcf_index, POL_TAB_MASK);\r\nwrite_lock_bh(&police_lock);\r\npolice->tcf_next = tcf_police_ht[h];\r\ntcf_police_ht[h] = &police->common;\r\nwrite_unlock_bh(&police_lock);\r\na->priv = police;\r\nreturn ret;\r\nfailure_unlock:\r\nspin_unlock_bh(&police->tcf_lock);\r\nfailure:\r\nif (P_tab)\r\nqdisc_put_rtab(P_tab);\r\nif (R_tab)\r\nqdisc_put_rtab(R_tab);\r\nif (ret == ACT_P_CREATED)\r\nkfree(police);\r\nreturn err;\r\n}\r\nstatic int tcf_act_police_cleanup(struct tc_action *a, int bind)\r\n{\r\nstruct tcf_police *p = a->priv;\r\nint ret = 0;\r\nif (p != NULL) {\r\nif (bind)\r\np->tcf_bindcnt--;\r\np->tcf_refcnt--;\r\nif (p->tcf_refcnt <= 0 && !p->tcf_bindcnt) {\r\ntcf_police_destroy(p);\r\nret = 1;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int tcf_act_police(struct sk_buff *skb, const struct tc_action *a,\r\nstruct tcf_result *res)\r\n{\r\nstruct tcf_police *police = a->priv;\r\npsched_time_t now;\r\nlong toks;\r\nlong ptoks = 0;\r\nspin_lock(&police->tcf_lock);\r\nbstats_update(&police->tcf_bstats, skb);\r\nif (police->tcfp_ewma_rate &&\r\npolice->tcf_rate_est.bps >= police->tcfp_ewma_rate) {\r\npolice->tcf_qstats.overlimits++;\r\nif (police->tcf_action == TC_ACT_SHOT)\r\npolice->tcf_qstats.drops++;\r\nspin_unlock(&police->tcf_lock);\r\nreturn police->tcf_action;\r\n}\r\nif (qdisc_pkt_len(skb) <= police->tcfp_mtu) {\r\nif (police->tcfp_R_tab == NULL) {\r\nspin_unlock(&police->tcf_lock);\r\nreturn police->tcfp_result;\r\n}\r\nnow = psched_get_time();\r\ntoks = psched_tdiff_bounded(now, police->tcfp_t_c,\r\npolice->tcfp_burst);\r\nif (police->tcfp_P_tab) {\r\nptoks = toks + police->tcfp_ptoks;\r\nif (ptoks > (long)L2T_P(police, police->tcfp_mtu))\r\nptoks = (long)L2T_P(police, police->tcfp_mtu);\r\nptoks -= L2T_P(police, qdisc_pkt_len(skb));\r\n}\r\ntoks += police->tcfp_toks;\r\nif (toks > (long)police->tcfp_burst)\r\ntoks = police->tcfp_burst;\r\ntoks -= L2T(police, qdisc_pkt_len(skb));\r\nif ((toks|ptoks) >= 0) {\r\npolice->tcfp_t_c = now;\r\npolice->tcfp_toks = toks;\r\npolice->tcfp_ptoks = ptoks;\r\nspin_unlock(&police->tcf_lock);\r\nreturn police->tcfp_result;\r\n}\r\n}\r\npolice->tcf_qstats.overlimits++;\r\nif (police->tcf_action == TC_ACT_SHOT)\r\npolice->tcf_qstats.drops++;\r\nspin_unlock(&police->tcf_lock);\r\nreturn police->tcf_action;\r\n}\r\nstatic int\r\ntcf_act_police_dump(struct sk_buff *skb, struct tc_action *a, int bind, int ref)\r\n{\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct tcf_police *police = a->priv;\r\nstruct tc_police opt = {\r\n.index = police->tcf_index,\r\n.action = police->tcf_action,\r\n.mtu = police->tcfp_mtu,\r\n.burst = police->tcfp_burst,\r\n.refcnt = police->tcf_refcnt - ref,\r\n.bindcnt = police->tcf_bindcnt - bind,\r\n};\r\nif (police->tcfp_R_tab)\r\nopt.rate = police->tcfp_R_tab->rate;\r\nif (police->tcfp_P_tab)\r\nopt.peakrate = police->tcfp_P_tab->rate;\r\nNLA_PUT(skb, TCA_POLICE_TBF, sizeof(opt), &opt);\r\nif (police->tcfp_result)\r\nNLA_PUT_U32(skb, TCA_POLICE_RESULT, police->tcfp_result);\r\nif (police->tcfp_ewma_rate)\r\nNLA_PUT_U32(skb, TCA_POLICE_AVRATE, police->tcfp_ewma_rate);\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int __init\r\npolice_init_module(void)\r\n{\r\nreturn tcf_register_action(&act_police_ops);\r\n}\r\nstatic void __exit\r\npolice_cleanup_module(void)\r\n{\r\ntcf_unregister_action(&act_police_ops);\r\n}
