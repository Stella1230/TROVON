static int snd_pcm_ioctl_delay_compat(struct snd_pcm_substream *substream,\r\ns32 __user *src)\r\n{\r\nsnd_pcm_sframes_t delay;\r\nmm_segment_t fs;\r\nint err;\r\nfs = snd_enter_user();\r\nerr = snd_pcm_delay(substream, &delay);\r\nsnd_leave_user(fs);\r\nif (err < 0)\r\nreturn err;\r\nif (put_user(delay, src))\r\nreturn -EFAULT;\r\nreturn err;\r\n}\r\nstatic int snd_pcm_ioctl_rewind_compat(struct snd_pcm_substream *substream,\r\nu32 __user *src)\r\n{\r\nsnd_pcm_uframes_t frames;\r\nint err;\r\nif (get_user(frames, src))\r\nreturn -EFAULT;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nerr = snd_pcm_playback_rewind(substream, frames);\r\nelse\r\nerr = snd_pcm_capture_rewind(substream, frames);\r\nif (put_user(err, src))\r\nreturn -EFAULT;\r\nreturn err < 0 ? err : 0;\r\n}\r\nstatic int snd_pcm_ioctl_forward_compat(struct snd_pcm_substream *substream,\r\nu32 __user *src)\r\n{\r\nsnd_pcm_uframes_t frames;\r\nint err;\r\nif (get_user(frames, src))\r\nreturn -EFAULT;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nerr = snd_pcm_playback_forward(substream, frames);\r\nelse\r\nerr = snd_pcm_capture_forward(substream, frames);\r\nif (put_user(err, src))\r\nreturn -EFAULT;\r\nreturn err < 0 ? err : 0;\r\n}\r\nstatic snd_pcm_uframes_t recalculate_boundary(struct snd_pcm_runtime *runtime)\r\n{\r\nsnd_pcm_uframes_t boundary;\r\nif (! runtime->buffer_size)\r\nreturn 0;\r\nboundary = runtime->buffer_size;\r\nwhile (boundary * 2 <= 0x7fffffffUL - runtime->buffer_size)\r\nboundary *= 2;\r\nreturn boundary;\r\n}\r\nstatic int snd_pcm_ioctl_sw_params_compat(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_sw_params32 __user *src)\r\n{\r\nstruct snd_pcm_sw_params params;\r\nsnd_pcm_uframes_t boundary;\r\nint err;\r\nmemset(&params, 0, sizeof(params));\r\nif (get_user(params.tstamp_mode, &src->tstamp_mode) ||\r\nget_user(params.period_step, &src->period_step) ||\r\nget_user(params.sleep_min, &src->sleep_min) ||\r\nget_user(params.avail_min, &src->avail_min) ||\r\nget_user(params.xfer_align, &src->xfer_align) ||\r\nget_user(params.start_threshold, &src->start_threshold) ||\r\nget_user(params.stop_threshold, &src->stop_threshold) ||\r\nget_user(params.silence_threshold, &src->silence_threshold) ||\r\nget_user(params.silence_size, &src->silence_size))\r\nreturn -EFAULT;\r\nboundary = recalculate_boundary(substream->runtime);\r\nif (boundary && params.silence_size >= boundary)\r\nparams.silence_size = substream->runtime->boundary;\r\nerr = snd_pcm_sw_params(substream, &params);\r\nif (err < 0)\r\nreturn err;\r\nif (boundary && put_user(boundary, &src->boundary))\r\nreturn -EFAULT;\r\nreturn err;\r\n}\r\nstatic int snd_pcm_ioctl_channel_info_compat(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_channel_info32 __user *src)\r\n{\r\nstruct snd_pcm_channel_info info;\r\nint err;\r\nif (get_user(info.channel, &src->channel) ||\r\nget_user(info.offset, &src->offset) ||\r\nget_user(info.first, &src->first) ||\r\nget_user(info.step, &src->step))\r\nreturn -EFAULT;\r\nerr = snd_pcm_channel_info(substream, &info);\r\nif (err < 0)\r\nreturn err;\r\nif (put_user(info.channel, &src->channel) ||\r\nput_user(info.offset, &src->offset) ||\r\nput_user(info.first, &src->first) ||\r\nput_user(info.step, &src->step))\r\nreturn -EFAULT;\r\nreturn err;\r\n}\r\nstatic int snd_pcm_status_user_compat(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_status32 __user *src)\r\n{\r\nstruct snd_pcm_status status;\r\nint err;\r\nerr = snd_pcm_status(substream, &status);\r\nif (err < 0)\r\nreturn err;\r\nif (put_user(status.state, &src->state) ||\r\nput_user(status.trigger_tstamp.tv_sec, &src->trigger_tstamp.tv_sec) ||\r\nput_user(status.trigger_tstamp.tv_nsec, &src->trigger_tstamp.tv_nsec) ||\r\nput_user(status.tstamp.tv_sec, &src->tstamp.tv_sec) ||\r\nput_user(status.tstamp.tv_nsec, &src->tstamp.tv_nsec) ||\r\nput_user(status.appl_ptr, &src->appl_ptr) ||\r\nput_user(status.hw_ptr, &src->hw_ptr) ||\r\nput_user(status.delay, &src->delay) ||\r\nput_user(status.avail, &src->avail) ||\r\nput_user(status.avail_max, &src->avail_max) ||\r\nput_user(status.overrange, &src->overrange) ||\r\nput_user(status.suspended_state, &src->suspended_state))\r\nreturn -EFAULT;\r\nreturn err;\r\n}\r\nstatic int snd_pcm_ioctl_hw_params_compat(struct snd_pcm_substream *substream,\r\nint refine,\r\nstruct snd_pcm_hw_params32 __user *data32)\r\n{\r\nstruct snd_pcm_hw_params *data;\r\nstruct snd_pcm_runtime *runtime;\r\nint err;\r\nif (! (runtime = substream->runtime))\r\nreturn -ENOTTY;\r\ndata = memdup_user(data32, sizeof(*data32));\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\nif (refine)\r\nerr = snd_pcm_hw_refine(substream, data);\r\nelse\r\nerr = snd_pcm_hw_params(substream, data);\r\nif (err < 0)\r\ngoto error;\r\nif (copy_to_user(data32, data, sizeof(*data32)) ||\r\nput_user(data->fifo_size, &data32->fifo_size)) {\r\nerr = -EFAULT;\r\ngoto error;\r\n}\r\nif (! refine) {\r\nunsigned int new_boundary = recalculate_boundary(runtime);\r\nif (new_boundary)\r\nruntime->boundary = new_boundary;\r\n}\r\nerror:\r\nkfree(data);\r\nreturn err;\r\n}\r\nstatic int snd_pcm_ioctl_xferi_compat(struct snd_pcm_substream *substream,\r\nint dir, struct snd_xferi32 __user *data32)\r\n{\r\ncompat_caddr_t buf;\r\nu32 frames;\r\nint err;\r\nif (! substream->runtime)\r\nreturn -ENOTTY;\r\nif (substream->stream != dir)\r\nreturn -EINVAL;\r\nif (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN)\r\nreturn -EBADFD;\r\nif (get_user(buf, &data32->buf) ||\r\nget_user(frames, &data32->frames))\r\nreturn -EFAULT;\r\nif (dir == SNDRV_PCM_STREAM_PLAYBACK)\r\nerr = snd_pcm_lib_write(substream, compat_ptr(buf), frames);\r\nelse\r\nerr = snd_pcm_lib_read(substream, compat_ptr(buf), frames);\r\nif (err < 0)\r\nreturn err;\r\nif (put_user(err, &data32->result))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_pcm_ioctl_xfern_compat(struct snd_pcm_substream *substream,\r\nint dir, struct snd_xfern32 __user *data32)\r\n{\r\ncompat_caddr_t buf;\r\ncompat_caddr_t __user *bufptr;\r\nu32 frames;\r\nvoid __user **bufs;\r\nint err, ch, i;\r\nif (! substream->runtime)\r\nreturn -ENOTTY;\r\nif (substream->stream != dir)\r\nreturn -EINVAL;\r\nif ((ch = substream->runtime->channels) > 128)\r\nreturn -EINVAL;\r\nif (get_user(buf, &data32->bufs) ||\r\nget_user(frames, &data32->frames))\r\nreturn -EFAULT;\r\nbufptr = compat_ptr(buf);\r\nbufs = kmalloc(sizeof(void __user *) * ch, GFP_KERNEL);\r\nif (bufs == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ch; i++) {\r\nu32 ptr;\r\nif (get_user(ptr, bufptr)) {\r\nkfree(bufs);\r\nreturn -EFAULT;\r\n}\r\nbufs[i] = compat_ptr(ptr);\r\nbufptr++;\r\n}\r\nif (dir == SNDRV_PCM_STREAM_PLAYBACK)\r\nerr = snd_pcm_lib_writev(substream, bufs, frames);\r\nelse\r\nerr = snd_pcm_lib_readv(substream, bufs, frames);\r\nif (err >= 0) {\r\nif (put_user(err, &data32->result))\r\nerr = -EFAULT;\r\n}\r\nkfree(bufs);\r\nreturn err;\r\n}\r\nstatic int snd_pcm_ioctl_sync_ptr_compat(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_sync_ptr32 __user *src)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nvolatile struct snd_pcm_mmap_status *status;\r\nvolatile struct snd_pcm_mmap_control *control;\r\nu32 sflags;\r\nstruct snd_pcm_mmap_control scontrol;\r\nstruct snd_pcm_mmap_status sstatus;\r\nsnd_pcm_uframes_t boundary;\r\nint err;\r\nif (snd_BUG_ON(!runtime))\r\nreturn -EINVAL;\r\nif (get_user(sflags, &src->flags) ||\r\nget_user(scontrol.appl_ptr, &src->c.control.appl_ptr) ||\r\nget_user(scontrol.avail_min, &src->c.control.avail_min))\r\nreturn -EFAULT;\r\nif (sflags & SNDRV_PCM_SYNC_PTR_HWSYNC) {\r\nerr = snd_pcm_hwsync(substream);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nstatus = runtime->status;\r\ncontrol = runtime->control;\r\nboundary = recalculate_boundary(runtime);\r\nif (! boundary)\r\nboundary = 0x7fffffff;\r\nsnd_pcm_stream_lock_irq(substream);\r\nif (!(sflags & SNDRV_PCM_SYNC_PTR_APPL))\r\ncontrol->appl_ptr = scontrol.appl_ptr;\r\nelse\r\nscontrol.appl_ptr = control->appl_ptr % boundary;\r\nif (!(sflags & SNDRV_PCM_SYNC_PTR_AVAIL_MIN))\r\ncontrol->avail_min = scontrol.avail_min;\r\nelse\r\nscontrol.avail_min = control->avail_min;\r\nsstatus.state = status->state;\r\nsstatus.hw_ptr = status->hw_ptr % boundary;\r\nsstatus.tstamp = status->tstamp;\r\nsstatus.suspended_state = status->suspended_state;\r\nsnd_pcm_stream_unlock_irq(substream);\r\nif (put_user(sstatus.state, &src->s.status.state) ||\r\nput_user(sstatus.hw_ptr, &src->s.status.hw_ptr) ||\r\nput_user(sstatus.tstamp.tv_sec, &src->s.status.tstamp.tv_sec) ||\r\nput_user(sstatus.tstamp.tv_nsec, &src->s.status.tstamp.tv_nsec) ||\r\nput_user(sstatus.suspended_state, &src->s.status.suspended_state) ||\r\nput_user(scontrol.appl_ptr, &src->c.control.appl_ptr) ||\r\nput_user(scontrol.avail_min, &src->c.control.avail_min))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long snd_pcm_ioctl_compat(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct snd_pcm_file *pcm_file;\r\nstruct snd_pcm_substream *substream;\r\nvoid __user *argp = compat_ptr(arg);\r\npcm_file = file->private_data;\r\nif (! pcm_file)\r\nreturn -ENOTTY;\r\nsubstream = pcm_file->substream;\r\nif (! substream)\r\nreturn -ENOTTY;\r\npcm_file->no_compat_mmap = 1;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_IOCTL_PVERSION:\r\ncase SNDRV_PCM_IOCTL_INFO:\r\ncase SNDRV_PCM_IOCTL_TSTAMP:\r\ncase SNDRV_PCM_IOCTL_TTSTAMP:\r\ncase SNDRV_PCM_IOCTL_HWSYNC:\r\ncase SNDRV_PCM_IOCTL_PREPARE:\r\ncase SNDRV_PCM_IOCTL_RESET:\r\ncase SNDRV_PCM_IOCTL_START:\r\ncase SNDRV_PCM_IOCTL_DROP:\r\ncase SNDRV_PCM_IOCTL_DRAIN:\r\ncase SNDRV_PCM_IOCTL_PAUSE:\r\ncase SNDRV_PCM_IOCTL_HW_FREE:\r\ncase SNDRV_PCM_IOCTL_RESUME:\r\ncase SNDRV_PCM_IOCTL_XRUN:\r\ncase SNDRV_PCM_IOCTL_LINK:\r\ncase SNDRV_PCM_IOCTL_UNLINK:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nreturn snd_pcm_playback_ioctl1(file, substream, cmd, argp);\r\nelse\r\nreturn snd_pcm_capture_ioctl1(file, substream, cmd, argp);\r\ncase SNDRV_PCM_IOCTL_HW_REFINE32:\r\nreturn snd_pcm_ioctl_hw_params_compat(substream, 1, argp);\r\ncase SNDRV_PCM_IOCTL_HW_PARAMS32:\r\nreturn snd_pcm_ioctl_hw_params_compat(substream, 0, argp);\r\ncase SNDRV_PCM_IOCTL_SW_PARAMS32:\r\nreturn snd_pcm_ioctl_sw_params_compat(substream, argp);\r\ncase SNDRV_PCM_IOCTL_STATUS32:\r\nreturn snd_pcm_status_user_compat(substream, argp);\r\ncase SNDRV_PCM_IOCTL_SYNC_PTR32:\r\nreturn snd_pcm_ioctl_sync_ptr_compat(substream, argp);\r\ncase SNDRV_PCM_IOCTL_CHANNEL_INFO32:\r\nreturn snd_pcm_ioctl_channel_info_compat(substream, argp);\r\ncase SNDRV_PCM_IOCTL_WRITEI_FRAMES32:\r\nreturn snd_pcm_ioctl_xferi_compat(substream, SNDRV_PCM_STREAM_PLAYBACK, argp);\r\ncase SNDRV_PCM_IOCTL_READI_FRAMES32:\r\nreturn snd_pcm_ioctl_xferi_compat(substream, SNDRV_PCM_STREAM_CAPTURE, argp);\r\ncase SNDRV_PCM_IOCTL_WRITEN_FRAMES32:\r\nreturn snd_pcm_ioctl_xfern_compat(substream, SNDRV_PCM_STREAM_PLAYBACK, argp);\r\ncase SNDRV_PCM_IOCTL_READN_FRAMES32:\r\nreturn snd_pcm_ioctl_xfern_compat(substream, SNDRV_PCM_STREAM_CAPTURE, argp);\r\ncase SNDRV_PCM_IOCTL_DELAY32:\r\nreturn snd_pcm_ioctl_delay_compat(substream, argp);\r\ncase SNDRV_PCM_IOCTL_REWIND32:\r\nreturn snd_pcm_ioctl_rewind_compat(substream, argp);\r\ncase SNDRV_PCM_IOCTL_FORWARD32:\r\nreturn snd_pcm_ioctl_forward_compat(substream, argp);\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}
