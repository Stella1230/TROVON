static bool wm8903_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM8903_SW_RESET_AND_ID:\r\ncase WM8903_REVISION_NUMBER:\r\ncase WM8903_BIAS_CONTROL_0:\r\ncase WM8903_VMID_CONTROL_0:\r\ncase WM8903_MIC_BIAS_CONTROL_0:\r\ncase WM8903_ANALOGUE_DAC_0:\r\ncase WM8903_ANALOGUE_ADC_0:\r\ncase WM8903_POWER_MANAGEMENT_0:\r\ncase WM8903_POWER_MANAGEMENT_1:\r\ncase WM8903_POWER_MANAGEMENT_2:\r\ncase WM8903_POWER_MANAGEMENT_3:\r\ncase WM8903_POWER_MANAGEMENT_4:\r\ncase WM8903_POWER_MANAGEMENT_5:\r\ncase WM8903_POWER_MANAGEMENT_6:\r\ncase WM8903_CLOCK_RATES_0:\r\ncase WM8903_CLOCK_RATES_1:\r\ncase WM8903_CLOCK_RATES_2:\r\ncase WM8903_AUDIO_INTERFACE_0:\r\ncase WM8903_AUDIO_INTERFACE_1:\r\ncase WM8903_AUDIO_INTERFACE_2:\r\ncase WM8903_AUDIO_INTERFACE_3:\r\ncase WM8903_DAC_DIGITAL_VOLUME_LEFT:\r\ncase WM8903_DAC_DIGITAL_VOLUME_RIGHT:\r\ncase WM8903_DAC_DIGITAL_0:\r\ncase WM8903_DAC_DIGITAL_1:\r\ncase WM8903_ADC_DIGITAL_VOLUME_LEFT:\r\ncase WM8903_ADC_DIGITAL_VOLUME_RIGHT:\r\ncase WM8903_ADC_DIGITAL_0:\r\ncase WM8903_DIGITAL_MICROPHONE_0:\r\ncase WM8903_DRC_0:\r\ncase WM8903_DRC_1:\r\ncase WM8903_DRC_2:\r\ncase WM8903_DRC_3:\r\ncase WM8903_ANALOGUE_LEFT_INPUT_0:\r\ncase WM8903_ANALOGUE_RIGHT_INPUT_0:\r\ncase WM8903_ANALOGUE_LEFT_INPUT_1:\r\ncase WM8903_ANALOGUE_RIGHT_INPUT_1:\r\ncase WM8903_ANALOGUE_LEFT_MIX_0:\r\ncase WM8903_ANALOGUE_RIGHT_MIX_0:\r\ncase WM8903_ANALOGUE_SPK_MIX_LEFT_0:\r\ncase WM8903_ANALOGUE_SPK_MIX_LEFT_1:\r\ncase WM8903_ANALOGUE_SPK_MIX_RIGHT_0:\r\ncase WM8903_ANALOGUE_SPK_MIX_RIGHT_1:\r\ncase WM8903_ANALOGUE_OUT1_LEFT:\r\ncase WM8903_ANALOGUE_OUT1_RIGHT:\r\ncase WM8903_ANALOGUE_OUT2_LEFT:\r\ncase WM8903_ANALOGUE_OUT2_RIGHT:\r\ncase WM8903_ANALOGUE_OUT3_LEFT:\r\ncase WM8903_ANALOGUE_OUT3_RIGHT:\r\ncase WM8903_ANALOGUE_SPK_OUTPUT_CONTROL_0:\r\ncase WM8903_DC_SERVO_0:\r\ncase WM8903_DC_SERVO_2:\r\ncase WM8903_DC_SERVO_READBACK_1:\r\ncase WM8903_DC_SERVO_READBACK_2:\r\ncase WM8903_DC_SERVO_READBACK_3:\r\ncase WM8903_DC_SERVO_READBACK_4:\r\ncase WM8903_ANALOGUE_HP_0:\r\ncase WM8903_ANALOGUE_LINEOUT_0:\r\ncase WM8903_CHARGE_PUMP_0:\r\ncase WM8903_CLASS_W_0:\r\ncase WM8903_WRITE_SEQUENCER_0:\r\ncase WM8903_WRITE_SEQUENCER_1:\r\ncase WM8903_WRITE_SEQUENCER_2:\r\ncase WM8903_WRITE_SEQUENCER_3:\r\ncase WM8903_WRITE_SEQUENCER_4:\r\ncase WM8903_CONTROL_INTERFACE:\r\ncase WM8903_GPIO_CONTROL_1:\r\ncase WM8903_GPIO_CONTROL_2:\r\ncase WM8903_GPIO_CONTROL_3:\r\ncase WM8903_GPIO_CONTROL_4:\r\ncase WM8903_GPIO_CONTROL_5:\r\ncase WM8903_INTERRUPT_STATUS_1:\r\ncase WM8903_INTERRUPT_STATUS_1_MASK:\r\ncase WM8903_INTERRUPT_POLARITY_1:\r\ncase WM8903_INTERRUPT_CONTROL:\r\ncase WM8903_CLOCK_RATE_TEST_4:\r\ncase WM8903_ANALOGUE_OUTPUT_BIAS_0:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool wm8903_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM8903_SW_RESET_AND_ID:\r\ncase WM8903_REVISION_NUMBER:\r\ncase WM8903_INTERRUPT_STATUS_1:\r\ncase WM8903_WRITE_SEQUENCER_4:\r\ncase WM8903_DC_SERVO_READBACK_1:\r\ncase WM8903_DC_SERVO_READBACK_2:\r\ncase WM8903_DC_SERVO_READBACK_3:\r\ncase WM8903_DC_SERVO_READBACK_4:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int wm8903_cp_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nWARN_ON(event != SND_SOC_DAPM_POST_PMU);\r\nmdelay(4);\r\nreturn 0;\r\n}\r\nstatic int wm8903_dcs_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nstruct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nwm8903->dcs_pending |= 1 << w->shift;\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(codec, WM8903_DC_SERVO_0,\r\n1 << w->shift, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void wm8903_seq_notifier(struct snd_soc_dapm_context *dapm,\r\nenum snd_soc_dapm_type event, int subseq)\r\n{\r\nstruct snd_soc_codec *codec = container_of(dapm,\r\nstruct snd_soc_codec, dapm);\r\nstruct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);\r\nint dcs_mode = WM8903_DCS_MODE_WRITE_STOP;\r\nint i, val;\r\nif (wm8903->dcs_pending) {\r\ndev_dbg(codec->dev, "Starting DC servo for %x\n",\r\nwm8903->dcs_pending);\r\nfor (i = 0; i < ARRAY_SIZE(wm8903->dcs_cache); i++) {\r\nif (!(wm8903->dcs_pending & (1 << i)))\r\ncontinue;\r\nif (wm8903->dcs_cache[i]) {\r\ndev_dbg(codec->dev,\r\n"Restore DC servo %d value %x\n",\r\n3 - i, wm8903->dcs_cache[i]);\r\nsnd_soc_write(codec, WM8903_DC_SERVO_4 + i,\r\nwm8903->dcs_cache[i] & 0xff);\r\n} else {\r\ndev_dbg(codec->dev,\r\n"Calibrate DC servo %d\n", 3 - i);\r\ndcs_mode = WM8903_DCS_MODE_START_STOP;\r\n}\r\n}\r\nif (wm8903->class_w_users)\r\ndcs_mode = WM8903_DCS_MODE_START_STOP;\r\nsnd_soc_update_bits(codec, WM8903_DC_SERVO_2,\r\nWM8903_DCS_MODE_MASK, dcs_mode);\r\nsnd_soc_update_bits(codec, WM8903_DC_SERVO_0,\r\nWM8903_DCS_ENA_MASK, wm8903->dcs_pending);\r\nswitch (dcs_mode) {\r\ncase WM8903_DCS_MODE_WRITE_STOP:\r\nbreak;\r\ncase WM8903_DCS_MODE_START_STOP:\r\nmsleep(270);\r\nif (wm8903->class_w_users)\r\nbreak;\r\nfor (i = 0; i < ARRAY_SIZE(wm8903->dcs_cache); i++) {\r\nif (!(wm8903->dcs_pending & (1 << i)))\r\ncontinue;\r\nval = snd_soc_read(codec,\r\nWM8903_DC_SERVO_READBACK_1 + i);\r\ndev_dbg(codec->dev, "DC servo %d: %x\n",\r\n3 - i, val);\r\nwm8903->dcs_cache[i] = val;\r\n}\r\nbreak;\r\ndefault:\r\npr_warn("DCS mode %d delay not set\n", dcs_mode);\r\nbreak;\r\n}\r\nwm8903->dcs_pending = 0;\r\n}\r\n}\r\nstatic int wm8903_class_w_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);\r\nstruct snd_soc_dapm_widget *widget = wlist->widgets[0];\r\nstruct snd_soc_codec *codec = widget->codec;\r\nstruct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);\r\nu16 reg;\r\nint ret;\r\nreg = snd_soc_read(codec, WM8903_CLASS_W_0);\r\nif (ucontrol->value.integer.value[0]) {\r\nif (wm8903->class_w_users == 0) {\r\ndev_dbg(codec->dev, "Disabling Class W\n");\r\nsnd_soc_write(codec, WM8903_CLASS_W_0, reg &\r\n~(WM8903_CP_DYN_FREQ | WM8903_CP_DYN_V));\r\n}\r\nwm8903->class_w_users++;\r\n}\r\nret = snd_soc_dapm_put_volsw(kcontrol, ucontrol);\r\nif (!ucontrol->value.integer.value[0]) {\r\nif (wm8903->class_w_users == 1) {\r\ndev_dbg(codec->dev, "Enabling Class W\n");\r\nsnd_soc_write(codec, WM8903_CLASS_W_0, reg |\r\nWM8903_CP_DYN_FREQ | WM8903_CP_DYN_V);\r\n}\r\nwm8903->class_w_users--;\r\n}\r\ndev_dbg(codec->dev, "Bypass use count now %d\n",\r\nwm8903->class_w_users);\r\nreturn ret;\r\n}\r\nstatic int wm8903_set_deemph(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);\r\nint val, i, best;\r\nif (wm8903->deemph) {\r\nbest = 1;\r\nfor (i = 2; i < ARRAY_SIZE(wm8903_deemph); i++) {\r\nif (abs(wm8903_deemph[i] - wm8903->fs) <\r\nabs(wm8903_deemph[best] - wm8903->fs))\r\nbest = i;\r\n}\r\nval = best << WM8903_DEEMPH_SHIFT;\r\n} else {\r\nbest = 0;\r\nval = 0;\r\n}\r\ndev_dbg(codec->dev, "Set deemphasis %d (%dHz)\n",\r\nbest, wm8903_deemph[best]);\r\nreturn snd_soc_update_bits(codec, WM8903_DAC_DIGITAL_1,\r\nWM8903_DEEMPH_MASK, val);\r\n}\r\nstatic int wm8903_get_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.enumerated.item[0] = wm8903->deemph;\r\nreturn 0;\r\n}\r\nstatic int wm8903_put_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);\r\nint deemph = ucontrol->value.enumerated.item[0];\r\nint ret = 0;\r\nif (deemph > 1)\r\nreturn -EINVAL;\r\nmutex_lock(&codec->mutex);\r\nif (wm8903->deemph != deemph) {\r\nwm8903->deemph = deemph;\r\nwm8903_set_deemph(codec);\r\nret = 1;\r\n}\r\nmutex_unlock(&codec->mutex);\r\nreturn ret;\r\n}\r\nstatic int wm8903_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_update_bits(codec, WM8903_VMID_CONTROL_0,\r\nWM8903_VMID_RES_MASK,\r\nWM8903_VMID_RES_50K);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nsnd_soc_update_bits(codec, WM8903_BIAS_CONTROL_0,\r\nWM8903_POBCTRL | WM8903_ISEL_MASK |\r\nWM8903_STARTUP_BIAS_ENA |\r\nWM8903_BIAS_ENA,\r\nWM8903_POBCTRL |\r\n(2 << WM8903_ISEL_SHIFT) |\r\nWM8903_STARTUP_BIAS_ENA);\r\nsnd_soc_update_bits(codec,\r\nWM8903_ANALOGUE_SPK_OUTPUT_CONTROL_0,\r\nWM8903_SPK_DISCHARGE,\r\nWM8903_SPK_DISCHARGE);\r\nmsleep(33);\r\nsnd_soc_update_bits(codec, WM8903_POWER_MANAGEMENT_5,\r\nWM8903_SPKL_ENA | WM8903_SPKR_ENA,\r\nWM8903_SPKL_ENA | WM8903_SPKR_ENA);\r\nsnd_soc_update_bits(codec,\r\nWM8903_ANALOGUE_SPK_OUTPUT_CONTROL_0,\r\nWM8903_SPK_DISCHARGE, 0);\r\nsnd_soc_update_bits(codec, WM8903_VMID_CONTROL_0,\r\nWM8903_VMID_TIE_ENA |\r\nWM8903_BUFIO_ENA |\r\nWM8903_VMID_IO_ENA |\r\nWM8903_VMID_SOFT_MASK |\r\nWM8903_VMID_RES_MASK |\r\nWM8903_VMID_BUF_ENA,\r\nWM8903_VMID_TIE_ENA |\r\nWM8903_BUFIO_ENA |\r\nWM8903_VMID_IO_ENA |\r\n(2 << WM8903_VMID_SOFT_SHIFT) |\r\nWM8903_VMID_RES_250K |\r\nWM8903_VMID_BUF_ENA);\r\nmsleep(129);\r\nsnd_soc_update_bits(codec, WM8903_POWER_MANAGEMENT_5,\r\nWM8903_SPKL_ENA | WM8903_SPKR_ENA,\r\n0);\r\nsnd_soc_update_bits(codec, WM8903_VMID_CONTROL_0,\r\nWM8903_VMID_SOFT_MASK, 0);\r\nsnd_soc_update_bits(codec, WM8903_VMID_CONTROL_0,\r\nWM8903_VMID_RES_MASK,\r\nWM8903_VMID_RES_50K);\r\nsnd_soc_update_bits(codec, WM8903_BIAS_CONTROL_0,\r\nWM8903_BIAS_ENA | WM8903_POBCTRL,\r\nWM8903_BIAS_ENA);\r\ndev_dbg(codec->dev, "Enabling Class W\n");\r\nsnd_soc_update_bits(codec, WM8903_CLASS_W_0,\r\nWM8903_CP_DYN_FREQ |\r\nWM8903_CP_DYN_V,\r\nWM8903_CP_DYN_FREQ |\r\nWM8903_CP_DYN_V);\r\n}\r\nsnd_soc_update_bits(codec, WM8903_VMID_CONTROL_0,\r\nWM8903_VMID_RES_MASK,\r\nWM8903_VMID_RES_250K);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, WM8903_BIAS_CONTROL_0,\r\nWM8903_BIAS_ENA, 0);\r\nsnd_soc_update_bits(codec, WM8903_VMID_CONTROL_0,\r\nWM8903_VMID_SOFT_MASK,\r\n2 << WM8903_VMID_SOFT_SHIFT);\r\nsnd_soc_update_bits(codec, WM8903_VMID_CONTROL_0,\r\nWM8903_VMID_BUF_ENA, 0);\r\nmsleep(290);\r\nsnd_soc_update_bits(codec, WM8903_VMID_CONTROL_0,\r\nWM8903_VMID_TIE_ENA | WM8903_BUFIO_ENA |\r\nWM8903_VMID_IO_ENA | WM8903_VMID_RES_MASK |\r\nWM8903_VMID_SOFT_MASK |\r\nWM8903_VMID_BUF_ENA, 0);\r\nsnd_soc_update_bits(codec, WM8903_BIAS_CONTROL_0,\r\nWM8903_STARTUP_BIAS_ENA, 0);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int wm8903_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);\r\nwm8903->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int wm8903_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 aif1 = snd_soc_read(codec, WM8903_AUDIO_INTERFACE_1);\r\naif1 &= ~(WM8903_LRCLK_DIR | WM8903_BCLK_DIR | WM8903_AIF_FMT_MASK |\r\nWM8903_AIF_LRCLK_INV | WM8903_AIF_BCLK_INV);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\naif1 |= WM8903_LRCLK_DIR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\naif1 |= WM8903_LRCLK_DIR | WM8903_BCLK_DIR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\naif1 |= WM8903_BCLK_DIR;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\naif1 |= 0x3;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\naif1 |= 0x3 | WM8903_AIF_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\naif1 |= 0x2;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\naif1 |= 0x1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\naif1 |= WM8903_AIF_BCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\naif1 |= WM8903_AIF_BCLK_INV | WM8903_AIF_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\naif1 |= WM8903_AIF_BCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\naif1 |= WM8903_AIF_LRCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, WM8903_AUDIO_INTERFACE_1, aif1);\r\nreturn 0;\r\n}\r\nstatic int wm8903_digital_mute(struct snd_soc_dai *codec_dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 reg;\r\nreg = snd_soc_read(codec, WM8903_DAC_DIGITAL_1);\r\nif (mute)\r\nreg |= WM8903_DAC_MUTE;\r\nelse\r\nreg &= ~WM8903_DAC_MUTE;\r\nsnd_soc_write(codec, WM8903_DAC_DIGITAL_1, reg);\r\nreturn 0;\r\n}\r\nstatic int wm8903_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_codec *codec =rtd->codec;\r\nstruct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);\r\nint fs = params_rate(params);\r\nint bclk;\r\nint bclk_div;\r\nint i;\r\nint dsp_config;\r\nint clk_config;\r\nint best_val;\r\nint cur_val;\r\nint clk_sys;\r\nu16 aif1 = snd_soc_read(codec, WM8903_AUDIO_INTERFACE_1);\r\nu16 aif2 = snd_soc_read(codec, WM8903_AUDIO_INTERFACE_2);\r\nu16 aif3 = snd_soc_read(codec, WM8903_AUDIO_INTERFACE_3);\r\nu16 clock0 = snd_soc_read(codec, WM8903_CLOCK_RATES_0);\r\nu16 clock1 = snd_soc_read(codec, WM8903_CLOCK_RATES_1);\r\nu16 dac_digital1 = snd_soc_read(codec, WM8903_DAC_DIGITAL_1);\r\nif (fs <= 24000)\r\ndac_digital1 |= WM8903_DAC_SB_FILT;\r\nelse\r\ndac_digital1 &= ~WM8903_DAC_SB_FILT;\r\ndsp_config = 0;\r\nbest_val = abs(sample_rates[dsp_config].rate - fs);\r\nfor (i = 1; i < ARRAY_SIZE(sample_rates); i++) {\r\ncur_val = abs(sample_rates[i].rate - fs);\r\nif (cur_val <= best_val) {\r\ndsp_config = i;\r\nbest_val = cur_val;\r\n}\r\n}\r\ndev_dbg(codec->dev, "DSP fs = %dHz\n", sample_rates[dsp_config].rate);\r\nclock1 &= ~WM8903_SAMPLE_RATE_MASK;\r\nclock1 |= sample_rates[dsp_config].value;\r\naif1 &= ~WM8903_AIF_WL_MASK;\r\nbclk = 2 * fs;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbclk *= 16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nbclk *= 20;\r\naif1 |= 0x4;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nbclk *= 24;\r\naif1 |= 0x8;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nbclk *= 32;\r\naif1 |= 0xc;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(codec->dev, "MCLK = %dHz, target sample rate = %dHz\n",\r\nwm8903->sysclk, fs);\r\nclk_config = 0;\r\nbest_val = abs((wm8903->sysclk /\r\n(clk_sys_ratios[0].mclk_div *\r\nclk_sys_ratios[0].div)) - fs);\r\nfor (i = 1; i < ARRAY_SIZE(clk_sys_ratios); i++) {\r\ncur_val = abs((wm8903->sysclk /\r\n(clk_sys_ratios[i].mclk_div *\r\nclk_sys_ratios[i].div)) - fs);\r\nif (cur_val <= best_val) {\r\nclk_config = i;\r\nbest_val = cur_val;\r\n}\r\n}\r\nif (clk_sys_ratios[clk_config].mclk_div == 2) {\r\nclock0 |= WM8903_MCLKDIV2;\r\nclk_sys = wm8903->sysclk / 2;\r\n} else {\r\nclock0 &= ~WM8903_MCLKDIV2;\r\nclk_sys = wm8903->sysclk;\r\n}\r\nclock1 &= ~(WM8903_CLK_SYS_RATE_MASK |\r\nWM8903_CLK_SYS_MODE_MASK);\r\nclock1 |= clk_sys_ratios[clk_config].rate << WM8903_CLK_SYS_RATE_SHIFT;\r\nclock1 |= clk_sys_ratios[clk_config].mode << WM8903_CLK_SYS_MODE_SHIFT;\r\ndev_dbg(codec->dev, "CLK_SYS_RATE=%x, CLK_SYS_MODE=%x div=%d\n",\r\nclk_sys_ratios[clk_config].rate,\r\nclk_sys_ratios[clk_config].mode,\r\nclk_sys_ratios[clk_config].div);\r\ndev_dbg(codec->dev, "Actual CLK_SYS = %dHz\n", clk_sys);\r\nbclk_div = 0;\r\nbest_val = ((clk_sys * 10) / bclk_divs[0].ratio) - bclk;\r\ni = 1;\r\nwhile (i < ARRAY_SIZE(bclk_divs)) {\r\ncur_val = ((clk_sys * 10) / bclk_divs[i].ratio) - bclk;\r\nif (cur_val < 0)\r\nbreak;\r\nbclk_div = i;\r\nbest_val = cur_val;\r\ni++;\r\n}\r\naif2 &= ~WM8903_BCLK_DIV_MASK;\r\naif3 &= ~WM8903_LRCLK_RATE_MASK;\r\ndev_dbg(codec->dev, "BCLK ratio %d for %dHz - actual BCLK = %dHz\n",\r\nbclk_divs[bclk_div].ratio / 10, bclk,\r\n(clk_sys * 10) / bclk_divs[bclk_div].ratio);\r\naif2 |= bclk_divs[bclk_div].div;\r\naif3 |= bclk / fs;\r\nwm8903->fs = params_rate(params);\r\nwm8903_set_deemph(codec);\r\nsnd_soc_write(codec, WM8903_CLOCK_RATES_0, clock0);\r\nsnd_soc_write(codec, WM8903_CLOCK_RATES_1, clock1);\r\nsnd_soc_write(codec, WM8903_AUDIO_INTERFACE_1, aif1);\r\nsnd_soc_write(codec, WM8903_AUDIO_INTERFACE_2, aif2);\r\nsnd_soc_write(codec, WM8903_AUDIO_INTERFACE_3, aif3);\r\nsnd_soc_write(codec, WM8903_DAC_DIGITAL_1, dac_digital1);\r\nreturn 0;\r\n}\r\nint wm8903_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *jack,\r\nint det, int shrt)\r\n{\r\nstruct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);\r\nint irq_mask = WM8903_MICDET_EINT | WM8903_MICSHRT_EINT;\r\ndev_dbg(codec->dev, "Enabling microphone detection: %x %x\n",\r\ndet, shrt);\r\nwm8903->mic_jack = jack;\r\nwm8903->mic_det = det;\r\nwm8903->mic_short = shrt;\r\nif (det)\r\nirq_mask &= ~WM8903_MICDET_EINT;\r\nif (shrt)\r\nirq_mask &= ~WM8903_MICSHRT_EINT;\r\nsnd_soc_update_bits(codec, WM8903_INTERRUPT_STATUS_1_MASK,\r\nWM8903_MICDET_EINT | WM8903_MICSHRT_EINT,\r\nirq_mask);\r\nif (det || shrt) {\r\nsnd_soc_update_bits(codec, WM8903_WRITE_SEQUENCER_0,\r\nWM8903_WSEQ_ENA, WM8903_WSEQ_ENA);\r\nsnd_soc_update_bits(codec, WM8903_MIC_BIAS_CONTROL_0,\r\nWM8903_MICDET_ENA, WM8903_MICDET_ENA);\r\n} else {\r\nsnd_soc_update_bits(codec, WM8903_MIC_BIAS_CONTROL_0,\r\nWM8903_MICDET_ENA, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t wm8903_irq(int irq, void *data)\r\n{\r\nstruct snd_soc_codec *codec = data;\r\nstruct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);\r\nint mic_report;\r\nint int_pol;\r\nint int_val = 0;\r\nint mask = ~snd_soc_read(codec, WM8903_INTERRUPT_STATUS_1_MASK);\r\nint_val = snd_soc_read(codec, WM8903_INTERRUPT_STATUS_1) & mask;\r\nif (int_val & WM8903_WSEQ_BUSY_EINT) {\r\ndev_warn(codec->dev, "Write sequencer done\n");\r\n}\r\nmic_report = wm8903->mic_last_report;\r\nint_pol = snd_soc_read(codec, WM8903_INTERRUPT_POLARITY_1);\r\n#ifndef CONFIG_SND_SOC_WM8903_MODULE\r\nif (int_val & (WM8903_MICSHRT_EINT | WM8903_MICDET_EINT))\r\ntrace_snd_soc_jack_irq(dev_name(codec->dev));\r\n#endif\r\nif (int_val & WM8903_MICSHRT_EINT) {\r\ndev_dbg(codec->dev, "Microphone short (pol=%x)\n", int_pol);\r\nmic_report ^= wm8903->mic_short;\r\nint_pol ^= WM8903_MICSHRT_INV;\r\n}\r\nif (int_val & WM8903_MICDET_EINT) {\r\ndev_dbg(codec->dev, "Microphone detect (pol=%x)\n", int_pol);\r\nmic_report ^= wm8903->mic_det;\r\nint_pol ^= WM8903_MICDET_INV;\r\nmsleep(wm8903->mic_delay);\r\n}\r\nsnd_soc_update_bits(codec, WM8903_INTERRUPT_POLARITY_1,\r\nWM8903_MICSHRT_INV | WM8903_MICDET_INV, int_pol);\r\nsnd_soc_jack_report(wm8903->mic_jack, mic_report,\r\nwm8903->mic_short | wm8903->mic_det);\r\nwm8903->mic_last_report = mic_report;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int wm8903_suspend(struct snd_soc_codec *codec)\r\n{\r\nwm8903_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm8903_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);\r\nregcache_sync(wm8903->regmap);\r\nwm8903_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic inline struct wm8903_priv *gpio_to_wm8903(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct wm8903_priv, gpio_chip);\r\n}\r\nstatic int wm8903_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nif (offset >= WM8903_NUM_GPIO)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int wm8903_gpio_direction_in(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct wm8903_priv *wm8903 = gpio_to_wm8903(chip);\r\nstruct snd_soc_codec *codec = wm8903->codec;\r\nunsigned int mask, val;\r\nint ret;\r\nmask = WM8903_GP1_FN_MASK | WM8903_GP1_DIR_MASK;\r\nval = (WM8903_GPn_FN_GPIO_INPUT << WM8903_GP1_FN_SHIFT) |\r\nWM8903_GP1_DIR;\r\nret = snd_soc_update_bits(codec, WM8903_GPIO_CONTROL_1 + offset,\r\nmask, val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int wm8903_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct wm8903_priv *wm8903 = gpio_to_wm8903(chip);\r\nstruct snd_soc_codec *codec = wm8903->codec;\r\nint reg;\r\nreg = snd_soc_read(codec, WM8903_GPIO_CONTROL_1 + offset);\r\nreturn (reg & WM8903_GP1_LVL_MASK) >> WM8903_GP1_LVL_SHIFT;\r\n}\r\nstatic int wm8903_gpio_direction_out(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct wm8903_priv *wm8903 = gpio_to_wm8903(chip);\r\nstruct snd_soc_codec *codec = wm8903->codec;\r\nunsigned int mask, val;\r\nint ret;\r\nmask = WM8903_GP1_FN_MASK | WM8903_GP1_DIR_MASK | WM8903_GP1_LVL_MASK;\r\nval = (WM8903_GPn_FN_GPIO_OUTPUT << WM8903_GP1_FN_SHIFT) |\r\n(value << WM8903_GP2_LVL_SHIFT);\r\nret = snd_soc_update_bits(codec, WM8903_GPIO_CONTROL_1 + offset,\r\nmask, val);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void wm8903_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct wm8903_priv *wm8903 = gpio_to_wm8903(chip);\r\nstruct snd_soc_codec *codec = wm8903->codec;\r\nsnd_soc_update_bits(codec, WM8903_GPIO_CONTROL_1 + offset,\r\nWM8903_GP1_LVL_MASK,\r\n!!value << WM8903_GP1_LVL_SHIFT);\r\n}\r\nstatic void wm8903_init_gpio(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8903_platform_data *pdata = wm8903->pdata;\r\nint ret;\r\nwm8903->gpio_chip = wm8903_template_chip;\r\nwm8903->gpio_chip.ngpio = WM8903_NUM_GPIO;\r\nwm8903->gpio_chip.dev = codec->dev;\r\nif (pdata->gpio_base)\r\nwm8903->gpio_chip.base = pdata->gpio_base;\r\nelse\r\nwm8903->gpio_chip.base = -1;\r\nret = gpiochip_add(&wm8903->gpio_chip);\r\nif (ret != 0)\r\ndev_err(codec->dev, "Failed to add GPIOs: %d\n", ret);\r\n}\r\nstatic void wm8903_free_gpio(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = gpiochip_remove(&wm8903->gpio_chip);\r\nif (ret != 0)\r\ndev_err(codec->dev, "Failed to remove GPIOs: %d\n", ret);\r\n}\r\nstatic void wm8903_init_gpio(struct snd_soc_codec *codec)\r\n{\r\n}\r\nstatic void wm8903_free_gpio(struct snd_soc_codec *codec)\r\n{\r\n}\r\nstatic int wm8903_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8903_platform_data *pdata = wm8903->pdata;\r\nint ret, i;\r\nint trigger, irq_pol;\r\nu16 val;\r\nbool mic_gpio = false;\r\nwm8903->codec = codec;\r\ncodec->control_data = wm8903->regmap;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 16, SND_SOC_REGMAP);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(pdata->gpio_cfg); i++) {\r\nif ((!pdata->gpio_cfg[i]) ||\r\n(pdata->gpio_cfg[i] > WM8903_GPIO_CONFIG_ZERO))\r\ncontinue;\r\nsnd_soc_write(codec, WM8903_GPIO_CONTROL_1 + i,\r\npdata->gpio_cfg[i] & 0x7fff);\r\nval = (pdata->gpio_cfg[i] & WM8903_GP1_FN_MASK)\r\n>> WM8903_GP1_FN_SHIFT;\r\nswitch (val) {\r\ncase WM8903_GPn_FN_MICBIAS_CURRENT_DETECT:\r\ncase WM8903_GPn_FN_MICBIAS_SHORT_DETECT:\r\nmic_gpio = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nsnd_soc_write(codec, WM8903_MIC_BIAS_CONTROL_0,\r\npdata->micdet_cfg);\r\nif (pdata->micdet_cfg)\r\nsnd_soc_update_bits(codec, WM8903_WRITE_SEQUENCER_0,\r\nWM8903_WSEQ_ENA, WM8903_WSEQ_ENA);\r\nWARN_ON(!mic_gpio && (pdata->micdet_cfg & WM8903_MICDET_ENA));\r\nwm8903->mic_delay = pdata->micdet_delay;\r\nif (wm8903->irq) {\r\nif (pdata->irq_active_low) {\r\ntrigger = IRQF_TRIGGER_LOW;\r\nirq_pol = WM8903_IRQ_POL;\r\n} else {\r\ntrigger = IRQF_TRIGGER_HIGH;\r\nirq_pol = 0;\r\n}\r\nsnd_soc_update_bits(codec, WM8903_INTERRUPT_CONTROL,\r\nWM8903_IRQ_POL, irq_pol);\r\nret = request_threaded_irq(wm8903->irq, NULL, wm8903_irq,\r\ntrigger | IRQF_ONESHOT,\r\n"wm8903", codec);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to request IRQ: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nsnd_soc_update_bits(codec, WM8903_INTERRUPT_STATUS_1_MASK,\r\nWM8903_IM_WSEQ_BUSY_EINT, 0);\r\n}\r\nwm8903_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nval = snd_soc_read(codec, WM8903_ADC_DIGITAL_VOLUME_LEFT);\r\nval |= WM8903_ADCVU;\r\nsnd_soc_write(codec, WM8903_ADC_DIGITAL_VOLUME_LEFT, val);\r\nsnd_soc_write(codec, WM8903_ADC_DIGITAL_VOLUME_RIGHT, val);\r\nval = snd_soc_read(codec, WM8903_DAC_DIGITAL_VOLUME_LEFT);\r\nval |= WM8903_DACVU;\r\nsnd_soc_write(codec, WM8903_DAC_DIGITAL_VOLUME_LEFT, val);\r\nsnd_soc_write(codec, WM8903_DAC_DIGITAL_VOLUME_RIGHT, val);\r\nval = snd_soc_read(codec, WM8903_ANALOGUE_OUT1_LEFT);\r\nval |= WM8903_HPOUTVU;\r\nsnd_soc_write(codec, WM8903_ANALOGUE_OUT1_LEFT, val);\r\nsnd_soc_write(codec, WM8903_ANALOGUE_OUT1_RIGHT, val);\r\nval = snd_soc_read(codec, WM8903_ANALOGUE_OUT2_LEFT);\r\nval |= WM8903_LINEOUTVU;\r\nsnd_soc_write(codec, WM8903_ANALOGUE_OUT2_LEFT, val);\r\nsnd_soc_write(codec, WM8903_ANALOGUE_OUT2_RIGHT, val);\r\nval = snd_soc_read(codec, WM8903_ANALOGUE_OUT3_LEFT);\r\nval |= WM8903_SPKVU;\r\nsnd_soc_write(codec, WM8903_ANALOGUE_OUT3_LEFT, val);\r\nsnd_soc_write(codec, WM8903_ANALOGUE_OUT3_RIGHT, val);\r\nsnd_soc_update_bits(codec, WM8903_DAC_DIGITAL_1,\r\nWM8903_DAC_MUTEMODE | WM8903_DAC_MUTE,\r\nWM8903_DAC_MUTEMODE | WM8903_DAC_MUTE);\r\nwm8903_init_gpio(codec);\r\nreturn ret;\r\n}\r\nstatic int wm8903_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);\r\nwm8903_free_gpio(codec);\r\nwm8903_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nif (wm8903->irq)\r\nfree_irq(wm8903->irq, codec);\r\nreturn 0;\r\n}\r\nstatic int wm8903_set_pdata_irq_trigger(struct i2c_client *i2c,\r\nstruct wm8903_platform_data *pdata)\r\n{\r\nstruct irq_data *irq_data = irq_get_irq_data(i2c->irq);\r\nif (!irq_data) {\r\ndev_err(&i2c->dev, "Invalid IRQ: %d\n",\r\ni2c->irq);\r\nreturn -EINVAL;\r\n}\r\nswitch (irqd_get_trigger_type(irq_data)) {\r\ncase IRQ_TYPE_NONE:\r\ndefault:\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\npdata->irq_active_low = false;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\npdata->irq_active_low = true;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8903_set_pdata_from_of(struct i2c_client *i2c,\r\nstruct wm8903_platform_data *pdata)\r\n{\r\nconst struct device_node *np = i2c->dev.of_node;\r\nu32 val32;\r\nint i;\r\nif (of_property_read_u32(np, "micdet-cfg", &val32) >= 0)\r\npdata->micdet_cfg = val32;\r\nif (of_property_read_u32(np, "micdet-delay", &val32) >= 0)\r\npdata->micdet_delay = val32;\r\nif (of_property_read_u32_array(np, "gpio-cfg", pdata->gpio_cfg,\r\nARRAY_SIZE(pdata->gpio_cfg)) >= 0) {\r\nfor (i = 0; i < ARRAY_SIZE(pdata->gpio_cfg); i++) {\r\nif (pdata->gpio_cfg[i] == 0) {\r\npdata->gpio_cfg[i] = WM8903_GPIO_CONFIG_ZERO;\r\n} else if (pdata->gpio_cfg[i] == 0xffffffff) {\r\npdata->gpio_cfg[i] = 0;\r\n} else if (pdata->gpio_cfg[i] > 0x7fff) {\r\ndev_err(&i2c->dev, "Invalid gpio-cfg[%d] %x\n",\r\ni, pdata->gpio_cfg[i]);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic __devinit int wm8903_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm8903_platform_data *pdata = dev_get_platdata(&i2c->dev);\r\nstruct wm8903_priv *wm8903;\r\nunsigned int val;\r\nint ret;\r\nwm8903 = devm_kzalloc(&i2c->dev, sizeof(struct wm8903_priv),\r\nGFP_KERNEL);\r\nif (wm8903 == NULL)\r\nreturn -ENOMEM;\r\nwm8903->regmap = regmap_init_i2c(i2c, &wm8903_regmap);\r\nif (IS_ERR(wm8903->regmap)) {\r\nret = PTR_ERR(wm8903->regmap);\r\ndev_err(&i2c->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(i2c, wm8903);\r\nwm8903->irq = i2c->irq;\r\nif (pdata) {\r\nwm8903->pdata = pdata;\r\n} else {\r\nwm8903->pdata = devm_kzalloc(&i2c->dev,\r\nsizeof(struct wm8903_platform_data),\r\nGFP_KERNEL);\r\nif (wm8903->pdata == NULL) {\r\ndev_err(&i2c->dev, "Failed to allocate pdata\n");\r\nreturn -ENOMEM;\r\n}\r\nif (i2c->irq) {\r\nret = wm8903_set_pdata_irq_trigger(i2c, wm8903->pdata);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nif (i2c->dev.of_node) {\r\nret = wm8903_set_pdata_from_of(i2c, wm8903->pdata);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\n}\r\nret = regmap_read(wm8903->regmap, WM8903_SW_RESET_AND_ID, &val);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to read chip ID: %d\n", ret);\r\ngoto err;\r\n}\r\nif (val != 0x8903) {\r\ndev_err(&i2c->dev, "Device with ID %x is not a WM8903\n", val);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nret = regmap_read(wm8903->regmap, WM8903_REVISION_NUMBER, &val);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to read chip revision: %d\n", ret);\r\ngoto err;\r\n}\r\ndev_info(&i2c->dev, "WM8903 revision %c\n",\r\n(val & WM8903_CHIP_REV_MASK) + 'A');\r\nregmap_write(wm8903->regmap, WM8903_SW_RESET_AND_ID, 0x8903);\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm8903, &wm8903_dai, 1);\r\nif (ret != 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nregmap_exit(wm8903->regmap);\r\nreturn ret;\r\n}\r\nstatic __devexit int wm8903_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct wm8903_priv *wm8903 = i2c_get_clientdata(client);\r\nregmap_exit(wm8903->regmap);\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}\r\nstatic int __init wm8903_modinit(void)\r\n{\r\nint ret = 0;\r\nret = i2c_add_driver(&wm8903_i2c_driver);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "Failed to register wm8903 I2C driver: %d\n",\r\nret);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit wm8903_exit(void)\r\n{\r\ni2c_del_driver(&wm8903_i2c_driver);\r\n}
