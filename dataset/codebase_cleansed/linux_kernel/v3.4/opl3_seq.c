int snd_opl3_synth_use_inc(struct snd_opl3 * opl3)\r\n{\r\nif (!try_module_get(opl3->card->module))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nvoid snd_opl3_synth_use_dec(struct snd_opl3 * opl3)\r\n{\r\nmodule_put(opl3->card->module);\r\n}\r\nint snd_opl3_synth_setup(struct snd_opl3 * opl3)\r\n{\r\nint idx;\r\nstruct snd_hwdep *hwdep = opl3->hwdep;\r\nmutex_lock(&hwdep->open_mutex);\r\nif (hwdep->used) {\r\nmutex_unlock(&hwdep->open_mutex);\r\nreturn -EBUSY;\r\n}\r\nhwdep->used++;\r\nmutex_unlock(&hwdep->open_mutex);\r\nsnd_opl3_reset(opl3);\r\nfor (idx = 0; idx < MAX_OPL3_VOICES; idx++) {\r\nopl3->voices[idx].state = SNDRV_OPL3_ST_OFF;\r\nopl3->voices[idx].time = 0;\r\nopl3->voices[idx].keyon_reg = 0x00;\r\n}\r\nopl3->use_time = 0;\r\nopl3->connection_reg = 0x00;\r\nif (opl3->hardware >= OPL3_HW_OPL3) {\r\nopl3->command(opl3, OPL3_RIGHT | OPL3_REG_CONNECTION_SELECT,\r\nopl3->connection_reg);\r\nopl3->max_voices = MAX_OPL3_VOICES;\r\n}\r\nreturn 0;\r\n}\r\nvoid snd_opl3_synth_cleanup(struct snd_opl3 * opl3)\r\n{\r\nunsigned long flags;\r\nstruct snd_hwdep *hwdep;\r\nspin_lock_irqsave(&opl3->sys_timer_lock, flags);\r\nif (opl3->sys_timer_status) {\r\ndel_timer(&opl3->tlist);\r\nopl3->sys_timer_status = 0;\r\n}\r\nspin_unlock_irqrestore(&opl3->sys_timer_lock, flags);\r\nsnd_opl3_reset(opl3);\r\nhwdep = opl3->hwdep;\r\nmutex_lock(&hwdep->open_mutex);\r\nhwdep->used--;\r\nmutex_unlock(&hwdep->open_mutex);\r\nwake_up(&hwdep->open_wait);\r\n}\r\nstatic int snd_opl3_synth_use(void *private_data, struct snd_seq_port_subscribe * info)\r\n{\r\nstruct snd_opl3 *opl3 = private_data;\r\nint err;\r\nif ((err = snd_opl3_synth_setup(opl3)) < 0)\r\nreturn err;\r\nif (use_internal_drums) {\r\nopl3->voices[6].state = opl3->voices[7].state =\r\nopl3->voices[8].state = SNDRV_OPL3_ST_NOT_AVAIL;\r\nsnd_opl3_load_drums(opl3);\r\nopl3->drum_reg = OPL3_PERCUSSION_ENABLE;\r\nopl3->command(opl3, OPL3_LEFT | OPL3_REG_PERCUSSION, opl3->drum_reg);\r\n} else {\r\nopl3->drum_reg = 0x00;\r\n}\r\nif (info->sender.client != SNDRV_SEQ_CLIENT_SYSTEM) {\r\nif ((err = snd_opl3_synth_use_inc(opl3)) < 0)\r\nreturn err;\r\n}\r\nopl3->synth_mode = SNDRV_OPL3_MODE_SEQ;\r\nreturn 0;\r\n}\r\nstatic int snd_opl3_synth_unuse(void *private_data, struct snd_seq_port_subscribe * info)\r\n{\r\nstruct snd_opl3 *opl3 = private_data;\r\nsnd_opl3_synth_cleanup(opl3);\r\nif (info->sender.client != SNDRV_SEQ_CLIENT_SYSTEM)\r\nsnd_opl3_synth_use_dec(opl3);\r\nreturn 0;\r\n}\r\nstatic int snd_opl3_synth_event_input(struct snd_seq_event * ev, int direct,\r\nvoid *private_data, int atomic, int hop)\r\n{\r\nstruct snd_opl3 *opl3 = private_data;\r\nsnd_midi_process_event(&opl3_ops, ev, opl3->chset);\r\nreturn 0;\r\n}\r\nstatic void snd_opl3_synth_free_port(void *private_data)\r\n{\r\nstruct snd_opl3 *opl3 = private_data;\r\nsnd_midi_channel_free_set(opl3->chset);\r\n}\r\nstatic int snd_opl3_synth_create_port(struct snd_opl3 * opl3)\r\n{\r\nstruct snd_seq_port_callback callbacks;\r\nchar name[32];\r\nint voices, opl_ver;\r\nvoices = (opl3->hardware < OPL3_HW_OPL3) ?\r\nMAX_OPL2_VOICES : MAX_OPL3_VOICES;\r\nopl3->chset = snd_midi_channel_alloc_set(16);\r\nif (opl3->chset == NULL)\r\nreturn -ENOMEM;\r\nopl3->chset->private_data = opl3;\r\nmemset(&callbacks, 0, sizeof(callbacks));\r\ncallbacks.owner = THIS_MODULE;\r\ncallbacks.use = snd_opl3_synth_use;\r\ncallbacks.unuse = snd_opl3_synth_unuse;\r\ncallbacks.event_input = snd_opl3_synth_event_input;\r\ncallbacks.private_free = snd_opl3_synth_free_port;\r\ncallbacks.private_data = opl3;\r\nopl_ver = (opl3->hardware & OPL3_HW_MASK) >> 8;\r\nsprintf(name, "OPL%i FM Port", opl_ver);\r\nopl3->chset->client = opl3->seq_client;\r\nopl3->chset->port = snd_seq_event_port_attach(opl3->seq_client, &callbacks,\r\nSNDRV_SEQ_PORT_CAP_WRITE |\r\nSNDRV_SEQ_PORT_CAP_SUBS_WRITE,\r\nSNDRV_SEQ_PORT_TYPE_MIDI_GENERIC |\r\nSNDRV_SEQ_PORT_TYPE_MIDI_GM |\r\nSNDRV_SEQ_PORT_TYPE_DIRECT_SAMPLE |\r\nSNDRV_SEQ_PORT_TYPE_HARDWARE |\r\nSNDRV_SEQ_PORT_TYPE_SYNTHESIZER,\r\n16, voices,\r\nname);\r\nif (opl3->chset->port < 0) {\r\nint port;\r\nport = opl3->chset->port;\r\nsnd_midi_channel_free_set(opl3->chset);\r\nreturn port;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_opl3_seq_new_device(struct snd_seq_device *dev)\r\n{\r\nstruct snd_opl3 *opl3;\r\nint client, err;\r\nchar name[32];\r\nint opl_ver;\r\nopl3 = *(struct snd_opl3 **)SNDRV_SEQ_DEVICE_ARGPTR(dev);\r\nif (opl3 == NULL)\r\nreturn -EINVAL;\r\nspin_lock_init(&opl3->voice_lock);\r\nopl3->seq_client = -1;\r\nopl_ver = (opl3->hardware & OPL3_HW_MASK) >> 8;\r\nsprintf(name, "OPL%i FM synth", opl_ver);\r\nclient = opl3->seq_client =\r\nsnd_seq_create_kernel_client(opl3->card, opl3->seq_dev_num,\r\nname);\r\nif (client < 0)\r\nreturn client;\r\nif ((err = snd_opl3_synth_create_port(opl3)) < 0) {\r\nsnd_seq_delete_kernel_client(client);\r\nopl3->seq_client = -1;\r\nreturn err;\r\n}\r\ninit_timer(&opl3->tlist);\r\nopl3->tlist.function = snd_opl3_timer_func;\r\nopl3->tlist.data = (unsigned long) opl3;\r\nspin_lock_init(&opl3->sys_timer_lock);\r\nopl3->sys_timer_status = 0;\r\n#ifdef CONFIG_SND_SEQUENCER_OSS\r\nsnd_opl3_init_seq_oss(opl3, name);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int snd_opl3_seq_delete_device(struct snd_seq_device *dev)\r\n{\r\nstruct snd_opl3 *opl3;\r\nopl3 = *(struct snd_opl3 **)SNDRV_SEQ_DEVICE_ARGPTR(dev);\r\nif (opl3 == NULL)\r\nreturn -EINVAL;\r\n#ifdef CONFIG_SND_SEQUENCER_OSS\r\nsnd_opl3_free_seq_oss(opl3);\r\n#endif\r\nif (opl3->seq_client >= 0) {\r\nsnd_seq_delete_kernel_client(opl3->seq_client);\r\nopl3->seq_client = -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init alsa_opl3_seq_init(void)\r\n{\r\nstatic struct snd_seq_dev_ops ops =\r\n{\r\nsnd_opl3_seq_new_device,\r\nsnd_opl3_seq_delete_device\r\n};\r\nreturn snd_seq_device_register_driver(SNDRV_SEQ_DEV_ID_OPL3, &ops,\r\nsizeof(struct snd_opl3 *));\r\n}\r\nstatic void __exit alsa_opl3_seq_exit(void)\r\n{\r\nsnd_seq_device_unregister_driver(SNDRV_SEQ_DEV_ID_OPL3);\r\n}
