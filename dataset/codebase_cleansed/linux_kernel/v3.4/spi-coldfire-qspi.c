static void mcfqspi_wr_qmr(struct mcfqspi *mcfqspi, u16 val)\r\n{\r\nwritew(val, mcfqspi->iobase + MCFQSPI_QMR);\r\n}\r\nstatic void mcfqspi_wr_qdlyr(struct mcfqspi *mcfqspi, u16 val)\r\n{\r\nwritew(val, mcfqspi->iobase + MCFQSPI_QDLYR);\r\n}\r\nstatic u16 mcfqspi_rd_qdlyr(struct mcfqspi *mcfqspi)\r\n{\r\nreturn readw(mcfqspi->iobase + MCFQSPI_QDLYR);\r\n}\r\nstatic void mcfqspi_wr_qwr(struct mcfqspi *mcfqspi, u16 val)\r\n{\r\nwritew(val, mcfqspi->iobase + MCFQSPI_QWR);\r\n}\r\nstatic void mcfqspi_wr_qir(struct mcfqspi *mcfqspi, u16 val)\r\n{\r\nwritew(val, mcfqspi->iobase + MCFQSPI_QIR);\r\n}\r\nstatic void mcfqspi_wr_qar(struct mcfqspi *mcfqspi, u16 val)\r\n{\r\nwritew(val, mcfqspi->iobase + MCFQSPI_QAR);\r\n}\r\nstatic void mcfqspi_wr_qdr(struct mcfqspi *mcfqspi, u16 val)\r\n{\r\nwritew(val, mcfqspi->iobase + MCFQSPI_QDR);\r\n}\r\nstatic u16 mcfqspi_rd_qdr(struct mcfqspi *mcfqspi)\r\n{\r\nreturn readw(mcfqspi->iobase + MCFQSPI_QDR);\r\n}\r\nstatic void mcfqspi_cs_select(struct mcfqspi *mcfqspi, u8 chip_select,\r\nbool cs_high)\r\n{\r\nmcfqspi->cs_control->select(mcfqspi->cs_control, chip_select, cs_high);\r\n}\r\nstatic void mcfqspi_cs_deselect(struct mcfqspi *mcfqspi, u8 chip_select,\r\nbool cs_high)\r\n{\r\nmcfqspi->cs_control->deselect(mcfqspi->cs_control, chip_select, cs_high);\r\n}\r\nstatic int mcfqspi_cs_setup(struct mcfqspi *mcfqspi)\r\n{\r\nreturn (mcfqspi->cs_control && mcfqspi->cs_control->setup) ?\r\nmcfqspi->cs_control->setup(mcfqspi->cs_control) : 0;\r\n}\r\nstatic void mcfqspi_cs_teardown(struct mcfqspi *mcfqspi)\r\n{\r\nif (mcfqspi->cs_control && mcfqspi->cs_control->teardown)\r\nmcfqspi->cs_control->teardown(mcfqspi->cs_control);\r\n}\r\nstatic u8 mcfqspi_qmr_baud(u32 speed_hz)\r\n{\r\nreturn clamp((MCFQSPI_BUSCLK + speed_hz - 1) / speed_hz, 2u, 255u);\r\n}\r\nstatic bool mcfqspi_qdlyr_spe(struct mcfqspi *mcfqspi)\r\n{\r\nreturn mcfqspi_rd_qdlyr(mcfqspi) & MCFQSPI_QDLYR_SPE;\r\n}\r\nstatic irqreturn_t mcfqspi_irq_handler(int this_irq, void *dev_id)\r\n{\r\nstruct mcfqspi *mcfqspi = dev_id;\r\nmcfqspi_wr_qir(mcfqspi, MCFQSPI_QIR_SPIFE | MCFQSPI_QIR_SPIF);\r\nwake_up(&mcfqspi->waitq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mcfqspi_transfer_msg8(struct mcfqspi *mcfqspi, unsigned count,\r\nconst u8 *txbuf, u8 *rxbuf)\r\n{\r\nunsigned i, n, offset = 0;\r\nn = min(count, 16u);\r\nmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_CMDBUF);\r\nfor (i = 0; i < n; ++i)\r\nmcfqspi_wr_qdr(mcfqspi, MCFQSPI_QCR_BITSE);\r\nmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_TXBUF);\r\nif (txbuf)\r\nfor (i = 0; i < n; ++i)\r\nmcfqspi_wr_qdr(mcfqspi, *txbuf++);\r\nelse\r\nfor (i = 0; i < count; ++i)\r\nmcfqspi_wr_qdr(mcfqspi, 0);\r\ncount -= n;\r\nif (count) {\r\nu16 qwr = 0xf08;\r\nmcfqspi_wr_qwr(mcfqspi, 0x700);\r\nmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\r\ndo {\r\nwait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));\r\nmcfqspi_wr_qwr(mcfqspi, qwr);\r\nmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\r\nif (rxbuf) {\r\nmcfqspi_wr_qar(mcfqspi,\r\nMCFQSPI_QAR_RXBUF + offset);\r\nfor (i = 0; i < 8; ++i)\r\n*rxbuf++ = mcfqspi_rd_qdr(mcfqspi);\r\n}\r\nn = min(count, 8u);\r\nif (txbuf) {\r\nmcfqspi_wr_qar(mcfqspi,\r\nMCFQSPI_QAR_TXBUF + offset);\r\nfor (i = 0; i < n; ++i)\r\nmcfqspi_wr_qdr(mcfqspi, *txbuf++);\r\n}\r\nqwr = (offset ? 0x808 : 0) + ((n - 1) << 8);\r\noffset ^= 8;\r\ncount -= n;\r\n} while (count);\r\nwait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));\r\nmcfqspi_wr_qwr(mcfqspi, qwr);\r\nmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\r\nif (rxbuf) {\r\nmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_RXBUF + offset);\r\nfor (i = 0; i < 8; ++i)\r\n*rxbuf++ = mcfqspi_rd_qdr(mcfqspi);\r\noffset ^= 8;\r\n}\r\n} else {\r\nmcfqspi_wr_qwr(mcfqspi, (n - 1) << 8);\r\nmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\r\n}\r\nwait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));\r\nif (rxbuf) {\r\nmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_RXBUF + offset);\r\nfor (i = 0; i < n; ++i)\r\n*rxbuf++ = mcfqspi_rd_qdr(mcfqspi);\r\n}\r\n}\r\nstatic void mcfqspi_transfer_msg16(struct mcfqspi *mcfqspi, unsigned count,\r\nconst u16 *txbuf, u16 *rxbuf)\r\n{\r\nunsigned i, n, offset = 0;\r\nn = min(count, 16u);\r\nmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_CMDBUF);\r\nfor (i = 0; i < n; ++i)\r\nmcfqspi_wr_qdr(mcfqspi, MCFQSPI_QCR_BITSE);\r\nmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_TXBUF);\r\nif (txbuf)\r\nfor (i = 0; i < n; ++i)\r\nmcfqspi_wr_qdr(mcfqspi, *txbuf++);\r\nelse\r\nfor (i = 0; i < count; ++i)\r\nmcfqspi_wr_qdr(mcfqspi, 0);\r\ncount -= n;\r\nif (count) {\r\nu16 qwr = 0xf08;\r\nmcfqspi_wr_qwr(mcfqspi, 0x700);\r\nmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\r\ndo {\r\nwait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));\r\nmcfqspi_wr_qwr(mcfqspi, qwr);\r\nmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\r\nif (rxbuf) {\r\nmcfqspi_wr_qar(mcfqspi,\r\nMCFQSPI_QAR_RXBUF + offset);\r\nfor (i = 0; i < 8; ++i)\r\n*rxbuf++ = mcfqspi_rd_qdr(mcfqspi);\r\n}\r\nn = min(count, 8u);\r\nif (txbuf) {\r\nmcfqspi_wr_qar(mcfqspi,\r\nMCFQSPI_QAR_TXBUF + offset);\r\nfor (i = 0; i < n; ++i)\r\nmcfqspi_wr_qdr(mcfqspi, *txbuf++);\r\n}\r\nqwr = (offset ? 0x808 : 0x000) + ((n - 1) << 8);\r\noffset ^= 8;\r\ncount -= n;\r\n} while (count);\r\nwait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));\r\nmcfqspi_wr_qwr(mcfqspi, qwr);\r\nmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\r\nif (rxbuf) {\r\nmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_RXBUF + offset);\r\nfor (i = 0; i < 8; ++i)\r\n*rxbuf++ = mcfqspi_rd_qdr(mcfqspi);\r\noffset ^= 8;\r\n}\r\n} else {\r\nmcfqspi_wr_qwr(mcfqspi, (n - 1) << 8);\r\nmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\r\n}\r\nwait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));\r\nif (rxbuf) {\r\nmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_RXBUF + offset);\r\nfor (i = 0; i < n; ++i)\r\n*rxbuf++ = mcfqspi_rd_qdr(mcfqspi);\r\n}\r\n}\r\nstatic void mcfqspi_work(struct work_struct *work)\r\n{\r\nstruct mcfqspi *mcfqspi = container_of(work, struct mcfqspi, work);\r\nunsigned long flags;\r\nspin_lock_irqsave(&mcfqspi->lock, flags);\r\nwhile (!list_empty(&mcfqspi->msgq)) {\r\nstruct spi_message *msg;\r\nstruct spi_device *spi;\r\nstruct spi_transfer *xfer;\r\nint status = 0;\r\nmsg = container_of(mcfqspi->msgq.next, struct spi_message,\r\nqueue);\r\nlist_del_init(&msg->queue);\r\nspin_unlock_irqrestore(&mcfqspi->lock, flags);\r\nspi = msg->spi;\r\nlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\r\nbool cs_high = spi->mode & SPI_CS_HIGH;\r\nu16 qmr = MCFQSPI_QMR_MSTR;\r\nif (xfer->bits_per_word)\r\nqmr |= xfer->bits_per_word << 10;\r\nelse\r\nqmr |= spi->bits_per_word << 10;\r\nif (spi->mode & SPI_CPHA)\r\nqmr |= MCFQSPI_QMR_CPHA;\r\nif (spi->mode & SPI_CPOL)\r\nqmr |= MCFQSPI_QMR_CPOL;\r\nif (xfer->speed_hz)\r\nqmr |= mcfqspi_qmr_baud(xfer->speed_hz);\r\nelse\r\nqmr |= mcfqspi_qmr_baud(spi->max_speed_hz);\r\nmcfqspi_wr_qmr(mcfqspi, qmr);\r\nmcfqspi_cs_select(mcfqspi, spi->chip_select, cs_high);\r\nmcfqspi_wr_qir(mcfqspi, MCFQSPI_QIR_SPIFE);\r\nif ((xfer->bits_per_word ? xfer->bits_per_word :\r\nspi->bits_per_word) == 8)\r\nmcfqspi_transfer_msg8(mcfqspi, xfer->len,\r\nxfer->tx_buf,\r\nxfer->rx_buf);\r\nelse\r\nmcfqspi_transfer_msg16(mcfqspi, xfer->len / 2,\r\nxfer->tx_buf,\r\nxfer->rx_buf);\r\nmcfqspi_wr_qir(mcfqspi, 0);\r\nif (xfer->delay_usecs)\r\nudelay(xfer->delay_usecs);\r\nif (xfer->cs_change) {\r\nif (!list_is_last(&xfer->transfer_list,\r\n&msg->transfers))\r\nmcfqspi_cs_deselect(mcfqspi,\r\nspi->chip_select,\r\ncs_high);\r\n} else {\r\nif (list_is_last(&xfer->transfer_list,\r\n&msg->transfers))\r\nmcfqspi_cs_deselect(mcfqspi,\r\nspi->chip_select,\r\ncs_high);\r\n}\r\nmsg->actual_length += xfer->len;\r\n}\r\nmsg->status = status;\r\nmsg->complete(msg->context);\r\nspin_lock_irqsave(&mcfqspi->lock, flags);\r\n}\r\nspin_unlock_irqrestore(&mcfqspi->lock, flags);\r\n}\r\nstatic int mcfqspi_transfer(struct spi_device *spi, struct spi_message *msg)\r\n{\r\nstruct mcfqspi *mcfqspi;\r\nstruct spi_transfer *xfer;\r\nunsigned long flags;\r\nmcfqspi = spi_master_get_devdata(spi->master);\r\nlist_for_each_entry(xfer, &msg->transfers, transfer_list) {\r\nif (xfer->bits_per_word && ((xfer->bits_per_word < 8)\r\n|| (xfer->bits_per_word > 16))) {\r\ndev_dbg(&spi->dev,\r\n"%d bits per word is not supported\n",\r\nxfer->bits_per_word);\r\ngoto fail;\r\n}\r\nif (xfer->speed_hz) {\r\nu32 real_speed = MCFQSPI_BUSCLK /\r\nmcfqspi_qmr_baud(xfer->speed_hz);\r\nif (real_speed != xfer->speed_hz)\r\ndev_dbg(&spi->dev,\r\n"using speed %d instead of %d\n",\r\nreal_speed, xfer->speed_hz);\r\n}\r\n}\r\nmsg->status = -EINPROGRESS;\r\nmsg->actual_length = 0;\r\nspin_lock_irqsave(&mcfqspi->lock, flags);\r\nlist_add_tail(&msg->queue, &mcfqspi->msgq);\r\nqueue_work(mcfqspi->workq, &mcfqspi->work);\r\nspin_unlock_irqrestore(&mcfqspi->lock, flags);\r\nreturn 0;\r\nfail:\r\nmsg->status = -EINVAL;\r\nreturn -EINVAL;\r\n}\r\nstatic int mcfqspi_setup(struct spi_device *spi)\r\n{\r\nif ((spi->bits_per_word < 8) || (spi->bits_per_word > 16)) {\r\ndev_dbg(&spi->dev, "%d bits per word is not supported\n",\r\nspi->bits_per_word);\r\nreturn -EINVAL;\r\n}\r\nif (spi->chip_select >= spi->master->num_chipselect) {\r\ndev_dbg(&spi->dev, "%d chip select is out of range\n",\r\nspi->chip_select);\r\nreturn -EINVAL;\r\n}\r\nmcfqspi_cs_deselect(spi_master_get_devdata(spi->master),\r\nspi->chip_select, spi->mode & SPI_CS_HIGH);\r\ndev_dbg(&spi->dev,\r\n"bits per word %d, chip select %d, speed %d KHz\n",\r\nspi->bits_per_word, spi->chip_select,\r\n(MCFQSPI_BUSCLK / mcfqspi_qmr_baud(spi->max_speed_hz))\r\n/ 1000);\r\nreturn 0;\r\n}\r\nstatic int __devinit mcfqspi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct mcfqspi *mcfqspi;\r\nstruct resource *res;\r\nstruct mcfqspi_platform_data *pdata;\r\nint status;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*mcfqspi));\r\nif (master == NULL) {\r\ndev_dbg(&pdev->dev, "spi_alloc_master failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmcfqspi = spi_master_get_devdata(master);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_dbg(&pdev->dev, "platform_get_resource failed\n");\r\nstatus = -ENXIO;\r\ngoto fail0;\r\n}\r\nif (!request_mem_region(res->start, resource_size(res), pdev->name)) {\r\ndev_dbg(&pdev->dev, "request_mem_region failed\n");\r\nstatus = -EBUSY;\r\ngoto fail0;\r\n}\r\nmcfqspi->iobase = ioremap(res->start, resource_size(res));\r\nif (!mcfqspi->iobase) {\r\ndev_dbg(&pdev->dev, "ioremap failed\n");\r\nstatus = -ENOMEM;\r\ngoto fail1;\r\n}\r\nmcfqspi->irq = platform_get_irq(pdev, 0);\r\nif (mcfqspi->irq < 0) {\r\ndev_dbg(&pdev->dev, "platform_get_irq failed\n");\r\nstatus = -ENXIO;\r\ngoto fail2;\r\n}\r\nstatus = request_irq(mcfqspi->irq, mcfqspi_irq_handler, 0,\r\npdev->name, mcfqspi);\r\nif (status) {\r\ndev_dbg(&pdev->dev, "request_irq failed\n");\r\ngoto fail2;\r\n}\r\nmcfqspi->clk = clk_get(&pdev->dev, "qspi_clk");\r\nif (IS_ERR(mcfqspi->clk)) {\r\ndev_dbg(&pdev->dev, "clk_get failed\n");\r\nstatus = PTR_ERR(mcfqspi->clk);\r\ngoto fail3;\r\n}\r\nclk_enable(mcfqspi->clk);\r\nmcfqspi->workq = create_singlethread_workqueue(dev_name(master->dev.parent));\r\nif (!mcfqspi->workq) {\r\ndev_dbg(&pdev->dev, "create_workqueue failed\n");\r\nstatus = -ENOMEM;\r\ngoto fail4;\r\n}\r\nINIT_WORK(&mcfqspi->work, mcfqspi_work);\r\nspin_lock_init(&mcfqspi->lock);\r\nINIT_LIST_HEAD(&mcfqspi->msgq);\r\ninit_waitqueue_head(&mcfqspi->waitq);\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_dbg(&pdev->dev, "platform data is missing\n");\r\ngoto fail5;\r\n}\r\nmaster->bus_num = pdata->bus_num;\r\nmaster->num_chipselect = pdata->num_chipselect;\r\nmcfqspi->cs_control = pdata->cs_control;\r\nstatus = mcfqspi_cs_setup(mcfqspi);\r\nif (status) {\r\ndev_dbg(&pdev->dev, "error initializing cs_control\n");\r\ngoto fail5;\r\n}\r\nmaster->mode_bits = SPI_CS_HIGH | SPI_CPOL | SPI_CPHA;\r\nmaster->setup = mcfqspi_setup;\r\nmaster->transfer = mcfqspi_transfer;\r\nplatform_set_drvdata(pdev, master);\r\nstatus = spi_register_master(master);\r\nif (status) {\r\ndev_dbg(&pdev->dev, "spi_register_master failed\n");\r\ngoto fail6;\r\n}\r\ndev_info(&pdev->dev, "Coldfire QSPI bus driver\n");\r\nreturn 0;\r\nfail6:\r\nmcfqspi_cs_teardown(mcfqspi);\r\nfail5:\r\ndestroy_workqueue(mcfqspi->workq);\r\nfail4:\r\nclk_disable(mcfqspi->clk);\r\nclk_put(mcfqspi->clk);\r\nfail3:\r\nfree_irq(mcfqspi->irq, mcfqspi);\r\nfail2:\r\niounmap(mcfqspi->iobase);\r\nfail1:\r\nrelease_mem_region(res->start, resource_size(res));\r\nfail0:\r\nspi_master_put(master);\r\ndev_dbg(&pdev->dev, "Coldfire QSPI probe failed\n");\r\nreturn status;\r\n}\r\nstatic int __devexit mcfqspi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct mcfqspi *mcfqspi = spi_master_get_devdata(master);\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmcfqspi_wr_qmr(mcfqspi, MCFQSPI_QMR_MSTR);\r\nplatform_set_drvdata(pdev, NULL);\r\nmcfqspi_cs_teardown(mcfqspi);\r\ndestroy_workqueue(mcfqspi->workq);\r\nclk_disable(mcfqspi->clk);\r\nclk_put(mcfqspi->clk);\r\nfree_irq(mcfqspi->irq, mcfqspi);\r\niounmap(mcfqspi->iobase);\r\nrelease_mem_region(res->start, resource_size(res));\r\nspi_unregister_master(master);\r\nspi_master_put(master);\r\nreturn 0;\r\n}\r\nstatic int mcfqspi_suspend(struct device *dev)\r\n{\r\nstruct mcfqspi *mcfqspi = platform_get_drvdata(to_platform_device(dev));\r\nclk_disable(mcfqspi->clk);\r\nreturn 0;\r\n}\r\nstatic int mcfqspi_resume(struct device *dev)\r\n{\r\nstruct mcfqspi *mcfqspi = platform_get_drvdata(to_platform_device(dev));\r\nclk_enable(mcfqspi->clk);\r\nreturn 0;\r\n}
