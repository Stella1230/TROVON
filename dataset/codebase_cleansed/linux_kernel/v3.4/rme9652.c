static int snd_hammerfall_get_buffer(struct pci_dev *pci, struct snd_dma_buffer *dmab, size_t size)\r\n{\r\ndmab->dev.type = SNDRV_DMA_TYPE_DEV;\r\ndmab->dev.dev = snd_dma_pci_data(pci);\r\nif (snd_dma_get_reserved_buf(dmab, snd_dma_pci_buf_id(pci))) {\r\nif (dmab->bytes >= size)\r\nreturn 0;\r\n}\r\nif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),\r\nsize, dmab) < 0)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void snd_hammerfall_free_buffer(struct snd_dma_buffer *dmab, struct pci_dev *pci)\r\n{\r\nif (dmab->area) {\r\ndmab->dev.dev = NULL;\r\nsnd_dma_reserve_buf(dmab, snd_dma_pci_buf_id(pci));\r\n}\r\n}\r\nstatic inline void rme9652_write(struct snd_rme9652 *rme9652, int reg, int val)\r\n{\r\nwritel(val, rme9652->iobase + reg);\r\n}\r\nstatic inline unsigned int rme9652_read(struct snd_rme9652 *rme9652, int reg)\r\n{\r\nreturn readl(rme9652->iobase + reg);\r\n}\r\nstatic inline int snd_rme9652_use_is_exclusive(struct snd_rme9652 *rme9652)\r\n{\r\nunsigned long flags;\r\nint ret = 1;\r\nspin_lock_irqsave(&rme9652->lock, flags);\r\nif ((rme9652->playback_pid != rme9652->capture_pid) &&\r\n(rme9652->playback_pid >= 0) && (rme9652->capture_pid >= 0)) {\r\nret = 0;\r\n}\r\nspin_unlock_irqrestore(&rme9652->lock, flags);\r\nreturn ret;\r\n}\r\nstatic inline int rme9652_adat_sample_rate(struct snd_rme9652 *rme9652)\r\n{\r\nif (rme9652_running_double_speed(rme9652)) {\r\nreturn (rme9652_read(rme9652, RME9652_status_register) &\r\nRME9652_fs48) ? 96000 : 88200;\r\n} else {\r\nreturn (rme9652_read(rme9652, RME9652_status_register) &\r\nRME9652_fs48) ? 48000 : 44100;\r\n}\r\n}\r\nstatic inline void rme9652_compute_period_size(struct snd_rme9652 *rme9652)\r\n{\r\nunsigned int i;\r\ni = rme9652->control_register & RME9652_latency;\r\nrme9652->period_bytes = 1 << ((rme9652_decode_latency(i) + 8));\r\nrme9652->hw_offsetmask =\r\n(rme9652->period_bytes * 2 - 1) & RME9652_buf_pos;\r\nrme9652->max_jitter = 80;\r\n}\r\nstatic snd_pcm_uframes_t rme9652_hw_pointer(struct snd_rme9652 *rme9652)\r\n{\r\nint status;\r\nunsigned int offset, frag;\r\nsnd_pcm_uframes_t period_size = rme9652->period_bytes / 4;\r\nsnd_pcm_sframes_t delta;\r\nstatus = rme9652_read(rme9652, RME9652_status_register);\r\nif (!rme9652->precise_ptr)\r\nreturn (status & RME9652_buffer_id) ? period_size : 0;\r\noffset = status & RME9652_buf_pos;\r\ndelta = rme9652->prev_hw_offset - offset;\r\ndelta &= 0xffff;\r\nif (delta <= (snd_pcm_sframes_t)rme9652->max_jitter * 4)\r\noffset = rme9652->prev_hw_offset;\r\nelse\r\nrme9652->prev_hw_offset = offset;\r\noffset &= rme9652->hw_offsetmask;\r\noffset /= 4;\r\nfrag = status & RME9652_buffer_id;\r\nif (offset < period_size) {\r\nif (offset > rme9652->max_jitter) {\r\nif (frag)\r\nprintk(KERN_ERR "Unexpected hw_pointer position (bufid == 0): status: %x offset: %d\n", status, offset);\r\n} else if (!frag)\r\nreturn 0;\r\noffset -= rme9652->max_jitter;\r\nif ((int)offset < 0)\r\noffset += period_size * 2;\r\n} else {\r\nif (offset > period_size + rme9652->max_jitter) {\r\nif (!frag)\r\nprintk(KERN_ERR "Unexpected hw_pointer position (bufid == 1): status: %x offset: %d\n", status, offset);\r\n} else if (frag)\r\nreturn period_size;\r\noffset -= rme9652->max_jitter;\r\n}\r\nreturn offset;\r\n}\r\nstatic inline void rme9652_reset_hw_pointer(struct snd_rme9652 *rme9652)\r\n{\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nrme9652_write(rme9652, i * 4, 0);\r\nudelay(10);\r\n}\r\nrme9652->prev_hw_offset = 0;\r\n}\r\nstatic inline void rme9652_start(struct snd_rme9652 *s)\r\n{\r\ns->control_register |= (RME9652_IE | RME9652_start_bit);\r\nrme9652_write(s, RME9652_control_register, s->control_register);\r\n}\r\nstatic inline void rme9652_stop(struct snd_rme9652 *s)\r\n{\r\ns->control_register &= ~(RME9652_start_bit | RME9652_IE);\r\nrme9652_write(s, RME9652_control_register, s->control_register);\r\n}\r\nstatic int rme9652_set_interrupt_interval(struct snd_rme9652 *s,\r\nunsigned int frames)\r\n{\r\nint restart = 0;\r\nint n;\r\nspin_lock_irq(&s->lock);\r\nif ((restart = s->running)) {\r\nrme9652_stop(s);\r\n}\r\nframes >>= 7;\r\nn = 0;\r\nwhile (frames) {\r\nn++;\r\nframes >>= 1;\r\n}\r\ns->control_register &= ~RME9652_latency;\r\ns->control_register |= rme9652_encode_latency(n);\r\nrme9652_write(s, RME9652_control_register, s->control_register);\r\nrme9652_compute_period_size(s);\r\nif (restart)\r\nrme9652_start(s);\r\nspin_unlock_irq(&s->lock);\r\nreturn 0;\r\n}\r\nstatic int rme9652_set_rate(struct snd_rme9652 *rme9652, int rate)\r\n{\r\nint restart;\r\nint reject_if_open = 0;\r\nint xrate;\r\nif (!snd_rme9652_use_is_exclusive (rme9652)) {\r\nreturn -EBUSY;\r\n}\r\nspin_lock_irq(&rme9652->lock);\r\nxrate = rme9652_adat_sample_rate(rme9652);\r\nswitch (rate) {\r\ncase 44100:\r\nif (xrate > 48000) {\r\nreject_if_open = 1;\r\n}\r\nrate = 0;\r\nbreak;\r\ncase 48000:\r\nif (xrate > 48000) {\r\nreject_if_open = 1;\r\n}\r\nrate = RME9652_freq;\r\nbreak;\r\ncase 88200:\r\nif (xrate < 48000) {\r\nreject_if_open = 1;\r\n}\r\nrate = RME9652_DS;\r\nbreak;\r\ncase 96000:\r\nif (xrate < 48000) {\r\nreject_if_open = 1;\r\n}\r\nrate = RME9652_DS | RME9652_freq;\r\nbreak;\r\ndefault:\r\nspin_unlock_irq(&rme9652->lock);\r\nreturn -EINVAL;\r\n}\r\nif (reject_if_open && (rme9652->capture_pid >= 0 || rme9652->playback_pid >= 0)) {\r\nspin_unlock_irq(&rme9652->lock);\r\nreturn -EBUSY;\r\n}\r\nif ((restart = rme9652->running)) {\r\nrme9652_stop(rme9652);\r\n}\r\nrme9652->control_register &= ~(RME9652_freq | RME9652_DS);\r\nrme9652->control_register |= rate;\r\nrme9652_write(rme9652, RME9652_control_register, rme9652->control_register);\r\nif (restart) {\r\nrme9652_start(rme9652);\r\n}\r\nif (rate & RME9652_DS) {\r\nif (rme9652->ss_channels == RME9652_NCHANNELS) {\r\nrme9652->channel_map = channel_map_9652_ds;\r\n} else {\r\nrme9652->channel_map = channel_map_9636_ds;\r\n}\r\n} else {\r\nif (rme9652->ss_channels == RME9652_NCHANNELS) {\r\nrme9652->channel_map = channel_map_9652_ss;\r\n} else {\r\nrme9652->channel_map = channel_map_9636_ss;\r\n}\r\n}\r\nspin_unlock_irq(&rme9652->lock);\r\nreturn 0;\r\n}\r\nstatic void rme9652_set_thru(struct snd_rme9652 *rme9652, int channel, int enable)\r\n{\r\nint i;\r\nrme9652->passthru = 0;\r\nif (channel < 0) {\r\nif (enable) {\r\nfor (i = 0; i < RME9652_NCHANNELS; i++) {\r\nrme9652->thru_bits |= (1 << i);\r\nrme9652_write(rme9652, RME9652_thru_base + i * 4, 1);\r\n}\r\n} else {\r\nfor (i = 0; i < RME9652_NCHANNELS; i++) {\r\nrme9652->thru_bits &= ~(1 << i);\r\nrme9652_write(rme9652, RME9652_thru_base + i * 4, 0);\r\n}\r\n}\r\n} else {\r\nint mapped_channel;\r\nmapped_channel = rme9652->channel_map[channel];\r\nif (enable) {\r\nrme9652->thru_bits |= (1 << mapped_channel);\r\n} else {\r\nrme9652->thru_bits &= ~(1 << mapped_channel);\r\n}\r\nrme9652_write(rme9652,\r\nRME9652_thru_base + mapped_channel * 4,\r\nenable ? 1 : 0);\r\n}\r\n}\r\nstatic int rme9652_set_passthru(struct snd_rme9652 *rme9652, int onoff)\r\n{\r\nif (onoff) {\r\nrme9652_set_thru(rme9652, -1, 1);\r\nrme9652->control_register =\r\nRME9652_inp_0 |\r\nrme9652_encode_latency(7) |\r\nRME9652_start_bit;\r\nrme9652_reset_hw_pointer(rme9652);\r\nrme9652_write(rme9652, RME9652_control_register,\r\nrme9652->control_register);\r\nrme9652->passthru = 1;\r\n} else {\r\nrme9652_set_thru(rme9652, -1, 0);\r\nrme9652_stop(rme9652);\r\nrme9652->passthru = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rme9652_spdif_set_bit (struct snd_rme9652 *rme9652, int mask, int onoff)\r\n{\r\nif (onoff)\r\nrme9652->control_register |= mask;\r\nelse\r\nrme9652->control_register &= ~mask;\r\nrme9652_write(rme9652, RME9652_control_register, rme9652->control_register);\r\n}\r\nstatic void rme9652_spdif_write_byte (struct snd_rme9652 *rme9652, const int val)\r\n{\r\nlong mask;\r\nlong i;\r\nfor (i = 0, mask = 0x80; i < 8; i++, mask >>= 1) {\r\nif (val & mask)\r\nrme9652_spdif_set_bit (rme9652, RME9652_SPDIF_WRITE, 1);\r\nelse\r\nrme9652_spdif_set_bit (rme9652, RME9652_SPDIF_WRITE, 0);\r\nrme9652_spdif_set_bit (rme9652, RME9652_SPDIF_CLOCK, 1);\r\nrme9652_spdif_set_bit (rme9652, RME9652_SPDIF_CLOCK, 0);\r\n}\r\n}\r\nstatic int rme9652_spdif_read_byte (struct snd_rme9652 *rme9652)\r\n{\r\nlong mask;\r\nlong val;\r\nlong i;\r\nval = 0;\r\nfor (i = 0, mask = 0x80; i < 8; i++, mask >>= 1) {\r\nrme9652_spdif_set_bit (rme9652, RME9652_SPDIF_CLOCK, 1);\r\nif (rme9652_read (rme9652, RME9652_status_register) & RME9652_SPDIF_READ)\r\nval |= mask;\r\nrme9652_spdif_set_bit (rme9652, RME9652_SPDIF_CLOCK, 0);\r\n}\r\nreturn val;\r\n}\r\nstatic void rme9652_write_spdif_codec (struct snd_rme9652 *rme9652, const int address, const int data)\r\n{\r\nrme9652_spdif_set_bit (rme9652, RME9652_SPDIF_SELECT, 1);\r\nrme9652_spdif_write_byte (rme9652, 0x20);\r\nrme9652_spdif_write_byte (rme9652, address);\r\nrme9652_spdif_write_byte (rme9652, data);\r\nrme9652_spdif_set_bit (rme9652, RME9652_SPDIF_SELECT, 0);\r\n}\r\nstatic int rme9652_spdif_read_codec (struct snd_rme9652 *rme9652, const int address)\r\n{\r\nint ret;\r\nrme9652_spdif_set_bit (rme9652, RME9652_SPDIF_SELECT, 1);\r\nrme9652_spdif_write_byte (rme9652, 0x20);\r\nrme9652_spdif_write_byte (rme9652, address);\r\nrme9652_spdif_set_bit (rme9652, RME9652_SPDIF_SELECT, 0);\r\nrme9652_spdif_set_bit (rme9652, RME9652_SPDIF_SELECT, 1);\r\nrme9652_spdif_write_byte (rme9652, 0x21);\r\nret = rme9652_spdif_read_byte (rme9652);\r\nrme9652_spdif_set_bit (rme9652, RME9652_SPDIF_SELECT, 0);\r\nreturn ret;\r\n}\r\nstatic void rme9652_initialize_spdif_receiver (struct snd_rme9652 *rme9652)\r\n{\r\nrme9652->control_register |= RME9652_SPDIF_RESET;\r\nrme9652_write_spdif_codec (rme9652, 4, 0x40);\r\nrme9652_write_spdif_codec (rme9652, 17, 0x13);\r\nrme9652_write_spdif_codec (rme9652, 6, 0x02);\r\n}\r\nstatic inline int rme9652_spdif_sample_rate(struct snd_rme9652 *s)\r\n{\r\nunsigned int rate_bits;\r\nif (rme9652_read(s, RME9652_status_register) & RME9652_ERF) {\r\nreturn -1;\r\n}\r\nif (s->hw_rev == 15) {\r\nint x, y, ret;\r\nx = rme9652_spdif_read_codec (s, 30);\r\nif (x != 0)\r\ny = 48000 * 64 / x;\r\nelse\r\ny = 0;\r\nif (y > 30400 && y < 33600) ret = 32000;\r\nelse if (y > 41900 && y < 46000) ret = 44100;\r\nelse if (y > 46000 && y < 50400) ret = 48000;\r\nelse if (y > 60800 && y < 67200) ret = 64000;\r\nelse if (y > 83700 && y < 92000) ret = 88200;\r\nelse if (y > 92000 && y < 100000) ret = 96000;\r\nelse ret = 0;\r\nreturn ret;\r\n}\r\nrate_bits = rme9652_read(s, RME9652_status_register) & RME9652_F;\r\nswitch (rme9652_decode_spdif_rate(rate_bits)) {\r\ncase 0x7:\r\nreturn 32000;\r\nbreak;\r\ncase 0x6:\r\nreturn 44100;\r\nbreak;\r\ncase 0x5:\r\nreturn 48000;\r\nbreak;\r\ncase 0x4:\r\nreturn 88200;\r\nbreak;\r\ncase 0x3:\r\nreturn 96000;\r\nbreak;\r\ncase 0x0:\r\nreturn 64000;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR "%s: unknown S/PDIF input rate (bits = 0x%x)\n",\r\ns->card_name, rate_bits);\r\nreturn 0;\r\nbreak;\r\n}\r\n}\r\nstatic u32 snd_rme9652_convert_from_aes(struct snd_aes_iec958 *aes)\r\n{\r\nu32 val = 0;\r\nval |= (aes->status[0] & IEC958_AES0_PROFESSIONAL) ? RME9652_PRO : 0;\r\nval |= (aes->status[0] & IEC958_AES0_NONAUDIO) ? RME9652_Dolby : 0;\r\nif (val & RME9652_PRO)\r\nval |= (aes->status[0] & IEC958_AES0_PRO_EMPHASIS_5015) ? RME9652_EMP : 0;\r\nelse\r\nval |= (aes->status[0] & IEC958_AES0_CON_EMPHASIS_5015) ? RME9652_EMP : 0;\r\nreturn val;\r\n}\r\nstatic void snd_rme9652_convert_to_aes(struct snd_aes_iec958 *aes, u32 val)\r\n{\r\naes->status[0] = ((val & RME9652_PRO) ? IEC958_AES0_PROFESSIONAL : 0) |\r\n((val & RME9652_Dolby) ? IEC958_AES0_NONAUDIO : 0);\r\nif (val & RME9652_PRO)\r\naes->status[0] |= (val & RME9652_EMP) ? IEC958_AES0_PRO_EMPHASIS_5015 : 0;\r\nelse\r\naes->status[0] |= (val & RME9652_EMP) ? IEC958_AES0_CON_EMPHASIS_5015 : 0;\r\n}\r\nstatic int snd_rme9652_control_spdif_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_control_spdif_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nsnd_rme9652_convert_to_aes(&ucontrol->value.iec958, rme9652->creg_spdif);\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_control_spdif_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nu32 val;\r\nval = snd_rme9652_convert_from_aes(&ucontrol->value.iec958);\r\nspin_lock_irq(&rme9652->lock);\r\nchange = val != rme9652->creg_spdif;\r\nrme9652->creg_spdif = val;\r\nspin_unlock_irq(&rme9652->lock);\r\nreturn change;\r\n}\r\nstatic int snd_rme9652_control_spdif_stream_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_control_spdif_stream_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nsnd_rme9652_convert_to_aes(&ucontrol->value.iec958, rme9652->creg_spdif_stream);\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_control_spdif_stream_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nu32 val;\r\nval = snd_rme9652_convert_from_aes(&ucontrol->value.iec958);\r\nspin_lock_irq(&rme9652->lock);\r\nchange = val != rme9652->creg_spdif_stream;\r\nrme9652->creg_spdif_stream = val;\r\nrme9652->control_register &= ~(RME9652_PRO | RME9652_Dolby | RME9652_EMP);\r\nrme9652_write(rme9652, RME9652_control_register, rme9652->control_register |= val);\r\nspin_unlock_irq(&rme9652->lock);\r\nreturn change;\r\n}\r\nstatic int snd_rme9652_control_spdif_mask_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_control_spdif_mask_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = kcontrol->private_value;\r\nreturn 0;\r\n}\r\nstatic unsigned int rme9652_adat1_in(struct snd_rme9652 *rme9652)\r\n{\r\nif (rme9652->control_register & RME9652_ADAT1_INTERNAL)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int rme9652_set_adat1_input(struct snd_rme9652 *rme9652, int internal)\r\n{\r\nint restart = 0;\r\nif (internal) {\r\nrme9652->control_register |= RME9652_ADAT1_INTERNAL;\r\n} else {\r\nrme9652->control_register &= ~RME9652_ADAT1_INTERNAL;\r\n}\r\nif ((restart = rme9652->running)) {\r\nrme9652_stop(rme9652);\r\n}\r\nrme9652_write(rme9652, RME9652_control_register, rme9652->control_register);\r\nif (restart) {\r\nrme9652_start(rme9652);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_info_adat1_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[2] = {"ADAT1", "Internal"};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 2;\r\nif (uinfo->value.enumerated.item > 1)\r\nuinfo->value.enumerated.item = 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_get_adat1_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&rme9652->lock);\r\nucontrol->value.enumerated.item[0] = rme9652_adat1_in(rme9652);\r\nspin_unlock_irq(&rme9652->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_put_adat1_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nunsigned int val;\r\nif (!snd_rme9652_use_is_exclusive(rme9652))\r\nreturn -EBUSY;\r\nval = ucontrol->value.enumerated.item[0] % 2;\r\nspin_lock_irq(&rme9652->lock);\r\nchange = val != rme9652_adat1_in(rme9652);\r\nif (change)\r\nrme9652_set_adat1_input(rme9652, val);\r\nspin_unlock_irq(&rme9652->lock);\r\nreturn change;\r\n}\r\nstatic unsigned int rme9652_spdif_in(struct snd_rme9652 *rme9652)\r\n{\r\nreturn rme9652_decode_spdif_in(rme9652->control_register &\r\nRME9652_inp);\r\n}\r\nstatic int rme9652_set_spdif_input(struct snd_rme9652 *rme9652, int in)\r\n{\r\nint restart = 0;\r\nrme9652->control_register &= ~RME9652_inp;\r\nrme9652->control_register |= rme9652_encode_spdif_in(in);\r\nif ((restart = rme9652->running)) {\r\nrme9652_stop(rme9652);\r\n}\r\nrme9652_write(rme9652, RME9652_control_register, rme9652->control_register);\r\nif (restart) {\r\nrme9652_start(rme9652);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_info_spdif_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[3] = {"ADAT1", "Coaxial", "Internal"};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 3;\r\nif (uinfo->value.enumerated.item > 2)\r\nuinfo->value.enumerated.item = 2;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_get_spdif_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&rme9652->lock);\r\nucontrol->value.enumerated.item[0] = rme9652_spdif_in(rme9652);\r\nspin_unlock_irq(&rme9652->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_put_spdif_in(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nunsigned int val;\r\nif (!snd_rme9652_use_is_exclusive(rme9652))\r\nreturn -EBUSY;\r\nval = ucontrol->value.enumerated.item[0] % 3;\r\nspin_lock_irq(&rme9652->lock);\r\nchange = val != rme9652_spdif_in(rme9652);\r\nif (change)\r\nrme9652_set_spdif_input(rme9652, val);\r\nspin_unlock_irq(&rme9652->lock);\r\nreturn change;\r\n}\r\nstatic int rme9652_spdif_out(struct snd_rme9652 *rme9652)\r\n{\r\nreturn (rme9652->control_register & RME9652_opt_out) ? 1 : 0;\r\n}\r\nstatic int rme9652_set_spdif_output(struct snd_rme9652 *rme9652, int out)\r\n{\r\nint restart = 0;\r\nif (out) {\r\nrme9652->control_register |= RME9652_opt_out;\r\n} else {\r\nrme9652->control_register &= ~RME9652_opt_out;\r\n}\r\nif ((restart = rme9652->running)) {\r\nrme9652_stop(rme9652);\r\n}\r\nrme9652_write(rme9652, RME9652_control_register, rme9652->control_register);\r\nif (restart) {\r\nrme9652_start(rme9652);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_get_spdif_out(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&rme9652->lock);\r\nucontrol->value.integer.value[0] = rme9652_spdif_out(rme9652);\r\nspin_unlock_irq(&rme9652->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_put_spdif_out(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nunsigned int val;\r\nif (!snd_rme9652_use_is_exclusive(rme9652))\r\nreturn -EBUSY;\r\nval = ucontrol->value.integer.value[0] & 1;\r\nspin_lock_irq(&rme9652->lock);\r\nchange = (int)val != rme9652_spdif_out(rme9652);\r\nrme9652_set_spdif_output(rme9652, val);\r\nspin_unlock_irq(&rme9652->lock);\r\nreturn change;\r\n}\r\nstatic int rme9652_sync_mode(struct snd_rme9652 *rme9652)\r\n{\r\nif (rme9652->control_register & RME9652_wsel) {\r\nreturn 2;\r\n} else if (rme9652->control_register & RME9652_Master) {\r\nreturn 1;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic int rme9652_set_sync_mode(struct snd_rme9652 *rme9652, int mode)\r\n{\r\nint restart = 0;\r\nswitch (mode) {\r\ncase 0:\r\nrme9652->control_register &=\r\n~(RME9652_Master | RME9652_wsel);\r\nbreak;\r\ncase 1:\r\nrme9652->control_register =\r\n(rme9652->control_register & ~RME9652_wsel) | RME9652_Master;\r\nbreak;\r\ncase 2:\r\nrme9652->control_register |=\r\n(RME9652_Master | RME9652_wsel);\r\nbreak;\r\n}\r\nif ((restart = rme9652->running)) {\r\nrme9652_stop(rme9652);\r\n}\r\nrme9652_write(rme9652, RME9652_control_register, rme9652->control_register);\r\nif (restart) {\r\nrme9652_start(rme9652);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_info_sync_mode(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[3] = {"AutoSync", "Master", "Word Clock"};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 3;\r\nif (uinfo->value.enumerated.item > 2)\r\nuinfo->value.enumerated.item = 2;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_get_sync_mode(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&rme9652->lock);\r\nucontrol->value.enumerated.item[0] = rme9652_sync_mode(rme9652);\r\nspin_unlock_irq(&rme9652->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_put_sync_mode(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nunsigned int val;\r\nval = ucontrol->value.enumerated.item[0] % 3;\r\nspin_lock_irq(&rme9652->lock);\r\nchange = (int)val != rme9652_sync_mode(rme9652);\r\nrme9652_set_sync_mode(rme9652, val);\r\nspin_unlock_irq(&rme9652->lock);\r\nreturn change;\r\n}\r\nstatic int rme9652_sync_pref(struct snd_rme9652 *rme9652)\r\n{\r\nswitch (rme9652->control_register & RME9652_SyncPref_Mask) {\r\ncase RME9652_SyncPref_ADAT1:\r\nreturn RME9652_SYNC_FROM_ADAT1;\r\ncase RME9652_SyncPref_ADAT2:\r\nreturn RME9652_SYNC_FROM_ADAT2;\r\ncase RME9652_SyncPref_ADAT3:\r\nreturn RME9652_SYNC_FROM_ADAT3;\r\ncase RME9652_SyncPref_SPDIF:\r\nreturn RME9652_SYNC_FROM_SPDIF;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rme9652_set_sync_pref(struct snd_rme9652 *rme9652, int pref)\r\n{\r\nint restart;\r\nrme9652->control_register &= ~RME9652_SyncPref_Mask;\r\nswitch (pref) {\r\ncase RME9652_SYNC_FROM_ADAT1:\r\nrme9652->control_register |= RME9652_SyncPref_ADAT1;\r\nbreak;\r\ncase RME9652_SYNC_FROM_ADAT2:\r\nrme9652->control_register |= RME9652_SyncPref_ADAT2;\r\nbreak;\r\ncase RME9652_SYNC_FROM_ADAT3:\r\nrme9652->control_register |= RME9652_SyncPref_ADAT3;\r\nbreak;\r\ncase RME9652_SYNC_FROM_SPDIF:\r\nrme9652->control_register |= RME9652_SyncPref_SPDIF;\r\nbreak;\r\n}\r\nif ((restart = rme9652->running)) {\r\nrme9652_stop(rme9652);\r\n}\r\nrme9652_write(rme9652, RME9652_control_register, rme9652->control_register);\r\nif (restart) {\r\nrme9652_start(rme9652);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_info_sync_pref(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[4] = {"IEC958 In", "ADAT1 In", "ADAT2 In", "ADAT3 In"};\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = rme9652->ss_channels == RME9652_NCHANNELS ? 4 : 3;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_get_sync_pref(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&rme9652->lock);\r\nucontrol->value.enumerated.item[0] = rme9652_sync_pref(rme9652);\r\nspin_unlock_irq(&rme9652->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_put_sync_pref(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nint change, max;\r\nunsigned int val;\r\nif (!snd_rme9652_use_is_exclusive(rme9652))\r\nreturn -EBUSY;\r\nmax = rme9652->ss_channels == RME9652_NCHANNELS ? 4 : 3;\r\nval = ucontrol->value.enumerated.item[0] % max;\r\nspin_lock_irq(&rme9652->lock);\r\nchange = (int)val != rme9652_sync_pref(rme9652);\r\nrme9652_set_sync_pref(rme9652, val);\r\nspin_unlock_irq(&rme9652->lock);\r\nreturn change;\r\n}\r\nstatic int snd_rme9652_info_thru(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = rme9652->ss_channels;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_get_thru(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nunsigned int k;\r\nu32 thru_bits = rme9652->thru_bits;\r\nfor (k = 0; k < rme9652->ss_channels; ++k) {\r\nucontrol->value.integer.value[k] = !!(thru_bits & (1 << k));\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_put_thru(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nunsigned int chn;\r\nu32 thru_bits = 0;\r\nif (!snd_rme9652_use_is_exclusive(rme9652))\r\nreturn -EBUSY;\r\nfor (chn = 0; chn < rme9652->ss_channels; ++chn) {\r\nif (ucontrol->value.integer.value[chn])\r\nthru_bits |= 1 << chn;\r\n}\r\nspin_lock_irq(&rme9652->lock);\r\nchange = thru_bits ^ rme9652->thru_bits;\r\nif (change) {\r\nfor (chn = 0; chn < rme9652->ss_channels; ++chn) {\r\nif (!(change & (1 << chn)))\r\ncontinue;\r\nrme9652_set_thru(rme9652,chn,thru_bits&(1<<chn));\r\n}\r\n}\r\nspin_unlock_irq(&rme9652->lock);\r\nreturn !!change;\r\n}\r\nstatic int snd_rme9652_get_passthru(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&rme9652->lock);\r\nucontrol->value.integer.value[0] = rme9652->passthru;\r\nspin_unlock_irq(&rme9652->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_put_passthru(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nunsigned int val;\r\nint err = 0;\r\nif (!snd_rme9652_use_is_exclusive(rme9652))\r\nreturn -EBUSY;\r\nval = ucontrol->value.integer.value[0] & 1;\r\nspin_lock_irq(&rme9652->lock);\r\nchange = (ucontrol->value.integer.value[0] != rme9652->passthru);\r\nif (change)\r\nerr = rme9652_set_passthru(rme9652, val);\r\nspin_unlock_irq(&rme9652->lock);\r\nreturn err ? err : change;\r\n}\r\nstatic int snd_rme9652_info_spdif_rate(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 96000;\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_get_spdif_rate(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&rme9652->lock);\r\nucontrol->value.integer.value[0] = rme9652_spdif_sample_rate(rme9652);\r\nspin_unlock_irq(&rme9652->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_info_adat_sync(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[4] = {"No Lock", "Lock", "No Lock Sync", "Lock Sync"};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 4;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_get_adat_sync(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nunsigned int mask1, mask2, val;\r\nswitch (kcontrol->private_value) {\r\ncase 0: mask1 = RME9652_lock_0; mask2 = RME9652_sync_0; break;\r\ncase 1: mask1 = RME9652_lock_1; mask2 = RME9652_sync_1; break;\r\ncase 2: mask1 = RME9652_lock_2; mask2 = RME9652_sync_2; break;\r\ndefault: return -EINVAL;\r\n}\r\nval = rme9652_read(rme9652, RME9652_status_register);\r\nucontrol->value.enumerated.item[0] = (val & mask1) ? 1 : 0;\r\nucontrol->value.enumerated.item[0] |= (val & mask2) ? 2 : 0;\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_get_tc_valid(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] =\r\n(rme9652_read(rme9652, RME9652_status_register) & RME9652_tc_valid) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_get_tc_value(void *private_data,\r\nsnd_kswitch_t *kswitch,\r\nsnd_switch_t *uswitch)\r\n{\r\nstruct snd_rme9652 *s = (struct snd_rme9652 *) private_data;\r\nu32 value;\r\nint i;\r\nuswitch->type = SNDRV_SW_TYPE_DWORD;\r\nif ((rme9652_read(s, RME9652_status_register) &\r\nRME9652_tc_valid) == 0) {\r\nuswitch->value.data32[0] = 0;\r\nreturn 0;\r\n}\r\nrme9652_write(s, RME9652_time_code, 0);\r\nfor (i = 0; i < 50; i++) {\r\nif (!(rme9652_read(s, i * 4) & RME9652_tc_busy))\r\nbreak;\r\n}\r\nif (!(rme9652_read(s, i * 4) & RME9652_tc_busy)) {\r\nreturn -EIO;\r\n}\r\nvalue = 0;\r\nfor (i = 0; i < 32; i++) {\r\nvalue >>= 1;\r\nif (rme9652_read(s, i * 4) & RME9652_tc_out)\r\nvalue |= 0x80000000;\r\n}\r\nif (value > 2 * 60 * 48000) {\r\nvalue -= 2 * 60 * 48000;\r\n} else {\r\nvalue = 0;\r\n}\r\nuswitch->value.data32[0] = value;\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_create_controls(struct snd_card *card, struct snd_rme9652 *rme9652)\r\n{\r\nunsigned int idx;\r\nint err;\r\nstruct snd_kcontrol *kctl;\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_rme9652_controls); idx++) {\r\nif ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_rme9652_controls[idx], rme9652))) < 0)\r\nreturn err;\r\nif (idx == 1)\r\nrme9652->spdif_ctl = kctl;\r\n}\r\nif (rme9652->ss_channels == RME9652_NCHANNELS)\r\nif ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_rme9652_adat3_check, rme9652))) < 0)\r\nreturn err;\r\nif (rme9652->hw_rev >= 15)\r\nif ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_rme9652_adat1_input, rme9652))) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_rme9652_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\r\n{\r\nstruct snd_rme9652 *rme9652 = (struct snd_rme9652 *) entry->private_data;\r\nu32 thru_bits = rme9652->thru_bits;\r\nint show_auto_sync_source = 0;\r\nint i;\r\nunsigned int status;\r\nint x;\r\nstatus = rme9652_read(rme9652, RME9652_status_register);\r\nsnd_iprintf(buffer, "%s (Card #%d)\n", rme9652->card_name, rme9652->card->number + 1);\r\nsnd_iprintf(buffer, "Buffers: capture %p playback %p\n",\r\nrme9652->capture_buffer, rme9652->playback_buffer);\r\nsnd_iprintf(buffer, "IRQ: %d Registers bus: 0x%lx VM: 0x%lx\n",\r\nrme9652->irq, rme9652->port, (unsigned long)rme9652->iobase);\r\nsnd_iprintf(buffer, "Control register: %x\n", rme9652->control_register);\r\nsnd_iprintf(buffer, "\n");\r\nx = 1 << (6 + rme9652_decode_latency(rme9652->control_register &\r\nRME9652_latency));\r\nsnd_iprintf(buffer, "Latency: %d samples (2 periods of %lu bytes)\n",\r\nx, (unsigned long) rme9652->period_bytes);\r\nsnd_iprintf(buffer, "Hardware pointer (frames): %ld\n",\r\nrme9652_hw_pointer(rme9652));\r\nsnd_iprintf(buffer, "Passthru: %s\n",\r\nrme9652->passthru ? "yes" : "no");\r\nif ((rme9652->control_register & (RME9652_Master | RME9652_wsel)) == 0) {\r\nsnd_iprintf(buffer, "Clock mode: autosync\n");\r\nshow_auto_sync_source = 1;\r\n} else if (rme9652->control_register & RME9652_wsel) {\r\nif (status & RME9652_wsel_rd) {\r\nsnd_iprintf(buffer, "Clock mode: word clock\n");\r\n} else {\r\nsnd_iprintf(buffer, "Clock mode: word clock (no signal)\n");\r\n}\r\n} else {\r\nsnd_iprintf(buffer, "Clock mode: master\n");\r\n}\r\nif (show_auto_sync_source) {\r\nswitch (rme9652->control_register & RME9652_SyncPref_Mask) {\r\ncase RME9652_SyncPref_ADAT1:\r\nsnd_iprintf(buffer, "Pref. sync source: ADAT1\n");\r\nbreak;\r\ncase RME9652_SyncPref_ADAT2:\r\nsnd_iprintf(buffer, "Pref. sync source: ADAT2\n");\r\nbreak;\r\ncase RME9652_SyncPref_ADAT3:\r\nsnd_iprintf(buffer, "Pref. sync source: ADAT3\n");\r\nbreak;\r\ncase RME9652_SyncPref_SPDIF:\r\nsnd_iprintf(buffer, "Pref. sync source: IEC958\n");\r\nbreak;\r\ndefault:\r\nsnd_iprintf(buffer, "Pref. sync source: ???\n");\r\n}\r\n}\r\nif (rme9652->hw_rev >= 15)\r\nsnd_iprintf(buffer, "\nADAT1 Input source: %s\n",\r\n(rme9652->control_register & RME9652_ADAT1_INTERNAL) ?\r\n"Internal" : "ADAT1 optical");\r\nsnd_iprintf(buffer, "\n");\r\nswitch (rme9652_decode_spdif_in(rme9652->control_register &\r\nRME9652_inp)) {\r\ncase RME9652_SPDIFIN_OPTICAL:\r\nsnd_iprintf(buffer, "IEC958 input: ADAT1\n");\r\nbreak;\r\ncase RME9652_SPDIFIN_COAXIAL:\r\nsnd_iprintf(buffer, "IEC958 input: Coaxial\n");\r\nbreak;\r\ncase RME9652_SPDIFIN_INTERN:\r\nsnd_iprintf(buffer, "IEC958 input: Internal\n");\r\nbreak;\r\ndefault:\r\nsnd_iprintf(buffer, "IEC958 input: ???\n");\r\nbreak;\r\n}\r\nif (rme9652->control_register & RME9652_opt_out) {\r\nsnd_iprintf(buffer, "IEC958 output: Coaxial & ADAT1\n");\r\n} else {\r\nsnd_iprintf(buffer, "IEC958 output: Coaxial only\n");\r\n}\r\nif (rme9652->control_register & RME9652_PRO) {\r\nsnd_iprintf(buffer, "IEC958 quality: Professional\n");\r\n} else {\r\nsnd_iprintf(buffer, "IEC958 quality: Consumer\n");\r\n}\r\nif (rme9652->control_register & RME9652_EMP) {\r\nsnd_iprintf(buffer, "IEC958 emphasis: on\n");\r\n} else {\r\nsnd_iprintf(buffer, "IEC958 emphasis: off\n");\r\n}\r\nif (rme9652->control_register & RME9652_Dolby) {\r\nsnd_iprintf(buffer, "IEC958 Dolby: on\n");\r\n} else {\r\nsnd_iprintf(buffer, "IEC958 Dolby: off\n");\r\n}\r\ni = rme9652_spdif_sample_rate(rme9652);\r\nif (i < 0) {\r\nsnd_iprintf(buffer,\r\n"IEC958 sample rate: error flag set\n");\r\n} else if (i == 0) {\r\nsnd_iprintf(buffer, "IEC958 sample rate: undetermined\n");\r\n} else {\r\nsnd_iprintf(buffer, "IEC958 sample rate: %d\n", i);\r\n}\r\nsnd_iprintf(buffer, "\n");\r\nsnd_iprintf(buffer, "ADAT Sample rate: %dHz\n",\r\nrme9652_adat_sample_rate(rme9652));\r\nx = status & RME9652_sync_0;\r\nif (status & RME9652_lock_0) {\r\nsnd_iprintf(buffer, "ADAT1: %s\n", x ? "Sync" : "Lock");\r\n} else {\r\nsnd_iprintf(buffer, "ADAT1: No Lock\n");\r\n}\r\nx = status & RME9652_sync_1;\r\nif (status & RME9652_lock_1) {\r\nsnd_iprintf(buffer, "ADAT2: %s\n", x ? "Sync" : "Lock");\r\n} else {\r\nsnd_iprintf(buffer, "ADAT2: No Lock\n");\r\n}\r\nx = status & RME9652_sync_2;\r\nif (status & RME9652_lock_2) {\r\nsnd_iprintf(buffer, "ADAT3: %s\n", x ? "Sync" : "Lock");\r\n} else {\r\nsnd_iprintf(buffer, "ADAT3: No Lock\n");\r\n}\r\nsnd_iprintf(buffer, "\n");\r\nsnd_iprintf(buffer, "Timecode signal: %s\n",\r\n(status & RME9652_tc_valid) ? "yes" : "no");\r\nsnd_iprintf(buffer, "Punch Status:\n\n");\r\nfor (i = 0; i < rme9652->ss_channels; i++) {\r\nif (thru_bits & (1 << i)) {\r\nsnd_iprintf(buffer, "%2d: on ", i + 1);\r\n} else {\r\nsnd_iprintf(buffer, "%2d: off ", i + 1);\r\n}\r\nif (((i + 1) % 8) == 0) {\r\nsnd_iprintf(buffer, "\n");\r\n}\r\n}\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nstatic void __devinit snd_rme9652_proc_init(struct snd_rme9652 *rme9652)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (! snd_card_proc_new(rme9652->card, "rme9652", &entry))\r\nsnd_info_set_text_ops(entry, rme9652, snd_rme9652_proc_read);\r\n}\r\nstatic void snd_rme9652_free_buffers(struct snd_rme9652 *rme9652)\r\n{\r\nsnd_hammerfall_free_buffer(&rme9652->capture_dma_buf, rme9652->pci);\r\nsnd_hammerfall_free_buffer(&rme9652->playback_dma_buf, rme9652->pci);\r\n}\r\nstatic int snd_rme9652_free(struct snd_rme9652 *rme9652)\r\n{\r\nif (rme9652->irq >= 0)\r\nrme9652_stop(rme9652);\r\nsnd_rme9652_free_buffers(rme9652);\r\nif (rme9652->irq >= 0)\r\nfree_irq(rme9652->irq, (void *)rme9652);\r\nif (rme9652->iobase)\r\niounmap(rme9652->iobase);\r\nif (rme9652->port)\r\npci_release_regions(rme9652->pci);\r\npci_disable_device(rme9652->pci);\r\nreturn 0;\r\n}\r\nstatic int __devinit snd_rme9652_initialize_memory(struct snd_rme9652 *rme9652)\r\n{\r\nunsigned long pb_bus, cb_bus;\r\nif (snd_hammerfall_get_buffer(rme9652->pci, &rme9652->capture_dma_buf, RME9652_DMA_AREA_BYTES) < 0 ||\r\nsnd_hammerfall_get_buffer(rme9652->pci, &rme9652->playback_dma_buf, RME9652_DMA_AREA_BYTES) < 0) {\r\nif (rme9652->capture_dma_buf.area)\r\nsnd_dma_free_pages(&rme9652->capture_dma_buf);\r\nprintk(KERN_ERR "%s: no buffers available\n", rme9652->card_name);\r\nreturn -ENOMEM;\r\n}\r\ncb_bus = ALIGN(rme9652->capture_dma_buf.addr, 0x10000ul);\r\npb_bus = ALIGN(rme9652->playback_dma_buf.addr, 0x10000ul);\r\nrme9652_write(rme9652, RME9652_rec_buffer, cb_bus);\r\nrme9652_write(rme9652, RME9652_play_buffer, pb_bus);\r\nrme9652->capture_buffer = rme9652->capture_dma_buf.area + (cb_bus - rme9652->capture_dma_buf.addr);\r\nrme9652->playback_buffer = rme9652->playback_dma_buf.area + (pb_bus - rme9652->playback_dma_buf.addr);\r\nreturn 0;\r\n}\r\nstatic void snd_rme9652_set_defaults(struct snd_rme9652 *rme9652)\r\n{\r\nunsigned int k;\r\nrme9652->control_register =\r\nRME9652_inp_0 | rme9652_encode_latency(7);\r\nrme9652_write(rme9652, RME9652_control_register, rme9652->control_register);\r\nrme9652_reset_hw_pointer(rme9652);\r\nrme9652_compute_period_size(rme9652);\r\nfor (k = 0; k < RME9652_NCHANNELS; ++k)\r\nrme9652_write(rme9652, RME9652_thru_base + k * 4, 0);\r\nrme9652->thru_bits = 0;\r\nrme9652->passthru = 0;\r\nrme9652_set_rate(rme9652, 48000);\r\n}\r\nstatic irqreturn_t snd_rme9652_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_rme9652 *rme9652 = (struct snd_rme9652 *) dev_id;\r\nif (!(rme9652_read(rme9652, RME9652_status_register) & RME9652_IRQ)) {\r\nreturn IRQ_NONE;\r\n}\r\nrme9652_write(rme9652, RME9652_irq_clear, 0);\r\nif (rme9652->capture_substream) {\r\nsnd_pcm_period_elapsed(rme9652->pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream);\r\n}\r\nif (rme9652->playback_substream) {\r\nsnd_pcm_period_elapsed(rme9652->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic snd_pcm_uframes_t snd_rme9652_hw_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\r\nreturn rme9652_hw_pointer(rme9652);\r\n}\r\nstatic char *rme9652_channel_buffer_location(struct snd_rme9652 *rme9652,\r\nint stream,\r\nint channel)\r\n{\r\nint mapped_channel;\r\nif (snd_BUG_ON(channel < 0 || channel >= RME9652_NCHANNELS))\r\nreturn NULL;\r\nif ((mapped_channel = rme9652->channel_map[channel]) < 0) {\r\nreturn NULL;\r\n}\r\nif (stream == SNDRV_PCM_STREAM_CAPTURE) {\r\nreturn rme9652->capture_buffer +\r\n(mapped_channel * RME9652_CHANNEL_BUFFER_BYTES);\r\n} else {\r\nreturn rme9652->playback_buffer +\r\n(mapped_channel * RME9652_CHANNEL_BUFFER_BYTES);\r\n}\r\n}\r\nstatic int snd_rme9652_playback_copy(struct snd_pcm_substream *substream, int channel,\r\nsnd_pcm_uframes_t pos, void __user *src, snd_pcm_uframes_t count)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\r\nchar *channel_buf;\r\nif (snd_BUG_ON(pos + count > RME9652_CHANNEL_BUFFER_BYTES / 4))\r\nreturn -EINVAL;\r\nchannel_buf = rme9652_channel_buffer_location (rme9652,\r\nsubstream->pstr->stream,\r\nchannel);\r\nif (snd_BUG_ON(!channel_buf))\r\nreturn -EIO;\r\nif (copy_from_user(channel_buf + pos * 4, src, count * 4))\r\nreturn -EFAULT;\r\nreturn count;\r\n}\r\nstatic int snd_rme9652_capture_copy(struct snd_pcm_substream *substream, int channel,\r\nsnd_pcm_uframes_t pos, void __user *dst, snd_pcm_uframes_t count)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\r\nchar *channel_buf;\r\nif (snd_BUG_ON(pos + count > RME9652_CHANNEL_BUFFER_BYTES / 4))\r\nreturn -EINVAL;\r\nchannel_buf = rme9652_channel_buffer_location (rme9652,\r\nsubstream->pstr->stream,\r\nchannel);\r\nif (snd_BUG_ON(!channel_buf))\r\nreturn -EIO;\r\nif (copy_to_user(dst, channel_buf + pos * 4, count * 4))\r\nreturn -EFAULT;\r\nreturn count;\r\n}\r\nstatic int snd_rme9652_hw_silence(struct snd_pcm_substream *substream, int channel,\r\nsnd_pcm_uframes_t pos, snd_pcm_uframes_t count)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\r\nchar *channel_buf;\r\nchannel_buf = rme9652_channel_buffer_location (rme9652,\r\nsubstream->pstr->stream,\r\nchannel);\r\nif (snd_BUG_ON(!channel_buf))\r\nreturn -EIO;\r\nmemset(channel_buf + pos * 4, 0, count * 4);\r\nreturn count;\r\n}\r\nstatic int snd_rme9652_reset(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_substream *other;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nother = rme9652->capture_substream;\r\nelse\r\nother = rme9652->playback_substream;\r\nif (rme9652->running)\r\nruntime->status->hw_ptr = rme9652_hw_pointer(rme9652);\r\nelse\r\nruntime->status->hw_ptr = 0;\r\nif (other) {\r\nstruct snd_pcm_substream *s;\r\nstruct snd_pcm_runtime *oruntime = other->runtime;\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s == other) {\r\noruntime->status->hw_ptr = runtime->status->hw_ptr;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\r\nint err;\r\npid_t this_pid;\r\npid_t other_pid;\r\nspin_lock_irq(&rme9652->lock);\r\nif (substream->pstr->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nrme9652->control_register &= ~(RME9652_PRO | RME9652_Dolby | RME9652_EMP);\r\nrme9652_write(rme9652, RME9652_control_register, rme9652->control_register |= rme9652->creg_spdif_stream);\r\nthis_pid = rme9652->playback_pid;\r\nother_pid = rme9652->capture_pid;\r\n} else {\r\nthis_pid = rme9652->capture_pid;\r\nother_pid = rme9652->playback_pid;\r\n}\r\nif ((other_pid > 0) && (this_pid != other_pid)) {\r\nif ((int)params_rate(params) !=\r\nrme9652_adat_sample_rate(rme9652)) {\r\nspin_unlock_irq(&rme9652->lock);\r\n_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_RATE);\r\nreturn -EBUSY;\r\n}\r\nif (params_period_size(params) != rme9652->period_bytes / 4) {\r\nspin_unlock_irq(&rme9652->lock);\r\n_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);\r\nreturn -EBUSY;\r\n}\r\nspin_unlock_irq(&rme9652->lock);\r\nreturn 0;\r\n} else {\r\nspin_unlock_irq(&rme9652->lock);\r\n}\r\nif ((err = rme9652_set_rate(rme9652, params_rate(params))) < 0) {\r\n_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_RATE);\r\nreturn err;\r\n}\r\nif ((err = rme9652_set_interrupt_interval(rme9652, params_period_size(params))) < 0) {\r\n_snd_pcm_hw_param_setempty(params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_channel_info(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_channel_info *info)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\r\nint chn;\r\nif (snd_BUG_ON(info->channel >= RME9652_NCHANNELS))\r\nreturn -EINVAL;\r\nif ((chn = rme9652->channel_map[info->channel]) < 0) {\r\nreturn -EINVAL;\r\n}\r\ninfo->offset = chn * RME9652_CHANNEL_BUFFER_BYTES;\r\ninfo->first = 0;\r\ninfo->step = 32;\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_ioctl(struct snd_pcm_substream *substream,\r\nunsigned int cmd, void *arg)\r\n{\r\nswitch (cmd) {\r\ncase SNDRV_PCM_IOCTL1_RESET:\r\n{\r\nreturn snd_rme9652_reset(substream);\r\n}\r\ncase SNDRV_PCM_IOCTL1_CHANNEL_INFO:\r\n{\r\nstruct snd_pcm_channel_info *info = arg;\r\nreturn snd_rme9652_channel_info(substream, info);\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn snd_pcm_lib_ioctl(substream, cmd, arg);\r\n}\r\nstatic void rme9652_silence_playback(struct snd_rme9652 *rme9652)\r\n{\r\nmemset(rme9652->playback_buffer, 0, RME9652_DMA_AREA_BYTES);\r\n}\r\nstatic int snd_rme9652_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_substream *other;\r\nint running;\r\nspin_lock(&rme9652->lock);\r\nrunning = rme9652->running;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nrunning |= 1 << substream->stream;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nrunning &= ~(1 << substream->stream);\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nspin_unlock(&rme9652->lock);\r\nreturn -EINVAL;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nother = rme9652->capture_substream;\r\nelse\r\nother = rme9652->playback_substream;\r\nif (other) {\r\nstruct snd_pcm_substream *s;\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s == other) {\r\nsnd_pcm_trigger_done(s, substream);\r\nif (cmd == SNDRV_PCM_TRIGGER_START)\r\nrunning |= 1 << s->stream;\r\nelse\r\nrunning &= ~(1 << s->stream);\r\ngoto _ok;\r\n}\r\n}\r\nif (cmd == SNDRV_PCM_TRIGGER_START) {\r\nif (!(running & (1 << SNDRV_PCM_STREAM_PLAYBACK)) &&\r\nsubstream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nrme9652_silence_playback(rme9652);\r\n} else {\r\nif (running &&\r\nsubstream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nrme9652_silence_playback(rme9652);\r\n}\r\n} else {\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nrme9652_silence_playback(rme9652);\r\n}\r\n_ok:\r\nsnd_pcm_trigger_done(substream, substream);\r\nif (!rme9652->running && running)\r\nrme9652_start(rme9652);\r\nelse if (rme9652->running && !running)\r\nrme9652_stop(rme9652);\r\nrme9652->running = running;\r\nspin_unlock(&rme9652->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\r\nunsigned long flags;\r\nint result = 0;\r\nspin_lock_irqsave(&rme9652->lock, flags);\r\nif (!rme9652->running)\r\nrme9652_reset_hw_pointer(rme9652);\r\nspin_unlock_irqrestore(&rme9652->lock, flags);\r\nreturn result;\r\n}\r\nstatic int snd_rme9652_hw_rule_channels(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_rme9652 *rme9652 = rule->private;\r\nstruct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nunsigned int list[2] = { rme9652->ds_channels, rme9652->ss_channels };\r\nreturn snd_interval_list(c, 2, list, 0);\r\n}\r\nstatic int snd_rme9652_hw_rule_channels_rate(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_rme9652 *rme9652 = rule->private;\r\nstruct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_interval *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nif (r->min > 48000) {\r\nstruct snd_interval t = {\r\n.min = rme9652->ds_channels,\r\n.max = rme9652->ds_channels,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(c, &t);\r\n} else if (r->max < 88200) {\r\nstruct snd_interval t = {\r\n.min = rme9652->ss_channels,\r\n.max = rme9652->ss_channels,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(c, &t);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_hw_rule_rate_channels(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_rme9652 *rme9652 = rule->private;\r\nstruct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_interval *r = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nif (c->min >= rme9652->ss_channels) {\r\nstruct snd_interval t = {\r\n.min = 44100,\r\n.max = 48000,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(r, &t);\r\n} else if (c->max <= rme9652->ds_channels) {\r\nstruct snd_interval t = {\r\n.min = 88200,\r\n.max = 96000,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(r, &t);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nspin_lock_irq(&rme9652->lock);\r\nsnd_pcm_set_sync(substream);\r\nruntime->hw = snd_rme9652_playback_subinfo;\r\nruntime->dma_area = rme9652->playback_buffer;\r\nruntime->dma_bytes = RME9652_DMA_AREA_BYTES;\r\nif (rme9652->capture_substream == NULL) {\r\nrme9652_stop(rme9652);\r\nrme9652_set_thru(rme9652, -1, 0);\r\n}\r\nrme9652->playback_pid = current->pid;\r\nrme9652->playback_substream = substream;\r\nspin_unlock_irq(&rme9652->lock);\r\nsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, &hw_constraints_period_sizes);\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nsnd_rme9652_hw_rule_channels, rme9652,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nsnd_rme9652_hw_rule_channels_rate, rme9652,\r\nSNDRV_PCM_HW_PARAM_RATE, -1);\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\nsnd_rme9652_hw_rule_rate_channels, rme9652,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nrme9652->creg_spdif_stream = rme9652->creg_spdif;\r\nrme9652->spdif_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(rme9652->card, SNDRV_CTL_EVENT_MASK_VALUE |\r\nSNDRV_CTL_EVENT_MASK_INFO, &rme9652->spdif_ctl->id);\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_playback_release(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\r\nspin_lock_irq(&rme9652->lock);\r\nrme9652->playback_pid = -1;\r\nrme9652->playback_substream = NULL;\r\nspin_unlock_irq(&rme9652->lock);\r\nrme9652->spdif_ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(rme9652->card, SNDRV_CTL_EVENT_MASK_VALUE |\r\nSNDRV_CTL_EVENT_MASK_INFO, &rme9652->spdif_ctl->id);\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nspin_lock_irq(&rme9652->lock);\r\nsnd_pcm_set_sync(substream);\r\nruntime->hw = snd_rme9652_capture_subinfo;\r\nruntime->dma_area = rme9652->capture_buffer;\r\nruntime->dma_bytes = RME9652_DMA_AREA_BYTES;\r\nif (rme9652->playback_substream == NULL) {\r\nrme9652_stop(rme9652);\r\nrme9652_set_thru(rme9652, -1, 0);\r\n}\r\nrme9652->capture_pid = current->pid;\r\nrme9652->capture_substream = substream;\r\nspin_unlock_irq(&rme9652->lock);\r\nsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, &hw_constraints_period_sizes);\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nsnd_rme9652_hw_rule_channels, rme9652,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nsnd_rme9652_hw_rule_channels_rate, rme9652,\r\nSNDRV_PCM_HW_PARAM_RATE, -1);\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\nsnd_rme9652_hw_rule_rate_channels, rme9652,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nreturn 0;\r\n}\r\nstatic int snd_rme9652_capture_release(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_rme9652 *rme9652 = snd_pcm_substream_chip(substream);\r\nspin_lock_irq(&rme9652->lock);\r\nrme9652->capture_pid = -1;\r\nrme9652->capture_substream = NULL;\r\nspin_unlock_irq(&rme9652->lock);\r\nreturn 0;\r\n}\r\nstatic int __devinit snd_rme9652_create_pcm(struct snd_card *card,\r\nstruct snd_rme9652 *rme9652)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif ((err = snd_pcm_new(card,\r\nrme9652->card_name,\r\n0, 1, 1, &pcm)) < 0) {\r\nreturn err;\r\n}\r\nrme9652->pcm = pcm;\r\npcm->private_data = rme9652;\r\nstrcpy(pcm->name, rme9652->card_name);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_rme9652_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_rme9652_capture_ops);\r\npcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;\r\nreturn 0;\r\n}\r\nstatic int __devinit snd_rme9652_create(struct snd_card *card,\r\nstruct snd_rme9652 *rme9652,\r\nint precise_ptr)\r\n{\r\nstruct pci_dev *pci = rme9652->pci;\r\nint err;\r\nint status;\r\nunsigned short rev;\r\nrme9652->irq = -1;\r\nrme9652->card = card;\r\npci_read_config_word(rme9652->pci, PCI_CLASS_REVISION, &rev);\r\nswitch (rev & 0xff) {\r\ncase 3:\r\ncase 4:\r\ncase 8:\r\ncase 9:\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nspin_lock_init(&rme9652->lock);\r\nif ((err = pci_request_regions(pci, "rme9652")) < 0)\r\nreturn err;\r\nrme9652->port = pci_resource_start(pci, 0);\r\nrme9652->iobase = ioremap_nocache(rme9652->port, RME9652_IO_EXTENT);\r\nif (rme9652->iobase == NULL) {\r\nsnd_printk(KERN_ERR "unable to remap region 0x%lx-0x%lx\n", rme9652->port, rme9652->port + RME9652_IO_EXTENT - 1);\r\nreturn -EBUSY;\r\n}\r\nif (request_irq(pci->irq, snd_rme9652_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, rme9652)) {\r\nsnd_printk(KERN_ERR "unable to request IRQ %d\n", pci->irq);\r\nreturn -EBUSY;\r\n}\r\nrme9652->irq = pci->irq;\r\nrme9652->precise_ptr = precise_ptr;\r\nstatus = rme9652_read(rme9652, RME9652_status_register);\r\nif (rme9652_decode_spdif_rate(status&RME9652_F) == 1) {\r\nrme9652->hw_rev = 15;\r\n} else {\r\nrme9652->hw_rev = 11;\r\n}\r\nswitch (rev) {\r\ncase 8:\r\nstrcpy(card->driver, "RME9636");\r\nif (rme9652->hw_rev == 15) {\r\nrme9652->card_name = "RME Digi9636 (Rev 1.5)";\r\n} else {\r\nrme9652->card_name = "RME Digi9636";\r\n}\r\nrme9652->ss_channels = RME9636_NCHANNELS;\r\nbreak;\r\ncase 9:\r\nstrcpy(card->driver, "RME9636");\r\nrme9652->card_name = "RME Digi9636 (Rev G)";\r\nrme9652->ss_channels = RME9636_NCHANNELS;\r\nbreak;\r\ncase 4:\r\nstrcpy(card->driver, "RME9652");\r\nrme9652->card_name = "RME Digi9652 (Rev G)";\r\nrme9652->ss_channels = RME9652_NCHANNELS;\r\nbreak;\r\ncase 3:\r\nstrcpy(card->driver, "RME9652");\r\nif (rme9652->hw_rev == 15) {\r\nrme9652->card_name = "RME Digi9652 (Rev 1.5)";\r\n} else {\r\nrme9652->card_name = "RME Digi9652";\r\n}\r\nrme9652->ss_channels = RME9652_NCHANNELS;\r\nbreak;\r\n}\r\nrme9652->ds_channels = (rme9652->ss_channels - 2) / 2 + 2;\r\npci_set_master(rme9652->pci);\r\nif ((err = snd_rme9652_initialize_memory(rme9652)) < 0) {\r\nreturn err;\r\n}\r\nif ((err = snd_rme9652_create_pcm(card, rme9652)) < 0) {\r\nreturn err;\r\n}\r\nif ((err = snd_rme9652_create_controls(card, rme9652)) < 0) {\r\nreturn err;\r\n}\r\nsnd_rme9652_proc_init(rme9652);\r\nrme9652->last_spdif_sample_rate = -1;\r\nrme9652->last_adat_sample_rate = -1;\r\nrme9652->playback_pid = -1;\r\nrme9652->capture_pid = -1;\r\nrme9652->capture_substream = NULL;\r\nrme9652->playback_substream = NULL;\r\nsnd_rme9652_set_defaults(rme9652);\r\nif (rme9652->hw_rev == 15) {\r\nrme9652_initialize_spdif_receiver (rme9652);\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_rme9652_card_free(struct snd_card *card)\r\n{\r\nstruct snd_rme9652 *rme9652 = (struct snd_rme9652 *) card->private_data;\r\nif (rme9652)\r\nsnd_rme9652_free(rme9652);\r\n}\r\nstatic int __devinit snd_rme9652_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_rme9652 *rme9652;\r\nstruct snd_card *card;\r\nint err;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE,\r\nsizeof(struct snd_rme9652), &card);\r\nif (err < 0)\r\nreturn err;\r\nrme9652 = (struct snd_rme9652 *) card->private_data;\r\ncard->private_free = snd_rme9652_card_free;\r\nrme9652->dev = dev;\r\nrme9652->pci = pci;\r\nsnd_card_set_dev(card, &pci->dev);\r\nif ((err = snd_rme9652_create(card, rme9652, precise_ptr[dev])) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstrcpy(card->shortname, rme9652->card_name);\r\nsprintf(card->longname, "%s at 0x%lx, irq %d",\r\ncard->shortname, rme9652->port, rme9652->irq);\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void __devexit snd_rme9652_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\npci_set_drvdata(pci, NULL);\r\n}\r\nstatic int __init alsa_card_hammerfall_init(void)\r\n{\r\nreturn pci_register_driver(&driver);\r\n}\r\nstatic void __exit alsa_card_hammerfall_exit(void)\r\n{\r\npci_unregister_driver(&driver);\r\n}
