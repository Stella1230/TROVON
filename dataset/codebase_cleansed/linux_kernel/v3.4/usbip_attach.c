void usbip_attach_usage(void)\r\n{\r\nprintf("usage: %s", usbip_attach_usage_string);\r\n}\r\nstatic int record_connection(char *host, char *port, char *busid, int rhport)\r\n{\r\nint fd;\r\nchar path[PATH_MAX+1];\r\nchar buff[MAX_BUFF+1];\r\nint ret;\r\nret = mkdir(VHCI_STATE_PATH, 0700);\r\nif (ret < 0)\r\nreturn -1;\r\nsnprintf(path, PATH_MAX, VHCI_STATE_PATH"/port%d", rhport);\r\nfd = open(path, O_WRONLY|O_CREAT|O_TRUNC, S_IRWXU);\r\nif (fd < 0)\r\nreturn -1;\r\nsnprintf(buff, MAX_BUFF, "%s %s %s\n",\r\nhost, port, busid);\r\nret = write(fd, buff, strlen(buff));\r\nif (ret != (ssize_t) strlen(buff)) {\r\nclose(fd);\r\nreturn -1;\r\n}\r\nclose(fd);\r\nreturn 0;\r\n}\r\nstatic int import_device(int sockfd, struct usbip_usb_device *udev)\r\n{\r\nint rc;\r\nint port;\r\nrc = usbip_vhci_driver_open();\r\nif (rc < 0) {\r\nerr("open vhci_driver");\r\nreturn -1;\r\n}\r\nport = usbip_vhci_get_free_port();\r\nif (port < 0) {\r\nerr("no free port");\r\nusbip_vhci_driver_close();\r\nreturn -1;\r\n}\r\nrc = usbip_vhci_attach_device(port, sockfd, udev->busnum,\r\nudev->devnum, udev->speed);\r\nif (rc < 0) {\r\nerr("import device");\r\nusbip_vhci_driver_close();\r\nreturn -1;\r\n}\r\nusbip_vhci_driver_close();\r\nreturn port;\r\n}\r\nstatic int query_import_device(int sockfd, char *busid)\r\n{\r\nint rc;\r\nstruct op_import_request request;\r\nstruct op_import_reply reply;\r\nuint16_t code = OP_REP_IMPORT;\r\nmemset(&request, 0, sizeof(request));\r\nmemset(&reply, 0, sizeof(reply));\r\nrc = usbip_net_send_op_common(sockfd, OP_REQ_IMPORT, 0);\r\nif (rc < 0) {\r\nerr("send op_common");\r\nreturn -1;\r\n}\r\nstrncpy(request.busid, busid, SYSFS_BUS_ID_SIZE-1);\r\nPACK_OP_IMPORT_REQUEST(0, &request);\r\nrc = usbip_net_send(sockfd, (void *) &request, sizeof(request));\r\nif (rc < 0) {\r\nerr("send op_import_request");\r\nreturn -1;\r\n}\r\nrc = usbip_net_recv_op_common(sockfd, &code);\r\nif (rc < 0) {\r\nerr("recv op_common");\r\nreturn -1;\r\n}\r\nrc = usbip_net_recv(sockfd, (void *) &reply, sizeof(reply));\r\nif (rc < 0) {\r\nerr("recv op_import_reply");\r\nreturn -1;\r\n}\r\nPACK_OP_IMPORT_REPLY(0, &reply);\r\nif (strncmp(reply.udev.busid, busid, SYSFS_BUS_ID_SIZE)) {\r\nerr("recv different busid %s", reply.udev.busid);\r\nreturn -1;\r\n}\r\nreturn import_device(sockfd, &reply.udev);\r\n}\r\nstatic int attach_device(char *host, char *busid)\r\n{\r\nint sockfd;\r\nint rc;\r\nint rhport;\r\nsockfd = usbip_net_tcp_connect(host, USBIP_PORT_STRING);\r\nif (sockfd < 0) {\r\nerr("tcp connect");\r\nreturn -1;\r\n}\r\nrhport = query_import_device(sockfd, busid);\r\nif (rhport < 0) {\r\nerr("query");\r\nreturn -1;\r\n}\r\nclose(sockfd);\r\nrc = record_connection(host, USBIP_PORT_STRING, busid, rhport);\r\nif (rc < 0) {\r\nerr("record connection");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint usbip_attach(int argc, char *argv[])\r\n{\r\nstatic const struct option opts[] = {\r\n{ "host", required_argument, NULL, 'h' },\r\n{ "busid", required_argument, NULL, 'b' },\r\n{ NULL, 0, NULL, 0 }\r\n};\r\nchar *host = NULL;\r\nchar *busid = NULL;\r\nint opt;\r\nint ret = -1;\r\nfor (;;) {\r\nopt = getopt_long(argc, argv, "h:b:", opts, NULL);\r\nif (opt == -1)\r\nbreak;\r\nswitch (opt) {\r\ncase 'h':\r\nhost = optarg;\r\nbreak;\r\ncase 'b':\r\nbusid = optarg;\r\nbreak;\r\ndefault:\r\ngoto err_out;\r\n}\r\n}\r\nif (!host || !busid)\r\ngoto err_out;\r\nret = attach_device(host, busid);\r\ngoto out;\r\nerr_out:\r\nusbip_attach_usage();\r\nout:\r\nreturn ret;\r\n}
