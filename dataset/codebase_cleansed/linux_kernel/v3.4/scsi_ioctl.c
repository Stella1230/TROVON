static int sg_get_version(int __user *p)\r\n{\r\nstatic const int sg_version_num = 30527;\r\nreturn put_user(sg_version_num, p);\r\n}\r\nstatic int scsi_get_idlun(struct request_queue *q, int __user *p)\r\n{\r\nreturn put_user(0, p);\r\n}\r\nstatic int scsi_get_bus(struct request_queue *q, int __user *p)\r\n{\r\nreturn put_user(0, p);\r\n}\r\nstatic int sg_get_timeout(struct request_queue *q)\r\n{\r\nreturn jiffies_to_clock_t(q->sg_timeout);\r\n}\r\nstatic int sg_set_timeout(struct request_queue *q, int __user *p)\r\n{\r\nint timeout, err = get_user(timeout, p);\r\nif (!err)\r\nq->sg_timeout = clock_t_to_jiffies(timeout);\r\nreturn err;\r\n}\r\nstatic int sg_get_reserved_size(struct request_queue *q, int __user *p)\r\n{\r\nunsigned val = min(q->sg_reserved_size, queue_max_sectors(q) << 9);\r\nreturn put_user(val, p);\r\n}\r\nstatic int sg_set_reserved_size(struct request_queue *q, int __user *p)\r\n{\r\nint size, err = get_user(size, p);\r\nif (err)\r\nreturn err;\r\nif (size < 0)\r\nreturn -EINVAL;\r\nif (size > (queue_max_sectors(q) << 9))\r\nsize = queue_max_sectors(q) << 9;\r\nq->sg_reserved_size = size;\r\nreturn 0;\r\n}\r\nstatic int sg_emulated_host(struct request_queue *q, int __user *p)\r\n{\r\nreturn put_user(1, p);\r\n}\r\nstatic void blk_set_cmd_filter_defaults(struct blk_cmd_filter *filter)\r\n{\r\n__set_bit(TEST_UNIT_READY, filter->read_ok);\r\n__set_bit(REQUEST_SENSE, filter->read_ok);\r\n__set_bit(READ_6, filter->read_ok);\r\n__set_bit(READ_10, filter->read_ok);\r\n__set_bit(READ_12, filter->read_ok);\r\n__set_bit(READ_16, filter->read_ok);\r\n__set_bit(READ_BUFFER, filter->read_ok);\r\n__set_bit(READ_DEFECT_DATA, filter->read_ok);\r\n__set_bit(READ_CAPACITY, filter->read_ok);\r\n__set_bit(READ_LONG, filter->read_ok);\r\n__set_bit(INQUIRY, filter->read_ok);\r\n__set_bit(MODE_SENSE, filter->read_ok);\r\n__set_bit(MODE_SENSE_10, filter->read_ok);\r\n__set_bit(LOG_SENSE, filter->read_ok);\r\n__set_bit(START_STOP, filter->read_ok);\r\n__set_bit(GPCMD_VERIFY_10, filter->read_ok);\r\n__set_bit(VERIFY_16, filter->read_ok);\r\n__set_bit(REPORT_LUNS, filter->read_ok);\r\n__set_bit(SERVICE_ACTION_IN, filter->read_ok);\r\n__set_bit(RECEIVE_DIAGNOSTIC, filter->read_ok);\r\n__set_bit(MAINTENANCE_IN, filter->read_ok);\r\n__set_bit(GPCMD_READ_BUFFER_CAPACITY, filter->read_ok);\r\n__set_bit(GPCMD_PLAY_CD, filter->read_ok);\r\n__set_bit(GPCMD_PLAY_AUDIO_10, filter->read_ok);\r\n__set_bit(GPCMD_PLAY_AUDIO_MSF, filter->read_ok);\r\n__set_bit(GPCMD_PLAY_AUDIO_TI, filter->read_ok);\r\n__set_bit(GPCMD_PAUSE_RESUME, filter->read_ok);\r\n__set_bit(GPCMD_READ_CD, filter->read_ok);\r\n__set_bit(GPCMD_READ_CD_MSF, filter->read_ok);\r\n__set_bit(GPCMD_READ_DISC_INFO, filter->read_ok);\r\n__set_bit(GPCMD_READ_CDVD_CAPACITY, filter->read_ok);\r\n__set_bit(GPCMD_READ_DVD_STRUCTURE, filter->read_ok);\r\n__set_bit(GPCMD_READ_HEADER, filter->read_ok);\r\n__set_bit(GPCMD_READ_TRACK_RZONE_INFO, filter->read_ok);\r\n__set_bit(GPCMD_READ_SUBCHANNEL, filter->read_ok);\r\n__set_bit(GPCMD_READ_TOC_PMA_ATIP, filter->read_ok);\r\n__set_bit(GPCMD_REPORT_KEY, filter->read_ok);\r\n__set_bit(GPCMD_SCAN, filter->read_ok);\r\n__set_bit(GPCMD_GET_CONFIGURATION, filter->read_ok);\r\n__set_bit(GPCMD_READ_FORMAT_CAPACITIES, filter->read_ok);\r\n__set_bit(GPCMD_GET_EVENT_STATUS_NOTIFICATION, filter->read_ok);\r\n__set_bit(GPCMD_GET_PERFORMANCE, filter->read_ok);\r\n__set_bit(GPCMD_SEEK, filter->read_ok);\r\n__set_bit(GPCMD_STOP_PLAY_SCAN, filter->read_ok);\r\n__set_bit(WRITE_6, filter->write_ok);\r\n__set_bit(WRITE_10, filter->write_ok);\r\n__set_bit(WRITE_VERIFY, filter->write_ok);\r\n__set_bit(WRITE_12, filter->write_ok);\r\n__set_bit(WRITE_VERIFY_12, filter->write_ok);\r\n__set_bit(WRITE_16, filter->write_ok);\r\n__set_bit(WRITE_LONG, filter->write_ok);\r\n__set_bit(WRITE_LONG_2, filter->write_ok);\r\n__set_bit(ERASE, filter->write_ok);\r\n__set_bit(GPCMD_MODE_SELECT_10, filter->write_ok);\r\n__set_bit(MODE_SELECT, filter->write_ok);\r\n__set_bit(LOG_SELECT, filter->write_ok);\r\n__set_bit(GPCMD_BLANK, filter->write_ok);\r\n__set_bit(GPCMD_CLOSE_TRACK, filter->write_ok);\r\n__set_bit(GPCMD_FLUSH_CACHE, filter->write_ok);\r\n__set_bit(GPCMD_FORMAT_UNIT, filter->write_ok);\r\n__set_bit(GPCMD_REPAIR_RZONE_TRACK, filter->write_ok);\r\n__set_bit(GPCMD_RESERVE_RZONE_TRACK, filter->write_ok);\r\n__set_bit(GPCMD_SEND_DVD_STRUCTURE, filter->write_ok);\r\n__set_bit(GPCMD_SEND_EVENT, filter->write_ok);\r\n__set_bit(GPCMD_SEND_KEY, filter->write_ok);\r\n__set_bit(GPCMD_SEND_OPC, filter->write_ok);\r\n__set_bit(GPCMD_SEND_CUE_SHEET, filter->write_ok);\r\n__set_bit(GPCMD_SET_SPEED, filter->write_ok);\r\n__set_bit(GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL, filter->write_ok);\r\n__set_bit(GPCMD_LOAD_UNLOAD, filter->write_ok);\r\n__set_bit(GPCMD_SET_STREAMING, filter->write_ok);\r\n__set_bit(GPCMD_SET_READ_AHEAD, filter->write_ok);\r\n}\r\nint blk_verify_command(unsigned char *cmd, fmode_t has_write_perm)\r\n{\r\nstruct blk_cmd_filter *filter = &blk_default_cmd_filter;\r\nif (capable(CAP_SYS_RAWIO))\r\nreturn 0;\r\nif (!filter)\r\nreturn -EPERM;\r\nif (test_bit(cmd[0], filter->read_ok))\r\nreturn 0;\r\nif (test_bit(cmd[0], filter->write_ok) && has_write_perm)\r\nreturn 0;\r\nreturn -EPERM;\r\n}\r\nstatic int blk_fill_sghdr_rq(struct request_queue *q, struct request *rq,\r\nstruct sg_io_hdr *hdr, fmode_t mode)\r\n{\r\nif (copy_from_user(rq->cmd, hdr->cmdp, hdr->cmd_len))\r\nreturn -EFAULT;\r\nif (blk_verify_command(rq->cmd, mode & FMODE_WRITE))\r\nreturn -EPERM;\r\nrq->cmd_len = hdr->cmd_len;\r\nrq->cmd_type = REQ_TYPE_BLOCK_PC;\r\nrq->timeout = msecs_to_jiffies(hdr->timeout);\r\nif (!rq->timeout)\r\nrq->timeout = q->sg_timeout;\r\nif (!rq->timeout)\r\nrq->timeout = BLK_DEFAULT_SG_TIMEOUT;\r\nif (rq->timeout < BLK_MIN_SG_TIMEOUT)\r\nrq->timeout = BLK_MIN_SG_TIMEOUT;\r\nreturn 0;\r\n}\r\nstatic int blk_complete_sghdr_rq(struct request *rq, struct sg_io_hdr *hdr,\r\nstruct bio *bio)\r\n{\r\nint r, ret = 0;\r\nhdr->status = rq->errors & 0xff;\r\nhdr->masked_status = status_byte(rq->errors);\r\nhdr->msg_status = msg_byte(rq->errors);\r\nhdr->host_status = host_byte(rq->errors);\r\nhdr->driver_status = driver_byte(rq->errors);\r\nhdr->info = 0;\r\nif (hdr->masked_status || hdr->host_status || hdr->driver_status)\r\nhdr->info |= SG_INFO_CHECK;\r\nhdr->resid = rq->resid_len;\r\nhdr->sb_len_wr = 0;\r\nif (rq->sense_len && hdr->sbp) {\r\nint len = min((unsigned int) hdr->mx_sb_len, rq->sense_len);\r\nif (!copy_to_user(hdr->sbp, rq->sense, len))\r\nhdr->sb_len_wr = len;\r\nelse\r\nret = -EFAULT;\r\n}\r\nr = blk_rq_unmap_user(bio);\r\nif (!ret)\r\nret = r;\r\nblk_put_request(rq);\r\nreturn ret;\r\n}\r\nstatic int sg_io(struct request_queue *q, struct gendisk *bd_disk,\r\nstruct sg_io_hdr *hdr, fmode_t mode)\r\n{\r\nunsigned long start_time;\r\nint writing = 0, ret = 0;\r\nstruct request *rq;\r\nchar sense[SCSI_SENSE_BUFFERSIZE];\r\nstruct bio *bio;\r\nif (hdr->interface_id != 'S')\r\nreturn -EINVAL;\r\nif (hdr->cmd_len > BLK_MAX_CDB)\r\nreturn -EINVAL;\r\nif (hdr->dxfer_len > (queue_max_hw_sectors(q) << 9))\r\nreturn -EIO;\r\nif (hdr->dxfer_len)\r\nswitch (hdr->dxfer_direction) {\r\ndefault:\r\nreturn -EINVAL;\r\ncase SG_DXFER_TO_DEV:\r\nwriting = 1;\r\nbreak;\r\ncase SG_DXFER_TO_FROM_DEV:\r\ncase SG_DXFER_FROM_DEV:\r\nbreak;\r\n}\r\nrq = blk_get_request(q, writing ? WRITE : READ, GFP_KERNEL);\r\nif (!rq)\r\nreturn -ENOMEM;\r\nif (blk_fill_sghdr_rq(q, rq, hdr, mode)) {\r\nblk_put_request(rq);\r\nreturn -EFAULT;\r\n}\r\nif (hdr->iovec_count) {\r\nconst int size = sizeof(struct sg_iovec) * hdr->iovec_count;\r\nsize_t iov_data_len;\r\nstruct sg_iovec *sg_iov;\r\nstruct iovec *iov;\r\nint i;\r\nsg_iov = kmalloc(size, GFP_KERNEL);\r\nif (!sg_iov) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (copy_from_user(sg_iov, hdr->dxferp, size)) {\r\nkfree(sg_iov);\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\niov = (struct iovec *) sg_iov;\r\niov_data_len = 0;\r\nfor (i = 0; i < hdr->iovec_count; i++) {\r\nif (iov_data_len + iov[i].iov_len < iov_data_len) {\r\nkfree(sg_iov);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\niov_data_len += iov[i].iov_len;\r\n}\r\nif (hdr->dxfer_len < iov_data_len) {\r\nhdr->iovec_count = iov_shorten(iov,\r\nhdr->iovec_count,\r\nhdr->dxfer_len);\r\niov_data_len = hdr->dxfer_len;\r\n}\r\nret = blk_rq_map_user_iov(q, rq, NULL, sg_iov, hdr->iovec_count,\r\niov_data_len, GFP_KERNEL);\r\nkfree(sg_iov);\r\n} else if (hdr->dxfer_len)\r\nret = blk_rq_map_user(q, rq, NULL, hdr->dxferp, hdr->dxfer_len,\r\nGFP_KERNEL);\r\nif (ret)\r\ngoto out;\r\nbio = rq->bio;\r\nmemset(sense, 0, sizeof(sense));\r\nrq->sense = sense;\r\nrq->sense_len = 0;\r\nrq->retries = 0;\r\nstart_time = jiffies;\r\nblk_execute_rq(q, bd_disk, rq, 0);\r\nhdr->duration = jiffies_to_msecs(jiffies - start_time);\r\nreturn blk_complete_sghdr_rq(rq, hdr, bio);\r\nout:\r\nblk_put_request(rq);\r\nreturn ret;\r\n}\r\nint sg_scsi_ioctl(struct request_queue *q, struct gendisk *disk, fmode_t mode,\r\nstruct scsi_ioctl_command __user *sic)\r\n{\r\nstruct request *rq;\r\nint err;\r\nunsigned int in_len, out_len, bytes, opcode, cmdlen;\r\nchar *buffer = NULL, sense[SCSI_SENSE_BUFFERSIZE];\r\nif (!sic)\r\nreturn -EINVAL;\r\nif (get_user(in_len, &sic->inlen))\r\nreturn -EFAULT;\r\nif (get_user(out_len, &sic->outlen))\r\nreturn -EFAULT;\r\nif (in_len > PAGE_SIZE || out_len > PAGE_SIZE)\r\nreturn -EINVAL;\r\nif (get_user(opcode, sic->data))\r\nreturn -EFAULT;\r\nbytes = max(in_len, out_len);\r\nif (bytes) {\r\nbuffer = kzalloc(bytes, q->bounce_gfp | GFP_USER| __GFP_NOWARN);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\n}\r\nrq = blk_get_request(q, in_len ? WRITE : READ, __GFP_WAIT);\r\ncmdlen = COMMAND_SIZE(opcode);\r\nerr = -EFAULT;\r\nrq->cmd_len = cmdlen;\r\nif (copy_from_user(rq->cmd, sic->data, cmdlen))\r\ngoto error;\r\nif (in_len && copy_from_user(buffer, sic->data + cmdlen, in_len))\r\ngoto error;\r\nerr = blk_verify_command(rq->cmd, mode & FMODE_WRITE);\r\nif (err)\r\ngoto error;\r\nrq->retries = 5;\r\nswitch (opcode) {\r\ncase SEND_DIAGNOSTIC:\r\ncase FORMAT_UNIT:\r\nrq->timeout = FORMAT_UNIT_TIMEOUT;\r\nrq->retries = 1;\r\nbreak;\r\ncase START_STOP:\r\nrq->timeout = START_STOP_TIMEOUT;\r\nbreak;\r\ncase MOVE_MEDIUM:\r\nrq->timeout = MOVE_MEDIUM_TIMEOUT;\r\nbreak;\r\ncase READ_ELEMENT_STATUS:\r\nrq->timeout = READ_ELEMENT_STATUS_TIMEOUT;\r\nbreak;\r\ncase READ_DEFECT_DATA:\r\nrq->timeout = READ_DEFECT_DATA_TIMEOUT;\r\nrq->retries = 1;\r\nbreak;\r\ndefault:\r\nrq->timeout = BLK_DEFAULT_SG_TIMEOUT;\r\nbreak;\r\n}\r\nif (bytes && blk_rq_map_kern(q, rq, buffer, bytes, __GFP_WAIT)) {\r\nerr = DRIVER_ERROR << 24;\r\ngoto out;\r\n}\r\nmemset(sense, 0, sizeof(sense));\r\nrq->sense = sense;\r\nrq->sense_len = 0;\r\nrq->cmd_type = REQ_TYPE_BLOCK_PC;\r\nblk_execute_rq(q, disk, rq, 0);\r\nout:\r\nerr = rq->errors & 0xff;\r\nif (err) {\r\nif (rq->sense_len && rq->sense) {\r\nbytes = (OMAX_SB_LEN > rq->sense_len) ?\r\nrq->sense_len : OMAX_SB_LEN;\r\nif (copy_to_user(sic->data, rq->sense, bytes))\r\nerr = -EFAULT;\r\n}\r\n} else {\r\nif (copy_to_user(sic->data, buffer, out_len))\r\nerr = -EFAULT;\r\n}\r\nerror:\r\nkfree(buffer);\r\nblk_put_request(rq);\r\nreturn err;\r\n}\r\nstatic int __blk_send_generic(struct request_queue *q, struct gendisk *bd_disk,\r\nint cmd, int data)\r\n{\r\nstruct request *rq;\r\nint err;\r\nrq = blk_get_request(q, WRITE, __GFP_WAIT);\r\nrq->cmd_type = REQ_TYPE_BLOCK_PC;\r\nrq->timeout = BLK_DEFAULT_SG_TIMEOUT;\r\nrq->cmd[0] = cmd;\r\nrq->cmd[4] = data;\r\nrq->cmd_len = 6;\r\nerr = blk_execute_rq(q, bd_disk, rq, 0);\r\nblk_put_request(rq);\r\nreturn err;\r\n}\r\nstatic inline int blk_send_start_stop(struct request_queue *q,\r\nstruct gendisk *bd_disk, int data)\r\n{\r\nreturn __blk_send_generic(q, bd_disk, GPCMD_START_STOP_UNIT, data);\r\n}\r\nint scsi_cmd_ioctl(struct request_queue *q, struct gendisk *bd_disk, fmode_t mode,\r\nunsigned int cmd, void __user *arg)\r\n{\r\nint err;\r\nif (!q)\r\nreturn -ENXIO;\r\nswitch (cmd) {\r\ncase SG_GET_VERSION_NUM:\r\nerr = sg_get_version(arg);\r\nbreak;\r\ncase SCSI_IOCTL_GET_IDLUN:\r\nerr = scsi_get_idlun(q, arg);\r\nbreak;\r\ncase SCSI_IOCTL_GET_BUS_NUMBER:\r\nerr = scsi_get_bus(q, arg);\r\nbreak;\r\ncase SG_SET_TIMEOUT:\r\nerr = sg_set_timeout(q, arg);\r\nbreak;\r\ncase SG_GET_TIMEOUT:\r\nerr = sg_get_timeout(q);\r\nbreak;\r\ncase SG_GET_RESERVED_SIZE:\r\nerr = sg_get_reserved_size(q, arg);\r\nbreak;\r\ncase SG_SET_RESERVED_SIZE:\r\nerr = sg_set_reserved_size(q, arg);\r\nbreak;\r\ncase SG_EMULATED_HOST:\r\nerr = sg_emulated_host(q, arg);\r\nbreak;\r\ncase SG_IO: {\r\nstruct sg_io_hdr hdr;\r\nerr = -EFAULT;\r\nif (copy_from_user(&hdr, arg, sizeof(hdr)))\r\nbreak;\r\nerr = sg_io(q, bd_disk, &hdr, mode);\r\nif (err == -EFAULT)\r\nbreak;\r\nif (copy_to_user(arg, &hdr, sizeof(hdr)))\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\ncase CDROM_SEND_PACKET: {\r\nstruct cdrom_generic_command cgc;\r\nstruct sg_io_hdr hdr;\r\nerr = -EFAULT;\r\nif (copy_from_user(&cgc, arg, sizeof(cgc)))\r\nbreak;\r\ncgc.timeout = clock_t_to_jiffies(cgc.timeout);\r\nmemset(&hdr, 0, sizeof(hdr));\r\nhdr.interface_id = 'S';\r\nhdr.cmd_len = sizeof(cgc.cmd);\r\nhdr.dxfer_len = cgc.buflen;\r\nerr = 0;\r\nswitch (cgc.data_direction) {\r\ncase CGC_DATA_UNKNOWN:\r\nhdr.dxfer_direction = SG_DXFER_UNKNOWN;\r\nbreak;\r\ncase CGC_DATA_WRITE:\r\nhdr.dxfer_direction = SG_DXFER_TO_DEV;\r\nbreak;\r\ncase CGC_DATA_READ:\r\nhdr.dxfer_direction = SG_DXFER_FROM_DEV;\r\nbreak;\r\ncase CGC_DATA_NONE:\r\nhdr.dxfer_direction = SG_DXFER_NONE;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nif (err)\r\nbreak;\r\nhdr.dxferp = cgc.buffer;\r\nhdr.sbp = cgc.sense;\r\nif (hdr.sbp)\r\nhdr.mx_sb_len = sizeof(struct request_sense);\r\nhdr.timeout = jiffies_to_msecs(cgc.timeout);\r\nhdr.cmdp = ((struct cdrom_generic_command __user*) arg)->cmd;\r\nhdr.cmd_len = sizeof(cgc.cmd);\r\nerr = sg_io(q, bd_disk, &hdr, mode);\r\nif (err == -EFAULT)\r\nbreak;\r\nif (hdr.status)\r\nerr = -EIO;\r\ncgc.stat = err;\r\ncgc.buflen = hdr.resid;\r\nif (copy_to_user(arg, &cgc, sizeof(cgc)))\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\ncase SCSI_IOCTL_SEND_COMMAND:\r\nprintk(KERN_WARNING "program %s is using a deprecated SCSI ioctl, please convert it to SG_IO\n", current->comm);\r\nerr = -EINVAL;\r\nif (!arg)\r\nbreak;\r\nerr = sg_scsi_ioctl(q, bd_disk, mode, arg);\r\nbreak;\r\ncase CDROMCLOSETRAY:\r\nerr = blk_send_start_stop(q, bd_disk, 0x03);\r\nbreak;\r\ncase CDROMEJECT:\r\nerr = blk_send_start_stop(q, bd_disk, 0x02);\r\nbreak;\r\ndefault:\r\nerr = -ENOTTY;\r\n}\r\nreturn err;\r\n}\r\nint scsi_verify_blk_ioctl(struct block_device *bd, unsigned int cmd)\r\n{\r\nif (bd && bd == bd->bd_contains)\r\nreturn 0;\r\nswitch (cmd) {\r\ncase SCSI_IOCTL_GET_IDLUN:\r\ncase SCSI_IOCTL_GET_BUS_NUMBER:\r\ncase SCSI_IOCTL_GET_PCI:\r\ncase SCSI_IOCTL_PROBE_HOST:\r\ncase SG_GET_VERSION_NUM:\r\ncase SG_SET_TIMEOUT:\r\ncase SG_GET_TIMEOUT:\r\ncase SG_GET_RESERVED_SIZE:\r\ncase SG_SET_RESERVED_SIZE:\r\ncase SG_EMULATED_HOST:\r\nreturn 0;\r\ncase CDROM_GET_CAPABILITY:\r\nreturn -ENOIOCTLCMD;\r\ndefault:\r\nbreak;\r\n}\r\nprintk_ratelimited(KERN_WARNING\r\n"%s: sending ioctl %x to a partition!\n", current->comm, cmd);\r\nreturn capable(CAP_SYS_RAWIO) ? 0 : -ENOIOCTLCMD;\r\n}\r\nint scsi_cmd_blk_ioctl(struct block_device *bd, fmode_t mode,\r\nunsigned int cmd, void __user *arg)\r\n{\r\nint ret;\r\nret = scsi_verify_blk_ioctl(bd, cmd);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn scsi_cmd_ioctl(bd->bd_disk->queue, bd->bd_disk, mode, cmd, arg);\r\n}\r\nstatic int __init blk_scsi_ioctl_init(void)\r\n{\r\nblk_set_cmd_filter_defaults(&blk_default_cmd_filter);\r\nreturn 0;\r\n}
