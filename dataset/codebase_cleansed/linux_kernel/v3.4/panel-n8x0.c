static inline\r\nstruct panel_n8x0_data *get_board_data(const struct omap_dss_device *dssdev)\r\n{\r\nreturn dssdev->data;\r\n}\r\nstatic inline\r\nstruct panel_drv_data *get_drv_data(const struct omap_dss_device *dssdev)\r\n{\r\nreturn &s_drv_data;\r\n}\r\nstatic inline void blizzard_cmd(u8 cmd)\r\n{\r\nomap_rfbi_write_command(&cmd, 1);\r\n}\r\nstatic inline void blizzard_write(u8 cmd, const u8 *buf, int len)\r\n{\r\nomap_rfbi_write_command(&cmd, 1);\r\nomap_rfbi_write_data(buf, len);\r\n}\r\nstatic inline void blizzard_read(u8 cmd, u8 *buf, int len)\r\n{\r\nomap_rfbi_write_command(&cmd, 1);\r\nomap_rfbi_read_data(buf, len);\r\n}\r\nstatic u8 blizzard_read_reg(u8 cmd)\r\n{\r\nu8 data;\r\nblizzard_read(cmd, &data, 1);\r\nreturn data;\r\n}\r\nstatic void blizzard_ctrl_setup_update(struct omap_dss_device *dssdev,\r\nint x, int y, int w, int h)\r\n{\r\nstruct panel_drv_data *ddata = get_drv_data(dssdev);\r\nu8 tmp[18];\r\nint x_end, y_end;\r\nx_end = x + w - 1;\r\ny_end = y + h - 1;\r\ntmp[0] = x;\r\ntmp[1] = x >> 8;\r\ntmp[2] = y;\r\ntmp[3] = y >> 8;\r\ntmp[4] = x_end;\r\ntmp[5] = x_end >> 8;\r\ntmp[6] = y_end;\r\ntmp[7] = y_end >> 8;\r\ntmp[8] = x;\r\ntmp[9] = x >> 8;\r\ntmp[10] = y;\r\ntmp[11] = y >> 8;\r\ntmp[12] = x_end;\r\ntmp[13] = x_end >> 8;\r\ntmp[14] = y_end;\r\ntmp[15] = y_end >> 8;\r\ntmp[16] = BLIZZARD_COLOR_RGB565;\r\nif (ddata->blizzard_ver == BLIZZARD_VERSION_S1D13745)\r\ntmp[17] = BLIZZARD_SRC_WRITE_LCD_BACKGROUND;\r\nelse\r\ntmp[17] = ddata->blizzard_ver == BLIZZARD_VERSION_S1D13744 ?\r\nBLIZZARD_SRC_WRITE_LCD :\r\nBLIZZARD_SRC_WRITE_LCD_DESTRUCTIVE;\r\nomap_rfbi_configure(dssdev, 16, 8);\r\nblizzard_write(BLIZZARD_INPUT_WIN_X_START_0, tmp, 18);\r\nomap_rfbi_configure(dssdev, 16, 16);\r\n}\r\nstatic void mipid_transfer(struct spi_device *spi, int cmd, const u8 *wbuf,\r\nint wlen, u8 *rbuf, int rlen)\r\n{\r\nstruct spi_message m;\r\nstruct spi_transfer *x, xfer[4];\r\nu16 w;\r\nint r;\r\nspi_message_init(&m);\r\nmemset(xfer, 0, sizeof(xfer));\r\nx = &xfer[0];\r\ncmd &= 0xff;\r\nx->tx_buf = &cmd;\r\nx->bits_per_word = 9;\r\nx->len = 2;\r\nspi_message_add_tail(x, &m);\r\nif (wlen) {\r\nx++;\r\nx->tx_buf = wbuf;\r\nx->len = wlen;\r\nx->bits_per_word = 9;\r\nspi_message_add_tail(x, &m);\r\n}\r\nif (rlen) {\r\nx++;\r\nx->rx_buf = &w;\r\nx->len = 1;\r\nspi_message_add_tail(x, &m);\r\nif (rlen > 1) {\r\nx->bits_per_word = 9;\r\nx->len = 2;\r\nx++;\r\nx->rx_buf = &rbuf[1];\r\nx->len = rlen - 1;\r\nspi_message_add_tail(x, &m);\r\n}\r\n}\r\nr = spi_sync(spi, &m);\r\nif (r < 0)\r\ndev_dbg(&spi->dev, "spi_sync %d\n", r);\r\nif (rlen)\r\nrbuf[0] = w & 0xff;\r\n}\r\nstatic inline void mipid_cmd(struct spi_device *spi, int cmd)\r\n{\r\nmipid_transfer(spi, cmd, NULL, 0, NULL, 0);\r\n}\r\nstatic inline void mipid_write(struct spi_device *spi,\r\nint reg, const u8 *buf, int len)\r\n{\r\nmipid_transfer(spi, reg, buf, len, NULL, 0);\r\n}\r\nstatic inline void mipid_read(struct spi_device *spi,\r\nint reg, u8 *buf, int len)\r\n{\r\nmipid_transfer(spi, reg, NULL, 0, buf, len);\r\n}\r\nstatic void set_data_lines(struct spi_device *spi, int data_lines)\r\n{\r\nu16 par;\r\nswitch (data_lines) {\r\ncase 16:\r\npar = 0x150;\r\nbreak;\r\ncase 18:\r\npar = 0x160;\r\nbreak;\r\ncase 24:\r\npar = 0x170;\r\nbreak;\r\n}\r\nmipid_write(spi, 0x3a, (u8 *)&par, 2);\r\n}\r\nstatic void send_init_string(struct spi_device *spi)\r\n{\r\nu16 initpar[] = { 0x0102, 0x0100, 0x0100 };\r\nmipid_write(spi, 0xc2, (u8 *)initpar, sizeof(initpar));\r\n}\r\nstatic void send_display_on(struct spi_device *spi)\r\n{\r\nmipid_cmd(spi, MIPID_CMD_DISP_ON);\r\n}\r\nstatic void send_display_off(struct spi_device *spi)\r\n{\r\nmipid_cmd(spi, MIPID_CMD_DISP_OFF);\r\n}\r\nstatic void send_sleep_out(struct spi_device *spi)\r\n{\r\nmipid_cmd(spi, MIPID_CMD_SLEEP_OUT);\r\nmsleep(120);\r\n}\r\nstatic void send_sleep_in(struct spi_device *spi)\r\n{\r\nmipid_cmd(spi, MIPID_CMD_SLEEP_IN);\r\nmsleep(50);\r\n}\r\nstatic int n8x0_panel_power_on(struct omap_dss_device *dssdev)\r\n{\r\nint r;\r\nstruct panel_n8x0_data *bdata = get_board_data(dssdev);\r\nstruct panel_drv_data *ddata = get_drv_data(dssdev);\r\nstruct spi_device *spi = ddata->spidev;\r\nu8 rev, conf;\r\nu8 display_id[3];\r\nconst char *panel_name;\r\nif (dssdev->state == OMAP_DSS_DISPLAY_ACTIVE)\r\nreturn 0;\r\ngpio_direction_output(bdata->ctrl_pwrdown, 1);\r\nif (bdata->platform_enable) {\r\nr = bdata->platform_enable(dssdev);\r\nif (r)\r\ngoto err_plat_en;\r\n}\r\nr = omapdss_rfbi_display_enable(dssdev);\r\nif (r)\r\ngoto err_rfbi_en;\r\nrev = blizzard_read_reg(BLIZZARD_REV_CODE);\r\nconf = blizzard_read_reg(BLIZZARD_CONFIG);\r\nswitch (rev & 0xfc) {\r\ncase 0x9c:\r\nddata->blizzard_ver = BLIZZARD_VERSION_S1D13744;\r\ndev_info(&dssdev->dev, "s1d13744 LCD controller rev %d "\r\n"initialized (CNF pins %x)\n", rev & 0x03, conf & 0x07);\r\nbreak;\r\ncase 0xa4:\r\nddata->blizzard_ver = BLIZZARD_VERSION_S1D13745;\r\ndev_info(&dssdev->dev, "s1d13745 LCD controller rev %d "\r\n"initialized (CNF pins %x)\n", rev & 0x03, conf & 0x07);\r\nbreak;\r\ndefault:\r\ndev_err(&dssdev->dev, "invalid s1d1374x revision %02x\n", rev);\r\nr = -ENODEV;\r\ngoto err_inv_chip;\r\n}\r\ngpio_direction_output(bdata->panel_reset, 1);\r\nmipid_read(spi, MIPID_CMD_READ_DISP_ID, display_id, 3);\r\ndev_dbg(&spi->dev, "MIPI display ID: %02x%02x%02x\n",\r\ndisplay_id[0], display_id[1], display_id[2]);\r\nswitch (display_id[0]) {\r\ncase 0x45:\r\npanel_name = "lph8923";\r\nbreak;\r\ncase 0x83:\r\npanel_name = "ls041y3";\r\nbreak;\r\ndefault:\r\ndev_err(&dssdev->dev, "invalid display ID 0x%x\n",\r\ndisplay_id[0]);\r\nr = -ENODEV;\r\ngoto err_inv_panel;\r\n}\r\ndev_info(&dssdev->dev, "%s rev %02x LCD detected\n",\r\npanel_name, display_id[1]);\r\nsend_sleep_out(spi);\r\nsend_init_string(spi);\r\nset_data_lines(spi, 24);\r\nsend_display_on(spi);\r\nreturn 0;\r\nerr_inv_panel:\r\nerr_inv_chip:\r\nomapdss_rfbi_display_disable(dssdev);\r\nerr_rfbi_en:\r\nif (bdata->platform_disable)\r\nbdata->platform_disable(dssdev);\r\nerr_plat_en:\r\ngpio_direction_output(bdata->ctrl_pwrdown, 0);\r\nreturn r;\r\n}\r\nstatic void n8x0_panel_power_off(struct omap_dss_device *dssdev)\r\n{\r\nstruct panel_n8x0_data *bdata = get_board_data(dssdev);\r\nstruct panel_drv_data *ddata = get_drv_data(dssdev);\r\nstruct spi_device *spi = ddata->spidev;\r\nif (dssdev->state != OMAP_DSS_DISPLAY_ACTIVE)\r\nreturn;\r\nsend_display_off(spi);\r\nsend_sleep_in(spi);\r\nif (bdata->platform_disable)\r\nbdata->platform_disable(dssdev);\r\ngpio_direction_output(bdata->ctrl_pwrdown, 0);\r\nomapdss_rfbi_display_disable(dssdev);\r\n}\r\nstatic int n8x0_bl_update_status(struct backlight_device *dev)\r\n{\r\nstruct omap_dss_device *dssdev = dev_get_drvdata(&dev->dev);\r\nstruct panel_n8x0_data *bdata = get_board_data(dssdev);\r\nstruct panel_drv_data *ddata = get_drv_data(dssdev);\r\nint r;\r\nint level;\r\nmutex_lock(&ddata->lock);\r\nif (dev->props.fb_blank == FB_BLANK_UNBLANK &&\r\ndev->props.power == FB_BLANK_UNBLANK)\r\nlevel = dev->props.brightness;\r\nelse\r\nlevel = 0;\r\ndev_dbg(&dssdev->dev, "update brightness to %d\n", level);\r\nif (!bdata->set_backlight)\r\nr = -EINVAL;\r\nelse\r\nr = bdata->set_backlight(dssdev, level);\r\nmutex_unlock(&ddata->lock);\r\nreturn r;\r\n}\r\nstatic int n8x0_bl_get_intensity(struct backlight_device *dev)\r\n{\r\nif (dev->props.fb_blank == FB_BLANK_UNBLANK &&\r\ndev->props.power == FB_BLANK_UNBLANK)\r\nreturn dev->props.brightness;\r\nreturn 0;\r\n}\r\nstatic int n8x0_panel_probe(struct omap_dss_device *dssdev)\r\n{\r\nstruct panel_n8x0_data *bdata = get_board_data(dssdev);\r\nstruct panel_drv_data *ddata;\r\nstruct backlight_device *bldev;\r\nstruct backlight_properties props;\r\nint r;\r\ndev_dbg(&dssdev->dev, "probe\n");\r\nif (!bdata)\r\nreturn -EINVAL;\r\ns_drv_data.dssdev = dssdev;\r\nddata = &s_drv_data;\r\nmutex_init(&ddata->lock);\r\ndssdev->panel.config = OMAP_DSS_LCD_TFT;\r\ndssdev->panel.timings.x_res = 800;\r\ndssdev->panel.timings.y_res = 480;\r\ndssdev->ctrl.pixel_size = 16;\r\ndssdev->ctrl.rfbi_timings = n8x0_panel_timings;\r\nmemset(&props, 0, sizeof(props));\r\nprops.max_brightness = 127;\r\nprops.type = BACKLIGHT_PLATFORM;\r\nbldev = backlight_device_register(dev_name(&dssdev->dev), &dssdev->dev,\r\ndssdev, &n8x0_bl_ops, &props);\r\nif (IS_ERR(bldev)) {\r\nr = PTR_ERR(bldev);\r\ndev_err(&dssdev->dev, "register backlight failed\n");\r\nreturn r;\r\n}\r\nddata->bldev = bldev;\r\nbldev->props.fb_blank = FB_BLANK_UNBLANK;\r\nbldev->props.power = FB_BLANK_UNBLANK;\r\nbldev->props.brightness = 127;\r\nn8x0_bl_update_status(bldev);\r\nreturn 0;\r\n}\r\nstatic void n8x0_panel_remove(struct omap_dss_device *dssdev)\r\n{\r\nstruct panel_drv_data *ddata = get_drv_data(dssdev);\r\nstruct backlight_device *bldev;\r\ndev_dbg(&dssdev->dev, "remove\n");\r\nbldev = ddata->bldev;\r\nbldev->props.power = FB_BLANK_POWERDOWN;\r\nn8x0_bl_update_status(bldev);\r\nbacklight_device_unregister(bldev);\r\ndev_set_drvdata(&dssdev->dev, NULL);\r\n}\r\nstatic int n8x0_panel_enable(struct omap_dss_device *dssdev)\r\n{\r\nstruct panel_drv_data *ddata = get_drv_data(dssdev);\r\nint r;\r\ndev_dbg(&dssdev->dev, "enable\n");\r\nmutex_lock(&ddata->lock);\r\nrfbi_bus_lock();\r\nr = n8x0_panel_power_on(dssdev);\r\nrfbi_bus_unlock();\r\nif (r) {\r\nmutex_unlock(&ddata->lock);\r\nreturn r;\r\n}\r\ndssdev->state = OMAP_DSS_DISPLAY_ACTIVE;\r\nmutex_unlock(&ddata->lock);\r\nreturn 0;\r\n}\r\nstatic void n8x0_panel_disable(struct omap_dss_device *dssdev)\r\n{\r\nstruct panel_drv_data *ddata = get_drv_data(dssdev);\r\ndev_dbg(&dssdev->dev, "disable\n");\r\nmutex_lock(&ddata->lock);\r\nrfbi_bus_lock();\r\nn8x0_panel_power_off(dssdev);\r\nrfbi_bus_unlock();\r\ndssdev->state = OMAP_DSS_DISPLAY_DISABLED;\r\nmutex_unlock(&ddata->lock);\r\n}\r\nstatic int n8x0_panel_suspend(struct omap_dss_device *dssdev)\r\n{\r\nstruct panel_drv_data *ddata = get_drv_data(dssdev);\r\ndev_dbg(&dssdev->dev, "suspend\n");\r\nmutex_lock(&ddata->lock);\r\nrfbi_bus_lock();\r\nn8x0_panel_power_off(dssdev);\r\nrfbi_bus_unlock();\r\ndssdev->state = OMAP_DSS_DISPLAY_SUSPENDED;\r\nmutex_unlock(&ddata->lock);\r\nreturn 0;\r\n}\r\nstatic int n8x0_panel_resume(struct omap_dss_device *dssdev)\r\n{\r\nstruct panel_drv_data *ddata = get_drv_data(dssdev);\r\nint r;\r\ndev_dbg(&dssdev->dev, "resume\n");\r\nmutex_lock(&ddata->lock);\r\nrfbi_bus_lock();\r\nr = n8x0_panel_power_on(dssdev);\r\nrfbi_bus_unlock();\r\nif (r) {\r\nmutex_unlock(&ddata->lock);\r\nreturn r;\r\n}\r\ndssdev->state = OMAP_DSS_DISPLAY_ACTIVE;\r\nmutex_unlock(&ddata->lock);\r\nreturn 0;\r\n}\r\nstatic void n8x0_panel_get_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\n*timings = dssdev->panel.timings;\r\n}\r\nstatic void n8x0_panel_get_resolution(struct omap_dss_device *dssdev,\r\nu16 *xres, u16 *yres)\r\n{\r\n*xres = dssdev->panel.timings.x_res;\r\n*yres = dssdev->panel.timings.y_res;\r\n}\r\nstatic void update_done(void *data)\r\n{\r\nrfbi_bus_unlock();\r\n}\r\nstatic int n8x0_panel_update(struct omap_dss_device *dssdev,\r\nu16 x, u16 y, u16 w, u16 h)\r\n{\r\nstruct panel_drv_data *ddata = get_drv_data(dssdev);\r\ndev_dbg(&dssdev->dev, "update\n");\r\nmutex_lock(&ddata->lock);\r\nrfbi_bus_lock();\r\nomap_rfbi_prepare_update(dssdev, &x, &y, &w, &h);\r\nblizzard_ctrl_setup_update(dssdev, x, y, w, h);\r\nomap_rfbi_update(dssdev, x, y, w, h, update_done, NULL);\r\nmutex_unlock(&ddata->lock);\r\nreturn 0;\r\n}\r\nstatic int n8x0_panel_sync(struct omap_dss_device *dssdev)\r\n{\r\nstruct panel_drv_data *ddata = get_drv_data(dssdev);\r\ndev_dbg(&dssdev->dev, "sync\n");\r\nmutex_lock(&ddata->lock);\r\nrfbi_bus_lock();\r\nrfbi_bus_unlock();\r\nmutex_unlock(&ddata->lock);\r\nreturn 0;\r\n}\r\nstatic int mipid_spi_probe(struct spi_device *spi)\r\n{\r\ndev_dbg(&spi->dev, "mipid_spi_probe\n");\r\nspi->mode = SPI_MODE_0;\r\ns_drv_data.spidev = spi;\r\nreturn 0;\r\n}\r\nstatic int mipid_spi_remove(struct spi_device *spi)\r\n{\r\ndev_dbg(&spi->dev, "mipid_spi_remove\n");\r\nreturn 0;\r\n}\r\nstatic int __init n8x0_panel_drv_init(void)\r\n{\r\nint r;\r\nr = spi_register_driver(&mipid_spi_driver);\r\nif (r) {\r\npr_err("n8x0_panel: spi driver registration failed\n");\r\nreturn r;\r\n}\r\nr = omap_dss_register_driver(&n8x0_panel_driver);\r\nif (r) {\r\npr_err("n8x0_panel: dss driver registration failed\n");\r\nspi_unregister_driver(&mipid_spi_driver);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit n8x0_panel_drv_exit(void)\r\n{\r\nspi_unregister_driver(&mipid_spi_driver);\r\nomap_dss_unregister_driver(&n8x0_panel_driver);\r\n}
