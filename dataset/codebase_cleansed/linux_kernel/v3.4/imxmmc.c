static void imxmci_stop_clock(struct imxmci_host *host)\r\n{\r\nint i = 0;\r\nu16 reg;\r\nreg = readw(host->base + MMC_REG_STR_STP_CLK);\r\nwritew(reg & ~STR_STP_CLK_START_CLK, host->base + MMC_REG_STR_STP_CLK);\r\nwhile (i < 0x1000) {\r\nif (!(i & 0x7f)) {\r\nreg = readw(host->base + MMC_REG_STR_STP_CLK);\r\nwritew(reg | STR_STP_CLK_STOP_CLK,\r\nhost->base + MMC_REG_STR_STP_CLK);\r\n}\r\nreg = readw(host->base + MMC_REG_STATUS);\r\nif (!(reg & STATUS_CARD_BUS_CLK_RUN)) {\r\nreg = readw(host->base + MMC_REG_STATUS);\r\nif (!(reg & STATUS_CARD_BUS_CLK_RUN))\r\nreturn;\r\n}\r\ni++;\r\n}\r\ndev_dbg(mmc_dev(host->mmc), "imxmci_stop_clock blocked, no luck\n");\r\n}\r\nstatic int imxmci_start_clock(struct imxmci_host *host)\r\n{\r\nunsigned int trials = 0;\r\nunsigned int delay_limit = 128;\r\nunsigned long flags;\r\nu16 reg;\r\nreg = readw(host->base + MMC_REG_STR_STP_CLK);\r\nwritew(reg & ~STR_STP_CLK_STOP_CLK, host->base + MMC_REG_STR_STP_CLK);\r\nclear_bit(IMXMCI_PEND_STARTED_b, &host->pending_events);\r\nreg = readw(host->base + MMC_REG_STR_STP_CLK);\r\nwritew(reg | STR_STP_CLK_START_CLK, host->base + MMC_REG_STR_STP_CLK);\r\ndo {\r\nunsigned int delay = delay_limit;\r\nwhile (delay--) {\r\nreg = readw(host->base + MMC_REG_STATUS);\r\nif (reg & STATUS_CARD_BUS_CLK_RUN) {\r\nreg = readw(host->base + MMC_REG_STATUS);\r\nif (reg & STATUS_CARD_BUS_CLK_RUN)\r\nreturn 0;\r\n}\r\nif (test_bit(IMXMCI_PEND_STARTED_b, &host->pending_events))\r\nreturn 0;\r\n}\r\nlocal_irq_save(flags);\r\nif (!test_bit(IMXMCI_PEND_STARTED_b, &host->pending_events)) {\r\nreg = readw(host->base + MMC_REG_STR_STP_CLK);\r\nwritew(reg | STR_STP_CLK_START_CLK,\r\nhost->base + MMC_REG_STR_STP_CLK);\r\n}\r\nlocal_irq_restore(flags);\r\n} while (++trials < 256);\r\ndev_err(mmc_dev(host->mmc), "imxmci_start_clock blocked, no luck\n");\r\nreturn -1;\r\n}\r\nstatic void imxmci_softreset(struct imxmci_host *host)\r\n{\r\nint i;\r\nwritew(0x08, host->base + MMC_REG_STR_STP_CLK);\r\nwritew(0x0D, host->base + MMC_REG_STR_STP_CLK);\r\nfor (i = 0; i < 8; i++)\r\nwritew(0x05, host->base + MMC_REG_STR_STP_CLK);\r\nwritew(0xff, host->base + MMC_REG_RES_TO);\r\nwritew(512, host->base + MMC_REG_BLK_LEN);\r\nwritew(1, host->base + MMC_REG_NOB);\r\n}\r\nstatic int imxmci_busy_wait_for_status(struct imxmci_host *host,\r\nunsigned int *pstat, unsigned int stat_mask,\r\nint timeout, const char *where)\r\n{\r\nint loops = 0;\r\nwhile (!(*pstat & stat_mask)) {\r\nloops += 2;\r\nif (loops >= timeout) {\r\ndev_dbg(mmc_dev(host->mmc), "busy wait timeout in %s, STATUS = 0x%x (0x%x)\n",\r\nwhere, *pstat, stat_mask);\r\nreturn -1;\r\n}\r\nudelay(2);\r\n*pstat |= readw(host->base + MMC_REG_STATUS);\r\n}\r\nif (!loops)\r\nreturn 0;\r\nif (!(stat_mask & STATUS_END_CMD_RESP) || (host->mmc->ios.clock >= 8000000))\r\ndev_info(mmc_dev(host->mmc), "busy wait for %d usec in %s, STATUS = 0x%x (0x%x)\n",\r\nloops, where, *pstat, stat_mask);\r\nreturn loops;\r\n}\r\nstatic void imxmci_setup_data(struct imxmci_host *host, struct mmc_data *data)\r\n{\r\nunsigned int nob = data->blocks;\r\nunsigned int blksz = data->blksz;\r\nunsigned int datasz = nob * blksz;\r\nint i;\r\nif (data->flags & MMC_DATA_STREAM)\r\nnob = 0xffff;\r\nhost->data = data;\r\ndata->bytes_xfered = 0;\r\nwritew(nob, host->base + MMC_REG_NOB);\r\nwritew(blksz, host->base + MMC_REG_BLK_LEN);\r\nif (datasz < 512) {\r\nhost->dma_size = datasz;\r\nif (data->flags & MMC_DATA_READ) {\r\nhost->dma_dir = DMA_FROM_DEVICE;\r\nwritew(1, host->base + MMC_REG_NOB);\r\nwritew(512, host->base + MMC_REG_BLK_LEN);\r\n} else {\r\nhost->dma_dir = DMA_TO_DEVICE;\r\n}\r\nhost->data_ptr = (u16 *)sg_virt(data->sg);\r\nhost->data_cnt = 0;\r\nclear_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events);\r\nset_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events);\r\nreturn;\r\n}\r\nif (data->flags & MMC_DATA_READ) {\r\nhost->dma_dir = DMA_FROM_DEVICE;\r\nhost->dma_nents = dma_map_sg(mmc_dev(host->mmc), data->sg,\r\ndata->sg_len, host->dma_dir);\r\nimx_dma_setup_sg(host->dma, data->sg, data->sg_len, datasz,\r\nhost->res->start + MMC_REG_BUFFER_ACCESS,\r\nDMA_MODE_READ);\r\nCCR(host->dma) = CCR_DMOD_LINEAR | CCR_DSIZ_32 | CCR_SMOD_FIFO | CCR_SSIZ_16 | CCR_REN;\r\n} else {\r\nhost->dma_dir = DMA_TO_DEVICE;\r\nhost->dma_nents = dma_map_sg(mmc_dev(host->mmc), data->sg,\r\ndata->sg_len, host->dma_dir);\r\nimx_dma_setup_sg(host->dma, data->sg, data->sg_len, datasz,\r\nhost->res->start + MMC_REG_BUFFER_ACCESS,\r\nDMA_MODE_WRITE);\r\nCCR(host->dma) = CCR_SMOD_LINEAR | CCR_SSIZ_32 | CCR_DMOD_FIFO | CCR_DSIZ_16 | CCR_REN;\r\n}\r\n#if 1\r\nhost->dma_size = 0;\r\nfor (i = 0; i < host->dma_nents; i++)\r\nhost->dma_size += data->sg[i].length;\r\nif (datasz > host->dma_size) {\r\ndev_err(mmc_dev(host->mmc), "imxmci_setup_data datasz 0x%x > 0x%x dm_size\n",\r\ndatasz, host->dma_size);\r\n}\r\n#endif\r\nhost->dma_size = datasz;\r\nwmb();\r\nset_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events);\r\nclear_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events);\r\nif (host->dma_dir == DMA_FROM_DEVICE)\r\nimx_dma_enable(host->dma);\r\n}\r\nstatic void imxmci_start_cmd(struct imxmci_host *host, struct mmc_command *cmd, unsigned int cmdat)\r\n{\r\nunsigned long flags;\r\nu32 imask;\r\nWARN_ON(host->cmd != NULL);\r\nhost->cmd = cmd;\r\nimxmci_stop_clock(host);\r\nif (cmd->flags & MMC_RSP_BUSY)\r\ncmdat |= CMD_DAT_CONT_BUSY;\r\nswitch (mmc_resp_type(cmd)) {\r\ncase MMC_RSP_R1:\r\ncase MMC_RSP_R1B:\r\ncmdat |= CMD_DAT_CONT_RESPONSE_FORMAT_R1;\r\nbreak;\r\ncase MMC_RSP_R2:\r\ncmdat |= CMD_DAT_CONT_RESPONSE_FORMAT_R2;\r\nbreak;\r\ncase MMC_RSP_R3:\r\ncmdat |= CMD_DAT_CONT_RESPONSE_FORMAT_R3;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (test_and_clear_bit(IMXMCI_PEND_SET_INIT_b, &host->pending_events))\r\ncmdat |= CMD_DAT_CONT_INIT;\r\nif (host->actual_bus_width == MMC_BUS_WIDTH_4)\r\ncmdat |= CMD_DAT_CONT_BUS_WIDTH_4;\r\nwritew(cmd->opcode, host->base + MMC_REG_CMD);\r\nwritew(cmd->arg >> 16, host->base + MMC_REG_ARGH);\r\nwritew(cmd->arg & 0xffff, host->base + MMC_REG_ARGL);\r\nwritew(cmdat, host->base + MMC_REG_CMD_DAT_CONT);\r\natomic_set(&host->stuck_timeout, 0);\r\nset_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events);\r\nimask = IMXMCI_INT_MASK_DEFAULT;\r\nimask &= ~INT_MASK_END_CMD_RES;\r\nif (cmdat & CMD_DAT_CONT_DATA_ENABLE) {\r\nimask &= ~INT_MASK_DATA_TRAN;\r\nif (cmdat & CMD_DAT_CONT_WRITE)\r\nimask &= ~INT_MASK_WRITE_OP_DONE;\r\nif (test_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events))\r\nimask &= ~INT_MASK_BUF_READY;\r\n}\r\nspin_lock_irqsave(&host->lock, flags);\r\nhost->imask = imask;\r\nwritew(host->imask, host->base + MMC_REG_INT_MASK);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\ndev_dbg(mmc_dev(host->mmc), "CMD%02d (0x%02x) mask set to 0x%04x\n",\r\ncmd->opcode, cmd->opcode, imask);\r\nimxmci_start_clock(host);\r\n}\r\nstatic void imxmci_finish_request(struct imxmci_host *host, struct mmc_request *req)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\nhost->pending_events &= ~(IMXMCI_PEND_WAIT_RESP_m | IMXMCI_PEND_DMA_END_m |\r\nIMXMCI_PEND_DMA_DATA_m | IMXMCI_PEND_CPU_DATA_m);\r\nhost->imask = IMXMCI_INT_MASK_DEFAULT;\r\nwritew(host->imask, host->base + MMC_REG_INT_MASK);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nif (req && req->cmd)\r\nhost->prev_cmd_code = req->cmd->opcode;\r\nhost->req = NULL;\r\nhost->cmd = NULL;\r\nhost->data = NULL;\r\nmmc_request_done(host->mmc, req);\r\n}\r\nstatic int imxmci_finish_data(struct imxmci_host *host, unsigned int stat)\r\n{\r\nstruct mmc_data *data = host->data;\r\nint data_error;\r\nif (test_and_clear_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events)) {\r\nimx_dma_disable(host->dma);\r\ndma_unmap_sg(mmc_dev(host->mmc), data->sg, host->dma_nents,\r\nhost->dma_dir);\r\n}\r\nif (stat & STATUS_ERR_MASK) {\r\ndev_dbg(mmc_dev(host->mmc), "request failed. status: 0x%08x\n", stat);\r\nif (stat & (STATUS_CRC_READ_ERR | STATUS_CRC_WRITE_ERR))\r\ndata->error = -EILSEQ;\r\nelse if (stat & STATUS_TIME_OUT_READ)\r\ndata->error = -ETIMEDOUT;\r\nelse\r\ndata->error = -EIO;\r\n} else {\r\ndata->bytes_xfered = host->dma_size;\r\n}\r\ndata_error = data->error;\r\nhost->data = NULL;\r\nreturn data_error;\r\n}\r\nstatic int imxmci_cmd_done(struct imxmci_host *host, unsigned int stat)\r\n{\r\nstruct mmc_command *cmd = host->cmd;\r\nint i;\r\nu32 a, b, c;\r\nstruct mmc_data *data = host->data;\r\nif (!cmd)\r\nreturn 0;\r\nhost->cmd = NULL;\r\nif (stat & STATUS_TIME_OUT_RESP) {\r\ndev_dbg(mmc_dev(host->mmc), "CMD TIMEOUT\n");\r\ncmd->error = -ETIMEDOUT;\r\n} else if (stat & STATUS_RESP_CRC_ERR && cmd->flags & MMC_RSP_CRC) {\r\ndev_dbg(mmc_dev(host->mmc), "cmd crc error\n");\r\ncmd->error = -EILSEQ;\r\n}\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\nif (cmd->flags & MMC_RSP_136) {\r\nfor (i = 0; i < 4; i++) {\r\na = readw(host->base + MMC_REG_RES_FIFO);\r\nb = readw(host->base + MMC_REG_RES_FIFO);\r\ncmd->resp[i] = a << 16 | b;\r\n}\r\n} else {\r\na = readw(host->base + MMC_REG_RES_FIFO);\r\nb = readw(host->base + MMC_REG_RES_FIFO);\r\nc = readw(host->base + MMC_REG_RES_FIFO);\r\ncmd->resp[0] = a << 24 | b << 8 | c >> 8;\r\n}\r\n}\r\ndev_dbg(mmc_dev(host->mmc), "RESP 0x%08x, 0x%08x, 0x%08x, 0x%08x, error %d\n",\r\ncmd->resp[0], cmd->resp[1], cmd->resp[2], cmd->resp[3], cmd->error);\r\nif (data && !cmd->error && !(stat & STATUS_ERR_MASK)) {\r\nif (host->req->data->flags & MMC_DATA_WRITE) {\r\nstat = readw(host->base + MMC_REG_STATUS);\r\nif (imxmci_busy_wait_for_status(host, &stat,\r\nSTATUS_APPL_BUFF_FE,\r\n40, "imxmci_cmd_done DMA WR") < 0) {\r\ncmd->error = -EIO;\r\nimxmci_finish_data(host, stat);\r\nif (host->req)\r\nimxmci_finish_request(host, host->req);\r\ndev_warn(mmc_dev(host->mmc), "STATUS = 0x%04x\n",\r\nstat);\r\nreturn 0;\r\n}\r\nif (test_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events))\r\nimx_dma_enable(host->dma);\r\n}\r\n} else {\r\nstruct mmc_request *req;\r\nimxmci_stop_clock(host);\r\nreq = host->req;\r\nif (data)\r\nimxmci_finish_data(host, stat);\r\nif (req)\r\nimxmci_finish_request(host, req);\r\nelse\r\ndev_warn(mmc_dev(host->mmc), "imxmci_cmd_done: no request to finish\n");\r\n}\r\nreturn 1;\r\n}\r\nstatic int imxmci_data_done(struct imxmci_host *host, unsigned int stat)\r\n{\r\nstruct mmc_data *data = host->data;\r\nint data_error;\r\nif (!data)\r\nreturn 0;\r\ndata_error = imxmci_finish_data(host, stat);\r\nif (host->req->stop) {\r\nimxmci_stop_clock(host);\r\nimxmci_start_cmd(host, host->req->stop, 0);\r\n} else {\r\nstruct mmc_request *req;\r\nreq = host->req;\r\nif (req)\r\nimxmci_finish_request(host, req);\r\nelse\r\ndev_warn(mmc_dev(host->mmc), "imxmci_data_done: no request to finish\n");\r\n}\r\nreturn 1;\r\n}\r\nstatic int imxmci_cpu_driven_data(struct imxmci_host *host, unsigned int *pstat)\r\n{\r\nint i;\r\nint burst_len;\r\nint trans_done = 0;\r\nunsigned int stat = *pstat;\r\nif (host->actual_bus_width != MMC_BUS_WIDTH_4)\r\nburst_len = 16;\r\nelse\r\nburst_len = 64;\r\ndev_dbg(mmc_dev(host->mmc), "imxmci_cpu_driven_data running STATUS = 0x%x\n",\r\nstat);\r\nudelay(20);\r\nif (host->dma_dir == DMA_FROM_DEVICE) {\r\nimxmci_busy_wait_for_status(host, &stat,\r\nSTATUS_APPL_BUFF_FF | STATUS_DATA_TRANS_DONE |\r\nSTATUS_TIME_OUT_READ,\r\n50, "imxmci_cpu_driven_data read");\r\nwhile ((stat & (STATUS_APPL_BUFF_FF | STATUS_DATA_TRANS_DONE)) &&\r\n!(stat & STATUS_TIME_OUT_READ) &&\r\n(host->data_cnt < 512)) {\r\nudelay(20);\r\nfor (i = burst_len; i >= 2 ; i -= 2) {\r\nu16 data;\r\ndata = readw(host->base + MMC_REG_BUFFER_ACCESS);\r\nudelay(10);\r\nif (host->data_cnt+2 <= host->dma_size) {\r\n*(host->data_ptr++) = data;\r\n} else {\r\nif (host->data_cnt < host->dma_size)\r\n*(u8 *)(host->data_ptr) = data;\r\n}\r\nhost->data_cnt += 2;\r\n}\r\nstat = readw(host->base + MMC_REG_STATUS);\r\ndev_dbg(mmc_dev(host->mmc), "imxmci_cpu_driven_data read %d burst %d STATUS = 0x%x\n",\r\nhost->data_cnt, burst_len, stat);\r\n}\r\nif ((stat & STATUS_DATA_TRANS_DONE) && (host->data_cnt >= 512))\r\ntrans_done = 1;\r\nif (host->dma_size & 0x1ff)\r\nstat &= ~STATUS_CRC_READ_ERR;\r\nif (stat & STATUS_TIME_OUT_READ) {\r\ndev_dbg(mmc_dev(host->mmc), "imxmci_cpu_driven_data read timeout STATUS = 0x%x\n",\r\nstat);\r\ntrans_done = -1;\r\n}\r\n} else {\r\nimxmci_busy_wait_for_status(host, &stat,\r\nSTATUS_APPL_BUFF_FE,\r\n20, "imxmci_cpu_driven_data write");\r\nwhile ((stat & STATUS_APPL_BUFF_FE) &&\r\n(host->data_cnt < host->dma_size)) {\r\nif (burst_len >= host->dma_size - host->data_cnt) {\r\nburst_len = host->dma_size - host->data_cnt;\r\nhost->data_cnt = host->dma_size;\r\ntrans_done = 1;\r\n} else {\r\nhost->data_cnt += burst_len;\r\n}\r\nfor (i = burst_len; i > 0 ; i -= 2)\r\nwritew(*(host->data_ptr++), host->base + MMC_REG_BUFFER_ACCESS);\r\nstat = readw(host->base + MMC_REG_STATUS);\r\ndev_dbg(mmc_dev(host->mmc), "imxmci_cpu_driven_data write burst %d STATUS = 0x%x\n",\r\nburst_len, stat);\r\n}\r\n}\r\n*pstat = stat;\r\nreturn trans_done;\r\n}\r\nstatic void imxmci_dma_irq(int dma, void *devid)\r\n{\r\nstruct imxmci_host *host = devid;\r\nu32 stat = readw(host->base + MMC_REG_STATUS);\r\natomic_set(&host->stuck_timeout, 0);\r\nhost->status_reg = stat;\r\nset_bit(IMXMCI_PEND_DMA_END_b, &host->pending_events);\r\ntasklet_schedule(&host->tasklet);\r\n}\r\nstatic irqreturn_t imxmci_irq(int irq, void *devid)\r\n{\r\nstruct imxmci_host *host = devid;\r\nu32 stat = readw(host->base + MMC_REG_STATUS);\r\nint handled = 1;\r\nwritew(host->imask | INT_MASK_SDIO | INT_MASK_AUTO_CARD_DETECT,\r\nhost->base + MMC_REG_INT_MASK);\r\natomic_set(&host->stuck_timeout, 0);\r\nhost->status_reg = stat;\r\nset_bit(IMXMCI_PEND_IRQ_b, &host->pending_events);\r\nset_bit(IMXMCI_PEND_STARTED_b, &host->pending_events);\r\ntasklet_schedule(&host->tasklet);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void imxmci_tasklet_fnc(unsigned long data)\r\n{\r\nstruct imxmci_host *host = (struct imxmci_host *)data;\r\nu32 stat;\r\nunsigned int data_dir_mask = 0;\r\nint timeout = 0;\r\nif (atomic_read(&host->stuck_timeout) > 4) {\r\nchar *what;\r\ntimeout = 1;\r\nstat = readw(host->base + MMC_REG_STATUS);\r\nhost->status_reg = stat;\r\nif (test_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events))\r\nif (test_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events))\r\nwhat = "RESP+DMA";\r\nelse\r\nwhat = "RESP";\r\nelse\r\nif (test_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events))\r\nif (test_bit(IMXMCI_PEND_DMA_END_b, &host->pending_events))\r\nwhat = "DATA";\r\nelse\r\nwhat = "DMA";\r\nelse\r\nwhat = "???";\r\ndev_err(mmc_dev(host->mmc),\r\n"%s TIMEOUT, hardware stucked STATUS = 0x%04x IMASK = 0x%04x\n",\r\nwhat, stat,\r\nreadw(host->base + MMC_REG_INT_MASK));\r\ndev_err(mmc_dev(host->mmc),\r\n"CMD_DAT_CONT = 0x%04x, MMC_BLK_LEN = 0x%04x, MMC_NOB = 0x%04x, DMA_CCR = 0x%08x\n",\r\nreadw(host->base + MMC_REG_CMD_DAT_CONT),\r\nreadw(host->base + MMC_REG_BLK_LEN),\r\nreadw(host->base + MMC_REG_NOB),\r\nCCR(host->dma));\r\ndev_err(mmc_dev(host->mmc), "CMD%d, prevCMD%d, bus %d-bit, dma_size = 0x%x\n",\r\nhost->cmd ? host->cmd->opcode : 0,\r\nhost->prev_cmd_code,\r\n1 << host->actual_bus_width, host->dma_size);\r\n}\r\nif (!host->present || timeout)\r\nhost->status_reg = STATUS_TIME_OUT_RESP | STATUS_TIME_OUT_READ |\r\nSTATUS_CRC_READ_ERR | STATUS_CRC_WRITE_ERR;\r\nif (test_bit(IMXMCI_PEND_IRQ_b, &host->pending_events) || timeout) {\r\nclear_bit(IMXMCI_PEND_IRQ_b, &host->pending_events);\r\nstat = readw(host->base + MMC_REG_STATUS);\r\nstat |= host->status_reg;\r\nif (test_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events))\r\nstat &= ~STATUS_CRC_READ_ERR;\r\nif (test_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events)) {\r\nimxmci_busy_wait_for_status(host, &stat,\r\nSTATUS_END_CMD_RESP | STATUS_ERR_MASK,\r\n20, "imxmci_tasklet_fnc resp (ERRATUM #4)");\r\n}\r\nif (stat & (STATUS_END_CMD_RESP | STATUS_ERR_MASK)) {\r\nif (test_and_clear_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events))\r\nimxmci_cmd_done(host, stat);\r\nif (host->data && (stat & STATUS_ERR_MASK))\r\nimxmci_data_done(host, stat);\r\n}\r\nif (test_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events)) {\r\nstat |= readw(host->base + MMC_REG_STATUS);\r\nif (imxmci_cpu_driven_data(host, &stat)) {\r\nif (test_and_clear_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events))\r\nimxmci_cmd_done(host, stat);\r\natomic_clear_mask(IMXMCI_PEND_IRQ_m|IMXMCI_PEND_CPU_DATA_m,\r\n&host->pending_events);\r\nimxmci_data_done(host, stat);\r\n}\r\n}\r\n}\r\nif (test_bit(IMXMCI_PEND_DMA_END_b, &host->pending_events) &&\r\n!test_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events)) {\r\nstat = readw(host->base + MMC_REG_STATUS);\r\nstat |= host->status_reg;\r\nif (host->dma_dir == DMA_TO_DEVICE)\r\ndata_dir_mask = STATUS_WRITE_OP_DONE;\r\nelse\r\ndata_dir_mask = STATUS_DATA_TRANS_DONE;\r\nif (stat & data_dir_mask) {\r\nclear_bit(IMXMCI_PEND_DMA_END_b, &host->pending_events);\r\nimxmci_data_done(host, stat);\r\n}\r\n}\r\nif (test_and_clear_bit(IMXMCI_PEND_CARD_XCHG_b, &host->pending_events)) {\r\nif (host->cmd)\r\nimxmci_cmd_done(host, STATUS_TIME_OUT_RESP);\r\nif (host->data)\r\nimxmci_data_done(host, STATUS_TIME_OUT_READ |\r\nSTATUS_CRC_READ_ERR | STATUS_CRC_WRITE_ERR);\r\nif (host->req)\r\nimxmci_finish_request(host, host->req);\r\nmmc_detect_change(host->mmc, msecs_to_jiffies(100));\r\n}\r\n}\r\nstatic void imxmci_request(struct mmc_host *mmc, struct mmc_request *req)\r\n{\r\nstruct imxmci_host *host = mmc_priv(mmc);\r\nunsigned int cmdat;\r\nWARN_ON(host->req != NULL);\r\nhost->req = req;\r\ncmdat = 0;\r\nif (req->data) {\r\nimxmci_setup_data(host, req->data);\r\ncmdat |= CMD_DAT_CONT_DATA_ENABLE;\r\nif (req->data->flags & MMC_DATA_WRITE)\r\ncmdat |= CMD_DAT_CONT_WRITE;\r\nif (req->data->flags & MMC_DATA_STREAM)\r\ncmdat |= CMD_DAT_CONT_STREAM_BLOCK;\r\n}\r\nimxmci_start_cmd(host, req->cmd, cmdat);\r\n}\r\nstatic void imxmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct imxmci_host *host = mmc_priv(mmc);\r\nint prescaler;\r\nif (ios->bus_width == MMC_BUS_WIDTH_4) {\r\nhost->actual_bus_width = MMC_BUS_WIDTH_4;\r\nimx_gpio_mode(PB11_PF_SD_DAT3);\r\nBLR(host->dma) = 0;\r\n} else {\r\nhost->actual_bus_width = MMC_BUS_WIDTH_1;\r\nimx_gpio_mode(GPIO_PORTB | GPIO_IN | GPIO_PUEN | 11);\r\nBLR(host->dma) = 16;\r\n}\r\nif (host->power_mode != ios->power_mode) {\r\nswitch (ios->power_mode) {\r\ncase MMC_POWER_OFF:\r\nbreak;\r\ncase MMC_POWER_UP:\r\nset_bit(IMXMCI_PEND_SET_INIT_b, &host->pending_events);\r\nbreak;\r\ncase MMC_POWER_ON:\r\nbreak;\r\n}\r\nhost->power_mode = ios->power_mode;\r\n}\r\nif (ios->clock) {\r\nunsigned int clk;\r\nu16 reg;\r\nclk = clk_get_rate(host->clk);\r\nprescaler = (clk + (CLK_RATE * 7) / 8) / CLK_RATE;\r\nswitch (prescaler) {\r\ncase 0:\r\ncase 1: prescaler = 0;\r\nbreak;\r\ncase 2: prescaler = 1;\r\nbreak;\r\ncase 3: prescaler = 2;\r\nbreak;\r\ncase 4: prescaler = 4;\r\nbreak;\r\ndefault:\r\ncase 5: prescaler = 5;\r\nbreak;\r\n}\r\ndev_dbg(mmc_dev(host->mmc), "PERCLK2 %d MHz -> prescaler %d\n",\r\nclk, prescaler);\r\nfor (clk = 0; clk < 8; clk++) {\r\nint x;\r\nx = CLK_RATE / (1 << clk);\r\nif (x <= ios->clock)\r\nbreak;\r\n}\r\nreg = readw(host->base + MMC_REG_STR_STP_CLK);\r\nwritew(reg | STR_STP_CLK_ENABLE,\r\nhost->base + MMC_REG_STR_STP_CLK);\r\nimxmci_stop_clock(host);\r\nwritew((prescaler << 3) | clk, host->base + MMC_REG_CLK_RATE);\r\ndev_dbg(mmc_dev(host->mmc),\r\n"MMC_CLK_RATE: 0x%08x\n",\r\nreadw(host->base + MMC_REG_CLK_RATE));\r\n} else {\r\nimxmci_stop_clock(host);\r\n}\r\n}\r\nstatic int imxmci_get_ro(struct mmc_host *mmc)\r\n{\r\nstruct imxmci_host *host = mmc_priv(mmc);\r\nif (host->pdata && host->pdata->get_ro)\r\nreturn !!host->pdata->get_ro(mmc_dev(mmc));\r\nreturn -ENOSYS;\r\n}\r\nstatic void imxmci_check_status(unsigned long data)\r\n{\r\nstruct imxmci_host *host = (struct imxmci_host *)data;\r\nif (host->pdata && host->pdata->card_present &&\r\nhost->pdata->card_present(mmc_dev(host->mmc)) != host->present) {\r\nhost->present ^= 1;\r\ndev_info(mmc_dev(host->mmc), "card %s\n",\r\nhost->present ? "inserted" : "removed");\r\nset_bit(IMXMCI_PEND_CARD_XCHG_b, &host->pending_events);\r\ntasklet_schedule(&host->tasklet);\r\n}\r\nif (test_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events) ||\r\ntest_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events)) {\r\natomic_inc(&host->stuck_timeout);\r\nif (atomic_read(&host->stuck_timeout) > 4)\r\ntasklet_schedule(&host->tasklet);\r\n} else {\r\natomic_set(&host->stuck_timeout, 0);\r\n}\r\nmod_timer(&host->timer, jiffies + (HZ>>1));\r\n}\r\nstatic int __init imxmci_probe(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc;\r\nstruct imxmci_host *host = NULL;\r\nstruct resource *r;\r\nint ret = 0, irq;\r\nu16 rev_no;\r\npr_info("i.MX mmc driver\n");\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!r || irq < 0)\r\nreturn -ENXIO;\r\nr = request_mem_region(r->start, resource_size(r), pdev->name);\r\nif (!r)\r\nreturn -EBUSY;\r\nmmc = mmc_alloc_host(sizeof(struct imxmci_host), &pdev->dev);\r\nif (!mmc) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmmc->ops = &imxmci_ops;\r\nmmc->f_min = 150000;\r\nmmc->f_max = CLK_RATE/2;\r\nmmc->ocr_avail = MMC_VDD_32_33;\r\nmmc->caps = MMC_CAP_4_BIT_DATA;\r\nmmc->max_segs = 64;\r\nmmc->max_seg_size = 64*512;\r\nmmc->max_req_size = 64*512;\r\nmmc->max_blk_size = 2048;\r\nmmc->max_blk_count = 65535;\r\nhost = mmc_priv(mmc);\r\nhost->base = ioremap(r->start, resource_size(r));\r\nif (!host->base) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nhost->mmc = mmc;\r\nhost->dma_allocated = 0;\r\nhost->pdata = pdev->dev.platform_data;\r\nif (!host->pdata)\r\ndev_warn(&pdev->dev, "No platform data provided!\n");\r\nspin_lock_init(&host->lock);\r\nhost->res = r;\r\nhost->irq = irq;\r\nhost->clk = clk_get(&pdev->dev, "perclk2");\r\nif (IS_ERR(host->clk)) {\r\nret = PTR_ERR(host->clk);\r\ngoto out;\r\n}\r\nclk_enable(host->clk);\r\nimx_gpio_mode(PB8_PF_SD_DAT0);\r\nimx_gpio_mode(PB9_PF_SD_DAT1);\r\nimx_gpio_mode(PB10_PF_SD_DAT2);\r\nimx_gpio_mode(GPIO_PORTB | GPIO_IN | GPIO_PUEN | 11);\r\nimx_gpio_mode(PB12_PF_SD_CLK);\r\nimx_gpio_mode(PB13_PF_SD_CMD);\r\nimxmci_softreset(host);\r\nrev_no = readw(host->base + MMC_REG_REV_NO);\r\nif (rev_no != 0x390) {\r\ndev_err(mmc_dev(host->mmc), "wrong rev.no. 0x%08x. aborting.\n",\r\nreadw(host->base + MMC_REG_REV_NO));\r\ngoto out;\r\n}\r\nwritew(0x2db4, host->base + MMC_REG_READ_TO);\r\nhost->imask = IMXMCI_INT_MASK_DEFAULT;\r\nwritew(host->imask, host->base + MMC_REG_INT_MASK);\r\nhost->dma = imx_dma_request_by_prio(DRIVER_NAME, DMA_PRIO_LOW);\r\nif(host->dma < 0) {\r\ndev_err(mmc_dev(host->mmc), "imx_dma_request_by_prio failed\n");\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nhost->dma_allocated = 1;\r\nimx_dma_setup_handlers(host->dma, imxmci_dma_irq, NULL, host);\r\nRSSR(host->dma) = DMA_REQ_SDHC;\r\ntasklet_init(&host->tasklet, imxmci_tasklet_fnc, (unsigned long)host);\r\nhost->status_reg=0;\r\nhost->pending_events=0;\r\nret = request_irq(host->irq, imxmci_irq, 0, DRIVER_NAME, host);\r\nif (ret)\r\ngoto out;\r\nif (host->pdata && host->pdata->card_present)\r\nhost->present = host->pdata->card_present(mmc_dev(mmc));\r\nelse\r\nhost->present = 1;\r\ninit_timer(&host->timer);\r\nhost->timer.data = (unsigned long)host;\r\nhost->timer.function = imxmci_check_status;\r\nadd_timer(&host->timer);\r\nmod_timer(&host->timer, jiffies + (HZ >> 1));\r\nplatform_set_drvdata(pdev, mmc);\r\nmmc_add_host(mmc);\r\nreturn 0;\r\nout:\r\nif (host) {\r\nif (host->dma_allocated) {\r\nimx_dma_free(host->dma);\r\nhost->dma_allocated = 0;\r\n}\r\nif (host->clk) {\r\nclk_disable(host->clk);\r\nclk_put(host->clk);\r\n}\r\nif (host->base)\r\niounmap(host->base);\r\n}\r\nif (mmc)\r\nmmc_free_host(mmc);\r\nrelease_mem_region(r->start, resource_size(r));\r\nreturn ret;\r\n}\r\nstatic int __exit imxmci_remove(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nif (mmc) {\r\nstruct imxmci_host *host = mmc_priv(mmc);\r\ntasklet_disable(&host->tasklet);\r\ndel_timer_sync(&host->timer);\r\nmmc_remove_host(mmc);\r\nfree_irq(host->irq, host);\r\niounmap(host->base);\r\nif (host->dma_allocated) {\r\nimx_dma_free(host->dma);\r\nhost->dma_allocated = 0;\r\n}\r\ntasklet_kill(&host->tasklet);\r\nclk_disable(host->clk);\r\nclk_put(host->clk);\r\nrelease_mem_region(host->res->start, resource_size(host->res));\r\nmmc_free_host(mmc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int imxmci_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(dev);\r\nint ret = 0;\r\nif (mmc)\r\nret = mmc_suspend_host(mmc);\r\nreturn ret;\r\n}\r\nstatic int imxmci_resume(struct platform_device *dev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(dev);\r\nstruct imxmci_host *host;\r\nint ret = 0;\r\nif (mmc) {\r\nhost = mmc_priv(mmc);\r\nif (host)\r\nset_bit(IMXMCI_PEND_SET_INIT_b, &host->pending_events);\r\nret = mmc_resume_host(mmc);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init imxmci_init(void)\r\n{\r\nreturn platform_driver_probe(&imxmci_driver, imxmci_probe);\r\n}\r\nstatic void __exit imxmci_exit(void)\r\n{\r\nplatform_driver_unregister(&imxmci_driver);\r\n}
