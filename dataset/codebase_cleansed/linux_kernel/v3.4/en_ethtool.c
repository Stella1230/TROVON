static void\r\nmlx4_en_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nstrlcpy(drvinfo->driver, DRV_NAME, sizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->version, DRV_VERSION " (" DRV_RELDATE ")",\r\nsizeof(drvinfo->version));\r\nsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\r\n"%d.%d.%d",\r\n(u16) (mdev->dev->caps.fw_ver >> 32),\r\n(u16) ((mdev->dev->caps.fw_ver >> 16) & 0xffff),\r\n(u16) (mdev->dev->caps.fw_ver & 0xffff));\r\nstrlcpy(drvinfo->bus_info, pci_name(mdev->dev->pdev),\r\nsizeof(drvinfo->bus_info));\r\ndrvinfo->n_stats = 0;\r\ndrvinfo->regdump_len = 0;\r\ndrvinfo->eedump_len = 0;\r\n}\r\nstatic u32 mlx4_en_get_msglevel(struct net_device *dev)\r\n{\r\nreturn ((struct mlx4_en_priv *) netdev_priv(dev))->msg_enable;\r\n}\r\nstatic void mlx4_en_set_msglevel(struct net_device *dev, u32 val)\r\n{\r\n((struct mlx4_en_priv *) netdev_priv(dev))->msg_enable = val;\r\n}\r\nstatic void mlx4_en_get_wol(struct net_device *netdev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(netdev);\r\nint err = 0;\r\nu64 config = 0;\r\nu64 mask;\r\nif ((priv->port < 1) || (priv->port > 2)) {\r\nen_err(priv, "Failed to get WoL information\n");\r\nreturn;\r\n}\r\nmask = (priv->port == 1) ? MLX4_DEV_CAP_FLAG_WOL_PORT1 :\r\nMLX4_DEV_CAP_FLAG_WOL_PORT2;\r\nif (!(priv->mdev->dev->caps.flags & mask)) {\r\nwol->supported = 0;\r\nwol->wolopts = 0;\r\nreturn;\r\n}\r\nerr = mlx4_wol_read(priv->mdev->dev, &config, priv->port);\r\nif (err) {\r\nen_err(priv, "Failed to get WoL information\n");\r\nreturn;\r\n}\r\nif (config & MLX4_EN_WOL_MAGIC)\r\nwol->supported = WAKE_MAGIC;\r\nelse\r\nwol->supported = 0;\r\nif (config & MLX4_EN_WOL_ENABLED)\r\nwol->wolopts = WAKE_MAGIC;\r\nelse\r\nwol->wolopts = 0;\r\n}\r\nstatic int mlx4_en_set_wol(struct net_device *netdev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(netdev);\r\nu64 config = 0;\r\nint err = 0;\r\nu64 mask;\r\nif ((priv->port < 1) || (priv->port > 2))\r\nreturn -EOPNOTSUPP;\r\nmask = (priv->port == 1) ? MLX4_DEV_CAP_FLAG_WOL_PORT1 :\r\nMLX4_DEV_CAP_FLAG_WOL_PORT2;\r\nif (!(priv->mdev->dev->caps.flags & mask))\r\nreturn -EOPNOTSUPP;\r\nif (wol->supported & ~WAKE_MAGIC)\r\nreturn -EINVAL;\r\nerr = mlx4_wol_read(priv->mdev->dev, &config, priv->port);\r\nif (err) {\r\nen_err(priv, "Failed to get WoL info, unable to modify\n");\r\nreturn err;\r\n}\r\nif (wol->wolopts & WAKE_MAGIC) {\r\nconfig |= MLX4_EN_WOL_DO_MODIFY | MLX4_EN_WOL_ENABLED |\r\nMLX4_EN_WOL_MAGIC;\r\n} else {\r\nconfig &= ~(MLX4_EN_WOL_ENABLED | MLX4_EN_WOL_MAGIC);\r\nconfig |= MLX4_EN_WOL_DO_MODIFY;\r\n}\r\nerr = mlx4_wol_write(priv->mdev->dev, config, priv->port);\r\nif (err)\r\nen_err(priv, "Failed to set WoL information\n");\r\nreturn err;\r\n}\r\nstatic int mlx4_en_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nint bit_count = hweight64(priv->stats_bitmap);\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn (priv->stats_bitmap ? bit_count : NUM_ALL_STATS) +\r\n(priv->tx_ring_num + priv->rx_ring_num) * 2;\r\ncase ETH_SS_TEST:\r\nreturn MLX4_EN_NUM_SELF_TEST - !(priv->mdev->dev->caps.flags\r\n& MLX4_DEV_CAP_FLAG_UC_LOOPBACK) * 2;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void mlx4_en_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats, uint64_t *data)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nint index = 0;\r\nint i, j = 0;\r\nspin_lock_bh(&priv->stats_lock);\r\nif (!(priv->stats_bitmap)) {\r\nfor (i = 0; i < NUM_MAIN_STATS; i++)\r\ndata[index++] =\r\n((unsigned long *) &priv->stats)[i];\r\nfor (i = 0; i < NUM_PORT_STATS; i++)\r\ndata[index++] =\r\n((unsigned long *) &priv->port_stats)[i];\r\nfor (i = 0; i < NUM_PKT_STATS; i++)\r\ndata[index++] =\r\n((unsigned long *) &priv->pkstats)[i];\r\n} else {\r\nfor (i = 0; i < NUM_MAIN_STATS; i++) {\r\nif ((priv->stats_bitmap >> j) & 1)\r\ndata[index++] =\r\n((unsigned long *) &priv->stats)[i];\r\nj++;\r\n}\r\nfor (i = 0; i < NUM_PORT_STATS; i++) {\r\nif ((priv->stats_bitmap >> j) & 1)\r\ndata[index++] =\r\n((unsigned long *) &priv->port_stats)[i];\r\nj++;\r\n}\r\n}\r\nfor (i = 0; i < priv->tx_ring_num; i++) {\r\ndata[index++] = priv->tx_ring[i].packets;\r\ndata[index++] = priv->tx_ring[i].bytes;\r\n}\r\nfor (i = 0; i < priv->rx_ring_num; i++) {\r\ndata[index++] = priv->rx_ring[i].packets;\r\ndata[index++] = priv->rx_ring[i].bytes;\r\n}\r\nspin_unlock_bh(&priv->stats_lock);\r\n}\r\nstatic void mlx4_en_self_test(struct net_device *dev,\r\nstruct ethtool_test *etest, u64 *buf)\r\n{\r\nmlx4_en_ex_selftest(dev, &etest->flags, buf);\r\n}\r\nstatic void mlx4_en_get_strings(struct net_device *dev,\r\nuint32_t stringset, uint8_t *data)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nint index = 0;\r\nint i;\r\nswitch (stringset) {\r\ncase ETH_SS_TEST:\r\nfor (i = 0; i < MLX4_EN_NUM_SELF_TEST - 2; i++)\r\nstrcpy(data + i * ETH_GSTRING_LEN, mlx4_en_test_names[i]);\r\nif (priv->mdev->dev->caps.flags & MLX4_DEV_CAP_FLAG_UC_LOOPBACK)\r\nfor (; i < MLX4_EN_NUM_SELF_TEST; i++)\r\nstrcpy(data + i * ETH_GSTRING_LEN, mlx4_en_test_names[i]);\r\nbreak;\r\ncase ETH_SS_STATS:\r\nif (!priv->stats_bitmap) {\r\nfor (i = 0; i < NUM_MAIN_STATS; i++)\r\nstrcpy(data + (index++) * ETH_GSTRING_LEN,\r\nmain_strings[i]);\r\nfor (i = 0; i < NUM_PORT_STATS; i++)\r\nstrcpy(data + (index++) * ETH_GSTRING_LEN,\r\nmain_strings[i +\r\nNUM_MAIN_STATS]);\r\nfor (i = 0; i < NUM_PKT_STATS; i++)\r\nstrcpy(data + (index++) * ETH_GSTRING_LEN,\r\nmain_strings[i +\r\nNUM_MAIN_STATS +\r\nNUM_PORT_STATS]);\r\n} else\r\nfor (i = 0; i < NUM_MAIN_STATS + NUM_PORT_STATS; i++) {\r\nif ((priv->stats_bitmap >> i) & 1) {\r\nstrcpy(data +\r\n(index++) * ETH_GSTRING_LEN,\r\nmain_strings[i]);\r\n}\r\nif (!(priv->stats_bitmap >> i))\r\nbreak;\r\n}\r\nfor (i = 0; i < priv->tx_ring_num; i++) {\r\nsprintf(data + (index++) * ETH_GSTRING_LEN,\r\n"tx%d_packets", i);\r\nsprintf(data + (index++) * ETH_GSTRING_LEN,\r\n"tx%d_bytes", i);\r\n}\r\nfor (i = 0; i < priv->rx_ring_num; i++) {\r\nsprintf(data + (index++) * ETH_GSTRING_LEN,\r\n"rx%d_packets", i);\r\nsprintf(data + (index++) * ETH_GSTRING_LEN,\r\n"rx%d_bytes", i);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int mlx4_en_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nint trans_type;\r\ncmd->autoneg = AUTONEG_DISABLE;\r\ncmd->supported = SUPPORTED_10000baseT_Full;\r\ncmd->advertising = ADVERTISED_10000baseT_Full;\r\nif (mlx4_en_QUERY_PORT(priv->mdev, priv->port))\r\nreturn -ENOMEM;\r\ntrans_type = priv->port_state.transciver;\r\nif (netif_carrier_ok(dev)) {\r\nethtool_cmd_speed_set(cmd, priv->port_state.link_speed);\r\ncmd->duplex = DUPLEX_FULL;\r\n} else {\r\nethtool_cmd_speed_set(cmd, -1);\r\ncmd->duplex = -1;\r\n}\r\nif (trans_type > 0 && trans_type <= 0xC) {\r\ncmd->port = PORT_FIBRE;\r\ncmd->transceiver = XCVR_EXTERNAL;\r\ncmd->supported |= SUPPORTED_FIBRE;\r\ncmd->advertising |= ADVERTISED_FIBRE;\r\n} else if (trans_type == 0x80 || trans_type == 0) {\r\ncmd->port = PORT_TP;\r\ncmd->transceiver = XCVR_INTERNAL;\r\ncmd->supported |= SUPPORTED_TP;\r\ncmd->advertising |= ADVERTISED_TP;\r\n} else {\r\ncmd->port = -1;\r\ncmd->transceiver = -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nif ((cmd->autoneg == AUTONEG_ENABLE) ||\r\n(ethtool_cmd_speed(cmd) != SPEED_10000) ||\r\n(cmd->duplex != DUPLEX_FULL))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_get_coalesce(struct net_device *dev,\r\nstruct ethtool_coalesce *coal)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\ncoal->tx_coalesce_usecs = 0;\r\ncoal->tx_max_coalesced_frames = 0;\r\ncoal->rx_coalesce_usecs = priv->rx_usecs;\r\ncoal->rx_max_coalesced_frames = priv->rx_frames;\r\ncoal->pkt_rate_low = priv->pkt_rate_low;\r\ncoal->rx_coalesce_usecs_low = priv->rx_usecs_low;\r\ncoal->pkt_rate_high = priv->pkt_rate_high;\r\ncoal->rx_coalesce_usecs_high = priv->rx_usecs_high;\r\ncoal->rate_sample_interval = priv->sample_interval;\r\ncoal->use_adaptive_rx_coalesce = priv->adaptive_rx_coal;\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_set_coalesce(struct net_device *dev,\r\nstruct ethtool_coalesce *coal)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nint err, i;\r\npriv->rx_frames = (coal->rx_max_coalesced_frames ==\r\nMLX4_EN_AUTO_CONF) ?\r\nMLX4_EN_RX_COAL_TARGET :\r\ncoal->rx_max_coalesced_frames;\r\npriv->rx_usecs = (coal->rx_coalesce_usecs ==\r\nMLX4_EN_AUTO_CONF) ?\r\nMLX4_EN_RX_COAL_TIME :\r\ncoal->rx_coalesce_usecs;\r\npriv->pkt_rate_low = coal->pkt_rate_low;\r\npriv->rx_usecs_low = coal->rx_coalesce_usecs_low;\r\npriv->pkt_rate_high = coal->pkt_rate_high;\r\npriv->rx_usecs_high = coal->rx_coalesce_usecs_high;\r\npriv->sample_interval = coal->rate_sample_interval;\r\npriv->adaptive_rx_coal = coal->use_adaptive_rx_coalesce;\r\nif (priv->adaptive_rx_coal)\r\nreturn 0;\r\nfor (i = 0; i < priv->rx_ring_num; i++) {\r\npriv->rx_cq[i].moder_cnt = priv->rx_frames;\r\npriv->rx_cq[i].moder_time = priv->rx_usecs;\r\npriv->last_moder_time[i] = MLX4_EN_AUTO_CONF;\r\nerr = mlx4_en_set_cq_moder(priv, &priv->rx_cq[i]);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mlx4_en_set_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nint err;\r\npriv->prof->tx_pause = pause->tx_pause != 0;\r\npriv->prof->rx_pause = pause->rx_pause != 0;\r\nerr = mlx4_SET_PORT_general(mdev->dev, priv->port,\r\npriv->rx_skb_size + ETH_FCS_LEN,\r\npriv->prof->tx_pause,\r\npriv->prof->tx_ppp,\r\npriv->prof->rx_pause,\r\npriv->prof->rx_ppp);\r\nif (err)\r\nen_err(priv, "Failed setting pause params\n");\r\nreturn err;\r\n}\r\nstatic void mlx4_en_get_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\npause->tx_pause = priv->prof->tx_pause;\r\npause->rx_pause = priv->prof->rx_pause;\r\n}\r\nstatic int mlx4_en_set_ringparam(struct net_device *dev,\r\nstruct ethtool_ringparam *param)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nu32 rx_size, tx_size;\r\nint port_up = 0;\r\nint err = 0;\r\nint i;\r\nif (param->rx_jumbo_pending || param->rx_mini_pending)\r\nreturn -EINVAL;\r\nrx_size = roundup_pow_of_two(param->rx_pending);\r\nrx_size = max_t(u32, rx_size, MLX4_EN_MIN_RX_SIZE);\r\nrx_size = min_t(u32, rx_size, MLX4_EN_MAX_RX_SIZE);\r\ntx_size = roundup_pow_of_two(param->tx_pending);\r\ntx_size = max_t(u32, tx_size, MLX4_EN_MIN_TX_SIZE);\r\ntx_size = min_t(u32, tx_size, MLX4_EN_MAX_TX_SIZE);\r\nif (rx_size == (priv->port_up ? priv->rx_ring[0].actual_size :\r\npriv->rx_ring[0].size) &&\r\ntx_size == priv->tx_ring[0].size)\r\nreturn 0;\r\nmutex_lock(&mdev->state_lock);\r\nif (priv->port_up) {\r\nport_up = 1;\r\nmlx4_en_stop_port(dev);\r\n}\r\nmlx4_en_free_resources(priv);\r\npriv->prof->tx_ring_size = tx_size;\r\npriv->prof->rx_ring_size = rx_size;\r\nerr = mlx4_en_alloc_resources(priv);\r\nif (err) {\r\nen_err(priv, "Failed reallocating port resources\n");\r\ngoto out;\r\n}\r\nif (port_up) {\r\nerr = mlx4_en_start_port(dev);\r\nif (err)\r\nen_err(priv, "Failed starting port\n");\r\n}\r\nfor (i = 0; i < priv->rx_ring_num; i++) {\r\npriv->rx_cq[i].moder_cnt = priv->rx_frames;\r\npriv->rx_cq[i].moder_time = priv->rx_usecs;\r\npriv->last_moder_time[i] = MLX4_EN_AUTO_CONF;\r\nerr = mlx4_en_set_cq_moder(priv, &priv->rx_cq[i]);\r\nif (err)\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&mdev->state_lock);\r\nreturn err;\r\n}\r\nstatic void mlx4_en_get_ringparam(struct net_device *dev,\r\nstruct ethtool_ringparam *param)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nmemset(param, 0, sizeof(*param));\r\nparam->rx_max_pending = MLX4_EN_MAX_RX_SIZE;\r\nparam->tx_max_pending = MLX4_EN_MAX_TX_SIZE;\r\nparam->rx_pending = priv->port_up ?\r\npriv->rx_ring[0].actual_size : priv->rx_ring[0].size;\r\nparam->tx_pending = priv->tx_ring[0].size;\r\n}\r\nstatic u32 mlx4_en_get_rxfh_indir_size(struct net_device *dev)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nreturn priv->rx_ring_num;\r\n}\r\nstatic int mlx4_en_get_rxfh_indir(struct net_device *dev, u32 *ring_index)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_en_rss_map *rss_map = &priv->rss_map;\r\nint rss_rings;\r\nsize_t n = priv->rx_ring_num;\r\nint err = 0;\r\nrss_rings = priv->prof->rss_rings ?: priv->rx_ring_num;\r\nwhile (n--) {\r\nring_index[n] = rss_map->qps[n % rss_rings].qpn -\r\nrss_map->base_qpn;\r\n}\r\nreturn err;\r\n}\r\nstatic int mlx4_en_set_rxfh_indir(struct net_device *dev,\r\nconst u32 *ring_index)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nstruct mlx4_en_dev *mdev = priv->mdev;\r\nint port_up = 0;\r\nint err = 0;\r\nint i;\r\nint rss_rings = 0;\r\nfor (i = 0; i < priv->rx_ring_num; i++) {\r\nif (i > 0 && !ring_index[i] && !rss_rings)\r\nrss_rings = i;\r\nif (ring_index[i] != (i % (rss_rings ?: priv->rx_ring_num)))\r\nreturn -EINVAL;\r\n}\r\nif (!rss_rings)\r\nrss_rings = priv->rx_ring_num;\r\nif (!is_power_of_2(rss_rings))\r\nreturn -EINVAL;\r\nmutex_lock(&mdev->state_lock);\r\nif (priv->port_up) {\r\nport_up = 1;\r\nmlx4_en_stop_port(dev);\r\n}\r\npriv->prof->rss_rings = rss_rings;\r\nif (port_up) {\r\nerr = mlx4_en_start_port(dev);\r\nif (err)\r\nen_err(priv, "Failed starting port\n");\r\n}\r\nmutex_unlock(&mdev->state_lock);\r\nreturn err;\r\n}\r\nstatic int mlx4_en_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,\r\nu32 *rule_locs)\r\n{\r\nstruct mlx4_en_priv *priv = netdev_priv(dev);\r\nint err = 0;\r\nswitch (cmd->cmd) {\r\ncase ETHTOOL_GRXRINGS:\r\ncmd->data = priv->rx_ring_num;\r\nbreak;\r\ndefault:\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn err;\r\n}
