static int\r\nnv40_get_intensity(struct backlight_device *bd)\r\n{\r\nstruct drm_device *dev = bl_get_data(bd);\r\nint val = (nv_rd32(dev, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK)\r\n>> 16;\r\nreturn val;\r\n}\r\nstatic int\r\nnv40_set_intensity(struct backlight_device *bd)\r\n{\r\nstruct drm_device *dev = bl_get_data(bd);\r\nint val = bd->props.brightness;\r\nint reg = nv_rd32(dev, NV40_PMC_BACKLIGHT);\r\nnv_wr32(dev, NV40_PMC_BACKLIGHT,\r\n(val << 16) | (reg & ~NV40_PMC_BACKLIGHT_MASK));\r\nreturn 0;\r\n}\r\nstatic int\r\nnv40_backlight_init(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct backlight_properties props;\r\nstruct backlight_device *bd;\r\nif (!(nv_rd32(dev, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK))\r\nreturn 0;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = 31;\r\nbd = backlight_device_register("nv_backlight", &connector->kdev, dev,\r\n&nv40_bl_ops, &props);\r\nif (IS_ERR(bd))\r\nreturn PTR_ERR(bd);\r\ndev_priv->backlight = bd;\r\nbd->props.brightness = nv40_get_intensity(bd);\r\nbacklight_update_status(bd);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_get_intensity(struct backlight_device *bd)\r\n{\r\nstruct nouveau_encoder *nv_encoder = bl_get_data(bd);\r\nstruct drm_device *dev = nv_encoder->base.base.dev;\r\nint or = nv_encoder->or;\r\nu32 div = 1025;\r\nu32 val;\r\nval = nv_rd32(dev, NV50_PDISP_SOR_PWM_CTL(or));\r\nval &= NV50_PDISP_SOR_PWM_CTL_VAL;\r\nreturn ((val * 100) + (div / 2)) / div;\r\n}\r\nstatic int\r\nnv50_set_intensity(struct backlight_device *bd)\r\n{\r\nstruct nouveau_encoder *nv_encoder = bl_get_data(bd);\r\nstruct drm_device *dev = nv_encoder->base.base.dev;\r\nint or = nv_encoder->or;\r\nu32 div = 1025;\r\nu32 val = (bd->props.brightness * div) / 100;\r\nnv_wr32(dev, NV50_PDISP_SOR_PWM_CTL(or),\r\nNV50_PDISP_SOR_PWM_CTL_NEW | val);\r\nreturn 0;\r\n}\r\nstatic int\r\nnva3_get_intensity(struct backlight_device *bd)\r\n{\r\nstruct nouveau_encoder *nv_encoder = bl_get_data(bd);\r\nstruct drm_device *dev = nv_encoder->base.base.dev;\r\nint or = nv_encoder->or;\r\nu32 div, val;\r\ndiv = nv_rd32(dev, NV50_PDISP_SOR_PWM_DIV(or));\r\nval = nv_rd32(dev, NV50_PDISP_SOR_PWM_CTL(or));\r\nval &= NVA3_PDISP_SOR_PWM_CTL_VAL;\r\nif (div && div >= val)\r\nreturn ((val * 100) + (div / 2)) / div;\r\nreturn 100;\r\n}\r\nstatic int\r\nnva3_set_intensity(struct backlight_device *bd)\r\n{\r\nstruct nouveau_encoder *nv_encoder = bl_get_data(bd);\r\nstruct drm_device *dev = nv_encoder->base.base.dev;\r\nint or = nv_encoder->or;\r\nu32 div, val;\r\ndiv = nv_rd32(dev, NV50_PDISP_SOR_PWM_DIV(or));\r\nval = (bd->props.brightness * div) / 100;\r\nif (div) {\r\nnv_wr32(dev, NV50_PDISP_SOR_PWM_CTL(or), val |\r\nNV50_PDISP_SOR_PWM_CTL_NEW |\r\nNVA3_PDISP_SOR_PWM_CTL_UNK);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nnv50_backlight_init(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_encoder *nv_encoder;\r\nstruct backlight_properties props;\r\nstruct backlight_device *bd;\r\nconst struct backlight_ops *ops;\r\nnv_encoder = find_encoder(connector, OUTPUT_LVDS);\r\nif (!nv_encoder) {\r\nnv_encoder = find_encoder(connector, OUTPUT_DP);\r\nif (!nv_encoder)\r\nreturn -ENODEV;\r\n}\r\nif (!nv_rd32(dev, NV50_PDISP_SOR_PWM_CTL(nv_encoder->or)))\r\nreturn 0;\r\nif (dev_priv->chipset <= 0xa0 ||\r\ndev_priv->chipset == 0xaa ||\r\ndev_priv->chipset == 0xac)\r\nops = &nv50_bl_ops;\r\nelse\r\nops = &nva3_bl_ops;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = 100;\r\nbd = backlight_device_register("nv_backlight", &connector->kdev,\r\nnv_encoder, ops, &props);\r\nif (IS_ERR(bd))\r\nreturn PTR_ERR(bd);\r\ndev_priv->backlight = bd;\r\nbd->props.brightness = bd->ops->get_brightness(bd);\r\nbacklight_update_status(bd);\r\nreturn 0;\r\n}\r\nint\r\nnouveau_backlight_init(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct drm_connector *connector;\r\n#ifdef CONFIG_ACPI\r\nif (acpi_video_backlight_support()) {\r\nNV_INFO(dev, "ACPI backlight interface available, "\r\n"not registering our own\n");\r\nreturn 0;\r\n}\r\n#endif\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nif (connector->connector_type != DRM_MODE_CONNECTOR_LVDS &&\r\nconnector->connector_type != DRM_MODE_CONNECTOR_eDP)\r\ncontinue;\r\nswitch (dev_priv->card_type) {\r\ncase NV_40:\r\nreturn nv40_backlight_init(connector);\r\ncase NV_50:\r\nreturn nv50_backlight_init(connector);\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nnouveau_backlight_exit(struct drm_device *dev)\r\n{\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nif (dev_priv->backlight) {\r\nbacklight_device_unregister(dev_priv->backlight);\r\ndev_priv->backlight = NULL;\r\n}\r\n}
