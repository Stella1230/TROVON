static void scc_pciex_io_flush(struct iowa_bus *bus)\r\n{\r\n(void)PEX_IN(bus->phb->cfg_addr, PEXDMRDEN0);\r\n}\r\nstatic void scc_pciex_memcpy_fromio(void *dest, const PCI_IO_ADDR src,\r\nunsigned long n)\r\n{\r\n__do_memcpy_fromio(dest, src, n);\r\nscc_pciex_io_flush(iowa_mem_find_bus(src));\r\n}\r\nstatic inline unsigned long get_bus_address(struct pci_controller *phb,\r\nunsigned long port)\r\n{\r\nreturn port - ((unsigned long)(phb->io_base_virt) - _IO_BASE);\r\n}\r\nstatic u32 scc_pciex_read_port(struct pci_controller *phb,\r\nunsigned long port, int size)\r\n{\r\nunsigned int byte_enable;\r\nunsigned int cmd, shift;\r\nunsigned long addr;\r\nu32 data, ret;\r\nBUG_ON(((port & 0x3ul) + size) > 4);\r\naddr = get_bus_address(phb, port);\r\nshift = addr & 0x3ul;\r\nbyte_enable = ((1 << size) - 1) << shift;\r\ncmd = PEXDCMND_IO_READ | (byte_enable << PEXDCMND_BYTE_EN_SHIFT);\r\nPEX_OUT(phb->cfg_addr, PEXDADRS, (addr & ~0x3ul));\r\nPEX_OUT(phb->cfg_addr, PEXDCMND, cmd);\r\ndata = PEX_IN(phb->cfg_addr, PEXDRDATA);\r\nret = (data >> (shift * 8)) & (0xFFFFFFFF >> ((4 - size) * 8));\r\npr_debug("PCIEX:PIO READ:port=0x%lx, addr=0x%lx, size=%d, be=%x,"\r\n" cmd=%x, data=%x, ret=%x\n", port, addr, size, byte_enable,\r\ncmd, data, ret);\r\nreturn ret;\r\n}\r\nstatic void scc_pciex_write_port(struct pci_controller *phb,\r\nunsigned long port, int size, u32 val)\r\n{\r\nunsigned int byte_enable;\r\nunsigned int cmd, shift;\r\nunsigned long addr;\r\nu32 data;\r\nBUG_ON(((port & 0x3ul) + size) > 4);\r\naddr = get_bus_address(phb, port);\r\nshift = addr & 0x3ul;\r\nbyte_enable = ((1 << size) - 1) << shift;\r\ncmd = PEXDCMND_IO_WRITE | (byte_enable << PEXDCMND_BYTE_EN_SHIFT);\r\ndata = (val & (0xFFFFFFFF >> (4 - size) * 8)) << (shift * 8);\r\nPEX_OUT(phb->cfg_addr, PEXDADRS, (addr & ~0x3ul));\r\nPEX_OUT(phb->cfg_addr, PEXDCMND, cmd);\r\nPEX_OUT(phb->cfg_addr, PEXDWDATA, data);\r\npr_debug("PCIEX:PIO WRITE:port=0x%lx, addr=%lx, size=%d, val=%x,"\r\n" be=%x, cmd=%x, data=%x\n", port, addr, size, val,\r\nbyte_enable, cmd, data);\r\n}\r\nstatic u8 __scc_pciex_inb(struct pci_controller *phb, unsigned long port)\r\n{\r\nreturn (u8)scc_pciex_read_port(phb, port, 1);\r\n}\r\nstatic u16 __scc_pciex_inw(struct pci_controller *phb, unsigned long port)\r\n{\r\nu32 data;\r\nif ((port & 0x3ul) < 3)\r\ndata = scc_pciex_read_port(phb, port, 2);\r\nelse {\r\nu32 d1 = scc_pciex_read_port(phb, port, 1);\r\nu32 d2 = scc_pciex_read_port(phb, port + 1, 1);\r\ndata = d1 | (d2 << 8);\r\n}\r\nreturn (u16)data;\r\n}\r\nstatic u32 __scc_pciex_inl(struct pci_controller *phb, unsigned long port)\r\n{\r\nunsigned int mod = port & 0x3ul;\r\nu32 data;\r\nif (mod == 0)\r\ndata = scc_pciex_read_port(phb, port, 4);\r\nelse {\r\nu32 d1 = scc_pciex_read_port(phb, port, 4 - mod);\r\nu32 d2 = scc_pciex_read_port(phb, port + 1, mod);\r\ndata = d1 | (d2 << (mod * 8));\r\n}\r\nreturn data;\r\n}\r\nstatic void __scc_pciex_outb(struct pci_controller *phb,\r\nu8 val, unsigned long port)\r\n{\r\nscc_pciex_write_port(phb, port, 1, (u32)val);\r\n}\r\nstatic void __scc_pciex_outw(struct pci_controller *phb,\r\nu16 val, unsigned long port)\r\n{\r\nif ((port & 0x3ul) < 3)\r\nscc_pciex_write_port(phb, port, 2, (u32)val);\r\nelse {\r\nu32 d1 = val & 0x000000FF;\r\nu32 d2 = (val & 0x0000FF00) >> 8;\r\nscc_pciex_write_port(phb, port, 1, d1);\r\nscc_pciex_write_port(phb, port + 1, 1, d2);\r\n}\r\n}\r\nstatic void __scc_pciex_outl(struct pci_controller *phb,\r\nu32 val, unsigned long port)\r\n{\r\nunsigned int mod = port & 0x3ul;\r\nif (mod == 0)\r\nscc_pciex_write_port(phb, port, 4, val);\r\nelse {\r\nu32 d1 = val & (0xFFFFFFFFul >> (mod * 8));\r\nu32 d2 = val >> ((4 - mod) * 8);\r\nscc_pciex_write_port(phb, port, 4 - mod, d1);\r\nscc_pciex_write_port(phb, port + 1, mod, d2);\r\n}\r\n}\r\nstatic int __init scc_pciex_iowa_init(struct iowa_bus *bus, void *data)\r\n{\r\ndma_addr_t dummy_page_da;\r\nvoid *dummy_page_va;\r\ndummy_page_va = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!dummy_page_va) {\r\npr_err("PCIEX:Alloc dummy_page_va failed\n");\r\nreturn -1;\r\n}\r\ndummy_page_da = dma_map_single(bus->phb->parent, dummy_page_va,\r\nPAGE_SIZE, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(bus->phb->parent, dummy_page_da)) {\r\npr_err("PCIEX:Map dummy page failed.\n");\r\nkfree(dummy_page_va);\r\nreturn -1;\r\n}\r\nPEX_OUT(bus->phb->cfg_addr, PEXDMRDADR0, dummy_page_da);\r\nreturn 0;\r\n}\r\nstatic uint32_t config_read_pciex_dev(unsigned int __iomem *base,\r\nuint64_t bus_no, uint64_t dev_no, uint64_t func_no,\r\nuint64_t off, uint64_t size)\r\n{\r\nuint32_t ret;\r\nuint32_t addr, cmd;\r\naddr = MK_PEXDADRS(bus_no, dev_no, func_no, off);\r\ncmd = MK_PEXDCMND(PEXDCMND_CONFIG_READ, off, size);\r\nPEX_OUT(base, PEXDADRS, addr);\r\nPEX_OUT(base, PEXDCMND, cmd);\r\nret = (PEX_IN(base, PEXDRDATA)\r\n>> ((off & (4-size)) * 8)) & ((0x1 << (size * 8)) - 1);\r\nreturn ret;\r\n}\r\nstatic void config_write_pciex_dev(unsigned int __iomem *base, uint64_t bus_no,\r\nuint64_t dev_no, uint64_t func_no, uint64_t off, uint64_t size,\r\nuint32_t data)\r\n{\r\nuint32_t addr, cmd;\r\naddr = MK_PEXDADRS(bus_no, dev_no, func_no, off);\r\ncmd = MK_PEXDCMND(PEXDCMND_CONFIG_WRITE, off, size);\r\nPEX_OUT(base, PEXDADRS, addr);\r\nPEX_OUT(base, PEXDCMND, cmd);\r\nPEX_OUT(base, PEXDWDATA,\r\n(data & ((0x1 << (size * 8)) - 1)) << ((off & (4-size)) * 8));\r\n}\r\nstatic uint32_t config_read_pciex_rc(unsigned int __iomem *base,\r\nuint32_t where, uint32_t size)\r\n{\r\nPEX_OUT(base, PEXCADRS, MK_PEXCADRS(PEXCADRS_CMD_READ, where, size));\r\nreturn (PEX_IN(base, PEXCRDATA)\r\n>> ((where & (4 - size)) * 8)) & ((0x1 << (size * 8)) - 1);\r\n}\r\nstatic void config_write_pciex_rc(unsigned int __iomem *base, uint32_t where,\r\nuint32_t size, uint32_t val)\r\n{\r\nuint32_t data;\r\ndata = (val & ((0x1 << (size * 8)) - 1)) << ((where & (4 - size)) * 8);\r\nPEX_OUT(base, PEXCADRS, MK_PEXCADRS(PEXCADRS_CMD_WRITE, where, size));\r\nPEX_OUT(base, PEXCWDATA, data);\r\n}\r\nstatic int scc_pciex_read_config(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, unsigned int *val)\r\n{\r\nstruct pci_controller *phb = pci_bus_to_host(bus);\r\nif (bus->number == phb->first_busno && PCI_SLOT(devfn) != 1) {\r\n*val = ~0;\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nif (bus->number == 0 && PCI_SLOT(devfn) == 0)\r\n*val = config_read_pciex_rc(phb->cfg_addr, where, size);\r\nelse\r\n*val = config_read_pciex_dev(phb->cfg_addr, bus->number,\r\nPCI_SLOT(devfn), PCI_FUNC(devfn), where, size);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int scc_pciex_write_config(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, unsigned int val)\r\n{\r\nstruct pci_controller *phb = pci_bus_to_host(bus);\r\nif (bus->number == phb->first_busno && PCI_SLOT(devfn) != 1)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (bus->number == 0 && PCI_SLOT(devfn) == 0)\r\nconfig_write_pciex_rc(phb->cfg_addr, where, size, val);\r\nelse\r\nconfig_write_pciex_dev(phb->cfg_addr, bus->number,\r\nPCI_SLOT(devfn), PCI_FUNC(devfn), where, size, val);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic void pciex_clear_intr_all(unsigned int __iomem *base)\r\n{\r\nPEX_OUT(base, PEXAERRSTS, 0xffffffff);\r\nPEX_OUT(base, PEXPRERRSTS, 0xffffffff);\r\nPEX_OUT(base, PEXINTSTS, 0xffffffff);\r\n}\r\nstatic void pciex_enable_intr_all(unsigned int __iomem *base)\r\n{\r\nPEX_OUT(base, PEXINTMASK, 0x0000e7f1);\r\nPEX_OUT(base, PEXAERRMASK, 0x03ff01ff);\r\nPEX_OUT(base, PEXPRERRMASK, 0x0001010f);\r\nPEX_OUT(base, PEXVDMASK, 0x00000001);\r\n}\r\nstatic void pciex_check_status(unsigned int __iomem *base)\r\n{\r\nuint32_t err = 0;\r\nuint32_t intsts, aerr, prerr, rcvcp, lenerr;\r\nuint32_t maea, maec;\r\nintsts = PEX_IN(base, PEXINTSTS);\r\naerr = PEX_IN(base, PEXAERRSTS);\r\nprerr = PEX_IN(base, PEXPRERRSTS);\r\nrcvcp = PEX_IN(base, PEXRCVCPLIDA);\r\nlenerr = PEX_IN(base, PEXLENERRIDA);\r\nif (intsts || aerr || prerr || rcvcp || lenerr)\r\nerr = 1;\r\npr_info("PCEXC interrupt!!\n");\r\npr_info("PEXINTSTS :0x%08x\n", intsts);\r\npr_info("PEXAERRSTS :0x%08x\n", aerr);\r\npr_info("PEXPRERRSTS :0x%08x\n", prerr);\r\npr_info("PEXRCVCPLIDA :0x%08x\n", rcvcp);\r\npr_info("PEXLENERRIDA :0x%08x\n", lenerr);\r\nif (intsts & 0x00004000) {\r\nuint32_t i, n;\r\nfor (i = 0; i < 4; i++) {\r\nn = 1 << i;\r\nif (prerr & n) {\r\nmaea = PEX_IN(base, PEXMAEA(i));\r\nmaec = PEX_IN(base, PEXMAEC(i));\r\npr_info("PEXMAEC%d :0x%08x\n", i, maec);\r\npr_info("PEXMAEA%d :0x%08x\n", i, maea);\r\n}\r\n}\r\n}\r\nif (err)\r\npciex_clear_intr_all(base);\r\n}\r\nstatic irqreturn_t pciex_handle_internal_irq(int irq, void *dev_id)\r\n{\r\nstruct pci_controller *phb = dev_id;\r\npr_debug("PCIEX:pciex_handle_internal_irq(irq=%d)\n", irq);\r\nBUG_ON(phb->cfg_addr == NULL);\r\npciex_check_status(phb->cfg_addr);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic __init int celleb_setup_pciex(struct device_node *node,\r\nstruct pci_controller *phb)\r\n{\r\nstruct resource r;\r\nstruct of_irq oirq;\r\nint virq;\r\nif (of_address_to_resource(node, 0, &r)) {\r\npr_err("PCIEXC:Failed to get config resource.\n");\r\nreturn 1;\r\n}\r\nphb->cfg_addr = ioremap(r.start, resource_size(&r));\r\nif (!phb->cfg_addr) {\r\npr_err("PCIEXC:Failed to remap SMMIO region.\n");\r\nreturn 1;\r\n}\r\nphb->cfg_data = NULL;\r\nphb->ops = &scc_pciex_pci_ops;\r\nif (of_irq_map_one(node, 1, &oirq)) {\r\npr_err("PCIEXC:Failed to map irq\n");\r\ngoto error;\r\n}\r\nvirq = irq_create_of_mapping(oirq.controller, oirq.specifier,\r\noirq.size);\r\nif (request_irq(virq, pciex_handle_internal_irq,\r\n0, "pciex", (void *)phb)) {\r\npr_err("PCIEXC:Failed to request irq\n");\r\ngoto error;\r\n}\r\npciex_clear_intr_all(phb->cfg_addr);\r\npciex_enable_intr_all(phb->cfg_addr);\r\nreturn 0;\r\nerror:\r\nphb->cfg_data = NULL;\r\nif (phb->cfg_addr)\r\niounmap(phb->cfg_addr);\r\nphb->cfg_addr = NULL;\r\nreturn 1;\r\n}
