static void jlj_write2(struct gspca_dev *gspca_dev, unsigned char *command)\r\n{\r\nint retval;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nmemcpy(gspca_dev->usb_buf, command, 2);\r\nretval = usb_bulk_msg(gspca_dev->dev,\r\nusb_sndbulkpipe(gspca_dev->dev, 3),\r\ngspca_dev->usb_buf, 2, NULL, 500);\r\nif (retval < 0) {\r\npr_err("command write [%02x] error %d\n",\r\ngspca_dev->usb_buf[0], retval);\r\ngspca_dev->usb_err = retval;\r\n}\r\n}\r\nstatic void jlj_read1(struct gspca_dev *gspca_dev, unsigned char response)\r\n{\r\nint retval;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nretval = usb_bulk_msg(gspca_dev->dev,\r\nusb_rcvbulkpipe(gspca_dev->dev, 0x84),\r\ngspca_dev->usb_buf, 1, NULL, 500);\r\nresponse = gspca_dev->usb_buf[0];\r\nif (retval < 0) {\r\npr_err("read command [%02x] error %d\n",\r\ngspca_dev->usb_buf[0], retval);\r\ngspca_dev->usb_err = retval;\r\n}\r\n}\r\nstatic void setfreq(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 freq_commands[][2] = {\r\n{0x71, 0x80},\r\n{0x70, 0x07}\r\n};\r\nfreq_commands[0][1] |= (sd->ctrls[LIGHTFREQ].val >> 1);\r\njlj_write2(gspca_dev, freq_commands[0]);\r\njlj_write2(gspca_dev, freq_commands[1]);\r\n}\r\nstatic void setcamquality(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 quality_commands[][2] = {\r\n{0x71, 0x1E},\r\n{0x70, 0x06}\r\n};\r\nu8 camquality;\r\ncamquality = ((QUALITY_MAX - sd->quality) * CAMQUALITY_MAX)\r\n/ (QUALITY_MAX - QUALITY_MIN);\r\nquality_commands[0][1] += camquality;\r\njlj_write2(gspca_dev, quality_commands[0]);\r\njlj_write2(gspca_dev, quality_commands[1]);\r\n}\r\nstatic void setautogain(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 autogain_commands[][2] = {\r\n{0x94, 0x02},\r\n{0xcf, 0x00}\r\n};\r\nautogain_commands[1][1] = (sd->ctrls[AUTOGAIN].val << 4);\r\njlj_write2(gspca_dev, autogain_commands[0]);\r\njlj_write2(gspca_dev, autogain_commands[1]);\r\n}\r\nstatic void setred(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 setred_commands[][2] = {\r\n{0x94, 0x02},\r\n{0xe6, 0x00}\r\n};\r\nsetred_commands[1][1] = sd->ctrls[RED].val;\r\njlj_write2(gspca_dev, setred_commands[0]);\r\njlj_write2(gspca_dev, setred_commands[1]);\r\n}\r\nstatic void setgreen(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 setgreen_commands[][2] = {\r\n{0x94, 0x02},\r\n{0xe7, 0x00}\r\n};\r\nsetgreen_commands[1][1] = sd->ctrls[GREEN].val;\r\njlj_write2(gspca_dev, setgreen_commands[0]);\r\njlj_write2(gspca_dev, setgreen_commands[1]);\r\n}\r\nstatic void setblue(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 setblue_commands[][2] = {\r\n{0x94, 0x02},\r\n{0xe9, 0x00}\r\n};\r\nsetblue_commands[1][1] = sd->ctrls[BLUE].val;\r\njlj_write2(gspca_dev, setblue_commands[0]);\r\njlj_write2(gspca_dev, setblue_commands[1]);\r\n}\r\nstatic int jlj_start(struct gspca_dev *gspca_dev)\r\n{\r\nint i;\r\nint start_commands_size;\r\nu8 response = 0xff;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct jlj_command start_commands[] = {\r\n{{0x71, 0x81}, 0, 0},\r\n{{0x70, 0x05}, 0, JEILINJ_CMD_DELAY},\r\n{{0x95, 0x70}, 1, 0},\r\n{{0x71, 0x81 - gspca_dev->curr_mode}, 0, 0},\r\n{{0x70, 0x04}, 0, JEILINJ_CMD_DELAY},\r\n{{0x95, 0x70}, 1, 0},\r\n{{0x71, 0x00}, 0, 0},\r\n{{0x70, 0x08}, 0, JEILINJ_CMD_DELAY},\r\n{{0x95, 0x70}, 1, 0},\r\n#define SPORTSCAM_DV15_CMD_SIZE 9\r\n{{0x94, 0x02}, 0, 0},\r\n{{0xde, 0x24}, 0, 0},\r\n{{0x94, 0x02}, 0, 0},\r\n{{0xdd, 0xf0}, 0, 0},\r\n{{0x94, 0x02}, 0, 0},\r\n{{0xe3, 0x2c}, 0, 0},\r\n{{0x94, 0x02}, 0, 0},\r\n{{0xe4, 0x00}, 0, 0},\r\n{{0x94, 0x02}, 0, 0},\r\n{{0xe5, 0x00}, 0, 0},\r\n{{0x94, 0x02}, 0, 0},\r\n{{0xe6, 0x2c}, 0, 0},\r\n{{0x94, 0x03}, 0, 0},\r\n{{0xaa, 0x00}, 0, 0}\r\n};\r\nsd->blocks_left = 0;\r\nif (sd->type == SPORTSCAM_DV15)\r\nstart_commands_size = SPORTSCAM_DV15_CMD_SIZE;\r\nelse\r\nstart_commands_size = ARRAY_SIZE(start_commands);\r\nfor (i = 0; i < start_commands_size; i++) {\r\njlj_write2(gspca_dev, start_commands[i].instruction);\r\nif (start_commands[i].delay)\r\nmsleep(start_commands[i].delay);\r\nif (start_commands[i].ack_wanted)\r\njlj_read1(gspca_dev, response);\r\n}\r\nsetcamquality(gspca_dev);\r\nmsleep(2);\r\nsetfreq(gspca_dev);\r\nif (gspca_dev->usb_err < 0)\r\nPDEBUG(D_ERR, "Start streaming command failed");\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data, int len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint packet_type;\r\nu32 header_marker;\r\nPDEBUG(D_STREAM, "Got %d bytes out of %d for Block 0",\r\nlen, JEILINJ_MAX_TRANSFER);\r\nif (len != JEILINJ_MAX_TRANSFER) {\r\nPDEBUG(D_PACK, "bad length");\r\ngoto discard;\r\n}\r\nheader_marker = ((u32 *)data)[0];\r\nif (header_marker == FRAME_START) {\r\nsd->blocks_left = data[0x0a] - 1;\r\nPDEBUG(D_STREAM, "blocks_left = 0x%x", sd->blocks_left);\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\nsd->jpeg_hdr, JPEG_HDR_SZ);\r\ngspca_frame_add(gspca_dev, INTER_PACKET,\r\ndata + FRAME_HEADER_LEN,\r\nJEILINJ_MAX_TRANSFER - FRAME_HEADER_LEN);\r\n} else if (sd->blocks_left > 0) {\r\nPDEBUG(D_STREAM, "%d blocks remaining for frame",\r\nsd->blocks_left);\r\nsd->blocks_left -= 1;\r\nif (sd->blocks_left == 0)\r\npacket_type = LAST_PACKET;\r\nelse\r\npacket_type = INTER_PACKET;\r\ngspca_frame_add(gspca_dev, packet_type,\r\ndata, JEILINJ_MAX_TRANSFER);\r\n} else\r\ngoto discard;\r\nreturn;\r\ndiscard:\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct cam *cam = &gspca_dev->cam;\r\nstruct sd *dev = (struct sd *) gspca_dev;\r\ndev->type = id->driver_info;\r\ngspca_dev->cam.ctrls = dev->ctrls;\r\ndev->quality = QUALITY_DEF;\r\ncam->cam_mode = jlj_mode;\r\ncam->nmodes = ARRAY_SIZE(jlj_mode);\r\ncam->bulk = 1;\r\ncam->bulk_nurbs = 1;\r\ncam->bulk_size = JEILINJ_MAX_TRANSFER;\r\nreturn 0;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nint i;\r\nu8 *buf;\r\nstatic u8 stop_commands[][2] = {\r\n{0x71, 0x00},\r\n{0x70, 0x09},\r\n{0x71, 0x80},\r\n{0x70, 0x05}\r\n};\r\nfor (;;) {\r\nusb_bulk_msg(gspca_dev->dev,\r\ngspca_dev->urb[0]->pipe,\r\ngspca_dev->urb[0]->transfer_buffer,\r\nJEILINJ_MAX_TRANSFER, NULL,\r\nJEILINJ_DATA_TIMEOUT);\r\ni = 0;\r\nbuf = gspca_dev->urb[0]->transfer_buffer;\r\nwhile ((i < (JEILINJ_MAX_TRANSFER - 1)) &&\r\n((buf[i] != 0xff) || (buf[i+1] != 0xd9)))\r\ni++;\r\nif (i != (JEILINJ_MAX_TRANSFER - 1))\r\nbreak;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(stop_commands); i++)\r\njlj_write2(gspca_dev, stop_commands[i]);\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *dev = (struct sd *) gspca_dev;\r\njpeg_define(dev->jpeg_hdr, gspca_dev->height, gspca_dev->width,\r\n0x21);\r\njpeg_set_qual(dev->jpeg_hdr, dev->quality);\r\nPDEBUG(D_STREAM, "Start streaming at %dx%d",\r\ngspca_dev->height, gspca_dev->width);\r\njlj_start(gspca_dev);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_querymenu(struct gspca_dev *gspca_dev,\r\nstruct v4l2_querymenu *menu)\r\n{\r\nswitch (menu->id) {\r\ncase V4L2_CID_POWER_LINE_FREQUENCY:\r\nswitch (menu->index) {\r\ncase 0:\r\nstrcpy((char *) menu->name, "disable");\r\nreturn 0;\r\ncase 1:\r\nstrcpy((char *) menu->name, "50 Hz");\r\nreturn 0;\r\ncase 2:\r\nstrcpy((char *) menu->name, "60 Hz");\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int sd_set_jcomp(struct gspca_dev *gspca_dev,\r\nstruct v4l2_jpegcompression *jcomp)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (jcomp->quality < QUALITY_MIN)\r\nsd->quality = QUALITY_MIN;\r\nelse if (jcomp->quality > QUALITY_MAX)\r\nsd->quality = QUALITY_MAX;\r\nelse\r\nsd->quality = jcomp->quality;\r\nif (gspca_dev->streaming) {\r\njpeg_set_qual(sd->jpeg_hdr, sd->quality);\r\nsetcamquality(gspca_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_get_jcomp(struct gspca_dev *gspca_dev,\r\nstruct v4l2_jpegcompression *jcomp)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nmemset(jcomp, 0, sizeof *jcomp);\r\njcomp->quality = sd->quality;\r\njcomp->jpeg_markers = V4L2_JPEG_MARKER_DHT\r\n| V4L2_JPEG_MARKER_DQT;\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id,\r\nsd_desc[id->driver_info],\r\nsizeof(struct sd),\r\nTHIS_MODULE);\r\n}
