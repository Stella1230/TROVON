static int das800_probe(struct comedi_device *dev)\r\n{\r\nint id_bits;\r\nunsigned long irq_flags;\r\nint board;\r\nspin_lock_irqsave(&dev->spinlock, irq_flags);\r\noutb(ID, dev->iobase + DAS800_GAIN);\r\nid_bits = inb(dev->iobase + DAS800_ID) & 0x3;\r\nspin_unlock_irqrestore(&dev->spinlock, irq_flags);\r\nboard = thisboard - das800_boards;\r\nswitch (id_bits) {\r\ncase 0x0:\r\nif (board == das800) {\r\ndev_dbg(dev->hw_dev, "Board model: DAS-800\n");\r\nreturn board;\r\n}\r\nif (board == ciodas800) {\r\ndev_dbg(dev->hw_dev, "Board model: CIO-DAS800\n");\r\nreturn board;\r\n}\r\ndev_dbg(dev->hw_dev, "Board model (probed): DAS-800\n");\r\nreturn das800;\r\nbreak;\r\ncase 0x2:\r\nif (board == das801) {\r\ndev_dbg(dev->hw_dev, "Board model: DAS-801\n");\r\nreturn board;\r\n}\r\nif (board == ciodas801) {\r\ndev_dbg(dev->hw_dev, "Board model: CIO-DAS801\n");\r\nreturn board;\r\n}\r\ndev_dbg(dev->hw_dev, "Board model (probed): DAS-801\n");\r\nreturn das801;\r\nbreak;\r\ncase 0x3:\r\nif (board == das802) {\r\ndev_dbg(dev->hw_dev, "Board model: DAS-802\n");\r\nreturn board;\r\n}\r\nif (board == ciodas802) {\r\ndev_dbg(dev->hw_dev, "Board model: CIO-DAS802\n");\r\nreturn board;\r\n}\r\nif (board == ciodas80216) {\r\ndev_dbg(dev->hw_dev, "Board model: CIO-DAS802/16\n");\r\nreturn board;\r\n}\r\ndev_dbg(dev->hw_dev, "Board model (probed): DAS-802\n");\r\nreturn das802;\r\nbreak;\r\ndefault:\r\ndev_dbg(dev->hw_dev, "Board model: probe returned 0x%x (unknown)\n",\r\nid_bits);\r\nreturn board;\r\nbreak;\r\n}\r\nreturn -1;\r\n}\r\nstatic int __init driver_das800_init_module(void)\r\n{\r\nreturn comedi_driver_register(&driver_das800);\r\n}\r\nstatic void __exit driver_das800_cleanup_module(void)\r\n{\r\ncomedi_driver_unregister(&driver_das800);\r\n}\r\nstatic irqreturn_t das800_interrupt(int irq, void *d)\r\n{\r\nshort i;\r\nshort dataPoint = 0;\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async;\r\nint status;\r\nunsigned long irq_flags;\r\nstatic const int max_loops = 128;\r\nint fifo_empty = 0;\r\nint fifo_overflow = 0;\r\nstatus = inb(dev->iobase + DAS800_STATUS);\r\nif (!(status & IRQ))\r\nreturn IRQ_NONE;\r\nif (!(dev->attached))\r\nreturn IRQ_HANDLED;\r\nasync = s->async;\r\nspin_lock_irqsave(&dev->spinlock, irq_flags);\r\noutb(CONTROL1, dev->iobase + DAS800_GAIN);\r\nstatus = inb(dev->iobase + DAS800_STATUS2) & STATUS2_HCEN;\r\nif (status == 0) {\r\nspin_unlock_irqrestore(&dev->spinlock, irq_flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nfor (i = 0; i < max_loops; i++) {\r\ndataPoint = inb(dev->iobase + DAS800_LSB);\r\ndataPoint += inb(dev->iobase + DAS800_MSB) << 8;\r\nif (thisboard->resolution == 12) {\r\nfifo_empty = dataPoint & FIFO_EMPTY;\r\nfifo_overflow = dataPoint & FIFO_OVF;\r\nif (fifo_overflow)\r\nbreak;\r\n} else {\r\nfifo_empty = 0;\r\n}\r\nif (fifo_empty)\r\nbreak;\r\nif (thisboard->resolution == 12)\r\ndataPoint = (dataPoint >> 4) & 0xfff;\r\nif (devpriv->count > 0 || devpriv->forever == 1) {\r\ncfc_write_to_buffer(s, dataPoint);\r\nif (devpriv->count > 0)\r\ndevpriv->count--;\r\n}\r\n}\r\nasync->events |= COMEDI_CB_BLOCK;\r\nif (thisboard->resolution == 12) {\r\nfifo_overflow = dataPoint & FIFO_OVF;\r\n} else {\r\nfifo_overflow = inb(dev->iobase + DAS800_GAIN) & CIO_FFOV;\r\n}\r\nif (fifo_overflow) {\r\nspin_unlock_irqrestore(&dev->spinlock, irq_flags);\r\ncomedi_error(dev, "DAS800 FIFO overflow");\r\ndas800_cancel(dev, dev->subdevices + 0);\r\nasync->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;\r\ncomedi_event(dev, s);\r\nasync->events = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\nif (devpriv->count > 0 || devpriv->forever == 1) {\r\noutb(CONTROL1, dev->iobase + DAS800_GAIN);\r\noutb(CONTROL1_INTE | devpriv->do_bits,\r\ndev->iobase + DAS800_CONTROL1);\r\nspin_unlock_irqrestore(&dev->spinlock, irq_flags);\r\n} else {\r\nspin_unlock_irqrestore(&dev->spinlock, irq_flags);\r\ndisable_das800(dev);\r\nasync->events |= COMEDI_CB_EOA;\r\n}\r\ncomedi_event(dev, s);\r\nasync->events = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nunsigned long iobase = it->options[0];\r\nunsigned int irq = it->options[1];\r\nunsigned long irq_flags;\r\nint board;\r\ndev_info(dev->hw_dev, "comedi%d: das800: io 0x%lx\n", dev->minor,\r\niobase);\r\nif (irq)\r\ndev_dbg(dev->hw_dev, "irq %u\n", irq);\r\nif (alloc_private(dev, sizeof(struct das800_private)) < 0)\r\nreturn -ENOMEM;\r\nif (iobase == 0) {\r\ndev_err(dev->hw_dev, "io base address required for das800\n");\r\nreturn -EINVAL;\r\n}\r\nif (!request_region(iobase, DAS800_SIZE, "das800")) {\r\ndev_err(dev->hw_dev, "I/O port conflict\n");\r\nreturn -EIO;\r\n}\r\ndev->iobase = iobase;\r\nboard = das800_probe(dev);\r\nif (board < 0) {\r\ndev_dbg(dev->hw_dev, "unable to determine board type\n");\r\nreturn -ENODEV;\r\n}\r\ndev->board_ptr = das800_boards + board;\r\nif (irq == 1 || irq > 7) {\r\ndev_err(dev->hw_dev, "irq out of range\n");\r\nreturn -EINVAL;\r\n}\r\nif (irq) {\r\nif (request_irq(irq, das800_interrupt, 0, "das800", dev)) {\r\ndev_err(dev->hw_dev, "unable to allocate irq %u\n",\r\nirq);\r\nreturn -EINVAL;\r\n}\r\n}\r\ndev->irq = irq;\r\ndev->board_name = thisboard->name;\r\nif (alloc_subdevices(dev, 3) < 0)\r\nreturn -ENOMEM;\r\ns = dev->subdevices + 0;\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;\r\ns->n_chan = 8;\r\ns->len_chanlist = 8;\r\ns->maxdata = (1 << thisboard->resolution) - 1;\r\ns->range_table = thisboard->ai_range;\r\ns->do_cmd = das800_ai_do_cmd;\r\ns->do_cmdtest = das800_ai_do_cmdtest;\r\ns->insn_read = das800_ai_rinsn;\r\ns->cancel = das800_cancel;\r\ns = dev->subdevices + 1;\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 3;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = das800_di_rbits;\r\ns = dev->subdevices + 2;\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = 4;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = das800_do_wbits;\r\ndisable_das800(dev);\r\nspin_lock_irqsave(&dev->spinlock, irq_flags);\r\noutb(CONTROL1, dev->iobase + DAS800_GAIN);\r\noutb(CONTROL1_INTE | devpriv->do_bits, dev->iobase + DAS800_CONTROL1);\r\nspin_unlock_irqrestore(&dev->spinlock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic int das800_detach(struct comedi_device *dev)\r\n{\r\ndev_info(dev->hw_dev, "comedi%d: das800: remove\n", dev->minor);\r\nif (dev->iobase)\r\nrelease_region(dev->iobase, DAS800_SIZE);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nreturn 0;\r\n}\r\nstatic int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\ndevpriv->forever = 0;\r\ndevpriv->count = 0;\r\ndisable_das800(dev);\r\nreturn 0;\r\n}\r\nstatic void enable_das800(struct comedi_device *dev)\r\n{\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&dev->spinlock, irq_flags);\r\nif (thisboard->resolution == 16)\r\noutb(CIO_ENHF, dev->iobase + DAS800_GAIN);\r\noutb(CONV_CONTROL, dev->iobase + DAS800_GAIN);\r\noutb(CONV_HCEN, dev->iobase + DAS800_CONV_CONTROL);\r\noutb(CONTROL1, dev->iobase + DAS800_GAIN);\r\noutb(CONTROL1_INTE | devpriv->do_bits, dev->iobase + DAS800_CONTROL1);\r\nspin_unlock_irqrestore(&dev->spinlock, irq_flags);\r\n}\r\nstatic void disable_das800(struct comedi_device *dev)\r\n{\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&dev->spinlock, irq_flags);\r\noutb(CONV_CONTROL, dev->iobase + DAS800_GAIN);\r\noutb(0x0, dev->iobase + DAS800_CONV_CONTROL);\r\nspin_unlock_irqrestore(&dev->spinlock, irq_flags);\r\n}\r\nstatic int das800_ai_do_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp;\r\nint gain, startChan;\r\nint i;\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW | TRIG_EXT;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_FOLLOW;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_TIMER | TRIG_EXT;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->stop_src != TRIG_COUNT && cmd->stop_src != TRIG_NONE)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (cmd->convert_arg < thisboard->ai_speed) {\r\ncmd->convert_arg = thisboard->ai_speed;\r\nerr++;\r\n}\r\n}\r\nif (!cmd->chanlist_len) {\r\ncmd->chanlist_len = 1;\r\nerr++;\r\n}\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (!cmd->stop_arg) {\r\ncmd->stop_arg = 1;\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ntmp = cmd->convert_arg;\r\ni8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),\r\n&(devpriv->divisor2),\r\n&(cmd->convert_arg),\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (tmp != cmd->convert_arg)\r\nerr++;\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist) {\r\ngain = CR_RANGE(cmd->chanlist[0]);\r\nstartChan = CR_CHAN(cmd->chanlist[0]);\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nif (CR_CHAN(cmd->chanlist[i]) !=\r\n(startChan + i) % N_CHAN_AI) {\r\ncomedi_error(dev,\r\n"entries in chanlist must be consecutive channels, counting upwards\n");\r\nerr++;\r\n}\r\nif (CR_RANGE(cmd->chanlist[i]) != gain) {\r\ncomedi_error(dev,\r\n"entries in chanlist must all have the same gain\n");\r\nerr++;\r\n}\r\n}\r\n}\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int das800_ai_do_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nint startChan, endChan, scan, gain;\r\nint conv_bits;\r\nunsigned long irq_flags;\r\nstruct comedi_async *async = s->async;\r\nif (!dev->irq) {\r\ncomedi_error(dev,\r\n"no irq assigned for das-800, cannot do hardware conversions");\r\nreturn -1;\r\n}\r\ndisable_das800(dev);\r\nstartChan = CR_CHAN(async->cmd.chanlist[0]);\r\nendChan = (startChan + async->cmd.chanlist_len - 1) % 8;\r\nscan = (endChan << 3) | startChan;\r\nspin_lock_irqsave(&dev->spinlock, irq_flags);\r\noutb(SCAN_LIMITS, dev->iobase + DAS800_GAIN);\r\noutb(scan, dev->iobase + DAS800_SCAN_LIMITS);\r\nspin_unlock_irqrestore(&dev->spinlock, irq_flags);\r\ngain = CR_RANGE(async->cmd.chanlist[0]);\r\nif (thisboard->resolution == 12 && gain > 0)\r\ngain += 0x7;\r\ngain &= 0xf;\r\noutb(gain, dev->iobase + DAS800_GAIN);\r\nswitch (async->cmd.stop_src) {\r\ncase TRIG_COUNT:\r\ndevpriv->count = async->cmd.stop_arg * async->cmd.chanlist_len;\r\ndevpriv->forever = 0;\r\nbreak;\r\ncase TRIG_NONE:\r\ndevpriv->forever = 1;\r\ndevpriv->count = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nconv_bits = 0;\r\nconv_bits |= EACS | IEOC;\r\nif (async->cmd.start_src == TRIG_EXT)\r\nconv_bits |= DTEN;\r\nswitch (async->cmd.convert_src) {\r\ncase TRIG_TIMER:\r\nconv_bits |= CASC | ITE;\r\ni8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),\r\n&(devpriv->divisor2),\r\n&(async->cmd.convert_arg),\r\nasync->cmd.\r\nflags & TRIG_ROUND_MASK);\r\nif (das800_set_frequency(dev) < 0) {\r\ncomedi_error(dev, "Error setting up counters");\r\nreturn -1;\r\n}\r\nbreak;\r\ncase TRIG_EXT:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_lock_irqsave(&dev->spinlock, irq_flags);\r\noutb(CONV_CONTROL, dev->iobase + DAS800_GAIN);\r\noutb(conv_bits, dev->iobase + DAS800_CONV_CONTROL);\r\nspin_unlock_irqrestore(&dev->spinlock, irq_flags);\r\nasync->events = 0;\r\nenable_das800(dev);\r\nreturn 0;\r\n}\r\nstatic int das800_ai_rinsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint i, n;\r\nint chan;\r\nint range;\r\nint lsb, msb;\r\nint timeout = 1000;\r\nunsigned long irq_flags;\r\ndisable_das800(dev);\r\nchan = CR_CHAN(insn->chanspec);\r\nspin_lock_irqsave(&dev->spinlock, irq_flags);\r\noutb(CONTROL1, dev->iobase + DAS800_GAIN);\r\noutb(chan | devpriv->do_bits, dev->iobase + DAS800_CONTROL1);\r\nspin_unlock_irqrestore(&dev->spinlock, irq_flags);\r\nrange = CR_RANGE(insn->chanspec);\r\nif (thisboard->resolution == 12 && range)\r\nrange += 0x7;\r\nrange &= 0xf;\r\noutb(range, dev->iobase + DAS800_GAIN);\r\nudelay(5);\r\nfor (n = 0; n < insn->n; n++) {\r\noutb_p(0, dev->iobase + DAS800_MSB);\r\nfor (i = 0; i < timeout; i++) {\r\nif (!(inb(dev->iobase + DAS800_STATUS) & BUSY))\r\nbreak;\r\n}\r\nif (i == timeout) {\r\ncomedi_error(dev, "timeout");\r\nreturn -ETIME;\r\n}\r\nlsb = inb(dev->iobase + DAS800_LSB);\r\nmsb = inb(dev->iobase + DAS800_MSB);\r\nif (thisboard->resolution == 12) {\r\ndata[n] = (lsb >> 4) & 0xff;\r\ndata[n] |= (msb << 4);\r\n} else {\r\ndata[n] = (msb << 8) | lsb;\r\n}\r\n}\r\nreturn n;\r\n}\r\nstatic int das800_di_rbits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int bits;\r\nbits = inb(dev->iobase + DAS800_STATUS) >> 4;\r\nbits &= 0x7;\r\ndata[1] = bits;\r\ndata[0] = 0;\r\nreturn 2;\r\n}\r\nstatic int das800_do_wbits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint wbits;\r\nunsigned long irq_flags;\r\ndata[0] &= 0xf;\r\nwbits = devpriv->do_bits >> 4;\r\nwbits &= ~data[0];\r\nwbits |= data[0] & data[1];\r\ndevpriv->do_bits = wbits << 4;\r\nspin_lock_irqsave(&dev->spinlock, irq_flags);\r\noutb(CONTROL1, dev->iobase + DAS800_GAIN);\r\noutb(devpriv->do_bits | CONTROL1_INTE, dev->iobase + DAS800_CONTROL1);\r\nspin_unlock_irqrestore(&dev->spinlock, irq_flags);\r\ndata[1] = wbits;\r\nreturn 2;\r\n}\r\nstatic int das800_set_frequency(struct comedi_device *dev)\r\n{\r\nint err = 0;\r\nif (i8254_load(dev->iobase + DAS800_8254, 0, 1, devpriv->divisor1, 2))\r\nerr++;\r\nif (i8254_load(dev->iobase + DAS800_8254, 0, 2, devpriv->divisor2, 2))\r\nerr++;\r\nif (err)\r\nreturn -1;\r\nreturn 0;\r\n}
