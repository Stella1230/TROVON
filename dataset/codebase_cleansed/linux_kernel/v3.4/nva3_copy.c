static int\r\nnva3_copy_context_new(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct drm_nouveau_private *dev_priv = dev->dev_private;\r\nstruct nouveau_gpuobj *ramin = chan->ramin;\r\nstruct nouveau_gpuobj *ctx = NULL;\r\nint ret;\r\nNV_DEBUG(dev, "ch%d\n", chan->id);\r\nret = nouveau_gpuobj_new(dev, chan, 256, 0, NVOBJ_FLAG_ZERO_ALLOC |\r\nNVOBJ_FLAG_ZERO_FREE, &ctx);\r\nif (ret)\r\nreturn ret;\r\nnv_wo32(ramin, 0xc0, 0x00190000);\r\nnv_wo32(ramin, 0xc4, ctx->vinst + ctx->size - 1);\r\nnv_wo32(ramin, 0xc8, ctx->vinst);\r\nnv_wo32(ramin, 0xcc, 0x00000000);\r\nnv_wo32(ramin, 0xd0, 0x00000000);\r\nnv_wo32(ramin, 0xd4, 0x00000000);\r\ndev_priv->engine.instmem.flush(dev);\r\natomic_inc(&chan->vm->engref[engine]);\r\nchan->engctx[engine] = ctx;\r\nreturn 0;\r\n}\r\nstatic int\r\nnva3_copy_object_new(struct nouveau_channel *chan, int engine,\r\nu32 handle, u16 class)\r\n{\r\nstruct nouveau_gpuobj *ctx = chan->engctx[engine];\r\nctx->engine = 3;\r\nctx->class = class;\r\nreturn nouveau_ramht_insert(chan, handle, ctx);\r\n}\r\nstatic void\r\nnva3_copy_context_del(struct nouveau_channel *chan, int engine)\r\n{\r\nstruct nouveau_gpuobj *ctx = chan->engctx[engine];\r\nstruct drm_device *dev = chan->dev;\r\nu32 inst;\r\ninst = (chan->ramin->vinst >> 12);\r\ninst |= 0x40000000;\r\nnv_wr32(dev, 0x104048, 0x00000000);\r\nif (nv_rd32(dev, 0x104050) == inst)\r\nnv_mask(dev, 0x104050, 0x40000000, 0x00000000);\r\nif (nv_rd32(dev, 0x104054) == inst)\r\nnv_mask(dev, 0x104054, 0x40000000, 0x00000000);\r\nnv_wr32(dev, 0x104048, 0x00000003);\r\nfor (inst = 0xc0; inst <= 0xd4; inst += 4)\r\nnv_wo32(chan->ramin, inst, 0x00000000);\r\nnouveau_gpuobj_ref(NULL, &ctx);\r\natomic_dec(&chan->vm->engref[engine]);\r\nchan->engctx[engine] = ctx;\r\n}\r\nstatic void\r\nnva3_copy_tlb_flush(struct drm_device *dev, int engine)\r\n{\r\nnv50_vm_flush_engine(dev, 0x0d);\r\n}\r\nstatic int\r\nnva3_copy_init(struct drm_device *dev, int engine)\r\n{\r\nint i;\r\nnv_mask(dev, 0x000200, 0x00002000, 0x00000000);\r\nnv_mask(dev, 0x000200, 0x00002000, 0x00002000);\r\nnv_wr32(dev, 0x104014, 0xffffffff);\r\nnv_wr32(dev, 0x1041c0, 0x01000000);\r\nfor (i = 0; i < sizeof(nva3_pcopy_data) / 4; i++)\r\nnv_wr32(dev, 0x1041c4, nva3_pcopy_data[i]);\r\nnv_wr32(dev, 0x104180, 0x01000000);\r\nfor (i = 0; i < sizeof(nva3_pcopy_code) / 4; i++) {\r\nif ((i & 0x3f) == 0)\r\nnv_wr32(dev, 0x104188, i >> 6);\r\nnv_wr32(dev, 0x104184, nva3_pcopy_code[i]);\r\n}\r\nnv_wr32(dev, 0x10410c, 0x00000000);\r\nnv_wr32(dev, 0x104104, 0x00000000);\r\nnv_wr32(dev, 0x104100, 0x00000002);\r\nreturn 0;\r\n}\r\nstatic int\r\nnva3_copy_fini(struct drm_device *dev, int engine, bool suspend)\r\n{\r\nnv_mask(dev, 0x104048, 0x00000003, 0x00000000);\r\nnv_wait(dev, 0x104008, 0x0000000c, 0x00000000);\r\nnv_mask(dev, 0x104054, 0x40000000, 0x00000000);\r\nnv_wr32(dev, 0x104000, 0x00000008);\r\nnv_wait(dev, 0x104008, 0x00000008, 0x00000000);\r\nnv_wr32(dev, 0x104014, 0xffffffff);\r\nreturn 0;\r\n}\r\nstatic void\r\nnva3_copy_isr(struct drm_device *dev)\r\n{\r\nu32 dispatch = nv_rd32(dev, 0x10401c);\r\nu32 stat = nv_rd32(dev, 0x104008) & dispatch & ~(dispatch >> 16);\r\nu32 inst = nv_rd32(dev, 0x104050) & 0x3fffffff;\r\nu32 ssta = nv_rd32(dev, 0x104040) & 0x0000ffff;\r\nu32 addr = nv_rd32(dev, 0x104040) >> 16;\r\nu32 mthd = (addr & 0x07ff) << 2;\r\nu32 subc = (addr & 0x3800) >> 11;\r\nu32 data = nv_rd32(dev, 0x104044);\r\nint chid = nv50_graph_isr_chid(dev, inst);\r\nif (stat & 0x00000040) {\r\nNV_INFO(dev, "PCOPY: DISPATCH_ERROR [");\r\nnouveau_enum_print(nva3_copy_isr_error_name, ssta);\r\nprintk("] ch %d [0x%08x] subc %d mthd 0x%04x data 0x%08x\n",\r\nchid, inst, subc, mthd, data);\r\nnv_wr32(dev, 0x104004, 0x00000040);\r\nstat &= ~0x00000040;\r\n}\r\nif (stat) {\r\nNV_INFO(dev, "PCOPY: unhandled intr 0x%08x\n", stat);\r\nnv_wr32(dev, 0x104004, stat);\r\n}\r\nnv50_fb_vm_trap(dev, 1);\r\n}\r\nstatic void\r\nnva3_copy_destroy(struct drm_device *dev, int engine)\r\n{\r\nstruct nva3_copy_engine *pcopy = nv_engine(dev, engine);\r\nnouveau_irq_unregister(dev, 22);\r\nNVOBJ_ENGINE_DEL(dev, COPY0);\r\nkfree(pcopy);\r\n}\r\nint\r\nnva3_copy_create(struct drm_device *dev)\r\n{\r\nstruct nva3_copy_engine *pcopy;\r\npcopy = kzalloc(sizeof(*pcopy), GFP_KERNEL);\r\nif (!pcopy)\r\nreturn -ENOMEM;\r\npcopy->base.destroy = nva3_copy_destroy;\r\npcopy->base.init = nva3_copy_init;\r\npcopy->base.fini = nva3_copy_fini;\r\npcopy->base.context_new = nva3_copy_context_new;\r\npcopy->base.context_del = nva3_copy_context_del;\r\npcopy->base.object_new = nva3_copy_object_new;\r\npcopy->base.tlb_flush = nva3_copy_tlb_flush;\r\nnouveau_irq_register(dev, 22, nva3_copy_isr);\r\nNVOBJ_ENGINE_ADD(dev, COPY0, &pcopy->base);\r\nNVOBJ_CLASS(dev, 0x85b5, COPY0);\r\nreturn 0;\r\n}
