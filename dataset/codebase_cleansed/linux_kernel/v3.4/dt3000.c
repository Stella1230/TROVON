static int __devinit driver_dt3000_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nreturn comedi_pci_auto_config(dev, driver_dt3000.driver_name);\r\n}\r\nstatic void __devexit driver_dt3000_pci_remove(struct pci_dev *dev)\r\n{\r\ncomedi_pci_auto_unconfig(dev);\r\n}\r\nstatic int __init driver_dt3000_init_module(void)\r\n{\r\nint retval;\r\nretval = comedi_driver_register(&driver_dt3000);\r\nif (retval < 0)\r\nreturn retval;\r\ndriver_dt3000_pci_driver.name = (char *)driver_dt3000.driver_name;\r\nreturn pci_register_driver(&driver_dt3000_pci_driver);\r\n}\r\nstatic void __exit driver_dt3000_cleanup_module(void)\r\n{\r\npci_unregister_driver(&driver_dt3000_pci_driver);\r\ncomedi_driver_unregister(&driver_dt3000);\r\n}\r\nstatic int dt3k_send_cmd(struct comedi_device *dev, unsigned int cmd)\r\n{\r\nint i;\r\nunsigned int status = 0;\r\nwritew(cmd, devpriv->io_addr + DPR_Command_Mbx);\r\nfor (i = 0; i < TIMEOUT; i++) {\r\nstatus = readw(devpriv->io_addr + DPR_Command_Mbx);\r\nif ((status & DT3000_COMPLETION_MASK) != DT3000_NOTPROCESSED)\r\nbreak;\r\nudelay(1);\r\n}\r\nif ((status & DT3000_COMPLETION_MASK) == DT3000_NOERROR)\r\nreturn 0;\r\ndev_dbg(dev->hw_dev, "dt3k_send_cmd() timeout/error status=0x%04x\n",\r\nstatus);\r\nreturn -ETIME;\r\n}\r\nstatic unsigned int dt3k_readsingle(struct comedi_device *dev,\r\nunsigned int subsys, unsigned int chan,\r\nunsigned int gain)\r\n{\r\nwritew(subsys, devpriv->io_addr + DPR_SubSys);\r\nwritew(chan, devpriv->io_addr + DPR_Params(0));\r\nwritew(gain, devpriv->io_addr + DPR_Params(1));\r\ndt3k_send_cmd(dev, CMD_READSINGLE);\r\nreturn readw(devpriv->io_addr + DPR_Params(2));\r\n}\r\nstatic void dt3k_writesingle(struct comedi_device *dev, unsigned int subsys,\r\nunsigned int chan, unsigned int data)\r\n{\r\nwritew(subsys, devpriv->io_addr + DPR_SubSys);\r\nwritew(chan, devpriv->io_addr + DPR_Params(0));\r\nwritew(0, devpriv->io_addr + DPR_Params(1));\r\nwritew(data, devpriv->io_addr + DPR_Params(2));\r\ndt3k_send_cmd(dev, CMD_WRITESINGLE);\r\n}\r\nstatic irqreturn_t dt3k_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s;\r\nunsigned int status;\r\nif (!dev->attached)\r\nreturn IRQ_NONE;\r\ns = dev->subdevices + 0;\r\nstatus = readw(devpriv->io_addr + DPR_Intr_Flag);\r\n#ifdef DEBUG\r\ndebug_intr_flags(status);\r\n#endif\r\nif (status & DT3000_ADFULL) {\r\ndt3k_ai_empty_fifo(dev, s);\r\ns->async->events |= COMEDI_CB_BLOCK;\r\n}\r\nif (status & (DT3000_ADSWERR | DT3000_ADHWERR))\r\ns->async->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;\r\ndebug_n_ints++;\r\nif (debug_n_ints >= 10) {\r\ndt3k_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA;\r\n}\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void debug_intr_flags(unsigned int flags)\r\n{\r\nint i;\r\nprintk(KERN_DEBUG "dt3k: intr_flags:");\r\nfor (i = 0; i < 8; i++) {\r\nif (flags & (1 << i))\r\nprintk(KERN_CONT " %s", intr_flags[i]);\r\n}\r\nprintk(KERN_CONT "\n");\r\n}\r\nstatic void dt3k_ai_empty_fifo(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nint front;\r\nint rear;\r\nint count;\r\nint i;\r\nshort data;\r\nfront = readw(devpriv->io_addr + DPR_AD_Buf_Front);\r\ncount = front - devpriv->ai_front;\r\nif (count < 0)\r\ncount += AI_FIFO_DEPTH;\r\ndev_dbg(dev->hw_dev, "reading %d samples\n", count);\r\nrear = devpriv->ai_rear;\r\nfor (i = 0; i < count; i++) {\r\ndata = readw(devpriv->io_addr + DPR_ADC_buffer + rear);\r\ncomedi_buf_put(s->async, data);\r\nrear++;\r\nif (rear >= AI_FIFO_DEPTH)\r\nrear = 0;\r\n}\r\ndevpriv->ai_rear = rear;\r\nwritew(rear, devpriv->io_addr + DPR_AD_Buf_Rear);\r\n}\r\nstatic int dt3k_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp;\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_TIMER;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_TIMER;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (cmd->scan_begin_arg < this_board->ai_speed) {\r\ncmd->scan_begin_arg = this_board->ai_speed;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_arg > 100 * 16 * 65535) {\r\ncmd->scan_begin_arg = 100 * 16 * 65535;\r\nerr++;\r\n}\r\n} else {\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (cmd->convert_arg < this_board->ai_speed) {\r\ncmd->convert_arg = this_board->ai_speed;\r\nerr++;\r\n}\r\nif (cmd->convert_arg > 50 * 16 * 65535) {\r\ncmd->convert_arg = 50 * 16 * 65535;\r\nerr++;\r\n}\r\n} else {\r\n}\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (cmd->stop_arg > 0x00ffffff) {\r\ncmd->stop_arg = 0x00ffffff;\r\nerr++;\r\n}\r\n} else {\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ntmp = cmd->scan_begin_arg;\r\ndt3k_ns_to_timer(100, &cmd->scan_begin_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (tmp != cmd->scan_begin_arg)\r\nerr++;\r\n} else {\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ntmp = cmd->convert_arg;\r\ndt3k_ns_to_timer(50, &cmd->convert_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (tmp != cmd->convert_arg)\r\nerr++;\r\nif (cmd->scan_begin_src == TRIG_TIMER &&\r\ncmd->scan_begin_arg <\r\ncmd->convert_arg * cmd->scan_end_arg) {\r\ncmd->scan_begin_arg =\r\ncmd->convert_arg * cmd->scan_end_arg;\r\nerr++;\r\n}\r\n} else {\r\n}\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int dt3k_ns_to_timer(unsigned int timer_base, unsigned int *nanosec,\r\nunsigned int round_mode)\r\n{\r\nint divider, base, prescale;\r\nfor (prescale = 0; prescale < 16; prescale++) {\r\nbase = timer_base * (prescale + 1);\r\nswitch (round_mode) {\r\ncase TRIG_ROUND_NEAREST:\r\ndefault:\r\ndivider = (*nanosec + base / 2) / base;\r\nbreak;\r\ncase TRIG_ROUND_DOWN:\r\ndivider = (*nanosec) / base;\r\nbreak;\r\ncase TRIG_ROUND_UP:\r\ndivider = (*nanosec) / base;\r\nbreak;\r\n}\r\nif (divider < 65536) {\r\n*nanosec = divider * base;\r\nreturn (prescale << 16) | (divider);\r\n}\r\n}\r\nprescale = 15;\r\nbase = timer_base * (1 << prescale);\r\ndivider = 65535;\r\n*nanosec = divider * base;\r\nreturn (prescale << 16) | (divider);\r\n}\r\nstatic int dt3k_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint i;\r\nunsigned int chan, range, aref;\r\nunsigned int divider;\r\nunsigned int tscandiv;\r\nint ret;\r\nunsigned int mode;\r\ndev_dbg(dev->hw_dev, "dt3k_ai_cmd:\n");\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nchan = CR_CHAN(cmd->chanlist[i]);\r\nrange = CR_RANGE(cmd->chanlist[i]);\r\nwritew((range << 6) | chan,\r\ndevpriv->io_addr + DPR_ADC_buffer + i);\r\n}\r\naref = CR_AREF(cmd->chanlist[0]);\r\nwritew(cmd->scan_end_arg, devpriv->io_addr + DPR_Params(0));\r\ndev_dbg(dev->hw_dev, "param[0]=0x%04x\n", cmd->scan_end_arg);\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ndivider = dt3k_ns_to_timer(50, &cmd->convert_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nwritew((divider >> 16), devpriv->io_addr + DPR_Params(1));\r\ndev_dbg(dev->hw_dev, "param[1]=0x%04x\n", divider >> 16);\r\nwritew((divider & 0xffff), devpriv->io_addr + DPR_Params(2));\r\ndev_dbg(dev->hw_dev, "param[2]=0x%04x\n", divider & 0xffff);\r\n} else {\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\ntscandiv = dt3k_ns_to_timer(100, &cmd->scan_begin_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nwritew((tscandiv >> 16), devpriv->io_addr + DPR_Params(3));\r\ndev_dbg(dev->hw_dev, "param[3]=0x%04x\n", tscandiv >> 16);\r\nwritew((tscandiv & 0xffff), devpriv->io_addr + DPR_Params(4));\r\ndev_dbg(dev->hw_dev, "param[4]=0x%04x\n", tscandiv & 0xffff);\r\n} else {\r\n}\r\nmode = DT3000_AD_RETRIG_INTERNAL | 0 | 0;\r\nwritew(mode, devpriv->io_addr + DPR_Params(5));\r\ndev_dbg(dev->hw_dev, "param[5]=0x%04x\n", mode);\r\nwritew(aref == AREF_DIFF, devpriv->io_addr + DPR_Params(6));\r\ndev_dbg(dev->hw_dev, "param[6]=0x%04x\n", aref == AREF_DIFF);\r\nwritew(AI_FIFO_DEPTH / 2, devpriv->io_addr + DPR_Params(7));\r\ndev_dbg(dev->hw_dev, "param[7]=0x%04x\n", AI_FIFO_DEPTH / 2);\r\nwritew(SUBS_AI, devpriv->io_addr + DPR_SubSys);\r\nret = dt3k_send_cmd(dev, CMD_CONFIG);\r\nwritew(DT3000_ADFULL | DT3000_ADSWERR | DT3000_ADHWERR,\r\ndevpriv->io_addr + DPR_Int_Mask);\r\ndebug_n_ints = 0;\r\nwritew(SUBS_AI, devpriv->io_addr + DPR_SubSys);\r\nret = dt3k_send_cmd(dev, CMD_START);\r\nreturn 0;\r\n}\r\nstatic int dt3k_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nint ret;\r\nwritew(SUBS_AI, devpriv->io_addr + DPR_SubSys);\r\nret = dt3k_send_cmd(dev, CMD_STOP);\r\nwritew(0, devpriv->io_addr + DPR_Int_Mask);\r\nreturn 0;\r\n}\r\nstatic int dt3k_ai_insn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i;\r\nunsigned int chan, gain, aref;\r\nchan = CR_CHAN(insn->chanspec);\r\ngain = CR_RANGE(insn->chanspec);\r\naref = CR_AREF(insn->chanspec);\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = dt3k_readsingle(dev, SUBS_AI, chan, gain);\r\nreturn i;\r\n}\r\nstatic int dt3k_ao_insn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i;\r\nunsigned int chan;\r\nchan = CR_CHAN(insn->chanspec);\r\nfor (i = 0; i < insn->n; i++) {\r\ndt3k_writesingle(dev, SUBS_AO, chan, data[i]);\r\ndevpriv->ao_readback[chan] = data[i];\r\n}\r\nreturn i;\r\n}\r\nstatic int dt3k_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i;\r\nunsigned int chan;\r\nchan = CR_CHAN(insn->chanspec);\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = devpriv->ao_readback[chan];\r\nreturn i;\r\n}\r\nstatic void dt3k_dio_config(struct comedi_device *dev, int bits)\r\n{\r\nwritew(SUBS_DOUT, devpriv->io_addr + DPR_SubSys);\r\nwritew(bits, devpriv->io_addr + DPR_Params(0));\r\n#if 0\r\nwritew(0, devpriv->io_addr + DPR_Params(1));\r\nwritew(0, devpriv->io_addr + DPR_Params(2));\r\n#endif\r\ndt3k_send_cmd(dev, CMD_CONFIG);\r\n}\r\nstatic int dt3k_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint mask;\r\nmask = (CR_CHAN(insn->chanspec) < 4) ? 0x0f : 0xf0;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIO_OUTPUT:\r\ns->io_bits |= mask;\r\nbreak;\r\ncase INSN_CONFIG_DIO_INPUT:\r\ns->io_bits &= ~mask;\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\ndata[1] =\r\n(s->\r\nio_bits & (1 << CR_CHAN(insn->chanspec))) ? COMEDI_OUTPUT :\r\nCOMEDI_INPUT;\r\nreturn insn->n;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nmask = (s->io_bits & 0x01) | ((s->io_bits & 0x10) >> 3);\r\ndt3k_dio_config(dev, mask);\r\nreturn insn->n;\r\n}\r\nstatic int dt3k_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nif (insn->n != 2)\r\nreturn -EINVAL;\r\nif (data[0]) {\r\ns->state &= ~data[0];\r\ns->state |= data[1] & data[0];\r\ndt3k_writesingle(dev, SUBS_DOUT, 0, s->state);\r\n}\r\ndata[1] = dt3k_readsingle(dev, SUBS_DIN, 0, 0);\r\nreturn 2;\r\n}\r\nstatic int dt3k_mem_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int addr = CR_CHAN(insn->chanspec);\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\nwritew(SUBS_MEM, devpriv->io_addr + DPR_SubSys);\r\nwritew(addr, devpriv->io_addr + DPR_Params(0));\r\nwritew(1, devpriv->io_addr + DPR_Params(1));\r\ndt3k_send_cmd(dev, CMD_READCODE);\r\ndata[i] = readw(devpriv->io_addr + DPR_Params(2));\r\n}\r\nreturn i;\r\n}\r\nstatic int dt3000_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nint bus, slot;\r\nint ret = 0;\r\ndev_dbg(dev->hw_dev, "dt3000:\n");\r\nbus = it->options[0];\r\nslot = it->options[1];\r\nret = alloc_private(dev, sizeof(struct dt3k_private));\r\nif (ret < 0)\r\nreturn ret;\r\nret = dt_pci_probe(dev, bus, slot);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret == 0) {\r\ndev_warn(dev->hw_dev, "no DT board found\n");\r\nreturn -ENODEV;\r\n}\r\ndev->board_name = this_board->name;\r\nif (request_irq(devpriv->pci_dev->irq, dt3k_interrupt, IRQF_SHARED,\r\n"dt3000", dev)) {\r\ndev_err(dev->hw_dev, "unable to allocate IRQ %u\n",\r\ndevpriv->pci_dev->irq);\r\nreturn -EINVAL;\r\n}\r\ndev->irq = devpriv->pci_dev->irq;\r\nret = alloc_subdevices(dev, 4);\r\nif (ret < 0)\r\nreturn ret;\r\ns = dev->subdevices;\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF | SDF_CMD_READ;\r\ns->n_chan = this_board->adchan;\r\ns->insn_read = dt3k_ai_insn;\r\ns->maxdata = (1 << this_board->adbits) - 1;\r\ns->len_chanlist = 512;\r\ns->range_table = &range_dt3000_ai;\r\ns->do_cmd = dt3k_ai_cmd;\r\ns->do_cmdtest = dt3k_ai_cmdtest;\r\ns->cancel = dt3k_ai_cancel;\r\ns++;\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 2;\r\ns->insn_read = dt3k_ao_insn_read;\r\ns->insn_write = dt3k_ao_insn;\r\ns->maxdata = (1 << this_board->dabits) - 1;\r\ns->len_chanlist = 1;\r\ns->range_table = &range_bipolar10;\r\ns++;\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 8;\r\ns->insn_config = dt3k_dio_insn_config;\r\ns->insn_bits = dt3k_dio_insn_bits;\r\ns->maxdata = 1;\r\ns->len_chanlist = 8;\r\ns->range_table = &range_digital;\r\ns++;\r\ns->type = COMEDI_SUBD_MEMORY;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 0x1000;\r\ns->insn_read = dt3k_mem_insn_read;\r\ns->maxdata = 0xff;\r\ns->len_chanlist = 1;\r\ns->range_table = &range_unknown;\r\n#if 0\r\ns++;\r\ns->type = COMEDI_SUBD_PROC;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int dt3000_detach(struct comedi_device *dev)\r\n{\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (devpriv) {\r\nif (devpriv->pci_dev) {\r\nif (devpriv->phys_addr)\r\ncomedi_pci_disable(devpriv->pci_dev);\r\npci_dev_put(devpriv->pci_dev);\r\n}\r\nif (devpriv->io_addr)\r\niounmap(devpriv->io_addr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dt_pci_probe(struct comedi_device *dev, int bus, int slot)\r\n{\r\nint board;\r\nint ret;\r\nstruct pci_dev *pcidev;\r\npcidev = NULL;\r\nwhile ((pcidev = dt_pci_find_device(pcidev, &board)) != NULL) {\r\nif ((bus == 0 && slot == 0) ||\r\n(pcidev->bus->number == bus &&\r\nPCI_SLOT(pcidev->devfn) == slot)) {\r\nbreak;\r\n}\r\n}\r\ndevpriv->pci_dev = pcidev;\r\nif (board >= 0)\r\ndev->board_ptr = dt3k_boardtypes + board;\r\nif (!devpriv->pci_dev)\r\nreturn 0;\r\nret = setup_pci(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 1;\r\n}\r\nstatic int setup_pci(struct comedi_device *dev)\r\n{\r\nresource_size_t addr;\r\nint ret;\r\nret = comedi_pci_enable(devpriv->pci_dev, "dt3000");\r\nif (ret < 0)\r\nreturn ret;\r\naddr = pci_resource_start(devpriv->pci_dev, 0);\r\ndevpriv->phys_addr = addr;\r\ndevpriv->io_addr = ioremap(devpriv->phys_addr, DT3000_SIZE);\r\nif (!devpriv->io_addr)\r\nreturn -ENOMEM;\r\n#if DEBUG\r\nprintk("0x%08llx mapped to %p, ",\r\n(unsigned long long)devpriv->phys_addr, devpriv->io_addr);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic struct pci_dev *dt_pci_find_device(struct pci_dev *from, int *board)\r\n{\r\nint i;\r\nfor (from = pci_get_device(PCI_VENDOR_ID_DT, PCI_ANY_ID, from);\r\nfrom != NULL;\r\nfrom = pci_get_device(PCI_VENDOR_ID_DT, PCI_ANY_ID, from)) {\r\nfor (i = 0; i < n_dt3k_boards; i++) {\r\nif (from->device == dt3k_boardtypes[i].device_id) {\r\n*board = i;\r\nreturn from;\r\n}\r\n}\r\nprintk\r\n("unknown Data Translation PCI device found with device_id=0x%04x\n",\r\nfrom->device);\r\n}\r\n*board = -1;\r\nreturn from;\r\n}
