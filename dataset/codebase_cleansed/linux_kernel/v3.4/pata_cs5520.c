static void cs5520_set_timings(struct ata_port *ap, struct ata_device *adev, int pio)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nint slave = adev->devno;\r\npio -= XFER_PIO_0;\r\npci_write_config_byte(pdev, 0x62 + ap->port_no,\r\n(cs5520_pio_clocks[pio].recovery << 4) |\r\n(cs5520_pio_clocks[pio].assert));\r\npci_write_config_byte(pdev, 0x64 + 4*ap->port_no + slave,\r\n(cs5520_pio_clocks[pio].recovery << 4) |\r\n(cs5520_pio_clocks[pio].assert));\r\npci_write_config_byte(pdev, 0x66 + 4*ap->port_no + slave,\r\n(cs5520_pio_clocks[pio].recovery << 4) |\r\n(cs5520_pio_clocks[pio].assert));\r\n}\r\nstatic void cs5520_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\ncs5520_set_timings(ap, adev, adev->pio_mode);\r\n}\r\nstatic int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstatic const unsigned int cmd_port[] = { 0x1F0, 0x170 };\r\nstatic const unsigned int ctl_port[] = { 0x3F6, 0x376 };\r\nstruct ata_port_info pi = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.port_ops = &cs5520_port_ops,\r\n};\r\nconst struct ata_port_info *ppi[2];\r\nu8 pcicfg;\r\nvoid __iomem *iomap[5];\r\nstruct ata_host *host;\r\nstruct ata_ioports *ioaddr;\r\nint i, rc;\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\npci_read_config_byte(pdev, 0x60, &pcicfg);\r\nif ((pcicfg & 3) == 0)\r\nreturn -ENODEV;\r\nppi[0] = ppi[1] = &ata_dummy_port_info;\r\nif (pcicfg & 1)\r\nppi[0] = &pi;\r\nif (pcicfg & 2)\r\nppi[1] = &pi;\r\nif ((pcicfg & 0x40) == 0) {\r\ndev_warn(&pdev->dev, "DMA mode disabled. Enabling.\n");\r\npci_write_config_byte(pdev, 0x60, pcicfg | 0x40);\r\n}\r\npi.mwdma_mask = id->driver_data;\r\nhost = ata_host_alloc_pinfo(&pdev->dev, ppi, 2);\r\nif (!host)\r\nreturn -ENOMEM;\r\nif (pci_enable_device_io(pdev)) {\r\nprintk(KERN_ERR DRV_NAME ": unable to configure BAR2.\n");\r\nreturn -ENODEV;\r\n}\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\nprintk(KERN_ERR DRV_NAME ": unable to configure DMA mask.\n");\r\nreturn -ENODEV;\r\n}\r\nif (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\nprintk(KERN_ERR DRV_NAME ": unable to configure consistent DMA mask.\n");\r\nreturn -ENODEV;\r\n}\r\niomap[0] = devm_ioport_map(&pdev->dev, cmd_port[0], 8);\r\niomap[1] = devm_ioport_map(&pdev->dev, ctl_port[0], 1);\r\niomap[2] = devm_ioport_map(&pdev->dev, cmd_port[1], 8);\r\niomap[3] = devm_ioport_map(&pdev->dev, ctl_port[1], 1);\r\niomap[4] = pcim_iomap(pdev, 2, 0);\r\nif (!iomap[0] || !iomap[1] || !iomap[2] || !iomap[3] || !iomap[4])\r\nreturn -ENOMEM;\r\nioaddr = &host->ports[0]->ioaddr;\r\nioaddr->cmd_addr = iomap[0];\r\nioaddr->ctl_addr = iomap[1];\r\nioaddr->altstatus_addr = iomap[1];\r\nioaddr->bmdma_addr = iomap[4];\r\nata_sff_std_ports(ioaddr);\r\nata_port_desc(host->ports[0],\r\n"cmd 0x%x ctl 0x%x", cmd_port[0], ctl_port[0]);\r\nata_port_pbar_desc(host->ports[0], 4, 0, "bmdma");\r\nioaddr = &host->ports[1]->ioaddr;\r\nioaddr->cmd_addr = iomap[2];\r\nioaddr->ctl_addr = iomap[3];\r\nioaddr->altstatus_addr = iomap[3];\r\nioaddr->bmdma_addr = iomap[4] + 8;\r\nata_sff_std_ports(ioaddr);\r\nata_port_desc(host->ports[1],\r\n"cmd 0x%x ctl 0x%x", cmd_port[1], ctl_port[1]);\r\nata_port_pbar_desc(host->ports[1], 4, 8, "bmdma");\r\npci_set_master(pdev);\r\nrc = ata_host_start(host);\r\nif (rc)\r\nreturn rc;\r\nfor (i = 0; i < 2; i++) {\r\nstatic const int irq[] = { 14, 15 };\r\nstruct ata_port *ap = host->ports[i];\r\nif (ata_port_is_dummy(ap))\r\ncontinue;\r\nrc = devm_request_irq(&pdev->dev, irq[ap->port_no],\r\nata_bmdma_interrupt, 0, DRV_NAME, host);\r\nif (rc)\r\nreturn rc;\r\nata_port_desc(ap, "irq %d", irq[i]);\r\n}\r\nreturn ata_host_register(host, &cs5520_sht);\r\n}\r\nstatic int cs5520_reinit_one(struct pci_dev *pdev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(&pdev->dev);\r\nu8 pcicfg;\r\nint rc;\r\nrc = ata_pci_device_do_resume(pdev);\r\nif (rc)\r\nreturn rc;\r\npci_read_config_byte(pdev, 0x60, &pcicfg);\r\nif ((pcicfg & 0x40) == 0)\r\npci_write_config_byte(pdev, 0x60, pcicfg | 0x40);\r\nata_host_resume(host);\r\nreturn 0;\r\n}\r\nstatic int cs5520_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(&pdev->dev);\r\nint rc = 0;\r\nrc = ata_host_suspend(host, mesg);\r\nif (rc)\r\nreturn rc;\r\npci_save_state(pdev);\r\nreturn 0;\r\n}\r\nstatic int __init cs5520_init(void)\r\n{\r\nreturn pci_register_driver(&cs5520_pci_driver);\r\n}\r\nstatic void __exit cs5520_exit(void)\r\n{\r\npci_unregister_driver(&cs5520_pci_driver);\r\n}
