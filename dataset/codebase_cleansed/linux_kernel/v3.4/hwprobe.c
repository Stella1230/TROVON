void __init\r\nshow_two (hdw_info_t * hi, int brdno)\r\n{\r\nci_t *ci;\r\nstruct pci_dev *pdev;\r\nchar *bid;\r\nchar *bp, banner[80];\r\nchar sn[6];\r\nbp = banner;\r\nmemset (banner, 0, 80);\r\nci = (ci_t *)(netdev_priv(hi->ndev));\r\nbid = sbeid_get_bdname (ci);\r\nswitch (hi->promfmt)\r\n{\r\ncase PROM_FORMAT_TYPE1:\r\nmemcpy (sn, (FLD_TYPE1 *) (hi->mfg_info.pft1.Serial), 6);\r\nbreak;\r\ncase PROM_FORMAT_TYPE2:\r\nmemcpy (sn, (FLD_TYPE2 *) (hi->mfg_info.pft2.Serial), 6);\r\nbreak;\r\ndefault:\r\nmemset (sn, 0, 6);\r\nbreak;\r\n}\r\nsprintf (banner, "%s: %s S/N %06X, MUSYCC Rev %02X",\r\nhi->devname, bid,\r\n((sn[3] << 16) & 0xff0000) |\r\n((sn[4] << 8) & 0x00ff00) |\r\n(sn[5] & 0x0000ff),\r\n(u_int8_t) hi->revid[0]);\r\npr_info("%s\n", banner);\r\npdev = hi->pdev[0];\r\npr_info("%s: %s at v/p=%lx/%lx (%02x:%02x.%x) irq %d\n",\r\nhi->devname, "MUSYCC",\r\n(unsigned long) hi->addr_mapped[0], hi->addr[0],\r\nhi->pci_busno, (u_int8_t) PCI_SLOT (pdev->devfn),\r\n(u_int8_t) PCI_FUNC (pdev->devfn), pdev->irq);\r\npdev = hi->pdev[1];\r\npr_info("%s: %s at v/p=%lx/%lx (%02x:%02x.%x) irq %d\n",\r\nhi->devname, "EBUS ",\r\n(unsigned long) hi->addr_mapped[1], hi->addr[1],\r\nhi->pci_busno, (u_int8_t) PCI_SLOT (pdev->devfn),\r\n(u_int8_t) PCI_FUNC (pdev->devfn), pdev->irq);\r\n}\r\nvoid __init\r\nhdw_sn_get (hdw_info_t * hi, int brdno)\r\n{\r\nlong addr;\r\naddr = (long) hi->addr_mapped[1] + EEPROM_OFFSET;\r\npmc_eeprom_read_buffer (addr, 0, (char *) hi->mfg_info.data, sizeof (FLD_TYPE2));\r\n#if 0\r\n{\r\nunsigned char *ucp = (unsigned char *) &hi->mfg_info.data;\r\npr_info("eeprom[00]: %02x %02x %02x %02x %02x %02x %02x %02x\n",\r\n*(ucp + 0), *(ucp + 1), *(ucp + 2), *(ucp + 3), *(ucp + 4), *(ucp + 5), *(ucp + 6), *(ucp + 7));\r\npr_info("eeprom[08]: %02x %02x %02x %02x %02x %02x %02x %02x\n",\r\n*(ucp + 8), *(ucp + 9), *(ucp + 10), *(ucp + 11), *(ucp + 12), *(ucp + 13), *(ucp + 14), *(ucp + 15));\r\npr_info("eeprom[16]: %02x %02x %02x %02x %02x %02x %02x %02x\n",\r\n*(ucp + 16), *(ucp + 17), *(ucp + 18), *(ucp + 19), *(ucp + 20), *(ucp + 21), *(ucp + 22), *(ucp + 23));\r\npr_info("eeprom[24]: %02x %02x %02x %02x %02x %02x %02x %02x\n",\r\n*(ucp + 24), *(ucp + 25), *(ucp + 26), *(ucp + 27), *(ucp + 28), *(ucp + 29), *(ucp + 30), *(ucp + 31));\r\npr_info("eeprom[32]: %02x %02x %02x %02x %02x %02x %02x %02x\n",\r\n*(ucp + 32), *(ucp + 33), *(ucp + 34), *(ucp + 35), *(ucp + 36), *(ucp + 37), *(ucp + 38), *(ucp + 39));\r\npr_info("eeprom[40]: %02x %02x %02x %02x %02x %02x %02x %02x\n",\r\n*(ucp + 40), *(ucp + 41), *(ucp + 42), *(ucp + 43), *(ucp + 44), *(ucp + 45), *(ucp + 46), *(ucp + 47));\r\n}\r\n#endif\r\n#if 0\r\npr_info("sn: %x %x %x %x %x %x\n",\r\nhi->mfg_info.Serial[0],\r\nhi->mfg_info.Serial[1],\r\nhi->mfg_info.Serial[2],\r\nhi->mfg_info.Serial[3],\r\nhi->mfg_info.Serial[4],\r\nhi->mfg_info.Serial[5]);\r\n#endif\r\nif ((hi->promfmt = pmc_verify_cksum (&hi->mfg_info.data)) == PROM_FORMAT_Unk)\r\n{\r\nif (cxt1e1_log_level >= LOG_WARN)\r\npr_info("%s: EEPROM cksum error\n", hi->devname);\r\nhi->mfg_info_sts = EEPROM_CRCERR;\r\n} else\r\nhi->mfg_info_sts = EEPROM_OK;\r\n}\r\nvoid __init\r\nprep_hdw_info (void)\r\n{\r\nhdw_info_t *hi;\r\nint i;\r\nfor (i = 0, hi = hdw_info; i < MAX_BOARDS; i++, hi++)\r\n{\r\nhi->pci_busno = 0xff;\r\nhi->pci_slot = 0xff;\r\nhi->pci_pin[0] = 0;\r\nhi->pci_pin[1] = 0;\r\nhi->ndev = 0;\r\nhi->addr[0] = 0L;\r\nhi->addr[1] = 0L;\r\nhi->addr_mapped[0] = 0L;\r\nhi->addr_mapped[1] = 0L;\r\n}\r\n}\r\nvoid\r\ncleanup_ioremap (void)\r\n{\r\nhdw_info_t *hi;\r\nint i;\r\nfor (i = 0, hi = hdw_info; i < MAX_BOARDS; i++, hi++)\r\n{\r\nif (hi->pci_slot == 0xff)\r\nbreak;\r\nif (hi->addr_mapped[0])\r\n{\r\niounmap ((void *) (hi->addr_mapped[0]));\r\nrelease_mem_region ((long) hi->addr[0], hi->len[0]);\r\nhi->addr_mapped[0] = 0;\r\n}\r\nif (hi->addr_mapped[1])\r\n{\r\niounmap ((void *) (hi->addr_mapped[1]));\r\nrelease_mem_region ((long) hi->addr[1], hi->len[1]);\r\nhi->addr_mapped[1] = 0;\r\n}\r\n}\r\n}\r\nvoid\r\ncleanup_devs (void)\r\n{\r\nhdw_info_t *hi;\r\nint i;\r\nfor (i = 0, hi = hdw_info; i < MAX_BOARDS; i++, hi++)\r\n{\r\nif (hi->pci_slot == 0xff || !hi->ndev)\r\nbreak;\r\nc4_stopwd(netdev_priv(hi->ndev));\r\n#ifdef CONFIG_PROC_FS\r\nsbecom_proc_brd_cleanup(netdev_priv(hi->ndev));\r\n#endif\r\nunregister_netdev (hi->ndev);\r\nfree_irq (hi->pdev[0]->irq, hi->ndev);\r\n#ifdef CONFIG_SBE_PMCC4_NCOMM\r\nfree_irq (hi->pdev[1]->irq, hi->ndev);\r\n#endif\r\nOS_kfree (hi->ndev);\r\n}\r\n}\r\nSTATIC int __init\r\nc4_hdw_init (struct pci_dev * pdev, int found)\r\n{\r\nhdw_info_t *hi;\r\nint i;\r\nint fun, slot;\r\nunsigned char busno = 0xff;\r\nif ((fun = PCI_FUNC (pdev->devfn)) > 1)\r\n{\r\npr_warning("unexpected devfun: 0x%x\n", pdev->devfn);\r\nreturn 0;\r\n}\r\nif (pdev->bus)\r\nbusno = pdev->bus->number;\r\nelse\r\nbusno = 0;\r\nslot = pdev->devfn & ~0x07;\r\nfor (i = 0, hi = hdw_info; i < MAX_BOARDS; i++, hi++)\r\n{\r\nif ((hi->pci_slot == 0xff) ||\r\n((hi->pci_slot == slot) && (hi->bus == pdev->bus)))\r\nbreak;\r\n}\r\nif (i == MAX_BOARDS)\r\n{\r\npr_warning("exceeded number of allowed devices (>%d)?\n", MAX_BOARDS);\r\nreturn 0;\r\n}\r\nif (pdev->bus)\r\nhi->pci_busno = pdev->bus->number;\r\nelse\r\nhi->pci_busno = 0;\r\nhi->pci_slot = slot;\r\npci_read_config_byte (pdev, PCI_INTERRUPT_PIN, &hi->pci_pin[fun]);\r\npci_read_config_byte (pdev, PCI_REVISION_ID, &hi->revid[fun]);\r\nhi->bus = pdev->bus;\r\nhi->addr[fun] = pci_resource_start (pdev, 0);\r\nhi->len[fun] = pci_resource_end (pdev, 0) - hi->addr[fun] + 1;\r\nhi->pdev[fun] = pdev;\r\n{\r\nchar *cp = hi->devname;\r\nstrcpy (cp, KBUILD_MODNAME);\r\ncp += strlen (cp);\r\n*cp++ = '-';\r\n*cp++ = '0' + (found / 2);\r\n*cp = 0;\r\n}\r\nreturn 1;\r\n}\r\nstatus_t __init\r\nc4hw_attach_all (void)\r\n{\r\nhdw_info_t *hi;\r\nstruct pci_dev *pdev = NULL;\r\nint found = 0, i, j;\r\nerror_flag = 0;\r\nprep_hdw_info ();\r\nwhile ((pdev = pci_get_device (PCI_VENDOR_ID_CONEXANT,\r\nPCI_DEVICE_ID_CN8474,\r\npdev)))\r\n{\r\nif (c4_hdw_init (pdev, found))\r\nfound++;\r\n}\r\nif (!found)\r\n{\r\npr_warning("No boards found\n");\r\nreturn ENODEV;\r\n}\r\nfor (i = 0, hi = hdw_info; i < MAX_BOARDS; i++, hi++)\r\n{\r\nif (hi->pci_slot != 0xff && (!hi->addr[0] || !hi->addr[1]))\r\n{\r\npr_warning("%s: something very wrong with pci_get_device\n",\r\nhi->devname);\r\nreturn EIO;\r\n}\r\n}\r\nfor (i = 0, hi = hdw_info; i < MAX_BOARDS; i++, hi++)\r\n{\r\nif (hi->pci_slot == 0xff)\r\nbreak;\r\nfor (j = 0; j < 2; j++)\r\n{\r\nif (request_mem_region (hi->addr[j], hi->len[j], hi->devname) == 0)\r\n{\r\npr_warning("%s: memory in use, addr=0x%lx, len=0x%lx ?\n",\r\nhi->devname, hi->addr[j], hi->len[j]);\r\ncleanup_ioremap ();\r\nreturn ENOMEM;\r\n}\r\nhi->addr_mapped[j] = (unsigned long) ioremap (hi->addr[j], hi->len[j]);\r\nif (!hi->addr_mapped[j])\r\n{\r\npr_warning("%s: ioremap fails, addr=0x%lx, len=0x%lx ?\n",\r\nhi->devname, hi->addr[j], hi->len[j]);\r\ncleanup_ioremap ();\r\nreturn ENOMEM;\r\n}\r\n#ifdef SBE_MAP_DEBUG\r\npr_warning("%s: io remapped from phys %x to virt %x\n",\r\nhi->devname, (u_int32_t) hi->addr[j], (u_int32_t) hi->addr_mapped[j]);\r\n#endif\r\n}\r\n}\r\ndrvr_state = SBE_DRVR_AVAILABLE;\r\nfor (i = 0, hi = hdw_info; i < MAX_BOARDS; i++, hi++)\r\n{\r\nif (hi->pci_slot == 0xff)\r\nbreak;\r\nif (pci_enable_device (hi->pdev[0]) ||\r\npci_enable_device (hi->pdev[1]))\r\n{\r\ndrvr_state = SBE_DRVR_DOWN;\r\npr_warning("%s: failed to enable card %d slot %d\n",\r\nhi->devname, i, hi->pci_slot);\r\ncleanup_devs ();\r\ncleanup_ioremap ();\r\nreturn EIO;\r\n}\r\npci_set_master (hi->pdev[0]);\r\npci_set_master (hi->pdev[1]);\r\nif (!(hi->ndev = c4_add_dev (hi, i, (long) hi->addr_mapped[0],\r\n(long) hi->addr_mapped[1],\r\nhi->pdev[0]->irq,\r\nhi->pdev[1]->irq)))\r\n{\r\ndrvr_state = SBE_DRVR_DOWN;\r\ncleanup_ioremap ();\r\n#if 0\r\ncleanup_devs ();\r\n#endif\r\nreturn error_flag;\r\n}\r\nshow_two (hi, i);\r\n}\r\nreturn 0;\r\n}
