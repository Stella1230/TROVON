static u32 tvaudio_carr2reg(u32 carrier)\r\n{\r\nu64 a = carrier;\r\na <<= 24;\r\ndo_div(a,12288);\r\nreturn a;\r\n}\r\nstatic void tvaudio_setcarrier(struct saa7134_dev *dev,\r\nint primary, int secondary)\r\n{\r\nif (-1 == secondary)\r\nsecondary = primary;\r\nsaa_writel(SAA7134_CARRIER1_FREQ0 >> 2, tvaudio_carr2reg(primary));\r\nsaa_writel(SAA7134_CARRIER2_FREQ0 >> 2, tvaudio_carr2reg(secondary));\r\n}\r\nstatic void mute_input_7134(struct saa7134_dev *dev)\r\n{\r\nunsigned int mute;\r\nstruct saa7134_input *in;\r\nint ausel=0, ics=0, ocs=0;\r\nint mask;\r\nin = dev->input;\r\nmute = (dev->ctl_mute ||\r\n(dev->automute && (&card(dev).radio) != in));\r\nif (card(dev).mute.name) {\r\nif (mute)\r\nin = &card(dev).mute;\r\n}\r\nif (dev->hw_mute == mute &&\r\ndev->hw_input == in && !dev->insuspend) {\r\ndprintk("mute/input: nothing to do [mute=%d,input=%s]\n",\r\nmute,in->name);\r\nreturn;\r\n}\r\ndprintk("ctl_mute=%d automute=%d input=%s => mute=%d input=%s\n",\r\ndev->ctl_mute,dev->automute,dev->input->name,mute,in->name);\r\ndev->hw_mute = mute;\r\ndev->hw_input = in;\r\nif (PCI_DEVICE_ID_PHILIPS_SAA7134 == dev->pci->device)\r\nsaa_writeb(SAA7134_AUDIO_MUTE_CTRL, mute ?\r\nSAA7134_MUTE_MASK |\r\nSAA7134_MUTE_ANALOG |\r\nSAA7134_MUTE_I2S :\r\nSAA7134_MUTE_MASK);\r\nswitch (in->amux) {\r\ncase TV: ausel=0xc0; ics=0x00; ocs=0x02; break;\r\ncase LINE1: ausel=0x80; ics=0x00; ocs=0x00; break;\r\ncase LINE2: ausel=0x80; ics=0x08; ocs=0x01; break;\r\ncase LINE2_LEFT: ausel=0x80; ics=0x08; ocs=0x05; break;\r\n}\r\nsaa_andorb(SAA7134_AUDIO_FORMAT_CTRL, 0xc0, ausel);\r\nsaa_andorb(SAA7134_ANALOG_IO_SELECT, 0x08, ics);\r\nsaa_andorb(SAA7134_ANALOG_IO_SELECT, 0x07, ocs);\r\nif (in->amux == TV)\r\nsaa_andorb(SAA7134_SIF_SAMPLE_FREQ, 0x03, 0x00);\r\nelse\r\nsaa_andorb(SAA7134_SIF_SAMPLE_FREQ, 0x03, 0x01);\r\nif (0 == card(dev).gpiomask)\r\nreturn;\r\nmask = card(dev).gpiomask;\r\nsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, mask, mask);\r\nsaa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, mask, in->gpio);\r\nsaa7134_track_gpio(dev,in->name);\r\n}\r\nstatic void tvaudio_setmode(struct saa7134_dev *dev,\r\nstruct saa7134_tvaudio *audio,\r\nchar *note)\r\n{\r\nint acpf, tweak = 0;\r\nif (dev->tvnorm->id == V4L2_STD_NTSC) {\r\nacpf = 0x19066;\r\n} else {\r\nacpf = 0x1e000;\r\n}\r\nif (audio_clock_tweak > -1024 && audio_clock_tweak < 1024)\r\ntweak = audio_clock_tweak;\r\nif (note)\r\ndprintk("tvaudio_setmode: %s %s [%d.%03d/%d.%03d MHz] acpf=%d%+d\n",\r\nnote,audio->name,\r\naudio->carr1 / 1000, audio->carr1 % 1000,\r\naudio->carr2 / 1000, audio->carr2 % 1000,\r\nacpf, tweak);\r\nacpf += tweak;\r\nsaa_writeb(SAA7134_AUDIO_CLOCKS_PER_FIELD0, (acpf & 0x0000ff) >> 0);\r\nsaa_writeb(SAA7134_AUDIO_CLOCKS_PER_FIELD1, (acpf & 0x00ff00) >> 8);\r\nsaa_writeb(SAA7134_AUDIO_CLOCKS_PER_FIELD2, (acpf & 0x030000) >> 16);\r\ntvaudio_setcarrier(dev,audio->carr1,audio->carr2);\r\nswitch (audio->mode) {\r\ncase TVAUDIO_FM_MONO:\r\ncase TVAUDIO_FM_BG_STEREO:\r\nsaa_writeb(SAA7134_DEMODULATOR, 0x00);\r\nsaa_writeb(SAA7134_DCXO_IDENT_CTRL, 0x00);\r\nsaa_writeb(SAA7134_FM_DEEMPHASIS, 0x22);\r\nsaa_writeb(SAA7134_FM_DEMATRIX, 0x80);\r\nsaa_writeb(SAA7134_STEREO_DAC_OUTPUT_SELECT, 0xa0);\r\nbreak;\r\ncase TVAUDIO_FM_K_STEREO:\r\nsaa_writeb(SAA7134_DEMODULATOR, 0x00);\r\nsaa_writeb(SAA7134_DCXO_IDENT_CTRL, 0x01);\r\nsaa_writeb(SAA7134_FM_DEEMPHASIS, 0x22);\r\nsaa_writeb(SAA7134_FM_DEMATRIX, 0x80);\r\nsaa_writeb(SAA7134_STEREO_DAC_OUTPUT_SELECT, 0xa0);\r\nbreak;\r\ncase TVAUDIO_NICAM_FM:\r\nsaa_writeb(SAA7134_DEMODULATOR, 0x10);\r\nsaa_writeb(SAA7134_DCXO_IDENT_CTRL, 0x00);\r\nsaa_writeb(SAA7134_FM_DEEMPHASIS, 0x44);\r\nsaa_writeb(SAA7134_STEREO_DAC_OUTPUT_SELECT, 0xa1);\r\nsaa_writeb(SAA7134_NICAM_CONFIG, 0x00);\r\nbreak;\r\ncase TVAUDIO_NICAM_AM:\r\nsaa_writeb(SAA7134_DEMODULATOR, 0x12);\r\nsaa_writeb(SAA7134_DCXO_IDENT_CTRL, 0x00);\r\nsaa_writeb(SAA7134_FM_DEEMPHASIS, 0x44);\r\nsaa_writeb(SAA7134_STEREO_DAC_OUTPUT_SELECT, 0xa1);\r\nsaa_writeb(SAA7134_NICAM_CONFIG, 0x00);\r\nbreak;\r\ncase TVAUDIO_FM_SAT_STEREO:\r\nbreak;\r\n}\r\n}\r\nstatic int tvaudio_sleep(struct saa7134_dev *dev, int timeout)\r\n{\r\nif (dev->thread.scan1 == dev->thread.scan2 &&\r\n!kthread_should_stop()) {\r\nif (timeout < 0) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule();\r\n} else {\r\nschedule_timeout_interruptible\r\n(msecs_to_jiffies(timeout));\r\n}\r\n}\r\nreturn dev->thread.scan1 != dev->thread.scan2;\r\n}\r\nstatic int tvaudio_checkcarrier(struct saa7134_dev *dev, struct mainscan *scan)\r\n{\r\n__s32 left,right,value;\r\nif (!(dev->tvnorm->id & scan->std)) {\r\nvalue = 0;\r\ndprintk("skipping %d.%03d MHz [%4s]\n",\r\nscan->carr / 1000, scan->carr % 1000, scan->name);\r\nreturn 0;\r\n}\r\nif (audio_debug > 1) {\r\nint i;\r\ndprintk("debug %d:",scan->carr);\r\nfor (i = -150; i <= 150; i += 30) {\r\ntvaudio_setcarrier(dev,scan->carr+i,scan->carr+i);\r\nsaa_readl(SAA7134_LEVEL_READOUT1 >> 2);\r\nif (tvaudio_sleep(dev,SCAN_SAMPLE_DELAY))\r\nreturn -1;\r\nvalue = saa_readl(SAA7134_LEVEL_READOUT1 >> 2);\r\nif (0 == i)\r\nprintk(" # %6d # ",value >> 16);\r\nelse\r\nprintk(" %6d",value >> 16);\r\n}\r\nprintk("\n");\r\n}\r\ntvaudio_setcarrier(dev,scan->carr-90,scan->carr-90);\r\nsaa_readl(SAA7134_LEVEL_READOUT1 >> 2);\r\nif (tvaudio_sleep(dev,SCAN_SAMPLE_DELAY))\r\nreturn -1;\r\nleft = saa_readl(SAA7134_LEVEL_READOUT1 >> 2);\r\ntvaudio_setcarrier(dev,scan->carr+90,scan->carr+90);\r\nsaa_readl(SAA7134_LEVEL_READOUT1 >> 2);\r\nif (tvaudio_sleep(dev,SCAN_SAMPLE_DELAY))\r\nreturn -1;\r\nright = saa_readl(SAA7134_LEVEL_READOUT1 >> 2);\r\nleft >>= 16;\r\nright >>= 16;\r\nvalue = left > right ? left - right : right - left;\r\ndprintk("scanning %d.%03d MHz [%4s] => dc is %5d [%d/%d]\n",\r\nscan->carr / 1000, scan->carr % 1000,\r\nscan->name, value, left, right);\r\nreturn value;\r\n}\r\nstatic int tvaudio_getstereo(struct saa7134_dev *dev, struct saa7134_tvaudio *audio)\r\n{\r\n__u32 idp, nicam, nicam_status;\r\nint retval = -1;\r\nswitch (audio->mode) {\r\ncase TVAUDIO_FM_MONO:\r\nreturn V4L2_TUNER_SUB_MONO;\r\ncase TVAUDIO_FM_K_STEREO:\r\ncase TVAUDIO_FM_BG_STEREO:\r\nidp = (saa_readb(SAA7134_IDENT_SIF) & 0xe0) >> 5;\r\ndprintk("getstereo: fm/stereo: idp=0x%x\n",idp);\r\nif (0x03 == (idp & 0x03))\r\nretval = V4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_LANG2;\r\nelse if (0x05 == (idp & 0x05))\r\nretval = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;\r\nelse if (0x01 == (idp & 0x01))\r\nretval = V4L2_TUNER_SUB_MONO;\r\nbreak;\r\ncase TVAUDIO_FM_SAT_STEREO:\r\nbreak;\r\ncase TVAUDIO_NICAM_FM:\r\ncase TVAUDIO_NICAM_AM:\r\nnicam = saa_readb(SAA7134_AUDIO_STATUS);\r\ndprintk("getstereo: nicam=0x%x\n",nicam);\r\nif (nicam & 0x1) {\r\nnicam_status = saa_readb(SAA7134_NICAM_STATUS);\r\ndprintk("getstereo: nicam_status=0x%x\n", nicam_status);\r\nswitch (nicam_status & 0x03) {\r\ncase 0x01:\r\nretval = V4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_LANG2;\r\nbreak;\r\ncase 0x02:\r\nretval = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;\r\nbreak;\r\ndefault:\r\nretval = V4L2_TUNER_SUB_MONO;\r\n}\r\n} else {\r\n}\r\nbreak;\r\n}\r\nif (retval != -1)\r\ndprintk("found audio subchannels:%s%s%s%s\n",\r\n(retval & V4L2_TUNER_SUB_MONO) ? " mono" : "",\r\n(retval & V4L2_TUNER_SUB_STEREO) ? " stereo" : "",\r\n(retval & V4L2_TUNER_SUB_LANG1) ? " lang1" : "",\r\n(retval & V4L2_TUNER_SUB_LANG2) ? " lang2" : "");\r\nreturn retval;\r\n}\r\nstatic int tvaudio_setstereo(struct saa7134_dev *dev, struct saa7134_tvaudio *audio,\r\nu32 mode)\r\n{\r\nstatic char *name[] = {\r\n[ V4L2_TUNER_MODE_MONO ] = "mono",\r\n[ V4L2_TUNER_MODE_STEREO ] = "stereo",\r\n[ V4L2_TUNER_MODE_LANG1 ] = "lang1",\r\n[ V4L2_TUNER_MODE_LANG2 ] = "lang2",\r\n[ V4L2_TUNER_MODE_LANG1_LANG2 ] = "lang1+lang2",\r\n};\r\nstatic u32 fm[] = {\r\n[ V4L2_TUNER_MODE_MONO ] = 0x00,\r\n[ V4L2_TUNER_MODE_STEREO ] = 0x80,\r\n[ V4L2_TUNER_MODE_LANG1 ] = 0x00,\r\n[ V4L2_TUNER_MODE_LANG2 ] = 0x01,\r\n[ V4L2_TUNER_MODE_LANG1_LANG2 ] = 0x80,\r\n};\r\nu32 reg;\r\nswitch (audio->mode) {\r\ncase TVAUDIO_FM_MONO:\r\nbreak;\r\ncase TVAUDIO_FM_K_STEREO:\r\ncase TVAUDIO_FM_BG_STEREO:\r\ncase TVAUDIO_NICAM_AM:\r\ncase TVAUDIO_NICAM_FM:\r\ndprintk("setstereo [fm] => %s\n",\r\nname[ mode % ARRAY_SIZE(name) ]);\r\nreg = fm[ mode % ARRAY_SIZE(fm) ];\r\nsaa_writeb(SAA7134_FM_DEMATRIX, reg);\r\nbreak;\r\ncase TVAUDIO_FM_SAT_STEREO:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tvaudio_thread(void *data)\r\n{\r\nstruct saa7134_dev *dev = data;\r\nint carr_vals[ARRAY_SIZE(mainscan)];\r\nunsigned int i, audio, nscan;\r\nint max1,max2,carrier,rx,mode,lastmode,default_carrier;\r\nset_freezable();\r\nfor (;;) {\r\ntvaudio_sleep(dev,-1);\r\nif (kthread_should_stop())\r\ngoto done;\r\nrestart:\r\ntry_to_freeze();\r\ndev->thread.scan1 = dev->thread.scan2;\r\ndprintk("tvaudio thread scan start [%d]\n",dev->thread.scan1);\r\ndev->tvaudio = NULL;\r\nsaa_writeb(SAA7134_MONITOR_SELECT, 0xa0);\r\nsaa_writeb(SAA7134_FM_DEMATRIX, 0x80);\r\nif (dev->ctl_automute)\r\ndev->automute = 1;\r\nmute_input_7134(dev);\r\nif (tvaudio_sleep(dev,SCAN_INITIAL_DELAY))\r\ngoto restart;\r\nmax1 = 0;\r\nmax2 = 0;\r\nnscan = 0;\r\ncarrier = 0;\r\ndefault_carrier = 0;\r\nfor (i = 0; i < ARRAY_SIZE(mainscan); i++) {\r\nif (!(dev->tvnorm->id & mainscan[i].std))\r\ncontinue;\r\nif (!default_carrier)\r\ndefault_carrier = mainscan[i].carr;\r\nnscan++;\r\n}\r\nif (1 == nscan) {\r\ndprintk("only one main carrier candidate - skipping scan\n");\r\nmax1 = 12345;\r\ncarrier = default_carrier;\r\n} else {\r\nsaa_writeb(SAA7134_MONITOR_SELECT,0x00);\r\ntvaudio_setmode(dev,&tvaudio[0],NULL);\r\nfor (i = 0; i < ARRAY_SIZE(mainscan); i++) {\r\ncarr_vals[i] = tvaudio_checkcarrier(dev, mainscan+i);\r\nif (dev->thread.scan1 != dev->thread.scan2)\r\ngoto restart;\r\n}\r\nfor (max1 = 0, max2 = 0, i = 0; i < ARRAY_SIZE(mainscan); i++) {\r\nif (max1 < carr_vals[i]) {\r\nmax2 = max1;\r\nmax1 = carr_vals[i];\r\ncarrier = mainscan[i].carr;\r\n} else if (max2 < carr_vals[i]) {\r\nmax2 = carr_vals[i];\r\n}\r\n}\r\n}\r\nif (0 != carrier && max1 > 2000 && max1 > max2*3) {\r\ndprintk("found %s main sound carrier @ %d.%03d MHz [%d/%d]\n",\r\ndev->tvnorm->name, carrier/1000, carrier%1000,\r\nmax1, max2);\r\ndev->last_carrier = carrier;\r\ndev->automute = 0;\r\n} else if (0 != dev->last_carrier) {\r\ncarrier = dev->last_carrier;\r\ndprintk("audio carrier scan failed, "\r\n"using %d.%03d MHz [last detected]\n",\r\ncarrier/1000, carrier%1000);\r\ndev->automute = 1;\r\n} else {\r\ncarrier = default_carrier;\r\ndprintk("audio carrier scan failed, "\r\n"using %d.%03d MHz [default]\n",\r\ncarrier/1000, carrier%1000);\r\ndev->automute = 1;\r\n}\r\ntvaudio_setcarrier(dev,carrier,carrier);\r\nsaa_andorb(SAA7134_STEREO_DAC_OUTPUT_SELECT, 0x30, 0x00);\r\nsaa7134_tvaudio_setmute(dev);\r\nfor (audio = UNSET, i = 0; i < TVAUDIO; i++) {\r\nif (dev->tvnorm->id != UNSET &&\r\n!(dev->tvnorm->id & tvaudio[i].std))\r\ncontinue;\r\nif (tvaudio[i].carr1 != carrier)\r\ncontinue;\r\nif (UNSET == audio)\r\naudio = i;\r\ntvaudio_setmode(dev,&tvaudio[i],"trying");\r\nif (tvaudio_sleep(dev,SCAN_SUBCARRIER_DELAY))\r\ngoto restart;\r\nif (-1 != tvaudio_getstereo(dev,&tvaudio[i])) {\r\naudio = i;\r\nbreak;\r\n}\r\n}\r\nsaa_andorb(SAA7134_STEREO_DAC_OUTPUT_SELECT, 0x30, 0x30);\r\nif (UNSET == audio)\r\ncontinue;\r\ntvaudio_setmode(dev,&tvaudio[audio],"using");\r\ntvaudio_setstereo(dev,&tvaudio[audio],V4L2_TUNER_MODE_MONO);\r\ndev->tvaudio = &tvaudio[audio];\r\nlastmode = 42;\r\nfor (;;) {\r\ntry_to_freeze();\r\nif (tvaudio_sleep(dev,5000))\r\ngoto restart;\r\nif (kthread_should_stop())\r\nbreak;\r\nif (UNSET == dev->thread.mode) {\r\nrx = tvaudio_getstereo(dev, &tvaudio[audio]);\r\nmode = saa7134_tvaudio_rx2mode(rx);\r\n} else {\r\nmode = dev->thread.mode;\r\n}\r\nif (lastmode != mode) {\r\ntvaudio_setstereo(dev,&tvaudio[audio],mode);\r\nlastmode = mode;\r\n}\r\n}\r\n}\r\ndone:\r\ndev->thread.stopped = 1;\r\nreturn 0;\r\n}\r\nstatic inline int saa_dsp_reset_error_bit(struct saa7134_dev *dev)\r\n{\r\nint state = saa_readb(SAA7135_DSP_RWSTATE);\r\nif (unlikely(state & SAA7135_DSP_RWSTATE_ERR)) {\r\nd2printk("%s: resetting error bit\n", dev->name);\r\nsaa_writeb(SAA7135_DSP_RWCLEAR, SAA7135_DSP_RWCLEAR_RERR);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int saa_dsp_wait_bit(struct saa7134_dev *dev, int bit)\r\n{\r\nint state, count = DSP_RETRY;\r\nstate = saa_readb(SAA7135_DSP_RWSTATE);\r\nif (unlikely(state & SAA7135_DSP_RWSTATE_ERR)) {\r\nprintk(KERN_WARNING "%s: dsp access error\n", dev->name);\r\nsaa_dsp_reset_error_bit(dev);\r\nreturn -EIO;\r\n}\r\nwhile (0 == (state & bit)) {\r\nif (unlikely(0 == count)) {\r\nprintk("%s: dsp access wait timeout [bit=%s]\n",\r\ndev->name,\r\n(bit & SAA7135_DSP_RWSTATE_WRR) ? "WRR" :\r\n(bit & SAA7135_DSP_RWSTATE_RDB) ? "RDB" :\r\n(bit & SAA7135_DSP_RWSTATE_IDA) ? "IDA" :\r\n"???");\r\nreturn -EIO;\r\n}\r\nsaa_wait(DSP_DELAY);\r\nstate = saa_readb(SAA7135_DSP_RWSTATE);\r\ncount--;\r\n}\r\nreturn 0;\r\n}\r\nint saa_dsp_writel(struct saa7134_dev *dev, int reg, u32 value)\r\n{\r\nint err;\r\nd2printk("dsp write reg 0x%x = 0x%06x\n",reg<<2,value);\r\nerr = saa_dsp_wait_bit(dev,SAA7135_DSP_RWSTATE_WRR);\r\nif (err < 0)\r\nreturn err;\r\nsaa_writel(reg,value);\r\nerr = saa_dsp_wait_bit(dev,SAA7135_DSP_RWSTATE_WRR);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int getstereo_7133(struct saa7134_dev *dev)\r\n{\r\nint retval = V4L2_TUNER_SUB_MONO;\r\nu32 value;\r\nvalue = saa_readl(0x528 >> 2);\r\nif (value & 0x20)\r\nretval = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;\r\nif (value & 0x40)\r\nretval = V4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_LANG2;\r\nreturn retval;\r\n}\r\nstatic int mute_input_7133(struct saa7134_dev *dev)\r\n{\r\nu32 reg = 0;\r\nu32 xbarin, xbarout;\r\nint mask;\r\nstruct saa7134_input *in;\r\nxbarin = 0x03;\r\nswitch (dev->input->amux) {\r\ncase TV:\r\nreg = 0x02;\r\nxbarin = 0;\r\nbreak;\r\ncase LINE1:\r\nreg = 0x00;\r\nbreak;\r\ncase LINE2:\r\ncase LINE2_LEFT:\r\nreg = 0x09;\r\nbreak;\r\n}\r\nsaa_dsp_writel(dev, 0x464 >> 2, xbarin);\r\nif (dev->ctl_mute) {\r\nreg = 0x07;\r\nxbarout = 0xbbbbbb;\r\n} else\r\nxbarout = 0xbbbb10;\r\nsaa_dsp_writel(dev, 0x46c >> 2, xbarout);\r\nsaa_writel(0x594 >> 2, reg);\r\nif (0 != card(dev).gpiomask) {\r\nmask = card(dev).gpiomask;\r\nif (card(dev).mute.name && dev->ctl_mute)\r\nin = &card(dev).mute;\r\nelse\r\nin = dev->input;\r\nsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, mask, mask);\r\nsaa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, mask, in->gpio);\r\nsaa7134_track_gpio(dev,in->name);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tvaudio_thread_ddep(void *data)\r\n{\r\nstruct saa7134_dev *dev = data;\r\nu32 value, norms;\r\nset_freezable();\r\nfor (;;) {\r\ntvaudio_sleep(dev,-1);\r\nif (kthread_should_stop())\r\ngoto done;\r\nrestart:\r\ntry_to_freeze();\r\ndev->thread.scan1 = dev->thread.scan2;\r\ndprintk("tvaudio thread scan start [%d]\n",dev->thread.scan1);\r\nif (audio_ddep >= 0x04 && audio_ddep <= 0x0e) {\r\nnorms = (audio_ddep << 2) | 0x01;\r\ndprintk("ddep override: %s\n",stdres[audio_ddep]);\r\n} else if (&card(dev).radio == dev->input) {\r\ndprintk("FM Radio\n");\r\nif (dev->tuner_type == TUNER_PHILIPS_TDA8290) {\r\nnorms = (0x11 << 2) | 0x01;\r\nsaa_dsp_writel(dev, 0x42c >> 2, 0x729555);\r\n} else {\r\nnorms = (0x0f << 2) | 0x01;\r\n}\r\n} else {\r\nnorms = 0;\r\nif (dev->tvnorm->id & (V4L2_STD_B | V4L2_STD_GH))\r\nnorms |= 0x04;\r\nif (dev->tvnorm->id & V4L2_STD_PAL_I)\r\nnorms |= 0x20;\r\nif (dev->tvnorm->id & V4L2_STD_DK)\r\nnorms |= 0x08;\r\nif (dev->tvnorm->id & V4L2_STD_MN)\r\nnorms |= 0x40;\r\nif (dev->tvnorm->id & (V4L2_STD_SECAM_L | V4L2_STD_SECAM_LC))\r\nnorms |= 0x10;\r\nif (0 == norms)\r\nnorms = 0x7c;\r\ndprintk("scanning:%s%s%s%s%s\n",\r\n(norms & 0x04) ? " B/G" : "",\r\n(norms & 0x08) ? " D/K" : "",\r\n(norms & 0x10) ? " L/L'" : "",\r\n(norms & 0x20) ? " I" : "",\r\n(norms & 0x40) ? " M" : "");\r\n}\r\nsaa_dsp_writel(dev, 0x454 >> 2, 0);\r\nsaa_dsp_writel(dev, 0x454 >> 2, norms | 0x80);\r\nsaa_dsp_writel(dev, 0x464 >> 2, 0x000000);\r\nsaa_dsp_writel(dev, 0x470 >> 2, 0x101010);\r\nif (tvaudio_sleep(dev,3000))\r\ngoto restart;\r\nvalue = saa_readl(0x528 >> 2) & 0xffffff;\r\ndprintk("tvaudio thread status: 0x%x [%s%s%s]\n",\r\nvalue, stdres[value & 0x1f],\r\n(value & 0x000020) ? ",stereo" : "",\r\n(value & 0x000040) ? ",dual" : "");\r\ndprintk("detailed status: "\r\n"%s#%s#%s#%s#%s#%s#%s#%s#%s#%s#%s#%s#%s#%s\n",\r\n(value & 0x000080) ? " A2/EIAJ pilot tone " : "",\r\n(value & 0x000100) ? " A2/EIAJ dual " : "",\r\n(value & 0x000200) ? " A2/EIAJ stereo " : "",\r\n(value & 0x000400) ? " A2/EIAJ noise mute " : "",\r\n(value & 0x000800) ? " BTSC/FM radio pilot " : "",\r\n(value & 0x001000) ? " SAP carrier " : "",\r\n(value & 0x002000) ? " BTSC stereo noise mute " : "",\r\n(value & 0x004000) ? " SAP noise mute " : "",\r\n(value & 0x008000) ? " VDSP " : "",\r\n(value & 0x010000) ? " NICST " : "",\r\n(value & 0x020000) ? " NICDU " : "",\r\n(value & 0x040000) ? " NICAM muted " : "",\r\n(value & 0x080000) ? " NICAM reserve sound " : "",\r\n(value & 0x100000) ? " init done " : "");\r\n}\r\ndone:\r\ndev->thread.stopped = 1;\r\nreturn 0;\r\n}\r\nvoid saa7134_enable_i2s(struct saa7134_dev *dev)\r\n{\r\nint i2s_format;\r\nif (!card_is_empress(dev))\r\nreturn;\r\nif (dev->pci->device == PCI_DEVICE_ID_PHILIPS_SAA7130)\r\nreturn;\r\nsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, 0x0E000000, 0x00000000);\r\nswitch (dev->pci->device) {\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7133:\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7135:\r\nsaa_writeb(SAA7133_I2S_AUDIO_CONTROL, 0x00);\r\nsaa_writeb(SAA7134_I2S_AUDIO_OUTPUT, 0x11);\r\nbreak;\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7134:\r\ni2s_format = (dev->input->amux == TV) ? 0x00 : 0x01;\r\nsaa_writeb(SAA7134_I2S_OUTPUT_SELECT, 0x80);\r\nsaa_writeb(SAA7134_I2S_OUTPUT_FORMAT, i2s_format);\r\nsaa_writeb(SAA7134_I2S_OUTPUT_LEVEL, 0x0F);\r\nsaa_writeb(SAA7134_I2S_AUDIO_OUTPUT, 0x01);\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nint saa7134_tvaudio_rx2mode(u32 rx)\r\n{\r\nu32 mode;\r\nmode = V4L2_TUNER_MODE_MONO;\r\nif (rx & V4L2_TUNER_SUB_STEREO)\r\nmode = V4L2_TUNER_MODE_STEREO;\r\nelse if (rx & V4L2_TUNER_SUB_LANG1)\r\nmode = V4L2_TUNER_MODE_LANG1;\r\nelse if (rx & V4L2_TUNER_SUB_LANG2)\r\nmode = V4L2_TUNER_MODE_LANG2;\r\nreturn mode;\r\n}\r\nvoid saa7134_tvaudio_setmute(struct saa7134_dev *dev)\r\n{\r\nswitch (dev->pci->device) {\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7130:\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7134:\r\nmute_input_7134(dev);\r\nbreak;\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7133:\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7135:\r\nmute_input_7133(dev);\r\nbreak;\r\n}\r\n}\r\nvoid saa7134_tvaudio_setinput(struct saa7134_dev *dev,\r\nstruct saa7134_input *in)\r\n{\r\ndev->input = in;\r\nswitch (dev->pci->device) {\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7130:\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7134:\r\nmute_input_7134(dev);\r\nbreak;\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7133:\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7135:\r\nmute_input_7133(dev);\r\nbreak;\r\n}\r\nsaa7134_enable_i2s(dev);\r\n}\r\nvoid saa7134_tvaudio_setvolume(struct saa7134_dev *dev, int level)\r\n{\r\nswitch (dev->pci->device) {\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7134:\r\nsaa_writeb(SAA7134_CHANNEL1_LEVEL, level & 0x1f);\r\nsaa_writeb(SAA7134_CHANNEL2_LEVEL, level & 0x1f);\r\nsaa_writeb(SAA7134_NICAM_LEVEL_ADJUST, level & 0x1f);\r\nbreak;\r\n}\r\n}\r\nint saa7134_tvaudio_getstereo(struct saa7134_dev *dev)\r\n{\r\nint retval = V4L2_TUNER_SUB_MONO;\r\nswitch (dev->pci->device) {\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7134:\r\nif (dev->tvaudio)\r\nretval = tvaudio_getstereo(dev,dev->tvaudio);\r\nbreak;\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7133:\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7135:\r\nretval = getstereo_7133(dev);\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nvoid saa7134_tvaudio_init(struct saa7134_dev *dev)\r\n{\r\nint clock = saa7134_boards[dev->board].audio_clock;\r\nif (UNSET != audio_clock_override)\r\nclock = audio_clock_override;\r\nswitch (dev->pci->device) {\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7134:\r\nsaa_writeb(SAA7134_AUDIO_PLL_CTRL, 0x00);\r\nif (need_resched())\r\nschedule();\r\nelse\r\nudelay(10);\r\nsaa_writeb(SAA7134_AUDIO_CLOCK0, clock & 0xff);\r\nsaa_writeb(SAA7134_AUDIO_CLOCK1, (clock >> 8) & 0xff);\r\nsaa_writeb(SAA7134_AUDIO_CLOCK2, (clock >> 16) & 0xff);\r\nsaa_writeb(SAA7134_AUDIO_PLL_CTRL, 0x01);\r\nsaa_writeb(SAA7134_NICAM_ERROR_LOW, 0x14);\r\nsaa_writeb(SAA7134_NICAM_ERROR_HIGH, 0x50);\r\nbreak;\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7133:\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7135:\r\nsaa_writel(0x598 >> 2, clock);\r\nsaa_dsp_writel(dev, 0x474 >> 2, 0x00);\r\nsaa_dsp_writel(dev, 0x450 >> 2, 0x00);\r\n}\r\n}\r\nint saa7134_tvaudio_init2(struct saa7134_dev *dev)\r\n{\r\nint (*my_thread)(void *data) = NULL;\r\nswitch (dev->pci->device) {\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7134:\r\nmy_thread = tvaudio_thread;\r\nbreak;\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7133:\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7135:\r\nmy_thread = tvaudio_thread_ddep;\r\nbreak;\r\n}\r\ndev->thread.thread = NULL;\r\ndev->thread.scan1 = dev->thread.scan2 = 0;\r\nif (my_thread) {\r\nsaa7134_tvaudio_init(dev);\r\ndev->thread.thread = kthread_run(my_thread, dev, "%s", dev->name);\r\nif (IS_ERR(dev->thread.thread)) {\r\nprintk(KERN_WARNING "%s: kernel_thread() failed\n",\r\ndev->name);\r\n}\r\n}\r\nsaa7134_enable_i2s(dev);\r\nreturn 0;\r\n}\r\nint saa7134_tvaudio_close(struct saa7134_dev *dev)\r\n{\r\ndev->automute = 1;\r\nreturn 0;\r\n}\r\nint saa7134_tvaudio_fini(struct saa7134_dev *dev)\r\n{\r\nif (dev->thread.thread && !dev->thread.stopped)\r\nkthread_stop(dev->thread.thread);\r\nsaa_andorb(SAA7134_ANALOG_IO_SELECT, 0x07, 0x00);\r\nreturn 0;\r\n}\r\nint saa7134_tvaudio_do_scan(struct saa7134_dev *dev)\r\n{\r\nif (dev->input->amux != TV) {\r\ndprintk("sound IF not in use, skipping scan\n");\r\ndev->automute = 0;\r\nsaa7134_tvaudio_setmute(dev);\r\n} else if (dev->thread.thread) {\r\ndev->thread.mode = UNSET;\r\ndev->thread.scan2++;\r\nif (!dev->insuspend && !dev->thread.stopped)\r\nwake_up_process(dev->thread.thread);\r\n} else {\r\ndev->automute = 0;\r\nsaa7134_tvaudio_setmute(dev);\r\n}\r\nreturn 0;\r\n}
