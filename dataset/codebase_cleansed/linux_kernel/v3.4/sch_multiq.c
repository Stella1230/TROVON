static struct Qdisc *\r\nmultiq_classify(struct sk_buff *skb, struct Qdisc *sch, int *qerr)\r\n{\r\nstruct multiq_sched_data *q = qdisc_priv(sch);\r\nu32 band;\r\nstruct tcf_result res;\r\nint err;\r\n*qerr = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\r\nerr = tc_classify(skb, q->filter_list, &res);\r\n#ifdef CONFIG_NET_CLS_ACT\r\nswitch (err) {\r\ncase TC_ACT_STOLEN:\r\ncase TC_ACT_QUEUED:\r\n*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;\r\ncase TC_ACT_SHOT:\r\nreturn NULL;\r\n}\r\n#endif\r\nband = skb_get_queue_mapping(skb);\r\nif (band >= q->bands)\r\nreturn q->queues[0];\r\nreturn q->queues[band];\r\n}\r\nstatic int\r\nmultiq_enqueue(struct sk_buff *skb, struct Qdisc *sch)\r\n{\r\nstruct Qdisc *qdisc;\r\nint ret;\r\nqdisc = multiq_classify(skb, sch, &ret);\r\n#ifdef CONFIG_NET_CLS_ACT\r\nif (qdisc == NULL) {\r\nif (ret & __NET_XMIT_BYPASS)\r\nsch->qstats.drops++;\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\n#endif\r\nret = qdisc_enqueue(skb, qdisc);\r\nif (ret == NET_XMIT_SUCCESS) {\r\nsch->q.qlen++;\r\nreturn NET_XMIT_SUCCESS;\r\n}\r\nif (net_xmit_drop_count(ret))\r\nsch->qstats.drops++;\r\nreturn ret;\r\n}\r\nstatic struct sk_buff *multiq_dequeue(struct Qdisc *sch)\r\n{\r\nstruct multiq_sched_data *q = qdisc_priv(sch);\r\nstruct Qdisc *qdisc;\r\nstruct sk_buff *skb;\r\nint band;\r\nfor (band = 0; band < q->bands; band++) {\r\nq->curband++;\r\nif (q->curband >= q->bands)\r\nq->curband = 0;\r\nif (!netif_xmit_stopped(\r\nnetdev_get_tx_queue(qdisc_dev(sch), q->curband))) {\r\nqdisc = q->queues[q->curband];\r\nskb = qdisc->dequeue(qdisc);\r\nif (skb) {\r\nqdisc_bstats_update(sch, skb);\r\nsch->q.qlen--;\r\nreturn skb;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sk_buff *multiq_peek(struct Qdisc *sch)\r\n{\r\nstruct multiq_sched_data *q = qdisc_priv(sch);\r\nunsigned int curband = q->curband;\r\nstruct Qdisc *qdisc;\r\nstruct sk_buff *skb;\r\nint band;\r\nfor (band = 0; band < q->bands; band++) {\r\ncurband++;\r\nif (curband >= q->bands)\r\ncurband = 0;\r\nif (!netif_xmit_stopped(\r\nnetdev_get_tx_queue(qdisc_dev(sch), curband))) {\r\nqdisc = q->queues[curband];\r\nskb = qdisc->ops->peek(qdisc);\r\nif (skb)\r\nreturn skb;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic unsigned int multiq_drop(struct Qdisc *sch)\r\n{\r\nstruct multiq_sched_data *q = qdisc_priv(sch);\r\nint band;\r\nunsigned int len;\r\nstruct Qdisc *qdisc;\r\nfor (band = q->bands - 1; band >= 0; band--) {\r\nqdisc = q->queues[band];\r\nif (qdisc->ops->drop) {\r\nlen = qdisc->ops->drop(qdisc);\r\nif (len != 0) {\r\nsch->q.qlen--;\r\nreturn len;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nmultiq_reset(struct Qdisc *sch)\r\n{\r\nu16 band;\r\nstruct multiq_sched_data *q = qdisc_priv(sch);\r\nfor (band = 0; band < q->bands; band++)\r\nqdisc_reset(q->queues[band]);\r\nsch->q.qlen = 0;\r\nq->curband = 0;\r\n}\r\nstatic void\r\nmultiq_destroy(struct Qdisc *sch)\r\n{\r\nint band;\r\nstruct multiq_sched_data *q = qdisc_priv(sch);\r\ntcf_destroy_chain(&q->filter_list);\r\nfor (band = 0; band < q->bands; band++)\r\nqdisc_destroy(q->queues[band]);\r\nkfree(q->queues);\r\n}\r\nstatic int multiq_tune(struct Qdisc *sch, struct nlattr *opt)\r\n{\r\nstruct multiq_sched_data *q = qdisc_priv(sch);\r\nstruct tc_multiq_qopt *qopt;\r\nint i;\r\nif (!netif_is_multiqueue(qdisc_dev(sch)))\r\nreturn -EOPNOTSUPP;\r\nif (nla_len(opt) < sizeof(*qopt))\r\nreturn -EINVAL;\r\nqopt = nla_data(opt);\r\nqopt->bands = qdisc_dev(sch)->real_num_tx_queues;\r\nsch_tree_lock(sch);\r\nq->bands = qopt->bands;\r\nfor (i = q->bands; i < q->max_bands; i++) {\r\nif (q->queues[i] != &noop_qdisc) {\r\nstruct Qdisc *child = q->queues[i];\r\nq->queues[i] = &noop_qdisc;\r\nqdisc_tree_decrease_qlen(child, child->q.qlen);\r\nqdisc_destroy(child);\r\n}\r\n}\r\nsch_tree_unlock(sch);\r\nfor (i = 0; i < q->bands; i++) {\r\nif (q->queues[i] == &noop_qdisc) {\r\nstruct Qdisc *child, *old;\r\nchild = qdisc_create_dflt(sch->dev_queue,\r\n&pfifo_qdisc_ops,\r\nTC_H_MAKE(sch->handle,\r\ni + 1));\r\nif (child) {\r\nsch_tree_lock(sch);\r\nold = q->queues[i];\r\nq->queues[i] = child;\r\nif (old != &noop_qdisc) {\r\nqdisc_tree_decrease_qlen(old,\r\nold->q.qlen);\r\nqdisc_destroy(old);\r\n}\r\nsch_tree_unlock(sch);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int multiq_init(struct Qdisc *sch, struct nlattr *opt)\r\n{\r\nstruct multiq_sched_data *q = qdisc_priv(sch);\r\nint i, err;\r\nq->queues = NULL;\r\nif (opt == NULL)\r\nreturn -EINVAL;\r\nq->max_bands = qdisc_dev(sch)->num_tx_queues;\r\nq->queues = kcalloc(q->max_bands, sizeof(struct Qdisc *), GFP_KERNEL);\r\nif (!q->queues)\r\nreturn -ENOBUFS;\r\nfor (i = 0; i < q->max_bands; i++)\r\nq->queues[i] = &noop_qdisc;\r\nerr = multiq_tune(sch, opt);\r\nif (err)\r\nkfree(q->queues);\r\nreturn err;\r\n}\r\nstatic int multiq_dump(struct Qdisc *sch, struct sk_buff *skb)\r\n{\r\nstruct multiq_sched_data *q = qdisc_priv(sch);\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct tc_multiq_qopt opt;\r\nopt.bands = q->bands;\r\nopt.max_bands = q->max_bands;\r\nNLA_PUT(skb, TCA_OPTIONS, sizeof(opt), &opt);\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int multiq_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,\r\nstruct Qdisc **old)\r\n{\r\nstruct multiq_sched_data *q = qdisc_priv(sch);\r\nunsigned long band = arg - 1;\r\nif (new == NULL)\r\nnew = &noop_qdisc;\r\nsch_tree_lock(sch);\r\n*old = q->queues[band];\r\nq->queues[band] = new;\r\nqdisc_tree_decrease_qlen(*old, (*old)->q.qlen);\r\nqdisc_reset(*old);\r\nsch_tree_unlock(sch);\r\nreturn 0;\r\n}\r\nstatic struct Qdisc *\r\nmultiq_leaf(struct Qdisc *sch, unsigned long arg)\r\n{\r\nstruct multiq_sched_data *q = qdisc_priv(sch);\r\nunsigned long band = arg - 1;\r\nreturn q->queues[band];\r\n}\r\nstatic unsigned long multiq_get(struct Qdisc *sch, u32 classid)\r\n{\r\nstruct multiq_sched_data *q = qdisc_priv(sch);\r\nunsigned long band = TC_H_MIN(classid);\r\nif (band - 1 >= q->bands)\r\nreturn 0;\r\nreturn band;\r\n}\r\nstatic unsigned long multiq_bind(struct Qdisc *sch, unsigned long parent,\r\nu32 classid)\r\n{\r\nreturn multiq_get(sch, classid);\r\n}\r\nstatic void multiq_put(struct Qdisc *q, unsigned long cl)\r\n{\r\n}\r\nstatic int multiq_dump_class(struct Qdisc *sch, unsigned long cl,\r\nstruct sk_buff *skb, struct tcmsg *tcm)\r\n{\r\nstruct multiq_sched_data *q = qdisc_priv(sch);\r\ntcm->tcm_handle |= TC_H_MIN(cl);\r\ntcm->tcm_info = q->queues[cl - 1]->handle;\r\nreturn 0;\r\n}\r\nstatic int multiq_dump_class_stats(struct Qdisc *sch, unsigned long cl,\r\nstruct gnet_dump *d)\r\n{\r\nstruct multiq_sched_data *q = qdisc_priv(sch);\r\nstruct Qdisc *cl_q;\r\ncl_q = q->queues[cl - 1];\r\ncl_q->qstats.qlen = cl_q->q.qlen;\r\nif (gnet_stats_copy_basic(d, &cl_q->bstats) < 0 ||\r\ngnet_stats_copy_queue(d, &cl_q->qstats) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void multiq_walk(struct Qdisc *sch, struct qdisc_walker *arg)\r\n{\r\nstruct multiq_sched_data *q = qdisc_priv(sch);\r\nint band;\r\nif (arg->stop)\r\nreturn;\r\nfor (band = 0; band < q->bands; band++) {\r\nif (arg->count < arg->skip) {\r\narg->count++;\r\ncontinue;\r\n}\r\nif (arg->fn(sch, band + 1, arg) < 0) {\r\narg->stop = 1;\r\nbreak;\r\n}\r\narg->count++;\r\n}\r\n}\r\nstatic struct tcf_proto **multiq_find_tcf(struct Qdisc *sch, unsigned long cl)\r\n{\r\nstruct multiq_sched_data *q = qdisc_priv(sch);\r\nif (cl)\r\nreturn NULL;\r\nreturn &q->filter_list;\r\n}\r\nstatic int __init multiq_module_init(void)\r\n{\r\nreturn register_qdisc(&multiq_qdisc_ops);\r\n}\r\nstatic void __exit multiq_module_exit(void)\r\n{\r\nunregister_qdisc(&multiq_qdisc_ops);\r\n}
