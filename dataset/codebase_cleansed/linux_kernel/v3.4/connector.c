int cn_netlink_send(struct cn_msg *msg, u32 __group, gfp_t gfp_mask)\r\n{\r\nstruct cn_callback_entry *__cbq;\r\nunsigned int size;\r\nstruct sk_buff *skb;\r\nstruct nlmsghdr *nlh;\r\nstruct cn_msg *data;\r\nstruct cn_dev *dev = &cdev;\r\nu32 group = 0;\r\nint found = 0;\r\nif (!__group) {\r\nspin_lock_bh(&dev->cbdev->queue_lock);\r\nlist_for_each_entry(__cbq, &dev->cbdev->queue_list,\r\ncallback_entry) {\r\nif (cn_cb_equal(&__cbq->id.id, &msg->id)) {\r\nfound = 1;\r\ngroup = __cbq->group;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&dev->cbdev->queue_lock);\r\nif (!found)\r\nreturn -ENODEV;\r\n} else {\r\ngroup = __group;\r\n}\r\nif (!netlink_has_listeners(dev->nls, group))\r\nreturn -ESRCH;\r\nsize = NLMSG_SPACE(sizeof(*msg) + msg->len);\r\nskb = alloc_skb(size, gfp_mask);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nnlh = NLMSG_PUT(skb, 0, msg->seq, NLMSG_DONE, size - sizeof(*nlh));\r\ndata = NLMSG_DATA(nlh);\r\nmemcpy(data, msg, sizeof(*data) + msg->len);\r\nNETLINK_CB(skb).dst_group = group;\r\nreturn netlink_broadcast(dev->nls, skb, 0, group, gfp_mask);\r\nnlmsg_failure:\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nstatic int cn_call_callback(struct sk_buff *skb)\r\n{\r\nstruct cn_callback_entry *i, *cbq = NULL;\r\nstruct cn_dev *dev = &cdev;\r\nstruct cn_msg *msg = NLMSG_DATA(nlmsg_hdr(skb));\r\nstruct netlink_skb_parms *nsp = &NETLINK_CB(skb);\r\nint err = -ENODEV;\r\nspin_lock_bh(&dev->cbdev->queue_lock);\r\nlist_for_each_entry(i, &dev->cbdev->queue_list, callback_entry) {\r\nif (cn_cb_equal(&i->id.id, &msg->id)) {\r\natomic_inc(&i->refcnt);\r\ncbq = i;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&dev->cbdev->queue_lock);\r\nif (cbq != NULL) {\r\nerr = 0;\r\ncbq->callback(msg, nsp);\r\nkfree_skb(skb);\r\ncn_queue_release_callback(cbq);\r\nerr = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic void cn_rx_skb(struct sk_buff *__skb)\r\n{\r\nstruct nlmsghdr *nlh;\r\nint err;\r\nstruct sk_buff *skb;\r\nskb = skb_get(__skb);\r\nif (skb->len >= NLMSG_SPACE(0)) {\r\nnlh = nlmsg_hdr(skb);\r\nif (nlh->nlmsg_len < sizeof(struct cn_msg) ||\r\nskb->len < nlh->nlmsg_len ||\r\nnlh->nlmsg_len > CONNECTOR_MAX_MSG_SIZE) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nerr = cn_call_callback(skb);\r\nif (err < 0)\r\nkfree_skb(skb);\r\n}\r\n}\r\nint cn_add_callback(struct cb_id *id, const char *name,\r\nvoid (*callback)(struct cn_msg *, struct netlink_skb_parms *))\r\n{\r\nint err;\r\nstruct cn_dev *dev = &cdev;\r\nif (!cn_already_initialized)\r\nreturn -EAGAIN;\r\nerr = cn_queue_add_callback(dev->cbdev, name, id, callback);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nvoid cn_del_callback(struct cb_id *id)\r\n{\r\nstruct cn_dev *dev = &cdev;\r\ncn_queue_del_callback(dev->cbdev, id);\r\n}\r\nstatic int cn_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct cn_queue_dev *dev = cdev.cbdev;\r\nstruct cn_callback_entry *cbq;\r\nseq_printf(m, "Name ID\n");\r\nspin_lock_bh(&dev->queue_lock);\r\nlist_for_each_entry(cbq, &dev->queue_list, callback_entry) {\r\nseq_printf(m, "%-15s %u:%u\n",\r\ncbq->id.name,\r\ncbq->id.id.idx,\r\ncbq->id.id.val);\r\n}\r\nspin_unlock_bh(&dev->queue_lock);\r\nreturn 0;\r\n}\r\nstatic int cn_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, cn_proc_show, NULL);\r\n}\r\nstatic int __devinit cn_init(void)\r\n{\r\nstruct cn_dev *dev = &cdev;\r\ndev->input = cn_rx_skb;\r\ndev->nls = netlink_kernel_create(&init_net, NETLINK_CONNECTOR,\r\nCN_NETLINK_USERS + 0xf,\r\ndev->input, NULL, THIS_MODULE);\r\nif (!dev->nls)\r\nreturn -EIO;\r\ndev->cbdev = cn_queue_alloc_dev("cqueue", dev->nls);\r\nif (!dev->cbdev) {\r\nnetlink_kernel_release(dev->nls);\r\nreturn -EINVAL;\r\n}\r\ncn_already_initialized = 1;\r\nproc_net_fops_create(&init_net, "connector", S_IRUGO, &cn_file_ops);\r\nreturn 0;\r\n}\r\nstatic void __devexit cn_fini(void)\r\n{\r\nstruct cn_dev *dev = &cdev;\r\ncn_already_initialized = 0;\r\nproc_net_remove(&init_net, "connector");\r\ncn_queue_free_dev(dev->cbdev);\r\nnetlink_kernel_release(dev->nls);\r\n}
