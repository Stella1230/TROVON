static int mx1_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,\r\nunsigned int *size)\r\n{\r\nstruct soc_camera_device *icd = vq->priv_data;\r\nint bytes_per_line = soc_mbus_bytes_per_line(icd->user_width,\r\nicd->current_fmt->host_fmt);\r\nif (bytes_per_line < 0)\r\nreturn bytes_per_line;\r\n*size = bytes_per_line * icd->user_height;\r\nif (!*count)\r\n*count = 32;\r\nif (*size * *count > MAX_VIDEO_MEM * 1024 * 1024)\r\n*count = (MAX_VIDEO_MEM * 1024 * 1024) / *size;\r\ndev_dbg(icd->parent, "count=%d, size=%d\n", *count, *size);\r\nreturn 0;\r\n}\r\nstatic void free_buffer(struct videobuf_queue *vq, struct mx1_buffer *buf)\r\n{\r\nstruct soc_camera_device *icd = vq->priv_data;\r\nstruct videobuf_buffer *vb = &buf->vb;\r\nBUG_ON(in_interrupt());\r\ndev_dbg(icd->parent, "%s (vb=0x%p) 0x%08lx %d\n", __func__,\r\nvb, vb->baddr, vb->bsize);\r\nvideobuf_waiton(vq, vb, 0, 0);\r\nvideobuf_dma_contig_free(vq, vb);\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic int mx1_videobuf_prepare(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb, enum v4l2_field field)\r\n{\r\nstruct soc_camera_device *icd = vq->priv_data;\r\nstruct mx1_buffer *buf = container_of(vb, struct mx1_buffer, vb);\r\nint ret;\r\nint bytes_per_line = soc_mbus_bytes_per_line(icd->user_width,\r\nicd->current_fmt->host_fmt);\r\nif (bytes_per_line < 0)\r\nreturn bytes_per_line;\r\ndev_dbg(icd->parent, "%s (vb=0x%p) 0x%08lx %d\n", __func__,\r\nvb, vb->baddr, vb->bsize);\r\nWARN_ON(!list_empty(&vb->queue));\r\nBUG_ON(NULL == icd->current_fmt);\r\nbuf->inwork = 1;\r\nif (buf->code != icd->current_fmt->code ||\r\nvb->width != icd->user_width ||\r\nvb->height != icd->user_height ||\r\nvb->field != field) {\r\nbuf->code = icd->current_fmt->code;\r\nvb->width = icd->user_width;\r\nvb->height = icd->user_height;\r\nvb->field = field;\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nvb->size = bytes_per_line * vb->height;\r\nif (0 != vb->baddr && vb->bsize < vb->size) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (vb->state == VIDEOBUF_NEEDS_INIT) {\r\nret = videobuf_iolock(vq, vb, NULL);\r\nif (ret)\r\ngoto fail;\r\nvb->state = VIDEOBUF_PREPARED;\r\n}\r\nbuf->inwork = 0;\r\nreturn 0;\r\nfail:\r\nfree_buffer(vq, buf);\r\nout:\r\nbuf->inwork = 0;\r\nreturn ret;\r\n}\r\nstatic int mx1_camera_setup_dma(struct mx1_camera_dev *pcdev)\r\n{\r\nstruct videobuf_buffer *vbuf = &pcdev->active->vb;\r\nstruct device *dev = pcdev->icd->parent;\r\nint ret;\r\nif (unlikely(!pcdev->active)) {\r\ndev_err(dev, "DMA End IRQ with no active buffer\n");\r\nreturn -EFAULT;\r\n}\r\nret = imx_dma_setup_single(pcdev->dma_chan,\r\nvideobuf_to_dma_contig(vbuf),\r\nvbuf->size, pcdev->res->start +\r\nCSIRXR, DMA_MODE_READ);\r\nif (unlikely(ret))\r\ndev_err(dev, "Failed to setup DMA sg list\n");\r\nreturn ret;\r\n}\r\nstatic void mx1_videobuf_queue(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct soc_camera_device *icd = vq->priv_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct mx1_camera_dev *pcdev = ici->priv;\r\nstruct mx1_buffer *buf = container_of(vb, struct mx1_buffer, vb);\r\ndev_dbg(icd->parent, "%s (vb=0x%p) 0x%08lx %d\n", __func__,\r\nvb, vb->baddr, vb->bsize);\r\nlist_add_tail(&vb->queue, &pcdev->capture);\r\nvb->state = VIDEOBUF_ACTIVE;\r\nif (!pcdev->active) {\r\npcdev->active = buf;\r\nif (!mx1_camera_setup_dma(pcdev)) {\r\nunsigned int temp;\r\ntemp = __raw_readl(pcdev->base + CSICR1) |\r\nCSICR1_SOF_INTEN;\r\n__raw_writel(temp, pcdev->base + CSICR1);\r\n}\r\n}\r\n}\r\nstatic void mx1_videobuf_release(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct mx1_buffer *buf = container_of(vb, struct mx1_buffer, vb);\r\n#ifdef DEBUG\r\nstruct soc_camera_device *icd = vq->priv_data;\r\nstruct device *dev = icd->parent;\r\ndev_dbg(dev, "%s (vb=0x%p) 0x%08lx %d\n", __func__,\r\nvb, vb->baddr, vb->bsize);\r\nswitch (vb->state) {\r\ncase VIDEOBUF_ACTIVE:\r\ndev_dbg(dev, "%s (active)\n", __func__);\r\nbreak;\r\ncase VIDEOBUF_QUEUED:\r\ndev_dbg(dev, "%s (queued)\n", __func__);\r\nbreak;\r\ncase VIDEOBUF_PREPARED:\r\ndev_dbg(dev, "%s (prepared)\n", __func__);\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "%s (unknown)\n", __func__);\r\nbreak;\r\n}\r\n#endif\r\nfree_buffer(vq, buf);\r\n}\r\nstatic void mx1_camera_wakeup(struct mx1_camera_dev *pcdev,\r\nstruct videobuf_buffer *vb,\r\nstruct mx1_buffer *buf)\r\n{\r\nlist_del_init(&vb->queue);\r\nvb->state = VIDEOBUF_DONE;\r\ndo_gettimeofday(&vb->ts);\r\nvb->field_count++;\r\nwake_up(&vb->done);\r\nif (list_empty(&pcdev->capture)) {\r\npcdev->active = NULL;\r\nreturn;\r\n}\r\npcdev->active = list_entry(pcdev->capture.next,\r\nstruct mx1_buffer, vb.queue);\r\nif (likely(!mx1_camera_setup_dma(pcdev))) {\r\nunsigned int temp;\r\ntemp = __raw_readl(pcdev->base + CSICR1) | CSICR1_SOF_INTEN;\r\n__raw_writel(temp, pcdev->base + CSICR1);\r\n}\r\n}\r\nstatic void mx1_camera_dma_irq(int channel, void *data)\r\n{\r\nstruct mx1_camera_dev *pcdev = data;\r\nstruct device *dev = pcdev->icd->parent;\r\nstruct mx1_buffer *buf;\r\nstruct videobuf_buffer *vb;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pcdev->lock, flags);\r\nimx_dma_disable(channel);\r\nif (unlikely(!pcdev->active)) {\r\ndev_err(dev, "DMA End IRQ with no active buffer\n");\r\ngoto out;\r\n}\r\nvb = &pcdev->active->vb;\r\nbuf = container_of(vb, struct mx1_buffer, vb);\r\nWARN_ON(buf->inwork || list_empty(&vb->queue));\r\ndev_dbg(dev, "%s (vb=0x%p) 0x%08lx %d\n", __func__,\r\nvb, vb->baddr, vb->bsize);\r\nmx1_camera_wakeup(pcdev, vb, buf);\r\nout:\r\nspin_unlock_irqrestore(&pcdev->lock, flags);\r\n}\r\nstatic void mx1_camera_init_videobuf(struct videobuf_queue *q,\r\nstruct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct mx1_camera_dev *pcdev = ici->priv;\r\nvideobuf_queue_dma_contig_init(q, &mx1_videobuf_ops, icd->parent,\r\n&pcdev->lock, V4L2_BUF_TYPE_VIDEO_CAPTURE,\r\nV4L2_FIELD_NONE,\r\nsizeof(struct mx1_buffer), icd, &icd->video_lock);\r\n}\r\nstatic int mclk_get_divisor(struct mx1_camera_dev *pcdev)\r\n{\r\nunsigned int mclk = pcdev->mclk;\r\nunsigned long div;\r\nunsigned long lcdclk;\r\nlcdclk = clk_get_rate(pcdev->clk);\r\ndiv = (lcdclk + 2 * mclk - 1) / (2 * mclk) - 1;\r\ndev_dbg(pcdev->icd->parent,\r\n"System clock %lukHz, target freq %dkHz, divisor %lu\n",\r\nlcdclk / 1000, mclk / 1000, div);\r\nreturn div;\r\n}\r\nstatic void mx1_camera_activate(struct mx1_camera_dev *pcdev)\r\n{\r\nunsigned int csicr1 = CSICR1_EN;\r\ndev_dbg(pcdev->icd->parent, "Activate device\n");\r\nclk_enable(pcdev->clk);\r\n__raw_writel(csicr1, pcdev->base + CSICR1);\r\ncsicr1 |= CSICR1_MCLKEN | CSICR1_FCC | CSICR1_GCLK_MODE;\r\ncsicr1 |= CSICR1_MCLKDIV(mclk_get_divisor(pcdev));\r\ncsicr1 |= CSICR1_RXFF_LEVEL(2);\r\n__raw_writel(csicr1, pcdev->base + CSICR1);\r\n}\r\nstatic void mx1_camera_deactivate(struct mx1_camera_dev *pcdev)\r\n{\r\ndev_dbg(pcdev->icd->parent, "Deactivate device\n");\r\n__raw_writel(0x00, pcdev->base + CSICR1);\r\nclk_disable(pcdev->clk);\r\n}\r\nstatic int mx1_camera_add_device(struct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct mx1_camera_dev *pcdev = ici->priv;\r\nif (pcdev->icd)\r\nreturn -EBUSY;\r\ndev_info(icd->parent, "MX1 Camera driver attached to camera %d\n",\r\nicd->devnum);\r\nmx1_camera_activate(pcdev);\r\npcdev->icd = icd;\r\nreturn 0;\r\n}\r\nstatic void mx1_camera_remove_device(struct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct mx1_camera_dev *pcdev = ici->priv;\r\nunsigned int csicr1;\r\nBUG_ON(icd != pcdev->icd);\r\ncsicr1 = __raw_readl(pcdev->base + CSICR1) & ~CSI_IRQ_MASK;\r\n__raw_writel(csicr1, pcdev->base + CSICR1);\r\nimx_dma_disable(pcdev->dma_chan);\r\ndev_info(icd->parent, "MX1 Camera driver detached from camera %d\n",\r\nicd->devnum);\r\nmx1_camera_deactivate(pcdev);\r\npcdev->icd = NULL;\r\n}\r\nstatic int mx1_camera_set_crop(struct soc_camera_device *icd,\r\nstruct v4l2_crop *a)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nreturn v4l2_subdev_call(sd, video, s_crop, a);\r\n}\r\nstatic int mx1_camera_set_bus_param(struct soc_camera_device *icd)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct mx1_camera_dev *pcdev = ici->priv;\r\nstruct v4l2_mbus_config cfg = {.type = V4L2_MBUS_PARALLEL,};\r\nunsigned long common_flags;\r\nunsigned int csicr1;\r\nint ret;\r\nret = v4l2_subdev_call(sd, video, g_mbus_config, &cfg);\r\nif (!ret) {\r\ncommon_flags = soc_mbus_config_compatible(&cfg, CSI_BUS_FLAGS);\r\nif (!common_flags) {\r\ndev_warn(icd->parent,\r\n"Flags incompatible: camera 0x%x, host 0x%x\n",\r\ncfg.flags, CSI_BUS_FLAGS);\r\nreturn -EINVAL;\r\n}\r\n} else if (ret != -ENOIOCTLCMD) {\r\nreturn ret;\r\n} else {\r\ncommon_flags = CSI_BUS_FLAGS;\r\n}\r\nif ((common_flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH) &&\r\n(common_flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)) {\r\nif (!pcdev->pdata ||\r\npcdev->pdata->flags & MX1_CAMERA_VSYNC_HIGH)\r\ncommon_flags &= ~V4L2_MBUS_VSYNC_ACTIVE_LOW;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_VSYNC_ACTIVE_HIGH;\r\n}\r\nif ((common_flags & V4L2_MBUS_PCLK_SAMPLE_RISING) &&\r\n(common_flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)) {\r\nif (!pcdev->pdata ||\r\npcdev->pdata->flags & MX1_CAMERA_PCLK_RISING)\r\ncommon_flags &= ~V4L2_MBUS_PCLK_SAMPLE_FALLING;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_PCLK_SAMPLE_RISING;\r\n}\r\nif ((common_flags & V4L2_MBUS_DATA_ACTIVE_HIGH) &&\r\n(common_flags & V4L2_MBUS_DATA_ACTIVE_LOW)) {\r\nif (!pcdev->pdata ||\r\npcdev->pdata->flags & MX1_CAMERA_DATA_HIGH)\r\ncommon_flags &= ~V4L2_MBUS_DATA_ACTIVE_LOW;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_DATA_ACTIVE_HIGH;\r\n}\r\ncfg.flags = common_flags;\r\nret = v4l2_subdev_call(sd, video, s_mbus_config, &cfg);\r\nif (ret < 0 && ret != -ENOIOCTLCMD) {\r\ndev_dbg(icd->parent, "camera s_mbus_config(0x%lx) returned %d\n",\r\ncommon_flags, ret);\r\nreturn ret;\r\n}\r\ncsicr1 = __raw_readl(pcdev->base + CSICR1);\r\nif (common_flags & V4L2_MBUS_PCLK_SAMPLE_RISING)\r\ncsicr1 |= CSICR1_REDGE;\r\nif (common_flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)\r\ncsicr1 |= CSICR1_SOF_POL;\r\nif (common_flags & V4L2_MBUS_DATA_ACTIVE_LOW)\r\ncsicr1 |= CSICR1_DATA_POL;\r\n__raw_writel(csicr1, pcdev->base + CSICR1);\r\nreturn 0;\r\n}\r\nstatic int mx1_camera_set_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_format *f)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nconst struct soc_camera_format_xlate *xlate;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_mbus_framefmt mf;\r\nint ret, buswidth;\r\nxlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);\r\nif (!xlate) {\r\ndev_warn(icd->parent, "Format %x not found\n",\r\npix->pixelformat);\r\nreturn -EINVAL;\r\n}\r\nbuswidth = xlate->host_fmt->bits_per_sample;\r\nif (buswidth > 8) {\r\ndev_warn(icd->parent,\r\n"bits-per-sample %d for format %x unsupported\n",\r\nbuswidth, pix->pixelformat);\r\nreturn -EINVAL;\r\n}\r\nmf.width = pix->width;\r\nmf.height = pix->height;\r\nmf.field = pix->field;\r\nmf.colorspace = pix->colorspace;\r\nmf.code = xlate->code;\r\nret = v4l2_subdev_call(sd, video, s_mbus_fmt, &mf);\r\nif (ret < 0)\r\nreturn ret;\r\nif (mf.code != xlate->code)\r\nreturn -EINVAL;\r\npix->width = mf.width;\r\npix->height = mf.height;\r\npix->field = mf.field;\r\npix->colorspace = mf.colorspace;\r\nicd->current_fmt = xlate;\r\nreturn ret;\r\n}\r\nstatic int mx1_camera_try_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_format *f)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nconst struct soc_camera_format_xlate *xlate;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_mbus_framefmt mf;\r\nint ret;\r\nxlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);\r\nif (!xlate) {\r\ndev_warn(icd->parent, "Format %x not found\n",\r\npix->pixelformat);\r\nreturn -EINVAL;\r\n}\r\nmf.width = pix->width;\r\nmf.height = pix->height;\r\nmf.field = pix->field;\r\nmf.colorspace = pix->colorspace;\r\nmf.code = xlate->code;\r\nret = v4l2_subdev_call(sd, video, try_mbus_fmt, &mf);\r\nif (ret < 0)\r\nreturn ret;\r\npix->width = mf.width;\r\npix->height = mf.height;\r\npix->field = mf.field;\r\npix->colorspace = mf.colorspace;\r\nreturn 0;\r\n}\r\nstatic int mx1_camera_reqbufs(struct soc_camera_device *icd,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nint i;\r\nfor (i = 0; i < p->count; i++) {\r\nstruct mx1_buffer *buf = container_of(icd->vb_vidq.bufs[i],\r\nstruct mx1_buffer, vb);\r\nbuf->inwork = 0;\r\nINIT_LIST_HEAD(&buf->vb.queue);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int mx1_camera_poll(struct file *file, poll_table *pt)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct mx1_buffer *buf;\r\nbuf = list_entry(icd->vb_vidq.stream.next, struct mx1_buffer,\r\nvb.stream);\r\npoll_wait(file, &buf->vb.done, pt);\r\nif (buf->vb.state == VIDEOBUF_DONE ||\r\nbuf->vb.state == VIDEOBUF_ERROR)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int mx1_camera_querycap(struct soc_camera_host *ici,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrlcpy(cap->card, "i.MX1/i.MXL Camera", sizeof(cap->card));\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\nreturn 0;\r\n}\r\nstatic int __init mx1_camera_probe(struct platform_device *pdev)\r\n{\r\nstruct mx1_camera_dev *pcdev;\r\nstruct resource *res;\r\nstruct pt_regs regs;\r\nstruct clk *clk;\r\nvoid __iomem *base;\r\nunsigned int irq;\r\nint err = 0;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!res || (int)irq <= 0) {\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\nclk = clk_get(&pdev->dev, "csi_clk");\r\nif (IS_ERR(clk)) {\r\nerr = PTR_ERR(clk);\r\ngoto exit;\r\n}\r\npcdev = kzalloc(sizeof(*pcdev), GFP_KERNEL);\r\nif (!pcdev) {\r\ndev_err(&pdev->dev, "Could not allocate pcdev\n");\r\nerr = -ENOMEM;\r\ngoto exit_put_clk;\r\n}\r\npcdev->res = res;\r\npcdev->clk = clk;\r\npcdev->pdata = pdev->dev.platform_data;\r\nif (pcdev->pdata)\r\npcdev->mclk = pcdev->pdata->mclk_10khz * 10000;\r\nif (!pcdev->mclk) {\r\ndev_warn(&pdev->dev,\r\n"mclk_10khz == 0! Please, fix your platform data. "\r\n"Using default 20MHz\n");\r\npcdev->mclk = 20000000;\r\n}\r\nINIT_LIST_HEAD(&pcdev->capture);\r\nspin_lock_init(&pcdev->lock);\r\nif (!request_mem_region(res->start, resource_size(res), DRIVER_NAME)) {\r\nerr = -EBUSY;\r\ngoto exit_kfree;\r\n}\r\nbase = ioremap(res->start, resource_size(res));\r\nif (!base) {\r\nerr = -ENOMEM;\r\ngoto exit_release;\r\n}\r\npcdev->irq = irq;\r\npcdev->base = base;\r\npcdev->dma_chan = imx_dma_request_by_prio(DRIVER_NAME, DMA_PRIO_HIGH);\r\nif (pcdev->dma_chan < 0) {\r\ndev_err(&pdev->dev, "Can't request DMA for MX1 CSI\n");\r\nerr = -EBUSY;\r\ngoto exit_iounmap;\r\n}\r\ndev_dbg(&pdev->dev, "got DMA channel %d\n", pcdev->dma_chan);\r\nimx_dma_setup_handlers(pcdev->dma_chan, mx1_camera_dma_irq, NULL,\r\npcdev);\r\nimx_dma_config_channel(pcdev->dma_chan, IMX_DMA_TYPE_FIFO,\r\nIMX_DMA_MEMSIZE_32, MX1_DMA_REQ_CSI_R, 0);\r\nimx_dma_config_burstlen(pcdev->dma_chan, 0);\r\nerr = claim_fiq(&fh);\r\nif (err) {\r\ndev_err(&pdev->dev, "Camera interrupt register failed \n");\r\ngoto exit_free_dma;\r\n}\r\nset_fiq_handler(&mx1_camera_sof_fiq_start, &mx1_camera_sof_fiq_end -\r\n&mx1_camera_sof_fiq_start);\r\nregs.ARM_r8 = (long)MX1_DMA_DIMR;\r\nregs.ARM_r9 = (long)MX1_DMA_CCR(pcdev->dma_chan);\r\nregs.ARM_r10 = (long)pcdev->base + CSICR1;\r\nregs.ARM_fp = (long)pcdev->base + CSISR;\r\nregs.ARM_sp = 1 << pcdev->dma_chan;\r\nset_fiq_regs(&regs);\r\nmxc_set_irq_fiq(irq, 1);\r\nenable_fiq(irq);\r\npcdev->soc_host.drv_name = DRIVER_NAME;\r\npcdev->soc_host.ops = &mx1_soc_camera_host_ops;\r\npcdev->soc_host.priv = pcdev;\r\npcdev->soc_host.v4l2_dev.dev = &pdev->dev;\r\npcdev->soc_host.nr = pdev->id;\r\nerr = soc_camera_host_register(&pcdev->soc_host);\r\nif (err)\r\ngoto exit_free_irq;\r\ndev_info(&pdev->dev, "MX1 Camera driver loaded\n");\r\nreturn 0;\r\nexit_free_irq:\r\ndisable_fiq(irq);\r\nmxc_set_irq_fiq(irq, 0);\r\nrelease_fiq(&fh);\r\nexit_free_dma:\r\nimx_dma_free(pcdev->dma_chan);\r\nexit_iounmap:\r\niounmap(base);\r\nexit_release:\r\nrelease_mem_region(res->start, resource_size(res));\r\nexit_kfree:\r\nkfree(pcdev);\r\nexit_put_clk:\r\nclk_put(clk);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int __exit mx1_camera_remove(struct platform_device *pdev)\r\n{\r\nstruct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);\r\nstruct mx1_camera_dev *pcdev = container_of(soc_host,\r\nstruct mx1_camera_dev, soc_host);\r\nstruct resource *res;\r\nimx_dma_free(pcdev->dma_chan);\r\ndisable_fiq(pcdev->irq);\r\nmxc_set_irq_fiq(pcdev->irq, 0);\r\nrelease_fiq(&fh);\r\nclk_put(pcdev->clk);\r\nsoc_camera_host_unregister(soc_host);\r\niounmap(pcdev->base);\r\nres = pcdev->res;\r\nrelease_mem_region(res->start, resource_size(res));\r\nkfree(pcdev);\r\ndev_info(&pdev->dev, "MX1 Camera driver unloaded\n");\r\nreturn 0;\r\n}\r\nstatic int __init mx1_camera_init(void)\r\n{\r\nreturn platform_driver_probe(&mx1_camera_driver, mx1_camera_probe);\r\n}\r\nstatic void __exit mx1_camera_exit(void)\r\n{\r\nreturn platform_driver_unregister(&mx1_camera_driver);\r\n}
