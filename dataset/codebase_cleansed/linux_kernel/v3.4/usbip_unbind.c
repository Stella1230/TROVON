void usbip_unbind_usage(void)\r\n{\r\nprintf("usage: %s", usbip_unbind_usage_string);\r\n}\r\nstatic int unbind_device(char *busid)\r\n{\r\nchar bus_type[] = "usb";\r\nstruct sysfs_driver *usbip_host_drv;\r\nstruct sysfs_device *dev;\r\nstruct dlist *devlist;\r\nint verified = 0;\r\nint rc, ret = -1;\r\nchar attr_name[] = "bConfigurationValue";\r\nchar sysfs_mntpath[SYSFS_PATH_MAX];\r\nchar busid_attr_path[SYSFS_PATH_MAX];\r\nstruct sysfs_attribute *busid_attr;\r\nchar *val = NULL;\r\nint len;\r\nusbip_host_drv = sysfs_open_driver(bus_type, USBIP_HOST_DRV_NAME);\r\nif (!usbip_host_drv) {\r\nerr("could not open %s driver: %s", USBIP_HOST_DRV_NAME,\r\nstrerror(errno));\r\nreturn -1;\r\n}\r\ndevlist = sysfs_get_driver_devices(usbip_host_drv);\r\nif (!devlist) {\r\nerr("%s is not in use by any devices", USBIP_HOST_DRV_NAME);\r\ngoto err_close_usbip_host_drv;\r\n}\r\ndlist_for_each_data(devlist, dev, struct sysfs_device) {\r\nif (!strncmp(busid, dev->name, strlen(busid)) &&\r\n!strncmp(dev->driver_name, USBIP_HOST_DRV_NAME,\r\nstrlen(USBIP_HOST_DRV_NAME))) {\r\nverified = 1;\r\nbreak;\r\n}\r\n}\r\nif (!verified) {\r\nerr("device on busid %s is not using %s", busid,\r\nUSBIP_HOST_DRV_NAME);\r\ngoto err_close_usbip_host_drv;\r\n}\r\nrc = sysfs_get_mnt_path(sysfs_mntpath, SYSFS_PATH_MAX);\r\nif (rc < 0) {\r\nerr("sysfs must be mounted: %s", strerror(errno));\r\nreturn -1;\r\n}\r\nsnprintf(busid_attr_path, sizeof(busid_attr_path), "%s/%s/%s/%s/%s/%s",\r\nsysfs_mntpath, SYSFS_BUS_NAME, bus_type, SYSFS_DEVICES_NAME,\r\nbusid, attr_name);\r\nbusid_attr = sysfs_open_attribute(busid_attr_path);\r\nif (!busid_attr) {\r\nerr("could not open %s/%s: %s", busid, attr_name,\r\nstrerror(errno));\r\nreturn -1;\r\n}\r\nif (sysfs_read_attribute(busid_attr) < 0) {\r\nerr("problem reading attribute: %s", strerror(errno));\r\ngoto err_out;\r\n}\r\nlen = busid_attr->len;\r\nval = malloc(len);\r\n*val = *busid_attr->value;\r\nsysfs_close_attribute(busid_attr);\r\nrc = modify_match_busid(busid, 0);\r\nif (rc < 0) {\r\nerr("unable to unbind device on %s", busid);\r\ngoto err_out;\r\n}\r\nbusid_attr = sysfs_open_attribute(busid_attr_path);\r\nif (!busid_attr) {\r\nerr("could not open %s/%s: %s", busid, attr_name,\r\nstrerror(errno));\r\nreturn -1;\r\n}\r\nrc = sysfs_write_attribute(busid_attr, val, len);\r\nif (rc < 0) {\r\nerr("problem writing attribute: %s", strerror(errno));\r\ngoto err_out;\r\n}\r\nsysfs_close_attribute(busid_attr);\r\nret = 0;\r\nprintf("unbind device on busid %s: complete\n", busid);\r\nerr_out:\r\nfree(val);\r\nerr_close_usbip_host_drv:\r\nsysfs_close_driver(usbip_host_drv);\r\nreturn ret;\r\n}\r\nint usbip_unbind(int argc, char *argv[])\r\n{\r\nstatic const struct option opts[] = {\r\n{ "busid", required_argument, NULL, 'b' },\r\n{ NULL, 0, NULL, 0 }\r\n};\r\nint opt;\r\nint ret = -1;\r\nfor (;;) {\r\nopt = getopt_long(argc, argv, "b:", opts, NULL);\r\nif (opt == -1)\r\nbreak;\r\nswitch (opt) {\r\ncase 'b':\r\nret = unbind_device(optarg);\r\ngoto out;\r\ndefault:\r\ngoto err_out;\r\n}\r\n}\r\nerr_out:\r\nusbip_unbind_usage();\r\nout:\r\nreturn ret;\r\n}
