static void ulog_send(unsigned int nlgroup)\r\n{\r\nebt_ulog_buff_t *ub = &ulog_buffers[nlgroup];\r\nif (timer_pending(&ub->timer))\r\ndel_timer(&ub->timer);\r\nif (!ub->skb)\r\nreturn;\r\nif (ub->qlen > 1)\r\nub->lastnlh->nlmsg_type = NLMSG_DONE;\r\nNETLINK_CB(ub->skb).dst_group = nlgroup + 1;\r\nnetlink_broadcast(ebtulognl, ub->skb, 0, nlgroup + 1, GFP_ATOMIC);\r\nub->qlen = 0;\r\nub->skb = NULL;\r\n}\r\nstatic void ulog_timer(unsigned long data)\r\n{\r\nspin_lock_bh(&ulog_buffers[data].lock);\r\nif (ulog_buffers[data].skb)\r\nulog_send(data);\r\nspin_unlock_bh(&ulog_buffers[data].lock);\r\n}\r\nstatic struct sk_buff *ulog_alloc_skb(unsigned int size)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned int n;\r\nn = max(size, nlbufsiz);\r\nskb = alloc_skb(n, GFP_ATOMIC | __GFP_NOWARN);\r\nif (!skb) {\r\nif (n > size) {\r\nskb = alloc_skb(size, GFP_ATOMIC);\r\nif (!skb)\r\npr_debug("cannot even allocate buffer of size %ub\n",\r\nsize);\r\n}\r\n}\r\nreturn skb;\r\n}\r\nstatic void ebt_ulog_packet(unsigned int hooknr, const struct sk_buff *skb,\r\nconst struct net_device *in, const struct net_device *out,\r\nconst struct ebt_ulog_info *uloginfo, const char *prefix)\r\n{\r\nebt_ulog_packet_msg_t *pm;\r\nsize_t size, copy_len;\r\nstruct nlmsghdr *nlh;\r\nunsigned int group = uloginfo->nlgroup;\r\nebt_ulog_buff_t *ub = &ulog_buffers[group];\r\nspinlock_t *lock = &ub->lock;\r\nktime_t kt;\r\nif ((uloginfo->cprange == 0) ||\r\n(uloginfo->cprange > skb->len + ETH_HLEN))\r\ncopy_len = skb->len + ETH_HLEN;\r\nelse\r\ncopy_len = uloginfo->cprange;\r\nsize = NLMSG_SPACE(sizeof(*pm) + copy_len);\r\nif (size > nlbufsiz) {\r\npr_debug("Size %Zd needed, but nlbufsiz=%d\n", size, nlbufsiz);\r\nreturn;\r\n}\r\nspin_lock_bh(lock);\r\nif (!ub->skb) {\r\nif (!(ub->skb = ulog_alloc_skb(size)))\r\ngoto alloc_failure;\r\n} else if (size > skb_tailroom(ub->skb)) {\r\nulog_send(group);\r\nif (!(ub->skb = ulog_alloc_skb(size)))\r\ngoto alloc_failure;\r\n}\r\nnlh = NLMSG_PUT(ub->skb, 0, ub->qlen, 0,\r\nsize - NLMSG_ALIGN(sizeof(*nlh)));\r\nub->qlen++;\r\npm = NLMSG_DATA(nlh);\r\npm->version = EBT_ULOG_VERSION;\r\nkt = ktime_get_real();\r\npm->stamp = ktime_to_timeval(kt);\r\nif (ub->qlen == 1)\r\nub->skb->tstamp = kt;\r\npm->data_len = copy_len;\r\npm->mark = skb->mark;\r\npm->hook = hooknr;\r\nif (uloginfo->prefix != NULL)\r\nstrcpy(pm->prefix, uloginfo->prefix);\r\nelse\r\n*(pm->prefix) = '\0';\r\nif (in) {\r\nstrcpy(pm->physindev, in->name);\r\nif (br_port_exists(in))\r\nstrcpy(pm->indev, br_port_get_rcu(in)->br->dev->name);\r\nelse\r\nstrcpy(pm->indev, in->name);\r\n} else\r\npm->indev[0] = pm->physindev[0] = '\0';\r\nif (out) {\r\nstrcpy(pm->physoutdev, out->name);\r\nstrcpy(pm->outdev, br_port_get_rcu(out)->br->dev->name);\r\n} else\r\npm->outdev[0] = pm->physoutdev[0] = '\0';\r\nif (skb_copy_bits(skb, -ETH_HLEN, pm->data, copy_len) < 0)\r\nBUG();\r\nif (ub->qlen > 1)\r\nub->lastnlh->nlmsg_flags |= NLM_F_MULTI;\r\nub->lastnlh = nlh;\r\nif (ub->qlen >= uloginfo->qthreshold)\r\nulog_send(group);\r\nelse if (!timer_pending(&ub->timer)) {\r\nub->timer.expires = jiffies + flushtimeout * HZ / 100;\r\nadd_timer(&ub->timer);\r\n}\r\nunlock:\r\nspin_unlock_bh(lock);\r\nreturn;\r\nnlmsg_failure:\r\npr_debug("error during NLMSG_PUT. This should "\r\n"not happen, please report to author.\n");\r\nalloc_failure:\r\ngoto unlock;\r\n}\r\nstatic void ebt_log_packet(u_int8_t pf, unsigned int hooknum,\r\nconst struct sk_buff *skb, const struct net_device *in,\r\nconst struct net_device *out, const struct nf_loginfo *li,\r\nconst char *prefix)\r\n{\r\nstruct ebt_ulog_info loginfo;\r\nif (!li || li->type != NF_LOG_TYPE_ULOG) {\r\nloginfo.nlgroup = EBT_ULOG_DEFAULT_NLGROUP;\r\nloginfo.cprange = 0;\r\nloginfo.qthreshold = EBT_ULOG_DEFAULT_QTHRESHOLD;\r\nloginfo.prefix[0] = '\0';\r\n} else {\r\nloginfo.nlgroup = li->u.ulog.group;\r\nloginfo.cprange = li->u.ulog.copy_len;\r\nloginfo.qthreshold = li->u.ulog.qthreshold;\r\nstrlcpy(loginfo.prefix, prefix, sizeof(loginfo.prefix));\r\n}\r\nebt_ulog_packet(hooknum, skb, in, out, &loginfo, prefix);\r\n}\r\nstatic unsigned int\r\nebt_ulog_tg(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nebt_ulog_packet(par->hooknum, skb, par->in, par->out,\r\npar->targinfo, NULL);\r\nreturn EBT_CONTINUE;\r\n}\r\nstatic int ebt_ulog_tg_check(const struct xt_tgchk_param *par)\r\n{\r\nstruct ebt_ulog_info *uloginfo = par->targinfo;\r\nif (uloginfo->nlgroup > 31)\r\nreturn -EINVAL;\r\nuloginfo->prefix[EBT_ULOG_PREFIX_LEN - 1] = '\0';\r\nif (uloginfo->qthreshold > EBT_ULOG_MAX_QLEN)\r\nuloginfo->qthreshold = EBT_ULOG_MAX_QLEN;\r\nreturn 0;\r\n}\r\nstatic int __init ebt_ulog_init(void)\r\n{\r\nint ret;\r\nint i;\r\nif (nlbufsiz >= 128*1024) {\r\npr_warning("Netlink buffer has to be <= 128kB,"\r\n" please try a smaller nlbufsiz parameter.\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < EBT_ULOG_MAXNLGROUPS; i++) {\r\nsetup_timer(&ulog_buffers[i].timer, ulog_timer, i);\r\nspin_lock_init(&ulog_buffers[i].lock);\r\n}\r\nebtulognl = netlink_kernel_create(&init_net, NETLINK_NFLOG,\r\nEBT_ULOG_MAXNLGROUPS, NULL, NULL,\r\nTHIS_MODULE);\r\nif (!ebtulognl)\r\nret = -ENOMEM;\r\nelse if ((ret = xt_register_target(&ebt_ulog_tg_reg)) != 0)\r\nnetlink_kernel_release(ebtulognl);\r\nif (ret == 0)\r\nnf_log_register(NFPROTO_BRIDGE, &ebt_ulog_logger);\r\nreturn ret;\r\n}\r\nstatic void __exit ebt_ulog_fini(void)\r\n{\r\nebt_ulog_buff_t *ub;\r\nint i;\r\nnf_log_unregister(&ebt_ulog_logger);\r\nxt_unregister_target(&ebt_ulog_tg_reg);\r\nfor (i = 0; i < EBT_ULOG_MAXNLGROUPS; i++) {\r\nub = &ulog_buffers[i];\r\nif (timer_pending(&ub->timer))\r\ndel_timer(&ub->timer);\r\nspin_lock_bh(&ub->lock);\r\nif (ub->skb) {\r\nkfree_skb(ub->skb);\r\nub->skb = NULL;\r\n}\r\nspin_unlock_bh(&ub->lock);\r\n}\r\nnetlink_kernel_release(ebtulognl);\r\n}
