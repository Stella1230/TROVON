void usb_wwan_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct usb_wwan_port_private *portdata;\r\nstruct usb_wwan_intf_private *intfdata;\r\ndbg("%s", __func__);\r\nintfdata = port->serial->private;\r\nif (!intfdata->send_setup)\r\nreturn;\r\nportdata = usb_get_serial_port_data(port);\r\nmutex_lock(&serial->disc_mutex);\r\nportdata->rts_state = on;\r\nportdata->dtr_state = on;\r\nif (serial->dev)\r\nintfdata->send_setup(port);\r\nmutex_unlock(&serial->disc_mutex);\r\n}\r\nvoid usb_wwan_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct usb_wwan_intf_private *intfdata = port->serial->private;\r\ndbg("%s", __func__);\r\ntty_termios_copy_hw(tty->termios, old_termios);\r\nif (intfdata->send_setup)\r\nintfdata->send_setup(port);\r\n}\r\nint usb_wwan_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nunsigned int value;\r\nstruct usb_wwan_port_private *portdata;\r\nportdata = usb_get_serial_port_data(port);\r\nvalue = ((portdata->rts_state) ? TIOCM_RTS : 0) |\r\n((portdata->dtr_state) ? TIOCM_DTR : 0) |\r\n((portdata->cts_state) ? TIOCM_CTS : 0) |\r\n((portdata->dsr_state) ? TIOCM_DSR : 0) |\r\n((portdata->dcd_state) ? TIOCM_CAR : 0) |\r\n((portdata->ri_state) ? TIOCM_RNG : 0);\r\nreturn value;\r\n}\r\nint usb_wwan_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_wwan_port_private *portdata;\r\nstruct usb_wwan_intf_private *intfdata;\r\nportdata = usb_get_serial_port_data(port);\r\nintfdata = port->serial->private;\r\nif (!intfdata->send_setup)\r\nreturn -EINVAL;\r\nif (set & TIOCM_RTS)\r\nportdata->rts_state = 1;\r\nif (set & TIOCM_DTR)\r\nportdata->dtr_state = 1;\r\nif (clear & TIOCM_RTS)\r\nportdata->rts_state = 0;\r\nif (clear & TIOCM_DTR)\r\nportdata->dtr_state = 0;\r\nreturn intfdata->send_setup(port);\r\n}\r\nstatic int get_serial_info(struct usb_serial_port *port,\r\nstruct serial_struct __user *retinfo)\r\n{\r\nstruct serial_struct tmp;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntmp.line = port->serial->minor;\r\ntmp.port = port->number;\r\ntmp.baud_base = tty_get_baud_rate(port->port.tty);\r\ntmp.close_delay = port->port.close_delay / 10;\r\ntmp.closing_wait = port->port.closing_wait == ASYNC_CLOSING_WAIT_NONE ?\r\nASYNC_CLOSING_WAIT_NONE :\r\nport->port.closing_wait / 10;\r\nif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int set_serial_info(struct usb_serial_port *port,\r\nstruct serial_struct __user *newinfo)\r\n{\r\nstruct serial_struct new_serial;\r\nunsigned int closing_wait, close_delay;\r\nint retval = 0;\r\nif (copy_from_user(&new_serial, newinfo, sizeof(new_serial)))\r\nreturn -EFAULT;\r\nclose_delay = new_serial.close_delay * 10;\r\nclosing_wait = new_serial.closing_wait == ASYNC_CLOSING_WAIT_NONE ?\r\nASYNC_CLOSING_WAIT_NONE : new_serial.closing_wait * 10;\r\nmutex_lock(&port->port.mutex);\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nif ((close_delay != port->port.close_delay) ||\r\n(closing_wait != port->port.closing_wait))\r\nretval = -EPERM;\r\nelse\r\nretval = -EOPNOTSUPP;\r\n} else {\r\nport->port.close_delay = close_delay;\r\nport->port.closing_wait = closing_wait;\r\n}\r\nmutex_unlock(&port->port.mutex);\r\nreturn retval;\r\n}\r\nint usb_wwan_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\ndbg("%s cmd 0x%04x", __func__, cmd);\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nreturn get_serial_info(port,\r\n(struct serial_struct __user *) arg);\r\ncase TIOCSSERIAL:\r\nreturn set_serial_info(port,\r\n(struct serial_struct __user *) arg);\r\ndefault:\r\nbreak;\r\n}\r\ndbg("%s arg not supported", __func__);\r\nreturn -ENOIOCTLCMD;\r\n}\r\nint usb_wwan_write(struct tty_struct *tty, struct usb_serial_port *port,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct usb_wwan_port_private *portdata;\r\nstruct usb_wwan_intf_private *intfdata;\r\nint i;\r\nint left, todo;\r\nstruct urb *this_urb = NULL;\r\nint err;\r\nunsigned long flags;\r\nportdata = usb_get_serial_port_data(port);\r\nintfdata = port->serial->private;\r\ndbg("%s: write (%d chars)", __func__, count);\r\ni = 0;\r\nleft = count;\r\nfor (i = 0; left > 0 && i < N_OUT_URB; i++) {\r\ntodo = left;\r\nif (todo > OUT_BUFLEN)\r\ntodo = OUT_BUFLEN;\r\nthis_urb = portdata->out_urbs[i];\r\nif (test_and_set_bit(i, &portdata->out_busy)) {\r\nif (time_before(jiffies,\r\nportdata->tx_start_time[i] + 10 * HZ))\r\ncontinue;\r\nusb_unlink_urb(this_urb);\r\ncontinue;\r\n}\r\ndbg("%s: endpoint %d buf %d", __func__,\r\nusb_pipeendpoint(this_urb->pipe), i);\r\nerr = usb_autopm_get_interface_async(port->serial->interface);\r\nif (err < 0)\r\nbreak;\r\nmemcpy(this_urb->transfer_buffer, buf, todo);\r\nthis_urb->transfer_buffer_length = todo;\r\nspin_lock_irqsave(&intfdata->susp_lock, flags);\r\nif (intfdata->suspended) {\r\nusb_anchor_urb(this_urb, &portdata->delayed);\r\nspin_unlock_irqrestore(&intfdata->susp_lock, flags);\r\n} else {\r\nintfdata->in_flight++;\r\nspin_unlock_irqrestore(&intfdata->susp_lock, flags);\r\nerr = usb_submit_urb(this_urb, GFP_ATOMIC);\r\nif (err) {\r\ndbg("usb_submit_urb %p (write bulk) failed "\r\n"(%d)", this_urb, err);\r\nclear_bit(i, &portdata->out_busy);\r\nspin_lock_irqsave(&intfdata->susp_lock, flags);\r\nintfdata->in_flight--;\r\nspin_unlock_irqrestore(&intfdata->susp_lock,\r\nflags);\r\nusb_autopm_put_interface_async(port->serial->interface);\r\nbreak;\r\n}\r\n}\r\nportdata->tx_start_time[i] = jiffies;\r\nbuf += todo;\r\nleft -= todo;\r\n}\r\ncount -= left;\r\ndbg("%s: wrote (did %d)", __func__, count);\r\nreturn count;\r\n}\r\nstatic void usb_wwan_indat_callback(struct urb *urb)\r\n{\r\nint err;\r\nint endpoint;\r\nstruct usb_serial_port *port;\r\nstruct tty_struct *tty;\r\nunsigned char *data = urb->transfer_buffer;\r\nint status = urb->status;\r\ndbg("%s: %p", __func__, urb);\r\nendpoint = usb_pipeendpoint(urb->pipe);\r\nport = urb->context;\r\nif (status) {\r\ndbg("%s: nonzero status: %d on endpoint %02x.",\r\n__func__, status, endpoint);\r\n} else {\r\ntty = tty_port_tty_get(&port->port);\r\nif (tty) {\r\nif (urb->actual_length) {\r\ntty_insert_flip_string(tty, data,\r\nurb->actual_length);\r\ntty_flip_buffer_push(tty);\r\n} else\r\ndbg("%s: empty read urb received", __func__);\r\ntty_kref_put(tty);\r\n}\r\nif (status != -ESHUTDOWN) {\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err) {\r\nif (err != -EPERM) {\r\nprintk(KERN_ERR "%s: resubmit read urb failed. "\r\n"(%d)", __func__, err);\r\nusb_mark_last_busy(port->serial->dev);\r\n}\r\n} else {\r\nusb_mark_last_busy(port->serial->dev);\r\n}\r\n}\r\n}\r\n}\r\nstatic void usb_wwan_outdat_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port;\r\nstruct usb_wwan_port_private *portdata;\r\nstruct usb_wwan_intf_private *intfdata;\r\nint i;\r\ndbg("%s", __func__);\r\nport = urb->context;\r\nintfdata = port->serial->private;\r\nusb_serial_port_softint(port);\r\nusb_autopm_put_interface_async(port->serial->interface);\r\nportdata = usb_get_serial_port_data(port);\r\nspin_lock(&intfdata->susp_lock);\r\nintfdata->in_flight--;\r\nspin_unlock(&intfdata->susp_lock);\r\nfor (i = 0; i < N_OUT_URB; ++i) {\r\nif (portdata->out_urbs[i] == urb) {\r\nsmp_mb__before_clear_bit();\r\nclear_bit(i, &portdata->out_busy);\r\nbreak;\r\n}\r\n}\r\n}\r\nint usb_wwan_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_wwan_port_private *portdata;\r\nint i;\r\nint data_len = 0;\r\nstruct urb *this_urb;\r\nportdata = usb_get_serial_port_data(port);\r\nfor (i = 0; i < N_OUT_URB; i++) {\r\nthis_urb = portdata->out_urbs[i];\r\nif (this_urb && !test_bit(i, &portdata->out_busy))\r\ndata_len += OUT_BUFLEN;\r\n}\r\ndbg("%s: %d", __func__, data_len);\r\nreturn data_len;\r\n}\r\nint usb_wwan_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_wwan_port_private *portdata;\r\nint i;\r\nint data_len = 0;\r\nstruct urb *this_urb;\r\nportdata = usb_get_serial_port_data(port);\r\nfor (i = 0; i < N_OUT_URB; i++) {\r\nthis_urb = portdata->out_urbs[i];\r\nif (this_urb && test_bit(i, &portdata->out_busy))\r\ndata_len += this_urb->transfer_buffer_length;\r\n}\r\ndbg("%s: %d", __func__, data_len);\r\nreturn data_len;\r\n}\r\nint usb_wwan_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct usb_wwan_port_private *portdata;\r\nstruct usb_wwan_intf_private *intfdata;\r\nstruct usb_serial *serial = port->serial;\r\nint i, err;\r\nstruct urb *urb;\r\nportdata = usb_get_serial_port_data(port);\r\nintfdata = serial->private;\r\ndbg("%s", __func__);\r\nfor (i = 0; i < N_IN_URB; i++) {\r\nurb = portdata->in_urbs[i];\r\nif (!urb)\r\ncontinue;\r\nerr = usb_submit_urb(urb, GFP_KERNEL);\r\nif (err) {\r\ndbg("%s: submit urb %d failed (%d) %d",\r\n__func__, i, err, urb->transfer_buffer_length);\r\n}\r\n}\r\nif (intfdata->send_setup)\r\nintfdata->send_setup(port);\r\nserial->interface->needs_remote_wakeup = 1;\r\nspin_lock_irq(&intfdata->susp_lock);\r\nportdata->opened = 1;\r\nspin_unlock_irq(&intfdata->susp_lock);\r\nusb_autopm_put_interface(serial->interface);\r\nreturn 0;\r\n}\r\nvoid usb_wwan_close(struct usb_serial_port *port)\r\n{\r\nint i;\r\nstruct usb_serial *serial = port->serial;\r\nstruct usb_wwan_port_private *portdata;\r\nstruct usb_wwan_intf_private *intfdata = port->serial->private;\r\ndbg("%s", __func__);\r\nportdata = usb_get_serial_port_data(port);\r\nif (serial->dev) {\r\nspin_lock_irq(&intfdata->susp_lock);\r\nportdata->opened = 0;\r\nspin_unlock_irq(&intfdata->susp_lock);\r\nfor (i = 0; i < N_IN_URB; i++)\r\nusb_kill_urb(portdata->in_urbs[i]);\r\nfor (i = 0; i < N_OUT_URB; i++)\r\nusb_kill_urb(portdata->out_urbs[i]);\r\nusb_autopm_get_interface_no_resume(serial->interface);\r\nserial->interface->needs_remote_wakeup = 0;\r\n}\r\n}\r\nstatic struct urb *usb_wwan_setup_urb(struct usb_serial *serial, int endpoint,\r\nint dir, void *ctx, char *buf, int len,\r\nvoid (*callback) (struct urb *))\r\n{\r\nstruct urb *urb;\r\nif (endpoint == -1)\r\nreturn NULL;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (urb == NULL) {\r\ndbg("%s: alloc for endpoint %d failed.", __func__, endpoint);\r\nreturn NULL;\r\n}\r\nusb_fill_bulk_urb(urb, serial->dev,\r\nusb_sndbulkpipe(serial->dev, endpoint) | dir,\r\nbuf, len, callback, ctx);\r\nreturn urb;\r\n}\r\nstatic void usb_wwan_setup_urbs(struct usb_serial *serial)\r\n{\r\nint i, j;\r\nstruct usb_serial_port *port;\r\nstruct usb_wwan_port_private *portdata;\r\ndbg("%s", __func__);\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\nportdata = usb_get_serial_port_data(port);\r\nfor (j = 0; j < N_IN_URB; ++j) {\r\nportdata->in_urbs[j] = usb_wwan_setup_urb(serial,\r\nport->\r\nbulk_in_endpointAddress,\r\nUSB_DIR_IN,\r\nport,\r\nportdata->\r\nin_buffer[j],\r\nIN_BUFLEN,\r\nusb_wwan_indat_callback);\r\n}\r\nfor (j = 0; j < N_OUT_URB; ++j) {\r\nportdata->out_urbs[j] = usb_wwan_setup_urb(serial,\r\nport->\r\nbulk_out_endpointAddress,\r\nUSB_DIR_OUT,\r\nport,\r\nportdata->\r\nout_buffer\r\n[j],\r\nOUT_BUFLEN,\r\nusb_wwan_outdat_callback);\r\n}\r\n}\r\n}\r\nint usb_wwan_startup(struct usb_serial *serial)\r\n{\r\nint i, j, err;\r\nstruct usb_serial_port *port;\r\nstruct usb_wwan_port_private *portdata;\r\nu8 *buffer;\r\ndbg("%s", __func__);\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\nportdata = kzalloc(sizeof(*portdata), GFP_KERNEL);\r\nif (!portdata) {\r\ndbg("%s: kmalloc for usb_wwan_port_private (%d) failed!.",\r\n__func__, i);\r\nreturn 1;\r\n}\r\ninit_usb_anchor(&portdata->delayed);\r\nfor (j = 0; j < N_IN_URB; j++) {\r\nbuffer = (u8 *) __get_free_page(GFP_KERNEL);\r\nif (!buffer)\r\ngoto bail_out_error;\r\nportdata->in_buffer[j] = buffer;\r\n}\r\nfor (j = 0; j < N_OUT_URB; j++) {\r\nbuffer = kmalloc(OUT_BUFLEN, GFP_KERNEL);\r\nif (!buffer)\r\ngoto bail_out_error2;\r\nportdata->out_buffer[j] = buffer;\r\n}\r\nusb_set_serial_port_data(port, portdata);\r\nif (!port->interrupt_in_urb)\r\ncontinue;\r\nerr = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\r\nif (err)\r\ndbg("%s: submit irq_in urb failed %d", __func__, err);\r\n}\r\nusb_wwan_setup_urbs(serial);\r\nreturn 0;\r\nbail_out_error2:\r\nfor (j = 0; j < N_OUT_URB; j++)\r\nkfree(portdata->out_buffer[j]);\r\nbail_out_error:\r\nfor (j = 0; j < N_IN_URB; j++)\r\nif (portdata->in_buffer[j])\r\nfree_page((unsigned long)portdata->in_buffer[j]);\r\nkfree(portdata);\r\nreturn 1;\r\n}\r\nstatic void stop_read_write_urbs(struct usb_serial *serial)\r\n{\r\nint i, j;\r\nstruct usb_serial_port *port;\r\nstruct usb_wwan_port_private *portdata;\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\nport = serial->port[i];\r\nportdata = usb_get_serial_port_data(port);\r\nfor (j = 0; j < N_IN_URB; j++)\r\nusb_kill_urb(portdata->in_urbs[j]);\r\nfor (j = 0; j < N_OUT_URB; j++)\r\nusb_kill_urb(portdata->out_urbs[j]);\r\n}\r\n}\r\nvoid usb_wwan_disconnect(struct usb_serial *serial)\r\n{\r\ndbg("%s", __func__);\r\nstop_read_write_urbs(serial);\r\n}\r\nvoid usb_wwan_release(struct usb_serial *serial)\r\n{\r\nint i, j;\r\nstruct usb_serial_port *port;\r\nstruct usb_wwan_port_private *portdata;\r\ndbg("%s", __func__);\r\nfor (i = 0; i < serial->num_ports; ++i) {\r\nport = serial->port[i];\r\nportdata = usb_get_serial_port_data(port);\r\nfor (j = 0; j < N_IN_URB; j++) {\r\nusb_free_urb(portdata->in_urbs[j]);\r\nfree_page((unsigned long)\r\nportdata->in_buffer[j]);\r\nportdata->in_urbs[j] = NULL;\r\n}\r\nfor (j = 0; j < N_OUT_URB; j++) {\r\nusb_free_urb(portdata->out_urbs[j]);\r\nkfree(portdata->out_buffer[j]);\r\nportdata->out_urbs[j] = NULL;\r\n}\r\n}\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\nkfree(usb_get_serial_port_data(port));\r\n}\r\n}\r\nint usb_wwan_suspend(struct usb_serial *serial, pm_message_t message)\r\n{\r\nstruct usb_wwan_intf_private *intfdata = serial->private;\r\nint b;\r\ndbg("%s entered", __func__);\r\nif (PMSG_IS_AUTO(message)) {\r\nspin_lock_irq(&intfdata->susp_lock);\r\nb = intfdata->in_flight;\r\nspin_unlock_irq(&intfdata->susp_lock);\r\nif (b)\r\nreturn -EBUSY;\r\n}\r\nspin_lock_irq(&intfdata->susp_lock);\r\nintfdata->suspended = 1;\r\nspin_unlock_irq(&intfdata->susp_lock);\r\nstop_read_write_urbs(serial);\r\nreturn 0;\r\n}\r\nstatic void unbusy_queued_urb(struct urb *urb, struct usb_wwan_port_private *portdata)\r\n{\r\nint i;\r\nfor (i = 0; i < N_OUT_URB; i++) {\r\nif (urb == portdata->out_urbs[i]) {\r\nclear_bit(i, &portdata->out_busy);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void play_delayed(struct usb_serial_port *port)\r\n{\r\nstruct usb_wwan_intf_private *data;\r\nstruct usb_wwan_port_private *portdata;\r\nstruct urb *urb;\r\nint err;\r\nportdata = usb_get_serial_port_data(port);\r\ndata = port->serial->private;\r\nwhile ((urb = usb_get_from_anchor(&portdata->delayed))) {\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (!err) {\r\ndata->in_flight++;\r\n} else {\r\ndo {\r\nunbusy_queued_urb(urb, portdata);\r\nusb_autopm_put_interface_no_suspend(port->serial->interface);\r\n} while ((urb = usb_get_from_anchor(&portdata->delayed)));\r\nbreak;\r\n}\r\n}\r\n}\r\nint usb_wwan_resume(struct usb_serial *serial)\r\n{\r\nint i, j;\r\nstruct usb_serial_port *port;\r\nstruct usb_wwan_intf_private *intfdata = serial->private;\r\nstruct usb_wwan_port_private *portdata;\r\nstruct urb *urb;\r\nint err = 0;\r\ndbg("%s entered", __func__);\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\nif (!port->interrupt_in_urb) {\r\ndbg("%s: No interrupt URB for port %d", __func__, i);\r\ncontinue;\r\n}\r\nerr = usb_submit_urb(port->interrupt_in_urb, GFP_NOIO);\r\ndbg("Submitted interrupt URB for port %d (result %d)", i, err);\r\nif (err < 0) {\r\nerr("%s: Error %d for interrupt URB of port%d",\r\n__func__, err, i);\r\ngoto err_out;\r\n}\r\n}\r\nfor (i = 0; i < serial->num_ports; i++) {\r\nport = serial->port[i];\r\nportdata = usb_get_serial_port_data(port);\r\nspin_lock_irq(&intfdata->susp_lock);\r\nif (!portdata->opened) {\r\nspin_unlock_irq(&intfdata->susp_lock);\r\ncontinue;\r\n}\r\nfor (j = 0; j < N_IN_URB; j++) {\r\nurb = portdata->in_urbs[j];\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err < 0) {\r\nerr("%s: Error %d for bulk URB %d",\r\n__func__, err, i);\r\nspin_unlock_irq(&intfdata->susp_lock);\r\ngoto err_out;\r\n}\r\n}\r\nplay_delayed(port);\r\nspin_unlock_irq(&intfdata->susp_lock);\r\n}\r\nspin_lock_irq(&intfdata->susp_lock);\r\nintfdata->suspended = 0;\r\nspin_unlock_irq(&intfdata->susp_lock);\r\nerr_out:\r\nreturn err;\r\n}
