int x25_parse_address_block(struct sk_buff *skb,\r\nstruct x25_address *called_addr,\r\nstruct x25_address *calling_addr)\r\n{\r\nunsigned char len;\r\nint needed;\r\nint rc;\r\nif (!pskb_may_pull(skb, 1)) {\r\nrc = 0;\r\ngoto empty;\r\n}\r\nlen = *skb->data;\r\nneeded = 1 + (len >> 4) + (len & 0x0f);\r\nif (!pskb_may_pull(skb, needed)) {\r\nrc = -1;\r\ngoto empty;\r\n}\r\nreturn x25_addr_ntoa(skb->data, called_addr, calling_addr);\r\nempty:\r\n*called_addr->x25_addr = 0;\r\n*calling_addr->x25_addr = 0;\r\nreturn rc;\r\n}\r\nint x25_addr_ntoa(unsigned char *p, struct x25_address *called_addr,\r\nstruct x25_address *calling_addr)\r\n{\r\nunsigned int called_len, calling_len;\r\nchar *called, *calling;\r\nunsigned int i;\r\ncalled_len = (*p >> 0) & 0x0F;\r\ncalling_len = (*p >> 4) & 0x0F;\r\ncalled = called_addr->x25_addr;\r\ncalling = calling_addr->x25_addr;\r\np++;\r\nfor (i = 0; i < (called_len + calling_len); i++) {\r\nif (i < called_len) {\r\nif (i % 2 != 0) {\r\n*called++ = ((*p >> 0) & 0x0F) + '0';\r\np++;\r\n} else {\r\n*called++ = ((*p >> 4) & 0x0F) + '0';\r\n}\r\n} else {\r\nif (i % 2 != 0) {\r\n*calling++ = ((*p >> 0) & 0x0F) + '0';\r\np++;\r\n} else {\r\n*calling++ = ((*p >> 4) & 0x0F) + '0';\r\n}\r\n}\r\n}\r\n*called = *calling = '\0';\r\nreturn 1 + (called_len + calling_len + 1) / 2;\r\n}\r\nint x25_addr_aton(unsigned char *p, struct x25_address *called_addr,\r\nstruct x25_address *calling_addr)\r\n{\r\nunsigned int called_len, calling_len;\r\nchar *called, *calling;\r\nint i;\r\ncalled = called_addr->x25_addr;\r\ncalling = calling_addr->x25_addr;\r\ncalled_len = strlen(called);\r\ncalling_len = strlen(calling);\r\n*p++ = (calling_len << 4) | (called_len << 0);\r\nfor (i = 0; i < (called_len + calling_len); i++) {\r\nif (i < called_len) {\r\nif (i % 2 != 0) {\r\n*p |= (*called++ - '0') << 0;\r\np++;\r\n} else {\r\n*p = 0x00;\r\n*p |= (*called++ - '0') << 4;\r\n}\r\n} else {\r\nif (i % 2 != 0) {\r\n*p |= (*calling++ - '0') << 0;\r\np++;\r\n} else {\r\n*p = 0x00;\r\n*p |= (*calling++ - '0') << 4;\r\n}\r\n}\r\n}\r\nreturn 1 + (called_len + calling_len + 1) / 2;\r\n}\r\nstatic void x25_remove_socket(struct sock *sk)\r\n{\r\nwrite_lock_bh(&x25_list_lock);\r\nsk_del_node_init(sk);\r\nwrite_unlock_bh(&x25_list_lock);\r\n}\r\nstatic void x25_kill_by_device(struct net_device *dev)\r\n{\r\nstruct sock *s;\r\nstruct hlist_node *node;\r\nwrite_lock_bh(&x25_list_lock);\r\nsk_for_each(s, node, &x25_list)\r\nif (x25_sk(s)->neighbour && x25_sk(s)->neighbour->dev == dev)\r\nx25_disconnect(s, ENETUNREACH, 0, 0);\r\nwrite_unlock_bh(&x25_list_lock);\r\n}\r\nstatic int x25_device_event(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = ptr;\r\nstruct x25_neigh *nb;\r\nif (!net_eq(dev_net(dev), &init_net))\r\nreturn NOTIFY_DONE;\r\nif (dev->type == ARPHRD_X25\r\n#if IS_ENABLED(CONFIG_LLC)\r\n|| dev->type == ARPHRD_ETHER\r\n#endif\r\n) {\r\nswitch (event) {\r\ncase NETDEV_UP:\r\nx25_link_device_up(dev);\r\nbreak;\r\ncase NETDEV_GOING_DOWN:\r\nnb = x25_get_neigh(dev);\r\nif (nb) {\r\nx25_terminate_link(nb);\r\nx25_neigh_put(nb);\r\n}\r\nbreak;\r\ncase NETDEV_DOWN:\r\nx25_kill_by_device(dev);\r\nx25_route_device_down(dev);\r\nx25_link_device_down(dev);\r\nbreak;\r\n}\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void x25_insert_socket(struct sock *sk)\r\n{\r\nwrite_lock_bh(&x25_list_lock);\r\nsk_add_node(sk, &x25_list);\r\nwrite_unlock_bh(&x25_list_lock);\r\n}\r\nstatic struct sock *x25_find_listener(struct x25_address *addr,\r\nstruct sk_buff *skb)\r\n{\r\nstruct sock *s;\r\nstruct sock *next_best;\r\nstruct hlist_node *node;\r\nread_lock_bh(&x25_list_lock);\r\nnext_best = NULL;\r\nsk_for_each(s, node, &x25_list)\r\nif ((!strcmp(addr->x25_addr,\r\nx25_sk(s)->source_addr.x25_addr) ||\r\n!strcmp(addr->x25_addr,\r\nnull_x25_address.x25_addr)) &&\r\ns->sk_state == TCP_LISTEN) {\r\nif (x25_sk(s)->cudmatchlength > 0 &&\r\nskb->len >= x25_sk(s)->cudmatchlength) {\r\nif((memcmp(x25_sk(s)->calluserdata.cuddata,\r\nskb->data,\r\nx25_sk(s)->cudmatchlength)) == 0) {\r\nsock_hold(s);\r\ngoto found;\r\n}\r\n} else\r\nnext_best = s;\r\n}\r\nif (next_best) {\r\ns = next_best;\r\nsock_hold(s);\r\ngoto found;\r\n}\r\ns = NULL;\r\nfound:\r\nread_unlock_bh(&x25_list_lock);\r\nreturn s;\r\n}\r\nstatic struct sock *__x25_find_socket(unsigned int lci, struct x25_neigh *nb)\r\n{\r\nstruct sock *s;\r\nstruct hlist_node *node;\r\nsk_for_each(s, node, &x25_list)\r\nif (x25_sk(s)->lci == lci && x25_sk(s)->neighbour == nb) {\r\nsock_hold(s);\r\ngoto found;\r\n}\r\ns = NULL;\r\nfound:\r\nreturn s;\r\n}\r\nstruct sock *x25_find_socket(unsigned int lci, struct x25_neigh *nb)\r\n{\r\nstruct sock *s;\r\nread_lock_bh(&x25_list_lock);\r\ns = __x25_find_socket(lci, nb);\r\nread_unlock_bh(&x25_list_lock);\r\nreturn s;\r\n}\r\nstatic unsigned int x25_new_lci(struct x25_neigh *nb)\r\n{\r\nunsigned int lci = 1;\r\nstruct sock *sk;\r\nread_lock_bh(&x25_list_lock);\r\nwhile ((sk = __x25_find_socket(lci, nb)) != NULL) {\r\nsock_put(sk);\r\nif (++lci == 4096) {\r\nlci = 0;\r\nbreak;\r\n}\r\n}\r\nread_unlock_bh(&x25_list_lock);\r\nreturn lci;\r\n}\r\nstatic void x25_destroy_timer(unsigned long data)\r\n{\r\nx25_destroy_socket_from_timer((struct sock *)data);\r\n}\r\nstatic void __x25_destroy_socket(struct sock *sk)\r\n{\r\nstruct sk_buff *skb;\r\nx25_stop_heartbeat(sk);\r\nx25_stop_timer(sk);\r\nx25_remove_socket(sk);\r\nx25_clear_queues(sk);\r\nwhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\r\nif (skb->sk != sk) {\r\nskb->sk->sk_state = TCP_LISTEN;\r\nsock_set_flag(skb->sk, SOCK_DEAD);\r\nx25_start_heartbeat(skb->sk);\r\nx25_sk(skb->sk)->state = X25_STATE_0;\r\n}\r\nkfree_skb(skb);\r\n}\r\nif (sk_has_allocations(sk)) {\r\nsk->sk_timer.expires = jiffies + 10 * HZ;\r\nsk->sk_timer.function = x25_destroy_timer;\r\nsk->sk_timer.data = (unsigned long)sk;\r\nadd_timer(&sk->sk_timer);\r\n} else {\r\n__sock_put(sk);\r\n}\r\n}\r\nvoid x25_destroy_socket_from_timer(struct sock *sk)\r\n{\r\nsock_hold(sk);\r\nbh_lock_sock(sk);\r\n__x25_destroy_socket(sk);\r\nbh_unlock_sock(sk);\r\nsock_put(sk);\r\n}\r\nstatic int x25_setsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nint opt;\r\nstruct sock *sk = sock->sk;\r\nint rc = -ENOPROTOOPT;\r\nif (level != SOL_X25 || optname != X25_QBITINCL)\r\ngoto out;\r\nrc = -EINVAL;\r\nif (optlen < sizeof(int))\r\ngoto out;\r\nrc = -EFAULT;\r\nif (get_user(opt, (int __user *)optval))\r\ngoto out;\r\nif (opt)\r\nset_bit(X25_Q_BIT_FLAG, &x25_sk(sk)->flags);\r\nelse\r\nclear_bit(X25_Q_BIT_FLAG, &x25_sk(sk)->flags);\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int x25_getsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint val, len, rc = -ENOPROTOOPT;\r\nif (level != SOL_X25 || optname != X25_QBITINCL)\r\ngoto out;\r\nrc = -EFAULT;\r\nif (get_user(len, optlen))\r\ngoto out;\r\nlen = min_t(unsigned int, len, sizeof(int));\r\nrc = -EINVAL;\r\nif (len < 0)\r\ngoto out;\r\nrc = -EFAULT;\r\nif (put_user(len, optlen))\r\ngoto out;\r\nval = test_bit(X25_Q_BIT_FLAG, &x25_sk(sk)->flags);\r\nrc = copy_to_user(optval, &val, len) ? -EFAULT : 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int x25_listen(struct socket *sock, int backlog)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint rc = -EOPNOTSUPP;\r\nlock_sock(sk);\r\nif (sk->sk_state != TCP_LISTEN) {\r\nmemset(&x25_sk(sk)->dest_addr, 0, X25_ADDR_LEN);\r\nsk->sk_max_ack_backlog = backlog;\r\nsk->sk_state = TCP_LISTEN;\r\nrc = 0;\r\n}\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic struct sock *x25_alloc_socket(struct net *net)\r\n{\r\nstruct x25_sock *x25;\r\nstruct sock *sk = sk_alloc(net, AF_X25, GFP_ATOMIC, &x25_proto);\r\nif (!sk)\r\ngoto out;\r\nsock_init_data(NULL, sk);\r\nx25 = x25_sk(sk);\r\nskb_queue_head_init(&x25->ack_queue);\r\nskb_queue_head_init(&x25->fragment_queue);\r\nskb_queue_head_init(&x25->interrupt_in_queue);\r\nskb_queue_head_init(&x25->interrupt_out_queue);\r\nout:\r\nreturn sk;\r\n}\r\nstatic int x25_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct sock *sk;\r\nstruct x25_sock *x25;\r\nint rc = -EAFNOSUPPORT;\r\nif (!net_eq(net, &init_net))\r\ngoto out;\r\nrc = -ESOCKTNOSUPPORT;\r\nif (sock->type != SOCK_SEQPACKET)\r\ngoto out;\r\nrc = -EINVAL;\r\nif (protocol)\r\ngoto out;\r\nrc = -ENOBUFS;\r\nif ((sk = x25_alloc_socket(net)) == NULL)\r\ngoto out;\r\nx25 = x25_sk(sk);\r\nsock_init_data(sock, sk);\r\nx25_init_timers(sk);\r\nsock->ops = &x25_proto_ops;\r\nsk->sk_protocol = protocol;\r\nsk->sk_backlog_rcv = x25_backlog_rcv;\r\nx25->t21 = sysctl_x25_call_request_timeout;\r\nx25->t22 = sysctl_x25_reset_request_timeout;\r\nx25->t23 = sysctl_x25_clear_request_timeout;\r\nx25->t2 = sysctl_x25_ack_holdback_timeout;\r\nx25->state = X25_STATE_0;\r\nx25->cudmatchlength = 0;\r\nset_bit(X25_ACCPT_APPRV_FLAG, &x25->flags);\r\nx25->facilities.winsize_in = X25_DEFAULT_WINDOW_SIZE;\r\nx25->facilities.winsize_out = X25_DEFAULT_WINDOW_SIZE;\r\nx25->facilities.pacsize_in = X25_DEFAULT_PACKET_SIZE;\r\nx25->facilities.pacsize_out = X25_DEFAULT_PACKET_SIZE;\r\nx25->facilities.throughput = 0;\r\nx25->facilities.reverse = X25_DEFAULT_REVERSE;\r\nx25->dte_facilities.calling_len = 0;\r\nx25->dte_facilities.called_len = 0;\r\nmemset(x25->dte_facilities.called_ae, '\0',\r\nsizeof(x25->dte_facilities.called_ae));\r\nmemset(x25->dte_facilities.calling_ae, '\0',\r\nsizeof(x25->dte_facilities.calling_ae));\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic struct sock *x25_make_new(struct sock *osk)\r\n{\r\nstruct sock *sk = NULL;\r\nstruct x25_sock *x25, *ox25;\r\nif (osk->sk_type != SOCK_SEQPACKET)\r\ngoto out;\r\nif ((sk = x25_alloc_socket(sock_net(osk))) == NULL)\r\ngoto out;\r\nx25 = x25_sk(sk);\r\nsk->sk_type = osk->sk_type;\r\nsk->sk_priority = osk->sk_priority;\r\nsk->sk_protocol = osk->sk_protocol;\r\nsk->sk_rcvbuf = osk->sk_rcvbuf;\r\nsk->sk_sndbuf = osk->sk_sndbuf;\r\nsk->sk_state = TCP_ESTABLISHED;\r\nsk->sk_backlog_rcv = osk->sk_backlog_rcv;\r\nsock_copy_flags(sk, osk);\r\nox25 = x25_sk(osk);\r\nx25->t21 = ox25->t21;\r\nx25->t22 = ox25->t22;\r\nx25->t23 = ox25->t23;\r\nx25->t2 = ox25->t2;\r\nx25->flags = ox25->flags;\r\nx25->facilities = ox25->facilities;\r\nx25->dte_facilities = ox25->dte_facilities;\r\nx25->cudmatchlength = ox25->cudmatchlength;\r\nclear_bit(X25_INTERRUPT_FLAG, &x25->flags);\r\nx25_init_timers(sk);\r\nout:\r\nreturn sk;\r\n}\r\nstatic int x25_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct x25_sock *x25;\r\nif (!sk)\r\nreturn 0;\r\nx25 = x25_sk(sk);\r\nsock_hold(sk);\r\nlock_sock(sk);\r\nswitch (x25->state) {\r\ncase X25_STATE_0:\r\ncase X25_STATE_2:\r\nx25_disconnect(sk, 0, 0, 0);\r\n__x25_destroy_socket(sk);\r\ngoto out;\r\ncase X25_STATE_1:\r\ncase X25_STATE_3:\r\ncase X25_STATE_4:\r\nx25_clear_queues(sk);\r\nx25_write_internal(sk, X25_CLEAR_REQUEST);\r\nx25_start_t23timer(sk);\r\nx25->state = X25_STATE_2;\r\nsk->sk_state = TCP_CLOSE;\r\nsk->sk_shutdown |= SEND_SHUTDOWN;\r\nsk->sk_state_change(sk);\r\nsock_set_flag(sk, SOCK_DEAD);\r\nsock_set_flag(sk, SOCK_DESTROY);\r\nbreak;\r\n}\r\nsock_orphan(sk);\r\nout:\r\nrelease_sock(sk);\r\nsock_put(sk);\r\nreturn 0;\r\n}\r\nstatic int x25_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\r\nint len, i, rc = 0;\r\nif (!sock_flag(sk, SOCK_ZAPPED) ||\r\naddr_len != sizeof(struct sockaddr_x25) ||\r\naddr->sx25_family != AF_X25) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nlen = strlen(addr->sx25_addr.x25_addr);\r\nfor (i = 0; i < len; i++) {\r\nif (!isdigit(addr->sx25_addr.x25_addr[i])) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nlock_sock(sk);\r\nx25_sk(sk)->source_addr = addr->sx25_addr;\r\nx25_insert_socket(sk);\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\nrelease_sock(sk);\r\nSOCK_DEBUG(sk, "x25_bind: socket is bound\n");\r\nout:\r\nreturn rc;\r\n}\r\nstatic int x25_wait_for_connection_establishment(struct sock *sk)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nint rc;\r\nadd_wait_queue_exclusive(sk_sleep(sk), &wait);\r\nfor (;;) {\r\n__set_current_state(TASK_INTERRUPTIBLE);\r\nrc = -ERESTARTSYS;\r\nif (signal_pending(current))\r\nbreak;\r\nrc = sock_error(sk);\r\nif (rc) {\r\nsk->sk_socket->state = SS_UNCONNECTED;\r\nbreak;\r\n}\r\nrc = 0;\r\nif (sk->sk_state != TCP_ESTABLISHED) {\r\nrelease_sock(sk);\r\nschedule();\r\nlock_sock(sk);\r\n} else\r\nbreak;\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nremove_wait_queue(sk_sleep(sk), &wait);\r\nreturn rc;\r\n}\r\nstatic int x25_connect(struct socket *sock, struct sockaddr *uaddr,\r\nint addr_len, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct x25_sock *x25 = x25_sk(sk);\r\nstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\r\nstruct x25_route *rt;\r\nint rc = 0;\r\nlock_sock(sk);\r\nif (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {\r\nsock->state = SS_CONNECTED;\r\ngoto out;\r\n}\r\nrc = -ECONNREFUSED;\r\nif (sk->sk_state == TCP_CLOSE && sock->state == SS_CONNECTING) {\r\nsock->state = SS_UNCONNECTED;\r\ngoto out;\r\n}\r\nrc = -EISCONN;\r\nif (sk->sk_state == TCP_ESTABLISHED)\r\ngoto out;\r\nsk->sk_state = TCP_CLOSE;\r\nsock->state = SS_UNCONNECTED;\r\nrc = -EINVAL;\r\nif (addr_len != sizeof(struct sockaddr_x25) ||\r\naddr->sx25_family != AF_X25)\r\ngoto out;\r\nrc = -ENETUNREACH;\r\nrt = x25_get_route(&addr->sx25_addr);\r\nif (!rt)\r\ngoto out;\r\nx25->neighbour = x25_get_neigh(rt->dev);\r\nif (!x25->neighbour)\r\ngoto out_put_route;\r\nx25_limit_facilities(&x25->facilities, x25->neighbour);\r\nx25->lci = x25_new_lci(x25->neighbour);\r\nif (!x25->lci)\r\ngoto out_put_neigh;\r\nrc = -EINVAL;\r\nif (sock_flag(sk, SOCK_ZAPPED))\r\ngoto out_put_neigh;\r\nif (!strcmp(x25->source_addr.x25_addr, null_x25_address.x25_addr))\r\nmemset(&x25->source_addr, '\0', X25_ADDR_LEN);\r\nx25->dest_addr = addr->sx25_addr;\r\nsock->state = SS_CONNECTING;\r\nsk->sk_state = TCP_SYN_SENT;\r\nx25->state = X25_STATE_1;\r\nx25_write_internal(sk, X25_CALL_REQUEST);\r\nx25_start_heartbeat(sk);\r\nx25_start_t21timer(sk);\r\nrc = -EINPROGRESS;\r\nif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK))\r\ngoto out_put_neigh;\r\nrc = x25_wait_for_connection_establishment(sk);\r\nif (rc)\r\ngoto out_put_neigh;\r\nsock->state = SS_CONNECTED;\r\nrc = 0;\r\nout_put_neigh:\r\nif (rc)\r\nx25_neigh_put(x25->neighbour);\r\nout_put_route:\r\nx25_route_put(rt);\r\nout:\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int x25_wait_for_data(struct sock *sk, long timeout)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nint rc = 0;\r\nadd_wait_queue_exclusive(sk_sleep(sk), &wait);\r\nfor (;;) {\r\n__set_current_state(TASK_INTERRUPTIBLE);\r\nif (sk->sk_shutdown & RCV_SHUTDOWN)\r\nbreak;\r\nrc = -ERESTARTSYS;\r\nif (signal_pending(current))\r\nbreak;\r\nrc = -EAGAIN;\r\nif (!timeout)\r\nbreak;\r\nrc = 0;\r\nif (skb_queue_empty(&sk->sk_receive_queue)) {\r\nrelease_sock(sk);\r\ntimeout = schedule_timeout(timeout);\r\nlock_sock(sk);\r\n} else\r\nbreak;\r\n}\r\n__set_current_state(TASK_RUNNING);\r\nremove_wait_queue(sk_sleep(sk), &wait);\r\nreturn rc;\r\n}\r\nstatic int x25_accept(struct socket *sock, struct socket *newsock, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sock *newsk;\r\nstruct sk_buff *skb;\r\nint rc = -EINVAL;\r\nif (!sk)\r\ngoto out;\r\nrc = -EOPNOTSUPP;\r\nif (sk->sk_type != SOCK_SEQPACKET)\r\ngoto out;\r\nlock_sock(sk);\r\nrc = -EINVAL;\r\nif (sk->sk_state != TCP_LISTEN)\r\ngoto out2;\r\nrc = x25_wait_for_data(sk, sk->sk_rcvtimeo);\r\nif (rc)\r\ngoto out2;\r\nskb = skb_dequeue(&sk->sk_receive_queue);\r\nrc = -EINVAL;\r\nif (!skb->sk)\r\ngoto out2;\r\nnewsk = skb->sk;\r\nsock_graft(newsk, newsock);\r\nskb->sk = NULL;\r\nkfree_skb(skb);\r\nsk->sk_ack_backlog--;\r\nnewsock->state = SS_CONNECTED;\r\nrc = 0;\r\nout2:\r\nrelease_sock(sk);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int x25_getname(struct socket *sock, struct sockaddr *uaddr,\r\nint *uaddr_len, int peer)\r\n{\r\nstruct sockaddr_x25 *sx25 = (struct sockaddr_x25 *)uaddr;\r\nstruct sock *sk = sock->sk;\r\nstruct x25_sock *x25 = x25_sk(sk);\r\nint rc = 0;\r\nif (peer) {\r\nif (sk->sk_state != TCP_ESTABLISHED) {\r\nrc = -ENOTCONN;\r\ngoto out;\r\n}\r\nsx25->sx25_addr = x25->dest_addr;\r\n} else\r\nsx25->sx25_addr = x25->source_addr;\r\nsx25->sx25_family = AF_X25;\r\n*uaddr_len = sizeof(*sx25);\r\nout:\r\nreturn rc;\r\n}\r\nint x25_rx_call_request(struct sk_buff *skb, struct x25_neigh *nb,\r\nunsigned int lci)\r\n{\r\nstruct sock *sk;\r\nstruct sock *make;\r\nstruct x25_sock *makex25;\r\nstruct x25_address source_addr, dest_addr;\r\nstruct x25_facilities facilities;\r\nstruct x25_dte_facilities dte_facilities;\r\nint len, addr_len, rc;\r\nskb_pull(skb, X25_STD_MIN_LEN);\r\naddr_len = x25_parse_address_block(skb, &source_addr, &dest_addr);\r\nif (addr_len <= 0)\r\ngoto out_clear_request;\r\nskb_pull(skb, addr_len);\r\nif (!pskb_may_pull(skb, 1))\r\ngoto out_clear_request;\r\nlen = skb->data[0] + 1;\r\nif (!pskb_may_pull(skb, len))\r\ngoto out_clear_request;\r\nskb_pull(skb,len);\r\nif (skb->len > X25_MAX_CUD_LEN)\r\ngoto out_clear_request;\r\nif (!pskb_may_pull(skb, skb->len))\r\ngoto out_clear_request;\r\nsk = x25_find_listener(&source_addr,skb);\r\nskb_push(skb,len);\r\nif (sk != NULL && sk_acceptq_is_full(sk)) {\r\ngoto out_sock_put;\r\n}\r\nif (sk == NULL) {\r\nskb_push(skb, addr_len + X25_STD_MIN_LEN);\r\nif (sysctl_x25_forward &&\r\nx25_forward_call(&dest_addr, nb, skb, lci) > 0)\r\n{\r\nkfree_skb(skb);\r\nrc = 1;\r\ngoto out;\r\n} else {\r\ngoto out_clear_request;\r\n}\r\n}\r\nlen = x25_negotiate_facilities(skb, sk, &facilities, &dte_facilities);\r\nif (len == -1)\r\ngoto out_sock_put;\r\nx25_limit_facilities(&facilities, nb);\r\nmake = x25_make_new(sk);\r\nif (!make)\r\ngoto out_sock_put;\r\nskb_pull(skb, len);\r\nskb->sk = make;\r\nmake->sk_state = TCP_ESTABLISHED;\r\nmakex25 = x25_sk(make);\r\nmakex25->lci = lci;\r\nmakex25->dest_addr = dest_addr;\r\nmakex25->source_addr = source_addr;\r\nmakex25->neighbour = nb;\r\nmakex25->facilities = facilities;\r\nmakex25->dte_facilities= dte_facilities;\r\nmakex25->vc_facil_mask = x25_sk(sk)->vc_facil_mask;\r\nmakex25->vc_facil_mask &= ~X25_MASK_REVERSE;\r\nmakex25->vc_facil_mask &= ~X25_MASK_CALLING_AE;\r\nmakex25->cudmatchlength = x25_sk(sk)->cudmatchlength;\r\nif (test_bit(X25_ACCPT_APPRV_FLAG, &makex25->flags)) {\r\nx25_write_internal(make, X25_CALL_ACCEPTED);\r\nmakex25->state = X25_STATE_3;\r\n}\r\nskb_copy_from_linear_data(skb, makex25->calluserdata.cuddata, skb->len);\r\nmakex25->calluserdata.cudlength = skb->len;\r\nsk->sk_ack_backlog++;\r\nx25_insert_socket(make);\r\nskb_queue_head(&sk->sk_receive_queue, skb);\r\nx25_start_heartbeat(make);\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_data_ready(sk, skb->len);\r\nrc = 1;\r\nsock_put(sk);\r\nout:\r\nreturn rc;\r\nout_sock_put:\r\nsock_put(sk);\r\nout_clear_request:\r\nrc = 0;\r\nx25_transmit_clear_request(nb, lci, 0x01);\r\ngoto out;\r\n}\r\nstatic int x25_sendmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct x25_sock *x25 = x25_sk(sk);\r\nstruct sockaddr_x25 *usx25 = (struct sockaddr_x25 *)msg->msg_name;\r\nstruct sockaddr_x25 sx25;\r\nstruct sk_buff *skb;\r\nunsigned char *asmptr;\r\nint noblock = msg->msg_flags & MSG_DONTWAIT;\r\nsize_t size;\r\nint qbit = 0, rc = -EINVAL;\r\nlock_sock(sk);\r\nif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_OOB|MSG_EOR|MSG_CMSG_COMPAT))\r\ngoto out;\r\nif (!(msg->msg_flags & (MSG_EOR|MSG_OOB)))\r\ngoto out;\r\nrc = -EADDRNOTAVAIL;\r\nif (sock_flag(sk, SOCK_ZAPPED))\r\ngoto out;\r\nrc = -EPIPE;\r\nif (sk->sk_shutdown & SEND_SHUTDOWN) {\r\nsend_sig(SIGPIPE, current, 0);\r\ngoto out;\r\n}\r\nrc = -ENETUNREACH;\r\nif (!x25->neighbour)\r\ngoto out;\r\nif (usx25) {\r\nrc = -EINVAL;\r\nif (msg->msg_namelen < sizeof(sx25))\r\ngoto out;\r\nmemcpy(&sx25, usx25, sizeof(sx25));\r\nrc = -EISCONN;\r\nif (strcmp(x25->dest_addr.x25_addr, sx25.sx25_addr.x25_addr))\r\ngoto out;\r\nrc = -EINVAL;\r\nif (sx25.sx25_family != AF_X25)\r\ngoto out;\r\n} else {\r\nrc = -ENOTCONN;\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\ngoto out;\r\nsx25.sx25_family = AF_X25;\r\nsx25.sx25_addr = x25->dest_addr;\r\n}\r\nif (len > 65535) {\r\nrc = -EMSGSIZE;\r\ngoto out;\r\n}\r\nSOCK_DEBUG(sk, "x25_sendmsg: sendto: Addresses built.\n");\r\nSOCK_DEBUG(sk, "x25_sendmsg: sendto: building packet.\n");\r\nif ((msg->msg_flags & MSG_OOB) && len > 32)\r\nlen = 32;\r\nsize = len + X25_MAX_L2_LEN + X25_EXT_MIN_LEN;\r\nrelease_sock(sk);\r\nskb = sock_alloc_send_skb(sk, size, noblock, &rc);\r\nlock_sock(sk);\r\nif (!skb)\r\ngoto out;\r\nX25_SKB_CB(skb)->flags = msg->msg_flags;\r\nskb_reserve(skb, X25_MAX_L2_LEN + X25_EXT_MIN_LEN);\r\nSOCK_DEBUG(sk, "x25_sendmsg: Copying user data\n");\r\nskb_reset_transport_header(skb);\r\nskb_put(skb, len);\r\nrc = memcpy_fromiovec(skb_transport_header(skb), msg->msg_iov, len);\r\nif (rc)\r\ngoto out_kfree_skb;\r\nif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\r\nif (!pskb_may_pull(skb, 1))\r\ngoto out_kfree_skb;\r\nqbit = skb->data[0];\r\nskb_pull(skb, 1);\r\n}\r\nSOCK_DEBUG(sk, "x25_sendmsg: Building X.25 Header.\n");\r\nif (msg->msg_flags & MSG_OOB) {\r\nif (x25->neighbour->extended) {\r\nasmptr = skb_push(skb, X25_STD_MIN_LEN);\r\n*asmptr++ = ((x25->lci >> 8) & 0x0F) | X25_GFI_EXTSEQ;\r\n*asmptr++ = (x25->lci >> 0) & 0xFF;\r\n*asmptr++ = X25_INTERRUPT;\r\n} else {\r\nasmptr = skb_push(skb, X25_STD_MIN_LEN);\r\n*asmptr++ = ((x25->lci >> 8) & 0x0F) | X25_GFI_STDSEQ;\r\n*asmptr++ = (x25->lci >> 0) & 0xFF;\r\n*asmptr++ = X25_INTERRUPT;\r\n}\r\n} else {\r\nif (x25->neighbour->extended) {\r\nasmptr = skb_push(skb, X25_EXT_MIN_LEN);\r\n*asmptr++ = ((x25->lci >> 8) & 0x0F) | X25_GFI_EXTSEQ;\r\n*asmptr++ = (x25->lci >> 0) & 0xFF;\r\n*asmptr++ = X25_DATA;\r\n*asmptr++ = X25_DATA;\r\n} else {\r\nasmptr = skb_push(skb, X25_STD_MIN_LEN);\r\n*asmptr++ = ((x25->lci >> 8) & 0x0F) | X25_GFI_STDSEQ;\r\n*asmptr++ = (x25->lci >> 0) & 0xFF;\r\n*asmptr++ = X25_DATA;\r\n}\r\nif (qbit)\r\nskb->data[0] |= X25_Q_BIT;\r\n}\r\nSOCK_DEBUG(sk, "x25_sendmsg: Built header.\n");\r\nSOCK_DEBUG(sk, "x25_sendmsg: Transmitting buffer\n");\r\nrc = -ENOTCONN;\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\ngoto out_kfree_skb;\r\nif (msg->msg_flags & MSG_OOB)\r\nskb_queue_tail(&x25->interrupt_out_queue, skb);\r\nelse {\r\nrc = x25_output(sk, skb);\r\nlen = rc;\r\nif (rc < 0)\r\nkfree_skb(skb);\r\nelse if (test_bit(X25_Q_BIT_FLAG, &x25->flags))\r\nlen++;\r\n}\r\nx25_kick(sk);\r\nrc = len;\r\nout:\r\nrelease_sock(sk);\r\nreturn rc;\r\nout_kfree_skb:\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nstatic int x25_recvmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t size,\r\nint flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct x25_sock *x25 = x25_sk(sk);\r\nstruct sockaddr_x25 *sx25 = (struct sockaddr_x25 *)msg->msg_name;\r\nsize_t copied;\r\nint qbit, header_len;\r\nstruct sk_buff *skb;\r\nunsigned char *asmptr;\r\nint rc = -ENOTCONN;\r\nlock_sock(sk);\r\nif (x25->neighbour == NULL)\r\ngoto out;\r\nheader_len = x25->neighbour->extended ?\r\nX25_EXT_MIN_LEN : X25_STD_MIN_LEN;\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\ngoto out;\r\nif (flags & MSG_OOB) {\r\nrc = -EINVAL;\r\nif (sock_flag(sk, SOCK_URGINLINE) ||\r\n!skb_peek(&x25->interrupt_in_queue))\r\ngoto out;\r\nskb = skb_dequeue(&x25->interrupt_in_queue);\r\nif (!pskb_may_pull(skb, X25_STD_MIN_LEN))\r\ngoto out_free_dgram;\r\nskb_pull(skb, X25_STD_MIN_LEN);\r\nif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\r\nasmptr = skb_push(skb, 1);\r\n*asmptr = 0x00;\r\n}\r\nmsg->msg_flags |= MSG_OOB;\r\n} else {\r\nrelease_sock(sk);\r\nskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\r\nflags & MSG_DONTWAIT, &rc);\r\nlock_sock(sk);\r\nif (!skb)\r\ngoto out;\r\nif (!pskb_may_pull(skb, header_len))\r\ngoto out_free_dgram;\r\nqbit = (skb->data[0] & X25_Q_BIT) == X25_Q_BIT;\r\nskb_pull(skb, header_len);\r\nif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\r\nasmptr = skb_push(skb, 1);\r\n*asmptr = qbit;\r\n}\r\n}\r\nskb_reset_transport_header(skb);\r\ncopied = skb->len;\r\nif (copied > size) {\r\ncopied = size;\r\nmsg->msg_flags |= MSG_TRUNC;\r\n}\r\nmsg->msg_flags |= MSG_EOR;\r\nrc = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\r\nif (rc)\r\ngoto out_free_dgram;\r\nif (sx25) {\r\nsx25->sx25_family = AF_X25;\r\nsx25->sx25_addr = x25->dest_addr;\r\n}\r\nmsg->msg_namelen = sizeof(struct sockaddr_x25);\r\nx25_check_rbuf(sk);\r\nrc = copied;\r\nout_free_dgram:\r\nskb_free_datagram(sk, skb);\r\nout:\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int x25_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct x25_sock *x25 = x25_sk(sk);\r\nvoid __user *argp = (void __user *)arg;\r\nint rc;\r\nswitch (cmd) {\r\ncase TIOCOUTQ: {\r\nint amount;\r\namount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\r\nif (amount < 0)\r\namount = 0;\r\nrc = put_user(amount, (unsigned int __user *)argp);\r\nbreak;\r\n}\r\ncase TIOCINQ: {\r\nstruct sk_buff *skb;\r\nint amount = 0;\r\nlock_sock(sk);\r\nif ((skb = skb_peek(&sk->sk_receive_queue)) != NULL)\r\namount = skb->len;\r\nrelease_sock(sk);\r\nrc = put_user(amount, (unsigned int __user *)argp);\r\nbreak;\r\n}\r\ncase SIOCGSTAMP:\r\nrc = -EINVAL;\r\nif (sk)\r\nrc = sock_get_timestamp(sk,\r\n(struct timeval __user *)argp);\r\nbreak;\r\ncase SIOCGSTAMPNS:\r\nrc = -EINVAL;\r\nif (sk)\r\nrc = sock_get_timestampns(sk,\r\n(struct timespec __user *)argp);\r\nbreak;\r\ncase SIOCGIFADDR:\r\ncase SIOCSIFADDR:\r\ncase SIOCGIFDSTADDR:\r\ncase SIOCSIFDSTADDR:\r\ncase SIOCGIFBRDADDR:\r\ncase SIOCSIFBRDADDR:\r\ncase SIOCGIFNETMASK:\r\ncase SIOCSIFNETMASK:\r\ncase SIOCGIFMETRIC:\r\ncase SIOCSIFMETRIC:\r\nrc = -EINVAL;\r\nbreak;\r\ncase SIOCADDRT:\r\ncase SIOCDELRT:\r\nrc = -EPERM;\r\nif (!capable(CAP_NET_ADMIN))\r\nbreak;\r\nrc = x25_route_ioctl(cmd, argp);\r\nbreak;\r\ncase SIOCX25GSUBSCRIP:\r\nrc = x25_subscr_ioctl(cmd, argp);\r\nbreak;\r\ncase SIOCX25SSUBSCRIP:\r\nrc = -EPERM;\r\nif (!capable(CAP_NET_ADMIN))\r\nbreak;\r\nrc = x25_subscr_ioctl(cmd, argp);\r\nbreak;\r\ncase SIOCX25GFACILITIES: {\r\nlock_sock(sk);\r\nrc = copy_to_user(argp, &x25->facilities,\r\nsizeof(x25->facilities))\r\n? -EFAULT : 0;\r\nrelease_sock(sk);\r\nbreak;\r\n}\r\ncase SIOCX25SFACILITIES: {\r\nstruct x25_facilities facilities;\r\nrc = -EFAULT;\r\nif (copy_from_user(&facilities, argp, sizeof(facilities)))\r\nbreak;\r\nrc = -EINVAL;\r\nlock_sock(sk);\r\nif (sk->sk_state != TCP_LISTEN &&\r\nsk->sk_state != TCP_CLOSE)\r\ngoto out_fac_release;\r\nif (facilities.pacsize_in < X25_PS16 ||\r\nfacilities.pacsize_in > X25_PS4096)\r\ngoto out_fac_release;\r\nif (facilities.pacsize_out < X25_PS16 ||\r\nfacilities.pacsize_out > X25_PS4096)\r\ngoto out_fac_release;\r\nif (facilities.winsize_in < 1 ||\r\nfacilities.winsize_in > 127)\r\ngoto out_fac_release;\r\nif (facilities.throughput) {\r\nint out = facilities.throughput & 0xf0;\r\nint in = facilities.throughput & 0x0f;\r\nif (!out)\r\nfacilities.throughput |=\r\nX25_DEFAULT_THROUGHPUT << 4;\r\nelse if (out < 0x30 || out > 0xD0)\r\ngoto out_fac_release;\r\nif (!in)\r\nfacilities.throughput |=\r\nX25_DEFAULT_THROUGHPUT;\r\nelse if (in < 0x03 || in > 0x0D)\r\ngoto out_fac_release;\r\n}\r\nif (facilities.reverse &&\r\n(facilities.reverse & 0x81) != 0x81)\r\ngoto out_fac_release;\r\nx25->facilities = facilities;\r\nrc = 0;\r\nout_fac_release:\r\nrelease_sock(sk);\r\nbreak;\r\n}\r\ncase SIOCX25GDTEFACILITIES: {\r\nlock_sock(sk);\r\nrc = copy_to_user(argp, &x25->dte_facilities,\r\nsizeof(x25->dte_facilities));\r\nrelease_sock(sk);\r\nif (rc)\r\nrc = -EFAULT;\r\nbreak;\r\n}\r\ncase SIOCX25SDTEFACILITIES: {\r\nstruct x25_dte_facilities dtefacs;\r\nrc = -EFAULT;\r\nif (copy_from_user(&dtefacs, argp, sizeof(dtefacs)))\r\nbreak;\r\nrc = -EINVAL;\r\nlock_sock(sk);\r\nif (sk->sk_state != TCP_LISTEN &&\r\nsk->sk_state != TCP_CLOSE)\r\ngoto out_dtefac_release;\r\nif (dtefacs.calling_len > X25_MAX_AE_LEN)\r\ngoto out_dtefac_release;\r\nif (dtefacs.calling_ae == NULL)\r\ngoto out_dtefac_release;\r\nif (dtefacs.called_len > X25_MAX_AE_LEN)\r\ngoto out_dtefac_release;\r\nif (dtefacs.called_ae == NULL)\r\ngoto out_dtefac_release;\r\nx25->dte_facilities = dtefacs;\r\nrc = 0;\r\nout_dtefac_release:\r\nrelease_sock(sk);\r\nbreak;\r\n}\r\ncase SIOCX25GCALLUSERDATA: {\r\nlock_sock(sk);\r\nrc = copy_to_user(argp, &x25->calluserdata,\r\nsizeof(x25->calluserdata))\r\n? -EFAULT : 0;\r\nrelease_sock(sk);\r\nbreak;\r\n}\r\ncase SIOCX25SCALLUSERDATA: {\r\nstruct x25_calluserdata calluserdata;\r\nrc = -EFAULT;\r\nif (copy_from_user(&calluserdata, argp, sizeof(calluserdata)))\r\nbreak;\r\nrc = -EINVAL;\r\nif (calluserdata.cudlength > X25_MAX_CUD_LEN)\r\nbreak;\r\nlock_sock(sk);\r\nx25->calluserdata = calluserdata;\r\nrelease_sock(sk);\r\nrc = 0;\r\nbreak;\r\n}\r\ncase SIOCX25GCAUSEDIAG: {\r\nlock_sock(sk);\r\nrc = copy_to_user(argp, &x25->causediag, sizeof(x25->causediag))\r\n? -EFAULT : 0;\r\nrelease_sock(sk);\r\nbreak;\r\n}\r\ncase SIOCX25SCAUSEDIAG: {\r\nstruct x25_causediag causediag;\r\nrc = -EFAULT;\r\nif (copy_from_user(&causediag, argp, sizeof(causediag)))\r\nbreak;\r\nlock_sock(sk);\r\nx25->causediag = causediag;\r\nrelease_sock(sk);\r\nrc = 0;\r\nbreak;\r\n}\r\ncase SIOCX25SCUDMATCHLEN: {\r\nstruct x25_subaddr sub_addr;\r\nrc = -EINVAL;\r\nlock_sock(sk);\r\nif(sk->sk_state != TCP_CLOSE)\r\ngoto out_cud_release;\r\nrc = -EFAULT;\r\nif (copy_from_user(&sub_addr, argp,\r\nsizeof(sub_addr)))\r\ngoto out_cud_release;\r\nrc = -EINVAL;\r\nif (sub_addr.cudmatchlength > X25_MAX_CUD_LEN)\r\ngoto out_cud_release;\r\nx25->cudmatchlength = sub_addr.cudmatchlength;\r\nrc = 0;\r\nout_cud_release:\r\nrelease_sock(sk);\r\nbreak;\r\n}\r\ncase SIOCX25CALLACCPTAPPRV: {\r\nrc = -EINVAL;\r\nlock_sock(sk);\r\nif (sk->sk_state != TCP_CLOSE)\r\nbreak;\r\nclear_bit(X25_ACCPT_APPRV_FLAG, &x25->flags);\r\nrelease_sock(sk);\r\nrc = 0;\r\nbreak;\r\n}\r\ncase SIOCX25SENDCALLACCPT: {\r\nrc = -EINVAL;\r\nlock_sock(sk);\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\nbreak;\r\nif (test_bit(X25_ACCPT_APPRV_FLAG, &x25->flags))\r\nbreak;\r\nx25_write_internal(sk, X25_CALL_ACCEPTED);\r\nx25->state = X25_STATE_3;\r\nrelease_sock(sk);\r\nrc = 0;\r\nbreak;\r\n}\r\ndefault:\r\nrc = -ENOIOCTLCMD;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int compat_x25_subscr_ioctl(unsigned int cmd,\r\nstruct compat_x25_subscrip_struct __user *x25_subscr32)\r\n{\r\nstruct compat_x25_subscrip_struct x25_subscr;\r\nstruct x25_neigh *nb;\r\nstruct net_device *dev;\r\nint rc = -EINVAL;\r\nrc = -EFAULT;\r\nif (copy_from_user(&x25_subscr, x25_subscr32, sizeof(*x25_subscr32)))\r\ngoto out;\r\nrc = -EINVAL;\r\ndev = x25_dev_get(x25_subscr.device);\r\nif (dev == NULL)\r\ngoto out;\r\nnb = x25_get_neigh(dev);\r\nif (nb == NULL)\r\ngoto out_dev_put;\r\ndev_put(dev);\r\nif (cmd == SIOCX25GSUBSCRIP) {\r\nread_lock_bh(&x25_neigh_list_lock);\r\nx25_subscr.extended = nb->extended;\r\nx25_subscr.global_facil_mask = nb->global_facil_mask;\r\nread_unlock_bh(&x25_neigh_list_lock);\r\nrc = copy_to_user(x25_subscr32, &x25_subscr,\r\nsizeof(*x25_subscr32)) ? -EFAULT : 0;\r\n} else {\r\nrc = -EINVAL;\r\nif (x25_subscr.extended == 0 || x25_subscr.extended == 1) {\r\nrc = 0;\r\nwrite_lock_bh(&x25_neigh_list_lock);\r\nnb->extended = x25_subscr.extended;\r\nnb->global_facil_mask = x25_subscr.global_facil_mask;\r\nwrite_unlock_bh(&x25_neigh_list_lock);\r\n}\r\n}\r\nx25_neigh_put(nb);\r\nout:\r\nreturn rc;\r\nout_dev_put:\r\ndev_put(dev);\r\ngoto out;\r\n}\r\nstatic int compat_x25_ioctl(struct socket *sock, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvoid __user *argp = compat_ptr(arg);\r\nstruct sock *sk = sock->sk;\r\nint rc = -ENOIOCTLCMD;\r\nswitch(cmd) {\r\ncase TIOCOUTQ:\r\ncase TIOCINQ:\r\nrc = x25_ioctl(sock, cmd, (unsigned long)argp);\r\nbreak;\r\ncase SIOCGSTAMP:\r\nrc = -EINVAL;\r\nif (sk)\r\nrc = compat_sock_get_timestamp(sk,\r\n(struct timeval __user*)argp);\r\nbreak;\r\ncase SIOCGSTAMPNS:\r\nrc = -EINVAL;\r\nif (sk)\r\nrc = compat_sock_get_timestampns(sk,\r\n(struct timespec __user*)argp);\r\nbreak;\r\ncase SIOCGIFADDR:\r\ncase SIOCSIFADDR:\r\ncase SIOCGIFDSTADDR:\r\ncase SIOCSIFDSTADDR:\r\ncase SIOCGIFBRDADDR:\r\ncase SIOCSIFBRDADDR:\r\ncase SIOCGIFNETMASK:\r\ncase SIOCSIFNETMASK:\r\ncase SIOCGIFMETRIC:\r\ncase SIOCSIFMETRIC:\r\nrc = -EINVAL;\r\nbreak;\r\ncase SIOCADDRT:\r\ncase SIOCDELRT:\r\nrc = -EPERM;\r\nif (!capable(CAP_NET_ADMIN))\r\nbreak;\r\nrc = x25_route_ioctl(cmd, argp);\r\nbreak;\r\ncase SIOCX25GSUBSCRIP:\r\nrc = compat_x25_subscr_ioctl(cmd, argp);\r\nbreak;\r\ncase SIOCX25SSUBSCRIP:\r\nrc = -EPERM;\r\nif (!capable(CAP_NET_ADMIN))\r\nbreak;\r\nrc = compat_x25_subscr_ioctl(cmd, argp);\r\nbreak;\r\ncase SIOCX25GFACILITIES:\r\ncase SIOCX25SFACILITIES:\r\ncase SIOCX25GDTEFACILITIES:\r\ncase SIOCX25SDTEFACILITIES:\r\ncase SIOCX25GCALLUSERDATA:\r\ncase SIOCX25SCALLUSERDATA:\r\ncase SIOCX25GCAUSEDIAG:\r\ncase SIOCX25SCAUSEDIAG:\r\ncase SIOCX25SCUDMATCHLEN:\r\ncase SIOCX25CALLACCPTAPPRV:\r\ncase SIOCX25SENDCALLACCPT:\r\nrc = x25_ioctl(sock, cmd, (unsigned long)argp);\r\nbreak;\r\ndefault:\r\nrc = -ENOIOCTLCMD;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nvoid x25_kill_by_neigh(struct x25_neigh *nb)\r\n{\r\nstruct sock *s;\r\nstruct hlist_node *node;\r\nwrite_lock_bh(&x25_list_lock);\r\nsk_for_each(s, node, &x25_list)\r\nif (x25_sk(s)->neighbour == nb)\r\nx25_disconnect(s, ENETUNREACH, 0, 0);\r\nwrite_unlock_bh(&x25_list_lock);\r\nx25_clear_forward_by_dev(nb->dev);\r\n}\r\nstatic int __init x25_init(void)\r\n{\r\nint rc = proto_register(&x25_proto, 0);\r\nif (rc != 0)\r\ngoto out;\r\nrc = sock_register(&x25_family_ops);\r\nif (rc != 0)\r\ngoto out_proto;\r\ndev_add_pack(&x25_packet_type);\r\nrc = register_netdevice_notifier(&x25_dev_notifier);\r\nif (rc != 0)\r\ngoto out_sock;\r\nprintk(KERN_INFO "X.25 for Linux Version 0.2\n");\r\nx25_register_sysctl();\r\nrc = x25_proc_init();\r\nif (rc != 0)\r\ngoto out_dev;\r\nout:\r\nreturn rc;\r\nout_dev:\r\nunregister_netdevice_notifier(&x25_dev_notifier);\r\nout_sock:\r\nsock_unregister(AF_X25);\r\nout_proto:\r\nproto_unregister(&x25_proto);\r\ngoto out;\r\n}\r\nstatic void __exit x25_exit(void)\r\n{\r\nx25_proc_exit();\r\nx25_link_free();\r\nx25_route_free();\r\nx25_unregister_sysctl();\r\nunregister_netdevice_notifier(&x25_dev_notifier);\r\ndev_remove_pack(&x25_packet_type);\r\nsock_unregister(AF_X25);\r\nproto_unregister(&x25_proto);\r\n}
