static int dbgp_consume(char *buf, unsigned len)\r\n{\r\nchar c;\r\nif (!len)\r\nreturn 0;\r\nc = buf[len-1];\r\nif (c != 0)\r\nbuf[len-1] = 0;\r\nprintk(KERN_NOTICE "%s%c", buf, c);\r\nreturn 0;\r\n}\r\nstatic void __disable_ep(struct usb_ep *ep)\r\n{\r\nif (ep && ep->driver_data == dbgp.gadget) {\r\nusb_ep_disable(ep);\r\nep->driver_data = NULL;\r\n}\r\n}\r\nstatic void dbgp_disable_ep(void)\r\n{\r\n__disable_ep(dbgp.i_ep);\r\n__disable_ep(dbgp.o_ep);\r\n}\r\nstatic void dbgp_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nint stp;\r\nint err = 0;\r\nint status = req->status;\r\nif (ep == dbgp.i_ep) {\r\nstp = 1;\r\ngoto fail;\r\n}\r\nif (status != 0) {\r\nstp = 2;\r\ngoto release_req;\r\n}\r\ndbgp_consume(req->buf, req->actual);\r\nreq->length = DBGP_REQ_LEN;\r\nerr = usb_ep_queue(ep, req, GFP_ATOMIC);\r\nif (err < 0) {\r\nstp = 3;\r\ngoto release_req;\r\n}\r\nreturn;\r\nrelease_req:\r\nkfree(req->buf);\r\nusb_ep_free_request(dbgp.o_ep, req);\r\ndbgp_disable_ep();\r\nfail:\r\ndev_dbg(&dbgp.gadget->dev,\r\n"complete: failure (%d:%d) ==> %d\n", stp, err, status);\r\n}\r\nstatic int dbgp_enable_ep_req(struct usb_ep *ep)\r\n{\r\nint err, stp;\r\nstruct usb_request *req;\r\nreq = usb_ep_alloc_request(ep, GFP_KERNEL);\r\nif (!req) {\r\nerr = -ENOMEM;\r\nstp = 1;\r\ngoto fail_1;\r\n}\r\nreq->buf = kmalloc(DBGP_REQ_LEN, GFP_KERNEL);\r\nif (!req->buf) {\r\nerr = -ENOMEM;\r\nstp = 2;\r\ngoto fail_2;\r\n}\r\nreq->complete = dbgp_complete;\r\nreq->length = DBGP_REQ_LEN;\r\nerr = usb_ep_queue(ep, req, GFP_ATOMIC);\r\nif (err < 0) {\r\nstp = 3;\r\ngoto fail_3;\r\n}\r\nreturn 0;\r\nfail_3:\r\nkfree(req->buf);\r\nfail_2:\r\nusb_ep_free_request(dbgp.o_ep, req);\r\nfail_1:\r\ndev_dbg(&dbgp.gadget->dev,\r\n"enable ep req: failure (%d:%d)\n", stp, err);\r\nreturn err;\r\n}\r\nstatic int __enable_ep(struct usb_ep *ep, struct usb_endpoint_descriptor *desc)\r\n{\r\nint err;\r\nep->desc = desc;\r\nerr = usb_ep_enable(ep);\r\nep->driver_data = dbgp.gadget;\r\nreturn err;\r\n}\r\nstatic int dbgp_enable_ep(void)\r\n{\r\nint err, stp;\r\nerr = __enable_ep(dbgp.i_ep, &i_desc);\r\nif (err < 0) {\r\nstp = 1;\r\ngoto fail_1;\r\n}\r\nerr = __enable_ep(dbgp.o_ep, &o_desc);\r\nif (err < 0) {\r\nstp = 2;\r\ngoto fail_2;\r\n}\r\nerr = dbgp_enable_ep_req(dbgp.o_ep);\r\nif (err < 0) {\r\nstp = 3;\r\ngoto fail_3;\r\n}\r\nreturn 0;\r\nfail_3:\r\n__disable_ep(dbgp.o_ep);\r\nfail_2:\r\n__disable_ep(dbgp.i_ep);\r\nfail_1:\r\ndev_dbg(&dbgp.gadget->dev, "enable ep: failure (%d:%d)\n", stp, err);\r\nreturn err;\r\n}\r\nstatic void dbgp_disconnect(struct usb_gadget *gadget)\r\n{\r\n#ifdef CONFIG_USB_G_DBGP_PRINTK\r\ndbgp_disable_ep();\r\n#else\r\ngserial_disconnect(dbgp.serial);\r\n#endif\r\n}\r\nstatic void dbgp_unbind(struct usb_gadget *gadget)\r\n{\r\n#ifdef CONFIG_USB_G_DBGP_SERIAL\r\nkfree(dbgp.serial);\r\n#endif\r\nif (dbgp.req) {\r\nkfree(dbgp.req->buf);\r\nusb_ep_free_request(gadget->ep0, dbgp.req);\r\n}\r\ngadget->ep0->driver_data = NULL;\r\n}\r\nstatic int __init dbgp_configure_endpoints(struct usb_gadget *gadget)\r\n{\r\nint stp;\r\nusb_ep_autoconfig_reset(gadget);\r\ndbgp.i_ep = usb_ep_autoconfig(gadget, &i_desc);\r\nif (!dbgp.i_ep) {\r\nstp = 1;\r\ngoto fail_1;\r\n}\r\ndbgp.i_ep->driver_data = gadget;\r\ni_desc.wMaxPacketSize =\r\n__constant_cpu_to_le16(USB_DEBUG_MAX_PACKET_SIZE);\r\ndbgp.o_ep = usb_ep_autoconfig(gadget, &o_desc);\r\nif (!dbgp.o_ep) {\r\ndbgp.i_ep->driver_data = NULL;\r\nstp = 2;\r\ngoto fail_2;\r\n}\r\ndbgp.o_ep->driver_data = gadget;\r\no_desc.wMaxPacketSize =\r\n__constant_cpu_to_le16(USB_DEBUG_MAX_PACKET_SIZE);\r\ndbg_desc.bDebugInEndpoint = i_desc.bEndpointAddress;\r\ndbg_desc.bDebugOutEndpoint = o_desc.bEndpointAddress;\r\n#ifdef CONFIG_USB_G_DBGP_SERIAL\r\ndbgp.serial->in = dbgp.i_ep;\r\ndbgp.serial->out = dbgp.o_ep;\r\ndbgp.serial->in->desc = &i_desc;\r\ndbgp.serial->out->desc = &o_desc;\r\nif (gserial_setup(gadget, 1) < 0) {\r\nstp = 3;\r\ngoto fail_3;\r\n}\r\nreturn 0;\r\nfail_3:\r\ndbgp.o_ep->driver_data = NULL;\r\n#else\r\nreturn 0;\r\n#endif\r\nfail_2:\r\ndbgp.i_ep->driver_data = NULL;\r\nfail_1:\r\ndev_dbg(&dbgp.gadget->dev, "ep config: failure (%d)\n", stp);\r\nreturn -ENODEV;\r\n}\r\nstatic int __init dbgp_bind(struct usb_gadget *gadget)\r\n{\r\nint err, stp;\r\ndbgp.gadget = gadget;\r\ndbgp.req = usb_ep_alloc_request(gadget->ep0, GFP_KERNEL);\r\nif (!dbgp.req) {\r\nerr = -ENOMEM;\r\nstp = 1;\r\ngoto fail;\r\n}\r\ndbgp.req->buf = kmalloc(DBGP_REQ_EP0_LEN, GFP_KERNEL);\r\nif (!dbgp.req->buf) {\r\nerr = -ENOMEM;\r\nstp = 2;\r\ngoto fail;\r\n}\r\ndbgp.req->length = DBGP_REQ_EP0_LEN;\r\ngadget->ep0->driver_data = gadget;\r\n#ifdef CONFIG_USB_G_DBGP_SERIAL\r\ndbgp.serial = kzalloc(sizeof(struct gserial), GFP_KERNEL);\r\nif (!dbgp.serial) {\r\nstp = 3;\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\n#endif\r\nerr = dbgp_configure_endpoints(gadget);\r\nif (err < 0) {\r\nstp = 4;\r\ngoto fail;\r\n}\r\ndev_dbg(&dbgp.gadget->dev, "bind: success\n");\r\nreturn 0;\r\nfail:\r\ndev_dbg(&gadget->dev, "bind: failure (%d:%d)\n", stp, err);\r\ndbgp_unbind(gadget);\r\nreturn err;\r\n}\r\nstatic void dbgp_setup_complete(struct usb_ep *ep,\r\nstruct usb_request *req)\r\n{\r\ndev_dbg(&dbgp.gadget->dev, "setup complete: %d, %d/%d\n",\r\nreq->status, req->actual, req->length);\r\n}\r\nstatic int dbgp_setup(struct usb_gadget *gadget,\r\nconst struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct usb_request *req = dbgp.req;\r\nu8 request = ctrl->bRequest;\r\nu16 value = le16_to_cpu(ctrl->wValue);\r\nu16 length = le16_to_cpu(ctrl->wLength);\r\nint err = -EOPNOTSUPP;\r\nvoid *data = NULL;\r\nu16 len = 0;\r\ngadget->ep0->driver_data = gadget;\r\nif (request == USB_REQ_GET_DESCRIPTOR) {\r\nswitch (value>>8) {\r\ncase USB_DT_DEVICE:\r\ndev_dbg(&dbgp.gadget->dev, "setup: desc device\n");\r\nlen = sizeof device_desc;\r\ndata = &device_desc;\r\ndevice_desc.bMaxPacketSize0 = gadget->ep0->maxpacket;\r\nbreak;\r\ncase USB_DT_DEBUG:\r\ndev_dbg(&dbgp.gadget->dev, "setup: desc debug\n");\r\nlen = sizeof dbg_desc;\r\ndata = &dbg_desc;\r\nbreak;\r\ndefault:\r\ngoto fail;\r\n}\r\nerr = 0;\r\n} else if (request == USB_REQ_SET_FEATURE &&\r\nvalue == USB_DEVICE_DEBUG_MODE) {\r\ndev_dbg(&dbgp.gadget->dev, "setup: feat debug\n");\r\n#ifdef CONFIG_USB_G_DBGP_PRINTK\r\nerr = dbgp_enable_ep();\r\n#else\r\nerr = gserial_connect(dbgp.serial, 0);\r\n#endif\r\nif (err < 0)\r\ngoto fail;\r\n} else\r\ngoto fail;\r\nreq->length = min(length, len);\r\nreq->zero = len < req->length;\r\nif (data && req->length)\r\nmemcpy(req->buf, data, req->length);\r\nreq->complete = dbgp_setup_complete;\r\nreturn usb_ep_queue(gadget->ep0, req, GFP_ATOMIC);\r\nfail:\r\ndev_dbg(&dbgp.gadget->dev,\r\n"setup: failure req %x v %x\n", request, value);\r\nreturn err;\r\n}\r\nstatic int __init dbgp_init(void)\r\n{\r\nreturn usb_gadget_probe_driver(&dbgp_driver, dbgp_bind);\r\n}\r\nstatic void __exit dbgp_exit(void)\r\n{\r\nusb_gadget_unregister_driver(&dbgp_driver);\r\n#ifdef CONFIG_USB_G_DBGP_SERIAL\r\ngserial_cleanup();\r\n#endif\r\n}
