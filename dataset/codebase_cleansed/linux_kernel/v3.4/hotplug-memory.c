static unsigned long get_memblock_size(void)\r\n{\r\nstruct device_node *np;\r\nunsigned int memblock_size = MIN_MEMORY_BLOCK_SIZE;\r\nstruct resource r;\r\nnp = of_find_node_by_path("/ibm,dynamic-reconfiguration-memory");\r\nif (np) {\r\nconst __be64 *size;\r\nsize = of_get_property(np, "ibm,lmb-size", NULL);\r\nif (size)\r\nmemblock_size = be64_to_cpup(size);\r\nof_node_put(np);\r\n} else if (machine_is(pseries)) {\r\nunsigned int memzero_size = 0;\r\nnp = of_find_node_by_path("/memory@0");\r\nif (np) {\r\nif (!of_address_to_resource(np, 0, &r))\r\nmemzero_size = resource_size(&r);\r\nof_node_put(np);\r\n}\r\nif (memzero_size) {\r\nchar buf[64];\r\nsprintf(buf, "/memory@%x", memzero_size);\r\nnp = of_find_node_by_path(buf);\r\nif (np) {\r\nif (!of_address_to_resource(np, 0, &r))\r\nmemblock_size = resource_size(&r);\r\nof_node_put(np);\r\n}\r\n}\r\n}\r\nreturn memblock_size;\r\n}\r\nunsigned long memory_block_size_bytes(void)\r\n{\r\nreturn get_memblock_size();\r\n}\r\nstatic int pseries_remove_memblock(unsigned long base, unsigned int memblock_size)\r\n{\r\nunsigned long start, start_pfn;\r\nstruct zone *zone;\r\nint ret;\r\nstart_pfn = base >> PAGE_SHIFT;\r\nif (!pfn_valid(start_pfn)) {\r\nmemblock_remove(base, memblock_size);\r\nreturn 0;\r\n}\r\nzone = page_zone(pfn_to_page(start_pfn));\r\nret = __remove_pages(zone, start_pfn, memblock_size >> PAGE_SHIFT);\r\nif (ret)\r\nreturn ret;\r\nmemblock_remove(base, memblock_size);\r\nstart = (unsigned long)__va(base);\r\nret = remove_section_mapping(start, start + memblock_size);\r\nvm_unmap_aliases();\r\nreturn ret;\r\n}\r\nstatic int pseries_remove_memory(struct device_node *np)\r\n{\r\nconst char *type;\r\nconst unsigned int *regs;\r\nunsigned long base;\r\nunsigned int lmb_size;\r\nint ret = -EINVAL;\r\ntype = of_get_property(np, "device_type", NULL);\r\nif (type == NULL || strcmp(type, "memory") != 0)\r\nreturn 0;\r\nregs = of_get_property(np, "reg", NULL);\r\nif (!regs)\r\nreturn ret;\r\nbase = *(unsigned long *)regs;\r\nlmb_size = regs[3];\r\nret = pseries_remove_memblock(base, lmb_size);\r\nreturn ret;\r\n}\r\nstatic int pseries_add_memory(struct device_node *np)\r\n{\r\nconst char *type;\r\nconst unsigned int *regs;\r\nunsigned long base;\r\nunsigned int lmb_size;\r\nint ret = -EINVAL;\r\ntype = of_get_property(np, "device_type", NULL);\r\nif (type == NULL || strcmp(type, "memory") != 0)\r\nreturn 0;\r\nregs = of_get_property(np, "reg", NULL);\r\nif (!regs)\r\nreturn ret;\r\nbase = *(unsigned long *)regs;\r\nlmb_size = regs[3];\r\nret = memblock_add(base, lmb_size);\r\nreturn (ret < 0) ? -EINVAL : 0;\r\n}\r\nstatic int pseries_drconf_memory(unsigned long *base, unsigned int action)\r\n{\r\nunsigned long memblock_size;\r\nint rc;\r\nmemblock_size = get_memblock_size();\r\nif (!memblock_size)\r\nreturn -EINVAL;\r\nif (action == PSERIES_DRCONF_MEM_ADD) {\r\nrc = memblock_add(*base, memblock_size);\r\nrc = (rc < 0) ? -EINVAL : 0;\r\n} else if (action == PSERIES_DRCONF_MEM_REMOVE) {\r\nrc = pseries_remove_memblock(*base, memblock_size);\r\n} else {\r\nrc = -EINVAL;\r\n}\r\nreturn rc;\r\n}\r\nstatic int pseries_memory_notifier(struct notifier_block *nb,\r\nunsigned long action, void *node)\r\n{\r\nint err = 0;\r\nswitch (action) {\r\ncase PSERIES_RECONFIG_ADD:\r\nerr = pseries_add_memory(node);\r\nbreak;\r\ncase PSERIES_RECONFIG_REMOVE:\r\nerr = pseries_remove_memory(node);\r\nbreak;\r\ncase PSERIES_DRCONF_MEM_ADD:\r\ncase PSERIES_DRCONF_MEM_REMOVE:\r\nerr = pseries_drconf_memory(node, action);\r\nbreak;\r\n}\r\nreturn notifier_from_errno(err);\r\n}\r\nstatic int __init pseries_memory_hotplug_init(void)\r\n{\r\nif (firmware_has_feature(FW_FEATURE_LPAR))\r\npSeries_reconfig_notifier_register(&pseries_mem_nb);\r\nreturn 0;\r\n}
