static inline u64 div64_u64_safe(u64 dividend, u64 divisor)\r\n{\r\nif (divisor == 0 && dividend == 0)\r\nreturn 0;\r\nif (divisor == 0)\r\nreturn UINT_MAX;\r\nreturn div64_u64(dividend, divisor);\r\n}\r\nstatic unsigned int get_ohm_of_thermistor(struct ntc_data *data,\r\nunsigned int uV)\r\n{\r\nstruct ntc_thermistor_platform_data *pdata = data->pdata;\r\nu64 mV = uV / 1000;\r\nu64 pmV = pdata->pullup_uV / 1000;\r\nu64 N, puO, pdO;\r\npuO = pdata->pullup_ohm;\r\npdO = pdata->pulldown_ohm;\r\nif (mV == 0) {\r\nif (pdata->connect == NTC_CONNECTED_POSITIVE)\r\nreturn UINT_MAX;\r\nreturn 0;\r\n}\r\nif (mV >= pmV)\r\nreturn (pdata->connect == NTC_CONNECTED_POSITIVE) ?\r\n0 : UINT_MAX;\r\nif (pdata->connect == NTC_CONNECTED_POSITIVE && puO == 0)\r\nN = div64_u64_safe(pdO * (pmV - mV), mV);\r\nelse if (pdata->connect == NTC_CONNECTED_GROUND && pdO == 0)\r\nN = div64_u64_safe(puO * mV, pmV - mV);\r\nelse if (pdata->connect == NTC_CONNECTED_POSITIVE)\r\nN = div64_u64_safe(pdO * puO * (pmV - mV),\r\npuO * mV - pdO * (pmV - mV));\r\nelse\r\nN = div64_u64_safe(pdO * puO * mV, pdO * (pmV - mV) - puO * mV);\r\nreturn (unsigned int) N;\r\n}\r\nstatic int lookup_comp(struct ntc_data *data,\r\nunsigned int ohm, int *i_low, int *i_high)\r\n{\r\nint start, end, mid = -1;\r\nstart = 0;\r\nend = data->n_comp;\r\nwhile (end > start) {\r\nmid = start + (end - start) / 2;\r\nif (data->comp[mid].ohm < ohm)\r\nend = mid;\r\nelse if (data->comp[mid].ohm > ohm)\r\nstart = mid + 1;\r\nelse\r\nbreak;\r\n}\r\nif (mid == 0) {\r\nif (data->comp[mid].ohm > ohm) {\r\n*i_high = mid;\r\n*i_low = mid + 1;\r\nreturn 0;\r\n} else {\r\n*i_low = mid;\r\n*i_high = -1;\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (mid == (data->n_comp - 1)) {\r\nif (data->comp[mid].ohm <= ohm) {\r\n*i_low = mid;\r\n*i_high = mid - 1;\r\nreturn 0;\r\n} else {\r\n*i_low = -1;\r\n*i_high = mid;\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (data->comp[mid].ohm <= ohm) {\r\n*i_low = mid;\r\n*i_high = mid - 1;\r\n} else {\r\n*i_low = mid + 1;\r\n*i_high = mid;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_temp_mC(struct ntc_data *data, unsigned int ohm, int *temp)\r\n{\r\nint low, high;\r\nint ret;\r\nret = lookup_comp(data, ohm, &low, &high);\r\nif (ret) {\r\nif (low != -1)\r\n*temp = data->comp[low].temp_C * 1000;\r\nelse if (high != -1)\r\n*temp = data->comp[high].temp_C * 1000;\r\nelse\r\nreturn ret;\r\n} else {\r\n*temp = data->comp[low].temp_C * 1000 +\r\n((data->comp[high].temp_C - data->comp[low].temp_C) *\r\n1000 * ((int)ohm - (int)data->comp[low].ohm)) /\r\n((int)data->comp[high].ohm - (int)data->comp[low].ohm);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ntc_thermistor_read(struct ntc_data *data, int *temp)\r\n{\r\nint ret;\r\nint read_ohm, read_uV;\r\nunsigned int ohm = 0;\r\nif (data->pdata->read_ohm) {\r\nread_ohm = data->pdata->read_ohm();\r\nif (read_ohm < 0)\r\nreturn read_ohm;\r\nohm = (unsigned int)read_ohm;\r\n}\r\nif (data->pdata->read_uV) {\r\nread_uV = data->pdata->read_uV();\r\nif (read_uV < 0)\r\nreturn read_uV;\r\nohm = get_ohm_of_thermistor(data, (unsigned int)read_uV);\r\n}\r\nret = get_temp_mC(data, ohm, temp);\r\nif (ret) {\r\ndev_dbg(data->dev, "Sensor reading function not available.\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t ntc_show_name(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ntc_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", data->name);\r\n}\r\nstatic ssize_t ntc_show_type(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "4\n");\r\n}\r\nstatic ssize_t ntc_show_temp(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ntc_data *data = dev_get_drvdata(dev);\r\nint temp, ret;\r\nret = ntc_thermistor_read(data, &temp);\r\nif (ret)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", temp);\r\n}\r\nstatic int __devinit ntc_thermistor_probe(struct platform_device *pdev)\r\n{\r\nstruct ntc_data *data;\r\nstruct ntc_thermistor_platform_data *pdata = pdev->dev.platform_data;\r\nint ret = 0;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "No platform init data supplied.\n");\r\nreturn -ENODEV;\r\n}\r\nif (!pdata->read_uV && !pdata->read_ohm) {\r\ndev_err(&pdev->dev, "Both read_uV and read_ohm missing."\r\n"Need either one of the two.\n");\r\nreturn -EINVAL;\r\n}\r\nif (pdata->read_uV && pdata->read_ohm) {\r\ndev_warn(&pdev->dev, "Only one of read_uV and read_ohm "\r\n"is needed; ignoring read_uV.\n");\r\npdata->read_uV = NULL;\r\n}\r\nif (pdata->read_uV && (pdata->pullup_uV == 0 ||\r\n(pdata->pullup_ohm == 0 && pdata->connect ==\r\nNTC_CONNECTED_GROUND) ||\r\n(pdata->pulldown_ohm == 0 && pdata->connect ==\r\nNTC_CONNECTED_POSITIVE) ||\r\n(pdata->connect != NTC_CONNECTED_POSITIVE &&\r\npdata->connect != NTC_CONNECTED_GROUND))) {\r\ndev_err(&pdev->dev, "Required data to use read_uV not "\r\n"supplied.\n");\r\nreturn -EINVAL;\r\n}\r\ndata = kzalloc(sizeof(struct ntc_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->dev = &pdev->dev;\r\ndata->pdata = pdata;\r\nstrncpy(data->name, pdev->id_entry->name, PLATFORM_NAME_SIZE);\r\nswitch (pdev->id_entry->driver_data) {\r\ncase TYPE_NCPXXWB473:\r\ndata->comp = ncpXXwb473;\r\ndata->n_comp = ARRAY_SIZE(ncpXXwb473);\r\nbreak;\r\ncase TYPE_NCPXXWL333:\r\ndata->comp = ncpXXwl333;\r\ndata->n_comp = ARRAY_SIZE(ncpXXwl333);\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Unknown device type: %lu(%s)\n",\r\npdev->id_entry->driver_data,\r\npdev->id_entry->name);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nplatform_set_drvdata(pdev, data);\r\nret = sysfs_create_group(&data->dev->kobj, &ntc_attr_group);\r\nif (ret) {\r\ndev_err(data->dev, "unable to create sysfs files\n");\r\ngoto err;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(data->dev);\r\nif (IS_ERR_OR_NULL(data->hwmon_dev)) {\r\ndev_err(data->dev, "unable to register as hwmon device.\n");\r\nret = -EINVAL;\r\ngoto err_after_sysfs;\r\n}\r\ndev_info(&pdev->dev, "Thermistor %s:%d (type: %s/%lu) successfully probed.\n",\r\npdev->name, pdev->id, pdev->id_entry->name,\r\npdev->id_entry->driver_data);\r\nreturn 0;\r\nerr_after_sysfs:\r\nsysfs_remove_group(&data->dev->kobj, &ntc_attr_group);\r\nerr:\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic int __devexit ntc_thermistor_remove(struct platform_device *pdev)\r\n{\r\nstruct ntc_data *data = platform_get_drvdata(pdev);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&data->dev->kobj, &ntc_attr_group);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(data);\r\nreturn 0;\r\n}
