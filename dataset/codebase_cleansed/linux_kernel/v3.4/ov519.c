static unsigned char ov7670_abs_to_sm(unsigned char v)\r\n{\r\nif (v > 127)\r\nreturn v & 0x7f;\r\nreturn (128 - v) | 0x80;\r\n}\r\nstatic void reg_w(struct sd *sd, u16 index, u16 value)\r\n{\r\nint ret, req = 0;\r\nif (sd->gspca_dev.usb_err < 0)\r\nreturn;\r\nswitch (sd->bridge) {\r\ncase BRIDGE_OV511:\r\ncase BRIDGE_OV511PLUS:\r\nreq = 2;\r\nbreak;\r\ncase BRIDGE_OVFX2:\r\nreq = 0x0a;\r\ncase BRIDGE_W9968CF:\r\nPDEBUG(D_USBO, "SET %02x %04x %04x",\r\nreq, value, index);\r\nret = usb_control_msg(sd->gspca_dev.dev,\r\nusb_sndctrlpipe(sd->gspca_dev.dev, 0),\r\nreq,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index, NULL, 0, 500);\r\ngoto leave;\r\ndefault:\r\nreq = 1;\r\n}\r\nPDEBUG(D_USBO, "SET %02x 0000 %04x %02x",\r\nreq, index, value);\r\nsd->gspca_dev.usb_buf[0] = value;\r\nret = usb_control_msg(sd->gspca_dev.dev,\r\nusb_sndctrlpipe(sd->gspca_dev.dev, 0),\r\nreq,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, index,\r\nsd->gspca_dev.usb_buf, 1, 500);\r\nleave:\r\nif (ret < 0) {\r\npr_err("reg_w %02x failed %d\n", index, ret);\r\nsd->gspca_dev.usb_err = ret;\r\nreturn;\r\n}\r\n}\r\nstatic int reg_r(struct sd *sd, u16 index)\r\n{\r\nint ret;\r\nint req;\r\nif (sd->gspca_dev.usb_err < 0)\r\nreturn -1;\r\nswitch (sd->bridge) {\r\ncase BRIDGE_OV511:\r\ncase BRIDGE_OV511PLUS:\r\nreq = 3;\r\nbreak;\r\ncase BRIDGE_OVFX2:\r\nreq = 0x0b;\r\nbreak;\r\ndefault:\r\nreq = 1;\r\n}\r\nret = usb_control_msg(sd->gspca_dev.dev,\r\nusb_rcvctrlpipe(sd->gspca_dev.dev, 0),\r\nreq,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, index, sd->gspca_dev.usb_buf, 1, 500);\r\nif (ret >= 0) {\r\nret = sd->gspca_dev.usb_buf[0];\r\nPDEBUG(D_USBI, "GET %02x 0000 %04x %02x",\r\nreq, index, ret);\r\n} else {\r\npr_err("reg_r %02x failed %d\n", index, ret);\r\nsd->gspca_dev.usb_err = ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int reg_r8(struct sd *sd,\r\nu16 index)\r\n{\r\nint ret;\r\nif (sd->gspca_dev.usb_err < 0)\r\nreturn -1;\r\nret = usb_control_msg(sd->gspca_dev.dev,\r\nusb_rcvctrlpipe(sd->gspca_dev.dev, 0),\r\n1,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, index, sd->gspca_dev.usb_buf, 8, 500);\r\nif (ret >= 0) {\r\nret = sd->gspca_dev.usb_buf[0];\r\n} else {\r\npr_err("reg_r8 %02x failed %d\n", index, ret);\r\nsd->gspca_dev.usb_err = ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic void reg_w_mask(struct sd *sd,\r\nu16 index,\r\nu8 value,\r\nu8 mask)\r\n{\r\nint ret;\r\nu8 oldval;\r\nif (mask != 0xff) {\r\nvalue &= mask;\r\nret = reg_r(sd, index);\r\nif (ret < 0)\r\nreturn;\r\noldval = ret & ~mask;\r\nvalue |= oldval;\r\n}\r\nreg_w(sd, index, value);\r\n}\r\nstatic void ov518_reg_w32(struct sd *sd, u16 index, u32 value, int n)\r\n{\r\nint ret;\r\nif (sd->gspca_dev.usb_err < 0)\r\nreturn;\r\n*((__le32 *) sd->gspca_dev.usb_buf) = __cpu_to_le32(value);\r\nret = usb_control_msg(sd->gspca_dev.dev,\r\nusb_sndctrlpipe(sd->gspca_dev.dev, 0),\r\n1 ,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, index,\r\nsd->gspca_dev.usb_buf, n, 500);\r\nif (ret < 0) {\r\npr_err("reg_w32 %02x failed %d\n", index, ret);\r\nsd->gspca_dev.usb_err = ret;\r\n}\r\n}\r\nstatic void ov511_i2c_w(struct sd *sd, u8 reg, u8 value)\r\n{\r\nint rc, retries;\r\nPDEBUG(D_USBO, "ov511_i2c_w %02x %02x", reg, value);\r\nfor (retries = 6; ; ) {\r\nreg_w(sd, R51x_I2C_SADDR_3, reg);\r\nreg_w(sd, R51x_I2C_DATA, value);\r\nreg_w(sd, R511_I2C_CTL, 0x01);\r\ndo {\r\nrc = reg_r(sd, R511_I2C_CTL);\r\n} while (rc > 0 && ((rc & 1) == 0));\r\nif (rc < 0)\r\nreturn;\r\nif ((rc & 2) == 0)\r\nbreak;\r\nif (--retries < 0) {\r\nPDEBUG(D_USBO, "i2c write retries exhausted");\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic int ov511_i2c_r(struct sd *sd, u8 reg)\r\n{\r\nint rc, value, retries;\r\nfor (retries = 6; ; ) {\r\nreg_w(sd, R51x_I2C_SADDR_2, reg);\r\nreg_w(sd, R511_I2C_CTL, 0x03);\r\ndo {\r\nrc = reg_r(sd, R511_I2C_CTL);\r\n} while (rc > 0 && ((rc & 1) == 0));\r\nif (rc < 0)\r\nreturn rc;\r\nif ((rc & 2) == 0)\r\nbreak;\r\nreg_w(sd, R511_I2C_CTL, 0x10);\r\nif (--retries < 0) {\r\nPDEBUG(D_USBI, "i2c write retries exhausted");\r\nreturn -1;\r\n}\r\n}\r\nfor (retries = 6; ; ) {\r\nreg_w(sd, R511_I2C_CTL, 0x05);\r\ndo {\r\nrc = reg_r(sd, R511_I2C_CTL);\r\n} while (rc > 0 && ((rc & 1) == 0));\r\nif (rc < 0)\r\nreturn rc;\r\nif ((rc & 2) == 0)\r\nbreak;\r\nreg_w(sd, R511_I2C_CTL, 0x10);\r\nif (--retries < 0) {\r\nPDEBUG(D_USBI, "i2c read retries exhausted");\r\nreturn -1;\r\n}\r\n}\r\nvalue = reg_r(sd, R51x_I2C_DATA);\r\nPDEBUG(D_USBI, "ov511_i2c_r %02x %02x", reg, value);\r\nreg_w(sd, R511_I2C_CTL, 0x05);\r\nreturn value;\r\n}\r\nstatic void ov518_i2c_w(struct sd *sd,\r\nu8 reg,\r\nu8 value)\r\n{\r\nPDEBUG(D_USBO, "ov518_i2c_w %02x %02x", reg, value);\r\nreg_w(sd, R51x_I2C_SADDR_3, reg);\r\nreg_w(sd, R51x_I2C_DATA, value);\r\nreg_w(sd, R518_I2C_CTL, 0x01);\r\nmsleep(4);\r\nreg_r8(sd, R518_I2C_CTL);\r\n}\r\nstatic int ov518_i2c_r(struct sd *sd, u8 reg)\r\n{\r\nint value;\r\nreg_w(sd, R51x_I2C_SADDR_2, reg);\r\nreg_w(sd, R518_I2C_CTL, 0x03);\r\nreg_r8(sd, R518_I2C_CTL);\r\nreg_w(sd, R518_I2C_CTL, 0x05);\r\nreg_r8(sd, R518_I2C_CTL);\r\nvalue = reg_r(sd, R51x_I2C_DATA);\r\nPDEBUG(D_USBI, "ov518_i2c_r %02x %02x", reg, value);\r\nreturn value;\r\n}\r\nstatic void ovfx2_i2c_w(struct sd *sd, u8 reg, u8 value)\r\n{\r\nint ret;\r\nif (sd->gspca_dev.usb_err < 0)\r\nreturn;\r\nret = usb_control_msg(sd->gspca_dev.dev,\r\nusb_sndctrlpipe(sd->gspca_dev.dev, 0),\r\n0x02,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n(u16) value, (u16) reg, NULL, 0, 500);\r\nif (ret < 0) {\r\npr_err("ovfx2_i2c_w %02x failed %d\n", reg, ret);\r\nsd->gspca_dev.usb_err = ret;\r\n}\r\nPDEBUG(D_USBO, "ovfx2_i2c_w %02x %02x", reg, value);\r\n}\r\nstatic int ovfx2_i2c_r(struct sd *sd, u8 reg)\r\n{\r\nint ret;\r\nif (sd->gspca_dev.usb_err < 0)\r\nreturn -1;\r\nret = usb_control_msg(sd->gspca_dev.dev,\r\nusb_rcvctrlpipe(sd->gspca_dev.dev, 0),\r\n0x03,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, (u16) reg, sd->gspca_dev.usb_buf, 1, 500);\r\nif (ret >= 0) {\r\nret = sd->gspca_dev.usb_buf[0];\r\nPDEBUG(D_USBI, "ovfx2_i2c_r %02x %02x", reg, ret);\r\n} else {\r\npr_err("ovfx2_i2c_r %02x failed %d\n", reg, ret);\r\nsd->gspca_dev.usb_err = ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic void i2c_w(struct sd *sd, u8 reg, u8 value)\r\n{\r\nif (sd->sensor_reg_cache[reg] == value)\r\nreturn;\r\nswitch (sd->bridge) {\r\ncase BRIDGE_OV511:\r\ncase BRIDGE_OV511PLUS:\r\nov511_i2c_w(sd, reg, value);\r\nbreak;\r\ncase BRIDGE_OV518:\r\ncase BRIDGE_OV518PLUS:\r\ncase BRIDGE_OV519:\r\nov518_i2c_w(sd, reg, value);\r\nbreak;\r\ncase BRIDGE_OVFX2:\r\novfx2_i2c_w(sd, reg, value);\r\nbreak;\r\ncase BRIDGE_W9968CF:\r\nw9968cf_i2c_w(sd, reg, value);\r\nbreak;\r\n}\r\nif (sd->gspca_dev.usb_err >= 0) {\r\nif (reg == 0x12 && (value & 0x80))\r\nmemset(sd->sensor_reg_cache, -1,\r\nsizeof(sd->sensor_reg_cache));\r\nelse\r\nsd->sensor_reg_cache[reg] = value;\r\n}\r\n}\r\nstatic int i2c_r(struct sd *sd, u8 reg)\r\n{\r\nint ret = -1;\r\nif (sd->sensor_reg_cache[reg] != -1)\r\nreturn sd->sensor_reg_cache[reg];\r\nswitch (sd->bridge) {\r\ncase BRIDGE_OV511:\r\ncase BRIDGE_OV511PLUS:\r\nret = ov511_i2c_r(sd, reg);\r\nbreak;\r\ncase BRIDGE_OV518:\r\ncase BRIDGE_OV518PLUS:\r\ncase BRIDGE_OV519:\r\nret = ov518_i2c_r(sd, reg);\r\nbreak;\r\ncase BRIDGE_OVFX2:\r\nret = ovfx2_i2c_r(sd, reg);\r\nbreak;\r\ncase BRIDGE_W9968CF:\r\nret = w9968cf_i2c_r(sd, reg);\r\nbreak;\r\n}\r\nif (ret >= 0)\r\nsd->sensor_reg_cache[reg] = ret;\r\nreturn ret;\r\n}\r\nstatic void i2c_w_mask(struct sd *sd,\r\nu8 reg,\r\nu8 value,\r\nu8 mask)\r\n{\r\nint rc;\r\nu8 oldval;\r\nvalue &= mask;\r\nrc = i2c_r(sd, reg);\r\nif (rc < 0)\r\nreturn;\r\noldval = rc & ~mask;\r\nvalue |= oldval;\r\ni2c_w(sd, reg, value);\r\n}\r\nstatic inline void ov51x_stop(struct sd *sd)\r\n{\r\nPDEBUG(D_STREAM, "stopping");\r\nsd->stopped = 1;\r\nswitch (sd->bridge) {\r\ncase BRIDGE_OV511:\r\ncase BRIDGE_OV511PLUS:\r\nreg_w(sd, R51x_SYS_RESET, 0x3d);\r\nbreak;\r\ncase BRIDGE_OV518:\r\ncase BRIDGE_OV518PLUS:\r\nreg_w_mask(sd, R51x_SYS_RESET, 0x3a, 0x3a);\r\nbreak;\r\ncase BRIDGE_OV519:\r\nreg_w(sd, OV519_R51_RESET1, 0x0f);\r\nreg_w(sd, OV519_R51_RESET1, 0x00);\r\nreg_w(sd, 0x22, 0x00);\r\nbreak;\r\ncase BRIDGE_OVFX2:\r\nreg_w_mask(sd, 0x0f, 0x00, 0x02);\r\nbreak;\r\ncase BRIDGE_W9968CF:\r\nreg_w(sd, 0x3c, 0x0a05);\r\nbreak;\r\n}\r\n}\r\nstatic inline void ov51x_restart(struct sd *sd)\r\n{\r\nPDEBUG(D_STREAM, "restarting");\r\nif (!sd->stopped)\r\nreturn;\r\nsd->stopped = 0;\r\nswitch (sd->bridge) {\r\ncase BRIDGE_OV511:\r\ncase BRIDGE_OV511PLUS:\r\nreg_w(sd, R51x_SYS_RESET, 0x00);\r\nbreak;\r\ncase BRIDGE_OV518:\r\ncase BRIDGE_OV518PLUS:\r\nreg_w(sd, 0x2f, 0x80);\r\nreg_w(sd, R51x_SYS_RESET, 0x00);\r\nbreak;\r\ncase BRIDGE_OV519:\r\nreg_w(sd, OV519_R51_RESET1, 0x0f);\r\nreg_w(sd, OV519_R51_RESET1, 0x00);\r\nreg_w(sd, 0x22, 0x1d);\r\nbreak;\r\ncase BRIDGE_OVFX2:\r\nreg_w_mask(sd, 0x0f, 0x02, 0x02);\r\nbreak;\r\ncase BRIDGE_W9968CF:\r\nreg_w(sd, 0x3c, 0x8a05);\r\nbreak;\r\n}\r\n}\r\nstatic int init_ov_sensor(struct sd *sd, u8 slave)\r\n{\r\nint i;\r\nov51x_set_slave_ids(sd, slave);\r\ni2c_w(sd, 0x12, 0x80);\r\nmsleep(150);\r\nfor (i = 0; i < i2c_detect_tries; i++) {\r\nif (i2c_r(sd, OV7610_REG_ID_HIGH) == 0x7f &&\r\ni2c_r(sd, OV7610_REG_ID_LOW) == 0xa2) {\r\nPDEBUG(D_PROBE, "I2C synced in %d attempt(s)", i);\r\nreturn 0;\r\n}\r\ni2c_w(sd, 0x12, 0x80);\r\nmsleep(150);\r\nif (i2c_r(sd, 0x00) < 0)\r\nreturn -1;\r\n}\r\nreturn -1;\r\n}\r\nstatic void ov51x_set_slave_ids(struct sd *sd,\r\nu8 slave)\r\n{\r\nswitch (sd->bridge) {\r\ncase BRIDGE_OVFX2:\r\nreg_w(sd, OVFX2_I2C_ADDR, slave);\r\nreturn;\r\ncase BRIDGE_W9968CF:\r\nsd->sensor_addr = slave;\r\nreturn;\r\n}\r\nreg_w(sd, R51x_I2C_W_SID, slave);\r\nreg_w(sd, R51x_I2C_R_SID, slave + 1);\r\n}\r\nstatic void write_regvals(struct sd *sd,\r\nconst struct ov_regvals *regvals,\r\nint n)\r\n{\r\nwhile (--n >= 0) {\r\nreg_w(sd, regvals->reg, regvals->val);\r\nregvals++;\r\n}\r\n}\r\nstatic void write_i2c_regvals(struct sd *sd,\r\nconst struct ov_i2c_regvals *regvals,\r\nint n)\r\n{\r\nwhile (--n >= 0) {\r\ni2c_w(sd, regvals->reg, regvals->val);\r\nregvals++;\r\n}\r\n}\r\nstatic void ov_hires_configure(struct sd *sd)\r\n{\r\nint high, low;\r\nif (sd->bridge != BRIDGE_OVFX2) {\r\npr_err("error hires sensors only supported with ovfx2\n");\r\nreturn;\r\n}\r\nPDEBUG(D_PROBE, "starting ov hires configuration");\r\nhigh = i2c_r(sd, 0x0a);\r\nlow = i2c_r(sd, 0x0b);\r\nswitch (high) {\r\ncase 0x96:\r\nswitch (low) {\r\ncase 0x40:\r\nPDEBUG(D_PROBE, "Sensor is a OV2610");\r\nsd->sensor = SEN_OV2610;\r\nreturn;\r\ncase 0x41:\r\nPDEBUG(D_PROBE, "Sensor is a OV2610AE");\r\nsd->sensor = SEN_OV2610AE;\r\nreturn;\r\ncase 0xb1:\r\nPDEBUG(D_PROBE, "Sensor is a OV9600");\r\nsd->sensor = SEN_OV9600;\r\nreturn;\r\n}\r\nbreak;\r\ncase 0x36:\r\nif ((low & 0x0f) == 0x00) {\r\nPDEBUG(D_PROBE, "Sensor is a OV3610");\r\nsd->sensor = SEN_OV3610;\r\nreturn;\r\n}\r\nbreak;\r\n}\r\npr_err("Error unknown sensor type: %02x%02x\n", high, low);\r\n}\r\nstatic void ov8xx0_configure(struct sd *sd)\r\n{\r\nint rc;\r\nPDEBUG(D_PROBE, "starting ov8xx0 configuration");\r\nrc = i2c_r(sd, OV7610_REG_COM_I);\r\nif (rc < 0) {\r\nPDEBUG(D_ERR, "Error detecting sensor type");\r\nreturn;\r\n}\r\nif ((rc & 3) == 1)\r\nsd->sensor = SEN_OV8610;\r\nelse\r\npr_err("Unknown image sensor version: %d\n", rc & 3);\r\n}\r\nstatic void ov7xx0_configure(struct sd *sd)\r\n{\r\nint rc, high, low;\r\nPDEBUG(D_PROBE, "starting OV7xx0 configuration");\r\nrc = i2c_r(sd, OV7610_REG_COM_I);\r\nif (rc < 0) {\r\nPDEBUG(D_ERR, "Error detecting sensor type");\r\nreturn;\r\n}\r\nif ((rc & 3) == 3) {\r\nhigh = i2c_r(sd, 0x0a);\r\nlow = i2c_r(sd, 0x0b);\r\nif (high == 0x76 && (low & 0xf0) == 0x70) {\r\nPDEBUG(D_PROBE, "Sensor is an OV76%02x", low);\r\nsd->sensor = SEN_OV7670;\r\n} else {\r\nPDEBUG(D_PROBE, "Sensor is an OV7610");\r\nsd->sensor = SEN_OV7610;\r\n}\r\n} else if ((rc & 3) == 1) {\r\nif (i2c_r(sd, 0x15) & 1) {\r\nPDEBUG(D_PROBE, "Sensor is an OV7620AE");\r\nsd->sensor = SEN_OV7620AE;\r\n} else {\r\nPDEBUG(D_PROBE, "Sensor is an OV76BE");\r\nsd->sensor = SEN_OV76BE;\r\n}\r\n} else if ((rc & 3) == 0) {\r\nhigh = i2c_r(sd, 0x0a);\r\nif (high < 0) {\r\nPDEBUG(D_ERR, "Error detecting camera chip PID");\r\nreturn;\r\n}\r\nlow = i2c_r(sd, 0x0b);\r\nif (low < 0) {\r\nPDEBUG(D_ERR, "Error detecting camera chip VER");\r\nreturn;\r\n}\r\nif (high == 0x76) {\r\nswitch (low) {\r\ncase 0x30:\r\npr_err("Sensor is an OV7630/OV7635\n");\r\npr_err("7630 is not supported by this driver\n");\r\nreturn;\r\ncase 0x40:\r\nPDEBUG(D_PROBE, "Sensor is an OV7645");\r\nsd->sensor = SEN_OV7640;\r\nbreak;\r\ncase 0x45:\r\nPDEBUG(D_PROBE, "Sensor is an OV7645B");\r\nsd->sensor = SEN_OV7640;\r\nbreak;\r\ncase 0x48:\r\nPDEBUG(D_PROBE, "Sensor is an OV7648");\r\nsd->sensor = SEN_OV7648;\r\nbreak;\r\ncase 0x60:\r\nPDEBUG(D_PROBE, "Sensor is a OV7660");\r\nsd->sensor = SEN_OV7660;\r\nbreak;\r\ndefault:\r\nPDEBUG(D_PROBE, "Unknown sensor: 0x76%x", low);\r\nreturn;\r\n}\r\n} else {\r\nPDEBUG(D_PROBE, "Sensor is an OV7620");\r\nsd->sensor = SEN_OV7620;\r\n}\r\n} else {\r\npr_err("Unknown image sensor version: %d\n", rc & 3);\r\n}\r\n}\r\nstatic void ov6xx0_configure(struct sd *sd)\r\n{\r\nint rc;\r\nPDEBUG(D_PROBE, "starting OV6xx0 configuration");\r\nrc = i2c_r(sd, OV7610_REG_COM_I);\r\nif (rc < 0) {\r\nPDEBUG(D_ERR, "Error detecting sensor type");\r\nreturn;\r\n}\r\nswitch (rc) {\r\ncase 0x00:\r\nsd->sensor = SEN_OV6630;\r\npr_warn("WARNING: Sensor is an OV66308. Your camera may have been misdetected in previous driver versions.\n");\r\nbreak;\r\ncase 0x01:\r\nsd->sensor = SEN_OV6620;\r\nPDEBUG(D_PROBE, "Sensor is an OV6620");\r\nbreak;\r\ncase 0x02:\r\nsd->sensor = SEN_OV6630;\r\nPDEBUG(D_PROBE, "Sensor is an OV66308AE");\r\nbreak;\r\ncase 0x03:\r\nsd->sensor = SEN_OV66308AF;\r\nPDEBUG(D_PROBE, "Sensor is an OV66308AF");\r\nbreak;\r\ncase 0x90:\r\nsd->sensor = SEN_OV6630;\r\npr_warn("WARNING: Sensor is an OV66307. Your camera may have been misdetected in previous driver versions.\n");\r\nbreak;\r\ndefault:\r\npr_err("FATAL: Unknown sensor version: 0x%02x\n", rc);\r\nreturn;\r\n}\r\nsd->sif = 1;\r\n}\r\nstatic void ov51x_led_control(struct sd *sd, int on)\r\n{\r\nif (sd->invert_led)\r\non = !on;\r\nswitch (sd->bridge) {\r\ncase BRIDGE_OV511PLUS:\r\nreg_w(sd, R511_SYS_LED_CTL, on);\r\nbreak;\r\ncase BRIDGE_OV518:\r\ncase BRIDGE_OV518PLUS:\r\nreg_w_mask(sd, R518_GPIO_OUT, 0x02 * on, 0x02);\r\nbreak;\r\ncase BRIDGE_OV519:\r\nreg_w_mask(sd, OV519_GPIO_DATA_OUT0, on, 1);\r\nbreak;\r\n}\r\n}\r\nstatic void sd_reset_snapshot(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (!sd->snapshot_needs_reset)\r\nreturn;\r\nsd->snapshot_needs_reset = 0;\r\nswitch (sd->bridge) {\r\ncase BRIDGE_OV511:\r\ncase BRIDGE_OV511PLUS:\r\nreg_w(sd, R51x_SYS_SNAP, 0x02);\r\nreg_w(sd, R51x_SYS_SNAP, 0x00);\r\nbreak;\r\ncase BRIDGE_OV518:\r\ncase BRIDGE_OV518PLUS:\r\nreg_w(sd, R51x_SYS_SNAP, 0x02);\r\nreg_w(sd, R51x_SYS_SNAP, 0x01);\r\nbreak;\r\ncase BRIDGE_OV519:\r\nreg_w(sd, R51x_SYS_RESET, 0x40);\r\nreg_w(sd, R51x_SYS_RESET, 0x00);\r\nbreak;\r\n}\r\n}\r\nstatic void ov51x_upload_quan_tables(struct sd *sd)\r\n{\r\nconst unsigned char yQuanTable511[] = {\r\n0, 1, 1, 2, 2, 3, 3, 4,\r\n1, 1, 1, 2, 2, 3, 4, 4,\r\n1, 1, 2, 2, 3, 4, 4, 4,\r\n2, 2, 2, 3, 4, 4, 4, 4,\r\n2, 2, 3, 4, 4, 5, 5, 5,\r\n3, 3, 4, 4, 5, 5, 5, 5,\r\n3, 4, 4, 4, 5, 5, 5, 5,\r\n4, 4, 4, 4, 5, 5, 5, 5\r\n};\r\nconst unsigned char uvQuanTable511[] = {\r\n0, 2, 2, 3, 4, 4, 4, 4,\r\n2, 2, 2, 4, 4, 4, 4, 4,\r\n2, 2, 3, 4, 4, 4, 4, 4,\r\n3, 4, 4, 4, 4, 4, 4, 4,\r\n4, 4, 4, 4, 4, 4, 4, 4,\r\n4, 4, 4, 4, 4, 4, 4, 4,\r\n4, 4, 4, 4, 4, 4, 4, 4,\r\n4, 4, 4, 4, 4, 4, 4, 4\r\n};\r\nconst unsigned char yQuanTable518[] = {\r\n5, 4, 5, 6, 6, 7, 7, 7,\r\n5, 5, 5, 5, 6, 7, 7, 7,\r\n6, 6, 6, 6, 7, 7, 7, 8,\r\n7, 7, 6, 7, 7, 7, 8, 8\r\n};\r\nconst unsigned char uvQuanTable518[] = {\r\n6, 6, 6, 7, 7, 7, 7, 7,\r\n6, 6, 6, 7, 7, 7, 7, 7,\r\n6, 6, 6, 7, 7, 7, 7, 8,\r\n7, 7, 7, 7, 7, 7, 8, 8\r\n};\r\nconst unsigned char *pYTable, *pUVTable;\r\nunsigned char val0, val1;\r\nint i, size, reg = R51x_COMP_LUT_BEGIN;\r\nPDEBUG(D_PROBE, "Uploading quantization tables");\r\nif (sd->bridge == BRIDGE_OV511 || sd->bridge == BRIDGE_OV511PLUS) {\r\npYTable = yQuanTable511;\r\npUVTable = uvQuanTable511;\r\nsize = 32;\r\n} else {\r\npYTable = yQuanTable518;\r\npUVTable = uvQuanTable518;\r\nsize = 16;\r\n}\r\nfor (i = 0; i < size; i++) {\r\nval0 = *pYTable++;\r\nval1 = *pYTable++;\r\nval0 &= 0x0f;\r\nval1 &= 0x0f;\r\nval0 |= val1 << 4;\r\nreg_w(sd, reg, val0);\r\nval0 = *pUVTable++;\r\nval1 = *pUVTable++;\r\nval0 &= 0x0f;\r\nval1 &= 0x0f;\r\nval0 |= val1 << 4;\r\nreg_w(sd, reg + size, val0);\r\nreg++;\r\n}\r\n}\r\nstatic void ov511_configure(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nconst struct ov_regvals init_511[] = {\r\n{ R51x_SYS_RESET, 0x7f },\r\n{ R51x_SYS_INIT, 0x01 },\r\n{ R51x_SYS_RESET, 0x7f },\r\n{ R51x_SYS_INIT, 0x01 },\r\n{ R51x_SYS_RESET, 0x3f },\r\n{ R51x_SYS_INIT, 0x01 },\r\n{ R51x_SYS_RESET, 0x3d },\r\n};\r\nconst struct ov_regvals norm_511[] = {\r\n{ R511_DRAM_FLOW_CTL, 0x01 },\r\n{ R51x_SYS_SNAP, 0x00 },\r\n{ R51x_SYS_SNAP, 0x02 },\r\n{ R51x_SYS_SNAP, 0x00 },\r\n{ R511_FIFO_OPTS, 0x1f },\r\n{ R511_COMP_EN, 0x00 },\r\n{ R511_COMP_LUT_EN, 0x03 },\r\n};\r\nconst struct ov_regvals norm_511_p[] = {\r\n{ R511_DRAM_FLOW_CTL, 0xff },\r\n{ R51x_SYS_SNAP, 0x00 },\r\n{ R51x_SYS_SNAP, 0x02 },\r\n{ R51x_SYS_SNAP, 0x00 },\r\n{ R511_FIFO_OPTS, 0xff },\r\n{ R511_COMP_EN, 0x00 },\r\n{ R511_COMP_LUT_EN, 0x03 },\r\n};\r\nconst struct ov_regvals compress_511[] = {\r\n{ 0x70, 0x1f },\r\n{ 0x71, 0x05 },\r\n{ 0x72, 0x06 },\r\n{ 0x73, 0x06 },\r\n{ 0x74, 0x14 },\r\n{ 0x75, 0x03 },\r\n{ 0x76, 0x04 },\r\n{ 0x77, 0x04 },\r\n};\r\nPDEBUG(D_PROBE, "Device custom id %x", reg_r(sd, R51x_SYS_CUST_ID));\r\nwrite_regvals(sd, init_511, ARRAY_SIZE(init_511));\r\nswitch (sd->bridge) {\r\ncase BRIDGE_OV511:\r\nwrite_regvals(sd, norm_511, ARRAY_SIZE(norm_511));\r\nbreak;\r\ncase BRIDGE_OV511PLUS:\r\nwrite_regvals(sd, norm_511_p, ARRAY_SIZE(norm_511_p));\r\nbreak;\r\n}\r\nwrite_regvals(sd, compress_511, ARRAY_SIZE(compress_511));\r\nov51x_upload_quan_tables(sd);\r\n}\r\nstatic void ov518_configure(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nconst struct ov_regvals init_518[] = {\r\n{ R51x_SYS_RESET, 0x40 },\r\n{ R51x_SYS_INIT, 0xe1 },\r\n{ R51x_SYS_RESET, 0x3e },\r\n{ R51x_SYS_INIT, 0xe1 },\r\n{ R51x_SYS_RESET, 0x00 },\r\n{ R51x_SYS_INIT, 0xe1 },\r\n{ 0x46, 0x00 },\r\n{ 0x5d, 0x03 },\r\n};\r\nconst struct ov_regvals norm_518[] = {\r\n{ R51x_SYS_SNAP, 0x02 },\r\n{ R51x_SYS_SNAP, 0x01 },\r\n{ 0x31, 0x0f },\r\n{ 0x5d, 0x03 },\r\n{ 0x24, 0x9f },\r\n{ 0x25, 0x90 },\r\n{ 0x20, 0x00 },\r\n{ 0x51, 0x04 },\r\n{ 0x71, 0x19 },\r\n{ 0x2f, 0x80 },\r\n};\r\nconst struct ov_regvals norm_518_p[] = {\r\n{ R51x_SYS_SNAP, 0x02 },\r\n{ R51x_SYS_SNAP, 0x01 },\r\n{ 0x31, 0x0f },\r\n{ 0x5d, 0x03 },\r\n{ 0x24, 0x9f },\r\n{ 0x25, 0x90 },\r\n{ 0x20, 0x60 },\r\n{ 0x51, 0x02 },\r\n{ 0x71, 0x19 },\r\n{ 0x40, 0xff },\r\n{ 0x41, 0x42 },\r\n{ 0x46, 0x00 },\r\n{ 0x33, 0x04 },\r\n{ 0x21, 0x19 },\r\n{ 0x3f, 0x10 },\r\n{ 0x2f, 0x80 },\r\n};\r\nPDEBUG(D_PROBE, "Device revision %d",\r\n0x1f & reg_r(sd, R51x_SYS_CUST_ID));\r\nwrite_regvals(sd, init_518, ARRAY_SIZE(init_518));\r\nreg_w_mask(sd, R518_GPIO_CTL, 0x00, 0x02);\r\nswitch (sd->bridge) {\r\ncase BRIDGE_OV518:\r\nwrite_regvals(sd, norm_518, ARRAY_SIZE(norm_518));\r\nbreak;\r\ncase BRIDGE_OV518PLUS:\r\nwrite_regvals(sd, norm_518_p, ARRAY_SIZE(norm_518_p));\r\nbreak;\r\n}\r\nov51x_upload_quan_tables(sd);\r\nreg_w(sd, 0x2f, 0x80);\r\n}\r\nstatic void ov519_configure(struct sd *sd)\r\n{\r\nstatic const struct ov_regvals init_519[] = {\r\n{ 0x5a, 0x6d },\r\n{ 0x53, 0x9b },\r\n{ OV519_R54_EN_CLK1, 0xff },\r\n{ 0x5d, 0x03 },\r\n{ 0x49, 0x01 },\r\n{ 0x48, 0x00 },\r\n{ OV519_GPIO_IO_CTRL0, 0xee },\r\n{ OV519_R51_RESET1, 0x0f },\r\n{ OV519_R51_RESET1, 0x00 },\r\n{ 0x22, 0x00 },\r\n};\r\nwrite_regvals(sd, init_519, ARRAY_SIZE(init_519));\r\n}\r\nstatic void ovfx2_configure(struct sd *sd)\r\n{\r\nstatic const struct ov_regvals init_fx2[] = {\r\n{ 0x00, 0x60 },\r\n{ 0x02, 0x01 },\r\n{ 0x0f, 0x1d },\r\n{ 0xe9, 0x82 },\r\n{ 0xea, 0xc7 },\r\n{ 0xeb, 0x10 },\r\n{ 0xec, 0xf6 },\r\n};\r\nsd->stopped = 1;\r\nwrite_regvals(sd, init_fx2, ARRAY_SIZE(init_fx2));\r\n}\r\nstatic void ov519_set_mode(struct sd *sd)\r\n{\r\nstatic const struct ov_regvals bridge_ov7660[2][10] = {\r\n{{0x10, 0x14}, {0x11, 0x1e}, {0x12, 0x00}, {0x13, 0x00},\r\n{0x14, 0x00}, {0x15, 0x00}, {0x16, 0x00}, {0x20, 0x0c},\r\n{0x25, 0x01}, {0x26, 0x00}},\r\n{{0x10, 0x28}, {0x11, 0x3c}, {0x12, 0x00}, {0x13, 0x00},\r\n{0x14, 0x00}, {0x15, 0x00}, {0x16, 0x00}, {0x20, 0x0c},\r\n{0x25, 0x03}, {0x26, 0x00}}\r\n};\r\nstatic const struct ov_i2c_regvals sensor_ov7660[2][3] = {\r\n{{0x12, 0x00}, {0x24, 0x00}, {0x0c, 0x0c}},\r\n{{0x12, 0x00}, {0x04, 0x00}, {0x0c, 0x00}}\r\n};\r\nstatic const struct ov_i2c_regvals sensor_ov7660_2[] = {\r\n{OV7670_R17_HSTART, 0x13},\r\n{OV7670_R18_HSTOP, 0x01},\r\n{OV7670_R32_HREF, 0x92},\r\n{OV7670_R19_VSTART, 0x02},\r\n{OV7670_R1A_VSTOP, 0x7a},\r\n{OV7670_R03_VREF, 0x00},\r\n};\r\nwrite_regvals(sd, bridge_ov7660[sd->gspca_dev.curr_mode],\r\nARRAY_SIZE(bridge_ov7660[0]));\r\nwrite_i2c_regvals(sd, sensor_ov7660[sd->gspca_dev.curr_mode],\r\nARRAY_SIZE(sensor_ov7660[0]));\r\nwrite_i2c_regvals(sd, sensor_ov7660_2,\r\nARRAY_SIZE(sensor_ov7660_2));\r\n}\r\nstatic void ov519_set_fr(struct sd *sd)\r\n{\r\nint fr;\r\nu8 clock;\r\nstatic const u8 fr_tb[2][6][3] = {\r\n{{0x04, 0xff, 0x00},\r\n{0x04, 0x1f, 0x00},\r\n{0x04, 0x1b, 0x00},\r\n{0x04, 0x15, 0x00},\r\n{0x04, 0x09, 0x00},\r\n{0x04, 0x01, 0x00}},\r\n{{0x0c, 0xff, 0x00},\r\n{0x0c, 0x1f, 0x00},\r\n{0x0c, 0x1b, 0x00},\r\n{0x04, 0xff, 0x01},\r\n{0x04, 0x1f, 0x01},\r\n{0x04, 0x1b, 0x01}},\r\n};\r\nif (frame_rate > 0)\r\nsd->frame_rate = frame_rate;\r\nif (sd->frame_rate >= 30)\r\nfr = 0;\r\nelse if (sd->frame_rate >= 25)\r\nfr = 1;\r\nelse if (sd->frame_rate >= 20)\r\nfr = 2;\r\nelse if (sd->frame_rate >= 15)\r\nfr = 3;\r\nelse if (sd->frame_rate >= 10)\r\nfr = 4;\r\nelse\r\nfr = 5;\r\nreg_w(sd, 0xa4, fr_tb[sd->gspca_dev.curr_mode][fr][0]);\r\nreg_w(sd, 0x23, fr_tb[sd->gspca_dev.curr_mode][fr][1]);\r\nclock = fr_tb[sd->gspca_dev.curr_mode][fr][2];\r\nif (sd->sensor == SEN_OV7660)\r\nclock |= 0x80;\r\nov518_i2c_w(sd, OV7670_R11_CLKRC, clock);\r\n}\r\nstatic void setautogain(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ni2c_w_mask(sd, 0x13, sd->ctrls[AUTOGAIN].val ? 0x05 : 0x00, 0x05);\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam = &gspca_dev->cam;\r\nsd->bridge = id->driver_info & BRIDGE_MASK;\r\nsd->invert_led = (id->driver_info & BRIDGE_INVERT_LED) != 0;\r\nswitch (sd->bridge) {\r\ncase BRIDGE_OV511:\r\ncase BRIDGE_OV511PLUS:\r\ncam->cam_mode = ov511_vga_mode;\r\ncam->nmodes = ARRAY_SIZE(ov511_vga_mode);\r\nbreak;\r\ncase BRIDGE_OV518:\r\ncase BRIDGE_OV518PLUS:\r\ncam->cam_mode = ov518_vga_mode;\r\ncam->nmodes = ARRAY_SIZE(ov518_vga_mode);\r\nbreak;\r\ncase BRIDGE_OV519:\r\ncam->cam_mode = ov519_vga_mode;\r\ncam->nmodes = ARRAY_SIZE(ov519_vga_mode);\r\nbreak;\r\ncase BRIDGE_OVFX2:\r\ncam->cam_mode = ov519_vga_mode;\r\ncam->nmodes = ARRAY_SIZE(ov519_vga_mode);\r\ncam->bulk_size = OVFX2_BULK_SIZE;\r\ncam->bulk_nurbs = MAX_NURBS;\r\ncam->bulk = 1;\r\nbreak;\r\ncase BRIDGE_W9968CF:\r\ncam->cam_mode = w9968cf_vga_mode;\r\ncam->nmodes = ARRAY_SIZE(w9968cf_vga_mode);\r\nbreak;\r\n}\r\ngspca_dev->cam.ctrls = sd->ctrls;\r\nsd->quality = QUALITY_DEF;\r\nsd->frame_rate = 15;\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam = &gspca_dev->cam;\r\nswitch (sd->bridge) {\r\ncase BRIDGE_OV511:\r\ncase BRIDGE_OV511PLUS:\r\nov511_configure(gspca_dev);\r\nbreak;\r\ncase BRIDGE_OV518:\r\ncase BRIDGE_OV518PLUS:\r\nov518_configure(gspca_dev);\r\nbreak;\r\ncase BRIDGE_OV519:\r\nov519_configure(sd);\r\nbreak;\r\ncase BRIDGE_OVFX2:\r\novfx2_configure(sd);\r\nbreak;\r\ncase BRIDGE_W9968CF:\r\nw9968cf_configure(sd);\r\nbreak;\r\n}\r\nsd->sensor = -1;\r\nif (init_ov_sensor(sd, OV7xx0_SID) >= 0) {\r\nov7xx0_configure(sd);\r\n} else if (init_ov_sensor(sd, OV6xx0_SID) >= 0) {\r\nov6xx0_configure(sd);\r\n} else if (init_ov_sensor(sd, OV8xx0_SID) >= 0) {\r\nov8xx0_configure(sd);\r\n} else if (init_ov_sensor(sd, OV_HIRES_SID) >= 0) {\r\nov_hires_configure(sd);\r\n} else {\r\npr_err("Can't determine sensor slave IDs\n");\r\ngoto error;\r\n}\r\nif (sd->sensor < 0)\r\ngoto error;\r\nov51x_led_control(sd, 0);\r\nswitch (sd->bridge) {\r\ncase BRIDGE_OV511:\r\ncase BRIDGE_OV511PLUS:\r\nif (sd->sif) {\r\ncam->cam_mode = ov511_sif_mode;\r\ncam->nmodes = ARRAY_SIZE(ov511_sif_mode);\r\n}\r\nbreak;\r\ncase BRIDGE_OV518:\r\ncase BRIDGE_OV518PLUS:\r\nif (sd->sif) {\r\ncam->cam_mode = ov518_sif_mode;\r\ncam->nmodes = ARRAY_SIZE(ov518_sif_mode);\r\n}\r\nbreak;\r\ncase BRIDGE_OV519:\r\nif (sd->sif) {\r\ncam->cam_mode = ov519_sif_mode;\r\ncam->nmodes = ARRAY_SIZE(ov519_sif_mode);\r\n}\r\nbreak;\r\ncase BRIDGE_OVFX2:\r\nswitch (sd->sensor) {\r\ncase SEN_OV2610:\r\ncase SEN_OV2610AE:\r\ncam->cam_mode = ovfx2_ov2610_mode;\r\ncam->nmodes = ARRAY_SIZE(ovfx2_ov2610_mode);\r\nbreak;\r\ncase SEN_OV3610:\r\ncam->cam_mode = ovfx2_ov3610_mode;\r\ncam->nmodes = ARRAY_SIZE(ovfx2_ov3610_mode);\r\nbreak;\r\ncase SEN_OV9600:\r\ncam->cam_mode = ovfx2_ov9600_mode;\r\ncam->nmodes = ARRAY_SIZE(ovfx2_ov9600_mode);\r\nbreak;\r\ndefault:\r\nif (sd->sif) {\r\ncam->cam_mode = ov519_sif_mode;\r\ncam->nmodes = ARRAY_SIZE(ov519_sif_mode);\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ncase BRIDGE_W9968CF:\r\nif (sd->sif)\r\ncam->nmodes = ARRAY_SIZE(w9968cf_vga_mode) - 1;\r\nw9968cf_init(sd);\r\nbreak;\r\n}\r\ngspca_dev->ctrl_dis = ctrl_dis[sd->sensor];\r\nswitch (sd->sensor) {\r\ncase SEN_OV2610:\r\nwrite_i2c_regvals(sd, norm_2610, ARRAY_SIZE(norm_2610));\r\ni2c_w_mask(sd, 0x13, 0x27, 0x27);\r\nbreak;\r\ncase SEN_OV2610AE:\r\nwrite_i2c_regvals(sd, norm_2610ae, ARRAY_SIZE(norm_2610ae));\r\ni2c_w_mask(sd, 0x13, 0x05, 0x05);\r\nbreak;\r\ncase SEN_OV3610:\r\nwrite_i2c_regvals(sd, norm_3620b, ARRAY_SIZE(norm_3620b));\r\ni2c_w_mask(sd, 0x13, 0x27, 0x27);\r\nbreak;\r\ncase SEN_OV6620:\r\nwrite_i2c_regvals(sd, norm_6x20, ARRAY_SIZE(norm_6x20));\r\nbreak;\r\ncase SEN_OV6630:\r\ncase SEN_OV66308AF:\r\nsd->ctrls[CONTRAST].def = 200;\r\nwrite_i2c_regvals(sd, norm_6x30, ARRAY_SIZE(norm_6x30));\r\nbreak;\r\ndefault:\r\nwrite_i2c_regvals(sd, norm_7610, ARRAY_SIZE(norm_7610));\r\ni2c_w_mask(sd, 0x0e, 0x00, 0x40);\r\nbreak;\r\ncase SEN_OV7620:\r\ncase SEN_OV7620AE:\r\nwrite_i2c_regvals(sd, norm_7620, ARRAY_SIZE(norm_7620));\r\nbreak;\r\ncase SEN_OV7640:\r\ncase SEN_OV7648:\r\nwrite_i2c_regvals(sd, norm_7640, ARRAY_SIZE(norm_7640));\r\nbreak;\r\ncase SEN_OV7660:\r\ni2c_w(sd, OV7670_R12_COM7, OV7670_COM7_RESET);\r\nmsleep(14);\r\nreg_w(sd, OV519_R57_SNAPSHOT, 0x23);\r\nwrite_regvals(sd, init_519_ov7660,\r\nARRAY_SIZE(init_519_ov7660));\r\nwrite_i2c_regvals(sd, norm_7660, ARRAY_SIZE(norm_7660));\r\nsd->gspca_dev.curr_mode = 1;\r\nov519_set_mode(sd);\r\nov519_set_fr(sd);\r\nsd->ctrls[COLORS].max = 4;\r\nsd->ctrls[COLORS].val =\r\nsd->ctrls[COLORS].def = 2;\r\nsetcolors(gspca_dev);\r\nsd->ctrls[CONTRAST].max = 6;\r\nsd->ctrls[CONTRAST].val =\r\nsd->ctrls[CONTRAST].def = 3;\r\nsetcontrast(gspca_dev);\r\nsd->ctrls[BRIGHTNESS].max = 6;\r\nsd->ctrls[BRIGHTNESS].val =\r\nsd->ctrls[BRIGHTNESS].def = 3;\r\nsetbrightness(gspca_dev);\r\nsd_reset_snapshot(gspca_dev);\r\nov51x_restart(sd);\r\nov51x_stop(sd);\r\nov51x_led_control(sd, 0);\r\nbreak;\r\ncase SEN_OV7670:\r\nsd->ctrls[FREQ].max = 3;\r\nsd->ctrls[FREQ].def = 3;\r\nwrite_i2c_regvals(sd, norm_7670, ARRAY_SIZE(norm_7670));\r\nbreak;\r\ncase SEN_OV8610:\r\nwrite_i2c_regvals(sd, norm_8610, ARRAY_SIZE(norm_8610));\r\nbreak;\r\ncase SEN_OV9600:\r\nwrite_i2c_regvals(sd, norm_9600, ARRAY_SIZE(norm_9600));\r\nbreak;\r\n}\r\nreturn gspca_dev->usb_err;\r\nerror:\r\nPDEBUG(D_ERR, "OV519 Config failed");\r\nreturn -EINVAL;\r\n}\r\nstatic int sd_isoc_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nswitch (sd->bridge) {\r\ncase BRIDGE_OVFX2:\r\nif (gspca_dev->width != 800)\r\ngspca_dev->cam.bulk_size = OVFX2_BULK_SIZE;\r\nelse\r\ngspca_dev->cam.bulk_size = 7 * 4096;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ov511_mode_init_regs(struct sd *sd)\r\n{\r\nint hsegs, vsegs, packet_size, fps, needed;\r\nint interlaced = 0;\r\nstruct usb_host_interface *alt;\r\nstruct usb_interface *intf;\r\nintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\r\nalt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\r\nif (!alt) {\r\npr_err("Couldn't get altsetting\n");\r\nsd->gspca_dev.usb_err = -EIO;\r\nreturn;\r\n}\r\npacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\r\nreg_w(sd, R51x_FIFO_PSIZE, packet_size >> 5);\r\nreg_w(sd, R511_CAM_UV_EN, 0x01);\r\nreg_w(sd, R511_SNAP_UV_EN, 0x01);\r\nreg_w(sd, R511_SNAP_OPTS, 0x03);\r\nhsegs = (sd->gspca_dev.width >> 3) - 1;\r\nvsegs = (sd->gspca_dev.height >> 3) - 1;\r\nreg_w(sd, R511_CAM_PXCNT, hsegs);\r\nreg_w(sd, R511_CAM_LNCNT, vsegs);\r\nreg_w(sd, R511_CAM_PXDIV, 0x00);\r\nreg_w(sd, R511_CAM_LNDIV, 0x00);\r\nreg_w(sd, R511_CAM_OPTS, 0x03);\r\nreg_w(sd, R511_SNAP_PXCNT, hsegs);\r\nreg_w(sd, R511_SNAP_LNCNT, vsegs);\r\nreg_w(sd, R511_SNAP_PXDIV, 0x00);\r\nreg_w(sd, R511_SNAP_LNDIV, 0x00);\r\nif (frame_rate > 0)\r\nsd->frame_rate = frame_rate;\r\nswitch (sd->sensor) {\r\ncase SEN_OV6620:\r\nsd->clockdiv = 3;\r\nbreak;\r\ncase SEN_OV7620:\r\ncase SEN_OV7620AE:\r\ncase SEN_OV7640:\r\ncase SEN_OV7648:\r\ncase SEN_OV76BE:\r\nif (sd->gspca_dev.width == 320)\r\ninterlaced = 1;\r\ncase SEN_OV6630:\r\ncase SEN_OV7610:\r\ncase SEN_OV7670:\r\nswitch (sd->frame_rate) {\r\ncase 30:\r\ncase 25:\r\nif (sd->gspca_dev.width != 640) {\r\nsd->clockdiv = 0;\r\nbreak;\r\n}\r\ndefault:\r\nsd->clockdiv = 1;\r\nbreak;\r\ncase 10:\r\nsd->clockdiv = 2;\r\nbreak;\r\ncase 5:\r\nsd->clockdiv = 5;\r\nbreak;\r\n}\r\nif (interlaced) {\r\nsd->clockdiv = (sd->clockdiv + 1) * 2 - 1;\r\nif (sd->clockdiv > 10)\r\nsd->clockdiv = 10;\r\n}\r\nbreak;\r\ncase SEN_OV8610:\r\nsd->clockdiv = 0;\r\nbreak;\r\n}\r\nfps = (interlaced ? 60 : 30) / (sd->clockdiv + 1) + 1;\r\nneeded = fps * sd->gspca_dev.width * sd->gspca_dev.height * 3 / 2;\r\nif (needed > 1000 * packet_size) {\r\nreg_w(sd, R511_COMP_EN, 0x07);\r\nreg_w(sd, R511_COMP_LUT_EN, 0x03);\r\n} else {\r\nreg_w(sd, R511_COMP_EN, 0x06);\r\nreg_w(sd, R511_COMP_LUT_EN, 0x00);\r\n}\r\nreg_w(sd, R51x_SYS_RESET, OV511_RESET_OMNICE);\r\nreg_w(sd, R51x_SYS_RESET, 0);\r\n}\r\nstatic void ov518_mode_init_regs(struct sd *sd)\r\n{\r\nint hsegs, vsegs, packet_size;\r\nstruct usb_host_interface *alt;\r\nstruct usb_interface *intf;\r\nintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\r\nalt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\r\nif (!alt) {\r\npr_err("Couldn't get altsetting\n");\r\nsd->gspca_dev.usb_err = -EIO;\r\nreturn;\r\n}\r\npacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\r\nov518_reg_w32(sd, R51x_FIFO_PSIZE, packet_size & ~7, 2);\r\nreg_w(sd, 0x2b, 0);\r\nreg_w(sd, 0x2c, 0);\r\nreg_w(sd, 0x2d, 0);\r\nreg_w(sd, 0x2e, 0);\r\nreg_w(sd, 0x3b, 0);\r\nreg_w(sd, 0x3c, 0);\r\nreg_w(sd, 0x3d, 0);\r\nreg_w(sd, 0x3e, 0);\r\nif (sd->bridge == BRIDGE_OV518) {\r\nreg_w_mask(sd, 0x20, 0x08, 0x08);\r\nreg_w_mask(sd, 0x28, 0x80, 0xf0);\r\nreg_w_mask(sd, 0x38, 0x80, 0xf0);\r\n} else {\r\nreg_w(sd, 0x28, 0x80);\r\nreg_w(sd, 0x38, 0x80);\r\n}\r\nhsegs = sd->gspca_dev.width / 16;\r\nvsegs = sd->gspca_dev.height / 4;\r\nreg_w(sd, 0x29, hsegs);\r\nreg_w(sd, 0x2a, vsegs);\r\nreg_w(sd, 0x39, hsegs);\r\nreg_w(sd, 0x3a, vsegs);\r\nreg_w(sd, 0x2f, 0x80);\r\nsd->clockdiv = 1;\r\nreg_w(sd, 0x51, 0x04);\r\nreg_w(sd, 0x22, 0x18);\r\nreg_w(sd, 0x23, 0xff);\r\nif (sd->bridge == BRIDGE_OV518PLUS) {\r\nswitch (sd->sensor) {\r\ncase SEN_OV7620AE:\r\nif (sd->gspca_dev.width == 320) {\r\nreg_w(sd, 0x20, 0x00);\r\nreg_w(sd, 0x21, 0x19);\r\n} else {\r\nreg_w(sd, 0x20, 0x60);\r\nreg_w(sd, 0x21, 0x1f);\r\n}\r\nbreak;\r\ncase SEN_OV7620:\r\nreg_w(sd, 0x20, 0x00);\r\nreg_w(sd, 0x21, 0x19);\r\nbreak;\r\ndefault:\r\nreg_w(sd, 0x21, 0x19);\r\n}\r\n} else\r\nreg_w(sd, 0x71, 0x17);\r\ni2c_w(sd, 0x54, 0x23);\r\nreg_w(sd, 0x2f, 0x80);\r\nif (sd->bridge == BRIDGE_OV518PLUS) {\r\nreg_w(sd, 0x24, 0x94);\r\nreg_w(sd, 0x25, 0x90);\r\nov518_reg_w32(sd, 0xc4, 400, 2);\r\nov518_reg_w32(sd, 0xc6, 540, 2);\r\nov518_reg_w32(sd, 0xc7, 540, 2);\r\nov518_reg_w32(sd, 0xc8, 108, 2);\r\nov518_reg_w32(sd, 0xca, 131098, 3);\r\nov518_reg_w32(sd, 0xcb, 532, 2);\r\nov518_reg_w32(sd, 0xcc, 2400, 2);\r\nov518_reg_w32(sd, 0xcd, 32, 2);\r\nov518_reg_w32(sd, 0xce, 608, 2);\r\n} else {\r\nreg_w(sd, 0x24, 0x9f);\r\nreg_w(sd, 0x25, 0x90);\r\nov518_reg_w32(sd, 0xc4, 400, 2);\r\nov518_reg_w32(sd, 0xc6, 381, 2);\r\nov518_reg_w32(sd, 0xc7, 381, 2);\r\nov518_reg_w32(sd, 0xc8, 128, 2);\r\nov518_reg_w32(sd, 0xca, 183331, 3);\r\nov518_reg_w32(sd, 0xcb, 746, 2);\r\nov518_reg_w32(sd, 0xcc, 1750, 2);\r\nov518_reg_w32(sd, 0xcd, 45, 2);\r\nov518_reg_w32(sd, 0xce, 851, 2);\r\n}\r\nreg_w(sd, 0x2f, 0x80);\r\n}\r\nstatic void ov519_mode_init_regs(struct sd *sd)\r\n{\r\nstatic const struct ov_regvals mode_init_519_ov7670[] = {\r\n{ 0x5d, 0x03 },\r\n{ 0x53, 0x9f },\r\n{ OV519_R54_EN_CLK1, 0x0f },\r\n{ 0xa2, 0x20 },\r\n{ 0xa3, 0x18 },\r\n{ 0xa4, 0x04 },\r\n{ 0xa5, 0x28 },\r\n{ 0x37, 0x00 },\r\n{ 0x55, 0x02 },\r\n{ 0x20, 0x0c },\r\n{ 0x21, 0x38 },\r\n{ 0x22, 0x1d },\r\n{ 0x17, 0x50 },\r\n{ 0x37, 0x00 },\r\n{ 0x40, 0xff },\r\n{ 0x46, 0x00 },\r\n{ 0x59, 0x04 },\r\n{ 0xff, 0x00 },\r\n};\r\nstatic const struct ov_regvals mode_init_519[] = {\r\n{ 0x5d, 0x03 },\r\n{ 0x53, 0x9f },\r\n{ OV519_R54_EN_CLK1, 0x0f },\r\n{ 0xa2, 0x20 },\r\n{ 0xa3, 0x18 },\r\n{ 0xa4, 0x04 },\r\n{ 0xa5, 0x28 },\r\n{ 0x37, 0x00 },\r\n{ 0x55, 0x02 },\r\n{ 0x22, 0x1d },\r\n{ 0x17, 0x50 },\r\n{ 0x37, 0x00 },\r\n{ 0x40, 0xff },\r\n{ 0x46, 0x00 },\r\n{ 0x59, 0x04 },\r\n{ 0xff, 0x00 },\r\n};\r\nswitch (sd->sensor) {\r\ndefault:\r\nwrite_regvals(sd, mode_init_519, ARRAY_SIZE(mode_init_519));\r\nif (sd->sensor == SEN_OV7640 ||\r\nsd->sensor == SEN_OV7648) {\r\nreg_w_mask(sd, OV519_R20_DFR, 0x10, 0x10);\r\n}\r\nbreak;\r\ncase SEN_OV7660:\r\nreturn;\r\ncase SEN_OV7670:\r\nwrite_regvals(sd, mode_init_519_ov7670,\r\nARRAY_SIZE(mode_init_519_ov7670));\r\nbreak;\r\n}\r\nreg_w(sd, OV519_R10_H_SIZE, sd->gspca_dev.width >> 4);\r\nreg_w(sd, OV519_R11_V_SIZE, sd->gspca_dev.height >> 3);\r\nif (sd->sensor == SEN_OV7670 &&\r\nsd->gspca_dev.cam.cam_mode[sd->gspca_dev.curr_mode].priv)\r\nreg_w(sd, OV519_R12_X_OFFSETL, 0x04);\r\nelse if (sd->sensor == SEN_OV7648 &&\r\nsd->gspca_dev.cam.cam_mode[sd->gspca_dev.curr_mode].priv)\r\nreg_w(sd, OV519_R12_X_OFFSETL, 0x01);\r\nelse\r\nreg_w(sd, OV519_R12_X_OFFSETL, 0x00);\r\nreg_w(sd, OV519_R13_X_OFFSETH, 0x00);\r\nreg_w(sd, OV519_R14_Y_OFFSETL, 0x00);\r\nreg_w(sd, OV519_R15_Y_OFFSETH, 0x00);\r\nreg_w(sd, OV519_R16_DIVIDER, 0x00);\r\nreg_w(sd, OV519_R25_FORMAT, 0x03);\r\nreg_w(sd, 0x26, 0x00);\r\nif (frame_rate > 0)\r\nsd->frame_rate = frame_rate;\r\nsd->clockdiv = 0;\r\nswitch (sd->sensor) {\r\ncase SEN_OV7640:\r\ncase SEN_OV7648:\r\nswitch (sd->frame_rate) {\r\ndefault:\r\nreg_w(sd, 0xa4, 0x0c);\r\nreg_w(sd, 0x23, 0xff);\r\nbreak;\r\ncase 25:\r\nreg_w(sd, 0xa4, 0x0c);\r\nreg_w(sd, 0x23, 0x1f);\r\nbreak;\r\ncase 20:\r\nreg_w(sd, 0xa4, 0x0c);\r\nreg_w(sd, 0x23, 0x1b);\r\nbreak;\r\ncase 15:\r\nreg_w(sd, 0xa4, 0x04);\r\nreg_w(sd, 0x23, 0xff);\r\nsd->clockdiv = 1;\r\nbreak;\r\ncase 10:\r\nreg_w(sd, 0xa4, 0x04);\r\nreg_w(sd, 0x23, 0x1f);\r\nsd->clockdiv = 1;\r\nbreak;\r\ncase 5:\r\nreg_w(sd, 0xa4, 0x04);\r\nreg_w(sd, 0x23, 0x1b);\r\nsd->clockdiv = 1;\r\nbreak;\r\n}\r\nbreak;\r\ncase SEN_OV8610:\r\nswitch (sd->frame_rate) {\r\ndefault:\r\nreg_w(sd, 0xa4, 0x06);\r\nreg_w(sd, 0x23, 0xff);\r\nbreak;\r\ncase 10:\r\nreg_w(sd, 0xa4, 0x06);\r\nreg_w(sd, 0x23, 0x1f);\r\nbreak;\r\ncase 5:\r\nreg_w(sd, 0xa4, 0x06);\r\nreg_w(sd, 0x23, 0x1b);\r\nbreak;\r\n}\r\nbreak;\r\ncase SEN_OV7670:\r\nPDEBUG(D_STREAM, "Setting framerate to %d fps",\r\n(sd->frame_rate == 0) ? 15 : sd->frame_rate);\r\nreg_w(sd, 0xa4, 0x10);\r\nswitch (sd->frame_rate) {\r\ncase 30:\r\nreg_w(sd, 0x23, 0xff);\r\nbreak;\r\ncase 20:\r\nreg_w(sd, 0x23, 0x1b);\r\nbreak;\r\ndefault:\r\nreg_w(sd, 0x23, 0xff);\r\nsd->clockdiv = 1;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void mode_init_ov_sensor_regs(struct sd *sd)\r\n{\r\nstruct gspca_dev *gspca_dev;\r\nint qvga, xstart, xend, ystart, yend;\r\nu8 v;\r\ngspca_dev = &sd->gspca_dev;\r\nqvga = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv & 1;\r\nswitch (sd->sensor) {\r\ncase SEN_OV2610:\r\ni2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\r\ni2c_w_mask(sd, 0x28, qvga ? 0x00 : 0x20, 0x20);\r\ni2c_w(sd, 0x24, qvga ? 0x20 : 0x3a);\r\ni2c_w(sd, 0x25, qvga ? 0x30 : 0x60);\r\ni2c_w_mask(sd, 0x2d, qvga ? 0x40 : 0x00, 0x40);\r\ni2c_w_mask(sd, 0x67, qvga ? 0xf0 : 0x90, 0xf0);\r\ni2c_w_mask(sd, 0x74, qvga ? 0x20 : 0x00, 0x20);\r\nreturn;\r\ncase SEN_OV2610AE: {\r\nu8 v;\r\nv = 80;\r\nif (qvga) {\r\nif (sd->frame_rate < 25)\r\nv = 0x81;\r\n} else {\r\nif (sd->frame_rate < 10)\r\nv = 0x81;\r\n}\r\ni2c_w(sd, 0x11, v);\r\ni2c_w(sd, 0x12, qvga ? 0x60 : 0x20);\r\nreturn;\r\n}\r\ncase SEN_OV3610:\r\nif (qvga) {\r\nxstart = (1040 - gspca_dev->width) / 2 + (0x1f << 4);\r\nystart = (776 - gspca_dev->height) / 2;\r\n} else {\r\nxstart = (2076 - gspca_dev->width) / 2 + (0x10 << 4);\r\nystart = (1544 - gspca_dev->height) / 2;\r\n}\r\nxend = xstart + gspca_dev->width;\r\nyend = ystart + gspca_dev->height;\r\ni2c_w_mask(sd, 0x12, qvga ? 0x40 : 0x00, 0xf0);\r\ni2c_w_mask(sd, 0x32,\r\n(((xend >> 1) & 7) << 3) | ((xstart >> 1) & 7),\r\n0x3f);\r\ni2c_w_mask(sd, 0x03,\r\n(((yend >> 1) & 3) << 2) | ((ystart >> 1) & 3),\r\n0x0f);\r\ni2c_w(sd, 0x17, xstart >> 4);\r\ni2c_w(sd, 0x18, xend >> 4);\r\ni2c_w(sd, 0x19, ystart >> 3);\r\ni2c_w(sd, 0x1a, yend >> 3);\r\nreturn;\r\ncase SEN_OV8610:\r\ni2c_w_mask(sd, OV7610_REG_COM_C, qvga ? (1 << 5) : 0, 1 << 5);\r\ni2c_w_mask(sd, 0x13, 0x00, 0x20);\r\ni2c_w_mask(sd, 0x12, 0x04, 0x06);\r\ni2c_w_mask(sd, 0x2d, 0x00, 0x40);\r\ni2c_w_mask(sd, 0x28, 0x20, 0x20);\r\nbreak;\r\ncase SEN_OV7610:\r\ni2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\r\ni2c_w(sd, 0x35, qvga ? 0x1e : 0x9e);\r\ni2c_w_mask(sd, 0x13, 0x00, 0x20);\r\ni2c_w_mask(sd, 0x12, 0x04, 0x06);\r\nbreak;\r\ncase SEN_OV7620:\r\ncase SEN_OV7620AE:\r\ncase SEN_OV76BE:\r\ni2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\r\ni2c_w_mask(sd, 0x28, qvga ? 0x00 : 0x20, 0x20);\r\ni2c_w(sd, 0x24, qvga ? 0x20 : 0x3a);\r\ni2c_w(sd, 0x25, qvga ? 0x30 : 0x60);\r\ni2c_w_mask(sd, 0x2d, qvga ? 0x40 : 0x00, 0x40);\r\ni2c_w_mask(sd, 0x67, qvga ? 0xb0 : 0x90, 0xf0);\r\ni2c_w_mask(sd, 0x74, qvga ? 0x20 : 0x00, 0x20);\r\ni2c_w_mask(sd, 0x13, 0x00, 0x20);\r\ni2c_w_mask(sd, 0x12, 0x04, 0x06);\r\nif (sd->sensor == SEN_OV76BE)\r\ni2c_w(sd, 0x35, qvga ? 0x1e : 0x9e);\r\nbreak;\r\ncase SEN_OV7640:\r\ncase SEN_OV7648:\r\ni2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\r\ni2c_w_mask(sd, 0x28, qvga ? 0x00 : 0x20, 0x20);\r\ni2c_w_mask(sd, 0x2d, qvga ? 0x40 : 0x00, 0x40);\r\ni2c_w_mask(sd, 0x67, qvga ? 0xf0 : 0x90, 0xf0);\r\ni2c_w_mask(sd, 0x74, qvga ? 0x20 : 0x00, 0x20);\r\ni2c_w_mask(sd, 0x12, 0x04, 0x04);\r\nbreak;\r\ncase SEN_OV7670:\r\ni2c_w_mask(sd, OV7670_R12_COM7,\r\nqvga ? OV7670_COM7_FMT_QVGA : OV7670_COM7_FMT_VGA,\r\nOV7670_COM7_FMT_MASK);\r\ni2c_w_mask(sd, 0x13, 0x00, 0x20);\r\ni2c_w_mask(sd, OV7670_R13_COM8, OV7670_COM8_AWB,\r\nOV7670_COM8_AWB);\r\nif (qvga) {\r\nxstart = 164;\r\nxend = 28;\r\nystart = 14;\r\nyend = 494;\r\n} else {\r\nxstart = 158;\r\nxend = 14;\r\nystart = 10;\r\nyend = 490;\r\n}\r\ni2c_w(sd, OV7670_R17_HSTART, xstart >> 3);\r\ni2c_w(sd, OV7670_R18_HSTOP, xend >> 3);\r\nv = i2c_r(sd, OV7670_R32_HREF);\r\nv = (v & 0xc0) | ((xend & 0x7) << 3) | (xstart & 0x07);\r\nmsleep(10);\r\ni2c_w(sd, OV7670_R32_HREF, v);\r\ni2c_w(sd, OV7670_R19_VSTART, ystart >> 2);\r\ni2c_w(sd, OV7670_R1A_VSTOP, yend >> 2);\r\nv = i2c_r(sd, OV7670_R03_VREF);\r\nv = (v & 0xc0) | ((yend & 0x3) << 2) | (ystart & 0x03);\r\nmsleep(10);\r\ni2c_w(sd, OV7670_R03_VREF, v);\r\nbreak;\r\ncase SEN_OV6620:\r\ni2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\r\ni2c_w_mask(sd, 0x13, 0x00, 0x20);\r\ni2c_w_mask(sd, 0x12, 0x04, 0x06);\r\nbreak;\r\ncase SEN_OV6630:\r\ncase SEN_OV66308AF:\r\ni2c_w_mask(sd, 0x14, qvga ? 0x20 : 0x00, 0x20);\r\ni2c_w_mask(sd, 0x12, 0x04, 0x06);\r\nbreak;\r\ncase SEN_OV9600: {\r\nconst struct ov_i2c_regvals *vals;\r\nstatic const struct ov_i2c_regvals sxga_15[] = {\r\n{0x11, 0x80}, {0x14, 0x3e}, {0x24, 0x85}, {0x25, 0x75}\r\n};\r\nstatic const struct ov_i2c_regvals sxga_7_5[] = {\r\n{0x11, 0x81}, {0x14, 0x3e}, {0x24, 0x85}, {0x25, 0x75}\r\n};\r\nstatic const struct ov_i2c_regvals vga_30[] = {\r\n{0x11, 0x81}, {0x14, 0x7e}, {0x24, 0x70}, {0x25, 0x60}\r\n};\r\nstatic const struct ov_i2c_regvals vga_15[] = {\r\n{0x11, 0x83}, {0x14, 0x3e}, {0x24, 0x80}, {0x25, 0x70}\r\n};\r\ni2c_w_mask(sd, 0x12, qvga ? 0x40 : 0x00, 0x40);\r\nif (qvga)\r\nvals = sd->frame_rate < 30 ? vga_15 : vga_30;\r\nelse\r\nvals = sd->frame_rate < 15 ? sxga_7_5 : sxga_15;\r\nwrite_i2c_regvals(sd, vals, ARRAY_SIZE(sxga_15));\r\nreturn;\r\n}\r\ndefault:\r\nreturn;\r\n}\r\ni2c_w(sd, 0x11, sd->clockdiv);\r\n}\r\nstatic void sethvflip(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->gspca_dev.streaming)\r\nreg_w(sd, OV519_R51_RESET1, 0x0f);\r\ni2c_w_mask(sd, OV7670_R1E_MVFP,\r\nOV7670_MVFP_MIRROR * sd->ctrls[HFLIP].val\r\n| OV7670_MVFP_VFLIP * sd->ctrls[VFLIP].val,\r\nOV7670_MVFP_MIRROR | OV7670_MVFP_VFLIP);\r\nif (sd->gspca_dev.streaming)\r\nreg_w(sd, OV519_R51_RESET1, 0x00);\r\n}\r\nstatic void set_ov_sensor_window(struct sd *sd)\r\n{\r\nstruct gspca_dev *gspca_dev;\r\nint qvga, crop;\r\nint hwsbase, hwebase, vwsbase, vwebase, hwscale, vwscale;\r\nswitch (sd->sensor) {\r\ncase SEN_OV2610:\r\ncase SEN_OV2610AE:\r\ncase SEN_OV3610:\r\ncase SEN_OV7670:\r\ncase SEN_OV9600:\r\nmode_init_ov_sensor_regs(sd);\r\nreturn;\r\ncase SEN_OV7660:\r\nov519_set_mode(sd);\r\nov519_set_fr(sd);\r\nreturn;\r\n}\r\ngspca_dev = &sd->gspca_dev;\r\nqvga = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv & 1;\r\ncrop = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv & 2;\r\nswitch (sd->sensor) {\r\ncase SEN_OV8610:\r\nhwsbase = 0x1e;\r\nhwebase = 0x1e;\r\nvwsbase = 0x02;\r\nvwebase = 0x02;\r\nbreak;\r\ncase SEN_OV7610:\r\ncase SEN_OV76BE:\r\nhwsbase = 0x38;\r\nhwebase = 0x3a;\r\nvwsbase = vwebase = 0x05;\r\nbreak;\r\ncase SEN_OV6620:\r\ncase SEN_OV6630:\r\ncase SEN_OV66308AF:\r\nhwsbase = 0x38;\r\nhwebase = 0x3a;\r\nvwsbase = 0x05;\r\nvwebase = 0x06;\r\nif (sd->sensor == SEN_OV66308AF && qvga)\r\nhwsbase++;\r\nif (crop) {\r\nhwsbase += 8;\r\nhwebase += 8;\r\nvwsbase += 11;\r\nvwebase += 11;\r\n}\r\nbreak;\r\ncase SEN_OV7620:\r\ncase SEN_OV7620AE:\r\nhwsbase = 0x2f;\r\nhwebase = 0x2f;\r\nvwsbase = vwebase = 0x05;\r\nbreak;\r\ncase SEN_OV7640:\r\ncase SEN_OV7648:\r\nhwsbase = 0x1a;\r\nhwebase = 0x1a;\r\nvwsbase = vwebase = 0x03;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nswitch (sd->sensor) {\r\ncase SEN_OV6620:\r\ncase SEN_OV6630:\r\ncase SEN_OV66308AF:\r\nif (qvga) {\r\nhwscale = 0;\r\nvwscale = 0;\r\n} else {\r\nhwscale = 1;\r\nvwscale = 1;\r\n}\r\nbreak;\r\ncase SEN_OV8610:\r\nif (qvga) {\r\nhwscale = 1;\r\nvwscale = 1;\r\n} else {\r\nhwscale = 2;\r\nvwscale = 2;\r\n}\r\nbreak;\r\ndefault:\r\nif (qvga) {\r\nhwscale = 1;\r\nvwscale = 0;\r\n} else {\r\nhwscale = 2;\r\nvwscale = 1;\r\n}\r\n}\r\nmode_init_ov_sensor_regs(sd);\r\ni2c_w(sd, 0x17, hwsbase);\r\ni2c_w(sd, 0x18, hwebase + (sd->sensor_width >> hwscale));\r\ni2c_w(sd, 0x19, vwsbase);\r\ni2c_w(sd, 0x1a, vwebase + (sd->sensor_height >> vwscale));\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->sensor_width = sd->gspca_dev.width;\r\nsd->sensor_height = sd->gspca_dev.height;\r\nswitch (sd->bridge) {\r\ncase BRIDGE_OV511:\r\ncase BRIDGE_OV511PLUS:\r\nov511_mode_init_regs(sd);\r\nbreak;\r\ncase BRIDGE_OV518:\r\ncase BRIDGE_OV518PLUS:\r\nov518_mode_init_regs(sd);\r\nbreak;\r\ncase BRIDGE_OV519:\r\nov519_mode_init_regs(sd);\r\nbreak;\r\ncase BRIDGE_W9968CF:\r\nw9968cf_mode_init_regs(sd);\r\nbreak;\r\n}\r\nset_ov_sensor_window(sd);\r\nif (!(sd->gspca_dev.ctrl_dis & (1 << CONTRAST)))\r\nsetcontrast(gspca_dev);\r\nif (!(sd->gspca_dev.ctrl_dis & (1 << BRIGHTNESS)))\r\nsetbrightness(gspca_dev);\r\nif (!(sd->gspca_dev.ctrl_dis & (1 << EXPOSURE)))\r\nsetexposure(gspca_dev);\r\nif (!(sd->gspca_dev.ctrl_dis & (1 << COLORS)))\r\nsetcolors(gspca_dev);\r\nif (!(sd->gspca_dev.ctrl_dis & ((1 << HFLIP) | (1 << VFLIP))))\r\nsethvflip(gspca_dev);\r\nif (!(sd->gspca_dev.ctrl_dis & (1 << AUTOBRIGHT)))\r\nsetautobright(gspca_dev);\r\nif (!(sd->gspca_dev.ctrl_dis & (1 << AUTOGAIN)))\r\nsetautogain(gspca_dev);\r\nif (!(sd->gspca_dev.ctrl_dis & (1 << FREQ)))\r\nsetfreq_i(sd);\r\nsd->snapshot_needs_reset = 1;\r\nsd_reset_snapshot(gspca_dev);\r\nsd->first_frame = 3;\r\nov51x_restart(sd);\r\nov51x_led_control(sd, 1);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nov51x_stop(sd);\r\nov51x_led_control(sd, 0);\r\n}\r\nstatic void sd_stop0(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (!sd->gspca_dev.present)\r\nreturn;\r\nif (sd->bridge == BRIDGE_W9968CF)\r\nw9968cf_stop0(sd);\r\n#if defined(CONFIG_INPUT) || defined(CONFIG_INPUT_MODULE)\r\nif (sd->snapshot_pressed) {\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\r\ninput_sync(gspca_dev->input_dev);\r\nsd->snapshot_pressed = 0;\r\n}\r\n#endif\r\nif (sd->bridge == BRIDGE_OV519)\r\nreg_w(sd, OV519_R57_SNAPSHOT, 0x23);\r\n}\r\nstatic void ov51x_handle_button(struct gspca_dev *gspca_dev, u8 state)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->snapshot_pressed != state) {\r\n#if defined(CONFIG_INPUT) || defined(CONFIG_INPUT_MODULE)\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, state);\r\ninput_sync(gspca_dev->input_dev);\r\n#endif\r\nif (state)\r\nsd->snapshot_needs_reset = 1;\r\nsd->snapshot_pressed = state;\r\n} else {\r\nswitch (sd->bridge) {\r\ncase BRIDGE_OV511:\r\ncase BRIDGE_OV511PLUS:\r\ncase BRIDGE_OV519:\r\nif (state)\r\nsd->snapshot_needs_reset = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void ov511_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *in,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (!(in[0] | in[1] | in[2] | in[3] | in[4] | in[5] | in[6] | in[7]) &&\r\n(in[8] & 0x08)) {\r\nov51x_handle_button(gspca_dev, (in[8] >> 2) & 1);\r\nif (in[8] & 0x80) {\r\nif ((in[9] + 1) * 8 != gspca_dev->width ||\r\n(in[10] + 1) * 8 != gspca_dev->height) {\r\nPDEBUG(D_ERR, "Invalid frame size, got: %dx%d,"\r\n" requested: %dx%d\n",\r\n(in[9] + 1) * 8, (in[10] + 1) * 8,\r\ngspca_dev->width, gspca_dev->height);\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\nreturn;\r\n}\r\ngspca_frame_add(gspca_dev, LAST_PACKET, in, 11);\r\nreturn;\r\n} else {\r\ngspca_frame_add(gspca_dev, FIRST_PACKET, in, 0);\r\nsd->packet_nr = 0;\r\n}\r\n}\r\nlen--;\r\ngspca_frame_add(gspca_dev, INTER_PACKET, in, len);\r\n}\r\nstatic void ov518_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif ((!(data[0] | data[1] | data[2] | data[3] | data[5])) && data[6]) {\r\nov51x_handle_button(gspca_dev, (data[6] >> 1) & 1);\r\ngspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\r\ngspca_frame_add(gspca_dev, FIRST_PACKET, NULL, 0);\r\nsd->packet_nr = 0;\r\n}\r\nif (gspca_dev->last_packet_type == DISCARD_PACKET)\r\nreturn;\r\nif (len & 7) {\r\nlen--;\r\nif (sd->packet_nr == data[len])\r\nsd->packet_nr++;\r\nelse if (sd->packet_nr == 0 || data[len]) {\r\nPDEBUG(D_ERR, "Invalid packet nr: %d (expect: %d)",\r\n(int)data[len], (int)sd->packet_nr);\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\nreturn;\r\n}\r\n}\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}\r\nstatic void ov519_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nif (data[0] == 0xff && data[1] == 0xff && data[2] == 0xff) {\r\nswitch (data[3]) {\r\ncase 0x50:\r\n#define HDRSZ 16\r\ndata += HDRSZ;\r\nlen -= HDRSZ;\r\n#undef HDRSZ\r\nif (data[0] == 0xff || data[1] == 0xd8)\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\ndata, len);\r\nelse\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\nreturn;\r\ncase 0x51:\r\nov51x_handle_button(gspca_dev, data[11] & 1);\r\nif (data[9] != 0)\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\nNULL, 0);\r\nreturn;\r\n}\r\n}\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n}\r\nstatic void ovfx2_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\nif (len < gspca_dev->cam.bulk_size) {\r\nif (sd->first_frame) {\r\nsd->first_frame--;\r\nif (gspca_dev->image_len <\r\nsd->gspca_dev.width * sd->gspca_dev.height)\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\n}\r\ngspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\r\ngspca_frame_add(gspca_dev, FIRST_PACKET, NULL, 0);\r\n}\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nswitch (sd->bridge) {\r\ncase BRIDGE_OV511:\r\ncase BRIDGE_OV511PLUS:\r\nov511_pkt_scan(gspca_dev, data, len);\r\nbreak;\r\ncase BRIDGE_OV518:\r\ncase BRIDGE_OV518PLUS:\r\nov518_pkt_scan(gspca_dev, data, len);\r\nbreak;\r\ncase BRIDGE_OV519:\r\nov519_pkt_scan(gspca_dev, data, len);\r\nbreak;\r\ncase BRIDGE_OVFX2:\r\novfx2_pkt_scan(gspca_dev, data, len);\r\nbreak;\r\ncase BRIDGE_W9968CF:\r\nw9968cf_pkt_scan(gspca_dev, data, len);\r\nbreak;\r\n}\r\n}\r\nstatic void setbrightness(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint val;\r\nstatic const struct ov_i2c_regvals brit_7660[][7] = {\r\n{{0x0f, 0x6a}, {0x24, 0x40}, {0x25, 0x2b}, {0x26, 0x90},\r\n{0x27, 0xe0}, {0x28, 0xe0}, {0x2c, 0xe0}},\r\n{{0x0f, 0x6a}, {0x24, 0x50}, {0x25, 0x40}, {0x26, 0xa1},\r\n{0x27, 0xc0}, {0x28, 0xc0}, {0x2c, 0xc0}},\r\n{{0x0f, 0x6a}, {0x24, 0x68}, {0x25, 0x58}, {0x26, 0xc2},\r\n{0x27, 0xa0}, {0x28, 0xa0}, {0x2c, 0xa0}},\r\n{{0x0f, 0x6a}, {0x24, 0x70}, {0x25, 0x68}, {0x26, 0xd3},\r\n{0x27, 0x80}, {0x28, 0x80}, {0x2c, 0x80}},\r\n{{0x0f, 0x6a}, {0x24, 0x80}, {0x25, 0x70}, {0x26, 0xd3},\r\n{0x27, 0x20}, {0x28, 0x20}, {0x2c, 0x20}},\r\n{{0x0f, 0x6a}, {0x24, 0x88}, {0x25, 0x78}, {0x26, 0xd3},\r\n{0x27, 0x40}, {0x28, 0x40}, {0x2c, 0x40}},\r\n{{0x0f, 0x6a}, {0x24, 0x90}, {0x25, 0x80}, {0x26, 0xd4},\r\n{0x27, 0x60}, {0x28, 0x60}, {0x2c, 0x60}}\r\n};\r\nval = sd->ctrls[BRIGHTNESS].val;\r\nswitch (sd->sensor) {\r\ncase SEN_OV8610:\r\ncase SEN_OV7610:\r\ncase SEN_OV76BE:\r\ncase SEN_OV6620:\r\ncase SEN_OV6630:\r\ncase SEN_OV66308AF:\r\ncase SEN_OV7640:\r\ncase SEN_OV7648:\r\ni2c_w(sd, OV7610_REG_BRT, val);\r\nbreak;\r\ncase SEN_OV7620:\r\ncase SEN_OV7620AE:\r\nif (!sd->ctrls[AUTOBRIGHT].val)\r\ni2c_w(sd, OV7610_REG_BRT, val);\r\nbreak;\r\ncase SEN_OV7660:\r\nwrite_i2c_regvals(sd, brit_7660[val],\r\nARRAY_SIZE(brit_7660[0]));\r\nbreak;\r\ncase SEN_OV7670:\r\ni2c_w(sd, OV7670_R55_BRIGHT, ov7670_abs_to_sm(val));\r\nbreak;\r\n}\r\n}\r\nstatic void setcontrast(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint val;\r\nstatic const struct ov_i2c_regvals contrast_7660[][31] = {\r\n{{0x6c, 0xf0}, {0x6d, 0xf0}, {0x6e, 0xf8}, {0x6f, 0xa0},\r\n{0x70, 0x58}, {0x71, 0x38}, {0x72, 0x30}, {0x73, 0x30},\r\n{0x74, 0x28}, {0x75, 0x28}, {0x76, 0x24}, {0x77, 0x24},\r\n{0x78, 0x22}, {0x79, 0x28}, {0x7a, 0x2a}, {0x7b, 0x34},\r\n{0x7c, 0x0f}, {0x7d, 0x1e}, {0x7e, 0x3d}, {0x7f, 0x65},\r\n{0x80, 0x70}, {0x81, 0x77}, {0x82, 0x7d}, {0x83, 0x83},\r\n{0x84, 0x88}, {0x85, 0x8d}, {0x86, 0x96}, {0x87, 0x9f},\r\n{0x88, 0xb0}, {0x89, 0xc4}, {0x8a, 0xd9}},\r\n{{0x6c, 0xf0}, {0x6d, 0xf0}, {0x6e, 0xf8}, {0x6f, 0x94},\r\n{0x70, 0x58}, {0x71, 0x40}, {0x72, 0x30}, {0x73, 0x30},\r\n{0x74, 0x30}, {0x75, 0x30}, {0x76, 0x2c}, {0x77, 0x24},\r\n{0x78, 0x22}, {0x79, 0x28}, {0x7a, 0x2a}, {0x7b, 0x31},\r\n{0x7c, 0x0f}, {0x7d, 0x1e}, {0x7e, 0x3d}, {0x7f, 0x62},\r\n{0x80, 0x6d}, {0x81, 0x75}, {0x82, 0x7b}, {0x83, 0x81},\r\n{0x84, 0x87}, {0x85, 0x8d}, {0x86, 0x98}, {0x87, 0xa1},\r\n{0x88, 0xb2}, {0x89, 0xc6}, {0x8a, 0xdb}},\r\n{{0x6c, 0xf0}, {0x6d, 0xf0}, {0x6e, 0xf0}, {0x6f, 0x84},\r\n{0x70, 0x58}, {0x71, 0x48}, {0x72, 0x40}, {0x73, 0x40},\r\n{0x74, 0x28}, {0x75, 0x28}, {0x76, 0x28}, {0x77, 0x24},\r\n{0x78, 0x26}, {0x79, 0x28}, {0x7a, 0x28}, {0x7b, 0x34},\r\n{0x7c, 0x0f}, {0x7d, 0x1e}, {0x7e, 0x3c}, {0x7f, 0x5d},\r\n{0x80, 0x68}, {0x81, 0x71}, {0x82, 0x79}, {0x83, 0x81},\r\n{0x84, 0x86}, {0x85, 0x8b}, {0x86, 0x95}, {0x87, 0x9e},\r\n{0x88, 0xb1}, {0x89, 0xc5}, {0x8a, 0xd9}},\r\n{{0x6c, 0xf0}, {0x6d, 0xf0}, {0x6e, 0xf0}, {0x6f, 0x70},\r\n{0x70, 0x58}, {0x71, 0x58}, {0x72, 0x48}, {0x73, 0x48},\r\n{0x74, 0x38}, {0x75, 0x40}, {0x76, 0x34}, {0x77, 0x34},\r\n{0x78, 0x2e}, {0x79, 0x28}, {0x7a, 0x24}, {0x7b, 0x22},\r\n{0x7c, 0x0f}, {0x7d, 0x1e}, {0x7e, 0x3c}, {0x7f, 0x58},\r\n{0x80, 0x63}, {0x81, 0x6e}, {0x82, 0x77}, {0x83, 0x80},\r\n{0x84, 0x87}, {0x85, 0x8f}, {0x86, 0x9c}, {0x87, 0xa9},\r\n{0x88, 0xc0}, {0x89, 0xd4}, {0x8a, 0xe6}},\r\n{{0x6c, 0xa0}, {0x6d, 0xf0}, {0x6e, 0x90}, {0x6f, 0x80},\r\n{0x70, 0x70}, {0x71, 0x80}, {0x72, 0x60}, {0x73, 0x60},\r\n{0x74, 0x58}, {0x75, 0x60}, {0x76, 0x4c}, {0x77, 0x38},\r\n{0x78, 0x38}, {0x79, 0x2a}, {0x7a, 0x20}, {0x7b, 0x0e},\r\n{0x7c, 0x0a}, {0x7d, 0x14}, {0x7e, 0x26}, {0x7f, 0x46},\r\n{0x80, 0x54}, {0x81, 0x64}, {0x82, 0x70}, {0x83, 0x7c},\r\n{0x84, 0x87}, {0x85, 0x93}, {0x86, 0xa6}, {0x87, 0xb4},\r\n{0x88, 0xd0}, {0x89, 0xe5}, {0x8a, 0xf5}},\r\n{{0x6c, 0x60}, {0x6d, 0x80}, {0x6e, 0x60}, {0x6f, 0x80},\r\n{0x70, 0x80}, {0x71, 0x80}, {0x72, 0x88}, {0x73, 0x30},\r\n{0x74, 0x70}, {0x75, 0x68}, {0x76, 0x64}, {0x77, 0x50},\r\n{0x78, 0x3c}, {0x79, 0x22}, {0x7a, 0x10}, {0x7b, 0x08},\r\n{0x7c, 0x06}, {0x7d, 0x0e}, {0x7e, 0x1a}, {0x7f, 0x3a},\r\n{0x80, 0x4a}, {0x81, 0x5a}, {0x82, 0x6b}, {0x83, 0x7b},\r\n{0x84, 0x89}, {0x85, 0x96}, {0x86, 0xaf}, {0x87, 0xc3},\r\n{0x88, 0xe1}, {0x89, 0xf2}, {0x8a, 0xfa}},\r\n{{0x6c, 0x20}, {0x6d, 0x40}, {0x6e, 0x20}, {0x6f, 0x60},\r\n{0x70, 0x88}, {0x71, 0xc8}, {0x72, 0xc0}, {0x73, 0xb8},\r\n{0x74, 0xa8}, {0x75, 0xb8}, {0x76, 0x80}, {0x77, 0x5c},\r\n{0x78, 0x26}, {0x79, 0x10}, {0x7a, 0x08}, {0x7b, 0x04},\r\n{0x7c, 0x02}, {0x7d, 0x06}, {0x7e, 0x0a}, {0x7f, 0x22},\r\n{0x80, 0x33}, {0x81, 0x4c}, {0x82, 0x64}, {0x83, 0x7b},\r\n{0x84, 0x90}, {0x85, 0xa7}, {0x86, 0xc7}, {0x87, 0xde},\r\n{0x88, 0xf1}, {0x89, 0xf9}, {0x8a, 0xfd}},\r\n};\r\nval = sd->ctrls[CONTRAST].val;\r\nswitch (sd->sensor) {\r\ncase SEN_OV7610:\r\ncase SEN_OV6620:\r\ni2c_w(sd, OV7610_REG_CNT, val);\r\nbreak;\r\ncase SEN_OV6630:\r\ncase SEN_OV66308AF:\r\ni2c_w_mask(sd, OV7610_REG_CNT, val >> 4, 0x0f);\r\nbreak;\r\ncase SEN_OV8610: {\r\nstatic const u8 ctab[] = {\r\n0x03, 0x09, 0x0b, 0x0f, 0x53, 0x6f, 0x35, 0x7f\r\n};\r\ni2c_w(sd, 0x64, ctab[val >> 5]);\r\nbreak;\r\n}\r\ncase SEN_OV7620:\r\ncase SEN_OV7620AE: {\r\nstatic const u8 ctab[] = {\r\n0x01, 0x05, 0x09, 0x11, 0x15, 0x35, 0x37, 0x57,\r\n0x5b, 0xa5, 0xa7, 0xc7, 0xc9, 0xcf, 0xef, 0xff\r\n};\r\ni2c_w(sd, 0x64, ctab[val >> 4]);\r\nbreak;\r\n}\r\ncase SEN_OV7660:\r\nwrite_i2c_regvals(sd, contrast_7660[val],\r\nARRAY_SIZE(contrast_7660[0]));\r\nbreak;\r\ncase SEN_OV7670:\r\ni2c_w(sd, OV7670_R56_CONTRAS, val >> 1);\r\nbreak;\r\n}\r\n}\r\nstatic void setexposure(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (!sd->ctrls[AUTOGAIN].val)\r\ni2c_w(sd, 0x10, sd->ctrls[EXPOSURE].val);\r\n}\r\nstatic void setcolors(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint val;\r\nstatic const struct ov_i2c_regvals colors_7660[][6] = {\r\n{{0x4f, 0x28}, {0x50, 0x2a}, {0x51, 0x02}, {0x52, 0x0a},\r\n{0x53, 0x19}, {0x54, 0x23}},\r\n{{0x4f, 0x47}, {0x50, 0x4a}, {0x51, 0x03}, {0x52, 0x11},\r\n{0x53, 0x2c}, {0x54, 0x3e}},\r\n{{0x4f, 0x66}, {0x50, 0x6b}, {0x51, 0x05}, {0x52, 0x19},\r\n{0x53, 0x40}, {0x54, 0x59}},\r\n{{0x4f, 0x84}, {0x50, 0x8b}, {0x51, 0x06}, {0x52, 0x20},\r\n{0x53, 0x53}, {0x54, 0x73}},\r\n{{0x4f, 0xa3}, {0x50, 0xab}, {0x51, 0x08}, {0x52, 0x28},\r\n{0x53, 0x66}, {0x54, 0x8e}},\r\n};\r\nval = sd->ctrls[COLORS].val;\r\nswitch (sd->sensor) {\r\ncase SEN_OV8610:\r\ncase SEN_OV7610:\r\ncase SEN_OV76BE:\r\ncase SEN_OV6620:\r\ncase SEN_OV6630:\r\ncase SEN_OV66308AF:\r\ni2c_w(sd, OV7610_REG_SAT, val);\r\nbreak;\r\ncase SEN_OV7620:\r\ncase SEN_OV7620AE:\r\ni2c_w(sd, OV7610_REG_SAT, val);\r\nbreak;\r\ncase SEN_OV7640:\r\ncase SEN_OV7648:\r\ni2c_w(sd, OV7610_REG_SAT, val & 0xf0);\r\nbreak;\r\ncase SEN_OV7660:\r\nwrite_i2c_regvals(sd, colors_7660[val],\r\nARRAY_SIZE(colors_7660[0]));\r\nbreak;\r\ncase SEN_OV7670:\r\nbreak;\r\n}\r\n}\r\nstatic void setautobright(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ni2c_w_mask(sd, 0x2d, sd->ctrls[AUTOBRIGHT].val ? 0x10 : 0x00, 0x10);\r\n}\r\nstatic int sd_setautogain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->ctrls[AUTOGAIN].val = val;\r\nif (val) {\r\ngspca_dev->ctrl_inac |= (1 << EXPOSURE);\r\n} else {\r\ngspca_dev->ctrl_inac &= ~(1 << EXPOSURE);\r\nsd->ctrls[EXPOSURE].val = i2c_r(sd, 0x10);\r\n}\r\nif (gspca_dev->streaming)\r\nsetautogain(gspca_dev);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void setfreq_i(struct sd *sd)\r\n{\r\nif (sd->sensor == SEN_OV7660\r\n|| sd->sensor == SEN_OV7670) {\r\nswitch (sd->ctrls[FREQ].val) {\r\ncase 0:\r\ni2c_w_mask(sd, OV7670_R13_COM8, 0, OV7670_COM8_BFILT);\r\nbreak;\r\ncase 1:\r\ni2c_w_mask(sd, OV7670_R13_COM8, OV7670_COM8_BFILT,\r\nOV7670_COM8_BFILT);\r\ni2c_w_mask(sd, OV7670_R3B_COM11, 0x08, 0x18);\r\nbreak;\r\ncase 2:\r\ni2c_w_mask(sd, OV7670_R13_COM8, OV7670_COM8_BFILT,\r\nOV7670_COM8_BFILT);\r\ni2c_w_mask(sd, OV7670_R3B_COM11, 0x00, 0x18);\r\nbreak;\r\ncase 3:\r\ni2c_w_mask(sd, OV7670_R13_COM8, OV7670_COM8_BFILT,\r\nOV7670_COM8_BFILT);\r\ni2c_w_mask(sd, OV7670_R3B_COM11, OV7670_COM11_HZAUTO,\r\n0x18);\r\nbreak;\r\n}\r\n} else {\r\nswitch (sd->ctrls[FREQ].val) {\r\ncase 0:\r\ni2c_w_mask(sd, 0x2d, 0x00, 0x04);\r\ni2c_w_mask(sd, 0x2a, 0x00, 0x80);\r\nbreak;\r\ncase 1:\r\ni2c_w_mask(sd, 0x2d, 0x04, 0x04);\r\ni2c_w_mask(sd, 0x2a, 0x80, 0x80);\r\nif (sd->sensor == SEN_OV6620 ||\r\nsd->sensor == SEN_OV6630 ||\r\nsd->sensor == SEN_OV66308AF)\r\ni2c_w(sd, 0x2b, 0x5e);\r\nelse\r\ni2c_w(sd, 0x2b, 0xac);\r\nbreak;\r\ncase 2:\r\ni2c_w_mask(sd, 0x2d, 0x04, 0x04);\r\nif (sd->sensor == SEN_OV6620 ||\r\nsd->sensor == SEN_OV6630 ||\r\nsd->sensor == SEN_OV66308AF) {\r\ni2c_w_mask(sd, 0x2a, 0x80, 0x80);\r\ni2c_w(sd, 0x2b, 0xa8);\r\n} else {\r\ni2c_w_mask(sd, 0x2a, 0x00, 0x80);\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void setfreq(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsetfreq_i(sd);\r\nif (sd->bridge == BRIDGE_W9968CF)\r\nw9968cf_set_crop_window(sd);\r\n}\r\nstatic int sd_querymenu(struct gspca_dev *gspca_dev,\r\nstruct v4l2_querymenu *menu)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nswitch (menu->id) {\r\ncase V4L2_CID_POWER_LINE_FREQUENCY:\r\nswitch (menu->index) {\r\ncase 0:\r\nstrcpy((char *) menu->name, "NoFliker");\r\nreturn 0;\r\ncase 1:\r\nstrcpy((char *) menu->name, "50 Hz");\r\nreturn 0;\r\ncase 2:\r\nstrcpy((char *) menu->name, "60 Hz");\r\nreturn 0;\r\ncase 3:\r\nif (sd->sensor != SEN_OV7670)\r\nreturn -EINVAL;\r\nstrcpy((char *) menu->name, "Automatic");\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int sd_get_jcomp(struct gspca_dev *gspca_dev,\r\nstruct v4l2_jpegcompression *jcomp)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->bridge != BRIDGE_W9968CF)\r\nreturn -EINVAL;\r\nmemset(jcomp, 0, sizeof *jcomp);\r\njcomp->quality = sd->quality;\r\njcomp->jpeg_markers = V4L2_JPEG_MARKER_DHT | V4L2_JPEG_MARKER_DQT |\r\nV4L2_JPEG_MARKER_DRI;\r\nreturn 0;\r\n}\r\nstatic int sd_set_jcomp(struct gspca_dev *gspca_dev,\r\nstruct v4l2_jpegcompression *jcomp)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->bridge != BRIDGE_W9968CF)\r\nreturn -EINVAL;\r\nif (gspca_dev->streaming)\r\nreturn -EBUSY;\r\nif (jcomp->quality < QUALITY_MIN)\r\nsd->quality = QUALITY_MIN;\r\nelse if (jcomp->quality > QUALITY_MAX)\r\nsd->quality = QUALITY_MAX;\r\nelse\r\nsd->quality = jcomp->quality;\r\nsd_get_jcomp(gspca_dev, jcomp);\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
