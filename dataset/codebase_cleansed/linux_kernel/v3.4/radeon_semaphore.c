static int radeon_semaphore_add_bo(struct radeon_device *rdev)\r\n{\r\nstruct radeon_semaphore_bo *bo;\r\nunsigned long irq_flags;\r\nuint64_t gpu_addr;\r\nuint32_t *cpu_ptr;\r\nint r, i;\r\nbo = kmalloc(sizeof(struct radeon_semaphore_bo), GFP_KERNEL);\r\nif (bo == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&bo->free);\r\nINIT_LIST_HEAD(&bo->list);\r\nbo->nused = 0;\r\nr = radeon_ib_get(rdev, 0, &bo->ib, RADEON_SEMAPHORE_BO_SIZE);\r\nif (r) {\r\ndev_err(rdev->dev, "failed to get a bo after 5 retry\n");\r\nkfree(bo);\r\nreturn r;\r\n}\r\ngpu_addr = rdev->ib_pool.sa_manager.gpu_addr;\r\ngpu_addr += bo->ib->sa_bo.offset;\r\ncpu_ptr = rdev->ib_pool.sa_manager.cpu_ptr;\r\ncpu_ptr += (bo->ib->sa_bo.offset >> 2);\r\nfor (i = 0; i < (RADEON_SEMAPHORE_BO_SIZE/8); i++) {\r\nbo->semaphores[i].gpu_addr = gpu_addr;\r\nbo->semaphores[i].cpu_ptr = cpu_ptr;\r\nbo->semaphores[i].bo = bo;\r\nlist_add_tail(&bo->semaphores[i].list, &bo->free);\r\ngpu_addr += 8;\r\ncpu_ptr += 2;\r\n}\r\nwrite_lock_irqsave(&rdev->semaphore_drv.lock, irq_flags);\r\nlist_add_tail(&bo->list, &rdev->semaphore_drv.bo);\r\nwrite_unlock_irqrestore(&rdev->semaphore_drv.lock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic void radeon_semaphore_del_bo_locked(struct radeon_device *rdev,\r\nstruct radeon_semaphore_bo *bo)\r\n{\r\nradeon_sa_bo_free(rdev, &bo->ib->sa_bo);\r\nradeon_fence_unref(&bo->ib->fence);\r\nlist_del(&bo->list);\r\nkfree(bo);\r\n}\r\nvoid radeon_semaphore_shrink_locked(struct radeon_device *rdev)\r\n{\r\nstruct radeon_semaphore_bo *bo, *n;\r\nif (list_empty(&rdev->semaphore_drv.bo)) {\r\nreturn;\r\n}\r\nbo = list_first_entry(&rdev->semaphore_drv.bo, struct radeon_semaphore_bo, list);\r\nif (list_empty(&bo->free)) {\r\nreturn;\r\n}\r\nlist_for_each_entry_safe_continue(bo, n, &rdev->semaphore_drv.bo, list) {\r\nif (bo->nused)\r\ncontinue;\r\nradeon_semaphore_del_bo_locked(rdev, bo);\r\n}\r\n}\r\nint radeon_semaphore_create(struct radeon_device *rdev,\r\nstruct radeon_semaphore **semaphore)\r\n{\r\nstruct radeon_semaphore_bo *bo;\r\nunsigned long irq_flags;\r\nbool do_retry = true;\r\nint r;\r\nretry:\r\n*semaphore = NULL;\r\nwrite_lock_irqsave(&rdev->semaphore_drv.lock, irq_flags);\r\nlist_for_each_entry(bo, &rdev->semaphore_drv.bo, list) {\r\nif (list_empty(&bo->free))\r\ncontinue;\r\n*semaphore = list_first_entry(&bo->free, struct radeon_semaphore, list);\r\n(*semaphore)->cpu_ptr[0] = 0;\r\n(*semaphore)->cpu_ptr[1] = 0;\r\nlist_del(&(*semaphore)->list);\r\nbo->nused++;\r\nbreak;\r\n}\r\nwrite_unlock_irqrestore(&rdev->semaphore_drv.lock, irq_flags);\r\nif (*semaphore == NULL) {\r\nif (do_retry) {\r\ndo_retry = false;\r\nr = radeon_semaphore_add_bo(rdev);\r\nif (r)\r\nreturn r;\r\ngoto retry;\r\n}\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid radeon_semaphore_emit_signal(struct radeon_device *rdev, int ring,\r\nstruct radeon_semaphore *semaphore)\r\n{\r\nradeon_semaphore_ring_emit(rdev, ring, &rdev->ring[ring], semaphore, false);\r\n}\r\nvoid radeon_semaphore_emit_wait(struct radeon_device *rdev, int ring,\r\nstruct radeon_semaphore *semaphore)\r\n{\r\nradeon_semaphore_ring_emit(rdev, ring, &rdev->ring[ring], semaphore, true);\r\n}\r\nvoid radeon_semaphore_free(struct radeon_device *rdev,\r\nstruct radeon_semaphore *semaphore)\r\n{\r\nunsigned long irq_flags;\r\nwrite_lock_irqsave(&rdev->semaphore_drv.lock, irq_flags);\r\nsemaphore->bo->nused--;\r\nlist_add_tail(&semaphore->list, &semaphore->bo->free);\r\nradeon_semaphore_shrink_locked(rdev);\r\nwrite_unlock_irqrestore(&rdev->semaphore_drv.lock, irq_flags);\r\n}\r\nvoid radeon_semaphore_driver_fini(struct radeon_device *rdev)\r\n{\r\nstruct radeon_semaphore_bo *bo, *n;\r\nunsigned long irq_flags;\r\nwrite_lock_irqsave(&rdev->semaphore_drv.lock, irq_flags);\r\nlist_for_each_entry_safe(bo, n, &rdev->semaphore_drv.bo, list) {\r\nif (!list_empty(&bo->free)) {\r\ndev_err(rdev->dev, "still in use semaphore\n");\r\n}\r\nradeon_semaphore_del_bo_locked(rdev, bo);\r\n}\r\nwrite_unlock_irqrestore(&rdev->semaphore_drv.lock, irq_flags);\r\n}
