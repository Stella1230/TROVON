static void event_tasklet(unsigned long data)\r\n{\r\nstruct ngene *dev = (struct ngene *)data;\r\nwhile (dev->EventQueueReadIndex != dev->EventQueueWriteIndex) {\r\nstruct EVENT_BUFFER Event =\r\ndev->EventQueue[dev->EventQueueReadIndex];\r\ndev->EventQueueReadIndex =\r\n(dev->EventQueueReadIndex + 1) & (EVENT_QUEUE_SIZE - 1);\r\nif ((Event.UARTStatus & 0x01) && (dev->TxEventNotify))\r\ndev->TxEventNotify(dev, Event.TimeStamp);\r\nif ((Event.UARTStatus & 0x02) && (dev->RxEventNotify))\r\ndev->RxEventNotify(dev, Event.TimeStamp,\r\nEvent.RXCharacter);\r\n}\r\n}\r\nstatic void demux_tasklet(unsigned long data)\r\n{\r\nstruct ngene_channel *chan = (struct ngene_channel *)data;\r\nstruct SBufferHeader *Cur = chan->nextBuffer;\r\nspin_lock_irq(&chan->state_lock);\r\nwhile (Cur->ngeneBuffer.SR.Flags & 0x80) {\r\nif (chan->mode & NGENE_IO_TSOUT) {\r\nu32 Flags = chan->DataFormatFlags;\r\nif (Cur->ngeneBuffer.SR.Flags & 0x20)\r\nFlags |= BEF_OVERFLOW;\r\nif (chan->pBufferExchange) {\r\nif (!chan->pBufferExchange(chan,\r\nCur->Buffer1,\r\nchan->Capture1Length,\r\nCur->ngeneBuffer.SR.\r\nClock, Flags)) {\r\nif (chan->HWState == HWSTATE_RUN) {\r\nCur->ngeneBuffer.SR.Flags &=\r\n~0x40;\r\nbreak;\r\n}\r\n} else {\r\nchan->HWState = HWSTATE_RUN;\r\n}\r\n} else {\r\nprintk(KERN_ERR DEVICE_NAME ": OOPS\n");\r\nif (chan->HWState == HWSTATE_RUN) {\r\nCur->ngeneBuffer.SR.Flags &= ~0x40;\r\nbreak;\r\n}\r\n}\r\nif (chan->AudioDTOUpdated) {\r\nprintk(KERN_INFO DEVICE_NAME\r\n": Update AudioDTO = %d\n",\r\nchan->AudioDTOValue);\r\nCur->ngeneBuffer.SR.DTOUpdate =\r\nchan->AudioDTOValue;\r\nchan->AudioDTOUpdated = 0;\r\n}\r\n} else {\r\nif (chan->HWState == HWSTATE_RUN) {\r\nu32 Flags = chan->DataFormatFlags;\r\nIBufferExchange *exch1 = chan->pBufferExchange;\r\nIBufferExchange *exch2 = chan->pBufferExchange2;\r\nif (Cur->ngeneBuffer.SR.Flags & 0x01)\r\nFlags |= BEF_EVEN_FIELD;\r\nif (Cur->ngeneBuffer.SR.Flags & 0x20)\r\nFlags |= BEF_OVERFLOW;\r\nspin_unlock_irq(&chan->state_lock);\r\nif (exch1)\r\nexch1(chan, Cur->Buffer1,\r\nchan->Capture1Length,\r\nCur->ngeneBuffer.SR.Clock,\r\nFlags);\r\nif (exch2)\r\nexch2(chan, Cur->Buffer2,\r\nchan->Capture2Length,\r\nCur->ngeneBuffer.SR.Clock,\r\nFlags);\r\nspin_lock_irq(&chan->state_lock);\r\n} else if (chan->HWState != HWSTATE_STOP)\r\nchan->HWState = HWSTATE_RUN;\r\n}\r\nCur->ngeneBuffer.SR.Flags = 0x00;\r\nCur = Cur->Next;\r\n}\r\nchan->nextBuffer = Cur;\r\nspin_unlock_irq(&chan->state_lock);\r\n}\r\nstatic irqreturn_t irq_handler(int irq, void *dev_id)\r\n{\r\nstruct ngene *dev = (struct ngene *)dev_id;\r\nu32 icounts = 0;\r\nirqreturn_t rc = IRQ_NONE;\r\nu32 i = MAX_STREAM;\r\nu8 *tmpCmdDoneByte;\r\nif (dev->BootFirmware) {\r\nicounts = ngreadl(NGENE_INT_COUNTS);\r\nif (icounts != dev->icounts) {\r\nngwritel(0, FORCE_NMI);\r\ndev->cmd_done = 1;\r\nwake_up(&dev->cmd_wq);\r\ndev->icounts = icounts;\r\nrc = IRQ_HANDLED;\r\n}\r\nreturn rc;\r\n}\r\nngwritel(0, FORCE_NMI);\r\nspin_lock(&dev->cmd_lock);\r\ntmpCmdDoneByte = dev->CmdDoneByte;\r\nif (tmpCmdDoneByte &&\r\n(*tmpCmdDoneByte ||\r\n(dev->ngenetohost[0] == 1 && dev->ngenetohost[1] != 0))) {\r\ndev->CmdDoneByte = NULL;\r\ndev->cmd_done = 1;\r\nwake_up(&dev->cmd_wq);\r\nrc = IRQ_HANDLED;\r\n}\r\nspin_unlock(&dev->cmd_lock);\r\nif (dev->EventBuffer->EventStatus & 0x80) {\r\nu8 nextWriteIndex =\r\n(dev->EventQueueWriteIndex + 1) &\r\n(EVENT_QUEUE_SIZE - 1);\r\nif (nextWriteIndex != dev->EventQueueReadIndex) {\r\ndev->EventQueue[dev->EventQueueWriteIndex] =\r\n*(dev->EventBuffer);\r\ndev->EventQueueWriteIndex = nextWriteIndex;\r\n} else {\r\nprintk(KERN_ERR DEVICE_NAME ": event overflow\n");\r\ndev->EventQueueOverflowCount += 1;\r\ndev->EventQueueOverflowFlag = 1;\r\n}\r\ndev->EventBuffer->EventStatus &= ~0x80;\r\ntasklet_schedule(&dev->event_tasklet);\r\nrc = IRQ_HANDLED;\r\n}\r\nwhile (i > 0) {\r\ni--;\r\nspin_lock(&dev->channel[i].state_lock);\r\nif (dev->channel[i].nextBuffer) {\r\nif ((dev->channel[i].nextBuffer->\r\nngeneBuffer.SR.Flags & 0xC0) == 0x80) {\r\ndev->channel[i].nextBuffer->\r\nngeneBuffer.SR.Flags |= 0x40;\r\ntasklet_schedule(\r\n&dev->channel[i].demux_tasklet);\r\nrc = IRQ_HANDLED;\r\n}\r\n}\r\nspin_unlock(&dev->channel[i].state_lock);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void dump_command_io(struct ngene *dev)\r\n{\r\nu8 buf[8], *b;\r\nngcpyfrom(buf, HOST_TO_NGENE, 8);\r\nprintk(KERN_ERR "host_to_ngene (%04x): %02x %02x %02x %02x %02x %02x %02x %02x\n",\r\nHOST_TO_NGENE, buf[0], buf[1], buf[2], buf[3],\r\nbuf[4], buf[5], buf[6], buf[7]);\r\nngcpyfrom(buf, NGENE_TO_HOST, 8);\r\nprintk(KERN_ERR "ngene_to_host (%04x): %02x %02x %02x %02x %02x %02x %02x %02x\n",\r\nNGENE_TO_HOST, buf[0], buf[1], buf[2], buf[3],\r\nbuf[4], buf[5], buf[6], buf[7]);\r\nb = dev->hosttongene;\r\nprintk(KERN_ERR "dev->hosttongene (%p): %02x %02x %02x %02x %02x %02x %02x %02x\n",\r\nb, b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);\r\nb = dev->ngenetohost;\r\nprintk(KERN_ERR "dev->ngenetohost (%p): %02x %02x %02x %02x %02x %02x %02x %02x\n",\r\nb, b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);\r\n}\r\nstatic int ngene_command_mutex(struct ngene *dev, struct ngene_command *com)\r\n{\r\nint ret;\r\nu8 *tmpCmdDoneByte;\r\ndev->cmd_done = 0;\r\nif (com->cmd.hdr.Opcode == CMD_FWLOAD_PREPARE) {\r\ndev->BootFirmware = 1;\r\ndev->icounts = ngreadl(NGENE_INT_COUNTS);\r\nngwritel(0, NGENE_COMMAND);\r\nngwritel(0, NGENE_COMMAND_HI);\r\nngwritel(0, NGENE_STATUS);\r\nngwritel(0, NGENE_STATUS_HI);\r\nngwritel(0, NGENE_EVENT);\r\nngwritel(0, NGENE_EVENT_HI);\r\n} else if (com->cmd.hdr.Opcode == CMD_FWLOAD_FINISH) {\r\nu64 fwio = dev->PAFWInterfaceBuffer;\r\nngwritel(fwio & 0xffffffff, NGENE_COMMAND);\r\nngwritel(fwio >> 32, NGENE_COMMAND_HI);\r\nngwritel((fwio + 256) & 0xffffffff, NGENE_STATUS);\r\nngwritel((fwio + 256) >> 32, NGENE_STATUS_HI);\r\nngwritel((fwio + 512) & 0xffffffff, NGENE_EVENT);\r\nngwritel((fwio + 512) >> 32, NGENE_EVENT_HI);\r\n}\r\nmemcpy(dev->FWInterfaceBuffer, com->cmd.raw8, com->in_len + 2);\r\nif (dev->BootFirmware)\r\nngcpyto(HOST_TO_NGENE, com->cmd.raw8, com->in_len + 2);\r\nspin_lock_irq(&dev->cmd_lock);\r\ntmpCmdDoneByte = dev->ngenetohost + com->out_len;\r\nif (!com->out_len)\r\ntmpCmdDoneByte++;\r\n*tmpCmdDoneByte = 0;\r\ndev->ngenetohost[0] = 0;\r\ndev->ngenetohost[1] = 0;\r\ndev->CmdDoneByte = tmpCmdDoneByte;\r\nspin_unlock_irq(&dev->cmd_lock);\r\nngwritel(1, FORCE_INT);\r\nret = wait_event_timeout(dev->cmd_wq, dev->cmd_done == 1, 2 * HZ);\r\nif (!ret) {\r\nprintk(KERN_ERR DEVICE_NAME\r\n": Command timeout cmd=%02x prev=%02x\n",\r\ncom->cmd.hdr.Opcode, dev->prev_cmd);\r\ndump_command_io(dev);\r\nreturn -1;\r\n}\r\nif (com->cmd.hdr.Opcode == CMD_FWLOAD_FINISH)\r\ndev->BootFirmware = 0;\r\ndev->prev_cmd = com->cmd.hdr.Opcode;\r\nif (!com->out_len)\r\nreturn 0;\r\nmemcpy(com->cmd.raw8, dev->ngenetohost, com->out_len);\r\nreturn 0;\r\n}\r\nint ngene_command(struct ngene *dev, struct ngene_command *com)\r\n{\r\nint result;\r\ndown(&dev->cmd_mutex);\r\nresult = ngene_command_mutex(dev, com);\r\nup(&dev->cmd_mutex);\r\nreturn result;\r\n}\r\nstatic int ngene_command_load_firmware(struct ngene *dev,\r\nu8 *ngene_fw, u32 size)\r\n{\r\n#define FIRSTCHUNK (1024)\r\nu32 cleft;\r\nstruct ngene_command com;\r\ncom.cmd.hdr.Opcode = CMD_FWLOAD_PREPARE;\r\ncom.cmd.hdr.Length = 0;\r\ncom.in_len = 0;\r\ncom.out_len = 0;\r\nngene_command(dev, &com);\r\ncleft = (size + 3) & ~3;\r\nif (cleft > FIRSTCHUNK) {\r\nngcpyto(PROGRAM_SRAM + FIRSTCHUNK, ngene_fw + FIRSTCHUNK,\r\ncleft - FIRSTCHUNK);\r\ncleft = FIRSTCHUNK;\r\n}\r\nngcpyto(DATA_FIFO_AREA, ngene_fw, cleft);\r\nmemset(&com, 0, sizeof(struct ngene_command));\r\ncom.cmd.hdr.Opcode = CMD_FWLOAD_FINISH;\r\ncom.cmd.hdr.Length = 4;\r\ncom.cmd.FWLoadFinish.Address = DATA_FIFO_AREA;\r\ncom.cmd.FWLoadFinish.Length = (unsigned short)cleft;\r\ncom.in_len = 4;\r\ncom.out_len = 0;\r\nreturn ngene_command(dev, &com);\r\n}\r\nstatic int ngene_command_config_buf(struct ngene *dev, u8 config)\r\n{\r\nstruct ngene_command com;\r\ncom.cmd.hdr.Opcode = CMD_CONFIGURE_BUFFER;\r\ncom.cmd.hdr.Length = 1;\r\ncom.cmd.ConfigureBuffers.config = config;\r\ncom.in_len = 1;\r\ncom.out_len = 0;\r\nif (ngene_command(dev, &com) < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int ngene_command_config_free_buf(struct ngene *dev, u8 *config)\r\n{\r\nstruct ngene_command com;\r\ncom.cmd.hdr.Opcode = CMD_CONFIGURE_FREE_BUFFER;\r\ncom.cmd.hdr.Length = 6;\r\nmemcpy(&com.cmd.ConfigureBuffers.config, config, 6);\r\ncom.in_len = 6;\r\ncom.out_len = 0;\r\nif (ngene_command(dev, &com) < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nint ngene_command_gpio_set(struct ngene *dev, u8 select, u8 level)\r\n{\r\nstruct ngene_command com;\r\ncom.cmd.hdr.Opcode = CMD_SET_GPIO_PIN;\r\ncom.cmd.hdr.Length = 1;\r\ncom.cmd.SetGpioPin.select = select | (level << 7);\r\ncom.in_len = 1;\r\ncom.out_len = 0;\r\nreturn ngene_command(dev, &com);\r\n}\r\nvoid FillTSBuffer(void *Buffer, int Length, u32 Flags)\r\n{\r\nu32 *ptr = Buffer;\r\nmemset(Buffer, TS_FILLER, Length);\r\nwhile (Length > 0) {\r\nif (Flags & DF_SWAP32)\r\n*ptr = 0x471FFF10;\r\nelse\r\n*ptr = 0x10FF1F47;\r\nptr += (188 / 4);\r\nLength -= 188;\r\n}\r\n}\r\nstatic void flush_buffers(struct ngene_channel *chan)\r\n{\r\nu8 val;\r\ndo {\r\nmsleep(1);\r\nspin_lock_irq(&chan->state_lock);\r\nval = chan->nextBuffer->ngeneBuffer.SR.Flags & 0x80;\r\nspin_unlock_irq(&chan->state_lock);\r\n} while (val);\r\n}\r\nstatic void clear_buffers(struct ngene_channel *chan)\r\n{\r\nstruct SBufferHeader *Cur = chan->nextBuffer;\r\ndo {\r\nmemset(&Cur->ngeneBuffer.SR, 0, sizeof(Cur->ngeneBuffer.SR));\r\nif (chan->mode & NGENE_IO_TSOUT)\r\nFillTSBuffer(Cur->Buffer1,\r\nchan->Capture1Length,\r\nchan->DataFormatFlags);\r\nCur = Cur->Next;\r\n} while (Cur != chan->nextBuffer);\r\nif (chan->mode & NGENE_IO_TSOUT) {\r\nchan->nextBuffer->ngeneBuffer.SR.DTOUpdate =\r\nchan->AudioDTOValue;\r\nchan->AudioDTOUpdated = 0;\r\nCur = chan->TSIdleBuffer.Head;\r\ndo {\r\nmemset(&Cur->ngeneBuffer.SR, 0,\r\nsizeof(Cur->ngeneBuffer.SR));\r\nFillTSBuffer(Cur->Buffer1,\r\nchan->Capture1Length,\r\nchan->DataFormatFlags);\r\nCur = Cur->Next;\r\n} while (Cur != chan->TSIdleBuffer.Head);\r\n}\r\n}\r\nstatic int ngene_command_stream_control(struct ngene *dev, u8 stream,\r\nu8 control, u8 mode, u8 flags)\r\n{\r\nstruct ngene_channel *chan = &dev->channel[stream];\r\nstruct ngene_command com;\r\nu16 BsUVI = ((stream & 1) ? 0x9400 : 0x9300);\r\nu16 BsSDI = ((stream & 1) ? 0x9600 : 0x9500);\r\nu16 BsSPI = ((stream & 1) ? 0x9800 : 0x9700);\r\nu16 BsSDO = 0x9B00;\r\ndown(&dev->stream_mutex);\r\nmemset(&com, 0, sizeof(com));\r\ncom.cmd.hdr.Opcode = CMD_CONTROL;\r\ncom.cmd.hdr.Length = sizeof(struct FW_STREAM_CONTROL) - 2;\r\ncom.cmd.StreamControl.Stream = stream | (control ? 8 : 0);\r\nif (chan->mode & NGENE_IO_TSOUT)\r\ncom.cmd.StreamControl.Stream |= 0x07;\r\ncom.cmd.StreamControl.Control = control |\r\n(flags & SFLAG_ORDER_LUMA_CHROMA);\r\ncom.cmd.StreamControl.Mode = mode;\r\ncom.in_len = sizeof(struct FW_STREAM_CONTROL);\r\ncom.out_len = 0;\r\ndprintk(KERN_INFO DEVICE_NAME\r\n": Stream=%02x, Control=%02x, Mode=%02x\n",\r\ncom.cmd.StreamControl.Stream, com.cmd.StreamControl.Control,\r\ncom.cmd.StreamControl.Mode);\r\nchan->Mode = mode;\r\nif (!(control & 0x80)) {\r\nspin_lock_irq(&chan->state_lock);\r\nif (chan->State == KSSTATE_RUN) {\r\nchan->State = KSSTATE_ACQUIRE;\r\nchan->HWState = HWSTATE_STOP;\r\nspin_unlock_irq(&chan->state_lock);\r\nif (ngene_command(dev, &com) < 0) {\r\nup(&dev->stream_mutex);\r\nreturn -1;\r\n}\r\nflush_buffers(chan);\r\nup(&dev->stream_mutex);\r\nreturn 0;\r\n}\r\nspin_unlock_irq(&chan->state_lock);\r\nup(&dev->stream_mutex);\r\nreturn 0;\r\n}\r\nif (mode & SMODE_AUDIO_CAPTURE) {\r\ncom.cmd.StreamControl.CaptureBlockCount =\r\nchan->Capture1Length / AUDIO_BLOCK_SIZE;\r\ncom.cmd.StreamControl.Buffer_Address = chan->RingBuffer.PAHead;\r\n} else if (mode & SMODE_TRANSPORT_STREAM) {\r\ncom.cmd.StreamControl.CaptureBlockCount =\r\nchan->Capture1Length / TS_BLOCK_SIZE;\r\ncom.cmd.StreamControl.MaxLinesPerField =\r\nchan->Capture1Length / TS_BLOCK_SIZE;\r\ncom.cmd.StreamControl.Buffer_Address =\r\nchan->TSRingBuffer.PAHead;\r\nif (chan->mode & NGENE_IO_TSOUT) {\r\ncom.cmd.StreamControl.BytesPerVBILine =\r\nchan->Capture1Length / TS_BLOCK_SIZE;\r\ncom.cmd.StreamControl.Stream |= 0x07;\r\n}\r\n} else {\r\ncom.cmd.StreamControl.BytesPerVideoLine = chan->nBytesPerLine;\r\ncom.cmd.StreamControl.MaxLinesPerField = chan->nLines;\r\ncom.cmd.StreamControl.MinLinesPerField = 100;\r\ncom.cmd.StreamControl.Buffer_Address = chan->RingBuffer.PAHead;\r\nif (mode & SMODE_VBI_CAPTURE) {\r\ncom.cmd.StreamControl.MaxVBILinesPerField =\r\nchan->nVBILines;\r\ncom.cmd.StreamControl.MinVBILinesPerField = 0;\r\ncom.cmd.StreamControl.BytesPerVBILine =\r\nchan->nBytesPerVBILine;\r\n}\r\nif (flags & SFLAG_COLORBAR)\r\ncom.cmd.StreamControl.Stream |= 0x04;\r\n}\r\nspin_lock_irq(&chan->state_lock);\r\nif (mode & SMODE_AUDIO_CAPTURE) {\r\nchan->nextBuffer = chan->RingBuffer.Head;\r\nif (mode & SMODE_AUDIO_SPDIF) {\r\ncom.cmd.StreamControl.SetupDataLen =\r\nsizeof(SPDIFConfiguration);\r\ncom.cmd.StreamControl.SetupDataAddr = BsSPI;\r\nmemcpy(com.cmd.StreamControl.SetupData,\r\nSPDIFConfiguration, sizeof(SPDIFConfiguration));\r\n} else {\r\ncom.cmd.StreamControl.SetupDataLen = 4;\r\ncom.cmd.StreamControl.SetupDataAddr = BsSDI;\r\nmemcpy(com.cmd.StreamControl.SetupData,\r\nI2SConfiguration +\r\n4 * dev->card_info->i2s[stream], 4);\r\n}\r\n} else if (mode & SMODE_TRANSPORT_STREAM) {\r\nchan->nextBuffer = chan->TSRingBuffer.Head;\r\nif (stream >= STREAM_AUDIOIN1) {\r\nif (chan->mode & NGENE_IO_TSOUT) {\r\ncom.cmd.StreamControl.SetupDataLen =\r\nsizeof(TS_I2SOutConfiguration);\r\ncom.cmd.StreamControl.SetupDataAddr = BsSDO;\r\nmemcpy(com.cmd.StreamControl.SetupData,\r\nTS_I2SOutConfiguration,\r\nsizeof(TS_I2SOutConfiguration));\r\n} else {\r\ncom.cmd.StreamControl.SetupDataLen =\r\nsizeof(TS_I2SConfiguration);\r\ncom.cmd.StreamControl.SetupDataAddr = BsSDI;\r\nmemcpy(com.cmd.StreamControl.SetupData,\r\nTS_I2SConfiguration,\r\nsizeof(TS_I2SConfiguration));\r\n}\r\n} else {\r\ncom.cmd.StreamControl.SetupDataLen = 8;\r\ncom.cmd.StreamControl.SetupDataAddr = BsUVI + 0x10;\r\nmemcpy(com.cmd.StreamControl.SetupData,\r\nTSFeatureDecoderSetup +\r\n8 * dev->card_info->tsf[stream], 8);\r\n}\r\n} else {\r\nchan->nextBuffer = chan->RingBuffer.Head;\r\ncom.cmd.StreamControl.SetupDataLen =\r\n16 + sizeof(ITUFeatureDecoderSetup);\r\ncom.cmd.StreamControl.SetupDataAddr = BsUVI;\r\nmemcpy(com.cmd.StreamControl.SetupData,\r\nITUDecoderSetup[chan->itumode], 16);\r\nmemcpy(com.cmd.StreamControl.SetupData + 16,\r\nITUFeatureDecoderSetup, sizeof(ITUFeatureDecoderSetup));\r\n}\r\nclear_buffers(chan);\r\nchan->State = KSSTATE_RUN;\r\nif (mode & SMODE_TRANSPORT_STREAM)\r\nchan->HWState = HWSTATE_RUN;\r\nelse\r\nchan->HWState = HWSTATE_STARTUP;\r\nspin_unlock_irq(&chan->state_lock);\r\nif (ngene_command(dev, &com) < 0) {\r\nup(&dev->stream_mutex);\r\nreturn -1;\r\n}\r\nup(&dev->stream_mutex);\r\nreturn 0;\r\n}\r\nvoid set_transfer(struct ngene_channel *chan, int state)\r\n{\r\nu8 control = 0, mode = 0, flags = 0;\r\nstruct ngene *dev = chan->dev;\r\nint ret;\r\nif (state) {\r\nif (chan->running) {\r\nprintk(KERN_INFO DEVICE_NAME ": already running\n");\r\nreturn;\r\n}\r\n} else {\r\nif (!chan->running) {\r\nprintk(KERN_INFO DEVICE_NAME ": already stopped\n");\r\nreturn;\r\n}\r\n}\r\nif (dev->card_info->switch_ctrl)\r\ndev->card_info->switch_ctrl(chan, 1, state ^ 1);\r\nif (state) {\r\nspin_lock_irq(&chan->state_lock);\r\ndvb_ringbuffer_flush(&dev->tsout_rbuf);\r\ncontrol = 0x80;\r\nif (chan->mode & (NGENE_IO_TSIN | NGENE_IO_TSOUT)) {\r\nchan->Capture1Length = 512 * 188;\r\nmode = SMODE_TRANSPORT_STREAM;\r\n}\r\nif (chan->mode & NGENE_IO_TSOUT) {\r\nchan->pBufferExchange = tsout_exchange;\r\nchan->AudioDTOValue = 0x80000000;\r\nchan->AudioDTOUpdated = 1;\r\n}\r\nif (chan->mode & NGENE_IO_TSIN)\r\nchan->pBufferExchange = tsin_exchange;\r\nspin_unlock_irq(&chan->state_lock);\r\n} else\r\n;\r\nret = ngene_command_stream_control(dev, chan->number,\r\ncontrol, mode, flags);\r\nif (!ret)\r\nchan->running = state;\r\nelse\r\nprintk(KERN_ERR DEVICE_NAME ": set_transfer %d failed\n",\r\nstate);\r\nif (!state) {\r\nspin_lock_irq(&chan->state_lock);\r\nchan->pBufferExchange = NULL;\r\ndvb_ringbuffer_flush(&dev->tsout_rbuf);\r\nspin_unlock_irq(&chan->state_lock);\r\n}\r\n}\r\nstatic void free_ringbuffer(struct ngene *dev, struct SRingBufferDescriptor *rb)\r\n{\r\nstruct SBufferHeader *Cur = rb->Head;\r\nu32 j;\r\nif (!Cur)\r\nreturn;\r\nfor (j = 0; j < rb->NumBuffers; j++, Cur = Cur->Next) {\r\nif (Cur->Buffer1)\r\npci_free_consistent(dev->pci_dev,\r\nrb->Buffer1Length,\r\nCur->Buffer1,\r\nCur->scList1->Address);\r\nif (Cur->Buffer2)\r\npci_free_consistent(dev->pci_dev,\r\nrb->Buffer2Length,\r\nCur->Buffer2,\r\nCur->scList2->Address);\r\n}\r\nif (rb->SCListMem)\r\npci_free_consistent(dev->pci_dev, rb->SCListMemSize,\r\nrb->SCListMem, rb->PASCListMem);\r\npci_free_consistent(dev->pci_dev, rb->MemSize, rb->Head, rb->PAHead);\r\n}\r\nstatic void free_idlebuffer(struct ngene *dev,\r\nstruct SRingBufferDescriptor *rb,\r\nstruct SRingBufferDescriptor *tb)\r\n{\r\nint j;\r\nstruct SBufferHeader *Cur = tb->Head;\r\nif (!rb->Head)\r\nreturn;\r\nfree_ringbuffer(dev, rb);\r\nfor (j = 0; j < tb->NumBuffers; j++, Cur = Cur->Next) {\r\nCur->Buffer2 = NULL;\r\nCur->scList2 = NULL;\r\nCur->ngeneBuffer.Address_of_first_entry_2 = 0;\r\nCur->ngeneBuffer.Number_of_entries_2 = 0;\r\n}\r\n}\r\nstatic void free_common_buffers(struct ngene *dev)\r\n{\r\nu32 i;\r\nstruct ngene_channel *chan;\r\nfor (i = STREAM_VIDEOIN1; i < MAX_STREAM; i++) {\r\nchan = &dev->channel[i];\r\nfree_idlebuffer(dev, &chan->TSIdleBuffer, &chan->TSRingBuffer);\r\nfree_ringbuffer(dev, &chan->RingBuffer);\r\nfree_ringbuffer(dev, &chan->TSRingBuffer);\r\n}\r\nif (dev->OverflowBuffer)\r\npci_free_consistent(dev->pci_dev,\r\nOVERFLOW_BUFFER_SIZE,\r\ndev->OverflowBuffer, dev->PAOverflowBuffer);\r\nif (dev->FWInterfaceBuffer)\r\npci_free_consistent(dev->pci_dev,\r\n4096,\r\ndev->FWInterfaceBuffer,\r\ndev->PAFWInterfaceBuffer);\r\n}\r\nstatic int create_ring_buffer(struct pci_dev *pci_dev,\r\nstruct SRingBufferDescriptor *descr, u32 NumBuffers)\r\n{\r\ndma_addr_t tmp;\r\nstruct SBufferHeader *Head;\r\nu32 i;\r\nu32 MemSize = SIZEOF_SBufferHeader * NumBuffers;\r\nu64 PARingBufferHead;\r\nu64 PARingBufferCur;\r\nu64 PARingBufferNext;\r\nstruct SBufferHeader *Cur, *Next;\r\ndescr->Head = NULL;\r\ndescr->MemSize = 0;\r\ndescr->PAHead = 0;\r\ndescr->NumBuffers = 0;\r\nif (MemSize < 4096)\r\nMemSize = 4096;\r\nHead = pci_alloc_consistent(pci_dev, MemSize, &tmp);\r\nPARingBufferHead = tmp;\r\nif (!Head)\r\nreturn -ENOMEM;\r\nmemset(Head, 0, MemSize);\r\nPARingBufferCur = PARingBufferHead;\r\nCur = Head;\r\nfor (i = 0; i < NumBuffers - 1; i++) {\r\nNext = (struct SBufferHeader *)\r\n(((u8 *) Cur) + SIZEOF_SBufferHeader);\r\nPARingBufferNext = PARingBufferCur + SIZEOF_SBufferHeader;\r\nCur->Next = Next;\r\nCur->ngeneBuffer.Next = PARingBufferNext;\r\nCur = Next;\r\nPARingBufferCur = PARingBufferNext;\r\n}\r\nCur->Next = Head;\r\nCur->ngeneBuffer.Next = PARingBufferHead;\r\ndescr->Head = Head;\r\ndescr->MemSize = MemSize;\r\ndescr->PAHead = PARingBufferHead;\r\ndescr->NumBuffers = NumBuffers;\r\nreturn 0;\r\n}\r\nstatic int AllocateRingBuffers(struct pci_dev *pci_dev,\r\ndma_addr_t of,\r\nstruct SRingBufferDescriptor *pRingBuffer,\r\nu32 Buffer1Length, u32 Buffer2Length)\r\n{\r\ndma_addr_t tmp;\r\nu32 i, j;\r\nint status = 0;\r\nu32 SCListMemSize = pRingBuffer->NumBuffers\r\n* ((Buffer2Length != 0) ? (NUM_SCATTER_GATHER_ENTRIES * 2) :\r\nNUM_SCATTER_GATHER_ENTRIES)\r\n* sizeof(struct HW_SCATTER_GATHER_ELEMENT);\r\nu64 PASCListMem;\r\nstruct HW_SCATTER_GATHER_ELEMENT *SCListEntry;\r\nu64 PASCListEntry;\r\nstruct SBufferHeader *Cur;\r\nvoid *SCListMem;\r\nif (SCListMemSize < 4096)\r\nSCListMemSize = 4096;\r\nSCListMem = pci_alloc_consistent(pci_dev, SCListMemSize, &tmp);\r\nPASCListMem = tmp;\r\nif (SCListMem == NULL)\r\nreturn -ENOMEM;\r\nmemset(SCListMem, 0, SCListMemSize);\r\npRingBuffer->SCListMem = SCListMem;\r\npRingBuffer->PASCListMem = PASCListMem;\r\npRingBuffer->SCListMemSize = SCListMemSize;\r\npRingBuffer->Buffer1Length = Buffer1Length;\r\npRingBuffer->Buffer2Length = Buffer2Length;\r\nSCListEntry = SCListMem;\r\nPASCListEntry = PASCListMem;\r\nCur = pRingBuffer->Head;\r\nfor (i = 0; i < pRingBuffer->NumBuffers; i += 1, Cur = Cur->Next) {\r\nu64 PABuffer;\r\nvoid *Buffer = pci_alloc_consistent(pci_dev, Buffer1Length,\r\n&tmp);\r\nPABuffer = tmp;\r\nif (Buffer == NULL)\r\nreturn -ENOMEM;\r\nCur->Buffer1 = Buffer;\r\nSCListEntry->Address = PABuffer;\r\nSCListEntry->Length = Buffer1Length;\r\nCur->scList1 = SCListEntry;\r\nCur->ngeneBuffer.Address_of_first_entry_1 = PASCListEntry;\r\nCur->ngeneBuffer.Number_of_entries_1 =\r\nNUM_SCATTER_GATHER_ENTRIES;\r\nSCListEntry += 1;\r\nPASCListEntry += sizeof(struct HW_SCATTER_GATHER_ELEMENT);\r\n#if NUM_SCATTER_GATHER_ENTRIES > 1\r\nfor (j = 0; j < NUM_SCATTER_GATHER_ENTRIES - 1; j += 1) {\r\nSCListEntry->Address = of;\r\nSCListEntry->Length = OVERFLOW_BUFFER_SIZE;\r\nSCListEntry += 1;\r\nPASCListEntry +=\r\nsizeof(struct HW_SCATTER_GATHER_ELEMENT);\r\n}\r\n#endif\r\nif (!Buffer2Length)\r\ncontinue;\r\nBuffer = pci_alloc_consistent(pci_dev, Buffer2Length, &tmp);\r\nPABuffer = tmp;\r\nif (Buffer == NULL)\r\nreturn -ENOMEM;\r\nCur->Buffer2 = Buffer;\r\nSCListEntry->Address = PABuffer;\r\nSCListEntry->Length = Buffer2Length;\r\nCur->scList2 = SCListEntry;\r\nCur->ngeneBuffer.Address_of_first_entry_2 = PASCListEntry;\r\nCur->ngeneBuffer.Number_of_entries_2 =\r\nNUM_SCATTER_GATHER_ENTRIES;\r\nSCListEntry += 1;\r\nPASCListEntry += sizeof(struct HW_SCATTER_GATHER_ELEMENT);\r\n#if NUM_SCATTER_GATHER_ENTRIES > 1\r\nfor (j = 0; j < NUM_SCATTER_GATHER_ENTRIES - 1; j++) {\r\nSCListEntry->Address = of;\r\nSCListEntry->Length = OVERFLOW_BUFFER_SIZE;\r\nSCListEntry += 1;\r\nPASCListEntry +=\r\nsizeof(struct HW_SCATTER_GATHER_ELEMENT);\r\n}\r\n#endif\r\n}\r\nreturn status;\r\n}\r\nstatic int FillTSIdleBuffer(struct SRingBufferDescriptor *pIdleBuffer,\r\nstruct SRingBufferDescriptor *pRingBuffer)\r\n{\r\nint status = 0;\r\nu32 n = pRingBuffer->NumBuffers;\r\nstruct SBufferHeader *Cur = pRingBuffer->Head;\r\nint i;\r\nfor (i = 0; i < n; i++) {\r\nCur->Buffer2 = pIdleBuffer->Head->Buffer1;\r\nCur->scList2 = pIdleBuffer->Head->scList1;\r\nCur->ngeneBuffer.Address_of_first_entry_2 =\r\npIdleBuffer->Head->ngeneBuffer.\r\nAddress_of_first_entry_1;\r\nCur->ngeneBuffer.Number_of_entries_2 =\r\npIdleBuffer->Head->ngeneBuffer.Number_of_entries_1;\r\nCur = Cur->Next;\r\n}\r\nreturn status;\r\n}\r\nstatic int AllocCommonBuffers(struct ngene *dev)\r\n{\r\nint status = 0, i;\r\ndev->FWInterfaceBuffer = pci_alloc_consistent(dev->pci_dev, 4096,\r\n&dev->PAFWInterfaceBuffer);\r\nif (!dev->FWInterfaceBuffer)\r\nreturn -ENOMEM;\r\ndev->hosttongene = dev->FWInterfaceBuffer;\r\ndev->ngenetohost = dev->FWInterfaceBuffer + 256;\r\ndev->EventBuffer = dev->FWInterfaceBuffer + 512;\r\ndev->OverflowBuffer = pci_alloc_consistent(dev->pci_dev,\r\nOVERFLOW_BUFFER_SIZE,\r\n&dev->PAOverflowBuffer);\r\nif (!dev->OverflowBuffer)\r\nreturn -ENOMEM;\r\nmemset(dev->OverflowBuffer, 0, OVERFLOW_BUFFER_SIZE);\r\nfor (i = STREAM_VIDEOIN1; i < MAX_STREAM; i++) {\r\nint type = dev->card_info->io_type[i];\r\ndev->channel[i].State = KSSTATE_STOP;\r\nif (type & (NGENE_IO_TV | NGENE_IO_HDTV | NGENE_IO_AIN)) {\r\nstatus = create_ring_buffer(dev->pci_dev,\r\n&dev->channel[i].RingBuffer,\r\nRingBufferSizes[i]);\r\nif (status < 0)\r\nbreak;\r\nif (type & (NGENE_IO_TV | NGENE_IO_AIN)) {\r\nstatus = AllocateRingBuffers(dev->pci_dev,\r\ndev->\r\nPAOverflowBuffer,\r\n&dev->channel[i].\r\nRingBuffer,\r\nBuffer1Sizes[i],\r\nBuffer2Sizes[i]);\r\nif (status < 0)\r\nbreak;\r\n} else if (type & NGENE_IO_HDTV) {\r\nstatus = AllocateRingBuffers(dev->pci_dev,\r\ndev->\r\nPAOverflowBuffer,\r\n&dev->channel[i].\r\nRingBuffer,\r\nMAX_HDTV_BUFFER_SIZE,\r\n0);\r\nif (status < 0)\r\nbreak;\r\n}\r\n}\r\nif (type & (NGENE_IO_TSIN | NGENE_IO_TSOUT)) {\r\nstatus = create_ring_buffer(dev->pci_dev,\r\n&dev->channel[i].\r\nTSRingBuffer, RING_SIZE_TS);\r\nif (status < 0)\r\nbreak;\r\nstatus = AllocateRingBuffers(dev->pci_dev,\r\ndev->PAOverflowBuffer,\r\n&dev->channel[i].\r\nTSRingBuffer,\r\nMAX_TS_BUFFER_SIZE, 0);\r\nif (status)\r\nbreak;\r\n}\r\nif (type & NGENE_IO_TSOUT) {\r\nstatus = create_ring_buffer(dev->pci_dev,\r\n&dev->channel[i].\r\nTSIdleBuffer, 1);\r\nif (status < 0)\r\nbreak;\r\nstatus = AllocateRingBuffers(dev->pci_dev,\r\ndev->PAOverflowBuffer,\r\n&dev->channel[i].\r\nTSIdleBuffer,\r\nMAX_TS_BUFFER_SIZE, 0);\r\nif (status)\r\nbreak;\r\nFillTSIdleBuffer(&dev->channel[i].TSIdleBuffer,\r\n&dev->channel[i].TSRingBuffer);\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic void ngene_release_buffers(struct ngene *dev)\r\n{\r\nif (dev->iomem)\r\niounmap(dev->iomem);\r\nfree_common_buffers(dev);\r\nvfree(dev->tsout_buf);\r\nvfree(dev->tsin_buf);\r\nvfree(dev->ain_buf);\r\nvfree(dev->vin_buf);\r\nvfree(dev);\r\n}\r\nstatic int ngene_get_buffers(struct ngene *dev)\r\n{\r\nif (AllocCommonBuffers(dev))\r\nreturn -ENOMEM;\r\nif (dev->card_info->io_type[4] & NGENE_IO_TSOUT) {\r\ndev->tsout_buf = vmalloc(TSOUT_BUF_SIZE);\r\nif (!dev->tsout_buf)\r\nreturn -ENOMEM;\r\ndvb_ringbuffer_init(&dev->tsout_rbuf,\r\ndev->tsout_buf, TSOUT_BUF_SIZE);\r\n}\r\nif (dev->card_info->io_type[2]&NGENE_IO_TSIN) {\r\ndev->tsin_buf = vmalloc(TSIN_BUF_SIZE);\r\nif (!dev->tsin_buf)\r\nreturn -ENOMEM;\r\ndvb_ringbuffer_init(&dev->tsin_rbuf,\r\ndev->tsin_buf, TSIN_BUF_SIZE);\r\n}\r\nif (dev->card_info->io_type[2] & NGENE_IO_AIN) {\r\ndev->ain_buf = vmalloc(AIN_BUF_SIZE);\r\nif (!dev->ain_buf)\r\nreturn -ENOMEM;\r\ndvb_ringbuffer_init(&dev->ain_rbuf, dev->ain_buf, AIN_BUF_SIZE);\r\n}\r\nif (dev->card_info->io_type[0] & NGENE_IO_HDTV) {\r\ndev->vin_buf = vmalloc(VIN_BUF_SIZE);\r\nif (!dev->vin_buf)\r\nreturn -ENOMEM;\r\ndvb_ringbuffer_init(&dev->vin_rbuf, dev->vin_buf, VIN_BUF_SIZE);\r\n}\r\ndev->iomem = ioremap(pci_resource_start(dev->pci_dev, 0),\r\npci_resource_len(dev->pci_dev, 0));\r\nif (!dev->iomem)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void ngene_init(struct ngene *dev)\r\n{\r\nint i;\r\ntasklet_init(&dev->event_tasklet, event_tasklet, (unsigned long)dev);\r\nmemset_io(dev->iomem + 0xc000, 0x00, 0x220);\r\nmemset_io(dev->iomem + 0xc400, 0x00, 0x100);\r\nfor (i = 0; i < MAX_STREAM; i++) {\r\ndev->channel[i].dev = dev;\r\ndev->channel[i].number = i;\r\n}\r\ndev->fw_interface_version = 0;\r\nngwritel(0, NGENE_INT_ENABLE);\r\ndev->icounts = ngreadl(NGENE_INT_COUNTS);\r\ndev->device_version = ngreadl(DEV_VER) & 0x0f;\r\nprintk(KERN_INFO DEVICE_NAME ": Device version %d\n",\r\ndev->device_version);\r\n}\r\nstatic int ngene_load_firm(struct ngene *dev)\r\n{\r\nu32 size;\r\nconst struct firmware *fw = NULL;\r\nu8 *ngene_fw;\r\nchar *fw_name;\r\nint err, version;\r\nversion = dev->card_info->fw_version;\r\nswitch (version) {\r\ndefault:\r\ncase 15:\r\nversion = 15;\r\nsize = 23466;\r\nfw_name = "ngene_15.fw";\r\ndev->cmd_timeout_workaround = true;\r\nbreak;\r\ncase 16:\r\nsize = 23498;\r\nfw_name = "ngene_16.fw";\r\ndev->cmd_timeout_workaround = true;\r\nbreak;\r\ncase 17:\r\nsize = 24446;\r\nfw_name = "ngene_17.fw";\r\ndev->cmd_timeout_workaround = true;\r\nbreak;\r\ncase 18:\r\nsize = 0;\r\nfw_name = "ngene_18.fw";\r\nbreak;\r\n}\r\nif (request_firmware(&fw, fw_name, &dev->pci_dev->dev) < 0) {\r\nprintk(KERN_ERR DEVICE_NAME\r\n": Could not load firmware file %s.\n", fw_name);\r\nprintk(KERN_INFO DEVICE_NAME\r\n": Copy %s to your hotplug directory!\n", fw_name);\r\nreturn -1;\r\n}\r\nif (size == 0)\r\nsize = fw->size;\r\nif (size != fw->size) {\r\nprintk(KERN_ERR DEVICE_NAME\r\n": Firmware %s has invalid size!", fw_name);\r\nerr = -1;\r\n} else {\r\nprintk(KERN_INFO DEVICE_NAME\r\n": Loading firmware file %s.\n", fw_name);\r\nngene_fw = (u8 *) fw->data;\r\nerr = ngene_command_load_firmware(dev, ngene_fw, size);\r\n}\r\nrelease_firmware(fw);\r\nreturn err;\r\n}\r\nstatic void ngene_stop(struct ngene *dev)\r\n{\r\ndown(&dev->cmd_mutex);\r\ni2c_del_adapter(&(dev->channel[0].i2c_adapter));\r\ni2c_del_adapter(&(dev->channel[1].i2c_adapter));\r\nngwritel(0, NGENE_INT_ENABLE);\r\nngwritel(0, NGENE_COMMAND);\r\nngwritel(0, NGENE_COMMAND_HI);\r\nngwritel(0, NGENE_STATUS);\r\nngwritel(0, NGENE_STATUS_HI);\r\nngwritel(0, NGENE_EVENT);\r\nngwritel(0, NGENE_EVENT_HI);\r\nfree_irq(dev->pci_dev->irq, dev);\r\n#ifdef CONFIG_PCI_MSI\r\nif (dev->msi_enabled)\r\npci_disable_msi(dev->pci_dev);\r\n#endif\r\n}\r\nstatic int ngene_buffer_config(struct ngene *dev)\r\n{\r\nint stat;\r\nif (dev->card_info->fw_version >= 17) {\r\nu8 tsin12_config[6] = { 0x60, 0x60, 0x00, 0x00, 0x00, 0x00 };\r\nu8 tsin1234_config[6] = { 0x30, 0x30, 0x00, 0x30, 0x30, 0x00 };\r\nu8 tsio1235_config[6] = { 0x30, 0x30, 0x00, 0x28, 0x00, 0x38 };\r\nu8 *bconf = tsin12_config;\r\nif (dev->card_info->io_type[2]&NGENE_IO_TSIN &&\r\ndev->card_info->io_type[3]&NGENE_IO_TSIN) {\r\nbconf = tsin1234_config;\r\nif (dev->card_info->io_type[4]&NGENE_IO_TSOUT &&\r\ndev->ci.en)\r\nbconf = tsio1235_config;\r\n}\r\nstat = ngene_command_config_free_buf(dev, bconf);\r\n} else {\r\nint bconf = BUFFER_CONFIG_4422;\r\nif (dev->card_info->io_type[3] == NGENE_IO_TSIN)\r\nbconf = BUFFER_CONFIG_3333;\r\nstat = ngene_command_config_buf(dev, bconf);\r\n}\r\nreturn stat;\r\n}\r\nstatic int ngene_start(struct ngene *dev)\r\n{\r\nint stat;\r\nint i;\r\npci_set_master(dev->pci_dev);\r\nngene_init(dev);\r\nstat = request_irq(dev->pci_dev->irq, irq_handler,\r\nIRQF_SHARED, "nGene",\r\n(void *)dev);\r\nif (stat < 0)\r\nreturn stat;\r\ninit_waitqueue_head(&dev->cmd_wq);\r\ninit_waitqueue_head(&dev->tx_wq);\r\ninit_waitqueue_head(&dev->rx_wq);\r\nsema_init(&dev->cmd_mutex, 1);\r\nsema_init(&dev->stream_mutex, 1);\r\nsema_init(&dev->pll_mutex, 1);\r\nsema_init(&dev->i2c_switch_mutex, 1);\r\nspin_lock_init(&dev->cmd_lock);\r\nfor (i = 0; i < MAX_STREAM; i++)\r\nspin_lock_init(&dev->channel[i].state_lock);\r\nngwritel(1, TIMESTAMPS);\r\nngwritel(1, NGENE_INT_ENABLE);\r\nstat = ngene_load_firm(dev);\r\nif (stat < 0)\r\ngoto fail;\r\n#ifdef CONFIG_PCI_MSI\r\nif (pci_msi_enabled() && dev->card_info->msi_supported) {\r\nunsigned long flags;\r\nngwritel(0, NGENE_INT_ENABLE);\r\nfree_irq(dev->pci_dev->irq, dev);\r\nstat = pci_enable_msi(dev->pci_dev);\r\nif (stat) {\r\nprintk(KERN_INFO DEVICE_NAME\r\n": MSI not available\n");\r\nflags = IRQF_SHARED;\r\n} else {\r\nflags = 0;\r\ndev->msi_enabled = true;\r\n}\r\nstat = request_irq(dev->pci_dev->irq, irq_handler,\r\nflags, "nGene", dev);\r\nif (stat < 0)\r\ngoto fail2;\r\nngwritel(1, NGENE_INT_ENABLE);\r\n}\r\n#endif\r\nstat = ngene_i2c_init(dev, 0);\r\nif (stat < 0)\r\ngoto fail;\r\nstat = ngene_i2c_init(dev, 1);\r\nif (stat < 0)\r\ngoto fail;\r\nif (!stat)\r\nreturn stat;\r\nfail:\r\nngwritel(0, NGENE_INT_ENABLE);\r\nfree_irq(dev->pci_dev->irq, dev);\r\n#ifdef CONFIG_PCI_MSI\r\nfail2:\r\nif (dev->msi_enabled)\r\npci_disable_msi(dev->pci_dev);\r\n#endif\r\nreturn stat;\r\n}\r\nstatic void release_channel(struct ngene_channel *chan)\r\n{\r\nstruct dvb_demux *dvbdemux = &chan->demux;\r\nstruct ngene *dev = chan->dev;\r\nif (chan->running)\r\nset_transfer(chan, 0);\r\ntasklet_kill(&chan->demux_tasklet);\r\nif (chan->ci_dev) {\r\ndvb_unregister_device(chan->ci_dev);\r\nchan->ci_dev = NULL;\r\n}\r\nif (chan->fe2)\r\ndvb_unregister_frontend(chan->fe2);\r\nif (chan->fe) {\r\ndvb_unregister_frontend(chan->fe);\r\ndvb_frontend_detach(chan->fe);\r\nchan->fe = NULL;\r\n}\r\nif (chan->has_demux) {\r\ndvb_net_release(&chan->dvbnet);\r\ndvbdemux->dmx.close(&dvbdemux->dmx);\r\ndvbdemux->dmx.remove_frontend(&dvbdemux->dmx,\r\n&chan->hw_frontend);\r\ndvbdemux->dmx.remove_frontend(&dvbdemux->dmx,\r\n&chan->mem_frontend);\r\ndvb_dmxdev_release(&chan->dmxdev);\r\ndvb_dmx_release(&chan->demux);\r\nchan->has_demux = false;\r\n}\r\nif (chan->has_adapter) {\r\ndvb_unregister_adapter(&dev->adapter[chan->number]);\r\nchan->has_adapter = false;\r\n}\r\n}\r\nstatic int init_channel(struct ngene_channel *chan)\r\n{\r\nint ret = 0, nr = chan->number;\r\nstruct dvb_adapter *adapter = NULL;\r\nstruct dvb_demux *dvbdemux = &chan->demux;\r\nstruct ngene *dev = chan->dev;\r\nstruct ngene_info *ni = dev->card_info;\r\nint io = ni->io_type[nr];\r\ntasklet_init(&chan->demux_tasklet, demux_tasklet, (unsigned long)chan);\r\nchan->users = 0;\r\nchan->type = io;\r\nchan->mode = chan->type;\r\nif (io & NGENE_IO_TSIN) {\r\nchan->fe = NULL;\r\nif (ni->demod_attach[nr]) {\r\nret = ni->demod_attach[nr](chan);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nif (chan->fe && ni->tuner_attach[nr]) {\r\nret = ni->tuner_attach[nr](chan);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\n}\r\nif (!dev->ci.en && (io & NGENE_IO_TSOUT))\r\nreturn 0;\r\nif (io & (NGENE_IO_TSIN | NGENE_IO_TSOUT)) {\r\nif (nr >= STREAM_AUDIOIN1)\r\nchan->DataFormatFlags = DF_SWAP32;\r\nif (nr == 0 || !one_adapter || dev->first_adapter == NULL) {\r\nadapter = &dev->adapter[nr];\r\nret = dvb_register_adapter(adapter, "nGene",\r\nTHIS_MODULE,\r\n&chan->dev->pci_dev->dev,\r\nadapter_nr);\r\nif (ret < 0)\r\ngoto err;\r\nif (dev->first_adapter == NULL)\r\ndev->first_adapter = adapter;\r\nchan->has_adapter = true;\r\n} else\r\nadapter = dev->first_adapter;\r\n}\r\nif (dev->ci.en && (io & NGENE_IO_TSOUT)) {\r\ndvb_ca_en50221_init(adapter, dev->ci.en, 0, 1);\r\nset_transfer(chan, 1);\r\nchan->dev->channel[2].DataFormatFlags = DF_SWAP32;\r\nset_transfer(&chan->dev->channel[2], 1);\r\ndvb_register_device(adapter, &chan->ci_dev,\r\n&ngene_dvbdev_ci, (void *) chan,\r\nDVB_DEVICE_SEC);\r\nif (!chan->ci_dev)\r\ngoto err;\r\n}\r\nif (chan->fe) {\r\nif (dvb_register_frontend(adapter, chan->fe) < 0)\r\ngoto err;\r\nchan->has_demux = true;\r\n}\r\nif (chan->fe2) {\r\nif (dvb_register_frontend(adapter, chan->fe2) < 0)\r\ngoto err;\r\nchan->fe2->tuner_priv = chan->fe->tuner_priv;\r\nmemcpy(&chan->fe2->ops.tuner_ops,\r\n&chan->fe->ops.tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\n}\r\nif (chan->has_demux) {\r\nret = my_dvb_dmx_ts_card_init(dvbdemux, "SW demux",\r\nngene_start_feed,\r\nngene_stop_feed, chan);\r\nret = my_dvb_dmxdev_ts_card_init(&chan->dmxdev, &chan->demux,\r\n&chan->hw_frontend,\r\n&chan->mem_frontend, adapter);\r\nret = dvb_net_init(adapter, &chan->dvbnet, &chan->demux.dmx);\r\n}\r\nreturn ret;\r\nerr:\r\nif (chan->fe) {\r\ndvb_frontend_detach(chan->fe);\r\nchan->fe = NULL;\r\n}\r\nrelease_channel(chan);\r\nreturn 0;\r\n}\r\nstatic int init_channels(struct ngene *dev)\r\n{\r\nint i, j;\r\nfor (i = 0; i < MAX_STREAM; i++) {\r\ndev->channel[i].number = i;\r\nif (init_channel(&dev->channel[i]) < 0) {\r\nfor (j = i - 1; j >= 0; j--)\r\nrelease_channel(&dev->channel[j]);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void cxd_attach(struct ngene *dev)\r\n{\r\nstruct ngene_ci *ci = &dev->ci;\r\nci->en = cxd2099_attach(&cxd_cfg, dev, &dev->channel[0].i2c_adapter);\r\nci->dev = dev;\r\nreturn;\r\n}\r\nstatic void cxd_detach(struct ngene *dev)\r\n{\r\nstruct ngene_ci *ci = &dev->ci;\r\ndvb_ca_en50221_release(ci->en);\r\nkfree(ci->en);\r\nci->en = 0;\r\n}\r\nstatic void ngene_unlink(struct ngene *dev)\r\n{\r\nstruct ngene_command com;\r\ncom.cmd.hdr.Opcode = CMD_MEM_WRITE;\r\ncom.cmd.hdr.Length = 3;\r\ncom.cmd.MemoryWrite.address = 0x910c;\r\ncom.cmd.MemoryWrite.data = 0xff;\r\ncom.in_len = 3;\r\ncom.out_len = 1;\r\ndown(&dev->cmd_mutex);\r\nngwritel(0, NGENE_INT_ENABLE);\r\nngene_command_mutex(dev, &com);\r\nup(&dev->cmd_mutex);\r\n}\r\nvoid ngene_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct ngene *dev = (struct ngene *)pci_get_drvdata(pdev);\r\nif (!dev || !shutdown_workaround)\r\nreturn;\r\nprintk(KERN_INFO DEVICE_NAME ": shutdown workaround...\n");\r\nngene_unlink(dev);\r\npci_disable_device(pdev);\r\n}\r\nvoid __devexit ngene_remove(struct pci_dev *pdev)\r\n{\r\nstruct ngene *dev = pci_get_drvdata(pdev);\r\nint i;\r\ntasklet_kill(&dev->event_tasklet);\r\nfor (i = MAX_STREAM - 1; i >= 0; i--)\r\nrelease_channel(&dev->channel[i]);\r\nif (dev->ci.en)\r\ncxd_detach(dev);\r\nngene_stop(dev);\r\nngene_release_buffers(dev);\r\npci_set_drvdata(pdev, NULL);\r\npci_disable_device(pdev);\r\n}\r\nint __devinit ngene_probe(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct ngene *dev;\r\nint stat = 0;\r\nif (pci_enable_device(pci_dev) < 0)\r\nreturn -ENODEV;\r\ndev = vzalloc(sizeof(struct ngene));\r\nif (dev == NULL) {\r\nstat = -ENOMEM;\r\ngoto fail0;\r\n}\r\ndev->pci_dev = pci_dev;\r\ndev->card_info = (struct ngene_info *)id->driver_data;\r\nprintk(KERN_INFO DEVICE_NAME ": Found %s\n", dev->card_info->name);\r\npci_set_drvdata(pci_dev, dev);\r\nstat = ngene_get_buffers(dev);\r\nif (stat < 0)\r\ngoto fail1;\r\nstat = ngene_start(dev);\r\nif (stat < 0)\r\ngoto fail1;\r\ncxd_attach(dev);\r\nstat = ngene_buffer_config(dev);\r\nif (stat < 0)\r\ngoto fail1;\r\ndev->i2c_current_bus = -1;\r\nif (init_channels(dev) < 0)\r\ngoto fail2;\r\nreturn 0;\r\nfail2:\r\nngene_stop(dev);\r\nfail1:\r\nngene_release_buffers(dev);\r\nfail0:\r\npci_disable_device(pci_dev);\r\npci_set_drvdata(pci_dev, NULL);\r\nreturn stat;\r\n}
