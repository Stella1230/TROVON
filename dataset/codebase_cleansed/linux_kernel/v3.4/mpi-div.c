int mpi_fdiv_r(MPI rem, MPI dividend, MPI divisor)\r\n{\r\nint rc = -ENOMEM;\r\nint divisor_sign = divisor->sign;\r\nMPI temp_divisor = NULL;\r\nif (rem == divisor) {\r\nif (mpi_copy(&temp_divisor, divisor) < 0)\r\ngoto nomem;\r\ndivisor = temp_divisor;\r\n}\r\nif (mpi_tdiv_qr(NULL, rem, dividend, divisor) < 0)\r\ngoto nomem;\r\nif (((divisor_sign ? 1 : 0) ^ (dividend->sign ? 1 : 0)) && rem->nlimbs)\r\nif (mpi_add(rem, rem, divisor) < 0)\r\ngoto nomem;\r\nrc = 0;\r\nnomem:\r\nif (temp_divisor)\r\nmpi_free(temp_divisor);\r\nreturn rc;\r\n}\r\nulong mpi_fdiv_r_ui(MPI rem, MPI dividend, ulong divisor)\r\n{\r\nmpi_limb_t rlimb;\r\nrlimb = mpihelp_mod_1(dividend->d, dividend->nlimbs, divisor);\r\nif (rlimb && dividend->sign)\r\nrlimb = divisor - rlimb;\r\nif (rem) {\r\nrem->d[0] = rlimb;\r\nrem->nlimbs = rlimb ? 1 : 0;\r\n}\r\nreturn rlimb;\r\n}\r\nint mpi_fdiv_q(MPI quot, MPI dividend, MPI divisor)\r\n{\r\nMPI tmp = mpi_alloc(mpi_get_nlimbs(quot));\r\nif (!tmp)\r\nreturn -ENOMEM;\r\nmpi_fdiv_qr(quot, tmp, dividend, divisor);\r\nmpi_free(tmp);\r\nreturn 0;\r\n}\r\nint mpi_fdiv_qr(MPI quot, MPI rem, MPI dividend, MPI divisor)\r\n{\r\nint divisor_sign = divisor->sign;\r\nMPI temp_divisor = NULL;\r\nif (quot == divisor || rem == divisor) {\r\nif (mpi_copy(&temp_divisor, divisor) < 0)\r\nreturn -ENOMEM;\r\ndivisor = temp_divisor;\r\n}\r\nif (mpi_tdiv_qr(quot, rem, dividend, divisor) < 0)\r\ngoto nomem;\r\nif ((divisor_sign ^ dividend->sign) && rem->nlimbs) {\r\nif (mpi_sub_ui(quot, quot, 1) < 0)\r\ngoto nomem;\r\nif (mpi_add(rem, rem, divisor) < 0)\r\ngoto nomem;\r\n}\r\nif (temp_divisor)\r\nmpi_free(temp_divisor);\r\nreturn 0;\r\nnomem:\r\nmpi_free(temp_divisor);\r\nreturn -ENOMEM;\r\n}\r\nint mpi_tdiv_r(MPI rem, MPI num, MPI den)\r\n{\r\nreturn mpi_tdiv_qr(NULL, rem, num, den);\r\n}\r\nint mpi_tdiv_qr(MPI quot, MPI rem, MPI num, MPI den)\r\n{\r\nint rc = -ENOMEM;\r\nmpi_ptr_t np, dp;\r\nmpi_ptr_t qp, rp;\r\nmpi_size_t nsize = num->nlimbs;\r\nmpi_size_t dsize = den->nlimbs;\r\nmpi_size_t qsize, rsize;\r\nmpi_size_t sign_remainder = num->sign;\r\nmpi_size_t sign_quotient = num->sign ^ den->sign;\r\nunsigned normalization_steps;\r\nmpi_limb_t q_limb;\r\nmpi_ptr_t marker[5];\r\nint markidx = 0;\r\nif (!dsize)\r\nreturn -EINVAL;\r\nmemset(marker, 0, sizeof(marker));\r\nrsize = nsize + 1;\r\nif (mpi_resize(rem, rsize) < 0)\r\ngoto nomem;\r\nqsize = rsize - dsize;\r\nif (qsize <= 0) {\r\nif (num != rem) {\r\nrem->nlimbs = num->nlimbs;\r\nrem->sign = num->sign;\r\nMPN_COPY(rem->d, num->d, nsize);\r\n}\r\nif (quot) {\r\nquot->nlimbs = 0;\r\nquot->sign = 0;\r\n}\r\nreturn 0;\r\n}\r\nif (quot)\r\nif (mpi_resize(quot, qsize) < 0)\r\ngoto nomem;\r\nnp = num->d;\r\ndp = den->d;\r\nrp = rem->d;\r\nif (dsize == 1) {\r\nmpi_limb_t rlimb;\r\nif (quot) {\r\nqp = quot->d;\r\nrlimb = mpihelp_divmod_1(qp, np, nsize, dp[0]);\r\nqsize -= qp[qsize - 1] == 0;\r\nquot->nlimbs = qsize;\r\nquot->sign = sign_quotient;\r\n} else\r\nrlimb = mpihelp_mod_1(np, nsize, dp[0]);\r\nrp[0] = rlimb;\r\nrsize = rlimb != 0 ? 1 : 0;\r\nrem->nlimbs = rsize;\r\nrem->sign = sign_remainder;\r\nreturn 0;\r\n}\r\nif (quot) {\r\nqp = quot->d;\r\nif (qp == np) {\r\nnp = marker[markidx++] = mpi_alloc_limb_space(nsize);\r\nif (!np)\r\ngoto nomem;\r\nMPN_COPY(np, qp, nsize);\r\n}\r\n} else\r\nqp = rp + dsize;\r\ncount_leading_zeros(normalization_steps, dp[dsize - 1]);\r\nif (normalization_steps) {\r\nmpi_ptr_t tp;\r\nmpi_limb_t nlimb;\r\ntp = marker[markidx++] = mpi_alloc_limb_space(dsize);\r\nif (!tp)\r\ngoto nomem;\r\nmpihelp_lshift(tp, dp, dsize, normalization_steps);\r\ndp = tp;\r\nnlimb = mpihelp_lshift(rp, np, nsize, normalization_steps);\r\nif (nlimb) {\r\nrp[nsize] = nlimb;\r\nrsize = nsize + 1;\r\n} else\r\nrsize = nsize;\r\n} else {\r\nif (dp == rp || (quot && (dp == qp))) {\r\nmpi_ptr_t tp;\r\ntp = marker[markidx++] = mpi_alloc_limb_space(dsize);\r\nif (!tp)\r\ngoto nomem;\r\nMPN_COPY(tp, dp, dsize);\r\ndp = tp;\r\n}\r\nif (rp != np)\r\nMPN_COPY(rp, np, nsize);\r\nrsize = nsize;\r\n}\r\nq_limb = mpihelp_divrem(qp, 0, rp, rsize, dp, dsize);\r\nif (quot) {\r\nqsize = rsize - dsize;\r\nif (q_limb) {\r\nqp[qsize] = q_limb;\r\nqsize += 1;\r\n}\r\nquot->nlimbs = qsize;\r\nquot->sign = sign_quotient;\r\n}\r\nrsize = dsize;\r\nMPN_NORMALIZE(rp, rsize);\r\nif (normalization_steps && rsize) {\r\nmpihelp_rshift(rp, rp, rsize, normalization_steps);\r\nrsize -= rp[rsize - 1] == 0 ? 1 : 0;\r\n}\r\nrem->nlimbs = rsize;\r\nrem->sign = sign_remainder;\r\nrc = 0;\r\nnomem:\r\nwhile (markidx)\r\nmpi_free_limb_space(marker[--markidx]);\r\nreturn rc;\r\n}\r\nint mpi_tdiv_q_2exp(MPI w, MPI u, unsigned count)\r\n{\r\nmpi_size_t usize, wsize;\r\nmpi_size_t limb_cnt;\r\nusize = u->nlimbs;\r\nlimb_cnt = count / BITS_PER_MPI_LIMB;\r\nwsize = usize - limb_cnt;\r\nif (limb_cnt >= usize)\r\nw->nlimbs = 0;\r\nelse {\r\nmpi_ptr_t wp;\r\nmpi_ptr_t up;\r\nif (RESIZE_IF_NEEDED(w, wsize) < 0)\r\nreturn -ENOMEM;\r\nwp = w->d;\r\nup = u->d;\r\ncount %= BITS_PER_MPI_LIMB;\r\nif (count) {\r\nmpihelp_rshift(wp, up + limb_cnt, wsize, count);\r\nwsize -= !wp[wsize - 1];\r\n} else {\r\nMPN_COPY_INCR(wp, up + limb_cnt, wsize);\r\n}\r\nw->nlimbs = wsize;\r\n}\r\nreturn 0;\r\n}\r\nint mpi_divisible_ui(MPI dividend, ulong divisor)\r\n{\r\nreturn !mpihelp_mod_1(dividend->d, dividend->nlimbs, divisor);\r\n}
