struct rpc_cred *rpc_lookup_cred(void)\r\n{\r\nreturn rpcauth_lookupcred(&generic_auth, 0);\r\n}\r\nstruct rpc_cred *rpc_lookup_machine_cred(const char *service_name)\r\n{\r\nstruct auth_cred acred = {\r\n.uid = RPC_MACHINE_CRED_USERID,\r\n.gid = RPC_MACHINE_CRED_GROUPID,\r\n.principal = service_name,\r\n.machine_cred = 1,\r\n};\r\ndprintk("RPC: looking up machine cred for service %s\n",\r\nservice_name);\r\nreturn generic_auth.au_ops->lookup_cred(&generic_auth, &acred, 0);\r\n}\r\nstatic struct rpc_cred *generic_bind_cred(struct rpc_task *task,\r\nstruct rpc_cred *cred, int lookupflags)\r\n{\r\nstruct rpc_auth *auth = task->tk_client->cl_auth;\r\nstruct auth_cred *acred = &container_of(cred, struct generic_cred, gc_base)->acred;\r\nreturn auth->au_ops->lookup_cred(auth, acred, lookupflags);\r\n}\r\nstatic struct rpc_cred *\r\ngeneric_lookup_cred(struct rpc_auth *auth, struct auth_cred *acred, int flags)\r\n{\r\nreturn rpcauth_lookup_credcache(&generic_auth, acred, flags);\r\n}\r\nstatic struct rpc_cred *\r\ngeneric_create_cred(struct rpc_auth *auth, struct auth_cred *acred, int flags)\r\n{\r\nstruct generic_cred *gcred;\r\ngcred = kmalloc(sizeof(*gcred), GFP_KERNEL);\r\nif (gcred == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nrpcauth_init_cred(&gcred->gc_base, acred, &generic_auth, &generic_credops);\r\ngcred->gc_base.cr_flags = 1UL << RPCAUTH_CRED_UPTODATE;\r\ngcred->acred.uid = acred->uid;\r\ngcred->acred.gid = acred->gid;\r\ngcred->acred.group_info = acred->group_info;\r\nif (gcred->acred.group_info != NULL)\r\nget_group_info(gcred->acred.group_info);\r\ngcred->acred.machine_cred = acred->machine_cred;\r\ngcred->acred.principal = acred->principal;\r\ndprintk("RPC: allocated %s cred %p for uid %d gid %d\n",\r\ngcred->acred.machine_cred ? "machine" : "generic",\r\ngcred, acred->uid, acred->gid);\r\nreturn &gcred->gc_base;\r\n}\r\nstatic void\r\ngeneric_free_cred(struct rpc_cred *cred)\r\n{\r\nstruct generic_cred *gcred = container_of(cred, struct generic_cred, gc_base);\r\ndprintk("RPC: generic_free_cred %p\n", gcred);\r\nif (gcred->acred.group_info != NULL)\r\nput_group_info(gcred->acred.group_info);\r\nkfree(gcred);\r\n}\r\nstatic void\r\ngeneric_free_cred_callback(struct rcu_head *head)\r\n{\r\nstruct rpc_cred *cred = container_of(head, struct rpc_cred, cr_rcu);\r\ngeneric_free_cred(cred);\r\n}\r\nstatic void\r\ngeneric_destroy_cred(struct rpc_cred *cred)\r\n{\r\ncall_rcu(&cred->cr_rcu, generic_free_cred_callback);\r\n}\r\nstatic int\r\nmachine_cred_match(struct auth_cred *acred, struct generic_cred *gcred, int flags)\r\n{\r\nif (!gcred->acred.machine_cred ||\r\ngcred->acred.principal != acred->principal ||\r\ngcred->acred.uid != acred->uid ||\r\ngcred->acred.gid != acred->gid)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int\r\ngeneric_match(struct auth_cred *acred, struct rpc_cred *cred, int flags)\r\n{\r\nstruct generic_cred *gcred = container_of(cred, struct generic_cred, gc_base);\r\nint i;\r\nif (acred->machine_cred)\r\nreturn machine_cred_match(acred, gcred, flags);\r\nif (gcred->acred.uid != acred->uid ||\r\ngcred->acred.gid != acred->gid ||\r\ngcred->acred.machine_cred != 0)\r\ngoto out_nomatch;\r\nif (gcred->acred.group_info == acred->group_info)\r\ngoto out_match;\r\nif (gcred->acred.group_info->ngroups != acred->group_info->ngroups)\r\ngoto out_nomatch;\r\nfor (i = 0; i < gcred->acred.group_info->ngroups; i++) {\r\nif (GROUP_AT(gcred->acred.group_info, i) !=\r\nGROUP_AT(acred->group_info, i))\r\ngoto out_nomatch;\r\n}\r\nout_match:\r\nreturn 1;\r\nout_nomatch:\r\nreturn 0;\r\n}\r\nint __init rpc_init_generic_auth(void)\r\n{\r\nreturn rpcauth_init_credcache(&generic_auth);\r\n}\r\nvoid rpc_destroy_generic_auth(void)\r\n{\r\nrpcauth_destroy_credcache(&generic_auth);\r\n}
