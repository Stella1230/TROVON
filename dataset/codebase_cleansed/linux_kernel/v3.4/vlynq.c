static void vlynq_dump_regs(struct vlynq_device *dev)\r\n{\r\nint i;\r\nprintk(KERN_DEBUG "VLYNQ local=%p remote=%p\n",\r\ndev->local, dev->remote);\r\nfor (i = 0; i < 32; i++) {\r\nprintk(KERN_DEBUG "VLYNQ: local %d: %08x\n",\r\ni + 1, ((u32 *)dev->local)[i]);\r\nprintk(KERN_DEBUG "VLYNQ: remote %d: %08x\n",\r\ni + 1, ((u32 *)dev->remote)[i]);\r\n}\r\n}\r\nstatic void vlynq_dump_mem(u32 *base, int count)\r\n{\r\nint i;\r\nfor (i = 0; i < (count + 3) / 4; i++) {\r\nif (i % 4 == 0)\r\nprintk(KERN_DEBUG "\nMEM[0x%04x]:", i * 4);\r\nprintk(KERN_DEBUG " 0x%08x", *(base + i));\r\n}\r\nprintk(KERN_DEBUG "\n");\r\n}\r\nstatic int vlynq_linked(struct vlynq_device *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < 100; i++)\r\nif (readl(&dev->local->status) & VLYNQ_STATUS_LINK)\r\nreturn 1;\r\nelse\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nstatic void vlynq_reset(struct vlynq_device *dev)\r\n{\r\nwritel(readl(&dev->local->control) | VLYNQ_CTRL_RESET,\r\n&dev->local->control);\r\nmsleep(5);\r\nwritel(readl(&dev->local->control) & ~VLYNQ_CTRL_RESET,\r\n&dev->local->control);\r\nmsleep(5);\r\n}\r\nstatic void vlynq_irq_unmask(struct irq_data *d)\r\n{\r\nstruct vlynq_device *dev = irq_data_get_irq_chip_data(d);\r\nint virq;\r\nu32 val;\r\nBUG_ON(!dev);\r\nvirq = d->irq - dev->irq_start;\r\nval = readl(&dev->remote->int_device[virq >> 2]);\r\nval |= (VINT_ENABLE | virq) << VINT_OFFSET(virq);\r\nwritel(val, &dev->remote->int_device[virq >> 2]);\r\n}\r\nstatic void vlynq_irq_mask(struct irq_data *d)\r\n{\r\nstruct vlynq_device *dev = irq_data_get_irq_chip_data(d);\r\nint virq;\r\nu32 val;\r\nBUG_ON(!dev);\r\nvirq = d->irq - dev->irq_start;\r\nval = readl(&dev->remote->int_device[virq >> 2]);\r\nval &= ~(VINT_ENABLE << VINT_OFFSET(virq));\r\nwritel(val, &dev->remote->int_device[virq >> 2]);\r\n}\r\nstatic int vlynq_irq_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nstruct vlynq_device *dev = irq_data_get_irq_chip_data(d);\r\nint virq;\r\nu32 val;\r\nBUG_ON(!dev);\r\nvirq = d->irq - dev->irq_start;\r\nval = readl(&dev->remote->int_device[virq >> 2]);\r\nswitch (flow_type & IRQ_TYPE_SENSE_MASK) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nval |= VINT_TYPE_EDGE << VINT_OFFSET(virq);\r\nval &= ~(VINT_LEVEL_LOW << VINT_OFFSET(virq));\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nval &= ~(VINT_TYPE_EDGE << VINT_OFFSET(virq));\r\nval &= ~(VINT_LEVEL_LOW << VINT_OFFSET(virq));\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nval &= ~(VINT_TYPE_EDGE << VINT_OFFSET(virq));\r\nval |= VINT_LEVEL_LOW << VINT_OFFSET(virq);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwritel(val, &dev->remote->int_device[virq >> 2]);\r\nreturn 0;\r\n}\r\nstatic void vlynq_local_ack(struct irq_data *d)\r\n{\r\nstruct vlynq_device *dev = irq_data_get_irq_chip_data(d);\r\nu32 status = readl(&dev->local->status);\r\npr_debug("%s: local status: 0x%08x\n",\r\ndev_name(&dev->dev), status);\r\nwritel(status, &dev->local->status);\r\n}\r\nstatic void vlynq_remote_ack(struct irq_data *d)\r\n{\r\nstruct vlynq_device *dev = irq_data_get_irq_chip_data(d);\r\nu32 status = readl(&dev->remote->status);\r\npr_debug("%s: remote status: 0x%08x\n",\r\ndev_name(&dev->dev), status);\r\nwritel(status, &dev->remote->status);\r\n}\r\nstatic irqreturn_t vlynq_irq(int irq, void *dev_id)\r\n{\r\nstruct vlynq_device *dev = dev_id;\r\nu32 status;\r\nint virq = 0;\r\nstatus = readl(&dev->local->int_status);\r\nwritel(status, &dev->local->int_status);\r\nif (unlikely(!status))\r\nspurious_interrupt();\r\nwhile (status) {\r\nif (status & 1)\r\ndo_IRQ(dev->irq_start + virq);\r\nstatus >>= 1;\r\nvirq++;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int vlynq_setup_irq(struct vlynq_device *dev)\r\n{\r\nu32 val;\r\nint i, virq;\r\nif (dev->local_irq == dev->remote_irq) {\r\nprintk(KERN_ERR\r\n"%s: local vlynq irq should be different from remote\n",\r\ndev_name(&dev->dev));\r\nreturn -EINVAL;\r\n}\r\nwritel(readl(&dev->local->status), &dev->local->status);\r\nwritel(readl(&dev->remote->status), &dev->remote->status);\r\nval = VLYNQ_CTRL_INT_VECTOR(dev->local_irq);\r\nval |= VLYNQ_CTRL_INT_ENABLE | VLYNQ_CTRL_INT_LOCAL |\r\nVLYNQ_CTRL_INT2CFG;\r\nval |= readl(&dev->local->control);\r\nwritel(VLYNQ_INT_OFFSET, &dev->local->int_ptr);\r\nwritel(val, &dev->local->control);\r\nval = VLYNQ_CTRL_INT_VECTOR(dev->remote_irq);\r\nval |= VLYNQ_CTRL_INT_ENABLE;\r\nval |= readl(&dev->remote->control);\r\nwritel(VLYNQ_INT_OFFSET, &dev->remote->int_ptr);\r\nwritel(val, &dev->remote->int_ptr);\r\nwritel(val, &dev->remote->control);\r\nfor (i = dev->irq_start; i <= dev->irq_end; i++) {\r\nvirq = i - dev->irq_start;\r\nif (virq == dev->local_irq) {\r\nirq_set_chip_and_handler(i, &vlynq_local_chip,\r\nhandle_level_irq);\r\nirq_set_chip_data(i, dev);\r\n} else if (virq == dev->remote_irq) {\r\nirq_set_chip_and_handler(i, &vlynq_remote_chip,\r\nhandle_level_irq);\r\nirq_set_chip_data(i, dev);\r\n} else {\r\nirq_set_chip_and_handler(i, &vlynq_irq_chip,\r\nhandle_simple_irq);\r\nirq_set_chip_data(i, dev);\r\nwritel(0, &dev->remote->int_device[virq >> 2]);\r\n}\r\n}\r\nif (request_irq(dev->irq, vlynq_irq, IRQF_SHARED, "vlynq", dev)) {\r\nprintk(KERN_ERR "%s: request_irq failed\n",\r\ndev_name(&dev->dev));\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vlynq_device_release(struct device *dev)\r\n{\r\nstruct vlynq_device *vdev = to_vlynq_device(dev);\r\nkfree(vdev);\r\n}\r\nstatic int vlynq_device_match(struct device *dev,\r\nstruct device_driver *drv)\r\n{\r\nstruct vlynq_device *vdev = to_vlynq_device(dev);\r\nstruct vlynq_driver *vdrv = to_vlynq_driver(drv);\r\nstruct vlynq_device_id *ids = vdrv->id_table;\r\nwhile (ids->id) {\r\nif (ids->id == vdev->dev_id) {\r\nvdev->divisor = ids->divisor;\r\nvlynq_set_drvdata(vdev, ids);\r\nprintk(KERN_INFO "Driver found for VLYNQ "\r\n"device: %08x\n", vdev->dev_id);\r\nreturn 1;\r\n}\r\nprintk(KERN_DEBUG "Not using the %08x VLYNQ device's driver"\r\n" for VLYNQ device: %08x\n", ids->id, vdev->dev_id);\r\nids++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vlynq_device_probe(struct device *dev)\r\n{\r\nstruct vlynq_device *vdev = to_vlynq_device(dev);\r\nstruct vlynq_driver *drv = to_vlynq_driver(dev->driver);\r\nstruct vlynq_device_id *id = vlynq_get_drvdata(vdev);\r\nint result = -ENODEV;\r\nif (drv->probe)\r\nresult = drv->probe(vdev, id);\r\nif (result)\r\nput_device(dev);\r\nreturn result;\r\n}\r\nstatic int vlynq_device_remove(struct device *dev)\r\n{\r\nstruct vlynq_driver *drv = to_vlynq_driver(dev->driver);\r\nif (drv->remove)\r\ndrv->remove(to_vlynq_device(dev));\r\nreturn 0;\r\n}\r\nint __vlynq_register_driver(struct vlynq_driver *driver, struct module *owner)\r\n{\r\ndriver->driver.name = driver->name;\r\ndriver->driver.bus = &vlynq_bus_type;\r\nreturn driver_register(&driver->driver);\r\n}\r\nvoid vlynq_unregister_driver(struct vlynq_driver *driver)\r\n{\r\ndriver_unregister(&driver->driver);\r\n}\r\nstatic int __vlynq_try_remote(struct vlynq_device *dev)\r\n{\r\nint i;\r\nvlynq_reset(dev);\r\nfor (i = dev->dev_id ? vlynq_rdiv2 : vlynq_rdiv8; dev->dev_id ?\r\ni <= vlynq_rdiv8 : i >= vlynq_rdiv2;\r\ndev->dev_id ? i++ : i--) {\r\nif (!vlynq_linked(dev))\r\nbreak;\r\nwritel((readl(&dev->remote->control) &\r\n~VLYNQ_CTRL_CLOCK_MASK) |\r\nVLYNQ_CTRL_CLOCK_INT |\r\nVLYNQ_CTRL_CLOCK_DIV(i - vlynq_rdiv1),\r\n&dev->remote->control);\r\nwritel((readl(&dev->local->control)\r\n& ~(VLYNQ_CTRL_CLOCK_INT |\r\nVLYNQ_CTRL_CLOCK_MASK)) |\r\nVLYNQ_CTRL_CLOCK_DIV(i - vlynq_rdiv1),\r\n&dev->local->control);\r\nif (vlynq_linked(dev)) {\r\nprintk(KERN_DEBUG\r\n"%s: using remote clock divisor %d\n",\r\ndev_name(&dev->dev), i - vlynq_rdiv1 + 1);\r\ndev->divisor = i;\r\nreturn 0;\r\n} else {\r\nvlynq_reset(dev);\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int __vlynq_try_local(struct vlynq_device *dev)\r\n{\r\nint i;\r\nvlynq_reset(dev);\r\nfor (i = dev->dev_id ? vlynq_ldiv2 : vlynq_ldiv8; dev->dev_id ?\r\ni <= vlynq_ldiv8 : i >= vlynq_ldiv2;\r\ndev->dev_id ? i++ : i--) {\r\nwritel((readl(&dev->local->control) &\r\n~VLYNQ_CTRL_CLOCK_MASK) |\r\nVLYNQ_CTRL_CLOCK_INT |\r\nVLYNQ_CTRL_CLOCK_DIV(i - vlynq_ldiv1),\r\n&dev->local->control);\r\nif (vlynq_linked(dev)) {\r\nprintk(KERN_DEBUG\r\n"%s: using local clock divisor %d\n",\r\ndev_name(&dev->dev), i - vlynq_ldiv1 + 1);\r\ndev->divisor = i;\r\nreturn 0;\r\n} else {\r\nvlynq_reset(dev);\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int __vlynq_try_external(struct vlynq_device *dev)\r\n{\r\nvlynq_reset(dev);\r\nif (!vlynq_linked(dev))\r\nreturn -ENODEV;\r\nwritel((readl(&dev->remote->control) &\r\n~VLYNQ_CTRL_CLOCK_INT),\r\n&dev->remote->control);\r\nwritel((readl(&dev->local->control) &\r\n~VLYNQ_CTRL_CLOCK_INT),\r\n&dev->local->control);\r\nif (vlynq_linked(dev)) {\r\nprintk(KERN_DEBUG "%s: using external clock\n",\r\ndev_name(&dev->dev));\r\ndev->divisor = vlynq_div_external;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int __vlynq_enable_device(struct vlynq_device *dev)\r\n{\r\nint result;\r\nstruct plat_vlynq_ops *ops = dev->dev.platform_data;\r\nresult = ops->on(dev);\r\nif (result)\r\nreturn result;\r\nswitch (dev->divisor) {\r\ncase vlynq_div_external:\r\ncase vlynq_div_auto:\r\nif (vlynq_linked(dev) && readl(&dev->remote->control) &\r\nVLYNQ_CTRL_CLOCK_INT) {\r\nif (!__vlynq_try_remote(dev) ||\r\n!__vlynq_try_local(dev) ||\r\n!__vlynq_try_external(dev))\r\nreturn 0;\r\n} else {\r\nif (!__vlynq_try_external(dev) ||\r\n!__vlynq_try_local(dev) ||\r\n!__vlynq_try_remote(dev))\r\nreturn 0;\r\n}\r\nbreak;\r\ncase vlynq_ldiv1:\r\ncase vlynq_ldiv2:\r\ncase vlynq_ldiv3:\r\ncase vlynq_ldiv4:\r\ncase vlynq_ldiv5:\r\ncase vlynq_ldiv6:\r\ncase vlynq_ldiv7:\r\ncase vlynq_ldiv8:\r\nwritel(VLYNQ_CTRL_CLOCK_INT |\r\nVLYNQ_CTRL_CLOCK_DIV(dev->divisor -\r\nvlynq_ldiv1), &dev->local->control);\r\nwritel(0, &dev->remote->control);\r\nif (vlynq_linked(dev)) {\r\nprintk(KERN_DEBUG\r\n"%s: using local clock divisor %d\n",\r\ndev_name(&dev->dev),\r\ndev->divisor - vlynq_ldiv1 + 1);\r\nreturn 0;\r\n}\r\nbreak;\r\ncase vlynq_rdiv1:\r\ncase vlynq_rdiv2:\r\ncase vlynq_rdiv3:\r\ncase vlynq_rdiv4:\r\ncase vlynq_rdiv5:\r\ncase vlynq_rdiv6:\r\ncase vlynq_rdiv7:\r\ncase vlynq_rdiv8:\r\nwritel(0, &dev->local->control);\r\nwritel(VLYNQ_CTRL_CLOCK_INT |\r\nVLYNQ_CTRL_CLOCK_DIV(dev->divisor -\r\nvlynq_rdiv1), &dev->remote->control);\r\nif (vlynq_linked(dev)) {\r\nprintk(KERN_DEBUG\r\n"%s: using remote clock divisor %d\n",\r\ndev_name(&dev->dev),\r\ndev->divisor - vlynq_rdiv1 + 1);\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\nops->off(dev);\r\nreturn -ENODEV;\r\n}\r\nint vlynq_enable_device(struct vlynq_device *dev)\r\n{\r\nstruct plat_vlynq_ops *ops = dev->dev.platform_data;\r\nint result = -ENODEV;\r\nresult = __vlynq_enable_device(dev);\r\nif (result)\r\nreturn result;\r\nresult = vlynq_setup_irq(dev);\r\nif (result)\r\nops->off(dev);\r\ndev->enabled = !result;\r\nreturn result;\r\n}\r\nvoid vlynq_disable_device(struct vlynq_device *dev)\r\n{\r\nstruct plat_vlynq_ops *ops = dev->dev.platform_data;\r\ndev->enabled = 0;\r\nfree_irq(dev->irq, dev);\r\nops->off(dev);\r\n}\r\nint vlynq_set_local_mapping(struct vlynq_device *dev, u32 tx_offset,\r\nstruct vlynq_mapping *mapping)\r\n{\r\nint i;\r\nif (!dev->enabled)\r\nreturn -ENXIO;\r\nwritel(tx_offset, &dev->local->tx_offset);\r\nfor (i = 0; i < 4; i++) {\r\nwritel(mapping[i].offset, &dev->local->rx_mapping[i].offset);\r\nwritel(mapping[i].size, &dev->local->rx_mapping[i].size);\r\n}\r\nreturn 0;\r\n}\r\nint vlynq_set_remote_mapping(struct vlynq_device *dev, u32 tx_offset,\r\nstruct vlynq_mapping *mapping)\r\n{\r\nint i;\r\nif (!dev->enabled)\r\nreturn -ENXIO;\r\nwritel(tx_offset, &dev->remote->tx_offset);\r\nfor (i = 0; i < 4; i++) {\r\nwritel(mapping[i].offset, &dev->remote->rx_mapping[i].offset);\r\nwritel(mapping[i].size, &dev->remote->rx_mapping[i].size);\r\n}\r\nreturn 0;\r\n}\r\nint vlynq_set_local_irq(struct vlynq_device *dev, int virq)\r\n{\r\nint irq = dev->irq_start + virq;\r\nif (dev->enabled)\r\nreturn -EBUSY;\r\nif ((irq < dev->irq_start) || (irq > dev->irq_end))\r\nreturn -EINVAL;\r\nif (virq == dev->remote_irq)\r\nreturn -EINVAL;\r\ndev->local_irq = virq;\r\nreturn 0;\r\n}\r\nint vlynq_set_remote_irq(struct vlynq_device *dev, int virq)\r\n{\r\nint irq = dev->irq_start + virq;\r\nif (dev->enabled)\r\nreturn -EBUSY;\r\nif ((irq < dev->irq_start) || (irq > dev->irq_end))\r\nreturn -EINVAL;\r\nif (virq == dev->local_irq)\r\nreturn -EINVAL;\r\ndev->remote_irq = virq;\r\nreturn 0;\r\n}\r\nstatic int vlynq_probe(struct platform_device *pdev)\r\n{\r\nstruct vlynq_device *dev;\r\nstruct resource *regs_res, *mem_res, *irq_res;\r\nint len, result;\r\nregs_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "regs");\r\nif (!regs_res)\r\nreturn -ENODEV;\r\nmem_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mem");\r\nif (!mem_res)\r\nreturn -ENODEV;\r\nirq_res = platform_get_resource_byname(pdev, IORESOURCE_IRQ, "devirq");\r\nif (!irq_res)\r\nreturn -ENODEV;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nprintk(KERN_ERR\r\n"vlynq: failed to allocate device structure\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->id = pdev->id;\r\ndev->dev.bus = &vlynq_bus_type;\r\ndev->dev.parent = &pdev->dev;\r\ndev_set_name(&dev->dev, "vlynq%d", dev->id);\r\ndev->dev.platform_data = pdev->dev.platform_data;\r\ndev->dev.release = vlynq_device_release;\r\ndev->regs_start = regs_res->start;\r\ndev->regs_end = regs_res->end;\r\ndev->mem_start = mem_res->start;\r\ndev->mem_end = mem_res->end;\r\nlen = resource_size(regs_res);\r\nif (!request_mem_region(regs_res->start, len, dev_name(&dev->dev))) {\r\nprintk(KERN_ERR "%s: Can't request vlynq registers\n",\r\ndev_name(&dev->dev));\r\nresult = -ENXIO;\r\ngoto fail_request;\r\n}\r\ndev->local = ioremap(regs_res->start, len);\r\nif (!dev->local) {\r\nprintk(KERN_ERR "%s: Can't remap vlynq registers\n",\r\ndev_name(&dev->dev));\r\nresult = -ENXIO;\r\ngoto fail_remap;\r\n}\r\ndev->remote = (struct vlynq_regs *)((void *)dev->local +\r\nVLYNQ_REMOTE_OFFSET);\r\ndev->irq = platform_get_irq_byname(pdev, "irq");\r\ndev->irq_start = irq_res->start;\r\ndev->irq_end = irq_res->end;\r\ndev->local_irq = dev->irq_end - dev->irq_start;\r\ndev->remote_irq = dev->local_irq - 1;\r\nif (device_register(&dev->dev))\r\ngoto fail_register;\r\nplatform_set_drvdata(pdev, dev);\r\nprintk(KERN_INFO "%s: regs 0x%p, irq %d, mem 0x%p\n",\r\ndev_name(&dev->dev), (void *)dev->regs_start, dev->irq,\r\n(void *)dev->mem_start);\r\ndev->dev_id = 0;\r\ndev->divisor = vlynq_div_auto;\r\nresult = __vlynq_enable_device(dev);\r\nif (result == 0) {\r\ndev->dev_id = readl(&dev->remote->chip);\r\n((struct plat_vlynq_ops *)(dev->dev.platform_data))->off(dev);\r\n}\r\nif (dev->dev_id)\r\nprintk(KERN_INFO "Found a VLYNQ device: %08x\n", dev->dev_id);\r\nreturn 0;\r\nfail_register:\r\niounmap(dev->local);\r\nfail_remap:\r\nfail_request:\r\nrelease_mem_region(regs_res->start, len);\r\nkfree(dev);\r\nreturn result;\r\n}\r\nstatic int vlynq_remove(struct platform_device *pdev)\r\n{\r\nstruct vlynq_device *dev = platform_get_drvdata(pdev);\r\ndevice_unregister(&dev->dev);\r\niounmap(dev->local);\r\nrelease_mem_region(dev->regs_start, dev->regs_end - dev->regs_start);\r\nkfree(dev);\r\nreturn 0;\r\n}\r\nstatic int __devinit vlynq_init(void)\r\n{\r\nint res = 0;\r\nres = bus_register(&vlynq_bus_type);\r\nif (res)\r\ngoto fail_bus;\r\nres = platform_driver_register(&vlynq_platform_driver);\r\nif (res)\r\ngoto fail_platform;\r\nreturn 0;\r\nfail_platform:\r\nbus_unregister(&vlynq_bus_type);\r\nfail_bus:\r\nreturn res;\r\n}\r\nstatic void __devexit vlynq_exit(void)\r\n{\r\nplatform_driver_unregister(&vlynq_platform_driver);\r\nbus_unregister(&vlynq_bus_type);\r\n}
