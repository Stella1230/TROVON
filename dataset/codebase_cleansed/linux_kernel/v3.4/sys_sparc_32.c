asmlinkage unsigned long sys_getpagesize(void)\r\n{\r\nreturn PAGE_SIZE;\r\n}\r\nunsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr, unsigned long len, unsigned long pgoff, unsigned long flags)\r\n{\r\nstruct vm_area_struct * vmm;\r\nif (flags & MAP_FIXED) {\r\nif ((flags & MAP_SHARED) &&\r\n((addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1)))\r\nreturn -EINVAL;\r\nreturn addr;\r\n}\r\nif (len > TASK_SIZE - PAGE_SIZE)\r\nreturn -ENOMEM;\r\nif (ARCH_SUN4C && len > 0x20000000)\r\nreturn -ENOMEM;\r\nif (!addr)\r\naddr = TASK_UNMAPPED_BASE;\r\nif (flags & MAP_SHARED)\r\naddr = COLOUR_ALIGN(addr);\r\nelse\r\naddr = PAGE_ALIGN(addr);\r\nfor (vmm = find_vma(current->mm, addr); ; vmm = vmm->vm_next) {\r\nif (ARCH_SUN4C && addr < 0xe0000000 && 0x20000000 - len < addr) {\r\naddr = PAGE_OFFSET;\r\nvmm = find_vma(current->mm, PAGE_OFFSET);\r\n}\r\nif (TASK_SIZE - PAGE_SIZE - len < addr)\r\nreturn -ENOMEM;\r\nif (!vmm || addr + len <= vmm->vm_start)\r\nreturn addr;\r\naddr = vmm->vm_end;\r\nif (flags & MAP_SHARED)\r\naddr = COLOUR_ALIGN(addr);\r\n}\r\n}\r\nasmlinkage int sparc_pipe(struct pt_regs *regs)\r\n{\r\nint fd[2];\r\nint error;\r\nerror = do_pipe_flags(fd, 0);\r\nif (error)\r\ngoto out;\r\nregs->u_regs[UREG_I1] = fd[1];\r\nerror = fd[0];\r\nout:\r\nreturn error;\r\n}\r\nint sparc_mmap_check(unsigned long addr, unsigned long len)\r\n{\r\nif (ARCH_SUN4C &&\r\n(len > 0x20000000 ||\r\n(addr < 0xe0000000 && addr + len > 0x20000000)))\r\nreturn -EINVAL;\r\nif (len > TASK_SIZE - PAGE_SIZE || addr + len > TASK_SIZE - PAGE_SIZE)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nasmlinkage unsigned long sys_mmap2(unsigned long addr, unsigned long len,\r\nunsigned long prot, unsigned long flags, unsigned long fd,\r\nunsigned long pgoff)\r\n{\r\nreturn sys_mmap_pgoff(addr, len, prot, flags, fd,\r\npgoff >> (PAGE_SHIFT - 12));\r\n}\r\nasmlinkage unsigned long sys_mmap(unsigned long addr, unsigned long len,\r\nunsigned long prot, unsigned long flags, unsigned long fd,\r\nunsigned long off)\r\n{\r\nreturn sys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);\r\n}\r\nlong sparc_remap_file_pages(unsigned long start, unsigned long size,\r\nunsigned long prot, unsigned long pgoff,\r\nunsigned long flags)\r\n{\r\nreturn sys_remap_file_pages(start, size, prot,\r\n(pgoff >> (PAGE_SHIFT - 12)), flags);\r\n}\r\nasmlinkage unsigned long\r\nc_sys_nis_syscall (struct pt_regs *regs)\r\n{\r\nstatic int count = 0;\r\nif (count++ > 5)\r\nreturn -ENOSYS;\r\nprintk ("%s[%d]: Unimplemented SPARC system call %d\n",\r\ncurrent->comm, task_pid_nr(current), (int)regs->u_regs[1]);\r\n#ifdef DEBUG_UNIMP_SYSCALL\r\nshow_regs (regs);\r\n#endif\r\nreturn -ENOSYS;\r\n}\r\nasmlinkage void\r\nsparc_breakpoint (struct pt_regs *regs)\r\n{\r\nsiginfo_t info;\r\n#ifdef DEBUG_SPARC_BREAKPOINT\r\nprintk ("TRAP: Entering kernel PC=%x, nPC=%x\n", regs->pc, regs->npc);\r\n#endif\r\ninfo.si_signo = SIGTRAP;\r\ninfo.si_errno = 0;\r\ninfo.si_code = TRAP_BRKPT;\r\ninfo.si_addr = (void __user *)regs->pc;\r\ninfo.si_trapno = 0;\r\nforce_sig_info(SIGTRAP, &info, current);\r\n#ifdef DEBUG_SPARC_BREAKPOINT\r\nprintk ("TRAP: Returning to space: PC=%x nPC=%x\n", regs->pc, regs->npc);\r\n#endif\r\n}\r\nasmlinkage int\r\nsparc_sigaction (int sig, const struct old_sigaction __user *act,\r\nstruct old_sigaction __user *oact)\r\n{\r\nstruct k_sigaction new_ka, old_ka;\r\nint ret;\r\nWARN_ON_ONCE(sig >= 0);\r\nsig = -sig;\r\nif (act) {\r\nunsigned long mask;\r\nif (!access_ok(VERIFY_READ, act, sizeof(*act)) ||\r\n__get_user(new_ka.sa.sa_handler, &act->sa_handler) ||\r\n__get_user(new_ka.sa.sa_restorer, &act->sa_restorer))\r\nreturn -EFAULT;\r\n__get_user(new_ka.sa.sa_flags, &act->sa_flags);\r\n__get_user(mask, &act->sa_mask);\r\nsiginitset(&new_ka.sa.sa_mask, mask);\r\nnew_ka.ka_restorer = NULL;\r\n}\r\nret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\r\nif (!ret && oact) {\r\nif (!access_ok(VERIFY_WRITE, oact, sizeof(*oact)) ||\r\n__put_user(old_ka.sa.sa_handler, &oact->sa_handler) ||\r\n__put_user(old_ka.sa.sa_restorer, &oact->sa_restorer))\r\nreturn -EFAULT;\r\n__put_user(old_ka.sa.sa_flags, &oact->sa_flags);\r\n__put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask);\r\n}\r\nreturn ret;\r\n}\r\nasmlinkage long\r\nsys_rt_sigaction(int sig,\r\nconst struct sigaction __user *act,\r\nstruct sigaction __user *oact,\r\nvoid __user *restorer,\r\nsize_t sigsetsize)\r\n{\r\nstruct k_sigaction new_ka, old_ka;\r\nint ret;\r\nif (sigsetsize != sizeof(sigset_t))\r\nreturn -EINVAL;\r\nif (act) {\r\nnew_ka.ka_restorer = restorer;\r\nif (copy_from_user(&new_ka.sa, act, sizeof(*act)))\r\nreturn -EFAULT;\r\n}\r\nret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\r\nif (!ret && oact) {\r\nif (copy_to_user(oact, &old_ka.sa, sizeof(*oact)))\r\nreturn -EFAULT;\r\n}\r\nreturn ret;\r\n}\r\nasmlinkage int sys_getdomainname(char __user *name, int len)\r\n{\r\nint nlen, err;\r\nif (len < 0)\r\nreturn -EINVAL;\r\ndown_read(&uts_sem);\r\nnlen = strlen(utsname()->domainname) + 1;\r\nerr = -EINVAL;\r\nif (nlen > len)\r\ngoto out;\r\nerr = -EFAULT;\r\nif (!copy_to_user(name, utsname()->domainname, nlen))\r\nerr = 0;\r\nout:\r\nup_read(&uts_sem);\r\nreturn err;\r\n}\r\nint kernel_execve(const char *filename,\r\nconst char *const argv[],\r\nconst char *const envp[])\r\n{\r\nlong __res;\r\nregister long __g1 __asm__ ("g1") = __NR_execve;\r\nregister long __o0 __asm__ ("o0") = (long)(filename);\r\nregister long __o1 __asm__ ("o1") = (long)(argv);\r\nregister long __o2 __asm__ ("o2") = (long)(envp);\r\nasm volatile ("t 0x10\n\t"\r\n"bcc 1f\n\t"\r\n"mov %%o0, %0\n\t"\r\n"sub %%g0, %%o0, %0\n\t"\r\n"1:\n\t"\r\n: "=r" (__res), "=&r" (__o0)\r\n: "1" (__o0), "r" (__o1), "r" (__o2), "r" (__g1)\r\n: "cc");\r\nreturn __res;\r\n}
