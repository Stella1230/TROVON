int edac_pci_get_check_errors(void)\r\n{\r\nreturn check_pci_errors;\r\n}\r\nstatic int edac_pci_get_log_pe(void)\r\n{\r\nreturn edac_pci_log_pe;\r\n}\r\nstatic int edac_pci_get_log_npe(void)\r\n{\r\nreturn edac_pci_log_npe;\r\n}\r\nstatic int edac_pci_get_panic_on_pe(void)\r\n{\r\nreturn edac_pci_panic_on_pe;\r\n}\r\nint edac_pci_get_poll_msec(void)\r\n{\r\nreturn edac_pci_poll_msec;\r\n}\r\nstatic ssize_t instance_pe_count_show(struct edac_pci_ctl_info *pci, char *data)\r\n{\r\nreturn sprintf(data, "%u\n", atomic_read(&pci->counters.pe_count));\r\n}\r\nstatic ssize_t instance_npe_count_show(struct edac_pci_ctl_info *pci,\r\nchar *data)\r\n{\r\nreturn sprintf(data, "%u\n", atomic_read(&pci->counters.npe_count));\r\n}\r\nstatic void edac_pci_instance_release(struct kobject *kobj)\r\n{\r\nstruct edac_pci_ctl_info *pci;\r\ndebugf0("%s()\n", __func__);\r\npci = to_instance(kobj);\r\nkobject_put(edac_pci_top_main_kobj);\r\nkfree(pci);\r\n}\r\nstatic ssize_t edac_pci_instance_show(struct kobject *kobj,\r\nstruct attribute *attr, char *buffer)\r\n{\r\nstruct edac_pci_ctl_info *pci = to_instance(kobj);\r\nstruct instance_attribute *instance_attr = to_instance_attr(attr);\r\nif (instance_attr->show)\r\nreturn instance_attr->show(pci, buffer);\r\nreturn -EIO;\r\n}\r\nstatic ssize_t edac_pci_instance_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *buffer, size_t count)\r\n{\r\nstruct edac_pci_ctl_info *pci = to_instance(kobj);\r\nstruct instance_attribute *instance_attr = to_instance_attr(attr);\r\nif (instance_attr->store)\r\nreturn instance_attr->store(pci, buffer, count);\r\nreturn -EIO;\r\n}\r\nstatic int edac_pci_create_instance_kobj(struct edac_pci_ctl_info *pci, int idx)\r\n{\r\nstruct kobject *main_kobj;\r\nint err;\r\ndebugf0("%s()\n", __func__);\r\nmain_kobj = kobject_get(edac_pci_top_main_kobj);\r\nif (!main_kobj) {\r\nerr = -ENODEV;\r\ngoto error_out;\r\n}\r\nerr = kobject_init_and_add(&pci->kobj, &ktype_pci_instance,\r\nedac_pci_top_main_kobj, "pci%d", idx);\r\nif (err != 0) {\r\ndebugf2("%s() failed to register instance pci%d\n",\r\n__func__, idx);\r\nkobject_put(edac_pci_top_main_kobj);\r\ngoto error_out;\r\n}\r\nkobject_uevent(&pci->kobj, KOBJ_ADD);\r\ndebugf1("%s() Register instance 'pci%d' kobject\n", __func__, idx);\r\nreturn 0;\r\nerror_out:\r\nreturn err;\r\n}\r\nstatic void edac_pci_unregister_sysfs_instance_kobj(\r\nstruct edac_pci_ctl_info *pci)\r\n{\r\ndebugf0("%s()\n", __func__);\r\nkobject_put(&pci->kobj);\r\n}\r\nstatic ssize_t edac_pci_int_show(void *ptr, char *buffer)\r\n{\r\nint *value = ptr;\r\nreturn sprintf(buffer, "%d\n", *value);\r\n}\r\nstatic ssize_t edac_pci_int_store(void *ptr, const char *buffer, size_t count)\r\n{\r\nint *value = ptr;\r\nif (isdigit(*buffer))\r\n*value = simple_strtoul(buffer, NULL, 0);\r\nreturn count;\r\n}\r\nstatic ssize_t edac_pci_dev_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buffer)\r\n{\r\nstruct edac_pci_dev_attribute *edac_pci_dev;\r\nedac_pci_dev = (struct edac_pci_dev_attribute *)attr;\r\nif (edac_pci_dev->show)\r\nreturn edac_pci_dev->show(edac_pci_dev->value, buffer);\r\nreturn -EIO;\r\n}\r\nstatic ssize_t edac_pci_dev_store(struct kobject *kobj,\r\nstruct attribute *attr, const char *buffer,\r\nsize_t count)\r\n{\r\nstruct edac_pci_dev_attribute *edac_pci_dev;\r\nedac_pci_dev = (struct edac_pci_dev_attribute *)attr;\r\nif (edac_pci_dev->show)\r\nreturn edac_pci_dev->store(edac_pci_dev->value, buffer, count);\r\nreturn -EIO;\r\n}\r\nstatic void edac_pci_release_main_kobj(struct kobject *kobj)\r\n{\r\ndebugf0("%s() here to module_put(THIS_MODULE)\n", __func__);\r\nkfree(kobj);\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic int edac_pci_main_kobj_setup(void)\r\n{\r\nint err;\r\nstruct bus_type *edac_subsys;\r\ndebugf0("%s()\n", __func__);\r\nif (atomic_inc_return(&edac_pci_sysfs_refcount) != 1)\r\nreturn 0;\r\nedac_subsys = edac_get_sysfs_subsys();\r\nif (edac_subsys == NULL) {\r\ndebugf1("%s() no edac_subsys\n", __func__);\r\nerr = -ENODEV;\r\ngoto decrement_count_fail;\r\n}\r\nif (!try_module_get(THIS_MODULE)) {\r\ndebugf1("%s() try_module_get() failed\n", __func__);\r\nerr = -ENODEV;\r\ngoto mod_get_fail;\r\n}\r\nedac_pci_top_main_kobj = kzalloc(sizeof(struct kobject), GFP_KERNEL);\r\nif (!edac_pci_top_main_kobj) {\r\ndebugf1("Failed to allocate\n");\r\nerr = -ENOMEM;\r\ngoto kzalloc_fail;\r\n}\r\nerr = kobject_init_and_add(edac_pci_top_main_kobj,\r\n&ktype_edac_pci_main_kobj,\r\n&edac_subsys->dev_root->kobj, "pci");\r\nif (err) {\r\ndebugf1("Failed to register '.../edac/pci'\n");\r\ngoto kobject_init_and_add_fail;\r\n}\r\nkobject_uevent(edac_pci_top_main_kobj, KOBJ_ADD);\r\ndebugf1("Registered '.../edac/pci' kobject\n");\r\nreturn 0;\r\nkobject_init_and_add_fail:\r\nkfree(edac_pci_top_main_kobj);\r\nkzalloc_fail:\r\nmodule_put(THIS_MODULE);\r\nmod_get_fail:\r\nedac_put_sysfs_subsys();\r\ndecrement_count_fail:\r\natomic_dec(&edac_pci_sysfs_refcount);\r\nreturn err;\r\n}\r\nstatic void edac_pci_main_kobj_teardown(void)\r\n{\r\ndebugf0("%s()\n", __func__);\r\nif (atomic_dec_return(&edac_pci_sysfs_refcount) == 0) {\r\ndebugf0("%s() called kobject_put on main kobj\n",\r\n__func__);\r\nkobject_put(edac_pci_top_main_kobj);\r\n}\r\nedac_put_sysfs_subsys();\r\n}\r\nint edac_pci_create_sysfs(struct edac_pci_ctl_info *pci)\r\n{\r\nint err;\r\nstruct kobject *edac_kobj = &pci->kobj;\r\ndebugf0("%s() idx=%d\n", __func__, pci->pci_idx);\r\nerr = edac_pci_main_kobj_setup();\r\nif (err)\r\nreturn err;\r\nerr = edac_pci_create_instance_kobj(pci, pci->pci_idx);\r\nif (err)\r\ngoto unregister_cleanup;\r\nerr = sysfs_create_link(edac_kobj, &pci->dev->kobj, EDAC_PCI_SYMLINK);\r\nif (err) {\r\ndebugf0("%s() sysfs_create_link() returned err= %d\n",\r\n__func__, err);\r\ngoto symlink_fail;\r\n}\r\nreturn 0;\r\nsymlink_fail:\r\nedac_pci_unregister_sysfs_instance_kobj(pci);\r\nunregister_cleanup:\r\nedac_pci_main_kobj_teardown();\r\nreturn err;\r\n}\r\nvoid edac_pci_remove_sysfs(struct edac_pci_ctl_info *pci)\r\n{\r\ndebugf0("%s() index=%d\n", __func__, pci->pci_idx);\r\nsysfs_remove_link(&pci->kobj, EDAC_PCI_SYMLINK);\r\nedac_pci_unregister_sysfs_instance_kobj(pci);\r\ndebugf0("%s() calling edac_pci_main_kobj_teardown()\n", __func__);\r\nedac_pci_main_kobj_teardown();\r\n}\r\nstatic u16 get_pci_parity_status(struct pci_dev *dev, int secondary)\r\n{\r\nint where;\r\nu16 status;\r\nwhere = secondary ? PCI_SEC_STATUS : PCI_STATUS;\r\npci_read_config_word(dev, where, &status);\r\nif (status == 0xFFFF) {\r\nu32 sanity;\r\npci_read_config_dword(dev, 0, &sanity);\r\nif (sanity == 0xFFFFFFFF)\r\nreturn 0;\r\n}\r\nstatus &= PCI_STATUS_DETECTED_PARITY | PCI_STATUS_SIG_SYSTEM_ERROR |\r\nPCI_STATUS_PARITY;\r\nif (status)\r\npci_write_config_word(dev, where, status);\r\nreturn status;\r\n}\r\nstatic void edac_pci_dev_parity_clear(struct pci_dev *dev)\r\n{\r\nu8 header_type;\r\nget_pci_parity_status(dev, 0);\r\npci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);\r\nif ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE)\r\nget_pci_parity_status(dev, 1);\r\n}\r\nstatic void edac_pci_dev_parity_test(struct pci_dev *dev)\r\n{\r\nunsigned long flags;\r\nu16 status;\r\nu8 header_type;\r\nlocal_irq_save(flags);\r\nstatus = get_pci_parity_status(dev, 0);\r\npci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);\r\nlocal_irq_restore(flags);\r\ndebugf4("PCI STATUS= 0x%04x %s\n", status, dev_name(&dev->dev));\r\nif (status && !dev->broken_parity_status) {\r\nif (status & (PCI_STATUS_SIG_SYSTEM_ERROR)) {\r\nedac_printk(KERN_CRIT, EDAC_PCI,\r\n"Signaled System Error on %s\n",\r\npci_name(dev));\r\natomic_inc(&pci_nonparity_count);\r\n}\r\nif (status & (PCI_STATUS_PARITY)) {\r\nedac_printk(KERN_CRIT, EDAC_PCI,\r\n"Master Data Parity Error on %s\n",\r\npci_name(dev));\r\natomic_inc(&pci_parity_count);\r\n}\r\nif (status & (PCI_STATUS_DETECTED_PARITY)) {\r\nedac_printk(KERN_CRIT, EDAC_PCI,\r\n"Detected Parity Error on %s\n",\r\npci_name(dev));\r\natomic_inc(&pci_parity_count);\r\n}\r\n}\r\ndebugf4("PCI HEADER TYPE= 0x%02x %s\n", header_type, dev_name(&dev->dev));\r\nif ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {\r\nstatus = get_pci_parity_status(dev, 1);\r\ndebugf4("PCI SEC_STATUS= 0x%04x %s\n", status, dev_name(&dev->dev));\r\nif (status && !dev->broken_parity_status) {\r\nif (status & (PCI_STATUS_SIG_SYSTEM_ERROR)) {\r\nedac_printk(KERN_CRIT, EDAC_PCI, "Bridge "\r\n"Signaled System Error on %s\n",\r\npci_name(dev));\r\natomic_inc(&pci_nonparity_count);\r\n}\r\nif (status & (PCI_STATUS_PARITY)) {\r\nedac_printk(KERN_CRIT, EDAC_PCI, "Bridge "\r\n"Master Data Parity Error on "\r\n"%s\n", pci_name(dev));\r\natomic_inc(&pci_parity_count);\r\n}\r\nif (status & (PCI_STATUS_DETECTED_PARITY)) {\r\nedac_printk(KERN_CRIT, EDAC_PCI, "Bridge "\r\n"Detected Parity Error on %s\n",\r\npci_name(dev));\r\natomic_inc(&pci_parity_count);\r\n}\r\n}\r\n}\r\n}\r\nstatic inline void edac_pci_dev_parity_iterator(pci_parity_check_fn_t fn)\r\n{\r\nstruct pci_dev *dev = NULL;\r\nwhile ((dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {\r\nfn(dev);\r\n}\r\n}\r\nvoid edac_pci_do_parity_check(void)\r\n{\r\nint before_count;\r\ndebugf3("%s()\n", __func__);\r\nif (!check_pci_errors)\r\nreturn;\r\nbefore_count = atomic_read(&pci_parity_count);\r\nedac_pci_dev_parity_iterator(edac_pci_dev_parity_test);\r\nif (edac_pci_get_panic_on_pe()) {\r\nif (before_count != atomic_read(&pci_parity_count))\r\npanic("EDAC: PCI Parity Error");\r\n}\r\n}\r\nvoid edac_pci_clear_parity_errors(void)\r\n{\r\nedac_pci_dev_parity_iterator(edac_pci_dev_parity_clear);\r\n}\r\nvoid edac_pci_handle_pe(struct edac_pci_ctl_info *pci, const char *msg)\r\n{\r\natomic_inc(&pci->counters.pe_count);\r\nif (edac_pci_get_log_pe())\r\nedac_pci_printk(pci, KERN_WARNING,\r\n"Parity Error ctl: %s %d: %s\n",\r\npci->ctl_name, pci->pci_idx, msg);\r\nedac_pci_do_parity_check();\r\n}\r\nvoid edac_pci_handle_npe(struct edac_pci_ctl_info *pci, const char *msg)\r\n{\r\natomic_inc(&pci->counters.npe_count);\r\nif (edac_pci_get_log_npe())\r\nedac_pci_printk(pci, KERN_WARNING,\r\n"Non-Parity Error ctl: %s %d: %s\n",\r\npci->ctl_name, pci->pci_idx, msg);\r\nedac_pci_do_parity_check();\r\n}
