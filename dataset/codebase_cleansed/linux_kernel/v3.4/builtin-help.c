static enum help_format parse_help_format(const char *format)\r\n{\r\nif (!strcmp(format, "man"))\r\nreturn HELP_FORMAT_MAN;\r\nif (!strcmp(format, "info"))\r\nreturn HELP_FORMAT_INFO;\r\nif (!strcmp(format, "web") || !strcmp(format, "html"))\r\nreturn HELP_FORMAT_WEB;\r\ndie("unrecognized help format '%s'", format);\r\n}\r\nstatic const char *get_man_viewer_info(const char *name)\r\n{\r\nstruct man_viewer_info_list *viewer;\r\nfor (viewer = man_viewer_info_list; viewer; viewer = viewer->next) {\r\nif (!strcasecmp(name, viewer->name))\r\nreturn viewer->info;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int check_emacsclient_version(void)\r\n{\r\nstruct strbuf buffer = STRBUF_INIT;\r\nstruct child_process ec_process;\r\nconst char *argv_ec[] = { "emacsclient", "--version", NULL };\r\nint version;\r\nmemset(&ec_process, 0, sizeof(ec_process));\r\nec_process.argv = argv_ec;\r\nec_process.err = -1;\r\nec_process.stdout_to_stderr = 1;\r\nif (start_command(&ec_process)) {\r\nfprintf(stderr, "Failed to start emacsclient.\n");\r\nreturn -1;\r\n}\r\nstrbuf_read(&buffer, ec_process.err, 20);\r\nclose(ec_process.err);\r\nfinish_command(&ec_process);\r\nif (prefixcmp(buffer.buf, "emacsclient")) {\r\nfprintf(stderr, "Failed to parse emacsclient version.\n");\r\nstrbuf_release(&buffer);\r\nreturn -1;\r\n}\r\nstrbuf_remove(&buffer, 0, strlen("emacsclient"));\r\nversion = atoi(buffer.buf);\r\nif (version < 22) {\r\nfprintf(stderr,\r\n"emacsclient version '%d' too old (< 22).\n",\r\nversion);\r\nstrbuf_release(&buffer);\r\nreturn -1;\r\n}\r\nstrbuf_release(&buffer);\r\nreturn 0;\r\n}\r\nstatic void exec_woman_emacs(const char *path, const char *page)\r\n{\r\nif (!check_emacsclient_version()) {\r\nstruct strbuf man_page = STRBUF_INIT;\r\nif (!path)\r\npath = "emacsclient";\r\nstrbuf_addf(&man_page, "(woman \"%s\")", page);\r\nexeclp(path, "emacsclient", "-e", man_page.buf, NULL);\r\nwarning("failed to exec '%s': %s", path, strerror(errno));\r\n}\r\n}\r\nstatic void exec_man_konqueror(const char *path, const char *page)\r\n{\r\nconst char *display = getenv("DISPLAY");\r\nif (display && *display) {\r\nstruct strbuf man_page = STRBUF_INIT;\r\nconst char *filename = "kfmclient";\r\nif (path) {\r\nconst char *file = strrchr(path, '/');\r\nif (file && !strcmp(file + 1, "konqueror")) {\r\nchar *new = strdup(path);\r\nchar *dest = strrchr(new, '/');\r\nstrcpy(dest + 1, "kfmclient");\r\npath = new;\r\n}\r\nif (file)\r\nfilename = file;\r\n} else\r\npath = "kfmclient";\r\nstrbuf_addf(&man_page, "man:%s(1)", page);\r\nexeclp(path, filename, "newTab", man_page.buf, NULL);\r\nwarning("failed to exec '%s': %s", path, strerror(errno));\r\n}\r\n}\r\nstatic void exec_man_man(const char *path, const char *page)\r\n{\r\nif (!path)\r\npath = "man";\r\nexeclp(path, "man", page, NULL);\r\nwarning("failed to exec '%s': %s", path, strerror(errno));\r\n}\r\nstatic void exec_man_cmd(const char *cmd, const char *page)\r\n{\r\nstruct strbuf shell_cmd = STRBUF_INIT;\r\nstrbuf_addf(&shell_cmd, "%s %s", cmd, page);\r\nexecl("/bin/sh", "sh", "-c", shell_cmd.buf, NULL);\r\nwarning("failed to exec '%s': %s", cmd, strerror(errno));\r\n}\r\nstatic void add_man_viewer(const char *name)\r\n{\r\nstruct man_viewer_list **p = &man_viewer_list;\r\nsize_t len = strlen(name);\r\nwhile (*p)\r\np = &((*p)->next);\r\n*p = zalloc(sizeof(**p) + len + 1);\r\nstrncpy((*p)->name, name, len);\r\n}\r\nstatic int supported_man_viewer(const char *name, size_t len)\r\n{\r\nreturn (!strncasecmp("man", name, len) ||\r\n!strncasecmp("woman", name, len) ||\r\n!strncasecmp("konqueror", name, len));\r\n}\r\nstatic void do_add_man_viewer_info(const char *name,\r\nsize_t len,\r\nconst char *value)\r\n{\r\nstruct man_viewer_info_list *new = zalloc(sizeof(*new) + len + 1);\r\nstrncpy(new->name, name, len);\r\nnew->info = strdup(value);\r\nnew->next = man_viewer_info_list;\r\nman_viewer_info_list = new;\r\n}\r\nstatic int add_man_viewer_path(const char *name,\r\nsize_t len,\r\nconst char *value)\r\n{\r\nif (supported_man_viewer(name, len))\r\ndo_add_man_viewer_info(name, len, value);\r\nelse\r\nwarning("'%s': path for unsupported man viewer.\n"\r\n"Please consider using 'man.<tool>.cmd' instead.",\r\nname);\r\nreturn 0;\r\n}\r\nstatic int add_man_viewer_cmd(const char *name,\r\nsize_t len,\r\nconst char *value)\r\n{\r\nif (supported_man_viewer(name, len))\r\nwarning("'%s': cmd for supported man viewer.\n"\r\n"Please consider using 'man.<tool>.path' instead.",\r\nname);\r\nelse\r\ndo_add_man_viewer_info(name, len, value);\r\nreturn 0;\r\n}\r\nstatic int add_man_viewer_info(const char *var, const char *value)\r\n{\r\nconst char *name = var + 4;\r\nconst char *subkey = strrchr(name, '.');\r\nif (!subkey)\r\nreturn error("Config with no key for man viewer: %s", name);\r\nif (!strcmp(subkey, ".path")) {\r\nif (!value)\r\nreturn config_error_nonbool(var);\r\nreturn add_man_viewer_path(name, subkey - name, value);\r\n}\r\nif (!strcmp(subkey, ".cmd")) {\r\nif (!value)\r\nreturn config_error_nonbool(var);\r\nreturn add_man_viewer_cmd(name, subkey - name, value);\r\n}\r\nwarning("'%s': unsupported man viewer sub key.", subkey);\r\nreturn 0;\r\n}\r\nstatic int perf_help_config(const char *var, const char *value, void *cb)\r\n{\r\nif (!strcmp(var, "help.format")) {\r\nif (!value)\r\nreturn config_error_nonbool(var);\r\nhelp_format = parse_help_format(value);\r\nreturn 0;\r\n}\r\nif (!strcmp(var, "man.viewer")) {\r\nif (!value)\r\nreturn config_error_nonbool(var);\r\nadd_man_viewer(value);\r\nreturn 0;\r\n}\r\nif (!prefixcmp(var, "man."))\r\nreturn add_man_viewer_info(var, value);\r\nreturn perf_default_config(var, value, cb);\r\n}\r\nvoid list_common_cmds_help(void)\r\n{\r\nunsigned int i, longest = 0;\r\nfor (i = 0; i < ARRAY_SIZE(common_cmds); i++) {\r\nif (longest < strlen(common_cmds[i].name))\r\nlongest = strlen(common_cmds[i].name);\r\n}\r\nputs(" The most commonly used perf commands are:");\r\nfor (i = 0; i < ARRAY_SIZE(common_cmds); i++) {\r\nprintf(" %-*s ", longest, common_cmds[i].name);\r\nputs(common_cmds[i].help);\r\n}\r\n}\r\nstatic int is_perf_command(const char *s)\r\n{\r\nreturn is_in_cmdlist(&main_cmds, s) ||\r\nis_in_cmdlist(&other_cmds, s);\r\n}\r\nstatic const char *prepend(const char *prefix, const char *cmd)\r\n{\r\nsize_t pre_len = strlen(prefix);\r\nsize_t cmd_len = strlen(cmd);\r\nchar *p = malloc(pre_len + cmd_len + 1);\r\nmemcpy(p, prefix, pre_len);\r\nstrcpy(p + pre_len, cmd);\r\nreturn p;\r\n}\r\nstatic const char *cmd_to_page(const char *perf_cmd)\r\n{\r\nif (!perf_cmd)\r\nreturn "perf";\r\nelse if (!prefixcmp(perf_cmd, "perf"))\r\nreturn perf_cmd;\r\nelse\r\nreturn prepend("perf-", perf_cmd);\r\n}\r\nstatic void setup_man_path(void)\r\n{\r\nstruct strbuf new_path = STRBUF_INIT;\r\nconst char *old_path = getenv("MANPATH");\r\nstrbuf_addstr(&new_path, system_path(PERF_MAN_PATH));\r\nstrbuf_addch(&new_path, ':');\r\nif (old_path)\r\nstrbuf_addstr(&new_path, old_path);\r\nsetenv("MANPATH", new_path.buf, 1);\r\nstrbuf_release(&new_path);\r\n}\r\nstatic void exec_viewer(const char *name, const char *page)\r\n{\r\nconst char *info = get_man_viewer_info(name);\r\nif (!strcasecmp(name, "man"))\r\nexec_man_man(info, page);\r\nelse if (!strcasecmp(name, "woman"))\r\nexec_woman_emacs(info, page);\r\nelse if (!strcasecmp(name, "konqueror"))\r\nexec_man_konqueror(info, page);\r\nelse if (info)\r\nexec_man_cmd(info, page);\r\nelse\r\nwarning("'%s': unknown man viewer.", name);\r\n}\r\nstatic void show_man_page(const char *perf_cmd)\r\n{\r\nstruct man_viewer_list *viewer;\r\nconst char *page = cmd_to_page(perf_cmd);\r\nconst char *fallback = getenv("PERF_MAN_VIEWER");\r\nsetup_man_path();\r\nfor (viewer = man_viewer_list; viewer; viewer = viewer->next)\r\nexec_viewer(viewer->name, page);\r\nif (fallback)\r\nexec_viewer(fallback, page);\r\nexec_viewer("man", page);\r\ndie("no man viewer handled the request");\r\n}\r\nstatic void show_info_page(const char *perf_cmd)\r\n{\r\nconst char *page = cmd_to_page(perf_cmd);\r\nsetenv("INFOPATH", system_path(PERF_INFO_PATH), 1);\r\nexeclp("info", "info", "perfman", page, NULL);\r\n}\r\nstatic void get_html_page_path(struct strbuf *page_path, const char *page)\r\n{\r\nstruct stat st;\r\nconst char *html_path = system_path(PERF_HTML_PATH);\r\nif (stat(mkpath("%s/perf.html", html_path), &st)\r\n|| !S_ISREG(st.st_mode))\r\ndie("'%s': not a documentation directory.", html_path);\r\nstrbuf_init(page_path, 0);\r\nstrbuf_addf(page_path, "%s/%s.html", html_path, page);\r\n}\r\nstatic void open_html(const char *path)\r\n{\r\nexecl_perf_cmd("web--browse", "-c", "help.browser", path, NULL);\r\n}\r\nstatic void show_html_page(const char *perf_cmd)\r\n{\r\nconst char *page = cmd_to_page(perf_cmd);\r\nstruct strbuf page_path;\r\nget_html_page_path(&page_path, page);\r\nopen_html(page_path.buf);\r\n}\r\nint cmd_help(int argc, const char **argv, const char *prefix __used)\r\n{\r\nconst char *alias;\r\nload_command_list("perf-", &main_cmds, &other_cmds);\r\nperf_config(perf_help_config, NULL);\r\nargc = parse_options(argc, argv, builtin_help_options,\r\nbuiltin_help_usage, 0);\r\nif (show_all) {\r\nprintf("\n usage: %s\n\n", perf_usage_string);\r\nlist_commands("perf commands", &main_cmds, &other_cmds);\r\nprintf(" %s\n\n", perf_more_info_string);\r\nreturn 0;\r\n}\r\nif (!argv[0]) {\r\nprintf("\n usage: %s\n\n", perf_usage_string);\r\nlist_common_cmds_help();\r\nprintf("\n %s\n\n", perf_more_info_string);\r\nreturn 0;\r\n}\r\nalias = alias_lookup(argv[0]);\r\nif (alias && !is_perf_command(argv[0])) {\r\nprintf("`perf %s' is aliased to `%s'\n", argv[0], alias);\r\nreturn 0;\r\n}\r\nswitch (help_format) {\r\ncase HELP_FORMAT_MAN:\r\nshow_man_page(argv[0]);\r\nbreak;\r\ncase HELP_FORMAT_INFO:\r\nshow_info_page(argv[0]);\r\nbreak;\r\ncase HELP_FORMAT_WEB:\r\nshow_html_page(argv[0]);\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}
