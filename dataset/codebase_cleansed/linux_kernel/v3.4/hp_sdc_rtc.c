static void hp_sdc_rtc_isr (int irq, void *dev_id,\r\nuint8_t status, uint8_t data)\r\n{\r\nreturn;\r\n}\r\nstatic int hp_sdc_rtc_do_read_bbrtc (struct rtc_time *rtctm)\r\n{\r\nstruct semaphore tsem;\r\nhp_sdc_transaction t;\r\nuint8_t tseq[91];\r\nint i;\r\ni = 0;\r\nwhile (i < 91) {\r\ntseq[i++] = HP_SDC_ACT_DATAREG |\r\nHP_SDC_ACT_POSTCMD | HP_SDC_ACT_DATAIN;\r\ntseq[i++] = 0x01;\r\ntseq[i] = i / 7;\r\ni++;\r\ntseq[i++] = HP_SDC_CMD_DO_RTCR;\r\ntseq[i++] = 2;\r\ni++; i++;\r\n}\r\ntseq[84] |= HP_SDC_ACT_SEMAPHORE;\r\nt.endidx = 91;\r\nt.seq = tseq;\r\nt.act.semaphore = &tsem;\r\nsema_init(&tsem, 0);\r\nif (hp_sdc_enqueue_transaction(&t)) return -1;\r\ndown_interruptible(&tsem);\r\nif (!((tseq[83] | tseq[90] | tseq[69] | tseq[76] |\r\ntseq[55] | tseq[62] | tseq[34] | tseq[41] |\r\ntseq[20] | tseq[27] | tseq[6] | tseq[13]) & 0x0f))\r\nreturn -1;\r\nmemset(rtctm, 0, sizeof(struct rtc_time));\r\nrtctm->tm_year = (tseq[83] & 0x0f) + (tseq[90] & 0x0f) * 10;\r\nrtctm->tm_mon = (tseq[69] & 0x0f) + (tseq[76] & 0x0f) * 10;\r\nrtctm->tm_mday = (tseq[55] & 0x0f) + (tseq[62] & 0x0f) * 10;\r\nrtctm->tm_wday = (tseq[48] & 0x0f);\r\nrtctm->tm_hour = (tseq[34] & 0x0f) + (tseq[41] & 0x0f) * 10;\r\nrtctm->tm_min = (tseq[20] & 0x0f) + (tseq[27] & 0x0f) * 10;\r\nrtctm->tm_sec = (tseq[6] & 0x0f) + (tseq[13] & 0x0f) * 10;\r\nreturn 0;\r\n}\r\nstatic int hp_sdc_rtc_read_bbrtc (struct rtc_time *rtctm)\r\n{\r\nstruct rtc_time tm, tm_last;\r\nint i = 0;\r\nif (hp_sdc_rtc_do_read_bbrtc(&tm_last)) return -1;\r\nif (hp_sdc_rtc_do_read_bbrtc(&tm)) return -1;\r\nwhile (memcmp(&tm, &tm_last, sizeof(struct rtc_time))) {\r\nif (i++ > 4) return -1;\r\nmemcpy(&tm_last, &tm, sizeof(struct rtc_time));\r\nif (hp_sdc_rtc_do_read_bbrtc(&tm)) return -1;\r\n}\r\nmemcpy(rtctm, &tm, sizeof(struct rtc_time));\r\nreturn 0;\r\n}\r\nstatic int64_t hp_sdc_rtc_read_i8042timer (uint8_t loadcmd, int numreg)\r\n{\r\nhp_sdc_transaction t;\r\nuint8_t tseq[26] = {\r\nHP_SDC_ACT_PRECMD | HP_SDC_ACT_POSTCMD | HP_SDC_ACT_DATAIN,\r\n0,\r\nHP_SDC_CMD_READ_T1, 2, 0, 0,\r\nHP_SDC_ACT_POSTCMD | HP_SDC_ACT_DATAIN,\r\nHP_SDC_CMD_READ_T2, 2, 0, 0,\r\nHP_SDC_ACT_POSTCMD | HP_SDC_ACT_DATAIN,\r\nHP_SDC_CMD_READ_T3, 2, 0, 0,\r\nHP_SDC_ACT_POSTCMD | HP_SDC_ACT_DATAIN,\r\nHP_SDC_CMD_READ_T4, 2, 0, 0,\r\nHP_SDC_ACT_POSTCMD | HP_SDC_ACT_DATAIN,\r\nHP_SDC_CMD_READ_T5, 2, 0, 0\r\n};\r\nt.endidx = numreg * 5;\r\ntseq[1] = loadcmd;\r\ntseq[t.endidx - 4] |= HP_SDC_ACT_SEMAPHORE;\r\nt.seq = tseq;\r\nt.act.semaphore = &i8042tregs;\r\ndown_interruptible(&i8042tregs);\r\nif (hp_sdc_enqueue_transaction(&t)) return -1;\r\ndown_interruptible(&i8042tregs);\r\nup(&i8042tregs);\r\nreturn (tseq[5] |\r\n((uint64_t)(tseq[10]) << 8) | ((uint64_t)(tseq[15]) << 16) |\r\n((uint64_t)(tseq[20]) << 24) | ((uint64_t)(tseq[25]) << 32));\r\n}\r\nstatic inline int hp_sdc_rtc_read_rt(struct timeval *res) {\r\nint64_t raw;\r\nuint32_t tenms;\r\nunsigned int days;\r\nraw = hp_sdc_rtc_read_i8042timer(HP_SDC_CMD_LOAD_RT, 5);\r\nif (raw < 0) return -1;\r\ntenms = (uint32_t)raw & 0xffffff;\r\ndays = (unsigned int)(raw >> 24) & 0xffff;\r\nres->tv_usec = (suseconds_t)(tenms % 100) * 10000;\r\nres->tv_sec = (time_t)(tenms / 100) + days * 86400;\r\nreturn 0;\r\n}\r\nstatic inline int hp_sdc_rtc_read_fhs(struct timeval *res) {\r\nint64_t raw;\r\nunsigned int tenms;\r\nraw = hp_sdc_rtc_read_i8042timer(HP_SDC_CMD_LOAD_FHS, 2);\r\nif (raw < 0) return -1;\r\ntenms = (unsigned int)raw & 0xffff;\r\nres->tv_usec = (suseconds_t)(tenms % 100) * 10000;\r\nres->tv_sec = (time_t)(tenms / 100);\r\nreturn 0;\r\n}\r\nstatic inline int hp_sdc_rtc_read_mt(struct timeval *res) {\r\nint64_t raw;\r\nuint32_t tenms;\r\nraw = hp_sdc_rtc_read_i8042timer(HP_SDC_CMD_LOAD_MT, 3);\r\nif (raw < 0) return -1;\r\ntenms = (uint32_t)raw & 0xffffff;\r\nres->tv_usec = (suseconds_t)(tenms % 100) * 10000;\r\nres->tv_sec = (time_t)(tenms / 100);\r\nreturn 0;\r\n}\r\nstatic inline int hp_sdc_rtc_read_dt(struct timeval *res) {\r\nint64_t raw;\r\nuint32_t tenms;\r\nraw = hp_sdc_rtc_read_i8042timer(HP_SDC_CMD_LOAD_DT, 3);\r\nif (raw < 0) return -1;\r\ntenms = (uint32_t)raw & 0xffffff;\r\nres->tv_usec = (suseconds_t)(tenms % 100) * 10000;\r\nres->tv_sec = (time_t)(tenms / 100);\r\nreturn 0;\r\n}\r\nstatic inline int hp_sdc_rtc_read_ct(struct timeval *res) {\r\nint64_t raw;\r\nuint32_t tenms;\r\nraw = hp_sdc_rtc_read_i8042timer(HP_SDC_CMD_LOAD_CT, 3);\r\nif (raw < 0) return -1;\r\ntenms = (uint32_t)raw & 0xffffff;\r\nres->tv_usec = (suseconds_t)(tenms % 100) * 10000;\r\nres->tv_sec = (time_t)(tenms / 100);\r\nreturn 0;\r\n}\r\nstatic int hp_sdc_rtc_set_rt (struct timeval *setto)\r\n{\r\nuint32_t tenms;\r\nunsigned int days;\r\nhp_sdc_transaction t;\r\nuint8_t tseq[11] = {\r\nHP_SDC_ACT_PRECMD | HP_SDC_ACT_DATAOUT,\r\nHP_SDC_CMD_SET_RTMS, 3, 0, 0, 0,\r\nHP_SDC_ACT_PRECMD | HP_SDC_ACT_DATAOUT,\r\nHP_SDC_CMD_SET_RTD, 2, 0, 0\r\n};\r\nt.endidx = 10;\r\nif (0xffff < setto->tv_sec / 86400) return -1;\r\ndays = setto->tv_sec / 86400;\r\nif (0xffff < setto->tv_usec / 1000000 / 86400) return -1;\r\ndays += ((setto->tv_sec % 86400) + setto->tv_usec / 1000000) / 86400;\r\nif (days > 0xffff) return -1;\r\nif (0xffffff < setto->tv_sec) return -1;\r\ntenms = setto->tv_sec * 100;\r\nif (0xffffff < setto->tv_usec / 10000) return -1;\r\ntenms += setto->tv_usec / 10000;\r\nif (tenms > 0xffffff) return -1;\r\ntseq[3] = (uint8_t)(tenms & 0xff);\r\ntseq[4] = (uint8_t)((tenms >> 8) & 0xff);\r\ntseq[5] = (uint8_t)((tenms >> 16) & 0xff);\r\ntseq[9] = (uint8_t)(days & 0xff);\r\ntseq[10] = (uint8_t)((days >> 8) & 0xff);\r\nt.seq = tseq;\r\nif (hp_sdc_enqueue_transaction(&t)) return -1;\r\nreturn 0;\r\n}\r\nstatic int hp_sdc_rtc_set_fhs (struct timeval *setto)\r\n{\r\nuint32_t tenms;\r\nhp_sdc_transaction t;\r\nuint8_t tseq[5] = {\r\nHP_SDC_ACT_PRECMD | HP_SDC_ACT_DATAOUT,\r\nHP_SDC_CMD_SET_FHS, 2, 0, 0\r\n};\r\nt.endidx = 4;\r\nif (0xffff < setto->tv_sec) return -1;\r\ntenms = setto->tv_sec * 100;\r\nif (0xffff < setto->tv_usec / 10000) return -1;\r\ntenms += setto->tv_usec / 10000;\r\nif (tenms > 0xffff) return -1;\r\ntseq[3] = (uint8_t)(tenms & 0xff);\r\ntseq[4] = (uint8_t)((tenms >> 8) & 0xff);\r\nt.seq = tseq;\r\nif (hp_sdc_enqueue_transaction(&t)) return -1;\r\nreturn 0;\r\n}\r\nstatic int hp_sdc_rtc_set_i8042timer (struct timeval *setto, uint8_t setcmd)\r\n{\r\nuint32_t tenms;\r\nhp_sdc_transaction t;\r\nuint8_t tseq[6] = {\r\nHP_SDC_ACT_PRECMD | HP_SDC_ACT_DATAOUT,\r\n0, 3, 0, 0, 0\r\n};\r\nt.endidx = 6;\r\nif (0xffffff < setto->tv_sec) return -1;\r\ntenms = setto->tv_sec * 100;\r\nif (0xffffff < setto->tv_usec / 10000) return -1;\r\ntenms += setto->tv_usec / 10000;\r\nif (tenms > 0xffffff) return -1;\r\ntseq[1] = setcmd;\r\ntseq[3] = (uint8_t)(tenms & 0xff);\r\ntseq[4] = (uint8_t)((tenms >> 8) & 0xff);\r\ntseq[5] = (uint8_t)((tenms >> 16) & 0xff);\r\nt.seq = tseq;\r\nif (hp_sdc_enqueue_transaction(&t)) {\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t hp_sdc_rtc_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos) {\r\nssize_t retval;\r\nif (count < sizeof(unsigned long))\r\nreturn -EINVAL;\r\nretval = put_user(68, (unsigned long __user *)buf);\r\nreturn retval;\r\n}\r\nstatic unsigned int hp_sdc_rtc_poll(struct file *file, poll_table *wait)\r\n{\r\nunsigned long l;\r\nl = 0;\r\nif (l != 0)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int hp_sdc_rtc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic int hp_sdc_rtc_fasync (int fd, struct file *filp, int on)\r\n{\r\nreturn fasync_helper (fd, filp, on, &hp_sdc_rtc_async_queue);\r\n}\r\nstatic int hp_sdc_rtc_proc_output (char *buf)\r\n{\r\n#define YN(bit) ("no")\r\n#define NY(bit) ("yes")\r\nchar *p;\r\nstruct rtc_time tm;\r\nstruct timeval tv;\r\nmemset(&tm, 0, sizeof(struct rtc_time));\r\np = buf;\r\nif (hp_sdc_rtc_read_bbrtc(&tm)) {\r\np += sprintf(p, "BBRTC\t\t: READ FAILED!\n");\r\n} else {\r\np += sprintf(p,\r\n"rtc_time\t: %02d:%02d:%02d\n"\r\n"rtc_date\t: %04d-%02d-%02d\n"\r\n"rtc_epoch\t: %04lu\n",\r\ntm.tm_hour, tm.tm_min, tm.tm_sec,\r\ntm.tm_year + 1900, tm.tm_mon + 1,\r\ntm.tm_mday, epoch);\r\n}\r\nif (hp_sdc_rtc_read_rt(&tv)) {\r\np += sprintf(p, "i8042 rtc\t: READ FAILED!\n");\r\n} else {\r\np += sprintf(p, "i8042 rtc\t: %ld.%02d seconds\n",\r\ntv.tv_sec, (int)tv.tv_usec/1000);\r\n}\r\nif (hp_sdc_rtc_read_fhs(&tv)) {\r\np += sprintf(p, "handshake\t: READ FAILED!\n");\r\n} else {\r\np += sprintf(p, "handshake\t: %ld.%02d seconds\n",\r\ntv.tv_sec, (int)tv.tv_usec/1000);\r\n}\r\nif (hp_sdc_rtc_read_mt(&tv)) {\r\np += sprintf(p, "alarm\t\t: READ FAILED!\n");\r\n} else {\r\np += sprintf(p, "alarm\t\t: %ld.%02d seconds\n",\r\ntv.tv_sec, (int)tv.tv_usec/1000);\r\n}\r\nif (hp_sdc_rtc_read_dt(&tv)) {\r\np += sprintf(p, "delay\t\t: READ FAILED!\n");\r\n} else {\r\np += sprintf(p, "delay\t\t: %ld.%02d seconds\n",\r\ntv.tv_sec, (int)tv.tv_usec/1000);\r\n}\r\nif (hp_sdc_rtc_read_ct(&tv)) {\r\np += sprintf(p, "periodic\t: READ FAILED!\n");\r\n} else {\r\np += sprintf(p, "periodic\t: %ld.%02d seconds\n",\r\ntv.tv_sec, (int)tv.tv_usec/1000);\r\n}\r\np += sprintf(p,\r\n"DST_enable\t: %s\n"\r\n"BCD\t\t: %s\n"\r\n"24hr\t\t: %s\n"\r\n"square_wave\t: %s\n"\r\n"alarm_IRQ\t: %s\n"\r\n"update_IRQ\t: %s\n"\r\n"periodic_IRQ\t: %s\n"\r\n"periodic_freq\t: %ld\n"\r\n"batt_status\t: %s\n",\r\nYN(RTC_DST_EN),\r\nNY(RTC_DM_BINARY),\r\nYN(RTC_24H),\r\nYN(RTC_SQWE),\r\nYN(RTC_AIE),\r\nYN(RTC_UIE),\r\nYN(RTC_PIE),\r\n1UL,\r\n1 ? "okay" : "dead");\r\nreturn p - buf;\r\n#undef YN\r\n#undef NY\r\n}\r\nstatic int hp_sdc_rtc_read_proc(char *page, char **start, off_t off,\r\nint count, int *eof, void *data)\r\n{\r\nint len = hp_sdc_rtc_proc_output (page);\r\nif (len <= off+count) *eof = 1;\r\n*start = page + off;\r\nlen -= off;\r\nif (len>count) len = count;\r\nif (len<0) len = 0;\r\nreturn len;\r\n}\r\nstatic int hp_sdc_rtc_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\n#if 1\r\nreturn -EINVAL;\r\n#else\r\nstruct rtc_time wtime;\r\nstruct timeval ttime;\r\nint use_wtime = 0;\r\nswitch (cmd) {\r\ncase RTC_AIE_OFF:\r\ncase RTC_AIE_ON:\r\ncase RTC_PIE_OFF:\r\ncase RTC_PIE_ON:\r\ncase RTC_UIE_ON:\r\ncase RTC_UIE_OFF:\r\n{\r\nreturn -EINVAL;\r\n}\r\ncase RTC_ALM_READ:\r\n{\r\nif (hp_sdc_rtc_read_mt(&ttime)) return -EFAULT;\r\nif (hp_sdc_rtc_read_bbrtc(&wtime)) return -EFAULT;\r\nwtime.tm_hour = ttime.tv_sec / 3600; ttime.tv_sec %= 3600;\r\nwtime.tm_min = ttime.tv_sec / 60; ttime.tv_sec %= 60;\r\nwtime.tm_sec = ttime.tv_sec;\r\nbreak;\r\n}\r\ncase RTC_IRQP_READ:\r\n{\r\nreturn put_user(hp_sdc_rtc_freq, (unsigned long *)arg);\r\n}\r\ncase RTC_IRQP_SET:\r\n{\r\nif ((arg < 1) || (arg > 100)) return -EINVAL;\r\nttime.tv_sec = 0;\r\nttime.tv_usec = 1000000 / arg;\r\nif (hp_sdc_rtc_set_ct(&ttime)) return -EFAULT;\r\nhp_sdc_rtc_freq = arg;\r\nreturn 0;\r\n}\r\ncase RTC_ALM_SET:\r\n{\r\nstruct hp_sdc_rtc_time alm_tm;\r\nif (copy_from_user(&alm_tm, (struct hp_sdc_rtc_time*)arg,\r\nsizeof(struct hp_sdc_rtc_time)))\r\nreturn -EFAULT;\r\nif (alm_tm.tm_hour > 23) return -EINVAL;\r\nif (alm_tm.tm_min > 59) return -EINVAL;\r\nif (alm_tm.tm_sec > 59) return -EINVAL;\r\nttime.sec = alm_tm.tm_hour * 3600 +\r\nalm_tm.tm_min * 60 + alm_tm.tm_sec;\r\nttime.usec = 0;\r\nif (hp_sdc_rtc_set_mt(&ttime)) return -EFAULT;\r\nreturn 0;\r\n}\r\ncase RTC_RD_TIME:\r\n{\r\nif (hp_sdc_rtc_read_bbrtc(&wtime)) return -EFAULT;\r\nbreak;\r\n}\r\ncase RTC_SET_TIME:\r\n{\r\nstruct rtc_time hp_sdc_rtc_tm;\r\nunsigned char mon, day, hrs, min, sec, leap_yr;\r\nunsigned int yrs;\r\nif (!capable(CAP_SYS_TIME))\r\nreturn -EACCES;\r\nif (copy_from_user(&hp_sdc_rtc_tm, (struct rtc_time *)arg,\r\nsizeof(struct rtc_time)))\r\nreturn -EFAULT;\r\nyrs = hp_sdc_rtc_tm.tm_year + 1900;\r\nmon = hp_sdc_rtc_tm.tm_mon + 1;\r\nday = hp_sdc_rtc_tm.tm_mday;\r\nhrs = hp_sdc_rtc_tm.tm_hour;\r\nmin = hp_sdc_rtc_tm.tm_min;\r\nsec = hp_sdc_rtc_tm.tm_sec;\r\nif (yrs < 1970)\r\nreturn -EINVAL;\r\nleap_yr = ((!(yrs % 4) && (yrs % 100)) || !(yrs % 400));\r\nif ((mon > 12) || (day == 0))\r\nreturn -EINVAL;\r\nif (day > (days_in_mo[mon] + ((mon == 2) && leap_yr)))\r\nreturn -EINVAL;\r\nif ((hrs >= 24) || (min >= 60) || (sec >= 60))\r\nreturn -EINVAL;\r\nif ((yrs -= eH) > 255)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\ncase RTC_EPOCH_READ:\r\n{\r\nreturn put_user (epoch, (unsigned long *)arg);\r\n}\r\ncase RTC_EPOCH_SET:\r\n{\r\nif (arg < 1900)\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_TIME))\r\nreturn -EACCES;\r\nepoch = arg;\r\nreturn 0;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn copy_to_user((void *)arg, &wtime, sizeof wtime) ? -EFAULT : 0;\r\n#endif\r\n}\r\nstatic long hp_sdc_rtc_unlocked_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint ret;\r\nmutex_lock(&hp_sdc_rtc_mutex);\r\nret = hp_sdc_rtc_ioctl(file, cmd, arg);\r\nmutex_unlock(&hp_sdc_rtc_mutex);\r\nreturn ret;\r\n}\r\nstatic int __init hp_sdc_rtc_init(void)\r\n{\r\nint ret;\r\n#ifdef __mc68000__\r\nif (!MACH_IS_HP300)\r\nreturn -ENODEV;\r\n#endif\r\nsema_init(&i8042tregs, 1);\r\nif ((ret = hp_sdc_request_timer_irq(&hp_sdc_rtc_isr)))\r\nreturn ret;\r\nif (misc_register(&hp_sdc_rtc_dev) != 0)\r\nprintk(KERN_INFO "Could not register misc. dev for i8042 rtc\n");\r\ncreate_proc_read_entry ("driver/rtc", 0, NULL,\r\nhp_sdc_rtc_read_proc, NULL);\r\nprintk(KERN_INFO "HP i8042 SDC + MSM-58321 RTC support loaded "\r\n"(RTC v " RTC_VERSION ")\n");\r\nreturn 0;\r\n}\r\nstatic void __exit hp_sdc_rtc_exit(void)\r\n{\r\nremove_proc_entry ("driver/rtc", NULL);\r\nmisc_deregister(&hp_sdc_rtc_dev);\r\nhp_sdc_release_timer_irq(hp_sdc_rtc_isr);\r\nprintk(KERN_INFO "HP i8042 SDC + MSM-58321 RTC support unloaded\n");\r\n}
