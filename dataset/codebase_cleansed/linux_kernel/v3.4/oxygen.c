static void ak4396_write(struct oxygen *chip, unsigned int codec,\r\nu8 reg, u8 value)\r\n{\r\nstatic const u8 codec_spi_map[4] = {\r\n0, 1, 2, 4\r\n};\r\nstruct generic_data *data = chip->model_data;\r\noxygen_write_spi(chip, OXYGEN_SPI_TRIGGER |\r\nOXYGEN_SPI_DATA_LENGTH_2 |\r\nOXYGEN_SPI_CLOCK_160 |\r\n(codec_spi_map[codec] << OXYGEN_SPI_CODEC_SHIFT) |\r\nOXYGEN_SPI_CEN_LATCH_CLOCK_HI,\r\nAK4396_WRITE | (reg << 8) | value);\r\ndata->ak4396_regs[codec][reg] = value;\r\n}\r\nstatic void ak4396_write_cached(struct oxygen *chip, unsigned int codec,\r\nu8 reg, u8 value)\r\n{\r\nstruct generic_data *data = chip->model_data;\r\nif (value != data->ak4396_regs[codec][reg])\r\nak4396_write(chip, codec, reg, value);\r\n}\r\nstatic void wm8785_write(struct oxygen *chip, u8 reg, unsigned int value)\r\n{\r\nstruct generic_data *data = chip->model_data;\r\noxygen_write_spi(chip, OXYGEN_SPI_TRIGGER |\r\nOXYGEN_SPI_DATA_LENGTH_2 |\r\nOXYGEN_SPI_CLOCK_160 |\r\n(3 << OXYGEN_SPI_CODEC_SHIFT) |\r\nOXYGEN_SPI_CEN_LATCH_CLOCK_LO,\r\n(reg << 9) | value);\r\nif (reg < ARRAY_SIZE(data->wm8785_regs))\r\ndata->wm8785_regs[reg] = value;\r\n}\r\nstatic void ak4396_registers_init(struct oxygen *chip)\r\n{\r\nstruct generic_data *data = chip->model_data;\r\nunsigned int i;\r\nfor (i = 0; i < data->dacs; ++i) {\r\nak4396_write(chip, i, AK4396_CONTROL_1,\r\nAK4396_DIF_24_MSB | AK4396_RSTN);\r\nak4396_write(chip, i, AK4396_CONTROL_2,\r\ndata->ak4396_regs[0][AK4396_CONTROL_2]);\r\nak4396_write(chip, i, AK4396_CONTROL_3,\r\nAK4396_PCM);\r\nak4396_write(chip, i, AK4396_LCH_ATT,\r\nchip->dac_volume[i * 2]);\r\nak4396_write(chip, i, AK4396_RCH_ATT,\r\nchip->dac_volume[i * 2 + 1]);\r\n}\r\n}\r\nstatic void ak4396_init(struct oxygen *chip)\r\n{\r\nstruct generic_data *data = chip->model_data;\r\ndata->dacs = chip->model.dac_channels_pcm / 2;\r\ndata->ak4396_regs[0][AK4396_CONTROL_2] =\r\nAK4396_SMUTE | AK4396_DEM_OFF | AK4396_DFS_NORMAL;\r\nak4396_registers_init(chip);\r\nsnd_component_add(chip->card, "AK4396");\r\n}\r\nstatic void ak5385_init(struct oxygen *chip)\r\n{\r\noxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL, GPIO_AK5385_DFS_MASK);\r\noxygen_clear_bits16(chip, OXYGEN_GPIO_DATA, GPIO_AK5385_DFS_MASK);\r\nsnd_component_add(chip->card, "AK5385");\r\n}\r\nstatic void wm8785_registers_init(struct oxygen *chip)\r\n{\r\nstruct generic_data *data = chip->model_data;\r\nwm8785_write(chip, WM8785_R7, 0);\r\nwm8785_write(chip, WM8785_R0, data->wm8785_regs[0]);\r\nwm8785_write(chip, WM8785_R2, data->wm8785_regs[2]);\r\n}\r\nstatic void wm8785_init(struct oxygen *chip)\r\n{\r\nstruct generic_data *data = chip->model_data;\r\ndata->wm8785_regs[0] =\r\nWM8785_MCR_SLAVE | WM8785_OSR_SINGLE | WM8785_FORMAT_LJUST;\r\ndata->wm8785_regs[2] = WM8785_HPFR | WM8785_HPFL;\r\nwm8785_registers_init(chip);\r\nsnd_component_add(chip->card, "WM8785");\r\n}\r\nstatic void generic_init(struct oxygen *chip)\r\n{\r\nak4396_init(chip);\r\nwm8785_init(chip);\r\n}\r\nstatic void meridian_init(struct oxygen *chip)\r\n{\r\noxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL,\r\nGPIO_MERIDIAN_DIG_MASK);\r\noxygen_write16_masked(chip, OXYGEN_GPIO_DATA,\r\nGPIO_MERIDIAN_DIG_BOARD, GPIO_MERIDIAN_DIG_MASK);\r\nak4396_init(chip);\r\nak5385_init(chip);\r\n}\r\nstatic void claro_enable_hp(struct oxygen *chip)\r\n{\r\nmsleep(300);\r\noxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL, GPIO_CLARO_HP);\r\noxygen_set_bits16(chip, OXYGEN_GPIO_DATA, GPIO_CLARO_HP);\r\n}\r\nstatic void claro_init(struct oxygen *chip)\r\n{\r\noxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL, GPIO_CLARO_DIG_COAX);\r\noxygen_clear_bits16(chip, OXYGEN_GPIO_DATA, GPIO_CLARO_DIG_COAX);\r\nak4396_init(chip);\r\nwm8785_init(chip);\r\nclaro_enable_hp(chip);\r\n}\r\nstatic void claro_halo_init(struct oxygen *chip)\r\n{\r\noxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL, GPIO_CLARO_DIG_COAX);\r\noxygen_clear_bits16(chip, OXYGEN_GPIO_DATA, GPIO_CLARO_DIG_COAX);\r\nak4396_init(chip);\r\nak5385_init(chip);\r\nclaro_enable_hp(chip);\r\n}\r\nstatic void fantasia_init(struct oxygen *chip)\r\n{\r\nak4396_init(chip);\r\nsnd_component_add(chip->card, "CS5340");\r\n}\r\nstatic void stereo_output_init(struct oxygen *chip)\r\n{\r\nak4396_init(chip);\r\n}\r\nstatic void generic_cleanup(struct oxygen *chip)\r\n{\r\n}\r\nstatic void claro_disable_hp(struct oxygen *chip)\r\n{\r\noxygen_clear_bits16(chip, OXYGEN_GPIO_DATA, GPIO_CLARO_HP);\r\n}\r\nstatic void claro_cleanup(struct oxygen *chip)\r\n{\r\nclaro_disable_hp(chip);\r\n}\r\nstatic void claro_suspend(struct oxygen *chip)\r\n{\r\nclaro_disable_hp(chip);\r\n}\r\nstatic void generic_resume(struct oxygen *chip)\r\n{\r\nak4396_registers_init(chip);\r\nwm8785_registers_init(chip);\r\n}\r\nstatic void meridian_resume(struct oxygen *chip)\r\n{\r\nak4396_registers_init(chip);\r\n}\r\nstatic void claro_resume(struct oxygen *chip)\r\n{\r\nak4396_registers_init(chip);\r\nclaro_enable_hp(chip);\r\n}\r\nstatic void stereo_resume(struct oxygen *chip)\r\n{\r\nak4396_registers_init(chip);\r\n}\r\nstatic void set_ak4396_params(struct oxygen *chip,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct generic_data *data = chip->model_data;\r\nunsigned int i;\r\nu8 value;\r\nvalue = data->ak4396_regs[0][AK4396_CONTROL_2] & ~AK4396_DFS_MASK;\r\nif (params_rate(params) <= 54000)\r\nvalue |= AK4396_DFS_NORMAL;\r\nelse if (params_rate(params) <= 108000)\r\nvalue |= AK4396_DFS_DOUBLE;\r\nelse\r\nvalue |= AK4396_DFS_QUAD;\r\nmsleep(1);\r\nif (value != data->ak4396_regs[0][AK4396_CONTROL_2]) {\r\nfor (i = 0; i < data->dacs; ++i) {\r\nak4396_write(chip, i, AK4396_CONTROL_1,\r\nAK4396_DIF_24_MSB);\r\nak4396_write(chip, i, AK4396_CONTROL_2, value);\r\nak4396_write(chip, i, AK4396_CONTROL_1,\r\nAK4396_DIF_24_MSB | AK4396_RSTN);\r\n}\r\n}\r\n}\r\nstatic void update_ak4396_volume(struct oxygen *chip)\r\n{\r\nstruct generic_data *data = chip->model_data;\r\nunsigned int i;\r\nfor (i = 0; i < data->dacs; ++i) {\r\nak4396_write_cached(chip, i, AK4396_LCH_ATT,\r\nchip->dac_volume[i * 2]);\r\nak4396_write_cached(chip, i, AK4396_RCH_ATT,\r\nchip->dac_volume[i * 2 + 1]);\r\n}\r\n}\r\nstatic void update_ak4396_mute(struct oxygen *chip)\r\n{\r\nstruct generic_data *data = chip->model_data;\r\nunsigned int i;\r\nu8 value;\r\nvalue = data->ak4396_regs[0][AK4396_CONTROL_2] & ~AK4396_SMUTE;\r\nif (chip->dac_mute)\r\nvalue |= AK4396_SMUTE;\r\nfor (i = 0; i < data->dacs; ++i)\r\nak4396_write_cached(chip, i, AK4396_CONTROL_2, value);\r\n}\r\nstatic void set_wm8785_params(struct oxygen *chip,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct generic_data *data = chip->model_data;\r\nunsigned int value;\r\nvalue = WM8785_MCR_SLAVE | WM8785_FORMAT_LJUST;\r\nif (params_rate(params) <= 48000)\r\nvalue |= WM8785_OSR_SINGLE;\r\nelse if (params_rate(params) <= 96000)\r\nvalue |= WM8785_OSR_DOUBLE;\r\nelse\r\nvalue |= WM8785_OSR_QUAD;\r\nif (value != data->wm8785_regs[0]) {\r\nwm8785_write(chip, WM8785_R7, 0);\r\nwm8785_write(chip, WM8785_R0, value);\r\nwm8785_write(chip, WM8785_R2, data->wm8785_regs[2]);\r\n}\r\n}\r\nstatic void set_ak5385_params(struct oxygen *chip,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nunsigned int value;\r\nif (params_rate(params) <= 54000)\r\nvalue = GPIO_AK5385_DFS_NORMAL;\r\nelse if (params_rate(params) <= 108000)\r\nvalue = GPIO_AK5385_DFS_DOUBLE;\r\nelse\r\nvalue = GPIO_AK5385_DFS_QUAD;\r\noxygen_write16_masked(chip, OXYGEN_GPIO_DATA,\r\nvalue, GPIO_AK5385_DFS_MASK);\r\n}\r\nstatic void set_no_params(struct oxygen *chip, struct snd_pcm_hw_params *params)\r\n{\r\n}\r\nstatic int rolloff_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const names[2] = {\r\n"Sharp Roll-off", "Slow Roll-off"\r\n};\r\nreturn snd_ctl_enum_info(info, 1, 2, names);\r\n}\r\nstatic int rolloff_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct generic_data *data = chip->model_data;\r\nvalue->value.enumerated.item[0] =\r\n(data->ak4396_regs[0][AK4396_CONTROL_2] & AK4396_SLOW) != 0;\r\nreturn 0;\r\n}\r\nstatic int rolloff_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct generic_data *data = chip->model_data;\r\nunsigned int i;\r\nint changed;\r\nu8 reg;\r\nmutex_lock(&chip->mutex);\r\nreg = data->ak4396_regs[0][AK4396_CONTROL_2];\r\nif (value->value.enumerated.item[0])\r\nreg |= AK4396_SLOW;\r\nelse\r\nreg &= ~AK4396_SLOW;\r\nchanged = reg != data->ak4396_regs[0][AK4396_CONTROL_2];\r\nif (changed) {\r\nfor (i = 0; i < data->dacs; ++i)\r\nak4396_write(chip, i, AK4396_CONTROL_2, reg);\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int hpf_info(struct snd_kcontrol *ctl, struct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const names[2] = {\r\n"None", "High-pass Filter"\r\n};\r\nreturn snd_ctl_enum_info(info, 1, 2, names);\r\n}\r\nstatic int hpf_get(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct generic_data *data = chip->model_data;\r\nvalue->value.enumerated.item[0] =\r\n(data->wm8785_regs[WM8785_R2] & WM8785_HPFR) != 0;\r\nreturn 0;\r\n}\r\nstatic int hpf_put(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct generic_data *data = chip->model_data;\r\nunsigned int reg;\r\nint changed;\r\nmutex_lock(&chip->mutex);\r\nreg = data->wm8785_regs[WM8785_R2] & ~(WM8785_HPFR | WM8785_HPFL);\r\nif (value->value.enumerated.item[0])\r\nreg |= WM8785_HPFR | WM8785_HPFL;\r\nchanged = reg != data->wm8785_regs[WM8785_R2];\r\nif (changed)\r\nwm8785_write(chip, WM8785_R2, reg);\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int meridian_dig_source_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const names[2] = { "On-board", "Extension" };\r\nreturn snd_ctl_enum_info(info, 1, 2, names);\r\n}\r\nstatic int claro_dig_source_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const names[2] = { "Optical", "Coaxial" };\r\nreturn snd_ctl_enum_info(info, 1, 2, names);\r\n}\r\nstatic int meridian_dig_source_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nvalue->value.enumerated.item[0] =\r\n!!(oxygen_read16(chip, OXYGEN_GPIO_DATA) &\r\nGPIO_MERIDIAN_DIG_EXT);\r\nreturn 0;\r\n}\r\nstatic int claro_dig_source_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nvalue->value.enumerated.item[0] =\r\n!!(oxygen_read16(chip, OXYGEN_GPIO_DATA) &\r\nGPIO_CLARO_DIG_COAX);\r\nreturn 0;\r\n}\r\nstatic int meridian_dig_source_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nu16 old_reg, new_reg;\r\nint changed;\r\nmutex_lock(&chip->mutex);\r\nold_reg = oxygen_read16(chip, OXYGEN_GPIO_DATA);\r\nnew_reg = old_reg & ~GPIO_MERIDIAN_DIG_MASK;\r\nif (value->value.enumerated.item[0] == 0)\r\nnew_reg |= GPIO_MERIDIAN_DIG_BOARD;\r\nelse\r\nnew_reg |= GPIO_MERIDIAN_DIG_EXT;\r\nchanged = new_reg != old_reg;\r\nif (changed)\r\noxygen_write16(chip, OXYGEN_GPIO_DATA, new_reg);\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int claro_dig_source_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nu16 old_reg, new_reg;\r\nint changed;\r\nmutex_lock(&chip->mutex);\r\nold_reg = oxygen_read16(chip, OXYGEN_GPIO_DATA);\r\nnew_reg = old_reg & ~GPIO_CLARO_DIG_COAX;\r\nif (value->value.enumerated.item[0])\r\nnew_reg |= GPIO_CLARO_DIG_COAX;\r\nchanged = new_reg != old_reg;\r\nif (changed)\r\noxygen_write16(chip, OXYGEN_GPIO_DATA, new_reg);\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int generic_mixer_init(struct oxygen *chip)\r\n{\r\nreturn snd_ctl_add(chip->card, snd_ctl_new1(&rolloff_control, chip));\r\n}\r\nstatic int generic_wm8785_mixer_init(struct oxygen *chip)\r\n{\r\nint err;\r\nerr = generic_mixer_init(chip);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card, snd_ctl_new1(&hpf_control, chip));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int meridian_mixer_init(struct oxygen *chip)\r\n{\r\nint err;\r\nerr = generic_mixer_init(chip);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&meridian_dig_source_control, chip));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int claro_mixer_init(struct oxygen *chip)\r\n{\r\nint err;\r\nerr = generic_wm8785_mixer_init(chip);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&claro_dig_source_control, chip));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int claro_halo_mixer_init(struct oxygen *chip)\r\n{\r\nint err;\r\nerr = generic_mixer_init(chip);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&claro_dig_source_control, chip));\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void dump_ak4396_registers(struct oxygen *chip,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct generic_data *data = chip->model_data;\r\nunsigned int dac, i;\r\nfor (dac = 0; dac < data->dacs; ++dac) {\r\nsnd_iprintf(buffer, "\nAK4396 %u:", dac + 1);\r\nfor (i = 0; i < 5; ++i)\r\nsnd_iprintf(buffer, " %02x", data->ak4396_regs[dac][i]);\r\n}\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nstatic void dump_wm8785_registers(struct oxygen *chip,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct generic_data *data = chip->model_data;\r\nunsigned int i;\r\nsnd_iprintf(buffer, "\nWM8785:");\r\nfor (i = 0; i < 3; ++i)\r\nsnd_iprintf(buffer, " %03x", data->wm8785_regs[i]);\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nstatic void dump_oxygen_registers(struct oxygen *chip,\r\nstruct snd_info_buffer *buffer)\r\n{\r\ndump_ak4396_registers(chip, buffer);\r\ndump_wm8785_registers(chip, buffer);\r\n}\r\nstatic int __devinit get_oxygen_model(struct oxygen *chip,\r\nconst struct pci_device_id *id)\r\n{\r\nstatic const char *const names[] = {\r\n[MODEL_MERIDIAN] = "AuzenTech X-Meridian",\r\n[MODEL_MERIDIAN_2G] = "AuzenTech X-Meridian 2G",\r\n[MODEL_CLARO] = "HT-Omega Claro",\r\n[MODEL_CLARO_HALO] = "HT-Omega Claro halo",\r\n[MODEL_FANTASIA] = "TempoTec HiFier Fantasia",\r\n[MODEL_SERENADE] = "TempoTec HiFier Serenade",\r\n[MODEL_HG2PCI] = "CMI8787-HG2PCI",\r\n};\r\nchip->model = model_generic;\r\nswitch (id->driver_data) {\r\ncase MODEL_MERIDIAN:\r\ncase MODEL_MERIDIAN_2G:\r\nchip->model.init = meridian_init;\r\nchip->model.mixer_init = meridian_mixer_init;\r\nchip->model.resume = meridian_resume;\r\nchip->model.set_adc_params = set_ak5385_params;\r\nchip->model.dump_registers = dump_ak4396_registers;\r\nchip->model.device_config = PLAYBACK_0_TO_I2S |\r\nPLAYBACK_1_TO_SPDIF |\r\nCAPTURE_0_FROM_I2S_2 |\r\nCAPTURE_1_FROM_SPDIF;\r\nif (id->driver_data == MODEL_MERIDIAN)\r\nchip->model.device_config |= AC97_CD_INPUT;\r\nbreak;\r\ncase MODEL_CLARO:\r\nchip->model.init = claro_init;\r\nchip->model.mixer_init = claro_mixer_init;\r\nchip->model.cleanup = claro_cleanup;\r\nchip->model.suspend = claro_suspend;\r\nchip->model.resume = claro_resume;\r\nbreak;\r\ncase MODEL_CLARO_HALO:\r\nchip->model.init = claro_halo_init;\r\nchip->model.mixer_init = claro_halo_mixer_init;\r\nchip->model.cleanup = claro_cleanup;\r\nchip->model.suspend = claro_suspend;\r\nchip->model.resume = claro_resume;\r\nchip->model.set_adc_params = set_ak5385_params;\r\nchip->model.dump_registers = dump_ak4396_registers;\r\nchip->model.device_config = PLAYBACK_0_TO_I2S |\r\nPLAYBACK_1_TO_SPDIF |\r\nCAPTURE_0_FROM_I2S_2 |\r\nCAPTURE_1_FROM_SPDIF;\r\nbreak;\r\ncase MODEL_FANTASIA:\r\ncase MODEL_SERENADE:\r\ncase MODEL_2CH_OUTPUT:\r\ncase MODEL_HG2PCI:\r\nchip->model.shortname = "C-Media CMI8787";\r\nchip->model.chip = "CMI8787";\r\nif (id->driver_data == MODEL_FANTASIA)\r\nchip->model.init = fantasia_init;\r\nelse\r\nchip->model.init = stereo_output_init;\r\nchip->model.resume = stereo_resume;\r\nchip->model.mixer_init = generic_mixer_init;\r\nchip->model.set_adc_params = set_no_params;\r\nchip->model.dump_registers = dump_ak4396_registers;\r\nchip->model.device_config = PLAYBACK_0_TO_I2S |\r\nPLAYBACK_1_TO_SPDIF;\r\nif (id->driver_data == MODEL_FANTASIA) {\r\nchip->model.device_config |= CAPTURE_0_FROM_I2S_1;\r\nchip->model.adc_mclks = OXYGEN_MCLKS(256, 128, 128);\r\n}\r\nchip->model.dac_channels_pcm = 2;\r\nchip->model.dac_channels_mixer = 2;\r\nbreak;\r\ncase MODEL_XONAR_DG:\r\nchip->model = model_xonar_dg;\r\nbreak;\r\n}\r\nif (id->driver_data == MODEL_MERIDIAN ||\r\nid->driver_data == MODEL_MERIDIAN_2G ||\r\nid->driver_data == MODEL_CLARO_HALO) {\r\nchip->model.misc_flags = OXYGEN_MISC_MIDI;\r\nchip->model.device_config |= MIDI_OUTPUT | MIDI_INPUT;\r\n}\r\nif (id->driver_data < ARRAY_SIZE(names) && names[id->driver_data])\r\nchip->model.shortname = names[id->driver_data];\r\nreturn 0;\r\n}\r\nstatic int __devinit generic_oxygen_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nint err;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\n++dev;\r\nreturn -ENOENT;\r\n}\r\nerr = oxygen_pci_probe(pci, index[dev], id[dev], THIS_MODULE,\r\noxygen_ids, get_oxygen_model);\r\nif (err >= 0)\r\n++dev;\r\nreturn err;\r\n}\r\nstatic int __init alsa_card_oxygen_init(void)\r\n{\r\nreturn pci_register_driver(&oxygen_driver);\r\n}\r\nstatic void __exit alsa_card_oxygen_exit(void)\r\n{\r\npci_unregister_driver(&oxygen_driver);\r\n}
