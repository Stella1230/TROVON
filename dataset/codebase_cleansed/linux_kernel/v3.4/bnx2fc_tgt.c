static void bnx2fc_upld_timer(unsigned long data)\r\n{\r\nstruct bnx2fc_rport *tgt = (struct bnx2fc_rport *)data;\r\nBNX2FC_TGT_DBG(tgt, "upld_timer - Upload compl not received!!\n");\r\nclear_bit(BNX2FC_FLAG_OFFLOADED, &tgt->flags);\r\nset_bit(BNX2FC_FLAG_UPLD_REQ_COMPL, &tgt->flags);\r\nwake_up_interruptible(&tgt->upld_wait);\r\n}\r\nstatic void bnx2fc_ofld_timer(unsigned long data)\r\n{\r\nstruct bnx2fc_rport *tgt = (struct bnx2fc_rport *)data;\r\nBNX2FC_TGT_DBG(tgt, "entered bnx2fc_ofld_timer\n");\r\nclear_bit(BNX2FC_FLAG_OFFLOADED, &tgt->flags);\r\nset_bit(BNX2FC_FLAG_OFLD_REQ_CMPL, &tgt->flags);\r\nwake_up_interruptible(&tgt->ofld_wait);\r\n}\r\nstatic void bnx2fc_offload_session(struct fcoe_port *port,\r\nstruct bnx2fc_rport *tgt,\r\nstruct fc_rport_priv *rdata)\r\n{\r\nstruct fc_lport *lport = rdata->local_port;\r\nstruct fc_rport *rport = rdata->rport;\r\nstruct bnx2fc_interface *interface = port->priv;\r\nstruct bnx2fc_hba *hba = interface->hba;\r\nint rval;\r\nint i = 0;\r\nrval = bnx2fc_init_tgt(tgt, port, rdata);\r\nif (rval) {\r\nprintk(KERN_ERR PFX "Failed to allocate conn id for "\r\n"port_id (%6x)\n", rport->port_id);\r\ngoto tgt_init_err;\r\n}\r\nrval = bnx2fc_alloc_session_resc(hba, tgt);\r\nif (rval) {\r\nprintk(KERN_ERR PFX "Failed to allocate resources\n");\r\ngoto ofld_err;\r\n}\r\nretry_ofld:\r\nclear_bit(BNX2FC_FLAG_OFLD_REQ_CMPL, &tgt->flags);\r\nrval = bnx2fc_send_session_ofld_req(port, tgt);\r\nif (rval) {\r\nprintk(KERN_ERR PFX "ofld_req failed\n");\r\ngoto ofld_err;\r\n}\r\nsetup_timer(&tgt->ofld_timer, bnx2fc_ofld_timer, (unsigned long)tgt);\r\nmod_timer(&tgt->ofld_timer, jiffies + BNX2FC_FW_TIMEOUT);\r\nwait_event_interruptible(tgt->ofld_wait,\r\n(test_bit(\r\nBNX2FC_FLAG_OFLD_REQ_CMPL,\r\n&tgt->flags)));\r\nif (signal_pending(current))\r\nflush_signals(current);\r\ndel_timer_sync(&tgt->ofld_timer);\r\nif (!(test_bit(BNX2FC_FLAG_OFFLOADED, &tgt->flags))) {\r\nif (test_and_clear_bit(BNX2FC_FLAG_CTX_ALLOC_FAILURE,\r\n&tgt->flags)) {\r\nBNX2FC_TGT_DBG(tgt, "ctx_alloc_failure, "\r\n"retry ofld..%d\n", i++);\r\nmsleep_interruptible(1000);\r\nif (i > 3) {\r\ni = 0;\r\ngoto ofld_err;\r\n}\r\ngoto retry_ofld;\r\n}\r\ngoto ofld_err;\r\n}\r\nif (bnx2fc_map_doorbell(tgt)) {\r\nprintk(KERN_ERR PFX "map doorbell failed - no mem\n");\r\nlport->tt.rport_logoff(rdata);\r\n}\r\nreturn;\r\nofld_err:\r\nBNX2FC_TGT_DBG(tgt, "bnx2fc_offload_session - offload error\n");\r\nbnx2fc_free_session_resc(hba, tgt);\r\ntgt_init_err:\r\nif (tgt->fcoe_conn_id != -1)\r\nbnx2fc_free_conn_id(hba, tgt->fcoe_conn_id);\r\nlport->tt.rport_logoff(rdata);\r\n}\r\nvoid bnx2fc_flush_active_ios(struct bnx2fc_rport *tgt)\r\n{\r\nstruct bnx2fc_cmd *io_req;\r\nstruct list_head *list;\r\nstruct list_head *tmp;\r\nint rc;\r\nint i = 0;\r\nBNX2FC_TGT_DBG(tgt, "Entered flush_active_ios - %d\n",\r\ntgt->num_active_ios.counter);\r\nspin_lock_bh(&tgt->tgt_lock);\r\ntgt->flush_in_prog = 1;\r\nlist_for_each_safe(list, tmp, &tgt->active_cmd_queue) {\r\ni++;\r\nio_req = (struct bnx2fc_cmd *)list;\r\nlist_del_init(&io_req->link);\r\nio_req->on_active_queue = 0;\r\nBNX2FC_IO_DBG(io_req, "cmd_queue cleanup\n");\r\nif (cancel_delayed_work(&io_req->timeout_work)) {\r\nif (test_and_clear_bit(BNX2FC_FLAG_EH_ABORT,\r\n&io_req->req_flags)) {\r\nBNX2FC_IO_DBG(io_req, "eh_abort for IO "\r\n"cleaned up\n");\r\ncomplete(&io_req->tm_done);\r\n}\r\nkref_put(&io_req->refcount,\r\nbnx2fc_cmd_release);\r\n}\r\nset_bit(BNX2FC_FLAG_IO_COMPL, &io_req->req_flags);\r\nset_bit(BNX2FC_FLAG_IO_CLEANUP, &io_req->req_flags);\r\nrc = bnx2fc_initiate_cleanup(io_req);\r\nBUG_ON(rc);\r\n}\r\nlist_for_each_safe(list, tmp, &tgt->els_queue) {\r\ni++;\r\nio_req = (struct bnx2fc_cmd *)list;\r\nlist_del_init(&io_req->link);\r\nio_req->on_active_queue = 0;\r\nBNX2FC_IO_DBG(io_req, "els_queue cleanup\n");\r\nif (cancel_delayed_work(&io_req->timeout_work))\r\nkref_put(&io_req->refcount,\r\nbnx2fc_cmd_release);\r\nif ((io_req->cb_func) && (io_req->cb_arg)) {\r\nio_req->cb_func(io_req->cb_arg);\r\nio_req->cb_arg = NULL;\r\n}\r\nrc = bnx2fc_initiate_cleanup(io_req);\r\nBUG_ON(rc);\r\n}\r\nlist_for_each_safe(list, tmp, &tgt->io_retire_queue) {\r\ni++;\r\nio_req = (struct bnx2fc_cmd *)list;\r\nlist_del_init(&io_req->link);\r\nBNX2FC_IO_DBG(io_req, "retire_queue flush\n");\r\nif (cancel_delayed_work(&io_req->timeout_work))\r\nkref_put(&io_req->refcount, bnx2fc_cmd_release);\r\nclear_bit(BNX2FC_FLAG_ISSUE_RRQ, &io_req->req_flags);\r\n}\r\nBNX2FC_TGT_DBG(tgt, "IOs flushed = %d\n", i);\r\ni = 0;\r\nspin_unlock_bh(&tgt->tgt_lock);\r\nwhile ((tgt->num_active_ios.counter != 0) && (i++ < BNX2FC_WAIT_CNT))\r\nmsleep(25);\r\nif (tgt->num_active_ios.counter != 0)\r\nprintk(KERN_ERR PFX "CLEANUP on port 0x%x:"\r\n" active_ios = %d\n",\r\ntgt->rdata->ids.port_id, tgt->num_active_ios.counter);\r\nspin_lock_bh(&tgt->tgt_lock);\r\ntgt->flush_in_prog = 0;\r\nspin_unlock_bh(&tgt->tgt_lock);\r\n}\r\nstatic void bnx2fc_upload_session(struct fcoe_port *port,\r\nstruct bnx2fc_rport *tgt)\r\n{\r\nstruct bnx2fc_interface *interface = port->priv;\r\nstruct bnx2fc_hba *hba = interface->hba;\r\nBNX2FC_TGT_DBG(tgt, "upload_session: active_ios = %d\n",\r\ntgt->num_active_ios.counter);\r\nclear_bit(BNX2FC_FLAG_UPLD_REQ_COMPL, &tgt->flags);\r\nbnx2fc_send_session_disable_req(port, tgt);\r\nsetup_timer(&tgt->upld_timer, bnx2fc_upld_timer, (unsigned long)tgt);\r\nmod_timer(&tgt->upld_timer, jiffies + BNX2FC_FW_TIMEOUT);\r\nBNX2FC_TGT_DBG(tgt, "waiting for disable compl\n");\r\nwait_event_interruptible(tgt->upld_wait,\r\n(test_bit(\r\nBNX2FC_FLAG_UPLD_REQ_COMPL,\r\n&tgt->flags)));\r\nif (signal_pending(current))\r\nflush_signals(current);\r\ndel_timer_sync(&tgt->upld_timer);\r\nBNX2FC_TGT_DBG(tgt, "flush/upload - disable wait flags = 0x%lx\n",\r\ntgt->flags);\r\nbnx2fc_flush_active_ios(tgt);\r\nif (test_bit(BNX2FC_FLAG_DISABLED, &tgt->flags)) {\r\nBNX2FC_TGT_DBG(tgt, "send destroy req\n");\r\nclear_bit(BNX2FC_FLAG_UPLD_REQ_COMPL, &tgt->flags);\r\nbnx2fc_send_session_destroy_req(hba, tgt);\r\nsetup_timer(&tgt->upld_timer,\r\nbnx2fc_upld_timer, (unsigned long)tgt);\r\nmod_timer(&tgt->upld_timer, jiffies + BNX2FC_FW_TIMEOUT);\r\nwait_event_interruptible(tgt->upld_wait,\r\n(test_bit(\r\nBNX2FC_FLAG_UPLD_REQ_COMPL,\r\n&tgt->flags)));\r\nif (!(test_bit(BNX2FC_FLAG_DESTROYED, &tgt->flags)))\r\nprintk(KERN_ERR PFX "ERROR!! destroy timed out\n");\r\nBNX2FC_TGT_DBG(tgt, "destroy wait complete flags = 0x%lx\n",\r\ntgt->flags);\r\nif (signal_pending(current))\r\nflush_signals(current);\r\ndel_timer_sync(&tgt->upld_timer);\r\n} else\r\nprintk(KERN_ERR PFX "ERROR!! DISABLE req timed out, destroy"\r\n" not sent to FW\n");\r\nbnx2fc_free_session_resc(hba, tgt);\r\nbnx2fc_free_conn_id(hba, tgt->fcoe_conn_id);\r\n}\r\nstatic int bnx2fc_init_tgt(struct bnx2fc_rport *tgt,\r\nstruct fcoe_port *port,\r\nstruct fc_rport_priv *rdata)\r\n{\r\nstruct fc_rport *rport = rdata->rport;\r\nstruct bnx2fc_interface *interface = port->priv;\r\nstruct bnx2fc_hba *hba = interface->hba;\r\nstruct b577xx_doorbell_set_prod *sq_db = &tgt->sq_db;\r\nstruct b577xx_fcoe_rx_doorbell *rx_db = &tgt->rx_db;\r\ntgt->rport = rport;\r\ntgt->rdata = rdata;\r\ntgt->port = port;\r\nif (hba->num_ofld_sess >= BNX2FC_NUM_MAX_SESS) {\r\nBNX2FC_TGT_DBG(tgt, "exceeded max sessions. logoff this tgt\n");\r\ntgt->fcoe_conn_id = -1;\r\nreturn -1;\r\n}\r\ntgt->fcoe_conn_id = bnx2fc_alloc_conn_id(hba, tgt);\r\nif (tgt->fcoe_conn_id == -1)\r\nreturn -1;\r\nBNX2FC_TGT_DBG(tgt, "init_tgt - conn_id = 0x%x\n", tgt->fcoe_conn_id);\r\ntgt->max_sqes = BNX2FC_SQ_WQES_MAX;\r\ntgt->max_rqes = BNX2FC_RQ_WQES_MAX;\r\ntgt->max_cqes = BNX2FC_CQ_WQES_MAX;\r\natomic_set(&tgt->free_sqes, BNX2FC_SQ_WQES_MAX);\r\ntgt->sq_curr_toggle_bit = 1;\r\ntgt->cq_curr_toggle_bit = 1;\r\ntgt->sq_prod_idx = 0;\r\ntgt->cq_cons_idx = 0;\r\ntgt->rq_prod_idx = 0x8000;\r\ntgt->rq_cons_idx = 0;\r\natomic_set(&tgt->num_active_ios, 0);\r\nif (rdata->flags & FC_RP_FLAGS_RETRY) {\r\ntgt->dev_type = TYPE_TAPE;\r\ntgt->io_timeout = 0;\r\n} else {\r\ntgt->dev_type = TYPE_DISK;\r\ntgt->io_timeout = BNX2FC_IO_TIMEOUT;\r\n}\r\nsq_db->header.header = B577XX_DOORBELL_HDR_DB_TYPE;\r\nsq_db->header.header |= B577XX_FCOE_CONNECTION_TYPE <<\r\nB577XX_DOORBELL_HDR_CONN_TYPE_SHIFT;\r\nrx_db->hdr.header = ((0x1 << B577XX_DOORBELL_HDR_RX_SHIFT) |\r\n(0x1 << B577XX_DOORBELL_HDR_DB_TYPE_SHIFT) |\r\n(B577XX_FCOE_CONNECTION_TYPE <<\r\nB577XX_DOORBELL_HDR_CONN_TYPE_SHIFT));\r\nrx_db->params = (0x2 << B577XX_FCOE_RX_DOORBELL_NEGATIVE_ARM_SHIFT) |\r\n(0x3 << B577XX_FCOE_RX_DOORBELL_OPCODE_SHIFT);\r\nspin_lock_init(&tgt->tgt_lock);\r\nspin_lock_init(&tgt->cq_lock);\r\nINIT_LIST_HEAD(&tgt->active_cmd_queue);\r\nINIT_LIST_HEAD(&tgt->io_retire_queue);\r\nINIT_LIST_HEAD(&tgt->els_queue);\r\nINIT_LIST_HEAD(&tgt->active_tm_queue);\r\ninit_waitqueue_head(&tgt->ofld_wait);\r\ninit_waitqueue_head(&tgt->upld_wait);\r\nreturn 0;\r\n}\r\nvoid bnx2fc_rport_event_handler(struct fc_lport *lport,\r\nstruct fc_rport_priv *rdata,\r\nenum fc_rport_event event)\r\n{\r\nstruct fcoe_port *port = lport_priv(lport);\r\nstruct bnx2fc_interface *interface = port->priv;\r\nstruct bnx2fc_hba *hba = interface->hba;\r\nstruct fc_rport *rport = rdata->rport;\r\nstruct fc_rport_libfc_priv *rp;\r\nstruct bnx2fc_rport *tgt;\r\nu32 port_id;\r\nBNX2FC_HBA_DBG(lport, "rport_event_hdlr: event = %d, port_id = 0x%x\n",\r\nevent, rdata->ids.port_id);\r\nswitch (event) {\r\ncase RPORT_EV_READY:\r\nif (!rport) {\r\nprintk(KERN_ERR PFX "rport is NULL: ERROR!\n");\r\nbreak;\r\n}\r\nrp = rport->dd_data;\r\nif (rport->port_id == FC_FID_DIR_SERV) {\r\nprintk(KERN_ERR PFX "%x - rport_event_handler ERROR\n",\r\nrdata->ids.port_id);\r\nbreak;\r\n}\r\nif (rdata->spp_type != FC_TYPE_FCP) {\r\nBNX2FC_HBA_DBG(lport, "not FCP type target."\r\n" not offloading\n");\r\nbreak;\r\n}\r\nif (!(rdata->ids.roles & FC_RPORT_ROLE_FCP_TARGET)) {\r\nBNX2FC_HBA_DBG(lport, "not FCP_TARGET"\r\n" not offloading\n");\r\nbreak;\r\n}\r\nmutex_lock(&hba->hba_mutex);\r\ntgt = (struct bnx2fc_rport *)&rp[1];\r\nif (test_bit(BNX2FC_FLAG_OFFLOADED, &tgt->flags)) {\r\nBNX2FC_TGT_DBG(tgt, "already offloaded\n");\r\nmutex_unlock(&hba->hba_mutex);\r\nreturn;\r\n}\r\nbnx2fc_offload_session(port, tgt, rdata);\r\nBNX2FC_TGT_DBG(tgt, "OFFLOAD num_ofld_sess = %d\n",\r\nhba->num_ofld_sess);\r\nif (test_bit(BNX2FC_FLAG_OFFLOADED, &tgt->flags)) {\r\nBNX2FC_TGT_DBG(tgt, "sess offloaded\n");\r\nhba->num_ofld_sess++;\r\nset_bit(BNX2FC_FLAG_SESSION_READY, &tgt->flags);\r\n} else {\r\nBNX2FC_TGT_DBG(tgt, "Port is being logged off as "\r\n"offloaded flag not set\n");\r\n}\r\nmutex_unlock(&hba->hba_mutex);\r\nbreak;\r\ncase RPORT_EV_LOGO:\r\ncase RPORT_EV_FAILED:\r\ncase RPORT_EV_STOP:\r\nport_id = rdata->ids.port_id;\r\nif (port_id == FC_FID_DIR_SERV)\r\nbreak;\r\nif (!rport) {\r\nprintk(KERN_INFO PFX "%x - rport not created Yet!!\n",\r\nport_id);\r\nbreak;\r\n}\r\nrp = rport->dd_data;\r\nmutex_lock(&hba->hba_mutex);\r\ntgt = (struct bnx2fc_rport *)&rp[1];\r\nif (!(test_bit(BNX2FC_FLAG_OFFLOADED, &tgt->flags))) {\r\nmutex_unlock(&hba->hba_mutex);\r\nbreak;\r\n}\r\nclear_bit(BNX2FC_FLAG_SESSION_READY, &tgt->flags);\r\nbnx2fc_upload_session(port, tgt);\r\nhba->num_ofld_sess--;\r\nBNX2FC_TGT_DBG(tgt, "UPLOAD num_ofld_sess = %d\n",\r\nhba->num_ofld_sess);\r\nif ((hba->wait_for_link_down) &&\r\n(hba->num_ofld_sess == 0)) {\r\nwake_up_interruptible(&hba->shutdown_wait);\r\n}\r\nif (test_bit(BNX2FC_FLAG_EXPL_LOGO, &tgt->flags)) {\r\nprintk(KERN_ERR PFX "Relogin to the tgt\n");\r\nmutex_lock(&lport->disc.disc_mutex);\r\nlport->tt.rport_login(rdata);\r\nmutex_unlock(&lport->disc.disc_mutex);\r\n}\r\nmutex_unlock(&hba->hba_mutex);\r\nbreak;\r\ncase RPORT_EV_NONE:\r\nbreak;\r\n}\r\n}\r\nstruct bnx2fc_rport *bnx2fc_tgt_lookup(struct fcoe_port *port,\r\nu32 port_id)\r\n{\r\nstruct bnx2fc_interface *interface = port->priv;\r\nstruct bnx2fc_hba *hba = interface->hba;\r\nstruct bnx2fc_rport *tgt;\r\nstruct fc_rport_priv *rdata;\r\nint i;\r\nfor (i = 0; i < BNX2FC_NUM_MAX_SESS; i++) {\r\ntgt = hba->tgt_ofld_list[i];\r\nif ((tgt) && (tgt->port == port)) {\r\nrdata = tgt->rdata;\r\nif (rdata->ids.port_id == port_id) {\r\nif (rdata->rp_state != RPORT_ST_DELETE) {\r\nBNX2FC_TGT_DBG(tgt, "rport "\r\n"obtained\n");\r\nreturn tgt;\r\n} else {\r\nBNX2FC_TGT_DBG(tgt, "rport 0x%x "\r\n"is in DELETED state\n",\r\nrdata->ids.port_id);\r\nreturn NULL;\r\n}\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic u32 bnx2fc_alloc_conn_id(struct bnx2fc_hba *hba,\r\nstruct bnx2fc_rport *tgt)\r\n{\r\nu32 conn_id, next;\r\nspin_lock_bh(&hba->hba_lock);\r\nnext = hba->next_conn_id;\r\nconn_id = hba->next_conn_id++;\r\nif (hba->next_conn_id == BNX2FC_NUM_MAX_SESS)\r\nhba->next_conn_id = 0;\r\nwhile (hba->tgt_ofld_list[conn_id] != NULL) {\r\nconn_id++;\r\nif (conn_id == BNX2FC_NUM_MAX_SESS)\r\nconn_id = 0;\r\nif (conn_id == next) {\r\nspin_unlock_bh(&hba->hba_lock);\r\nreturn -1;\r\n}\r\n}\r\nhba->tgt_ofld_list[conn_id] = tgt;\r\ntgt->fcoe_conn_id = conn_id;\r\nspin_unlock_bh(&hba->hba_lock);\r\nreturn conn_id;\r\n}\r\nstatic void bnx2fc_free_conn_id(struct bnx2fc_hba *hba, u32 conn_id)\r\n{\r\nspin_lock_bh(&hba->hba_lock);\r\nhba->tgt_ofld_list[conn_id] = NULL;\r\nspin_unlock_bh(&hba->hba_lock);\r\n}\r\nstatic int bnx2fc_alloc_session_resc(struct bnx2fc_hba *hba,\r\nstruct bnx2fc_rport *tgt)\r\n{\r\ndma_addr_t page;\r\nint num_pages;\r\nu32 *pbl;\r\ntgt->sq_mem_size = tgt->max_sqes * BNX2FC_SQ_WQE_SIZE;\r\ntgt->sq_mem_size = (tgt->sq_mem_size + (PAGE_SIZE - 1)) & PAGE_MASK;\r\ntgt->sq = dma_alloc_coherent(&hba->pcidev->dev, tgt->sq_mem_size,\r\n&tgt->sq_dma, GFP_KERNEL);\r\nif (!tgt->sq) {\r\nprintk(KERN_ERR PFX "unable to allocate SQ memory %d\n",\r\ntgt->sq_mem_size);\r\ngoto mem_alloc_failure;\r\n}\r\nmemset(tgt->sq, 0, tgt->sq_mem_size);\r\ntgt->cq_mem_size = tgt->max_cqes * BNX2FC_CQ_WQE_SIZE;\r\ntgt->cq_mem_size = (tgt->cq_mem_size + (PAGE_SIZE - 1)) & PAGE_MASK;\r\ntgt->cq = dma_alloc_coherent(&hba->pcidev->dev, tgt->cq_mem_size,\r\n&tgt->cq_dma, GFP_KERNEL);\r\nif (!tgt->cq) {\r\nprintk(KERN_ERR PFX "unable to allocate CQ memory %d\n",\r\ntgt->cq_mem_size);\r\ngoto mem_alloc_failure;\r\n}\r\nmemset(tgt->cq, 0, tgt->cq_mem_size);\r\ntgt->rq_mem_size = tgt->max_rqes * BNX2FC_RQ_WQE_SIZE;\r\ntgt->rq_mem_size = (tgt->rq_mem_size + (PAGE_SIZE - 1)) & PAGE_MASK;\r\ntgt->rq = dma_alloc_coherent(&hba->pcidev->dev, tgt->rq_mem_size,\r\n&tgt->rq_dma, GFP_KERNEL);\r\nif (!tgt->rq) {\r\nprintk(KERN_ERR PFX "unable to allocate RQ memory %d\n",\r\ntgt->rq_mem_size);\r\ngoto mem_alloc_failure;\r\n}\r\nmemset(tgt->rq, 0, tgt->rq_mem_size);\r\ntgt->rq_pbl_size = (tgt->rq_mem_size / PAGE_SIZE) * sizeof(void *);\r\ntgt->rq_pbl_size = (tgt->rq_pbl_size + (PAGE_SIZE - 1)) & PAGE_MASK;\r\ntgt->rq_pbl = dma_alloc_coherent(&hba->pcidev->dev, tgt->rq_pbl_size,\r\n&tgt->rq_pbl_dma, GFP_KERNEL);\r\nif (!tgt->rq_pbl) {\r\nprintk(KERN_ERR PFX "unable to allocate RQ PBL %d\n",\r\ntgt->rq_pbl_size);\r\ngoto mem_alloc_failure;\r\n}\r\nmemset(tgt->rq_pbl, 0, tgt->rq_pbl_size);\r\nnum_pages = tgt->rq_mem_size / PAGE_SIZE;\r\npage = tgt->rq_dma;\r\npbl = (u32 *)tgt->rq_pbl;\r\nwhile (num_pages--) {\r\n*pbl = (u32)page;\r\npbl++;\r\n*pbl = (u32)((u64)page >> 32);\r\npbl++;\r\npage += PAGE_SIZE;\r\n}\r\ntgt->xferq_mem_size = tgt->max_sqes * BNX2FC_XFERQ_WQE_SIZE;\r\ntgt->xferq_mem_size = (tgt->xferq_mem_size + (PAGE_SIZE - 1)) &\r\nPAGE_MASK;\r\ntgt->xferq = dma_alloc_coherent(&hba->pcidev->dev, tgt->xferq_mem_size,\r\n&tgt->xferq_dma, GFP_KERNEL);\r\nif (!tgt->xferq) {\r\nprintk(KERN_ERR PFX "unable to allocate XFERQ %d\n",\r\ntgt->xferq_mem_size);\r\ngoto mem_alloc_failure;\r\n}\r\nmemset(tgt->xferq, 0, tgt->xferq_mem_size);\r\ntgt->confq_mem_size = tgt->max_sqes * BNX2FC_CONFQ_WQE_SIZE;\r\ntgt->confq_mem_size = (tgt->confq_mem_size + (PAGE_SIZE - 1)) &\r\nPAGE_MASK;\r\ntgt->confq = dma_alloc_coherent(&hba->pcidev->dev, tgt->confq_mem_size,\r\n&tgt->confq_dma, GFP_KERNEL);\r\nif (!tgt->confq) {\r\nprintk(KERN_ERR PFX "unable to allocate CONFQ %d\n",\r\ntgt->confq_mem_size);\r\ngoto mem_alloc_failure;\r\n}\r\nmemset(tgt->confq, 0, tgt->confq_mem_size);\r\ntgt->confq_pbl_size =\r\n(tgt->confq_mem_size / PAGE_SIZE) * sizeof(void *);\r\ntgt->confq_pbl_size =\r\n(tgt->confq_pbl_size + (PAGE_SIZE - 1)) & PAGE_MASK;\r\ntgt->confq_pbl = dma_alloc_coherent(&hba->pcidev->dev,\r\ntgt->confq_pbl_size,\r\n&tgt->confq_pbl_dma, GFP_KERNEL);\r\nif (!tgt->confq_pbl) {\r\nprintk(KERN_ERR PFX "unable to allocate CONFQ PBL %d\n",\r\ntgt->confq_pbl_size);\r\ngoto mem_alloc_failure;\r\n}\r\nmemset(tgt->confq_pbl, 0, tgt->confq_pbl_size);\r\nnum_pages = tgt->confq_mem_size / PAGE_SIZE;\r\npage = tgt->confq_dma;\r\npbl = (u32 *)tgt->confq_pbl;\r\nwhile (num_pages--) {\r\n*pbl = (u32)page;\r\npbl++;\r\n*pbl = (u32)((u64)page >> 32);\r\npbl++;\r\npage += PAGE_SIZE;\r\n}\r\ntgt->conn_db_mem_size = sizeof(struct fcoe_conn_db);\r\ntgt->conn_db = dma_alloc_coherent(&hba->pcidev->dev,\r\ntgt->conn_db_mem_size,\r\n&tgt->conn_db_dma, GFP_KERNEL);\r\nif (!tgt->conn_db) {\r\nprintk(KERN_ERR PFX "unable to allocate conn_db %d\n",\r\ntgt->conn_db_mem_size);\r\ngoto mem_alloc_failure;\r\n}\r\nmemset(tgt->conn_db, 0, tgt->conn_db_mem_size);\r\ntgt->lcq_mem_size = (tgt->max_sqes + 8) * BNX2FC_SQ_WQE_SIZE;\r\ntgt->lcq_mem_size = (tgt->lcq_mem_size + (PAGE_SIZE - 1)) &\r\nPAGE_MASK;\r\ntgt->lcq = dma_alloc_coherent(&hba->pcidev->dev, tgt->lcq_mem_size,\r\n&tgt->lcq_dma, GFP_KERNEL);\r\nif (!tgt->lcq) {\r\nprintk(KERN_ERR PFX "unable to allocate lcq %d\n",\r\ntgt->lcq_mem_size);\r\ngoto mem_alloc_failure;\r\n}\r\nmemset(tgt->lcq, 0, tgt->lcq_mem_size);\r\ntgt->conn_db->rq_prod = 0x8000;\r\nreturn 0;\r\nmem_alloc_failure:\r\nreturn -ENOMEM;\r\n}\r\nstatic void bnx2fc_free_session_resc(struct bnx2fc_hba *hba,\r\nstruct bnx2fc_rport *tgt)\r\n{\r\nvoid __iomem *ctx_base_ptr;\r\nBNX2FC_TGT_DBG(tgt, "Freeing up session resources\n");\r\nspin_lock_bh(&tgt->cq_lock);\r\nctx_base_ptr = tgt->ctx_base;\r\ntgt->ctx_base = NULL;\r\nif (tgt->lcq) {\r\ndma_free_coherent(&hba->pcidev->dev, tgt->lcq_mem_size,\r\ntgt->lcq, tgt->lcq_dma);\r\ntgt->lcq = NULL;\r\n}\r\nif (tgt->conn_db) {\r\ndma_free_coherent(&hba->pcidev->dev, tgt->conn_db_mem_size,\r\ntgt->conn_db, tgt->conn_db_dma);\r\ntgt->conn_db = NULL;\r\n}\r\nif (tgt->confq_pbl) {\r\ndma_free_coherent(&hba->pcidev->dev, tgt->confq_pbl_size,\r\ntgt->confq_pbl, tgt->confq_pbl_dma);\r\ntgt->confq_pbl = NULL;\r\n}\r\nif (tgt->confq) {\r\ndma_free_coherent(&hba->pcidev->dev, tgt->confq_mem_size,\r\ntgt->confq, tgt->confq_dma);\r\ntgt->confq = NULL;\r\n}\r\nif (tgt->xferq) {\r\ndma_free_coherent(&hba->pcidev->dev, tgt->xferq_mem_size,\r\ntgt->xferq, tgt->xferq_dma);\r\ntgt->xferq = NULL;\r\n}\r\nif (tgt->rq_pbl) {\r\ndma_free_coherent(&hba->pcidev->dev, tgt->rq_pbl_size,\r\ntgt->rq_pbl, tgt->rq_pbl_dma);\r\ntgt->rq_pbl = NULL;\r\n}\r\nif (tgt->rq) {\r\ndma_free_coherent(&hba->pcidev->dev, tgt->rq_mem_size,\r\ntgt->rq, tgt->rq_dma);\r\ntgt->rq = NULL;\r\n}\r\nif (tgt->cq) {\r\ndma_free_coherent(&hba->pcidev->dev, tgt->cq_mem_size,\r\ntgt->cq, tgt->cq_dma);\r\ntgt->cq = NULL;\r\n}\r\nif (tgt->sq) {\r\ndma_free_coherent(&hba->pcidev->dev, tgt->sq_mem_size,\r\ntgt->sq, tgt->sq_dma);\r\ntgt->sq = NULL;\r\n}\r\nspin_unlock_bh(&tgt->cq_lock);\r\nif (ctx_base_ptr)\r\niounmap(ctx_base_ptr);\r\n}
