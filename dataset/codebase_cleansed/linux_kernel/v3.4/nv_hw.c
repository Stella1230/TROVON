void NVLockUnlock(struct nvidia_par *par, int Lock)\r\n{\r\nu8 cr11;\r\nVGA_WR08(par->PCIO, 0x3D4, 0x1F);\r\nVGA_WR08(par->PCIO, 0x3D5, Lock ? 0x99 : 0x57);\r\nVGA_WR08(par->PCIO, 0x3D4, 0x11);\r\ncr11 = VGA_RD08(par->PCIO, 0x3D5);\r\nif (Lock)\r\ncr11 |= 0x80;\r\nelse\r\ncr11 &= ~0x80;\r\nVGA_WR08(par->PCIO, 0x3D5, cr11);\r\n}\r\nint NVShowHideCursor(struct nvidia_par *par, int ShowHide)\r\n{\r\nint cur = par->CurrentState->cursor1;\r\npar->CurrentState->cursor1 = (par->CurrentState->cursor1 & 0xFE) |\r\n(ShowHide & 0x01);\r\nVGA_WR08(par->PCIO, 0x3D4, 0x31);\r\nVGA_WR08(par->PCIO, 0x3D5, par->CurrentState->cursor1);\r\nif (par->Architecture == NV_ARCH_40)\r\nNV_WR32(par->PRAMDAC, 0x0300, NV_RD32(par->PRAMDAC, 0x0300));\r\nreturn (cur & 0x01);\r\n}\r\nstatic void nvGetClocks(struct nvidia_par *par, unsigned int *MClk,\r\nunsigned int *NVClk)\r\n{\r\nunsigned int pll, N, M, MB, NB, P;\r\nif (par->Architecture >= NV_ARCH_40) {\r\npll = NV_RD32(par->PMC, 0x4020);\r\nP = (pll >> 16) & 0x07;\r\npll = NV_RD32(par->PMC, 0x4024);\r\nM = pll & 0xFF;\r\nN = (pll >> 8) & 0xFF;\r\nif (((par->Chipset & 0xfff0) == 0x0290) ||\r\n((par->Chipset & 0xfff0) == 0x0390)) {\r\nMB = 1;\r\nNB = 1;\r\n} else {\r\nMB = (pll >> 16) & 0xFF;\r\nNB = (pll >> 24) & 0xFF;\r\n}\r\n*MClk = ((N * NB * par->CrystalFreqKHz) / (M * MB)) >> P;\r\npll = NV_RD32(par->PMC, 0x4000);\r\nP = (pll >> 16) & 0x07;\r\npll = NV_RD32(par->PMC, 0x4004);\r\nM = pll & 0xFF;\r\nN = (pll >> 8) & 0xFF;\r\nMB = (pll >> 16) & 0xFF;\r\nNB = (pll >> 24) & 0xFF;\r\n*NVClk = ((N * NB * par->CrystalFreqKHz) / (M * MB)) >> P;\r\n} else if (par->twoStagePLL) {\r\npll = NV_RD32(par->PRAMDAC0, 0x0504);\r\nM = pll & 0xFF;\r\nN = (pll >> 8) & 0xFF;\r\nP = (pll >> 16) & 0x0F;\r\npll = NV_RD32(par->PRAMDAC0, 0x0574);\r\nif (pll & 0x80000000) {\r\nMB = pll & 0xFF;\r\nNB = (pll >> 8) & 0xFF;\r\n} else {\r\nMB = 1;\r\nNB = 1;\r\n}\r\n*MClk = ((N * NB * par->CrystalFreqKHz) / (M * MB)) >> P;\r\npll = NV_RD32(par->PRAMDAC0, 0x0500);\r\nM = pll & 0xFF;\r\nN = (pll >> 8) & 0xFF;\r\nP = (pll >> 16) & 0x0F;\r\npll = NV_RD32(par->PRAMDAC0, 0x0570);\r\nif (pll & 0x80000000) {\r\nMB = pll & 0xFF;\r\nNB = (pll >> 8) & 0xFF;\r\n} else {\r\nMB = 1;\r\nNB = 1;\r\n}\r\n*NVClk = ((N * NB * par->CrystalFreqKHz) / (M * MB)) >> P;\r\n} else\r\nif (((par->Chipset & 0x0ff0) == 0x0300) ||\r\n((par->Chipset & 0x0ff0) == 0x0330)) {\r\npll = NV_RD32(par->PRAMDAC0, 0x0504);\r\nM = pll & 0x0F;\r\nN = (pll >> 8) & 0xFF;\r\nP = (pll >> 16) & 0x07;\r\nif (pll & 0x00000080) {\r\nMB = (pll >> 4) & 0x07;\r\nNB = (pll >> 19) & 0x1f;\r\n} else {\r\nMB = 1;\r\nNB = 1;\r\n}\r\n*MClk = ((N * NB * par->CrystalFreqKHz) / (M * MB)) >> P;\r\npll = NV_RD32(par->PRAMDAC0, 0x0500);\r\nM = pll & 0x0F;\r\nN = (pll >> 8) & 0xFF;\r\nP = (pll >> 16) & 0x07;\r\nif (pll & 0x00000080) {\r\nMB = (pll >> 4) & 0x07;\r\nNB = (pll >> 19) & 0x1f;\r\n} else {\r\nMB = 1;\r\nNB = 1;\r\n}\r\n*NVClk = ((N * NB * par->CrystalFreqKHz) / (M * MB)) >> P;\r\n} else {\r\npll = NV_RD32(par->PRAMDAC0, 0x0504);\r\nM = pll & 0xFF;\r\nN = (pll >> 8) & 0xFF;\r\nP = (pll >> 16) & 0x0F;\r\n*MClk = (N * par->CrystalFreqKHz / M) >> P;\r\npll = NV_RD32(par->PRAMDAC0, 0x0500);\r\nM = pll & 0xFF;\r\nN = (pll >> 8) & 0xFF;\r\nP = (pll >> 16) & 0x0F;\r\n*NVClk = (N * par->CrystalFreqKHz / M) >> P;\r\n}\r\n}\r\nstatic void nv4CalcArbitration(nv4_fifo_info * fifo, nv4_sim_state * arb)\r\n{\r\nint data, pagemiss, cas, width, video_enable, bpp;\r\nint nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;\r\nint found, mclk_extra, mclk_loop, cbs, m1, p1;\r\nint mclk_freq, pclk_freq, nvclk_freq, mp_enable;\r\nint us_m, us_n, us_p, video_drain_rate, crtc_drain_rate;\r\nint vpm_us, us_video, vlwm, video_fill_us, cpm_us, us_crt, clwm;\r\nfifo->valid = 1;\r\npclk_freq = arb->pclk_khz;\r\nmclk_freq = arb->mclk_khz;\r\nnvclk_freq = arb->nvclk_khz;\r\npagemiss = arb->mem_page_miss;\r\ncas = arb->mem_latency;\r\nwidth = arb->memory_width >> 6;\r\nvideo_enable = arb->enable_video;\r\nbpp = arb->pix_bpp;\r\nmp_enable = arb->enable_mp;\r\nclwm = 0;\r\nvlwm = 0;\r\ncbs = 128;\r\npclks = 2;\r\nnvclks = 2;\r\nnvclks += 2;\r\nnvclks += 1;\r\nmclks = 5;\r\nmclks += 3;\r\nmclks += 1;\r\nmclks += cas;\r\nmclks += 1;\r\nmclks += 1;\r\nmclks += 1;\r\nmclks += 1;\r\nmclk_extra = 3;\r\nnvclks += 2;\r\nnvclks += 1;\r\nnvclks += 1;\r\nnvclks += 1;\r\nif (mp_enable)\r\nmclks += 4;\r\nnvclks += 0;\r\npclks += 0;\r\nfound = 0;\r\nvbs = 0;\r\nwhile (found != 1) {\r\nfifo->valid = 1;\r\nfound = 1;\r\nmclk_loop = mclks + mclk_extra;\r\nus_m = mclk_loop * 1000 * 1000 / mclk_freq;\r\nus_n = nvclks * 1000 * 1000 / nvclk_freq;\r\nus_p = nvclks * 1000 * 1000 / pclk_freq;\r\nif (video_enable) {\r\nvideo_drain_rate = pclk_freq * 2;\r\ncrtc_drain_rate = pclk_freq * bpp / 8;\r\nvpagemiss = 2;\r\nvpagemiss += 1;\r\ncrtpagemiss = 2;\r\nvpm_us =\r\n(vpagemiss * pagemiss) * 1000 * 1000 / mclk_freq;\r\nif (nvclk_freq * 2 > mclk_freq * width)\r\nvideo_fill_us =\r\ncbs * 1000 * 1000 / 16 / nvclk_freq;\r\nelse\r\nvideo_fill_us =\r\ncbs * 1000 * 1000 / (8 * width) /\r\nmclk_freq;\r\nus_video = vpm_us + us_m + us_n + us_p + video_fill_us;\r\nvlwm = us_video * video_drain_rate / (1000 * 1000);\r\nvlwm++;\r\nvbs = 128;\r\nif (vlwm > 128)\r\nvbs = 64;\r\nif (vlwm > (256 - 64))\r\nvbs = 32;\r\nif (nvclk_freq * 2 > mclk_freq * width)\r\nvideo_fill_us =\r\nvbs * 1000 * 1000 / 16 / nvclk_freq;\r\nelse\r\nvideo_fill_us =\r\nvbs * 1000 * 1000 / (8 * width) /\r\nmclk_freq;\r\ncpm_us =\r\ncrtpagemiss * pagemiss * 1000 * 1000 / mclk_freq;\r\nus_crt =\r\nus_video + video_fill_us + cpm_us + us_m + us_n +\r\nus_p;\r\nclwm = us_crt * crtc_drain_rate / (1000 * 1000);\r\nclwm++;\r\n} else {\r\ncrtc_drain_rate = pclk_freq * bpp / 8;\r\ncrtpagemiss = 2;\r\ncrtpagemiss += 1;\r\ncpm_us =\r\ncrtpagemiss * pagemiss * 1000 * 1000 / mclk_freq;\r\nus_crt = cpm_us + us_m + us_n + us_p;\r\nclwm = us_crt * crtc_drain_rate / (1000 * 1000);\r\nclwm++;\r\n}\r\nm1 = clwm + cbs - 512;\r\np1 = m1 * pclk_freq / mclk_freq;\r\np1 = p1 * bpp / 8;\r\nif ((p1 < m1) && (m1 > 0)) {\r\nfifo->valid = 0;\r\nfound = 0;\r\nif (mclk_extra == 0)\r\nfound = 1;\r\nmclk_extra--;\r\n} else if (video_enable) {\r\nif ((clwm > 511) || (vlwm > 255)) {\r\nfifo->valid = 0;\r\nfound = 0;\r\nif (mclk_extra == 0)\r\nfound = 1;\r\nmclk_extra--;\r\n}\r\n} else {\r\nif (clwm > 519) {\r\nfifo->valid = 0;\r\nfound = 0;\r\nif (mclk_extra == 0)\r\nfound = 1;\r\nmclk_extra--;\r\n}\r\n}\r\nif (clwm < 384)\r\nclwm = 384;\r\nif (vlwm < 128)\r\nvlwm = 128;\r\ndata = (int)(clwm);\r\nfifo->graphics_lwm = data;\r\nfifo->graphics_burst_size = 128;\r\ndata = (int)((vlwm + 15));\r\nfifo->video_lwm = data;\r\nfifo->video_burst_size = vbs;\r\n}\r\n}\r\nstatic void nv4UpdateArbitrationSettings(unsigned VClk,\r\nunsigned pixelDepth,\r\nunsigned *burst,\r\nunsigned *lwm, struct nvidia_par *par)\r\n{\r\nnv4_fifo_info fifo_data;\r\nnv4_sim_state sim_data;\r\nunsigned int MClk, NVClk, cfg1;\r\nnvGetClocks(par, &MClk, &NVClk);\r\ncfg1 = NV_RD32(par->PFB, 0x00000204);\r\nsim_data.pix_bpp = (char)pixelDepth;\r\nsim_data.enable_video = 0;\r\nsim_data.enable_mp = 0;\r\nsim_data.memory_width = (NV_RD32(par->PEXTDEV, 0x0000) & 0x10) ?\r\n128 : 64;\r\nsim_data.mem_latency = (char)cfg1 & 0x0F;\r\nsim_data.mem_aligned = 1;\r\nsim_data.mem_page_miss =\r\n(char)(((cfg1 >> 4) & 0x0F) + ((cfg1 >> 31) & 0x01));\r\nsim_data.gr_during_vid = 0;\r\nsim_data.pclk_khz = VClk;\r\nsim_data.mclk_khz = MClk;\r\nsim_data.nvclk_khz = NVClk;\r\nnv4CalcArbitration(&fifo_data, &sim_data);\r\nif (fifo_data.valid) {\r\nint b = fifo_data.graphics_burst_size >> 4;\r\n*burst = 0;\r\nwhile (b >>= 1)\r\n(*burst)++;\r\n*lwm = fifo_data.graphics_lwm >> 3;\r\n}\r\n}\r\nstatic void nv10CalcArbitration(nv10_fifo_info * fifo, nv10_sim_state * arb)\r\n{\r\nint data, pagemiss, width, video_enable, bpp;\r\nint nvclks, mclks, pclks, vpagemiss, crtpagemiss;\r\nint nvclk_fill;\r\nint found, mclk_extra, mclk_loop, cbs, m1;\r\nint mclk_freq, pclk_freq, nvclk_freq, mp_enable;\r\nint us_m, us_m_min, us_n, us_p, crtc_drain_rate;\r\nint vus_m;\r\nint vpm_us, us_video, cpm_us, us_crt, clwm;\r\nint clwm_rnd_down;\r\nint m2us, us_pipe_min, p1clk, p2;\r\nint min_mclk_extra;\r\nint us_min_mclk_extra;\r\nfifo->valid = 1;\r\npclk_freq = arb->pclk_khz;\r\nmclk_freq = arb->mclk_khz;\r\nnvclk_freq = arb->nvclk_khz;\r\npagemiss = arb->mem_page_miss;\r\nwidth = arb->memory_width / 64;\r\nvideo_enable = arb->enable_video;\r\nbpp = arb->pix_bpp;\r\nmp_enable = arb->enable_mp;\r\nclwm = 0;\r\ncbs = 512;\r\npclks = 4;\r\nnvclks = 3;\r\nnvclks += 2;\r\nmclks = 1;\r\nmclks += 1;\r\nmclks += 5;\r\nmclks += 2;\r\nmclks += 2;\r\nmclks += 7;\r\nif (arb->memory_type == 0)\r\nif (arb->memory_width == 64)\r\nmclks += 4;\r\nelse\r\nmclks += 2;\r\nelse if (arb->memory_width == 64)\r\nmclks += 2;\r\nelse\r\nmclks += 1;\r\nif ((!video_enable) && (arb->memory_width == 128)) {\r\nmclk_extra = (bpp == 32) ? 31 : 42;\r\nmin_mclk_extra = 17;\r\n} else {\r\nmclk_extra = (bpp == 32) ? 8 : 4;\r\nmin_mclk_extra = 18;\r\n}\r\nnvclks += 1;\r\nnvclks += 1;\r\nnvclks += 1;\r\nnvclks += 1;\r\nif (mp_enable)\r\nmclks += 4;\r\nnvclks += 0;\r\npclks += 0;\r\nfound = 0;\r\nwhile (found != 1) {\r\nfifo->valid = 1;\r\nfound = 1;\r\nmclk_loop = mclks + mclk_extra;\r\nus_m = mclk_loop * 1000 * 1000 / mclk_freq;\r\nus_m_min = mclks * 1000 * 1000 / mclk_freq;\r\nus_min_mclk_extra = min_mclk_extra * 1000 * 1000 / mclk_freq;\r\nus_n = nvclks * 1000 * 1000 / nvclk_freq;\r\nus_p = pclks * 1000 * 1000 / pclk_freq;\r\nus_pipe_min = us_m_min + us_n + us_p;\r\nvus_m = mclk_loop * 1000 * 1000 / mclk_freq;\r\nif (video_enable) {\r\ncrtc_drain_rate = pclk_freq * bpp / 8;\r\nvpagemiss = 1;\r\nvpagemiss += 1;\r\ncrtpagemiss = 2;\r\nif (mp_enable)\r\ncrtpagemiss += 1;\r\nvpm_us =\r\n(vpagemiss * pagemiss) * 1000 * 1000 / mclk_freq;\r\nus_video = vpm_us + vus_m;\r\ncpm_us =\r\ncrtpagemiss * pagemiss * 1000 * 1000 / mclk_freq;\r\nus_crt = us_video\r\n+ cpm_us\r\n+ us_m + us_n + us_p\r\n;\r\nclwm = us_crt * crtc_drain_rate / (1000 * 1000);\r\nclwm++;\r\n} else {\r\ncrtc_drain_rate = pclk_freq * bpp / 8;\r\ncrtpagemiss = 1;\r\ncrtpagemiss += 1;\r\nif (mp_enable)\r\ncrtpagemiss += 1;\r\ncpm_us =\r\ncrtpagemiss * pagemiss * 1000 * 1000 / mclk_freq;\r\nus_crt = cpm_us + us_m + us_n + us_p;\r\nclwm = us_crt * crtc_drain_rate / (1000 * 1000);\r\nclwm++;\r\nif (width == 1) {\r\nnvclk_fill = nvclk_freq * 8;\r\nif (crtc_drain_rate * 100 >= nvclk_fill * 102)\r\nclwm = 0xfff;\r\nelse if (crtc_drain_rate * 100 >=\r\nnvclk_fill * 98) {\r\nclwm = 1024;\r\ncbs = 512;\r\n}\r\n}\r\n}\r\nclwm_rnd_down = ((int)clwm / 8) * 8;\r\nif (clwm_rnd_down < clwm)\r\nclwm += 8;\r\nm1 = clwm + cbs - 1024;\r\nm2us = us_pipe_min + us_min_mclk_extra;\r\np1clk = m2us * pclk_freq / (1000 * 1000);\r\np2 = p1clk * bpp / 8;\r\nif ((p2 < m1) && (m1 > 0)) {\r\nfifo->valid = 0;\r\nfound = 0;\r\nif (min_mclk_extra == 0) {\r\nif (cbs <= 32) {\r\nfound = 1;\r\n} else {\r\ncbs = cbs / 2;\r\n}\r\n} else {\r\nmin_mclk_extra--;\r\n}\r\n} else {\r\nif (clwm > 1023) {\r\nfifo->valid = 0;\r\nfound = 0;\r\nif (min_mclk_extra == 0)\r\nfound = 1;\r\nelse\r\nmin_mclk_extra--;\r\n}\r\n}\r\nif (clwm < (1024 - cbs + 8))\r\nclwm = 1024 - cbs + 8;\r\ndata = (int)(clwm);\r\nfifo->graphics_lwm = data;\r\nfifo->graphics_burst_size = cbs;\r\nfifo->video_lwm = 1024;\r\nfifo->video_burst_size = 512;\r\n}\r\n}\r\nstatic void nv10UpdateArbitrationSettings(unsigned VClk,\r\nunsigned pixelDepth,\r\nunsigned *burst,\r\nunsigned *lwm,\r\nstruct nvidia_par *par)\r\n{\r\nnv10_fifo_info fifo_data;\r\nnv10_sim_state sim_data;\r\nunsigned int MClk, NVClk, cfg1;\r\nnvGetClocks(par, &MClk, &NVClk);\r\ncfg1 = NV_RD32(par->PFB, 0x0204);\r\nsim_data.pix_bpp = (char)pixelDepth;\r\nsim_data.enable_video = 1;\r\nsim_data.enable_mp = 0;\r\nsim_data.memory_type = (NV_RD32(par->PFB, 0x0200) & 0x01) ? 1 : 0;\r\nsim_data.memory_width = (NV_RD32(par->PEXTDEV, 0x0000) & 0x10) ?\r\n128 : 64;\r\nsim_data.mem_latency = (char)cfg1 & 0x0F;\r\nsim_data.mem_aligned = 1;\r\nsim_data.mem_page_miss =\r\n(char)(((cfg1 >> 4) & 0x0F) + ((cfg1 >> 31) & 0x01));\r\nsim_data.gr_during_vid = 0;\r\nsim_data.pclk_khz = VClk;\r\nsim_data.mclk_khz = MClk;\r\nsim_data.nvclk_khz = NVClk;\r\nnv10CalcArbitration(&fifo_data, &sim_data);\r\nif (fifo_data.valid) {\r\nint b = fifo_data.graphics_burst_size >> 4;\r\n*burst = 0;\r\nwhile (b >>= 1)\r\n(*burst)++;\r\n*lwm = fifo_data.graphics_lwm >> 3;\r\n}\r\n}\r\nstatic void nv30UpdateArbitrationSettings (\r\nstruct nvidia_par *par,\r\nunsigned int *burst,\r\nunsigned int *lwm\r\n)\r\n{\r\nunsigned int MClk, NVClk;\r\nunsigned int fifo_size, burst_size, graphics_lwm;\r\nfifo_size = 2048;\r\nburst_size = 512;\r\ngraphics_lwm = fifo_size - burst_size;\r\nnvGetClocks(par, &MClk, &NVClk);\r\n*burst = 0;\r\nburst_size >>= 5;\r\nwhile(burst_size >>= 1) (*burst)++;\r\n*lwm = graphics_lwm >> 3;\r\n}\r\nstatic void nForceUpdateArbitrationSettings(unsigned VClk,\r\nunsigned pixelDepth,\r\nunsigned *burst,\r\nunsigned *lwm,\r\nstruct nvidia_par *par)\r\n{\r\nnv10_fifo_info fifo_data;\r\nnv10_sim_state sim_data;\r\nunsigned int M, N, P, pll, MClk, NVClk, memctrl;\r\nstruct pci_dev *dev;\r\nif ((par->Chipset & 0x0FF0) == 0x01A0) {\r\nunsigned int uMClkPostDiv;\r\ndev = pci_get_bus_and_slot(0, 3);\r\npci_read_config_dword(dev, 0x6C, &uMClkPostDiv);\r\nuMClkPostDiv = (uMClkPostDiv >> 8) & 0xf;\r\nif (!uMClkPostDiv)\r\nuMClkPostDiv = 4;\r\nMClk = 400000 / uMClkPostDiv;\r\n} else {\r\ndev = pci_get_bus_and_slot(0, 5);\r\npci_read_config_dword(dev, 0x4c, &MClk);\r\nMClk /= 1000;\r\n}\r\npci_dev_put(dev);\r\npll = NV_RD32(par->PRAMDAC0, 0x0500);\r\nM = (pll >> 0) & 0xFF;\r\nN = (pll >> 8) & 0xFF;\r\nP = (pll >> 16) & 0x0F;\r\nNVClk = (N * par->CrystalFreqKHz / M) >> P;\r\nsim_data.pix_bpp = (char)pixelDepth;\r\nsim_data.enable_video = 0;\r\nsim_data.enable_mp = 0;\r\ndev = pci_get_bus_and_slot(0, 1);\r\npci_read_config_dword(dev, 0x7C, &sim_data.memory_type);\r\npci_dev_put(dev);\r\nsim_data.memory_type = (sim_data.memory_type >> 12) & 1;\r\nsim_data.memory_width = 64;\r\ndev = pci_get_bus_and_slot(0, 3);\r\npci_read_config_dword(dev, 0, &memctrl);\r\npci_dev_put(dev);\r\nmemctrl >>= 16;\r\nif ((memctrl == 0x1A9) || (memctrl == 0x1AB) || (memctrl == 0x1ED)) {\r\nu32 dimm[3];\r\ndev = pci_get_bus_and_slot(0, 2);\r\npci_read_config_dword(dev, 0x40, &dimm[0]);\r\ndimm[0] = (dimm[0] >> 8) & 0x4f;\r\npci_read_config_dword(dev, 0x44, &dimm[1]);\r\ndimm[1] = (dimm[1] >> 8) & 0x4f;\r\npci_read_config_dword(dev, 0x48, &dimm[2]);\r\ndimm[2] = (dimm[2] >> 8) & 0x4f;\r\nif ((dimm[0] + dimm[1]) != dimm[2]) {\r\nprintk("nvidiafb: your nForce DIMMs are not arranged "\r\n"in optimal banks!\n");\r\n}\r\npci_dev_put(dev);\r\n}\r\nsim_data.mem_latency = 3;\r\nsim_data.mem_aligned = 1;\r\nsim_data.mem_page_miss = 10;\r\nsim_data.gr_during_vid = 0;\r\nsim_data.pclk_khz = VClk;\r\nsim_data.mclk_khz = MClk;\r\nsim_data.nvclk_khz = NVClk;\r\nnv10CalcArbitration(&fifo_data, &sim_data);\r\nif (fifo_data.valid) {\r\nint b = fifo_data.graphics_burst_size >> 4;\r\n*burst = 0;\r\nwhile (b >>= 1)\r\n(*burst)++;\r\n*lwm = fifo_data.graphics_lwm >> 3;\r\n}\r\n}\r\nstatic void CalcVClock(int clockIn,\r\nint *clockOut, u32 * pllOut, struct nvidia_par *par)\r\n{\r\nunsigned lowM, highM;\r\nunsigned DeltaNew, DeltaOld;\r\nunsigned VClk, Freq;\r\nunsigned M, N, P;\r\nDeltaOld = 0xFFFFFFFF;\r\nVClk = (unsigned)clockIn;\r\nif (par->CrystalFreqKHz == 13500) {\r\nlowM = 7;\r\nhighM = 13;\r\n} else {\r\nlowM = 8;\r\nhighM = 14;\r\n}\r\nfor (P = 0; P <= 4; P++) {\r\nFreq = VClk << P;\r\nif ((Freq >= 128000) && (Freq <= 350000)) {\r\nfor (M = lowM; M <= highM; M++) {\r\nN = ((VClk << P) * M) / par->CrystalFreqKHz;\r\nif (N <= 255) {\r\nFreq =\r\n((par->CrystalFreqKHz * N) /\r\nM) >> P;\r\nif (Freq > VClk)\r\nDeltaNew = Freq - VClk;\r\nelse\r\nDeltaNew = VClk - Freq;\r\nif (DeltaNew < DeltaOld) {\r\n*pllOut =\r\n(P << 16) | (N << 8) | M;\r\n*clockOut = Freq;\r\nDeltaOld = DeltaNew;\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void CalcVClock2Stage(int clockIn,\r\nint *clockOut,\r\nu32 * pllOut,\r\nu32 * pllBOut, struct nvidia_par *par)\r\n{\r\nunsigned DeltaNew, DeltaOld;\r\nunsigned VClk, Freq;\r\nunsigned M, N, P;\r\nDeltaOld = 0xFFFFFFFF;\r\n*pllBOut = 0x80000401;\r\nVClk = (unsigned)clockIn;\r\nfor (P = 0; P <= 6; P++) {\r\nFreq = VClk << P;\r\nif ((Freq >= 400000) && (Freq <= 1000000)) {\r\nfor (M = 1; M <= 13; M++) {\r\nN = ((VClk << P) * M) /\r\n(par->CrystalFreqKHz << 2);\r\nif ((N >= 5) && (N <= 255)) {\r\nFreq =\r\n(((par->CrystalFreqKHz << 2) * N) /\r\nM) >> P;\r\nif (Freq > VClk)\r\nDeltaNew = Freq - VClk;\r\nelse\r\nDeltaNew = VClk - Freq;\r\nif (DeltaNew < DeltaOld) {\r\n*pllOut =\r\n(P << 16) | (N << 8) | M;\r\n*clockOut = Freq;\r\nDeltaOld = DeltaNew;\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nvoid NVCalcStateExt(struct nvidia_par *par,\r\nRIVA_HW_STATE * state,\r\nint bpp,\r\nint width,\r\nint hDisplaySize, int height, int dotClock, int flags)\r\n{\r\nint pixelDepth, VClk = 0;\r\nstate->bpp = bpp;\r\nstate->width = width;\r\nstate->height = height;\r\npixelDepth = (bpp + 1) / 8;\r\nif (par->twoStagePLL)\r\nCalcVClock2Stage(dotClock, &VClk, &state->pll, &state->pllB,\r\npar);\r\nelse\r\nCalcVClock(dotClock, &VClk, &state->pll, par);\r\nswitch (par->Architecture) {\r\ncase NV_ARCH_04:\r\nnv4UpdateArbitrationSettings(VClk,\r\npixelDepth * 8,\r\n&(state->arbitration0),\r\n&(state->arbitration1), par);\r\nstate->cursor0 = 0x00;\r\nstate->cursor1 = 0xbC;\r\nif (flags & FB_VMODE_DOUBLE)\r\nstate->cursor1 |= 2;\r\nstate->cursor2 = 0x00000000;\r\nstate->pllsel = 0x10000700;\r\nstate->config = 0x00001114;\r\nstate->general = bpp == 16 ? 0x00101100 : 0x00100100;\r\nstate->repaint1 = hDisplaySize < 1280 ? 0x04 : 0x00;\r\nbreak;\r\ncase NV_ARCH_40:\r\nif (!par->FlatPanel)\r\nstate->control = NV_RD32(par->PRAMDAC0, 0x0580) &\r\n0xeffffeff;\r\ncase NV_ARCH_10:\r\ncase NV_ARCH_20:\r\ncase NV_ARCH_30:\r\ndefault:\r\nif ((par->Chipset & 0xfff0) == 0x0240 ||\r\n(par->Chipset & 0xfff0) == 0x03d0) {\r\nstate->arbitration0 = 256;\r\nstate->arbitration1 = 0x0480;\r\n} else if (((par->Chipset & 0xffff) == 0x01A0) ||\r\n((par->Chipset & 0xffff) == 0x01f0)) {\r\nnForceUpdateArbitrationSettings(VClk,\r\npixelDepth * 8,\r\n&(state->arbitration0),\r\n&(state->arbitration1),\r\npar);\r\n} else if (par->Architecture < NV_ARCH_30) {\r\nnv10UpdateArbitrationSettings(VClk,\r\npixelDepth * 8,\r\n&(state->arbitration0),\r\n&(state->arbitration1),\r\npar);\r\n} else {\r\nnv30UpdateArbitrationSettings(par,\r\n&(state->arbitration0),\r\n&(state->arbitration1));\r\n}\r\nstate->cursor0 = 0x80 | (par->CursorStart >> 17);\r\nstate->cursor1 = (par->CursorStart >> 11) << 2;\r\nstate->cursor2 = par->CursorStart >> 24;\r\nif (flags & FB_VMODE_DOUBLE)\r\nstate->cursor1 |= 2;\r\nstate->pllsel = 0x10000700;\r\nstate->config = NV_RD32(par->PFB, 0x00000200);\r\nstate->general = bpp == 16 ? 0x00101100 : 0x00100100;\r\nstate->repaint1 = hDisplaySize < 1280 ? 0x04 : 0x00;\r\nbreak;\r\n}\r\nif (bpp != 8)\r\nstate->general |= 0x00000030;\r\nstate->repaint0 = (((width / 8) * pixelDepth) & 0x700) >> 3;\r\nstate->pixel = (pixelDepth > 2) ? 3 : pixelDepth;\r\n}\r\nvoid NVLoadStateExt(struct nvidia_par *par, RIVA_HW_STATE * state)\r\n{\r\nint i, j;\r\nNV_WR32(par->PMC, 0x0140, 0x00000000);\r\nNV_WR32(par->PMC, 0x0200, 0xFFFF00FF);\r\nNV_WR32(par->PMC, 0x0200, 0xFFFFFFFF);\r\nNV_WR32(par->PTIMER, 0x0200 * 4, 0x00000008);\r\nNV_WR32(par->PTIMER, 0x0210 * 4, 0x00000003);\r\nNV_WR32(par->PTIMER, 0x0140 * 4, 0x00000000);\r\nNV_WR32(par->PTIMER, 0x0100 * 4, 0xFFFFFFFF);\r\nif (par->Architecture == NV_ARCH_04) {\r\nif (state)\r\nNV_WR32(par->PFB, 0x0200, state->config);\r\n} else if ((par->Architecture < NV_ARCH_40) ||\r\n(par->Chipset & 0xfff0) == 0x0040) {\r\nfor (i = 0; i < 8; i++) {\r\nNV_WR32(par->PFB, 0x0240 + (i * 0x10), 0);\r\nNV_WR32(par->PFB, 0x0244 + (i * 0x10),\r\npar->FbMapSize - 1);\r\n}\r\n} else {\r\nint regions = 12;\r\nif (((par->Chipset & 0xfff0) == 0x0090) ||\r\n((par->Chipset & 0xfff0) == 0x01D0) ||\r\n((par->Chipset & 0xfff0) == 0x0290) ||\r\n((par->Chipset & 0xfff0) == 0x0390) ||\r\n((par->Chipset & 0xfff0) == 0x03D0))\r\nregions = 15;\r\nfor(i = 0; i < regions; i++) {\r\nNV_WR32(par->PFB, 0x0600 + (i * 0x10), 0);\r\nNV_WR32(par->PFB, 0x0604 + (i * 0x10),\r\npar->FbMapSize - 1);\r\n}\r\n}\r\nif (par->Architecture >= NV_ARCH_40) {\r\nNV_WR32(par->PRAMIN, 0x0000 * 4, 0x80000010);\r\nNV_WR32(par->PRAMIN, 0x0001 * 4, 0x00101202);\r\nNV_WR32(par->PRAMIN, 0x0002 * 4, 0x80000011);\r\nNV_WR32(par->PRAMIN, 0x0003 * 4, 0x00101204);\r\nNV_WR32(par->PRAMIN, 0x0004 * 4, 0x80000012);\r\nNV_WR32(par->PRAMIN, 0x0005 * 4, 0x00101206);\r\nNV_WR32(par->PRAMIN, 0x0006 * 4, 0x80000013);\r\nNV_WR32(par->PRAMIN, 0x0007 * 4, 0x00101208);\r\nNV_WR32(par->PRAMIN, 0x0008 * 4, 0x80000014);\r\nNV_WR32(par->PRAMIN, 0x0009 * 4, 0x0010120A);\r\nNV_WR32(par->PRAMIN, 0x000A * 4, 0x80000015);\r\nNV_WR32(par->PRAMIN, 0x000B * 4, 0x0010120C);\r\nNV_WR32(par->PRAMIN, 0x000C * 4, 0x80000016);\r\nNV_WR32(par->PRAMIN, 0x000D * 4, 0x0010120E);\r\nNV_WR32(par->PRAMIN, 0x000E * 4, 0x80000017);\r\nNV_WR32(par->PRAMIN, 0x000F * 4, 0x00101210);\r\nNV_WR32(par->PRAMIN, 0x0800 * 4, 0x00003000);\r\nNV_WR32(par->PRAMIN, 0x0801 * 4, par->FbMapSize - 1);\r\nNV_WR32(par->PRAMIN, 0x0802 * 4, 0x00000002);\r\nNV_WR32(par->PRAMIN, 0x0808 * 4, 0x02080062);\r\nNV_WR32(par->PRAMIN, 0x0809 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x080A * 4, 0x00001200);\r\nNV_WR32(par->PRAMIN, 0x080B * 4, 0x00001200);\r\nNV_WR32(par->PRAMIN, 0x080C * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x080D * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0810 * 4, 0x02080043);\r\nNV_WR32(par->PRAMIN, 0x0811 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0812 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0813 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0814 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0815 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0818 * 4, 0x02080044);\r\nNV_WR32(par->PRAMIN, 0x0819 * 4, 0x02000000);\r\nNV_WR32(par->PRAMIN, 0x081A * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x081B * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x081C * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x081D * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0820 * 4, 0x02080019);\r\nNV_WR32(par->PRAMIN, 0x0821 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0822 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0823 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0824 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0825 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0828 * 4, 0x020A005C);\r\nNV_WR32(par->PRAMIN, 0x0829 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x082A * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x082B * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x082C * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x082D * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0830 * 4, 0x0208009F);\r\nNV_WR32(par->PRAMIN, 0x0831 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0832 * 4, 0x00001200);\r\nNV_WR32(par->PRAMIN, 0x0833 * 4, 0x00001200);\r\nNV_WR32(par->PRAMIN, 0x0834 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0835 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0838 * 4, 0x0208004A);\r\nNV_WR32(par->PRAMIN, 0x0839 * 4, 0x02000000);\r\nNV_WR32(par->PRAMIN, 0x083A * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x083B * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x083C * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x083D * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0840 * 4, 0x02080077);\r\nNV_WR32(par->PRAMIN, 0x0841 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0842 * 4, 0x00001200);\r\nNV_WR32(par->PRAMIN, 0x0843 * 4, 0x00001200);\r\nNV_WR32(par->PRAMIN, 0x0844 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0845 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x084C * 4, 0x00003002);\r\nNV_WR32(par->PRAMIN, 0x084D * 4, 0x00007FFF);\r\nNV_WR32(par->PRAMIN, 0x084E * 4,\r\npar->FbUsableSize | 0x00000002);\r\n#ifdef __BIG_ENDIAN\r\nNV_WR32(par->PRAMIN, 0x080A * 4,\r\nNV_RD32(par->PRAMIN, 0x080A * 4) | 0x01000000);\r\nNV_WR32(par->PRAMIN, 0x0812 * 4,\r\nNV_RD32(par->PRAMIN, 0x0812 * 4) | 0x01000000);\r\nNV_WR32(par->PRAMIN, 0x081A * 4,\r\nNV_RD32(par->PRAMIN, 0x081A * 4) | 0x01000000);\r\nNV_WR32(par->PRAMIN, 0x0822 * 4,\r\nNV_RD32(par->PRAMIN, 0x0822 * 4) | 0x01000000);\r\nNV_WR32(par->PRAMIN, 0x082A * 4,\r\nNV_RD32(par->PRAMIN, 0x082A * 4) | 0x01000000);\r\nNV_WR32(par->PRAMIN, 0x0832 * 4,\r\nNV_RD32(par->PRAMIN, 0x0832 * 4) | 0x01000000);\r\nNV_WR32(par->PRAMIN, 0x083A * 4,\r\nNV_RD32(par->PRAMIN, 0x083A * 4) | 0x01000000);\r\nNV_WR32(par->PRAMIN, 0x0842 * 4,\r\nNV_RD32(par->PRAMIN, 0x0842 * 4) | 0x01000000);\r\nNV_WR32(par->PRAMIN, 0x0819 * 4, 0x01000000);\r\nNV_WR32(par->PRAMIN, 0x0839 * 4, 0x01000000);\r\n#endif\r\n} else {\r\nNV_WR32(par->PRAMIN, 0x0000 * 4, 0x80000010);\r\nNV_WR32(par->PRAMIN, 0x0001 * 4, 0x80011201);\r\nNV_WR32(par->PRAMIN, 0x0002 * 4, 0x80000011);\r\nNV_WR32(par->PRAMIN, 0x0003 * 4, 0x80011202);\r\nNV_WR32(par->PRAMIN, 0x0004 * 4, 0x80000012);\r\nNV_WR32(par->PRAMIN, 0x0005 * 4, 0x80011203);\r\nNV_WR32(par->PRAMIN, 0x0006 * 4, 0x80000013);\r\nNV_WR32(par->PRAMIN, 0x0007 * 4, 0x80011204);\r\nNV_WR32(par->PRAMIN, 0x0008 * 4, 0x80000014);\r\nNV_WR32(par->PRAMIN, 0x0009 * 4, 0x80011205);\r\nNV_WR32(par->PRAMIN, 0x000A * 4, 0x80000015);\r\nNV_WR32(par->PRAMIN, 0x000B * 4, 0x80011206);\r\nNV_WR32(par->PRAMIN, 0x000C * 4, 0x80000016);\r\nNV_WR32(par->PRAMIN, 0x000D * 4, 0x80011207);\r\nNV_WR32(par->PRAMIN, 0x000E * 4, 0x80000017);\r\nNV_WR32(par->PRAMIN, 0x000F * 4, 0x80011208);\r\nNV_WR32(par->PRAMIN, 0x0800 * 4, 0x00003000);\r\nNV_WR32(par->PRAMIN, 0x0801 * 4, par->FbMapSize - 1);\r\nNV_WR32(par->PRAMIN, 0x0802 * 4, 0x00000002);\r\nNV_WR32(par->PRAMIN, 0x0803 * 4, 0x00000002);\r\nif (par->Architecture >= NV_ARCH_10)\r\nNV_WR32(par->PRAMIN, 0x0804 * 4, 0x01008062);\r\nelse\r\nNV_WR32(par->PRAMIN, 0x0804 * 4, 0x01008042);\r\nNV_WR32(par->PRAMIN, 0x0805 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0806 * 4, 0x12001200);\r\nNV_WR32(par->PRAMIN, 0x0807 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0808 * 4, 0x01008043);\r\nNV_WR32(par->PRAMIN, 0x0809 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x080A * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x080B * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x080C * 4, 0x01008044);\r\nNV_WR32(par->PRAMIN, 0x080D * 4, 0x00000002);\r\nNV_WR32(par->PRAMIN, 0x080E * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x080F * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0810 * 4, 0x01008019);\r\nNV_WR32(par->PRAMIN, 0x0811 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0812 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0813 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0814 * 4, 0x0100A05C);\r\nNV_WR32(par->PRAMIN, 0x0815 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0816 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0817 * 4, 0x00000000);\r\nif (par->WaitVSyncPossible)\r\nNV_WR32(par->PRAMIN, 0x0818 * 4, 0x0100809F);\r\nelse\r\nNV_WR32(par->PRAMIN, 0x0818 * 4, 0x0100805F);\r\nNV_WR32(par->PRAMIN, 0x0819 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x081A * 4, 0x12001200);\r\nNV_WR32(par->PRAMIN, 0x081B * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x081C * 4, 0x0100804A);\r\nNV_WR32(par->PRAMIN, 0x081D * 4, 0x00000002);\r\nNV_WR32(par->PRAMIN, 0x081E * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x081F * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0820 * 4, 0x01018077);\r\nNV_WR32(par->PRAMIN, 0x0821 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0822 * 4, 0x12001200);\r\nNV_WR32(par->PRAMIN, 0x0823 * 4, 0x00000000);\r\nNV_WR32(par->PRAMIN, 0x0824 * 4, 0x00003002);\r\nNV_WR32(par->PRAMIN, 0x0825 * 4, 0x00007FFF);\r\nNV_WR32(par->PRAMIN, 0x0826 * 4,\r\npar->FbUsableSize | 0x00000002);\r\nNV_WR32(par->PRAMIN, 0x0827 * 4, 0x00000002);\r\n#ifdef __BIG_ENDIAN\r\nNV_WR32(par->PRAMIN, 0x0804 * 4,\r\nNV_RD32(par->PRAMIN, 0x0804 * 4) | 0x00080000);\r\nNV_WR32(par->PRAMIN, 0x0808 * 4,\r\nNV_RD32(par->PRAMIN, 0x0808 * 4) | 0x00080000);\r\nNV_WR32(par->PRAMIN, 0x080C * 4,\r\nNV_RD32(par->PRAMIN, 0x080C * 4) | 0x00080000);\r\nNV_WR32(par->PRAMIN, 0x0810 * 4,\r\nNV_RD32(par->PRAMIN, 0x0810 * 4) | 0x00080000);\r\nNV_WR32(par->PRAMIN, 0x0814 * 4,\r\nNV_RD32(par->PRAMIN, 0x0814 * 4) | 0x00080000);\r\nNV_WR32(par->PRAMIN, 0x0818 * 4,\r\nNV_RD32(par->PRAMIN, 0x0818 * 4) | 0x00080000);\r\nNV_WR32(par->PRAMIN, 0x081C * 4,\r\nNV_RD32(par->PRAMIN, 0x081C * 4) | 0x00080000);\r\nNV_WR32(par->PRAMIN, 0x0820 * 4,\r\nNV_RD32(par->PRAMIN, 0x0820 * 4) | 0x00080000);\r\nNV_WR32(par->PRAMIN, 0x080D * 4, 0x00000001);\r\nNV_WR32(par->PRAMIN, 0x081D * 4, 0x00000001);\r\n#endif\r\n}\r\nif (par->Architecture < NV_ARCH_10) {\r\nif ((par->Chipset & 0x0fff) == 0x0020) {\r\nNV_WR32(par->PRAMIN, 0x0824 * 4,\r\nNV_RD32(par->PRAMIN, 0x0824 * 4) | 0x00020000);\r\nNV_WR32(par->PRAMIN, 0x0826 * 4,\r\nNV_RD32(par->PRAMIN,\r\n0x0826 * 4) + par->FbAddress);\r\n}\r\nNV_WR32(par->PGRAPH, 0x0080, 0x000001FF);\r\nNV_WR32(par->PGRAPH, 0x0080, 0x1230C000);\r\nNV_WR32(par->PGRAPH, 0x0084, 0x72111101);\r\nNV_WR32(par->PGRAPH, 0x0088, 0x11D5F071);\r\nNV_WR32(par->PGRAPH, 0x008C, 0x0004FF31);\r\nNV_WR32(par->PGRAPH, 0x008C, 0x4004FF31);\r\nNV_WR32(par->PGRAPH, 0x0140, 0x00000000);\r\nNV_WR32(par->PGRAPH, 0x0100, 0xFFFFFFFF);\r\nNV_WR32(par->PGRAPH, 0x0170, 0x10010100);\r\nNV_WR32(par->PGRAPH, 0x0710, 0xFFFFFFFF);\r\nNV_WR32(par->PGRAPH, 0x0720, 0x00000001);\r\nNV_WR32(par->PGRAPH, 0x0810, 0x00000000);\r\nNV_WR32(par->PGRAPH, 0x0608, 0xFFFFFFFF);\r\n} else {\r\nNV_WR32(par->PGRAPH, 0x0080, 0xFFFFFFFF);\r\nNV_WR32(par->PGRAPH, 0x0080, 0x00000000);\r\nNV_WR32(par->PGRAPH, 0x0140, 0x00000000);\r\nNV_WR32(par->PGRAPH, 0x0100, 0xFFFFFFFF);\r\nNV_WR32(par->PGRAPH, 0x0144, 0x10010100);\r\nNV_WR32(par->PGRAPH, 0x0714, 0xFFFFFFFF);\r\nNV_WR32(par->PGRAPH, 0x0720, 0x00000001);\r\nNV_WR32(par->PGRAPH, 0x0710,\r\nNV_RD32(par->PGRAPH, 0x0710) & 0x0007ff00);\r\nNV_WR32(par->PGRAPH, 0x0710,\r\nNV_RD32(par->PGRAPH, 0x0710) | 0x00020100);\r\nif (par->Architecture == NV_ARCH_10) {\r\nNV_WR32(par->PGRAPH, 0x0084, 0x00118700);\r\nNV_WR32(par->PGRAPH, 0x0088, 0x24E00810);\r\nNV_WR32(par->PGRAPH, 0x008C, 0x55DE0030);\r\nfor (i = 0; i < 32; i++)\r\nNV_WR32(&par->PGRAPH[(0x0B00 / 4) + i], 0,\r\nNV_RD32(&par->PFB[(0x0240 / 4) + i],\r\n0));\r\nNV_WR32(par->PGRAPH, 0x640, 0);\r\nNV_WR32(par->PGRAPH, 0x644, 0);\r\nNV_WR32(par->PGRAPH, 0x684, par->FbMapSize - 1);\r\nNV_WR32(par->PGRAPH, 0x688, par->FbMapSize - 1);\r\nNV_WR32(par->PGRAPH, 0x0810, 0x00000000);\r\nNV_WR32(par->PGRAPH, 0x0608, 0xFFFFFFFF);\r\n} else {\r\nif (par->Architecture >= NV_ARCH_40) {\r\nNV_WR32(par->PGRAPH, 0x0084, 0x401287c0);\r\nNV_WR32(par->PGRAPH, 0x008C, 0x60de8051);\r\nNV_WR32(par->PGRAPH, 0x0090, 0x00008000);\r\nNV_WR32(par->PGRAPH, 0x0610, 0x00be3c5f);\r\nNV_WR32(par->PGRAPH, 0x0bc4,\r\nNV_RD32(par->PGRAPH, 0x0bc4) |\r\n0x00008000);\r\nj = NV_RD32(par->REGS, 0x1540) & 0xff;\r\nif (j) {\r\nfor (i = 0; !(j & 1); j >>= 1, i++);\r\nNV_WR32(par->PGRAPH, 0x5000, i);\r\n}\r\nif ((par->Chipset & 0xfff0) == 0x0040) {\r\nNV_WR32(par->PGRAPH, 0x09b0,\r\n0x83280fff);\r\nNV_WR32(par->PGRAPH, 0x09b4,\r\n0x000000a0);\r\n} else {\r\nNV_WR32(par->PGRAPH, 0x0820,\r\n0x83280eff);\r\nNV_WR32(par->PGRAPH, 0x0824,\r\n0x000000a0);\r\n}\r\nswitch (par->Chipset & 0xfff0) {\r\ncase 0x0040:\r\ncase 0x0210:\r\nNV_WR32(par->PGRAPH, 0x09b8,\r\n0x0078e366);\r\nNV_WR32(par->PGRAPH, 0x09bc,\r\n0x0000014c);\r\nNV_WR32(par->PFB, 0x033C,\r\nNV_RD32(par->PFB, 0x33C) &\r\n0xffff7fff);\r\nbreak;\r\ncase 0x00C0:\r\ncase 0x0120:\r\nNV_WR32(par->PGRAPH, 0x0828,\r\n0x007596ff);\r\nNV_WR32(par->PGRAPH, 0x082C,\r\n0x00000108);\r\nbreak;\r\ncase 0x0160:\r\ncase 0x01D0:\r\ncase 0x0240:\r\ncase 0x03D0:\r\nNV_WR32(par->PMC, 0x1700,\r\nNV_RD32(par->PFB, 0x020C));\r\nNV_WR32(par->PMC, 0x1704, 0);\r\nNV_WR32(par->PMC, 0x1708, 0);\r\nNV_WR32(par->PMC, 0x170C,\r\nNV_RD32(par->PFB, 0x020C));\r\nNV_WR32(par->PGRAPH, 0x0860, 0);\r\nNV_WR32(par->PGRAPH, 0x0864, 0);\r\nNV_WR32(par->PRAMDAC, 0x0608,\r\nNV_RD32(par->PRAMDAC,\r\n0x0608) | 0x00100000);\r\nbreak;\r\ncase 0x0140:\r\nNV_WR32(par->PGRAPH, 0x0828,\r\n0x0072cb77);\r\nNV_WR32(par->PGRAPH, 0x082C,\r\n0x00000108);\r\nbreak;\r\ncase 0x0220:\r\nNV_WR32(par->PGRAPH, 0x0860, 0);\r\nNV_WR32(par->PGRAPH, 0x0864, 0);\r\nNV_WR32(par->PRAMDAC, 0x0608,\r\nNV_RD32(par->PRAMDAC, 0x0608) |\r\n0x00100000);\r\nbreak;\r\ncase 0x0090:\r\ncase 0x0290:\r\ncase 0x0390:\r\nNV_WR32(par->PRAMDAC, 0x0608,\r\nNV_RD32(par->PRAMDAC, 0x0608) |\r\n0x00100000);\r\nNV_WR32(par->PGRAPH, 0x0828,\r\n0x07830610);\r\nNV_WR32(par->PGRAPH, 0x082C,\r\n0x0000016A);\r\nbreak;\r\ndefault:\r\nbreak;\r\n};\r\nNV_WR32(par->PGRAPH, 0x0b38, 0x2ffff800);\r\nNV_WR32(par->PGRAPH, 0x0b3c, 0x00006000);\r\nNV_WR32(par->PGRAPH, 0x032C, 0x01000000);\r\nNV_WR32(par->PGRAPH, 0x0220, 0x00001200);\r\n} else if (par->Architecture == NV_ARCH_30) {\r\nNV_WR32(par->PGRAPH, 0x0084, 0x40108700);\r\nNV_WR32(par->PGRAPH, 0x0890, 0x00140000);\r\nNV_WR32(par->PGRAPH, 0x008C, 0xf00e0431);\r\nNV_WR32(par->PGRAPH, 0x0090, 0x00008000);\r\nNV_WR32(par->PGRAPH, 0x0610, 0xf04b1f36);\r\nNV_WR32(par->PGRAPH, 0x0B80, 0x1002d888);\r\nNV_WR32(par->PGRAPH, 0x0B88, 0x62ff007f);\r\n} else {\r\nNV_WR32(par->PGRAPH, 0x0084, 0x00118700);\r\nNV_WR32(par->PGRAPH, 0x008C, 0xF20E0431);\r\nNV_WR32(par->PGRAPH, 0x0090, 0x00000000);\r\nNV_WR32(par->PGRAPH, 0x009C, 0x00000040);\r\nif ((par->Chipset & 0x0ff0) >= 0x0250) {\r\nNV_WR32(par->PGRAPH, 0x0890,\r\n0x00080000);\r\nNV_WR32(par->PGRAPH, 0x0610,\r\n0x304B1FB6);\r\nNV_WR32(par->PGRAPH, 0x0B80,\r\n0x18B82880);\r\nNV_WR32(par->PGRAPH, 0x0B84,\r\n0x44000000);\r\nNV_WR32(par->PGRAPH, 0x0098,\r\n0x40000080);\r\nNV_WR32(par->PGRAPH, 0x0B88,\r\n0x000000ff);\r\n} else {\r\nNV_WR32(par->PGRAPH, 0x0880,\r\n0x00080000);\r\nNV_WR32(par->PGRAPH, 0x0094,\r\n0x00000005);\r\nNV_WR32(par->PGRAPH, 0x0B80,\r\n0x45CAA208);\r\nNV_WR32(par->PGRAPH, 0x0B84,\r\n0x24000000);\r\nNV_WR32(par->PGRAPH, 0x0098,\r\n0x00000040);\r\nNV_WR32(par->PGRAPH, 0x0750,\r\n0x00E00038);\r\nNV_WR32(par->PGRAPH, 0x0754,\r\n0x00000030);\r\nNV_WR32(par->PGRAPH, 0x0750,\r\n0x00E10038);\r\nNV_WR32(par->PGRAPH, 0x0754,\r\n0x00000030);\r\n}\r\n}\r\nif ((par->Architecture < NV_ARCH_40) ||\r\n((par->Chipset & 0xfff0) == 0x0040)) {\r\nfor (i = 0; i < 32; i++) {\r\nNV_WR32(par->PGRAPH, 0x0900 + i*4,\r\nNV_RD32(par->PFB, 0x0240 +i*4));\r\nNV_WR32(par->PGRAPH, 0x6900 + i*4,\r\nNV_RD32(par->PFB, 0x0240 +i*4));\r\n}\r\n} else {\r\nif (((par->Chipset & 0xfff0) == 0x0090) ||\r\n((par->Chipset & 0xfff0) == 0x01D0) ||\r\n((par->Chipset & 0xfff0) == 0x0290) ||\r\n((par->Chipset & 0xfff0) == 0x0390) ||\r\n((par->Chipset & 0xfff0) == 0x03D0)) {\r\nfor (i = 0; i < 60; i++) {\r\nNV_WR32(par->PGRAPH,\r\n0x0D00 + i*4,\r\nNV_RD32(par->PFB,\r\n0x0600 + i*4));\r\nNV_WR32(par->PGRAPH,\r\n0x6900 + i*4,\r\nNV_RD32(par->PFB,\r\n0x0600 + i*4));\r\n}\r\n} else {\r\nfor (i = 0; i < 48; i++) {\r\nNV_WR32(par->PGRAPH,\r\n0x0900 + i*4,\r\nNV_RD32(par->PFB,\r\n0x0600 + i*4));\r\nif(((par->Chipset & 0xfff0)\r\n!= 0x0160) &&\r\n((par->Chipset & 0xfff0)\r\n!= 0x0220) &&\r\n((par->Chipset & 0xfff0)\r\n!= 0x240))\r\nNV_WR32(par->PGRAPH,\r\n0x6900 + i*4,\r\nNV_RD32(par->PFB,\r\n0x0600 + i*4));\r\n}\r\n}\r\n}\r\nif (par->Architecture >= NV_ARCH_40) {\r\nif ((par->Chipset & 0xfff0) == 0x0040) {\r\nNV_WR32(par->PGRAPH, 0x09A4,\r\nNV_RD32(par->PFB, 0x0200));\r\nNV_WR32(par->PGRAPH, 0x09A8,\r\nNV_RD32(par->PFB, 0x0204));\r\nNV_WR32(par->PGRAPH, 0x69A4,\r\nNV_RD32(par->PFB, 0x0200));\r\nNV_WR32(par->PGRAPH, 0x69A8,\r\nNV_RD32(par->PFB, 0x0204));\r\nNV_WR32(par->PGRAPH, 0x0820, 0);\r\nNV_WR32(par->PGRAPH, 0x0824, 0);\r\nNV_WR32(par->PGRAPH, 0x0864,\r\npar->FbMapSize - 1);\r\nNV_WR32(par->PGRAPH, 0x0868,\r\npar->FbMapSize - 1);\r\n} else {\r\nif ((par->Chipset & 0xfff0) == 0x0090 ||\r\n(par->Chipset & 0xfff0) == 0x01D0 ||\r\n(par->Chipset & 0xfff0) == 0x0290 ||\r\n(par->Chipset & 0xfff0) == 0x0390) {\r\nNV_WR32(par->PGRAPH, 0x0DF0,\r\nNV_RD32(par->PFB, 0x0200));\r\nNV_WR32(par->PGRAPH, 0x0DF4,\r\nNV_RD32(par->PFB, 0x0204));\r\n} else {\r\nNV_WR32(par->PGRAPH, 0x09F0,\r\nNV_RD32(par->PFB, 0x0200));\r\nNV_WR32(par->PGRAPH, 0x09F4,\r\nNV_RD32(par->PFB, 0x0204));\r\n}\r\nNV_WR32(par->PGRAPH, 0x69F0,\r\nNV_RD32(par->PFB, 0x0200));\r\nNV_WR32(par->PGRAPH, 0x69F4,\r\nNV_RD32(par->PFB, 0x0204));\r\nNV_WR32(par->PGRAPH, 0x0840, 0);\r\nNV_WR32(par->PGRAPH, 0x0844, 0);\r\nNV_WR32(par->PGRAPH, 0x08a0,\r\npar->FbMapSize - 1);\r\nNV_WR32(par->PGRAPH, 0x08a4,\r\npar->FbMapSize - 1);\r\n}\r\n} else {\r\nNV_WR32(par->PGRAPH, 0x09A4,\r\nNV_RD32(par->PFB, 0x0200));\r\nNV_WR32(par->PGRAPH, 0x09A8,\r\nNV_RD32(par->PFB, 0x0204));\r\nNV_WR32(par->PGRAPH, 0x0750, 0x00EA0000);\r\nNV_WR32(par->PGRAPH, 0x0754,\r\nNV_RD32(par->PFB, 0x0200));\r\nNV_WR32(par->PGRAPH, 0x0750, 0x00EA0004);\r\nNV_WR32(par->PGRAPH, 0x0754,\r\nNV_RD32(par->PFB, 0x0204));\r\nNV_WR32(par->PGRAPH, 0x0820, 0);\r\nNV_WR32(par->PGRAPH, 0x0824, 0);\r\nNV_WR32(par->PGRAPH, 0x0864,\r\npar->FbMapSize - 1);\r\nNV_WR32(par->PGRAPH, 0x0868,\r\npar->FbMapSize - 1);\r\n}\r\nNV_WR32(par->PGRAPH, 0x0B20, 0x00000000);\r\nNV_WR32(par->PGRAPH, 0x0B04, 0xFFFFFFFF);\r\n}\r\n}\r\nNV_WR32(par->PGRAPH, 0x053C, 0);\r\nNV_WR32(par->PGRAPH, 0x0540, 0);\r\nNV_WR32(par->PGRAPH, 0x0544, 0x00007FFF);\r\nNV_WR32(par->PGRAPH, 0x0548, 0x00007FFF);\r\nNV_WR32(par->PFIFO, 0x0140 * 4, 0x00000000);\r\nNV_WR32(par->PFIFO, 0x0141 * 4, 0x00000001);\r\nNV_WR32(par->PFIFO, 0x0480 * 4, 0x00000000);\r\nNV_WR32(par->PFIFO, 0x0494 * 4, 0x00000000);\r\nif (par->Architecture >= NV_ARCH_40)\r\nNV_WR32(par->PFIFO, 0x0481 * 4, 0x00010000);\r\nelse\r\nNV_WR32(par->PFIFO, 0x0481 * 4, 0x00000100);\r\nNV_WR32(par->PFIFO, 0x0490 * 4, 0x00000000);\r\nNV_WR32(par->PFIFO, 0x0491 * 4, 0x00000000);\r\nif (par->Architecture >= NV_ARCH_40)\r\nNV_WR32(par->PFIFO, 0x048B * 4, 0x00001213);\r\nelse\r\nNV_WR32(par->PFIFO, 0x048B * 4, 0x00001209);\r\nNV_WR32(par->PFIFO, 0x0400 * 4, 0x00000000);\r\nNV_WR32(par->PFIFO, 0x0414 * 4, 0x00000000);\r\nNV_WR32(par->PFIFO, 0x0084 * 4, 0x03000100);\r\nNV_WR32(par->PFIFO, 0x0085 * 4, 0x00000110);\r\nNV_WR32(par->PFIFO, 0x0086 * 4, 0x00000112);\r\nNV_WR32(par->PFIFO, 0x0143 * 4, 0x0000FFFF);\r\nNV_WR32(par->PFIFO, 0x0496 * 4, 0x0000FFFF);\r\nNV_WR32(par->PFIFO, 0x0050 * 4, 0x00000000);\r\nNV_WR32(par->PFIFO, 0x0040 * 4, 0xFFFFFFFF);\r\nNV_WR32(par->PFIFO, 0x0415 * 4, 0x00000001);\r\nNV_WR32(par->PFIFO, 0x048C * 4, 0x00000000);\r\nNV_WR32(par->PFIFO, 0x04A0 * 4, 0x00000000);\r\n#ifdef __BIG_ENDIAN\r\nNV_WR32(par->PFIFO, 0x0489 * 4, 0x800F0078);\r\n#else\r\nNV_WR32(par->PFIFO, 0x0489 * 4, 0x000F0078);\r\n#endif\r\nNV_WR32(par->PFIFO, 0x0488 * 4, 0x00000001);\r\nNV_WR32(par->PFIFO, 0x0480 * 4, 0x00000001);\r\nNV_WR32(par->PFIFO, 0x0494 * 4, 0x00000001);\r\nNV_WR32(par->PFIFO, 0x0495 * 4, 0x00000001);\r\nNV_WR32(par->PFIFO, 0x0140 * 4, 0x00000001);\r\nif (!state) {\r\npar->CurrentState = NULL;\r\nreturn;\r\n}\r\nif (par->Architecture >= NV_ARCH_10) {\r\nif (par->twoHeads) {\r\nNV_WR32(par->PCRTC0, 0x0860, state->head);\r\nNV_WR32(par->PCRTC0, 0x2860, state->head2);\r\n}\r\nNV_WR32(par->PRAMDAC, 0x0404, NV_RD32(par->PRAMDAC, 0x0404) |\r\n(1 << 25));\r\nNV_WR32(par->PMC, 0x8704, 1);\r\nNV_WR32(par->PMC, 0x8140, 0);\r\nNV_WR32(par->PMC, 0x8920, 0);\r\nNV_WR32(par->PMC, 0x8924, 0);\r\nNV_WR32(par->PMC, 0x8908, par->FbMapSize - 1);\r\nNV_WR32(par->PMC, 0x890C, par->FbMapSize - 1);\r\nNV_WR32(par->PMC, 0x1588, 0);\r\nNV_WR32(par->PCRTC, 0x0810, state->cursorConfig);\r\nNV_WR32(par->PCRTC, 0x0830, state->displayV - 3);\r\nNV_WR32(par->PCRTC, 0x0834, state->displayV - 1);\r\nif (par->FlatPanel) {\r\nif ((par->Chipset & 0x0ff0) == 0x0110) {\r\nNV_WR32(par->PRAMDAC, 0x0528, state->dither);\r\n} else if (par->twoHeads) {\r\nNV_WR32(par->PRAMDAC, 0x083C, state->dither);\r\n}\r\nVGA_WR08(par->PCIO, 0x03D4, 0x53);\r\nVGA_WR08(par->PCIO, 0x03D5, state->timingH);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x54);\r\nVGA_WR08(par->PCIO, 0x03D5, state->timingV);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x21);\r\nVGA_WR08(par->PCIO, 0x03D5, 0xfa);\r\n}\r\nVGA_WR08(par->PCIO, 0x03D4, 0x41);\r\nVGA_WR08(par->PCIO, 0x03D5, state->extra);\r\n}\r\nVGA_WR08(par->PCIO, 0x03D4, 0x19);\r\nVGA_WR08(par->PCIO, 0x03D5, state->repaint0);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x1A);\r\nVGA_WR08(par->PCIO, 0x03D5, state->repaint1);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x25);\r\nVGA_WR08(par->PCIO, 0x03D5, state->screen);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x28);\r\nVGA_WR08(par->PCIO, 0x03D5, state->pixel);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x2D);\r\nVGA_WR08(par->PCIO, 0x03D5, state->horiz);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x1C);\r\nVGA_WR08(par->PCIO, 0x03D5, state->fifo);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x1B);\r\nVGA_WR08(par->PCIO, 0x03D5, state->arbitration0);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x20);\r\nVGA_WR08(par->PCIO, 0x03D5, state->arbitration1);\r\nif(par->Architecture >= NV_ARCH_30) {\r\nVGA_WR08(par->PCIO, 0x03D4, 0x47);\r\nVGA_WR08(par->PCIO, 0x03D5, state->arbitration1 >> 8);\r\n}\r\nVGA_WR08(par->PCIO, 0x03D4, 0x30);\r\nVGA_WR08(par->PCIO, 0x03D5, state->cursor0);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x31);\r\nVGA_WR08(par->PCIO, 0x03D5, state->cursor1);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x2F);\r\nVGA_WR08(par->PCIO, 0x03D5, state->cursor2);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x39);\r\nVGA_WR08(par->PCIO, 0x03D5, state->interlace);\r\nif (!par->FlatPanel) {\r\nif (par->Architecture >= NV_ARCH_40)\r\nNV_WR32(par->PRAMDAC0, 0x0580, state->control);\r\nNV_WR32(par->PRAMDAC0, 0x050C, state->pllsel);\r\nNV_WR32(par->PRAMDAC0, 0x0508, state->vpll);\r\nif (par->twoHeads)\r\nNV_WR32(par->PRAMDAC0, 0x0520, state->vpll2);\r\nif (par->twoStagePLL) {\r\nNV_WR32(par->PRAMDAC0, 0x0578, state->vpllB);\r\nNV_WR32(par->PRAMDAC0, 0x057C, state->vpll2B);\r\n}\r\n} else {\r\nNV_WR32(par->PRAMDAC, 0x0848, state->scale);\r\nNV_WR32(par->PRAMDAC, 0x0828, state->crtcSync +\r\npar->PanelTweak);\r\n}\r\nNV_WR32(par->PRAMDAC, 0x0600, state->general);\r\nNV_WR32(par->PCRTC, 0x0140, 0);\r\nNV_WR32(par->PCRTC, 0x0100, 1);\r\npar->CurrentState = state;\r\n}\r\nvoid NVUnloadStateExt(struct nvidia_par *par, RIVA_HW_STATE * state) {\r\nVGA_WR08(par->PCIO, 0x03D4, 0x19);\r\nstate->repaint0 = VGA_RD08(par->PCIO, 0x03D5);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x1A);\r\nstate->repaint1 = VGA_RD08(par->PCIO, 0x03D5);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x25);\r\nstate->screen = VGA_RD08(par->PCIO, 0x03D5);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x28);\r\nstate->pixel = VGA_RD08(par->PCIO, 0x03D5);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x2D);\r\nstate->horiz = VGA_RD08(par->PCIO, 0x03D5);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x1C);\r\nstate->fifo = VGA_RD08(par->PCIO, 0x03D5);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x1B);\r\nstate->arbitration0 = VGA_RD08(par->PCIO, 0x03D5);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x20);\r\nstate->arbitration1 = VGA_RD08(par->PCIO, 0x03D5);\r\nif(par->Architecture >= NV_ARCH_30) {\r\nVGA_WR08(par->PCIO, 0x03D4, 0x47);\r\nstate->arbitration1 |= (VGA_RD08(par->PCIO, 0x03D5) & 1) << 8;\r\n}\r\nVGA_WR08(par->PCIO, 0x03D4, 0x30);\r\nstate->cursor0 = VGA_RD08(par->PCIO, 0x03D5);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x31);\r\nstate->cursor1 = VGA_RD08(par->PCIO, 0x03D5);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x2F);\r\nstate->cursor2 = VGA_RD08(par->PCIO, 0x03D5);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x39);\r\nstate->interlace = VGA_RD08(par->PCIO, 0x03D5);\r\nstate->vpll = NV_RD32(par->PRAMDAC0, 0x0508);\r\nif (par->twoHeads)\r\nstate->vpll2 = NV_RD32(par->PRAMDAC0, 0x0520);\r\nif (par->twoStagePLL) {\r\nstate->vpllB = NV_RD32(par->PRAMDAC0, 0x0578);\r\nstate->vpll2B = NV_RD32(par->PRAMDAC0, 0x057C);\r\n}\r\nstate->pllsel = NV_RD32(par->PRAMDAC0, 0x050C);\r\nstate->general = NV_RD32(par->PRAMDAC, 0x0600);\r\nstate->scale = NV_RD32(par->PRAMDAC, 0x0848);\r\nstate->config = NV_RD32(par->PFB, 0x0200);\r\nif (par->Architecture >= NV_ARCH_40 && !par->FlatPanel)\r\nstate->control = NV_RD32(par->PRAMDAC0, 0x0580);\r\nif (par->Architecture >= NV_ARCH_10) {\r\nif (par->twoHeads) {\r\nstate->head = NV_RD32(par->PCRTC0, 0x0860);\r\nstate->head2 = NV_RD32(par->PCRTC0, 0x2860);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x44);\r\nstate->crtcOwner = VGA_RD08(par->PCIO, 0x03D5);\r\n}\r\nVGA_WR08(par->PCIO, 0x03D4, 0x41);\r\nstate->extra = VGA_RD08(par->PCIO, 0x03D5);\r\nstate->cursorConfig = NV_RD32(par->PCRTC, 0x0810);\r\nif ((par->Chipset & 0x0ff0) == 0x0110) {\r\nstate->dither = NV_RD32(par->PRAMDAC, 0x0528);\r\n} else if (par->twoHeads) {\r\nstate->dither = NV_RD32(par->PRAMDAC, 0x083C);\r\n}\r\nif (par->FlatPanel) {\r\nVGA_WR08(par->PCIO, 0x03D4, 0x53);\r\nstate->timingH = VGA_RD08(par->PCIO, 0x03D5);\r\nVGA_WR08(par->PCIO, 0x03D4, 0x54);\r\nstate->timingV = VGA_RD08(par->PCIO, 0x03D5);\r\n}\r\n}\r\n}\r\nvoid NVSetStartAddress(struct nvidia_par *par, u32 start)\r\n{\r\nNV_WR32(par->PCRTC, 0x800, start);\r\n}
