void qib_disarm_piobufs(struct qib_devdata *dd, unsigned first, unsigned cnt)\r\n{\r\nunsigned long flags;\r\nunsigned i;\r\nunsigned last;\r\nlast = first + cnt;\r\nspin_lock_irqsave(&dd->pioavail_lock, flags);\r\nfor (i = first; i < last; i++) {\r\n__clear_bit(i, dd->pio_need_disarm);\r\ndd->f_sendctrl(dd->pport, QIB_SENDCTRL_DISARM_BUF(i));\r\n}\r\nspin_unlock_irqrestore(&dd->pioavail_lock, flags);\r\n}\r\nint qib_disarm_piobufs_ifneeded(struct qib_ctxtdata *rcd)\r\n{\r\nstruct qib_devdata *dd = rcd->dd;\r\nunsigned i;\r\nunsigned last;\r\nunsigned n = 0;\r\nlast = rcd->pio_base + rcd->piocnt;\r\nif (rcd->user_event_mask) {\r\nclear_bit(_QIB_EVENT_DISARM_BUFS_BIT, &rcd->user_event_mask[0]);\r\nfor (i = 1; i < rcd->subctxt_cnt; i++)\r\nclear_bit(_QIB_EVENT_DISARM_BUFS_BIT,\r\n&rcd->user_event_mask[i]);\r\n}\r\nspin_lock_irq(&dd->pioavail_lock);\r\nfor (i = rcd->pio_base; i < last; i++) {\r\nif (__test_and_clear_bit(i, dd->pio_need_disarm)) {\r\nn++;\r\ndd->f_sendctrl(rcd->ppd, QIB_SENDCTRL_DISARM_BUF(i));\r\n}\r\n}\r\nspin_unlock_irq(&dd->pioavail_lock);\r\nreturn 0;\r\n}\r\nstatic struct qib_pportdata *is_sdma_buf(struct qib_devdata *dd, unsigned i)\r\n{\r\nstruct qib_pportdata *ppd;\r\nunsigned pidx;\r\nfor (pidx = 0; pidx < dd->num_pports; pidx++) {\r\nppd = dd->pport + pidx;\r\nif (i >= ppd->sdma_state.first_sendbuf &&\r\ni < ppd->sdma_state.last_sendbuf)\r\nreturn ppd;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int find_ctxt(struct qib_devdata *dd, unsigned bufn)\r\n{\r\nstruct qib_ctxtdata *rcd;\r\nunsigned ctxt;\r\nint ret = 0;\r\nspin_lock(&dd->uctxt_lock);\r\nfor (ctxt = dd->first_user_ctxt; ctxt < dd->cfgctxts; ctxt++) {\r\nrcd = dd->rcd[ctxt];\r\nif (!rcd || bufn < rcd->pio_base ||\r\nbufn >= rcd->pio_base + rcd->piocnt)\r\ncontinue;\r\nif (rcd->user_event_mask) {\r\nint i;\r\nset_bit(_QIB_EVENT_DISARM_BUFS_BIT,\r\n&rcd->user_event_mask[0]);\r\nfor (i = 1; i < rcd->subctxt_cnt; i++)\r\nset_bit(_QIB_EVENT_DISARM_BUFS_BIT,\r\n&rcd->user_event_mask[i]);\r\n}\r\nret = 1;\r\nbreak;\r\n}\r\nspin_unlock(&dd->uctxt_lock);\r\nreturn ret;\r\n}\r\nvoid qib_disarm_piobufs_set(struct qib_devdata *dd, unsigned long *mask,\r\nunsigned cnt)\r\n{\r\nstruct qib_pportdata *ppd, *pppd[QIB_MAX_IB_PORTS];\r\nunsigned i;\r\nunsigned long flags;\r\nfor (i = 0; i < dd->num_pports; i++)\r\npppd[i] = NULL;\r\nfor (i = 0; i < cnt; i++) {\r\nint which;\r\nif (!test_bit(i, mask))\r\ncontinue;\r\nppd = is_sdma_buf(dd, i);\r\nif (ppd) {\r\npppd[ppd->port] = ppd;\r\ncontinue;\r\n}\r\nspin_lock_irqsave(&dd->pioavail_lock, flags);\r\nif (test_bit(i, dd->pio_writing) ||\r\n(!test_bit(i << 1, dd->pioavailkernel) &&\r\nfind_ctxt(dd, i))) {\r\n__set_bit(i, dd->pio_need_disarm);\r\nwhich = 0;\r\n} else {\r\nwhich = 1;\r\ndd->f_sendctrl(dd->pport, QIB_SENDCTRL_DISARM_BUF(i));\r\n}\r\nspin_unlock_irqrestore(&dd->pioavail_lock, flags);\r\n}\r\nfor (i = 0; i < dd->num_pports; i++)\r\nif (pppd[i])\r\nqib_cancel_sends(pppd[i]);\r\n}\r\nstatic void update_send_bufs(struct qib_devdata *dd)\r\n{\r\nunsigned long flags;\r\nunsigned i;\r\nconst unsigned piobregs = dd->pioavregs;\r\nif (!dd->pioavailregs_dma)\r\nreturn;\r\nspin_lock_irqsave(&dd->pioavail_lock, flags);\r\nfor (i = 0; i < piobregs; i++) {\r\nu64 pchbusy, pchg, piov, pnew;\r\npiov = le64_to_cpu(dd->pioavailregs_dma[i]);\r\npchg = dd->pioavailkernel[i] &\r\n~(dd->pioavailshadow[i] ^ piov);\r\npchbusy = pchg << QLOGIC_IB_SENDPIOAVAIL_BUSY_SHIFT;\r\nif (pchg && (pchbusy & dd->pioavailshadow[i])) {\r\npnew = dd->pioavailshadow[i] & ~pchbusy;\r\npnew |= piov & pchbusy;\r\ndd->pioavailshadow[i] = pnew;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dd->pioavail_lock, flags);\r\n}\r\nstatic noinline void no_send_bufs(struct qib_devdata *dd)\r\n{\r\ndd->upd_pio_shadow = 1;\r\nqib_stats.sps_nopiobufs++;\r\n}\r\nu32 __iomem *qib_getsendbuf_range(struct qib_devdata *dd, u32 *pbufnum,\r\nu32 first, u32 last)\r\n{\r\nunsigned i, j, updated = 0;\r\nunsigned nbufs;\r\nunsigned long flags;\r\nunsigned long *shadow = dd->pioavailshadow;\r\nu32 __iomem *buf;\r\nif (!(dd->flags & QIB_PRESENT))\r\nreturn NULL;\r\nnbufs = last - first + 1;\r\nif (dd->upd_pio_shadow) {\r\nupdate_send_bufs(dd);\r\nupdated++;\r\n}\r\ni = first;\r\nrescan:\r\nspin_lock_irqsave(&dd->pioavail_lock, flags);\r\nfor (j = 0; j < nbufs; j++, i++) {\r\nif (i > last)\r\ni = first;\r\nif (__test_and_set_bit((2 * i) + 1, shadow))\r\ncontinue;\r\n__change_bit(2 * i, shadow);\r\n__set_bit(i, dd->pio_writing);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&dd->pioavail_lock, flags);\r\nif (j == nbufs) {\r\nif (!updated) {\r\nupdate_send_bufs(dd);\r\nupdated++;\r\ni = first;\r\ngoto rescan;\r\n}\r\nno_send_bufs(dd);\r\nbuf = NULL;\r\n} else {\r\nif (i < dd->piobcnt2k)\r\nbuf = (u32 __iomem *)(dd->pio2kbase +\r\ni * dd->palign);\r\nelse if (i < dd->piobcnt2k + dd->piobcnt4k || !dd->piovl15base)\r\nbuf = (u32 __iomem *)(dd->pio4kbase +\r\n(i - dd->piobcnt2k) * dd->align4k);\r\nelse\r\nbuf = (u32 __iomem *)(dd->piovl15base +\r\n(i - (dd->piobcnt2k + dd->piobcnt4k)) *\r\ndd->align4k);\r\nif (pbufnum)\r\n*pbufnum = i;\r\ndd->upd_pio_shadow = 0;\r\n}\r\nreturn buf;\r\n}\r\nvoid qib_sendbuf_done(struct qib_devdata *dd, unsigned n)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dd->pioavail_lock, flags);\r\n__clear_bit(n, dd->pio_writing);\r\nif (__test_and_clear_bit(n, dd->pio_need_disarm))\r\ndd->f_sendctrl(dd->pport, QIB_SENDCTRL_DISARM_BUF(n));\r\nspin_unlock_irqrestore(&dd->pioavail_lock, flags);\r\n}\r\nvoid qib_chg_pioavailkernel(struct qib_devdata *dd, unsigned start,\r\nunsigned len, u32 avail, struct qib_ctxtdata *rcd)\r\n{\r\nunsigned long flags;\r\nunsigned end;\r\nunsigned ostart = start;\r\nstart *= 2;\r\nend = start + len * 2;\r\nspin_lock_irqsave(&dd->pioavail_lock, flags);\r\nwhile (start < end) {\r\nif (avail) {\r\nunsigned long dma;\r\nint i;\r\ni = start / BITS_PER_LONG;\r\n__clear_bit(QLOGIC_IB_SENDPIOAVAIL_BUSY_SHIFT + start,\r\ndd->pioavailshadow);\r\ndma = (unsigned long)\r\nle64_to_cpu(dd->pioavailregs_dma[i]);\r\nif (test_bit((QLOGIC_IB_SENDPIOAVAIL_CHECK_SHIFT +\r\nstart) % BITS_PER_LONG, &dma))\r\n__set_bit(QLOGIC_IB_SENDPIOAVAIL_CHECK_SHIFT +\r\nstart, dd->pioavailshadow);\r\nelse\r\n__clear_bit(QLOGIC_IB_SENDPIOAVAIL_CHECK_SHIFT\r\n+ start, dd->pioavailshadow);\r\n__set_bit(start, dd->pioavailkernel);\r\n} else {\r\n__set_bit(start + QLOGIC_IB_SENDPIOAVAIL_BUSY_SHIFT,\r\ndd->pioavailshadow);\r\n__clear_bit(start, dd->pioavailkernel);\r\n}\r\nstart += 2;\r\n}\r\nspin_unlock_irqrestore(&dd->pioavail_lock, flags);\r\ndd->f_txchk_change(dd, ostart, len, avail, rcd);\r\n}\r\nvoid qib_cancel_sends(struct qib_pportdata *ppd)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nstruct qib_ctxtdata *rcd;\r\nunsigned long flags;\r\nunsigned ctxt;\r\nunsigned i;\r\nunsigned last;\r\nfor (ctxt = dd->first_user_ctxt; ctxt < dd->cfgctxts; ctxt++) {\r\nspin_lock_irqsave(&dd->uctxt_lock, flags);\r\nrcd = dd->rcd[ctxt];\r\nif (rcd && rcd->ppd == ppd) {\r\nlast = rcd->pio_base + rcd->piocnt;\r\nif (rcd->user_event_mask) {\r\nset_bit(_QIB_EVENT_DISARM_BUFS_BIT,\r\n&rcd->user_event_mask[0]);\r\nfor (i = 1; i < rcd->subctxt_cnt; i++)\r\nset_bit(_QIB_EVENT_DISARM_BUFS_BIT,\r\n&rcd->user_event_mask[i]);\r\n}\r\ni = rcd->pio_base;\r\nspin_unlock_irqrestore(&dd->uctxt_lock, flags);\r\nspin_lock_irqsave(&dd->pioavail_lock, flags);\r\nfor (; i < last; i++)\r\n__set_bit(i, dd->pio_need_disarm);\r\nspin_unlock_irqrestore(&dd->pioavail_lock, flags);\r\n} else\r\nspin_unlock_irqrestore(&dd->uctxt_lock, flags);\r\n}\r\nif (!(dd->flags & QIB_HAS_SEND_DMA))\r\ndd->f_sendctrl(ppd, QIB_SENDCTRL_DISARM_ALL |\r\nQIB_SENDCTRL_FLUSH);\r\n}\r\nvoid qib_force_pio_avail_update(struct qib_devdata *dd)\r\n{\r\ndd->f_sendctrl(dd->pport, QIB_SENDCTRL_AVAIL_BLIP);\r\n}\r\nvoid qib_hol_down(struct qib_pportdata *ppd)\r\n{\r\nif (!(ppd->lflags & QIBL_IB_AUTONEG_INPROG))\r\nqib_cancel_sends(ppd);\r\n}\r\nvoid qib_hol_init(struct qib_pportdata *ppd)\r\n{\r\nif (ppd->hol_state != QIB_HOL_INIT) {\r\nppd->hol_state = QIB_HOL_INIT;\r\nmod_timer(&ppd->hol_timer,\r\njiffies + msecs_to_jiffies(qib_hol_timeout_ms));\r\n}\r\n}\r\nvoid qib_hol_up(struct qib_pportdata *ppd)\r\n{\r\nppd->hol_state = QIB_HOL_UP;\r\n}\r\nvoid qib_hol_event(unsigned long opaque)\r\n{\r\nstruct qib_pportdata *ppd = (struct qib_pportdata *)opaque;\r\nif (!(ppd->dd->flags & QIB_INITTED))\r\nreturn;\r\nif (ppd->hol_state != QIB_HOL_UP) {\r\nqib_hol_down(ppd);\r\nmod_timer(&ppd->hol_timer,\r\njiffies + msecs_to_jiffies(qib_hol_timeout_ms));\r\n}\r\n}
