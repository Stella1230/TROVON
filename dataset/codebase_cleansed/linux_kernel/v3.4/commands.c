static int iwm_send_lmac_ptrough_cmd(struct iwm_priv *iwm,\r\nu8 lmac_cmd_id,\r\nconst void *lmac_payload,\r\nu16 lmac_payload_size,\r\nu8 resp)\r\n{\r\nstruct iwm_udma_wifi_cmd udma_cmd = UDMA_LMAC_INIT;\r\nstruct iwm_umac_cmd umac_cmd;\r\nstruct iwm_lmac_cmd lmac_cmd;\r\nlmac_cmd.id = lmac_cmd_id;\r\numac_cmd.id = UMAC_CMD_OPCODE_WIFI_PASS_THROUGH;\r\numac_cmd.resp = resp;\r\nreturn iwm_hal_send_host_cmd(iwm, &udma_cmd, &umac_cmd, &lmac_cmd,\r\nlmac_payload, lmac_payload_size);\r\n}\r\nint iwm_send_wifi_if_cmd(struct iwm_priv *iwm, void *payload, u16 payload_size,\r\nbool resp)\r\n{\r\nstruct iwm_umac_wifi_if *hdr = (struct iwm_umac_wifi_if *)payload;\r\nstruct iwm_udma_wifi_cmd udma_cmd = UDMA_UMAC_INIT;\r\nstruct iwm_umac_cmd umac_cmd;\r\nint ret;\r\nu8 oid = hdr->oid;\r\nif (!test_bit(IWM_STATUS_READY, &iwm->status)) {\r\nIWM_ERR(iwm, "Interface is not ready yet");\r\nreturn -EAGAIN;\r\n}\r\numac_cmd.id = UMAC_CMD_OPCODE_WIFI_IF_WRAPPER;\r\numac_cmd.resp = resp;\r\nret = iwm_hal_send_umac_cmd(iwm, &udma_cmd, &umac_cmd,\r\npayload, payload_size);\r\nif (resp) {\r\nret = wait_event_interruptible_timeout(iwm->wifi_ntfy_queue,\r\ntest_and_clear_bit(oid, &iwm->wifi_ntfy[0]),\r\n3 * HZ);\r\nreturn ret ? 0 : -EBUSY;\r\n}\r\nreturn ret;\r\n}\r\nint iwm_send_prio_table(struct iwm_priv *iwm)\r\n{\r\nstruct iwm_coex_prio_table_cmd coex_table_cmd;\r\nu32 coex_enabled, mode_enabled;\r\nmemset(&coex_table_cmd, 0, sizeof(struct iwm_coex_prio_table_cmd));\r\ncoex_table_cmd.flags = COEX_FLAGS_STA_TABLE_VALID_MSK;\r\nswitch (modparam_wiwi) {\r\ncase COEX_MODE_XOR:\r\ncase COEX_MODE_CM:\r\ncoex_enabled = 1;\r\nbreak;\r\ndefault:\r\ncoex_enabled = 0;\r\nbreak;\r\n}\r\nswitch (iwm->conf.mode) {\r\ncase UMAC_MODE_BSS:\r\ncase UMAC_MODE_IBSS:\r\nmode_enabled = 1;\r\nbreak;\r\ndefault:\r\nmode_enabled = 0;\r\nbreak;\r\n}\r\nif (coex_enabled && mode_enabled) {\r\ncoex_table_cmd.flags |= COEX_FLAGS_COEX_ENABLE_MSK |\r\nCOEX_FLAGS_ASSOC_WAKEUP_UMASK_MSK |\r\nCOEX_FLAGS_UNASSOC_WAKEUP_UMASK_MSK;\r\nswitch (modparam_wiwi) {\r\ncase COEX_MODE_XOR:\r\nmemcpy(coex_table_cmd.sta_prio, iwm_sta_xor_prio_tbl,\r\nsizeof(iwm_sta_xor_prio_tbl));\r\nbreak;\r\ncase COEX_MODE_CM:\r\nmemcpy(coex_table_cmd.sta_prio, iwm_sta_cm_prio_tbl,\r\nsizeof(iwm_sta_cm_prio_tbl));\r\nbreak;\r\ndefault:\r\nIWM_ERR(iwm, "Invalid coex_mode 0x%x\n",\r\nmodparam_wiwi);\r\nbreak;\r\n}\r\n} else\r\nIWM_WARN(iwm, "coexistense disabled\n");\r\nreturn iwm_send_lmac_ptrough_cmd(iwm, COEX_PRIORITY_TABLE_CMD,\r\n&coex_table_cmd,\r\nsizeof(struct iwm_coex_prio_table_cmd), 0);\r\n}\r\nint iwm_send_init_calib_cfg(struct iwm_priv *iwm, u8 calib_requested)\r\n{\r\nstruct iwm_lmac_cal_cfg_cmd cal_cfg_cmd;\r\nmemset(&cal_cfg_cmd, 0, sizeof(struct iwm_lmac_cal_cfg_cmd));\r\ncal_cfg_cmd.ucode_cfg.init.enable = cpu_to_le32(calib_requested);\r\ncal_cfg_cmd.ucode_cfg.init.start = cpu_to_le32(calib_requested);\r\ncal_cfg_cmd.ucode_cfg.init.send_res = cpu_to_le32(calib_requested);\r\ncal_cfg_cmd.ucode_cfg.flags =\r\ncpu_to_le32(CALIB_CFG_FLAG_SEND_COMPLETE_NTFY_AFTER_MSK);\r\nreturn iwm_send_lmac_ptrough_cmd(iwm, CALIBRATION_CFG_CMD, &cal_cfg_cmd,\r\nsizeof(struct iwm_lmac_cal_cfg_cmd), 1);\r\n}\r\nint iwm_send_periodic_calib_cfg(struct iwm_priv *iwm, u8 calib_requested)\r\n{\r\nstruct iwm_lmac_cal_cfg_cmd cal_cfg_cmd;\r\nmemset(&cal_cfg_cmd, 0, sizeof(struct iwm_lmac_cal_cfg_cmd));\r\ncal_cfg_cmd.ucode_cfg.periodic.enable = cpu_to_le32(calib_requested);\r\ncal_cfg_cmd.ucode_cfg.periodic.start = cpu_to_le32(calib_requested);\r\nreturn iwm_send_lmac_ptrough_cmd(iwm, CALIBRATION_CFG_CMD, &cal_cfg_cmd,\r\nsizeof(struct iwm_lmac_cal_cfg_cmd), 0);\r\n}\r\nint iwm_store_rxiq_calib_result(struct iwm_priv *iwm)\r\n{\r\nstruct iwm_calib_rxiq *rxiq;\r\nu8 *eeprom_rxiq = iwm_eeprom_access(iwm, IWM_EEPROM_CALIB_RXIQ);\r\nint grplen = sizeof(struct iwm_calib_rxiq_group);\r\nrxiq = kzalloc(sizeof(struct iwm_calib_rxiq), GFP_KERNEL);\r\nif (!rxiq) {\r\nIWM_ERR(iwm, "Couldn't alloc memory for RX IQ\n");\r\nreturn -ENOMEM;\r\n}\r\neeprom_rxiq = iwm_eeprom_access(iwm, IWM_EEPROM_CALIB_RXIQ);\r\nif (IS_ERR(eeprom_rxiq)) {\r\nIWM_ERR(iwm, "Couldn't access EEPROM RX IQ entry\n");\r\nkfree(rxiq);\r\nreturn PTR_ERR(eeprom_rxiq);\r\n}\r\niwm->calib_res[SHILOH_PHY_CALIBRATE_RX_IQ_CMD].buf = (u8 *)rxiq;\r\niwm->calib_res[SHILOH_PHY_CALIBRATE_RX_IQ_CMD].size = sizeof(*rxiq);\r\nrxiq->hdr.opcode = SHILOH_PHY_CALIBRATE_RX_IQ_CMD;\r\nrxiq->hdr.first_grp = 0;\r\nrxiq->hdr.grp_num = 1;\r\nrxiq->hdr.all_data_valid = 1;\r\nmemcpy(&rxiq->group[0], eeprom_rxiq, 4 * grplen);\r\nmemcpy(&rxiq->group[4], eeprom_rxiq + 6 * grplen, grplen);\r\nreturn 0;\r\n}\r\nint iwm_send_calib_results(struct iwm_priv *iwm)\r\n{\r\nint i, ret = 0;\r\nfor (i = PHY_CALIBRATE_OPCODES_NUM; i < CALIBRATION_CMD_NUM; i++) {\r\nif (test_bit(i - PHY_CALIBRATE_OPCODES_NUM,\r\n&iwm->calib_done_map)) {\r\nIWM_DBG_CMD(iwm, DBG,\r\n"Send calibration %d result\n", i);\r\nret |= iwm_send_lmac_ptrough_cmd(iwm,\r\nREPLY_PHY_CALIBRATION_CMD,\r\niwm->calib_res[i].buf,\r\niwm->calib_res[i].size, 0);\r\nkfree(iwm->calib_res[i].buf);\r\niwm->calib_res[i].buf = NULL;\r\niwm->calib_res[i].size = 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint iwm_send_ct_kill_cfg(struct iwm_priv *iwm, u8 entry, u8 exit)\r\n{\r\nstruct iwm_ct_kill_cfg_cmd cmd;\r\ncmd.entry_threshold = entry;\r\ncmd.exit_threshold = exit;\r\nreturn iwm_send_lmac_ptrough_cmd(iwm, REPLY_CT_KILL_CONFIG_CMD, &cmd,\r\nsizeof(struct iwm_ct_kill_cfg_cmd), 0);\r\n}\r\nint iwm_send_umac_reset(struct iwm_priv *iwm, __le32 reset_flags, bool resp)\r\n{\r\nstruct iwm_udma_wifi_cmd udma_cmd = UDMA_UMAC_INIT;\r\nstruct iwm_umac_cmd umac_cmd;\r\nstruct iwm_umac_cmd_reset reset;\r\nreset.flags = reset_flags;\r\numac_cmd.id = UMAC_CMD_OPCODE_RESET;\r\numac_cmd.resp = resp;\r\nreturn iwm_hal_send_umac_cmd(iwm, &udma_cmd, &umac_cmd, &reset,\r\nsizeof(struct iwm_umac_cmd_reset));\r\n}\r\nint iwm_umac_set_config_fix(struct iwm_priv *iwm, u16 tbl, u16 key, u32 value)\r\n{\r\nstruct iwm_udma_wifi_cmd udma_cmd = UDMA_UMAC_INIT;\r\nstruct iwm_umac_cmd umac_cmd;\r\nstruct iwm_umac_cmd_set_param_fix param;\r\nif ((tbl != UMAC_PARAM_TBL_CFG_FIX) &&\r\n(tbl != UMAC_PARAM_TBL_FA_CFG_FIX))\r\nreturn -EINVAL;\r\numac_cmd.id = UMAC_CMD_OPCODE_SET_PARAM_FIX;\r\numac_cmd.resp = 0;\r\nparam.tbl = cpu_to_le16(tbl);\r\nparam.key = cpu_to_le16(key);\r\nparam.value = cpu_to_le32(value);\r\nreturn iwm_hal_send_umac_cmd(iwm, &udma_cmd, &umac_cmd, &param,\r\nsizeof(struct iwm_umac_cmd_set_param_fix));\r\n}\r\nint iwm_umac_set_config_var(struct iwm_priv *iwm, u16 key,\r\nvoid *payload, u16 payload_size)\r\n{\r\nstruct iwm_udma_wifi_cmd udma_cmd = UDMA_UMAC_INIT;\r\nstruct iwm_umac_cmd umac_cmd;\r\nstruct iwm_umac_cmd_set_param_var *param_hdr;\r\nu8 *param;\r\nint ret;\r\nparam = kzalloc(payload_size +\r\nsizeof(struct iwm_umac_cmd_set_param_var), GFP_KERNEL);\r\nif (!param) {\r\nIWM_ERR(iwm, "Couldn't allocate param\n");\r\nreturn -ENOMEM;\r\n}\r\nparam_hdr = (struct iwm_umac_cmd_set_param_var *)param;\r\numac_cmd.id = UMAC_CMD_OPCODE_SET_PARAM_VAR;\r\numac_cmd.resp = 0;\r\nparam_hdr->tbl = cpu_to_le16(UMAC_PARAM_TBL_CFG_VAR);\r\nparam_hdr->key = cpu_to_le16(key);\r\nparam_hdr->len = cpu_to_le16(payload_size);\r\nmemcpy(param + sizeof(struct iwm_umac_cmd_set_param_var),\r\npayload, payload_size);\r\nret = iwm_hal_send_umac_cmd(iwm, &udma_cmd, &umac_cmd, param,\r\nsizeof(struct iwm_umac_cmd_set_param_var) +\r\npayload_size);\r\nkfree(param);\r\nreturn ret;\r\n}\r\nint iwm_send_umac_config(struct iwm_priv *iwm, __le32 reset_flags)\r\n{\r\nint ret;\r\nret = iwm_umac_set_config_fix(iwm, UMAC_PARAM_TBL_CFG_FIX,\r\nCFG_POWER_INDEX, iwm->conf.power_index);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iwm_umac_set_config_fix(iwm, UMAC_PARAM_TBL_FA_CFG_FIX,\r\nCFG_FRAG_THRESHOLD,\r\niwm->conf.frag_threshold);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iwm_umac_set_config_fix(iwm, UMAC_PARAM_TBL_CFG_FIX,\r\nCFG_RTS_THRESHOLD,\r\niwm->conf.rts_threshold);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iwm_umac_set_config_fix(iwm, UMAC_PARAM_TBL_CFG_FIX,\r\nCFG_CTS_TO_SELF, iwm->conf.cts_to_self);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iwm_umac_set_config_fix(iwm, UMAC_PARAM_TBL_CFG_FIX,\r\nCFG_WIRELESS_MODE,\r\niwm->conf.wireless_mode);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iwm_umac_set_config_fix(iwm, UMAC_PARAM_TBL_CFG_FIX,\r\nCFG_COEX_MODE, modparam_wiwi);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iwm_umac_set_config_var(iwm, CFG_NET_ADDR,\r\niwm_to_ndev(iwm)->dev_addr, ETH_ALEN);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iwm_umac_set_config_fix(iwm, UMAC_PARAM_TBL_CFG_FIX,\r\nCFG_PM_LEGACY_RX_TIMEOUT, 0x12C);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iwm_umac_set_config_fix(iwm, UMAC_PARAM_TBL_CFG_FIX,\r\nCFG_PM_LEGACY_TX_TIMEOUT, 0x15E);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iwm_umac_set_config_fix(iwm, UMAC_PARAM_TBL_CFG_FIX,\r\nCFG_PM_CTRL_FLAGS, 0x1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iwm_umac_set_config_fix(iwm, UMAC_PARAM_TBL_CFG_FIX,\r\nCFG_PM_KEEP_ALIVE_IN_BEACONS, 0x80);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iwm_send_umac_reset(iwm, reset_flags, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iwm_notif_handle(iwm, UMAC_CMD_OPCODE_RESET, IWM_SRC_UMAC,\r\nWAIT_NOTIF_TIMEOUT);\r\nif (ret) {\r\nIWM_ERR(iwm, "Wait for UMAC RESET timeout\n");\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nint iwm_send_packet(struct iwm_priv *iwm, struct sk_buff *skb, int pool_id)\r\n{\r\nstruct iwm_udma_wifi_cmd udma_cmd;\r\nstruct iwm_umac_cmd umac_cmd;\r\nstruct iwm_tx_info *tx_info = skb_to_tx_info(skb);\r\nudma_cmd.eop = 1;\r\nudma_cmd.credit_group = pool_id;\r\nudma_cmd.ra_tid = tx_info->sta << 4 | tx_info->tid;\r\nudma_cmd.lmac_offset = 0;\r\numac_cmd.id = REPLY_TX;\r\numac_cmd.color = tx_info->color;\r\numac_cmd.resp = 0;\r\nreturn iwm_hal_send_umac_cmd(iwm, &udma_cmd, &umac_cmd,\r\nskb->data, skb->len);\r\n}\r\nstatic int iwm_target_read(struct iwm_priv *iwm, __le32 address,\r\nu8 *response, u32 resp_size)\r\n{\r\nstruct iwm_udma_nonwifi_cmd target_cmd;\r\nstruct iwm_nonwifi_cmd *cmd;\r\nu16 seq_num;\r\nint ret = 0;\r\ntarget_cmd.opcode = UMAC_HDI_OUT_OPCODE_READ;\r\ntarget_cmd.addr = address;\r\ntarget_cmd.op1_sz = cpu_to_le32(resp_size);\r\ntarget_cmd.op2 = 0;\r\ntarget_cmd.handle_by_hw = 0;\r\ntarget_cmd.resp = 1;\r\ntarget_cmd.eop = 1;\r\nret = iwm_hal_send_target_cmd(iwm, &target_cmd, NULL);\r\nif (ret < 0) {\r\nIWM_ERR(iwm, "Couldn't send READ command\n");\r\nreturn ret;\r\n}\r\nseq_num = ret;\r\nret = wait_event_interruptible_timeout(iwm->nonwifi_queue,\r\n(cmd = iwm_get_pending_nonwifi_cmd(iwm, seq_num,\r\nUMAC_HDI_OUT_OPCODE_READ)) != NULL,\r\n2 * HZ);\r\nif (!ret) {\r\nIWM_ERR(iwm, "Didn't receive a target READ answer\n");\r\nreturn ret;\r\n}\r\nmemcpy(response, cmd->buf.hdr + sizeof(struct iwm_udma_in_hdr),\r\nresp_size);\r\nkfree(cmd);\r\nreturn 0;\r\n}\r\nint iwm_read_mac(struct iwm_priv *iwm, u8 *mac)\r\n{\r\nint ret;\r\nu8 mac_align[ALIGN(ETH_ALEN, 8)];\r\nret = iwm_target_read(iwm, cpu_to_le32(WICO_MAC_ADDRESS_ADDR),\r\nmac_align, sizeof(mac_align));\r\nif (ret)\r\nreturn ret;\r\nif (is_valid_ether_addr(mac_align))\r\nmemcpy(mac, mac_align, ETH_ALEN);\r\nelse {\r\nIWM_ERR(iwm, "Invalid EEPROM MAC\n");\r\nmemcpy(mac, iwm->conf.mac_addr, ETH_ALEN);\r\nget_random_bytes(&mac[3], 3);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iwm_check_profile(struct iwm_priv *iwm)\r\n{\r\nif (!iwm->umac_profile_active)\r\nreturn -EAGAIN;\r\nif (iwm->umac_profile->sec.ucast_cipher != UMAC_CIPHER_TYPE_WEP_40 &&\r\niwm->umac_profile->sec.ucast_cipher != UMAC_CIPHER_TYPE_WEP_104 &&\r\niwm->umac_profile->sec.ucast_cipher != UMAC_CIPHER_TYPE_TKIP &&\r\niwm->umac_profile->sec.ucast_cipher != UMAC_CIPHER_TYPE_CCMP) {\r\nIWM_ERR(iwm, "Wrong unicast cipher: 0x%x\n",\r\niwm->umac_profile->sec.ucast_cipher);\r\nreturn -EAGAIN;\r\n}\r\nif (iwm->umac_profile->sec.mcast_cipher != UMAC_CIPHER_TYPE_WEP_40 &&\r\niwm->umac_profile->sec.mcast_cipher != UMAC_CIPHER_TYPE_WEP_104 &&\r\niwm->umac_profile->sec.mcast_cipher != UMAC_CIPHER_TYPE_TKIP &&\r\niwm->umac_profile->sec.mcast_cipher != UMAC_CIPHER_TYPE_CCMP) {\r\nIWM_ERR(iwm, "Wrong multicast cipher: 0x%x\n",\r\niwm->umac_profile->sec.mcast_cipher);\r\nreturn -EAGAIN;\r\n}\r\nif ((iwm->umac_profile->sec.ucast_cipher == UMAC_CIPHER_TYPE_WEP_40 ||\r\niwm->umac_profile->sec.ucast_cipher == UMAC_CIPHER_TYPE_WEP_104) &&\r\n(iwm->umac_profile->sec.ucast_cipher !=\r\niwm->umac_profile->sec.mcast_cipher)) {\r\nIWM_ERR(iwm, "Unicast and multicast ciphers differ for WEP\n");\r\n}\r\nreturn 0;\r\n}\r\nint iwm_set_tx_key(struct iwm_priv *iwm, u8 key_idx)\r\n{\r\nstruct iwm_umac_tx_key_id tx_key_id;\r\nint ret;\r\nret = iwm_check_profile(iwm);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((iwm->umac_profile->sec.ucast_cipher != UMAC_CIPHER_TYPE_WEP_40 &&\r\niwm->umac_profile->sec.ucast_cipher != UMAC_CIPHER_TYPE_WEP_104) ||\r\niwm->umac_profile->sec.auth_type == UMAC_AUTH_TYPE_8021X ||\r\niwm->umac_profile->sec.auth_type == UMAC_AUTH_TYPE_RSNA_PSK)\r\nreturn 0;\r\ntx_key_id.hdr.oid = UMAC_WIFI_IF_CMD_GLOBAL_TX_KEY_ID;\r\ntx_key_id.hdr.buf_size = cpu_to_le16(sizeof(struct iwm_umac_tx_key_id) -\r\nsizeof(struct iwm_umac_wifi_if));\r\ntx_key_id.key_idx = key_idx;\r\nreturn iwm_send_wifi_if_cmd(iwm, &tx_key_id, sizeof(tx_key_id), 1);\r\n}\r\nint iwm_set_key(struct iwm_priv *iwm, bool remove, struct iwm_key *key)\r\n{\r\nint ret = 0;\r\nu8 cmd[64], *sta_addr, *key_data, key_len;\r\ns8 key_idx;\r\nu16 cmd_size = 0;\r\nstruct iwm_umac_key_hdr *key_hdr = &key->hdr;\r\nstruct iwm_umac_key_wep40 *wep40 = (struct iwm_umac_key_wep40 *)cmd;\r\nstruct iwm_umac_key_wep104 *wep104 = (struct iwm_umac_key_wep104 *)cmd;\r\nstruct iwm_umac_key_tkip *tkip = (struct iwm_umac_key_tkip *)cmd;\r\nstruct iwm_umac_key_ccmp *ccmp = (struct iwm_umac_key_ccmp *)cmd;\r\nif (!remove) {\r\nret = iwm_check_profile(iwm);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nsta_addr = key->hdr.mac;\r\nkey_data = key->key;\r\nkey_len = key->key_len;\r\nkey_idx = key->hdr.key_idx;\r\nif (!remove) {\r\nu8 auth_type = iwm->umac_profile->sec.auth_type;\r\nIWM_DBG_WEXT(iwm, DBG, "key_idx:%d\n", key_idx);\r\nIWM_DBG_WEXT(iwm, DBG, "key_len:%d\n", key_len);\r\nIWM_DBG_WEXT(iwm, DBG, "MAC:%pM, idx:%d, multicast:%d\n",\r\nkey_hdr->mac, key_hdr->key_idx, key_hdr->multicast);\r\nIWM_DBG_WEXT(iwm, DBG, "profile: mcast:0x%x, ucast:0x%x\n",\r\niwm->umac_profile->sec.mcast_cipher,\r\niwm->umac_profile->sec.ucast_cipher);\r\nIWM_DBG_WEXT(iwm, DBG, "profile: auth_type:0x%x, flags:0x%x\n",\r\niwm->umac_profile->sec.auth_type,\r\niwm->umac_profile->sec.flags);\r\nswitch (key->cipher) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\nwep40->hdr.oid = UMAC_WIFI_IF_CMD_ADD_WEP40_KEY;\r\nwep40->hdr.buf_size =\r\ncpu_to_le16(sizeof(struct iwm_umac_key_wep40) -\r\nsizeof(struct iwm_umac_wifi_if));\r\nmemcpy(&wep40->key_hdr, key_hdr,\r\nsizeof(struct iwm_umac_key_hdr));\r\nmemcpy(wep40->key, key_data, key_len);\r\nwep40->static_key =\r\n!!((auth_type != UMAC_AUTH_TYPE_8021X) &&\r\n(auth_type != UMAC_AUTH_TYPE_RSNA_PSK));\r\ncmd_size = sizeof(struct iwm_umac_key_wep40);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nwep104->hdr.oid = UMAC_WIFI_IF_CMD_ADD_WEP104_KEY;\r\nwep104->hdr.buf_size =\r\ncpu_to_le16(sizeof(struct iwm_umac_key_wep104) -\r\nsizeof(struct iwm_umac_wifi_if));\r\nmemcpy(&wep104->key_hdr, key_hdr,\r\nsizeof(struct iwm_umac_key_hdr));\r\nmemcpy(wep104->key, key_data, key_len);\r\nwep104->static_key =\r\n!!((auth_type != UMAC_AUTH_TYPE_8021X) &&\r\n(auth_type != UMAC_AUTH_TYPE_RSNA_PSK));\r\ncmd_size = sizeof(struct iwm_umac_key_wep104);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nkey_hdr->key_idx++;\r\nccmp->hdr.oid = UMAC_WIFI_IF_CMD_ADD_CCMP_KEY;\r\nccmp->hdr.buf_size =\r\ncpu_to_le16(sizeof(struct iwm_umac_key_ccmp) -\r\nsizeof(struct iwm_umac_wifi_if));\r\nmemcpy(&ccmp->key_hdr, key_hdr,\r\nsizeof(struct iwm_umac_key_hdr));\r\nmemcpy(ccmp->key, key_data, key_len);\r\nif (key->seq_len)\r\nmemcpy(ccmp->iv_count, key->seq, key->seq_len);\r\ncmd_size = sizeof(struct iwm_umac_key_ccmp);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nkey_hdr->key_idx++;\r\ntkip->hdr.oid = UMAC_WIFI_IF_CMD_ADD_TKIP_KEY;\r\ntkip->hdr.buf_size =\r\ncpu_to_le16(sizeof(struct iwm_umac_key_tkip) -\r\nsizeof(struct iwm_umac_wifi_if));\r\nmemcpy(&tkip->key_hdr, key_hdr,\r\nsizeof(struct iwm_umac_key_hdr));\r\nmemcpy(tkip->tkip_key, key_data, IWM_TKIP_KEY_SIZE);\r\nmemcpy(tkip->mic_tx_key, key_data + IWM_TKIP_KEY_SIZE,\r\nIWM_TKIP_MIC_SIZE);\r\nmemcpy(tkip->mic_rx_key,\r\nkey_data + IWM_TKIP_KEY_SIZE + IWM_TKIP_MIC_SIZE,\r\nIWM_TKIP_MIC_SIZE);\r\nif (key->seq_len)\r\nmemcpy(ccmp->iv_count, key->seq, key->seq_len);\r\ncmd_size = sizeof(struct iwm_umac_key_tkip);\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\nif ((key->cipher == WLAN_CIPHER_SUITE_TKIP) ||\r\n(key->cipher == WLAN_CIPHER_SUITE_CCMP))\r\nschedule_timeout_interruptible(usecs_to_jiffies(300));\r\nret = iwm_send_wifi_if_cmd(iwm, cmd, cmd_size, 1);\r\n} else {\r\nstruct iwm_umac_key_remove key_remove;\r\nIWM_DBG_WEXT(iwm, ERR, "Removing key_idx:%d\n", key_idx);\r\nkey_remove.hdr.oid = UMAC_WIFI_IF_CMD_REMOVE_KEY;\r\nkey_remove.hdr.buf_size =\r\ncpu_to_le16(sizeof(struct iwm_umac_key_remove) -\r\nsizeof(struct iwm_umac_wifi_if));\r\nmemcpy(&key_remove.key_hdr, key_hdr,\r\nsizeof(struct iwm_umac_key_hdr));\r\nret = iwm_send_wifi_if_cmd(iwm, &key_remove,\r\nsizeof(struct iwm_umac_key_remove),\r\n1);\r\nif (ret)\r\nreturn ret;\r\niwm->keys[key_idx].key_len = 0;\r\n}\r\nreturn ret;\r\n}\r\nint iwm_send_mlme_profile(struct iwm_priv *iwm)\r\n{\r\nint ret;\r\nstruct iwm_umac_profile profile;\r\nmemcpy(&profile, iwm->umac_profile, sizeof(profile));\r\nprofile.hdr.oid = UMAC_WIFI_IF_CMD_SET_PROFILE;\r\nprofile.hdr.buf_size = cpu_to_le16(sizeof(struct iwm_umac_profile) -\r\nsizeof(struct iwm_umac_wifi_if));\r\nret = iwm_send_wifi_if_cmd(iwm, &profile, sizeof(profile), 1);\r\nif (ret) {\r\nIWM_ERR(iwm, "Send profile command failed\n");\r\nreturn ret;\r\n}\r\nset_bit(IWM_STATUS_SME_CONNECTING, &iwm->status);\r\nreturn 0;\r\n}\r\nint __iwm_invalidate_mlme_profile(struct iwm_priv *iwm)\r\n{\r\nstruct iwm_umac_invalidate_profile invalid;\r\ninvalid.hdr.oid = UMAC_WIFI_IF_CMD_INVALIDATE_PROFILE;\r\ninvalid.hdr.buf_size =\r\ncpu_to_le16(sizeof(struct iwm_umac_invalidate_profile) -\r\nsizeof(struct iwm_umac_wifi_if));\r\ninvalid.reason = WLAN_REASON_UNSPECIFIED;\r\nreturn iwm_send_wifi_if_cmd(iwm, &invalid, sizeof(invalid), 1);\r\n}\r\nint iwm_invalidate_mlme_profile(struct iwm_priv *iwm)\r\n{\r\nint ret;\r\nret = __iwm_invalidate_mlme_profile(iwm);\r\nif (ret)\r\nreturn ret;\r\nret = wait_event_interruptible_timeout(iwm->mlme_queue,\r\n(iwm->umac_profile_active == 0), 5 * HZ);\r\nreturn ret ? 0 : -EBUSY;\r\n}\r\nint iwm_tx_power_trigger(struct iwm_priv *iwm)\r\n{\r\nstruct iwm_umac_pwr_trigger pwr_trigger;\r\npwr_trigger.hdr.oid = UMAC_WIFI_IF_CMD_TX_PWR_TRIGGER;\r\npwr_trigger.hdr.buf_size =\r\ncpu_to_le16(sizeof(struct iwm_umac_pwr_trigger) -\r\nsizeof(struct iwm_umac_wifi_if));\r\nreturn iwm_send_wifi_if_cmd(iwm, &pwr_trigger, sizeof(pwr_trigger), 1);\r\n}\r\nint iwm_send_umac_stats_req(struct iwm_priv *iwm, u32 flags)\r\n{\r\nstruct iwm_udma_wifi_cmd udma_cmd = UDMA_UMAC_INIT;\r\nstruct iwm_umac_cmd umac_cmd;\r\nstruct iwm_umac_cmd_stats_req stats_req;\r\nstats_req.flags = cpu_to_le32(flags);\r\numac_cmd.id = UMAC_CMD_OPCODE_STATISTIC_REQUEST;\r\numac_cmd.resp = 0;\r\nreturn iwm_hal_send_umac_cmd(iwm, &udma_cmd, &umac_cmd, &stats_req,\r\nsizeof(struct iwm_umac_cmd_stats_req));\r\n}\r\nint iwm_send_umac_channel_list(struct iwm_priv *iwm)\r\n{\r\nstruct iwm_udma_wifi_cmd udma_cmd = UDMA_UMAC_INIT;\r\nstruct iwm_umac_cmd umac_cmd;\r\nstruct iwm_umac_cmd_get_channel_list *ch_list;\r\nint size = sizeof(struct iwm_umac_cmd_get_channel_list) +\r\nsizeof(struct iwm_umac_channel_info) * 4;\r\nint ret;\r\nch_list = kzalloc(size, GFP_KERNEL);\r\nif (!ch_list) {\r\nIWM_ERR(iwm, "Couldn't allocate channel list cmd\n");\r\nreturn -ENOMEM;\r\n}\r\nch_list->ch[0].band = UMAC_BAND_2GHZ;\r\nch_list->ch[0].type = UMAC_CHANNEL_WIDTH_20MHZ;\r\nch_list->ch[0].flags = UMAC_CHANNEL_FLAG_VALID;\r\nch_list->ch[1].band = UMAC_BAND_5GHZ;\r\nch_list->ch[1].type = UMAC_CHANNEL_WIDTH_20MHZ;\r\nch_list->ch[1].flags = UMAC_CHANNEL_FLAG_VALID;\r\nch_list->ch[2].band = UMAC_BAND_2GHZ;\r\nch_list->ch[2].type = UMAC_CHANNEL_WIDTH_20MHZ;\r\nch_list->ch[2].flags = UMAC_CHANNEL_FLAG_VALID | UMAC_CHANNEL_FLAG_IBSS;\r\nch_list->ch[3].band = UMAC_BAND_5GHZ;\r\nch_list->ch[3].type = UMAC_CHANNEL_WIDTH_20MHZ;\r\nch_list->ch[3].flags = UMAC_CHANNEL_FLAG_VALID | UMAC_CHANNEL_FLAG_IBSS;\r\nch_list->count = cpu_to_le16(4);\r\numac_cmd.id = UMAC_CMD_OPCODE_GET_CHAN_INFO_LIST;\r\numac_cmd.resp = 1;\r\nret = iwm_hal_send_umac_cmd(iwm, &udma_cmd, &umac_cmd, ch_list, size);\r\nkfree(ch_list);\r\nreturn ret;\r\n}\r\nint iwm_scan_ssids(struct iwm_priv *iwm, struct cfg80211_ssid *ssids,\r\nint ssid_num)\r\n{\r\nstruct iwm_umac_cmd_scan_request req;\r\nint i, ret;\r\nmemset(&req, 0, sizeof(struct iwm_umac_cmd_scan_request));\r\nreq.hdr.oid = UMAC_WIFI_IF_CMD_SCAN_REQUEST;\r\nreq.hdr.buf_size = cpu_to_le16(sizeof(struct iwm_umac_cmd_scan_request)\r\n- sizeof(struct iwm_umac_wifi_if));\r\nreq.type = UMAC_WIFI_IF_SCAN_TYPE_USER;\r\nreq.timeout = 2;\r\nreq.seq_num = iwm->scan_id;\r\nreq.ssid_num = min(ssid_num, UMAC_WIFI_IF_PROBE_OPTION_MAX);\r\nfor (i = 0; i < req.ssid_num; i++) {\r\nmemcpy(req.ssids[i].ssid, ssids[i].ssid, ssids[i].ssid_len);\r\nreq.ssids[i].ssid_len = ssids[i].ssid_len;\r\n}\r\nret = iwm_send_wifi_if_cmd(iwm, &req, sizeof(req), 0);\r\nif (ret) {\r\nIWM_ERR(iwm, "Couldn't send scan request\n");\r\nreturn ret;\r\n}\r\niwm->scan_id = (iwm->scan_id + 1) % IWM_SCAN_ID_MAX;\r\nreturn 0;\r\n}\r\nint iwm_scan_one_ssid(struct iwm_priv *iwm, u8 *ssid, int ssid_len)\r\n{\r\nstruct cfg80211_ssid one_ssid;\r\nif (test_and_set_bit(IWM_STATUS_SCANNING, &iwm->status))\r\nreturn 0;\r\none_ssid.ssid_len = min(ssid_len, IEEE80211_MAX_SSID_LEN);\r\nmemcpy(&one_ssid.ssid, ssid, one_ssid.ssid_len);\r\nreturn iwm_scan_ssids(iwm, &one_ssid, 1);\r\n}\r\nint iwm_target_reset(struct iwm_priv *iwm)\r\n{\r\nstruct iwm_udma_nonwifi_cmd target_cmd;\r\ntarget_cmd.opcode = UMAC_HDI_OUT_OPCODE_REBOOT;\r\ntarget_cmd.addr = 0;\r\ntarget_cmd.op1_sz = 0;\r\ntarget_cmd.op2 = 0;\r\ntarget_cmd.handle_by_hw = 0;\r\ntarget_cmd.resp = 0;\r\ntarget_cmd.eop = 1;\r\nreturn iwm_hal_send_target_cmd(iwm, &target_cmd, NULL);\r\n}\r\nint iwm_send_umac_stop_resume_tx(struct iwm_priv *iwm,\r\nstruct iwm_umac_notif_stop_resume_tx *ntf)\r\n{\r\nstruct iwm_udma_wifi_cmd udma_cmd = UDMA_UMAC_INIT;\r\nstruct iwm_umac_cmd umac_cmd;\r\nstruct iwm_umac_cmd_stop_resume_tx stp_res_cmd;\r\nstruct iwm_sta_info *sta_info;\r\nu8 sta_id = STA_ID_N_COLOR_ID(ntf->sta_id);\r\nint i;\r\nsta_info = &iwm->sta_table[sta_id];\r\nif (!sta_info->valid) {\r\nIWM_ERR(iwm, "Invalid STA: %d\n", sta_id);\r\nreturn -EINVAL;\r\n}\r\numac_cmd.id = UMAC_CMD_OPCODE_STOP_RESUME_STA_TX;\r\numac_cmd.resp = 0;\r\nstp_res_cmd.flags = ntf->flags;\r\nstp_res_cmd.sta_id = ntf->sta_id;\r\nstp_res_cmd.stop_resume_tid_msk = ntf->stop_resume_tid_msk;\r\nfor (i = 0; i < IWM_UMAC_TID_NR; i++)\r\nstp_res_cmd.last_seq_num[i] =\r\nsta_info->tid_info[i].last_seq_num;\r\nreturn iwm_hal_send_umac_cmd(iwm, &udma_cmd, &umac_cmd, &stp_res_cmd,\r\nsizeof(struct iwm_umac_cmd_stop_resume_tx));\r\n}\r\nint iwm_send_pmkid_update(struct iwm_priv *iwm,\r\nstruct cfg80211_pmksa *pmksa, u32 command)\r\n{\r\nstruct iwm_umac_pmkid_update update;\r\nint ret;\r\nmemset(&update, 0, sizeof(struct iwm_umac_pmkid_update));\r\nupdate.hdr.oid = UMAC_WIFI_IF_CMD_PMKID_UPDATE;\r\nupdate.hdr.buf_size = cpu_to_le16(sizeof(struct iwm_umac_pmkid_update) -\r\nsizeof(struct iwm_umac_wifi_if));\r\nupdate.command = cpu_to_le32(command);\r\nif (pmksa->bssid)\r\nmemcpy(&update.bssid, pmksa->bssid, ETH_ALEN);\r\nif (pmksa->pmkid)\r\nmemcpy(&update.pmkid, pmksa->pmkid, WLAN_PMKID_LEN);\r\nret = iwm_send_wifi_if_cmd(iwm, &update,\r\nsizeof(struct iwm_umac_pmkid_update), 0);\r\nif (ret) {\r\nIWM_ERR(iwm, "PMKID update command failed\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
