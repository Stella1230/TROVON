static int comedi_load_firmware(struct comedi_device *dev, char *name,\r\nint (*cb)(struct comedi_device *dev,\r\nconst u8 *data, size_t size))\r\n{\r\nint result = 0;\r\nconst struct firmware *fw;\r\nchar *firmware_path;\r\nstatic const char *prefix = "comedi/";\r\nstruct jr3_pci_dev_private *devpriv = dev->private;\r\nfirmware_path = kmalloc(strlen(prefix) + strlen(name) + 1, GFP_KERNEL);\r\nif (!firmware_path) {\r\nresult = -ENOMEM;\r\n} else {\r\nfirmware_path[0] = '\0';\r\nstrcat(firmware_path, prefix);\r\nstrcat(firmware_path, name);\r\nresult = request_firmware(&fw, firmware_path,\r\n&devpriv->pci_dev->dev);\r\nif (result == 0) {\r\nif (!cb)\r\nresult = -EINVAL;\r\nelse\r\nresult = cb(dev, fw->data, fw->size);\r\nrelease_firmware(fw);\r\n}\r\nkfree(firmware_path);\r\n}\r\nreturn result;\r\n}\r\nstatic struct poll_delay_t poll_delay_min_max(int min, int max)\r\n{\r\nstruct poll_delay_t result;\r\nresult.min = min;\r\nresult.max = max;\r\nreturn result;\r\n}\r\nstatic int is_complete(volatile struct jr3_channel *channel)\r\n{\r\nreturn get_s16(&channel->command_word0) == 0;\r\n}\r\nstatic void set_transforms(volatile struct jr3_channel *channel,\r\nstruct transform_t transf, short num)\r\n{\r\nint i;\r\nnum &= 0x000f;\r\nfor (i = 0; i < 8; i++) {\r\nset_u16(&channel->transforms[num].link[i].link_type,\r\ntransf.link[i].link_type);\r\nudelay(1);\r\nset_s16(&channel->transforms[num].link[i].link_amount,\r\ntransf.link[i].link_amount);\r\nudelay(1);\r\nif (transf.link[i].link_type == end_x_form)\r\nbreak;\r\n}\r\n}\r\nstatic void use_transform(volatile struct jr3_channel *channel,\r\nshort transf_num)\r\n{\r\nset_s16(&channel->command_word0, 0x0500 + (transf_num & 0x000f));\r\n}\r\nstatic void use_offset(volatile struct jr3_channel *channel, short offset_num)\r\n{\r\nset_s16(&channel->command_word0, 0x0600 + (offset_num & 0x000f));\r\n}\r\nstatic void set_offset(volatile struct jr3_channel *channel)\r\n{\r\nset_s16(&channel->command_word0, 0x0700);\r\n}\r\nstatic void set_full_scales(volatile struct jr3_channel *channel,\r\nstruct six_axis_t full_scale)\r\n{\r\nprintk("%d %d %d %d %d %d\n",\r\nfull_scale.fx,\r\nfull_scale.fy,\r\nfull_scale.fz, full_scale.mx, full_scale.my, full_scale.mz);\r\nset_s16(&channel->full_scale.fx, full_scale.fx);\r\nset_s16(&channel->full_scale.fy, full_scale.fy);\r\nset_s16(&channel->full_scale.fz, full_scale.fz);\r\nset_s16(&channel->full_scale.mx, full_scale.mx);\r\nset_s16(&channel->full_scale.my, full_scale.my);\r\nset_s16(&channel->full_scale.mz, full_scale.mz);\r\nset_s16(&channel->command_word0, 0x0a00);\r\n}\r\nstatic struct six_axis_t get_min_full_scales(volatile struct jr3_channel\r\n*channel)\r\n{\r\nstruct six_axis_t result;\r\nresult.fx = get_s16(&channel->min_full_scale.fx);\r\nresult.fy = get_s16(&channel->min_full_scale.fy);\r\nresult.fz = get_s16(&channel->min_full_scale.fz);\r\nresult.mx = get_s16(&channel->min_full_scale.mx);\r\nresult.my = get_s16(&channel->min_full_scale.my);\r\nresult.mz = get_s16(&channel->min_full_scale.mz);\r\nreturn result;\r\n}\r\nstatic struct six_axis_t get_max_full_scales(volatile struct jr3_channel\r\n*channel)\r\n{\r\nstruct six_axis_t result;\r\nresult.fx = get_s16(&channel->max_full_scale.fx);\r\nresult.fy = get_s16(&channel->max_full_scale.fy);\r\nresult.fz = get_s16(&channel->max_full_scale.fz);\r\nresult.mx = get_s16(&channel->max_full_scale.mx);\r\nresult.my = get_s16(&channel->max_full_scale.my);\r\nresult.mz = get_s16(&channel->max_full_scale.mz);\r\nreturn result;\r\n}\r\nstatic int jr3_pci_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint result;\r\nstruct jr3_pci_subdev_private *p;\r\nint channel;\r\np = s->private;\r\nchannel = CR_CHAN(insn->chanspec);\r\nif (p == NULL || channel > 57) {\r\nresult = -EINVAL;\r\n} else {\r\nint i;\r\nresult = insn->n;\r\nif (p->state != state_jr3_done ||\r\n(get_u16(&p->channel->errors) & (watch_dog | watch_dog2 |\r\nsensor_change))) {\r\nif (p->state == state_jr3_done) {\r\np->state = state_jr3_poll;\r\n}\r\nresult = -EAGAIN;\r\n}\r\nfor (i = 0; i < insn->n; i++) {\r\nif (channel < 56) {\r\nint axis, filter;\r\naxis = channel % 8;\r\nfilter = channel / 8;\r\nif (p->state != state_jr3_done) {\r\ndata[i] = 0;\r\n} else {\r\nint F = 0;\r\nswitch (axis) {\r\ncase 0:{\r\nF = get_s16\r\n(&p->channel->filter\r\n[filter].fx);\r\n}\r\nbreak;\r\ncase 1:{\r\nF = get_s16\r\n(&p->channel->filter\r\n[filter].fy);\r\n}\r\nbreak;\r\ncase 2:{\r\nF = get_s16\r\n(&p->channel->filter\r\n[filter].fz);\r\n}\r\nbreak;\r\ncase 3:{\r\nF = get_s16\r\n(&p->channel->filter\r\n[filter].mx);\r\n}\r\nbreak;\r\ncase 4:{\r\nF = get_s16\r\n(&p->channel->filter\r\n[filter].my);\r\n}\r\nbreak;\r\ncase 5:{\r\nF = get_s16\r\n(&p->channel->filter\r\n[filter].mz);\r\n}\r\nbreak;\r\ncase 6:{\r\nF = get_s16\r\n(&p->channel->filter\r\n[filter].v1);\r\n}\r\nbreak;\r\ncase 7:{\r\nF = get_s16\r\n(&p->channel->filter\r\n[filter].v2);\r\n}\r\nbreak;\r\n}\r\ndata[i] = F + 0x4000;\r\n}\r\n} else if (channel == 56) {\r\nif (p->state != state_jr3_done) {\r\ndata[i] = 0;\r\n} else {\r\ndata[i] =\r\nget_u16(&p->channel->model_no);\r\n}\r\n} else if (channel == 57) {\r\nif (p->state != state_jr3_done) {\r\ndata[i] = 0;\r\n} else {\r\ndata[i] =\r\nget_u16(&p->channel->serial_no);\r\n}\r\n}\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic int jr3_pci_open(struct comedi_device *dev)\r\n{\r\nint i;\r\nstruct jr3_pci_dev_private *devpriv = dev->private;\r\ndev_dbg(dev->hw_dev, "jr3_pci_open\n");\r\nfor (i = 0; i < devpriv->n_channels; i++) {\r\nstruct jr3_pci_subdev_private *p;\r\np = dev->subdevices[i].private;\r\nif (p) {\r\ndev_dbg(dev->hw_dev, "serial: %p %d (%d)\n", p,\r\np->serial_no, p->channel_no);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint read_idm_word(const u8 * data, size_t size, int *pos, unsigned int *val)\r\n{\r\nint result = 0;\r\nif (pos != 0 && val != 0) {\r\nfor (; *pos < size && !isxdigit(data[*pos]); (*pos)++) {\r\n}\r\n*val = 0;\r\nfor (; *pos < size; (*pos)++) {\r\nint value;\r\nvalue = hex_to_bin(data[*pos]);\r\nif (value >= 0) {\r\nresult = 1;\r\n*val = (*val << 4) + value;\r\n} else\r\nbreak;\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic int jr3_download_firmware(struct comedi_device *dev, const u8 * data,\r\nsize_t size)\r\n{\r\nint result, more, pos, OK;\r\nresult = 0;\r\nmore = 1;\r\npos = 0;\r\nOK = 0;\r\nwhile (more) {\r\nunsigned int count, addr;\r\nmore = more && read_idm_word(data, size, &pos, &count);\r\nif (more && count == 0xffff) {\r\nOK = 1;\r\nbreak;\r\n}\r\nmore = more && read_idm_word(data, size, &pos, &addr);\r\nwhile (more && count > 0) {\r\nunsigned int dummy;\r\nmore = more && read_idm_word(data, size, &pos, &dummy);\r\ncount--;\r\n}\r\n}\r\nif (!OK) {\r\nresult = -ENODATA;\r\n} else {\r\nint i;\r\nstruct jr3_pci_dev_private *p = dev->private;\r\nfor (i = 0; i < p->n_channels; i++) {\r\nstruct jr3_pci_subdev_private *sp;\r\nsp = dev->subdevices[i].private;\r\nmore = 1;\r\npos = 0;\r\nwhile (more) {\r\nunsigned int count, addr;\r\nmore = more\r\n&& read_idm_word(data, size, &pos, &count);\r\nif (more && count == 0xffff)\r\nbreak;\r\nmore = more\r\n&& read_idm_word(data, size, &pos, &addr);\r\ndev_dbg(dev->hw_dev, "Loading#%d %4.4x bytes at %4.4x\n",\r\ni, count, addr);\r\nwhile (more && count > 0) {\r\nif (addr & 0x4000) {\r\nunsigned int data1;\r\nmore = more\r\n&& read_idm_word(data,\r\nsize, &pos,\r\n&data1);\r\ncount--;\r\n} else {\r\nunsigned int data1, data2;\r\nmore = more\r\n&& read_idm_word(data,\r\nsize, &pos,\r\n&data1);\r\nmore = more\r\n&& read_idm_word(data, size,\r\n&pos,\r\n&data2);\r\ncount -= 2;\r\nif (more) {\r\nset_u16(&p->\r\niobase->channel\r\n[i].program_low\r\n[addr], data1);\r\nudelay(1);\r\nset_u16(&p->\r\niobase->channel\r\n[i].program_high\r\n[addr], data2);\r\nudelay(1);\r\n}\r\n}\r\naddr++;\r\n}\r\n}\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic struct poll_delay_t jr3_pci_poll_subdevice(struct comedi_subdevice *s)\r\n{\r\nstruct poll_delay_t result = poll_delay_min_max(1000, 2000);\r\nstruct jr3_pci_subdev_private *p = s->private;\r\nint i;\r\nif (p) {\r\nvolatile struct jr3_channel *channel = p->channel;\r\nint errors = get_u16(&channel->errors);\r\nif (errors != p->errors) {\r\nprintk("Errors: %x -> %x\n", p->errors, errors);\r\np->errors = errors;\r\n}\r\nif (errors & (watch_dog | watch_dog2 | sensor_change)) {\r\np->state = state_jr3_poll;\r\n}\r\nswitch (p->state) {\r\ncase state_jr3_poll:{\r\nu16 model_no = get_u16(&channel->model_no);\r\nu16 serial_no = get_u16(&channel->serial_no);\r\nif ((errors & (watch_dog | watch_dog2)) ||\r\nmodel_no == 0 || serial_no == 0) {\r\nresult = poll_delay_min_max(1000, 2000);\r\n} else {\r\np->retries = 0;\r\np->state =\r\nstate_jr3_init_wait_for_offset;\r\nresult = poll_delay_min_max(1000, 2000);\r\n}\r\n}\r\nbreak;\r\ncase state_jr3_init_wait_for_offset:{\r\np->retries++;\r\nif (p->retries < 10) {\r\nresult = poll_delay_min_max(1000, 2000);\r\n} else {\r\nstruct transform_t transf;\r\np->model_no =\r\nget_u16(&channel->model_no);\r\np->serial_no =\r\nget_u16(&channel->serial_no);\r\nprintk\r\n("Setting transform for channel %d\n",\r\np->channel_no);\r\nprintk("Sensor Model = %i\n",\r\np->model_no);\r\nprintk("Sensor Serial = %i\n",\r\np->serial_no);\r\nfor (i = 0; i < ARRAY_SIZE(transf.link); i++) {\r\ntransf.link[i].link_type =\r\n(enum link_types)0;\r\ntransf.link[i].link_amount = 0;\r\n}\r\nset_transforms(channel, transf, 0);\r\nuse_transform(channel, 0);\r\np->state =\r\nstate_jr3_init_transform_complete;\r\nresult = poll_delay_min_max(20, 100);\r\n}\r\n} break;\r\ncase state_jr3_init_transform_complete:{\r\nif (!is_complete(channel)) {\r\nprintk\r\n("state_jr3_init_transform_complete complete = %d\n",\r\nis_complete(channel));\r\nresult = poll_delay_min_max(20, 100);\r\n} else {\r\nstruct six_axis_t min_full_scale;\r\nstruct six_axis_t max_full_scale;\r\nmin_full_scale =\r\nget_min_full_scales(channel);\r\nprintk("Obtained Min. Full Scales:\n");\r\nprintk(KERN_DEBUG "%i ", (min_full_scale).fx);\r\nprintk(KERN_CONT "%i ", (min_full_scale).fy);\r\nprintk(KERN_CONT "%i ", (min_full_scale).fz);\r\nprintk(KERN_CONT "%i ", (min_full_scale).mx);\r\nprintk(KERN_CONT "%i ", (min_full_scale).my);\r\nprintk(KERN_CONT "%i ", (min_full_scale).mz);\r\nprintk(KERN_CONT "\n");\r\nmax_full_scale =\r\nget_max_full_scales(channel);\r\nprintk("Obtained Max. Full Scales:\n");\r\nprintk(KERN_DEBUG "%i ", (max_full_scale).fx);\r\nprintk(KERN_CONT "%i ", (max_full_scale).fy);\r\nprintk(KERN_CONT "%i ", (max_full_scale).fz);\r\nprintk(KERN_CONT "%i ", (max_full_scale).mx);\r\nprintk(KERN_CONT "%i ", (max_full_scale).my);\r\nprintk(KERN_CONT "%i ", (max_full_scale).mz);\r\nprintk(KERN_CONT "\n");\r\nset_full_scales(channel,\r\nmax_full_scale);\r\np->state =\r\nstate_jr3_init_set_full_scale_complete;\r\nresult = poll_delay_min_max(20, 100);\r\n}\r\n}\r\nbreak;\r\ncase state_jr3_init_set_full_scale_complete:{\r\nif (!is_complete(channel)) {\r\nprintk\r\n("state_jr3_init_set_full_scale_complete complete = %d\n",\r\nis_complete(channel));\r\nresult = poll_delay_min_max(20, 100);\r\n} else {\r\nvolatile struct force_array *full_scale;\r\nfull_scale = &channel->full_scale;\r\np->range[0].range.min =\r\n-get_s16(&full_scale->fx) * 1000;\r\np->range[0].range.max =\r\nget_s16(&full_scale->fx) * 1000;\r\np->range[1].range.min =\r\n-get_s16(&full_scale->fy) * 1000;\r\np->range[1].range.max =\r\nget_s16(&full_scale->fy) * 1000;\r\np->range[2].range.min =\r\n-get_s16(&full_scale->fz) * 1000;\r\np->range[2].range.max =\r\nget_s16(&full_scale->fz) * 1000;\r\np->range[3].range.min =\r\n-get_s16(&full_scale->mx) * 100;\r\np->range[3].range.max =\r\nget_s16(&full_scale->mx) * 100;\r\np->range[4].range.min =\r\n-get_s16(&full_scale->my) * 100;\r\np->range[4].range.max =\r\nget_s16(&full_scale->my) * 100;\r\np->range[5].range.min =\r\n-get_s16(&full_scale->mz) * 100;\r\np->range[5].range.max =\r\nget_s16(&full_scale->mz) * 100;\r\np->range[6].range.min = -get_s16(&full_scale->v1) * 100;\r\np->range[6].range.max = get_s16(&full_scale->v1) * 100;\r\np->range[7].range.min = -get_s16(&full_scale->v2) * 100;\r\np->range[7].range.max = get_s16(&full_scale->v2) * 100;\r\np->range[8].range.min = 0;\r\np->range[8].range.max = 65535;\r\n{\r\nint i;\r\nfor (i = 0; i < 9; i++) {\r\nprintk("%d %d - %d\n",\r\ni,\r\np->\r\nrange[i].range.\r\nmin,\r\np->\r\nrange[i].range.\r\nmax);\r\n}\r\n}\r\nuse_offset(channel, 0);\r\np->state =\r\nstate_jr3_init_use_offset_complete;\r\nresult = poll_delay_min_max(40, 100);\r\n}\r\n}\r\nbreak;\r\ncase state_jr3_init_use_offset_complete:{\r\nif (!is_complete(channel)) {\r\nprintk\r\n("state_jr3_init_use_offset_complete complete = %d\n",\r\nis_complete(channel));\r\nresult = poll_delay_min_max(20, 100);\r\n} else {\r\nprintk\r\n("Default offsets %d %d %d %d %d %d\n",\r\nget_s16(&channel->offsets.fx),\r\nget_s16(&channel->offsets.fy),\r\nget_s16(&channel->offsets.fz),\r\nget_s16(&channel->offsets.mx),\r\nget_s16(&channel->offsets.my),\r\nget_s16(&channel->offsets.mz));\r\nset_s16(&channel->offsets.fx, 0);\r\nset_s16(&channel->offsets.fy, 0);\r\nset_s16(&channel->offsets.fz, 0);\r\nset_s16(&channel->offsets.mx, 0);\r\nset_s16(&channel->offsets.my, 0);\r\nset_s16(&channel->offsets.mz, 0);\r\nset_offset(channel);\r\np->state = state_jr3_done;\r\n}\r\n}\r\nbreak;\r\ncase state_jr3_done:{\r\npoll_delay_min_max(10000, 20000);\r\n}\r\nbreak;\r\ndefault:{\r\npoll_delay_min_max(1000, 2000);\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic void jr3_pci_poll_dev(unsigned long data)\r\n{\r\nunsigned long flags;\r\nstruct comedi_device *dev = (struct comedi_device *)data;\r\nstruct jr3_pci_dev_private *devpriv = dev->private;\r\nunsigned long now;\r\nint delay;\r\nint i;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndelay = 1000;\r\nnow = jiffies;\r\nfor (i = 0; i < devpriv->n_channels; i++) {\r\nstruct jr3_pci_subdev_private *subdevpriv =\r\ndev->subdevices[i].private;\r\nif (now > subdevpriv->next_time_min) {\r\nstruct poll_delay_t sub_delay;\r\nsub_delay = jr3_pci_poll_subdevice(&dev->subdevices[i]);\r\nsubdevpriv->next_time_min =\r\njiffies + msecs_to_jiffies(sub_delay.min);\r\nsubdevpriv->next_time_max =\r\njiffies + msecs_to_jiffies(sub_delay.max);\r\nif (sub_delay.max && sub_delay.max < delay) {\r\ndelay = sub_delay.max;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\ndevpriv->timer.expires = jiffies + msecs_to_jiffies(delay);\r\nadd_timer(&devpriv->timer);\r\n}\r\nstatic int jr3_pci_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nint result = 0;\r\nstruct pci_dev *card = NULL;\r\nint opt_bus, opt_slot, i;\r\nstruct jr3_pci_dev_private *devpriv;\r\nopt_bus = it->options[0];\r\nopt_slot = it->options[1];\r\nif (sizeof(struct jr3_channel) != 0xc00) {\r\ndev_err(dev->hw_dev, "sizeof(struct jr3_channel) = %x [expected %x]\n",\r\n(unsigned)sizeof(struct jr3_channel), 0xc00);\r\nreturn -EINVAL;\r\n}\r\nresult = alloc_private(dev, sizeof(struct jr3_pci_dev_private));\r\nif (result < 0)\r\nreturn -ENOMEM;\r\ncard = NULL;\r\ndevpriv = dev->private;\r\ninit_timer(&devpriv->timer);\r\nwhile (1) {\r\ncard = pci_get_device(PCI_VENDOR_ID_JR3, PCI_ANY_ID, card);\r\nif (card == NULL) {\r\nbreak;\r\n} else {\r\nswitch (card->device) {\r\ncase PCI_DEVICE_ID_JR3_1_CHANNEL:{\r\ndevpriv->n_channels = 1;\r\n}\r\nbreak;\r\ncase PCI_DEVICE_ID_JR3_1_CHANNEL_NEW:{\r\ndevpriv->n_channels = 1;\r\n}\r\nbreak;\r\ncase PCI_DEVICE_ID_JR3_2_CHANNEL:{\r\ndevpriv->n_channels = 2;\r\n}\r\nbreak;\r\ncase PCI_DEVICE_ID_JR3_3_CHANNEL:{\r\ndevpriv->n_channels = 3;\r\n}\r\nbreak;\r\ncase PCI_DEVICE_ID_JR3_4_CHANNEL:{\r\ndevpriv->n_channels = 4;\r\n}\r\nbreak;\r\ndefault:{\r\ndevpriv->n_channels = 0;\r\n}\r\n}\r\nif (devpriv->n_channels >= 1) {\r\nif (opt_bus == 0 && opt_slot == 0) {\r\nbreak;\r\n} else if (opt_bus == card->bus->number &&\r\nopt_slot == PCI_SLOT(card->devfn)) {\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nif (!card) {\r\ndev_err(dev->hw_dev, "no jr3_pci found\n");\r\nreturn -EIO;\r\n} else {\r\ndevpriv->pci_dev = card;\r\ndev->board_name = "jr3_pci";\r\n}\r\nresult = comedi_pci_enable(card, "jr3_pci");\r\nif (result < 0)\r\nreturn -EIO;\r\ndevpriv->pci_enabled = 1;\r\ndevpriv->iobase = ioremap(pci_resource_start(card, 0),\r\noffsetof(struct jr3_t, channel[devpriv->n_channels]));\r\nif (!devpriv->iobase)\r\nreturn -ENOMEM;\r\nresult = alloc_subdevices(dev, devpriv->n_channels);\r\nif (result < 0)\r\ngoto out;\r\ndev->open = jr3_pci_open;\r\nfor (i = 0; i < devpriv->n_channels; i++) {\r\ndev->subdevices[i].type = COMEDI_SUBD_AI;\r\ndev->subdevices[i].subdev_flags = SDF_READABLE | SDF_GROUND;\r\ndev->subdevices[i].n_chan = 8 * 7 + 2;\r\ndev->subdevices[i].insn_read = jr3_pci_ai_insn_read;\r\ndev->subdevices[i].private =\r\nkzalloc(sizeof(struct jr3_pci_subdev_private), GFP_KERNEL);\r\nif (dev->subdevices[i].private) {\r\nstruct jr3_pci_subdev_private *p;\r\nint j;\r\np = dev->subdevices[i].private;\r\np->channel = &devpriv->iobase->channel[i].data;\r\ndev_dbg(dev->hw_dev, "p->channel %p %p (%tx)\n",\r\np->channel, devpriv->iobase,\r\n((char *)(p->channel) -\r\n(char *)(devpriv->iobase)));\r\np->channel_no = i;\r\nfor (j = 0; j < 8; j++) {\r\nint k;\r\np->range[j].length = 1;\r\np->range[j].range.min = -1000000;\r\np->range[j].range.max = 1000000;\r\nfor (k = 0; k < 7; k++) {\r\np->range_table_list[j + k * 8] =\r\n(struct comedi_lrange *)&p->\r\nrange[j];\r\np->maxdata_list[j + k * 8] = 0x7fff;\r\n}\r\n}\r\np->range[8].length = 1;\r\np->range[8].range.min = 0;\r\np->range[8].range.max = 65536;\r\np->range_table_list[56] =\r\n(struct comedi_lrange *)&p->range[8];\r\np->range_table_list[57] =\r\n(struct comedi_lrange *)&p->range[8];\r\np->maxdata_list[56] = 0xffff;\r\np->maxdata_list[57] = 0xffff;\r\ndev->subdevices[i].range_table = 0;\r\ndev->subdevices[i].range_table_list =\r\np->range_table_list;\r\ndev->subdevices[i].maxdata = 0;\r\ndev->subdevices[i].maxdata_list = p->maxdata_list;\r\n}\r\n}\r\ndevpriv->iobase->channel[0].reset = 0;\r\nresult = comedi_load_firmware(dev, "jr3pci.idm", jr3_download_firmware);\r\ndev_dbg(dev->hw_dev, "Firmare load %d\n", result);\r\nif (result < 0)\r\ngoto out;\r\nmsleep_interruptible(25);\r\nfor (i = 0; i < 0x18; i++) {\r\ndev_dbg(dev->hw_dev, "%c\n",\r\nget_u16(&devpriv->iobase->channel[0].\r\ndata.copyright[i]) >> 8);\r\n}\r\nfor (i = 0; i < devpriv->n_channels; i++) {\r\nstruct jr3_pci_subdev_private *p = dev->subdevices[i].private;\r\np->next_time_min = jiffies + msecs_to_jiffies(500);\r\np->next_time_max = jiffies + msecs_to_jiffies(2000);\r\n}\r\ndevpriv->timer.data = (unsigned long)dev;\r\ndevpriv->timer.function = jr3_pci_poll_dev;\r\ndevpriv->timer.expires = jiffies + msecs_to_jiffies(1000);\r\nadd_timer(&devpriv->timer);\r\nout:\r\nreturn result;\r\n}\r\nstatic int jr3_pci_detach(struct comedi_device *dev)\r\n{\r\nint i;\r\nstruct jr3_pci_dev_private *devpriv = dev->private;\r\nif (devpriv) {\r\ndel_timer_sync(&devpriv->timer);\r\nif (dev->subdevices) {\r\nfor (i = 0; i < devpriv->n_channels; i++)\r\nkfree(dev->subdevices[i].private);\r\n}\r\nif (devpriv->iobase)\r\niounmap((void *)devpriv->iobase);\r\nif (devpriv->pci_enabled)\r\ncomedi_pci_disable(devpriv->pci_dev);\r\nif (devpriv->pci_dev)\r\npci_dev_put(devpriv->pci_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit driver_jr3_pci_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nreturn comedi_pci_auto_config(dev, driver_jr3_pci.driver_name);\r\n}\r\nstatic void __devexit driver_jr3_pci_pci_remove(struct pci_dev *dev)\r\n{\r\ncomedi_pci_auto_unconfig(dev);\r\n}\r\nstatic int __init driver_jr3_pci_init_module(void)\r\n{\r\nint retval;\r\nretval = comedi_driver_register(&driver_jr3_pci);\r\nif (retval < 0)\r\nreturn retval;\r\ndriver_jr3_pci_pci_driver.name = (char *)driver_jr3_pci.driver_name;\r\nreturn pci_register_driver(&driver_jr3_pci_pci_driver);\r\n}\r\nstatic void __exit driver_jr3_pci_cleanup_module(void)\r\n{\r\npci_unregister_driver(&driver_jr3_pci_pci_driver);\r\ncomedi_driver_unregister(&driver_jr3_pci);\r\n}
