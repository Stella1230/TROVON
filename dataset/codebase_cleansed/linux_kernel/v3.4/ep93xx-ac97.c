static inline unsigned ep93xx_ac97_read_reg(struct ep93xx_ac97_info *info,\r\nunsigned reg)\r\n{\r\nreturn __raw_readl(info->regs + reg);\r\n}\r\nstatic inline void ep93xx_ac97_write_reg(struct ep93xx_ac97_info *info,\r\nunsigned reg, unsigned val)\r\n{\r\n__raw_writel(val, info->regs + reg);\r\n}\r\nstatic unsigned short ep93xx_ac97_read(struct snd_ac97 *ac97,\r\nunsigned short reg)\r\n{\r\nstruct ep93xx_ac97_info *info = ep93xx_ac97_info;\r\nunsigned short val;\r\nmutex_lock(&info->lock);\r\nep93xx_ac97_write_reg(info, AC97S1DATA, reg);\r\nep93xx_ac97_write_reg(info, AC97IM, AC97_SLOT2RXVALID);\r\nif (!wait_for_completion_timeout(&info->done, AC97_TIMEOUT)) {\r\ndev_warn(info->dev, "timeout reading register %x\n", reg);\r\nmutex_unlock(&info->lock);\r\nreturn -ETIMEDOUT;\r\n}\r\nval = (unsigned short)ep93xx_ac97_read_reg(info, AC97S2DATA);\r\nmutex_unlock(&info->lock);\r\nreturn val;\r\n}\r\nstatic void ep93xx_ac97_write(struct snd_ac97 *ac97,\r\nunsigned short reg,\r\nunsigned short val)\r\n{\r\nstruct ep93xx_ac97_info *info = ep93xx_ac97_info;\r\nmutex_lock(&info->lock);\r\nep93xx_ac97_write_reg(info, AC97S2DATA, val);\r\nep93xx_ac97_write_reg(info, AC97S1DATA, reg);\r\nep93xx_ac97_write_reg(info, AC97IM, AC97_SLOT2TXCOMPLETE);\r\nif (!wait_for_completion_timeout(&info->done, AC97_TIMEOUT))\r\ndev_warn(info->dev, "timeout writing register %x\n", reg);\r\nmutex_unlock(&info->lock);\r\n}\r\nstatic void ep93xx_ac97_warm_reset(struct snd_ac97 *ac97)\r\n{\r\nstruct ep93xx_ac97_info *info = ep93xx_ac97_info;\r\nmutex_lock(&info->lock);\r\nep93xx_ac97_write_reg(info, AC97SYNC, AC97SYNC_TIMEDSYNC);\r\nep93xx_ac97_write_reg(info, AC97IM, AC97_CODECREADY);\r\nif (!wait_for_completion_timeout(&info->done, AC97_TIMEOUT))\r\ndev_warn(info->dev, "codec warm reset timeout\n");\r\nmutex_unlock(&info->lock);\r\n}\r\nstatic void ep93xx_ac97_cold_reset(struct snd_ac97 *ac97)\r\n{\r\nstruct ep93xx_ac97_info *info = ep93xx_ac97_info;\r\nmutex_lock(&info->lock);\r\nep93xx_ac97_write_reg(info, AC97GCR, 0);\r\nep93xx_ac97_write_reg(info, AC97EOI, AC97EOI_CODECREADY | AC97EOI_WINT);\r\nep93xx_ac97_write_reg(info, AC97GCR, AC97GCR_AC97IFE);\r\nep93xx_ac97_write_reg(info, AC97RESET, AC97RESET_TIMEDRESET);\r\nep93xx_ac97_write_reg(info, AC97IM, AC97_CODECREADY);\r\nif (!wait_for_completion_timeout(&info->done, AC97_TIMEOUT))\r\ndev_warn(info->dev, "codec cold reset timeout\n");\r\nusleep_range(15000, 20000);\r\nmutex_unlock(&info->lock);\r\n}\r\nstatic irqreturn_t ep93xx_ac97_interrupt(int irq, void *dev_id)\r\n{\r\nstruct ep93xx_ac97_info *info = dev_id;\r\nunsigned status, mask;\r\nstatus = ep93xx_ac97_read_reg(info, AC97GIS);\r\nmask = ep93xx_ac97_read_reg(info, AC97IM);\r\nmask &= ~status;\r\nep93xx_ac97_write_reg(info, AC97IM, mask);\r\ncomplete(&info->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ep93xx_ac97_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *dai)\r\n{\r\nstruct ep93xx_ac97_info *info = snd_soc_dai_get_drvdata(dai);\r\nunsigned v = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nv |= AC97TXCR_CM;\r\nv |= AC97TXCR_TX3 | AC97TXCR_TX4;\r\nv |= AC97TXCR_TEN;\r\nep93xx_ac97_write_reg(info, AC97TXCR(1), v);\r\n} else {\r\nv |= AC97RXCR_CM;\r\nv |= AC97RXCR_RX3 | AC97RXCR_RX4;\r\nv |= AC97RXCR_REN;\r\nep93xx_ac97_write_reg(info, AC97RXCR(1), v);\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nunsigned long timeout = jiffies + AC97_TIMEOUT;\r\ndo {\r\nv = ep93xx_ac97_read_reg(info, AC97SR(1));\r\nif (time_after(jiffies, timeout)) {\r\ndev_warn(info->dev, "TX timeout\n");\r\nbreak;\r\n}\r\n} while (!(v & (AC97SR_TXFE | AC97SR_TXUE)));\r\nep93xx_ac97_write_reg(info, AC97TXCR(1), 0);\r\n} else {\r\nep93xx_ac97_write_reg(info, AC97RXCR(1), 0);\r\n}\r\nbreak;\r\ndefault:\r\ndev_warn(info->dev, "unknown command %d\n", cmd);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ep93xx_ac97_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct ep93xx_pcm_dma_params *dma_data;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndma_data = &ep93xx_ac97_pcm_out;\r\nelse\r\ndma_data = &ep93xx_ac97_pcm_in;\r\nsnd_soc_dai_set_dma_data(dai, substream, dma_data);\r\nreturn 0;\r\n}\r\nstatic int __devinit ep93xx_ac97_probe(struct platform_device *pdev)\r\n{\r\nstruct ep93xx_ac97_info *info;\r\nint ret;\r\ninfo = kzalloc(sizeof(struct ep93xx_ac97_info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&pdev->dev, info);\r\nmutex_init(&info->lock);\r\ninit_completion(&info->done);\r\ninfo->dev = &pdev->dev;\r\ninfo->mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!info->mem) {\r\nret = -ENXIO;\r\ngoto fail_free_info;\r\n}\r\ninfo->irq = platform_get_irq(pdev, 0);\r\nif (!info->irq) {\r\nret = -ENXIO;\r\ngoto fail_free_info;\r\n}\r\nif (!request_mem_region(info->mem->start, resource_size(info->mem),\r\npdev->name)) {\r\nret = -EBUSY;\r\ngoto fail_free_info;\r\n}\r\ninfo->regs = ioremap(info->mem->start, resource_size(info->mem));\r\nif (!info->regs) {\r\nret = -ENOMEM;\r\ngoto fail_release_mem;\r\n}\r\nret = request_irq(info->irq, ep93xx_ac97_interrupt, IRQF_TRIGGER_HIGH,\r\npdev->name, info);\r\nif (ret)\r\ngoto fail_unmap_mem;\r\nep93xx_ac97_info = info;\r\nplatform_set_drvdata(pdev, info);\r\nret = snd_soc_register_dai(&pdev->dev, &ep93xx_ac97_dai);\r\nif (ret)\r\ngoto fail_free_irq;\r\nreturn 0;\r\nfail_free_irq:\r\nplatform_set_drvdata(pdev, NULL);\r\nfree_irq(info->irq, info);\r\nfail_unmap_mem:\r\niounmap(info->regs);\r\nfail_release_mem:\r\nrelease_mem_region(info->mem->start, resource_size(info->mem));\r\nfail_free_info:\r\nkfree(info);\r\nreturn ret;\r\n}\r\nstatic int __devexit ep93xx_ac97_remove(struct platform_device *pdev)\r\n{\r\nstruct ep93xx_ac97_info *info = platform_get_drvdata(pdev);\r\nsnd_soc_unregister_dai(&pdev->dev);\r\nep93xx_ac97_write_reg(info, AC97GCR, 0);\r\nfree_irq(info->irq, info);\r\niounmap(info->regs);\r\nrelease_mem_region(info->mem->start, resource_size(info->mem));\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(info);\r\nreturn 0;\r\n}
