static inline struct tty_ldisc *get_ldisc(struct tty_ldisc *ld)\r\n{\r\nif (ld)\r\natomic_inc(&ld->users);\r\nreturn ld;\r\n}\r\nstatic void put_ldisc(struct tty_ldisc *ld)\r\n{\r\nunsigned long flags;\r\nif (WARN_ON_ONCE(!ld))\r\nreturn;\r\nlocal_irq_save(flags);\r\nif (atomic_dec_and_lock(&ld->users, &tty_ldisc_lock)) {\r\nstruct tty_ldisc_ops *ldo = ld->ops;\r\nldo->refcount--;\r\nmodule_put(ldo->owner);\r\nspin_unlock_irqrestore(&tty_ldisc_lock, flags);\r\nkfree(ld);\r\nreturn;\r\n}\r\nlocal_irq_restore(flags);\r\nwake_up(&tty_ldisc_idle);\r\n}\r\nint tty_register_ldisc(int disc, struct tty_ldisc_ops *new_ldisc)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nif (disc < N_TTY || disc >= NR_LDISCS)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&tty_ldisc_lock, flags);\r\ntty_ldiscs[disc] = new_ldisc;\r\nnew_ldisc->num = disc;\r\nnew_ldisc->refcount = 0;\r\nspin_unlock_irqrestore(&tty_ldisc_lock, flags);\r\nreturn ret;\r\n}\r\nint tty_unregister_ldisc(int disc)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nif (disc < N_TTY || disc >= NR_LDISCS)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&tty_ldisc_lock, flags);\r\nif (tty_ldiscs[disc]->refcount)\r\nret = -EBUSY;\r\nelse\r\ntty_ldiscs[disc] = NULL;\r\nspin_unlock_irqrestore(&tty_ldisc_lock, flags);\r\nreturn ret;\r\n}\r\nstatic struct tty_ldisc_ops *get_ldops(int disc)\r\n{\r\nunsigned long flags;\r\nstruct tty_ldisc_ops *ldops, *ret;\r\nspin_lock_irqsave(&tty_ldisc_lock, flags);\r\nret = ERR_PTR(-EINVAL);\r\nldops = tty_ldiscs[disc];\r\nif (ldops) {\r\nret = ERR_PTR(-EAGAIN);\r\nif (try_module_get(ldops->owner)) {\r\nldops->refcount++;\r\nret = ldops;\r\n}\r\n}\r\nspin_unlock_irqrestore(&tty_ldisc_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void put_ldops(struct tty_ldisc_ops *ldops)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&tty_ldisc_lock, flags);\r\nldops->refcount--;\r\nmodule_put(ldops->owner);\r\nspin_unlock_irqrestore(&tty_ldisc_lock, flags);\r\n}\r\nstatic struct tty_ldisc *tty_ldisc_get(int disc)\r\n{\r\nstruct tty_ldisc *ld;\r\nstruct tty_ldisc_ops *ldops;\r\nif (disc < N_TTY || disc >= NR_LDISCS)\r\nreturn ERR_PTR(-EINVAL);\r\nldops = get_ldops(disc);\r\nif (IS_ERR(ldops)) {\r\nrequest_module("tty-ldisc-%d", disc);\r\nldops = get_ldops(disc);\r\nif (IS_ERR(ldops))\r\nreturn ERR_CAST(ldops);\r\n}\r\nld = kmalloc(sizeof(struct tty_ldisc), GFP_KERNEL);\r\nif (ld == NULL) {\r\nput_ldops(ldops);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nld->ops = ldops;\r\natomic_set(&ld->users, 1);\r\nreturn ld;\r\n}\r\nstatic void *tty_ldiscs_seq_start(struct seq_file *m, loff_t *pos)\r\n{\r\nreturn (*pos < NR_LDISCS) ? pos : NULL;\r\n}\r\nstatic void *tty_ldiscs_seq_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nreturn (*pos < NR_LDISCS) ? pos : NULL;\r\n}\r\nstatic void tty_ldiscs_seq_stop(struct seq_file *m, void *v)\r\n{\r\n}\r\nstatic int tty_ldiscs_seq_show(struct seq_file *m, void *v)\r\n{\r\nint i = *(loff_t *)v;\r\nstruct tty_ldisc_ops *ldops;\r\nldops = get_ldops(i);\r\nif (IS_ERR(ldops))\r\nreturn 0;\r\nseq_printf(m, "%-10s %2d\n", ldops->name ? ldops->name : "???", i);\r\nput_ldops(ldops);\r\nreturn 0;\r\n}\r\nstatic int proc_tty_ldiscs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &tty_ldiscs_seq_ops);\r\n}\r\nstatic void tty_ldisc_assign(struct tty_struct *tty, struct tty_ldisc *ld)\r\n{\r\ntty->ldisc = ld;\r\n}\r\nstatic struct tty_ldisc *tty_ldisc_try(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nstruct tty_ldisc *ld;\r\nspin_lock_irqsave(&tty_ldisc_lock, flags);\r\nld = NULL;\r\nif (test_bit(TTY_LDISC, &tty->flags))\r\nld = get_ldisc(tty->ldisc);\r\nspin_unlock_irqrestore(&tty_ldisc_lock, flags);\r\nreturn ld;\r\n}\r\nstruct tty_ldisc *tty_ldisc_ref_wait(struct tty_struct *tty)\r\n{\r\nstruct tty_ldisc *ld;\r\nwait_event(tty_ldisc_wait, (ld = tty_ldisc_try(tty)) != NULL);\r\nreturn ld;\r\n}\r\nstruct tty_ldisc *tty_ldisc_ref(struct tty_struct *tty)\r\n{\r\nreturn tty_ldisc_try(tty);\r\n}\r\nvoid tty_ldisc_deref(struct tty_ldisc *ld)\r\n{\r\nput_ldisc(ld);\r\n}\r\nstatic inline void tty_ldisc_put(struct tty_ldisc *ld)\r\n{\r\nput_ldisc(ld);\r\n}\r\nvoid tty_ldisc_enable(struct tty_struct *tty)\r\n{\r\nset_bit(TTY_LDISC, &tty->flags);\r\nclear_bit(TTY_LDISC_CHANGING, &tty->flags);\r\nwake_up(&tty_ldisc_wait);\r\n}\r\nvoid tty_ldisc_flush(struct tty_struct *tty)\r\n{\r\nstruct tty_ldisc *ld = tty_ldisc_ref(tty);\r\nif (ld) {\r\nif (ld->ops->flush_buffer)\r\nld->ops->flush_buffer(tty);\r\ntty_ldisc_deref(ld);\r\n}\r\ntty_buffer_flush(tty);\r\n}\r\nstatic void tty_set_termios_ldisc(struct tty_struct *tty, int num)\r\n{\r\nmutex_lock(&tty->termios_mutex);\r\ntty->termios->c_line = num;\r\nmutex_unlock(&tty->termios_mutex);\r\n}\r\nstatic int tty_ldisc_open(struct tty_struct *tty, struct tty_ldisc *ld)\r\n{\r\nWARN_ON(test_and_set_bit(TTY_LDISC_OPEN, &tty->flags));\r\nif (ld->ops->open) {\r\nint ret;\r\nret = ld->ops->open(tty);\r\nif (ret)\r\nclear_bit(TTY_LDISC_OPEN, &tty->flags);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tty_ldisc_close(struct tty_struct *tty, struct tty_ldisc *ld)\r\n{\r\nWARN_ON(!test_bit(TTY_LDISC_OPEN, &tty->flags));\r\nclear_bit(TTY_LDISC_OPEN, &tty->flags);\r\nif (ld->ops->close)\r\nld->ops->close(tty);\r\n}\r\nstatic void tty_ldisc_restore(struct tty_struct *tty, struct tty_ldisc *old)\r\n{\r\nchar buf[64];\r\nstruct tty_ldisc *new_ldisc;\r\nint r;\r\nold = tty_ldisc_get(old->ops->num);\r\nWARN_ON(IS_ERR(old));\r\ntty_ldisc_assign(tty, old);\r\ntty_set_termios_ldisc(tty, old->ops->num);\r\nif (tty_ldisc_open(tty, old) < 0) {\r\ntty_ldisc_put(old);\r\nnew_ldisc = tty_ldisc_get(N_TTY);\r\nif (IS_ERR(new_ldisc))\r\npanic("n_tty: get");\r\ntty_ldisc_assign(tty, new_ldisc);\r\ntty_set_termios_ldisc(tty, N_TTY);\r\nr = tty_ldisc_open(tty, new_ldisc);\r\nif (r < 0)\r\npanic("Couldn't open N_TTY ldisc for "\r\n"%s --- error %d.",\r\ntty_name(tty, buf), r);\r\n}\r\n}\r\nstatic int tty_ldisc_halt(struct tty_struct *tty)\r\n{\r\nclear_bit(TTY_LDISC, &tty->flags);\r\nreturn cancel_work_sync(&tty->buf.work);\r\n}\r\nstatic void tty_ldisc_flush_works(struct tty_struct *tty)\r\n{\r\nflush_work_sync(&tty->hangup_work);\r\nflush_work_sync(&tty->SAK_work);\r\nflush_work_sync(&tty->buf.work);\r\n}\r\nstatic int tty_ldisc_wait_idle(struct tty_struct *tty, long timeout)\r\n{\r\nlong ret;\r\nret = wait_event_timeout(tty_ldisc_idle,\r\natomic_read(&tty->ldisc->users) == 1, timeout);\r\nreturn ret > 0 ? 0 : -EBUSY;\r\n}\r\nint tty_set_ldisc(struct tty_struct *tty, int ldisc)\r\n{\r\nint retval;\r\nstruct tty_ldisc *o_ldisc, *new_ldisc;\r\nint work, o_work = 0;\r\nstruct tty_struct *o_tty;\r\nnew_ldisc = tty_ldisc_get(ldisc);\r\nif (IS_ERR(new_ldisc))\r\nreturn PTR_ERR(new_ldisc);\r\ntty_lock();\r\no_tty = tty->link;\r\nif (tty->ldisc->ops->num == ldisc) {\r\ntty_unlock();\r\ntty_ldisc_put(new_ldisc);\r\nreturn 0;\r\n}\r\ntty_unlock();\r\ntty_wait_until_sent(tty, 0);\r\ntty_lock();\r\nmutex_lock(&tty->ldisc_mutex);\r\nwhile (test_bit(TTY_LDISC_CHANGING, &tty->flags)) {\r\nmutex_unlock(&tty->ldisc_mutex);\r\ntty_unlock();\r\nwait_event(tty_ldisc_wait,\r\ntest_bit(TTY_LDISC_CHANGING, &tty->flags) == 0);\r\ntty_lock();\r\nmutex_lock(&tty->ldisc_mutex);\r\n}\r\nset_bit(TTY_LDISC_CHANGING, &tty->flags);\r\ntty->receive_room = 0;\r\no_ldisc = tty->ldisc;\r\ntty_unlock();\r\nwork = tty_ldisc_halt(tty);\r\nif (o_tty)\r\no_work = tty_ldisc_halt(o_tty);\r\nmutex_unlock(&tty->ldisc_mutex);\r\ntty_ldisc_flush_works(tty);\r\nretval = tty_ldisc_wait_idle(tty, 5 * HZ);\r\ntty_lock();\r\nmutex_lock(&tty->ldisc_mutex);\r\nif (retval) {\r\ntty_ldisc_put(new_ldisc);\r\ngoto enable;\r\n}\r\nif (test_bit(TTY_HUPPED, &tty->flags)) {\r\nclear_bit(TTY_LDISC_CHANGING, &tty->flags);\r\nmutex_unlock(&tty->ldisc_mutex);\r\ntty_ldisc_put(new_ldisc);\r\ntty_unlock();\r\nreturn -EIO;\r\n}\r\ntty_ldisc_close(tty, o_ldisc);\r\ntty_ldisc_assign(tty, new_ldisc);\r\ntty_set_termios_ldisc(tty, ldisc);\r\nretval = tty_ldisc_open(tty, new_ldisc);\r\nif (retval < 0) {\r\ntty_ldisc_put(new_ldisc);\r\ntty_ldisc_restore(tty, o_ldisc);\r\n}\r\nif (tty->ldisc->ops->num != o_ldisc->ops->num && tty->ops->set_ldisc)\r\ntty->ops->set_ldisc(tty);\r\ntty_ldisc_put(o_ldisc);\r\nenable:\r\ntty_ldisc_enable(tty);\r\nif (o_tty)\r\ntty_ldisc_enable(o_tty);\r\nif (work)\r\nschedule_work(&tty->buf.work);\r\nif (o_work)\r\nschedule_work(&o_tty->buf.work);\r\nmutex_unlock(&tty->ldisc_mutex);\r\ntty_unlock();\r\nreturn retval;\r\n}\r\nstatic void tty_reset_termios(struct tty_struct *tty)\r\n{\r\nmutex_lock(&tty->termios_mutex);\r\n*tty->termios = tty->driver->init_termios;\r\ntty->termios->c_ispeed = tty_termios_input_baud_rate(tty->termios);\r\ntty->termios->c_ospeed = tty_termios_baud_rate(tty->termios);\r\nmutex_unlock(&tty->termios_mutex);\r\n}\r\nstatic int tty_ldisc_reinit(struct tty_struct *tty, int ldisc)\r\n{\r\nstruct tty_ldisc *ld = tty_ldisc_get(ldisc);\r\nif (IS_ERR(ld))\r\nreturn -1;\r\ntty_ldisc_close(tty, tty->ldisc);\r\ntty_ldisc_put(tty->ldisc);\r\ntty->ldisc = NULL;\r\ntty_ldisc_assign(tty, ld);\r\ntty_set_termios_ldisc(tty, ldisc);\r\nreturn 0;\r\n}\r\nvoid tty_ldisc_hangup(struct tty_struct *tty)\r\n{\r\nstruct tty_ldisc *ld;\r\nint reset = tty->driver->flags & TTY_DRIVER_RESET_TERMIOS;\r\nint err = 0;\r\nld = tty_ldisc_ref(tty);\r\nif (ld != NULL) {\r\nif (ld->ops->flush_buffer)\r\nld->ops->flush_buffer(tty);\r\ntty_driver_flush_buffer(tty);\r\nif ((test_bit(TTY_DO_WRITE_WAKEUP, &tty->flags)) &&\r\nld->ops->write_wakeup)\r\nld->ops->write_wakeup(tty);\r\nif (ld->ops->hangup)\r\nld->ops->hangup(tty);\r\ntty_ldisc_deref(ld);\r\n}\r\nwake_up_interruptible_poll(&tty->write_wait, POLLOUT);\r\nwake_up_interruptible_poll(&tty->read_wait, POLLIN);\r\nmutex_lock(&tty->ldisc_mutex);\r\nclear_bit(TTY_LDISC, &tty->flags);\r\ntty_unlock();\r\ncancel_work_sync(&tty->buf.work);\r\nmutex_unlock(&tty->ldisc_mutex);\r\nretry:\r\ntty_lock();\r\nmutex_lock(&tty->ldisc_mutex);\r\nif (tty->ldisc) {\r\nif (atomic_read(&tty->ldisc->users) != 1) {\r\nchar cur_n[TASK_COMM_LEN], tty_n[64];\r\nlong timeout = 3 * HZ;\r\ntty_unlock();\r\nwhile (tty_ldisc_wait_idle(tty, timeout) == -EBUSY) {\r\ntimeout = MAX_SCHEDULE_TIMEOUT;\r\nprintk_ratelimited(KERN_WARNING\r\n"%s: waiting (%s) for %s took too long, but we keep waiting...\n",\r\n__func__, get_task_comm(cur_n, current),\r\ntty_name(tty, tty_n));\r\n}\r\nmutex_unlock(&tty->ldisc_mutex);\r\ngoto retry;\r\n}\r\nif (reset == 0) {\r\nif (!tty_ldisc_reinit(tty, tty->termios->c_line))\r\nerr = tty_ldisc_open(tty, tty->ldisc);\r\nelse\r\nerr = 1;\r\n}\r\nif (reset || err) {\r\nBUG_ON(tty_ldisc_reinit(tty, N_TTY));\r\nWARN_ON(tty_ldisc_open(tty, tty->ldisc));\r\n}\r\ntty_ldisc_enable(tty);\r\n}\r\nmutex_unlock(&tty->ldisc_mutex);\r\nif (reset)\r\ntty_reset_termios(tty);\r\n}\r\nint tty_ldisc_setup(struct tty_struct *tty, struct tty_struct *o_tty)\r\n{\r\nstruct tty_ldisc *ld = tty->ldisc;\r\nint retval;\r\nretval = tty_ldisc_open(tty, ld);\r\nif (retval)\r\nreturn retval;\r\nif (o_tty) {\r\nretval = tty_ldisc_open(o_tty, o_tty->ldisc);\r\nif (retval) {\r\ntty_ldisc_close(tty, ld);\r\nreturn retval;\r\n}\r\ntty_ldisc_enable(o_tty);\r\n}\r\ntty_ldisc_enable(tty);\r\nreturn 0;\r\n}\r\nvoid tty_ldisc_release(struct tty_struct *tty, struct tty_struct *o_tty)\r\n{\r\ntty_unlock();\r\ntty_ldisc_halt(tty);\r\ntty_ldisc_flush_works(tty);\r\ntty_lock();\r\nmutex_lock(&tty->ldisc_mutex);\r\ntty_ldisc_close(tty, tty->ldisc);\r\ntty_ldisc_put(tty->ldisc);\r\ntty->ldisc = NULL;\r\ntty_set_termios_ldisc(tty, N_TTY);\r\nmutex_unlock(&tty->ldisc_mutex);\r\nif (o_tty)\r\ntty_ldisc_release(o_tty, NULL);\r\n}\r\nvoid tty_ldisc_init(struct tty_struct *tty)\r\n{\r\nstruct tty_ldisc *ld = tty_ldisc_get(N_TTY);\r\nif (IS_ERR(ld))\r\npanic("n_tty: init_tty");\r\ntty_ldisc_assign(tty, ld);\r\n}\r\nvoid tty_ldisc_deinit(struct tty_struct *tty)\r\n{\r\nput_ldisc(tty->ldisc);\r\ntty_ldisc_assign(tty, NULL);\r\n}\r\nvoid tty_ldisc_begin(void)\r\n{\r\n(void) tty_register_ldisc(N_TTY, &tty_ldisc_N_TTY);\r\n}
