static void zap_pte(struct mm_struct *mm, struct vm_area_struct *vma,\r\nunsigned long addr, pte_t *ptep)\r\n{\r\npte_t pte = *ptep;\r\nif (pte_present(pte)) {\r\nstruct page *page;\r\nflush_cache_page(vma, addr, pte_pfn(pte));\r\npte = ptep_clear_flush(vma, addr, ptep);\r\npage = vm_normal_page(vma, addr, pte);\r\nif (page) {\r\nif (pte_dirty(pte))\r\nset_page_dirty(page);\r\npage_remove_rmap(page);\r\npage_cache_release(page);\r\nupdate_hiwater_rss(mm);\r\ndec_mm_counter(mm, MM_FILEPAGES);\r\n}\r\n} else {\r\nif (!pte_file(pte))\r\nfree_swap_and_cache(pte_to_swp_entry(pte));\r\npte_clear_not_present_full(mm, addr, ptep, 0);\r\n}\r\n}\r\nstatic int install_file_pte(struct mm_struct *mm, struct vm_area_struct *vma,\r\nunsigned long addr, unsigned long pgoff, pgprot_t prot)\r\n{\r\nint err = -ENOMEM;\r\npte_t *pte;\r\nspinlock_t *ptl;\r\npte = get_locked_pte(mm, addr, &ptl);\r\nif (!pte)\r\ngoto out;\r\nif (!pte_none(*pte))\r\nzap_pte(mm, vma, addr, pte);\r\nset_pte_at(mm, addr, pte, pgoff_to_pte(pgoff));\r\npte_unmap_unlock(pte, ptl);\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int populate_range(struct mm_struct *mm, struct vm_area_struct *vma,\r\nunsigned long addr, unsigned long size, pgoff_t pgoff)\r\n{\r\nint err;\r\ndo {\r\nerr = install_file_pte(mm, vma, addr, pgoff, vma->vm_page_prot);\r\nif (err)\r\nreturn err;\r\nsize -= PAGE_SIZE;\r\naddr += PAGE_SIZE;\r\npgoff++;\r\n} while (size);\r\nreturn 0;\r\n}
