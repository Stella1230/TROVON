unsigned char\r\nMds_initial(struct wbsoft_priv *adapter)\r\n{\r\nstruct wb35_mds *pMds = &adapter->Mds;\r\npMds->TxPause = false;\r\npMds->TxRTSThreshold = DEFAULT_RTSThreshold;\r\npMds->TxFragmentThreshold = DEFAULT_FRAGMENT_THRESHOLD;\r\nreturn hal_get_tx_buffer(&adapter->sHwData, &pMds->pTxBuffer);\r\n}\r\nstatic void Mds_DurationSet(struct wbsoft_priv *adapter, struct wb35_descriptor *pDes, u8 *buffer)\r\n{\r\nstruct T00_descriptor *pT00;\r\nstruct T01_descriptor *pT01;\r\nu16 Duration, NextBodyLen, OffsetSize;\r\nu8 Rate, i;\r\nunsigned char CTS_on = false, RTS_on = false;\r\nstruct T00_descriptor *pNextT00;\r\nu16 BodyLen = 0;\r\nunsigned char boGroupAddr = false;\r\nOffsetSize = pDes->FragmentThreshold + 32 + 3;\r\nOffsetSize &= ~0x03;\r\nRate = pDes->TxRate >> 1;\r\nif (!Rate)\r\nRate = 1;\r\npT00 = (struct T00_descriptor *)buffer;\r\npT01 = (struct T01_descriptor *)(buffer+4);\r\npNextT00 = (struct T00_descriptor *)(buffer+OffsetSize);\r\nif (buffer[DOT_11_DA_OFFSET+8] & 0x1)\r\nboGroupAddr = true;\r\nif (!boGroupAddr) {\r\nBodyLen = (u16)pT00->T00_frame_length;\r\nBodyLen += 4;\r\nif (BodyLen >= CURRENT_RTS_THRESHOLD)\r\nRTS_on = true;\r\nelse {\r\nif (pT01->T01_modulation_type) {\r\nif (CURRENT_PROTECT_MECHANISM)\r\nCTS_on = true;\r\n}\r\n}\r\n}\r\nif (RTS_on || CTS_on) {\r\nif (pT01->T01_modulation_type) {\r\nDuration = 2*DEFAULT_SIFSTIME +\r\n2*PREAMBLE_PLUS_SIGNAL_PLUS_SIGNALEXTENSION +\r\n((BodyLen*8 + 22 + Rate*4 - 1)/(Rate*4))*Tsym +\r\n((112 + 22 + 95)/96)*Tsym;\r\n} else {\r\nif (pT01->T01_plcp_header_length)\r\nDuration = LONG_PREAMBLE_PLUS_PLCPHEADER_TIME*2;\r\nelse\r\nDuration = SHORT_PREAMBLE_PLUS_PLCPHEADER_TIME*2;\r\nDuration += (((BodyLen + 14)*8 + Rate-1) / Rate +\r\nDEFAULT_SIFSTIME*2);\r\n}\r\nif (RTS_on) {\r\nif (pT01->T01_modulation_type) {\r\nDuration += (DEFAULT_SIFSTIME +\r\nPREAMBLE_PLUS_SIGNAL_PLUS_SIGNALEXTENSION +\r\n((112 + 22 + 95)/96)*Tsym);\r\n} else {\r\nif (pT01->T01_plcp_header_length)\r\nDuration += LONG_PREAMBLE_PLUS_PLCPHEADER_TIME;\r\nelse\r\nDuration += SHORT_PREAMBLE_PLUS_PLCPHEADER_TIME;\r\nDuration += (((112 + Rate-1) / Rate) + DEFAULT_SIFSTIME);\r\n}\r\n}\r\npT01->T01_add_rts = RTS_on ? 1 : 0;\r\npT01->T01_add_cts = CTS_on ? 1 : 0;\r\npT01->T01_rts_cts_duration = Duration;\r\n}\r\nif (boGroupAddr)\r\nDuration = 0;\r\nelse {\r\nfor (i = pDes->FragmentCount-1; i > 0; i--) {\r\nNextBodyLen = (u16)pNextT00->T00_frame_length;\r\nNextBodyLen += 4;\r\nif (pT01->T01_modulation_type) {\r\nDuration = PREAMBLE_PLUS_SIGNAL_PLUS_SIGNALEXTENSION * 3;\r\nDuration += (((NextBodyLen*8 + 22 + Rate*4 - 1)/(Rate*4)) * Tsym +\r\n(((2*14)*8 + 22 + 95)/96)*Tsym +\r\nDEFAULT_SIFSTIME*3);\r\n} else {\r\nif (pT01->T01_plcp_header_length)\r\nDuration = LONG_PREAMBLE_PLUS_PLCPHEADER_TIME*3;\r\nelse\r\nDuration = SHORT_PREAMBLE_PLUS_PLCPHEADER_TIME*3;\r\nDuration += (((NextBodyLen + (2*14))*8 + Rate-1) / Rate +\r\nDEFAULT_SIFSTIME*3);\r\n}\r\n((u16 *)buffer)[5] = cpu_to_le16(Duration);\r\npNextT00->value = cpu_to_le32(pNextT00->value);\r\npT01->value = cpu_to_le32(pT01->value);\r\nbuffer += OffsetSize;\r\npT01 = (struct T01_descriptor *)(buffer+4);\r\nif (i != 1)\r\npNextT00 = (struct T00_descriptor *)(buffer+OffsetSize);\r\n}\r\nif (pT01->T01_modulation_type) {\r\nDuration = PREAMBLE_PLUS_SIGNAL_PLUS_SIGNALEXTENSION;\r\nDuration += (((112 + 22 + 95)/96)*Tsym + DEFAULT_SIFSTIME);\r\n} else {\r\nif (pT01->T01_plcp_header_length)\r\nDuration = LONG_PREAMBLE_PLUS_PLCPHEADER_TIME;\r\nelse\r\nDuration = SHORT_PREAMBLE_PLUS_PLCPHEADER_TIME;\r\nDuration += ((112 + Rate-1)/Rate + DEFAULT_SIFSTIME);\r\n}\r\n}\r\n((u16 *)buffer)[5] = cpu_to_le16(Duration);\r\npT00->value = cpu_to_le32(pT00->value);\r\npT01->value = cpu_to_le32(pT01->value);\r\n}\r\nstatic u16 Mds_BodyCopy(struct wbsoft_priv *adapter, struct wb35_descriptor *pDes, u8 *TargetBuffer)\r\n{\r\nstruct T00_descriptor *pT00;\r\nstruct wb35_mds *pMds = &adapter->Mds;\r\nu8 *buffer;\r\nu8 *src_buffer;\r\nu8 *pctmp;\r\nu16 Size = 0;\r\nu16 SizeLeft, CopySize, CopyLeft, stmp;\r\nu8 buf_index, FragmentCount = 0;\r\nbuffer = TargetBuffer;\r\nSizeLeft = pDes->buffer_total_size;\r\nbuf_index = pDes->buffer_start_index;\r\npT00 = (struct T00_descriptor *)buffer;\r\nwhile (SizeLeft) {\r\npT00 = (struct T00_descriptor *)buffer;\r\nCopySize = SizeLeft;\r\nif (SizeLeft > pDes->FragmentThreshold) {\r\nCopySize = pDes->FragmentThreshold;\r\npT00->T00_frame_length = 24 + CopySize;\r\n} else\r\npT00->T00_frame_length = 24 + SizeLeft;\r\nSizeLeft -= CopySize;\r\npctmp = (u8 *)(buffer + 8 + DOT_11_SEQUENCE_OFFSET);\r\n*pctmp &= 0xf0;\r\n*pctmp |= FragmentCount;\r\nif (!FragmentCount)\r\npT00->T00_first_mpdu = 1;\r\nbuffer += 32;\r\nSize += 32;\r\nstmp = CopySize + 3;\r\nstmp &= ~0x03;\r\nSize += stmp;\r\nwhile (CopySize) {\r\nsrc_buffer = pDes->buffer_address[buf_index];\r\nCopyLeft = CopySize;\r\nif (CopySize >= pDes->buffer_size[buf_index]) {\r\nCopyLeft = pDes->buffer_size[buf_index];\r\nbuf_index++;\r\nbuf_index %= MAX_DESCRIPTOR_BUFFER_INDEX;\r\n} else {\r\nu8 *pctmp = pDes->buffer_address[buf_index];\r\npctmp += CopySize;\r\npDes->buffer_address[buf_index] = pctmp;\r\npDes->buffer_size[buf_index] -= CopySize;\r\n}\r\nmemcpy(buffer, src_buffer, CopyLeft);\r\nbuffer += CopyLeft;\r\nCopySize -= CopyLeft;\r\n}\r\nif (pMds->MicAdd) {\r\nif (!SizeLeft) {\r\npMds->MicWriteAddress[pMds->MicWriteIndex] = buffer - pMds->MicAdd;\r\npMds->MicWriteSize[pMds->MicWriteIndex] = pMds->MicAdd;\r\npMds->MicAdd = 0;\r\n} else if (SizeLeft < 8) {\r\npMds->MicAdd = SizeLeft;\r\npMds->MicWriteAddress[pMds->MicWriteIndex] = buffer - (8 - SizeLeft);\r\npMds->MicWriteSize[pMds->MicWriteIndex] = 8 - SizeLeft;\r\npMds->MicWriteIndex++;\r\n}\r\n}\r\nif (SizeLeft) {\r\nbuffer = TargetBuffer + Size;\r\nmemcpy(buffer, TargetBuffer, 32);\r\npT00 = (struct T00_descriptor *)buffer;\r\npT00->T00_first_mpdu = 0;\r\n}\r\nFragmentCount++;\r\n}\r\npT00->T00_last_mpdu = 1;\r\npT00->T00_IsLastMpdu = 1;\r\nbuffer = (u8 *)pT00 + 8;\r\nbuffer[1] &= ~0x04;\r\npDes->FragmentCount = FragmentCount;\r\nreturn Size;\r\n}\r\nstatic void Mds_HeaderCopy(struct wbsoft_priv *adapter, struct wb35_descriptor *pDes, u8 *TargetBuffer)\r\n{\r\nstruct wb35_mds *pMds = &adapter->Mds;\r\nu8 *src_buffer = pDes->buffer_address[0];\r\nstruct T00_descriptor *pT00;\r\nstruct T01_descriptor *pT01;\r\nu16 stmp;\r\nu8 i, ctmp1, ctmp2, ctmpf;\r\nu16 FragmentThreshold = CURRENT_FRAGMENT_THRESHOLD;\r\nstmp = pDes->buffer_total_size;\r\npT00 = (struct T00_descriptor *)TargetBuffer;\r\nTargetBuffer += 4;\r\npT01 = (struct T01_descriptor *)TargetBuffer;\r\nTargetBuffer += 4;\r\npT00->value = 0;\r\npT01->value = 0;\r\npT00->T00_tx_packet_id = pDes->Descriptor_ID;\r\npT00->T00_header_length = 24;\r\npT01->T01_retry_abort_ebable = 1;\r\npT01->T01_wep_id = 0;\r\nFragmentThreshold = DEFAULT_FRAGMENT_THRESHOLD;\r\nmemcpy(TargetBuffer, src_buffer, DOT_11_MAC_HEADER_SIZE);\r\npDes->buffer_address[0] = src_buffer + DOT_11_MAC_HEADER_SIZE;\r\npDes->buffer_total_size -= DOT_11_MAC_HEADER_SIZE;\r\npDes->buffer_size[0] = pDes->buffer_total_size;\r\nFragmentThreshold -= (DOT_11_MAC_HEADER_SIZE + 4);\r\npDes->FragmentThreshold = FragmentThreshold;\r\nTargetBuffer[1] |= 0x04;\r\nstmp = *(u16 *)(TargetBuffer+30);\r\nctmp1 = ctmpf = CURRENT_TX_RATE_FOR_MNG;\r\npDes->TxRate = ctmp1;\r\npr_debug("Tx rate =%x\n", ctmp1);\r\npT01->T01_modulation_type = (ctmp1%3) ? 0 : 1;\r\nfor (i = 0; i < 2; i++) {\r\nif (i == 1)\r\nctmp1 = ctmpf;\r\npMds->TxRate[pDes->Descriptor_ID][i] = ctmp1;\r\nif (ctmp1 == 108)\r\nctmp2 = 7;\r\nelse if (ctmp1 == 96)\r\nctmp2 = 6;\r\nelse if (ctmp1 == 72)\r\nctmp2 = 5;\r\nelse if (ctmp1 == 48)\r\nctmp2 = 4;\r\nelse if (ctmp1 == 36)\r\nctmp2 = 3;\r\nelse if (ctmp1 == 24)\r\nctmp2 = 2;\r\nelse if (ctmp1 == 18)\r\nctmp2 = 1;\r\nelse if (ctmp1 == 12)\r\nctmp2 = 0;\r\nelse if (ctmp1 == 22)\r\nctmp2 = 3;\r\nelse if (ctmp1 == 11)\r\nctmp2 = 2;\r\nelse if (ctmp1 == 4)\r\nctmp2 = 1;\r\nelse\r\nctmp2 = 0;\r\nif (i == 0)\r\npT01->T01_transmit_rate = ctmp2;\r\nelse\r\npT01->T01_fall_back_rate = ctmp2;\r\n}\r\nif ((pT01->T01_modulation_type == 0) && (pT01->T01_transmit_rate == 0))\r\npDes->PreambleMode = WLAN_PREAMBLE_TYPE_LONG;\r\nelse\r\npDes->PreambleMode = CURRENT_PREAMBLE_MODE;\r\npT01->T01_plcp_header_length = pDes->PreambleMode;\r\n}\r\nstatic void MLME_GetNextPacket(struct wbsoft_priv *adapter, struct wb35_descriptor *desc)\r\n{\r\ndesc->InternalUsed = desc->buffer_start_index + desc->buffer_number;\r\ndesc->InternalUsed %= MAX_DESCRIPTOR_BUFFER_INDEX;\r\ndesc->buffer_address[desc->InternalUsed] = adapter->sMlmeFrame.pMMPDU;\r\ndesc->buffer_size[desc->InternalUsed] = adapter->sMlmeFrame.len;\r\ndesc->buffer_total_size += adapter->sMlmeFrame.len;\r\ndesc->buffer_number++;\r\ndesc->Type = adapter->sMlmeFrame.DataType;\r\n}\r\nstatic void MLMEfreeMMPDUBuffer(struct wbsoft_priv *adapter, s8 *pData)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_NUM_TX_MMPDU; i++) {\r\nif (pData == (s8 *)&(adapter->sMlmeFrame.TxMMPDU[i]))\r\nbreak;\r\n}\r\nif (adapter->sMlmeFrame.TxMMPDUInUse[i])\r\nadapter->sMlmeFrame.TxMMPDUInUse[i] = false;\r\nelse {\r\n}\r\n}\r\nstatic void MLME_SendComplete(struct wbsoft_priv *adapter, u8 PacketID, unsigned char SendOK)\r\n{\r\nadapter->sMlmeFrame.len = 0;\r\nMLMEfreeMMPDUBuffer(adapter, adapter->sMlmeFrame.pMMPDU);\r\nadapter->sMlmeFrame.IsInUsed = PACKET_FREE_TO_USE;\r\n}\r\nvoid\r\nMds_Tx(struct wbsoft_priv *adapter)\r\n{\r\nstruct hw_data *pHwData = &adapter->sHwData;\r\nstruct wb35_mds *pMds = &adapter->Mds;\r\nstruct wb35_descriptor TxDes;\r\nstruct wb35_descriptor *pTxDes = &TxDes;\r\nu8 *XmitBufAddress;\r\nu16 XmitBufSize, PacketSize, stmp, CurrentSize, FragmentThreshold;\r\nu8 FillIndex, TxDesIndex, FragmentCount, FillCount;\r\nunsigned char BufferFilled = false;\r\nif (pMds->TxPause)\r\nreturn;\r\nif (!hal_driver_init_OK(pHwData))\r\nreturn;\r\nif (atomic_inc_return(&pMds->TxThreadCount) != 1)\r\ngoto cleanup;\r\ndo {\r\nFillIndex = pMds->TxFillIndex;\r\nif (pMds->TxOwner[FillIndex]) {\r\npr_debug("[Mds_Tx] Tx Owner is H/W.\n");\r\nbreak;\r\n}\r\nXmitBufAddress = pMds->pTxBuffer + (MAX_USB_TX_BUFFER * FillIndex);\r\nXmitBufSize = 0;\r\nFillCount = 0;\r\ndo {\r\nPacketSize = adapter->sMlmeFrame.len;\r\nif (!PacketSize)\r\nbreak;\r\nFragmentThreshold = CURRENT_FRAGMENT_THRESHOLD;\r\nFragmentCount = PacketSize/FragmentThreshold + 1;\r\nstmp = PacketSize + FragmentCount*32 + 8;\r\nif ((XmitBufSize + stmp) >= MAX_USB_TX_BUFFER) {\r\nprintk("[Mds_Tx] Excess max tx buffer.\n");\r\nbreak;\r\n}\r\nBufferFilled = true;\r\nmemset((u8 *)pTxDes + 1, 0, sizeof(struct wb35_descriptor) - 1);\r\nTxDesIndex = pMds->TxDesIndex;\r\npTxDes->Descriptor_ID = TxDesIndex;\r\npMds->TxDesFrom[TxDesIndex] = 2;\r\npMds->TxDesIndex++;\r\npMds->TxDesIndex %= MAX_USB_TX_DESCRIPTOR;\r\nMLME_GetNextPacket(adapter, pTxDes);\r\nMds_HeaderCopy(adapter, pTxDes, XmitBufAddress);\r\nif (pTxDes->EapFix) {\r\npr_debug("35: EPA 4th frame detected. Size = %d\n", PacketSize);\r\npHwData->IsKeyPreSet = 1;\r\n}\r\nCurrentSize = Mds_BodyCopy(adapter, pTxDes, XmitBufAddress);\r\nMds_DurationSet(adapter, pTxDes, XmitBufAddress);\r\nXmitBufSize += CurrentSize;\r\nXmitBufAddress += CurrentSize;\r\nMLME_SendComplete(adapter, 0, true);\r\npMds->TxTsc++;\r\nif (pMds->TxTsc == 0)\r\npMds->TxTsc_2++;\r\nFillCount++;\r\n} while (HAL_USB_MODE_BURST(pHwData));\r\nif (BufferFilled) {\r\npMds->TxBufferSize[FillIndex] = XmitBufSize;\r\npMds->TxCountInBuffer[FillIndex] = FillCount;\r\npMds->TxOwner[FillIndex] = 1;\r\npMds->TxFillIndex++;\r\npMds->TxFillIndex %= MAX_USB_TX_BUFFER_NUMBER;\r\nBufferFilled = false;\r\n} else\r\nbreak;\r\nif (!PacketSize)\r\nbreak;\r\n} while (true);\r\nif (!pHwData->IsKeyPreSet)\r\nWb35Tx_start(adapter);\r\ncleanup:\r\natomic_dec(&pMds->TxThreadCount);\r\n}\r\nvoid\r\nMds_SendComplete(struct wbsoft_priv *adapter, struct T02_descriptor *pT02)\r\n{\r\nstruct wb35_mds *pMds = &adapter->Mds;\r\nstruct hw_data *pHwData = &adapter->sHwData;\r\nu8 PacketId = (u8)pT02->T02_Tx_PktID;\r\nunsigned char SendOK = true;\r\nu8 RetryCount, TxRate;\r\nif (pT02->T02_IgnoreResult)\r\nreturn;\r\nif (pT02->T02_IsLastMpdu) {\r\nTxRate = pMds->TxRate[PacketId][0];\r\nRetryCount = (u8)pT02->T02_MPDU_Cnt;\r\nif (pT02->value & FLAG_ERROR_TX_MASK) {\r\nSendOK = false;\r\nif (pT02->T02_transmit_abort || pT02->T02_out_of_MaxTxMSDULiftTime) {\r\npHwData->dto_tx_retry_count += (RetryCount+1);\r\nif (RetryCount < 7)\r\npHwData->tx_retry_count[RetryCount] += RetryCount;\r\nelse\r\npHwData->tx_retry_count[7] += RetryCount;\r\npr_debug("dto_tx_retry_count =%d\n", pHwData->dto_tx_retry_count);\r\nMTO_SetTxCount(adapter, TxRate, RetryCount);\r\n}\r\npHwData->dto_tx_frag_count += (RetryCount+1);\r\nif (pT02->T02_transmit_abort_due_to_TBTT)\r\npHwData->tx_TBTT_start_count++;\r\nif (pT02->T02_transmit_without_encryption_due_to_wep_on_false)\r\npHwData->tx_WepOn_false_count++;\r\nif (pT02->T02_discard_due_to_null_wep_key)\r\npHwData->tx_Null_key_count++;\r\n} else {\r\nif (pT02->T02_effective_transmission_rate)\r\npHwData->tx_ETR_count++;\r\nMTO_SetTxCount(adapter, TxRate, RetryCount);\r\n}\r\npMds->TxResult[PacketId] = 0;\r\n} else\r\npMds->TxResult[PacketId] |= ((u16)(pT02->value & 0x0ffff));\r\n}
