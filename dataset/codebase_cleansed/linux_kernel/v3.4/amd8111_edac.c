static int edac_pci_read_dword(struct pci_dev *dev, int reg, u32 *val32)\r\n{\r\nint ret;\r\nret = pci_read_config_dword(dev, reg, val32);\r\nif (ret != 0)\r\nprintk(KERN_ERR AMD8111_EDAC_MOD_STR\r\n" PCI Access Read Error at 0x%x\n", reg);\r\nreturn ret;\r\n}\r\nstatic void edac_pci_read_byte(struct pci_dev *dev, int reg, u8 *val8)\r\n{\r\nint ret;\r\nret = pci_read_config_byte(dev, reg, val8);\r\nif (ret != 0)\r\nprintk(KERN_ERR AMD8111_EDAC_MOD_STR\r\n" PCI Access Read Error at 0x%x\n", reg);\r\n}\r\nstatic void edac_pci_write_dword(struct pci_dev *dev, int reg, u32 val32)\r\n{\r\nint ret;\r\nret = pci_write_config_dword(dev, reg, val32);\r\nif (ret != 0)\r\nprintk(KERN_ERR AMD8111_EDAC_MOD_STR\r\n" PCI Access Write Error at 0x%x\n", reg);\r\n}\r\nstatic void edac_pci_write_byte(struct pci_dev *dev, int reg, u8 val8)\r\n{\r\nint ret;\r\nret = pci_write_config_byte(dev, reg, val8);\r\nif (ret != 0)\r\nprintk(KERN_ERR AMD8111_EDAC_MOD_STR\r\n" PCI Access Write Error at 0x%x\n", reg);\r\n}\r\nstatic void amd8111_pci_bridge_init(struct amd8111_pci_info *pci_info)\r\n{\r\nu32 val32;\r\nstruct pci_dev *dev = pci_info->dev;\r\nedac_pci_read_dword(dev, REG_PCI_STSCMD, &val32);\r\nif (val32 & PCI_STSCMD_CLEAR_MASK)\r\nedac_pci_write_dword(dev, REG_PCI_STSCMD, val32);\r\nedac_pci_read_dword(dev, REG_HT_LINK, &val32);\r\nif (val32 & HT_LINK_CLEAR_MASK)\r\nedac_pci_write_dword(dev, REG_HT_LINK, val32);\r\nedac_pci_read_dword(dev, REG_MEM_LIM, &val32);\r\nif (val32 & MEM_LIMIT_CLEAR_MASK)\r\nedac_pci_write_dword(dev, REG_MEM_LIM, val32);\r\nedac_pci_read_dword(dev, REG_PCI_INTBRG_CTRL, &val32);\r\nif (val32 & PCI_INTBRG_CTRL_CLEAR_MASK)\r\nedac_pci_write_dword(dev, REG_PCI_INTBRG_CTRL, val32);\r\nif (edac_op_state == EDAC_OPSTATE_POLL) {\r\nedac_pci_read_dword(dev, REG_PCI_STSCMD, &val32);\r\nval32 |= PCI_STSCMD_SERREN;\r\nedac_pci_write_dword(dev, REG_PCI_STSCMD, val32);\r\nedac_pci_read_dword(dev, REG_HT_LINK, &val32);\r\nval32 |= HT_LINK_CRCFEN;\r\nedac_pci_write_dword(dev, REG_HT_LINK, val32);\r\nedac_pci_read_dword(dev, REG_PCI_INTBRG_CTRL, &val32);\r\nval32 |= PCI_INTBRG_CTRL_POLL_MASK;\r\nedac_pci_write_dword(dev, REG_PCI_INTBRG_CTRL, val32);\r\n}\r\n}\r\nstatic void amd8111_pci_bridge_exit(struct amd8111_pci_info *pci_info)\r\n{\r\nu32 val32;\r\nstruct pci_dev *dev = pci_info->dev;\r\nif (edac_op_state == EDAC_OPSTATE_POLL) {\r\nedac_pci_read_dword(dev, REG_PCI_STSCMD, &val32);\r\nval32 &= ~PCI_STSCMD_SERREN;\r\nedac_pci_write_dword(dev, REG_PCI_STSCMD, val32);\r\nedac_pci_read_dword(dev, REG_HT_LINK, &val32);\r\nval32 &= ~HT_LINK_CRCFEN;\r\nedac_pci_write_dword(dev, REG_HT_LINK, val32);\r\nedac_pci_read_dword(dev, REG_PCI_INTBRG_CTRL, &val32);\r\nval32 &= ~PCI_INTBRG_CTRL_POLL_MASK;\r\nedac_pci_write_dword(dev, REG_PCI_INTBRG_CTRL, val32);\r\n}\r\n}\r\nstatic void amd8111_pci_bridge_check(struct edac_pci_ctl_info *edac_dev)\r\n{\r\nstruct amd8111_pci_info *pci_info = edac_dev->pvt_info;\r\nstruct pci_dev *dev = pci_info->dev;\r\nu32 val32;\r\nedac_pci_read_dword(dev, REG_PCI_STSCMD, &val32);\r\nif (val32 & PCI_STSCMD_CLEAR_MASK) {\r\nprintk(KERN_INFO "Error(s) in PCI bridge status and command"\r\n"register on device %s\n", pci_info->ctl_name);\r\nprintk(KERN_INFO "SSE: %d, RMA: %d, RTA: %d\n",\r\n(val32 & PCI_STSCMD_SSE) != 0,\r\n(val32 & PCI_STSCMD_RMA) != 0,\r\n(val32 & PCI_STSCMD_RTA) != 0);\r\nval32 |= PCI_STSCMD_CLEAR_MASK;\r\nedac_pci_write_dword(dev, REG_PCI_STSCMD, val32);\r\nedac_pci_handle_npe(edac_dev, edac_dev->ctl_name);\r\n}\r\nedac_pci_read_dword(dev, REG_HT_LINK, &val32);\r\nif (val32 & HT_LINK_LKFAIL) {\r\nprintk(KERN_INFO "Error(s) in hypertransport link control"\r\n"register on device %s\n", pci_info->ctl_name);\r\nprintk(KERN_INFO "LKFAIL: %d\n",\r\n(val32 & HT_LINK_LKFAIL) != 0);\r\nval32 |= HT_LINK_LKFAIL;\r\nedac_pci_write_dword(dev, REG_HT_LINK, val32);\r\nedac_pci_handle_npe(edac_dev, edac_dev->ctl_name);\r\n}\r\nedac_pci_read_dword(dev, REG_PCI_INTBRG_CTRL, &val32);\r\nif (val32 & PCI_INTBRG_CTRL_DTSTAT) {\r\nprintk(KERN_INFO "Error(s) in PCI interrupt and bridge control"\r\n"register on device %s\n", pci_info->ctl_name);\r\nprintk(KERN_INFO "DTSTAT: %d\n",\r\n(val32 & PCI_INTBRG_CTRL_DTSTAT) != 0);\r\nval32 |= PCI_INTBRG_CTRL_DTSTAT;\r\nedac_pci_write_dword(dev, REG_PCI_INTBRG_CTRL, val32);\r\nedac_pci_handle_npe(edac_dev, edac_dev->ctl_name);\r\n}\r\nedac_pci_read_dword(dev, REG_MEM_LIM, &val32);\r\nif (val32 & MEM_LIMIT_CLEAR_MASK) {\r\nprintk(KERN_INFO\r\n"Error(s) in mem limit register on %s device\n",\r\npci_info->ctl_name);\r\nprintk(KERN_INFO "DPE: %d, RSE: %d, RMA: %d\n"\r\n"RTA: %d, STA: %d, MDPE: %d\n",\r\n(val32 & MEM_LIMIT_DPE) != 0,\r\n(val32 & MEM_LIMIT_RSE) != 0,\r\n(val32 & MEM_LIMIT_RMA) != 0,\r\n(val32 & MEM_LIMIT_RTA) != 0,\r\n(val32 & MEM_LIMIT_STA) != 0,\r\n(val32 & MEM_LIMIT_MDPE) != 0);\r\nval32 |= MEM_LIMIT_CLEAR_MASK;\r\nedac_pci_write_dword(dev, REG_MEM_LIM, val32);\r\nedac_pci_handle_npe(edac_dev, edac_dev->ctl_name);\r\n}\r\n}\r\nstatic void amd8111_lpc_bridge_init(struct amd8111_dev_info *dev_info)\r\n{\r\nu8 val8;\r\nstruct pci_dev *dev = dev_info->dev;\r\nlegacy_io_res = request_region(REG_AT_COMPAT, LEGACY_NR_PORTS,\r\nAMD8111_EDAC_MOD_STR);\r\nif (!legacy_io_res)\r\nprintk(KERN_INFO "%s: failed to request legacy I/O region "\r\n"start %d, len %d\n", __func__,\r\nREG_AT_COMPAT, LEGACY_NR_PORTS);\r\nelse {\r\nval8 = __do_inb(REG_AT_COMPAT);\r\nif (val8 == 0xff) {\r\nprintk(KERN_INFO "%s: port %d is buggy, not supported"\r\n" by hardware?\n", __func__, REG_AT_COMPAT);\r\nat_compat_reg_broken = 1;\r\nrelease_region(REG_AT_COMPAT, LEGACY_NR_PORTS);\r\nlegacy_io_res = NULL;\r\n} else {\r\nu8 out8 = 0;\r\nif (val8 & AT_COMPAT_SERR)\r\nout8 = AT_COMPAT_CLRSERR;\r\nif (val8 & AT_COMPAT_IOCHK)\r\nout8 |= AT_COMPAT_CLRIOCHK;\r\nif (out8 > 0)\r\n__do_outb(out8, REG_AT_COMPAT);\r\n}\r\n}\r\nedac_pci_read_byte(dev, REG_IO_CTRL_1, &val8);\r\nif (val8 & IO_CTRL_1_CLEAR_MASK)\r\nedac_pci_write_byte(dev, REG_IO_CTRL_1, val8);\r\n}\r\nstatic void amd8111_lpc_bridge_exit(struct amd8111_dev_info *dev_info)\r\n{\r\nif (legacy_io_res)\r\nrelease_region(REG_AT_COMPAT, LEGACY_NR_PORTS);\r\n}\r\nstatic void amd8111_lpc_bridge_check(struct edac_device_ctl_info *edac_dev)\r\n{\r\nstruct amd8111_dev_info *dev_info = edac_dev->pvt_info;\r\nstruct pci_dev *dev = dev_info->dev;\r\nu8 val8;\r\nedac_pci_read_byte(dev, REG_IO_CTRL_1, &val8);\r\nif (val8 & IO_CTRL_1_CLEAR_MASK) {\r\nprintk(KERN_INFO\r\n"Error(s) in IO control register on %s device\n",\r\ndev_info->ctl_name);\r\nprintk(KERN_INFO "LPC ERR: %d, PW2LPC: %d\n",\r\n(val8 & IO_CTRL_1_LPC_ERR) != 0,\r\n(val8 & IO_CTRL_1_PW2LPC) != 0);\r\nval8 |= IO_CTRL_1_CLEAR_MASK;\r\nedac_pci_write_byte(dev, REG_IO_CTRL_1, val8);\r\nedac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);\r\n}\r\nif (at_compat_reg_broken == 0) {\r\nu8 out8 = 0;\r\nval8 = __do_inb(REG_AT_COMPAT);\r\nif (val8 & AT_COMPAT_SERR)\r\nout8 = AT_COMPAT_CLRSERR;\r\nif (val8 & AT_COMPAT_IOCHK)\r\nout8 |= AT_COMPAT_CLRIOCHK;\r\nif (out8 > 0) {\r\n__do_outb(out8, REG_AT_COMPAT);\r\nedac_device_handle_ue(edac_dev, 0, 0,\r\nedac_dev->ctl_name);\r\n}\r\n}\r\n}\r\nstatic int amd8111_dev_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct amd8111_dev_info *dev_info = &amd8111_devices[id->driver_data];\r\ndev_info->dev = pci_get_device(PCI_VENDOR_ID_AMD,\r\ndev_info->err_dev, NULL);\r\nif (!dev_info->dev) {\r\nprintk(KERN_ERR "EDAC device not found:"\r\n"vendor %x, device %x, name %s\n",\r\nPCI_VENDOR_ID_AMD, dev_info->err_dev,\r\ndev_info->ctl_name);\r\nreturn -ENODEV;\r\n}\r\nif (pci_enable_device(dev_info->dev)) {\r\npci_dev_put(dev_info->dev);\r\nprintk(KERN_ERR "failed to enable:"\r\n"vendor %x, device %x, name %s\n",\r\nPCI_VENDOR_ID_AMD, dev_info->err_dev,\r\ndev_info->ctl_name);\r\nreturn -ENODEV;\r\n}\r\ndev_info->edac_idx = edac_device_alloc_index();\r\ndev_info->edac_dev =\r\nedac_device_alloc_ctl_info(0, dev_info->ctl_name, 1,\r\nNULL, 0, 0,\r\nNULL, 0, dev_info->edac_idx);\r\nif (!dev_info->edac_dev)\r\nreturn -ENOMEM;\r\ndev_info->edac_dev->pvt_info = dev_info;\r\ndev_info->edac_dev->dev = &dev_info->dev->dev;\r\ndev_info->edac_dev->mod_name = AMD8111_EDAC_MOD_STR;\r\ndev_info->edac_dev->ctl_name = dev_info->ctl_name;\r\ndev_info->edac_dev->dev_name = dev_name(&dev_info->dev->dev);\r\nif (edac_op_state == EDAC_OPSTATE_POLL)\r\ndev_info->edac_dev->edac_check = dev_info->check;\r\nif (dev_info->init)\r\ndev_info->init(dev_info);\r\nif (edac_device_add_device(dev_info->edac_dev) > 0) {\r\nprintk(KERN_ERR "failed to add edac_dev for %s\n",\r\ndev_info->ctl_name);\r\nedac_device_free_ctl_info(dev_info->edac_dev);\r\nreturn -ENODEV;\r\n}\r\nprintk(KERN_INFO "added one edac_dev on AMD8111 "\r\n"vendor %x, device %x, name %s\n",\r\nPCI_VENDOR_ID_AMD, dev_info->err_dev,\r\ndev_info->ctl_name);\r\nreturn 0;\r\n}\r\nstatic void amd8111_dev_remove(struct pci_dev *dev)\r\n{\r\nstruct amd8111_dev_info *dev_info;\r\nfor (dev_info = amd8111_devices; dev_info->err_dev; dev_info++)\r\nif (dev_info->dev->device == dev->device)\r\nbreak;\r\nif (!dev_info->err_dev)\r\nreturn;\r\nif (dev_info->edac_dev) {\r\nedac_device_del_device(dev_info->edac_dev->dev);\r\nedac_device_free_ctl_info(dev_info->edac_dev);\r\n}\r\nif (dev_info->exit)\r\ndev_info->exit(dev_info);\r\npci_dev_put(dev_info->dev);\r\n}\r\nstatic int amd8111_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct amd8111_pci_info *pci_info = &amd8111_pcis[id->driver_data];\r\npci_info->dev = pci_get_device(PCI_VENDOR_ID_AMD,\r\npci_info->err_dev, NULL);\r\nif (!pci_info->dev) {\r\nprintk(KERN_ERR "EDAC device not found:"\r\n"vendor %x, device %x, name %s\n",\r\nPCI_VENDOR_ID_AMD, pci_info->err_dev,\r\npci_info->ctl_name);\r\nreturn -ENODEV;\r\n}\r\nif (pci_enable_device(pci_info->dev)) {\r\npci_dev_put(pci_info->dev);\r\nprintk(KERN_ERR "failed to enable:"\r\n"vendor %x, device %x, name %s\n",\r\nPCI_VENDOR_ID_AMD, pci_info->err_dev,\r\npci_info->ctl_name);\r\nreturn -ENODEV;\r\n}\r\npci_info->edac_idx = edac_pci_alloc_index();\r\npci_info->edac_dev = edac_pci_alloc_ctl_info(0, pci_info->ctl_name);\r\nif (!pci_info->edac_dev)\r\nreturn -ENOMEM;\r\npci_info->edac_dev->pvt_info = pci_info;\r\npci_info->edac_dev->dev = &pci_info->dev->dev;\r\npci_info->edac_dev->mod_name = AMD8111_EDAC_MOD_STR;\r\npci_info->edac_dev->ctl_name = pci_info->ctl_name;\r\npci_info->edac_dev->dev_name = dev_name(&pci_info->dev->dev);\r\nif (edac_op_state == EDAC_OPSTATE_POLL)\r\npci_info->edac_dev->edac_check = pci_info->check;\r\nif (pci_info->init)\r\npci_info->init(pci_info);\r\nif (edac_pci_add_device(pci_info->edac_dev, pci_info->edac_idx) > 0) {\r\nprintk(KERN_ERR "failed to add edac_pci for %s\n",\r\npci_info->ctl_name);\r\nedac_pci_free_ctl_info(pci_info->edac_dev);\r\nreturn -ENODEV;\r\n}\r\nprintk(KERN_INFO "added one edac_pci on AMD8111 "\r\n"vendor %x, device %x, name %s\n",\r\nPCI_VENDOR_ID_AMD, pci_info->err_dev,\r\npci_info->ctl_name);\r\nreturn 0;\r\n}\r\nstatic void amd8111_pci_remove(struct pci_dev *dev)\r\n{\r\nstruct amd8111_pci_info *pci_info;\r\nfor (pci_info = amd8111_pcis; pci_info->err_dev; pci_info++)\r\nif (pci_info->dev->device == dev->device)\r\nbreak;\r\nif (!pci_info->err_dev)\r\nreturn;\r\nif (pci_info->edac_dev) {\r\nedac_pci_del_device(pci_info->edac_dev->dev);\r\nedac_pci_free_ctl_info(pci_info->edac_dev);\r\n}\r\nif (pci_info->exit)\r\npci_info->exit(pci_info);\r\npci_dev_put(pci_info->dev);\r\n}\r\nstatic int __init amd8111_edac_init(void)\r\n{\r\nint val;\r\nprintk(KERN_INFO "AMD8111 EDAC driver " AMD8111_EDAC_REVISION "\n");\r\nprintk(KERN_INFO "\t(c) 2008 Wind River Systems, Inc.\n");\r\nedac_op_state = EDAC_OPSTATE_POLL;\r\nval = pci_register_driver(&amd8111_edac_dev_driver);\r\nval |= pci_register_driver(&amd8111_edac_pci_driver);\r\nreturn val;\r\n}\r\nstatic void __exit amd8111_edac_exit(void)\r\n{\r\npci_unregister_driver(&amd8111_edac_pci_driver);\r\npci_unregister_driver(&amd8111_edac_dev_driver);\r\n}
