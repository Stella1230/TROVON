static int read_method_int(acpi_handle handle, const char *method, int *val)\r\n{\r\nacpi_status status;\r\nunsigned long long result;\r\nstatus = acpi_evaluate_integer(handle, (char *)method, NULL, &result);\r\nif (ACPI_FAILURE(status)) {\r\n*val = -1;\r\nreturn -1;\r\n} else {\r\n*val = result;\r\nreturn 0;\r\n}\r\n}\r\nstatic int method_vpcr(acpi_handle handle, int cmd, int *ret)\r\n{\r\nacpi_status status;\r\nunsigned long long result;\r\nstruct acpi_object_list params;\r\nunion acpi_object in_obj;\r\nparams.count = 1;\r\nparams.pointer = &in_obj;\r\nin_obj.type = ACPI_TYPE_INTEGER;\r\nin_obj.integer.value = cmd;\r\nstatus = acpi_evaluate_integer(handle, "VPCR", &params, &result);\r\nif (ACPI_FAILURE(status)) {\r\n*ret = -1;\r\nreturn -1;\r\n} else {\r\n*ret = result;\r\nreturn 0;\r\n}\r\n}\r\nstatic int method_vpcw(acpi_handle handle, int cmd, int data)\r\n{\r\nstruct acpi_object_list params;\r\nunion acpi_object in_obj[2];\r\nacpi_status status;\r\nparams.count = 2;\r\nparams.pointer = in_obj;\r\nin_obj[0].type = ACPI_TYPE_INTEGER;\r\nin_obj[0].integer.value = cmd;\r\nin_obj[1].type = ACPI_TYPE_INTEGER;\r\nin_obj[1].integer.value = data;\r\nstatus = acpi_evaluate_object(handle, "VPCW", &params, NULL);\r\nif (status != AE_OK)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int read_ec_data(acpi_handle handle, int cmd, unsigned long *data)\r\n{\r\nint val;\r\nunsigned long int end_jiffies;\r\nif (method_vpcw(handle, 1, cmd))\r\nreturn -1;\r\nfor (end_jiffies = jiffies+(HZ)*IDEAPAD_EC_TIMEOUT/1000+1;\r\ntime_before(jiffies, end_jiffies);) {\r\nschedule();\r\nif (method_vpcr(handle, 1, &val))\r\nreturn -1;\r\nif (val == 0) {\r\nif (method_vpcr(handle, 0, &val))\r\nreturn -1;\r\n*data = val;\r\nreturn 0;\r\n}\r\n}\r\npr_err("timeout in read_ec_cmd\n");\r\nreturn -1;\r\n}\r\nstatic int write_ec_cmd(acpi_handle handle, int cmd, unsigned long data)\r\n{\r\nint val;\r\nunsigned long int end_jiffies;\r\nif (method_vpcw(handle, 0, data))\r\nreturn -1;\r\nif (method_vpcw(handle, 1, cmd))\r\nreturn -1;\r\nfor (end_jiffies = jiffies+(HZ)*IDEAPAD_EC_TIMEOUT/1000+1;\r\ntime_before(jiffies, end_jiffies);) {\r\nschedule();\r\nif (method_vpcr(handle, 1, &val))\r\nreturn -1;\r\nif (val == 0)\r\nreturn 0;\r\n}\r\npr_err("timeout in write_ec_cmd\n");\r\nreturn -1;\r\n}\r\nstatic int debugfs_status_show(struct seq_file *s, void *data)\r\n{\r\nunsigned long value;\r\nif (!read_ec_data(ideapad_handle, VPCCMD_R_BL_MAX, &value))\r\nseq_printf(s, "Backlight max:\t%lu\n", value);\r\nif (!read_ec_data(ideapad_handle, VPCCMD_R_BL, &value))\r\nseq_printf(s, "Backlight now:\t%lu\n", value);\r\nif (!read_ec_data(ideapad_handle, VPCCMD_R_BL_POWER, &value))\r\nseq_printf(s, "BL power value:\t%s\n", value ? "On" : "Off");\r\nseq_printf(s, "=====================\n");\r\nif (!read_ec_data(ideapad_handle, VPCCMD_R_RF, &value))\r\nseq_printf(s, "Radio status:\t%s(%lu)\n",\r\nvalue ? "On" : "Off", value);\r\nif (!read_ec_data(ideapad_handle, VPCCMD_R_WIFI, &value))\r\nseq_printf(s, "Wifi status:\t%s(%lu)\n",\r\nvalue ? "On" : "Off", value);\r\nif (!read_ec_data(ideapad_handle, VPCCMD_R_BT, &value))\r\nseq_printf(s, "BT status:\t%s(%lu)\n",\r\nvalue ? "On" : "Off", value);\r\nif (!read_ec_data(ideapad_handle, VPCCMD_R_3G, &value))\r\nseq_printf(s, "3G status:\t%s(%lu)\n",\r\nvalue ? "On" : "Off", value);\r\nseq_printf(s, "=====================\n");\r\nif (!read_ec_data(ideapad_handle, VPCCMD_R_TOUCHPAD, &value))\r\nseq_printf(s, "Touchpad status:%s(%lu)\n",\r\nvalue ? "On" : "Off", value);\r\nif (!read_ec_data(ideapad_handle, VPCCMD_R_CAMERA, &value))\r\nseq_printf(s, "Camera status:\t%s(%lu)\n",\r\nvalue ? "On" : "Off", value);\r\nreturn 0;\r\n}\r\nstatic int debugfs_status_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, debugfs_status_show, NULL);\r\n}\r\nstatic int debugfs_cfg_show(struct seq_file *s, void *data)\r\n{\r\nif (!ideapad_priv) {\r\nseq_printf(s, "cfg: N/A\n");\r\n} else {\r\nseq_printf(s, "cfg: 0x%.8lX\n\nCapability: ",\r\nideapad_priv->cfg);\r\nif (test_bit(CFG_BT_BIT, &ideapad_priv->cfg))\r\nseq_printf(s, "Bluetooth ");\r\nif (test_bit(CFG_3G_BIT, &ideapad_priv->cfg))\r\nseq_printf(s, "3G ");\r\nif (test_bit(CFG_WIFI_BIT, &ideapad_priv->cfg))\r\nseq_printf(s, "Wireless ");\r\nif (test_bit(CFG_CAMERA_BIT, &ideapad_priv->cfg))\r\nseq_printf(s, "Camera ");\r\nseq_printf(s, "\nGraphic: ");\r\nswitch ((ideapad_priv->cfg)&0x700) {\r\ncase 0x100:\r\nseq_printf(s, "Intel");\r\nbreak;\r\ncase 0x200:\r\nseq_printf(s, "ATI");\r\nbreak;\r\ncase 0x300:\r\nseq_printf(s, "Nvidia");\r\nbreak;\r\ncase 0x400:\r\nseq_printf(s, "Intel and ATI");\r\nbreak;\r\ncase 0x500:\r\nseq_printf(s, "Intel and Nvidia");\r\nbreak;\r\n}\r\nseq_printf(s, "\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int debugfs_cfg_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, debugfs_cfg_show, NULL);\r\n}\r\nstatic int __devinit ideapad_debugfs_init(struct ideapad_private *priv)\r\n{\r\nstruct dentry *node;\r\npriv->debug = debugfs_create_dir("ideapad", NULL);\r\nif (priv->debug == NULL) {\r\npr_err("failed to create debugfs directory");\r\ngoto errout;\r\n}\r\nnode = debugfs_create_file("cfg", S_IRUGO, priv->debug, NULL,\r\n&debugfs_cfg_fops);\r\nif (!node) {\r\npr_err("failed to create cfg in debugfs");\r\ngoto errout;\r\n}\r\nnode = debugfs_create_file("status", S_IRUGO, priv->debug, NULL,\r\n&debugfs_status_fops);\r\nif (!node) {\r\npr_err("failed to create event in debugfs");\r\ngoto errout;\r\n}\r\nreturn 0;\r\nerrout:\r\nreturn -ENOMEM;\r\n}\r\nstatic void ideapad_debugfs_exit(struct ideapad_private *priv)\r\n{\r\ndebugfs_remove_recursive(priv->debug);\r\npriv->debug = NULL;\r\n}\r\nstatic ssize_t show_ideapad_cam(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long result;\r\nif (read_ec_data(ideapad_handle, VPCCMD_R_CAMERA, &result))\r\nreturn sprintf(buf, "-1\n");\r\nreturn sprintf(buf, "%lu\n", result);\r\n}\r\nstatic ssize_t store_ideapad_cam(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret, state;\r\nif (!count)\r\nreturn 0;\r\nif (sscanf(buf, "%i", &state) != 1)\r\nreturn -EINVAL;\r\nret = write_ec_cmd(ideapad_handle, VPCCMD_W_CAMERA, state);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic umode_t ideapad_is_visible(struct kobject *kobj,\r\nstruct attribute *attr,\r\nint idx)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct ideapad_private *priv = dev_get_drvdata(dev);\r\nbool supported;\r\nif (attr == &dev_attr_camera_power.attr)\r\nsupported = test_bit(CFG_CAMERA_BIT, &(priv->cfg));\r\nelse\r\nsupported = true;\r\nreturn supported ? attr->mode : 0;\r\n}\r\nstatic int ideapad_rfk_set(void *data, bool blocked)\r\n{\r\nunsigned long opcode = (unsigned long)data;\r\nreturn write_ec_cmd(ideapad_handle, opcode, !blocked);\r\n}\r\nstatic void ideapad_sync_rfk_state(struct ideapad_private *priv)\r\n{\r\nunsigned long hw_blocked;\r\nint i;\r\nif (read_ec_data(ideapad_handle, VPCCMD_R_RF, &hw_blocked))\r\nreturn;\r\nhw_blocked = !hw_blocked;\r\nfor (i = 0; i < IDEAPAD_RFKILL_DEV_NUM; i++)\r\nif (priv->rfk[i])\r\nrfkill_set_hw_state(priv->rfk[i], hw_blocked);\r\n}\r\nstatic int __devinit ideapad_register_rfkill(struct acpi_device *adevice,\r\nint dev)\r\n{\r\nstruct ideapad_private *priv = dev_get_drvdata(&adevice->dev);\r\nint ret;\r\nunsigned long sw_blocked;\r\nif (no_bt_rfkill &&\r\n(ideapad_rfk_data[dev].type == RFKILL_TYPE_BLUETOOTH)) {\r\nwrite_ec_cmd(ideapad_handle,\r\nideapad_rfk_data[dev].opcode, 1);\r\nreturn 0;\r\n}\r\npriv->rfk[dev] = rfkill_alloc(ideapad_rfk_data[dev].name, &adevice->dev,\r\nideapad_rfk_data[dev].type, &ideapad_rfk_ops,\r\n(void *)(long)dev);\r\nif (!priv->rfk[dev])\r\nreturn -ENOMEM;\r\nif (read_ec_data(ideapad_handle, ideapad_rfk_data[dev].opcode-1,\r\n&sw_blocked)) {\r\nrfkill_init_sw_state(priv->rfk[dev], 0);\r\n} else {\r\nsw_blocked = !sw_blocked;\r\nrfkill_init_sw_state(priv->rfk[dev], sw_blocked);\r\n}\r\nret = rfkill_register(priv->rfk[dev]);\r\nif (ret) {\r\nrfkill_destroy(priv->rfk[dev]);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ideapad_unregister_rfkill(struct acpi_device *adevice, int dev)\r\n{\r\nstruct ideapad_private *priv = dev_get_drvdata(&adevice->dev);\r\nif (!priv->rfk[dev])\r\nreturn;\r\nrfkill_unregister(priv->rfk[dev]);\r\nrfkill_destroy(priv->rfk[dev]);\r\n}\r\nstatic int __devinit ideapad_platform_init(struct ideapad_private *priv)\r\n{\r\nint result;\r\npriv->platform_device = platform_device_alloc("ideapad", -1);\r\nif (!priv->platform_device)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(priv->platform_device, priv);\r\nresult = platform_device_add(priv->platform_device);\r\nif (result)\r\ngoto fail_platform_device;\r\nresult = sysfs_create_group(&priv->platform_device->dev.kobj,\r\n&ideapad_attribute_group);\r\nif (result)\r\ngoto fail_sysfs;\r\nreturn 0;\r\nfail_sysfs:\r\nplatform_device_del(priv->platform_device);\r\nfail_platform_device:\r\nplatform_device_put(priv->platform_device);\r\nreturn result;\r\n}\r\nstatic void ideapad_platform_exit(struct ideapad_private *priv)\r\n{\r\nsysfs_remove_group(&priv->platform_device->dev.kobj,\r\n&ideapad_attribute_group);\r\nplatform_device_unregister(priv->platform_device);\r\n}\r\nstatic int __devinit ideapad_input_init(struct ideapad_private *priv)\r\n{\r\nstruct input_dev *inputdev;\r\nint error;\r\ninputdev = input_allocate_device();\r\nif (!inputdev) {\r\npr_info("Unable to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\ninputdev->name = "Ideapad extra buttons";\r\ninputdev->phys = "ideapad/input0";\r\ninputdev->id.bustype = BUS_HOST;\r\ninputdev->dev.parent = &priv->platform_device->dev;\r\nerror = sparse_keymap_setup(inputdev, ideapad_keymap, NULL);\r\nif (error) {\r\npr_err("Unable to setup input device keymap\n");\r\ngoto err_free_dev;\r\n}\r\nerror = input_register_device(inputdev);\r\nif (error) {\r\npr_err("Unable to register input device\n");\r\ngoto err_free_keymap;\r\n}\r\npriv->inputdev = inputdev;\r\nreturn 0;\r\nerr_free_keymap:\r\nsparse_keymap_free(inputdev);\r\nerr_free_dev:\r\ninput_free_device(inputdev);\r\nreturn error;\r\n}\r\nstatic void ideapad_input_exit(struct ideapad_private *priv)\r\n{\r\nsparse_keymap_free(priv->inputdev);\r\ninput_unregister_device(priv->inputdev);\r\npriv->inputdev = NULL;\r\n}\r\nstatic void ideapad_input_report(struct ideapad_private *priv,\r\nunsigned long scancode)\r\n{\r\nsparse_keymap_report_event(priv->inputdev, scancode, 1, true);\r\n}\r\nstatic void ideapad_input_novokey(struct ideapad_private *priv)\r\n{\r\nunsigned long long_pressed;\r\nif (read_ec_data(ideapad_handle, VPCCMD_R_NOVO, &long_pressed))\r\nreturn;\r\nif (long_pressed)\r\nideapad_input_report(priv, 17);\r\nelse\r\nideapad_input_report(priv, 16);\r\n}\r\nstatic int ideapad_backlight_get_brightness(struct backlight_device *blightdev)\r\n{\r\nunsigned long now;\r\nif (read_ec_data(ideapad_handle, VPCCMD_R_BL, &now))\r\nreturn -EIO;\r\nreturn now;\r\n}\r\nstatic int ideapad_backlight_update_status(struct backlight_device *blightdev)\r\n{\r\nif (write_ec_cmd(ideapad_handle, VPCCMD_W_BL,\r\nblightdev->props.brightness))\r\nreturn -EIO;\r\nif (write_ec_cmd(ideapad_handle, VPCCMD_W_BL_POWER,\r\nblightdev->props.power == FB_BLANK_POWERDOWN ? 0 : 1))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int ideapad_backlight_init(struct ideapad_private *priv)\r\n{\r\nstruct backlight_device *blightdev;\r\nstruct backlight_properties props;\r\nunsigned long max, now, power;\r\nif (read_ec_data(ideapad_handle, VPCCMD_R_BL_MAX, &max))\r\nreturn -EIO;\r\nif (read_ec_data(ideapad_handle, VPCCMD_R_BL, &now))\r\nreturn -EIO;\r\nif (read_ec_data(ideapad_handle, VPCCMD_R_BL_POWER, &power))\r\nreturn -EIO;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.max_brightness = max;\r\nprops.type = BACKLIGHT_PLATFORM;\r\nblightdev = backlight_device_register("ideapad",\r\n&priv->platform_device->dev,\r\npriv,\r\n&ideapad_backlight_ops,\r\n&props);\r\nif (IS_ERR(blightdev)) {\r\npr_err("Could not register backlight device\n");\r\nreturn PTR_ERR(blightdev);\r\n}\r\npriv->blightdev = blightdev;\r\nblightdev->props.brightness = now;\r\nblightdev->props.power = power ? FB_BLANK_UNBLANK : FB_BLANK_POWERDOWN;\r\nbacklight_update_status(blightdev);\r\nreturn 0;\r\n}\r\nstatic void ideapad_backlight_exit(struct ideapad_private *priv)\r\n{\r\nif (priv->blightdev)\r\nbacklight_device_unregister(priv->blightdev);\r\npriv->blightdev = NULL;\r\n}\r\nstatic void ideapad_backlight_notify_power(struct ideapad_private *priv)\r\n{\r\nunsigned long power;\r\nstruct backlight_device *blightdev = priv->blightdev;\r\nif (!blightdev)\r\nreturn;\r\nif (read_ec_data(ideapad_handle, VPCCMD_R_BL_POWER, &power))\r\nreturn;\r\nblightdev->props.power = power ? FB_BLANK_UNBLANK : FB_BLANK_POWERDOWN;\r\n}\r\nstatic void ideapad_backlight_notify_brightness(struct ideapad_private *priv)\r\n{\r\nunsigned long now;\r\nif (priv->blightdev == NULL) {\r\nread_ec_data(ideapad_handle, VPCCMD_R_BL, &now);\r\nreturn;\r\n}\r\nbacklight_force_update(priv->blightdev, BACKLIGHT_UPDATE_HOTKEY);\r\n}\r\nstatic int __devinit ideapad_acpi_add(struct acpi_device *adevice)\r\n{\r\nint ret, i;\r\nunsigned long cfg;\r\nstruct ideapad_private *priv;\r\nif (read_method_int(adevice->handle, "_CFG", (int *)&cfg))\r\nreturn -ENODEV;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&adevice->dev, priv);\r\nideapad_priv = priv;\r\nideapad_handle = adevice->handle;\r\npriv->cfg = cfg;\r\nret = ideapad_platform_init(priv);\r\nif (ret)\r\ngoto platform_failed;\r\nret = ideapad_debugfs_init(priv);\r\nif (ret)\r\ngoto debugfs_failed;\r\nret = ideapad_input_init(priv);\r\nif (ret)\r\ngoto input_failed;\r\nfor (i = 0; i < IDEAPAD_RFKILL_DEV_NUM; i++) {\r\nif (test_bit(ideapad_rfk_data[i].cfgbit, &cfg))\r\nideapad_register_rfkill(adevice, i);\r\nelse\r\npriv->rfk[i] = NULL;\r\n}\r\nideapad_sync_rfk_state(priv);\r\nif (!acpi_video_backlight_support()) {\r\nret = ideapad_backlight_init(priv);\r\nif (ret && ret != -ENODEV)\r\ngoto backlight_failed;\r\n}\r\nreturn 0;\r\nbacklight_failed:\r\nfor (i = 0; i < IDEAPAD_RFKILL_DEV_NUM; i++)\r\nideapad_unregister_rfkill(adevice, i);\r\nideapad_input_exit(priv);\r\ninput_failed:\r\nideapad_debugfs_exit(priv);\r\ndebugfs_failed:\r\nideapad_platform_exit(priv);\r\nplatform_failed:\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nstatic int __devexit ideapad_acpi_remove(struct acpi_device *adevice, int type)\r\n{\r\nstruct ideapad_private *priv = dev_get_drvdata(&adevice->dev);\r\nint i;\r\nideapad_backlight_exit(priv);\r\nfor (i = 0; i < IDEAPAD_RFKILL_DEV_NUM; i++)\r\nideapad_unregister_rfkill(adevice, i);\r\nideapad_input_exit(priv);\r\nideapad_debugfs_exit(priv);\r\nideapad_platform_exit(priv);\r\ndev_set_drvdata(&adevice->dev, NULL);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic void ideapad_acpi_notify(struct acpi_device *adevice, u32 event)\r\n{\r\nstruct ideapad_private *priv = dev_get_drvdata(&adevice->dev);\r\nacpi_handle handle = adevice->handle;\r\nunsigned long vpc1, vpc2, vpc_bit;\r\nif (read_ec_data(handle, VPCCMD_R_VPC1, &vpc1))\r\nreturn;\r\nif (read_ec_data(handle, VPCCMD_R_VPC2, &vpc2))\r\nreturn;\r\nvpc1 = (vpc2 << 8) | vpc1;\r\nfor (vpc_bit = 0; vpc_bit < 16; vpc_bit++) {\r\nif (test_bit(vpc_bit, &vpc1)) {\r\nswitch (vpc_bit) {\r\ncase 9:\r\nideapad_sync_rfk_state(priv);\r\nbreak;\r\ncase 4:\r\nideapad_backlight_notify_brightness(priv);\r\nbreak;\r\ncase 3:\r\nideapad_input_novokey(priv);\r\nbreak;\r\ncase 2:\r\nideapad_backlight_notify_power(priv);\r\nbreak;\r\ndefault:\r\nideapad_input_report(priv, vpc_bit);\r\n}\r\n}\r\n}\r\n}\r\nstatic int __init ideapad_acpi_module_init(void)\r\n{\r\nreturn acpi_bus_register_driver(&ideapad_acpi_driver);\r\n}\r\nstatic void __exit ideapad_acpi_module_exit(void)\r\n{\r\nacpi_bus_unregister_driver(&ideapad_acpi_driver);\r\n}
