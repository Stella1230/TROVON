static int write_reg(struct stir_cb *stir, __u16 reg, __u8 value)\r\n{\r\nstruct usb_device *dev = stir->usbdev;\r\npr_debug("%s: write reg %d = 0x%x\n",\r\nstir->netdev->name, reg, value);\r\nreturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nREQ_WRITE_SINGLE,\r\nUSB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_DEVICE,\r\nvalue, reg, NULL, 0,\r\nCTRL_TIMEOUT);\r\n}\r\nstatic inline int read_reg(struct stir_cb *stir, __u16 reg,\r\n__u8 *data, __u16 count)\r\n{\r\nstruct usb_device *dev = stir->usbdev;\r\nreturn usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\nREQ_READ_REG,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, reg, data, count,\r\nCTRL_TIMEOUT);\r\n}\r\nstatic inline int isfir(u32 speed)\r\n{\r\nreturn speed == 4000000;\r\n}\r\nstatic inline __u8 *stuff_fir(__u8 *p, __u8 c)\r\n{\r\nswitch(c) {\r\ncase 0x7d:\r\ncase 0x7e:\r\ncase 0x7f:\r\n*p++ = 0x7d;\r\nc ^= IRDA_TRANS;\r\ndefault:\r\n*p++ = c;\r\n}\r\nreturn p;\r\n}\r\nstatic unsigned wrap_fir_skb(const struct sk_buff *skb, __u8 *buf)\r\n{\r\n__u8 *ptr = buf;\r\n__u32 fcs = ~(crc32_le(~0, skb->data, skb->len));\r\n__u16 wraplen;\r\nint i;\r\nbuf[0] = 0x55;\r\nbuf[1] = 0xAA;\r\nptr = buf + STIR_IRDA_HEADER;\r\nmemset(ptr, 0x7f, 16);\r\nptr += 16;\r\n*ptr++ = 0x7e;\r\n*ptr++ = 0x7e;\r\nfor (i = 0; i < skb->len; i++)\r\nptr = stuff_fir(ptr, skb->data[i]);\r\nptr = stuff_fir(ptr, fcs & 0xff);\r\nptr = stuff_fir(ptr, (fcs >> 8) & 0xff);\r\nptr = stuff_fir(ptr, (fcs >> 16) & 0xff);\r\nptr = stuff_fir(ptr, (fcs >> 24) & 0xff);\r\n*ptr++ = 0x7e;\r\n*ptr++ = 0x7e;\r\nwraplen = (ptr - buf) - STIR_IRDA_HEADER;\r\nbuf[2] = wraplen & 0xff;\r\nbuf[3] = (wraplen >> 8) & 0xff;\r\nreturn wraplen + STIR_IRDA_HEADER;\r\n}\r\nstatic unsigned wrap_sir_skb(struct sk_buff *skb, __u8 *buf)\r\n{\r\n__u16 wraplen;\r\nwraplen = async_wrap_skb(skb, buf + STIR_IRDA_HEADER,\r\nSTIR_FIFO_SIZE - STIR_IRDA_HEADER);\r\nbuf[0] = 0x55;\r\nbuf[1] = 0xAA;\r\nbuf[2] = wraplen & 0xff;\r\nbuf[3] = (wraplen >> 8) & 0xff;\r\nreturn wraplen + STIR_IRDA_HEADER;\r\n}\r\nstatic void fir_eof(struct stir_cb *stir)\r\n{\r\niobuff_t *rx_buff = &stir->rx_buff;\r\nint len = rx_buff->len - 4;\r\nstruct sk_buff *skb, *nskb;\r\n__u32 fcs;\r\nif (unlikely(len <= 0)) {\r\npr_debug("%s: short frame len %d\n",\r\nstir->netdev->name, len);\r\n++stir->netdev->stats.rx_errors;\r\n++stir->netdev->stats.rx_length_errors;\r\nreturn;\r\n}\r\nfcs = ~(crc32_le(~0, rx_buff->data, len));\r\nif (fcs != get_unaligned_le32(rx_buff->data + len)) {\r\npr_debug("crc error calc 0x%x len %d\n", fcs, len);\r\nstir->netdev->stats.rx_errors++;\r\nstir->netdev->stats.rx_crc_errors++;\r\nreturn;\r\n}\r\nif (len < IRDA_RX_COPY_THRESHOLD) {\r\nnskb = dev_alloc_skb(len + 1);\r\nif (unlikely(!nskb)) {\r\n++stir->netdev->stats.rx_dropped;\r\nreturn;\r\n}\r\nskb_reserve(nskb, 1);\r\nskb = nskb;\r\nskb_copy_to_linear_data(nskb, rx_buff->data, len);\r\n} else {\r\nnskb = dev_alloc_skb(rx_buff->truesize);\r\nif (unlikely(!nskb)) {\r\n++stir->netdev->stats.rx_dropped;\r\nreturn;\r\n}\r\nskb_reserve(nskb, 1);\r\nskb = rx_buff->skb;\r\nrx_buff->skb = nskb;\r\nrx_buff->head = nskb->data;\r\n}\r\nskb_put(skb, len);\r\nskb_reset_mac_header(skb);\r\nskb->protocol = htons(ETH_P_IRDA);\r\nskb->dev = stir->netdev;\r\nnetif_rx(skb);\r\nstir->netdev->stats.rx_packets++;\r\nstir->netdev->stats.rx_bytes += len;\r\nrx_buff->data = rx_buff->head;\r\nrx_buff->len = 0;\r\n}\r\nstatic void stir_fir_chars(struct stir_cb *stir,\r\nconst __u8 *bytes, int len)\r\n{\r\niobuff_t *rx_buff = &stir->rx_buff;\r\nint i;\r\nfor (i = 0; i < len; i++) {\r\n__u8 byte = bytes[i];\r\nswitch(rx_buff->state) {\r\ncase OUTSIDE_FRAME:\r\nif (unlikely(byte != FIR_EOF))\r\ncontinue;\r\nrx_buff->state = BEGIN_FRAME;\r\nrx_buff->data = rx_buff->head;\r\nrx_buff->len = 0;\r\ncontinue;\r\ncase LINK_ESCAPE:\r\nif (byte == FIR_EOF) {\r\npr_debug("%s: got EOF after escape\n",\r\nstir->netdev->name);\r\ngoto frame_error;\r\n}\r\nrx_buff->state = INSIDE_FRAME;\r\nbyte ^= IRDA_TRANS;\r\nbreak;\r\ncase BEGIN_FRAME:\r\nif (byte == FIR_EOF)\r\ncontinue;\r\nrx_buff->state = INSIDE_FRAME;\r\nrx_buff->in_frame = TRUE;\r\ncase INSIDE_FRAME:\r\nswitch(byte) {\r\ncase FIR_CE:\r\nrx_buff->state = LINK_ESCAPE;\r\ncontinue;\r\ncase FIR_XBOF:\r\npr_debug("%s: got XBOF without escape\n",\r\nstir->netdev->name);\r\ngoto frame_error;\r\ncase FIR_EOF:\r\nrx_buff->state = OUTSIDE_FRAME;\r\nrx_buff->in_frame = FALSE;\r\nfir_eof(stir);\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nif (unlikely(rx_buff->len >= rx_buff->truesize)) {\r\npr_debug("%s: fir frame exceeds %d\n",\r\nstir->netdev->name, rx_buff->truesize);\r\n++stir->netdev->stats.rx_over_errors;\r\ngoto error_recovery;\r\n}\r\nrx_buff->data[rx_buff->len++] = byte;\r\ncontinue;\r\nframe_error:\r\n++stir->netdev->stats.rx_frame_errors;\r\nerror_recovery:\r\n++stir->netdev->stats.rx_errors;\r\nrx_buff->state = OUTSIDE_FRAME;\r\nrx_buff->in_frame = FALSE;\r\n}\r\n}\r\nstatic void stir_sir_chars(struct stir_cb *stir,\r\nconst __u8 *bytes, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nasync_unwrap_char(stir->netdev, &stir->netdev->stats,\r\n&stir->rx_buff, bytes[i]);\r\n}\r\nstatic inline void unwrap_chars(struct stir_cb *stir,\r\nconst __u8 *bytes, int length)\r\n{\r\nif (isfir(stir->speed))\r\nstir_fir_chars(stir, bytes, length);\r\nelse\r\nstir_sir_chars(stir, bytes, length);\r\n}\r\nstatic int change_speed(struct stir_cb *stir, unsigned speed)\r\n{\r\nint i, err;\r\n__u8 mode;\r\nfor (i = 0; i < ARRAY_SIZE(stir_modes); ++i) {\r\nif (speed == stir_modes[i].speed)\r\ngoto found;\r\n}\r\ndev_warn(&stir->netdev->dev, "invalid speed %d\n", speed);\r\nreturn -EINVAL;\r\nfound:\r\npr_debug("speed change from %d to %d\n", stir->speed, speed);\r\nerr = write_reg(stir, REG_CTRL1, CTRL1_SRESET);\r\nif (err)\r\ngoto out;\r\nerr = write_reg(stir, REG_DPLL, 0x15);\r\nif (err)\r\ngoto out;\r\nerr = write_reg(stir, REG_PDCLK, stir_modes[i].pdclk);\r\nif (err)\r\ngoto out;\r\nmode = MODE_NRESET | MODE_FASTRX;\r\nif (isfir(speed))\r\nmode |= MODE_FIR | MODE_FFRSTEN;\r\nelse\r\nmode |= MODE_SIR;\r\nif (speed == 2400)\r\nmode |= MODE_2400;\r\nerr = write_reg(stir, REG_MODE, mode);\r\nif (err)\r\ngoto out;\r\nerr = write_reg(stir, REG_CTRL1,\r\nCTRL1_SDMODE | (tx_power & 3) << 1);\r\nif (err)\r\ngoto out;\r\nerr = write_reg(stir, REG_CTRL1, (tx_power & 3) << 1);\r\nif (err)\r\ngoto out;\r\nerr = write_reg(stir, REG_CTRL2, (rx_sensitivity & 7) << 5);\r\nout:\r\nstir->speed = speed;\r\nreturn err;\r\n}\r\nstatic netdev_tx_t stir_hard_xmit(struct sk_buff *skb,\r\nstruct net_device *netdev)\r\n{\r\nstruct stir_cb *stir = netdev_priv(netdev);\r\nnetif_stop_queue(netdev);\r\nSKB_LINEAR_ASSERT(skb);\r\nskb = xchg(&stir->tx_pending, skb);\r\nwake_up_process(stir->thread);\r\nif (unlikely(skb)) {\r\nWARN_ON(1);\r\ndev_kfree_skb(skb);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int fifo_txwait(struct stir_cb *stir, int space)\r\n{\r\nint err;\r\nunsigned long count, status;\r\nunsigned long prev_count = 0x1fff;\r\nfor (;; prev_count = count) {\r\nerr = read_reg(stir, REG_FIFOCTL, stir->fifo_status,\r\nFIFO_REGS_SIZE);\r\nif (unlikely(err != FIFO_REGS_SIZE)) {\r\ndev_warn(&stir->netdev->dev,\r\n"FIFO register read error: %d\n", err);\r\nreturn err;\r\n}\r\nstatus = stir->fifo_status[0];\r\ncount = (unsigned)(stir->fifo_status[2] & 0x1f) << 8\r\n| stir->fifo_status[1];\r\npr_debug("fifo status 0x%lx count %lu\n", status, count);\r\nif (!(status & FIFOCTL_DIR) ||\r\n(status & FIFOCTL_EMPTY))\r\nreturn 0;\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nif (!netif_running(stir->netdev) ||\r\n!netif_device_present(stir->netdev))\r\nreturn -ESHUTDOWN;\r\nif (space >= 0 && STIR_FIFO_SIZE - 4 > space + count)\r\nreturn 0;\r\nif (prev_count < count)\r\nbreak;\r\nmsleep((count * 8000) / stir->speed);\r\n}\r\nerr = write_reg(stir, REG_FIFOCTL, FIFOCTL_CLR);\r\nif (err)\r\nreturn err;\r\nerr = write_reg(stir, REG_FIFOCTL, 0);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void turnaround_delay(const struct stir_cb *stir, long us)\r\n{\r\nlong ticks;\r\nstruct timeval now;\r\nif (us <= 0)\r\nreturn;\r\ndo_gettimeofday(&now);\r\nif (now.tv_sec - stir->rx_time.tv_sec > 0)\r\nus -= USEC_PER_SEC;\r\nus -= now.tv_usec - stir->rx_time.tv_usec;\r\nif (us < 10)\r\nreturn;\r\nticks = us / (1000000 / HZ);\r\nif (ticks > 0)\r\nschedule_timeout_interruptible(1 + ticks);\r\nelse\r\nudelay(us);\r\n}\r\nstatic int receive_start(struct stir_cb *stir)\r\n{\r\nstir->receiving = 1;\r\nstir->rx_buff.in_frame = FALSE;\r\nstir->rx_buff.state = OUTSIDE_FRAME;\r\nstir->rx_urb->status = 0;\r\nreturn usb_submit_urb(stir->rx_urb, GFP_KERNEL);\r\n}\r\nstatic void receive_stop(struct stir_cb *stir)\r\n{\r\nstir->receiving = 0;\r\nusb_kill_urb(stir->rx_urb);\r\nif (stir->rx_buff.in_frame)\r\nstir->netdev->stats.collisions++;\r\n}\r\nstatic void stir_send(struct stir_cb *stir, struct sk_buff *skb)\r\n{\r\nunsigned wraplen;\r\nint first_frame = 0;\r\nif (stir->receiving) {\r\nreceive_stop(stir);\r\nturnaround_delay(stir, irda_get_mtt(skb));\r\nfirst_frame = 1;\r\n}\r\nif (isfir(stir->speed))\r\nwraplen = wrap_fir_skb(skb, stir->io_buf);\r\nelse\r\nwraplen = wrap_sir_skb(skb, stir->io_buf);\r\nif (!first_frame)\r\nfifo_txwait(stir, wraplen);\r\nstir->netdev->stats.tx_packets++;\r\nstir->netdev->stats.tx_bytes += skb->len;\r\nstir->netdev->trans_start = jiffies;\r\npr_debug("send %d (%d)\n", skb->len, wraplen);\r\nif (usb_bulk_msg(stir->usbdev, usb_sndbulkpipe(stir->usbdev, 1),\r\nstir->io_buf, wraplen,\r\nNULL, TRANSMIT_TIMEOUT))\r\nstir->netdev->stats.tx_errors++;\r\n}\r\nstatic int stir_transmit_thread(void *arg)\r\n{\r\nstruct stir_cb *stir = arg;\r\nstruct net_device *dev = stir->netdev;\r\nstruct sk_buff *skb;\r\nwhile (!kthread_should_stop()) {\r\n#ifdef CONFIG_PM\r\nif (unlikely(freezing(current))) {\r\nif (stir->receiving)\r\nreceive_stop(stir);\r\nelse\r\nfifo_txwait(stir, -1);\r\nwrite_reg(stir, REG_CTRL1, CTRL1_TXPWD|CTRL1_RXPWD);\r\ntry_to_freeze();\r\nif (change_speed(stir, stir->speed))\r\nbreak;\r\n}\r\n#endif\r\nskb = xchg(&stir->tx_pending, NULL);\r\nif (skb) {\r\nunsigned new_speed = irda_get_next_speed(skb);\r\nnetif_wake_queue(dev);\r\nif (skb->len > 0)\r\nstir_send(stir, skb);\r\ndev_kfree_skb(skb);\r\nif ((new_speed != -1) && (stir->speed != new_speed)) {\r\nif (fifo_txwait(stir, -1) ||\r\nchange_speed(stir, new_speed))\r\nbreak;\r\n}\r\ncontinue;\r\n}\r\nif (!stir->receiving &&\r\nirda_device_txqueue_empty(dev)) {\r\nif (fifo_txwait(stir, -1))\r\nbreak;\r\nif (unlikely(receive_start(stir))) {\r\nif (net_ratelimit())\r\ndev_info(&dev->dev,\r\n"%s: receive usb submit failed\n",\r\nstir->netdev->name);\r\nstir->receiving = 0;\r\nmsleep(10);\r\ncontinue;\r\n}\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule();\r\n}\r\nreturn 0;\r\n}\r\nstatic void stir_rcv_irq(struct urb *urb)\r\n{\r\nstruct stir_cb *stir = urb->context;\r\nint err;\r\nif (!netif_running(stir->netdev))\r\nreturn;\r\nif (urb->status != 0)\r\nreturn;\r\nif (urb->actual_length > 0) {\r\npr_debug("receive %d\n", urb->actual_length);\r\nunwrap_chars(stir, urb->transfer_buffer,\r\nurb->actual_length);\r\ndo_gettimeofday(&stir->rx_time);\r\n}\r\nif (!stir->receiving)\r\nreturn;\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err) {\r\ndev_warn(&stir->netdev->dev, "usb receive submit error: %d\n",\r\nerr);\r\nstir->receiving = 0;\r\nwake_up_process(stir->thread);\r\n}\r\n}\r\nstatic int stir_net_open(struct net_device *netdev)\r\n{\r\nstruct stir_cb *stir = netdev_priv(netdev);\r\nint err;\r\nchar hwname[16];\r\nerr = usb_clear_halt(stir->usbdev, usb_sndbulkpipe(stir->usbdev, 1));\r\nif (err)\r\ngoto err_out1;\r\nerr = usb_clear_halt(stir->usbdev, usb_rcvbulkpipe(stir->usbdev, 2));\r\nif (err)\r\ngoto err_out1;\r\nerr = change_speed(stir, 9600);\r\nif (err)\r\ngoto err_out1;\r\nerr = -ENOMEM;\r\nstir->receiving = 0;\r\nstir->rx_buff.truesize = IRDA_SKB_MAX_MTU;\r\nstir->rx_buff.skb = dev_alloc_skb(IRDA_SKB_MAX_MTU);\r\nif (!stir->rx_buff.skb)\r\ngoto err_out1;\r\nskb_reserve(stir->rx_buff.skb, 1);\r\nstir->rx_buff.head = stir->rx_buff.skb->data;\r\ndo_gettimeofday(&stir->rx_time);\r\nstir->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!stir->rx_urb)\r\ngoto err_out2;\r\nstir->io_buf = kmalloc(STIR_FIFO_SIZE, GFP_KERNEL);\r\nif (!stir->io_buf)\r\ngoto err_out3;\r\nusb_fill_bulk_urb(stir->rx_urb, stir->usbdev,\r\nusb_rcvbulkpipe(stir->usbdev, 2),\r\nstir->io_buf, STIR_FIFO_SIZE,\r\nstir_rcv_irq, stir);\r\nstir->fifo_status = kmalloc(FIFO_REGS_SIZE, GFP_KERNEL);\r\nif (!stir->fifo_status)\r\ngoto err_out4;\r\nsprintf(hwname, "usb#%d", stir->usbdev->devnum);\r\nstir->irlap = irlap_open(netdev, &stir->qos, hwname);\r\nif (!stir->irlap) {\r\nerr("stir4200: irlap_open failed");\r\ngoto err_out5;\r\n}\r\nstir->thread = kthread_run(stir_transmit_thread, stir,\r\n"%s", stir->netdev->name);\r\nif (IS_ERR(stir->thread)) {\r\nerr = PTR_ERR(stir->thread);\r\nerr("stir4200: unable to start kernel thread");\r\ngoto err_out6;\r\n}\r\nnetif_start_queue(netdev);\r\nreturn 0;\r\nerr_out6:\r\nirlap_close(stir->irlap);\r\nerr_out5:\r\nkfree(stir->fifo_status);\r\nerr_out4:\r\nkfree(stir->io_buf);\r\nerr_out3:\r\nusb_free_urb(stir->rx_urb);\r\nerr_out2:\r\nkfree_skb(stir->rx_buff.skb);\r\nerr_out1:\r\nreturn err;\r\n}\r\nstatic int stir_net_close(struct net_device *netdev)\r\n{\r\nstruct stir_cb *stir = netdev_priv(netdev);\r\nnetif_stop_queue(netdev);\r\nkthread_stop(stir->thread);\r\nkfree(stir->fifo_status);\r\nusb_kill_urb(stir->rx_urb);\r\nkfree(stir->io_buf);\r\nusb_free_urb(stir->rx_urb);\r\nkfree_skb(stir->rx_buff.skb);\r\nif (stir->irlap)\r\nirlap_close(stir->irlap);\r\nstir->irlap = NULL;\r\nreturn 0;\r\n}\r\nstatic int stir_net_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)\r\n{\r\nstruct if_irda_req *irq = (struct if_irda_req *) rq;\r\nstruct stir_cb *stir = netdev_priv(netdev);\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase SIOCSBANDWIDTH:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (netif_device_present(stir->netdev))\r\nret = change_speed(stir, irq->ifr_baudrate);\r\nbreak;\r\ncase SIOCSMEDIABUSY:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (netif_running(stir->netdev))\r\nirda_device_set_media_busy(stir->netdev, TRUE);\r\nbreak;\r\ncase SIOCGRECEIVING:\r\nirq->ifr_receiving = stir->receiving;\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic int stir_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nstruct stir_cb *stir = NULL;\r\nstruct net_device *net;\r\nint ret = -ENOMEM;\r\nnet = alloc_irdadev(sizeof(*stir));\r\nif(!net)\r\ngoto err_out1;\r\nSET_NETDEV_DEV(net, &intf->dev);\r\nstir = netdev_priv(net);\r\nstir->netdev = net;\r\nstir->usbdev = dev;\r\nret = usb_reset_configuration(dev);\r\nif (ret != 0) {\r\nerr("stir4200: usb reset configuration failed");\r\ngoto err_out2;\r\n}\r\nprintk(KERN_INFO "SigmaTel STIr4200 IRDA/USB found at address %d, "\r\n"Vendor: %x, Product: %x\n",\r\ndev->devnum, le16_to_cpu(dev->descriptor.idVendor),\r\nle16_to_cpu(dev->descriptor.idProduct));\r\nirda_init_max_qos_capabilies(&stir->qos);\r\nstir->qos.baud_rate.bits &= IR_2400 | IR_9600 | IR_19200 |\r\nIR_38400 | IR_57600 | IR_115200 |\r\n(IR_4000000 << 8);\r\nstir->qos.min_turn_time.bits &= qos_mtt_bits;\r\nirda_qos_bits_to_value(&stir->qos);\r\nnet->netdev_ops = &stir_netdev_ops;\r\nret = register_netdev(net);\r\nif (ret != 0)\r\ngoto err_out2;\r\ndev_info(&intf->dev, "IrDA: Registered SigmaTel device %s\n",\r\nnet->name);\r\nusb_set_intfdata(intf, stir);\r\nreturn 0;\r\nerr_out2:\r\nfree_netdev(net);\r\nerr_out1:\r\nreturn ret;\r\n}\r\nstatic void stir_disconnect(struct usb_interface *intf)\r\n{\r\nstruct stir_cb *stir = usb_get_intfdata(intf);\r\nif (!stir)\r\nreturn;\r\nunregister_netdev(stir->netdev);\r\nfree_netdev(stir->netdev);\r\nusb_set_intfdata(intf, NULL);\r\n}\r\nstatic int stir_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct stir_cb *stir = usb_get_intfdata(intf);\r\nnetif_device_detach(stir->netdev);\r\nreturn 0;\r\n}\r\nstatic int stir_resume(struct usb_interface *intf)\r\n{\r\nstruct stir_cb *stir = usb_get_intfdata(intf);\r\nnetif_device_attach(stir->netdev);\r\nreturn 0;\r\n}
