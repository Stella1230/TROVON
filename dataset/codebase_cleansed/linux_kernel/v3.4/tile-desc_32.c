const struct tilepro_opcode *\r\nfind_opcode(tilepro_bundle_bits bits, tilepro_pipeline pipe)\r\n{\r\nconst unsigned short *table = tilepro_bundle_decoder_fsms[pipe];\r\nint index = 0;\r\nwhile (1)\r\n{\r\nunsigned short bitspec = table[index];\r\nunsigned int bitfield =\r\n((unsigned int)(bits >> (bitspec & 63))) & (bitspec >> 6);\r\nunsigned short next = table[index + 1 + bitfield];\r\nif (next <= TILEPRO_OPC_NONE)\r\nreturn &tilepro_opcodes[next];\r\nindex = next - TILEPRO_OPC_NONE;\r\n}\r\n}\r\nint\r\nparse_insn_tilepro(tilepro_bundle_bits bits,\r\nunsigned int pc,\r\nstruct tilepro_decoded_instruction\r\ndecoded[TILEPRO_MAX_INSTRUCTIONS_PER_BUNDLE])\r\n{\r\nint num_instructions = 0;\r\nint pipe;\r\nint min_pipe, max_pipe;\r\nif ((bits & TILEPRO_BUNDLE_Y_ENCODING_MASK) == 0)\r\n{\r\nmin_pipe = TILEPRO_PIPELINE_X0;\r\nmax_pipe = TILEPRO_PIPELINE_X1;\r\n}\r\nelse\r\n{\r\nmin_pipe = TILEPRO_PIPELINE_Y0;\r\nmax_pipe = TILEPRO_PIPELINE_Y2;\r\n}\r\nfor (pipe = min_pipe; pipe <= max_pipe; pipe++)\r\n{\r\nconst struct tilepro_opcode *opc;\r\nstruct tilepro_decoded_instruction *d;\r\nint i;\r\nd = &decoded[num_instructions++];\r\nopc = find_opcode (bits, (tilepro_pipeline)pipe);\r\nd->opcode = opc;\r\nfor (i = 0; i < opc->num_operands; i++)\r\n{\r\nconst struct tilepro_operand *op =\r\n&tilepro_operands[opc->operands[pipe][i]];\r\nint opval = op->extract (bits);\r\nif (op->is_signed)\r\n{\r\nint shift = (int)((sizeof(int) * 8) - op->num_bits);\r\nopval = (opval << shift) >> shift;\r\n}\r\nif (op->type == TILEPRO_OP_TYPE_ADDRESS)\r\n{\r\nopval *= TILEPRO_BUNDLE_SIZE_IN_BYTES;\r\nopval += (int)pc;\r\n}\r\nd->operands[i] = op;\r\nd->operand_values[i] = opval;\r\n}\r\n}\r\nreturn num_instructions;\r\n}
