static int intel_mid_i2c_disable(struct i2c_adapter *adap)\r\n{\r\nstruct intel_mid_i2c_private *i2c = i2c_get_adapdata(adap);\r\nint err = 0;\r\nint count = 0;\r\nint ret1, ret2;\r\nstatic const u16 delay[NUM_SPEEDS] = {100, 25, 3};\r\nwritel(0, i2c->base + IC_ENABLE);\r\ndev_dbg(&adap->dev, "mrst i2c disable\n");\r\nwhile ((ret1 = readl(i2c->base + IC_ENABLE_STATUS) & 0x1)\r\n|| (ret2 = readl(i2c->base + IC_STATUS) & 0x1)) {\r\nudelay(delay[i2c->speed]);\r\nwritel(0, i2c->base + IC_ENABLE);\r\ndev_dbg(&adap->dev, "i2c is busy, count is %d speed %d\n",\r\ncount, i2c->speed);\r\nif (count++ > 10) {\r\nerr = -ETIMEDOUT;\r\nbreak;\r\n}\r\n}\r\nreadl(i2c->base + IC_CLR_INTR);\r\nreadl(i2c->base + IC_CLR_STOP_DET);\r\nreadl(i2c->base + IC_CLR_START_DET);\r\nreadl(i2c->base + IC_CLR_ACTIVITY);\r\nreadl(i2c->base + IC_CLR_TX_ABRT);\r\nreadl(i2c->base + IC_CLR_RX_OVER);\r\nreadl(i2c->base + IC_CLR_RX_UNDER);\r\nreadl(i2c->base + IC_CLR_TX_OVER);\r\nreadl(i2c->base + IC_CLR_RX_DONE);\r\nreadl(i2c->base + IC_CLR_GEN_CALL);\r\nwritel(0x0000, i2c->base + IC_INTR_MASK);\r\nreturn err;\r\n}\r\nstatic int intel_mid_i2c_hwinit(struct intel_mid_i2c_private *i2c)\r\n{\r\nint err;\r\nstatic const u16 hcnt[NUM_PLATFORMS][NUM_SPEEDS] = {\r\n{ 0x75, 0x15, 0x07 },\r\n{ 0x04c, 0x10, 0x06 }\r\n};\r\nstatic const u16 lcnt[NUM_PLATFORMS][NUM_SPEEDS] = {\r\n{ 0x7C, 0x21, 0x0E },\r\n{ 0x053, 0x19, 0x0F }\r\n};\r\nerr = intel_mid_i2c_disable(&i2c->adap);\r\nif (err)\r\nreturn err;\r\nwritel((i2c->speed + 1) << 1 | SLV_DIS | RESTART | MASTER_EN,\r\ni2c->base + IC_CON);\r\nwritel(hcnt[i2c->platform][i2c->speed],\r\ni2c->base + (IC_SS_SCL_HCNT + (i2c->speed << 3)));\r\nwritel(lcnt[i2c->platform][i2c->speed],\r\ni2c->base + (IC_SS_SCL_LCNT + (i2c->speed << 3)));\r\nwritel(0x0, i2c->base + IC_RX_TL);\r\nwritel(0x0, i2c->base + IC_TX_TL);\r\nreturn 0;\r\n}\r\nstatic u32 intel_mid_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic inline bool intel_mid_i2c_address_neq(const struct i2c_msg *p1,\r\nconst struct i2c_msg *p2)\r\n{\r\nif (p1->addr != p2->addr)\r\nreturn 1;\r\nif ((p1->flags ^ p2->flags) & I2C_M_TEN)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void intel_mid_i2c_abort(struct intel_mid_i2c_private *i2c)\r\n{\r\nint abort = i2c->abort;\r\nstruct i2c_adapter *adap = &i2c->adap;\r\nif (abort & ABRT_MASTER_DIS)\r\ndev_err(&adap->dev,\r\n"initiate master operation with master mode disabled.\n");\r\nif (abort & ABRT_10B_RD_NORSTRT)\r\ndev_err(&adap->dev,\r\n"RESTART disabled and master sent READ cmd in 10-bit addressing.\n");\r\nif (abort & ABRT_SBYTE_NORSTRT) {\r\ndev_err(&adap->dev,\r\n"RESTART disabled and user is trying to send START byte.\n");\r\nwritel(~ABRT_SBYTE_NORSTRT, i2c->base + IC_TX_ABRT_SOURCE);\r\nwritel(RESTART, i2c->base + IC_CON);\r\nwritel(~IC_TAR_SPECIAL, i2c->base + IC_TAR);\r\n}\r\nif (abort & ABRT_SBYTE_ACKDET)\r\ndev_err(&adap->dev,\r\n"START byte was not acknowledged.\n");\r\nif (abort & ABRT_TXDATA_NOACK)\r\ndev_dbg(&adap->dev,\r\n"No acknowledgement received from slave.\n");\r\nif (abort & ABRT_10ADDR2_NOACK)\r\ndev_dbg(&adap->dev,\r\n"The 2nd address byte of the 10-bit address was not acknowledged.\n");\r\nif (abort & ABRT_10ADDR1_NOACK)\r\ndev_dbg(&adap->dev,\r\n"The 1st address byte of 10-bit address was not acknowledged.\n");\r\nif (abort & ABRT_7B_ADDR_NOACK)\r\ndev_dbg(&adap->dev,\r\n"I2C slave device not acknowledged.\n");\r\nreadl(i2c->base + IC_CLR_TX_ABRT);\r\ni2c->status = STATUS_XFER_ABORT;\r\n}\r\nstatic int xfer_read(struct i2c_adapter *adap, unsigned char *buf, int length)\r\n{\r\nstruct intel_mid_i2c_private *i2c = i2c_get_adapdata(adap);\r\nint i = length;\r\nint err;\r\nif (length >= 256) {\r\ndev_err(&adap->dev,\r\n"I2C FIFO cannot support larger than 256 bytes\n");\r\nreturn -EMSGSIZE;\r\n}\r\nINIT_COMPLETION(i2c->complete);\r\nreadl(i2c->base + IC_CLR_INTR);\r\nwritel(0x0044, i2c->base + IC_INTR_MASK);\r\ni2c->status = STATUS_READ_START;\r\nwhile (i--)\r\nwritel(IC_RD, i2c->base + IC_DATA_CMD);\r\ni2c->status = STATUS_READ_START;\r\nerr = wait_for_completion_interruptible_timeout(&i2c->complete, HZ);\r\nif (!err) {\r\ndev_err(&adap->dev, "Timeout for ACK from I2C slave device\n");\r\nintel_mid_i2c_hwinit(i2c);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (i2c->status == STATUS_READ_SUCCESS)\r\nreturn 0;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic int xfer_write(struct i2c_adapter *adap,\r\nunsigned char *buf, int length)\r\n{\r\nstruct intel_mid_i2c_private *i2c = i2c_get_adapdata(adap);\r\nint i, err;\r\nif (length >= 256) {\r\ndev_err(&adap->dev,\r\n"I2C FIFO cannot support larger than 256 bytes\n");\r\nreturn -EMSGSIZE;\r\n}\r\nINIT_COMPLETION(i2c->complete);\r\nreadl(i2c->base + IC_CLR_INTR);\r\nwritel(0x0050, i2c->base + IC_INTR_MASK);\r\ni2c->status = STATUS_WRITE_START;\r\nfor (i = 0; i < length; i++)\r\nwritel((u16)(*(buf + i)), i2c->base + IC_DATA_CMD);\r\ni2c->status = STATUS_WRITE_START;\r\nerr = wait_for_completion_interruptible_timeout(&i2c->complete, HZ);\r\nif (!err) {\r\ndev_err(&adap->dev, "Timeout for ACK from I2C slave device\n");\r\nintel_mid_i2c_hwinit(i2c);\r\nreturn -ETIMEDOUT;\r\n} else {\r\nif (i2c->status == STATUS_WRITE_SUCCESS)\r\nreturn 0;\r\nelse\r\nreturn -EIO;\r\n}\r\n}\r\nstatic int intel_mid_i2c_setup(struct i2c_adapter *adap, struct i2c_msg *pmsg)\r\n{\r\nstruct intel_mid_i2c_private *i2c = i2c_get_adapdata(adap);\r\nint err;\r\nu32 reg;\r\nu32 bit_mask;\r\nu32 mode;\r\nerr = intel_mid_i2c_disable(adap);\r\nif (err) {\r\ndev_err(&adap->dev,\r\n"Cannot disable i2c controller, timeout\n");\r\nreturn err;\r\n}\r\nmode = (1 + i2c->speed) << 1;\r\nreg = readl(i2c->base + IC_CON);\r\nif ((reg & 0x06) != mode) {\r\ndev_dbg(&adap->dev, "set mode %d\n", i2c->speed);\r\nwritel((reg & ~0x6) | mode, i2c->base + IC_CON);\r\n}\r\nreg = readl(i2c->base + IC_CON);\r\nif (pmsg->flags & I2C_M_TEN) {\r\nif ((reg & ADDR_10BIT) != ADDR_10BIT) {\r\ndev_dbg(&adap->dev, "set i2c 10 bit address mode\n");\r\nwritel(reg | ADDR_10BIT, i2c->base + IC_CON);\r\n}\r\n} else {\r\nif ((reg & ADDR_10BIT) != 0x0) {\r\ndev_dbg(&adap->dev, "set i2c 7 bit address mode\n");\r\nwritel(reg & ~ADDR_10BIT, i2c->base + IC_CON);\r\n}\r\n}\r\nreg = readl(i2c->base + IC_CON);\r\nif ((reg & RESTART) != RESTART) {\r\ndev_dbg(&adap->dev, "enable restart conditions\n");\r\nwritel(reg | RESTART, i2c->base + IC_CON);\r\n}\r\nreg = readl(i2c->base + IC_CON);\r\ndev_dbg(&adap->dev, "ic_con reg is 0x%x\n", reg);\r\nwritel(reg | MASTER_EN, i2c->base + IC_CON);\r\nif ((reg & SLV_DIS) != SLV_DIS) {\r\ndev_dbg(&adap->dev, "enable master FSM\n");\r\nwritel(reg | SLV_DIS, i2c->base + IC_CON);\r\ndev_dbg(&adap->dev, "ic_con reg is 0x%x\n", reg);\r\n}\r\nreg = readl(i2c->base + IC_TAR);\r\nbit_mask = IC_TAR_SPECIAL | IC_TAR_GC_OR_START;\r\nif ((reg & bit_mask) != 0x0) {\r\ndev_dbg(&adap->dev,\r\n"WR: use target address when intiating transfer, i2c_tx_target\n");\r\nwritel(reg & ~bit_mask, i2c->base + IC_TAR);\r\n}\r\ndev_dbg(&adap->dev,\r\n"set target address to the I2C slave address, addr is %x\n",\r\npmsg->addr);\r\nwritel(pmsg->addr | (pmsg->flags & I2C_M_TEN ? IC_TAR_10BIT_ADDR : 0),\r\ni2c->base + IC_TAR);\r\nwritel(ENABLE, i2c->base + IC_ENABLE);\r\nreturn 0;\r\n}\r\nstatic int intel_mid_i2c_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg *pmsg,\r\nint num)\r\n{\r\nstruct intel_mid_i2c_private *i2c = i2c_get_adapdata(adap);\r\nint i, err = 0;\r\nif (num == 0)\r\nreturn 0;\r\npm_runtime_get(i2c->dev);\r\nmutex_lock(&i2c->lock);\r\ndev_dbg(&adap->dev, "intel_mid_i2c_xfer, process %d msg(s)\n", num);\r\ndev_dbg(&adap->dev, "slave address is %x\n", pmsg->addr);\r\nif (i2c->status != STATUS_IDLE) {\r\ndev_err(&adap->dev, "Adapter %d in transfer/standby\n",\r\nadap->nr);\r\nmutex_unlock(&i2c->lock);\r\npm_runtime_put(i2c->dev);\r\nreturn -1;\r\n}\r\nfor (i = 1; i < num; i++) {\r\nif (unlikely(intel_mid_i2c_address_neq(&pmsg[0], &pmsg[i]))) {\r\ndev_err(&adap->dev, "Invalid address in msg[%d]\n", i);\r\nmutex_unlock(&i2c->lock);\r\npm_runtime_put(i2c->dev);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (intel_mid_i2c_setup(adap, pmsg)) {\r\nmutex_unlock(&i2c->lock);\r\npm_runtime_put(i2c->dev);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < num; i++) {\r\ni2c->msg = pmsg;\r\ni2c->status = STATUS_IDLE;\r\nif (pmsg->flags & I2C_M_RD) {\r\ndev_dbg(&adap->dev, "I2C_M_RD\n");\r\nerr = xfer_read(adap, pmsg->buf, pmsg->len);\r\n} else {\r\ndev_dbg(&adap->dev, "I2C_M_WR\n");\r\nerr = xfer_write(adap, pmsg->buf, pmsg->len);\r\n}\r\nif (err < 0)\r\nbreak;\r\ndev_dbg(&adap->dev, "msg[%d] transfer complete\n", i);\r\npmsg++;\r\n}\r\nwritel(0x0000, i2c->base + IC_INTR_MASK);\r\nreadl(i2c->base + IC_CLR_INTR);\r\ni2c->status = STATUS_IDLE;\r\nmutex_unlock(&i2c->lock);\r\npm_runtime_put(i2c->dev);\r\nreturn err;\r\n}\r\nstatic int intel_mid_i2c_runtime_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct intel_mid_i2c_private *i2c = pci_get_drvdata(pdev);\r\nstruct i2c_adapter *adap = to_i2c_adapter(dev);\r\nint err;\r\nif (i2c->status != STATUS_IDLE)\r\nreturn -1;\r\nintel_mid_i2c_disable(adap);\r\nerr = pci_save_state(pdev);\r\nif (err) {\r\ndev_err(dev, "pci_save_state failed\n");\r\nreturn err;\r\n}\r\nerr = pci_set_power_state(pdev, PCI_D3hot);\r\nif (err) {\r\ndev_err(dev, "pci_set_power_state failed\n");\r\nreturn err;\r\n}\r\ni2c->status = STATUS_STANDBY;\r\nreturn 0;\r\n}\r\nstatic int intel_mid_i2c_runtime_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct intel_mid_i2c_private *i2c = pci_get_drvdata(pdev);\r\nint err;\r\nif (i2c->status != STATUS_STANDBY)\r\nreturn 0;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\ndev_err(dev, "pci_enable_device failed\n");\r\nreturn err;\r\n}\r\ni2c->status = STATUS_IDLE;\r\nintel_mid_i2c_hwinit(i2c);\r\nreturn err;\r\n}\r\nstatic void i2c_isr_read(struct intel_mid_i2c_private *i2c)\r\n{\r\nstruct i2c_msg *msg = i2c->msg;\r\nint rx_num;\r\nu32 len;\r\nu8 *buf;\r\nif (!(msg->flags & I2C_M_RD))\r\nreturn;\r\nif (i2c->status != STATUS_READ_IN_PROGRESS) {\r\nlen = msg->len;\r\nbuf = msg->buf;\r\n} else {\r\nlen = i2c->rx_buf_len;\r\nbuf = i2c->rx_buf;\r\n}\r\nrx_num = readl(i2c->base + IC_RXFLR);\r\nfor (; len > 0 && rx_num > 0; len--, rx_num--)\r\n*buf++ = readl(i2c->base + IC_DATA_CMD);\r\nif (len > 0) {\r\ni2c->status = STATUS_READ_IN_PROGRESS;\r\ni2c->rx_buf_len = len;\r\ni2c->rx_buf = buf;\r\n} else\r\ni2c->status = STATUS_READ_SUCCESS;\r\nreturn;\r\n}\r\nstatic irqreturn_t intel_mid_i2c_isr(int this_irq, void *dev)\r\n{\r\nstruct intel_mid_i2c_private *i2c = dev;\r\nu32 stat = readl(i2c->base + IC_INTR_STAT);\r\nif (!stat)\r\nreturn IRQ_NONE;\r\ndev_dbg(&i2c->adap.dev, "%s, stat = 0x%x\n", __func__, stat);\r\nstat &= 0x54;\r\nif (i2c->status != STATUS_WRITE_START &&\r\ni2c->status != STATUS_READ_START &&\r\ni2c->status != STATUS_READ_IN_PROGRESS)\r\ngoto err;\r\nif (stat & TX_ABRT)\r\ni2c->abort = readl(i2c->base + IC_TX_ABRT_SOURCE);\r\nreadl(i2c->base + IC_CLR_INTR);\r\nif (stat & TX_ABRT) {\r\nintel_mid_i2c_abort(i2c);\r\ngoto exit;\r\n}\r\nif (stat & RX_FULL) {\r\ni2c_isr_read(i2c);\r\ngoto exit;\r\n}\r\nif (stat & TX_EMPTY) {\r\nif (readl(i2c->base + IC_STATUS) & 0x4)\r\ni2c->status = STATUS_WRITE_SUCCESS;\r\n}\r\nexit:\r\nif (i2c->status == STATUS_READ_SUCCESS ||\r\ni2c->status == STATUS_WRITE_SUCCESS ||\r\ni2c->status == STATUS_XFER_ABORT) {\r\nreadl(i2c->base + IC_CLR_INTR);\r\nwritel(0, i2c->base + IC_INTR_MASK);\r\ncomplete(&i2c->complete);\r\n}\r\nerr:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit intel_mid_i2c_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct intel_mid_i2c_private *mrst;\r\nunsigned long start, len;\r\nint err, busnum;\r\nvoid __iomem *base = NULL;\r\ndev_dbg(&dev->dev, "Get into probe function for I2C\n");\r\nerr = pci_enable_device(dev);\r\nif (err) {\r\ndev_err(&dev->dev, "Failed to enable I2C PCI device (%d)\n",\r\nerr);\r\ngoto exit;\r\n}\r\nstart = pci_resource_start(dev, 0);\r\nlen = pci_resource_len(dev, 0);\r\nif (!start || len == 0) {\r\ndev_err(&dev->dev, "base address not set\n");\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\ndev_dbg(&dev->dev, "%s i2c resource start 0x%lx, len=%ld\n",\r\nPLATFORM, start, len);\r\nerr = pci_request_region(dev, 0, DRIVER_NAME);\r\nif (err) {\r\ndev_err(&dev->dev, "failed to request I2C region "\r\n"0x%lx-0x%lx\n", start,\r\n(unsigned long)pci_resource_end(dev, 0));\r\ngoto exit;\r\n}\r\nbase = ioremap_nocache(start, len);\r\nif (!base) {\r\ndev_err(&dev->dev, "I/O memory remapping failed\n");\r\nerr = -ENOMEM;\r\ngoto fail0;\r\n}\r\nmrst = kzalloc(sizeof(struct intel_mid_i2c_private), GFP_KERNEL);\r\nif (mrst == NULL) {\r\ndev_err(&dev->dev, "can't allocate interface\n");\r\nerr = -ENOMEM;\r\ngoto fail1;\r\n}\r\nsnprintf(mrst->adap.name, sizeof(mrst->adap.name),\r\n"Intel MID I2C at %lx", start);\r\nmrst->adap.owner = THIS_MODULE;\r\nmrst->adap.algo = &intel_mid_i2c_algorithm;\r\nmrst->adap.dev.parent = &dev->dev;\r\nmrst->dev = &dev->dev;\r\nmrst->base = base;\r\nmrst->speed = STANDARD;\r\nmrst->abort = 0;\r\nmrst->rx_buf_len = 0;\r\nmrst->status = STATUS_IDLE;\r\npci_set_drvdata(dev, mrst);\r\ni2c_set_adapdata(&mrst->adap, mrst);\r\nmrst->adap.nr = busnum = id->driver_data;\r\nif (dev->device <= 0x0804)\r\nmrst->platform = MOORESTOWN;\r\nelse\r\nmrst->platform = MEDFIELD;\r\ndev_dbg(&dev->dev, "I2C%d\n", busnum);\r\nif (ctl_num > busnum) {\r\nif (speed_mode[busnum] < 0 || speed_mode[busnum] >= NUM_SPEEDS)\r\ndev_warn(&dev->dev, "invalid speed %d ignored.\n",\r\nspeed_mode[busnum]);\r\nelse\r\nmrst->speed = speed_mode[busnum];\r\n}\r\nerr = intel_mid_i2c_hwinit(mrst);\r\nif (err < 0) {\r\ndev_err(&dev->dev, "I2C interface initialization failed\n");\r\ngoto fail2;\r\n}\r\nmutex_init(&mrst->lock);\r\ninit_completion(&mrst->complete);\r\nreadl(mrst->base + IC_CLR_INTR);\r\nwritel(0x0000, mrst->base + IC_INTR_MASK);\r\nerr = request_irq(dev->irq, intel_mid_i2c_isr, IRQF_SHARED,\r\nmrst->adap.name, mrst);\r\nif (err) {\r\ndev_err(&dev->dev, "Failed to request IRQ for I2C controller: "\r\n"%s", mrst->adap.name);\r\ngoto fail2;\r\n}\r\nerr = i2c_add_numbered_adapter(&mrst->adap);\r\nif (err) {\r\ndev_err(&dev->dev, "Adapter %s registration failed\n",\r\nmrst->adap.name);\r\ngoto fail3;\r\n}\r\ndev_dbg(&dev->dev, "%s I2C bus %d driver bind success.\n",\r\n(mrst->platform == MOORESTOWN) ? "Moorestown" : "Medfield",\r\nbusnum);\r\npm_runtime_enable(&dev->dev);\r\nreturn 0;\r\nfail3:\r\nfree_irq(dev->irq, mrst);\r\nfail2:\r\npci_set_drvdata(dev, NULL);\r\nkfree(mrst);\r\nfail1:\r\niounmap(base);\r\nfail0:\r\npci_release_region(dev, 0);\r\nexit:\r\nreturn err;\r\n}\r\nstatic void __devexit intel_mid_i2c_remove(struct pci_dev *dev)\r\n{\r\nstruct intel_mid_i2c_private *mrst = pci_get_drvdata(dev);\r\nintel_mid_i2c_disable(&mrst->adap);\r\nif (i2c_del_adapter(&mrst->adap))\r\ndev_err(&dev->dev, "Failed to delete i2c adapter");\r\nfree_irq(dev->irq, mrst);\r\npci_set_drvdata(dev, NULL);\r\niounmap(mrst->base);\r\nkfree(mrst);\r\npci_release_region(dev, 0);\r\n}\r\nstatic int __init intel_mid_i2c_init(void)\r\n{\r\nreturn pci_register_driver(&intel_mid_i2c_driver);\r\n}\r\nstatic void __exit intel_mid_i2c_exit(void)\r\n{\r\npci_unregister_driver(&intel_mid_i2c_driver);\r\n}
