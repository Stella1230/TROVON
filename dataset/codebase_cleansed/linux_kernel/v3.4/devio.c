static int usbfs_increase_memory_usage(unsigned amount)\r\n{\r\nunsigned lim;\r\nlim = ACCESS_ONCE(usbfs_memory_mb);\r\nif (lim == 0 || lim > (USBFS_XFER_MAX >> 20))\r\nlim = USBFS_XFER_MAX;\r\nelse\r\nlim <<= 20;\r\natomic_add(amount, &usbfs_memory_usage);\r\nif (atomic_read(&usbfs_memory_usage) <= lim)\r\nreturn 0;\r\natomic_sub(amount, &usbfs_memory_usage);\r\nreturn -ENOMEM;\r\n}\r\nstatic void usbfs_decrease_memory_usage(unsigned amount)\r\n{\r\natomic_sub(amount, &usbfs_memory_usage);\r\n}\r\nstatic int connected(struct dev_state *ps)\r\n{\r\nreturn (!list_empty(&ps->list) &&\r\nps->dev->state != USB_STATE_NOTATTACHED);\r\n}\r\nstatic loff_t usbdev_lseek(struct file *file, loff_t offset, int orig)\r\n{\r\nloff_t ret;\r\nmutex_lock(&file->f_dentry->d_inode->i_mutex);\r\nswitch (orig) {\r\ncase 0:\r\nfile->f_pos = offset;\r\nret = file->f_pos;\r\nbreak;\r\ncase 1:\r\nfile->f_pos += offset;\r\nret = file->f_pos;\r\nbreak;\r\ncase 2:\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&file->f_dentry->d_inode->i_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t usbdev_read(struct file *file, char __user *buf, size_t nbytes,\r\nloff_t *ppos)\r\n{\r\nstruct dev_state *ps = file->private_data;\r\nstruct usb_device *dev = ps->dev;\r\nssize_t ret = 0;\r\nunsigned len;\r\nloff_t pos;\r\nint i;\r\npos = *ppos;\r\nusb_lock_device(dev);\r\nif (!connected(ps)) {\r\nret = -ENODEV;\r\ngoto err;\r\n} else if (pos < 0) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (pos < sizeof(struct usb_device_descriptor)) {\r\nstruct usb_device_descriptor temp_desc;\r\nmemcpy(&temp_desc, &dev->descriptor, sizeof(dev->descriptor));\r\nle16_to_cpus(&temp_desc.bcdUSB);\r\nle16_to_cpus(&temp_desc.idVendor);\r\nle16_to_cpus(&temp_desc.idProduct);\r\nle16_to_cpus(&temp_desc.bcdDevice);\r\nlen = sizeof(struct usb_device_descriptor) - pos;\r\nif (len > nbytes)\r\nlen = nbytes;\r\nif (copy_to_user(buf, ((char *)&temp_desc) + pos, len)) {\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\n*ppos += len;\r\nbuf += len;\r\nnbytes -= len;\r\nret += len;\r\n}\r\npos = sizeof(struct usb_device_descriptor);\r\nfor (i = 0; nbytes && i < dev->descriptor.bNumConfigurations; i++) {\r\nstruct usb_config_descriptor *config =\r\n(struct usb_config_descriptor *)dev->rawdescriptors[i];\r\nunsigned int length = le16_to_cpu(config->wTotalLength);\r\nif (*ppos < pos + length) {\r\nunsigned alloclen =\r\nle16_to_cpu(dev->config[i].desc.wTotalLength);\r\nlen = length - (*ppos - pos);\r\nif (len > nbytes)\r\nlen = nbytes;\r\nif (alloclen > (*ppos - pos)) {\r\nalloclen -= (*ppos - pos);\r\nif (copy_to_user(buf,\r\ndev->rawdescriptors[i] + (*ppos - pos),\r\nmin(len, alloclen))) {\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\n}\r\n*ppos += len;\r\nbuf += len;\r\nnbytes -= len;\r\nret += len;\r\n}\r\npos += length;\r\n}\r\nerr:\r\nusb_unlock_device(dev);\r\nreturn ret;\r\n}\r\nstatic struct async *alloc_async(unsigned int numisoframes)\r\n{\r\nstruct async *as;\r\nas = kzalloc(sizeof(struct async), GFP_KERNEL);\r\nif (!as)\r\nreturn NULL;\r\nas->urb = usb_alloc_urb(numisoframes, GFP_KERNEL);\r\nif (!as->urb) {\r\nkfree(as);\r\nreturn NULL;\r\n}\r\nreturn as;\r\n}\r\nstatic void free_async(struct async *as)\r\n{\r\nput_pid(as->pid);\r\nif (as->cred)\r\nput_cred(as->cred);\r\nkfree(as->urb->transfer_buffer);\r\nkfree(as->urb->setup_packet);\r\nusb_free_urb(as->urb);\r\nusbfs_decrease_memory_usage(as->mem_usage);\r\nkfree(as);\r\n}\r\nstatic void async_newpending(struct async *as)\r\n{\r\nstruct dev_state *ps = as->ps;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ps->lock, flags);\r\nlist_add_tail(&as->asynclist, &ps->async_pending);\r\nspin_unlock_irqrestore(&ps->lock, flags);\r\n}\r\nstatic void async_removepending(struct async *as)\r\n{\r\nstruct dev_state *ps = as->ps;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ps->lock, flags);\r\nlist_del_init(&as->asynclist);\r\nspin_unlock_irqrestore(&ps->lock, flags);\r\n}\r\nstatic struct async *async_getcompleted(struct dev_state *ps)\r\n{\r\nunsigned long flags;\r\nstruct async *as = NULL;\r\nspin_lock_irqsave(&ps->lock, flags);\r\nif (!list_empty(&ps->async_completed)) {\r\nas = list_entry(ps->async_completed.next, struct async,\r\nasynclist);\r\nlist_del_init(&as->asynclist);\r\n}\r\nspin_unlock_irqrestore(&ps->lock, flags);\r\nreturn as;\r\n}\r\nstatic struct async *async_getpending(struct dev_state *ps,\r\nvoid __user *userurb)\r\n{\r\nunsigned long flags;\r\nstruct async *as;\r\nspin_lock_irqsave(&ps->lock, flags);\r\nlist_for_each_entry(as, &ps->async_pending, asynclist)\r\nif (as->userurb == userurb) {\r\nlist_del_init(&as->asynclist);\r\nspin_unlock_irqrestore(&ps->lock, flags);\r\nreturn as;\r\n}\r\nspin_unlock_irqrestore(&ps->lock, flags);\r\nreturn NULL;\r\n}\r\nstatic void snoop_urb(struct usb_device *udev,\r\nvoid __user *userurb, int pipe, unsigned length,\r\nint timeout_or_status, enum snoop_when when,\r\nunsigned char *data, unsigned data_len)\r\n{\r\nstatic const char *types[] = {"isoc", "int", "ctrl", "bulk"};\r\nstatic const char *dirs[] = {"out", "in"};\r\nint ep;\r\nconst char *t, *d;\r\nif (!usbfs_snoop)\r\nreturn;\r\nep = usb_pipeendpoint(pipe);\r\nt = types[usb_pipetype(pipe)];\r\nd = dirs[!!usb_pipein(pipe)];\r\nif (userurb) {\r\nif (when == SUBMIT)\r\ndev_info(&udev->dev, "userurb %p, ep%d %s-%s, "\r\n"length %u\n",\r\nuserurb, ep, t, d, length);\r\nelse\r\ndev_info(&udev->dev, "userurb %p, ep%d %s-%s, "\r\n"actual_length %u status %d\n",\r\nuserurb, ep, t, d, length,\r\ntimeout_or_status);\r\n} else {\r\nif (when == SUBMIT)\r\ndev_info(&udev->dev, "ep%d %s-%s, length %u, "\r\n"timeout %d\n",\r\nep, t, d, length, timeout_or_status);\r\nelse\r\ndev_info(&udev->dev, "ep%d %s-%s, actual_length %u, "\r\n"status %d\n",\r\nep, t, d, length, timeout_or_status);\r\n}\r\nif (data && data_len > 0) {\r\nprint_hex_dump(KERN_DEBUG, "data: ", DUMP_PREFIX_NONE, 32, 1,\r\ndata, data_len, 1);\r\n}\r\n}\r\nstatic void cancel_bulk_urbs(struct dev_state *ps, unsigned bulk_addr)\r\n__releases(ps->lock)\r\n__acquires(ps->lock)\r\n{\r\nstruct async *as;\r\nlist_for_each_entry(as, &ps->async_pending, asynclist) {\r\nif (as->bulk_addr == bulk_addr) {\r\nif (as->bulk_status != AS_CONTINUATION)\r\ngoto rescan;\r\nas->bulk_status = AS_UNLINK;\r\nas->bulk_addr = 0;\r\n}\r\n}\r\nps->disabled_bulk_eps |= (1 << bulk_addr);\r\nrescan:\r\nlist_for_each_entry(as, &ps->async_pending, asynclist) {\r\nif (as->bulk_status == AS_UNLINK) {\r\nas->bulk_status = 0;\r\nspin_unlock(&ps->lock);\r\nusb_unlink_urb(as->urb);\r\nspin_lock(&ps->lock);\r\ngoto rescan;\r\n}\r\n}\r\n}\r\nstatic void async_completed(struct urb *urb)\r\n{\r\nstruct async *as = urb->context;\r\nstruct dev_state *ps = as->ps;\r\nstruct siginfo sinfo;\r\nstruct pid *pid = NULL;\r\nu32 secid = 0;\r\nconst struct cred *cred = NULL;\r\nint signr;\r\nspin_lock(&ps->lock);\r\nlist_move_tail(&as->asynclist, &ps->async_completed);\r\nas->status = urb->status;\r\nsignr = as->signr;\r\nif (signr) {\r\nsinfo.si_signo = as->signr;\r\nsinfo.si_errno = as->status;\r\nsinfo.si_code = SI_ASYNCIO;\r\nsinfo.si_addr = as->userurb;\r\npid = get_pid(as->pid);\r\ncred = get_cred(as->cred);\r\nsecid = as->secid;\r\n}\r\nsnoop(&urb->dev->dev, "urb complete\n");\r\nsnoop_urb(urb->dev, as->userurb, urb->pipe, urb->actual_length,\r\nas->status, COMPLETE,\r\n((urb->transfer_flags & URB_DIR_MASK) == USB_DIR_OUT) ?\r\nNULL : urb->transfer_buffer, urb->actual_length);\r\nif (as->status < 0 && as->bulk_addr && as->status != -ECONNRESET &&\r\nas->status != -ENOENT)\r\ncancel_bulk_urbs(ps, as->bulk_addr);\r\nspin_unlock(&ps->lock);\r\nif (signr) {\r\nkill_pid_info_as_cred(sinfo.si_signo, &sinfo, pid, cred, secid);\r\nput_pid(pid);\r\nput_cred(cred);\r\n}\r\nwake_up(&ps->wait);\r\n}\r\nstatic void destroy_async(struct dev_state *ps, struct list_head *list)\r\n{\r\nstruct async *as;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ps->lock, flags);\r\nwhile (!list_empty(list)) {\r\nas = list_entry(list->next, struct async, asynclist);\r\nlist_del_init(&as->asynclist);\r\nspin_unlock_irqrestore(&ps->lock, flags);\r\nusb_kill_urb(as->urb);\r\nspin_lock_irqsave(&ps->lock, flags);\r\n}\r\nspin_unlock_irqrestore(&ps->lock, flags);\r\n}\r\nstatic void destroy_async_on_interface(struct dev_state *ps,\r\nunsigned int ifnum)\r\n{\r\nstruct list_head *p, *q, hitlist;\r\nunsigned long flags;\r\nINIT_LIST_HEAD(&hitlist);\r\nspin_lock_irqsave(&ps->lock, flags);\r\nlist_for_each_safe(p, q, &ps->async_pending)\r\nif (ifnum == list_entry(p, struct async, asynclist)->ifnum)\r\nlist_move_tail(p, &hitlist);\r\nspin_unlock_irqrestore(&ps->lock, flags);\r\ndestroy_async(ps, &hitlist);\r\n}\r\nstatic void destroy_all_async(struct dev_state *ps)\r\n{\r\ndestroy_async(ps, &ps->async_pending);\r\n}\r\nstatic int driver_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic void driver_disconnect(struct usb_interface *intf)\r\n{\r\nstruct dev_state *ps = usb_get_intfdata(intf);\r\nunsigned int ifnum = intf->altsetting->desc.bInterfaceNumber;\r\nif (!ps)\r\nreturn;\r\nif (likely(ifnum < 8*sizeof(ps->ifclaimed)))\r\nclear_bit(ifnum, &ps->ifclaimed);\r\nelse\r\ndev_warn(&intf->dev, "interface number %u out of range\n",\r\nifnum);\r\nusb_set_intfdata(intf, NULL);\r\ndestroy_async_on_interface(ps, ifnum);\r\n}\r\nstatic int driver_suspend(struct usb_interface *intf, pm_message_t msg)\r\n{\r\nreturn 0;\r\n}\r\nstatic int driver_resume(struct usb_interface *intf)\r\n{\r\nreturn 0;\r\n}\r\nstatic int claimintf(struct dev_state *ps, unsigned int ifnum)\r\n{\r\nstruct usb_device *dev = ps->dev;\r\nstruct usb_interface *intf;\r\nint err;\r\nif (ifnum >= 8*sizeof(ps->ifclaimed))\r\nreturn -EINVAL;\r\nif (test_bit(ifnum, &ps->ifclaimed))\r\nreturn 0;\r\nintf = usb_ifnum_to_if(dev, ifnum);\r\nif (!intf)\r\nerr = -ENOENT;\r\nelse\r\nerr = usb_driver_claim_interface(&usbfs_driver, intf, ps);\r\nif (err == 0)\r\nset_bit(ifnum, &ps->ifclaimed);\r\nreturn err;\r\n}\r\nstatic int releaseintf(struct dev_state *ps, unsigned int ifnum)\r\n{\r\nstruct usb_device *dev;\r\nstruct usb_interface *intf;\r\nint err;\r\nerr = -EINVAL;\r\nif (ifnum >= 8*sizeof(ps->ifclaimed))\r\nreturn err;\r\ndev = ps->dev;\r\nintf = usb_ifnum_to_if(dev, ifnum);\r\nif (!intf)\r\nerr = -ENOENT;\r\nelse if (test_and_clear_bit(ifnum, &ps->ifclaimed)) {\r\nusb_driver_release_interface(&usbfs_driver, intf);\r\nerr = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic int checkintf(struct dev_state *ps, unsigned int ifnum)\r\n{\r\nif (ps->dev->state != USB_STATE_CONFIGURED)\r\nreturn -EHOSTUNREACH;\r\nif (ifnum >= 8*sizeof(ps->ifclaimed))\r\nreturn -EINVAL;\r\nif (test_bit(ifnum, &ps->ifclaimed))\r\nreturn 0;\r\ndev_warn(&ps->dev->dev, "usbfs: process %d (%s) did not claim "\r\n"interface %u before use\n", task_pid_nr(current),\r\ncurrent->comm, ifnum);\r\nreturn claimintf(ps, ifnum);\r\n}\r\nstatic int findintfep(struct usb_device *dev, unsigned int ep)\r\n{\r\nunsigned int i, j, e;\r\nstruct usb_interface *intf;\r\nstruct usb_host_interface *alts;\r\nstruct usb_endpoint_descriptor *endpt;\r\nif (ep & ~(USB_DIR_IN|0xf))\r\nreturn -EINVAL;\r\nif (!dev->actconfig)\r\nreturn -ESRCH;\r\nfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {\r\nintf = dev->actconfig->interface[i];\r\nfor (j = 0; j < intf->num_altsetting; j++) {\r\nalts = &intf->altsetting[j];\r\nfor (e = 0; e < alts->desc.bNumEndpoints; e++) {\r\nendpt = &alts->endpoint[e].desc;\r\nif (endpt->bEndpointAddress == ep)\r\nreturn alts->desc.bInterfaceNumber;\r\n}\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int check_ctrlrecip(struct dev_state *ps, unsigned int requesttype,\r\nunsigned int request, unsigned int index)\r\n{\r\nint ret = 0;\r\nstruct usb_host_interface *alt_setting;\r\nif (ps->dev->state != USB_STATE_UNAUTHENTICATED\r\n&& ps->dev->state != USB_STATE_ADDRESS\r\n&& ps->dev->state != USB_STATE_CONFIGURED)\r\nreturn -EHOSTUNREACH;\r\nif (USB_TYPE_VENDOR == (USB_TYPE_MASK & requesttype))\r\nreturn 0;\r\nif (requesttype == 0xa1 && request == 0) {\r\nalt_setting = usb_find_alt_setting(ps->dev->actconfig,\r\nindex >> 8, index & 0xff);\r\nif (alt_setting\r\n&& alt_setting->desc.bInterfaceClass == USB_CLASS_PRINTER)\r\nindex >>= 8;\r\n}\r\nindex &= 0xff;\r\nswitch (requesttype & USB_RECIP_MASK) {\r\ncase USB_RECIP_ENDPOINT:\r\nret = findintfep(ps->dev, index);\r\nif (ret >= 0)\r\nret = checkintf(ps, ret);\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nret = checkintf(ps, index);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int match_devt(struct device *dev, void *data)\r\n{\r\nreturn dev->devt == (dev_t) (unsigned long) data;\r\n}\r\nstatic struct usb_device *usbdev_lookup_by_devt(dev_t devt)\r\n{\r\nstruct device *dev;\r\ndev = bus_find_device(&usb_bus_type, NULL,\r\n(void *) (unsigned long) devt, match_devt);\r\nif (!dev)\r\nreturn NULL;\r\nreturn container_of(dev, struct usb_device, dev);\r\n}\r\nstatic int usbdev_open(struct inode *inode, struct file *file)\r\n{\r\nstruct usb_device *dev = NULL;\r\nstruct dev_state *ps;\r\nint ret;\r\nret = -ENOMEM;\r\nps = kmalloc(sizeof(struct dev_state), GFP_KERNEL);\r\nif (!ps)\r\ngoto out_free_ps;\r\nret = -ENODEV;\r\nmutex_lock(&usbfs_mutex);\r\nif (imajor(inode) == USB_DEVICE_MAJOR)\r\ndev = usbdev_lookup_by_devt(inode->i_rdev);\r\n#ifdef CONFIG_USB_DEVICEFS\r\nif (!dev) {\r\ndev = inode->i_private;\r\nif (dev && dev->usbfs_dentry &&\r\ndev->usbfs_dentry->d_inode == inode)\r\nusb_get_dev(dev);\r\nelse\r\ndev = NULL;\r\n}\r\n#endif\r\nmutex_unlock(&usbfs_mutex);\r\nif (!dev)\r\ngoto out_free_ps;\r\nusb_lock_device(dev);\r\nif (dev->state == USB_STATE_NOTATTACHED)\r\ngoto out_unlock_device;\r\nret = usb_autoresume_device(dev);\r\nif (ret)\r\ngoto out_unlock_device;\r\nps->dev = dev;\r\nps->file = file;\r\nspin_lock_init(&ps->lock);\r\nINIT_LIST_HEAD(&ps->list);\r\nINIT_LIST_HEAD(&ps->async_pending);\r\nINIT_LIST_HEAD(&ps->async_completed);\r\ninit_waitqueue_head(&ps->wait);\r\nps->discsignr = 0;\r\nps->disc_pid = get_pid(task_pid(current));\r\nps->cred = get_current_cred();\r\nps->disccontext = NULL;\r\nps->ifclaimed = 0;\r\nsecurity_task_getsecid(current, &ps->secid);\r\nsmp_wmb();\r\nlist_add_tail(&ps->list, &dev->filelist);\r\nfile->private_data = ps;\r\nusb_unlock_device(dev);\r\nsnoop(&dev->dev, "opened by process %d: %s\n", task_pid_nr(current),\r\ncurrent->comm);\r\nreturn ret;\r\nout_unlock_device:\r\nusb_unlock_device(dev);\r\nusb_put_dev(dev);\r\nout_free_ps:\r\nkfree(ps);\r\nreturn ret;\r\n}\r\nstatic int usbdev_release(struct inode *inode, struct file *file)\r\n{\r\nstruct dev_state *ps = file->private_data;\r\nstruct usb_device *dev = ps->dev;\r\nunsigned int ifnum;\r\nstruct async *as;\r\nusb_lock_device(dev);\r\nusb_hub_release_all_ports(dev, ps);\r\nlist_del_init(&ps->list);\r\nfor (ifnum = 0; ps->ifclaimed && ifnum < 8*sizeof(ps->ifclaimed);\r\nifnum++) {\r\nif (test_bit(ifnum, &ps->ifclaimed))\r\nreleaseintf(ps, ifnum);\r\n}\r\ndestroy_all_async(ps);\r\nusb_autosuspend_device(dev);\r\nusb_unlock_device(dev);\r\nusb_put_dev(dev);\r\nput_pid(ps->disc_pid);\r\nput_cred(ps->cred);\r\nas = async_getcompleted(ps);\r\nwhile (as) {\r\nfree_async(as);\r\nas = async_getcompleted(ps);\r\n}\r\nkfree(ps);\r\nreturn 0;\r\n}\r\nstatic int proc_control(struct dev_state *ps, void __user *arg)\r\n{\r\nstruct usb_device *dev = ps->dev;\r\nstruct usbdevfs_ctrltransfer ctrl;\r\nunsigned int tmo;\r\nunsigned char *tbuf;\r\nunsigned wLength;\r\nint i, pipe, ret;\r\nif (copy_from_user(&ctrl, arg, sizeof(ctrl)))\r\nreturn -EFAULT;\r\nret = check_ctrlrecip(ps, ctrl.bRequestType, ctrl.bRequest,\r\nctrl.wIndex);\r\nif (ret)\r\nreturn ret;\r\nwLength = ctrl.wLength;\r\nif (wLength > PAGE_SIZE)\r\nreturn -EINVAL;\r\nret = usbfs_increase_memory_usage(PAGE_SIZE + sizeof(struct urb) +\r\nsizeof(struct usb_ctrlrequest));\r\nif (ret)\r\nreturn ret;\r\ntbuf = (unsigned char *)__get_free_page(GFP_KERNEL);\r\nif (!tbuf) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\ntmo = ctrl.timeout;\r\nsnoop(&dev->dev, "control urb: bRequestType=%02x "\r\n"bRequest=%02x wValue=%04x "\r\n"wIndex=%04x wLength=%04x\n",\r\nctrl.bRequestType, ctrl.bRequest,\r\n__le16_to_cpup(&ctrl.wValue),\r\n__le16_to_cpup(&ctrl.wIndex),\r\n__le16_to_cpup(&ctrl.wLength));\r\nif (ctrl.bRequestType & 0x80) {\r\nif (ctrl.wLength && !access_ok(VERIFY_WRITE, ctrl.data,\r\nctrl.wLength)) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\npipe = usb_rcvctrlpipe(dev, 0);\r\nsnoop_urb(dev, NULL, pipe, ctrl.wLength, tmo, SUBMIT, NULL, 0);\r\nusb_unlock_device(dev);\r\ni = usb_control_msg(dev, pipe, ctrl.bRequest,\r\nctrl.bRequestType, ctrl.wValue, ctrl.wIndex,\r\ntbuf, ctrl.wLength, tmo);\r\nusb_lock_device(dev);\r\nsnoop_urb(dev, NULL, pipe, max(i, 0), min(i, 0), COMPLETE,\r\ntbuf, max(i, 0));\r\nif ((i > 0) && ctrl.wLength) {\r\nif (copy_to_user(ctrl.data, tbuf, i)) {\r\nret = -EFAULT;\r\ngoto done;\r\n}\r\n}\r\n} else {\r\nif (ctrl.wLength) {\r\nif (copy_from_user(tbuf, ctrl.data, ctrl.wLength)) {\r\nret = -EFAULT;\r\ngoto done;\r\n}\r\n}\r\npipe = usb_sndctrlpipe(dev, 0);\r\nsnoop_urb(dev, NULL, pipe, ctrl.wLength, tmo, SUBMIT,\r\ntbuf, ctrl.wLength);\r\nusb_unlock_device(dev);\r\ni = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), ctrl.bRequest,\r\nctrl.bRequestType, ctrl.wValue, ctrl.wIndex,\r\ntbuf, ctrl.wLength, tmo);\r\nusb_lock_device(dev);\r\nsnoop_urb(dev, NULL, pipe, max(i, 0), min(i, 0), COMPLETE, NULL, 0);\r\n}\r\nif (i < 0 && i != -EPIPE) {\r\ndev_printk(KERN_DEBUG, &dev->dev, "usbfs: USBDEVFS_CONTROL "\r\n"failed cmd %s rqt %u rq %u len %u ret %d\n",\r\ncurrent->comm, ctrl.bRequestType, ctrl.bRequest,\r\nctrl.wLength, i);\r\n}\r\nret = i;\r\ndone:\r\nfree_page((unsigned long) tbuf);\r\nusbfs_decrease_memory_usage(PAGE_SIZE + sizeof(struct urb) +\r\nsizeof(struct usb_ctrlrequest));\r\nreturn ret;\r\n}\r\nstatic int proc_bulk(struct dev_state *ps, void __user *arg)\r\n{\r\nstruct usb_device *dev = ps->dev;\r\nstruct usbdevfs_bulktransfer bulk;\r\nunsigned int tmo, len1, pipe;\r\nint len2;\r\nunsigned char *tbuf;\r\nint i, ret;\r\nif (copy_from_user(&bulk, arg, sizeof(bulk)))\r\nreturn -EFAULT;\r\nret = findintfep(ps->dev, bulk.ep);\r\nif (ret < 0)\r\nreturn ret;\r\nret = checkintf(ps, ret);\r\nif (ret)\r\nreturn ret;\r\nif (bulk.ep & USB_DIR_IN)\r\npipe = usb_rcvbulkpipe(dev, bulk.ep & 0x7f);\r\nelse\r\npipe = usb_sndbulkpipe(dev, bulk.ep & 0x7f);\r\nif (!usb_maxpacket(dev, pipe, !(bulk.ep & USB_DIR_IN)))\r\nreturn -EINVAL;\r\nlen1 = bulk.len;\r\nif (len1 >= USBFS_XFER_MAX)\r\nreturn -EINVAL;\r\nret = usbfs_increase_memory_usage(len1 + sizeof(struct urb));\r\nif (ret)\r\nreturn ret;\r\nif (!(tbuf = kmalloc(len1, GFP_KERNEL))) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\ntmo = bulk.timeout;\r\nif (bulk.ep & 0x80) {\r\nif (len1 && !access_ok(VERIFY_WRITE, bulk.data, len1)) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nsnoop_urb(dev, NULL, pipe, len1, tmo, SUBMIT, NULL, 0);\r\nusb_unlock_device(dev);\r\ni = usb_bulk_msg(dev, pipe, tbuf, len1, &len2, tmo);\r\nusb_lock_device(dev);\r\nsnoop_urb(dev, NULL, pipe, len2, i, COMPLETE, tbuf, len2);\r\nif (!i && len2) {\r\nif (copy_to_user(bulk.data, tbuf, len2)) {\r\nret = -EFAULT;\r\ngoto done;\r\n}\r\n}\r\n} else {\r\nif (len1) {\r\nif (copy_from_user(tbuf, bulk.data, len1)) {\r\nret = -EFAULT;\r\ngoto done;\r\n}\r\n}\r\nsnoop_urb(dev, NULL, pipe, len1, tmo, SUBMIT, tbuf, len1);\r\nusb_unlock_device(dev);\r\ni = usb_bulk_msg(dev, pipe, tbuf, len1, &len2, tmo);\r\nusb_lock_device(dev);\r\nsnoop_urb(dev, NULL, pipe, len2, i, COMPLETE, NULL, 0);\r\n}\r\nret = (i < 0 ? i : len2);\r\ndone:\r\nkfree(tbuf);\r\nusbfs_decrease_memory_usage(len1 + sizeof(struct urb));\r\nreturn ret;\r\n}\r\nstatic int proc_resetep(struct dev_state *ps, void __user *arg)\r\n{\r\nunsigned int ep;\r\nint ret;\r\nif (get_user(ep, (unsigned int __user *)arg))\r\nreturn -EFAULT;\r\nret = findintfep(ps->dev, ep);\r\nif (ret < 0)\r\nreturn ret;\r\nret = checkintf(ps, ret);\r\nif (ret)\r\nreturn ret;\r\nusb_reset_endpoint(ps->dev, ep);\r\nreturn 0;\r\n}\r\nstatic int proc_clearhalt(struct dev_state *ps, void __user *arg)\r\n{\r\nunsigned int ep;\r\nint pipe;\r\nint ret;\r\nif (get_user(ep, (unsigned int __user *)arg))\r\nreturn -EFAULT;\r\nret = findintfep(ps->dev, ep);\r\nif (ret < 0)\r\nreturn ret;\r\nret = checkintf(ps, ret);\r\nif (ret)\r\nreturn ret;\r\nif (ep & USB_DIR_IN)\r\npipe = usb_rcvbulkpipe(ps->dev, ep & 0x7f);\r\nelse\r\npipe = usb_sndbulkpipe(ps->dev, ep & 0x7f);\r\nreturn usb_clear_halt(ps->dev, pipe);\r\n}\r\nstatic int proc_getdriver(struct dev_state *ps, void __user *arg)\r\n{\r\nstruct usbdevfs_getdriver gd;\r\nstruct usb_interface *intf;\r\nint ret;\r\nif (copy_from_user(&gd, arg, sizeof(gd)))\r\nreturn -EFAULT;\r\nintf = usb_ifnum_to_if(ps->dev, gd.interface);\r\nif (!intf || !intf->dev.driver)\r\nret = -ENODATA;\r\nelse {\r\nstrncpy(gd.driver, intf->dev.driver->name,\r\nsizeof(gd.driver));\r\nret = (copy_to_user(arg, &gd, sizeof(gd)) ? -EFAULT : 0);\r\n}\r\nreturn ret;\r\n}\r\nstatic int proc_connectinfo(struct dev_state *ps, void __user *arg)\r\n{\r\nstruct usbdevfs_connectinfo ci = {\r\n.devnum = ps->dev->devnum,\r\n.slow = ps->dev->speed == USB_SPEED_LOW\r\n};\r\nif (copy_to_user(arg, &ci, sizeof(ci)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int proc_resetdevice(struct dev_state *ps)\r\n{\r\nreturn usb_reset_device(ps->dev);\r\n}\r\nstatic int proc_setintf(struct dev_state *ps, void __user *arg)\r\n{\r\nstruct usbdevfs_setinterface setintf;\r\nint ret;\r\nif (copy_from_user(&setintf, arg, sizeof(setintf)))\r\nreturn -EFAULT;\r\nif ((ret = checkintf(ps, setintf.interface)))\r\nreturn ret;\r\nreturn usb_set_interface(ps->dev, setintf.interface,\r\nsetintf.altsetting);\r\n}\r\nstatic int proc_setconfig(struct dev_state *ps, void __user *arg)\r\n{\r\nint u;\r\nint status = 0;\r\nstruct usb_host_config *actconfig;\r\nif (get_user(u, (int __user *)arg))\r\nreturn -EFAULT;\r\nactconfig = ps->dev->actconfig;\r\nif (actconfig) {\r\nint i;\r\nfor (i = 0; i < actconfig->desc.bNumInterfaces; ++i) {\r\nif (usb_interface_claimed(actconfig->interface[i])) {\r\ndev_warn(&ps->dev->dev,\r\n"usbfs: interface %d claimed by %s "\r\n"while '%s' sets config #%d\n",\r\nactconfig->interface[i]\r\n->cur_altsetting\r\n->desc.bInterfaceNumber,\r\nactconfig->interface[i]\r\n->dev.driver->name,\r\ncurrent->comm, u);\r\nstatus = -EBUSY;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (status == 0) {\r\nif (actconfig && actconfig->desc.bConfigurationValue == u)\r\nstatus = usb_reset_configuration(ps->dev);\r\nelse\r\nstatus = usb_set_configuration(ps->dev, u);\r\n}\r\nreturn status;\r\n}\r\nstatic int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,\r\nstruct usbdevfs_iso_packet_desc __user *iso_frame_desc,\r\nvoid __user *arg)\r\n{\r\nstruct usbdevfs_iso_packet_desc *isopkt = NULL;\r\nstruct usb_host_endpoint *ep;\r\nstruct async *as = NULL;\r\nstruct usb_ctrlrequest *dr = NULL;\r\nunsigned int u, totlen, isofrmlen;\r\nint ret, ifnum = -1;\r\nint is_in;\r\nif (uurb->flags & ~(USBDEVFS_URB_ISO_ASAP |\r\nUSBDEVFS_URB_SHORT_NOT_OK |\r\nUSBDEVFS_URB_BULK_CONTINUATION |\r\nUSBDEVFS_URB_NO_FSBR |\r\nUSBDEVFS_URB_ZERO_PACKET |\r\nUSBDEVFS_URB_NO_INTERRUPT))\r\nreturn -EINVAL;\r\nif (uurb->buffer_length > 0 && !uurb->buffer)\r\nreturn -EINVAL;\r\nif (!(uurb->type == USBDEVFS_URB_TYPE_CONTROL &&\r\n(uurb->endpoint & ~USB_ENDPOINT_DIR_MASK) == 0)) {\r\nifnum = findintfep(ps->dev, uurb->endpoint);\r\nif (ifnum < 0)\r\nreturn ifnum;\r\nret = checkintf(ps, ifnum);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif ((uurb->endpoint & USB_ENDPOINT_DIR_MASK) != 0) {\r\nis_in = 1;\r\nep = ps->dev->ep_in[uurb->endpoint & USB_ENDPOINT_NUMBER_MASK];\r\n} else {\r\nis_in = 0;\r\nep = ps->dev->ep_out[uurb->endpoint & USB_ENDPOINT_NUMBER_MASK];\r\n}\r\nif (!ep)\r\nreturn -ENOENT;\r\nu = 0;\r\nswitch(uurb->type) {\r\ncase USBDEVFS_URB_TYPE_CONTROL:\r\nif (!usb_endpoint_xfer_control(&ep->desc))\r\nreturn -EINVAL;\r\nif (uurb->buffer_length < 8)\r\nreturn -EINVAL;\r\ndr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);\r\nif (!dr)\r\nreturn -ENOMEM;\r\nif (copy_from_user(dr, uurb->buffer, 8)) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\nif (uurb->buffer_length < (le16_to_cpup(&dr->wLength) + 8)) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nret = check_ctrlrecip(ps, dr->bRequestType, dr->bRequest,\r\nle16_to_cpup(&dr->wIndex));\r\nif (ret)\r\ngoto error;\r\nuurb->number_of_packets = 0;\r\nuurb->buffer_length = le16_to_cpup(&dr->wLength);\r\nuurb->buffer += 8;\r\nif ((dr->bRequestType & USB_DIR_IN) && uurb->buffer_length) {\r\nis_in = 1;\r\nuurb->endpoint |= USB_DIR_IN;\r\n} else {\r\nis_in = 0;\r\nuurb->endpoint &= ~USB_DIR_IN;\r\n}\r\nsnoop(&ps->dev->dev, "control urb: bRequestType=%02x "\r\n"bRequest=%02x wValue=%04x "\r\n"wIndex=%04x wLength=%04x\n",\r\ndr->bRequestType, dr->bRequest,\r\n__le16_to_cpup(&dr->wValue),\r\n__le16_to_cpup(&dr->wIndex),\r\n__le16_to_cpup(&dr->wLength));\r\nu = sizeof(struct usb_ctrlrequest);\r\nbreak;\r\ncase USBDEVFS_URB_TYPE_BULK:\r\nswitch (usb_endpoint_type(&ep->desc)) {\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nreturn -EINVAL;\r\ncase USB_ENDPOINT_XFER_INT:\r\nuurb->type = USBDEVFS_URB_TYPE_INTERRUPT;\r\ngoto interrupt_urb;\r\n}\r\nuurb->number_of_packets = 0;\r\nbreak;\r\ncase USBDEVFS_URB_TYPE_INTERRUPT:\r\nif (!usb_endpoint_xfer_int(&ep->desc))\r\nreturn -EINVAL;\r\ninterrupt_urb:\r\nuurb->number_of_packets = 0;\r\nbreak;\r\ncase USBDEVFS_URB_TYPE_ISO:\r\nif (uurb->number_of_packets < 1 ||\r\nuurb->number_of_packets > 128)\r\nreturn -EINVAL;\r\nif (!usb_endpoint_xfer_isoc(&ep->desc))\r\nreturn -EINVAL;\r\nisofrmlen = sizeof(struct usbdevfs_iso_packet_desc) *\r\nuurb->number_of_packets;\r\nif (!(isopkt = kmalloc(isofrmlen, GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nif (copy_from_user(isopkt, iso_frame_desc, isofrmlen)) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\nfor (totlen = u = 0; u < uurb->number_of_packets; u++) {\r\nif (isopkt[u].length > 8192) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\ntotlen += isopkt[u].length;\r\n}\r\nu *= sizeof(struct usb_iso_packet_descriptor);\r\nuurb->buffer_length = totlen;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (uurb->buffer_length >= USBFS_XFER_MAX) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nif (uurb->buffer_length > 0 &&\r\n!access_ok(is_in ? VERIFY_WRITE : VERIFY_READ,\r\nuurb->buffer, uurb->buffer_length)) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\nas = alloc_async(uurb->number_of_packets);\r\nif (!as) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nu += sizeof(struct async) + sizeof(struct urb) + uurb->buffer_length;\r\nret = usbfs_increase_memory_usage(u);\r\nif (ret)\r\ngoto error;\r\nas->mem_usage = u;\r\nif (uurb->buffer_length > 0) {\r\nas->urb->transfer_buffer = kmalloc(uurb->buffer_length,\r\nGFP_KERNEL);\r\nif (!as->urb->transfer_buffer) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (is_in && uurb->type == USBDEVFS_URB_TYPE_ISO)\r\nmemset(as->urb->transfer_buffer, 0,\r\nuurb->buffer_length);\r\n}\r\nas->urb->dev = ps->dev;\r\nas->urb->pipe = (uurb->type << 30) |\r\n__create_pipe(ps->dev, uurb->endpoint & 0xf) |\r\n(uurb->endpoint & USB_DIR_IN);\r\nu = (is_in ? URB_DIR_IN : URB_DIR_OUT);\r\nif (uurb->flags & USBDEVFS_URB_ISO_ASAP)\r\nu |= URB_ISO_ASAP;\r\nif (uurb->flags & USBDEVFS_URB_SHORT_NOT_OK)\r\nu |= URB_SHORT_NOT_OK;\r\nif (uurb->flags & USBDEVFS_URB_NO_FSBR)\r\nu |= URB_NO_FSBR;\r\nif (uurb->flags & USBDEVFS_URB_ZERO_PACKET)\r\nu |= URB_ZERO_PACKET;\r\nif (uurb->flags & USBDEVFS_URB_NO_INTERRUPT)\r\nu |= URB_NO_INTERRUPT;\r\nas->urb->transfer_flags = u;\r\nas->urb->transfer_buffer_length = uurb->buffer_length;\r\nas->urb->setup_packet = (unsigned char *)dr;\r\ndr = NULL;\r\nas->urb->start_frame = uurb->start_frame;\r\nas->urb->number_of_packets = uurb->number_of_packets;\r\nif (uurb->type == USBDEVFS_URB_TYPE_ISO ||\r\nps->dev->speed == USB_SPEED_HIGH)\r\nas->urb->interval = 1 << min(15, ep->desc.bInterval - 1);\r\nelse\r\nas->urb->interval = ep->desc.bInterval;\r\nas->urb->context = as;\r\nas->urb->complete = async_completed;\r\nfor (totlen = u = 0; u < uurb->number_of_packets; u++) {\r\nas->urb->iso_frame_desc[u].offset = totlen;\r\nas->urb->iso_frame_desc[u].length = isopkt[u].length;\r\ntotlen += isopkt[u].length;\r\n}\r\nkfree(isopkt);\r\nisopkt = NULL;\r\nas->ps = ps;\r\nas->userurb = arg;\r\nif (is_in && uurb->buffer_length > 0)\r\nas->userbuffer = uurb->buffer;\r\nelse\r\nas->userbuffer = NULL;\r\nas->signr = uurb->signr;\r\nas->ifnum = ifnum;\r\nas->pid = get_pid(task_pid(current));\r\nas->cred = get_current_cred();\r\nsecurity_task_getsecid(current, &as->secid);\r\nif (!is_in && uurb->buffer_length > 0) {\r\nif (copy_from_user(as->urb->transfer_buffer, uurb->buffer,\r\nuurb->buffer_length)) {\r\nret = -EFAULT;\r\ngoto error;\r\n}\r\n}\r\nsnoop_urb(ps->dev, as->userurb, as->urb->pipe,\r\nas->urb->transfer_buffer_length, 0, SUBMIT,\r\nis_in ? NULL : as->urb->transfer_buffer,\r\nuurb->buffer_length);\r\nasync_newpending(as);\r\nif (usb_endpoint_xfer_bulk(&ep->desc)) {\r\nspin_lock_irq(&ps->lock);\r\nas->bulk_addr = usb_endpoint_num(&ep->desc) |\r\n((ep->desc.bEndpointAddress & USB_ENDPOINT_DIR_MASK)\r\n>> 3);\r\nif (uurb->flags & USBDEVFS_URB_BULK_CONTINUATION)\r\nas->bulk_status = AS_CONTINUATION;\r\nelse\r\nps->disabled_bulk_eps &= ~(1 << as->bulk_addr);\r\nif (ps->disabled_bulk_eps & (1 << as->bulk_addr))\r\nret = -EREMOTEIO;\r\nelse\r\nret = usb_submit_urb(as->urb, GFP_ATOMIC);\r\nspin_unlock_irq(&ps->lock);\r\n} else {\r\nret = usb_submit_urb(as->urb, GFP_KERNEL);\r\n}\r\nif (ret) {\r\ndev_printk(KERN_DEBUG, &ps->dev->dev,\r\n"usbfs: usb_submit_urb returned %d\n", ret);\r\nsnoop_urb(ps->dev, as->userurb, as->urb->pipe,\r\n0, ret, COMPLETE, NULL, 0);\r\nasync_removepending(as);\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nkfree(isopkt);\r\nkfree(dr);\r\nif (as)\r\nfree_async(as);\r\nreturn ret;\r\n}\r\nstatic int proc_submiturb(struct dev_state *ps, void __user *arg)\r\n{\r\nstruct usbdevfs_urb uurb;\r\nif (copy_from_user(&uurb, arg, sizeof(uurb)))\r\nreturn -EFAULT;\r\nreturn proc_do_submiturb(ps, &uurb,\r\n(((struct usbdevfs_urb __user *)arg)->iso_frame_desc),\r\narg);\r\n}\r\nstatic int proc_unlinkurb(struct dev_state *ps, void __user *arg)\r\n{\r\nstruct async *as;\r\nas = async_getpending(ps, arg);\r\nif (!as)\r\nreturn -EINVAL;\r\nusb_kill_urb(as->urb);\r\nreturn 0;\r\n}\r\nstatic int processcompl(struct async *as, void __user * __user *arg)\r\n{\r\nstruct urb *urb = as->urb;\r\nstruct usbdevfs_urb __user *userurb = as->userurb;\r\nvoid __user *addr = as->userurb;\r\nunsigned int i;\r\nif (as->userbuffer && urb->actual_length) {\r\nif (urb->number_of_packets > 0)\r\ni = urb->transfer_buffer_length;\r\nelse\r\ni = urb->actual_length;\r\nif (copy_to_user(as->userbuffer, urb->transfer_buffer, i))\r\ngoto err_out;\r\n}\r\nif (put_user(as->status, &userurb->status))\r\ngoto err_out;\r\nif (put_user(urb->actual_length, &userurb->actual_length))\r\ngoto err_out;\r\nif (put_user(urb->error_count, &userurb->error_count))\r\ngoto err_out;\r\nif (usb_endpoint_xfer_isoc(&urb->ep->desc)) {\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nif (put_user(urb->iso_frame_desc[i].actual_length,\r\n&userurb->iso_frame_desc[i].actual_length))\r\ngoto err_out;\r\nif (put_user(urb->iso_frame_desc[i].status,\r\n&userurb->iso_frame_desc[i].status))\r\ngoto err_out;\r\n}\r\n}\r\nif (put_user(addr, (void __user * __user *)arg))\r\nreturn -EFAULT;\r\nreturn 0;\r\nerr_out:\r\nreturn -EFAULT;\r\n}\r\nstatic struct async *reap_as(struct dev_state *ps)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nstruct async *as = NULL;\r\nstruct usb_device *dev = ps->dev;\r\nadd_wait_queue(&ps->wait, &wait);\r\nfor (;;) {\r\n__set_current_state(TASK_INTERRUPTIBLE);\r\nas = async_getcompleted(ps);\r\nif (as)\r\nbreak;\r\nif (signal_pending(current))\r\nbreak;\r\nusb_unlock_device(dev);\r\nschedule();\r\nusb_lock_device(dev);\r\n}\r\nremove_wait_queue(&ps->wait, &wait);\r\nset_current_state(TASK_RUNNING);\r\nreturn as;\r\n}\r\nstatic int proc_reapurb(struct dev_state *ps, void __user *arg)\r\n{\r\nstruct async *as = reap_as(ps);\r\nif (as) {\r\nint retval = processcompl(as, (void __user * __user *)arg);\r\nfree_async(as);\r\nreturn retval;\r\n}\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nreturn -EIO;\r\n}\r\nstatic int proc_reapurbnonblock(struct dev_state *ps, void __user *arg)\r\n{\r\nint retval;\r\nstruct async *as;\r\nas = async_getcompleted(ps);\r\nretval = -EAGAIN;\r\nif (as) {\r\nretval = processcompl(as, (void __user * __user *)arg);\r\nfree_async(as);\r\n}\r\nreturn retval;\r\n}\r\nstatic int proc_control_compat(struct dev_state *ps,\r\nstruct usbdevfs_ctrltransfer32 __user *p32)\r\n{\r\nstruct usbdevfs_ctrltransfer __user *p;\r\n__u32 udata;\r\np = compat_alloc_user_space(sizeof(*p));\r\nif (copy_in_user(p, p32, (sizeof(*p32) - sizeof(compat_caddr_t))) ||\r\nget_user(udata, &p32->data) ||\r\nput_user(compat_ptr(udata), &p->data))\r\nreturn -EFAULT;\r\nreturn proc_control(ps, p);\r\n}\r\nstatic int proc_bulk_compat(struct dev_state *ps,\r\nstruct usbdevfs_bulktransfer32 __user *p32)\r\n{\r\nstruct usbdevfs_bulktransfer __user *p;\r\ncompat_uint_t n;\r\ncompat_caddr_t addr;\r\np = compat_alloc_user_space(sizeof(*p));\r\nif (get_user(n, &p32->ep) || put_user(n, &p->ep) ||\r\nget_user(n, &p32->len) || put_user(n, &p->len) ||\r\nget_user(n, &p32->timeout) || put_user(n, &p->timeout) ||\r\nget_user(addr, &p32->data) || put_user(compat_ptr(addr), &p->data))\r\nreturn -EFAULT;\r\nreturn proc_bulk(ps, p);\r\n}\r\nstatic int proc_disconnectsignal_compat(struct dev_state *ps, void __user *arg)\r\n{\r\nstruct usbdevfs_disconnectsignal32 ds;\r\nif (copy_from_user(&ds, arg, sizeof(ds)))\r\nreturn -EFAULT;\r\nps->discsignr = ds.signr;\r\nps->disccontext = compat_ptr(ds.context);\r\nreturn 0;\r\n}\r\nstatic int get_urb32(struct usbdevfs_urb *kurb,\r\nstruct usbdevfs_urb32 __user *uurb)\r\n{\r\n__u32 uptr;\r\nif (!access_ok(VERIFY_READ, uurb, sizeof(*uurb)) ||\r\n__get_user(kurb->type, &uurb->type) ||\r\n__get_user(kurb->endpoint, &uurb->endpoint) ||\r\n__get_user(kurb->status, &uurb->status) ||\r\n__get_user(kurb->flags, &uurb->flags) ||\r\n__get_user(kurb->buffer_length, &uurb->buffer_length) ||\r\n__get_user(kurb->actual_length, &uurb->actual_length) ||\r\n__get_user(kurb->start_frame, &uurb->start_frame) ||\r\n__get_user(kurb->number_of_packets, &uurb->number_of_packets) ||\r\n__get_user(kurb->error_count, &uurb->error_count) ||\r\n__get_user(kurb->signr, &uurb->signr))\r\nreturn -EFAULT;\r\nif (__get_user(uptr, &uurb->buffer))\r\nreturn -EFAULT;\r\nkurb->buffer = compat_ptr(uptr);\r\nif (__get_user(uptr, &uurb->usercontext))\r\nreturn -EFAULT;\r\nkurb->usercontext = compat_ptr(uptr);\r\nreturn 0;\r\n}\r\nstatic int proc_submiturb_compat(struct dev_state *ps, void __user *arg)\r\n{\r\nstruct usbdevfs_urb uurb;\r\nif (get_urb32(&uurb, (struct usbdevfs_urb32 __user *)arg))\r\nreturn -EFAULT;\r\nreturn proc_do_submiturb(ps, &uurb,\r\n((struct usbdevfs_urb32 __user *)arg)->iso_frame_desc,\r\narg);\r\n}\r\nstatic int processcompl_compat(struct async *as, void __user * __user *arg)\r\n{\r\nstruct urb *urb = as->urb;\r\nstruct usbdevfs_urb32 __user *userurb = as->userurb;\r\nvoid __user *addr = as->userurb;\r\nunsigned int i;\r\nif (as->userbuffer && urb->actual_length)\r\nif (copy_to_user(as->userbuffer, urb->transfer_buffer,\r\nurb->actual_length))\r\nreturn -EFAULT;\r\nif (put_user(as->status, &userurb->status))\r\nreturn -EFAULT;\r\nif (put_user(urb->actual_length, &userurb->actual_length))\r\nreturn -EFAULT;\r\nif (put_user(urb->error_count, &userurb->error_count))\r\nreturn -EFAULT;\r\nif (usb_endpoint_xfer_isoc(&urb->ep->desc)) {\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nif (put_user(urb->iso_frame_desc[i].actual_length,\r\n&userurb->iso_frame_desc[i].actual_length))\r\nreturn -EFAULT;\r\nif (put_user(urb->iso_frame_desc[i].status,\r\n&userurb->iso_frame_desc[i].status))\r\nreturn -EFAULT;\r\n}\r\n}\r\nif (put_user(ptr_to_compat(addr), (u32 __user *)arg))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int proc_reapurb_compat(struct dev_state *ps, void __user *arg)\r\n{\r\nstruct async *as = reap_as(ps);\r\nif (as) {\r\nint retval = processcompl_compat(as, (void __user * __user *)arg);\r\nfree_async(as);\r\nreturn retval;\r\n}\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nreturn -EIO;\r\n}\r\nstatic int proc_reapurbnonblock_compat(struct dev_state *ps, void __user *arg)\r\n{\r\nint retval;\r\nstruct async *as;\r\nretval = -EAGAIN;\r\nas = async_getcompleted(ps);\r\nif (as) {\r\nretval = processcompl_compat(as, (void __user * __user *)arg);\r\nfree_async(as);\r\n}\r\nreturn retval;\r\n}\r\nstatic int proc_disconnectsignal(struct dev_state *ps, void __user *arg)\r\n{\r\nstruct usbdevfs_disconnectsignal ds;\r\nif (copy_from_user(&ds, arg, sizeof(ds)))\r\nreturn -EFAULT;\r\nps->discsignr = ds.signr;\r\nps->disccontext = ds.context;\r\nreturn 0;\r\n}\r\nstatic int proc_claiminterface(struct dev_state *ps, void __user *arg)\r\n{\r\nunsigned int ifnum;\r\nif (get_user(ifnum, (unsigned int __user *)arg))\r\nreturn -EFAULT;\r\nreturn claimintf(ps, ifnum);\r\n}\r\nstatic int proc_releaseinterface(struct dev_state *ps, void __user *arg)\r\n{\r\nunsigned int ifnum;\r\nint ret;\r\nif (get_user(ifnum, (unsigned int __user *)arg))\r\nreturn -EFAULT;\r\nif ((ret = releaseintf(ps, ifnum)) < 0)\r\nreturn ret;\r\ndestroy_async_on_interface (ps, ifnum);\r\nreturn 0;\r\n}\r\nstatic int proc_ioctl(struct dev_state *ps, struct usbdevfs_ioctl *ctl)\r\n{\r\nint size;\r\nvoid *buf = NULL;\r\nint retval = 0;\r\nstruct usb_interface *intf = NULL;\r\nstruct usb_driver *driver = NULL;\r\nif ((size = _IOC_SIZE(ctl->ioctl_code)) > 0) {\r\nif ((buf = kmalloc(size, GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\nif ((_IOC_DIR(ctl->ioctl_code) & _IOC_WRITE)) {\r\nif (copy_from_user(buf, ctl->data, size)) {\r\nkfree(buf);\r\nreturn -EFAULT;\r\n}\r\n} else {\r\nmemset(buf, 0, size);\r\n}\r\n}\r\nif (!connected(ps)) {\r\nkfree(buf);\r\nreturn -ENODEV;\r\n}\r\nif (ps->dev->state != USB_STATE_CONFIGURED)\r\nretval = -EHOSTUNREACH;\r\nelse if (!(intf = usb_ifnum_to_if(ps->dev, ctl->ifno)))\r\nretval = -EINVAL;\r\nelse switch (ctl->ioctl_code) {\r\ncase USBDEVFS_DISCONNECT:\r\nif (intf->dev.driver) {\r\ndriver = to_usb_driver(intf->dev.driver);\r\ndev_dbg(&intf->dev, "disconnect by usbfs\n");\r\nusb_driver_release_interface(driver, intf);\r\n} else\r\nretval = -ENODATA;\r\nbreak;\r\ncase USBDEVFS_CONNECT:\r\nif (!intf->dev.driver)\r\nretval = device_attach(&intf->dev);\r\nelse\r\nretval = -EBUSY;\r\nbreak;\r\ndefault:\r\nif (intf->dev.driver)\r\ndriver = to_usb_driver(intf->dev.driver);\r\nif (driver == NULL || driver->unlocked_ioctl == NULL) {\r\nretval = -ENOTTY;\r\n} else {\r\nretval = driver->unlocked_ioctl(intf, ctl->ioctl_code, buf);\r\nif (retval == -ENOIOCTLCMD)\r\nretval = -ENOTTY;\r\n}\r\n}\r\nif (retval >= 0\r\n&& (_IOC_DIR(ctl->ioctl_code) & _IOC_READ) != 0\r\n&& size > 0\r\n&& copy_to_user(ctl->data, buf, size) != 0)\r\nretval = -EFAULT;\r\nkfree(buf);\r\nreturn retval;\r\n}\r\nstatic int proc_ioctl_default(struct dev_state *ps, void __user *arg)\r\n{\r\nstruct usbdevfs_ioctl ctrl;\r\nif (copy_from_user(&ctrl, arg, sizeof(ctrl)))\r\nreturn -EFAULT;\r\nreturn proc_ioctl(ps, &ctrl);\r\n}\r\nstatic int proc_ioctl_compat(struct dev_state *ps, compat_uptr_t arg)\r\n{\r\nstruct usbdevfs_ioctl32 __user *uioc;\r\nstruct usbdevfs_ioctl ctrl;\r\nu32 udata;\r\nuioc = compat_ptr((long)arg);\r\nif (!access_ok(VERIFY_READ, uioc, sizeof(*uioc)) ||\r\n__get_user(ctrl.ifno, &uioc->ifno) ||\r\n__get_user(ctrl.ioctl_code, &uioc->ioctl_code) ||\r\n__get_user(udata, &uioc->data))\r\nreturn -EFAULT;\r\nctrl.data = compat_ptr(udata);\r\nreturn proc_ioctl(ps, &ctrl);\r\n}\r\nstatic int proc_claim_port(struct dev_state *ps, void __user *arg)\r\n{\r\nunsigned portnum;\r\nint rc;\r\nif (get_user(portnum, (unsigned __user *) arg))\r\nreturn -EFAULT;\r\nrc = usb_hub_claim_port(ps->dev, portnum, ps);\r\nif (rc == 0)\r\nsnoop(&ps->dev->dev, "port %d claimed by process %d: %s\n",\r\nportnum, task_pid_nr(current), current->comm);\r\nreturn rc;\r\n}\r\nstatic int proc_release_port(struct dev_state *ps, void __user *arg)\r\n{\r\nunsigned portnum;\r\nif (get_user(portnum, (unsigned __user *) arg))\r\nreturn -EFAULT;\r\nreturn usb_hub_release_port(ps->dev, portnum, ps);\r\n}\r\nstatic long usbdev_do_ioctl(struct file *file, unsigned int cmd,\r\nvoid __user *p)\r\n{\r\nstruct dev_state *ps = file->private_data;\r\nstruct inode *inode = file->f_path.dentry->d_inode;\r\nstruct usb_device *dev = ps->dev;\r\nint ret = -ENOTTY;\r\nif (!(file->f_mode & FMODE_WRITE))\r\nreturn -EPERM;\r\nusb_lock_device(dev);\r\nif (!connected(ps)) {\r\nusb_unlock_device(dev);\r\nreturn -ENODEV;\r\n}\r\nswitch (cmd) {\r\ncase USBDEVFS_CONTROL:\r\nsnoop(&dev->dev, "%s: CONTROL\n", __func__);\r\nret = proc_control(ps, p);\r\nif (ret >= 0)\r\ninode->i_mtime = CURRENT_TIME;\r\nbreak;\r\ncase USBDEVFS_BULK:\r\nsnoop(&dev->dev, "%s: BULK\n", __func__);\r\nret = proc_bulk(ps, p);\r\nif (ret >= 0)\r\ninode->i_mtime = CURRENT_TIME;\r\nbreak;\r\ncase USBDEVFS_RESETEP:\r\nsnoop(&dev->dev, "%s: RESETEP\n", __func__);\r\nret = proc_resetep(ps, p);\r\nif (ret >= 0)\r\ninode->i_mtime = CURRENT_TIME;\r\nbreak;\r\ncase USBDEVFS_RESET:\r\nsnoop(&dev->dev, "%s: RESET\n", __func__);\r\nret = proc_resetdevice(ps);\r\nbreak;\r\ncase USBDEVFS_CLEAR_HALT:\r\nsnoop(&dev->dev, "%s: CLEAR_HALT\n", __func__);\r\nret = proc_clearhalt(ps, p);\r\nif (ret >= 0)\r\ninode->i_mtime = CURRENT_TIME;\r\nbreak;\r\ncase USBDEVFS_GETDRIVER:\r\nsnoop(&dev->dev, "%s: GETDRIVER\n", __func__);\r\nret = proc_getdriver(ps, p);\r\nbreak;\r\ncase USBDEVFS_CONNECTINFO:\r\nsnoop(&dev->dev, "%s: CONNECTINFO\n", __func__);\r\nret = proc_connectinfo(ps, p);\r\nbreak;\r\ncase USBDEVFS_SETINTERFACE:\r\nsnoop(&dev->dev, "%s: SETINTERFACE\n", __func__);\r\nret = proc_setintf(ps, p);\r\nbreak;\r\ncase USBDEVFS_SETCONFIGURATION:\r\nsnoop(&dev->dev, "%s: SETCONFIGURATION\n", __func__);\r\nret = proc_setconfig(ps, p);\r\nbreak;\r\ncase USBDEVFS_SUBMITURB:\r\nsnoop(&dev->dev, "%s: SUBMITURB\n", __func__);\r\nret = proc_submiturb(ps, p);\r\nif (ret >= 0)\r\ninode->i_mtime = CURRENT_TIME;\r\nbreak;\r\n#ifdef CONFIG_COMPAT\r\ncase USBDEVFS_CONTROL32:\r\nsnoop(&dev->dev, "%s: CONTROL32\n", __func__);\r\nret = proc_control_compat(ps, p);\r\nif (ret >= 0)\r\ninode->i_mtime = CURRENT_TIME;\r\nbreak;\r\ncase USBDEVFS_BULK32:\r\nsnoop(&dev->dev, "%s: BULK32\n", __func__);\r\nret = proc_bulk_compat(ps, p);\r\nif (ret >= 0)\r\ninode->i_mtime = CURRENT_TIME;\r\nbreak;\r\ncase USBDEVFS_DISCSIGNAL32:\r\nsnoop(&dev->dev, "%s: DISCSIGNAL32\n", __func__);\r\nret = proc_disconnectsignal_compat(ps, p);\r\nbreak;\r\ncase USBDEVFS_SUBMITURB32:\r\nsnoop(&dev->dev, "%s: SUBMITURB32\n", __func__);\r\nret = proc_submiturb_compat(ps, p);\r\nif (ret >= 0)\r\ninode->i_mtime = CURRENT_TIME;\r\nbreak;\r\ncase USBDEVFS_REAPURB32:\r\nsnoop(&dev->dev, "%s: REAPURB32\n", __func__);\r\nret = proc_reapurb_compat(ps, p);\r\nbreak;\r\ncase USBDEVFS_REAPURBNDELAY32:\r\nsnoop(&dev->dev, "%s: REAPURBNDELAY32\n", __func__);\r\nret = proc_reapurbnonblock_compat(ps, p);\r\nbreak;\r\ncase USBDEVFS_IOCTL32:\r\nsnoop(&dev->dev, "%s: IOCTL32\n", __func__);\r\nret = proc_ioctl_compat(ps, ptr_to_compat(p));\r\nbreak;\r\n#endif\r\ncase USBDEVFS_DISCARDURB:\r\nsnoop(&dev->dev, "%s: DISCARDURB\n", __func__);\r\nret = proc_unlinkurb(ps, p);\r\nbreak;\r\ncase USBDEVFS_REAPURB:\r\nsnoop(&dev->dev, "%s: REAPURB\n", __func__);\r\nret = proc_reapurb(ps, p);\r\nbreak;\r\ncase USBDEVFS_REAPURBNDELAY:\r\nsnoop(&dev->dev, "%s: REAPURBNDELAY\n", __func__);\r\nret = proc_reapurbnonblock(ps, p);\r\nbreak;\r\ncase USBDEVFS_DISCSIGNAL:\r\nsnoop(&dev->dev, "%s: DISCSIGNAL\n", __func__);\r\nret = proc_disconnectsignal(ps, p);\r\nbreak;\r\ncase USBDEVFS_CLAIMINTERFACE:\r\nsnoop(&dev->dev, "%s: CLAIMINTERFACE\n", __func__);\r\nret = proc_claiminterface(ps, p);\r\nbreak;\r\ncase USBDEVFS_RELEASEINTERFACE:\r\nsnoop(&dev->dev, "%s: RELEASEINTERFACE\n", __func__);\r\nret = proc_releaseinterface(ps, p);\r\nbreak;\r\ncase USBDEVFS_IOCTL:\r\nsnoop(&dev->dev, "%s: IOCTL\n", __func__);\r\nret = proc_ioctl_default(ps, p);\r\nbreak;\r\ncase USBDEVFS_CLAIM_PORT:\r\nsnoop(&dev->dev, "%s: CLAIM_PORT\n", __func__);\r\nret = proc_claim_port(ps, p);\r\nbreak;\r\ncase USBDEVFS_RELEASE_PORT:\r\nsnoop(&dev->dev, "%s: RELEASE_PORT\n", __func__);\r\nret = proc_release_port(ps, p);\r\nbreak;\r\n}\r\nusb_unlock_device(dev);\r\nif (ret >= 0)\r\ninode->i_atime = CURRENT_TIME;\r\nreturn ret;\r\n}\r\nstatic long usbdev_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint ret;\r\nret = usbdev_do_ioctl(file, cmd, (void __user *)arg);\r\nreturn ret;\r\n}\r\nstatic long usbdev_compat_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint ret;\r\nret = usbdev_do_ioctl(file, cmd, compat_ptr(arg));\r\nreturn ret;\r\n}\r\nstatic unsigned int usbdev_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct dev_state *ps = file->private_data;\r\nunsigned int mask = 0;\r\npoll_wait(file, &ps->wait, wait);\r\nif (file->f_mode & FMODE_WRITE && !list_empty(&ps->async_completed))\r\nmask |= POLLOUT | POLLWRNORM;\r\nif (!connected(ps))\r\nmask |= POLLERR | POLLHUP;\r\nreturn mask;\r\n}\r\nstatic void usbdev_remove(struct usb_device *udev)\r\n{\r\nstruct dev_state *ps;\r\nstruct siginfo sinfo;\r\nwhile (!list_empty(&udev->filelist)) {\r\nps = list_entry(udev->filelist.next, struct dev_state, list);\r\ndestroy_all_async(ps);\r\nwake_up_all(&ps->wait);\r\nlist_del_init(&ps->list);\r\nif (ps->discsignr) {\r\nsinfo.si_signo = ps->discsignr;\r\nsinfo.si_errno = EPIPE;\r\nsinfo.si_code = SI_ASYNCIO;\r\nsinfo.si_addr = ps->disccontext;\r\nkill_pid_info_as_cred(ps->discsignr, &sinfo,\r\nps->disc_pid, ps->cred, ps->secid);\r\n}\r\n}\r\n}\r\nstatic int usb_classdev_add(struct usb_device *dev)\r\n{\r\nstruct device *cldev;\r\ncldev = device_create(usb_classdev_class, &dev->dev, dev->dev.devt,\r\nNULL, "usbdev%d.%d", dev->bus->busnum,\r\ndev->devnum);\r\nif (IS_ERR(cldev))\r\nreturn PTR_ERR(cldev);\r\ndev->usb_classdev = cldev;\r\nreturn 0;\r\n}\r\nstatic void usb_classdev_remove(struct usb_device *dev)\r\n{\r\nif (dev->usb_classdev)\r\ndevice_unregister(dev->usb_classdev);\r\n}\r\nstatic int usbdev_notify(struct notifier_block *self,\r\nunsigned long action, void *dev)\r\n{\r\nswitch (action) {\r\ncase USB_DEVICE_ADD:\r\nif (usb_classdev_add(dev))\r\nreturn NOTIFY_BAD;\r\nbreak;\r\ncase USB_DEVICE_REMOVE:\r\nusb_classdev_remove(dev);\r\nusbdev_remove(dev);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nint __init usb_devio_init(void)\r\n{\r\nint retval;\r\nretval = register_chrdev_region(USB_DEVICE_DEV, USB_DEVICE_MAX,\r\n"usb_device");\r\nif (retval) {\r\nprintk(KERN_ERR "Unable to register minors for usb_device\n");\r\ngoto out;\r\n}\r\ncdev_init(&usb_device_cdev, &usbdev_file_operations);\r\nretval = cdev_add(&usb_device_cdev, USB_DEVICE_DEV, USB_DEVICE_MAX);\r\nif (retval) {\r\nprintk(KERN_ERR "Unable to get usb_device major %d\n",\r\nUSB_DEVICE_MAJOR);\r\ngoto error_cdev;\r\n}\r\n#ifdef CONFIG_USB_DEVICE_CLASS\r\nusb_classdev_class = class_create(THIS_MODULE, "usb_device");\r\nif (IS_ERR(usb_classdev_class)) {\r\nprintk(KERN_ERR "Unable to register usb_device class\n");\r\nretval = PTR_ERR(usb_classdev_class);\r\ncdev_del(&usb_device_cdev);\r\nusb_classdev_class = NULL;\r\ngoto out;\r\n}\r\nusb_classdev_class->dev_kobj = NULL;\r\n#endif\r\nusb_register_notify(&usbdev_nb);\r\nout:\r\nreturn retval;\r\nerror_cdev:\r\nunregister_chrdev_region(USB_DEVICE_DEV, USB_DEVICE_MAX);\r\ngoto out;\r\n}\r\nvoid usb_devio_cleanup(void)\r\n{\r\nusb_unregister_notify(&usbdev_nb);\r\n#ifdef CONFIG_USB_DEVICE_CLASS\r\nclass_destroy(usb_classdev_class);\r\n#endif\r\ncdev_del(&usb_device_cdev);\r\nunregister_chrdev_region(USB_DEVICE_DEV, USB_DEVICE_MAX);\r\n}
