static int conf_space_read(struct pci_dev *dev,\r\nconst struct config_field_entry *entry,\r\nint offset, u32 *value)\r\n{\r\nint ret = 0;\r\nconst struct config_field *field = entry->field;\r\n*value = 0;\r\nswitch (field->size) {\r\ncase 1:\r\nif (field->u.b.read)\r\nret = field->u.b.read(dev, offset, (u8 *) value,\r\nentry->data);\r\nbreak;\r\ncase 2:\r\nif (field->u.w.read)\r\nret = field->u.w.read(dev, offset, (u16 *) value,\r\nentry->data);\r\nbreak;\r\ncase 4:\r\nif (field->u.dw.read)\r\nret = field->u.dw.read(dev, offset, value, entry->data);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int conf_space_write(struct pci_dev *dev,\r\nconst struct config_field_entry *entry,\r\nint offset, u32 value)\r\n{\r\nint ret = 0;\r\nconst struct config_field *field = entry->field;\r\nswitch (field->size) {\r\ncase 1:\r\nif (field->u.b.write)\r\nret = field->u.b.write(dev, offset, (u8) value,\r\nentry->data);\r\nbreak;\r\ncase 2:\r\nif (field->u.w.write)\r\nret = field->u.w.write(dev, offset, (u16) value,\r\nentry->data);\r\nbreak;\r\ncase 4:\r\nif (field->u.dw.write)\r\nret = field->u.dw.write(dev, offset, value,\r\nentry->data);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline u32 get_mask(int size)\r\n{\r\nif (size == 1)\r\nreturn 0xff;\r\nelse if (size == 2)\r\nreturn 0xffff;\r\nelse\r\nreturn 0xffffffff;\r\n}\r\nstatic inline int valid_request(int offset, int size)\r\n{\r\nif ((size == 1 || size == 2 || size == 4) && (offset % size) == 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline u32 merge_value(u32 val, u32 new_val, u32 new_val_mask,\r\nint offset)\r\n{\r\nif (offset >= 0) {\r\nnew_val_mask <<= (offset * 8);\r\nnew_val <<= (offset * 8);\r\n} else {\r\nnew_val_mask >>= (offset * -8);\r\nnew_val >>= (offset * -8);\r\n}\r\nval = (val & ~new_val_mask) | (new_val & new_val_mask);\r\nreturn val;\r\n}\r\nstatic int pcibios_err_to_errno(int err)\r\n{\r\nswitch (err) {\r\ncase PCIBIOS_SUCCESSFUL:\r\nreturn XEN_PCI_ERR_success;\r\ncase PCIBIOS_DEVICE_NOT_FOUND:\r\nreturn XEN_PCI_ERR_dev_not_found;\r\ncase PCIBIOS_BAD_REGISTER_NUMBER:\r\nreturn XEN_PCI_ERR_invalid_offset;\r\ncase PCIBIOS_FUNC_NOT_SUPPORTED:\r\nreturn XEN_PCI_ERR_not_implemented;\r\ncase PCIBIOS_SET_FAILED:\r\nreturn XEN_PCI_ERR_access_denied;\r\n}\r\nreturn err;\r\n}\r\nint xen_pcibk_config_read(struct pci_dev *dev, int offset, int size,\r\nu32 *ret_val)\r\n{\r\nint err = 0;\r\nstruct xen_pcibk_dev_data *dev_data = pci_get_drvdata(dev);\r\nconst struct config_field_entry *cfg_entry;\r\nconst struct config_field *field;\r\nint req_start, req_end, field_start, field_end;\r\nu32 value = 0, tmp_val;\r\nif (unlikely(verbose_request))\r\nprintk(KERN_DEBUG DRV_NAME ": %s: read %d bytes at 0x%x\n",\r\npci_name(dev), size, offset);\r\nif (!valid_request(offset, size)) {\r\nerr = XEN_PCI_ERR_invalid_offset;\r\ngoto out;\r\n}\r\nswitch (size) {\r\ncase 1:\r\nerr = pci_read_config_byte(dev, offset, (u8 *) &value);\r\nbreak;\r\ncase 2:\r\nerr = pci_read_config_word(dev, offset, (u16 *) &value);\r\nbreak;\r\ncase 4:\r\nerr = pci_read_config_dword(dev, offset, &value);\r\nbreak;\r\n}\r\nlist_for_each_entry(cfg_entry, &dev_data->config_fields, list) {\r\nfield = cfg_entry->field;\r\nreq_start = offset;\r\nreq_end = offset + size;\r\nfield_start = OFFSET(cfg_entry);\r\nfield_end = OFFSET(cfg_entry) + field->size;\r\nif ((req_start >= field_start && req_start < field_end)\r\n|| (req_end > field_start && req_end <= field_end)) {\r\nerr = conf_space_read(dev, cfg_entry, field_start,\r\n&tmp_val);\r\nif (err)\r\ngoto out;\r\nvalue = merge_value(value, tmp_val,\r\nget_mask(field->size),\r\nfield_start - req_start);\r\n}\r\n}\r\nout:\r\nif (unlikely(verbose_request))\r\nprintk(KERN_DEBUG DRV_NAME ": %s: read %d bytes at 0x%x = %x\n",\r\npci_name(dev), size, offset, value);\r\n*ret_val = value;\r\nreturn pcibios_err_to_errno(err);\r\n}\r\nint xen_pcibk_config_write(struct pci_dev *dev, int offset, int size, u32 value)\r\n{\r\nint err = 0, handled = 0;\r\nstruct xen_pcibk_dev_data *dev_data = pci_get_drvdata(dev);\r\nconst struct config_field_entry *cfg_entry;\r\nconst struct config_field *field;\r\nu32 tmp_val;\r\nint req_start, req_end, field_start, field_end;\r\nif (unlikely(verbose_request))\r\nprintk(KERN_DEBUG\r\nDRV_NAME ": %s: write request %d bytes at 0x%x = %x\n",\r\npci_name(dev), size, offset, value);\r\nif (!valid_request(offset, size))\r\nreturn XEN_PCI_ERR_invalid_offset;\r\nlist_for_each_entry(cfg_entry, &dev_data->config_fields, list) {\r\nfield = cfg_entry->field;\r\nreq_start = offset;\r\nreq_end = offset + size;\r\nfield_start = OFFSET(cfg_entry);\r\nfield_end = OFFSET(cfg_entry) + field->size;\r\nif ((req_start >= field_start && req_start < field_end)\r\n|| (req_end > field_start && req_end <= field_end)) {\r\ntmp_val = 0;\r\nerr = xen_pcibk_config_read(dev, field_start,\r\nfield->size, &tmp_val);\r\nif (err)\r\nbreak;\r\ntmp_val = merge_value(tmp_val, value, get_mask(size),\r\nreq_start - field_start);\r\nerr = conf_space_write(dev, cfg_entry, field_start,\r\ntmp_val);\r\nhandled = 1;\r\n}\r\n}\r\nif (!handled && !err) {\r\nif (dev_data->permissive || permissive) {\r\nswitch (size) {\r\ncase 1:\r\nerr = pci_write_config_byte(dev, offset,\r\n(u8) value);\r\nbreak;\r\ncase 2:\r\nerr = pci_write_config_word(dev, offset,\r\n(u16) value);\r\nbreak;\r\ncase 4:\r\nerr = pci_write_config_dword(dev, offset,\r\n(u32) value);\r\nbreak;\r\n}\r\n} else if (!dev_data->warned_on_write) {\r\ndev_data->warned_on_write = 1;\r\ndev_warn(&dev->dev, "Driver tried to write to a "\r\n"read-only configuration space field at offset"\r\n" 0x%x, size %d. This may be harmless, but if "\r\n"you have problems with your device:\n"\r\n"1) see permissive attribute in sysfs\n"\r\n"2) report problems to the xen-devel "\r\n"mailing list along with details of your "\r\n"device obtained from lspci.\n", offset, size);\r\n}\r\n}\r\nreturn pcibios_err_to_errno(err);\r\n}\r\nvoid xen_pcibk_config_free_dyn_fields(struct pci_dev *dev)\r\n{\r\nstruct xen_pcibk_dev_data *dev_data = pci_get_drvdata(dev);\r\nstruct config_field_entry *cfg_entry, *t;\r\nconst struct config_field *field;\r\ndev_dbg(&dev->dev, "free-ing dynamically allocated virtual "\r\n"configuration space fields\n");\r\nif (!dev_data)\r\nreturn;\r\nlist_for_each_entry_safe(cfg_entry, t, &dev_data->config_fields, list) {\r\nfield = cfg_entry->field;\r\nif (field->clean) {\r\nfield->clean((struct config_field *)field);\r\nkfree(cfg_entry->data);\r\nlist_del(&cfg_entry->list);\r\nkfree(cfg_entry);\r\n}\r\n}\r\n}\r\nvoid xen_pcibk_config_reset_dev(struct pci_dev *dev)\r\n{\r\nstruct xen_pcibk_dev_data *dev_data = pci_get_drvdata(dev);\r\nconst struct config_field_entry *cfg_entry;\r\nconst struct config_field *field;\r\ndev_dbg(&dev->dev, "resetting virtual configuration space\n");\r\nif (!dev_data)\r\nreturn;\r\nlist_for_each_entry(cfg_entry, &dev_data->config_fields, list) {\r\nfield = cfg_entry->field;\r\nif (field->reset)\r\nfield->reset(dev, OFFSET(cfg_entry), cfg_entry->data);\r\n}\r\n}\r\nvoid xen_pcibk_config_free_dev(struct pci_dev *dev)\r\n{\r\nstruct xen_pcibk_dev_data *dev_data = pci_get_drvdata(dev);\r\nstruct config_field_entry *cfg_entry, *t;\r\nconst struct config_field *field;\r\ndev_dbg(&dev->dev, "free-ing virtual configuration space fields\n");\r\nif (!dev_data)\r\nreturn;\r\nlist_for_each_entry_safe(cfg_entry, t, &dev_data->config_fields, list) {\r\nlist_del(&cfg_entry->list);\r\nfield = cfg_entry->field;\r\nif (field->release)\r\nfield->release(dev, OFFSET(cfg_entry), cfg_entry->data);\r\nkfree(cfg_entry);\r\n}\r\n}\r\nint xen_pcibk_config_add_field_offset(struct pci_dev *dev,\r\nconst struct config_field *field,\r\nunsigned int base_offset)\r\n{\r\nint err = 0;\r\nstruct xen_pcibk_dev_data *dev_data = pci_get_drvdata(dev);\r\nstruct config_field_entry *cfg_entry;\r\nvoid *tmp;\r\ncfg_entry = kmalloc(sizeof(*cfg_entry), GFP_KERNEL);\r\nif (!cfg_entry) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\ncfg_entry->data = NULL;\r\ncfg_entry->field = field;\r\ncfg_entry->base_offset = base_offset;\r\nerr = xen_pcibk_field_is_dup(dev, OFFSET(cfg_entry));\r\nif (err)\r\ngoto out;\r\nif (field->init) {\r\ntmp = field->init(dev, OFFSET(cfg_entry));\r\nif (IS_ERR(tmp)) {\r\nerr = PTR_ERR(tmp);\r\ngoto out;\r\n}\r\ncfg_entry->data = tmp;\r\n}\r\ndev_dbg(&dev->dev, "added config field at offset 0x%02x\n",\r\nOFFSET(cfg_entry));\r\nlist_add_tail(&cfg_entry->list, &dev_data->config_fields);\r\nout:\r\nif (err)\r\nkfree(cfg_entry);\r\nreturn err;\r\n}\r\nint xen_pcibk_config_init_dev(struct pci_dev *dev)\r\n{\r\nint err = 0;\r\nstruct xen_pcibk_dev_data *dev_data = pci_get_drvdata(dev);\r\ndev_dbg(&dev->dev, "initializing virtual configuration space\n");\r\nINIT_LIST_HEAD(&dev_data->config_fields);\r\nerr = xen_pcibk_config_header_add_fields(dev);\r\nif (err)\r\ngoto out;\r\nerr = xen_pcibk_config_capability_add_fields(dev);\r\nif (err)\r\ngoto out;\r\nerr = xen_pcibk_config_quirks_init(dev);\r\nout:\r\nreturn err;\r\n}\r\nint xen_pcibk_config_init(void)\r\n{\r\nreturn xen_pcibk_config_capability_init();\r\n}
