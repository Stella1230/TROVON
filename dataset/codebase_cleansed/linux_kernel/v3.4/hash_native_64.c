static inline void __tlbie(unsigned long va, int psize, int ssize)\r\n{\r\nunsigned int penc;\r\nva &= ~(0xffffULL << 48);\r\nswitch (psize) {\r\ncase MMU_PAGE_4K:\r\nva &= ~0xffful;\r\nva |= ssize << 8;\r\nasm volatile(ASM_FTR_IFCLR("tlbie %0,0", PPC_TLBIE(%1,%0), %2)\r\n: : "r" (va), "r"(0), "i" (CPU_FTR_ARCH_206)\r\n: "memory");\r\nbreak;\r\ndefault:\r\npenc = mmu_psize_defs[psize].penc;\r\nva &= ~((1ul << mmu_psize_defs[psize].shift) - 1);\r\nva |= penc << 12;\r\nva |= ssize << 8;\r\nva |= 1;\r\nasm volatile(ASM_FTR_IFCLR("tlbie %0,1", PPC_TLBIE(%1,%0), %2)\r\n: : "r" (va), "r"(0), "i" (CPU_FTR_ARCH_206)\r\n: "memory");\r\nbreak;\r\n}\r\n}\r\nstatic inline void __tlbiel(unsigned long va, int psize, int ssize)\r\n{\r\nunsigned int penc;\r\nva &= ~(0xffffULL << 48);\r\nswitch (psize) {\r\ncase MMU_PAGE_4K:\r\nva &= ~0xffful;\r\nva |= ssize << 8;\r\nasm volatile(".long 0x7c000224 | (%0 << 11) | (0 << 21)"\r\n: : "r"(va) : "memory");\r\nbreak;\r\ndefault:\r\npenc = mmu_psize_defs[psize].penc;\r\nva &= ~((1ul << mmu_psize_defs[psize].shift) - 1);\r\nva |= penc << 12;\r\nva |= ssize << 8;\r\nva |= 1;\r\nasm volatile(".long 0x7c000224 | (%0 << 11) | (1 << 21)"\r\n: : "r"(va) : "memory");\r\nbreak;\r\n}\r\n}\r\nstatic inline void tlbie(unsigned long va, int psize, int ssize, int local)\r\n{\r\nunsigned int use_local = local && mmu_has_feature(MMU_FTR_TLBIEL);\r\nint lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);\r\nif (use_local)\r\nuse_local = mmu_psize_defs[psize].tlbiel;\r\nif (lock_tlbie && !use_local)\r\nraw_spin_lock(&native_tlbie_lock);\r\nasm volatile("ptesync": : :"memory");\r\nif (use_local) {\r\n__tlbiel(va, psize, ssize);\r\nasm volatile("ptesync": : :"memory");\r\n} else {\r\n__tlbie(va, psize, ssize);\r\nasm volatile("eieio; tlbsync; ptesync": : :"memory");\r\n}\r\nif (lock_tlbie && !use_local)\r\nraw_spin_unlock(&native_tlbie_lock);\r\n}\r\nstatic inline void native_lock_hpte(struct hash_pte *hptep)\r\n{\r\nunsigned long *word = &hptep->v;\r\nwhile (1) {\r\nif (!test_and_set_bit_lock(HPTE_LOCK_BIT, word))\r\nbreak;\r\nwhile(test_bit(HPTE_LOCK_BIT, word))\r\ncpu_relax();\r\n}\r\n}\r\nstatic inline void native_unlock_hpte(struct hash_pte *hptep)\r\n{\r\nunsigned long *word = &hptep->v;\r\nclear_bit_unlock(HPTE_LOCK_BIT, word);\r\n}\r\nstatic long native_hpte_insert(unsigned long hpte_group, unsigned long va,\r\nunsigned long pa, unsigned long rflags,\r\nunsigned long vflags, int psize, int ssize)\r\n{\r\nstruct hash_pte *hptep = htab_address + hpte_group;\r\nunsigned long hpte_v, hpte_r;\r\nint i;\r\nif (!(vflags & HPTE_V_BOLTED)) {\r\nDBG_LOW(" insert(group=%lx, va=%016lx, pa=%016lx,"\r\n" rflags=%lx, vflags=%lx, psize=%d)\n",\r\nhpte_group, va, pa, rflags, vflags, psize);\r\n}\r\nfor (i = 0; i < HPTES_PER_GROUP; i++) {\r\nif (! (hptep->v & HPTE_V_VALID)) {\r\nnative_lock_hpte(hptep);\r\nif (! (hptep->v & HPTE_V_VALID))\r\nbreak;\r\nnative_unlock_hpte(hptep);\r\n}\r\nhptep++;\r\n}\r\nif (i == HPTES_PER_GROUP)\r\nreturn -1;\r\nhpte_v = hpte_encode_v(va, psize, ssize) | vflags | HPTE_V_VALID;\r\nhpte_r = hpte_encode_r(pa, psize) | rflags;\r\nif (!(vflags & HPTE_V_BOLTED)) {\r\nDBG_LOW(" i=%x hpte_v=%016lx, hpte_r=%016lx\n",\r\ni, hpte_v, hpte_r);\r\n}\r\nhptep->r = hpte_r;\r\neieio();\r\nhptep->v = hpte_v;\r\n__asm__ __volatile__ ("ptesync" : : : "memory");\r\nreturn i | (!!(vflags & HPTE_V_SECONDARY) << 3);\r\n}\r\nstatic long native_hpte_remove(unsigned long hpte_group)\r\n{\r\nstruct hash_pte *hptep;\r\nint i;\r\nint slot_offset;\r\nunsigned long hpte_v;\r\nDBG_LOW(" remove(group=%lx)\n", hpte_group);\r\nslot_offset = mftb() & 0x7;\r\nfor (i = 0; i < HPTES_PER_GROUP; i++) {\r\nhptep = htab_address + hpte_group + slot_offset;\r\nhpte_v = hptep->v;\r\nif ((hpte_v & HPTE_V_VALID) && !(hpte_v & HPTE_V_BOLTED)) {\r\nnative_lock_hpte(hptep);\r\nhpte_v = hptep->v;\r\nif ((hpte_v & HPTE_V_VALID)\r\n&& !(hpte_v & HPTE_V_BOLTED))\r\nbreak;\r\nnative_unlock_hpte(hptep);\r\n}\r\nslot_offset++;\r\nslot_offset &= 0x7;\r\n}\r\nif (i == HPTES_PER_GROUP)\r\nreturn -1;\r\nhptep->v = 0;\r\nreturn i;\r\n}\r\nstatic long native_hpte_updatepp(unsigned long slot, unsigned long newpp,\r\nunsigned long va, int psize, int ssize,\r\nint local)\r\n{\r\nstruct hash_pte *hptep = htab_address + slot;\r\nunsigned long hpte_v, want_v;\r\nint ret = 0;\r\nwant_v = hpte_encode_v(va, psize, ssize);\r\nDBG_LOW(" update(va=%016lx, avpnv=%016lx, hash=%016lx, newpp=%x)",\r\nva, want_v & HPTE_V_AVPN, slot, newpp);\r\nnative_lock_hpte(hptep);\r\nhpte_v = hptep->v;\r\nif (!HPTE_V_COMPARE(hpte_v, want_v) || !(hpte_v & HPTE_V_VALID)) {\r\nDBG_LOW(" -> miss\n");\r\nret = -1;\r\n} else {\r\nDBG_LOW(" -> hit\n");\r\nhptep->r = (hptep->r & ~(HPTE_R_PP | HPTE_R_N)) |\r\n(newpp & (HPTE_R_PP | HPTE_R_N | HPTE_R_C));\r\n}\r\nnative_unlock_hpte(hptep);\r\ntlbie(va, psize, ssize, local);\r\nreturn ret;\r\n}\r\nstatic long native_hpte_find(unsigned long va, int psize, int ssize)\r\n{\r\nstruct hash_pte *hptep;\r\nunsigned long hash;\r\nunsigned long i;\r\nlong slot;\r\nunsigned long want_v, hpte_v;\r\nhash = hpt_hash(va, mmu_psize_defs[psize].shift, ssize);\r\nwant_v = hpte_encode_v(va, psize, ssize);\r\nslot = (hash & htab_hash_mask) * HPTES_PER_GROUP;\r\nfor (i = 0; i < HPTES_PER_GROUP; i++) {\r\nhptep = htab_address + slot;\r\nhpte_v = hptep->v;\r\nif (HPTE_V_COMPARE(hpte_v, want_v) && (hpte_v & HPTE_V_VALID))\r\nreturn slot;\r\n++slot;\r\n}\r\nreturn -1;\r\n}\r\nstatic void native_hpte_updateboltedpp(unsigned long newpp, unsigned long ea,\r\nint psize, int ssize)\r\n{\r\nunsigned long vsid, va;\r\nlong slot;\r\nstruct hash_pte *hptep;\r\nvsid = get_kernel_vsid(ea, ssize);\r\nva = hpt_va(ea, vsid, ssize);\r\nslot = native_hpte_find(va, psize, ssize);\r\nif (slot == -1)\r\npanic("could not find page to bolt\n");\r\nhptep = htab_address + slot;\r\nhptep->r = (hptep->r & ~(HPTE_R_PP | HPTE_R_N)) |\r\n(newpp & (HPTE_R_PP | HPTE_R_N));\r\ntlbie(va, psize, ssize, 0);\r\n}\r\nstatic void native_hpte_invalidate(unsigned long slot, unsigned long va,\r\nint psize, int ssize, int local)\r\n{\r\nstruct hash_pte *hptep = htab_address + slot;\r\nunsigned long hpte_v;\r\nunsigned long want_v;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nDBG_LOW(" invalidate(va=%016lx, hash: %x)\n", va, slot);\r\nwant_v = hpte_encode_v(va, psize, ssize);\r\nnative_lock_hpte(hptep);\r\nhpte_v = hptep->v;\r\nif (!HPTE_V_COMPARE(hpte_v, want_v) || !(hpte_v & HPTE_V_VALID))\r\nnative_unlock_hpte(hptep);\r\nelse\r\nhptep->v = 0;\r\ntlbie(va, psize, ssize, local);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void hpte_decode(struct hash_pte *hpte, unsigned long slot,\r\nint *psize, int *ssize, unsigned long *va)\r\n{\r\nunsigned long hpte_r = hpte->r;\r\nunsigned long hpte_v = hpte->v;\r\nunsigned long avpn;\r\nint i, size, shift, penc;\r\nif (!(hpte_v & HPTE_V_LARGE))\r\nsize = MMU_PAGE_4K;\r\nelse {\r\nfor (i = 0; i < LP_BITS; i++) {\r\nif ((hpte_r & LP_MASK(i+1)) == LP_MASK(i+1))\r\nbreak;\r\n}\r\npenc = LP_MASK(i+1) >> LP_SHIFT;\r\nfor (size = 0; size < MMU_PAGE_COUNT; size++) {\r\nif (size == MMU_PAGE_4K)\r\ncontinue;\r\nif (!mmu_psize_defs[size].shift)\r\ncontinue;\r\nif (penc == mmu_psize_defs[size].penc)\r\nbreak;\r\n}\r\n}\r\nshift = mmu_psize_defs[size].shift;\r\navpn = (HPTE_V_AVPN_VAL(hpte_v) & ~mmu_psize_defs[size].avpnm) << 23;\r\nif (shift < 23) {\r\nunsigned long vpi, vsid, pteg;\r\npteg = slot / HPTES_PER_GROUP;\r\nif (hpte_v & HPTE_V_SECONDARY)\r\npteg = ~pteg;\r\nswitch (hpte_v >> HPTE_V_SSIZE_SHIFT) {\r\ncase MMU_SEGSIZE_256M:\r\nvpi = ((avpn >> 28) ^ pteg) & htab_hash_mask;\r\nbreak;\r\ncase MMU_SEGSIZE_1T:\r\nvsid = avpn >> 40;\r\nvpi = (vsid ^ (vsid << 25) ^ pteg) & htab_hash_mask;\r\nbreak;\r\ndefault:\r\navpn = vpi = size = 0;\r\n}\r\navpn |= (vpi << mmu_psize_defs[size].shift);\r\n}\r\n*va = avpn;\r\n*psize = size;\r\n*ssize = hpte_v >> HPTE_V_SSIZE_SHIFT;\r\n}\r\nstatic void native_hpte_clear(void)\r\n{\r\nunsigned long slot, slots, flags;\r\nstruct hash_pte *hptep = htab_address;\r\nunsigned long hpte_v, va;\r\nunsigned long pteg_count;\r\nint psize, ssize;\r\npteg_count = htab_hash_mask + 1;\r\nlocal_irq_save(flags);\r\nraw_spin_lock(&native_tlbie_lock);\r\nslots = pteg_count * HPTES_PER_GROUP;\r\nfor (slot = 0; slot < slots; slot++, hptep++) {\r\nhpte_v = hptep->v;\r\nif (hpte_v & HPTE_V_VALID) {\r\nhpte_decode(hptep, slot, &psize, &ssize, &va);\r\nhptep->v = 0;\r\n__tlbie(va, psize, ssize);\r\n}\r\n}\r\nasm volatile("eieio; tlbsync; ptesync":::"memory");\r\nraw_spin_unlock(&native_tlbie_lock);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void native_flush_hash_range(unsigned long number, int local)\r\n{\r\nunsigned long va, hash, index, hidx, shift, slot;\r\nstruct hash_pte *hptep;\r\nunsigned long hpte_v;\r\nunsigned long want_v;\r\nunsigned long flags;\r\nreal_pte_t pte;\r\nstruct ppc64_tlb_batch *batch = &__get_cpu_var(ppc64_tlb_batch);\r\nunsigned long psize = batch->psize;\r\nint ssize = batch->ssize;\r\nint i;\r\nlocal_irq_save(flags);\r\nfor (i = 0; i < number; i++) {\r\nva = batch->vaddr[i];\r\npte = batch->pte[i];\r\npte_iterate_hashed_subpages(pte, psize, va, index, shift) {\r\nhash = hpt_hash(va, shift, ssize);\r\nhidx = __rpte_to_hidx(pte, index);\r\nif (hidx & _PTEIDX_SECONDARY)\r\nhash = ~hash;\r\nslot = (hash & htab_hash_mask) * HPTES_PER_GROUP;\r\nslot += hidx & _PTEIDX_GROUP_IX;\r\nhptep = htab_address + slot;\r\nwant_v = hpte_encode_v(va, psize, ssize);\r\nnative_lock_hpte(hptep);\r\nhpte_v = hptep->v;\r\nif (!HPTE_V_COMPARE(hpte_v, want_v) ||\r\n!(hpte_v & HPTE_V_VALID))\r\nnative_unlock_hpte(hptep);\r\nelse\r\nhptep->v = 0;\r\n} pte_iterate_hashed_end();\r\n}\r\nif (mmu_has_feature(MMU_FTR_TLBIEL) &&\r\nmmu_psize_defs[psize].tlbiel && local) {\r\nasm volatile("ptesync":::"memory");\r\nfor (i = 0; i < number; i++) {\r\nva = batch->vaddr[i];\r\npte = batch->pte[i];\r\npte_iterate_hashed_subpages(pte, psize, va, index,\r\nshift) {\r\n__tlbiel(va, psize, ssize);\r\n} pte_iterate_hashed_end();\r\n}\r\nasm volatile("ptesync":::"memory");\r\n} else {\r\nint lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);\r\nif (lock_tlbie)\r\nraw_spin_lock(&native_tlbie_lock);\r\nasm volatile("ptesync":::"memory");\r\nfor (i = 0; i < number; i++) {\r\nva = batch->vaddr[i];\r\npte = batch->pte[i];\r\npte_iterate_hashed_subpages(pte, psize, va, index,\r\nshift) {\r\n__tlbie(va, psize, ssize);\r\n} pte_iterate_hashed_end();\r\n}\r\nasm volatile("eieio; tlbsync; ptesync":::"memory");\r\nif (lock_tlbie)\r\nraw_spin_unlock(&native_tlbie_lock);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nstatic inline int tlb_batching_enabled(void)\r\n{\r\nstruct device_node *root = of_find_node_by_path("/");\r\nint enabled = 1;\r\nif (root) {\r\nconst char *model = of_get_property(root, "model", NULL);\r\nif (model && !strcmp(model, "IBM,9076-N81"))\r\nenabled = 0;\r\nof_node_put(root);\r\n}\r\nreturn enabled;\r\n}\r\nstatic inline int tlb_batching_enabled(void)\r\n{\r\nreturn 1;\r\n}\r\nvoid __init hpte_init_native(void)\r\n{\r\nppc_md.hpte_invalidate = native_hpte_invalidate;\r\nppc_md.hpte_updatepp = native_hpte_updatepp;\r\nppc_md.hpte_updateboltedpp = native_hpte_updateboltedpp;\r\nppc_md.hpte_insert = native_hpte_insert;\r\nppc_md.hpte_remove = native_hpte_remove;\r\nppc_md.hpte_clear_all = native_hpte_clear;\r\nif (tlb_batching_enabled())\r\nppc_md.flush_hash_range = native_flush_hash_range;\r\n}
