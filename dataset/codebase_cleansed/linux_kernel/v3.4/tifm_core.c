static const char *tifm_media_type_name(unsigned char type, unsigned char nt)\r\n{\r\nconst char *card_type_name[3][3] = {\r\n{ "SmartMedia/xD", "MemoryStick", "MMC/SD" },\r\n{ "XD", "MS", "SD"},\r\n{ "xd", "ms", "sd"}\r\n};\r\nif (nt > 2 || type < 1 || type > 3)\r\nreturn NULL;\r\nreturn card_type_name[nt][type - 1];\r\n}\r\nstatic int tifm_dev_match(struct tifm_dev *sock, struct tifm_device_id *id)\r\n{\r\nif (sock->type == id->type)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int tifm_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct tifm_dev *sock = container_of(dev, struct tifm_dev, dev);\r\nstruct tifm_driver *fm_drv = container_of(drv, struct tifm_driver,\r\ndriver);\r\nstruct tifm_device_id *ids = fm_drv->id_table;\r\nif (ids) {\r\nwhile (ids->type) {\r\nif (tifm_dev_match(sock, ids))\r\nreturn 1;\r\n++ids;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tifm_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct tifm_dev *sock = container_of(dev, struct tifm_dev, dev);\r\nif (add_uevent_var(env, "TIFM_CARD_TYPE=%s", tifm_media_type_name(sock->type, 1)))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int tifm_device_probe(struct device *dev)\r\n{\r\nstruct tifm_dev *sock = container_of(dev, struct tifm_dev, dev);\r\nstruct tifm_driver *drv = container_of(dev->driver, struct tifm_driver,\r\ndriver);\r\nint rc = -ENODEV;\r\nget_device(dev);\r\nif (dev->driver && drv->probe) {\r\nrc = drv->probe(sock);\r\nif (!rc)\r\nreturn 0;\r\n}\r\nput_device(dev);\r\nreturn rc;\r\n}\r\nstatic void tifm_dummy_event(struct tifm_dev *sock)\r\n{\r\nreturn;\r\n}\r\nstatic int tifm_device_remove(struct device *dev)\r\n{\r\nstruct tifm_dev *sock = container_of(dev, struct tifm_dev, dev);\r\nstruct tifm_driver *drv = container_of(dev->driver, struct tifm_driver,\r\ndriver);\r\nif (dev->driver && drv->remove) {\r\nsock->card_event = tifm_dummy_event;\r\nsock->data_event = tifm_dummy_event;\r\ndrv->remove(sock);\r\nsock->dev.driver = NULL;\r\n}\r\nput_device(dev);\r\nreturn 0;\r\n}\r\nstatic int tifm_device_suspend(struct device *dev, pm_message_t state)\r\n{\r\nstruct tifm_dev *sock = container_of(dev, struct tifm_dev, dev);\r\nstruct tifm_driver *drv = container_of(dev->driver, struct tifm_driver,\r\ndriver);\r\nif (dev->driver && drv->suspend)\r\nreturn drv->suspend(sock, state);\r\nreturn 0;\r\n}\r\nstatic int tifm_device_resume(struct device *dev)\r\n{\r\nstruct tifm_dev *sock = container_of(dev, struct tifm_dev, dev);\r\nstruct tifm_driver *drv = container_of(dev->driver, struct tifm_driver,\r\ndriver);\r\nif (dev->driver && drv->resume)\r\nreturn drv->resume(sock);\r\nreturn 0;\r\n}\r\nstatic ssize_t type_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct tifm_dev *sock = container_of(dev, struct tifm_dev, dev);\r\nreturn sprintf(buf, "%x", sock->type);\r\n}\r\nstatic void tifm_free(struct device *dev)\r\n{\r\nstruct tifm_adapter *fm = container_of(dev, struct tifm_adapter, dev);\r\nkfree(fm);\r\n}\r\nstruct tifm_adapter *tifm_alloc_adapter(unsigned int num_sockets,\r\nstruct device *dev)\r\n{\r\nstruct tifm_adapter *fm;\r\nfm = kzalloc(sizeof(struct tifm_adapter)\r\n+ sizeof(struct tifm_dev*) * num_sockets, GFP_KERNEL);\r\nif (fm) {\r\nfm->dev.class = &tifm_adapter_class;\r\nfm->dev.parent = dev;\r\ndevice_initialize(&fm->dev);\r\nspin_lock_init(&fm->lock);\r\nfm->num_sockets = num_sockets;\r\n}\r\nreturn fm;\r\n}\r\nint tifm_add_adapter(struct tifm_adapter *fm)\r\n{\r\nint rc;\r\nif (!idr_pre_get(&tifm_adapter_idr, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nspin_lock(&tifm_adapter_lock);\r\nrc = idr_get_new(&tifm_adapter_idr, fm, &fm->id);\r\nspin_unlock(&tifm_adapter_lock);\r\nif (rc)\r\nreturn rc;\r\ndev_set_name(&fm->dev, "tifm%u", fm->id);\r\nrc = device_add(&fm->dev);\r\nif (rc) {\r\nspin_lock(&tifm_adapter_lock);\r\nidr_remove(&tifm_adapter_idr, fm->id);\r\nspin_unlock(&tifm_adapter_lock);\r\n}\r\nreturn rc;\r\n}\r\nvoid tifm_remove_adapter(struct tifm_adapter *fm)\r\n{\r\nunsigned int cnt;\r\nflush_workqueue(workqueue);\r\nfor (cnt = 0; cnt < fm->num_sockets; ++cnt) {\r\nif (fm->sockets[cnt])\r\ndevice_unregister(&fm->sockets[cnt]->dev);\r\n}\r\nspin_lock(&tifm_adapter_lock);\r\nidr_remove(&tifm_adapter_idr, fm->id);\r\nspin_unlock(&tifm_adapter_lock);\r\ndevice_del(&fm->dev);\r\n}\r\nvoid tifm_free_adapter(struct tifm_adapter *fm)\r\n{\r\nput_device(&fm->dev);\r\n}\r\nvoid tifm_free_device(struct device *dev)\r\n{\r\nstruct tifm_dev *sock = container_of(dev, struct tifm_dev, dev);\r\nkfree(sock);\r\n}\r\nstruct tifm_dev *tifm_alloc_device(struct tifm_adapter *fm, unsigned int id,\r\nunsigned char type)\r\n{\r\nstruct tifm_dev *sock = NULL;\r\nif (!tifm_media_type_name(type, 0))\r\nreturn sock;\r\nsock = kzalloc(sizeof(struct tifm_dev), GFP_KERNEL);\r\nif (sock) {\r\nspin_lock_init(&sock->lock);\r\nsock->type = type;\r\nsock->socket_id = id;\r\nsock->card_event = tifm_dummy_event;\r\nsock->data_event = tifm_dummy_event;\r\nsock->dev.parent = fm->dev.parent;\r\nsock->dev.bus = &tifm_bus_type;\r\nsock->dev.dma_mask = fm->dev.parent->dma_mask;\r\nsock->dev.release = tifm_free_device;\r\ndev_set_name(&sock->dev, "tifm_%s%u:%u",\r\ntifm_media_type_name(type, 2), fm->id, id);\r\nprintk(KERN_INFO DRIVER_NAME\r\n": %s card detected in socket %u:%u\n",\r\ntifm_media_type_name(type, 0), fm->id, id);\r\n}\r\nreturn sock;\r\n}\r\nvoid tifm_eject(struct tifm_dev *sock)\r\n{\r\nstruct tifm_adapter *fm = dev_get_drvdata(sock->dev.parent);\r\nfm->eject(fm, sock);\r\n}\r\nint tifm_has_ms_pif(struct tifm_dev *sock)\r\n{\r\nstruct tifm_adapter *fm = dev_get_drvdata(sock->dev.parent);\r\nreturn fm->has_ms_pif(fm, sock);\r\n}\r\nint tifm_map_sg(struct tifm_dev *sock, struct scatterlist *sg, int nents,\r\nint direction)\r\n{\r\nreturn pci_map_sg(to_pci_dev(sock->dev.parent), sg, nents, direction);\r\n}\r\nvoid tifm_unmap_sg(struct tifm_dev *sock, struct scatterlist *sg, int nents,\r\nint direction)\r\n{\r\npci_unmap_sg(to_pci_dev(sock->dev.parent), sg, nents, direction);\r\n}\r\nvoid tifm_queue_work(struct work_struct *work)\r\n{\r\nqueue_work(workqueue, work);\r\n}\r\nint tifm_register_driver(struct tifm_driver *drv)\r\n{\r\ndrv->driver.bus = &tifm_bus_type;\r\nreturn driver_register(&drv->driver);\r\n}\r\nvoid tifm_unregister_driver(struct tifm_driver *drv)\r\n{\r\ndriver_unregister(&drv->driver);\r\n}\r\nstatic int __init tifm_init(void)\r\n{\r\nint rc;\r\nworkqueue = create_freezable_workqueue("tifm");\r\nif (!workqueue)\r\nreturn -ENOMEM;\r\nrc = bus_register(&tifm_bus_type);\r\nif (rc)\r\ngoto err_out_wq;\r\nrc = class_register(&tifm_adapter_class);\r\nif (!rc)\r\nreturn 0;\r\nbus_unregister(&tifm_bus_type);\r\nerr_out_wq:\r\ndestroy_workqueue(workqueue);\r\nreturn rc;\r\n}\r\nstatic void __exit tifm_exit(void)\r\n{\r\nclass_unregister(&tifm_adapter_class);\r\nbus_unregister(&tifm_bus_type);\r\ndestroy_workqueue(workqueue);\r\n}
