struct seq_oss_writeq *\r\nsnd_seq_oss_writeq_new(struct seq_oss_devinfo *dp, int maxlen)\r\n{\r\nstruct seq_oss_writeq *q;\r\nstruct snd_seq_client_pool pool;\r\nif ((q = kzalloc(sizeof(*q), GFP_KERNEL)) == NULL)\r\nreturn NULL;\r\nq->dp = dp;\r\nq->maxlen = maxlen;\r\nspin_lock_init(&q->sync_lock);\r\nq->sync_event_put = 0;\r\nq->sync_time = 0;\r\ninit_waitqueue_head(&q->sync_sleep);\r\nmemset(&pool, 0, sizeof(pool));\r\npool.client = dp->cseq;\r\npool.output_pool = maxlen;\r\npool.output_room = maxlen / 2;\r\nsnd_seq_oss_control(dp, SNDRV_SEQ_IOCTL_SET_CLIENT_POOL, &pool);\r\nreturn q;\r\n}\r\nvoid\r\nsnd_seq_oss_writeq_delete(struct seq_oss_writeq *q)\r\n{\r\nif (q) {\r\nsnd_seq_oss_writeq_clear(q);\r\nkfree(q);\r\n}\r\n}\r\nvoid\r\nsnd_seq_oss_writeq_clear(struct seq_oss_writeq *q)\r\n{\r\nstruct snd_seq_remove_events reset;\r\nmemset(&reset, 0, sizeof(reset));\r\nreset.remove_mode = SNDRV_SEQ_REMOVE_OUTPUT;\r\nsnd_seq_oss_control(q->dp, SNDRV_SEQ_IOCTL_REMOVE_EVENTS, &reset);\r\nsnd_seq_oss_writeq_wakeup(q, 0);\r\n}\r\nint\r\nsnd_seq_oss_writeq_sync(struct seq_oss_writeq *q)\r\n{\r\nstruct seq_oss_devinfo *dp = q->dp;\r\nabstime_t time;\r\ntime = snd_seq_oss_timer_cur_tick(dp->timer);\r\nif (q->sync_time >= time)\r\nreturn 0;\r\nif (! q->sync_event_put) {\r\nstruct snd_seq_event ev;\r\nunion evrec *rec;\r\nmemset(&ev, 0, sizeof(ev));\r\nev.flags = 0;\r\nev.type = SNDRV_SEQ_EVENT_ECHO;\r\nev.time.tick = time;\r\nsnd_seq_oss_fill_addr(dp, &ev, dp->addr.client, dp->addr.port);\r\nrec = (union evrec *)&ev.data;\r\nrec->t.code = SEQ_SYNCTIMER;\r\nrec->t.time = time;\r\nq->sync_event_put = 1;\r\nsnd_seq_kernel_client_enqueue_blocking(dp->cseq, &ev, NULL, 0, 0);\r\n}\r\nwait_event_interruptible_timeout(q->sync_sleep, ! q->sync_event_put, HZ);\r\nif (signal_pending(current))\r\nq->sync_event_put = 0;\r\nif (! q->sync_event_put || q->sync_time >= time)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nvoid\r\nsnd_seq_oss_writeq_wakeup(struct seq_oss_writeq *q, abstime_t time)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&q->sync_lock, flags);\r\nq->sync_time = time;\r\nq->sync_event_put = 0;\r\nif (waitqueue_active(&q->sync_sleep)) {\r\nwake_up(&q->sync_sleep);\r\n}\r\nspin_unlock_irqrestore(&q->sync_lock, flags);\r\n}\r\nint\r\nsnd_seq_oss_writeq_get_free_size(struct seq_oss_writeq *q)\r\n{\r\nstruct snd_seq_client_pool pool;\r\npool.client = q->dp->cseq;\r\nsnd_seq_oss_control(q->dp, SNDRV_SEQ_IOCTL_GET_CLIENT_POOL, &pool);\r\nreturn pool.output_free;\r\n}\r\nvoid\r\nsnd_seq_oss_writeq_set_output(struct seq_oss_writeq *q, int val)\r\n{\r\nstruct snd_seq_client_pool pool;\r\npool.client = q->dp->cseq;\r\nsnd_seq_oss_control(q->dp, SNDRV_SEQ_IOCTL_GET_CLIENT_POOL, &pool);\r\npool.output_room = val;\r\nsnd_seq_oss_control(q->dp, SNDRV_SEQ_IOCTL_SET_CLIENT_POOL, &pool);\r\n}
