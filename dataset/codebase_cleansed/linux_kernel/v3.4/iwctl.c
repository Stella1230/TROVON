struct iw_statistics *iwctl_get_wireless_stats(struct net_device *dev)\r\n{\r\nPSDevice pDevice = netdev_priv(dev);\r\nlong ldBm;\r\npDevice->wstats.status = pDevice->eOPMode;\r\n#ifdef Calcu_LinkQual\r\n#if 0\r\nif(pDevice->byBBType == BB_TYPE_11B) {\r\nif(pDevice->byCurrSQ > 120)\r\npDevice->scStatistic.LinkQuality = 100;\r\nelse\r\npDevice->scStatistic.LinkQuality = pDevice->byCurrSQ*100/120;\r\n}\r\nelse if(pDevice->byBBType == BB_TYPE_11G) {\r\nif(pDevice->byCurrSQ < 20)\r\npDevice->scStatistic.LinkQuality = 100;\r\nelse if(pDevice->byCurrSQ >96)\r\npDevice->scStatistic.LinkQuality = 0;\r\nelse\r\npDevice->scStatistic.LinkQuality = (96-pDevice->byCurrSQ)*100/76;\r\n}\r\nif(pDevice->bLinkPass !=true)\r\npDevice->scStatistic.LinkQuality = 0;\r\n#endif\r\nif(pDevice->scStatistic.LinkQuality > 100)\r\npDevice->scStatistic.LinkQuality = 100;\r\npDevice->wstats.qual.qual =(unsigned char) pDevice->scStatistic.LinkQuality;\r\n#else\r\npDevice->wstats.qual.qual = pDevice->byCurrSQ;\r\n#endif\r\nRFvRSSITodBm(pDevice, (unsigned char)(pDevice->uCurrRSSI), &ldBm);\r\npDevice->wstats.qual.level = ldBm;\r\npDevice->wstats.qual.noise = 0;\r\npDevice->wstats.qual.updated = 1;\r\npDevice->wstats.discard.nwid = 0;\r\npDevice->wstats.discard.code = 0;\r\npDevice->wstats.discard.fragment = 0;\r\npDevice->wstats.discard.retries = (unsigned long)pDevice->scStatistic.dwTsrErr;\r\npDevice->wstats.discard.misc = 0;\r\npDevice->wstats.miss.beacon = 0;\r\nreturn &pDevice->wstats;\r\n}\r\nstatic int iwctl_commit(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nvoid *wrq,\r\nchar *extra)\r\n{\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWCOMMIT \n");\r\nreturn 0;\r\n}\r\nint iwctl_giwname(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nchar *wrq,\r\nchar *extra)\r\n{\r\nstrcpy(wrq, "802.11-a/b/g");\r\nreturn 0;\r\n}\r\nint iwctl_siwscan(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nstruct iw_scan_req *req = (struct iw_scan_req *)extra;\r\nunsigned char abyScanSSID[WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1];\r\nPWLAN_IE_SSID pItemSSID=NULL;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSCAN \n");\r\nif(pDevice->byReAssocCount > 0) {\r\nunion iwreq_data wrqu;\r\nPRINT_K("wireless_send_event--->SIOCGIWSCAN(scan done)\n");\r\nmemset(&wrqu, 0, sizeof(wrqu));\r\nwireless_send_event(pDevice->dev, SIOCGIWSCAN, &wrqu, NULL);\r\nreturn 0;\r\n}\r\nspin_lock_irq(&pDevice->lock);\r\nBSSvClearBSSList((void *)pDevice, pDevice->bLinkPass);\r\nif(wrq->length == sizeof(struct iw_scan_req)) {\r\nif (wrq->flags & IW_SCAN_THIS_ESSID) {\r\nmemset(abyScanSSID, 0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);\r\npItemSSID = (PWLAN_IE_SSID)abyScanSSID;\r\npItemSSID->byElementID = WLAN_EID_SSID;\r\nmemcpy(pItemSSID->abySSID, req->essid, (int)req->essid_len);\r\nif (pItemSSID->abySSID[req->essid_len - 1] == '\0') {\r\nif(req->essid_len>0)\r\npItemSSID->len = req->essid_len - 1;\r\n}\r\nelse\r\npItemSSID->len = req->essid_len;\r\npMgmt->eScanType = WMAC_SCAN_PASSIVE;\r\nPRINT_K("SIOCSIWSCAN:[desired_ssid=%s,len=%d]\n",((PWLAN_IE_SSID)abyScanSSID)->abySSID,\r\n((PWLAN_IE_SSID)abyScanSSID)->len);\r\nbScheduleCommand((void *) pDevice, WLAN_CMD_BSSID_SCAN, abyScanSSID);\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn 0;\r\n}\r\nelse if(req->scan_type == IW_SCAN_TYPE_PASSIVE) {\r\npMgmt->eScanType = WMAC_SCAN_PASSIVE;\r\n}\r\n}\r\nelse {\r\npMgmt->eScanType = WMAC_SCAN_ACTIVE;\r\n}\r\npMgmt->eScanType = WMAC_SCAN_PASSIVE;\r\nbScheduleCommand((void *) pDevice, WLAN_CMD_BSSID_SCAN, NULL);\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn 0;\r\n}\r\nint iwctl_giwscan(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *wrq,\r\nchar *extra)\r\n{\r\nint ii, jj, kk;\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nPKnownBSS pBSS;\r\nPWLAN_IE_SSID pItemSSID;\r\nPWLAN_IE_SUPP_RATES pSuppRates, pExtSuppRates;\r\nchar *current_ev = extra;\r\nchar *end_buf = extra + IW_SCAN_MAX_DATA;\r\nchar *current_val = NULL;\r\nstruct iw_event iwe;\r\nlong ldBm;\r\nchar buf[MAX_WPA_IE_LEN * 2 + 30];\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWSCAN \n");\r\nif (pMgmt->eScanState == WMAC_IS_SCANNING) {\r\nreturn -EAGAIN;\r\n}\r\npBSS = &(pMgmt->sBSSList[0]);\r\nfor (ii = 0, jj = 0; jj < MAX_BSS_NUM ; jj++) {\r\nif (current_ev >= end_buf)\r\nbreak;\r\npBSS = &(pMgmt->sBSSList[jj]);\r\nif (pBSS->bActive) {\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = SIOCGIWAP;\r\niwe.u.ap_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(iwe.u.ap_addr.sa_data, pBSS->abyBSSID, WLAN_BSSID_LEN);\r\ncurrent_ev = iwe_stream_add_event(info,current_ev,end_buf, &iwe, IW_EV_ADDR_LEN);\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = SIOCGIWESSID;\r\npItemSSID = (PWLAN_IE_SSID)pBSS->abySSID;\r\niwe.u.data.length = pItemSSID->len;\r\niwe.u.data.flags = 1;\r\ncurrent_ev = iwe_stream_add_point(info,current_ev,end_buf, &iwe, pItemSSID->abySSID);\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = SIOCGIWMODE;\r\nif (WLAN_GET_CAP_INFO_ESS(pBSS->wCapInfo)) {\r\niwe.u.mode = IW_MODE_INFRA;\r\n}\r\nelse {\r\niwe.u.mode = IW_MODE_ADHOC;\r\n}\r\niwe.len = IW_EV_UINT_LEN;\r\ncurrent_ev = iwe_stream_add_event(info,current_ev, end_buf, &iwe, IW_EV_UINT_LEN);\r\npSuppRates = (PWLAN_IE_SUPP_RATES)pBSS->abySuppRates;\r\npExtSuppRates = (PWLAN_IE_SUPP_RATES)pBSS->abyExtSuppRates;\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = SIOCGIWFREQ;\r\niwe.u.freq.m = pBSS->uChannel;\r\niwe.u.freq.e = 0;\r\niwe.u.freq.i = 0;\r\ncurrent_ev = iwe_stream_add_event(info,current_ev,end_buf, &iwe, IW_EV_FREQ_LEN);\r\n{\r\nint f = (int)pBSS->uChannel - 1;\r\nif(f < 0)f = 0;\r\niwe.u.freq.m = frequency_list[f] * 100000;\r\niwe.u.freq.e = 1;\r\n}\r\ncurrent_ev = iwe_stream_add_event(info,current_ev,end_buf, &iwe, IW_EV_FREQ_LEN);\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVQUAL;\r\nRFvRSSITodBm(pDevice, (unsigned char)(pBSS->uRSSI), &ldBm);\r\niwe.u.qual.level = ldBm;\r\niwe.u.qual.noise = 0;\r\nif(-ldBm<50){\r\niwe.u.qual.qual = 100;\r\n}else if(-ldBm > 90) {\r\niwe.u.qual.qual = 0;\r\n}else {\r\niwe.u.qual.qual=(40-(-ldBm-50))*100/40;\r\n}\r\niwe.u.qual.updated=7;\r\ncurrent_ev = iwe_stream_add_event(info,current_ev, end_buf, &iwe, IW_EV_QUAL_LEN);\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = SIOCGIWENCODE;\r\niwe.u.data.length = 0;\r\nif (WLAN_GET_CAP_INFO_PRIVACY(pBSS->wCapInfo)) {\r\niwe.u.data.flags =IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\r\n}else {\r\niwe.u.data.flags = IW_ENCODE_DISABLED;\r\n}\r\ncurrent_ev = iwe_stream_add_point(info,current_ev,end_buf, &iwe, pItemSSID->abySSID);\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = SIOCGIWRATE;\r\niwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;\r\ncurrent_val = current_ev + IW_EV_LCP_LEN;\r\nfor (kk = 0 ; kk < 12 ; kk++) {\r\nif (pSuppRates->abyRates[kk] == 0)\r\nbreak;\r\niwe.u.bitrate.value = ((pSuppRates->abyRates[kk] & 0x7f) * 500000);\r\ncurrent_val = iwe_stream_add_value(info,current_ev, current_val, end_buf, &iwe, IW_EV_PARAM_LEN);\r\n}\r\nfor (kk = 0 ; kk < 8 ; kk++) {\r\nif (pExtSuppRates->abyRates[kk] == 0)\r\nbreak;\r\niwe.u.bitrate.value = ((pExtSuppRates->abyRates[kk] & 0x7f) * 500000);\r\ncurrent_val = iwe_stream_add_value(info,current_ev, current_val, end_buf, &iwe, IW_EV_PARAM_LEN);\r\n}\r\nif((current_val - current_ev) > IW_EV_LCP_LEN)\r\ncurrent_ev = current_val;\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVCUSTOM;\r\nsprintf(buf, "bcn_int=%d", pBSS->wBeaconInterval);\r\niwe.u.data.length = strlen(buf);\r\ncurrent_ev = iwe_stream_add_point(info,current_ev, end_buf, &iwe, buf);\r\nif ((pBSS->wWPALen > 0) && (pBSS->wWPALen <= MAX_WPA_IE_LEN)) {\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVGENIE;\r\niwe.u.data.length = pBSS->wWPALen;\r\ncurrent_ev = iwe_stream_add_point(info,current_ev, end_buf, &iwe, pBSS->byWPAIE);\r\n}\r\nif ((pBSS->wRSNLen > 0) && (pBSS->wRSNLen <= MAX_WPA_IE_LEN)) {\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVGENIE;\r\niwe.u.data.length = pBSS->wRSNLen;\r\ncurrent_ev = iwe_stream_add_point(info,current_ev, end_buf, &iwe, pBSS->byRSNIE);\r\n}\r\n}\r\n}\r\nwrq->length = current_ev - extra;\r\nreturn 0;\r\n}\r\nint iwctl_siwfreq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_freq *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nint rc = 0;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWFREQ \n");\r\nif((wrq->e == 1) &&\r\n(wrq->m >= (int) 2.412e8) &&\r\n(wrq->m <= (int) 2.487e8)) {\r\nint f = wrq->m / 100000;\r\nint c = 0;\r\nwhile((c < 14) && (f != frequency_list[c]))\r\nc++;\r\nwrq->e = 0;\r\nwrq->m = c + 1;\r\n}\r\nif((wrq->m > 14) || (wrq->e > 0))\r\nrc = -EOPNOTSUPP;\r\nelse {\r\nint channel = wrq->m;\r\nif((channel < 1) || (channel > 14)) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "%s: New channel value of %d is invalid!\n", dev->name, wrq->m);\r\nrc = -EINVAL;\r\n} else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " Set to channel = %d\n", channel);\r\npDevice->uChannel = channel;\r\npDevice->bCommit = true;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nint iwctl_giwfreq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_freq *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWFREQ \n");\r\n#ifdef WEXT_USECHANNELS\r\nwrq->m = (int)pMgmt->uCurrChannel;\r\nwrq->e = 0;\r\n#else\r\n{\r\nint f = (int)pMgmt->uCurrChannel - 1;\r\nif(f < 0)\r\nf = 0;\r\nwrq->m = frequency_list[f] * 100000;\r\nwrq->e = 1;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nint iwctl_siwmode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\n__u32 *wmode,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nint rc = 0;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWMODE \n");\r\nif (pMgmt->eCurrMode == WMAC_MODE_ESS_AP && pDevice->bEnableHostapd) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Can't set operation mode, hostapd is running \n");\r\nreturn rc;\r\n}\r\nswitch(*wmode) {\r\ncase IW_MODE_ADHOC:\r\nif (pMgmt->eConfigMode != WMAC_CONFIG_IBSS_STA) {\r\npMgmt->eConfigMode = WMAC_CONFIG_IBSS_STA;\r\nif (pDevice->flags & DEVICE_FLAGS_OPENED) {\r\npDevice->bCommit = true;\r\n}\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "set mode to ad-hoc \n");\r\nbreak;\r\ncase IW_MODE_AUTO:\r\ncase IW_MODE_INFRA:\r\nif (pMgmt->eConfigMode != WMAC_CONFIG_ESS_STA) {\r\npMgmt->eConfigMode = WMAC_CONFIG_ESS_STA;\r\nif (pDevice->flags & DEVICE_FLAGS_OPENED) {\r\npDevice->bCommit = true;\r\n}\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "set mode to infrastructure \n");\r\nbreak;\r\ncase IW_MODE_MASTER:\r\npMgmt->eConfigMode = WMAC_CONFIG_ESS_STA;\r\nrc = -EOPNOTSUPP;\r\nbreak;\r\nif (pMgmt->eConfigMode != WMAC_CONFIG_AP) {\r\npMgmt->eConfigMode = WMAC_CONFIG_AP;\r\nif (pDevice->flags & DEVICE_FLAGS_OPENED) {\r\npDevice->bCommit = true;\r\n}\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "set mode to Access Point \n");\r\nbreak;\r\ncase IW_MODE_REPEAT:\r\npMgmt->eConfigMode = WMAC_CONFIG_ESS_STA;\r\nrc = -EOPNOTSUPP;\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\n}\r\nreturn rc;\r\n}\r\nint iwctl_giwmode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\n__u32 *wmode,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWMODE \n");\r\nswitch (pMgmt->eConfigMode) {\r\ncase WMAC_CONFIG_ESS_STA:\r\n*wmode = IW_MODE_INFRA;\r\nbreak;\r\ncase WMAC_CONFIG_IBSS_STA:\r\n*wmode = IW_MODE_ADHOC;\r\nbreak;\r\ncase WMAC_CONFIG_AUTO:\r\n*wmode = IW_MODE_INFRA;\r\nbreak;\r\ncase WMAC_CONFIG_AP:\r\n*wmode = IW_MODE_MASTER;\r\nbreak;\r\ndefault:\r\n*wmode = IW_MODE_ADHOC;\r\n}\r\nreturn 0;\r\n}\r\nint iwctl_giwrange(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *wrq,\r\nchar *extra)\r\n{\r\nstruct iw_range *range = (struct iw_range *) extra;\r\nint i,k;\r\nunsigned char abySupportedRates[13]= {0x02, 0x04, 0x0B, 0x16, 0x0c, 0x12, 0x18, 0x24, 0x30, 0x48, 0x60, 0x6C, 0x90};\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWRANGE \n");\r\nif (wrq->pointer) {\r\nwrq->length = sizeof(struct iw_range);\r\nmemset(range, 0, sizeof(struct iw_range));\r\nrange->min_nwid = 0x0000;\r\nrange->max_nwid = 0x0000;\r\nrange->num_channels = 14;\r\nk = 0;\r\nfor(i = 0; i < 14; i++) {\r\nrange->freq[k].i = i + 1;\r\nrange->freq[k].m = frequency_list[i] * 100000;\r\nrange->freq[k++].e = 1;\r\n}\r\nrange->num_frequency = k;\r\n#ifdef Calcu_LinkQual\r\nrange->max_qual.qual = 100;\r\n#else\r\nrange->max_qual.qual = 255;\r\n#endif\r\nrange->max_qual.level = 0;\r\nrange->max_qual.noise = 0;\r\nrange->sensitivity = 255;\r\nfor(i = 0 ; i < 13 ; i++) {\r\nrange->bitrate[i] = abySupportedRates[i] * 500000;\r\nif(range->bitrate[i] == 0)\r\nbreak;\r\n}\r\nrange->num_bitrates = i;\r\nif(i > 2)\r\nrange->throughput = 5 * 1000 * 1000;\r\nelse\r\nrange->throughput = 1.5 * 1000 * 1000;\r\nrange->min_rts = 0;\r\nrange->max_rts = 2312;\r\nrange->min_frag = 256;\r\nrange->max_frag = 2312;\r\nrange->num_encoding_sizes = 3;\r\nrange->encoding_size[0] = 5;\r\nrange->encoding_size[1] = 13;\r\nrange->encoding_size[2] = 32;\r\nrange->max_encoding_tokens = 4;\r\nrange->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |\r\nIW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;\r\nrange->min_pmp = 0;\r\nrange->max_pmp = 1000000;\r\nrange->min_pmt = 0;\r\nrange->max_pmt = 1000000;\r\nrange->pmp_flags = IW_POWER_PERIOD;\r\nrange->pmt_flags = IW_POWER_TIMEOUT;\r\nrange->pm_capa = IW_POWER_PERIOD | IW_POWER_TIMEOUT | IW_POWER_ALL_R;\r\nrange->txpower[0] = 100;\r\nrange->num_txpower = 1;\r\nrange->txpower_capa = IW_TXPOW_MWATT;\r\nrange->we_version_source = SUPPORTED_WIRELESS_EXT;\r\nrange->we_version_compiled = WIRELESS_EXT;\r\nrange->retry_capa = IW_RETRY_LIMIT | IW_RETRY_LIFETIME;\r\nrange->retry_flags = IW_RETRY_LIMIT;\r\nrange->r_time_flags = IW_RETRY_LIFETIME;\r\nrange->min_retry = 1;\r\nrange->max_retry = 65535;\r\nrange->min_r_time = 1024;\r\nrange->max_r_time = 65535 * 1024;\r\nrange->avg_qual.qual = 6;\r\nrange->avg_qual.level = 176;\r\nrange->avg_qual.noise = 0;\r\n}\r\nreturn 0;\r\n}\r\nint iwctl_siwap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct sockaddr *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nint rc = 0;\r\nunsigned char ZeroBSSID[WLAN_BSSID_LEN]={0x00,0x00,0x00,0x00,0x00,0x00};\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWAP \n");\r\nif (pMgmt->eScanState == WMAC_IS_SCANNING) {\r\nprintk("SIOCSIWAP(??)-->In scanning...\n");\r\n}\r\nif (wrq->sa_family != ARPHRD_ETHER)\r\nrc = -EINVAL;\r\nelse {\r\nmemcpy(pMgmt->abyDesireBSSID, wrq->sa_data, 6);\r\nif((pDevice->bLinkPass == true) &&\r\n(memcmp(pMgmt->abyDesireBSSID, pMgmt->abyCurrBSSID, 6)== 0)){\r\nreturn rc;\r\n}\r\nif ((is_broadcast_ether_addr(pMgmt->abyDesireBSSID)) ||\r\n(memcmp(pMgmt->abyDesireBSSID, ZeroBSSID, 6) == 0)){\r\nPRINT_K("SIOCSIWAP:invalid desired BSSID return!\n");\r\nreturn rc;\r\n}\r\n{\r\nunsigned int ii , uSameBssidNum=0;\r\nfor (ii = 0; ii < MAX_BSS_NUM; ii++) {\r\nif (pMgmt->sBSSList[ii].bActive &&\r\n!compare_ether_addr(pMgmt->sBSSList[ii].abyBSSID, pMgmt->abyDesireBSSID)) {\r\nuSameBssidNum++;\r\n}\r\n}\r\nif(uSameBssidNum >= 2) {\r\nPRINT_K("SIOCSIWAP:ignore for desired AP in hidden mode\n");\r\nreturn rc;\r\n}\r\n}\r\nif (pDevice->flags & DEVICE_FLAGS_OPENED) {\r\npDevice->bCommit = true;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nint iwctl_giwap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct sockaddr *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWAP \n");\r\nmemcpy(wrq->sa_data, pMgmt->abyCurrBSSID, 6);\r\nif ((pDevice->bLinkPass == false) && (pMgmt->eCurrMode != WMAC_MODE_ESS_AP))\r\nmemset(wrq->sa_data, 0, 6);\r\nif (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {\r\nmemcpy(wrq->sa_data, pMgmt->abyCurrBSSID, 6);\r\n}\r\nwrq->sa_family = ARPHRD_ETHER;\r\nreturn 0;\r\n}\r\nint iwctl_giwaplist(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *wrq,\r\nchar *extra)\r\n{\r\nint ii,jj, rc = 0;\r\nstruct sockaddr sock[IW_MAX_AP];\r\nstruct iw_quality qual[IW_MAX_AP];\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWAPLIST \n");\r\nif (!capable(CAP_NET_ADMIN)) {\r\nrc = -EPERM;\r\nreturn rc;\r\n}\r\nif (wrq->pointer) {\r\nPKnownBSS pBSS = &(pMgmt->sBSSList[0]);\r\nfor (ii = 0, jj= 0; ii < MAX_BSS_NUM; ii++) {\r\npBSS = &(pMgmt->sBSSList[ii]);\r\nif (!pBSS->bActive)\r\ncontinue;\r\nif ( jj >= IW_MAX_AP)\r\nbreak;\r\nmemcpy(sock[jj].sa_data, pBSS->abyBSSID, 6);\r\nsock[jj].sa_family = ARPHRD_ETHER;\r\nqual[jj].level = pBSS->uRSSI;\r\nqual[jj].qual = qual[jj].noise = 0;\r\nqual[jj].updated = 2;\r\njj++;\r\n}\r\nwrq->flags = 1;\r\nwrq->length = jj;\r\nmemcpy(extra, sock, sizeof(struct sockaddr)*jj);\r\nmemcpy(extra + sizeof(struct sockaddr)*jj, qual, sizeof(struct iw_quality)*jj);\r\n}\r\nreturn rc;\r\n}\r\nint iwctl_siwessid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nPWLAN_IE_SSID pItemSSID;\r\nunsigned char len;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWESSID \n");\r\npDevice->fWPA_Authened = false;\r\nif (pMgmt->eScanState == WMAC_IS_SCANNING) {\r\nprintk("SIOCSIWESSID(??)-->In scanning...\n");\r\n}\r\nif(wrq->flags == 0) {\r\nmemset(pMgmt->abyDesireSSID, 0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);\r\nmemset(pMgmt->abyDesireBSSID, 0xFF,6);\r\nPRINT_K("set essid to 'any' \n");\r\n#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT\r\nreturn 0;\r\n#endif\r\n} else {\r\nmemset(pMgmt->abyDesireSSID, 0, WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1);\r\npItemSSID = (PWLAN_IE_SSID)pMgmt->abyDesireSSID;\r\npItemSSID->byElementID = WLAN_EID_SSID;\r\nmemcpy(pItemSSID->abySSID, extra, wrq->length);\r\nif (pItemSSID->abySSID[wrq->length - 1] == '\0') {\r\nif(wrq->length>0)\r\npItemSSID->len = wrq->length - 1;\r\n}\r\nelse\r\npItemSSID->len = wrq->length;\r\nprintk("set essid to %s \n",pItemSSID->abySSID);\r\nlen=(pItemSSID->len > ((PWLAN_IE_SSID)pMgmt->abyCurrSSID)->len)?pItemSSID->len:((PWLAN_IE_SSID)pMgmt->abyCurrSSID)->len;\r\nif((pDevice->bLinkPass == true) &&\r\n(memcmp(pItemSSID->abySSID,((PWLAN_IE_SSID)pMgmt->abyCurrSSID)->abySSID,len)==0))\r\nreturn 0;\r\nif(pItemSSID->len==0) {\r\nmemset(pMgmt->abyDesireBSSID, 0xFF,6);\r\nreturn 0;\r\n}\r\n#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT\r\nif(pDevice->bWPASuppWextEnabled == true) {\r\n{\r\nPKnownBSS pCurr = NULL;\r\nunsigned char abyTmpDesireSSID[WLAN_IEHDR_LEN + WLAN_SSID_MAXLEN + 1];\r\nunsigned int ii , uSameBssidNum=0;\r\nmemcpy(abyTmpDesireSSID,pMgmt->abyDesireSSID,sizeof(abyTmpDesireSSID));\r\npCurr = BSSpSearchBSSList(pDevice,\r\nNULL,\r\nabyTmpDesireSSID,\r\npMgmt->eConfigPHYMode\r\n);\r\nif (pCurr == NULL){\r\nPRINT_K("SIOCSIWESSID:hidden ssid site survey before associate.......\n");\r\nvResetCommandTimer((void *) pDevice);\r\npMgmt->eScanType = WMAC_SCAN_ACTIVE;\r\nbScheduleCommand((void *) pDevice, WLAN_CMD_BSSID_SCAN, pMgmt->abyDesireSSID);\r\nbScheduleCommand((void *) pDevice, WLAN_CMD_SSID, pMgmt->abyDesireSSID);\r\n}\r\nelse {\r\nfor (ii = 0; ii < MAX_BSS_NUM; ii++) {\r\nif (pMgmt->sBSSList[ii].bActive &&\r\n!compare_ether_addr(pMgmt->sBSSList[ii].abyBSSID, pCurr->abyBSSID)) {\r\nuSameBssidNum++;\r\n}\r\n}\r\nif(uSameBssidNum >= 2) {\r\nprintk("SIOCSIWESSID:hidden ssid directly associate.......\n");\r\nvResetCommandTimer((void *) pDevice);\r\npMgmt->eScanType = WMAC_SCAN_PASSIVE;\r\nbScheduleCommand((void *) pDevice, WLAN_CMD_BSSID_SCAN, pMgmt->abyDesireSSID);\r\nbScheduleCommand((void *) pDevice, WLAN_CMD_SSID, pMgmt->abyDesireSSID);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\n#endif\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "set essid = %s \n", pItemSSID->abySSID);\r\n}\r\nif (pDevice->flags & DEVICE_FLAGS_OPENED) {\r\npDevice->bCommit = true;\r\n}\r\nreturn 0;\r\n}\r\nint iwctl_giwessid(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nPWLAN_IE_SSID pItemSSID;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWESSID \n");\r\npItemSSID = (PWLAN_IE_SSID)pMgmt->abyCurrSSID;\r\nmemcpy(extra, pItemSSID->abySSID , pItemSSID->len);\r\nextra[pItemSSID->len] = '\0';\r\nwrq->length = pItemSSID->len + 1;\r\nwrq->length = pItemSSID->len;\r\nwrq->flags = 1;\r\nreturn 0;\r\n}\r\nint iwctl_siwrate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nint rc = 0;\r\nu8 brate = 0;\r\nint i;\r\nunsigned char abySupportedRates[13]= {0x02, 0x04, 0x0B, 0x16, 0x0c, 0x12, 0x18, 0x24, 0x30, 0x48, 0x60, 0x6C, 0x90};\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWRATE \n");\r\nif (!(pDevice->flags & DEVICE_FLAGS_OPENED)) {\r\nrc = -EINVAL;\r\nreturn rc;\r\n}\r\nif((wrq->value < 13) &&\r\n(wrq->value >= 0)) {\r\nbrate = wrq->value;\r\n} else {\r\nu8 normvalue = (u8) (wrq->value/500000);\r\nfor(i = 0 ; i < 13 ; i++) {\r\nif(normvalue == abySupportedRates[i]) {\r\nbrate = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nif(wrq->value == -1) {\r\nfor(i = 0 ; i < 13 ; i++) {\r\nif(abySupportedRates[i] == 0)\r\nbreak;\r\n}\r\nif(i != 0)\r\nbrate = i - 1;\r\n}\r\nif(brate > 13 ) {\r\nrc = -EINVAL;\r\nreturn rc;\r\n}\r\nif(wrq->fixed != 0) {\r\nprintk("Rate Fix\n");\r\npDevice->bFixRate = true;\r\nif ((pDevice->byBBType == BB_TYPE_11B)&& (brate > 3)) {\r\npDevice->uConnectionRate = 3;\r\n}\r\nelse {\r\npDevice->uConnectionRate = brate;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Fixed to Rate %d \n", pDevice->uConnectionRate);\r\n}\r\n}\r\nelse {\r\npDevice->bFixRate = false;\r\npDevice->uConnectionRate = 13;\r\nprintk("auto rate:connection_rate is 13\n");\r\n}\r\nreturn rc;\r\n}\r\nint iwctl_giwrate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWRATE \n");\r\n{\r\nunsigned char abySupportedRates[13]= {0x02, 0x04, 0x0B, 0x16, 0x0c, 0x12, 0x18, 0x24, 0x30, 0x48, 0x60, 0x6C, 0x90};\r\nint brate = 0;\r\nif(pDevice->bLinkPass){\r\nif(pDevice->bFixRate == true){\r\nif (pDevice->uConnectionRate < 13) {\r\nbrate = abySupportedRates[pDevice->uConnectionRate];\r\n}else {\r\nif (pDevice->byBBType == BB_TYPE_11B)\r\nbrate = 0x16;\r\nif (pDevice->byBBType == BB_TYPE_11G)\r\nbrate = 0x6C;\r\nif (pDevice->byBBType == BB_TYPE_11A)\r\nbrate = 0x6C;\r\n}\r\n}\r\nelse\r\n{\r\nbrate = abySupportedRates[TxRate_iwconfig];\r\n}\r\n}\r\nelse brate =0;\r\nwrq->value = brate * 500000;\r\nif (pDevice->bFixRate == true)\r\nwrq->fixed = true;\r\n}\r\nreturn 0;\r\n}\r\nint iwctl_siwrts(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nint rc = 0;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWRTS \n");\r\n{\r\nint rthr = wrq->value;\r\nif(wrq->disabled)\r\nrthr = 2312;\r\nif((rthr < 0) || (rthr > 2312)) {\r\nrc = -EINVAL;\r\n}else {\r\npDevice->wRTSThreshold = rthr;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint iwctl_giwrts(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWRTS \n");\r\nwrq->value = pDevice->wRTSThreshold;\r\nwrq->disabled = (wrq->value >= 2312);\r\nwrq->fixed = 1;\r\nreturn 0;\r\n}\r\nint iwctl_siwfrag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nint rc = 0;\r\nint fthr = wrq->value;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWFRAG \n");\r\nif (wrq->disabled)\r\nfthr = 2312;\r\nif((fthr < 256) || (fthr > 2312)) {\r\nrc = -EINVAL;\r\n}else {\r\nfthr &= ~0x1;\r\npDevice->wFragmentationThreshold = (u16)fthr;\r\n}\r\nreturn rc;\r\n}\r\nint iwctl_giwfrag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWFRAG \n");\r\nwrq->value = pDevice->wFragmentationThreshold;\r\nwrq->disabled = (wrq->value >= 2312);\r\nwrq->fixed = 1;\r\nreturn 0;\r\n}\r\nint iwctl_siwretry(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nint rc = 0;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWRETRY \n");\r\nif (wrq->disabled) {\r\nrc = -EINVAL;\r\nreturn rc;\r\n}\r\nif (wrq->flags & IW_RETRY_LIMIT) {\r\nif(wrq->flags & IW_RETRY_MAX)\r\npDevice->byLongRetryLimit = wrq->value;\r\nelse if (wrq->flags & IW_RETRY_MIN)\r\npDevice->byShortRetryLimit = wrq->value;\r\nelse {\r\npDevice->byShortRetryLimit = wrq->value;\r\npDevice->byLongRetryLimit = wrq->value;\r\n}\r\n}\r\nif (wrq->flags & IW_RETRY_LIFETIME) {\r\npDevice->wMaxTransmitMSDULifetime = wrq->value;\r\n}\r\nreturn rc;\r\n}\r\nint iwctl_giwretry(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWRETRY \n");\r\nwrq->disabled = 0;\r\nif((wrq->flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME) {\r\nwrq->flags = IW_RETRY_LIFETIME;\r\nwrq->value = (int)pDevice->wMaxTransmitMSDULifetime;\r\n} else if((wrq->flags & IW_RETRY_MAX)) {\r\nwrq->flags = IW_RETRY_LIMIT | IW_RETRY_MAX;\r\nwrq->value = (int)pDevice->byLongRetryLimit;\r\n} else {\r\nwrq->flags = IW_RETRY_LIMIT;\r\nwrq->value = (int)pDevice->byShortRetryLimit;\r\nif((int)pDevice->byShortRetryLimit != (int)pDevice->byLongRetryLimit)\r\nwrq->flags |= IW_RETRY_MIN;\r\n}\r\nreturn 0;\r\n}\r\nint iwctl_siwencode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nunsigned long dwKeyIndex = (unsigned long)(wrq->flags & IW_ENCODE_INDEX);\r\nint ii,uu, rc = 0;\r\nint index = (wrq->flags & IW_ENCODE_INDEX);\r\nPSKeyTable pkeytab;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWENCODE \n");\r\nif((wrq->flags & IW_ENCODE_DISABLED)==0){\r\nif (dwKeyIndex > WLAN_WEP_NKEYS) {\r\nrc = -EINVAL;\r\nreturn rc;\r\n}\r\nif(dwKeyIndex<1&&((wrq->flags&IW_ENCODE_NOKEY)==0)){\r\nif(pDevice->byKeyIndex<WLAN_WEP_NKEYS){\r\ndwKeyIndex=pDevice->byKeyIndex;\r\n}\r\nelse dwKeyIndex=0;\r\n}else dwKeyIndex--;\r\nif (wrq->length > WLAN_WEP232_KEYLEN) {\r\nrc = -EINVAL;\r\nreturn rc;\r\n}\r\nif(wrq->length>0){\r\nif (wrq->length == WLAN_WEP232_KEYLEN) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Set 232 bit wep key\n");\r\n}\r\nelse if (wrq->length == WLAN_WEP104_KEYLEN) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Set 104 bit wep key\n");\r\n}\r\nelse if (wrq->length == WLAN_WEP40_KEYLEN) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Set 40 bit wep key, index= %d\n", (int)dwKeyIndex);\r\n}else {\r\nrc = -EINVAL;\r\nreturn rc;\r\n}\r\nmemset(pDevice->abyKey, 0, WLAN_WEP232_KEYLEN);\r\nmemcpy(pDevice->abyKey, extra, wrq->length);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"abyKey: ");\r\nfor (ii = 0; ii < wrq->length; ii++) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "%02x ", pDevice->abyKey[ii]);\r\n}\r\nif (pDevice->flags & DEVICE_FLAGS_OPENED) {\r\nspin_lock_irq(&pDevice->lock);\r\nKeybSetDefaultKey(&(pDevice->sKey),\r\n(unsigned long)(dwKeyIndex | (1 << 31)),\r\nwrq->length,\r\nNULL,\r\npDevice->abyKey,\r\nKEY_CTL_WEP,\r\npDevice->PortOffset,\r\npDevice->byLocalID\r\n);\r\nspin_unlock_irq(&pDevice->lock);\r\n}\r\npDevice->byKeyIndex = (unsigned char)dwKeyIndex;\r\npDevice->uKeyLength = wrq->length;\r\npDevice->bTransmitKey = true;\r\npDevice->bEncryptionEnable = true;\r\npDevice->eEncryptionStatus = Ndis802_11Encryption1Enabled;\r\n}else if(index>0){\r\nif(pDevice->bEncryptionEnable==false)\r\n{\r\nrc = -EINVAL;\r\nreturn rc;\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Just set Default key Index:\n");\r\npkeytab=&(pDevice->sKey.KeyTable[MAX_KEY_TABLE-1]);\r\nif(pkeytab->GroupKey[(unsigned char)dwKeyIndex].uKeyLength==0){\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Default key len is 0\n");\r\nrc = -EINVAL;\r\nreturn rc;\r\n}\r\npDevice->byKeyIndex =(unsigned char)dwKeyIndex;\r\npkeytab->dwGTKeyIndex =dwKeyIndex | (1 << 31);\r\npkeytab->GroupKey[(unsigned char)dwKeyIndex].dwKeyIndex=dwKeyIndex | (1 << 31);\r\n}\r\n}else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Disable WEP function\n");\r\nif(pDevice->bEncryptionEnable==false)\r\nreturn 0;\r\npMgmt->bShareKeyAlgorithm = false;\r\npDevice->bEncryptionEnable = false;\r\npDevice->eEncryptionStatus = Ndis802_11EncryptionDisabled;\r\nif (pDevice->flags & DEVICE_FLAGS_OPENED) {\r\nspin_lock_irq(&pDevice->lock);\r\nfor(uu=0;uu<MAX_KEY_TABLE;uu++)\r\nMACvDisableKeyEntry(pDevice->PortOffset, uu);\r\nspin_unlock_irq(&pDevice->lock);\r\n}\r\n}\r\nif(wrq->flags & IW_ENCODE_RESTRICTED) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Enable WEP & ShareKey System\n");\r\npMgmt->bShareKeyAlgorithm = true;\r\n}\r\nif(wrq->flags & IW_ENCODE_OPEN) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Enable WEP & Open System\n");\r\npMgmt->bShareKeyAlgorithm = false;\r\n}\r\nreturn rc;\r\n}\r\nint iwctl_giwencode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nchar abyKey[WLAN_WEP232_KEYLEN];\r\nunsigned int index = (unsigned int)(wrq->flags & IW_ENCODE_INDEX);\r\nPSKeyItem pKey = NULL;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWENCODE\n");\r\nif (index > WLAN_WEP_NKEYS) {\r\nreturn -EINVAL;\r\n}\r\nif(index<1){\r\nif(pDevice->byKeyIndex<WLAN_WEP_NKEYS){\r\nindex=pDevice->byKeyIndex;\r\n} else\r\nindex=0;\r\n}else\r\nindex--;\r\nmemset(abyKey, 0, WLAN_WEP232_KEYLEN);\r\nwrq->flags = IW_ENCODE_NOKEY;\r\nif (pDevice->bEncryptionEnable)\r\nwrq->flags |= IW_ENCODE_ENABLED;\r\nelse\r\nwrq->flags |= IW_ENCODE_DISABLED;\r\nif (pMgmt->bShareKeyAlgorithm)\r\nwrq->flags |= IW_ENCODE_RESTRICTED;\r\nelse\r\nwrq->flags |= IW_ENCODE_OPEN;\r\nwrq->length=0;\r\nif((index==0)&&(pDevice->eEncryptionStatus == Ndis802_11Encryption2Enabled||\r\npDevice->eEncryptionStatus == Ndis802_11Encryption3Enabled)){\r\nif (KeybGetKey(&(pDevice->sKey),pMgmt->abyCurrBSSID, 0xffffffff, &pKey)){\r\nwrq->length = pKey->uKeyLength;\r\nmemcpy(abyKey, pKey->abyKey, pKey->uKeyLength);\r\nmemcpy(extra, abyKey, WLAN_WEP232_KEYLEN);\r\n}\r\n}else if (KeybGetKey(&(pDevice->sKey), pDevice->abyBroadcastAddr, (unsigned char)index , &pKey)){\r\nwrq->length = pKey->uKeyLength;\r\nmemcpy(abyKey, pKey->abyKey, pKey->uKeyLength);\r\nmemcpy(extra, abyKey, WLAN_WEP232_KEYLEN);\r\n}\r\nwrq->flags |= index+1;\r\nreturn 0;\r\n}\r\nint iwctl_siwpower(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nint rc = 0;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWPOWER \n");\r\nif (!(pDevice->flags & DEVICE_FLAGS_OPENED)) {\r\nrc = -EINVAL;\r\nreturn rc;\r\n}\r\nif (wrq->disabled) {\r\npDevice->ePSMode = WMAC_POWER_CAM;\r\nPSvDisablePowerSaving(pDevice);\r\nreturn rc;\r\n}\r\nif ((wrq->flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {\r\npDevice->ePSMode = WMAC_POWER_FAST;\r\nPSvEnablePowerSaving((void *)pDevice, pMgmt->wListenInterval);\r\n} else if ((wrq->flags & IW_POWER_TYPE) == IW_POWER_PERIOD) {\r\npDevice->ePSMode = WMAC_POWER_FAST;\r\nPSvEnablePowerSaving((void *)pDevice, pMgmt->wListenInterval);\r\n}\r\nswitch (wrq->flags & IW_POWER_MODE) {\r\ncase IW_POWER_UNICAST_R:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWPOWER: IW_POWER_UNICAST_R \n");\r\nrc = -EINVAL;\r\nbreak;\r\ncase IW_POWER_ALL_R:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWPOWER: IW_POWER_ALL_R \n");\r\nrc = -EINVAL;\r\ncase IW_POWER_ON:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWPOWER: IW_POWER_ON \n");\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\n}\r\nreturn rc;\r\n}\r\nint iwctl_giwpower(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nint mode = pDevice->ePSMode;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWPOWER \n");\r\nwrq->disabled = (mode == WMAC_POWER_CAM);\r\nif (wrq->disabled)\r\nreturn 0;\r\nif ((wrq->flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {\r\nwrq->value = (int)((pMgmt->wListenInterval * pMgmt->wCurrBeaconPeriod) << 10);\r\nwrq->flags = IW_POWER_TIMEOUT;\r\n} else {\r\nwrq->value = (int)((pMgmt->wListenInterval * pMgmt->wCurrBeaconPeriod) << 10);\r\nwrq->flags = IW_POWER_PERIOD;\r\n}\r\nwrq->flags |= IW_POWER_ALL_R;\r\nreturn 0;\r\n}\r\nint iwctl_giwsens(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nlong ldBm;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWSENS \n");\r\nif (pDevice->bLinkPass == true) {\r\nRFvRSSITodBm(pDevice, (unsigned char)(pDevice->uCurrRSSI), &ldBm);\r\nwrq->value = ldBm;\r\n}\r\nelse {\r\nwrq->value = 0;\r\n};\r\nwrq->disabled = (wrq->value == 0);\r\nwrq->fixed = 1;\r\nreturn 0;\r\n}\r\nint iwctl_siwauth(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nint ret=0;\r\nstatic int wpa_version=0;\r\nstatic int pairwise=0;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWAUTH \n");\r\nswitch (wrq->flags & IW_AUTH_INDEX) {\r\ncase IW_AUTH_WPA_VERSION:\r\nwpa_version = wrq->value;\r\nif(wrq->value == IW_AUTH_WPA_VERSION_DISABLED) {\r\nPRINT_K("iwctl_siwauth:set WPADEV to disable at 1??????\n");\r\n}\r\nelse if(wrq->value == IW_AUTH_WPA_VERSION_WPA) {\r\nPRINT_K("iwctl_siwauth:set WPADEV to WPA1******\n");\r\n}\r\nelse {\r\nPRINT_K("iwctl_siwauth:set WPADEV to WPA2******\n");\r\n}\r\nbreak;\r\ncase IW_AUTH_CIPHER_PAIRWISE:\r\npairwise = wrq->value;\r\nif(pairwise == IW_AUTH_CIPHER_CCMP){\r\npDevice->eEncryptionStatus = Ndis802_11Encryption3Enabled;\r\n}else if(pairwise == IW_AUTH_CIPHER_TKIP){\r\npDevice->eEncryptionStatus = Ndis802_11Encryption2Enabled;\r\n}else if(pairwise == IW_AUTH_CIPHER_WEP40||pairwise == IW_AUTH_CIPHER_WEP104){\r\npDevice->eEncryptionStatus = Ndis802_11Encryption1Enabled;\r\n}else if(pairwise == IW_AUTH_CIPHER_NONE){\r\n}else pDevice->eEncryptionStatus = Ndis802_11EncryptionDisabled;\r\nbreak;\r\ncase IW_AUTH_CIPHER_GROUP:\r\nif(wpa_version == IW_AUTH_WPA_VERSION_DISABLED)\r\nbreak;\r\nif(pairwise == IW_AUTH_CIPHER_NONE){\r\nif(wrq->value == IW_AUTH_CIPHER_CCMP){\r\npDevice->eEncryptionStatus = Ndis802_11Encryption3Enabled;\r\n}else {\r\npDevice->eEncryptionStatus = Ndis802_11Encryption2Enabled;\r\n}\r\n}\r\nbreak;\r\ncase IW_AUTH_KEY_MGMT:\r\nif(wpa_version == IW_AUTH_WPA_VERSION_WPA2){\r\nif(wrq->value == IW_AUTH_KEY_MGMT_PSK)\r\npMgmt->eAuthenMode = WMAC_AUTH_WPA2PSK;\r\nelse pMgmt->eAuthenMode = WMAC_AUTH_WPA2;\r\n}else if(wpa_version == IW_AUTH_WPA_VERSION_WPA){\r\nif(wrq->value == 0){\r\npMgmt->eAuthenMode = WMAC_AUTH_WPANONE;\r\n}else if(wrq->value == IW_AUTH_KEY_MGMT_PSK)\r\npMgmt->eAuthenMode = WMAC_AUTH_WPAPSK;\r\nelse pMgmt->eAuthenMode = WMAC_AUTH_WPA;\r\n}\r\nbreak;\r\ncase IW_AUTH_TKIP_COUNTERMEASURES:\r\nbreak;\r\ncase IW_AUTH_DROP_UNENCRYPTED:\r\nbreak;\r\ncase IW_AUTH_80211_AUTH_ALG:\r\nif(wrq->value==IW_AUTH_ALG_OPEN_SYSTEM){\r\npMgmt->bShareKeyAlgorithm=false;\r\n}else if(wrq->value==IW_AUTH_ALG_SHARED_KEY){\r\npMgmt->bShareKeyAlgorithm=true;\r\n}\r\nbreak;\r\ncase IW_AUTH_WPA_ENABLED:\r\nbreak;\r\ncase IW_AUTH_RX_UNENCRYPTED_EAPOL:\r\nbreak;\r\ncase IW_AUTH_ROAMING_CONTROL:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\ncase IW_AUTH_PRIVACY_INVOKED:\r\npDevice->bEncryptionEnable = !!wrq->value;\r\nif(pDevice->bEncryptionEnable == false){\r\nwpa_version = 0;\r\npairwise = 0;\r\npDevice->eEncryptionStatus = Ndis802_11EncryptionDisabled;\r\npMgmt->bShareKeyAlgorithm = false;\r\npMgmt->eAuthenMode = false;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint iwctl_giwauth(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *wrq,\r\nchar *extra)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nint iwctl_siwgenie(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nint ret=0;\r\nif(wrq->length){\r\nif ((wrq->length < 2) || (extra[1]+2 != wrq->length)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif(wrq->length > MAX_WPA_IE_LEN){\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmemset(pMgmt->abyWPAIE, 0, MAX_WPA_IE_LEN);\r\nif(copy_from_user(pMgmt->abyWPAIE, extra, wrq->length)){\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\npMgmt->wWPAIELen = wrq->length;\r\n}else {\r\nmemset(pMgmt->abyWPAIE, 0, MAX_WPA_IE_LEN);\r\npMgmt->wWPAIELen = 0;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nint iwctl_giwgenie(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nint ret=0;\r\nint space = wrq->length;\r\nwrq->length = 0;\r\nif(pMgmt->wWPAIELen > 0){\r\nwrq->length = pMgmt->wWPAIELen;\r\nif(pMgmt->wWPAIELen <= space){\r\nif(copy_to_user(extra, pMgmt->abyWPAIE, pMgmt->wWPAIELen)){\r\nret = -EFAULT;\r\n}\r\n}else\r\nret = -E2BIG;\r\n}\r\nreturn ret;\r\n}\r\nint iwctl_siwencodeext(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext*)extra;\r\nstruct viawget_wpa_param *param=NULL;\r\nwpa_alg alg_name;\r\nu8 addr[6];\r\nint key_idx, set_tx=0;\r\nu8 seq[IW_ENCODE_SEQ_MAX_SIZE];\r\nu8 key[64];\r\nsize_t seq_len=0,key_len=0;\r\nu8 *buf;\r\nsize_t blen;\r\nu8 key_array[64];\r\nint ret=0;\r\nPRINT_K("SIOCSIWENCODEEXT...... \n");\r\nblen = sizeof(*param);\r\nbuf = kmalloc((int)blen, (int)GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nmemset(buf, 0, blen);\r\nparam = (struct viawget_wpa_param *) buf;\r\nswitch (ext->alg) {\r\ncase IW_ENCODE_ALG_NONE:\r\nalg_name = WPA_ALG_NONE;\r\nbreak;\r\ncase IW_ENCODE_ALG_WEP:\r\nalg_name = WPA_ALG_WEP;\r\nbreak;\r\ncase IW_ENCODE_ALG_TKIP:\r\nalg_name = WPA_ALG_TKIP;\r\nbreak;\r\ncase IW_ENCODE_ALG_CCMP:\r\nalg_name = WPA_ALG_CCMP;\r\nbreak;\r\ndefault:\r\nPRINT_K("Unknown alg = %d\n",ext->alg);\r\nret= -ENOMEM;\r\ngoto error;\r\n}\r\nmemcpy(addr, ext->addr.sa_data, ETH_ALEN);\r\nkey_idx = (wrq->flags&IW_ENCODE_INDEX) - 1;\r\nif(ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY)\r\nset_tx = 1;\r\nif(ext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID) {\r\nseq_len=IW_ENCODE_SEQ_MAX_SIZE;\r\nmemcpy(seq, ext->rx_seq, seq_len);\r\n}\r\nif(ext->key_len) {\r\nkey_len=ext->key_len;\r\nmemcpy(key, &ext->key[0], key_len);\r\n}\r\nmemset(key_array, 0, 64);\r\nif ( key_len > 0) {\r\nmemcpy(key_array, key, key_len);\r\nif (key_len == 32) {\r\nmemcpy(&key_array[16], &key[24], 8);\r\nmemcpy(&key_array[24], &key[16], 8);\r\n}\r\n}\r\nmemcpy(param->addr, addr, ETH_ALEN);\r\nparam->u.wpa_key.alg_name = (int)alg_name;\r\nparam->u.wpa_key.set_tx = set_tx;\r\nparam->u.wpa_key.key_index = key_idx;\r\nparam->u.wpa_key.key_len = key_len;\r\nparam->u.wpa_key.key = (u8 *)key_array;\r\nparam->u.wpa_key.seq = (u8 *)seq;\r\nparam->u.wpa_key.seq_len = seq_len;\r\n#if 0\r\nprintk("param->u.wpa_key.alg_name =%d\n",param->u.wpa_key.alg_name);\r\nprintk(KERN_DEBUG "param->addr=%pM\n", param->addr);\r\nprintk("param->u.wpa_key.set_tx =%d\n",param->u.wpa_key.set_tx);\r\nprintk("param->u.wpa_key.key_index =%d\n",param->u.wpa_key.key_index);\r\nprintk("param->u.wpa_key.key_len =%d\n",param->u.wpa_key.key_len);\r\nprintk("param->u.wpa_key.key =");\r\nfor(ii=0;ii<param->u.wpa_key.key_len;ii++)\r\nprintk("%02x:",param->u.wpa_key.key[ii]);\r\nprintk("\n");\r\nprintk("param->u.wpa_key.seq_len =%d\n",param->u.wpa_key.seq_len);\r\nprintk("param->u.wpa_key.seq =");\r\nfor(ii=0;ii<param->u.wpa_key.seq_len;ii++)\r\nprintk("%02x:",param->u.wpa_key.seq[ii]);\r\nprintk("\n");\r\nprintk("...........\n");\r\n#endif\r\nif(param->u.wpa_key.alg_name == WPA_ALG_NONE) {\r\nif(param->u.wpa_key.key_index ==0) {\r\npDevice->bwextcount++;\r\n}\r\nif((pDevice->bwextcount == 1)&&(param->u.wpa_key.key_index ==1)) {\r\npDevice->bwextcount++;\r\n}\r\nif((pDevice->bwextcount ==2)&&(param->u.wpa_key.key_index ==2)) {\r\npDevice->bwextcount++;\r\n}\r\nif((pDevice->bwextcount ==3)&&(param->u.wpa_key.key_index ==3)) {\r\npDevice->bwextcount++;\r\n}\r\n}\r\nif( pDevice->bwextcount == 4) {\r\nprintk("SIOCSIWENCODEEXT:Enable WPA WEXT SUPPORT!!!!!\n");\r\npDevice->bwextcount=0;\r\npDevice->bWPASuppWextEnabled = true;\r\n}\r\nspin_lock_irq(&pDevice->lock);\r\nret = wpa_set_keys(pDevice, param, true);\r\nspin_unlock_irq(&pDevice->lock);\r\nerror:\r\nkfree(param);\r\nreturn ret;\r\n}\r\nint iwctl_giwencodeext(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_point *wrq,\r\nchar *extra)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nint iwctl_siwmlme(struct net_device *dev,\r\nstruct iw_request_info * info,\r\nstruct iw_point *wrq,\r\nchar *extra)\r\n{\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nstruct iw_mlme *mlme = (struct iw_mlme *)extra;\r\nint ret = 0;\r\nif(memcmp(pMgmt->abyCurrBSSID, mlme->addr.sa_data, ETH_ALEN)){\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nswitch(mlme->cmd){\r\ncase IW_MLME_DEAUTH:\r\nbreak;\r\ncase IW_MLME_DISASSOC:\r\nif(pDevice->bLinkPass == true){\r\nprintk("iwctl_siwmlme--->send DISASSOCIATE\n");\r\nmemset(pMgmt->abyDesireBSSID, 0xFF,6);\r\nKeyvInitTable(&pDevice->sKey, pDevice->PortOffset);\r\nbScheduleCommand((void *)pDevice, WLAN_CMD_DISASSOCIATE, NULL);\r\n}\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}
