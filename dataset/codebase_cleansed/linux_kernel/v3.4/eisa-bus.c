static int is_forced_dev(int *forced_tab,\r\nint forced_count,\r\nstruct eisa_root_device *root,\r\nstruct eisa_device *edev)\r\n{\r\nint i, x;\r\nfor (i = 0; i < forced_count; i++) {\r\nx = (root->bus_nr << 8) | edev->slot;\r\nif (forced_tab[i] == x)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init eisa_name_device(struct eisa_device *edev)\r\n{\r\n#ifdef CONFIG_EISA_NAMES\r\nint i;\r\nfor (i = 0; i < EISA_INFOS; i++) {\r\nif (!strcmp(edev->id.sig, eisa_table[i].id.sig)) {\r\nstrlcpy(edev->pretty_name,\r\neisa_table[i].name,\r\nsizeof(edev->pretty_name));\r\nreturn;\r\n}\r\n}\r\nsprintf(edev->pretty_name, "EISA device %.7s", edev->id.sig);\r\n#endif\r\n}\r\nstatic char __init *decode_eisa_sig(unsigned long addr)\r\n{\r\nstatic char sig_str[EISA_SIG_LEN];\r\nu8 sig[4];\r\nu16 rev;\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\n#ifdef CONFIG_EISA_VLB_PRIMING\r\noutb(0x80 + i, addr);\r\n#endif\r\nsig[i] = inb(addr + i);\r\nif (!i && (sig[0] & 0x80))\r\nreturn NULL;\r\n}\r\nsig_str[0] = ((sig[0] >> 2) & 0x1f) + ('A' - 1);\r\nsig_str[1] = (((sig[0] & 3) << 3) | (sig[1] >> 5)) + ('A' - 1);\r\nsig_str[2] = (sig[1] & 0x1f) + ('A' - 1);\r\nrev = (sig[2] << 8) | sig[3];\r\nsprintf(sig_str + 3, "%04X", rev);\r\nreturn sig_str;\r\n}\r\nstatic int eisa_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct eisa_device *edev = to_eisa_device(dev);\r\nstruct eisa_driver *edrv = to_eisa_driver(drv);\r\nconst struct eisa_device_id *eids = edrv->id_table;\r\nif (!eids)\r\nreturn 0;\r\nwhile (strlen(eids->sig)) {\r\nif (!strcmp(eids->sig, edev->id.sig) &&\r\nedev->state & EISA_CONFIG_ENABLED) {\r\nedev->id.driver_data = eids->driver_data;\r\nreturn 1;\r\n}\r\neids++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int eisa_bus_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct eisa_device *edev = to_eisa_device(dev);\r\nadd_uevent_var(env, "MODALIAS=" EISA_DEVICE_MODALIAS_FMT, edev->id.sig);\r\nreturn 0;\r\n}\r\nint eisa_driver_register(struct eisa_driver *edrv)\r\n{\r\nedrv->driver.bus = &eisa_bus_type;\r\nreturn driver_register(&edrv->driver);\r\n}\r\nvoid eisa_driver_unregister(struct eisa_driver *edrv)\r\n{\r\ndriver_unregister(&edrv->driver);\r\n}\r\nstatic ssize_t eisa_show_sig(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct eisa_device *edev = to_eisa_device(dev);\r\nreturn sprintf(buf, "%s\n", edev->id.sig);\r\n}\r\nstatic ssize_t eisa_show_state(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct eisa_device *edev = to_eisa_device(dev);\r\nreturn sprintf(buf, "%d\n", edev->state & EISA_CONFIG_ENABLED);\r\n}\r\nstatic ssize_t eisa_show_modalias(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct eisa_device *edev = to_eisa_device(dev);\r\nreturn sprintf(buf, EISA_DEVICE_MODALIAS_FMT "\n", edev->id.sig);\r\n}\r\nstatic int __init eisa_init_device(struct eisa_root_device *root,\r\nstruct eisa_device *edev,\r\nint slot)\r\n{\r\nchar *sig;\r\nunsigned long sig_addr;\r\nint i;\r\nsig_addr = SLOT_ADDRESS(root, slot) + EISA_VENDOR_ID_OFFSET;\r\nsig = decode_eisa_sig(sig_addr);\r\nif (!sig)\r\nreturn -1;\r\nmemcpy(edev->id.sig, sig, EISA_SIG_LEN);\r\nedev->slot = slot;\r\nedev->state = inb(SLOT_ADDRESS(root, slot) + EISA_CONFIG_OFFSET)\r\n& EISA_CONFIG_ENABLED;\r\nedev->base_addr = SLOT_ADDRESS(root, slot);\r\nedev->dma_mask = root->dma_mask;\r\neisa_name_device(edev);\r\nedev->dev.parent = root->dev;\r\nedev->dev.bus = &eisa_bus_type;\r\nedev->dev.dma_mask = &edev->dma_mask;\r\nedev->dev.coherent_dma_mask = edev->dma_mask;\r\ndev_set_name(&edev->dev, "%02X:%02X", root->bus_nr, slot);\r\nfor (i = 0; i < EISA_MAX_RESOURCES; i++) {\r\n#ifdef CONFIG_EISA_NAMES\r\nedev->res[i].name = edev->pretty_name;\r\n#else\r\nedev->res[i].name = edev->id.sig;\r\n#endif\r\n}\r\nif (is_forced_dev(enable_dev, enable_dev_count, root, edev))\r\nedev->state = EISA_CONFIG_ENABLED | EISA_CONFIG_FORCED;\r\nif (is_forced_dev(disable_dev, disable_dev_count, root, edev))\r\nedev->state = EISA_CONFIG_FORCED;\r\nreturn 0;\r\n}\r\nstatic int __init eisa_register_device(struct eisa_device *edev)\r\n{\r\nint rc = device_register(&edev->dev);\r\nif (rc)\r\nreturn rc;\r\nrc = device_create_file(&edev->dev, &dev_attr_signature);\r\nif (rc)\r\ngoto err_devreg;\r\nrc = device_create_file(&edev->dev, &dev_attr_enabled);\r\nif (rc)\r\ngoto err_sig;\r\nrc = device_create_file(&edev->dev, &dev_attr_modalias);\r\nif (rc)\r\ngoto err_enab;\r\nreturn 0;\r\nerr_enab:\r\ndevice_remove_file(&edev->dev, &dev_attr_enabled);\r\nerr_sig:\r\ndevice_remove_file(&edev->dev, &dev_attr_signature);\r\nerr_devreg:\r\ndevice_unregister(&edev->dev);\r\nreturn rc;\r\n}\r\nstatic int __init eisa_request_resources(struct eisa_root_device *root,\r\nstruct eisa_device *edev,\r\nint slot)\r\n{\r\nint i;\r\nfor (i = 0; i < EISA_MAX_RESOURCES; i++) {\r\nif (!slot && i > 0) {\r\nedev->res[i].start = edev->res[i].end = 0;\r\ncontinue;\r\n}\r\nif (slot) {\r\nedev->res[i].name = NULL;\r\nedev->res[i].start = SLOT_ADDRESS(root, slot)\r\n+ (i * 0x400);\r\nedev->res[i].end = edev->res[i].start + 0xff;\r\nedev->res[i].flags = IORESOURCE_IO;\r\n} else {\r\nedev->res[i].name = NULL;\r\nedev->res[i].start = SLOT_ADDRESS(root, slot)\r\n+ EISA_VENDOR_ID_OFFSET;\r\nedev->res[i].end = edev->res[i].start + 3;\r\nedev->res[i].flags = IORESOURCE_BUSY;\r\n}\r\nif (request_resource(root->res, &edev->res[i]))\r\ngoto failed;\r\n}\r\nreturn 0;\r\nfailed:\r\nwhile (--i >= 0)\r\nrelease_resource(&edev->res[i]);\r\nreturn -1;\r\n}\r\nstatic void __init eisa_release_resources(struct eisa_device *edev)\r\n{\r\nint i;\r\nfor (i = 0; i < EISA_MAX_RESOURCES; i++)\r\nif (edev->res[i].start || edev->res[i].end)\r\nrelease_resource(&edev->res[i]);\r\n}\r\nstatic int __init eisa_probe(struct eisa_root_device *root)\r\n{\r\nint i, c;\r\nstruct eisa_device *edev;\r\nprintk(KERN_INFO "EISA: Probing bus %d at %s\n",\r\nroot->bus_nr, dev_name(root->dev));\r\nedev = kzalloc(sizeof(*edev), GFP_KERNEL);\r\nif (!edev) {\r\nprintk(KERN_ERR "EISA: Couldn't allocate mainboard slot\n");\r\nreturn -ENOMEM;\r\n}\r\nif (eisa_request_resources(root, edev, 0)) {\r\nprintk(KERN_WARNING \\r\n"EISA: Cannot allocate resource for mainboard\n");\r\nkfree(edev);\r\nif (!root->force_probe)\r\nreturn -EBUSY;\r\ngoto force_probe;\r\n}\r\nif (eisa_init_device(root, edev, 0)) {\r\neisa_release_resources(edev);\r\nkfree(edev);\r\nif (!root->force_probe)\r\nreturn -ENODEV;\r\ngoto force_probe;\r\n}\r\nprintk(KERN_INFO "EISA: Mainboard %s detected.\n", edev->id.sig);\r\nif (eisa_register_device(edev)) {\r\nprintk(KERN_ERR "EISA: Failed to register %s\n",\r\nedev->id.sig);\r\neisa_release_resources(edev);\r\nkfree(edev);\r\n}\r\nforce_probe:\r\nfor (c = 0, i = 1; i <= root->slots; i++) {\r\nedev = kzalloc(sizeof(*edev), GFP_KERNEL);\r\nif (!edev) {\r\nprintk(KERN_ERR "EISA: Out of memory for slot %d\n", i);\r\ncontinue;\r\n}\r\nif (eisa_request_resources(root, edev, i)) {\r\nprintk(KERN_WARNING \\r\n"Cannot allocate resource for EISA slot %d\n",\r\ni);\r\nkfree(edev);\r\ncontinue;\r\n}\r\nif (eisa_init_device(root, edev, i)) {\r\neisa_release_resources(edev);\r\nkfree(edev);\r\ncontinue;\r\n}\r\nprintk(KERN_INFO "EISA: slot %d : %s detected",\r\ni, edev->id.sig);\r\nswitch (edev->state) {\r\ncase EISA_CONFIG_ENABLED | EISA_CONFIG_FORCED:\r\nprintk(" (forced enabled)");\r\nbreak;\r\ncase EISA_CONFIG_FORCED:\r\nprintk(" (forced disabled)");\r\nbreak;\r\ncase 0:\r\nprintk(" (disabled)");\r\nbreak;\r\n}\r\nprintk (".\n");\r\nc++;\r\nif (eisa_register_device(edev)) {\r\nprintk(KERN_ERR "EISA: Failed to register %s\n",\r\nedev->id.sig);\r\neisa_release_resources(edev);\r\nkfree(edev);\r\n}\r\n}\r\nprintk(KERN_INFO "EISA: Detected %d card%s.\n", c, c == 1 ? "" : "s");\r\nreturn 0;\r\n}\r\nint __init eisa_root_register(struct eisa_root_device *root)\r\n{\r\nint err;\r\nroot->eisa_root_res.name = eisa_root_res.name;\r\nroot->eisa_root_res.start = root->res->start;\r\nroot->eisa_root_res.end = root->res->end;\r\nroot->eisa_root_res.flags = IORESOURCE_BUSY;\r\nerr = request_resource(&eisa_root_res, &root->eisa_root_res);\r\nif (err)\r\nreturn err;\r\nroot->bus_nr = eisa_bus_count++;\r\nerr = eisa_probe(root);\r\nif (err)\r\nrelease_resource(&root->eisa_root_res);\r\nreturn err;\r\n}\r\nstatic int __init eisa_init(void)\r\n{\r\nint r;\r\nr = bus_register(&eisa_bus_type);\r\nif (r)\r\nreturn r;\r\nprintk(KERN_INFO "EISA bus registered\n");\r\nreturn 0;\r\n}
