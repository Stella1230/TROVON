static struct page *page_chain_del(struct page **head, int n)\r\n{\r\nstruct page *page;\r\nstruct page *tmp;\r\nBUG_ON(!n);\r\nBUG_ON(!head);\r\npage = *head;\r\nif (!page)\r\nreturn NULL;\r\nwhile (page) {\r\ntmp = page_chain_next(page);\r\nif (--n == 0)\r\nbreak;\r\nif (tmp == NULL)\r\nreturn NULL;\r\npage = tmp;\r\n}\r\nset_page_private(page, 0);\r\npage = *head;\r\n*head = tmp;\r\nreturn page;\r\n}\r\nstatic struct page *page_chain_tail(struct page *page, int *len)\r\n{\r\nstruct page *tmp;\r\nint i = 1;\r\nwhile ((tmp = page_chain_next(page)))\r\n++i, page = tmp;\r\nif (len)\r\n*len = i;\r\nreturn page;\r\n}\r\nstatic int page_chain_free(struct page *page)\r\n{\r\nstruct page *tmp;\r\nint i = 0;\r\npage_chain_for_each_safe(page, tmp) {\r\nput_page(page);\r\n++i;\r\n}\r\nreturn i;\r\n}\r\nstatic void page_chain_add(struct page **head,\r\nstruct page *chain_first, struct page *chain_last)\r\n{\r\n#if 1\r\nstruct page *tmp;\r\ntmp = page_chain_tail(chain_first, NULL);\r\nBUG_ON(tmp != chain_last);\r\n#endif\r\nset_page_private(chain_last, (unsigned long)*head);\r\n*head = chain_first;\r\n}\r\nstatic struct page *drbd_pp_first_pages_or_try_alloc(struct drbd_conf *mdev, int number)\r\n{\r\nstruct page *page = NULL;\r\nstruct page *tmp = NULL;\r\nint i = 0;\r\nif (drbd_pp_vacant >= number) {\r\nspin_lock(&drbd_pp_lock);\r\npage = page_chain_del(&drbd_pp_pool, number);\r\nif (page)\r\ndrbd_pp_vacant -= number;\r\nspin_unlock(&drbd_pp_lock);\r\nif (page)\r\nreturn page;\r\n}\r\nfor (i = 0; i < number; i++) {\r\ntmp = alloc_page(GFP_TRY);\r\nif (!tmp)\r\nbreak;\r\nset_page_private(tmp, (unsigned long)page);\r\npage = tmp;\r\n}\r\nif (i == number)\r\nreturn page;\r\nif (page) {\r\ntmp = page_chain_tail(page, NULL);\r\nspin_lock(&drbd_pp_lock);\r\npage_chain_add(&drbd_pp_pool, page, tmp);\r\ndrbd_pp_vacant += i;\r\nspin_unlock(&drbd_pp_lock);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void reclaim_net_ee(struct drbd_conf *mdev, struct list_head *to_be_freed)\r\n{\r\nstruct drbd_epoch_entry *e;\r\nstruct list_head *le, *tle;\r\nlist_for_each_safe(le, tle, &mdev->net_ee) {\r\ne = list_entry(le, struct drbd_epoch_entry, w.list);\r\nif (drbd_ee_has_active_page(e))\r\nbreak;\r\nlist_move(le, to_be_freed);\r\n}\r\n}\r\nstatic void drbd_kick_lo_and_reclaim_net(struct drbd_conf *mdev)\r\n{\r\nLIST_HEAD(reclaimed);\r\nstruct drbd_epoch_entry *e, *t;\r\nspin_lock_irq(&mdev->req_lock);\r\nreclaim_net_ee(mdev, &reclaimed);\r\nspin_unlock_irq(&mdev->req_lock);\r\nlist_for_each_entry_safe(e, t, &reclaimed, w.list)\r\ndrbd_free_net_ee(mdev, e);\r\n}\r\nstatic struct page *drbd_pp_alloc(struct drbd_conf *mdev, unsigned number, bool retry)\r\n{\r\nstruct page *page = NULL;\r\nDEFINE_WAIT(wait);\r\nif (atomic_read(&mdev->pp_in_use) < mdev->net_conf->max_buffers)\r\npage = drbd_pp_first_pages_or_try_alloc(mdev, number);\r\nwhile (page == NULL) {\r\nprepare_to_wait(&drbd_pp_wait, &wait, TASK_INTERRUPTIBLE);\r\ndrbd_kick_lo_and_reclaim_net(mdev);\r\nif (atomic_read(&mdev->pp_in_use) < mdev->net_conf->max_buffers) {\r\npage = drbd_pp_first_pages_or_try_alloc(mdev, number);\r\nif (page)\r\nbreak;\r\n}\r\nif (!retry)\r\nbreak;\r\nif (signal_pending(current)) {\r\ndev_warn(DEV, "drbd_pp_alloc interrupted!\n");\r\nbreak;\r\n}\r\nschedule();\r\n}\r\nfinish_wait(&drbd_pp_wait, &wait);\r\nif (page)\r\natomic_add(number, &mdev->pp_in_use);\r\nreturn page;\r\n}\r\nstatic void drbd_pp_free(struct drbd_conf *mdev, struct page *page, int is_net)\r\n{\r\natomic_t *a = is_net ? &mdev->pp_in_use_by_net : &mdev->pp_in_use;\r\nint i;\r\nif (drbd_pp_vacant > (DRBD_MAX_BIO_SIZE/PAGE_SIZE)*minor_count)\r\ni = page_chain_free(page);\r\nelse {\r\nstruct page *tmp;\r\ntmp = page_chain_tail(page, &i);\r\nspin_lock(&drbd_pp_lock);\r\npage_chain_add(&drbd_pp_pool, page, tmp);\r\ndrbd_pp_vacant += i;\r\nspin_unlock(&drbd_pp_lock);\r\n}\r\ni = atomic_sub_return(i, a);\r\nif (i < 0)\r\ndev_warn(DEV, "ASSERTION FAILED: %s: %d < 0\n",\r\nis_net ? "pp_in_use_by_net" : "pp_in_use", i);\r\nwake_up(&drbd_pp_wait);\r\n}\r\nstruct drbd_epoch_entry *drbd_alloc_ee(struct drbd_conf *mdev,\r\nu64 id,\r\nsector_t sector,\r\nunsigned int data_size,\r\ngfp_t gfp_mask) __must_hold(local)\r\n{\r\nstruct drbd_epoch_entry *e;\r\nstruct page *page;\r\nunsigned nr_pages = (data_size + PAGE_SIZE -1) >> PAGE_SHIFT;\r\nif (drbd_insert_fault(mdev, DRBD_FAULT_AL_EE))\r\nreturn NULL;\r\ne = mempool_alloc(drbd_ee_mempool, gfp_mask & ~__GFP_HIGHMEM);\r\nif (!e) {\r\nif (!(gfp_mask & __GFP_NOWARN))\r\ndev_err(DEV, "alloc_ee: Allocation of an EE failed\n");\r\nreturn NULL;\r\n}\r\npage = drbd_pp_alloc(mdev, nr_pages, (gfp_mask & __GFP_WAIT));\r\nif (!page)\r\ngoto fail;\r\nINIT_HLIST_NODE(&e->collision);\r\ne->epoch = NULL;\r\ne->mdev = mdev;\r\ne->pages = page;\r\natomic_set(&e->pending_bios, 0);\r\ne->size = data_size;\r\ne->flags = 0;\r\ne->sector = sector;\r\ne->block_id = id;\r\nreturn e;\r\nfail:\r\nmempool_free(e, drbd_ee_mempool);\r\nreturn NULL;\r\n}\r\nvoid drbd_free_some_ee(struct drbd_conf *mdev, struct drbd_epoch_entry *e, int is_net)\r\n{\r\nif (e->flags & EE_HAS_DIGEST)\r\nkfree(e->digest);\r\ndrbd_pp_free(mdev, e->pages, is_net);\r\nD_ASSERT(atomic_read(&e->pending_bios) == 0);\r\nD_ASSERT(hlist_unhashed(&e->collision));\r\nmempool_free(e, drbd_ee_mempool);\r\n}\r\nint drbd_release_ee(struct drbd_conf *mdev, struct list_head *list)\r\n{\r\nLIST_HEAD(work_list);\r\nstruct drbd_epoch_entry *e, *t;\r\nint count = 0;\r\nint is_net = list == &mdev->net_ee;\r\nspin_lock_irq(&mdev->req_lock);\r\nlist_splice_init(list, &work_list);\r\nspin_unlock_irq(&mdev->req_lock);\r\nlist_for_each_entry_safe(e, t, &work_list, w.list) {\r\ndrbd_free_some_ee(mdev, e, is_net);\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic int drbd_process_done_ee(struct drbd_conf *mdev)\r\n{\r\nLIST_HEAD(work_list);\r\nLIST_HEAD(reclaimed);\r\nstruct drbd_epoch_entry *e, *t;\r\nint ok = (mdev->state.conn >= C_WF_REPORT_PARAMS);\r\nspin_lock_irq(&mdev->req_lock);\r\nreclaim_net_ee(mdev, &reclaimed);\r\nlist_splice_init(&mdev->done_ee, &work_list);\r\nspin_unlock_irq(&mdev->req_lock);\r\nlist_for_each_entry_safe(e, t, &reclaimed, w.list)\r\ndrbd_free_net_ee(mdev, e);\r\nlist_for_each_entry_safe(e, t, &work_list, w.list) {\r\nok = e->w.cb(mdev, &e->w, !ok) && ok;\r\ndrbd_free_ee(mdev, e);\r\n}\r\nwake_up(&mdev->ee_wait);\r\nreturn ok;\r\n}\r\nvoid _drbd_wait_ee_list_empty(struct drbd_conf *mdev, struct list_head *head)\r\n{\r\nDEFINE_WAIT(wait);\r\nwhile (!list_empty(head)) {\r\nprepare_to_wait(&mdev->ee_wait, &wait, TASK_UNINTERRUPTIBLE);\r\nspin_unlock_irq(&mdev->req_lock);\r\nio_schedule();\r\nfinish_wait(&mdev->ee_wait, &wait);\r\nspin_lock_irq(&mdev->req_lock);\r\n}\r\n}\r\nvoid drbd_wait_ee_list_empty(struct drbd_conf *mdev, struct list_head *head)\r\n{\r\nspin_lock_irq(&mdev->req_lock);\r\n_drbd_wait_ee_list_empty(mdev, head);\r\nspin_unlock_irq(&mdev->req_lock);\r\n}\r\nstatic int drbd_accept(struct drbd_conf *mdev, const char **what,\r\nstruct socket *sock, struct socket **newsock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint err = 0;\r\n*what = "listen";\r\nerr = sock->ops->listen(sock, 5);\r\nif (err < 0)\r\ngoto out;\r\n*what = "sock_create_lite";\r\nerr = sock_create_lite(sk->sk_family, sk->sk_type, sk->sk_protocol,\r\nnewsock);\r\nif (err < 0)\r\ngoto out;\r\n*what = "accept";\r\nerr = sock->ops->accept(sock, *newsock, 0);\r\nif (err < 0) {\r\nsock_release(*newsock);\r\n*newsock = NULL;\r\ngoto out;\r\n}\r\n(*newsock)->ops = sock->ops;\r\nout:\r\nreturn err;\r\n}\r\nstatic int drbd_recv_short(struct drbd_conf *mdev, struct socket *sock,\r\nvoid *buf, size_t size, int flags)\r\n{\r\nmm_segment_t oldfs;\r\nstruct kvec iov = {\r\n.iov_base = buf,\r\n.iov_len = size,\r\n};\r\nstruct msghdr msg = {\r\n.msg_iovlen = 1,\r\n.msg_iov = (struct iovec *)&iov,\r\n.msg_flags = (flags ? flags : MSG_WAITALL | MSG_NOSIGNAL)\r\n};\r\nint rv;\r\noldfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nrv = sock_recvmsg(sock, &msg, size, msg.msg_flags);\r\nset_fs(oldfs);\r\nreturn rv;\r\n}\r\nstatic int drbd_recv(struct drbd_conf *mdev, void *buf, size_t size)\r\n{\r\nmm_segment_t oldfs;\r\nstruct kvec iov = {\r\n.iov_base = buf,\r\n.iov_len = size,\r\n};\r\nstruct msghdr msg = {\r\n.msg_iovlen = 1,\r\n.msg_iov = (struct iovec *)&iov,\r\n.msg_flags = MSG_WAITALL | MSG_NOSIGNAL\r\n};\r\nint rv;\r\noldfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nfor (;;) {\r\nrv = sock_recvmsg(mdev->data.socket, &msg, size, msg.msg_flags);\r\nif (rv == size)\r\nbreak;\r\nif (rv < 0) {\r\nif (rv == -ECONNRESET)\r\ndev_info(DEV, "sock was reset by peer\n");\r\nelse if (rv != -ERESTARTSYS)\r\ndev_err(DEV, "sock_recvmsg returned %d\n", rv);\r\nbreak;\r\n} else if (rv == 0) {\r\ndev_info(DEV, "sock was shut down by peer\n");\r\nbreak;\r\n} else {\r\nbreak;\r\n}\r\n};\r\nset_fs(oldfs);\r\nif (rv != size)\r\ndrbd_force_state(mdev, NS(conn, C_BROKEN_PIPE));\r\nreturn rv;\r\n}\r\nstatic void drbd_setbufsize(struct socket *sock, unsigned int snd,\r\nunsigned int rcv)\r\n{\r\nif (snd) {\r\nsock->sk->sk_sndbuf = snd;\r\nsock->sk->sk_userlocks |= SOCK_SNDBUF_LOCK;\r\n}\r\nif (rcv) {\r\nsock->sk->sk_rcvbuf = rcv;\r\nsock->sk->sk_userlocks |= SOCK_RCVBUF_LOCK;\r\n}\r\n}\r\nstatic struct socket *drbd_try_connect(struct drbd_conf *mdev)\r\n{\r\nconst char *what;\r\nstruct socket *sock;\r\nstruct sockaddr_in6 src_in6;\r\nint err;\r\nint disconnect_on_error = 1;\r\nif (!get_net_conf(mdev))\r\nreturn NULL;\r\nwhat = "sock_create_kern";\r\nerr = sock_create_kern(((struct sockaddr *)mdev->net_conf->my_addr)->sa_family,\r\nSOCK_STREAM, IPPROTO_TCP, &sock);\r\nif (err < 0) {\r\nsock = NULL;\r\ngoto out;\r\n}\r\nsock->sk->sk_rcvtimeo =\r\nsock->sk->sk_sndtimeo = mdev->net_conf->try_connect_int*HZ;\r\ndrbd_setbufsize(sock, mdev->net_conf->sndbuf_size,\r\nmdev->net_conf->rcvbuf_size);\r\nmemcpy(&src_in6, mdev->net_conf->my_addr,\r\nmin_t(int, mdev->net_conf->my_addr_len, sizeof(src_in6)));\r\nif (((struct sockaddr *)mdev->net_conf->my_addr)->sa_family == AF_INET6)\r\nsrc_in6.sin6_port = 0;\r\nelse\r\n((struct sockaddr_in *)&src_in6)->sin_port = 0;\r\nwhat = "bind before connect";\r\nerr = sock->ops->bind(sock,\r\n(struct sockaddr *) &src_in6,\r\nmdev->net_conf->my_addr_len);\r\nif (err < 0)\r\ngoto out;\r\ndisconnect_on_error = 0;\r\nwhat = "connect";\r\nerr = sock->ops->connect(sock,\r\n(struct sockaddr *)mdev->net_conf->peer_addr,\r\nmdev->net_conf->peer_addr_len, 0);\r\nout:\r\nif (err < 0) {\r\nif (sock) {\r\nsock_release(sock);\r\nsock = NULL;\r\n}\r\nswitch (-err) {\r\ncase ETIMEDOUT: case EAGAIN: case EINPROGRESS:\r\ncase EINTR: case ERESTARTSYS:\r\ncase ECONNREFUSED: case ENETUNREACH:\r\ncase EHOSTDOWN: case EHOSTUNREACH:\r\ndisconnect_on_error = 0;\r\nbreak;\r\ndefault:\r\ndev_err(DEV, "%s failed, err = %d\n", what, err);\r\n}\r\nif (disconnect_on_error)\r\ndrbd_force_state(mdev, NS(conn, C_DISCONNECTING));\r\n}\r\nput_net_conf(mdev);\r\nreturn sock;\r\n}\r\nstatic struct socket *drbd_wait_for_connect(struct drbd_conf *mdev)\r\n{\r\nint timeo, err;\r\nstruct socket *s_estab = NULL, *s_listen;\r\nconst char *what;\r\nif (!get_net_conf(mdev))\r\nreturn NULL;\r\nwhat = "sock_create_kern";\r\nerr = sock_create_kern(((struct sockaddr *)mdev->net_conf->my_addr)->sa_family,\r\nSOCK_STREAM, IPPROTO_TCP, &s_listen);\r\nif (err) {\r\ns_listen = NULL;\r\ngoto out;\r\n}\r\ntimeo = mdev->net_conf->try_connect_int * HZ;\r\ntimeo += (random32() & 1) ? timeo / 7 : -timeo / 7;\r\ns_listen->sk->sk_reuse = 1;\r\ns_listen->sk->sk_rcvtimeo = timeo;\r\ns_listen->sk->sk_sndtimeo = timeo;\r\ndrbd_setbufsize(s_listen, mdev->net_conf->sndbuf_size,\r\nmdev->net_conf->rcvbuf_size);\r\nwhat = "bind before listen";\r\nerr = s_listen->ops->bind(s_listen,\r\n(struct sockaddr *) mdev->net_conf->my_addr,\r\nmdev->net_conf->my_addr_len);\r\nif (err < 0)\r\ngoto out;\r\nerr = drbd_accept(mdev, &what, s_listen, &s_estab);\r\nout:\r\nif (s_listen)\r\nsock_release(s_listen);\r\nif (err < 0) {\r\nif (err != -EAGAIN && err != -EINTR && err != -ERESTARTSYS) {\r\ndev_err(DEV, "%s failed, err = %d\n", what, err);\r\ndrbd_force_state(mdev, NS(conn, C_DISCONNECTING));\r\n}\r\n}\r\nput_net_conf(mdev);\r\nreturn s_estab;\r\n}\r\nstatic int drbd_send_fp(struct drbd_conf *mdev,\r\nstruct socket *sock, enum drbd_packets cmd)\r\n{\r\nstruct p_header80 *h = &mdev->data.sbuf.header.h80;\r\nreturn _drbd_send_cmd(mdev, sock, cmd, h, sizeof(*h), 0);\r\n}\r\nstatic enum drbd_packets drbd_recv_fp(struct drbd_conf *mdev, struct socket *sock)\r\n{\r\nstruct p_header80 *h = &mdev->data.rbuf.header.h80;\r\nint rr;\r\nrr = drbd_recv_short(mdev, sock, h, sizeof(*h), 0);\r\nif (rr == sizeof(*h) && h->magic == BE_DRBD_MAGIC)\r\nreturn be16_to_cpu(h->command);\r\nreturn 0xffff;\r\n}\r\nstatic int drbd_socket_okay(struct drbd_conf *mdev, struct socket **sock)\r\n{\r\nint rr;\r\nchar tb[4];\r\nif (!*sock)\r\nreturn false;\r\nrr = drbd_recv_short(mdev, *sock, tb, 4, MSG_DONTWAIT | MSG_PEEK);\r\nif (rr > 0 || rr == -EAGAIN) {\r\nreturn true;\r\n} else {\r\nsock_release(*sock);\r\n*sock = NULL;\r\nreturn false;\r\n}\r\n}\r\nstatic int drbd_connect(struct drbd_conf *mdev)\r\n{\r\nstruct socket *s, *sock, *msock;\r\nint try, h, ok;\r\nD_ASSERT(!mdev->data.socket);\r\nif (drbd_request_state(mdev, NS(conn, C_WF_CONNECTION)) < SS_SUCCESS)\r\nreturn -2;\r\nclear_bit(DISCARD_CONCURRENT, &mdev->flags);\r\nsock = NULL;\r\nmsock = NULL;\r\ndo {\r\nfor (try = 0;;) {\r\ns = drbd_try_connect(mdev);\r\nif (s || ++try >= 3)\r\nbreak;\r\nschedule_timeout_interruptible(HZ / 10);\r\n}\r\nif (s) {\r\nif (!sock) {\r\ndrbd_send_fp(mdev, s, P_HAND_SHAKE_S);\r\nsock = s;\r\ns = NULL;\r\n} else if (!msock) {\r\ndrbd_send_fp(mdev, s, P_HAND_SHAKE_M);\r\nmsock = s;\r\ns = NULL;\r\n} else {\r\ndev_err(DEV, "Logic error in drbd_connect()\n");\r\ngoto out_release_sockets;\r\n}\r\n}\r\nif (sock && msock) {\r\nschedule_timeout_interruptible(mdev->net_conf->ping_timeo*HZ/10);\r\nok = drbd_socket_okay(mdev, &sock);\r\nok = drbd_socket_okay(mdev, &msock) && ok;\r\nif (ok)\r\nbreak;\r\n}\r\nretry:\r\ns = drbd_wait_for_connect(mdev);\r\nif (s) {\r\ntry = drbd_recv_fp(mdev, s);\r\ndrbd_socket_okay(mdev, &sock);\r\ndrbd_socket_okay(mdev, &msock);\r\nswitch (try) {\r\ncase P_HAND_SHAKE_S:\r\nif (sock) {\r\ndev_warn(DEV, "initial packet S crossed\n");\r\nsock_release(sock);\r\n}\r\nsock = s;\r\nbreak;\r\ncase P_HAND_SHAKE_M:\r\nif (msock) {\r\ndev_warn(DEV, "initial packet M crossed\n");\r\nsock_release(msock);\r\n}\r\nmsock = s;\r\nset_bit(DISCARD_CONCURRENT, &mdev->flags);\r\nbreak;\r\ndefault:\r\ndev_warn(DEV, "Error receiving initial packet\n");\r\nsock_release(s);\r\nif (random32() & 1)\r\ngoto retry;\r\n}\r\n}\r\nif (mdev->state.conn <= C_DISCONNECTING)\r\ngoto out_release_sockets;\r\nif (signal_pending(current)) {\r\nflush_signals(current);\r\nsmp_rmb();\r\nif (get_t_state(&mdev->receiver) == Exiting)\r\ngoto out_release_sockets;\r\n}\r\nif (sock && msock) {\r\nok = drbd_socket_okay(mdev, &sock);\r\nok = drbd_socket_okay(mdev, &msock) && ok;\r\nif (ok)\r\nbreak;\r\n}\r\n} while (1);\r\nmsock->sk->sk_reuse = 1;\r\nsock->sk->sk_reuse = 1;\r\nsock->sk->sk_allocation = GFP_NOIO;\r\nmsock->sk->sk_allocation = GFP_NOIO;\r\nsock->sk->sk_priority = TC_PRIO_INTERACTIVE_BULK;\r\nmsock->sk->sk_priority = TC_PRIO_INTERACTIVE;\r\nsock->sk->sk_sndtimeo =\r\nsock->sk->sk_rcvtimeo = mdev->net_conf->ping_timeo*4*HZ/10;\r\nmsock->sk->sk_sndtimeo = mdev->net_conf->timeout*HZ/10;\r\nmsock->sk->sk_rcvtimeo = mdev->net_conf->ping_int*HZ;\r\ndrbd_tcp_nodelay(sock);\r\ndrbd_tcp_nodelay(msock);\r\nmdev->data.socket = sock;\r\nmdev->meta.socket = msock;\r\nmdev->last_received = jiffies;\r\nD_ASSERT(mdev->asender.task == NULL);\r\nh = drbd_do_handshake(mdev);\r\nif (h <= 0)\r\nreturn h;\r\nif (mdev->cram_hmac_tfm) {\r\nswitch (drbd_do_auth(mdev)) {\r\ncase -1:\r\ndev_err(DEV, "Authentication of peer failed\n");\r\nreturn -1;\r\ncase 0:\r\ndev_err(DEV, "Authentication of peer failed, trying again.\n");\r\nreturn 0;\r\n}\r\n}\r\nif (drbd_request_state(mdev, NS(conn, C_WF_REPORT_PARAMS)) < SS_SUCCESS)\r\nreturn 0;\r\nsock->sk->sk_sndtimeo = mdev->net_conf->timeout*HZ/10;\r\nsock->sk->sk_rcvtimeo = MAX_SCHEDULE_TIMEOUT;\r\natomic_set(&mdev->packet_seq, 0);\r\nmdev->peer_seq = 0;\r\ndrbd_thread_start(&mdev->asender);\r\nif (drbd_send_protocol(mdev) == -1)\r\nreturn -1;\r\ndrbd_send_sync_param(mdev, &mdev->sync_conf);\r\ndrbd_send_sizes(mdev, 0, 0);\r\ndrbd_send_uuids(mdev);\r\ndrbd_send_state(mdev);\r\nclear_bit(USE_DEGR_WFC_T, &mdev->flags);\r\nclear_bit(RESIZE_PENDING, &mdev->flags);\r\nmod_timer(&mdev->request_timer, jiffies + HZ);\r\nreturn 1;\r\nout_release_sockets:\r\nif (sock)\r\nsock_release(sock);\r\nif (msock)\r\nsock_release(msock);\r\nreturn -1;\r\n}\r\nstatic int drbd_recv_header(struct drbd_conf *mdev, enum drbd_packets *cmd, unsigned int *packet_size)\r\n{\r\nunion p_header *h = &mdev->data.rbuf.header;\r\nint r;\r\nr = drbd_recv(mdev, h, sizeof(*h));\r\nif (unlikely(r != sizeof(*h))) {\r\nif (!signal_pending(current))\r\ndev_warn(DEV, "short read expecting header on sock: r=%d\n", r);\r\nreturn false;\r\n}\r\nif (likely(h->h80.magic == BE_DRBD_MAGIC)) {\r\n*cmd = be16_to_cpu(h->h80.command);\r\n*packet_size = be16_to_cpu(h->h80.length);\r\n} else if (h->h95.magic == BE_DRBD_MAGIC_BIG) {\r\n*cmd = be16_to_cpu(h->h95.command);\r\n*packet_size = be32_to_cpu(h->h95.length);\r\n} else {\r\ndev_err(DEV, "magic?? on data m: 0x%08x c: %d l: %d\n",\r\nbe32_to_cpu(h->h80.magic),\r\nbe16_to_cpu(h->h80.command),\r\nbe16_to_cpu(h->h80.length));\r\nreturn false;\r\n}\r\nmdev->last_received = jiffies;\r\nreturn true;\r\n}\r\nstatic void drbd_flush(struct drbd_conf *mdev)\r\n{\r\nint rv;\r\nif (mdev->write_ordering >= WO_bdev_flush && get_ldev(mdev)) {\r\nrv = blkdev_issue_flush(mdev->ldev->backing_bdev, GFP_KERNEL,\r\nNULL);\r\nif (rv) {\r\ndev_err(DEV, "local disk flush failed with status %d\n", rv);\r\ndrbd_bump_write_ordering(mdev, WO_drain_io);\r\n}\r\nput_ldev(mdev);\r\n}\r\n}\r\nstatic enum finish_epoch drbd_may_finish_epoch(struct drbd_conf *mdev,\r\nstruct drbd_epoch *epoch,\r\nenum epoch_event ev)\r\n{\r\nint epoch_size;\r\nstruct drbd_epoch *next_epoch;\r\nenum finish_epoch rv = FE_STILL_LIVE;\r\nspin_lock(&mdev->epoch_lock);\r\ndo {\r\nnext_epoch = NULL;\r\nepoch_size = atomic_read(&epoch->epoch_size);\r\nswitch (ev & ~EV_CLEANUP) {\r\ncase EV_PUT:\r\natomic_dec(&epoch->active);\r\nbreak;\r\ncase EV_GOT_BARRIER_NR:\r\nset_bit(DE_HAVE_BARRIER_NUMBER, &epoch->flags);\r\nbreak;\r\ncase EV_BECAME_LAST:\r\nbreak;\r\n}\r\nif (epoch_size != 0 &&\r\natomic_read(&epoch->active) == 0 &&\r\ntest_bit(DE_HAVE_BARRIER_NUMBER, &epoch->flags)) {\r\nif (!(ev & EV_CLEANUP)) {\r\nspin_unlock(&mdev->epoch_lock);\r\ndrbd_send_b_ack(mdev, epoch->barrier_nr, epoch_size);\r\nspin_lock(&mdev->epoch_lock);\r\n}\r\ndec_unacked(mdev);\r\nif (mdev->current_epoch != epoch) {\r\nnext_epoch = list_entry(epoch->list.next, struct drbd_epoch, list);\r\nlist_del(&epoch->list);\r\nev = EV_BECAME_LAST | (ev & EV_CLEANUP);\r\nmdev->epochs--;\r\nkfree(epoch);\r\nif (rv == FE_STILL_LIVE)\r\nrv = FE_DESTROYED;\r\n} else {\r\nepoch->flags = 0;\r\natomic_set(&epoch->epoch_size, 0);\r\nif (rv == FE_STILL_LIVE)\r\nrv = FE_RECYCLED;\r\nwake_up(&mdev->ee_wait);\r\n}\r\n}\r\nif (!next_epoch)\r\nbreak;\r\nepoch = next_epoch;\r\n} while (1);\r\nspin_unlock(&mdev->epoch_lock);\r\nreturn rv;\r\n}\r\nvoid drbd_bump_write_ordering(struct drbd_conf *mdev, enum write_ordering_e wo) __must_hold(local)\r\n{\r\nenum write_ordering_e pwo;\r\nstatic char *write_ordering_str[] = {\r\n[WO_none] = "none",\r\n[WO_drain_io] = "drain",\r\n[WO_bdev_flush] = "flush",\r\n};\r\npwo = mdev->write_ordering;\r\nwo = min(pwo, wo);\r\nif (wo == WO_bdev_flush && mdev->ldev->dc.no_disk_flush)\r\nwo = WO_drain_io;\r\nif (wo == WO_drain_io && mdev->ldev->dc.no_disk_drain)\r\nwo = WO_none;\r\nmdev->write_ordering = wo;\r\nif (pwo != mdev->write_ordering || wo == WO_bdev_flush)\r\ndev_info(DEV, "Method to ensure write ordering: %s\n", write_ordering_str[mdev->write_ordering]);\r\n}\r\nint drbd_submit_ee(struct drbd_conf *mdev, struct drbd_epoch_entry *e,\r\nconst unsigned rw, const int fault_type)\r\n{\r\nstruct bio *bios = NULL;\r\nstruct bio *bio;\r\nstruct page *page = e->pages;\r\nsector_t sector = e->sector;\r\nunsigned ds = e->size;\r\nunsigned n_bios = 0;\r\nunsigned nr_pages = (ds + PAGE_SIZE -1) >> PAGE_SHIFT;\r\nint err = -ENOMEM;\r\nnext_bio:\r\nbio = bio_alloc(GFP_NOIO, nr_pages);\r\nif (!bio) {\r\ndev_err(DEV, "submit_ee: Allocation of a bio failed\n");\r\ngoto fail;\r\n}\r\nbio->bi_sector = sector;\r\nbio->bi_bdev = mdev->ldev->backing_bdev;\r\nbio->bi_rw = rw;\r\nbio->bi_private = e;\r\nbio->bi_end_io = drbd_endio_sec;\r\nbio->bi_next = bios;\r\nbios = bio;\r\n++n_bios;\r\npage_chain_for_each(page) {\r\nunsigned len = min_t(unsigned, ds, PAGE_SIZE);\r\nif (!bio_add_page(bio, page, len, 0)) {\r\nif (bio->bi_vcnt == 0) {\r\ndev_err(DEV,\r\n"bio_add_page failed for len=%u, "\r\n"bi_vcnt=0 (bi_sector=%llu)\n",\r\nlen, (unsigned long long)bio->bi_sector);\r\nerr = -ENOSPC;\r\ngoto fail;\r\n}\r\ngoto next_bio;\r\n}\r\nds -= len;\r\nsector += len >> 9;\r\n--nr_pages;\r\n}\r\nD_ASSERT(page == NULL);\r\nD_ASSERT(ds == 0);\r\natomic_set(&e->pending_bios, n_bios);\r\ndo {\r\nbio = bios;\r\nbios = bios->bi_next;\r\nbio->bi_next = NULL;\r\ndrbd_generic_make_request(mdev, fault_type, bio);\r\n} while (bios);\r\nreturn 0;\r\nfail:\r\nwhile (bios) {\r\nbio = bios;\r\nbios = bios->bi_next;\r\nbio_put(bio);\r\n}\r\nreturn err;\r\n}\r\nstatic int receive_Barrier(struct drbd_conf *mdev, enum drbd_packets cmd, unsigned int data_size)\r\n{\r\nint rv;\r\nstruct p_barrier *p = &mdev->data.rbuf.barrier;\r\nstruct drbd_epoch *epoch;\r\ninc_unacked(mdev);\r\nmdev->current_epoch->barrier_nr = p->barrier;\r\nrv = drbd_may_finish_epoch(mdev, mdev->current_epoch, EV_GOT_BARRIER_NR);\r\nswitch (mdev->write_ordering) {\r\ncase WO_none:\r\nif (rv == FE_RECYCLED)\r\nreturn true;\r\nepoch = kmalloc(sizeof(struct drbd_epoch), GFP_NOIO);\r\nif (epoch)\r\nbreak;\r\nelse\r\ndev_warn(DEV, "Allocation of an epoch failed, slowing down\n");\r\ncase WO_bdev_flush:\r\ncase WO_drain_io:\r\ndrbd_wait_ee_list_empty(mdev, &mdev->active_ee);\r\ndrbd_flush(mdev);\r\nif (atomic_read(&mdev->current_epoch->epoch_size)) {\r\nepoch = kmalloc(sizeof(struct drbd_epoch), GFP_NOIO);\r\nif (epoch)\r\nbreak;\r\n}\r\nepoch = mdev->current_epoch;\r\nwait_event(mdev->ee_wait, atomic_read(&epoch->epoch_size) == 0);\r\nD_ASSERT(atomic_read(&epoch->active) == 0);\r\nD_ASSERT(epoch->flags == 0);\r\nreturn true;\r\ndefault:\r\ndev_err(DEV, "Strangeness in mdev->write_ordering %d\n", mdev->write_ordering);\r\nreturn false;\r\n}\r\nepoch->flags = 0;\r\natomic_set(&epoch->epoch_size, 0);\r\natomic_set(&epoch->active, 0);\r\nspin_lock(&mdev->epoch_lock);\r\nif (atomic_read(&mdev->current_epoch->epoch_size)) {\r\nlist_add(&epoch->list, &mdev->current_epoch->list);\r\nmdev->current_epoch = epoch;\r\nmdev->epochs++;\r\n} else {\r\nkfree(epoch);\r\n}\r\nspin_unlock(&mdev->epoch_lock);\r\nreturn true;\r\n}\r\nstatic struct drbd_epoch_entry *\r\nread_in_block(struct drbd_conf *mdev, u64 id, sector_t sector, int data_size) __must_hold(local)\r\n{\r\nconst sector_t capacity = drbd_get_capacity(mdev->this_bdev);\r\nstruct drbd_epoch_entry *e;\r\nstruct page *page;\r\nint dgs, ds, rr;\r\nvoid *dig_in = mdev->int_dig_in;\r\nvoid *dig_vv = mdev->int_dig_vv;\r\nunsigned long *data;\r\ndgs = (mdev->agreed_pro_version >= 87 && mdev->integrity_r_tfm) ?\r\ncrypto_hash_digestsize(mdev->integrity_r_tfm) : 0;\r\nif (dgs) {\r\nrr = drbd_recv(mdev, dig_in, dgs);\r\nif (rr != dgs) {\r\nif (!signal_pending(current))\r\ndev_warn(DEV,\r\n"short read receiving data digest: read %d expected %d\n",\r\nrr, dgs);\r\nreturn NULL;\r\n}\r\n}\r\ndata_size -= dgs;\r\nERR_IF(data_size == 0) return NULL;\r\nERR_IF(data_size & 0x1ff) return NULL;\r\nERR_IF(data_size > DRBD_MAX_BIO_SIZE) return NULL;\r\nif (sector + (data_size>>9) > capacity) {\r\ndev_err(DEV, "request from peer beyond end of local disk: "\r\n"capacity: %llus < sector: %llus + size: %u\n",\r\n(unsigned long long)capacity,\r\n(unsigned long long)sector, data_size);\r\nreturn NULL;\r\n}\r\ne = drbd_alloc_ee(mdev, id, sector, data_size, GFP_NOIO);\r\nif (!e)\r\nreturn NULL;\r\nds = data_size;\r\npage = e->pages;\r\npage_chain_for_each(page) {\r\nunsigned len = min_t(int, ds, PAGE_SIZE);\r\ndata = kmap(page);\r\nrr = drbd_recv(mdev, data, len);\r\nif (drbd_insert_fault(mdev, DRBD_FAULT_RECEIVE)) {\r\ndev_err(DEV, "Fault injection: Corrupting data on receive\n");\r\ndata[0] = data[0] ^ (unsigned long)-1;\r\n}\r\nkunmap(page);\r\nif (rr != len) {\r\ndrbd_free_ee(mdev, e);\r\nif (!signal_pending(current))\r\ndev_warn(DEV, "short read receiving data: read %d expected %d\n",\r\nrr, len);\r\nreturn NULL;\r\n}\r\nds -= rr;\r\n}\r\nif (dgs) {\r\ndrbd_csum_ee(mdev, mdev->integrity_r_tfm, e, dig_vv);\r\nif (memcmp(dig_in, dig_vv, dgs)) {\r\ndev_err(DEV, "Digest integrity check FAILED: %llus +%u\n",\r\n(unsigned long long)sector, data_size);\r\ndrbd_bcast_ee(mdev, "digest failed",\r\ndgs, dig_in, dig_vv, e);\r\ndrbd_free_ee(mdev, e);\r\nreturn NULL;\r\n}\r\n}\r\nmdev->recv_cnt += data_size>>9;\r\nreturn e;\r\n}\r\nstatic int drbd_drain_block(struct drbd_conf *mdev, int data_size)\r\n{\r\nstruct page *page;\r\nint rr, rv = 1;\r\nvoid *data;\r\nif (!data_size)\r\nreturn true;\r\npage = drbd_pp_alloc(mdev, 1, 1);\r\ndata = kmap(page);\r\nwhile (data_size) {\r\nrr = drbd_recv(mdev, data, min_t(int, data_size, PAGE_SIZE));\r\nif (rr != min_t(int, data_size, PAGE_SIZE)) {\r\nrv = 0;\r\nif (!signal_pending(current))\r\ndev_warn(DEV,\r\n"short read receiving data: read %d expected %d\n",\r\nrr, min_t(int, data_size, PAGE_SIZE));\r\nbreak;\r\n}\r\ndata_size -= rr;\r\n}\r\nkunmap(page);\r\ndrbd_pp_free(mdev, page, 0);\r\nreturn rv;\r\n}\r\nstatic int recv_dless_read(struct drbd_conf *mdev, struct drbd_request *req,\r\nsector_t sector, int data_size)\r\n{\r\nstruct bio_vec *bvec;\r\nstruct bio *bio;\r\nint dgs, rr, i, expect;\r\nvoid *dig_in = mdev->int_dig_in;\r\nvoid *dig_vv = mdev->int_dig_vv;\r\ndgs = (mdev->agreed_pro_version >= 87 && mdev->integrity_r_tfm) ?\r\ncrypto_hash_digestsize(mdev->integrity_r_tfm) : 0;\r\nif (dgs) {\r\nrr = drbd_recv(mdev, dig_in, dgs);\r\nif (rr != dgs) {\r\nif (!signal_pending(current))\r\ndev_warn(DEV,\r\n"short read receiving data reply digest: read %d expected %d\n",\r\nrr, dgs);\r\nreturn 0;\r\n}\r\n}\r\ndata_size -= dgs;\r\nmdev->recv_cnt += data_size>>9;\r\nbio = req->master_bio;\r\nD_ASSERT(sector == bio->bi_sector);\r\nbio_for_each_segment(bvec, bio, i) {\r\nexpect = min_t(int, data_size, bvec->bv_len);\r\nrr = drbd_recv(mdev,\r\nkmap(bvec->bv_page)+bvec->bv_offset,\r\nexpect);\r\nkunmap(bvec->bv_page);\r\nif (rr != expect) {\r\nif (!signal_pending(current))\r\ndev_warn(DEV, "short read receiving data reply: "\r\n"read %d expected %d\n",\r\nrr, expect);\r\nreturn 0;\r\n}\r\ndata_size -= rr;\r\n}\r\nif (dgs) {\r\ndrbd_csum_bio(mdev, mdev->integrity_r_tfm, bio, dig_vv);\r\nif (memcmp(dig_in, dig_vv, dgs)) {\r\ndev_err(DEV, "Digest integrity check FAILED. Broken NICs?\n");\r\nreturn 0;\r\n}\r\n}\r\nD_ASSERT(data_size == 0);\r\nreturn 1;\r\n}\r\nstatic int e_end_resync_block(struct drbd_conf *mdev, struct drbd_work *w, int unused)\r\n{\r\nstruct drbd_epoch_entry *e = (struct drbd_epoch_entry *)w;\r\nsector_t sector = e->sector;\r\nint ok;\r\nD_ASSERT(hlist_unhashed(&e->collision));\r\nif (likely((e->flags & EE_WAS_ERROR) == 0)) {\r\ndrbd_set_in_sync(mdev, sector, e->size);\r\nok = drbd_send_ack(mdev, P_RS_WRITE_ACK, e);\r\n} else {\r\ndrbd_rs_failed_io(mdev, sector, e->size);\r\nok = drbd_send_ack(mdev, P_NEG_ACK, e);\r\n}\r\ndec_unacked(mdev);\r\nreturn ok;\r\n}\r\nstatic int recv_resync_read(struct drbd_conf *mdev, sector_t sector, int data_size) __releases(local)\r\n{\r\nstruct drbd_epoch_entry *e;\r\ne = read_in_block(mdev, ID_SYNCER, sector, data_size);\r\nif (!e)\r\ngoto fail;\r\ndec_rs_pending(mdev);\r\ninc_unacked(mdev);\r\ne->w.cb = e_end_resync_block;\r\nspin_lock_irq(&mdev->req_lock);\r\nlist_add(&e->w.list, &mdev->sync_ee);\r\nspin_unlock_irq(&mdev->req_lock);\r\natomic_add(data_size >> 9, &mdev->rs_sect_ev);\r\nif (drbd_submit_ee(mdev, e, WRITE, DRBD_FAULT_RS_WR) == 0)\r\nreturn true;\r\ndev_err(DEV, "submit failed, triggering re-connect\n");\r\nspin_lock_irq(&mdev->req_lock);\r\nlist_del(&e->w.list);\r\nspin_unlock_irq(&mdev->req_lock);\r\ndrbd_free_ee(mdev, e);\r\nfail:\r\nput_ldev(mdev);\r\nreturn false;\r\n}\r\nstatic int receive_DataReply(struct drbd_conf *mdev, enum drbd_packets cmd, unsigned int data_size)\r\n{\r\nstruct drbd_request *req;\r\nsector_t sector;\r\nint ok;\r\nstruct p_data *p = &mdev->data.rbuf.data;\r\nsector = be64_to_cpu(p->sector);\r\nspin_lock_irq(&mdev->req_lock);\r\nreq = _ar_id_to_req(mdev, p->block_id, sector);\r\nspin_unlock_irq(&mdev->req_lock);\r\nif (unlikely(!req)) {\r\ndev_err(DEV, "Got a corrupt block_id/sector pair(1).\n");\r\nreturn false;\r\n}\r\nok = recv_dless_read(mdev, req, sector, data_size);\r\nif (ok)\r\nreq_mod(req, data_received);\r\nreturn ok;\r\n}\r\nstatic int receive_RSDataReply(struct drbd_conf *mdev, enum drbd_packets cmd, unsigned int data_size)\r\n{\r\nsector_t sector;\r\nint ok;\r\nstruct p_data *p = &mdev->data.rbuf.data;\r\nsector = be64_to_cpu(p->sector);\r\nD_ASSERT(p->block_id == ID_SYNCER);\r\nif (get_ldev(mdev)) {\r\nok = recv_resync_read(mdev, sector, data_size);\r\n} else {\r\nif (__ratelimit(&drbd_ratelimit_state))\r\ndev_err(DEV, "Can not write resync data to local disk.\n");\r\nok = drbd_drain_block(mdev, data_size);\r\ndrbd_send_ack_dp(mdev, P_NEG_ACK, p, data_size);\r\n}\r\natomic_add(data_size >> 9, &mdev->rs_sect_in);\r\nreturn ok;\r\n}\r\nstatic int e_end_block(struct drbd_conf *mdev, struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_epoch_entry *e = (struct drbd_epoch_entry *)w;\r\nsector_t sector = e->sector;\r\nint ok = 1, pcmd;\r\nif (mdev->net_conf->wire_protocol == DRBD_PROT_C) {\r\nif (likely((e->flags & EE_WAS_ERROR) == 0)) {\r\npcmd = (mdev->state.conn >= C_SYNC_SOURCE &&\r\nmdev->state.conn <= C_PAUSED_SYNC_T &&\r\ne->flags & EE_MAY_SET_IN_SYNC) ?\r\nP_RS_WRITE_ACK : P_WRITE_ACK;\r\nok &= drbd_send_ack(mdev, pcmd, e);\r\nif (pcmd == P_RS_WRITE_ACK)\r\ndrbd_set_in_sync(mdev, sector, e->size);\r\n} else {\r\nok = drbd_send_ack(mdev, P_NEG_ACK, e);\r\n}\r\ndec_unacked(mdev);\r\n}\r\nif (mdev->net_conf->two_primaries) {\r\nspin_lock_irq(&mdev->req_lock);\r\nD_ASSERT(!hlist_unhashed(&e->collision));\r\nhlist_del_init(&e->collision);\r\nspin_unlock_irq(&mdev->req_lock);\r\n} else {\r\nD_ASSERT(hlist_unhashed(&e->collision));\r\n}\r\ndrbd_may_finish_epoch(mdev, e->epoch, EV_PUT + (cancel ? EV_CLEANUP : 0));\r\nreturn ok;\r\n}\r\nstatic int e_send_discard_ack(struct drbd_conf *mdev, struct drbd_work *w, int unused)\r\n{\r\nstruct drbd_epoch_entry *e = (struct drbd_epoch_entry *)w;\r\nint ok = 1;\r\nD_ASSERT(mdev->net_conf->wire_protocol == DRBD_PROT_C);\r\nok = drbd_send_ack(mdev, P_DISCARD_ACK, e);\r\nspin_lock_irq(&mdev->req_lock);\r\nD_ASSERT(!hlist_unhashed(&e->collision));\r\nhlist_del_init(&e->collision);\r\nspin_unlock_irq(&mdev->req_lock);\r\ndec_unacked(mdev);\r\nreturn ok;\r\n}\r\nstatic int drbd_wait_peer_seq(struct drbd_conf *mdev, const u32 packet_seq)\r\n{\r\nDEFINE_WAIT(wait);\r\nunsigned int p_seq;\r\nlong timeout;\r\nint ret = 0;\r\nspin_lock(&mdev->peer_seq_lock);\r\nfor (;;) {\r\nprepare_to_wait(&mdev->seq_wait, &wait, TASK_INTERRUPTIBLE);\r\nif (seq_le(packet_seq, mdev->peer_seq+1))\r\nbreak;\r\nif (signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\np_seq = mdev->peer_seq;\r\nspin_unlock(&mdev->peer_seq_lock);\r\ntimeout = schedule_timeout(30*HZ);\r\nspin_lock(&mdev->peer_seq_lock);\r\nif (timeout == 0 && p_seq == mdev->peer_seq) {\r\nret = -ETIMEDOUT;\r\ndev_err(DEV, "ASSERT FAILED waited 30 seconds for sequence update, forcing reconnect\n");\r\nbreak;\r\n}\r\n}\r\nfinish_wait(&mdev->seq_wait, &wait);\r\nif (mdev->peer_seq+1 == packet_seq)\r\nmdev->peer_seq++;\r\nspin_unlock(&mdev->peer_seq_lock);\r\nreturn ret;\r\n}\r\nstatic unsigned long wire_flags_to_bio(struct drbd_conf *mdev, u32 dpf)\r\n{\r\nreturn (dpf & DP_RW_SYNC ? REQ_SYNC : 0) |\r\n(dpf & DP_FUA ? REQ_FUA : 0) |\r\n(dpf & DP_FLUSH ? REQ_FLUSH : 0) |\r\n(dpf & DP_DISCARD ? REQ_DISCARD : 0);\r\n}\r\nstatic int receive_Data(struct drbd_conf *mdev, enum drbd_packets cmd, unsigned int data_size)\r\n{\r\nsector_t sector;\r\nstruct drbd_epoch_entry *e;\r\nstruct p_data *p = &mdev->data.rbuf.data;\r\nint rw = WRITE;\r\nu32 dp_flags;\r\nif (!get_ldev(mdev)) {\r\nspin_lock(&mdev->peer_seq_lock);\r\nif (mdev->peer_seq+1 == be32_to_cpu(p->seq_num))\r\nmdev->peer_seq++;\r\nspin_unlock(&mdev->peer_seq_lock);\r\ndrbd_send_ack_dp(mdev, P_NEG_ACK, p, data_size);\r\natomic_inc(&mdev->current_epoch->epoch_size);\r\nreturn drbd_drain_block(mdev, data_size);\r\n}\r\nsector = be64_to_cpu(p->sector);\r\ne = read_in_block(mdev, p->block_id, sector, data_size);\r\nif (!e) {\r\nput_ldev(mdev);\r\nreturn false;\r\n}\r\ne->w.cb = e_end_block;\r\ndp_flags = be32_to_cpu(p->dp_flags);\r\nrw |= wire_flags_to_bio(mdev, dp_flags);\r\nif (dp_flags & DP_MAY_SET_IN_SYNC)\r\ne->flags |= EE_MAY_SET_IN_SYNC;\r\nspin_lock(&mdev->epoch_lock);\r\ne->epoch = mdev->current_epoch;\r\natomic_inc(&e->epoch->epoch_size);\r\natomic_inc(&e->epoch->active);\r\nspin_unlock(&mdev->epoch_lock);\r\nif (!mdev->net_conf->two_primaries) {\r\nspin_lock_irq(&mdev->req_lock);\r\n} else {\r\nconst int size = e->size;\r\nconst int discard = test_bit(DISCARD_CONCURRENT, &mdev->flags);\r\nDEFINE_WAIT(wait);\r\nstruct drbd_request *i;\r\nstruct hlist_node *n;\r\nstruct hlist_head *slot;\r\nint first;\r\nD_ASSERT(mdev->net_conf->wire_protocol == DRBD_PROT_C);\r\nBUG_ON(mdev->ee_hash == NULL);\r\nBUG_ON(mdev->tl_hash == NULL);\r\nif (drbd_wait_peer_seq(mdev, be32_to_cpu(p->seq_num)))\r\ngoto out_interrupted;\r\nspin_lock_irq(&mdev->req_lock);\r\nhlist_add_head(&e->collision, ee_hash_slot(mdev, sector));\r\n#define OVERLAPS overlaps(i->sector, i->size, sector, size)\r\nslot = tl_hash_slot(mdev, sector);\r\nfirst = 1;\r\nfor (;;) {\r\nint have_unacked = 0;\r\nint have_conflict = 0;\r\nprepare_to_wait(&mdev->misc_wait, &wait,\r\nTASK_INTERRUPTIBLE);\r\nhlist_for_each_entry(i, n, slot, collision) {\r\nif (OVERLAPS) {\r\nif (first)\r\ndev_alert(DEV, "%s[%u] Concurrent local write detected!"\r\n" new: %llus +%u; pending: %llus +%u\n",\r\ncurrent->comm, current->pid,\r\n(unsigned long long)sector, size,\r\n(unsigned long long)i->sector, i->size);\r\nif (i->rq_state & RQ_NET_PENDING)\r\n++have_unacked;\r\n++have_conflict;\r\n}\r\n}\r\n#undef OVERLAPS\r\nif (!have_conflict)\r\nbreak;\r\nif (first && discard && have_unacked) {\r\ndev_alert(DEV, "Concurrent write! [DISCARD BY FLAG] sec=%llus\n",\r\n(unsigned long long)sector);\r\ninc_unacked(mdev);\r\ne->w.cb = e_send_discard_ack;\r\nlist_add_tail(&e->w.list, &mdev->done_ee);\r\nspin_unlock_irq(&mdev->req_lock);\r\nput_ldev(mdev);\r\nwake_asender(mdev);\r\nfinish_wait(&mdev->misc_wait, &wait);\r\nreturn true;\r\n}\r\nif (signal_pending(current)) {\r\nhlist_del_init(&e->collision);\r\nspin_unlock_irq(&mdev->req_lock);\r\nfinish_wait(&mdev->misc_wait, &wait);\r\ngoto out_interrupted;\r\n}\r\nspin_unlock_irq(&mdev->req_lock);\r\nif (first) {\r\nfirst = 0;\r\ndev_alert(DEV, "Concurrent write! [W AFTERWARDS] "\r\n"sec=%llus\n", (unsigned long long)sector);\r\n} else if (discard) {\r\nD_ASSERT(have_unacked == 0);\r\n}\r\nschedule();\r\nspin_lock_irq(&mdev->req_lock);\r\n}\r\nfinish_wait(&mdev->misc_wait, &wait);\r\n}\r\nlist_add(&e->w.list, &mdev->active_ee);\r\nspin_unlock_irq(&mdev->req_lock);\r\nswitch (mdev->net_conf->wire_protocol) {\r\ncase DRBD_PROT_C:\r\ninc_unacked(mdev);\r\nbreak;\r\ncase DRBD_PROT_B:\r\ndrbd_send_ack(mdev, P_RECV_ACK, e);\r\nbreak;\r\ncase DRBD_PROT_A:\r\nbreak;\r\n}\r\nif (mdev->state.pdsk < D_INCONSISTENT) {\r\ndrbd_set_out_of_sync(mdev, e->sector, e->size);\r\ne->flags |= EE_CALL_AL_COMPLETE_IO;\r\ne->flags &= ~EE_MAY_SET_IN_SYNC;\r\ndrbd_al_begin_io(mdev, e->sector);\r\n}\r\nif (drbd_submit_ee(mdev, e, rw, DRBD_FAULT_DT_WR) == 0)\r\nreturn true;\r\ndev_err(DEV, "submit failed, triggering re-connect\n");\r\nspin_lock_irq(&mdev->req_lock);\r\nlist_del(&e->w.list);\r\nhlist_del_init(&e->collision);\r\nspin_unlock_irq(&mdev->req_lock);\r\nif (e->flags & EE_CALL_AL_COMPLETE_IO)\r\ndrbd_al_complete_io(mdev, e->sector);\r\nout_interrupted:\r\ndrbd_may_finish_epoch(mdev, e->epoch, EV_PUT + EV_CLEANUP);\r\nput_ldev(mdev);\r\ndrbd_free_ee(mdev, e);\r\nreturn false;\r\n}\r\nint drbd_rs_should_slow_down(struct drbd_conf *mdev, sector_t sector)\r\n{\r\nstruct gendisk *disk = mdev->ldev->backing_bdev->bd_contains->bd_disk;\r\nunsigned long db, dt, dbdt;\r\nstruct lc_element *tmp;\r\nint curr_events;\r\nint throttle = 0;\r\nif (mdev->sync_conf.c_min_rate == 0)\r\nreturn 0;\r\nspin_lock_irq(&mdev->al_lock);\r\ntmp = lc_find(mdev->resync, BM_SECT_TO_EXT(sector));\r\nif (tmp) {\r\nstruct bm_extent *bm_ext = lc_entry(tmp, struct bm_extent, lce);\r\nif (test_bit(BME_PRIORITY, &bm_ext->flags)) {\r\nspin_unlock_irq(&mdev->al_lock);\r\nreturn 0;\r\n}\r\n}\r\nspin_unlock_irq(&mdev->al_lock);\r\ncurr_events = (int)part_stat_read(&disk->part0, sectors[0]) +\r\n(int)part_stat_read(&disk->part0, sectors[1]) -\r\natomic_read(&mdev->rs_sect_ev);\r\nif (!mdev->rs_last_events || curr_events - mdev->rs_last_events > 64) {\r\nunsigned long rs_left;\r\nint i;\r\nmdev->rs_last_events = curr_events;\r\ni = (mdev->rs_last_mark + DRBD_SYNC_MARKS-1) % DRBD_SYNC_MARKS;\r\nif (mdev->state.conn == C_VERIFY_S || mdev->state.conn == C_VERIFY_T)\r\nrs_left = mdev->ov_left;\r\nelse\r\nrs_left = drbd_bm_total_weight(mdev) - mdev->rs_failed;\r\ndt = ((long)jiffies - (long)mdev->rs_mark_time[i]) / HZ;\r\nif (!dt)\r\ndt++;\r\ndb = mdev->rs_mark_left[i] - rs_left;\r\ndbdt = Bit2KB(db/dt);\r\nif (dbdt > mdev->sync_conf.c_min_rate)\r\nthrottle = 1;\r\n}\r\nreturn throttle;\r\n}\r\nstatic int receive_DataRequest(struct drbd_conf *mdev, enum drbd_packets cmd, unsigned int digest_size)\r\n{\r\nsector_t sector;\r\nconst sector_t capacity = drbd_get_capacity(mdev->this_bdev);\r\nstruct drbd_epoch_entry *e;\r\nstruct digest_info *di = NULL;\r\nint size, verb;\r\nunsigned int fault_type;\r\nstruct p_block_req *p = &mdev->data.rbuf.block_req;\r\nsector = be64_to_cpu(p->sector);\r\nsize = be32_to_cpu(p->blksize);\r\nif (size <= 0 || (size & 0x1ff) != 0 || size > DRBD_MAX_BIO_SIZE) {\r\ndev_err(DEV, "%s:%d: sector: %llus, size: %u\n", __FILE__, __LINE__,\r\n(unsigned long long)sector, size);\r\nreturn false;\r\n}\r\nif (sector + (size>>9) > capacity) {\r\ndev_err(DEV, "%s:%d: sector: %llus, size: %u\n", __FILE__, __LINE__,\r\n(unsigned long long)sector, size);\r\nreturn false;\r\n}\r\nif (!get_ldev_if_state(mdev, D_UP_TO_DATE)) {\r\nverb = 1;\r\nswitch (cmd) {\r\ncase P_DATA_REQUEST:\r\ndrbd_send_ack_rp(mdev, P_NEG_DREPLY, p);\r\nbreak;\r\ncase P_RS_DATA_REQUEST:\r\ncase P_CSUM_RS_REQUEST:\r\ncase P_OV_REQUEST:\r\ndrbd_send_ack_rp(mdev, P_NEG_RS_DREPLY , p);\r\nbreak;\r\ncase P_OV_REPLY:\r\nverb = 0;\r\ndec_rs_pending(mdev);\r\ndrbd_send_ack_ex(mdev, P_OV_RESULT, sector, size, ID_IN_SYNC);\r\nbreak;\r\ndefault:\r\ndev_err(DEV, "unexpected command (%s) in receive_DataRequest\n",\r\ncmdname(cmd));\r\n}\r\nif (verb && __ratelimit(&drbd_ratelimit_state))\r\ndev_err(DEV, "Can not satisfy peer's read request, "\r\n"no local data.\n");\r\nreturn drbd_drain_block(mdev, digest_size);\r\n}\r\ne = drbd_alloc_ee(mdev, p->block_id, sector, size, GFP_NOIO);\r\nif (!e) {\r\nput_ldev(mdev);\r\nreturn false;\r\n}\r\nswitch (cmd) {\r\ncase P_DATA_REQUEST:\r\ne->w.cb = w_e_end_data_req;\r\nfault_type = DRBD_FAULT_DT_RD;\r\ngoto submit;\r\ncase P_RS_DATA_REQUEST:\r\ne->w.cb = w_e_end_rsdata_req;\r\nfault_type = DRBD_FAULT_RS_RD;\r\nmdev->bm_resync_fo = BM_SECT_TO_BIT(sector);\r\nbreak;\r\ncase P_OV_REPLY:\r\ncase P_CSUM_RS_REQUEST:\r\nfault_type = DRBD_FAULT_RS_RD;\r\ndi = kmalloc(sizeof(*di) + digest_size, GFP_NOIO);\r\nif (!di)\r\ngoto out_free_e;\r\ndi->digest_size = digest_size;\r\ndi->digest = (((char *)di)+sizeof(struct digest_info));\r\ne->digest = di;\r\ne->flags |= EE_HAS_DIGEST;\r\nif (drbd_recv(mdev, di->digest, digest_size) != digest_size)\r\ngoto out_free_e;\r\nif (cmd == P_CSUM_RS_REQUEST) {\r\nD_ASSERT(mdev->agreed_pro_version >= 89);\r\ne->w.cb = w_e_end_csum_rs_req;\r\nmdev->bm_resync_fo = BM_SECT_TO_BIT(sector);\r\n} else if (cmd == P_OV_REPLY) {\r\natomic_add(size >> 9, &mdev->rs_sect_in);\r\ne->w.cb = w_e_end_ov_reply;\r\ndec_rs_pending(mdev);\r\ngoto submit_for_resync;\r\n}\r\nbreak;\r\ncase P_OV_REQUEST:\r\nif (mdev->ov_start_sector == ~(sector_t)0 &&\r\nmdev->agreed_pro_version >= 90) {\r\nunsigned long now = jiffies;\r\nint i;\r\nmdev->ov_start_sector = sector;\r\nmdev->ov_position = sector;\r\nmdev->ov_left = drbd_bm_bits(mdev) - BM_SECT_TO_BIT(sector);\r\nmdev->rs_total = mdev->ov_left;\r\nfor (i = 0; i < DRBD_SYNC_MARKS; i++) {\r\nmdev->rs_mark_left[i] = mdev->ov_left;\r\nmdev->rs_mark_time[i] = now;\r\n}\r\ndev_info(DEV, "Online Verify start sector: %llu\n",\r\n(unsigned long long)sector);\r\n}\r\ne->w.cb = w_e_end_ov_req;\r\nfault_type = DRBD_FAULT_RS_RD;\r\nbreak;\r\ndefault:\r\ndev_err(DEV, "unexpected command (%s) in receive_DataRequest\n",\r\ncmdname(cmd));\r\nfault_type = DRBD_FAULT_MAX;\r\ngoto out_free_e;\r\n}\r\nif (mdev->state.peer != R_PRIMARY && drbd_rs_should_slow_down(mdev, sector))\r\nschedule_timeout_uninterruptible(HZ/10);\r\nif (drbd_rs_begin_io(mdev, sector))\r\ngoto out_free_e;\r\nsubmit_for_resync:\r\natomic_add(size >> 9, &mdev->rs_sect_ev);\r\nsubmit:\r\ninc_unacked(mdev);\r\nspin_lock_irq(&mdev->req_lock);\r\nlist_add_tail(&e->w.list, &mdev->read_ee);\r\nspin_unlock_irq(&mdev->req_lock);\r\nif (drbd_submit_ee(mdev, e, READ, fault_type) == 0)\r\nreturn true;\r\ndev_err(DEV, "submit failed, triggering re-connect\n");\r\nspin_lock_irq(&mdev->req_lock);\r\nlist_del(&e->w.list);\r\nspin_unlock_irq(&mdev->req_lock);\r\nout_free_e:\r\nput_ldev(mdev);\r\ndrbd_free_ee(mdev, e);\r\nreturn false;\r\n}\r\nstatic int drbd_asb_recover_0p(struct drbd_conf *mdev) __must_hold(local)\r\n{\r\nint self, peer, rv = -100;\r\nunsigned long ch_self, ch_peer;\r\nself = mdev->ldev->md.uuid[UI_BITMAP] & 1;\r\npeer = mdev->p_uuid[UI_BITMAP] & 1;\r\nch_peer = mdev->p_uuid[UI_SIZE];\r\nch_self = mdev->comm_bm_set;\r\nswitch (mdev->net_conf->after_sb_0p) {\r\ncase ASB_CONSENSUS:\r\ncase ASB_DISCARD_SECONDARY:\r\ncase ASB_CALL_HELPER:\r\ndev_err(DEV, "Configuration error.\n");\r\nbreak;\r\ncase ASB_DISCONNECT:\r\nbreak;\r\ncase ASB_DISCARD_YOUNGER_PRI:\r\nif (self == 0 && peer == 1) {\r\nrv = -1;\r\nbreak;\r\n}\r\nif (self == 1 && peer == 0) {\r\nrv = 1;\r\nbreak;\r\n}\r\ncase ASB_DISCARD_OLDER_PRI:\r\nif (self == 0 && peer == 1) {\r\nrv = 1;\r\nbreak;\r\n}\r\nif (self == 1 && peer == 0) {\r\nrv = -1;\r\nbreak;\r\n}\r\ndev_warn(DEV, "Discard younger/older primary did not find a decision\n"\r\n"Using discard-least-changes instead\n");\r\ncase ASB_DISCARD_ZERO_CHG:\r\nif (ch_peer == 0 && ch_self == 0) {\r\nrv = test_bit(DISCARD_CONCURRENT, &mdev->flags)\r\n? -1 : 1;\r\nbreak;\r\n} else {\r\nif (ch_peer == 0) { rv = 1; break; }\r\nif (ch_self == 0) { rv = -1; break; }\r\n}\r\nif (mdev->net_conf->after_sb_0p == ASB_DISCARD_ZERO_CHG)\r\nbreak;\r\ncase ASB_DISCARD_LEAST_CHG:\r\nif (ch_self < ch_peer)\r\nrv = -1;\r\nelse if (ch_self > ch_peer)\r\nrv = 1;\r\nelse\r\nrv = test_bit(DISCARD_CONCURRENT, &mdev->flags)\r\n? -1 : 1;\r\nbreak;\r\ncase ASB_DISCARD_LOCAL:\r\nrv = -1;\r\nbreak;\r\ncase ASB_DISCARD_REMOTE:\r\nrv = 1;\r\n}\r\nreturn rv;\r\n}\r\nstatic int drbd_asb_recover_1p(struct drbd_conf *mdev) __must_hold(local)\r\n{\r\nint hg, rv = -100;\r\nswitch (mdev->net_conf->after_sb_1p) {\r\ncase ASB_DISCARD_YOUNGER_PRI:\r\ncase ASB_DISCARD_OLDER_PRI:\r\ncase ASB_DISCARD_LEAST_CHG:\r\ncase ASB_DISCARD_LOCAL:\r\ncase ASB_DISCARD_REMOTE:\r\ndev_err(DEV, "Configuration error.\n");\r\nbreak;\r\ncase ASB_DISCONNECT:\r\nbreak;\r\ncase ASB_CONSENSUS:\r\nhg = drbd_asb_recover_0p(mdev);\r\nif (hg == -1 && mdev->state.role == R_SECONDARY)\r\nrv = hg;\r\nif (hg == 1 && mdev->state.role == R_PRIMARY)\r\nrv = hg;\r\nbreak;\r\ncase ASB_VIOLENTLY:\r\nrv = drbd_asb_recover_0p(mdev);\r\nbreak;\r\ncase ASB_DISCARD_SECONDARY:\r\nreturn mdev->state.role == R_PRIMARY ? 1 : -1;\r\ncase ASB_CALL_HELPER:\r\nhg = drbd_asb_recover_0p(mdev);\r\nif (hg == -1 && mdev->state.role == R_PRIMARY) {\r\nenum drbd_state_rv rv2;\r\ndrbd_set_role(mdev, R_SECONDARY, 0);\r\nrv2 = drbd_change_state(mdev, CS_VERBOSE, NS(role, R_SECONDARY));\r\nif (rv2 != SS_SUCCESS) {\r\ndrbd_khelper(mdev, "pri-lost-after-sb");\r\n} else {\r\ndev_warn(DEV, "Successfully gave up primary role.\n");\r\nrv = hg;\r\n}\r\n} else\r\nrv = hg;\r\n}\r\nreturn rv;\r\n}\r\nstatic int drbd_asb_recover_2p(struct drbd_conf *mdev) __must_hold(local)\r\n{\r\nint hg, rv = -100;\r\nswitch (mdev->net_conf->after_sb_2p) {\r\ncase ASB_DISCARD_YOUNGER_PRI:\r\ncase ASB_DISCARD_OLDER_PRI:\r\ncase ASB_DISCARD_LEAST_CHG:\r\ncase ASB_DISCARD_LOCAL:\r\ncase ASB_DISCARD_REMOTE:\r\ncase ASB_CONSENSUS:\r\ncase ASB_DISCARD_SECONDARY:\r\ndev_err(DEV, "Configuration error.\n");\r\nbreak;\r\ncase ASB_VIOLENTLY:\r\nrv = drbd_asb_recover_0p(mdev);\r\nbreak;\r\ncase ASB_DISCONNECT:\r\nbreak;\r\ncase ASB_CALL_HELPER:\r\nhg = drbd_asb_recover_0p(mdev);\r\nif (hg == -1) {\r\nenum drbd_state_rv rv2;\r\nrv2 = drbd_change_state(mdev, CS_VERBOSE, NS(role, R_SECONDARY));\r\nif (rv2 != SS_SUCCESS) {\r\ndrbd_khelper(mdev, "pri-lost-after-sb");\r\n} else {\r\ndev_warn(DEV, "Successfully gave up primary role.\n");\r\nrv = hg;\r\n}\r\n} else\r\nrv = hg;\r\n}\r\nreturn rv;\r\n}\r\nstatic void drbd_uuid_dump(struct drbd_conf *mdev, char *text, u64 *uuid,\r\nu64 bits, u64 flags)\r\n{\r\nif (!uuid) {\r\ndev_info(DEV, "%s uuid info vanished while I was looking!\n", text);\r\nreturn;\r\n}\r\ndev_info(DEV, "%s %016llX:%016llX:%016llX:%016llX bits:%llu flags:%llX\n",\r\ntext,\r\n(unsigned long long)uuid[UI_CURRENT],\r\n(unsigned long long)uuid[UI_BITMAP],\r\n(unsigned long long)uuid[UI_HISTORY_START],\r\n(unsigned long long)uuid[UI_HISTORY_END],\r\n(unsigned long long)bits,\r\n(unsigned long long)flags);\r\n}\r\nstatic int drbd_uuid_compare(struct drbd_conf *mdev, int *rule_nr) __must_hold(local)\r\n{\r\nu64 self, peer;\r\nint i, j;\r\nself = mdev->ldev->md.uuid[UI_CURRENT] & ~((u64)1);\r\npeer = mdev->p_uuid[UI_CURRENT] & ~((u64)1);\r\n*rule_nr = 10;\r\nif (self == UUID_JUST_CREATED && peer == UUID_JUST_CREATED)\r\nreturn 0;\r\n*rule_nr = 20;\r\nif ((self == UUID_JUST_CREATED || self == (u64)0) &&\r\npeer != UUID_JUST_CREATED)\r\nreturn -2;\r\n*rule_nr = 30;\r\nif (self != UUID_JUST_CREATED &&\r\n(peer == UUID_JUST_CREATED || peer == (u64)0))\r\nreturn 2;\r\nif (self == peer) {\r\nint rct, dc;\r\nif (mdev->p_uuid[UI_BITMAP] == (u64)0 && mdev->ldev->md.uuid[UI_BITMAP] != (u64)0) {\r\nif (mdev->agreed_pro_version < 91)\r\nreturn -1091;\r\nif ((mdev->ldev->md.uuid[UI_BITMAP] & ~((u64)1)) == (mdev->p_uuid[UI_HISTORY_START] & ~((u64)1)) &&\r\n(mdev->ldev->md.uuid[UI_HISTORY_START] & ~((u64)1)) == (mdev->p_uuid[UI_HISTORY_START + 1] & ~((u64)1))) {\r\ndev_info(DEV, "was SyncSource, missed the resync finished event, corrected myself:\n");\r\ndrbd_uuid_set_bm(mdev, 0UL);\r\ndrbd_uuid_dump(mdev, "self", mdev->ldev->md.uuid,\r\nmdev->state.disk >= D_NEGOTIATING ? drbd_bm_total_weight(mdev) : 0, 0);\r\n*rule_nr = 34;\r\n} else {\r\ndev_info(DEV, "was SyncSource (peer failed to write sync_uuid)\n");\r\n*rule_nr = 36;\r\n}\r\nreturn 1;\r\n}\r\nif (mdev->ldev->md.uuid[UI_BITMAP] == (u64)0 && mdev->p_uuid[UI_BITMAP] != (u64)0) {\r\nif (mdev->agreed_pro_version < 91)\r\nreturn -1091;\r\nif ((mdev->ldev->md.uuid[UI_HISTORY_START] & ~((u64)1)) == (mdev->p_uuid[UI_BITMAP] & ~((u64)1)) &&\r\n(mdev->ldev->md.uuid[UI_HISTORY_START + 1] & ~((u64)1)) == (mdev->p_uuid[UI_HISTORY_START] & ~((u64)1))) {\r\ndev_info(DEV, "was SyncTarget, peer missed the resync finished event, corrected peer:\n");\r\nmdev->p_uuid[UI_HISTORY_START + 1] = mdev->p_uuid[UI_HISTORY_START];\r\nmdev->p_uuid[UI_HISTORY_START] = mdev->p_uuid[UI_BITMAP];\r\nmdev->p_uuid[UI_BITMAP] = 0UL;\r\ndrbd_uuid_dump(mdev, "peer", mdev->p_uuid, mdev->p_uuid[UI_SIZE], mdev->p_uuid[UI_FLAGS]);\r\n*rule_nr = 35;\r\n} else {\r\ndev_info(DEV, "was SyncTarget (failed to write sync_uuid)\n");\r\n*rule_nr = 37;\r\n}\r\nreturn -1;\r\n}\r\nrct = (test_bit(CRASHED_PRIMARY, &mdev->flags) ? 1 : 0) +\r\n(mdev->p_uuid[UI_FLAGS] & 2);\r\n*rule_nr = 40;\r\nswitch (rct) {\r\ncase 0: return 0;\r\ncase 1: return 1;\r\ncase 2: return -1;\r\ncase 3:\r\ndc = test_bit(DISCARD_CONCURRENT, &mdev->flags);\r\nreturn dc ? -1 : 1;\r\n}\r\n}\r\n*rule_nr = 50;\r\npeer = mdev->p_uuid[UI_BITMAP] & ~((u64)1);\r\nif (self == peer)\r\nreturn -1;\r\n*rule_nr = 51;\r\npeer = mdev->p_uuid[UI_HISTORY_START] & ~((u64)1);\r\nif (self == peer) {\r\nif (mdev->agreed_pro_version < 96 ?\r\n(mdev->ldev->md.uuid[UI_HISTORY_START] & ~((u64)1)) ==\r\n(mdev->p_uuid[UI_HISTORY_START + 1] & ~((u64)1)) :\r\npeer + UUID_NEW_BM_OFFSET == (mdev->p_uuid[UI_BITMAP] & ~((u64)1))) {\r\nif (mdev->agreed_pro_version < 91)\r\nreturn -1091;\r\nmdev->p_uuid[UI_BITMAP] = mdev->p_uuid[UI_HISTORY_START];\r\nmdev->p_uuid[UI_HISTORY_START] = mdev->p_uuid[UI_HISTORY_START + 1];\r\ndev_info(DEV, "Did not got last syncUUID packet, corrected:\n");\r\ndrbd_uuid_dump(mdev, "peer", mdev->p_uuid, mdev->p_uuid[UI_SIZE], mdev->p_uuid[UI_FLAGS]);\r\nreturn -1;\r\n}\r\n}\r\n*rule_nr = 60;\r\nself = mdev->ldev->md.uuid[UI_CURRENT] & ~((u64)1);\r\nfor (i = UI_HISTORY_START; i <= UI_HISTORY_END; i++) {\r\npeer = mdev->p_uuid[i] & ~((u64)1);\r\nif (self == peer)\r\nreturn -2;\r\n}\r\n*rule_nr = 70;\r\nself = mdev->ldev->md.uuid[UI_BITMAP] & ~((u64)1);\r\npeer = mdev->p_uuid[UI_CURRENT] & ~((u64)1);\r\nif (self == peer)\r\nreturn 1;\r\n*rule_nr = 71;\r\nself = mdev->ldev->md.uuid[UI_HISTORY_START] & ~((u64)1);\r\nif (self == peer) {\r\nif (mdev->agreed_pro_version < 96 ?\r\n(mdev->ldev->md.uuid[UI_HISTORY_START + 1] & ~((u64)1)) ==\r\n(mdev->p_uuid[UI_HISTORY_START] & ~((u64)1)) :\r\nself + UUID_NEW_BM_OFFSET == (mdev->ldev->md.uuid[UI_BITMAP] & ~((u64)1))) {\r\nif (mdev->agreed_pro_version < 91)\r\nreturn -1091;\r\n_drbd_uuid_set(mdev, UI_BITMAP, mdev->ldev->md.uuid[UI_HISTORY_START]);\r\n_drbd_uuid_set(mdev, UI_HISTORY_START, mdev->ldev->md.uuid[UI_HISTORY_START + 1]);\r\ndev_info(DEV, "Last syncUUID did not get through, corrected:\n");\r\ndrbd_uuid_dump(mdev, "self", mdev->ldev->md.uuid,\r\nmdev->state.disk >= D_NEGOTIATING ? drbd_bm_total_weight(mdev) : 0, 0);\r\nreturn 1;\r\n}\r\n}\r\n*rule_nr = 80;\r\npeer = mdev->p_uuid[UI_CURRENT] & ~((u64)1);\r\nfor (i = UI_HISTORY_START; i <= UI_HISTORY_END; i++) {\r\nself = mdev->ldev->md.uuid[i] & ~((u64)1);\r\nif (self == peer)\r\nreturn 2;\r\n}\r\n*rule_nr = 90;\r\nself = mdev->ldev->md.uuid[UI_BITMAP] & ~((u64)1);\r\npeer = mdev->p_uuid[UI_BITMAP] & ~((u64)1);\r\nif (self == peer && self != ((u64)0))\r\nreturn 100;\r\n*rule_nr = 100;\r\nfor (i = UI_HISTORY_START; i <= UI_HISTORY_END; i++) {\r\nself = mdev->ldev->md.uuid[i] & ~((u64)1);\r\nfor (j = UI_HISTORY_START; j <= UI_HISTORY_END; j++) {\r\npeer = mdev->p_uuid[j] & ~((u64)1);\r\nif (self == peer)\r\nreturn -100;\r\n}\r\n}\r\nreturn -1000;\r\n}\r\nstatic enum drbd_conns drbd_sync_handshake(struct drbd_conf *mdev, enum drbd_role peer_role,\r\nenum drbd_disk_state peer_disk) __must_hold(local)\r\n{\r\nint hg, rule_nr;\r\nenum drbd_conns rv = C_MASK;\r\nenum drbd_disk_state mydisk;\r\nmydisk = mdev->state.disk;\r\nif (mydisk == D_NEGOTIATING)\r\nmydisk = mdev->new_state_tmp.disk;\r\ndev_info(DEV, "drbd_sync_handshake:\n");\r\ndrbd_uuid_dump(mdev, "self", mdev->ldev->md.uuid, mdev->comm_bm_set, 0);\r\ndrbd_uuid_dump(mdev, "peer", mdev->p_uuid,\r\nmdev->p_uuid[UI_SIZE], mdev->p_uuid[UI_FLAGS]);\r\nhg = drbd_uuid_compare(mdev, &rule_nr);\r\ndev_info(DEV, "uuid_compare()=%d by rule %d\n", hg, rule_nr);\r\nif (hg == -1000) {\r\ndev_alert(DEV, "Unrelated data, aborting!\n");\r\nreturn C_MASK;\r\n}\r\nif (hg < -1000) {\r\ndev_alert(DEV, "To resolve this both sides have to support at least protocol %d\n", -hg - 1000);\r\nreturn C_MASK;\r\n}\r\nif ((mydisk == D_INCONSISTENT && peer_disk > D_INCONSISTENT) ||\r\n(peer_disk == D_INCONSISTENT && mydisk > D_INCONSISTENT)) {\r\nint f = (hg == -100) || abs(hg) == 2;\r\nhg = mydisk > D_INCONSISTENT ? 1 : -1;\r\nif (f)\r\nhg = hg*2;\r\ndev_info(DEV, "Becoming sync %s due to disk states.\n",\r\nhg > 0 ? "source" : "target");\r\n}\r\nif (abs(hg) == 100)\r\ndrbd_khelper(mdev, "initial-split-brain");\r\nif (hg == 100 || (hg == -100 && mdev->net_conf->always_asbp)) {\r\nint pcount = (mdev->state.role == R_PRIMARY)\r\n+ (peer_role == R_PRIMARY);\r\nint forced = (hg == -100);\r\nswitch (pcount) {\r\ncase 0:\r\nhg = drbd_asb_recover_0p(mdev);\r\nbreak;\r\ncase 1:\r\nhg = drbd_asb_recover_1p(mdev);\r\nbreak;\r\ncase 2:\r\nhg = drbd_asb_recover_2p(mdev);\r\nbreak;\r\n}\r\nif (abs(hg) < 100) {\r\ndev_warn(DEV, "Split-Brain detected, %d primaries, "\r\n"automatically solved. Sync from %s node\n",\r\npcount, (hg < 0) ? "peer" : "this");\r\nif (forced) {\r\ndev_warn(DEV, "Doing a full sync, since"\r\n" UUIDs where ambiguous.\n");\r\nhg = hg*2;\r\n}\r\n}\r\n}\r\nif (hg == -100) {\r\nif (mdev->net_conf->want_lose && !(mdev->p_uuid[UI_FLAGS]&1))\r\nhg = -1;\r\nif (!mdev->net_conf->want_lose && (mdev->p_uuid[UI_FLAGS]&1))\r\nhg = 1;\r\nif (abs(hg) < 100)\r\ndev_warn(DEV, "Split-Brain detected, manually solved. "\r\n"Sync from %s node\n",\r\n(hg < 0) ? "peer" : "this");\r\n}\r\nif (hg == -100) {\r\ndev_alert(DEV, "Split-Brain detected but unresolved, dropping connection!\n");\r\ndrbd_khelper(mdev, "split-brain");\r\nreturn C_MASK;\r\n}\r\nif (hg > 0 && mydisk <= D_INCONSISTENT) {\r\ndev_err(DEV, "I shall become SyncSource, but I am inconsistent!\n");\r\nreturn C_MASK;\r\n}\r\nif (hg < 0 &&\r\nmdev->state.role == R_PRIMARY && mdev->state.disk >= D_CONSISTENT) {\r\nswitch (mdev->net_conf->rr_conflict) {\r\ncase ASB_CALL_HELPER:\r\ndrbd_khelper(mdev, "pri-lost");\r\ncase ASB_DISCONNECT:\r\ndev_err(DEV, "I shall become SyncTarget, but I am primary!\n");\r\nreturn C_MASK;\r\ncase ASB_VIOLENTLY:\r\ndev_warn(DEV, "Becoming SyncTarget, violating the stable-data"\r\n"assumption\n");\r\n}\r\n}\r\nif (mdev->net_conf->dry_run || test_bit(CONN_DRY_RUN, &mdev->flags)) {\r\nif (hg == 0)\r\ndev_info(DEV, "dry-run connect: No resync, would become Connected immediately.\n");\r\nelse\r\ndev_info(DEV, "dry-run connect: Would become %s, doing a %s resync.",\r\ndrbd_conn_str(hg > 0 ? C_SYNC_SOURCE : C_SYNC_TARGET),\r\nabs(hg) >= 2 ? "full" : "bit-map based");\r\nreturn C_MASK;\r\n}\r\nif (abs(hg) >= 2) {\r\ndev_info(DEV, "Writing the whole bitmap, full sync required after drbd_sync_handshake.\n");\r\nif (drbd_bitmap_io(mdev, &drbd_bmio_set_n_write, "set_n_write from sync_handshake",\r\nBM_LOCKED_SET_ALLOWED))\r\nreturn C_MASK;\r\n}\r\nif (hg > 0) {\r\nrv = C_WF_BITMAP_S;\r\n} else if (hg < 0) {\r\nrv = C_WF_BITMAP_T;\r\n} else {\r\nrv = C_CONNECTED;\r\nif (drbd_bm_total_weight(mdev)) {\r\ndev_info(DEV, "No resync, but %lu bits in bitmap!\n",\r\ndrbd_bm_total_weight(mdev));\r\n}\r\n}\r\nreturn rv;\r\n}\r\nstatic int cmp_after_sb(enum drbd_after_sb_p peer, enum drbd_after_sb_p self)\r\n{\r\nif ((peer == ASB_DISCARD_REMOTE && self == ASB_DISCARD_LOCAL) ||\r\n(self == ASB_DISCARD_REMOTE && peer == ASB_DISCARD_LOCAL))\r\nreturn 0;\r\nif (peer == ASB_DISCARD_REMOTE || peer == ASB_DISCARD_LOCAL ||\r\nself == ASB_DISCARD_REMOTE || self == ASB_DISCARD_LOCAL)\r\nreturn 1;\r\nif (peer == self)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int receive_protocol(struct drbd_conf *mdev, enum drbd_packets cmd, unsigned int data_size)\r\n{\r\nstruct p_protocol *p = &mdev->data.rbuf.protocol;\r\nint p_proto, p_after_sb_0p, p_after_sb_1p, p_after_sb_2p;\r\nint p_want_lose, p_two_primaries, cf;\r\nchar p_integrity_alg[SHARED_SECRET_MAX] = "";\r\np_proto = be32_to_cpu(p->protocol);\r\np_after_sb_0p = be32_to_cpu(p->after_sb_0p);\r\np_after_sb_1p = be32_to_cpu(p->after_sb_1p);\r\np_after_sb_2p = be32_to_cpu(p->after_sb_2p);\r\np_two_primaries = be32_to_cpu(p->two_primaries);\r\ncf = be32_to_cpu(p->conn_flags);\r\np_want_lose = cf & CF_WANT_LOSE;\r\nclear_bit(CONN_DRY_RUN, &mdev->flags);\r\nif (cf & CF_DRY_RUN)\r\nset_bit(CONN_DRY_RUN, &mdev->flags);\r\nif (p_proto != mdev->net_conf->wire_protocol) {\r\ndev_err(DEV, "incompatible communication protocols\n");\r\ngoto disconnect;\r\n}\r\nif (cmp_after_sb(p_after_sb_0p, mdev->net_conf->after_sb_0p)) {\r\ndev_err(DEV, "incompatible after-sb-0pri settings\n");\r\ngoto disconnect;\r\n}\r\nif (cmp_after_sb(p_after_sb_1p, mdev->net_conf->after_sb_1p)) {\r\ndev_err(DEV, "incompatible after-sb-1pri settings\n");\r\ngoto disconnect;\r\n}\r\nif (cmp_after_sb(p_after_sb_2p, mdev->net_conf->after_sb_2p)) {\r\ndev_err(DEV, "incompatible after-sb-2pri settings\n");\r\ngoto disconnect;\r\n}\r\nif (p_want_lose && mdev->net_conf->want_lose) {\r\ndev_err(DEV, "both sides have the 'want_lose' flag set\n");\r\ngoto disconnect;\r\n}\r\nif (p_two_primaries != mdev->net_conf->two_primaries) {\r\ndev_err(DEV, "incompatible setting of the two-primaries options\n");\r\ngoto disconnect;\r\n}\r\nif (mdev->agreed_pro_version >= 87) {\r\nunsigned char *my_alg = mdev->net_conf->integrity_alg;\r\nif (drbd_recv(mdev, p_integrity_alg, data_size) != data_size)\r\nreturn false;\r\np_integrity_alg[SHARED_SECRET_MAX-1] = 0;\r\nif (strcmp(p_integrity_alg, my_alg)) {\r\ndev_err(DEV, "incompatible setting of the data-integrity-alg\n");\r\ngoto disconnect;\r\n}\r\ndev_info(DEV, "data-integrity-alg: %s\n",\r\nmy_alg[0] ? my_alg : (unsigned char *)"<not-used>");\r\n}\r\nreturn true;\r\ndisconnect:\r\ndrbd_force_state(mdev, NS(conn, C_DISCONNECTING));\r\nreturn false;\r\n}\r\nstruct crypto_hash *drbd_crypto_alloc_digest_safe(const struct drbd_conf *mdev,\r\nconst char *alg, const char *name)\r\n{\r\nstruct crypto_hash *tfm;\r\nif (!alg[0])\r\nreturn NULL;\r\ntfm = crypto_alloc_hash(alg, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(tfm)) {\r\ndev_err(DEV, "Can not allocate \"%s\" as %s (reason: %ld)\n",\r\nalg, name, PTR_ERR(tfm));\r\nreturn tfm;\r\n}\r\nif (!drbd_crypto_is_hash(crypto_hash_tfm(tfm))) {\r\ncrypto_free_hash(tfm);\r\ndev_err(DEV, "\"%s\" is not a digest (%s)\n", alg, name);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn tfm;\r\n}\r\nstatic int receive_SyncParam(struct drbd_conf *mdev, enum drbd_packets cmd, unsigned int packet_size)\r\n{\r\nint ok = true;\r\nstruct p_rs_param_95 *p = &mdev->data.rbuf.rs_param_95;\r\nunsigned int header_size, data_size, exp_max_sz;\r\nstruct crypto_hash *verify_tfm = NULL;\r\nstruct crypto_hash *csums_tfm = NULL;\r\nconst int apv = mdev->agreed_pro_version;\r\nint *rs_plan_s = NULL;\r\nint fifo_size = 0;\r\nexp_max_sz = apv <= 87 ? sizeof(struct p_rs_param)\r\n: apv == 88 ? sizeof(struct p_rs_param)\r\n+ SHARED_SECRET_MAX\r\n: apv <= 94 ? sizeof(struct p_rs_param_89)\r\n: sizeof(struct p_rs_param_95);\r\nif (packet_size > exp_max_sz) {\r\ndev_err(DEV, "SyncParam packet too long: received %u, expected <= %u bytes\n",\r\npacket_size, exp_max_sz);\r\nreturn false;\r\n}\r\nif (apv <= 88) {\r\nheader_size = sizeof(struct p_rs_param) - sizeof(struct p_header80);\r\ndata_size = packet_size - header_size;\r\n} else if (apv <= 94) {\r\nheader_size = sizeof(struct p_rs_param_89) - sizeof(struct p_header80);\r\ndata_size = packet_size - header_size;\r\nD_ASSERT(data_size == 0);\r\n} else {\r\nheader_size = sizeof(struct p_rs_param_95) - sizeof(struct p_header80);\r\ndata_size = packet_size - header_size;\r\nD_ASSERT(data_size == 0);\r\n}\r\nmemset(p->verify_alg, 0, 2 * SHARED_SECRET_MAX);\r\nif (drbd_recv(mdev, &p->head.payload, header_size) != header_size)\r\nreturn false;\r\nmdev->sync_conf.rate = be32_to_cpu(p->rate);\r\nif (apv >= 88) {\r\nif (apv == 88) {\r\nif (data_size > SHARED_SECRET_MAX) {\r\ndev_err(DEV, "verify-alg too long, "\r\n"peer wants %u, accepting only %u byte\n",\r\ndata_size, SHARED_SECRET_MAX);\r\nreturn false;\r\n}\r\nif (drbd_recv(mdev, p->verify_alg, data_size) != data_size)\r\nreturn false;\r\nD_ASSERT(p->verify_alg[data_size-1] == 0);\r\np->verify_alg[data_size-1] = 0;\r\n} else {\r\nD_ASSERT(p->verify_alg[SHARED_SECRET_MAX-1] == 0);\r\nD_ASSERT(p->csums_alg[SHARED_SECRET_MAX-1] == 0);\r\np->verify_alg[SHARED_SECRET_MAX-1] = 0;\r\np->csums_alg[SHARED_SECRET_MAX-1] = 0;\r\n}\r\nif (strcmp(mdev->sync_conf.verify_alg, p->verify_alg)) {\r\nif (mdev->state.conn == C_WF_REPORT_PARAMS) {\r\ndev_err(DEV, "Different verify-alg settings. me=\"%s\" peer=\"%s\"\n",\r\nmdev->sync_conf.verify_alg, p->verify_alg);\r\ngoto disconnect;\r\n}\r\nverify_tfm = drbd_crypto_alloc_digest_safe(mdev,\r\np->verify_alg, "verify-alg");\r\nif (IS_ERR(verify_tfm)) {\r\nverify_tfm = NULL;\r\ngoto disconnect;\r\n}\r\n}\r\nif (apv >= 89 && strcmp(mdev->sync_conf.csums_alg, p->csums_alg)) {\r\nif (mdev->state.conn == C_WF_REPORT_PARAMS) {\r\ndev_err(DEV, "Different csums-alg settings. me=\"%s\" peer=\"%s\"\n",\r\nmdev->sync_conf.csums_alg, p->csums_alg);\r\ngoto disconnect;\r\n}\r\ncsums_tfm = drbd_crypto_alloc_digest_safe(mdev,\r\np->csums_alg, "csums-alg");\r\nif (IS_ERR(csums_tfm)) {\r\ncsums_tfm = NULL;\r\ngoto disconnect;\r\n}\r\n}\r\nif (apv > 94) {\r\nmdev->sync_conf.rate = be32_to_cpu(p->rate);\r\nmdev->sync_conf.c_plan_ahead = be32_to_cpu(p->c_plan_ahead);\r\nmdev->sync_conf.c_delay_target = be32_to_cpu(p->c_delay_target);\r\nmdev->sync_conf.c_fill_target = be32_to_cpu(p->c_fill_target);\r\nmdev->sync_conf.c_max_rate = be32_to_cpu(p->c_max_rate);\r\nfifo_size = (mdev->sync_conf.c_plan_ahead * 10 * SLEEP_TIME) / HZ;\r\nif (fifo_size != mdev->rs_plan_s.size && fifo_size > 0) {\r\nrs_plan_s = kzalloc(sizeof(int) * fifo_size, GFP_KERNEL);\r\nif (!rs_plan_s) {\r\ndev_err(DEV, "kmalloc of fifo_buffer failed");\r\ngoto disconnect;\r\n}\r\n}\r\n}\r\nspin_lock(&mdev->peer_seq_lock);\r\nif (verify_tfm) {\r\nstrcpy(mdev->sync_conf.verify_alg, p->verify_alg);\r\nmdev->sync_conf.verify_alg_len = strlen(p->verify_alg) + 1;\r\ncrypto_free_hash(mdev->verify_tfm);\r\nmdev->verify_tfm = verify_tfm;\r\ndev_info(DEV, "using verify-alg: \"%s\"\n", p->verify_alg);\r\n}\r\nif (csums_tfm) {\r\nstrcpy(mdev->sync_conf.csums_alg, p->csums_alg);\r\nmdev->sync_conf.csums_alg_len = strlen(p->csums_alg) + 1;\r\ncrypto_free_hash(mdev->csums_tfm);\r\nmdev->csums_tfm = csums_tfm;\r\ndev_info(DEV, "using csums-alg: \"%s\"\n", p->csums_alg);\r\n}\r\nif (fifo_size != mdev->rs_plan_s.size) {\r\nkfree(mdev->rs_plan_s.values);\r\nmdev->rs_plan_s.values = rs_plan_s;\r\nmdev->rs_plan_s.size = fifo_size;\r\nmdev->rs_planed = 0;\r\n}\r\nspin_unlock(&mdev->peer_seq_lock);\r\n}\r\nreturn ok;\r\ndisconnect:\r\ncrypto_free_hash(csums_tfm);\r\ncrypto_free_hash(verify_tfm);\r\ndrbd_force_state(mdev, NS(conn, C_DISCONNECTING));\r\nreturn false;\r\n}\r\nstatic void warn_if_differ_considerably(struct drbd_conf *mdev,\r\nconst char *s, sector_t a, sector_t b)\r\n{\r\nsector_t d;\r\nif (a == 0 || b == 0)\r\nreturn;\r\nd = (a > b) ? (a - b) : (b - a);\r\nif (d > (a>>3) || d > (b>>3))\r\ndev_warn(DEV, "Considerable difference in %s: %llus vs. %llus\n", s,\r\n(unsigned long long)a, (unsigned long long)b);\r\n}\r\nstatic int receive_sizes(struct drbd_conf *mdev, enum drbd_packets cmd, unsigned int data_size)\r\n{\r\nstruct p_sizes *p = &mdev->data.rbuf.sizes;\r\nenum determine_dev_size dd = unchanged;\r\nsector_t p_size, p_usize, my_usize;\r\nint ldsc = 0;\r\nenum dds_flags ddsf;\r\np_size = be64_to_cpu(p->d_size);\r\np_usize = be64_to_cpu(p->u_size);\r\nif (p_size == 0 && mdev->state.disk == D_DISKLESS) {\r\ndev_err(DEV, "some backing storage is needed\n");\r\ndrbd_force_state(mdev, NS(conn, C_DISCONNECTING));\r\nreturn false;\r\n}\r\nmdev->p_size = p_size;\r\nif (get_ldev(mdev)) {\r\nwarn_if_differ_considerably(mdev, "lower level device sizes",\r\np_size, drbd_get_max_capacity(mdev->ldev));\r\nwarn_if_differ_considerably(mdev, "user requested size",\r\np_usize, mdev->ldev->dc.disk_size);\r\nif (mdev->state.conn == C_WF_REPORT_PARAMS)\r\np_usize = min_not_zero((sector_t)mdev->ldev->dc.disk_size,\r\np_usize);\r\nmy_usize = mdev->ldev->dc.disk_size;\r\nif (mdev->ldev->dc.disk_size != p_usize) {\r\nmdev->ldev->dc.disk_size = p_usize;\r\ndev_info(DEV, "Peer sets u_size to %lu sectors\n",\r\n(unsigned long)mdev->ldev->dc.disk_size);\r\n}\r\nif (drbd_new_dev_size(mdev, mdev->ldev, 0) <\r\ndrbd_get_capacity(mdev->this_bdev) &&\r\nmdev->state.disk >= D_OUTDATED &&\r\nmdev->state.conn < C_CONNECTED) {\r\ndev_err(DEV, "The peer's disk size is too small!\n");\r\ndrbd_force_state(mdev, NS(conn, C_DISCONNECTING));\r\nmdev->ldev->dc.disk_size = my_usize;\r\nput_ldev(mdev);\r\nreturn false;\r\n}\r\nput_ldev(mdev);\r\n}\r\nddsf = be16_to_cpu(p->dds_flags);\r\nif (get_ldev(mdev)) {\r\ndd = drbd_determine_dev_size(mdev, ddsf);\r\nput_ldev(mdev);\r\nif (dd == dev_size_error)\r\nreturn false;\r\ndrbd_md_sync(mdev);\r\n} else {\r\ndrbd_set_my_capacity(mdev, p_size);\r\n}\r\nmdev->peer_max_bio_size = be32_to_cpu(p->max_bio_size);\r\ndrbd_reconsider_max_bio_size(mdev);\r\nif (get_ldev(mdev)) {\r\nif (mdev->ldev->known_size != drbd_get_capacity(mdev->ldev->backing_bdev)) {\r\nmdev->ldev->known_size = drbd_get_capacity(mdev->ldev->backing_bdev);\r\nldsc = 1;\r\n}\r\nput_ldev(mdev);\r\n}\r\nif (mdev->state.conn > C_WF_REPORT_PARAMS) {\r\nif (be64_to_cpu(p->c_size) !=\r\ndrbd_get_capacity(mdev->this_bdev) || ldsc) {\r\ndrbd_send_sizes(mdev, 0, ddsf);\r\n}\r\nif (test_and_clear_bit(RESIZE_PENDING, &mdev->flags) ||\r\n(dd == grew && mdev->state.conn == C_CONNECTED)) {\r\nif (mdev->state.pdsk >= D_INCONSISTENT &&\r\nmdev->state.disk >= D_INCONSISTENT) {\r\nif (ddsf & DDSF_NO_RESYNC)\r\ndev_info(DEV, "Resync of new storage suppressed with --assume-clean\n");\r\nelse\r\nresync_after_online_grow(mdev);\r\n} else\r\nset_bit(RESYNC_AFTER_NEG, &mdev->flags);\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic int receive_uuids(struct drbd_conf *mdev, enum drbd_packets cmd, unsigned int data_size)\r\n{\r\nstruct p_uuids *p = &mdev->data.rbuf.uuids;\r\nu64 *p_uuid;\r\nint i, updated_uuids = 0;\r\np_uuid = kmalloc(sizeof(u64)*UI_EXTENDED_SIZE, GFP_NOIO);\r\nfor (i = UI_CURRENT; i < UI_EXTENDED_SIZE; i++)\r\np_uuid[i] = be64_to_cpu(p->uuid[i]);\r\nkfree(mdev->p_uuid);\r\nmdev->p_uuid = p_uuid;\r\nif (mdev->state.conn < C_CONNECTED &&\r\nmdev->state.disk < D_INCONSISTENT &&\r\nmdev->state.role == R_PRIMARY &&\r\n(mdev->ed_uuid & ~((u64)1)) != (p_uuid[UI_CURRENT] & ~((u64)1))) {\r\ndev_err(DEV, "Can only connect to data with current UUID=%016llX\n",\r\n(unsigned long long)mdev->ed_uuid);\r\ndrbd_force_state(mdev, NS(conn, C_DISCONNECTING));\r\nreturn false;\r\n}\r\nif (get_ldev(mdev)) {\r\nint skip_initial_sync =\r\nmdev->state.conn == C_CONNECTED &&\r\nmdev->agreed_pro_version >= 90 &&\r\nmdev->ldev->md.uuid[UI_CURRENT] == UUID_JUST_CREATED &&\r\n(p_uuid[UI_FLAGS] & 8);\r\nif (skip_initial_sync) {\r\ndev_info(DEV, "Accepted new current UUID, preparing to skip initial sync\n");\r\ndrbd_bitmap_io(mdev, &drbd_bmio_clear_n_write,\r\n"clear_n_write from receive_uuids",\r\nBM_LOCKED_TEST_ALLOWED);\r\n_drbd_uuid_set(mdev, UI_CURRENT, p_uuid[UI_CURRENT]);\r\n_drbd_uuid_set(mdev, UI_BITMAP, 0);\r\n_drbd_set_state(_NS2(mdev, disk, D_UP_TO_DATE, pdsk, D_UP_TO_DATE),\r\nCS_VERBOSE, NULL);\r\ndrbd_md_sync(mdev);\r\nupdated_uuids = 1;\r\n}\r\nput_ldev(mdev);\r\n} else if (mdev->state.disk < D_INCONSISTENT &&\r\nmdev->state.role == R_PRIMARY) {\r\nupdated_uuids = drbd_set_ed_uuid(mdev, p_uuid[UI_CURRENT]);\r\n}\r\nwait_event(mdev->misc_wait, !test_bit(CLUSTER_ST_CHANGE, &mdev->flags));\r\nif (mdev->state.conn >= C_CONNECTED && mdev->state.disk < D_INCONSISTENT)\r\nupdated_uuids |= drbd_set_ed_uuid(mdev, p_uuid[UI_CURRENT]);\r\nif (updated_uuids)\r\ndrbd_print_uuids(mdev, "receiver updated UUIDs to");\r\nreturn true;\r\n}\r\nstatic union drbd_state convert_state(union drbd_state ps)\r\n{\r\nunion drbd_state ms;\r\nstatic enum drbd_conns c_tab[] = {\r\n[C_CONNECTED] = C_CONNECTED,\r\n[C_STARTING_SYNC_S] = C_STARTING_SYNC_T,\r\n[C_STARTING_SYNC_T] = C_STARTING_SYNC_S,\r\n[C_DISCONNECTING] = C_TEAR_DOWN,\r\n[C_VERIFY_S] = C_VERIFY_T,\r\n[C_MASK] = C_MASK,\r\n};\r\nms.i = ps.i;\r\nms.conn = c_tab[ps.conn];\r\nms.peer = ps.role;\r\nms.role = ps.peer;\r\nms.pdsk = ps.disk;\r\nms.disk = ps.pdsk;\r\nms.peer_isp = (ps.aftr_isp | ps.user_isp);\r\nreturn ms;\r\n}\r\nstatic int receive_req_state(struct drbd_conf *mdev, enum drbd_packets cmd, unsigned int data_size)\r\n{\r\nstruct p_req_state *p = &mdev->data.rbuf.req_state;\r\nunion drbd_state mask, val;\r\nenum drbd_state_rv rv;\r\nmask.i = be32_to_cpu(p->mask);\r\nval.i = be32_to_cpu(p->val);\r\nif (test_bit(DISCARD_CONCURRENT, &mdev->flags) &&\r\ntest_bit(CLUSTER_ST_CHANGE, &mdev->flags)) {\r\ndrbd_send_sr_reply(mdev, SS_CONCURRENT_ST_CHG);\r\nreturn true;\r\n}\r\nmask = convert_state(mask);\r\nval = convert_state(val);\r\nrv = drbd_change_state(mdev, CS_VERBOSE, mask, val);\r\ndrbd_send_sr_reply(mdev, rv);\r\ndrbd_md_sync(mdev);\r\nreturn true;\r\n}\r\nstatic int receive_state(struct drbd_conf *mdev, enum drbd_packets cmd, unsigned int data_size)\r\n{\r\nstruct p_state *p = &mdev->data.rbuf.state;\r\nunion drbd_state os, ns, peer_state;\r\nenum drbd_disk_state real_peer_disk;\r\nenum chg_state_flags cs_flags;\r\nint rv;\r\npeer_state.i = be32_to_cpu(p->state);\r\nreal_peer_disk = peer_state.disk;\r\nif (peer_state.disk == D_NEGOTIATING) {\r\nreal_peer_disk = mdev->p_uuid[UI_FLAGS] & 4 ? D_INCONSISTENT : D_CONSISTENT;\r\ndev_info(DEV, "real peer disk state = %s\n", drbd_disk_str(real_peer_disk));\r\n}\r\nspin_lock_irq(&mdev->req_lock);\r\nretry:\r\nos = ns = mdev->state;\r\nspin_unlock_irq(&mdev->req_lock);\r\nif (os.pdsk == D_INCONSISTENT && real_peer_disk == D_UP_TO_DATE &&\r\nos.conn > C_CONNECTED && os.disk == D_UP_TO_DATE) {\r\nif (peer_state.conn > C_CONNECTED &&\r\npeer_state.conn < C_SYNC_SOURCE)\r\nreal_peer_disk = D_INCONSISTENT;\r\nelse if (os.conn >= C_SYNC_SOURCE &&\r\npeer_state.conn == C_CONNECTED) {\r\nif (drbd_bm_total_weight(mdev) <= mdev->rs_failed)\r\ndrbd_resync_finished(mdev);\r\nreturn true;\r\n}\r\n}\r\nif (os.pdsk == D_UP_TO_DATE && real_peer_disk == D_INCONSISTENT &&\r\nos.conn == C_CONNECTED && peer_state.conn > C_SYNC_SOURCE)\r\nreal_peer_disk = D_UP_TO_DATE;\r\nif (ns.conn == C_WF_REPORT_PARAMS)\r\nns.conn = C_CONNECTED;\r\nif (peer_state.conn == C_AHEAD)\r\nns.conn = C_BEHIND;\r\nif (mdev->p_uuid && peer_state.disk >= D_NEGOTIATING &&\r\nget_ldev_if_state(mdev, D_NEGOTIATING)) {\r\nint cr;\r\ncr = (os.conn < C_CONNECTED);\r\ncr |= (os.conn == C_CONNECTED &&\r\n(peer_state.disk == D_NEGOTIATING ||\r\nos.disk == D_NEGOTIATING));\r\ncr |= test_bit(CONSIDER_RESYNC, &mdev->flags);\r\ncr |= (os.conn == C_CONNECTED &&\r\n(peer_state.conn >= C_STARTING_SYNC_S &&\r\npeer_state.conn <= C_WF_BITMAP_T));\r\nif (cr)\r\nns.conn = drbd_sync_handshake(mdev, peer_state.role, real_peer_disk);\r\nput_ldev(mdev);\r\nif (ns.conn == C_MASK) {\r\nns.conn = C_CONNECTED;\r\nif (mdev->state.disk == D_NEGOTIATING) {\r\ndrbd_force_state(mdev, NS(disk, D_FAILED));\r\n} else if (peer_state.disk == D_NEGOTIATING) {\r\ndev_err(DEV, "Disk attach process on the peer node was aborted.\n");\r\npeer_state.disk = D_DISKLESS;\r\nreal_peer_disk = D_DISKLESS;\r\n} else {\r\nif (test_and_clear_bit(CONN_DRY_RUN, &mdev->flags))\r\nreturn false;\r\nD_ASSERT(os.conn == C_WF_REPORT_PARAMS);\r\ndrbd_force_state(mdev, NS(conn, C_DISCONNECTING));\r\nreturn false;\r\n}\r\n}\r\n}\r\nspin_lock_irq(&mdev->req_lock);\r\nif (mdev->state.i != os.i)\r\ngoto retry;\r\nclear_bit(CONSIDER_RESYNC, &mdev->flags);\r\nns.peer = peer_state.role;\r\nns.pdsk = real_peer_disk;\r\nns.peer_isp = (peer_state.aftr_isp | peer_state.user_isp);\r\nif ((ns.conn == C_CONNECTED || ns.conn == C_WF_BITMAP_S) && ns.disk == D_NEGOTIATING)\r\nns.disk = mdev->new_state_tmp.disk;\r\ncs_flags = CS_VERBOSE + (os.conn < C_CONNECTED && ns.conn >= C_CONNECTED ? 0 : CS_HARD);\r\nif (ns.pdsk == D_CONSISTENT && is_susp(ns) && ns.conn == C_CONNECTED && os.conn < C_CONNECTED &&\r\ntest_bit(NEW_CUR_UUID, &mdev->flags)) {\r\nspin_unlock_irq(&mdev->req_lock);\r\ndev_err(DEV, "Aborting Connect, can not thaw IO with an only Consistent peer\n");\r\ntl_clear(mdev);\r\ndrbd_uuid_new_current(mdev);\r\nclear_bit(NEW_CUR_UUID, &mdev->flags);\r\ndrbd_force_state(mdev, NS2(conn, C_PROTOCOL_ERROR, susp, 0));\r\nreturn false;\r\n}\r\nrv = _drbd_set_state(mdev, ns, cs_flags, NULL);\r\nns = mdev->state;\r\nspin_unlock_irq(&mdev->req_lock);\r\nif (rv < SS_SUCCESS) {\r\ndrbd_force_state(mdev, NS(conn, C_DISCONNECTING));\r\nreturn false;\r\n}\r\nif (os.conn > C_WF_REPORT_PARAMS) {\r\nif (ns.conn > C_CONNECTED && peer_state.conn <= C_CONNECTED &&\r\npeer_state.disk != D_NEGOTIATING ) {\r\ndrbd_send_uuids(mdev);\r\ndrbd_send_state(mdev);\r\n}\r\n}\r\nmdev->net_conf->want_lose = 0;\r\ndrbd_md_sync(mdev);\r\nreturn true;\r\n}\r\nstatic int receive_sync_uuid(struct drbd_conf *mdev, enum drbd_packets cmd, unsigned int data_size)\r\n{\r\nstruct p_rs_uuid *p = &mdev->data.rbuf.rs_uuid;\r\nwait_event(mdev->misc_wait,\r\nmdev->state.conn == C_WF_SYNC_UUID ||\r\nmdev->state.conn == C_BEHIND ||\r\nmdev->state.conn < C_CONNECTED ||\r\nmdev->state.disk < D_NEGOTIATING);\r\nif (get_ldev_if_state(mdev, D_NEGOTIATING)) {\r\n_drbd_uuid_set(mdev, UI_CURRENT, be64_to_cpu(p->uuid));\r\n_drbd_uuid_set(mdev, UI_BITMAP, 0UL);\r\ndrbd_print_uuids(mdev, "updated sync uuid");\r\ndrbd_start_resync(mdev, C_SYNC_TARGET);\r\nput_ldev(mdev);\r\n} else\r\ndev_err(DEV, "Ignoring SyncUUID packet!\n");\r\nreturn true;\r\n}\r\nstatic int\r\nreceive_bitmap_plain(struct drbd_conf *mdev, unsigned int data_size,\r\nunsigned long *buffer, struct bm_xfer_ctx *c)\r\n{\r\nunsigned num_words = min_t(size_t, BM_PACKET_WORDS, c->bm_words - c->word_offset);\r\nunsigned want = num_words * sizeof(long);\r\nint err;\r\nif (want != data_size) {\r\ndev_err(DEV, "%s:want (%u) != data_size (%u)\n", __func__, want, data_size);\r\nreturn -EIO;\r\n}\r\nif (want == 0)\r\nreturn 0;\r\nerr = drbd_recv(mdev, buffer, want);\r\nif (err != want) {\r\nif (err >= 0)\r\nerr = -EIO;\r\nreturn err;\r\n}\r\ndrbd_bm_merge_lel(mdev, c->word_offset, num_words, buffer);\r\nc->word_offset += num_words;\r\nc->bit_offset = c->word_offset * BITS_PER_LONG;\r\nif (c->bit_offset > c->bm_bits)\r\nc->bit_offset = c->bm_bits;\r\nreturn 1;\r\n}\r\nstatic int\r\nrecv_bm_rle_bits(struct drbd_conf *mdev,\r\nstruct p_compressed_bm *p,\r\nstruct bm_xfer_ctx *c)\r\n{\r\nstruct bitstream bs;\r\nu64 look_ahead;\r\nu64 rl;\r\nu64 tmp;\r\nunsigned long s = c->bit_offset;\r\nunsigned long e;\r\nint len = be16_to_cpu(p->head.length) - (sizeof(*p) - sizeof(p->head));\r\nint toggle = DCBP_get_start(p);\r\nint have;\r\nint bits;\r\nbitstream_init(&bs, p->code, len, DCBP_get_pad_bits(p));\r\nbits = bitstream_get_bits(&bs, &look_ahead, 64);\r\nif (bits < 0)\r\nreturn -EIO;\r\nfor (have = bits; have > 0; s += rl, toggle = !toggle) {\r\nbits = vli_decode_bits(&rl, look_ahead);\r\nif (bits <= 0)\r\nreturn -EIO;\r\nif (toggle) {\r\ne = s + rl -1;\r\nif (e >= c->bm_bits) {\r\ndev_err(DEV, "bitmap overflow (e:%lu) while decoding bm RLE packet\n", e);\r\nreturn -EIO;\r\n}\r\n_drbd_bm_set_bits(mdev, s, e);\r\n}\r\nif (have < bits) {\r\ndev_err(DEV, "bitmap decoding error: h:%d b:%d la:0x%08llx l:%u/%u\n",\r\nhave, bits, look_ahead,\r\n(unsigned int)(bs.cur.b - p->code),\r\n(unsigned int)bs.buf_len);\r\nreturn -EIO;\r\n}\r\nlook_ahead >>= bits;\r\nhave -= bits;\r\nbits = bitstream_get_bits(&bs, &tmp, 64 - have);\r\nif (bits < 0)\r\nreturn -EIO;\r\nlook_ahead |= tmp << have;\r\nhave += bits;\r\n}\r\nc->bit_offset = s;\r\nbm_xfer_ctx_bit_to_word_offset(c);\r\nreturn (s != c->bm_bits);\r\n}\r\nstatic int\r\ndecode_bitmap_c(struct drbd_conf *mdev,\r\nstruct p_compressed_bm *p,\r\nstruct bm_xfer_ctx *c)\r\n{\r\nif (DCBP_get_code(p) == RLE_VLI_Bits)\r\nreturn recv_bm_rle_bits(mdev, p, c);\r\ndev_err(DEV, "receive_bitmap_c: unknown encoding %u\n", p->encoding);\r\ndrbd_force_state(mdev, NS(conn, C_PROTOCOL_ERROR));\r\nreturn -EIO;\r\n}\r\nvoid INFO_bm_xfer_stats(struct drbd_conf *mdev,\r\nconst char *direction, struct bm_xfer_ctx *c)\r\n{\r\nunsigned plain = sizeof(struct p_header80) *\r\n((c->bm_words+BM_PACKET_WORDS-1)/BM_PACKET_WORDS+1)\r\n+ c->bm_words * sizeof(long);\r\nunsigned total = c->bytes[0] + c->bytes[1];\r\nunsigned r;\r\nif (total == 0)\r\nreturn;\r\nif (total >= plain)\r\nreturn;\r\nr = (total > UINT_MAX/1000) ? (total / (plain/1000))\r\n: (1000 * total / plain);\r\nif (r > 1000)\r\nr = 1000;\r\nr = 1000 - r;\r\ndev_info(DEV, "%s bitmap stats [Bytes(packets)]: plain %u(%u), RLE %u(%u), "\r\n"total %u; compression: %u.%u%%\n",\r\ndirection,\r\nc->bytes[1], c->packets[1],\r\nc->bytes[0], c->packets[0],\r\ntotal, r/10, r % 10);\r\n}\r\nstatic int receive_bitmap(struct drbd_conf *mdev, enum drbd_packets cmd, unsigned int data_size)\r\n{\r\nstruct bm_xfer_ctx c;\r\nvoid *buffer;\r\nint err;\r\nint ok = false;\r\nstruct p_header80 *h = &mdev->data.rbuf.header.h80;\r\ndrbd_bm_lock(mdev, "receive bitmap", BM_LOCKED_SET_ALLOWED);\r\nbuffer = (unsigned long *) __get_free_page(GFP_NOIO);\r\nif (!buffer) {\r\ndev_err(DEV, "failed to allocate one page buffer in %s\n", __func__);\r\ngoto out;\r\n}\r\nc = (struct bm_xfer_ctx) {\r\n.bm_bits = drbd_bm_bits(mdev),\r\n.bm_words = drbd_bm_words(mdev),\r\n};\r\nfor(;;) {\r\nif (cmd == P_BITMAP) {\r\nerr = receive_bitmap_plain(mdev, data_size, buffer, &c);\r\n} else if (cmd == P_COMPRESSED_BITMAP) {\r\nstruct p_compressed_bm *p;\r\nif (data_size > BM_PACKET_PAYLOAD_BYTES) {\r\ndev_err(DEV, "ReportCBitmap packet too large\n");\r\ngoto out;\r\n}\r\np = buffer;\r\nmemcpy(p, h, sizeof(*h));\r\nif (drbd_recv(mdev, p->head.payload, data_size) != data_size)\r\ngoto out;\r\nif (data_size <= (sizeof(*p) - sizeof(p->head))) {\r\ndev_err(DEV, "ReportCBitmap packet too small (l:%u)\n", data_size);\r\ngoto out;\r\n}\r\nerr = decode_bitmap_c(mdev, p, &c);\r\n} else {\r\ndev_warn(DEV, "receive_bitmap: cmd neither ReportBitMap nor ReportCBitMap (is 0x%x)", cmd);\r\ngoto out;\r\n}\r\nc.packets[cmd == P_BITMAP]++;\r\nc.bytes[cmd == P_BITMAP] += sizeof(struct p_header80) + data_size;\r\nif (err <= 0) {\r\nif (err < 0)\r\ngoto out;\r\nbreak;\r\n}\r\nif (!drbd_recv_header(mdev, &cmd, &data_size))\r\ngoto out;\r\n}\r\nINFO_bm_xfer_stats(mdev, "receive", &c);\r\nif (mdev->state.conn == C_WF_BITMAP_T) {\r\nenum drbd_state_rv rv;\r\nok = !drbd_send_bitmap(mdev);\r\nif (!ok)\r\ngoto out;\r\nrv = _drbd_request_state(mdev, NS(conn, C_WF_SYNC_UUID), CS_VERBOSE);\r\nD_ASSERT(rv == SS_SUCCESS);\r\n} else if (mdev->state.conn != C_WF_BITMAP_S) {\r\ndev_info(DEV, "unexpected cstate (%s) in receive_bitmap\n",\r\ndrbd_conn_str(mdev->state.conn));\r\n}\r\nok = true;\r\nout:\r\ndrbd_bm_unlock(mdev);\r\nif (ok && mdev->state.conn == C_WF_BITMAP_S)\r\ndrbd_start_resync(mdev, C_SYNC_SOURCE);\r\nfree_page((unsigned long) buffer);\r\nreturn ok;\r\n}\r\nstatic int receive_skip(struct drbd_conf *mdev, enum drbd_packets cmd, unsigned int data_size)\r\n{\r\nstatic char sink[128];\r\nint size, want, r;\r\ndev_warn(DEV, "skipping unknown optional packet type %d, l: %d!\n",\r\ncmd, data_size);\r\nsize = data_size;\r\nwhile (size > 0) {\r\nwant = min_t(int, size, sizeof(sink));\r\nr = drbd_recv(mdev, sink, want);\r\nERR_IF(r <= 0) break;\r\nsize -= r;\r\n}\r\nreturn size == 0;\r\n}\r\nstatic int receive_UnplugRemote(struct drbd_conf *mdev, enum drbd_packets cmd, unsigned int data_size)\r\n{\r\ndrbd_tcp_quickack(mdev->data.socket);\r\nreturn true;\r\n}\r\nstatic int receive_out_of_sync(struct drbd_conf *mdev, enum drbd_packets cmd, unsigned int data_size)\r\n{\r\nstruct p_block_desc *p = &mdev->data.rbuf.block_desc;\r\nswitch (mdev->state.conn) {\r\ncase C_WF_SYNC_UUID:\r\ncase C_WF_BITMAP_T:\r\ncase C_BEHIND:\r\nbreak;\r\ndefault:\r\ndev_err(DEV, "ASSERT FAILED cstate = %s, expected: WFSyncUUID|WFBitMapT|Behind\n",\r\ndrbd_conn_str(mdev->state.conn));\r\n}\r\ndrbd_set_out_of_sync(mdev, be64_to_cpu(p->sector), be32_to_cpu(p->blksize));\r\nreturn true;\r\n}\r\nstatic void drbdd(struct drbd_conf *mdev)\r\n{\r\nunion p_header *header = &mdev->data.rbuf.header;\r\nunsigned int packet_size;\r\nenum drbd_packets cmd;\r\nsize_t shs;\r\nint rv;\r\nwhile (get_t_state(&mdev->receiver) == Running) {\r\ndrbd_thread_current_set_cpu(mdev);\r\nif (!drbd_recv_header(mdev, &cmd, &packet_size))\r\ngoto err_out;\r\nif (unlikely(cmd >= P_MAX_CMD || !drbd_cmd_handler[cmd].function)) {\r\ndev_err(DEV, "unknown packet type %d, l: %d!\n", cmd, packet_size);\r\ngoto err_out;\r\n}\r\nshs = drbd_cmd_handler[cmd].pkt_size - sizeof(union p_header);\r\nif (packet_size - shs > 0 && !drbd_cmd_handler[cmd].expect_payload) {\r\ndev_err(DEV, "No payload expected %s l:%d\n", cmdname(cmd), packet_size);\r\ngoto err_out;\r\n}\r\nif (shs) {\r\nrv = drbd_recv(mdev, &header->h80.payload, shs);\r\nif (unlikely(rv != shs)) {\r\nif (!signal_pending(current))\r\ndev_warn(DEV, "short read while reading sub header: rv=%d\n", rv);\r\ngoto err_out;\r\n}\r\n}\r\nrv = drbd_cmd_handler[cmd].function(mdev, cmd, packet_size - shs);\r\nif (unlikely(!rv)) {\r\ndev_err(DEV, "error receiving %s, l: %d!\n",\r\ncmdname(cmd), packet_size);\r\ngoto err_out;\r\n}\r\n}\r\nif (0) {\r\nerr_out:\r\ndrbd_force_state(mdev, NS(conn, C_PROTOCOL_ERROR));\r\n}\r\ndrbd_md_sync(mdev);\r\n}\r\nvoid drbd_flush_workqueue(struct drbd_conf *mdev)\r\n{\r\nstruct drbd_wq_barrier barr;\r\nbarr.w.cb = w_prev_work_done;\r\ninit_completion(&barr.done);\r\ndrbd_queue_work(&mdev->data.work, &barr.w);\r\nwait_for_completion(&barr.done);\r\n}\r\nvoid drbd_free_tl_hash(struct drbd_conf *mdev)\r\n{\r\nstruct hlist_head *h;\r\nspin_lock_irq(&mdev->req_lock);\r\nif (!mdev->tl_hash || mdev->state.conn != C_STANDALONE) {\r\nspin_unlock_irq(&mdev->req_lock);\r\nreturn;\r\n}\r\nfor (h = mdev->ee_hash; h < mdev->ee_hash + mdev->ee_hash_s; h++)\r\nif (h->first)\r\ndev_err(DEV, "ASSERT FAILED ee_hash[%u].first == %p, expected NULL\n",\r\n(int)(h - mdev->ee_hash), h->first);\r\nkfree(mdev->ee_hash);\r\nmdev->ee_hash = NULL;\r\nmdev->ee_hash_s = 0;\r\nfor (h = mdev->tl_hash; h < mdev->tl_hash + mdev->tl_hash_s; h++)\r\nif (h->first)\r\ndev_err(DEV, "ASSERT FAILED tl_hash[%u] == %p, expected NULL\n",\r\n(int)(h - mdev->tl_hash), h->first);\r\nkfree(mdev->tl_hash);\r\nmdev->tl_hash = NULL;\r\nmdev->tl_hash_s = 0;\r\nspin_unlock_irq(&mdev->req_lock);\r\n}\r\nstatic void drbd_disconnect(struct drbd_conf *mdev)\r\n{\r\nenum drbd_fencing_p fp;\r\nunion drbd_state os, ns;\r\nint rv = SS_UNKNOWN_ERROR;\r\nunsigned int i;\r\nif (mdev->state.conn == C_STANDALONE)\r\nreturn;\r\ndrbd_thread_stop(&mdev->asender);\r\ndrbd_free_sock(mdev);\r\nspin_lock_irq(&mdev->req_lock);\r\n_drbd_wait_ee_list_empty(mdev, &mdev->active_ee);\r\n_drbd_wait_ee_list_empty(mdev, &mdev->sync_ee);\r\n_drbd_wait_ee_list_empty(mdev, &mdev->read_ee);\r\nspin_unlock_irq(&mdev->req_lock);\r\ndrbd_rs_cancel_all(mdev);\r\nmdev->rs_total = 0;\r\nmdev->rs_failed = 0;\r\natomic_set(&mdev->rs_pending_cnt, 0);\r\nwake_up(&mdev->misc_wait);\r\ndel_timer(&mdev->request_timer);\r\ndel_timer_sync(&mdev->resync_timer);\r\nresync_timer_fn((unsigned long)mdev);\r\ndrbd_flush_workqueue(mdev);\r\ndrbd_process_done_ee(mdev);\r\nkfree(mdev->p_uuid);\r\nmdev->p_uuid = NULL;\r\nif (!is_susp(mdev->state))\r\ntl_clear(mdev);\r\ndev_info(DEV, "Connection closed\n");\r\ndrbd_md_sync(mdev);\r\nfp = FP_DONT_CARE;\r\nif (get_ldev(mdev)) {\r\nfp = mdev->ldev->dc.fencing;\r\nput_ldev(mdev);\r\n}\r\nif (mdev->state.role == R_PRIMARY && fp >= FP_RESOURCE && mdev->state.pdsk >= D_UNKNOWN)\r\ndrbd_try_outdate_peer_async(mdev);\r\nspin_lock_irq(&mdev->req_lock);\r\nos = mdev->state;\r\nif (os.conn >= C_UNCONNECTED) {\r\nns = os;\r\nns.conn = C_UNCONNECTED;\r\nrv = _drbd_set_state(mdev, ns, CS_VERBOSE, NULL);\r\n}\r\nspin_unlock_irq(&mdev->req_lock);\r\nif (os.conn == C_DISCONNECTING) {\r\nwait_event(mdev->net_cnt_wait, atomic_read(&mdev->net_cnt) == 0);\r\ncrypto_free_hash(mdev->cram_hmac_tfm);\r\nmdev->cram_hmac_tfm = NULL;\r\nkfree(mdev->net_conf);\r\nmdev->net_conf = NULL;\r\ndrbd_request_state(mdev, NS(conn, C_STANDALONE));\r\n}\r\nwait_event(mdev->misc_wait, !test_bit(BITMAP_IO, &mdev->flags));\r\ni = drbd_release_ee(mdev, &mdev->net_ee);\r\nif (i)\r\ndev_info(DEV, "net_ee not empty, killed %u entries\n", i);\r\ni = atomic_read(&mdev->pp_in_use_by_net);\r\nif (i)\r\ndev_info(DEV, "pp_in_use_by_net = %d, expected 0\n", i);\r\ni = atomic_read(&mdev->pp_in_use);\r\nif (i)\r\ndev_info(DEV, "pp_in_use = %d, expected 0\n", i);\r\nD_ASSERT(list_empty(&mdev->read_ee));\r\nD_ASSERT(list_empty(&mdev->active_ee));\r\nD_ASSERT(list_empty(&mdev->sync_ee));\r\nD_ASSERT(list_empty(&mdev->done_ee));\r\natomic_set(&mdev->current_epoch->epoch_size, 0);\r\nD_ASSERT(list_empty(&mdev->current_epoch->list));\r\n}\r\nstatic int drbd_send_handshake(struct drbd_conf *mdev)\r\n{\r\nstruct p_handshake *p = &mdev->data.sbuf.handshake;\r\nint ok;\r\nif (mutex_lock_interruptible(&mdev->data.mutex)) {\r\ndev_err(DEV, "interrupted during initial handshake\n");\r\nreturn 0;\r\n}\r\nif (mdev->data.socket == NULL) {\r\nmutex_unlock(&mdev->data.mutex);\r\nreturn 0;\r\n}\r\nmemset(p, 0, sizeof(*p));\r\np->protocol_min = cpu_to_be32(PRO_VERSION_MIN);\r\np->protocol_max = cpu_to_be32(PRO_VERSION_MAX);\r\nok = _drbd_send_cmd( mdev, mdev->data.socket, P_HAND_SHAKE,\r\n(struct p_header80 *)p, sizeof(*p), 0 );\r\nmutex_unlock(&mdev->data.mutex);\r\nreturn ok;\r\n}\r\nstatic int drbd_do_handshake(struct drbd_conf *mdev)\r\n{\r\nstruct p_handshake *p = &mdev->data.rbuf.handshake;\r\nconst int expect = sizeof(struct p_handshake) - sizeof(struct p_header80);\r\nunsigned int length;\r\nenum drbd_packets cmd;\r\nint rv;\r\nrv = drbd_send_handshake(mdev);\r\nif (!rv)\r\nreturn 0;\r\nrv = drbd_recv_header(mdev, &cmd, &length);\r\nif (!rv)\r\nreturn 0;\r\nif (cmd != P_HAND_SHAKE) {\r\ndev_err(DEV, "expected HandShake packet, received: %s (0x%04x)\n",\r\ncmdname(cmd), cmd);\r\nreturn -1;\r\n}\r\nif (length != expect) {\r\ndev_err(DEV, "expected HandShake length: %u, received: %u\n",\r\nexpect, length);\r\nreturn -1;\r\n}\r\nrv = drbd_recv(mdev, &p->head.payload, expect);\r\nif (rv != expect) {\r\nif (!signal_pending(current))\r\ndev_warn(DEV, "short read receiving handshake packet: l=%u\n", rv);\r\nreturn 0;\r\n}\r\np->protocol_min = be32_to_cpu(p->protocol_min);\r\np->protocol_max = be32_to_cpu(p->protocol_max);\r\nif (p->protocol_max == 0)\r\np->protocol_max = p->protocol_min;\r\nif (PRO_VERSION_MAX < p->protocol_min ||\r\nPRO_VERSION_MIN > p->protocol_max)\r\ngoto incompat;\r\nmdev->agreed_pro_version = min_t(int, PRO_VERSION_MAX, p->protocol_max);\r\ndev_info(DEV, "Handshake successful: "\r\n"Agreed network protocol version %d\n", mdev->agreed_pro_version);\r\nreturn 1;\r\nincompat:\r\ndev_err(DEV, "incompatible DRBD dialects: "\r\n"I support %d-%d, peer supports %d-%d\n",\r\nPRO_VERSION_MIN, PRO_VERSION_MAX,\r\np->protocol_min, p->protocol_max);\r\nreturn -1;\r\n}\r\nstatic int drbd_do_auth(struct drbd_conf *mdev)\r\n{\r\ndev_err(DEV, "This kernel was build without CONFIG_CRYPTO_HMAC.\n");\r\ndev_err(DEV, "You need to disable 'cram-hmac-alg' in drbd.conf.\n");\r\nreturn -1;\r\n}\r\nstatic int drbd_do_auth(struct drbd_conf *mdev)\r\n{\r\nchar my_challenge[CHALLENGE_LEN];\r\nstruct scatterlist sg;\r\nchar *response = NULL;\r\nchar *right_response = NULL;\r\nchar *peers_ch = NULL;\r\nunsigned int key_len = strlen(mdev->net_conf->shared_secret);\r\nunsigned int resp_size;\r\nstruct hash_desc desc;\r\nenum drbd_packets cmd;\r\nunsigned int length;\r\nint rv;\r\ndesc.tfm = mdev->cram_hmac_tfm;\r\ndesc.flags = 0;\r\nrv = crypto_hash_setkey(mdev->cram_hmac_tfm,\r\n(u8 *)mdev->net_conf->shared_secret, key_len);\r\nif (rv) {\r\ndev_err(DEV, "crypto_hash_setkey() failed with %d\n", rv);\r\nrv = -1;\r\ngoto fail;\r\n}\r\nget_random_bytes(my_challenge, CHALLENGE_LEN);\r\nrv = drbd_send_cmd2(mdev, P_AUTH_CHALLENGE, my_challenge, CHALLENGE_LEN);\r\nif (!rv)\r\ngoto fail;\r\nrv = drbd_recv_header(mdev, &cmd, &length);\r\nif (!rv)\r\ngoto fail;\r\nif (cmd != P_AUTH_CHALLENGE) {\r\ndev_err(DEV, "expected AuthChallenge packet, received: %s (0x%04x)\n",\r\ncmdname(cmd), cmd);\r\nrv = 0;\r\ngoto fail;\r\n}\r\nif (length > CHALLENGE_LEN * 2) {\r\ndev_err(DEV, "expected AuthChallenge payload too big.\n");\r\nrv = -1;\r\ngoto fail;\r\n}\r\npeers_ch = kmalloc(length, GFP_NOIO);\r\nif (peers_ch == NULL) {\r\ndev_err(DEV, "kmalloc of peers_ch failed\n");\r\nrv = -1;\r\ngoto fail;\r\n}\r\nrv = drbd_recv(mdev, peers_ch, length);\r\nif (rv != length) {\r\nif (!signal_pending(current))\r\ndev_warn(DEV, "short read AuthChallenge: l=%u\n", rv);\r\nrv = 0;\r\ngoto fail;\r\n}\r\nresp_size = crypto_hash_digestsize(mdev->cram_hmac_tfm);\r\nresponse = kmalloc(resp_size, GFP_NOIO);\r\nif (response == NULL) {\r\ndev_err(DEV, "kmalloc of response failed\n");\r\nrv = -1;\r\ngoto fail;\r\n}\r\nsg_init_table(&sg, 1);\r\nsg_set_buf(&sg, peers_ch, length);\r\nrv = crypto_hash_digest(&desc, &sg, sg.length, response);\r\nif (rv) {\r\ndev_err(DEV, "crypto_hash_digest() failed with %d\n", rv);\r\nrv = -1;\r\ngoto fail;\r\n}\r\nrv = drbd_send_cmd2(mdev, P_AUTH_RESPONSE, response, resp_size);\r\nif (!rv)\r\ngoto fail;\r\nrv = drbd_recv_header(mdev, &cmd, &length);\r\nif (!rv)\r\ngoto fail;\r\nif (cmd != P_AUTH_RESPONSE) {\r\ndev_err(DEV, "expected AuthResponse packet, received: %s (0x%04x)\n",\r\ncmdname(cmd), cmd);\r\nrv = 0;\r\ngoto fail;\r\n}\r\nif (length != resp_size) {\r\ndev_err(DEV, "expected AuthResponse payload of wrong size\n");\r\nrv = 0;\r\ngoto fail;\r\n}\r\nrv = drbd_recv(mdev, response , resp_size);\r\nif (rv != resp_size) {\r\nif (!signal_pending(current))\r\ndev_warn(DEV, "short read receiving AuthResponse: l=%u\n", rv);\r\nrv = 0;\r\ngoto fail;\r\n}\r\nright_response = kmalloc(resp_size, GFP_NOIO);\r\nif (right_response == NULL) {\r\ndev_err(DEV, "kmalloc of right_response failed\n");\r\nrv = -1;\r\ngoto fail;\r\n}\r\nsg_set_buf(&sg, my_challenge, CHALLENGE_LEN);\r\nrv = crypto_hash_digest(&desc, &sg, sg.length, right_response);\r\nif (rv) {\r\ndev_err(DEV, "crypto_hash_digest() failed with %d\n", rv);\r\nrv = -1;\r\ngoto fail;\r\n}\r\nrv = !memcmp(response, right_response, resp_size);\r\nif (rv)\r\ndev_info(DEV, "Peer authenticated using %d bytes of '%s' HMAC\n",\r\nresp_size, mdev->net_conf->cram_hmac_alg);\r\nelse\r\nrv = -1;\r\nfail:\r\nkfree(peers_ch);\r\nkfree(response);\r\nkfree(right_response);\r\nreturn rv;\r\n}\r\nint drbdd_init(struct drbd_thread *thi)\r\n{\r\nstruct drbd_conf *mdev = thi->mdev;\r\nunsigned int minor = mdev_to_minor(mdev);\r\nint h;\r\nsprintf(current->comm, "drbd%d_receiver", minor);\r\ndev_info(DEV, "receiver (re)started\n");\r\ndo {\r\nh = drbd_connect(mdev);\r\nif (h == 0) {\r\ndrbd_disconnect(mdev);\r\nschedule_timeout_interruptible(HZ);\r\n}\r\nif (h == -1) {\r\ndev_warn(DEV, "Discarding network configuration.\n");\r\ndrbd_force_state(mdev, NS(conn, C_DISCONNECTING));\r\n}\r\n} while (h == 0);\r\nif (h > 0) {\r\nif (get_net_conf(mdev)) {\r\ndrbdd(mdev);\r\nput_net_conf(mdev);\r\n}\r\n}\r\ndrbd_disconnect(mdev);\r\ndev_info(DEV, "receiver terminated\n");\r\nreturn 0;\r\n}\r\nstatic int got_RqSReply(struct drbd_conf *mdev, struct p_header80 *h)\r\n{\r\nstruct p_req_state_reply *p = (struct p_req_state_reply *)h;\r\nint retcode = be32_to_cpu(p->retcode);\r\nif (retcode >= SS_SUCCESS) {\r\nset_bit(CL_ST_CHG_SUCCESS, &mdev->flags);\r\n} else {\r\nset_bit(CL_ST_CHG_FAIL, &mdev->flags);\r\ndev_err(DEV, "Requested state change failed by peer: %s (%d)\n",\r\ndrbd_set_st_err_str(retcode), retcode);\r\n}\r\nwake_up(&mdev->state_wait);\r\nreturn true;\r\n}\r\nstatic int got_Ping(struct drbd_conf *mdev, struct p_header80 *h)\r\n{\r\nreturn drbd_send_ping_ack(mdev);\r\n}\r\nstatic int got_PingAck(struct drbd_conf *mdev, struct p_header80 *h)\r\n{\r\nmdev->meta.socket->sk->sk_rcvtimeo = mdev->net_conf->ping_int*HZ;\r\nif (!test_and_set_bit(GOT_PING_ACK, &mdev->flags))\r\nwake_up(&mdev->misc_wait);\r\nreturn true;\r\n}\r\nstatic int got_IsInSync(struct drbd_conf *mdev, struct p_header80 *h)\r\n{\r\nstruct p_block_ack *p = (struct p_block_ack *)h;\r\nsector_t sector = be64_to_cpu(p->sector);\r\nint blksize = be32_to_cpu(p->blksize);\r\nD_ASSERT(mdev->agreed_pro_version >= 89);\r\nupdate_peer_seq(mdev, be32_to_cpu(p->seq_num));\r\nif (get_ldev(mdev)) {\r\ndrbd_rs_complete_io(mdev, sector);\r\ndrbd_set_in_sync(mdev, sector, blksize);\r\nmdev->rs_same_csum += (blksize >> BM_BLOCK_SHIFT);\r\nput_ldev(mdev);\r\n}\r\ndec_rs_pending(mdev);\r\natomic_add(blksize >> 9, &mdev->rs_sect_in);\r\nreturn true;\r\n}\r\nstatic struct drbd_request *_ack_id_to_req(struct drbd_conf *mdev,\r\nu64 id, sector_t sector)\r\n{\r\nstruct hlist_head *slot = tl_hash_slot(mdev, sector);\r\nstruct hlist_node *n;\r\nstruct drbd_request *req;\r\nhlist_for_each_entry(req, n, slot, collision) {\r\nif ((unsigned long)req == (unsigned long)id) {\r\nif (req->sector != sector) {\r\ndev_err(DEV, "_ack_id_to_req: found req %p but it has "\r\n"wrong sector (%llus versus %llus)\n", req,\r\n(unsigned long long)req->sector,\r\n(unsigned long long)sector);\r\nbreak;\r\n}\r\nreturn req;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int validate_req_change_req_state(struct drbd_conf *mdev,\r\nu64 id, sector_t sector, req_validator_fn validator,\r\nconst char *func, enum drbd_req_event what)\r\n{\r\nstruct drbd_request *req;\r\nstruct bio_and_error m;\r\nspin_lock_irq(&mdev->req_lock);\r\nreq = validator(mdev, id, sector);\r\nif (unlikely(!req)) {\r\nspin_unlock_irq(&mdev->req_lock);\r\ndev_err(DEV, "%s: failed to find req %p, sector %llus\n", func,\r\n(void *)(unsigned long)id, (unsigned long long)sector);\r\nreturn false;\r\n}\r\n__req_mod(req, what, &m);\r\nspin_unlock_irq(&mdev->req_lock);\r\nif (m.bio)\r\ncomplete_master_bio(mdev, &m);\r\nreturn true;\r\n}\r\nstatic int got_BlockAck(struct drbd_conf *mdev, struct p_header80 *h)\r\n{\r\nstruct p_block_ack *p = (struct p_block_ack *)h;\r\nsector_t sector = be64_to_cpu(p->sector);\r\nint blksize = be32_to_cpu(p->blksize);\r\nenum drbd_req_event what;\r\nupdate_peer_seq(mdev, be32_to_cpu(p->seq_num));\r\nif (is_syncer_block_id(p->block_id)) {\r\ndrbd_set_in_sync(mdev, sector, blksize);\r\ndec_rs_pending(mdev);\r\nreturn true;\r\n}\r\nswitch (be16_to_cpu(h->command)) {\r\ncase P_RS_WRITE_ACK:\r\nD_ASSERT(mdev->net_conf->wire_protocol == DRBD_PROT_C);\r\nwhat = write_acked_by_peer_and_sis;\r\nbreak;\r\ncase P_WRITE_ACK:\r\nD_ASSERT(mdev->net_conf->wire_protocol == DRBD_PROT_C);\r\nwhat = write_acked_by_peer;\r\nbreak;\r\ncase P_RECV_ACK:\r\nD_ASSERT(mdev->net_conf->wire_protocol == DRBD_PROT_B);\r\nwhat = recv_acked_by_peer;\r\nbreak;\r\ncase P_DISCARD_ACK:\r\nD_ASSERT(mdev->net_conf->wire_protocol == DRBD_PROT_C);\r\nwhat = conflict_discarded_by_peer;\r\nbreak;\r\ndefault:\r\nD_ASSERT(0);\r\nreturn false;\r\n}\r\nreturn validate_req_change_req_state(mdev, p->block_id, sector,\r\n_ack_id_to_req, __func__ , what);\r\n}\r\nstatic int got_NegAck(struct drbd_conf *mdev, struct p_header80 *h)\r\n{\r\nstruct p_block_ack *p = (struct p_block_ack *)h;\r\nsector_t sector = be64_to_cpu(p->sector);\r\nint size = be32_to_cpu(p->blksize);\r\nstruct drbd_request *req;\r\nstruct bio_and_error m;\r\nupdate_peer_seq(mdev, be32_to_cpu(p->seq_num));\r\nif (is_syncer_block_id(p->block_id)) {\r\ndec_rs_pending(mdev);\r\ndrbd_rs_failed_io(mdev, sector, size);\r\nreturn true;\r\n}\r\nspin_lock_irq(&mdev->req_lock);\r\nreq = _ack_id_to_req(mdev, p->block_id, sector);\r\nif (!req) {\r\nspin_unlock_irq(&mdev->req_lock);\r\nif (mdev->net_conf->wire_protocol == DRBD_PROT_A ||\r\nmdev->net_conf->wire_protocol == DRBD_PROT_B) {\r\ndrbd_set_out_of_sync(mdev, sector, size);\r\nreturn true;\r\n} else {\r\ndev_err(DEV, "%s: failed to find req %p, sector %llus\n", __func__,\r\n(void *)(unsigned long)p->block_id, (unsigned long long)sector);\r\nreturn false;\r\n}\r\n}\r\n__req_mod(req, neg_acked, &m);\r\nspin_unlock_irq(&mdev->req_lock);\r\nif (m.bio)\r\ncomplete_master_bio(mdev, &m);\r\nreturn true;\r\n}\r\nstatic int got_NegDReply(struct drbd_conf *mdev, struct p_header80 *h)\r\n{\r\nstruct p_block_ack *p = (struct p_block_ack *)h;\r\nsector_t sector = be64_to_cpu(p->sector);\r\nupdate_peer_seq(mdev, be32_to_cpu(p->seq_num));\r\ndev_err(DEV, "Got NegDReply; Sector %llus, len %u; Fail original request.\n",\r\n(unsigned long long)sector, be32_to_cpu(p->blksize));\r\nreturn validate_req_change_req_state(mdev, p->block_id, sector,\r\n_ar_id_to_req, __func__ , neg_acked);\r\n}\r\nstatic int got_NegRSDReply(struct drbd_conf *mdev, struct p_header80 *h)\r\n{\r\nsector_t sector;\r\nint size;\r\nstruct p_block_ack *p = (struct p_block_ack *)h;\r\nsector = be64_to_cpu(p->sector);\r\nsize = be32_to_cpu(p->blksize);\r\nupdate_peer_seq(mdev, be32_to_cpu(p->seq_num));\r\ndec_rs_pending(mdev);\r\nif (get_ldev_if_state(mdev, D_FAILED)) {\r\ndrbd_rs_complete_io(mdev, sector);\r\nswitch (be16_to_cpu(h->command)) {\r\ncase P_NEG_RS_DREPLY:\r\ndrbd_rs_failed_io(mdev, sector, size);\r\ncase P_RS_CANCEL:\r\nbreak;\r\ndefault:\r\nD_ASSERT(0);\r\nput_ldev(mdev);\r\nreturn false;\r\n}\r\nput_ldev(mdev);\r\n}\r\nreturn true;\r\n}\r\nstatic int got_BarrierAck(struct drbd_conf *mdev, struct p_header80 *h)\r\n{\r\nstruct p_barrier_ack *p = (struct p_barrier_ack *)h;\r\ntl_release(mdev, p->barrier, be32_to_cpu(p->set_size));\r\nif (mdev->state.conn == C_AHEAD &&\r\natomic_read(&mdev->ap_in_flight) == 0 &&\r\n!test_and_set_bit(AHEAD_TO_SYNC_SOURCE, &mdev->current_epoch->flags)) {\r\nmdev->start_resync_timer.expires = jiffies + HZ;\r\nadd_timer(&mdev->start_resync_timer);\r\n}\r\nreturn true;\r\n}\r\nstatic int got_OVResult(struct drbd_conf *mdev, struct p_header80 *h)\r\n{\r\nstruct p_block_ack *p = (struct p_block_ack *)h;\r\nstruct drbd_work *w;\r\nsector_t sector;\r\nint size;\r\nsector = be64_to_cpu(p->sector);\r\nsize = be32_to_cpu(p->blksize);\r\nupdate_peer_seq(mdev, be32_to_cpu(p->seq_num));\r\nif (be64_to_cpu(p->block_id) == ID_OUT_OF_SYNC)\r\ndrbd_ov_oos_found(mdev, sector, size);\r\nelse\r\nov_oos_print(mdev);\r\nif (!get_ldev(mdev))\r\nreturn true;\r\ndrbd_rs_complete_io(mdev, sector);\r\ndec_rs_pending(mdev);\r\n--mdev->ov_left;\r\nif ((mdev->ov_left & 0x200) == 0x200)\r\ndrbd_advance_rs_marks(mdev, mdev->ov_left);\r\nif (mdev->ov_left == 0) {\r\nw = kmalloc(sizeof(*w), GFP_NOIO);\r\nif (w) {\r\nw->cb = w_ov_finished;\r\ndrbd_queue_work_front(&mdev->data.work, w);\r\n} else {\r\ndev_err(DEV, "kmalloc(w) failed.");\r\nov_oos_print(mdev);\r\ndrbd_resync_finished(mdev);\r\n}\r\n}\r\nput_ldev(mdev);\r\nreturn true;\r\n}\r\nstatic int got_skip(struct drbd_conf *mdev, struct p_header80 *h)\r\n{\r\nreturn true;\r\n}\r\nstatic struct asender_cmd *get_asender_cmd(int cmd)\r\n{\r\nstatic struct asender_cmd asender_tbl[] = {\r\n[P_PING] = { sizeof(struct p_header80), got_Ping },\r\n[P_PING_ACK] = { sizeof(struct p_header80), got_PingAck },\r\n[P_RECV_ACK] = { sizeof(struct p_block_ack), got_BlockAck },\r\n[P_WRITE_ACK] = { sizeof(struct p_block_ack), got_BlockAck },\r\n[P_RS_WRITE_ACK] = { sizeof(struct p_block_ack), got_BlockAck },\r\n[P_DISCARD_ACK] = { sizeof(struct p_block_ack), got_BlockAck },\r\n[P_NEG_ACK] = { sizeof(struct p_block_ack), got_NegAck },\r\n[P_NEG_DREPLY] = { sizeof(struct p_block_ack), got_NegDReply },\r\n[P_NEG_RS_DREPLY] = { sizeof(struct p_block_ack), got_NegRSDReply},\r\n[P_OV_RESULT] = { sizeof(struct p_block_ack), got_OVResult },\r\n[P_BARRIER_ACK] = { sizeof(struct p_barrier_ack), got_BarrierAck },\r\n[P_STATE_CHG_REPLY] = { sizeof(struct p_req_state_reply), got_RqSReply },\r\n[P_RS_IS_IN_SYNC] = { sizeof(struct p_block_ack), got_IsInSync },\r\n[P_DELAY_PROBE] = { sizeof(struct p_delay_probe93), got_skip },\r\n[P_RS_CANCEL] = { sizeof(struct p_block_ack), got_NegRSDReply},\r\n[P_MAX_CMD] = { 0, NULL },\r\n};\r\nif (cmd > P_MAX_CMD || asender_tbl[cmd].process == NULL)\r\nreturn NULL;\r\nreturn &asender_tbl[cmd];\r\n}\r\nint drbd_asender(struct drbd_thread *thi)\r\n{\r\nstruct drbd_conf *mdev = thi->mdev;\r\nstruct p_header80 *h = &mdev->meta.rbuf.header.h80;\r\nstruct asender_cmd *cmd = NULL;\r\nint rv, len;\r\nvoid *buf = h;\r\nint received = 0;\r\nint expect = sizeof(struct p_header80);\r\nint empty;\r\nint ping_timeout_active = 0;\r\nsprintf(current->comm, "drbd%d_asender", mdev_to_minor(mdev));\r\ncurrent->policy = SCHED_RR;\r\ncurrent->rt_priority = 2;\r\nwhile (get_t_state(thi) == Running) {\r\ndrbd_thread_current_set_cpu(mdev);\r\nif (test_and_clear_bit(SEND_PING, &mdev->flags)) {\r\nERR_IF(!drbd_send_ping(mdev)) goto reconnect;\r\nmdev->meta.socket->sk->sk_rcvtimeo =\r\nmdev->net_conf->ping_timeo*HZ/10;\r\nping_timeout_active = 1;\r\n}\r\nif (!mdev->net_conf->no_cork &&\r\n3 < atomic_read(&mdev->unacked_cnt))\r\ndrbd_tcp_cork(mdev->meta.socket);\r\nwhile (1) {\r\nclear_bit(SIGNAL_ASENDER, &mdev->flags);\r\nflush_signals(current);\r\nif (!drbd_process_done_ee(mdev))\r\ngoto reconnect;\r\nset_bit(SIGNAL_ASENDER, &mdev->flags);\r\nspin_lock_irq(&mdev->req_lock);\r\nempty = list_empty(&mdev->done_ee);\r\nspin_unlock_irq(&mdev->req_lock);\r\nif (empty)\r\nbreak;\r\n}\r\nif (!mdev->net_conf->no_cork)\r\ndrbd_tcp_uncork(mdev->meta.socket);\r\nif (signal_pending(current))\r\ncontinue;\r\nrv = drbd_recv_short(mdev, mdev->meta.socket,\r\nbuf, expect-received, 0);\r\nclear_bit(SIGNAL_ASENDER, &mdev->flags);\r\nflush_signals(current);\r\nif (likely(rv > 0)) {\r\nreceived += rv;\r\nbuf += rv;\r\n} else if (rv == 0) {\r\ndev_err(DEV, "meta connection shut down by peer.\n");\r\ngoto reconnect;\r\n} else if (rv == -EAGAIN) {\r\nif (time_after(mdev->last_received,\r\njiffies - mdev->meta.socket->sk->sk_rcvtimeo))\r\ncontinue;\r\nif (ping_timeout_active) {\r\ndev_err(DEV, "PingAck did not arrive in time.\n");\r\ngoto reconnect;\r\n}\r\nset_bit(SEND_PING, &mdev->flags);\r\ncontinue;\r\n} else if (rv == -EINTR) {\r\ncontinue;\r\n} else {\r\ndev_err(DEV, "sock_recvmsg returned %d\n", rv);\r\ngoto reconnect;\r\n}\r\nif (received == expect && cmd == NULL) {\r\nif (unlikely(h->magic != BE_DRBD_MAGIC)) {\r\ndev_err(DEV, "magic?? on meta m: 0x%08x c: %d l: %d\n",\r\nbe32_to_cpu(h->magic),\r\nbe16_to_cpu(h->command),\r\nbe16_to_cpu(h->length));\r\ngoto reconnect;\r\n}\r\ncmd = get_asender_cmd(be16_to_cpu(h->command));\r\nlen = be16_to_cpu(h->length);\r\nif (unlikely(cmd == NULL)) {\r\ndev_err(DEV, "unknown command?? on meta m: 0x%08x c: %d l: %d\n",\r\nbe32_to_cpu(h->magic),\r\nbe16_to_cpu(h->command),\r\nbe16_to_cpu(h->length));\r\ngoto disconnect;\r\n}\r\nexpect = cmd->pkt_size;\r\nERR_IF(len != expect-sizeof(struct p_header80))\r\ngoto reconnect;\r\n}\r\nif (received == expect) {\r\nmdev->last_received = jiffies;\r\nD_ASSERT(cmd != NULL);\r\nif (!cmd->process(mdev, h))\r\ngoto reconnect;\r\nif (cmd == get_asender_cmd(P_PING_ACK))\r\nping_timeout_active = 0;\r\nbuf = h;\r\nreceived = 0;\r\nexpect = sizeof(struct p_header80);\r\ncmd = NULL;\r\n}\r\n}\r\nif (0) {\r\nreconnect:\r\ndrbd_force_state(mdev, NS(conn, C_NETWORK_FAILURE));\r\ndrbd_md_sync(mdev);\r\n}\r\nif (0) {\r\ndisconnect:\r\ndrbd_force_state(mdev, NS(conn, C_DISCONNECTING));\r\ndrbd_md_sync(mdev);\r\n}\r\nclear_bit(SIGNAL_ASENDER, &mdev->flags);\r\nD_ASSERT(mdev->state.conn < C_CONNECTED);\r\ndev_info(DEV, "asender terminated\n");\r\nreturn 0;\r\n}
