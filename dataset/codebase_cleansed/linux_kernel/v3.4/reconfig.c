static void add_node_proc_entries(struct device_node *np)\r\n{\r\nstruct proc_dir_entry *ent;\r\nent = proc_mkdir(strrchr(np->full_name, '/') + 1, np->parent->pde);\r\nif (ent)\r\nproc_device_tree_add_node(np, ent);\r\n}\r\nstatic void remove_node_proc_entries(struct device_node *np)\r\n{\r\nstruct property *pp = np->properties;\r\nstruct device_node *parent = np->parent;\r\nwhile (pp) {\r\nremove_proc_entry(pp->name, np->pde);\r\npp = pp->next;\r\n}\r\nif (np->pde)\r\nremove_proc_entry(np->pde->name, parent->pde);\r\n}\r\nstatic void add_node_proc_entries(struct device_node *np)\r\n{\r\nreturn;\r\n}\r\nstatic void remove_node_proc_entries(struct device_node *np)\r\n{\r\nreturn;\r\n}\r\nstatic struct device_node *derive_parent(const char *path)\r\n{\r\nstruct device_node *parent = NULL;\r\nchar *parent_path = "/";\r\nsize_t parent_path_len = strrchr(path, '/') - path + 1;\r\nif (!strcmp(path, "/"))\r\nreturn ERR_PTR(-EINVAL);\r\nif (strrchr(path, '/') != path) {\r\nparent_path = kmalloc(parent_path_len, GFP_KERNEL);\r\nif (!parent_path)\r\nreturn ERR_PTR(-ENOMEM);\r\nstrlcpy(parent_path, path, parent_path_len);\r\n}\r\nparent = of_find_node_by_path(parent_path);\r\nif (!parent)\r\nreturn ERR_PTR(-EINVAL);\r\nif (strcmp(parent_path, "/"))\r\nkfree(parent_path);\r\nreturn parent;\r\n}\r\nint pSeries_reconfig_notifier_register(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_register(&pSeries_reconfig_chain, nb);\r\n}\r\nvoid pSeries_reconfig_notifier_unregister(struct notifier_block *nb)\r\n{\r\nblocking_notifier_chain_unregister(&pSeries_reconfig_chain, nb);\r\n}\r\nint pSeries_reconfig_notify(unsigned long action, void *p)\r\n{\r\nint err = blocking_notifier_call_chain(&pSeries_reconfig_chain,\r\naction, p);\r\nreturn notifier_to_errno(err);\r\n}\r\nstatic int pSeries_reconfig_add_node(const char *path, struct property *proplist)\r\n{\r\nstruct device_node *np;\r\nint err = -ENOMEM;\r\nnp = kzalloc(sizeof(*np), GFP_KERNEL);\r\nif (!np)\r\ngoto out_err;\r\nnp->full_name = kstrdup(path, GFP_KERNEL);\r\nif (!np->full_name)\r\ngoto out_err;\r\nnp->properties = proplist;\r\nof_node_set_flag(np, OF_DYNAMIC);\r\nkref_init(&np->kref);\r\nnp->parent = derive_parent(path);\r\nif (IS_ERR(np->parent)) {\r\nerr = PTR_ERR(np->parent);\r\ngoto out_err;\r\n}\r\nerr = pSeries_reconfig_notify(PSERIES_RECONFIG_ADD, np);\r\nif (err) {\r\nprintk(KERN_ERR "Failed to add device node %s\n", path);\r\ngoto out_err;\r\n}\r\nof_attach_node(np);\r\nadd_node_proc_entries(np);\r\nof_node_put(np->parent);\r\nreturn 0;\r\nout_err:\r\nif (np) {\r\nof_node_put(np->parent);\r\nkfree(np->full_name);\r\nkfree(np);\r\n}\r\nreturn err;\r\n}\r\nstatic int pSeries_reconfig_remove_node(struct device_node *np)\r\n{\r\nstruct device_node *parent, *child;\r\nparent = of_get_parent(np);\r\nif (!parent)\r\nreturn -EINVAL;\r\nif ((child = of_get_next_child(np, NULL))) {\r\nof_node_put(child);\r\nof_node_put(parent);\r\nreturn -EBUSY;\r\n}\r\nremove_node_proc_entries(np);\r\npSeries_reconfig_notify(PSERIES_RECONFIG_REMOVE, np);\r\nof_detach_node(np);\r\nof_node_put(parent);\r\nof_node_put(np);\r\nreturn 0;\r\n}\r\nstatic void release_prop_list(const struct property *prop)\r\n{\r\nstruct property *next;\r\nfor (; prop; prop = next) {\r\nnext = prop->next;\r\nkfree(prop->name);\r\nkfree(prop->value);\r\nkfree(prop);\r\n}\r\n}\r\nstatic char * parse_next_property(char *buf, char *end, char **name, int *length,\r\nunsigned char **value)\r\n{\r\nchar *tmp;\r\n*name = buf;\r\ntmp = strchr(buf, ' ');\r\nif (!tmp) {\r\nprintk(KERN_ERR "property parse failed in %s at line %d\n",\r\n__func__, __LINE__);\r\nreturn NULL;\r\n}\r\n*tmp = '\0';\r\nif (++tmp >= end) {\r\nprintk(KERN_ERR "property parse failed in %s at line %d\n",\r\n__func__, __LINE__);\r\nreturn NULL;\r\n}\r\n*length = -1;\r\n*length = simple_strtoul(tmp, &tmp, 10);\r\nif (*length == -1) {\r\nprintk(KERN_ERR "property parse failed in %s at line %d\n",\r\n__func__, __LINE__);\r\nreturn NULL;\r\n}\r\nif (*tmp != ' ' || ++tmp >= end) {\r\nprintk(KERN_ERR "property parse failed in %s at line %d\n",\r\n__func__, __LINE__);\r\nreturn NULL;\r\n}\r\n*value = tmp;\r\ntmp += *length;\r\nif (tmp > end) {\r\nprintk(KERN_ERR "property parse failed in %s at line %d\n",\r\n__func__, __LINE__);\r\nreturn NULL;\r\n}\r\nelse if (tmp < end && *tmp != ' ' && *tmp != '\0') {\r\nprintk(KERN_ERR "property parse failed in %s at line %d\n",\r\n__func__, __LINE__);\r\nreturn NULL;\r\n}\r\ntmp++;\r\nreturn tmp;\r\n}\r\nstatic struct property *new_property(const char *name, const int length,\r\nconst unsigned char *value, struct property *last)\r\n{\r\nstruct property *new = kzalloc(sizeof(*new), GFP_KERNEL);\r\nif (!new)\r\nreturn NULL;\r\nif (!(new->name = kmalloc(strlen(name) + 1, GFP_KERNEL)))\r\ngoto cleanup;\r\nif (!(new->value = kmalloc(length + 1, GFP_KERNEL)))\r\ngoto cleanup;\r\nstrcpy(new->name, name);\r\nmemcpy(new->value, value, length);\r\n*(((char *)new->value) + length) = 0;\r\nnew->length = length;\r\nnew->next = last;\r\nreturn new;\r\ncleanup:\r\nkfree(new->name);\r\nkfree(new->value);\r\nkfree(new);\r\nreturn NULL;\r\n}\r\nstatic int do_add_node(char *buf, size_t bufsize)\r\n{\r\nchar *path, *end, *name;\r\nstruct device_node *np;\r\nstruct property *prop = NULL;\r\nunsigned char* value;\r\nint length, rv = 0;\r\nend = buf + bufsize;\r\npath = buf;\r\nbuf = strchr(buf, ' ');\r\nif (!buf)\r\nreturn -EINVAL;\r\n*buf = '\0';\r\nbuf++;\r\nif ((np = of_find_node_by_path(path))) {\r\nof_node_put(np);\r\nreturn -EINVAL;\r\n}\r\nwhile (buf < end &&\r\n(buf = parse_next_property(buf, end, &name, &length, &value))) {\r\nstruct property *last = prop;\r\nprop = new_property(name, length, value, last);\r\nif (!prop) {\r\nrv = -ENOMEM;\r\nprop = last;\r\ngoto out;\r\n}\r\n}\r\nif (!buf) {\r\nrv = -EINVAL;\r\ngoto out;\r\n}\r\nrv = pSeries_reconfig_add_node(path, prop);\r\nout:\r\nif (rv)\r\nrelease_prop_list(prop);\r\nreturn rv;\r\n}\r\nstatic int do_remove_node(char *buf)\r\n{\r\nstruct device_node *node;\r\nint rv = -ENODEV;\r\nif ((node = of_find_node_by_path(buf)))\r\nrv = pSeries_reconfig_remove_node(node);\r\nof_node_put(node);\r\nreturn rv;\r\n}\r\nstatic char *parse_node(char *buf, size_t bufsize, struct device_node **npp)\r\n{\r\nchar *handle_str;\r\nphandle handle;\r\n*npp = NULL;\r\nhandle_str = buf;\r\nbuf = strchr(buf, ' ');\r\nif (!buf)\r\nreturn NULL;\r\n*buf = '\0';\r\nbuf++;\r\nhandle = simple_strtoul(handle_str, NULL, 0);\r\n*npp = of_find_node_by_phandle(handle);\r\nreturn buf;\r\n}\r\nstatic int do_add_property(char *buf, size_t bufsize)\r\n{\r\nstruct property *prop = NULL;\r\nstruct device_node *np;\r\nunsigned char *value;\r\nchar *name, *end;\r\nint length;\r\nend = buf + bufsize;\r\nbuf = parse_node(buf, bufsize, &np);\r\nif (!np)\r\nreturn -ENODEV;\r\nif (parse_next_property(buf, end, &name, &length, &value) == NULL)\r\nreturn -EINVAL;\r\nprop = new_property(name, length, value, NULL);\r\nif (!prop)\r\nreturn -ENOMEM;\r\nprom_add_property(np, prop);\r\nreturn 0;\r\n}\r\nstatic int do_remove_property(char *buf, size_t bufsize)\r\n{\r\nstruct device_node *np;\r\nchar *tmp;\r\nstruct property *prop;\r\nbuf = parse_node(buf, bufsize, &np);\r\nif (!np)\r\nreturn -ENODEV;\r\ntmp = strchr(buf,' ');\r\nif (tmp)\r\n*tmp = '\0';\r\nif (strlen(buf) == 0)\r\nreturn -EINVAL;\r\nprop = of_find_property(np, buf, NULL);\r\nreturn prom_remove_property(np, prop);\r\n}\r\nstatic int do_update_property(char *buf, size_t bufsize)\r\n{\r\nstruct device_node *np;\r\nunsigned char *value;\r\nchar *name, *end, *next_prop;\r\nint rc, length;\r\nstruct property *newprop, *oldprop;\r\nbuf = parse_node(buf, bufsize, &np);\r\nend = buf + bufsize;\r\nif (!np)\r\nreturn -ENODEV;\r\nnext_prop = parse_next_property(buf, end, &name, &length, &value);\r\nif (!next_prop)\r\nreturn -EINVAL;\r\nnewprop = new_property(name, length, value, NULL);\r\nif (!newprop)\r\nreturn -ENOMEM;\r\nif (!strcmp(name, "slb-size") || !strcmp(name, "ibm,slb-size"))\r\nslb_set_size(*(int *)value);\r\noldprop = of_find_property(np, name,NULL);\r\nif (!oldprop) {\r\nif (strlen(name))\r\nreturn prom_add_property(np, newprop);\r\nreturn -ENODEV;\r\n}\r\nrc = prom_update_property(np, newprop, oldprop);\r\nif (rc)\r\nreturn rc;\r\nif (!strcmp(name, "ibm,dynamic-memory")) {\r\nint action;\r\nnext_prop = parse_next_property(next_prop, end, &name,\r\n&length, &value);\r\nif (!next_prop)\r\nreturn -EINVAL;\r\nif (!strcmp(name, "add"))\r\naction = PSERIES_DRCONF_MEM_ADD;\r\nelse\r\naction = PSERIES_DRCONF_MEM_REMOVE;\r\nrc = pSeries_reconfig_notify(action, value);\r\nif (rc) {\r\nprom_update_property(np, oldprop, newprop);\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t ofdt_write(struct file *file, const char __user *buf, size_t count,\r\nloff_t *off)\r\n{\r\nint rv = 0;\r\nchar *kbuf;\r\nchar *tmp;\r\nif (!(kbuf = kmalloc(count + 1, GFP_KERNEL))) {\r\nrv = -ENOMEM;\r\ngoto out;\r\n}\r\nif (copy_from_user(kbuf, buf, count)) {\r\nrv = -EFAULT;\r\ngoto out;\r\n}\r\nkbuf[count] = '\0';\r\ntmp = strchr(kbuf, ' ');\r\nif (!tmp) {\r\nrv = -EINVAL;\r\ngoto out;\r\n}\r\n*tmp = '\0';\r\ntmp++;\r\nif (!strcmp(kbuf, "add_node"))\r\nrv = do_add_node(tmp, count - (tmp - kbuf));\r\nelse if (!strcmp(kbuf, "remove_node"))\r\nrv = do_remove_node(tmp);\r\nelse if (!strcmp(kbuf, "add_property"))\r\nrv = do_add_property(tmp, count - (tmp - kbuf));\r\nelse if (!strcmp(kbuf, "remove_property"))\r\nrv = do_remove_property(tmp, count - (tmp - kbuf));\r\nelse if (!strcmp(kbuf, "update_property"))\r\nrv = do_update_property(tmp, count - (tmp - kbuf));\r\nelse\r\nrv = -EINVAL;\r\nout:\r\nkfree(kbuf);\r\nreturn rv ? rv : count;\r\n}\r\nstatic int proc_ppc64_create_ofdt(void)\r\n{\r\nstruct proc_dir_entry *ent;\r\nif (!machine_is(pseries))\r\nreturn 0;\r\nent = proc_create("powerpc/ofdt", S_IWUSR, NULL, &ofdt_fops);\r\nif (ent)\r\nent->size = 0;\r\nreturn 0;\r\n}
