static int idmouse_create_image(struct usb_idmouse *dev)\r\n{\r\nint bytes_read;\r\nint bulk_read;\r\nint result;\r\nmemcpy(dev->bulk_in_buffer, HEADER, sizeof(HEADER)-1);\r\nbytes_read = sizeof(HEADER)-1;\r\nresult = ftip_command(dev, FTIP_RELEASE, 0, 0);\r\nif (result < 0)\r\ngoto reset;\r\nresult = ftip_command(dev, FTIP_BLINK, 1, 0);\r\nif (result < 0)\r\ngoto reset;\r\nresult = ftip_command(dev, FTIP_ACQUIRE, 0, 0);\r\nif (result < 0)\r\ngoto reset;\r\nresult = ftip_command(dev, FTIP_ACQUIRE, 0, 0);\r\nif (result < 0)\r\ngoto reset;\r\nresult = ftip_command(dev, FTIP_RESET, 0, 0);\r\nif (result < 0)\r\ngoto reset;\r\nresult = ftip_command(dev, FTIP_RESET, 0, 0);\r\nif (result < 0)\r\ngoto reset;\r\nwhile (bytes_read < IMGSIZE) {\r\nresult = usb_bulk_msg (dev->udev,\r\nusb_rcvbulkpipe (dev->udev, dev->bulk_in_endpointAddr),\r\ndev->bulk_in_buffer + bytes_read,\r\ndev->bulk_in_size, &bulk_read, 5000);\r\nif (result < 0) {\r\nif (dev->bulk_in_size != dev->orig_bi_size) {\r\ndev->bulk_in_size = dev->orig_bi_size;\r\nresult = -EAGAIN;\r\n}\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nresult = -EINTR;\r\nbreak;\r\n}\r\nbytes_read += bulk_read;\r\n}\r\nreset:\r\nftip_command(dev, FTIP_RELEASE, 0, 0);\r\nfor (bytes_read = sizeof(HEADER)-1 + WIDTH-1; bytes_read < IMGSIZE; bytes_read += WIDTH)\r\nif (dev->bulk_in_buffer[bytes_read] != 0x00)\r\nreturn -EAGAIN;\r\nfor (bytes_read = IMGSIZE-WIDTH; bytes_read < IMGSIZE-1; bytes_read++)\r\nif (dev->bulk_in_buffer[bytes_read] != 0xFF)\r\nreturn -EAGAIN;\r\ndbg("read %d bytes fingerprint data", bytes_read);\r\nreturn result;\r\n}\r\nstatic int idmouse_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nreturn 0;\r\n}\r\nstatic int idmouse_resume(struct usb_interface *intf)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void idmouse_delete(struct usb_idmouse *dev)\r\n{\r\nkfree(dev->bulk_in_buffer);\r\nkfree(dev);\r\n}\r\nstatic int idmouse_open(struct inode *inode, struct file *file)\r\n{\r\nstruct usb_idmouse *dev;\r\nstruct usb_interface *interface;\r\nint result;\r\ninterface = usb_find_interface (&idmouse_driver, iminor (inode));\r\nif (!interface)\r\nreturn -ENODEV;\r\nmutex_lock(&open_disc_mutex);\r\ndev = usb_get_intfdata(interface);\r\nif (!dev) {\r\nmutex_unlock(&open_disc_mutex);\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&dev->lock);\r\nmutex_unlock(&open_disc_mutex);\r\nif (dev->open) {\r\nresult = -EBUSY;\r\n} else {\r\nresult = usb_autopm_get_interface(interface);\r\nif (result)\r\ngoto error;\r\nresult = idmouse_create_image (dev);\r\nif (result)\r\ngoto error;\r\nusb_autopm_put_interface(interface);\r\n++dev->open;\r\nfile->private_data = dev;\r\n}\r\nerror:\r\nmutex_unlock(&dev->lock);\r\nreturn result;\r\n}\r\nstatic int idmouse_release(struct inode *inode, struct file *file)\r\n{\r\nstruct usb_idmouse *dev;\r\ndev = file->private_data;\r\nif (dev == NULL)\r\nreturn -ENODEV;\r\nmutex_lock(&open_disc_mutex);\r\nmutex_lock(&dev->lock);\r\nif (dev->open <= 0) {\r\nmutex_unlock(&dev->lock);\r\nmutex_unlock(&open_disc_mutex);\r\nreturn -ENODEV;\r\n}\r\n--dev->open;\r\nif (!dev->present) {\r\nmutex_unlock(&dev->lock);\r\nmutex_unlock(&open_disc_mutex);\r\nidmouse_delete(dev);\r\n} else {\r\nmutex_unlock(&dev->lock);\r\nmutex_unlock(&open_disc_mutex);\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t idmouse_read(struct file *file, char __user *buffer, size_t count,\r\nloff_t * ppos)\r\n{\r\nstruct usb_idmouse *dev = file->private_data;\r\nint result;\r\nmutex_lock(&dev->lock);\r\nif (!dev->present) {\r\nmutex_unlock(&dev->lock);\r\nreturn -ENODEV;\r\n}\r\nresult = simple_read_from_buffer(buffer, count, ppos,\r\ndev->bulk_in_buffer, IMGSIZE);\r\nmutex_unlock(&dev->lock);\r\nreturn result;\r\n}\r\nstatic int idmouse_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nstruct usb_idmouse *dev;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint result;\r\niface_desc = &interface->altsetting[0];\r\nif (iface_desc->desc.bInterfaceClass != 0x0A)\r\nreturn -ENODEV;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL)\r\nreturn -ENOMEM;\r\nmutex_init(&dev->lock);\r\ndev->udev = udev;\r\ndev->interface = interface;\r\nendpoint = &iface_desc->endpoint[0].desc;\r\nif (!dev->bulk_in_endpointAddr && usb_endpoint_is_bulk_in(endpoint)) {\r\ndev->orig_bi_size = usb_endpoint_maxp(endpoint);\r\ndev->bulk_in_size = 0x200;\r\ndev->bulk_in_endpointAddr = endpoint->bEndpointAddress;\r\ndev->bulk_in_buffer =\r\nkmalloc(IMGSIZE + dev->bulk_in_size, GFP_KERNEL);\r\nif (!dev->bulk_in_buffer) {\r\nerr("Unable to allocate input buffer.");\r\nidmouse_delete(dev);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (!(dev->bulk_in_endpointAddr)) {\r\nerr("Unable to find bulk-in endpoint.");\r\nidmouse_delete(dev);\r\nreturn -ENODEV;\r\n}\r\ndev->present = 1;\r\nusb_set_intfdata(interface, dev);\r\nresult = usb_register_dev(interface, &idmouse_class);\r\nif (result) {\r\nerr("Unble to allocate minor number.");\r\nusb_set_intfdata(interface, NULL);\r\nidmouse_delete(dev);\r\nreturn result;\r\n}\r\ndev_info(&interface->dev,"%s now attached\n",DRIVER_DESC);\r\nreturn 0;\r\n}\r\nstatic void idmouse_disconnect(struct usb_interface *interface)\r\n{\r\nstruct usb_idmouse *dev;\r\ndev = usb_get_intfdata(interface);\r\nusb_deregister_dev(interface, &idmouse_class);\r\nmutex_lock(&open_disc_mutex);\r\nusb_set_intfdata(interface, NULL);\r\nmutex_lock(&dev->lock);\r\nmutex_unlock(&open_disc_mutex);\r\ndev->present = 0;\r\nif (!dev->open) {\r\nmutex_unlock(&dev->lock);\r\nidmouse_delete(dev);\r\n} else {\r\nmutex_unlock(&dev->lock);\r\n}\r\ndev_info(&interface->dev, "disconnected\n");\r\n}
