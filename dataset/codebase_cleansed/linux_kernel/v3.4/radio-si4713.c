static int radio_si4713_fill_audout(struct v4l2_audioout *vao)\r\n{\r\nstrlcpy(vao->name, "FM Modulator Audio Out", 32);\r\nreturn 0;\r\n}\r\nstatic int radio_si4713_enumaudout(struct file *file, void *priv,\r\nstruct v4l2_audioout *vao)\r\n{\r\nreturn radio_si4713_fill_audout(vao);\r\n}\r\nstatic int radio_si4713_g_audout(struct file *file, void *priv,\r\nstruct v4l2_audioout *vao)\r\n{\r\nint rval = radio_si4713_fill_audout(vao);\r\nvao->index = 0;\r\nreturn rval;\r\n}\r\nstatic int radio_si4713_s_audout(struct file *file, void *priv,\r\nstruct v4l2_audioout *vao)\r\n{\r\nreturn vao->index ? -EINVAL : 0;\r\n}\r\nstatic int radio_si4713_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *capability)\r\n{\r\nstrlcpy(capability->driver, "radio-si4713", sizeof(capability->driver));\r\nstrlcpy(capability->card, "Silicon Labs Si4713 Modulator",\r\nsizeof(capability->card));\r\ncapability->capabilities = V4L2_CAP_MODULATOR | V4L2_CAP_RDS_OUTPUT;\r\nreturn 0;\r\n}\r\nstatic int radio_si4713_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nstatic const u32 user_ctrls[] = {\r\nV4L2_CID_USER_CLASS,\r\nV4L2_CID_AUDIO_MUTE,\r\n0\r\n};\r\nstatic const u32 fmtx_ctrls[] = {\r\nV4L2_CID_FM_TX_CLASS,\r\nV4L2_CID_RDS_TX_DEVIATION,\r\nV4L2_CID_RDS_TX_PI,\r\nV4L2_CID_RDS_TX_PTY,\r\nV4L2_CID_RDS_TX_PS_NAME,\r\nV4L2_CID_RDS_TX_RADIO_TEXT,\r\nV4L2_CID_AUDIO_LIMITER_ENABLED,\r\nV4L2_CID_AUDIO_LIMITER_RELEASE_TIME,\r\nV4L2_CID_AUDIO_LIMITER_DEVIATION,\r\nV4L2_CID_AUDIO_COMPRESSION_ENABLED,\r\nV4L2_CID_AUDIO_COMPRESSION_GAIN,\r\nV4L2_CID_AUDIO_COMPRESSION_THRESHOLD,\r\nV4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME,\r\nV4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME,\r\nV4L2_CID_PILOT_TONE_ENABLED,\r\nV4L2_CID_PILOT_TONE_DEVIATION,\r\nV4L2_CID_PILOT_TONE_FREQUENCY,\r\nV4L2_CID_TUNE_PREEMPHASIS,\r\nV4L2_CID_TUNE_POWER_LEVEL,\r\nV4L2_CID_TUNE_ANTENNA_CAPACITOR,\r\n0\r\n};\r\nstatic const u32 *ctrl_classes[] = {\r\nuser_ctrls,\r\nfmtx_ctrls,\r\nNULL\r\n};\r\nstruct radio_si4713_device *rsdev;\r\nrsdev = video_get_drvdata(video_devdata(file));\r\nqc->id = v4l2_ctrl_next(ctrl_classes, qc->id);\r\nif (qc->id == 0)\r\nreturn -EINVAL;\r\nif (qc->id == V4L2_CID_USER_CLASS || qc->id == V4L2_CID_FM_TX_CLASS)\r\nreturn v4l2_ctrl_query_fill(qc, 0, 0, 0, 0);\r\nreturn v4l2_device_call_until_err(&rsdev->v4l2_dev, 0, core,\r\nqueryctrl, qc);\r\n}\r\nstatic inline struct v4l2_device *get_v4l2_dev(struct file *file)\r\n{\r\nreturn &((struct radio_si4713_device *)video_drvdata(file))->v4l2_dev;\r\n}\r\nstatic int radio_si4713_g_ext_ctrls(struct file *file, void *p,\r\nstruct v4l2_ext_controls *vecs)\r\n{\r\nreturn v4l2_device_call_until_err(get_v4l2_dev(file), 0, core,\r\ng_ext_ctrls, vecs);\r\n}\r\nstatic int radio_si4713_s_ext_ctrls(struct file *file, void *p,\r\nstruct v4l2_ext_controls *vecs)\r\n{\r\nreturn v4l2_device_call_until_err(get_v4l2_dev(file), 0, core,\r\ns_ext_ctrls, vecs);\r\n}\r\nstatic int radio_si4713_g_ctrl(struct file *file, void *p,\r\nstruct v4l2_control *vc)\r\n{\r\nreturn v4l2_device_call_until_err(get_v4l2_dev(file), 0, core,\r\ng_ctrl, vc);\r\n}\r\nstatic int radio_si4713_s_ctrl(struct file *file, void *p,\r\nstruct v4l2_control *vc)\r\n{\r\nreturn v4l2_device_call_until_err(get_v4l2_dev(file), 0, core,\r\ns_ctrl, vc);\r\n}\r\nstatic int radio_si4713_g_modulator(struct file *file, void *p,\r\nstruct v4l2_modulator *vm)\r\n{\r\nreturn v4l2_device_call_until_err(get_v4l2_dev(file), 0, tuner,\r\ng_modulator, vm);\r\n}\r\nstatic int radio_si4713_s_modulator(struct file *file, void *p,\r\nstruct v4l2_modulator *vm)\r\n{\r\nreturn v4l2_device_call_until_err(get_v4l2_dev(file), 0, tuner,\r\ns_modulator, vm);\r\n}\r\nstatic int radio_si4713_g_frequency(struct file *file, void *p,\r\nstruct v4l2_frequency *vf)\r\n{\r\nreturn v4l2_device_call_until_err(get_v4l2_dev(file), 0, tuner,\r\ng_frequency, vf);\r\n}\r\nstatic int radio_si4713_s_frequency(struct file *file, void *p,\r\nstruct v4l2_frequency *vf)\r\n{\r\nreturn v4l2_device_call_until_err(get_v4l2_dev(file), 0, tuner,\r\ns_frequency, vf);\r\n}\r\nstatic long radio_si4713_default(struct file *file, void *p,\r\nbool valid_prio, int cmd, void *arg)\r\n{\r\nreturn v4l2_device_call_until_err(get_v4l2_dev(file), 0, core,\r\nioctl, cmd, arg);\r\n}\r\nstatic int radio_si4713_pdriver_probe(struct platform_device *pdev)\r\n{\r\nstruct radio_si4713_platform_data *pdata = pdev->dev.platform_data;\r\nstruct radio_si4713_device *rsdev;\r\nstruct i2c_adapter *adapter;\r\nstruct v4l2_subdev *sd;\r\nint rval = 0;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "Cannot proceed without platform data.\n");\r\nrval = -EINVAL;\r\ngoto exit;\r\n}\r\nrsdev = kzalloc(sizeof *rsdev, GFP_KERNEL);\r\nif (!rsdev) {\r\ndev_err(&pdev->dev, "Failed to alloc video device.\n");\r\nrval = -ENOMEM;\r\ngoto exit;\r\n}\r\nrval = v4l2_device_register(&pdev->dev, &rsdev->v4l2_dev);\r\nif (rval) {\r\ndev_err(&pdev->dev, "Failed to register v4l2 device.\n");\r\ngoto free_rsdev;\r\n}\r\nadapter = i2c_get_adapter(pdata->i2c_bus);\r\nif (!adapter) {\r\ndev_err(&pdev->dev, "Cannot get i2c adapter %d\n",\r\npdata->i2c_bus);\r\nrval = -ENODEV;\r\ngoto unregister_v4l2_dev;\r\n}\r\nsd = v4l2_i2c_new_subdev_board(&rsdev->v4l2_dev, adapter,\r\npdata->subdev_board_info, NULL);\r\nif (!sd) {\r\ndev_err(&pdev->dev, "Cannot get v4l2 subdevice\n");\r\nrval = -ENODEV;\r\ngoto put_adapter;\r\n}\r\nrsdev->radio_dev = video_device_alloc();\r\nif (!rsdev->radio_dev) {\r\ndev_err(&pdev->dev, "Failed to alloc video device.\n");\r\nrval = -ENOMEM;\r\ngoto put_adapter;\r\n}\r\nmemcpy(rsdev->radio_dev, &radio_si4713_vdev_template,\r\nsizeof(radio_si4713_vdev_template));\r\nvideo_set_drvdata(rsdev->radio_dev, rsdev);\r\nif (video_register_device(rsdev->radio_dev, VFL_TYPE_RADIO, radio_nr)) {\r\ndev_err(&pdev->dev, "Could not register video device.\n");\r\nrval = -EIO;\r\ngoto free_vdev;\r\n}\r\ndev_info(&pdev->dev, "New device successfully probed\n");\r\ngoto exit;\r\nfree_vdev:\r\nvideo_device_release(rsdev->radio_dev);\r\nput_adapter:\r\ni2c_put_adapter(adapter);\r\nunregister_v4l2_dev:\r\nv4l2_device_unregister(&rsdev->v4l2_dev);\r\nfree_rsdev:\r\nkfree(rsdev);\r\nexit:\r\nreturn rval;\r\n}\r\nstatic int __exit radio_si4713_pdriver_remove(struct platform_device *pdev)\r\n{\r\nstruct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);\r\nstruct radio_si4713_device *rsdev = container_of(v4l2_dev,\r\nstruct radio_si4713_device,\r\nv4l2_dev);\r\nstruct v4l2_subdev *sd = list_entry(v4l2_dev->subdevs.next,\r\nstruct v4l2_subdev, list);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nvideo_unregister_device(rsdev->radio_dev);\r\ni2c_put_adapter(client->adapter);\r\nv4l2_device_unregister(&rsdev->v4l2_dev);\r\nkfree(rsdev);\r\nreturn 0;\r\n}
