asmlinkage int sys32_execve(nabi_no_regargs struct pt_regs regs)\r\n{\r\nint error;\r\nchar * filename;\r\nfilename = getname(compat_ptr(regs.regs[4]));\r\nerror = PTR_ERR(filename);\r\nif (IS_ERR(filename))\r\ngoto out;\r\nerror = compat_do_execve(filename, compat_ptr(regs.regs[5]),\r\ncompat_ptr(regs.regs[6]), &regs);\r\nputname(filename);\r\nout:\r\nreturn error;\r\n}\r\nasmlinkage ssize_t sys32_readahead(int fd, u32 pad0, u64 a2, u64 a3,\r\nsize_t count)\r\n{\r\nreturn sys_readahead(fd, merge_64(a2, a3), count);\r\n}\r\nasmlinkage long sys32_sync_file_range(int fd, int __pad,\r\nunsigned long a2, unsigned long a3,\r\nunsigned long a4, unsigned long a5,\r\nint flags)\r\n{\r\nreturn sys_sync_file_range(fd,\r\nmerge_64(a2, a3), merge_64(a4, a5),\r\nflags);\r\n}\r\nasmlinkage long sys32_fadvise64_64(int fd, int __pad,\r\nunsigned long a2, unsigned long a3,\r\nunsigned long a4, unsigned long a5,\r\nint flags)\r\n{\r\nreturn sys_fadvise64_64(fd,\r\nmerge_64(a2, a3), merge_64(a4, a5),\r\nflags);\r\n}\r\nasmlinkage long sys32_fallocate(int fd, int mode, unsigned offset_a2,\r\nunsigned offset_a3, unsigned len_a4, unsigned len_a5)\r\n{\r\nreturn sys_fallocate(fd, mode, merge_64(offset_a2, offset_a3),\r\nmerge_64(len_a4, len_a5));\r\n}\r\nstatic int noinline __used\r\n_sys32_clone(nabi_no_regargs struct pt_regs regs)\r\n{\r\nunsigned long clone_flags;\r\nunsigned long newsp;\r\nint __user *parent_tidptr, *child_tidptr;\r\nclone_flags = regs.regs[4];\r\nnewsp = regs.regs[5];\r\nif (!newsp)\r\nnewsp = regs.regs[29];\r\nparent_tidptr = (int __user *) regs.regs[6];\r\nchild_tidptr = (int __user *) __dummy4;\r\nreturn do_fork(clone_flags, newsp, &regs, 0,\r\nparent_tidptr, child_tidptr);\r\n}\r\nasmlinkage long sys32_lookup_dcookie(u32 a0, u32 a1, char __user *buf,\r\nsize_t len)\r\n{\r\nreturn sys_lookup_dcookie(merge_64(a0, a1), buf, len);\r\n}
