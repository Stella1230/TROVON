static void do_calc_lpt_geom(struct ubifs_info *c)\r\n{\r\nint i, n, bits, per_leb_wastage, max_pnode_cnt;\r\nlong long sz, tot_wastage;\r\nn = c->main_lebs + c->max_leb_cnt - c->leb_cnt;\r\nmax_pnode_cnt = DIV_ROUND_UP(n, UBIFS_LPT_FANOUT);\r\nc->lpt_hght = 1;\r\nn = UBIFS_LPT_FANOUT;\r\nwhile (n < max_pnode_cnt) {\r\nc->lpt_hght += 1;\r\nn <<= UBIFS_LPT_FANOUT_SHIFT;\r\n}\r\nc->pnode_cnt = DIV_ROUND_UP(c->main_lebs, UBIFS_LPT_FANOUT);\r\nn = DIV_ROUND_UP(c->pnode_cnt, UBIFS_LPT_FANOUT);\r\nc->nnode_cnt = n;\r\nfor (i = 1; i < c->lpt_hght; i++) {\r\nn = DIV_ROUND_UP(n, UBIFS_LPT_FANOUT);\r\nc->nnode_cnt += n;\r\n}\r\nc->space_bits = fls(c->leb_size) - 3;\r\nc->lpt_lnum_bits = fls(c->lpt_lebs);\r\nc->lpt_offs_bits = fls(c->leb_size - 1);\r\nc->lpt_spc_bits = fls(c->leb_size);\r\nn = DIV_ROUND_UP(c->max_leb_cnt, UBIFS_LPT_FANOUT);\r\nc->pcnt_bits = fls(n - 1);\r\nc->lnum_bits = fls(c->max_leb_cnt - 1);\r\nbits = UBIFS_LPT_CRC_BITS + UBIFS_LPT_TYPE_BITS +\r\n(c->big_lpt ? c->pcnt_bits : 0) +\r\n(c->space_bits * 2 + 1) * UBIFS_LPT_FANOUT;\r\nc->pnode_sz = (bits + 7) / 8;\r\nbits = UBIFS_LPT_CRC_BITS + UBIFS_LPT_TYPE_BITS +\r\n(c->big_lpt ? c->pcnt_bits : 0) +\r\n(c->lpt_lnum_bits + c->lpt_offs_bits) * UBIFS_LPT_FANOUT;\r\nc->nnode_sz = (bits + 7) / 8;\r\nbits = UBIFS_LPT_CRC_BITS + UBIFS_LPT_TYPE_BITS +\r\nc->lpt_lebs * c->lpt_spc_bits * 2;\r\nc->ltab_sz = (bits + 7) / 8;\r\nbits = UBIFS_LPT_CRC_BITS + UBIFS_LPT_TYPE_BITS +\r\nc->lnum_bits * c->lsave_cnt;\r\nc->lsave_sz = (bits + 7) / 8;\r\nc->lpt_sz = (long long)c->pnode_cnt * c->pnode_sz;\r\nc->lpt_sz += (long long)c->nnode_cnt * c->nnode_sz;\r\nc->lpt_sz += c->ltab_sz;\r\nif (c->big_lpt)\r\nc->lpt_sz += c->lsave_sz;\r\nsz = c->lpt_sz;\r\nper_leb_wastage = max_t(int, c->pnode_sz, c->nnode_sz);\r\nsz += per_leb_wastage;\r\ntot_wastage = per_leb_wastage;\r\nwhile (sz > c->leb_size) {\r\nsz += per_leb_wastage;\r\nsz -= c->leb_size;\r\ntot_wastage += per_leb_wastage;\r\n}\r\ntot_wastage += ALIGN(sz, c->min_io_size) - sz;\r\nc->lpt_sz += tot_wastage;\r\n}\r\nint ubifs_calc_lpt_geom(struct ubifs_info *c)\r\n{\r\nint lebs_needed;\r\nlong long sz;\r\ndo_calc_lpt_geom(c);\r\nsz = c->lpt_sz * 2;\r\nlebs_needed = div_u64(sz + c->leb_size - 1, c->leb_size);\r\nif (lebs_needed > c->lpt_lebs) {\r\nubifs_err("too few LPT LEBs");\r\nreturn -EINVAL;\r\n}\r\nif (c->ltab_sz > c->leb_size) {\r\nubifs_err("LPT ltab too big");\r\nreturn -EINVAL;\r\n}\r\nc->check_lpt_free = c->big_lpt;\r\nreturn 0;\r\n}\r\nstatic int calc_dflt_lpt_geom(struct ubifs_info *c, int *main_lebs,\r\nint *big_lpt)\r\n{\r\nint i, lebs_needed;\r\nlong long sz;\r\nc->lpt_lebs = UBIFS_MIN_LPT_LEBS;\r\nc->main_lebs = *main_lebs - c->lpt_lebs;\r\nif (c->main_lebs <= 0)\r\nreturn -EINVAL;\r\nc->big_lpt = 0;\r\ndo_calc_lpt_geom(c);\r\nif (c->lpt_sz > c->leb_size) {\r\nc->big_lpt = 1;\r\ndo_calc_lpt_geom(c);\r\n}\r\nfor (i = 0; i < 64 ; i++) {\r\nsz = c->lpt_sz * 4;\r\nlebs_needed = div_u64(sz + c->leb_size - 1, c->leb_size);\r\nif (lebs_needed > c->lpt_lebs) {\r\nc->lpt_lebs = lebs_needed;\r\nc->main_lebs = *main_lebs - c->lpt_lebs;\r\nif (c->main_lebs <= 0)\r\nreturn -EINVAL;\r\ndo_calc_lpt_geom(c);\r\ncontinue;\r\n}\r\nif (c->ltab_sz > c->leb_size) {\r\nubifs_err("LPT ltab too big");\r\nreturn -EINVAL;\r\n}\r\n*main_lebs = c->main_lebs;\r\n*big_lpt = c->big_lpt;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void pack_bits(uint8_t **addr, int *pos, uint32_t val, int nrbits)\r\n{\r\nuint8_t *p = *addr;\r\nint b = *pos;\r\nubifs_assert(nrbits > 0);\r\nubifs_assert(nrbits <= 32);\r\nubifs_assert(*pos >= 0);\r\nubifs_assert(*pos < 8);\r\nubifs_assert((val >> nrbits) == 0 || nrbits == 32);\r\nif (b) {\r\n*p |= ((uint8_t)val) << b;\r\nnrbits += b;\r\nif (nrbits > 8) {\r\n*++p = (uint8_t)(val >>= (8 - b));\r\nif (nrbits > 16) {\r\n*++p = (uint8_t)(val >>= 8);\r\nif (nrbits > 24) {\r\n*++p = (uint8_t)(val >>= 8);\r\nif (nrbits > 32)\r\n*++p = (uint8_t)(val >>= 8);\r\n}\r\n}\r\n}\r\n} else {\r\n*p = (uint8_t)val;\r\nif (nrbits > 8) {\r\n*++p = (uint8_t)(val >>= 8);\r\nif (nrbits > 16) {\r\n*++p = (uint8_t)(val >>= 8);\r\nif (nrbits > 24)\r\n*++p = (uint8_t)(val >>= 8);\r\n}\r\n}\r\n}\r\nb = nrbits & 7;\r\nif (b == 0)\r\np++;\r\n*addr = p;\r\n*pos = b;\r\n}\r\nuint32_t ubifs_unpack_bits(uint8_t **addr, int *pos, int nrbits)\r\n{\r\nconst int k = 32 - nrbits;\r\nuint8_t *p = *addr;\r\nint b = *pos;\r\nuint32_t uninitialized_var(val);\r\nconst int bytes = (nrbits + b + 7) >> 3;\r\nubifs_assert(nrbits > 0);\r\nubifs_assert(nrbits <= 32);\r\nubifs_assert(*pos >= 0);\r\nubifs_assert(*pos < 8);\r\nif (b) {\r\nswitch (bytes) {\r\ncase 2:\r\nval = p[1];\r\nbreak;\r\ncase 3:\r\nval = p[1] | ((uint32_t)p[2] << 8);\r\nbreak;\r\ncase 4:\r\nval = p[1] | ((uint32_t)p[2] << 8) |\r\n((uint32_t)p[3] << 16);\r\nbreak;\r\ncase 5:\r\nval = p[1] | ((uint32_t)p[2] << 8) |\r\n((uint32_t)p[3] << 16) |\r\n((uint32_t)p[4] << 24);\r\n}\r\nval <<= (8 - b);\r\nval |= *p >> b;\r\nnrbits += b;\r\n} else {\r\nswitch (bytes) {\r\ncase 1:\r\nval = p[0];\r\nbreak;\r\ncase 2:\r\nval = p[0] | ((uint32_t)p[1] << 8);\r\nbreak;\r\ncase 3:\r\nval = p[0] | ((uint32_t)p[1] << 8) |\r\n((uint32_t)p[2] << 16);\r\nbreak;\r\ncase 4:\r\nval = p[0] | ((uint32_t)p[1] << 8) |\r\n((uint32_t)p[2] << 16) |\r\n((uint32_t)p[3] << 24);\r\nbreak;\r\n}\r\n}\r\nval <<= k;\r\nval >>= k;\r\nb = nrbits & 7;\r\np += nrbits >> 3;\r\n*addr = p;\r\n*pos = b;\r\nubifs_assert((val >> nrbits) == 0 || nrbits - b == 32);\r\nreturn val;\r\n}\r\nvoid ubifs_pack_pnode(struct ubifs_info *c, void *buf,\r\nstruct ubifs_pnode *pnode)\r\n{\r\nuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\r\nint i, pos = 0;\r\nuint16_t crc;\r\npack_bits(&addr, &pos, UBIFS_LPT_PNODE, UBIFS_LPT_TYPE_BITS);\r\nif (c->big_lpt)\r\npack_bits(&addr, &pos, pnode->num, c->pcnt_bits);\r\nfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\r\npack_bits(&addr, &pos, pnode->lprops[i].free >> 3,\r\nc->space_bits);\r\npack_bits(&addr, &pos, pnode->lprops[i].dirty >> 3,\r\nc->space_bits);\r\nif (pnode->lprops[i].flags & LPROPS_INDEX)\r\npack_bits(&addr, &pos, 1, 1);\r\nelse\r\npack_bits(&addr, &pos, 0, 1);\r\n}\r\ncrc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\r\nc->pnode_sz - UBIFS_LPT_CRC_BYTES);\r\naddr = buf;\r\npos = 0;\r\npack_bits(&addr, &pos, crc, UBIFS_LPT_CRC_BITS);\r\n}\r\nvoid ubifs_pack_nnode(struct ubifs_info *c, void *buf,\r\nstruct ubifs_nnode *nnode)\r\n{\r\nuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\r\nint i, pos = 0;\r\nuint16_t crc;\r\npack_bits(&addr, &pos, UBIFS_LPT_NNODE, UBIFS_LPT_TYPE_BITS);\r\nif (c->big_lpt)\r\npack_bits(&addr, &pos, nnode->num, c->pcnt_bits);\r\nfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\r\nint lnum = nnode->nbranch[i].lnum;\r\nif (lnum == 0)\r\nlnum = c->lpt_last + 1;\r\npack_bits(&addr, &pos, lnum - c->lpt_first, c->lpt_lnum_bits);\r\npack_bits(&addr, &pos, nnode->nbranch[i].offs,\r\nc->lpt_offs_bits);\r\n}\r\ncrc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\r\nc->nnode_sz - UBIFS_LPT_CRC_BYTES);\r\naddr = buf;\r\npos = 0;\r\npack_bits(&addr, &pos, crc, UBIFS_LPT_CRC_BITS);\r\n}\r\nvoid ubifs_pack_ltab(struct ubifs_info *c, void *buf,\r\nstruct ubifs_lpt_lprops *ltab)\r\n{\r\nuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\r\nint i, pos = 0;\r\nuint16_t crc;\r\npack_bits(&addr, &pos, UBIFS_LPT_LTAB, UBIFS_LPT_TYPE_BITS);\r\nfor (i = 0; i < c->lpt_lebs; i++) {\r\npack_bits(&addr, &pos, ltab[i].free, c->lpt_spc_bits);\r\npack_bits(&addr, &pos, ltab[i].dirty, c->lpt_spc_bits);\r\n}\r\ncrc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\r\nc->ltab_sz - UBIFS_LPT_CRC_BYTES);\r\naddr = buf;\r\npos = 0;\r\npack_bits(&addr, &pos, crc, UBIFS_LPT_CRC_BITS);\r\n}\r\nvoid ubifs_pack_lsave(struct ubifs_info *c, void *buf, int *lsave)\r\n{\r\nuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\r\nint i, pos = 0;\r\nuint16_t crc;\r\npack_bits(&addr, &pos, UBIFS_LPT_LSAVE, UBIFS_LPT_TYPE_BITS);\r\nfor (i = 0; i < c->lsave_cnt; i++)\r\npack_bits(&addr, &pos, lsave[i], c->lnum_bits);\r\ncrc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\r\nc->lsave_sz - UBIFS_LPT_CRC_BYTES);\r\naddr = buf;\r\npos = 0;\r\npack_bits(&addr, &pos, crc, UBIFS_LPT_CRC_BITS);\r\n}\r\nvoid ubifs_add_lpt_dirt(struct ubifs_info *c, int lnum, int dirty)\r\n{\r\nif (!dirty || !lnum)\r\nreturn;\r\ndbg_lp("LEB %d add %d to %d",\r\nlnum, dirty, c->ltab[lnum - c->lpt_first].dirty);\r\nubifs_assert(lnum >= c->lpt_first && lnum <= c->lpt_last);\r\nc->ltab[lnum - c->lpt_first].dirty += dirty;\r\n}\r\nstatic void set_ltab(struct ubifs_info *c, int lnum, int free, int dirty)\r\n{\r\ndbg_lp("LEB %d free %d dirty %d to %d %d",\r\nlnum, c->ltab[lnum - c->lpt_first].free,\r\nc->ltab[lnum - c->lpt_first].dirty, free, dirty);\r\nubifs_assert(lnum >= c->lpt_first && lnum <= c->lpt_last);\r\nc->ltab[lnum - c->lpt_first].free = free;\r\nc->ltab[lnum - c->lpt_first].dirty = dirty;\r\n}\r\nvoid ubifs_add_nnode_dirt(struct ubifs_info *c, struct ubifs_nnode *nnode)\r\n{\r\nstruct ubifs_nnode *np = nnode->parent;\r\nif (np)\r\nubifs_add_lpt_dirt(c, np->nbranch[nnode->iip].lnum,\r\nc->nnode_sz);\r\nelse {\r\nubifs_add_lpt_dirt(c, c->lpt_lnum, c->nnode_sz);\r\nif (!(c->lpt_drty_flgs & LTAB_DIRTY)) {\r\nc->lpt_drty_flgs |= LTAB_DIRTY;\r\nubifs_add_lpt_dirt(c, c->ltab_lnum, c->ltab_sz);\r\n}\r\n}\r\n}\r\nstatic void add_pnode_dirt(struct ubifs_info *c, struct ubifs_pnode *pnode)\r\n{\r\nubifs_add_lpt_dirt(c, pnode->parent->nbranch[pnode->iip].lnum,\r\nc->pnode_sz);\r\n}\r\nstatic int calc_nnode_num(int row, int col)\r\n{\r\nint num, bits;\r\nnum = 1;\r\nwhile (row--) {\r\nbits = (col & (UBIFS_LPT_FANOUT - 1));\r\ncol >>= UBIFS_LPT_FANOUT_SHIFT;\r\nnum <<= UBIFS_LPT_FANOUT_SHIFT;\r\nnum |= bits;\r\n}\r\nreturn num;\r\n}\r\nstatic int calc_nnode_num_from_parent(const struct ubifs_info *c,\r\nstruct ubifs_nnode *parent, int iip)\r\n{\r\nint num, shft;\r\nif (!parent)\r\nreturn 1;\r\nshft = (c->lpt_hght - parent->level) * UBIFS_LPT_FANOUT_SHIFT;\r\nnum = parent->num ^ (1 << shft);\r\nnum |= (UBIFS_LPT_FANOUT + iip) << shft;\r\nreturn num;\r\n}\r\nstatic int calc_pnode_num_from_parent(const struct ubifs_info *c,\r\nstruct ubifs_nnode *parent, int iip)\r\n{\r\nint i, n = c->lpt_hght - 1, pnum = parent->num, num = 0;\r\nfor (i = 0; i < n; i++) {\r\nnum <<= UBIFS_LPT_FANOUT_SHIFT;\r\nnum |= pnum & (UBIFS_LPT_FANOUT - 1);\r\npnum >>= UBIFS_LPT_FANOUT_SHIFT;\r\n}\r\nnum <<= UBIFS_LPT_FANOUT_SHIFT;\r\nnum |= iip;\r\nreturn num;\r\n}\r\nint ubifs_create_dflt_lpt(struct ubifs_info *c, int *main_lebs, int lpt_first,\r\nint *lpt_lebs, int *big_lpt)\r\n{\r\nint lnum, err = 0, node_sz, iopos, i, j, cnt, len, alen, row;\r\nint blnum, boffs, bsz, bcnt;\r\nstruct ubifs_pnode *pnode = NULL;\r\nstruct ubifs_nnode *nnode = NULL;\r\nvoid *buf = NULL, *p;\r\nstruct ubifs_lpt_lprops *ltab = NULL;\r\nint *lsave = NULL;\r\nerr = calc_dflt_lpt_geom(c, main_lebs, big_lpt);\r\nif (err)\r\nreturn err;\r\n*lpt_lebs = c->lpt_lebs;\r\nc->lpt_first = lpt_first;\r\nc->lpt_last = lpt_first + c->lpt_lebs - 1;\r\nc->main_first = c->leb_cnt - *main_lebs;\r\nlsave = kmalloc(sizeof(int) * c->lsave_cnt, GFP_KERNEL);\r\npnode = kzalloc(sizeof(struct ubifs_pnode), GFP_KERNEL);\r\nnnode = kzalloc(sizeof(struct ubifs_nnode), GFP_KERNEL);\r\nbuf = vmalloc(c->leb_size);\r\nltab = vmalloc(sizeof(struct ubifs_lpt_lprops) * c->lpt_lebs);\r\nif (!pnode || !nnode || !buf || !ltab || !lsave) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nubifs_assert(!c->ltab);\r\nc->ltab = ltab;\r\nfor (i = 0; i < c->lpt_lebs; i++) {\r\nltab[i].free = c->leb_size;\r\nltab[i].dirty = 0;\r\nltab[i].tgc = 0;\r\nltab[i].cmt = 0;\r\n}\r\nlnum = lpt_first;\r\np = buf;\r\ncnt = c->pnode_cnt;\r\nnode_sz = ALIGN(ubifs_idx_node_sz(c, 1), 8);\r\niopos = ALIGN(node_sz, c->min_io_size);\r\npnode->lprops[0].free = c->leb_size - iopos;\r\npnode->lprops[0].dirty = iopos - node_sz;\r\npnode->lprops[0].flags = LPROPS_INDEX;\r\nnode_sz = UBIFS_INO_NODE_SZ;\r\niopos = ALIGN(node_sz, c->min_io_size);\r\npnode->lprops[1].free = c->leb_size - iopos;\r\npnode->lprops[1].dirty = iopos - node_sz;\r\nfor (i = 2; i < UBIFS_LPT_FANOUT; i++)\r\npnode->lprops[i].free = c->leb_size;\r\nubifs_pack_pnode(c, p, pnode);\r\np += c->pnode_sz;\r\nlen = c->pnode_sz;\r\npnode->num += 1;\r\npnode->lprops[0].free = c->leb_size;\r\npnode->lprops[0].dirty = 0;\r\npnode->lprops[0].flags = 0;\r\npnode->lprops[1].free = c->leb_size;\r\npnode->lprops[1].dirty = 0;\r\nblnum = lnum;\r\nboffs = 0;\r\nbcnt = cnt;\r\nbsz = c->pnode_sz;\r\nfor (i = 1; i < cnt; i++) {\r\nif (len + c->pnode_sz > c->leb_size) {\r\nalen = ALIGN(len, c->min_io_size);\r\nset_ltab(c, lnum, c->leb_size - alen, alen - len);\r\nmemset(p, 0xff, alen - len);\r\nerr = ubifs_leb_change(c, lnum++, buf, alen,\r\nUBI_SHORTTERM);\r\nif (err)\r\ngoto out;\r\np = buf;\r\nlen = 0;\r\n}\r\nubifs_pack_pnode(c, p, pnode);\r\np += c->pnode_sz;\r\nlen += c->pnode_sz;\r\npnode->num += 1;\r\n}\r\nrow = 0;\r\nfor (i = UBIFS_LPT_FANOUT; cnt > i; i <<= UBIFS_LPT_FANOUT_SHIFT)\r\nrow += 1;\r\nwhile (1) {\r\ncnt = DIV_ROUND_UP(cnt, UBIFS_LPT_FANOUT);\r\nfor (i = 0; i < cnt; i++) {\r\nif (len + c->nnode_sz > c->leb_size) {\r\nalen = ALIGN(len, c->min_io_size);\r\nset_ltab(c, lnum, c->leb_size - alen,\r\nalen - len);\r\nmemset(p, 0xff, alen - len);\r\nerr = ubifs_leb_change(c, lnum++, buf, alen,\r\nUBI_SHORTTERM);\r\nif (err)\r\ngoto out;\r\np = buf;\r\nlen = 0;\r\n}\r\nif (cnt == 1) {\r\nc->lpt_lnum = lnum;\r\nc->lpt_offs = len;\r\n}\r\nfor (j = 0; j < UBIFS_LPT_FANOUT; j++) {\r\nif (bcnt) {\r\nif (boffs + bsz > c->leb_size) {\r\nblnum += 1;\r\nboffs = 0;\r\n}\r\nnnode->nbranch[j].lnum = blnum;\r\nnnode->nbranch[j].offs = boffs;\r\nboffs += bsz;\r\nbcnt--;\r\n} else {\r\nnnode->nbranch[j].lnum = 0;\r\nnnode->nbranch[j].offs = 0;\r\n}\r\n}\r\nnnode->num = calc_nnode_num(row, i);\r\nubifs_pack_nnode(c, p, nnode);\r\np += c->nnode_sz;\r\nlen += c->nnode_sz;\r\n}\r\nif (cnt == 1)\r\nbreak;\r\nbcnt = cnt;\r\nbsz = c->nnode_sz;\r\nrow -= 1;\r\n}\r\nif (*big_lpt) {\r\nif (len + c->lsave_sz > c->leb_size) {\r\nalen = ALIGN(len, c->min_io_size);\r\nset_ltab(c, lnum, c->leb_size - alen, alen - len);\r\nmemset(p, 0xff, alen - len);\r\nerr = ubifs_leb_change(c, lnum++, buf, alen,\r\nUBI_SHORTTERM);\r\nif (err)\r\ngoto out;\r\np = buf;\r\nlen = 0;\r\n}\r\nc->lsave_lnum = lnum;\r\nc->lsave_offs = len;\r\nfor (i = 0; i < c->lsave_cnt && i < *main_lebs; i++)\r\nlsave[i] = c->main_first + i;\r\nfor (; i < c->lsave_cnt; i++)\r\nlsave[i] = c->main_first;\r\nubifs_pack_lsave(c, p, lsave);\r\np += c->lsave_sz;\r\nlen += c->lsave_sz;\r\n}\r\nif (len + c->ltab_sz > c->leb_size) {\r\nalen = ALIGN(len, c->min_io_size);\r\nset_ltab(c, lnum, c->leb_size - alen, alen - len);\r\nmemset(p, 0xff, alen - len);\r\nerr = ubifs_leb_change(c, lnum++, buf, alen, UBI_SHORTTERM);\r\nif (err)\r\ngoto out;\r\np = buf;\r\nlen = 0;\r\n}\r\nc->ltab_lnum = lnum;\r\nc->ltab_offs = len;\r\nlen += c->ltab_sz;\r\nalen = ALIGN(len, c->min_io_size);\r\nset_ltab(c, lnum, c->leb_size - alen, alen - len);\r\nubifs_pack_ltab(c, p, ltab);\r\np += c->ltab_sz;\r\nmemset(p, 0xff, alen - len);\r\nerr = ubifs_leb_change(c, lnum, buf, alen, UBI_SHORTTERM);\r\nif (err)\r\ngoto out;\r\nc->nhead_lnum = lnum;\r\nc->nhead_offs = ALIGN(len, c->min_io_size);\r\ndbg_lp("space_bits %d", c->space_bits);\r\ndbg_lp("lpt_lnum_bits %d", c->lpt_lnum_bits);\r\ndbg_lp("lpt_offs_bits %d", c->lpt_offs_bits);\r\ndbg_lp("lpt_spc_bits %d", c->lpt_spc_bits);\r\ndbg_lp("pcnt_bits %d", c->pcnt_bits);\r\ndbg_lp("lnum_bits %d", c->lnum_bits);\r\ndbg_lp("pnode_sz %d", c->pnode_sz);\r\ndbg_lp("nnode_sz %d", c->nnode_sz);\r\ndbg_lp("ltab_sz %d", c->ltab_sz);\r\ndbg_lp("lsave_sz %d", c->lsave_sz);\r\ndbg_lp("lsave_cnt %d", c->lsave_cnt);\r\ndbg_lp("lpt_hght %d", c->lpt_hght);\r\ndbg_lp("big_lpt %d", c->big_lpt);\r\ndbg_lp("LPT root is at %d:%d", c->lpt_lnum, c->lpt_offs);\r\ndbg_lp("LPT head is at %d:%d", c->nhead_lnum, c->nhead_offs);\r\ndbg_lp("LPT ltab is at %d:%d", c->ltab_lnum, c->ltab_offs);\r\nif (c->big_lpt)\r\ndbg_lp("LPT lsave is at %d:%d", c->lsave_lnum, c->lsave_offs);\r\nout:\r\nc->ltab = NULL;\r\nkfree(lsave);\r\nvfree(ltab);\r\nvfree(buf);\r\nkfree(nnode);\r\nkfree(pnode);\r\nreturn err;\r\n}\r\nstatic void update_cats(struct ubifs_info *c, struct ubifs_pnode *pnode)\r\n{\r\nint i;\r\nfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\r\nint cat = pnode->lprops[i].flags & LPROPS_CAT_MASK;\r\nint lnum = pnode->lprops[i].lnum;\r\nif (!lnum)\r\nreturn;\r\nubifs_add_to_cat(c, &pnode->lprops[i], cat);\r\n}\r\n}\r\nstatic void replace_cats(struct ubifs_info *c, struct ubifs_pnode *old_pnode,\r\nstruct ubifs_pnode *new_pnode)\r\n{\r\nint i;\r\nfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\r\nif (!new_pnode->lprops[i].lnum)\r\nreturn;\r\nubifs_replace_cat(c, &old_pnode->lprops[i],\r\n&new_pnode->lprops[i]);\r\n}\r\n}\r\nstatic int check_lpt_crc(void *buf, int len)\r\n{\r\nint pos = 0;\r\nuint8_t *addr = buf;\r\nuint16_t crc, calc_crc;\r\ncrc = ubifs_unpack_bits(&addr, &pos, UBIFS_LPT_CRC_BITS);\r\ncalc_crc = crc16(-1, buf + UBIFS_LPT_CRC_BYTES,\r\nlen - UBIFS_LPT_CRC_BYTES);\r\nif (crc != calc_crc) {\r\nubifs_err("invalid crc in LPT node: crc %hx calc %hx", crc,\r\ncalc_crc);\r\ndbg_dump_stack();\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_lpt_type(uint8_t **addr, int *pos, int type)\r\n{\r\nint node_type;\r\nnode_type = ubifs_unpack_bits(addr, pos, UBIFS_LPT_TYPE_BITS);\r\nif (node_type != type) {\r\nubifs_err("invalid type (%d) in LPT node type %d", node_type,\r\ntype);\r\ndbg_dump_stack();\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int unpack_pnode(const struct ubifs_info *c, void *buf,\r\nstruct ubifs_pnode *pnode)\r\n{\r\nuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\r\nint i, pos = 0, err;\r\nerr = check_lpt_type(&addr, &pos, UBIFS_LPT_PNODE);\r\nif (err)\r\nreturn err;\r\nif (c->big_lpt)\r\npnode->num = ubifs_unpack_bits(&addr, &pos, c->pcnt_bits);\r\nfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\r\nstruct ubifs_lprops * const lprops = &pnode->lprops[i];\r\nlprops->free = ubifs_unpack_bits(&addr, &pos, c->space_bits);\r\nlprops->free <<= 3;\r\nlprops->dirty = ubifs_unpack_bits(&addr, &pos, c->space_bits);\r\nlprops->dirty <<= 3;\r\nif (ubifs_unpack_bits(&addr, &pos, 1))\r\nlprops->flags = LPROPS_INDEX;\r\nelse\r\nlprops->flags = 0;\r\nlprops->flags |= ubifs_categorize_lprops(c, lprops);\r\n}\r\nerr = check_lpt_crc(buf, c->pnode_sz);\r\nreturn err;\r\n}\r\nint ubifs_unpack_nnode(const struct ubifs_info *c, void *buf,\r\nstruct ubifs_nnode *nnode)\r\n{\r\nuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\r\nint i, pos = 0, err;\r\nerr = check_lpt_type(&addr, &pos, UBIFS_LPT_NNODE);\r\nif (err)\r\nreturn err;\r\nif (c->big_lpt)\r\nnnode->num = ubifs_unpack_bits(&addr, &pos, c->pcnt_bits);\r\nfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\r\nint lnum;\r\nlnum = ubifs_unpack_bits(&addr, &pos, c->lpt_lnum_bits) +\r\nc->lpt_first;\r\nif (lnum == c->lpt_last + 1)\r\nlnum = 0;\r\nnnode->nbranch[i].lnum = lnum;\r\nnnode->nbranch[i].offs = ubifs_unpack_bits(&addr, &pos,\r\nc->lpt_offs_bits);\r\n}\r\nerr = check_lpt_crc(buf, c->nnode_sz);\r\nreturn err;\r\n}\r\nstatic int unpack_ltab(const struct ubifs_info *c, void *buf)\r\n{\r\nuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\r\nint i, pos = 0, err;\r\nerr = check_lpt_type(&addr, &pos, UBIFS_LPT_LTAB);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < c->lpt_lebs; i++) {\r\nint free = ubifs_unpack_bits(&addr, &pos, c->lpt_spc_bits);\r\nint dirty = ubifs_unpack_bits(&addr, &pos, c->lpt_spc_bits);\r\nif (free < 0 || free > c->leb_size || dirty < 0 ||\r\ndirty > c->leb_size || free + dirty > c->leb_size)\r\nreturn -EINVAL;\r\nc->ltab[i].free = free;\r\nc->ltab[i].dirty = dirty;\r\nc->ltab[i].tgc = 0;\r\nc->ltab[i].cmt = 0;\r\n}\r\nerr = check_lpt_crc(buf, c->ltab_sz);\r\nreturn err;\r\n}\r\nstatic int unpack_lsave(const struct ubifs_info *c, void *buf)\r\n{\r\nuint8_t *addr = buf + UBIFS_LPT_CRC_BYTES;\r\nint i, pos = 0, err;\r\nerr = check_lpt_type(&addr, &pos, UBIFS_LPT_LSAVE);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < c->lsave_cnt; i++) {\r\nint lnum = ubifs_unpack_bits(&addr, &pos, c->lnum_bits);\r\nif (lnum < c->main_first || lnum >= c->leb_cnt)\r\nreturn -EINVAL;\r\nc->lsave[i] = lnum;\r\n}\r\nerr = check_lpt_crc(buf, c->lsave_sz);\r\nreturn err;\r\n}\r\nstatic int validate_nnode(const struct ubifs_info *c, struct ubifs_nnode *nnode,\r\nstruct ubifs_nnode *parent, int iip)\r\n{\r\nint i, lvl, max_offs;\r\nif (c->big_lpt) {\r\nint num = calc_nnode_num_from_parent(c, parent, iip);\r\nif (nnode->num != num)\r\nreturn -EINVAL;\r\n}\r\nlvl = parent ? parent->level - 1 : c->lpt_hght;\r\nif (lvl < 1)\r\nreturn -EINVAL;\r\nif (lvl == 1)\r\nmax_offs = c->leb_size - c->pnode_sz;\r\nelse\r\nmax_offs = c->leb_size - c->nnode_sz;\r\nfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\r\nint lnum = nnode->nbranch[i].lnum;\r\nint offs = nnode->nbranch[i].offs;\r\nif (lnum == 0) {\r\nif (offs != 0)\r\nreturn -EINVAL;\r\ncontinue;\r\n}\r\nif (lnum < c->lpt_first || lnum > c->lpt_last)\r\nreturn -EINVAL;\r\nif (offs < 0 || offs > max_offs)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int validate_pnode(const struct ubifs_info *c, struct ubifs_pnode *pnode,\r\nstruct ubifs_nnode *parent, int iip)\r\n{\r\nint i;\r\nif (c->big_lpt) {\r\nint num = calc_pnode_num_from_parent(c, parent, iip);\r\nif (pnode->num != num)\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\r\nint free = pnode->lprops[i].free;\r\nint dirty = pnode->lprops[i].dirty;\r\nif (free < 0 || free > c->leb_size || free % c->min_io_size ||\r\n(free & 7))\r\nreturn -EINVAL;\r\nif (dirty < 0 || dirty > c->leb_size || (dirty & 7))\r\nreturn -EINVAL;\r\nif (dirty + free > c->leb_size)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void set_pnode_lnum(const struct ubifs_info *c,\r\nstruct ubifs_pnode *pnode)\r\n{\r\nint i, lnum;\r\nlnum = (pnode->num << UBIFS_LPT_FANOUT_SHIFT) + c->main_first;\r\nfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\r\nif (lnum >= c->leb_cnt)\r\nreturn;\r\npnode->lprops[i].lnum = lnum++;\r\n}\r\n}\r\nint ubifs_read_nnode(struct ubifs_info *c, struct ubifs_nnode *parent, int iip)\r\n{\r\nstruct ubifs_nbranch *branch = NULL;\r\nstruct ubifs_nnode *nnode = NULL;\r\nvoid *buf = c->lpt_nod_buf;\r\nint err, lnum, offs;\r\nif (parent) {\r\nbranch = &parent->nbranch[iip];\r\nlnum = branch->lnum;\r\noffs = branch->offs;\r\n} else {\r\nlnum = c->lpt_lnum;\r\noffs = c->lpt_offs;\r\n}\r\nnnode = kzalloc(sizeof(struct ubifs_nnode), GFP_NOFS);\r\nif (!nnode) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nif (lnum == 0) {\r\nif (c->big_lpt)\r\nnnode->num = calc_nnode_num_from_parent(c, parent, iip);\r\n} else {\r\nerr = ubifs_leb_read(c, lnum, buf, offs, c->nnode_sz, 1);\r\nif (err)\r\ngoto out;\r\nerr = ubifs_unpack_nnode(c, buf, nnode);\r\nif (err)\r\ngoto out;\r\n}\r\nerr = validate_nnode(c, nnode, parent, iip);\r\nif (err)\r\ngoto out;\r\nif (!c->big_lpt)\r\nnnode->num = calc_nnode_num_from_parent(c, parent, iip);\r\nif (parent) {\r\nbranch->nnode = nnode;\r\nnnode->level = parent->level - 1;\r\n} else {\r\nc->nroot = nnode;\r\nnnode->level = c->lpt_hght;\r\n}\r\nnnode->parent = parent;\r\nnnode->iip = iip;\r\nreturn 0;\r\nout:\r\nubifs_err("error %d reading nnode at %d:%d", err, lnum, offs);\r\ndbg_dump_stack();\r\nkfree(nnode);\r\nreturn err;\r\n}\r\nstatic int read_pnode(struct ubifs_info *c, struct ubifs_nnode *parent, int iip)\r\n{\r\nstruct ubifs_nbranch *branch;\r\nstruct ubifs_pnode *pnode = NULL;\r\nvoid *buf = c->lpt_nod_buf;\r\nint err, lnum, offs;\r\nbranch = &parent->nbranch[iip];\r\nlnum = branch->lnum;\r\noffs = branch->offs;\r\npnode = kzalloc(sizeof(struct ubifs_pnode), GFP_NOFS);\r\nif (!pnode)\r\nreturn -ENOMEM;\r\nif (lnum == 0) {\r\nint i;\r\nif (c->big_lpt)\r\npnode->num = calc_pnode_num_from_parent(c, parent, iip);\r\nfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\r\nstruct ubifs_lprops * const lprops = &pnode->lprops[i];\r\nlprops->free = c->leb_size;\r\nlprops->flags = ubifs_categorize_lprops(c, lprops);\r\n}\r\n} else {\r\nerr = ubifs_leb_read(c, lnum, buf, offs, c->pnode_sz, 1);\r\nif (err)\r\ngoto out;\r\nerr = unpack_pnode(c, buf, pnode);\r\nif (err)\r\ngoto out;\r\n}\r\nerr = validate_pnode(c, pnode, parent, iip);\r\nif (err)\r\ngoto out;\r\nif (!c->big_lpt)\r\npnode->num = calc_pnode_num_from_parent(c, parent, iip);\r\nbranch->pnode = pnode;\r\npnode->parent = parent;\r\npnode->iip = iip;\r\nset_pnode_lnum(c, pnode);\r\nc->pnodes_have += 1;\r\nreturn 0;\r\nout:\r\nubifs_err("error %d reading pnode at %d:%d", err, lnum, offs);\r\ndbg_dump_pnode(c, pnode, parent, iip);\r\ndbg_dump_stack();\r\ndbg_msg("calc num: %d", calc_pnode_num_from_parent(c, parent, iip));\r\nkfree(pnode);\r\nreturn err;\r\n}\r\nstatic int read_ltab(struct ubifs_info *c)\r\n{\r\nint err;\r\nvoid *buf;\r\nbuf = vmalloc(c->ltab_sz);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nerr = ubifs_leb_read(c, c->ltab_lnum, buf, c->ltab_offs, c->ltab_sz, 1);\r\nif (err)\r\ngoto out;\r\nerr = unpack_ltab(c, buf);\r\nout:\r\nvfree(buf);\r\nreturn err;\r\n}\r\nstatic int read_lsave(struct ubifs_info *c)\r\n{\r\nint err, i;\r\nvoid *buf;\r\nbuf = vmalloc(c->lsave_sz);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nerr = ubifs_leb_read(c, c->lsave_lnum, buf, c->lsave_offs,\r\nc->lsave_sz, 1);\r\nif (err)\r\ngoto out;\r\nerr = unpack_lsave(c, buf);\r\nif (err)\r\ngoto out;\r\nfor (i = 0; i < c->lsave_cnt; i++) {\r\nint lnum = c->lsave[i];\r\nstruct ubifs_lprops *lprops;\r\nif (lnum >= c->leb_cnt)\r\ncontinue;\r\nlprops = ubifs_lpt_lookup(c, lnum);\r\nif (IS_ERR(lprops)) {\r\nerr = PTR_ERR(lprops);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nvfree(buf);\r\nreturn err;\r\n}\r\nstruct ubifs_nnode *ubifs_get_nnode(struct ubifs_info *c,\r\nstruct ubifs_nnode *parent, int iip)\r\n{\r\nstruct ubifs_nbranch *branch;\r\nstruct ubifs_nnode *nnode;\r\nint err;\r\nbranch = &parent->nbranch[iip];\r\nnnode = branch->nnode;\r\nif (nnode)\r\nreturn nnode;\r\nerr = ubifs_read_nnode(c, parent, iip);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nreturn branch->nnode;\r\n}\r\nstruct ubifs_pnode *ubifs_get_pnode(struct ubifs_info *c,\r\nstruct ubifs_nnode *parent, int iip)\r\n{\r\nstruct ubifs_nbranch *branch;\r\nstruct ubifs_pnode *pnode;\r\nint err;\r\nbranch = &parent->nbranch[iip];\r\npnode = branch->pnode;\r\nif (pnode)\r\nreturn pnode;\r\nerr = read_pnode(c, parent, iip);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nupdate_cats(c, branch->pnode);\r\nreturn branch->pnode;\r\n}\r\nstruct ubifs_lprops *ubifs_lpt_lookup(struct ubifs_info *c, int lnum)\r\n{\r\nint err, i, h, iip, shft;\r\nstruct ubifs_nnode *nnode;\r\nstruct ubifs_pnode *pnode;\r\nif (!c->nroot) {\r\nerr = ubifs_read_nnode(c, NULL, 0);\r\nif (err)\r\nreturn ERR_PTR(err);\r\n}\r\nnnode = c->nroot;\r\ni = lnum - c->main_first;\r\nshft = c->lpt_hght * UBIFS_LPT_FANOUT_SHIFT;\r\nfor (h = 1; h < c->lpt_hght; h++) {\r\niip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\r\nshft -= UBIFS_LPT_FANOUT_SHIFT;\r\nnnode = ubifs_get_nnode(c, nnode, iip);\r\nif (IS_ERR(nnode))\r\nreturn ERR_CAST(nnode);\r\n}\r\niip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\r\nshft -= UBIFS_LPT_FANOUT_SHIFT;\r\npnode = ubifs_get_pnode(c, nnode, iip);\r\nif (IS_ERR(pnode))\r\nreturn ERR_CAST(pnode);\r\niip = (i & (UBIFS_LPT_FANOUT - 1));\r\ndbg_lp("LEB %d, free %d, dirty %d, flags %d", lnum,\r\npnode->lprops[iip].free, pnode->lprops[iip].dirty,\r\npnode->lprops[iip].flags);\r\nreturn &pnode->lprops[iip];\r\n}\r\nstatic struct ubifs_nnode *dirty_cow_nnode(struct ubifs_info *c,\r\nstruct ubifs_nnode *nnode)\r\n{\r\nstruct ubifs_nnode *n;\r\nint i;\r\nif (!test_bit(COW_CNODE, &nnode->flags)) {\r\nif (!test_and_set_bit(DIRTY_CNODE, &nnode->flags)) {\r\nc->dirty_nn_cnt += 1;\r\nubifs_add_nnode_dirt(c, nnode);\r\n}\r\nreturn nnode;\r\n}\r\nn = kmalloc(sizeof(struct ubifs_nnode), GFP_NOFS);\r\nif (unlikely(!n))\r\nreturn ERR_PTR(-ENOMEM);\r\nmemcpy(n, nnode, sizeof(struct ubifs_nnode));\r\nn->cnext = NULL;\r\n__set_bit(DIRTY_CNODE, &n->flags);\r\n__clear_bit(COW_CNODE, &n->flags);\r\nfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\r\nstruct ubifs_nbranch *branch = &n->nbranch[i];\r\nif (branch->cnode)\r\nbranch->cnode->parent = n;\r\n}\r\nubifs_assert(!test_bit(OBSOLETE_CNODE, &nnode->flags));\r\n__set_bit(OBSOLETE_CNODE, &nnode->flags);\r\nc->dirty_nn_cnt += 1;\r\nubifs_add_nnode_dirt(c, nnode);\r\nif (nnode->parent)\r\nnnode->parent->nbranch[n->iip].nnode = n;\r\nelse\r\nc->nroot = n;\r\nreturn n;\r\n}\r\nstatic struct ubifs_pnode *dirty_cow_pnode(struct ubifs_info *c,\r\nstruct ubifs_pnode *pnode)\r\n{\r\nstruct ubifs_pnode *p;\r\nif (!test_bit(COW_CNODE, &pnode->flags)) {\r\nif (!test_and_set_bit(DIRTY_CNODE, &pnode->flags)) {\r\nc->dirty_pn_cnt += 1;\r\nadd_pnode_dirt(c, pnode);\r\n}\r\nreturn pnode;\r\n}\r\np = kmalloc(sizeof(struct ubifs_pnode), GFP_NOFS);\r\nif (unlikely(!p))\r\nreturn ERR_PTR(-ENOMEM);\r\nmemcpy(p, pnode, sizeof(struct ubifs_pnode));\r\np->cnext = NULL;\r\n__set_bit(DIRTY_CNODE, &p->flags);\r\n__clear_bit(COW_CNODE, &p->flags);\r\nreplace_cats(c, pnode, p);\r\nubifs_assert(!test_bit(OBSOLETE_CNODE, &pnode->flags));\r\n__set_bit(OBSOLETE_CNODE, &pnode->flags);\r\nc->dirty_pn_cnt += 1;\r\nadd_pnode_dirt(c, pnode);\r\npnode->parent->nbranch[p->iip].pnode = p;\r\nreturn p;\r\n}\r\nstruct ubifs_lprops *ubifs_lpt_lookup_dirty(struct ubifs_info *c, int lnum)\r\n{\r\nint err, i, h, iip, shft;\r\nstruct ubifs_nnode *nnode;\r\nstruct ubifs_pnode *pnode;\r\nif (!c->nroot) {\r\nerr = ubifs_read_nnode(c, NULL, 0);\r\nif (err)\r\nreturn ERR_PTR(err);\r\n}\r\nnnode = c->nroot;\r\nnnode = dirty_cow_nnode(c, nnode);\r\nif (IS_ERR(nnode))\r\nreturn ERR_CAST(nnode);\r\ni = lnum - c->main_first;\r\nshft = c->lpt_hght * UBIFS_LPT_FANOUT_SHIFT;\r\nfor (h = 1; h < c->lpt_hght; h++) {\r\niip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\r\nshft -= UBIFS_LPT_FANOUT_SHIFT;\r\nnnode = ubifs_get_nnode(c, nnode, iip);\r\nif (IS_ERR(nnode))\r\nreturn ERR_CAST(nnode);\r\nnnode = dirty_cow_nnode(c, nnode);\r\nif (IS_ERR(nnode))\r\nreturn ERR_CAST(nnode);\r\n}\r\niip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\r\nshft -= UBIFS_LPT_FANOUT_SHIFT;\r\npnode = ubifs_get_pnode(c, nnode, iip);\r\nif (IS_ERR(pnode))\r\nreturn ERR_CAST(pnode);\r\npnode = dirty_cow_pnode(c, pnode);\r\nif (IS_ERR(pnode))\r\nreturn ERR_CAST(pnode);\r\niip = (i & (UBIFS_LPT_FANOUT - 1));\r\ndbg_lp("LEB %d, free %d, dirty %d, flags %d", lnum,\r\npnode->lprops[iip].free, pnode->lprops[iip].dirty,\r\npnode->lprops[iip].flags);\r\nubifs_assert(test_bit(DIRTY_CNODE, &pnode->flags));\r\nreturn &pnode->lprops[iip];\r\n}\r\nstatic int lpt_init_rd(struct ubifs_info *c)\r\n{\r\nint err, i;\r\nc->ltab = vmalloc(sizeof(struct ubifs_lpt_lprops) * c->lpt_lebs);\r\nif (!c->ltab)\r\nreturn -ENOMEM;\r\ni = max_t(int, c->nnode_sz, c->pnode_sz);\r\nc->lpt_nod_buf = kmalloc(i, GFP_KERNEL);\r\nif (!c->lpt_nod_buf)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < LPROPS_HEAP_CNT; i++) {\r\nc->lpt_heap[i].arr = kmalloc(sizeof(void *) * LPT_HEAP_SZ,\r\nGFP_KERNEL);\r\nif (!c->lpt_heap[i].arr)\r\nreturn -ENOMEM;\r\nc->lpt_heap[i].cnt = 0;\r\nc->lpt_heap[i].max_cnt = LPT_HEAP_SZ;\r\n}\r\nc->dirty_idx.arr = kmalloc(sizeof(void *) * LPT_HEAP_SZ, GFP_KERNEL);\r\nif (!c->dirty_idx.arr)\r\nreturn -ENOMEM;\r\nc->dirty_idx.cnt = 0;\r\nc->dirty_idx.max_cnt = LPT_HEAP_SZ;\r\nerr = read_ltab(c);\r\nif (err)\r\nreturn err;\r\ndbg_lp("space_bits %d", c->space_bits);\r\ndbg_lp("lpt_lnum_bits %d", c->lpt_lnum_bits);\r\ndbg_lp("lpt_offs_bits %d", c->lpt_offs_bits);\r\ndbg_lp("lpt_spc_bits %d", c->lpt_spc_bits);\r\ndbg_lp("pcnt_bits %d", c->pcnt_bits);\r\ndbg_lp("lnum_bits %d", c->lnum_bits);\r\ndbg_lp("pnode_sz %d", c->pnode_sz);\r\ndbg_lp("nnode_sz %d", c->nnode_sz);\r\ndbg_lp("ltab_sz %d", c->ltab_sz);\r\ndbg_lp("lsave_sz %d", c->lsave_sz);\r\ndbg_lp("lsave_cnt %d", c->lsave_cnt);\r\ndbg_lp("lpt_hght %d", c->lpt_hght);\r\ndbg_lp("big_lpt %d", c->big_lpt);\r\ndbg_lp("LPT root is at %d:%d", c->lpt_lnum, c->lpt_offs);\r\ndbg_lp("LPT head is at %d:%d", c->nhead_lnum, c->nhead_offs);\r\ndbg_lp("LPT ltab is at %d:%d", c->ltab_lnum, c->ltab_offs);\r\nif (c->big_lpt)\r\ndbg_lp("LPT lsave is at %d:%d", c->lsave_lnum, c->lsave_offs);\r\nreturn 0;\r\n}\r\nstatic int lpt_init_wr(struct ubifs_info *c)\r\n{\r\nint err, i;\r\nc->ltab_cmt = vmalloc(sizeof(struct ubifs_lpt_lprops) * c->lpt_lebs);\r\nif (!c->ltab_cmt)\r\nreturn -ENOMEM;\r\nc->lpt_buf = vmalloc(c->leb_size);\r\nif (!c->lpt_buf)\r\nreturn -ENOMEM;\r\nif (c->big_lpt) {\r\nc->lsave = kmalloc(sizeof(int) * c->lsave_cnt, GFP_NOFS);\r\nif (!c->lsave)\r\nreturn -ENOMEM;\r\nerr = read_lsave(c);\r\nif (err)\r\nreturn err;\r\n}\r\nfor (i = 0; i < c->lpt_lebs; i++)\r\nif (c->ltab[i].free == c->leb_size) {\r\nerr = ubifs_leb_unmap(c, i + c->lpt_first);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint ubifs_lpt_init(struct ubifs_info *c, int rd, int wr)\r\n{\r\nint err;\r\nif (rd) {\r\nerr = lpt_init_rd(c);\r\nif (err)\r\nreturn err;\r\n}\r\nif (wr) {\r\nerr = lpt_init_wr(c);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct ubifs_nnode *scan_get_nnode(struct ubifs_info *c,\r\nstruct lpt_scan_node *path,\r\nstruct ubifs_nnode *parent, int iip)\r\n{\r\nstruct ubifs_nbranch *branch;\r\nstruct ubifs_nnode *nnode;\r\nvoid *buf = c->lpt_nod_buf;\r\nint err;\r\nbranch = &parent->nbranch[iip];\r\nnnode = branch->nnode;\r\nif (nnode) {\r\npath->in_tree = 1;\r\npath->ptr.nnode = nnode;\r\nreturn nnode;\r\n}\r\nnnode = &path->nnode;\r\npath->in_tree = 0;\r\npath->ptr.nnode = nnode;\r\nmemset(nnode, 0, sizeof(struct ubifs_nnode));\r\nif (branch->lnum == 0) {\r\nif (c->big_lpt)\r\nnnode->num = calc_nnode_num_from_parent(c, parent, iip);\r\n} else {\r\nerr = ubifs_leb_read(c, branch->lnum, buf, branch->offs,\r\nc->nnode_sz, 1);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nerr = ubifs_unpack_nnode(c, buf, nnode);\r\nif (err)\r\nreturn ERR_PTR(err);\r\n}\r\nerr = validate_nnode(c, nnode, parent, iip);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nif (!c->big_lpt)\r\nnnode->num = calc_nnode_num_from_parent(c, parent, iip);\r\nnnode->level = parent->level - 1;\r\nnnode->parent = parent;\r\nnnode->iip = iip;\r\nreturn nnode;\r\n}\r\nstatic struct ubifs_pnode *scan_get_pnode(struct ubifs_info *c,\r\nstruct lpt_scan_node *path,\r\nstruct ubifs_nnode *parent, int iip)\r\n{\r\nstruct ubifs_nbranch *branch;\r\nstruct ubifs_pnode *pnode;\r\nvoid *buf = c->lpt_nod_buf;\r\nint err;\r\nbranch = &parent->nbranch[iip];\r\npnode = branch->pnode;\r\nif (pnode) {\r\npath->in_tree = 1;\r\npath->ptr.pnode = pnode;\r\nreturn pnode;\r\n}\r\npnode = &path->pnode;\r\npath->in_tree = 0;\r\npath->ptr.pnode = pnode;\r\nmemset(pnode, 0, sizeof(struct ubifs_pnode));\r\nif (branch->lnum == 0) {\r\nint i;\r\nif (c->big_lpt)\r\npnode->num = calc_pnode_num_from_parent(c, parent, iip);\r\nfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\r\nstruct ubifs_lprops * const lprops = &pnode->lprops[i];\r\nlprops->free = c->leb_size;\r\nlprops->flags = ubifs_categorize_lprops(c, lprops);\r\n}\r\n} else {\r\nubifs_assert(branch->lnum >= c->lpt_first &&\r\nbranch->lnum <= c->lpt_last);\r\nubifs_assert(branch->offs >= 0 && branch->offs < c->leb_size);\r\nerr = ubifs_leb_read(c, branch->lnum, buf, branch->offs,\r\nc->pnode_sz, 1);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nerr = unpack_pnode(c, buf, pnode);\r\nif (err)\r\nreturn ERR_PTR(err);\r\n}\r\nerr = validate_pnode(c, pnode, parent, iip);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nif (!c->big_lpt)\r\npnode->num = calc_pnode_num_from_parent(c, parent, iip);\r\npnode->parent = parent;\r\npnode->iip = iip;\r\nset_pnode_lnum(c, pnode);\r\nreturn pnode;\r\n}\r\nint ubifs_lpt_scan_nolock(struct ubifs_info *c, int start_lnum, int end_lnum,\r\nubifs_lpt_scan_callback scan_cb, void *data)\r\n{\r\nint err = 0, i, h, iip, shft;\r\nstruct ubifs_nnode *nnode;\r\nstruct ubifs_pnode *pnode;\r\nstruct lpt_scan_node *path;\r\nif (start_lnum == -1) {\r\nstart_lnum = end_lnum + 1;\r\nif (start_lnum >= c->leb_cnt)\r\nstart_lnum = c->main_first;\r\n}\r\nubifs_assert(start_lnum >= c->main_first && start_lnum < c->leb_cnt);\r\nubifs_assert(end_lnum >= c->main_first && end_lnum < c->leb_cnt);\r\nif (!c->nroot) {\r\nerr = ubifs_read_nnode(c, NULL, 0);\r\nif (err)\r\nreturn err;\r\n}\r\npath = kmalloc(sizeof(struct lpt_scan_node) * (c->lpt_hght + 1),\r\nGFP_NOFS);\r\nif (!path)\r\nreturn -ENOMEM;\r\npath[0].ptr.nnode = c->nroot;\r\npath[0].in_tree = 1;\r\nagain:\r\nnnode = c->nroot;\r\ni = start_lnum - c->main_first;\r\nshft = c->lpt_hght * UBIFS_LPT_FANOUT_SHIFT;\r\nfor (h = 1; h < c->lpt_hght; h++) {\r\niip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\r\nshft -= UBIFS_LPT_FANOUT_SHIFT;\r\nnnode = scan_get_nnode(c, path + h, nnode, iip);\r\nif (IS_ERR(nnode)) {\r\nerr = PTR_ERR(nnode);\r\ngoto out;\r\n}\r\n}\r\niip = ((i >> shft) & (UBIFS_LPT_FANOUT - 1));\r\nshft -= UBIFS_LPT_FANOUT_SHIFT;\r\npnode = scan_get_pnode(c, path + h, nnode, iip);\r\nif (IS_ERR(pnode)) {\r\nerr = PTR_ERR(pnode);\r\ngoto out;\r\n}\r\niip = (i & (UBIFS_LPT_FANOUT - 1));\r\nwhile (1) {\r\nstruct ubifs_lprops *lprops = &pnode->lprops[iip];\r\nint ret, lnum = lprops->lnum;\r\nret = scan_cb(c, lprops, path[h].in_tree, data);\r\nif (ret < 0) {\r\nerr = ret;\r\ngoto out;\r\n}\r\nif (ret & LPT_SCAN_ADD) {\r\nfor (h = 1; h < c->lpt_hght; h++) {\r\nconst size_t sz = sizeof(struct ubifs_nnode);\r\nstruct ubifs_nnode *parent;\r\nif (path[h].in_tree)\r\ncontinue;\r\nnnode = kmemdup(&path[h].nnode, sz, GFP_NOFS);\r\nif (!nnode) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nparent = nnode->parent;\r\nparent->nbranch[nnode->iip].nnode = nnode;\r\npath[h].ptr.nnode = nnode;\r\npath[h].in_tree = 1;\r\npath[h + 1].cnode.parent = nnode;\r\n}\r\nif (path[h].in_tree)\r\nubifs_ensure_cat(c, lprops);\r\nelse {\r\nconst size_t sz = sizeof(struct ubifs_pnode);\r\nstruct ubifs_nnode *parent;\r\npnode = kmemdup(&path[h].pnode, sz, GFP_NOFS);\r\nif (!pnode) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nparent = pnode->parent;\r\nparent->nbranch[pnode->iip].pnode = pnode;\r\npath[h].ptr.pnode = pnode;\r\npath[h].in_tree = 1;\r\nupdate_cats(c, pnode);\r\nc->pnodes_have += 1;\r\n}\r\nerr = dbg_check_lpt_nodes(c, (struct ubifs_cnode *)\r\nc->nroot, 0, 0);\r\nif (err)\r\ngoto out;\r\nerr = dbg_check_cats(c);\r\nif (err)\r\ngoto out;\r\n}\r\nif (ret & LPT_SCAN_STOP) {\r\nerr = 0;\r\nbreak;\r\n}\r\nif (lnum == end_lnum) {\r\nerr = -ENOSPC;\r\ngoto out;\r\n}\r\nif (lnum + 1 >= c->leb_cnt) {\r\nstart_lnum = c->main_first;\r\ngoto again;\r\n}\r\nif (iip + 1 < UBIFS_LPT_FANOUT) {\r\niip += 1;\r\ncontinue;\r\n}\r\niip = pnode->iip;\r\nwhile (1) {\r\nh -= 1;\r\nubifs_assert(h >= 0);\r\nnnode = path[h].ptr.nnode;\r\nif (iip + 1 < UBIFS_LPT_FANOUT)\r\nbreak;\r\niip = nnode->iip;\r\n}\r\niip += 1;\r\nh += 1;\r\nfor (; h < c->lpt_hght; h++) {\r\nnnode = scan_get_nnode(c, path + h, nnode, iip);\r\nif (IS_ERR(nnode)) {\r\nerr = PTR_ERR(nnode);\r\ngoto out;\r\n}\r\niip = 0;\r\n}\r\npnode = scan_get_pnode(c, path + h, nnode, iip);\r\nif (IS_ERR(pnode)) {\r\nerr = PTR_ERR(pnode);\r\ngoto out;\r\n}\r\niip = 0;\r\n}\r\nout:\r\nkfree(path);\r\nreturn err;\r\n}\r\nstatic int dbg_chk_pnode(struct ubifs_info *c, struct ubifs_pnode *pnode,\r\nint col)\r\n{\r\nint i;\r\nif (pnode->num != col) {\r\ndbg_err("pnode num %d expected %d parent num %d iip %d",\r\npnode->num, col, pnode->parent->num, pnode->iip);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < UBIFS_LPT_FANOUT; i++) {\r\nstruct ubifs_lprops *lp, *lprops = &pnode->lprops[i];\r\nint lnum = (pnode->num << UBIFS_LPT_FANOUT_SHIFT) + i +\r\nc->main_first;\r\nint found, cat = lprops->flags & LPROPS_CAT_MASK;\r\nstruct ubifs_lpt_heap *heap;\r\nstruct list_head *list = NULL;\r\nif (lnum >= c->leb_cnt)\r\ncontinue;\r\nif (lprops->lnum != lnum) {\r\ndbg_err("bad LEB number %d expected %d",\r\nlprops->lnum, lnum);\r\nreturn -EINVAL;\r\n}\r\nif (lprops->flags & LPROPS_TAKEN) {\r\nif (cat != LPROPS_UNCAT) {\r\ndbg_err("LEB %d taken but not uncat %d",\r\nlprops->lnum, cat);\r\nreturn -EINVAL;\r\n}\r\ncontinue;\r\n}\r\nif (lprops->flags & LPROPS_INDEX) {\r\nswitch (cat) {\r\ncase LPROPS_UNCAT:\r\ncase LPROPS_DIRTY_IDX:\r\ncase LPROPS_FRDI_IDX:\r\nbreak;\r\ndefault:\r\ndbg_err("LEB %d index but cat %d",\r\nlprops->lnum, cat);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nswitch (cat) {\r\ncase LPROPS_UNCAT:\r\ncase LPROPS_DIRTY:\r\ncase LPROPS_FREE:\r\ncase LPROPS_EMPTY:\r\ncase LPROPS_FREEABLE:\r\nbreak;\r\ndefault:\r\ndbg_err("LEB %d not index but cat %d",\r\nlprops->lnum, cat);\r\nreturn -EINVAL;\r\n}\r\n}\r\nswitch (cat) {\r\ncase LPROPS_UNCAT:\r\nlist = &c->uncat_list;\r\nbreak;\r\ncase LPROPS_EMPTY:\r\nlist = &c->empty_list;\r\nbreak;\r\ncase LPROPS_FREEABLE:\r\nlist = &c->freeable_list;\r\nbreak;\r\ncase LPROPS_FRDI_IDX:\r\nlist = &c->frdi_idx_list;\r\nbreak;\r\n}\r\nfound = 0;\r\nswitch (cat) {\r\ncase LPROPS_DIRTY:\r\ncase LPROPS_DIRTY_IDX:\r\ncase LPROPS_FREE:\r\nheap = &c->lpt_heap[cat - 1];\r\nif (lprops->hpos < heap->cnt &&\r\nheap->arr[lprops->hpos] == lprops)\r\nfound = 1;\r\nbreak;\r\ncase LPROPS_UNCAT:\r\ncase LPROPS_EMPTY:\r\ncase LPROPS_FREEABLE:\r\ncase LPROPS_FRDI_IDX:\r\nlist_for_each_entry(lp, list, list)\r\nif (lprops == lp) {\r\nfound = 1;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nif (!found) {\r\ndbg_err("LEB %d cat %d not found in cat heap/list",\r\nlprops->lnum, cat);\r\nreturn -EINVAL;\r\n}\r\nswitch (cat) {\r\ncase LPROPS_EMPTY:\r\nif (lprops->free != c->leb_size) {\r\ndbg_err("LEB %d cat %d free %d dirty %d",\r\nlprops->lnum, cat, lprops->free,\r\nlprops->dirty);\r\nreturn -EINVAL;\r\n}\r\ncase LPROPS_FREEABLE:\r\ncase LPROPS_FRDI_IDX:\r\nif (lprops->free + lprops->dirty != c->leb_size) {\r\ndbg_err("LEB %d cat %d free %d dirty %d",\r\nlprops->lnum, cat, lprops->free,\r\nlprops->dirty);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint dbg_check_lpt_nodes(struct ubifs_info *c, struct ubifs_cnode *cnode,\r\nint row, int col)\r\n{\r\nstruct ubifs_nnode *nnode, *nn;\r\nstruct ubifs_cnode *cn;\r\nint num, iip = 0, err;\r\nif (!dbg_is_chk_lprops(c))\r\nreturn 0;\r\nwhile (cnode) {\r\nubifs_assert(row >= 0);\r\nnnode = cnode->parent;\r\nif (cnode->level) {\r\nnum = calc_nnode_num(row, col);\r\nif (cnode->num != num) {\r\ndbg_err("nnode num %d expected %d "\r\n"parent num %d iip %d", cnode->num, num,\r\n(nnode ? nnode->num : 0), cnode->iip);\r\nreturn -EINVAL;\r\n}\r\nnn = (struct ubifs_nnode *)cnode;\r\nwhile (iip < UBIFS_LPT_FANOUT) {\r\ncn = nn->nbranch[iip].cnode;\r\nif (cn) {\r\nrow += 1;\r\ncol <<= UBIFS_LPT_FANOUT_SHIFT;\r\ncol += iip;\r\niip = 0;\r\ncnode = cn;\r\nbreak;\r\n}\r\niip += 1;\r\n}\r\nif (iip < UBIFS_LPT_FANOUT)\r\ncontinue;\r\n} else {\r\nstruct ubifs_pnode *pnode;\r\npnode = (struct ubifs_pnode *)cnode;\r\nerr = dbg_chk_pnode(c, pnode, col);\r\nif (err)\r\nreturn err;\r\n}\r\nrow -= 1;\r\ncol >>= UBIFS_LPT_FANOUT_SHIFT;\r\niip = cnode->iip + 1;\r\ncnode = (struct ubifs_cnode *)nnode;\r\n}\r\nreturn 0;\r\n}
