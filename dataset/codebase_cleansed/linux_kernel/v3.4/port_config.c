static s32 sci_sas_address_compare(\r\nstruct sci_sas_address address_one,\r\nstruct sci_sas_address address_two)\r\n{\r\nif (address_one.high > address_two.high) {\r\nreturn 1;\r\n} else if (address_one.high < address_two.high) {\r\nreturn -1;\r\n} else if (address_one.low > address_two.low) {\r\nreturn 1;\r\n} else if (address_one.low < address_two.low) {\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct isci_port *sci_port_configuration_agent_find_port(\r\nstruct isci_host *ihost,\r\nstruct isci_phy *iphy)\r\n{\r\nu8 i;\r\nstruct sci_sas_address port_sas_address;\r\nstruct sci_sas_address port_attached_device_address;\r\nstruct sci_sas_address phy_sas_address;\r\nstruct sci_sas_address phy_attached_device_address;\r\nsci_phy_get_sas_address(iphy, &phy_sas_address);\r\nsci_phy_get_attached_sas_address(iphy, &phy_attached_device_address);\r\nfor (i = 0; i < ihost->logical_port_entries; i++) {\r\nstruct isci_port *iport = &ihost->ports[i];\r\nsci_port_get_sas_address(iport, &port_sas_address);\r\nsci_port_get_attached_sas_address(iport, &port_attached_device_address);\r\nif (sci_sas_address_compare(port_sas_address, phy_sas_address) == 0 &&\r\nsci_sas_address_compare(port_attached_device_address, phy_attached_device_address) == 0)\r\nreturn iport;\r\n}\r\nreturn NULL;\r\n}\r\nstatic enum sci_status sci_port_configuration_agent_validate_ports(\r\nstruct isci_host *ihost,\r\nstruct sci_port_configuration_agent *port_agent)\r\n{\r\nstruct sci_sas_address first_address;\r\nstruct sci_sas_address second_address;\r\nif (port_agent->phy_valid_port_range[0].max_index != 0 ||\r\nport_agent->phy_valid_port_range[1].max_index != 1 ||\r\nport_agent->phy_valid_port_range[2].max_index != 2 ||\r\nport_agent->phy_valid_port_range[3].max_index != 3)\r\nreturn SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;\r\nif (port_agent->phy_valid_port_range[0].min_index == 0 &&\r\nport_agent->phy_valid_port_range[1].min_index == 0 &&\r\nport_agent->phy_valid_port_range[2].min_index == 0 &&\r\nport_agent->phy_valid_port_range[3].min_index == 0)\r\nreturn SCI_SUCCESS;\r\nif (port_agent->phy_valid_port_range[2].min_index == 1) {\r\nreturn SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;\r\n}\r\nsci_phy_get_sas_address(&ihost->phys[0], &first_address);\r\nsci_phy_get_sas_address(&ihost->phys[3], &second_address);\r\nif (sci_sas_address_compare(first_address, second_address) == 0) {\r\nreturn SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;\r\n}\r\nif (port_agent->phy_valid_port_range[0].min_index == 0 &&\r\nport_agent->phy_valid_port_range[1].min_index == 1) {\r\nsci_phy_get_sas_address(&ihost->phys[0], &first_address);\r\nsci_phy_get_sas_address(&ihost->phys[2], &second_address);\r\nif (sci_sas_address_compare(first_address, second_address) == 0) {\r\nreturn SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;\r\n}\r\n}\r\nif (port_agent->phy_valid_port_range[2].min_index == 2 &&\r\nport_agent->phy_valid_port_range[3].min_index == 3) {\r\nsci_phy_get_sas_address(&ihost->phys[1], &first_address);\r\nsci_phy_get_sas_address(&ihost->phys[3], &second_address);\r\nif (sci_sas_address_compare(first_address, second_address) == 0) {\r\nreturn SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;\r\n}\r\n}\r\nreturn SCI_SUCCESS;\r\n}\r\nstatic enum sci_status\r\nsci_mpc_agent_validate_phy_configuration(struct isci_host *ihost,\r\nstruct sci_port_configuration_agent *port_agent)\r\n{\r\nu32 phy_mask;\r\nu32 assigned_phy_mask;\r\nstruct sci_sas_address sas_address;\r\nstruct sci_sas_address phy_assigned_address;\r\nu8 port_index;\r\nu8 phy_index;\r\nassigned_phy_mask = 0;\r\nsas_address.high = 0;\r\nsas_address.low = 0;\r\nfor (port_index = 0; port_index < SCI_MAX_PORTS; port_index++) {\r\nphy_mask = ihost->oem_parameters.ports[port_index].phy_mask;\r\nif (!phy_mask)\r\ncontinue;\r\nif ((phy_mask & ~assigned_phy_mask) == 0) {\r\nreturn SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;\r\n}\r\nfor (phy_index = 0; phy_index < SCI_MAX_PHYS; phy_index++) {\r\nif ((phy_mask & (1 << phy_index)) == 0)\r\ncontinue;\r\nsci_phy_get_sas_address(&ihost->phys[phy_index],\r\n&sas_address);\r\nport_agent->phy_valid_port_range[phy_index].min_index = port_index;\r\nport_agent->phy_valid_port_range[phy_index].max_index = phy_index;\r\nif (phy_index != port_index) {\r\nreturn SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;\r\n}\r\nbreak;\r\n}\r\nwhile (phy_index < SCI_MAX_PHYS) {\r\nif ((phy_mask & (1 << phy_index)) == 0)\r\ncontinue;\r\nsci_phy_get_sas_address(&ihost->phys[phy_index],\r\n&phy_assigned_address);\r\nif (sci_sas_address_compare(sas_address, phy_assigned_address) != 0) {\r\nreturn SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;\r\n}\r\nport_agent->phy_valid_port_range[phy_index].min_index = port_index;\r\nport_agent->phy_valid_port_range[phy_index].max_index = phy_index;\r\nsci_port_add_phy(&ihost->ports[port_index],\r\n&ihost->phys[phy_index]);\r\nassigned_phy_mask |= (1 << phy_index);\r\n}\r\nphy_index++;\r\n}\r\nreturn sci_port_configuration_agent_validate_ports(ihost, port_agent);\r\n}\r\nstatic void mpc_agent_timeout(unsigned long data)\r\n{\r\nu8 index;\r\nstruct sci_timer *tmr = (struct sci_timer *)data;\r\nstruct sci_port_configuration_agent *port_agent;\r\nstruct isci_host *ihost;\r\nunsigned long flags;\r\nu16 configure_phy_mask;\r\nport_agent = container_of(tmr, typeof(*port_agent), timer);\r\nihost = container_of(port_agent, typeof(*ihost), port_agent);\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nif (tmr->cancel)\r\ngoto done;\r\nport_agent->timer_pending = false;\r\nconfigure_phy_mask = ~port_agent->phy_configured_mask & port_agent->phy_ready_mask;\r\nfor (index = 0; index < SCI_MAX_PHYS; index++) {\r\nstruct isci_phy *iphy = &ihost->phys[index];\r\nif (configure_phy_mask & (1 << index)) {\r\nport_agent->link_up_handler(ihost, port_agent,\r\nphy_get_non_dummy_port(iphy),\r\niphy);\r\n}\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\n}\r\nstatic void sci_mpc_agent_link_up(struct isci_host *ihost,\r\nstruct sci_port_configuration_agent *port_agent,\r\nstruct isci_port *iport,\r\nstruct isci_phy *iphy)\r\n{\r\nif (!iport)\r\nreturn;\r\nport_agent->phy_ready_mask |= (1 << iphy->phy_index);\r\nsci_port_link_up(iport, iphy);\r\nif ((iport->active_phy_mask & (1 << iphy->phy_index)))\r\nport_agent->phy_configured_mask |= (1 << iphy->phy_index);\r\n}\r\nstatic void sci_mpc_agent_link_down(\r\nstruct isci_host *ihost,\r\nstruct sci_port_configuration_agent *port_agent,\r\nstruct isci_port *iport,\r\nstruct isci_phy *iphy)\r\n{\r\nif (iport != NULL) {\r\nport_agent->phy_ready_mask &= ~(1 << iphy->phy_index);\r\nport_agent->phy_configured_mask &= ~(1 << iphy->phy_index);\r\nif ((port_agent->phy_configured_mask == 0x0000) &&\r\n(port_agent->phy_ready_mask != 0x0000) &&\r\n!port_agent->timer_pending) {\r\nport_agent->timer_pending = true;\r\nsci_mod_timer(&port_agent->timer,\r\nSCIC_SDS_MPC_RECONFIGURATION_TIMEOUT);\r\n}\r\nsci_port_link_down(iport, iphy);\r\n}\r\n}\r\nstatic enum sci_status\r\nsci_apc_agent_validate_phy_configuration(struct isci_host *ihost,\r\nstruct sci_port_configuration_agent *port_agent)\r\n{\r\nu8 phy_index;\r\nu8 port_index;\r\nstruct sci_sas_address sas_address;\r\nstruct sci_sas_address phy_assigned_address;\r\nphy_index = 0;\r\nwhile (phy_index < SCI_MAX_PHYS) {\r\nport_index = phy_index;\r\nsci_phy_get_sas_address(&ihost->phys[phy_index],\r\n&sas_address);\r\nwhile (++phy_index < SCI_MAX_PHYS) {\r\nsci_phy_get_sas_address(&ihost->phys[phy_index],\r\n&phy_assigned_address);\r\nif (sci_sas_address_compare(sas_address, phy_assigned_address) == 0) {\r\nport_agent->phy_valid_port_range[phy_index].min_index = port_index;\r\nport_agent->phy_valid_port_range[phy_index].max_index = phy_index;\r\n} else {\r\nport_agent->phy_valid_port_range[phy_index].min_index = phy_index;\r\nport_agent->phy_valid_port_range[phy_index].max_index = phy_index;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn sci_port_configuration_agent_validate_ports(ihost, port_agent);\r\n}\r\nstatic void sci_apc_agent_start_timer(\r\nstruct sci_port_configuration_agent *port_agent,\r\nu32 timeout)\r\n{\r\nif (port_agent->timer_pending)\r\nsci_del_timer(&port_agent->timer);\r\nport_agent->timer_pending = true;\r\nsci_mod_timer(&port_agent->timer, timeout);\r\n}\r\nstatic void sci_apc_agent_configure_ports(struct isci_host *ihost,\r\nstruct sci_port_configuration_agent *port_agent,\r\nstruct isci_phy *iphy,\r\nbool start_timer)\r\n{\r\nu8 port_index;\r\nenum sci_status status;\r\nstruct isci_port *iport;\r\nenum SCIC_SDS_APC_ACTIVITY apc_activity = SCIC_SDS_APC_SKIP_PHY;\r\niport = sci_port_configuration_agent_find_port(ihost, iphy);\r\nif (iport) {\r\nif (sci_port_is_valid_phy_assignment(iport, iphy->phy_index))\r\napc_activity = SCIC_SDS_APC_ADD_PHY;\r\nelse\r\napc_activity = SCIC_SDS_APC_SKIP_PHY;\r\n} else {\r\nfor (port_index = port_agent->phy_valid_port_range[iphy->phy_index].min_index;\r\nport_index <= port_agent->phy_valid_port_range[iphy->phy_index].max_index;\r\nport_index++) {\r\niport = &ihost->ports[port_index];\r\nif (sci_port_is_valid_phy_assignment(iport, iphy->phy_index)) {\r\nif (iport->active_phy_mask > (1 << iphy->phy_index)) {\r\napc_activity = SCIC_SDS_APC_SKIP_PHY;\r\nbreak;\r\n}\r\nif (iport->physical_port_index == iphy->phy_index) {\r\nif (apc_activity != SCIC_SDS_APC_START_TIMER) {\r\napc_activity = SCIC_SDS_APC_ADD_PHY;\r\n}\r\nbreak;\r\n}\r\nif (iport->active_phy_mask == 0) {\r\napc_activity = SCIC_SDS_APC_START_TIMER;\r\n}\r\n} else if (iport->active_phy_mask != 0) {\r\napc_activity = SCIC_SDS_APC_SKIP_PHY;\r\n}\r\n}\r\n}\r\nif (\r\n(start_timer == false)\r\n&& (apc_activity == SCIC_SDS_APC_START_TIMER)\r\n) {\r\napc_activity = SCIC_SDS_APC_ADD_PHY;\r\n}\r\nswitch (apc_activity) {\r\ncase SCIC_SDS_APC_ADD_PHY:\r\nstatus = sci_port_add_phy(iport, iphy);\r\nif (status == SCI_SUCCESS) {\r\nport_agent->phy_configured_mask |= (1 << iphy->phy_index);\r\n}\r\nbreak;\r\ncase SCIC_SDS_APC_START_TIMER:\r\nsci_apc_agent_start_timer(port_agent,\r\nSCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION);\r\nbreak;\r\ncase SCIC_SDS_APC_SKIP_PHY:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void sci_apc_agent_link_up(struct isci_host *ihost,\r\nstruct sci_port_configuration_agent *port_agent,\r\nstruct isci_port *iport,\r\nstruct isci_phy *iphy)\r\n{\r\nu8 phy_index = iphy->phy_index;\r\nif (!iport) {\r\nport_agent->phy_ready_mask |= 1 << phy_index;\r\nsci_apc_agent_start_timer(port_agent,\r\nSCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION);\r\n} else {\r\nu32 port_state = iport->sm.current_state_id;\r\nBUG_ON(port_state != SCI_PORT_RESETTING);\r\nport_agent->phy_ready_mask |= 1 << phy_index;\r\nsci_port_link_up(iport, iphy);\r\n}\r\n}\r\nstatic void sci_apc_agent_link_down(\r\nstruct isci_host *ihost,\r\nstruct sci_port_configuration_agent *port_agent,\r\nstruct isci_port *iport,\r\nstruct isci_phy *iphy)\r\n{\r\nport_agent->phy_ready_mask &= ~(1 << iphy->phy_index);\r\nif (!iport)\r\nreturn;\r\nif (port_agent->phy_configured_mask & (1 << iphy->phy_index)) {\r\nenum sci_status status;\r\nstatus = sci_port_remove_phy(iport, iphy);\r\nif (status == SCI_SUCCESS)\r\nport_agent->phy_configured_mask &= ~(1 << iphy->phy_index);\r\n}\r\n}\r\nstatic void apc_agent_timeout(unsigned long data)\r\n{\r\nu32 index;\r\nstruct sci_timer *tmr = (struct sci_timer *)data;\r\nstruct sci_port_configuration_agent *port_agent;\r\nstruct isci_host *ihost;\r\nunsigned long flags;\r\nu16 configure_phy_mask;\r\nport_agent = container_of(tmr, typeof(*port_agent), timer);\r\nihost = container_of(port_agent, typeof(*ihost), port_agent);\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nif (tmr->cancel)\r\ngoto done;\r\nport_agent->timer_pending = false;\r\nconfigure_phy_mask = ~port_agent->phy_configured_mask & port_agent->phy_ready_mask;\r\nif (!configure_phy_mask)\r\ngoto done;\r\nfor (index = 0; index < SCI_MAX_PHYS; index++) {\r\nif ((configure_phy_mask & (1 << index)) == 0)\r\ncontinue;\r\nsci_apc_agent_configure_ports(ihost, port_agent,\r\n&ihost->phys[index], false);\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\n}\r\nvoid sci_port_configuration_agent_construct(\r\nstruct sci_port_configuration_agent *port_agent)\r\n{\r\nu32 index;\r\nport_agent->phy_configured_mask = 0x00;\r\nport_agent->phy_ready_mask = 0x00;\r\nport_agent->link_up_handler = NULL;\r\nport_agent->link_down_handler = NULL;\r\nport_agent->timer_pending = false;\r\nfor (index = 0; index < SCI_MAX_PORTS; index++) {\r\nport_agent->phy_valid_port_range[index].min_index = 0;\r\nport_agent->phy_valid_port_range[index].max_index = 0;\r\n}\r\n}\r\nenum sci_status sci_port_configuration_agent_initialize(\r\nstruct isci_host *ihost,\r\nstruct sci_port_configuration_agent *port_agent)\r\n{\r\nenum sci_status status;\r\nenum sci_port_configuration_mode mode;\r\nmode = ihost->oem_parameters.controller.mode_type;\r\nif (mode == SCIC_PORT_MANUAL_CONFIGURATION_MODE) {\r\nstatus = sci_mpc_agent_validate_phy_configuration(\r\nihost, port_agent);\r\nport_agent->link_up_handler = sci_mpc_agent_link_up;\r\nport_agent->link_down_handler = sci_mpc_agent_link_down;\r\nsci_init_timer(&port_agent->timer, mpc_agent_timeout);\r\n} else {\r\nstatus = sci_apc_agent_validate_phy_configuration(\r\nihost, port_agent);\r\nport_agent->link_up_handler = sci_apc_agent_link_up;\r\nport_agent->link_down_handler = sci_apc_agent_link_down;\r\nsci_init_timer(&port_agent->timer, apc_agent_timeout);\r\n}\r\nreturn status;\r\n}
