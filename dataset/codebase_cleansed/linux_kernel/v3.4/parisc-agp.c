static int\r\nparisc_agp_fetch_size(void)\r\n{\r\nint size;\r\nsize = parisc_agp_info.gart_size / MB(1);\r\nparisc_agp_sizes[0].size = size;\r\nagp_bridge->current_size = (void *) &parisc_agp_sizes[0];\r\nreturn size;\r\n}\r\nstatic int\r\nparisc_agp_configure(void)\r\n{\r\nstruct _parisc_agp_info *info = &parisc_agp_info;\r\nagp_bridge->gart_bus_addr = info->gart_base;\r\nagp_bridge->capndx = info->lba_cap_offset;\r\nagp_bridge->mode = readl(info->lba_regs+info->lba_cap_offset+PCI_AGP_STATUS);\r\nreturn 0;\r\n}\r\nstatic void\r\nparisc_agp_tlbflush(struct agp_memory *mem)\r\n{\r\nstruct _parisc_agp_info *info = &parisc_agp_info;\r\nwriteq(info->gart_base | ilog2(info->gart_size), info->ioc_regs+IOC_PCOM);\r\nreadq(info->ioc_regs+IOC_PCOM);\r\n}\r\nstatic int\r\nparisc_agp_create_gatt_table(struct agp_bridge_data *bridge)\r\n{\r\nstruct _parisc_agp_info *info = &parisc_agp_info;\r\nint i;\r\nfor (i = 0; i < info->gatt_entries; i++) {\r\ninfo->gatt[i] = (unsigned long)agp_bridge->scratch_page;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nparisc_agp_free_gatt_table(struct agp_bridge_data *bridge)\r\n{\r\nstruct _parisc_agp_info *info = &parisc_agp_info;\r\ninfo->gatt[0] = SBA_AGPGART_COOKIE;\r\nreturn 0;\r\n}\r\nstatic int\r\nparisc_agp_insert_memory(struct agp_memory *mem, off_t pg_start, int type)\r\n{\r\nstruct _parisc_agp_info *info = &parisc_agp_info;\r\nint i, k;\r\noff_t j, io_pg_start;\r\nint io_pg_count;\r\nif (type != 0 || mem->type != 0) {\r\nreturn -EINVAL;\r\n}\r\nio_pg_start = info->io_pages_per_kpage * pg_start;\r\nio_pg_count = info->io_pages_per_kpage * mem->page_count;\r\nif ((io_pg_start + io_pg_count) > info->gatt_entries) {\r\nreturn -EINVAL;\r\n}\r\nj = io_pg_start;\r\nwhile (j < (io_pg_start + io_pg_count)) {\r\nif (info->gatt[j])\r\nreturn -EBUSY;\r\nj++;\r\n}\r\nif (!mem->is_flushed) {\r\nglobal_cache_flush();\r\nmem->is_flushed = true;\r\n}\r\nfor (i = 0, j = io_pg_start; i < mem->page_count; i++) {\r\nunsigned long paddr;\r\npaddr = page_to_phys(mem->pages[i]);\r\nfor (k = 0;\r\nk < info->io_pages_per_kpage;\r\nk++, j++, paddr += info->io_page_size) {\r\ninfo->gatt[j] =\r\nparisc_agp_mask_memory(agp_bridge,\r\npaddr, type);\r\n}\r\n}\r\nagp_bridge->driver->tlb_flush(mem);\r\nreturn 0;\r\n}\r\nstatic int\r\nparisc_agp_remove_memory(struct agp_memory *mem, off_t pg_start, int type)\r\n{\r\nstruct _parisc_agp_info *info = &parisc_agp_info;\r\nint i, io_pg_start, io_pg_count;\r\nif (type != 0 || mem->type != 0) {\r\nreturn -EINVAL;\r\n}\r\nio_pg_start = info->io_pages_per_kpage * pg_start;\r\nio_pg_count = info->io_pages_per_kpage * mem->page_count;\r\nfor (i = io_pg_start; i < io_pg_count + io_pg_start; i++) {\r\ninfo->gatt[i] = agp_bridge->scratch_page;\r\n}\r\nagp_bridge->driver->tlb_flush(mem);\r\nreturn 0;\r\n}\r\nstatic unsigned long\r\nparisc_agp_mask_memory(struct agp_bridge_data *bridge, dma_addr_t addr,\r\nint type)\r\n{\r\nreturn SBA_PDIR_VALID_BIT | addr;\r\n}\r\nstatic void\r\nparisc_agp_enable(struct agp_bridge_data *bridge, u32 mode)\r\n{\r\nstruct _parisc_agp_info *info = &parisc_agp_info;\r\nu32 command;\r\ncommand = readl(info->lba_regs + info->lba_cap_offset + PCI_AGP_STATUS);\r\ncommand = agp_collect_device_status(bridge, mode, command);\r\ncommand |= 0x00000100;\r\nwritel(command, info->lba_regs + info->lba_cap_offset + PCI_AGP_COMMAND);\r\nagp_device_command(command, (mode & AGP8X_MODE) != 0);\r\n}\r\nstatic int __init\r\nagp_ioc_init(void __iomem *ioc_regs)\r\n{\r\nstruct _parisc_agp_info *info = &parisc_agp_info;\r\nu64 iova_base, *io_pdir, io_tlb_ps;\r\nint io_tlb_shift;\r\nprintk(KERN_INFO DRVPFX "IO PDIR shared with sba_iommu\n");\r\ninfo->ioc_regs = ioc_regs;\r\nio_tlb_ps = readq(info->ioc_regs+IOC_TCNFG);\r\nswitch (io_tlb_ps) {\r\ncase 0: io_tlb_shift = 12; break;\r\ncase 1: io_tlb_shift = 13; break;\r\ncase 2: io_tlb_shift = 14; break;\r\ncase 3: io_tlb_shift = 16; break;\r\ndefault:\r\nprintk(KERN_ERR DRVPFX "Invalid IOTLB page size "\r\n"configuration 0x%llx\n", io_tlb_ps);\r\ninfo->gatt = NULL;\r\ninfo->gatt_entries = 0;\r\nreturn -ENODEV;\r\n}\r\ninfo->io_page_size = 1 << io_tlb_shift;\r\ninfo->io_pages_per_kpage = PAGE_SIZE / info->io_page_size;\r\niova_base = readq(info->ioc_regs+IOC_IBASE) & ~0x1;\r\ninfo->gart_base = iova_base + PLUTO_IOVA_SIZE - PLUTO_GART_SIZE;\r\ninfo->gart_size = PLUTO_GART_SIZE;\r\ninfo->gatt_entries = info->gart_size / info->io_page_size;\r\nio_pdir = phys_to_virt(readq(info->ioc_regs+IOC_PDIR_BASE));\r\ninfo->gatt = &io_pdir[(PLUTO_IOVA_SIZE/2) >> PAGE_SHIFT];\r\nif (info->gatt[0] != SBA_AGPGART_COOKIE) {\r\ninfo->gatt = NULL;\r\ninfo->gatt_entries = 0;\r\nprintk(KERN_ERR DRVPFX "No reserved IO PDIR entry found; "\r\n"GART disabled\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlba_find_capability(int cap)\r\n{\r\nstruct _parisc_agp_info *info = &parisc_agp_info;\r\nu16 status;\r\nu8 pos, id;\r\nint ttl = 48;\r\nstatus = readw(info->lba_regs + PCI_STATUS);\r\nif (!(status & PCI_STATUS_CAP_LIST))\r\nreturn 0;\r\npos = readb(info->lba_regs + PCI_CAPABILITY_LIST);\r\nwhile (ttl-- && pos >= 0x40) {\r\npos &= ~3;\r\nid = readb(info->lba_regs + pos + PCI_CAP_LIST_ID);\r\nif (id == 0xff)\r\nbreak;\r\nif (id == cap)\r\nreturn pos;\r\npos = readb(info->lba_regs + pos + PCI_CAP_LIST_NEXT);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init\r\nagp_lba_init(void __iomem *lba_hpa)\r\n{\r\nstruct _parisc_agp_info *info = &parisc_agp_info;\r\nint cap;\r\ninfo->lba_regs = lba_hpa;\r\ninfo->lba_cap_offset = lba_find_capability(PCI_CAP_ID_AGP);\r\ncap = readl(lba_hpa + info->lba_cap_offset) & 0xff;\r\nif (cap != PCI_CAP_ID_AGP) {\r\nprintk(KERN_ERR DRVPFX "Invalid capability ID 0x%02x at 0x%x\n",\r\ncap, info->lba_cap_offset);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init\r\nparisc_agp_setup(void __iomem *ioc_hpa, void __iomem *lba_hpa)\r\n{\r\nstruct pci_dev *fake_bridge_dev = NULL;\r\nstruct agp_bridge_data *bridge;\r\nint error = 0;\r\nfake_bridge_dev = alloc_pci_dev();\r\nif (!fake_bridge_dev) {\r\nerror = -ENOMEM;\r\ngoto fail;\r\n}\r\nerror = agp_ioc_init(ioc_hpa);\r\nif (error)\r\ngoto fail;\r\nerror = agp_lba_init(lba_hpa);\r\nif (error)\r\ngoto fail;\r\nbridge = agp_alloc_bridge();\r\nif (!bridge) {\r\nerror = -ENOMEM;\r\ngoto fail;\r\n}\r\nbridge->driver = &parisc_agp_driver;\r\nfake_bridge_dev->vendor = PCI_VENDOR_ID_HP;\r\nfake_bridge_dev->device = PCI_DEVICE_ID_HP_PCIX_LBA;\r\nbridge->dev = fake_bridge_dev;\r\nerror = agp_add_bridge(bridge);\r\nif (error)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nkfree(fake_bridge_dev);\r\nreturn error;\r\n}\r\nstatic int\r\nfind_quicksilver(struct device *dev, void *data)\r\n{\r\nstruct parisc_device **lba = data;\r\nstruct parisc_device *padev = to_parisc_device(dev);\r\nif (IS_QUICKSILVER(padev))\r\n*lba = padev;\r\nreturn 0;\r\n}\r\nstatic int\r\nparisc_agp_init(void)\r\n{\r\nextern struct sba_device *sba_list;\r\nint err = -1;\r\nstruct parisc_device *sba = NULL, *lba = NULL;\r\nstruct lba_device *lbadev = NULL;\r\nif (!sba_list)\r\ngoto out;\r\nsba = sba_list->dev;\r\nif (!IS_PLUTO(sba)) {\r\nprintk(KERN_INFO DRVPFX "No Pluto found, so no AGPGART for you.\n");\r\ngoto out;\r\n}\r\ndevice_for_each_child(&sba->dev, &lba, find_quicksilver);\r\nif (!lba) {\r\nprintk(KERN_INFO DRVPFX "No AGP devices found.\n");\r\ngoto out;\r\n}\r\nlbadev = parisc_get_drvdata(lba);\r\nparisc_agp_setup(sba_list->ioc[0].ioc_hpa, lbadev->hba.base_addr);\r\nreturn 0;\r\nout:\r\nreturn err;\r\n}
