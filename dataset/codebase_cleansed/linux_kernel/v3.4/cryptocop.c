static void free_cdesc(struct cryptocop_dma_desc *cdesc)\r\n{\r\nDEBUG(printk("free_cdesc: cdesc 0x%p, from_pool=%d\n", cdesc, cdesc->from_pool));\r\nkfree(cdesc->free_buf);\r\nif (cdesc->from_pool) {\r\nunsigned long int flags;\r\nspin_lock_irqsave(&descr_pool_lock, flags);\r\ncdesc->next = descr_pool_free_list;\r\ndescr_pool_free_list = cdesc;\r\n++descr_pool_no_free;\r\nspin_unlock_irqrestore(&descr_pool_lock, flags);\r\n} else {\r\nkfree(cdesc);\r\n}\r\n}\r\nstatic struct cryptocop_dma_desc *alloc_cdesc(int alloc_flag)\r\n{\r\nint use_pool = (alloc_flag & GFP_ATOMIC) ? 1 : 0;\r\nstruct cryptocop_dma_desc *cdesc;\r\nif (use_pool) {\r\nunsigned long int flags;\r\nspin_lock_irqsave(&descr_pool_lock, flags);\r\nif (!descr_pool_free_list) {\r\nspin_unlock_irqrestore(&descr_pool_lock, flags);\r\nDEBUG_API(printk("alloc_cdesc: pool is empty\n"));\r\nreturn NULL;\r\n}\r\ncdesc = descr_pool_free_list;\r\ndescr_pool_free_list = descr_pool_free_list->next;\r\n--descr_pool_no_free;\r\nspin_unlock_irqrestore(&descr_pool_lock, flags);\r\ncdesc->from_pool = 1;\r\n} else {\r\ncdesc = kmalloc(sizeof(struct cryptocop_dma_desc), alloc_flag);\r\nif (!cdesc) {\r\nDEBUG_API(printk("alloc_cdesc: kmalloc\n"));\r\nreturn NULL;\r\n}\r\ncdesc->from_pool = 0;\r\n}\r\ncdesc->dma_descr = (dma_descr_data*)(((unsigned long int)cdesc + offsetof(struct cryptocop_dma_desc, dma_descr_buf) + DESCR_ALLOC_PAD) & ~0x0000001F);\r\ncdesc->next = NULL;\r\ncdesc->free_buf = NULL;\r\ncdesc->dma_descr->out_eop = 0;\r\ncdesc->dma_descr->in_eop = 0;\r\ncdesc->dma_descr->intr = 0;\r\ncdesc->dma_descr->eol = 0;\r\ncdesc->dma_descr->wait = 0;\r\ncdesc->dma_descr->buf = NULL;\r\ncdesc->dma_descr->after = NULL;\r\nDEBUG_API(printk("alloc_cdesc: return 0x%p, cdesc->dma_descr=0x%p, from_pool=%d\n", cdesc, cdesc->dma_descr, cdesc->from_pool));\r\nreturn cdesc;\r\n}\r\nstatic void setup_descr_chain(struct cryptocop_dma_desc *cd)\r\n{\r\nDEBUG(printk("setup_descr_chain: entering\n"));\r\nwhile (cd) {\r\nif (cd->next) {\r\ncd->dma_descr->next = (dma_descr_data*)virt_to_phys(cd->next->dma_descr);\r\n} else {\r\ncd->dma_descr->next = NULL;\r\n}\r\ncd = cd->next;\r\n}\r\nDEBUG(printk("setup_descr_chain: exit\n"));\r\n}\r\nstatic int create_pad_descriptor(struct cryptocop_tfrm_ctx *tc, struct cryptocop_dma_desc **pad_desc, int alloc_flag)\r\n{\r\nstruct cryptocop_dma_desc *cdesc = NULL;\r\nint error = 0;\r\nstruct strcop_meta_out mo = {\r\n.ciphsel = src_none,\r\n.hashsel = src_none,\r\n.csumsel = src_none\r\n};\r\nchar *pad;\r\nsize_t plen;\r\nDEBUG(printk("create_pad_descriptor: start.\n"));\r\nDEBUG(printk("create_pad_descriptor: setting up padding.\n"));\r\ncdesc = alloc_cdesc(alloc_flag);\r\nif (!cdesc){\r\nDEBUG_API(printk("create_pad_descriptor: alloc pad desc\n"));\r\ngoto error_cleanup;\r\n}\r\nswitch (tc->unit_no) {\r\ncase src_md5:\r\nerror = create_md5_pad(alloc_flag, tc->consumed, &pad, &plen);\r\nif (error){\r\nDEBUG_API(printk("create_pad_descriptor: create_md5_pad_failed\n"));\r\ngoto error_cleanup;\r\n}\r\ncdesc->free_buf = pad;\r\nmo.hashsel = src_dma;\r\nmo.hashconf = tc->hash_conf;\r\nmo.hashmode = tc->hash_mode;\r\nbreak;\r\ncase src_sha1:\r\nerror = create_sha1_pad(alloc_flag, tc->consumed, &pad, &plen);\r\nif (error){\r\nDEBUG_API(printk("create_pad_descriptor: create_sha1_pad_failed\n"));\r\ngoto error_cleanup;\r\n}\r\ncdesc->free_buf = pad;\r\nmo.hashsel = src_dma;\r\nmo.hashconf = tc->hash_conf;\r\nmo.hashmode = tc->hash_mode;\r\nbreak;\r\ncase src_csum:\r\nif (tc->consumed % tc->blocklength){\r\npad = (char*)csum_zero_pad;\r\nplen = 1;\r\n} else {\r\npad = (char*)cdesc;\r\nplen = 0;\r\n}\r\nmo.csumsel = src_dma;\r\nbreak;\r\n}\r\ncdesc->dma_descr->wait = 1;\r\ncdesc->dma_descr->out_eop = 1;\r\ncdesc->dma_descr->buf = (char*)virt_to_phys((char*)pad);\r\ncdesc->dma_descr->after = cdesc->dma_descr->buf + plen;\r\ncdesc->dma_descr->md = REG_TYPE_CONV(unsigned short int, struct strcop_meta_out, mo);\r\n*pad_desc = cdesc;\r\nreturn 0;\r\nerror_cleanup:\r\nif (cdesc) free_cdesc(cdesc);\r\nreturn -1;\r\n}\r\nstatic int setup_key_dl_desc(struct cryptocop_tfrm_ctx *tc, struct cryptocop_dma_desc **kd, int alloc_flag)\r\n{\r\nstruct cryptocop_dma_desc *key_desc = alloc_cdesc(alloc_flag);\r\nstruct strcop_meta_out mo = {0};\r\nDEBUG(printk("setup_key_dl_desc\n"));\r\nif (!key_desc) {\r\nDEBUG_API(printk("setup_key_dl_desc: failed descriptor allocation.\n"));\r\nreturn -ENOMEM;\r\n}\r\nif ((tc->tctx->init.alg == cryptocop_alg_aes) && (tc->tcfg->flags & CRYPTOCOP_DECRYPT)) {\r\nif (!tc->tctx->dec_key_set){\r\nget_aes_decrypt_key(tc->tctx->dec_key, tc->tctx->init.key, tc->tctx->init.keylen);\r\ntc->tctx->dec_key_set = 1;\r\n}\r\nkey_desc->dma_descr->buf = (char*)virt_to_phys(tc->tctx->dec_key);\r\nkey_desc->dma_descr->after = key_desc->dma_descr->buf + tc->tctx->init.keylen/8;\r\n} else {\r\nkey_desc->dma_descr->buf = (char*)virt_to_phys(tc->tctx->init.key);\r\nkey_desc->dma_descr->after = key_desc->dma_descr->buf + tc->tctx->init.keylen/8;\r\n}\r\nmo.dlkey = 1;\r\nswitch (tc->tctx->init.keylen) {\r\ncase 64:\r\nmo.decrypt = 0;\r\nmo.hashmode = 0;\r\nbreak;\r\ncase 128:\r\nmo.decrypt = 0;\r\nmo.hashmode = 1;\r\nbreak;\r\ncase 192:\r\nmo.decrypt = 1;\r\nmo.hashmode = 0;\r\nbreak;\r\ncase 256:\r\nmo.decrypt = 1;\r\nmo.hashmode = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmo.ciphsel = mo.hashsel = mo.csumsel = src_none;\r\nkey_desc->dma_descr->md = REG_TYPE_CONV(unsigned short int, struct strcop_meta_out, mo);\r\nkey_desc->dma_descr->out_eop = 1;\r\nkey_desc->dma_descr->wait = 1;\r\nkey_desc->dma_descr->intr = 0;\r\n*kd = key_desc;\r\nreturn 0;\r\n}\r\nstatic int setup_cipher_iv_desc(struct cryptocop_tfrm_ctx *tc, struct cryptocop_dma_desc **id, int alloc_flag)\r\n{\r\nstruct cryptocop_dma_desc *iv_desc = alloc_cdesc(alloc_flag);\r\nstruct strcop_meta_out mo = {0};\r\nDEBUG(printk("setup_cipher_iv_desc\n"));\r\nif (!iv_desc) {\r\nDEBUG_API(printk("setup_cipher_iv_desc: failed CBC IV descriptor allocation.\n"));\r\nreturn -ENOMEM;\r\n}\r\niv_desc->dma_descr->buf = (char*)virt_to_phys(tc->tcfg->iv);\r\niv_desc->dma_descr->after = iv_desc->dma_descr->buf + tc->blocklength;\r\nmo.hashsel = mo.csumsel = src_none;\r\nmo.ciphsel = src_dma;\r\nmo.ciphconf = tc->ciph_conf;\r\nmo.cbcmode = tc->cbcmode;\r\niv_desc->dma_descr->md = REG_TYPE_CONV(unsigned short int, struct strcop_meta_out, mo);\r\niv_desc->dma_descr->out_eop = 0;\r\niv_desc->dma_descr->wait = 1;\r\niv_desc->dma_descr->intr = 0;\r\n*id = iv_desc;\r\nreturn 0;\r\n}\r\nstatic int create_input_descriptors(struct cryptocop_operation *operation, struct cryptocop_tfrm_ctx *tc, struct cryptocop_dma_desc **id, int alloc_flag)\r\n{\r\nint err = 0;\r\nstruct cryptocop_dma_desc head = {0};\r\nstruct cryptocop_dma_desc *outdesc = &head;\r\nsize_t iov_offset = 0;\r\nsize_t out_ix = 0;\r\nint outiov_ix = 0;\r\nstruct strcop_meta_in mi = {0};\r\nsize_t out_length = tc->produced;\r\nint rem_length;\r\nint dlength;\r\nassert(out_length != 0);\r\nif (((tc->produced + tc->tcfg->inject_ix) > operation->tfrm_op.outlen) || (tc->produced && (operation->tfrm_op.outlen == 0))) {\r\nDEBUG_API(printk("create_input_descriptors: operation outdata too small\n"));\r\nreturn -EINVAL;\r\n}\r\nwhile ((outiov_ix < operation->tfrm_op.outcount) && ((out_ix + operation->tfrm_op.outdata[outiov_ix].iov_len) <= tc->tcfg->inject_ix)){\r\nout_ix += operation->tfrm_op.outdata[outiov_ix].iov_len;\r\noutiov_ix++;\r\n}\r\nif (outiov_ix >= operation->tfrm_op.outcount){\r\nDEBUG_API(printk("create_input_descriptors: operation outdata too small\n"));\r\nreturn -EINVAL;\r\n}\r\niov_offset = tc->tcfg->inject_ix - out_ix;\r\nmi.dmasel = tc->unit_no;\r\nwhile ((out_length > 0) && (outiov_ix < operation->tfrm_op.outcount)) {\r\noutdesc->next = alloc_cdesc(alloc_flag);\r\nif (!outdesc->next) {\r\nDEBUG_API(printk("create_input_descriptors: alloc_cdesc\n"));\r\nerr = -ENOMEM;\r\ngoto error_cleanup;\r\n}\r\noutdesc = outdesc->next;\r\nrem_length = operation->tfrm_op.outdata[outiov_ix].iov_len - iov_offset;\r\ndlength = (out_length < rem_length) ? out_length : rem_length;\r\nDEBUG(printk("create_input_descriptors:\n"\r\n"outiov_ix=%d, rem_length=%d, dlength=%d\n"\r\n"iov_offset=%d, outdata[outiov_ix].iov_len=%d\n"\r\n"outcount=%d, outiov_ix=%d\n",\r\noutiov_ix, rem_length, dlength, iov_offset, operation->tfrm_op.outdata[outiov_ix].iov_len, operation->tfrm_op.outcount, outiov_ix));\r\noutdesc->dma_descr->buf = (char*)virt_to_phys(operation->tfrm_op.outdata[outiov_ix].iov_base + iov_offset);\r\noutdesc->dma_descr->after = outdesc->dma_descr->buf + dlength;\r\noutdesc->dma_descr->md = REG_TYPE_CONV(unsigned short int, struct strcop_meta_in, mi);\r\nout_length -= dlength;\r\niov_offset += dlength;\r\nif (iov_offset >= operation->tfrm_op.outdata[outiov_ix].iov_len) {\r\niov_offset = 0;\r\n++outiov_ix;\r\n}\r\n}\r\nif (out_length > 0){\r\nDEBUG_API(printk("create_input_descriptors: not enough room for output, %d remained\n", out_length));\r\nerr = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\nmi.sync = 1;\r\noutdesc->dma_descr->md = REG_TYPE_CONV(unsigned short int, struct strcop_meta_in, mi);\r\n*id = head.next;\r\nreturn 0;\r\nerror_cleanup:\r\nwhile (head.next) {\r\noutdesc = head.next->next;\r\nfree_cdesc(head.next);\r\nhead.next = outdesc;\r\n}\r\nreturn err;\r\n}\r\nstatic int create_output_descriptors(struct cryptocop_operation *operation, int *iniov_ix, int *iniov_offset, size_t desc_len, struct cryptocop_dma_desc **current_out_cdesc, struct strcop_meta_out *meta_out, int alloc_flag)\r\n{\r\nwhile (desc_len != 0) {\r\nstruct cryptocop_dma_desc *cdesc;\r\nint rem_length = operation->tfrm_op.indata[*iniov_ix].iov_len - *iniov_offset;\r\nint dlength = (desc_len < rem_length) ? desc_len : rem_length;\r\ncdesc = alloc_cdesc(alloc_flag);\r\nif (!cdesc) {\r\nDEBUG_API(printk("create_output_descriptors: alloc_cdesc\n"));\r\nreturn -ENOMEM;\r\n}\r\n(*current_out_cdesc)->next = cdesc;\r\n(*current_out_cdesc) = cdesc;\r\ncdesc->free_buf = NULL;\r\ncdesc->dma_descr->buf = (char*)virt_to_phys(operation->tfrm_op.indata[*iniov_ix].iov_base + *iniov_offset);\r\ncdesc->dma_descr->after = cdesc->dma_descr->buf + dlength;\r\nassert(desc_len >= dlength);\r\ndesc_len -= dlength;\r\n*iniov_offset += dlength;\r\nif (*iniov_offset >= operation->tfrm_op.indata[*iniov_ix].iov_len) {\r\n*iniov_offset = 0;\r\n++(*iniov_ix);\r\nif (*iniov_ix > operation->tfrm_op.incount) {\r\nDEBUG_API(printk("create_output_descriptors: not enough indata in operation."));\r\nreturn -EINVAL;\r\n}\r\n}\r\ncdesc->dma_descr->md = REG_TYPE_CONV(unsigned short int, struct strcop_meta_out, (*meta_out));\r\n}\r\n(*current_out_cdesc)->dma_descr->wait = 1;\r\nreturn 0;\r\n}\r\nstatic int append_input_descriptors(struct cryptocop_operation *operation, struct cryptocop_dma_desc **current_in_cdesc, struct cryptocop_dma_desc **current_out_cdesc, struct cryptocop_tfrm_ctx *tc, int alloc_flag)\r\n{\r\nDEBUG(printk("append_input_descriptors, tc=0x%p, unit_no=%d\n", tc, tc->unit_no));\r\nif (tc->tcfg) {\r\nint failed = 0;\r\nstruct cryptocop_dma_desc *idescs = NULL;\r\nDEBUG(printk("append_input_descriptors: pushing output, consumed %d produced %d bytes.\n", tc->consumed, tc->produced));\r\nif (tc->pad_descs) {\r\nDEBUG(printk("append_input_descriptors: append pad descriptors to DMA out list.\n"));\r\nwhile (tc->pad_descs) {\r\nDEBUG(printk("append descriptor 0x%p\n", tc->pad_descs));\r\n(*current_out_cdesc)->next = tc->pad_descs;\r\ntc->pad_descs = tc->pad_descs->next;\r\n(*current_out_cdesc) = (*current_out_cdesc)->next;\r\n}\r\n}\r\nif (tc->unit_no == src_dma){\r\nstruct strcop_meta_in mi = {.sync = 0, .dmasel = src_dma};\r\nunsigned int start_ix = tc->start_ix;\r\nwhile (start_ix){\r\nunsigned int desclen = start_ix < MEM2MEM_DISCARD_BUF_LENGTH ? start_ix : MEM2MEM_DISCARD_BUF_LENGTH;\r\n(*current_in_cdesc)->next = alloc_cdesc(alloc_flag);\r\nif (!(*current_in_cdesc)->next){\r\nDEBUG_API(printk("append_input_descriptors: alloc_cdesc mem2mem discard failed\n"));\r\nreturn -ENOMEM;\r\n}\r\n(*current_in_cdesc) = (*current_in_cdesc)->next;\r\n(*current_in_cdesc)->dma_descr->buf = (char*)virt_to_phys(mem2mem_discard_buf);\r\n(*current_in_cdesc)->dma_descr->after = (*current_in_cdesc)->dma_descr->buf + desclen;\r\n(*current_in_cdesc)->dma_descr->md = REG_TYPE_CONV(unsigned short int, struct strcop_meta_in, mi);\r\nstart_ix -= desclen;\r\n}\r\nmi.sync = 1;\r\n(*current_in_cdesc)->dma_descr->md = REG_TYPE_CONV(unsigned short int, struct strcop_meta_in, mi);\r\n}\r\nfailed = create_input_descriptors(operation, tc, &idescs, alloc_flag);\r\nif (failed){\r\nDEBUG_API(printk("append_input_descriptors: output descriptor setup failed\n"));\r\nreturn failed;\r\n}\r\nDEBUG(printk("append_input_descriptors: append output descriptors to DMA in list.\n"));\r\nwhile (idescs) {\r\nDEBUG(printk("append descriptor 0x%p\n", idescs));\r\n(*current_in_cdesc)->next = idescs;\r\nidescs = idescs->next;\r\n(*current_in_cdesc) = (*current_in_cdesc)->next;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cryptocop_setup_dma_list(struct cryptocop_operation *operation, struct cryptocop_int_operation **int_op, int alloc_flag)\r\n{\r\nstruct cryptocop_session *sess;\r\nstruct cryptocop_transform_ctx *tctx;\r\nstruct cryptocop_tfrm_ctx digest_ctx = {\r\n.previous_src = src_none,\r\n.current_src = src_none,\r\n.start_ix = 0,\r\n.requires_padding = 1,\r\n.strict_block_length = 0,\r\n.hash_conf = 0,\r\n.hash_mode = 0,\r\n.ciph_conf = 0,\r\n.cbcmode = 0,\r\n.decrypt = 0,\r\n.consumed = 0,\r\n.produced = 0,\r\n.pad_descs = NULL,\r\n.active = 0,\r\n.done = 0,\r\n.prev_src = NULL,\r\n.curr_src = NULL,\r\n.tcfg = NULL};\r\nstruct cryptocop_tfrm_ctx cipher_ctx = {\r\n.previous_src = src_none,\r\n.current_src = src_none,\r\n.start_ix = 0,\r\n.requires_padding = 0,\r\n.strict_block_length = 1,\r\n.hash_conf = 0,\r\n.hash_mode = 0,\r\n.ciph_conf = 0,\r\n.cbcmode = 0,\r\n.decrypt = 0,\r\n.consumed = 0,\r\n.produced = 0,\r\n.pad_descs = NULL,\r\n.active = 0,\r\n.done = 0,\r\n.prev_src = NULL,\r\n.curr_src = NULL,\r\n.tcfg = NULL};\r\nstruct cryptocop_tfrm_ctx csum_ctx = {\r\n.previous_src = src_none,\r\n.current_src = src_none,\r\n.start_ix = 0,\r\n.blocklength = 2,\r\n.requires_padding = 1,\r\n.strict_block_length = 0,\r\n.hash_conf = 0,\r\n.hash_mode = 0,\r\n.ciph_conf = 0,\r\n.cbcmode = 0,\r\n.decrypt = 0,\r\n.consumed = 0,\r\n.produced = 0,\r\n.pad_descs = NULL,\r\n.active = 0,\r\n.done = 0,\r\n.tcfg = NULL,\r\n.prev_src = NULL,\r\n.curr_src = NULL,\r\n.unit_no = src_csum};\r\nstruct cryptocop_tfrm_cfg *tcfg = operation->tfrm_op.tfrm_cfg;\r\nunsigned int indata_ix = 0;\r\nint iniov_ix = 0;\r\nint iniov_offset = 0;\r\nstruct cryptocop_desc *odsc;\r\nint failed = 0;\r\nstruct cryptocop_dma_desc out_cdesc_head = {0};\r\nstruct cryptocop_dma_desc in_cdesc_head = {0};\r\nstruct cryptocop_dma_desc *current_out_cdesc = &out_cdesc_head;\r\nstruct cryptocop_dma_desc *current_in_cdesc = &in_cdesc_head;\r\nstruct cryptocop_tfrm_ctx *output_tc = NULL;\r\nvoid *iop_alloc_ptr;\r\nassert(operation != NULL);\r\nassert(int_op != NULL);\r\nDEBUG(printk("cryptocop_setup_dma_list: start\n"));\r\nDEBUG(print_cryptocop_operation(operation));\r\nsess = get_session(operation->sid);\r\nif (!sess) {\r\nDEBUG_API(printk("cryptocop_setup_dma_list: no session found for operation.\n"));\r\nfailed = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\niop_alloc_ptr = kmalloc(DESCR_ALLOC_PAD + sizeof(struct cryptocop_int_operation), alloc_flag);\r\nif (!iop_alloc_ptr) {\r\nDEBUG_API(printk("cryptocop_setup_dma_list: kmalloc cryptocop_int_operation\n"));\r\nfailed = -ENOMEM;\r\ngoto error_cleanup;\r\n}\r\n(*int_op) = (struct cryptocop_int_operation*)(((unsigned long int)(iop_alloc_ptr + DESCR_ALLOC_PAD + offsetof(struct cryptocop_int_operation, ctx_out)) & ~0x0000001F) - offsetof(struct cryptocop_int_operation, ctx_out));\r\nDEBUG(memset((*int_op), 0xff, sizeof(struct cryptocop_int_operation)));\r\n(*int_op)->alloc_ptr = iop_alloc_ptr;\r\nDEBUG(printk("cryptocop_setup_dma_list: *int_op=0x%p, alloc_ptr=0x%p\n", *int_op, (*int_op)->alloc_ptr));\r\n(*int_op)->sid = operation->sid;\r\n(*int_op)->cdesc_out = NULL;\r\n(*int_op)->cdesc_in = NULL;\r\n(*int_op)->tdes_mode = cryptocop_3des_ede;\r\n(*int_op)->csum_mode = cryptocop_csum_le;\r\n(*int_op)->ddesc_out = NULL;\r\n(*int_op)->ddesc_in = NULL;\r\nif (!tcfg) {\r\nDEBUG_API(printk("cryptocop_setup_dma_list: no configured transforms in operation.\n"));\r\nfailed = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\nwhile (tcfg) {\r\ntctx = get_transform_ctx(sess, tcfg->tid);\r\nif (!tctx) {\r\nDEBUG_API(printk("cryptocop_setup_dma_list: no transform id %d in session.\n", tcfg->tid));\r\nfailed = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\nif (tcfg->inject_ix > operation->tfrm_op.outlen){\r\nDEBUG_API(printk("cryptocop_setup_dma_list: transform id %d inject_ix (%d) > operation->tfrm_op.outlen(%d)", tcfg->tid, tcfg->inject_ix, operation->tfrm_op.outlen));\r\nfailed = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\nswitch (tctx->init.alg){\r\ncase cryptocop_alg_mem2mem:\r\nif (cipher_ctx.tcfg != NULL){\r\nDEBUG_API(printk("cryptocop_setup_dma_list: multiple ciphers in operation.\n"));\r\nfailed = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\ncipher_ctx.cbcmode = 0;\r\ncipher_ctx.decrypt = 0;\r\ncipher_ctx.blocklength = 1;\r\ncipher_ctx.ciph_conf = 0;\r\ncipher_ctx.unit_no = src_dma;\r\ncipher_ctx.tcfg = tcfg;\r\ncipher_ctx.tctx = tctx;\r\nbreak;\r\ncase cryptocop_alg_des:\r\ncase cryptocop_alg_3des:\r\ncase cryptocop_alg_aes:\r\nif (cipher_ctx.tcfg != NULL){\r\nDEBUG_API(printk("cryptocop_setup_dma_list: multiple ciphers in operation.\n"));\r\nfailed = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\ncipher_ctx.tcfg = tcfg;\r\ncipher_ctx.tctx = tctx;\r\nif (cipher_ctx.tcfg->flags & CRYPTOCOP_DECRYPT){\r\ncipher_ctx.decrypt = 1;\r\n}\r\nswitch (tctx->init.cipher_mode) {\r\ncase cryptocop_cipher_mode_ecb:\r\ncipher_ctx.cbcmode = 0;\r\nbreak;\r\ncase cryptocop_cipher_mode_cbc:\r\ncipher_ctx.cbcmode = 1;\r\nbreak;\r\ndefault:\r\nDEBUG_API(printk("cryptocop_setup_dma_list: cipher_ctx, bad cipher mode==%d\n", tctx->init.cipher_mode));\r\nfailed = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\nDEBUG(printk("cryptocop_setup_dma_list: cipher_ctx, set CBC mode==%d\n", cipher_ctx.cbcmode));\r\nswitch (tctx->init.alg){\r\ncase cryptocop_alg_des:\r\ncipher_ctx.ciph_conf = 0;\r\ncipher_ctx.unit_no = src_des;\r\ncipher_ctx.blocklength = DES_BLOCK_LENGTH;\r\nbreak;\r\ncase cryptocop_alg_3des:\r\ncipher_ctx.ciph_conf = 1;\r\ncipher_ctx.unit_no = src_des;\r\ncipher_ctx.blocklength = DES_BLOCK_LENGTH;\r\nbreak;\r\ncase cryptocop_alg_aes:\r\ncipher_ctx.ciph_conf = 2;\r\ncipher_ctx.unit_no = src_aes;\r\ncipher_ctx.blocklength = AES_BLOCK_LENGTH;\r\nbreak;\r\ndefault:\r\npanic("cryptocop_setup_dma_list: impossible algorithm %d\n", tctx->init.alg);\r\n}\r\n(*int_op)->tdes_mode = tctx->init.tdes_mode;\r\nbreak;\r\ncase cryptocop_alg_md5:\r\ncase cryptocop_alg_sha1:\r\nif (digest_ctx.tcfg != NULL){\r\nDEBUG_API(printk("cryptocop_setup_dma_list: multiple digests in operation.\n"));\r\nfailed = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\ndigest_ctx.tcfg = tcfg;\r\ndigest_ctx.tctx = tctx;\r\ndigest_ctx.hash_mode = 0;\r\nswitch (tctx->init.alg){\r\ncase cryptocop_alg_md5:\r\ndigest_ctx.blocklength = MD5_BLOCK_LENGTH;\r\ndigest_ctx.unit_no = src_md5;\r\ndigest_ctx.hash_conf = 1;\r\nbreak;\r\ncase cryptocop_alg_sha1:\r\ndigest_ctx.blocklength = SHA1_BLOCK_LENGTH;\r\ndigest_ctx.unit_no = src_sha1;\r\ndigest_ctx.hash_conf = 0;\r\nbreak;\r\ndefault:\r\npanic("cryptocop_setup_dma_list: impossible digest algorithm\n");\r\n}\r\nbreak;\r\ncase cryptocop_alg_csum:\r\nif (csum_ctx.tcfg != NULL){\r\nDEBUG_API(printk("cryptocop_setup_dma_list: multiple checksums in operation.\n"));\r\nfailed = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\n(*int_op)->csum_mode = tctx->init.csum_mode;\r\ncsum_ctx.tcfg = tcfg;\r\ncsum_ctx.tctx = tctx;\r\nbreak;\r\ndefault:\r\nDEBUG_API(printk("cryptocop_setup_dma_list: invalid algorithm %d specified in tfrm %d.\n", tctx->init.alg, tcfg->tid));\r\nfailed = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\ntcfg = tcfg->next;\r\n}\r\nif (cipher_ctx.tcfg && (cipher_ctx.tctx->init.alg != cryptocop_alg_mem2mem)){\r\nstruct cryptocop_dma_desc *key_desc = NULL;\r\nfailed = setup_key_dl_desc(&cipher_ctx, &key_desc, alloc_flag);\r\nif (failed) {\r\nDEBUG_API(printk("cryptocop_setup_dma_list: setup key dl\n"));\r\ngoto error_cleanup;\r\n}\r\ncurrent_out_cdesc->next = key_desc;\r\ncurrent_out_cdesc = key_desc;\r\nindata_ix += (unsigned int)(key_desc->dma_descr->after - key_desc->dma_descr->buf);\r\nif ((cipher_ctx.tctx->init.cipher_mode == cryptocop_cipher_mode_cbc) && (cipher_ctx.tcfg->flags & CRYPTOCOP_EXPLICIT_IV)) {\r\nstruct cryptocop_dma_desc *iv_desc = NULL;\r\nDEBUG(printk("cryptocop_setup_dma_list: setup cipher CBC IV descriptor.\n"));\r\nfailed = setup_cipher_iv_desc(&cipher_ctx, &iv_desc, alloc_flag);\r\nif (failed) {\r\nDEBUG_API(printk("cryptocop_setup_dma_list: CBC IV descriptor.\n"));\r\ngoto error_cleanup;\r\n}\r\ncurrent_out_cdesc->next = iv_desc;\r\ncurrent_out_cdesc = iv_desc;\r\nindata_ix += (unsigned int)(iv_desc->dma_descr->after - iv_desc->dma_descr->buf);\r\n}\r\n}\r\nodsc = operation->tfrm_op.desc;\r\nwhile (odsc) {\r\nstruct cryptocop_desc_cfg *dcfg = odsc->cfg;\r\nstruct strcop_meta_out meta_out = {0};\r\nsize_t desc_len = odsc->length;\r\nint active_count, eop_needed_count;\r\noutput_tc = NULL;\r\nDEBUG(printk("cryptocop_setup_dma_list: parsing an operation descriptor\n"));\r\nwhile (dcfg) {\r\nstruct cryptocop_tfrm_ctx *tc = NULL;\r\nDEBUG(printk("cryptocop_setup_dma_list: parsing an operation descriptor configuration.\n"));\r\nif (digest_ctx.tcfg && (digest_ctx.tcfg->tid == dcfg->tid)){\r\ntc = &digest_ctx;\r\n} else if (cipher_ctx.tcfg && (cipher_ctx.tcfg->tid == dcfg->tid)){\r\ntc = &cipher_ctx;\r\n} else if (csum_ctx.tcfg && (csum_ctx.tcfg->tid == dcfg->tid)){\r\ntc = &csum_ctx;\r\n}\r\nif (!tc) {\r\nDEBUG_API(printk("cryptocop_setup_dma_list: invalid transform %d specified in descriptor.\n", dcfg->tid));\r\nfailed = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\nif (tc->done) {\r\nDEBUG_API(printk("cryptocop_setup_dma_list: completed transform %d reused.\n", dcfg->tid));\r\nfailed = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\nif (!tc->active) {\r\ntc->start_ix = indata_ix;\r\ntc->active = 1;\r\n}\r\ntc->previous_src = tc->current_src;\r\ntc->prev_src = tc->curr_src;\r\nswitch (dcfg->src){\r\ncase cryptocop_source_dma:\r\ntc->current_src = src_dma;\r\nbreak;\r\ncase cryptocop_source_des:\r\ntc->current_src = src_des;\r\nbreak;\r\ncase cryptocop_source_3des:\r\ntc->current_src = src_des;\r\nbreak;\r\ncase cryptocop_source_aes:\r\ntc->current_src = src_aes;\r\nbreak;\r\ncase cryptocop_source_md5:\r\ncase cryptocop_source_sha1:\r\ncase cryptocop_source_csum:\r\ncase cryptocop_source_none:\r\ndefault:\r\nDEBUG_API(printk("cryptocop_setup_dma_list: bad unit source configured %d.\n", dcfg->src));\r\nfailed = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\nif (tc->current_src != src_dma) {\r\nif (digest_ctx.unit_no == tc->current_src){\r\ntc->curr_src = &digest_ctx;\r\n} else if (cipher_ctx.unit_no == tc->current_src){\r\ntc->curr_src = &cipher_ctx;\r\n} else if (csum_ctx.unit_no == tc->current_src){\r\ntc->curr_src = &csum_ctx;\r\n}\r\nif ((tc->curr_src == tc) && (tc->unit_no != src_dma)){\r\nDEBUG_API(printk("cryptocop_setup_dma_list: unit %d configured to source from itself.\n", tc->unit_no));\r\nfailed = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\n} else {\r\ntc->curr_src = NULL;\r\n}\r\nDEBUG(printk("cryptocop_setup_dma_list: tc->active=%d tc->unit_no=%d tc->current_src=%d tc->previous_src=%d, tc->curr_src=0x%p, tc->prev_srv=0x%p\n", tc->active, tc->unit_no, tc->current_src, tc->previous_src, tc->curr_src, tc->prev_src));\r\nif (tc->active && (tc->current_src != tc->previous_src)) {\r\nif (((tc->prev_src != NULL) && (tc->prev_src->consumed % tc->prev_src->blocklength)) ||\r\n((tc->curr_src != NULL) && (tc->curr_src->consumed % tc->curr_src->blocklength)))\r\n{\r\nDEBUG_API(printk("cryptocop_setup_dma_list: can only disconnect from or connect to a unit on a multiple of the blocklength, old: cons=%d, prod=%d, block=%d, new: cons=%d prod=%d, block=%d.\n", tc->prev_src ? tc->prev_src->consumed : INT_MIN, tc->prev_src ? tc->prev_src->produced : INT_MIN, tc->prev_src ? tc->prev_src->blocklength : INT_MIN, tc->curr_src ? tc->curr_src->consumed : INT_MIN, tc->curr_src ? tc->curr_src->produced : INT_MIN, tc->curr_src ? tc->curr_src->blocklength : INT_MIN));\r\nfailed = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\n}\r\nif (dcfg->last) {\r\ntc->done = 1;\r\n}\r\ndcfg = dcfg->next;\r\n}\r\nDEBUG(printk("cryptocop_setup_dma_list: parsing operation descriptor configuration complete.\n"));\r\nif (cipher_ctx.active && (cipher_ctx.curr_src != NULL) && !cipher_ctx.curr_src->active){\r\nDEBUG_API(printk("cryptocop_setup_dma_list: cipher source from inactive unit %d\n", cipher_ctx.curr_src->unit_no));\r\nfailed = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\nif (digest_ctx.active && (digest_ctx.curr_src != NULL) && !digest_ctx.curr_src->active){\r\nDEBUG_API(printk("cryptocop_setup_dma_list: digest source from inactive unit %d\n", digest_ctx.curr_src->unit_no));\r\nfailed = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\nif (csum_ctx.active && (csum_ctx.curr_src != NULL) && !csum_ctx.curr_src->active){\r\nDEBUG_API(printk("cryptocop_setup_dma_list: cipher source from inactive unit %d\n", csum_ctx.curr_src->unit_no));\r\nfailed = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\nDEBUG(printk("cryptocop_setup_dma_list: desc->length=%d, desc_len=%d.\n", odsc->length, desc_len));\r\nif (csum_ctx.active) {\r\ncsum_ctx.consumed += desc_len;\r\nif (csum_ctx.done) {\r\ncsum_ctx.produced = 2;\r\n}\r\nDEBUG(printk("cryptocop_setup_dma_list: csum_ctx producing: consumed=%d, produced=%d, blocklength=%d.\n", csum_ctx.consumed, csum_ctx.produced, csum_ctx.blocklength));\r\n}\r\nif (digest_ctx.active) {\r\ndigest_ctx.consumed += desc_len;\r\nif (digest_ctx.done) {\r\nif (digest_ctx.unit_no == src_md5) {\r\ndigest_ctx.produced = MD5_STATE_LENGTH;\r\n} else {\r\ndigest_ctx.produced = SHA1_STATE_LENGTH;\r\n}\r\n}\r\nDEBUG(printk("cryptocop_setup_dma_list: digest_ctx producing: consumed=%d, produced=%d, blocklength=%d.\n", digest_ctx.consumed, digest_ctx.produced, digest_ctx.blocklength));\r\n}\r\nif (cipher_ctx.active) {\r\nassert(cipher_ctx.current_src == src_dma);\r\ncipher_ctx.consumed += desc_len;\r\ncipher_ctx.produced = cipher_ctx.blocklength * (cipher_ctx.consumed / cipher_ctx.blocklength);\r\nif (cipher_ctx.cbcmode && !(cipher_ctx.tcfg->flags & CRYPTOCOP_EXPLICIT_IV) && cipher_ctx.produced){\r\ncipher_ctx.produced -= cipher_ctx.blocklength;\r\n}\r\nDEBUG(printk("cryptocop_setup_dma_list: cipher_ctx producing: consumed=%d, produced=%d, blocklength=%d.\n", cipher_ctx.consumed, cipher_ctx.produced, cipher_ctx.blocklength));\r\n}\r\nactive_count = 0;\r\neop_needed_count = 0;\r\nif (cipher_ctx.active) {\r\n++active_count;\r\nif (cipher_ctx.unit_no == src_dma){\r\nmeta_out.ciphsel = src_none;\r\n} else {\r\nmeta_out.ciphsel = cipher_ctx.current_src;\r\n}\r\nmeta_out.ciphconf = cipher_ctx.ciph_conf;\r\nmeta_out.cbcmode = cipher_ctx.cbcmode;\r\nmeta_out.decrypt = cipher_ctx.decrypt;\r\nDEBUG(printk("set ciphsel=%d ciphconf=%d cbcmode=%d decrypt=%d\n", meta_out.ciphsel, meta_out.ciphconf, meta_out.cbcmode, meta_out.decrypt));\r\nif (cipher_ctx.done) ++eop_needed_count;\r\n} else {\r\nmeta_out.ciphsel = src_none;\r\n}\r\nif (digest_ctx.active) {\r\n++active_count;\r\nmeta_out.hashsel = digest_ctx.current_src;\r\nmeta_out.hashconf = digest_ctx.hash_conf;\r\nmeta_out.hashmode = 0;\r\nDEBUG(printk("set hashsel=%d hashconf=%d hashmode=%d\n", meta_out.hashsel, meta_out.hashconf, meta_out.hashmode));\r\nif (digest_ctx.done) {\r\nassert(digest_ctx.pad_descs == NULL);\r\nfailed = create_pad_descriptor(&digest_ctx, &digest_ctx.pad_descs, alloc_flag);\r\nif (failed) {\r\nDEBUG_API(printk("cryptocop_setup_dma_list: failed digest pad creation.\n"));\r\ngoto error_cleanup;\r\n}\r\n}\r\n} else {\r\nmeta_out.hashsel = src_none;\r\n}\r\nif (csum_ctx.active) {\r\n++active_count;\r\nmeta_out.csumsel = csum_ctx.current_src;\r\nif (csum_ctx.done) {\r\nassert(csum_ctx.pad_descs == NULL);\r\nfailed = create_pad_descriptor(&csum_ctx, &csum_ctx.pad_descs, alloc_flag);\r\nif (failed) {\r\nDEBUG_API(printk("cryptocop_setup_dma_list: failed csum pad creation.\n"));\r\ngoto error_cleanup;\r\n}\r\n}\r\n} else {\r\nmeta_out.csumsel = src_none;\r\n}\r\nDEBUG(printk("cryptocop_setup_dma_list: %d eop needed, %d active units\n", eop_needed_count, active_count));\r\nfailed = create_output_descriptors(operation, &iniov_ix, &iniov_offset, desc_len, &current_out_cdesc, &meta_out, alloc_flag);\r\nif (failed) {\r\nDEBUG_API(printk("cryptocop_setup_dma_list: create_output_descriptors %d\n", failed));\r\ngoto error_cleanup;\r\n}\r\nassert(active_count >= eop_needed_count);\r\nassert((eop_needed_count == 0) || (eop_needed_count == 1));\r\nif (eop_needed_count) {\r\nif (active_count > 1) {\r\nstruct cryptocop_dma_desc *ed = alloc_cdesc(alloc_flag);\r\nstruct strcop_meta_out ed_mo = {0};\r\nif (!ed) {\r\nDEBUG_API(printk("cryptocop_setup_dma_list: alloc EOP descriptor for cipher\n"));\r\nfailed = -ENOMEM;\r\ngoto error_cleanup;\r\n}\r\nassert(cipher_ctx.active && cipher_ctx.done);\r\nif (cipher_ctx.unit_no == src_dma){\r\ned_mo.ciphsel = src_none;\r\n} else {\r\ned_mo.ciphsel = cipher_ctx.current_src;\r\n}\r\ned_mo.ciphconf = cipher_ctx.ciph_conf;\r\ned_mo.cbcmode = cipher_ctx.cbcmode;\r\ned_mo.decrypt = cipher_ctx.decrypt;\r\ned->free_buf = NULL;\r\ned->dma_descr->wait = 1;\r\ned->dma_descr->out_eop = 1;\r\ned->dma_descr->buf = (char*)virt_to_phys(&ed);\r\ned->dma_descr->after = ed->dma_descr->buf;\r\ned->dma_descr->md = REG_TYPE_CONV(unsigned short int, struct strcop_meta_out, ed_mo);\r\ncurrent_out_cdesc->next = ed;\r\ncurrent_out_cdesc = ed;\r\n} else {\r\ncurrent_out_cdesc->dma_descr->out_eop = 1;\r\n}\r\n}\r\nif (cipher_ctx.done && cipher_ctx.active) cipher_ctx.active = 0;\r\nif (digest_ctx.done && digest_ctx.active) digest_ctx.active = 0;\r\nif (csum_ctx.done && csum_ctx.active) csum_ctx.active = 0;\r\nindata_ix += odsc->length;\r\nodsc = odsc->next;\r\n}\r\nDEBUG(printk("cryptocop_setup_dma_list: done parsing operation descriptors\n"));\r\nif (cipher_ctx.tcfg && (cipher_ctx.active || !cipher_ctx.done)){\r\nDEBUG_API(printk("cryptocop_setup_dma_list: cipher operation not terminated.\n"));\r\nfailed = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\nif (digest_ctx.tcfg && (digest_ctx.active || !digest_ctx.done)){\r\nDEBUG_API(printk("cryptocop_setup_dma_list: digest operation not terminated.\n"));\r\nfailed = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\nif (csum_ctx.tcfg && (csum_ctx.active || !csum_ctx.done)){\r\nDEBUG_API(printk("cryptocop_setup_dma_list: csum operation not terminated.\n"));\r\nfailed = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\nfailed = append_input_descriptors(operation, &current_in_cdesc, &current_out_cdesc, &cipher_ctx, alloc_flag);\r\nif (failed){\r\nDEBUG_API(printk("cryptocop_setup_dma_list: append_input_descriptors cipher_ctx %d\n", failed));\r\ngoto error_cleanup;\r\n}\r\nfailed = append_input_descriptors(operation, &current_in_cdesc, &current_out_cdesc, &digest_ctx, alloc_flag);\r\nif (failed){\r\nDEBUG_API(printk("cryptocop_setup_dma_list: append_input_descriptors cipher_ctx %d\n", failed));\r\ngoto error_cleanup;\r\n}\r\nfailed = append_input_descriptors(operation, &current_in_cdesc, &current_out_cdesc, &csum_ctx, alloc_flag);\r\nif (failed){\r\nDEBUG_API(printk("cryptocop_setup_dma_list: append_input_descriptors cipher_ctx %d\n", failed));\r\ngoto error_cleanup;\r\n}\r\nDEBUG(printk("cryptocop_setup_dma_list: int_op=0x%p, *int_op=0x%p\n", int_op, *int_op));\r\n(*int_op)->cdesc_out = out_cdesc_head.next;\r\n(*int_op)->cdesc_in = in_cdesc_head.next;\r\nDEBUG(printk("cryptocop_setup_dma_list: out_cdesc_head=0x%p in_cdesc_head=0x%p\n", (*int_op)->cdesc_out, (*int_op)->cdesc_in));\r\nsetup_descr_chain(out_cdesc_head.next);\r\nsetup_descr_chain(in_cdesc_head.next);\r\ncurrent_in_cdesc->dma_descr->intr = 1;\r\ncurrent_in_cdesc->dma_descr->eol = 1;\r\ncurrent_out_cdesc->dma_descr->eol = 1;\r\n(*int_op)->ctx_out.next = NULL;\r\n(*int_op)->ctx_out.eol = 1;\r\n(*int_op)->ctx_out.intr = 0;\r\n(*int_op)->ctx_out.store_mode = 0;\r\n(*int_op)->ctx_out.en = 0;\r\n(*int_op)->ctx_out.dis = 0;\r\n(*int_op)->ctx_out.md0 = 0;\r\n(*int_op)->ctx_out.md1 = 0;\r\n(*int_op)->ctx_out.md2 = 0;\r\n(*int_op)->ctx_out.md3 = 0;\r\n(*int_op)->ctx_out.md4 = 0;\r\n(*int_op)->ctx_out.saved_data = (dma_descr_data*)virt_to_phys((*int_op)->cdesc_out->dma_descr);\r\n(*int_op)->ctx_out.saved_data_buf = (*int_op)->cdesc_out->dma_descr->buf;\r\n(*int_op)->ctx_in.next = NULL;\r\n(*int_op)->ctx_in.eol = 1;\r\n(*int_op)->ctx_in.intr = 0;\r\n(*int_op)->ctx_in.store_mode = 0;\r\n(*int_op)->ctx_in.en = 0;\r\n(*int_op)->ctx_in.dis = 0;\r\n(*int_op)->ctx_in.md0 = 0;\r\n(*int_op)->ctx_in.md1 = 0;\r\n(*int_op)->ctx_in.md2 = 0;\r\n(*int_op)->ctx_in.md3 = 0;\r\n(*int_op)->ctx_in.md4 = 0;\r\n(*int_op)->ctx_in.saved_data = (dma_descr_data*)virt_to_phys((*int_op)->cdesc_in->dma_descr);\r\n(*int_op)->ctx_in.saved_data_buf = (*int_op)->cdesc_in->dma_descr->buf;\r\nDEBUG(printk("cryptocop_setup_dma_list: done\n"));\r\nreturn 0;\r\nerror_cleanup:\r\n{\r\nstruct cryptocop_dma_desc *tmp_cdesc;\r\nwhile (digest_ctx.pad_descs){\r\ntmp_cdesc = digest_ctx.pad_descs->next;\r\nfree_cdesc(digest_ctx.pad_descs);\r\ndigest_ctx.pad_descs = tmp_cdesc;\r\n}\r\nwhile (csum_ctx.pad_descs){\r\ntmp_cdesc = csum_ctx.pad_descs->next;\r\nfree_cdesc(csum_ctx.pad_descs);\r\ncsum_ctx.pad_descs = tmp_cdesc;\r\n}\r\nassert(cipher_ctx.pad_descs == NULL);\r\nif (*int_op != NULL) delete_internal_operation(*int_op);\r\n}\r\nDEBUG_API(printk("cryptocop_setup_dma_list: done with error %d\n", failed));\r\nreturn failed;\r\n}\r\nstatic void delete_internal_operation(struct cryptocop_int_operation *iop)\r\n{\r\nvoid *ptr = iop->alloc_ptr;\r\nstruct cryptocop_dma_desc *cd = iop->cdesc_out;\r\nstruct cryptocop_dma_desc *next;\r\nDEBUG(printk("delete_internal_operation: iop=0x%p, alloc_ptr=0x%p\n", iop, ptr));\r\nwhile (cd) {\r\nnext = cd->next;\r\nfree_cdesc(cd);\r\ncd = next;\r\n}\r\ncd = iop->cdesc_in;\r\nwhile (cd) {\r\nnext = cd->next;\r\nfree_cdesc(cd);\r\ncd = next;\r\n}\r\nkfree(ptr);\r\n}\r\nstatic int create_md5_pad(int alloc_flag, unsigned long long hashed_length, char **pad, size_t *pad_length)\r\n{\r\nsize_t padlen = MD5_BLOCK_LENGTH - (hashed_length % MD5_BLOCK_LENGTH);\r\nunsigned char *p;\r\nint i;\r\nunsigned long long int bit_length = hashed_length << 3;\r\nif (padlen < MD5_MIN_PAD_LENGTH) padlen += MD5_BLOCK_LENGTH;\r\np = kmalloc(padlen, alloc_flag);\r\nif (!p) return -ENOMEM;\r\n*p = 0x80;\r\nmemset(p+1, 0, padlen - 1);\r\nDEBUG(printk("create_md5_pad: hashed_length=%lld bits == %lld bytes\n", bit_length, hashed_length));\r\ni = padlen - MD5_PAD_LENGTH_FIELD_LENGTH;\r\nwhile (bit_length != 0){\r\np[i++] = bit_length % 0x100;\r\nbit_length >>= 8;\r\n}\r\n*pad = (char*)p;\r\n*pad_length = padlen;\r\nreturn 0;\r\n}\r\nstatic int create_sha1_pad(int alloc_flag, unsigned long long hashed_length, char **pad, size_t *pad_length)\r\n{\r\nsize_t padlen = SHA1_BLOCK_LENGTH - (hashed_length % SHA1_BLOCK_LENGTH);\r\nunsigned char *p;\r\nint i;\r\nunsigned long long int bit_length = hashed_length << 3;\r\nif (padlen < SHA1_MIN_PAD_LENGTH) padlen += SHA1_BLOCK_LENGTH;\r\np = kmalloc(padlen, alloc_flag);\r\nif (!p) return -ENOMEM;\r\n*p = 0x80;\r\nmemset(p+1, 0, padlen - 1);\r\nDEBUG(printk("create_sha1_pad: hashed_length=%lld bits == %lld bytes\n", bit_length, hashed_length));\r\ni = padlen - 1;\r\nwhile (bit_length != 0){\r\np[i--] = bit_length % 0x100;\r\nbit_length >>= 8;\r\n}\r\n*pad = (char*)p;\r\n*pad_length = padlen;\r\nreturn 0;\r\n}\r\nstatic int transform_ok(struct cryptocop_transform_init *tinit)\r\n{\r\nswitch (tinit->alg){\r\ncase cryptocop_alg_csum:\r\nswitch (tinit->csum_mode){\r\ncase cryptocop_csum_le:\r\ncase cryptocop_csum_be:\r\nbreak;\r\ndefault:\r\nDEBUG_API(printk("transform_ok: Bad mode set for csum transform\n"));\r\nreturn -EINVAL;\r\n}\r\ncase cryptocop_alg_mem2mem:\r\ncase cryptocop_alg_md5:\r\ncase cryptocop_alg_sha1:\r\nif (tinit->keylen != 0) {\r\nDEBUG_API(printk("transform_ok: non-zero keylength, %d, for a digest/csum algorithm\n", tinit->keylen));\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase cryptocop_alg_des:\r\nif (tinit->keylen != 64) {\r\nDEBUG_API(printk("transform_ok: keylen %d invalid for DES\n", tinit->keylen));\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase cryptocop_alg_3des:\r\nif (tinit->keylen != 192) {\r\nDEBUG_API(printk("transform_ok: keylen %d invalid for 3DES\n", tinit->keylen));\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase cryptocop_alg_aes:\r\nif (tinit->keylen != 128 && tinit->keylen != 192 && tinit->keylen != 256) {\r\nDEBUG_API(printk("transform_ok: keylen %d invalid for AES\n", tinit->keylen));\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase cryptocop_no_alg:\r\ndefault:\r\nDEBUG_API(printk("transform_ok: no such algorithm %d\n", tinit->alg));\r\nreturn -EINVAL;\r\n}\r\nswitch (tinit->alg){\r\ncase cryptocop_alg_des:\r\ncase cryptocop_alg_3des:\r\ncase cryptocop_alg_aes:\r\nif (tinit->cipher_mode != cryptocop_cipher_mode_ecb && tinit->cipher_mode != cryptocop_cipher_mode_cbc) return -EINVAL;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint cryptocop_new_session(cryptocop_session_id *sid, struct cryptocop_transform_init *tinit, int alloc_flag)\r\n{\r\nstruct cryptocop_session *sess;\r\nstruct cryptocop_transform_init *tfrm_in = tinit;\r\nstruct cryptocop_transform_init *tmp_in;\r\nint no_tfrms = 0;\r\nint i;\r\nunsigned long int flags;\r\ninit_stream_coprocessor();\r\nwhile (tfrm_in){\r\nint err;\r\n++no_tfrms;\r\nif ((err = transform_ok(tfrm_in))) {\r\nDEBUG_API(printk("cryptocop_new_session, bad transform\n"));\r\nreturn err;\r\n}\r\ntfrm_in = tfrm_in->next;\r\n}\r\nif (0 == no_tfrms) {\r\nDEBUG_API(printk("cryptocop_new_session, no transforms specified\n"));\r\nreturn -EINVAL;\r\n}\r\nsess = kmalloc(sizeof(struct cryptocop_session), alloc_flag);\r\nif (!sess){\r\nDEBUG_API(printk("cryptocop_new_session, kmalloc cryptocop_session\n"));\r\nreturn -ENOMEM;\r\n}\r\nsess->tfrm_ctx = kmalloc(no_tfrms * sizeof(struct cryptocop_transform_ctx), alloc_flag);\r\nif (!sess->tfrm_ctx) {\r\nDEBUG_API(printk("cryptocop_new_session, kmalloc cryptocop_transform_ctx\n"));\r\nkfree(sess);\r\nreturn -ENOMEM;\r\n}\r\ntfrm_in = tinit;\r\nfor (i = 0; i < no_tfrms; i++){\r\ntmp_in = tfrm_in->next;\r\nwhile (tmp_in){\r\nif (tmp_in->tid == tfrm_in->tid) {\r\nDEBUG_API(printk("cryptocop_new_session, duplicate transform ids\n"));\r\nkfree(sess->tfrm_ctx);\r\nkfree(sess);\r\nreturn -EINVAL;\r\n}\r\ntmp_in = tmp_in->next;\r\n}\r\nmemcpy(&sess->tfrm_ctx[i].init, tfrm_in, sizeof(struct cryptocop_transform_init));\r\nsess->tfrm_ctx[i].dec_key_set = 0;\r\nsess->tfrm_ctx[i].next = &sess->tfrm_ctx[i] + 1;\r\ntfrm_in = tfrm_in->next;\r\n}\r\nsess->tfrm_ctx[i-1].next = NULL;\r\nspin_lock_irqsave(&cryptocop_sessions_lock, flags);\r\nsess->sid = next_sid;\r\nnext_sid++;\r\nif (next_sid == 0) next_sid = 1;\r\nsess->next = cryptocop_sessions;\r\ncryptocop_sessions = sess;\r\nspin_unlock_irqrestore(&cryptocop_sessions_lock, flags);\r\n*sid = sess->sid;\r\nreturn 0;\r\n}\r\nint cryptocop_free_session(cryptocop_session_id sid)\r\n{\r\nstruct cryptocop_transform_ctx *tc;\r\nstruct cryptocop_session *sess = NULL;\r\nstruct cryptocop_session *psess = NULL;\r\nunsigned long int flags;\r\nint i;\r\nLIST_HEAD(remove_list);\r\nstruct list_head *node, *tmp;\r\nstruct cryptocop_prio_job *pj;\r\nDEBUG(printk("cryptocop_free_session: sid=%lld\n", sid));\r\nspin_lock_irqsave(&cryptocop_sessions_lock, flags);\r\nsess = cryptocop_sessions;\r\nwhile (sess && sess->sid != sid){\r\npsess = sess;\r\nsess = sess->next;\r\n}\r\nif (sess){\r\nif (psess){\r\npsess->next = sess->next;\r\n} else {\r\ncryptocop_sessions = sess->next;\r\n}\r\n}\r\nspin_unlock_irqrestore(&cryptocop_sessions_lock, flags);\r\nif (!sess) return -EINVAL;\r\nspin_lock_irqsave(&cryptocop_job_queue_lock, flags);\r\nfor (i = 0; i < cryptocop_prio_no_prios; i++){\r\nif (!list_empty(&(cryptocop_job_queues[i].jobs))){\r\nlist_for_each_safe(node, tmp, &(cryptocop_job_queues[i].jobs)) {\r\npj = list_entry(node, struct cryptocop_prio_job, node);\r\nif (pj->oper->sid == sid) {\r\nlist_move_tail(node, &remove_list);\r\n}\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&cryptocop_job_queue_lock, flags);\r\nlist_for_each_safe(node, tmp, &remove_list) {\r\nlist_del(node);\r\npj = list_entry(node, struct cryptocop_prio_job, node);\r\npj->oper->operation_status = -EAGAIN;\r\nDEBUG(printk("cryptocop_free_session: pj=0x%p, pj->oper=0x%p, pj->iop=0x%p\n", pj, pj->oper, pj->iop));\r\npj->oper->cb(pj->oper, pj->oper->cb_data);\r\ndelete_internal_operation(pj->iop);\r\nkfree(pj);\r\n}\r\ntc = sess->tfrm_ctx;\r\nwhile (tc){\r\nDEBUG(printk("cryptocop_free_session: memset keys, tfrm id=%d\n", tc->init.tid));\r\nmemset(tc->init.key, 0xff, CRYPTOCOP_MAX_KEY_LENGTH);\r\nmemset(tc->dec_key, 0xff, CRYPTOCOP_MAX_KEY_LENGTH);\r\ntc = tc->next;\r\n}\r\nkfree(sess->tfrm_ctx);\r\nkfree(sess);\r\nreturn 0;\r\n}\r\nstatic struct cryptocop_session *get_session(cryptocop_session_id sid)\r\n{\r\nstruct cryptocop_session *sess;\r\nunsigned long int flags;\r\nspin_lock_irqsave(&cryptocop_sessions_lock, flags);\r\nsess = cryptocop_sessions;\r\nwhile (sess && (sess->sid != sid)){\r\nsess = sess->next;\r\n}\r\nspin_unlock_irqrestore(&cryptocop_sessions_lock, flags);\r\nreturn sess;\r\n}\r\nstatic struct cryptocop_transform_ctx *get_transform_ctx(struct cryptocop_session *sess, cryptocop_tfrm_id tid)\r\n{\r\nstruct cryptocop_transform_ctx *tc = sess->tfrm_ctx;\r\nDEBUG(printk("get_transform_ctx, sess=0x%p, tid=%d\n", sess, tid));\r\nassert(sess != NULL);\r\nwhile (tc && tc->init.tid != tid){\r\nDEBUG(printk("tc=0x%p, tc->next=0x%p\n", tc, tc->next));\r\ntc = tc->next;\r\n}\r\nDEBUG(printk("get_transform_ctx, returning tc=0x%p\n", tc));\r\nreturn tc;\r\n}\r\nstatic u32 aes_ks_subword(const u32 w)\r\n{\r\nu8 bytes[4];\r\n*(u32*)(&bytes[0]) = w;\r\nbytes[0] = aes_sbox[bytes[0]];\r\nbytes[1] = aes_sbox[bytes[1]];\r\nbytes[2] = aes_sbox[bytes[2]];\r\nbytes[3] = aes_sbox[bytes[3]];\r\nreturn *(u32*)(&bytes[0]);\r\n}\r\nstatic void get_aes_decrypt_key(unsigned char *dec_key, const unsigned char *key, unsigned int keylength)\r\n{\r\nu32 temp;\r\nu32 w_ring[8];\r\nu8 w_last_ix;\r\nint i;\r\nu8 nr, nk;\r\nswitch (keylength){\r\ncase 128:\r\nnk = 4;\r\nnr = 10;\r\nbreak;\r\ncase 192:\r\nnk = 6;\r\nnr = 12;\r\nbreak;\r\ncase 256:\r\nnk = 8;\r\nnr = 14;\r\nbreak;\r\ndefault:\r\npanic("stream co-processor: bad aes key length in get_aes_decrypt_key\n");\r\n};\r\nfor (i = 0; i < nk; i+=1) {\r\nw_ring[i] = be32_to_cpu(*(u32*)&key[4*i]);\r\n}\r\ni = (int)nk;\r\nw_last_ix = i - 1;\r\nwhile (i < (4 * (nr + 2))) {\r\ntemp = w_ring[w_last_ix];\r\nif (!(i % nk)) {\r\ntemp = (temp << 8) | (temp >> 24);\r\ntemp = aes_ks_subword(temp);\r\ntemp ^= round_constant[i/nk - 1];\r\n} else if ((nk > 6) && ((i % nk) == 4)) {\r\ntemp = aes_ks_subword(temp);\r\n}\r\nw_last_ix = (w_last_ix + 1) % nk;\r\ntemp ^= w_ring[w_last_ix];\r\nw_ring[w_last_ix] = temp;\r\nif (i >= (4 * nr)) {\r\n*(u32*)dec_key = cpu_to_be32(temp);\r\ndec_key += 4;\r\n}\r\n++i;\r\n}\r\n}\r\nint cryptocop_job_queue_insert_csum(struct cryptocop_operation *operation)\r\n{\r\nreturn cryptocop_job_queue_insert(cryptocop_prio_kernel_csum, operation);\r\n}\r\nint cryptocop_job_queue_insert_crypto(struct cryptocop_operation *operation)\r\n{\r\nreturn cryptocop_job_queue_insert(cryptocop_prio_kernel, operation);\r\n}\r\nint cryptocop_job_queue_insert_user_job(struct cryptocop_operation *operation)\r\n{\r\nreturn cryptocop_job_queue_insert(cryptocop_prio_user, operation);\r\n}\r\nstatic int cryptocop_job_queue_insert(cryptocop_queue_priority prio, struct cryptocop_operation *operation)\r\n{\r\nint ret;\r\nstruct cryptocop_prio_job *pj = NULL;\r\nunsigned long int flags;\r\nDEBUG(printk("cryptocop_job_queue_insert(%d, 0x%p)\n", prio, operation));\r\nif (!operation || !operation->cb){\r\nDEBUG_API(printk("cryptocop_job_queue_insert oper=0x%p, NULL operation or callback\n", operation));\r\nreturn -EINVAL;\r\n}\r\nif ((ret = cryptocop_job_setup(&pj, operation)) != 0){\r\nDEBUG_API(printk("cryptocop_job_queue_insert: job setup failed\n"));\r\nreturn ret;\r\n}\r\nassert(pj != NULL);\r\nspin_lock_irqsave(&cryptocop_job_queue_lock, flags);\r\nlist_add_tail(&pj->node, &cryptocop_job_queues[prio].jobs);\r\nspin_unlock_irqrestore(&cryptocop_job_queue_lock, flags);\r\ncryptocop_start_job();\r\nreturn 0;\r\n}\r\nstatic void cryptocop_do_tasklet(unsigned long unused)\r\n{\r\nstruct list_head *node;\r\nstruct cryptocop_prio_job *pj = NULL;\r\nunsigned long flags;\r\nDEBUG(printk("cryptocop_do_tasklet: entering\n"));\r\ndo {\r\nspin_lock_irqsave(&cryptocop_completed_jobs_lock, flags);\r\nif (!list_empty(&cryptocop_completed_jobs)){\r\nnode = cryptocop_completed_jobs.next;\r\nlist_del(node);\r\npj = list_entry(node, struct cryptocop_prio_job, node);\r\n} else {\r\npj = NULL;\r\n}\r\nspin_unlock_irqrestore(&cryptocop_completed_jobs_lock, flags);\r\nif (pj) {\r\nassert(pj->oper != NULL);\r\nDEBUG(printk("cryptocop_do_tasklet: callback 0x%p, data 0x%p\n", pj->oper->cb, pj->oper->cb_data));\r\npj->oper->operation_status = 0;\r\npj->oper->cb(pj->oper, pj->oper->cb_data);\r\ndelete_internal_operation(pj->iop);\r\nkfree(pj);\r\n}\r\n} while (pj != NULL);\r\nDEBUG(printk("cryptocop_do_tasklet: exiting\n"));\r\n}\r\nstatic irqreturn_t\r\ndma_done_interrupt(int irq, void *dev_id)\r\n{\r\nstruct cryptocop_prio_job *done_job;\r\nreg_dma_rw_ack_intr ack_intr = {\r\n.data = 1,\r\n};\r\nREG_WR(dma, IN_DMA_INST, rw_ack_intr, ack_intr);\r\nDEBUG(printk("cryptocop DMA done\n"));\r\nspin_lock(&running_job_lock);\r\nif (cryptocop_running_job == NULL){\r\nprintk("stream co-processor got interrupt when not busy\n");\r\nspin_unlock(&running_job_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\ndone_job = cryptocop_running_job;\r\ncryptocop_running_job = NULL;\r\nspin_unlock(&running_job_lock);\r\nif (!spin_trylock(&cryptocop_process_lock)){\r\nDEBUG(printk("cryptocop irq handler, not starting a job\n"));\r\n} else {\r\ncryptocop_start_job();\r\nspin_unlock(&cryptocop_process_lock);\r\n}\r\ndone_job->oper->operation_status = 0;\r\nif (done_job->oper->fast_callback){\r\ndone_job->oper->cb(done_job->oper, done_job->oper->cb_data);\r\ndelete_internal_operation(done_job->iop);\r\nkfree(done_job);\r\n} else {\r\nspin_lock(&cryptocop_completed_jobs_lock);\r\nlist_add_tail(&(done_job->node), &cryptocop_completed_jobs);\r\nspin_unlock(&cryptocop_completed_jobs_lock);\r\ntasklet_schedule(&cryptocop_tasklet);\r\n}\r\nDEBUG(printk("cryptocop leave irq handler\n"));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int init_cryptocop(void)\r\n{\r\nunsigned long flags;\r\nreg_dma_rw_cfg dma_cfg = {.en = 1};\r\nreg_dma_rw_intr_mask intr_mask_in = {.data = regk_dma_yes};\r\nreg_dma_rw_ack_intr ack_intr = {.data = 1,.in_eop = 1 };\r\nreg_strcop_rw_cfg strcop_cfg = {\r\n.ipend = regk_strcop_little,\r\n.td1 = regk_strcop_e,\r\n.td2 = regk_strcop_d,\r\n.td3 = regk_strcop_e,\r\n.ignore_sync = 0,\r\n.en = 1\r\n};\r\nif (request_irq(DMA_IRQ, dma_done_interrupt, 0,\r\n"stream co-processor DMA", NULL))\r\npanic("request_irq stream co-processor irq dma9");\r\n(void)crisv32_request_dma(OUT_DMA, "strcop", DMA_PANIC_ON_ERROR,\r\n0, dma_strp);\r\n(void)crisv32_request_dma(IN_DMA, "strcop", DMA_PANIC_ON_ERROR,\r\n0, dma_strp);\r\nlocal_irq_save(flags);\r\nstrcop_cfg.en = 0;\r\nREG_WR(strcop, regi_strcop, rw_cfg, strcop_cfg);\r\nstrcop_cfg.en = 1;\r\nREG_WR(strcop, regi_strcop, rw_cfg, strcop_cfg);\r\nREG_WR(dma, IN_DMA_INST, rw_cfg, dma_cfg);\r\nREG_WR(dma, OUT_DMA_INST, rw_cfg, dma_cfg);\r\nDMA_WR_CMD(OUT_DMA_INST, regk_dma_set_w_size4);\r\nDMA_WR_CMD(IN_DMA_INST, regk_dma_set_w_size4);\r\nREG_WR(dma, IN_DMA_INST, rw_intr_mask, intr_mask_in);\r\nREG_WR(dma, IN_DMA_INST, rw_ack_intr, ack_intr);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic void release_cryptocop(void)\r\n{\r\nunsigned long flags;\r\nreg_dma_rw_cfg dma_cfg = {.en = 0};\r\nreg_dma_rw_intr_mask intr_mask_in = {0};\r\nreg_dma_rw_ack_intr ack_intr = {.data = 1,.in_eop = 1 };\r\nlocal_irq_save(flags);\r\nREG_WR(dma, IN_DMA_INST, rw_ack_intr, ack_intr);\r\nREG_WR(dma, IN_DMA_INST, rw_cfg, dma_cfg);\r\nREG_WR(dma, OUT_DMA_INST, rw_cfg, dma_cfg);\r\nREG_WR(dma, IN_DMA_INST, rw_intr_mask, intr_mask_in);\r\nlocal_irq_restore(flags);\r\nfree_irq(DMA_IRQ, NULL);\r\n(void)crisv32_free_dma(OUT_DMA);\r\n(void)crisv32_free_dma(IN_DMA);\r\n}\r\nstatic int cryptocop_job_queue_init(void)\r\n{\r\nint i;\r\nINIT_LIST_HEAD(&cryptocop_completed_jobs);\r\nfor (i = 0; i < cryptocop_prio_no_prios; i++){\r\ncryptocop_job_queues[i].prio = (cryptocop_queue_priority)i;\r\nINIT_LIST_HEAD(&cryptocop_job_queues[i].jobs);\r\n}\r\nreturn 0;\r\n}\r\nstatic void cryptocop_job_queue_close(void)\r\n{\r\nstruct list_head *node, *tmp;\r\nstruct cryptocop_prio_job *pj = NULL;\r\nunsigned long int process_flags, flags;\r\nint i;\r\nspin_lock_irqsave(&cryptocop_process_lock, process_flags);\r\nfor (i = 0; i < cryptocop_prio_no_prios; i++){\r\nif (!list_empty(&(cryptocop_job_queues[i].jobs))){\r\nlist_for_each_safe(node, tmp, &(cryptocop_job_queues[i].jobs)) {\r\npj = list_entry(node, struct cryptocop_prio_job, node);\r\nlist_del(node);\r\nDEBUG(printk("cryptocop_job_queue_close: callback 0x%p, data 0x%p\n", pj->oper->cb, pj->oper->cb_data));\r\npj->oper->operation_status = -EINTR;\r\npj->oper->cb(pj->oper, pj->oper->cb_data);\r\ndelete_internal_operation(pj->iop);\r\nkfree(pj);\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&cryptocop_process_lock, process_flags);\r\nspin_lock_irqsave(&running_job_lock, flags);\r\nif (cryptocop_running_job){\r\nreg_strcop_rw_cfg rw_cfg;\r\nreg_dma_rw_cfg dma_out_cfg, dma_in_cfg;\r\ndma_out_cfg = REG_RD(dma, OUT_DMA_INST, rw_cfg);\r\ndma_out_cfg.en = regk_dma_no;\r\nREG_WR(dma, OUT_DMA_INST, rw_cfg, dma_out_cfg);\r\ndma_in_cfg = REG_RD(dma, IN_DMA_INST, rw_cfg);\r\ndma_in_cfg.en = regk_dma_no;\r\nREG_WR(dma, IN_DMA_INST, rw_cfg, dma_in_cfg);\r\nrw_cfg = REG_RD(strcop, regi_strcop, rw_cfg);\r\nrw_cfg.en = 0;\r\nREG_WR(strcop, regi_strcop, rw_cfg, rw_cfg);\r\npj = cryptocop_running_job;\r\ncryptocop_running_job = NULL;\r\nDEBUG(printk("cryptocop_job_queue_close: callback 0x%p, data 0x%p\n", pj->oper->cb, pj->oper->cb_data));\r\npj->oper->operation_status = -EINTR;\r\npj->oper->cb(pj->oper, pj->oper->cb_data);\r\ndelete_internal_operation(pj->iop);\r\nkfree(pj);\r\n}\r\nspin_unlock_irqrestore(&running_job_lock, flags);\r\nspin_lock_irqsave(&cryptocop_completed_jobs_lock, flags);\r\nlist_for_each_safe(node, tmp, &cryptocop_completed_jobs) {\r\npj = list_entry(node, struct cryptocop_prio_job, node);\r\nlist_del(node);\r\nDEBUG(printk("cryptocop_job_queue_close: callback 0x%p, data 0x%p\n", pj->oper->cb, pj->oper->cb_data));\r\npj->oper->operation_status = -EINTR;\r\npj->oper->cb(pj->oper, pj->oper->cb_data);\r\ndelete_internal_operation(pj->iop);\r\nkfree(pj);\r\n}\r\nspin_unlock_irqrestore(&cryptocop_completed_jobs_lock, flags);\r\n}\r\nstatic void cryptocop_start_job(void)\r\n{\r\nint i;\r\nstruct cryptocop_prio_job *pj;\r\nunsigned long int flags;\r\nunsigned long int running_job_flags;\r\nreg_strcop_rw_cfg rw_cfg = {.en = 1, .ignore_sync = 0};\r\nDEBUG(printk("cryptocop_start_job: entering\n"));\r\nspin_lock_irqsave(&running_job_lock, running_job_flags);\r\nif (cryptocop_running_job != NULL){\r\nDEBUG(printk("cryptocop_start_job: already running, exit\n"));\r\nspin_unlock_irqrestore(&running_job_lock, running_job_flags);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&cryptocop_job_queue_lock, flags);\r\nfor (i = cryptocop_prio_kernel_csum; (i < cryptocop_prio_no_prios) && list_empty(&cryptocop_job_queues[i].jobs); i++);\r\nif (i == cryptocop_prio_no_prios) {\r\nspin_unlock_irqrestore(&cryptocop_job_queue_lock, flags);\r\nspin_unlock_irqrestore(&running_job_lock, running_job_flags);\r\nDEBUG(printk("cryptocop_start_job: no jobs to run\n"));\r\nreturn;\r\n}\r\nDEBUG(printk("starting job for prio %d\n", i));\r\npj = list_entry(cryptocop_job_queues[i].jobs.next, struct cryptocop_prio_job, node);\r\nlist_del(&pj->node);\r\nspin_unlock_irqrestore(&cryptocop_job_queue_lock, flags);\r\ncryptocop_running_job = pj;\r\nswitch (pj->iop->tdes_mode){\r\ncase cryptocop_3des_eee:\r\nrw_cfg.td1 = regk_strcop_e;\r\nrw_cfg.td2 = regk_strcop_e;\r\nrw_cfg.td3 = regk_strcop_e;\r\nbreak;\r\ncase cryptocop_3des_eed:\r\nrw_cfg.td1 = regk_strcop_e;\r\nrw_cfg.td2 = regk_strcop_e;\r\nrw_cfg.td3 = regk_strcop_d;\r\nbreak;\r\ncase cryptocop_3des_ede:\r\nrw_cfg.td1 = regk_strcop_e;\r\nrw_cfg.td2 = regk_strcop_d;\r\nrw_cfg.td3 = regk_strcop_e;\r\nbreak;\r\ncase cryptocop_3des_edd:\r\nrw_cfg.td1 = regk_strcop_e;\r\nrw_cfg.td2 = regk_strcop_d;\r\nrw_cfg.td3 = regk_strcop_d;\r\nbreak;\r\ncase cryptocop_3des_dee:\r\nrw_cfg.td1 = regk_strcop_d;\r\nrw_cfg.td2 = regk_strcop_e;\r\nrw_cfg.td3 = regk_strcop_e;\r\nbreak;\r\ncase cryptocop_3des_ded:\r\nrw_cfg.td1 = regk_strcop_d;\r\nrw_cfg.td2 = regk_strcop_e;\r\nrw_cfg.td3 = regk_strcop_d;\r\nbreak;\r\ncase cryptocop_3des_dde:\r\nrw_cfg.td1 = regk_strcop_d;\r\nrw_cfg.td2 = regk_strcop_d;\r\nrw_cfg.td3 = regk_strcop_e;\r\nbreak;\r\ncase cryptocop_3des_ddd:\r\nrw_cfg.td1 = regk_strcop_d;\r\nrw_cfg.td2 = regk_strcop_d;\r\nrw_cfg.td3 = regk_strcop_d;\r\nbreak;\r\ndefault:\r\nDEBUG(printk("cryptocop_setup_dma_list: bad 3DES mode\n"));\r\n}\r\nswitch (pj->iop->csum_mode){\r\ncase cryptocop_csum_le:\r\nrw_cfg.ipend = regk_strcop_little;\r\nbreak;\r\ncase cryptocop_csum_be:\r\nrw_cfg.ipend = regk_strcop_big;\r\nbreak;\r\ndefault:\r\nDEBUG(printk("cryptocop_setup_dma_list: bad checksum mode\n"));\r\n}\r\nREG_WR(strcop, regi_strcop, rw_cfg, rw_cfg);\r\nDEBUG(printk("cryptocop_start_job: starting DMA, new cryptocop_running_job=0x%p\n"\r\n"ctx_in: 0x%p, phys: 0x%p\n"\r\n"ctx_out: 0x%p, phys: 0x%p\n",\r\npj,\r\n&pj->iop->ctx_in, (char*)virt_to_phys(&pj->iop->ctx_in),\r\n&pj->iop->ctx_out, (char*)virt_to_phys(&pj->iop->ctx_out)));\r\nflush_dma_context(&pj->iop->ctx_in);\r\nDMA_START_CONTEXT(IN_DMA_INST, virt_to_phys(&pj->iop->ctx_in));\r\nDMA_START_CONTEXT(OUT_DMA_INST, virt_to_phys(&pj->iop->ctx_out));\r\nspin_unlock_irqrestore(&running_job_lock, running_job_flags);\r\nDEBUG(printk("cryptocop_start_job: exiting\n"));\r\n}\r\nstatic int cryptocop_job_setup(struct cryptocop_prio_job **pj, struct cryptocop_operation *operation)\r\n{\r\nint err;\r\nint alloc_flag = operation->in_interrupt ? GFP_ATOMIC : GFP_KERNEL;\r\nvoid *iop_alloc_ptr = NULL;\r\n*pj = kmalloc(sizeof (struct cryptocop_prio_job), alloc_flag);\r\nif (!*pj) return -ENOMEM;\r\nDEBUG(printk("cryptocop_job_setup: operation=0x%p\n", operation));\r\n(*pj)->oper = operation;\r\nDEBUG(printk("cryptocop_job_setup, cb=0x%p cb_data=0x%p\n", (*pj)->oper->cb, (*pj)->oper->cb_data));\r\nif (operation->use_dmalists) {\r\nDEBUG(print_user_dma_lists(&operation->list_op));\r\nif (!operation->list_op.inlist || !operation->list_op.outlist || !operation->list_op.out_data_buf || !operation->list_op.in_data_buf){\r\nDEBUG_API(printk("cryptocop_job_setup: bad indata (use_dmalists)\n"));\r\nkfree(*pj);\r\nreturn -EINVAL;\r\n}\r\niop_alloc_ptr = kmalloc(DESCR_ALLOC_PAD + sizeof(struct cryptocop_int_operation), alloc_flag);\r\nif (!iop_alloc_ptr) {\r\nDEBUG_API(printk("cryptocop_job_setup: kmalloc cryptocop_int_operation\n"));\r\nkfree(*pj);\r\nreturn -ENOMEM;\r\n}\r\n(*pj)->iop = (struct cryptocop_int_operation*)(((unsigned long int)(iop_alloc_ptr + DESCR_ALLOC_PAD + offsetof(struct cryptocop_int_operation, ctx_out)) & ~0x0000001F) - offsetof(struct cryptocop_int_operation, ctx_out));\r\nDEBUG(memset((*pj)->iop, 0xff, sizeof(struct cryptocop_int_operation)));\r\n(*pj)->iop->alloc_ptr = iop_alloc_ptr;\r\n(*pj)->iop->sid = operation->sid;\r\n(*pj)->iop->cdesc_out = NULL;\r\n(*pj)->iop->cdesc_in = NULL;\r\n(*pj)->iop->tdes_mode = operation->list_op.tdes_mode;\r\n(*pj)->iop->csum_mode = operation->list_op.csum_mode;\r\n(*pj)->iop->ddesc_out = operation->list_op.outlist;\r\n(*pj)->iop->ddesc_in = operation->list_op.inlist;\r\n(*pj)->iop->ctx_out.next = NULL;\r\n(*pj)->iop->ctx_out.eol = 1;\r\n(*pj)->iop->ctx_out.saved_data = operation->list_op.outlist;\r\n(*pj)->iop->ctx_out.saved_data_buf = operation->list_op.out_data_buf;\r\n(*pj)->iop->ctx_in.next = NULL;\r\n(*pj)->iop->ctx_in.eol = 1;\r\n(*pj)->iop->ctx_in.saved_data = operation->list_op.inlist;\r\n(*pj)->iop->ctx_in.saved_data_buf = operation->list_op.in_data_buf;\r\n} else {\r\nif ((err = cryptocop_setup_dma_list(operation, &(*pj)->iop, alloc_flag))) {\r\nDEBUG_API(printk("cryptocop_job_setup: cryptocop_setup_dma_list failed %d\n", err));\r\nkfree(*pj);\r\nreturn err;\r\n}\r\n}\r\nDEBUG(print_dma_descriptors((*pj)->iop));\r\nDEBUG(printk("cryptocop_job_setup, DMA list setup successful\n"));\r\nreturn 0;\r\n}\r\nstatic int cryptocop_open(struct inode *inode, struct file *filp)\r\n{\r\nint p = iminor(inode);\r\nif (p != CRYPTOCOP_MINOR) return -EINVAL;\r\nfilp->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int cryptocop_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct cryptocop_private *dev = filp->private_data;\r\nstruct cryptocop_private *dev_next;\r\nwhile (dev){\r\ndev_next = dev->next;\r\nif (dev->sid != CRYPTOCOP_SESSION_ID_NONE) {\r\n(void)cryptocop_free_session(dev->sid);\r\n}\r\nkfree(dev);\r\ndev = dev_next;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cryptocop_ioctl_close_session(struct inode *inode, struct file *filp,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct cryptocop_private *dev = filp->private_data;\r\nstruct cryptocop_private *prev_dev = NULL;\r\nstruct strcop_session_op *sess_op = (struct strcop_session_op *)arg;\r\nstruct strcop_session_op sop;\r\nint err;\r\nDEBUG(printk("cryptocop_ioctl_close_session\n"));\r\nif (!access_ok(VERIFY_READ, sess_op, sizeof(struct strcop_session_op)))\r\nreturn -EFAULT;\r\nerr = copy_from_user(&sop, sess_op, sizeof(struct strcop_session_op));\r\nif (err) return -EFAULT;\r\nwhile (dev && (dev->sid != sop.ses_id)) {\r\nprev_dev = dev;\r\ndev = dev->next;\r\n}\r\nif (dev){\r\nif (prev_dev){\r\nprev_dev->next = dev->next;\r\n} else {\r\nfilp->private_data = dev->next;\r\n}\r\nerr = cryptocop_free_session(dev->sid);\r\nif (err) return -EFAULT;\r\n} else {\r\nDEBUG_API(printk("cryptocop_ioctl_close_session: session %lld not found\n", sop.ses_id));\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ioctl_process_job_callback(struct cryptocop_operation *op, void*cb_data)\r\n{\r\nstruct ioctl_job_cb_ctx *jc = (struct ioctl_job_cb_ctx *)cb_data;\r\nDEBUG(printk("ioctl_process_job_callback: op=0x%p, cb_data=0x%p\n", op, cb_data));\r\njc->processed = 1;\r\nwake_up(&cryptocop_ioc_process_wq);\r\n}\r\nstatic size_t first_cfg_change_ix(struct strcop_crypto_op *crp_op)\r\n{\r\nsize_t ch_ix = 0;\r\nif (crp_op->do_cipher) ch_ix = crp_op->cipher_start;\r\nif (crp_op->do_digest && (crp_op->digest_start < ch_ix)) ch_ix = crp_op->digest_start;\r\nif (crp_op->do_csum && (crp_op->csum_start < ch_ix)) ch_ix = crp_op->csum_start;\r\nDEBUG(printk("first_cfg_change_ix: ix=%d\n", ch_ix));\r\nreturn ch_ix;\r\n}\r\nstatic size_t next_cfg_change_ix(struct strcop_crypto_op *crp_op, size_t ix)\r\n{\r\nsize_t ch_ix = INT_MAX;\r\nsize_t tmp_ix = 0;\r\nif (crp_op->do_cipher && ((crp_op->cipher_start + crp_op->cipher_len) > ix)){\r\nif (crp_op->cipher_start > ix) {\r\nch_ix = crp_op->cipher_start;\r\n} else {\r\nch_ix = crp_op->cipher_start + crp_op->cipher_len;\r\n}\r\n}\r\nif (crp_op->do_digest && ((crp_op->digest_start + crp_op->digest_len) > ix)){\r\nif (crp_op->digest_start > ix) {\r\ntmp_ix = crp_op->digest_start;\r\n} else {\r\ntmp_ix = crp_op->digest_start + crp_op->digest_len;\r\n}\r\nif (tmp_ix < ch_ix) ch_ix = tmp_ix;\r\n}\r\nif (crp_op->do_csum && ((crp_op->csum_start + crp_op->csum_len) > ix)){\r\nif (crp_op->csum_start > ix) {\r\ntmp_ix = crp_op->csum_start;\r\n} else {\r\ntmp_ix = crp_op->csum_start + crp_op->csum_len;\r\n}\r\nif (tmp_ix < ch_ix) ch_ix = tmp_ix;\r\n}\r\nif (ch_ix == INT_MAX) ch_ix = ix;\r\nDEBUG(printk("next_cfg_change_ix prev ix=%d, next ix=%d\n", ix, ch_ix));\r\nreturn ch_ix;\r\n}\r\nstatic int map_pages_to_iovec(struct iovec *iov, int iovlen, int *iovix, struct page **pages, int nopages, int *pageix, int *pageoffset, int map_length )\r\n{\r\nint tmplen;\r\nassert(iov != NULL);\r\nassert(iovix != NULL);\r\nassert(pages != NULL);\r\nassert(pageix != NULL);\r\nassert(pageoffset != NULL);\r\nDEBUG(printk("map_pages_to_iovec, map_length=%d, iovlen=%d, *iovix=%d, nopages=%d, *pageix=%d, *pageoffset=%d\n", map_length, iovlen, *iovix, nopages, *pageix, *pageoffset));\r\nwhile (map_length > 0){\r\nDEBUG(printk("map_pages_to_iovec, map_length=%d, iovlen=%d, *iovix=%d, nopages=%d, *pageix=%d, *pageoffset=%d\n", map_length, iovlen, *iovix, nopages, *pageix, *pageoffset));\r\nif (*iovix >= iovlen){\r\nDEBUG_API(printk("map_page_to_iovec: *iovix=%d >= iovlen=%d\n", *iovix, iovlen));\r\nreturn 0;\r\n}\r\nif (*pageix >= nopages){\r\nDEBUG_API(printk("map_page_to_iovec: *pageix=%d >= nopages=%d\n", *pageix, nopages));\r\nreturn 0;\r\n}\r\niov[*iovix].iov_base = (unsigned char*)page_address(pages[*pageix]) + *pageoffset;\r\ntmplen = PAGE_SIZE - *pageoffset;\r\nif (tmplen < map_length){\r\n(*pageoffset) = 0;\r\n(*pageix)++;\r\n} else {\r\ntmplen = map_length;\r\n(*pageoffset) += map_length;\r\n}\r\nDEBUG(printk("mapping %d bytes from page %d (or %d) to iovec %d\n", tmplen, *pageix, *pageix-1, *iovix));\r\niov[*iovix].iov_len = tmplen;\r\nmap_length -= tmplen;\r\n(*iovix)++;\r\n}\r\nDEBUG(printk("map_page_to_iovec, exit, *iovix=%d\n", *iovix));\r\nreturn -1;\r\n}\r\nstatic int cryptocop_ioctl_process(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nint i;\r\nstruct cryptocop_private *dev = filp->private_data;\r\nstruct strcop_crypto_op *crp_oper = (struct strcop_crypto_op *)arg;\r\nstruct strcop_crypto_op oper = {0};\r\nint err = 0;\r\nstruct cryptocop_operation *cop = NULL;\r\nstruct ioctl_job_cb_ctx *jc = NULL;\r\nstruct page **inpages = NULL;\r\nstruct page **outpages = NULL;\r\nint noinpages = 0;\r\nint nooutpages = 0;\r\nstruct cryptocop_desc descs[5];\r\nstruct cryptocop_desc_cfg dcfgs[5*3];\r\nint desc_ix = 0;\r\nint dcfg_ix = 0;\r\nstruct cryptocop_tfrm_cfg ciph_tcfg = {0};\r\nstruct cryptocop_tfrm_cfg digest_tcfg = {0};\r\nstruct cryptocop_tfrm_cfg csum_tcfg = {0};\r\nunsigned char *digest_result = NULL;\r\nint digest_length = 0;\r\nint cblocklen = 0;\r\nunsigned char csum_result[CSUM_BLOCK_LENGTH];\r\nstruct cryptocop_session *sess;\r\nint iovlen = 0;\r\nint iovix = 0;\r\nint pageix = 0;\r\nint pageoffset = 0;\r\nsize_t prev_ix = 0;\r\nsize_t next_ix;\r\nint cipher_active, digest_active, csum_active;\r\nint end_digest, end_csum;\r\nint digest_done = 0;\r\nint cipher_done = 0;\r\nint csum_done = 0;\r\nDEBUG(printk("cryptocop_ioctl_process\n"));\r\nif (!access_ok(VERIFY_WRITE, crp_oper, sizeof(struct strcop_crypto_op))){\r\nDEBUG_API(printk("cryptocop_ioctl_process: !access_ok crp_oper!\n"));\r\nreturn -EFAULT;\r\n}\r\nif (copy_from_user(&oper, crp_oper, sizeof(struct strcop_crypto_op))) {\r\nDEBUG_API(printk("cryptocop_ioctl_process: copy_from_user\n"));\r\nreturn -EFAULT;\r\n}\r\nDEBUG(print_strcop_crypto_op(&oper));\r\nwhile (dev && dev->sid != oper.ses_id) dev = dev->next;\r\nif (!dev){\r\nDEBUG_API(printk("cryptocop_ioctl_process: session %lld not found\n", oper.ses_id));\r\nreturn -EINVAL;\r\n}\r\nif (((oper.indata + oper.inlen) < oper.indata) || ((oper.cipher_outdata + oper.cipher_outlen) < oper.cipher_outdata)){\r\nDEBUG_API(printk("cryptocop_ioctl_process: user buffers wrapped around, bad user!\n"));\r\nreturn -EINVAL;\r\n}\r\nif (!access_ok(VERIFY_WRITE, oper.cipher_outdata, oper.cipher_outlen)){\r\nDEBUG_API(printk("cryptocop_ioctl_process: !access_ok out data!\n"));\r\nreturn -EFAULT;\r\n}\r\nif (!access_ok(VERIFY_READ, oper.indata, oper.inlen)){\r\nDEBUG_API(printk("cryptocop_ioctl_process: !access_ok in data!\n"));\r\nreturn -EFAULT;\r\n}\r\ncop = kmalloc(sizeof(struct cryptocop_operation), GFP_KERNEL);\r\nif (!cop) {\r\nDEBUG_API(printk("cryptocop_ioctl_process: kmalloc\n"));\r\nreturn -ENOMEM;\r\n}\r\njc = kmalloc(sizeof(struct ioctl_job_cb_ctx), GFP_KERNEL);\r\nif (!jc) {\r\nDEBUG_API(printk("cryptocop_ioctl_process: kmalloc\n"));\r\nerr = -ENOMEM;\r\ngoto error_cleanup;\r\n}\r\njc->processed = 0;\r\ncop->cb_data = jc;\r\ncop->cb = ioctl_process_job_callback;\r\ncop->operation_status = 0;\r\ncop->use_dmalists = 0;\r\ncop->in_interrupt = 0;\r\ncop->fast_callback = 0;\r\ncop->tfrm_op.tfrm_cfg = NULL;\r\ncop->tfrm_op.desc = NULL;\r\ncop->tfrm_op.indata = NULL;\r\ncop->tfrm_op.incount = 0;\r\ncop->tfrm_op.inlen = 0;\r\ncop->tfrm_op.outdata = NULL;\r\ncop->tfrm_op.outcount = 0;\r\ncop->tfrm_op.outlen = 0;\r\nsess = get_session(oper.ses_id);\r\nif (!sess){\r\nDEBUG_API(printk("cryptocop_ioctl_process: bad session id.\n"));\r\nkfree(cop);\r\nkfree(jc);\r\nreturn -EINVAL;\r\n}\r\nif (oper.do_cipher) {\r\nunsigned int cipher_outlen = 0;\r\nstruct cryptocop_transform_ctx *tc = get_transform_ctx(sess, CRYPTOCOP_IOCTL_CIPHER_TID);\r\nif (!tc) {\r\nDEBUG_API(printk("cryptocop_ioctl_process: no cipher transform in session.\n"));\r\nerr = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\nciph_tcfg.tid = CRYPTOCOP_IOCTL_CIPHER_TID;\r\nciph_tcfg.inject_ix = 0;\r\nciph_tcfg.flags = 0;\r\nif ((oper.cipher_start < 0) || (oper.cipher_len <= 0) || (oper.cipher_start > oper.inlen) || ((oper.cipher_start + oper.cipher_len) > oper.inlen)){\r\nDEBUG_API(printk("cryptocop_ioctl_process: bad cipher length\n"));\r\nkfree(cop);\r\nkfree(jc);\r\nreturn -EINVAL;\r\n}\r\ncblocklen = tc->init.alg == cryptocop_alg_aes ? AES_BLOCK_LENGTH : DES_BLOCK_LENGTH;\r\nif (oper.cipher_len % cblocklen) {\r\nkfree(cop);\r\nkfree(jc);\r\nDEBUG_API(printk("cryptocop_ioctl_process: cipher inlength not multiple of block length.\n"));\r\nreturn -EINVAL;\r\n}\r\ncipher_outlen = oper.cipher_len;\r\nif (tc->init.cipher_mode == cryptocop_cipher_mode_cbc){\r\nif (oper.cipher_explicit) {\r\nciph_tcfg.flags |= CRYPTOCOP_EXPLICIT_IV;\r\nmemcpy(ciph_tcfg.iv, oper.cipher_iv, cblocklen);\r\n} else {\r\ncipher_outlen = oper.cipher_len - cblocklen;\r\n}\r\n} else {\r\nif (oper.cipher_explicit){\r\nkfree(cop);\r\nkfree(jc);\r\nDEBUG_API(printk("cryptocop_ioctl_process: explicit_iv when not CBC mode\n"));\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (oper.cipher_outlen != cipher_outlen) {\r\nkfree(cop);\r\nkfree(jc);\r\nDEBUG_API(printk("cryptocop_ioctl_process: cipher_outlen incorrect, should be %d not %d.\n", cipher_outlen, oper.cipher_outlen));\r\nreturn -EINVAL;\r\n}\r\nif (oper.decrypt){\r\nciph_tcfg.flags |= CRYPTOCOP_DECRYPT;\r\n} else {\r\nciph_tcfg.flags |= CRYPTOCOP_ENCRYPT;\r\n}\r\nciph_tcfg.next = cop->tfrm_op.tfrm_cfg;\r\ncop->tfrm_op.tfrm_cfg = &ciph_tcfg;\r\n}\r\nif (oper.do_digest){\r\nstruct cryptocop_transform_ctx *tc = get_transform_ctx(sess, CRYPTOCOP_IOCTL_DIGEST_TID);\r\nif (!tc) {\r\nDEBUG_API(printk("cryptocop_ioctl_process: no digest transform in session.\n"));\r\nerr = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\ndigest_length = tc->init.alg == cryptocop_alg_md5 ? 16 : 20;\r\ndigest_result = kmalloc(digest_length, GFP_KERNEL);\r\nif (!digest_result) {\r\nDEBUG_API(printk("cryptocop_ioctl_process: kmalloc digest_result\n"));\r\nerr = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\nDEBUG(memset(digest_result, 0xff, digest_length));\r\ndigest_tcfg.tid = CRYPTOCOP_IOCTL_DIGEST_TID;\r\ndigest_tcfg.inject_ix = 0;\r\nciph_tcfg.inject_ix += digest_length;\r\nif ((oper.digest_start < 0) || (oper.digest_len <= 0) || (oper.digest_start > oper.inlen) || ((oper.digest_start + oper.digest_len) > oper.inlen)){\r\nDEBUG_API(printk("cryptocop_ioctl_process: bad digest length\n"));\r\nerr = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\ndigest_tcfg.next = cop->tfrm_op.tfrm_cfg;\r\ncop->tfrm_op.tfrm_cfg = &digest_tcfg;\r\n}\r\nif (oper.do_csum){\r\ncsum_tcfg.tid = CRYPTOCOP_IOCTL_CSUM_TID;\r\ncsum_tcfg.inject_ix = digest_length;\r\nciph_tcfg.inject_ix += 2;\r\nif ((oper.csum_start < 0) || (oper.csum_len <= 0) || (oper.csum_start > oper.inlen) || ((oper.csum_start + oper.csum_len) > oper.inlen)){\r\nDEBUG_API(printk("cryptocop_ioctl_process: bad csum length\n"));\r\nkfree(cop);\r\nkfree(jc);\r\nreturn -EINVAL;\r\n}\r\ncsum_tcfg.next = cop->tfrm_op.tfrm_cfg;\r\ncop->tfrm_op.tfrm_cfg = &csum_tcfg;\r\n}\r\nprev_ix = first_cfg_change_ix(&oper);\r\nif (prev_ix > oper.inlen) {\r\nDEBUG_API(printk("cryptocop_ioctl_process: length mismatch\n"));\r\nnooutpages = noinpages = 0;\r\nerr = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\nDEBUG(printk("cryptocop_ioctl_process: inlen=%d, cipher_outlen=%d\n", oper.inlen, oper.cipher_outlen));\r\nnoinpages = (((unsigned long int)(oper.indata + prev_ix) & ~PAGE_MASK) + oper.inlen - 1 - prev_ix + ~PAGE_MASK) >> PAGE_SHIFT;\r\nDEBUG(printk("cryptocop_ioctl_process: noinpages=%d\n", noinpages));\r\ninpages = kmalloc(noinpages * sizeof(struct page*), GFP_KERNEL);\r\nif (!inpages){\r\nDEBUG_API(printk("cryptocop_ioctl_process: kmalloc inpages\n"));\r\nnooutpages = noinpages = 0;\r\nerr = -ENOMEM;\r\ngoto error_cleanup;\r\n}\r\nif (oper.do_cipher){\r\nnooutpages = (((unsigned long int)oper.cipher_outdata & ~PAGE_MASK) + oper.cipher_outlen - 1 + ~PAGE_MASK) >> PAGE_SHIFT;\r\nDEBUG(printk("cryptocop_ioctl_process: nooutpages=%d\n", nooutpages));\r\noutpages = kmalloc(nooutpages * sizeof(struct page*), GFP_KERNEL);\r\nif (!outpages){\r\nDEBUG_API(printk("cryptocop_ioctl_process: kmalloc outpages\n"));\r\nnooutpages = noinpages = 0;\r\nerr = -ENOMEM;\r\ngoto error_cleanup;\r\n}\r\n}\r\ndown_read(&current->mm->mmap_sem);\r\nerr = get_user_pages(current,\r\ncurrent->mm,\r\n(unsigned long int)(oper.indata + prev_ix),\r\nnoinpages,\r\n0,\r\n0,\r\ninpages,\r\nNULL);\r\nif (err < 0) {\r\nup_read(&current->mm->mmap_sem);\r\nnooutpages = noinpages = 0;\r\nDEBUG_API(printk("cryptocop_ioctl_process: get_user_pages indata\n"));\r\ngoto error_cleanup;\r\n}\r\nnoinpages = err;\r\nif (oper.do_cipher){\r\nerr = get_user_pages(current,\r\ncurrent->mm,\r\n(unsigned long int)oper.cipher_outdata,\r\nnooutpages,\r\n1,\r\n0,\r\noutpages,\r\nNULL);\r\nup_read(&current->mm->mmap_sem);\r\nif (err < 0) {\r\nnooutpages = 0;\r\nDEBUG_API(printk("cryptocop_ioctl_process: get_user_pages outdata\n"));\r\ngoto error_cleanup;\r\n}\r\nnooutpages = err;\r\n} else {\r\nup_read(&current->mm->mmap_sem);\r\n}\r\ncop->tfrm_op.indata = kmalloc((noinpages) * sizeof(struct iovec), GFP_KERNEL);\r\ncop->tfrm_op.outdata = kmalloc((6 + nooutpages) * sizeof(struct iovec), GFP_KERNEL);\r\nif (!cop->tfrm_op.indata || !cop->tfrm_op.outdata) {\r\nDEBUG_API(printk("cryptocop_ioctl_process: kmalloc iovecs\n"));\r\nerr = -ENOMEM;\r\ngoto error_cleanup;\r\n}\r\ncop->tfrm_op.inlen = oper.inlen - prev_ix;\r\ncop->tfrm_op.outlen = 0;\r\nif (oper.do_cipher) cop->tfrm_op.outlen += oper.cipher_outlen;\r\nif (oper.do_digest) cop->tfrm_op.outlen += digest_length;\r\nif (oper.do_csum) cop->tfrm_op.outlen += 2;\r\ncop->tfrm_op.incount = noinpages;\r\nif (noinpages > 1){\r\nsize_t tmplen = cop->tfrm_op.inlen;\r\ncop->tfrm_op.indata[0].iov_len = PAGE_SIZE - ((unsigned long int)(oper.indata + prev_ix) & ~PAGE_MASK);\r\ncop->tfrm_op.indata[0].iov_base = (unsigned char*)page_address(inpages[0]) + ((unsigned long int)(oper.indata + prev_ix) & ~PAGE_MASK);\r\ntmplen -= cop->tfrm_op.indata[0].iov_len;\r\nfor (i = 1; i<noinpages; i++){\r\ncop->tfrm_op.indata[i].iov_len = tmplen < PAGE_SIZE ? tmplen : PAGE_SIZE;\r\ncop->tfrm_op.indata[i].iov_base = (unsigned char*)page_address(inpages[i]);\r\ntmplen -= PAGE_SIZE;\r\n}\r\n} else {\r\ncop->tfrm_op.indata[0].iov_len = oper.inlen - prev_ix;\r\ncop->tfrm_op.indata[0].iov_base = (unsigned char*)page_address(inpages[0]) + ((unsigned long int)(oper.indata + prev_ix) & ~PAGE_MASK);\r\n}\r\niovlen = nooutpages + 6;\r\npageoffset = oper.do_cipher ? ((unsigned long int)oper.cipher_outdata & ~PAGE_MASK) : 0;\r\nnext_ix = next_cfg_change_ix(&oper, prev_ix);\r\nif (prev_ix == next_ix){\r\nDEBUG_API(printk("cryptocop_ioctl_process: length configuration broken.\n"));\r\nerr = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\nwhile (prev_ix != next_ix){\r\nend_digest = end_csum = cipher_active = digest_active = csum_active = 0;\r\ndescs[desc_ix].cfg = NULL;\r\ndescs[desc_ix].length = next_ix - prev_ix;\r\nif (oper.do_cipher && (oper.cipher_start < next_ix) && (prev_ix < (oper.cipher_start + oper.cipher_len))) {\r\ndcfgs[dcfg_ix].tid = CRYPTOCOP_IOCTL_CIPHER_TID;\r\ndcfgs[dcfg_ix].src = cryptocop_source_dma;\r\ncipher_active = 1;\r\nif (next_ix == (oper.cipher_start + oper.cipher_len)){\r\ncipher_done = 1;\r\ndcfgs[dcfg_ix].last = 1;\r\n} else {\r\ndcfgs[dcfg_ix].last = 0;\r\n}\r\ndcfgs[dcfg_ix].next = descs[desc_ix].cfg;\r\ndescs[desc_ix].cfg = &dcfgs[dcfg_ix];\r\n++dcfg_ix;\r\n}\r\nif (oper.do_digest && (oper.digest_start < next_ix) && (prev_ix < (oper.digest_start + oper.digest_len))) {\r\ndigest_active = 1;\r\ndcfgs[dcfg_ix].tid = CRYPTOCOP_IOCTL_DIGEST_TID;\r\ndcfgs[dcfg_ix].src = cryptocop_source_dma;\r\nif (next_ix == (oper.digest_start + oper.digest_len)){\r\nassert(!digest_done);\r\ndigest_done = 1;\r\ndcfgs[dcfg_ix].last = 1;\r\n} else {\r\ndcfgs[dcfg_ix].last = 0;\r\n}\r\ndcfgs[dcfg_ix].next = descs[desc_ix].cfg;\r\ndescs[desc_ix].cfg = &dcfgs[dcfg_ix];\r\n++dcfg_ix;\r\n}\r\nif (oper.do_csum && (oper.csum_start < next_ix) && (prev_ix < (oper.csum_start + oper.csum_len))){\r\ncsum_active = 1;\r\ndcfgs[dcfg_ix].tid = CRYPTOCOP_IOCTL_CSUM_TID;\r\ndcfgs[dcfg_ix].src = cryptocop_source_dma;\r\nif (next_ix == (oper.csum_start + oper.csum_len)){\r\ncsum_done = 1;\r\ndcfgs[dcfg_ix].last = 1;\r\n} else {\r\ndcfgs[dcfg_ix].last = 0;\r\n}\r\ndcfgs[dcfg_ix].next = descs[desc_ix].cfg;\r\ndescs[desc_ix].cfg = &dcfgs[dcfg_ix];\r\n++dcfg_ix;\r\n}\r\nif (!descs[desc_ix].cfg){\r\nDEBUG_API(printk("cryptocop_ioctl_process: data segment %d (%d to %d) had no active transforms\n", desc_ix, prev_ix, next_ix));\r\nerr = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\ndescs[desc_ix].next = &(descs[desc_ix]) + 1;\r\n++desc_ix;\r\nprev_ix = next_ix;\r\nnext_ix = next_cfg_change_ix(&oper, prev_ix);\r\n}\r\nif (desc_ix > 0){\r\ndescs[desc_ix-1].next = NULL;\r\n} else {\r\ndescs[0].next = NULL;\r\n}\r\nif (oper.do_digest) {\r\nDEBUG(printk("cryptocop_ioctl_process: mapping %d byte digest output to iovec %d\n", digest_length, iovix));\r\ncop->tfrm_op.outdata[iovix].iov_base = digest_result;\r\ncop->tfrm_op.outdata[iovix].iov_len = digest_length;\r\n++iovix;\r\n}\r\nif (oper.do_csum) {\r\nDEBUG(printk("cryptocop_ioctl_process: mapping 2 byte csum output to iovec %d\n", iovix));\r\ncop->tfrm_op.outdata[iovix].iov_base = csum_result;\r\ncop->tfrm_op.outdata[iovix].iov_len = 2;\r\n++iovix;\r\n}\r\nif (oper.do_cipher) {\r\nif (!map_pages_to_iovec(cop->tfrm_op.outdata, iovlen, &iovix, outpages, nooutpages, &pageix, &pageoffset, oper.cipher_outlen)){\r\nDEBUG_API(printk("cryptocop_ioctl_process: failed to map pages to iovec.\n"));\r\nerr = -ENOSYS;\r\ngoto error_cleanup;\r\n}\r\n}\r\nDEBUG(printk("cryptocop_ioctl_process: setting cop->tfrm_op.outcount %d\n", iovix));\r\ncop->tfrm_op.outcount = iovix;\r\nassert(iovix <= (nooutpages + 6));\r\ncop->sid = oper.ses_id;\r\ncop->tfrm_op.desc = &descs[0];\r\nDEBUG(printk("cryptocop_ioctl_process: inserting job, cb_data=0x%p\n", cop->cb_data));\r\nif ((err = cryptocop_job_queue_insert_user_job(cop)) != 0) {\r\nDEBUG_API(printk("cryptocop_ioctl_process: insert job %d\n", err));\r\nerr = -EINVAL;\r\ngoto error_cleanup;\r\n}\r\nDEBUG(printk("cryptocop_ioctl_process: begin wait for result\n"));\r\nwait_event(cryptocop_ioc_process_wq, (jc->processed != 0));\r\nDEBUG(printk("cryptocop_ioctl_process: end wait for result\n"));\r\nif (!jc->processed){\r\nprintk(KERN_WARNING "cryptocop_ioctl_process: job not processed at completion\n");\r\nerr = -EIO;\r\ngoto error_cleanup;\r\n}\r\nDEBUG(printk("cryptocop_ioctl_process: operation_status = %d\n", cop->operation_status));\r\nif (cop->operation_status == 0){\r\nif (oper.do_digest){\r\nDEBUG(printk("cryptocop_ioctl_process: copy %d bytes digest to user\n", digest_length));\r\nerr = copy_to_user((unsigned char*)crp_oper + offsetof(struct strcop_crypto_op, digest), digest_result, digest_length);\r\nif (0 != err){\r\nDEBUG_API(printk("cryptocop_ioctl_process: copy_to_user, digest length %d, err %d\n", digest_length, err));\r\nerr = -EFAULT;\r\ngoto error_cleanup;\r\n}\r\n}\r\nif (oper.do_csum){\r\nDEBUG(printk("cryptocop_ioctl_process: copy 2 bytes checksum to user\n"));\r\nerr = copy_to_user((unsigned char*)crp_oper + offsetof(struct strcop_crypto_op, csum), csum_result, 2);\r\nif (0 != err){\r\nDEBUG_API(printk("cryptocop_ioctl_process: copy_to_user, csum, err %d\n", err));\r\nerr = -EFAULT;\r\ngoto error_cleanup;\r\n}\r\n}\r\nerr = 0;\r\n} else {\r\nDEBUG(printk("cryptocop_ioctl_process: returning err = operation_status = %d\n", cop->operation_status));\r\nerr = cop->operation_status;\r\n}\r\nerror_cleanup:\r\nfor (i = 0; i < noinpages; i++){\r\nput_page(inpages[i]);\r\n}\r\nfor (i = 0; i < nooutpages; i++){\r\nint spdl_err;\r\nspdl_err = set_page_dirty_lock(outpages[i]);\r\nDEBUG(if (spdl_err < 0)printk("cryptocop_ioctl_process: set_page_dirty_lock returned %d\n", spdl_err));\r\n}\r\nfor (i = 0; i < nooutpages; i++){\r\nput_page(outpages[i]);\r\n}\r\nkfree(digest_result);\r\nkfree(inpages);\r\nkfree(outpages);\r\nif (cop){\r\nkfree(cop->tfrm_op.indata);\r\nkfree(cop->tfrm_op.outdata);\r\nkfree(cop);\r\n}\r\nkfree(jc);\r\nDEBUG(print_lock_status());\r\nreturn err;\r\n}\r\nstatic int cryptocop_ioctl_create_session(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\ncryptocop_session_id sid;\r\nint err;\r\nstruct cryptocop_private *dev;\r\nstruct strcop_session_op *sess_op = (struct strcop_session_op *)arg;\r\nstruct strcop_session_op sop;\r\nstruct cryptocop_transform_init *tis = NULL;\r\nstruct cryptocop_transform_init ti_cipher = {0};\r\nstruct cryptocop_transform_init ti_digest = {0};\r\nstruct cryptocop_transform_init ti_csum = {0};\r\nif (!access_ok(VERIFY_WRITE, sess_op, sizeof(struct strcop_session_op)))\r\nreturn -EFAULT;\r\nerr = copy_from_user(&sop, sess_op, sizeof(struct strcop_session_op));\r\nif (err) return -EFAULT;\r\nif (sop.cipher != cryptocop_cipher_none) {\r\nif (!access_ok(VERIFY_READ, sop.key, sop.keylen)) return -EFAULT;\r\n}\r\nDEBUG(printk("cryptocop_ioctl_create_session, sess_op:\n"));\r\nDEBUG(printk("\tcipher:%d\n"\r\n"\tcipher_mode:%d\n"\r\n"\tdigest:%d\n"\r\n"\tcsum:%d\n",\r\n(int)sop.cipher,\r\n(int)sop.cmode,\r\n(int)sop.digest,\r\n(int)sop.csum));\r\nif (sop.cipher != cryptocop_cipher_none){\r\nswitch (sop.cipher){\r\ncase cryptocop_cipher_des:\r\nti_cipher.alg = cryptocop_alg_des;\r\nbreak;\r\ncase cryptocop_cipher_3des:\r\nti_cipher.alg = cryptocop_alg_3des;\r\nbreak;\r\ncase cryptocop_cipher_aes:\r\nti_cipher.alg = cryptocop_alg_aes;\r\nbreak;\r\ndefault:\r\nDEBUG_API(printk("create session, bad cipher algorithm %d\n", sop.cipher));\r\nreturn -EINVAL;\r\n};\r\nDEBUG(printk("setting cipher transform %d\n", ti_cipher.alg));\r\ncopy_from_user(ti_cipher.key, sop.key, sop.keylen/8);\r\nti_cipher.keylen = sop.keylen;\r\nswitch (sop.cmode){\r\ncase cryptocop_cipher_mode_cbc:\r\ncase cryptocop_cipher_mode_ecb:\r\nti_cipher.cipher_mode = sop.cmode;\r\nbreak;\r\ndefault:\r\nDEBUG_API(printk("create session, bad cipher mode %d\n", sop.cmode));\r\nreturn -EINVAL;\r\n}\r\nDEBUG(printk("cryptocop_ioctl_create_session: setting CBC mode %d\n", ti_cipher.cipher_mode));\r\nswitch (sop.des3_mode){\r\ncase cryptocop_3des_eee:\r\ncase cryptocop_3des_eed:\r\ncase cryptocop_3des_ede:\r\ncase cryptocop_3des_edd:\r\ncase cryptocop_3des_dee:\r\ncase cryptocop_3des_ded:\r\ncase cryptocop_3des_dde:\r\ncase cryptocop_3des_ddd:\r\nti_cipher.tdes_mode = sop.des3_mode;\r\nbreak;\r\ndefault:\r\nDEBUG_API(printk("create session, bad 3DES mode %d\n", sop.des3_mode));\r\nreturn -EINVAL;\r\n}\r\nti_cipher.tid = CRYPTOCOP_IOCTL_CIPHER_TID;\r\nti_cipher.next = tis;\r\ntis = &ti_cipher;\r\n}\r\nif (sop.digest != cryptocop_digest_none){\r\nDEBUG(printk("setting digest transform\n"));\r\nswitch (sop.digest){\r\ncase cryptocop_digest_md5:\r\nti_digest.alg = cryptocop_alg_md5;\r\nbreak;\r\ncase cryptocop_digest_sha1:\r\nti_digest.alg = cryptocop_alg_sha1;\r\nbreak;\r\ndefault:\r\nDEBUG_API(printk("create session, bad digest algorithm %d\n", sop.digest));\r\nreturn -EINVAL;\r\n}\r\nti_digest.tid = CRYPTOCOP_IOCTL_DIGEST_TID;\r\nti_digest.next = tis;\r\ntis = &ti_digest;\r\n}\r\nif (sop.csum != cryptocop_csum_none){\r\nDEBUG(printk("setting csum transform\n"));\r\nswitch (sop.csum){\r\ncase cryptocop_csum_le:\r\ncase cryptocop_csum_be:\r\nti_csum.csum_mode = sop.csum;\r\nbreak;\r\ndefault:\r\nDEBUG_API(printk("create session, bad checksum algorithm %d\n", sop.csum));\r\nreturn -EINVAL;\r\n}\r\nti_csum.alg = cryptocop_alg_csum;\r\nti_csum.tid = CRYPTOCOP_IOCTL_CSUM_TID;\r\nti_csum.next = tis;\r\ntis = &ti_csum;\r\n}\r\ndev = kmalloc(sizeof(struct cryptocop_private), GFP_KERNEL);\r\nif (!dev){\r\nDEBUG_API(printk("create session, alloc dev\n"));\r\nreturn -ENOMEM;\r\n}\r\nerr = cryptocop_new_session(&sid, tis, GFP_KERNEL);\r\nDEBUG({ if (err) printk("create session, cryptocop_new_session %d\n", err);});\r\nif (err) {\r\nkfree(dev);\r\nreturn err;\r\n}\r\nsess_op->ses_id = sid;\r\ndev->sid = sid;\r\ndev->next = filp->private_data;\r\nfilp->private_data = dev;\r\nreturn 0;\r\n}\r\nstatic long cryptocop_ioctl_unlocked(struct inode *inode,\r\nstruct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nint err = 0;\r\nif (_IOC_TYPE(cmd) != ETRAXCRYPTOCOP_IOCTYPE) {\r\nDEBUG_API(printk("cryptocop_ioctl: wrong type\n"));\r\nreturn -ENOTTY;\r\n}\r\nif (_IOC_NR(cmd) > CRYPTOCOP_IO_MAXNR){\r\nreturn -ENOTTY;\r\n}\r\nif (_IOC_DIR(cmd) & _IOC_READ)\r\nerr = !access_ok(VERIFY_WRITE, (void *)arg, _IOC_SIZE(cmd));\r\nelse if (_IOC_DIR(cmd) & _IOC_WRITE)\r\nerr = !access_ok(VERIFY_READ, (void *)arg, _IOC_SIZE(cmd));\r\nif (err) return -EFAULT;\r\nswitch (cmd) {\r\ncase CRYPTOCOP_IO_CREATE_SESSION:\r\nreturn cryptocop_ioctl_create_session(inode, filp, cmd, arg);\r\ncase CRYPTOCOP_IO_CLOSE_SESSION:\r\nreturn cryptocop_ioctl_close_session(inode, filp, cmd, arg);\r\ncase CRYPTOCOP_IO_PROCESS_OP:\r\nreturn cryptocop_ioctl_process(inode, filp, cmd, arg);\r\ndefault:\r\nDEBUG_API(printk("cryptocop_ioctl: unknown command\n"));\r\nreturn -ENOTTY;\r\n}\r\nreturn 0;\r\n}\r\nstatic long\r\ncryptocop_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct inode *inode = file->f_path.dentry->d_inode;\r\nlong ret;\r\nmutex_lock(&cryptocop_mutex);\r\nret = cryptocop_ioctl_unlocked(inode, filp, cmd, arg);\r\nmutex_unlock(&cryptocop_mutex);\r\nreturn ret;\r\n}\r\nstatic void print_dma_descriptors(struct cryptocop_int_operation *iop)\r\n{\r\nstruct cryptocop_dma_desc *cdesc_out = iop->cdesc_out;\r\nstruct cryptocop_dma_desc *cdesc_in = iop->cdesc_in;\r\nint i;\r\nprintk("print_dma_descriptors start\n");\r\nprintk("iop:\n");\r\nprintk("\tsid: 0x%lld\n", iop->sid);\r\nprintk("\tcdesc_out: 0x%p\n", iop->cdesc_out);\r\nprintk("\tcdesc_in: 0x%p\n", iop->cdesc_in);\r\nprintk("\tddesc_out: 0x%p\n", iop->ddesc_out);\r\nprintk("\tddesc_in: 0x%p\n", iop->ddesc_in);\r\nprintk("\niop->ctx_out: 0x%p phys: 0x%p\n", &iop->ctx_out, (char*)virt_to_phys(&iop->ctx_out));\r\nprintk("\tnext: 0x%p\n"\r\n"\tsaved_data: 0x%p\n"\r\n"\tsaved_data_buf: 0x%p\n",\r\niop->ctx_out.next,\r\niop->ctx_out.saved_data,\r\niop->ctx_out.saved_data_buf);\r\nprintk("\niop->ctx_in: 0x%p phys: 0x%p\n", &iop->ctx_in, (char*)virt_to_phys(&iop->ctx_in));\r\nprintk("\tnext: 0x%p\n"\r\n"\tsaved_data: 0x%p\n"\r\n"\tsaved_data_buf: 0x%p\n",\r\niop->ctx_in.next,\r\niop->ctx_in.saved_data,\r\niop->ctx_in.saved_data_buf);\r\ni = 0;\r\nwhile (cdesc_out) {\r\ndma_descr_data *td;\r\nprintk("cdesc_out %d, desc=0x%p\n", i, cdesc_out->dma_descr);\r\nprintk("\n\tvirt_to_phys(desc): 0x%p\n", (char*)virt_to_phys(cdesc_out->dma_descr));\r\ntd = cdesc_out->dma_descr;\r\nprintk("\n\tbuf: 0x%p\n"\r\n"\tafter: 0x%p\n"\r\n"\tmd: 0x%04x\n"\r\n"\tnext: 0x%p\n",\r\ntd->buf,\r\ntd->after,\r\ntd->md,\r\ntd->next);\r\nprintk("flags:\n"\r\n"\twait:\t%d\n"\r\n"\teol:\t%d\n"\r\n"\touteop:\t%d\n"\r\n"\tineop:\t%d\n"\r\n"\tintr:\t%d\n",\r\ntd->wait,\r\ntd->eol,\r\ntd->out_eop,\r\ntd->in_eop,\r\ntd->intr);\r\ncdesc_out = cdesc_out->next;\r\ni++;\r\n}\r\ni = 0;\r\nwhile (cdesc_in) {\r\ndma_descr_data *td;\r\nprintk("cdesc_in %d, desc=0x%p\n", i, cdesc_in->dma_descr);\r\nprintk("\n\tvirt_to_phys(desc): 0x%p\n", (char*)virt_to_phys(cdesc_in->dma_descr));\r\ntd = cdesc_in->dma_descr;\r\nprintk("\n\tbuf: 0x%p\n"\r\n"\tafter: 0x%p\n"\r\n"\tmd: 0x%04x\n"\r\n"\tnext: 0x%p\n",\r\ntd->buf,\r\ntd->after,\r\ntd->md,\r\ntd->next);\r\nprintk("flags:\n"\r\n"\twait:\t%d\n"\r\n"\teol:\t%d\n"\r\n"\touteop:\t%d\n"\r\n"\tineop:\t%d\n"\r\n"\tintr:\t%d\n",\r\ntd->wait,\r\ntd->eol,\r\ntd->out_eop,\r\ntd->in_eop,\r\ntd->intr);\r\ncdesc_in = cdesc_in->next;\r\ni++;\r\n}\r\nprintk("print_dma_descriptors end\n");\r\n}\r\nstatic void print_strcop_crypto_op(struct strcop_crypto_op *cop)\r\n{\r\nprintk("print_strcop_crypto_op, 0x%p\n", cop);\r\nprintk("indata=0x%p\n"\r\n"inlen=%d\n"\r\n"do_cipher=%d\n"\r\n"decrypt=%d\n"\r\n"cipher_explicit=%d\n"\r\n"cipher_start=%d\n"\r\n"cipher_len=%d\n"\r\n"outdata=0x%p\n"\r\n"outlen=%d\n",\r\ncop->indata,\r\ncop->inlen,\r\ncop->do_cipher,\r\ncop->decrypt,\r\ncop->cipher_explicit,\r\ncop->cipher_start,\r\ncop->cipher_len,\r\ncop->cipher_outdata,\r\ncop->cipher_outlen);\r\nprintk("do_digest=%d\n"\r\n"digest_start=%d\n"\r\n"digest_len=%d\n",\r\ncop->do_digest,\r\ncop->digest_start,\r\ncop->digest_len);\r\nprintk("do_csum=%d\n"\r\n"csum_start=%d\n"\r\n"csum_len=%d\n",\r\ncop->do_csum,\r\ncop->csum_start,\r\ncop->csum_len);\r\n}\r\nstatic void print_cryptocop_operation(struct cryptocop_operation *cop)\r\n{\r\nstruct cryptocop_desc *d;\r\nstruct cryptocop_tfrm_cfg *tc;\r\nstruct cryptocop_desc_cfg *dc;\r\nint i;\r\nprintk("print_cryptocop_operation, cop=0x%p\n\n", cop);\r\nprintk("sid: %lld\n", cop->sid);\r\nprintk("operation_status=%d\n"\r\n"use_dmalists=%d\n"\r\n"in_interrupt=%d\n"\r\n"fast_callback=%d\n",\r\ncop->operation_status,\r\ncop->use_dmalists,\r\ncop->in_interrupt,\r\ncop->fast_callback);\r\nif (cop->use_dmalists){\r\nprint_user_dma_lists(&cop->list_op);\r\n} else {\r\nprintk("cop->tfrm_op\n"\r\n"tfrm_cfg=0x%p\n"\r\n"desc=0x%p\n"\r\n"indata=0x%p\n"\r\n"incount=%d\n"\r\n"inlen=%d\n"\r\n"outdata=0x%p\n"\r\n"outcount=%d\n"\r\n"outlen=%d\n\n",\r\ncop->tfrm_op.tfrm_cfg,\r\ncop->tfrm_op.desc,\r\ncop->tfrm_op.indata,\r\ncop->tfrm_op.incount,\r\ncop->tfrm_op.inlen,\r\ncop->tfrm_op.outdata,\r\ncop->tfrm_op.outcount,\r\ncop->tfrm_op.outlen);\r\ntc = cop->tfrm_op.tfrm_cfg;\r\nwhile (tc){\r\nprintk("tfrm_cfg, 0x%p\n"\r\n"tid=%d\n"\r\n"flags=%d\n"\r\n"inject_ix=%d\n"\r\n"next=0x%p\n",\r\ntc,\r\ntc->tid,\r\ntc->flags,\r\ntc->inject_ix,\r\ntc->next);\r\ntc = tc->next;\r\n}\r\nd = cop->tfrm_op.desc;\r\nwhile (d){\r\nprintk("\n======================desc, 0x%p\n"\r\n"length=%d\n"\r\n"cfg=0x%p\n"\r\n"next=0x%p\n",\r\nd,\r\nd->length,\r\nd->cfg,\r\nd->next);\r\ndc = d->cfg;\r\nwhile (dc){\r\nprintk("=========desc_cfg, 0x%p\n"\r\n"tid=%d\n"\r\n"src=%d\n"\r\n"last=%d\n"\r\n"next=0x%p\n",\r\ndc,\r\ndc->tid,\r\ndc->src,\r\ndc->last,\r\ndc->next);\r\ndc = dc->next;\r\n}\r\nd = d->next;\r\n}\r\nprintk("\n====iniov\n");\r\nfor (i = 0; i < cop->tfrm_op.incount; i++){\r\nprintk("indata[%d]\n"\r\n"base=0x%p\n"\r\n"len=%d\n",\r\ni,\r\ncop->tfrm_op.indata[i].iov_base,\r\ncop->tfrm_op.indata[i].iov_len);\r\n}\r\nprintk("\n====outiov\n");\r\nfor (i = 0; i < cop->tfrm_op.outcount; i++){\r\nprintk("outdata[%d]\n"\r\n"base=0x%p\n"\r\n"len=%d\n",\r\ni,\r\ncop->tfrm_op.outdata[i].iov_base,\r\ncop->tfrm_op.outdata[i].iov_len);\r\n}\r\n}\r\nprintk("------------end print_cryptocop_operation\n");\r\n}\r\nstatic void print_user_dma_lists(struct cryptocop_dma_list_operation *dma_op)\r\n{\r\ndma_descr_data *dd;\r\nint i;\r\nprintk("print_user_dma_lists, dma_op=0x%p\n", dma_op);\r\nprintk("out_data_buf = 0x%p, phys_to_virt(out_data_buf) = 0x%p\n", dma_op->out_data_buf, phys_to_virt((unsigned long int)dma_op->out_data_buf));\r\nprintk("in_data_buf = 0x%p, phys_to_virt(in_data_buf) = 0x%p\n", dma_op->in_data_buf, phys_to_virt((unsigned long int)dma_op->in_data_buf));\r\nprintk("##############outlist\n");\r\ndd = phys_to_virt((unsigned long int)dma_op->outlist);\r\ni = 0;\r\nwhile (dd != NULL) {\r\nprintk("#%d phys_to_virt(desc) 0x%p\n", i, dd);\r\nprintk("\n\tbuf: 0x%p\n"\r\n"\tafter: 0x%p\n"\r\n"\tmd: 0x%04x\n"\r\n"\tnext: 0x%p\n",\r\ndd->buf,\r\ndd->after,\r\ndd->md,\r\ndd->next);\r\nprintk("flags:\n"\r\n"\twait:\t%d\n"\r\n"\teol:\t%d\n"\r\n"\touteop:\t%d\n"\r\n"\tineop:\t%d\n"\r\n"\tintr:\t%d\n",\r\ndd->wait,\r\ndd->eol,\r\ndd->out_eop,\r\ndd->in_eop,\r\ndd->intr);\r\nif (dd->eol)\r\ndd = NULL;\r\nelse\r\ndd = phys_to_virt((unsigned long int)dd->next);\r\n++i;\r\n}\r\nprintk("##############inlist\n");\r\ndd = phys_to_virt((unsigned long int)dma_op->inlist);\r\ni = 0;\r\nwhile (dd != NULL) {\r\nprintk("#%d phys_to_virt(desc) 0x%p\n", i, dd);\r\nprintk("\n\tbuf: 0x%p\n"\r\n"\tafter: 0x%p\n"\r\n"\tmd: 0x%04x\n"\r\n"\tnext: 0x%p\n",\r\ndd->buf,\r\ndd->after,\r\ndd->md,\r\ndd->next);\r\nprintk("flags:\n"\r\n"\twait:\t%d\n"\r\n"\teol:\t%d\n"\r\n"\touteop:\t%d\n"\r\n"\tineop:\t%d\n"\r\n"\tintr:\t%d\n",\r\ndd->wait,\r\ndd->eol,\r\ndd->out_eop,\r\ndd->in_eop,\r\ndd->intr);\r\nif (dd->eol)\r\ndd = NULL;\r\nelse\r\ndd = phys_to_virt((unsigned long int)dd->next);\r\n++i;\r\n}\r\n}\r\nstatic void print_lock_status(void)\r\n{\r\nprintk("**********************print_lock_status\n");\r\nprintk("cryptocop_completed_jobs_lock %d\n", spin_is_locked(&cryptocop_completed_jobs_lock));\r\nprintk("cryptocop_job_queue_lock %d\n", spin_is_locked(&cryptocop_job_queue_lock));\r\nprintk("descr_pool_lock %d\n", spin_is_locked(&descr_pool_lock));\r\nprintk("cryptocop_sessions_lock %d\n", spin_is_locked(cryptocop_sessions_lock));\r\nprintk("running_job_lock %d\n", spin_is_locked(running_job_lock));\r\nprintk("cryptocop_process_lock %d\n", spin_is_locked(cryptocop_process_lock));\r\n}\r\nstatic int init_stream_coprocessor(void)\r\n{\r\nint err;\r\nint i;\r\nstatic int initialized = 0;\r\nif (initialized)\r\nreturn 0;\r\ninitialized = 1;\r\nprintk("ETRAX FS stream co-processor driver v0.01, (c) 2003 Axis Communications AB\n");\r\nerr = register_chrdev(CRYPTOCOP_MAJOR, cryptocop_name, &cryptocop_fops);\r\nif (err < 0) {\r\nprintk(KERN_ERR "stream co-processor: could not get major number.\n");\r\nreturn err;\r\n}\r\nerr = init_cryptocop();\r\nif (err) {\r\n(void)unregister_chrdev(CRYPTOCOP_MAJOR, cryptocop_name);\r\nreturn err;\r\n}\r\nerr = cryptocop_job_queue_init();\r\nif (err) {\r\nrelease_cryptocop();\r\n(void)unregister_chrdev(CRYPTOCOP_MAJOR, cryptocop_name);\r\nreturn err;\r\n}\r\nfor (i = 0; i < CRYPTOCOP_DESCRIPTOR_POOL_SIZE - 1; i++) {\r\ndescr_pool[i].from_pool = 1;\r\ndescr_pool[i].next = &descr_pool[i + 1];\r\n}\r\ndescr_pool[i].from_pool = 1;\r\ndescr_pool[i].next = NULL;\r\ndescr_pool_free_list = &descr_pool[0];\r\ndescr_pool_no_free = CRYPTOCOP_DESCRIPTOR_POOL_SIZE;\r\nspin_lock_init(&cryptocop_completed_jobs_lock);\r\nspin_lock_init(&cryptocop_job_queue_lock);\r\nspin_lock_init(&descr_pool_lock);\r\nspin_lock_init(&cryptocop_sessions_lock);\r\nspin_lock_init(&running_job_lock);\r\nspin_lock_init(&cryptocop_process_lock);\r\ncryptocop_sessions = NULL;\r\nnext_sid = 1;\r\ncryptocop_running_job = NULL;\r\nprintk("stream co-processor: init done.\n");\r\nreturn 0;\r\n}\r\nstatic void __exit exit_stream_coprocessor(void)\r\n{\r\nrelease_cryptocop();\r\ncryptocop_job_queue_close();\r\n}
