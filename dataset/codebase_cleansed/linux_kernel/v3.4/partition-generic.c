char *disk_name(struct gendisk *hd, int partno, char *buf)\r\n{\r\nif (!partno)\r\nsnprintf(buf, BDEVNAME_SIZE, "%s", hd->disk_name);\r\nelse if (isdigit(hd->disk_name[strlen(hd->disk_name)-1]))\r\nsnprintf(buf, BDEVNAME_SIZE, "%sp%d", hd->disk_name, partno);\r\nelse\r\nsnprintf(buf, BDEVNAME_SIZE, "%s%d", hd->disk_name, partno);\r\nreturn buf;\r\n}\r\nconst char *bdevname(struct block_device *bdev, char *buf)\r\n{\r\nreturn disk_name(bdev->bd_disk, bdev->bd_part->partno, buf);\r\n}\r\nconst char *__bdevname(dev_t dev, char *buffer)\r\n{\r\nscnprintf(buffer, BDEVNAME_SIZE, "unknown-block(%u,%u)",\r\nMAJOR(dev), MINOR(dev));\r\nreturn buffer;\r\n}\r\nstatic ssize_t part_partition_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct hd_struct *p = dev_to_part(dev);\r\nreturn sprintf(buf, "%d\n", p->partno);\r\n}\r\nstatic ssize_t part_start_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct hd_struct *p = dev_to_part(dev);\r\nreturn sprintf(buf, "%llu\n",(unsigned long long)p->start_sect);\r\n}\r\nssize_t part_size_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct hd_struct *p = dev_to_part(dev);\r\nreturn sprintf(buf, "%llu\n",(unsigned long long)p->nr_sects);\r\n}\r\nstatic ssize_t part_ro_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct hd_struct *p = dev_to_part(dev);\r\nreturn sprintf(buf, "%d\n", p->policy ? 1 : 0);\r\n}\r\nstatic ssize_t part_alignment_offset_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct hd_struct *p = dev_to_part(dev);\r\nreturn sprintf(buf, "%llu\n", (unsigned long long)p->alignment_offset);\r\n}\r\nstatic ssize_t part_discard_alignment_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct hd_struct *p = dev_to_part(dev);\r\nreturn sprintf(buf, "%u\n", p->discard_alignment);\r\n}\r\nssize_t part_stat_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct hd_struct *p = dev_to_part(dev);\r\nint cpu;\r\ncpu = part_stat_lock();\r\npart_round_stats(cpu, p);\r\npart_stat_unlock();\r\nreturn sprintf(buf,\r\n"%8lu %8lu %8llu %8u "\r\n"%8lu %8lu %8llu %8u "\r\n"%8u %8u %8u"\r\n"\n",\r\npart_stat_read(p, ios[READ]),\r\npart_stat_read(p, merges[READ]),\r\n(unsigned long long)part_stat_read(p, sectors[READ]),\r\njiffies_to_msecs(part_stat_read(p, ticks[READ])),\r\npart_stat_read(p, ios[WRITE]),\r\npart_stat_read(p, merges[WRITE]),\r\n(unsigned long long)part_stat_read(p, sectors[WRITE]),\r\njiffies_to_msecs(part_stat_read(p, ticks[WRITE])),\r\npart_in_flight(p),\r\njiffies_to_msecs(part_stat_read(p, io_ticks)),\r\njiffies_to_msecs(part_stat_read(p, time_in_queue)));\r\n}\r\nssize_t part_inflight_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct hd_struct *p = dev_to_part(dev);\r\nreturn sprintf(buf, "%8u %8u\n", atomic_read(&p->in_flight[0]),\r\natomic_read(&p->in_flight[1]));\r\n}\r\nssize_t part_fail_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct hd_struct *p = dev_to_part(dev);\r\nreturn sprintf(buf, "%d\n", p->make_it_fail);\r\n}\r\nssize_t part_fail_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct hd_struct *p = dev_to_part(dev);\r\nint i;\r\nif (count > 0 && sscanf(buf, "%d", &i) > 0)\r\np->make_it_fail = (i == 0) ? 0 : 1;\r\nreturn count;\r\n}\r\nstatic void part_release(struct device *dev)\r\n{\r\nstruct hd_struct *p = dev_to_part(dev);\r\nfree_part_stats(p);\r\nfree_part_info(p);\r\nkfree(p);\r\n}\r\nstatic void delete_partition_rcu_cb(struct rcu_head *head)\r\n{\r\nstruct hd_struct *part = container_of(head, struct hd_struct, rcu_head);\r\npart->start_sect = 0;\r\npart->nr_sects = 0;\r\npart_stat_set_all(part, 0);\r\nput_device(part_to_dev(part));\r\n}\r\nvoid __delete_partition(struct hd_struct *part)\r\n{\r\ncall_rcu(&part->rcu_head, delete_partition_rcu_cb);\r\n}\r\nvoid delete_partition(struct gendisk *disk, int partno)\r\n{\r\nstruct disk_part_tbl *ptbl = disk->part_tbl;\r\nstruct hd_struct *part;\r\nif (partno >= ptbl->len)\r\nreturn;\r\npart = ptbl->part[partno];\r\nif (!part)\r\nreturn;\r\nblk_free_devt(part_devt(part));\r\nrcu_assign_pointer(ptbl->part[partno], NULL);\r\nrcu_assign_pointer(ptbl->last_lookup, NULL);\r\nkobject_put(part->holder_dir);\r\ndevice_del(part_to_dev(part));\r\nhd_struct_put(part);\r\n}\r\nstatic ssize_t whole_disk_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn 0;\r\n}\r\nstruct hd_struct *add_partition(struct gendisk *disk, int partno,\r\nsector_t start, sector_t len, int flags,\r\nstruct partition_meta_info *info)\r\n{\r\nstruct hd_struct *p;\r\ndev_t devt = MKDEV(0, 0);\r\nstruct device *ddev = disk_to_dev(disk);\r\nstruct device *pdev;\r\nstruct disk_part_tbl *ptbl;\r\nconst char *dname;\r\nint err;\r\nerr = disk_expand_part_tbl(disk, partno);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nptbl = disk->part_tbl;\r\nif (ptbl->part[partno])\r\nreturn ERR_PTR(-EBUSY);\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (!p)\r\nreturn ERR_PTR(-EBUSY);\r\nif (!init_part_stats(p)) {\r\nerr = -ENOMEM;\r\ngoto out_free;\r\n}\r\npdev = part_to_dev(p);\r\np->start_sect = start;\r\np->alignment_offset =\r\nqueue_limit_alignment_offset(&disk->queue->limits, start);\r\np->discard_alignment =\r\nqueue_limit_discard_alignment(&disk->queue->limits, start);\r\np->nr_sects = len;\r\np->partno = partno;\r\np->policy = get_disk_ro(disk);\r\nif (info) {\r\nstruct partition_meta_info *pinfo = alloc_part_info(disk);\r\nif (!pinfo)\r\ngoto out_free_stats;\r\nmemcpy(pinfo, info, sizeof(*info));\r\np->info = pinfo;\r\n}\r\ndname = dev_name(ddev);\r\nif (isdigit(dname[strlen(dname) - 1]))\r\ndev_set_name(pdev, "%sp%d", dname, partno);\r\nelse\r\ndev_set_name(pdev, "%s%d", dname, partno);\r\ndevice_initialize(pdev);\r\npdev->class = &block_class;\r\npdev->type = &part_type;\r\npdev->parent = ddev;\r\nerr = blk_alloc_devt(p, &devt);\r\nif (err)\r\ngoto out_free_info;\r\npdev->devt = devt;\r\ndev_set_uevent_suppress(pdev, 1);\r\nerr = device_add(pdev);\r\nif (err)\r\ngoto out_put;\r\nerr = -ENOMEM;\r\np->holder_dir = kobject_create_and_add("holders", &pdev->kobj);\r\nif (!p->holder_dir)\r\ngoto out_del;\r\ndev_set_uevent_suppress(pdev, 0);\r\nif (flags & ADDPART_FLAG_WHOLEDISK) {\r\nerr = device_create_file(pdev, &dev_attr_whole_disk);\r\nif (err)\r\ngoto out_del;\r\n}\r\nrcu_assign_pointer(ptbl->part[partno], p);\r\nif (!dev_get_uevent_suppress(ddev))\r\nkobject_uevent(&pdev->kobj, KOBJ_ADD);\r\nhd_ref_init(p);\r\nreturn p;\r\nout_free_info:\r\nfree_part_info(p);\r\nout_free_stats:\r\nfree_part_stats(p);\r\nout_free:\r\nkfree(p);\r\nreturn ERR_PTR(err);\r\nout_del:\r\nkobject_put(p->holder_dir);\r\ndevice_del(pdev);\r\nout_put:\r\nput_device(pdev);\r\nblk_free_devt(devt);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic bool disk_unlock_native_capacity(struct gendisk *disk)\r\n{\r\nconst struct block_device_operations *bdops = disk->fops;\r\nif (bdops->unlock_native_capacity &&\r\n!(disk->flags & GENHD_FL_NATIVE_CAPACITY)) {\r\nprintk(KERN_CONT "enabling native capacity\n");\r\nbdops->unlock_native_capacity(disk);\r\ndisk->flags |= GENHD_FL_NATIVE_CAPACITY;\r\nreturn true;\r\n} else {\r\nprintk(KERN_CONT "truncated\n");\r\nreturn false;\r\n}\r\n}\r\nstatic int drop_partitions(struct gendisk *disk, struct block_device *bdev)\r\n{\r\nstruct disk_part_iter piter;\r\nstruct hd_struct *part;\r\nint res;\r\nif (bdev->bd_part_count)\r\nreturn -EBUSY;\r\nres = invalidate_partition(disk, 0);\r\nif (res)\r\nreturn res;\r\ndisk_part_iter_init(&piter, disk, DISK_PITER_INCL_EMPTY);\r\nwhile ((part = disk_part_iter_next(&piter)))\r\ndelete_partition(disk, part->partno);\r\ndisk_part_iter_exit(&piter);\r\nreturn 0;\r\n}\r\nint rescan_partitions(struct gendisk *disk, struct block_device *bdev)\r\n{\r\nstruct parsed_partitions *state = NULL;\r\nstruct hd_struct *part;\r\nint p, highest, res;\r\nrescan:\r\nif (state && !IS_ERR(state)) {\r\nkfree(state);\r\nstate = NULL;\r\n}\r\nres = drop_partitions(disk, bdev);\r\nif (res)\r\nreturn res;\r\nif (disk->fops->revalidate_disk)\r\ndisk->fops->revalidate_disk(disk);\r\ncheck_disk_size_change(disk, bdev);\r\nbdev->bd_invalidated = 0;\r\nif (!get_capacity(disk) || !(state = check_partition(disk, bdev)))\r\nreturn 0;\r\nif (IS_ERR(state)) {\r\nif (PTR_ERR(state) == -ENOSPC) {\r\nprintk(KERN_WARNING "%s: partition table beyond EOD, ",\r\ndisk->disk_name);\r\nif (disk_unlock_native_capacity(disk))\r\ngoto rescan;\r\n}\r\nreturn -EIO;\r\n}\r\nif (state->access_beyond_eod) {\r\nprintk(KERN_WARNING\r\n"%s: partition table partially beyond EOD, ",\r\ndisk->disk_name);\r\nif (disk_unlock_native_capacity(disk))\r\ngoto rescan;\r\n}\r\nkobject_uevent(&disk_to_dev(disk)->kobj, KOBJ_CHANGE);\r\nfor (p = 1, highest = 0; p < state->limit; p++)\r\nif (state->parts[p].size)\r\nhighest = p;\r\ndisk_expand_part_tbl(disk, highest);\r\nfor (p = 1; p < state->limit; p++) {\r\nsector_t size, from;\r\nstruct partition_meta_info *info = NULL;\r\nsize = state->parts[p].size;\r\nif (!size)\r\ncontinue;\r\nfrom = state->parts[p].from;\r\nif (from >= get_capacity(disk)) {\r\nprintk(KERN_WARNING\r\n"%s: p%d start %llu is beyond EOD, ",\r\ndisk->disk_name, p, (unsigned long long) from);\r\nif (disk_unlock_native_capacity(disk))\r\ngoto rescan;\r\ncontinue;\r\n}\r\nif (from + size > get_capacity(disk)) {\r\nprintk(KERN_WARNING\r\n"%s: p%d size %llu extends beyond EOD, ",\r\ndisk->disk_name, p, (unsigned long long) size);\r\nif (disk_unlock_native_capacity(disk)) {\r\ngoto rescan;\r\n} else {\r\nsize = get_capacity(disk) - from;\r\n}\r\n}\r\nif (state->parts[p].has_info)\r\ninfo = &state->parts[p].info;\r\npart = add_partition(disk, p, from, size,\r\nstate->parts[p].flags,\r\n&state->parts[p].info);\r\nif (IS_ERR(part)) {\r\nprintk(KERN_ERR " %s: p%d could not be added: %ld\n",\r\ndisk->disk_name, p, -PTR_ERR(part));\r\ncontinue;\r\n}\r\n#ifdef CONFIG_BLK_DEV_MD\r\nif (state->parts[p].flags & ADDPART_FLAG_RAID)\r\nmd_autodetect_dev(part_to_dev(part)->devt);\r\n#endif\r\n}\r\nkfree(state);\r\nreturn 0;\r\n}\r\nint invalidate_partitions(struct gendisk *disk, struct block_device *bdev)\r\n{\r\nint res;\r\nif (!bdev->bd_invalidated)\r\nreturn 0;\r\nres = drop_partitions(disk, bdev);\r\nif (res)\r\nreturn res;\r\nset_capacity(disk, 0);\r\ncheck_disk_size_change(disk, bdev);\r\nbdev->bd_invalidated = 0;\r\nkobject_uevent(&disk_to_dev(disk)->kobj, KOBJ_CHANGE);\r\nreturn 0;\r\n}\r\nunsigned char *read_dev_sector(struct block_device *bdev, sector_t n, Sector *p)\r\n{\r\nstruct address_space *mapping = bdev->bd_inode->i_mapping;\r\nstruct page *page;\r\npage = read_mapping_page(mapping, (pgoff_t)(n >> (PAGE_CACHE_SHIFT-9)),\r\nNULL);\r\nif (!IS_ERR(page)) {\r\nif (PageError(page))\r\ngoto fail;\r\np->v = page;\r\nreturn (unsigned char *)page_address(page) + ((n & ((1 << (PAGE_CACHE_SHIFT - 9)) - 1)) << 9);\r\nfail:\r\npage_cache_release(page);\r\n}\r\np->v = NULL;\r\nreturn NULL;\r\n}
