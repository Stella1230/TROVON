static void reg_r(struct gspca_dev *gspca_dev,\r\n__u16 value)\r\n{\r\nusb_control_msg(gspca_dev->dev,\r\nusb_rcvctrlpipe(gspca_dev->dev, 0),\r\n0,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\nvalue,\r\n0,\r\ngspca_dev->usb_buf, 1,\r\n500);\r\n}\r\nstatic void reg_w(struct gspca_dev *gspca_dev,\r\n__u16 value,\r\nconst __u8 *buffer,\r\nint len)\r\n{\r\n#ifdef GSPCA_DEBUG\r\nif (len > USB_BUF_SZ) {\r\nPDEBUG(D_ERR|D_PACK, "reg_w: buffer overflow");\r\nreturn;\r\n}\r\n#endif\r\nmemcpy(gspca_dev->usb_buf, buffer, len);\r\nusb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0x08,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\nvalue,\r\n0,\r\ngspca_dev->usb_buf, len,\r\n500);\r\n}\r\nstatic int i2c_w(struct gspca_dev *gspca_dev, const __u8 *buffer)\r\n{\r\nint retry = 60;\r\nreg_w(gspca_dev, 0x08, buffer, 8);\r\nwhile (retry--) {\r\nmsleep(10);\r\nreg_r(gspca_dev, 0x08);\r\nif (gspca_dev->usb_buf[0] & 0x04) {\r\nif (gspca_dev->usb_buf[0] & 0x08)\r\nreturn -1;\r\nreturn 0;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic void i2c_w_vector(struct gspca_dev *gspca_dev,\r\nconst __u8 buffer[][8], int len)\r\n{\r\nfor (;;) {\r\nreg_w(gspca_dev, 0x08, *buffer, 8);\r\nlen -= 8;\r\nif (len <= 0)\r\nbreak;\r\nbuffer++;\r\n}\r\n}\r\nstatic void setbrightness(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nswitch (sd->sensor) {\r\ncase SENSOR_OV6650:\r\ncase SENSOR_OV7630: {\r\n__u8 i2cOV[] =\r\n{0xa0, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x10};\r\ni2cOV[1] = sensor_data[sd->sensor].sensor_addr;\r\ni2cOV[3] = sd->ctrls[BRIGHTNESS].val;\r\nif (i2c_w(gspca_dev, i2cOV) < 0)\r\ngoto err;\r\nbreak;\r\n}\r\ncase SENSOR_PAS106:\r\ncase SENSOR_PAS202: {\r\n__u8 i2cpbright[] =\r\n{0xb0, 0x40, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x16};\r\n__u8 i2cpdoit[] =\r\n{0xa0, 0x40, 0x11, 0x01, 0x00, 0x00, 0x00, 0x16};\r\nif (sd->sensor == SENSOR_PAS106) {\r\ni2cpbright[2] = 7;\r\ni2cpdoit[2] = 0x13;\r\n}\r\nif (sd->ctrls[BRIGHTNESS].val < 127) {\r\ni2cpbright[3] = 0x01;\r\ni2cpbright[4] = 127 - sd->ctrls[BRIGHTNESS].val;\r\n} else\r\ni2cpbright[4] = sd->ctrls[BRIGHTNESS].val - 127;\r\nif (i2c_w(gspca_dev, i2cpbright) < 0)\r\ngoto err;\r\nif (i2c_w(gspca_dev, i2cpdoit) < 0)\r\ngoto err;\r\nbreak;\r\n}\r\n}\r\nreturn;\r\nerr:\r\nPDEBUG(D_ERR, "i2c error brightness");\r\n}\r\nstatic void setsensorgain(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 gain = sd->ctrls[GAIN].val;\r\nswitch (sd->sensor) {\r\ncase SENSOR_HV7131D: {\r\n__u8 i2c[] =\r\n{0xc0, 0x11, 0x31, 0x00, 0x00, 0x00, 0x00, 0x17};\r\ni2c[3] = 0x3f - (gain / 4);\r\ni2c[4] = 0x3f - (gain / 4);\r\ni2c[5] = 0x3f - (gain / 4);\r\nif (i2c_w(gspca_dev, i2c) < 0)\r\ngoto err;\r\nbreak;\r\n}\r\ncase SENSOR_TAS5110C:\r\ncase SENSOR_TAS5130CXX: {\r\n__u8 i2c[] =\r\n{0x30, 0x11, 0x02, 0x20, 0x70, 0x00, 0x00, 0x10};\r\ni2c[4] = 255 - gain;\r\nif (i2c_w(gspca_dev, i2c) < 0)\r\ngoto err;\r\nbreak;\r\n}\r\ncase SENSOR_TAS5110D: {\r\n__u8 i2c[] = {\r\n0xb0, 0x61, 0x02, 0x00, 0x10, 0x00, 0x00, 0x17 };\r\ngain = 255 - gain;\r\ni2c[3] |= (gain & 0x80) >> 7;\r\ni2c[3] |= (gain & 0x40) >> 5;\r\ni2c[3] |= (gain & 0x20) >> 3;\r\ni2c[3] |= (gain & 0x10) >> 1;\r\ni2c[3] |= (gain & 0x08) << 1;\r\ni2c[3] |= (gain & 0x04) << 3;\r\ni2c[3] |= (gain & 0x02) << 5;\r\ni2c[3] |= (gain & 0x01) << 7;\r\nif (i2c_w(gspca_dev, i2c) < 0)\r\ngoto err;\r\nbreak;\r\n}\r\ncase SENSOR_OV6650:\r\ngain >>= 1;\r\ncase SENSOR_OV7630: {\r\n__u8 i2c[] = {0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};\r\ni2c[1] = sensor_data[sd->sensor].sensor_addr;\r\ni2c[3] = gain >> 2;\r\nif (i2c_w(gspca_dev, i2c) < 0)\r\ngoto err;\r\nbreak;\r\n}\r\ncase SENSOR_PAS106:\r\ncase SENSOR_PAS202: {\r\n__u8 i2cpgain[] =\r\n{0xa0, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x15};\r\n__u8 i2cpcolorgain[] =\r\n{0xc0, 0x40, 0x07, 0x00, 0x00, 0x00, 0x00, 0x15};\r\n__u8 i2cpdoit[] =\r\n{0xa0, 0x40, 0x11, 0x01, 0x00, 0x00, 0x00, 0x16};\r\nif (sd->sensor == SENSOR_PAS106) {\r\ni2cpgain[2] = 0x0e;\r\ni2cpcolorgain[0] = 0xd0;\r\ni2cpcolorgain[2] = 0x09;\r\ni2cpdoit[2] = 0x13;\r\n}\r\ni2cpgain[3] = gain >> 3;\r\ni2cpcolorgain[3] = gain >> 4;\r\ni2cpcolorgain[4] = gain >> 4;\r\ni2cpcolorgain[5] = gain >> 4;\r\ni2cpcolorgain[6] = gain >> 4;\r\nif (i2c_w(gspca_dev, i2cpgain) < 0)\r\ngoto err;\r\nif (i2c_w(gspca_dev, i2cpcolorgain) < 0)\r\ngoto err;\r\nif (i2c_w(gspca_dev, i2cpdoit) < 0)\r\ngoto err;\r\nbreak;\r\n}\r\n}\r\nreturn;\r\nerr:\r\nPDEBUG(D_ERR, "i2c error gain");\r\n}\r\nstatic void setgain(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n__u8 gain;\r\n__u8 buf[3] = { 0, 0, 0 };\r\nif (sensor_data[sd->sensor].flags & F_GAIN) {\r\nsetsensorgain(gspca_dev);\r\nreturn;\r\n}\r\nif (sd->bridge == BRIDGE_103) {\r\ngain = sd->ctrls[GAIN].val >> 1;\r\nbuf[0] = gain;\r\nbuf[1] = gain;\r\nbuf[2] = gain;\r\nreg_w(gspca_dev, 0x05, buf, 3);\r\n} else {\r\ngain = sd->ctrls[GAIN].val >> 4;\r\nbuf[0] = gain << 4 | gain;\r\nbuf[1] = gain;\r\nreg_w(gspca_dev, 0x10, buf, 2);\r\n}\r\n}\r\nstatic void setexposure(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nswitch (sd->sensor) {\r\ncase SENSOR_HV7131D: {\r\n__u8 i2c[] = {0xc0, 0x11, 0x25, 0x00, 0x00, 0x00, 0x00, 0x17};\r\nu16 reg = sd->ctrls[EXPOSURE].val * 6;\r\ni2c[3] = reg >> 8;\r\ni2c[4] = reg & 0xff;\r\nif (i2c_w(gspca_dev, i2c) != 0)\r\ngoto err;\r\nbreak;\r\n}\r\ncase SENSOR_TAS5110C:\r\ncase SENSOR_TAS5110D: {\r\nu8 reg = sd->ctrls[EXPOSURE].val;\r\nreg = (reg << 4) | 0x0b;\r\nreg_w(gspca_dev, 0x19, &reg, 1);\r\nbreak;\r\n}\r\ncase SENSOR_OV6650:\r\ncase SENSOR_OV7630: {\r\n__u8 i2c[] = {0xb0, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x10};\r\nint reg10, reg11, reg10_max;\r\nif (sd->sensor == SENSOR_OV6650) {\r\nreg10_max = 0x4d;\r\ni2c[4] = 0xc0;\r\n} else\r\nreg10_max = 0x41;\r\nreg11 = (15 * sd->ctrls[EXPOSURE].val + 999) / 1000;\r\nif (reg11 < 1)\r\nreg11 = 1;\r\nelse if (reg11 > 16)\r\nreg11 = 16;\r\nif (gspca_dev->width == 640 && reg11 < 4)\r\nreg11 = 4;\r\nreg10 = (sd->ctrls[EXPOSURE].val * 15 * reg10_max)\r\n/ (1000 * reg11);\r\nif (sd->ctrls[AUTOGAIN].val && reg10 < 10)\r\nreg10 = 10;\r\nelse if (reg10 > reg10_max)\r\nreg10 = reg10_max;\r\ni2c[1] = sensor_data[sd->sensor].sensor_addr;\r\ni2c[3] = reg10;\r\ni2c[4] |= reg11 - 1;\r\nif (sd->reg11 == reg11)\r\ni2c[0] = 0xa0;\r\nif (i2c_w(gspca_dev, i2c) == 0)\r\nsd->reg11 = reg11;\r\nelse\r\ngoto err;\r\nbreak;\r\n}\r\ncase SENSOR_PAS202: {\r\n__u8 i2cpframerate[] =\r\n{0xb0, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, 0x16};\r\n__u8 i2cpexpo[] =\r\n{0xa0, 0x40, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x16};\r\nconst __u8 i2cpdoit[] =\r\n{0xa0, 0x40, 0x11, 0x01, 0x00, 0x00, 0x00, 0x16};\r\nint framerate_ctrl;\r\nif (sd->ctrls[EXPOSURE].val < 200) {\r\ni2cpexpo[3] = 255 - (sd->ctrls[EXPOSURE].val * 255)\r\n/ 200;\r\nframerate_ctrl = 500;\r\n} else {\r\nframerate_ctrl = (sd->ctrls[EXPOSURE].val - 200)\r\n* 1000 / 229 + 500;\r\n}\r\ni2cpframerate[3] = framerate_ctrl >> 6;\r\ni2cpframerate[4] = framerate_ctrl & 0x3f;\r\nif (i2c_w(gspca_dev, i2cpframerate) < 0)\r\ngoto err;\r\nif (i2c_w(gspca_dev, i2cpexpo) < 0)\r\ngoto err;\r\nif (i2c_w(gspca_dev, i2cpdoit) < 0)\r\ngoto err;\r\nbreak;\r\n}\r\ncase SENSOR_PAS106: {\r\n__u8 i2cpframerate[] =\r\n{0xb1, 0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x14};\r\n__u8 i2cpexpo[] =\r\n{0xa1, 0x40, 0x05, 0x00, 0x00, 0x00, 0x00, 0x14};\r\nconst __u8 i2cpdoit[] =\r\n{0xa1, 0x40, 0x13, 0x01, 0x00, 0x00, 0x00, 0x14};\r\nint framerate_ctrl;\r\nif (sd->ctrls[EXPOSURE].val < 150) {\r\ni2cpexpo[3] = 150 - sd->ctrls[EXPOSURE].val;\r\nframerate_ctrl = 300;\r\n} else {\r\nframerate_ctrl = (sd->ctrls[EXPOSURE].val - 150)\r\n* 1000 / 230 + 300;\r\n}\r\ni2cpframerate[3] = framerate_ctrl >> 4;\r\ni2cpframerate[4] = framerate_ctrl & 0x0f;\r\nif (i2c_w(gspca_dev, i2cpframerate) < 0)\r\ngoto err;\r\nif (i2c_w(gspca_dev, i2cpexpo) < 0)\r\ngoto err;\r\nif (i2c_w(gspca_dev, i2cpdoit) < 0)\r\ngoto err;\r\nbreak;\r\n}\r\n}\r\nreturn;\r\nerr:\r\nPDEBUG(D_ERR, "i2c error exposure");\r\n}\r\nstatic void setfreq(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nswitch (sd->sensor) {\r\ncase SENSOR_OV6650:\r\ncase SENSOR_OV7630: {\r\n__u8 i2c[] = {0xa0, 0x00, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x10};\r\nswitch (sd->ctrls[FREQ].val) {\r\ndefault:\r\ni2c[3] = 0;\r\nbreak;\r\ncase 1:\r\ni2c[3] = (sd->sensor == SENSOR_OV6650)\r\n? 0x4f : 0x8a;\r\nbreak;\r\n}\r\ni2c[1] = sensor_data[sd->sensor].sensor_addr;\r\nif (i2c_w(gspca_dev, i2c) < 0)\r\nPDEBUG(D_ERR, "i2c error setfreq");\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void do_autogain(struct gspca_dev *gspca_dev)\r\n{\r\nint deadzone, desired_avg_lum, result;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint avg_lum = atomic_read(&sd->avg_lum);\r\nif ((gspca_dev->ctrl_dis & (1 << AUTOGAIN)) ||\r\navg_lum == -1 || !sd->ctrls[AUTOGAIN].val)\r\nreturn;\r\nif (sd->autogain_ignore_frames > 0) {\r\nsd->autogain_ignore_frames--;\r\nreturn;\r\n}\r\nif (sensor_data[sd->sensor].flags & F_SIF) {\r\ndeadzone = 500;\r\ndesired_avg_lum = 5000;\r\n} else {\r\ndeadzone = 1500;\r\ndesired_avg_lum = 13000;\r\n}\r\nif (sensor_data[sd->sensor].flags & F_COARSE_EXPO)\r\nresult = coarse_grained_expo_autogain(gspca_dev, avg_lum,\r\nsd->ctrls[BRIGHTNESS].val\r\n* desired_avg_lum / 127,\r\ndeadzone);\r\nelse\r\nresult = auto_gain_n_exposure(gspca_dev, avg_lum,\r\nsd->ctrls[BRIGHTNESS].val\r\n* desired_avg_lum / 127,\r\ndeadzone, GAIN_KNEE, EXPOSURE_KNEE);\r\nif (result) {\r\nPDEBUG(D_FRAM, "autogain: gain changed: gain: %d expo: %d",\r\n(int) sd->ctrls[GAIN].val,\r\n(int) sd->ctrls[EXPOSURE].val);\r\nsd->autogain_ignore_frames = AUTOGAIN_IGNORE_FRAMES;\r\n}\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam;\r\nreg_r(gspca_dev, 0x00);\r\nif (gspca_dev->usb_buf[0] != 0x10)\r\nreturn -ENODEV;\r\nsd->sensor = id->driver_info >> 8;\r\nsd->bridge = id->driver_info & 0xff;\r\ngspca_dev->ctrl_dis = sensor_data[sd->sensor].ctrl_dis;\r\n#if AUTOGAIN_DEF\r\nif (!(gspca_dev->ctrl_dis & (1 << AUTOGAIN)))\r\ngspca_dev->ctrl_inac = (1 << GAIN) | (1 << EXPOSURE);\r\n#endif\r\ncam = &gspca_dev->cam;\r\ncam->ctrls = sd->ctrls;\r\nif (!(sensor_data[sd->sensor].flags & F_SIF)) {\r\ncam->cam_mode = vga_mode;\r\ncam->nmodes = ARRAY_SIZE(vga_mode);\r\n} else {\r\ncam->cam_mode = sif_mode;\r\ncam->nmodes = ARRAY_SIZE(sif_mode);\r\n}\r\ncam->npkt = 36;\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nconst __u8 stop = 0x09;\r\nif (sensor_data[sd->sensor].flags & F_COARSE_EXPO) {\r\nsd->ctrls[EXPOSURE].min = COARSE_EXPOSURE_MIN;\r\nsd->ctrls[EXPOSURE].max = COARSE_EXPOSURE_MAX;\r\nsd->ctrls[EXPOSURE].def = COARSE_EXPOSURE_DEF;\r\nif (sd->ctrls[EXPOSURE].val > COARSE_EXPOSURE_MAX)\r\nsd->ctrls[EXPOSURE].val = COARSE_EXPOSURE_DEF;\r\n}\r\nreg_w(gspca_dev, 0x01, &stop, 1);\r\nreturn 0;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam = &gspca_dev->cam;\r\nint i, mode;\r\n__u8 regs[0x31];\r\nmode = cam->cam_mode[gspca_dev->curr_mode].priv & 0x07;\r\nmemcpy(&regs[0x01], sensor_data[sd->sensor].bridge_init, 0x19);\r\nregs[0x18] |= mode << 4;\r\nif (sd->bridge == BRIDGE_103) {\r\nregs[0x05] = 0x20;\r\nregs[0x06] = 0x20;\r\nregs[0x07] = 0x20;\r\n} else {\r\nregs[0x10] = 0x00;\r\nregs[0x11] = 0x00;\r\n}\r\nif (sensor_data[sd->sensor].flags & F_SIF) {\r\nregs[0x1a] = 0x14;\r\nregs[0x1b] = 0x0a;\r\nregs[0x1c] = 0x02;\r\nregs[0x1d] = 0x02;\r\nregs[0x1e] = 0x09;\r\nregs[0x1f] = 0x07;\r\n} else {\r\nregs[0x1a] = 0x1d;\r\nregs[0x1b] = 0x10;\r\nregs[0x1c] = 0x05;\r\nregs[0x1d] = 0x03;\r\nregs[0x1e] = 0x0f;\r\nregs[0x1f] = 0x0c;\r\n}\r\nfor (i = 0; i < 16; i++)\r\nregs[0x20 + i] = i * 16;\r\nregs[0x20 + i] = 255;\r\nswitch (sd->sensor) {\r\ncase SENSOR_TAS5130CXX:\r\nregs[0x19] = mode ? 0x23 : 0x43;\r\nbreak;\r\ncase SENSOR_OV7630:\r\nif (sd->bridge == BRIDGE_103) {\r\nregs[0x01] = 0x44;\r\nregs[0x12] = 0x02;\r\n}\r\n}\r\nif (cam->cam_mode[gspca_dev->curr_mode].priv & MODE_RAW)\r\nregs[0x18] &= ~0x80;\r\nif (cam->cam_mode[gspca_dev->curr_mode].priv & MODE_REDUCED_SIF) {\r\nregs[0x12] += 16;\r\nregs[0x13] += 24;\r\nregs[0x15] = 320 / 16;\r\nregs[0x16] = 240 / 16;\r\n}\r\nreg_w(gspca_dev, 0x01, &regs[0x01], 1);\r\nreg_w(gspca_dev, 0x17, &regs[0x17], 1);\r\nreg_w(gspca_dev, 0x01, &regs[0x01],\r\n(sd->bridge == BRIDGE_103) ? 0x30 : 0x1f);\r\ni2c_w_vector(gspca_dev, sensor_data[sd->sensor].sensor_init,\r\nsensor_data[sd->sensor].sensor_init_size);\r\nswitch (sd->sensor) {\r\ncase SENSOR_PAS202: {\r\nconst __u8 i2cpclockdiv[] =\r\n{0xa0, 0x40, 0x02, 0x03, 0x00, 0x00, 0x00, 0x10};\r\nif (mode)\r\ni2c_w(gspca_dev, i2cpclockdiv);\r\nbreak;\r\n}\r\ncase SENSOR_OV7630:\r\nif (sd->bridge == BRIDGE_103) {\r\nconst __u8 i2c[] = { 0xa0, 0x21, 0x13,\r\n0x80, 0x00, 0x00, 0x00, 0x10 };\r\ni2c_w(gspca_dev, i2c);\r\n}\r\nbreak;\r\n}\r\nreg_w(gspca_dev, 0x15, &regs[0x15], 2);\r\nreg_w(gspca_dev, 0x18, &regs[0x18], 1);\r\nreg_w(gspca_dev, 0x12, &regs[0x12], 1);\r\nreg_w(gspca_dev, 0x13, &regs[0x13], 1);\r\nreg_w(gspca_dev, 0x17, &regs[0x17], 1);\r\nreg_w(gspca_dev, 0x19, &regs[0x19], 1);\r\nreg_w(gspca_dev, 0x1c, &regs[0x1c], 4);\r\nreg_w(gspca_dev, 0x01, &regs[0x01], 1);\r\nreg_w(gspca_dev, 0x18, &regs[0x18], 2);\r\nmsleep(20);\r\nsd->reg11 = -1;\r\nsetgain(gspca_dev);\r\nsetbrightness(gspca_dev);\r\nsetexposure(gspca_dev);\r\nsetfreq(gspca_dev);\r\nsd->frames_to_drop = 0;\r\nsd->autogain_ignore_frames = 0;\r\nsd->exp_too_high_cnt = 0;\r\nsd->exp_too_low_cnt = 0;\r\natomic_set(&sd->avg_lum, -1);\r\nreturn 0;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nsd_init(gspca_dev);\r\n}\r\nstatic u8* find_sof(struct gspca_dev *gspca_dev, u8 *data, int len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint i, header_size = (sd->bridge == BRIDGE_103) ? 18 : 12;\r\nfor (i = 0; i < len; i++) {\r\nswitch (sd->header_read) {\r\ncase 0:\r\nif (data[i] == 0xff)\r\nsd->header_read++;\r\nbreak;\r\ncase 1:\r\nif (data[i] == 0xff)\r\nsd->header_read++;\r\nelse\r\nsd->header_read = 0;\r\nbreak;\r\ncase 2:\r\nif (data[i] == 0x00)\r\nsd->header_read++;\r\nelse if (data[i] != 0xff)\r\nsd->header_read = 0;\r\nbreak;\r\ncase 3:\r\nif (data[i] == 0xc4)\r\nsd->header_read++;\r\nelse if (data[i] == 0xff)\r\nsd->header_read = 1;\r\nelse\r\nsd->header_read = 0;\r\nbreak;\r\ncase 4:\r\nif (data[i] == 0xc4)\r\nsd->header_read++;\r\nelse if (data[i] == 0xff)\r\nsd->header_read = 1;\r\nelse\r\nsd->header_read = 0;\r\nbreak;\r\ncase 5:\r\nif (data[i] == 0x96)\r\nsd->header_read++;\r\nelse if (data[i] == 0xff)\r\nsd->header_read = 1;\r\nelse\r\nsd->header_read = 0;\r\nbreak;\r\ndefault:\r\nsd->header[sd->header_read - 6] = data[i];\r\nsd->header_read++;\r\nif (sd->header_read == header_size) {\r\nsd->header_read = 0;\r\nreturn data + i + 1;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nint fr_h_sz = 0, lum_offset = 0, len_after_sof = 0;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam = &gspca_dev->cam;\r\nu8 *sof;\r\nsof = find_sof(gspca_dev, data, len);\r\nif (sof) {\r\nif (sd->bridge == BRIDGE_103) {\r\nfr_h_sz = 18;\r\nlum_offset = 3;\r\n} else {\r\nfr_h_sz = 12;\r\nlum_offset = 2;\r\n}\r\nlen_after_sof = len - (sof - data);\r\nlen = (sof - data) - fr_h_sz;\r\nif (len < 0)\r\nlen = 0;\r\n}\r\nif (cam->cam_mode[gspca_dev->curr_mode].priv & MODE_RAW) {\r\nint used;\r\nint size = cam->cam_mode[gspca_dev->curr_mode].sizeimage;\r\nused = gspca_dev->image_len;\r\nif (used + len > size)\r\nlen = size - used;\r\n}\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\nif (sof) {\r\nint lum = sd->header[lum_offset] +\r\n(sd->header[lum_offset + 1] << 8);\r\nif (lum == 0 && sd->prev_avg_lum != 0) {\r\nlum = -1;\r\nsd->frames_to_drop = 2;\r\nsd->prev_avg_lum = 0;\r\n} else\r\nsd->prev_avg_lum = lum;\r\natomic_set(&sd->avg_lum, lum);\r\nif (sd->frames_to_drop)\r\nsd->frames_to_drop--;\r\nelse\r\ngspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\r\ngspca_frame_add(gspca_dev, FIRST_PACKET, sof, len_after_sof);\r\n}\r\n}\r\nstatic int sd_setautogain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->ctrls[AUTOGAIN].val = val;\r\nsd->exp_too_high_cnt = 0;\r\nsd->exp_too_low_cnt = 0;\r\nif (sd->ctrls[AUTOGAIN].val\r\n&& !(sensor_data[sd->sensor].flags & F_COARSE_EXPO)) {\r\nsd->ctrls[EXPOSURE].val = sd->ctrls[EXPOSURE].def;\r\nsd->ctrls[GAIN].val = sd->ctrls[GAIN].def;\r\nif (gspca_dev->streaming) {\r\nsd->autogain_ignore_frames = AUTOGAIN_IGNORE_FRAMES;\r\nsetexposure(gspca_dev);\r\nsetgain(gspca_dev);\r\n}\r\n}\r\nif (sd->ctrls[AUTOGAIN].val)\r\ngspca_dev->ctrl_inac = (1 << GAIN) | (1 << EXPOSURE);\r\nelse\r\ngspca_dev->ctrl_inac = 0;\r\nreturn 0;\r\n}\r\nstatic int sd_querymenu(struct gspca_dev *gspca_dev,\r\nstruct v4l2_querymenu *menu)\r\n{\r\nswitch (menu->id) {\r\ncase V4L2_CID_POWER_LINE_FREQUENCY:\r\nswitch (menu->index) {\r\ncase 0:\r\nstrcpy((char *) menu->name, "NoFliker");\r\nreturn 0;\r\ncase 1:\r\nstrcpy((char *) menu->name, "50 Hz");\r\nreturn 0;\r\ncase 2:\r\nstrcpy((char *) menu->name, "60 Hz");\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int sd_int_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nint ret = -EINVAL;\r\nif (len == 1 && data[0] == 1) {\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 1);\r\ninput_sync(gspca_dev->input_dev);\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\r\ninput_sync(gspca_dev->input_dev);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
