static int enable_locking(struct dlm_ls *ls, uint64_t seq)\r\n{\r\nint error = -EINTR;\r\ndown_write(&ls->ls_recv_active);\r\nspin_lock(&ls->ls_recover_lock);\r\nif (ls->ls_recover_seq == seq) {\r\nset_bit(LSFL_RUNNING, &ls->ls_flags);\r\nup_write(&ls->ls_in_recovery);\r\nerror = 0;\r\n}\r\nspin_unlock(&ls->ls_recover_lock);\r\nup_write(&ls->ls_recv_active);\r\nreturn error;\r\n}\r\nstatic int ls_recover(struct dlm_ls *ls, struct dlm_recover *rv)\r\n{\r\nunsigned long start;\r\nint error, neg = 0;\r\nlog_debug(ls, "dlm_recover %llx", (unsigned long long)rv->seq);\r\nmutex_lock(&ls->ls_recoverd_active);\r\ndlm_callback_suspend(ls);\r\ndlm_clear_toss_list(ls);\r\ndlm_create_root_list(ls);\r\nerror = dlm_recover_members(ls, rv, &neg);\r\nif (error) {\r\nlog_debug(ls, "dlm_recover_members error %d", error);\r\ngoto fail;\r\n}\r\ndlm_set_recover_status(ls, DLM_RS_NODES);\r\nerror = dlm_recover_members_wait(ls);\r\nif (error) {\r\nlog_debug(ls, "dlm_recover_members_wait error %d", error);\r\ngoto fail;\r\n}\r\nstart = jiffies;\r\nerror = dlm_recover_directory(ls);\r\nif (error) {\r\nlog_debug(ls, "dlm_recover_directory error %d", error);\r\ngoto fail;\r\n}\r\ndlm_set_recover_status(ls, DLM_RS_DIR);\r\nerror = dlm_recover_directory_wait(ls);\r\nif (error) {\r\nlog_debug(ls, "dlm_recover_directory_wait error %d", error);\r\ngoto fail;\r\n}\r\ndlm_recover_waiters_pre(ls);\r\nerror = dlm_recovery_stopped(ls);\r\nif (error)\r\ngoto fail;\r\nif (neg || dlm_no_directory(ls)) {\r\ndlm_purge_locks(ls);\r\nerror = dlm_recover_masters(ls);\r\nif (error) {\r\nlog_debug(ls, "dlm_recover_masters error %d", error);\r\ngoto fail;\r\n}\r\nerror = dlm_recover_locks(ls);\r\nif (error) {\r\nlog_debug(ls, "dlm_recover_locks error %d", error);\r\ngoto fail;\r\n}\r\ndlm_set_recover_status(ls, DLM_RS_LOCKS);\r\nerror = dlm_recover_locks_wait(ls);\r\nif (error) {\r\nlog_debug(ls, "dlm_recover_locks_wait error %d", error);\r\ngoto fail;\r\n}\r\ndlm_recover_rsbs(ls);\r\n} else {\r\ndlm_set_recover_status(ls, DLM_RS_LOCKS);\r\nerror = dlm_recover_locks_wait(ls);\r\nif (error) {\r\nlog_debug(ls, "dlm_recover_locks_wait error %d", error);\r\ngoto fail;\r\n}\r\n}\r\ndlm_release_root_list(ls);\r\ndlm_purge_requestqueue(ls);\r\ndlm_set_recover_status(ls, DLM_RS_DONE);\r\nerror = dlm_recover_done_wait(ls);\r\nif (error) {\r\nlog_debug(ls, "dlm_recover_done_wait error %d", error);\r\ngoto fail;\r\n}\r\ndlm_clear_members_gone(ls);\r\ndlm_adjust_timeouts(ls);\r\ndlm_callback_resume(ls);\r\nerror = enable_locking(ls, rv->seq);\r\nif (error) {\r\nlog_debug(ls, "enable_locking error %d", error);\r\ngoto fail;\r\n}\r\nerror = dlm_process_requestqueue(ls);\r\nif (error) {\r\nlog_debug(ls, "dlm_process_requestqueue error %d", error);\r\ngoto fail;\r\n}\r\nerror = dlm_recover_waiters_post(ls);\r\nif (error) {\r\nlog_debug(ls, "dlm_recover_waiters_post error %d", error);\r\ngoto fail;\r\n}\r\ndlm_grant_after_purge(ls);\r\nlog_debug(ls, "dlm_recover %llx generation %u done: %u ms",\r\n(unsigned long long)rv->seq, ls->ls_generation,\r\njiffies_to_msecs(jiffies - start));\r\nmutex_unlock(&ls->ls_recoverd_active);\r\ndlm_lsop_recover_done(ls);\r\nreturn 0;\r\nfail:\r\ndlm_release_root_list(ls);\r\nlog_debug(ls, "dlm_recover %llx error %d",\r\n(unsigned long long)rv->seq, error);\r\nmutex_unlock(&ls->ls_recoverd_active);\r\nreturn error;\r\n}\r\nstatic void do_ls_recovery(struct dlm_ls *ls)\r\n{\r\nstruct dlm_recover *rv = NULL;\r\nspin_lock(&ls->ls_recover_lock);\r\nrv = ls->ls_recover_args;\r\nls->ls_recover_args = NULL;\r\nif (rv && ls->ls_recover_seq == rv->seq)\r\nclear_bit(LSFL_RECOVERY_STOP, &ls->ls_flags);\r\nspin_unlock(&ls->ls_recover_lock);\r\nif (rv) {\r\nls_recover(ls, rv);\r\nkfree(rv->nodes);\r\nkfree(rv);\r\n}\r\n}\r\nstatic int dlm_recoverd(void *arg)\r\n{\r\nstruct dlm_ls *ls;\r\nls = dlm_find_lockspace_local(arg);\r\nif (!ls) {\r\nlog_print("dlm_recoverd: no lockspace %p", arg);\r\nreturn -1;\r\n}\r\nwhile (!kthread_should_stop()) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (!test_bit(LSFL_WORK, &ls->ls_flags))\r\nschedule();\r\nset_current_state(TASK_RUNNING);\r\nif (test_and_clear_bit(LSFL_WORK, &ls->ls_flags))\r\ndo_ls_recovery(ls);\r\n}\r\ndlm_put_lockspace(ls);\r\nreturn 0;\r\n}\r\nvoid dlm_recoverd_kick(struct dlm_ls *ls)\r\n{\r\nset_bit(LSFL_WORK, &ls->ls_flags);\r\nwake_up_process(ls->ls_recoverd_task);\r\n}\r\nint dlm_recoverd_start(struct dlm_ls *ls)\r\n{\r\nstruct task_struct *p;\r\nint error = 0;\r\np = kthread_run(dlm_recoverd, ls, "dlm_recoverd");\r\nif (IS_ERR(p))\r\nerror = PTR_ERR(p);\r\nelse\r\nls->ls_recoverd_task = p;\r\nreturn error;\r\n}\r\nvoid dlm_recoverd_stop(struct dlm_ls *ls)\r\n{\r\nkthread_stop(ls->ls_recoverd_task);\r\n}\r\nvoid dlm_recoverd_suspend(struct dlm_ls *ls)\r\n{\r\nwake_up(&ls->ls_wait_general);\r\nmutex_lock(&ls->ls_recoverd_active);\r\n}\r\nvoid dlm_recoverd_resume(struct dlm_ls *ls)\r\n{\r\nmutex_unlock(&ls->ls_recoverd_active);\r\n}
