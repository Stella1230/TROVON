static int ext4_release_file(struct inode *inode, struct file *filp)\r\n{\r\nif (ext4_test_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE)) {\r\next4_alloc_da_blocks(inode);\r\next4_clear_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE);\r\n}\r\nif ((filp->f_mode & FMODE_WRITE) &&\r\n(atomic_read(&inode->i_writecount) == 1) &&\r\n!EXT4_I(inode)->i_reserved_data_blocks)\r\n{\r\ndown_write(&EXT4_I(inode)->i_data_sem);\r\next4_discard_preallocations(inode);\r\nup_write(&EXT4_I(inode)->i_data_sem);\r\n}\r\nif (is_dx(inode) && filp->private_data)\r\next4_htree_free_dir_info(filp->private_data);\r\nreturn 0;\r\n}\r\nstatic void ext4_aiodio_wait(struct inode *inode)\r\n{\r\nwait_queue_head_t *wq = ext4_ioend_wq(inode);\r\nwait_event(*wq, (atomic_read(&EXT4_I(inode)->i_aiodio_unwritten) == 0));\r\n}\r\nstatic int\r\next4_unaligned_aio(struct inode *inode, const struct iovec *iov,\r\nunsigned long nr_segs, loff_t pos)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nint blockmask = sb->s_blocksize - 1;\r\nsize_t count = iov_length(iov, nr_segs);\r\nloff_t final_size = pos + count;\r\nif (pos >= inode->i_size)\r\nreturn 0;\r\nif ((pos & blockmask) || (final_size & blockmask))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\next4_file_write(struct kiocb *iocb, const struct iovec *iov,\r\nunsigned long nr_segs, loff_t pos)\r\n{\r\nstruct inode *inode = iocb->ki_filp->f_path.dentry->d_inode;\r\nint unaligned_aio = 0;\r\nint ret;\r\nif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {\r\nstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\r\nsize_t length = iov_length(iov, nr_segs);\r\nif ((pos > sbi->s_bitmap_maxbytes ||\r\n(pos == sbi->s_bitmap_maxbytes && length > 0)))\r\nreturn -EFBIG;\r\nif (pos + length > sbi->s_bitmap_maxbytes) {\r\nnr_segs = iov_shorten((struct iovec *)iov, nr_segs,\r\nsbi->s_bitmap_maxbytes - pos);\r\n}\r\n} else if (unlikely((iocb->ki_filp->f_flags & O_DIRECT) &&\r\n!is_sync_kiocb(iocb))) {\r\nunaligned_aio = ext4_unaligned_aio(inode, iov, nr_segs, pos);\r\n}\r\nif (unaligned_aio) {\r\nstatic unsigned long unaligned_warn_time;\r\nif (printk_timed_ratelimit(&unaligned_warn_time, 60*60*24*HZ))\r\next4_msg(inode->i_sb, KERN_WARNING,\r\n"Unaligned AIO/DIO on inode %ld by %s; "\r\n"performance will be poor.",\r\ninode->i_ino, current->comm);\r\nmutex_lock(ext4_aio_mutex(inode));\r\next4_aiodio_wait(inode);\r\n}\r\nret = generic_file_aio_write(iocb, iov, nr_segs, pos);\r\nif (unaligned_aio)\r\nmutex_unlock(ext4_aio_mutex(inode));\r\nreturn ret;\r\n}\r\nstatic int ext4_file_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct address_space *mapping = file->f_mapping;\r\nif (!mapping->a_ops->readpage)\r\nreturn -ENOEXEC;\r\nfile_accessed(file);\r\nvma->vm_ops = &ext4_file_vm_ops;\r\nvma->vm_flags |= VM_CAN_NONLINEAR;\r\nreturn 0;\r\n}\r\nstatic int ext4_file_open(struct inode * inode, struct file * filp)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\r\nstruct ext4_inode_info *ei = EXT4_I(inode);\r\nstruct vfsmount *mnt = filp->f_path.mnt;\r\nstruct path path;\r\nchar buf[64], *cp;\r\nif (unlikely(!(sbi->s_mount_flags & EXT4_MF_MNTDIR_SAMPLED) &&\r\n!(sb->s_flags & MS_RDONLY))) {\r\nsbi->s_mount_flags |= EXT4_MF_MNTDIR_SAMPLED;\r\nmemset(buf, 0, sizeof(buf));\r\npath.mnt = mnt;\r\npath.dentry = mnt->mnt_root;\r\ncp = d_path(&path, buf, sizeof(buf));\r\nif (!IS_ERR(cp)) {\r\nstrlcpy(sbi->s_es->s_last_mounted, cp,\r\nsizeof(sbi->s_es->s_last_mounted));\r\next4_mark_super_dirty(sb);\r\n}\r\n}\r\nif (sbi->s_journal && !ei->jinode && (filp->f_mode & FMODE_WRITE)) {\r\nstruct jbd2_inode *jinode = jbd2_alloc_inode(GFP_KERNEL);\r\nspin_lock(&inode->i_lock);\r\nif (!ei->jinode) {\r\nif (!jinode) {\r\nspin_unlock(&inode->i_lock);\r\nreturn -ENOMEM;\r\n}\r\nei->jinode = jinode;\r\njbd2_journal_init_jbd_inode(ei->jinode, inode);\r\njinode = NULL;\r\n}\r\nspin_unlock(&inode->i_lock);\r\nif (unlikely(jinode != NULL))\r\njbd2_free_inode(jinode);\r\n}\r\nreturn dquot_file_open(inode, filp);\r\n}\r\nloff_t ext4_llseek(struct file *file, loff_t offset, int origin)\r\n{\r\nstruct inode *inode = file->f_mapping->host;\r\nloff_t maxbytes;\r\nif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\r\nmaxbytes = EXT4_SB(inode->i_sb)->s_bitmap_maxbytes;\r\nelse\r\nmaxbytes = inode->i_sb->s_maxbytes;\r\nreturn generic_file_llseek_size(file, offset, origin, maxbytes);\r\n}
