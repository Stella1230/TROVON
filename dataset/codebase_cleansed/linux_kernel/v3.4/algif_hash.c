static int hash_sendmsg(struct kiocb *unused, struct socket *sock,\r\nstruct msghdr *msg, size_t ignored)\r\n{\r\nint limit = ALG_MAX_PAGES * PAGE_SIZE;\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct hash_ctx *ctx = ask->private;\r\nunsigned long iovlen;\r\nstruct iovec *iov;\r\nlong copied = 0;\r\nint err;\r\nif (limit > sk->sk_sndbuf)\r\nlimit = sk->sk_sndbuf;\r\nlock_sock(sk);\r\nif (!ctx->more) {\r\nerr = crypto_ahash_init(&ctx->req);\r\nif (err)\r\ngoto unlock;\r\n}\r\nctx->more = 0;\r\nfor (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;\r\niovlen--, iov++) {\r\nunsigned long seglen = iov->iov_len;\r\nchar __user *from = iov->iov_base;\r\nwhile (seglen) {\r\nint len = min_t(unsigned long, seglen, limit);\r\nint newlen;\r\nnewlen = af_alg_make_sg(&ctx->sgl, from, len, 0);\r\nif (newlen < 0) {\r\nerr = copied ? 0 : newlen;\r\ngoto unlock;\r\n}\r\nahash_request_set_crypt(&ctx->req, ctx->sgl.sg, NULL,\r\nnewlen);\r\nerr = af_alg_wait_for_completion(\r\ncrypto_ahash_update(&ctx->req),\r\n&ctx->completion);\r\naf_alg_free_sg(&ctx->sgl);\r\nif (err)\r\ngoto unlock;\r\nseglen -= newlen;\r\nfrom += newlen;\r\ncopied += newlen;\r\n}\r\n}\r\nerr = 0;\r\nctx->more = msg->msg_flags & MSG_MORE;\r\nif (!ctx->more) {\r\nahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);\r\nerr = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),\r\n&ctx->completion);\r\n}\r\nunlock:\r\nrelease_sock(sk);\r\nreturn err ?: copied;\r\n}\r\nstatic ssize_t hash_sendpage(struct socket *sock, struct page *page,\r\nint offset, size_t size, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct hash_ctx *ctx = ask->private;\r\nint err;\r\nlock_sock(sk);\r\nsg_init_table(ctx->sgl.sg, 1);\r\nsg_set_page(ctx->sgl.sg, page, size, offset);\r\nahash_request_set_crypt(&ctx->req, ctx->sgl.sg, ctx->result, size);\r\nif (!(flags & MSG_MORE)) {\r\nif (ctx->more)\r\nerr = crypto_ahash_finup(&ctx->req);\r\nelse\r\nerr = crypto_ahash_digest(&ctx->req);\r\n} else {\r\nif (!ctx->more) {\r\nerr = crypto_ahash_init(&ctx->req);\r\nif (err)\r\ngoto unlock;\r\n}\r\nerr = crypto_ahash_update(&ctx->req);\r\n}\r\nerr = af_alg_wait_for_completion(err, &ctx->completion);\r\nif (err)\r\ngoto unlock;\r\nctx->more = flags & MSG_MORE;\r\nunlock:\r\nrelease_sock(sk);\r\nreturn err ?: size;\r\n}\r\nstatic int hash_recvmsg(struct kiocb *unused, struct socket *sock,\r\nstruct msghdr *msg, size_t len, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct hash_ctx *ctx = ask->private;\r\nunsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));\r\nint err;\r\nif (len > ds)\r\nlen = ds;\r\nelse if (len < ds)\r\nmsg->msg_flags |= MSG_TRUNC;\r\nlock_sock(sk);\r\nif (ctx->more) {\r\nctx->more = 0;\r\nahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);\r\nerr = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),\r\n&ctx->completion);\r\nif (err)\r\ngoto unlock;\r\n}\r\nerr = memcpy_toiovec(msg->msg_iov, ctx->result, len);\r\nunlock:\r\nrelease_sock(sk);\r\nreturn err ?: len;\r\n}\r\nstatic int hash_accept(struct socket *sock, struct socket *newsock, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct hash_ctx *ctx = ask->private;\r\nstruct ahash_request *req = &ctx->req;\r\nchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\r\nstruct sock *sk2;\r\nstruct alg_sock *ask2;\r\nstruct hash_ctx *ctx2;\r\nint err;\r\nerr = crypto_ahash_export(req, state);\r\nif (err)\r\nreturn err;\r\nerr = af_alg_accept(ask->parent, newsock);\r\nif (err)\r\nreturn err;\r\nsk2 = newsock->sk;\r\nask2 = alg_sk(sk2);\r\nctx2 = ask2->private;\r\nctx2->more = 1;\r\nerr = crypto_ahash_import(&ctx2->req, state);\r\nif (err) {\r\nsock_orphan(sk2);\r\nsock_put(sk2);\r\n}\r\nreturn err;\r\n}\r\nstatic void *hash_bind(const char *name, u32 type, u32 mask)\r\n{\r\nreturn crypto_alloc_ahash(name, type, mask);\r\n}\r\nstatic void hash_release(void *private)\r\n{\r\ncrypto_free_ahash(private);\r\n}\r\nstatic int hash_setkey(void *private, const u8 *key, unsigned int keylen)\r\n{\r\nreturn crypto_ahash_setkey(private, key, keylen);\r\n}\r\nstatic void hash_sock_destruct(struct sock *sk)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct hash_ctx *ctx = ask->private;\r\nsock_kfree_s(sk, ctx->result,\r\ncrypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req)));\r\nsock_kfree_s(sk, ctx, ctx->len);\r\naf_alg_release_parent(sk);\r\n}\r\nstatic int hash_accept_parent(void *private, struct sock *sk)\r\n{\r\nstruct hash_ctx *ctx;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nunsigned len = sizeof(*ctx) + crypto_ahash_reqsize(private);\r\nunsigned ds = crypto_ahash_digestsize(private);\r\nctx = sock_kmalloc(sk, len, GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->result = sock_kmalloc(sk, ds, GFP_KERNEL);\r\nif (!ctx->result) {\r\nsock_kfree_s(sk, ctx, len);\r\nreturn -ENOMEM;\r\n}\r\nmemset(ctx->result, 0, ds);\r\nctx->len = len;\r\nctx->more = 0;\r\naf_alg_init_completion(&ctx->completion);\r\nask->private = ctx;\r\nahash_request_set_tfm(&ctx->req, private);\r\nahash_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\r\naf_alg_complete, &ctx->completion);\r\nsk->sk_destruct = hash_sock_destruct;\r\nreturn 0;\r\n}\r\nstatic int __init algif_hash_init(void)\r\n{\r\nreturn af_alg_register_type(&algif_type_hash);\r\n}\r\nstatic void __exit algif_hash_exit(void)\r\n{\r\nint err = af_alg_unregister_type(&algif_type_hash);\r\nBUG_ON(err);\r\n}
