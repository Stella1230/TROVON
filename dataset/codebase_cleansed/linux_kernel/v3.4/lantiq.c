static inline struct\r\nltq_uart_port *to_ltq_uart_port(struct uart_port *port)\r\n{\r\nreturn container_of(port, struct ltq_uart_port, port);\r\n}\r\nstatic void\r\nlqasc_stop_tx(struct uart_port *port)\r\n{\r\nreturn;\r\n}\r\nstatic void\r\nlqasc_start_tx(struct uart_port *port)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ltq_asc_lock, flags);\r\nlqasc_tx_chars(port);\r\nspin_unlock_irqrestore(&ltq_asc_lock, flags);\r\nreturn;\r\n}\r\nstatic void\r\nlqasc_stop_rx(struct uart_port *port)\r\n{\r\nltq_w32(ASCWHBSTATE_CLRREN, port->membase + LTQ_ASC_WHBSTATE);\r\n}\r\nstatic void\r\nlqasc_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic int\r\nlqasc_rx_chars(struct uart_port *port)\r\n{\r\nstruct tty_struct *tty = tty_port_tty_get(&port->state->port);\r\nunsigned int ch = 0, rsr = 0, fifocnt;\r\nif (!tty) {\r\ndev_dbg(port->dev, "%s:tty is busy now", __func__);\r\nreturn -EBUSY;\r\n}\r\nfifocnt =\r\nltq_r32(port->membase + LTQ_ASC_FSTAT) & ASCFSTAT_RXFFLMASK;\r\nwhile (fifocnt--) {\r\nu8 flag = TTY_NORMAL;\r\nch = ltq_r8(port->membase + LTQ_ASC_RBUF);\r\nrsr = (ltq_r32(port->membase + LTQ_ASC_STATE)\r\n& ASCSTATE_ANY) | UART_DUMMY_UER_RX;\r\ntty_flip_buffer_push(tty);\r\nport->icount.rx++;\r\nif (rsr & ASCSTATE_ANY) {\r\nif (rsr & ASCSTATE_PE) {\r\nport->icount.parity++;\r\nltq_w32_mask(0, ASCWHBSTATE_CLRPE,\r\nport->membase + LTQ_ASC_WHBSTATE);\r\n} else if (rsr & ASCSTATE_FE) {\r\nport->icount.frame++;\r\nltq_w32_mask(0, ASCWHBSTATE_CLRFE,\r\nport->membase + LTQ_ASC_WHBSTATE);\r\n}\r\nif (rsr & ASCSTATE_ROE) {\r\nport->icount.overrun++;\r\nltq_w32_mask(0, ASCWHBSTATE_CLRROE,\r\nport->membase + LTQ_ASC_WHBSTATE);\r\n}\r\nrsr &= port->read_status_mask;\r\nif (rsr & ASCSTATE_PE)\r\nflag = TTY_PARITY;\r\nelse if (rsr & ASCSTATE_FE)\r\nflag = TTY_FRAME;\r\n}\r\nif ((rsr & port->ignore_status_mask) == 0)\r\ntty_insert_flip_char(tty, ch, flag);\r\nif (rsr & ASCSTATE_ROE)\r\ntty_insert_flip_char(tty, 0, TTY_OVERRUN);\r\n}\r\nif (ch != 0)\r\ntty_flip_buffer_push(tty);\r\ntty_kref_put(tty);\r\nreturn 0;\r\n}\r\nstatic void\r\nlqasc_tx_chars(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nif (uart_tx_stopped(port)) {\r\nlqasc_stop_tx(port);\r\nreturn;\r\n}\r\nwhile (((ltq_r32(port->membase + LTQ_ASC_FSTAT) &\r\nASCFSTAT_TXFREEMASK) >> ASCFSTAT_TXFREEOFF) != 0) {\r\nif (port->x_char) {\r\nltq_w8(port->x_char, port->membase + LTQ_ASC_TBUF);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\ncontinue;\r\n}\r\nif (uart_circ_empty(xmit))\r\nbreak;\r\nltq_w8(port->state->xmit.buf[port->state->xmit.tail],\r\nport->membase + LTQ_ASC_TBUF);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\n}\r\nstatic irqreturn_t\r\nlqasc_tx_int(int irq, void *_port)\r\n{\r\nunsigned long flags;\r\nstruct uart_port *port = (struct uart_port *)_port;\r\nspin_lock_irqsave(&ltq_asc_lock, flags);\r\nltq_w32(ASC_IRNCR_TIR, port->membase + LTQ_ASC_IRNCR);\r\nspin_unlock_irqrestore(&ltq_asc_lock, flags);\r\nlqasc_start_tx(port);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nlqasc_err_int(int irq, void *_port)\r\n{\r\nunsigned long flags;\r\nstruct uart_port *port = (struct uart_port *)_port;\r\nspin_lock_irqsave(&ltq_asc_lock, flags);\r\nltq_w32_mask(0, ASCWHBSTATE_CLRPE | ASCWHBSTATE_CLRFE |\r\nASCWHBSTATE_CLRROE, port->membase + LTQ_ASC_WHBSTATE);\r\nspin_unlock_irqrestore(&ltq_asc_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nlqasc_rx_int(int irq, void *_port)\r\n{\r\nunsigned long flags;\r\nstruct uart_port *port = (struct uart_port *)_port;\r\nspin_lock_irqsave(&ltq_asc_lock, flags);\r\nltq_w32(ASC_IRNCR_RIR, port->membase + LTQ_ASC_IRNCR);\r\nlqasc_rx_chars(port);\r\nspin_unlock_irqrestore(&ltq_asc_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int\r\nlqasc_tx_empty(struct uart_port *port)\r\n{\r\nint status;\r\nstatus = ltq_r32(port->membase + LTQ_ASC_FSTAT) & ASCFSTAT_TXFFLMASK;\r\nreturn status ? 0 : TIOCSER_TEMT;\r\n}\r\nstatic unsigned int\r\nlqasc_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CTS | TIOCM_CAR | TIOCM_DSR;\r\n}\r\nstatic void\r\nlqasc_set_mctrl(struct uart_port *port, u_int mctrl)\r\n{\r\n}\r\nstatic void\r\nlqasc_break_ctl(struct uart_port *port, int break_state)\r\n{\r\n}\r\nstatic int\r\nlqasc_startup(struct uart_port *port)\r\n{\r\nstruct ltq_uart_port *ltq_port = to_ltq_uart_port(port);\r\nint retval;\r\nport->uartclk = clk_get_rate(ltq_port->clk);\r\nltq_w32_mask(ASCCLC_DISS | ASCCLC_RMCMASK, (1 << ASCCLC_RMCOFFSET),\r\nport->membase + LTQ_ASC_CLC);\r\nltq_w32(0, port->membase + LTQ_ASC_PISEL);\r\nltq_w32(\r\n((TXFIFO_FL << ASCTXFCON_TXFITLOFF) & ASCTXFCON_TXFITLMASK) |\r\nASCTXFCON_TXFEN | ASCTXFCON_TXFFLU,\r\nport->membase + LTQ_ASC_TXFCON);\r\nltq_w32(\r\n((RXFIFO_FL << ASCRXFCON_RXFITLOFF) & ASCRXFCON_RXFITLMASK)\r\n| ASCRXFCON_RXFEN | ASCRXFCON_RXFFLU,\r\nport->membase + LTQ_ASC_RXFCON);\r\nwmb();\r\nltq_w32_mask(0, ASCCON_M_8ASYNC | ASCCON_FEN | ASCCON_TOEN |\r\nASCCON_ROEN, port->membase + LTQ_ASC_CON);\r\nretval = request_irq(ltq_port->tx_irq, lqasc_tx_int,\r\n0, "asc_tx", port);\r\nif (retval) {\r\npr_err("failed to request lqasc_tx_int\n");\r\nreturn retval;\r\n}\r\nretval = request_irq(ltq_port->rx_irq, lqasc_rx_int,\r\n0, "asc_rx", port);\r\nif (retval) {\r\npr_err("failed to request lqasc_rx_int\n");\r\ngoto err1;\r\n}\r\nretval = request_irq(ltq_port->err_irq, lqasc_err_int,\r\n0, "asc_err", port);\r\nif (retval) {\r\npr_err("failed to request lqasc_err_int\n");\r\ngoto err2;\r\n}\r\nltq_w32(ASC_IRNREN_RX | ASC_IRNREN_ERR | ASC_IRNREN_TX,\r\nport->membase + LTQ_ASC_IRNREN);\r\nreturn 0;\r\nerr2:\r\nfree_irq(ltq_port->rx_irq, port);\r\nerr1:\r\nfree_irq(ltq_port->tx_irq, port);\r\nreturn retval;\r\n}\r\nstatic void\r\nlqasc_shutdown(struct uart_port *port)\r\n{\r\nstruct ltq_uart_port *ltq_port = to_ltq_uart_port(port);\r\nfree_irq(ltq_port->tx_irq, port);\r\nfree_irq(ltq_port->rx_irq, port);\r\nfree_irq(ltq_port->err_irq, port);\r\nltq_w32(0, port->membase + LTQ_ASC_CON);\r\nltq_w32_mask(ASCRXFCON_RXFEN, ASCRXFCON_RXFFLU,\r\nport->membase + LTQ_ASC_RXFCON);\r\nltq_w32_mask(ASCTXFCON_TXFEN, ASCTXFCON_TXFFLU,\r\nport->membase + LTQ_ASC_TXFCON);\r\n}\r\nstatic void\r\nlqasc_set_termios(struct uart_port *port,\r\nstruct ktermios *new, struct ktermios *old)\r\n{\r\nunsigned int cflag;\r\nunsigned int iflag;\r\nunsigned int divisor;\r\nunsigned int baud;\r\nunsigned int con = 0;\r\nunsigned long flags;\r\ncflag = new->c_cflag;\r\niflag = new->c_iflag;\r\nswitch (cflag & CSIZE) {\r\ncase CS7:\r\ncon = ASCCON_M_7ASYNC;\r\nbreak;\r\ncase CS5:\r\ncase CS6:\r\ndefault:\r\nnew->c_cflag &= ~ CSIZE;\r\nnew->c_cflag |= CS8;\r\ncon = ASCCON_M_8ASYNC;\r\nbreak;\r\n}\r\ncflag &= ~CMSPAR;\r\nif (cflag & CSTOPB)\r\ncon |= ASCCON_STP;\r\nif (cflag & PARENB) {\r\nif (!(cflag & PARODD))\r\ncon &= ~ASCCON_ODD;\r\nelse\r\ncon |= ASCCON_ODD;\r\n}\r\nport->read_status_mask = ASCSTATE_ROE;\r\nif (iflag & INPCK)\r\nport->read_status_mask |= ASCSTATE_FE | ASCSTATE_PE;\r\nport->ignore_status_mask = 0;\r\nif (iflag & IGNPAR)\r\nport->ignore_status_mask |= ASCSTATE_FE | ASCSTATE_PE;\r\nif (iflag & IGNBRK) {\r\nif (iflag & IGNPAR)\r\nport->ignore_status_mask |= ASCSTATE_ROE;\r\n}\r\nif ((cflag & CREAD) == 0)\r\nport->ignore_status_mask |= UART_DUMMY_UER_RX;\r\ncon |= ASCCON_FEN | ASCCON_TOEN | ASCCON_ROEN;\r\nspin_lock_irqsave(&ltq_asc_lock, flags);\r\nltq_w32_mask(0, con, port->membase + LTQ_ASC_CON);\r\nbaud = uart_get_baud_rate(port, new, old, 0, port->uartclk / 16);\r\ndivisor = uart_get_divisor(port, baud);\r\ndivisor = divisor / 2 - 1;\r\nltq_w32_mask(ASCCON_R, 0, port->membase + LTQ_ASC_CON);\r\nltq_w32_mask(ASCCON_FDE, 0, port->membase + LTQ_ASC_CON);\r\nltq_w32_mask(ASCCON_BRS, 0, port->membase + LTQ_ASC_CON);\r\nltq_w32(divisor, port->membase + LTQ_ASC_BG);\r\nltq_w32_mask(0, ASCCON_R, port->membase + LTQ_ASC_CON);\r\nltq_w32(ASCWHBSTATE_SETREN, port->membase + LTQ_ASC_WHBSTATE);\r\nspin_unlock_irqrestore(&ltq_asc_lock, flags);\r\nif (tty_termios_baud_rate(new))\r\ntty_termios_encode_baud_rate(new, baud, baud);\r\nuart_update_timeout(port, cflag, baud);\r\n}\r\nstatic const char*\r\nlqasc_type(struct uart_port *port)\r\n{\r\nif (port->type == PORT_LTQ_ASC)\r\nreturn DRVNAME;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic void\r\nlqasc_release_port(struct uart_port *port)\r\n{\r\nif (port->flags & UPF_IOREMAP) {\r\niounmap(port->membase);\r\nport->membase = NULL;\r\n}\r\n}\r\nstatic int\r\nlqasc_request_port(struct uart_port *port)\r\n{\r\nstruct platform_device *pdev = to_platform_device(port->dev);\r\nstruct resource *res;\r\nint size;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "cannot obtain I/O memory region");\r\nreturn -ENODEV;\r\n}\r\nsize = resource_size(res);\r\nres = devm_request_mem_region(&pdev->dev, res->start,\r\nsize, dev_name(&pdev->dev));\r\nif (!res) {\r\ndev_err(&pdev->dev, "cannot request I/O memory region");\r\nreturn -EBUSY;\r\n}\r\nif (port->flags & UPF_IOREMAP) {\r\nport->membase = devm_ioremap_nocache(&pdev->dev,\r\nport->mapbase, size);\r\nif (port->membase == NULL)\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nlqasc_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE) {\r\nport->type = PORT_LTQ_ASC;\r\nlqasc_request_port(port);\r\n}\r\n}\r\nstatic int\r\nlqasc_verify_port(struct uart_port *port,\r\nstruct serial_struct *ser)\r\n{\r\nint ret = 0;\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_LTQ_ASC)\r\nret = -EINVAL;\r\nif (ser->irq < 0 || ser->irq >= NR_IRQS)\r\nret = -EINVAL;\r\nif (ser->baud_base < 9600)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic void\r\nlqasc_console_putchar(struct uart_port *port, int ch)\r\n{\r\nint fifofree;\r\nif (!port->membase)\r\nreturn;\r\ndo {\r\nfifofree = (ltq_r32(port->membase + LTQ_ASC_FSTAT)\r\n& ASCFSTAT_TXFREEMASK) >> ASCFSTAT_TXFREEOFF;\r\n} while (fifofree == 0);\r\nltq_w8(ch, port->membase + LTQ_ASC_TBUF);\r\n}\r\nstatic void\r\nlqasc_console_write(struct console *co, const char *s, u_int count)\r\n{\r\nstruct ltq_uart_port *ltq_port;\r\nstruct uart_port *port;\r\nunsigned long flags;\r\nif (co->index >= MAXPORTS)\r\nreturn;\r\nltq_port = lqasc_port[co->index];\r\nif (!ltq_port)\r\nreturn;\r\nport = &ltq_port->port;\r\nspin_lock_irqsave(&ltq_asc_lock, flags);\r\nuart_console_write(port, s, count, lqasc_console_putchar);\r\nspin_unlock_irqrestore(&ltq_asc_lock, flags);\r\n}\r\nstatic int __init\r\nlqasc_console_setup(struct console *co, char *options)\r\n{\r\nstruct ltq_uart_port *ltq_port;\r\nstruct uart_port *port;\r\nint baud = 115200;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nif (co->index >= MAXPORTS)\r\nreturn -ENODEV;\r\nltq_port = lqasc_port[co->index];\r\nif (!ltq_port)\r\nreturn -ENODEV;\r\nport = &ltq_port->port;\r\nport->uartclk = clk_get_rate(ltq_port->clk);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init\r\nlqasc_console_init(void)\r\n{\r\nregister_console(&lqasc_console);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nlqasc_probe(struct platform_device *pdev)\r\n{\r\nstruct ltq_uart_port *ltq_port;\r\nstruct uart_port *port;\r\nstruct resource *mmres, *irqres;\r\nint tx_irq, rx_irq, err_irq;\r\nstruct clk *clk;\r\nint ret;\r\nmmres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirqres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!mmres || !irqres)\r\nreturn -ENODEV;\r\nif (pdev->id >= MAXPORTS)\r\nreturn -EBUSY;\r\nif (lqasc_port[pdev->id] != NULL)\r\nreturn -EBUSY;\r\nclk = clk_get(&pdev->dev, "fpi");\r\nif (IS_ERR(clk)) {\r\npr_err("failed to get fpi clk\n");\r\nreturn -ENOENT;\r\n}\r\ntx_irq = platform_get_irq_byname(pdev, "tx");\r\nrx_irq = platform_get_irq_byname(pdev, "rx");\r\nerr_irq = platform_get_irq_byname(pdev, "err");\r\nif ((tx_irq < 0) | (rx_irq < 0) | (err_irq < 0))\r\nreturn -ENODEV;\r\nltq_port = kzalloc(sizeof(struct ltq_uart_port), GFP_KERNEL);\r\nif (!ltq_port)\r\nreturn -ENOMEM;\r\nport = &ltq_port->port;\r\nport->iotype = SERIAL_IO_MEM;\r\nport->flags = ASYNC_BOOT_AUTOCONF | UPF_IOREMAP;\r\nport->ops = &lqasc_pops;\r\nport->fifosize = 16;\r\nport->type = PORT_LTQ_ASC,\r\nport->line = pdev->id;\r\nport->dev = &pdev->dev;\r\nport->irq = tx_irq;\r\nport->mapbase = mmres->start;\r\nltq_port->clk = clk;\r\nltq_port->tx_irq = tx_irq;\r\nltq_port->rx_irq = rx_irq;\r\nltq_port->err_irq = err_irq;\r\nlqasc_port[pdev->id] = ltq_port;\r\nplatform_set_drvdata(pdev, ltq_port);\r\nret = uart_add_one_port(&lqasc_reg, port);\r\nreturn ret;\r\n}\r\nint __init\r\ninit_lqasc(void)\r\n{\r\nint ret;\r\nret = uart_register_driver(&lqasc_reg);\r\nif (ret != 0)\r\nreturn ret;\r\nret = platform_driver_probe(&lqasc_driver, lqasc_probe);\r\nif (ret != 0)\r\nuart_unregister_driver(&lqasc_reg);\r\nreturn ret;\r\n}
