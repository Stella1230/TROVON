static void\r\ndccp_unique_tuple(struct nf_conntrack_tuple *tuple,\r\nconst struct nf_nat_ipv4_range *range,\r\nenum nf_nat_manip_type maniptype,\r\nconst struct nf_conn *ct)\r\n{\r\nnf_nat_proto_unique_tuple(tuple, range, maniptype, ct,\r\n&dccp_port_rover);\r\n}\r\nstatic bool\r\ndccp_manip_pkt(struct sk_buff *skb,\r\nunsigned int iphdroff,\r\nconst struct nf_conntrack_tuple *tuple,\r\nenum nf_nat_manip_type maniptype)\r\n{\r\nconst struct iphdr *iph = (const void *)(skb->data + iphdroff);\r\nstruct dccp_hdr *hdr;\r\nunsigned int hdroff = iphdroff + iph->ihl * 4;\r\n__be32 oldip, newip;\r\n__be16 *portptr, oldport, newport;\r\nint hdrsize = 8;\r\nif (skb->len >= hdroff + sizeof(struct dccp_hdr))\r\nhdrsize = sizeof(struct dccp_hdr);\r\nif (!skb_make_writable(skb, hdroff + hdrsize))\r\nreturn false;\r\niph = (struct iphdr *)(skb->data + iphdroff);\r\nhdr = (struct dccp_hdr *)(skb->data + hdroff);\r\nif (maniptype == NF_NAT_MANIP_SRC) {\r\noldip = iph->saddr;\r\nnewip = tuple->src.u3.ip;\r\nnewport = tuple->src.u.dccp.port;\r\nportptr = &hdr->dccph_sport;\r\n} else {\r\noldip = iph->daddr;\r\nnewip = tuple->dst.u3.ip;\r\nnewport = tuple->dst.u.dccp.port;\r\nportptr = &hdr->dccph_dport;\r\n}\r\noldport = *portptr;\r\n*portptr = newport;\r\nif (hdrsize < sizeof(*hdr))\r\nreturn true;\r\ninet_proto_csum_replace4(&hdr->dccph_checksum, skb, oldip, newip, 1);\r\ninet_proto_csum_replace2(&hdr->dccph_checksum, skb, oldport, newport,\r\n0);\r\nreturn true;\r\n}\r\nstatic int __init nf_nat_proto_dccp_init(void)\r\n{\r\nreturn nf_nat_protocol_register(&nf_nat_protocol_dccp);\r\n}\r\nstatic void __exit nf_nat_proto_dccp_fini(void)\r\n{\r\nnf_nat_protocol_unregister(&nf_nat_protocol_dccp);\r\n}
