static ssize_t qeth_l3_dev_route_show(struct qeth_card *card,\r\nstruct qeth_routing_info *route, char *buf)\r\n{\r\nswitch (route->type) {\r\ncase PRIMARY_ROUTER:\r\nreturn sprintf(buf, "%s\n", "primary router");\r\ncase SECONDARY_ROUTER:\r\nreturn sprintf(buf, "%s\n", "secondary router");\r\ncase MULTICAST_ROUTER:\r\nif (card->info.broadcast_capable == QETH_BROADCAST_WITHOUT_ECHO)\r\nreturn sprintf(buf, "%s\n", "multicast router+");\r\nelse\r\nreturn sprintf(buf, "%s\n", "multicast router");\r\ncase PRIMARY_CONNECTOR:\r\nif (card->info.broadcast_capable == QETH_BROADCAST_WITHOUT_ECHO)\r\nreturn sprintf(buf, "%s\n", "primary connector+");\r\nelse\r\nreturn sprintf(buf, "%s\n", "primary connector");\r\ncase SECONDARY_CONNECTOR:\r\nif (card->info.broadcast_capable == QETH_BROADCAST_WITHOUT_ECHO)\r\nreturn sprintf(buf, "%s\n", "secondary connector+");\r\nelse\r\nreturn sprintf(buf, "%s\n", "secondary connector");\r\ndefault:\r\nreturn sprintf(buf, "%s\n", "no");\r\n}\r\n}\r\nstatic ssize_t qeth_l3_dev_route4_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_route_show(card, &card->options.route4, buf);\r\n}\r\nstatic ssize_t qeth_l3_dev_route_store(struct qeth_card *card,\r\nstruct qeth_routing_info *route, enum qeth_prot_versions prot,\r\nconst char *buf, size_t count)\r\n{\r\nenum qeth_routing_types old_route_type = route->type;\r\nchar *tmp;\r\nint rc = 0;\r\ntmp = strsep((char **) &buf, "\n");\r\nmutex_lock(&card->conf_mutex);\r\nif (!strcmp(tmp, "no_router")) {\r\nroute->type = NO_ROUTER;\r\n} else if (!strcmp(tmp, "primary_connector")) {\r\nroute->type = PRIMARY_CONNECTOR;\r\n} else if (!strcmp(tmp, "secondary_connector")) {\r\nroute->type = SECONDARY_CONNECTOR;\r\n} else if (!strcmp(tmp, "primary_router")) {\r\nroute->type = PRIMARY_ROUTER;\r\n} else if (!strcmp(tmp, "secondary_router")) {\r\nroute->type = SECONDARY_ROUTER;\r\n} else if (!strcmp(tmp, "multicast_router")) {\r\nroute->type = MULTICAST_ROUTER;\r\n} else {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (((card->state == CARD_STATE_SOFTSETUP) ||\r\n(card->state == CARD_STATE_UP)) &&\r\n(old_route_type != route->type)) {\r\nif (prot == QETH_PROT_IPV4)\r\nrc = qeth_l3_setrouting_v4(card);\r\nelse if (prot == QETH_PROT_IPV6)\r\nrc = qeth_l3_setrouting_v6(card);\r\n}\r\nout:\r\nmutex_unlock(&card->conf_mutex);\r\nreturn rc ? rc : count;\r\n}\r\nstatic ssize_t qeth_l3_dev_route4_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_route_store(card, &card->options.route4,\r\nQETH_PROT_IPV4, buf, count);\r\n}\r\nstatic ssize_t qeth_l3_dev_route6_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_route_show(card, &card->options.route6, buf);\r\n}\r\nstatic ssize_t qeth_l3_dev_route6_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_route_store(card, &card->options.route6,\r\nQETH_PROT_IPV6, buf, count);\r\n}\r\nstatic ssize_t qeth_l3_dev_fake_broadcast_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn sprintf(buf, "%i\n", card->options.fake_broadcast? 1:0);\r\n}\r\nstatic ssize_t qeth_l3_dev_fake_broadcast_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nchar *tmp;\r\nint i, rc = 0;\r\nif (!card)\r\nreturn -EINVAL;\r\nmutex_lock(&card->conf_mutex);\r\nif ((card->state != CARD_STATE_DOWN) &&\r\n(card->state != CARD_STATE_RECOVER)) {\r\nrc = -EPERM;\r\ngoto out;\r\n}\r\ni = simple_strtoul(buf, &tmp, 16);\r\nif ((i == 0) || (i == 1))\r\ncard->options.fake_broadcast = i;\r\nelse\r\nrc = -EINVAL;\r\nout:\r\nmutex_unlock(&card->conf_mutex);\r\nreturn rc ? rc : count;\r\n}\r\nstatic ssize_t qeth_l3_dev_broadcast_mode_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nif (!((card->info.link_type == QETH_LINK_TYPE_HSTR) ||\r\n(card->info.link_type == QETH_LINK_TYPE_LANE_TR)))\r\nreturn sprintf(buf, "n/a\n");\r\nreturn sprintf(buf, "%s\n", (card->options.broadcast_mode ==\r\nQETH_TR_BROADCAST_ALLRINGS)?\r\n"all rings":"local");\r\n}\r\nstatic ssize_t qeth_l3_dev_broadcast_mode_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nchar *tmp;\r\nint rc = 0;\r\nif (!card)\r\nreturn -EINVAL;\r\nmutex_lock(&card->conf_mutex);\r\nif ((card->state != CARD_STATE_DOWN) &&\r\n(card->state != CARD_STATE_RECOVER)) {\r\nrc = -EPERM;\r\ngoto out;\r\n}\r\nif (!((card->info.link_type == QETH_LINK_TYPE_HSTR) ||\r\n(card->info.link_type == QETH_LINK_TYPE_LANE_TR))) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\ntmp = strsep((char **) &buf, "\n");\r\nif (!strcmp(tmp, "local"))\r\ncard->options.broadcast_mode = QETH_TR_BROADCAST_LOCAL;\r\nelse if (!strcmp(tmp, "all_rings"))\r\ncard->options.broadcast_mode = QETH_TR_BROADCAST_ALLRINGS;\r\nelse\r\nrc = -EINVAL;\r\nout:\r\nmutex_unlock(&card->conf_mutex);\r\nreturn rc ? rc : count;\r\n}\r\nstatic ssize_t qeth_l3_dev_canonical_macaddr_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nif (!((card->info.link_type == QETH_LINK_TYPE_HSTR) ||\r\n(card->info.link_type == QETH_LINK_TYPE_LANE_TR)))\r\nreturn sprintf(buf, "n/a\n");\r\nreturn sprintf(buf, "%i\n", (card->options.macaddr_mode ==\r\nQETH_TR_MACADDR_CANONICAL)? 1:0);\r\n}\r\nstatic ssize_t qeth_l3_dev_canonical_macaddr_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nchar *tmp;\r\nint i, rc = 0;\r\nif (!card)\r\nreturn -EINVAL;\r\nmutex_lock(&card->conf_mutex);\r\nif ((card->state != CARD_STATE_DOWN) &&\r\n(card->state != CARD_STATE_RECOVER)) {\r\nrc = -EPERM;\r\ngoto out;\r\n}\r\nif (!((card->info.link_type == QETH_LINK_TYPE_HSTR) ||\r\n(card->info.link_type == QETH_LINK_TYPE_LANE_TR))) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\ni = simple_strtoul(buf, &tmp, 16);\r\nif ((i == 0) || (i == 1))\r\ncard->options.macaddr_mode = i?\r\nQETH_TR_MACADDR_CANONICAL :\r\nQETH_TR_MACADDR_NONCANONICAL;\r\nelse\r\nrc = -EINVAL;\r\nout:\r\nmutex_unlock(&card->conf_mutex);\r\nreturn rc ? rc : count;\r\n}\r\nstatic ssize_t qeth_l3_dev_sniffer_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn sprintf(buf, "%i\n", card->options.sniffer ? 1 : 0);\r\n}\r\nstatic ssize_t qeth_l3_dev_sniffer_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nint rc = 0;\r\nunsigned long i;\r\nif (!card)\r\nreturn -EINVAL;\r\nif (card->info.type != QETH_CARD_TYPE_IQD)\r\nreturn -EPERM;\r\nif (card->options.cq == QETH_CQ_ENABLED)\r\nreturn -EPERM;\r\nmutex_lock(&card->conf_mutex);\r\nif ((card->state != CARD_STATE_DOWN) &&\r\n(card->state != CARD_STATE_RECOVER)) {\r\nrc = -EPERM;\r\ngoto out;\r\n}\r\nrc = strict_strtoul(buf, 16, &i);\r\nif (rc) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (i) {\r\ncase 0:\r\ncard->options.sniffer = i;\r\nbreak;\r\ncase 1:\r\nqdio_get_ssqd_desc(CARD_DDEV(card), &card->ssqd);\r\nif (card->ssqd.qdioac2 & QETH_SNIFF_AVAIL) {\r\ncard->options.sniffer = i;\r\nif (card->qdio.init_pool.buf_count !=\r\nQETH_IN_BUF_COUNT_MAX)\r\nqeth_realloc_buffer_pool(card,\r\nQETH_IN_BUF_COUNT_MAX);\r\n} else\r\nrc = -EPERM;\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\n}\r\nout:\r\nmutex_unlock(&card->conf_mutex);\r\nreturn rc ? rc : count;\r\n}\r\nstatic ssize_t qeth_l3_dev_hsuid_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nchar tmp_hsuid[9];\r\nif (!card)\r\nreturn -EINVAL;\r\nif (card->info.type != QETH_CARD_TYPE_IQD)\r\nreturn -EPERM;\r\nif (card->state == CARD_STATE_DOWN)\r\nreturn -EPERM;\r\nmemcpy(tmp_hsuid, card->options.hsuid, sizeof(tmp_hsuid));\r\nEBCASC(tmp_hsuid, 8);\r\nreturn sprintf(buf, "%s\n", tmp_hsuid);\r\n}\r\nstatic ssize_t qeth_l3_dev_hsuid_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nstruct qeth_ipaddr *addr;\r\nchar *tmp;\r\nint i;\r\nif (!card)\r\nreturn -EINVAL;\r\nif (card->info.type != QETH_CARD_TYPE_IQD)\r\nreturn -EPERM;\r\nif (card->state != CARD_STATE_DOWN &&\r\ncard->state != CARD_STATE_RECOVER)\r\nreturn -EPERM;\r\nif (card->options.sniffer)\r\nreturn -EPERM;\r\nif (card->options.cq == QETH_CQ_NOTAVAILABLE)\r\nreturn -EPERM;\r\ntmp = strsep((char **)&buf, "\n");\r\nif (strlen(tmp) > 8)\r\nreturn -EINVAL;\r\nif (card->options.hsuid[0]) {\r\naddr = qeth_l3_get_addr_buffer(QETH_PROT_IPV6);\r\nif (addr != NULL) {\r\naddr->u.a6.addr.s6_addr32[0] = 0xfe800000;\r\naddr->u.a6.addr.s6_addr32[1] = 0x00000000;\r\nfor (i = 8; i < 16; i++)\r\naddr->u.a6.addr.s6_addr[i] =\r\ncard->options.hsuid[i - 8];\r\naddr->u.a6.pfxlen = 0;\r\naddr->type = QETH_IP_TYPE_NORMAL;\r\n} else\r\nreturn -ENOMEM;\r\nif (!qeth_l3_delete_ip(card, addr))\r\nkfree(addr);\r\nqeth_l3_set_ip_addr_list(card);\r\n}\r\nif (strlen(tmp) == 0) {\r\ncard->options.hsuid[0] = '\0';\r\nif (card->dev)\r\nmemcpy(card->dev->perm_addr, card->options.hsuid, 9);\r\nqeth_configure_cq(card, QETH_CQ_DISABLED);\r\nreturn count;\r\n}\r\nif (qeth_configure_cq(card, QETH_CQ_ENABLED))\r\nreturn -EPERM;\r\nfor (i = 0; i < 8; i++)\r\ncard->options.hsuid[i] = ' ';\r\ncard->options.hsuid[8] = '\0';\r\nstrncpy(card->options.hsuid, tmp, strlen(tmp));\r\nASCEBC(card->options.hsuid, 8);\r\nif (card->dev)\r\nmemcpy(card->dev->perm_addr, card->options.hsuid, 9);\r\naddr = qeth_l3_get_addr_buffer(QETH_PROT_IPV6);\r\nif (addr != NULL) {\r\naddr->u.a6.addr.s6_addr32[0] = 0xfe800000;\r\naddr->u.a6.addr.s6_addr32[1] = 0x00000000;\r\nfor (i = 8; i < 16; i++)\r\naddr->u.a6.addr.s6_addr[i] = card->options.hsuid[i - 8];\r\naddr->u.a6.pfxlen = 0;\r\naddr->type = QETH_IP_TYPE_NORMAL;\r\n} else\r\nreturn -ENOMEM;\r\nif (!qeth_l3_add_ip(card, addr))\r\nkfree(addr);\r\nqeth_l3_set_ip_addr_list(card);\r\nreturn count;\r\n}\r\nstatic ssize_t qeth_l3_dev_ipato_enable_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn sprintf(buf, "%i\n", card->ipato.enabled? 1:0);\r\n}\r\nstatic ssize_t qeth_l3_dev_ipato_enable_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nstruct qeth_ipaddr *tmpipa, *t;\r\nchar *tmp;\r\nint rc = 0;\r\nif (!card)\r\nreturn -EINVAL;\r\nmutex_lock(&card->conf_mutex);\r\nif ((card->state != CARD_STATE_DOWN) &&\r\n(card->state != CARD_STATE_RECOVER)) {\r\nrc = -EPERM;\r\ngoto out;\r\n}\r\ntmp = strsep((char **) &buf, "\n");\r\nif (!strcmp(tmp, "toggle")) {\r\ncard->ipato.enabled = (card->ipato.enabled)? 0 : 1;\r\n} else if (!strcmp(tmp, "1")) {\r\ncard->ipato.enabled = 1;\r\nlist_for_each_entry_safe(tmpipa, t, card->ip_tbd_list, entry) {\r\nif ((tmpipa->type == QETH_IP_TYPE_NORMAL) &&\r\nqeth_l3_is_addr_covered_by_ipato(card, tmpipa))\r\ntmpipa->set_flags |=\r\nQETH_IPA_SETIP_TAKEOVER_FLAG;\r\n}\r\n} else if (!strcmp(tmp, "0")) {\r\ncard->ipato.enabled = 0;\r\nlist_for_each_entry_safe(tmpipa, t, card->ip_tbd_list, entry) {\r\nif (tmpipa->set_flags &\r\nQETH_IPA_SETIP_TAKEOVER_FLAG)\r\ntmpipa->set_flags &=\r\n~QETH_IPA_SETIP_TAKEOVER_FLAG;\r\n}\r\n} else\r\nrc = -EINVAL;\r\nout:\r\nmutex_unlock(&card->conf_mutex);\r\nreturn rc ? rc : count;\r\n}\r\nstatic ssize_t qeth_l3_dev_ipato_invert4_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn sprintf(buf, "%i\n", card->ipato.invert4? 1:0);\r\n}\r\nstatic ssize_t qeth_l3_dev_ipato_invert4_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nchar *tmp;\r\nint rc = 0;\r\nif (!card)\r\nreturn -EINVAL;\r\nmutex_lock(&card->conf_mutex);\r\ntmp = strsep((char **) &buf, "\n");\r\nif (!strcmp(tmp, "toggle")) {\r\ncard->ipato.invert4 = (card->ipato.invert4)? 0 : 1;\r\n} else if (!strcmp(tmp, "1")) {\r\ncard->ipato.invert4 = 1;\r\n} else if (!strcmp(tmp, "0")) {\r\ncard->ipato.invert4 = 0;\r\n} else\r\nrc = -EINVAL;\r\nmutex_unlock(&card->conf_mutex);\r\nreturn rc ? rc : count;\r\n}\r\nstatic ssize_t qeth_l3_dev_ipato_add_show(char *buf, struct qeth_card *card,\r\nenum qeth_prot_versions proto)\r\n{\r\nstruct qeth_ipato_entry *ipatoe;\r\nunsigned long flags;\r\nchar addr_str[40];\r\nint entry_len;\r\nint i = 0;\r\nentry_len = (proto == QETH_PROT_IPV4)? 12 : 40;\r\nentry_len += (proto == QETH_PROT_IPV4)? 5 : 6;\r\nspin_lock_irqsave(&card->ip_lock, flags);\r\nlist_for_each_entry(ipatoe, &card->ipato.entries, entry) {\r\nif (ipatoe->proto != proto)\r\ncontinue;\r\nif ((PAGE_SIZE - i) <= entry_len)\r\nbreak;\r\nqeth_l3_ipaddr_to_string(proto, ipatoe->addr, addr_str);\r\ni += snprintf(buf + i, PAGE_SIZE - i,\r\n"%s/%i\n", addr_str, ipatoe->mask_bits);\r\n}\r\nspin_unlock_irqrestore(&card->ip_lock, flags);\r\ni += snprintf(buf + i, PAGE_SIZE - i, "\n");\r\nreturn i;\r\n}\r\nstatic ssize_t qeth_l3_dev_ipato_add4_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_ipato_add_show(buf, card, QETH_PROT_IPV4);\r\n}\r\nstatic int qeth_l3_parse_ipatoe(const char *buf, enum qeth_prot_versions proto,\r\nu8 *addr, int *mask_bits)\r\n{\r\nconst char *start, *end;\r\nchar *tmp;\r\nchar buffer[40] = {0, };\r\nstart = buf;\r\nend = strchr(start, '/');\r\nif (!end || (end - start >= 40)) {\r\nreturn -EINVAL;\r\n}\r\nstrncpy(buffer, start, end - start);\r\nif (qeth_l3_string_to_ipaddr(buffer, proto, addr)) {\r\nreturn -EINVAL;\r\n}\r\nstart = end + 1;\r\n*mask_bits = simple_strtoul(start, &tmp, 10);\r\nif (!strlen(start) ||\r\n(tmp == start) ||\r\n(*mask_bits > ((proto == QETH_PROT_IPV4) ? 32 : 128))) {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t qeth_l3_dev_ipato_add_store(const char *buf, size_t count,\r\nstruct qeth_card *card, enum qeth_prot_versions proto)\r\n{\r\nstruct qeth_ipato_entry *ipatoe;\r\nu8 addr[16];\r\nint mask_bits;\r\nint rc = 0;\r\nmutex_lock(&card->conf_mutex);\r\nrc = qeth_l3_parse_ipatoe(buf, proto, addr, &mask_bits);\r\nif (rc)\r\ngoto out;\r\nipatoe = kzalloc(sizeof(struct qeth_ipato_entry), GFP_KERNEL);\r\nif (!ipatoe) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nipatoe->proto = proto;\r\nmemcpy(ipatoe->addr, addr, (proto == QETH_PROT_IPV4)? 4:16);\r\nipatoe->mask_bits = mask_bits;\r\nrc = qeth_l3_add_ipato_entry(card, ipatoe);\r\nif (rc)\r\nkfree(ipatoe);\r\nout:\r\nmutex_unlock(&card->conf_mutex);\r\nreturn rc ? rc : count;\r\n}\r\nstatic ssize_t qeth_l3_dev_ipato_add4_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_ipato_add_store(buf, count, card, QETH_PROT_IPV4);\r\n}\r\nstatic ssize_t qeth_l3_dev_ipato_del_store(const char *buf, size_t count,\r\nstruct qeth_card *card, enum qeth_prot_versions proto)\r\n{\r\nu8 addr[16];\r\nint mask_bits;\r\nint rc = 0;\r\nmutex_lock(&card->conf_mutex);\r\nrc = qeth_l3_parse_ipatoe(buf, proto, addr, &mask_bits);\r\nif (!rc)\r\nqeth_l3_del_ipato_entry(card, proto, addr, mask_bits);\r\nmutex_unlock(&card->conf_mutex);\r\nreturn rc ? rc : count;\r\n}\r\nstatic ssize_t qeth_l3_dev_ipato_del4_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_ipato_del_store(buf, count, card, QETH_PROT_IPV4);\r\n}\r\nstatic ssize_t qeth_l3_dev_ipato_invert6_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn sprintf(buf, "%i\n", card->ipato.invert6? 1:0);\r\n}\r\nstatic ssize_t qeth_l3_dev_ipato_invert6_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nchar *tmp;\r\nint rc = 0;\r\nif (!card)\r\nreturn -EINVAL;\r\nmutex_lock(&card->conf_mutex);\r\ntmp = strsep((char **) &buf, "\n");\r\nif (!strcmp(tmp, "toggle")) {\r\ncard->ipato.invert6 = (card->ipato.invert6)? 0 : 1;\r\n} else if (!strcmp(tmp, "1")) {\r\ncard->ipato.invert6 = 1;\r\n} else if (!strcmp(tmp, "0")) {\r\ncard->ipato.invert6 = 0;\r\n} else\r\nrc = -EINVAL;\r\nmutex_unlock(&card->conf_mutex);\r\nreturn rc ? rc : count;\r\n}\r\nstatic ssize_t qeth_l3_dev_ipato_add6_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_ipato_add_show(buf, card, QETH_PROT_IPV6);\r\n}\r\nstatic ssize_t qeth_l3_dev_ipato_add6_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_ipato_add_store(buf, count, card, QETH_PROT_IPV6);\r\n}\r\nstatic ssize_t qeth_l3_dev_ipato_del6_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_ipato_del_store(buf, count, card, QETH_PROT_IPV6);\r\n}\r\nstatic ssize_t qeth_l3_dev_vipa_add_show(char *buf, struct qeth_card *card,\r\nenum qeth_prot_versions proto)\r\n{\r\nstruct qeth_ipaddr *ipaddr;\r\nchar addr_str[40];\r\nint entry_len;\r\nunsigned long flags;\r\nint i = 0;\r\nentry_len = (proto == QETH_PROT_IPV4)? 12 : 40;\r\nentry_len += 2;\r\nspin_lock_irqsave(&card->ip_lock, flags);\r\nlist_for_each_entry(ipaddr, &card->ip_list, entry) {\r\nif (ipaddr->proto != proto)\r\ncontinue;\r\nif (ipaddr->type != QETH_IP_TYPE_VIPA)\r\ncontinue;\r\nif ((PAGE_SIZE - i) <= entry_len)\r\nbreak;\r\nqeth_l3_ipaddr_to_string(proto, (const u8 *)&ipaddr->u,\r\naddr_str);\r\ni += snprintf(buf + i, PAGE_SIZE - i, "%s\n", addr_str);\r\n}\r\nspin_unlock_irqrestore(&card->ip_lock, flags);\r\ni += snprintf(buf + i, PAGE_SIZE - i, "\n");\r\nreturn i;\r\n}\r\nstatic ssize_t qeth_l3_dev_vipa_add4_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_vipa_add_show(buf, card, QETH_PROT_IPV4);\r\n}\r\nstatic int qeth_l3_parse_vipae(const char *buf, enum qeth_prot_versions proto,\r\nu8 *addr)\r\n{\r\nif (qeth_l3_string_to_ipaddr(buf, proto, addr)) {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t qeth_l3_dev_vipa_add_store(const char *buf, size_t count,\r\nstruct qeth_card *card, enum qeth_prot_versions proto)\r\n{\r\nu8 addr[16] = {0, };\r\nint rc;\r\nmutex_lock(&card->conf_mutex);\r\nrc = qeth_l3_parse_vipae(buf, proto, addr);\r\nif (!rc)\r\nrc = qeth_l3_add_vipa(card, proto, addr);\r\nmutex_unlock(&card->conf_mutex);\r\nreturn rc ? rc : count;\r\n}\r\nstatic ssize_t qeth_l3_dev_vipa_add4_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_vipa_add_store(buf, count, card, QETH_PROT_IPV4);\r\n}\r\nstatic ssize_t qeth_l3_dev_vipa_del_store(const char *buf, size_t count,\r\nstruct qeth_card *card, enum qeth_prot_versions proto)\r\n{\r\nu8 addr[16];\r\nint rc;\r\nmutex_lock(&card->conf_mutex);\r\nrc = qeth_l3_parse_vipae(buf, proto, addr);\r\nif (!rc)\r\nqeth_l3_del_vipa(card, proto, addr);\r\nmutex_unlock(&card->conf_mutex);\r\nreturn rc ? rc : count;\r\n}\r\nstatic ssize_t qeth_l3_dev_vipa_del4_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_vipa_del_store(buf, count, card, QETH_PROT_IPV4);\r\n}\r\nstatic ssize_t qeth_l3_dev_vipa_add6_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_vipa_add_show(buf, card, QETH_PROT_IPV6);\r\n}\r\nstatic ssize_t qeth_l3_dev_vipa_add6_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_vipa_add_store(buf, count, card, QETH_PROT_IPV6);\r\n}\r\nstatic ssize_t qeth_l3_dev_vipa_del6_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_vipa_del_store(buf, count, card, QETH_PROT_IPV6);\r\n}\r\nstatic ssize_t qeth_l3_dev_rxip_add_show(char *buf, struct qeth_card *card,\r\nenum qeth_prot_versions proto)\r\n{\r\nstruct qeth_ipaddr *ipaddr;\r\nchar addr_str[40];\r\nint entry_len;\r\nunsigned long flags;\r\nint i = 0;\r\nentry_len = (proto == QETH_PROT_IPV4)? 12 : 40;\r\nentry_len += 2;\r\nspin_lock_irqsave(&card->ip_lock, flags);\r\nlist_for_each_entry(ipaddr, &card->ip_list, entry) {\r\nif (ipaddr->proto != proto)\r\ncontinue;\r\nif (ipaddr->type != QETH_IP_TYPE_RXIP)\r\ncontinue;\r\nif ((PAGE_SIZE - i) <= entry_len)\r\nbreak;\r\nqeth_l3_ipaddr_to_string(proto, (const u8 *)&ipaddr->u,\r\naddr_str);\r\ni += snprintf(buf + i, PAGE_SIZE - i, "%s\n", addr_str);\r\n}\r\nspin_unlock_irqrestore(&card->ip_lock, flags);\r\ni += snprintf(buf + i, PAGE_SIZE - i, "\n");\r\nreturn i;\r\n}\r\nstatic ssize_t qeth_l3_dev_rxip_add4_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_rxip_add_show(buf, card, QETH_PROT_IPV4);\r\n}\r\nstatic int qeth_l3_parse_rxipe(const char *buf, enum qeth_prot_versions proto,\r\nu8 *addr)\r\n{\r\nif (qeth_l3_string_to_ipaddr(buf, proto, addr)) {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t qeth_l3_dev_rxip_add_store(const char *buf, size_t count,\r\nstruct qeth_card *card, enum qeth_prot_versions proto)\r\n{\r\nu8 addr[16] = {0, };\r\nint rc;\r\nmutex_lock(&card->conf_mutex);\r\nrc = qeth_l3_parse_rxipe(buf, proto, addr);\r\nif (!rc)\r\nrc = qeth_l3_add_rxip(card, proto, addr);\r\nmutex_unlock(&card->conf_mutex);\r\nreturn rc ? rc : count;\r\n}\r\nstatic ssize_t qeth_l3_dev_rxip_add4_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_rxip_add_store(buf, count, card, QETH_PROT_IPV4);\r\n}\r\nstatic ssize_t qeth_l3_dev_rxip_del_store(const char *buf, size_t count,\r\nstruct qeth_card *card, enum qeth_prot_versions proto)\r\n{\r\nu8 addr[16];\r\nint rc;\r\nmutex_lock(&card->conf_mutex);\r\nrc = qeth_l3_parse_rxipe(buf, proto, addr);\r\nif (!rc)\r\nqeth_l3_del_rxip(card, proto, addr);\r\nmutex_unlock(&card->conf_mutex);\r\nreturn rc ? rc : count;\r\n}\r\nstatic ssize_t qeth_l3_dev_rxip_del4_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_rxip_del_store(buf, count, card, QETH_PROT_IPV4);\r\n}\r\nstatic ssize_t qeth_l3_dev_rxip_add6_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_rxip_add_show(buf, card, QETH_PROT_IPV6);\r\n}\r\nstatic ssize_t qeth_l3_dev_rxip_add6_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_rxip_add_store(buf, count, card, QETH_PROT_IPV6);\r\n}\r\nstatic ssize_t qeth_l3_dev_rxip_del6_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct qeth_card *card = dev_get_drvdata(dev);\r\nif (!card)\r\nreturn -EINVAL;\r\nreturn qeth_l3_dev_rxip_del_store(buf, count, card, QETH_PROT_IPV6);\r\n}\r\nint qeth_l3_create_device_attributes(struct device *dev)\r\n{\r\nint ret;\r\nret = sysfs_create_group(&dev->kobj, &qeth_l3_device_attr_group);\r\nif (ret)\r\nreturn ret;\r\nret = sysfs_create_group(&dev->kobj, &qeth_device_ipato_group);\r\nif (ret) {\r\nsysfs_remove_group(&dev->kobj, &qeth_l3_device_attr_group);\r\nreturn ret;\r\n}\r\nret = sysfs_create_group(&dev->kobj, &qeth_device_vipa_group);\r\nif (ret) {\r\nsysfs_remove_group(&dev->kobj, &qeth_l3_device_attr_group);\r\nsysfs_remove_group(&dev->kobj, &qeth_device_ipato_group);\r\nreturn ret;\r\n}\r\nret = sysfs_create_group(&dev->kobj, &qeth_device_rxip_group);\r\nif (ret) {\r\nsysfs_remove_group(&dev->kobj, &qeth_l3_device_attr_group);\r\nsysfs_remove_group(&dev->kobj, &qeth_device_ipato_group);\r\nsysfs_remove_group(&dev->kobj, &qeth_device_vipa_group);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid qeth_l3_remove_device_attributes(struct device *dev)\r\n{\r\nsysfs_remove_group(&dev->kobj, &qeth_l3_device_attr_group);\r\nsysfs_remove_group(&dev->kobj, &qeth_device_ipato_group);\r\nsysfs_remove_group(&dev->kobj, &qeth_device_vipa_group);\r\nsysfs_remove_group(&dev->kobj, &qeth_device_rxip_group);\r\n}
