static unsigned long clk_pwm_scaler_get_rate(struct clk *clk)\r\n{\r\nunsigned long tcfg0 = __raw_readl(S3C2410_TCFG0);\r\nif (clk == &clk_timer_scaler[1]) {\r\ntcfg0 &= S3C2410_TCFG_PRESCALER1_MASK;\r\ntcfg0 >>= S3C2410_TCFG_PRESCALER1_SHIFT;\r\n} else {\r\ntcfg0 &= S3C2410_TCFG_PRESCALER0_MASK;\r\n}\r\nreturn clk_get_rate(clk->parent) / (tcfg0 + 1);\r\n}\r\nstatic unsigned long clk_pwm_scaler_round_rate(struct clk *clk,\r\nunsigned long rate)\r\n{\r\nunsigned long parent_rate = clk_get_rate(clk->parent);\r\nunsigned long divisor = parent_rate / rate;\r\nif (divisor > 256)\r\ndivisor = 256;\r\nelse if (divisor < 2)\r\ndivisor = 2;\r\nreturn parent_rate / divisor;\r\n}\r\nstatic int clk_pwm_scaler_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nunsigned long round = clk_pwm_scaler_round_rate(clk, rate);\r\nunsigned long tcfg0;\r\nunsigned long divisor;\r\nunsigned long flags;\r\ndivisor = clk_get_rate(clk->parent) / round;\r\ndivisor--;\r\nlocal_irq_save(flags);\r\ntcfg0 = __raw_readl(S3C2410_TCFG0);\r\nif (clk == &clk_timer_scaler[1]) {\r\ntcfg0 &= ~S3C2410_TCFG_PRESCALER1_MASK;\r\ntcfg0 |= divisor << S3C2410_TCFG_PRESCALER1_SHIFT;\r\n} else {\r\ntcfg0 &= ~S3C2410_TCFG_PRESCALER0_MASK;\r\ntcfg0 |= divisor;\r\n}\r\n__raw_writel(tcfg0, S3C2410_TCFG0);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic inline struct pwm_tdiv_clk *to_tdiv(struct clk *clk)\r\n{\r\nreturn container_of(clk, struct pwm_tdiv_clk, clk);\r\n}\r\nstatic unsigned long clk_pwm_tdiv_get_rate(struct clk *clk)\r\n{\r\nunsigned long tcfg1 = __raw_readl(S3C2410_TCFG1);\r\nunsigned int divisor;\r\ntcfg1 >>= S3C2410_TCFG1_SHIFT(clk->id);\r\ntcfg1 &= S3C2410_TCFG1_MUX_MASK;\r\nif (pwm_cfg_src_is_tclk(tcfg1))\r\ndivisor = to_tdiv(clk)->divisor;\r\nelse\r\ndivisor = tcfg_to_divisor(tcfg1);\r\nreturn clk_get_rate(clk->parent) / divisor;\r\n}\r\nstatic unsigned long clk_pwm_tdiv_round_rate(struct clk *clk,\r\nunsigned long rate)\r\n{\r\nunsigned long parent_rate;\r\nunsigned long divisor;\r\nparent_rate = clk_get_rate(clk->parent);\r\ndivisor = parent_rate / rate;\r\nif (divisor <= 1 && pwm_tdiv_has_div1())\r\ndivisor = 1;\r\nelse if (divisor <= 2)\r\ndivisor = 2;\r\nelse if (divisor <= 4)\r\ndivisor = 4;\r\nelse if (divisor <= 8)\r\ndivisor = 8;\r\nelse\r\ndivisor = 16;\r\nreturn parent_rate / divisor;\r\n}\r\nstatic unsigned long clk_pwm_tdiv_bits(struct pwm_tdiv_clk *divclk)\r\n{\r\nreturn pwm_tdiv_div_bits(divclk->divisor);\r\n}\r\nstatic void clk_pwm_tdiv_update(struct pwm_tdiv_clk *divclk)\r\n{\r\nunsigned long tcfg1 = __raw_readl(S3C2410_TCFG1);\r\nunsigned long bits = clk_pwm_tdiv_bits(divclk);\r\nunsigned long flags;\r\nunsigned long shift = S3C2410_TCFG1_SHIFT(divclk->clk.id);\r\nlocal_irq_save(flags);\r\ntcfg1 = __raw_readl(S3C2410_TCFG1);\r\ntcfg1 &= ~(S3C2410_TCFG1_MUX_MASK << shift);\r\ntcfg1 |= bits << shift;\r\n__raw_writel(tcfg1, S3C2410_TCFG1);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int clk_pwm_tdiv_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nstruct pwm_tdiv_clk *divclk = to_tdiv(clk);\r\nunsigned long tcfg1 = __raw_readl(S3C2410_TCFG1);\r\nunsigned long parent_rate = clk_get_rate(clk->parent);\r\nunsigned long divisor;\r\ntcfg1 >>= S3C2410_TCFG1_SHIFT(clk->id);\r\ntcfg1 &= S3C2410_TCFG1_MUX_MASK;\r\nrate = clk_round_rate(clk, rate);\r\ndivisor = parent_rate / rate;\r\nif (divisor > 16)\r\nreturn -EINVAL;\r\ndivclk->divisor = divisor;\r\nif (!pwm_cfg_src_is_tclk(tcfg1))\r\nclk_pwm_tdiv_update(divclk);\r\nreturn 0;\r\n}\r\nstatic int __init clk_pwm_tdiv_register(unsigned int id)\r\n{\r\nstruct pwm_tdiv_clk *divclk = &clk_timer_tdiv[id];\r\nunsigned long tcfg1 = __raw_readl(S3C2410_TCFG1);\r\ntcfg1 >>= S3C2410_TCFG1_SHIFT(id);\r\ntcfg1 &= S3C2410_TCFG1_MUX_MASK;\r\ndivclk->clk.id = id;\r\ndivclk->divisor = tcfg_to_divisor(tcfg1);\r\nreturn s3c24xx_register_clock(&divclk->clk);\r\n}\r\nstatic inline struct clk *s3c24xx_pwmclk_tclk(unsigned int id)\r\n{\r\nreturn (id >= 2) ? &clk_timer_tclk[1] : &clk_timer_tclk[0];\r\n}\r\nstatic inline struct clk *s3c24xx_pwmclk_tdiv(unsigned int id)\r\n{\r\nreturn &clk_timer_tdiv[id].clk;\r\n}\r\nstatic int clk_pwm_tin_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nunsigned int id = clk->id;\r\nunsigned long tcfg1;\r\nunsigned long flags;\r\nunsigned long bits;\r\nunsigned long shift = S3C2410_TCFG1_SHIFT(id);\r\nunsigned long mux_tclk;\r\nif (soc_is_s3c24xx())\r\nmux_tclk = S3C2410_TCFG1_MUX_TCLK;\r\nelse if (soc_is_s5p6440() || soc_is_s5p6450())\r\nmux_tclk = 0;\r\nelse\r\nmux_tclk = S3C64XX_TCFG1_MUX_TCLK;\r\nif (parent == s3c24xx_pwmclk_tclk(id))\r\nbits = mux_tclk << shift;\r\nelse if (parent == s3c24xx_pwmclk_tdiv(id))\r\nbits = clk_pwm_tdiv_bits(to_tdiv(parent)) << shift;\r\nelse\r\nreturn -EINVAL;\r\nclk->parent = parent;\r\nlocal_irq_save(flags);\r\ntcfg1 = __raw_readl(S3C2410_TCFG1);\r\ntcfg1 &= ~(S3C2410_TCFG1_MUX_MASK << shift);\r\n__raw_writel(tcfg1 | bits, S3C2410_TCFG1);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic __init int clk_pwm_tin_register(struct clk *pwm)\r\n{\r\nunsigned long tcfg1 = __raw_readl(S3C2410_TCFG1);\r\nunsigned int id = pwm->id;\r\nstruct clk *parent;\r\nint ret;\r\nret = s3c24xx_register_clock(pwm);\r\nif (ret < 0)\r\nreturn ret;\r\ntcfg1 >>= S3C2410_TCFG1_SHIFT(id);\r\ntcfg1 &= S3C2410_TCFG1_MUX_MASK;\r\nif (pwm_cfg_src_is_tclk(tcfg1))\r\nparent = s3c24xx_pwmclk_tclk(id);\r\nelse\r\nparent = s3c24xx_pwmclk_tdiv(id);\r\nreturn clk_set_parent(pwm, parent);\r\n}\r\n__init void s3c_pwmclk_init(void)\r\n{\r\nstruct clk *clk_timers;\r\nunsigned int clk;\r\nint ret;\r\nclk_timers = clk_get(NULL, "timers");\r\nif (IS_ERR(clk_timers)) {\r\nprintk(KERN_ERR "%s: no parent clock\n", __func__);\r\nreturn;\r\n}\r\nfor (clk = 0; clk < ARRAY_SIZE(clk_timer_scaler); clk++)\r\nclk_timer_scaler[clk].parent = clk_timers;\r\ns3c_register_clocks(clk_timer_scaler, ARRAY_SIZE(clk_timer_scaler));\r\ns3c_register_clocks(clk_timer_tclk, ARRAY_SIZE(clk_timer_tclk));\r\nfor (clk = 0; clk < ARRAY_SIZE(clk_timer_tdiv); clk++) {\r\nret = clk_pwm_tdiv_register(clk);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "error adding pwm%d tdiv clock\n", clk);\r\nreturn;\r\n}\r\n}\r\nfor (clk = 0; clk < ARRAY_SIZE(clk_tin); clk++) {\r\nret = clk_pwm_tin_register(&clk_tin[clk]);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "error adding pwm%d tin clock\n", clk);\r\nreturn;\r\n}\r\n}\r\n}
