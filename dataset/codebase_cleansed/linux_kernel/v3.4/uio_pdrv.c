static int uio_pdrv_probe(struct platform_device *pdev)\r\n{\r\nstruct uio_info *uioinfo = pdev->dev.platform_data;\r\nstruct uio_platdata *pdata;\r\nstruct uio_mem *uiomem;\r\nint ret = -ENODEV;\r\nint i;\r\nif (!uioinfo || !uioinfo->name || !uioinfo->version) {\r\ndev_dbg(&pdev->dev, "%s: err_uioinfo\n", __func__);\r\ngoto err_uioinfo;\r\n}\r\npdata = kzalloc(sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata) {\r\nret = -ENOMEM;\r\ndev_dbg(&pdev->dev, "%s: err_alloc_pdata\n", __func__);\r\ngoto err_alloc_pdata;\r\n}\r\npdata->uioinfo = uioinfo;\r\nuiomem = &uioinfo->mem[0];\r\nfor (i = 0; i < pdev->num_resources; ++i) {\r\nstruct resource *r = &pdev->resource[i];\r\nif (r->flags != IORESOURCE_MEM)\r\ncontinue;\r\nif (uiomem >= &uioinfo->mem[MAX_UIO_MAPS]) {\r\ndev_warn(&pdev->dev, "device has more than "\r\n__stringify(MAX_UIO_MAPS)\r\n" I/O memory resources.\n");\r\nbreak;\r\n}\r\nuiomem->memtype = UIO_MEM_PHYS;\r\nuiomem->addr = r->start;\r\nuiomem->size = resource_size(r);\r\n++uiomem;\r\n}\r\nwhile (uiomem < &uioinfo->mem[MAX_UIO_MAPS]) {\r\nuiomem->size = 0;\r\n++uiomem;\r\n}\r\npdata->uioinfo->priv = pdata;\r\nret = uio_register_device(&pdev->dev, pdata->uioinfo);\r\nif (ret) {\r\nkfree(pdata);\r\nerr_alloc_pdata:\r\nerr_uioinfo:\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, pdata);\r\nreturn 0;\r\n}\r\nstatic int uio_pdrv_remove(struct platform_device *pdev)\r\n{\r\nstruct uio_platdata *pdata = platform_get_drvdata(pdev);\r\nuio_unregister_device(pdata->uioinfo);\r\nkfree(pdata);\r\nreturn 0;\r\n}
