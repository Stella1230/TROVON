static inline void omap_i2c_write_reg(struct omap_i2c_dev *i2c_dev,\r\nint reg, u16 val)\r\n{\r\n__raw_writew(val, i2c_dev->base +\r\n(i2c_dev->regs[reg] << i2c_dev->reg_shift));\r\n}\r\nstatic inline u16 omap_i2c_read_reg(struct omap_i2c_dev *i2c_dev, int reg)\r\n{\r\nreturn __raw_readw(i2c_dev->base +\r\n(i2c_dev->regs[reg] << i2c_dev->reg_shift));\r\n}\r\nstatic void omap_i2c_unidle(struct omap_i2c_dev *dev)\r\n{\r\nif (dev->flags & OMAP_I2C_FLAG_RESET_REGS_POSTIDLE) {\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG, 0);\r\nomap_i2c_write_reg(dev, OMAP_I2C_PSC_REG, dev->pscstate);\r\nomap_i2c_write_reg(dev, OMAP_I2C_SCLL_REG, dev->scllstate);\r\nomap_i2c_write_reg(dev, OMAP_I2C_SCLH_REG, dev->sclhstate);\r\nomap_i2c_write_reg(dev, OMAP_I2C_BUF_REG, dev->bufstate);\r\nomap_i2c_write_reg(dev, OMAP_I2C_SYSC_REG, dev->syscstate);\r\nomap_i2c_write_reg(dev, OMAP_I2C_WE_REG, dev->westate);\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG, OMAP_I2C_CON_EN);\r\n}\r\nif (dev->iestate)\r\nomap_i2c_write_reg(dev, OMAP_I2C_IE_REG, dev->iestate);\r\n}\r\nstatic void omap_i2c_idle(struct omap_i2c_dev *dev)\r\n{\r\nu16 iv;\r\ndev->iestate = omap_i2c_read_reg(dev, OMAP_I2C_IE_REG);\r\nif (dev->dtrev == OMAP_I2C_IP_VERSION_2)\r\nomap_i2c_write_reg(dev, OMAP_I2C_IP_V2_IRQENABLE_CLR, 1);\r\nelse\r\nomap_i2c_write_reg(dev, OMAP_I2C_IE_REG, 0);\r\nif (dev->rev < OMAP_I2C_OMAP1_REV_2) {\r\niv = omap_i2c_read_reg(dev, OMAP_I2C_IV_REG);\r\n} else {\r\nomap_i2c_write_reg(dev, OMAP_I2C_STAT_REG, dev->iestate);\r\nomap_i2c_read_reg(dev, OMAP_I2C_STAT_REG);\r\n}\r\n}\r\nstatic int omap_i2c_init(struct omap_i2c_dev *dev)\r\n{\r\nu16 psc = 0, scll = 0, sclh = 0, buf = 0;\r\nu16 fsscll = 0, fssclh = 0, hsscll = 0, hssclh = 0;\r\nunsigned long fclk_rate = 12000000;\r\nunsigned long timeout;\r\nunsigned long internal_clk = 0;\r\nstruct clk *fclk;\r\nif (dev->rev >= OMAP_I2C_OMAP1_REV_2) {\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG,\r\nomap_i2c_read_reg(dev, OMAP_I2C_CON_REG) &\r\n~(OMAP_I2C_CON_EN));\r\nomap_i2c_write_reg(dev, OMAP_I2C_SYSC_REG, SYSC_SOFTRESET_MASK);\r\ntimeout = jiffies + OMAP_I2C_TIMEOUT;\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG, OMAP_I2C_CON_EN);\r\nwhile (!(omap_i2c_read_reg(dev, OMAP_I2C_SYSS_REG) &\r\nSYSS_RESETDONE_MASK)) {\r\nif (time_after(jiffies, timeout)) {\r\ndev_warn(dev->dev, "timeout waiting "\r\n"for controller reset\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\n}\r\nif (dev->rev == OMAP_I2C_REV_ON_2430) {\r\nomap_i2c_write_reg(dev, OMAP_I2C_SYSC_REG,\r\nSYSC_AUTOIDLE_MASK);\r\n} else if (dev->rev >= OMAP_I2C_REV_ON_3430) {\r\ndev->syscstate = SYSC_AUTOIDLE_MASK;\r\ndev->syscstate |= SYSC_ENAWAKEUP_MASK;\r\ndev->syscstate |= (SYSC_IDLEMODE_SMART <<\r\n__ffs(SYSC_SIDLEMODE_MASK));\r\ndev->syscstate |= (SYSC_CLOCKACTIVITY_FCLK <<\r\n__ffs(SYSC_CLOCKACTIVITY_MASK));\r\nomap_i2c_write_reg(dev, OMAP_I2C_SYSC_REG,\r\ndev->syscstate);\r\ndev->westate = OMAP_I2C_WE_ALL;\r\nomap_i2c_write_reg(dev, OMAP_I2C_WE_REG,\r\ndev->westate);\r\n}\r\n}\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG, 0);\r\nif (dev->flags & OMAP_I2C_FLAG_ALWAYS_ARMXOR_CLK) {\r\nfclk = clk_get(dev->dev, "fck");\r\nfclk_rate = clk_get_rate(fclk);\r\nclk_put(fclk);\r\nif (fclk_rate > 12000000)\r\npsc = fclk_rate / 12000000;\r\n}\r\nif (!(dev->flags & OMAP_I2C_FLAG_SIMPLE_CLOCK)) {\r\nif (dev->speed > 400 ||\r\ndev->flags & OMAP_I2C_FLAG_FORCE_19200_INT_CLK)\r\ninternal_clk = 19200;\r\nelse if (dev->speed > 100)\r\ninternal_clk = 9600;\r\nelse\r\ninternal_clk = 4000;\r\nfclk = clk_get(dev->dev, "fck");\r\nfclk_rate = clk_get_rate(fclk) / 1000;\r\nclk_put(fclk);\r\npsc = fclk_rate / internal_clk;\r\npsc = psc - 1;\r\nif (dev->speed > 400) {\r\nunsigned long scl;\r\nscl = internal_clk / 400;\r\nfsscll = scl - (scl / 3) - 7;\r\nfssclh = (scl / 3) - 5;\r\nscl = fclk_rate / dev->speed;\r\nhsscll = scl - (scl / 3) - 7;\r\nhssclh = (scl / 3) - 5;\r\n} else if (dev->speed > 100) {\r\nunsigned long scl;\r\nscl = internal_clk / dev->speed;\r\nfsscll = scl - (scl / 3) - 7;\r\nfssclh = (scl / 3) - 5;\r\n} else {\r\nfsscll = internal_clk / (dev->speed * 2) - 7;\r\nfssclh = internal_clk / (dev->speed * 2) - 5;\r\n}\r\nscll = (hsscll << OMAP_I2C_SCLL_HSSCLL) | fsscll;\r\nsclh = (hssclh << OMAP_I2C_SCLH_HSSCLH) | fssclh;\r\n} else {\r\nfclk_rate /= (psc + 1) * 1000;\r\nif (psc > 2)\r\npsc = 2;\r\nscll = fclk_rate / (dev->speed * 2) - 7 + psc;\r\nsclh = fclk_rate / (dev->speed * 2) - 7 + psc;\r\n}\r\nomap_i2c_write_reg(dev, OMAP_I2C_PSC_REG, psc);\r\nomap_i2c_write_reg(dev, OMAP_I2C_SCLL_REG, scll);\r\nomap_i2c_write_reg(dev, OMAP_I2C_SCLH_REG, sclh);\r\nif (dev->fifo_size) {\r\nbuf = (dev->fifo_size - 1) << 8 | OMAP_I2C_BUF_RXFIF_CLR |\r\n(dev->fifo_size - 1) | OMAP_I2C_BUF_TXFIF_CLR;\r\nomap_i2c_write_reg(dev, OMAP_I2C_BUF_REG, buf);\r\n}\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG, OMAP_I2C_CON_EN);\r\ndev->errata = 0;\r\nif (dev->flags & OMAP_I2C_FLAG_APPLY_ERRATA_I207)\r\ndev->errata |= I2C_OMAP_ERRATA_I207;\r\ndev->iestate = (OMAP_I2C_IE_XRDY | OMAP_I2C_IE_RRDY |\r\nOMAP_I2C_IE_ARDY | OMAP_I2C_IE_NACK |\r\nOMAP_I2C_IE_AL) | ((dev->fifo_size) ?\r\n(OMAP_I2C_IE_RDR | OMAP_I2C_IE_XDR) : 0);\r\nomap_i2c_write_reg(dev, OMAP_I2C_IE_REG, dev->iestate);\r\nif (dev->flags & OMAP_I2C_FLAG_RESET_REGS_POSTIDLE) {\r\ndev->pscstate = psc;\r\ndev->scllstate = scll;\r\ndev->sclhstate = sclh;\r\ndev->bufstate = buf;\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_i2c_wait_for_bb(struct omap_i2c_dev *dev)\r\n{\r\nunsigned long timeout;\r\ntimeout = jiffies + OMAP_I2C_TIMEOUT;\r\nwhile (omap_i2c_read_reg(dev, OMAP_I2C_STAT_REG) & OMAP_I2C_STAT_BB) {\r\nif (time_after(jiffies, timeout)) {\r\ndev_warn(dev->dev, "timeout waiting for bus ready\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_i2c_xfer_msg(struct i2c_adapter *adap,\r\nstruct i2c_msg *msg, int stop)\r\n{\r\nstruct omap_i2c_dev *dev = i2c_get_adapdata(adap);\r\nint r;\r\nu16 w;\r\ndev_dbg(dev->dev, "addr: 0x%04x, len: %d, flags: 0x%x, stop: %d\n",\r\nmsg->addr, msg->len, msg->flags, stop);\r\nif (msg->len == 0)\r\nreturn -EINVAL;\r\nomap_i2c_write_reg(dev, OMAP_I2C_SA_REG, msg->addr);\r\ndev->buf = msg->buf;\r\ndev->buf_len = msg->len;\r\nomap_i2c_write_reg(dev, OMAP_I2C_CNT_REG, dev->buf_len);\r\nw = omap_i2c_read_reg(dev, OMAP_I2C_BUF_REG);\r\nw |= OMAP_I2C_BUF_RXFIF_CLR | OMAP_I2C_BUF_TXFIF_CLR;\r\nomap_i2c_write_reg(dev, OMAP_I2C_BUF_REG, w);\r\ninit_completion(&dev->cmd_complete);\r\ndev->cmd_err = 0;\r\nw = OMAP_I2C_CON_EN | OMAP_I2C_CON_MST | OMAP_I2C_CON_STT;\r\nif (dev->speed > 400)\r\nw |= OMAP_I2C_CON_OPMODE_HS;\r\nif (msg->flags & I2C_M_TEN)\r\nw |= OMAP_I2C_CON_XA;\r\nif (!(msg->flags & I2C_M_RD))\r\nw |= OMAP_I2C_CON_TRX;\r\nif (!dev->b_hw && stop)\r\nw |= OMAP_I2C_CON_STP;\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG, w);\r\nif (dev->b_hw && stop) {\r\nunsigned long delay = jiffies + OMAP_I2C_TIMEOUT;\r\nu16 con = omap_i2c_read_reg(dev, OMAP_I2C_CON_REG);\r\nwhile (con & OMAP_I2C_CON_STT) {\r\ncon = omap_i2c_read_reg(dev, OMAP_I2C_CON_REG);\r\nif (time_after(jiffies, delay)) {\r\ndev_err(dev->dev, "controller timed out "\r\n"waiting for start condition to finish\n");\r\nreturn -ETIMEDOUT;\r\n}\r\ncpu_relax();\r\n}\r\nw |= OMAP_I2C_CON_STP;\r\nw &= ~OMAP_I2C_CON_STT;\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG, w);\r\n}\r\nr = wait_for_completion_timeout(&dev->cmd_complete,\r\nOMAP_I2C_TIMEOUT);\r\ndev->buf_len = 0;\r\nif (r < 0)\r\nreturn r;\r\nif (r == 0) {\r\ndev_err(dev->dev, "controller timed out\n");\r\nomap_i2c_init(dev);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (likely(!dev->cmd_err))\r\nreturn 0;\r\nif (dev->cmd_err & (OMAP_I2C_STAT_AL | OMAP_I2C_STAT_ROVR |\r\nOMAP_I2C_STAT_XUDF)) {\r\nomap_i2c_init(dev);\r\nreturn -EIO;\r\n}\r\nif (dev->cmd_err & OMAP_I2C_STAT_NACK) {\r\nif (msg->flags & I2C_M_IGNORE_NAK)\r\nreturn 0;\r\nif (stop) {\r\nw = omap_i2c_read_reg(dev, OMAP_I2C_CON_REG);\r\nw |= OMAP_I2C_CON_STP;\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG, w);\r\n}\r\nreturn -EREMOTEIO;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int\r\nomap_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)\r\n{\r\nstruct omap_i2c_dev *dev = i2c_get_adapdata(adap);\r\nint i;\r\nint r;\r\npm_runtime_get_sync(dev->dev);\r\nr = omap_i2c_wait_for_bb(dev);\r\nif (r < 0)\r\ngoto out;\r\nif (dev->set_mpu_wkup_lat != NULL)\r\ndev->set_mpu_wkup_lat(dev->dev, dev->latency);\r\nfor (i = 0; i < num; i++) {\r\nr = omap_i2c_xfer_msg(adap, &msgs[i], (i == (num - 1)));\r\nif (r != 0)\r\nbreak;\r\n}\r\nif (dev->set_mpu_wkup_lat != NULL)\r\ndev->set_mpu_wkup_lat(dev->dev, -1);\r\nif (r == 0)\r\nr = num;\r\nomap_i2c_wait_for_bb(dev);\r\nout:\r\npm_runtime_put(dev->dev);\r\nreturn r;\r\n}\r\nstatic u32\r\nomap_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK);\r\n}\r\nstatic inline void\r\nomap_i2c_complete_cmd(struct omap_i2c_dev *dev, u16 err)\r\n{\r\ndev->cmd_err |= err;\r\ncomplete(&dev->cmd_complete);\r\n}\r\nstatic inline void\r\nomap_i2c_ack_stat(struct omap_i2c_dev *dev, u16 stat)\r\n{\r\nomap_i2c_write_reg(dev, OMAP_I2C_STAT_REG, stat);\r\n}\r\nstatic inline void i2c_omap_errata_i207(struct omap_i2c_dev *dev, u16 stat)\r\n{\r\nif (stat & OMAP_I2C_STAT_RDR) {\r\nomap_i2c_ack_stat(dev, OMAP_I2C_STAT_RDR);\r\nif (!(omap_i2c_read_reg(dev, OMAP_I2C_STAT_REG)\r\n& OMAP_I2C_STAT_BB)) {\r\nif (omap_i2c_read_reg(dev, OMAP_I2C_STAT_REG)\r\n& OMAP_I2C_STAT_RDR) {\r\nomap_i2c_ack_stat(dev, OMAP_I2C_STAT_RDR);\r\ndev_dbg(dev->dev, "RDR when bus is busy.\n");\r\n}\r\n}\r\n}\r\n}\r\nstatic irqreturn_t\r\nomap_i2c_omap1_isr(int this_irq, void *dev_id)\r\n{\r\nstruct omap_i2c_dev *dev = dev_id;\r\nu16 iv, w;\r\nif (pm_runtime_suspended(dev->dev))\r\nreturn IRQ_NONE;\r\niv = omap_i2c_read_reg(dev, OMAP_I2C_IV_REG);\r\nswitch (iv) {\r\ncase 0x00:\r\nbreak;\r\ncase 0x01:\r\ndev_err(dev->dev, "Arbitration lost\n");\r\nomap_i2c_complete_cmd(dev, OMAP_I2C_STAT_AL);\r\nbreak;\r\ncase 0x02:\r\nomap_i2c_complete_cmd(dev, OMAP_I2C_STAT_NACK);\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG, OMAP_I2C_CON_STP);\r\nbreak;\r\ncase 0x03:\r\nomap_i2c_complete_cmd(dev, 0);\r\nbreak;\r\ncase 0x04:\r\nif (dev->buf_len) {\r\nw = omap_i2c_read_reg(dev, OMAP_I2C_DATA_REG);\r\n*dev->buf++ = w;\r\ndev->buf_len--;\r\nif (dev->buf_len) {\r\n*dev->buf++ = w >> 8;\r\ndev->buf_len--;\r\n}\r\n} else\r\ndev_err(dev->dev, "RRDY IRQ while no data requested\n");\r\nbreak;\r\ncase 0x05:\r\nif (dev->buf_len) {\r\nw = *dev->buf++;\r\ndev->buf_len--;\r\nif (dev->buf_len) {\r\nw |= *dev->buf++ << 8;\r\ndev->buf_len--;\r\n}\r\nomap_i2c_write_reg(dev, OMAP_I2C_DATA_REG, w);\r\n} else\r\ndev_err(dev->dev, "XRDY IRQ while no data to send\n");\r\nbreak;\r\ndefault:\r\nreturn IRQ_NONE;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int errata_omap3_1p153(struct omap_i2c_dev *dev, u16 *stat, int *err)\r\n{\r\nunsigned long timeout = 10000;\r\nwhile (--timeout && !(*stat & OMAP_I2C_STAT_XUDF)) {\r\nif (*stat & (OMAP_I2C_STAT_NACK | OMAP_I2C_STAT_AL)) {\r\nomap_i2c_ack_stat(dev, *stat & (OMAP_I2C_STAT_XRDY |\r\nOMAP_I2C_STAT_XDR));\r\n*err |= OMAP_I2C_STAT_XUDF;\r\nreturn -ETIMEDOUT;\r\n}\r\ncpu_relax();\r\n*stat = omap_i2c_read_reg(dev, OMAP_I2C_STAT_REG);\r\n}\r\nif (!timeout) {\r\ndev_err(dev->dev, "timeout waiting on XUDF bit\n");\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t\r\nomap_i2c_isr(int this_irq, void *dev_id)\r\n{\r\nstruct omap_i2c_dev *dev = dev_id;\r\nu16 bits;\r\nu16 stat, w;\r\nint err, count = 0;\r\nif (pm_runtime_suspended(dev->dev))\r\nreturn IRQ_NONE;\r\nbits = omap_i2c_read_reg(dev, OMAP_I2C_IE_REG);\r\nwhile ((stat = (omap_i2c_read_reg(dev, OMAP_I2C_STAT_REG))) & bits) {\r\ndev_dbg(dev->dev, "IRQ (ISR = 0x%04x)\n", stat);\r\nif (count++ == 100) {\r\ndev_warn(dev->dev, "Too much work in one IRQ\n");\r\nbreak;\r\n}\r\nerr = 0;\r\ncomplete:\r\nomap_i2c_write_reg(dev, OMAP_I2C_STAT_REG, stat &\r\n~(OMAP_I2C_STAT_RRDY | OMAP_I2C_STAT_RDR |\r\nOMAP_I2C_STAT_XRDY | OMAP_I2C_STAT_XDR));\r\nif (stat & OMAP_I2C_STAT_NACK)\r\nerr |= OMAP_I2C_STAT_NACK;\r\nif (stat & OMAP_I2C_STAT_AL) {\r\ndev_err(dev->dev, "Arbitration lost\n");\r\nerr |= OMAP_I2C_STAT_AL;\r\n}\r\nif (stat & (OMAP_I2C_STAT_ARDY | OMAP_I2C_STAT_NACK |\r\nOMAP_I2C_STAT_AL)) {\r\nomap_i2c_ack_stat(dev, stat &\r\n(OMAP_I2C_STAT_RRDY | OMAP_I2C_STAT_RDR |\r\nOMAP_I2C_STAT_XRDY | OMAP_I2C_STAT_XDR |\r\nOMAP_I2C_STAT_ARDY));\r\nomap_i2c_complete_cmd(dev, err);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (stat & (OMAP_I2C_STAT_RRDY | OMAP_I2C_STAT_RDR)) {\r\nu8 num_bytes = 1;\r\nif (dev->errata & I2C_OMAP_ERRATA_I207)\r\ni2c_omap_errata_i207(dev, stat);\r\nif (dev->fifo_size) {\r\nif (stat & OMAP_I2C_STAT_RRDY)\r\nnum_bytes = dev->fifo_size;\r\nelse\r\nnum_bytes = (omap_i2c_read_reg(dev,\r\nOMAP_I2C_BUFSTAT_REG)\r\n>> 8) & 0x3F;\r\n}\r\nwhile (num_bytes) {\r\nnum_bytes--;\r\nw = omap_i2c_read_reg(dev, OMAP_I2C_DATA_REG);\r\nif (dev->buf_len) {\r\n*dev->buf++ = w;\r\ndev->buf_len--;\r\nif (dev->flags &\r\nOMAP_I2C_FLAG_16BIT_DATA_REG) {\r\nif (dev->buf_len) {\r\n*dev->buf++ = w >> 8;\r\ndev->buf_len--;\r\n}\r\n}\r\n} else {\r\nif (stat & OMAP_I2C_STAT_RRDY)\r\ndev_err(dev->dev,\r\n"RRDY IRQ while no data"\r\n" requested\n");\r\nif (stat & OMAP_I2C_STAT_RDR)\r\ndev_err(dev->dev,\r\n"RDR IRQ while no data"\r\n" requested\n");\r\nbreak;\r\n}\r\n}\r\nomap_i2c_ack_stat(dev,\r\nstat & (OMAP_I2C_STAT_RRDY | OMAP_I2C_STAT_RDR));\r\ncontinue;\r\n}\r\nif (stat & (OMAP_I2C_STAT_XRDY | OMAP_I2C_STAT_XDR)) {\r\nu8 num_bytes = 1;\r\nif (dev->fifo_size) {\r\nif (stat & OMAP_I2C_STAT_XRDY)\r\nnum_bytes = dev->fifo_size;\r\nelse\r\nnum_bytes = omap_i2c_read_reg(dev,\r\nOMAP_I2C_BUFSTAT_REG)\r\n& 0x3F;\r\n}\r\nwhile (num_bytes) {\r\nnum_bytes--;\r\nw = 0;\r\nif (dev->buf_len) {\r\nw = *dev->buf++;\r\ndev->buf_len--;\r\nif (dev->flags &\r\nOMAP_I2C_FLAG_16BIT_DATA_REG) {\r\nif (dev->buf_len) {\r\nw |= *dev->buf++ << 8;\r\ndev->buf_len--;\r\n}\r\n}\r\n} else {\r\nif (stat & OMAP_I2C_STAT_XRDY)\r\ndev_err(dev->dev,\r\n"XRDY IRQ while no "\r\n"data to send\n");\r\nif (stat & OMAP_I2C_STAT_XDR)\r\ndev_err(dev->dev,\r\n"XDR IRQ while no "\r\n"data to send\n");\r\nbreak;\r\n}\r\nif ((dev->errata & I2C_OMAP3_1P153) &&\r\nerrata_omap3_1p153(dev, &stat, &err))\r\ngoto complete;\r\nomap_i2c_write_reg(dev, OMAP_I2C_DATA_REG, w);\r\n}\r\nomap_i2c_ack_stat(dev,\r\nstat & (OMAP_I2C_STAT_XRDY | OMAP_I2C_STAT_XDR));\r\ncontinue;\r\n}\r\nif (stat & OMAP_I2C_STAT_ROVR) {\r\ndev_err(dev->dev, "Receive overrun\n");\r\ndev->cmd_err |= OMAP_I2C_STAT_ROVR;\r\n}\r\nif (stat & OMAP_I2C_STAT_XUDF) {\r\ndev_err(dev->dev, "Transmit underflow\n");\r\ndev->cmd_err |= OMAP_I2C_STAT_XUDF;\r\n}\r\n}\r\nreturn count ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic int __devinit\r\nomap_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_i2c_dev *dev;\r\nstruct i2c_adapter *adap;\r\nstruct resource *mem, *irq, *ioarea;\r\nstruct omap_i2c_bus_platform_data *pdata = pdev->dev.platform_data;\r\nstruct device_node *node = pdev->dev.of_node;\r\nconst struct of_device_id *match;\r\nirq_handler_t isr;\r\nint r;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(&pdev->dev, "no mem resource?\n");\r\nreturn -ENODEV;\r\n}\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!irq) {\r\ndev_err(&pdev->dev, "no irq resource?\n");\r\nreturn -ENODEV;\r\n}\r\nioarea = request_mem_region(mem->start, resource_size(mem),\r\npdev->name);\r\nif (!ioarea) {\r\ndev_err(&pdev->dev, "I2C region already claimed\n");\r\nreturn -EBUSY;\r\n}\r\ndev = kzalloc(sizeof(struct omap_i2c_dev), GFP_KERNEL);\r\nif (!dev) {\r\nr = -ENOMEM;\r\ngoto err_release_region;\r\n}\r\nmatch = of_match_device(of_match_ptr(omap_i2c_of_match), &pdev->dev);\r\nif (match) {\r\nu32 freq = 100000;\r\npdata = match->data;\r\ndev->dtrev = pdata->rev;\r\ndev->flags = pdata->flags;\r\nof_property_read_u32(node, "clock-frequency", &freq);\r\ndev->speed = freq / 1000;\r\n} else if (pdata != NULL) {\r\ndev->speed = pdata->clkrate;\r\ndev->flags = pdata->flags;\r\ndev->set_mpu_wkup_lat = pdata->set_mpu_wkup_lat;\r\ndev->dtrev = pdata->rev;\r\n}\r\ndev->dev = &pdev->dev;\r\ndev->irq = irq->start;\r\ndev->base = ioremap(mem->start, resource_size(mem));\r\nif (!dev->base) {\r\nr = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nplatform_set_drvdata(pdev, dev);\r\ndev->reg_shift = (dev->flags >> OMAP_I2C_FLAG_BUS_SHIFT__SHIFT) & 3;\r\nif (dev->dtrev == OMAP_I2C_IP_VERSION_2)\r\ndev->regs = (u8 *)reg_map_ip_v2;\r\nelse\r\ndev->regs = (u8 *)reg_map_ip_v1;\r\npm_runtime_enable(dev->dev);\r\npm_runtime_get_sync(dev->dev);\r\ndev->rev = omap_i2c_read_reg(dev, OMAP_I2C_REV_REG) & 0xff;\r\nif (dev->rev <= OMAP_I2C_REV_ON_3430)\r\ndev->errata |= I2C_OMAP3_1P153;\r\nif (!(dev->flags & OMAP_I2C_FLAG_NO_FIFO)) {\r\nu16 s;\r\ns = (omap_i2c_read_reg(dev, OMAP_I2C_BUFSTAT_REG) >> 14) & 0x3;\r\ndev->fifo_size = 0x8 << s;\r\ndev->fifo_size = (dev->fifo_size / 2);\r\nif (dev->rev >= OMAP_I2C_REV_ON_3530_4430)\r\ndev->b_hw = 0;\r\nelse\r\ndev->b_hw = 1;\r\nif (dev->set_mpu_wkup_lat != NULL)\r\ndev->latency = (1000000 * dev->fifo_size) /\r\n(1000 * dev->speed / 8);\r\n}\r\nomap_i2c_init(dev);\r\nisr = (dev->rev < OMAP_I2C_OMAP1_REV_2) ? omap_i2c_omap1_isr :\r\nomap_i2c_isr;\r\nr = request_irq(dev->irq, isr, 0, pdev->name, dev);\r\nif (r) {\r\ndev_err(dev->dev, "failure requesting irq %i\n", dev->irq);\r\ngoto err_unuse_clocks;\r\n}\r\ndev_info(dev->dev, "bus %d rev%d.%d.%d at %d kHz\n", pdev->id,\r\ndev->dtrev, dev->rev >> 4, dev->rev & 0xf, dev->speed);\r\npm_runtime_put(dev->dev);\r\nadap = &dev->adapter;\r\ni2c_set_adapdata(adap, dev);\r\nadap->owner = THIS_MODULE;\r\nadap->class = I2C_CLASS_HWMON;\r\nstrlcpy(adap->name, "OMAP I2C adapter", sizeof(adap->name));\r\nadap->algo = &omap_i2c_algo;\r\nadap->dev.parent = &pdev->dev;\r\nadap->dev.of_node = pdev->dev.of_node;\r\nadap->nr = pdev->id;\r\nr = i2c_add_numbered_adapter(adap);\r\nif (r) {\r\ndev_err(dev->dev, "failure adding adapter\n");\r\ngoto err_free_irq;\r\n}\r\nof_i2c_register_devices(adap);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(dev->irq, dev);\r\nerr_unuse_clocks:\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG, 0);\r\npm_runtime_put(dev->dev);\r\niounmap(dev->base);\r\nerr_free_mem:\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(dev);\r\nerr_release_region:\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nreturn r;\r\n}\r\nstatic int\r\nomap_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_i2c_dev *dev = platform_get_drvdata(pdev);\r\nstruct resource *mem;\r\nplatform_set_drvdata(pdev, NULL);\r\nfree_irq(dev->irq, dev);\r\ni2c_del_adapter(&dev->adapter);\r\nomap_i2c_write_reg(dev, OMAP_I2C_CON_REG, 0);\r\niounmap(dev->base);\r\nkfree(dev);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nreturn 0;\r\n}\r\nstatic int omap_i2c_runtime_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct omap_i2c_dev *_dev = platform_get_drvdata(pdev);\r\nomap_i2c_idle(_dev);\r\nreturn 0;\r\n}\r\nstatic int omap_i2c_runtime_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct omap_i2c_dev *_dev = platform_get_drvdata(pdev);\r\nomap_i2c_unidle(_dev);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nomap_i2c_init_driver(void)\r\n{\r\nreturn platform_driver_register(&omap_i2c_driver);\r\n}\r\nstatic void __exit omap_i2c_exit_driver(void)\r\n{\r\nplatform_driver_unregister(&omap_i2c_driver);\r\n}
