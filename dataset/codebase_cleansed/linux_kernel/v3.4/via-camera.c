static struct via_format *via_find_format(u32 pixelformat)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < N_VIA_FMTS; i++)\r\nif (via_formats[i].pixelformat == pixelformat)\r\nreturn via_formats + i;\r\nreturn via_formats;\r\n}\r\nstatic int via_sensor_power_setup(struct via_camera *cam)\r\n{\r\nint ret;\r\ncam->power_gpio = viafb_gpio_lookup("VGPIO3");\r\ncam->reset_gpio = viafb_gpio_lookup("VGPIO2");\r\nif (cam->power_gpio < 0 || cam->reset_gpio < 0) {\r\ndev_err(&cam->platdev->dev, "Unable to find GPIO lines\n");\r\nreturn -EINVAL;\r\n}\r\nret = gpio_request(cam->power_gpio, "viafb-camera");\r\nif (ret) {\r\ndev_err(&cam->platdev->dev, "Unable to request power GPIO\n");\r\nreturn ret;\r\n}\r\nret = gpio_request(cam->reset_gpio, "viafb-camera");\r\nif (ret) {\r\ndev_err(&cam->platdev->dev, "Unable to request reset GPIO\n");\r\ngpio_free(cam->power_gpio);\r\nreturn ret;\r\n}\r\ngpio_direction_output(cam->power_gpio, 0);\r\ngpio_direction_output(cam->reset_gpio, 0);\r\nreturn 0;\r\n}\r\nstatic void via_sensor_power_up(struct via_camera *cam)\r\n{\r\ngpio_set_value(cam->power_gpio, 1);\r\ngpio_set_value(cam->reset_gpio, 0);\r\nmsleep(20);\r\ngpio_set_value(cam->reset_gpio, 1);\r\nmsleep(20);\r\n}\r\nstatic void via_sensor_power_down(struct via_camera *cam)\r\n{\r\ngpio_set_value(cam->power_gpio, 0);\r\ngpio_set_value(cam->reset_gpio, 0);\r\n}\r\nstatic void via_sensor_power_release(struct via_camera *cam)\r\n{\r\nvia_sensor_power_down(cam);\r\ngpio_free(cam->power_gpio);\r\ngpio_free(cam->reset_gpio);\r\n}\r\nstatic int viacam_set_flip(struct via_camera *cam)\r\n{\r\nstruct v4l2_control ctrl;\r\nmemset(&ctrl, 0, sizeof(ctrl));\r\nctrl.id = V4L2_CID_VFLIP;\r\nctrl.value = flip_image;\r\nreturn sensor_call(cam, core, s_ctrl, &ctrl);\r\n}\r\nstatic int viacam_configure_sensor(struct via_camera *cam)\r\n{\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nint ret;\r\nv4l2_fill_mbus_format(&mbus_fmt, &cam->sensor_format, cam->mbus_code);\r\nret = sensor_call(cam, core, init, 0);\r\nif (ret == 0)\r\nret = sensor_call(cam, video, s_mbus_fmt, &mbus_fmt);\r\nif (ret == 0)\r\nret = viacam_set_flip(cam);\r\nreturn ret;\r\n}\r\nstatic inline void viacam_write_reg(struct via_camera *cam,\r\nint reg, int value)\r\n{\r\niowrite32(value, cam->mmio + reg);\r\n}\r\nstatic inline int viacam_read_reg(struct via_camera *cam, int reg)\r\n{\r\nreturn ioread32(cam->mmio + reg);\r\n}\r\nstatic inline void viacam_write_reg_mask(struct via_camera *cam,\r\nint reg, int value, int mask)\r\n{\r\nint tmp = viacam_read_reg(cam, reg);\r\ntmp = (tmp & ~mask) | (value & mask);\r\nviacam_write_reg(cam, reg, tmp);\r\n}\r\nstatic irqreturn_t viacam_quick_irq(int irq, void *data)\r\n{\r\nstruct via_camera *cam = data;\r\nirqreturn_t ret = IRQ_NONE;\r\nint icv;\r\nspin_lock(&cam->viadev->reg_lock);\r\nicv = viacam_read_reg(cam, VCR_INTCTRL);\r\nif (icv & VCR_IC_EAV) {\r\nicv |= VCR_IC_EAV|VCR_IC_EVBI|VCR_IC_FFULL;\r\nviacam_write_reg(cam, VCR_INTCTRL, icv);\r\nret = IRQ_WAKE_THREAD;\r\n}\r\nspin_unlock(&cam->viadev->reg_lock);\r\nreturn ret;\r\n}\r\nstatic struct videobuf_buffer *viacam_next_buffer(struct via_camera *cam)\r\n{\r\nunsigned long flags;\r\nstruct videobuf_buffer *buf = NULL;\r\nspin_lock_irqsave(&cam->viadev->reg_lock, flags);\r\nif (cam->opstate != S_RUNNING)\r\ngoto out;\r\nif (list_empty(&cam->buffer_queue))\r\ngoto out;\r\nbuf = list_entry(cam->buffer_queue.next, struct videobuf_buffer, queue);\r\nif (!waitqueue_active(&buf->done)) {\r\nbuf = NULL;\r\ngoto out;\r\n}\r\nlist_del(&buf->queue);\r\nbuf->state = VIDEOBUF_ACTIVE;\r\nout:\r\nspin_unlock_irqrestore(&cam->viadev->reg_lock, flags);\r\nreturn buf;\r\n}\r\nstatic irqreturn_t viacam_irq(int irq, void *data)\r\n{\r\nint bufn;\r\nstruct videobuf_buffer *vb;\r\nstruct via_camera *cam = data;\r\nstruct videobuf_dmabuf *vdma;\r\nvb = viacam_next_buffer(cam);\r\nif (vb == NULL)\r\ngoto done;\r\nbufn = (viacam_read_reg(cam, VCR_INTCTRL) & VCR_IC_ACTBUF) >> 3;\r\nbufn -= 1;\r\nif (bufn < 0)\r\nbufn = cam->n_cap_bufs - 1;\r\nvdma = videobuf_to_dma(vb);\r\nviafb_dma_copy_out_sg(cam->cb_offsets[bufn], vdma->sglist, vdma->sglen);\r\nvb->state = VIDEOBUF_DONE;\r\nvb->size = cam->user_format.sizeimage;\r\nwake_up(&vb->done);\r\ndone:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void viacam_int_enable(struct via_camera *cam)\r\n{\r\nviacam_write_reg(cam, VCR_INTCTRL,\r\nVCR_IC_INTEN|VCR_IC_EAV|VCR_IC_EVBI|VCR_IC_FFULL);\r\nviafb_irq_enable(VDE_I_C0AVEN);\r\n}\r\nstatic void viacam_int_disable(struct via_camera *cam)\r\n{\r\nviafb_irq_disable(VDE_I_C0AVEN);\r\nviacam_write_reg(cam, VCR_INTCTRL, 0);\r\n}\r\nstatic int viacam_ctlr_cbufs(struct via_camera *cam)\r\n{\r\nint nbuf = cam->viadev->camera_fbmem_size/cam->sensor_format.sizeimage;\r\nint i;\r\nunsigned int offset;\r\nif (nbuf >= 3) {\r\ncam->n_cap_bufs = 3;\r\nviacam_write_reg_mask(cam, VCR_CAPINTC, VCR_CI_3BUFS,\r\nVCR_CI_3BUFS);\r\n} else if (nbuf == 2) {\r\ncam->n_cap_bufs = 2;\r\nviacam_write_reg_mask(cam, VCR_CAPINTC, 0, VCR_CI_3BUFS);\r\n} else {\r\ncam_warn(cam, "Insufficient frame buffer memory\n");\r\nreturn -ENOMEM;\r\n}\r\noffset = cam->fb_offset;\r\nfor (i = 0; i < cam->n_cap_bufs; i++) {\r\ncam->cb_offsets[i] = offset;\r\ncam->cb_addrs[i] = cam->fbmem + offset;\r\nviacam_write_reg(cam, VCR_VBUF1 + i*4, offset & VCR_VBUF_MASK);\r\noffset += cam->sensor_format.sizeimage;\r\n}\r\nreturn 0;\r\n}\r\nstatic void viacam_set_scale(struct via_camera *cam)\r\n{\r\nunsigned int avscale;\r\nint sf;\r\nif (cam->user_format.width == VGA_WIDTH)\r\navscale = 0;\r\nelse {\r\nsf = (cam->user_format.width*2048)/VGA_WIDTH;\r\navscale = VCR_AVS_HEN | sf;\r\n}\r\nif (cam->user_format.height < VGA_HEIGHT) {\r\nsf = (1024*cam->user_format.height)/VGA_HEIGHT;\r\navscale |= VCR_AVS_VEN | (sf << 16);\r\n}\r\nviacam_write_reg(cam, VCR_AVSCALE, avscale);\r\n}\r\nstatic void viacam_ctlr_image(struct via_camera *cam)\r\n{\r\nint cicreg;\r\nviacam_write_reg(cam, VCR_CAPINTC, ~(VCR_CI_ENABLE|VCR_CI_CLKEN));\r\nviacam_write_reg(cam, VCR_HORRANGE, 0x06200120);\r\nviacam_write_reg(cam, VCR_VERTRANGE, 0x01de0000);\r\nviacam_set_scale(cam);\r\nviacam_write_reg(cam, VCR_MAXDATA,\r\n(cam->sensor_format.height << 16) |\r\n(cam->sensor_format.bytesperline >> 3));\r\nviacam_write_reg(cam, VCR_MAXVBI, 0);\r\nviacam_write_reg(cam, VCR_VSTRIDE,\r\ncam->user_format.bytesperline & VCR_VS_STRIDE);\r\ncicreg = VCR_CI_CLKEN |\r\n0x08000000 |\r\nVCR_CI_FLDINV |\r\nVCR_CI_VREFINV |\r\nVCR_CI_DIBOTH |\r\nVCR_CI_CCIR601_8;\r\nif (cam->n_cap_bufs == 3)\r\ncicreg |= VCR_CI_3BUFS;\r\nif (cam->user_format.pixelformat == V4L2_PIX_FMT_YUYV)\r\ncicreg |= VCR_CI_YUYV;\r\nelse\r\ncicreg |= VCR_CI_UYVY;\r\nviacam_write_reg(cam, VCR_CAPINTC, cicreg);\r\n}\r\nstatic int viacam_config_controller(struct via_camera *cam)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cam->viadev->reg_lock, flags);\r\nret = viacam_ctlr_cbufs(cam);\r\nif (!ret)\r\nviacam_ctlr_image(cam);\r\nspin_unlock_irqrestore(&cam->viadev->reg_lock, flags);\r\nclear_bit(CF_CONFIG_NEEDED, &cam->flags);\r\nreturn ret;\r\n}\r\nstatic void viacam_start_engine(struct via_camera *cam)\r\n{\r\nspin_lock_irq(&cam->viadev->reg_lock);\r\ncam->next_buf = 0;\r\nviacam_write_reg_mask(cam, VCR_CAPINTC, VCR_CI_ENABLE, VCR_CI_ENABLE);\r\nviacam_int_enable(cam);\r\n(void) viacam_read_reg(cam, VCR_CAPINTC);\r\ncam->opstate = S_RUNNING;\r\nspin_unlock_irq(&cam->viadev->reg_lock);\r\n}\r\nstatic void viacam_stop_engine(struct via_camera *cam)\r\n{\r\nspin_lock_irq(&cam->viadev->reg_lock);\r\nviacam_int_disable(cam);\r\nviacam_write_reg_mask(cam, VCR_CAPINTC, 0, VCR_CI_ENABLE);\r\n(void) viacam_read_reg(cam, VCR_CAPINTC);\r\ncam->opstate = S_IDLE;\r\nspin_unlock_irq(&cam->viadev->reg_lock);\r\n}\r\nstatic int viacam_vb_buf_setup(struct videobuf_queue *q,\r\nunsigned int *count, unsigned int *size)\r\n{\r\nstruct via_camera *cam = q->priv_data;\r\n*size = cam->user_format.sizeimage;\r\nif (*count == 0 || *count > 6)\r\n*count = 6;\r\nreturn 0;\r\n}\r\nstatic int viacam_vb_buf_prepare(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb, enum v4l2_field field)\r\n{\r\nstruct via_camera *cam = q->priv_data;\r\nvb->size = cam->user_format.sizeimage;\r\nvb->width = cam->user_format.width;\r\nvb->height = cam->user_format.height;\r\nvb->field = field;\r\nif (vb->state == VIDEOBUF_NEEDS_INIT) {\r\nint ret = videobuf_iolock(q, vb, NULL);\r\nif (ret)\r\nreturn ret;\r\n}\r\nvb->state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\n}\r\nstatic void viacam_vb_buf_queue(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct via_camera *cam = q->priv_data;\r\nvb->state = VIDEOBUF_QUEUED;\r\nlist_add_tail(&vb->queue, &cam->buffer_queue);\r\n}\r\nstatic void viacam_vb_buf_release(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct via_camera *cam = q->priv_data;\r\nvideobuf_dma_unmap(&cam->platdev->dev, videobuf_to_dma(vb));\r\nvideobuf_dma_free(videobuf_to_dma(vb));\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic int viacam_open(struct file *filp)\r\n{\r\nstruct via_camera *cam = video_drvdata(filp);\r\nfilp->private_data = cam;\r\nmutex_lock(&cam->lock);\r\nif (cam->users == 0) {\r\nint ret = viafb_request_dma();\r\nif (ret) {\r\nmutex_unlock(&cam->lock);\r\nreturn ret;\r\n}\r\nvia_sensor_power_up(cam);\r\nset_bit(CF_CONFIG_NEEDED, &cam->flags);\r\nvideobuf_queue_sg_init(&cam->vb_queue, &viacam_vb_ops,\r\n&cam->platdev->dev, &cam->viadev->reg_lock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE, V4L2_FIELD_NONE,\r\nsizeof(struct videobuf_buffer), cam, NULL);\r\n}\r\n(cam->users)++;\r\nmutex_unlock(&cam->lock);\r\nreturn 0;\r\n}\r\nstatic int viacam_release(struct file *filp)\r\n{\r\nstruct via_camera *cam = video_drvdata(filp);\r\nmutex_lock(&cam->lock);\r\n(cam->users)--;\r\nif (filp == cam->owner) {\r\nvideobuf_stop(&cam->vb_queue);\r\nif (cam->opstate != S_IDLE)\r\nviacam_stop_engine(cam);\r\ncam->owner = NULL;\r\n}\r\nif (cam->users == 0) {\r\nvideobuf_mmap_free(&cam->vb_queue);\r\nvia_sensor_power_down(cam);\r\nviafb_release_dma();\r\n}\r\nmutex_unlock(&cam->lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t viacam_read(struct file *filp, char __user *buffer,\r\nsize_t len, loff_t *pos)\r\n{\r\nstruct via_camera *cam = video_drvdata(filp);\r\nint ret;\r\nmutex_lock(&cam->lock);\r\nif (cam->owner && cam->owner != filp) {\r\nret = -EBUSY;\r\ngoto out_unlock;\r\n}\r\ncam->owner = filp;\r\nif (test_bit(CF_CONFIG_NEEDED, &cam->flags)) {\r\nret = viacam_configure_sensor(cam);\r\nif (!ret)\r\nret = viacam_config_controller(cam);\r\nif (ret)\r\ngoto out_unlock;\r\n}\r\nINIT_LIST_HEAD(&cam->buffer_queue);\r\nviacam_start_engine(cam);\r\nret = videobuf_read_stream(&cam->vb_queue, buffer, len, pos, 0,\r\nfilp->f_flags & O_NONBLOCK);\r\nviacam_stop_engine(cam);\r\nout_unlock:\r\nmutex_unlock(&cam->lock);\r\nreturn ret;\r\n}\r\nstatic unsigned int viacam_poll(struct file *filp, struct poll_table_struct *pt)\r\n{\r\nstruct via_camera *cam = video_drvdata(filp);\r\nreturn videobuf_poll_stream(filp, &cam->vb_queue, pt);\r\n}\r\nstatic int viacam_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct via_camera *cam = video_drvdata(filp);\r\nreturn videobuf_mmap_mapper(&cam->vb_queue, vma);\r\n}\r\nstatic int viacam_g_chip_ident(struct file *file, void *priv,\r\nstruct v4l2_dbg_chip_ident *ident)\r\n{\r\nstruct via_camera *cam = priv;\r\nident->ident = V4L2_IDENT_NONE;\r\nident->revision = 0;\r\nif (v4l2_chip_match_host(&ident->match)) {\r\nident->ident = V4L2_IDENT_VIA_VX855;\r\nreturn 0;\r\n}\r\nreturn sensor_call(cam, core, g_chip_ident, ident);\r\n}\r\nstatic int viacam_queryctrl(struct file *filp, void *priv,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nstruct via_camera *cam = priv;\r\nint ret;\r\nmutex_lock(&cam->lock);\r\nret = sensor_call(cam, core, queryctrl, qc);\r\nmutex_unlock(&cam->lock);\r\nreturn ret;\r\n}\r\nstatic int viacam_g_ctrl(struct file *filp, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct via_camera *cam = priv;\r\nint ret;\r\nmutex_lock(&cam->lock);\r\nret = sensor_call(cam, core, g_ctrl, ctrl);\r\nmutex_unlock(&cam->lock);\r\nreturn ret;\r\n}\r\nstatic int viacam_s_ctrl(struct file *filp, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct via_camera *cam = priv;\r\nint ret;\r\nmutex_lock(&cam->lock);\r\nret = sensor_call(cam, core, s_ctrl, ctrl);\r\nmutex_unlock(&cam->lock);\r\nreturn ret;\r\n}\r\nstatic int viacam_enum_input(struct file *filp, void *priv,\r\nstruct v4l2_input *input)\r\n{\r\nif (input->index != 0)\r\nreturn -EINVAL;\r\ninput->type = V4L2_INPUT_TYPE_CAMERA;\r\ninput->std = V4L2_STD_ALL;\r\nstrcpy(input->name, "Camera");\r\nreturn 0;\r\n}\r\nstatic int viacam_g_input(struct file *filp, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int viacam_s_input(struct file *filp, void *priv, unsigned int i)\r\n{\r\nif (i != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int viacam_s_std(struct file *filp, void *priv, v4l2_std_id *std)\r\n{\r\nreturn 0;\r\n}\r\nstatic int viacam_enum_fmt_vid_cap(struct file *filp, void *priv,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nif (fmt->index >= N_VIA_FMTS)\r\nreturn -EINVAL;\r\nstrlcpy(fmt->description, via_formats[fmt->index].desc,\r\nsizeof(fmt->description));\r\nfmt->pixelformat = via_formats[fmt->index].pixelformat;\r\nreturn 0;\r\n}\r\nstatic void viacam_fmt_pre(struct v4l2_pix_format *userfmt,\r\nstruct v4l2_pix_format *sensorfmt)\r\n{\r\n*sensorfmt = *userfmt;\r\nif (userfmt->width < QCIF_WIDTH || userfmt->height < QCIF_HEIGHT) {\r\nuserfmt->width = QCIF_WIDTH;\r\nuserfmt->height = QCIF_HEIGHT;\r\n}\r\nif (userfmt->width > VGA_WIDTH || userfmt->height > VGA_HEIGHT) {\r\nuserfmt->width = VGA_WIDTH;\r\nuserfmt->height = VGA_HEIGHT;\r\n}\r\nsensorfmt->width = VGA_WIDTH;\r\nsensorfmt->height = VGA_HEIGHT;\r\n}\r\nstatic void viacam_fmt_post(struct v4l2_pix_format *userfmt,\r\nstruct v4l2_pix_format *sensorfmt)\r\n{\r\nstruct via_format *f = via_find_format(userfmt->pixelformat);\r\nsensorfmt->bytesperline = sensorfmt->width * f->bpp;\r\nsensorfmt->sizeimage = sensorfmt->height * sensorfmt->bytesperline;\r\nuserfmt->pixelformat = sensorfmt->pixelformat;\r\nuserfmt->field = sensorfmt->field;\r\nuserfmt->bytesperline = 2 * userfmt->width;\r\nuserfmt->sizeimage = userfmt->bytesperline * userfmt->height;\r\n}\r\nstatic int viacam_do_try_fmt(struct via_camera *cam,\r\nstruct v4l2_pix_format *upix, struct v4l2_pix_format *spix)\r\n{\r\nint ret;\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nstruct via_format *f = via_find_format(upix->pixelformat);\r\nupix->pixelformat = f->pixelformat;\r\nviacam_fmt_pre(upix, spix);\r\nv4l2_fill_mbus_format(&mbus_fmt, upix, f->mbus_code);\r\nret = sensor_call(cam, video, try_mbus_fmt, &mbus_fmt);\r\nv4l2_fill_pix_format(spix, &mbus_fmt);\r\nviacam_fmt_post(upix, spix);\r\nreturn ret;\r\n}\r\nstatic int viacam_try_fmt_vid_cap(struct file *filp, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct via_camera *cam = priv;\r\nstruct v4l2_format sfmt;\r\nint ret;\r\nmutex_lock(&cam->lock);\r\nret = viacam_do_try_fmt(cam, &fmt->fmt.pix, &sfmt.fmt.pix);\r\nmutex_unlock(&cam->lock);\r\nreturn ret;\r\n}\r\nstatic int viacam_g_fmt_vid_cap(struct file *filp, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct via_camera *cam = priv;\r\nmutex_lock(&cam->lock);\r\nfmt->fmt.pix = cam->user_format;\r\nmutex_unlock(&cam->lock);\r\nreturn 0;\r\n}\r\nstatic int viacam_s_fmt_vid_cap(struct file *filp, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct via_camera *cam = priv;\r\nint ret;\r\nstruct v4l2_format sfmt;\r\nstruct via_format *f = via_find_format(fmt->fmt.pix.pixelformat);\r\nmutex_lock(&cam->lock);\r\nif (cam->opstate != S_IDLE) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nret = viacam_do_try_fmt(cam, &fmt->fmt.pix, &sfmt.fmt.pix);\r\nif (ret)\r\ngoto out;\r\ncam->user_format = fmt->fmt.pix;\r\ncam->sensor_format = sfmt.fmt.pix;\r\ncam->mbus_code = f->mbus_code;\r\nret = viacam_configure_sensor(cam);\r\nif (!ret)\r\nret = viacam_config_controller(cam);\r\nout:\r\nmutex_unlock(&cam->lock);\r\nreturn ret;\r\n}\r\nstatic int viacam_querycap(struct file *filp, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrcpy(cap->driver, "via-camera");\r\nstrcpy(cap->card, "via-camera");\r\ncap->version = 1;\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_READWRITE | V4L2_CAP_STREAMING;\r\nreturn 0;\r\n}\r\nstatic int viacam_reqbufs(struct file *filp, void *priv,\r\nstruct v4l2_requestbuffers *rb)\r\n{\r\nstruct via_camera *cam = priv;\r\nreturn videobuf_reqbufs(&cam->vb_queue, rb);\r\n}\r\nstatic int viacam_querybuf(struct file *filp, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct via_camera *cam = priv;\r\nreturn videobuf_querybuf(&cam->vb_queue, buf);\r\n}\r\nstatic int viacam_qbuf(struct file *filp, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct via_camera *cam = priv;\r\nreturn videobuf_qbuf(&cam->vb_queue, buf);\r\n}\r\nstatic int viacam_dqbuf(struct file *filp, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct via_camera *cam = priv;\r\nreturn videobuf_dqbuf(&cam->vb_queue, buf, filp->f_flags & O_NONBLOCK);\r\n}\r\nstatic int viacam_streamon(struct file *filp, void *priv, enum v4l2_buf_type t)\r\n{\r\nstruct via_camera *cam = priv;\r\nint ret = 0;\r\nif (t != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nmutex_lock(&cam->lock);\r\nif (cam->opstate != S_IDLE) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (cam->owner && cam->owner != filp) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\ncam->owner = filp;\r\nif (test_bit(CF_CONFIG_NEEDED, &cam->flags)) {\r\nret = viacam_configure_sensor(cam);\r\nif (ret)\r\ngoto out;\r\nret = viacam_config_controller(cam);\r\nif (ret)\r\ngoto out;\r\n}\r\npm_qos_add_request(&cam->qos_request, PM_QOS_CPU_DMA_LATENCY, 50);\r\nINIT_LIST_HEAD(&cam->buffer_queue);\r\nret = videobuf_streamon(&cam->vb_queue);\r\nif (!ret)\r\nviacam_start_engine(cam);\r\nout:\r\nmutex_unlock(&cam->lock);\r\nreturn ret;\r\n}\r\nstatic int viacam_streamoff(struct file *filp, void *priv, enum v4l2_buf_type t)\r\n{\r\nstruct via_camera *cam = priv;\r\nint ret;\r\nif (t != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nmutex_lock(&cam->lock);\r\nif (cam->opstate != S_RUNNING) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\npm_qos_remove_request(&cam->qos_request);\r\nviacam_stop_engine(cam);\r\nret = videobuf_streamoff(&cam->vb_queue);\r\nINIT_LIST_HEAD(&cam->buffer_queue);\r\nout:\r\nmutex_unlock(&cam->lock);\r\nreturn ret;\r\n}\r\nstatic int viacam_g_parm(struct file *filp, void *priv,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nstruct via_camera *cam = priv;\r\nint ret;\r\nmutex_lock(&cam->lock);\r\nret = sensor_call(cam, video, g_parm, parm);\r\nmutex_unlock(&cam->lock);\r\nparm->parm.capture.readbuffers = cam->n_cap_bufs;\r\nreturn ret;\r\n}\r\nstatic int viacam_s_parm(struct file *filp, void *priv,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nstruct via_camera *cam = priv;\r\nint ret;\r\nmutex_lock(&cam->lock);\r\nret = sensor_call(cam, video, s_parm, parm);\r\nmutex_unlock(&cam->lock);\r\nparm->parm.capture.readbuffers = cam->n_cap_bufs;\r\nreturn ret;\r\n}\r\nstatic int viacam_enum_framesizes(struct file *filp, void *priv,\r\nstruct v4l2_frmsizeenum *sizes)\r\n{\r\nif (sizes->index != 0)\r\nreturn -EINVAL;\r\nsizes->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;\r\nsizes->stepwise.min_width = QCIF_WIDTH;\r\nsizes->stepwise.min_height = QCIF_HEIGHT;\r\nsizes->stepwise.max_width = VGA_WIDTH;\r\nsizes->stepwise.max_height = VGA_HEIGHT;\r\nsizes->stepwise.step_width = sizes->stepwise.step_height = 1;\r\nreturn 0;\r\n}\r\nstatic int viacam_enum_frameintervals(struct file *filp, void *priv,\r\nstruct v4l2_frmivalenum *interval)\r\n{\r\nstruct via_camera *cam = priv;\r\nint ret;\r\nmutex_lock(&cam->lock);\r\nret = sensor_call(cam, video, enum_frameintervals, interval);\r\nmutex_unlock(&cam->lock);\r\nreturn ret;\r\n}\r\nstatic int viacam_suspend(void *priv)\r\n{\r\nstruct via_camera *cam = priv;\r\nenum viacam_opstate state = cam->opstate;\r\nif (cam->opstate != S_IDLE) {\r\nviacam_stop_engine(cam);\r\ncam->opstate = state;\r\n}\r\nreturn 0;\r\n}\r\nstatic int viacam_resume(void *priv)\r\n{\r\nstruct via_camera *cam = priv;\r\nint ret = 0;\r\nvia_write_reg_mask(VIASR, 0x78, 0, 0x80);\r\nvia_write_reg_mask(VIASR, 0x1e, 0xc0, 0xc0);\r\nviacam_int_disable(cam);\r\nset_bit(CF_CONFIG_NEEDED, &cam->flags);\r\nif (cam->users > 0)\r\nvia_sensor_power_up(cam);\r\nelse\r\nvia_sensor_power_down(cam);\r\nif (cam->opstate != S_IDLE) {\r\nmutex_lock(&cam->lock);\r\nret = viacam_configure_sensor(cam);\r\nif (!ret)\r\nret = viacam_config_controller(cam);\r\nmutex_unlock(&cam->lock);\r\nif (!ret)\r\nviacam_start_engine(cam);\r\n}\r\nreturn ret;\r\n}\r\nstatic __devinit bool viacam_serial_is_enabled(void)\r\n{\r\nstruct pci_bus *pbus = pci_find_bus(0, 0);\r\nu8 cbyte;\r\nif (!pbus)\r\nreturn false;\r\npci_bus_read_config_byte(pbus, VIACAM_SERIAL_DEVFN,\r\nVIACAM_SERIAL_CREG, &cbyte);\r\nif ((cbyte & VIACAM_SERIAL_BIT) == 0)\r\nreturn false;\r\nif (override_serial == 0) {\r\nprintk(KERN_NOTICE "Via camera: serial port is enabled, " \\r\n"refusing to load.\n");\r\nprintk(KERN_NOTICE "Specify override_serial=1 to force " \\r\n"module loading.\n");\r\nreturn true;\r\n}\r\nprintk(KERN_NOTICE "Via camera: overriding serial port\n");\r\npci_bus_write_config_byte(pbus, VIACAM_SERIAL_DEVFN,\r\nVIACAM_SERIAL_CREG, cbyte & ~VIACAM_SERIAL_BIT);\r\nreturn false;\r\n}\r\nstatic __devinit int viacam_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct i2c_adapter *sensor_adapter;\r\nstruct viafb_dev *viadev = pdev->dev.platform_data;\r\nstruct via_camera *cam;\r\nif (viadev->camera_fbmem_size < (VGA_HEIGHT*VGA_WIDTH*4)) {\r\nprintk(KERN_ERR "viacam: insufficient FB memory reserved\n");\r\nreturn -ENOMEM;\r\n}\r\nif (viadev->engine_mmio == NULL) {\r\nprintk(KERN_ERR "viacam: No I/O memory, so no pictures\n");\r\nreturn -ENOMEM;\r\n}\r\nif (machine_is_olpc() && viacam_serial_is_enabled())\r\nreturn -EBUSY;\r\ncam = kzalloc (sizeof(struct via_camera), GFP_KERNEL);\r\nif (cam == NULL)\r\nreturn -ENOMEM;\r\nvia_cam_info = cam;\r\ncam->platdev = pdev;\r\ncam->viadev = viadev;\r\ncam->users = 0;\r\ncam->owner = NULL;\r\ncam->opstate = S_IDLE;\r\ncam->user_format = cam->sensor_format = viacam_def_pix_format;\r\nmutex_init(&cam->lock);\r\nINIT_LIST_HEAD(&cam->buffer_queue);\r\ncam->mmio = viadev->engine_mmio;\r\ncam->fbmem = viadev->fbmem;\r\ncam->fb_offset = viadev->camera_fbmem_offset;\r\ncam->flags = 1 << CF_CONFIG_NEEDED;\r\ncam->mbus_code = via_def_mbus_code;\r\nret = v4l2_device_register(&pdev->dev, &cam->v4l2_dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable to register v4l2 device\n");\r\nreturn ret;\r\n}\r\npdev->dev.dma_mask = &viadev->pdev->dma_mask;\r\ndma_set_mask(&pdev->dev, 0xffffffff);\r\nvia_write_reg_mask(VIASR, 0x78, 0, 0x80);\r\nvia_write_reg_mask(VIASR, 0x1e, 0xc0, 0xc0);\r\nret = via_sensor_power_setup(cam);\r\nif (ret)\r\ngoto out_unregister;\r\nvia_sensor_power_up(cam);\r\nsensor_adapter = viafb_find_i2c_adapter(VIA_PORT_31);\r\ncam->sensor = v4l2_i2c_new_subdev(&cam->v4l2_dev, sensor_adapter,\r\n"ov7670", 0x42 >> 1, NULL);\r\nif (cam->sensor == NULL) {\r\ndev_err(&pdev->dev, "Unable to find the sensor!\n");\r\nret = -ENODEV;\r\ngoto out_power_down;\r\n}\r\nviacam_int_disable(cam);\r\nret = request_threaded_irq(viadev->pdev->irq, viacam_quick_irq,\r\nviacam_irq, IRQF_SHARED, "via-camera", cam);\r\nif (ret)\r\ngoto out_power_down;\r\ncam->vdev = viacam_v4l_template;\r\ncam->vdev.v4l2_dev = &cam->v4l2_dev;\r\nret = video_register_device(&cam->vdev, VFL_TYPE_GRABBER, -1);\r\nif (ret)\r\ngoto out_irq;\r\nvideo_set_drvdata(&cam->vdev, cam);\r\n#ifdef CONFIG_PM\r\nviacam_pm_hooks.private = cam;\r\nviafb_pm_register(&viacam_pm_hooks);\r\n#endif\r\nvia_sensor_power_down(cam);\r\nreturn 0;\r\nout_irq:\r\nfree_irq(viadev->pdev->irq, cam);\r\nout_power_down:\r\nvia_sensor_power_release(cam);\r\nout_unregister:\r\nv4l2_device_unregister(&cam->v4l2_dev);\r\nreturn ret;\r\n}\r\nstatic __devexit int viacam_remove(struct platform_device *pdev)\r\n{\r\nstruct via_camera *cam = via_cam_info;\r\nstruct viafb_dev *viadev = pdev->dev.platform_data;\r\nvideo_unregister_device(&cam->vdev);\r\nv4l2_device_unregister(&cam->v4l2_dev);\r\nfree_irq(viadev->pdev->irq, cam);\r\nvia_sensor_power_release(cam);\r\nvia_cam_info = NULL;\r\nreturn 0;\r\n}
