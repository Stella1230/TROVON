static void *zlib_init(struct squashfs_sb_info *dummy, void *buff, int len)\r\n{\r\nz_stream *stream = kmalloc(sizeof(z_stream), GFP_KERNEL);\r\nif (stream == NULL)\r\ngoto failed;\r\nstream->workspace = vmalloc(zlib_inflate_workspacesize());\r\nif (stream->workspace == NULL)\r\ngoto failed;\r\nreturn stream;\r\nfailed:\r\nERROR("Failed to allocate zlib workspace\n");\r\nkfree(stream);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic void zlib_free(void *strm)\r\n{\r\nz_stream *stream = strm;\r\nif (stream)\r\nvfree(stream->workspace);\r\nkfree(stream);\r\n}\r\nstatic int zlib_uncompress(struct squashfs_sb_info *msblk, void **buffer,\r\nstruct buffer_head **bh, int b, int offset, int length, int srclength,\r\nint pages)\r\n{\r\nint zlib_err, zlib_init = 0;\r\nint k = 0, page = 0;\r\nz_stream *stream = msblk->stream;\r\nmutex_lock(&msblk->read_data_mutex);\r\nstream->avail_out = 0;\r\nstream->avail_in = 0;\r\ndo {\r\nif (stream->avail_in == 0 && k < b) {\r\nint avail = min(length, msblk->devblksize - offset);\r\nlength -= avail;\r\nwait_on_buffer(bh[k]);\r\nif (!buffer_uptodate(bh[k]))\r\ngoto release_mutex;\r\nstream->next_in = bh[k]->b_data + offset;\r\nstream->avail_in = avail;\r\noffset = 0;\r\n}\r\nif (stream->avail_out == 0 && page < pages) {\r\nstream->next_out = buffer[page++];\r\nstream->avail_out = PAGE_CACHE_SIZE;\r\n}\r\nif (!zlib_init) {\r\nzlib_err = zlib_inflateInit(stream);\r\nif (zlib_err != Z_OK) {\r\nERROR("zlib_inflateInit returned unexpected "\r\n"result 0x%x, srclength %d\n",\r\nzlib_err, srclength);\r\ngoto release_mutex;\r\n}\r\nzlib_init = 1;\r\n}\r\nzlib_err = zlib_inflate(stream, Z_SYNC_FLUSH);\r\nif (stream->avail_in == 0 && k < b)\r\nput_bh(bh[k++]);\r\n} while (zlib_err == Z_OK);\r\nif (zlib_err != Z_STREAM_END) {\r\nERROR("zlib_inflate error, data probably corrupt\n");\r\ngoto release_mutex;\r\n}\r\nzlib_err = zlib_inflateEnd(stream);\r\nif (zlib_err != Z_OK) {\r\nERROR("zlib_inflate error, data probably corrupt\n");\r\ngoto release_mutex;\r\n}\r\nif (k < b) {\r\nERROR("zlib_uncompress error, data remaining\n");\r\ngoto release_mutex;\r\n}\r\nlength = stream->total_out;\r\nmutex_unlock(&msblk->read_data_mutex);\r\nreturn length;\r\nrelease_mutex:\r\nmutex_unlock(&msblk->read_data_mutex);\r\nfor (; k < b; k++)\r\nput_bh(bh[k]);\r\nreturn -EIO;\r\n}
