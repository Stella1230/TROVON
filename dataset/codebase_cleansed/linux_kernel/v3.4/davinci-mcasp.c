static inline void mcasp_set_bits(void __iomem *reg, u32 val)\r\n{\r\n__raw_writel(__raw_readl(reg) | val, reg);\r\n}\r\nstatic inline void mcasp_clr_bits(void __iomem *reg, u32 val)\r\n{\r\n__raw_writel((__raw_readl(reg) & ~(val)), reg);\r\n}\r\nstatic inline void mcasp_mod_bits(void __iomem *reg, u32 val, u32 mask)\r\n{\r\n__raw_writel((__raw_readl(reg) & ~mask) | val, reg);\r\n}\r\nstatic inline void mcasp_set_reg(void __iomem *reg, u32 val)\r\n{\r\n__raw_writel(val, reg);\r\n}\r\nstatic inline u32 mcasp_get_reg(void __iomem *reg)\r\n{\r\nreturn (unsigned int)__raw_readl(reg);\r\n}\r\nstatic inline void mcasp_set_ctl_reg(void __iomem *regs, u32 val)\r\n{\r\nint i = 0;\r\nmcasp_set_bits(regs, val);\r\nfor (i = 0; i < 1000; i++) {\r\nif ((mcasp_get_reg(regs) & val) == val)\r\nbreak;\r\n}\r\nif (i == 1000 && ((mcasp_get_reg(regs) & val) != val))\r\nprintk(KERN_ERR "GBLCTL write error\n");\r\n}\r\nstatic void mcasp_start_rx(struct davinci_audio_dev *dev)\r\n{\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXHCLKRST);\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXCLKRST);\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXSERCLR);\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_RXBUF_REG, 0);\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXSMRST);\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXFSRST);\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_RXBUF_REG, 0);\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXSMRST);\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXFSRST);\r\n}\r\nstatic void mcasp_start_tx(struct davinci_audio_dev *dev)\r\n{\r\nu8 offset = 0, i;\r\nu32 cnt;\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXHCLKRST);\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXCLKRST);\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXSERCLR);\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_TXBUF_REG, 0);\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXSMRST);\r\nmcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXFSRST);\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_TXBUF_REG, 0);\r\nfor (i = 0; i < dev->num_serializer; i++) {\r\nif (dev->serial_dir[i] == TX_MODE) {\r\noffset = i;\r\nbreak;\r\n}\r\n}\r\ncnt = 0;\r\nwhile (!(mcasp_get_reg(dev->base + DAVINCI_MCASP_XRSRCTL_REG(offset)) &\r\nTXSTATE) && (cnt < 100000))\r\ncnt++;\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_TXBUF_REG, 0);\r\n}\r\nstatic void davinci_mcasp_start(struct davinci_audio_dev *dev, int stream)\r\n{\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nif (dev->txnumevt)\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_WFIFOCTL,\r\nFIFO_ENABLE);\r\nmcasp_start_tx(dev);\r\n} else {\r\nif (dev->rxnumevt)\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_RFIFOCTL,\r\nFIFO_ENABLE);\r\nmcasp_start_rx(dev);\r\n}\r\n}\r\nstatic void mcasp_stop_rx(struct davinci_audio_dev *dev)\r\n{\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, 0);\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_RXSTAT_REG, 0xFFFFFFFF);\r\n}\r\nstatic void mcasp_stop_tx(struct davinci_audio_dev *dev)\r\n{\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, 0);\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_TXSTAT_REG, 0xFFFFFFFF);\r\n}\r\nstatic void davinci_mcasp_stop(struct davinci_audio_dev *dev, int stream)\r\n{\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nif (dev->txnumevt)\r\nmcasp_clr_bits(dev->base + DAVINCI_MCASP_WFIFOCTL,\r\nFIFO_ENABLE);\r\nmcasp_stop_tx(dev);\r\n} else {\r\nif (dev->rxnumevt)\r\nmcasp_clr_bits(dev->base + DAVINCI_MCASP_RFIFOCTL,\r\nFIFO_ENABLE);\r\nmcasp_stop_rx(dev);\r\n}\r\n}\r\nstatic int davinci_mcasp_set_dai_fmt(struct snd_soc_dai *cpu_dai,\r\nunsigned int fmt)\r\n{\r\nstruct davinci_audio_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);\r\nvoid __iomem *base = dev->base;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nmcasp_set_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXE);\r\nmcasp_set_bits(base + DAVINCI_MCASP_TXFMCTL_REG, AFSXE);\r\nmcasp_set_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRE);\r\nmcasp_set_bits(base + DAVINCI_MCASP_RXFMCTL_REG, AFSRE);\r\nmcasp_set_bits(base + DAVINCI_MCASP_PDIR_REG,\r\nACLKX | AHCLKX | AFSX);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nmcasp_clr_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXE);\r\nmcasp_set_bits(base + DAVINCI_MCASP_TXFMCTL_REG, AFSXE);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRE);\r\nmcasp_set_bits(base + DAVINCI_MCASP_RXFMCTL_REG, AFSRE);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_PDIR_REG,\r\nACLKX | ACLKR);\r\nmcasp_set_bits(base + DAVINCI_MCASP_PDIR_REG,\r\nAFSX | AFSR);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nmcasp_clr_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXE);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_TXFMCTL_REG, AFSXE);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRE);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_RXFMCTL_REG, AFSRE);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_PDIR_REG,\r\nACLKX | AHCLKX | AFSX | ACLKR | AHCLKR | AFSR);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nmcasp_clr_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_TXFMCTL_REG, FSXPOL);\r\nmcasp_set_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_RXFMCTL_REG, FSRPOL);\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nmcasp_set_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);\r\nmcasp_set_bits(base + DAVINCI_MCASP_TXFMCTL_REG, FSXPOL);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);\r\nmcasp_set_bits(base + DAVINCI_MCASP_RXFMCTL_REG, FSRPOL);\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nmcasp_clr_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);\r\nmcasp_set_bits(base + DAVINCI_MCASP_TXFMCTL_REG, FSXPOL);\r\nmcasp_set_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);\r\nmcasp_set_bits(base + DAVINCI_MCASP_RXFMCTL_REG, FSRPOL);\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nmcasp_set_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_TXFMCTL_REG, FSXPOL);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);\r\nmcasp_clr_bits(base + DAVINCI_MCASP_RXFMCTL_REG, FSRPOL);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int davinci_config_channel_size(struct davinci_audio_dev *dev,\r\nint channel_size)\r\n{\r\nu32 fmt = 0;\r\nu32 mask, rotate;\r\nswitch (channel_size) {\r\ncase DAVINCI_AUDIO_WORD_8:\r\nfmt = 0x03;\r\nrotate = 6;\r\nmask = 0x000000ff;\r\nbreak;\r\ncase DAVINCI_AUDIO_WORD_12:\r\nfmt = 0x05;\r\nrotate = 5;\r\nmask = 0x00000fff;\r\nbreak;\r\ncase DAVINCI_AUDIO_WORD_16:\r\nfmt = 0x07;\r\nrotate = 4;\r\nmask = 0x0000ffff;\r\nbreak;\r\ncase DAVINCI_AUDIO_WORD_20:\r\nfmt = 0x09;\r\nrotate = 3;\r\nmask = 0x000fffff;\r\nbreak;\r\ncase DAVINCI_AUDIO_WORD_24:\r\nfmt = 0x0B;\r\nrotate = 2;\r\nmask = 0x00ffffff;\r\nbreak;\r\ncase DAVINCI_AUDIO_WORD_28:\r\nfmt = 0x0D;\r\nrotate = 1;\r\nmask = 0x0fffffff;\r\nbreak;\r\ncase DAVINCI_AUDIO_WORD_32:\r\nfmt = 0x0F;\r\nrotate = 0;\r\nmask = 0xffffffff;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_RXFMT_REG,\r\nRXSSZ(fmt), RXSSZ(0x0F));\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_TXFMT_REG,\r\nTXSSZ(fmt), TXSSZ(0x0F));\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_TXFMT_REG, TXROT(rotate),\r\nTXROT(7));\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_RXFMT_REG, RXROT(rotate),\r\nRXROT(7));\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_TXMASK_REG, mask);\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_RXMASK_REG, mask);\r\nreturn 0;\r\n}\r\nstatic void davinci_hw_common_param(struct davinci_audio_dev *dev, int stream)\r\n{\r\nint i;\r\nu8 tx_ser = 0;\r\nu8 rx_ser = 0;\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_PWREMUMGT_REG, MCASP_SOFT);\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_PFUNC_REG, 0x00000000);\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_TXSTAT_REG, 0xFFFFFFFF);\r\nmcasp_clr_bits(dev->base + DAVINCI_MCASP_XEVTCTL_REG,\r\nTXDATADMADIS);\r\n} else {\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_RXSTAT_REG, 0xFFFFFFFF);\r\nmcasp_clr_bits(dev->base + DAVINCI_MCASP_REVTCTL_REG,\r\nRXDATADMADIS);\r\n}\r\nfor (i = 0; i < dev->num_serializer; i++) {\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_XRSRCTL_REG(i),\r\ndev->serial_dir[i]);\r\nif (dev->serial_dir[i] == TX_MODE) {\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_PDIR_REG,\r\nAXR(i));\r\ntx_ser++;\r\n} else if (dev->serial_dir[i] == RX_MODE) {\r\nmcasp_clr_bits(dev->base + DAVINCI_MCASP_PDIR_REG,\r\nAXR(i));\r\nrx_ser++;\r\n}\r\n}\r\nif (dev->txnumevt && stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nif (dev->txnumevt * tx_ser > 64)\r\ndev->txnumevt = 1;\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_WFIFOCTL, tx_ser,\r\nNUMDMA_MASK);\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_WFIFOCTL,\r\n((dev->txnumevt * tx_ser) << 8), NUMEVT_MASK);\r\n}\r\nif (dev->rxnumevt && stream == SNDRV_PCM_STREAM_CAPTURE) {\r\nif (dev->rxnumevt * rx_ser > 64)\r\ndev->rxnumevt = 1;\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_RFIFOCTL, rx_ser,\r\nNUMDMA_MASK);\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_RFIFOCTL,\r\n((dev->rxnumevt * rx_ser) << 8), NUMEVT_MASK);\r\n}\r\n}\r\nstatic void davinci_hw_param(struct davinci_audio_dev *dev, int stream)\r\n{\r\nint i, active_slots;\r\nu32 mask = 0;\r\nactive_slots = (dev->tdm_slots > 31) ? 32 : dev->tdm_slots;\r\nfor (i = 0; i < active_slots; i++)\r\nmask |= (1 << i);\r\nmcasp_clr_bits(dev->base + DAVINCI_MCASP_ACLKXCTL_REG, TX_ASYNC);\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_AHCLKXCTL_REG,\r\nAHCLKXE);\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_TXTDM_REG, mask);\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_TXFMT_REG, TXORD);\r\nif ((dev->tdm_slots >= 2) && (dev->tdm_slots <= 32))\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_TXFMCTL_REG,\r\nFSXMOD(dev->tdm_slots), FSXMOD(0x1FF));\r\nelse\r\nprintk(KERN_ERR "playback tdm slot %d not supported\n",\r\ndev->tdm_slots);\r\nmcasp_clr_bits(dev->base + DAVINCI_MCASP_TXFMCTL_REG, FSXDUR);\r\n} else {\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_RXFMT_REG, RXORD);\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_AHCLKRCTL_REG,\r\nAHCLKRE);\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_RXTDM_REG, mask);\r\nif ((dev->tdm_slots >= 2) && (dev->tdm_slots <= 32))\r\nmcasp_mod_bits(dev->base + DAVINCI_MCASP_RXFMCTL_REG,\r\nFSRMOD(dev->tdm_slots), FSRMOD(0x1FF));\r\nelse\r\nprintk(KERN_ERR "capture tdm slot %d not supported\n",\r\ndev->tdm_slots);\r\nmcasp_clr_bits(dev->base + DAVINCI_MCASP_RXFMCTL_REG, FSRDUR);\r\n}\r\n}\r\nstatic void davinci_hw_dit_param(struct davinci_audio_dev *dev)\r\n{\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_PDIR_REG, AFSX);\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_TXMASK_REG, 0x00FFFFFF);\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_TXFMT_REG,\r\nTXROT(6) | TXSSZ(15));\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_TXFMCTL_REG,\r\nAFSXE | FSXMOD(0x180));\r\nmcasp_set_reg(dev->base + DAVINCI_MCASP_TXTDM_REG, 0xFFFFFFFF);\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_ACLKXCTL_REG,\r\nACLKXE | TX_ASYNC);\r\nmcasp_clr_bits(dev->base + DAVINCI_MCASP_XEVTCTL_REG, TXDATADMADIS);\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_AHCLKXCTL_REG, AHCLKXDIV(3));\r\nmcasp_set_bits(dev->base + DAVINCI_MCASP_TXDITCTL_REG, DITEN);\r\n}\r\nstatic int davinci_mcasp_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct davinci_audio_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct davinci_pcm_dma_params *dma_params =\r\n&dev->dma_params[substream->stream];\r\nint word_length;\r\nu8 fifo_level;\r\ndavinci_hw_common_param(dev, substream->stream);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nfifo_level = dev->txnumevt;\r\nelse\r\nfifo_level = dev->rxnumevt;\r\nif (dev->op_mode == DAVINCI_MCASP_DIT_MODE)\r\ndavinci_hw_dit_param(dev);\r\nelse\r\ndavinci_hw_param(dev, substream->stream);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_U8:\r\ncase SNDRV_PCM_FORMAT_S8:\r\ndma_params->data_type = 1;\r\nword_length = DAVINCI_AUDIO_WORD_8;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_U16_LE:\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\ndma_params->data_type = 2;\r\nword_length = DAVINCI_AUDIO_WORD_16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_U32_LE:\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\ndma_params->data_type = 4;\r\nword_length = DAVINCI_AUDIO_WORD_32;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "davinci-mcasp: unsupported PCM format");\r\nreturn -EINVAL;\r\n}\r\nif (dev->version == MCASP_VERSION_2 && !fifo_level)\r\ndma_params->acnt = 4;\r\nelse\r\ndma_params->acnt = dma_params->data_type;\r\ndma_params->fifo_level = fifo_level;\r\ndavinci_config_channel_size(dev, word_length);\r\nreturn 0;\r\n}\r\nstatic int davinci_mcasp_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct davinci_audio_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (!dev->clk_active) {\r\nclk_enable(dev->clk);\r\ndev->clk_active = 1;\r\n}\r\ndavinci_mcasp_start(dev, substream->stream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ndavinci_mcasp_stop(dev, substream->stream);\r\nif (dev->clk_active) {\r\nclk_disable(dev->clk);\r\ndev->clk_active = 0;\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ndavinci_mcasp_stop(dev, substream->stream);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int davinci_mcasp_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct davinci_audio_dev *dev = snd_soc_dai_get_drvdata(dai);\r\nsnd_soc_dai_set_dma_data(dai, substream, dev->dma_params);\r\nreturn 0;\r\n}\r\nstatic int davinci_mcasp_probe(struct platform_device *pdev)\r\n{\r\nstruct davinci_pcm_dma_params *dma_data;\r\nstruct resource *mem, *ioarea, *res;\r\nstruct snd_platform_data *pdata;\r\nstruct davinci_audio_dev *dev;\r\nint ret;\r\ndev = devm_kzalloc(&pdev->dev, sizeof(struct davinci_audio_dev),\r\nGFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(&pdev->dev, "no mem resource?\n");\r\nreturn -ENODEV;\r\n}\r\nioarea = devm_request_mem_region(&pdev->dev, mem->start,\r\nresource_size(mem), pdev->name);\r\nif (!ioarea) {\r\ndev_err(&pdev->dev, "Audio region already claimed\n");\r\nreturn -EBUSY;\r\n}\r\npdata = pdev->dev.platform_data;\r\ndev->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(dev->clk))\r\nreturn -ENODEV;\r\nclk_enable(dev->clk);\r\ndev->clk_active = 1;\r\ndev->base = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));\r\nif (!dev->base) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto err_release_clk;\r\n}\r\ndev->op_mode = pdata->op_mode;\r\ndev->tdm_slots = pdata->tdm_slots;\r\ndev->num_serializer = pdata->num_serializer;\r\ndev->serial_dir = pdata->serial_dir;\r\ndev->codec_fmt = pdata->codec_fmt;\r\ndev->version = pdata->version;\r\ndev->txnumevt = pdata->txnumevt;\r\ndev->rxnumevt = pdata->rxnumevt;\r\ndma_data = &dev->dma_params[SNDRV_PCM_STREAM_PLAYBACK];\r\ndma_data->asp_chan_q = pdata->asp_chan_q;\r\ndma_data->ram_chan_q = pdata->ram_chan_q;\r\ndma_data->sram_size = pdata->sram_size_playback;\r\ndma_data->dma_addr = (dma_addr_t) (pdata->tx_dma_offset +\r\nmem->start);\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "no DMA resource\n");\r\nret = -ENODEV;\r\ngoto err_release_clk;\r\n}\r\ndma_data->channel = res->start;\r\ndma_data = &dev->dma_params[SNDRV_PCM_STREAM_CAPTURE];\r\ndma_data->asp_chan_q = pdata->asp_chan_q;\r\ndma_data->ram_chan_q = pdata->ram_chan_q;\r\ndma_data->sram_size = pdata->sram_size_capture;\r\ndma_data->dma_addr = (dma_addr_t)(pdata->rx_dma_offset +\r\nmem->start);\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (!res) {\r\ndev_err(&pdev->dev, "no DMA resource\n");\r\nret = -ENODEV;\r\ngoto err_release_clk;\r\n}\r\ndma_data->channel = res->start;\r\ndev_set_drvdata(&pdev->dev, dev);\r\nret = snd_soc_register_dai(&pdev->dev, &davinci_mcasp_dai[pdata->op_mode]);\r\nif (ret != 0)\r\ngoto err_release_clk;\r\nreturn 0;\r\nerr_release_clk:\r\nclk_disable(dev->clk);\r\nclk_put(dev->clk);\r\nreturn ret;\r\n}\r\nstatic int davinci_mcasp_remove(struct platform_device *pdev)\r\n{\r\nstruct davinci_audio_dev *dev = dev_get_drvdata(&pdev->dev);\r\nsnd_soc_unregister_dai(&pdev->dev);\r\nclk_disable(dev->clk);\r\nclk_put(dev->clk);\r\ndev->clk = NULL;\r\nreturn 0;\r\n}
