static int vv6410_probe(struct sd *sd)\r\n{\r\nu16 data;\r\nint err, i;\r\ns32 *sensor_settings;\r\nerr = stv06xx_read_sensor(sd, VV6410_DEVICEH, &data);\r\nif (err < 0)\r\nreturn -ENODEV;\r\nif (data == 0x19) {\r\npr_info("vv6410 sensor detected\n");\r\nsensor_settings = kmalloc(ARRAY_SIZE(vv6410_ctrl) * sizeof(s32),\r\nGFP_KERNEL);\r\nif (!sensor_settings)\r\nreturn -ENOMEM;\r\nsd->gspca_dev.cam.cam_mode = vv6410_mode;\r\nsd->gspca_dev.cam.nmodes = ARRAY_SIZE(vv6410_mode);\r\nsd->desc.ctrls = vv6410_ctrl;\r\nsd->desc.nctrls = ARRAY_SIZE(vv6410_ctrl);\r\nfor (i = 0; i < sd->desc.nctrls; i++)\r\nsensor_settings[i] = vv6410_ctrl[i].qctrl.default_value;\r\nsd->sensor_priv = sensor_settings;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int vv6410_init(struct sd *sd)\r\n{\r\nint err = 0, i;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nfor (i = 0; i < ARRAY_SIZE(stv_bridge_init); i++) {\r\nstv06xx_write_bridge(sd, stv_bridge_init[i].addr, stv_bridge_init[i].data);\r\n}\r\nif (err < 0)\r\nreturn err;\r\nerr = stv06xx_write_sensor_bytes(sd, (u8 *) vv6410_sensor_init,\r\nARRAY_SIZE(vv6410_sensor_init));\r\nif (err < 0)\r\nreturn err;\r\nerr = vv6410_set_exposure(&sd->gspca_dev,\r\nsensor_settings[EXPOSURE_IDX]);\r\nif (err < 0)\r\nreturn err;\r\nerr = vv6410_set_analog_gain(&sd->gspca_dev,\r\nsensor_settings[GAIN_IDX]);\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic void vv6410_disconnect(struct sd *sd)\r\n{\r\nsd->sensor = NULL;\r\nkfree(sd->sensor_priv);\r\n}\r\nstatic int vv6410_start(struct sd *sd)\r\n{\r\nint err;\r\nstruct cam *cam = &sd->gspca_dev.cam;\r\nu32 priv = cam->cam_mode[sd->gspca_dev.curr_mode].priv;\r\nif (priv & VV6410_SUBSAMPLE) {\r\nPDEBUG(D_CONF, "Enabling subsampling");\r\nstv06xx_write_bridge(sd, STV_Y_CTRL, 0x02);\r\nstv06xx_write_bridge(sd, STV_X_CTRL, 0x06);\r\nstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x10);\r\n} else {\r\nstv06xx_write_bridge(sd, STV_Y_CTRL, 0x01);\r\nstv06xx_write_bridge(sd, STV_X_CTRL, 0x0a);\r\nstv06xx_write_bridge(sd, STV_SCAN_RATE, 0x00);\r\n}\r\nerr = stv06xx_write_bridge(sd, STV_LED_CTRL, LED_ON);\r\nif (err < 0)\r\nreturn err;\r\nerr = stv06xx_write_sensor(sd, VV6410_SETUP0, 0);\r\nif (err < 0)\r\nreturn err;\r\nPDEBUG(D_STREAM, "Starting stream");\r\nreturn 0;\r\n}\r\nstatic int vv6410_stop(struct sd *sd)\r\n{\r\nint err;\r\nerr = stv06xx_write_bridge(sd, STV_LED_CTRL, LED_OFF);\r\nif (err < 0)\r\nreturn err;\r\nerr = stv06xx_write_sensor(sd, VV6410_SETUP0, VV6410_LOW_POWER_MODE);\r\nif (err < 0)\r\nreturn err;\r\nPDEBUG(D_STREAM, "Halting stream");\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic int vv6410_dump(struct sd *sd)\r\n{\r\nu8 i;\r\nint err = 0;\r\npr_info("Dumping all vv6410 sensor registers\n");\r\nfor (i = 0; i < 0xff && !err; i++) {\r\nu16 data;\r\nerr = stv06xx_read_sensor(sd, i, &data);\r\npr_info("Register 0x%x contained 0x%x\n", i, data);\r\n}\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic int vv6410_get_hflip(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[HFLIP_IDX];\r\nPDEBUG(D_V4L2, "Read horizontal flip %d", *val);\r\nreturn 0;\r\n}\r\nstatic int vv6410_set_hflip(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu16 i2c_data;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nsensor_settings[HFLIP_IDX] = val;\r\nerr = stv06xx_read_sensor(sd, VV6410_DATAFORMAT, &i2c_data);\r\nif (err < 0)\r\nreturn err;\r\nif (val)\r\ni2c_data |= VV6410_HFLIP;\r\nelse\r\ni2c_data &= ~VV6410_HFLIP;\r\nPDEBUG(D_V4L2, "Set horizontal flip to %d", val);\r\nerr = stv06xx_write_sensor(sd, VV6410_DATAFORMAT, i2c_data);\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic int vv6410_get_vflip(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[VFLIP_IDX];\r\nPDEBUG(D_V4L2, "Read vertical flip %d", *val);\r\nreturn 0;\r\n}\r\nstatic int vv6410_set_vflip(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu16 i2c_data;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nsensor_settings[VFLIP_IDX] = val;\r\nerr = stv06xx_read_sensor(sd, VV6410_DATAFORMAT, &i2c_data);\r\nif (err < 0)\r\nreturn err;\r\nif (val)\r\ni2c_data |= VV6410_VFLIP;\r\nelse\r\ni2c_data &= ~VV6410_VFLIP;\r\nPDEBUG(D_V4L2, "Set vertical flip to %d", val);\r\nerr = stv06xx_write_sensor(sd, VV6410_DATAFORMAT, i2c_data);\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic int vv6410_get_analog_gain(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[GAIN_IDX];\r\nPDEBUG(D_V4L2, "Read analog gain %d", *val);\r\nreturn 0;\r\n}\r\nstatic int vv6410_set_analog_gain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nsensor_settings[GAIN_IDX] = val;\r\nPDEBUG(D_V4L2, "Set analog gain to %d", val);\r\nerr = stv06xx_write_sensor(sd, VV6410_ANALOGGAIN, 0xf0 | (val & 0xf));\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic int vv6410_get_exposure(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\n*val = sensor_settings[EXPOSURE_IDX];\r\nPDEBUG(D_V4L2, "Read exposure %d", *val);\r\nreturn 0;\r\n}\r\nstatic int vv6410_set_exposure(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ns32 *sensor_settings = sd->sensor_priv;\r\nunsigned int fine, coarse;\r\nsensor_settings[EXPOSURE_IDX] = val;\r\nval = (val * val >> 14) + val / 4;\r\nfine = val % VV6410_CIF_LINELENGTH;\r\ncoarse = min(512, val / VV6410_CIF_LINELENGTH);\r\nPDEBUG(D_V4L2, "Set coarse exposure to %d, fine expsure to %d",\r\ncoarse, fine);\r\nerr = stv06xx_write_sensor(sd, VV6410_FINEH, fine >> 8);\r\nif (err < 0)\r\ngoto out;\r\nerr = stv06xx_write_sensor(sd, VV6410_FINEL, fine & 0xff);\r\nif (err < 0)\r\ngoto out;\r\nerr = stv06xx_write_sensor(sd, VV6410_COARSEH, coarse >> 8);\r\nif (err < 0)\r\ngoto out;\r\nerr = stv06xx_write_sensor(sd, VV6410_COARSEL, coarse & 0xff);\r\nout:\r\nreturn err;\r\n}
