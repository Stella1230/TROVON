static inline void highlander_i2c_irq_enable(struct highlander_i2c_dev *dev)\r\n{\r\niowrite16(ioread16(dev->base + SMCR) | SMCR_IEIC, dev->base + SMCR);\r\n}\r\nstatic inline void highlander_i2c_irq_disable(struct highlander_i2c_dev *dev)\r\n{\r\niowrite16(ioread16(dev->base + SMCR) & ~SMCR_IEIC, dev->base + SMCR);\r\n}\r\nstatic inline void highlander_i2c_start(struct highlander_i2c_dev *dev)\r\n{\r\niowrite16(ioread16(dev->base + SMCR) | SMCR_START, dev->base + SMCR);\r\n}\r\nstatic inline void highlander_i2c_done(struct highlander_i2c_dev *dev)\r\n{\r\niowrite16(ioread16(dev->base + SMCR) | SMCR_IRIC, dev->base + SMCR);\r\n}\r\nstatic void highlander_i2c_setup(struct highlander_i2c_dev *dev)\r\n{\r\nu16 smmr;\r\nsmmr = ioread16(dev->base + SMMR);\r\nsmmr |= SMMR_TMMD;\r\nif (iic_force_normal)\r\nsmmr &= ~SMMR_SP;\r\nelse\r\nsmmr |= SMMR_SP;\r\niowrite16(smmr, dev->base + SMMR);\r\n}\r\nstatic void smbus_write_data(u8 *src, u16 *dst, int len)\r\n{\r\nfor (; len > 1; len -= 2) {\r\n*dst++ = be16_to_cpup((__be16 *)src);\r\nsrc += 2;\r\n}\r\nif (len)\r\n*dst = *src << 8;\r\n}\r\nstatic void smbus_read_data(u16 *src, u8 *dst, int len)\r\n{\r\nfor (; len > 1; len -= 2) {\r\n*(__be16 *)dst = cpu_to_be16p(src++);\r\ndst += 2;\r\n}\r\nif (len)\r\n*dst = *src >> 8;\r\n}\r\nstatic void highlander_i2c_command(struct highlander_i2c_dev *dev,\r\nu8 command, int len)\r\n{\r\nunsigned int i;\r\nu16 cmd = (command << 8) | command;\r\nfor (i = 0; i < len; i += 2) {\r\nif (len - i == 1)\r\ncmd = command << 8;\r\niowrite16(cmd, dev->base + SMSADR + i);\r\ndev_dbg(dev->dev, "command data[%x] 0x%04x\n", i/2, cmd);\r\n}\r\n}\r\nstatic int highlander_i2c_wait_for_bbsy(struct highlander_i2c_dev *dev)\r\n{\r\nunsigned long timeout;\r\ntimeout = jiffies + msecs_to_jiffies(iic_timeout);\r\nwhile (ioread16(dev->base + SMCR) & SMCR_BBSY) {\r\nif (time_after(jiffies, timeout)) {\r\ndev_warn(dev->dev, "timeout waiting for bus ready\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int highlander_i2c_reset(struct highlander_i2c_dev *dev)\r\n{\r\niowrite16(ioread16(dev->base + SMCR) | SMCR_RST, dev->base + SMCR);\r\nreturn highlander_i2c_wait_for_bbsy(dev);\r\n}\r\nstatic int highlander_i2c_wait_for_ack(struct highlander_i2c_dev *dev)\r\n{\r\nu16 tmp = ioread16(dev->base + SMCR);\r\nif ((tmp & (SMCR_IRIC | SMCR_ACKE)) == SMCR_ACKE) {\r\ndev_warn(dev->dev, "ack abnormality\n");\r\nreturn highlander_i2c_reset(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t highlander_i2c_irq(int irq, void *dev_id)\r\n{\r\nstruct highlander_i2c_dev *dev = dev_id;\r\nhighlander_i2c_done(dev);\r\ncomplete(&dev->cmd_complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void highlander_i2c_poll(struct highlander_i2c_dev *dev)\r\n{\r\nunsigned long timeout;\r\nu16 smcr;\r\ntimeout = jiffies + msecs_to_jiffies(iic_timeout);\r\nfor (;;) {\r\nsmcr = ioread16(dev->base + SMCR);\r\nif (smcr & SMCR_IRIC)\r\nreturn;\r\nif (time_after(jiffies, timeout))\r\nbreak;\r\ncpu_relax();\r\ncond_resched();\r\n}\r\ndev_err(dev->dev, "polling timed out\n");\r\n}\r\nstatic inline int highlander_i2c_wait_xfer_done(struct highlander_i2c_dev *dev)\r\n{\r\nif (dev->irq)\r\nwait_for_completion_timeout(&dev->cmd_complete,\r\nmsecs_to_jiffies(iic_timeout));\r\nelse\r\nhighlander_i2c_poll(dev);\r\nreturn highlander_i2c_wait_for_ack(dev);\r\n}\r\nstatic int highlander_i2c_read(struct highlander_i2c_dev *dev)\r\n{\r\nint i, cnt;\r\nu16 data[16];\r\nif (highlander_i2c_wait_for_bbsy(dev))\r\nreturn -EAGAIN;\r\nhighlander_i2c_start(dev);\r\nif (highlander_i2c_wait_xfer_done(dev)) {\r\ndev_err(dev->dev, "Arbitration loss\n");\r\nreturn -EAGAIN;\r\n}\r\nif (iic_read_delay && time_before(jiffies, dev->last_read_time +\r\nmsecs_to_jiffies(iic_read_delay)))\r\nmsleep(jiffies_to_msecs((dev->last_read_time +\r\nmsecs_to_jiffies(iic_read_delay)) - jiffies));\r\ncnt = (dev->buf_len + 1) >> 1;\r\nfor (i = 0; i < cnt; i++) {\r\ndata[i] = ioread16(dev->base + SMTRDR + (i * sizeof(u16)));\r\ndev_dbg(dev->dev, "read data[%x] 0x%04x\n", i, data[i]);\r\n}\r\nsmbus_read_data(data, dev->buf, dev->buf_len);\r\ndev->last_read_time = jiffies;\r\nreturn 0;\r\n}\r\nstatic int highlander_i2c_write(struct highlander_i2c_dev *dev)\r\n{\r\nint i, cnt;\r\nu16 data[16];\r\nsmbus_write_data(dev->buf, data, dev->buf_len);\r\ncnt = (dev->buf_len + 1) >> 1;\r\nfor (i = 0; i < cnt; i++) {\r\niowrite16(data[i], dev->base + SMTRDR + (i * sizeof(u16)));\r\ndev_dbg(dev->dev, "write data[%x] 0x%04x\n", i, data[i]);\r\n}\r\nif (highlander_i2c_wait_for_bbsy(dev))\r\nreturn -EAGAIN;\r\nhighlander_i2c_start(dev);\r\nreturn highlander_i2c_wait_xfer_done(dev);\r\n}\r\nstatic int highlander_i2c_smbus_xfer(struct i2c_adapter *adap, u16 addr,\r\nunsigned short flags, char read_write,\r\nu8 command, int size,\r\nunion i2c_smbus_data *data)\r\n{\r\nstruct highlander_i2c_dev *dev = i2c_get_adapdata(adap);\r\nu16 tmp;\r\ninit_completion(&dev->cmd_complete);\r\ndev_dbg(dev->dev, "addr %04x, command %02x, read_write %d, size %d\n",\r\naddr, command, read_write, size);\r\nswitch (size) {\r\ncase I2C_SMBUS_BYTE_DATA:\r\ndev->buf = &data->byte;\r\ndev->buf_len = 1;\r\nbreak;\r\ncase I2C_SMBUS_I2C_BLOCK_DATA:\r\ndev->buf = &data->block[1];\r\ndev->buf_len = data->block[0];\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "unsupported command %d\n", size);\r\nreturn -EINVAL;\r\n}\r\ntmp = ioread16(dev->base + SMMR);\r\ntmp &= ~(SMMR_MODE0 | SMMR_MODE1);\r\nswitch (dev->buf_len) {\r\ncase 1:\r\nbreak;\r\ncase 8:\r\ntmp |= SMMR_MODE0;\r\nbreak;\r\ncase 16:\r\ntmp |= SMMR_MODE1;\r\nbreak;\r\ncase 32:\r\ntmp |= (SMMR_MODE0 | SMMR_MODE1);\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "unsupported xfer size %d\n", dev->buf_len);\r\nreturn -EINVAL;\r\n}\r\niowrite16(tmp, dev->base + SMMR);\r\nhighlander_i2c_done(dev);\r\niowrite16((addr << 1) | read_write, dev->base + SMSMADR);\r\nhighlander_i2c_command(dev, command, dev->buf_len);\r\nif (read_write == I2C_SMBUS_READ)\r\nreturn highlander_i2c_read(dev);\r\nelse\r\nreturn highlander_i2c_write(dev);\r\n}\r\nstatic u32 highlander_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_I2C_BLOCK;\r\n}\r\nstatic int __devinit highlander_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct highlander_i2c_dev *dev;\r\nstruct i2c_adapter *adap;\r\nstruct resource *res;\r\nint ret;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(!res)) {\r\ndev_err(&pdev->dev, "no mem resource\n");\r\nreturn -ENODEV;\r\n}\r\ndev = kzalloc(sizeof(struct highlander_i2c_dev), GFP_KERNEL);\r\nif (unlikely(!dev))\r\nreturn -ENOMEM;\r\ndev->base = ioremap_nocache(res->start, resource_size(res));\r\nif (unlikely(!dev->base)) {\r\nret = -ENXIO;\r\ngoto err;\r\n}\r\ndev->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, dev);\r\ndev->irq = platform_get_irq(pdev, 0);\r\nif (iic_force_poll)\r\ndev->irq = 0;\r\nif (dev->irq) {\r\nret = request_irq(dev->irq, highlander_i2c_irq, 0,\r\npdev->name, dev);\r\nif (unlikely(ret))\r\ngoto err_unmap;\r\nhighlander_i2c_irq_enable(dev);\r\n} else {\r\ndev_notice(&pdev->dev, "no IRQ, using polling mode\n");\r\nhighlander_i2c_irq_disable(dev);\r\n}\r\ndev->last_read_time = jiffies;\r\nhighlander_i2c_setup(dev);\r\nadap = &dev->adapter;\r\ni2c_set_adapdata(adap, dev);\r\nadap->owner = THIS_MODULE;\r\nadap->class = I2C_CLASS_HWMON;\r\nstrlcpy(adap->name, "HL FPGA I2C adapter", sizeof(adap->name));\r\nadap->algo = &highlander_i2c_algo;\r\nadap->dev.parent = &pdev->dev;\r\nadap->nr = pdev->id;\r\nret = highlander_i2c_reset(dev);\r\nif (unlikely(ret)) {\r\ndev_err(&pdev->dev, "controller didn't come up\n");\r\ngoto err_free_irq;\r\n}\r\nret = i2c_add_numbered_adapter(adap);\r\nif (unlikely(ret)) {\r\ndev_err(&pdev->dev, "failure adding adapter\n");\r\ngoto err_free_irq;\r\n}\r\nreturn 0;\r\nerr_free_irq:\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nerr_unmap:\r\niounmap(dev->base);\r\nerr:\r\nkfree(dev);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn ret;\r\n}\r\nstatic int __devexit highlander_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct highlander_i2c_dev *dev = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&dev->adapter);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\niounmap(dev->base);\r\nkfree(dev);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
