static void netdev_port_receive(struct vport *vport, struct sk_buff *skb)\r\n{\r\nif (unlikely(!vport)) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (unlikely(!skb))\r\nreturn;\r\nskb_push(skb, ETH_HLEN);\r\novs_vport_receive(vport, skb);\r\n}\r\nstatic rx_handler_result_t netdev_frame_hook(struct sk_buff **pskb)\r\n{\r\nstruct sk_buff *skb = *pskb;\r\nstruct vport *vport;\r\nif (unlikely(skb->pkt_type == PACKET_LOOPBACK))\r\nreturn RX_HANDLER_PASS;\r\nvport = ovs_netdev_get_vport(skb->dev);\r\nnetdev_port_receive(vport, skb);\r\nreturn RX_HANDLER_CONSUMED;\r\n}\r\nstatic struct vport *netdev_create(const struct vport_parms *parms)\r\n{\r\nstruct vport *vport;\r\nstruct netdev_vport *netdev_vport;\r\nint err;\r\nvport = ovs_vport_alloc(sizeof(struct netdev_vport),\r\n&ovs_netdev_vport_ops, parms);\r\nif (IS_ERR(vport)) {\r\nerr = PTR_ERR(vport);\r\ngoto error;\r\n}\r\nnetdev_vport = netdev_vport_priv(vport);\r\nnetdev_vport->dev = dev_get_by_name(&init_net, parms->name);\r\nif (!netdev_vport->dev) {\r\nerr = -ENODEV;\r\ngoto error_free_vport;\r\n}\r\nif (netdev_vport->dev->flags & IFF_LOOPBACK ||\r\nnetdev_vport->dev->type != ARPHRD_ETHER ||\r\novs_is_internal_dev(netdev_vport->dev)) {\r\nerr = -EINVAL;\r\ngoto error_put;\r\n}\r\nerr = netdev_rx_handler_register(netdev_vport->dev, netdev_frame_hook,\r\nvport);\r\nif (err)\r\ngoto error_put;\r\ndev_set_promiscuity(netdev_vport->dev, 1);\r\nnetdev_vport->dev->priv_flags |= IFF_OVS_DATAPATH;\r\nreturn vport;\r\nerror_put:\r\ndev_put(netdev_vport->dev);\r\nerror_free_vport:\r\novs_vport_free(vport);\r\nerror:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void netdev_destroy(struct vport *vport)\r\n{\r\nstruct netdev_vport *netdev_vport = netdev_vport_priv(vport);\r\nnetdev_vport->dev->priv_flags &= ~IFF_OVS_DATAPATH;\r\nnetdev_rx_handler_unregister(netdev_vport->dev);\r\ndev_set_promiscuity(netdev_vport->dev, -1);\r\nsynchronize_rcu();\r\ndev_put(netdev_vport->dev);\r\novs_vport_free(vport);\r\n}\r\nconst char *ovs_netdev_get_name(const struct vport *vport)\r\n{\r\nconst struct netdev_vport *netdev_vport = netdev_vport_priv(vport);\r\nreturn netdev_vport->dev->name;\r\n}\r\nint ovs_netdev_get_ifindex(const struct vport *vport)\r\n{\r\nconst struct netdev_vport *netdev_vport = netdev_vport_priv(vport);\r\nreturn netdev_vport->dev->ifindex;\r\n}\r\nstatic unsigned packet_length(const struct sk_buff *skb)\r\n{\r\nunsigned length = skb->len - ETH_HLEN;\r\nif (skb->protocol == htons(ETH_P_8021Q))\r\nlength -= VLAN_HLEN;\r\nreturn length;\r\n}\r\nstatic int netdev_send(struct vport *vport, struct sk_buff *skb)\r\n{\r\nstruct netdev_vport *netdev_vport = netdev_vport_priv(vport);\r\nint mtu = netdev_vport->dev->mtu;\r\nint len;\r\nif (unlikely(packet_length(skb) > mtu && !skb_is_gso(skb))) {\r\nif (net_ratelimit())\r\npr_warn("%s: dropped over-mtu packet: %d > %d\n",\r\novs_dp_name(vport->dp), packet_length(skb), mtu);\r\ngoto error;\r\n}\r\nif (unlikely(skb_warn_if_lro(skb)))\r\ngoto error;\r\nskb->dev = netdev_vport->dev;\r\nlen = skb->len;\r\ndev_queue_xmit(skb);\r\nreturn len;\r\nerror:\r\nkfree_skb(skb);\r\novs_vport_record_error(vport, VPORT_E_TX_DROPPED);\r\nreturn 0;\r\n}\r\nstruct vport *ovs_netdev_get_vport(struct net_device *dev)\r\n{\r\nif (likely(dev->priv_flags & IFF_OVS_DATAPATH))\r\nreturn (struct vport *)\r\nrcu_dereference_rtnl(dev->rx_handler_data);\r\nelse\r\nreturn NULL;\r\n}
