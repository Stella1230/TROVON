static __init int setup_nointremap(char *str)\r\n{\r\ndisable_intremap = 1;\r\nreturn 0;\r\n}\r\nstatic __init int setup_intremap(char *str)\r\n{\r\nif (!str)\r\nreturn -EINVAL;\r\nwhile (*str) {\r\nif (!strncmp(str, "on", 2))\r\ndisable_intremap = 0;\r\nelse if (!strncmp(str, "off", 3))\r\ndisable_intremap = 1;\r\nelse if (!strncmp(str, "nosid", 5))\r\ndisable_sourceid_checking = 1;\r\nelse if (!strncmp(str, "no_x2apic_optout", 16))\r\nno_x2apic_optout = 1;\r\nstr += strcspn(str, ",");\r\nwhile (*str == ',')\r\nstr++;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct irq_2_iommu *irq_2_iommu(unsigned int irq)\r\n{\r\nstruct irq_cfg *cfg = irq_get_chip_data(irq);\r\nreturn cfg ? &cfg->irq_2_iommu : NULL;\r\n}\r\nint get_irte(int irq, struct irte *entry)\r\n{\r\nstruct irq_2_iommu *irq_iommu = irq_2_iommu(irq);\r\nunsigned long flags;\r\nint index;\r\nif (!entry || !irq_iommu)\r\nreturn -1;\r\nraw_spin_lock_irqsave(&irq_2_ir_lock, flags);\r\nindex = irq_iommu->irte_index + irq_iommu->sub_handle;\r\n*entry = *(irq_iommu->iommu->ir_table->base + index);\r\nraw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\r\nreturn 0;\r\n}\r\nint alloc_irte(struct intel_iommu *iommu, int irq, u16 count)\r\n{\r\nstruct ir_table *table = iommu->ir_table;\r\nstruct irq_2_iommu *irq_iommu = irq_2_iommu(irq);\r\nu16 index, start_index;\r\nunsigned int mask = 0;\r\nunsigned long flags;\r\nint i;\r\nif (!count || !irq_iommu)\r\nreturn -1;\r\nindex = start_index = 0;\r\nif (count > 1) {\r\ncount = __roundup_pow_of_two(count);\r\nmask = ilog2(count);\r\n}\r\nif (mask > ecap_max_handle_mask(iommu->ecap)) {\r\nprintk(KERN_ERR\r\n"Requested mask %x exceeds the max invalidation handle"\r\n" mask value %Lx\n", mask,\r\necap_max_handle_mask(iommu->ecap));\r\nreturn -1;\r\n}\r\nraw_spin_lock_irqsave(&irq_2_ir_lock, flags);\r\ndo {\r\nfor (i = index; i < index + count; i++)\r\nif (table->base[i].present)\r\nbreak;\r\nif (i == index + count)\r\nbreak;\r\nindex = (index + count) % INTR_REMAP_TABLE_ENTRIES;\r\nif (index == start_index) {\r\nraw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\r\nprintk(KERN_ERR "can't allocate an IRTE\n");\r\nreturn -1;\r\n}\r\n} while (1);\r\nfor (i = index; i < index + count; i++)\r\ntable->base[i].present = 1;\r\nirq_iommu->iommu = iommu;\r\nirq_iommu->irte_index = index;\r\nirq_iommu->sub_handle = 0;\r\nirq_iommu->irte_mask = mask;\r\nraw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\r\nreturn index;\r\n}\r\nstatic int qi_flush_iec(struct intel_iommu *iommu, int index, int mask)\r\n{\r\nstruct qi_desc desc;\r\ndesc.low = QI_IEC_IIDEX(index) | QI_IEC_TYPE | QI_IEC_IM(mask)\r\n| QI_IEC_SELECTIVE;\r\ndesc.high = 0;\r\nreturn qi_submit_sync(&desc, iommu);\r\n}\r\nint map_irq_to_irte_handle(int irq, u16 *sub_handle)\r\n{\r\nstruct irq_2_iommu *irq_iommu = irq_2_iommu(irq);\r\nunsigned long flags;\r\nint index;\r\nif (!irq_iommu)\r\nreturn -1;\r\nraw_spin_lock_irqsave(&irq_2_ir_lock, flags);\r\n*sub_handle = irq_iommu->sub_handle;\r\nindex = irq_iommu->irte_index;\r\nraw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\r\nreturn index;\r\n}\r\nint set_irte_irq(int irq, struct intel_iommu *iommu, u16 index, u16 subhandle)\r\n{\r\nstruct irq_2_iommu *irq_iommu = irq_2_iommu(irq);\r\nunsigned long flags;\r\nif (!irq_iommu)\r\nreturn -1;\r\nraw_spin_lock_irqsave(&irq_2_ir_lock, flags);\r\nirq_iommu->iommu = iommu;\r\nirq_iommu->irte_index = index;\r\nirq_iommu->sub_handle = subhandle;\r\nirq_iommu->irte_mask = 0;\r\nraw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\r\nreturn 0;\r\n}\r\nint modify_irte(int irq, struct irte *irte_modified)\r\n{\r\nstruct irq_2_iommu *irq_iommu = irq_2_iommu(irq);\r\nstruct intel_iommu *iommu;\r\nunsigned long flags;\r\nstruct irte *irte;\r\nint rc, index;\r\nif (!irq_iommu)\r\nreturn -1;\r\nraw_spin_lock_irqsave(&irq_2_ir_lock, flags);\r\niommu = irq_iommu->iommu;\r\nindex = irq_iommu->irte_index + irq_iommu->sub_handle;\r\nirte = &iommu->ir_table->base[index];\r\nset_64bit(&irte->low, irte_modified->low);\r\nset_64bit(&irte->high, irte_modified->high);\r\n__iommu_flush_cache(iommu, irte, sizeof(*irte));\r\nrc = qi_flush_iec(iommu, index, 0);\r\nraw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\r\nreturn rc;\r\n}\r\nstruct intel_iommu *map_hpet_to_ir(u8 hpet_id)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_HPET_TBS; i++)\r\nif (ir_hpet[i].id == hpet_id)\r\nreturn ir_hpet[i].iommu;\r\nreturn NULL;\r\n}\r\nstruct intel_iommu *map_ioapic_to_ir(int apic)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_IO_APICS; i++)\r\nif (ir_ioapic[i].id == apic)\r\nreturn ir_ioapic[i].iommu;\r\nreturn NULL;\r\n}\r\nstruct intel_iommu *map_dev_to_ir(struct pci_dev *dev)\r\n{\r\nstruct dmar_drhd_unit *drhd;\r\ndrhd = dmar_find_matched_drhd_unit(dev);\r\nif (!drhd)\r\nreturn NULL;\r\nreturn drhd->iommu;\r\n}\r\nstatic int clear_entries(struct irq_2_iommu *irq_iommu)\r\n{\r\nstruct irte *start, *entry, *end;\r\nstruct intel_iommu *iommu;\r\nint index;\r\nif (irq_iommu->sub_handle)\r\nreturn 0;\r\niommu = irq_iommu->iommu;\r\nindex = irq_iommu->irte_index + irq_iommu->sub_handle;\r\nstart = iommu->ir_table->base + index;\r\nend = start + (1 << irq_iommu->irte_mask);\r\nfor (entry = start; entry < end; entry++) {\r\nset_64bit(&entry->low, 0);\r\nset_64bit(&entry->high, 0);\r\n}\r\nreturn qi_flush_iec(iommu, index, irq_iommu->irte_mask);\r\n}\r\nint free_irte(int irq)\r\n{\r\nstruct irq_2_iommu *irq_iommu = irq_2_iommu(irq);\r\nunsigned long flags;\r\nint rc;\r\nif (!irq_iommu)\r\nreturn -1;\r\nraw_spin_lock_irqsave(&irq_2_ir_lock, flags);\r\nrc = clear_entries(irq_iommu);\r\nirq_iommu->iommu = NULL;\r\nirq_iommu->irte_index = 0;\r\nirq_iommu->sub_handle = 0;\r\nirq_iommu->irte_mask = 0;\r\nraw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\r\nreturn rc;\r\n}\r\nstatic void set_irte_sid(struct irte *irte, unsigned int svt,\r\nunsigned int sq, unsigned int sid)\r\n{\r\nif (disable_sourceid_checking)\r\nsvt = SVT_NO_VERIFY;\r\nirte->svt = svt;\r\nirte->sq = sq;\r\nirte->sid = sid;\r\n}\r\nint set_ioapic_sid(struct irte *irte, int apic)\r\n{\r\nint i;\r\nu16 sid = 0;\r\nif (!irte)\r\nreturn -1;\r\nfor (i = 0; i < MAX_IO_APICS; i++) {\r\nif (ir_ioapic[i].id == apic) {\r\nsid = (ir_ioapic[i].bus << 8) | ir_ioapic[i].devfn;\r\nbreak;\r\n}\r\n}\r\nif (sid == 0) {\r\npr_warning("Failed to set source-id of IOAPIC (%d)\n", apic);\r\nreturn -1;\r\n}\r\nset_irte_sid(irte, 1, 0, sid);\r\nreturn 0;\r\n}\r\nint set_hpet_sid(struct irte *irte, u8 id)\r\n{\r\nint i;\r\nu16 sid = 0;\r\nif (!irte)\r\nreturn -1;\r\nfor (i = 0; i < MAX_HPET_TBS; i++) {\r\nif (ir_hpet[i].id == id) {\r\nsid = (ir_hpet[i].bus << 8) | ir_hpet[i].devfn;\r\nbreak;\r\n}\r\n}\r\nif (sid == 0) {\r\npr_warning("Failed to set source-id of HPET block (%d)\n", id);\r\nreturn -1;\r\n}\r\nset_irte_sid(irte, SVT_VERIFY_SID_SQ, SQ_13_IGNORE_3, sid);\r\nreturn 0;\r\n}\r\nint set_msi_sid(struct irte *irte, struct pci_dev *dev)\r\n{\r\nstruct pci_dev *bridge;\r\nif (!irte || !dev)\r\nreturn -1;\r\nif (pci_is_pcie(dev) || !dev->bus->parent) {\r\nset_irte_sid(irte, SVT_VERIFY_SID_SQ, SQ_ALL_16,\r\n(dev->bus->number << 8) | dev->devfn);\r\nreturn 0;\r\n}\r\nbridge = pci_find_upstream_pcie_bridge(dev);\r\nif (bridge) {\r\nif (pci_is_pcie(bridge))\r\nset_irte_sid(irte, SVT_VERIFY_BUS, SQ_ALL_16,\r\n(bridge->bus->number << 8) | dev->bus->number);\r\nelse\r\nset_irte_sid(irte, SVT_VERIFY_SID_SQ, SQ_ALL_16,\r\n(bridge->bus->number << 8) | bridge->devfn);\r\n}\r\nreturn 0;\r\n}\r\nstatic void iommu_set_intr_remapping(struct intel_iommu *iommu, int mode)\r\n{\r\nu64 addr;\r\nu32 sts;\r\nunsigned long flags;\r\naddr = virt_to_phys((void *)iommu->ir_table->base);\r\nraw_spin_lock_irqsave(&iommu->register_lock, flags);\r\ndmar_writeq(iommu->reg + DMAR_IRTA_REG,\r\n(addr) | IR_X2APIC_MODE(mode) | INTR_REMAP_TABLE_REG_SIZE);\r\niommu->gcmd |= DMA_GCMD_SIRTP;\r\nwritel(iommu->gcmd, iommu->reg + DMAR_GCMD_REG);\r\nIOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,\r\nreadl, (sts & DMA_GSTS_IRTPS), sts);\r\nraw_spin_unlock_irqrestore(&iommu->register_lock, flags);\r\nqi_global_iec(iommu);\r\nraw_spin_lock_irqsave(&iommu->register_lock, flags);\r\niommu->gcmd |= DMA_GCMD_IRE;\r\nwritel(iommu->gcmd, iommu->reg + DMAR_GCMD_REG);\r\nIOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,\r\nreadl, (sts & DMA_GSTS_IRES), sts);\r\nraw_spin_unlock_irqrestore(&iommu->register_lock, flags);\r\n}\r\nstatic int setup_intr_remapping(struct intel_iommu *iommu, int mode)\r\n{\r\nstruct ir_table *ir_table;\r\nstruct page *pages;\r\nir_table = iommu->ir_table = kzalloc(sizeof(struct ir_table),\r\nGFP_ATOMIC);\r\nif (!iommu->ir_table)\r\nreturn -ENOMEM;\r\npages = alloc_pages_node(iommu->node, GFP_ATOMIC | __GFP_ZERO,\r\nINTR_REMAP_PAGE_ORDER);\r\nif (!pages) {\r\nprintk(KERN_ERR "failed to allocate pages of order %d\n",\r\nINTR_REMAP_PAGE_ORDER);\r\nkfree(iommu->ir_table);\r\nreturn -ENOMEM;\r\n}\r\nir_table->base = page_address(pages);\r\niommu_set_intr_remapping(iommu, mode);\r\nreturn 0;\r\n}\r\nstatic void iommu_disable_intr_remapping(struct intel_iommu *iommu)\r\n{\r\nunsigned long flags;\r\nu32 sts;\r\nif (!ecap_ir_support(iommu->ecap))\r\nreturn;\r\nqi_global_iec(iommu);\r\nraw_spin_lock_irqsave(&iommu->register_lock, flags);\r\nsts = dmar_readq(iommu->reg + DMAR_GSTS_REG);\r\nif (!(sts & DMA_GSTS_IRES))\r\ngoto end;\r\niommu->gcmd &= ~DMA_GCMD_IRE;\r\nwritel(iommu->gcmd, iommu->reg + DMAR_GCMD_REG);\r\nIOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,\r\nreadl, !(sts & DMA_GSTS_IRES), sts);\r\nend:\r\nraw_spin_unlock_irqrestore(&iommu->register_lock, flags);\r\n}\r\nstatic int __init dmar_x2apic_optout(void)\r\n{\r\nstruct acpi_table_dmar *dmar;\r\ndmar = (struct acpi_table_dmar *)dmar_tbl;\r\nif (!dmar || no_x2apic_optout)\r\nreturn 0;\r\nreturn dmar->flags & DMAR_X2APIC_OPT_OUT;\r\n}\r\nint __init intr_remapping_supported(void)\r\n{\r\nstruct dmar_drhd_unit *drhd;\r\nif (disable_intremap)\r\nreturn 0;\r\nif (!dmar_ir_support())\r\nreturn 0;\r\nfor_each_drhd_unit(drhd) {\r\nstruct intel_iommu *iommu = drhd->iommu;\r\nif (!ecap_ir_support(iommu->ecap))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint __init enable_intr_remapping(void)\r\n{\r\nstruct dmar_drhd_unit *drhd;\r\nint setup = 0;\r\nint eim = 0;\r\nif (parse_ioapics_under_ir() != 1) {\r\nprintk(KERN_INFO "Not enable interrupt remapping\n");\r\nreturn -1;\r\n}\r\nif (x2apic_supported()) {\r\neim = !dmar_x2apic_optout();\r\nWARN(!eim, KERN_WARNING\r\n"Your BIOS is broken and requested that x2apic be disabled\n"\r\n"This will leave your machine vulnerable to irq-injection attacks\n"\r\n"Use 'intremap=no_x2apic_optout' to override BIOS request\n");\r\n}\r\nfor_each_drhd_unit(drhd) {\r\nstruct intel_iommu *iommu = drhd->iommu;\r\nif (iommu->qi)\r\ncontinue;\r\ndmar_fault(-1, iommu);\r\niommu_disable_intr_remapping(iommu);\r\ndmar_disable_qi(iommu);\r\n}\r\nfor_each_drhd_unit(drhd) {\r\nstruct intel_iommu *iommu = drhd->iommu;\r\nif (!ecap_ir_support(iommu->ecap))\r\ncontinue;\r\nif (eim && !ecap_eim_support(iommu->ecap)) {\r\nprintk(KERN_INFO "DRHD %Lx: EIM not supported by DRHD, "\r\n" ecap %Lx\n", drhd->reg_base_addr, iommu->ecap);\r\nreturn -1;\r\n}\r\n}\r\nfor_each_drhd_unit(drhd) {\r\nint ret;\r\nstruct intel_iommu *iommu = drhd->iommu;\r\nret = dmar_enable_qi(iommu);\r\nif (ret) {\r\nprintk(KERN_ERR "DRHD %Lx: failed to enable queued, "\r\n" invalidation, ecap %Lx, ret %d\n",\r\ndrhd->reg_base_addr, iommu->ecap, ret);\r\nreturn -1;\r\n}\r\n}\r\nfor_each_drhd_unit(drhd) {\r\nstruct intel_iommu *iommu = drhd->iommu;\r\nif (!ecap_ir_support(iommu->ecap))\r\ncontinue;\r\nif (setup_intr_remapping(iommu, eim))\r\ngoto error;\r\nsetup = 1;\r\n}\r\nif (!setup)\r\ngoto error;\r\nintr_remapping_enabled = 1;\r\npr_info("Enabled IRQ remapping in %s mode\n", eim ? "x2apic" : "xapic");\r\nreturn eim ? IRQ_REMAP_X2APIC_MODE : IRQ_REMAP_XAPIC_MODE;\r\nerror:\r\nreturn -1;\r\n}\r\nstatic void ir_parse_one_hpet_scope(struct acpi_dmar_device_scope *scope,\r\nstruct intel_iommu *iommu)\r\n{\r\nstruct acpi_dmar_pci_path *path;\r\nu8 bus;\r\nint count;\r\nbus = scope->bus;\r\npath = (struct acpi_dmar_pci_path *)(scope + 1);\r\ncount = (scope->length - sizeof(struct acpi_dmar_device_scope))\r\n/ sizeof(struct acpi_dmar_pci_path);\r\nwhile (--count > 0) {\r\nbus = read_pci_config_byte(bus, path->dev, path->fn,\r\nPCI_SECONDARY_BUS);\r\npath++;\r\n}\r\nir_hpet[ir_hpet_num].bus = bus;\r\nir_hpet[ir_hpet_num].devfn = PCI_DEVFN(path->dev, path->fn);\r\nir_hpet[ir_hpet_num].iommu = iommu;\r\nir_hpet[ir_hpet_num].id = scope->enumeration_id;\r\nir_hpet_num++;\r\n}\r\nstatic void ir_parse_one_ioapic_scope(struct acpi_dmar_device_scope *scope,\r\nstruct intel_iommu *iommu)\r\n{\r\nstruct acpi_dmar_pci_path *path;\r\nu8 bus;\r\nint count;\r\nbus = scope->bus;\r\npath = (struct acpi_dmar_pci_path *)(scope + 1);\r\ncount = (scope->length - sizeof(struct acpi_dmar_device_scope))\r\n/ sizeof(struct acpi_dmar_pci_path);\r\nwhile (--count > 0) {\r\nbus = read_pci_config_byte(bus, path->dev, path->fn,\r\nPCI_SECONDARY_BUS);\r\npath++;\r\n}\r\nir_ioapic[ir_ioapic_num].bus = bus;\r\nir_ioapic[ir_ioapic_num].devfn = PCI_DEVFN(path->dev, path->fn);\r\nir_ioapic[ir_ioapic_num].iommu = iommu;\r\nir_ioapic[ir_ioapic_num].id = scope->enumeration_id;\r\nir_ioapic_num++;\r\n}\r\nstatic int ir_parse_ioapic_hpet_scope(struct acpi_dmar_header *header,\r\nstruct intel_iommu *iommu)\r\n{\r\nstruct acpi_dmar_hardware_unit *drhd;\r\nstruct acpi_dmar_device_scope *scope;\r\nvoid *start, *end;\r\ndrhd = (struct acpi_dmar_hardware_unit *)header;\r\nstart = (void *)(drhd + 1);\r\nend = ((void *)drhd) + header->length;\r\nwhile (start < end) {\r\nscope = start;\r\nif (scope->entry_type == ACPI_DMAR_SCOPE_TYPE_IOAPIC) {\r\nif (ir_ioapic_num == MAX_IO_APICS) {\r\nprintk(KERN_WARNING "Exceeded Max IO APICS\n");\r\nreturn -1;\r\n}\r\nprintk(KERN_INFO "IOAPIC id %d under DRHD base "\r\n" 0x%Lx IOMMU %d\n", scope->enumeration_id,\r\ndrhd->address, iommu->seq_id);\r\nir_parse_one_ioapic_scope(scope, iommu);\r\n} else if (scope->entry_type == ACPI_DMAR_SCOPE_TYPE_HPET) {\r\nif (ir_hpet_num == MAX_HPET_TBS) {\r\nprintk(KERN_WARNING "Exceeded Max HPET blocks\n");\r\nreturn -1;\r\n}\r\nprintk(KERN_INFO "HPET id %d under DRHD base"\r\n" 0x%Lx\n", scope->enumeration_id,\r\ndrhd->address);\r\nir_parse_one_hpet_scope(scope, iommu);\r\n}\r\nstart += scope->length;\r\n}\r\nreturn 0;\r\n}\r\nint __init parse_ioapics_under_ir(void)\r\n{\r\nstruct dmar_drhd_unit *drhd;\r\nint ir_supported = 0;\r\nfor_each_drhd_unit(drhd) {\r\nstruct intel_iommu *iommu = drhd->iommu;\r\nif (ecap_ir_support(iommu->ecap)) {\r\nif (ir_parse_ioapic_hpet_scope(drhd->hdr, iommu))\r\nreturn -1;\r\nir_supported = 1;\r\n}\r\n}\r\nif (ir_supported && ir_ioapic_num != nr_ioapics) {\r\nprintk(KERN_WARNING\r\n"Not all IO-APIC's listed under remapping hardware\n");\r\nreturn -1;\r\n}\r\nreturn ir_supported;\r\n}\r\nint __init ir_dev_scope_init(void)\r\n{\r\nif (!intr_remapping_enabled)\r\nreturn 0;\r\nreturn dmar_dev_scope_init();\r\n}\r\nvoid disable_intr_remapping(void)\r\n{\r\nstruct dmar_drhd_unit *drhd;\r\nstruct intel_iommu *iommu = NULL;\r\nfor_each_iommu(iommu, drhd) {\r\nif (!ecap_ir_support(iommu->ecap))\r\ncontinue;\r\niommu_disable_intr_remapping(iommu);\r\n}\r\n}\r\nint reenable_intr_remapping(int eim)\r\n{\r\nstruct dmar_drhd_unit *drhd;\r\nint setup = 0;\r\nstruct intel_iommu *iommu = NULL;\r\nfor_each_iommu(iommu, drhd)\r\nif (iommu->qi)\r\ndmar_reenable_qi(iommu);\r\nfor_each_iommu(iommu, drhd) {\r\nif (!ecap_ir_support(iommu->ecap))\r\ncontinue;\r\niommu_set_intr_remapping(iommu, eim);\r\nsetup = 1;\r\n}\r\nif (!setup)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nreturn -1;\r\n}
