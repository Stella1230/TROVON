static int __init\r\nx86_get_mtrr_mem_range(struct range *range, int nr_range,\r\nunsigned long extra_remove_base,\r\nunsigned long extra_remove_size)\r\n{\r\nunsigned long base, size;\r\nmtrr_type type;\r\nint i;\r\nfor (i = 0; i < num_var_ranges; i++) {\r\ntype = range_state[i].type;\r\nif (type != MTRR_TYPE_WRBACK)\r\ncontinue;\r\nbase = range_state[i].base_pfn;\r\nsize = range_state[i].size_pfn;\r\nnr_range = add_range_with_merge(range, RANGE_NUM, nr_range,\r\nbase, base + size);\r\n}\r\nif (debug_print) {\r\nprintk(KERN_DEBUG "After WB checking\n");\r\nfor (i = 0; i < nr_range; i++)\r\nprintk(KERN_DEBUG "MTRR MAP PFN: %016llx - %016llx\n",\r\nrange[i].start, range[i].end);\r\n}\r\nfor (i = 0; i < num_var_ranges; i++) {\r\ntype = range_state[i].type;\r\nif (type != MTRR_TYPE_UNCACHABLE &&\r\ntype != MTRR_TYPE_WRPROT)\r\ncontinue;\r\nsize = range_state[i].size_pfn;\r\nif (!size)\r\ncontinue;\r\nbase = range_state[i].base_pfn;\r\nif (base < (1<<(20-PAGE_SHIFT)) && mtrr_state.have_fixed &&\r\n(mtrr_state.enabled & 1)) {\r\nprintk(BIOS_BUG_MSG, i);\r\nif (base + size <= (1<<(20-PAGE_SHIFT)))\r\ncontinue;\r\nsize -= (1<<(20-PAGE_SHIFT)) - base;\r\nbase = 1<<(20-PAGE_SHIFT);\r\n}\r\nsubtract_range(range, RANGE_NUM, base, base + size);\r\n}\r\nif (extra_remove_size)\r\nsubtract_range(range, RANGE_NUM, extra_remove_base,\r\nextra_remove_base + extra_remove_size);\r\nif (debug_print) {\r\nprintk(KERN_DEBUG "After UC checking\n");\r\nfor (i = 0; i < RANGE_NUM; i++) {\r\nif (!range[i].end)\r\ncontinue;\r\nprintk(KERN_DEBUG "MTRR MAP PFN: %016llx - %016llx\n",\r\nrange[i].start, range[i].end);\r\n}\r\n}\r\nnr_range = clean_sort_range(range, RANGE_NUM);\r\nif (debug_print) {\r\nprintk(KERN_DEBUG "After sorting\n");\r\nfor (i = 0; i < nr_range; i++)\r\nprintk(KERN_DEBUG "MTRR MAP PFN: %016llx - %016llx\n",\r\nrange[i].start, range[i].end);\r\n}\r\nreturn nr_range;\r\n}\r\nstatic unsigned long __init sum_ranges(struct range *range, int nr_range)\r\n{\r\nunsigned long sum = 0;\r\nint i;\r\nfor (i = 0; i < nr_range; i++)\r\nsum += range[i].end - range[i].start;\r\nreturn sum;\r\n}\r\nstatic int __init disable_mtrr_cleanup_setup(char *str)\r\n{\r\nenable_mtrr_cleanup = 0;\r\nreturn 0;\r\n}\r\nstatic int __init enable_mtrr_cleanup_setup(char *str)\r\n{\r\nenable_mtrr_cleanup = 1;\r\nreturn 0;\r\n}\r\nstatic int __init mtrr_cleanup_debug_setup(char *str)\r\n{\r\ndebug_print = 1;\r\nreturn 0;\r\n}\r\nstatic void __init\r\nset_var_mtrr(unsigned int reg, unsigned long basek, unsigned long sizek,\r\nunsigned char type, unsigned int address_bits)\r\n{\r\nu32 base_lo, base_hi, mask_lo, mask_hi;\r\nu64 base, mask;\r\nif (!sizek) {\r\nfill_mtrr_var_range(reg, 0, 0, 0, 0);\r\nreturn;\r\n}\r\nmask = (1ULL << address_bits) - 1;\r\nmask &= ~((((u64)sizek) << 10) - 1);\r\nbase = ((u64)basek) << 10;\r\nbase |= type;\r\nmask |= 0x800;\r\nbase_lo = base & ((1ULL<<32) - 1);\r\nbase_hi = base >> 32;\r\nmask_lo = mask & ((1ULL<<32) - 1);\r\nmask_hi = mask >> 32;\r\nfill_mtrr_var_range(reg, base_lo, base_hi, mask_lo, mask_hi);\r\n}\r\nstatic void __init\r\nsave_var_mtrr(unsigned int reg, unsigned long basek, unsigned long sizek,\r\nunsigned char type)\r\n{\r\nrange_state[reg].base_pfn = basek >> (PAGE_SHIFT - 10);\r\nrange_state[reg].size_pfn = sizek >> (PAGE_SHIFT - 10);\r\nrange_state[reg].type = type;\r\n}\r\nstatic void __init set_var_mtrr_all(unsigned int address_bits)\r\n{\r\nunsigned long basek, sizek;\r\nunsigned char type;\r\nunsigned int reg;\r\nfor (reg = 0; reg < num_var_ranges; reg++) {\r\nbasek = range_state[reg].base_pfn << (PAGE_SHIFT - 10);\r\nsizek = range_state[reg].size_pfn << (PAGE_SHIFT - 10);\r\ntype = range_state[reg].type;\r\nset_var_mtrr(reg, basek, sizek, type, address_bits);\r\n}\r\n}\r\nstatic unsigned long to_size_factor(unsigned long sizek, char *factorp)\r\n{\r\nunsigned long base = sizek;\r\nchar factor;\r\nif (base & ((1<<10) - 1)) {\r\nfactor = 'K';\r\n} else if (base & ((1<<20) - 1)) {\r\nfactor = 'M';\r\nbase >>= 10;\r\n} else {\r\nfactor = 'G';\r\nbase >>= 20;\r\n}\r\n*factorp = factor;\r\nreturn base;\r\n}\r\nstatic unsigned int __init\r\nrange_to_mtrr(unsigned int reg, unsigned long range_startk,\r\nunsigned long range_sizek, unsigned char type)\r\n{\r\nif (!range_sizek || (reg >= num_var_ranges))\r\nreturn reg;\r\nwhile (range_sizek) {\r\nunsigned long max_align, align;\r\nunsigned long sizek;\r\nif (range_startk)\r\nmax_align = ffs(range_startk) - 1;\r\nelse\r\nmax_align = 32;\r\nalign = fls(range_sizek) - 1;\r\nif (align > max_align)\r\nalign = max_align;\r\nsizek = 1 << align;\r\nif (debug_print) {\r\nchar start_factor = 'K', size_factor = 'K';\r\nunsigned long start_base, size_base;\r\nstart_base = to_size_factor(range_startk, &start_factor);\r\nsize_base = to_size_factor(sizek, &size_factor);\r\nDprintk("Setting variable MTRR %d, "\r\n"base: %ld%cB, range: %ld%cB, type %s\n",\r\nreg, start_base, start_factor,\r\nsize_base, size_factor,\r\n(type == MTRR_TYPE_UNCACHABLE) ? "UC" :\r\n((type == MTRR_TYPE_WRBACK) ? "WB" : "Other")\r\n);\r\n}\r\nsave_var_mtrr(reg++, range_startk, sizek, type);\r\nrange_startk += sizek;\r\nrange_sizek -= sizek;\r\nif (reg >= num_var_ranges)\r\nbreak;\r\n}\r\nreturn reg;\r\n}\r\nstatic unsigned __init\r\nrange_to_mtrr_with_hole(struct var_mtrr_state *state, unsigned long basek,\r\nunsigned long sizek)\r\n{\r\nunsigned long hole_basek, hole_sizek;\r\nunsigned long second_basek, second_sizek;\r\nunsigned long range0_basek, range0_sizek;\r\nunsigned long range_basek, range_sizek;\r\nunsigned long chunk_sizek;\r\nunsigned long gran_sizek;\r\nhole_basek = 0;\r\nhole_sizek = 0;\r\nsecond_basek = 0;\r\nsecond_sizek = 0;\r\nchunk_sizek = state->chunk_sizek;\r\ngran_sizek = state->gran_sizek;\r\nrange_basek = ALIGN(state->range_startk, gran_sizek);\r\nif ((range_basek > basek) && basek)\r\nreturn second_sizek;\r\nstate->range_sizek -= (range_basek - state->range_startk);\r\nrange_sizek = ALIGN(state->range_sizek, gran_sizek);\r\nwhile (range_sizek > state->range_sizek) {\r\nrange_sizek -= gran_sizek;\r\nif (!range_sizek)\r\nreturn 0;\r\n}\r\nstate->range_sizek = range_sizek;\r\nrange0_basek = state->range_startk;\r\nrange0_sizek = ALIGN(state->range_sizek, chunk_sizek);\r\nif (range0_sizek == state->range_sizek) {\r\nDprintk("rangeX: %016lx - %016lx\n",\r\nrange0_basek<<10,\r\n(range0_basek + state->range_sizek)<<10);\r\nstate->reg = range_to_mtrr(state->reg, range0_basek,\r\nstate->range_sizek, MTRR_TYPE_WRBACK);\r\nreturn 0;\r\n}\r\nif (sizek) {\r\nwhile (range0_basek + range0_sizek > (basek + sizek)) {\r\nif (range0_sizek >= chunk_sizek)\r\nrange0_sizek -= chunk_sizek;\r\nelse\r\nrange0_sizek = 0;\r\nif (!range0_sizek)\r\nbreak;\r\n}\r\n}\r\nsecond_try:\r\nrange_basek = range0_basek + range0_sizek;\r\nif (range_basek > basek && range_basek <= (basek + sizek))\r\nsecond_sizek = range_basek - basek;\r\nif (range0_sizek > state->range_sizek) {\r\nhole_sizek = range0_sizek - state->range_sizek - second_sizek;\r\nif (hole_sizek >= (range0_sizek >> 1) &&\r\nrange0_sizek >= chunk_sizek) {\r\nrange0_sizek -= chunk_sizek;\r\nsecond_sizek = 0;\r\nhole_sizek = 0;\r\ngoto second_try;\r\n}\r\n}\r\nif (range0_sizek) {\r\nDprintk("range0: %016lx - %016lx\n",\r\nrange0_basek<<10,\r\n(range0_basek + range0_sizek)<<10);\r\nstate->reg = range_to_mtrr(state->reg, range0_basek,\r\nrange0_sizek, MTRR_TYPE_WRBACK);\r\n}\r\nif (range0_sizek < state->range_sizek) {\r\nrange_sizek = state->range_sizek - range0_sizek;\r\nDprintk("range: %016lx - %016lx\n",\r\nrange_basek<<10,\r\n(range_basek + range_sizek)<<10);\r\nstate->reg = range_to_mtrr(state->reg, range_basek,\r\nrange_sizek, MTRR_TYPE_WRBACK);\r\n}\r\nif (hole_sizek) {\r\nhole_basek = range_basek - hole_sizek - second_sizek;\r\nDprintk("hole: %016lx - %016lx\n",\r\nhole_basek<<10,\r\n(hole_basek + hole_sizek)<<10);\r\nstate->reg = range_to_mtrr(state->reg, hole_basek,\r\nhole_sizek, MTRR_TYPE_UNCACHABLE);\r\n}\r\nreturn second_sizek;\r\n}\r\nstatic void __init\r\nset_var_mtrr_range(struct var_mtrr_state *state, unsigned long base_pfn,\r\nunsigned long size_pfn)\r\n{\r\nunsigned long basek, sizek;\r\nunsigned long second_sizek = 0;\r\nif (state->reg >= num_var_ranges)\r\nreturn;\r\nbasek = base_pfn << (PAGE_SHIFT - 10);\r\nsizek = size_pfn << (PAGE_SHIFT - 10);\r\nif ((basek <= 1024) ||\r\n(state->range_startk + state->range_sizek == basek)) {\r\nunsigned long endk = basek + sizek;\r\nstate->range_sizek = endk - state->range_startk;\r\nreturn;\r\n}\r\nif (state->range_sizek != 0)\r\nsecond_sizek = range_to_mtrr_with_hole(state, basek, sizek);\r\nstate->range_startk = basek + second_sizek;\r\nstate->range_sizek = sizek - second_sizek;\r\n}\r\nstatic int __init parse_mtrr_chunk_size_opt(char *p)\r\n{\r\nif (!p)\r\nreturn -EINVAL;\r\nmtrr_chunk_size = memparse(p, &p);\r\nreturn 0;\r\n}\r\nstatic int __init parse_mtrr_gran_size_opt(char *p)\r\n{\r\nif (!p)\r\nreturn -EINVAL;\r\nmtrr_gran_size = memparse(p, &p);\r\nreturn 0;\r\n}\r\nstatic int __init parse_mtrr_spare_reg(char *arg)\r\n{\r\nif (arg)\r\nnr_mtrr_spare_reg = simple_strtoul(arg, NULL, 0);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nx86_setup_var_mtrrs(struct range *range, int nr_range,\r\nu64 chunk_size, u64 gran_size)\r\n{\r\nstruct var_mtrr_state var_state;\r\nint num_reg;\r\nint i;\r\nvar_state.range_startk = 0;\r\nvar_state.range_sizek = 0;\r\nvar_state.reg = 0;\r\nvar_state.chunk_sizek = chunk_size >> 10;\r\nvar_state.gran_sizek = gran_size >> 10;\r\nmemset(range_state, 0, sizeof(range_state));\r\nfor (i = 0; i < nr_range; i++) {\r\nset_var_mtrr_range(&var_state, range[i].start,\r\nrange[i].end - range[i].start);\r\n}\r\nif (var_state.range_sizek != 0)\r\nrange_to_mtrr_with_hole(&var_state, 0, 0);\r\nnum_reg = var_state.reg;\r\nwhile (var_state.reg < num_var_ranges) {\r\nsave_var_mtrr(var_state.reg, 0, 0, 0);\r\nvar_state.reg++;\r\n}\r\nreturn num_reg;\r\n}\r\nstatic void __init print_out_mtrr_range_state(void)\r\n{\r\nchar start_factor = 'K', size_factor = 'K';\r\nunsigned long start_base, size_base;\r\nmtrr_type type;\r\nint i;\r\nfor (i = 0; i < num_var_ranges; i++) {\r\nsize_base = range_state[i].size_pfn << (PAGE_SHIFT - 10);\r\nif (!size_base)\r\ncontinue;\r\nsize_base = to_size_factor(size_base, &size_factor),\r\nstart_base = range_state[i].base_pfn << (PAGE_SHIFT - 10);\r\nstart_base = to_size_factor(start_base, &start_factor),\r\ntype = range_state[i].type;\r\nprintk(KERN_DEBUG "reg %d, base: %ld%cB, range: %ld%cB, type %s\n",\r\ni, start_base, start_factor,\r\nsize_base, size_factor,\r\n(type == MTRR_TYPE_UNCACHABLE) ? "UC" :\r\n((type == MTRR_TYPE_WRPROT) ? "WP" :\r\n((type == MTRR_TYPE_WRBACK) ? "WB" : "Other"))\r\n);\r\n}\r\n}\r\nstatic int __init mtrr_need_cleanup(void)\r\n{\r\nint i;\r\nmtrr_type type;\r\nunsigned long size;\r\nint num[MTRR_NUM_TYPES + 1];\r\nmemset(num, 0, sizeof(num));\r\nfor (i = 0; i < num_var_ranges; i++) {\r\ntype = range_state[i].type;\r\nsize = range_state[i].size_pfn;\r\nif (type >= MTRR_NUM_TYPES)\r\ncontinue;\r\nif (!size)\r\ntype = MTRR_NUM_TYPES;\r\nnum[type]++;\r\n}\r\nif (!num[MTRR_TYPE_UNCACHABLE])\r\nreturn 0;\r\nif (num[MTRR_TYPE_WRBACK] + num[MTRR_TYPE_UNCACHABLE] !=\r\nnum_var_ranges - num[MTRR_NUM_TYPES])\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void __init\r\nmtrr_calc_range_state(u64 chunk_size, u64 gran_size,\r\nunsigned long x_remove_base,\r\nunsigned long x_remove_size, int i)\r\n{\r\nstatic struct range range_new[RANGE_NUM];\r\nunsigned long range_sums_new;\r\nstatic int nr_range_new;\r\nint num_reg;\r\nnum_reg = x86_setup_var_mtrrs(range, nr_range, chunk_size, gran_size);\r\nmemset(range_new, 0, sizeof(range_new));\r\nnr_range_new = x86_get_mtrr_mem_range(range_new, 0,\r\nx_remove_base, x_remove_size);\r\nrange_sums_new = sum_ranges(range_new, nr_range_new);\r\nresult[i].chunk_sizek = chunk_size >> 10;\r\nresult[i].gran_sizek = gran_size >> 10;\r\nresult[i].num_reg = num_reg;\r\nif (range_sums < range_sums_new) {\r\nresult[i].lose_cover_sizek = (range_sums_new - range_sums) << PSHIFT;\r\nresult[i].bad = 1;\r\n} else {\r\nresult[i].lose_cover_sizek = (range_sums - range_sums_new) << PSHIFT;\r\n}\r\nif (!result[i].bad && !result[i].lose_cover_sizek) {\r\nif (nr_range_new != nr_range || memcmp(range, range_new, sizeof(range)))\r\nresult[i].bad = 1;\r\n}\r\nif (!result[i].bad && (range_sums - range_sums_new < min_loss_pfn[num_reg]))\r\nmin_loss_pfn[num_reg] = range_sums - range_sums_new;\r\n}\r\nstatic void __init mtrr_print_out_one_result(int i)\r\n{\r\nunsigned long gran_base, chunk_base, lose_base;\r\nchar gran_factor, chunk_factor, lose_factor;\r\ngran_base = to_size_factor(result[i].gran_sizek, &gran_factor);\r\nchunk_base = to_size_factor(result[i].chunk_sizek, &chunk_factor);\r\nlose_base = to_size_factor(result[i].lose_cover_sizek, &lose_factor);\r\npr_info("%sgran_size: %ld%c \tchunk_size: %ld%c \t",\r\nresult[i].bad ? "*BAD*" : " ",\r\ngran_base, gran_factor, chunk_base, chunk_factor);\r\npr_cont("num_reg: %d \tlose cover RAM: %s%ld%c\n",\r\nresult[i].num_reg, result[i].bad ? "-" : "",\r\nlose_base, lose_factor);\r\n}\r\nstatic int __init mtrr_search_optimal_index(void)\r\n{\r\nint num_reg_good;\r\nint index_good;\r\nint i;\r\nif (nr_mtrr_spare_reg >= num_var_ranges)\r\nnr_mtrr_spare_reg = num_var_ranges - 1;\r\nnum_reg_good = -1;\r\nfor (i = num_var_ranges - nr_mtrr_spare_reg; i > 0; i--) {\r\nif (!min_loss_pfn[i])\r\nnum_reg_good = i;\r\n}\r\nindex_good = -1;\r\nif (num_reg_good != -1) {\r\nfor (i = 0; i < NUM_RESULT; i++) {\r\nif (!result[i].bad &&\r\nresult[i].num_reg == num_reg_good &&\r\n!result[i].lose_cover_sizek) {\r\nindex_good = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn index_good;\r\n}\r\nint __init mtrr_cleanup(unsigned address_bits)\r\n{\r\nunsigned long x_remove_base, x_remove_size;\r\nunsigned long base, size, def, dummy;\r\nu64 chunk_size, gran_size;\r\nmtrr_type type;\r\nint index_good;\r\nint i;\r\nif (!is_cpu(INTEL) || enable_mtrr_cleanup < 1)\r\nreturn 0;\r\nrdmsr(MSR_MTRRdefType, def, dummy);\r\ndef &= 0xff;\r\nif (def != MTRR_TYPE_UNCACHABLE)\r\nreturn 0;\r\nmemset(range_state, 0, sizeof(range_state));\r\nfor (i = 0; i < num_var_ranges; i++) {\r\nmtrr_if->get(i, &base, &size, &type);\r\nrange_state[i].base_pfn = base;\r\nrange_state[i].size_pfn = size;\r\nrange_state[i].type = type;\r\n}\r\nif (!mtrr_need_cleanup())\r\nreturn 0;\r\nprintk(KERN_DEBUG "original variable MTRRs\n");\r\nprint_out_mtrr_range_state();\r\nmemset(range, 0, sizeof(range));\r\nx_remove_size = 0;\r\nx_remove_base = 1 << (32 - PAGE_SHIFT);\r\nif (mtrr_tom2)\r\nx_remove_size = (mtrr_tom2 >> PAGE_SHIFT) - x_remove_base;\r\nnr_range = x86_get_mtrr_mem_range(range, 0, x_remove_base, x_remove_size);\r\nnr_range = add_range_with_merge(range, RANGE_NUM, nr_range, 0,\r\n1ULL<<(20 - PAGE_SHIFT));\r\nsort_range(range, nr_range);\r\nrange_sums = sum_ranges(range, nr_range);\r\nprintk(KERN_INFO "total RAM covered: %ldM\n",\r\nrange_sums >> (20 - PAGE_SHIFT));\r\nif (mtrr_chunk_size && mtrr_gran_size) {\r\ni = 0;\r\nmtrr_calc_range_state(mtrr_chunk_size, mtrr_gran_size,\r\nx_remove_base, x_remove_size, i);\r\nmtrr_print_out_one_result(i);\r\nif (!result[i].bad) {\r\nset_var_mtrr_all(address_bits);\r\nprintk(KERN_DEBUG "New variable MTRRs\n");\r\nprint_out_mtrr_range_state();\r\nreturn 1;\r\n}\r\nprintk(KERN_INFO "invalid mtrr_gran_size or mtrr_chunk_size, "\r\n"will find optimal one\n");\r\n}\r\ni = 0;\r\nmemset(min_loss_pfn, 0xff, sizeof(min_loss_pfn));\r\nmemset(result, 0, sizeof(result));\r\nfor (gran_size = (1ULL<<16); gran_size < (1ULL<<32); gran_size <<= 1) {\r\nfor (chunk_size = gran_size; chunk_size < (1ULL<<32);\r\nchunk_size <<= 1) {\r\nif (i >= NUM_RESULT)\r\ncontinue;\r\nmtrr_calc_range_state(chunk_size, gran_size,\r\nx_remove_base, x_remove_size, i);\r\nif (debug_print) {\r\nmtrr_print_out_one_result(i);\r\nprintk(KERN_INFO "\n");\r\n}\r\ni++;\r\n}\r\n}\r\nindex_good = mtrr_search_optimal_index();\r\nif (index_good != -1) {\r\nprintk(KERN_INFO "Found optimal setting for mtrr clean up\n");\r\ni = index_good;\r\nmtrr_print_out_one_result(i);\r\nchunk_size = result[i].chunk_sizek;\r\nchunk_size <<= 10;\r\ngran_size = result[i].gran_sizek;\r\ngran_size <<= 10;\r\nx86_setup_var_mtrrs(range, nr_range, chunk_size, gran_size);\r\nset_var_mtrr_all(address_bits);\r\nprintk(KERN_DEBUG "New variable MTRRs\n");\r\nprint_out_mtrr_range_state();\r\nreturn 1;\r\n} else {\r\nfor (i = 0; i < NUM_RESULT; i++)\r\nmtrr_print_out_one_result(i);\r\n}\r\nprintk(KERN_INFO "mtrr_cleanup: can not find optimal value\n");\r\nprintk(KERN_INFO "please specify mtrr_gran_size/mtrr_chunk_size\n");\r\nreturn 0;\r\n}\r\nint __init mtrr_cleanup(unsigned address_bits)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init disable_mtrr_trim_setup(char *str)\r\n{\r\ndisable_mtrr_trim = 1;\r\nreturn 0;\r\n}\r\nint __init amd_special_default_mtrr(void)\r\n{\r\nu32 l, h;\r\nif (boot_cpu_data.x86_vendor != X86_VENDOR_AMD)\r\nreturn 0;\r\nif (boot_cpu_data.x86 < 0xf)\r\nreturn 0;\r\nif (rdmsr_safe(MSR_K8_SYSCFG, &l, &h) < 0)\r\nreturn 0;\r\nif ((l & (Tom2Enabled | Tom2ForceMemTypeWB)) ==\r\n(Tom2Enabled | Tom2ForceMemTypeWB))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic u64 __init\r\nreal_trim_memory(unsigned long start_pfn, unsigned long limit_pfn)\r\n{\r\nu64 trim_start, trim_size;\r\ntrim_start = start_pfn;\r\ntrim_start <<= PAGE_SHIFT;\r\ntrim_size = limit_pfn;\r\ntrim_size <<= PAGE_SHIFT;\r\ntrim_size -= trim_start;\r\nreturn e820_update_range(trim_start, trim_size, E820_RAM, E820_RESERVED);\r\n}\r\nint __init mtrr_trim_uncached_memory(unsigned long end_pfn)\r\n{\r\nunsigned long i, base, size, highest_pfn = 0, def, dummy;\r\nmtrr_type type;\r\nu64 total_trim_size;\r\nint num[MTRR_NUM_TYPES + 1];\r\nif (!is_cpu(INTEL) || disable_mtrr_trim)\r\nreturn 0;\r\nrdmsr(MSR_MTRRdefType, def, dummy);\r\ndef &= 0xff;\r\nif (def != MTRR_TYPE_UNCACHABLE)\r\nreturn 0;\r\nmemset(range_state, 0, sizeof(range_state));\r\nfor (i = 0; i < num_var_ranges; i++) {\r\nmtrr_if->get(i, &base, &size, &type);\r\nrange_state[i].base_pfn = base;\r\nrange_state[i].size_pfn = size;\r\nrange_state[i].type = type;\r\n}\r\nfor (i = 0; i < num_var_ranges; i++) {\r\ntype = range_state[i].type;\r\nif (type != MTRR_TYPE_WRBACK)\r\ncontinue;\r\nbase = range_state[i].base_pfn;\r\nsize = range_state[i].size_pfn;\r\nif (highest_pfn < base + size)\r\nhighest_pfn = base + size;\r\n}\r\nif (!highest_pfn) {\r\nprintk(KERN_INFO "CPU MTRRs all blank - virtualized system.\n");\r\nreturn 0;\r\n}\r\nmemset(num, 0, sizeof(num));\r\nfor (i = 0; i < num_var_ranges; i++) {\r\ntype = range_state[i].type;\r\nif (type >= MTRR_NUM_TYPES)\r\ncontinue;\r\nsize = range_state[i].size_pfn;\r\nif (!size)\r\ntype = MTRR_NUM_TYPES;\r\nnum[type]++;\r\n}\r\nif (!num[MTRR_TYPE_WRBACK])\r\nreturn 0;\r\nif (num[MTRR_TYPE_WRBACK] + num[MTRR_TYPE_UNCACHABLE] !=\r\nnum_var_ranges - num[MTRR_NUM_TYPES])\r\nreturn 0;\r\nmemset(range, 0, sizeof(range));\r\nnr_range = 0;\r\nif (mtrr_tom2) {\r\nrange[nr_range].start = (1ULL<<(32 - PAGE_SHIFT));\r\nrange[nr_range].end = mtrr_tom2 >> PAGE_SHIFT;\r\nif (highest_pfn < range[nr_range].end)\r\nhighest_pfn = range[nr_range].end;\r\nnr_range++;\r\n}\r\nnr_range = x86_get_mtrr_mem_range(range, nr_range, 0, 0);\r\ntotal_trim_size = 0;\r\nif (range[0].start)\r\ntotal_trim_size += real_trim_memory(0, range[0].start);\r\nfor (i = 0; i < nr_range - 1; i++) {\r\nif (range[i].end < range[i+1].start)\r\ntotal_trim_size += real_trim_memory(range[i].end,\r\nrange[i+1].start);\r\n}\r\ni = nr_range - 1;\r\nif (range[i].end < end_pfn)\r\ntotal_trim_size += real_trim_memory(range[i].end,\r\nend_pfn);\r\nif (total_trim_size) {\r\npr_warning("WARNING: BIOS bug: CPU MTRRs don't cover all of memory, losing %lluMB of RAM.\n", total_trim_size >> 20);\r\nif (!changed_by_mtrr_cleanup)\r\nWARN_ON(1);\r\npr_info("update e820 for mtrr\n");\r\nupdate_e820();\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}
