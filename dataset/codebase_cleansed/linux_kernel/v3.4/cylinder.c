static void ufs_read_cylinder (struct super_block * sb,\r\nunsigned cgno, unsigned bitmap_nr)\r\n{\r\nstruct ufs_sb_info * sbi = UFS_SB(sb);\r\nstruct ufs_sb_private_info * uspi;\r\nstruct ufs_cg_private_info * ucpi;\r\nstruct ufs_cylinder_group * ucg;\r\nunsigned i, j;\r\nUFSD("ENTER, cgno %u, bitmap_nr %u\n", cgno, bitmap_nr);\r\nuspi = sbi->s_uspi;\r\nucpi = sbi->s_ucpi[bitmap_nr];\r\nucg = (struct ufs_cylinder_group *)sbi->s_ucg[cgno]->b_data;\r\nUCPI_UBH(ucpi)->fragment = ufs_cgcmin(cgno);\r\nUCPI_UBH(ucpi)->count = uspi->s_cgsize >> sb->s_blocksize_bits;\r\nUCPI_UBH(ucpi)->bh[0] = sbi->s_ucg[cgno];\r\nfor (i = 1; i < UCPI_UBH(ucpi)->count; i++)\r\nif (!(UCPI_UBH(ucpi)->bh[i] = sb_bread(sb, UCPI_UBH(ucpi)->fragment + i)))\r\ngoto failed;\r\nsbi->s_cgno[bitmap_nr] = cgno;\r\nucpi->c_cgx = fs32_to_cpu(sb, ucg->cg_cgx);\r\nucpi->c_ncyl = fs16_to_cpu(sb, ucg->cg_ncyl);\r\nucpi->c_niblk = fs16_to_cpu(sb, ucg->cg_niblk);\r\nucpi->c_ndblk = fs32_to_cpu(sb, ucg->cg_ndblk);\r\nucpi->c_rotor = fs32_to_cpu(sb, ucg->cg_rotor);\r\nucpi->c_frotor = fs32_to_cpu(sb, ucg->cg_frotor);\r\nucpi->c_irotor = fs32_to_cpu(sb, ucg->cg_irotor);\r\nucpi->c_btotoff = fs32_to_cpu(sb, ucg->cg_btotoff);\r\nucpi->c_boff = fs32_to_cpu(sb, ucg->cg_boff);\r\nucpi->c_iusedoff = fs32_to_cpu(sb, ucg->cg_iusedoff);\r\nucpi->c_freeoff = fs32_to_cpu(sb, ucg->cg_freeoff);\r\nucpi->c_nextfreeoff = fs32_to_cpu(sb, ucg->cg_nextfreeoff);\r\nucpi->c_clustersumoff = fs32_to_cpu(sb, ucg->cg_u.cg_44.cg_clustersumoff);\r\nucpi->c_clusteroff = fs32_to_cpu(sb, ucg->cg_u.cg_44.cg_clusteroff);\r\nucpi->c_nclusterblks = fs32_to_cpu(sb, ucg->cg_u.cg_44.cg_nclusterblks);\r\nUFSD("EXIT\n");\r\nreturn;\r\nfailed:\r\nfor (j = 1; j < i; j++)\r\nbrelse (sbi->s_ucg[j]);\r\nsbi->s_cgno[bitmap_nr] = UFS_CGNO_EMPTY;\r\nufs_error (sb, "ufs_read_cylinder", "can't read cylinder group block %u", cgno);\r\n}\r\nvoid ufs_put_cylinder (struct super_block * sb, unsigned bitmap_nr)\r\n{\r\nstruct ufs_sb_info * sbi = UFS_SB(sb);\r\nstruct ufs_sb_private_info * uspi;\r\nstruct ufs_cg_private_info * ucpi;\r\nstruct ufs_cylinder_group * ucg;\r\nunsigned i;\r\nUFSD("ENTER, bitmap_nr %u\n", bitmap_nr);\r\nuspi = sbi->s_uspi;\r\nif (sbi->s_cgno[bitmap_nr] == UFS_CGNO_EMPTY) {\r\nUFSD("EXIT\n");\r\nreturn;\r\n}\r\nucpi = sbi->s_ucpi[bitmap_nr];\r\nucg = ubh_get_ucg(UCPI_UBH(ucpi));\r\nif (uspi->s_ncg > UFS_MAX_GROUP_LOADED && bitmap_nr >= sbi->s_cg_loaded) {\r\nufs_panic (sb, "ufs_put_cylinder", "internal error");\r\nreturn;\r\n}\r\nucg->cg_rotor = cpu_to_fs32(sb, ucpi->c_rotor);\r\nucg->cg_frotor = cpu_to_fs32(sb, ucpi->c_frotor);\r\nucg->cg_irotor = cpu_to_fs32(sb, ucpi->c_irotor);\r\nubh_mark_buffer_dirty (UCPI_UBH(ucpi));\r\nfor (i = 1; i < UCPI_UBH(ucpi)->count; i++) {\r\nbrelse (UCPI_UBH(ucpi)->bh[i]);\r\n}\r\nsbi->s_cgno[bitmap_nr] = UFS_CGNO_EMPTY;\r\nUFSD("EXIT\n");\r\n}\r\nstruct ufs_cg_private_info * ufs_load_cylinder (\r\nstruct super_block * sb, unsigned cgno)\r\n{\r\nstruct ufs_sb_info * sbi = UFS_SB(sb);\r\nstruct ufs_sb_private_info * uspi;\r\nstruct ufs_cg_private_info * ucpi;\r\nunsigned cg, i, j;\r\nUFSD("ENTER, cgno %u\n", cgno);\r\nuspi = sbi->s_uspi;\r\nif (cgno >= uspi->s_ncg) {\r\nufs_panic (sb, "ufs_load_cylinder", "internal error, high number of cg");\r\nreturn NULL;\r\n}\r\nif (sbi->s_cgno[0] == cgno) {\r\nUFSD("EXIT\n");\r\nreturn sbi->s_ucpi[0];\r\n}\r\nif (uspi->s_ncg <= UFS_MAX_GROUP_LOADED) {\r\nif (sbi->s_cgno[cgno] != UFS_CGNO_EMPTY) {\r\nif (sbi->s_cgno[cgno] != cgno) {\r\nufs_panic (sb, "ufs_load_cylinder", "internal error, wrong number of cg in cache");\r\nUFSD("EXIT (FAILED)\n");\r\nreturn NULL;\r\n}\r\nelse {\r\nUFSD("EXIT\n");\r\nreturn sbi->s_ucpi[cgno];\r\n}\r\n} else {\r\nufs_read_cylinder (sb, cgno, cgno);\r\nUFSD("EXIT\n");\r\nreturn sbi->s_ucpi[cgno];\r\n}\r\n}\r\nfor (i = 0; i < sbi->s_cg_loaded && sbi->s_cgno[i] != cgno; i++);\r\nif (i < sbi->s_cg_loaded && sbi->s_cgno[i] == cgno) {\r\ncg = sbi->s_cgno[i];\r\nucpi = sbi->s_ucpi[i];\r\nfor (j = i; j > 0; j--) {\r\nsbi->s_cgno[j] = sbi->s_cgno[j-1];\r\nsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\r\n}\r\nsbi->s_cgno[0] = cg;\r\nsbi->s_ucpi[0] = ucpi;\r\n} else {\r\nif (sbi->s_cg_loaded < UFS_MAX_GROUP_LOADED)\r\nsbi->s_cg_loaded++;\r\nelse\r\nufs_put_cylinder (sb, UFS_MAX_GROUP_LOADED-1);\r\nucpi = sbi->s_ucpi[sbi->s_cg_loaded - 1];\r\nfor (j = sbi->s_cg_loaded - 1; j > 0; j--) {\r\nsbi->s_cgno[j] = sbi->s_cgno[j-1];\r\nsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\r\n}\r\nsbi->s_ucpi[0] = ucpi;\r\nufs_read_cylinder (sb, cgno, 0);\r\n}\r\nUFSD("EXIT\n");\r\nreturn sbi->s_ucpi[0];\r\n}
