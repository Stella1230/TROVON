static int _clk_enable(struct clk *clk)\r\n{\r\nu32 reg;\r\nreg = __raw_readl(clk->enable_reg);\r\nreg |= 1 << clk->enable_shift;\r\n__raw_writel(reg, clk->enable_reg);\r\nreturn 0;\r\n}\r\nstatic void _clk_disable(struct clk *clk)\r\n{\r\nu32 reg;\r\nreg = __raw_readl(clk->enable_reg);\r\nreg &= ~(1 << clk->enable_shift);\r\n__raw_writel(reg, clk->enable_reg);\r\n}\r\nstatic unsigned long _clk_generic_round_rate(struct clk *clk,\r\nunsigned long rate,\r\nu32 max_divisor)\r\n{\r\nu32 div;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\ndiv = parent_rate / rate;\r\nif (parent_rate % rate)\r\ndiv++;\r\nif (div > max_divisor)\r\ndiv = max_divisor;\r\nreturn parent_rate / div;\r\n}\r\nstatic int _clk_spll_enable(struct clk *clk)\r\n{\r\nu32 reg;\r\nreg = __raw_readl(CCM_CSCR);\r\nreg |= CCM_CSCR_SPEN;\r\n__raw_writel(reg, CCM_CSCR);\r\nwhile ((__raw_readl(CCM_SPCTL1) & CCM_SPCTL1_LF) == 0)\r\n;\r\nreturn 0;\r\n}\r\nstatic void _clk_spll_disable(struct clk *clk)\r\n{\r\nu32 reg;\r\nreg = __raw_readl(CCM_CSCR);\r\nreg &= ~CCM_CSCR_SPEN;\r\n__raw_writel(reg, CCM_CSCR);\r\n}\r\nstatic unsigned long _clk_perclkx_round_rate(struct clk *clk,\r\nunsigned long rate)\r\n{\r\nreturn _clk_generic_round_rate(clk, rate, 64);\r\n}\r\nstatic int _clk_perclkx_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nu32 reg;\r\nu32 div;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\nif (clk->id < 0 || clk->id > 3)\r\nreturn -EINVAL;\r\ndiv = parent_rate / rate;\r\nif (div > 64 || div < 1 || ((parent_rate / div) != rate))\r\nreturn -EINVAL;\r\ndiv--;\r\nreg =\r\n__raw_readl(CCM_PCDR1) & ~(CCM_PCDR1_PERDIV1_MASK <<\r\n(clk->id << 3));\r\nreg |= div << (clk->id << 3);\r\n__raw_writel(reg, CCM_PCDR1);\r\nreturn 0;\r\n}\r\nstatic unsigned long _clk_usb_recalc(struct clk *clk)\r\n{\r\nunsigned long usb_pdf;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\nusb_pdf = (CSCR() & CCM_CSCR_USB_MASK) >> CCM_CSCR_USB_OFFSET;\r\nreturn parent_rate / (usb_pdf + 1U);\r\n}\r\nstatic unsigned long _clk_usb_round_rate(struct clk *clk,\r\nunsigned long rate)\r\n{\r\nreturn _clk_generic_round_rate(clk, rate, 8);\r\n}\r\nstatic int _clk_usb_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nu32 reg;\r\nu32 div;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\ndiv = parent_rate / rate;\r\nif (div > 8 || div < 1 || ((parent_rate / div) != rate))\r\nreturn -EINVAL;\r\ndiv--;\r\nreg = CSCR() & ~CCM_CSCR_USB_MASK;\r\nreg |= div << CCM_CSCR_USB_OFFSET;\r\n__raw_writel(reg, CCM_CSCR);\r\nreturn 0;\r\n}\r\nstatic unsigned long _clk_ssix_recalc(struct clk *clk, unsigned long pdf)\r\n{\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\npdf = (pdf < 2) ? 124UL : pdf;\r\nreturn 2UL * parent_rate / pdf;\r\n}\r\nstatic unsigned long _clk_ssi1_recalc(struct clk *clk)\r\n{\r\nreturn _clk_ssix_recalc(clk,\r\n(PCDR0() & CCM_PCDR0_SSI1BAUDDIV_MASK)\r\n>> CCM_PCDR0_SSI1BAUDDIV_OFFSET);\r\n}\r\nstatic unsigned long _clk_ssi2_recalc(struct clk *clk)\r\n{\r\nreturn _clk_ssix_recalc(clk,\r\n(PCDR0() & CCM_PCDR0_SSI2BAUDDIV_MASK) >>\r\nCCM_PCDR0_SSI2BAUDDIV_OFFSET);\r\n}\r\nstatic unsigned long _clk_nfc_recalc(struct clk *clk)\r\n{\r\nunsigned long nfc_pdf;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\nnfc_pdf = (PCDR0() & CCM_PCDR0_NFCDIV_MASK)\r\n>> CCM_PCDR0_NFCDIV_OFFSET;\r\nreturn parent_rate / (nfc_pdf + 1);\r\n}\r\nstatic unsigned long _clk_parent_round_rate(struct clk *clk, unsigned long rate)\r\n{\r\nreturn clk->parent->round_rate(clk->parent, rate);\r\n}\r\nstatic int _clk_parent_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nreturn clk->parent->set_rate(clk->parent, rate);\r\n}\r\nstatic unsigned long get_high_reference_clock_rate(struct clk *clk)\r\n{\r\nreturn external_high_reference;\r\n}\r\nstatic unsigned long get_low_reference_clock_rate(struct clk *clk)\r\n{\r\nreturn external_low_reference;\r\n}\r\nstatic unsigned long _clk_fpm_recalc(struct clk *clk)\r\n{\r\nreturn clk_get_rate(clk->parent) * 512;\r\n}\r\nstatic unsigned long get_mpll_clk(struct clk *clk)\r\n{\r\nuint32_t reg;\r\nunsigned long ref_clk;\r\nunsigned long mfi = 0, mfn = 0, mfd = 0, pdf = 0;\r\nunsigned long long temp;\r\nref_clk = clk_get_rate(clk->parent);\r\nreg = __raw_readl(CCM_MPCTL0);\r\npdf = (reg & CCM_MPCTL0_PD_MASK) >> CCM_MPCTL0_PD_OFFSET;\r\nmfd = (reg & CCM_MPCTL0_MFD_MASK) >> CCM_MPCTL0_MFD_OFFSET;\r\nmfi = (reg & CCM_MPCTL0_MFI_MASK) >> CCM_MPCTL0_MFI_OFFSET;\r\nmfn = (reg & CCM_MPCTL0_MFN_MASK) >> CCM_MPCTL0_MFN_OFFSET;\r\nmfi = (mfi <= 5) ? 5 : mfi;\r\ntemp = 2LL * ref_clk * mfn;\r\ndo_div(temp, mfd + 1);\r\ntemp = 2LL * ref_clk * mfi + temp;\r\ndo_div(temp, pdf + 1);\r\nreturn (unsigned long)temp;\r\n}\r\nstatic unsigned long _clk_fclk_get_rate(struct clk *clk)\r\n{\r\nunsigned long parent_rate;\r\nu32 div;\r\ndiv = (CSCR() & CCM_CSCR_PRESC_MASK) >> CCM_CSCR_PRESC_OFFSET;\r\nparent_rate = clk_get_rate(clk->parent);\r\nreturn parent_rate / (div+1);\r\n}\r\nstatic unsigned long get_spll_clk(struct clk *clk)\r\n{\r\nuint32_t reg;\r\nunsigned long ref_clk;\r\nunsigned long mfi = 0, mfn = 0, mfd = 0, pdf = 0;\r\nunsigned long long temp;\r\nref_clk = clk_get_rate(clk->parent);\r\nreg = __raw_readl(CCM_SPCTL0);\r\npdf = (reg & CCM_SPCTL0_PD_MASK) >> CCM_SPCTL0_PD_OFFSET;\r\nmfd = (reg & CCM_SPCTL0_MFD_MASK) >> CCM_SPCTL0_MFD_OFFSET;\r\nmfi = (reg & CCM_SPCTL0_MFI_MASK) >> CCM_SPCTL0_MFI_OFFSET;\r\nmfn = (reg & CCM_SPCTL0_MFN_MASK) >> CCM_SPCTL0_MFN_OFFSET;\r\nmfi = (mfi <= 5) ? 5 : mfi;\r\ntemp = 2LL * ref_clk * mfn;\r\ndo_div(temp, mfd + 1);\r\ntemp = 2LL * ref_clk * mfi + temp;\r\ndo_div(temp, pdf + 1);\r\nreturn (unsigned long)temp;\r\n}\r\nstatic unsigned long get_hclk_clk(struct clk *clk)\r\n{\r\nunsigned long rate;\r\nunsigned long bclk_pdf;\r\nbclk_pdf = (CSCR() & CCM_CSCR_BCLK_MASK)\r\n>> CCM_CSCR_BCLK_OFFSET;\r\nrate = clk_get_rate(clk->parent);\r\nreturn rate / (bclk_pdf + 1);\r\n}\r\nstatic unsigned long get_ipg_clk(struct clk *clk)\r\n{\r\nunsigned long rate;\r\nunsigned long ipg_pdf;\r\nipg_pdf = (CSCR() & CCM_CSCR_IPDIV) >> CCM_CSCR_IPDIV_OFFSET;\r\nrate = clk_get_rate(clk->parent);\r\nreturn rate / (ipg_pdf + 1);\r\n}\r\nstatic unsigned long _clk_perclkx_recalc(struct clk *clk)\r\n{\r\nunsigned long perclk_pdf;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\nif (clk->id < 0 || clk->id > 3)\r\nreturn 0;\r\nperclk_pdf = (PCDR1() >> (clk->id << 3)) & CCM_PCDR1_PERDIV1_MASK;\r\nreturn parent_rate / (perclk_pdf + 1);\r\n}\r\nstatic unsigned long _clk_clko_round_rate(struct clk *clk, unsigned long rate)\r\n{\r\nreturn _clk_generic_round_rate(clk, rate, 8);\r\n}\r\nstatic int _clk_clko_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nu32 reg;\r\nu32 div;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\ndiv = parent_rate / rate;\r\nif (div > 8 || div < 1 || ((parent_rate / div) != rate))\r\nreturn -EINVAL;\r\ndiv--;\r\nreg = __raw_readl(CCM_PCDR0);\r\nif (clk->parent == &usb_clk[0]) {\r\nreg &= ~CCM_PCDR0_48MDIV_MASK;\r\nreg |= div << CCM_PCDR0_48MDIV_OFFSET;\r\n}\r\n__raw_writel(reg, CCM_PCDR0);\r\nreturn 0;\r\n}\r\nstatic unsigned long _clk_clko_recalc(struct clk *clk)\r\n{\r\nu32 div = 0;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\nif (clk->parent == &usb_clk[0])\r\ndiv = __raw_readl(CCM_PCDR0) & CCM_PCDR0_48MDIV_MASK\r\n>> CCM_PCDR0_48MDIV_OFFSET;\r\ndiv++;\r\nreturn parent_rate / div;\r\n}\r\nstatic int _clk_clko_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nu32 reg;\r\nreg = __raw_readl(CCM_CCSR) & ~CCM_CCSR_CLKOSEL_MASK;\r\nif (parent == &ckil_clk)\r\nreg |= 0 << CCM_CCSR_CLKOSEL_OFFSET;\r\nelse if (parent == &fpm_clk)\r\nreg |= 1 << CCM_CCSR_CLKOSEL_OFFSET;\r\nelse if (parent == &ckih_clk)\r\nreg |= 2 << CCM_CCSR_CLKOSEL_OFFSET;\r\nelse if (parent == mpll_clk.parent)\r\nreg |= 3 << CCM_CCSR_CLKOSEL_OFFSET;\r\nelse if (parent == spll_clk.parent)\r\nreg |= 4 << CCM_CCSR_CLKOSEL_OFFSET;\r\nelse if (parent == &mpll_clk)\r\nreg |= 5 << CCM_CCSR_CLKOSEL_OFFSET;\r\nelse if (parent == &spll_clk)\r\nreg |= 6 << CCM_CCSR_CLKOSEL_OFFSET;\r\nelse if (parent == &fclk_clk)\r\nreg |= 7 << CCM_CCSR_CLKOSEL_OFFSET;\r\nelse if (parent == &hclk_clk)\r\nreg |= 8 << CCM_CCSR_CLKOSEL_OFFSET;\r\nelse if (parent == &ipg_clk)\r\nreg |= 9 << CCM_CCSR_CLKOSEL_OFFSET;\r\nelse if (parent == &per_clk[0])\r\nreg |= 0xA << CCM_CCSR_CLKOSEL_OFFSET;\r\nelse if (parent == &per_clk[1])\r\nreg |= 0xB << CCM_CCSR_CLKOSEL_OFFSET;\r\nelse if (parent == &per_clk[2])\r\nreg |= 0xC << CCM_CCSR_CLKOSEL_OFFSET;\r\nelse if (parent == &per_clk[3])\r\nreg |= 0xD << CCM_CCSR_CLKOSEL_OFFSET;\r\nelse if (parent == &ssi_clk[0])\r\nreg |= 0xE << CCM_CCSR_CLKOSEL_OFFSET;\r\nelse if (parent == &ssi_clk[1])\r\nreg |= 0xF << CCM_CCSR_CLKOSEL_OFFSET;\r\nelse if (parent == &nfc_clk)\r\nreg |= 0x10 << CCM_CCSR_CLKOSEL_OFFSET;\r\nelse if (parent == &usb_clk[0])\r\nreg |= 0x14 << CCM_CCSR_CLKOSEL_OFFSET;\r\nelse if (parent == &clko_clk)\r\nreg |= 0x15 << CCM_CCSR_CLKOSEL_OFFSET;\r\nelse\r\nreturn -EINVAL;\r\n__raw_writel(reg, CCM_CCSR);\r\nreturn 0;\r\n}\r\nint __init mx21_clocks_init(unsigned long lref, unsigned long href)\r\n{\r\nu32 cscr;\r\nexternal_low_reference = lref;\r\nexternal_high_reference = href;\r\ncscr = CSCR();\r\nif (cscr & CCM_CSCR_MCU)\r\nmpll_clk.parent = &ckih_clk;\r\nelse\r\nmpll_clk.parent = &fpm_clk;\r\nif (cscr & CCM_CSCR_SP)\r\nspll_clk.parent = &ckih_clk;\r\nelse\r\nspll_clk.parent = &fpm_clk;\r\nclkdev_add_table(lookups, ARRAY_SIZE(lookups));\r\n__raw_writel(0, CCM_PCCR0);\r\n__raw_writel(CCM_PCCR_GPT1_MASK, CCM_PCCR1);\r\nspll_clk.disable(&spll_clk);\r\nclk_enable(&per_clk[0]);\r\nclk_enable(&gpio_clk);\r\n#if defined(CONFIG_DEBUG_LL) && !defined(CONFIG_DEBUG_ICEDCC)\r\nclk_enable(&uart_clk[0]);\r\n#endif\r\nmxc_timer_init(&gpt_clk[0], MX21_IO_ADDRESS(MX21_GPT1_BASE_ADDR),\r\nMX21_INT_GPT1);\r\nreturn 0;\r\n}
