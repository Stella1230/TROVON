static inline int cs_vendor_coef_get(struct hda_codec *codec, unsigned int idx)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nsnd_hda_codec_write(codec, spec->vendor_nid, 0,\r\nAC_VERB_SET_COEF_INDEX, idx);\r\nreturn snd_hda_codec_read(codec, spec->vendor_nid, 0,\r\nAC_VERB_GET_PROC_COEF, 0);\r\n}\r\nstatic inline void cs_vendor_coef_set(struct hda_codec *codec, unsigned int idx,\r\nunsigned int coef)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nsnd_hda_codec_write(codec, spec->vendor_nid, 0,\r\nAC_VERB_SET_COEF_INDEX, idx);\r\nsnd_hda_codec_write(codec, spec->vendor_nid, 0,\r\nAC_VERB_SET_PROC_COEF, coef);\r\n}\r\nstatic int cs_playback_pcm_open(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_analog_open(codec, &spec->multiout, substream,\r\nhinfo);\r\n}\r\nstatic int cs_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_analog_prepare(codec, &spec->multiout,\r\nstream_tag, format, substream);\r\n}\r\nstatic int cs_playback_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_analog_cleanup(codec, &spec->multiout);\r\n}\r\nstatic int cs_dig_playback_pcm_open(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_open(codec, &spec->multiout);\r\n}\r\nstatic int cs_dig_playback_pcm_close(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_close(codec, &spec->multiout);\r\n}\r\nstatic int cs_dig_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_prepare(codec, &spec->multiout, stream_tag,\r\nformat, substream);\r\n}\r\nstatic int cs_dig_playback_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_cleanup(codec, &spec->multiout);\r\n}\r\nstatic void cs_update_input_select(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nif (spec->cur_adc)\r\nsnd_hda_codec_write(codec, spec->cur_adc, 0,\r\nAC_VERB_SET_CONNECT_SEL,\r\nspec->adc_idx[spec->cur_input]);\r\n}\r\nstatic int cs_capture_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nspec->cur_adc = spec->adc_nid[spec->cur_input];\r\nspec->cur_adc_stream_tag = stream_tag;\r\nspec->cur_adc_format = format;\r\ncs_update_input_select(codec);\r\nsnd_hda_codec_setup_stream(codec, spec->cur_adc, stream_tag, 0, format);\r\nreturn 0;\r\n}\r\nstatic int cs_capture_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nsnd_hda_codec_cleanup_stream(codec, spec->cur_adc);\r\nspec->cur_adc = 0;\r\nreturn 0;\r\n}\r\nstatic int cs_build_pcms(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nstruct hda_pcm *info = spec->pcm_rec;\r\ncodec->pcm_info = info;\r\ncodec->num_pcms = 0;\r\ninfo->name = "Cirrus Analog";\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK] = cs_pcm_analog_playback;\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK].nid = spec->dac_nid[0];\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK].channels_max =\r\nspec->multiout.max_channels;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE] = cs_pcm_analog_capture;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE].nid =\r\nspec->adc_nid[spec->cur_input];\r\ncodec->num_pcms++;\r\nif (!spec->multiout.dig_out_nid && !spec->dig_in)\r\nreturn 0;\r\ninfo++;\r\ninfo->name = "Cirrus Digital";\r\ninfo->pcm_type = spec->autocfg.dig_out_type[0];\r\nif (!info->pcm_type)\r\ninfo->pcm_type = HDA_PCM_TYPE_SPDIF;\r\nif (spec->multiout.dig_out_nid) {\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK] =\r\ncs_pcm_digital_playback;\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK].nid =\r\nspec->multiout.dig_out_nid;\r\n}\r\nif (spec->dig_in) {\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE] =\r\ncs_pcm_digital_capture;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->dig_in;\r\n}\r\ncodec->num_pcms++;\r\nreturn 0;\r\n}\r\nstatic hda_nid_t get_dac(struct hda_codec *codec, hda_nid_t pin)\r\n{\r\nhda_nid_t dac;\r\nif (!pin)\r\nreturn 0;\r\nif (snd_hda_get_connections(codec, pin, &dac, 1) != 1)\r\nreturn 0;\r\nreturn dac;\r\n}\r\nstatic int is_ext_mic(struct hda_codec *codec, unsigned int idx)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nhda_nid_t pin = cfg->inputs[idx].pin;\r\nunsigned int val;\r\nif (!is_jack_detectable(codec, pin))\r\nreturn 0;\r\nval = snd_hda_codec_get_pincfg(codec, pin);\r\nreturn (snd_hda_get_input_pin_attr(val) != INPUT_PIN_ATTR_INT);\r\n}\r\nstatic hda_nid_t get_adc(struct hda_codec *codec, hda_nid_t pin,\r\nunsigned int *idxp)\r\n{\r\nint i, idx;\r\nhda_nid_t nid;\r\nnid = codec->start_nid;\r\nfor (i = 0; i < codec->num_nodes; i++, nid++) {\r\nunsigned int type;\r\ntype = get_wcaps_type(get_wcaps(codec, nid));\r\nif (type != AC_WID_AUD_IN)\r\ncontinue;\r\nidx = snd_hda_get_conn_index(codec, nid, pin, false);\r\nif (idx >= 0) {\r\n*idxp = idx;\r\nreturn nid;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int is_active_pin(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nunsigned int val;\r\nval = snd_hda_codec_get_pincfg(codec, nid);\r\nreturn (get_defcfg_connect(val) != AC_JACK_PORT_NONE);\r\n}\r\nstatic int parse_output(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nint i, extra_nids;\r\nhda_nid_t dac;\r\nfor (i = 0; i < cfg->line_outs; i++) {\r\ndac = get_dac(codec, cfg->line_out_pins[i]);\r\nif (!dac)\r\nbreak;\r\nspec->dac_nid[i] = dac;\r\n}\r\nspec->multiout.num_dacs = i;\r\nspec->multiout.dac_nids = spec->dac_nid;\r\nspec->multiout.max_channels = i * 2;\r\nextra_nids = 0;\r\nfor (i = 0; i < cfg->hp_outs; i++) {\r\ndac = get_dac(codec, cfg->hp_pins[i]);\r\nif (!dac)\r\nbreak;\r\nif (!i)\r\nspec->multiout.hp_nid = dac;\r\nelse\r\nspec->multiout.extra_out_nid[extra_nids++] = dac;\r\n}\r\nfor (i = 0; i < cfg->speaker_outs; i++) {\r\ndac = get_dac(codec, cfg->speaker_pins[i]);\r\nif (!dac)\r\nbreak;\r\nspec->multiout.extra_out_nid[extra_nids++] = dac;\r\n}\r\nif (cfg->line_out_type == AUTO_PIN_SPEAKER_OUT) {\r\ncfg->speaker_outs = cfg->line_outs;\r\nmemcpy(cfg->speaker_pins, cfg->line_out_pins,\r\nsizeof(cfg->speaker_pins));\r\ncfg->line_outs = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int parse_input(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nint i;\r\nfor (i = 0; i < cfg->num_inputs; i++) {\r\nhda_nid_t pin = cfg->inputs[i].pin;\r\nspec->input_idx[spec->num_inputs] = i;\r\nspec->capsrc_idx[i] = spec->num_inputs++;\r\nspec->cur_input = i;\r\nspec->adc_nid[i] = get_adc(codec, pin, &spec->adc_idx[i]);\r\n}\r\nif (!spec->num_inputs)\r\nreturn 0;\r\nif (spec->num_inputs == 2 &&\r\ncfg->inputs[0].type == AUTO_PIN_MIC &&\r\ncfg->inputs[1].type == AUTO_PIN_MIC) {\r\nif (is_ext_mic(codec, cfg->inputs[0].pin)) {\r\nif (!is_ext_mic(codec, cfg->inputs[1].pin)) {\r\nspec->mic_detect = 1;\r\nspec->automic_idx = 0;\r\n}\r\n} else {\r\nif (is_ext_mic(codec, cfg->inputs[1].pin)) {\r\nspec->mic_detect = 1;\r\nspec->automic_idx = 1;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int parse_digital_output(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nhda_nid_t nid;\r\nif (!cfg->dig_outs)\r\nreturn 0;\r\nif (snd_hda_get_connections(codec, cfg->dig_out_pins[0], &nid, 1) < 1)\r\nreturn 0;\r\nspec->multiout.dig_out_nid = nid;\r\nspec->multiout.share_spdif = 1;\r\nif (cfg->dig_outs > 1 &&\r\nsnd_hda_get_connections(codec, cfg->dig_out_pins[1], &nid, 1) > 0) {\r\nspec->slave_dig_outs[0] = nid;\r\ncodec->slave_dig_outs = spec->slave_dig_outs;\r\n}\r\nreturn 0;\r\n}\r\nstatic int parse_digital_input(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nint idx;\r\nif (cfg->dig_in_pin)\r\nspec->dig_in = get_adc(codec, cfg->dig_in_pin, &idx);\r\nreturn 0;\r\n}\r\nstatic int add_mute(struct hda_codec *codec, const char *name, int index,\r\nunsigned int pval, int dir, struct snd_kcontrol **kctlp)\r\n{\r\nchar tmp[44];\r\nstruct snd_kcontrol_new knew =\r\nHDA_CODEC_MUTE_IDX(tmp, index, 0, 0, HDA_OUTPUT);\r\nknew.private_value = pval;\r\nsnprintf(tmp, sizeof(tmp), "%s %s Switch", name, dir_sfx[dir]);\r\n*kctlp = snd_ctl_new1(&knew, codec);\r\n(*kctlp)->id.subdevice = HDA_SUBDEV_AMP_FLAG;\r\nreturn snd_hda_ctl_add(codec, 0, *kctlp);\r\n}\r\nstatic int add_volume(struct hda_codec *codec, const char *name,\r\nint index, unsigned int pval, int dir,\r\nstruct snd_kcontrol **kctlp)\r\n{\r\nchar tmp[44];\r\nstruct snd_kcontrol_new knew =\r\nHDA_CODEC_VOLUME_IDX(tmp, index, 0, 0, HDA_OUTPUT);\r\nknew.private_value = pval;\r\nsnprintf(tmp, sizeof(tmp), "%s %s Volume", name, dir_sfx[dir]);\r\n*kctlp = snd_ctl_new1(&knew, codec);\r\n(*kctlp)->id.subdevice = HDA_SUBDEV_AMP_FLAG;\r\nreturn snd_hda_ctl_add(codec, 0, *kctlp);\r\n}\r\nstatic void fix_volume_caps(struct hda_codec *codec, hda_nid_t dac)\r\n{\r\nunsigned int caps;\r\ncaps = query_amp_caps(codec, dac, HDA_OUTPUT);\r\ncaps &= ~(0x7f << AC_AMPCAP_NUM_STEPS_SHIFT);\r\ncaps |= ((caps >> AC_AMPCAP_OFFSET_SHIFT) & 0x7f)\r\n<< AC_AMPCAP_NUM_STEPS_SHIFT;\r\nsnd_hda_override_amp_caps(codec, dac, HDA_OUTPUT, caps);\r\n}\r\nstatic int add_vmaster(struct hda_codec *codec, hda_nid_t dac)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nunsigned int tlv[4];\r\nint err;\r\nspec->vmaster_sw =\r\nsnd_ctl_make_virtual_master("Master Playback Switch", NULL);\r\nerr = snd_hda_ctl_add(codec, dac, spec->vmaster_sw);\r\nif (err < 0)\r\nreturn err;\r\nsnd_hda_set_vmaster_tlv(codec, dac, HDA_OUTPUT, tlv);\r\nspec->vmaster_vol =\r\nsnd_ctl_make_virtual_master("Master Playback Volume", tlv);\r\nerr = snd_hda_ctl_add(codec, dac, spec->vmaster_vol);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int add_output(struct hda_codec *codec, hda_nid_t dac, int idx,\r\nint num_ctls, int type)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nconst char *name;\r\nint err, index;\r\nstruct snd_kcontrol *kctl;\r\nstatic const char * const speakers[] = {\r\n"Front Speaker", "Surround Speaker", "Bass Speaker"\r\n};\r\nstatic const char * const line_outs[] = {\r\n"Front Line Out", "Surround Line Out", "Bass Line Out"\r\n};\r\nfix_volume_caps(codec, dac);\r\nif (!spec->vmaster_sw) {\r\nerr = add_vmaster(codec, dac);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nindex = 0;\r\nswitch (type) {\r\ncase AUTO_PIN_HP_OUT:\r\nname = "Headphone";\r\nindex = idx;\r\nbreak;\r\ncase AUTO_PIN_SPEAKER_OUT:\r\nif (num_ctls > 1)\r\nname = speakers[idx];\r\nelse\r\nname = "Speaker";\r\nbreak;\r\ndefault:\r\nif (num_ctls > 1)\r\nname = line_outs[idx];\r\nelse\r\nname = "Line Out";\r\nbreak;\r\n}\r\nerr = add_mute(codec, name, index,\r\nHDA_COMPOSE_AMP_VAL(dac, 3, 0, HDA_OUTPUT), 0, &kctl);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add_slave(spec->vmaster_sw, kctl);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_volume(codec, name, index,\r\nHDA_COMPOSE_AMP_VAL(dac, 3, 0, HDA_OUTPUT), 0, &kctl);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add_slave(spec->vmaster_vol, kctl);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int build_output(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nint i, err;\r\nfor (i = 0; i < cfg->line_outs; i++) {\r\nerr = add_output(codec, get_dac(codec, cfg->line_out_pins[i]),\r\ni, cfg->line_outs, cfg->line_out_type);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < cfg->hp_outs; i++) {\r\nerr = add_output(codec, get_dac(codec, cfg->hp_pins[i]),\r\ni, cfg->hp_outs, AUTO_PIN_HP_OUT);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < cfg->speaker_outs; i++) {\r\nerr = add_output(codec, get_dac(codec, cfg->speaker_pins[i]),\r\ni, cfg->speaker_outs, AUTO_PIN_SPEAKER_OUT);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int change_cur_input(struct hda_codec *codec, unsigned int idx,\r\nint force)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nif (spec->cur_input == idx && !force)\r\nreturn 0;\r\nif (spec->cur_adc && spec->cur_adc != spec->adc_nid[idx]) {\r\n__snd_hda_codec_cleanup_stream(codec, spec->cur_adc, 1);\r\nspec->cur_adc = spec->adc_nid[idx];\r\nsnd_hda_codec_setup_stream(codec, spec->cur_adc,\r\nspec->cur_adc_stream_tag, 0,\r\nspec->cur_adc_format);\r\n}\r\nspec->cur_input = idx;\r\ncs_update_input_select(codec);\r\nreturn 1;\r\n}\r\nstatic int cs_capture_source_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct cs_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nunsigned int idx;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = spec->num_inputs;\r\nif (uinfo->value.enumerated.item >= spec->num_inputs)\r\nuinfo->value.enumerated.item = spec->num_inputs - 1;\r\nidx = spec->input_idx[uinfo->value.enumerated.item];\r\nsnd_hda_get_pin_label(codec, cfg->inputs[idx].pin, cfg,\r\nuinfo->value.enumerated.name,\r\nsizeof(uinfo->value.enumerated.name), NULL);\r\nreturn 0;\r\n}\r\nstatic int cs_capture_source_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct cs_spec *spec = codec->spec;\r\nucontrol->value.enumerated.item[0] = spec->capsrc_idx[spec->cur_input];\r\nreturn 0;\r\n}\r\nstatic int cs_capture_source_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct cs_spec *spec = codec->spec;\r\nunsigned int idx = ucontrol->value.enumerated.item[0];\r\nif (idx >= spec->num_inputs)\r\nreturn -EINVAL;\r\nidx = spec->input_idx[idx];\r\nreturn change_cur_input(codec, idx, 0);\r\n}\r\nstatic const struct hda_bind_ctls *make_bind_capture(struct hda_codec *codec,\r\nstruct hda_ctl_ops *ops)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nstruct hda_bind_ctls *bind;\r\nint i, n;\r\nbind = kzalloc(sizeof(*bind) + sizeof(long) * (spec->num_inputs + 1),\r\nGFP_KERNEL);\r\nif (!bind)\r\nreturn NULL;\r\nbind->ops = ops;\r\nn = 0;\r\nfor (i = 0; i < AUTO_PIN_LAST; i++) {\r\nif (!spec->adc_nid[i])\r\ncontinue;\r\nbind->values[n++] =\r\nHDA_COMPOSE_AMP_VAL(spec->adc_nid[i], 3,\r\nspec->adc_idx[i], HDA_INPUT);\r\n}\r\nreturn bind;\r\n}\r\nstatic int add_input_volume_control(struct hda_codec *codec,\r\nstruct auto_pin_cfg *cfg,\r\nint item)\r\n{\r\nhda_nid_t pin = cfg->inputs[item].pin;\r\nu32 caps;\r\nconst char *label;\r\nstruct snd_kcontrol *kctl;\r\nif (!(get_wcaps(codec, pin) & AC_WCAP_IN_AMP))\r\nreturn 0;\r\ncaps = query_amp_caps(codec, pin, HDA_INPUT);\r\ncaps = (caps & AC_AMPCAP_NUM_STEPS) >> AC_AMPCAP_NUM_STEPS_SHIFT;\r\nif (caps <= 1)\r\nreturn 0;\r\nlabel = hda_get_autocfg_input_label(codec, cfg, item);\r\nreturn add_volume(codec, label, 0,\r\nHDA_COMPOSE_AMP_VAL(pin, 3, 0, HDA_INPUT), 1, &kctl);\r\n}\r\nstatic int build_input(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nint i, err;\r\nif (!spec->num_inputs)\r\nreturn 0;\r\nspec->capture_bind[0] = make_bind_capture(codec, &snd_hda_bind_sw);\r\nspec->capture_bind[1] = make_bind_capture(codec, &snd_hda_bind_vol);\r\nfor (i = 0; i < 2; i++) {\r\nstruct snd_kcontrol *kctl;\r\nint n;\r\nif (!spec->capture_bind[i])\r\nreturn -ENOMEM;\r\nkctl = snd_ctl_new1(&cs_capture_ctls[i], codec);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nkctl->private_value = (long)spec->capture_bind[i];\r\nerr = snd_hda_ctl_add(codec, 0, kctl);\r\nif (err < 0)\r\nreturn err;\r\nfor (n = 0; n < AUTO_PIN_LAST; n++) {\r\nif (!spec->adc_nid[n])\r\ncontinue;\r\nerr = snd_hda_add_nid(codec, kctl, 0, spec->adc_nid[n]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nif (spec->num_inputs > 1 && !spec->mic_detect) {\r\nerr = snd_hda_ctl_add(codec, 0,\r\nsnd_ctl_new1(&cs_capture_source, codec));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < spec->num_inputs; i++) {\r\nerr = add_input_volume_control(codec, &spec->autocfg, i);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int build_digital_output(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nint err;\r\nif (!spec->multiout.dig_out_nid)\r\nreturn 0;\r\nerr = snd_hda_create_spdif_out_ctls(codec, spec->multiout.dig_out_nid,\r\nspec->multiout.dig_out_nid);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_hda_create_spdif_share_sw(codec, &spec->multiout);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int build_digital_input(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nif (spec->dig_in)\r\nreturn snd_hda_create_spdif_in_ctls(codec, spec->dig_in);\r\nreturn 0;\r\n}\r\nstatic void cs_automute(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nunsigned int hp_present;\r\nunsigned int spdif_present;\r\nhda_nid_t nid;\r\nint i;\r\nspdif_present = 0;\r\nif (cfg->dig_outs) {\r\nnid = cfg->dig_out_pins[0];\r\nif (is_jack_detectable(codec, nid)) {\r\nif (snd_hda_jack_detect(codec, nid)\r\n)\r\nspdif_present = 1;\r\n}\r\n}\r\nhp_present = 0;\r\nfor (i = 0; i < cfg->hp_outs; i++) {\r\nnid = cfg->hp_pins[i];\r\nif (!is_jack_detectable(codec, nid))\r\ncontinue;\r\nhp_present = snd_hda_jack_detect(codec, nid);\r\nif (hp_present)\r\nbreak;\r\n}\r\nfor (i = 0; i < cfg->speaker_outs; i++) {\r\nint pin_ctl = hp_present ? 0 : PIN_OUT;\r\nif (spdif_present && (spec->vendor_nid == CS4210_VENDOR_NID))\r\npin_ctl = 0;\r\nnid = cfg->speaker_pins[i];\r\nsnd_hda_codec_write(codec, nid, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL, pin_ctl);\r\n}\r\nif (spec->gpio_eapd_hp) {\r\nunsigned int gpio = hp_present ?\r\nspec->gpio_eapd_hp : spec->gpio_eapd_speaker;\r\nsnd_hda_codec_write(codec, 0x01, 0,\r\nAC_VERB_SET_GPIO_DATA, gpio);\r\n}\r\nif (spec->vendor_nid == CS4210_VENDOR_NID) {\r\nfor (i = 0; i < cfg->hp_outs; i++) {\r\nnid = cfg->hp_pins[i];\r\nsnd_hda_codec_write(codec, nid, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL,\r\n(spdif_present && spec->sense_b) ? 0 : PIN_HP);\r\n}\r\nif (cfg->dig_outs) {\r\nnid = cfg->dig_out_pins[0];\r\nsnd_hda_codec_write(codec, nid, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL,\r\nspdif_present ? PIN_OUT : 0);\r\n}\r\n}\r\n}\r\nstatic void cs_automic(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nhda_nid_t nid;\r\nunsigned int present;\r\nnid = cfg->inputs[spec->automic_idx].pin;\r\npresent = snd_hda_jack_detect(codec, nid);\r\nif (spec->vendor_nid == CS420X_VENDOR_NID) {\r\nif (present)\r\nchange_cur_input(codec, spec->automic_idx, 0);\r\nelse\r\nchange_cur_input(codec, !spec->automic_idx, 0);\r\n} else {\r\nif (present) {\r\nif (spec->cur_input != spec->automic_idx) {\r\nspec->last_input = spec->cur_input;\r\nspec->cur_input = spec->automic_idx;\r\n}\r\n} else {\r\nspec->cur_input = spec->last_input;\r\n}\r\ncs_update_input_select(codec);\r\n}\r\n}\r\nstatic void init_output(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nint i;\r\nfor (i = 0; i < spec->multiout.num_dacs; i++)\r\nsnd_hda_codec_write(codec, spec->multiout.dac_nids[i], 0,\r\nAC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE);\r\nif (spec->multiout.hp_nid)\r\nsnd_hda_codec_write(codec, spec->multiout.hp_nid, 0,\r\nAC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE);\r\nfor (i = 0; i < ARRAY_SIZE(spec->multiout.extra_out_nid); i++) {\r\nif (!spec->multiout.extra_out_nid[i])\r\nbreak;\r\nsnd_hda_codec_write(codec, spec->multiout.extra_out_nid[i], 0,\r\nAC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_MUTE);\r\n}\r\nfor (i = 0; i < cfg->line_outs; i++)\r\nsnd_hda_codec_write(codec, cfg->line_out_pins[i], 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT);\r\nfor (i = 0; i < cfg->hp_outs; i++) {\r\nhda_nid_t nid = cfg->hp_pins[i];\r\nsnd_hda_codec_write(codec, nid, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL, PIN_HP);\r\nif (!cfg->speaker_outs)\r\ncontinue;\r\nif (get_wcaps(codec, nid) & AC_WCAP_UNSOL_CAP) {\r\nsnd_hda_jack_detect_enable(codec, nid, HP_EVENT);\r\nspec->hp_detect = 1;\r\n}\r\n}\r\nfor (i = 0; i < cfg->speaker_outs; i++)\r\nsnd_hda_codec_write(codec, cfg->speaker_pins[i], 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT);\r\nif (spec->hp_detect || spec->spdif_detect)\r\ncs_automute(codec);\r\n}\r\nstatic void init_input(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nunsigned int coef;\r\nint i;\r\nfor (i = 0; i < cfg->num_inputs; i++) {\r\nunsigned int ctl;\r\nhda_nid_t pin = cfg->inputs[i].pin;\r\nif (!spec->adc_nid[i])\r\ncontinue;\r\nctl = PIN_IN;\r\nif (cfg->inputs[i].type == AUTO_PIN_MIC) {\r\nunsigned int caps = snd_hda_query_pin_caps(codec, pin);\r\ncaps >>= AC_PINCAP_VREF_SHIFT;\r\nif (caps & AC_PINCAP_VREF_80)\r\nctl = PIN_VREF80;\r\n}\r\nsnd_hda_codec_write(codec, pin, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL, ctl);\r\nsnd_hda_codec_write(codec, spec->adc_nid[i], 0,\r\nAC_VERB_SET_AMP_GAIN_MUTE,\r\nAMP_IN_MUTE(spec->adc_idx[i]));\r\nif (spec->mic_detect && spec->automic_idx == i)\r\nsnd_hda_jack_detect_enable(codec, pin, MIC_EVENT);\r\n}\r\nif (spec->vendor_nid == CS420X_VENDOR_NID) {\r\nchange_cur_input(codec, spec->cur_input, 1);\r\nif (spec->mic_detect)\r\ncs_automic(codec);\r\ncoef = 0x000a;\r\nif (is_active_pin(codec, CS_DMIC2_PIN_NID))\r\ncoef |= 0x0500;\r\nif (is_active_pin(codec, CS_DMIC1_PIN_NID))\r\ncoef |= 0x1800;\r\ncs_vendor_coef_set(codec, IDX_ADC_CFG, coef);\r\n} else {\r\nif (spec->mic_detect)\r\ncs_automic(codec);\r\nelse {\r\nspec->cur_adc = spec->adc_nid[spec->cur_input];\r\ncs_update_input_select(codec);\r\n}\r\n}\r\n}\r\nstatic void init_digital(struct hda_codec *codec)\r\n{\r\nunsigned int coef;\r\ncoef = 0x0002;\r\ncoef |= 0x0008;\r\nif (is_active_pin(codec, CS_DIG_OUT2_PIN_NID))\r\ncoef |= 0x4000;\r\ncs_vendor_coef_set(codec, IDX_SPDIF_CTL, coef);\r\n}\r\nstatic int cs_init(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nsnd_hda_sequence_write(codec, cs_errata_init_verbs);\r\nsnd_hda_sequence_write(codec, cs_coef_init_verbs);\r\nif (spec->gpio_mask) {\r\nsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_MASK,\r\nspec->gpio_mask);\r\nsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_DIRECTION,\r\nspec->gpio_dir);\r\nsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_DATA,\r\nspec->gpio_data);\r\n}\r\ninit_output(codec);\r\ninit_input(codec);\r\ninit_digital(codec);\r\nsnd_hda_jack_report_sync(codec);\r\nreturn 0;\r\n}\r\nstatic int cs_build_controls(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nint err;\r\nerr = build_output(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = build_input(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = build_digital_output(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = build_digital_input(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = cs_init(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_hda_jack_add_kctls(codec, &spec->autocfg);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void cs_free(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nkfree(spec->capture_bind[0]);\r\nkfree(spec->capture_bind[1]);\r\nkfree(codec->spec);\r\n}\r\nstatic void cs_unsol_event(struct hda_codec *codec, unsigned int res)\r\n{\r\nswitch (snd_hda_jack_get_action(codec, res >> 26)) {\r\ncase HP_EVENT:\r\ncs_automute(codec);\r\nbreak;\r\ncase MIC_EVENT:\r\ncs_automic(codec);\r\nbreak;\r\n}\r\nsnd_hda_jack_report_sync(codec);\r\n}\r\nstatic int cs_parse_auto_config(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nint err;\r\nerr = snd_hda_parse_pin_def_config(codec, &spec->autocfg, NULL);\r\nif (err < 0)\r\nreturn err;\r\nerr = parse_output(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = parse_input(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = parse_digital_output(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = parse_digital_input(codec);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void fix_pincfg(struct hda_codec *codec, int model,\r\nconst struct cs_pincfg **pin_configs)\r\n{\r\nconst struct cs_pincfg *cfg = pin_configs[model];\r\nif (!cfg)\r\nreturn;\r\nfor (; cfg->nid; cfg++)\r\nsnd_hda_codec_set_pincfg(codec, cfg->nid, cfg->val);\r\n}\r\nstatic int patch_cs420x(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec;\r\nint err;\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\ncodec->spec = spec;\r\nspec->vendor_nid = CS420X_VENDOR_NID;\r\nspec->board_config =\r\nsnd_hda_check_board_config(codec, CS420X_MODELS,\r\ncs420x_models, cs420x_cfg_tbl);\r\nif (spec->board_config < 0)\r\nspec->board_config =\r\nsnd_hda_check_board_codec_sid_config(codec,\r\nCS420X_MODELS, NULL, cs420x_codec_cfg_tbl);\r\nif (spec->board_config >= 0)\r\nfix_pincfg(codec, spec->board_config, cs_pincfgs);\r\nswitch (spec->board_config) {\r\ncase CS420X_IMAC27:\r\ncase CS420X_MBP53:\r\ncase CS420X_MBP55:\r\ncase CS420X_APPLE:\r\nspec->gpio_eapd_hp = 2;\r\nspec->gpio_eapd_speaker = 8;\r\nspec->gpio_mask = spec->gpio_dir =\r\nspec->gpio_eapd_hp | spec->gpio_eapd_speaker;\r\nbreak;\r\ncase CS420X_IMAC27_122:\r\nspec->gpio_eapd_hp = 4;\r\nspec->gpio_eapd_speaker = 8;\r\nspec->gpio_mask = spec->gpio_dir =\r\nspec->gpio_eapd_hp | spec->gpio_eapd_speaker;\r\nbreak;\r\n}\r\nerr = cs_parse_auto_config(codec);\r\nif (err < 0)\r\ngoto error;\r\ncodec->patch_ops = cs_patch_ops;\r\nreturn 0;\r\nerror:\r\nkfree(codec->spec);\r\ncodec->spec = NULL;\r\nreturn err;\r\n}\r\nstatic int cs421x_boost_vol_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 3;\r\nreturn 0;\r\n}\r\nstatic int cs421x_boost_vol_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] =\r\ncs_vendor_coef_get(codec, CS421X_IDX_SPK_CTL) & 0x0003;\r\nreturn 0;\r\n}\r\nstatic int cs421x_boost_vol_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nunsigned int vol = ucontrol->value.integer.value[0];\r\nunsigned int coef =\r\ncs_vendor_coef_get(codec, CS421X_IDX_SPK_CTL);\r\nunsigned int original_coef = coef;\r\ncoef &= ~0x0003;\r\ncoef |= (vol & 0x0003);\r\nif (original_coef == coef)\r\nreturn 0;\r\nelse {\r\ncs_vendor_coef_set(codec, CS421X_IDX_SPK_CTL, coef);\r\nreturn 1;\r\n}\r\n}\r\nstatic void cs4210_pinmux_init(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nunsigned int def_conf, coef;\r\ncoef = cs_vendor_coef_get(codec, CS421X_IDX_DEV_CFG);\r\nif (spec->gpio_mask)\r\ncoef |= 0x0008;\r\nelse\r\ncoef &= ~0x0008;\r\nif (spec->sense_b)\r\ncoef |= 0x0010;\r\nelse\r\ncoef &= ~0x0010;\r\ncs_vendor_coef_set(codec, CS421X_IDX_DEV_CFG, coef);\r\nif ((spec->gpio_mask || spec->sense_b) &&\r\nis_active_pin(codec, CS421X_DMIC_PIN_NID)) {\r\ndef_conf = snd_hda_codec_get_pincfg(codec, CS421X_DMIC_PIN_NID);\r\ndef_conf &= ~AC_DEFCFG_PORT_CONN;\r\ndef_conf |= (AC_JACK_PORT_NONE << AC_DEFCFG_PORT_CONN_SHIFT);\r\nsnd_hda_codec_set_pincfg(codec, CS421X_DMIC_PIN_NID, def_conf);\r\n}\r\n}\r\nstatic void init_cs421x_digital(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nint i;\r\nfor (i = 0; i < cfg->dig_outs; i++) {\r\nhda_nid_t nid = cfg->dig_out_pins[i];\r\nif (!cfg->speaker_outs)\r\ncontinue;\r\nif (get_wcaps(codec, nid) & AC_WCAP_UNSOL_CAP) {\r\nsnd_hda_jack_detect_enable(codec, nid, SPDIF_EVENT);\r\nspec->spdif_detect = 1;\r\n}\r\n}\r\n}\r\nstatic int cs421x_init(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nif (spec->vendor_nid == CS4210_VENDOR_NID) {\r\nsnd_hda_sequence_write(codec, cs421x_coef_init_verbs);\r\nsnd_hda_sequence_write(codec, cs421x_coef_init_verbs_A1_silicon_fixes);\r\ncs4210_pinmux_init(codec);\r\n}\r\nif (spec->gpio_mask) {\r\nsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_MASK,\r\nspec->gpio_mask);\r\nsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_DIRECTION,\r\nspec->gpio_dir);\r\nsnd_hda_codec_write(codec, 0x01, 0, AC_VERB_SET_GPIO_DATA,\r\nspec->gpio_data);\r\n}\r\ninit_output(codec);\r\ninit_input(codec);\r\ninit_cs421x_digital(codec);\r\nsnd_hda_jack_report_sync(codec);\r\nreturn 0;\r\n}\r\nstatic int cs421x_mux_enum_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct cs_spec *spec = codec->spec;\r\nreturn snd_hda_input_mux_info(&spec->input_mux, uinfo);\r\n}\r\nstatic int cs421x_mux_enum_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct cs_spec *spec = codec->spec;\r\nucontrol->value.enumerated.item[0] = spec->cur_input;\r\nreturn 0;\r\n}\r\nstatic int cs421x_mux_enum_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct cs_spec *spec = codec->spec;\r\nreturn snd_hda_input_mux_put(codec, &spec->input_mux, ucontrol,\r\nspec->adc_nid[0], &spec->cur_input);\r\n}\r\nstatic int cs421x_add_input_volume_control(struct hda_codec *codec, int item)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nconst struct hda_input_mux *imux = &spec->input_mux;\r\nhda_nid_t pin = cfg->inputs[item].pin;\r\nstruct snd_kcontrol *kctl;\r\nu32 caps;\r\nif (!(get_wcaps(codec, pin) & AC_WCAP_IN_AMP))\r\nreturn 0;\r\ncaps = query_amp_caps(codec, pin, HDA_INPUT);\r\ncaps = (caps & AC_AMPCAP_NUM_STEPS) >> AC_AMPCAP_NUM_STEPS_SHIFT;\r\nif (caps <= 1)\r\nreturn 0;\r\nreturn add_volume(codec, imux->items[item].label, 0,\r\nHDA_COMPOSE_AMP_VAL(pin, 3, 0, HDA_INPUT), 1, &kctl);\r\n}\r\nstatic int build_cs421x_input(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nstruct hda_input_mux *imux = &spec->input_mux;\r\nint i, err, type_idx;\r\nconst char *label;\r\nif (!spec->num_inputs)\r\nreturn 0;\r\nspec->capture_bind[0] = make_bind_capture(codec, &snd_hda_bind_sw);\r\nspec->capture_bind[1] = make_bind_capture(codec, &snd_hda_bind_vol);\r\nfor (i = 0; i < 2; i++) {\r\nstruct snd_kcontrol *kctl;\r\nint n;\r\nif (!spec->capture_bind[i])\r\nreturn -ENOMEM;\r\nkctl = snd_ctl_new1(&cs_capture_ctls[i], codec);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nkctl->private_value = (long)spec->capture_bind[i];\r\nerr = snd_hda_ctl_add(codec, 0, kctl);\r\nif (err < 0)\r\nreturn err;\r\nfor (n = 0; n < AUTO_PIN_LAST; n++) {\r\nif (!spec->adc_nid[n])\r\ncontinue;\r\nerr = snd_hda_add_nid(codec, kctl, 0, spec->adc_nid[n]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nfor (i = 0; i < spec->num_inputs; i++) {\r\nlabel = hda_get_autocfg_input_label(codec, cfg, i);\r\nsnd_hda_add_imux_item(imux, label, spec->adc_idx[i], &type_idx);\r\nerr = cs421x_add_input_volume_control(codec, i);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif ((spec->num_inputs == 2 && !spec->mic_detect) ||\r\n(spec->num_inputs == 3)) {\r\nerr = snd_hda_ctl_add(codec, spec->adc_nid[0],\r\nsnd_ctl_new1(&cs421x_capture_source, codec));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int build_cs421x_output(struct hda_codec *codec)\r\n{\r\nhda_nid_t dac = CS4210_DAC_NID;\r\nstruct cs_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nstruct snd_kcontrol *kctl;\r\nint err;\r\nchar *name = "Master";\r\nfix_volume_caps(codec, dac);\r\nerr = add_mute(codec, name, 0,\r\nHDA_COMPOSE_AMP_VAL(dac, 3, 0, HDA_OUTPUT), 0, &kctl);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_volume(codec, name, 0,\r\nHDA_COMPOSE_AMP_VAL(dac, 3, 0, HDA_OUTPUT), 0, &kctl);\r\nif (err < 0)\r\nreturn err;\r\nif (cfg->speaker_outs && (spec->vendor_nid == CS4210_VENDOR_NID)) {\r\nerr = snd_hda_ctl_add(codec, 0,\r\nsnd_ctl_new1(&cs421x_speaker_bost_ctl, codec));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nstatic int cs421x_build_controls(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nint err;\r\nerr = build_cs421x_output(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = build_cs421x_input(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = build_digital_output(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = cs421x_init(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_hda_jack_add_kctls(codec, &spec->autocfg);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void cs421x_unsol_event(struct hda_codec *codec, unsigned int res)\r\n{\r\nswitch (snd_hda_jack_get_action(codec, res >> 26)) {\r\ncase HP_EVENT:\r\ncase SPDIF_EVENT:\r\ncs_automute(codec);\r\nbreak;\r\ncase MIC_EVENT:\r\ncs_automic(codec);\r\nbreak;\r\n}\r\nsnd_hda_jack_report_sync(codec);\r\n}\r\nstatic int parse_cs421x_input(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nint i;\r\nfor (i = 0; i < cfg->num_inputs; i++) {\r\nhda_nid_t pin = cfg->inputs[i].pin;\r\nspec->adc_nid[i] = get_adc(codec, pin, &spec->adc_idx[i]);\r\nspec->cur_input = spec->last_input = i;\r\nspec->num_inputs++;\r\nif (is_ext_mic(codec, i) && cfg->num_inputs >= 2) {\r\nspec->mic_detect = 1;\r\nspec->automic_idx = i;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cs421x_parse_auto_config(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nint err;\r\nerr = snd_hda_parse_pin_def_config(codec, &spec->autocfg, NULL);\r\nif (err < 0)\r\nreturn err;\r\nerr = parse_output(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = parse_cs421x_input(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = parse_digital_output(codec);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int cs421x_suspend(struct hda_codec *codec, pm_message_t state)\r\n{\r\nstruct cs_spec *spec = codec->spec;\r\nunsigned int coef;\r\nsnd_hda_shutup_pins(codec);\r\nsnd_hda_codec_write(codec, CS4210_DAC_NID, 0,\r\nAC_VERB_SET_POWER_STATE, AC_PWRST_D3);\r\nsnd_hda_codec_write(codec, CS4210_ADC_NID, 0,\r\nAC_VERB_SET_POWER_STATE, AC_PWRST_D3);\r\nif (spec->vendor_nid == CS4210_VENDOR_NID) {\r\ncoef = cs_vendor_coef_get(codec, CS421X_IDX_DEV_CFG);\r\ncoef |= 0x0004;\r\ncs_vendor_coef_set(codec, CS421X_IDX_DEV_CFG, coef);\r\n}\r\nreturn 0;\r\n}\r\nstatic int patch_cs4210(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec;\r\nint err;\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\ncodec->spec = spec;\r\nspec->vendor_nid = CS4210_VENDOR_NID;\r\nspec->board_config =\r\nsnd_hda_check_board_config(codec, CS421X_MODELS,\r\ncs421x_models, cs421x_cfg_tbl);\r\nif (spec->board_config >= 0)\r\nfix_pincfg(codec, spec->board_config, cs421x_pincfgs);\r\nswitch (spec->board_config) {\r\ncase CS421X_CDB4210:\r\nsnd_printd("CS4210 board: %s\n",\r\ncs421x_models[spec->board_config]);\r\nspec->sense_b = 1;\r\nbreak;\r\n}\r\ncs4210_pinmux_init(codec);\r\nerr = cs421x_parse_auto_config(codec);\r\nif (err < 0)\r\ngoto error;\r\ncodec->patch_ops = cs421x_patch_ops;\r\nreturn 0;\r\nerror:\r\nkfree(codec->spec);\r\ncodec->spec = NULL;\r\nreturn err;\r\n}\r\nstatic int patch_cs4213(struct hda_codec *codec)\r\n{\r\nstruct cs_spec *spec;\r\nint err;\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\ncodec->spec = spec;\r\nspec->vendor_nid = CS4213_VENDOR_NID;\r\nerr = cs421x_parse_auto_config(codec);\r\nif (err < 0)\r\ngoto error;\r\ncodec->patch_ops = cs421x_patch_ops;\r\nreturn 0;\r\nerror:\r\nkfree(codec->spec);\r\ncodec->spec = NULL;\r\nreturn err;\r\n}\r\nstatic int __init patch_cirrus_init(void)\r\n{\r\nreturn snd_hda_add_codec_preset(&cirrus_list);\r\n}\r\nstatic void __exit patch_cirrus_exit(void)\r\n{\r\nsnd_hda_delete_codec_preset(&cirrus_list);\r\n}
