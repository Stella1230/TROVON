void dload_error(struct dload_state *dlthis, const char *errtxt, ...)\r\n{\r\nva_list args;\r\nva_start(args, errtxt);\r\ndlthis->mysym->error_report(dlthis->mysym, errtxt, args);\r\nva_end(args);\r\ndlthis->dload_errcount += 1;\r\n}\r\nvoid dload_syms_error(struct dynamic_loader_sym *syms, const char *errtxt, ...)\r\n{\r\nva_list args;\r\nva_start(args, errtxt);\r\nsyms->error_report(syms, errtxt, args);\r\nva_end(args);\r\n}\r\nint dynamic_load_module(struct dynamic_loader_stream *module,\r\nstruct dynamic_loader_sym *syms,\r\nstruct dynamic_loader_allocate *alloc,\r\nstruct dynamic_loader_initialize *init,\r\nunsigned options, void **mhandle)\r\n{\r\nregister unsigned *dp, sz;\r\nstruct dload_state dl_state;\r\ndp = (unsigned *)&dl_state;\r\nfor (sz = sizeof(dl_state) / sizeof(unsigned); sz > 0; sz -= 1)\r\n*dp++ = 0;\r\nif ((options & DLOAD_INITBSS) == DLOAD_INITBSS)\r\ndl_state.myoptions = DLOAD_INITBSS;\r\nif (!module || !syms) {\r\ndload_error(&dl_state, "Required parameter is NULL");\r\n} else {\r\ndl_state.strm = module;\r\ndl_state.mysym = syms;\r\ndload_headers(&dl_state);\r\nif (!dl_state.dload_errcount)\r\ndload_strings(&dl_state, false);\r\nif (!dl_state.dload_errcount)\r\ndload_sections(&dl_state);\r\nif (init && !dl_state.dload_errcount) {\r\nif (init->connect(init)) {\r\ndl_state.myio = init;\r\ndl_state.myalloc = alloc;\r\nallocate_sections(&dl_state);\r\n} else\r\ndload_error(&dl_state, iconnect);\r\n}\r\nif (!dl_state.dload_errcount) {\r\nunsigned sref = dl_state.dfile_hdr.df_entry_secn - 1;\r\nif (sref < dl_state.allocated_secn_count)\r\ndl_state.dfile_hdr.df_entrypt +=\r\ndl_state.ldr_sections[sref].run_addr;\r\ndload_symbols(&dl_state);\r\n}\r\nif (init && !dl_state.dload_errcount)\r\ndload_data(&dl_state);\r\ninit_module_handle(&dl_state);\r\nif (dl_state.myio) {\r\nif ((!dl_state.dload_errcount) &&\r\n(dl_state.dfile_hdr.df_entry_secn != DN_UNDEF) &&\r\n(!init->execute(init,\r\ndl_state.dfile_hdr.df_entrypt)))\r\ndload_error(&dl_state, "Init->Execute Failed");\r\ninit->release(init);\r\n}\r\nsymbol_table_free(&dl_state);\r\nsection_table_free(&dl_state);\r\nstring_table_free(&dl_state);\r\ndload_tramp_cleanup(&dl_state);\r\nif (dl_state.dload_errcount) {\r\ndynamic_unload_module(dl_state.myhandle, syms, alloc,\r\ninit);\r\ndl_state.myhandle = NULL;\r\n}\r\n}\r\nif (mhandle)\r\n*mhandle = dl_state.myhandle;\r\nreturn dl_state.dload_errcount;\r\n}\r\nint\r\ndynamic_open_module(struct dynamic_loader_stream *module,\r\nstruct dynamic_loader_sym *syms,\r\nstruct dynamic_loader_allocate *alloc,\r\nstruct dynamic_loader_initialize *init,\r\nunsigned options, void **mhandle)\r\n{\r\nregister unsigned *dp, sz;\r\nstruct dload_state dl_state;\r\ndp = (unsigned *)&dl_state;\r\nfor (sz = sizeof(dl_state) / sizeof(unsigned); sz > 0; sz -= 1)\r\n*dp++ = 0;\r\nif ((options & DLOAD_INITBSS) == DLOAD_INITBSS)\r\ndl_state.myoptions = DLOAD_INITBSS;\r\nif (!module || !syms) {\r\ndload_error(&dl_state, "Required parameter is NULL");\r\n} else {\r\ndl_state.strm = module;\r\ndl_state.mysym = syms;\r\ndload_headers(&dl_state);\r\nif (!dl_state.dload_errcount)\r\ndload_strings(&dl_state, false);\r\nif (!dl_state.dload_errcount)\r\ndload_sections(&dl_state);\r\nif (init && !dl_state.dload_errcount) {\r\nif (init->connect(init)) {\r\ndl_state.myio = init;\r\ndl_state.myalloc = alloc;\r\nallocate_sections(&dl_state);\r\n} else\r\ndload_error(&dl_state, iconnect);\r\n}\r\nif (!dl_state.dload_errcount) {\r\nunsigned sref = dl_state.dfile_hdr.df_entry_secn - 1;\r\nif (sref < dl_state.allocated_secn_count)\r\ndl_state.dfile_hdr.df_entrypt +=\r\ndl_state.ldr_sections[sref].run_addr;\r\ndload_symbols(&dl_state);\r\n}\r\ninit_module_handle(&dl_state);\r\nif (dl_state.myio) {\r\nif ((!dl_state.dload_errcount) &&\r\n(dl_state.dfile_hdr.df_entry_secn != DN_UNDEF) &&\r\n(!init->execute(init,\r\ndl_state.dfile_hdr.df_entrypt)))\r\ndload_error(&dl_state, "Init->Execute Failed");\r\ninit->release(init);\r\n}\r\nsymbol_table_free(&dl_state);\r\nsection_table_free(&dl_state);\r\nstring_table_free(&dl_state);\r\nif (dl_state.dload_errcount) {\r\ndynamic_unload_module(dl_state.myhandle, syms, alloc,\r\ninit);\r\ndl_state.myhandle = NULL;\r\n}\r\n}\r\nif (mhandle)\r\n*mhandle = dl_state.myhandle;\r\nreturn dl_state.dload_errcount;\r\n}\r\nvoid dload_headers(struct dload_state *dlthis)\r\n{\r\nu32 map;\r\nif (dlthis->strm->read_buffer(dlthis->strm, &dlthis->dfile_hdr,\r\nCOMBINED_HEADER_SIZE) !=\r\nCOMBINED_HEADER_SIZE) {\r\nDL_ERROR(readstrm, "File Headers");\r\nreturn;\r\n}\r\nmap = REORDER_MAP(dlthis->dfile_hdr.df_byte_reshuffle);\r\nif (map != REORDER_MAP(BYTE_RESHUFFLE_VALUE)) {\r\nif ((map & 0xFCFCFCFC) == 0) {\r\ndload_reorder(&dlthis->dfile_hdr, COMBINED_HEADER_SIZE,\r\nmap);\r\n}\r\nif (dlthis->dfile_hdr.df_byte_reshuffle !=\r\nBYTE_RESHUFFLE_VALUE) {\r\ndload_error(dlthis,\r\n"Bad byte swap map " FMT_UI32 " in header",\r\ndlthis->dfile_hdr.df_byte_reshuffle);\r\nreturn;\r\n}\r\ndlthis->reorder_map = map;\r\n}\r\nif (~dload_checksum(&dlthis->dfile_hdr,\r\nsizeof(struct doff_filehdr_t)) ||\r\n~dload_checksum(&dlthis->verify,\r\nsizeof(struct doff_verify_rec_t))) {\r\nDL_ERROR(err_checksum, "header or verify record");\r\nreturn;\r\n}\r\n#if HOST_ENDIANNESS\r\ndlthis->dfile_hdr.df_byte_reshuffle = map;\r\n#endif\r\nif ((dlthis->dfile_hdr.df_target_id != TARGET_ID) &&\r\n-(dlthis->dfile_hdr.df_target_id != TMS470_ID)) {\r\ndload_error(dlthis, "Bad target ID 0x%x and TARGET_ID 0x%x",\r\ndlthis->dfile_hdr.df_target_id, TARGET_ID);\r\nreturn;\r\n}\r\nif ((dlthis->dfile_hdr.df_doff_version != DOFF0)) {\r\ndload_error(dlthis, "Bad DOFF version 0x%x",\r\ndlthis->dfile_hdr.df_doff_version);\r\nreturn;\r\n}\r\nif (dlthis->dfile_hdr.df_strtab_size > MAX_REASONABLE_STRINGTAB) {\r\ndload_error(dlthis, "Excessive string table size " FMT_UI32,\r\ndlthis->dfile_hdr.df_strtab_size);\r\nreturn;\r\n}\r\nif (dlthis->dfile_hdr.df_no_scns > MAX_REASONABLE_SECTIONS) {\r\ndload_error(dlthis, "Excessive section count 0x%x",\r\ndlthis->dfile_hdr.df_no_scns);\r\nreturn;\r\n}\r\n#ifndef TARGET_ENDIANNESS\r\nif ((dlthis->dfile_hdr.df_flags >> ALIGN_COFF_ENDIANNESS) &\r\ndlthis->myoptions & ENDIANNESS_MASK) {\r\ndload_error(dlthis,\r\n"Input endianness disagrees with specified option");\r\nreturn;\r\n}\r\ndlthis->big_e_target = dlthis->dfile_hdr.df_flags & DF_BIG;\r\n#endif\r\n}\r\nvoid dload_sections(struct dload_state *dlthis)\r\n{\r\ns16 siz;\r\nstruct doff_scnhdr_t *shp;\r\nunsigned nsecs = dlthis->dfile_hdr.df_no_scns;\r\nsiz = nsecs * sizeof(struct doff_scnhdr_t);\r\nshp =\r\n(struct doff_scnhdr_t *)dlthis->mysym->dload_allocate(dlthis->mysym,\r\nsiz);\r\nif (!shp) {\r\nDL_ERROR(err_alloc, siz);\r\nreturn;\r\n}\r\ndlthis->sect_hdrs = shp;\r\nif (dlthis->strm->read_buffer(dlthis->strm, shp, siz) != siz) {\r\nDL_ERROR(readstrm, secn_errid);\r\nreturn;\r\n}\r\nif (dlthis->reorder_map)\r\ndload_reorder(shp, siz, dlthis->reorder_map);\r\nif (~dload_checksum(dlthis->sect_hdrs, siz) !=\r\ndlthis->verify.dv_scn_rec_checksum) {\r\nDL_ERROR(err_checksum, secn_errid);\r\nreturn;\r\n}\r\n}\r\nstatic void allocate_sections(struct dload_state *dlthis)\r\n{\r\nu16 curr_sect, nsecs, siz;\r\nstruct doff_scnhdr_t *shp;\r\nstruct ldr_section_info *asecs;\r\nstruct my_handle *hndl;\r\nnsecs = dlthis->dfile_hdr.df_no_scns;\r\nif (!nsecs)\r\nreturn;\r\nif ((dlthis->myalloc == NULL) &&\r\n(dlthis->dfile_hdr.df_target_scns > 0)) {\r\nDL_ERROR("Arg 3 (alloc) required but NULL", 0);\r\nreturn;\r\n}\r\nsiz = (dlthis->dfile_hdr.df_target_scns + 1) *\r\nsizeof(struct ldr_section_info) + MY_HANDLE_SIZE;\r\nhndl =\r\n(struct my_handle *)dlthis->mysym->dload_allocate(dlthis->mysym,\r\nsiz);\r\nif (!hndl) {\r\nDL_ERROR(err_alloc, siz);\r\nreturn;\r\n}\r\nhndl->dm.next = hndl->dm.prev = hndl;\r\nhndl->dm.root = NULL;\r\nhndl->dm.dbthis = 0;\r\ndlthis->myhandle = hndl;\r\ndlthis->ldr_sections = asecs = hndl->secns;\r\nshp = dlthis->sect_hdrs;\r\nfor (curr_sect = 0; curr_sect < nsecs; curr_sect++) {\r\nu32 soffset = shp->ds_offset;\r\n#if BITS_PER_AU <= BITS_PER_BYTE\r\nif (soffset < dlthis->dfile_hdr.df_strtab_size)\r\n((struct ldr_section_info *)shp)->name =\r\ndlthis->str_head + soffset;\r\nelse {\r\ndload_error(dlthis, "Bad name offset in section %d",\r\ncurr_sect);\r\n((struct ldr_section_info *)shp)->name = NULL;\r\n}\r\n#endif\r\nif (ds_needs_allocation(shp)) {\r\n*asecs = *(struct ldr_section_info *)shp;\r\nasecs->context = 0;\r\n#if BITS_PER_AU > BITS_PER_BYTE\r\nasecs->name = unpack_name(dlthis, soffset);\r\ndlthis->debug_string_size = soffset + dlthis->temp_len;\r\n#else\r\ndlthis->debug_string_size = soffset;\r\n#endif\r\nif (dlthis->myalloc != NULL) {\r\nif (!dlthis->myalloc->\r\ndload_allocate(dlthis->myalloc, asecs,\r\nds_alignment(asecs->type))) {\r\ndload_error(dlthis, tgtalloc,\r\nasecs->name, asecs->size);\r\nreturn;\r\n}\r\n}\r\nshp->ds_vaddr = asecs->load_addr - shp->ds_vaddr;\r\nshp->ds_paddr = asecs->run_addr - shp->ds_paddr;\r\ndlthis->allocated_secn_count += 1;\r\n}\r\nshp += 1;\r\nasecs += 1;\r\n}\r\n#if BITS_PER_AU <= BITS_PER_BYTE\r\ndlthis->debug_string_size +=\r\nstrlen(dlthis->str_head + dlthis->debug_string_size) + 1;\r\n#endif\r\n}\r\nstatic void section_table_free(struct dload_state *dlthis)\r\n{\r\nstruct doff_scnhdr_t *shp;\r\nshp = dlthis->sect_hdrs;\r\nif (shp)\r\ndlthis->mysym->dload_deallocate(dlthis->mysym, shp);\r\n}\r\nvoid dload_strings(struct dload_state *dlthis, bool sec_names_only)\r\n{\r\nu32 ssiz;\r\nchar *strbuf;\r\nif (sec_names_only) {\r\nssiz = BYTE_TO_HOST(DOFF_ALIGN\r\n(dlthis->dfile_hdr.df_scn_name_size));\r\n} else {\r\nssiz = BYTE_TO_HOST(DOFF_ALIGN\r\n(dlthis->dfile_hdr.df_strtab_size));\r\n}\r\nif (ssiz == 0)\r\nreturn;\r\n#if BITS_PER_AU > BITS_PER_BYTE\r\nstrbuf = (char *)dlthis->mysym->dload_allocate(dlthis->mysym, ssiz +\r\ndlthis->dfile_hdr.\r\ndf_max_str_len);\r\n#else\r\nstrbuf = (char *)dlthis->mysym->dload_allocate(dlthis->mysym, ssiz);\r\n#endif\r\nif (strbuf == NULL) {\r\nDL_ERROR(err_alloc, ssiz);\r\nreturn;\r\n}\r\ndlthis->str_head = strbuf;\r\n#if BITS_PER_AU > BITS_PER_BYTE\r\ndlthis->str_temp = strbuf + ssiz;\r\n#endif\r\nif ((unsigned)(dlthis->strm->read_buffer(dlthis->strm, strbuf,\r\nssiz)) != ssiz) {\r\nDL_ERROR(readstrm, stringtbl);\r\n}\r\n#ifndef _BIG_ENDIAN\r\nif (dlthis->reorder_map)\r\ndload_reorder(strbuf, ssiz, dlthis->reorder_map);\r\nif ((!sec_names_only) && (~dload_checksum(strbuf, ssiz) !=\r\ndlthis->verify.dv_str_tab_checksum)) {\r\nDL_ERROR(err_checksum, stringtbl);\r\n}\r\n#else\r\nif (dlthis->dfile_hdr.df_byte_reshuffle !=\r\nHOST_BYTE_ORDER(REORDER_MAP(BYTE_RESHUFFLE_VALUE))) {\r\ndload_reorder(strbuf, ssiz,\r\nHOST_BYTE_ORDER(dlthis->\r\ndfile_hdr.df_byte_reshuffle));\r\n}\r\nif ((!sec_names_only) && (~dload_reverse_checksum(strbuf, ssiz) !=\r\ndlthis->verify.dv_str_tab_checksum)) {\r\nDL_ERROR(err_checksum, stringtbl);\r\n}\r\n#endif\r\n}\r\nstatic void string_table_free(struct dload_state *dlthis)\r\n{\r\nif (dlthis->str_head)\r\ndlthis->mysym->dload_deallocate(dlthis->mysym,\r\ndlthis->str_head);\r\n}\r\nstatic void dload_symbols(struct dload_state *dlthis)\r\n{\r\nu32 sym_count, siz, dsiz, symbols_left;\r\nu32 checks;\r\nstruct local_symbol *sp;\r\nstruct dynload_symbol *symp;\r\nstruct dynload_symbol *newsym;\r\nsym_count = dlthis->dfile_hdr.df_no_syms;\r\nif (sym_count == 0)\r\nreturn;\r\nsiz = sym_count * sizeof(struct local_symbol);\r\ndsiz = DBG_HDR_SIZE +\r\n(sizeof(struct dll_sect) * dlthis->allocated_secn_count) +\r\nBYTE_TO_HOST_ROUND(dlthis->debug_string_size + 1);\r\nif (dsiz > siz)\r\nsiz = dsiz;\r\nsp = (struct local_symbol *)dlthis->mysym->dload_allocate(dlthis->mysym,\r\nsiz);\r\nif (!sp) {\r\nDL_ERROR(err_alloc, siz);\r\nreturn;\r\n}\r\ndlthis->local_symtab = sp;\r\nchecks = dlthis->verify.dv_sym_tab_checksum;\r\nsymbols_left = sym_count;\r\ndo {\r\nchar *sname;\r\nu32 val;\r\ns32 delta;\r\nstruct doff_syment_t *input_sym;\r\nunsigned syms_in_buf;\r\nstruct doff_syment_t my_sym_buf[MY_SYM_BUF_SIZ];\r\ninput_sym = my_sym_buf;\r\nsyms_in_buf = symbols_left > MY_SYM_BUF_SIZ ?\r\nMY_SYM_BUF_SIZ : symbols_left;\r\nsiz = syms_in_buf * sizeof(struct doff_syment_t);\r\nif (dlthis->strm->read_buffer(dlthis->strm, input_sym, siz) !=\r\nsiz) {\r\nDL_ERROR(readstrm, sym_errid);\r\nreturn;\r\n}\r\nif (dlthis->reorder_map)\r\ndload_reorder(input_sym, siz, dlthis->reorder_map);\r\nchecks += dload_checksum(input_sym, siz);\r\ndo {\r\nsymbols_left -= 1;\r\nsname = NULL;\r\nif (input_sym->dn_offset > 0) {\r\n#if BITS_PER_AU <= BITS_PER_BYTE\r\nif ((u32) input_sym->dn_offset <\r\ndlthis->dfile_hdr.df_strtab_size)\r\nsname = dlthis->str_head +\r\nBYTE_TO_HOST(input_sym->dn_offset);\r\nelse\r\ndload_error(dlthis,\r\n"Bad name offset in symbol "\r\n" %d", symbols_left);\r\n#else\r\nsname = unpack_name(dlthis,\r\ninput_sym->dn_offset);\r\n#endif\r\n}\r\nval = input_sym->dn_value;\r\ndelta = 0;\r\nsp->sclass = input_sym->dn_sclass;\r\nsp->secnn = input_sym->dn_scnum;\r\nif (sp->secnn == DN_UNDEF) {\r\nif (input_sym->dn_sclass != DN_EXT)\r\ngoto loop_cont;\r\nsymp = dlthis->mysym->find_matching_symbol\r\n(dlthis->mysym, sname);\r\nif (!symp) {\r\nDL_ERROR\r\n("Undefined external symbol %s",\r\nsname);\r\ngoto loop_cont;\r\n}\r\nval = delta = symp->value;\r\n#ifdef ENABLE_TRAMP_DEBUG\r\ndload_syms_error(dlthis->mysym,\r\n"===> ext sym [%s] at %x",\r\nsname, val);\r\n#endif\r\ngoto loop_cont;\r\n}\r\nif (sp->secnn > 0) {\r\nif ((unsigned)sp->secnn <=\r\ndlthis->allocated_secn_count) {\r\nstruct doff_scnhdr_t *srefp =\r\n&dlthis->sect_hdrs[sp->secnn - 1];\r\nif (input_sym->dn_sclass ==\r\nDN_STATLAB ||\r\ninput_sym->dn_sclass == DN_EXTLAB) {\r\ndelta = srefp->ds_vaddr;\r\n} else {\r\ndelta = srefp->ds_paddr;\r\n}\r\nval += delta;\r\n}\r\ngoto loop_itr;\r\n}\r\nif (sp->secnn == DN_ABS && ((sp->sclass == DN_EXT) ||\r\n(sp->sclass ==\r\nDN_EXTLAB))) {\r\nsymp =\r\ndlthis->mysym->find_matching_symbol(dlthis->\r\nmysym,\r\nsname);\r\nif (!symp)\r\ngoto loop_itr;\r\nif (symp->value == input_sym->dn_value) {\r\nsp->value = val;\r\nsp->delta = delta;\r\nsp += 1;\r\ninput_sym += 1;\r\ncontinue;\r\n} else {\r\nDL_ERROR("Absolute symbol %s is "\r\n"defined multiple times with "\r\n"different values", sname);\r\nreturn;\r\n}\r\n}\r\nloop_itr:\r\nif (input_sym->dn_sclass == DN_EXT ||\r\ninput_sym->dn_sclass == DN_EXTLAB) {\r\nif (!sname)\r\ngoto loop_cont;\r\nnewsym = dlthis->mysym->add_to_symbol_table\r\n(dlthis->mysym, sname,\r\n(unsigned)dlthis->myhandle);\r\nif (newsym)\r\nnewsym->value = val;\r\n}\r\nloop_cont:\r\nsp->value = val;\r\nsp->delta = delta;\r\nsp += 1;\r\ninput_sym += 1;\r\n} while ((syms_in_buf -= 1) > 0);\r\n} while (symbols_left > 0);\r\nif (~checks)\r\ndload_error(dlthis, "Checksum of symbols failed");\r\n}\r\nstatic void symbol_table_free(struct dload_state *dlthis)\r\n{\r\nif (dlthis->local_symtab) {\r\nif (dlthis->dload_errcount) {\r\ndlthis->mysym->purge_symbol_table(dlthis->mysym,\r\n(unsigned)\r\ndlthis->myhandle);\r\n}\r\ndlthis->mysym->dload_deallocate(dlthis->mysym,\r\ndlthis->local_symtab);\r\n}\r\n}\r\nstatic void cload_cinit(struct dload_state *dlthis,\r\nstruct image_packet_t *ipacket)\r\n{\r\n#if TDATA_TO_HOST(CINIT_COUNT)*BITS_PER_AU > 16\r\ns32 init_count, left;\r\n#else\r\ns16 init_count, left;\r\n#endif\r\nunsigned char *pktp = ipacket->img_data;\r\nunsigned char *pktend = pktp + BYTE_TO_HOST_ROUND(ipacket->packet_size);\r\nint temp;\r\nldr_addr atmp;\r\nstruct ldr_section_info cinit_info;\r\nwhile (true) {\r\nleft = pktend - pktp;\r\nswitch (dlthis->cinit_state) {\r\ncase CI_COUNT:\r\nif (left < TDATA_TO_HOST(CINIT_COUNT))\r\ngoto loopexit;\r\ntemp = dload_unpack(dlthis, (tgt_au_t *) pktp,\r\nCINIT_COUNT * TDATA_AU_BITS, 0,\r\nROP_SGN);\r\npktp += TDATA_TO_HOST(CINIT_COUNT);\r\nif (temp <= 0) {\r\ndlthis->cinit_state = CI_DONE;\r\nbreak;\r\n}\r\ndlthis->cinit_count = temp;\r\ndlthis->cinit_state = CI_ADDRESS;\r\nbreak;\r\n#if CINIT_ALIGN < CINIT_ADDRESS\r\ncase CI_PARTADDRESS:\r\npktp -= TDATA_TO_HOST(CINIT_ALIGN);\r\n*(uint16_t *) pktp = dlthis->cinit_addr;\r\n#endif\r\ncase CI_ADDRESS:\r\nif (left < TDATA_TO_HOST(CINIT_ADDRESS)) {\r\n#if CINIT_ALIGN < CINIT_ADDRESS\r\nif (left == TDATA_TO_HOST(CINIT_ALIGN)) {\r\ndlthis->cinit_addr = *(uint16_t *) pktp;\r\ndlthis->cinit_state = CI_PARTADDRESS;\r\nleft = 0;\r\n}\r\n#endif\r\ngoto loopexit;\r\n}\r\natmp = dload_unpack(dlthis, (tgt_au_t *) pktp,\r\nCINIT_ADDRESS * TDATA_AU_BITS, 0,\r\nROP_UNS);\r\npktp += TDATA_TO_HOST(CINIT_ADDRESS);\r\n#if CINIT_PAGE_BITS > 0\r\ndlthis->cinit_page = atmp &\r\n((1 << CINIT_PAGE_BITS) - 1);\r\natmp >>= CINIT_PAGE_BITS;\r\n#else\r\ndlthis->cinit_page = CINIT_DEFAULT_PAGE;\r\n#endif\r\ndlthis->cinit_addr = atmp;\r\ndlthis->cinit_state = CI_COPY;\r\nbreak;\r\ncase CI_COPY:\r\ninit_count = HOST_TO_TDATA(left);\r\nif (init_count > dlthis->cinit_count)\r\ninit_count = dlthis->cinit_count;\r\nif (init_count == 0)\r\ngoto loopexit;\r\ncinit_info = cinit_info_init;\r\ncinit_info.page = dlthis->cinit_page;\r\nif (!dlthis->myio->writemem(dlthis->myio, pktp,\r\nTDATA_TO_TADDR\r\n(dlthis->cinit_addr),\r\n&cinit_info,\r\nTDATA_TO_HOST(init_count))) {\r\ndload_error(dlthis, initfail, "write",\r\ndlthis->cinit_addr);\r\n}\r\ndlthis->cinit_count -= init_count;\r\nif (dlthis->cinit_count <= 0) {\r\ndlthis->cinit_state = CI_COUNT;\r\ninit_count = (init_count + CINIT_ALIGN - 1) &\r\n-CINIT_ALIGN;\r\n}\r\npktp += TDATA_TO_HOST(init_count);\r\ndlthis->cinit_addr += init_count;\r\nbreak;\r\ncase CI_DONE:\r\nreturn;\r\n}\r\n}\r\nloopexit:\r\nif (left > 0) {\r\ndload_error(dlthis, "%d bytes left over in cinit packet", left);\r\ndlthis->cinit_state = CI_DONE;\r\n}\r\n}\r\nstatic int relocate_packet(struct dload_state *dlthis,\r\nstruct image_packet_t *ipacket,\r\nu32 *checks, bool *tramps_generated)\r\n{\r\nu32 rnum;\r\n*tramps_generated = false;\r\nrnum = ipacket->num_relocs;\r\ndo {\r\nunsigned rinbuf;\r\nint siz;\r\nstruct reloc_record_t *rp, rrec[MY_RELOC_BUF_SIZ];\r\nrp = rrec;\r\nrinbuf = rnum > MY_RELOC_BUF_SIZ ? MY_RELOC_BUF_SIZ : rnum;\r\nsiz = rinbuf * sizeof(struct reloc_record_t);\r\nif (dlthis->strm->read_buffer(dlthis->strm, rp, siz) != siz) {\r\nDL_ERROR(readstrm, "relocation");\r\nreturn 0;\r\n}\r\nif (dlthis->reorder_map)\r\ndload_reorder(rp, siz, dlthis->reorder_map);\r\n*checks += dload_checksum(rp, siz);\r\ndo {\r\ndload_relocate(dlthis, (tgt_au_t *) ipacket->img_data,\r\nrp, tramps_generated, false);\r\nrp += 1;\r\nrnum -= 1;\r\n} while ((rinbuf -= 1) > 0);\r\n} while (rnum > 0);\r\nif (*tramps_generated == true) {\r\ndload_tramp_pkt_udpate(dlthis,\r\n(dlthis->image_secn -\r\ndlthis->ldr_sections),\r\ndlthis->image_offset, ipacket);\r\n}\r\nreturn 1;\r\n}\r\nstatic void dload_data(struct dload_state *dlthis)\r\n{\r\nu16 curr_sect;\r\nstruct doff_scnhdr_t *sptr = dlthis->sect_hdrs;\r\nstruct ldr_section_info *lptr = dlthis->ldr_sections;\r\nu8 *dest;\r\nstruct {\r\nstruct image_packet_t ipacket;\r\nu8 bufr[BYTE_TO_HOST(IMAGE_PACKET_SIZE)];\r\n} ibuf;\r\nbool cinit_processed = false;\r\nfor (curr_sect = 0; curr_sect < dlthis->dfile_hdr.df_no_scns;\r\ncurr_sect += 1) {\r\nif (ds_needs_download(sptr)) {\r\ns32 nip;\r\nldr_addr image_offset = 0;\r\nif (curr_sect < dlthis->allocated_secn_count)\r\ndlthis->delta_runaddr = sptr->ds_paddr;\r\nelse {\r\nlptr = (struct ldr_section_info *)sptr;\r\ndlthis->delta_runaddr = 0;\r\n}\r\ndlthis->image_secn = lptr;\r\n#if BITS_PER_AU > BITS_PER_BYTE\r\nlptr->name = unpack_name(dlthis, sptr->ds_offset);\r\n#endif\r\nnip = sptr->ds_nipacks;\r\nwhile ((nip -= 1) >= 0) {\r\ns32 ipsize;\r\nu32 checks;\r\nbool tramp_generated = false;\r\nif (dlthis->strm->read_buffer(dlthis->strm,\r\n&ibuf.ipacket,\r\nIPH_SIZE) !=\r\nIPH_SIZE) {\r\nDL_ERROR(readstrm, imagepak);\r\nreturn;\r\n}\r\nif (dlthis->reorder_map) {\r\ndload_reorder(&ibuf.ipacket, IPH_SIZE,\r\ndlthis->reorder_map);\r\n}\r\nipsize =\r\nBYTE_TO_HOST(DOFF_ALIGN\r\n(ibuf.ipacket.packet_size));\r\nif (ipsize > BYTE_TO_HOST(IMAGE_PACKET_SIZE)) {\r\nDL_ERROR("Bad image packet size %d",\r\nipsize);\r\nreturn;\r\n}\r\ndest = ibuf.bufr;\r\nif (dlthis->strm->read_buffer(dlthis->strm,\r\nibuf.bufr,\r\nipsize) !=\r\nipsize) {\r\nDL_ERROR(readstrm, imagepak);\r\nreturn;\r\n}\r\nibuf.ipacket.img_data = dest;\r\n#if !defined(_BIG_ENDIAN) || (TARGET_AU_BITS > 16)\r\nif (dlthis->reorder_map) {\r\ndload_reorder(dest, ipsize,\r\ndlthis->reorder_map);\r\n}\r\nchecks = dload_checksum(dest, ipsize);\r\n#else\r\nif (dlthis->dfile_hdr.df_byte_reshuffle !=\r\nTARGET_ORDER(REORDER_MAP\r\n(BYTE_RESHUFFLE_VALUE))) {\r\ndload_reorder(dest, ipsize,\r\nTARGET_ORDER\r\n(dlthis->dfile_hdr.\r\ndf_byte_reshuffle));\r\n}\r\n#if TARGET_AU_BITS > 8\r\nchecks = dload_reverse_checksum16(dest, ipsize);\r\n#else\r\nchecks = dload_reverse_checksum(dest, ipsize);\r\n#endif\r\n#endif\r\nchecks += dload_checksum(&ibuf.ipacket,\r\nIPH_SIZE);\r\nif (ibuf.ipacket.num_relocs) {\r\ndlthis->image_offset = image_offset;\r\nif (!relocate_packet(dlthis,\r\n&ibuf.ipacket,\r\n&checks,\r\n&tramp_generated))\r\nreturn;\r\n}\r\nif (~checks)\r\nDL_ERROR(err_checksum, imagepak);\r\nif (tramp_generated == false) {\r\nif (dload_check_type(sptr,\r\nDLOAD_CINIT)) {\r\ncload_cinit(dlthis,\r\n&ibuf.ipacket);\r\ncinit_processed = true;\r\n} else {\r\nif (!dlthis->myio->\r\nwritemem(dlthis->\r\nmyio,\r\nibuf.bufr,\r\nlptr->\r\nload_addr +\r\nimage_offset,\r\nlptr,\r\nBYTE_TO_HOST\r\n(ibuf.\r\nipacket.\r\npacket_size))) {\r\nDL_ERROR\r\n("Write to "\r\nFMT_UI32\r\n" failed",\r\nlptr->\r\nload_addr +\r\nimage_offset);\r\n}\r\n}\r\n}\r\nimage_offset +=\r\nBYTE_TO_TADDR(ibuf.ipacket.packet_size);\r\n}\r\nif (!dload_check_type(sptr, DLOAD_BSS))\r\ngoto loop_cont;\r\nif (!(dlthis->myoptions & DLOAD_INITBSS))\r\ngoto loop_cont;\r\nif (cinit_processed) {\r\nDL_ERROR\r\n("Zero-initialization at " FMT_UI32\r\n" after " "load-time initialization!",\r\nlptr->load_addr);\r\ngoto loop_cont;\r\n}\r\ndlthis->myio->fillmem(dlthis->myio,\r\nTADDR_TO_HOST(lptr->load_addr),\r\nlptr, TADDR_TO_HOST(lptr->size),\r\nDLOAD_FILL_BSS);\r\ngoto loop_cont;\r\n}\r\nif (!dload_check_type(sptr, DLOAD_BSS))\r\ngoto loop_cont;\r\nif (!(dlthis->myoptions & DLOAD_INITBSS))\r\ngoto loop_cont;\r\nif (curr_sect >= dlthis->allocated_secn_count)\r\nlptr = (struct ldr_section_info *)sptr;\r\nif (cinit_processed) {\r\nDL_ERROR("Zero-initialization at " FMT_UI32\r\n" attempted after "\r\n"load-time initialization!", lptr->load_addr);\r\ngoto loop_cont;\r\n}\r\ndlthis->myio->fillmem(dlthis->myio,\r\nTADDR_TO_HOST(lptr->load_addr), lptr,\r\nTADDR_TO_HOST(lptr->size),\r\nDLOAD_FILL_BSS);\r\nloop_cont:\r\nsptr += 1;\r\nlptr += 1;\r\n}\r\nif (dload_tramp_finalize(dlthis) == 0) {\r\nDL_ERROR("Finalization of auto-trampolines (size = " FMT_UI32\r\n") failed", dlthis->tramp.tramp_sect_next_addr);\r\n}\r\n}\r\nvoid dload_reorder(void *data, int dsiz, unsigned int map)\r\n{\r\nregister u32 tmp, tmap, datv;\r\nu32 *dp = (u32 *) data;\r\nmap <<= LOG_BITS_PER_BYTE;\r\ndo {\r\ntmp = 0;\r\ndatv = *dp;\r\ntmap = map;\r\ndo {\r\ntmp |= (datv & BYTE_MASK) << (tmap & SHIFT_COUNT_MASK);\r\ntmap >>= BITS_PER_BYTE;\r\n} while (datv >>= BITS_PER_BYTE);\r\n*dp++ = tmp;\r\n} while ((dsiz -= sizeof(u32)) > 0);\r\n}\r\nu32 dload_checksum(void *data, unsigned siz)\r\n{\r\nu32 sum;\r\nu32 *dp;\r\nint left;\r\nsum = 0;\r\ndp = (u32 *) data;\r\nfor (left = siz; left > 0; left -= sizeof(u32))\r\nsum += *dp++;\r\nreturn sum;\r\n}\r\nu32 dload_reverse_checksum(void *data, unsigned siz)\r\n{\r\nu32 sum, temp;\r\nu32 *dp;\r\nint left;\r\nsum = 0;\r\ndp = (u32 *) data;\r\nfor (left = siz; left > 0; left -= sizeof(u32)) {\r\ntemp = *dp++;\r\nsum += temp << BITS_PER_BYTE * 3;\r\nsum += temp >> BITS_PER_BYTE * 3;\r\nsum += (temp >> BITS_PER_BYTE) & (BYTE_MASK << BITS_PER_BYTE);\r\nsum += (temp & (BYTE_MASK << BITS_PER_BYTE)) << BITS_PER_BYTE;\r\n}\r\nreturn sum;\r\n}\r\nu32 dload_reverse_checksum16(void *data, unsigned siz)\r\n{\r\nuint_fast32_t sum, temp;\r\nu32 *dp;\r\nint left;\r\nsum = 0;\r\ndp = (u32 *) data;\r\nfor (left = siz; left > 0; left -= sizeof(u32)) {\r\ntemp = *dp++;\r\nsum += temp << BITS_PER_BYTE * 2;\r\nsum += temp >> BITS_PER_BYTE * 2;\r\n}\r\nreturn sum;\r\n}\r\nstatic void swap_words(void *data, unsigned siz, unsigned bitmap)\r\n{\r\nregister int i;\r\n#if TARGET_AU_BITS < 16\r\nregister u16 *sp;\r\n#endif\r\nregister u32 *lp;\r\nsiz /= sizeof(u16);\r\n#if TARGET_AU_BITS < 16\r\ni = siz;\r\nsp = (u16 *) data;\r\ndo {\r\nregister u16 tmp;\r\ntmp = *sp;\r\n*sp++ = SWAP16BY8(tmp);\r\n} while ((i -= 1) > 0);\r\n#endif\r\n#if TARGET_AU_BITS < 32\r\ni = siz >> 1;\r\nlp = (u32 *) data;\r\ndo {\r\nif ((bitmap & 1) == 0) {\r\nregister u32 tmp;\r\ntmp = *lp;\r\n*lp = SWAP32BY16(tmp);\r\n}\r\nlp += 1;\r\nbitmap >>= 1;\r\n} while ((i -= 1) > 0);\r\n#endif\r\n}\r\nstatic char *copy_tgt_strings(void *dstp, void *srcp, unsigned charcount)\r\n{\r\nregister tgt_au_t *src = (tgt_au_t *) srcp;\r\nregister tgt_au_t *dst = (tgt_au_t *) dstp;\r\nregister int cnt = charcount;\r\ndo {\r\n#if TARGET_AU_BITS <= BITS_PER_AU\r\n*dst++ = *src++;\r\n#else\r\n*dst++ = *src++;\r\n#endif\r\n} while ((cnt -= (sizeof(tgt_au_t) * BITS_PER_AU / BITS_PER_BYTE)) > 0);\r\n#if (BITS_PER_AU == BITS_PER_BYTE) && (TARGET_AU_BITS == BITS_PER_BYTE)\r\ndst[-1] = 0;\r\n#else\r\ndst[-1] &= (1 << (BITS_PER_AU - BITS_PER_BYTE)) - 1;\r\n#endif\r\nreturn (char *)dst;\r\n}\r\nstatic void init_module_handle(struct dload_state *dlthis)\r\n{\r\nstruct my_handle *hndl;\r\nu16 curr_sect;\r\nstruct ldr_section_info *asecs;\r\nstruct dll_module *dbmod;\r\nstruct dll_sect *dbsec;\r\nstruct dbg_mirror_root *mlist;\r\nregister char *cp;\r\nstruct modules_header mhdr;\r\nstruct ldr_section_info dllview_info;\r\nstruct dynload_symbol *debug_mirror_sym;\r\nhndl = dlthis->myhandle;\r\nif (!hndl)\r\nreturn;\r\nhndl->secn_count = dlthis->allocated_secn_count;\r\nif (dlthis->tramp.tramp_sect_next_addr != 0)\r\nhndl->secn_count += 1;\r\nhndl->secn_count = hndl->secn_count << 1;\r\nhndl->secn_count = dlthis->allocated_secn_count << 1;\r\n#ifndef TARGET_ENDIANNESS\r\nif (dlthis->big_e_target)\r\nhndl->secn_count += 1;\r\n#endif\r\nif (dlthis->dload_errcount)\r\nreturn;\r\ndebug_mirror_sym = dlthis->mysym->find_matching_symbol(dlthis->mysym,\r\nloader_dllview_root);\r\nif (!debug_mirror_sym) {\r\nstruct dynload_symbol *dlmodsym;\r\nstruct dbg_mirror_root *mlst;\r\ndlmodsym = dlthis->mysym->find_matching_symbol(dlthis->mysym,\r\nLINKER_MODULES_HEADER);\r\nif (!dlmodsym)\r\nreturn;\r\nmlst = (struct dbg_mirror_root *)\r\ndlthis->mysym->dload_allocate(dlthis->mysym,\r\nsizeof(struct\r\ndbg_mirror_root));\r\nif (!mlst) {\r\nDL_ERROR(err_alloc, sizeof(struct dbg_mirror_root));\r\nreturn;\r\n}\r\nmlst->next = NULL;\r\nmlst->changes = 0;\r\nmlst->refcount = 0;\r\nmlst->dbthis = TDATA_TO_TADDR(dlmodsym->value);\r\ndebug_mirror_sym = dlthis->mysym->add_to_symbol_table\r\n(dlthis->mysym, loader_dllview_root,\r\n(unsigned)dlthis->myhandle);\r\nif (!debug_mirror_sym) {\r\ndlthis->mysym->dload_deallocate(dlthis->mysym, mlst);\r\nreturn;\r\n}\r\ndebug_mirror_sym->value = (u32) mlst;\r\n}\r\n#ifndef DEBUG_HEADER_IN_LOADER\r\nmlist = (struct dbg_mirror_root *)debug_mirror_sym->value;\r\nif (!mlist)\r\nreturn;\r\n#else\r\nmlist = (struct dbg_mirror_root *)&debug_list_header;\r\n#endif\r\nhndl->dm.root = mlist;\r\nif (!dlthis->allocated_secn_count)\r\nreturn;\r\ndbmod = (struct dll_module *)dlthis->local_symtab;\r\ndbmod->num_sects = dlthis->allocated_secn_count;\r\ndbmod->timestamp = dlthis->verify.dv_timdat;\r\ndbmod->version = INIT_VERSION;\r\ndbmod->verification = VERIFICATION;\r\nasecs = dlthis->ldr_sections;\r\ndbsec = dbmod->sects;\r\nfor (curr_sect = dlthis->allocated_secn_count;\r\ncurr_sect > 0; curr_sect -= 1) {\r\ndbsec->sect_load_adr = asecs->load_addr;\r\ndbsec->sect_run_adr = asecs->run_addr;\r\ndbsec += 1;\r\nasecs += 1;\r\n}\r\nif (dlthis->tramp.tramp_sect_next_addr != 0) {\r\ndbmod->num_sects++;\r\ndbsec->sect_load_adr = asecs->load_addr;\r\ndbsec->sect_run_adr = asecs->run_addr;\r\ndbsec++;\r\nasecs++;\r\n}\r\ncp = copy_tgt_strings(dbsec, dlthis->str_head,\r\ndlthis->debug_string_size);\r\nif (dlthis->tramp.tramp_sect_next_addr != 0) {\r\ncp = copy_tgt_strings(cp,\r\ndlthis->tramp.final_string_table,\r\nstrlen(dlthis->tramp.final_string_table) +\r\n1);\r\n}\r\nhndl->dm.dbsiz = HOST_TO_TDATA_ROUND(cp - (char *)dbmod);\r\n*cp = 0;\r\ndllview_info = dllview_info_init;\r\ndllview_info.size = TDATA_TO_TADDR(hndl->dm.dbsiz);\r\ndllview_info.context = 0;\r\nhndl->dm.context = 0;\r\nif (mlist->next) {\r\ndbmod->next_module = TADDR_TO_TDATA(mlist->next->dm.dbthis);\r\ndbmod->next_module_size = mlist->next->dm.dbsiz;\r\n} else {\r\ndbmod->next_module_size = 0;\r\ndbmod->next_module = 0;\r\n}\r\nif (!dlthis->myalloc)\r\nreturn;\r\nif (!dlthis->myalloc->dload_allocate(dlthis->myalloc, &dllview_info,\r\nHOST_TO_TADDR(sizeof(u32)))) {\r\nreturn;\r\n}\r\nhndl->dm.dbthis = dllview_info.load_addr;\r\nhndl->dm.context = dllview_info.context;\r\nmlist->refcount += 1;\r\nif (TARGET_ENDIANNESS_DIFFERS(TARGET_BIG_ENDIAN)) {\r\nswap_words(dbmod, (char *)dbsec - (char *)dbmod,\r\nDLL_MODULE_BITMAP);\r\n}\r\nif (!dlthis->myio->writemem(dlthis->myio, dbmod,\r\ndllview_info.load_addr, &dllview_info,\r\nTADDR_TO_HOST(dllview_info.size))) {\r\nreturn;\r\n}\r\nmhdr.first_module_size = hndl->dm.dbsiz;\r\nmhdr.first_module = TADDR_TO_TDATA(dllview_info.load_addr);\r\nif (TARGET_ENDIANNESS_DIFFERS(TARGET_BIG_ENDIAN)) {\r\nswap_words(&mhdr, sizeof(struct modules_header) - sizeof(u16),\r\nMODULES_HEADER_BITMAP);\r\n}\r\ndllview_info = dllview_info_init;\r\nif (!dlthis->myio->writemem(dlthis->myio, &mhdr, mlist->dbthis,\r\n&dllview_info,\r\nsizeof(struct modules_header) -\r\nsizeof(u16))) {\r\nreturn;\r\n}\r\nhndl->dm.next = mlist->next;\r\nif (hndl->dm.next)\r\nhndl->dm.next->dm.prev = hndl;\r\nhndl->dm.prev = (struct my_handle *)mlist;\r\nmlist->next = hndl;\r\n}\r\nint dynamic_unload_module(void *mhandle,\r\nstruct dynamic_loader_sym *syms,\r\nstruct dynamic_loader_allocate *alloc,\r\nstruct dynamic_loader_initialize *init)\r\n{\r\ns16 curr_sect;\r\nstruct ldr_section_info *asecs;\r\nstruct my_handle *hndl;\r\nstruct dbg_mirror_root *root;\r\nunsigned errcount = 0;\r\nstruct ldr_section_info dllview_info = dllview_info_init;\r\nstruct modules_header mhdr;\r\nhndl = (struct my_handle *)mhandle;\r\nif (!hndl)\r\nreturn 0;\r\nif (!syms)\r\nreturn 1;\r\nsyms->purge_symbol_table(syms, (unsigned)hndl);\r\nasecs = hndl->secns;\r\nif (alloc)\r\nfor (curr_sect = (hndl->secn_count >> 1); curr_sect > 0;\r\ncurr_sect -= 1) {\r\nasecs->name = NULL;\r\nalloc->dload_deallocate(alloc, asecs++);\r\n}\r\nroot = hndl->dm.root;\r\nif (!root) {\r\ngoto func_end;\r\n}\r\nif (!hndl->dm.dbthis) {\r\ngoto loop_end;\r\n}\r\ndllview_info.context = hndl->dm.context;\r\nif (hndl->dm.prev == hndl)\r\ngoto exitunltgt;\r\nhndl->dm.prev->dm.next = hndl->dm.next;\r\nif (hndl->dm.next)\r\nhndl->dm.next->dm.prev = hndl->dm.prev;\r\nif (hndl->dm.next) {\r\nmhdr.first_module = TADDR_TO_TDATA(hndl->dm.next->dm.dbthis);\r\nmhdr.first_module_size = hndl->dm.next->dm.dbsiz;\r\n} else {\r\nmhdr.first_module = 0;\r\nmhdr.first_module_size = 0;\r\n}\r\nif (!init)\r\ngoto exitunltgt;\r\nif (!init->connect(init)) {\r\ndload_syms_error(syms, iconnect);\r\nerrcount += 1;\r\ngoto exitunltgt;\r\n}\r\nif (TARGET_ENDIANNESS_DIFFERS(hndl->secn_count & 0x1)) {\r\nswap_words(&mhdr, sizeof(struct modules_header) - sizeof(u16),\r\nMODULES_HEADER_BITMAP);\r\n}\r\nif (!init->writemem(init, &mhdr, hndl->dm.prev->dm.dbthis,\r\n&dllview_info, sizeof(struct modules_header) -\r\nsizeof(mhdr.update_flag))) {\r\ndload_syms_error(syms, dlvwrite);\r\nerrcount += 1;\r\n}\r\nroot->changes += 1;\r\nif (!init->writemem(init, &(root->changes),\r\nroot->dbthis + HOST_TO_TADDR\r\n(sizeof(mhdr.first_module) +\r\nsizeof(mhdr.first_module_size)),\r\n&dllview_info, sizeof(mhdr.update_flag))) {\r\ndload_syms_error(syms, dlvwrite);\r\nerrcount += 1;\r\n}\r\ninit->release(init);\r\nexitunltgt:\r\ndllview_info.size = TDATA_TO_TADDR(hndl->dm.dbsiz);\r\ndllview_info.load_addr = hndl->dm.dbthis;\r\nif (alloc)\r\nalloc->dload_deallocate(alloc, &dllview_info);\r\nroot->refcount -= 1;\r\nloop_end:\r\n#ifndef DEBUG_HEADER_IN_LOADER\r\nif (root->refcount <= 0) {\r\nif (syms->find_matching_symbol\r\n(syms, loader_dllview_root) == NULL)\r\nsyms->dload_deallocate(syms, root);\r\n}\r\n#endif\r\nfunc_end:\r\nsyms->dload_deallocate(syms, mhandle);\r\nreturn errcount;\r\n}\r\nstatic char *unpack_name(struct dload_state *dlthis, u32 soffset)\r\n{\r\nu8 tmp, *src;\r\nchar *dst;\r\nif (soffset >= dlthis->dfile_hdr.df_strtab_size) {\r\ndload_error(dlthis, "Bad string table offset " FMT_UI32,\r\nsoffset);\r\nreturn NULL;\r\n}\r\nsrc = (uint_least8_t *) dlthis->str_head +\r\n(soffset >> (LOG_BITS_PER_AU - LOG_BITS_PER_BYTE));\r\ndst = dlthis->str_temp;\r\nif (soffset & 1)\r\n*dst++ = *src++;\r\ndo {\r\ntmp = *src++;\r\n*dst = (tmp >> BITS_PER_BYTE);\r\nif (!(*dst++))\r\nbreak;\r\n} while ((*dst++ = tmp & BYTE_MASK));\r\ndlthis->temp_len = dst - dlthis->str_temp;\r\nreturn dlthis->str_temp;\r\n}
