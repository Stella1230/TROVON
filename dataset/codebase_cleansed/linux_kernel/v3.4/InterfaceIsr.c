static void read_int_callback(struct urb *urb)\r\n{\r\nint status = urb->status;\r\nPS_INTERFACE_ADAPTER psIntfAdapter = (PS_INTERFACE_ADAPTER)urb->context;\r\nPMINI_ADAPTER Adapter = psIntfAdapter->psAdapter ;\r\nif (netif_msg_intr(Adapter))\r\npr_info(PFX "%s: interrupt status %d\n",\r\nAdapter->dev->name, status);\r\nif(Adapter->device_removed == TRUE)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, INTF_INIT, DBG_LVL_ALL,"Device has Got Removed.");\r\nreturn ;\r\n}\r\nif(((Adapter->bPreparingForLowPowerMode == TRUE) && (Adapter->bDoSuspend == TRUE)) ||\r\npsIntfAdapter->bSuspended ||\r\npsIntfAdapter->bPreparingForBusSuspend)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, INTF_INIT, DBG_LVL_ALL,"Interrupt call back is called while suspending the device");\r\nreturn ;\r\n}\r\nswitch (status) {\r\ncase STATUS_SUCCESS:\r\nif ( urb->actual_length )\r\n{\r\nif(psIntfAdapter->ulInterruptData[1] & 0xFF)\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, INTF_INIT, DBG_LVL_ALL, "Got USIM interrupt");\r\n}\r\nif(psIntfAdapter->ulInterruptData[1] & 0xFF00)\r\n{\r\natomic_set(&Adapter->CurrNumFreeTxDesc,\r\n(psIntfAdapter->ulInterruptData[1] & 0xFF00) >> 8);\r\natomic_set (&Adapter->uiMBupdate, TRUE);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, INTF_INIT, DBG_LVL_ALL, "TX mailbox contains %d",\r\natomic_read(&Adapter->CurrNumFreeTxDesc));\r\n}\r\nif(psIntfAdapter->ulInterruptData[1] >> 16)\r\n{\r\nAdapter->CurrNumRecvDescs=\r\n(psIntfAdapter->ulInterruptData[1] >> 16);\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, INTF_INIT, DBG_LVL_ALL,"RX mailbox contains %d",\r\nAdapter->CurrNumRecvDescs);\r\nInterfaceRx(psIntfAdapter);\r\n}\r\nif(Adapter->fw_download_done &&\r\n!Adapter->downloadDDR &&\r\natomic_read(&Adapter->CurrNumFreeTxDesc))\r\n{\r\npsIntfAdapter->psAdapter->downloadDDR +=1;\r\nwake_up(&Adapter->tx_packet_wait_queue);\r\n}\r\nif(FALSE == Adapter->waiting_to_fw_download_done)\r\n{\r\nAdapter->waiting_to_fw_download_done = TRUE;\r\nwake_up(&Adapter->ioctl_fw_dnld_wait_queue);\r\n}\r\nif(!atomic_read(&Adapter->TxPktAvail))\r\n{\r\natomic_set(&Adapter->TxPktAvail, 1);\r\nwake_up(&Adapter->tx_packet_wait_queue);\r\n}\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, INTF_INIT, DBG_LVL_ALL,"Firing interrupt in URB");\r\n}\r\nbreak;\r\ncase -ENOENT :\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, INTF_INIT, DBG_LVL_ALL,"URB has got disconnected ....");\r\nreturn ;\r\n}\r\ncase -EINPROGRESS:\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, INTF_INIT, DBG_LVL_ALL,"Impossibe condition has occurred... something very bad is going on");\r\nbreak ;\r\n}\r\ncase -EPIPE:\r\n{\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, INTF_INIT, DBG_LVL_ALL,"Interrupt IN endPoint has got halted/stalled...need to clear this");\r\nAdapter->bEndPointHalted = TRUE ;\r\nwake_up(&Adapter->tx_packet_wait_queue);\r\nurb->status = STATUS_SUCCESS ;\r\nreturn;\r\n}\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\ncase -ENODEV :\r\ncase -EINVAL :\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_OTHERS, INTF_INIT, DBG_LVL_ALL,"interrupt urb error %d", status);\r\nurb->status = STATUS_SUCCESS ;\r\nbreak ;\r\ndefault:\r\nBCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, NEXT_SEND, DBG_LVL_ALL,"GOT DEFAULT INTERRUPT URB STATUS :%d..Please Analyze it...", status);\r\nbreak;\r\n}\r\nStartInterruptUrb(psIntfAdapter);\r\n}\r\nint CreateInterruptUrb(PS_INTERFACE_ADAPTER psIntfAdapter)\r\n{\r\npsIntfAdapter->psInterruptUrb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!psIntfAdapter->psInterruptUrb)\r\n{\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_OTHERS, INTF_INIT, DBG_LVL_ALL,"Cannot allocate interrupt urb");\r\nreturn -ENOMEM;\r\n}\r\npsIntfAdapter->psInterruptUrb->transfer_buffer =\r\npsIntfAdapter->ulInterruptData;\r\npsIntfAdapter->psInterruptUrb->transfer_buffer_length =\r\nsizeof(psIntfAdapter->ulInterruptData);\r\npsIntfAdapter->sIntrIn.int_in_pipe = usb_rcvintpipe(psIntfAdapter->udev,\r\npsIntfAdapter->sIntrIn.int_in_endpointAddr);\r\nusb_fill_int_urb(psIntfAdapter->psInterruptUrb, psIntfAdapter->udev,\r\npsIntfAdapter->sIntrIn.int_in_pipe,\r\npsIntfAdapter->psInterruptUrb->transfer_buffer,\r\npsIntfAdapter->psInterruptUrb->transfer_buffer_length,\r\nread_int_callback, psIntfAdapter,\r\npsIntfAdapter->sIntrIn.int_in_interval);\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_OTHERS, INTF_INIT, DBG_LVL_ALL,"Interrupt Interval: %d\n",\r\npsIntfAdapter->sIntrIn.int_in_interval);\r\nreturn 0;\r\n}\r\nINT StartInterruptUrb(PS_INTERFACE_ADAPTER psIntfAdapter)\r\n{\r\nINT status = 0;\r\nif( FALSE == psIntfAdapter->psAdapter->device_removed &&\r\nFALSE == psIntfAdapter->psAdapter->bEndPointHalted &&\r\nFALSE == psIntfAdapter->bSuspended &&\r\nFALSE == psIntfAdapter->bPreparingForBusSuspend &&\r\nFALSE == psIntfAdapter->psAdapter->StopAllXaction)\r\n{\r\nstatus = usb_submit_urb(psIntfAdapter->psInterruptUrb, GFP_ATOMIC);\r\nif (status)\r\n{\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,DBG_TYPE_OTHERS, INTF_INIT, DBG_LVL_ALL,"Cannot send int urb %d\n", status);\r\nif(status == -EPIPE)\r\n{\r\npsIntfAdapter->psAdapter->bEndPointHalted = TRUE ;\r\nwake_up(&psIntfAdapter->psAdapter->tx_packet_wait_queue);\r\n}\r\n}\r\n}\r\nreturn status;\r\n}
