void iforce_dump_packet(char *msg, u16 cmd, unsigned char *data)\r\n{\r\nint i;\r\nprintk(KERN_DEBUG __FILE__ ": %s cmd = %04x, data = ", msg, cmd);\r\nfor (i = 0; i < LO(cmd); i++)\r\nprintk("%02x ", data[i]);\r\nprintk("\n");\r\n}\r\nint iforce_send_packet(struct iforce *iforce, u16 cmd, unsigned char* data)\r\n{\r\nint n = LO(cmd);\r\nint c;\r\nint empty;\r\nint head, tail;\r\nunsigned long flags;\r\nspin_lock_irqsave(&iforce->xmit_lock, flags);\r\nhead = iforce->xmit.head;\r\ntail = iforce->xmit.tail;\r\nif (CIRC_SPACE(head, tail, XMIT_SIZE) < n+2) {\r\ndev_warn(&iforce->dev->dev,\r\n"not enough space in xmit buffer to send new packet\n");\r\nspin_unlock_irqrestore(&iforce->xmit_lock, flags);\r\nreturn -1;\r\n}\r\nempty = head == tail;\r\nXMIT_INC(iforce->xmit.head, n+2);\r\niforce->xmit.buf[head] = HI(cmd);\r\nXMIT_INC(head, 1);\r\niforce->xmit.buf[head] = LO(cmd);\r\nXMIT_INC(head, 1);\r\nc = CIRC_SPACE_TO_END(head, tail, XMIT_SIZE);\r\nif (n < c) c=n;\r\nmemcpy(&iforce->xmit.buf[head],\r\ndata,\r\nc);\r\nif (n != c) {\r\nmemcpy(&iforce->xmit.buf[0],\r\ndata + c,\r\nn - c);\r\n}\r\nXMIT_INC(head, n);\r\nspin_unlock_irqrestore(&iforce->xmit_lock, flags);\r\nswitch (iforce->bus) {\r\n#ifdef CONFIG_JOYSTICK_IFORCE_232\r\ncase IFORCE_232:\r\nif (empty)\r\niforce_serial_xmit(iforce);\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_JOYSTICK_IFORCE_USB\r\ncase IFORCE_USB:\r\nif (iforce->usbdev && empty &&\r\n!test_and_set_bit(IFORCE_XMIT_RUNNING, iforce->xmit_flags)) {\r\niforce_usb_xmit(iforce);\r\n}\r\nbreak;\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nint iforce_control_playback(struct iforce* iforce, u16 id, unsigned int value)\r\n{\r\nunsigned char data[3];\r\ndata[0] = LO(id);\r\ndata[1] = (value > 0) ? ((value > 1) ? 0x41 : 0x01) : 0;\r\ndata[2] = LO(value);\r\nreturn iforce_send_packet(iforce, FF_CMD_PLAY, data);\r\n}\r\nstatic int mark_core_as_ready(struct iforce *iforce, unsigned short addr)\r\n{\r\nint i;\r\nif (!iforce->dev->ff)\r\nreturn 0;\r\nfor (i = 0; i < iforce->dev->ff->max_effects; ++i) {\r\nif (test_bit(FF_CORE_IS_USED, iforce->core_effects[i].flags) &&\r\n(iforce->core_effects[i].mod1_chunk.start == addr ||\r\niforce->core_effects[i].mod2_chunk.start == addr)) {\r\nclear_bit(FF_CORE_UPDATE, iforce->core_effects[i].flags);\r\nreturn 0;\r\n}\r\n}\r\ndev_warn(&iforce->dev->dev, "unused effect %04x updated !!!\n", addr);\r\nreturn -1;\r\n}\r\nvoid iforce_process_packet(struct iforce *iforce, u16 cmd, unsigned char *data)\r\n{\r\nstruct input_dev *dev = iforce->dev;\r\nint i;\r\nstatic int being_used = 0;\r\nif (being_used)\r\ndev_warn(&iforce->dev->dev,\r\n"re-entrant call to iforce_process %d\n", being_used);\r\nbeing_used++;\r\n#ifdef CONFIG_JOYSTICK_IFORCE_232\r\nif (HI(iforce->expect_packet) == HI(cmd)) {\r\niforce->expect_packet = 0;\r\niforce->ecmd = cmd;\r\nmemcpy(iforce->edata, data, IFORCE_MAX_LENGTH);\r\n}\r\n#endif\r\nwake_up(&iforce->wait);\r\nif (!iforce->type) {\r\nbeing_used--;\r\nreturn;\r\n}\r\nswitch (HI(cmd)) {\r\ncase 0x01:\r\ncase 0x03:\r\nif (HI(cmd) == 1) {\r\ninput_report_abs(dev, ABS_X, (__s16) (((__s16)data[1] << 8) | data[0]));\r\ninput_report_abs(dev, ABS_Y, (__s16) (((__s16)data[3] << 8) | data[2]));\r\ninput_report_abs(dev, ABS_THROTTLE, 255 - data[4]);\r\nif (LO(cmd) >= 8 && test_bit(ABS_RUDDER ,dev->absbit))\r\ninput_report_abs(dev, ABS_RUDDER, (__s8)data[7]);\r\n} else {\r\ninput_report_abs(dev, ABS_WHEEL, (__s16) (((__s16)data[1] << 8) | data[0]));\r\ninput_report_abs(dev, ABS_GAS, 255 - data[2]);\r\ninput_report_abs(dev, ABS_BRAKE, 255 - data[3]);\r\n}\r\ninput_report_abs(dev, ABS_HAT0X, iforce_hat_to_axis[data[6] >> 4].x);\r\ninput_report_abs(dev, ABS_HAT0Y, iforce_hat_to_axis[data[6] >> 4].y);\r\nfor (i = 0; iforce->type->btn[i] >= 0; i++)\r\ninput_report_key(dev, iforce->type->btn[i], data[(i >> 3) + 5] & (1 << (i & 7)));\r\nif (i <= 8) {\r\nint btns = data[6];\r\nif (test_bit(ABS_HAT1X, dev->absbit)) {\r\nif (btns & 8) input_report_abs(dev, ABS_HAT1X, -1);\r\nelse if (btns & 2) input_report_abs(dev, ABS_HAT1X, 1);\r\nelse input_report_abs(dev, ABS_HAT1X, 0);\r\n}\r\nif (test_bit(ABS_HAT1Y, dev->absbit)) {\r\nif (btns & 1) input_report_abs(dev, ABS_HAT1Y, -1);\r\nelse if (btns & 4) input_report_abs(dev, ABS_HAT1Y, 1);\r\nelse input_report_abs(dev, ABS_HAT1Y, 0);\r\n}\r\n}\r\ninput_sync(dev);\r\nbreak;\r\ncase 0x02:\r\ninput_report_key(dev, BTN_DEAD, data[0] & 0x02);\r\ninput_sync(dev);\r\ni = data[1] & 0x7f;\r\nif (data[1] & 0x80) {\r\nif (!test_and_set_bit(FF_CORE_IS_PLAYED, iforce->core_effects[i].flags)) {\r\ninput_report_ff_status(dev, i, FF_STATUS_PLAYING);\r\n}\r\n} else if (test_and_clear_bit(FF_CORE_IS_PLAYED, iforce->core_effects[i].flags)) {\r\ninput_report_ff_status(dev, i, FF_STATUS_STOPPED);\r\n}\r\nif (LO(cmd) > 3) {\r\nint j;\r\nfor (j = 3; j < LO(cmd); j += 2)\r\nmark_core_as_ready(iforce, data[j] | (data[j+1]<<8));\r\n}\r\nbreak;\r\n}\r\nbeing_used--;\r\n}\r\nint iforce_get_id_packet(struct iforce *iforce, char *packet)\r\n{\r\nswitch (iforce->bus) {\r\ncase IFORCE_USB: {\r\n#ifdef CONFIG_JOYSTICK_IFORCE_USB\r\nint status;\r\niforce->cr.bRequest = packet[0];\r\niforce->ctrl->dev = iforce->usbdev;\r\nstatus = usb_submit_urb(iforce->ctrl, GFP_ATOMIC);\r\nif (status) {\r\nerr("usb_submit_urb failed %d", status);\r\nreturn -1;\r\n}\r\nwait_event_interruptible_timeout(iforce->wait,\r\niforce->ctrl->status != -EINPROGRESS, HZ);\r\nif (iforce->ctrl->status) {\r\ndbg("iforce->ctrl->status = %d", iforce->ctrl->status);\r\nusb_unlink_urb(iforce->ctrl);\r\nreturn -1;\r\n}\r\n#else\r\ndbg("iforce_get_id_packet: iforce->bus = USB!");\r\n#endif\r\n}\r\nbreak;\r\ncase IFORCE_232:\r\n#ifdef CONFIG_JOYSTICK_IFORCE_232\r\niforce->expect_packet = FF_CMD_QUERY;\r\niforce_send_packet(iforce, FF_CMD_QUERY, packet);\r\nwait_event_interruptible_timeout(iforce->wait,\r\n!iforce->expect_packet, HZ);\r\nif (iforce->expect_packet) {\r\niforce->expect_packet = 0;\r\nreturn -1;\r\n}\r\n#else\r\nerr("iforce_get_id_packet: iforce->bus = SERIO!");\r\n#endif\r\nbreak;\r\ndefault:\r\nerr("iforce_get_id_packet: iforce->bus = %d", iforce->bus);\r\nbreak;\r\n}\r\nreturn -(iforce->edata[0] != packet[0]);\r\n}
