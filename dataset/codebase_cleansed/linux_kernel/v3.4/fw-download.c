static int iwmct_fw_parser_init(struct iwmct_priv *priv, const u8 *file,\r\nsize_t file_size, size_t block_size)\r\n{\r\nstruct iwmct_parser *parser = &priv->parser;\r\nstruct iwmct_fw_hdr *fw_hdr = &parser->versions;\r\nLOG_TRACE(priv, FW_DOWNLOAD, "-->\n");\r\nLOG_INFO(priv, FW_DOWNLOAD, "file_size=%zd\n", file_size);\r\nparser->file = file;\r\nparser->file_size = file_size;\r\nparser->cur_pos = 0;\r\nparser->entry_point = 0;\r\nparser->buf = kzalloc(block_size, GFP_KERNEL);\r\nif (!parser->buf) {\r\nLOG_ERROR(priv, FW_DOWNLOAD, "kzalloc error\n");\r\nreturn -ENOMEM;\r\n}\r\nparser->buf_size = block_size;\r\nmemcpy(fw_hdr, parser->file, sizeof(struct iwmct_fw_hdr));\r\nLOG_INFO(priv, FW_DOWNLOAD, "fw versions are:\n"\r\n"top %u.%u.%u gps %u.%u.%u bt %u.%u.%u tic %s\n",\r\nfw_hdr->top_major, fw_hdr->top_minor, fw_hdr->top_revision,\r\nfw_hdr->gps_major, fw_hdr->gps_minor, fw_hdr->gps_revision,\r\nfw_hdr->bt_major, fw_hdr->bt_minor, fw_hdr->bt_revision,\r\nfw_hdr->tic_name);\r\nparser->cur_pos += sizeof(struct iwmct_fw_hdr);\r\nLOG_TRACE(priv, FW_DOWNLOAD, "<--\n");\r\nreturn 0;\r\n}\r\nstatic bool iwmct_checksum(struct iwmct_priv *priv)\r\n{\r\nstruct iwmct_parser *parser = &priv->parser;\r\n__le32 *file = (__le32 *)parser->file;\r\nint i, pad, steps;\r\nu32 accum = 0;\r\nu32 checksum;\r\nu32 mask = 0xffffffff;\r\npad = (parser->file_size - CHECKSUM_BYTES_NUM) % 4;\r\nsteps = (parser->file_size - CHECKSUM_BYTES_NUM) / 4;\r\nLOG_INFO(priv, FW_DOWNLOAD, "pad=%d steps=%d\n", pad, steps);\r\nfor (i = 0; i < steps; i++)\r\naccum += le32_to_cpu(file[i]);\r\nif (pad) {\r\nmask <<= 8 * (4 - pad);\r\naccum += le32_to_cpu(file[steps]) & mask;\r\n}\r\nchecksum = get_unaligned_le32((__le32 *)(parser->file +\r\nparser->file_size - CHECKSUM_BYTES_NUM));\r\nLOG_INFO(priv, FW_DOWNLOAD,\r\n"compare checksum accum=0x%x to checksum=0x%x\n",\r\naccum, checksum);\r\nreturn checksum == accum;\r\n}\r\nstatic int iwmct_parse_next_section(struct iwmct_priv *priv, const u8 **p_sec,\r\nsize_t *sec_size, __le32 *sec_addr)\r\n{\r\nstruct iwmct_parser *parser = &priv->parser;\r\nstruct iwmct_dbg *dbg = &priv->dbg;\r\nstruct iwmct_fw_sec_hdr *sec_hdr;\r\nLOG_TRACE(priv, FW_DOWNLOAD, "-->\n");\r\nwhile (parser->cur_pos + sizeof(struct iwmct_fw_sec_hdr)\r\n<= parser->file_size) {\r\nsec_hdr = (struct iwmct_fw_sec_hdr *)\r\n(parser->file + parser->cur_pos);\r\nparser->cur_pos += sizeof(struct iwmct_fw_sec_hdr);\r\nLOG_INFO(priv, FW_DOWNLOAD,\r\n"sec hdr: type=%s addr=0x%x size=%d\n",\r\nsec_hdr->type, sec_hdr->target_addr,\r\nsec_hdr->data_size);\r\nif (strcmp(sec_hdr->type, "ENT") == 0)\r\nparser->entry_point = le32_to_cpu(sec_hdr->target_addr);\r\nelse if (strcmp(sec_hdr->type, "LBL") == 0)\r\nstrcpy(dbg->label_fw, parser->file + parser->cur_pos);\r\nelse if (((strcmp(sec_hdr->type, "TOP") == 0) &&\r\n(priv->barker & BARKER_DNLOAD_TOP_MSK)) ||\r\n((strcmp(sec_hdr->type, "GPS") == 0) &&\r\n(priv->barker & BARKER_DNLOAD_GPS_MSK)) ||\r\n((strcmp(sec_hdr->type, "BTH") == 0) &&\r\n(priv->barker & BARKER_DNLOAD_BT_MSK))) {\r\n*sec_addr = sec_hdr->target_addr;\r\n*sec_size = le32_to_cpu(sec_hdr->data_size);\r\n*p_sec = parser->file + parser->cur_pos;\r\nparser->cur_pos += le32_to_cpu(sec_hdr->data_size);\r\nreturn 1;\r\n} else if (strcmp(sec_hdr->type, "LOG") != 0)\r\nLOG_WARNING(priv, FW_DOWNLOAD,\r\n"skipping section type %s\n",\r\nsec_hdr->type);\r\nparser->cur_pos += le32_to_cpu(sec_hdr->data_size);\r\nLOG_INFO(priv, FW_DOWNLOAD,\r\n"finished with section cur_pos=%zd\n", parser->cur_pos);\r\n}\r\nLOG_TRACE(priv, INIT, "<--\n");\r\nreturn 0;\r\n}\r\nstatic int iwmct_download_section(struct iwmct_priv *priv, const u8 *p_sec,\r\nsize_t sec_size, __le32 addr)\r\n{\r\nstruct iwmct_parser *parser = &priv->parser;\r\nstruct iwmct_fw_load_hdr *hdr = (struct iwmct_fw_load_hdr *)parser->buf;\r\nconst u8 *cur_block = p_sec;\r\nsize_t sent = 0;\r\nint cnt = 0;\r\nint ret = 0;\r\nu32 cmd = 0;\r\nLOG_TRACE(priv, FW_DOWNLOAD, "-->\n");\r\nLOG_INFO(priv, FW_DOWNLOAD, "Download address 0x%x size 0x%zx\n",\r\naddr, sec_size);\r\nwhile (sent < sec_size) {\r\nint i;\r\nu32 chksm = 0;\r\nu32 reset = atomic_read(&priv->reset);\r\nu32 data_size = min(parser->buf_size - sizeof(*hdr),\r\nsec_size - sent);\r\nu32 trans_size = (data_size + sizeof(*hdr) +\r\nIWMC_SDIO_BLK_SIZE - 1) &\r\n~(IWMC_SDIO_BLK_SIZE - 1);\r\n++cnt;\r\nif (reset) {\r\nLOG_INFO(priv, FW_DOWNLOAD,\r\n"Reset detected. Abort FW download!!!");\r\nret = -ECANCELED;\r\ngoto exit;\r\n}\r\nmemset(parser->buf, 0, parser->buf_size);\r\ncmd |= IWMC_OPCODE_WRITE << CMD_HDR_OPCODE_POS;\r\ncmd |= IWMC_CMD_SIGNATURE << CMD_HDR_SIGNATURE_POS;\r\ncmd |= (priv->dbg.direct ? 1 : 0) << CMD_HDR_DIRECT_ACCESS_POS;\r\ncmd |= (priv->dbg.checksum ? 1 : 0) << CMD_HDR_USE_CHECKSUM_POS;\r\nhdr->data_size = cpu_to_le32(data_size);\r\nhdr->target_addr = addr;\r\nif (data_size & 0x3)\r\ncmd &= ~CMD_HDR_USE_CHECKSUM_MSK;\r\nmemcpy(hdr->data, cur_block, data_size);\r\nif (cmd & CMD_HDR_USE_CHECKSUM_MSK) {\r\nchksm = data_size + le32_to_cpu(addr) + cmd;\r\nfor (i = 0; i < data_size >> 2; i++)\r\nchksm += ((u32 *)cur_block)[i];\r\nhdr->block_chksm = cpu_to_le32(chksm);\r\nLOG_INFO(priv, FW_DOWNLOAD, "Checksum = 0x%X\n",\r\nhdr->block_chksm);\r\n}\r\nLOG_INFO(priv, FW_DOWNLOAD, "trans#%d, len=%d, sent=%zd, "\r\n"sec_size=%zd, startAddress 0x%X\n",\r\ncnt, trans_size, sent, sec_size, addr);\r\nif (priv->dbg.dump)\r\nLOG_HEXDUMP(FW_DOWNLOAD, parser->buf, trans_size);\r\nhdr->cmd = cpu_to_le32(cmd);\r\nret = iwmct_tx(priv, parser->buf, trans_size);\r\nif (ret != 0) {\r\nLOG_INFO(priv, FW_DOWNLOAD,\r\n"iwmct_tx returned %d\n", ret);\r\ngoto exit;\r\n}\r\naddr = cpu_to_le32(le32_to_cpu(addr) + data_size);\r\nsent += data_size;\r\ncur_block = p_sec + sent;\r\nif (priv->dbg.blocks && (cnt + 1) >= priv->dbg.blocks) {\r\nLOG_INFO(priv, FW_DOWNLOAD,\r\n"Block number limit is reached [%d]\n",\r\npriv->dbg.blocks);\r\nbreak;\r\n}\r\n}\r\nif (sent < sec_size)\r\nret = -EINVAL;\r\nexit:\r\nLOG_TRACE(priv, FW_DOWNLOAD, "<--\n");\r\nreturn ret;\r\n}\r\nstatic int iwmct_kick_fw(struct iwmct_priv *priv, bool jump)\r\n{\r\nstruct iwmct_parser *parser = &priv->parser;\r\nstruct iwmct_fw_load_hdr *hdr = (struct iwmct_fw_load_hdr *)parser->buf;\r\nint ret;\r\nu32 cmd;\r\nLOG_TRACE(priv, FW_DOWNLOAD, "-->\n");\r\nmemset(parser->buf, 0, parser->buf_size);\r\ncmd = IWMC_CMD_SIGNATURE << CMD_HDR_SIGNATURE_POS;\r\nif (jump) {\r\ncmd |= IWMC_OPCODE_JUMP << CMD_HDR_OPCODE_POS;\r\nhdr->target_addr = cpu_to_le32(parser->entry_point);\r\nLOG_INFO(priv, FW_DOWNLOAD, "jump address 0x%x\n",\r\nparser->entry_point);\r\n} else {\r\ncmd |= IWMC_OPCODE_LAST_COMMAND << CMD_HDR_OPCODE_POS;\r\nLOG_INFO(priv, FW_DOWNLOAD, "last command\n");\r\n}\r\nhdr->cmd = cpu_to_le32(cmd);\r\nLOG_HEXDUMP(FW_DOWNLOAD, parser->buf, sizeof(*hdr));\r\nret = iwmct_tx(priv, parser->buf, IWMC_SDIO_BLK_SIZE);\r\nif (ret)\r\nLOG_INFO(priv, FW_DOWNLOAD, "iwmct_tx returned %d", ret);\r\nLOG_TRACE(priv, FW_DOWNLOAD, "<--\n");\r\nreturn 0;\r\n}\r\nint iwmct_fw_load(struct iwmct_priv *priv)\r\n{\r\nconst u8 *fw_name = FW_NAME(FW_API_VER);\r\nconst struct firmware *raw;\r\nconst u8 *pdata;\r\nsize_t len;\r\n__le32 addr;\r\nint ret;\r\nLOG_INFO(priv, FW_DOWNLOAD, "barker download request 0x%x is:\n",\r\npriv->barker);\r\nLOG_INFO(priv, FW_DOWNLOAD, "******* Top FW %s requested ********\n",\r\n(priv->barker & BARKER_DNLOAD_TOP_MSK) ? "was" : "not");\r\nLOG_INFO(priv, FW_DOWNLOAD, "******* GPS FW %s requested ********\n",\r\n(priv->barker & BARKER_DNLOAD_GPS_MSK) ? "was" : "not");\r\nLOG_INFO(priv, FW_DOWNLOAD, "******* BT FW %s requested ********\n",\r\n(priv->barker & BARKER_DNLOAD_BT_MSK) ? "was" : "not");\r\nret = request_firmware(&raw, fw_name, &priv->func->dev);\r\nif (ret < 0) {\r\nLOG_ERROR(priv, FW_DOWNLOAD, "%s request_firmware failed %d\n",\r\nfw_name, ret);\r\ngoto exit;\r\n}\r\nif (raw->size < sizeof(struct iwmct_fw_sec_hdr)) {\r\nLOG_ERROR(priv, FW_DOWNLOAD, "%s smaller then (%zd) (%zd)\n",\r\nfw_name, sizeof(struct iwmct_fw_sec_hdr), raw->size);\r\ngoto exit;\r\n}\r\nLOG_INFO(priv, FW_DOWNLOAD, "Read firmware '%s'\n", fw_name);\r\nret = iwmct_fw_parser_init(priv, raw->data, raw->size, priv->trans_len);\r\nif (ret < 0) {\r\nLOG_ERROR(priv, FW_DOWNLOAD,\r\n"iwmct_parser_init failed: Reason %d\n", ret);\r\ngoto exit;\r\n}\r\nif (!iwmct_checksum(priv)) {\r\nLOG_ERROR(priv, FW_DOWNLOAD, "checksum error\n");\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nwhile (iwmct_parse_next_section(priv, &pdata, &len, &addr)) {\r\nret = iwmct_download_section(priv, pdata, len, addr);\r\nif (ret) {\r\nLOG_ERROR(priv, FW_DOWNLOAD,\r\n"%s download section failed\n", fw_name);\r\ngoto exit;\r\n}\r\n}\r\nret = iwmct_kick_fw(priv, !!(priv->barker & BARKER_DNLOAD_JUMP_MSK));\r\nexit:\r\nkfree(priv->parser.buf);\r\nrelease_firmware(raw);\r\nreturn ret;\r\n}
