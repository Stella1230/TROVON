static inline u_int8_t instance_hashfn(u_int16_t group_num)\r\n{\r\nreturn ((group_num & 0xff) % INSTANCE_BUCKETS);\r\n}\r\nstatic struct nfulnl_instance *\r\n__instance_lookup(u_int16_t group_num)\r\n{\r\nstruct hlist_head *head;\r\nstruct hlist_node *pos;\r\nstruct nfulnl_instance *inst;\r\nhead = &instance_table[instance_hashfn(group_num)];\r\nhlist_for_each_entry_rcu(inst, pos, head, hlist) {\r\nif (inst->group_num == group_num)\r\nreturn inst;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline void\r\ninstance_get(struct nfulnl_instance *inst)\r\n{\r\natomic_inc(&inst->use);\r\n}\r\nstatic struct nfulnl_instance *\r\ninstance_lookup_get(u_int16_t group_num)\r\n{\r\nstruct nfulnl_instance *inst;\r\nrcu_read_lock_bh();\r\ninst = __instance_lookup(group_num);\r\nif (inst && !atomic_inc_not_zero(&inst->use))\r\ninst = NULL;\r\nrcu_read_unlock_bh();\r\nreturn inst;\r\n}\r\nstatic void nfulnl_instance_free_rcu(struct rcu_head *head)\r\n{\r\nkfree(container_of(head, struct nfulnl_instance, rcu));\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic void\r\ninstance_put(struct nfulnl_instance *inst)\r\n{\r\nif (inst && atomic_dec_and_test(&inst->use))\r\ncall_rcu_bh(&inst->rcu, nfulnl_instance_free_rcu);\r\n}\r\nstatic struct nfulnl_instance *\r\ninstance_create(u_int16_t group_num, int pid)\r\n{\r\nstruct nfulnl_instance *inst;\r\nint err;\r\nspin_lock_bh(&instances_lock);\r\nif (__instance_lookup(group_num)) {\r\nerr = -EEXIST;\r\ngoto out_unlock;\r\n}\r\ninst = kzalloc(sizeof(*inst), GFP_ATOMIC);\r\nif (!inst) {\r\nerr = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nif (!try_module_get(THIS_MODULE)) {\r\nkfree(inst);\r\nerr = -EAGAIN;\r\ngoto out_unlock;\r\n}\r\nINIT_HLIST_NODE(&inst->hlist);\r\nspin_lock_init(&inst->lock);\r\natomic_set(&inst->use, 2);\r\nsetup_timer(&inst->timer, nfulnl_timer, (unsigned long)inst);\r\ninst->peer_pid = pid;\r\ninst->group_num = group_num;\r\ninst->qthreshold = NFULNL_QTHRESH_DEFAULT;\r\ninst->flushtimeout = NFULNL_TIMEOUT_DEFAULT;\r\ninst->nlbufsiz = NFULNL_NLBUFSIZ_DEFAULT;\r\ninst->copy_mode = NFULNL_COPY_PACKET;\r\ninst->copy_range = NFULNL_COPY_RANGE_MAX;\r\nhlist_add_head_rcu(&inst->hlist,\r\n&instance_table[instance_hashfn(group_num)]);\r\nspin_unlock_bh(&instances_lock);\r\nreturn inst;\r\nout_unlock:\r\nspin_unlock_bh(&instances_lock);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void\r\n__instance_destroy(struct nfulnl_instance *inst)\r\n{\r\nhlist_del_rcu(&inst->hlist);\r\nspin_lock(&inst->lock);\r\ninst->copy_mode = NFULNL_COPY_DISABLED;\r\nif (inst->skb)\r\n__nfulnl_flush(inst);\r\nspin_unlock(&inst->lock);\r\ninstance_put(inst);\r\n}\r\nstatic inline void\r\ninstance_destroy(struct nfulnl_instance *inst)\r\n{\r\nspin_lock_bh(&instances_lock);\r\n__instance_destroy(inst);\r\nspin_unlock_bh(&instances_lock);\r\n}\r\nstatic int\r\nnfulnl_set_mode(struct nfulnl_instance *inst, u_int8_t mode,\r\nunsigned int range)\r\n{\r\nint status = 0;\r\nspin_lock_bh(&inst->lock);\r\nswitch (mode) {\r\ncase NFULNL_COPY_NONE:\r\ncase NFULNL_COPY_META:\r\ninst->copy_mode = mode;\r\ninst->copy_range = 0;\r\nbreak;\r\ncase NFULNL_COPY_PACKET:\r\ninst->copy_mode = mode;\r\ninst->copy_range = min_t(unsigned int,\r\nrange, NFULNL_COPY_RANGE_MAX);\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock_bh(&inst->lock);\r\nreturn status;\r\n}\r\nstatic int\r\nnfulnl_set_nlbufsiz(struct nfulnl_instance *inst, u_int32_t nlbufsiz)\r\n{\r\nint status;\r\nspin_lock_bh(&inst->lock);\r\nif (nlbufsiz < NFULNL_NLBUFSIZ_DEFAULT)\r\nstatus = -ERANGE;\r\nelse if (nlbufsiz > 131072)\r\nstatus = -ERANGE;\r\nelse {\r\ninst->nlbufsiz = nlbufsiz;\r\nstatus = 0;\r\n}\r\nspin_unlock_bh(&inst->lock);\r\nreturn status;\r\n}\r\nstatic int\r\nnfulnl_set_timeout(struct nfulnl_instance *inst, u_int32_t timeout)\r\n{\r\nspin_lock_bh(&inst->lock);\r\ninst->flushtimeout = timeout;\r\nspin_unlock_bh(&inst->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nnfulnl_set_qthresh(struct nfulnl_instance *inst, u_int32_t qthresh)\r\n{\r\nspin_lock_bh(&inst->lock);\r\ninst->qthreshold = qthresh;\r\nspin_unlock_bh(&inst->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nnfulnl_set_flags(struct nfulnl_instance *inst, u_int16_t flags)\r\n{\r\nspin_lock_bh(&inst->lock);\r\ninst->flags = flags;\r\nspin_unlock_bh(&inst->lock);\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *\r\nnfulnl_alloc_skb(unsigned int inst_size, unsigned int pkt_size)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned int n;\r\nn = max(inst_size, pkt_size);\r\nskb = alloc_skb(n, GFP_ATOMIC);\r\nif (!skb) {\r\nif (n > pkt_size) {\r\nskb = alloc_skb(pkt_size, GFP_ATOMIC);\r\nif (!skb)\r\npr_err("nfnetlink_log: can't even alloc %u bytes\n",\r\npkt_size);\r\n}\r\n}\r\nreturn skb;\r\n}\r\nstatic int\r\n__nfulnl_send(struct nfulnl_instance *inst)\r\n{\r\nint status = -1;\r\nif (inst->qlen > 1)\r\nNLMSG_PUT(inst->skb, 0, 0,\r\nNLMSG_DONE,\r\nsizeof(struct nfgenmsg));\r\nstatus = nfnetlink_unicast(inst->skb, &init_net, inst->peer_pid,\r\nMSG_DONTWAIT);\r\ninst->qlen = 0;\r\ninst->skb = NULL;\r\nnlmsg_failure:\r\nreturn status;\r\n}\r\nstatic void\r\n__nfulnl_flush(struct nfulnl_instance *inst)\r\n{\r\nif (del_timer(&inst->timer))\r\ninstance_put(inst);\r\nif (inst->skb)\r\n__nfulnl_send(inst);\r\n}\r\nstatic void\r\nnfulnl_timer(unsigned long data)\r\n{\r\nstruct nfulnl_instance *inst = (struct nfulnl_instance *)data;\r\nspin_lock_bh(&inst->lock);\r\nif (inst->skb)\r\n__nfulnl_send(inst);\r\nspin_unlock_bh(&inst->lock);\r\ninstance_put(inst);\r\n}\r\nstatic inline int\r\n__build_packet_message(struct nfulnl_instance *inst,\r\nconst struct sk_buff *skb,\r\nunsigned int data_len,\r\nu_int8_t pf,\r\nunsigned int hooknum,\r\nconst struct net_device *indev,\r\nconst struct net_device *outdev,\r\nconst char *prefix, unsigned int plen)\r\n{\r\nstruct nfulnl_msg_packet_hdr pmsg;\r\nstruct nlmsghdr *nlh;\r\nstruct nfgenmsg *nfmsg;\r\nsk_buff_data_t old_tail = inst->skb->tail;\r\nnlh = NLMSG_PUT(inst->skb, 0, 0,\r\nNFNL_SUBSYS_ULOG << 8 | NFULNL_MSG_PACKET,\r\nsizeof(struct nfgenmsg));\r\nnfmsg = NLMSG_DATA(nlh);\r\nnfmsg->nfgen_family = pf;\r\nnfmsg->version = NFNETLINK_V0;\r\nnfmsg->res_id = htons(inst->group_num);\r\npmsg.hw_protocol = skb->protocol;\r\npmsg.hook = hooknum;\r\nNLA_PUT(inst->skb, NFULA_PACKET_HDR, sizeof(pmsg), &pmsg);\r\nif (prefix)\r\nNLA_PUT(inst->skb, NFULA_PREFIX, plen, prefix);\r\nif (indev) {\r\n#ifndef CONFIG_BRIDGE_NETFILTER\r\nNLA_PUT_BE32(inst->skb, NFULA_IFINDEX_INDEV,\r\nhtonl(indev->ifindex));\r\n#else\r\nif (pf == PF_BRIDGE) {\r\nNLA_PUT_BE32(inst->skb, NFULA_IFINDEX_PHYSINDEV,\r\nhtonl(indev->ifindex));\r\nNLA_PUT_BE32(inst->skb, NFULA_IFINDEX_INDEV,\r\nhtonl(br_port_get_rcu(indev)->br->dev->ifindex));\r\n} else {\r\nNLA_PUT_BE32(inst->skb, NFULA_IFINDEX_INDEV,\r\nhtonl(indev->ifindex));\r\nif (skb->nf_bridge && skb->nf_bridge->physindev)\r\nNLA_PUT_BE32(inst->skb, NFULA_IFINDEX_PHYSINDEV,\r\nhtonl(skb->nf_bridge->physindev->ifindex));\r\n}\r\n#endif\r\n}\r\nif (outdev) {\r\n#ifndef CONFIG_BRIDGE_NETFILTER\r\nNLA_PUT_BE32(inst->skb, NFULA_IFINDEX_OUTDEV,\r\nhtonl(outdev->ifindex));\r\n#else\r\nif (pf == PF_BRIDGE) {\r\nNLA_PUT_BE32(inst->skb, NFULA_IFINDEX_PHYSOUTDEV,\r\nhtonl(outdev->ifindex));\r\nNLA_PUT_BE32(inst->skb, NFULA_IFINDEX_OUTDEV,\r\nhtonl(br_port_get_rcu(outdev)->br->dev->ifindex));\r\n} else {\r\nNLA_PUT_BE32(inst->skb, NFULA_IFINDEX_OUTDEV,\r\nhtonl(outdev->ifindex));\r\nif (skb->nf_bridge && skb->nf_bridge->physoutdev)\r\nNLA_PUT_BE32(inst->skb, NFULA_IFINDEX_PHYSOUTDEV,\r\nhtonl(skb->nf_bridge->physoutdev->ifindex));\r\n}\r\n#endif\r\n}\r\nif (skb->mark)\r\nNLA_PUT_BE32(inst->skb, NFULA_MARK, htonl(skb->mark));\r\nif (indev && skb->dev &&\r\nskb->mac_header != skb->network_header) {\r\nstruct nfulnl_msg_packet_hw phw;\r\nint len = dev_parse_header(skb, phw.hw_addr);\r\nif (len > 0) {\r\nphw.hw_addrlen = htons(len);\r\nNLA_PUT(inst->skb, NFULA_HWADDR, sizeof(phw), &phw);\r\n}\r\n}\r\nif (indev && skb_mac_header_was_set(skb)) {\r\nNLA_PUT_BE16(inst->skb, NFULA_HWTYPE, htons(skb->dev->type));\r\nNLA_PUT_BE16(inst->skb, NFULA_HWLEN,\r\nhtons(skb->dev->hard_header_len));\r\nNLA_PUT(inst->skb, NFULA_HWHEADER, skb->dev->hard_header_len,\r\nskb_mac_header(skb));\r\n}\r\nif (skb->tstamp.tv64) {\r\nstruct nfulnl_msg_packet_timestamp ts;\r\nstruct timeval tv = ktime_to_timeval(skb->tstamp);\r\nts.sec = cpu_to_be64(tv.tv_sec);\r\nts.usec = cpu_to_be64(tv.tv_usec);\r\nNLA_PUT(inst->skb, NFULA_TIMESTAMP, sizeof(ts), &ts);\r\n}\r\nif (skb->sk) {\r\nread_lock_bh(&skb->sk->sk_callback_lock);\r\nif (skb->sk->sk_socket && skb->sk->sk_socket->file) {\r\nstruct file *file = skb->sk->sk_socket->file;\r\n__be32 uid = htonl(file->f_cred->fsuid);\r\n__be32 gid = htonl(file->f_cred->fsgid);\r\nread_unlock_bh(&skb->sk->sk_callback_lock);\r\nNLA_PUT_BE32(inst->skb, NFULA_UID, uid);\r\nNLA_PUT_BE32(inst->skb, NFULA_GID, gid);\r\n} else\r\nread_unlock_bh(&skb->sk->sk_callback_lock);\r\n}\r\nif (inst->flags & NFULNL_CFG_F_SEQ)\r\nNLA_PUT_BE32(inst->skb, NFULA_SEQ, htonl(inst->seq++));\r\nif (inst->flags & NFULNL_CFG_F_SEQ_GLOBAL)\r\nNLA_PUT_BE32(inst->skb, NFULA_SEQ_GLOBAL,\r\nhtonl(atomic_inc_return(&global_seq)));\r\nif (data_len) {\r\nstruct nlattr *nla;\r\nint size = nla_attr_size(data_len);\r\nif (skb_tailroom(inst->skb) < nla_total_size(data_len)) {\r\nprintk(KERN_WARNING "nfnetlink_log: no tailroom!\n");\r\ngoto nlmsg_failure;\r\n}\r\nnla = (struct nlattr *)skb_put(inst->skb, nla_total_size(data_len));\r\nnla->nla_type = NFULA_PAYLOAD;\r\nnla->nla_len = size;\r\nif (skb_copy_bits(skb, 0, nla_data(nla), data_len))\r\nBUG();\r\n}\r\nnlh->nlmsg_len = inst->skb->tail - old_tail;\r\nreturn 0;\r\nnlmsg_failure:\r\nnla_put_failure:\r\nPRINTR(KERN_ERR "nfnetlink_log: error creating log nlmsg\n");\r\nreturn -1;\r\n}\r\nvoid\r\nnfulnl_log_packet(u_int8_t pf,\r\nunsigned int hooknum,\r\nconst struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nconst struct nf_loginfo *li_user,\r\nconst char *prefix)\r\n{\r\nunsigned int size, data_len;\r\nstruct nfulnl_instance *inst;\r\nconst struct nf_loginfo *li;\r\nunsigned int qthreshold;\r\nunsigned int plen;\r\nif (li_user && li_user->type == NF_LOG_TYPE_ULOG)\r\nli = li_user;\r\nelse\r\nli = &default_loginfo;\r\ninst = instance_lookup_get(li->u.ulog.group);\r\nif (!inst)\r\nreturn;\r\nplen = 0;\r\nif (prefix)\r\nplen = strlen(prefix) + 1;\r\nsize = NLMSG_SPACE(sizeof(struct nfgenmsg))\r\n+ nla_total_size(sizeof(struct nfulnl_msg_packet_hdr))\r\n+ nla_total_size(sizeof(u_int32_t))\r\n+ nla_total_size(sizeof(u_int32_t))\r\n#ifdef CONFIG_BRIDGE_NETFILTER\r\n+ nla_total_size(sizeof(u_int32_t))\r\n+ nla_total_size(sizeof(u_int32_t))\r\n#endif\r\n+ nla_total_size(sizeof(u_int32_t))\r\n+ nla_total_size(sizeof(u_int32_t))\r\n+ nla_total_size(sizeof(u_int32_t))\r\n+ nla_total_size(plen)\r\n+ nla_total_size(sizeof(struct nfulnl_msg_packet_hw))\r\n+ nla_total_size(sizeof(struct nfulnl_msg_packet_timestamp));\r\nif (in && skb_mac_header_was_set(skb)) {\r\nsize += nla_total_size(skb->dev->hard_header_len)\r\n+ nla_total_size(sizeof(u_int16_t))\r\n+ nla_total_size(sizeof(u_int16_t));\r\n}\r\nspin_lock_bh(&inst->lock);\r\nif (inst->flags & NFULNL_CFG_F_SEQ)\r\nsize += nla_total_size(sizeof(u_int32_t));\r\nif (inst->flags & NFULNL_CFG_F_SEQ_GLOBAL)\r\nsize += nla_total_size(sizeof(u_int32_t));\r\nqthreshold = inst->qthreshold;\r\nif (li->u.ulog.qthreshold)\r\nif (qthreshold > li->u.ulog.qthreshold)\r\nqthreshold = li->u.ulog.qthreshold;\r\nswitch (inst->copy_mode) {\r\ncase NFULNL_COPY_META:\r\ncase NFULNL_COPY_NONE:\r\ndata_len = 0;\r\nbreak;\r\ncase NFULNL_COPY_PACKET:\r\nif (inst->copy_range == 0\r\n|| inst->copy_range > skb->len)\r\ndata_len = skb->len;\r\nelse\r\ndata_len = inst->copy_range;\r\nsize += nla_total_size(data_len);\r\nbreak;\r\ncase NFULNL_COPY_DISABLED:\r\ndefault:\r\ngoto unlock_and_release;\r\n}\r\nif (inst->skb &&\r\nsize > skb_tailroom(inst->skb) - sizeof(struct nfgenmsg)) {\r\n__nfulnl_flush(inst);\r\n}\r\nif (!inst->skb) {\r\ninst->skb = nfulnl_alloc_skb(inst->nlbufsiz, size);\r\nif (!inst->skb)\r\ngoto alloc_failure;\r\n}\r\ninst->qlen++;\r\n__build_packet_message(inst, skb, data_len, pf,\r\nhooknum, in, out, prefix, plen);\r\nif (inst->qlen >= qthreshold)\r\n__nfulnl_flush(inst);\r\nelse if (!timer_pending(&inst->timer)) {\r\ninstance_get(inst);\r\ninst->timer.expires = jiffies + (inst->flushtimeout*HZ/100);\r\nadd_timer(&inst->timer);\r\n}\r\nunlock_and_release:\r\nspin_unlock_bh(&inst->lock);\r\ninstance_put(inst);\r\nreturn;\r\nalloc_failure:\r\ngoto unlock_and_release;\r\n}\r\nstatic int\r\nnfulnl_rcv_nl_event(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct netlink_notify *n = ptr;\r\nif (event == NETLINK_URELEASE && n->protocol == NETLINK_NETFILTER) {\r\nint i;\r\nspin_lock_bh(&instances_lock);\r\nfor (i = 0; i < INSTANCE_BUCKETS; i++) {\r\nstruct hlist_node *tmp, *t2;\r\nstruct nfulnl_instance *inst;\r\nstruct hlist_head *head = &instance_table[i];\r\nhlist_for_each_entry_safe(inst, tmp, t2, head, hlist) {\r\nif ((net_eq(n->net, &init_net)) &&\r\n(n->pid == inst->peer_pid))\r\n__instance_destroy(inst);\r\n}\r\n}\r\nspin_unlock_bh(&instances_lock);\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int\r\nnfulnl_recv_unsupp(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const nfqa[])\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int\r\nnfulnl_recv_config(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const nfula[])\r\n{\r\nstruct nfgenmsg *nfmsg = NLMSG_DATA(nlh);\r\nu_int16_t group_num = ntohs(nfmsg->res_id);\r\nstruct nfulnl_instance *inst;\r\nstruct nfulnl_msg_config_cmd *cmd = NULL;\r\nint ret = 0;\r\nif (nfula[NFULA_CFG_CMD]) {\r\nu_int8_t pf = nfmsg->nfgen_family;\r\ncmd = nla_data(nfula[NFULA_CFG_CMD]);\r\nswitch (cmd->command) {\r\ncase NFULNL_CFG_CMD_PF_BIND:\r\nreturn nf_log_bind_pf(pf, &nfulnl_logger);\r\ncase NFULNL_CFG_CMD_PF_UNBIND:\r\nnf_log_unbind_pf(pf);\r\nreturn 0;\r\n}\r\n}\r\ninst = instance_lookup_get(group_num);\r\nif (inst && inst->peer_pid != NETLINK_CB(skb).pid) {\r\nret = -EPERM;\r\ngoto out_put;\r\n}\r\nif (cmd != NULL) {\r\nswitch (cmd->command) {\r\ncase NFULNL_CFG_CMD_BIND:\r\nif (inst) {\r\nret = -EBUSY;\r\ngoto out_put;\r\n}\r\ninst = instance_create(group_num,\r\nNETLINK_CB(skb).pid);\r\nif (IS_ERR(inst)) {\r\nret = PTR_ERR(inst);\r\ngoto out;\r\n}\r\nbreak;\r\ncase NFULNL_CFG_CMD_UNBIND:\r\nif (!inst) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\ninstance_destroy(inst);\r\ngoto out_put;\r\ndefault:\r\nret = -ENOTSUPP;\r\nbreak;\r\n}\r\n}\r\nif (nfula[NFULA_CFG_MODE]) {\r\nstruct nfulnl_msg_config_mode *params;\r\nparams = nla_data(nfula[NFULA_CFG_MODE]);\r\nif (!inst) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nnfulnl_set_mode(inst, params->copy_mode,\r\nntohl(params->copy_range));\r\n}\r\nif (nfula[NFULA_CFG_TIMEOUT]) {\r\n__be32 timeout = nla_get_be32(nfula[NFULA_CFG_TIMEOUT]);\r\nif (!inst) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nnfulnl_set_timeout(inst, ntohl(timeout));\r\n}\r\nif (nfula[NFULA_CFG_NLBUFSIZ]) {\r\n__be32 nlbufsiz = nla_get_be32(nfula[NFULA_CFG_NLBUFSIZ]);\r\nif (!inst) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nnfulnl_set_nlbufsiz(inst, ntohl(nlbufsiz));\r\n}\r\nif (nfula[NFULA_CFG_QTHRESH]) {\r\n__be32 qthresh = nla_get_be32(nfula[NFULA_CFG_QTHRESH]);\r\nif (!inst) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nnfulnl_set_qthresh(inst, ntohl(qthresh));\r\n}\r\nif (nfula[NFULA_CFG_FLAGS]) {\r\n__be16 flags = nla_get_be16(nfula[NFULA_CFG_FLAGS]);\r\nif (!inst) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nnfulnl_set_flags(inst, ntohs(flags));\r\n}\r\nout_put:\r\ninstance_put(inst);\r\nout:\r\nreturn ret;\r\n}\r\nstatic struct hlist_node *get_first(struct iter_state *st)\r\n{\r\nif (!st)\r\nreturn NULL;\r\nfor (st->bucket = 0; st->bucket < INSTANCE_BUCKETS; st->bucket++) {\r\nif (!hlist_empty(&instance_table[st->bucket]))\r\nreturn rcu_dereference_bh(hlist_first_rcu(&instance_table[st->bucket]));\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct hlist_node *get_next(struct iter_state *st, struct hlist_node *h)\r\n{\r\nh = rcu_dereference_bh(hlist_next_rcu(h));\r\nwhile (!h) {\r\nif (++st->bucket >= INSTANCE_BUCKETS)\r\nreturn NULL;\r\nh = rcu_dereference_bh(hlist_first_rcu(&instance_table[st->bucket]));\r\n}\r\nreturn h;\r\n}\r\nstatic struct hlist_node *get_idx(struct iter_state *st, loff_t pos)\r\n{\r\nstruct hlist_node *head;\r\nhead = get_first(st);\r\nif (head)\r\nwhile (pos && (head = get_next(st, head)))\r\npos--;\r\nreturn pos ? NULL : head;\r\n}\r\nstatic void *seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(rcu_bh)\r\n{\r\nrcu_read_lock_bh();\r\nreturn get_idx(seq->private, *pos);\r\n}\r\nstatic void *seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nreturn get_next(s->private, v);\r\n}\r\nstatic void seq_stop(struct seq_file *s, void *v)\r\n__releases(rcu_bh)\r\n{\r\nrcu_read_unlock_bh();\r\n}\r\nstatic int seq_show(struct seq_file *s, void *v)\r\n{\r\nconst struct nfulnl_instance *inst = v;\r\nreturn seq_printf(s, "%5d %6d %5d %1d %5d %6d %2d\n",\r\ninst->group_num,\r\ninst->peer_pid, inst->qlen,\r\ninst->copy_mode, inst->copy_range,\r\ninst->flushtimeout, atomic_read(&inst->use));\r\n}\r\nstatic int nful_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_private(file, &nful_seq_ops,\r\nsizeof(struct iter_state));\r\n}\r\nstatic int __init nfnetlink_log_init(void)\r\n{\r\nint i, status = -ENOMEM;\r\nfor (i = 0; i < INSTANCE_BUCKETS; i++)\r\nINIT_HLIST_HEAD(&instance_table[i]);\r\nget_random_bytes(&hash_init, sizeof(hash_init));\r\nnetlink_register_notifier(&nfulnl_rtnl_notifier);\r\nstatus = nfnetlink_subsys_register(&nfulnl_subsys);\r\nif (status < 0) {\r\nprintk(KERN_ERR "log: failed to create netlink socket\n");\r\ngoto cleanup_netlink_notifier;\r\n}\r\nstatus = nf_log_register(NFPROTO_UNSPEC, &nfulnl_logger);\r\nif (status < 0) {\r\nprintk(KERN_ERR "log: failed to register logger\n");\r\ngoto cleanup_subsys;\r\n}\r\n#ifdef CONFIG_PROC_FS\r\nif (!proc_create("nfnetlink_log", 0440,\r\nproc_net_netfilter, &nful_file_ops))\r\ngoto cleanup_logger;\r\n#endif\r\nreturn status;\r\n#ifdef CONFIG_PROC_FS\r\ncleanup_logger:\r\nnf_log_unregister(&nfulnl_logger);\r\n#endif\r\ncleanup_subsys:\r\nnfnetlink_subsys_unregister(&nfulnl_subsys);\r\ncleanup_netlink_notifier:\r\nnetlink_unregister_notifier(&nfulnl_rtnl_notifier);\r\nreturn status;\r\n}\r\nstatic void __exit nfnetlink_log_fini(void)\r\n{\r\nnf_log_unregister(&nfulnl_logger);\r\n#ifdef CONFIG_PROC_FS\r\nremove_proc_entry("nfnetlink_log", proc_net_netfilter);\r\n#endif\r\nnfnetlink_subsys_unregister(&nfulnl_subsys);\r\nnetlink_unregister_notifier(&nfulnl_rtnl_notifier);\r\n}
