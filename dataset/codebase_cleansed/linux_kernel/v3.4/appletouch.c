static int atp_geyser_init(struct usb_device *udev)\r\n{\r\nchar *data;\r\nint size;\r\nint i;\r\nint ret;\r\ndata = kmalloc(8, GFP_KERNEL);\r\nif (!data) {\r\nerr("Out of memory");\r\nreturn -ENOMEM;\r\n}\r\nsize = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\nATP_GEYSER_MODE_READ_REQUEST_ID,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\nATP_GEYSER_MODE_REQUEST_VALUE,\r\nATP_GEYSER_MODE_REQUEST_INDEX, data, 8, 5000);\r\nif (size != 8) {\r\ndprintk("atp_geyser_init: read error\n");\r\nfor (i = 0; i < 8; i++)\r\ndprintk("appletouch[%d]: %d\n", i, data[i]);\r\nerr("Failed to read mode from device.");\r\nret = -EIO;\r\ngoto out_free;\r\n}\r\ndata[0] = ATP_GEYSER_MODE_VENDOR_VALUE;\r\nsize = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nATP_GEYSER_MODE_WRITE_REQUEST_ID,\r\nUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\nATP_GEYSER_MODE_REQUEST_VALUE,\r\nATP_GEYSER_MODE_REQUEST_INDEX, data, 8, 5000);\r\nif (size != 8) {\r\ndprintk("atp_geyser_init: write error\n");\r\nfor (i = 0; i < 8; i++)\r\ndprintk("appletouch[%d]: %d\n", i, data[i]);\r\nerr("Failed to request geyser raw mode");\r\nret = -EIO;\r\ngoto out_free;\r\n}\r\nret = 0;\r\nout_free:\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic void atp_reinit(struct work_struct *work)\r\n{\r\nstruct atp *dev = container_of(work, struct atp, work);\r\nstruct usb_device *udev = dev->udev;\r\nint retval;\r\ndprintk("appletouch: putting appletouch to sleep (reinit)\n");\r\natp_geyser_init(udev);\r\nretval = usb_submit_urb(dev->urb, GFP_ATOMIC);\r\nif (retval)\r\nerr("atp_reinit: usb_submit_urb failed with error %d",\r\nretval);\r\n}\r\nstatic int atp_calculate_abs(int *xy_sensors, int nb_sensors, int fact,\r\nint *z, int *fingers)\r\n{\r\nint i;\r\nint pcum = 0, psum = 0;\r\nint is_increasing = 0;\r\n*fingers = 0;\r\nfor (i = 0; i < nb_sensors; i++) {\r\nif (xy_sensors[i] < threshold) {\r\nif (is_increasing)\r\nis_increasing = 0;\r\ncontinue;\r\n}\r\nif (i < 1 ||\r\n(!is_increasing && xy_sensors[i - 1] < xy_sensors[i])) {\r\n(*fingers)++;\r\nis_increasing = 1;\r\n} else if (i > 0 && (xy_sensors[i - 1] - xy_sensors[i] > threshold)) {\r\nis_increasing = 0;\r\n}\r\npcum += (xy_sensors[i] - threshold) * i;\r\npsum += (xy_sensors[i] - threshold);\r\n}\r\nif (psum > 0) {\r\n*z = psum;\r\nreturn pcum * fact / psum;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void atp_report_fingers(struct input_dev *input, int fingers)\r\n{\r\ninput_report_key(input, BTN_TOOL_FINGER, fingers == 1);\r\ninput_report_key(input, BTN_TOOL_DOUBLETAP, fingers == 2);\r\ninput_report_key(input, BTN_TOOL_TRIPLETAP, fingers > 2);\r\n}\r\nstatic int atp_status_check(struct urb *urb)\r\n{\r\nstruct atp *dev = urb->context;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -EOVERFLOW:\r\nif (!dev->overflow_warned) {\r\nprintk(KERN_WARNING "appletouch: OVERFLOW with data "\r\n"length %d, actual length is %d\n",\r\ndev->info->datalen, dev->urb->actual_length);\r\ndev->overflow_warned = true;\r\n}\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndbg("atp_complete: urb shutting down with status: %d",\r\nurb->status);\r\nreturn ATP_URB_STATUS_ERROR_FATAL;\r\ndefault:\r\ndbg("atp_complete: nonzero urb status received: %d",\r\nurb->status);\r\nreturn ATP_URB_STATUS_ERROR;\r\n}\r\nif (dev->urb->actual_length != dev->info->datalen) {\r\ndprintk("appletouch: incomplete data package"\r\n" (first byte: %d, length: %d).\n",\r\ndev->data[0], dev->urb->actual_length);\r\nreturn ATP_URB_STATUS_ERROR;\r\n}\r\nreturn ATP_URB_STATUS_SUCCESS;\r\n}\r\nstatic void atp_detect_size(struct atp *dev)\r\n{\r\nint i;\r\nfor (i = dev->info->xsensors; i < ATP_XSENSORS; i++) {\r\nif (dev->xy_cur[i]) {\r\nprintk(KERN_INFO "appletouch: 17\" model detected.\n");\r\ninput_set_abs_params(dev->input, ABS_X, 0,\r\n(dev->info->xsensors_17 - 1) *\r\ndev->info->xfact - 1,\r\nATP_FUZZ, 0);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void atp_complete_geyser_1_2(struct urb *urb)\r\n{\r\nint x, y, x_z, y_z, x_f, y_f;\r\nint retval, i, j;\r\nint key;\r\nstruct atp *dev = urb->context;\r\nint status = atp_status_check(urb);\r\nif (status == ATP_URB_STATUS_ERROR_FATAL)\r\nreturn;\r\nelse if (status == ATP_URB_STATUS_ERROR)\r\ngoto exit;\r\nif (dev->info == &geyser2_info) {\r\nmemset(dev->xy_cur, 0, sizeof(dev->xy_cur));\r\nfor (i = 0, j = 19; i < 20; i += 2, j += 3) {\r\ndev->xy_cur[i] = dev->data[j];\r\ndev->xy_cur[i + 1] = dev->data[j + 1];\r\n}\r\nfor (i = 0, j = 1; i < 9; i += 2, j += 3) {\r\ndev->xy_cur[ATP_XSENSORS + i] = dev->data[j];\r\ndev->xy_cur[ATP_XSENSORS + i + 1] = dev->data[j + 1];\r\n}\r\n} else {\r\nfor (i = 0; i < 8; i++) {\r\ndev->xy_cur[i + 0] = dev->data[5 * i + 2];\r\ndev->xy_cur[i + 8] = dev->data[5 * i + 4];\r\ndev->xy_cur[i + 16] = dev->data[5 * i + 42];\r\nif (i < 2)\r\ndev->xy_cur[i + 24] = dev->data[5 * i + 44];\r\ndev->xy_cur[ATP_XSENSORS + i] = dev->data[5 * i + 1];\r\ndev->xy_cur[ATP_XSENSORS + i + 8] = dev->data[5 * i + 3];\r\n}\r\n}\r\ndbg_dump("sample", dev->xy_cur);\r\nif (!dev->valid) {\r\ndev->valid = true;\r\ndev->x_old = dev->y_old = -1;\r\nmemcpy(dev->xy_old, dev->xy_cur, sizeof(dev->xy_old));\r\nif (unlikely(!dev->size_detect_done)) {\r\natp_detect_size(dev);\r\ndev->size_detect_done = 1;\r\ngoto exit;\r\n}\r\n}\r\nfor (i = 0; i < ATP_XSENSORS + ATP_YSENSORS; i++) {\r\nsigned char change = dev->xy_old[i] - dev->xy_cur[i];\r\ndev->xy_acc[i] -= change;\r\nif (dev->xy_acc[i] < 0)\r\ndev->xy_acc[i] = 0;\r\n}\r\nmemcpy(dev->xy_old, dev->xy_cur, sizeof(dev->xy_old));\r\ndbg_dump("accumulator", dev->xy_acc);\r\nx = atp_calculate_abs(dev->xy_acc, ATP_XSENSORS,\r\ndev->info->xfact, &x_z, &x_f);\r\ny = atp_calculate_abs(dev->xy_acc + ATP_XSENSORS, ATP_YSENSORS,\r\ndev->info->yfact, &y_z, &y_f);\r\nkey = dev->data[dev->info->datalen - 1] & ATP_STATUS_BUTTON;\r\nif (x && y) {\r\nif (dev->x_old != -1) {\r\nx = (dev->x_old * 3 + x) >> 2;\r\ny = (dev->y_old * 3 + y) >> 2;\r\ndev->x_old = x;\r\ndev->y_old = y;\r\nif (debug > 1)\r\nprintk(KERN_DEBUG "appletouch: "\r\n"X: %3d Y: %3d Xz: %3d Yz: %3d\n",\r\nx, y, x_z, y_z);\r\ninput_report_key(dev->input, BTN_TOUCH, 1);\r\ninput_report_abs(dev->input, ABS_X, x);\r\ninput_report_abs(dev->input, ABS_Y, y);\r\ninput_report_abs(dev->input, ABS_PRESSURE,\r\nmin(ATP_PRESSURE, x_z + y_z));\r\natp_report_fingers(dev->input, max(x_f, y_f));\r\n}\r\ndev->x_old = x;\r\ndev->y_old = y;\r\n} else if (!x && !y) {\r\ndev->x_old = dev->y_old = -1;\r\ninput_report_key(dev->input, BTN_TOUCH, 0);\r\ninput_report_abs(dev->input, ABS_PRESSURE, 0);\r\natp_report_fingers(dev->input, 0);\r\nmemset(dev->xy_acc, 0, sizeof(dev->xy_acc));\r\n}\r\ninput_report_key(dev->input, BTN_LEFT, key);\r\ninput_sync(dev->input);\r\nexit:\r\nretval = usb_submit_urb(dev->urb, GFP_ATOMIC);\r\nif (retval)\r\nerr("atp_complete: usb_submit_urb failed with result %d",\r\nretval);\r\n}\r\nstatic void atp_complete_geyser_3_4(struct urb *urb)\r\n{\r\nint x, y, x_z, y_z, x_f, y_f;\r\nint retval, i, j;\r\nint key;\r\nstruct atp *dev = urb->context;\r\nint status = atp_status_check(urb);\r\nif (status == ATP_URB_STATUS_ERROR_FATAL)\r\nreturn;\r\nelse if (status == ATP_URB_STATUS_ERROR)\r\ngoto exit;\r\nfor (i = 0, j = 19; i < 20; i += 2, j += 3) {\r\ndev->xy_cur[i] = dev->data[j + 1];\r\ndev->xy_cur[i + 1] = dev->data[j + 2];\r\n}\r\nfor (i = 0, j = 1; i < 9; i += 2, j += 3) {\r\ndev->xy_cur[ATP_XSENSORS + i] = dev->data[j + 1];\r\ndev->xy_cur[ATP_XSENSORS + i + 1] = dev->data[j + 2];\r\n}\r\ndbg_dump("sample", dev->xy_cur);\r\nif (dev->data[dev->info->datalen - 1] & ATP_STATUS_BASE_UPDATE) {\r\ndprintk("appletouch: updated base values\n");\r\nmemcpy(dev->xy_old, dev->xy_cur, sizeof(dev->xy_old));\r\ngoto exit;\r\n}\r\nfor (i = 0; i < ATP_XSENSORS + ATP_YSENSORS; i++) {\r\ndev->xy_acc[i] = dev->xy_cur[i] - dev->xy_old[i];\r\nif (dev->xy_acc[i] > 127)\r\ndev->xy_acc[i] -= 256;\r\nif (dev->xy_acc[i] < -127)\r\ndev->xy_acc[i] += 256;\r\nif (dev->xy_acc[i] < 0)\r\ndev->xy_acc[i] = 0;\r\n}\r\ndbg_dump("accumulator", dev->xy_acc);\r\nx = atp_calculate_abs(dev->xy_acc, ATP_XSENSORS,\r\ndev->info->xfact, &x_z, &x_f);\r\ny = atp_calculate_abs(dev->xy_acc + ATP_XSENSORS, ATP_YSENSORS,\r\ndev->info->yfact, &y_z, &y_f);\r\nkey = dev->data[dev->info->datalen - 1] & ATP_STATUS_BUTTON;\r\nif (x && y) {\r\nif (dev->x_old != -1) {\r\nx = (dev->x_old * 3 + x) >> 2;\r\ny = (dev->y_old * 3 + y) >> 2;\r\ndev->x_old = x;\r\ndev->y_old = y;\r\nif (debug > 1)\r\nprintk(KERN_DEBUG "appletouch: X: %3d Y: %3d "\r\n"Xz: %3d Yz: %3d\n",\r\nx, y, x_z, y_z);\r\ninput_report_key(dev->input, BTN_TOUCH, 1);\r\ninput_report_abs(dev->input, ABS_X, x);\r\ninput_report_abs(dev->input, ABS_Y, y);\r\ninput_report_abs(dev->input, ABS_PRESSURE,\r\nmin(ATP_PRESSURE, x_z + y_z));\r\natp_report_fingers(dev->input, max(x_f, y_f));\r\n}\r\ndev->x_old = x;\r\ndev->y_old = y;\r\n} else if (!x && !y) {\r\ndev->x_old = dev->y_old = -1;\r\ninput_report_key(dev->input, BTN_TOUCH, 0);\r\ninput_report_abs(dev->input, ABS_PRESSURE, 0);\r\natp_report_fingers(dev->input, 0);\r\nmemset(dev->xy_acc, 0, sizeof(dev->xy_acc));\r\n}\r\ninput_report_key(dev->input, BTN_LEFT, key);\r\ninput_sync(dev->input);\r\nif (!x && !y && !key) {\r\ndev->idlecount++;\r\nif (dev->idlecount == 10) {\r\ndev->x_old = dev->y_old = -1;\r\ndev->idlecount = 0;\r\nschedule_work(&dev->work);\r\nreturn;\r\n}\r\n} else\r\ndev->idlecount = 0;\r\nexit:\r\nretval = usb_submit_urb(dev->urb, GFP_ATOMIC);\r\nif (retval)\r\nerr("atp_complete: usb_submit_urb failed with result %d",\r\nretval);\r\n}\r\nstatic int atp_open(struct input_dev *input)\r\n{\r\nstruct atp *dev = input_get_drvdata(input);\r\nif (usb_submit_urb(dev->urb, GFP_ATOMIC))\r\nreturn -EIO;\r\ndev->open = 1;\r\nreturn 0;\r\n}\r\nstatic void atp_close(struct input_dev *input)\r\n{\r\nstruct atp *dev = input_get_drvdata(input);\r\nusb_kill_urb(dev->urb);\r\ncancel_work_sync(&dev->work);\r\ndev->open = 0;\r\n}\r\nstatic int atp_handle_geyser(struct atp *dev)\r\n{\r\nstruct usb_device *udev = dev->udev;\r\nif (dev->info != &fountain_info) {\r\nif (atp_geyser_init(udev))\r\nreturn -EIO;\r\nprintk(KERN_INFO "appletouch: Geyser mode initialized.\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int atp_probe(struct usb_interface *iface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct atp *dev;\r\nstruct input_dev *input_dev;\r\nstruct usb_device *udev = interface_to_usbdev(iface);\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint int_in_endpointAddr = 0;\r\nint i, error = -ENOMEM;\r\nconst struct atp_info *info = (const struct atp_info *)id->driver_info;\r\niface_desc = iface->cur_altsetting;\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (!int_in_endpointAddr && usb_endpoint_is_int_in(endpoint)) {\r\nint_in_endpointAddr = endpoint->bEndpointAddress;\r\nbreak;\r\n}\r\n}\r\nif (!int_in_endpointAddr) {\r\nerr("Could not find int-in endpoint");\r\nreturn -EIO;\r\n}\r\ndev = kzalloc(sizeof(struct atp), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!dev || !input_dev) {\r\nerr("Out of memory");\r\ngoto err_free_devs;\r\n}\r\ndev->udev = udev;\r\ndev->input = input_dev;\r\ndev->info = info;\r\ndev->overflow_warned = false;\r\ndev->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->urb)\r\ngoto err_free_devs;\r\ndev->data = usb_alloc_coherent(dev->udev, dev->info->datalen, GFP_KERNEL,\r\n&dev->urb->transfer_dma);\r\nif (!dev->data)\r\ngoto err_free_urb;\r\nusb_fill_int_urb(dev->urb, udev,\r\nusb_rcvintpipe(udev, int_in_endpointAddr),\r\ndev->data, dev->info->datalen,\r\ndev->info->callback, dev, 1);\r\nerror = atp_handle_geyser(dev);\r\nif (error)\r\ngoto err_free_buffer;\r\nusb_make_path(udev, dev->phys, sizeof(dev->phys));\r\nstrlcat(dev->phys, "/input0", sizeof(dev->phys));\r\ninput_dev->name = "appletouch";\r\ninput_dev->phys = dev->phys;\r\nusb_to_input_id(dev->udev, &input_dev->id);\r\ninput_dev->dev.parent = &iface->dev;\r\ninput_set_drvdata(input_dev, dev);\r\ninput_dev->open = atp_open;\r\ninput_dev->close = atp_close;\r\nset_bit(EV_ABS, input_dev->evbit);\r\ninput_set_abs_params(input_dev, ABS_X, 0,\r\n(dev->info->xsensors - 1) * dev->info->xfact - 1,\r\nATP_FUZZ, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0,\r\n(dev->info->ysensors - 1) * dev->info->yfact - 1,\r\nATP_FUZZ, 0);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE, 0, ATP_PRESSURE, 0, 0);\r\nset_bit(EV_KEY, input_dev->evbit);\r\nset_bit(BTN_TOUCH, input_dev->keybit);\r\nset_bit(BTN_TOOL_FINGER, input_dev->keybit);\r\nset_bit(BTN_TOOL_DOUBLETAP, input_dev->keybit);\r\nset_bit(BTN_TOOL_TRIPLETAP, input_dev->keybit);\r\nset_bit(BTN_LEFT, input_dev->keybit);\r\nerror = input_register_device(dev->input);\r\nif (error)\r\ngoto err_free_buffer;\r\nusb_set_intfdata(iface, dev);\r\nINIT_WORK(&dev->work, atp_reinit);\r\nreturn 0;\r\nerr_free_buffer:\r\nusb_free_coherent(dev->udev, dev->info->datalen,\r\ndev->data, dev->urb->transfer_dma);\r\nerr_free_urb:\r\nusb_free_urb(dev->urb);\r\nerr_free_devs:\r\nusb_set_intfdata(iface, NULL);\r\nkfree(dev);\r\ninput_free_device(input_dev);\r\nreturn error;\r\n}\r\nstatic void atp_disconnect(struct usb_interface *iface)\r\n{\r\nstruct atp *dev = usb_get_intfdata(iface);\r\nusb_set_intfdata(iface, NULL);\r\nif (dev) {\r\nusb_kill_urb(dev->urb);\r\ninput_unregister_device(dev->input);\r\nusb_free_coherent(dev->udev, dev->info->datalen,\r\ndev->data, dev->urb->transfer_dma);\r\nusb_free_urb(dev->urb);\r\nkfree(dev);\r\n}\r\nprintk(KERN_INFO "input: appletouch disconnected\n");\r\n}\r\nstatic int atp_recover(struct atp *dev)\r\n{\r\nint error;\r\nerror = atp_handle_geyser(dev);\r\nif (error)\r\nreturn error;\r\nif (dev->open && usb_submit_urb(dev->urb, GFP_ATOMIC))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int atp_suspend(struct usb_interface *iface, pm_message_t message)\r\n{\r\nstruct atp *dev = usb_get_intfdata(iface);\r\nusb_kill_urb(dev->urb);\r\nreturn 0;\r\n}\r\nstatic int atp_resume(struct usb_interface *iface)\r\n{\r\nstruct atp *dev = usb_get_intfdata(iface);\r\nif (dev->open && usb_submit_urb(dev->urb, GFP_ATOMIC))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int atp_reset_resume(struct usb_interface *iface)\r\n{\r\nstruct atp *dev = usb_get_intfdata(iface);\r\nreturn atp_recover(dev);\r\n}
