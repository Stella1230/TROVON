static char* get_chip_name(int chip_id) {\r\nint i;\r\nfor (i=0;chip_info_table[i].name!=NULL;i++)\r\nif (chip_info_table[i].chip_id==chip_id)\r\nbreak;\r\nreturn chip_info_table[i].name;\r\n}\r\nstatic void __devexit vt6655_remove(struct pci_dev *pcid)\r\n{\r\nPSDevice pDevice=pci_get_drvdata(pcid);\r\nif (pDevice==NULL)\r\nreturn;\r\ndevice_free_info(pDevice);\r\n}\r\nstatic void\r\ndevice_get_options(PSDevice pDevice, int index, char* devname) {\r\nPOPTIONS pOpts = &(pDevice->sOpts);\r\npOpts->nRxDescs0=RX_DESC_DEF0;\r\npOpts->nRxDescs1=RX_DESC_DEF1;\r\npOpts->nTxDescs[0]=TX_DESC_DEF0;\r\npOpts->nTxDescs[1]=TX_DESC_DEF1;\r\npOpts->flags|=DEVICE_FLAGS_IP_ALIGN;\r\npOpts->int_works=INT_WORKS_DEF;\r\npOpts->rts_thresh=RTS_THRESH_DEF;\r\npOpts->frag_thresh=FRAG_THRESH_DEF;\r\npOpts->data_rate=DATA_RATE_DEF;\r\npOpts->channel_num=CHANNEL_DEF;\r\npOpts->flags|=DEVICE_FLAGS_PREAMBLE_TYPE;\r\npOpts->flags|=DEVICE_FLAGS_OP_MODE;\r\npOpts->short_retry=SHORT_RETRY_DEF;\r\npOpts->long_retry=LONG_RETRY_DEF;\r\npOpts->bbp_type=BBP_TYPE_DEF;\r\npOpts->flags|=DEVICE_FLAGS_80211h_MODE;\r\npOpts->flags|=DEVICE_FLAGS_DiversityANT;\r\n}\r\nstatic void\r\ndevice_set_options(PSDevice pDevice) {\r\nunsigned char abyBroadcastAddr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nunsigned char abySNAP_RFC1042[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00};\r\nunsigned char abySNAP_Bridgetunnel[ETH_ALEN] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8};\r\nmemcpy(pDevice->abyBroadcastAddr, abyBroadcastAddr, ETH_ALEN);\r\nmemcpy(pDevice->abySNAP_RFC1042, abySNAP_RFC1042, ETH_ALEN);\r\nmemcpy(pDevice->abySNAP_Bridgetunnel, abySNAP_Bridgetunnel, ETH_ALEN);\r\npDevice->uChannel = pDevice->sOpts.channel_num;\r\npDevice->wRTSThreshold = pDevice->sOpts.rts_thresh;\r\npDevice->wFragmentationThreshold = pDevice->sOpts.frag_thresh;\r\npDevice->byShortRetryLimit = pDevice->sOpts.short_retry;\r\npDevice->byLongRetryLimit = pDevice->sOpts.long_retry;\r\npDevice->wMaxTransmitMSDULifetime = DEFAULT_MSDU_LIFETIME;\r\npDevice->byShortPreamble = (pDevice->sOpts.flags & DEVICE_FLAGS_PREAMBLE_TYPE) ? 1 : 0;\r\npDevice->byOpMode = (pDevice->sOpts.flags & DEVICE_FLAGS_OP_MODE) ? 1 : 0;\r\npDevice->ePSMode = (pDevice->sOpts.flags & DEVICE_FLAGS_PS_MODE) ? 1 : 0;\r\npDevice->b11hEnable = (pDevice->sOpts.flags & DEVICE_FLAGS_80211h_MODE) ? 1 : 0;\r\npDevice->bDiversityRegCtlON = (pDevice->sOpts.flags & DEVICE_FLAGS_DiversityANT) ? 1 : 0;\r\npDevice->uConnectionRate = pDevice->sOpts.data_rate;\r\nif (pDevice->uConnectionRate < RATE_AUTO) pDevice->bFixRate = true;\r\npDevice->byBBType = pDevice->sOpts.bbp_type;\r\npDevice->byPacketType = pDevice->byBBType;\r\npDevice->byAutoFBCtrl = AUTO_FB_0;\r\npDevice->bUpdateBBVGA = true;\r\npDevice->byFOETuning = 0;\r\npDevice->wCTSDuration = 0;\r\npDevice->byPreambleType = 0;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" uChannel= %d\n",(int)pDevice->uChannel);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byOpMode= %d\n",(int)pDevice->byOpMode);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" ePSMode= %d\n",(int)pDevice->ePSMode);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" wRTSThreshold= %d\n",(int)pDevice->wRTSThreshold);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byShortRetryLimit= %d\n",(int)pDevice->byShortRetryLimit);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byLongRetryLimit= %d\n",(int)pDevice->byLongRetryLimit);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byPreambleType= %d\n",(int)pDevice->byPreambleType);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byShortPreamble= %d\n",(int)pDevice->byShortPreamble);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" uConnectionRate= %d\n",(int)pDevice->uConnectionRate);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" byBBType= %d\n",(int)pDevice->byBBType);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pDevice->b11hEnable= %d\n",(int)pDevice->b11hEnable);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" pDevice->bDiversityRegCtlON= %d\n",(int)pDevice->bDiversityRegCtlON);\r\n}\r\nstatic void s_vCompleteCurrentMeasure (PSDevice pDevice, unsigned char byResult)\r\n{\r\nunsigned int ii;\r\nunsigned long dwDuration = 0;\r\nunsigned char byRPI0 = 0;\r\nfor(ii=1;ii<8;ii++) {\r\npDevice->dwRPIs[ii] *= 255;\r\ndwDuration |= *((unsigned short *) (pDevice->pCurrMeasureEID->sReq.abyDuration));\r\ndwDuration <<= 10;\r\npDevice->dwRPIs[ii] /= dwDuration;\r\npDevice->abyRPIs[ii] = (unsigned char) pDevice->dwRPIs[ii];\r\nbyRPI0 += pDevice->abyRPIs[ii];\r\n}\r\npDevice->abyRPIs[0] = (0xFF - byRPI0);\r\nif (pDevice->uNumOfMeasureEIDs == 0) {\r\nVNTWIFIbMeasureReport( pDevice->pMgmt,\r\ntrue,\r\npDevice->pCurrMeasureEID,\r\nbyResult,\r\npDevice->byBasicMap,\r\npDevice->byCCAFraction,\r\npDevice->abyRPIs\r\n);\r\n} else {\r\nVNTWIFIbMeasureReport( pDevice->pMgmt,\r\nfalse,\r\npDevice->pCurrMeasureEID,\r\nbyResult,\r\npDevice->byBasicMap,\r\npDevice->byCCAFraction,\r\npDevice->abyRPIs\r\n);\r\nCARDbStartMeasure (pDevice, pDevice->pCurrMeasureEID++, pDevice->uNumOfMeasureEIDs);\r\n}\r\n}\r\nstatic void device_init_registers(PSDevice pDevice, DEVICE_INIT_TYPE InitType)\r\n{\r\nunsigned int ii;\r\nunsigned char byValue;\r\nunsigned char byValue1;\r\nunsigned char byCCKPwrdBm = 0;\r\nunsigned char byOFDMPwrdBm = 0;\r\nint zonetype=0;\r\nPSMgmtObject pMgmt = &(pDevice->sMgmtObj);\r\nMACbShutdown(pDevice->PortOffset);\r\nBBvSoftwareReset(pDevice->PortOffset);\r\nif ((InitType == DEVICE_INIT_COLD) ||\r\n(InitType == DEVICE_INIT_DXPL)) {\r\nMACbSoftwareReset(pDevice->PortOffset);\r\npDevice->bCCK = true;\r\npDevice->bAES = false;\r\npDevice->bProtectMode = false;\r\npDevice->bNonERPPresent = false;\r\npDevice->bBarkerPreambleMd = false;\r\npDevice->wCurrentRate = RATE_1M;\r\npDevice->byTopOFDMBasicRate = RATE_24M;\r\npDevice->byTopCCKBasicRate = RATE_1M;\r\npDevice->byRevId = 0;\r\nMACvInitialize(pDevice->PortOffset);\r\nVNSvInPortB(pDevice->PortOffset + MAC_REG_LOCALID, &(pDevice->byLocalID));\r\nspin_lock_irq(&pDevice->lock);\r\nSROMvReadAllContents(pDevice->PortOffset,pDevice->abyEEPROM);\r\nspin_unlock_irq(&pDevice->lock);\r\npDevice->byMinChannel = 1;\r\npDevice->byMaxChannel = CB_MAX_CHANNEL;\r\nbyValue = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);\r\nif (byValue & EEP_ANTINV)\r\npDevice->bTxRxAntInv = true;\r\nelse\r\npDevice->bTxRxAntInv = false;\r\n#ifdef PLICE_DEBUG\r\n#endif\r\nbyValue &= (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);\r\nif (byValue == 0)\r\nbyValue = (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN);\r\n#ifdef PLICE_DEBUG\r\n#endif\r\npDevice->ulDiversityNValue = 100*260;\r\npDevice->ulDiversityMValue = 100*16;\r\npDevice->byTMax = 1;\r\npDevice->byTMax2 = 4;\r\npDevice->ulSQ3TH = 0;\r\npDevice->byTMax3 = 64;\r\nif (byValue == (EEP_ANTENNA_AUX | EEP_ANTENNA_MAIN)) {\r\npDevice->byAntennaCount = 2;\r\npDevice->byTxAntennaMode = ANT_B;\r\npDevice->dwTxAntennaSel = 1;\r\npDevice->dwRxAntennaSel = 1;\r\nif (pDevice->bTxRxAntInv == true)\r\npDevice->byRxAntennaMode = ANT_A;\r\nelse\r\npDevice->byRxAntennaMode = ANT_B;\r\nbyValue1 = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ANTENNA);\r\nif((byValue1&0x08)==0)\r\npDevice->bDiversityEnable = false;\r\nelse\r\npDevice->bDiversityEnable = true;\r\n#ifdef PLICE_DEBUG\r\n#endif\r\n} else {\r\npDevice->bDiversityEnable = false;\r\npDevice->byAntennaCount = 1;\r\npDevice->dwTxAntennaSel = 0;\r\npDevice->dwRxAntennaSel = 0;\r\nif (byValue & EEP_ANTENNA_AUX) {\r\npDevice->byTxAntennaMode = ANT_A;\r\nif (pDevice->bTxRxAntInv == true)\r\npDevice->byRxAntennaMode = ANT_B;\r\nelse\r\npDevice->byRxAntennaMode = ANT_A;\r\n} else {\r\npDevice->byTxAntennaMode = ANT_B;\r\nif (pDevice->bTxRxAntInv == true)\r\npDevice->byRxAntennaMode = ANT_A;\r\nelse\r\npDevice->byRxAntennaMode = ANT_B;\r\n}\r\n}\r\n#ifdef PLICE_DEBUG\r\n#endif\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "bDiversityEnable=[%d],NValue=[%d],MValue=[%d],TMax=[%d],TMax2=[%d]\n",\r\npDevice->bDiversityEnable,(int)pDevice->ulDiversityNValue,(int)pDevice->ulDiversityMValue,pDevice->byTMax,pDevice->byTMax2);\r\npDevice->byOriginalZonetype = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];\r\nzonetype = Config_FileOperation(pDevice,false,NULL);\r\nif (zonetype >= 0) {\r\nif ((zonetype == 0)&&\r\n(pDevice->abyEEPROM[EEP_OFS_ZONETYPE] !=0x00)){\r\npDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0;\r\npDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0B;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Init Zone Type :USA\n");\r\n}\r\nelse if((zonetype == 1)&&\r\n(pDevice->abyEEPROM[EEP_OFS_ZONETYPE]!=0x01)){\r\npDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0x01;\r\npDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0D;\r\n}\r\nelse if((zonetype == 2)&&\r\n(pDevice->abyEEPROM[EEP_OFS_ZONETYPE]!=0x02)){\r\npDevice->abyEEPROM[EEP_OFS_ZONETYPE] = 0x02;\r\npDevice->abyEEPROM[EEP_OFS_MAXCHANNEL] = 0x0D;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Init Zone Type :Europe\n");\r\n}\r\nelse\r\n{\r\nif(zonetype!=pDevice->abyEEPROM[EEP_OFS_ZONETYPE])\r\nprintk("zonetype in file[%02x] mismatch with in EEPROM[%02x]\n",zonetype,pDevice->abyEEPROM[EEP_OFS_ZONETYPE]);\r\nelse\r\nprintk("Read Zonetype file success,use default zonetype setting[%02x]\n",zonetype);\r\n}\r\n}\r\nelse\r\nprintk("Read Zonetype file fail,use default zonetype setting[%02x]\n",SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_ZONETYPE));\r\npDevice->byRFType = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_RFTYPE);\r\nif ((pDevice->byRFType & RF_EMU) != 0) {\r\npDevice->byRevId = 0x80;\r\n}\r\npDevice->byRFType &= RF_MASK;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRFType = %x\n", pDevice->byRFType);\r\nif (pDevice->bZoneRegExist == false) {\r\npDevice->byZoneType = pDevice->abyEEPROM[EEP_OFS_ZONETYPE];\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byZoneType = %x\n", pDevice->byZoneType);\r\nRFbInit(pDevice);\r\npDevice->byCurPwr = 0xFF;\r\npDevice->byCCKPwr = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_PWR_CCK);\r\npDevice->byOFDMPwrG = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_PWR_OFDMG);\r\nfor (ii=0;ii<CB_MAX_CHANNEL_24G;ii++) {\r\npDevice->abyCCKPwrTbl[ii+1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_CCK_PWR_TBL));\r\nif (pDevice->abyCCKPwrTbl[ii+1] == 0) {\r\npDevice->abyCCKPwrTbl[ii+1] = pDevice->byCCKPwr;\r\n}\r\npDevice->abyOFDMPwrTbl[ii+1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_OFDM_PWR_TBL));\r\nif (pDevice->abyOFDMPwrTbl[ii+1] == 0) {\r\npDevice->abyOFDMPwrTbl[ii+1] = pDevice->byOFDMPwrG;\r\n}\r\npDevice->abyCCKDefaultPwr[ii+1] = byCCKPwrdBm;\r\npDevice->abyOFDMDefaultPwr[ii+1] = byOFDMPwrdBm;\r\n}\r\nif(((pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Japan) ||\r\n(pDevice->abyEEPROM[EEP_OFS_ZONETYPE] == ZoneType_Europe))&&\r\n(pDevice->byOriginalZonetype == ZoneType_USA)) {\r\nfor(ii=11;ii<14;ii++) {\r\npDevice->abyCCKPwrTbl[ii] = pDevice->abyCCKPwrTbl[10];\r\npDevice->abyOFDMPwrTbl[ii] = pDevice->abyOFDMPwrTbl[10];\r\n}\r\n}\r\nfor (ii=0;ii<CB_MAX_CHANNEL_5G;ii++) {\r\npDevice->abyOFDMPwrTbl[ii+CB_MAX_CHANNEL_24G+1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_OFDMA_PWR_TBL));\r\npDevice->abyOFDMDefaultPwr[ii+CB_MAX_CHANNEL_24G+1] = SROMbyReadEmbedded(pDevice->PortOffset, (unsigned char)(ii + EEP_OFS_OFDMA_PWR_dBm));\r\n}\r\ninit_channel_table((void *)pDevice);\r\nif (pDevice->byLocalID > REV_ID_VT3253_B1) {\r\nMACvSelectPage1(pDevice->PortOffset);\r\nVNSvOutPortB(pDevice->PortOffset + MAC_REG_MSRCTL + 1, (MSRCTL1_TXPWR | MSRCTL1_CSAPAREN));\r\nMACvSelectPage0(pDevice->PortOffset);\r\n}\r\nMACvWordRegBitsOn(pDevice->PortOffset, MAC_REG_CFG, (CFG_TKIPOPT | CFG_NOTXTIMEOUT));\r\nMACvSetShortRetryLimit(pDevice->PortOffset, pDevice->byShortRetryLimit);\r\nMACvSetLongRetryLimit(pDevice->PortOffset, pDevice->byLongRetryLimit);\r\nVNSvOutPortB(pDevice->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTRST);\r\nVNSvOutPortB(pDevice->PortOffset + MAC_REG_TFTCTL, TFTCTL_TSFCNTREN);\r\nBBbVT3253Init(pDevice);\r\nif (pDevice->bUpdateBBVGA) {\r\npDevice->byBBVGACurrent = pDevice->abyBBVGA[0];\r\npDevice->byBBVGANew = pDevice->byBBVGACurrent;\r\nBBvSetVGAGainOffset(pDevice, pDevice->abyBBVGA[0]);\r\n}\r\n#ifdef PLICE_DEBUG\r\n#endif\r\nBBvSetRxAntennaMode(pDevice->PortOffset, pDevice->byRxAntennaMode);\r\nBBvSetTxAntennaMode(pDevice->PortOffset, pDevice->byTxAntennaMode);\r\npDevice->byCurrentCh = 0;\r\nif (pDevice->uConnectionRate == RATE_AUTO) {\r\npDevice->wCurrentRate = RATE_54M;\r\n} else {\r\npDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;\r\n}\r\nVNTWIFIbConfigPhyMode(pDevice->pMgmt, PHY_TYPE_11G);\r\nVNTWIFIbConfigPhyMode(pDevice->pMgmt, PHY_TYPE_AUTO);\r\npDevice->bRadioOff = false;\r\npDevice->byRadioCtl = SROMbyReadEmbedded(pDevice->PortOffset, EEP_OFS_RADIOCTL);\r\npDevice->bHWRadioOff = false;\r\nif (pDevice->byRadioCtl & EEP_RADIOCTL_ENABLE) {\r\nMACvGPIOIn(pDevice->PortOffset, &pDevice->byGPIO);\r\n#ifdef FOR_LED_ON_NOTEBOOK\r\nif (pDevice->byGPIO & GPIO0_DATA){pDevice->bHWRadioOff = true;}\r\nif ( !(pDevice->byGPIO & GPIO0_DATA)){pDevice->bHWRadioOff = false;}\r\n}\r\nif ( (pDevice->bRadioControlOff == true)) {\r\nCARDbRadioPowerOff(pDevice);\r\n}\r\nelse CARDbRadioPowerOn(pDevice);\r\n#else\r\nif (((pDevice->byGPIO & GPIO0_DATA) && !(pDevice->byRadioCtl & EEP_RADIOCTL_INV)) ||\r\n( !(pDevice->byGPIO & GPIO0_DATA) && (pDevice->byRadioCtl & EEP_RADIOCTL_INV))) {\r\npDevice->bHWRadioOff = true;\r\n}\r\n}\r\nif ((pDevice->bHWRadioOff == true) || (pDevice->bRadioControlOff == true)) {\r\nCARDbRadioPowerOff(pDevice);\r\n}\r\n#endif\r\n}\r\nvoid device_init_diversity_timer(PSDevice pDevice) {\r\ninit_timer(&pDevice->TimerSQ3Tmax1);\r\npDevice->TimerSQ3Tmax1.data = (unsigned long) pDevice;\r\npDevice->TimerSQ3Tmax1.function = (TimerFunction)TimerSQ3CallBack;\r\npDevice->TimerSQ3Tmax1.expires = RUN_AT(HZ);\r\ninit_timer(&pDevice->TimerSQ3Tmax2);\r\npDevice->TimerSQ3Tmax2.data = (unsigned long) pDevice;\r\npDevice->TimerSQ3Tmax2.function = (TimerFunction)TimerSQ3CallBack;\r\npDevice->TimerSQ3Tmax2.expires = RUN_AT(HZ);\r\ninit_timer(&pDevice->TimerSQ3Tmax3);\r\npDevice->TimerSQ3Tmax3.data = (unsigned long) pDevice;\r\npDevice->TimerSQ3Tmax3.function = (TimerFunction)TimerState1CallBack;\r\npDevice->TimerSQ3Tmax3.expires = RUN_AT(HZ);\r\nreturn;\r\n}\r\nstatic bool device_release_WPADEV(PSDevice pDevice)\r\n{\r\nviawget_wpa_header *wpahdr;\r\nint ii=0;\r\nif (pDevice->bWPADEVUp==true) {\r\nwpahdr = (viawget_wpa_header *)pDevice->skb->data;\r\nwpahdr->type = VIAWGET_DEVICECLOSE_MSG;\r\nwpahdr->resp_ie_len = 0;\r\nwpahdr->req_ie_len = 0;\r\nskb_put(pDevice->skb, sizeof(viawget_wpa_header));\r\npDevice->skb->dev = pDevice->wpadev;\r\nskb_reset_mac_header(pDevice->skb);\r\npDevice->skb->pkt_type = PACKET_HOST;\r\npDevice->skb->protocol = htons(ETH_P_802_2);\r\nmemset(pDevice->skb->cb, 0, sizeof(pDevice->skb->cb));\r\nnetif_rx(pDevice->skb);\r\npDevice->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);\r\nwhile((pDevice->bWPADEVUp==true)) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout (HZ/20);\r\nii++;\r\nif(ii>20)\r\nbreak;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic int __devinit\r\nvt6655_probe(struct pci_dev *pcid, const struct pci_device_id *ent)\r\n{\r\nstatic bool bFirst = true;\r\nstruct net_device* dev = NULL;\r\nPCHIP_INFO pChip_info = (PCHIP_INFO)ent->driver_data;\r\nPSDevice pDevice;\r\nint rc;\r\nif (device_nics ++>= MAX_UINTS) {\r\nprintk(KERN_NOTICE DEVICE_NAME ": already found %d NICs\n", device_nics);\r\nreturn -ENODEV;\r\n}\r\ndev = alloc_etherdev(sizeof(DEVICE_INFO));\r\npDevice = (PSDevice) netdev_priv(dev);\r\nif (dev == NULL) {\r\nprintk(KERN_ERR DEVICE_NAME ": allocate net device failed \n");\r\nreturn -ENODEV;\r\n}\r\nSET_NETDEV_DEV(dev, &pcid->dev);\r\nif (bFirst) {\r\nprintk(KERN_NOTICE "%s Ver. %s\n",DEVICE_FULL_DRV_NAM, DEVICE_VERSION);\r\nprintk(KERN_NOTICE "Copyright (c) 2003 VIA Networking Technologies, Inc.\n");\r\nbFirst=false;\r\n}\r\nif (!vt6655_init_info(pcid, &pDevice, pChip_info)) {\r\nreturn -ENOMEM;\r\n}\r\npDevice->dev = dev;\r\npDevice->next_module = root_device_dev;\r\nroot_device_dev = dev;\r\nif (pci_enable_device(pcid)) {\r\ndevice_free_info(pDevice);\r\nreturn -ENODEV;\r\n}\r\ndev->irq = pcid->irq;\r\n#ifdef DEBUG\r\nprintk("Before get pci_info memaddr is %x\n",pDevice->memaddr);\r\n#endif\r\nif (device_get_pci_info(pDevice,pcid) == false) {\r\nprintk(KERN_ERR DEVICE_NAME ": Failed to find PCI device.\n");\r\ndevice_free_info(pDevice);\r\nreturn -ENODEV;\r\n}\r\n#if 1\r\n#ifdef DEBUG\r\nprintk("after get pci_info memaddr is %x, io addr is %x,io_size is %d\n",pDevice->memaddr,pDevice->ioaddr,pDevice->io_size);\r\n{\r\nint i;\r\nu32 bar,len;\r\nu32 address[] = {\r\nPCI_BASE_ADDRESS_0,\r\nPCI_BASE_ADDRESS_1,\r\nPCI_BASE_ADDRESS_2,\r\nPCI_BASE_ADDRESS_3,\r\nPCI_BASE_ADDRESS_4,\r\nPCI_BASE_ADDRESS_5,\r\n0};\r\nfor (i=0;address[i];i++)\r\n{\r\npci_read_config_dword(pcid, address[i], &bar);\r\nprintk("bar %d is %x\n",i,bar);\r\nif (!bar)\r\n{\r\nprintk("bar %d not implemented\n",i);\r\ncontinue;\r\n}\r\nif (bar & PCI_BASE_ADDRESS_SPACE_IO) {\r\nlen = bar & (PCI_BASE_ADDRESS_IO_MASK & 0xFFFF);\r\nlen = len & ~(len - 1);\r\nprintk("IO space: len in IO %x, BAR %d\n", len, i);\r\n}\r\nelse\r\n{\r\nlen = bar & 0xFFFFFFF0;\r\nlen = ~len + 1;\r\nprintk("len in MEM %x, BAR %d\n", len, i);\r\n}\r\n}\r\n}\r\n#endif\r\n#endif\r\n#ifdef DEBUG\r\n#endif\r\npDevice->PortOffset = (unsigned long)ioremap(pDevice->memaddr & PCI_BASE_ADDRESS_MEM_MASK, pDevice->io_size);\r\nif(pDevice->PortOffset == 0) {\r\nprintk(KERN_ERR DEVICE_NAME ": Failed to IO remapping ..\n");\r\ndevice_free_info(pDevice);\r\nreturn -ENODEV;\r\n}\r\nrc = pci_request_regions(pcid, DEVICE_NAME);\r\nif (rc) {\r\nprintk(KERN_ERR DEVICE_NAME ": Failed to find PCI device\n");\r\ndevice_free_info(pDevice);\r\nreturn -ENODEV;\r\n}\r\ndev->base_addr = pDevice->ioaddr;\r\n#ifdef PLICE_DEBUG\r\nunsigned char value;\r\nVNSvInPortB(pDevice->PortOffset+0x4F, &value);\r\nprintk("Before write: value is %x\n",value);\r\nVNSvOutPortB(pDevice->PortOffset,value);\r\nVNSvInPortB(pDevice->PortOffset+0x4F, &value);\r\nprintk("After write: value is %x\n",value);\r\n#endif\r\n#ifdef IO_MAP\r\npDevice->PortOffset = pDevice->ioaddr;\r\n#endif\r\nif (!MACbSoftwareReset(pDevice->PortOffset)) {\r\nprintk(KERN_ERR DEVICE_NAME ": Failed to access MAC hardware..\n");\r\ndevice_free_info(pDevice);\r\nreturn -ENODEV;\r\n}\r\nMACvInitialize(pDevice->PortOffset);\r\nMACvReadEtherAddress(pDevice->PortOffset, dev->dev_addr);\r\ndevice_get_options(pDevice, device_nics-1, dev->name);\r\ndevice_set_options(pDevice);\r\npDevice->sOpts.flags &= pChip_info->flags;\r\npDevice->flags = pDevice->sOpts.flags | (pChip_info->flags & 0xFF000000UL);\r\npDevice->tx_80211 = device_dma0_tx_80211;\r\npDevice->sMgmtObj.pAdapter = (void *)pDevice;\r\npDevice->pMgmt = &(pDevice->sMgmtObj);\r\ndev->irq = pcid->irq;\r\ndev->netdev_ops = &device_netdev_ops;\r\ndev->wireless_handlers = (struct iw_handler_def *)&iwctl_handler_def;\r\nrc = register_netdev(dev);\r\nif (rc)\r\n{\r\nprintk(KERN_ERR DEVICE_NAME " Failed to register netdev\n");\r\ndevice_free_info(pDevice);\r\nreturn -ENODEV;\r\n}\r\n#if 0\r\nif(wpa_set_wpadev(pDevice, 1)!=0) {\r\nprintk("Fail to Register WPADEV?\n");\r\nunregister_netdev(pDevice->dev);\r\nfree_netdev(dev);\r\n}\r\n#endif\r\ndevice_print_info(pDevice);\r\npci_set_drvdata(pcid, pDevice);\r\nreturn 0;\r\n}\r\nstatic void device_print_info(PSDevice pDevice)\r\n{\r\nstruct net_device* dev=pDevice->dev;\r\nDBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: %s\n",dev->name, get_chip_name(pDevice->chip_id));\r\nDBG_PRT(MSG_LEVEL_INFO, KERN_INFO "%s: MAC=%pM", dev->name, dev->dev_addr);\r\n#ifdef IO_MAP\r\nDBG_PRT(MSG_LEVEL_INFO, KERN_INFO" IO=0x%lx ",(unsigned long) pDevice->ioaddr);\r\nDBG_PRT(MSG_LEVEL_INFO, KERN_INFO" IRQ=%d \n", pDevice->dev->irq);\r\n#else\r\nDBG_PRT(MSG_LEVEL_INFO, KERN_INFO" IO=0x%lx Mem=0x%lx ",\r\n(unsigned long) pDevice->ioaddr,(unsigned long) pDevice->PortOffset);\r\nDBG_PRT(MSG_LEVEL_INFO, KERN_INFO" IRQ=%d \n", pDevice->dev->irq);\r\n#endif\r\n}\r\nstatic bool __devinit vt6655_init_info(struct pci_dev* pcid, PSDevice* ppDevice,\r\nPCHIP_INFO pChip_info) {\r\nPSDevice p;\r\nmemset(*ppDevice,0,sizeof(DEVICE_INFO));\r\nif (pDevice_Infos == NULL) {\r\npDevice_Infos =*ppDevice;\r\n}\r\nelse {\r\nfor (p=pDevice_Infos;p->next!=NULL;p=p->next)\r\ndo {} while (0);\r\np->next = *ppDevice;\r\n(*ppDevice)->prev = p;\r\n}\r\n(*ppDevice)->pcid = pcid;\r\n(*ppDevice)->chip_id = pChip_info->chip_id;\r\n(*ppDevice)->io_size = pChip_info->io_size;\r\n(*ppDevice)->nTxQueues = pChip_info->nTxQueue;\r\n(*ppDevice)->multicast_limit =32;\r\nspin_lock_init(&((*ppDevice)->lock));\r\nreturn true;\r\n}\r\nstatic bool device_get_pci_info(PSDevice pDevice, struct pci_dev* pcid) {\r\nu16 pci_cmd;\r\nu8 b;\r\nunsigned int cis_addr;\r\n#ifdef PLICE_DEBUG\r\nunsigned char pci_config[256];\r\nunsigned char value =0x00;\r\nint ii,j;\r\nu16 max_lat=0x0000;\r\nmemset(pci_config,0x00,256);\r\n#endif\r\npci_read_config_byte(pcid, PCI_REVISION_ID, &pDevice->byRevId);\r\npci_read_config_word(pcid, PCI_SUBSYSTEM_ID,&pDevice->SubSystemID);\r\npci_read_config_word(pcid, PCI_SUBSYSTEM_VENDOR_ID, &pDevice->SubVendorID);\r\npci_read_config_word(pcid, PCI_COMMAND, (u16 *) & (pci_cmd));\r\npci_set_master(pcid);\r\npDevice->memaddr = pci_resource_start(pcid,0);\r\npDevice->ioaddr = pci_resource_start(pcid,1);\r\n#ifdef DEBUG\r\n#endif\r\ncis_addr = pci_resource_start(pcid,2);\r\npDevice->pcid = pcid;\r\npci_read_config_byte(pcid, PCI_COMMAND, &b);\r\npci_write_config_byte(pcid, PCI_COMMAND, (b|PCI_COMMAND_MASTER));\r\n#ifdef PLICE_DEBUG\r\nfor (ii=0;ii<0xFF;ii++)\r\n{\r\npci_read_config_byte(pcid,ii,&value);\r\npci_config[ii] = value;\r\n}\r\nfor (ii=0,j=1;ii<0x100;ii++,j++)\r\n{\r\nif (j %16 == 0)\r\n{\r\nprintk("%x:",pci_config[ii]);\r\nprintk("\n");\r\n}\r\nelse\r\n{\r\nprintk("%x:",pci_config[ii]);\r\n}\r\n}\r\n#endif\r\nreturn true;\r\n}\r\nstatic void device_free_info(PSDevice pDevice) {\r\nPSDevice ptr;\r\nstruct net_device* dev=pDevice->dev;\r\nASSERT(pDevice);\r\ndevice_release_WPADEV(pDevice);\r\nif(wpa_set_wpadev(pDevice, 0)!=0)\r\nprintk("unregister wpadev fail?\n");\r\nif (pDevice_Infos==NULL)\r\nreturn;\r\nfor (ptr=pDevice_Infos;ptr && (ptr!=pDevice);ptr=ptr->next)\r\ndo {} while (0);\r\nif (ptr==pDevice) {\r\nif (ptr==pDevice_Infos)\r\npDevice_Infos=ptr->next;\r\nelse\r\nptr->prev->next=ptr->next;\r\n}\r\nelse {\r\nDBG_PRT(MSG_LEVEL_ERR, KERN_ERR "info struct not found\n");\r\nreturn;\r\n}\r\n#ifdef HOSTAP\r\nif (dev)\r\nvt6655_hostap_set_hostapd(pDevice, 0, 0);\r\n#endif\r\nif (dev)\r\nunregister_netdev(dev);\r\nif (pDevice->PortOffset)\r\niounmap((void *)pDevice->PortOffset);\r\nif (pDevice->pcid)\r\npci_release_regions(pDevice->pcid);\r\nif (dev)\r\nfree_netdev(dev);\r\nif (pDevice->pcid) {\r\npci_set_drvdata(pDevice->pcid,NULL);\r\n}\r\n}\r\nstatic bool device_init_rings(PSDevice pDevice) {\r\nvoid* vir_pool;\r\nvir_pool = pci_alloc_consistent(pDevice->pcid,\r\npDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +\r\npDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +\r\npDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +\r\npDevice->sOpts.nTxDescs[1] * sizeof(STxDesc),\r\n&pDevice->pool_dma);\r\nif (vir_pool == NULL) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s : allocate desc dma memory failed\n", pDevice->dev->name);\r\nreturn false;\r\n}\r\nmemset(vir_pool, 0,\r\npDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +\r\npDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +\r\npDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +\r\npDevice->sOpts.nTxDescs[1] * sizeof(STxDesc)\r\n);\r\npDevice->aRD0Ring = vir_pool;\r\npDevice->aRD1Ring = vir_pool +\r\npDevice->sOpts.nRxDescs0 * sizeof(SRxDesc);\r\npDevice->rd0_pool_dma = pDevice->pool_dma;\r\npDevice->rd1_pool_dma = pDevice->rd0_pool_dma +\r\npDevice->sOpts.nRxDescs0 * sizeof(SRxDesc);\r\npDevice->tx0_bufs = pci_alloc_consistent(pDevice->pcid,\r\npDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ +\r\npDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ +\r\nCB_BEACON_BUF_SIZE +\r\nCB_MAX_BUF_SIZE,\r\n&pDevice->tx_bufs_dma0);\r\nif (pDevice->tx0_bufs == NULL) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: allocate buf dma memory failed\n", pDevice->dev->name);\r\npci_free_consistent(pDevice->pcid,\r\npDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +\r\npDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +\r\npDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +\r\npDevice->sOpts.nTxDescs[1] * sizeof(STxDesc),\r\nvir_pool, pDevice->pool_dma\r\n);\r\nreturn false;\r\n}\r\nmemset(pDevice->tx0_bufs, 0,\r\npDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ +\r\npDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ +\r\nCB_BEACON_BUF_SIZE +\r\nCB_MAX_BUF_SIZE\r\n);\r\npDevice->td0_pool_dma = pDevice->rd1_pool_dma +\r\npDevice->sOpts.nRxDescs1 * sizeof(SRxDesc);\r\npDevice->td1_pool_dma = pDevice->td0_pool_dma +\r\npDevice->sOpts.nTxDescs[0] * sizeof(STxDesc);\r\npDevice->apTD0Rings = vir_pool\r\n+ pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc)\r\n+ pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc);\r\npDevice->apTD1Rings = vir_pool\r\n+ pDevice->sOpts.nRxDescs0 * sizeof(SRxDesc)\r\n+ pDevice->sOpts.nRxDescs1 * sizeof(SRxDesc)\r\n+ pDevice->sOpts.nTxDescs[0] * sizeof(STxDesc);\r\npDevice->tx1_bufs = pDevice->tx0_bufs +\r\npDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ;\r\npDevice->tx_beacon_bufs = pDevice->tx1_bufs +\r\npDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ;\r\npDevice->pbyTmpBuff = pDevice->tx_beacon_bufs +\r\nCB_BEACON_BUF_SIZE;\r\npDevice->tx_bufs_dma1 = pDevice->tx_bufs_dma0 +\r\npDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ;\r\npDevice->tx_beacon_dma = pDevice->tx_bufs_dma1 +\r\npDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ;\r\nreturn true;\r\n}\r\nstatic void device_free_rings(PSDevice pDevice) {\r\npci_free_consistent(pDevice->pcid,\r\npDevice->sOpts.nRxDescs0 * sizeof(SRxDesc) +\r\npDevice->sOpts.nRxDescs1 * sizeof(SRxDesc) +\r\npDevice->sOpts.nTxDescs[0] * sizeof(STxDesc) +\r\npDevice->sOpts.nTxDescs[1] * sizeof(STxDesc)\r\n,\r\npDevice->aRD0Ring, pDevice->pool_dma\r\n);\r\nif (pDevice->tx0_bufs)\r\npci_free_consistent(pDevice->pcid,\r\npDevice->sOpts.nTxDescs[0] * PKT_BUF_SZ +\r\npDevice->sOpts.nTxDescs[1] * PKT_BUF_SZ +\r\nCB_BEACON_BUF_SIZE +\r\nCB_MAX_BUF_SIZE,\r\npDevice->tx0_bufs, pDevice->tx_bufs_dma0\r\n);\r\n}\r\nstatic void device_init_rd0_ring(PSDevice pDevice) {\r\nint i;\r\ndma_addr_t curr = pDevice->rd0_pool_dma;\r\nPSRxDesc pDesc;\r\nfor (i = 0; i < pDevice->sOpts.nRxDescs0; i ++, curr += sizeof(SRxDesc)) {\r\npDesc = &(pDevice->aRD0Ring[i]);\r\npDesc->pRDInfo = alloc_rd_info();\r\nASSERT(pDesc->pRDInfo);\r\nif (!device_alloc_rx_buf(pDevice, pDesc)) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc rx bufs\n",\r\npDevice->dev->name);\r\n}\r\npDesc->next = &(pDevice->aRD0Ring[(i+1) % pDevice->sOpts.nRxDescs0]);\r\npDesc->pRDInfo->curr_desc = cpu_to_le32(curr);\r\npDesc->next_desc = cpu_to_le32(curr + sizeof(SRxDesc));\r\n}\r\nif (i > 0)\r\npDevice->aRD0Ring[i-1].next_desc = cpu_to_le32(pDevice->rd0_pool_dma);\r\npDevice->pCurrRD[0] = &(pDevice->aRD0Ring[0]);\r\n}\r\nstatic void device_init_rd1_ring(PSDevice pDevice) {\r\nint i;\r\ndma_addr_t curr = pDevice->rd1_pool_dma;\r\nPSRxDesc pDesc;\r\nfor (i = 0; i < pDevice->sOpts.nRxDescs1; i ++, curr += sizeof(SRxDesc)) {\r\npDesc = &(pDevice->aRD1Ring[i]);\r\npDesc->pRDInfo = alloc_rd_info();\r\nASSERT(pDesc->pRDInfo);\r\nif (!device_alloc_rx_buf(pDevice, pDesc)) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc rx bufs\n",\r\npDevice->dev->name);\r\n}\r\npDesc->next = &(pDevice->aRD1Ring[(i+1) % pDevice->sOpts.nRxDescs1]);\r\npDesc->pRDInfo->curr_desc = cpu_to_le32(curr);\r\npDesc->next_desc = cpu_to_le32(curr + sizeof(SRxDesc));\r\n}\r\nif (i > 0)\r\npDevice->aRD1Ring[i-1].next_desc = cpu_to_le32(pDevice->rd1_pool_dma);\r\npDevice->pCurrRD[1] = &(pDevice->aRD1Ring[0]);\r\n}\r\nstatic void device_init_defrag_cb(PSDevice pDevice) {\r\nint i;\r\nPSDeFragControlBlock pDeF;\r\nfor (i = 0; i < CB_MAX_RX_FRAG; i++) {\r\npDeF = &(pDevice->sRxDFCB[i]);\r\nif (!device_alloc_frag_buf(pDevice, pDeF)) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_ERR "%s: can not alloc frag bufs\n",\r\npDevice->dev->name);\r\n}\r\n}\r\npDevice->cbDFCB = CB_MAX_RX_FRAG;\r\npDevice->cbFreeDFCB = pDevice->cbDFCB;\r\n}\r\nstatic void device_free_rd0_ring(PSDevice pDevice) {\r\nint i;\r\nfor (i = 0; i < pDevice->sOpts.nRxDescs0; i++) {\r\nPSRxDesc pDesc =&(pDevice->aRD0Ring[i]);\r\nPDEVICE_RD_INFO pRDInfo =pDesc->pRDInfo;\r\npci_unmap_single(pDevice->pcid,pRDInfo->skb_dma,\r\npDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(pRDInfo->skb);\r\nkfree((void *)pDesc->pRDInfo);\r\n}\r\n}\r\nstatic void device_free_rd1_ring(PSDevice pDevice) {\r\nint i;\r\nfor (i = 0; i < pDevice->sOpts.nRxDescs1; i++) {\r\nPSRxDesc pDesc=&(pDevice->aRD1Ring[i]);\r\nPDEVICE_RD_INFO pRDInfo=pDesc->pRDInfo;\r\npci_unmap_single(pDevice->pcid,pRDInfo->skb_dma,\r\npDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(pRDInfo->skb);\r\nkfree((void *)pDesc->pRDInfo);\r\n}\r\n}\r\nstatic void device_free_frag_buf(PSDevice pDevice) {\r\nPSDeFragControlBlock pDeF;\r\nint i;\r\nfor (i = 0; i < CB_MAX_RX_FRAG; i++) {\r\npDeF = &(pDevice->sRxDFCB[i]);\r\nif (pDeF->skb)\r\ndev_kfree_skb(pDeF->skb);\r\n}\r\n}\r\nstatic void device_init_td0_ring(PSDevice pDevice) {\r\nint i;\r\ndma_addr_t curr;\r\nPSTxDesc pDesc;\r\ncurr = pDevice->td0_pool_dma;\r\nfor (i = 0; i < pDevice->sOpts.nTxDescs[0]; i++, curr += sizeof(STxDesc)) {\r\npDesc = &(pDevice->apTD0Rings[i]);\r\npDesc->pTDInfo = alloc_td_info();\r\nASSERT(pDesc->pTDInfo);\r\nif (pDevice->flags & DEVICE_FLAGS_TX_ALIGN) {\r\npDesc->pTDInfo->buf = pDevice->tx0_bufs + (i)*PKT_BUF_SZ;\r\npDesc->pTDInfo->buf_dma = pDevice->tx_bufs_dma0 + (i)*PKT_BUF_SZ;\r\n}\r\npDesc->next =&(pDevice->apTD0Rings[(i+1) % pDevice->sOpts.nTxDescs[0]]);\r\npDesc->pTDInfo->curr_desc = cpu_to_le32(curr);\r\npDesc->next_desc = cpu_to_le32(curr+sizeof(STxDesc));\r\n}\r\nif (i > 0)\r\npDevice->apTD0Rings[i-1].next_desc = cpu_to_le32(pDevice->td0_pool_dma);\r\npDevice->apTailTD[0] = pDevice->apCurrTD[0] =&(pDevice->apTD0Rings[0]);\r\n}\r\nstatic void device_init_td1_ring(PSDevice pDevice) {\r\nint i;\r\ndma_addr_t curr;\r\nPSTxDesc pDesc;\r\ncurr=pDevice->td1_pool_dma;\r\nfor (i = 0; i < pDevice->sOpts.nTxDescs[1]; i++, curr+=sizeof(STxDesc)) {\r\npDesc=&(pDevice->apTD1Rings[i]);\r\npDesc->pTDInfo = alloc_td_info();\r\nASSERT(pDesc->pTDInfo);\r\nif (pDevice->flags & DEVICE_FLAGS_TX_ALIGN) {\r\npDesc->pTDInfo->buf=pDevice->tx1_bufs+(i)*PKT_BUF_SZ;\r\npDesc->pTDInfo->buf_dma=pDevice->tx_bufs_dma1+(i)*PKT_BUF_SZ;\r\n}\r\npDesc->next=&(pDevice->apTD1Rings[(i+1) % pDevice->sOpts.nTxDescs[1]]);\r\npDesc->pTDInfo->curr_desc = cpu_to_le32(curr);\r\npDesc->next_desc = cpu_to_le32(curr+sizeof(STxDesc));\r\n}\r\nif (i > 0)\r\npDevice->apTD1Rings[i-1].next_desc = cpu_to_le32(pDevice->td1_pool_dma);\r\npDevice->apTailTD[1] = pDevice->apCurrTD[1] = &(pDevice->apTD1Rings[0]);\r\n}\r\nstatic void device_free_td0_ring(PSDevice pDevice) {\r\nint i;\r\nfor (i = 0; i < pDevice->sOpts.nTxDescs[0]; i++) {\r\nPSTxDesc pDesc=&(pDevice->apTD0Rings[i]);\r\nPDEVICE_TD_INFO pTDInfo=pDesc->pTDInfo;\r\nif (pTDInfo->skb_dma && (pTDInfo->skb_dma != pTDInfo->buf_dma))\r\npci_unmap_single(pDevice->pcid,pTDInfo->skb_dma,\r\npTDInfo->skb->len, PCI_DMA_TODEVICE);\r\nif (pTDInfo->skb)\r\ndev_kfree_skb(pTDInfo->skb);\r\nkfree((void *)pDesc->pTDInfo);\r\n}\r\n}\r\nstatic void device_free_td1_ring(PSDevice pDevice) {\r\nint i;\r\nfor (i = 0; i < pDevice->sOpts.nTxDescs[1]; i++) {\r\nPSTxDesc pDesc=&(pDevice->apTD1Rings[i]);\r\nPDEVICE_TD_INFO pTDInfo=pDesc->pTDInfo;\r\nif (pTDInfo->skb_dma && (pTDInfo->skb_dma != pTDInfo->buf_dma))\r\npci_unmap_single(pDevice->pcid, pTDInfo->skb_dma,\r\npTDInfo->skb->len, PCI_DMA_TODEVICE);\r\nif (pTDInfo->skb)\r\ndev_kfree_skb(pTDInfo->skb);\r\nkfree((void *)pDesc->pTDInfo);\r\n}\r\n}\r\nstatic int device_rx_srv(PSDevice pDevice, unsigned int uIdx) {\r\nPSRxDesc pRD;\r\nint works = 0;\r\nfor (pRD = pDevice->pCurrRD[uIdx];\r\npRD->m_rd0RD0.f1Owner == OWNED_BY_HOST;\r\npRD = pRD->next) {\r\nif (works++>15)\r\nbreak;\r\nif (device_receive_frame(pDevice, pRD)) {\r\nif (!device_alloc_rx_buf(pDevice,pRD)) {\r\nDBG_PRT(MSG_LEVEL_ERR, KERN_ERR\r\n"%s: can not allocate rx buf\n", pDevice->dev->name);\r\nbreak;\r\n}\r\n}\r\npRD->m_rd0RD0.f1Owner = OWNED_BY_NIC;\r\npDevice->dev->last_rx = jiffies;\r\n}\r\npDevice->pCurrRD[uIdx]=pRD;\r\nreturn works;\r\n}\r\nstatic bool device_alloc_rx_buf(PSDevice pDevice, PSRxDesc pRD) {\r\nPDEVICE_RD_INFO pRDInfo=pRD->pRDInfo;\r\npRDInfo->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);\r\n#ifdef PLICE_DEBUG\r\n#endif\r\nif (pRDInfo->skb==NULL)\r\nreturn false;\r\nASSERT(pRDInfo->skb);\r\npRDInfo->skb->dev = pDevice->dev;\r\npRDInfo->skb_dma = pci_map_single(pDevice->pcid, skb_tail_pointer(pRDInfo->skb),\r\npDevice->rx_buf_sz, PCI_DMA_FROMDEVICE);\r\n*((unsigned int *) &(pRD->m_rd0RD0)) = 0;\r\npRD->m_rd0RD0.wResCount = cpu_to_le16(pDevice->rx_buf_sz);\r\npRD->m_rd0RD0.f1Owner = OWNED_BY_NIC;\r\npRD->m_rd1RD1.wReqCount = cpu_to_le16(pDevice->rx_buf_sz);\r\npRD->buff_addr = cpu_to_le32(pRDInfo->skb_dma);\r\nreturn true;\r\n}\r\nbool device_alloc_frag_buf(PSDevice pDevice, PSDeFragControlBlock pDeF) {\r\npDeF->skb = dev_alloc_skb((int)pDevice->rx_buf_sz);\r\nif (pDeF->skb == NULL)\r\nreturn false;\r\nASSERT(pDeF->skb);\r\npDeF->skb->dev = pDevice->dev;\r\nreturn true;\r\n}\r\nstatic int device_tx_srv(PSDevice pDevice, unsigned int uIdx) {\r\nPSTxDesc pTD;\r\nbool bFull=false;\r\nint works = 0;\r\nunsigned char byTsr0;\r\nunsigned char byTsr1;\r\nunsigned int uFrameSize, uFIFOHeaderSize;\r\nPSTxBufHead pTxBufHead;\r\nstruct net_device_stats* pStats = &pDevice->stats;\r\nstruct sk_buff* skb;\r\nunsigned int uNodeIndex;\r\nPSMgmtObject pMgmt = pDevice->pMgmt;\r\nfor (pTD = pDevice->apTailTD[uIdx]; pDevice->iTDUsed[uIdx] >0; pTD = pTD->next) {\r\nif (pTD->m_td0TD0.f1Owner == OWNED_BY_NIC)\r\nbreak;\r\nif (works++>15)\r\nbreak;\r\nbyTsr0 = pTD->m_td0TD0.byTSR0;\r\nbyTsr1 = pTD->m_td0TD0.byTSR1;\r\nif (pTD->m_td1TD1.byTCR & TCR_STP) {\r\nif ((pTD->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB) != 0) {\r\nuFIFOHeaderSize = pTD->pTDInfo->dwHeaderLength;\r\nuFrameSize = pTD->pTDInfo->dwReqCount - uFIFOHeaderSize;\r\npTxBufHead = (PSTxBufHead) (pTD->pTDInfo->buf);\r\nSTAvUpdateTDStatCounter(&pDevice->scStatistic,\r\nbyTsr0, byTsr1,\r\n(unsigned char *)(pTD->pTDInfo->buf + uFIFOHeaderSize),\r\nuFrameSize, uIdx);\r\nBSSvUpdateNodeTxCounter(pDevice,\r\nbyTsr0, byTsr1,\r\n(unsigned char *)(pTD->pTDInfo->buf),\r\nuFIFOHeaderSize\r\n);\r\nif ( !(byTsr1 & TSR1_TERR)) {\r\nif (byTsr0 != 0) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] OK but has error. tsr1[%02X] tsr0[%02X].\n",\r\n(int)uIdx, byTsr1, byTsr0);\r\n}\r\nif ((pTxBufHead->wFragCtl & FRAGCTL_ENDFRAG) != FRAGCTL_NONFRAG) {\r\npDevice->s802_11Counter.TransmittedFragmentCount ++;\r\n}\r\npStats->tx_packets++;\r\npStats->tx_bytes += pTD->pTDInfo->skb->len;\r\n}\r\nelse {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] dropped & tsr1[%02X] tsr0[%02X].\n",\r\n(int)uIdx, byTsr1, byTsr0);\r\npStats->tx_errors++;\r\npStats->tx_dropped++;\r\n}\r\n}\r\nif ((pTD->pTDInfo->byFlags & TD_FLAGS_PRIV_SKB) != 0) {\r\nif (pDevice->bEnableHostapd) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "tx call back netif.. \n");\r\nskb = pTD->pTDInfo->skb;\r\nskb->dev = pDevice->apdev;\r\nskb_reset_mac_header(skb);\r\nskb->pkt_type = PACKET_OTHERHOST;\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nnetif_rx(skb);\r\n}\r\n}\r\nif (byTsr1 & TSR1_TERR) {\r\nif ((pTD->pTDInfo->byFlags & TD_FLAGS_PRIV_SKB) != 0) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO" Tx[%d] fail has error. tsr1[%02X] tsr0[%02X].\n",\r\n(int)uIdx, byTsr1, byTsr0);\r\n}\r\nif ((pMgmt->eCurrMode == WMAC_MODE_ESS_AP) &&\r\n(pTD->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB)) {\r\nunsigned short wAID;\r\nunsigned char byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};\r\nskb = pTD->pTDInfo->skb;\r\nif (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(skb->data), &uNodeIndex)) {\r\nif (pMgmt->sNodeDBTable[uNodeIndex].bPSEnable) {\r\nskb_queue_tail(&pMgmt->sNodeDBTable[uNodeIndex].sTxPSQueue, skb);\r\npMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt++;\r\nwAID = pMgmt->sNodeDBTable[uNodeIndex].wAID;\r\npMgmt->abyPSTxMap[wAID >> 3] |= byMask[wAID & 7];\r\npTD->pTDInfo->byFlags &= ~(TD_FLAGS_NETIF_SKB);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "tx_srv:tx fail re-queue sta index= %d, QueCnt= %d\n"\r\n,(int)uNodeIndex, pMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt);\r\npStats->tx_errors--;\r\npStats->tx_dropped--;\r\n}\r\n}\r\n}\r\n}\r\ndevice_free_tx_buf(pDevice,pTD);\r\npDevice->iTDUsed[uIdx]--;\r\n}\r\n}\r\nif (uIdx == TYPE_AC0DMA) {\r\nif (AVAIL_TD(pDevice, uIdx) < RESERV_AC0DMA) {\r\nbFull = true;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " AC0DMA is Full = %d\n", pDevice->iTDUsed[uIdx]);\r\n}\r\nif (netif_queue_stopped(pDevice->dev) && (bFull==false)){\r\nnetif_wake_queue(pDevice->dev);\r\n}\r\n}\r\npDevice->apTailTD[uIdx] = pTD;\r\nreturn works;\r\n}\r\nstatic void device_error(PSDevice pDevice, unsigned short status) {\r\nif (status & ISR_FETALERR) {\r\nDBG_PRT(MSG_LEVEL_ERR, KERN_ERR\r\n"%s: Hardware fatal error.\n",\r\npDevice->dev->name);\r\nnetif_stop_queue(pDevice->dev);\r\ndel_timer(&pDevice->sTimerCommand);\r\ndel_timer(&(pDevice->pMgmt->sTimerSecondCallback));\r\npDevice->bCmdRunning = false;\r\nMACbShutdown(pDevice->PortOffset);\r\nreturn;\r\n}\r\n}\r\nstatic void device_free_tx_buf(PSDevice pDevice, PSTxDesc pDesc) {\r\nPDEVICE_TD_INFO pTDInfo=pDesc->pTDInfo;\r\nstruct sk_buff* skb=pTDInfo->skb;\r\nif (pTDInfo->skb_dma && (pTDInfo->skb_dma != pTDInfo->buf_dma)) {\r\npci_unmap_single(pDevice->pcid,pTDInfo->skb_dma,skb->len,\r\nPCI_DMA_TODEVICE);\r\n}\r\nif ((pTDInfo->byFlags & TD_FLAGS_NETIF_SKB) != 0)\r\ndev_kfree_skb_irq(skb);\r\npTDInfo->skb_dma = 0;\r\npTDInfo->skb = 0;\r\npTDInfo->byFlags = 0;\r\n}\r\nvoid InitRxManagementQueue(PSDevice pDevice)\r\n{\r\npDevice->rxManeQueue.packet_num = 0;\r\npDevice->rxManeQueue.head = pDevice->rxManeQueue.tail = 0;\r\n}\r\nint MlmeThread(\r\nvoid * Context)\r\n{\r\nPSDevice pDevice = (PSDevice) Context;\r\nPSRxMgmtPacket pRxMgmtPacket;\r\n#if 1\r\nwhile (1)\r\n{\r\n#if 1\r\nspin_lock_irq(&pDevice->lock);\r\nwhile(pDevice->rxManeQueue.packet_num != 0)\r\n{\r\npRxMgmtPacket = DeQueue(pDevice);\r\nvMgrRxManagePacket(pDevice, pDevice->pMgmt, pRxMgmtPacket);\r\n}\r\nspin_unlock_irq(&pDevice->lock);\r\nif (mlme_kill == 0)\r\nbreak;\r\n#endif\r\nschedule();\r\nif (mlme_kill == 0)\r\nbreak;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int device_open(struct net_device *dev) {\r\nPSDevice pDevice=(PSDevice) netdev_priv(dev);\r\nint i;\r\n#ifdef WPA_SM_Transtatus\r\nextern SWPAResult wpa_Result;\r\n#endif\r\npDevice->rx_buf_sz = PKT_BUF_SZ;\r\nif (!device_init_rings(pDevice)) {\r\nreturn -ENOMEM;\r\n}\r\ni=request_irq(pDevice->pcid->irq, &device_intr, IRQF_SHARED, dev->name, dev);\r\nif (i)\r\nreturn i;\r\n#ifdef WPA_SM_Transtatus\r\nmemset(wpa_Result.ifname,0,sizeof(wpa_Result.ifname));\r\nwpa_Result.proto = 0;\r\nwpa_Result.key_mgmt = 0;\r\nwpa_Result.eap_type = 0;\r\nwpa_Result.authenticated = false;\r\npDevice->fWPA_Authened = false;\r\n#endif\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device init rd0 ring\n");\r\ndevice_init_rd0_ring(pDevice);\r\ndevice_init_rd1_ring(pDevice);\r\ndevice_init_defrag_cb(pDevice);\r\ndevice_init_td0_ring(pDevice);\r\ndevice_init_td1_ring(pDevice);\r\nif (pDevice->bDiversityRegCtlON) {\r\ndevice_init_diversity_timer(pDevice);\r\n}\r\nvMgrObjectInit(pDevice);\r\nvMgrTimerInit(pDevice);\r\n#ifdef TASK_LET\r\ntasklet_init (&pDevice->RxMngWorkItem,(void *)MngWorkItem,(unsigned long )pDevice);\r\n#endif\r\n#ifdef THREAD\r\nInitRxManagementQueue(pDevice);\r\nmlme_kill = 0;\r\nmlme_task = kthread_run(MlmeThread,(void *) pDevice, "MLME");\r\nif (IS_ERR(mlme_task)) {\r\nprintk("thread create fail\n");\r\nreturn -1;\r\n}\r\nmlme_kill = 1;\r\n#endif\r\n#if 0\r\npDevice->MLMEThr_pid = kernel_thread(MlmeThread, pDevice, CLONE_VM);\r\nif (pDevice->MLMEThr_pid <0 )\r\n{\r\nprintk("unable start thread MlmeThread\n");\r\nreturn -1;\r\n}\r\n#endif\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call device_init_registers\n");\r\ndevice_init_registers(pDevice, DEVICE_INIT_COLD);\r\nMACvReadEtherAddress(pDevice->PortOffset, pDevice->abyCurrentNetAddr);\r\nmemcpy(pDevice->pMgmt->abyMACAddr, pDevice->abyCurrentNetAddr, ETH_ALEN);\r\ndevice_set_multi(pDevice->dev);\r\nKeyvInitTable(&pDevice->sKey, pDevice->PortOffset);\r\nadd_timer(&(pDevice->pMgmt->sTimerSecondCallback));\r\n#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT\r\npDevice->bwextcount=0;\r\npDevice->bWPASuppWextEnabled = false;\r\n#endif\r\npDevice->byReAssocCount = 0;\r\npDevice->bWPADEVUp = false;\r\nif ((pDevice->bEncryptionEnable == true) && (pDevice->bTransmitKey == true)) {\r\nKeybSetDefaultKey(&(pDevice->sKey),\r\n(unsigned long)(pDevice->byKeyIndex | (1 << 31)),\r\npDevice->uKeyLength,\r\nNULL,\r\npDevice->abyKey,\r\nKEY_CTL_WEP,\r\npDevice->PortOffset,\r\npDevice->byLocalID\r\n);\r\npDevice->eEncryptionStatus = Ndis802_11Encryption1Enabled;\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "call MACvIntEnable\n");\r\nMACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);\r\nif (pDevice->pMgmt->eConfigMode == WMAC_CONFIG_AP) {\r\nbScheduleCommand((void *)pDevice, WLAN_CMD_RUN_AP, NULL);\r\n}\r\nelse {\r\nbScheduleCommand((void *)pDevice, WLAN_CMD_BSSID_SCAN, NULL);\r\nbScheduleCommand((void *)pDevice, WLAN_CMD_SSID, NULL);\r\n}\r\npDevice->flags |=DEVICE_FLAGS_OPENED;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_open success.. \n");\r\nreturn 0;\r\n}\r\nstatic int device_close(struct net_device *dev) {\r\nPSDevice pDevice=(PSDevice) netdev_priv(dev);\r\nPSMgmtObject pMgmt = pDevice->pMgmt;\r\n#ifdef THREAD\r\nmlme_kill = 0;\r\n#endif\r\nif (pDevice->bLinkPass) {\r\nbScheduleCommand((void *)pDevice, WLAN_CMD_DISASSOCIATE, NULL);\r\nmdelay(30);\r\n}\r\n#ifdef TxInSleep\r\ndel_timer(&pDevice->sTimerTxData);\r\n#endif\r\ndel_timer(&pDevice->sTimerCommand);\r\ndel_timer(&pMgmt->sTimerSecondCallback);\r\nif (pDevice->bDiversityRegCtlON) {\r\ndel_timer(&pDevice->TimerSQ3Tmax1);\r\ndel_timer(&pDevice->TimerSQ3Tmax2);\r\ndel_timer(&pDevice->TimerSQ3Tmax3);\r\n}\r\n#ifdef TASK_LET\r\ntasklet_kill(&pDevice->RxMngWorkItem);\r\n#endif\r\nnetif_stop_queue(dev);\r\npDevice->bCmdRunning = false;\r\nMACbShutdown(pDevice->PortOffset);\r\nMACbSoftwareReset(pDevice->PortOffset);\r\nCARDbRadioPowerOff(pDevice);\r\npDevice->bLinkPass = false;\r\nmemset(pMgmt->abyCurrBSSID, 0, 6);\r\npMgmt->eCurrState = WMAC_STATE_IDLE;\r\ndevice_free_td0_ring(pDevice);\r\ndevice_free_td1_ring(pDevice);\r\ndevice_free_rd0_ring(pDevice);\r\ndevice_free_rd1_ring(pDevice);\r\ndevice_free_frag_buf(pDevice);\r\ndevice_free_rings(pDevice);\r\nBSSvClearNodeDBTable(pDevice, 0);\r\nfree_irq(dev->irq, dev);\r\npDevice->flags &=(~DEVICE_FLAGS_OPENED);\r\ndevice_release_WPADEV(pDevice);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_close.. \n");\r\nreturn 0;\r\n}\r\nstatic int device_dma0_tx_80211(struct sk_buff *skb, struct net_device *dev) {\r\nPSDevice pDevice=netdev_priv(dev);\r\nunsigned char *pbMPDU;\r\nunsigned int cbMPDULen = 0;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_tx_80211\n");\r\nspin_lock_irq(&pDevice->lock);\r\nif (AVAIL_TD(pDevice, TYPE_TXDMA0) <= 0) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_tx_80211, td0 <=0\n");\r\ndev_kfree_skb_irq(skb);\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn 0;\r\n}\r\nif (pDevice->bStopTx0Pkt == true) {\r\ndev_kfree_skb_irq(skb);\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn 0;\r\n}\r\ncbMPDULen = skb->len;\r\npbMPDU = skb->data;\r\nvDMA0_tx_80211(pDevice, skb, pbMPDU, cbMPDULen);\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn 0;\r\n}\r\nbool device_dma0_xmit(PSDevice pDevice, struct sk_buff *skb, unsigned int uNodeIndex) {\r\nPSMgmtObject pMgmt = pDevice->pMgmt;\r\nPSTxDesc pHeadTD, pLastTD;\r\nunsigned int cbFrameBodySize;\r\nunsigned int uMACfragNum;\r\nunsigned char byPktType;\r\nbool bNeedEncryption = false;\r\nPSKeyItem pTransmitKey = NULL;\r\nunsigned int cbHeaderSize;\r\nunsigned int ii;\r\nSKeyItem STempKey;\r\nif (pDevice->bStopTx0Pkt == true) {\r\ndev_kfree_skb_irq(skb);\r\nreturn false;\r\n}\r\nif (AVAIL_TD(pDevice, TYPE_TXDMA0) <= 0) {\r\ndev_kfree_skb_irq(skb);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_xmit, td0 <=0\n");\r\nreturn false;\r\n}\r\nif (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {\r\nif (pDevice->uAssocCount == 0) {\r\ndev_kfree_skb_irq(skb);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "device_dma0_xmit, assocCount = 0\n");\r\nreturn false;\r\n}\r\n}\r\npHeadTD = pDevice->apCurrTD[TYPE_TXDMA0];\r\npHeadTD->m_td1TD1.byTCR = (TCR_EDP|TCR_STP);\r\nmemcpy(pDevice->sTxEthHeader.abyDstAddr, (unsigned char *)(skb->data), ETH_HLEN);\r\ncbFrameBodySize = skb->len - ETH_HLEN;\r\nif (ntohs(pDevice->sTxEthHeader.wType) > ETH_DATA_LEN) {\r\ncbFrameBodySize += 8;\r\n}\r\nuMACfragNum = cbGetFragCount(pDevice, pTransmitKey, cbFrameBodySize, &pDevice->sTxEthHeader);\r\nif ( uMACfragNum > AVAIL_TD(pDevice, TYPE_TXDMA0)) {\r\ndev_kfree_skb_irq(skb);\r\nreturn false;\r\n}\r\nbyPktType = (unsigned char)pDevice->byPacketType;\r\nif (pDevice->bFixRate) {\r\nif (pDevice->eCurrentPHYType == PHY_TYPE_11B) {\r\nif (pDevice->uConnectionRate >= RATE_11M) {\r\npDevice->wCurrentRate = RATE_11M;\r\n} else {\r\npDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;\r\n}\r\n} else {\r\nif (pDevice->uConnectionRate >= RATE_54M)\r\npDevice->wCurrentRate = RATE_54M;\r\nelse\r\npDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;\r\n}\r\n}\r\nelse {\r\npDevice->wCurrentRate = pDevice->pMgmt->sNodeDBTable[uNodeIndex].wTxDataRate;\r\n}\r\nif (pMgmt->sNodeDBTable[uNodeIndex].bShortPreamble) {\r\npDevice->byPreambleType = pDevice->byShortPreamble;\r\n}\r\nelse {\r\npDevice->byPreambleType = PREAMBLE_LONG;\r\n}\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dma0: pDevice->wCurrentRate = %d \n", pDevice->wCurrentRate);\r\nif (pDevice->wCurrentRate <= RATE_11M) {\r\nbyPktType = PK_TYPE_11B;\r\n} else if (pDevice->eCurrentPHYType == PHY_TYPE_11A) {\r\nbyPktType = PK_TYPE_11A;\r\n} else {\r\nif (pDevice->bProtectMode == true) {\r\nbyPktType = PK_TYPE_11GB;\r\n} else {\r\nbyPktType = PK_TYPE_11GA;\r\n}\r\n}\r\nif (pDevice->bEncryptionEnable == true)\r\nbNeedEncryption = true;\r\nif (pDevice->bEnableHostWEP) {\r\npTransmitKey = &STempKey;\r\npTransmitKey->byCipherSuite = pMgmt->sNodeDBTable[uNodeIndex].byCipherSuite;\r\npTransmitKey->dwKeyIndex = pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex;\r\npTransmitKey->uKeyLength = pMgmt->sNodeDBTable[uNodeIndex].uWepKeyLength;\r\npTransmitKey->dwTSC47_16 = pMgmt->sNodeDBTable[uNodeIndex].dwTSC47_16;\r\npTransmitKey->wTSC15_0 = pMgmt->sNodeDBTable[uNodeIndex].wTSC15_0;\r\nmemcpy(pTransmitKey->abyKey,\r\n&pMgmt->sNodeDBTable[uNodeIndex].abyWepKey[0],\r\npTransmitKey->uKeyLength\r\n);\r\n}\r\nvGenerateFIFOHeader(pDevice, byPktType, pDevice->pbyTmpBuff, bNeedEncryption,\r\ncbFrameBodySize, TYPE_TXDMA0, pHeadTD,\r\n&pDevice->sTxEthHeader, (unsigned char *)skb->data, pTransmitKey, uNodeIndex,\r\n&uMACfragNum,\r\n&cbHeaderSize\r\n);\r\nif (MACbIsRegBitsOn(pDevice->PortOffset, MAC_REG_PSCTL, PSCTL_PS)) {\r\nMACbPSWakeup(pDevice->PortOffset);\r\n}\r\npDevice->bPWBitOn = false;\r\npLastTD = pHeadTD;\r\nfor (ii = 0; ii < uMACfragNum; ii++) {\r\nwmb();\r\npHeadTD->m_td0TD0.f1Owner=OWNED_BY_NIC;\r\nwmb();\r\nif (ii == (uMACfragNum - 1))\r\npLastTD = pHeadTD;\r\npHeadTD = pHeadTD->next;\r\n}\r\npLastTD->pTDInfo->skb = skb;\r\npLastTD->pTDInfo->byFlags = 0;\r\npLastTD->pTDInfo->byFlags |= TD_FLAGS_NETIF_SKB;\r\npDevice->apCurrTD[TYPE_TXDMA0] = pHeadTD;\r\nMACvTransmit0(pDevice->PortOffset);\r\nreturn true;\r\n}\r\nstatic int device_xmit(struct sk_buff *skb, struct net_device *dev) {\r\nPSDevice pDevice=netdev_priv(dev);\r\nPSMgmtObject pMgmt = pDevice->pMgmt;\r\nPSTxDesc pHeadTD, pLastTD;\r\nunsigned int uNodeIndex = 0;\r\nunsigned char byMask[8] = {1, 2, 4, 8, 0x10, 0x20, 0x40, 0x80};\r\nunsigned short wAID;\r\nunsigned int uMACfragNum = 1;\r\nunsigned int cbFrameBodySize;\r\nunsigned char byPktType;\r\nunsigned int cbHeaderSize;\r\nbool bNeedEncryption = false;\r\nPSKeyItem pTransmitKey = NULL;\r\nSKeyItem STempKey;\r\nunsigned int ii;\r\nbool bTKIP_UseGTK = false;\r\nbool bNeedDeAuth = false;\r\nunsigned char *pbyBSSID;\r\nbool bNodeExist = false;\r\nspin_lock_irq(&pDevice->lock);\r\nif (pDevice->bLinkPass == false) {\r\ndev_kfree_skb_irq(skb);\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn 0;\r\n}\r\nif (pDevice->bStopDataPkt) {\r\ndev_kfree_skb_irq(skb);\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn 0;\r\n}\r\nif (pMgmt->eCurrMode == WMAC_MODE_ESS_AP) {\r\nif (pDevice->uAssocCount == 0) {\r\ndev_kfree_skb_irq(skb);\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn 0;\r\n}\r\nif (is_multicast_ether_addr((unsigned char *)(skb->data))) {\r\nuNodeIndex = 0;\r\nbNodeExist = true;\r\nif (pMgmt->sNodeDBTable[0].bPSEnable) {\r\nskb_queue_tail(&(pMgmt->sNodeDBTable[0].sTxPSQueue), skb);\r\npMgmt->sNodeDBTable[0].wEnQueueCnt++;\r\npMgmt->abyPSTxMap[0] |= byMask[0];\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn 0;\r\n}\r\n}else {\r\nif (BSSDBbIsSTAInNodeDB(pMgmt, (unsigned char *)(skb->data), &uNodeIndex)) {\r\nif (pMgmt->sNodeDBTable[uNodeIndex].bPSEnable) {\r\nskb_queue_tail(&pMgmt->sNodeDBTable[uNodeIndex].sTxPSQueue, skb);\r\npMgmt->sNodeDBTable[uNodeIndex].wEnQueueCnt++;\r\nwAID = pMgmt->sNodeDBTable[uNodeIndex].wAID;\r\npMgmt->abyPSTxMap[wAID >> 3] |= byMask[wAID & 7];\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Set:pMgmt->abyPSTxMap[%d]= %d\n",\r\n(wAID >> 3), pMgmt->abyPSTxMap[wAID >> 3]);\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn 0;\r\n}\r\nif (pMgmt->sNodeDBTable[uNodeIndex].bShortPreamble) {\r\npDevice->byPreambleType = pDevice->byShortPreamble;\r\n}else {\r\npDevice->byPreambleType = PREAMBLE_LONG;\r\n}\r\nbNodeExist = true;\r\n}\r\n}\r\nif (bNodeExist == false) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Unknown STA not found in node DB \n");\r\ndev_kfree_skb_irq(skb);\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn 0;\r\n}\r\n}\r\npHeadTD = pDevice->apCurrTD[TYPE_AC0DMA];\r\npHeadTD->m_td1TD1.byTCR = (TCR_EDP|TCR_STP);\r\nmemcpy(pDevice->sTxEthHeader.abyDstAddr, (unsigned char *)(skb->data), ETH_HLEN);\r\ncbFrameBodySize = skb->len - ETH_HLEN;\r\nif (ntohs(pDevice->sTxEthHeader.wType) > ETH_DATA_LEN) {\r\ncbFrameBodySize += 8;\r\n}\r\nif (pDevice->bEncryptionEnable == true) {\r\nbNeedEncryption = true;\r\ndo {\r\nif ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) &&\r\n(pDevice->pMgmt->eCurrState == WMAC_STATE_ASSOC)) {\r\npbyBSSID = pDevice->abyBSSID;\r\nif (KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, PAIRWISE_KEY, &pTransmitKey) == false) {\r\nif(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == true) {\r\nbTKIP_UseGTK = true;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get GTK.\n");\r\nbreak;\r\n}\r\n} else {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get PTK.\n");\r\nbreak;\r\n}\r\n}else if (pDevice->pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {\r\npbyBSSID = pDevice->sTxEthHeader.abyDstAddr;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"IBSS Serach Key: \n");\r\nfor (ii = 0; ii< 6; ii++)\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"%x \n", *(pbyBSSID+ii));\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"\n");\r\nif(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, PAIRWISE_KEY, &pTransmitKey) == true)\r\nbreak;\r\n}\r\npbyBSSID = pDevice->abyBroadcastAddr;\r\nif(KeybGetTransmitKey(&(pDevice->sKey), pbyBSSID, GROUP_KEY, &pTransmitKey) == false) {\r\npTransmitKey = NULL;\r\nif (pDevice->pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"IBSS and KEY is NULL. [%d]\n", pDevice->pMgmt->eCurrMode);\r\n}\r\nelse\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"NOT IBSS and KEY is NULL. [%d]\n", pDevice->pMgmt->eCurrMode);\r\n} else {\r\nbTKIP_UseGTK = true;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"Get GTK.\n");\r\n}\r\n} while(false);\r\n}\r\nif (pDevice->bEnableHostWEP) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_DEBUG"acdma0: STA index %d\n", uNodeIndex);\r\nif (pDevice->bEncryptionEnable == true) {\r\npTransmitKey = &STempKey;\r\npTransmitKey->byCipherSuite = pMgmt->sNodeDBTable[uNodeIndex].byCipherSuite;\r\npTransmitKey->dwKeyIndex = pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex;\r\npTransmitKey->uKeyLength = pMgmt->sNodeDBTable[uNodeIndex].uWepKeyLength;\r\npTransmitKey->dwTSC47_16 = pMgmt->sNodeDBTable[uNodeIndex].dwTSC47_16;\r\npTransmitKey->wTSC15_0 = pMgmt->sNodeDBTable[uNodeIndex].wTSC15_0;\r\nmemcpy(pTransmitKey->abyKey,\r\n&pMgmt->sNodeDBTable[uNodeIndex].abyWepKey[0],\r\npTransmitKey->uKeyLength\r\n);\r\n}\r\n}\r\nuMACfragNum = cbGetFragCount(pDevice, pTransmitKey, cbFrameBodySize, &pDevice->sTxEthHeader);\r\nif (uMACfragNum > AVAIL_TD(pDevice, TYPE_AC0DMA)) {\r\nDBG_PRT(MSG_LEVEL_ERR, KERN_DEBUG "uMACfragNum > AVAIL_TD(TYPE_AC0DMA) = %d\n", uMACfragNum);\r\ndev_kfree_skb_irq(skb);\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn 0;\r\n}\r\nif (pTransmitKey != NULL) {\r\nif ((pTransmitKey->byCipherSuite == KEY_CTL_WEP) &&\r\n(pTransmitKey->uKeyLength == WLAN_WEP232_KEYLEN)) {\r\nuMACfragNum = 1;\r\n}\r\n}\r\nbyPktType = (unsigned char)pDevice->byPacketType;\r\nif (pDevice->bFixRate) {\r\n#ifdef PLICE_DEBUG\r\nprintk("Fix Rate: PhyType is %d,ConnectionRate is %d\n",pDevice->eCurrentPHYType,pDevice->uConnectionRate);\r\n#endif\r\nif (pDevice->eCurrentPHYType == PHY_TYPE_11B) {\r\nif (pDevice->uConnectionRate >= RATE_11M) {\r\npDevice->wCurrentRate = RATE_11M;\r\n} else {\r\npDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;\r\n}\r\n} else {\r\nif ((pDevice->eCurrentPHYType == PHY_TYPE_11A) &&\r\n(pDevice->uConnectionRate <= RATE_6M)) {\r\npDevice->wCurrentRate = RATE_6M;\r\n} else {\r\nif (pDevice->uConnectionRate >= RATE_54M)\r\npDevice->wCurrentRate = RATE_54M;\r\nelse\r\npDevice->wCurrentRate = (unsigned short)pDevice->uConnectionRate;\r\n}\r\n}\r\npDevice->byACKRate = (unsigned char) pDevice->wCurrentRate;\r\npDevice->byTopCCKBasicRate = RATE_1M;\r\npDevice->byTopOFDMBasicRate = RATE_6M;\r\n}\r\nelse {\r\nif (pDevice->sTxEthHeader.wType == TYPE_PKT_802_1x) {\r\nif (pDevice->eCurrentPHYType != PHY_TYPE_11A) {\r\npDevice->wCurrentRate = RATE_1M;\r\npDevice->byACKRate = RATE_1M;\r\npDevice->byTopCCKBasicRate = RATE_1M;\r\npDevice->byTopOFDMBasicRate = RATE_6M;\r\n} else {\r\npDevice->wCurrentRate = RATE_6M;\r\npDevice->byACKRate = RATE_6M;\r\npDevice->byTopCCKBasicRate = RATE_1M;\r\npDevice->byTopOFDMBasicRate = RATE_6M;\r\n}\r\n}\r\nelse {\r\nVNTWIFIvGetTxRate( pDevice->pMgmt,\r\npDevice->sTxEthHeader.abyDstAddr,\r\n&(pDevice->wCurrentRate),\r\n&(pDevice->byACKRate),\r\n&(pDevice->byTopCCKBasicRate),\r\n&(pDevice->byTopOFDMBasicRate));\r\n#if 0\r\nprintk("auto rate:Rate : %d,AckRate:%d,TopCCKRate:%d,TopOFDMRate:%d\n",\r\npDevice->wCurrentRate,pDevice->byACKRate,\r\npDevice->byTopCCKBasicRate,pDevice->byTopOFDMBasicRate);\r\n#endif\r\n#if 0\r\npDevice->wCurrentRate = 11;\r\npDevice->byACKRate = 8;\r\npDevice->byTopCCKBasicRate = 3;\r\npDevice->byTopOFDMBasicRate = 8;\r\n#endif\r\n}\r\n}\r\nif (pDevice->wCurrentRate <= RATE_11M) {\r\nbyPktType = PK_TYPE_11B;\r\n} else if (pDevice->eCurrentPHYType == PHY_TYPE_11A) {\r\nbyPktType = PK_TYPE_11A;\r\n} else {\r\nif (pDevice->bProtectMode == true) {\r\nbyPktType = PK_TYPE_11GB;\r\n} else {\r\nbyPktType = PK_TYPE_11GA;\r\n}\r\n}\r\nif (bNeedEncryption == true) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ntohs Pkt Type=%04x\n", ntohs(pDevice->sTxEthHeader.wType));\r\nif ((pDevice->sTxEthHeader.wType) == TYPE_PKT_802_1x) {\r\nbNeedEncryption = false;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Pkt Type=%04x\n", (pDevice->sTxEthHeader.wType));\r\nif ((pDevice->pMgmt->eCurrMode == WMAC_MODE_ESS_STA) && (pDevice->pMgmt->eCurrState == WMAC_STATE_ASSOC)) {\r\nif (pTransmitKey == NULL) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Don't Find TX KEY\n");\r\n}\r\nelse {\r\nif (bTKIP_UseGTK == true) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"error: KEY is GTK!!~~\n");\r\n}\r\nelse {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Find PTK [%lX]\n", pTransmitKey->dwKeyIndex);\r\nbNeedEncryption = true;\r\n}\r\n}\r\n}\r\nif (pDevice->byCntMeasure == 2) {\r\nbNeedDeAuth = true;\r\npDevice->s802_11Counter.TKIPCounterMeasuresInvoked++;\r\n}\r\nif (pDevice->bEnableHostWEP) {\r\nif ((uNodeIndex != 0) &&\r\n(pMgmt->sNodeDBTable[uNodeIndex].dwKeyIndex & PAIRWISE_KEY)) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Find PTK [%lX]\n", pTransmitKey->dwKeyIndex);\r\nbNeedEncryption = true;\r\n}\r\n}\r\n}\r\nelse {\r\nif (pTransmitKey == NULL) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"return no tx key\n");\r\ndev_kfree_skb_irq(skb);\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn 0;\r\n}\r\n}\r\n}\r\n#ifdef PLICE_DEBUG\r\n#endif\r\nvGenerateFIFOHeader(pDevice, byPktType, pDevice->pbyTmpBuff, bNeedEncryption,\r\ncbFrameBodySize, TYPE_AC0DMA, pHeadTD,\r\n&pDevice->sTxEthHeader, (unsigned char *)skb->data, pTransmitKey, uNodeIndex,\r\n&uMACfragNum,\r\n&cbHeaderSize\r\n);\r\nif (MACbIsRegBitsOn(pDevice->PortOffset, MAC_REG_PSCTL, PSCTL_PS)) {\r\nMACbPSWakeup(pDevice->PortOffset);\r\n}\r\npDevice->bPWBitOn = false;\r\npLastTD = pHeadTD;\r\nfor (ii = 0; ii < uMACfragNum; ii++) {\r\nwmb();\r\npHeadTD->m_td0TD0.f1Owner=OWNED_BY_NIC;\r\nwmb();\r\nif (ii == uMACfragNum - 1)\r\npLastTD = pHeadTD;\r\npHeadTD = pHeadTD->next;\r\n}\r\npLastTD->pTDInfo->skb = skb;\r\npLastTD->pTDInfo->byFlags = 0;\r\npLastTD->pTDInfo->byFlags |= TD_FLAGS_NETIF_SKB;\r\n#ifdef TxInSleep\r\npDevice->nTxDataTimeCout=0;\r\n#endif\r\nif (AVAIL_TD(pDevice, TYPE_AC0DMA) <= 1) {\r\nnetif_stop_queue(dev);\r\n}\r\npDevice->apCurrTD[TYPE_AC0DMA] = pHeadTD;\r\nif (pDevice->bFixRate)\r\n{\r\nprintk("FixRate:Rate is %d,TxPower is %d\n",pDevice->wCurrentRate,pDevice->byCurPwr);\r\n}\r\nelse\r\n{\r\n}\r\n{\r\nunsigned char Protocol_Version;\r\nunsigned char Packet_Type;\r\nunsigned char Descriptor_type;\r\nunsigned short Key_info;\r\nbool bTxeapol_key = false;\r\nProtocol_Version = skb->data[ETH_HLEN];\r\nPacket_Type = skb->data[ETH_HLEN+1];\r\nDescriptor_type = skb->data[ETH_HLEN+1+1+2];\r\nKey_info = (skb->data[ETH_HLEN+1+1+2+1] << 8)|(skb->data[ETH_HLEN+1+1+2+2]);\r\nif (pDevice->sTxEthHeader.wType == TYPE_PKT_802_1x) {\r\nif(((Protocol_Version==1) ||(Protocol_Version==2)) &&\r\n(Packet_Type==3)) {\r\nbTxeapol_key = true;\r\nif((Descriptor_type==254)||(Descriptor_type==2)) {\r\nif(!(Key_info & BIT3) &&\r\n(Key_info & BIT8) && (Key_info & BIT9)) {\r\npDevice->fWPA_Authened = true;\r\nif(Descriptor_type==254)\r\nprintk("WPA ");\r\nelse\r\nprintk("WPA2 ");\r\nprintk("Authentication completed!!\n");\r\n}\r\n}\r\n}\r\n}\r\n}\r\nMACvTransmitAC0(pDevice->PortOffset);\r\ndev->trans_start = jiffies;\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t device_intr(int irq, void *dev_instance) {\r\nstruct net_device* dev=dev_instance;\r\nPSDevice pDevice=(PSDevice) netdev_priv(dev);\r\nint max_count=0;\r\nunsigned long dwMIBCounter=0;\r\nPSMgmtObject pMgmt = pDevice->pMgmt;\r\nunsigned char byOrgPageSel=0;\r\nint handled = 0;\r\nunsigned char byData = 0;\r\nint ii= 0;\r\nMACvReadISR(pDevice->PortOffset, &pDevice->dwIsr);\r\nif (pDevice->dwIsr == 0)\r\nreturn IRQ_RETVAL(handled);\r\nif (pDevice->dwIsr == 0xffffffff) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "dwIsr = 0xffff\n");\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nhandled = 1;\r\nMACvIntDisable(pDevice->PortOffset);\r\nspin_lock_irq(&pDevice->lock);\r\nVNSvInPortB(pDevice->PortOffset + MAC_REG_PAGE1SEL, &byOrgPageSel);\r\nif (byOrgPageSel == 1) {\r\nMACvSelectPage0(pDevice->PortOffset);\r\n}\r\nelse\r\nbyOrgPageSel = 0;\r\nMACvReadMIBCounter(pDevice->PortOffset, &dwMIBCounter);\r\nSTAvUpdate802_11Counter(&pDevice->s802_11Counter, &pDevice->scStatistic , dwMIBCounter);\r\nwhile (pDevice->dwIsr != 0) {\r\nSTAvUpdateIsrStatCounter(&pDevice->scStatistic, pDevice->dwIsr);\r\nMACvWriteISR(pDevice->PortOffset, pDevice->dwIsr);\r\nif (pDevice->dwIsr & ISR_FETALERR){\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " ISR_FETALERR \n");\r\nVNSvOutPortB(pDevice->PortOffset + MAC_REG_SOFTPWRCTL, 0);\r\nVNSvOutPortW(pDevice->PortOffset + MAC_REG_SOFTPWRCTL, SOFTPWRCTL_SWPECTI);\r\ndevice_error(pDevice, pDevice->dwIsr);\r\n}\r\nif (pDevice->byLocalID > REV_ID_VT3253_B1) {\r\nif (pDevice->dwIsr & ISR_MEASURESTART) {\r\npDevice->byOrgChannel = pDevice->byCurrentCh;\r\nVNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byOrgRCR));\r\nVNSvOutPortB(pDevice->PortOffset + MAC_REG_RCR, (RCR_RXALLTYPE | RCR_UNICAST | RCR_BROADCAST | RCR_MULTICAST | RCR_WPAERR));\r\nMACvSelectPage1(pDevice->PortOffset);\r\nVNSvInPortD(pDevice->PortOffset + MAC_REG_MAR0, &(pDevice->dwOrgMAR0));\r\nVNSvInPortD(pDevice->PortOffset + MAC_REG_MAR4, &(pDevice->dwOrgMAR4));\r\nMACvSelectPage0(pDevice->PortOffset);\r\nif (set_channel(pDevice, pDevice->pCurrMeasureEID->sReq.byChannel) == true) {\r\npDevice->bMeasureInProgress = true;\r\nMACvSelectPage1(pDevice->PortOffset);\r\nMACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL, MSRCTL_READY);\r\nMACvSelectPage0(pDevice->PortOffset);\r\npDevice->byBasicMap = 0;\r\npDevice->byCCAFraction = 0;\r\nfor(ii=0;ii<8;ii++) {\r\npDevice->dwRPIs[ii] = 0;\r\n}\r\n} else {\r\nMACvRegBitsOff(pDevice->PortOffset, MAC_REG_MSRCTL, MSRCTL_EN);\r\ns_vCompleteCurrentMeasure(pDevice, MEASURE_MODE_INCAPABLE);\r\nMACvSelectPage1(pDevice->PortOffset);\r\nMACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);\r\nMACvSelectPage0(pDevice->PortOffset);\r\n}\r\n}\r\nif (pDevice->dwIsr & ISR_MEASUREEND) {\r\npDevice->bMeasureInProgress = false;\r\nVNSvOutPortB(pDevice->PortOffset + MAC_REG_RCR, pDevice->byOrgRCR);\r\nMACvSelectPage1(pDevice->PortOffset);\r\nVNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0, pDevice->dwOrgMAR0);\r\nVNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR4, pDevice->dwOrgMAR4);\r\nVNSvInPortB(pDevice->PortOffset + MAC_REG_MSRBBSTS, &byData);\r\npDevice->byBasicMap |= (byData >> 4);\r\nVNSvInPortB(pDevice->PortOffset + MAC_REG_CCAFRACTION, &pDevice->byCCAFraction);\r\nVNSvInPortB(pDevice->PortOffset + MAC_REG_MSRCTL, &byData);\r\nMACvRegBitsOff(pDevice->PortOffset, MAC_REG_MSRCTL, MSRCTL_EN);\r\nMACvSelectPage0(pDevice->PortOffset);\r\nset_channel(pDevice, pDevice->byOrgChannel);\r\nMACvSelectPage1(pDevice->PortOffset);\r\nMACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);\r\nMACvSelectPage0(pDevice->PortOffset);\r\nif (byData & MSRCTL_FINISH) {\r\ns_vCompleteCurrentMeasure(pDevice, 0);\r\n} else {\r\ns_vCompleteCurrentMeasure(pDevice, MEASURE_MODE_LATE);\r\n}\r\n}\r\nif (pDevice->dwIsr & ISR_QUIETSTART) {\r\ndo {\r\n;\r\n} while (CARDbStartQuiet(pDevice) == false);\r\n}\r\n}\r\nif (pDevice->dwIsr & ISR_TBTT) {\r\nif (pDevice->bEnableFirstQuiet == true) {\r\npDevice->byQuietStartCount--;\r\nif (pDevice->byQuietStartCount == 0) {\r\npDevice->bEnableFirstQuiet = false;\r\nMACvSelectPage1(pDevice->PortOffset);\r\nMACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL, (MSRCTL_QUIETTXCHK | MSRCTL_QUIETEN));\r\nMACvSelectPage0(pDevice->PortOffset);\r\n}\r\n}\r\nif ((pDevice->bChannelSwitch == true) &&\r\n(pDevice->eOPMode == OP_MODE_INFRASTRUCTURE)) {\r\npDevice->byChannelSwitchCount--;\r\nif (pDevice->byChannelSwitchCount == 0) {\r\npDevice->bChannelSwitch = false;\r\nset_channel(pDevice, pDevice->byNewChannel);\r\nVNTWIFIbChannelSwitch(pDevice->pMgmt, pDevice->byNewChannel);\r\nMACvSelectPage1(pDevice->PortOffset);\r\nMACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);\r\nMACvSelectPage0(pDevice->PortOffset);\r\nCARDbStartTxPacket(pDevice, PKT_TYPE_802_11_ALL);\r\n}\r\n}\r\nif (pDevice->eOPMode == OP_MODE_ADHOC) {\r\n} else {\r\nif ((pDevice->bUpdateBBVGA) && (pDevice->bLinkPass == true) && (pDevice->uCurrRSSI != 0)) {\r\nlong ldBm;\r\nRFvRSSITodBm(pDevice, (unsigned char) pDevice->uCurrRSSI, &ldBm);\r\nfor (ii=0;ii<BB_VGA_LEVEL;ii++) {\r\nif (ldBm < pDevice->ldBmThreshold[ii]) {\r\npDevice->byBBVGANew = pDevice->abyBBVGA[ii];\r\nbreak;\r\n}\r\n}\r\nif (pDevice->byBBVGANew != pDevice->byBBVGACurrent) {\r\npDevice->uBBVGADiffCount++;\r\nif (pDevice->uBBVGADiffCount == 1) {\r\nBBvSetVGAGainOffset(pDevice, pDevice->byBBVGANew);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"First RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",\r\n(int)ldBm, pDevice->byBBVGANew, pDevice->byBBVGACurrent, (int)pDevice->uBBVGADiffCount);\r\n}\r\nif (pDevice->uBBVGADiffCount >= BB_VGA_CHANGE_THRESHOLD) {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"RSSI[%d] NewGain[%d] OldGain[%d] Count[%d]\n",\r\n(int)ldBm, pDevice->byBBVGANew, pDevice->byBBVGACurrent, (int)pDevice->uBBVGADiffCount);\r\nBBvSetVGAGainOffset(pDevice, pDevice->byBBVGANew);\r\n}\r\n} else {\r\npDevice->uBBVGADiffCount = 1;\r\n}\r\n}\r\n}\r\npDevice->bBeaconSent = false;\r\nif (pDevice->bEnablePSMode) {\r\nPSbIsNextTBTTWakeUp((void *)pDevice);\r\n}\r\nif ((pDevice->eOPMode == OP_MODE_AP) ||\r\n(pDevice->eOPMode == OP_MODE_ADHOC)) {\r\nMACvOneShotTimer1MicroSec(pDevice->PortOffset,\r\n(pMgmt->wIBSSBeaconPeriod - MAKE_BEACON_RESERVED) << 10);\r\n}\r\nif (pDevice->eOPMode == OP_MODE_ADHOC && pDevice->pMgmt->wCurrATIMWindow > 0) {\r\n}\r\n}\r\nif (pDevice->dwIsr & ISR_BNTX) {\r\nif (pDevice->eOPMode == OP_MODE_ADHOC) {\r\npDevice->bIsBeaconBufReadySet = false;\r\npDevice->cbBeaconBufReadySetCnt = 0;\r\n}\r\nif (pDevice->eOPMode == OP_MODE_AP) {\r\nif(pMgmt->byDTIMCount > 0) {\r\npMgmt->byDTIMCount --;\r\npMgmt->sNodeDBTable[0].bRxPSPoll = false;\r\n}\r\nelse {\r\nif(pMgmt->byDTIMCount == 0) {\r\npMgmt->byDTIMCount = pMgmt->byDTIMPeriod - 1;\r\npMgmt->sNodeDBTable[0].bRxPSPoll = true;\r\nbScheduleCommand((void *)pDevice, WLAN_CMD_RX_PSPOLL, NULL);\r\n}\r\n}\r\n}\r\npDevice->bBeaconSent = true;\r\nif (pDevice->bChannelSwitch == true) {\r\npDevice->byChannelSwitchCount--;\r\nif (pDevice->byChannelSwitchCount == 0) {\r\npDevice->bChannelSwitch = false;\r\nset_channel(pDevice, pDevice->byNewChannel);\r\nVNTWIFIbChannelSwitch(pDevice->pMgmt, pDevice->byNewChannel);\r\nMACvSelectPage1(pDevice->PortOffset);\r\nMACvRegBitsOn(pDevice->PortOffset, MAC_REG_MSRCTL+1, MSRCTL1_TXPAUSE);\r\nMACvSelectPage0(pDevice->PortOffset);\r\nCARDbStartTxPacket(pDevice, PKT_TYPE_802_11_ALL);\r\n}\r\n}\r\n}\r\nif (pDevice->dwIsr & ISR_RXDMA0) {\r\nmax_count += device_rx_srv(pDevice, TYPE_RXDMA0);\r\n}\r\nif (pDevice->dwIsr & ISR_RXDMA1) {\r\nmax_count += device_rx_srv(pDevice, TYPE_RXDMA1);\r\n}\r\nif (pDevice->dwIsr & ISR_TXDMA0){\r\nmax_count += device_tx_srv(pDevice, TYPE_TXDMA0);\r\n}\r\nif (pDevice->dwIsr & ISR_AC0DMA){\r\nmax_count += device_tx_srv(pDevice, TYPE_AC0DMA);\r\n}\r\nif (pDevice->dwIsr & ISR_SOFTTIMER) {\r\n}\r\nif (pDevice->dwIsr & ISR_SOFTTIMER1) {\r\nif (pDevice->eOPMode == OP_MODE_AP) {\r\nif (pDevice->bShortSlotTime)\r\npMgmt->wCurrCapInfo |= WLAN_SET_CAP_INFO_SHORTSLOTTIME(1);\r\nelse\r\npMgmt->wCurrCapInfo &= ~(WLAN_SET_CAP_INFO_SHORTSLOTTIME(1));\r\n}\r\nbMgrPrepareBeaconToSend(pDevice, pMgmt);\r\npDevice->byCntMeasure = 0;\r\n}\r\nMACvReadISR(pDevice->PortOffset, &pDevice->dwIsr);\r\nMACvReceive0(pDevice->PortOffset);\r\nMACvReceive1(pDevice->PortOffset);\r\nif (max_count>pDevice->sOpts.int_works)\r\nbreak;\r\n}\r\nif (byOrgPageSel == 1) {\r\nMACvSelectPage1(pDevice->PortOffset);\r\n}\r\nspin_unlock_irq(&pDevice->lock);\r\nMACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic inline u32 ether_crc(int length, unsigned char *data)\r\n{\r\nint crc = -1;\r\nwhile(--length >= 0) {\r\nunsigned char current_octet = *data++;\r\nint bit;\r\nfor (bit = 0; bit < 8; bit++, current_octet >>= 1) {\r\ncrc = (crc << 1) ^\r\n((crc < 0) ^ (current_octet & 1) ? ethernet_polynomial : 0);\r\n}\r\n}\r\nreturn crc;\r\n}\r\nstatic int Config_FileGetParameter(unsigned char *string,\r\nunsigned char *dest, unsigned char *source)\r\n{\r\nunsigned char buf1[100];\r\nint source_len = strlen(source);\r\nmemset(buf1,0,100);\r\nstrcat(buf1, string);\r\nstrcat(buf1, "=");\r\nsource+=strlen(buf1);\r\nmemcpy(dest,source,source_len-strlen(buf1));\r\nreturn true;\r\n}\r\nint Config_FileOperation(PSDevice pDevice,bool fwrite,unsigned char *Parameter) {\r\nunsigned char *config_path = CONFIG_PATH;\r\nunsigned char *buffer = NULL;\r\nunsigned char tmpbuffer[20];\r\nstruct file *filp=NULL;\r\nmm_segment_t old_fs = get_fs();\r\nint result=0;\r\nset_fs (KERNEL_DS);\r\nfilp = filp_open(config_path, O_RDWR, 0);\r\nif (IS_ERR(filp)) {\r\nprintk("Config_FileOperation:open file fail?\n");\r\nresult=-1;\r\ngoto error2;\r\n}\r\nif(!(filp->f_op) || !(filp->f_op->read) ||!(filp->f_op->write)) {\r\nprintk("file %s cann't readable or writable?\n",config_path);\r\nresult = -1;\r\ngoto error1;\r\n}\r\nbuffer = kmalloc(1024, GFP_KERNEL);\r\nif(buffer==NULL) {\r\nprintk("allocate mem for file fail?\n");\r\nresult = -1;\r\ngoto error1;\r\n}\r\nif(filp->f_op->read(filp, buffer, 1024, &filp->f_pos)<0) {\r\nprintk("read file error?\n");\r\nresult = -1;\r\ngoto error1;\r\n}\r\nif(Config_FileGetParameter("ZONETYPE",tmpbuffer,buffer)!=true) {\r\nprintk("get parameter error?\n");\r\nresult = -1;\r\ngoto error1;\r\n}\r\nif(memcmp(tmpbuffer,"USA",3)==0) {\r\nresult=ZoneType_USA;\r\n}\r\nelse if(memcmp(tmpbuffer,"JAPAN",5)==0) {\r\nresult=ZoneType_Japan;\r\n}\r\nelse if(memcmp(tmpbuffer,"EUROPE",5)==0) {\r\nresult=ZoneType_Europe;\r\n}\r\nelse {\r\nresult = -1;\r\nprintk("Unknown Zonetype[%s]?\n",tmpbuffer);\r\n}\r\nerror1:\r\nkfree(buffer);\r\nif(filp_close(filp,NULL))\r\nprintk("Config_FileOperation:close file fail\n");\r\nerror2:\r\nset_fs (old_fs);\r\nreturn result;\r\n}\r\nstatic void device_set_multi(struct net_device *dev) {\r\nPSDevice pDevice = (PSDevice) netdev_priv(dev);\r\nPSMgmtObject pMgmt = pDevice->pMgmt;\r\nu32 mc_filter[2];\r\nstruct netdev_hw_addr *ha;\r\nVNSvInPortB(pDevice->PortOffset + MAC_REG_RCR, &(pDevice->byRxMode));\r\nif (dev->flags & IFF_PROMISC) {\r\nDBG_PRT(MSG_LEVEL_ERR,KERN_NOTICE "%s: Promiscuous mode enabled.\n", dev->name);\r\npDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST|RCR_UNICAST);\r\n}\r\nelse if ((netdev_mc_count(dev) > pDevice->multicast_limit)\r\n|| (dev->flags & IFF_ALLMULTI)) {\r\nMACvSelectPage1(pDevice->PortOffset);\r\nVNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0, 0xffffffff);\r\nVNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0 + 4, 0xffffffff);\r\nMACvSelectPage0(pDevice->PortOffset);\r\npDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);\r\n}\r\nelse {\r\nmemset(mc_filter, 0, sizeof(mc_filter));\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;\r\nmc_filter[bit_nr >> 5] |= cpu_to_le32(1 << (bit_nr & 31));\r\n}\r\nMACvSelectPage1(pDevice->PortOffset);\r\nVNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0, mc_filter[0]);\r\nVNSvOutPortD(pDevice->PortOffset + MAC_REG_MAR0 + 4, mc_filter[1]);\r\nMACvSelectPage0(pDevice->PortOffset);\r\npDevice->byRxMode &= ~(RCR_UNICAST);\r\npDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);\r\n}\r\nif (pMgmt->eConfigMode == WMAC_CONFIG_AP) {\r\npDevice->byRxMode |= (RCR_MULTICAST|RCR_BROADCAST);\r\npDevice->byRxMode &= ~(RCR_UNICAST);\r\n}\r\nVNSvOutPortB(pDevice->PortOffset + MAC_REG_RCR, pDevice->byRxMode);\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "pDevice->byRxMode = %x\n", pDevice->byRxMode );\r\n}\r\nstatic struct net_device_stats *device_get_stats(struct net_device *dev) {\r\nPSDevice pDevice=(PSDevice) netdev_priv(dev);\r\nreturn &pDevice->stats;\r\n}\r\nstatic int device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {\r\nPSDevice pDevice = (PSDevice)netdev_priv(dev);\r\nstruct iwreq *wrq = (struct iwreq *) rq;\r\nint rc =0;\r\nPSMgmtObject pMgmt = pDevice->pMgmt;\r\nPSCmdRequest pReq;\r\nif (pMgmt == NULL) {\r\nrc = -EFAULT;\r\nreturn rc;\r\n}\r\nswitch(cmd) {\r\ncase SIOCGIWNAME:\r\nrc = iwctl_giwname(dev, NULL, (char *)&(wrq->u.name), NULL);\r\nbreak;\r\ncase SIOCGIWNWID:\r\nrc = -EOPNOTSUPP;\r\nbreak;\r\ncase SIOCSIWFREQ:\r\nrc = iwctl_siwfreq(dev, NULL, &(wrq->u.freq), NULL);\r\nbreak;\r\ncase SIOCGIWFREQ:\r\nrc = iwctl_giwfreq(dev, NULL, &(wrq->u.freq), NULL);\r\nbreak;\r\ncase SIOCSIWESSID:\r\n{\r\nchar essid[IW_ESSID_MAX_SIZE+1];\r\nif (wrq->u.essid.length > IW_ESSID_MAX_SIZE) {\r\nrc = -E2BIG;\r\nbreak;\r\n}\r\nif (copy_from_user(essid, wrq->u.essid.pointer,\r\nwrq->u.essid.length)) {\r\nrc = -EFAULT;\r\nbreak;\r\n}\r\nrc = iwctl_siwessid(dev, NULL,\r\n&(wrq->u.essid), essid);\r\n}\r\nbreak;\r\ncase SIOCGIWESSID:\r\n{\r\nchar essid[IW_ESSID_MAX_SIZE+1];\r\nif (wrq->u.essid.pointer)\r\nrc = iwctl_giwessid(dev, NULL,\r\n&(wrq->u.essid), essid);\r\nif (copy_to_user(wrq->u.essid.pointer,\r\nessid,\r\nwrq->u.essid.length) )\r\nrc = -EFAULT;\r\n}\r\nbreak;\r\ncase SIOCSIWAP:\r\nrc = iwctl_siwap(dev, NULL, &(wrq->u.ap_addr), NULL);\r\nbreak;\r\ncase SIOCGIWAP:\r\nrc = iwctl_giwap(dev, NULL, &(wrq->u.ap_addr), NULL);\r\nbreak;\r\ncase SIOCSIWNICKN:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWNICKN \n");\r\nrc = -EOPNOTSUPP;\r\nbreak;\r\ncase SIOCGIWNICKN:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWNICKN \n");\r\nrc = -EOPNOTSUPP;\r\nbreak;\r\ncase SIOCSIWRATE:\r\nrc = iwctl_siwrate(dev, NULL, &(wrq->u.bitrate), NULL);\r\nbreak;\r\ncase SIOCGIWRATE:\r\nrc = iwctl_giwrate(dev, NULL, &(wrq->u.bitrate), NULL);\r\nbreak;\r\ncase SIOCSIWRTS:\r\nrc = iwctl_siwrts(dev, NULL, &(wrq->u.rts), NULL);\r\nbreak;\r\ncase SIOCGIWRTS:\r\nrc = iwctl_giwrts(dev, NULL, &(wrq->u.rts), NULL);\r\nbreak;\r\ncase SIOCSIWFRAG:\r\nrc = iwctl_siwfrag(dev, NULL, &(wrq->u.frag), NULL);\r\nbreak;\r\ncase SIOCGIWFRAG:\r\nrc = iwctl_giwfrag(dev, NULL, &(wrq->u.frag), NULL);\r\nbreak;\r\ncase SIOCSIWMODE:\r\nrc = iwctl_siwmode(dev, NULL, &(wrq->u.mode), NULL);\r\nbreak;\r\ncase SIOCGIWMODE:\r\nrc = iwctl_giwmode(dev, NULL, &(wrq->u.mode), NULL);\r\nbreak;\r\ncase SIOCSIWENCODE:\r\n{\r\nchar abyKey[WLAN_WEP232_KEYLEN];\r\nif (wrq->u.encoding.pointer) {\r\nif (wrq->u.encoding.length > WLAN_WEP232_KEYLEN) {\r\nrc = -E2BIG;\r\nbreak;\r\n}\r\nmemset(abyKey, 0, WLAN_WEP232_KEYLEN);\r\nif (copy_from_user(abyKey,\r\nwrq->u.encoding.pointer,\r\nwrq->u.encoding.length)) {\r\nrc = -EFAULT;\r\nbreak;\r\n}\r\n} else if (wrq->u.encoding.length != 0) {\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nrc = iwctl_siwencode(dev, NULL, &(wrq->u.encoding), abyKey);\r\n}\r\nbreak;\r\ncase SIOCGIWENCODE:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nrc = -EPERM;\r\nbreak;\r\n}\r\n{\r\nchar abyKey[WLAN_WEP232_KEYLEN];\r\nrc = iwctl_giwencode(dev, NULL, &(wrq->u.encoding), abyKey);\r\nif (rc != 0) break;\r\nif (wrq->u.encoding.pointer) {\r\nif (copy_to_user(wrq->u.encoding.pointer,\r\nabyKey,\r\nwrq->u.encoding.length))\r\nrc = -EFAULT;\r\n}\r\n}\r\nbreak;\r\ncase SIOCGIWTXPOW:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWTXPOW \n");\r\nrc = -EOPNOTSUPP;\r\nbreak;\r\ncase SIOCSIWTXPOW:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWTXPOW \n");\r\nrc = -EOPNOTSUPP;\r\nbreak;\r\ncase SIOCSIWRETRY:\r\nrc = iwctl_siwretry(dev, NULL, &(wrq->u.retry), NULL);\r\nbreak;\r\ncase SIOCGIWRETRY:\r\nrc = iwctl_giwretry(dev, NULL, &(wrq->u.retry), NULL);\r\nbreak;\r\ncase SIOCGIWRANGE:\r\n{\r\nstruct iw_range range;\r\nrc = iwctl_giwrange(dev, NULL, &(wrq->u.data), (char *) &range);\r\nif (copy_to_user(wrq->u.data.pointer, &range, sizeof(struct iw_range)))\r\nrc = -EFAULT;\r\n}\r\nbreak;\r\ncase SIOCGIWPOWER:\r\nrc = iwctl_giwpower(dev, NULL, &(wrq->u.power), NULL);\r\nbreak;\r\ncase SIOCSIWPOWER:\r\nrc = iwctl_siwpower(dev, NULL, &(wrq->u.power), NULL);\r\nbreak;\r\ncase SIOCGIWSENS:\r\nrc = iwctl_giwsens(dev, NULL, &(wrq->u.sens), NULL);\r\nbreak;\r\ncase SIOCSIWSENS:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSENS \n");\r\nrc = -EOPNOTSUPP;\r\nbreak;\r\ncase SIOCGIWAPLIST:\r\n{\r\nchar buffer[IW_MAX_AP * (sizeof(struct sockaddr) + sizeof(struct iw_quality))];\r\nif (wrq->u.data.pointer) {\r\nrc = iwctl_giwaplist(dev, NULL, &(wrq->u.data), buffer);\r\nif (rc == 0) {\r\nif (copy_to_user(wrq->u.data.pointer,\r\nbuffer,\r\n(wrq->u.data.length * (sizeof(struct sockaddr) + sizeof(struct iw_quality)))\r\n))\r\nrc = -EFAULT;\r\n}\r\n}\r\n}\r\nbreak;\r\n#ifdef WIRELESS_SPY\r\ncase SIOCSIWSPY:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWSPY \n");\r\nrc = -EOPNOTSUPP;\r\nbreak;\r\ncase SIOCGIWSPY:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWSPY \n");\r\nrc = -EOPNOTSUPP;\r\nbreak;\r\n#endif\r\ncase SIOCGIWPRIV:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWPRIV \n");\r\nrc = -EOPNOTSUPP;\r\nbreak;\r\n#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT\r\ncase SIOCSIWAUTH:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWAUTH \n");\r\nrc = iwctl_siwauth(dev, NULL, &(wrq->u.param), NULL);\r\nbreak;\r\ncase SIOCGIWAUTH:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWAUTH \n");\r\nrc = iwctl_giwauth(dev, NULL, &(wrq->u.param), NULL);\r\nbreak;\r\ncase SIOCSIWGENIE:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWGENIE \n");\r\nrc = iwctl_siwgenie(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);\r\nbreak;\r\ncase SIOCGIWGENIE:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWGENIE \n");\r\nrc = iwctl_giwgenie(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);\r\nbreak;\r\ncase SIOCSIWENCODEEXT:\r\n{\r\nchar extra[sizeof(struct iw_encode_ext)+MAX_KEY_LEN+1];\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWENCODEEXT \n");\r\nif(wrq->u.encoding.pointer){\r\nmemset(extra, 0, sizeof(struct iw_encode_ext)+MAX_KEY_LEN+1);\r\nif(wrq->u.encoding.length > (sizeof(struct iw_encode_ext)+ MAX_KEY_LEN)){\r\nrc = -E2BIG;\r\nbreak;\r\n}\r\nif(copy_from_user(extra, wrq->u.encoding.pointer,wrq->u.encoding.length)){\r\nrc = -EFAULT;\r\nbreak;\r\n}\r\n}else if(wrq->u.encoding.length != 0){\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nrc = iwctl_siwencodeext(dev, NULL, &(wrq->u.encoding), extra);\r\n}\r\nbreak;\r\ncase SIOCGIWENCODEEXT:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCGIWENCODEEXT \n");\r\nrc = iwctl_giwencodeext(dev, NULL, &(wrq->u.encoding), NULL);\r\nbreak;\r\ncase SIOCSIWMLME:\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO " SIOCSIWMLME \n");\r\nrc = iwctl_siwmlme(dev, NULL, &(wrq->u.data), wrq->u.data.pointer);\r\nbreak;\r\n#endif\r\ncase IOCTL_CMD_TEST:\r\nif (!(pDevice->flags & DEVICE_FLAGS_OPENED)) {\r\nrc = -EFAULT;\r\nbreak;\r\n} else {\r\nrc = 0;\r\n}\r\npReq = (PSCmdRequest)rq;\r\npReq->wResult = MAGIC_CODE;\r\nbreak;\r\ncase IOCTL_CMD_SET:\r\n#ifdef SndEvt_ToAPI\r\nif((((PSCmdRequest)rq)->wCmdCode !=WLAN_CMD_SET_EVT) &&\r\n!(pDevice->flags & DEVICE_FLAGS_OPENED))\r\n#else\r\nif (!(pDevice->flags & DEVICE_FLAGS_OPENED) &&\r\n(((PSCmdRequest)rq)->wCmdCode !=WLAN_CMD_SET_WPA))\r\n#endif\r\n{\r\nrc = -EFAULT;\r\nbreak;\r\n} else {\r\nrc = 0;\r\n}\r\nif (test_and_set_bit( 0, (void*)&(pMgmt->uCmdBusy))) {\r\nreturn -EBUSY;\r\n}\r\nrc = private_ioctl(pDevice, rq);\r\nclear_bit( 0, (void*)&(pMgmt->uCmdBusy));\r\nbreak;\r\ncase IOCTL_CMD_HOSTAPD:\r\nrc = vt6655_hostap_ioctl(pDevice, &wrq->u.data);\r\nbreak;\r\ncase IOCTL_CMD_WPA:\r\nrc = wpa_ioctl(pDevice, &wrq->u.data);\r\nbreak;\r\ncase SIOCETHTOOL:\r\nreturn ethtool_ioctl(dev, (void *) rq->ifr_data);\r\ndefault:\r\nrc = -EOPNOTSUPP;\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Ioctl command not support..%x\n", cmd);\r\n}\r\nif (pDevice->bCommit) {\r\nif (pMgmt->eConfigMode == WMAC_CONFIG_AP) {\r\nnetif_stop_queue(pDevice->dev);\r\nspin_lock_irq(&pDevice->lock);\r\nbScheduleCommand((void *)pDevice, WLAN_CMD_RUN_AP, NULL);\r\nspin_unlock_irq(&pDevice->lock);\r\n}\r\nelse {\r\nDBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO "Commit the settings\n");\r\nspin_lock_irq(&pDevice->lock);\r\npDevice->bLinkPass = false;\r\nmemset(pMgmt->abyCurrBSSID, 0, 6);\r\npMgmt->eCurrState = WMAC_STATE_IDLE;\r\nnetif_stop_queue(pDevice->dev);\r\n#ifdef WPA_SUPPLICANT_DRIVER_WEXT_SUPPORT\r\npMgmt->eScanType = WMAC_SCAN_ACTIVE;\r\nif(pDevice->bWPASuppWextEnabled !=true)\r\n#endif\r\nbScheduleCommand((void *) pDevice, WLAN_CMD_BSSID_SCAN, pMgmt->abyDesireSSID);\r\nbScheduleCommand((void *) pDevice, WLAN_CMD_SSID, NULL);\r\nspin_unlock_irq(&pDevice->lock);\r\n}\r\npDevice->bCommit = false;\r\n}\r\nreturn rc;\r\n}\r\nstatic int ethtool_ioctl(struct net_device *dev, void *useraddr)\r\n{\r\nu32 ethcmd;\r\nif (copy_from_user(&ethcmd, useraddr, sizeof(ethcmd)))\r\nreturn -EFAULT;\r\nswitch (ethcmd) {\r\ncase ETHTOOL_GDRVINFO: {\r\nstruct ethtool_drvinfo info = {ETHTOOL_GDRVINFO};\r\nstrncpy(info.driver, DEVICE_NAME, sizeof(info.driver)-1);\r\nstrncpy(info.version, DEVICE_VERSION, sizeof(info.version)-1);\r\nif (copy_to_user(useraddr, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int __init vt6655_init_module(void)\r\n{\r\nint ret;\r\nret = pci_register_driver(&device_driver);\r\n#ifdef CONFIG_PM\r\nif(ret >= 0)\r\nregister_reboot_notifier(&device_notifier);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __exit vt6655_cleanup_module(void)\r\n{\r\n#ifdef CONFIG_PM\r\nunregister_reboot_notifier(&device_notifier);\r\n#endif\r\npci_unregister_driver(&device_driver);\r\n}\r\nstatic int\r\ndevice_notify_reboot(struct notifier_block *nb, unsigned long event, void *p)\r\n{\r\nstruct pci_dev *pdev = NULL;\r\nswitch(event) {\r\ncase SYS_DOWN:\r\ncase SYS_HALT:\r\ncase SYS_POWER_OFF:\r\nfor_each_pci_dev(pdev) {\r\nif(pci_dev_driver(pdev) == &device_driver) {\r\nif (pci_get_drvdata(pdev))\r\nviawget_suspend(pdev, PMSG_HIBERNATE);\r\n}\r\n}\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int\r\nviawget_suspend(struct pci_dev *pcid, pm_message_t state)\r\n{\r\nint power_status;\r\nPSDevice pDevice=pci_get_drvdata(pcid);\r\nPSMgmtObject pMgmt = pDevice->pMgmt;\r\nnetif_stop_queue(pDevice->dev);\r\nspin_lock_irq(&pDevice->lock);\r\npci_save_state(pcid);\r\ndel_timer(&pDevice->sTimerCommand);\r\ndel_timer(&pMgmt->sTimerSecondCallback);\r\npDevice->cbFreeCmdQueue = CMD_Q_SIZE;\r\npDevice->uCmdDequeueIdx = 0;\r\npDevice->uCmdEnqueueIdx = 0;\r\npDevice->bCmdRunning = false;\r\nMACbShutdown(pDevice->PortOffset);\r\nMACvSaveContext(pDevice->PortOffset, pDevice->abyMacContext);\r\npDevice->bLinkPass = false;\r\nmemset(pMgmt->abyCurrBSSID, 0, 6);\r\npMgmt->eCurrState = WMAC_STATE_IDLE;\r\npci_disable_device(pcid);\r\npower_status = pci_set_power_state(pcid, pci_choose_state(pcid, state));\r\nspin_unlock_irq(&pDevice->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nviawget_resume(struct pci_dev *pcid)\r\n{\r\nPSDevice pDevice=pci_get_drvdata(pcid);\r\nPSMgmtObject pMgmt = pDevice->pMgmt;\r\nint power_status;\r\npower_status = pci_set_power_state(pcid, 0);\r\npower_status = pci_enable_wake(pcid, 0, 0);\r\npci_restore_state(pcid);\r\nif (netif_running(pDevice->dev)) {\r\nspin_lock_irq(&pDevice->lock);\r\nMACvRestoreContext(pDevice->PortOffset, pDevice->abyMacContext);\r\ndevice_init_registers(pDevice, DEVICE_INIT_DXPL);\r\nif (pMgmt->sNodeDBTable[0].bActive == true) {\r\npMgmt->sNodeDBTable[0].bActive = false;\r\npDevice->bLinkPass = false;\r\nif(pMgmt->eCurrMode == WMAC_MODE_IBSS_STA) {\r\npMgmt->eCurrState = WMAC_STATE_STARTED;\r\n}\r\nelse {\r\npMgmt->eCurrMode = WMAC_MODE_STANDBY;\r\npMgmt->eCurrState = WMAC_STATE_IDLE;\r\n}\r\n}\r\ninit_timer(&pMgmt->sTimerSecondCallback);\r\ninit_timer(&pDevice->sTimerCommand);\r\nMACvIntEnable(pDevice->PortOffset, IMR_MASK_VALUE);\r\nBSSvClearBSSList((void *)pDevice, pDevice->bLinkPass);\r\nbScheduleCommand((void *) pDevice, WLAN_CMD_BSSID_SCAN, NULL);\r\nbScheduleCommand((void *) pDevice, WLAN_CMD_SSID, NULL);\r\nspin_unlock_irq(&pDevice->lock);\r\n}\r\nreturn 0;\r\n}
