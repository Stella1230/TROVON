static int bpck6_read_regr(PIA *pi, int cont, int reg)\r\n{\r\nunsigned int out;\r\nif (reg<0 || reg>7 || cont<0 || cont>2)\r\n{\r\nreturn(-1);\r\n}\r\nout=ppc6_rd_port(PPCSTRUCT(pi),cont?reg|8:reg);\r\nreturn(out);\r\n}\r\nstatic void bpck6_write_regr(PIA *pi, int cont, int reg, int val)\r\n{\r\nif (reg>=0 && reg<=7 && cont>=0 && cont<=1)\r\n{\r\nppc6_wr_port(PPCSTRUCT(pi),cont?reg|8:reg,(u8)val);\r\n}\r\n}\r\nstatic void bpck6_write_block( PIA *pi, char * buf, int len )\r\n{\r\nppc6_wr_port16_blk(PPCSTRUCT(pi),ATAPI_DATA,buf,(u32)len>>1);\r\n}\r\nstatic void bpck6_read_block( PIA *pi, char * buf, int len )\r\n{\r\nppc6_rd_port16_blk(PPCSTRUCT(pi),ATAPI_DATA,buf,(u32)len>>1);\r\n}\r\nstatic void bpck6_connect ( PIA *pi )\r\n{\r\nif(verbose)\r\n{\r\nprintk(KERN_DEBUG "connect\n");\r\n}\r\nif(pi->mode >=2)\r\n{\r\nPPCSTRUCT(pi)->mode=4+pi->mode-2;\r\n}\r\nelse if(pi->mode==1)\r\n{\r\nPPCSTRUCT(pi)->mode=3;\r\n}\r\nelse\r\n{\r\nPPCSTRUCT(pi)->mode=1;\r\n}\r\nppc6_open(PPCSTRUCT(pi));\r\nppc6_wr_extout(PPCSTRUCT(pi),0x3);\r\n}\r\nstatic void bpck6_disconnect ( PIA *pi )\r\n{\r\nif(verbose)\r\n{\r\nprintk("disconnect\n");\r\n}\r\nppc6_wr_extout(PPCSTRUCT(pi),0x0);\r\nppc6_close(PPCSTRUCT(pi));\r\n}\r\nstatic int bpck6_test_port ( PIA *pi )\r\n{\r\nif(verbose)\r\n{\r\nprintk(KERN_DEBUG "PARPORT indicates modes=%x for lp=0x%lx\n",\r\n((struct pardevice*)(pi->pardev))->port->modes,\r\n((struct pardevice *)(pi->pardev))->port->base);\r\n}\r\nPPCSTRUCT(pi)->ppc_id=pi->unit;\r\nPPCSTRUCT(pi)->lpt_addr=pi->port;\r\nif(((struct pardevice *)(pi->pardev))->port->modes &\r\n(PARPORT_MODE_EPP)\r\n)\r\n{\r\nreturn 5;\r\n}\r\nelse if(((struct pardevice *)(pi->pardev))->port->modes &\r\n(PARPORT_MODE_TRISTATE)\r\n)\r\n{\r\nreturn 2;\r\n}\r\nelse\r\n{\r\nreturn 1;\r\n}\r\n}\r\nstatic int bpck6_probe_unit ( PIA *pi )\r\n{\r\nint out;\r\nif(verbose)\r\n{\r\nprintk(KERN_DEBUG "PROBE UNIT %x on port:%x\n",pi->unit,pi->port);\r\n}\r\nPPCSTRUCT(pi)->ppc_id=pi->unit;\r\nPPCSTRUCT(pi)->mode=1;\r\nout=ppc6_open(PPCSTRUCT(pi));\r\nif(verbose)\r\n{\r\nprintk(KERN_DEBUG "ppc_open returned %2x\n",out);\r\n}\r\nif(out)\r\n{\r\nppc6_close(PPCSTRUCT(pi));\r\nif(verbose)\r\n{\r\nprintk(KERN_DEBUG "leaving probe\n");\r\n}\r\nreturn(1);\r\n}\r\nelse\r\n{\r\nif(verbose)\r\n{\r\nprintk(KERN_DEBUG "Failed open\n");\r\n}\r\nreturn(0);\r\n}\r\n}\r\nstatic void bpck6_log_adapter( PIA *pi, char * scratch, int verbose )\r\n{\r\nchar *mode_string[5]=\r\n{"4-bit","8-bit","EPP-8","EPP-16","EPP-32"};\r\nprintk("%s: BACKPACK Protocol Driver V"BACKPACK_VERSION"\n",pi->device);\r\nprintk("%s: Copyright 2001 by Micro Solutions, Inc., DeKalb IL.\n",pi->device);\r\nprintk("%s: BACKPACK %s, Micro Solutions BACKPACK Drive at 0x%x\n",\r\npi->device,BACKPACK_VERSION,pi->port);\r\nprintk("%s: Unit: %d Mode:%d (%s) Delay %d\n",pi->device,\r\npi->unit,pi->mode,mode_string[pi->mode],pi->delay);\r\n}\r\nstatic int bpck6_init_proto(PIA *pi)\r\n{\r\nInterface *p = kzalloc(sizeof(Interface), GFP_KERNEL);\r\nif (p) {\r\npi->private = (unsigned long)p;\r\nreturn 0;\r\n}\r\nprintk(KERN_ERR "%s: ERROR COULDN'T ALLOCATE MEMORY\n", pi->device);\r\nreturn -1;\r\n}\r\nstatic void bpck6_release_proto(PIA *pi)\r\n{\r\nkfree((void *)(pi->private));\r\n}\r\nstatic int __init bpck6_init(void)\r\n{\r\nprintk(KERN_INFO "bpck6: BACKPACK Protocol Driver V"BACKPACK_VERSION"\n");\r\nprintk(KERN_INFO "bpck6: Copyright 2001 by Micro Solutions, Inc., DeKalb IL. USA\n");\r\nif(verbose)\r\nprintk(KERN_DEBUG "bpck6: verbose debug enabled.\n");\r\nreturn paride_register(&bpck6);\r\n}\r\nstatic void __exit bpck6_exit(void)\r\n{\r\nparide_unregister(&bpck6);\r\n}
