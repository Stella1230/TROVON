struct gtm_timer *gtm_get_timer16(void)\r\n{\r\nstruct gtm *gtm = NULL;\r\nint i;\r\nlist_for_each_entry(gtm, &gtms, list_node) {\r\nspin_lock_irq(&gtm->lock);\r\nfor (i = 0; i < ARRAY_SIZE(gtm->timers); i++) {\r\nif (!gtm->timers[i].requested) {\r\ngtm->timers[i].requested = true;\r\nspin_unlock_irq(&gtm->lock);\r\nreturn &gtm->timers[i];\r\n}\r\n}\r\nspin_unlock_irq(&gtm->lock);\r\n}\r\nif (gtm)\r\nreturn ERR_PTR(-EBUSY);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstruct gtm_timer *gtm_get_specific_timer16(struct gtm *gtm,\r\nunsigned int timer)\r\n{\r\nstruct gtm_timer *ret = ERR_PTR(-EBUSY);\r\nif (timer > 3)\r\nreturn ERR_PTR(-EINVAL);\r\nspin_lock_irq(&gtm->lock);\r\nif (gtm->timers[timer].requested)\r\ngoto out;\r\nret = &gtm->timers[timer];\r\nret->requested = true;\r\nout:\r\nspin_unlock_irq(&gtm->lock);\r\nreturn ret;\r\n}\r\nvoid gtm_put_timer16(struct gtm_timer *tmr)\r\n{\r\ngtm_stop_timer16(tmr);\r\nspin_lock_irq(&tmr->gtm->lock);\r\ntmr->requested = false;\r\nspin_unlock_irq(&tmr->gtm->lock);\r\n}\r\nstatic int gtm_set_ref_timer16(struct gtm_timer *tmr, int frequency,\r\nint reference_value, bool free_run)\r\n{\r\nstruct gtm *gtm = tmr->gtm;\r\nint num = tmr - &gtm->timers[0];\r\nunsigned int prescaler;\r\nu8 iclk = GTMDR_ICLK_ICLK;\r\nu8 psr;\r\nu8 sps;\r\nunsigned long flags;\r\nint max_prescaler = 256 * 256 * 16;\r\nif (!tmr->gtpsr)\r\nmax_prescaler /= 256;\r\nprescaler = gtm->clock / frequency;\r\nif (prescaler > max_prescaler)\r\nreturn -EINVAL;\r\nif (prescaler > max_prescaler / 16) {\r\niclk = GTMDR_ICLK_SLGO;\r\nprescaler /= 16;\r\n}\r\nif (prescaler <= 256) {\r\npsr = 0;\r\nsps = prescaler - 1;\r\n} else {\r\npsr = 256 - 1;\r\nsps = prescaler / 256 - 1;\r\n}\r\nspin_lock_irqsave(&gtm->lock, flags);\r\nclrsetbits_8(tmr->gtcfr, ~(GTCFR_STP(num) | GTCFR_RST(num)),\r\nGTCFR_STP(num) | GTCFR_RST(num));\r\nsetbits8(tmr->gtcfr, GTCFR_STP(num));\r\nif (tmr->gtpsr)\r\nout_be16(tmr->gtpsr, psr);\r\nclrsetbits_be16(tmr->gtmdr, 0xFFFF, iclk | GTMDR_SPS(sps) |\r\nGTMDR_ORI | (free_run ? GTMDR_FRR : 0));\r\nout_be16(tmr->gtcnr, 0);\r\nout_be16(tmr->gtrfr, reference_value);\r\nout_be16(tmr->gtevr, 0xFFFF);\r\nclrbits8(tmr->gtcfr, GTCFR_STP(num));\r\nspin_unlock_irqrestore(&gtm->lock, flags);\r\nreturn 0;\r\n}\r\nint gtm_set_timer16(struct gtm_timer *tmr, unsigned long usec, bool reload)\r\n{\r\nint freq = 1000000;\r\nunsigned int bit;\r\nbit = fls_long(usec);\r\nif (bit > 15) {\r\nfreq >>= bit - 15;\r\nusec >>= bit - 15;\r\n}\r\nif (!freq)\r\nreturn -EINVAL;\r\nreturn gtm_set_ref_timer16(tmr, freq, usec, reload);\r\n}\r\nint gtm_set_exact_timer16(struct gtm_timer *tmr, u16 usec, bool reload)\r\n{\r\nconst int freq = 1000000;\r\nreturn gtm_set_ref_timer16(tmr, freq, usec, reload);\r\n}\r\nvoid gtm_stop_timer16(struct gtm_timer *tmr)\r\n{\r\nstruct gtm *gtm = tmr->gtm;\r\nint num = tmr - &gtm->timers[0];\r\nunsigned long flags;\r\nspin_lock_irqsave(&gtm->lock, flags);\r\nsetbits8(tmr->gtcfr, GTCFR_STP(num));\r\nout_be16(tmr->gtevr, 0xFFFF);\r\nspin_unlock_irqrestore(&gtm->lock, flags);\r\n}\r\nvoid gtm_ack_timer16(struct gtm_timer *tmr, u16 events)\r\n{\r\nout_be16(tmr->gtevr, events);\r\n}\r\nstatic void __init gtm_set_shortcuts(struct device_node *np,\r\nstruct gtm_timer *timers,\r\nstruct gtm_timers_regs __iomem *regs)\r\n{\r\ntimers[0].gtcfr = &regs->gtcfr1;\r\ntimers[0].gtmdr = &regs->gtmdr1;\r\ntimers[0].gtcnr = &regs->gtcnr1;\r\ntimers[0].gtrfr = &regs->gtrfr1;\r\ntimers[0].gtevr = &regs->gtevr1;\r\ntimers[1].gtcfr = &regs->gtcfr1;\r\ntimers[1].gtmdr = &regs->gtmdr2;\r\ntimers[1].gtcnr = &regs->gtcnr2;\r\ntimers[1].gtrfr = &regs->gtrfr2;\r\ntimers[1].gtevr = &regs->gtevr2;\r\ntimers[2].gtcfr = &regs->gtcfr2;\r\ntimers[2].gtmdr = &regs->gtmdr3;\r\ntimers[2].gtcnr = &regs->gtcnr3;\r\ntimers[2].gtrfr = &regs->gtrfr3;\r\ntimers[2].gtevr = &regs->gtevr3;\r\ntimers[3].gtcfr = &regs->gtcfr2;\r\ntimers[3].gtmdr = &regs->gtmdr4;\r\ntimers[3].gtcnr = &regs->gtcnr4;\r\ntimers[3].gtrfr = &regs->gtrfr4;\r\ntimers[3].gtevr = &regs->gtevr4;\r\nif (!of_device_is_compatible(np, "fsl,cpm2-gtm")) {\r\ntimers[0].gtpsr = &regs->gtpsr1;\r\ntimers[1].gtpsr = &regs->gtpsr2;\r\ntimers[2].gtpsr = &regs->gtpsr3;\r\ntimers[3].gtpsr = &regs->gtpsr4;\r\n}\r\n}\r\nstatic int __init fsl_gtm_init(void)\r\n{\r\nstruct device_node *np;\r\nfor_each_compatible_node(np, NULL, "fsl,gtm") {\r\nint i;\r\nstruct gtm *gtm;\r\nconst u32 *clock;\r\nint size;\r\ngtm = kzalloc(sizeof(*gtm), GFP_KERNEL);\r\nif (!gtm) {\r\npr_err("%s: unable to allocate memory\n",\r\nnp->full_name);\r\ncontinue;\r\n}\r\nspin_lock_init(&gtm->lock);\r\nclock = of_get_property(np, "clock-frequency", &size);\r\nif (!clock || size != sizeof(*clock)) {\r\npr_err("%s: no clock-frequency\n", np->full_name);\r\ngoto err;\r\n}\r\ngtm->clock = *clock;\r\nfor (i = 0; i < ARRAY_SIZE(gtm->timers); i++) {\r\nint ret;\r\nstruct resource irq;\r\nret = of_irq_to_resource(np, i, &irq);\r\nif (ret == NO_IRQ) {\r\npr_err("%s: not enough interrupts specified\n",\r\nnp->full_name);\r\ngoto err;\r\n}\r\ngtm->timers[i].irq = irq.start;\r\ngtm->timers[i].gtm = gtm;\r\n}\r\ngtm->regs = of_iomap(np, 0);\r\nif (!gtm->regs) {\r\npr_err("%s: unable to iomap registers\n",\r\nnp->full_name);\r\ngoto err;\r\n}\r\ngtm_set_shortcuts(np, gtm->timers, gtm->regs);\r\nlist_add(&gtm->list_node, &gtms);\r\nnp->data = gtm;\r\nof_node_get(np);\r\ncontinue;\r\nerr:\r\nkfree(gtm);\r\n}\r\nreturn 0;\r\n}
