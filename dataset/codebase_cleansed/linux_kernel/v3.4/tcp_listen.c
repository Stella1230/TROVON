static int rds_tcp_accept_one(struct socket *sock)\r\n{\r\nstruct socket *new_sock = NULL;\r\nstruct rds_connection *conn;\r\nint ret;\r\nstruct inet_sock *inet;\r\nret = sock_create_lite(sock->sk->sk_family, sock->sk->sk_type,\r\nsock->sk->sk_protocol, &new_sock);\r\nif (ret)\r\ngoto out;\r\nnew_sock->type = sock->type;\r\nnew_sock->ops = sock->ops;\r\nret = sock->ops->accept(sock, new_sock, O_NONBLOCK);\r\nif (ret < 0)\r\ngoto out;\r\nrds_tcp_tune(new_sock);\r\ninet = inet_sk(new_sock->sk);\r\nrdsdebug("accepted tcp %pI4:%u -> %pI4:%u\n",\r\n&inet->inet_saddr, ntohs(inet->inet_sport),\r\n&inet->inet_daddr, ntohs(inet->inet_dport));\r\nconn = rds_conn_create(inet->inet_saddr, inet->inet_daddr,\r\n&rds_tcp_transport, GFP_KERNEL);\r\nif (IS_ERR(conn)) {\r\nret = PTR_ERR(conn);\r\ngoto out;\r\n}\r\nif (!rds_conn_transition(conn, RDS_CONN_DOWN, RDS_CONN_CONNECTING)) {\r\nif (rds_conn_state(conn) == RDS_CONN_UP)\r\nrds_tcp_stats_inc(s_tcp_listen_closed_stale);\r\nelse\r\nrds_tcp_stats_inc(s_tcp_connect_raced);\r\nrds_conn_drop(conn);\r\nret = 0;\r\ngoto out;\r\n}\r\nrds_tcp_set_callbacks(new_sock, conn);\r\nrds_connect_complete(conn);\r\nnew_sock = NULL;\r\nret = 0;\r\nout:\r\nif (new_sock)\r\nsock_release(new_sock);\r\nreturn ret;\r\n}\r\nstatic void rds_tcp_accept_worker(struct work_struct *work)\r\n{\r\nwhile (rds_tcp_accept_one(rds_tcp_listen_sock) == 0)\r\ncond_resched();\r\n}\r\nvoid rds_tcp_listen_data_ready(struct sock *sk, int bytes)\r\n{\r\nvoid (*ready)(struct sock *sk, int bytes);\r\nrdsdebug("listen data ready sk %p\n", sk);\r\nread_lock_bh(&sk->sk_callback_lock);\r\nready = sk->sk_user_data;\r\nif (!ready) {\r\nready = sk->sk_data_ready;\r\ngoto out;\r\n}\r\nif (sk->sk_state == TCP_LISTEN)\r\nqueue_work(rds_wq, &rds_tcp_listen_work);\r\nout:\r\nread_unlock_bh(&sk->sk_callback_lock);\r\nready(sk, bytes);\r\n}\r\nint rds_tcp_listen_init(void)\r\n{\r\nstruct sockaddr_in sin;\r\nstruct socket *sock = NULL;\r\nint ret;\r\nret = sock_create(PF_INET, SOCK_STREAM, IPPROTO_TCP, &sock);\r\nif (ret < 0)\r\ngoto out;\r\nsock->sk->sk_reuse = 1;\r\nrds_tcp_nonagle(sock);\r\nwrite_lock_bh(&sock->sk->sk_callback_lock);\r\nsock->sk->sk_user_data = sock->sk->sk_data_ready;\r\nsock->sk->sk_data_ready = rds_tcp_listen_data_ready;\r\nwrite_unlock_bh(&sock->sk->sk_callback_lock);\r\nsin.sin_family = PF_INET,\r\nsin.sin_addr.s_addr = (__force u32)htonl(INADDR_ANY);\r\nsin.sin_port = (__force u16)htons(RDS_TCP_PORT);\r\nret = sock->ops->bind(sock, (struct sockaddr *)&sin, sizeof(sin));\r\nif (ret < 0)\r\ngoto out;\r\nret = sock->ops->listen(sock, 64);\r\nif (ret < 0)\r\ngoto out;\r\nrds_tcp_listen_sock = sock;\r\nsock = NULL;\r\nout:\r\nif (sock)\r\nsock_release(sock);\r\nreturn ret;\r\n}\r\nvoid rds_tcp_listen_stop(void)\r\n{\r\nstruct socket *sock = rds_tcp_listen_sock;\r\nstruct sock *sk;\r\nif (!sock)\r\nreturn;\r\nsk = sock->sk;\r\nlock_sock(sk);\r\nwrite_lock_bh(&sk->sk_callback_lock);\r\nif (sk->sk_user_data) {\r\nsk->sk_data_ready = sk->sk_user_data;\r\nsk->sk_user_data = NULL;\r\n}\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\nrelease_sock(sk);\r\nflush_workqueue(rds_wq);\r\nsock_release(sock);\r\nrds_tcp_listen_sock = NULL;\r\n}
