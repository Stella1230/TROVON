static int snd_compr_open(struct inode *inode, struct file *f)\r\n{\r\nstruct snd_compr *compr;\r\nstruct snd_compr_file *data;\r\nstruct snd_compr_runtime *runtime;\r\nenum snd_compr_direction dirn;\r\nint maj = imajor(inode);\r\nint ret;\r\nif (f->f_flags & O_WRONLY)\r\ndirn = SND_COMPRESS_PLAYBACK;\r\nelse if (f->f_flags & O_RDONLY)\r\ndirn = SND_COMPRESS_CAPTURE;\r\nelse {\r\npr_err("invalid direction\n");\r\nreturn -EINVAL;\r\n}\r\nif (maj == snd_major)\r\ncompr = snd_lookup_minor_data(iminor(inode),\r\nSNDRV_DEVICE_TYPE_COMPRESS);\r\nelse\r\nreturn -EBADFD;\r\nif (compr == NULL) {\r\npr_err("no device data!!!\n");\r\nreturn -ENODEV;\r\n}\r\nif (dirn != compr->direction) {\r\npr_err("this device doesn't support this direction\n");\r\nreturn -EINVAL;\r\n}\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->stream.ops = compr->ops;\r\ndata->stream.direction = dirn;\r\ndata->stream.private_data = compr->private_data;\r\ndata->stream.device = compr;\r\nruntime = kzalloc(sizeof(*runtime), GFP_KERNEL);\r\nif (!runtime) {\r\nkfree(data);\r\nreturn -ENOMEM;\r\n}\r\nruntime->state = SNDRV_PCM_STATE_OPEN;\r\ninit_waitqueue_head(&runtime->sleep);\r\ndata->stream.runtime = runtime;\r\nf->private_data = (void *)data;\r\nmutex_lock(&compr->lock);\r\nret = compr->ops->open(&data->stream);\r\nmutex_unlock(&compr->lock);\r\nif (ret) {\r\nkfree(runtime);\r\nkfree(data);\r\n}\r\nreturn ret;\r\n}\r\nstatic int snd_compr_free(struct inode *inode, struct file *f)\r\n{\r\nstruct snd_compr_file *data = f->private_data;\r\ndata->stream.ops->free(&data->stream);\r\nkfree(data->stream.runtime->buffer);\r\nkfree(data->stream.runtime);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic void snd_compr_update_tstamp(struct snd_compr_stream *stream,\r\nstruct snd_compr_tstamp *tstamp)\r\n{\r\nif (!stream->ops->pointer)\r\nreturn;\r\nstream->ops->pointer(stream, tstamp);\r\npr_debug("dsp consumed till %d total %d bytes\n",\r\ntstamp->byte_offset, tstamp->copied_total);\r\nstream->runtime->hw_pointer = tstamp->byte_offset;\r\nstream->runtime->total_bytes_transferred = tstamp->copied_total;\r\n}\r\nstatic size_t snd_compr_calc_avail(struct snd_compr_stream *stream,\r\nstruct snd_compr_avail *avail)\r\n{\r\nlong avail_calc;\r\nsnd_compr_update_tstamp(stream, &avail->tstamp);\r\nif (stream->runtime->total_bytes_available == 0 &&\r\nstream->runtime->state == SNDRV_PCM_STATE_SETUP) {\r\npr_debug("detected init and someone forgot to do a write\n");\r\nreturn stream->runtime->buffer_size;\r\n}\r\npr_debug("app wrote %lld, DSP consumed %lld\n",\r\nstream->runtime->total_bytes_available,\r\nstream->runtime->total_bytes_transferred);\r\nif (stream->runtime->total_bytes_available ==\r\nstream->runtime->total_bytes_transferred) {\r\npr_debug("both pointers are same, returning full avail\n");\r\nreturn stream->runtime->buffer_size;\r\n}\r\navail_calc = stream->runtime->buffer_size -\r\n(stream->runtime->app_pointer - stream->runtime->hw_pointer);\r\npr_debug("calc avail as %ld, app_ptr %lld, hw+ptr %lld\n", avail_calc,\r\nstream->runtime->app_pointer,\r\nstream->runtime->hw_pointer);\r\nif (avail_calc >= stream->runtime->buffer_size)\r\navail_calc -= stream->runtime->buffer_size;\r\npr_debug("ret avail as %ld\n", avail_calc);\r\navail->avail = avail_calc;\r\nreturn avail_calc;\r\n}\r\nstatic inline size_t snd_compr_get_avail(struct snd_compr_stream *stream)\r\n{\r\nstruct snd_compr_avail avail;\r\nreturn snd_compr_calc_avail(stream, &avail);\r\n}\r\nstatic int\r\nsnd_compr_ioctl_avail(struct snd_compr_stream *stream, unsigned long arg)\r\n{\r\nstruct snd_compr_avail ioctl_avail;\r\nsize_t avail;\r\navail = snd_compr_calc_avail(stream, &ioctl_avail);\r\nioctl_avail.avail = avail;\r\nif (copy_to_user((__u64 __user *)arg,\r\n&ioctl_avail, sizeof(ioctl_avail)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_compr_write_data(struct snd_compr_stream *stream,\r\nconst char __user *buf, size_t count)\r\n{\r\nvoid *dstn;\r\nsize_t copy;\r\nstruct snd_compr_runtime *runtime = stream->runtime;\r\ndstn = runtime->buffer + runtime->app_pointer;\r\npr_debug("copying %ld at %lld\n",\r\n(unsigned long)count, runtime->app_pointer);\r\nif (count < runtime->buffer_size - runtime->app_pointer) {\r\nif (copy_from_user(dstn, buf, count))\r\nreturn -EFAULT;\r\nruntime->app_pointer += count;\r\n} else {\r\ncopy = runtime->buffer_size - runtime->app_pointer;\r\nif (copy_from_user(dstn, buf, copy))\r\nreturn -EFAULT;\r\nif (copy_from_user(runtime->buffer, buf + copy, count - copy))\r\nreturn -EFAULT;\r\nruntime->app_pointer = count - copy;\r\n}\r\nif (stream->ops->ack)\r\nstream->ops->ack(stream, count);\r\nreturn count;\r\n}\r\nstatic ssize_t snd_compr_write(struct file *f, const char __user *buf,\r\nsize_t count, loff_t *offset)\r\n{\r\nstruct snd_compr_file *data = f->private_data;\r\nstruct snd_compr_stream *stream;\r\nsize_t avail;\r\nint retval;\r\nif (snd_BUG_ON(!data))\r\nreturn -EFAULT;\r\nstream = &data->stream;\r\nmutex_lock(&stream->device->lock);\r\nif (stream->runtime->state != SNDRV_PCM_STATE_SETUP &&\r\nstream->runtime->state != SNDRV_PCM_STATE_RUNNING) {\r\nmutex_unlock(&stream->device->lock);\r\nreturn -EBADFD;\r\n}\r\navail = snd_compr_get_avail(stream);\r\npr_debug("avail returned %ld\n", (unsigned long)avail);\r\nif (avail > count)\r\navail = count;\r\nif (stream->ops->copy)\r\nretval = stream->ops->copy(stream, buf, avail);\r\nelse\r\nretval = snd_compr_write_data(stream, buf, avail);\r\nif (retval > 0)\r\nstream->runtime->total_bytes_available += retval;\r\nif (stream->runtime->state == SNDRV_PCM_STATE_SETUP) {\r\nstream->runtime->state = SNDRV_PCM_STATE_PREPARED;\r\npr_debug("stream prepared, Houston we are good to go\n");\r\n}\r\nmutex_unlock(&stream->device->lock);\r\nreturn retval;\r\n}\r\nstatic ssize_t snd_compr_read(struct file *f, char __user *buf,\r\nsize_t count, loff_t *offset)\r\n{\r\nreturn -ENXIO;\r\n}\r\nstatic int snd_compr_mmap(struct file *f, struct vm_area_struct *vma)\r\n{\r\nreturn -ENXIO;\r\n}\r\nstatic inline int snd_compr_get_poll(struct snd_compr_stream *stream)\r\n{\r\nif (stream->direction == SND_COMPRESS_PLAYBACK)\r\nreturn POLLOUT | POLLWRNORM;\r\nelse\r\nreturn POLLIN | POLLRDNORM;\r\n}\r\nstatic unsigned int snd_compr_poll(struct file *f, poll_table *wait)\r\n{\r\nstruct snd_compr_file *data = f->private_data;\r\nstruct snd_compr_stream *stream;\r\nsize_t avail;\r\nint retval = 0;\r\nif (snd_BUG_ON(!data))\r\nreturn -EFAULT;\r\nstream = &data->stream;\r\nif (snd_BUG_ON(!stream))\r\nreturn -EFAULT;\r\nmutex_lock(&stream->device->lock);\r\nif (stream->runtime->state == SNDRV_PCM_STATE_PAUSED ||\r\nstream->runtime->state == SNDRV_PCM_STATE_OPEN) {\r\nretval = -EBADFD;\r\ngoto out;\r\n}\r\npoll_wait(f, &stream->runtime->sleep, wait);\r\navail = snd_compr_get_avail(stream);\r\npr_debug("avail is %ld\n", (unsigned long)avail);\r\nswitch (stream->runtime->state) {\r\ncase SNDRV_PCM_STATE_DRAINING:\r\nretval = snd_compr_get_poll(stream);\r\nstream->runtime->state = SNDRV_PCM_STATE_SETUP;\r\nbreak;\r\ncase SNDRV_PCM_STATE_RUNNING:\r\ncase SNDRV_PCM_STATE_PREPARED:\r\ncase SNDRV_PCM_STATE_PAUSED:\r\nif (avail >= stream->runtime->fragment_size)\r\nretval = snd_compr_get_poll(stream);\r\nbreak;\r\ndefault:\r\nif (stream->direction == SND_COMPRESS_PLAYBACK)\r\nretval = POLLOUT | POLLWRNORM | POLLERR;\r\nelse\r\nretval = POLLIN | POLLRDNORM | POLLERR;\r\nbreak;\r\n}\r\nout:\r\nmutex_unlock(&stream->device->lock);\r\nreturn retval;\r\n}\r\nstatic int\r\nsnd_compr_get_caps(struct snd_compr_stream *stream, unsigned long arg)\r\n{\r\nint retval;\r\nstruct snd_compr_caps caps;\r\nif (!stream->ops->get_caps)\r\nreturn -ENXIO;\r\nretval = stream->ops->get_caps(stream, &caps);\r\nif (retval)\r\ngoto out;\r\nif (copy_to_user((void __user *)arg, &caps, sizeof(caps)))\r\nretval = -EFAULT;\r\nout:\r\nreturn retval;\r\n}\r\nstatic int\r\nsnd_compr_get_codec_caps(struct snd_compr_stream *stream, unsigned long arg)\r\n{\r\nint retval;\r\nstruct snd_compr_codec_caps *caps;\r\nif (!stream->ops->get_codec_caps)\r\nreturn -ENXIO;\r\ncaps = kmalloc(sizeof(*caps), GFP_KERNEL);\r\nif (!caps)\r\nreturn -ENOMEM;\r\nretval = stream->ops->get_codec_caps(stream, caps);\r\nif (retval)\r\ngoto out;\r\nif (copy_to_user((void __user *)arg, caps, sizeof(*caps)))\r\nretval = -EFAULT;\r\nout:\r\nkfree(caps);\r\nreturn retval;\r\n}\r\nstatic int snd_compr_allocate_buffer(struct snd_compr_stream *stream,\r\nstruct snd_compr_params *params)\r\n{\r\nunsigned int buffer_size;\r\nvoid *buffer;\r\nbuffer_size = params->buffer.fragment_size * params->buffer.fragments;\r\nif (stream->ops->copy) {\r\nbuffer = NULL;\r\n} else {\r\nbuffer = kmalloc(buffer_size, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\n}\r\nstream->runtime->fragment_size = params->buffer.fragment_size;\r\nstream->runtime->fragments = params->buffer.fragments;\r\nstream->runtime->buffer = buffer;\r\nstream->runtime->buffer_size = buffer_size;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_compr_set_params(struct snd_compr_stream *stream, unsigned long arg)\r\n{\r\nstruct snd_compr_params *params;\r\nint retval;\r\nif (stream->runtime->state == SNDRV_PCM_STATE_OPEN) {\r\nparams = kmalloc(sizeof(*params), GFP_KERNEL);\r\nif (!params)\r\nreturn -ENOMEM;\r\nif (copy_from_user(params, (void __user *)arg, sizeof(*params))) {\r\nretval = -EFAULT;\r\ngoto out;\r\n}\r\nretval = snd_compr_allocate_buffer(stream, params);\r\nif (retval) {\r\nretval = -ENOMEM;\r\ngoto out;\r\n}\r\nretval = stream->ops->set_params(stream, params);\r\nif (retval)\r\ngoto out;\r\nstream->runtime->state = SNDRV_PCM_STATE_SETUP;\r\n} else {\r\nreturn -EPERM;\r\n}\r\nout:\r\nkfree(params);\r\nreturn retval;\r\n}\r\nstatic int\r\nsnd_compr_get_params(struct snd_compr_stream *stream, unsigned long arg)\r\n{\r\nstruct snd_codec *params;\r\nint retval;\r\nif (!stream->ops->get_params)\r\nreturn -EBADFD;\r\nparams = kmalloc(sizeof(*params), GFP_KERNEL);\r\nif (!params)\r\nreturn -ENOMEM;\r\nretval = stream->ops->get_params(stream, params);\r\nif (retval)\r\ngoto out;\r\nif (copy_to_user((char __user *)arg, params, sizeof(*params)))\r\nretval = -EFAULT;\r\nout:\r\nkfree(params);\r\nreturn retval;\r\n}\r\nstatic inline int\r\nsnd_compr_tstamp(struct snd_compr_stream *stream, unsigned long arg)\r\n{\r\nstruct snd_compr_tstamp tstamp;\r\nsnd_compr_update_tstamp(stream, &tstamp);\r\nreturn copy_to_user((struct snd_compr_tstamp __user *)arg,\r\n&tstamp, sizeof(tstamp)) ? -EFAULT : 0;\r\n}\r\nstatic int snd_compr_pause(struct snd_compr_stream *stream)\r\n{\r\nint retval;\r\nif (stream->runtime->state != SNDRV_PCM_STATE_RUNNING)\r\nreturn -EPERM;\r\nretval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_PAUSE_PUSH);\r\nif (!retval) {\r\nstream->runtime->state = SNDRV_PCM_STATE_PAUSED;\r\nwake_up(&stream->runtime->sleep);\r\n}\r\nreturn retval;\r\n}\r\nstatic int snd_compr_resume(struct snd_compr_stream *stream)\r\n{\r\nint retval;\r\nif (stream->runtime->state != SNDRV_PCM_STATE_PAUSED)\r\nreturn -EPERM;\r\nretval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_PAUSE_RELEASE);\r\nif (!retval)\r\nstream->runtime->state = SNDRV_PCM_STATE_RUNNING;\r\nreturn retval;\r\n}\r\nstatic int snd_compr_start(struct snd_compr_stream *stream)\r\n{\r\nint retval;\r\nif (stream->runtime->state != SNDRV_PCM_STATE_PREPARED)\r\nreturn -EPERM;\r\nretval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_START);\r\nif (!retval)\r\nstream->runtime->state = SNDRV_PCM_STATE_RUNNING;\r\nreturn retval;\r\n}\r\nstatic int snd_compr_stop(struct snd_compr_stream *stream)\r\n{\r\nint retval;\r\nif (stream->runtime->state == SNDRV_PCM_STATE_PREPARED ||\r\nstream->runtime->state == SNDRV_PCM_STATE_SETUP)\r\nreturn -EPERM;\r\nretval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_STOP);\r\nif (!retval) {\r\nstream->runtime->state = SNDRV_PCM_STATE_SETUP;\r\nwake_up(&stream->runtime->sleep);\r\n}\r\nreturn retval;\r\n}\r\nstatic int snd_compr_drain(struct snd_compr_stream *stream)\r\n{\r\nint retval;\r\nif (stream->runtime->state == SNDRV_PCM_STATE_PREPARED ||\r\nstream->runtime->state == SNDRV_PCM_STATE_SETUP)\r\nreturn -EPERM;\r\nretval = stream->ops->trigger(stream, SND_COMPR_TRIGGER_DRAIN);\r\nif (!retval) {\r\nstream->runtime->state = SNDRV_PCM_STATE_DRAINING;\r\nwake_up(&stream->runtime->sleep);\r\n}\r\nreturn retval;\r\n}\r\nstatic long snd_compr_ioctl(struct file *f, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct snd_compr_file *data = f->private_data;\r\nstruct snd_compr_stream *stream;\r\nint retval = -ENOTTY;\r\nif (snd_BUG_ON(!data))\r\nreturn -EFAULT;\r\nstream = &data->stream;\r\nif (snd_BUG_ON(!stream))\r\nreturn -EFAULT;\r\nmutex_lock(&stream->device->lock);\r\nswitch (_IOC_NR(cmd)) {\r\ncase _IOC_NR(SNDRV_COMPRESS_IOCTL_VERSION):\r\nput_user(SNDRV_COMPRESS_VERSION,\r\n(int __user *)arg) ? -EFAULT : 0;\r\nbreak;\r\ncase _IOC_NR(SNDRV_COMPRESS_GET_CAPS):\r\nretval = snd_compr_get_caps(stream, arg);\r\nbreak;\r\ncase _IOC_NR(SNDRV_COMPRESS_GET_CODEC_CAPS):\r\nretval = snd_compr_get_codec_caps(stream, arg);\r\nbreak;\r\ncase _IOC_NR(SNDRV_COMPRESS_SET_PARAMS):\r\nretval = snd_compr_set_params(stream, arg);\r\nbreak;\r\ncase _IOC_NR(SNDRV_COMPRESS_GET_PARAMS):\r\nretval = snd_compr_get_params(stream, arg);\r\nbreak;\r\ncase _IOC_NR(SNDRV_COMPRESS_TSTAMP):\r\nretval = snd_compr_tstamp(stream, arg);\r\nbreak;\r\ncase _IOC_NR(SNDRV_COMPRESS_AVAIL):\r\nretval = snd_compr_ioctl_avail(stream, arg);\r\nbreak;\r\ncase _IOC_NR(SNDRV_COMPRESS_PAUSE):\r\nretval = snd_compr_pause(stream);\r\nbreak;\r\ncase _IOC_NR(SNDRV_COMPRESS_RESUME):\r\nretval = snd_compr_resume(stream);\r\nbreak;\r\ncase _IOC_NR(SNDRV_COMPRESS_START):\r\nretval = snd_compr_start(stream);\r\nbreak;\r\ncase _IOC_NR(SNDRV_COMPRESS_STOP):\r\nretval = snd_compr_stop(stream);\r\nbreak;\r\ncase _IOC_NR(SNDRV_COMPRESS_DRAIN):\r\nretval = snd_compr_drain(stream);\r\nbreak;\r\n}\r\nmutex_unlock(&stream->device->lock);\r\nreturn retval;\r\n}\r\nstatic int snd_compress_dev_register(struct snd_device *device)\r\n{\r\nint ret = -EINVAL;\r\nchar str[16];\r\nstruct snd_compr *compr;\r\nif (snd_BUG_ON(!device || !device->device_data))\r\nreturn -EBADFD;\r\ncompr = device->device_data;\r\nsprintf(str, "comprC%iD%i", compr->card->number, compr->device);\r\npr_debug("reg %s for device %s, direction %d\n", str, compr->name,\r\ncompr->direction);\r\nret = snd_register_device(SNDRV_DEVICE_TYPE_COMPRESS, compr->card,\r\ncompr->device, &snd_compr_file_ops, compr, str);\r\nif (ret < 0) {\r\npr_err("snd_register_device failed\n %d", ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int snd_compress_dev_disconnect(struct snd_device *device)\r\n{\r\nstruct snd_compr *compr;\r\ncompr = device->device_data;\r\nsnd_unregister_device(compr->direction, compr->card, compr->device);\r\nreturn 0;\r\n}\r\nint snd_compress_new(struct snd_card *card, int device,\r\nint dirn, struct snd_compr *compr)\r\n{\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = NULL,\r\n.dev_register = snd_compress_dev_register,\r\n.dev_disconnect = snd_compress_dev_disconnect,\r\n};\r\ncompr->card = card;\r\ncompr->device = device;\r\ncompr->direction = dirn;\r\nreturn snd_device_new(card, SNDRV_DEV_COMPRESS, compr, &ops);\r\n}\r\nstatic int snd_compress_add_device(struct snd_compr *device)\r\n{\r\nint ret;\r\nif (!device->card)\r\nreturn -EINVAL;\r\nret = snd_card_register(device->card);\r\nif (ret)\r\ngoto out;\r\nreturn 0;\r\nout:\r\npr_err("failed with %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int snd_compress_remove_device(struct snd_compr *device)\r\n{\r\nreturn snd_card_free(device->card);\r\n}\r\nint snd_compress_register(struct snd_compr *device)\r\n{\r\nint retval;\r\nif (device->name == NULL || device->dev == NULL || device->ops == NULL)\r\nreturn -EINVAL;\r\npr_debug("Registering compressed device %s\n", device->name);\r\nif (snd_BUG_ON(!device->ops->open))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(!device->ops->free))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(!device->ops->set_params))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(!device->ops->trigger))\r\nreturn -EINVAL;\r\nmutex_init(&device->lock);\r\nmutex_lock(&device_mutex);\r\nretval = snd_compress_add_device(device);\r\nmutex_unlock(&device_mutex);\r\nreturn retval;\r\n}\r\nint snd_compress_deregister(struct snd_compr *device)\r\n{\r\npr_debug("Removing compressed device %s\n", device->name);\r\nmutex_lock(&device_mutex);\r\nsnd_compress_remove_device(device);\r\nmutex_unlock(&device_mutex);\r\nreturn 0;\r\n}\r\nstatic int __init snd_compress_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit snd_compress_exit(void)\r\n{\r\n}
