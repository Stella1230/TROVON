static int _read_reg(struct w1_slave *sl, u8 address, unsigned char* buf)\r\n{\r\nu8 wrbuf[3];\r\ndev_dbg(&sl->dev,\r\n"Reading with slave: %p, reg addr: %0#4x, buff addr: %p",\r\nsl, (unsigned int)address, buf);\r\nif (!buf)\r\nreturn -EINVAL;\r\nmutex_lock(&sl->master->mutex);\r\ndev_dbg(&sl->dev, "mutex locked");\r\nif (w1_reset_select_slave(sl)) {\r\nmutex_unlock(&sl->master->mutex);\r\nreturn -EIO;\r\n}\r\nwrbuf[0] = W1_F29_FUNC_READ_PIO_REGS;\r\nwrbuf[1] = address;\r\nwrbuf[2] = 0;\r\nw1_write_block(sl->master, wrbuf, 3);\r\n*buf = w1_read_8(sl->master);\r\nmutex_unlock(&sl->master->mutex);\r\ndev_dbg(&sl->dev, "mutex unlocked");\r\nreturn 1;\r\n}\r\nstatic ssize_t w1_f29_read_state(\r\nstruct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\ndev_dbg(&kobj_to_w1_slave(kobj)->dev,\r\n"Reading %s kobj: %p, off: %0#10x, count: %zu, buff addr: %p",\r\nbin_attr->attr.name, kobj, (unsigned int)off, count, buf);\r\nif (count != 1 || off != 0)\r\nreturn -EFAULT;\r\nreturn _read_reg(kobj_to_w1_slave(kobj), W1_F29_REG_LOGIG_STATE, buf);\r\n}\r\nstatic ssize_t w1_f29_read_output(\r\nstruct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\ndev_dbg(&kobj_to_w1_slave(kobj)->dev,\r\n"Reading %s kobj: %p, off: %0#10x, count: %zu, buff addr: %p",\r\nbin_attr->attr.name, kobj, (unsigned int)off, count, buf);\r\nif (count != 1 || off != 0)\r\nreturn -EFAULT;\r\nreturn _read_reg(kobj_to_w1_slave(kobj),\r\nW1_F29_REG_OUTPUT_LATCH_STATE, buf);\r\n}\r\nstatic ssize_t w1_f29_read_activity(\r\nstruct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\ndev_dbg(&kobj_to_w1_slave(kobj)->dev,\r\n"Reading %s kobj: %p, off: %0#10x, count: %zu, buff addr: %p",\r\nbin_attr->attr.name, kobj, (unsigned int)off, count, buf);\r\nif (count != 1 || off != 0)\r\nreturn -EFAULT;\r\nreturn _read_reg(kobj_to_w1_slave(kobj),\r\nW1_F29_REG_ACTIVITY_LATCH_STATE, buf);\r\n}\r\nstatic ssize_t w1_f29_read_cond_search_mask(\r\nstruct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\ndev_dbg(&kobj_to_w1_slave(kobj)->dev,\r\n"Reading %s kobj: %p, off: %0#10x, count: %zu, buff addr: %p",\r\nbin_attr->attr.name, kobj, (unsigned int)off, count, buf);\r\nif (count != 1 || off != 0)\r\nreturn -EFAULT;\r\nreturn _read_reg(kobj_to_w1_slave(kobj),\r\nW1_F29_REG_COND_SEARCH_SELECT_MASK, buf);\r\n}\r\nstatic ssize_t w1_f29_read_cond_search_polarity(\r\nstruct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nif (count != 1 || off != 0)\r\nreturn -EFAULT;\r\nreturn _read_reg(kobj_to_w1_slave(kobj),\r\nW1_F29_REG_COND_SEARCH_POL_SELECT, buf);\r\n}\r\nstatic ssize_t w1_f29_read_status_control(\r\nstruct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nif (count != 1 || off != 0)\r\nreturn -EFAULT;\r\nreturn _read_reg(kobj_to_w1_slave(kobj),\r\nW1_F29_REG_CONTROL_AND_STATUS, buf);\r\n}\r\nstatic ssize_t w1_f29_write_output(\r\nstruct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct w1_slave *sl = kobj_to_w1_slave(kobj);\r\nu8 w1_buf[3];\r\nu8 readBack;\r\nunsigned int retries = W1_F29_RETRIES;\r\nif (count != 1 || off != 0)\r\nreturn -EFAULT;\r\ndev_dbg(&sl->dev, "locking mutex for write_output");\r\nmutex_lock(&sl->master->mutex);\r\ndev_dbg(&sl->dev, "mutex locked");\r\nif (w1_reset_select_slave(sl))\r\ngoto error;\r\nwhile (retries--) {\r\nw1_buf[0] = W1_F29_FUNC_CHANN_ACCESS_WRITE;\r\nw1_buf[1] = *buf;\r\nw1_buf[2] = ~(*buf);\r\nw1_write_block(sl->master, w1_buf, 3);\r\nreadBack = w1_read_8(sl->master);\r\nif (w1_reset_resume_command(sl->master))\r\ngoto error;\r\nif (readBack != 0xAA) {\r\ncontinue;\r\n}\r\nw1_buf[0] = W1_F29_FUNC_READ_PIO_REGS;\r\nw1_buf[1] = W1_F29_REG_OUTPUT_LATCH_STATE;\r\nw1_buf[2] = 0;\r\nw1_write_block(sl->master, w1_buf, 3);\r\nif (w1_read_8(sl->master) == *buf) {\r\nmutex_unlock(&sl->master->mutex);\r\ndev_dbg(&sl->dev,\r\n"mutex unlocked, retries:%d", retries);\r\nreturn 1;\r\n}\r\n}\r\nerror:\r\nmutex_unlock(&sl->master->mutex);\r\ndev_dbg(&sl->dev, "mutex unlocked in error, retries:%d", retries);\r\nreturn -EIO;\r\n}\r\nstatic ssize_t w1_f29_write_activity(\r\nstruct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct w1_slave *sl = kobj_to_w1_slave(kobj);\r\nunsigned int retries = W1_F29_RETRIES;\r\nif (count != 1 || off != 0)\r\nreturn -EFAULT;\r\nmutex_lock(&sl->master->mutex);\r\nif (w1_reset_select_slave(sl))\r\ngoto error;\r\nwhile (retries--) {\r\nw1_write_8(sl->master, W1_F29_FUNC_RESET_ACTIVITY_LATCHES);\r\nif (w1_read_8(sl->master) == W1_F29_SUCCESS_CONFIRM_BYTE) {\r\nmutex_unlock(&sl->master->mutex);\r\nreturn 1;\r\n}\r\nif (w1_reset_resume_command(sl->master))\r\ngoto error;\r\n}\r\nerror:\r\nmutex_unlock(&sl->master->mutex);\r\nreturn -EIO;\r\n}\r\nstatic ssize_t w1_f29_write_status_control(\r\nstruct file *filp,\r\nstruct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf,\r\nloff_t off,\r\nsize_t count)\r\n{\r\nstruct w1_slave *sl = kobj_to_w1_slave(kobj);\r\nu8 w1_buf[4];\r\nunsigned int retries = W1_F29_RETRIES;\r\nif (count != 1 || off != 0)\r\nreturn -EFAULT;\r\nmutex_lock(&sl->master->mutex);\r\nif (w1_reset_select_slave(sl))\r\ngoto error;\r\nwhile (retries--) {\r\nw1_buf[0] = W1_F29_FUNC_WRITE_COND_SEARCH_REG;\r\nw1_buf[1] = W1_F29_REG_CONTROL_AND_STATUS;\r\nw1_buf[2] = 0;\r\nw1_buf[3] = *buf;\r\nw1_write_block(sl->master, w1_buf, 4);\r\nif (w1_reset_resume_command(sl->master))\r\ngoto error;\r\nw1_buf[0] = W1_F29_FUNC_READ_PIO_REGS;\r\nw1_buf[1] = W1_F29_REG_CONTROL_AND_STATUS;\r\nw1_buf[2] = 0;\r\nw1_write_block(sl->master, w1_buf, 3);\r\nif (w1_read_8(sl->master) == *buf) {\r\nmutex_unlock(&sl->master->mutex);\r\nreturn 1;\r\n}\r\n}\r\nerror:\r\nmutex_unlock(&sl->master->mutex);\r\nreturn -EIO;\r\n}\r\nstatic int w1_f29_add_slave(struct w1_slave *sl)\r\n{\r\nint err = 0;\r\nint i;\r\nfor (i = 0; i < NB_SYSFS_BIN_FILES && !err; ++i)\r\nerr = sysfs_create_bin_file(\r\n&sl->dev.kobj,\r\n&(w1_f29_sysfs_bin_files[i]));\r\nif (err)\r\nwhile (--i >= 0)\r\nsysfs_remove_bin_file(&sl->dev.kobj,\r\n&(w1_f29_sysfs_bin_files[i]));\r\nreturn err;\r\n}\r\nstatic void w1_f29_remove_slave(struct w1_slave *sl)\r\n{\r\nint i;\r\nfor (i = NB_SYSFS_BIN_FILES - 1; i >= 0; --i)\r\nsysfs_remove_bin_file(&sl->dev.kobj,\r\n&(w1_f29_sysfs_bin_files[i]));\r\n}\r\nstatic int __init w1_f29_init(void)\r\n{\r\nreturn w1_register_family(&w1_family_29);\r\n}\r\nstatic void __exit w1_f29_exit(void)\r\n{\r\nw1_unregister_family(&w1_family_29);\r\n}
