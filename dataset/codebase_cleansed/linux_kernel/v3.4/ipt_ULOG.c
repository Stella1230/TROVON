static void ulog_send(unsigned int nlgroupnum)\r\n{\r\nulog_buff_t *ub = &ulog_buffers[nlgroupnum];\r\nif (timer_pending(&ub->timer)) {\r\npr_debug("ulog_send: timer was pending, deleting\n");\r\ndel_timer(&ub->timer);\r\n}\r\nif (!ub->skb) {\r\npr_debug("ulog_send: nothing to send\n");\r\nreturn;\r\n}\r\nif (ub->qlen > 1)\r\nub->lastnlh->nlmsg_type = NLMSG_DONE;\r\nNETLINK_CB(ub->skb).dst_group = nlgroupnum + 1;\r\npr_debug("throwing %d packets to netlink group %u\n",\r\nub->qlen, nlgroupnum + 1);\r\nnetlink_broadcast(nflognl, ub->skb, 0, nlgroupnum + 1, GFP_ATOMIC);\r\nub->qlen = 0;\r\nub->skb = NULL;\r\nub->lastnlh = NULL;\r\n}\r\nstatic void ulog_timer(unsigned long data)\r\n{\r\npr_debug("timer function called, calling ulog_send\n");\r\nspin_lock_bh(&ulog_lock);\r\nulog_send(data);\r\nspin_unlock_bh(&ulog_lock);\r\n}\r\nstatic struct sk_buff *ulog_alloc_skb(unsigned int size)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned int n;\r\nn = max(size, nlbufsiz);\r\nskb = alloc_skb(n, GFP_ATOMIC | __GFP_NOWARN);\r\nif (!skb) {\r\nif (n > size) {\r\nskb = alloc_skb(size, GFP_ATOMIC);\r\nif (!skb)\r\npr_debug("cannot even allocate %ub\n", size);\r\n}\r\n}\r\nreturn skb;\r\n}\r\nstatic void ipt_ulog_packet(unsigned int hooknum,\r\nconst struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nconst struct ipt_ulog_info *loginfo,\r\nconst char *prefix)\r\n{\r\nulog_buff_t *ub;\r\nulog_packet_msg_t *pm;\r\nsize_t size, copy_len;\r\nstruct nlmsghdr *nlh;\r\nstruct timeval tv;\r\nunsigned int groupnum = ffs(loginfo->nl_group) - 1;\r\nif (loginfo->copy_range == 0 || loginfo->copy_range > skb->len)\r\ncopy_len = skb->len;\r\nelse\r\ncopy_len = loginfo->copy_range;\r\nsize = NLMSG_SPACE(sizeof(*pm) + copy_len);\r\nub = &ulog_buffers[groupnum];\r\nspin_lock_bh(&ulog_lock);\r\nif (!ub->skb) {\r\nif (!(ub->skb = ulog_alloc_skb(size)))\r\ngoto alloc_failure;\r\n} else if (ub->qlen >= loginfo->qthreshold ||\r\nsize > skb_tailroom(ub->skb)) {\r\nulog_send(groupnum);\r\nif (!(ub->skb = ulog_alloc_skb(size)))\r\ngoto alloc_failure;\r\n}\r\npr_debug("qlen %d, qthreshold %Zu\n", ub->qlen, loginfo->qthreshold);\r\nnlh = NLMSG_PUT(ub->skb, 0, ub->qlen, ULOG_NL_EVENT,\r\nsizeof(*pm)+copy_len);\r\nub->qlen++;\r\npm = NLMSG_DATA(nlh);\r\nif (skb->tstamp.tv64 == 0)\r\n__net_timestamp((struct sk_buff *)skb);\r\npm->data_len = copy_len;\r\ntv = ktime_to_timeval(skb->tstamp);\r\nput_unaligned(tv.tv_sec, &pm->timestamp_sec);\r\nput_unaligned(tv.tv_usec, &pm->timestamp_usec);\r\nput_unaligned(skb->mark, &pm->mark);\r\npm->hook = hooknum;\r\nif (prefix != NULL)\r\nstrncpy(pm->prefix, prefix, sizeof(pm->prefix));\r\nelse if (loginfo->prefix[0] != '\0')\r\nstrncpy(pm->prefix, loginfo->prefix, sizeof(pm->prefix));\r\nelse\r\n*(pm->prefix) = '\0';\r\nif (in && in->hard_header_len > 0 &&\r\nskb->mac_header != skb->network_header &&\r\nin->hard_header_len <= ULOG_MAC_LEN) {\r\nmemcpy(pm->mac, skb_mac_header(skb), in->hard_header_len);\r\npm->mac_len = in->hard_header_len;\r\n} else\r\npm->mac_len = 0;\r\nif (in)\r\nstrncpy(pm->indev_name, in->name, sizeof(pm->indev_name));\r\nelse\r\npm->indev_name[0] = '\0';\r\nif (out)\r\nstrncpy(pm->outdev_name, out->name, sizeof(pm->outdev_name));\r\nelse\r\npm->outdev_name[0] = '\0';\r\nif (skb_copy_bits(skb, 0, pm->payload, copy_len) < 0)\r\nBUG();\r\nif (ub->qlen > 1)\r\nub->lastnlh->nlmsg_flags |= NLM_F_MULTI;\r\nub->lastnlh = nlh;\r\nif (!timer_pending(&ub->timer)) {\r\nub->timer.expires = jiffies + flushtimeout * HZ / 100;\r\nadd_timer(&ub->timer);\r\n}\r\nif (ub->qlen >= loginfo->qthreshold) {\r\nif (loginfo->qthreshold > 1)\r\nnlh->nlmsg_type = NLMSG_DONE;\r\nulog_send(groupnum);\r\n}\r\nspin_unlock_bh(&ulog_lock);\r\nreturn;\r\nnlmsg_failure:\r\npr_debug("error during NLMSG_PUT\n");\r\nalloc_failure:\r\npr_debug("Error building netlink message\n");\r\nspin_unlock_bh(&ulog_lock);\r\n}\r\nstatic unsigned int\r\nulog_tg(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nipt_ulog_packet(par->hooknum, skb, par->in, par->out,\r\npar->targinfo, NULL);\r\nreturn XT_CONTINUE;\r\n}\r\nstatic void ipt_logfn(u_int8_t pf,\r\nunsigned int hooknum,\r\nconst struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nconst struct nf_loginfo *li,\r\nconst char *prefix)\r\n{\r\nstruct ipt_ulog_info loginfo;\r\nif (!li || li->type != NF_LOG_TYPE_ULOG) {\r\nloginfo.nl_group = ULOG_DEFAULT_NLGROUP;\r\nloginfo.copy_range = 0;\r\nloginfo.qthreshold = ULOG_DEFAULT_QTHRESHOLD;\r\nloginfo.prefix[0] = '\0';\r\n} else {\r\nloginfo.nl_group = li->u.ulog.group;\r\nloginfo.copy_range = li->u.ulog.copy_len;\r\nloginfo.qthreshold = li->u.ulog.qthreshold;\r\nstrlcpy(loginfo.prefix, prefix, sizeof(loginfo.prefix));\r\n}\r\nipt_ulog_packet(hooknum, skb, in, out, &loginfo, prefix);\r\n}\r\nstatic int ulog_tg_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct ipt_ulog_info *loginfo = par->targinfo;\r\nif (loginfo->prefix[sizeof(loginfo->prefix) - 1] != '\0') {\r\npr_debug("prefix not null-terminated\n");\r\nreturn -EINVAL;\r\n}\r\nif (loginfo->qthreshold > ULOG_MAX_QLEN) {\r\npr_debug("queue threshold %Zu > MAX_QLEN\n",\r\nloginfo->qthreshold);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ulog_tg_compat_from_user(void *dst, const void *src)\r\n{\r\nconst struct compat_ipt_ulog_info *cl = src;\r\nstruct ipt_ulog_info l = {\r\n.nl_group = cl->nl_group,\r\n.copy_range = cl->copy_range,\r\n.qthreshold = cl->qthreshold,\r\n};\r\nmemcpy(l.prefix, cl->prefix, sizeof(l.prefix));\r\nmemcpy(dst, &l, sizeof(l));\r\n}\r\nstatic int ulog_tg_compat_to_user(void __user *dst, const void *src)\r\n{\r\nconst struct ipt_ulog_info *l = src;\r\nstruct compat_ipt_ulog_info cl = {\r\n.nl_group = l->nl_group,\r\n.copy_range = l->copy_range,\r\n.qthreshold = l->qthreshold,\r\n};\r\nmemcpy(cl.prefix, l->prefix, sizeof(cl.prefix));\r\nreturn copy_to_user(dst, &cl, sizeof(cl)) ? -EFAULT : 0;\r\n}\r\nstatic int __init ulog_tg_init(void)\r\n{\r\nint ret, i;\r\npr_debug("init module\n");\r\nif (nlbufsiz > 128*1024) {\r\npr_warning("Netlink buffer has to be <= 128kB\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ULOG_MAXNLGROUPS; i++)\r\nsetup_timer(&ulog_buffers[i].timer, ulog_timer, i);\r\nnflognl = netlink_kernel_create(&init_net,\r\nNETLINK_NFLOG, ULOG_MAXNLGROUPS, NULL,\r\nNULL, THIS_MODULE);\r\nif (!nflognl)\r\nreturn -ENOMEM;\r\nret = xt_register_target(&ulog_tg_reg);\r\nif (ret < 0) {\r\nnetlink_kernel_release(nflognl);\r\nreturn ret;\r\n}\r\nif (nflog)\r\nnf_log_register(NFPROTO_IPV4, &ipt_ulog_logger);\r\nreturn 0;\r\n}\r\nstatic void __exit ulog_tg_exit(void)\r\n{\r\nulog_buff_t *ub;\r\nint i;\r\npr_debug("cleanup_module\n");\r\nif (nflog)\r\nnf_log_unregister(&ipt_ulog_logger);\r\nxt_unregister_target(&ulog_tg_reg);\r\nnetlink_kernel_release(nflognl);\r\nfor (i = 0; i < ULOG_MAXNLGROUPS; i++) {\r\nub = &ulog_buffers[i];\r\nif (timer_pending(&ub->timer)) {\r\npr_debug("timer was pending, deleting\n");\r\ndel_timer(&ub->timer);\r\n}\r\nif (ub->skb) {\r\nkfree_skb(ub->skb);\r\nub->skb = NULL;\r\n}\r\n}\r\n}
