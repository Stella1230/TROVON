static int hid_lg4ff_play(struct input_dev *dev, void *data, struct ff_effect *effect)\r\n{\r\nstruct hid_device *hid = input_get_drvdata(dev);\r\nstruct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\r\nstruct hid_report *report = list_entry(report_list->next, struct hid_report, list);\r\nint x;\r\n#define CLAMP(x) if (x < 0) x = 0; if (x > 0xff) x = 0xff\r\nswitch (effect->type) {\r\ncase FF_CONSTANT:\r\nx = effect->u.ramp.start_level + 0x80;\r\nCLAMP(x);\r\nreport->field[0]->value[0] = 0x11;\r\nreport->field[0]->value[1] = 0x08;\r\nreport->field[0]->value[2] = x;\r\nreport->field[0]->value[3] = 0x80;\r\nreport->field[0]->value[4] = 0x00;\r\nreport->field[0]->value[5] = 0x00;\r\nreport->field[0]->value[6] = 0x00;\r\nusbhid_submit_report(hid, report, USB_DIR_OUT);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hid_lg4ff_set_autocenter_default(struct input_dev *dev, u16 magnitude)\r\n{\r\nstruct hid_device *hid = input_get_drvdata(dev);\r\nstruct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\r\nstruct hid_report *report = list_entry(report_list->next, struct hid_report, list);\r\nreport->field[0]->value[0] = 0xfe;\r\nreport->field[0]->value[1] = 0x0d;\r\nreport->field[0]->value[2] = magnitude >> 13;\r\nreport->field[0]->value[3] = magnitude >> 13;\r\nreport->field[0]->value[4] = magnitude >> 8;\r\nreport->field[0]->value[5] = 0x00;\r\nreport->field[0]->value[6] = 0x00;\r\nusbhid_submit_report(hid, report, USB_DIR_OUT);\r\n}\r\nstatic void hid_lg4ff_set_autocenter_ffex(struct input_dev *dev, u16 magnitude)\r\n{\r\nstruct hid_device *hid = input_get_drvdata(dev);\r\nstruct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\r\nstruct hid_report *report = list_entry(report_list->next, struct hid_report, list);\r\nmagnitude = magnitude * 90 / 65535;\r\nreport->field[0]->value[0] = 0xfe;\r\nreport->field[0]->value[1] = 0x03;\r\nreport->field[0]->value[2] = magnitude >> 14;\r\nreport->field[0]->value[3] = magnitude >> 14;\r\nreport->field[0]->value[4] = magnitude;\r\nreport->field[0]->value[5] = 0x00;\r\nreport->field[0]->value[6] = 0x00;\r\nusbhid_submit_report(hid, report, USB_DIR_OUT);\r\n}\r\nstatic void hid_lg4ff_set_range_g25(struct hid_device *hid, u16 range)\r\n{\r\nstruct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\r\nstruct hid_report *report = list_entry(report_list->next, struct hid_report, list);\r\ndbg_hid("G25/G27/DFGT: setting range to %u\n", range);\r\nreport->field[0]->value[0] = 0xf8;\r\nreport->field[0]->value[1] = 0x81;\r\nreport->field[0]->value[2] = range & 0x00ff;\r\nreport->field[0]->value[3] = (range & 0xff00) >> 8;\r\nreport->field[0]->value[4] = 0x00;\r\nreport->field[0]->value[5] = 0x00;\r\nreport->field[0]->value[6] = 0x00;\r\nusbhid_submit_report(hid, report, USB_DIR_OUT);\r\n}\r\nstatic void hid_lg4ff_set_range_dfp(struct hid_device *hid, __u16 range)\r\n{\r\nstruct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\r\nstruct hid_report *report = list_entry(report_list->next, struct hid_report, list);\r\nint start_left, start_right, full_range;\r\ndbg_hid("Driving Force Pro: setting range to %u\n", range);\r\nreport->field[0]->value[0] = 0xf8;\r\nreport->field[0]->value[1] = 0x00;\r\nreport->field[0]->value[2] = 0x00;\r\nreport->field[0]->value[3] = 0x00;\r\nreport->field[0]->value[4] = 0x00;\r\nreport->field[0]->value[5] = 0x00;\r\nreport->field[0]->value[6] = 0x00;\r\nif (range > 200) {\r\nreport->field[0]->value[1] = 0x03;\r\nfull_range = 900;\r\n} else {\r\nreport->field[0]->value[1] = 0x02;\r\nfull_range = 200;\r\n}\r\nusbhid_submit_report(hid, report, USB_DIR_OUT);\r\nreport->field[0]->value[0] = 0x81;\r\nreport->field[0]->value[1] = 0x0b;\r\nreport->field[0]->value[2] = 0x00;\r\nreport->field[0]->value[3] = 0x00;\r\nreport->field[0]->value[4] = 0x00;\r\nreport->field[0]->value[5] = 0x00;\r\nreport->field[0]->value[6] = 0x00;\r\nif (range == 200 || range == 900) {\r\nusbhid_submit_report(hid, report, USB_DIR_OUT);\r\nreturn;\r\n}\r\nstart_left = (((full_range - range + 1) * 2047) / full_range);\r\nstart_right = 0xfff - start_left;\r\nreport->field[0]->value[2] = start_left >> 4;\r\nreport->field[0]->value[3] = start_right >> 4;\r\nreport->field[0]->value[4] = 0xff;\r\nreport->field[0]->value[5] = (start_right & 0xe) << 4 | (start_left & 0xe);\r\nreport->field[0]->value[6] = 0xff;\r\nusbhid_submit_report(hid, report, USB_DIR_OUT);\r\n}\r\nstatic void hid_lg4ff_switch_native(struct hid_device *hid, const struct lg4ff_native_cmd *cmd)\r\n{\r\nstruct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\r\nstruct hid_report *report = list_entry(report_list->next, struct hid_report, list);\r\n__u8 i, j;\r\nj = 0;\r\nwhile (j < 7*cmd->cmd_num) {\r\nfor (i = 0; i < 7; i++)\r\nreport->field[0]->value[i] = cmd->cmd[j++];\r\nusbhid_submit_report(hid, report, USB_DIR_OUT);\r\n}\r\n}\r\nstatic ssize_t lg4ff_range_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct lg4ff_device_entry *uninitialized_var(entry);\r\nstruct list_head *h;\r\nstruct hid_device *hid = to_hid_device(dev);\r\nsize_t count;\r\nlist_for_each(h, &device_list.list) {\r\nentry = list_entry(h, struct lg4ff_device_entry, list);\r\nif (strcmp(entry->device_id, (&hid->dev)->kobj.name) == 0)\r\nbreak;\r\n}\r\nif (h == &device_list.list) {\r\ndbg_hid("Device not found!");\r\nreturn 0;\r\n}\r\ncount = scnprintf(buf, PAGE_SIZE, "%u\n", entry->range);\r\nreturn count;\r\n}\r\nstatic ssize_t lg4ff_range_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct lg4ff_device_entry *uninitialized_var(entry);\r\nstruct list_head *h;\r\nstruct hid_device *hid = to_hid_device(dev);\r\n__u16 range = simple_strtoul(buf, NULL, 10);\r\nlist_for_each(h, &device_list.list) {\r\nentry = list_entry(h, struct lg4ff_device_entry, list);\r\nif (strcmp(entry->device_id, (&hid->dev)->kobj.name) == 0)\r\nbreak;\r\n}\r\nif (h == &device_list.list) {\r\ndbg_hid("Device not found!");\r\nreturn count;\r\n}\r\nif (range == 0)\r\nrange = entry->max_range;\r\nif (entry->set_range != NULL && range >= entry->min_range && range <= entry->max_range) {\r\nentry->set_range(hid, range);\r\nentry->range = range;\r\n}\r\nreturn count;\r\n}\r\nint lg4ff_init(struct hid_device *hid)\r\n{\r\nstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\r\nstruct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;\r\nstruct input_dev *dev = hidinput->input;\r\nstruct hid_report *report;\r\nstruct hid_field *field;\r\nstruct lg4ff_device_entry *entry;\r\nstruct usb_device_descriptor *udesc;\r\nint error, i, j;\r\n__u16 bcdDevice, rev_maj, rev_min;\r\nif (list_empty(report_list)) {\r\nhid_err(hid, "No output report found\n");\r\nreturn -1;\r\n}\r\nreport = list_entry(report_list->next, struct hid_report, list);\r\nif (!report) {\r\nhid_err(hid, "NULL output report\n");\r\nreturn -1;\r\n}\r\nfield = report->field[0];\r\nif (!field) {\r\nhid_err(hid, "NULL field\n");\r\nreturn -1;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(lg4ff_devices); i++) {\r\nif (hid->product == lg4ff_devices[i].product_id) {\r\ndbg_hid("Found compatible device, product ID %04X\n", lg4ff_devices[i].product_id);\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(lg4ff_devices)) {\r\nhid_err(hid, "Device is not supported by lg4ff driver. If you think it should be, consider reporting a bug to"\r\n"LKML, Simon Wood <simon@mungewell.org> or Michal Maly <madcatxster@gmail.com>\n");\r\nreturn -1;\r\n}\r\nudesc = &(hid_to_usb_dev(hid)->descriptor);\r\nif (!udesc) {\r\nhid_err(hid, "NULL USB device descriptor\n");\r\nreturn -1;\r\n}\r\nbcdDevice = le16_to_cpu(udesc->bcdDevice);\r\nrev_maj = bcdDevice >> 8;\r\nrev_min = bcdDevice & 0xff;\r\nif (lg4ff_devices[i].product_id == USB_DEVICE_ID_LOGITECH_WHEEL) {\r\ndbg_hid("Generic wheel detected, can it do native?\n");\r\ndbg_hid("USB revision: %2x.%02x\n", rev_maj, rev_min);\r\nfor (j = 0; j < ARRAY_SIZE(lg4ff_revs); j++) {\r\nif (lg4ff_revs[j].rev_maj == rev_maj && lg4ff_revs[j].rev_min == rev_min) {\r\nhid_lg4ff_switch_native(hid, lg4ff_revs[j].command);\r\nhid_info(hid, "Switched to native mode\n");\r\n}\r\n}\r\n}\r\nfor (j = 0; lg4ff_devices[i].ff_effects[j] >= 0; j++)\r\nset_bit(lg4ff_devices[i].ff_effects[j], dev->ffbit);\r\nerror = input_ff_create_memless(dev, NULL, hid_lg4ff_play);\r\nif (error)\r\nreturn error;\r\nif (test_bit(FF_AUTOCENTER, dev->ffbit)) {\r\nif(rev_maj == FFEX_REV_MAJ && rev_min == FFEX_REV_MIN)\r\ndev->ff->set_autocenter = hid_lg4ff_set_autocenter_ffex;\r\nelse\r\ndev->ff->set_autocenter = hid_lg4ff_set_autocenter_default;\r\ndev->ff->set_autocenter(dev, 0);\r\n}\r\nif (!list_inited) {\r\nINIT_LIST_HEAD(&device_list.list);\r\nlist_inited = 1;\r\n}\r\nentry = kzalloc(sizeof(struct lg4ff_device_entry), GFP_KERNEL);\r\nif (!entry) {\r\nhid_err(hid, "Cannot add device, insufficient memory.\n");\r\nreturn -ENOMEM;\r\n}\r\nentry->device_id = kstrdup((&hid->dev)->kobj.name, GFP_KERNEL);\r\nif (!entry->device_id) {\r\nhid_err(hid, "Cannot set device_id, insufficient memory.\n");\r\nkfree(entry);\r\nreturn -ENOMEM;\r\n}\r\nentry->min_range = lg4ff_devices[i].min_range;\r\nentry->max_range = lg4ff_devices[i].max_range;\r\nentry->set_range = lg4ff_devices[i].set_range;\r\nlist_add(&entry->list, &device_list.list);\r\nerror = device_create_file(&hid->dev, &dev_attr_range);\r\nif (error)\r\nreturn error;\r\ndbg_hid("sysfs interface created\n");\r\nentry->range = entry->max_range;\r\nif (entry->set_range != NULL)\r\nentry->set_range(hid, entry->range);\r\nhid_info(hid, "Force feedback for Logitech Speed Force Wireless by Simon Wood <simon@mungewell.org>\n");\r\nreturn 0;\r\n}\r\nint lg4ff_deinit(struct hid_device *hid)\r\n{\r\nbool found = 0;\r\nstruct lg4ff_device_entry *entry;\r\nstruct list_head *h, *g;\r\nlist_for_each_safe(h, g, &device_list.list) {\r\nentry = list_entry(h, struct lg4ff_device_entry, list);\r\nif (strcmp(entry->device_id, (&hid->dev)->kobj.name) == 0) {\r\nlist_del(h);\r\nkfree(entry->device_id);\r\nkfree(entry);\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\ndbg_hid("Device entry not found!\n");\r\nreturn -1;\r\n}\r\ndevice_remove_file(&hid->dev, &dev_attr_range);\r\ndbg_hid("Device successfully unregistered\n");\r\nreturn 0;\r\n}
