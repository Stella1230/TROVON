struct usb_request *alloc_ep_req(struct usb_ep *ep)\r\n{\r\nstruct usb_request *req;\r\nreq = usb_ep_alloc_request(ep, GFP_ATOMIC);\r\nif (req) {\r\nreq->length = buflen;\r\nreq->buf = kmalloc(buflen, GFP_ATOMIC);\r\nif (!req->buf) {\r\nusb_ep_free_request(ep, req);\r\nreq = NULL;\r\n}\r\n}\r\nreturn req;\r\n}\r\nvoid free_ep_req(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nkfree(req->buf);\r\nusb_ep_free_request(ep, req);\r\n}\r\nstatic void disable_ep(struct usb_composite_dev *cdev, struct usb_ep *ep)\r\n{\r\nint value;\r\nif (ep->driver_data) {\r\nvalue = usb_ep_disable(ep);\r\nif (value < 0)\r\nDBG(cdev, "disable %s --> %d\n",\r\nep->name, value);\r\nep->driver_data = NULL;\r\n}\r\n}\r\nvoid disable_endpoints(struct usb_composite_dev *cdev,\r\nstruct usb_ep *in, struct usb_ep *out)\r\n{\r\ndisable_ep(cdev, in);\r\ndisable_ep(cdev, out);\r\n}\r\nstatic void zero_autoresume(unsigned long _c)\r\n{\r\nstruct usb_composite_dev *cdev = (void *)_c;\r\nstruct usb_gadget *g = cdev->gadget;\r\nif (!cdev->config)\r\nreturn;\r\nif (g->speed != USB_SPEED_UNKNOWN) {\r\nint status = usb_gadget_wakeup(g);\r\nINFO(cdev, "%s --> %d\n", __func__, status);\r\n}\r\n}\r\nstatic void zero_suspend(struct usb_composite_dev *cdev)\r\n{\r\nif (cdev->gadget->speed == USB_SPEED_UNKNOWN)\r\nreturn;\r\nif (autoresume) {\r\nmod_timer(&autoresume_timer, jiffies + (HZ * autoresume));\r\nDBG(cdev, "suspend, wakeup in %d seconds\n", autoresume);\r\n} else\r\nDBG(cdev, "%s\n", __func__);\r\n}\r\nstatic void zero_resume(struct usb_composite_dev *cdev)\r\n{\r\nDBG(cdev, "%s\n", __func__);\r\ndel_timer(&autoresume_timer);\r\n}\r\nstatic int __init zero_bind(struct usb_composite_dev *cdev)\r\n{\r\nint gcnum;\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nint id;\r\nid = usb_string_id(cdev);\r\nif (id < 0)\r\nreturn id;\r\nstrings_dev[STRING_MANUFACTURER_IDX].id = id;\r\ndevice_desc.iManufacturer = id;\r\nid = usb_string_id(cdev);\r\nif (id < 0)\r\nreturn id;\r\nstrings_dev[STRING_PRODUCT_IDX].id = id;\r\ndevice_desc.iProduct = id;\r\nid = usb_string_id(cdev);\r\nif (id < 0)\r\nreturn id;\r\nstrings_dev[STRING_SERIAL_IDX].id = id;\r\ndevice_desc.iSerialNumber = id;\r\nsetup_timer(&autoresume_timer, zero_autoresume, (unsigned long) cdev);\r\nif (loopdefault) {\r\nloopback_add(cdev, autoresume != 0);\r\nsourcesink_add(cdev, autoresume != 0);\r\n} else {\r\nsourcesink_add(cdev, autoresume != 0);\r\nloopback_add(cdev, autoresume != 0);\r\n}\r\ngcnum = usb_gadget_controller_number(gadget);\r\nif (gcnum >= 0)\r\ndevice_desc.bcdDevice = cpu_to_le16(0x0200 + gcnum);\r\nelse {\r\npr_warning("%s: controller '%s' not recognized\n",\r\nlongname, gadget->name);\r\ndevice_desc.bcdDevice = cpu_to_le16(0x9999);\r\n}\r\nINFO(cdev, "%s, version: " DRIVER_VERSION "\n", longname);\r\nsnprintf(manufacturer, sizeof manufacturer, "%s %s with %s",\r\ninit_utsname()->sysname, init_utsname()->release,\r\ngadget->name);\r\nreturn 0;\r\n}\r\nstatic int zero_unbind(struct usb_composite_dev *cdev)\r\n{\r\ndel_timer_sync(&autoresume_timer);\r\nreturn 0;\r\n}\r\nstatic int __init init(void)\r\n{\r\nreturn usb_composite_probe(&zero_driver, zero_bind);\r\n}\r\nstatic void __exit cleanup(void)\r\n{\r\nusb_composite_unregister(&zero_driver);\r\n}
