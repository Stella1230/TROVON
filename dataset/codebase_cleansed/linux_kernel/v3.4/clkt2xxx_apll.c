static int omap2_clk_apll_enable(struct clk *clk, u32 status_mask)\r\n{\r\nu32 cval, apll_mask;\r\napll_mask = EN_APLL_LOCKED << clk->enable_bit;\r\ncval = omap2_cm_read_mod_reg(PLL_MOD, CM_CLKEN);\r\nif ((cval & apll_mask) == apll_mask)\r\nreturn 0;\r\ncval &= ~apll_mask;\r\ncval |= apll_mask;\r\nomap2_cm_write_mod_reg(cval, PLL_MOD, CM_CLKEN);\r\nomap2_cm_wait_idlest(cm_idlest_pll, status_mask,\r\nOMAP24XX_CM_IDLEST_VAL, clk->name);\r\nreturn 0;\r\n}\r\nstatic int omap2_clk_apll96_enable(struct clk *clk)\r\n{\r\nreturn omap2_clk_apll_enable(clk, OMAP24XX_ST_96M_APLL_MASK);\r\n}\r\nstatic int omap2_clk_apll54_enable(struct clk *clk)\r\n{\r\nreturn omap2_clk_apll_enable(clk, OMAP24XX_ST_54M_APLL_MASK);\r\n}\r\nstatic void _apll96_allow_idle(struct clk *clk)\r\n{\r\nomap2xxx_cm_set_apll96_auto_low_power_stop();\r\n}\r\nstatic void _apll96_deny_idle(struct clk *clk)\r\n{\r\nomap2xxx_cm_set_apll96_disable_autoidle();\r\n}\r\nstatic void _apll54_allow_idle(struct clk *clk)\r\n{\r\nomap2xxx_cm_set_apll54_auto_low_power_stop();\r\n}\r\nstatic void _apll54_deny_idle(struct clk *clk)\r\n{\r\nomap2xxx_cm_set_apll54_disable_autoidle();\r\n}\r\nstatic void omap2_clk_apll_disable(struct clk *clk)\r\n{\r\nu32 cval;\r\ncval = omap2_cm_read_mod_reg(PLL_MOD, CM_CLKEN);\r\ncval &= ~(EN_APLL_LOCKED << clk->enable_bit);\r\nomap2_cm_write_mod_reg(cval, PLL_MOD, CM_CLKEN);\r\n}\r\nu32 omap2xxx_get_apll_clkin(void)\r\n{\r\nu32 aplls, srate = 0;\r\naplls = omap2_cm_read_mod_reg(PLL_MOD, CM_CLKSEL1);\r\naplls &= OMAP24XX_APLLS_CLKIN_MASK;\r\naplls >>= OMAP24XX_APLLS_CLKIN_SHIFT;\r\nif (aplls == APLLS_CLKIN_19_2MHZ)\r\nsrate = 19200000;\r\nelse if (aplls == APLLS_CLKIN_13MHZ)\r\nsrate = 13000000;\r\nelse if (aplls == APLLS_CLKIN_12MHZ)\r\nsrate = 12000000;\r\nreturn srate;\r\n}
