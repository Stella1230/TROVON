struct ubifs_znode *ubifs_tnc_levelorder_next(struct ubifs_znode *zr,\r\nstruct ubifs_znode *znode)\r\n{\r\nint level, iip, level_search = 0;\r\nstruct ubifs_znode *zn;\r\nubifs_assert(zr);\r\nif (unlikely(!znode))\r\nreturn zr;\r\nif (unlikely(znode == zr)) {\r\nif (znode->level == 0)\r\nreturn NULL;\r\nreturn ubifs_tnc_find_child(zr, 0);\r\n}\r\nlevel = znode->level;\r\niip = znode->iip;\r\nwhile (1) {\r\nubifs_assert(znode->level <= zr->level);\r\nwhile (znode->parent != zr && iip >= znode->parent->child_cnt) {\r\nznode = znode->parent;\r\niip = znode->iip;\r\n}\r\nif (unlikely(znode->parent == zr &&\r\niip >= znode->parent->child_cnt)) {\r\nlevel -= 1;\r\nif (level_search || level < 0)\r\nreturn NULL;\r\nlevel_search = 1;\r\niip = -1;\r\nznode = ubifs_tnc_find_child(zr, 0);\r\nubifs_assert(znode);\r\n}\r\nzn = ubifs_tnc_find_child(znode->parent, iip + 1);\r\nif (!zn) {\r\niip = znode->parent->child_cnt;\r\ncontinue;\r\n}\r\nwhile (zn->level != level) {\r\nznode = zn;\r\nzn = ubifs_tnc_find_child(zn, 0);\r\nif (!zn) {\r\niip = znode->iip;\r\nbreak;\r\n}\r\n}\r\nif (zn) {\r\nubifs_assert(zn->level >= 0);\r\nreturn zn;\r\n}\r\n}\r\n}\r\nint ubifs_search_zbranch(const struct ubifs_info *c,\r\nconst struct ubifs_znode *znode,\r\nconst union ubifs_key *key, int *n)\r\n{\r\nint beg = 0, end = znode->child_cnt, uninitialized_var(mid);\r\nint uninitialized_var(cmp);\r\nconst struct ubifs_zbranch *zbr = &znode->zbranch[0];\r\nubifs_assert(end > beg);\r\nwhile (end > beg) {\r\nmid = (beg + end) >> 1;\r\ncmp = keys_cmp(c, key, &zbr[mid].key);\r\nif (cmp > 0)\r\nbeg = mid + 1;\r\nelse if (cmp < 0)\r\nend = mid;\r\nelse {\r\n*n = mid;\r\nreturn 1;\r\n}\r\n}\r\n*n = end - 1;\r\nubifs_assert(*n >= -1 && *n < znode->child_cnt);\r\nif (*n == -1)\r\nubifs_assert(keys_cmp(c, key, &zbr[0].key) < 0);\r\nelse\r\nubifs_assert(keys_cmp(c, key, &zbr[*n].key) > 0);\r\nif (*n + 1 < znode->child_cnt)\r\nubifs_assert(keys_cmp(c, key, &zbr[*n + 1].key) < 0);\r\nreturn 0;\r\n}\r\nstruct ubifs_znode *ubifs_tnc_postorder_first(struct ubifs_znode *znode)\r\n{\r\nif (unlikely(!znode))\r\nreturn NULL;\r\nwhile (znode->level > 0) {\r\nstruct ubifs_znode *child;\r\nchild = ubifs_tnc_find_child(znode, 0);\r\nif (!child)\r\nreturn znode;\r\nznode = child;\r\n}\r\nreturn znode;\r\n}\r\nstruct ubifs_znode *ubifs_tnc_postorder_next(struct ubifs_znode *znode)\r\n{\r\nstruct ubifs_znode *zn;\r\nubifs_assert(znode);\r\nif (unlikely(!znode->parent))\r\nreturn NULL;\r\nzn = ubifs_tnc_find_child(znode->parent, znode->iip + 1);\r\nif (!zn)\r\nreturn znode->parent;\r\nreturn ubifs_tnc_postorder_first(zn);\r\n}\r\nlong ubifs_destroy_tnc_subtree(struct ubifs_znode *znode)\r\n{\r\nstruct ubifs_znode *zn = ubifs_tnc_postorder_first(znode);\r\nlong clean_freed = 0;\r\nint n;\r\nubifs_assert(zn);\r\nwhile (1) {\r\nfor (n = 0; n < zn->child_cnt; n++) {\r\nif (!zn->zbranch[n].znode)\r\ncontinue;\r\nif (zn->level > 0 &&\r\n!ubifs_zn_dirty(zn->zbranch[n].znode))\r\nclean_freed += 1;\r\ncond_resched();\r\nkfree(zn->zbranch[n].znode);\r\n}\r\nif (zn == znode) {\r\nif (!ubifs_zn_dirty(zn))\r\nclean_freed += 1;\r\nkfree(zn);\r\nreturn clean_freed;\r\n}\r\nzn = ubifs_tnc_postorder_next(zn);\r\n}\r\n}\r\nstatic int read_znode(struct ubifs_info *c, int lnum, int offs, int len,\r\nstruct ubifs_znode *znode)\r\n{\r\nint i, err, type, cmp;\r\nstruct ubifs_idx_node *idx;\r\nidx = kmalloc(c->max_idx_node_sz, GFP_NOFS);\r\nif (!idx)\r\nreturn -ENOMEM;\r\nerr = ubifs_read_node(c, idx, UBIFS_IDX_NODE, len, lnum, offs);\r\nif (err < 0) {\r\nkfree(idx);\r\nreturn err;\r\n}\r\nznode->child_cnt = le16_to_cpu(idx->child_cnt);\r\nznode->level = le16_to_cpu(idx->level);\r\ndbg_tnc("LEB %d:%d, level %d, %d branch",\r\nlnum, offs, znode->level, znode->child_cnt);\r\nif (znode->child_cnt > c->fanout || znode->level > UBIFS_MAX_LEVELS) {\r\ndbg_err("current fanout %d, branch count %d",\r\nc->fanout, znode->child_cnt);\r\ndbg_err("max levels %d, znode level %d",\r\nUBIFS_MAX_LEVELS, znode->level);\r\nerr = 1;\r\ngoto out_dump;\r\n}\r\nfor (i = 0; i < znode->child_cnt; i++) {\r\nconst struct ubifs_branch *br = ubifs_idx_branch(c, idx, i);\r\nstruct ubifs_zbranch *zbr = &znode->zbranch[i];\r\nkey_read(c, &br->key, &zbr->key);\r\nzbr->lnum = le32_to_cpu(br->lnum);\r\nzbr->offs = le32_to_cpu(br->offs);\r\nzbr->len = le32_to_cpu(br->len);\r\nzbr->znode = NULL;\r\nif (zbr->lnum < c->main_first ||\r\nzbr->lnum >= c->leb_cnt || zbr->offs < 0 ||\r\nzbr->offs + zbr->len > c->leb_size || zbr->offs & 7) {\r\ndbg_err("bad branch %d", i);\r\nerr = 2;\r\ngoto out_dump;\r\n}\r\nswitch (key_type(c, &zbr->key)) {\r\ncase UBIFS_INO_KEY:\r\ncase UBIFS_DATA_KEY:\r\ncase UBIFS_DENT_KEY:\r\ncase UBIFS_XENT_KEY:\r\nbreak;\r\ndefault:\r\ndbg_msg("bad key type at slot %d: %d",\r\ni, key_type(c, &zbr->key));\r\nerr = 3;\r\ngoto out_dump;\r\n}\r\nif (znode->level)\r\ncontinue;\r\ntype = key_type(c, &zbr->key);\r\nif (c->ranges[type].max_len == 0) {\r\nif (zbr->len != c->ranges[type].len) {\r\ndbg_err("bad target node (type %d) length (%d)",\r\ntype, zbr->len);\r\ndbg_err("have to be %d", c->ranges[type].len);\r\nerr = 4;\r\ngoto out_dump;\r\n}\r\n} else if (zbr->len < c->ranges[type].min_len ||\r\nzbr->len > c->ranges[type].max_len) {\r\ndbg_err("bad target node (type %d) length (%d)",\r\ntype, zbr->len);\r\ndbg_err("have to be in range of %d-%d",\r\nc->ranges[type].min_len,\r\nc->ranges[type].max_len);\r\nerr = 5;\r\ngoto out_dump;\r\n}\r\n}\r\nfor (i = 0; i < znode->child_cnt - 1; i++) {\r\nconst union ubifs_key *key1, *key2;\r\nkey1 = &znode->zbranch[i].key;\r\nkey2 = &znode->zbranch[i + 1].key;\r\ncmp = keys_cmp(c, key1, key2);\r\nif (cmp > 0) {\r\ndbg_err("bad key order (keys %d and %d)", i, i + 1);\r\nerr = 6;\r\ngoto out_dump;\r\n} else if (cmp == 0 && !is_hash_key(c, key1)) {\r\ndbg_err("keys %d and %d are not hashed but equivalent",\r\ni, i + 1);\r\nerr = 7;\r\ngoto out_dump;\r\n}\r\n}\r\nkfree(idx);\r\nreturn 0;\r\nout_dump:\r\nubifs_err("bad indexing node at LEB %d:%d, error %d", lnum, offs, err);\r\ndbg_dump_node(c, idx);\r\nkfree(idx);\r\nreturn -EINVAL;\r\n}\r\nstruct ubifs_znode *ubifs_load_znode(struct ubifs_info *c,\r\nstruct ubifs_zbranch *zbr,\r\nstruct ubifs_znode *parent, int iip)\r\n{\r\nint err;\r\nstruct ubifs_znode *znode;\r\nubifs_assert(!zbr->znode);\r\nznode = kzalloc(c->max_znode_sz, GFP_NOFS);\r\nif (!znode)\r\nreturn ERR_PTR(-ENOMEM);\r\nerr = read_znode(c, zbr->lnum, zbr->offs, zbr->len, znode);\r\nif (err)\r\ngoto out;\r\natomic_long_inc(&c->clean_zn_cnt);\r\natomic_long_inc(&ubifs_clean_zn_cnt);\r\nzbr->znode = znode;\r\nznode->parent = parent;\r\nznode->time = get_seconds();\r\nznode->iip = iip;\r\nreturn znode;\r\nout:\r\nkfree(znode);\r\nreturn ERR_PTR(err);\r\n}\r\nint ubifs_tnc_read_node(struct ubifs_info *c, struct ubifs_zbranch *zbr,\r\nvoid *node)\r\n{\r\nunion ubifs_key key1, *key = &zbr->key;\r\nint err, type = key_type(c, key);\r\nstruct ubifs_wbuf *wbuf;\r\nwbuf = ubifs_get_wbuf(c, zbr->lnum);\r\nif (wbuf)\r\nerr = ubifs_read_node_wbuf(wbuf, node, type, zbr->len,\r\nzbr->lnum, zbr->offs);\r\nelse\r\nerr = ubifs_read_node(c, node, type, zbr->len, zbr->lnum,\r\nzbr->offs);\r\nif (err) {\r\ndbg_tnck(key, "key ");\r\nreturn err;\r\n}\r\nkey_read(c, node + UBIFS_KEY_OFFSET, &key1);\r\nif (!keys_eq(c, key, &key1)) {\r\nubifs_err("bad key in node at LEB %d:%d",\r\nzbr->lnum, zbr->offs);\r\ndbg_tnck(key, "looked for key ");\r\ndbg_tnck(&key1, "but found node's key ");\r\ndbg_dump_node(c, node);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}
