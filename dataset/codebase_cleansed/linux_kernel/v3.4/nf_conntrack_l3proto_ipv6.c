static bool ipv6_pkt_to_tuple(const struct sk_buff *skb, unsigned int nhoff,\r\nstruct nf_conntrack_tuple *tuple)\r\n{\r\nconst u_int32_t *ap;\r\nu_int32_t _addrs[8];\r\nap = skb_header_pointer(skb, nhoff + offsetof(struct ipv6hdr, saddr),\r\nsizeof(_addrs), _addrs);\r\nif (ap == NULL)\r\nreturn false;\r\nmemcpy(tuple->src.u3.ip6, ap, sizeof(tuple->src.u3.ip6));\r\nmemcpy(tuple->dst.u3.ip6, ap + 4, sizeof(tuple->dst.u3.ip6));\r\nreturn true;\r\n}\r\nstatic bool ipv6_invert_tuple(struct nf_conntrack_tuple *tuple,\r\nconst struct nf_conntrack_tuple *orig)\r\n{\r\nmemcpy(tuple->src.u3.ip6, orig->dst.u3.ip6, sizeof(tuple->src.u3.ip6));\r\nmemcpy(tuple->dst.u3.ip6, orig->src.u3.ip6, sizeof(tuple->dst.u3.ip6));\r\nreturn true;\r\n}\r\nstatic int ipv6_print_tuple(struct seq_file *s,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nreturn seq_printf(s, "src=%pI6 dst=%pI6 ",\r\ntuple->src.u3.ip6, tuple->dst.u3.ip6);\r\n}\r\nstatic int nf_ct_ipv6_skip_exthdr(const struct sk_buff *skb, int start,\r\nu8 *nexthdrp, int len)\r\n{\r\nu8 nexthdr = *nexthdrp;\r\nwhile (ipv6_ext_hdr(nexthdr)) {\r\nstruct ipv6_opt_hdr hdr;\r\nint hdrlen;\r\nif (len < (int)sizeof(struct ipv6_opt_hdr))\r\nreturn -1;\r\nif (nexthdr == NEXTHDR_NONE)\r\nbreak;\r\nif (nexthdr == NEXTHDR_FRAGMENT)\r\nbreak;\r\nif (skb_copy_bits(skb, start, &hdr, sizeof(hdr)))\r\nBUG();\r\nif (nexthdr == NEXTHDR_AUTH)\r\nhdrlen = (hdr.hdrlen+2)<<2;\r\nelse\r\nhdrlen = ipv6_optlen(&hdr);\r\nnexthdr = hdr.nexthdr;\r\nlen -= hdrlen;\r\nstart += hdrlen;\r\n}\r\n*nexthdrp = nexthdr;\r\nreturn start;\r\n}\r\nstatic int ipv6_get_l4proto(const struct sk_buff *skb, unsigned int nhoff,\r\nunsigned int *dataoff, u_int8_t *protonum)\r\n{\r\nunsigned int extoff = nhoff + sizeof(struct ipv6hdr);\r\nunsigned char pnum;\r\nint protoff;\r\nif (skb_copy_bits(skb, nhoff + offsetof(struct ipv6hdr, nexthdr),\r\n&pnum, sizeof(pnum)) != 0) {\r\npr_debug("ip6_conntrack_core: can't get nexthdr\n");\r\nreturn -NF_ACCEPT;\r\n}\r\nprotoff = nf_ct_ipv6_skip_exthdr(skb, extoff, &pnum, skb->len - extoff);\r\nif ((protoff < 0) || (protoff > skb->len)) {\r\npr_debug("ip6_conntrack_core: can't find proto in pkt\n");\r\nreturn -NF_ACCEPT;\r\n}\r\n*dataoff = protoff;\r\n*protonum = pnum;\r\nreturn NF_ACCEPT;\r\n}\r\nstatic unsigned int ipv6_confirm(unsigned int hooknum,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nstruct nf_conn *ct;\r\nconst struct nf_conn_help *help;\r\nconst struct nf_conntrack_helper *helper;\r\nenum ip_conntrack_info ctinfo;\r\nunsigned int ret, protoff;\r\nunsigned int extoff = (u8 *)(ipv6_hdr(skb) + 1) - skb->data;\r\nunsigned char pnum = ipv6_hdr(skb)->nexthdr;\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (!ct || ctinfo == IP_CT_RELATED_REPLY)\r\ngoto out;\r\nhelp = nfct_help(ct);\r\nif (!help)\r\ngoto out;\r\nhelper = rcu_dereference(help->helper);\r\nif (!helper)\r\ngoto out;\r\nprotoff = nf_ct_ipv6_skip_exthdr(skb, extoff, &pnum,\r\nskb->len - extoff);\r\nif (protoff > skb->len || pnum == NEXTHDR_FRAGMENT) {\r\npr_debug("proto header not found\n");\r\nreturn NF_ACCEPT;\r\n}\r\nret = helper->help(skb, protoff, ct, ctinfo);\r\nif (ret != NF_ACCEPT) {\r\nnf_log_packet(NFPROTO_IPV6, hooknum, skb, in, out, NULL,\r\n"nf_ct_%s: dropping packet", helper->name);\r\nreturn ret;\r\n}\r\nout:\r\nreturn nf_conntrack_confirm(skb);\r\n}\r\nstatic unsigned int __ipv6_conntrack_in(struct net *net,\r\nunsigned int hooknum,\r\nstruct sk_buff *skb,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nstruct sk_buff *reasm = skb->nfct_reasm;\r\nif (reasm) {\r\nif (!reasm->nfct) {\r\nunsigned int ret;\r\nret = nf_conntrack_in(net, PF_INET6, hooknum, reasm);\r\nif (ret != NF_ACCEPT)\r\nreturn ret;\r\n}\r\nnf_conntrack_get(reasm->nfct);\r\nskb->nfct = reasm->nfct;\r\nskb->nfctinfo = reasm->nfctinfo;\r\nreturn NF_ACCEPT;\r\n}\r\nreturn nf_conntrack_in(net, PF_INET6, hooknum, skb);\r\n}\r\nstatic unsigned int ipv6_conntrack_in(unsigned int hooknum,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nreturn __ipv6_conntrack_in(dev_net(in), hooknum, skb, okfn);\r\n}\r\nstatic unsigned int ipv6_conntrack_local(unsigned int hooknum,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nif (skb->len < sizeof(struct ipv6hdr)) {\r\nif (net_ratelimit())\r\npr_notice("ipv6_conntrack_local: packet too short\n");\r\nreturn NF_ACCEPT;\r\n}\r\nreturn __ipv6_conntrack_in(dev_net(out), hooknum, skb, okfn);\r\n}\r\nstatic int ipv6_tuple_to_nlattr(struct sk_buff *skb,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nNLA_PUT(skb, CTA_IP_V6_SRC, sizeof(u_int32_t) * 4,\r\n&tuple->src.u3.ip6);\r\nNLA_PUT(skb, CTA_IP_V6_DST, sizeof(u_int32_t) * 4,\r\n&tuple->dst.u3.ip6);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int ipv6_nlattr_to_tuple(struct nlattr *tb[],\r\nstruct nf_conntrack_tuple *t)\r\n{\r\nif (!tb[CTA_IP_V6_SRC] || !tb[CTA_IP_V6_DST])\r\nreturn -EINVAL;\r\nmemcpy(&t->src.u3.ip6, nla_data(tb[CTA_IP_V6_SRC]),\r\nsizeof(u_int32_t) * 4);\r\nmemcpy(&t->dst.u3.ip6, nla_data(tb[CTA_IP_V6_DST]),\r\nsizeof(u_int32_t) * 4);\r\nreturn 0;\r\n}\r\nstatic int ipv6_nlattr_tuple_size(void)\r\n{\r\nreturn nla_policy_len(ipv6_nla_policy, CTA_IP_MAX + 1);\r\n}\r\nstatic int __init nf_conntrack_l3proto_ipv6_init(void)\r\n{\r\nint ret = 0;\r\nneed_conntrack();\r\nnf_defrag_ipv6_enable();\r\nret = nf_conntrack_l4proto_register(&nf_conntrack_l4proto_tcp6);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_ipv6: can't register tcp.\n");\r\nreturn ret;\r\n}\r\nret = nf_conntrack_l4proto_register(&nf_conntrack_l4proto_udp6);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_ipv6: can't register udp.\n");\r\ngoto cleanup_tcp;\r\n}\r\nret = nf_conntrack_l4proto_register(&nf_conntrack_l4proto_icmpv6);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_ipv6: can't register icmpv6.\n");\r\ngoto cleanup_udp;\r\n}\r\nret = nf_conntrack_l3proto_register(&nf_conntrack_l3proto_ipv6);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_ipv6: can't register ipv6\n");\r\ngoto cleanup_icmpv6;\r\n}\r\nret = nf_register_hooks(ipv6_conntrack_ops,\r\nARRAY_SIZE(ipv6_conntrack_ops));\r\nif (ret < 0) {\r\npr_err("nf_conntrack_ipv6: can't register pre-routing defrag "\r\n"hook.\n");\r\ngoto cleanup_ipv6;\r\n}\r\nreturn ret;\r\ncleanup_ipv6:\r\nnf_conntrack_l3proto_unregister(&nf_conntrack_l3proto_ipv6);\r\ncleanup_icmpv6:\r\nnf_conntrack_l4proto_unregister(&nf_conntrack_l4proto_icmpv6);\r\ncleanup_udp:\r\nnf_conntrack_l4proto_unregister(&nf_conntrack_l4proto_udp6);\r\ncleanup_tcp:\r\nnf_conntrack_l4proto_unregister(&nf_conntrack_l4proto_tcp6);\r\nreturn ret;\r\n}\r\nstatic void __exit nf_conntrack_l3proto_ipv6_fini(void)\r\n{\r\nsynchronize_net();\r\nnf_unregister_hooks(ipv6_conntrack_ops, ARRAY_SIZE(ipv6_conntrack_ops));\r\nnf_conntrack_l3proto_unregister(&nf_conntrack_l3proto_ipv6);\r\nnf_conntrack_l4proto_unregister(&nf_conntrack_l4proto_icmpv6);\r\nnf_conntrack_l4proto_unregister(&nf_conntrack_l4proto_udp6);\r\nnf_conntrack_l4proto_unregister(&nf_conntrack_l4proto_tcp6);\r\n}
