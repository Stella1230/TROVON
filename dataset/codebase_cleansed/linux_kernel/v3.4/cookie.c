void fscache_cookie_init_once(void *_cookie)\r\n{\r\nstruct fscache_cookie *cookie = _cookie;\r\nmemset(cookie, 0, sizeof(*cookie));\r\nspin_lock_init(&cookie->lock);\r\nspin_lock_init(&cookie->stores_lock);\r\nINIT_HLIST_HEAD(&cookie->backing_objects);\r\n}\r\nstruct fscache_cookie *__fscache_acquire_cookie(\r\nstruct fscache_cookie *parent,\r\nconst struct fscache_cookie_def *def,\r\nvoid *netfs_data)\r\n{\r\nstruct fscache_cookie *cookie;\r\nBUG_ON(!def);\r\n_enter("{%s},{%s},%p",\r\nparent ? (char *) parent->def->name : "<no-parent>",\r\ndef->name, netfs_data);\r\nfscache_stat(&fscache_n_acquires);\r\nif (!parent) {\r\nfscache_stat(&fscache_n_acquires_null);\r\n_leave(" [no parent]");\r\nreturn NULL;\r\n}\r\nBUG_ON(!def->get_key);\r\nBUG_ON(!def->name[0]);\r\nBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\r\nparent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\r\ncookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\r\nif (!cookie) {\r\nfscache_stat(&fscache_n_acquires_oom);\r\n_leave(" [ENOMEM]");\r\nreturn NULL;\r\n}\r\natomic_set(&cookie->usage, 1);\r\natomic_set(&cookie->n_children, 0);\r\natomic_inc(&parent->usage);\r\natomic_inc(&parent->n_children);\r\ncookie->def = def;\r\ncookie->parent = parent;\r\ncookie->netfs_data = netfs_data;\r\ncookie->flags = 0;\r\nINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_WAIT);\r\nswitch (cookie->def->type) {\r\ncase FSCACHE_COOKIE_TYPE_INDEX:\r\nfscache_stat(&fscache_n_cookie_index);\r\nbreak;\r\ncase FSCACHE_COOKIE_TYPE_DATAFILE:\r\nfscache_stat(&fscache_n_cookie_data);\r\nbreak;\r\ndefault:\r\nfscache_stat(&fscache_n_cookie_special);\r\nbreak;\r\n}\r\nif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\r\nif (fscache_acquire_non_index_cookie(cookie) < 0) {\r\natomic_dec(&parent->n_children);\r\n__fscache_cookie_put(cookie);\r\nfscache_stat(&fscache_n_acquires_nobufs);\r\n_leave(" = NULL");\r\nreturn NULL;\r\n}\r\n}\r\nfscache_stat(&fscache_n_acquires_ok);\r\n_leave(" = %p", cookie);\r\nreturn cookie;\r\n}\r\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie)\r\n{\r\nstruct fscache_object *object;\r\nstruct fscache_cache *cache;\r\nuint64_t i_size;\r\nint ret;\r\n_enter("");\r\ncookie->flags = 1 << FSCACHE_COOKIE_UNAVAILABLE;\r\ndown_read(&fscache_addremove_sem);\r\nif (list_empty(&fscache_cache_list)) {\r\nup_read(&fscache_addremove_sem);\r\n_leave(" = 0 [no caches]");\r\nreturn 0;\r\n}\r\ncache = fscache_select_cache_for_object(cookie->parent);\r\nif (!cache) {\r\nup_read(&fscache_addremove_sem);\r\nfscache_stat(&fscache_n_acquires_no_cache);\r\n_leave(" = -ENOMEDIUM [no cache]");\r\nreturn -ENOMEDIUM;\r\n}\r\n_debug("cache %s", cache->tag->name);\r\ncookie->flags =\r\n(1 << FSCACHE_COOKIE_LOOKING_UP) |\r\n(1 << FSCACHE_COOKIE_CREATING) |\r\n(1 << FSCACHE_COOKIE_NO_DATA_YET);\r\nret = fscache_alloc_object(cache, cookie);\r\nif (ret < 0) {\r\nup_read(&fscache_addremove_sem);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\ncookie->def->get_attr(cookie->netfs_data, &i_size);\r\nspin_lock(&cookie->lock);\r\nif (hlist_empty(&cookie->backing_objects)) {\r\nspin_unlock(&cookie->lock);\r\ngoto unavailable;\r\n}\r\nobject = hlist_entry(cookie->backing_objects.first,\r\nstruct fscache_object, cookie_link);\r\nfscache_set_store_limit(object, i_size);\r\nfscache_enqueue_object(object);\r\nspin_unlock(&cookie->lock);\r\nif (!fscache_defer_lookup) {\r\n_debug("non-deferred lookup %p", &cookie->flags);\r\nwait_on_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP,\r\nfscache_wait_bit, TASK_UNINTERRUPTIBLE);\r\n_debug("complete");\r\nif (test_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags))\r\ngoto unavailable;\r\n}\r\nup_read(&fscache_addremove_sem);\r\n_leave(" = 0 [deferred]");\r\nreturn 0;\r\nunavailable:\r\nup_read(&fscache_addremove_sem);\r\n_leave(" = -ENOBUFS");\r\nreturn -ENOBUFS;\r\n}\r\nstatic int fscache_alloc_object(struct fscache_cache *cache,\r\nstruct fscache_cookie *cookie)\r\n{\r\nstruct fscache_object *object;\r\nstruct hlist_node *_n;\r\nint ret;\r\n_enter("%p,%p{%s}", cache, cookie, cookie->def->name);\r\nspin_lock(&cookie->lock);\r\nhlist_for_each_entry(object, _n, &cookie->backing_objects,\r\ncookie_link) {\r\nif (object->cache == cache)\r\ngoto object_already_extant;\r\n}\r\nspin_unlock(&cookie->lock);\r\nfscache_stat(&fscache_n_cop_alloc_object);\r\nobject = cache->ops->alloc_object(cache, cookie);\r\nfscache_stat_d(&fscache_n_cop_alloc_object);\r\nif (IS_ERR(object)) {\r\nfscache_stat(&fscache_n_object_no_alloc);\r\nret = PTR_ERR(object);\r\ngoto error;\r\n}\r\nfscache_stat(&fscache_n_object_alloc);\r\nobject->debug_id = atomic_inc_return(&fscache_object_debug_id);\r\n_debug("ALLOC OBJ%x: %s {%lx}",\r\nobject->debug_id, cookie->def->name, object->events);\r\nret = fscache_alloc_object(cache, cookie->parent);\r\nif (ret < 0)\r\ngoto error_put;\r\nif (fscache_attach_object(cookie, object) < 0) {\r\nfscache_stat(&fscache_n_cop_put_object);\r\ncache->ops->put_object(object);\r\nfscache_stat_d(&fscache_n_cop_put_object);\r\n}\r\n_leave(" = 0");\r\nreturn 0;\r\nobject_already_extant:\r\nret = -ENOBUFS;\r\nif (object->state >= FSCACHE_OBJECT_DYING) {\r\nspin_unlock(&cookie->lock);\r\ngoto error;\r\n}\r\nspin_unlock(&cookie->lock);\r\n_leave(" = 0 [found]");\r\nreturn 0;\r\nerror_put:\r\nfscache_stat(&fscache_n_cop_put_object);\r\ncache->ops->put_object(object);\r\nfscache_stat_d(&fscache_n_cop_put_object);\r\nerror:\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\r\nstruct fscache_object *object)\r\n{\r\nstruct fscache_object *p;\r\nstruct fscache_cache *cache = object->cache;\r\nstruct hlist_node *_n;\r\nint ret;\r\n_enter("{%s},{OBJ%x}", cookie->def->name, object->debug_id);\r\nspin_lock(&cookie->lock);\r\nret = -EEXIST;\r\nhlist_for_each_entry(p, _n, &cookie->backing_objects, cookie_link) {\r\nif (p->cache == object->cache) {\r\nif (p->state >= FSCACHE_OBJECT_DYING)\r\nret = -ENOBUFS;\r\ngoto cant_attach_object;\r\n}\r\n}\r\nspin_lock_nested(&cookie->parent->lock, 1);\r\nhlist_for_each_entry(p, _n, &cookie->parent->backing_objects,\r\ncookie_link) {\r\nif (p->cache == object->cache) {\r\nif (p->state >= FSCACHE_OBJECT_DYING) {\r\nret = -ENOBUFS;\r\nspin_unlock(&cookie->parent->lock);\r\ngoto cant_attach_object;\r\n}\r\nobject->parent = p;\r\nspin_lock(&p->lock);\r\np->n_children++;\r\nspin_unlock(&p->lock);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&cookie->parent->lock);\r\nif (list_empty(&object->cache_link)) {\r\nspin_lock(&cache->object_list_lock);\r\nlist_add(&object->cache_link, &cache->object_list);\r\nspin_unlock(&cache->object_list_lock);\r\n}\r\nobject->cookie = cookie;\r\natomic_inc(&cookie->usage);\r\nhlist_add_head(&object->cookie_link, &cookie->backing_objects);\r\nfscache_objlist_add(object);\r\nret = 0;\r\ncant_attach_object:\r\nspin_unlock(&cookie->lock);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nvoid __fscache_update_cookie(struct fscache_cookie *cookie)\r\n{\r\nstruct fscache_object *object;\r\nstruct hlist_node *_p;\r\nfscache_stat(&fscache_n_updates);\r\nif (!cookie) {\r\nfscache_stat(&fscache_n_updates_null);\r\n_leave(" [no cookie]");\r\nreturn;\r\n}\r\n_enter("{%s}", cookie->def->name);\r\nBUG_ON(!cookie->def->get_aux);\r\nspin_lock(&cookie->lock);\r\nhlist_for_each_entry(object, _p,\r\n&cookie->backing_objects, cookie_link) {\r\nfscache_raise_event(object, FSCACHE_OBJECT_EV_UPDATE);\r\n}\r\nspin_unlock(&cookie->lock);\r\n_leave("");\r\n}\r\nvoid __fscache_relinquish_cookie(struct fscache_cookie *cookie, int retire)\r\n{\r\nstruct fscache_cache *cache;\r\nstruct fscache_object *object;\r\nunsigned long event;\r\nfscache_stat(&fscache_n_relinquishes);\r\nif (retire)\r\nfscache_stat(&fscache_n_relinquishes_retire);\r\nif (!cookie) {\r\nfscache_stat(&fscache_n_relinquishes_null);\r\n_leave(" [no cookie]");\r\nreturn;\r\n}\r\n_enter("%p{%s,%p},%d",\r\ncookie, cookie->def->name, cookie->netfs_data, retire);\r\nif (atomic_read(&cookie->n_children) != 0) {\r\nprintk(KERN_ERR "FS-Cache: Cookie '%s' still has children\n",\r\ncookie->def->name);\r\nBUG();\r\n}\r\nif (test_bit(FSCACHE_COOKIE_CREATING, &cookie->flags)) {\r\nfscache_stat(&fscache_n_relinquishes_waitcrt);\r\nwait_on_bit(&cookie->flags, FSCACHE_COOKIE_CREATING,\r\nfscache_wait_bit, TASK_UNINTERRUPTIBLE);\r\n}\r\nevent = retire ? FSCACHE_OBJECT_EV_RETIRE : FSCACHE_OBJECT_EV_RELEASE;\r\nspin_lock(&cookie->lock);\r\nwhile (!hlist_empty(&cookie->backing_objects)) {\r\nobject = hlist_entry(cookie->backing_objects.first,\r\nstruct fscache_object,\r\ncookie_link);\r\n_debug("RELEASE OBJ%x", object->debug_id);\r\nspin_lock(&object->lock);\r\nhlist_del_init(&object->cookie_link);\r\ncache = object->cache;\r\nobject->cookie = NULL;\r\nfscache_raise_event(object, event);\r\nspin_unlock(&object->lock);\r\nif (atomic_dec_and_test(&cookie->usage))\r\nBUG();\r\n}\r\ncookie->netfs_data = NULL;\r\ncookie->def = NULL;\r\nspin_unlock(&cookie->lock);\r\nif (cookie->parent) {\r\nASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\r\nASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\r\natomic_dec(&cookie->parent->n_children);\r\n}\r\nASSERTCMP(atomic_read(&cookie->usage), >, 0);\r\nfscache_cookie_put(cookie);\r\n_leave("");\r\n}\r\nvoid __fscache_cookie_put(struct fscache_cookie *cookie)\r\n{\r\nstruct fscache_cookie *parent;\r\n_enter("%p", cookie);\r\nfor (;;) {\r\n_debug("FREE COOKIE %p", cookie);\r\nparent = cookie->parent;\r\nBUG_ON(!hlist_empty(&cookie->backing_objects));\r\nkmem_cache_free(fscache_cookie_jar, cookie);\r\nif (!parent)\r\nbreak;\r\ncookie = parent;\r\nBUG_ON(atomic_read(&cookie->usage) <= 0);\r\nif (!atomic_dec_and_test(&cookie->usage))\r\nbreak;\r\n}\r\n_leave("");\r\n}
