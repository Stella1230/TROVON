static int send_control_msg(struct usb_device *udev, u8 request, u16 value,\r\nu16 index, unsigned char *cp, u16 size)\r\n{\r\nint status;\r\nunsigned char *transfer_buffer = kmalloc(size, GFP_KERNEL);\r\nif (!transfer_buffer) {\r\ndev_err(&udev->dev, "kmalloc(%d) failed\n", size);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(transfer_buffer, cp, size);\r\nstatus = usb_control_msg(udev,\r\nusb_sndctrlpipe(udev, 0),\r\nrequest,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE, value, index,\r\ntransfer_buffer, size, CTRL_TIMEOUT);\r\nkfree(transfer_buffer);\r\nif (status < 0)\r\ndev_err(&udev->dev,\r\n"Failed sending control message, error %d.\n", status);\r\nreturn status;\r\n}\r\nstatic int buffer_setup(struct videobuf_queue *vq, unsigned int *count,\r\nunsigned int *size)\r\n{\r\nstruct zr364xx_camera *cam = vq->priv_data;\r\n*size = cam->width * cam->height * (cam->fmt->depth >> 3);\r\nif (*count == 0)\r\n*count = ZR364XX_DEF_BUFS;\r\nif (*size * *count > ZR364XX_DEF_BUFS * 1024 * 1024)\r\n*count = (ZR364XX_DEF_BUFS * 1024 * 1024) / *size;\r\nreturn 0;\r\n}\r\nstatic void free_buffer(struct videobuf_queue *vq, struct zr364xx_buffer *buf)\r\n{\r\n_DBG("%s\n", __func__);\r\nif (in_interrupt())\r\nBUG();\r\nvideobuf_vmalloc_free(&buf->vb);\r\nbuf->vb.state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic int buffer_prepare(struct videobuf_queue *vq, struct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct zr364xx_camera *cam = vq->priv_data;\r\nstruct zr364xx_buffer *buf = container_of(vb, struct zr364xx_buffer,\r\nvb);\r\nint rc;\r\nDBG("%s, field=%d, fmt name = %s\n", __func__, field, cam->fmt != NULL ?\r\ncam->fmt->name : "");\r\nif (cam->fmt == NULL)\r\nreturn -EINVAL;\r\nbuf->vb.size = cam->width * cam->height * (cam->fmt->depth >> 3);\r\nif (buf->vb.baddr != 0 && buf->vb.bsize < buf->vb.size) {\r\nDBG("invalid buffer prepare\n");\r\nreturn -EINVAL;\r\n}\r\nbuf->fmt = cam->fmt;\r\nbuf->vb.width = cam->width;\r\nbuf->vb.height = cam->height;\r\nbuf->vb.field = field;\r\nif (buf->vb.state == VIDEOBUF_NEEDS_INIT) {\r\nrc = videobuf_iolock(vq, &buf->vb, NULL);\r\nif (rc < 0)\r\ngoto fail;\r\n}\r\nbuf->vb.state = VIDEOBUF_PREPARED;\r\nreturn 0;\r\nfail:\r\nfree_buffer(vq, buf);\r\nreturn rc;\r\n}\r\nstatic void buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)\r\n{\r\nstruct zr364xx_buffer *buf = container_of(vb, struct zr364xx_buffer,\r\nvb);\r\nstruct zr364xx_camera *cam = vq->priv_data;\r\n_DBG("%s\n", __func__);\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\nlist_add_tail(&buf->vb.queue, &cam->vidq.active);\r\n}\r\nstatic void buffer_release(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct zr364xx_buffer *buf = container_of(vb, struct zr364xx_buffer,\r\nvb);\r\n_DBG("%s\n", __func__);\r\nfree_buffer(vq, buf);\r\n}\r\nstatic ssize_t zr364xx_read(struct file *file, char __user *buf, size_t count,\r\nloff_t * ppos)\r\n{\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\n_DBG("%s\n", __func__);\r\nif (!buf)\r\nreturn -EINVAL;\r\nif (!count)\r\nreturn -EINVAL;\r\nif (cam->type == V4L2_BUF_TYPE_VIDEO_CAPTURE &&\r\nzr364xx_vidioc_streamon(file, cam, cam->type) == 0) {\r\nDBG("%s: reading %d bytes at pos %d.\n", __func__, (int) count,\r\n(int) *ppos);\r\nreturn videobuf_read_one(&cam->vb_vidq, buf, count, ppos,\r\nfile->f_flags & O_NONBLOCK);\r\n}\r\nreturn 0;\r\n}\r\nstatic void zr364xx_fillbuff(struct zr364xx_camera *cam,\r\nstruct zr364xx_buffer *buf,\r\nint jpgsize)\r\n{\r\nint pos = 0;\r\nstruct timeval ts;\r\nconst char *tmpbuf;\r\nchar *vbuf = videobuf_to_vmalloc(&buf->vb);\r\nunsigned long last_frame;\r\nstruct zr364xx_framei *frm;\r\nif (!vbuf)\r\nreturn;\r\nlast_frame = cam->last_frame;\r\nif (last_frame != -1) {\r\nfrm = &cam->buffer.frame[last_frame];\r\ntmpbuf = (const char *)cam->buffer.frame[last_frame].lpvbits;\r\nswitch (buf->fmt->fourcc) {\r\ncase V4L2_PIX_FMT_JPEG:\r\nbuf->vb.size = jpgsize;\r\nmemcpy(vbuf, tmpbuf, buf->vb.size);\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG KBUILD_MODNAME ": unknown format?\n");\r\n}\r\ncam->last_frame = -1;\r\n} else {\r\nprintk(KERN_ERR KBUILD_MODNAME ": =======no frame\n");\r\nreturn;\r\n}\r\nDBG("%s: Buffer 0x%08lx size= %d\n", __func__,\r\n(unsigned long)vbuf, pos);\r\nbuf->vb.field_count = cam->frame_count * 2;\r\ndo_gettimeofday(&ts);\r\nbuf->vb.ts = ts;\r\nbuf->vb.state = VIDEOBUF_DONE;\r\n}\r\nstatic int zr364xx_got_frame(struct zr364xx_camera *cam, int jpgsize)\r\n{\r\nstruct zr364xx_dmaqueue *dma_q = &cam->vidq;\r\nstruct zr364xx_buffer *buf;\r\nunsigned long flags = 0;\r\nint rc = 0;\r\nDBG("wakeup: %p\n", &dma_q);\r\nspin_lock_irqsave(&cam->slock, flags);\r\nif (list_empty(&dma_q->active)) {\r\nDBG("No active queue to serve\n");\r\nrc = -1;\r\ngoto unlock;\r\n}\r\nbuf = list_entry(dma_q->active.next,\r\nstruct zr364xx_buffer, vb.queue);\r\nif (!waitqueue_active(&buf->vb.done)) {\r\nrc = -1;\r\ngoto unlock;\r\n}\r\nlist_del(&buf->vb.queue);\r\ndo_gettimeofday(&buf->vb.ts);\r\nDBG("[%p/%d] wakeup\n", buf, buf->vb.i);\r\nzr364xx_fillbuff(cam, buf, jpgsize);\r\nwake_up(&buf->vb.done);\r\nDBG("wakeup [buf/i] [%p/%d]\n", buf, buf->vb.i);\r\nunlock:\r\nspin_unlock_irqrestore(&cam->slock, flags);\r\nreturn rc;\r\n}\r\nstatic int zr364xx_read_video_callback(struct zr364xx_camera *cam,\r\nstruct zr364xx_pipeinfo *pipe_info,\r\nstruct urb *purb)\r\n{\r\nunsigned char *pdest;\r\nunsigned char *psrc;\r\ns32 idx = -1;\r\nstruct zr364xx_framei *frm;\r\nint i = 0;\r\nunsigned char *ptr = NULL;\r\n_DBG("buffer to user\n");\r\nidx = cam->cur_frame;\r\nfrm = &cam->buffer.frame[idx];\r\nif (cam->method == METHOD0) {\r\nu16 *buf = (u16 *)pipe_info->transfer_buffer;\r\nfor (i = 0; i < purb->actual_length/2; i++)\r\nswab16s(buf + i);\r\n}\r\nif (!cam->b_acquire) {\r\nfrm->ulState = ZR364XX_READ_IDLE;\r\nreturn -EINVAL;\r\n}\r\npsrc = (u8 *)pipe_info->transfer_buffer;\r\nptr = pdest = frm->lpvbits;\r\nif (frm->ulState == ZR364XX_READ_IDLE) {\r\nfrm->ulState = ZR364XX_READ_FRAME;\r\nfrm->cur_size = 0;\r\n_DBG("jpeg header, ");\r\nmemcpy(ptr, header1, sizeof(header1));\r\nptr += sizeof(header1);\r\nheader3 = 0;\r\nmemcpy(ptr, &header3, 1);\r\nptr++;\r\nmemcpy(ptr, psrc, 64);\r\nptr += 64;\r\nheader3 = 1;\r\nmemcpy(ptr, &header3, 1);\r\nptr++;\r\nmemcpy(ptr, psrc + 64, 64);\r\nptr += 64;\r\nmemcpy(ptr, header2, sizeof(header2));\r\nptr += sizeof(header2);\r\nmemcpy(ptr, psrc + 128,\r\npurb->actual_length - 128);\r\nptr += purb->actual_length - 128;\r\n_DBG("header : %d %d %d %d %d %d %d %d %d\n",\r\npsrc[0], psrc[1], psrc[2],\r\npsrc[3], psrc[4], psrc[5],\r\npsrc[6], psrc[7], psrc[8]);\r\nfrm->cur_size = ptr - pdest;\r\n} else {\r\nif (frm->cur_size + purb->actual_length > MAX_FRAME_SIZE) {\r\ndev_info(&cam->udev->dev,\r\n"%s: buffer (%d bytes) too small to hold "\r\n"frame data. Discarding frame data.\n",\r\n__func__, MAX_FRAME_SIZE);\r\n} else {\r\npdest += frm->cur_size;\r\nmemcpy(pdest, psrc, purb->actual_length);\r\nfrm->cur_size += purb->actual_length;\r\n}\r\n}\r\nif (purb->actual_length < pipe_info->transfer_size) {\r\n_DBG("****************Buffer[%d]full*************\n", idx);\r\ncam->last_frame = cam->cur_frame;\r\ncam->cur_frame++;\r\nif (cam->cur_frame == cam->buffer.dwFrames)\r\ncam->cur_frame = 0;\r\nptr = pdest = frm->lpvbits;\r\nptr += frm->cur_size - 2;\r\nwhile (ptr > pdest) {\r\nif (*ptr == 0xFF && *(ptr + 1) == 0xD9\r\n&& *(ptr + 2) == 0xFF)\r\nbreak;\r\nptr--;\r\n}\r\nif (ptr == pdest)\r\nDBG("No EOI marker\n");\r\nwhile (ptr > pdest) {\r\nif (*ptr == 0xFF && *(ptr + 1) == 0xFF\r\n&& *(ptr + 2) == 0xFF)\r\nbreak;\r\nptr--;\r\n}\r\nif (ptr != pdest) {\r\nDBG("Bogus frame ? %d\n", ++(cam->nb));\r\n} else if (cam->b_acquire) {\r\nif (cam->skip)\r\ncam->skip--;\r\nelse {\r\n_DBG("jpeg(%lu): %d %d %d %d %d %d %d %d\n",\r\nfrm->cur_size,\r\npdest[0], pdest[1], pdest[2], pdest[3],\r\npdest[4], pdest[5], pdest[6], pdest[7]);\r\nzr364xx_got_frame(cam, frm->cur_size);\r\n}\r\n}\r\ncam->frame_count++;\r\nfrm->ulState = ZR364XX_READ_IDLE;\r\nfrm->cur_size = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int res_get(struct zr364xx_camera *cam)\r\n{\r\nmutex_lock(&cam->lock);\r\nif (cam->resources) {\r\nmutex_unlock(&cam->lock);\r\nreturn 0;\r\n}\r\ncam->resources = 1;\r\n_DBG("res: get\n");\r\nmutex_unlock(&cam->lock);\r\nreturn 1;\r\n}\r\nstatic inline int res_check(struct zr364xx_camera *cam)\r\n{\r\nreturn cam->resources;\r\n}\r\nstatic void res_free(struct zr364xx_camera *cam)\r\n{\r\nmutex_lock(&cam->lock);\r\ncam->resources = 0;\r\nmutex_unlock(&cam->lock);\r\n_DBG("res: put\n");\r\n}\r\nstatic int zr364xx_vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\nstrlcpy(cap->driver, DRIVER_DESC, sizeof(cap->driver));\r\nstrlcpy(cap->card, cam->udev->product, sizeof(cap->card));\r\nstrlcpy(cap->bus_info, dev_name(&cam->udev->dev),\r\nsizeof(cap->bus_info));\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING;\r\nreturn 0;\r\n}\r\nstatic int zr364xx_vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nif (i->index != 0)\r\nreturn -EINVAL;\r\nstrcpy(i->name, DRIVER_DESC " Camera");\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nreturn 0;\r\n}\r\nstatic int zr364xx_vidioc_g_input(struct file *file, void *priv,\r\nunsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int zr364xx_vidioc_s_input(struct file *file, void *priv,\r\nunsigned int i)\r\n{\r\nif (i != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int zr364xx_vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *c)\r\n{\r\nstruct zr364xx_camera *cam;\r\nif (file == NULL)\r\nreturn -ENODEV;\r\ncam = video_drvdata(file);\r\nswitch (c->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nc->type = V4L2_CTRL_TYPE_INTEGER;\r\nstrcpy(c->name, "Brightness");\r\nc->minimum = 0;\r\nc->maximum = 127;\r\nc->step = 1;\r\nc->default_value = cam->mode.brightness;\r\nc->flags = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zr364xx_vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *c)\r\n{\r\nstruct zr364xx_camera *cam;\r\nint temp;\r\nif (file == NULL)\r\nreturn -ENODEV;\r\ncam = video_drvdata(file);\r\nswitch (c->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\ncam->mode.brightness = c->value;\r\nmutex_lock(&cam->lock);\r\nsend_control_msg(cam->udev, 1, 0x2001, 0, NULL, 0);\r\ntemp = (0x60 << 8) + 127 - cam->mode.brightness;\r\nsend_control_msg(cam->udev, 1, temp, 0, NULL, 0);\r\nmutex_unlock(&cam->lock);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zr364xx_vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *c)\r\n{\r\nstruct zr364xx_camera *cam;\r\nif (file == NULL)\r\nreturn -ENODEV;\r\ncam = video_drvdata(file);\r\nswitch (c->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nc->value = cam->mode.brightness;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zr364xx_vidioc_enum_fmt_vid_cap(struct file *file,\r\nvoid *priv, struct v4l2_fmtdesc *f)\r\n{\r\nif (f->index > 0)\r\nreturn -EINVAL;\r\nf->flags = V4L2_FMT_FLAG_COMPRESSED;\r\nstrcpy(f->description, formats[0].name);\r\nf->pixelformat = formats[0].fourcc;\r\nreturn 0;\r\n}\r\nstatic char *decode_fourcc(__u32 pixelformat, char *buf)\r\n{\r\nbuf[0] = pixelformat & 0xff;\r\nbuf[1] = (pixelformat >> 8) & 0xff;\r\nbuf[2] = (pixelformat >> 16) & 0xff;\r\nbuf[3] = (pixelformat >> 24) & 0xff;\r\nbuf[4] = '\0';\r\nreturn buf;\r\n}\r\nstatic int zr364xx_vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\nchar pixelformat_name[5];\r\nif (cam == NULL)\r\nreturn -ENODEV;\r\nif (f->fmt.pix.pixelformat != V4L2_PIX_FMT_JPEG) {\r\nDBG("%s: unsupported pixelformat V4L2_PIX_FMT_%s\n", __func__,\r\ndecode_fourcc(f->fmt.pix.pixelformat, pixelformat_name));\r\nreturn -EINVAL;\r\n}\r\nif (!(f->fmt.pix.width == 160 && f->fmt.pix.height == 120) &&\r\n!(f->fmt.pix.width == 640 && f->fmt.pix.height == 480)) {\r\nf->fmt.pix.width = 320;\r\nf->fmt.pix.height = 240;\r\n}\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nf->fmt.pix.bytesperline = f->fmt.pix.width * 2;\r\nf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = 0;\r\nf->fmt.pix.priv = 0;\r\nDBG("%s: V4L2_PIX_FMT_%s (%d) ok!\n", __func__,\r\ndecode_fourcc(f->fmt.pix.pixelformat, pixelformat_name),\r\nf->fmt.pix.field);\r\nreturn 0;\r\n}\r\nstatic int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct zr364xx_camera *cam;\r\nif (file == NULL)\r\nreturn -ENODEV;\r\ncam = video_drvdata(file);\r\nf->fmt.pix.pixelformat = formats[0].fourcc;\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nf->fmt.pix.width = cam->width;\r\nf->fmt.pix.height = cam->height;\r\nf->fmt.pix.bytesperline = f->fmt.pix.width * 2;\r\nf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = 0;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int zr364xx_vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\nstruct videobuf_queue *q = &cam->vb_vidq;\r\nchar pixelformat_name[5];\r\nint ret = zr364xx_vidioc_try_fmt_vid_cap(file, cam, f);\r\nint i;\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&q->vb_lock);\r\nif (videobuf_queue_is_busy(&cam->vb_vidq)) {\r\nDBG("%s queue busy\n", __func__);\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (res_check(cam)) {\r\nDBG("%s can't change format after started\n", __func__);\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\ncam->width = f->fmt.pix.width;\r\ncam->height = f->fmt.pix.height;\r\ndev_info(&cam->udev->dev, "%s: %dx%d mode selected\n", __func__,\r\ncam->width, cam->height);\r\nf->fmt.pix.bytesperline = f->fmt.pix.width * 2;\r\nf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = 0;\r\nf->fmt.pix.priv = 0;\r\ncam->vb_vidq.field = f->fmt.pix.field;\r\ncam->mode.color = V4L2_PIX_FMT_JPEG;\r\nif (f->fmt.pix.width == 160 && f->fmt.pix.height == 120)\r\nmode = 1;\r\nelse if (f->fmt.pix.width == 640 && f->fmt.pix.height == 480)\r\nmode = 2;\r\nelse\r\nmode = 0;\r\nm0d1[0] = mode;\r\nm1[2].value = 0xf000 + mode;\r\nm2[1].value = 0xf000 + mode;\r\nif (cam->method == METHOD3) {\r\nswitch (mode) {\r\ncase 1:\r\nm2[1].value = 0xf000 + 4;\r\nbreak;\r\ncase 2:\r\nm2[1].value = 0xf000 + 0;\r\nbreak;\r\ndefault:\r\nm2[1].value = 0xf000 + 1;\r\nbreak;\r\n}\r\n}\r\nheader2[437] = cam->height / 256;\r\nheader2[438] = cam->height % 256;\r\nheader2[439] = cam->width / 256;\r\nheader2[440] = cam->width % 256;\r\nfor (i = 0; init[cam->method][i].size != -1; i++) {\r\nret =\r\nsend_control_msg(cam->udev, 1, init[cam->method][i].value,\r\n0, init[cam->method][i].bytes,\r\ninit[cam->method][i].size);\r\nif (ret < 0) {\r\ndev_err(&cam->udev->dev,\r\n"error during resolution change sequence: %d\n", i);\r\ngoto out;\r\n}\r\n}\r\nmdelay(100);\r\ncam->skip = 2;\r\nret = 0;\r\nout:\r\nmutex_unlock(&q->vb_lock);\r\nDBG("%s: V4L2_PIX_FMT_%s (%d) ok!\n", __func__,\r\ndecode_fourcc(f->fmt.pix.pixelformat, pixelformat_name),\r\nf->fmt.pix.field);\r\nreturn ret;\r\n}\r\nstatic int zr364xx_vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nint rc;\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\nrc = videobuf_reqbufs(&cam->vb_vidq, p);\r\nreturn rc;\r\n}\r\nstatic int zr364xx_vidioc_querybuf(struct file *file,\r\nvoid *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nint rc;\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\nrc = videobuf_querybuf(&cam->vb_vidq, p);\r\nreturn rc;\r\n}\r\nstatic int zr364xx_vidioc_qbuf(struct file *file,\r\nvoid *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nint rc;\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\n_DBG("%s\n", __func__);\r\nrc = videobuf_qbuf(&cam->vb_vidq, p);\r\nreturn rc;\r\n}\r\nstatic int zr364xx_vidioc_dqbuf(struct file *file,\r\nvoid *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nint rc;\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\n_DBG("%s\n", __func__);\r\nrc = videobuf_dqbuf(&cam->vb_vidq, p, file->f_flags & O_NONBLOCK);\r\nreturn rc;\r\n}\r\nstatic void read_pipe_completion(struct urb *purb)\r\n{\r\nstruct zr364xx_pipeinfo *pipe_info;\r\nstruct zr364xx_camera *cam;\r\nint pipe;\r\npipe_info = purb->context;\r\n_DBG("%s %p, status %d\n", __func__, purb, purb->status);\r\nif (pipe_info == NULL) {\r\nprintk(KERN_ERR KBUILD_MODNAME ": no context!\n");\r\nreturn;\r\n}\r\ncam = pipe_info->cam;\r\nif (cam == NULL) {\r\nprintk(KERN_ERR KBUILD_MODNAME ": no context!\n");\r\nreturn;\r\n}\r\nif (purb->status == -ESHUTDOWN) {\r\nDBG("%s, err shutdown\n", __func__);\r\npipe_info->err_count++;\r\nreturn;\r\n}\r\nif (pipe_info->state == 0) {\r\nDBG("exiting USB pipe\n");\r\nreturn;\r\n}\r\nif (purb->actual_length < 0 ||\r\npurb->actual_length > pipe_info->transfer_size) {\r\ndev_err(&cam->udev->dev, "wrong number of bytes\n");\r\nreturn;\r\n}\r\nif (purb->status == 0)\r\nzr364xx_read_video_callback(cam, pipe_info, purb);\r\nelse {\r\npipe_info->err_count++;\r\nDBG("%s: failed URB %d\n", __func__, purb->status);\r\n}\r\npipe = usb_rcvbulkpipe(cam->udev, cam->read_endpoint);\r\nusb_fill_bulk_urb(pipe_info->stream_urb, cam->udev,\r\npipe,\r\npipe_info->transfer_buffer,\r\npipe_info->transfer_size,\r\nread_pipe_completion, pipe_info);\r\nif (pipe_info->state != 0) {\r\npurb->status = usb_submit_urb(pipe_info->stream_urb,\r\nGFP_ATOMIC);\r\nif (purb->status)\r\ndev_err(&cam->udev->dev,\r\n"error submitting urb (error=%i)\n",\r\npurb->status);\r\n} else\r\nDBG("read pipe complete state 0\n");\r\n}\r\nstatic int zr364xx_start_readpipe(struct zr364xx_camera *cam)\r\n{\r\nint pipe;\r\nint retval;\r\nstruct zr364xx_pipeinfo *pipe_info = cam->pipe;\r\npipe = usb_rcvbulkpipe(cam->udev, cam->read_endpoint);\r\nDBG("%s: start pipe IN x%x\n", __func__, cam->read_endpoint);\r\npipe_info->state = 1;\r\npipe_info->err_count = 0;\r\npipe_info->stream_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!pipe_info->stream_urb) {\r\ndev_err(&cam->udev->dev, "ReadStream: Unable to alloc URB\n");\r\nreturn -ENOMEM;\r\n}\r\nusb_fill_bulk_urb(pipe_info->stream_urb, cam->udev,\r\npipe,\r\npipe_info->transfer_buffer,\r\npipe_info->transfer_size,\r\nread_pipe_completion, pipe_info);\r\nDBG("submitting URB %p\n", pipe_info->stream_urb);\r\nretval = usb_submit_urb(pipe_info->stream_urb, GFP_KERNEL);\r\nif (retval) {\r\nprintk(KERN_ERR KBUILD_MODNAME ": start read pipe failed\n");\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic void zr364xx_stop_readpipe(struct zr364xx_camera *cam)\r\n{\r\nstruct zr364xx_pipeinfo *pipe_info;\r\nif (cam == NULL) {\r\nprintk(KERN_ERR KBUILD_MODNAME ": invalid device\n");\r\nreturn;\r\n}\r\nDBG("stop read pipe\n");\r\npipe_info = cam->pipe;\r\nif (pipe_info) {\r\nif (pipe_info->state != 0)\r\npipe_info->state = 0;\r\nif (pipe_info->stream_urb) {\r\nusb_kill_urb(pipe_info->stream_urb);\r\nusb_free_urb(pipe_info->stream_urb);\r\npipe_info->stream_urb = NULL;\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic int zr364xx_start_acquire(struct zr364xx_camera *cam)\r\n{\r\nint j;\r\nDBG("start acquire\n");\r\ncam->last_frame = -1;\r\ncam->cur_frame = 0;\r\nfor (j = 0; j < FRAMES; j++) {\r\ncam->buffer.frame[j].ulState = ZR364XX_READ_IDLE;\r\ncam->buffer.frame[j].cur_size = 0;\r\n}\r\ncam->b_acquire = 1;\r\nreturn 0;\r\n}\r\nstatic inline int zr364xx_stop_acquire(struct zr364xx_camera *cam)\r\n{\r\ncam->b_acquire = 0;\r\nreturn 0;\r\n}\r\nstatic int zr364xx_vidioc_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\nint j;\r\nint res;\r\nDBG("%s\n", __func__);\r\nif (cam->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\ndev_err(&cam->udev->dev, "invalid fh type0\n");\r\nreturn -EINVAL;\r\n}\r\nif (cam->type != type) {\r\ndev_err(&cam->udev->dev, "invalid fh type1\n");\r\nreturn -EINVAL;\r\n}\r\nif (!res_get(cam)) {\r\ndev_err(&cam->udev->dev, "stream busy\n");\r\nreturn -EBUSY;\r\n}\r\ncam->last_frame = -1;\r\ncam->cur_frame = 0;\r\ncam->frame_count = 0;\r\nfor (j = 0; j < FRAMES; j++) {\r\ncam->buffer.frame[j].ulState = ZR364XX_READ_IDLE;\r\ncam->buffer.frame[j].cur_size = 0;\r\n}\r\nres = videobuf_streamon(&cam->vb_vidq);\r\nif (res == 0) {\r\nzr364xx_start_acquire(cam);\r\n} else {\r\nres_free(cam);\r\n}\r\nreturn res;\r\n}\r\nstatic int zr364xx_vidioc_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nint res;\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\nDBG("%s\n", __func__);\r\nif (cam->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\ndev_err(&cam->udev->dev, "invalid fh type0\n");\r\nreturn -EINVAL;\r\n}\r\nif (cam->type != type) {\r\ndev_err(&cam->udev->dev, "invalid fh type1\n");\r\nreturn -EINVAL;\r\n}\r\nzr364xx_stop_acquire(cam);\r\nres = videobuf_streamoff(&cam->vb_vidq);\r\nif (res < 0)\r\nreturn res;\r\nres_free(cam);\r\nreturn 0;\r\n}\r\nstatic int zr364xx_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\nstruct usb_device *udev = cam->udev;\r\nint i, err;\r\nDBG("%s\n", __func__);\r\nmutex_lock(&cam->open_lock);\r\nif (cam->users) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nfor (i = 0; init[cam->method][i].size != -1; i++) {\r\nerr =\r\nsend_control_msg(udev, 1, init[cam->method][i].value,\r\n0, init[cam->method][i].bytes,\r\ninit[cam->method][i].size);\r\nif (err < 0) {\r\ndev_err(&cam->udev->dev,\r\n"error during open sequence: %d\n", i);\r\ngoto out;\r\n}\r\n}\r\ncam->skip = 2;\r\ncam->users++;\r\nfile->private_data = vdev;\r\ncam->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ncam->fmt = formats;\r\nvideobuf_queue_vmalloc_init(&cam->vb_vidq, &zr364xx_video_qops,\r\nNULL, &cam->slock,\r\ncam->type,\r\nV4L2_FIELD_NONE,\r\nsizeof(struct zr364xx_buffer), cam, NULL);\r\nmdelay(100);\r\nerr = 0;\r\nout:\r\nmutex_unlock(&cam->open_lock);\r\nDBG("%s: %d\n", __func__, err);\r\nreturn err;\r\n}\r\nstatic void zr364xx_destroy(struct zr364xx_camera *cam)\r\n{\r\nunsigned long i;\r\nif (!cam) {\r\nprintk(KERN_ERR KBUILD_MODNAME ", %s: no device\n", __func__);\r\nreturn;\r\n}\r\nmutex_lock(&cam->open_lock);\r\nif (cam->vdev)\r\nvideo_unregister_device(cam->vdev);\r\ncam->vdev = NULL;\r\nif (cam->b_acquire)\r\nzr364xx_stop_acquire(cam);\r\nzr364xx_stop_readpipe(cam);\r\nfor (i = 0; i < FRAMES; i++) {\r\nif (cam->buffer.frame[i].lpvbits) {\r\nDBG("vfree %p\n", cam->buffer.frame[i].lpvbits);\r\nvfree(cam->buffer.frame[i].lpvbits);\r\n}\r\ncam->buffer.frame[i].lpvbits = NULL;\r\n}\r\nkfree(cam->pipe->transfer_buffer);\r\ncam->pipe->transfer_buffer = NULL;\r\nmutex_unlock(&cam->open_lock);\r\nkfree(cam);\r\ncam = NULL;\r\n}\r\nstatic int zr364xx_release(struct file *file)\r\n{\r\nstruct zr364xx_camera *cam;\r\nstruct usb_device *udev;\r\nint i, err;\r\nDBG("%s\n", __func__);\r\ncam = video_drvdata(file);\r\nif (!cam)\r\nreturn -ENODEV;\r\nmutex_lock(&cam->open_lock);\r\nudev = cam->udev;\r\nif (res_check(cam)) {\r\nif (cam->b_acquire)\r\nzr364xx_stop_acquire(cam);\r\nvideobuf_streamoff(&cam->vb_vidq);\r\nres_free(cam);\r\n}\r\ncam->users--;\r\nfile->private_data = NULL;\r\nfor (i = 0; i < 2; i++) {\r\nerr =\r\nsend_control_msg(udev, 1, init[cam->method][i].value,\r\n0, init[cam->method][i].bytes,\r\ninit[cam->method][i].size);\r\nif (err < 0) {\r\ndev_err(&udev->dev, "error during release sequence\n");\r\ngoto out;\r\n}\r\n}\r\nmdelay(100);\r\nerr = 0;\r\nout:\r\nmutex_unlock(&cam->open_lock);\r\nreturn err;\r\n}\r\nstatic int zr364xx_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\nint ret;\r\nif (cam == NULL) {\r\nDBG("%s: cam == NULL\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nDBG("mmap called, vma=0x%08lx\n", (unsigned long)vma);\r\nret = videobuf_mmap_mapper(&cam->vb_vidq, vma);\r\nDBG("vma start=0x%08lx, size=%ld, ret=%d\n",\r\n(unsigned long)vma->vm_start,\r\n(unsigned long)vma->vm_end - (unsigned long)vma->vm_start, ret);\r\nreturn ret;\r\n}\r\nstatic unsigned int zr364xx_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct zr364xx_camera *cam = video_drvdata(file);\r\nstruct videobuf_queue *q = &cam->vb_vidq;\r\n_DBG("%s\n", __func__);\r\nif (cam->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn POLLERR;\r\nreturn videobuf_poll_stream(file, q, wait);\r\n}\r\nstatic int zr364xx_board_init(struct zr364xx_camera *cam)\r\n{\r\nstruct zr364xx_pipeinfo *pipe = cam->pipe;\r\nunsigned long i;\r\nDBG("board init: %p\n", cam);\r\nmemset(pipe, 0, sizeof(*pipe));\r\npipe->cam = cam;\r\npipe->transfer_size = BUFFER_SIZE;\r\npipe->transfer_buffer = kzalloc(pipe->transfer_size,\r\nGFP_KERNEL);\r\nif (pipe->transfer_buffer == NULL) {\r\nDBG("out of memory!\n");\r\nreturn -ENOMEM;\r\n}\r\ncam->b_acquire = 0;\r\ncam->frame_count = 0;\r\nfor (i = 0; i < FRAMES; i++) {\r\ncam->buffer.frame[i].lpvbits = vmalloc(MAX_FRAME_SIZE);\r\nDBG("valloc %p, idx %lu, pdata %p\n",\r\n&cam->buffer.frame[i], i,\r\ncam->buffer.frame[i].lpvbits);\r\nif (cam->buffer.frame[i].lpvbits == NULL) {\r\nprintk(KERN_INFO KBUILD_MODNAME ": out of memory. "\r\n"Using less frames\n");\r\nbreak;\r\n}\r\n}\r\nif (i == 0) {\r\nprintk(KERN_INFO KBUILD_MODNAME ": out of memory. Aborting\n");\r\nkfree(cam->pipe->transfer_buffer);\r\ncam->pipe->transfer_buffer = NULL;\r\nreturn -ENOMEM;\r\n} else\r\ncam->buffer.dwFrames = i;\r\nfor (i = 0; i < FRAMES; i++) {\r\ncam->buffer.frame[i].ulState = ZR364XX_READ_IDLE;\r\ncam->buffer.frame[i].cur_size = 0;\r\n}\r\ncam->cur_frame = 0;\r\ncam->last_frame = -1;\r\nzr364xx_start_readpipe(cam);\r\nDBG(": board initialized\n");\r\nreturn 0;\r\n}\r\nstatic int zr364xx_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct zr364xx_camera *cam = NULL;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint err;\r\nint i;\r\nDBG("probing...\n");\r\ndev_info(&intf->dev, DRIVER_DESC " compatible webcam plugged\n");\r\ndev_info(&intf->dev, "model %04x:%04x detected\n",\r\nle16_to_cpu(udev->descriptor.idVendor),\r\nle16_to_cpu(udev->descriptor.idProduct));\r\ncam = kzalloc(sizeof(struct zr364xx_camera), GFP_KERNEL);\r\nif (cam == NULL) {\r\ndev_err(&udev->dev, "cam: out of memory !\n");\r\nreturn -ENOMEM;\r\n}\r\ncam->method = id->driver_info;\r\ncam->vdev = video_device_alloc();\r\nif (cam->vdev == NULL) {\r\ndev_err(&udev->dev, "cam->vdev: out of memory !\n");\r\nkfree(cam);\r\ncam = NULL;\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(cam->vdev, &zr364xx_template, sizeof(zr364xx_template));\r\ncam->vdev->parent = &intf->dev;\r\nvideo_set_drvdata(cam->vdev, cam);\r\nif (debug)\r\ncam->vdev->debug = V4L2_DEBUG_IOCTL | V4L2_DEBUG_IOCTL_ARG;\r\ncam->udev = udev;\r\nswitch (mode) {\r\ncase 1:\r\ndev_info(&udev->dev, "160x120 mode selected\n");\r\ncam->width = 160;\r\ncam->height = 120;\r\nbreak;\r\ncase 2:\r\ndev_info(&udev->dev, "640x480 mode selected\n");\r\ncam->width = 640;\r\ncam->height = 480;\r\nbreak;\r\ndefault:\r\ndev_info(&udev->dev, "320x240 mode selected\n");\r\ncam->width = 320;\r\ncam->height = 240;\r\nbreak;\r\n}\r\nm0d1[0] = mode;\r\nm1[2].value = 0xf000 + mode;\r\nm2[1].value = 0xf000 + mode;\r\nif (cam->method == METHOD3) {\r\nswitch (mode) {\r\ncase 1:\r\nm2[1].value = 0xf000 + 4;\r\nbreak;\r\ncase 2:\r\nm2[1].value = 0xf000 + 0;\r\nbreak;\r\ndefault:\r\nm2[1].value = 0xf000 + 1;\r\nbreak;\r\n}\r\n}\r\nheader2[437] = cam->height / 256;\r\nheader2[438] = cam->height % 256;\r\nheader2[439] = cam->width / 256;\r\nheader2[440] = cam->width % 256;\r\ncam->users = 0;\r\ncam->nb = 0;\r\ncam->mode.brightness = 64;\r\nmutex_init(&cam->lock);\r\nmutex_init(&cam->open_lock);\r\nDBG("dev: %p, udev %p interface %p\n", cam, cam->udev, intf);\r\niface_desc = intf->cur_altsetting;\r\nDBG("num endpoints %d\n", iface_desc->desc.bNumEndpoints);\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (!cam->read_endpoint && usb_endpoint_is_bulk_in(endpoint)) {\r\ncam->read_endpoint = endpoint->bEndpointAddress;\r\n}\r\n}\r\nif (!cam->read_endpoint) {\r\ndev_err(&intf->dev, "Could not find bulk-in endpoint\n");\r\nvideo_device_release(cam->vdev);\r\nkfree(cam);\r\ncam = NULL;\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&cam->vidq.active);\r\ncam->vidq.cam = cam;\r\nerr = video_register_device(cam->vdev, VFL_TYPE_GRABBER, -1);\r\nif (err) {\r\ndev_err(&udev->dev, "video_register_device failed\n");\r\nvideo_device_release(cam->vdev);\r\nkfree(cam);\r\ncam = NULL;\r\nreturn err;\r\n}\r\nusb_set_intfdata(intf, cam);\r\nerr = zr364xx_board_init(cam);\r\nif (err) {\r\nspin_lock_init(&cam->slock);\r\nreturn err;\r\n}\r\nspin_lock_init(&cam->slock);\r\ndev_info(&udev->dev, DRIVER_DESC " controlling device %s\n",\r\nvideo_device_node_name(cam->vdev));\r\nreturn 0;\r\n}\r\nstatic void zr364xx_disconnect(struct usb_interface *intf)\r\n{\r\nstruct zr364xx_camera *cam = usb_get_intfdata(intf);\r\nvideobuf_mmap_free(&cam->vb_vidq);\r\nusb_set_intfdata(intf, NULL);\r\ndev_info(&intf->dev, DRIVER_DESC " webcam unplugged\n");\r\nzr364xx_destroy(cam);\r\n}
