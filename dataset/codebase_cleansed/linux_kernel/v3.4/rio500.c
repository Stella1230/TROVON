static int open_rio(struct inode *inode, struct file *file)\r\n{\r\nstruct rio_usb_data *rio = &rio_instance;\r\nmutex_lock(&rio500_mutex);\r\nmutex_lock(&(rio->lock));\r\nif (rio->isopen || !rio->present) {\r\nmutex_unlock(&(rio->lock));\r\nmutex_unlock(&rio500_mutex);\r\nreturn -EBUSY;\r\n}\r\nrio->isopen = 1;\r\ninit_waitqueue_head(&rio->wait_q);\r\nmutex_unlock(&(rio->lock));\r\ndev_info(&rio->rio_dev->dev, "Rio opened.\n");\r\nmutex_unlock(&rio500_mutex);\r\nreturn 0;\r\n}\r\nstatic int close_rio(struct inode *inode, struct file *file)\r\n{\r\nstruct rio_usb_data *rio = &rio_instance;\r\nrio->isopen = 0;\r\ndev_info(&rio->rio_dev->dev, "Rio closed.\n");\r\nreturn 0;\r\n}\r\nstatic long ioctl_rio(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct RioCommand rio_cmd;\r\nstruct rio_usb_data *rio = &rio_instance;\r\nvoid __user *data;\r\nunsigned char *buffer;\r\nint result, requesttype;\r\nint retries;\r\nint retval=0;\r\nmutex_lock(&(rio->lock));\r\nif (rio->present == 0 || rio->rio_dev == NULL) {\r\nretval = -ENODEV;\r\ngoto err_out;\r\n}\r\nswitch (cmd) {\r\ncase RIO_RECV_COMMAND:\r\ndata = (void __user *) arg;\r\nif (data == NULL)\r\nbreak;\r\nif (copy_from_user(&rio_cmd, data, sizeof(struct RioCommand))) {\r\nretval = -EFAULT;\r\ngoto err_out;\r\n}\r\nif (rio_cmd.length < 0 || rio_cmd.length > PAGE_SIZE) {\r\nretval = -EINVAL;\r\ngoto err_out;\r\n}\r\nbuffer = (unsigned char *) __get_free_page(GFP_KERNEL);\r\nif (buffer == NULL) {\r\nretval = -ENOMEM;\r\ngoto err_out;\r\n}\r\nif (copy_from_user(buffer, rio_cmd.buffer, rio_cmd.length)) {\r\nretval = -EFAULT;\r\nfree_page((unsigned long) buffer);\r\ngoto err_out;\r\n}\r\nrequesttype = rio_cmd.requesttype | USB_DIR_IN |\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE;\r\ndbg\r\n("sending command:reqtype=%0x req=%0x value=%0x index=%0x len=%0x",\r\nrequesttype, rio_cmd.request, rio_cmd.value,\r\nrio_cmd.index, rio_cmd.length);\r\nretries = 3;\r\nwhile (retries) {\r\nresult = usb_control_msg(rio->rio_dev,\r\nusb_rcvctrlpipe(rio-> rio_dev, 0),\r\nrio_cmd.request,\r\nrequesttype,\r\nrio_cmd.value,\r\nrio_cmd.index, buffer,\r\nrio_cmd.length,\r\njiffies_to_msecs(rio_cmd.timeout));\r\nif (result == -ETIMEDOUT)\r\nretries--;\r\nelse if (result < 0) {\r\nerr("Error executing ioctrl. code = %d", result);\r\nretries = 0;\r\n} else {\r\ndbg("Executed ioctl. Result = %d (data=%02x)",\r\nresult, buffer[0]);\r\nif (copy_to_user(rio_cmd.buffer, buffer,\r\nrio_cmd.length)) {\r\nfree_page((unsigned long) buffer);\r\nretval = -EFAULT;\r\ngoto err_out;\r\n}\r\nretries = 0;\r\n}\r\n}\r\nfree_page((unsigned long) buffer);\r\nbreak;\r\ncase RIO_SEND_COMMAND:\r\ndata = (void __user *) arg;\r\nif (data == NULL)\r\nbreak;\r\nif (copy_from_user(&rio_cmd, data, sizeof(struct RioCommand))) {\r\nretval = -EFAULT;\r\ngoto err_out;\r\n}\r\nif (rio_cmd.length < 0 || rio_cmd.length > PAGE_SIZE) {\r\nretval = -EINVAL;\r\ngoto err_out;\r\n}\r\nbuffer = (unsigned char *) __get_free_page(GFP_KERNEL);\r\nif (buffer == NULL) {\r\nretval = -ENOMEM;\r\ngoto err_out;\r\n}\r\nif (copy_from_user(buffer, rio_cmd.buffer, rio_cmd.length)) {\r\nfree_page((unsigned long)buffer);\r\nretval = -EFAULT;\r\ngoto err_out;\r\n}\r\nrequesttype = rio_cmd.requesttype | USB_DIR_OUT |\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE;\r\ndbg("sending command: reqtype=%0x req=%0x value=%0x index=%0x len=%0x",\r\nrequesttype, rio_cmd.request, rio_cmd.value,\r\nrio_cmd.index, rio_cmd.length);\r\nretries = 3;\r\nwhile (retries) {\r\nresult = usb_control_msg(rio->rio_dev,\r\nusb_sndctrlpipe(rio-> rio_dev, 0),\r\nrio_cmd.request,\r\nrequesttype,\r\nrio_cmd.value,\r\nrio_cmd.index, buffer,\r\nrio_cmd.length,\r\njiffies_to_msecs(rio_cmd.timeout));\r\nif (result == -ETIMEDOUT)\r\nretries--;\r\nelse if (result < 0) {\r\nerr("Error executing ioctrl. code = %d", result);\r\nretries = 0;\r\n} else {\r\ndbg("Executed ioctl. Result = %d", result);\r\nretries = 0;\r\n}\r\n}\r\nfree_page((unsigned long) buffer);\r\nbreak;\r\ndefault:\r\nretval = -ENOTTY;\r\nbreak;\r\n}\r\nerr_out:\r\nmutex_unlock(&(rio->lock));\r\nreturn retval;\r\n}\r\nstatic ssize_t\r\nwrite_rio(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t * ppos)\r\n{\r\nDEFINE_WAIT(wait);\r\nstruct rio_usb_data *rio = &rio_instance;\r\nunsigned long copy_size;\r\nunsigned long bytes_written = 0;\r\nunsigned int partial;\r\nint result = 0;\r\nint maxretry;\r\nint errn = 0;\r\nint intr;\r\nintr = mutex_lock_interruptible(&(rio->lock));\r\nif (intr)\r\nreturn -EINTR;\r\nif (rio->present == 0 || rio->rio_dev == NULL) {\r\nmutex_unlock(&(rio->lock));\r\nreturn -ENODEV;\r\n}\r\ndo {\r\nunsigned long thistime;\r\nchar *obuf = rio->obuf;\r\nthistime = copy_size =\r\n(count >= OBUF_SIZE) ? OBUF_SIZE : count;\r\nif (copy_from_user(rio->obuf, buffer, copy_size)) {\r\nerrn = -EFAULT;\r\ngoto error;\r\n}\r\nmaxretry = 5;\r\nwhile (thistime) {\r\nif (!rio->rio_dev) {\r\nerrn = -ENODEV;\r\ngoto error;\r\n}\r\nif (signal_pending(current)) {\r\nmutex_unlock(&(rio->lock));\r\nreturn bytes_written ? bytes_written : -EINTR;\r\n}\r\nresult = usb_bulk_msg(rio->rio_dev,\r\nusb_sndbulkpipe(rio->rio_dev, 2),\r\nobuf, thistime, &partial, 5000);\r\ndbg("write stats: result:%d thistime:%lu partial:%u",\r\nresult, thistime, partial);\r\nif (result == -ETIMEDOUT) {\r\nif (!maxretry--) {\r\nerrn = -ETIME;\r\ngoto error;\r\n}\r\nprepare_to_wait(&rio->wait_q, &wait, TASK_INTERRUPTIBLE);\r\nschedule_timeout(NAK_TIMEOUT);\r\nfinish_wait(&rio->wait_q, &wait);\r\ncontinue;\r\n} else if (!result && partial) {\r\nobuf += partial;\r\nthistime -= partial;\r\n} else\r\nbreak;\r\n};\r\nif (result) {\r\nerr("Write Whoops - %x", result);\r\nerrn = -EIO;\r\ngoto error;\r\n}\r\nbytes_written += copy_size;\r\ncount -= copy_size;\r\nbuffer += copy_size;\r\n} while (count > 0);\r\nmutex_unlock(&(rio->lock));\r\nreturn bytes_written ? bytes_written : -EIO;\r\nerror:\r\nmutex_unlock(&(rio->lock));\r\nreturn errn;\r\n}\r\nstatic ssize_t\r\nread_rio(struct file *file, char __user *buffer, size_t count, loff_t * ppos)\r\n{\r\nDEFINE_WAIT(wait);\r\nstruct rio_usb_data *rio = &rio_instance;\r\nssize_t read_count;\r\nunsigned int partial;\r\nint this_read;\r\nint result;\r\nint maxretry = 10;\r\nchar *ibuf;\r\nint intr;\r\nintr = mutex_lock_interruptible(&(rio->lock));\r\nif (intr)\r\nreturn -EINTR;\r\nif (rio->present == 0 || rio->rio_dev == NULL) {\r\nmutex_unlock(&(rio->lock));\r\nreturn -ENODEV;\r\n}\r\nibuf = rio->ibuf;\r\nread_count = 0;\r\nwhile (count > 0) {\r\nif (signal_pending(current)) {\r\nmutex_unlock(&(rio->lock));\r\nreturn read_count ? read_count : -EINTR;\r\n}\r\nif (!rio->rio_dev) {\r\nmutex_unlock(&(rio->lock));\r\nreturn -ENODEV;\r\n}\r\nthis_read = (count >= IBUF_SIZE) ? IBUF_SIZE : count;\r\nresult = usb_bulk_msg(rio->rio_dev,\r\nusb_rcvbulkpipe(rio->rio_dev, 1),\r\nibuf, this_read, &partial,\r\n8000);\r\ndbg("read stats: result:%d this_read:%u partial:%u",\r\nresult, this_read, partial);\r\nif (partial) {\r\ncount = this_read = partial;\r\n} else if (result == -ETIMEDOUT || result == 15) {\r\nif (!maxretry--) {\r\nmutex_unlock(&(rio->lock));\r\nerr("read_rio: maxretry timeout");\r\nreturn -ETIME;\r\n}\r\nprepare_to_wait(&rio->wait_q, &wait, TASK_INTERRUPTIBLE);\r\nschedule_timeout(NAK_TIMEOUT);\r\nfinish_wait(&rio->wait_q, &wait);\r\ncontinue;\r\n} else if (result != -EREMOTEIO) {\r\nmutex_unlock(&(rio->lock));\r\nerr("Read Whoops - result:%u partial:%u this_read:%u",\r\nresult, partial, this_read);\r\nreturn -EIO;\r\n} else {\r\nmutex_unlock(&(rio->lock));\r\nreturn (0);\r\n}\r\nif (this_read) {\r\nif (copy_to_user(buffer, ibuf, this_read)) {\r\nmutex_unlock(&(rio->lock));\r\nreturn -EFAULT;\r\n}\r\ncount -= this_read;\r\nread_count += this_read;\r\nbuffer += this_read;\r\n}\r\n}\r\nmutex_unlock(&(rio->lock));\r\nreturn read_count;\r\n}\r\nstatic int probe_rio(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nstruct rio_usb_data *rio = &rio_instance;\r\nint retval;\r\ndev_info(&intf->dev, "USB Rio found at address %d\n", dev->devnum);\r\nretval = usb_register_dev(intf, &usb_rio_class);\r\nif (retval) {\r\nerr("Not able to get a minor for this device.");\r\nreturn -ENOMEM;\r\n}\r\nrio->rio_dev = dev;\r\nif (!(rio->obuf = kmalloc(OBUF_SIZE, GFP_KERNEL))) {\r\nerr("probe_rio: Not enough memory for the output buffer");\r\nusb_deregister_dev(intf, &usb_rio_class);\r\nreturn -ENOMEM;\r\n}\r\ndbg("probe_rio: obuf address:%p", rio->obuf);\r\nif (!(rio->ibuf = kmalloc(IBUF_SIZE, GFP_KERNEL))) {\r\nerr("probe_rio: Not enough memory for the input buffer");\r\nusb_deregister_dev(intf, &usb_rio_class);\r\nkfree(rio->obuf);\r\nreturn -ENOMEM;\r\n}\r\ndbg("probe_rio: ibuf address:%p", rio->ibuf);\r\nmutex_init(&(rio->lock));\r\nusb_set_intfdata (intf, rio);\r\nrio->present = 1;\r\nreturn 0;\r\n}\r\nstatic void disconnect_rio(struct usb_interface *intf)\r\n{\r\nstruct rio_usb_data *rio = usb_get_intfdata (intf);\r\nusb_set_intfdata (intf, NULL);\r\nmutex_lock(&rio500_mutex);\r\nif (rio) {\r\nusb_deregister_dev(intf, &usb_rio_class);\r\nmutex_lock(&(rio->lock));\r\nif (rio->isopen) {\r\nrio->isopen = 0;\r\nrio->rio_dev = NULL;\r\nmutex_unlock(&(rio->lock));\r\nmutex_unlock(&rio500_mutex);\r\nreturn;\r\n}\r\nkfree(rio->ibuf);\r\nkfree(rio->obuf);\r\ndev_info(&intf->dev, "USB Rio disconnected.\n");\r\nrio->present = 0;\r\nmutex_unlock(&(rio->lock));\r\n}\r\nmutex_unlock(&rio500_mutex);\r\n}
