static inline void set_sysmmu_active(sysmmu_ips ips)\r\n{\r\nsysmmu_states |= 3 << (ips * 2);\r\n}\r\nstatic inline void set_sysmmu_inactive(sysmmu_ips ips)\r\n{\r\nsysmmu_states &= ~(3 << (ips * 2));\r\n}\r\nstatic inline int is_sysmmu_active(sysmmu_ips ips)\r\n{\r\nreturn sysmmu_states & (3 << (ips * 2));\r\n}\r\nstatic inline void sysmmu_block(sysmmu_ips ips)\r\n{\r\n__raw_writel(CTRL_BLOCK, sysmmusfrs[ips] + S5P_MMU_CTRL);\r\ndev_dbg(dev, "%s is blocked.\n", sysmmu_ips_name[ips]);\r\n}\r\nstatic inline void sysmmu_unblock(sysmmu_ips ips)\r\n{\r\n__raw_writel(CTRL_ENABLE, sysmmusfrs[ips] + S5P_MMU_CTRL);\r\ndev_dbg(dev, "%s is unblocked.\n", sysmmu_ips_name[ips]);\r\n}\r\nstatic inline void __sysmmu_tlb_invalidate(sysmmu_ips ips)\r\n{\r\n__raw_writel(0x1, sysmmusfrs[ips] + S5P_MMU_FLUSH);\r\ndev_dbg(dev, "TLB of %s is invalidated.\n", sysmmu_ips_name[ips]);\r\n}\r\nstatic inline void __sysmmu_set_ptbase(sysmmu_ips ips, unsigned long pgd)\r\n{\r\nif (unlikely(pgd == 0)) {\r\npgd = (unsigned long)ZERO_PAGE(0);\r\n__raw_writel(0x20, sysmmusfrs[ips] + S5P_MMU_CFG);\r\n} else {\r\n__raw_writel(0x0, sysmmusfrs[ips] + S5P_MMU_CFG);\r\n}\r\n__raw_writel(pgd, sysmmusfrs[ips] + S5P_PT_BASE_ADDR);\r\ndev_dbg(dev, "Page table base of %s is initialized with 0x%08lX.\n",\r\nsysmmu_ips_name[ips], pgd);\r\n__sysmmu_tlb_invalidate(ips);\r\n}\r\nvoid sysmmu_set_fault_handler(sysmmu_ips ips,\r\nint (*handler)(enum S5P_SYSMMU_INTERRUPT_TYPE itype,\r\nunsigned long pgtable_base,\r\nunsigned long fault_addr))\r\n{\r\nBUG_ON(!((ips >= SYSMMU_MDMA) && (ips < S5P_SYSMMU_TOTAL_IPNUM)));\r\nfault_handlers[ips] = handler;\r\n}\r\nstatic irqreturn_t s5p_sysmmu_irq(int irq, void *dev_id)\r\n{\r\nunsigned long base = 0;\r\nsysmmu_ips ips = (sysmmu_ips)dev_id;\r\nenum S5P_SYSMMU_INTERRUPT_TYPE itype;\r\nitype = (enum S5P_SYSMMU_INTERRUPT_TYPE)\r\n__ffs(__raw_readl(sysmmusfrs[ips] + S5P_INT_STATUS));\r\nBUG_ON(!((itype >= 0) && (itype < 8)));\r\ndev_alert(dev, "%s occurred by %s.\n", sysmmu_fault_name[itype],\r\nsysmmu_ips_name[ips]);\r\nif (fault_handlers[ips]) {\r\nunsigned long addr;\r\nbase = __raw_readl(sysmmusfrs[ips] + S5P_PT_BASE_ADDR);\r\naddr = __raw_readl(sysmmusfrs[ips] + fault_reg_offset[itype]);\r\nif (fault_handlers[ips](itype, base, addr)) {\r\n__raw_writel(1 << itype,\r\nsysmmusfrs[ips] + S5P_INT_CLEAR);\r\ndev_notice(dev, "%s from %s is resolved."\r\n" Retrying translation.\n",\r\nsysmmu_fault_name[itype], sysmmu_ips_name[ips]);\r\n} else {\r\nbase = 0;\r\n}\r\n}\r\nsysmmu_unblock(ips);\r\nif (!base)\r\ndev_notice(dev, "%s from %s is not handled.\n",\r\nsysmmu_fault_name[itype], sysmmu_ips_name[ips]);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid s5p_sysmmu_set_tablebase_pgd(sysmmu_ips ips, unsigned long pgd)\r\n{\r\nif (is_sysmmu_active(ips)) {\r\nsysmmu_block(ips);\r\n__sysmmu_set_ptbase(ips, pgd);\r\nsysmmu_unblock(ips);\r\n} else {\r\ndev_dbg(dev, "%s is disabled. "\r\n"Skipping initializing page table base.\n",\r\nsysmmu_ips_name[ips]);\r\n}\r\n}\r\nvoid s5p_sysmmu_enable(sysmmu_ips ips, unsigned long pgd)\r\n{\r\nif (!is_sysmmu_active(ips)) {\r\nsysmmu_clk_enable(ips);\r\n__sysmmu_set_ptbase(ips, pgd);\r\n__raw_writel(CTRL_ENABLE, sysmmusfrs[ips] + S5P_MMU_CTRL);\r\nset_sysmmu_active(ips);\r\ndev_dbg(dev, "%s is enabled.\n", sysmmu_ips_name[ips]);\r\n} else {\r\ndev_dbg(dev, "%s is already enabled.\n", sysmmu_ips_name[ips]);\r\n}\r\n}\r\nvoid s5p_sysmmu_disable(sysmmu_ips ips)\r\n{\r\nif (is_sysmmu_active(ips)) {\r\n__raw_writel(CTRL_DISABLE, sysmmusfrs[ips] + S5P_MMU_CTRL);\r\nset_sysmmu_inactive(ips);\r\nsysmmu_clk_disable(ips);\r\ndev_dbg(dev, "%s is disabled.\n", sysmmu_ips_name[ips]);\r\n} else {\r\ndev_dbg(dev, "%s is already disabled.\n", sysmmu_ips_name[ips]);\r\n}\r\n}\r\nvoid s5p_sysmmu_tlb_invalidate(sysmmu_ips ips)\r\n{\r\nif (is_sysmmu_active(ips)) {\r\nsysmmu_block(ips);\r\n__sysmmu_tlb_invalidate(ips);\r\nsysmmu_unblock(ips);\r\n} else {\r\ndev_dbg(dev, "%s is disabled. "\r\n"Skipping invalidating TLB.\n", sysmmu_ips_name[ips]);\r\n}\r\n}\r\nstatic int s5p_sysmmu_probe(struct platform_device *pdev)\r\n{\r\nint i, ret;\r\nstruct resource *res, *mem;\r\ndev = &pdev->dev;\r\nfor (i = 0; i < S5P_SYSMMU_TOTAL_IPNUM; i++) {\r\nint irq;\r\nsysmmu_clk_init(dev, i);\r\nsysmmu_clk_disable(i);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, i);\r\nif (!res) {\r\ndev_err(dev, "Failed to get the resource of %s.\n",\r\nsysmmu_ips_name[i]);\r\nret = -ENODEV;\r\ngoto err_res;\r\n}\r\nmem = request_mem_region(res->start, resource_size(res),\r\npdev->name);\r\nif (!mem) {\r\ndev_err(dev, "Failed to request the memory region of %s.\n",\r\nsysmmu_ips_name[i]);\r\nret = -EBUSY;\r\ngoto err_res;\r\n}\r\nsysmmusfrs[i] = ioremap(res->start, resource_size(res));\r\nif (!sysmmusfrs[i]) {\r\ndev_err(dev, "Failed to ioremap() for %s.\n",\r\nsysmmu_ips_name[i]);\r\nret = -ENXIO;\r\ngoto err_reg;\r\n}\r\nirq = platform_get_irq(pdev, i);\r\nif (irq <= 0) {\r\ndev_err(dev, "Failed to get the IRQ resource of %s.\n",\r\nsysmmu_ips_name[i]);\r\nret = -ENOENT;\r\ngoto err_map;\r\n}\r\nif (request_irq(irq, s5p_sysmmu_irq, IRQF_DISABLED,\r\npdev->name, (void *)i)) {\r\ndev_err(dev, "Failed to request IRQ for %s.\n",\r\nsysmmu_ips_name[i]);\r\nret = -ENOENT;\r\ngoto err_map;\r\n}\r\n}\r\nreturn 0;\r\nerr_map:\r\niounmap(sysmmusfrs[i]);\r\nerr_reg:\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nerr_res:\r\nreturn ret;\r\n}\r\nstatic int s5p_sysmmu_remove(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nint s5p_sysmmu_runtime_suspend(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nint s5p_sysmmu_runtime_resume(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init s5p_sysmmu_init(void)\r\n{\r\nreturn platform_driver_register(&s5p_sysmmu_driver);\r\n}
