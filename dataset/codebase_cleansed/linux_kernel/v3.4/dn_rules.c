int dn_fib_lookup(struct flowidn *flp, struct dn_fib_res *res)\r\n{\r\nstruct fib_lookup_arg arg = {\r\n.result = res,\r\n};\r\nint err;\r\nerr = fib_rules_lookup(dn_fib_rules_ops,\r\nflowidn_to_flowi(flp), 0, &arg);\r\nres->r = arg.rule;\r\nreturn err;\r\n}\r\nstatic int dn_fib_rule_action(struct fib_rule *rule, struct flowi *flp,\r\nint flags, struct fib_lookup_arg *arg)\r\n{\r\nstruct flowidn *fld = &flp->u.dn;\r\nint err = -EAGAIN;\r\nstruct dn_fib_table *tbl;\r\nswitch(rule->action) {\r\ncase FR_ACT_TO_TBL:\r\nbreak;\r\ncase FR_ACT_UNREACHABLE:\r\nerr = -ENETUNREACH;\r\ngoto errout;\r\ncase FR_ACT_PROHIBIT:\r\nerr = -EACCES;\r\ngoto errout;\r\ncase FR_ACT_BLACKHOLE:\r\ndefault:\r\nerr = -EINVAL;\r\ngoto errout;\r\n}\r\ntbl = dn_fib_get_table(rule->table, 0);\r\nif (tbl == NULL)\r\ngoto errout;\r\nerr = tbl->lookup(tbl, fld, (struct dn_fib_res *)arg->result);\r\nif (err > 0)\r\nerr = -EAGAIN;\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int dn_fib_rule_match(struct fib_rule *rule, struct flowi *fl, int flags)\r\n{\r\nstruct dn_fib_rule *r = (struct dn_fib_rule *)rule;\r\nstruct flowidn *fld = &fl->u.dn;\r\n__le16 daddr = fld->daddr;\r\n__le16 saddr = fld->saddr;\r\nif (((saddr ^ r->src) & r->srcmask) ||\r\n((daddr ^ r->dst) & r->dstmask))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int dn_fib_rule_configure(struct fib_rule *rule, struct sk_buff *skb,\r\nstruct fib_rule_hdr *frh,\r\nstruct nlattr **tb)\r\n{\r\nint err = -EINVAL;\r\nstruct dn_fib_rule *r = (struct dn_fib_rule *)rule;\r\nif (frh->tos)\r\ngoto errout;\r\nif (rule->table == RT_TABLE_UNSPEC) {\r\nif (rule->action == FR_ACT_TO_TBL) {\r\nstruct dn_fib_table *table;\r\ntable = dn_fib_empty_table();\r\nif (table == NULL) {\r\nerr = -ENOBUFS;\r\ngoto errout;\r\n}\r\nrule->table = table->n;\r\n}\r\n}\r\nif (frh->src_len)\r\nr->src = nla_get_le16(tb[FRA_SRC]);\r\nif (frh->dst_len)\r\nr->dst = nla_get_le16(tb[FRA_DST]);\r\nr->src_len = frh->src_len;\r\nr->srcmask = dnet_make_mask(r->src_len);\r\nr->dst_len = frh->dst_len;\r\nr->dstmask = dnet_make_mask(r->dst_len);\r\nerr = 0;\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int dn_fib_rule_compare(struct fib_rule *rule, struct fib_rule_hdr *frh,\r\nstruct nlattr **tb)\r\n{\r\nstruct dn_fib_rule *r = (struct dn_fib_rule *)rule;\r\nif (frh->src_len && (r->src_len != frh->src_len))\r\nreturn 0;\r\nif (frh->dst_len && (r->dst_len != frh->dst_len))\r\nreturn 0;\r\nif (frh->src_len && (r->src != nla_get_le16(tb[FRA_SRC])))\r\nreturn 0;\r\nif (frh->dst_len && (r->dst != nla_get_le16(tb[FRA_DST])))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nunsigned dnet_addr_type(__le16 addr)\r\n{\r\nstruct flowidn fld = { .daddr = addr };\r\nstruct dn_fib_res res;\r\nunsigned ret = RTN_UNICAST;\r\nstruct dn_fib_table *tb = dn_fib_get_table(RT_TABLE_LOCAL, 0);\r\nres.r = NULL;\r\nif (tb) {\r\nif (!tb->lookup(tb, &fld, &res)) {\r\nret = res.type;\r\ndn_fib_res_put(&res);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int dn_fib_rule_fill(struct fib_rule *rule, struct sk_buff *skb,\r\nstruct fib_rule_hdr *frh)\r\n{\r\nstruct dn_fib_rule *r = (struct dn_fib_rule *)rule;\r\nfrh->dst_len = r->dst_len;\r\nfrh->src_len = r->src_len;\r\nfrh->tos = 0;\r\nif (r->dst_len)\r\nNLA_PUT_LE16(skb, FRA_DST, r->dst);\r\nif (r->src_len)\r\nNLA_PUT_LE16(skb, FRA_SRC, r->src);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -ENOBUFS;\r\n}\r\nstatic void dn_fib_rule_flush_cache(struct fib_rules_ops *ops)\r\n{\r\ndn_rt_cache_flush(-1);\r\n}\r\nvoid __init dn_fib_rules_init(void)\r\n{\r\ndn_fib_rules_ops =\r\nfib_rules_register(&dn_fib_rules_ops_template, &init_net);\r\nBUG_ON(IS_ERR(dn_fib_rules_ops));\r\nBUG_ON(fib_default_rule_add(dn_fib_rules_ops, 0x7fff,\r\nRT_TABLE_MAIN, 0));\r\n}\r\nvoid __exit dn_fib_rules_cleanup(void)\r\n{\r\nfib_rules_unregister(dn_fib_rules_ops);\r\nrcu_barrier();\r\n}
