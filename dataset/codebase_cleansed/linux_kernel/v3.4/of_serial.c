static int __devinit of_platform_serial_setup(struct platform_device *ofdev,\r\nint type, struct uart_port *port)\r\n{\r\nstruct resource resource;\r\nstruct device_node *np = ofdev->dev.of_node;\r\nu32 clk, spd, prop;\r\nint ret;\r\nmemset(port, 0, sizeof *port);\r\nif (of_property_read_u32(np, "clock-frequency", &clk)) {\r\ndev_warn(&ofdev->dev, "no clock-frequency property set\n");\r\nreturn -ENODEV;\r\n}\r\nif (of_property_read_u32(np, "current-speed", &spd) == 0)\r\nport->custom_divisor = clk / (16 * spd);\r\nret = of_address_to_resource(np, 0, &resource);\r\nif (ret) {\r\ndev_warn(&ofdev->dev, "invalid address\n");\r\nreturn ret;\r\n}\r\nspin_lock_init(&port->lock);\r\nport->mapbase = resource.start;\r\nif (of_property_read_u32(np, "reg-offset", &prop) == 0)\r\nport->mapbase += prop;\r\nif (of_property_read_u32(np, "reg-shift", &prop) == 0)\r\nport->regshift = prop;\r\nport->irq = irq_of_parse_and_map(np, 0);\r\nport->iotype = UPIO_MEM;\r\nif (of_property_read_u32(np, "reg-io-width", &prop) == 0) {\r\nswitch (prop) {\r\ncase 1:\r\nport->iotype = UPIO_MEM;\r\nbreak;\r\ncase 4:\r\nport->iotype = UPIO_MEM32;\r\nbreak;\r\ndefault:\r\ndev_warn(&ofdev->dev, "unsupported reg-io-width (%d)\n",\r\nprop);\r\nreturn -EINVAL;\r\n}\r\n}\r\nport->type = type;\r\nport->uartclk = clk;\r\nport->flags = UPF_SHARE_IRQ | UPF_BOOT_AUTOCONF | UPF_IOREMAP\r\n| UPF_FIXED_PORT | UPF_FIXED_TYPE;\r\nport->dev = &ofdev->dev;\r\nreturn 0;\r\n}\r\nstatic int __devinit of_platform_serial_probe(struct platform_device *ofdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct of_serial_info *info;\r\nstruct uart_port port;\r\nint port_type;\r\nint ret;\r\nmatch = of_match_device(of_platform_serial_table, &ofdev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nif (of_find_property(ofdev->dev.of_node, "used-by-rtas", NULL))\r\nreturn -EBUSY;\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (info == NULL)\r\nreturn -ENOMEM;\r\nport_type = (unsigned long)match->data;\r\nret = of_platform_serial_setup(ofdev, port_type, &port);\r\nif (ret)\r\ngoto out;\r\nswitch (port_type) {\r\n#ifdef CONFIG_SERIAL_8250\r\ncase PORT_8250 ... PORT_MAX_8250:\r\nret = serial8250_register_port(&port);\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_SERIAL_OF_PLATFORM_NWPSERIAL\r\ncase PORT_NWPSERIAL:\r\nret = nwpserial_register_port(&port);\r\nbreak;\r\n#endif\r\ndefault:\r\ncase PORT_UNKNOWN:\r\ndev_info(&ofdev->dev, "Unknown serial port found, ignored\n");\r\nret = -ENODEV;\r\nbreak;\r\n}\r\nif (ret < 0)\r\ngoto out;\r\ninfo->type = port_type;\r\ninfo->line = ret;\r\ndev_set_drvdata(&ofdev->dev, info);\r\nreturn 0;\r\nout:\r\nkfree(info);\r\nirq_dispose_mapping(port.irq);\r\nreturn ret;\r\n}\r\nstatic int of_platform_serial_remove(struct platform_device *ofdev)\r\n{\r\nstruct of_serial_info *info = dev_get_drvdata(&ofdev->dev);\r\nswitch (info->type) {\r\n#ifdef CONFIG_SERIAL_8250\r\ncase PORT_8250 ... PORT_MAX_8250:\r\nserial8250_unregister_port(info->line);\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_SERIAL_OF_PLATFORM_NWPSERIAL\r\ncase PORT_NWPSERIAL:\r\nnwpserial_unregister_port(info->line);\r\nbreak;\r\n#endif\r\ndefault:\r\nbreak;\r\n}\r\nkfree(info);\r\nreturn 0;\r\n}
