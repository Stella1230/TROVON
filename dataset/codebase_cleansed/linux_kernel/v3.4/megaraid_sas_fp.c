u32 mega_mod64(u64 dividend, u32 divisor)\r\n{\r\nu64 d;\r\nu32 remainder;\r\nif (!divisor)\r\nprintk(KERN_ERR "megasas : DIVISOR is zero, in div fn\n");\r\nd = dividend;\r\nremainder = do_div(d, divisor);\r\nreturn remainder;\r\n}\r\nu64 mega_div64_32(uint64_t dividend, uint32_t divisor)\r\n{\r\nu32 remainder;\r\nu64 d;\r\nif (!divisor)\r\nprintk(KERN_ERR "megasas : DIVISOR is zero in mod fn\n");\r\nd = dividend;\r\nremainder = do_div(d, divisor);\r\nreturn d;\r\n}\r\nstruct MR_LD_RAID *MR_LdRaidGet(u32 ld, struct MR_FW_RAID_MAP_ALL *map)\r\n{\r\nreturn &map->raidMap.ldSpanMap[ld].ldRaid;\r\n}\r\nstatic struct MR_SPAN_BLOCK_INFO *MR_LdSpanInfoGet(u32 ld,\r\nstruct MR_FW_RAID_MAP_ALL\r\n*map)\r\n{\r\nreturn &map->raidMap.ldSpanMap[ld].spanBlock[0];\r\n}\r\nstatic u8 MR_LdDataArmGet(u32 ld, u32 armIdx, struct MR_FW_RAID_MAP_ALL *map)\r\n{\r\nreturn map->raidMap.ldSpanMap[ld].dataArmMap[armIdx];\r\n}\r\nstatic u16 MR_ArPdGet(u32 ar, u32 arm, struct MR_FW_RAID_MAP_ALL *map)\r\n{\r\nreturn map->raidMap.arMapInfo[ar].pd[arm];\r\n}\r\nstatic u16 MR_LdSpanArrayGet(u32 ld, u32 span, struct MR_FW_RAID_MAP_ALL *map)\r\n{\r\nreturn map->raidMap.ldSpanMap[ld].spanBlock[span].span.arrayRef;\r\n}\r\nstatic u16 MR_PdDevHandleGet(u32 pd, struct MR_FW_RAID_MAP_ALL *map)\r\n{\r\nreturn map->raidMap.devHndlInfo[pd].curDevHdl;\r\n}\r\nu16 MR_GetLDTgtId(u32 ld, struct MR_FW_RAID_MAP_ALL *map)\r\n{\r\nreturn map->raidMap.ldSpanMap[ld].ldRaid.targetId;\r\n}\r\nu16 MR_TargetIdToLdGet(u32 ldTgtId, struct MR_FW_RAID_MAP_ALL *map)\r\n{\r\nreturn map->raidMap.ldTgtIdToLd[ldTgtId];\r\n}\r\nstatic struct MR_LD_SPAN *MR_LdSpanPtrGet(u32 ld, u32 span,\r\nstruct MR_FW_RAID_MAP_ALL *map)\r\n{\r\nreturn &map->raidMap.ldSpanMap[ld].spanBlock[span].span;\r\n}\r\nu8 MR_ValidateMapInfo(struct MR_FW_RAID_MAP_ALL *map,\r\nstruct LD_LOAD_BALANCE_INFO *lbInfo)\r\n{\r\nstruct MR_FW_RAID_MAP *pFwRaidMap = &map->raidMap;\r\nif (pFwRaidMap->totalSize !=\r\n(sizeof(struct MR_FW_RAID_MAP) -sizeof(struct MR_LD_SPAN_MAP) +\r\n(sizeof(struct MR_LD_SPAN_MAP) *pFwRaidMap->ldCount))) {\r\nprintk(KERN_ERR "megasas: map info structure size 0x%x is not matching with ld count\n",\r\n(unsigned int)((sizeof(struct MR_FW_RAID_MAP) -\r\nsizeof(struct MR_LD_SPAN_MAP)) +\r\n(sizeof(struct MR_LD_SPAN_MAP) *\r\npFwRaidMap->ldCount)));\r\nprintk(KERN_ERR "megasas: span map %x, pFwRaidMap->totalSize "\r\n": %x\n", (unsigned int)sizeof(struct MR_LD_SPAN_MAP),\r\npFwRaidMap->totalSize);\r\nreturn 0;\r\n}\r\nmr_update_load_balance_params(map, lbInfo);\r\nreturn 1;\r\n}\r\nu32 MR_GetSpanBlock(u32 ld, u64 row, u64 *span_blk,\r\nstruct MR_FW_RAID_MAP_ALL *map, int *div_error)\r\n{\r\nstruct MR_SPAN_BLOCK_INFO *pSpanBlock = MR_LdSpanInfoGet(ld, map);\r\nstruct MR_QUAD_ELEMENT *quad;\r\nstruct MR_LD_RAID *raid = MR_LdRaidGet(ld, map);\r\nu32 span, j;\r\nfor (span = 0; span < raid->spanDepth; span++, pSpanBlock++) {\r\nfor (j = 0; j < pSpanBlock->block_span_info.noElements; j++) {\r\nquad = &pSpanBlock->block_span_info.quad[j];\r\nif (quad->diff == 0) {\r\n*div_error = 1;\r\nreturn span;\r\n}\r\nif (quad->logStart <= row && row <= quad->logEnd &&\r\n(mega_mod64(row-quad->logStart, quad->diff)) == 0) {\r\nif (span_blk != NULL) {\r\nu64 blk, debugBlk;\r\nblk =\r\nmega_div64_32(\r\n(row-quad->logStart),\r\nquad->diff);\r\ndebugBlk = blk;\r\nblk = (blk + quad->offsetInSpan) <<\r\nraid->stripeShift;\r\n*span_blk = blk;\r\n}\r\nreturn span;\r\n}\r\n}\r\n}\r\nreturn span;\r\n}\r\nu8 MR_GetPhyParams(struct megasas_instance *instance, u32 ld, u64 stripRow,\r\nu16 stripRef, u64 *pdBlock, u16 *pDevHandle,\r\nstruct RAID_CONTEXT *pRAID_Context,\r\nstruct MR_FW_RAID_MAP_ALL *map)\r\n{\r\nstruct MR_LD_RAID *raid = MR_LdRaidGet(ld, map);\r\nu32 pd, arRef;\r\nu8 physArm, span;\r\nu64 row;\r\nu8 retval = TRUE;\r\nint error_code = 0;\r\nrow = mega_div64_32(stripRow, raid->rowDataSize);\r\nif (raid->level == 6) {\r\nu32 logArm = mega_mod64(stripRow, raid->rowDataSize);\r\nu32 rowMod, armQ, arm;\r\nif (raid->rowSize == 0)\r\nreturn FALSE;\r\nrowMod = mega_mod64(row, raid->rowSize);\r\narmQ = raid->rowSize-1-rowMod;\r\narm = armQ+1+logArm;\r\nif (arm >= raid->rowSize)\r\narm -= raid->rowSize;\r\nphysArm = (u8)arm;\r\n} else {\r\nif (raid->modFactor == 0)\r\nreturn FALSE;\r\nphysArm = MR_LdDataArmGet(ld, mega_mod64(stripRow,\r\nraid->modFactor),\r\nmap);\r\n}\r\nif (raid->spanDepth == 1) {\r\nspan = 0;\r\n*pdBlock = row << raid->stripeShift;\r\n} else {\r\nspan = (u8)MR_GetSpanBlock(ld, row, pdBlock, map, &error_code);\r\nif (error_code == 1)\r\nreturn FALSE;\r\n}\r\narRef = MR_LdSpanArrayGet(ld, span, map);\r\npd = MR_ArPdGet(arRef, physArm, map);\r\nif (pd != MR_PD_INVALID)\r\n*pDevHandle = MR_PdDevHandleGet(pd, map);\r\nelse {\r\n*pDevHandle = MR_PD_INVALID;\r\nif ((raid->level >= 5) &&\r\n((instance->pdev->device != PCI_DEVICE_ID_LSI_INVADER) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER &&\r\nraid->regTypeReqOnRead != REGION_TYPE_UNUSED)))\r\npRAID_Context->regLockFlags = REGION_TYPE_EXCLUSIVE;\r\nelse if (raid->level == 1) {\r\npd = MR_ArPdGet(arRef, physArm + 1, map);\r\nif (pd != MR_PD_INVALID)\r\n*pDevHandle = MR_PdDevHandleGet(pd, map);\r\n}\r\n}\r\n*pdBlock += stripRef + MR_LdSpanPtrGet(ld, span, map)->startBlk;\r\npRAID_Context->spanArm = (span << RAID_CTX_SPANARM_SPAN_SHIFT) |\r\nphysArm;\r\nreturn retval;\r\n}\r\nu8\r\nMR_BuildRaidContext(struct megasas_instance *instance,\r\nstruct IO_REQUEST_INFO *io_info,\r\nstruct RAID_CONTEXT *pRAID_Context,\r\nstruct MR_FW_RAID_MAP_ALL *map)\r\n{\r\nstruct MR_LD_RAID *raid;\r\nu32 ld, stripSize, stripe_mask;\r\nu64 endLba, endStrip, endRow, start_row, start_strip;\r\nu64 regStart;\r\nu32 regSize;\r\nu8 num_strips, numRows;\r\nu16 ref_in_start_stripe, ref_in_end_stripe;\r\nu64 ldStartBlock;\r\nu32 numBlocks, ldTgtId;\r\nu8 isRead;\r\nu8 retval = 0;\r\nldStartBlock = io_info->ldStartBlock;\r\nnumBlocks = io_info->numBlocks;\r\nldTgtId = io_info->ldTgtId;\r\nisRead = io_info->isRead;\r\nld = MR_TargetIdToLdGet(ldTgtId, map);\r\nraid = MR_LdRaidGet(ld, map);\r\nstripSize = 1 << raid->stripeShift;\r\nstripe_mask = stripSize-1;\r\nstart_strip = ldStartBlock >> raid->stripeShift;\r\nref_in_start_stripe = (u16)(ldStartBlock & stripe_mask);\r\nendLba = ldStartBlock + numBlocks - 1;\r\nref_in_end_stripe = (u16)(endLba & stripe_mask);\r\nendStrip = endLba >> raid->stripeShift;\r\nnum_strips = (u8)(endStrip - start_strip + 1);\r\nif (raid->rowDataSize == 0)\r\nreturn FALSE;\r\nstart_row = mega_div64_32(start_strip, raid->rowDataSize);\r\nendRow = mega_div64_32(endStrip, raid->rowDataSize);\r\nnumRows = (u8)(endRow - start_row + 1);\r\nregStart = start_row << raid->stripeShift;\r\nregSize = stripSize;\r\nif (num_strips > 1 || (!isRead && raid->level != 0) ||\r\n!raid->capability.fpCapable) {\r\nio_info->fpOkForIo = FALSE;\r\n} else {\r\nio_info->fpOkForIo = TRUE;\r\n}\r\nif (numRows == 1) {\r\nif (num_strips == 1) {\r\nregStart += ref_in_start_stripe;\r\nregSize = numBlocks;\r\n}\r\n} else {\r\nif (start_strip == (start_row + 1) * raid->rowDataSize - 1) {\r\nregStart += ref_in_start_stripe;\r\nregSize = stripSize - ref_in_start_stripe;\r\n}\r\nif (numRows > 2)\r\nregSize += (numRows-2) << raid->stripeShift;\r\nif (endStrip == endRow*raid->rowDataSize)\r\nregSize += ref_in_end_stripe+1;\r\nelse\r\nregSize += stripSize;\r\n}\r\npRAID_Context->timeoutValue = map->raidMap.fpPdIoTimeoutSec;\r\nif (instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER)\r\npRAID_Context->regLockFlags = (isRead) ?\r\nraid->regTypeReqOnRead : raid->regTypeReqOnWrite;\r\nelse\r\npRAID_Context->regLockFlags = (isRead) ?\r\nREGION_TYPE_SHARED_READ : raid->regTypeReqOnWrite;\r\npRAID_Context->VirtualDiskTgtId = raid->targetId;\r\npRAID_Context->regLockRowLBA = regStart;\r\npRAID_Context->regLockLength = regSize;\r\npRAID_Context->configSeqNum = raid->seqNum;\r\nif (io_info->fpOkForIo) {\r\nretval = MR_GetPhyParams(instance, ld, start_strip,\r\nref_in_start_stripe,\r\n&io_info->pdBlock,\r\n&io_info->devHandle, pRAID_Context,\r\nmap);\r\nif (io_info->devHandle == MR_PD_INVALID)\r\nio_info->fpOkForIo = FALSE;\r\nreturn retval;\r\n} else if (isRead) {\r\nuint stripIdx;\r\nfor (stripIdx = 0; stripIdx < num_strips; stripIdx++) {\r\nif (!MR_GetPhyParams(instance, ld,\r\nstart_strip + stripIdx,\r\nref_in_start_stripe,\r\n&io_info->pdBlock,\r\n&io_info->devHandle,\r\npRAID_Context, map))\r\nreturn TRUE;\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nvoid\r\nmr_update_load_balance_params(struct MR_FW_RAID_MAP_ALL *map,\r\nstruct LD_LOAD_BALANCE_INFO *lbInfo)\r\n{\r\nint ldCount;\r\nu16 ld;\r\nstruct MR_LD_RAID *raid;\r\nfor (ldCount = 0; ldCount < MAX_LOGICAL_DRIVES; ldCount++) {\r\nld = MR_TargetIdToLdGet(ldCount, map);\r\nif (ld >= MAX_LOGICAL_DRIVES) {\r\nlbInfo[ldCount].loadBalanceFlag = 0;\r\ncontinue;\r\n}\r\nraid = MR_LdRaidGet(ld, map);\r\nif ((raid->level == 1) && (raid->rowSize == 2) &&\r\n(raid->spanDepth == 1) && raid->ldState ==\r\nMR_LD_STATE_OPTIMAL) {\r\nu32 pd, arRef;\r\nlbInfo[ldCount].loadBalanceFlag = 1;\r\narRef = MR_LdSpanArrayGet(ld, 0, map);\r\npd = MR_ArPdGet(arRef, 0, map);\r\nlbInfo[ldCount].raid1DevHandle[0] =\r\nMR_PdDevHandleGet(pd, map);\r\npd = MR_ArPdGet(arRef, 1, map);\r\nlbInfo[ldCount].raid1DevHandle[1] =\r\nMR_PdDevHandleGet(pd, map);\r\n} else\r\nlbInfo[ldCount].loadBalanceFlag = 0;\r\n}\r\n}\r\nu8 megasas_get_best_arm(struct LD_LOAD_BALANCE_INFO *lbInfo, u8 arm, u64 block,\r\nu32 count)\r\n{\r\nu16 pend0, pend1;\r\nu64 diff0, diff1;\r\nu8 bestArm;\r\npend0 = atomic_read(&lbInfo->scsi_pending_cmds[0]);\r\npend1 = atomic_read(&lbInfo->scsi_pending_cmds[1]);\r\ndiff0 = ABS_DIFF(block, lbInfo->last_accessed_block[0]);\r\ndiff1 = ABS_DIFF(block, lbInfo->last_accessed_block[1]);\r\nbestArm = (diff0 <= diff1 ? 0 : 1);\r\nif ((bestArm == arm && pend0 > pend1 + 16) ||\r\n(bestArm != arm && pend1 > pend0 + 16))\r\nbestArm ^= 1;\r\nlbInfo->last_accessed_block[bestArm] = block + count - 1;\r\nreturn bestArm;\r\n}\r\nu16 get_updated_dev_handle(struct LD_LOAD_BALANCE_INFO *lbInfo,\r\nstruct IO_REQUEST_INFO *io_info)\r\n{\r\nu8 arm, old_arm;\r\nu16 devHandle;\r\nold_arm = lbInfo->raid1DevHandle[0] == io_info->devHandle ? 0 : 1;\r\narm = megasas_get_best_arm(lbInfo, old_arm, io_info->ldStartBlock,\r\nio_info->numBlocks);\r\ndevHandle = lbInfo->raid1DevHandle[arm];\r\natomic_inc(&lbInfo->scsi_pending_cmds[arm]);\r\nreturn devHandle;\r\n}
