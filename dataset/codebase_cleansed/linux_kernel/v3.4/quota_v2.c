static inline qsize_t v2_stoqb(qsize_t space)\r\n{\r\nreturn (space + QUOTABLOCK_SIZE - 1) >> QUOTABLOCK_BITS;\r\n}\r\nstatic inline qsize_t v2_qbtos(qsize_t blocks)\r\n{\r\nreturn blocks << QUOTABLOCK_BITS;\r\n}\r\nstatic int v2_read_header(struct super_block *sb, int type,\r\nstruct v2_disk_dqheader *dqhead)\r\n{\r\nssize_t size;\r\nsize = sb->s_op->quota_read(sb, type, (char *)dqhead,\r\nsizeof(struct v2_disk_dqheader), 0);\r\nif (size != sizeof(struct v2_disk_dqheader)) {\r\nquota_error(sb, "Failed header read: expected=%zd got=%zd",\r\nsizeof(struct v2_disk_dqheader), size);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int v2_check_quota_file(struct super_block *sb, int type)\r\n{\r\nstruct v2_disk_dqheader dqhead;\r\nstatic const uint quota_magics[] = V2_INITQMAGICS;\r\nstatic const uint quota_versions[] = V2_INITQVERSIONS;\r\nif (!v2_read_header(sb, type, &dqhead))\r\nreturn 0;\r\nif (le32_to_cpu(dqhead.dqh_magic) != quota_magics[type] ||\r\nle32_to_cpu(dqhead.dqh_version) > quota_versions[type])\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int v2_read_file_info(struct super_block *sb, int type)\r\n{\r\nstruct v2_disk_dqinfo dinfo;\r\nstruct v2_disk_dqheader dqhead;\r\nstruct mem_dqinfo *info = sb_dqinfo(sb, type);\r\nstruct qtree_mem_dqinfo *qinfo;\r\nssize_t size;\r\nunsigned int version;\r\nif (!v2_read_header(sb, type, &dqhead))\r\nreturn -1;\r\nversion = le32_to_cpu(dqhead.dqh_version);\r\nif ((info->dqi_fmt_id == QFMT_VFS_V0 && version != 0) ||\r\n(info->dqi_fmt_id == QFMT_VFS_V1 && version != 1))\r\nreturn -1;\r\nsize = sb->s_op->quota_read(sb, type, (char *)&dinfo,\r\nsizeof(struct v2_disk_dqinfo), V2_DQINFOOFF);\r\nif (size != sizeof(struct v2_disk_dqinfo)) {\r\nquota_error(sb, "Can't read info structure");\r\nreturn -1;\r\n}\r\ninfo->dqi_priv = kmalloc(sizeof(struct qtree_mem_dqinfo), GFP_NOFS);\r\nif (!info->dqi_priv) {\r\nprintk(KERN_WARNING\r\n"Not enough memory for quota information structure.\n");\r\nreturn -ENOMEM;\r\n}\r\nqinfo = info->dqi_priv;\r\nif (version == 0) {\r\ninfo->dqi_maxblimit = 0xffffffff;\r\ninfo->dqi_maxilimit = 0xffffffff;\r\n} else {\r\ninfo->dqi_maxblimit = 0xffffffffffffffffULL;\r\ninfo->dqi_maxilimit = 0xffffffffffffffffULL;\r\n}\r\ninfo->dqi_bgrace = le32_to_cpu(dinfo.dqi_bgrace);\r\ninfo->dqi_igrace = le32_to_cpu(dinfo.dqi_igrace);\r\ninfo->dqi_flags = le32_to_cpu(dinfo.dqi_flags);\r\nqinfo->dqi_sb = sb;\r\nqinfo->dqi_type = type;\r\nqinfo->dqi_blocks = le32_to_cpu(dinfo.dqi_blocks);\r\nqinfo->dqi_free_blk = le32_to_cpu(dinfo.dqi_free_blk);\r\nqinfo->dqi_free_entry = le32_to_cpu(dinfo.dqi_free_entry);\r\nqinfo->dqi_blocksize_bits = V2_DQBLKSIZE_BITS;\r\nqinfo->dqi_usable_bs = 1 << V2_DQBLKSIZE_BITS;\r\nqinfo->dqi_qtree_depth = qtree_depth(qinfo);\r\nif (version == 0) {\r\nqinfo->dqi_entry_size = sizeof(struct v2r0_disk_dqblk);\r\nqinfo->dqi_ops = &v2r0_qtree_ops;\r\n} else {\r\nqinfo->dqi_entry_size = sizeof(struct v2r1_disk_dqblk);\r\nqinfo->dqi_ops = &v2r1_qtree_ops;\r\n}\r\nreturn 0;\r\n}\r\nstatic int v2_write_file_info(struct super_block *sb, int type)\r\n{\r\nstruct v2_disk_dqinfo dinfo;\r\nstruct mem_dqinfo *info = sb_dqinfo(sb, type);\r\nstruct qtree_mem_dqinfo *qinfo = info->dqi_priv;\r\nssize_t size;\r\nspin_lock(&dq_data_lock);\r\ninfo->dqi_flags &= ~DQF_INFO_DIRTY;\r\ndinfo.dqi_bgrace = cpu_to_le32(info->dqi_bgrace);\r\ndinfo.dqi_igrace = cpu_to_le32(info->dqi_igrace);\r\ndinfo.dqi_flags = cpu_to_le32(info->dqi_flags & DQF_MASK);\r\nspin_unlock(&dq_data_lock);\r\ndinfo.dqi_blocks = cpu_to_le32(qinfo->dqi_blocks);\r\ndinfo.dqi_free_blk = cpu_to_le32(qinfo->dqi_free_blk);\r\ndinfo.dqi_free_entry = cpu_to_le32(qinfo->dqi_free_entry);\r\nsize = sb->s_op->quota_write(sb, type, (char *)&dinfo,\r\nsizeof(struct v2_disk_dqinfo), V2_DQINFOOFF);\r\nif (size != sizeof(struct v2_disk_dqinfo)) {\r\nquota_error(sb, "Can't write info structure");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void v2r0_disk2memdqb(struct dquot *dquot, void *dp)\r\n{\r\nstruct v2r0_disk_dqblk *d = dp, empty;\r\nstruct mem_dqblk *m = &dquot->dq_dqb;\r\nm->dqb_ihardlimit = le32_to_cpu(d->dqb_ihardlimit);\r\nm->dqb_isoftlimit = le32_to_cpu(d->dqb_isoftlimit);\r\nm->dqb_curinodes = le32_to_cpu(d->dqb_curinodes);\r\nm->dqb_itime = le64_to_cpu(d->dqb_itime);\r\nm->dqb_bhardlimit = v2_qbtos(le32_to_cpu(d->dqb_bhardlimit));\r\nm->dqb_bsoftlimit = v2_qbtos(le32_to_cpu(d->dqb_bsoftlimit));\r\nm->dqb_curspace = le64_to_cpu(d->dqb_curspace);\r\nm->dqb_btime = le64_to_cpu(d->dqb_btime);\r\nmemset(&empty, 0, sizeof(struct v2r0_disk_dqblk));\r\nempty.dqb_itime = cpu_to_le64(1);\r\nif (!memcmp(&empty, dp, sizeof(struct v2r0_disk_dqblk)))\r\nm->dqb_itime = 0;\r\n}\r\nstatic void v2r0_mem2diskdqb(void *dp, struct dquot *dquot)\r\n{\r\nstruct v2r0_disk_dqblk *d = dp;\r\nstruct mem_dqblk *m = &dquot->dq_dqb;\r\nstruct qtree_mem_dqinfo *info =\r\nsb_dqinfo(dquot->dq_sb, dquot->dq_type)->dqi_priv;\r\nd->dqb_ihardlimit = cpu_to_le32(m->dqb_ihardlimit);\r\nd->dqb_isoftlimit = cpu_to_le32(m->dqb_isoftlimit);\r\nd->dqb_curinodes = cpu_to_le32(m->dqb_curinodes);\r\nd->dqb_itime = cpu_to_le64(m->dqb_itime);\r\nd->dqb_bhardlimit = cpu_to_le32(v2_stoqb(m->dqb_bhardlimit));\r\nd->dqb_bsoftlimit = cpu_to_le32(v2_stoqb(m->dqb_bsoftlimit));\r\nd->dqb_curspace = cpu_to_le64(m->dqb_curspace);\r\nd->dqb_btime = cpu_to_le64(m->dqb_btime);\r\nd->dqb_id = cpu_to_le32(dquot->dq_id);\r\nif (qtree_entry_unused(info, dp))\r\nd->dqb_itime = cpu_to_le64(1);\r\n}\r\nstatic int v2r0_is_id(void *dp, struct dquot *dquot)\r\n{\r\nstruct v2r0_disk_dqblk *d = dp;\r\nstruct qtree_mem_dqinfo *info =\r\nsb_dqinfo(dquot->dq_sb, dquot->dq_type)->dqi_priv;\r\nif (qtree_entry_unused(info, dp))\r\nreturn 0;\r\nreturn le32_to_cpu(d->dqb_id) == dquot->dq_id;\r\n}\r\nstatic void v2r1_disk2memdqb(struct dquot *dquot, void *dp)\r\n{\r\nstruct v2r1_disk_dqblk *d = dp, empty;\r\nstruct mem_dqblk *m = &dquot->dq_dqb;\r\nm->dqb_ihardlimit = le64_to_cpu(d->dqb_ihardlimit);\r\nm->dqb_isoftlimit = le64_to_cpu(d->dqb_isoftlimit);\r\nm->dqb_curinodes = le64_to_cpu(d->dqb_curinodes);\r\nm->dqb_itime = le64_to_cpu(d->dqb_itime);\r\nm->dqb_bhardlimit = v2_qbtos(le64_to_cpu(d->dqb_bhardlimit));\r\nm->dqb_bsoftlimit = v2_qbtos(le64_to_cpu(d->dqb_bsoftlimit));\r\nm->dqb_curspace = le64_to_cpu(d->dqb_curspace);\r\nm->dqb_btime = le64_to_cpu(d->dqb_btime);\r\nmemset(&empty, 0, sizeof(struct v2r1_disk_dqblk));\r\nempty.dqb_itime = cpu_to_le64(1);\r\nif (!memcmp(&empty, dp, sizeof(struct v2r1_disk_dqblk)))\r\nm->dqb_itime = 0;\r\n}\r\nstatic void v2r1_mem2diskdqb(void *dp, struct dquot *dquot)\r\n{\r\nstruct v2r1_disk_dqblk *d = dp;\r\nstruct mem_dqblk *m = &dquot->dq_dqb;\r\nstruct qtree_mem_dqinfo *info =\r\nsb_dqinfo(dquot->dq_sb, dquot->dq_type)->dqi_priv;\r\nd->dqb_ihardlimit = cpu_to_le64(m->dqb_ihardlimit);\r\nd->dqb_isoftlimit = cpu_to_le64(m->dqb_isoftlimit);\r\nd->dqb_curinodes = cpu_to_le64(m->dqb_curinodes);\r\nd->dqb_itime = cpu_to_le64(m->dqb_itime);\r\nd->dqb_bhardlimit = cpu_to_le64(v2_stoqb(m->dqb_bhardlimit));\r\nd->dqb_bsoftlimit = cpu_to_le64(v2_stoqb(m->dqb_bsoftlimit));\r\nd->dqb_curspace = cpu_to_le64(m->dqb_curspace);\r\nd->dqb_btime = cpu_to_le64(m->dqb_btime);\r\nd->dqb_id = cpu_to_le32(dquot->dq_id);\r\nif (qtree_entry_unused(info, dp))\r\nd->dqb_itime = cpu_to_le64(1);\r\n}\r\nstatic int v2r1_is_id(void *dp, struct dquot *dquot)\r\n{\r\nstruct v2r1_disk_dqblk *d = dp;\r\nstruct qtree_mem_dqinfo *info =\r\nsb_dqinfo(dquot->dq_sb, dquot->dq_type)->dqi_priv;\r\nif (qtree_entry_unused(info, dp))\r\nreturn 0;\r\nreturn le32_to_cpu(d->dqb_id) == dquot->dq_id;\r\n}\r\nstatic int v2_read_dquot(struct dquot *dquot)\r\n{\r\nreturn qtree_read_dquot(sb_dqinfo(dquot->dq_sb, dquot->dq_type)->dqi_priv, dquot);\r\n}\r\nstatic int v2_write_dquot(struct dquot *dquot)\r\n{\r\nreturn qtree_write_dquot(sb_dqinfo(dquot->dq_sb, dquot->dq_type)->dqi_priv, dquot);\r\n}\r\nstatic int v2_release_dquot(struct dquot *dquot)\r\n{\r\nreturn qtree_release_dquot(sb_dqinfo(dquot->dq_sb, dquot->dq_type)->dqi_priv, dquot);\r\n}\r\nstatic int v2_free_file_info(struct super_block *sb, int type)\r\n{\r\nkfree(sb_dqinfo(sb, type)->dqi_priv);\r\nreturn 0;\r\n}\r\nstatic int __init init_v2_quota_format(void)\r\n{\r\nint ret;\r\nret = register_quota_format(&v2r0_quota_format);\r\nif (ret)\r\nreturn ret;\r\nreturn register_quota_format(&v2r1_quota_format);\r\n}\r\nstatic void __exit exit_v2_quota_format(void)\r\n{\r\nunregister_quota_format(&v2r0_quota_format);\r\nunregister_quota_format(&v2r1_quota_format);\r\n}
