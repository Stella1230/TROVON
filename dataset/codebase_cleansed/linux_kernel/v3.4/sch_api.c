int register_qdisc(struct Qdisc_ops *qops)\r\n{\r\nstruct Qdisc_ops *q, **qp;\r\nint rc = -EEXIST;\r\nwrite_lock(&qdisc_mod_lock);\r\nfor (qp = &qdisc_base; (q = *qp) != NULL; qp = &q->next)\r\nif (!strcmp(qops->id, q->id))\r\ngoto out;\r\nif (qops->enqueue == NULL)\r\nqops->enqueue = noop_qdisc_ops.enqueue;\r\nif (qops->peek == NULL) {\r\nif (qops->dequeue == NULL)\r\nqops->peek = noop_qdisc_ops.peek;\r\nelse\r\ngoto out_einval;\r\n}\r\nif (qops->dequeue == NULL)\r\nqops->dequeue = noop_qdisc_ops.dequeue;\r\nif (qops->cl_ops) {\r\nconst struct Qdisc_class_ops *cops = qops->cl_ops;\r\nif (!(cops->get && cops->put && cops->walk && cops->leaf))\r\ngoto out_einval;\r\nif (cops->tcf_chain && !(cops->bind_tcf && cops->unbind_tcf))\r\ngoto out_einval;\r\n}\r\nqops->next = NULL;\r\n*qp = qops;\r\nrc = 0;\r\nout:\r\nwrite_unlock(&qdisc_mod_lock);\r\nreturn rc;\r\nout_einval:\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nint unregister_qdisc(struct Qdisc_ops *qops)\r\n{\r\nstruct Qdisc_ops *q, **qp;\r\nint err = -ENOENT;\r\nwrite_lock(&qdisc_mod_lock);\r\nfor (qp = &qdisc_base; (q = *qp) != NULL; qp = &q->next)\r\nif (q == qops)\r\nbreak;\r\nif (q) {\r\n*qp = q->next;\r\nq->next = NULL;\r\nerr = 0;\r\n}\r\nwrite_unlock(&qdisc_mod_lock);\r\nreturn err;\r\n}\r\nstatic struct Qdisc *qdisc_match_from_root(struct Qdisc *root, u32 handle)\r\n{\r\nstruct Qdisc *q;\r\nif (!(root->flags & TCQ_F_BUILTIN) &&\r\nroot->handle == handle)\r\nreturn root;\r\nlist_for_each_entry(q, &root->list, list) {\r\nif (q->handle == handle)\r\nreturn q;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void qdisc_list_add(struct Qdisc *q)\r\n{\r\nif ((q->parent != TC_H_ROOT) && !(q->flags & TCQ_F_INGRESS))\r\nlist_add_tail(&q->list, &qdisc_dev(q)->qdisc->list);\r\n}\r\nvoid qdisc_list_del(struct Qdisc *q)\r\n{\r\nif ((q->parent != TC_H_ROOT) && !(q->flags & TCQ_F_INGRESS))\r\nlist_del(&q->list);\r\n}\r\nstruct Qdisc *qdisc_lookup(struct net_device *dev, u32 handle)\r\n{\r\nstruct Qdisc *q;\r\nq = qdisc_match_from_root(dev->qdisc, handle);\r\nif (q)\r\ngoto out;\r\nif (dev_ingress_queue(dev))\r\nq = qdisc_match_from_root(\r\ndev_ingress_queue(dev)->qdisc_sleeping,\r\nhandle);\r\nout:\r\nreturn q;\r\n}\r\nstatic struct Qdisc *qdisc_leaf(struct Qdisc *p, u32 classid)\r\n{\r\nunsigned long cl;\r\nstruct Qdisc *leaf;\r\nconst struct Qdisc_class_ops *cops = p->ops->cl_ops;\r\nif (cops == NULL)\r\nreturn NULL;\r\ncl = cops->get(p, classid);\r\nif (cl == 0)\r\nreturn NULL;\r\nleaf = cops->leaf(p, cl);\r\ncops->put(p, cl);\r\nreturn leaf;\r\n}\r\nstatic struct Qdisc_ops *qdisc_lookup_ops(struct nlattr *kind)\r\n{\r\nstruct Qdisc_ops *q = NULL;\r\nif (kind) {\r\nread_lock(&qdisc_mod_lock);\r\nfor (q = qdisc_base; q; q = q->next) {\r\nif (nla_strcmp(kind, q->id) == 0) {\r\nif (!try_module_get(q->owner))\r\nq = NULL;\r\nbreak;\r\n}\r\n}\r\nread_unlock(&qdisc_mod_lock);\r\n}\r\nreturn q;\r\n}\r\nstruct qdisc_rate_table *qdisc_get_rtab(struct tc_ratespec *r, struct nlattr *tab)\r\n{\r\nstruct qdisc_rate_table *rtab;\r\nfor (rtab = qdisc_rtab_list; rtab; rtab = rtab->next) {\r\nif (memcmp(&rtab->rate, r, sizeof(struct tc_ratespec)) == 0) {\r\nrtab->refcnt++;\r\nreturn rtab;\r\n}\r\n}\r\nif (tab == NULL || r->rate == 0 || r->cell_log == 0 ||\r\nnla_len(tab) != TC_RTAB_SIZE)\r\nreturn NULL;\r\nrtab = kmalloc(sizeof(*rtab), GFP_KERNEL);\r\nif (rtab) {\r\nrtab->rate = *r;\r\nrtab->refcnt = 1;\r\nmemcpy(rtab->data, nla_data(tab), 1024);\r\nrtab->next = qdisc_rtab_list;\r\nqdisc_rtab_list = rtab;\r\n}\r\nreturn rtab;\r\n}\r\nvoid qdisc_put_rtab(struct qdisc_rate_table *tab)\r\n{\r\nstruct qdisc_rate_table *rtab, **rtabp;\r\nif (!tab || --tab->refcnt)\r\nreturn;\r\nfor (rtabp = &qdisc_rtab_list;\r\n(rtab = *rtabp) != NULL;\r\nrtabp = &rtab->next) {\r\nif (rtab == tab) {\r\n*rtabp = rtab->next;\r\nkfree(rtab);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic struct qdisc_size_table *qdisc_get_stab(struct nlattr *opt)\r\n{\r\nstruct nlattr *tb[TCA_STAB_MAX + 1];\r\nstruct qdisc_size_table *stab;\r\nstruct tc_sizespec *s;\r\nunsigned int tsize = 0;\r\nu16 *tab = NULL;\r\nint err;\r\nerr = nla_parse_nested(tb, TCA_STAB_MAX, opt, stab_policy);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\nif (!tb[TCA_STAB_BASE])\r\nreturn ERR_PTR(-EINVAL);\r\ns = nla_data(tb[TCA_STAB_BASE]);\r\nif (s->tsize > 0) {\r\nif (!tb[TCA_STAB_DATA])\r\nreturn ERR_PTR(-EINVAL);\r\ntab = nla_data(tb[TCA_STAB_DATA]);\r\ntsize = nla_len(tb[TCA_STAB_DATA]) / sizeof(u16);\r\n}\r\nif (tsize != s->tsize || (!tab && tsize > 0))\r\nreturn ERR_PTR(-EINVAL);\r\nspin_lock(&qdisc_stab_lock);\r\nlist_for_each_entry(stab, &qdisc_stab_list, list) {\r\nif (memcmp(&stab->szopts, s, sizeof(*s)))\r\ncontinue;\r\nif (tsize > 0 && memcmp(stab->data, tab, tsize * sizeof(u16)))\r\ncontinue;\r\nstab->refcnt++;\r\nspin_unlock(&qdisc_stab_lock);\r\nreturn stab;\r\n}\r\nspin_unlock(&qdisc_stab_lock);\r\nstab = kmalloc(sizeof(*stab) + tsize * sizeof(u16), GFP_KERNEL);\r\nif (!stab)\r\nreturn ERR_PTR(-ENOMEM);\r\nstab->refcnt = 1;\r\nstab->szopts = *s;\r\nif (tsize > 0)\r\nmemcpy(stab->data, tab, tsize * sizeof(u16));\r\nspin_lock(&qdisc_stab_lock);\r\nlist_add_tail(&stab->list, &qdisc_stab_list);\r\nspin_unlock(&qdisc_stab_lock);\r\nreturn stab;\r\n}\r\nstatic void stab_kfree_rcu(struct rcu_head *head)\r\n{\r\nkfree(container_of(head, struct qdisc_size_table, rcu));\r\n}\r\nvoid qdisc_put_stab(struct qdisc_size_table *tab)\r\n{\r\nif (!tab)\r\nreturn;\r\nspin_lock(&qdisc_stab_lock);\r\nif (--tab->refcnt == 0) {\r\nlist_del(&tab->list);\r\ncall_rcu_bh(&tab->rcu, stab_kfree_rcu);\r\n}\r\nspin_unlock(&qdisc_stab_lock);\r\n}\r\nstatic int qdisc_dump_stab(struct sk_buff *skb, struct qdisc_size_table *stab)\r\n{\r\nstruct nlattr *nest;\r\nnest = nla_nest_start(skb, TCA_STAB);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nNLA_PUT(skb, TCA_STAB_BASE, sizeof(stab->szopts), &stab->szopts);\r\nnla_nest_end(skb, nest);\r\nreturn skb->len;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nvoid __qdisc_calculate_pkt_len(struct sk_buff *skb, const struct qdisc_size_table *stab)\r\n{\r\nint pkt_len, slot;\r\npkt_len = skb->len + stab->szopts.overhead;\r\nif (unlikely(!stab->szopts.tsize))\r\ngoto out;\r\nslot = pkt_len + stab->szopts.cell_align;\r\nif (unlikely(slot < 0))\r\nslot = 0;\r\nslot >>= stab->szopts.cell_log;\r\nif (likely(slot < stab->szopts.tsize))\r\npkt_len = stab->data[slot];\r\nelse\r\npkt_len = stab->data[stab->szopts.tsize - 1] *\r\n(slot / stab->szopts.tsize) +\r\nstab->data[slot % stab->szopts.tsize];\r\npkt_len <<= stab->szopts.size_log;\r\nout:\r\nif (unlikely(pkt_len < 1))\r\npkt_len = 1;\r\nqdisc_skb_cb(skb)->pkt_len = pkt_len;\r\n}\r\nvoid qdisc_warn_nonwc(char *txt, struct Qdisc *qdisc)\r\n{\r\nif (!(qdisc->flags & TCQ_F_WARN_NONWC)) {\r\npr_warn("%s: %s qdisc %X: is non-work-conserving?\n",\r\ntxt, qdisc->ops->id, qdisc->handle >> 16);\r\nqdisc->flags |= TCQ_F_WARN_NONWC;\r\n}\r\n}\r\nstatic enum hrtimer_restart qdisc_watchdog(struct hrtimer *timer)\r\n{\r\nstruct qdisc_watchdog *wd = container_of(timer, struct qdisc_watchdog,\r\ntimer);\r\nqdisc_unthrottled(wd->qdisc);\r\n__netif_schedule(qdisc_root(wd->qdisc));\r\nreturn HRTIMER_NORESTART;\r\n}\r\nvoid qdisc_watchdog_init(struct qdisc_watchdog *wd, struct Qdisc *qdisc)\r\n{\r\nhrtimer_init(&wd->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\r\nwd->timer.function = qdisc_watchdog;\r\nwd->qdisc = qdisc;\r\n}\r\nvoid qdisc_watchdog_schedule(struct qdisc_watchdog *wd, psched_time_t expires)\r\n{\r\nktime_t time;\r\nif (test_bit(__QDISC_STATE_DEACTIVATED,\r\n&qdisc_root_sleeping(wd->qdisc)->state))\r\nreturn;\r\nqdisc_throttled(wd->qdisc);\r\ntime = ktime_set(0, 0);\r\ntime = ktime_add_ns(time, PSCHED_TICKS2NS(expires));\r\nhrtimer_start(&wd->timer, time, HRTIMER_MODE_ABS);\r\n}\r\nvoid qdisc_watchdog_cancel(struct qdisc_watchdog *wd)\r\n{\r\nhrtimer_cancel(&wd->timer);\r\nqdisc_unthrottled(wd->qdisc);\r\n}\r\nstatic struct hlist_head *qdisc_class_hash_alloc(unsigned int n)\r\n{\r\nunsigned int size = n * sizeof(struct hlist_head), i;\r\nstruct hlist_head *h;\r\nif (size <= PAGE_SIZE)\r\nh = kmalloc(size, GFP_KERNEL);\r\nelse\r\nh = (struct hlist_head *)\r\n__get_free_pages(GFP_KERNEL, get_order(size));\r\nif (h != NULL) {\r\nfor (i = 0; i < n; i++)\r\nINIT_HLIST_HEAD(&h[i]);\r\n}\r\nreturn h;\r\n}\r\nstatic void qdisc_class_hash_free(struct hlist_head *h, unsigned int n)\r\n{\r\nunsigned int size = n * sizeof(struct hlist_head);\r\nif (size <= PAGE_SIZE)\r\nkfree(h);\r\nelse\r\nfree_pages((unsigned long)h, get_order(size));\r\n}\r\nvoid qdisc_class_hash_grow(struct Qdisc *sch, struct Qdisc_class_hash *clhash)\r\n{\r\nstruct Qdisc_class_common *cl;\r\nstruct hlist_node *n, *next;\r\nstruct hlist_head *nhash, *ohash;\r\nunsigned int nsize, nmask, osize;\r\nunsigned int i, h;\r\nif (clhash->hashelems * 4 <= clhash->hashsize * 3)\r\nreturn;\r\nnsize = clhash->hashsize * 2;\r\nnmask = nsize - 1;\r\nnhash = qdisc_class_hash_alloc(nsize);\r\nif (nhash == NULL)\r\nreturn;\r\nohash = clhash->hash;\r\nosize = clhash->hashsize;\r\nsch_tree_lock(sch);\r\nfor (i = 0; i < osize; i++) {\r\nhlist_for_each_entry_safe(cl, n, next, &ohash[i], hnode) {\r\nh = qdisc_class_hash(cl->classid, nmask);\r\nhlist_add_head(&cl->hnode, &nhash[h]);\r\n}\r\n}\r\nclhash->hash = nhash;\r\nclhash->hashsize = nsize;\r\nclhash->hashmask = nmask;\r\nsch_tree_unlock(sch);\r\nqdisc_class_hash_free(ohash, osize);\r\n}\r\nint qdisc_class_hash_init(struct Qdisc_class_hash *clhash)\r\n{\r\nunsigned int size = 4;\r\nclhash->hash = qdisc_class_hash_alloc(size);\r\nif (clhash->hash == NULL)\r\nreturn -ENOMEM;\r\nclhash->hashsize = size;\r\nclhash->hashmask = size - 1;\r\nclhash->hashelems = 0;\r\nreturn 0;\r\n}\r\nvoid qdisc_class_hash_destroy(struct Qdisc_class_hash *clhash)\r\n{\r\nqdisc_class_hash_free(clhash->hash, clhash->hashsize);\r\n}\r\nvoid qdisc_class_hash_insert(struct Qdisc_class_hash *clhash,\r\nstruct Qdisc_class_common *cl)\r\n{\r\nunsigned int h;\r\nINIT_HLIST_NODE(&cl->hnode);\r\nh = qdisc_class_hash(cl->classid, clhash->hashmask);\r\nhlist_add_head(&cl->hnode, &clhash->hash[h]);\r\nclhash->hashelems++;\r\n}\r\nvoid qdisc_class_hash_remove(struct Qdisc_class_hash *clhash,\r\nstruct Qdisc_class_common *cl)\r\n{\r\nhlist_del(&cl->hnode);\r\nclhash->hashelems--;\r\n}\r\nstatic u32 qdisc_alloc_handle(struct net_device *dev)\r\n{\r\nint i = 0x8000;\r\nstatic u32 autohandle = TC_H_MAKE(0x80000000U, 0);\r\ndo {\r\nautohandle += TC_H_MAKE(0x10000U, 0);\r\nif (autohandle == TC_H_MAKE(TC_H_ROOT, 0))\r\nautohandle = TC_H_MAKE(0x80000000U, 0);\r\nif (!qdisc_lookup(dev, autohandle))\r\nreturn autohandle;\r\ncond_resched();\r\n} while (--i > 0);\r\nreturn 0;\r\n}\r\nvoid qdisc_tree_decrease_qlen(struct Qdisc *sch, unsigned int n)\r\n{\r\nconst struct Qdisc_class_ops *cops;\r\nunsigned long cl;\r\nu32 parentid;\r\nif (n == 0)\r\nreturn;\r\nwhile ((parentid = sch->parent)) {\r\nif (TC_H_MAJ(parentid) == TC_H_MAJ(TC_H_INGRESS))\r\nreturn;\r\nsch = qdisc_lookup(qdisc_dev(sch), TC_H_MAJ(parentid));\r\nif (sch == NULL) {\r\nWARN_ON(parentid != TC_H_ROOT);\r\nreturn;\r\n}\r\ncops = sch->ops->cl_ops;\r\nif (cops->qlen_notify) {\r\ncl = cops->get(sch, parentid);\r\ncops->qlen_notify(sch, cl);\r\ncops->put(sch, cl);\r\n}\r\nsch->q.qlen -= n;\r\n}\r\n}\r\nstatic void notify_and_destroy(struct net *net, struct sk_buff *skb,\r\nstruct nlmsghdr *n, u32 clid,\r\nstruct Qdisc *old, struct Qdisc *new)\r\n{\r\nif (new || old)\r\nqdisc_notify(net, skb, n, clid, old, new);\r\nif (old)\r\nqdisc_destroy(old);\r\n}\r\nstatic int qdisc_graft(struct net_device *dev, struct Qdisc *parent,\r\nstruct sk_buff *skb, struct nlmsghdr *n, u32 classid,\r\nstruct Qdisc *new, struct Qdisc *old)\r\n{\r\nstruct Qdisc *q = old;\r\nstruct net *net = dev_net(dev);\r\nint err = 0;\r\nif (parent == NULL) {\r\nunsigned int i, num_q, ingress;\r\ningress = 0;\r\nnum_q = dev->num_tx_queues;\r\nif ((q && q->flags & TCQ_F_INGRESS) ||\r\n(new && new->flags & TCQ_F_INGRESS)) {\r\nnum_q = 1;\r\ningress = 1;\r\nif (!dev_ingress_queue(dev))\r\nreturn -ENOENT;\r\n}\r\nif (dev->flags & IFF_UP)\r\ndev_deactivate(dev);\r\nif (new && new->ops->attach) {\r\nnew->ops->attach(new);\r\nnum_q = 0;\r\n}\r\nfor (i = 0; i < num_q; i++) {\r\nstruct netdev_queue *dev_queue = dev_ingress_queue(dev);\r\nif (!ingress)\r\ndev_queue = netdev_get_tx_queue(dev, i);\r\nold = dev_graft_qdisc(dev_queue, new);\r\nif (new && i > 0)\r\natomic_inc(&new->refcnt);\r\nif (!ingress)\r\nqdisc_destroy(old);\r\n}\r\nif (!ingress) {\r\nnotify_and_destroy(net, skb, n, classid,\r\ndev->qdisc, new);\r\nif (new && !new->ops->attach)\r\natomic_inc(&new->refcnt);\r\ndev->qdisc = new ? : &noop_qdisc;\r\n} else {\r\nnotify_and_destroy(net, skb, n, classid, old, new);\r\n}\r\nif (dev->flags & IFF_UP)\r\ndev_activate(dev);\r\n} else {\r\nconst struct Qdisc_class_ops *cops = parent->ops->cl_ops;\r\nerr = -EOPNOTSUPP;\r\nif (cops && cops->graft) {\r\nunsigned long cl = cops->get(parent, classid);\r\nif (cl) {\r\nerr = cops->graft(parent, cl, new, &old);\r\ncops->put(parent, cl);\r\n} else\r\nerr = -ENOENT;\r\n}\r\nif (!err)\r\nnotify_and_destroy(net, skb, n, classid, old, new);\r\n}\r\nreturn err;\r\n}\r\nstatic struct Qdisc *\r\nqdisc_create(struct net_device *dev, struct netdev_queue *dev_queue,\r\nstruct Qdisc *p, u32 parent, u32 handle,\r\nstruct nlattr **tca, int *errp)\r\n{\r\nint err;\r\nstruct nlattr *kind = tca[TCA_KIND];\r\nstruct Qdisc *sch;\r\nstruct Qdisc_ops *ops;\r\nstruct qdisc_size_table *stab;\r\nops = qdisc_lookup_ops(kind);\r\n#ifdef CONFIG_MODULES\r\nif (ops == NULL && kind != NULL) {\r\nchar name[IFNAMSIZ];\r\nif (nla_strlcpy(name, kind, IFNAMSIZ) < IFNAMSIZ) {\r\nrtnl_unlock();\r\nrequest_module("sch_%s", name);\r\nrtnl_lock();\r\nops = qdisc_lookup_ops(kind);\r\nif (ops != NULL) {\r\nmodule_put(ops->owner);\r\nerr = -EAGAIN;\r\ngoto err_out;\r\n}\r\n}\r\n}\r\n#endif\r\nerr = -ENOENT;\r\nif (ops == NULL)\r\ngoto err_out;\r\nsch = qdisc_alloc(dev_queue, ops);\r\nif (IS_ERR(sch)) {\r\nerr = PTR_ERR(sch);\r\ngoto err_out2;\r\n}\r\nsch->parent = parent;\r\nif (handle == TC_H_INGRESS) {\r\nsch->flags |= TCQ_F_INGRESS;\r\nhandle = TC_H_MAKE(TC_H_INGRESS, 0);\r\nlockdep_set_class(qdisc_lock(sch), &qdisc_rx_lock);\r\n} else {\r\nif (handle == 0) {\r\nhandle = qdisc_alloc_handle(dev);\r\nerr = -ENOMEM;\r\nif (handle == 0)\r\ngoto err_out3;\r\n}\r\nlockdep_set_class(qdisc_lock(sch), &qdisc_tx_lock);\r\n}\r\nsch->handle = handle;\r\nif (!ops->init || (err = ops->init(sch, tca[TCA_OPTIONS])) == 0) {\r\nif (tca[TCA_STAB]) {\r\nstab = qdisc_get_stab(tca[TCA_STAB]);\r\nif (IS_ERR(stab)) {\r\nerr = PTR_ERR(stab);\r\ngoto err_out4;\r\n}\r\nrcu_assign_pointer(sch->stab, stab);\r\n}\r\nif (tca[TCA_RATE]) {\r\nspinlock_t *root_lock;\r\nerr = -EOPNOTSUPP;\r\nif (sch->flags & TCQ_F_MQROOT)\r\ngoto err_out4;\r\nif ((sch->parent != TC_H_ROOT) &&\r\n!(sch->flags & TCQ_F_INGRESS) &&\r\n(!p || !(p->flags & TCQ_F_MQROOT)))\r\nroot_lock = qdisc_root_sleeping_lock(sch);\r\nelse\r\nroot_lock = qdisc_lock(sch);\r\nerr = gen_new_estimator(&sch->bstats, &sch->rate_est,\r\nroot_lock, tca[TCA_RATE]);\r\nif (err)\r\ngoto err_out4;\r\n}\r\nqdisc_list_add(sch);\r\nreturn sch;\r\n}\r\nerr_out3:\r\ndev_put(dev);\r\nkfree((char *) sch - sch->padded);\r\nerr_out2:\r\nmodule_put(ops->owner);\r\nerr_out:\r\n*errp = err;\r\nreturn NULL;\r\nerr_out4:\r\nqdisc_put_stab(rtnl_dereference(sch->stab));\r\nif (ops->destroy)\r\nops->destroy(sch);\r\ngoto err_out3;\r\n}\r\nstatic int qdisc_change(struct Qdisc *sch, struct nlattr **tca)\r\n{\r\nstruct qdisc_size_table *ostab, *stab = NULL;\r\nint err = 0;\r\nif (tca[TCA_OPTIONS]) {\r\nif (sch->ops->change == NULL)\r\nreturn -EINVAL;\r\nerr = sch->ops->change(sch, tca[TCA_OPTIONS]);\r\nif (err)\r\nreturn err;\r\n}\r\nif (tca[TCA_STAB]) {\r\nstab = qdisc_get_stab(tca[TCA_STAB]);\r\nif (IS_ERR(stab))\r\nreturn PTR_ERR(stab);\r\n}\r\nostab = rtnl_dereference(sch->stab);\r\nrcu_assign_pointer(sch->stab, stab);\r\nqdisc_put_stab(ostab);\r\nif (tca[TCA_RATE]) {\r\nif (sch->flags & TCQ_F_MQROOT)\r\ngoto out;\r\ngen_replace_estimator(&sch->bstats, &sch->rate_est,\r\nqdisc_root_sleeping_lock(sch),\r\ntca[TCA_RATE]);\r\n}\r\nout:\r\nreturn 0;\r\n}\r\nstatic int check_loop(struct Qdisc *q, struct Qdisc *p, int depth)\r\n{\r\nstruct check_loop_arg arg;\r\nif (q->ops->cl_ops == NULL)\r\nreturn 0;\r\narg.w.stop = arg.w.skip = arg.w.count = 0;\r\narg.w.fn = check_loop_fn;\r\narg.depth = depth;\r\narg.p = p;\r\nq->ops->cl_ops->walk(q, &arg.w);\r\nreturn arg.w.stop ? -ELOOP : 0;\r\n}\r\nstatic int\r\ncheck_loop_fn(struct Qdisc *q, unsigned long cl, struct qdisc_walker *w)\r\n{\r\nstruct Qdisc *leaf;\r\nconst struct Qdisc_class_ops *cops = q->ops->cl_ops;\r\nstruct check_loop_arg *arg = (struct check_loop_arg *)w;\r\nleaf = cops->leaf(q, cl);\r\nif (leaf) {\r\nif (leaf == arg->p || arg->depth > 7)\r\nreturn -ELOOP;\r\nreturn check_loop(leaf, arg->p, arg->depth + 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tc_get_qdisc(struct sk_buff *skb, struct nlmsghdr *n, void *arg)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct tcmsg *tcm = NLMSG_DATA(n);\r\nstruct nlattr *tca[TCA_MAX + 1];\r\nstruct net_device *dev;\r\nu32 clid = tcm->tcm_parent;\r\nstruct Qdisc *q = NULL;\r\nstruct Qdisc *p = NULL;\r\nint err;\r\ndev = __dev_get_by_index(net, tcm->tcm_ifindex);\r\nif (!dev)\r\nreturn -ENODEV;\r\nerr = nlmsg_parse(n, sizeof(*tcm), tca, TCA_MAX, NULL);\r\nif (err < 0)\r\nreturn err;\r\nif (clid) {\r\nif (clid != TC_H_ROOT) {\r\nif (TC_H_MAJ(clid) != TC_H_MAJ(TC_H_INGRESS)) {\r\np = qdisc_lookup(dev, TC_H_MAJ(clid));\r\nif (!p)\r\nreturn -ENOENT;\r\nq = qdisc_leaf(p, clid);\r\n} else if (dev_ingress_queue(dev)) {\r\nq = dev_ingress_queue(dev)->qdisc_sleeping;\r\n}\r\n} else {\r\nq = dev->qdisc;\r\n}\r\nif (!q)\r\nreturn -ENOENT;\r\nif (tcm->tcm_handle && q->handle != tcm->tcm_handle)\r\nreturn -EINVAL;\r\n} else {\r\nq = qdisc_lookup(dev, tcm->tcm_handle);\r\nif (!q)\r\nreturn -ENOENT;\r\n}\r\nif (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], q->ops->id))\r\nreturn -EINVAL;\r\nif (n->nlmsg_type == RTM_DELQDISC) {\r\nif (!clid)\r\nreturn -EINVAL;\r\nif (q->handle == 0)\r\nreturn -ENOENT;\r\nerr = qdisc_graft(dev, p, skb, n, clid, NULL, q);\r\nif (err != 0)\r\nreturn err;\r\n} else {\r\nqdisc_notify(net, skb, n, clid, NULL, q);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tc_modify_qdisc(struct sk_buff *skb, struct nlmsghdr *n, void *arg)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct tcmsg *tcm;\r\nstruct nlattr *tca[TCA_MAX + 1];\r\nstruct net_device *dev;\r\nu32 clid;\r\nstruct Qdisc *q, *p;\r\nint err;\r\nreplay:\r\ntcm = NLMSG_DATA(n);\r\nclid = tcm->tcm_parent;\r\nq = p = NULL;\r\ndev = __dev_get_by_index(net, tcm->tcm_ifindex);\r\nif (!dev)\r\nreturn -ENODEV;\r\nerr = nlmsg_parse(n, sizeof(*tcm), tca, TCA_MAX, NULL);\r\nif (err < 0)\r\nreturn err;\r\nif (clid) {\r\nif (clid != TC_H_ROOT) {\r\nif (clid != TC_H_INGRESS) {\r\np = qdisc_lookup(dev, TC_H_MAJ(clid));\r\nif (!p)\r\nreturn -ENOENT;\r\nq = qdisc_leaf(p, clid);\r\n} else if (dev_ingress_queue_create(dev)) {\r\nq = dev_ingress_queue(dev)->qdisc_sleeping;\r\n}\r\n} else {\r\nq = dev->qdisc;\r\n}\r\nif (q && q->handle == 0)\r\nq = NULL;\r\nif (!q || !tcm->tcm_handle || q->handle != tcm->tcm_handle) {\r\nif (tcm->tcm_handle) {\r\nif (q && !(n->nlmsg_flags & NLM_F_REPLACE))\r\nreturn -EEXIST;\r\nif (TC_H_MIN(tcm->tcm_handle))\r\nreturn -EINVAL;\r\nq = qdisc_lookup(dev, tcm->tcm_handle);\r\nif (!q)\r\ngoto create_n_graft;\r\nif (n->nlmsg_flags & NLM_F_EXCL)\r\nreturn -EEXIST;\r\nif (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], q->ops->id))\r\nreturn -EINVAL;\r\nif (q == p ||\r\n(p && check_loop(q, p, 0)))\r\nreturn -ELOOP;\r\natomic_inc(&q->refcnt);\r\ngoto graft;\r\n} else {\r\nif (!q)\r\ngoto create_n_graft;\r\nif ((n->nlmsg_flags & NLM_F_CREATE) &&\r\n(n->nlmsg_flags & NLM_F_REPLACE) &&\r\n((n->nlmsg_flags & NLM_F_EXCL) ||\r\n(tca[TCA_KIND] &&\r\nnla_strcmp(tca[TCA_KIND], q->ops->id))))\r\ngoto create_n_graft;\r\n}\r\n}\r\n} else {\r\nif (!tcm->tcm_handle)\r\nreturn -EINVAL;\r\nq = qdisc_lookup(dev, tcm->tcm_handle);\r\n}\r\nif (q == NULL)\r\nreturn -ENOENT;\r\nif (n->nlmsg_flags & NLM_F_EXCL)\r\nreturn -EEXIST;\r\nif (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], q->ops->id))\r\nreturn -EINVAL;\r\nerr = qdisc_change(q, tca);\r\nif (err == 0)\r\nqdisc_notify(net, skb, n, clid, NULL, q);\r\nreturn err;\r\ncreate_n_graft:\r\nif (!(n->nlmsg_flags & NLM_F_CREATE))\r\nreturn -ENOENT;\r\nif (clid == TC_H_INGRESS) {\r\nif (dev_ingress_queue(dev))\r\nq = qdisc_create(dev, dev_ingress_queue(dev), p,\r\ntcm->tcm_parent, tcm->tcm_parent,\r\ntca, &err);\r\nelse\r\nerr = -ENOENT;\r\n} else {\r\nstruct netdev_queue *dev_queue;\r\nif (p && p->ops->cl_ops && p->ops->cl_ops->select_queue)\r\ndev_queue = p->ops->cl_ops->select_queue(p, tcm);\r\nelse if (p)\r\ndev_queue = p->dev_queue;\r\nelse\r\ndev_queue = netdev_get_tx_queue(dev, 0);\r\nq = qdisc_create(dev, dev_queue, p,\r\ntcm->tcm_parent, tcm->tcm_handle,\r\ntca, &err);\r\n}\r\nif (q == NULL) {\r\nif (err == -EAGAIN)\r\ngoto replay;\r\nreturn err;\r\n}\r\ngraft:\r\nerr = qdisc_graft(dev, p, skb, n, clid, q, NULL);\r\nif (err) {\r\nif (q)\r\nqdisc_destroy(q);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tc_fill_qdisc(struct sk_buff *skb, struct Qdisc *q, u32 clid,\r\nu32 pid, u32 seq, u16 flags, int event)\r\n{\r\nstruct tcmsg *tcm;\r\nstruct nlmsghdr *nlh;\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct gnet_dump d;\r\nstruct qdisc_size_table *stab;\r\nnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\r\ntcm = NLMSG_DATA(nlh);\r\ntcm->tcm_family = AF_UNSPEC;\r\ntcm->tcm__pad1 = 0;\r\ntcm->tcm__pad2 = 0;\r\ntcm->tcm_ifindex = qdisc_dev(q)->ifindex;\r\ntcm->tcm_parent = clid;\r\ntcm->tcm_handle = q->handle;\r\ntcm->tcm_info = atomic_read(&q->refcnt);\r\nNLA_PUT_STRING(skb, TCA_KIND, q->ops->id);\r\nif (q->ops->dump && q->ops->dump(q, skb) < 0)\r\ngoto nla_put_failure;\r\nq->qstats.qlen = q->q.qlen;\r\nstab = rtnl_dereference(q->stab);\r\nif (stab && qdisc_dump_stab(skb, stab) < 0)\r\ngoto nla_put_failure;\r\nif (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS, TCA_XSTATS,\r\nqdisc_root_sleeping_lock(q), &d) < 0)\r\ngoto nla_put_failure;\r\nif (q->ops->dump_stats && q->ops->dump_stats(q, &d) < 0)\r\ngoto nla_put_failure;\r\nif (gnet_stats_copy_basic(&d, &q->bstats) < 0 ||\r\ngnet_stats_copy_rate_est(&d, &q->bstats, &q->rate_est) < 0 ||\r\ngnet_stats_copy_queue(&d, &q->qstats) < 0)\r\ngoto nla_put_failure;\r\nif (gnet_stats_finish_copy(&d) < 0)\r\ngoto nla_put_failure;\r\nnlh->nlmsg_len = skb_tail_pointer(skb) - b;\r\nreturn skb->len;\r\nnlmsg_failure:\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic bool tc_qdisc_dump_ignore(struct Qdisc *q)\r\n{\r\nreturn (q->flags & TCQ_F_BUILTIN) ? true : false;\r\n}\r\nstatic int qdisc_notify(struct net *net, struct sk_buff *oskb,\r\nstruct nlmsghdr *n, u32 clid,\r\nstruct Qdisc *old, struct Qdisc *new)\r\n{\r\nstruct sk_buff *skb;\r\nu32 pid = oskb ? NETLINK_CB(oskb).pid : 0;\r\nskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOBUFS;\r\nif (old && !tc_qdisc_dump_ignore(old)) {\r\nif (tc_fill_qdisc(skb, old, clid, pid, n->nlmsg_seq,\r\n0, RTM_DELQDISC) < 0)\r\ngoto err_out;\r\n}\r\nif (new && !tc_qdisc_dump_ignore(new)) {\r\nif (tc_fill_qdisc(skb, new, clid, pid, n->nlmsg_seq,\r\nold ? NLM_F_REPLACE : 0, RTM_NEWQDISC) < 0)\r\ngoto err_out;\r\n}\r\nif (skb->len)\r\nreturn rtnetlink_send(skb, net, pid, RTNLGRP_TC,\r\nn->nlmsg_flags & NLM_F_ECHO);\r\nerr_out:\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nstatic int tc_dump_qdisc_root(struct Qdisc *root, struct sk_buff *skb,\r\nstruct netlink_callback *cb,\r\nint *q_idx_p, int s_q_idx)\r\n{\r\nint ret = 0, q_idx = *q_idx_p;\r\nstruct Qdisc *q;\r\nif (!root)\r\nreturn 0;\r\nq = root;\r\nif (q_idx < s_q_idx) {\r\nq_idx++;\r\n} else {\r\nif (!tc_qdisc_dump_ignore(q) &&\r\ntc_fill_qdisc(skb, q, q->parent, NETLINK_CB(cb->skb).pid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI, RTM_NEWQDISC) <= 0)\r\ngoto done;\r\nq_idx++;\r\n}\r\nlist_for_each_entry(q, &root->list, list) {\r\nif (q_idx < s_q_idx) {\r\nq_idx++;\r\ncontinue;\r\n}\r\nif (!tc_qdisc_dump_ignore(q) &&\r\ntc_fill_qdisc(skb, q, q->parent, NETLINK_CB(cb->skb).pid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI, RTM_NEWQDISC) <= 0)\r\ngoto done;\r\nq_idx++;\r\n}\r\nout:\r\n*q_idx_p = q_idx;\r\nreturn ret;\r\ndone:\r\nret = -1;\r\ngoto out;\r\n}\r\nstatic int tc_dump_qdisc(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nint idx, q_idx;\r\nint s_idx, s_q_idx;\r\nstruct net_device *dev;\r\ns_idx = cb->args[0];\r\ns_q_idx = q_idx = cb->args[1];\r\nrcu_read_lock();\r\nidx = 0;\r\nfor_each_netdev_rcu(net, dev) {\r\nstruct netdev_queue *dev_queue;\r\nif (idx < s_idx)\r\ngoto cont;\r\nif (idx > s_idx)\r\ns_q_idx = 0;\r\nq_idx = 0;\r\nif (tc_dump_qdisc_root(dev->qdisc, skb, cb, &q_idx, s_q_idx) < 0)\r\ngoto done;\r\ndev_queue = dev_ingress_queue(dev);\r\nif (dev_queue &&\r\ntc_dump_qdisc_root(dev_queue->qdisc_sleeping, skb, cb,\r\n&q_idx, s_q_idx) < 0)\r\ngoto done;\r\ncont:\r\nidx++;\r\n}\r\ndone:\r\nrcu_read_unlock();\r\ncb->args[0] = idx;\r\ncb->args[1] = q_idx;\r\nreturn skb->len;\r\n}\r\nstatic int tc_ctl_tclass(struct sk_buff *skb, struct nlmsghdr *n, void *arg)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct tcmsg *tcm = NLMSG_DATA(n);\r\nstruct nlattr *tca[TCA_MAX + 1];\r\nstruct net_device *dev;\r\nstruct Qdisc *q = NULL;\r\nconst struct Qdisc_class_ops *cops;\r\nunsigned long cl = 0;\r\nunsigned long new_cl;\r\nu32 pid = tcm->tcm_parent;\r\nu32 clid = tcm->tcm_handle;\r\nu32 qid = TC_H_MAJ(clid);\r\nint err;\r\ndev = __dev_get_by_index(net, tcm->tcm_ifindex);\r\nif (!dev)\r\nreturn -ENODEV;\r\nerr = nlmsg_parse(n, sizeof(*tcm), tca, TCA_MAX, NULL);\r\nif (err < 0)\r\nreturn err;\r\nif (pid != TC_H_ROOT) {\r\nu32 qid1 = TC_H_MAJ(pid);\r\nif (qid && qid1) {\r\nif (qid != qid1)\r\nreturn -EINVAL;\r\n} else if (qid1) {\r\nqid = qid1;\r\n} else if (qid == 0)\r\nqid = dev->qdisc->handle;\r\nif (pid)\r\npid = TC_H_MAKE(qid, pid);\r\n} else {\r\nif (qid == 0)\r\nqid = dev->qdisc->handle;\r\n}\r\nq = qdisc_lookup(dev, qid);\r\nif (!q)\r\nreturn -ENOENT;\r\ncops = q->ops->cl_ops;\r\nif (cops == NULL)\r\nreturn -EINVAL;\r\nif (clid == 0) {\r\nif (pid == TC_H_ROOT)\r\nclid = qid;\r\n} else\r\nclid = TC_H_MAKE(qid, clid);\r\nif (clid)\r\ncl = cops->get(q, clid);\r\nif (cl == 0) {\r\nerr = -ENOENT;\r\nif (n->nlmsg_type != RTM_NEWTCLASS ||\r\n!(n->nlmsg_flags & NLM_F_CREATE))\r\ngoto out;\r\n} else {\r\nswitch (n->nlmsg_type) {\r\ncase RTM_NEWTCLASS:\r\nerr = -EEXIST;\r\nif (n->nlmsg_flags & NLM_F_EXCL)\r\ngoto out;\r\nbreak;\r\ncase RTM_DELTCLASS:\r\nerr = -EOPNOTSUPP;\r\nif (cops->delete)\r\nerr = cops->delete(q, cl);\r\nif (err == 0)\r\ntclass_notify(net, skb, n, q, cl, RTM_DELTCLASS);\r\ngoto out;\r\ncase RTM_GETTCLASS:\r\nerr = tclass_notify(net, skb, n, q, cl, RTM_NEWTCLASS);\r\ngoto out;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nnew_cl = cl;\r\nerr = -EOPNOTSUPP;\r\nif (cops->change)\r\nerr = cops->change(q, clid, pid, tca, &new_cl);\r\nif (err == 0)\r\ntclass_notify(net, skb, n, q, new_cl, RTM_NEWTCLASS);\r\nout:\r\nif (cl)\r\ncops->put(q, cl);\r\nreturn err;\r\n}\r\nstatic int tc_fill_tclass(struct sk_buff *skb, struct Qdisc *q,\r\nunsigned long cl,\r\nu32 pid, u32 seq, u16 flags, int event)\r\n{\r\nstruct tcmsg *tcm;\r\nstruct nlmsghdr *nlh;\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct gnet_dump d;\r\nconst struct Qdisc_class_ops *cl_ops = q->ops->cl_ops;\r\nnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\r\ntcm = NLMSG_DATA(nlh);\r\ntcm->tcm_family = AF_UNSPEC;\r\ntcm->tcm__pad1 = 0;\r\ntcm->tcm__pad2 = 0;\r\ntcm->tcm_ifindex = qdisc_dev(q)->ifindex;\r\ntcm->tcm_parent = q->handle;\r\ntcm->tcm_handle = q->handle;\r\ntcm->tcm_info = 0;\r\nNLA_PUT_STRING(skb, TCA_KIND, q->ops->id);\r\nif (cl_ops->dump && cl_ops->dump(q, cl, skb, tcm) < 0)\r\ngoto nla_put_failure;\r\nif (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS, TCA_XSTATS,\r\nqdisc_root_sleeping_lock(q), &d) < 0)\r\ngoto nla_put_failure;\r\nif (cl_ops->dump_stats && cl_ops->dump_stats(q, cl, &d) < 0)\r\ngoto nla_put_failure;\r\nif (gnet_stats_finish_copy(&d) < 0)\r\ngoto nla_put_failure;\r\nnlh->nlmsg_len = skb_tail_pointer(skb) - b;\r\nreturn skb->len;\r\nnlmsg_failure:\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int tclass_notify(struct net *net, struct sk_buff *oskb,\r\nstruct nlmsghdr *n, struct Qdisc *q,\r\nunsigned long cl, int event)\r\n{\r\nstruct sk_buff *skb;\r\nu32 pid = oskb ? NETLINK_CB(oskb).pid : 0;\r\nskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOBUFS;\r\nif (tc_fill_tclass(skb, q, cl, pid, n->nlmsg_seq, 0, event) < 0) {\r\nkfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nreturn rtnetlink_send(skb, net, pid, RTNLGRP_TC,\r\nn->nlmsg_flags & NLM_F_ECHO);\r\n}\r\nstatic int qdisc_class_dump(struct Qdisc *q, unsigned long cl, struct qdisc_walker *arg)\r\n{\r\nstruct qdisc_dump_args *a = (struct qdisc_dump_args *)arg;\r\nreturn tc_fill_tclass(a->skb, q, cl, NETLINK_CB(a->cb->skb).pid,\r\na->cb->nlh->nlmsg_seq, NLM_F_MULTI, RTM_NEWTCLASS);\r\n}\r\nstatic int tc_dump_tclass_qdisc(struct Qdisc *q, struct sk_buff *skb,\r\nstruct tcmsg *tcm, struct netlink_callback *cb,\r\nint *t_p, int s_t)\r\n{\r\nstruct qdisc_dump_args arg;\r\nif (tc_qdisc_dump_ignore(q) ||\r\n*t_p < s_t || !q->ops->cl_ops ||\r\n(tcm->tcm_parent &&\r\nTC_H_MAJ(tcm->tcm_parent) != q->handle)) {\r\n(*t_p)++;\r\nreturn 0;\r\n}\r\nif (*t_p > s_t)\r\nmemset(&cb->args[1], 0, sizeof(cb->args)-sizeof(cb->args[0]));\r\narg.w.fn = qdisc_class_dump;\r\narg.skb = skb;\r\narg.cb = cb;\r\narg.w.stop = 0;\r\narg.w.skip = cb->args[1];\r\narg.w.count = 0;\r\nq->ops->cl_ops->walk(q, &arg.w);\r\ncb->args[1] = arg.w.count;\r\nif (arg.w.stop)\r\nreturn -1;\r\n(*t_p)++;\r\nreturn 0;\r\n}\r\nstatic int tc_dump_tclass_root(struct Qdisc *root, struct sk_buff *skb,\r\nstruct tcmsg *tcm, struct netlink_callback *cb,\r\nint *t_p, int s_t)\r\n{\r\nstruct Qdisc *q;\r\nif (!root)\r\nreturn 0;\r\nif (tc_dump_tclass_qdisc(root, skb, tcm, cb, t_p, s_t) < 0)\r\nreturn -1;\r\nlist_for_each_entry(q, &root->list, list) {\r\nif (tc_dump_tclass_qdisc(q, skb, tcm, cb, t_p, s_t) < 0)\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tc_dump_tclass(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct tcmsg *tcm = (struct tcmsg *)NLMSG_DATA(cb->nlh);\r\nstruct net *net = sock_net(skb->sk);\r\nstruct netdev_queue *dev_queue;\r\nstruct net_device *dev;\r\nint t, s_t;\r\nif (cb->nlh->nlmsg_len < NLMSG_LENGTH(sizeof(*tcm)))\r\nreturn 0;\r\ndev = dev_get_by_index(net, tcm->tcm_ifindex);\r\nif (!dev)\r\nreturn 0;\r\ns_t = cb->args[0];\r\nt = 0;\r\nif (tc_dump_tclass_root(dev->qdisc, skb, tcm, cb, &t, s_t) < 0)\r\ngoto done;\r\ndev_queue = dev_ingress_queue(dev);\r\nif (dev_queue &&\r\ntc_dump_tclass_root(dev_queue->qdisc_sleeping, skb, tcm, cb,\r\n&t, s_t) < 0)\r\ngoto done;\r\ndone:\r\ncb->args[0] = t;\r\ndev_put(dev);\r\nreturn skb->len;\r\n}\r\nint tc_classify_compat(struct sk_buff *skb, const struct tcf_proto *tp,\r\nstruct tcf_result *res)\r\n{\r\n__be16 protocol = skb->protocol;\r\nint err;\r\nfor (; tp; tp = tp->next) {\r\nif (tp->protocol != protocol &&\r\ntp->protocol != htons(ETH_P_ALL))\r\ncontinue;\r\nerr = tp->classify(skb, tp, res);\r\nif (err >= 0) {\r\n#ifdef CONFIG_NET_CLS_ACT\r\nif (err != TC_ACT_RECLASSIFY && skb->tc_verd)\r\nskb->tc_verd = SET_TC_VERD(skb->tc_verd, 0);\r\n#endif\r\nreturn err;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nint tc_classify(struct sk_buff *skb, const struct tcf_proto *tp,\r\nstruct tcf_result *res)\r\n{\r\nint err = 0;\r\n#ifdef CONFIG_NET_CLS_ACT\r\nconst struct tcf_proto *otp = tp;\r\nreclassify:\r\n#endif\r\nerr = tc_classify_compat(skb, tp, res);\r\n#ifdef CONFIG_NET_CLS_ACT\r\nif (err == TC_ACT_RECLASSIFY) {\r\nu32 verd = G_TC_VERD(skb->tc_verd);\r\ntp = otp;\r\nif (verd++ >= MAX_REC_LOOP) {\r\nif (net_ratelimit())\r\npr_notice("%s: packet reclassify loop"\r\n" rule prio %u protocol %02x\n",\r\ntp->q->ops->id,\r\ntp->prio & 0xffff,\r\nntohs(tp->protocol));\r\nreturn TC_ACT_SHOT;\r\n}\r\nskb->tc_verd = SET_TC_VERD(skb->tc_verd, verd);\r\ngoto reclassify;\r\n}\r\n#endif\r\nreturn err;\r\n}\r\nvoid tcf_destroy(struct tcf_proto *tp)\r\n{\r\ntp->ops->destroy(tp);\r\nmodule_put(tp->ops->owner);\r\nkfree(tp);\r\n}\r\nvoid tcf_destroy_chain(struct tcf_proto **fl)\r\n{\r\nstruct tcf_proto *tp;\r\nwhile ((tp = *fl) != NULL) {\r\n*fl = tp->next;\r\ntcf_destroy(tp);\r\n}\r\n}\r\nstatic int psched_show(struct seq_file *seq, void *v)\r\n{\r\nstruct timespec ts;\r\nhrtimer_get_res(CLOCK_MONOTONIC, &ts);\r\nseq_printf(seq, "%08x %08x %08x %08x\n",\r\n(u32)NSEC_PER_USEC, (u32)PSCHED_TICKS2NS(1),\r\n1000000,\r\n(u32)NSEC_PER_SEC/(u32)ktime_to_ns(timespec_to_ktime(ts)));\r\nreturn 0;\r\n}\r\nstatic int psched_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, psched_show, NULL);\r\n}\r\nstatic int __net_init psched_net_init(struct net *net)\r\n{\r\nstruct proc_dir_entry *e;\r\ne = proc_net_fops_create(net, "psched", 0, &psched_fops);\r\nif (e == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __net_exit psched_net_exit(struct net *net)\r\n{\r\nproc_net_remove(net, "psched");\r\n}\r\nstatic int __net_init psched_net_init(struct net *net)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __net_exit psched_net_exit(struct net *net)\r\n{\r\n}\r\nstatic int __init pktsched_init(void)\r\n{\r\nint err;\r\nerr = register_pernet_subsys(&psched_net_ops);\r\nif (err) {\r\npr_err("pktsched_init: "\r\n"cannot initialize per netns operations\n");\r\nreturn err;\r\n}\r\nregister_qdisc(&pfifo_qdisc_ops);\r\nregister_qdisc(&bfifo_qdisc_ops);\r\nregister_qdisc(&pfifo_head_drop_qdisc_ops);\r\nregister_qdisc(&mq_qdisc_ops);\r\nrtnl_register(PF_UNSPEC, RTM_NEWQDISC, tc_modify_qdisc, NULL, NULL);\r\nrtnl_register(PF_UNSPEC, RTM_DELQDISC, tc_get_qdisc, NULL, NULL);\r\nrtnl_register(PF_UNSPEC, RTM_GETQDISC, tc_get_qdisc, tc_dump_qdisc, NULL);\r\nrtnl_register(PF_UNSPEC, RTM_NEWTCLASS, tc_ctl_tclass, NULL, NULL);\r\nrtnl_register(PF_UNSPEC, RTM_DELTCLASS, tc_ctl_tclass, NULL, NULL);\r\nrtnl_register(PF_UNSPEC, RTM_GETTCLASS, tc_ctl_tclass, tc_dump_tclass, NULL);\r\nreturn 0;\r\n}
