static char *escape(const char* text, char *bf, int len)\r\n{\r\nchar *bfp = bf;\r\nint multiline = strchr(text, '\n') != NULL;\r\nint eol = 0;\r\nint textlen = strlen(text);\r\nif ((textlen > 0) && (text[textlen-1] == '\n'))\r\neol = 1;\r\n*bfp++ = '"';\r\n--len;\r\nif (multiline) {\r\n*bfp++ = '"';\r\n*bfp++ = '\n';\r\n*bfp++ = '"';\r\nlen -= 3;\r\n}\r\nwhile (*text != '\0' && len > 1) {\r\nif (*text == '"')\r\n*bfp++ = '\\';\r\nelse if (*text == '\n') {\r\n*bfp++ = '\\';\r\n*bfp++ = 'n';\r\n*bfp++ = '"';\r\n*bfp++ = '\n';\r\n*bfp++ = '"';\r\nlen -= 5;\r\n++text;\r\ngoto next;\r\n}\r\nelse if (*text == '\\') {\r\n*bfp++ = '\\';\r\nlen--;\r\n}\r\n*bfp++ = *text++;\r\nnext:\r\n--len;\r\n}\r\nif (multiline && eol)\r\nbfp -= 3;\r\n*bfp++ = '"';\r\n*bfp = '\0';\r\nreturn bf;\r\n}\r\nstatic struct file_line *file_line__new(const char *file, int lineno)\r\n{\r\nstruct file_line *self = malloc(sizeof(*self));\r\nif (self == NULL)\r\ngoto out;\r\nself->file = file;\r\nself->lineno = lineno;\r\nself->next = NULL;\r\nout:\r\nreturn self;\r\n}\r\nstatic struct message *message__new(const char *msg, char *option,\r\nconst char *file, int lineno)\r\n{\r\nstruct message *self = malloc(sizeof(*self));\r\nif (self == NULL)\r\ngoto out;\r\nself->files = file_line__new(file, lineno);\r\nif (self->files == NULL)\r\ngoto out_fail;\r\nself->msg = strdup(msg);\r\nif (self->msg == NULL)\r\ngoto out_fail_msg;\r\nself->option = option;\r\nself->next = NULL;\r\nout:\r\nreturn self;\r\nout_fail_msg:\r\nfree(self->files);\r\nout_fail:\r\nfree(self);\r\nself = NULL;\r\ngoto out;\r\n}\r\nstatic struct message *mesage__find(const char *msg)\r\n{\r\nstruct message *m = message__list;\r\nwhile (m != NULL) {\r\nif (strcmp(m->msg, msg) == 0)\r\nbreak;\r\nm = m->next;\r\n}\r\nreturn m;\r\n}\r\nstatic int message__add_file_line(struct message *self, const char *file,\r\nint lineno)\r\n{\r\nint rc = -1;\r\nstruct file_line *fl = file_line__new(file, lineno);\r\nif (fl == NULL)\r\ngoto out;\r\nfl->next = self->files;\r\nself->files = fl;\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int message__add(const char *msg, char *option, const char *file,\r\nint lineno)\r\n{\r\nint rc = 0;\r\nchar bf[16384];\r\nchar *escaped = escape(msg, bf, sizeof(bf));\r\nstruct message *m = mesage__find(escaped);\r\nif (m != NULL)\r\nrc = message__add_file_line(m, file, lineno);\r\nelse {\r\nm = message__new(escaped, option, file, lineno);\r\nif (m != NULL) {\r\nm->next = message__list;\r\nmessage__list = m;\r\n} else\r\nrc = -1;\r\n}\r\nreturn rc;\r\n}\r\nstatic void menu_build_message_list(struct menu *menu)\r\n{\r\nstruct menu *child;\r\nmessage__add(menu_get_prompt(menu), NULL,\r\nmenu->file == NULL ? "Root Menu" : menu->file->name,\r\nmenu->lineno);\r\nif (menu->sym != NULL && menu_has_help(menu))\r\nmessage__add(menu_get_help(menu), menu->sym->name,\r\nmenu->file == NULL ? "Root Menu" : menu->file->name,\r\nmenu->lineno);\r\nfor (child = menu->list; child != NULL; child = child->next)\r\nif (child->prompt != NULL)\r\nmenu_build_message_list(child);\r\n}\r\nstatic void message__print_file_lineno(struct message *self)\r\n{\r\nstruct file_line *fl = self->files;\r\nputchar('\n');\r\nif (self->option != NULL)\r\nprintf("# %s:00000\n", self->option);\r\nprintf("#: %s:%d", fl->file, fl->lineno);\r\nfl = fl->next;\r\nwhile (fl != NULL) {\r\nprintf(", %s:%d", fl->file, fl->lineno);\r\nfl = fl->next;\r\n}\r\nputchar('\n');\r\n}\r\nstatic void message__print_gettext_msgid_msgstr(struct message *self)\r\n{\r\nmessage__print_file_lineno(self);\r\nprintf("msgid %s\n"\r\n"msgstr \"\"\n", self->msg);\r\n}\r\nstatic void menu__xgettext(void)\r\n{\r\nstruct message *m = message__list;\r\nwhile (m != NULL) {\r\nif (strlen(m->msg) > sizeof("\"\""))\r\nmessage__print_gettext_msgid_msgstr(m);\r\nm = m->next;\r\n}\r\n}\r\nint main(int ac, char **av)\r\n{\r\nconf_parse(av[1]);\r\nmenu_build_message_list(menu_get_root_menu(NULL));\r\nmenu__xgettext();\r\nreturn 0;\r\n}
