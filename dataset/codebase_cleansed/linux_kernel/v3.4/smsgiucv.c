static int smsg_path_pending(struct iucv_path *path, u8 ipvmid[8],\r\nu8 ipuser[16])\r\n{\r\nif (strncmp(ipvmid, "*MSG ", 8) != 0)\r\nreturn -EINVAL;\r\nreturn iucv_path_accept(path, &smsg_handler, "SMSGIUCV ", NULL);\r\n}\r\nstatic void smsg_message_pending(struct iucv_path *path,\r\nstruct iucv_message *msg)\r\n{\r\nstruct smsg_callback *cb;\r\nunsigned char *buffer;\r\nunsigned char sender[9];\r\nint rc, i;\r\nbuffer = kmalloc(msg->length + 1, GFP_ATOMIC | GFP_DMA);\r\nif (!buffer) {\r\niucv_message_reject(path, msg);\r\nreturn;\r\n}\r\nrc = iucv_message_receive(path, msg, 0, buffer, msg->length, NULL);\r\nif (rc == 0) {\r\nbuffer[msg->length] = 0;\r\nEBCASC(buffer, msg->length);\r\nmemcpy(sender, buffer, 8);\r\nsender[8] = 0;\r\nfor (i = 7; i >= 0; i--) {\r\nif (sender[i] != ' ' && sender[i] != '\t')\r\nbreak;\r\nsender[i] = 0;\r\n}\r\nspin_lock(&smsg_list_lock);\r\nlist_for_each_entry(cb, &smsg_list, list)\r\nif (strncmp(buffer + 8, cb->prefix, cb->len) == 0) {\r\ncb->callback(sender, buffer + 8);\r\nbreak;\r\n}\r\nspin_unlock(&smsg_list_lock);\r\n}\r\nkfree(buffer);\r\n}\r\nint smsg_register_callback(const char *prefix,\r\nvoid (*callback)(const char *from, char *str))\r\n{\r\nstruct smsg_callback *cb;\r\ncb = kmalloc(sizeof(struct smsg_callback), GFP_KERNEL);\r\nif (!cb)\r\nreturn -ENOMEM;\r\ncb->prefix = prefix;\r\ncb->len = strlen(prefix);\r\ncb->callback = callback;\r\nspin_lock_bh(&smsg_list_lock);\r\nlist_add_tail(&cb->list, &smsg_list);\r\nspin_unlock_bh(&smsg_list_lock);\r\nreturn 0;\r\n}\r\nvoid smsg_unregister_callback(const char *prefix,\r\nvoid (*callback)(const char *from,\r\nchar *str))\r\n{\r\nstruct smsg_callback *cb, *tmp;\r\nspin_lock_bh(&smsg_list_lock);\r\ncb = NULL;\r\nlist_for_each_entry(tmp, &smsg_list, list)\r\nif (tmp->callback == callback &&\r\nstrcmp(tmp->prefix, prefix) == 0) {\r\ncb = tmp;\r\nlist_del(&cb->list);\r\nbreak;\r\n}\r\nspin_unlock_bh(&smsg_list_lock);\r\nkfree(cb);\r\n}\r\nstatic int smsg_pm_freeze(struct device *dev)\r\n{\r\n#ifdef CONFIG_PM_DEBUG\r\nprintk(KERN_WARNING "smsg_pm_freeze\n");\r\n#endif\r\nif (smsg_path && iucv_path_connected) {\r\niucv_path_sever(smsg_path, NULL);\r\niucv_path_connected = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smsg_pm_restore_thaw(struct device *dev)\r\n{\r\nint rc;\r\n#ifdef CONFIG_PM_DEBUG\r\nprintk(KERN_WARNING "smsg_pm_restore_thaw\n");\r\n#endif\r\nif (smsg_path && iucv_path_connected) {\r\nmemset(smsg_path, 0, sizeof(*smsg_path));\r\nsmsg_path->msglim = 255;\r\nsmsg_path->flags = 0;\r\nrc = iucv_path_connect(smsg_path, &smsg_handler, "*MSG ",\r\nNULL, NULL, NULL);\r\n#ifdef CONFIG_PM_DEBUG\r\nif (rc)\r\nprintk(KERN_ERR\r\n"iucv_path_connect returned with rc %i\n", rc);\r\n#endif\r\nif (!rc)\r\niucv_path_connected = 1;\r\ncpcmd("SET SMSG IUCV", NULL, 0, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit smsg_exit(void)\r\n{\r\ncpcmd("SET SMSG IUCV", NULL, 0, NULL);\r\ndevice_unregister(smsg_dev);\r\niucv_unregister(&smsg_handler, 1);\r\ndriver_unregister(&smsg_driver);\r\n}\r\nstatic int __init smsg_init(void)\r\n{\r\nint rc;\r\nif (!MACHINE_IS_VM) {\r\nrc = -EPROTONOSUPPORT;\r\ngoto out;\r\n}\r\nrc = driver_register(&smsg_driver);\r\nif (rc != 0)\r\ngoto out;\r\nrc = iucv_register(&smsg_handler, 1);\r\nif (rc)\r\ngoto out_driver;\r\nsmsg_path = iucv_path_alloc(255, 0, GFP_KERNEL);\r\nif (!smsg_path) {\r\nrc = -ENOMEM;\r\ngoto out_register;\r\n}\r\nrc = iucv_path_connect(smsg_path, &smsg_handler, "*MSG ",\r\nNULL, NULL, NULL);\r\nif (rc)\r\ngoto out_free_path;\r\nelse\r\niucv_path_connected = 1;\r\nsmsg_dev = kzalloc(sizeof(struct device), GFP_KERNEL);\r\nif (!smsg_dev) {\r\nrc = -ENOMEM;\r\ngoto out_free_path;\r\n}\r\ndev_set_name(smsg_dev, "smsg_iucv");\r\nsmsg_dev->bus = &iucv_bus;\r\nsmsg_dev->parent = iucv_root;\r\nsmsg_dev->release = (void (*)(struct device *))kfree;\r\nsmsg_dev->driver = &smsg_driver;\r\nrc = device_register(smsg_dev);\r\nif (rc)\r\ngoto out_put;\r\ncpcmd("SET SMSG IUCV", NULL, 0, NULL);\r\nreturn 0;\r\nout_put:\r\nput_device(smsg_dev);\r\nout_free_path:\r\niucv_path_free(smsg_path);\r\nsmsg_path = NULL;\r\nout_register:\r\niucv_unregister(&smsg_handler, 1);\r\nout_driver:\r\ndriver_unregister(&smsg_driver);\r\nout:\r\nreturn rc;\r\n}
