static int rts51x_sd_direct_cmnd(struct rts51x_chip *chip,\r\nstruct sd_direct_cmnd *cmnd)\r\n{\r\nint retval;\r\nu8 dir, cmd12, standby, acmd, cmd_idx, rsp_code;\r\nu8 *buf;\r\nu32 arg, len;\r\ndir = (cmnd->cmnd[0] >> 3) & 0x03;\r\ncmd12 = (cmnd->cmnd[0] >> 2) & 0x01;\r\nstandby = (cmnd->cmnd[0] >> 1) & 0x01;\r\nacmd = cmnd->cmnd[0] & 0x01;\r\ncmd_idx = cmnd->cmnd[1];\r\narg = ((u32) (cmnd->cmnd[2]) << 24) | ((u32) (cmnd->cmnd[3]) << 16) |\r\n((u32) (cmnd->cmnd[4]) << 8) | cmnd->cmnd[5];\r\nlen =\r\n((u32) (cmnd->cmnd[6]) << 16) | ((u32) (cmnd->cmnd[7]) << 8) |\r\ncmnd->cmnd[8];\r\nrsp_code = cmnd->cmnd[9];\r\nif (dir) {\r\nif (!cmnd->buf || (cmnd->buf_len < len))\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nswitch (dir) {\r\ncase 0:\r\nretval = ext_sd_execute_no_data(chip, chip->card2lun[SD_CARD],\r\ncmd_idx, standby, acmd,\r\nrsp_code, arg);\r\nif (retval != TRANSPORT_GOOD)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nbreak;\r\ncase 1:\r\nbuf = kmalloc(cmnd->buf_len, GFP_KERNEL);\r\nif (!buf)\r\nTRACE_RET(chip, STATUS_NOMEM);\r\nretval = ext_sd_execute_read_data(chip, chip->card2lun[SD_CARD],\r\ncmd_idx, cmd12, standby, acmd,\r\nrsp_code, arg, len, buf,\r\ncmnd->buf_len, 0);\r\nif (retval != TRANSPORT_GOOD) {\r\nkfree(buf);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nretval =\r\ncopy_to_user((void *)cmnd->buf, (void *)buf, cmnd->buf_len);\r\nif (retval) {\r\nkfree(buf);\r\nTRACE_RET(chip, STATUS_NOMEM);\r\n}\r\nkfree(buf);\r\nbreak;\r\ncase 2:\r\nbuf = kmalloc(cmnd->buf_len, GFP_KERNEL);\r\nif (!buf)\r\nTRACE_RET(chip, STATUS_NOMEM);\r\nretval =\r\ncopy_from_user((void *)buf, (void *)cmnd->buf,\r\ncmnd->buf_len);\r\nif (retval) {\r\nkfree(buf);\r\nTRACE_RET(chip, STATUS_NOMEM);\r\n}\r\nretval =\r\next_sd_execute_write_data(chip, chip->card2lun[SD_CARD],\r\ncmd_idx, cmd12, standby, acmd,\r\nrsp_code, arg, len, buf,\r\ncmnd->buf_len, 0);\r\nif (retval != TRANSPORT_GOOD) {\r\nkfree(buf);\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nkfree(buf);\r\nbreak;\r\ndefault:\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int rts51x_sd_get_rsp(struct rts51x_chip *chip, struct sd_rsp *rsp)\r\n{\r\nstruct sd_info *sd_card = &(chip->sd_card);\r\nint count = 0, retval;\r\nif (sd_card->pre_cmd_err) {\r\nsd_card->pre_cmd_err = 0;\r\nTRACE_RET(chip, STATUS_FAIL);\r\n}\r\nif (sd_card->last_rsp_type == SD_RSP_TYPE_R0)\r\nTRACE_RET(chip, STATUS_FAIL);\r\nelse if (sd_card->last_rsp_type == SD_RSP_TYPE_R2)\r\ncount = (rsp->rsp_len < 17) ? rsp->rsp_len : 17;\r\nelse\r\ncount = (rsp->rsp_len < 6) ? rsp->rsp_len : 6;\r\nretval = copy_to_user((void *)rsp->rsp, (void *)sd_card->rsp, count);\r\nif (retval)\r\nTRACE_RET(chip, STATUS_NOMEM);\r\nRTS51X_DEBUGP("Response length: %d\n", count);\r\nRTS51X_DEBUGP("Response: 0x%x 0x%x 0x%x 0x%x\n",\r\nsd_card->rsp[0], sd_card->rsp[1], sd_card->rsp[2],\r\nsd_card->rsp[3]);\r\nreturn STATUS_SUCCESS;\r\n}\r\nint rts51x_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct rts51x_chip *chip;\r\nstruct usb_interface *interface;\r\nint subminor;\r\nint retval = 0;\r\nsubminor = iminor(inode);\r\ninterface = usb_find_interface(&rts51x_driver, subminor);\r\nif (!interface) {\r\nRTS51X_DEBUGP("%s - error, can't find device for minor %d\n",\r\n__func__, subminor);\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nchip = (struct rts51x_chip *)usb_get_intfdata(interface);\r\nif (!chip) {\r\nRTS51X_DEBUGP("Can't find chip\n");\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\nscsi_host_get(rts51x_to_host(chip));\r\nmutex_lock(&(chip->usb->dev_mutex));\r\nfilp->private_data = chip;\r\nmutex_unlock(&chip->usb->dev_mutex);\r\nexit:\r\nreturn retval;\r\n}\r\nint rts51x_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct rts51x_chip *chip;\r\nchip = (struct rts51x_chip *)filp->private_data;\r\nif (chip == NULL)\r\nreturn -ENODEV;\r\nscsi_host_put(rts51x_to_host(chip));\r\nreturn 0;\r\n}\r\nssize_t rts51x_read(struct file *filp, char __user *buf, size_t count,\r\nloff_t *f_pos)\r\n{\r\nreturn 0;\r\n}\r\nssize_t rts51x_write(struct file *filp, const char __user *buf, size_t count,\r\nloff_t *f_pos)\r\n{\r\nreturn 0;\r\n}\r\nlong rts51x_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n#endif\r\n{\r\nstruct rts51x_chip *chip;\r\nstruct sd_direct_cmnd cmnd;\r\nstruct sd_rsp rsp;\r\nint retval = 0;\r\nchip = (struct rts51x_chip *)filp->private_data;\r\nif (chip == NULL)\r\nreturn -ENODEV;\r\nmutex_lock(&(chip->usb->dev_mutex));\r\nswitch (cmd) {\r\ncase RTS5139_IOC_SD_DIRECT:\r\nretval =\r\ncopy_from_user((void *)&cmnd, (void *)arg,\r\nsizeof(struct sd_direct_cmnd));\r\nif (retval) {\r\nretval = -ENOMEM;\r\nTRACE_GOTO(chip, exit);\r\n}\r\nretval = rts51x_sd_direct_cmnd(chip, &cmnd);\r\nif (retval != STATUS_SUCCESS) {\r\nretval = -EIO;\r\nTRACE_GOTO(chip, exit);\r\n}\r\nbreak;\r\ncase RTS5139_IOC_SD_GET_RSP:\r\nretval =\r\ncopy_from_user((void *)&rsp, (void *)arg,\r\nsizeof(struct sd_rsp));\r\nif (retval) {\r\nretval = -ENOMEM;\r\nTRACE_GOTO(chip, exit);\r\n}\r\nretval = rts51x_sd_get_rsp(chip, &rsp);\r\nif (retval != STATUS_SUCCESS) {\r\nretval = -EIO;\r\nTRACE_GOTO(chip, exit);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nexit:\r\nmutex_unlock(&chip->usb->dev_mutex);\r\nreturn retval;\r\n}
