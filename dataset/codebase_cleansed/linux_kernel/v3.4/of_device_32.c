static int of_bus_pci_match(struct device_node *np)\r\n{\r\nif (!strcmp(np->type, "pci") || !strcmp(np->type, "pciex")) {\r\nif (!of_find_property(np, "ranges", NULL))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void of_bus_pci_count_cells(struct device_node *np,\r\nint *addrc, int *sizec)\r\n{\r\nif (addrc)\r\n*addrc = 3;\r\nif (sizec)\r\n*sizec = 2;\r\n}\r\nstatic int of_bus_pci_map(u32 *addr, const u32 *range,\r\nint na, int ns, int pna)\r\n{\r\nu32 result[OF_MAX_ADDR_CELLS];\r\nint i;\r\nif ((addr[0] ^ range[0]) & 0x03000000)\r\nreturn -EINVAL;\r\nif (of_out_of_range(addr + 1, range + 1, range + na + pna,\r\nna - 1, ns))\r\nreturn -EINVAL;\r\nmemcpy(result, range + na, pna * 4);\r\nfor (i = 0; i < na - 1; i++)\r\nresult[pna - 1 - i] +=\r\n(addr[na - 1 - i] -\r\nrange[na - 1 - i]);\r\nmemcpy(addr, result, pna * 4);\r\nreturn 0;\r\n}\r\nstatic unsigned long of_bus_pci_get_flags(const u32 *addr, unsigned long flags)\r\n{\r\nu32 w = addr[0];\r\nflags = 0;\r\nswitch((w >> 24) & 0x03) {\r\ncase 0x01:\r\nflags |= IORESOURCE_IO;\r\nbreak;\r\ncase 0x02:\r\ncase 0x03:\r\nflags |= IORESOURCE_MEM;\r\nbreak;\r\n}\r\nif (w & 0x40000000)\r\nflags |= IORESOURCE_PREFETCH;\r\nreturn flags;\r\n}\r\nstatic unsigned long of_bus_sbus_get_flags(const u32 *addr, unsigned long flags)\r\n{\r\nreturn IORESOURCE_MEM;\r\n}\r\nstatic int of_bus_ambapp_match(struct device_node *np)\r\n{\r\nreturn !strcmp(np->type, "ambapp");\r\n}\r\nstatic void of_bus_ambapp_count_cells(struct device_node *child,\r\nint *addrc, int *sizec)\r\n{\r\nif (addrc)\r\n*addrc = 1;\r\nif (sizec)\r\n*sizec = 1;\r\n}\r\nstatic int of_bus_ambapp_map(u32 *addr, const u32 *range,\r\nint na, int ns, int pna)\r\n{\r\nreturn of_bus_default_map(addr, range, na, ns, pna);\r\n}\r\nstatic unsigned long of_bus_ambapp_get_flags(const u32 *addr,\r\nunsigned long flags)\r\n{\r\nreturn IORESOURCE_MEM;\r\n}\r\nstatic struct of_bus *of_match_bus(struct device_node *np)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(of_busses); i ++)\r\nif (!of_busses[i].match || of_busses[i].match(np))\r\nreturn &of_busses[i];\r\nBUG();\r\nreturn NULL;\r\n}\r\nstatic int __init build_one_resource(struct device_node *parent,\r\nstruct of_bus *bus,\r\nstruct of_bus *pbus,\r\nu32 *addr,\r\nint na, int ns, int pna)\r\n{\r\nconst u32 *ranges;\r\nunsigned int rlen;\r\nint rone;\r\nranges = of_get_property(parent, "ranges", &rlen);\r\nif (ranges == NULL || rlen == 0) {\r\nu32 result[OF_MAX_ADDR_CELLS];\r\nint i;\r\nmemset(result, 0, pna * 4);\r\nfor (i = 0; i < na; i++)\r\nresult[pna - 1 - i] =\r\naddr[na - 1 - i];\r\nmemcpy(addr, result, pna * 4);\r\nreturn 0;\r\n}\r\nrlen /= 4;\r\nrone = na + pna + ns;\r\nfor (; rlen >= rone; rlen -= rone, ranges += rone) {\r\nif (!bus->map(addr, ranges, na, ns, pna))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int __init use_1to1_mapping(struct device_node *pp)\r\n{\r\nif (of_find_property(pp, "ranges", NULL) != NULL)\r\nreturn 0;\r\nif (!strcmp(pp->name, "dma") ||\r\n!strcmp(pp->name, "espdma") ||\r\n!strcmp(pp->name, "ledma") ||\r\n!strcmp(pp->name, "lebuffer"))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void __init build_device_resources(struct platform_device *op,\r\nstruct device *parent)\r\n{\r\nstruct platform_device *p_op;\r\nstruct of_bus *bus;\r\nint na, ns;\r\nint index, num_reg;\r\nconst void *preg;\r\nif (!parent)\r\nreturn;\r\np_op = to_platform_device(parent);\r\nbus = of_match_bus(p_op->dev.of_node);\r\nbus->count_cells(op->dev.of_node, &na, &ns);\r\npreg = of_get_property(op->dev.of_node, bus->addr_prop_name, &num_reg);\r\nif (!preg || num_reg == 0)\r\nreturn;\r\nnum_reg /= 4;\r\nnum_reg /= na + ns;\r\nop->resource = op->archdata.resource;\r\nop->num_resources = num_reg;\r\nfor (index = 0; index < num_reg; index++) {\r\nstruct resource *r = &op->resource[index];\r\nu32 addr[OF_MAX_ADDR_CELLS];\r\nconst u32 *reg = (preg + (index * ((na + ns) * 4)));\r\nstruct device_node *dp = op->dev.of_node;\r\nstruct device_node *pp = p_op->dev.of_node;\r\nstruct of_bus *pbus, *dbus;\r\nu64 size, result = OF_BAD_ADDR;\r\nunsigned long flags;\r\nint dna, dns;\r\nint pna, pns;\r\nsize = of_read_addr(reg + na, ns);\r\nmemcpy(addr, reg, na * 4);\r\nflags = bus->get_flags(reg, 0);\r\nif (use_1to1_mapping(pp)) {\r\nresult = of_read_addr(addr, na);\r\ngoto build_res;\r\n}\r\ndna = na;\r\ndns = ns;\r\ndbus = bus;\r\nwhile (1) {\r\ndp = pp;\r\npp = dp->parent;\r\nif (!pp) {\r\nresult = of_read_addr(addr, dna);\r\nbreak;\r\n}\r\npbus = of_match_bus(pp);\r\npbus->count_cells(dp, &pna, &pns);\r\nif (build_one_resource(dp, dbus, pbus, addr,\r\ndna, dns, pna))\r\nbreak;\r\nflags = pbus->get_flags(addr, flags);\r\ndna = pna;\r\ndns = pns;\r\ndbus = pbus;\r\n}\r\nbuild_res:\r\nmemset(r, 0, sizeof(*r));\r\nif (of_resource_verbose)\r\nprintk("%s reg[%d] -> %llx\n",\r\nop->dev.of_node->full_name, index,\r\nresult);\r\nif (result != OF_BAD_ADDR) {\r\nr->start = result & 0xffffffff;\r\nr->end = result + size - 1;\r\nr->flags = flags | ((result >> 32ULL) & 0xffUL);\r\n}\r\nr->name = op->dev.of_node->name;\r\n}\r\n}\r\nstatic struct platform_device * __init scan_one_device(struct device_node *dp,\r\nstruct device *parent)\r\n{\r\nstruct platform_device *op = kzalloc(sizeof(*op), GFP_KERNEL);\r\nconst struct linux_prom_irqs *intr;\r\nstruct dev_archdata *sd;\r\nint len, i;\r\nif (!op)\r\nreturn NULL;\r\nsd = &op->dev.archdata;\r\nsd->op = op;\r\nop->dev.of_node = dp;\r\nintr = of_get_property(dp, "intr", &len);\r\nif (intr) {\r\nop->archdata.num_irqs = len / sizeof(struct linux_prom_irqs);\r\nfor (i = 0; i < op->archdata.num_irqs; i++)\r\nop->archdata.irqs[i] =\r\nsparc_irq_config.build_device_irq(op, intr[i].pri);\r\n} else {\r\nconst unsigned int *irq =\r\nof_get_property(dp, "interrupts", &len);\r\nif (irq) {\r\nop->archdata.num_irqs = len / sizeof(unsigned int);\r\nfor (i = 0; i < op->archdata.num_irqs; i++)\r\nop->archdata.irqs[i] =\r\nsparc_irq_config.build_device_irq(op, irq[i]);\r\n} else {\r\nop->archdata.num_irqs = 0;\r\n}\r\n}\r\nbuild_device_resources(op, parent);\r\nop->dev.parent = parent;\r\nop->dev.bus = &platform_bus_type;\r\nif (!parent)\r\ndev_set_name(&op->dev, "root");\r\nelse\r\ndev_set_name(&op->dev, "%08x", dp->phandle);\r\nif (of_device_register(op)) {\r\nprintk("%s: Could not register of device.\n",\r\ndp->full_name);\r\nkfree(op);\r\nop = NULL;\r\n}\r\nreturn op;\r\n}\r\nstatic void __init scan_tree(struct device_node *dp, struct device *parent)\r\n{\r\nwhile (dp) {\r\nstruct platform_device *op = scan_one_device(dp, parent);\r\nif (op)\r\nscan_tree(dp->child, &op->dev);\r\ndp = dp->sibling;\r\n}\r\n}\r\nstatic int __init scan_of_devices(void)\r\n{\r\nstruct device_node *root = of_find_node_by_path("/");\r\nstruct platform_device *parent;\r\nparent = scan_one_device(root, NULL);\r\nif (!parent)\r\nreturn 0;\r\nscan_tree(root->child, &parent->dev);\r\nreturn 0;\r\n}\r\nstatic int __init of_debug(char *str)\r\n{\r\nint val = 0;\r\nget_option(&str, &val);\r\nif (val & 1)\r\nof_resource_verbose = 1;\r\nreturn 1;\r\n}
