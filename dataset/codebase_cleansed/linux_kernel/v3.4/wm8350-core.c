static int wm8350_phys_read(struct wm8350 *wm8350, u8 reg, int num_regs,\r\nu16 *dest)\r\n{\r\nint i, ret;\r\nint bytes = num_regs * 2;\r\ndev_dbg(wm8350->dev, "volatile read\n");\r\nret = wm8350->read_dev(wm8350, reg, bytes, (char *)dest);\r\nfor (i = reg; i < reg + num_regs; i++) {\r\ndest[i - reg] = be16_to_cpu(dest[i - reg]);\r\ndest[i - reg] &= wm8350_reg_io_map[i].readable;\r\n}\r\ndump(num_regs, dest);\r\nreturn ret;\r\n}\r\nstatic int wm8350_read(struct wm8350 *wm8350, u8 reg, int num_regs, u16 *dest)\r\n{\r\nint i;\r\nint end = reg + num_regs;\r\nint ret = 0;\r\nint bytes = num_regs * 2;\r\nif (wm8350->read_dev == NULL)\r\nreturn -ENODEV;\r\nif ((reg + num_regs - 1) > WM8350_MAX_REGISTER) {\r\ndev_err(wm8350->dev, "invalid reg %x\n",\r\nreg + num_regs - 1);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(wm8350->dev,\r\n"%s R%d(0x%2.2x) %d regs\n", __func__, reg, reg, num_regs);\r\n#if WM8350_BUS_DEBUG\r\nfor (i = reg; i < end; i++) {\r\nif (!wm8350_reg_io_map[i].readable)\r\ndev_warn(wm8350->dev,\r\n"reg R%d is not readable\n", i);\r\n}\r\n#endif\r\nfor (i = reg; i < end; i++)\r\nif (wm8350_reg_io_map[i].vol)\r\nreturn wm8350_phys_read(wm8350, reg, num_regs, dest);\r\ndev_dbg(wm8350->dev, "cache read\n");\r\nmemcpy(dest, &wm8350->reg_cache[reg], bytes);\r\ndump(num_regs, dest);\r\nreturn ret;\r\n}\r\nstatic inline int is_reg_locked(struct wm8350 *wm8350, u8 reg)\r\n{\r\nif (reg == WM8350_SECURITY ||\r\nwm8350->reg_cache[WM8350_SECURITY] == WM8350_UNLOCK_KEY)\r\nreturn 0;\r\nif ((reg >= WM8350_GPIO_FUNCTION_SELECT_1 &&\r\nreg <= WM8350_GPIO_FUNCTION_SELECT_4) ||\r\n(reg >= WM8350_BATTERY_CHARGER_CONTROL_1 &&\r\nreg <= WM8350_BATTERY_CHARGER_CONTROL_3))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int wm8350_write(struct wm8350 *wm8350, u8 reg, int num_regs, u16 *src)\r\n{\r\nint i;\r\nint end = reg + num_regs;\r\nint bytes = num_regs * 2;\r\nif (wm8350->write_dev == NULL)\r\nreturn -ENODEV;\r\nif ((reg + num_regs - 1) > WM8350_MAX_REGISTER) {\r\ndev_err(wm8350->dev, "invalid reg %x\n",\r\nreg + num_regs - 1);\r\nreturn -EINVAL;\r\n}\r\nfor (i = reg; i < end; i++) {\r\nif (!wm8350_reg_io_map[i].writable) {\r\ndev_err(wm8350->dev,\r\n"attempted write to read only reg R%d\n", i);\r\nreturn -EINVAL;\r\n}\r\nif (is_reg_locked(wm8350, i)) {\r\ndev_err(wm8350->dev,\r\n"attempted write to locked reg R%d\n", i);\r\nreturn -EINVAL;\r\n}\r\nsrc[i - reg] &= wm8350_reg_io_map[i].writable;\r\nwm8350->reg_cache[i] =\r\n(wm8350->reg_cache[i] & ~wm8350_reg_io_map[i].writable)\r\n| src[i - reg];\r\nsrc[i - reg] = cpu_to_be16(src[i - reg]);\r\n}\r\nreturn wm8350->write_dev(wm8350, reg, bytes, (char *)src);\r\n}\r\nint wm8350_clear_bits(struct wm8350 *wm8350, u16 reg, u16 mask)\r\n{\r\nu16 data;\r\nint err;\r\nmutex_lock(&io_mutex);\r\nerr = wm8350_read(wm8350, reg, 1, &data);\r\nif (err) {\r\ndev_err(wm8350->dev, "read from reg R%d failed\n", reg);\r\ngoto out;\r\n}\r\ndata &= ~mask;\r\nerr = wm8350_write(wm8350, reg, 1, &data);\r\nif (err)\r\ndev_err(wm8350->dev, "write to reg R%d failed\n", reg);\r\nout:\r\nmutex_unlock(&io_mutex);\r\nreturn err;\r\n}\r\nint wm8350_set_bits(struct wm8350 *wm8350, u16 reg, u16 mask)\r\n{\r\nu16 data;\r\nint err;\r\nmutex_lock(&io_mutex);\r\nerr = wm8350_read(wm8350, reg, 1, &data);\r\nif (err) {\r\ndev_err(wm8350->dev, "read from reg R%d failed\n", reg);\r\ngoto out;\r\n}\r\ndata |= mask;\r\nerr = wm8350_write(wm8350, reg, 1, &data);\r\nif (err)\r\ndev_err(wm8350->dev, "write to reg R%d failed\n", reg);\r\nout:\r\nmutex_unlock(&io_mutex);\r\nreturn err;\r\n}\r\nu16 wm8350_reg_read(struct wm8350 *wm8350, int reg)\r\n{\r\nu16 data;\r\nint err;\r\nmutex_lock(&io_mutex);\r\nerr = wm8350_read(wm8350, reg, 1, &data);\r\nif (err)\r\ndev_err(wm8350->dev, "read from reg R%d failed\n", reg);\r\nmutex_unlock(&io_mutex);\r\nreturn data;\r\n}\r\nint wm8350_reg_write(struct wm8350 *wm8350, int reg, u16 val)\r\n{\r\nint ret;\r\nu16 data = val;\r\nmutex_lock(&io_mutex);\r\nret = wm8350_write(wm8350, reg, 1, &data);\r\nif (ret)\r\ndev_err(wm8350->dev, "write to reg R%d failed\n", reg);\r\nmutex_unlock(&io_mutex);\r\nreturn ret;\r\n}\r\nint wm8350_block_read(struct wm8350 *wm8350, int start_reg, int regs,\r\nu16 *dest)\r\n{\r\nint err = 0;\r\nmutex_lock(&io_mutex);\r\nerr = wm8350_read(wm8350, start_reg, regs, dest);\r\nif (err)\r\ndev_err(wm8350->dev, "block read starting from R%d failed\n",\r\nstart_reg);\r\nmutex_unlock(&io_mutex);\r\nreturn err;\r\n}\r\nint wm8350_block_write(struct wm8350 *wm8350, int start_reg, int regs,\r\nu16 *src)\r\n{\r\nint ret = 0;\r\nmutex_lock(&io_mutex);\r\nret = wm8350_write(wm8350, start_reg, regs, src);\r\nif (ret)\r\ndev_err(wm8350->dev, "block write starting at R%d failed\n",\r\nstart_reg);\r\nmutex_unlock(&io_mutex);\r\nreturn ret;\r\n}\r\nint wm8350_reg_lock(struct wm8350 *wm8350)\r\n{\r\nu16 key = WM8350_LOCK_KEY;\r\nint ret;\r\nldbg(__func__);\r\nmutex_lock(&io_mutex);\r\nret = wm8350_write(wm8350, WM8350_SECURITY, 1, &key);\r\nif (ret)\r\ndev_err(wm8350->dev, "lock failed\n");\r\nmutex_unlock(&io_mutex);\r\nreturn ret;\r\n}\r\nint wm8350_reg_unlock(struct wm8350 *wm8350)\r\n{\r\nu16 key = WM8350_UNLOCK_KEY;\r\nint ret;\r\nldbg(__func__);\r\nmutex_lock(&io_mutex);\r\nret = wm8350_write(wm8350, WM8350_SECURITY, 1, &key);\r\nif (ret)\r\ndev_err(wm8350->dev, "unlock failed\n");\r\nmutex_unlock(&io_mutex);\r\nreturn ret;\r\n}\r\nint wm8350_read_auxadc(struct wm8350 *wm8350, int channel, int scale, int vref)\r\n{\r\nu16 reg, result = 0;\r\nif (channel < WM8350_AUXADC_AUX1 || channel > WM8350_AUXADC_TEMP)\r\nreturn -EINVAL;\r\nif (channel >= WM8350_AUXADC_USB && channel <= WM8350_AUXADC_TEMP\r\n&& (scale != 0 || vref != 0))\r\nreturn -EINVAL;\r\nmutex_lock(&wm8350->auxadc_mutex);\r\nreg = wm8350_reg_read(wm8350, WM8350_POWER_MGMT_5);\r\nwm8350_reg_write(wm8350, WM8350_POWER_MGMT_5, reg | WM8350_AUXADC_ENA);\r\nif (scale || vref) {\r\nreg = scale << 13;\r\nreg |= vref << 12;\r\nwm8350_reg_write(wm8350, WM8350_AUX1_READBACK + channel, reg);\r\n}\r\nreg = wm8350_reg_read(wm8350, WM8350_DIGITISER_CONTROL_1);\r\nreg |= 1 << channel | WM8350_AUXADC_POLL;\r\nwm8350_reg_write(wm8350, WM8350_DIGITISER_CONTROL_1, reg);\r\ntry_wait_for_completion(&wm8350->auxadc_done);\r\nwait_for_completion_timeout(&wm8350->auxadc_done, msecs_to_jiffies(5));\r\nreg = wm8350_reg_read(wm8350, WM8350_DIGITISER_CONTROL_1);\r\nif (reg & WM8350_AUXADC_POLL)\r\ndev_err(wm8350->dev, "adc chn %d read timeout\n", channel);\r\nelse\r\nresult = wm8350_reg_read(wm8350,\r\nWM8350_AUX1_READBACK + channel);\r\nreg = wm8350_reg_read(wm8350, WM8350_POWER_MGMT_5);\r\nwm8350_reg_write(wm8350, WM8350_POWER_MGMT_5,\r\nreg & ~WM8350_AUXADC_ENA);\r\nmutex_unlock(&wm8350->auxadc_mutex);\r\nreturn result & WM8350_AUXADC_DATA1_MASK;\r\n}\r\nstatic irqreturn_t wm8350_auxadc_irq(int irq, void *irq_data)\r\n{\r\nstruct wm8350 *wm8350 = irq_data;\r\ncomplete(&wm8350->auxadc_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int wm8350_create_cache(struct wm8350 *wm8350, int type, int mode)\r\n{\r\nint i, ret = 0;\r\nu16 value;\r\nconst u16 *reg_map;\r\nswitch (type) {\r\ncase 0:\r\nswitch (mode) {\r\n#ifdef CONFIG_MFD_WM8350_CONFIG_MODE_0\r\ncase 0:\r\nreg_map = wm8350_mode0_defaults;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_MFD_WM8350_CONFIG_MODE_1\r\ncase 1:\r\nreg_map = wm8350_mode1_defaults;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_MFD_WM8350_CONFIG_MODE_2\r\ncase 2:\r\nreg_map = wm8350_mode2_defaults;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_MFD_WM8350_CONFIG_MODE_3\r\ncase 3:\r\nreg_map = wm8350_mode3_defaults;\r\nbreak;\r\n#endif\r\ndefault:\r\ndev_err(wm8350->dev,\r\n"WM8350 configuration mode %d not supported\n",\r\nmode);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase 1:\r\nswitch (mode) {\r\n#ifdef CONFIG_MFD_WM8351_CONFIG_MODE_0\r\ncase 0:\r\nreg_map = wm8351_mode0_defaults;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_MFD_WM8351_CONFIG_MODE_1\r\ncase 1:\r\nreg_map = wm8351_mode1_defaults;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_MFD_WM8351_CONFIG_MODE_2\r\ncase 2:\r\nreg_map = wm8351_mode2_defaults;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_MFD_WM8351_CONFIG_MODE_3\r\ncase 3:\r\nreg_map = wm8351_mode3_defaults;\r\nbreak;\r\n#endif\r\ndefault:\r\ndev_err(wm8350->dev,\r\n"WM8351 configuration mode %d not supported\n",\r\nmode);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase 2:\r\nswitch (mode) {\r\n#ifdef CONFIG_MFD_WM8352_CONFIG_MODE_0\r\ncase 0:\r\nreg_map = wm8352_mode0_defaults;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_MFD_WM8352_CONFIG_MODE_1\r\ncase 1:\r\nreg_map = wm8352_mode1_defaults;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_MFD_WM8352_CONFIG_MODE_2\r\ncase 2:\r\nreg_map = wm8352_mode2_defaults;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_MFD_WM8352_CONFIG_MODE_3\r\ncase 3:\r\nreg_map = wm8352_mode3_defaults;\r\nbreak;\r\n#endif\r\ndefault:\r\ndev_err(wm8350->dev,\r\n"WM8352 configuration mode %d not supported\n",\r\nmode);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(wm8350->dev,\r\n"WM835x configuration mode %d not supported\n",\r\nmode);\r\nreturn -EINVAL;\r\n}\r\nwm8350->reg_cache =\r\nkmalloc(sizeof(u16) * (WM8350_MAX_REGISTER + 1), GFP_KERNEL);\r\nif (wm8350->reg_cache == NULL)\r\nreturn -ENOMEM;\r\nret = wm8350->read_dev(wm8350, 0,\r\nsizeof(u16) * (WM8350_MAX_REGISTER + 1),\r\nwm8350->reg_cache);\r\nif (ret < 0) {\r\ndev_err(wm8350->dev,\r\n"failed to read initial cache values\n");\r\ngoto out;\r\n}\r\nfor (i = 0; i < WM8350_MAX_REGISTER; i++) {\r\nif (wm8350_reg_io_map[i].readable &&\r\n(i < WM8350_CLOCK_CONTROL_1 || i > WM8350_AIF_TEST)) {\r\nvalue = be16_to_cpu(wm8350->reg_cache[i]);\r\nvalue &= wm8350_reg_io_map[i].readable;\r\nwm8350->reg_cache[i] = value;\r\n} else\r\nwm8350->reg_cache[i] = reg_map[i];\r\n}\r\nout:\r\nkfree(wm8350->reg_cache);\r\nreturn ret;\r\n}\r\nstatic void wm8350_client_dev_register(struct wm8350 *wm8350,\r\nconst char *name,\r\nstruct platform_device **pdev)\r\n{\r\nint ret;\r\n*pdev = platform_device_alloc(name, -1);\r\nif (*pdev == NULL) {\r\ndev_err(wm8350->dev, "Failed to allocate %s\n", name);\r\nreturn;\r\n}\r\n(*pdev)->dev.parent = wm8350->dev;\r\nplatform_set_drvdata(*pdev, wm8350);\r\nret = platform_device_add(*pdev);\r\nif (ret != 0) {\r\ndev_err(wm8350->dev, "Failed to register %s: %d\n", name, ret);\r\nplatform_device_put(*pdev);\r\n*pdev = NULL;\r\n}\r\n}\r\nint wm8350_device_init(struct wm8350 *wm8350, int irq,\r\nstruct wm8350_platform_data *pdata)\r\n{\r\nint ret;\r\nu16 id1, id2, mask_rev;\r\nu16 cust_id, mode, chip_rev;\r\ndev_set_drvdata(wm8350->dev, wm8350);\r\nret = wm8350->read_dev(wm8350, WM8350_RESET_ID, sizeof(id1), &id1);\r\nif (ret != 0) {\r\ndev_err(wm8350->dev, "Failed to read ID: %d\n", ret);\r\ngoto err;\r\n}\r\nret = wm8350->read_dev(wm8350, WM8350_ID, sizeof(id2), &id2);\r\nif (ret != 0) {\r\ndev_err(wm8350->dev, "Failed to read ID: %d\n", ret);\r\ngoto err;\r\n}\r\nret = wm8350->read_dev(wm8350, WM8350_REVISION, sizeof(mask_rev),\r\n&mask_rev);\r\nif (ret != 0) {\r\ndev_err(wm8350->dev, "Failed to read revision: %d\n", ret);\r\ngoto err;\r\n}\r\nid1 = be16_to_cpu(id1);\r\nid2 = be16_to_cpu(id2);\r\nmask_rev = be16_to_cpu(mask_rev);\r\nif (id1 != 0x6143) {\r\ndev_err(wm8350->dev,\r\n"Device with ID %x is not a WM8350\n", id1);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nmode = id2 & WM8350_CONF_STS_MASK >> 10;\r\ncust_id = id2 & WM8350_CUST_ID_MASK;\r\nchip_rev = (id2 & WM8350_CHIP_REV_MASK) >> 12;\r\ndev_info(wm8350->dev,\r\n"CONF_STS %d, CUST_ID %d, MASK_REV %d, CHIP_REV %d\n",\r\nmode, cust_id, mask_rev, chip_rev);\r\nif (cust_id != 0) {\r\ndev_err(wm8350->dev, "Unsupported CUST_ID\n");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nswitch (mask_rev) {\r\ncase 0:\r\nwm8350->pmic.max_dcdc = WM8350_DCDC_6;\r\nwm8350->pmic.max_isink = WM8350_ISINK_B;\r\nswitch (chip_rev) {\r\ncase WM8350_REV_E:\r\ndev_info(wm8350->dev, "WM8350 Rev E\n");\r\nbreak;\r\ncase WM8350_REV_F:\r\ndev_info(wm8350->dev, "WM8350 Rev F\n");\r\nbreak;\r\ncase WM8350_REV_G:\r\ndev_info(wm8350->dev, "WM8350 Rev G\n");\r\nwm8350->power.rev_g_coeff = 1;\r\nbreak;\r\ncase WM8350_REV_H:\r\ndev_info(wm8350->dev, "WM8350 Rev H\n");\r\nwm8350->power.rev_g_coeff = 1;\r\nbreak;\r\ndefault:\r\ndev_err(wm8350->dev, "Unknown WM8350 CHIP_REV\n");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nbreak;\r\ncase 1:\r\nwm8350->pmic.max_dcdc = WM8350_DCDC_4;\r\nwm8350->pmic.max_isink = WM8350_ISINK_A;\r\nswitch (chip_rev) {\r\ncase 0:\r\ndev_info(wm8350->dev, "WM8351 Rev A\n");\r\nwm8350->power.rev_g_coeff = 1;\r\nbreak;\r\ncase 1:\r\ndev_info(wm8350->dev, "WM8351 Rev B\n");\r\nwm8350->power.rev_g_coeff = 1;\r\nbreak;\r\ndefault:\r\ndev_err(wm8350->dev, "Unknown WM8351 CHIP_REV\n");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nbreak;\r\ncase 2:\r\nwm8350->pmic.max_dcdc = WM8350_DCDC_6;\r\nwm8350->pmic.max_isink = WM8350_ISINK_B;\r\nswitch (chip_rev) {\r\ncase 0:\r\ndev_info(wm8350->dev, "WM8352 Rev A\n");\r\nwm8350->power.rev_g_coeff = 1;\r\nbreak;\r\ndefault:\r\ndev_err(wm8350->dev, "Unknown WM8352 CHIP_REV\n");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(wm8350->dev, "Unknown MASK_REV\n");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nret = wm8350_create_cache(wm8350, mask_rev, mode);\r\nif (ret < 0) {\r\ndev_err(wm8350->dev, "Failed to create register cache\n");\r\nreturn ret;\r\n}\r\nmutex_init(&wm8350->auxadc_mutex);\r\ninit_completion(&wm8350->auxadc_done);\r\nret = wm8350_irq_init(wm8350, irq, pdata);\r\nif (ret < 0)\r\ngoto err_free;\r\nif (wm8350->irq_base) {\r\nret = request_threaded_irq(wm8350->irq_base +\r\nWM8350_IRQ_AUXADC_DATARDY,\r\nNULL, wm8350_auxadc_irq, 0,\r\n"auxadc", wm8350);\r\nif (ret < 0)\r\ndev_warn(wm8350->dev,\r\n"Failed to request AUXADC IRQ: %d\n", ret);\r\n}\r\nif (pdata && pdata->init) {\r\nret = pdata->init(wm8350);\r\nif (ret != 0) {\r\ndev_err(wm8350->dev, "Platform init() failed: %d\n",\r\nret);\r\ngoto err_irq;\r\n}\r\n}\r\nwm8350_reg_write(wm8350, WM8350_SYSTEM_INTERRUPTS_MASK, 0x0);\r\nwm8350_client_dev_register(wm8350, "wm8350-codec",\r\n&(wm8350->codec.pdev));\r\nwm8350_client_dev_register(wm8350, "wm8350-gpio",\r\n&(wm8350->gpio.pdev));\r\nwm8350_client_dev_register(wm8350, "wm8350-hwmon",\r\n&(wm8350->hwmon.pdev));\r\nwm8350_client_dev_register(wm8350, "wm8350-power",\r\n&(wm8350->power.pdev));\r\nwm8350_client_dev_register(wm8350, "wm8350-rtc", &(wm8350->rtc.pdev));\r\nwm8350_client_dev_register(wm8350, "wm8350-wdt", &(wm8350->wdt.pdev));\r\nreturn 0;\r\nerr_irq:\r\nwm8350_irq_exit(wm8350);\r\nerr_free:\r\nkfree(wm8350->reg_cache);\r\nerr:\r\nreturn ret;\r\n}\r\nvoid wm8350_device_exit(struct wm8350 *wm8350)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(wm8350->pmic.led); i++)\r\nplatform_device_unregister(wm8350->pmic.led[i].pdev);\r\nfor (i = 0; i < ARRAY_SIZE(wm8350->pmic.pdev); i++)\r\nplatform_device_unregister(wm8350->pmic.pdev[i]);\r\nplatform_device_unregister(wm8350->wdt.pdev);\r\nplatform_device_unregister(wm8350->rtc.pdev);\r\nplatform_device_unregister(wm8350->power.pdev);\r\nplatform_device_unregister(wm8350->hwmon.pdev);\r\nplatform_device_unregister(wm8350->gpio.pdev);\r\nplatform_device_unregister(wm8350->codec.pdev);\r\nif (wm8350->irq_base)\r\nfree_irq(wm8350->irq_base + WM8350_IRQ_AUXADC_DATARDY, wm8350);\r\nwm8350_irq_exit(wm8350);\r\nkfree(wm8350->reg_cache);\r\n}
