static void kingsun_send_irq(struct urb *urb)\r\n{\r\nstruct kingsun_cb *kingsun = urb->context;\r\nstruct net_device *netdev = kingsun->netdev;\r\nif (!netif_running(kingsun->netdev)) {\r\nerr("kingsun_send_irq: Network not running!");\r\nreturn;\r\n}\r\nif (urb->status != 0) {\r\nerr("kingsun_send_irq: urb asynchronously failed - %d",\r\nurb->status);\r\n}\r\nnetif_wake_queue(netdev);\r\n}\r\nstatic netdev_tx_t kingsun_hard_xmit(struct sk_buff *skb,\r\nstruct net_device *netdev)\r\n{\r\nstruct kingsun_cb *kingsun;\r\nint wraplen;\r\nint ret = 0;\r\nnetif_stop_queue(netdev);\r\nSKB_LINEAR_ASSERT(skb);\r\nkingsun = netdev_priv(netdev);\r\nspin_lock(&kingsun->lock);\r\nwraplen = async_wrap_skb(skb,\r\nkingsun->out_buf,\r\nKINGSUN_FIFO_SIZE);\r\nusb_fill_int_urb(kingsun->tx_urb, kingsun->usbdev,\r\nusb_sndintpipe(kingsun->usbdev, kingsun->ep_out),\r\nkingsun->out_buf, wraplen, kingsun_send_irq,\r\nkingsun, 1);\r\nif ((ret = usb_submit_urb(kingsun->tx_urb, GFP_ATOMIC))) {\r\nerr("kingsun_hard_xmit: failed tx_urb submit: %d", ret);\r\nswitch (ret) {\r\ncase -ENODEV:\r\ncase -EPIPE:\r\nbreak;\r\ndefault:\r\nnetdev->stats.tx_errors++;\r\nnetif_start_queue(netdev);\r\n}\r\n} else {\r\nnetdev->stats.tx_packets++;\r\nnetdev->stats.tx_bytes += skb->len;\r\n}\r\ndev_kfree_skb(skb);\r\nspin_unlock(&kingsun->lock);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void kingsun_rcv_irq(struct urb *urb)\r\n{\r\nstruct kingsun_cb *kingsun = urb->context;\r\nint ret;\r\nif (!netif_running(kingsun->netdev)) {\r\nkingsun->receiving = 0;\r\nreturn;\r\n}\r\nif (urb->status != 0) {\r\nerr("kingsun_rcv_irq: urb asynchronously failed - %d",\r\nurb->status);\r\nkingsun->receiving = 0;\r\nreturn;\r\n}\r\nif (urb->actual_length == kingsun->max_rx) {\r\n__u8 *bytes = urb->transfer_buffer;\r\nint i;\r\nif (bytes[0] >= 1 && bytes[0] < kingsun->max_rx) {\r\nfor (i = 1; i <= bytes[0]; i++) {\r\nasync_unwrap_char(kingsun->netdev,\r\n&kingsun->netdev->stats,\r\n&kingsun->rx_buff, bytes[i]);\r\n}\r\ndo_gettimeofday(&kingsun->rx_time);\r\nkingsun->receiving =\r\n(kingsun->rx_buff.state != OUTSIDE_FRAME)\r\n? 1 : 0;\r\n}\r\n} else if (urb->actual_length > 0) {\r\nerr("%s(): Unexpected response length, expected %d got %d",\r\n__func__, kingsun->max_rx, urb->actual_length);\r\n}\r\nret = usb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\nstatic int kingsun_net_open(struct net_device *netdev)\r\n{\r\nstruct kingsun_cb *kingsun = netdev_priv(netdev);\r\nint err = -ENOMEM;\r\nchar hwname[16];\r\nkingsun->receiving = 0;\r\nkingsun->rx_buff.in_frame = FALSE;\r\nkingsun->rx_buff.state = OUTSIDE_FRAME;\r\nkingsun->rx_buff.truesize = IRDA_SKB_MAX_MTU;\r\nkingsun->rx_buff.skb = dev_alloc_skb(IRDA_SKB_MAX_MTU);\r\nif (!kingsun->rx_buff.skb)\r\ngoto free_mem;\r\nskb_reserve(kingsun->rx_buff.skb, 1);\r\nkingsun->rx_buff.head = kingsun->rx_buff.skb->data;\r\ndo_gettimeofday(&kingsun->rx_time);\r\nkingsun->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!kingsun->rx_urb)\r\ngoto free_mem;\r\nkingsun->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!kingsun->tx_urb)\r\ngoto free_mem;\r\nsprintf(hwname, "usb#%d", kingsun->usbdev->devnum);\r\nkingsun->irlap = irlap_open(netdev, &kingsun->qos, hwname);\r\nif (!kingsun->irlap) {\r\nerr("kingsun-sir: irlap_open failed");\r\ngoto free_mem;\r\n}\r\nusb_fill_int_urb(kingsun->rx_urb, kingsun->usbdev,\r\nusb_rcvintpipe(kingsun->usbdev, kingsun->ep_in),\r\nkingsun->in_buf, kingsun->max_rx,\r\nkingsun_rcv_irq, kingsun, 1);\r\nkingsun->rx_urb->status = 0;\r\nerr = usb_submit_urb(kingsun->rx_urb, GFP_KERNEL);\r\nif (err) {\r\nerr("kingsun-sir: first urb-submit failed: %d", err);\r\ngoto close_irlap;\r\n}\r\nnetif_start_queue(netdev);\r\nreturn 0;\r\nclose_irlap:\r\nirlap_close(kingsun->irlap);\r\nfree_mem:\r\nif (kingsun->tx_urb) {\r\nusb_free_urb(kingsun->tx_urb);\r\nkingsun->tx_urb = NULL;\r\n}\r\nif (kingsun->rx_urb) {\r\nusb_free_urb(kingsun->rx_urb);\r\nkingsun->rx_urb = NULL;\r\n}\r\nif (kingsun->rx_buff.skb) {\r\nkfree_skb(kingsun->rx_buff.skb);\r\nkingsun->rx_buff.skb = NULL;\r\nkingsun->rx_buff.head = NULL;\r\n}\r\nreturn err;\r\n}\r\nstatic int kingsun_net_close(struct net_device *netdev)\r\n{\r\nstruct kingsun_cb *kingsun = netdev_priv(netdev);\r\nnetif_stop_queue(netdev);\r\nusb_kill_urb(kingsun->tx_urb);\r\nusb_kill_urb(kingsun->rx_urb);\r\nusb_free_urb(kingsun->tx_urb);\r\nusb_free_urb(kingsun->rx_urb);\r\nkingsun->tx_urb = NULL;\r\nkingsun->rx_urb = NULL;\r\nkfree_skb(kingsun->rx_buff.skb);\r\nkingsun->rx_buff.skb = NULL;\r\nkingsun->rx_buff.head = NULL;\r\nkingsun->rx_buff.in_frame = FALSE;\r\nkingsun->rx_buff.state = OUTSIDE_FRAME;\r\nkingsun->receiving = 0;\r\nif (kingsun->irlap)\r\nirlap_close(kingsun->irlap);\r\nkingsun->irlap = NULL;\r\nreturn 0;\r\n}\r\nstatic int kingsun_net_ioctl(struct net_device *netdev, struct ifreq *rq,\r\nint cmd)\r\n{\r\nstruct if_irda_req *irq = (struct if_irda_req *) rq;\r\nstruct kingsun_cb *kingsun = netdev_priv(netdev);\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase SIOCSBANDWIDTH:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (netif_device_present(kingsun->netdev))\r\nret = -EOPNOTSUPP;\r\nbreak;\r\ncase SIOCSMEDIABUSY:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (netif_running(kingsun->netdev))\r\nirda_device_set_media_busy(kingsun->netdev, TRUE);\r\nbreak;\r\ncase SIOCGRECEIVING:\r\nirq->ifr_receiving = kingsun->receiving;\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic int kingsun_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_host_interface *interface;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nstruct kingsun_cb *kingsun = NULL;\r\nstruct net_device *net = NULL;\r\nint ret = -ENOMEM;\r\nint pipe, maxp_in, maxp_out;\r\n__u8 ep_in;\r\n__u8 ep_out;\r\ninterface = intf->cur_altsetting;\r\nif (interface->desc.bNumEndpoints != 2) {\r\nerr("kingsun-sir: expected 2 endpoints, found %d",\r\ninterface->desc.bNumEndpoints);\r\nreturn -ENODEV;\r\n}\r\nendpoint = &interface->endpoint[KINGSUN_EP_IN].desc;\r\nif (!usb_endpoint_is_int_in(endpoint)) {\r\nerr("kingsun-sir: endpoint 0 is not interrupt IN");\r\nreturn -ENODEV;\r\n}\r\nep_in = endpoint->bEndpointAddress;\r\npipe = usb_rcvintpipe(dev, ep_in);\r\nmaxp_in = usb_maxpacket(dev, pipe, usb_pipeout(pipe));\r\nif (maxp_in > 255 || maxp_in <= 1) {\r\nerr("%s: endpoint 0 has max packet size %d not in range",\r\n__FILE__, maxp_in);\r\nreturn -ENODEV;\r\n}\r\nendpoint = &interface->endpoint[KINGSUN_EP_OUT].desc;\r\nif (!usb_endpoint_is_int_out(endpoint)) {\r\nerr("kingsun-sir: endpoint 1 is not interrupt OUT");\r\nreturn -ENODEV;\r\n}\r\nep_out = endpoint->bEndpointAddress;\r\npipe = usb_sndintpipe(dev, ep_out);\r\nmaxp_out = usb_maxpacket(dev, pipe, usb_pipeout(pipe));\r\nnet = alloc_irdadev(sizeof(*kingsun));\r\nif(!net)\r\ngoto err_out1;\r\nSET_NETDEV_DEV(net, &intf->dev);\r\nkingsun = netdev_priv(net);\r\nkingsun->irlap = NULL;\r\nkingsun->tx_urb = NULL;\r\nkingsun->rx_urb = NULL;\r\nkingsun->ep_in = ep_in;\r\nkingsun->ep_out = ep_out;\r\nkingsun->in_buf = NULL;\r\nkingsun->out_buf = NULL;\r\nkingsun->max_rx = (__u8)maxp_in;\r\nkingsun->max_tx = (__u8)maxp_out;\r\nkingsun->netdev = net;\r\nkingsun->usbdev = dev;\r\nkingsun->rx_buff.in_frame = FALSE;\r\nkingsun->rx_buff.state = OUTSIDE_FRAME;\r\nkingsun->rx_buff.skb = NULL;\r\nkingsun->receiving = 0;\r\nspin_lock_init(&kingsun->lock);\r\nkingsun->in_buf = kmalloc(kingsun->max_rx, GFP_KERNEL);\r\nif (!kingsun->in_buf)\r\ngoto free_mem;\r\nkingsun->out_buf = kmalloc(KINGSUN_FIFO_SIZE, GFP_KERNEL);\r\nif (!kingsun->out_buf)\r\ngoto free_mem;\r\nprintk(KERN_INFO "KingSun/DonShine IRDA/USB found at address %d, "\r\n"Vendor: %x, Product: %x\n",\r\ndev->devnum, le16_to_cpu(dev->descriptor.idVendor),\r\nle16_to_cpu(dev->descriptor.idProduct));\r\nirda_init_max_qos_capabilies(&kingsun->qos);\r\nkingsun->qos.baud_rate.bits &= IR_9600;\r\nkingsun->qos.min_turn_time.bits &= KINGSUN_MTT;\r\nirda_qos_bits_to_value(&kingsun->qos);\r\nnet->netdev_ops = &kingsun_ops;\r\nret = register_netdev(net);\r\nif (ret != 0)\r\ngoto free_mem;\r\ndev_info(&net->dev, "IrDA: Registered KingSun/DonShine device %s\n",\r\nnet->name);\r\nusb_set_intfdata(intf, kingsun);\r\nreturn 0;\r\nfree_mem:\r\nif (kingsun->out_buf) kfree(kingsun->out_buf);\r\nif (kingsun->in_buf) kfree(kingsun->in_buf);\r\nfree_netdev(net);\r\nerr_out1:\r\nreturn ret;\r\n}\r\nstatic void kingsun_disconnect(struct usb_interface *intf)\r\n{\r\nstruct kingsun_cb *kingsun = usb_get_intfdata(intf);\r\nif (!kingsun)\r\nreturn;\r\nunregister_netdev(kingsun->netdev);\r\nif (kingsun->tx_urb != NULL) {\r\nusb_kill_urb(kingsun->tx_urb);\r\nusb_free_urb(kingsun->tx_urb);\r\nkingsun->tx_urb = NULL;\r\n}\r\nif (kingsun->rx_urb != NULL) {\r\nusb_kill_urb(kingsun->rx_urb);\r\nusb_free_urb(kingsun->rx_urb);\r\nkingsun->rx_urb = NULL;\r\n}\r\nkfree(kingsun->out_buf);\r\nkfree(kingsun->in_buf);\r\nfree_netdev(kingsun->netdev);\r\nusb_set_intfdata(intf, NULL);\r\n}\r\nstatic int kingsun_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct kingsun_cb *kingsun = usb_get_intfdata(intf);\r\nnetif_device_detach(kingsun->netdev);\r\nif (kingsun->tx_urb != NULL) usb_kill_urb(kingsun->tx_urb);\r\nif (kingsun->rx_urb != NULL) usb_kill_urb(kingsun->rx_urb);\r\nreturn 0;\r\n}\r\nstatic int kingsun_resume(struct usb_interface *intf)\r\n{\r\nstruct kingsun_cb *kingsun = usb_get_intfdata(intf);\r\nif (kingsun->rx_urb != NULL)\r\nusb_submit_urb(kingsun->rx_urb, GFP_KERNEL);\r\nnetif_device_attach(kingsun->netdev);\r\nreturn 0;\r\n}
