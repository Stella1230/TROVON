void ath9k_htc_beaconq_config(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_hw *ah = priv->ah;\r\nstruct ath9k_tx_queue_info qi, qi_be;\r\nmemset(&qi, 0, sizeof(struct ath9k_tx_queue_info));\r\nmemset(&qi_be, 0, sizeof(struct ath9k_tx_queue_info));\r\nath9k_hw_get_txq_props(ah, priv->beaconq, &qi);\r\nif (priv->ah->opmode == NL80211_IFTYPE_AP) {\r\nqi.tqi_aifs = 1;\r\nqi.tqi_cwmin = 0;\r\nqi.tqi_cwmax = 0;\r\n} else if (priv->ah->opmode == NL80211_IFTYPE_ADHOC) {\r\nint qnum = priv->hwq_map[WME_AC_BE];\r\nath9k_hw_get_txq_props(ah, qnum, &qi_be);\r\nqi.tqi_aifs = qi_be.tqi_aifs;\r\nif (ah->slottime == ATH9K_SLOT_TIME_20)\r\nqi.tqi_cwmin = 2*qi_be.tqi_cwmin;\r\nelse\r\nqi.tqi_cwmin = 4*qi_be.tqi_cwmin;\r\nqi.tqi_cwmax = qi_be.tqi_cwmax;\r\n}\r\nif (!ath9k_hw_set_txq_props(ah, priv->beaconq, &qi)) {\r\nath_err(ath9k_hw_common(ah),\r\n"Unable to update beacon queue %u!\n", priv->beaconq);\r\n} else {\r\nath9k_hw_resettxqueue(ah, priv->beaconq);\r\n}\r\n}\r\nstatic void ath9k_htc_beacon_config_sta(struct ath9k_htc_priv *priv,\r\nstruct htc_beacon_config *bss_conf)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_beacon_state bs;\r\nenum ath9k_int imask = 0;\r\nint dtimperiod, dtimcount, sleepduration;\r\nint cfpperiod, cfpcount, bmiss_timeout;\r\nu32 nexttbtt = 0, intval, tsftu;\r\n__be32 htc_imask = 0;\r\nu64 tsf;\r\nint num_beacons, offset, dtim_dec_count, cfp_dec_count;\r\nint ret __attribute__ ((unused));\r\nu8 cmd_rsp;\r\nmemset(&bs, 0, sizeof(bs));\r\nintval = bss_conf->beacon_interval;\r\nbmiss_timeout = (ATH_DEFAULT_BMISS_LIMIT * bss_conf->beacon_interval);\r\ndtimperiod = bss_conf->dtim_period;\r\nif (dtimperiod <= 0)\r\ndtimperiod = 1;\r\ndtimcount = 1;\r\nif (dtimcount >= dtimperiod)\r\ndtimcount = 0;\r\ncfpperiod = 1;\r\ncfpcount = 0;\r\nsleepduration = intval;\r\nif (sleepduration <= 0)\r\nsleepduration = intval;\r\ntsf = ath9k_hw_gettsf64(priv->ah);\r\ntsftu = TSF_TO_TU(tsf>>32, tsf) + FUDGE;\r\nnum_beacons = tsftu / intval + 1;\r\noffset = tsftu % intval;\r\nnexttbtt = tsftu - offset;\r\nif (offset)\r\nnexttbtt += intval;\r\ndtim_dec_count = num_beacons % dtimperiod;\r\ncfp_dec_count = (num_beacons / dtimperiod) % cfpperiod;\r\nif (dtim_dec_count)\r\ncfp_dec_count++;\r\ndtimcount -= dtim_dec_count;\r\nif (dtimcount < 0)\r\ndtimcount += dtimperiod;\r\ncfpcount -= cfp_dec_count;\r\nif (cfpcount < 0)\r\ncfpcount += cfpperiod;\r\nbs.bs_intval = intval;\r\nbs.bs_nexttbtt = nexttbtt;\r\nbs.bs_dtimperiod = dtimperiod*intval;\r\nbs.bs_nextdtim = bs.bs_nexttbtt + dtimcount*intval;\r\nbs.bs_cfpperiod = cfpperiod*bs.bs_dtimperiod;\r\nbs.bs_cfpnext = bs.bs_nextdtim + cfpcount*bs.bs_dtimperiod;\r\nbs.bs_cfpmaxduration = 0;\r\nif (sleepduration > intval) {\r\nbs.bs_bmissthreshold = ATH_DEFAULT_BMISS_LIMIT / 2;\r\n} else {\r\nbs.bs_bmissthreshold = DIV_ROUND_UP(bmiss_timeout, intval);\r\nif (bs.bs_bmissthreshold > 15)\r\nbs.bs_bmissthreshold = 15;\r\nelse if (bs.bs_bmissthreshold <= 0)\r\nbs.bs_bmissthreshold = 1;\r\n}\r\nbs.bs_sleepduration = roundup(IEEE80211_MS_TO_TU(100), sleepduration);\r\nif (bs.bs_sleepduration > bs.bs_dtimperiod)\r\nbs.bs_sleepduration = bs.bs_dtimperiod;\r\nbs.bs_tsfoor_threshold = ATH9K_TSFOOR_THRESHOLD;\r\nath_dbg(common, CONFIG, "intval: %u tsf: %llu tsftu: %u\n",\r\nintval, tsf, tsftu);\r\nath_dbg(common, CONFIG,\r\n"bmiss: %u sleep: %u cfp-period: %u maxdur: %u next: %u\n",\r\nbs.bs_bmissthreshold, bs.bs_sleepduration,\r\nbs.bs_cfpperiod, bs.bs_cfpmaxduration, bs.bs_cfpnext);\r\nWMI_CMD(WMI_DISABLE_INTR_CMDID);\r\nath9k_hw_set_sta_beacon_timers(priv->ah, &bs);\r\nimask |= ATH9K_INT_BMISS;\r\nhtc_imask = cpu_to_be32(imask);\r\nWMI_CMD_BUF(WMI_ENABLE_INTR_CMDID, &htc_imask);\r\n}\r\nstatic void ath9k_htc_beacon_config_ap(struct ath9k_htc_priv *priv,\r\nstruct htc_beacon_config *bss_conf)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nenum ath9k_int imask = 0;\r\nu32 nexttbtt, intval, tsftu;\r\n__be32 htc_imask = 0;\r\nint ret __attribute__ ((unused));\r\nu8 cmd_rsp;\r\nu64 tsf;\r\nintval = bss_conf->beacon_interval;\r\nintval /= ATH9K_HTC_MAX_BCN_VIF;\r\nnexttbtt = intval;\r\nif (intval > DEFAULT_SWBA_RESPONSE)\r\npriv->ah->config.sw_beacon_response_time = DEFAULT_SWBA_RESPONSE;\r\nelse\r\npriv->ah->config.sw_beacon_response_time = MIN_SWBA_RESPONSE;\r\nif (priv->op_flags & OP_TSF_RESET) {\r\nath9k_hw_reset_tsf(priv->ah);\r\npriv->op_flags &= ~OP_TSF_RESET;\r\n} else {\r\ntsf = ath9k_hw_gettsf64(priv->ah);\r\ntsftu = TSF_TO_TU(tsf >> 32, tsf) + FUDGE;\r\ndo {\r\nnexttbtt += intval;\r\n} while (nexttbtt < tsftu);\r\n}\r\nif (priv->op_flags & OP_ENABLE_BEACON)\r\nimask |= ATH9K_INT_SWBA;\r\nath_dbg(common, CONFIG,\r\n"AP Beacon config, intval: %d, nexttbtt: %u, resp_time: %d imask: 0x%x\n",\r\nbss_conf->beacon_interval, nexttbtt,\r\npriv->ah->config.sw_beacon_response_time, imask);\r\nath9k_htc_beaconq_config(priv);\r\nWMI_CMD(WMI_DISABLE_INTR_CMDID);\r\nath9k_hw_beaconinit(priv->ah, TU_TO_USEC(nexttbtt), TU_TO_USEC(intval));\r\npriv->cur_beacon_conf.bmiss_cnt = 0;\r\nhtc_imask = cpu_to_be32(imask);\r\nWMI_CMD_BUF(WMI_ENABLE_INTR_CMDID, &htc_imask);\r\n}\r\nstatic void ath9k_htc_beacon_config_adhoc(struct ath9k_htc_priv *priv,\r\nstruct htc_beacon_config *bss_conf)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nenum ath9k_int imask = 0;\r\nu32 nexttbtt, intval, tsftu;\r\n__be32 htc_imask = 0;\r\nint ret __attribute__ ((unused));\r\nu8 cmd_rsp;\r\nu64 tsf;\r\nintval = bss_conf->beacon_interval;\r\nnexttbtt = intval;\r\ntsf = ath9k_hw_gettsf64(priv->ah);\r\ntsftu = TSF_TO_TU(tsf >> 32, tsf) + FUDGE;\r\ndo {\r\nnexttbtt += intval;\r\n} while (nexttbtt < tsftu);\r\nif (intval > DEFAULT_SWBA_RESPONSE)\r\npriv->ah->config.sw_beacon_response_time = DEFAULT_SWBA_RESPONSE;\r\nelse\r\npriv->ah->config.sw_beacon_response_time = MIN_SWBA_RESPONSE;\r\nif (priv->op_flags & OP_ENABLE_BEACON)\r\nimask |= ATH9K_INT_SWBA;\r\nath_dbg(common, CONFIG,\r\n"IBSS Beacon config, intval: %d, nexttbtt: %u, resp_time: %d, imask: 0x%x\n",\r\nbss_conf->beacon_interval, nexttbtt,\r\npriv->ah->config.sw_beacon_response_time, imask);\r\nWMI_CMD(WMI_DISABLE_INTR_CMDID);\r\nath9k_hw_beaconinit(priv->ah, TU_TO_USEC(nexttbtt), TU_TO_USEC(intval));\r\npriv->cur_beacon_conf.bmiss_cnt = 0;\r\nhtc_imask = cpu_to_be32(imask);\r\nWMI_CMD_BUF(WMI_ENABLE_INTR_CMDID, &htc_imask);\r\n}\r\nvoid ath9k_htc_beaconep(void *drv_priv, struct sk_buff *skb,\r\nenum htc_endpoint_id ep_id, bool txok)\r\n{\r\ndev_kfree_skb_any(skb);\r\n}\r\nstatic void ath9k_htc_send_buffered(struct ath9k_htc_priv *priv,\r\nint slot)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ieee80211_vif *vif;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_hdr *hdr;\r\nint padpos, padsize, ret, tx_slot;\r\nspin_lock_bh(&priv->beacon_lock);\r\nvif = priv->cur_beacon_conf.bslot[slot];\r\nskb = ieee80211_get_buffered_bc(priv->hw, vif);\r\nwhile(skb) {\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\npadpos = ath9k_cmn_padpos(hdr->frame_control);\r\npadsize = padpos & 3;\r\nif (padsize && skb->len > padpos) {\r\nif (skb_headroom(skb) < padsize) {\r\ndev_kfree_skb_any(skb);\r\ngoto next;\r\n}\r\nskb_push(skb, padsize);\r\nmemmove(skb->data, skb->data + padsize, padpos);\r\n}\r\ntx_slot = ath9k_htc_tx_get_slot(priv);\r\nif (tx_slot < 0) {\r\nath_dbg(common, XMIT, "No free CAB slot\n");\r\ndev_kfree_skb_any(skb);\r\ngoto next;\r\n}\r\nret = ath9k_htc_tx_start(priv, skb, tx_slot, true);\r\nif (ret != 0) {\r\nath9k_htc_tx_clear_slot(priv, tx_slot);\r\ndev_kfree_skb_any(skb);\r\nath_dbg(common, XMIT, "Failed to send CAB frame\n");\r\n} else {\r\nspin_lock_bh(&priv->tx.tx_lock);\r\npriv->tx.queued_cnt++;\r\nspin_unlock_bh(&priv->tx.tx_lock);\r\n}\r\nnext:\r\nskb = ieee80211_get_buffered_bc(priv->hw, vif);\r\n}\r\nspin_unlock_bh(&priv->beacon_lock);\r\n}\r\nstatic void ath9k_htc_send_beacon(struct ath9k_htc_priv *priv,\r\nint slot)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ieee80211_vif *vif;\r\nstruct ath9k_htc_vif *avp;\r\nstruct tx_beacon_header beacon_hdr;\r\nstruct ath9k_htc_tx_ctl *tx_ctl;\r\nstruct ieee80211_tx_info *info;\r\nstruct ieee80211_mgmt *mgmt;\r\nstruct sk_buff *beacon;\r\nu8 *tx_fhdr;\r\nint ret;\r\nmemset(&beacon_hdr, 0, sizeof(struct tx_beacon_header));\r\nspin_lock_bh(&priv->beacon_lock);\r\nvif = priv->cur_beacon_conf.bslot[slot];\r\navp = (struct ath9k_htc_vif *)vif->drv_priv;\r\nif (unlikely(priv->op_flags & OP_SCANNING)) {\r\nspin_unlock_bh(&priv->beacon_lock);\r\nreturn;\r\n}\r\nbeacon = ieee80211_beacon_get(priv->hw, vif);\r\nif (!beacon) {\r\nspin_unlock_bh(&priv->beacon_lock);\r\nreturn;\r\n}\r\nmgmt = (struct ieee80211_mgmt *)beacon->data;\r\nmgmt->u.beacon.timestamp = avp->tsfadjust;\r\ninfo = IEEE80211_SKB_CB(beacon);\r\nif (info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ) {\r\nstruct ieee80211_hdr *hdr =\r\n(struct ieee80211_hdr *) beacon->data;\r\navp->seq_no += 0x10;\r\nhdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);\r\nhdr->seq_ctrl |= cpu_to_le16(avp->seq_no);\r\n}\r\ntx_ctl = HTC_SKB_CB(beacon);\r\nmemset(tx_ctl, 0, sizeof(*tx_ctl));\r\ntx_ctl->type = ATH9K_HTC_BEACON;\r\ntx_ctl->epid = priv->beacon_ep;\r\nbeacon_hdr.vif_index = avp->index;\r\ntx_fhdr = skb_push(beacon, sizeof(beacon_hdr));\r\nmemcpy(tx_fhdr, (u8 *) &beacon_hdr, sizeof(beacon_hdr));\r\nret = htc_send(priv->htc, beacon);\r\nif (ret != 0) {\r\nif (ret == -ENOMEM) {\r\nath_dbg(common, BSTUCK,\r\n"Failed to send beacon, no free TX buffer\n");\r\n}\r\ndev_kfree_skb_any(beacon);\r\n}\r\nspin_unlock_bh(&priv->beacon_lock);\r\n}\r\nstatic int ath9k_htc_choose_bslot(struct ath9k_htc_priv *priv,\r\nstruct wmi_event_swba *swba)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nu64 tsf;\r\nu32 tsftu;\r\nu16 intval;\r\nint slot;\r\nintval = priv->cur_beacon_conf.beacon_interval;\r\ntsf = be64_to_cpu(swba->tsf);\r\ntsftu = TSF_TO_TU(tsf >> 32, tsf);\r\nslot = ((tsftu % intval) * ATH9K_HTC_MAX_BCN_VIF) / intval;\r\nslot = ATH9K_HTC_MAX_BCN_VIF - slot - 1;\r\nath_dbg(common, BEACON,\r\n"Choose slot: %d, tsf: %llu, tsftu: %u, intval: %u\n",\r\nslot, tsf, tsftu, intval);\r\nreturn slot;\r\n}\r\nvoid ath9k_htc_swba(struct ath9k_htc_priv *priv,\r\nstruct wmi_event_swba *swba)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nint slot;\r\nif (swba->beacon_pending != 0) {\r\npriv->cur_beacon_conf.bmiss_cnt++;\r\nif (priv->cur_beacon_conf.bmiss_cnt > BSTUCK_THRESHOLD) {\r\nath_dbg(common, BSTUCK, "Beacon stuck, HW reset\n");\r\nieee80211_queue_work(priv->hw,\r\n&priv->fatal_work);\r\n}\r\nreturn;\r\n}\r\nif (priv->cur_beacon_conf.bmiss_cnt) {\r\nath_dbg(common, BSTUCK,\r\n"Resuming beacon xmit after %u misses\n",\r\npriv->cur_beacon_conf.bmiss_cnt);\r\npriv->cur_beacon_conf.bmiss_cnt = 0;\r\n}\r\nslot = ath9k_htc_choose_bslot(priv, swba);\r\nspin_lock_bh(&priv->beacon_lock);\r\nif (priv->cur_beacon_conf.bslot[slot] == NULL) {\r\nspin_unlock_bh(&priv->beacon_lock);\r\nreturn;\r\n}\r\nspin_unlock_bh(&priv->beacon_lock);\r\nath9k_htc_send_buffered(priv, slot);\r\nath9k_htc_send_beacon(priv, slot);\r\n}\r\nvoid ath9k_htc_assign_bslot(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_htc_vif *avp = (struct ath9k_htc_vif *)vif->drv_priv;\r\nint i = 0;\r\nspin_lock_bh(&priv->beacon_lock);\r\nfor (i = 0; i < ATH9K_HTC_MAX_BCN_VIF; i++) {\r\nif (priv->cur_beacon_conf.bslot[i] == NULL) {\r\navp->bslot = i;\r\nbreak;\r\n}\r\n}\r\npriv->cur_beacon_conf.bslot[avp->bslot] = vif;\r\nspin_unlock_bh(&priv->beacon_lock);\r\nath_dbg(common, CONFIG, "Added interface at beacon slot: %d\n",\r\navp->bslot);\r\n}\r\nvoid ath9k_htc_remove_bslot(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_htc_vif *avp = (struct ath9k_htc_vif *)vif->drv_priv;\r\nspin_lock_bh(&priv->beacon_lock);\r\npriv->cur_beacon_conf.bslot[avp->bslot] = NULL;\r\nspin_unlock_bh(&priv->beacon_lock);\r\nath_dbg(common, CONFIG, "Removed interface at beacon slot: %d\n",\r\navp->bslot);\r\n}\r\nvoid ath9k_htc_set_tsfadjust(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_htc_vif *avp = (struct ath9k_htc_vif *)vif->drv_priv;\r\nstruct htc_beacon_config *cur_conf = &priv->cur_beacon_conf;\r\nu64 tsfadjust;\r\nif (avp->bslot == 0)\r\nreturn;\r\ntsfadjust = cur_conf->beacon_interval * avp->bslot / ATH9K_HTC_MAX_BCN_VIF;\r\navp->tsfadjust = cpu_to_le64(TU_TO_USEC(tsfadjust));\r\nath_dbg(common, CONFIG, "tsfadjust is: %llu for bslot: %d\n",\r\n(unsigned long long)tsfadjust, avp->bslot);\r\n}\r\nstatic void ath9k_htc_beacon_iter(void *data, u8 *mac, struct ieee80211_vif *vif)\r\n{\r\nbool *beacon_configured = (bool *)data;\r\nstruct ath9k_htc_vif *avp = (struct ath9k_htc_vif *) vif->drv_priv;\r\nif (vif->type == NL80211_IFTYPE_STATION &&\r\navp->beacon_configured)\r\n*beacon_configured = true;\r\n}\r\nstatic bool ath9k_htc_check_beacon_config(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct htc_beacon_config *cur_conf = &priv->cur_beacon_conf;\r\nstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\r\nbool beacon_configured;\r\nif ((priv->ah->opmode == NL80211_IFTYPE_AP) &&\r\n(priv->num_ap_vif > 1) &&\r\n(vif->type == NL80211_IFTYPE_AP) &&\r\n(cur_conf->beacon_interval != bss_conf->beacon_int)) {\r\nath_dbg(common, CONFIG,\r\n"Changing beacon interval of multiple AP interfaces !\n");\r\nreturn false;\r\n}\r\nif (priv->num_ap_vif &&\r\n(vif->type != NL80211_IFTYPE_AP)) {\r\nath_dbg(common, CONFIG,\r\n"HW in AP mode, cannot set STA beacon parameters\n");\r\nreturn false;\r\n}\r\nif ((priv->ah->opmode == NL80211_IFTYPE_STATION) &&\r\n(priv->num_sta_vif > 1) &&\r\n(vif->type == NL80211_IFTYPE_STATION)) {\r\nbeacon_configured = false;\r\nieee80211_iterate_active_interfaces_atomic(priv->hw,\r\nath9k_htc_beacon_iter,\r\n&beacon_configured);\r\nif (beacon_configured) {\r\nath_dbg(common, CONFIG,\r\n"Beacon already configured for a station interface\n");\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nvoid ath9k_htc_beacon_config(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct htc_beacon_config *cur_conf = &priv->cur_beacon_conf;\r\nstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\r\nstruct ath9k_htc_vif *avp = (struct ath9k_htc_vif *) vif->drv_priv;\r\nif (!ath9k_htc_check_beacon_config(priv, vif))\r\nreturn;\r\ncur_conf->beacon_interval = bss_conf->beacon_int;\r\nif (cur_conf->beacon_interval == 0)\r\ncur_conf->beacon_interval = 100;\r\ncur_conf->dtim_period = bss_conf->dtim_period;\r\ncur_conf->bmiss_timeout =\r\nATH_DEFAULT_BMISS_LIMIT * cur_conf->beacon_interval;\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_STATION:\r\nath9k_htc_beacon_config_sta(priv, cur_conf);\r\navp->beacon_configured = true;\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nath9k_htc_beacon_config_adhoc(priv, cur_conf);\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\nath9k_htc_beacon_config_ap(priv, cur_conf);\r\nbreak;\r\ndefault:\r\nath_dbg(common, CONFIG, "Unsupported beaconing mode\n");\r\nreturn;\r\n}\r\n}\r\nvoid ath9k_htc_beacon_reconfig(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct htc_beacon_config *cur_conf = &priv->cur_beacon_conf;\r\nswitch (priv->ah->opmode) {\r\ncase NL80211_IFTYPE_STATION:\r\nath9k_htc_beacon_config_sta(priv, cur_conf);\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nath9k_htc_beacon_config_adhoc(priv, cur_conf);\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\nath9k_htc_beacon_config_ap(priv, cur_conf);\r\nbreak;\r\ndefault:\r\nath_dbg(common, CONFIG, "Unsupported beaconing mode\n");\r\nreturn;\r\n}\r\n}
