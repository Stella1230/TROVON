static inline bool is_wwr_sku(u16 regd)\r\n{\r\nreturn ((regd & COUNTRY_ERD_FLAG) != COUNTRY_ERD_FLAG) &&\r\n(((regd & WORLD_SKU_MASK) == WORLD_SKU_PREFIX) ||\r\n(regd == WORLD));\r\n}\r\nstatic u16 ath_regd_get_eepromRD(struct ath_regulatory *reg)\r\n{\r\nreturn reg->current_rd & ~WORLDWIDE_ROAMING_FLAG;\r\n}\r\nbool ath_is_world_regd(struct ath_regulatory *reg)\r\n{\r\nreturn is_wwr_sku(ath_regd_get_eepromRD(reg));\r\n}\r\nstatic const struct ieee80211_regdomain *ath_default_world_regdomain(void)\r\n{\r\nreturn &ath_world_regdom_64;\r\n}\r\nstatic const struct\r\nieee80211_regdomain *ath_world_regdomain(struct ath_regulatory *reg)\r\n{\r\nswitch (reg->regpair->regDmnEnum) {\r\ncase 0x60:\r\ncase 0x61:\r\ncase 0x62:\r\nreturn &ath_world_regdom_60_61_62;\r\ncase 0x63:\r\ncase 0x65:\r\nreturn &ath_world_regdom_63_65;\r\ncase 0x64:\r\nreturn &ath_world_regdom_64;\r\ncase 0x66:\r\ncase 0x69:\r\nreturn &ath_world_regdom_66_69;\r\ncase 0x67:\r\ncase 0x68:\r\ncase 0x6A:\r\ncase 0x6C:\r\nreturn &ath_world_regdom_67_68_6A_6C;\r\ndefault:\r\nWARN_ON(1);\r\nreturn ath_default_world_regdomain();\r\n}\r\n}\r\nbool ath_is_49ghz_allowed(u16 regdomain)\r\n{\r\nreturn regdomain == MKK9_MKKC;\r\n}\r\nstatic bool ath_is_radar_freq(u16 center_freq)\r\n{\r\nreturn (center_freq >= 5260 && center_freq <= 5700);\r\n}\r\nstatic void\r\nath_reg_apply_beaconing_flags(struct wiphy *wiphy,\r\nenum nl80211_reg_initiator initiator)\r\n{\r\nenum ieee80211_band band;\r\nstruct ieee80211_supported_band *sband;\r\nconst struct ieee80211_reg_rule *reg_rule;\r\nstruct ieee80211_channel *ch;\r\nunsigned int i;\r\nu32 bandwidth = 0;\r\nint r;\r\nfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\r\nif (!wiphy->bands[band])\r\ncontinue;\r\nsband = wiphy->bands[band];\r\nfor (i = 0; i < sband->n_channels; i++) {\r\nch = &sband->channels[i];\r\nif (ath_is_radar_freq(ch->center_freq) ||\r\n(ch->flags & IEEE80211_CHAN_RADAR))\r\ncontinue;\r\nif (initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE) {\r\nr = freq_reg_info(wiphy,\r\nch->center_freq,\r\nbandwidth,\r\n&reg_rule);\r\nif (r)\r\ncontinue;\r\nif (!(reg_rule->flags &\r\nNL80211_RRF_NO_IBSS))\r\nch->flags &=\r\n~IEEE80211_CHAN_NO_IBSS;\r\nif (!(reg_rule->flags &\r\nNL80211_RRF_PASSIVE_SCAN))\r\nch->flags &=\r\n~IEEE80211_CHAN_PASSIVE_SCAN;\r\n} else {\r\nif (ch->beacon_found)\r\nch->flags &= ~(IEEE80211_CHAN_NO_IBSS |\r\nIEEE80211_CHAN_PASSIVE_SCAN);\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\nath_reg_apply_active_scan_flags(struct wiphy *wiphy,\r\nenum nl80211_reg_initiator initiator)\r\n{\r\nstruct ieee80211_supported_band *sband;\r\nstruct ieee80211_channel *ch;\r\nconst struct ieee80211_reg_rule *reg_rule;\r\nu32 bandwidth = 0;\r\nint r;\r\nsband = wiphy->bands[IEEE80211_BAND_2GHZ];\r\nif (!sband)\r\nreturn;\r\nif (initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE) {\r\nch = &sband->channels[11];\r\nif (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)\r\nch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;\r\nch = &sband->channels[12];\r\nif (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)\r\nch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;\r\nreturn;\r\n}\r\nch = &sband->channels[11];\r\nr = freq_reg_info(wiphy, ch->center_freq, bandwidth, &reg_rule);\r\nif (!r) {\r\nif (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))\r\nif (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)\r\nch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;\r\n}\r\nch = &sband->channels[12];\r\nr = freq_reg_info(wiphy, ch->center_freq, bandwidth, &reg_rule);\r\nif (!r) {\r\nif (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))\r\nif (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)\r\nch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;\r\n}\r\n}\r\nstatic void ath_reg_apply_radar_flags(struct wiphy *wiphy)\r\n{\r\nstruct ieee80211_supported_band *sband;\r\nstruct ieee80211_channel *ch;\r\nunsigned int i;\r\nif (!wiphy->bands[IEEE80211_BAND_5GHZ])\r\nreturn;\r\nsband = wiphy->bands[IEEE80211_BAND_5GHZ];\r\nfor (i = 0; i < sband->n_channels; i++) {\r\nch = &sband->channels[i];\r\nif (!ath_is_radar_freq(ch->center_freq))\r\ncontinue;\r\nif (!(ch->flags & IEEE80211_CHAN_DISABLED))\r\nch->flags |= IEEE80211_CHAN_RADAR |\r\nIEEE80211_CHAN_NO_IBSS |\r\nIEEE80211_CHAN_PASSIVE_SCAN;\r\n}\r\n}\r\nstatic void ath_reg_apply_world_flags(struct wiphy *wiphy,\r\nenum nl80211_reg_initiator initiator,\r\nstruct ath_regulatory *reg)\r\n{\r\nswitch (reg->regpair->regDmnEnum) {\r\ncase 0x60:\r\ncase 0x63:\r\ncase 0x66:\r\ncase 0x67:\r\ncase 0x6C:\r\nath_reg_apply_beaconing_flags(wiphy, initiator);\r\nbreak;\r\ncase 0x68:\r\nath_reg_apply_beaconing_flags(wiphy, initiator);\r\nath_reg_apply_active_scan_flags(wiphy, initiator);\r\nbreak;\r\n}\r\n}\r\nstatic u16 ath_regd_find_country_by_name(char *alpha2)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(allCountries); i++) {\r\nif (!memcmp(allCountries[i].isoName, alpha2, 2))\r\nreturn allCountries[i].countryCode;\r\n}\r\nreturn -1;\r\n}\r\nint ath_reg_notifier_apply(struct wiphy *wiphy,\r\nstruct regulatory_request *request,\r\nstruct ath_regulatory *reg)\r\n{\r\nstruct ath_common *common = container_of(reg, struct ath_common,\r\nregulatory);\r\nu16 country_code;\r\nath_reg_apply_radar_flags(wiphy);\r\nif (!request)\r\nreturn 0;\r\nswitch (request->initiator) {\r\ncase NL80211_REGDOM_SET_BY_CORE:\r\nif (!ath_is_world_regd(&common->reg_world_copy))\r\nbreak;\r\nmemcpy(reg, &common->reg_world_copy,\r\nsizeof(struct ath_regulatory));\r\nbreak;\r\ncase NL80211_REGDOM_SET_BY_DRIVER:\r\ncase NL80211_REGDOM_SET_BY_USER:\r\nbreak;\r\ncase NL80211_REGDOM_SET_BY_COUNTRY_IE:\r\nif (!ath_is_world_regd(reg))\r\nbreak;\r\ncountry_code = ath_regd_find_country_by_name(request->alpha2);\r\nif (country_code == (u16) -1)\r\nbreak;\r\nreg->current_rd = COUNTRY_ERD_FLAG;\r\nreg->current_rd |= country_code;\r\nprintk(KERN_DEBUG "ath: regdomain 0x%0x updated by CountryIE\n",\r\nreg->current_rd);\r\n__ath_regd_init(reg);\r\nath_reg_apply_world_flags(wiphy, request->initiator, reg);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool ath_regd_is_eeprom_valid(struct ath_regulatory *reg)\r\n{\r\nu16 rd = ath_regd_get_eepromRD(reg);\r\nint i;\r\nif (rd & COUNTRY_ERD_FLAG) {\r\nu16 cc = rd & ~COUNTRY_ERD_FLAG;\r\nprintk(KERN_DEBUG\r\n"ath: EEPROM indicates we should expect "\r\n"a country code\n");\r\nfor (i = 0; i < ARRAY_SIZE(allCountries); i++)\r\nif (allCountries[i].countryCode == cc)\r\nreturn true;\r\n} else {\r\nif (rd != CTRY_DEFAULT)\r\nprintk(KERN_DEBUG "ath: EEPROM indicates we "\r\n"should expect a direct regpair map\n");\r\nfor (i = 0; i < ARRAY_SIZE(regDomainPairs); i++)\r\nif (regDomainPairs[i].regDmnEnum == rd)\r\nreturn true;\r\n}\r\nprintk(KERN_DEBUG\r\n"ath: invalid regulatory domain/country code 0x%x\n", rd);\r\nreturn false;\r\n}\r\nstatic struct country_code_to_enum_rd*\r\nath_regd_find_country(u16 countryCode)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(allCountries); i++) {\r\nif (allCountries[i].countryCode == countryCode)\r\nreturn &allCountries[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct country_code_to_enum_rd*\r\nath_regd_find_country_by_rd(int regdmn)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(allCountries); i++) {\r\nif (allCountries[i].regDmnEnum == regdmn)\r\nreturn &allCountries[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic u16 ath_regd_get_default_country(u16 rd)\r\n{\r\nif (rd & COUNTRY_ERD_FLAG) {\r\nstruct country_code_to_enum_rd *country = NULL;\r\nu16 cc = rd & ~COUNTRY_ERD_FLAG;\r\ncountry = ath_regd_find_country(cc);\r\nif (country != NULL)\r\nreturn cc;\r\n}\r\nreturn CTRY_DEFAULT;\r\n}\r\nstatic struct reg_dmn_pair_mapping*\r\nath_get_regpair(int regdmn)\r\n{\r\nint i;\r\nif (regdmn == NO_ENUMRD)\r\nreturn NULL;\r\nfor (i = 0; i < ARRAY_SIZE(regDomainPairs); i++) {\r\nif (regDomainPairs[i].regDmnEnum == regdmn)\r\nreturn &regDomainPairs[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nath_regd_init_wiphy(struct ath_regulatory *reg,\r\nstruct wiphy *wiphy,\r\nint (*reg_notifier)(struct wiphy *wiphy,\r\nstruct regulatory_request *request))\r\n{\r\nconst struct ieee80211_regdomain *regd;\r\nwiphy->reg_notifier = reg_notifier;\r\nwiphy->flags |= WIPHY_FLAG_STRICT_REGULATORY;\r\nif (ath_is_world_regd(reg)) {\r\nregd = ath_world_regdomain(reg);\r\nwiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;\r\n} else {\r\nregd = ath_default_world_regdomain();\r\n}\r\nwiphy_apply_custom_regulatory(wiphy, regd);\r\nath_reg_apply_radar_flags(wiphy);\r\nath_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER, reg);\r\nreturn 0;\r\n}\r\nstatic void ath_regd_sanitize(struct ath_regulatory *reg)\r\n{\r\nif (reg->current_rd != COUNTRY_ERD_FLAG)\r\nreturn;\r\nprintk(KERN_DEBUG "ath: EEPROM regdomain sanitized\n");\r\nreg->current_rd = 0x64;\r\n}\r\nstatic int __ath_regd_init(struct ath_regulatory *reg)\r\n{\r\nstruct country_code_to_enum_rd *country = NULL;\r\nu16 regdmn;\r\nif (!reg)\r\nreturn -EINVAL;\r\nath_regd_sanitize(reg);\r\nprintk(KERN_DEBUG "ath: EEPROM regdomain: 0x%0x\n", reg->current_rd);\r\nif (!ath_regd_is_eeprom_valid(reg)) {\r\nprintk(KERN_ERR "ath: Invalid EEPROM contents\n");\r\nreturn -EINVAL;\r\n}\r\nregdmn = ath_regd_get_eepromRD(reg);\r\nreg->country_code = ath_regd_get_default_country(regdmn);\r\nif (reg->country_code == CTRY_DEFAULT &&\r\nregdmn == CTRY_DEFAULT) {\r\nprintk(KERN_DEBUG "ath: EEPROM indicates default "\r\n"country code should be used\n");\r\nreg->country_code = CTRY_UNITED_STATES;\r\n}\r\nif (reg->country_code == CTRY_DEFAULT) {\r\ncountry = NULL;\r\n} else {\r\nprintk(KERN_DEBUG "ath: doing EEPROM country->regdmn "\r\n"map search\n");\r\ncountry = ath_regd_find_country(reg->country_code);\r\nif (country == NULL) {\r\nprintk(KERN_DEBUG\r\n"ath: no valid country maps found for "\r\n"country code: 0x%0x\n",\r\nreg->country_code);\r\nreturn -EINVAL;\r\n} else {\r\nregdmn = country->regDmnEnum;\r\nprintk(KERN_DEBUG "ath: country maps to "\r\n"regdmn code: 0x%0x\n",\r\nregdmn);\r\n}\r\n}\r\nreg->regpair = ath_get_regpair(regdmn);\r\nif (!reg->regpair) {\r\nprintk(KERN_DEBUG "ath: "\r\n"No regulatory domain pair found, cannot continue\n");\r\nreturn -EINVAL;\r\n}\r\nif (!country)\r\ncountry = ath_regd_find_country_by_rd(regdmn);\r\nif (country) {\r\nreg->alpha2[0] = country->isoName[0];\r\nreg->alpha2[1] = country->isoName[1];\r\n} else {\r\nreg->alpha2[0] = '0';\r\nreg->alpha2[1] = '0';\r\n}\r\nprintk(KERN_DEBUG "ath: Country alpha2 being used: %c%c\n",\r\nreg->alpha2[0], reg->alpha2[1]);\r\nprintk(KERN_DEBUG "ath: Regpair used: 0x%0x\n",\r\nreg->regpair->regDmnEnum);\r\nreturn 0;\r\n}\r\nint\r\nath_regd_init(struct ath_regulatory *reg,\r\nstruct wiphy *wiphy,\r\nint (*reg_notifier)(struct wiphy *wiphy,\r\nstruct regulatory_request *request))\r\n{\r\nstruct ath_common *common = container_of(reg, struct ath_common,\r\nregulatory);\r\nint r;\r\nr = __ath_regd_init(reg);\r\nif (r)\r\nreturn r;\r\nif (ath_is_world_regd(reg))\r\nmemcpy(&common->reg_world_copy, reg,\r\nsizeof(struct ath_regulatory));\r\nath_regd_init_wiphy(reg, wiphy, reg_notifier);\r\nreturn 0;\r\n}\r\nu32 ath_regd_get_band_ctl(struct ath_regulatory *reg,\r\nenum ieee80211_band band)\r\n{\r\nif (!reg->regpair ||\r\n(reg->country_code == CTRY_DEFAULT &&\r\nis_wwr_sku(ath_regd_get_eepromRD(reg)))) {\r\nreturn SD_NO_CTL;\r\n}\r\nswitch (band) {\r\ncase IEEE80211_BAND_2GHZ:\r\nreturn reg->regpair->reg_2ghz_ctl;\r\ncase IEEE80211_BAND_5GHZ:\r\nreturn reg->regpair->reg_5ghz_ctl;\r\ndefault:\r\nreturn NO_CTL;\r\n}\r\n}
