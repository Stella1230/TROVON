static __be32\r\nnfsacld_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)\r\n{\r\nreturn nfs_ok;\r\n}\r\nstatic __be32 nfsacld_proc_getacl(struct svc_rqst * rqstp,\r\nstruct nfsd3_getaclargs *argp, struct nfsd3_getaclres *resp)\r\n{\r\nsvc_fh *fh;\r\nstruct posix_acl *acl;\r\n__be32 nfserr = 0;\r\ndprintk("nfsd: GETACL(2acl) %s\n", SVCFH_fmt(&argp->fh));\r\nfh = fh_copy(&resp->fh, &argp->fh);\r\nnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_NOP);\r\nif (nfserr)\r\nRETURN_STATUS(nfserr);\r\nif (argp->mask & ~(NFS_ACL|NFS_ACLCNT|NFS_DFACL|NFS_DFACLCNT))\r\nRETURN_STATUS(nfserr_inval);\r\nresp->mask = argp->mask;\r\nif (resp->mask & (NFS_ACL|NFS_ACLCNT)) {\r\nacl = nfsd_get_posix_acl(fh, ACL_TYPE_ACCESS);\r\nif (IS_ERR(acl)) {\r\nint err = PTR_ERR(acl);\r\nif (err == -ENODATA || err == -EOPNOTSUPP)\r\nacl = NULL;\r\nelse {\r\nnfserr = nfserrno(err);\r\ngoto fail;\r\n}\r\n}\r\nif (acl == NULL) {\r\nstruct inode *inode = fh->fh_dentry->d_inode;\r\nacl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);\r\n}\r\nresp->acl_access = acl;\r\n}\r\nif (resp->mask & (NFS_DFACL|NFS_DFACLCNT)) {\r\nacl = nfsd_get_posix_acl(fh, ACL_TYPE_DEFAULT);\r\nif (IS_ERR(acl)) {\r\nint err = PTR_ERR(acl);\r\nif (err == -ENODATA || err == -EOPNOTSUPP)\r\nacl = NULL;\r\nelse {\r\nnfserr = nfserrno(err);\r\ngoto fail;\r\n}\r\n}\r\nresp->acl_default = acl;\r\n}\r\nRETURN_STATUS(0);\r\nfail:\r\nposix_acl_release(resp->acl_access);\r\nposix_acl_release(resp->acl_default);\r\nRETURN_STATUS(nfserr);\r\n}\r\nstatic __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\r\nstruct nfsd3_setaclargs *argp,\r\nstruct nfsd_attrstat *resp)\r\n{\r\nsvc_fh *fh;\r\n__be32 nfserr = 0;\r\ndprintk("nfsd: SETACL(2acl) %s\n", SVCFH_fmt(&argp->fh));\r\nfh = fh_copy(&resp->fh, &argp->fh);\r\nnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\r\nif (!nfserr) {\r\nnfserr = nfserrno( nfsd_set_posix_acl(\r\nfh, ACL_TYPE_ACCESS, argp->acl_access) );\r\n}\r\nif (!nfserr) {\r\nnfserr = nfserrno( nfsd_set_posix_acl(\r\nfh, ACL_TYPE_DEFAULT, argp->acl_default) );\r\n}\r\nposix_acl_release(argp->acl_access);\r\nposix_acl_release(argp->acl_default);\r\nreturn nfserr;\r\n}\r\nstatic __be32 nfsacld_proc_getattr(struct svc_rqst * rqstp,\r\nstruct nfsd_fhandle *argp, struct nfsd_attrstat *resp)\r\n{\r\ndprintk("nfsd: GETATTR %s\n", SVCFH_fmt(&argp->fh));\r\nfh_copy(&resp->fh, &argp->fh);\r\nreturn fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_NOP);\r\n}\r\nstatic __be32 nfsacld_proc_access(struct svc_rqst *rqstp, struct nfsd3_accessargs *argp,\r\nstruct nfsd3_accessres *resp)\r\n{\r\n__be32 nfserr;\r\ndprintk("nfsd: ACCESS(2acl) %s 0x%x\n",\r\nSVCFH_fmt(&argp->fh),\r\nargp->access);\r\nfh_copy(&resp->fh, &argp->fh);\r\nresp->access = argp->access;\r\nnfserr = nfsd_access(rqstp, &resp->fh, &resp->access, NULL);\r\nreturn nfserr;\r\n}\r\nstatic int nfsaclsvc_decode_getaclargs(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_getaclargs *argp)\r\n{\r\nif (!(p = nfs2svc_decode_fh(p, &argp->fh)))\r\nreturn 0;\r\nargp->mask = ntohl(*p); p++;\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nstatic int nfsaclsvc_decode_setaclargs(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_setaclargs *argp)\r\n{\r\nstruct kvec *head = rqstp->rq_arg.head;\r\nunsigned int base;\r\nint n;\r\nif (!(p = nfs2svc_decode_fh(p, &argp->fh)))\r\nreturn 0;\r\nargp->mask = ntohl(*p++);\r\nif (argp->mask & ~(NFS_ACL|NFS_ACLCNT|NFS_DFACL|NFS_DFACLCNT) ||\r\n!xdr_argsize_check(rqstp, p))\r\nreturn 0;\r\nbase = (char *)p - (char *)head->iov_base;\r\nn = nfsacl_decode(&rqstp->rq_arg, base, NULL,\r\n(argp->mask & NFS_ACL) ?\r\n&argp->acl_access : NULL);\r\nif (n > 0)\r\nn = nfsacl_decode(&rqstp->rq_arg, base + n, NULL,\r\n(argp->mask & NFS_DFACL) ?\r\n&argp->acl_default : NULL);\r\nreturn (n > 0);\r\n}\r\nstatic int nfsaclsvc_decode_fhandleargs(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_fhandle *argp)\r\n{\r\nif (!(p = nfs2svc_decode_fh(p, &argp->fh)))\r\nreturn 0;\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nstatic int nfsaclsvc_decode_accessargs(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_accessargs *argp)\r\n{\r\nif (!(p = nfs2svc_decode_fh(p, &argp->fh)))\r\nreturn 0;\r\nargp->access = ntohl(*p++);\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nint\r\nnfsaclsvc_encode_voidres(struct svc_rqst *rqstp, __be32 *p, void *dummy)\r\n{\r\nreturn xdr_ressize_check(rqstp, p);\r\n}\r\nstatic int nfsaclsvc_encode_getaclres(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_getaclres *resp)\r\n{\r\nstruct dentry *dentry = resp->fh.fh_dentry;\r\nstruct inode *inode;\r\nstruct kvec *head = rqstp->rq_res.head;\r\nunsigned int base;\r\nint n;\r\nint w;\r\nif (dentry == NULL || dentry->d_inode == NULL)\r\nreturn 0;\r\ninode = dentry->d_inode;\r\np = nfs2svc_encode_fattr(rqstp, p, &resp->fh);\r\n*p++ = htonl(resp->mask);\r\nif (!xdr_ressize_check(rqstp, p))\r\nreturn 0;\r\nbase = (char *)p - (char *)head->iov_base;\r\nrqstp->rq_res.page_len = w = nfsacl_size(\r\n(resp->mask & NFS_ACL) ? resp->acl_access : NULL,\r\n(resp->mask & NFS_DFACL) ? resp->acl_default : NULL);\r\nwhile (w > 0) {\r\nif (!rqstp->rq_respages[rqstp->rq_resused++])\r\nreturn 0;\r\nw -= PAGE_SIZE;\r\n}\r\nn = nfsacl_encode(&rqstp->rq_res, base, inode,\r\nresp->acl_access,\r\nresp->mask & NFS_ACL, 0);\r\nif (n > 0)\r\nn = nfsacl_encode(&rqstp->rq_res, base + n, inode,\r\nresp->acl_default,\r\nresp->mask & NFS_DFACL,\r\nNFS_ACL_DEFAULT);\r\nif (n <= 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int nfsaclsvc_encode_attrstatres(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_attrstat *resp)\r\n{\r\np = nfs2svc_encode_fattr(rqstp, p, &resp->fh);\r\nreturn xdr_ressize_check(rqstp, p);\r\n}\r\nstatic int nfsaclsvc_encode_accessres(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_accessres *resp)\r\n{\r\np = nfs2svc_encode_fattr(rqstp, p, &resp->fh);\r\n*p++ = htonl(resp->access);\r\nreturn xdr_ressize_check(rqstp, p);\r\n}\r\nstatic int nfsaclsvc_release_getacl(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_getaclres *resp)\r\n{\r\nfh_put(&resp->fh);\r\nposix_acl_release(resp->acl_access);\r\nposix_acl_release(resp->acl_default);\r\nreturn 1;\r\n}\r\nstatic int nfsaclsvc_release_attrstat(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd_attrstat *resp)\r\n{\r\nfh_put(&resp->fh);\r\nreturn 1;\r\n}\r\nstatic int nfsaclsvc_release_access(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_accessres *resp)\r\n{\r\nfh_put(&resp->fh);\r\nreturn 1;\r\n}
