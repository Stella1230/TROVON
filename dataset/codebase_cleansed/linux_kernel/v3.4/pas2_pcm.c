static int pcm_set_speed(int arg)\r\n{\r\nint foo, tmp;\r\nunsigned long flags;\r\nif (arg == 0)\r\nreturn pcm_speed;\r\nif (arg > 44100)\r\narg = 44100;\r\nif (arg < 5000)\r\narg = 5000;\r\nif (pcm_channels & 2)\r\n{\r\nfoo = ((PIT_TICK_RATE / 2) + (arg / 2)) / arg;\r\narg = ((PIT_TICK_RATE / 2) + (foo / 2)) / foo;\r\n}\r\nelse\r\n{\r\nfoo = (PIT_TICK_RATE + (arg / 2)) / arg;\r\narg = (PIT_TICK_RATE + (foo / 2)) / foo;\r\n}\r\npcm_speed = arg;\r\ntmp = pas_read(0x0B8A);\r\n#if !defined NO_AUTO_FILTER_SET\r\ntmp &= 0xe0;\r\nif (pcm_speed >= 2 * 17897)\r\ntmp |= 0x01;\r\nelse if (pcm_speed >= 2 * 15909)\r\ntmp |= 0x02;\r\nelse if (pcm_speed >= 2 * 11931)\r\ntmp |= 0x09;\r\nelse if (pcm_speed >= 2 * 8948)\r\ntmp |= 0x11;\r\nelse if (pcm_speed >= 2 * 5965)\r\ntmp |= 0x19;\r\nelse if (pcm_speed >= 2 * 2982)\r\ntmp |= 0x04;\r\npcm_filter = tmp;\r\n#endif\r\nspin_lock_irqsave(&pas_lock, flags);\r\npas_write(tmp & ~(0x40 | 0x80), 0x0B8A);\r\npas_write(0x00 | 0x30 | 0x04, 0x138B);\r\npas_write(foo & 0xff, 0x1388);\r\npas_write((foo >> 8) & 0xff, 0x1388);\r\npas_write(tmp, 0x0B8A);\r\nspin_unlock_irqrestore(&pas_lock, flags);\r\nreturn pcm_speed;\r\n}\r\nstatic int pcm_set_channels(int arg)\r\n{\r\nif ((arg != 1) && (arg != 2))\r\nreturn pcm_channels;\r\nif (arg != pcm_channels)\r\n{\r\npas_write(pas_read(0xF8A) ^ 0x20, 0xF8A);\r\npcm_channels = arg;\r\npcm_set_speed(pcm_speed);\r\n}\r\nreturn pcm_channels;\r\n}\r\nstatic int pcm_set_bits(int arg)\r\n{\r\nif (arg == 0)\r\nreturn pcm_bits;\r\nif ((arg & pcm_bitsok) != arg)\r\nreturn pcm_bits;\r\nif (arg != pcm_bits)\r\n{\r\npas_write(pas_read(0x8389) ^ 0x04, 0x8389);\r\npcm_bits = arg;\r\n}\r\nreturn pcm_bits;\r\n}\r\nstatic int pas_audio_ioctl(int dev, unsigned int cmd, void __user *arg)\r\n{\r\nint val, ret;\r\nint __user *p = arg;\r\nDEB(printk("pas2_pcm.c: static int pas_audio_ioctl(unsigned int cmd = %X, unsigned int arg = %X)\n", cmd, arg));\r\nswitch (cmd)\r\n{\r\ncase SOUND_PCM_WRITE_RATE:\r\nif (get_user(val, p))\r\nreturn -EFAULT;\r\nret = pcm_set_speed(val);\r\nbreak;\r\ncase SOUND_PCM_READ_RATE:\r\nret = pcm_speed;\r\nbreak;\r\ncase SNDCTL_DSP_STEREO:\r\nif (get_user(val, p))\r\nreturn -EFAULT;\r\nret = pcm_set_channels(val + 1) - 1;\r\nbreak;\r\ncase SOUND_PCM_WRITE_CHANNELS:\r\nif (get_user(val, p))\r\nreturn -EFAULT;\r\nret = pcm_set_channels(val);\r\nbreak;\r\ncase SOUND_PCM_READ_CHANNELS:\r\nret = pcm_channels;\r\nbreak;\r\ncase SNDCTL_DSP_SETFMT:\r\nif (get_user(val, p))\r\nreturn -EFAULT;\r\nret = pcm_set_bits(val);\r\nbreak;\r\ncase SOUND_PCM_READ_BITS:\r\nret = pcm_bits;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn put_user(ret, p);\r\n}\r\nstatic void pas_audio_reset(int dev)\r\n{\r\nDEB(printk("pas2_pcm.c: static void pas_audio_reset(void)\n"));\r\npas_write(pas_read(0xF8A) & ~0x40, 0xF8A);\r\n}\r\nstatic int pas_audio_open(int dev, int mode)\r\n{\r\nint err;\r\nunsigned long flags;\r\nDEB(printk("pas2_pcm.c: static int pas_audio_open(int mode = %X)\n", mode));\r\nspin_lock_irqsave(&pas_lock, flags);\r\nif (pcm_busy)\r\n{\r\nspin_unlock_irqrestore(&pas_lock, flags);\r\nreturn -EBUSY;\r\n}\r\npcm_busy = 1;\r\nspin_unlock_irqrestore(&pas_lock, flags);\r\nif ((err = pas_set_intr(PAS_PCM_INTRBITS)) < 0)\r\nreturn err;\r\npcm_count = 0;\r\nopen_mode = mode;\r\nreturn 0;\r\n}\r\nstatic void pas_audio_close(int dev)\r\n{\r\nunsigned long flags;\r\nDEB(printk("pas2_pcm.c: static void pas_audio_close(void)\n"));\r\nspin_lock_irqsave(&pas_lock, flags);\r\npas_audio_reset(dev);\r\npas_remove_intr(PAS_PCM_INTRBITS);\r\npcm_mode = PCM_NON;\r\npcm_busy = 0;\r\nspin_unlock_irqrestore(&pas_lock, flags);\r\n}\r\nstatic void pas_audio_output_block(int dev, unsigned long buf, int count,\r\nint intrflag)\r\n{\r\nunsigned long flags, cnt;\r\nDEB(printk("pas2_pcm.c: static void pas_audio_output_block(char *buf = %P, int count = %X)\n", buf, count));\r\ncnt = count;\r\nif (audio_devs[dev]->dmap_out->dma > 3)\r\ncnt >>= 1;\r\nif (audio_devs[dev]->flags & DMA_AUTOMODE &&\r\nintrflag &&\r\ncnt == pcm_count)\r\nreturn;\r\nspin_lock_irqsave(&pas_lock, flags);\r\npas_write(pas_read(0xF8A) & ~0x40,\r\n0xF8A);\r\nif (audio_devs[dev]->dmap_out->dma > 3)\r\ncount >>= 1;\r\nif (count != pcm_count)\r\n{\r\npas_write(pas_read(0x0B8A) & ~0x80, 0x0B8A);\r\npas_write(0x40 | 0x30 | 0x04, 0x138B);\r\npas_write(count & 0xff, 0x1389);\r\npas_write((count >> 8) & 0xff, 0x1389);\r\npas_write(pas_read(0x0B8A) | 0x80, 0x0B8A);\r\npcm_count = count;\r\n}\r\npas_write(pas_read(0x0B8A) | 0x80 | 0x40, 0x0B8A);\r\n#ifdef NO_TRIGGER\r\npas_write(pas_read(0xF8A) | 0x40 | 0x10, 0xF8A);\r\n#endif\r\npcm_mode = PCM_DAC;\r\nspin_unlock_irqrestore(&pas_lock, flags);\r\n}\r\nstatic void pas_audio_start_input(int dev, unsigned long buf, int count,\r\nint intrflag)\r\n{\r\nunsigned long flags;\r\nint cnt;\r\nDEB(printk("pas2_pcm.c: static void pas_audio_start_input(char *buf = %P, int count = %X)\n", buf, count));\r\ncnt = count;\r\nif (audio_devs[dev]->dmap_out->dma > 3)\r\ncnt >>= 1;\r\nif (audio_devs[pas_audiodev]->flags & DMA_AUTOMODE &&\r\nintrflag &&\r\ncnt == pcm_count)\r\nreturn;\r\nspin_lock_irqsave(&pas_lock, flags);\r\nif (audio_devs[dev]->dmap_out->dma > 3)\r\ncount >>= 1;\r\nif (count != pcm_count)\r\n{\r\npas_write(pas_read(0x0B8A) & ~0x80, 0x0B8A);\r\npas_write(0x40 | 0x30 | 0x04, 0x138B);\r\npas_write(count & 0xff, 0x1389);\r\npas_write((count >> 8) & 0xff, 0x1389);\r\npas_write(pas_read(0x0B8A) | 0x80, 0x0B8A);\r\npcm_count = count;\r\n}\r\npas_write(pas_read(0x0B8A) | 0x80 | 0x40, 0x0B8A);\r\n#ifdef NO_TRIGGER\r\npas_write((pas_read(0xF8A) | 0x40) & ~0x10, 0xF8A);\r\n#endif\r\npcm_mode = PCM_ADC;\r\nspin_unlock_irqrestore(&pas_lock, flags);\r\n}\r\nstatic void pas_audio_trigger(int dev, int state)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&pas_lock, flags);\r\nstate &= open_mode;\r\nif (state & PCM_ENABLE_OUTPUT)\r\npas_write(pas_read(0xF8A) | 0x40 | 0x10, 0xF8A);\r\nelse if (state & PCM_ENABLE_INPUT)\r\npas_write((pas_read(0xF8A) | 0x40) & ~0x10, 0xF8A);\r\nelse\r\npas_write(pas_read(0xF8A) & ~0x40, 0xF8A);\r\nspin_unlock_irqrestore(&pas_lock, flags);\r\n}\r\nstatic int pas_audio_prepare_for_input(int dev, int bsize, int bcount)\r\n{\r\npas_audio_reset(dev);\r\nreturn 0;\r\n}\r\nstatic int pas_audio_prepare_for_output(int dev, int bsize, int bcount)\r\n{\r\npas_audio_reset(dev);\r\nreturn 0;\r\n}\r\nvoid __init pas_pcm_init(struct address_info *hw_config)\r\n{\r\nDEB(printk("pas2_pcm.c: long pas_pcm_init()\n"));\r\npcm_bitsok = 8;\r\nif (pas_read(0xEF8B) & 0x08)\r\npcm_bitsok |= 16;\r\npcm_set_speed(DSP_DEFAULT_SPEED);\r\nif ((pas_audiodev = sound_install_audiodrv(AUDIO_DRIVER_VERSION,\r\n"Pro Audio Spectrum",\r\n&pas_audio_driver,\r\nsizeof(struct audio_driver),\r\nDMA_AUTOMODE,\r\nAFMT_U8 | AFMT_S16_LE,\r\nNULL,\r\nhw_config->dma,\r\nhw_config->dma)) < 0)\r\nprintk(KERN_WARNING "PAS16: Too many PCM devices available\n");\r\n}\r\nvoid pas_pcm_interrupt(unsigned char status, int cause)\r\n{\r\nif (cause == 1)\r\n{\r\nif (!(audio_devs[pas_audiodev]->flags & DMA_AUTOMODE))\r\npas_write(pas_read(0xF8A) & ~0x40, 0xF8A);\r\nswitch (pcm_mode)\r\n{\r\ncase PCM_DAC:\r\nDMAbuf_outputintr(pas_audiodev, 1);\r\nbreak;\r\ncase PCM_ADC:\r\nDMAbuf_inputintr(pas_audiodev);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "PAS: Unexpected PCM interrupt\n");\r\n}\r\n}\r\n}
