static inline u32 qib_read_ureg32(const struct qib_devdata *dd,\r\nenum qib_ureg regno, int ctxt)\r\n{\r\nif (!dd->kregbase || !(dd->flags & QIB_PRESENT))\r\nreturn 0;\r\nif (dd->userbase)\r\nreturn readl(regno + (u64 __iomem *)\r\n((char __iomem *)dd->userbase +\r\ndd->ureg_align * ctxt));\r\nelse\r\nreturn readl(regno + (u64 __iomem *)\r\n(dd->uregbase +\r\n(char __iomem *)dd->kregbase +\r\ndd->ureg_align * ctxt));\r\n}\r\nstatic inline void qib_write_ureg(const struct qib_devdata *dd,\r\nenum qib_ureg regno, u64 value, int ctxt)\r\n{\r\nu64 __iomem *ubase;\r\nif (dd->userbase)\r\nubase = (u64 __iomem *)\r\n((char __iomem *) dd->userbase +\r\ndd->ureg_align * ctxt);\r\nelse\r\nubase = (u64 __iomem *)\r\n(dd->uregbase +\r\n(char __iomem *) dd->kregbase +\r\ndd->ureg_align * ctxt);\r\nif (dd->kregbase && (dd->flags & QIB_PRESENT))\r\nwriteq(value, &ubase[regno]);\r\n}\r\nstatic inline void qib_write_kreg_ctxt(const struct qib_devdata *dd,\r\nconst u16 regno, unsigned ctxt,\r\nu64 value)\r\n{\r\nqib_write_kreg(dd, regno + ctxt, value);\r\n}\r\nstatic inline void write_7220_creg(const struct qib_devdata *dd,\r\nu16 regno, u64 value)\r\n{\r\nif (dd->cspec->cregbase && (dd->flags & QIB_PRESENT))\r\nwriteq(value, &dd->cspec->cregbase[regno]);\r\n}\r\nstatic inline u64 read_7220_creg(const struct qib_devdata *dd, u16 regno)\r\n{\r\nif (!dd->cspec->cregbase || !(dd->flags & QIB_PRESENT))\r\nreturn 0;\r\nreturn readq(&dd->cspec->cregbase[regno]);\r\n}\r\nstatic inline u32 read_7220_creg32(const struct qib_devdata *dd, u16 regno)\r\n{\r\nif (!dd->cspec->cregbase || !(dd->flags & QIB_PRESENT))\r\nreturn 0;\r\nreturn readl(&dd->cspec->cregbase[regno]);\r\n}\r\nstatic void qib_disarm_7220_senderrbufs(struct qib_pportdata *ppd)\r\n{\r\nunsigned long sbuf[3];\r\nstruct qib_devdata *dd = ppd->dd;\r\nsbuf[0] = qib_read_kreg64(dd, kr_sendbuffererror);\r\nsbuf[1] = qib_read_kreg64(dd, kr_sendbuffererror + 1);\r\nsbuf[2] = qib_read_kreg64(dd, kr_sendbuffererror + 2);\r\nif (sbuf[0] || sbuf[1] || sbuf[2])\r\nqib_disarm_piobufs_set(dd, sbuf,\r\ndd->piobcnt2k + dd->piobcnt4k);\r\n}\r\nstatic void qib_7220_txe_recover(struct qib_devdata *dd)\r\n{\r\nqib_devinfo(dd->pcidev, "Recovering from TXE PIO parity error\n");\r\nqib_disarm_7220_senderrbufs(dd->pport);\r\n}\r\nstatic void qib_7220_sdma_sendctrl(struct qib_pportdata *ppd, unsigned op)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nu64 set_sendctrl = 0;\r\nu64 clr_sendctrl = 0;\r\nif (op & QIB_SDMA_SENDCTRL_OP_ENABLE)\r\nset_sendctrl |= SYM_MASK(SendCtrl, SDmaEnable);\r\nelse\r\nclr_sendctrl |= SYM_MASK(SendCtrl, SDmaEnable);\r\nif (op & QIB_SDMA_SENDCTRL_OP_INTENABLE)\r\nset_sendctrl |= SYM_MASK(SendCtrl, SDmaIntEnable);\r\nelse\r\nclr_sendctrl |= SYM_MASK(SendCtrl, SDmaIntEnable);\r\nif (op & QIB_SDMA_SENDCTRL_OP_HALT)\r\nset_sendctrl |= SYM_MASK(SendCtrl, SDmaHalt);\r\nelse\r\nclr_sendctrl |= SYM_MASK(SendCtrl, SDmaHalt);\r\nspin_lock(&dd->sendctrl_lock);\r\ndd->sendctrl |= set_sendctrl;\r\ndd->sendctrl &= ~clr_sendctrl;\r\nqib_write_kreg(dd, kr_sendctrl, dd->sendctrl);\r\nqib_write_kreg(dd, kr_scratch, 0);\r\nspin_unlock(&dd->sendctrl_lock);\r\n}\r\nstatic void qib_decode_7220_sdma_errs(struct qib_pportdata *ppd,\r\nu64 err, char *buf, size_t blen)\r\n{\r\nstatic const struct {\r\nu64 err;\r\nconst char *msg;\r\n} errs[] = {\r\n{ ERR_MASK(SDmaGenMismatchErr),\r\n"SDmaGenMismatch" },\r\n{ ERR_MASK(SDmaOutOfBoundErr),\r\n"SDmaOutOfBound" },\r\n{ ERR_MASK(SDmaTailOutOfBoundErr),\r\n"SDmaTailOutOfBound" },\r\n{ ERR_MASK(SDmaBaseErr),\r\n"SDmaBase" },\r\n{ ERR_MASK(SDma1stDescErr),\r\n"SDma1stDesc" },\r\n{ ERR_MASK(SDmaRpyTagErr),\r\n"SDmaRpyTag" },\r\n{ ERR_MASK(SDmaDwEnErr),\r\n"SDmaDwEn" },\r\n{ ERR_MASK(SDmaMissingDwErr),\r\n"SDmaMissingDw" },\r\n{ ERR_MASK(SDmaUnexpDataErr),\r\n"SDmaUnexpData" },\r\n{ ERR_MASK(SDmaDescAddrMisalignErr),\r\n"SDmaDescAddrMisalign" },\r\n{ ERR_MASK(SendBufMisuseErr),\r\n"SendBufMisuse" },\r\n{ ERR_MASK(SDmaDisabledErr),\r\n"SDmaDisabled" },\r\n};\r\nint i;\r\nsize_t bidx = 0;\r\nfor (i = 0; i < ARRAY_SIZE(errs); i++) {\r\nif (err & errs[i].err)\r\nbidx += scnprintf(buf + bidx, blen - bidx,\r\n"%s ", errs[i].msg);\r\n}\r\n}\r\nstatic void qib_7220_sdma_hw_clean_up(struct qib_pportdata *ppd)\r\n{\r\nsendctrl_7220_mod(ppd, QIB_SENDCTRL_DISARM_ALL | QIB_SENDCTRL_FLUSH |\r\nQIB_SENDCTRL_AVAIL_BLIP);\r\nppd->dd->upd_pio_shadow = 1;\r\n}\r\nstatic void qib_sdma_7220_setlengen(struct qib_pportdata *ppd)\r\n{\r\nqib_write_kreg(ppd->dd, kr_senddmalengen, ppd->sdma_descq_cnt);\r\nqib_write_kreg(ppd->dd, kr_senddmalengen,\r\nppd->sdma_descq_cnt |\r\n(1ULL << QIB_7220_SendDmaLenGen_Generation_MSB));\r\n}\r\nstatic void qib_7220_sdma_hw_start_up(struct qib_pportdata *ppd)\r\n{\r\nqib_sdma_7220_setlengen(ppd);\r\nqib_sdma_update_7220_tail(ppd, 0);\r\nppd->sdma_head_dma[0] = 0;\r\n}\r\nstatic void sdma_7220_errors(struct qib_pportdata *ppd, u64 errs)\r\n{\r\nunsigned long flags;\r\nstruct qib_devdata *dd = ppd->dd;\r\nchar *msg;\r\nerrs &= QLOGIC_IB_E_SDMAERRS;\r\nmsg = dd->cspec->sdmamsgbuf;\r\nqib_decode_7220_sdma_errs(ppd, errs, msg, sizeof dd->cspec->sdmamsgbuf);\r\nspin_lock_irqsave(&ppd->sdma_lock, flags);\r\nif (errs & ERR_MASK(SendBufMisuseErr)) {\r\nunsigned long sbuf[3];\r\nsbuf[0] = qib_read_kreg64(dd, kr_sendbuffererror);\r\nsbuf[1] = qib_read_kreg64(dd, kr_sendbuffererror + 1);\r\nsbuf[2] = qib_read_kreg64(dd, kr_sendbuffererror + 2);\r\nqib_dev_err(ppd->dd,\r\n"IB%u:%u SendBufMisuse: %04lx %016lx %016lx\n",\r\nppd->dd->unit, ppd->port, sbuf[2], sbuf[1],\r\nsbuf[0]);\r\n}\r\nif (errs & ERR_MASK(SDmaUnexpDataErr))\r\nqib_dev_err(dd, "IB%u:%u SDmaUnexpData\n", ppd->dd->unit,\r\nppd->port);\r\nswitch (ppd->sdma_state.current_state) {\r\ncase qib_sdma_state_s00_hw_down:\r\nbreak;\r\ncase qib_sdma_state_s10_hw_start_up_wait:\r\nbreak;\r\ncase qib_sdma_state_s20_idle:\r\nbreak;\r\ncase qib_sdma_state_s30_sw_clean_up_wait:\r\nbreak;\r\ncase qib_sdma_state_s40_hw_clean_up_wait:\r\nif (errs & ERR_MASK(SDmaDisabledErr))\r\n__qib_sdma_process_event(ppd,\r\nqib_sdma_event_e50_hw_cleaned);\r\nbreak;\r\ncase qib_sdma_state_s50_hw_halt_wait:\r\nbreak;\r\ncase qib_sdma_state_s99_running:\r\nif (errs & DISABLES_SDMA)\r\n__qib_sdma_process_event(ppd,\r\nqib_sdma_event_e7220_err_halted);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&ppd->sdma_lock, flags);\r\n}\r\nstatic int qib_decode_7220_err(struct qib_devdata *dd, char *buf, size_t blen,\r\nu64 err)\r\n{\r\nint iserr = 1;\r\n*buf = '\0';\r\nif (err & QLOGIC_IB_E_PKTERRS) {\r\nif (!(err & ~QLOGIC_IB_E_PKTERRS))\r\niserr = 0;\r\nif ((err & ERR_MASK(RcvICRCErr)) &&\r\n!(err & (ERR_MASK(RcvVCRCErr) | ERR_MASK(RcvEBPErr))))\r\nstrlcat(buf, "CRC ", blen);\r\nif (!iserr)\r\ngoto done;\r\n}\r\nif (err & ERR_MASK(RcvHdrLenErr))\r\nstrlcat(buf, "rhdrlen ", blen);\r\nif (err & ERR_MASK(RcvBadTidErr))\r\nstrlcat(buf, "rbadtid ", blen);\r\nif (err & ERR_MASK(RcvBadVersionErr))\r\nstrlcat(buf, "rbadversion ", blen);\r\nif (err & ERR_MASK(RcvHdrErr))\r\nstrlcat(buf, "rhdr ", blen);\r\nif (err & ERR_MASK(SendSpecialTriggerErr))\r\nstrlcat(buf, "sendspecialtrigger ", blen);\r\nif (err & ERR_MASK(RcvLongPktLenErr))\r\nstrlcat(buf, "rlongpktlen ", blen);\r\nif (err & ERR_MASK(RcvMaxPktLenErr))\r\nstrlcat(buf, "rmaxpktlen ", blen);\r\nif (err & ERR_MASK(RcvMinPktLenErr))\r\nstrlcat(buf, "rminpktlen ", blen);\r\nif (err & ERR_MASK(SendMinPktLenErr))\r\nstrlcat(buf, "sminpktlen ", blen);\r\nif (err & ERR_MASK(RcvFormatErr))\r\nstrlcat(buf, "rformaterr ", blen);\r\nif (err & ERR_MASK(RcvUnsupportedVLErr))\r\nstrlcat(buf, "runsupvl ", blen);\r\nif (err & ERR_MASK(RcvUnexpectedCharErr))\r\nstrlcat(buf, "runexpchar ", blen);\r\nif (err & ERR_MASK(RcvIBFlowErr))\r\nstrlcat(buf, "ribflow ", blen);\r\nif (err & ERR_MASK(SendUnderRunErr))\r\nstrlcat(buf, "sunderrun ", blen);\r\nif (err & ERR_MASK(SendPioArmLaunchErr))\r\nstrlcat(buf, "spioarmlaunch ", blen);\r\nif (err & ERR_MASK(SendUnexpectedPktNumErr))\r\nstrlcat(buf, "sunexperrpktnum ", blen);\r\nif (err & ERR_MASK(SendDroppedSmpPktErr))\r\nstrlcat(buf, "sdroppedsmppkt ", blen);\r\nif (err & ERR_MASK(SendMaxPktLenErr))\r\nstrlcat(buf, "smaxpktlen ", blen);\r\nif (err & ERR_MASK(SendUnsupportedVLErr))\r\nstrlcat(buf, "sunsupVL ", blen);\r\nif (err & ERR_MASK(InvalidAddrErr))\r\nstrlcat(buf, "invalidaddr ", blen);\r\nif (err & ERR_MASK(RcvEgrFullErr))\r\nstrlcat(buf, "rcvegrfull ", blen);\r\nif (err & ERR_MASK(RcvHdrFullErr))\r\nstrlcat(buf, "rcvhdrfull ", blen);\r\nif (err & ERR_MASK(IBStatusChanged))\r\nstrlcat(buf, "ibcstatuschg ", blen);\r\nif (err & ERR_MASK(RcvIBLostLinkErr))\r\nstrlcat(buf, "riblostlink ", blen);\r\nif (err & ERR_MASK(HardwareErr))\r\nstrlcat(buf, "hardware ", blen);\r\nif (err & ERR_MASK(ResetNegated))\r\nstrlcat(buf, "reset ", blen);\r\nif (err & QLOGIC_IB_E_SDMAERRS)\r\nqib_decode_7220_sdma_errs(dd->pport, err, buf, blen);\r\nif (err & ERR_MASK(InvalidEEPCmd))\r\nstrlcat(buf, "invalideepromcmd ", blen);\r\ndone:\r\nreturn iserr;\r\n}\r\nstatic void reenable_7220_chase(unsigned long opaque)\r\n{\r\nstruct qib_pportdata *ppd = (struct qib_pportdata *)opaque;\r\nppd->cpspec->chase_timer.expires = 0;\r\nqib_set_ib_7220_lstate(ppd, QLOGIC_IB_IBCC_LINKCMD_DOWN,\r\nQLOGIC_IB_IBCC_LINKINITCMD_POLL);\r\n}\r\nstatic void handle_7220_chase(struct qib_pportdata *ppd, u64 ibcst)\r\n{\r\nu8 ibclt;\r\nunsigned long tnow;\r\nibclt = (u8)SYM_FIELD(ibcst, IBCStatus, LinkTrainingState);\r\nswitch (ibclt) {\r\ncase IB_7220_LT_STATE_CFGRCVFCFG:\r\ncase IB_7220_LT_STATE_CFGWAITRMT:\r\ncase IB_7220_LT_STATE_TXREVLANES:\r\ncase IB_7220_LT_STATE_CFGENH:\r\ntnow = jiffies;\r\nif (ppd->cpspec->chase_end &&\r\ntime_after(tnow, ppd->cpspec->chase_end)) {\r\nppd->cpspec->chase_end = 0;\r\nqib_set_ib_7220_lstate(ppd,\r\nQLOGIC_IB_IBCC_LINKCMD_DOWN,\r\nQLOGIC_IB_IBCC_LINKINITCMD_DISABLE);\r\nppd->cpspec->chase_timer.expires = jiffies +\r\nQIB_CHASE_DIS_TIME;\r\nadd_timer(&ppd->cpspec->chase_timer);\r\n} else if (!ppd->cpspec->chase_end)\r\nppd->cpspec->chase_end = tnow + QIB_CHASE_TIME;\r\nbreak;\r\ndefault:\r\nppd->cpspec->chase_end = 0;\r\nbreak;\r\n}\r\n}\r\nstatic void handle_7220_errors(struct qib_devdata *dd, u64 errs)\r\n{\r\nchar *msg;\r\nu64 ignore_this_time = 0;\r\nu64 iserr = 0;\r\nint log_idx;\r\nstruct qib_pportdata *ppd = dd->pport;\r\nu64 mask;\r\nerrs &= dd->cspec->errormask;\r\nmsg = dd->cspec->emsgbuf;\r\nif (errs & ERR_MASK(HardwareErr))\r\nqib_7220_handle_hwerrors(dd, msg, sizeof dd->cspec->emsgbuf);\r\nelse\r\nfor (log_idx = 0; log_idx < QIB_EEP_LOG_CNT; ++log_idx)\r\nif (errs & dd->eep_st_masks[log_idx].errs_to_log)\r\nqib_inc_eeprom_err(dd, log_idx, 1);\r\nif (errs & QLOGIC_IB_E_SDMAERRS)\r\nsdma_7220_errors(ppd, errs);\r\nif (errs & ~IB_E_BITSEXTANT)\r\nqib_dev_err(dd, "error interrupt with unknown errors "\r\n"%llx set\n", (unsigned long long)\r\n(errs & ~IB_E_BITSEXTANT));\r\nif (errs & E_SUM_ERRS) {\r\nqib_disarm_7220_senderrbufs(ppd);\r\nif ((errs & E_SUM_LINK_PKTERRS) &&\r\n!(ppd->lflags & QIBL_LINKACTIVE)) {\r\nignore_this_time = errs & E_SUM_LINK_PKTERRS;\r\n}\r\n} else if ((errs & E_SUM_LINK_PKTERRS) &&\r\n!(ppd->lflags & QIBL_LINKACTIVE)) {\r\nignore_this_time = errs & E_SUM_LINK_PKTERRS;\r\n}\r\nqib_write_kreg(dd, kr_errclear, errs);\r\nerrs &= ~ignore_this_time;\r\nif (!errs)\r\ngoto done;\r\nmask = ERR_MASK(IBStatusChanged) |\r\nERR_MASK(RcvEgrFullErr) | ERR_MASK(RcvHdrFullErr) |\r\nERR_MASK(HardwareErr) | ERR_MASK(SDmaDisabledErr);\r\nqib_decode_7220_err(dd, msg, sizeof dd->cspec->emsgbuf, errs & ~mask);\r\nif (errs & E_SUM_PKTERRS)\r\nqib_stats.sps_rcverrs++;\r\nif (errs & E_SUM_ERRS)\r\nqib_stats.sps_txerrs++;\r\niserr = errs & ~(E_SUM_PKTERRS | QLOGIC_IB_E_PKTERRS |\r\nERR_MASK(SDmaDisabledErr));\r\nif (errs & ERR_MASK(IBStatusChanged)) {\r\nu64 ibcs;\r\nibcs = qib_read_kreg64(dd, kr_ibcstatus);\r\nif (!(ppd->lflags & QIBL_IB_AUTONEG_INPROG))\r\nhandle_7220_chase(ppd, ibcs);\r\nppd->link_width_active =\r\n((ibcs >> IBA7220_LINKWIDTH_SHIFT) & 1) ?\r\nIB_WIDTH_4X : IB_WIDTH_1X;\r\nppd->link_speed_active =\r\n((ibcs >> IBA7220_LINKSPEED_SHIFT) & 1) ?\r\nQIB_IB_DDR : QIB_IB_SDR;\r\nif (qib_7220_phys_portstate(ibcs) !=\r\nIB_PHYSPORTSTATE_LINK_ERR_RECOVER)\r\nqib_handle_e_ibstatuschanged(ppd, ibcs);\r\n}\r\nif (errs & ERR_MASK(ResetNegated)) {\r\nqib_dev_err(dd, "Got reset, requires re-init "\r\n"(unload and reload driver)\n");\r\ndd->flags &= ~QIB_INITTED;\r\n*dd->devstatusp |= QIB_STATUS_HWERROR;\r\n*dd->pport->statusp &= ~QIB_STATUS_IB_CONF;\r\n}\r\nif (*msg && iserr)\r\nqib_dev_porterr(dd, ppd->port, "%s error\n", msg);\r\nif (ppd->state_wanted & ppd->lflags)\r\nwake_up_interruptible(&ppd->state_wait);\r\nif (errs & (ERR_MASK(RcvEgrFullErr) | ERR_MASK(RcvHdrFullErr))) {\r\nqib_handle_urcv(dd, ~0U);\r\nif (errs & ERR_MASK(RcvEgrFullErr))\r\nqib_stats.sps_buffull++;\r\nelse\r\nqib_stats.sps_hdrfull++;\r\n}\r\ndone:\r\nreturn;\r\n}\r\nstatic void qib_7220_set_intr_state(struct qib_devdata *dd, u32 enable)\r\n{\r\nif (enable) {\r\nif (dd->flags & QIB_BADINTR)\r\nreturn;\r\nqib_write_kreg(dd, kr_intmask, ~0ULL);\r\nqib_write_kreg(dd, kr_intclear, 0ULL);\r\n} else\r\nqib_write_kreg(dd, kr_intmask, 0ULL);\r\n}\r\nstatic void qib_7220_clear_freeze(struct qib_devdata *dd)\r\n{\r\nqib_write_kreg(dd, kr_errmask, 0ULL);\r\nqib_7220_set_intr_state(dd, 0);\r\nqib_cancel_sends(dd->pport);\r\nqib_write_kreg(dd, kr_control, dd->control);\r\nqib_read_kreg32(dd, kr_scratch);\r\nqib_force_pio_avail_update(dd);\r\nqib_write_kreg(dd, kr_hwerrclear, 0ULL);\r\nqib_write_kreg(dd, kr_errclear, E_SPKT_ERRS_IGNORE);\r\nqib_write_kreg(dd, kr_errmask, dd->cspec->errormask);\r\nqib_7220_set_intr_state(dd, 1);\r\n}\r\nstatic void qib_7220_handle_hwerrors(struct qib_devdata *dd, char *msg,\r\nsize_t msgl)\r\n{\r\nu64 hwerrs;\r\nu32 bits, ctrl;\r\nint isfatal = 0;\r\nchar *bitsmsg;\r\nint log_idx;\r\nhwerrs = qib_read_kreg64(dd, kr_hwerrstatus);\r\nif (!hwerrs)\r\ngoto bail;\r\nif (hwerrs == ~0ULL) {\r\nqib_dev_err(dd, "Read of hardware error status failed "\r\n"(all bits set); ignoring\n");\r\ngoto bail;\r\n}\r\nqib_stats.sps_hwerrs++;\r\nqib_write_kreg(dd, kr_hwerrclear,\r\nhwerrs & ~HWE_MASK(PowerOnBISTFailed));\r\nhwerrs &= dd->cspec->hwerrmask;\r\nfor (log_idx = 0; log_idx < QIB_EEP_LOG_CNT; ++log_idx)\r\nif (hwerrs & dd->eep_st_masks[log_idx].hwerrs_to_log)\r\nqib_inc_eeprom_err(dd, log_idx, 1);\r\nif (hwerrs & ~(TXEMEMPARITYERR_PIOBUF | TXEMEMPARITYERR_PIOPBC |\r\nRXE_PARITY))\r\nqib_devinfo(dd->pcidev, "Hardware error: hwerr=0x%llx "\r\n"(cleared)\n", (unsigned long long) hwerrs);\r\nif (hwerrs & ~IB_HWE_BITSEXTANT)\r\nqib_dev_err(dd, "hwerror interrupt with unknown errors "\r\n"%llx set\n", (unsigned long long)\r\n(hwerrs & ~IB_HWE_BITSEXTANT));\r\nif (hwerrs & QLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR)\r\nqib_sd7220_clr_ibpar(dd);\r\nctrl = qib_read_kreg32(dd, kr_control);\r\nif ((ctrl & QLOGIC_IB_C_FREEZEMODE) && !dd->diag_client) {\r\nif (hwerrs & (TXEMEMPARITYERR_PIOBUF |\r\nTXEMEMPARITYERR_PIOPBC)) {\r\nqib_7220_txe_recover(dd);\r\nhwerrs &= ~(TXEMEMPARITYERR_PIOBUF |\r\nTXEMEMPARITYERR_PIOPBC);\r\n}\r\nif (hwerrs)\r\nisfatal = 1;\r\nelse\r\nqib_7220_clear_freeze(dd);\r\n}\r\n*msg = '\0';\r\nif (hwerrs & HWE_MASK(PowerOnBISTFailed)) {\r\nisfatal = 1;\r\nstrlcat(msg, "[Memory BIST test failed, "\r\n"InfiniPath hardware unusable]", msgl);\r\ndd->cspec->hwerrmask &= ~HWE_MASK(PowerOnBISTFailed);\r\nqib_write_kreg(dd, kr_hwerrmask, dd->cspec->hwerrmask);\r\n}\r\nqib_format_hwerrors(hwerrs, qib_7220_hwerror_msgs,\r\nARRAY_SIZE(qib_7220_hwerror_msgs), msg, msgl);\r\nbitsmsg = dd->cspec->bitsmsgbuf;\r\nif (hwerrs & (QLOGIC_IB_HWE_PCIEMEMPARITYERR_MASK <<\r\nQLOGIC_IB_HWE_PCIEMEMPARITYERR_SHIFT)) {\r\nbits = (u32) ((hwerrs >>\r\nQLOGIC_IB_HWE_PCIEMEMPARITYERR_SHIFT) &\r\nQLOGIC_IB_HWE_PCIEMEMPARITYERR_MASK);\r\nsnprintf(bitsmsg, sizeof dd->cspec->bitsmsgbuf,\r\n"[PCIe Mem Parity Errs %x] ", bits);\r\nstrlcat(msg, bitsmsg, msgl);\r\n}\r\n#define _QIB_PLL_FAIL (QLOGIC_IB_HWE_COREPLL_FBSLIP | \\r\nQLOGIC_IB_HWE_COREPLL_RFSLIP)\r\nif (hwerrs & _QIB_PLL_FAIL) {\r\nisfatal = 1;\r\nsnprintf(bitsmsg, sizeof dd->cspec->bitsmsgbuf,\r\n"[PLL failed (%llx), InfiniPath hardware unusable]",\r\n(unsigned long long) hwerrs & _QIB_PLL_FAIL);\r\nstrlcat(msg, bitsmsg, msgl);\r\ndd->cspec->hwerrmask &= ~(hwerrs & _QIB_PLL_FAIL);\r\nqib_write_kreg(dd, kr_hwerrmask, dd->cspec->hwerrmask);\r\n}\r\nif (hwerrs & QLOGIC_IB_HWE_SERDESPLLFAILED) {\r\ndd->cspec->hwerrmask &= ~QLOGIC_IB_HWE_SERDESPLLFAILED;\r\nqib_write_kreg(dd, kr_hwerrmask, dd->cspec->hwerrmask);\r\n}\r\nqib_dev_err(dd, "%s hardware error\n", msg);\r\nif (isfatal && !dd->diag_client) {\r\nqib_dev_err(dd, "Fatal Hardware Error, no longer"\r\n" usable, SN %.16s\n", dd->serial);\r\nif (dd->freezemsg)\r\nsnprintf(dd->freezemsg, dd->freezelen,\r\n"{%s}", msg);\r\nqib_disable_after_error(dd);\r\n}\r\nbail:;\r\n}\r\nstatic void qib_7220_init_hwerrors(struct qib_devdata *dd)\r\n{\r\nu64 val;\r\nu64 extsval;\r\nextsval = qib_read_kreg64(dd, kr_extstatus);\r\nif (!(extsval & (QLOGIC_IB_EXTS_MEMBIST_ENDTEST |\r\nQLOGIC_IB_EXTS_MEMBIST_DISABLED)))\r\nqib_dev_err(dd, "MemBIST did not complete!\n");\r\nif (extsval & QLOGIC_IB_EXTS_MEMBIST_DISABLED)\r\nqib_devinfo(dd->pcidev, "MemBIST is disabled.\n");\r\nval = ~0ULL;\r\nval &= ~QLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR;\r\ndd->cspec->hwerrmask = val;\r\nqib_write_kreg(dd, kr_hwerrclear, ~HWE_MASK(PowerOnBISTFailed));\r\nqib_write_kreg(dd, kr_hwerrmask, dd->cspec->hwerrmask);\r\nqib_write_kreg(dd, kr_errclear, ~0ULL);\r\nqib_write_kreg(dd, kr_errmask, ~0ULL);\r\ndd->cspec->errormask = qib_read_kreg64(dd, kr_errmask);\r\nqib_write_kreg(dd, kr_intclear, ~0ULL);\r\n}\r\nstatic void qib_set_7220_armlaunch(struct qib_devdata *dd, u32 enable)\r\n{\r\nif (enable) {\r\nqib_write_kreg(dd, kr_errclear, ERR_MASK(SendPioArmLaunchErr));\r\ndd->cspec->errormask |= ERR_MASK(SendPioArmLaunchErr);\r\n} else\r\ndd->cspec->errormask &= ~ERR_MASK(SendPioArmLaunchErr);\r\nqib_write_kreg(dd, kr_errmask, dd->cspec->errormask);\r\n}\r\nstatic void qib_set_ib_7220_lstate(struct qib_pportdata *ppd, u16 linkcmd,\r\nu16 linitcmd)\r\n{\r\nu64 mod_wd;\r\nstruct qib_devdata *dd = ppd->dd;\r\nunsigned long flags;\r\nif (linitcmd == QLOGIC_IB_IBCC_LINKINITCMD_DISABLE) {\r\nspin_lock_irqsave(&ppd->lflags_lock, flags);\r\nppd->lflags |= QIBL_IB_LINK_DISABLED;\r\nspin_unlock_irqrestore(&ppd->lflags_lock, flags);\r\n} else if (linitcmd || linkcmd == QLOGIC_IB_IBCC_LINKCMD_DOWN) {\r\nspin_lock_irqsave(&ppd->lflags_lock, flags);\r\nppd->lflags &= ~QIBL_IB_LINK_DISABLED;\r\nspin_unlock_irqrestore(&ppd->lflags_lock, flags);\r\n}\r\nmod_wd = (linkcmd << IBA7220_IBCC_LINKCMD_SHIFT) |\r\n(linitcmd << QLOGIC_IB_IBCC_LINKINITCMD_SHIFT);\r\nqib_write_kreg(dd, kr_ibcctrl, ppd->cpspec->ibcctrl | mod_wd);\r\nqib_write_kreg(dd, kr_scratch, 0);\r\n}\r\nstatic int qib_7220_bringup_serdes(struct qib_pportdata *ppd)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nu64 val, prev_val, guid, ibc;\r\nint ret = 0;\r\ndd->control &= ~QLOGIC_IB_C_LINKENABLE;\r\nqib_write_kreg(dd, kr_control, 0ULL);\r\nif (qib_compat_ddr_negotiate) {\r\nppd->cpspec->ibdeltainprog = 1;\r\nppd->cpspec->ibsymsnap = read_7220_creg32(dd, cr_ibsymbolerr);\r\nppd->cpspec->iblnkerrsnap =\r\nread_7220_creg32(dd, cr_iblinkerrrecov);\r\n}\r\nibc = 0x5ULL << SYM_LSB(IBCCtrl, FlowCtrlWaterMark);\r\nibc |= 0x3ULL << SYM_LSB(IBCCtrl, FlowCtrlPeriod);\r\nibc |= 0xfULL << SYM_LSB(IBCCtrl, PhyerrThreshold);\r\nibc |= 4ULL << SYM_LSB(IBCCtrl, CreditScale);\r\nibc |= 0xfULL << SYM_LSB(IBCCtrl, OverrunThreshold);\r\nibc |= ((u64)(ppd->ibmaxlen >> 2) + 1) << SYM_LSB(IBCCtrl, MaxPktLen);\r\nppd->cpspec->ibcctrl = ibc;\r\nval = ppd->cpspec->ibcctrl | (QLOGIC_IB_IBCC_LINKINITCMD_DISABLE <<\r\nQLOGIC_IB_IBCC_LINKINITCMD_SHIFT);\r\nqib_write_kreg(dd, kr_ibcctrl, val);\r\nif (!ppd->cpspec->ibcddrctrl) {\r\nppd->cpspec->ibcddrctrl = qib_read_kreg64(dd, kr_ibcddrctrl);\r\nif (ppd->link_speed_enabled == (QIB_IB_SDR | QIB_IB_DDR))\r\nppd->cpspec->ibcddrctrl |=\r\nIBA7220_IBC_SPEED_AUTONEG_MASK |\r\nIBA7220_IBC_IBTA_1_2_MASK;\r\nelse\r\nppd->cpspec->ibcddrctrl |=\r\nppd->link_speed_enabled == QIB_IB_DDR ?\r\nIBA7220_IBC_SPEED_DDR : IBA7220_IBC_SPEED_SDR;\r\nif ((ppd->link_width_enabled & (IB_WIDTH_1X | IB_WIDTH_4X)) ==\r\n(IB_WIDTH_1X | IB_WIDTH_4X))\r\nppd->cpspec->ibcddrctrl |= IBA7220_IBC_WIDTH_AUTONEG;\r\nelse\r\nppd->cpspec->ibcddrctrl |=\r\nppd->link_width_enabled == IB_WIDTH_4X ?\r\nIBA7220_IBC_WIDTH_4X_ONLY :\r\nIBA7220_IBC_WIDTH_1X_ONLY;\r\nppd->cpspec->ibcddrctrl |=\r\nIBA7220_IBC_RXPOL_MASK << IBA7220_IBC_RXPOL_SHIFT;\r\nppd->cpspec->ibcddrctrl |=\r\nIBA7220_IBC_HRTBT_MASK << IBA7220_IBC_HRTBT_SHIFT;\r\nppd->cpspec->ibcddrctrl |= IBA7220_IBC_LANE_REV_SUPPORTED;\r\n} else\r\nqib_write_kreg(dd, kr_scratch, 0);\r\nqib_write_kreg(dd, kr_ibcddrctrl, ppd->cpspec->ibcddrctrl);\r\nqib_write_kreg(dd, kr_scratch, 0);\r\nqib_write_kreg(dd, kr_ncmodectrl, 0Ull);\r\nqib_write_kreg(dd, kr_scratch, 0);\r\nret = qib_sd7220_init(dd);\r\nval = qib_read_kreg64(dd, kr_xgxs_cfg);\r\nprev_val = val;\r\nval |= QLOGIC_IB_XGXS_FC_SAFE;\r\nif (val != prev_val) {\r\nqib_write_kreg(dd, kr_xgxs_cfg, val);\r\nqib_read_kreg32(dd, kr_scratch);\r\n}\r\nif (val & QLOGIC_IB_XGXS_RESET)\r\nval &= ~QLOGIC_IB_XGXS_RESET;\r\nif (val != prev_val)\r\nqib_write_kreg(dd, kr_xgxs_cfg, val);\r\nif (!ppd->guid)\r\nppd->guid = dd->base_guid;\r\nguid = be64_to_cpu(ppd->guid);\r\nqib_write_kreg(dd, kr_hrtbt_guid, guid);\r\nif (!ret) {\r\ndd->control |= QLOGIC_IB_C_LINKENABLE;\r\nqib_write_kreg(dd, kr_control, dd->control);\r\n} else\r\nqib_write_kreg(dd, kr_scratch, 0);\r\nreturn ret;\r\n}\r\nstatic void qib_7220_quiet_serdes(struct qib_pportdata *ppd)\r\n{\r\nu64 val;\r\nstruct qib_devdata *dd = ppd->dd;\r\nunsigned long flags;\r\ndd->control &= ~QLOGIC_IB_C_LINKENABLE;\r\nqib_write_kreg(dd, kr_control,\r\ndd->control | QLOGIC_IB_C_FREEZEMODE);\r\nppd->cpspec->chase_end = 0;\r\nif (ppd->cpspec->chase_timer.data)\r\ndel_timer_sync(&ppd->cpspec->chase_timer);\r\nif (ppd->cpspec->ibsymdelta || ppd->cpspec->iblnkerrdelta ||\r\nppd->cpspec->ibdeltainprog) {\r\nu64 diagc;\r\ndiagc = qib_read_kreg64(dd, kr_hwdiagctrl);\r\nqib_write_kreg(dd, kr_hwdiagctrl,\r\ndiagc | SYM_MASK(HwDiagCtrl, CounterWrEnable));\r\nif (ppd->cpspec->ibsymdelta || ppd->cpspec->ibdeltainprog) {\r\nval = read_7220_creg32(dd, cr_ibsymbolerr);\r\nif (ppd->cpspec->ibdeltainprog)\r\nval -= val - ppd->cpspec->ibsymsnap;\r\nval -= ppd->cpspec->ibsymdelta;\r\nwrite_7220_creg(dd, cr_ibsymbolerr, val);\r\n}\r\nif (ppd->cpspec->iblnkerrdelta || ppd->cpspec->ibdeltainprog) {\r\nval = read_7220_creg32(dd, cr_iblinkerrrecov);\r\nif (ppd->cpspec->ibdeltainprog)\r\nval -= val - ppd->cpspec->iblnkerrsnap;\r\nval -= ppd->cpspec->iblnkerrdelta;\r\nwrite_7220_creg(dd, cr_iblinkerrrecov, val);\r\n}\r\nqib_write_kreg(dd, kr_hwdiagctrl, diagc);\r\n}\r\nqib_set_ib_7220_lstate(ppd, 0, QLOGIC_IB_IBCC_LINKINITCMD_DISABLE);\r\nspin_lock_irqsave(&ppd->lflags_lock, flags);\r\nppd->lflags &= ~QIBL_IB_AUTONEG_INPROG;\r\nspin_unlock_irqrestore(&ppd->lflags_lock, flags);\r\nwake_up(&ppd->cpspec->autoneg_wait);\r\ncancel_delayed_work_sync(&ppd->cpspec->autoneg_work);\r\nshutdown_7220_relock_poll(ppd->dd);\r\nval = qib_read_kreg64(ppd->dd, kr_xgxs_cfg);\r\nval |= QLOGIC_IB_XGXS_RESET;\r\nqib_write_kreg(ppd->dd, kr_xgxs_cfg, val);\r\n}\r\nstatic void qib_setup_7220_setextled(struct qib_pportdata *ppd, u32 on)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nu64 extctl, ledblink = 0, val, lst, ltst;\r\nunsigned long flags;\r\nif (dd->diag_client)\r\nreturn;\r\nif (ppd->led_override) {\r\nltst = (ppd->led_override & QIB_LED_PHYS) ?\r\nIB_PHYSPORTSTATE_LINKUP : IB_PHYSPORTSTATE_DISABLED,\r\nlst = (ppd->led_override & QIB_LED_LOG) ?\r\nIB_PORT_ACTIVE : IB_PORT_DOWN;\r\n} else if (on) {\r\nval = qib_read_kreg64(dd, kr_ibcstatus);\r\nltst = qib_7220_phys_portstate(val);\r\nlst = qib_7220_iblink_state(val);\r\n} else {\r\nltst = 0;\r\nlst = 0;\r\n}\r\nspin_lock_irqsave(&dd->cspec->gpio_lock, flags);\r\nextctl = dd->cspec->extctrl & ~(SYM_MASK(EXTCtrl, LEDPriPortGreenOn) |\r\nSYM_MASK(EXTCtrl, LEDPriPortYellowOn));\r\nif (ltst == IB_PHYSPORTSTATE_LINKUP) {\r\nextctl |= SYM_MASK(EXTCtrl, LEDPriPortGreenOn);\r\nledblink = ((66600 * 1000UL / 4) << IBA7220_LEDBLINK_ON_SHIFT)\r\n| ((187500 * 1000UL / 4) << IBA7220_LEDBLINK_OFF_SHIFT);\r\n}\r\nif (lst == IB_PORT_ACTIVE)\r\nextctl |= SYM_MASK(EXTCtrl, LEDPriPortYellowOn);\r\ndd->cspec->extctrl = extctl;\r\nqib_write_kreg(dd, kr_extctrl, extctl);\r\nspin_unlock_irqrestore(&dd->cspec->gpio_lock, flags);\r\nif (ledblink)\r\nqib_write_kreg(dd, kr_rcvpktledcnt, ledblink);\r\n}\r\nstatic void qib_7220_free_irq(struct qib_devdata *dd)\r\n{\r\nif (dd->cspec->irq) {\r\nfree_irq(dd->cspec->irq, dd);\r\ndd->cspec->irq = 0;\r\n}\r\nqib_nomsi(dd);\r\n}\r\nstatic void qib_setup_7220_cleanup(struct qib_devdata *dd)\r\n{\r\nqib_7220_free_irq(dd);\r\nkfree(dd->cspec->cntrs);\r\nkfree(dd->cspec->portcntrs);\r\n}\r\nstatic void sdma_7220_intr(struct qib_pportdata *ppd, u64 istat)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ppd->sdma_lock, flags);\r\nswitch (ppd->sdma_state.current_state) {\r\ncase qib_sdma_state_s00_hw_down:\r\nbreak;\r\ncase qib_sdma_state_s10_hw_start_up_wait:\r\n__qib_sdma_process_event(ppd, qib_sdma_event_e20_hw_started);\r\nbreak;\r\ncase qib_sdma_state_s20_idle:\r\nbreak;\r\ncase qib_sdma_state_s30_sw_clean_up_wait:\r\nbreak;\r\ncase qib_sdma_state_s40_hw_clean_up_wait:\r\nbreak;\r\ncase qib_sdma_state_s50_hw_halt_wait:\r\n__qib_sdma_process_event(ppd, qib_sdma_event_e60_hw_halted);\r\nbreak;\r\ncase qib_sdma_state_s99_running:\r\n__qib_sdma_intr(ppd);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&ppd->sdma_lock, flags);\r\n}\r\nstatic void qib_wantpiobuf_7220_intr(struct qib_devdata *dd, u32 needint)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dd->sendctrl_lock, flags);\r\nif (needint) {\r\nif (!(dd->sendctrl & SYM_MASK(SendCtrl, SendBufAvailUpd)))\r\ngoto done;\r\nqib_write_kreg(dd, kr_sendctrl, dd->sendctrl &\r\n~SYM_MASK(SendCtrl, SendBufAvailUpd));\r\nqib_write_kreg(dd, kr_scratch, 0ULL);\r\ndd->sendctrl |= SYM_MASK(SendCtrl, SendIntBufAvail);\r\n} else\r\ndd->sendctrl &= ~SYM_MASK(SendCtrl, SendIntBufAvail);\r\nqib_write_kreg(dd, kr_sendctrl, dd->sendctrl);\r\nqib_write_kreg(dd, kr_scratch, 0ULL);\r\ndone:\r\nspin_unlock_irqrestore(&dd->sendctrl_lock, flags);\r\n}\r\nstatic noinline void unlikely_7220_intr(struct qib_devdata *dd, u64 istat)\r\n{\r\nif (unlikely(istat & ~QLOGIC_IB_I_BITSEXTANT))\r\nqib_dev_err(dd,\r\n"interrupt with unknown interrupts %Lx set\n",\r\nistat & ~QLOGIC_IB_I_BITSEXTANT);\r\nif (istat & QLOGIC_IB_I_GPIO) {\r\nu32 gpiostatus;\r\ngpiostatus = qib_read_kreg32(dd, kr_gpio_status);\r\nqib_write_kreg(dd, kr_gpio_clear, gpiostatus);\r\nif (gpiostatus) {\r\nconst u32 mask = qib_read_kreg32(dd, kr_gpio_mask);\r\nu32 gpio_irq = mask & gpiostatus;\r\ndd->cspec->gpio_mask &= ~gpio_irq;\r\nqib_write_kreg(dd, kr_gpio_mask, dd->cspec->gpio_mask);\r\n}\r\n}\r\nif (istat & QLOGIC_IB_I_ERROR) {\r\nu64 estat;\r\nqib_stats.sps_errints++;\r\nestat = qib_read_kreg64(dd, kr_errstatus);\r\nif (!estat)\r\nqib_devinfo(dd->pcidev, "error interrupt (%Lx), "\r\n"but no error bits set!\n", istat);\r\nelse\r\nhandle_7220_errors(dd, estat);\r\n}\r\n}\r\nstatic irqreturn_t qib_7220intr(int irq, void *data)\r\n{\r\nstruct qib_devdata *dd = data;\r\nirqreturn_t ret;\r\nu64 istat;\r\nu64 ctxtrbits;\r\nu64 rmask;\r\nunsigned i;\r\nif ((dd->flags & (QIB_PRESENT | QIB_BADINTR)) != QIB_PRESENT) {\r\nret = IRQ_HANDLED;\r\ngoto bail;\r\n}\r\nistat = qib_read_kreg64(dd, kr_intstatus);\r\nif (unlikely(!istat)) {\r\nret = IRQ_NONE;\r\ngoto bail;\r\n}\r\nif (unlikely(istat == -1)) {\r\nqib_bad_intrstatus(dd);\r\nret = IRQ_NONE;\r\ngoto bail;\r\n}\r\nqib_stats.sps_ints++;\r\nif (dd->int_counter != (u32) -1)\r\ndd->int_counter++;\r\nif (unlikely(istat & (~QLOGIC_IB_I_BITSEXTANT |\r\nQLOGIC_IB_I_GPIO | QLOGIC_IB_I_ERROR)))\r\nunlikely_7220_intr(dd, istat);\r\nqib_write_kreg(dd, kr_intclear, istat);\r\nctxtrbits = istat &\r\n((QLOGIC_IB_I_RCVAVAIL_MASK << QLOGIC_IB_I_RCVAVAIL_SHIFT) |\r\n(QLOGIC_IB_I_RCVURG_MASK << QLOGIC_IB_I_RCVURG_SHIFT));\r\nif (ctxtrbits) {\r\nrmask = (1ULL << QLOGIC_IB_I_RCVAVAIL_SHIFT) |\r\n(1ULL << QLOGIC_IB_I_RCVURG_SHIFT);\r\nfor (i = 0; i < dd->first_user_ctxt; i++) {\r\nif (ctxtrbits & rmask) {\r\nctxtrbits &= ~rmask;\r\nqib_kreceive(dd->rcd[i], NULL, NULL);\r\n}\r\nrmask <<= 1;\r\n}\r\nif (ctxtrbits) {\r\nctxtrbits =\r\n(ctxtrbits >> QLOGIC_IB_I_RCVAVAIL_SHIFT) |\r\n(ctxtrbits >> QLOGIC_IB_I_RCVURG_SHIFT);\r\nqib_handle_urcv(dd, ctxtrbits);\r\n}\r\n}\r\nif (istat & QLOGIC_IB_I_SDMAINT)\r\nsdma_7220_intr(dd->pport, istat);\r\nif ((istat & QLOGIC_IB_I_SPIOBUFAVAIL) && (dd->flags & QIB_INITTED))\r\nqib_ib_piobufavail(dd);\r\nret = IRQ_HANDLED;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic void qib_setup_7220_interrupt(struct qib_devdata *dd)\r\n{\r\nif (!dd->cspec->irq)\r\nqib_dev_err(dd, "irq is 0, BIOS error? Interrupts won't "\r\n"work\n");\r\nelse {\r\nint ret = request_irq(dd->cspec->irq, qib_7220intr,\r\ndd->msi_lo ? 0 : IRQF_SHARED,\r\nQIB_DRV_NAME, dd);\r\nif (ret)\r\nqib_dev_err(dd, "Couldn't setup %s interrupt "\r\n"(irq=%d): %d\n", dd->msi_lo ?\r\n"MSI" : "INTx", dd->cspec->irq, ret);\r\n}\r\n}\r\nstatic void qib_7220_boardname(struct qib_devdata *dd)\r\n{\r\nchar *n;\r\nu32 boardid, namelen;\r\nboardid = SYM_FIELD(dd->revision, Revision,\r\nBoardID);\r\nswitch (boardid) {\r\ncase 1:\r\nn = "InfiniPath_QLE7240";\r\nbreak;\r\ncase 2:\r\nn = "InfiniPath_QLE7280";\r\nbreak;\r\ndefault:\r\nqib_dev_err(dd, "Unknown 7220 board with ID %u\n", boardid);\r\nn = "Unknown_InfiniPath_7220";\r\nbreak;\r\n}\r\nnamelen = strlen(n) + 1;\r\ndd->boardname = kmalloc(namelen, GFP_KERNEL);\r\nif (!dd->boardname)\r\nqib_dev_err(dd, "Failed allocation for board name: %s\n", n);\r\nelse\r\nsnprintf(dd->boardname, namelen, "%s", n);\r\nif (dd->majrev != 5 || !dd->minrev || dd->minrev > 2)\r\nqib_dev_err(dd, "Unsupported InfiniPath hardware "\r\n"revision %u.%u!\n",\r\ndd->majrev, dd->minrev);\r\nsnprintf(dd->boardversion, sizeof(dd->boardversion),\r\n"ChipABI %u.%u, %s, InfiniPath%u %u.%u, SW Compat %u\n",\r\nQIB_CHIP_VERS_MAJ, QIB_CHIP_VERS_MIN, dd->boardname,\r\n(unsigned)SYM_FIELD(dd->revision, Revision_R, Arch),\r\ndd->majrev, dd->minrev,\r\n(unsigned)SYM_FIELD(dd->revision, Revision_R, SW));\r\n}\r\nstatic int qib_setup_7220_reset(struct qib_devdata *dd)\r\n{\r\nu64 val;\r\nint i;\r\nint ret;\r\nu16 cmdval;\r\nu8 int_line, clinesz;\r\nunsigned long flags;\r\nqib_pcie_getcmd(dd, &cmdval, &int_line, &clinesz);\r\nqib_dev_err(dd, "Resetting InfiniPath unit %u\n", dd->unit);\r\nqib_7220_set_intr_state(dd, 0);\r\ndd->pport->cpspec->ibdeltainprog = 0;\r\ndd->pport->cpspec->ibsymdelta = 0;\r\ndd->pport->cpspec->iblnkerrdelta = 0;\r\ndd->flags &= ~(QIB_INITTED | QIB_PRESENT);\r\ndd->int_counter = 0;\r\nval = dd->control | QLOGIC_IB_C_RESET;\r\nwriteq(val, &dd->kregbase[kr_control]);\r\nmb();\r\nfor (i = 1; i <= 5; i++) {\r\nmsleep(1000 + (1 + i) * 2000);\r\nqib_pcie_reenable(dd, cmdval, int_line, clinesz);\r\nval = readq(&dd->kregbase[kr_revision]);\r\nif (val == dd->revision) {\r\ndd->flags |= QIB_PRESENT;\r\nret = qib_reinit_intr(dd);\r\ngoto bail;\r\n}\r\n}\r\nret = 0;\r\nbail:\r\nif (ret) {\r\nif (qib_pcie_params(dd, dd->lbus_width, NULL, NULL))\r\nqib_dev_err(dd, "Reset failed to setup PCIe or "\r\n"interrupts; continuing anyway\n");\r\nqib_write_kreg(dd, kr_control, 0ULL);\r\nqib_7220_init_hwerrors(dd);\r\nif (dd->pport->cpspec->ibcddrctrl & IBA7220_IBC_IBTA_1_2_MASK)\r\ndd->cspec->presets_needed = 1;\r\nspin_lock_irqsave(&dd->pport->lflags_lock, flags);\r\ndd->pport->lflags |= QIBL_IB_FORCE_NOTIFY;\r\ndd->pport->lflags &= ~QIBL_IB_AUTONEG_FAILED;\r\nspin_unlock_irqrestore(&dd->pport->lflags_lock, flags);\r\n}\r\nreturn ret;\r\n}\r\nstatic void qib_7220_put_tid(struct qib_devdata *dd, u64 __iomem *tidptr,\r\nu32 type, unsigned long pa)\r\n{\r\nif (pa != dd->tidinvalid) {\r\nu64 chippa = pa >> IBA7220_TID_PA_SHIFT;\r\nif (pa != (chippa << IBA7220_TID_PA_SHIFT)) {\r\nqib_dev_err(dd, "Physaddr %lx not 2KB aligned!\n",\r\npa);\r\nreturn;\r\n}\r\nif (chippa >= (1UL << IBA7220_TID_SZ_SHIFT)) {\r\nqib_dev_err(dd, "Physical page address 0x%lx "\r\n"larger than supported\n", pa);\r\nreturn;\r\n}\r\nif (type == RCVHQ_RCV_TYPE_EAGER)\r\nchippa |= dd->tidtemplate;\r\nelse\r\nchippa |= IBA7220_TID_SZ_4K;\r\npa = chippa;\r\n}\r\nwriteq(pa, tidptr);\r\nmmiowb();\r\n}\r\nstatic void qib_7220_clear_tids(struct qib_devdata *dd,\r\nstruct qib_ctxtdata *rcd)\r\n{\r\nu64 __iomem *tidbase;\r\nunsigned long tidinv;\r\nu32 ctxt;\r\nint i;\r\nif (!dd->kregbase || !rcd)\r\nreturn;\r\nctxt = rcd->ctxt;\r\ntidinv = dd->tidinvalid;\r\ntidbase = (u64 __iomem *)\r\n((char __iomem *)(dd->kregbase) +\r\ndd->rcvtidbase +\r\nctxt * dd->rcvtidcnt * sizeof(*tidbase));\r\nfor (i = 0; i < dd->rcvtidcnt; i++)\r\nqib_7220_put_tid(dd, &tidbase[i], RCVHQ_RCV_TYPE_EXPECTED,\r\ntidinv);\r\ntidbase = (u64 __iomem *)\r\n((char __iomem *)(dd->kregbase) +\r\ndd->rcvegrbase +\r\nrcd->rcvegr_tid_base * sizeof(*tidbase));\r\nfor (i = 0; i < rcd->rcvegrcnt; i++)\r\nqib_7220_put_tid(dd, &tidbase[i], RCVHQ_RCV_TYPE_EAGER,\r\ntidinv);\r\n}\r\nstatic void qib_7220_tidtemplate(struct qib_devdata *dd)\r\n{\r\nif (dd->rcvegrbufsize == 2048)\r\ndd->tidtemplate = IBA7220_TID_SZ_2K;\r\nelse if (dd->rcvegrbufsize == 4096)\r\ndd->tidtemplate = IBA7220_TID_SZ_4K;\r\ndd->tidinvalid = 0;\r\n}\r\nstatic int qib_7220_get_base_info(struct qib_ctxtdata *rcd,\r\nstruct qib_base_info *kinfo)\r\n{\r\nkinfo->spi_runtime_flags |= QIB_RUNTIME_PCIE |\r\nQIB_RUNTIME_NODMA_RTAIL | QIB_RUNTIME_SDMA;\r\nif (rcd->dd->flags & QIB_USE_SPCL_TRIG)\r\nkinfo->spi_runtime_flags |= QIB_RUNTIME_SPECIAL_TRIGGER;\r\nreturn 0;\r\n}\r\nstatic struct qib_message_header *\r\nqib_7220_get_msgheader(struct qib_devdata *dd, __le32 *rhf_addr)\r\n{\r\nu32 offset = qib_hdrget_offset(rhf_addr);\r\nreturn (struct qib_message_header *)\r\n(rhf_addr - dd->rhf_offset + offset);\r\n}\r\nstatic void qib_7220_config_ctxts(struct qib_devdata *dd)\r\n{\r\nunsigned long flags;\r\nu32 nchipctxts;\r\nnchipctxts = qib_read_kreg32(dd, kr_portcnt);\r\ndd->cspec->numctxts = nchipctxts;\r\nif (qib_n_krcv_queues > 1) {\r\ndd->qpn_mask = 0x3e;\r\ndd->first_user_ctxt = qib_n_krcv_queues * dd->num_pports;\r\nif (dd->first_user_ctxt > nchipctxts)\r\ndd->first_user_ctxt = nchipctxts;\r\n} else\r\ndd->first_user_ctxt = dd->num_pports;\r\ndd->n_krcv_queues = dd->first_user_ctxt;\r\nif (!qib_cfgctxts) {\r\nint nctxts = dd->first_user_ctxt + num_online_cpus();\r\nif (nctxts <= 5)\r\ndd->ctxtcnt = 5;\r\nelse if (nctxts <= 9)\r\ndd->ctxtcnt = 9;\r\nelse if (nctxts <= nchipctxts)\r\ndd->ctxtcnt = nchipctxts;\r\n} else if (qib_cfgctxts <= nchipctxts)\r\ndd->ctxtcnt = qib_cfgctxts;\r\nif (!dd->ctxtcnt)\r\ndd->ctxtcnt = nchipctxts;\r\nspin_lock_irqsave(&dd->cspec->rcvmod_lock, flags);\r\nif (dd->ctxtcnt > 9)\r\ndd->rcvctrl |= 2ULL << IBA7220_R_CTXTCFG_SHIFT;\r\nelse if (dd->ctxtcnt > 5)\r\ndd->rcvctrl |= 1ULL << IBA7220_R_CTXTCFG_SHIFT;\r\nif (dd->qpn_mask)\r\ndd->rcvctrl |= 1ULL << QIB_7220_RcvCtrl_RcvQPMapEnable_LSB;\r\nqib_write_kreg(dd, kr_rcvctrl, dd->rcvctrl);\r\nspin_unlock_irqrestore(&dd->cspec->rcvmod_lock, flags);\r\ndd->cspec->rcvegrcnt = qib_read_kreg32(dd, kr_rcvegrcnt);\r\ndd->rcvhdrcnt = max(dd->cspec->rcvegrcnt, IBA7220_KRCVEGRCNT);\r\n}\r\nstatic int qib_7220_get_ib_cfg(struct qib_pportdata *ppd, int which)\r\n{\r\nint lsb, ret = 0;\r\nu64 maskr;\r\nswitch (which) {\r\ncase QIB_IB_CFG_LWID_ENB:\r\nret = ppd->link_width_enabled;\r\ngoto done;\r\ncase QIB_IB_CFG_LWID:\r\nret = ppd->link_width_active;\r\ngoto done;\r\ncase QIB_IB_CFG_SPD_ENB:\r\nret = ppd->link_speed_enabled;\r\ngoto done;\r\ncase QIB_IB_CFG_SPD:\r\nret = ppd->link_speed_active;\r\ngoto done;\r\ncase QIB_IB_CFG_RXPOL_ENB:\r\nlsb = IBA7220_IBC_RXPOL_SHIFT;\r\nmaskr = IBA7220_IBC_RXPOL_MASK;\r\nbreak;\r\ncase QIB_IB_CFG_LREV_ENB:\r\nlsb = IBA7220_IBC_LREV_SHIFT;\r\nmaskr = IBA7220_IBC_LREV_MASK;\r\nbreak;\r\ncase QIB_IB_CFG_LINKLATENCY:\r\nret = qib_read_kreg64(ppd->dd, kr_ibcddrstatus)\r\n& IBA7220_DDRSTAT_LINKLAT_MASK;\r\ngoto done;\r\ncase QIB_IB_CFG_OP_VLS:\r\nret = ppd->vls_operational;\r\ngoto done;\r\ncase QIB_IB_CFG_VL_HIGH_CAP:\r\nret = 0;\r\ngoto done;\r\ncase QIB_IB_CFG_VL_LOW_CAP:\r\nret = 0;\r\ngoto done;\r\ncase QIB_IB_CFG_OVERRUN_THRESH:\r\nret = SYM_FIELD(ppd->cpspec->ibcctrl, IBCCtrl,\r\nOverrunThreshold);\r\ngoto done;\r\ncase QIB_IB_CFG_PHYERR_THRESH:\r\nret = SYM_FIELD(ppd->cpspec->ibcctrl, IBCCtrl,\r\nPhyerrThreshold);\r\ngoto done;\r\ncase QIB_IB_CFG_LINKDEFAULT:\r\nret = (ppd->cpspec->ibcctrl &\r\nSYM_MASK(IBCCtrl, LinkDownDefaultState)) ?\r\nIB_LINKINITCMD_SLEEP : IB_LINKINITCMD_POLL;\r\ngoto done;\r\ncase QIB_IB_CFG_HRTBT:\r\nlsb = IBA7220_IBC_HRTBT_SHIFT;\r\nmaskr = IBA7220_IBC_HRTBT_MASK;\r\nbreak;\r\ncase QIB_IB_CFG_PMA_TICKS:\r\nret = (ppd->link_speed_active == QIB_IB_DDR);\r\ngoto done;\r\ndefault:\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nret = (int)((ppd->cpspec->ibcddrctrl >> lsb) & maskr);\r\ndone:\r\nreturn ret;\r\n}\r\nstatic int qib_7220_set_ib_cfg(struct qib_pportdata *ppd, int which, u32 val)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nu64 maskr;\r\nint lsb, ret = 0, setforce = 0;\r\nu16 lcmd, licmd;\r\nunsigned long flags;\r\nu32 tmp = 0;\r\nswitch (which) {\r\ncase QIB_IB_CFG_LIDLMC:\r\nlsb = IBA7220_IBC_DLIDLMC_SHIFT;\r\nmaskr = IBA7220_IBC_DLIDLMC_MASK;\r\nbreak;\r\ncase QIB_IB_CFG_LWID_ENB:\r\nppd->link_width_enabled = val;\r\nif (!(ppd->lflags & QIBL_LINKDOWN))\r\ngoto bail;\r\nval--;\r\nmaskr = IBA7220_IBC_WIDTH_MASK;\r\nlsb = IBA7220_IBC_WIDTH_SHIFT;\r\nsetforce = 1;\r\nbreak;\r\ncase QIB_IB_CFG_SPD_ENB:\r\nppd->link_speed_enabled = val;\r\nif ((ppd->cpspec->ibcddrctrl & IBA7220_IBC_IBTA_1_2_MASK) &&\r\n!(val & (val - 1)))\r\ndd->cspec->presets_needed = 1;\r\nif (!(ppd->lflags & QIBL_LINKDOWN))\r\ngoto bail;\r\nif (val == (QIB_IB_SDR | QIB_IB_DDR)) {\r\nval = IBA7220_IBC_SPEED_AUTONEG_MASK |\r\nIBA7220_IBC_IBTA_1_2_MASK;\r\nspin_lock_irqsave(&ppd->lflags_lock, flags);\r\nppd->lflags &= ~QIBL_IB_AUTONEG_FAILED;\r\nspin_unlock_irqrestore(&ppd->lflags_lock, flags);\r\n} else\r\nval = val == QIB_IB_DDR ?\r\nIBA7220_IBC_SPEED_DDR : IBA7220_IBC_SPEED_SDR;\r\nmaskr = IBA7220_IBC_SPEED_AUTONEG_MASK |\r\nIBA7220_IBC_IBTA_1_2_MASK;\r\nlsb = SYM_LSB(IBCDDRCtrl, IB_ENHANCED_MODE);\r\nsetforce = 1;\r\nbreak;\r\ncase QIB_IB_CFG_RXPOL_ENB:\r\nlsb = IBA7220_IBC_RXPOL_SHIFT;\r\nmaskr = IBA7220_IBC_RXPOL_MASK;\r\nbreak;\r\ncase QIB_IB_CFG_LREV_ENB:\r\nlsb = IBA7220_IBC_LREV_SHIFT;\r\nmaskr = IBA7220_IBC_LREV_MASK;\r\nbreak;\r\ncase QIB_IB_CFG_OVERRUN_THRESH:\r\nmaskr = SYM_FIELD(ppd->cpspec->ibcctrl, IBCCtrl,\r\nOverrunThreshold);\r\nif (maskr != val) {\r\nppd->cpspec->ibcctrl &=\r\n~SYM_MASK(IBCCtrl, OverrunThreshold);\r\nppd->cpspec->ibcctrl |= (u64) val <<\r\nSYM_LSB(IBCCtrl, OverrunThreshold);\r\nqib_write_kreg(dd, kr_ibcctrl, ppd->cpspec->ibcctrl);\r\nqib_write_kreg(dd, kr_scratch, 0);\r\n}\r\ngoto bail;\r\ncase QIB_IB_CFG_PHYERR_THRESH:\r\nmaskr = SYM_FIELD(ppd->cpspec->ibcctrl, IBCCtrl,\r\nPhyerrThreshold);\r\nif (maskr != val) {\r\nppd->cpspec->ibcctrl &=\r\n~SYM_MASK(IBCCtrl, PhyerrThreshold);\r\nppd->cpspec->ibcctrl |= (u64) val <<\r\nSYM_LSB(IBCCtrl, PhyerrThreshold);\r\nqib_write_kreg(dd, kr_ibcctrl, ppd->cpspec->ibcctrl);\r\nqib_write_kreg(dd, kr_scratch, 0);\r\n}\r\ngoto bail;\r\ncase QIB_IB_CFG_PKEYS:\r\nmaskr = (u64) ppd->pkeys[0] | ((u64) ppd->pkeys[1] << 16) |\r\n((u64) ppd->pkeys[2] << 32) |\r\n((u64) ppd->pkeys[3] << 48);\r\nqib_write_kreg(dd, kr_partitionkey, maskr);\r\ngoto bail;\r\ncase QIB_IB_CFG_LINKDEFAULT:\r\nif (val == IB_LINKINITCMD_POLL)\r\nppd->cpspec->ibcctrl &=\r\n~SYM_MASK(IBCCtrl, LinkDownDefaultState);\r\nelse\r\nppd->cpspec->ibcctrl |=\r\nSYM_MASK(IBCCtrl, LinkDownDefaultState);\r\nqib_write_kreg(dd, kr_ibcctrl, ppd->cpspec->ibcctrl);\r\nqib_write_kreg(dd, kr_scratch, 0);\r\ngoto bail;\r\ncase QIB_IB_CFG_MTU:\r\nval = (ppd->ibmaxlen >> 2) + 1;\r\nppd->cpspec->ibcctrl &= ~SYM_MASK(IBCCtrl, MaxPktLen);\r\nppd->cpspec->ibcctrl |= (u64)val << SYM_LSB(IBCCtrl, MaxPktLen);\r\nqib_write_kreg(dd, kr_ibcctrl, ppd->cpspec->ibcctrl);\r\nqib_write_kreg(dd, kr_scratch, 0);\r\ngoto bail;\r\ncase QIB_IB_CFG_LSTATE:\r\nswitch (val & 0xffff0000) {\r\ncase IB_LINKCMD_DOWN:\r\nlcmd = QLOGIC_IB_IBCC_LINKCMD_DOWN;\r\nif (!ppd->cpspec->ibdeltainprog &&\r\nqib_compat_ddr_negotiate) {\r\nppd->cpspec->ibdeltainprog = 1;\r\nppd->cpspec->ibsymsnap =\r\nread_7220_creg32(dd, cr_ibsymbolerr);\r\nppd->cpspec->iblnkerrsnap =\r\nread_7220_creg32(dd, cr_iblinkerrrecov);\r\n}\r\nbreak;\r\ncase IB_LINKCMD_ARMED:\r\nlcmd = QLOGIC_IB_IBCC_LINKCMD_ARMED;\r\nbreak;\r\ncase IB_LINKCMD_ACTIVE:\r\nlcmd = QLOGIC_IB_IBCC_LINKCMD_ACTIVE;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nqib_dev_err(dd, "bad linkcmd req 0x%x\n", val >> 16);\r\ngoto bail;\r\n}\r\nswitch (val & 0xffff) {\r\ncase IB_LINKINITCMD_NOP:\r\nlicmd = 0;\r\nbreak;\r\ncase IB_LINKINITCMD_POLL:\r\nlicmd = QLOGIC_IB_IBCC_LINKINITCMD_POLL;\r\nbreak;\r\ncase IB_LINKINITCMD_SLEEP:\r\nlicmd = QLOGIC_IB_IBCC_LINKINITCMD_SLEEP;\r\nbreak;\r\ncase IB_LINKINITCMD_DISABLE:\r\nlicmd = QLOGIC_IB_IBCC_LINKINITCMD_DISABLE;\r\nppd->cpspec->chase_end = 0;\r\nif (ppd->cpspec->chase_timer.expires) {\r\ndel_timer_sync(&ppd->cpspec->chase_timer);\r\nppd->cpspec->chase_timer.expires = 0;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nqib_dev_err(dd, "bad linkinitcmd req 0x%x\n",\r\nval & 0xffff);\r\ngoto bail;\r\n}\r\nqib_set_ib_7220_lstate(ppd, lcmd, licmd);\r\nmaskr = IBA7220_IBC_WIDTH_MASK;\r\nlsb = IBA7220_IBC_WIDTH_SHIFT;\r\ntmp = (ppd->cpspec->ibcddrctrl >> lsb) & maskr;\r\nif (ppd->link_width_enabled-1 != tmp) {\r\nppd->cpspec->ibcddrctrl &= ~(maskr << lsb);\r\nppd->cpspec->ibcddrctrl |=\r\n(((u64)(ppd->link_width_enabled-1) & maskr) <<\r\nlsb);\r\nqib_write_kreg(dd, kr_ibcddrctrl,\r\nppd->cpspec->ibcddrctrl);\r\nqib_write_kreg(dd, kr_scratch, 0);\r\nspin_lock_irqsave(&ppd->lflags_lock, flags);\r\nppd->lflags |= QIBL_IB_FORCE_NOTIFY;\r\nspin_unlock_irqrestore(&ppd->lflags_lock, flags);\r\n}\r\ngoto bail;\r\ncase QIB_IB_CFG_HRTBT:\r\nif (val > IBA7220_IBC_HRTBT_MASK) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nlsb = IBA7220_IBC_HRTBT_SHIFT;\r\nmaskr = IBA7220_IBC_HRTBT_MASK;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nppd->cpspec->ibcddrctrl &= ~(maskr << lsb);\r\nppd->cpspec->ibcddrctrl |= (((u64) val & maskr) << lsb);\r\nqib_write_kreg(dd, kr_ibcddrctrl, ppd->cpspec->ibcddrctrl);\r\nqib_write_kreg(dd, kr_scratch, 0);\r\nif (setforce) {\r\nspin_lock_irqsave(&ppd->lflags_lock, flags);\r\nppd->lflags |= QIBL_IB_FORCE_NOTIFY;\r\nspin_unlock_irqrestore(&ppd->lflags_lock, flags);\r\n}\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int qib_7220_set_loopback(struct qib_pportdata *ppd, const char *what)\r\n{\r\nint ret = 0;\r\nu64 val, ddr;\r\nif (!strncmp(what, "ibc", 3)) {\r\nppd->cpspec->ibcctrl |= SYM_MASK(IBCCtrl, Loopback);\r\nval = 0;\r\nqib_devinfo(ppd->dd->pcidev, "Enabling IB%u:%u IBC loopback\n",\r\nppd->dd->unit, ppd->port);\r\n} else if (!strncmp(what, "off", 3)) {\r\nppd->cpspec->ibcctrl &= ~SYM_MASK(IBCCtrl, Loopback);\r\nval = IBA7220_IBC_HRTBT_MASK << IBA7220_IBC_HRTBT_SHIFT;\r\nqib_devinfo(ppd->dd->pcidev, "Disabling IB%u:%u IBC loopback "\r\n"(normal)\n", ppd->dd->unit, ppd->port);\r\n} else\r\nret = -EINVAL;\r\nif (!ret) {\r\nqib_write_kreg(ppd->dd, kr_ibcctrl, ppd->cpspec->ibcctrl);\r\nddr = ppd->cpspec->ibcddrctrl & ~(IBA7220_IBC_HRTBT_MASK\r\n<< IBA7220_IBC_HRTBT_SHIFT);\r\nppd->cpspec->ibcddrctrl = ddr | val;\r\nqib_write_kreg(ppd->dd, kr_ibcddrctrl,\r\nppd->cpspec->ibcddrctrl);\r\nqib_write_kreg(ppd->dd, kr_scratch, 0);\r\n}\r\nreturn ret;\r\n}\r\nstatic void qib_update_7220_usrhead(struct qib_ctxtdata *rcd, u64 hd,\r\nu32 updegr, u32 egrhd, u32 npkts)\r\n{\r\nif (updegr)\r\nqib_write_ureg(rcd->dd, ur_rcvegrindexhead, egrhd, rcd->ctxt);\r\nmmiowb();\r\nqib_write_ureg(rcd->dd, ur_rcvhdrhead, hd, rcd->ctxt);\r\nmmiowb();\r\n}\r\nstatic u32 qib_7220_hdrqempty(struct qib_ctxtdata *rcd)\r\n{\r\nu32 head, tail;\r\nhead = qib_read_ureg32(rcd->dd, ur_rcvhdrhead, rcd->ctxt);\r\nif (rcd->rcvhdrtail_kvaddr)\r\ntail = qib_get_rcvhdrtail(rcd);\r\nelse\r\ntail = qib_read_ureg32(rcd->dd, ur_rcvhdrtail, rcd->ctxt);\r\nreturn head == tail;\r\n}\r\nstatic void rcvctrl_7220_mod(struct qib_pportdata *ppd, unsigned int op,\r\nint ctxt)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nu64 mask, val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dd->cspec->rcvmod_lock, flags);\r\nif (op & QIB_RCVCTRL_TAILUPD_ENB)\r\ndd->rcvctrl |= (1ULL << IBA7220_R_TAILUPD_SHIFT);\r\nif (op & QIB_RCVCTRL_TAILUPD_DIS)\r\ndd->rcvctrl &= ~(1ULL << IBA7220_R_TAILUPD_SHIFT);\r\nif (op & QIB_RCVCTRL_PKEY_ENB)\r\ndd->rcvctrl &= ~(1ULL << IBA7220_R_PKEY_DIS_SHIFT);\r\nif (op & QIB_RCVCTRL_PKEY_DIS)\r\ndd->rcvctrl |= (1ULL << IBA7220_R_PKEY_DIS_SHIFT);\r\nif (ctxt < 0)\r\nmask = (1ULL << dd->ctxtcnt) - 1;\r\nelse\r\nmask = (1ULL << ctxt);\r\nif (op & QIB_RCVCTRL_CTXT_ENB) {\r\ndd->rcvctrl |= (mask << SYM_LSB(RcvCtrl, PortEnable));\r\nif (!(dd->flags & QIB_NODMA_RTAIL))\r\ndd->rcvctrl |= 1ULL << IBA7220_R_TAILUPD_SHIFT;\r\nqib_write_kreg_ctxt(dd, kr_rcvhdrtailaddr, ctxt,\r\ndd->rcd[ctxt]->rcvhdrqtailaddr_phys);\r\nqib_write_kreg_ctxt(dd, kr_rcvhdraddr, ctxt,\r\ndd->rcd[ctxt]->rcvhdrq_phys);\r\ndd->rcd[ctxt]->seq_cnt = 1;\r\n}\r\nif (op & QIB_RCVCTRL_CTXT_DIS)\r\ndd->rcvctrl &= ~(mask << SYM_LSB(RcvCtrl, PortEnable));\r\nif (op & QIB_RCVCTRL_INTRAVAIL_ENB)\r\ndd->rcvctrl |= (mask << IBA7220_R_INTRAVAIL_SHIFT);\r\nif (op & QIB_RCVCTRL_INTRAVAIL_DIS)\r\ndd->rcvctrl &= ~(mask << IBA7220_R_INTRAVAIL_SHIFT);\r\nqib_write_kreg(dd, kr_rcvctrl, dd->rcvctrl);\r\nif ((op & QIB_RCVCTRL_INTRAVAIL_ENB) && dd->rhdrhead_intr_off) {\r\nval = qib_read_ureg32(dd, ur_rcvhdrhead, ctxt) |\r\ndd->rhdrhead_intr_off;\r\nqib_write_ureg(dd, ur_rcvhdrhead, val, ctxt);\r\n}\r\nif (op & QIB_RCVCTRL_CTXT_ENB) {\r\nval = qib_read_ureg32(dd, ur_rcvegrindextail, ctxt);\r\nqib_write_ureg(dd, ur_rcvegrindexhead, val, ctxt);\r\nval = qib_read_ureg32(dd, ur_rcvhdrtail, ctxt);\r\ndd->rcd[ctxt]->head = val;\r\nif (ctxt < dd->first_user_ctxt)\r\nval |= dd->rhdrhead_intr_off;\r\nqib_write_ureg(dd, ur_rcvhdrhead, val, ctxt);\r\n}\r\nif (op & QIB_RCVCTRL_CTXT_DIS) {\r\nif (ctxt >= 0) {\r\nqib_write_kreg_ctxt(dd, kr_rcvhdrtailaddr, ctxt, 0);\r\nqib_write_kreg_ctxt(dd, kr_rcvhdraddr, ctxt, 0);\r\n} else {\r\nunsigned i;\r\nfor (i = 0; i < dd->cfgctxts; i++) {\r\nqib_write_kreg_ctxt(dd, kr_rcvhdrtailaddr,\r\ni, 0);\r\nqib_write_kreg_ctxt(dd, kr_rcvhdraddr, i, 0);\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&dd->cspec->rcvmod_lock, flags);\r\n}\r\nstatic void sendctrl_7220_mod(struct qib_pportdata *ppd, u32 op)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nu64 tmp_dd_sendctrl;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dd->sendctrl_lock, flags);\r\nif (op & QIB_SENDCTRL_CLEAR)\r\ndd->sendctrl = 0;\r\nif (op & QIB_SENDCTRL_SEND_DIS)\r\ndd->sendctrl &= ~SYM_MASK(SendCtrl, SPioEnable);\r\nelse if (op & QIB_SENDCTRL_SEND_ENB) {\r\ndd->sendctrl |= SYM_MASK(SendCtrl, SPioEnable);\r\nif (dd->flags & QIB_USE_SPCL_TRIG)\r\ndd->sendctrl |= SYM_MASK(SendCtrl,\r\nSSpecialTriggerEn);\r\n}\r\nif (op & QIB_SENDCTRL_AVAIL_DIS)\r\ndd->sendctrl &= ~SYM_MASK(SendCtrl, SendBufAvailUpd);\r\nelse if (op & QIB_SENDCTRL_AVAIL_ENB)\r\ndd->sendctrl |= SYM_MASK(SendCtrl, SendBufAvailUpd);\r\nif (op & QIB_SENDCTRL_DISARM_ALL) {\r\nu32 i, last;\r\ntmp_dd_sendctrl = dd->sendctrl;\r\nlast = dd->piobcnt2k + dd->piobcnt4k;\r\ntmp_dd_sendctrl &=\r\n~(SYM_MASK(SendCtrl, SPioEnable) |\r\nSYM_MASK(SendCtrl, SendBufAvailUpd));\r\nfor (i = 0; i < last; i++) {\r\nqib_write_kreg(dd, kr_sendctrl,\r\ntmp_dd_sendctrl |\r\nSYM_MASK(SendCtrl, Disarm) | i);\r\nqib_write_kreg(dd, kr_scratch, 0);\r\n}\r\n}\r\ntmp_dd_sendctrl = dd->sendctrl;\r\nif (op & QIB_SENDCTRL_FLUSH)\r\ntmp_dd_sendctrl |= SYM_MASK(SendCtrl, Abort);\r\nif (op & QIB_SENDCTRL_DISARM)\r\ntmp_dd_sendctrl |= SYM_MASK(SendCtrl, Disarm) |\r\n((op & QIB_7220_SendCtrl_DisarmPIOBuf_RMASK) <<\r\nSYM_LSB(SendCtrl, DisarmPIOBuf));\r\nif ((op & QIB_SENDCTRL_AVAIL_BLIP) &&\r\n(dd->sendctrl & SYM_MASK(SendCtrl, SendBufAvailUpd)))\r\ntmp_dd_sendctrl &= ~SYM_MASK(SendCtrl, SendBufAvailUpd);\r\nqib_write_kreg(dd, kr_sendctrl, tmp_dd_sendctrl);\r\nqib_write_kreg(dd, kr_scratch, 0);\r\nif (op & QIB_SENDCTRL_AVAIL_BLIP) {\r\nqib_write_kreg(dd, kr_sendctrl, dd->sendctrl);\r\nqib_write_kreg(dd, kr_scratch, 0);\r\n}\r\nspin_unlock_irqrestore(&dd->sendctrl_lock, flags);\r\nif (op & QIB_SENDCTRL_FLUSH) {\r\nu32 v;\r\nv = qib_read_kreg32(dd, kr_scratch);\r\nqib_write_kreg(dd, kr_scratch, v);\r\nv = qib_read_kreg32(dd, kr_scratch);\r\nqib_write_kreg(dd, kr_scratch, v);\r\nqib_read_kreg32(dd, kr_scratch);\r\n}\r\n}\r\nstatic u64 qib_portcntr_7220(struct qib_pportdata *ppd, u32 reg)\r\n{\r\nu64 ret = 0ULL;\r\nstruct qib_devdata *dd = ppd->dd;\r\nu16 creg;\r\nstatic const u16 xlator[] = {\r\n[QIBPORTCNTR_PKTSEND] = cr_pktsend,\r\n[QIBPORTCNTR_WORDSEND] = cr_wordsend,\r\n[QIBPORTCNTR_PSXMITDATA] = cr_psxmitdatacount,\r\n[QIBPORTCNTR_PSXMITPKTS] = cr_psxmitpktscount,\r\n[QIBPORTCNTR_PSXMITWAIT] = cr_psxmitwaitcount,\r\n[QIBPORTCNTR_SENDSTALL] = cr_sendstall,\r\n[QIBPORTCNTR_PKTRCV] = cr_pktrcv,\r\n[QIBPORTCNTR_PSRCVDATA] = cr_psrcvdatacount,\r\n[QIBPORTCNTR_PSRCVPKTS] = cr_psrcvpktscount,\r\n[QIBPORTCNTR_RCVEBP] = cr_rcvebp,\r\n[QIBPORTCNTR_RCVOVFL] = cr_rcvovfl,\r\n[QIBPORTCNTR_WORDRCV] = cr_wordrcv,\r\n[QIBPORTCNTR_RXDROPPKT] = cr_rxdroppkt,\r\n[QIBPORTCNTR_RXLOCALPHYERR] = cr_rxotherlocalphyerr,\r\n[QIBPORTCNTR_RXVLERR] = cr_rxvlerr,\r\n[QIBPORTCNTR_ERRICRC] = cr_erricrc,\r\n[QIBPORTCNTR_ERRVCRC] = cr_errvcrc,\r\n[QIBPORTCNTR_ERRLPCRC] = cr_errlpcrc,\r\n[QIBPORTCNTR_BADFORMAT] = cr_badformat,\r\n[QIBPORTCNTR_ERR_RLEN] = cr_err_rlen,\r\n[QIBPORTCNTR_IBSYMBOLERR] = cr_ibsymbolerr,\r\n[QIBPORTCNTR_INVALIDRLEN] = cr_invalidrlen,\r\n[QIBPORTCNTR_UNSUPVL] = cr_txunsupvl,\r\n[QIBPORTCNTR_EXCESSBUFOVFL] = cr_excessbufferovfl,\r\n[QIBPORTCNTR_ERRLINK] = cr_errlink,\r\n[QIBPORTCNTR_IBLINKDOWN] = cr_iblinkdown,\r\n[QIBPORTCNTR_IBLINKERRRECOV] = cr_iblinkerrrecov,\r\n[QIBPORTCNTR_LLI] = cr_locallinkintegrityerr,\r\n[QIBPORTCNTR_PSINTERVAL] = cr_psinterval,\r\n[QIBPORTCNTR_PSSTART] = cr_psstart,\r\n[QIBPORTCNTR_PSSTAT] = cr_psstat,\r\n[QIBPORTCNTR_VL15PKTDROP] = cr_vl15droppedpkt,\r\n[QIBPORTCNTR_ERRPKEY] = cr_errpkey,\r\n[QIBPORTCNTR_KHDROVFL] = 0xffff,\r\n};\r\nif (reg >= ARRAY_SIZE(xlator)) {\r\nqib_devinfo(ppd->dd->pcidev,\r\n"Unimplemented portcounter %u\n", reg);\r\ngoto done;\r\n}\r\ncreg = xlator[reg];\r\nif (reg == QIBPORTCNTR_KHDROVFL) {\r\nint i;\r\nfor (i = 0; i < dd->first_user_ctxt; i++)\r\nret += read_7220_creg32(dd, cr_portovfl + i);\r\n}\r\nif (creg == 0xffff)\r\ngoto done;\r\nif ((creg == cr_wordsend || creg == cr_wordrcv ||\r\ncreg == cr_pktsend || creg == cr_pktrcv))\r\nret = read_7220_creg(dd, creg);\r\nelse\r\nret = read_7220_creg32(dd, creg);\r\nif (creg == cr_ibsymbolerr) {\r\nif (dd->pport->cpspec->ibdeltainprog)\r\nret -= ret - ppd->cpspec->ibsymsnap;\r\nret -= dd->pport->cpspec->ibsymdelta;\r\n} else if (creg == cr_iblinkerrrecov) {\r\nif (dd->pport->cpspec->ibdeltainprog)\r\nret -= ret - ppd->cpspec->iblnkerrsnap;\r\nret -= dd->pport->cpspec->iblnkerrdelta;\r\n}\r\ndone:\r\nreturn ret;\r\n}\r\nstatic void init_7220_cntrnames(struct qib_devdata *dd)\r\n{\r\nint i, j = 0;\r\nchar *s;\r\nfor (i = 0, s = (char *)cntr7220names; s && j <= dd->cfgctxts;\r\ni++) {\r\nif (!j && !strncmp("Ctxt0EgrOvfl", s + 1, 12))\r\nj = 1;\r\ns = strchr(s + 1, '\n');\r\nif (s && j)\r\nj++;\r\n}\r\ndd->cspec->ncntrs = i;\r\nif (!s)\r\ndd->cspec->cntrnamelen = sizeof(cntr7220names) - 1;\r\nelse\r\ndd->cspec->cntrnamelen = 1 + s - cntr7220names;\r\ndd->cspec->cntrs = kmalloc(dd->cspec->ncntrs\r\n* sizeof(u64), GFP_KERNEL);\r\nif (!dd->cspec->cntrs)\r\nqib_dev_err(dd, "Failed allocation for counters\n");\r\nfor (i = 0, s = (char *)portcntr7220names; s; i++)\r\ns = strchr(s + 1, '\n');\r\ndd->cspec->nportcntrs = i - 1;\r\ndd->cspec->portcntrnamelen = sizeof(portcntr7220names) - 1;\r\ndd->cspec->portcntrs = kmalloc(dd->cspec->nportcntrs\r\n* sizeof(u64), GFP_KERNEL);\r\nif (!dd->cspec->portcntrs)\r\nqib_dev_err(dd, "Failed allocation for portcounters\n");\r\n}\r\nstatic u32 qib_read_7220cntrs(struct qib_devdata *dd, loff_t pos, char **namep,\r\nu64 **cntrp)\r\n{\r\nu32 ret;\r\nif (!dd->cspec->cntrs) {\r\nret = 0;\r\ngoto done;\r\n}\r\nif (namep) {\r\n*namep = (char *)cntr7220names;\r\nret = dd->cspec->cntrnamelen;\r\nif (pos >= ret)\r\nret = 0;\r\n} else {\r\nu64 *cntr = dd->cspec->cntrs;\r\nint i;\r\nret = dd->cspec->ncntrs * sizeof(u64);\r\nif (!cntr || pos >= ret) {\r\nret = 0;\r\ngoto done;\r\n}\r\n*cntrp = cntr;\r\nfor (i = 0; i < dd->cspec->ncntrs; i++)\r\n*cntr++ = read_7220_creg32(dd, cntr7220indices[i]);\r\n}\r\ndone:\r\nreturn ret;\r\n}\r\nstatic u32 qib_read_7220portcntrs(struct qib_devdata *dd, loff_t pos, u32 port,\r\nchar **namep, u64 **cntrp)\r\n{\r\nu32 ret;\r\nif (!dd->cspec->portcntrs) {\r\nret = 0;\r\ngoto done;\r\n}\r\nif (namep) {\r\n*namep = (char *)portcntr7220names;\r\nret = dd->cspec->portcntrnamelen;\r\nif (pos >= ret)\r\nret = 0;\r\n} else {\r\nu64 *cntr = dd->cspec->portcntrs;\r\nstruct qib_pportdata *ppd = &dd->pport[port];\r\nint i;\r\nret = dd->cspec->nportcntrs * sizeof(u64);\r\nif (!cntr || pos >= ret) {\r\nret = 0;\r\ngoto done;\r\n}\r\n*cntrp = cntr;\r\nfor (i = 0; i < dd->cspec->nportcntrs; i++) {\r\nif (portcntr7220indices[i] & _PORT_VIRT_FLAG)\r\n*cntr++ = qib_portcntr_7220(ppd,\r\nportcntr7220indices[i] &\r\n~_PORT_VIRT_FLAG);\r\nelse\r\n*cntr++ = read_7220_creg32(dd,\r\nportcntr7220indices[i]);\r\n}\r\n}\r\ndone:\r\nreturn ret;\r\n}\r\nstatic void qib_get_7220_faststats(unsigned long opaque)\r\n{\r\nstruct qib_devdata *dd = (struct qib_devdata *) opaque;\r\nstruct qib_pportdata *ppd = dd->pport;\r\nunsigned long flags;\r\nu64 traffic_wds;\r\nif (!(dd->flags & QIB_INITTED) || dd->diag_client)\r\ngoto done;\r\ntraffic_wds = qib_portcntr_7220(ppd, cr_wordsend) +\r\nqib_portcntr_7220(ppd, cr_wordrcv);\r\nspin_lock_irqsave(&dd->eep_st_lock, flags);\r\ntraffic_wds -= dd->traffic_wds;\r\ndd->traffic_wds += traffic_wds;\r\nif (traffic_wds >= QIB_TRAFFIC_ACTIVE_THRESHOLD)\r\natomic_add(5, &dd->active_time);\r\nspin_unlock_irqrestore(&dd->eep_st_lock, flags);\r\ndone:\r\nmod_timer(&dd->stats_timer, jiffies + HZ * ACTIVITY_TIMER);\r\n}\r\nstatic int qib_7220_intr_fallback(struct qib_devdata *dd)\r\n{\r\nif (!dd->msi_lo)\r\nreturn 0;\r\nqib_devinfo(dd->pcidev, "MSI interrupt not detected,"\r\n" trying INTx interrupts\n");\r\nqib_7220_free_irq(dd);\r\nqib_enable_intx(dd->pcidev);\r\ndd->cspec->irq = dd->pcidev->irq;\r\nqib_setup_7220_interrupt(dd);\r\nreturn 1;\r\n}\r\nstatic void qib_7220_xgxs_reset(struct qib_pportdata *ppd)\r\n{\r\nu64 val, prev_val;\r\nstruct qib_devdata *dd = ppd->dd;\r\nprev_val = qib_read_kreg64(dd, kr_xgxs_cfg);\r\nval = prev_val | QLOGIC_IB_XGXS_RESET;\r\nprev_val &= ~QLOGIC_IB_XGXS_RESET;\r\nqib_write_kreg(dd, kr_control,\r\ndd->control & ~QLOGIC_IB_C_LINKENABLE);\r\nqib_write_kreg(dd, kr_xgxs_cfg, val);\r\nqib_read_kreg32(dd, kr_scratch);\r\nqib_write_kreg(dd, kr_xgxs_cfg, prev_val);\r\nqib_write_kreg(dd, kr_control, dd->control);\r\n}\r\nstatic u32 __iomem *get_7220_link_buf(struct qib_pportdata *ppd, u32 *bnum)\r\n{\r\nu32 __iomem *buf;\r\nu32 lbuf = ppd->dd->cspec->lastbuf_for_pio;\r\nint do_cleanup;\r\nunsigned long flags;\r\nsendctrl_7220_mod(ppd->dd->pport, QIB_SENDCTRL_AVAIL_BLIP);\r\nqib_read_kreg64(ppd->dd, kr_scratch);\r\nbuf = qib_getsendbuf_range(ppd->dd, bnum, lbuf, lbuf);\r\nif (buf)\r\ngoto done;\r\nspin_lock_irqsave(&ppd->sdma_lock, flags);\r\nif (ppd->sdma_state.current_state == qib_sdma_state_s20_idle &&\r\nppd->sdma_state.current_state != qib_sdma_state_s00_hw_down) {\r\n__qib_sdma_process_event(ppd, qib_sdma_event_e00_go_hw_down);\r\ndo_cleanup = 0;\r\n} else {\r\ndo_cleanup = 1;\r\nqib_7220_sdma_hw_clean_up(ppd);\r\n}\r\nspin_unlock_irqrestore(&ppd->sdma_lock, flags);\r\nif (do_cleanup) {\r\nqib_read_kreg64(ppd->dd, kr_scratch);\r\nbuf = qib_getsendbuf_range(ppd->dd, bnum, lbuf, lbuf);\r\n}\r\ndone:\r\nreturn buf;\r\n}\r\nstatic void autoneg_7220_sendpkt(struct qib_pportdata *ppd, u32 *hdr,\r\nu32 dcnt, u32 *data)\r\n{\r\nint i;\r\nu64 pbc;\r\nu32 __iomem *piobuf;\r\nu32 pnum;\r\nstruct qib_devdata *dd = ppd->dd;\r\ni = 0;\r\npbc = 7 + dcnt + 1;\r\npbc |= PBC_7220_VL15_SEND;\r\nwhile (!(piobuf = get_7220_link_buf(ppd, &pnum))) {\r\nif (i++ > 5)\r\nreturn;\r\nudelay(2);\r\n}\r\nsendctrl_7220_mod(dd->pport, QIB_SENDCTRL_DISARM_BUF(pnum));\r\nwriteq(pbc, piobuf);\r\nqib_flush_wc();\r\nqib_pio_copy(piobuf + 2, hdr, 7);\r\nqib_pio_copy(piobuf + 9, data, dcnt);\r\nif (dd->flags & QIB_USE_SPCL_TRIG) {\r\nu32 spcl_off = (pnum >= dd->piobcnt2k) ? 2047 : 1023;\r\nqib_flush_wc();\r\n__raw_writel(0xaebecede, piobuf + spcl_off);\r\n}\r\nqib_flush_wc();\r\nqib_sendbuf_done(dd, pnum);\r\n}\r\nstatic void autoneg_7220_send(struct qib_pportdata *ppd, int which)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nstatic u32 swapped;\r\nu32 dw, i, hcnt, dcnt, *data;\r\nstatic u32 hdr[7] = { 0xf002ffff, 0x48ffff, 0x6400abba };\r\nstatic u32 madpayload_start[0x40] = {\r\n0x1810103, 0x1, 0x0, 0x0, 0x2c90000, 0x2c9, 0x0, 0x0,\r\n0xffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\r\n0x1, 0x1388, 0x15e, 0x1,\r\n};\r\nstatic u32 madpayload_done[0x40] = {\r\n0x1810103, 0x1, 0x0, 0x0, 0x2c90000, 0x2c9, 0x0, 0x0,\r\n0xffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\r\n0x40000001, 0x1388, 0x15e,\r\n};\r\ndcnt = ARRAY_SIZE(madpayload_start);\r\nhcnt = ARRAY_SIZE(hdr);\r\nif (!swapped) {\r\nfor (i = 0; i < hcnt; i++) {\r\ndw = (__force u32) cpu_to_be32(hdr[i]);\r\nhdr[i] = dw;\r\n}\r\nfor (i = 0; i < dcnt; i++) {\r\ndw = (__force u32) cpu_to_be32(madpayload_start[i]);\r\nmadpayload_start[i] = dw;\r\ndw = (__force u32) cpu_to_be32(madpayload_done[i]);\r\nmadpayload_done[i] = dw;\r\n}\r\nswapped = 1;\r\n}\r\ndata = which ? madpayload_done : madpayload_start;\r\nautoneg_7220_sendpkt(ppd, hdr, dcnt, data);\r\nqib_read_kreg64(dd, kr_scratch);\r\nudelay(2);\r\nautoneg_7220_sendpkt(ppd, hdr, dcnt, data);\r\nqib_read_kreg64(dd, kr_scratch);\r\nudelay(2);\r\n}\r\nstatic void set_7220_ibspeed_fast(struct qib_pportdata *ppd, u32 speed)\r\n{\r\nppd->cpspec->ibcddrctrl &= ~(IBA7220_IBC_SPEED_AUTONEG_MASK |\r\nIBA7220_IBC_IBTA_1_2_MASK);\r\nif (speed == (QIB_IB_SDR | QIB_IB_DDR))\r\nppd->cpspec->ibcddrctrl |= IBA7220_IBC_SPEED_AUTONEG_MASK |\r\nIBA7220_IBC_IBTA_1_2_MASK;\r\nelse\r\nppd->cpspec->ibcddrctrl |= speed == QIB_IB_DDR ?\r\nIBA7220_IBC_SPEED_DDR : IBA7220_IBC_SPEED_SDR;\r\nqib_write_kreg(ppd->dd, kr_ibcddrctrl, ppd->cpspec->ibcddrctrl);\r\nqib_write_kreg(ppd->dd, kr_scratch, 0);\r\n}\r\nstatic void try_7220_autoneg(struct qib_pportdata *ppd)\r\n{\r\nunsigned long flags;\r\nqib_write_kreg(ppd->dd, kr_ncmodectrl, 0x3b9dc07);\r\nspin_lock_irqsave(&ppd->lflags_lock, flags);\r\nppd->lflags |= QIBL_IB_AUTONEG_INPROG;\r\nspin_unlock_irqrestore(&ppd->lflags_lock, flags);\r\nautoneg_7220_send(ppd, 0);\r\nset_7220_ibspeed_fast(ppd, QIB_IB_DDR);\r\ntoggle_7220_rclkrls(ppd->dd);\r\nqueue_delayed_work(ib_wq, &ppd->cpspec->autoneg_work,\r\nmsecs_to_jiffies(2));\r\n}\r\nstatic void autoneg_7220_work(struct work_struct *work)\r\n{\r\nstruct qib_pportdata *ppd;\r\nstruct qib_devdata *dd;\r\nu64 startms;\r\nu32 i;\r\nunsigned long flags;\r\nppd = &container_of(work, struct qib_chippport_specific,\r\nautoneg_work.work)->pportdata;\r\ndd = ppd->dd;\r\nstartms = jiffies_to_msecs(jiffies);\r\nfor (i = 0; i < 25; i++) {\r\nif (SYM_FIELD(ppd->lastibcstat, IBCStatus, LinkTrainingState)\r\n== IB_7220_LT_STATE_POLLQUIET) {\r\nqib_set_linkstate(ppd, QIB_IB_LINKDOWN_DISABLE);\r\nbreak;\r\n}\r\nudelay(100);\r\n}\r\nif (!(ppd->lflags & QIBL_IB_AUTONEG_INPROG))\r\ngoto done;\r\nif (wait_event_timeout(ppd->cpspec->autoneg_wait,\r\n!(ppd->lflags & QIBL_IB_AUTONEG_INPROG),\r\nmsecs_to_jiffies(90)))\r\ngoto done;\r\ntoggle_7220_rclkrls(dd);\r\nif (wait_event_timeout(ppd->cpspec->autoneg_wait,\r\n!(ppd->lflags & QIBL_IB_AUTONEG_INPROG),\r\nmsecs_to_jiffies(1700)))\r\ngoto done;\r\nset_7220_ibspeed_fast(ppd, QIB_IB_SDR);\r\ntoggle_7220_rclkrls(dd);\r\nwait_event_timeout(ppd->cpspec->autoneg_wait,\r\n!(ppd->lflags & QIBL_IB_AUTONEG_INPROG),\r\nmsecs_to_jiffies(250));\r\ndone:\r\nif (ppd->lflags & QIBL_IB_AUTONEG_INPROG) {\r\nspin_lock_irqsave(&ppd->lflags_lock, flags);\r\nppd->lflags &= ~QIBL_IB_AUTONEG_INPROG;\r\nif (dd->cspec->autoneg_tries == AUTONEG_TRIES) {\r\nppd->lflags |= QIBL_IB_AUTONEG_FAILED;\r\ndd->cspec->autoneg_tries = 0;\r\n}\r\nspin_unlock_irqrestore(&ppd->lflags_lock, flags);\r\nset_7220_ibspeed_fast(ppd, ppd->link_speed_enabled);\r\n}\r\n}\r\nstatic u32 qib_7220_iblink_state(u64 ibcs)\r\n{\r\nu32 state = (u32)SYM_FIELD(ibcs, IBCStatus, LinkState);\r\nswitch (state) {\r\ncase IB_7220_L_STATE_INIT:\r\nstate = IB_PORT_INIT;\r\nbreak;\r\ncase IB_7220_L_STATE_ARM:\r\nstate = IB_PORT_ARMED;\r\nbreak;\r\ncase IB_7220_L_STATE_ACTIVE:\r\ncase IB_7220_L_STATE_ACT_DEFER:\r\nstate = IB_PORT_ACTIVE;\r\nbreak;\r\ndefault:\r\ncase IB_7220_L_STATE_DOWN:\r\nstate = IB_PORT_DOWN;\r\nbreak;\r\n}\r\nreturn state;\r\n}\r\nstatic u8 qib_7220_phys_portstate(u64 ibcs)\r\n{\r\nu8 state = (u8)SYM_FIELD(ibcs, IBCStatus, LinkTrainingState);\r\nreturn qib_7220_physportstate[state];\r\n}\r\nstatic int qib_7220_ib_updown(struct qib_pportdata *ppd, int ibup, u64 ibcs)\r\n{\r\nint ret = 0, symadj = 0;\r\nstruct qib_devdata *dd = ppd->dd;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ppd->lflags_lock, flags);\r\nppd->lflags &= ~QIBL_IB_FORCE_NOTIFY;\r\nspin_unlock_irqrestore(&ppd->lflags_lock, flags);\r\nif (!ibup) {\r\nif (!(ppd->lflags & (QIBL_IB_AUTONEG_FAILED |\r\nQIBL_IB_AUTONEG_INPROG)))\r\nset_7220_ibspeed_fast(ppd, ppd->link_speed_enabled);\r\nif (!(ppd->lflags & QIBL_IB_AUTONEG_INPROG)) {\r\nqib_sd7220_presets(dd);\r\nqib_cancel_sends(ppd);\r\nspin_lock_irqsave(&ppd->sdma_lock, flags);\r\nif (__qib_sdma_running(ppd))\r\n__qib_sdma_process_event(ppd,\r\nqib_sdma_event_e70_go_idle);\r\nspin_unlock_irqrestore(&ppd->sdma_lock, flags);\r\n}\r\nset_7220_relock_poll(dd, ibup);\r\n} else {\r\nif (qib_compat_ddr_negotiate &&\r\n!(ppd->lflags & (QIBL_IB_AUTONEG_FAILED |\r\nQIBL_IB_AUTONEG_INPROG)) &&\r\nppd->link_speed_active == QIB_IB_SDR &&\r\n(ppd->link_speed_enabled & (QIB_IB_DDR | QIB_IB_SDR)) ==\r\n(QIB_IB_DDR | QIB_IB_SDR) &&\r\ndd->cspec->autoneg_tries < AUTONEG_TRIES) {\r\n++dd->cspec->autoneg_tries;\r\nif (!ppd->cpspec->ibdeltainprog) {\r\nppd->cpspec->ibdeltainprog = 1;\r\nppd->cpspec->ibsymsnap = read_7220_creg32(dd,\r\ncr_ibsymbolerr);\r\nppd->cpspec->iblnkerrsnap = read_7220_creg32(dd,\r\ncr_iblinkerrrecov);\r\n}\r\ntry_7220_autoneg(ppd);\r\nret = 1;\r\n} else if ((ppd->lflags & QIBL_IB_AUTONEG_INPROG) &&\r\nppd->link_speed_active == QIB_IB_SDR) {\r\nautoneg_7220_send(ppd, 1);\r\nset_7220_ibspeed_fast(ppd, QIB_IB_DDR);\r\nudelay(2);\r\ntoggle_7220_rclkrls(dd);\r\nret = 1;\r\n} else {\r\nif ((ppd->lflags & QIBL_IB_AUTONEG_INPROG) &&\r\n(ppd->link_speed_active & QIB_IB_DDR)) {\r\nspin_lock_irqsave(&ppd->lflags_lock, flags);\r\nppd->lflags &= ~(QIBL_IB_AUTONEG_INPROG |\r\nQIBL_IB_AUTONEG_FAILED);\r\nspin_unlock_irqrestore(&ppd->lflags_lock,\r\nflags);\r\ndd->cspec->autoneg_tries = 0;\r\nset_7220_ibspeed_fast(ppd,\r\nppd->link_speed_enabled);\r\nwake_up(&ppd->cpspec->autoneg_wait);\r\nsymadj = 1;\r\n} else if (ppd->lflags & QIBL_IB_AUTONEG_FAILED) {\r\nspin_lock_irqsave(&ppd->lflags_lock, flags);\r\nppd->lflags &= ~QIBL_IB_AUTONEG_FAILED;\r\nspin_unlock_irqrestore(&ppd->lflags_lock,\r\nflags);\r\nppd->cpspec->ibcddrctrl |=\r\nIBA7220_IBC_IBTA_1_2_MASK;\r\nqib_write_kreg(dd, kr_ncmodectrl, 0);\r\nsymadj = 1;\r\n}\r\n}\r\nif (!(ppd->lflags & QIBL_IB_AUTONEG_INPROG))\r\nsymadj = 1;\r\nif (!ret) {\r\nppd->delay_mult = rate_to_delay\r\n[(ibcs >> IBA7220_LINKSPEED_SHIFT) & 1]\r\n[(ibcs >> IBA7220_LINKWIDTH_SHIFT) & 1];\r\nset_7220_relock_poll(dd, ibup);\r\nspin_lock_irqsave(&ppd->sdma_lock, flags);\r\nif (ppd->sdma_state.current_state !=\r\nqib_sdma_state_s20_idle)\r\n__qib_sdma_process_event(ppd,\r\nqib_sdma_event_e00_go_hw_down);\r\nspin_unlock_irqrestore(&ppd->sdma_lock, flags);\r\n}\r\n}\r\nif (symadj) {\r\nif (ppd->cpspec->ibdeltainprog) {\r\nppd->cpspec->ibdeltainprog = 0;\r\nppd->cpspec->ibsymdelta += read_7220_creg32(ppd->dd,\r\ncr_ibsymbolerr) - ppd->cpspec->ibsymsnap;\r\nppd->cpspec->iblnkerrdelta += read_7220_creg32(ppd->dd,\r\ncr_iblinkerrrecov) - ppd->cpspec->iblnkerrsnap;\r\n}\r\n} else if (!ibup && qib_compat_ddr_negotiate &&\r\n!ppd->cpspec->ibdeltainprog &&\r\n!(ppd->lflags & QIBL_IB_AUTONEG_INPROG)) {\r\nppd->cpspec->ibdeltainprog = 1;\r\nppd->cpspec->ibsymsnap = read_7220_creg32(ppd->dd,\r\ncr_ibsymbolerr);\r\nppd->cpspec->iblnkerrsnap = read_7220_creg32(ppd->dd,\r\ncr_iblinkerrrecov);\r\n}\r\nif (!ret)\r\nqib_setup_7220_setextled(ppd, ibup);\r\nreturn ret;\r\n}\r\nstatic int gpio_7220_mod(struct qib_devdata *dd, u32 out, u32 dir, u32 mask)\r\n{\r\nu64 read_val, new_out;\r\nunsigned long flags;\r\nif (mask) {\r\ndir &= mask;\r\nout &= mask;\r\nspin_lock_irqsave(&dd->cspec->gpio_lock, flags);\r\ndd->cspec->extctrl &= ~((u64)mask << SYM_LSB(EXTCtrl, GPIOOe));\r\ndd->cspec->extctrl |= ((u64) dir << SYM_LSB(EXTCtrl, GPIOOe));\r\nnew_out = (dd->cspec->gpio_out & ~mask) | out;\r\nqib_write_kreg(dd, kr_extctrl, dd->cspec->extctrl);\r\nqib_write_kreg(dd, kr_gpio_out, new_out);\r\ndd->cspec->gpio_out = new_out;\r\nspin_unlock_irqrestore(&dd->cspec->gpio_lock, flags);\r\n}\r\nread_val = qib_read_kreg64(dd, kr_extstatus);\r\nreturn SYM_FIELD(read_val, EXTStatus, GPIOIn);\r\n}\r\nstatic void get_7220_chip_params(struct qib_devdata *dd)\r\n{\r\nu64 val;\r\nu32 piobufs;\r\nint mtu;\r\ndd->uregbase = qib_read_kreg32(dd, kr_userregbase);\r\ndd->rcvtidcnt = qib_read_kreg32(dd, kr_rcvtidcnt);\r\ndd->rcvtidbase = qib_read_kreg32(dd, kr_rcvtidbase);\r\ndd->rcvegrbase = qib_read_kreg32(dd, kr_rcvegrbase);\r\ndd->palign = qib_read_kreg32(dd, kr_palign);\r\ndd->piobufbase = qib_read_kreg64(dd, kr_sendpiobufbase);\r\ndd->pio2k_bufbase = dd->piobufbase & 0xffffffff;\r\nval = qib_read_kreg64(dd, kr_sendpiosize);\r\ndd->piosize2k = val & ~0U;\r\ndd->piosize4k = val >> 32;\r\nmtu = ib_mtu_enum_to_int(qib_ibmtu);\r\nif (mtu == -1)\r\nmtu = QIB_DEFAULT_MTU;\r\ndd->pport->ibmtu = (u32)mtu;\r\nval = qib_read_kreg64(dd, kr_sendpiobufcnt);\r\ndd->piobcnt2k = val & ~0U;\r\ndd->piobcnt4k = val >> 32;\r\ndd->pio2kbase = (u32 __iomem *)\r\n((char __iomem *) dd->kregbase + dd->pio2k_bufbase);\r\nif (dd->piobcnt4k) {\r\ndd->pio4kbase = (u32 __iomem *)\r\n((char __iomem *) dd->kregbase +\r\n(dd->piobufbase >> 32));\r\ndd->align4k = ALIGN(dd->piosize4k, dd->palign);\r\n}\r\npiobufs = dd->piobcnt4k + dd->piobcnt2k;\r\ndd->pioavregs = ALIGN(piobufs, sizeof(u64) * BITS_PER_BYTE / 2) /\r\n(sizeof(u64) * BITS_PER_BYTE / 2);\r\n}\r\nstatic void set_7220_baseaddrs(struct qib_devdata *dd)\r\n{\r\nu32 cregbase;\r\ncregbase = qib_read_kreg32(dd, kr_counterregbase);\r\ndd->cspec->cregbase = (u64 __iomem *)\r\n((char __iomem *) dd->kregbase + cregbase);\r\ndd->egrtidbase = (u64 __iomem *)\r\n((char __iomem *) dd->kregbase + dd->rcvegrbase);\r\n}\r\nstatic int sendctrl_hook(struct qib_devdata *dd,\r\nconst struct diag_observer *op,\r\nu32 offs, u64 *data, u64 mask, int only_32)\r\n{\r\nunsigned long flags;\r\nunsigned idx = offs / sizeof(u64);\r\nu64 local_data, all_bits;\r\nif (idx != kr_sendctrl) {\r\nqib_dev_err(dd, "SendCtrl Hook called with offs %X, %s-bit\n",\r\noffs, only_32 ? "32" : "64");\r\nreturn 0;\r\n}\r\nall_bits = ~0ULL;\r\nif (only_32)\r\nall_bits >>= 32;\r\nspin_lock_irqsave(&dd->sendctrl_lock, flags);\r\nif ((mask & all_bits) != all_bits) {\r\nif (only_32)\r\nlocal_data = (u64)qib_read_kreg32(dd, idx);\r\nelse\r\nlocal_data = qib_read_kreg64(dd, idx);\r\nqib_dev_err(dd, "Sendctrl -> %X, Shad -> %X\n",\r\n(u32)local_data, (u32)dd->sendctrl);\r\nif ((local_data & SENDCTRL_SHADOWED) !=\r\n(dd->sendctrl & SENDCTRL_SHADOWED))\r\nqib_dev_err(dd, "Sendctrl read: %X shadow is %X\n",\r\n(u32)local_data, (u32) dd->sendctrl);\r\n*data = (local_data & ~mask) | (*data & mask);\r\n}\r\nif (mask) {\r\nu64 sval, tval;\r\nsval = (dd->sendctrl & ~mask);\r\nsval |= *data & SENDCTRL_SHADOWED & mask;\r\ndd->sendctrl = sval;\r\ntval = sval | (*data & ~SENDCTRL_SHADOWED & mask);\r\nqib_dev_err(dd, "Sendctrl <- %X, Shad <- %X\n",\r\n(u32)tval, (u32)sval);\r\nqib_write_kreg(dd, kr_sendctrl, tval);\r\nqib_write_kreg(dd, kr_scratch, 0Ull);\r\n}\r\nspin_unlock_irqrestore(&dd->sendctrl_lock, flags);\r\nreturn only_32 ? 4 : 8;\r\n}\r\nstatic int qib_late_7220_initreg(struct qib_devdata *dd)\r\n{\r\nint ret = 0;\r\nu64 val;\r\nqib_write_kreg(dd, kr_rcvhdrentsize, dd->rcvhdrentsize);\r\nqib_write_kreg(dd, kr_rcvhdrsize, dd->rcvhdrsize);\r\nqib_write_kreg(dd, kr_rcvhdrcnt, dd->rcvhdrcnt);\r\nqib_write_kreg(dd, kr_sendpioavailaddr, dd->pioavailregs_phys);\r\nval = qib_read_kreg64(dd, kr_sendpioavailaddr);\r\nif (val != dd->pioavailregs_phys) {\r\nqib_dev_err(dd, "Catastrophic software error, "\r\n"SendPIOAvailAddr written as %lx, "\r\n"read back as %llx\n",\r\n(unsigned long) dd->pioavailregs_phys,\r\n(unsigned long long) val);\r\nret = -EINVAL;\r\n}\r\nqib_register_observer(dd, &sendctrl_observer);\r\nreturn ret;\r\n}\r\nstatic int qib_init_7220_variables(struct qib_devdata *dd)\r\n{\r\nstruct qib_chippport_specific *cpspec;\r\nstruct qib_pportdata *ppd;\r\nint ret = 0;\r\nu32 sbufs, updthresh;\r\ncpspec = (struct qib_chippport_specific *)(dd + 1);\r\nppd = &cpspec->pportdata;\r\ndd->pport = ppd;\r\ndd->num_pports = 1;\r\ndd->cspec = (struct qib_chip_specific *)(cpspec + dd->num_pports);\r\nppd->cpspec = cpspec;\r\nspin_lock_init(&dd->cspec->sdepb_lock);\r\nspin_lock_init(&dd->cspec->rcvmod_lock);\r\nspin_lock_init(&dd->cspec->gpio_lock);\r\ndd->revision = readq(&dd->kregbase[kr_revision]);\r\nif ((dd->revision & 0xffffffffU) == 0xffffffffU) {\r\nqib_dev_err(dd, "Revision register read failure, "\r\n"giving up initialization\n");\r\nret = -ENODEV;\r\ngoto bail;\r\n}\r\ndd->flags |= QIB_PRESENT;\r\ndd->majrev = (u8) SYM_FIELD(dd->revision, Revision_R,\r\nChipRevMajor);\r\ndd->minrev = (u8) SYM_FIELD(dd->revision, Revision_R,\r\nChipRevMinor);\r\nget_7220_chip_params(dd);\r\nqib_7220_boardname(dd);\r\ndd->gpio_sda_num = _QIB_GPIO_SDA_NUM;\r\ndd->gpio_scl_num = _QIB_GPIO_SCL_NUM;\r\ndd->twsi_eeprom_dev = QIB_TWSI_EEPROM_DEV;\r\ndd->flags |= QIB_HAS_INTX | QIB_HAS_LINK_LATENCY |\r\nQIB_NODMA_RTAIL | QIB_HAS_THRESH_UPDATE;\r\ndd->flags |= qib_special_trigger ?\r\nQIB_USE_SPCL_TRIG : QIB_HAS_SEND_DMA;\r\ndd->eep_st_masks[0].hwerrs_to_log = HWE_MASK(TXEMemParityErr);\r\ndd->eep_st_masks[1].hwerrs_to_log = HWE_MASK(RXEMemParityErr);\r\ndd->eep_st_masks[2].errs_to_log = ERR_MASK(ResetNegated);\r\ninit_waitqueue_head(&cpspec->autoneg_wait);\r\nINIT_DELAYED_WORK(&cpspec->autoneg_work, autoneg_7220_work);\r\nqib_init_pportdata(ppd, dd, 0, 1);\r\nppd->link_width_supported = IB_WIDTH_1X | IB_WIDTH_4X;\r\nppd->link_speed_supported = QIB_IB_SDR | QIB_IB_DDR;\r\nppd->link_width_enabled = ppd->link_width_supported;\r\nppd->link_speed_enabled = ppd->link_speed_supported;\r\nppd->link_width_active = IB_WIDTH_4X;\r\nppd->link_speed_active = QIB_IB_SDR;\r\nppd->delay_mult = rate_to_delay[0][1];\r\nppd->vls_supported = IB_VL_VL0;\r\nppd->vls_operational = ppd->vls_supported;\r\nif (!qib_mini_init)\r\nqib_write_kreg(dd, kr_rcvbthqp, QIB_KD_QP);\r\ninit_timer(&ppd->cpspec->chase_timer);\r\nppd->cpspec->chase_timer.function = reenable_7220_chase;\r\nppd->cpspec->chase_timer.data = (unsigned long)ppd;\r\nqib_num_cfg_vls = 1;\r\ndd->rcvhdrentsize = QIB_RCVHDR_ENTSIZE;\r\ndd->rcvhdrsize = QIB_DFLT_RCVHDRSIZE;\r\ndd->rhf_offset =\r\ndd->rcvhdrentsize - sizeof(u64) / sizeof(u32);\r\nret = ib_mtu_enum_to_int(qib_ibmtu);\r\ndd->rcvegrbufsize = ret != -1 ? max(ret, 2048) : QIB_DEFAULT_MTU;\r\nBUG_ON(!is_power_of_2(dd->rcvegrbufsize));\r\ndd->rcvegrbufsize_shift = ilog2(dd->rcvegrbufsize);\r\nqib_7220_tidtemplate(dd);\r\ndd->rhdrhead_intr_off = 1ULL << 32;\r\ninit_timer(&dd->stats_timer);\r\ndd->stats_timer.function = qib_get_7220_faststats;\r\ndd->stats_timer.data = (unsigned long) dd;\r\ndd->stats_timer.expires = jiffies + ACTIVITY_TIMER * HZ;\r\nif (qib_sdma_fetch_arb)\r\ndd->control |= 1 << 4;\r\ndd->ureg_align = 0x10000;\r\ndd->piosize2kmax_dwords = (dd->piosize2k >> 2)-1;\r\nqib_7220_config_ctxts(dd);\r\nqib_set_ctxtcnt(dd);\r\nif (qib_wc_pat) {\r\nret = init_chip_wc_pat(dd, 0);\r\nif (ret)\r\ngoto bail;\r\n}\r\nset_7220_baseaddrs(dd);\r\nret = 0;\r\nif (qib_mini_init)\r\ngoto bail;\r\nret = qib_create_ctxts(dd);\r\ninit_7220_cntrnames(dd);\r\nupdthresh = 8U;\r\nif (dd->flags & QIB_HAS_SEND_DMA) {\r\ndd->cspec->sdmabufcnt = dd->piobcnt4k;\r\nsbufs = updthresh > 3 ? updthresh : 3;\r\n} else {\r\ndd->cspec->sdmabufcnt = 0;\r\nsbufs = dd->piobcnt4k;\r\n}\r\ndd->cspec->lastbuf_for_pio = dd->piobcnt2k + dd->piobcnt4k -\r\ndd->cspec->sdmabufcnt;\r\ndd->lastctxt_piobuf = dd->cspec->lastbuf_for_pio - sbufs;\r\ndd->cspec->lastbuf_for_pio--;\r\ndd->pbufsctxt = dd->lastctxt_piobuf /\r\n(dd->cfgctxts - dd->first_user_ctxt);\r\nif ((dd->pbufsctxt - 2) < updthresh)\r\nupdthresh = dd->pbufsctxt - 2;\r\ndd->cspec->updthresh_dflt = updthresh;\r\ndd->cspec->updthresh = updthresh;\r\ndd->sendctrl |= (updthresh & SYM_RMASK(SendCtrl, AvailUpdThld))\r\n<< SYM_LSB(SendCtrl, AvailUpdThld);\r\ndd->psxmitwait_supported = 1;\r\ndd->psxmitwait_check_rate = QIB_7220_PSXMITWAIT_CHECK_RATE;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic u32 __iomem *qib_7220_getsendbuf(struct qib_pportdata *ppd, u64 pbc,\r\nu32 *pbufnum)\r\n{\r\nu32 first, last, plen = pbc & QIB_PBC_LENGTH_MASK;\r\nstruct qib_devdata *dd = ppd->dd;\r\nu32 __iomem *buf;\r\nif (((pbc >> 32) & PBC_7220_VL15_SEND_CTRL) &&\r\n!(ppd->lflags & (QIBL_IB_AUTONEG_INPROG | QIBL_LINKACTIVE)))\r\nbuf = get_7220_link_buf(ppd, pbufnum);\r\nelse {\r\nif ((plen + 1) > dd->piosize2kmax_dwords)\r\nfirst = dd->piobcnt2k;\r\nelse\r\nfirst = 0;\r\nlast = dd->cspec->lastbuf_for_pio;\r\nbuf = qib_getsendbuf_range(dd, pbufnum, first, last);\r\n}\r\nreturn buf;\r\n}\r\nstatic void qib_set_cntr_7220_sample(struct qib_pportdata *ppd, u32 intv,\r\nu32 start)\r\n{\r\nwrite_7220_creg(ppd->dd, cr_psinterval, intv);\r\nwrite_7220_creg(ppd->dd, cr_psstart, start);\r\n}\r\nstatic void qib_sdma_update_7220_tail(struct qib_pportdata *ppd, u16 tail)\r\n{\r\nwmb();\r\nppd->sdma_descq_tail = tail;\r\nqib_write_kreg(ppd->dd, kr_senddmatail, tail);\r\n}\r\nstatic void qib_sdma_set_7220_desc_cnt(struct qib_pportdata *ppd, unsigned cnt)\r\n{\r\n}\r\nstatic void qib_7220_sdma_init_early(struct qib_pportdata *ppd)\r\n{\r\nppd->sdma_state.set_state_action = sdma_7220_action_table;\r\n}\r\nstatic int init_sdma_7220_regs(struct qib_pportdata *ppd)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nunsigned i, n;\r\nu64 senddmabufmask[3] = { 0 };\r\nqib_write_kreg(dd, kr_senddmabase, ppd->sdma_descq_phys);\r\nqib_sdma_7220_setlengen(ppd);\r\nqib_sdma_update_7220_tail(ppd, 0);\r\nqib_write_kreg(dd, kr_senddmaheadaddr, ppd->sdma_head_phys);\r\nn = dd->piobcnt2k + dd->piobcnt4k;\r\ni = n - dd->cspec->sdmabufcnt;\r\nfor (; i < n; ++i) {\r\nunsigned word = i / 64;\r\nunsigned bit = i & 63;\r\nBUG_ON(word >= 3);\r\nsenddmabufmask[word] |= 1ULL << bit;\r\n}\r\nqib_write_kreg(dd, kr_senddmabufmask0, senddmabufmask[0]);\r\nqib_write_kreg(dd, kr_senddmabufmask1, senddmabufmask[1]);\r\nqib_write_kreg(dd, kr_senddmabufmask2, senddmabufmask[2]);\r\nppd->sdma_state.first_sendbuf = i;\r\nppd->sdma_state.last_sendbuf = n;\r\nreturn 0;\r\n}\r\nstatic u16 qib_sdma_7220_gethead(struct qib_pportdata *ppd)\r\n{\r\nstruct qib_devdata *dd = ppd->dd;\r\nint sane;\r\nint use_dmahead;\r\nu16 swhead;\r\nu16 swtail;\r\nu16 cnt;\r\nu16 hwhead;\r\nuse_dmahead = __qib_sdma_running(ppd) &&\r\n(dd->flags & QIB_HAS_SDMA_TIMEOUT);\r\nretry:\r\nhwhead = use_dmahead ?\r\n(u16)le64_to_cpu(*ppd->sdma_head_dma) :\r\n(u16)qib_read_kreg32(dd, kr_senddmahead);\r\nswhead = ppd->sdma_descq_head;\r\nswtail = ppd->sdma_descq_tail;\r\ncnt = ppd->sdma_descq_cnt;\r\nif (swhead < swtail) {\r\nsane = (hwhead >= swhead) & (hwhead <= swtail);\r\n} else if (swhead > swtail) {\r\nsane = ((hwhead >= swhead) && (hwhead < cnt)) ||\r\n(hwhead <= swtail);\r\n} else {\r\nsane = (hwhead == swhead);\r\n}\r\nif (unlikely(!sane)) {\r\nif (use_dmahead) {\r\nuse_dmahead = 0;\r\ngoto retry;\r\n}\r\nhwhead = swhead;\r\n}\r\nreturn hwhead;\r\n}\r\nstatic int qib_sdma_7220_busy(struct qib_pportdata *ppd)\r\n{\r\nu64 hwstatus = qib_read_kreg64(ppd->dd, kr_senddmastatus);\r\nreturn (hwstatus & SYM_MASK(SendDmaStatus, ScoreBoardDrainInProg)) ||\r\n(hwstatus & SYM_MASK(SendDmaStatus, AbortInProg)) ||\r\n(hwstatus & SYM_MASK(SendDmaStatus, InternalSDmaEnable)) ||\r\n!(hwstatus & SYM_MASK(SendDmaStatus, ScbEmpty));\r\n}\r\nstatic u32 qib_7220_setpbc_control(struct qib_pportdata *ppd, u32 plen,\r\nu8 srate, u8 vl)\r\n{\r\nu8 snd_mult = ppd->delay_mult;\r\nu8 rcv_mult = ib_rate_to_delay[srate];\r\nu32 ret = ppd->cpspec->last_delay_mult;\r\nppd->cpspec->last_delay_mult = (rcv_mult > snd_mult) ?\r\n(plen * (rcv_mult - snd_mult) + 1) >> 1 : 0;\r\nif (vl == 15)\r\nret |= PBC_7220_VL15_SEND_CTRL;\r\nreturn ret;\r\n}\r\nstatic void qib_7220_initvl15_bufs(struct qib_devdata *dd)\r\n{\r\n}\r\nstatic void qib_7220_init_ctxt(struct qib_ctxtdata *rcd)\r\n{\r\nif (!rcd->ctxt) {\r\nrcd->rcvegrcnt = IBA7220_KRCVEGRCNT;\r\nrcd->rcvegr_tid_base = 0;\r\n} else {\r\nrcd->rcvegrcnt = rcd->dd->cspec->rcvegrcnt;\r\nrcd->rcvegr_tid_base = IBA7220_KRCVEGRCNT +\r\n(rcd->ctxt - 1) * rcd->rcvegrcnt;\r\n}\r\n}\r\nstatic void qib_7220_txchk_change(struct qib_devdata *dd, u32 start,\r\nu32 len, u32 which, struct qib_ctxtdata *rcd)\r\n{\r\nint i;\r\nunsigned long flags;\r\nswitch (which) {\r\ncase TXCHK_CHG_TYPE_KERN:\r\nspin_lock_irqsave(&dd->uctxt_lock, flags);\r\nfor (i = dd->first_user_ctxt;\r\ndd->cspec->updthresh != dd->cspec->updthresh_dflt\r\n&& i < dd->cfgctxts; i++)\r\nif (dd->rcd[i] && dd->rcd[i]->subctxt_cnt &&\r\n((dd->rcd[i]->piocnt / dd->rcd[i]->subctxt_cnt) - 1)\r\n< dd->cspec->updthresh_dflt)\r\nbreak;\r\nspin_unlock_irqrestore(&dd->uctxt_lock, flags);\r\nif (i == dd->cfgctxts) {\r\nspin_lock_irqsave(&dd->sendctrl_lock, flags);\r\ndd->cspec->updthresh = dd->cspec->updthresh_dflt;\r\ndd->sendctrl &= ~SYM_MASK(SendCtrl, AvailUpdThld);\r\ndd->sendctrl |= (dd->cspec->updthresh &\r\nSYM_RMASK(SendCtrl, AvailUpdThld)) <<\r\nSYM_LSB(SendCtrl, AvailUpdThld);\r\nspin_unlock_irqrestore(&dd->sendctrl_lock, flags);\r\nsendctrl_7220_mod(dd->pport, QIB_SENDCTRL_AVAIL_BLIP);\r\n}\r\nbreak;\r\ncase TXCHK_CHG_TYPE_USER:\r\nspin_lock_irqsave(&dd->sendctrl_lock, flags);\r\nif (rcd && rcd->subctxt_cnt && ((rcd->piocnt\r\n/ rcd->subctxt_cnt) - 1) < dd->cspec->updthresh) {\r\ndd->cspec->updthresh = (rcd->piocnt /\r\nrcd->subctxt_cnt) - 1;\r\ndd->sendctrl &= ~SYM_MASK(SendCtrl, AvailUpdThld);\r\ndd->sendctrl |= (dd->cspec->updthresh &\r\nSYM_RMASK(SendCtrl, AvailUpdThld))\r\n<< SYM_LSB(SendCtrl, AvailUpdThld);\r\nspin_unlock_irqrestore(&dd->sendctrl_lock, flags);\r\nsendctrl_7220_mod(dd->pport, QIB_SENDCTRL_AVAIL_BLIP);\r\n} else\r\nspin_unlock_irqrestore(&dd->sendctrl_lock, flags);\r\nbreak;\r\n}\r\n}\r\nstatic void writescratch(struct qib_devdata *dd, u32 val)\r\n{\r\nqib_write_kreg(dd, kr_scratch, val);\r\n}\r\nstatic int qib_7220_tempsense_rd(struct qib_devdata *dd, int regnum)\r\n{\r\nint ret;\r\nu8 rdata;\r\nif (regnum > 7) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nif (!((1 << regnum) & VALID_TS_RD_REG_MASK)) {\r\nret = 0;\r\ngoto bail;\r\n}\r\nret = mutex_lock_interruptible(&dd->eep_lock);\r\nif (ret)\r\ngoto bail;\r\nret = qib_twsi_blk_rd(dd, QIB_TWSI_TEMP_DEV, regnum, &rdata, 1);\r\nif (!ret)\r\nret = rdata;\r\nmutex_unlock(&dd->eep_lock);\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int qib_7220_eeprom_wen(struct qib_devdata *dd, int wen)\r\n{\r\nreturn 1;\r\n}\r\nstruct qib_devdata *qib_init_iba7220_funcs(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct qib_devdata *dd;\r\nint ret;\r\nu32 boardid, minwidth;\r\ndd = qib_alloc_devdata(pdev, sizeof(struct qib_chip_specific) +\r\nsizeof(struct qib_chippport_specific));\r\nif (IS_ERR(dd))\r\ngoto bail;\r\ndd->f_bringup_serdes = qib_7220_bringup_serdes;\r\ndd->f_cleanup = qib_setup_7220_cleanup;\r\ndd->f_clear_tids = qib_7220_clear_tids;\r\ndd->f_free_irq = qib_7220_free_irq;\r\ndd->f_get_base_info = qib_7220_get_base_info;\r\ndd->f_get_msgheader = qib_7220_get_msgheader;\r\ndd->f_getsendbuf = qib_7220_getsendbuf;\r\ndd->f_gpio_mod = gpio_7220_mod;\r\ndd->f_eeprom_wen = qib_7220_eeprom_wen;\r\ndd->f_hdrqempty = qib_7220_hdrqempty;\r\ndd->f_ib_updown = qib_7220_ib_updown;\r\ndd->f_init_ctxt = qib_7220_init_ctxt;\r\ndd->f_initvl15_bufs = qib_7220_initvl15_bufs;\r\ndd->f_intr_fallback = qib_7220_intr_fallback;\r\ndd->f_late_initreg = qib_late_7220_initreg;\r\ndd->f_setpbc_control = qib_7220_setpbc_control;\r\ndd->f_portcntr = qib_portcntr_7220;\r\ndd->f_put_tid = qib_7220_put_tid;\r\ndd->f_quiet_serdes = qib_7220_quiet_serdes;\r\ndd->f_rcvctrl = rcvctrl_7220_mod;\r\ndd->f_read_cntrs = qib_read_7220cntrs;\r\ndd->f_read_portcntrs = qib_read_7220portcntrs;\r\ndd->f_reset = qib_setup_7220_reset;\r\ndd->f_init_sdma_regs = init_sdma_7220_regs;\r\ndd->f_sdma_busy = qib_sdma_7220_busy;\r\ndd->f_sdma_gethead = qib_sdma_7220_gethead;\r\ndd->f_sdma_sendctrl = qib_7220_sdma_sendctrl;\r\ndd->f_sdma_set_desc_cnt = qib_sdma_set_7220_desc_cnt;\r\ndd->f_sdma_update_tail = qib_sdma_update_7220_tail;\r\ndd->f_sdma_hw_clean_up = qib_7220_sdma_hw_clean_up;\r\ndd->f_sdma_hw_start_up = qib_7220_sdma_hw_start_up;\r\ndd->f_sdma_init_early = qib_7220_sdma_init_early;\r\ndd->f_sendctrl = sendctrl_7220_mod;\r\ndd->f_set_armlaunch = qib_set_7220_armlaunch;\r\ndd->f_set_cntr_sample = qib_set_cntr_7220_sample;\r\ndd->f_iblink_state = qib_7220_iblink_state;\r\ndd->f_ibphys_portstate = qib_7220_phys_portstate;\r\ndd->f_get_ib_cfg = qib_7220_get_ib_cfg;\r\ndd->f_set_ib_cfg = qib_7220_set_ib_cfg;\r\ndd->f_set_ib_loopback = qib_7220_set_loopback;\r\ndd->f_set_intr_state = qib_7220_set_intr_state;\r\ndd->f_setextled = qib_setup_7220_setextled;\r\ndd->f_txchk_change = qib_7220_txchk_change;\r\ndd->f_update_usrhead = qib_update_7220_usrhead;\r\ndd->f_wantpiobuf_intr = qib_wantpiobuf_7220_intr;\r\ndd->f_xgxs_reset = qib_7220_xgxs_reset;\r\ndd->f_writescratch = writescratch;\r\ndd->f_tempsense_rd = qib_7220_tempsense_rd;\r\nret = qib_pcie_ddinit(dd, pdev, ent);\r\nif (ret < 0)\r\ngoto bail_free;\r\nret = qib_init_7220_variables(dd);\r\nif (ret)\r\ngoto bail_cleanup;\r\nif (qib_mini_init)\r\ngoto bail;\r\nboardid = SYM_FIELD(dd->revision, Revision,\r\nBoardID);\r\nswitch (boardid) {\r\ncase 0:\r\ncase 2:\r\ncase 10:\r\ncase 12:\r\nminwidth = 16;\r\nbreak;\r\ndefault:\r\nminwidth = 8;\r\nbreak;\r\n}\r\nif (qib_pcie_params(dd, minwidth, NULL, NULL))\r\nqib_dev_err(dd, "Failed to setup PCIe or interrupts; "\r\n"continuing anyway\n");\r\ndd->cspec->irq = pdev->irq;\r\nif (qib_read_kreg64(dd, kr_hwerrstatus) &\r\nQLOGIC_IB_HWE_SERDESPLLFAILED)\r\nqib_write_kreg(dd, kr_hwerrclear,\r\nQLOGIC_IB_HWE_SERDESPLLFAILED);\r\nqib_setup_7220_interrupt(dd);\r\nqib_7220_init_hwerrors(dd);\r\nqib_write_kreg(dd, kr_hwdiagctrl, 0);\r\ngoto bail;\r\nbail_cleanup:\r\nqib_pcie_ddcleanup(dd);\r\nbail_free:\r\nqib_free_devdata(dd);\r\ndd = ERR_PTR(ret);\r\nbail:\r\nreturn dd;\r\n}
