static void imx_keypad_scan_matrix(struct imx_keypad *keypad,\r\nunsigned short *matrix_volatile_state)\r\n{\r\nint col;\r\nunsigned short reg_val;\r\nfor (col = 0; col < MAX_MATRIX_KEY_COLS; col++) {\r\nif ((keypad->cols_en_mask & (1 << col)) == 0)\r\ncontinue;\r\nreg_val = readw(keypad->mmio_base + KPDR);\r\nreg_val |= 0xff00;\r\nwritew(reg_val, keypad->mmio_base + KPDR);\r\nreg_val = readw(keypad->mmio_base + KPCR);\r\nreg_val &= ~((keypad->cols_en_mask & 0xff) << 8);\r\nwritew(reg_val, keypad->mmio_base + KPCR);\r\nudelay(2);\r\nreg_val = readw(keypad->mmio_base + KPCR);\r\nreg_val |= (keypad->cols_en_mask & 0xff) << 8;\r\nwritew(reg_val, keypad->mmio_base + KPCR);\r\nreg_val = readw(keypad->mmio_base + KPDR);\r\nreg_val &= ~(1 << (8 + col));\r\nwritew(reg_val, keypad->mmio_base + KPDR);\r\nudelay(5);\r\nreg_val = readw(keypad->mmio_base + KPDR);\r\nmatrix_volatile_state[col] = (~reg_val) & keypad->rows_en_mask;\r\n}\r\nreg_val = readw(keypad->mmio_base + KPDR);\r\nreg_val &= 0x00ff;\r\nwritew(reg_val, keypad->mmio_base + KPDR);\r\n}\r\nstatic void imx_keypad_fire_events(struct imx_keypad *keypad,\r\nunsigned short *matrix_volatile_state)\r\n{\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nint row, col;\r\nfor (col = 0; col < MAX_MATRIX_KEY_COLS; col++) {\r\nunsigned short bits_changed;\r\nint code;\r\nif ((keypad->cols_en_mask & (1 << col)) == 0)\r\ncontinue;\r\nbits_changed = keypad->matrix_stable_state[col] ^\r\nmatrix_volatile_state[col];\r\nif (bits_changed == 0)\r\ncontinue;\r\nfor (row = 0; row < MAX_MATRIX_KEY_ROWS; row++) {\r\nif ((keypad->rows_en_mask & (1 << row)) == 0)\r\ncontinue;\r\nif ((bits_changed & (1 << row)) == 0)\r\ncontinue;\r\ncode = MATRIX_SCAN_CODE(row, col, MATRIX_ROW_SHIFT);\r\ninput_event(input_dev, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(input_dev, keypad->keycodes[code],\r\nmatrix_volatile_state[col] & (1 << row));\r\ndev_dbg(&input_dev->dev, "Event code: %d, val: %d",\r\nkeypad->keycodes[code],\r\nmatrix_volatile_state[col] & (1 << row));\r\n}\r\n}\r\ninput_sync(input_dev);\r\n}\r\nstatic void imx_keypad_check_for_events(unsigned long data)\r\n{\r\nstruct imx_keypad *keypad = (struct imx_keypad *) data;\r\nunsigned short matrix_volatile_state[MAX_MATRIX_KEY_COLS];\r\nunsigned short reg_val;\r\nbool state_changed, is_zero_matrix;\r\nint i;\r\nmemset(matrix_volatile_state, 0, sizeof(matrix_volatile_state));\r\nimx_keypad_scan_matrix(keypad, matrix_volatile_state);\r\nstate_changed = false;\r\nfor (i = 0; i < MAX_MATRIX_KEY_COLS; i++) {\r\nif ((keypad->cols_en_mask & (1 << i)) == 0)\r\ncontinue;\r\nif (keypad->matrix_unstable_state[i] ^ matrix_volatile_state[i]) {\r\nstate_changed = true;\r\nbreak;\r\n}\r\n}\r\nif (state_changed) {\r\nmemcpy(keypad->matrix_unstable_state, matrix_volatile_state,\r\nsizeof(matrix_volatile_state));\r\nkeypad->stable_count = 0;\r\n} else\r\nkeypad->stable_count++;\r\nif (keypad->stable_count < IMX_KEYPAD_SCANS_FOR_STABILITY) {\r\nmod_timer(&keypad->check_matrix_timer,\r\njiffies + msecs_to_jiffies(10));\r\nreturn;\r\n}\r\nif (keypad->stable_count == IMX_KEYPAD_SCANS_FOR_STABILITY) {\r\nimx_keypad_fire_events(keypad, matrix_volatile_state);\r\nmemcpy(keypad->matrix_stable_state, matrix_volatile_state,\r\nsizeof(matrix_volatile_state));\r\n}\r\nis_zero_matrix = true;\r\nfor (i = 0; i < MAX_MATRIX_KEY_COLS; i++) {\r\nif (matrix_volatile_state[i] != 0) {\r\nis_zero_matrix = false;\r\nbreak;\r\n}\r\n}\r\nif (is_zero_matrix) {\r\nreg_val = readw(keypad->mmio_base + KPSR);\r\nreg_val |= KBD_STAT_KPKD | KBD_STAT_KDSC;\r\nwritew(reg_val, keypad->mmio_base + KPSR);\r\nreg_val = readw(keypad->mmio_base + KPSR);\r\nreg_val |= KBD_STAT_KDIE;\r\nreg_val &= ~KBD_STAT_KRIE;\r\nwritew(reg_val, keypad->mmio_base + KPSR);\r\n} else {\r\nmod_timer(&keypad->check_matrix_timer,\r\njiffies + msecs_to_jiffies(60));\r\nreg_val = readw(keypad->mmio_base + KPSR);\r\nreg_val |= KBD_STAT_KPKR | KBD_STAT_KRSS;\r\nwritew(reg_val, keypad->mmio_base + KPSR);\r\nreg_val = readw(keypad->mmio_base + KPSR);\r\nreg_val |= KBD_STAT_KRIE;\r\nreg_val &= ~KBD_STAT_KDIE;\r\nwritew(reg_val, keypad->mmio_base + KPSR);\r\n}\r\n}\r\nstatic irqreturn_t imx_keypad_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct imx_keypad *keypad = dev_id;\r\nunsigned short reg_val;\r\nreg_val = readw(keypad->mmio_base + KPSR);\r\nreg_val &= ~(KBD_STAT_KRIE | KBD_STAT_KDIE);\r\nreg_val |= KBD_STAT_KPKR | KBD_STAT_KPKD;\r\nwritew(reg_val, keypad->mmio_base + KPSR);\r\nif (keypad->enabled) {\r\nkeypad->stable_count = 0;\r\nmod_timer(&keypad->check_matrix_timer,\r\njiffies + msecs_to_jiffies(2));\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void imx_keypad_config(struct imx_keypad *keypad)\r\n{\r\nunsigned short reg_val;\r\nreg_val = readw(keypad->mmio_base + KPCR);\r\nreg_val |= keypad->rows_en_mask & 0xff;\r\nreg_val |= (keypad->cols_en_mask & 0xff) << 8;\r\nwritew(reg_val, keypad->mmio_base + KPCR);\r\nreg_val = readw(keypad->mmio_base + KPDR);\r\nreg_val &= 0x00ff;\r\nwritew(reg_val, keypad->mmio_base + KPDR);\r\nwritew(0xff00, keypad->mmio_base + KDDR);\r\nreg_val = readw(keypad->mmio_base + KPSR);\r\nreg_val |= KBD_STAT_KPKR | KBD_STAT_KPKD |\r\nKBD_STAT_KDSC | KBD_STAT_KRSS;\r\nwritew(reg_val, keypad->mmio_base + KPSR);\r\nreg_val |= KBD_STAT_KDIE;\r\nreg_val &= ~KBD_STAT_KRIE;\r\nwritew(reg_val, keypad->mmio_base + KPSR);\r\n}\r\nstatic void imx_keypad_inhibit(struct imx_keypad *keypad)\r\n{\r\nunsigned short reg_val;\r\nreg_val = readw(keypad->mmio_base + KPSR);\r\nreg_val &= ~(KBD_STAT_KRIE | KBD_STAT_KDIE);\r\nwritew(reg_val, keypad->mmio_base + KPSR);\r\nwritew(0xff00, keypad->mmio_base + KPCR);\r\n}\r\nstatic void imx_keypad_close(struct input_dev *dev)\r\n{\r\nstruct imx_keypad *keypad = input_get_drvdata(dev);\r\ndev_dbg(&dev->dev, ">%s\n", __func__);\r\nkeypad->enabled = false;\r\nsynchronize_irq(keypad->irq);\r\ndel_timer_sync(&keypad->check_matrix_timer);\r\nimx_keypad_inhibit(keypad);\r\nclk_disable(keypad->clk);\r\n}\r\nstatic int imx_keypad_open(struct input_dev *dev)\r\n{\r\nstruct imx_keypad *keypad = input_get_drvdata(dev);\r\ndev_dbg(&dev->dev, ">%s\n", __func__);\r\nkeypad->enabled = true;\r\nclk_enable(keypad->clk);\r\nimx_keypad_config(keypad);\r\nif ((readw(keypad->mmio_base + KPDR) & keypad->rows_en_mask) == 0) {\r\ndev_err(&dev->dev,\r\n"too many keys pressed, control pins initialisation\n");\r\ngoto open_err;\r\n}\r\nreturn 0;\r\nopen_err:\r\nimx_keypad_close(dev);\r\nreturn -EIO;\r\n}\r\nstatic int __devinit imx_keypad_probe(struct platform_device *pdev)\r\n{\r\nconst struct matrix_keymap_data *keymap_data = pdev->dev.platform_data;\r\nstruct imx_keypad *keypad;\r\nstruct input_dev *input_dev;\r\nstruct resource *res;\r\nint irq, error, i;\r\nif (keymap_data == NULL) {\r\ndev_err(&pdev->dev, "no keymap defined\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no irq defined in platform data\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "no I/O memory defined in platform data\n");\r\nreturn -EINVAL;\r\n}\r\nres = request_mem_region(res->start, resource_size(res), pdev->name);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "failed to request I/O memory\n");\r\nreturn -EBUSY;\r\n}\r\ninput_dev = input_allocate_device();\r\nif (!input_dev) {\r\ndev_err(&pdev->dev, "failed to allocate the input device\n");\r\nerror = -ENOMEM;\r\ngoto failed_rel_mem;\r\n}\r\nkeypad = kzalloc(sizeof(struct imx_keypad), GFP_KERNEL);\r\nif (!keypad) {\r\ndev_err(&pdev->dev, "not enough memory for driver data\n");\r\nerror = -ENOMEM;\r\ngoto failed_free_input;\r\n}\r\nkeypad->input_dev = input_dev;\r\nkeypad->irq = irq;\r\nkeypad->stable_count = 0;\r\nsetup_timer(&keypad->check_matrix_timer,\r\nimx_keypad_check_for_events, (unsigned long) keypad);\r\nkeypad->mmio_base = ioremap(res->start, resource_size(res));\r\nif (keypad->mmio_base == NULL) {\r\ndev_err(&pdev->dev, "failed to remap I/O memory\n");\r\nerror = -ENOMEM;\r\ngoto failed_free_priv;\r\n}\r\nkeypad->clk = clk_get(&pdev->dev, "kpp");\r\nif (IS_ERR(keypad->clk)) {\r\ndev_err(&pdev->dev, "failed to get keypad clock\n");\r\nerror = PTR_ERR(keypad->clk);\r\ngoto failed_unmap;\r\n}\r\nfor (i = 0; i < keymap_data->keymap_size; i++) {\r\nkeypad->rows_en_mask |= 1 << KEY_ROW(keymap_data->keymap[i]);\r\nkeypad->cols_en_mask |= 1 << KEY_COL(keymap_data->keymap[i]);\r\n}\r\nif (keypad->rows_en_mask > ((1 << MAX_MATRIX_KEY_ROWS) - 1) ||\r\nkeypad->cols_en_mask > ((1 << MAX_MATRIX_KEY_COLS) - 1)) {\r\ndev_err(&pdev->dev,\r\n"invalid key data (too many rows or colums)\n");\r\nerror = -EINVAL;\r\ngoto failed_clock_put;\r\n}\r\ndev_dbg(&pdev->dev, "enabled rows mask: %x\n", keypad->rows_en_mask);\r\ndev_dbg(&pdev->dev, "enabled cols mask: %x\n", keypad->cols_en_mask);\r\ninput_dev->name = pdev->name;\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->dev.parent = &pdev->dev;\r\ninput_dev->open = imx_keypad_open;\r\ninput_dev->close = imx_keypad_close;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);\r\ninput_dev->keycode = keypad->keycodes;\r\ninput_dev->keycodesize = sizeof(keypad->keycodes[0]);\r\ninput_dev->keycodemax = ARRAY_SIZE(keypad->keycodes);\r\nmatrix_keypad_build_keymap(keymap_data, MATRIX_ROW_SHIFT,\r\nkeypad->keycodes, input_dev->keybit);\r\ninput_set_capability(input_dev, EV_MSC, MSC_SCAN);\r\ninput_set_drvdata(input_dev, keypad);\r\nimx_keypad_inhibit(keypad);\r\nerror = request_irq(irq, imx_keypad_irq_handler, 0,\r\npdev->name, keypad);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to request IRQ\n");\r\ngoto failed_clock_put;\r\n}\r\nerror = input_register_device(input_dev);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to register input device\n");\r\ngoto failed_free_irq;\r\n}\r\nplatform_set_drvdata(pdev, keypad);\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nreturn 0;\r\nfailed_free_irq:\r\nfree_irq(irq, pdev);\r\nfailed_clock_put:\r\nclk_put(keypad->clk);\r\nfailed_unmap:\r\niounmap(keypad->mmio_base);\r\nfailed_free_priv:\r\nkfree(keypad);\r\nfailed_free_input:\r\ninput_free_device(input_dev);\r\nfailed_rel_mem:\r\nrelease_mem_region(res->start, resource_size(res));\r\nreturn error;\r\n}\r\nstatic int __devexit imx_keypad_remove(struct platform_device *pdev)\r\n{\r\nstruct imx_keypad *keypad = platform_get_drvdata(pdev);\r\nstruct resource *res;\r\ndev_dbg(&pdev->dev, ">%s\n", __func__);\r\nplatform_set_drvdata(pdev, NULL);\r\ninput_unregister_device(keypad->input_dev);\r\nfree_irq(keypad->irq, keypad);\r\nclk_put(keypad->clk);\r\niounmap(keypad->mmio_base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\nkfree(keypad);\r\nreturn 0;\r\n}\r\nstatic int imx_kbd_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct imx_keypad *kbd = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = kbd->input_dev;\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\nclk_disable(kbd->clk);\r\nmutex_unlock(&input_dev->mutex);\r\nif (device_may_wakeup(&pdev->dev))\r\nenable_irq_wake(kbd->irq);\r\nreturn 0;\r\n}\r\nstatic int imx_kbd_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct imx_keypad *kbd = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = kbd->input_dev;\r\nif (device_may_wakeup(&pdev->dev))\r\ndisable_irq_wake(kbd->irq);\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\nclk_enable(kbd->clk);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}
