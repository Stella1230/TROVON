static int ak4641_set_deemph(struct snd_soc_codec *codec)\r\n{\r\nstruct ak4641_priv *ak4641 = snd_soc_codec_get_drvdata(codec);\r\nint i, best = 0;\r\nfor (i = 0 ; i < ARRAY_SIZE(deemph_settings); i++) {\r\nif (ak4641->deemph && deemph_settings[i] != 0 &&\r\nabs(deemph_settings[i] - ak4641->playback_fs) <\r\nabs(deemph_settings[best] - ak4641->playback_fs))\r\nbest = i;\r\nif (!ak4641->deemph && deemph_settings[i] == 0)\r\nbest = i;\r\n}\r\ndev_dbg(codec->dev, "Set deemphasis %d\n", best);\r\nreturn snd_soc_update_bits(codec, AK4641_DAC, 0x3, best);\r\n}\r\nstatic int ak4641_put_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ak4641_priv *ak4641 = snd_soc_codec_get_drvdata(codec);\r\nint deemph = ucontrol->value.enumerated.item[0];\r\nif (deemph > 1)\r\nreturn -EINVAL;\r\nak4641->deemph = deemph;\r\nreturn ak4641_set_deemph(codec);\r\n}\r\nstatic int ak4641_get_deemph(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ak4641_priv *ak4641 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.enumerated.item[0] = ak4641->deemph;\r\nreturn 0;\r\n}\r\nstatic int ak4641_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct ak4641_priv *ak4641 = snd_soc_codec_get_drvdata(codec);\r\nak4641->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int ak4641_i2s_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_codec *codec = rtd->codec;\r\nstruct ak4641_priv *ak4641 = snd_soc_codec_get_drvdata(codec);\r\nint rate = params_rate(params), fs = 256;\r\nu8 mode2;\r\nif (rate)\r\nfs = ak4641->sysclk / rate;\r\nelse\r\nreturn -EINVAL;\r\nswitch (fs) {\r\ncase 1024:\r\nmode2 = (0x2 << 5);\r\nbreak;\r\ncase 512:\r\nmode2 = (0x1 << 5);\r\nbreak;\r\ncase 256:\r\nmode2 = (0x0 << 5);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Error: unsupported fs=%d\n", fs);\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, AK4641_MODE2, (0x3 << 5), mode2);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nak4641->playback_fs = rate;\r\nak4641_set_deemph(codec);\r\n};\r\nreturn 0;\r\n}\r\nstatic int ak4641_pcm_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu8 btif;\r\nint ret;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nbtif = (0x3 << 5);\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nbtif = (0x2 << 5);\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nbtif = (0x0 << 5);\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nbtif = (0x1 << 5);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = snd_soc_update_bits(codec, AK4641_BTIF, (0x3 << 5), btif);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int ak4641_i2s_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu8 mode1 = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nmode1 = 0x02;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nmode1 = 0x01;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn snd_soc_write(codec, AK4641_MODE1, mode1);\r\n}\r\nstatic int ak4641_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nreturn snd_soc_update_bits(codec, AK4641_DAC, 0x20, mute ? 0x20 : 0);\r\n}\r\nstatic int ak4641_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct ak4641_platform_data *pdata = codec->dev->platform_data;\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nsnd_soc_update_bits(codec, AK4641_DAC, 0x20, 0);\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_update_bits(codec, AK4641_DAC, 0x20, 0x20);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nif (pdata && gpio_is_valid(pdata->gpio_power))\r\ngpio_set_value(pdata->gpio_power, 1);\r\nmdelay(1);\r\nif (pdata && gpio_is_valid(pdata->gpio_npdn))\r\ngpio_set_value(pdata->gpio_npdn, 1);\r\nmdelay(1);\r\nret = snd_soc_cache_sync(codec);\r\nif (ret) {\r\ndev_err(codec->dev,\r\n"Failed to sync cache: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nsnd_soc_update_bits(codec, AK4641_PM1, 0x80, 0x80);\r\nsnd_soc_update_bits(codec, AK4641_PM2, 0x80, 0);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, AK4641_PM1, 0x80, 0);\r\nif (pdata && gpio_is_valid(pdata->gpio_npdn))\r\ngpio_set_value(pdata->gpio_npdn, 0);\r\nif (pdata && gpio_is_valid(pdata->gpio_power))\r\ngpio_set_value(pdata->gpio_power, 0);\r\ncodec->cache_sync = 1;\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int ak4641_suspend(struct snd_soc_codec *codec)\r\n{\r\nak4641_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int ak4641_resume(struct snd_soc_codec *codec)\r\n{\r\nak4641_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int ak4641_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct ak4641_platform_data *pdata = codec->dev->platform_data;\r\nint ret;\r\nif (pdata) {\r\nif (gpio_is_valid(pdata->gpio_power)) {\r\nret = gpio_request_one(pdata->gpio_power,\r\nGPIOF_OUT_INIT_LOW, "ak4641 power");\r\nif (ret)\r\ngoto err_out;\r\n}\r\nif (gpio_is_valid(pdata->gpio_npdn)) {\r\nret = gpio_request_one(pdata->gpio_npdn,\r\nGPIOF_OUT_INIT_LOW, "ak4641 npdn");\r\nif (ret)\r\ngoto err_gpio;\r\nudelay(1);\r\ngpio_set_value(pdata->gpio_npdn, 1);\r\n}\r\n}\r\nret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_I2C);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\ngoto err_register;\r\n}\r\nak4641_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\nerr_register:\r\nif (pdata) {\r\nif (gpio_is_valid(pdata->gpio_power))\r\ngpio_set_value(pdata->gpio_power, 0);\r\nif (gpio_is_valid(pdata->gpio_npdn))\r\ngpio_free(pdata->gpio_npdn);\r\n}\r\nerr_gpio:\r\nif (pdata && gpio_is_valid(pdata->gpio_power))\r\ngpio_free(pdata->gpio_power);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic int ak4641_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct ak4641_platform_data *pdata = codec->dev->platform_data;\r\nak4641_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nif (pdata) {\r\nif (gpio_is_valid(pdata->gpio_power)) {\r\ngpio_set_value(pdata->gpio_power, 0);\r\ngpio_free(pdata->gpio_power);\r\n}\r\nif (gpio_is_valid(pdata->gpio_npdn))\r\ngpio_free(pdata->gpio_npdn);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devinit ak4641_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ak4641_priv *ak4641;\r\nint ret;\r\nak4641 = devm_kzalloc(&i2c->dev, sizeof(struct ak4641_priv),\r\nGFP_KERNEL);\r\nif (!ak4641)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, ak4641);\r\nret = snd_soc_register_codec(&i2c->dev, &soc_codec_dev_ak4641,\r\nak4641_dai, ARRAY_SIZE(ak4641_dai));\r\nreturn ret;\r\n}\r\nstatic int __devexit ak4641_i2c_remove(struct i2c_client *i2c)\r\n{\r\nsnd_soc_unregister_codec(&i2c->dev);\r\nreturn 0;\r\n}\r\nstatic int __init ak4641_modinit(void)\r\n{\r\nint ret;\r\nret = i2c_add_driver(&ak4641_i2c_driver);\r\nif (ret != 0)\r\npr_err("Failed to register AK4641 I2C driver: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void __exit ak4641_exit(void)\r\n{\r\ni2c_del_driver(&ak4641_i2c_driver);\r\n}
