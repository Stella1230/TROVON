static unsigned int cpm_uart_tx_empty(struct uart_port *port)\r\n{\r\nstruct uart_cpm_port *pinfo = (struct uart_cpm_port *)port;\r\ncbd_t __iomem *bdp = pinfo->tx_bd_base;\r\nint ret = 0;\r\nwhile (1) {\r\nif (in_be16(&bdp->cbd_sc) & BD_SC_READY)\r\nbreak;\r\nif (in_be16(&bdp->cbd_sc) & BD_SC_WRAP) {\r\nret = TIOCSER_TEMT;\r\nbreak;\r\n}\r\nbdp++;\r\n}\r\npr_debug("CPM uart[%d]:tx_empty: %d\n", port->line, ret);\r\nreturn ret;\r\n}\r\nstatic void cpm_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct uart_cpm_port *pinfo = (struct uart_cpm_port *)port;\r\nif (pinfo->gpios[GPIO_RTS] >= 0)\r\ngpio_set_value(pinfo->gpios[GPIO_RTS], !(mctrl & TIOCM_RTS));\r\nif (pinfo->gpios[GPIO_DTR] >= 0)\r\ngpio_set_value(pinfo->gpios[GPIO_DTR], !(mctrl & TIOCM_DTR));\r\n}\r\nstatic unsigned int cpm_uart_get_mctrl(struct uart_port *port)\r\n{\r\nstruct uart_cpm_port *pinfo = (struct uart_cpm_port *)port;\r\nunsigned int mctrl = TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\r\nif (pinfo->gpios[GPIO_CTS] >= 0) {\r\nif (gpio_get_value(pinfo->gpios[GPIO_CTS]))\r\nmctrl &= ~TIOCM_CTS;\r\n}\r\nif (pinfo->gpios[GPIO_DSR] >= 0) {\r\nif (gpio_get_value(pinfo->gpios[GPIO_DSR]))\r\nmctrl &= ~TIOCM_DSR;\r\n}\r\nif (pinfo->gpios[GPIO_DCD] >= 0) {\r\nif (gpio_get_value(pinfo->gpios[GPIO_DCD]))\r\nmctrl &= ~TIOCM_CAR;\r\n}\r\nif (pinfo->gpios[GPIO_RI] >= 0) {\r\nif (!gpio_get_value(pinfo->gpios[GPIO_RI]))\r\nmctrl |= TIOCM_RNG;\r\n}\r\nreturn mctrl;\r\n}\r\nstatic void cpm_uart_stop_tx(struct uart_port *port)\r\n{\r\nstruct uart_cpm_port *pinfo = (struct uart_cpm_port *)port;\r\nsmc_t __iomem *smcp = pinfo->smcp;\r\nscc_t __iomem *sccp = pinfo->sccp;\r\npr_debug("CPM uart[%d]:stop tx\n", port->line);\r\nif (IS_SMC(pinfo))\r\nclrbits8(&smcp->smc_smcm, SMCM_TX);\r\nelse\r\nclrbits16(&sccp->scc_sccm, UART_SCCM_TX);\r\n}\r\nstatic void cpm_uart_start_tx(struct uart_port *port)\r\n{\r\nstruct uart_cpm_port *pinfo = (struct uart_cpm_port *)port;\r\nsmc_t __iomem *smcp = pinfo->smcp;\r\nscc_t __iomem *sccp = pinfo->sccp;\r\npr_debug("CPM uart[%d]:start tx\n", port->line);\r\nif (IS_SMC(pinfo)) {\r\nif (in_8(&smcp->smc_smcm) & SMCM_TX)\r\nreturn;\r\n} else {\r\nif (in_be16(&sccp->scc_sccm) & UART_SCCM_TX)\r\nreturn;\r\n}\r\nif (cpm_uart_tx_pump(port) != 0) {\r\nif (IS_SMC(pinfo)) {\r\nsetbits8(&smcp->smc_smcm, SMCM_TX);\r\n} else {\r\nsetbits16(&sccp->scc_sccm, UART_SCCM_TX);\r\n}\r\n}\r\n}\r\nstatic void cpm_uart_stop_rx(struct uart_port *port)\r\n{\r\nstruct uart_cpm_port *pinfo = (struct uart_cpm_port *)port;\r\nsmc_t __iomem *smcp = pinfo->smcp;\r\nscc_t __iomem *sccp = pinfo->sccp;\r\npr_debug("CPM uart[%d]:stop rx\n", port->line);\r\nif (IS_SMC(pinfo))\r\nclrbits8(&smcp->smc_smcm, SMCM_RX);\r\nelse\r\nclrbits16(&sccp->scc_sccm, UART_SCCM_RX);\r\n}\r\nstatic void cpm_uart_enable_ms(struct uart_port *port)\r\n{\r\npr_debug("CPM uart[%d]:enable ms\n", port->line);\r\n}\r\nstatic void cpm_uart_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct uart_cpm_port *pinfo = (struct uart_cpm_port *)port;\r\npr_debug("CPM uart[%d]:break ctrl, break_state: %d\n", port->line,\r\nbreak_state);\r\nif (break_state)\r\ncpm_line_cr_cmd(pinfo, CPM_CR_STOP_TX);\r\nelse\r\ncpm_line_cr_cmd(pinfo, CPM_CR_RESTART_TX);\r\n}\r\nstatic void cpm_uart_int_tx(struct uart_port *port)\r\n{\r\npr_debug("CPM uart[%d]:TX INT\n", port->line);\r\ncpm_uart_tx_pump(port);\r\n}\r\nstatic void cpm_uart_int_rx(struct uart_port *port)\r\n{\r\nint i;\r\nunsigned char ch;\r\nu8 *cp;\r\nstruct tty_struct *tty = port->state->port.tty;\r\nstruct uart_cpm_port *pinfo = (struct uart_cpm_port *)port;\r\ncbd_t __iomem *bdp;\r\nu16 status;\r\nunsigned int flg;\r\npr_debug("CPM uart[%d]:RX INT\n", port->line);\r\nbdp = pinfo->rx_cur;\r\nfor (;;) {\r\n#ifdef CONFIG_CONSOLE_POLL\r\nif (unlikely(serial_polled)) {\r\nserial_polled = 0;\r\nreturn;\r\n}\r\n#endif\r\nstatus = in_be16(&bdp->cbd_sc);\r\nif (status & BD_SC_EMPTY)\r\nbreak;\r\ni = in_be16(&bdp->cbd_datlen);\r\nif(tty_buffer_request_room(tty, i) < i) {\r\nprintk(KERN_WARNING "No room in flip buffer\n");\r\nreturn;\r\n}\r\ncp = cpm2cpu_addr(in_be32(&bdp->cbd_bufaddr), pinfo);\r\nwhile (i-- > 0) {\r\nch = *cp++;\r\nport->icount.rx++;\r\nflg = TTY_NORMAL;\r\nif (status &\r\n(BD_SC_BR | BD_SC_FR | BD_SC_PR | BD_SC_OV))\r\ngoto handle_error;\r\nif (uart_handle_sysrq_char(port, ch))\r\ncontinue;\r\n#ifdef CONFIG_CONSOLE_POLL\r\nif (unlikely(serial_polled)) {\r\nserial_polled = 0;\r\nreturn;\r\n}\r\n#endif\r\nerror_return:\r\ntty_insert_flip_char(tty, ch, flg);\r\n}\r\nclrbits16(&bdp->cbd_sc, BD_SC_BR | BD_SC_FR | BD_SC_PR |\r\nBD_SC_OV | BD_SC_ID);\r\nsetbits16(&bdp->cbd_sc, BD_SC_EMPTY);\r\nif (in_be16(&bdp->cbd_sc) & BD_SC_WRAP)\r\nbdp = pinfo->rx_bd_base;\r\nelse\r\nbdp++;\r\n}\r\npinfo->rx_cur = bdp;\r\ntty_flip_buffer_push(tty);\r\nreturn;\r\nhandle_error:\r\nif (status & BD_SC_BR)\r\nport->icount.brk++;\r\nif (status & BD_SC_PR)\r\nport->icount.parity++;\r\nif (status & BD_SC_FR)\r\nport->icount.frame++;\r\nif (status & BD_SC_OV)\r\nport->icount.overrun++;\r\nstatus &= port->read_status_mask;\r\nif (status & BD_SC_BR)\r\nflg = TTY_BREAK;\r\nelse if (status & BD_SC_PR)\r\nflg = TTY_PARITY;\r\nelse if (status & BD_SC_FR)\r\nflg = TTY_FRAME;\r\nif (status & BD_SC_OV) {\r\nch = 0;\r\nflg = TTY_OVERRUN;\r\ni = 0;\r\n}\r\n#ifdef SUPPORT_SYSRQ\r\nport->sysrq = 0;\r\n#endif\r\ngoto error_return;\r\n}\r\nstatic irqreturn_t cpm_uart_int(int irq, void *data)\r\n{\r\nu8 events;\r\nstruct uart_port *port = data;\r\nstruct uart_cpm_port *pinfo = (struct uart_cpm_port *)port;\r\nsmc_t __iomem *smcp = pinfo->smcp;\r\nscc_t __iomem *sccp = pinfo->sccp;\r\npr_debug("CPM uart[%d]:IRQ\n", port->line);\r\nif (IS_SMC(pinfo)) {\r\nevents = in_8(&smcp->smc_smce);\r\nout_8(&smcp->smc_smce, events);\r\nif (events & SMCM_BRKE)\r\nuart_handle_break(port);\r\nif (events & SMCM_RX)\r\ncpm_uart_int_rx(port);\r\nif (events & SMCM_TX)\r\ncpm_uart_int_tx(port);\r\n} else {\r\nevents = in_be16(&sccp->scc_scce);\r\nout_be16(&sccp->scc_scce, events);\r\nif (events & UART_SCCM_BRKE)\r\nuart_handle_break(port);\r\nif (events & UART_SCCM_RX)\r\ncpm_uart_int_rx(port);\r\nif (events & UART_SCCM_TX)\r\ncpm_uart_int_tx(port);\r\n}\r\nreturn (events) ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic int cpm_uart_startup(struct uart_port *port)\r\n{\r\nint retval;\r\nstruct uart_cpm_port *pinfo = (struct uart_cpm_port *)port;\r\npr_debug("CPM uart[%d]:startup\n", port->line);\r\nif (!(pinfo->flags & FLAG_CONSOLE)) {\r\nif (IS_SMC(pinfo)) {\r\nclrbits16(&pinfo->smcp->smc_smcmr, SMCMR_REN);\r\nclrbits8(&pinfo->smcp->smc_smcm, SMCM_RX);\r\n} else {\r\nclrbits32(&pinfo->sccp->scc_gsmrl, SCC_GSMRL_ENR);\r\nclrbits16(&pinfo->sccp->scc_sccm, UART_SCCM_RX);\r\n}\r\ncpm_line_cr_cmd(pinfo, CPM_CR_INIT_TRX);\r\n}\r\nretval = request_irq(port->irq, cpm_uart_int, 0, "cpm_uart", port);\r\nif (retval)\r\nreturn retval;\r\nif (IS_SMC(pinfo)) {\r\nsetbits8(&pinfo->smcp->smc_smcm, SMCM_RX);\r\nsetbits16(&pinfo->smcp->smc_smcmr, (SMCMR_REN | SMCMR_TEN));\r\n} else {\r\nsetbits16(&pinfo->sccp->scc_sccm, UART_SCCM_RX);\r\nsetbits32(&pinfo->sccp->scc_gsmrl, (SCC_GSMRL_ENR | SCC_GSMRL_ENT));\r\n}\r\nreturn 0;\r\n}\r\ninline void cpm_uart_wait_until_send(struct uart_cpm_port *pinfo)\r\n{\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(pinfo->wait_closing);\r\n}\r\nstatic void cpm_uart_shutdown(struct uart_port *port)\r\n{\r\nstruct uart_cpm_port *pinfo = (struct uart_cpm_port *)port;\r\npr_debug("CPM uart[%d]:shutdown\n", port->line);\r\nfree_irq(port->irq, port);\r\nif (!(pinfo->flags & FLAG_CONSOLE)) {\r\nwhile(!cpm_uart_tx_empty(port)) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(2);\r\n}\r\nif (pinfo->wait_closing)\r\ncpm_uart_wait_until_send(pinfo);\r\nif (IS_SMC(pinfo)) {\r\nsmc_t __iomem *smcp = pinfo->smcp;\r\nclrbits16(&smcp->smc_smcmr, SMCMR_REN | SMCMR_TEN);\r\nclrbits8(&smcp->smc_smcm, SMCM_RX | SMCM_TX);\r\n} else {\r\nscc_t __iomem *sccp = pinfo->sccp;\r\nclrbits32(&sccp->scc_gsmrl, SCC_GSMRL_ENR | SCC_GSMRL_ENT);\r\nclrbits16(&sccp->scc_sccm, UART_SCCM_TX | UART_SCCM_RX);\r\n}\r\nif (IS_SMC(pinfo)) {\r\nout_be16(&pinfo->smcup->smc_brkcr, 0);\r\ncpm_line_cr_cmd(pinfo, CPM_CR_STOP_TX);\r\n} else {\r\nout_be16(&pinfo->sccup->scc_brkcr, 0);\r\ncpm_line_cr_cmd(pinfo, CPM_CR_GRA_STOP_TX);\r\n}\r\ncpm_uart_initbd(pinfo);\r\n}\r\n}\r\nstatic void cpm_uart_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nint baud;\r\nunsigned long flags;\r\nu16 cval, scval, prev_mode;\r\nint bits, sbits;\r\nstruct uart_cpm_port *pinfo = (struct uart_cpm_port *)port;\r\nsmc_t __iomem *smcp = pinfo->smcp;\r\nscc_t __iomem *sccp = pinfo->sccp;\r\npr_debug("CPM uart[%d]:set_termios\n", port->line);\r\nbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk / 16);\r\nif (baud <= HW_BUF_SPD_THRESHOLD ||\r\n(pinfo->port.state && pinfo->port.state->port.tty->low_latency))\r\npinfo->rx_fifosize = 1;\r\nelse\r\npinfo->rx_fifosize = RX_BUF_SIZE;\r\ncval = 0;\r\nscval = 0;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nbits = 5;\r\nbreak;\r\ncase CS6:\r\nbits = 6;\r\nbreak;\r\ncase CS7:\r\nbits = 7;\r\nbreak;\r\ncase CS8:\r\nbits = 8;\r\nbreak;\r\ndefault:\r\nbits = 8;\r\nbreak;\r\n}\r\nsbits = bits - 5;\r\nif (termios->c_cflag & CSTOPB) {\r\ncval |= SMCMR_SL;\r\nscval |= SCU_PSMR_SL;\r\nbits++;\r\n}\r\nif (termios->c_cflag & PARENB) {\r\ncval |= SMCMR_PEN;\r\nscval |= SCU_PSMR_PEN;\r\nbits++;\r\nif (!(termios->c_cflag & PARODD)) {\r\ncval |= SMCMR_PM_EVEN;\r\nscval |= (SCU_PSMR_REVP | SCU_PSMR_TEVP);\r\n}\r\n}\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\n#define RELEVANT_IFLAG(iflag) (iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))\r\nport->read_status_mask = (BD_SC_EMPTY | BD_SC_OV);\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= BD_SC_FR | BD_SC_PR;\r\nif ((termios->c_iflag & BRKINT) || (termios->c_iflag & PARMRK))\r\nport->read_status_mask |= BD_SC_BR;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= BD_SC_PR | BD_SC_FR;\r\nif (termios->c_iflag & IGNBRK) {\r\nport->ignore_status_mask |= BD_SC_BR;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= BD_SC_OV;\r\n}\r\nif ((termios->c_cflag & CREAD) == 0)\r\nport->read_status_mask &= ~BD_SC_EMPTY;\r\nspin_lock_irqsave(&port->lock, flags);\r\nbits++;\r\nif (IS_SMC(pinfo)) {\r\nout_be16(&pinfo->smcup->smc_mrblr, pinfo->rx_fifosize);\r\nprev_mode = in_be16(&smcp->smc_smcmr) & (SMCMR_REN | SMCMR_TEN);\r\nout_be16(&smcp->smc_smcmr, smcr_mk_clen(bits) | cval |\r\nSMCMR_SM_UART | prev_mode);\r\n} else {\r\nout_be16(&pinfo->sccup->scc_genscc.scc_mrblr, pinfo->rx_fifosize);\r\nout_be16(&sccp->scc_psmr, (sbits << 12) | scval);\r\n}\r\nif (pinfo->clk)\r\nclk_set_rate(pinfo->clk, baud);\r\nelse\r\ncpm_set_brg(pinfo->brg - 1, baud);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *cpm_uart_type(struct uart_port *port)\r\n{\r\npr_debug("CPM uart[%d]:uart_type\n", port->line);\r\nreturn port->type == PORT_CPM ? "CPM UART" : NULL;\r\n}\r\nstatic int cpm_uart_verify_port(struct uart_port *port,\r\nstruct serial_struct *ser)\r\n{\r\nint ret = 0;\r\npr_debug("CPM uart[%d]:verify_port\n", port->line);\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_CPM)\r\nret = -EINVAL;\r\nif (ser->irq < 0 || ser->irq >= nr_irqs)\r\nret = -EINVAL;\r\nif (ser->baud_base < 9600)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int cpm_uart_tx_pump(struct uart_port *port)\r\n{\r\ncbd_t __iomem *bdp;\r\nu8 *p;\r\nint count;\r\nstruct uart_cpm_port *pinfo = (struct uart_cpm_port *)port;\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nif (port->x_char) {\r\nbdp = pinfo->tx_cur;\r\np = cpm2cpu_addr(in_be32(&bdp->cbd_bufaddr), pinfo);\r\n*p++ = port->x_char;\r\nout_be16(&bdp->cbd_datlen, 1);\r\nsetbits16(&bdp->cbd_sc, BD_SC_READY);\r\nif (in_be16(&bdp->cbd_sc) & BD_SC_WRAP)\r\nbdp = pinfo->tx_bd_base;\r\nelse\r\nbdp++;\r\npinfo->tx_cur = bdp;\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn 1;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port)) {\r\ncpm_uart_stop_tx(port);\r\nreturn 0;\r\n}\r\nbdp = pinfo->tx_cur;\r\nwhile (!(in_be16(&bdp->cbd_sc) & BD_SC_READY) &&\r\nxmit->tail != xmit->head) {\r\ncount = 0;\r\np = cpm2cpu_addr(in_be32(&bdp->cbd_bufaddr), pinfo);\r\nwhile (count < pinfo->tx_fifosize) {\r\n*p++ = xmit->buf[xmit->tail];\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\ncount++;\r\nif (xmit->head == xmit->tail)\r\nbreak;\r\n}\r\nout_be16(&bdp->cbd_datlen, count);\r\nsetbits16(&bdp->cbd_sc, BD_SC_READY);\r\nif (in_be16(&bdp->cbd_sc) & BD_SC_WRAP)\r\nbdp = pinfo->tx_bd_base;\r\nelse\r\nbdp++;\r\n}\r\npinfo->tx_cur = bdp;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\nif (uart_circ_empty(xmit)) {\r\ncpm_uart_stop_tx(port);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void cpm_uart_initbd(struct uart_cpm_port *pinfo)\r\n{\r\nint i;\r\nu8 *mem_addr;\r\ncbd_t __iomem *bdp;\r\npr_debug("CPM uart[%d]:initbd\n", pinfo->port.line);\r\nmem_addr = pinfo->mem_addr;\r\nbdp = pinfo->rx_cur = pinfo->rx_bd_base;\r\nfor (i = 0; i < (pinfo->rx_nrfifos - 1); i++, bdp++) {\r\nout_be32(&bdp->cbd_bufaddr, cpu2cpm_addr(mem_addr, pinfo));\r\nout_be16(&bdp->cbd_sc, BD_SC_EMPTY | BD_SC_INTRPT);\r\nmem_addr += pinfo->rx_fifosize;\r\n}\r\nout_be32(&bdp->cbd_bufaddr, cpu2cpm_addr(mem_addr, pinfo));\r\nout_be16(&bdp->cbd_sc, BD_SC_WRAP | BD_SC_EMPTY | BD_SC_INTRPT);\r\nmem_addr = pinfo->mem_addr + L1_CACHE_ALIGN(pinfo->rx_nrfifos * pinfo->rx_fifosize);\r\nbdp = pinfo->tx_cur = pinfo->tx_bd_base;\r\nfor (i = 0; i < (pinfo->tx_nrfifos - 1); i++, bdp++) {\r\nout_be32(&bdp->cbd_bufaddr, cpu2cpm_addr(mem_addr, pinfo));\r\nout_be16(&bdp->cbd_sc, BD_SC_INTRPT);\r\nmem_addr += pinfo->tx_fifosize;\r\n}\r\nout_be32(&bdp->cbd_bufaddr, cpu2cpm_addr(mem_addr, pinfo));\r\nout_be16(&bdp->cbd_sc, BD_SC_WRAP | BD_SC_INTRPT);\r\n}\r\nstatic void cpm_uart_init_scc(struct uart_cpm_port *pinfo)\r\n{\r\nscc_t __iomem *scp;\r\nscc_uart_t __iomem *sup;\r\npr_debug("CPM uart[%d]:init_scc\n", pinfo->port.line);\r\nscp = pinfo->sccp;\r\nsup = pinfo->sccup;\r\nout_be16(&pinfo->sccup->scc_genscc.scc_rbase,\r\n(u8 __iomem *)pinfo->rx_bd_base - DPRAM_BASE);\r\nout_be16(&pinfo->sccup->scc_genscc.scc_tbase,\r\n(u8 __iomem *)pinfo->tx_bd_base - DPRAM_BASE);\r\ncpm_set_scc_fcr(sup);\r\nout_be16(&sup->scc_genscc.scc_mrblr, pinfo->rx_fifosize);\r\nout_be16(&sup->scc_maxidl, pinfo->rx_fifosize);\r\nout_be16(&sup->scc_brkcr, 1);\r\nout_be16(&sup->scc_parec, 0);\r\nout_be16(&sup->scc_frmec, 0);\r\nout_be16(&sup->scc_nosec, 0);\r\nout_be16(&sup->scc_brkec, 0);\r\nout_be16(&sup->scc_uaddr1, 0);\r\nout_be16(&sup->scc_uaddr2, 0);\r\nout_be16(&sup->scc_toseq, 0);\r\nout_be16(&sup->scc_char1, 0x8000);\r\nout_be16(&sup->scc_char2, 0x8000);\r\nout_be16(&sup->scc_char3, 0x8000);\r\nout_be16(&sup->scc_char4, 0x8000);\r\nout_be16(&sup->scc_char5, 0x8000);\r\nout_be16(&sup->scc_char6, 0x8000);\r\nout_be16(&sup->scc_char7, 0x8000);\r\nout_be16(&sup->scc_char8, 0x8000);\r\nout_be16(&sup->scc_rccm, 0xc0ff);\r\ncpm_line_cr_cmd(pinfo, CPM_CR_INIT_TRX);\r\nout_be32(&scp->scc_gsmrh, 0);\r\nout_be32(&scp->scc_gsmrl,\r\nSCC_GSMRL_MODE_UART | SCC_GSMRL_TDCR_16 | SCC_GSMRL_RDCR_16);\r\nout_be16(&scp->scc_sccm, 0);\r\nout_be16(&scp->scc_scce, 0xffff);\r\nout_be16(&scp->scc_dsr, 0x7e7e);\r\nout_be16(&scp->scc_psmr, 0x3000);\r\nsetbits32(&scp->scc_gsmrl, SCC_GSMRL_ENR | SCC_GSMRL_ENT);\r\n}\r\nstatic void cpm_uart_init_smc(struct uart_cpm_port *pinfo)\r\n{\r\nsmc_t __iomem *sp;\r\nsmc_uart_t __iomem *up;\r\npr_debug("CPM uart[%d]:init_smc\n", pinfo->port.line);\r\nsp = pinfo->smcp;\r\nup = pinfo->smcup;\r\nout_be16(&pinfo->smcup->smc_rbase,\r\n(u8 __iomem *)pinfo->rx_bd_base - DPRAM_BASE);\r\nout_be16(&pinfo->smcup->smc_tbase,\r\n(u8 __iomem *)pinfo->tx_bd_base - DPRAM_BASE);\r\n#if defined (CONFIG_I2C_SPI_SMC1_UCODE_PATCH)\r\nout_be16(&up->smc_rbptr, in_be16(&pinfo->smcup->smc_rbase));\r\nout_be16(&up->smc_tbptr, in_be16(&pinfo->smcup->smc_tbase));\r\nout_be32(&up->smc_rstate, 0);\r\nout_be32(&up->smc_tstate, 0);\r\nout_be16(&up->smc_brkcr, 1);\r\nout_be16(&up->smc_brkec, 0);\r\n#endif\r\ncpm_set_smc_fcr(up);\r\nout_be16(&up->smc_mrblr, pinfo->rx_fifosize);\r\nout_be16(&up->smc_maxidl, pinfo->rx_fifosize);\r\nout_be16(&up->smc_brklen, 0);\r\nout_be16(&up->smc_brkec, 0);\r\nout_be16(&up->smc_brkcr, 1);\r\ncpm_line_cr_cmd(pinfo, CPM_CR_INIT_TRX);\r\nout_be16(&sp->smc_smcmr, smcr_mk_clen(9) | SMCMR_SM_UART);\r\nout_8(&sp->smc_smcm, 0);\r\nout_8(&sp->smc_smce, 0xff);\r\nsetbits16(&sp->smc_smcmr, SMCMR_REN | SMCMR_TEN);\r\n}\r\nstatic int cpm_uart_request_port(struct uart_port *port)\r\n{\r\nstruct uart_cpm_port *pinfo = (struct uart_cpm_port *)port;\r\nint ret;\r\npr_debug("CPM uart[%d]:request port\n", port->line);\r\nif (pinfo->flags & FLAG_CONSOLE)\r\nreturn 0;\r\nif (IS_SMC(pinfo)) {\r\nclrbits8(&pinfo->smcp->smc_smcm, SMCM_RX | SMCM_TX);\r\nclrbits16(&pinfo->smcp->smc_smcmr, SMCMR_REN | SMCMR_TEN);\r\n} else {\r\nclrbits16(&pinfo->sccp->scc_sccm, UART_SCCM_TX | UART_SCCM_RX);\r\nclrbits32(&pinfo->sccp->scc_gsmrl, SCC_GSMRL_ENR | SCC_GSMRL_ENT);\r\n}\r\nret = cpm_uart_allocbuf(pinfo, 0);\r\nif (ret)\r\nreturn ret;\r\ncpm_uart_initbd(pinfo);\r\nif (IS_SMC(pinfo))\r\ncpm_uart_init_smc(pinfo);\r\nelse\r\ncpm_uart_init_scc(pinfo);\r\nreturn 0;\r\n}\r\nstatic void cpm_uart_release_port(struct uart_port *port)\r\n{\r\nstruct uart_cpm_port *pinfo = (struct uart_cpm_port *)port;\r\nif (!(pinfo->flags & FLAG_CONSOLE))\r\ncpm_uart_freebuf(pinfo);\r\n}\r\nstatic void cpm_uart_config_port(struct uart_port *port, int flags)\r\n{\r\npr_debug("CPM uart[%d]:config_port\n", port->line);\r\nif (flags & UART_CONFIG_TYPE) {\r\nport->type = PORT_CPM;\r\ncpm_uart_request_port(port);\r\n}\r\n}\r\nstatic void cpm_uart_early_write(struct uart_cpm_port *pinfo,\r\nconst char *string, u_int count)\r\n{\r\nunsigned int i;\r\ncbd_t __iomem *bdp, *bdbase;\r\nunsigned char *cpm_outp_addr;\r\nbdp = pinfo->tx_cur;\r\nbdbase = pinfo->tx_bd_base;\r\nfor (i = 0; i < count; i++, string++) {\r\nwhile ((in_be16(&bdp->cbd_sc) & BD_SC_READY) != 0)\r\n;\r\ncpm_outp_addr = cpm2cpu_addr(in_be32(&bdp->cbd_bufaddr),\r\npinfo);\r\n*cpm_outp_addr = *string;\r\nout_be16(&bdp->cbd_datlen, 1);\r\nsetbits16(&bdp->cbd_sc, BD_SC_READY);\r\nif (in_be16(&bdp->cbd_sc) & BD_SC_WRAP)\r\nbdp = bdbase;\r\nelse\r\nbdp++;\r\nif (*string == 10) {\r\nwhile ((in_be16(&bdp->cbd_sc) & BD_SC_READY) != 0)\r\n;\r\ncpm_outp_addr = cpm2cpu_addr(in_be32(&bdp->cbd_bufaddr),\r\npinfo);\r\n*cpm_outp_addr = 13;\r\nout_be16(&bdp->cbd_datlen, 1);\r\nsetbits16(&bdp->cbd_sc, BD_SC_READY);\r\nif (in_be16(&bdp->cbd_sc) & BD_SC_WRAP)\r\nbdp = bdbase;\r\nelse\r\nbdp++;\r\n}\r\n}\r\nwhile ((in_be16(&bdp->cbd_sc) & BD_SC_READY) != 0)\r\n;\r\npinfo->tx_cur = bdp;\r\n}\r\nstatic int poll_wait_key(char *obuf, struct uart_cpm_port *pinfo)\r\n{\r\nu_char c, *cp;\r\nvolatile cbd_t *bdp;\r\nint i;\r\nbdp = pinfo->rx_cur;\r\nwhile (bdp->cbd_sc & BD_SC_EMPTY)\r\n;\r\ncp = cpm2cpu_addr(bdp->cbd_bufaddr, pinfo);\r\nif (obuf) {\r\ni = c = bdp->cbd_datlen;\r\nwhile (i-- > 0)\r\n*obuf++ = *cp++;\r\n} else\r\nc = *cp;\r\nbdp->cbd_sc &= ~(BD_SC_BR | BD_SC_FR | BD_SC_PR | BD_SC_OV | BD_SC_ID);\r\nbdp->cbd_sc |= BD_SC_EMPTY;\r\nif (bdp->cbd_sc & BD_SC_WRAP)\r\nbdp = pinfo->rx_bd_base;\r\nelse\r\nbdp++;\r\npinfo->rx_cur = (cbd_t *)bdp;\r\nreturn (int)c;\r\n}\r\nstatic int cpm_get_poll_char(struct uart_port *port)\r\n{\r\nstruct uart_cpm_port *pinfo = (struct uart_cpm_port *)port;\r\nif (!serial_polled) {\r\nserial_polled = 1;\r\npoll_chars = 0;\r\n}\r\nif (poll_chars <= 0) {\r\npoll_chars = poll_wait_key(poll_buf, pinfo);\r\npollp = poll_buf;\r\n}\r\npoll_chars--;\r\nreturn *pollp++;\r\n}\r\nstatic void cpm_put_poll_char(struct uart_port *port,\r\nunsigned char c)\r\n{\r\nstruct uart_cpm_port *pinfo = (struct uart_cpm_port *)port;\r\nstatic char ch[2];\r\nch[0] = (char)c;\r\ncpm_uart_early_write(pinfo, ch, 1);\r\n}\r\nstatic int cpm_uart_init_port(struct device_node *np,\r\nstruct uart_cpm_port *pinfo)\r\n{\r\nconst u32 *data;\r\nvoid __iomem *mem, *pram;\r\nint len;\r\nint ret;\r\nint i;\r\ndata = of_get_property(np, "clock", NULL);\r\nif (data) {\r\nstruct clk *clk = clk_get(NULL, (const char*)data);\r\nif (!IS_ERR(clk))\r\npinfo->clk = clk;\r\n}\r\nif (!pinfo->clk) {\r\ndata = of_get_property(np, "fsl,cpm-brg", &len);\r\nif (!data || len != 4) {\r\nprintk(KERN_ERR "CPM UART %s has no/invalid "\r\n"fsl,cpm-brg property.\n", np->name);\r\nreturn -EINVAL;\r\n}\r\npinfo->brg = *data;\r\n}\r\ndata = of_get_property(np, "fsl,cpm-command", &len);\r\nif (!data || len != 4) {\r\nprintk(KERN_ERR "CPM UART %s has no/invalid "\r\n"fsl,cpm-command property.\n", np->name);\r\nreturn -EINVAL;\r\n}\r\npinfo->command = *data;\r\nmem = of_iomap(np, 0);\r\nif (!mem)\r\nreturn -ENOMEM;\r\nif (of_device_is_compatible(np, "fsl,cpm1-scc-uart") ||\r\nof_device_is_compatible(np, "fsl,cpm2-scc-uart")) {\r\npinfo->sccp = mem;\r\npinfo->sccup = pram = cpm_uart_map_pram(pinfo, np);\r\n} else if (of_device_is_compatible(np, "fsl,cpm1-smc-uart") ||\r\nof_device_is_compatible(np, "fsl,cpm2-smc-uart")) {\r\npinfo->flags |= FLAG_SMC;\r\npinfo->smcp = mem;\r\npinfo->smcup = pram = cpm_uart_map_pram(pinfo, np);\r\n} else {\r\nret = -ENODEV;\r\ngoto out_mem;\r\n}\r\nif (!pram) {\r\nret = -ENOMEM;\r\ngoto out_mem;\r\n}\r\npinfo->tx_nrfifos = TX_NUM_FIFO;\r\npinfo->tx_fifosize = TX_BUF_SIZE;\r\npinfo->rx_nrfifos = RX_NUM_FIFO;\r\npinfo->rx_fifosize = RX_BUF_SIZE;\r\npinfo->port.uartclk = ppc_proc_freq;\r\npinfo->port.mapbase = (unsigned long)mem;\r\npinfo->port.type = PORT_CPM;\r\npinfo->port.ops = &cpm_uart_pops,\r\npinfo->port.iotype = UPIO_MEM;\r\npinfo->port.fifosize = pinfo->tx_nrfifos * pinfo->tx_fifosize;\r\nspin_lock_init(&pinfo->port.lock);\r\npinfo->port.irq = of_irq_to_resource(np, 0, NULL);\r\nif (pinfo->port.irq == NO_IRQ) {\r\nret = -EINVAL;\r\ngoto out_pram;\r\n}\r\nfor (i = 0; i < NUM_GPIOS; i++)\r\npinfo->gpios[i] = of_get_gpio(np, i);\r\n#ifdef CONFIG_PPC_EARLY_DEBUG_CPM\r\nudbg_putc = NULL;\r\n#endif\r\nreturn cpm_uart_request_port(&pinfo->port);\r\nout_pram:\r\ncpm_uart_unmap_pram(pinfo, pram);\r\nout_mem:\r\niounmap(mem);\r\nreturn ret;\r\n}\r\nstatic void cpm_uart_console_write(struct console *co, const char *s,\r\nu_int count)\r\n{\r\nstruct uart_cpm_port *pinfo = &cpm_uart_ports[co->index];\r\nunsigned long flags;\r\nint nolock = oops_in_progress;\r\nif (unlikely(nolock)) {\r\nlocal_irq_save(flags);\r\n} else {\r\nspin_lock_irqsave(&pinfo->port.lock, flags);\r\n}\r\ncpm_uart_early_write(pinfo, s, count);\r\nif (unlikely(nolock)) {\r\nlocal_irq_restore(flags);\r\n} else {\r\nspin_unlock_irqrestore(&pinfo->port.lock, flags);\r\n}\r\n}\r\nstatic int __init cpm_uart_console_setup(struct console *co, char *options)\r\n{\r\nint baud = 38400;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nint ret;\r\nstruct uart_cpm_port *pinfo;\r\nstruct uart_port *port;\r\nstruct device_node *np = NULL;\r\nint i = 0;\r\nif (co->index >= UART_NR) {\r\nprintk(KERN_ERR "cpm_uart: console index %d too high\n",\r\nco->index);\r\nreturn -ENODEV;\r\n}\r\ndo {\r\nnp = of_find_node_by_type(np, "serial");\r\nif (!np)\r\nreturn -ENODEV;\r\nif (!of_device_is_compatible(np, "fsl,cpm1-smc-uart") &&\r\n!of_device_is_compatible(np, "fsl,cpm1-scc-uart") &&\r\n!of_device_is_compatible(np, "fsl,cpm2-smc-uart") &&\r\n!of_device_is_compatible(np, "fsl,cpm2-scc-uart"))\r\ni--;\r\n} while (i++ != co->index);\r\npinfo = &cpm_uart_ports[co->index];\r\npinfo->flags |= FLAG_CONSOLE;\r\nport = &pinfo->port;\r\nret = cpm_uart_init_port(np, pinfo);\r\nof_node_put(np);\r\nif (ret)\r\nreturn ret;\r\nif (options) {\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\n} else {\r\nif ((baud = uart_baudrate()) == -1)\r\nbaud = 9600;\r\n}\r\nif (IS_SMC(pinfo)) {\r\nout_be16(&pinfo->smcup->smc_brkcr, 0);\r\ncpm_line_cr_cmd(pinfo, CPM_CR_STOP_TX);\r\nclrbits8(&pinfo->smcp->smc_smcm, SMCM_RX | SMCM_TX);\r\nclrbits16(&pinfo->smcp->smc_smcmr, SMCMR_REN | SMCMR_TEN);\r\n} else {\r\nout_be16(&pinfo->sccup->scc_brkcr, 0);\r\ncpm_line_cr_cmd(pinfo, CPM_CR_GRA_STOP_TX);\r\nclrbits16(&pinfo->sccp->scc_sccm, UART_SCCM_TX | UART_SCCM_RX);\r\nclrbits32(&pinfo->sccp->scc_gsmrl, SCC_GSMRL_ENR | SCC_GSMRL_ENT);\r\n}\r\nret = cpm_uart_allocbuf(pinfo, 1);\r\nif (ret)\r\nreturn ret;\r\ncpm_uart_initbd(pinfo);\r\nif (IS_SMC(pinfo))\r\ncpm_uart_init_smc(pinfo);\r\nelse\r\ncpm_uart_init_scc(pinfo);\r\nuart_set_options(port, co, baud, parity, bits, flow);\r\ncpm_line_cr_cmd(pinfo, CPM_CR_RESTART_TX);\r\nreturn 0;\r\n}\r\nstatic int __init cpm_uart_console_init(void)\r\n{\r\nregister_console(&cpm_scc_uart_console);\r\nreturn 0;\r\n}\r\nstatic int __devinit cpm_uart_probe(struct platform_device *ofdev)\r\n{\r\nint index = probe_index++;\r\nstruct uart_cpm_port *pinfo = &cpm_uart_ports[index];\r\nint ret;\r\npinfo->port.line = index;\r\nif (index >= UART_NR)\r\nreturn -ENODEV;\r\ndev_set_drvdata(&ofdev->dev, pinfo);\r\npinfo->port.dev = &ofdev->dev;\r\nret = cpm_uart_init_port(ofdev->dev.of_node, pinfo);\r\nif (ret)\r\nreturn ret;\r\nreturn uart_add_one_port(&cpm_reg, &pinfo->port);\r\n}\r\nstatic int __devexit cpm_uart_remove(struct platform_device *ofdev)\r\n{\r\nstruct uart_cpm_port *pinfo = dev_get_drvdata(&ofdev->dev);\r\nreturn uart_remove_one_port(&cpm_reg, &pinfo->port);\r\n}\r\nstatic int __init cpm_uart_init(void)\r\n{\r\nint ret = uart_register_driver(&cpm_reg);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&cpm_uart_driver);\r\nif (ret)\r\nuart_unregister_driver(&cpm_reg);\r\nreturn ret;\r\n}\r\nstatic void __exit cpm_uart_exit(void)\r\n{\r\nplatform_driver_unregister(&cpm_uart_driver);\r\nuart_unregister_driver(&cpm_reg);\r\n}
