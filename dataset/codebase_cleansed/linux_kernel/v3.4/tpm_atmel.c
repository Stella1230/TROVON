static int tpm_atml_recv(struct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\nu8 status, *hdr = buf;\r\nu32 size;\r\nint i;\r\n__be32 *native_size;\r\nif (count < 6)\r\nreturn -EIO;\r\nfor (i = 0; i < 6; i++) {\r\nstatus = ioread8(chip->vendor.iobase + 1);\r\nif ((status & ATML_STATUS_DATA_AVAIL) == 0) {\r\ndev_err(chip->dev, "error reading header\n");\r\nreturn -EIO;\r\n}\r\n*buf++ = ioread8(chip->vendor.iobase);\r\n}\r\nnative_size = (__force __be32 *) (hdr + 2);\r\nsize = be32_to_cpu(*native_size);\r\nif (count < size) {\r\ndev_err(chip->dev,\r\n"Recv size(%d) less than available space\n", size);\r\nfor (; i < size; i++) {\r\nstatus = ioread8(chip->vendor.iobase + 1);\r\nif ((status & ATML_STATUS_DATA_AVAIL) == 0) {\r\ndev_err(chip->dev, "error reading data\n");\r\nreturn -EIO;\r\n}\r\n}\r\nreturn -EIO;\r\n}\r\nfor (; i < size; i++) {\r\nstatus = ioread8(chip->vendor.iobase + 1);\r\nif ((status & ATML_STATUS_DATA_AVAIL) == 0) {\r\ndev_err(chip->dev, "error reading data\n");\r\nreturn -EIO;\r\n}\r\n*buf++ = ioread8(chip->vendor.iobase);\r\n}\r\nstatus = ioread8(chip->vendor.iobase + 1);\r\nif (status & ATML_STATUS_DATA_AVAIL) {\r\ndev_err(chip->dev, "data available is stuck\n");\r\nreturn -EIO;\r\n}\r\nreturn size;\r\n}\r\nstatic int tpm_atml_send(struct tpm_chip *chip, u8 *buf, size_t count)\r\n{\r\nint i;\r\ndev_dbg(chip->dev, "tpm_atml_send:\n");\r\nfor (i = 0; i < count; i++) {\r\ndev_dbg(chip->dev, "%d 0x%x(%d)\n", i, buf[i], buf[i]);\r\niowrite8(buf[i], chip->vendor.iobase);\r\n}\r\nreturn count;\r\n}\r\nstatic void tpm_atml_cancel(struct tpm_chip *chip)\r\n{\r\niowrite8(ATML_STATUS_ABORT, chip->vendor.iobase + 1);\r\n}\r\nstatic u8 tpm_atml_status(struct tpm_chip *chip)\r\n{\r\nreturn ioread8(chip->vendor.iobase + 1);\r\n}\r\nstatic void atml_plat_remove(void)\r\n{\r\nstruct tpm_chip *chip = dev_get_drvdata(&pdev->dev);\r\nif (chip) {\r\nif (chip->vendor.have_region)\r\natmel_release_region(chip->vendor.base,\r\nchip->vendor.region_size);\r\natmel_put_base_addr(chip->vendor.iobase);\r\ntpm_remove_hardware(chip->dev);\r\nplatform_device_unregister(pdev);\r\n}\r\n}\r\nstatic int tpm_atml_suspend(struct platform_device *dev, pm_message_t msg)\r\n{\r\nreturn tpm_pm_suspend(&dev->dev, msg);\r\n}\r\nstatic int tpm_atml_resume(struct platform_device *dev)\r\n{\r\nreturn tpm_pm_resume(&dev->dev);\r\n}\r\nstatic int __init init_atmel(void)\r\n{\r\nint rc = 0;\r\nvoid __iomem *iobase = NULL;\r\nint have_region, region_size;\r\nunsigned long base;\r\nstruct tpm_chip *chip;\r\nrc = platform_driver_register(&atml_drv);\r\nif (rc)\r\nreturn rc;\r\nif ((iobase = atmel_get_base_addr(&base, &region_size)) == NULL) {\r\nrc = -ENODEV;\r\ngoto err_unreg_drv;\r\n}\r\nhave_region =\r\n(atmel_request_region\r\n(tpm_atmel.base, region_size, "tpm_atmel0") == NULL) ? 0 : 1;\r\npdev = platform_device_register_simple("tpm_atmel", -1, NULL, 0);\r\nif (IS_ERR(pdev)) {\r\nrc = PTR_ERR(pdev);\r\ngoto err_rel_reg;\r\n}\r\nif (!(chip = tpm_register_hardware(&pdev->dev, &tpm_atmel))) {\r\nrc = -ENODEV;\r\ngoto err_unreg_dev;\r\n}\r\nchip->vendor.iobase = iobase;\r\nchip->vendor.base = base;\r\nchip->vendor.have_region = have_region;\r\nchip->vendor.region_size = region_size;\r\nreturn 0;\r\nerr_unreg_dev:\r\nplatform_device_unregister(pdev);\r\nerr_rel_reg:\r\natmel_put_base_addr(iobase);\r\nif (have_region)\r\natmel_release_region(base,\r\nregion_size);\r\nerr_unreg_drv:\r\nplatform_driver_unregister(&atml_drv);\r\nreturn rc;\r\n}\r\nstatic void __exit cleanup_atmel(void)\r\n{\r\nplatform_driver_unregister(&atml_drv);\r\natml_plat_remove();\r\n}
