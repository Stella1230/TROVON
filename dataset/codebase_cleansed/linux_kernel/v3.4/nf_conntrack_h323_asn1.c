static unsigned int get_len(bitstr_t *bs)\r\n{\r\nunsigned int v;\r\nv = *bs->cur++;\r\nif (v & 0x80) {\r\nv &= 0x3f;\r\nv <<= 8;\r\nv += *bs->cur++;\r\n}\r\nreturn v;\r\n}\r\nstatic unsigned int get_bit(bitstr_t *bs)\r\n{\r\nunsigned int b = (*bs->cur) & (0x80 >> bs->bit);\r\nINC_BIT(bs);\r\nreturn b;\r\n}\r\nstatic unsigned int get_bits(bitstr_t *bs, unsigned int b)\r\n{\r\nunsigned int v, l;\r\nv = (*bs->cur) & (0xffU >> bs->bit);\r\nl = b + bs->bit;\r\nif (l < 8) {\r\nv >>= 8 - l;\r\nbs->bit = l;\r\n} else if (l == 8) {\r\nbs->cur++;\r\nbs->bit = 0;\r\n} else {\r\nv <<= 8;\r\nv += *(++bs->cur);\r\nv >>= 16 - l;\r\nbs->bit = l - 8;\r\n}\r\nreturn v;\r\n}\r\nstatic unsigned int get_bitmap(bitstr_t *bs, unsigned int b)\r\n{\r\nunsigned int v, l, shift, bytes;\r\nif (!b)\r\nreturn 0;\r\nl = bs->bit + b;\r\nif (l < 8) {\r\nv = (unsigned int)(*bs->cur) << (bs->bit + 24);\r\nbs->bit = l;\r\n} else if (l == 8) {\r\nv = (unsigned int)(*bs->cur++) << (bs->bit + 24);\r\nbs->bit = 0;\r\n} else {\r\nfor (bytes = l >> 3, shift = 24, v = 0; bytes;\r\nbytes--, shift -= 8)\r\nv |= (unsigned int)(*bs->cur++) << shift;\r\nif (l < 32) {\r\nv |= (unsigned int)(*bs->cur) << shift;\r\nv <<= bs->bit;\r\n} else if (l > 32) {\r\nv <<= bs->bit;\r\nv |= (*bs->cur) >> (8 - bs->bit);\r\n}\r\nbs->bit = l & 0x7;\r\n}\r\nv &= 0xffffffff << (32 - b);\r\nreturn v;\r\n}\r\nstatic unsigned int get_uint(bitstr_t *bs, int b)\r\n{\r\nunsigned int v = 0;\r\nswitch (b) {\r\ncase 4:\r\nv |= *bs->cur++;\r\nv <<= 8;\r\ncase 3:\r\nv |= *bs->cur++;\r\nv <<= 8;\r\ncase 2:\r\nv |= *bs->cur++;\r\nv <<= 8;\r\ncase 1:\r\nv |= *bs->cur++;\r\nbreak;\r\n}\r\nreturn v;\r\n}\r\nstatic int decode_nul(bitstr_t *bs, const struct field_t *f,\r\nchar *base, int level)\r\n{\r\nPRINT("%*.s%s\n", level * TAB_SIZE, " ", f->name);\r\nreturn H323_ERROR_NONE;\r\n}\r\nstatic int decode_bool(bitstr_t *bs, const struct field_t *f,\r\nchar *base, int level)\r\n{\r\nPRINT("%*.s%s\n", level * TAB_SIZE, " ", f->name);\r\nINC_BIT(bs);\r\nCHECK_BOUND(bs, 0);\r\nreturn H323_ERROR_NONE;\r\n}\r\nstatic int decode_oid(bitstr_t *bs, const struct field_t *f,\r\nchar *base, int level)\r\n{\r\nint len;\r\nPRINT("%*.s%s\n", level * TAB_SIZE, " ", f->name);\r\nBYTE_ALIGN(bs);\r\nCHECK_BOUND(bs, 1);\r\nlen = *bs->cur++;\r\nbs->cur += len;\r\nCHECK_BOUND(bs, 0);\r\nreturn H323_ERROR_NONE;\r\n}\r\nstatic int decode_int(bitstr_t *bs, const struct field_t *f,\r\nchar *base, int level)\r\n{\r\nunsigned int len;\r\nPRINT("%*.s%s", level * TAB_SIZE, " ", f->name);\r\nswitch (f->sz) {\r\ncase BYTE:\r\nBYTE_ALIGN(bs);\r\nbs->cur++;\r\nbreak;\r\ncase WORD:\r\nBYTE_ALIGN(bs);\r\nbs->cur += 2;\r\nbreak;\r\ncase CONS:\r\nlen = get_bits(bs, 2) + 1;\r\nBYTE_ALIGN(bs);\r\nif (base && (f->attr & DECODE)) {\r\nunsigned int v = get_uint(bs, len) + f->lb;\r\nPRINT(" = %u", v);\r\n*((unsigned int *)(base + f->offset)) = v;\r\n}\r\nbs->cur += len;\r\nbreak;\r\ncase UNCO:\r\nBYTE_ALIGN(bs);\r\nCHECK_BOUND(bs, 2);\r\nlen = get_len(bs);\r\nbs->cur += len;\r\nbreak;\r\ndefault:\r\nINC_BITS(bs, f->sz);\r\nbreak;\r\n}\r\nPRINT("\n");\r\nCHECK_BOUND(bs, 0);\r\nreturn H323_ERROR_NONE;\r\n}\r\nstatic int decode_enum(bitstr_t *bs, const struct field_t *f,\r\nchar *base, int level)\r\n{\r\nPRINT("%*.s%s\n", level * TAB_SIZE, " ", f->name);\r\nif ((f->attr & EXT) && get_bit(bs)) {\r\nINC_BITS(bs, 7);\r\n} else {\r\nINC_BITS(bs, f->sz);\r\n}\r\nCHECK_BOUND(bs, 0);\r\nreturn H323_ERROR_NONE;\r\n}\r\nstatic int decode_bitstr(bitstr_t *bs, const struct field_t *f,\r\nchar *base, int level)\r\n{\r\nunsigned int len;\r\nPRINT("%*.s%s\n", level * TAB_SIZE, " ", f->name);\r\nBYTE_ALIGN(bs);\r\nswitch (f->sz) {\r\ncase FIXD:\r\nlen = f->lb;\r\nbreak;\r\ncase WORD:\r\nCHECK_BOUND(bs, 2);\r\nlen = (*bs->cur++) << 8;\r\nlen += (*bs->cur++) + f->lb;\r\nbreak;\r\ncase SEMI:\r\nCHECK_BOUND(bs, 2);\r\nlen = get_len(bs);\r\nbreak;\r\ndefault:\r\nlen = 0;\r\nbreak;\r\n}\r\nbs->cur += len >> 3;\r\nbs->bit = len & 7;\r\nCHECK_BOUND(bs, 0);\r\nreturn H323_ERROR_NONE;\r\n}\r\nstatic int decode_numstr(bitstr_t *bs, const struct field_t *f,\r\nchar *base, int level)\r\n{\r\nunsigned int len;\r\nPRINT("%*.s%s\n", level * TAB_SIZE, " ", f->name);\r\nlen = get_bits(bs, f->sz) + f->lb;\r\nBYTE_ALIGN(bs);\r\nINC_BITS(bs, (len << 2));\r\nCHECK_BOUND(bs, 0);\r\nreturn H323_ERROR_NONE;\r\n}\r\nstatic int decode_octstr(bitstr_t *bs, const struct field_t *f,\r\nchar *base, int level)\r\n{\r\nunsigned int len;\r\nPRINT("%*.s%s", level * TAB_SIZE, " ", f->name);\r\nswitch (f->sz) {\r\ncase FIXD:\r\nif (f->lb > 2) {\r\nBYTE_ALIGN(bs);\r\nif (base && (f->attr & DECODE)) {\r\nIFTHEN(f->lb == 4,\r\nPRINT(" = %d.%d.%d.%d:%d",\r\nbs->cur[0], bs->cur[1],\r\nbs->cur[2], bs->cur[3],\r\nbs->cur[4] * 256 + bs->cur[5]));\r\n*((unsigned int *)(base + f->offset)) =\r\nbs->cur - bs->buf;\r\n}\r\n}\r\nlen = f->lb;\r\nbreak;\r\ncase BYTE:\r\nBYTE_ALIGN(bs);\r\nCHECK_BOUND(bs, 1);\r\nlen = (*bs->cur++) + f->lb;\r\nbreak;\r\ncase SEMI:\r\nBYTE_ALIGN(bs);\r\nCHECK_BOUND(bs, 2);\r\nlen = get_len(bs) + f->lb;\r\nbreak;\r\ndefault:\r\nlen = get_bits(bs, f->sz) + f->lb;\r\nBYTE_ALIGN(bs);\r\nbreak;\r\n}\r\nbs->cur += len;\r\nPRINT("\n");\r\nCHECK_BOUND(bs, 0);\r\nreturn H323_ERROR_NONE;\r\n}\r\nstatic int decode_bmpstr(bitstr_t *bs, const struct field_t *f,\r\nchar *base, int level)\r\n{\r\nunsigned int len;\r\nPRINT("%*.s%s\n", level * TAB_SIZE, " ", f->name);\r\nswitch (f->sz) {\r\ncase BYTE:\r\nBYTE_ALIGN(bs);\r\nCHECK_BOUND(bs, 1);\r\nlen = (*bs->cur++) + f->lb;\r\nbreak;\r\ndefault:\r\nlen = get_bits(bs, f->sz) + f->lb;\r\nBYTE_ALIGN(bs);\r\nbreak;\r\n}\r\nbs->cur += len << 1;\r\nCHECK_BOUND(bs, 0);\r\nreturn H323_ERROR_NONE;\r\n}\r\nstatic int decode_seq(bitstr_t *bs, const struct field_t *f,\r\nchar *base, int level)\r\n{\r\nunsigned int ext, bmp, i, opt, len = 0, bmp2, bmp2_len;\r\nint err;\r\nconst struct field_t *son;\r\nunsigned char *beg = NULL;\r\nPRINT("%*.s%s\n", level * TAB_SIZE, " ", f->name);\r\nbase = (base && (f->attr & DECODE)) ? base + f->offset : NULL;\r\next = (f->attr & EXT) ? get_bit(bs) : 0;\r\nbmp = get_bitmap(bs, f->sz);\r\nif (base)\r\n*(unsigned int *)base = bmp;\r\nfor (i = opt = 0, son = f->fields; i < f->lb; i++, son++) {\r\nif (son->attr & STOP) {\r\nPRINT("%*.s%s\n", (level + 1) * TAB_SIZE, " ",\r\nson->name);\r\nreturn H323_ERROR_STOP;\r\n}\r\nif (son->attr & OPT) {\r\nif (!((0x80000000U >> (opt++)) & bmp))\r\ncontinue;\r\n}\r\nif (son->attr & OPEN) {\r\nCHECK_BOUND(bs, 2);\r\nlen = get_len(bs);\r\nCHECK_BOUND(bs, len);\r\nif (!base || !(son->attr & DECODE)) {\r\nPRINT("%*.s%s\n", (level + 1) * TAB_SIZE,\r\n" ", son->name);\r\nbs->cur += len;\r\ncontinue;\r\n}\r\nbeg = bs->cur;\r\nif ((err = (Decoders[son->type]) (bs, son, base,\r\nlevel + 1)) <\r\nH323_ERROR_NONE)\r\nreturn err;\r\nbs->cur = beg + len;\r\nbs->bit = 0;\r\n} else if ((err = (Decoders[son->type]) (bs, son, base,\r\nlevel + 1)) <\r\nH323_ERROR_NONE)\r\nreturn err;\r\n}\r\nif (!ext)\r\nreturn H323_ERROR_NONE;\r\nbmp2_len = get_bits(bs, 7) + 1;\r\nCHECK_BOUND(bs, (bmp2_len + 7) >> 3);\r\nbmp2 = get_bitmap(bs, bmp2_len);\r\nbmp |= bmp2 >> f->sz;\r\nif (base)\r\n*(unsigned int *)base = bmp;\r\nBYTE_ALIGN(bs);\r\nfor (opt = 0; opt < bmp2_len; opt++, i++, son++) {\r\nif (i >= f->ub) {\r\nCHECK_BOUND(bs, 2);\r\nlen = get_len(bs);\r\nCHECK_BOUND(bs, len);\r\nbs->cur += len;\r\ncontinue;\r\n}\r\nif (son->attr & STOP) {\r\nPRINT("%*.s%s\n", (level + 1) * TAB_SIZE, " ",\r\nson->name);\r\nreturn H323_ERROR_STOP;\r\n}\r\nif (!((0x80000000 >> opt) & bmp2))\r\ncontinue;\r\nCHECK_BOUND(bs, 2);\r\nlen = get_len(bs);\r\nCHECK_BOUND(bs, len);\r\nif (!base || !(son->attr & DECODE)) {\r\nPRINT("%*.s%s\n", (level + 1) * TAB_SIZE, " ",\r\nson->name);\r\nbs->cur += len;\r\ncontinue;\r\n}\r\nbeg = bs->cur;\r\nif ((err = (Decoders[son->type]) (bs, son, base,\r\nlevel + 1)) <\r\nH323_ERROR_NONE)\r\nreturn err;\r\nbs->cur = beg + len;\r\nbs->bit = 0;\r\n}\r\nreturn H323_ERROR_NONE;\r\n}\r\nstatic int decode_seqof(bitstr_t *bs, const struct field_t *f,\r\nchar *base, int level)\r\n{\r\nunsigned int count, effective_count = 0, i, len = 0;\r\nint err;\r\nconst struct field_t *son;\r\nunsigned char *beg = NULL;\r\nPRINT("%*.s%s\n", level * TAB_SIZE, " ", f->name);\r\nbase = (base && (f->attr & DECODE)) ? base + f->offset : NULL;\r\nswitch (f->sz) {\r\ncase BYTE:\r\nBYTE_ALIGN(bs);\r\nCHECK_BOUND(bs, 1);\r\ncount = *bs->cur++;\r\nbreak;\r\ncase WORD:\r\nBYTE_ALIGN(bs);\r\nCHECK_BOUND(bs, 2);\r\ncount = *bs->cur++;\r\ncount <<= 8;\r\ncount += *bs->cur++;\r\nbreak;\r\ncase SEMI:\r\nBYTE_ALIGN(bs);\r\nCHECK_BOUND(bs, 2);\r\ncount = get_len(bs);\r\nbreak;\r\ndefault:\r\ncount = get_bits(bs, f->sz);\r\nbreak;\r\n}\r\ncount += f->lb;\r\nif (base) {\r\neffective_count = count > f->ub ? f->ub : count;\r\n*(unsigned int *)base = effective_count;\r\nbase += sizeof(unsigned int);\r\n}\r\nson = f->fields;\r\nif (base)\r\nbase -= son->offset;\r\nfor (i = 0; i < count; i++) {\r\nif (son->attr & OPEN) {\r\nBYTE_ALIGN(bs);\r\nlen = get_len(bs);\r\nCHECK_BOUND(bs, len);\r\nif (!base || !(son->attr & DECODE)) {\r\nPRINT("%*.s%s\n", (level + 1) * TAB_SIZE,\r\n" ", son->name);\r\nbs->cur += len;\r\ncontinue;\r\n}\r\nbeg = bs->cur;\r\nif ((err = (Decoders[son->type]) (bs, son,\r\ni <\r\neffective_count ?\r\nbase : NULL,\r\nlevel + 1)) <\r\nH323_ERROR_NONE)\r\nreturn err;\r\nbs->cur = beg + len;\r\nbs->bit = 0;\r\n} else\r\nif ((err = (Decoders[son->type]) (bs, son,\r\ni <\r\neffective_count ?\r\nbase : NULL,\r\nlevel + 1)) <\r\nH323_ERROR_NONE)\r\nreturn err;\r\nif (base)\r\nbase += son->offset;\r\n}\r\nreturn H323_ERROR_NONE;\r\n}\r\nstatic int decode_choice(bitstr_t *bs, const struct field_t *f,\r\nchar *base, int level)\r\n{\r\nunsigned int type, ext, len = 0;\r\nint err;\r\nconst struct field_t *son;\r\nunsigned char *beg = NULL;\r\nPRINT("%*.s%s\n", level * TAB_SIZE, " ", f->name);\r\nbase = (base && (f->attr & DECODE)) ? base + f->offset : NULL;\r\nif ((f->attr & EXT) && get_bit(bs)) {\r\next = 1;\r\ntype = get_bits(bs, 7) + f->lb;\r\n} else {\r\next = 0;\r\ntype = get_bits(bs, f->sz);\r\nif (type >= f->lb)\r\nreturn H323_ERROR_RANGE;\r\n}\r\nif (base)\r\n*(unsigned int *)base = type;\r\nif (type >= f->ub) {\r\nBYTE_ALIGN(bs);\r\nlen = get_len(bs);\r\nCHECK_BOUND(bs, len);\r\nbs->cur += len;\r\nreturn H323_ERROR_NONE;\r\n}\r\nson = &f->fields[type];\r\nif (son->attr & STOP) {\r\nPRINT("%*.s%s\n", (level + 1) * TAB_SIZE, " ", son->name);\r\nreturn H323_ERROR_STOP;\r\n}\r\nif (ext || (son->attr & OPEN)) {\r\nBYTE_ALIGN(bs);\r\nlen = get_len(bs);\r\nCHECK_BOUND(bs, len);\r\nif (!base || !(son->attr & DECODE)) {\r\nPRINT("%*.s%s\n", (level + 1) * TAB_SIZE, " ",\r\nson->name);\r\nbs->cur += len;\r\nreturn H323_ERROR_NONE;\r\n}\r\nbeg = bs->cur;\r\nif ((err = (Decoders[son->type]) (bs, son, base, level + 1)) <\r\nH323_ERROR_NONE)\r\nreturn err;\r\nbs->cur = beg + len;\r\nbs->bit = 0;\r\n} else if ((err = (Decoders[son->type]) (bs, son, base, level + 1)) <\r\nH323_ERROR_NONE)\r\nreturn err;\r\nreturn H323_ERROR_NONE;\r\n}\r\nint DecodeRasMessage(unsigned char *buf, size_t sz, RasMessage *ras)\r\n{\r\nstatic const struct field_t ras_message = {\r\nFNAME("RasMessage") CHOICE, 5, 24, 32, DECODE | EXT,\r\n0, _RasMessage\r\n};\r\nbitstr_t bs;\r\nbs.buf = bs.beg = bs.cur = buf;\r\nbs.end = buf + sz;\r\nbs.bit = 0;\r\nreturn decode_choice(&bs, &ras_message, (char *) ras, 0);\r\n}\r\nstatic int DecodeH323_UserInformation(unsigned char *buf, unsigned char *beg,\r\nsize_t sz, H323_UserInformation *uuie)\r\n{\r\nstatic const struct field_t h323_userinformation = {\r\nFNAME("H323-UserInformation") SEQ, 1, 2, 2, DECODE | EXT,\r\n0, _H323_UserInformation\r\n};\r\nbitstr_t bs;\r\nbs.buf = buf;\r\nbs.beg = bs.cur = beg;\r\nbs.end = beg + sz;\r\nbs.bit = 0;\r\nreturn decode_seq(&bs, &h323_userinformation, (char *) uuie, 0);\r\n}\r\nint DecodeMultimediaSystemControlMessage(unsigned char *buf, size_t sz,\r\nMultimediaSystemControlMessage *\r\nmscm)\r\n{\r\nstatic const struct field_t multimediasystemcontrolmessage = {\r\nFNAME("MultimediaSystemControlMessage") CHOICE, 2, 4, 4,\r\nDECODE | EXT, 0, _MultimediaSystemControlMessage\r\n};\r\nbitstr_t bs;\r\nbs.buf = bs.beg = bs.cur = buf;\r\nbs.end = buf + sz;\r\nbs.bit = 0;\r\nreturn decode_choice(&bs, &multimediasystemcontrolmessage,\r\n(char *) mscm, 0);\r\n}\r\nint DecodeQ931(unsigned char *buf, size_t sz, Q931 *q931)\r\n{\r\nunsigned char *p = buf;\r\nint len;\r\nif (!p || sz < 1)\r\nreturn H323_ERROR_BOUND;\r\nif (*p != 0x08) {\r\nPRINT("Unknown Protocol Discriminator\n");\r\nreturn H323_ERROR_RANGE;\r\n}\r\np++;\r\nsz--;\r\nif (sz < 1)\r\nreturn H323_ERROR_BOUND;\r\nlen = *p++;\r\nsz--;\r\nif (sz < len)\r\nreturn H323_ERROR_BOUND;\r\np += len;\r\nsz -= len;\r\nif (sz < 1)\r\nreturn H323_ERROR_BOUND;\r\nq931->MessageType = *p++;\r\nPRINT("MessageType = %02X\n", q931->MessageType);\r\nif (*p & 0x80) {\r\np++;\r\nsz--;\r\n}\r\nwhile (sz > 0) {\r\nif (*p == 0x7e) {\r\nif (sz < 3)\r\nbreak;\r\np++;\r\nlen = *p++ << 8;\r\nlen |= *p++;\r\nsz -= 3;\r\nif (sz < len)\r\nbreak;\r\np++;\r\nlen--;\r\nreturn DecodeH323_UserInformation(buf, p, len,\r\n&q931->UUIE);\r\n}\r\np++;\r\nsz--;\r\nif (sz < 1)\r\nbreak;\r\nlen = *p++;\r\nif (sz < len)\r\nbreak;\r\np += len;\r\nsz -= len;\r\n}\r\nPRINT("Q.931 UUIE not found\n");\r\nreturn H323_ERROR_BOUND;\r\n}
