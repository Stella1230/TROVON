static inline bool trace_isrunning(struct tracectx *t)\r\n{\r\nreturn !!(t->flags & TRACER_RUNNING);\r\n}\r\nstatic int etm_setup_address_range(struct tracectx *t, int n,\r\nunsigned long start, unsigned long end, int exclude, int data)\r\n{\r\nu32 flags = ETMAAT_ARM | ETMAAT_IGNCONTEXTID | ETMAAT_NSONLY | \\r\nETMAAT_NOVALCMP;\r\nif (n < 1 || n > t->ncmppairs)\r\nreturn -EINVAL;\r\nn--;\r\nif (data)\r\nflags |= ETMAAT_DLOADSTORE;\r\nelse\r\nflags |= ETMAAT_IEXEC;\r\netm_writel(t, flags, ETMR_COMP_ACC_TYPE(n * 2));\r\netm_writel(t, start, ETMR_COMP_VAL(n * 2));\r\netm_writel(t, flags, ETMR_COMP_ACC_TYPE(n * 2 + 1));\r\netm_writel(t, end, ETMR_COMP_VAL(n * 2 + 1));\r\nflags = exclude ? ETMTE_INCLEXCL : 0;\r\netm_writel(t, flags | (1 << n), ETMR_TRACEENCTRL);\r\nreturn 0;\r\n}\r\nstatic int trace_start(struct tracectx *t)\r\n{\r\nu32 v;\r\nunsigned long timeout = TRACER_TIMEOUT;\r\netb_unlock(t);\r\netb_writel(t, 0, ETBR_FORMATTERCTRL);\r\netb_writel(t, 1, ETBR_CTRL);\r\netb_lock(t);\r\nv = ETMCTRL_OPTS | ETMCTRL_PROGRAM | ETMCTRL_PORTSIZE(t->etm_portsz);\r\nif (t->flags & TRACER_CYCLE_ACC)\r\nv |= ETMCTRL_CYCLEACCURATE;\r\netm_unlock(t);\r\netm_writel(t, v, ETMR_CTRL);\r\nwhile (!(etm_readl(t, ETMR_CTRL) & ETMCTRL_PROGRAM) && --timeout)\r\n;\r\nif (!timeout) {\r\ndev_dbg(t->dev, "Waiting for progbit to assert timed out\n");\r\netm_lock(t);\r\nreturn -EFAULT;\r\n}\r\netm_setup_address_range(t, 1, (unsigned long)_stext,\r\n(unsigned long)_etext, 0, 0);\r\netm_writel(t, 0, ETMR_TRACEENCTRL2);\r\netm_writel(t, 0, ETMR_TRACESSCTRL);\r\netm_writel(t, 0x6f, ETMR_TRACEENEVT);\r\nv &= ~ETMCTRL_PROGRAM;\r\nv |= ETMCTRL_PORTSEL;\r\netm_writel(t, v, ETMR_CTRL);\r\ntimeout = TRACER_TIMEOUT;\r\nwhile (etm_readl(t, ETMR_CTRL) & ETMCTRL_PROGRAM && --timeout)\r\n;\r\nif (!timeout) {\r\ndev_dbg(t->dev, "Waiting for progbit to deassert timed out\n");\r\netm_lock(t);\r\nreturn -EFAULT;\r\n}\r\netm_lock(t);\r\nt->flags |= TRACER_RUNNING;\r\nreturn 0;\r\n}\r\nstatic int trace_stop(struct tracectx *t)\r\n{\r\nunsigned long timeout = TRACER_TIMEOUT;\r\netm_unlock(t);\r\netm_writel(t, 0x440, ETMR_CTRL);\r\nwhile (!(etm_readl(t, ETMR_CTRL) & ETMCTRL_PROGRAM) && --timeout)\r\n;\r\nif (!timeout) {\r\ndev_dbg(t->dev, "Waiting for progbit to assert timed out\n");\r\netm_lock(t);\r\nreturn -EFAULT;\r\n}\r\netm_lock(t);\r\netb_unlock(t);\r\netb_writel(t, ETBFF_MANUAL_FLUSH, ETBR_FORMATTERCTRL);\r\ntimeout = TRACER_TIMEOUT;\r\nwhile (etb_readl(t, ETBR_FORMATTERCTRL) &\r\nETBFF_MANUAL_FLUSH && --timeout)\r\n;\r\nif (!timeout) {\r\ndev_dbg(t->dev, "Waiting for formatter flush to commence "\r\n"timed out\n");\r\netb_lock(t);\r\nreturn -EFAULT;\r\n}\r\netb_writel(t, 0, ETBR_CTRL);\r\netb_lock(t);\r\nt->flags &= ~TRACER_RUNNING;\r\nreturn 0;\r\n}\r\nstatic int etb_getdatalen(struct tracectx *t)\r\n{\r\nu32 v;\r\nint rp, wp;\r\nv = etb_readl(t, ETBR_STATUS);\r\nif (v & 1)\r\nreturn t->etb_bufsz;\r\nrp = etb_readl(t, ETBR_READADDR);\r\nwp = etb_readl(t, ETBR_WRITEADDR);\r\nif (rp > wp) {\r\netb_writel(t, 0, ETBR_READADDR);\r\netb_writel(t, 0, ETBR_WRITEADDR);\r\nreturn 0;\r\n}\r\nreturn wp - rp;\r\n}\r\nstatic void etm_dump(void)\r\n{\r\nstruct tracectx *t = &tracer;\r\nu32 first = 0;\r\nint length;\r\nif (!t->etb_regs) {\r\nprintk(KERN_INFO "No tracing hardware found\n");\r\nreturn;\r\n}\r\nif (trace_isrunning(t))\r\ntrace_stop(t);\r\netb_unlock(t);\r\nlength = etb_getdatalen(t);\r\nif (length == t->etb_bufsz)\r\nfirst = etb_readl(t, ETBR_WRITEADDR);\r\netb_writel(t, first, ETBR_READADDR);\r\nprintk(KERN_INFO "Trace buffer contents length: %d\n", length);\r\nprintk(KERN_INFO "--- ETB buffer begin ---\n");\r\nfor (; length; length--)\r\nprintk("%08x", cpu_to_be32(etb_readl(t, ETBR_READMEM)));\r\nprintk(KERN_INFO "\n--- ETB buffer end ---\n");\r\netb_writel(t, 1, ETBR_CTRL);\r\netb_writel(t, 0, ETBR_CTRL);\r\netb_writel(t, 0, ETBR_TRIGGERCOUNT);\r\netb_writel(t, 0, ETBR_READADDR);\r\netb_writel(t, 0, ETBR_WRITEADDR);\r\netb_lock(t);\r\n}\r\nstatic void sysrq_etm_dump(int key)\r\n{\r\ndev_dbg(tracer.dev, "Dumping ETB buffer\n");\r\netm_dump();\r\n}\r\nstatic int etb_open(struct inode *inode, struct file *file)\r\n{\r\nif (!tracer.etb_regs)\r\nreturn -ENODEV;\r\nfile->private_data = &tracer;\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic ssize_t etb_read(struct file *file, char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nint total, i;\r\nlong length;\r\nstruct tracectx *t = file->private_data;\r\nu32 first = 0;\r\nu32 *buf;\r\nmutex_lock(&t->mutex);\r\nif (trace_isrunning(t)) {\r\nlength = 0;\r\ngoto out;\r\n}\r\netb_unlock(t);\r\ntotal = etb_getdatalen(t);\r\nif (total == t->etb_bufsz)\r\nfirst = etb_readl(t, ETBR_WRITEADDR);\r\netb_writel(t, first, ETBR_READADDR);\r\nlength = min(total * 4, (int)len);\r\nbuf = vmalloc(length);\r\ndev_dbg(t->dev, "ETB buffer length: %d\n", total);\r\ndev_dbg(t->dev, "ETB status reg: %x\n", etb_readl(t, ETBR_STATUS));\r\nfor (i = 0; i < length / 4; i++)\r\nbuf[i] = etb_readl(t, ETBR_READMEM);\r\netb_writel(t, 1, ETBR_CTRL);\r\netb_writel(t, 0, ETBR_CTRL);\r\netb_writel(t, 0, ETBR_WRITEADDR);\r\netb_writel(t, 0, ETBR_READADDR);\r\netb_writel(t, 0, ETBR_TRIGGERCOUNT);\r\netb_lock(t);\r\nlength -= copy_to_user(data, buf, length);\r\nvfree(buf);\r\nout:\r\nmutex_unlock(&t->mutex);\r\nreturn length;\r\n}\r\nstatic int etb_release(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __devinit etb_probe(struct amba_device *dev, const struct amba_id *id)\r\n{\r\nstruct tracectx *t = &tracer;\r\nint ret = 0;\r\nret = amba_request_regions(dev, NULL);\r\nif (ret)\r\ngoto out;\r\nt->etb_regs = ioremap_nocache(dev->res.start, resource_size(&dev->res));\r\nif (!t->etb_regs) {\r\nret = -ENOMEM;\r\ngoto out_release;\r\n}\r\namba_set_drvdata(dev, t);\r\netb_miscdev.parent = &dev->dev;\r\nret = misc_register(&etb_miscdev);\r\nif (ret)\r\ngoto out_unmap;\r\nt->emu_clk = clk_get(&dev->dev, "emu_src_ck");\r\nif (IS_ERR(t->emu_clk)) {\r\ndev_dbg(&dev->dev, "Failed to obtain emu_src_ck.\n");\r\nreturn -EFAULT;\r\n}\r\nclk_enable(t->emu_clk);\r\netb_unlock(t);\r\nt->etb_bufsz = etb_readl(t, ETBR_DEPTH);\r\ndev_dbg(&dev->dev, "Size: %x\n", t->etb_bufsz);\r\netb_writel(t, 0, ETBR_CTRL);\r\netb_writel(t, 0x1000, ETBR_FORMATTERCTRL);\r\netb_lock(t);\r\ndev_dbg(&dev->dev, "ETB AMBA driver initialized.\n");\r\nout:\r\nreturn ret;\r\nout_unmap:\r\namba_set_drvdata(dev, NULL);\r\niounmap(t->etb_regs);\r\nout_release:\r\namba_release_regions(dev);\r\nreturn ret;\r\n}\r\nstatic int etb_remove(struct amba_device *dev)\r\n{\r\nstruct tracectx *t = amba_get_drvdata(dev);\r\namba_set_drvdata(dev, NULL);\r\niounmap(t->etb_regs);\r\nt->etb_regs = NULL;\r\nclk_disable(t->emu_clk);\r\nclk_put(t->emu_clk);\r\namba_release_regions(dev);\r\nreturn 0;\r\n}\r\nstatic ssize_t trace_running_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%x\n", trace_isrunning(&tracer));\r\n}\r\nstatic ssize_t trace_running_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t n)\r\n{\r\nunsigned int value;\r\nint ret;\r\nif (sscanf(buf, "%u", &value) != 1)\r\nreturn -EINVAL;\r\nmutex_lock(&tracer.mutex);\r\nret = value ? trace_start(&tracer) : trace_stop(&tracer);\r\nmutex_unlock(&tracer.mutex);\r\nreturn ret ? : n;\r\n}\r\nstatic ssize_t trace_info_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nchar *buf)\r\n{\r\nu32 etb_wa, etb_ra, etb_st, etb_fc, etm_ctrl, etm_st;\r\nint datalen;\r\netb_unlock(&tracer);\r\ndatalen = etb_getdatalen(&tracer);\r\netb_wa = etb_readl(&tracer, ETBR_WRITEADDR);\r\netb_ra = etb_readl(&tracer, ETBR_READADDR);\r\netb_st = etb_readl(&tracer, ETBR_STATUS);\r\netb_fc = etb_readl(&tracer, ETBR_FORMATTERCTRL);\r\netb_lock(&tracer);\r\netm_unlock(&tracer);\r\netm_ctrl = etm_readl(&tracer, ETMR_CTRL);\r\netm_st = etm_readl(&tracer, ETMR_STATUS);\r\netm_lock(&tracer);\r\nreturn sprintf(buf, "Trace buffer len: %d\nComparator pairs: %d\n"\r\n"ETBR_WRITEADDR:\t%08x\n"\r\n"ETBR_READADDR:\t%08x\n"\r\n"ETBR_STATUS:\t%08x\n"\r\n"ETBR_FORMATTERCTRL:\t%08x\n"\r\n"ETMR_CTRL:\t%08x\n"\r\n"ETMR_STATUS:\t%08x\n",\r\ndatalen,\r\ntracer.ncmppairs,\r\netb_wa,\r\netb_ra,\r\netb_st,\r\netb_fc,\r\netm_ctrl,\r\netm_st\r\n);\r\n}\r\nstatic ssize_t trace_mode_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%d %d\n",\r\n!!(tracer.flags & TRACER_CYCLE_ACC),\r\ntracer.etm_portsz);\r\n}\r\nstatic ssize_t trace_mode_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t n)\r\n{\r\nunsigned int cycacc, portsz;\r\nif (sscanf(buf, "%u %u", &cycacc, &portsz) != 2)\r\nreturn -EINVAL;\r\nmutex_lock(&tracer.mutex);\r\nif (cycacc)\r\ntracer.flags |= TRACER_CYCLE_ACC;\r\nelse\r\ntracer.flags &= ~TRACER_CYCLE_ACC;\r\ntracer.etm_portsz = portsz & 0x0f;\r\nmutex_unlock(&tracer.mutex);\r\nreturn n;\r\n}\r\nstatic int __devinit etm_probe(struct amba_device *dev, const struct amba_id *id)\r\n{\r\nstruct tracectx *t = &tracer;\r\nint ret = 0;\r\nif (t->etm_regs) {\r\ndev_dbg(&dev->dev, "ETM already initialized\n");\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nret = amba_request_regions(dev, NULL);\r\nif (ret)\r\ngoto out;\r\nt->etm_regs = ioremap_nocache(dev->res.start, resource_size(&dev->res));\r\nif (!t->etm_regs) {\r\nret = -ENOMEM;\r\ngoto out_release;\r\n}\r\namba_set_drvdata(dev, t);\r\nmutex_init(&t->mutex);\r\nt->dev = &dev->dev;\r\nt->flags = TRACER_CYCLE_ACC;\r\nt->etm_portsz = 1;\r\netm_unlock(t);\r\n(void)etm_readl(t, ETMMR_PDSR);\r\n(void)etm_readl(&tracer, ETMMR_OSSRR);\r\nt->ncmppairs = etm_readl(t, ETMR_CONFCODE) & 0xf;\r\netm_writel(t, 0x440, ETMR_CTRL);\r\netm_lock(t);\r\nret = sysfs_create_file(&dev->dev.kobj,\r\n&trace_running_attr.attr);\r\nif (ret)\r\ngoto out_unmap;\r\nret = sysfs_create_file(&dev->dev.kobj, &trace_info_attr.attr);\r\nif (ret)\r\ndev_dbg(&dev->dev, "Failed to create trace_info in sysfs\n");\r\nret = sysfs_create_file(&dev->dev.kobj, &trace_mode_attr.attr);\r\nif (ret)\r\ndev_dbg(&dev->dev, "Failed to create trace_mode in sysfs\n");\r\ndev_dbg(t->dev, "ETM AMBA driver initialized.\n");\r\nout:\r\nreturn ret;\r\nout_unmap:\r\namba_set_drvdata(dev, NULL);\r\niounmap(t->etm_regs);\r\nout_release:\r\namba_release_regions(dev);\r\nreturn ret;\r\n}\r\nstatic int etm_remove(struct amba_device *dev)\r\n{\r\nstruct tracectx *t = amba_get_drvdata(dev);\r\namba_set_drvdata(dev, NULL);\r\niounmap(t->etm_regs);\r\nt->etm_regs = NULL;\r\namba_release_regions(dev);\r\nsysfs_remove_file(&dev->dev.kobj, &trace_running_attr.attr);\r\nsysfs_remove_file(&dev->dev.kobj, &trace_info_attr.attr);\r\nsysfs_remove_file(&dev->dev.kobj, &trace_mode_attr.attr);\r\nreturn 0;\r\n}\r\nstatic int __init etm_init(void)\r\n{\r\nint retval;\r\nretval = amba_driver_register(&etb_driver);\r\nif (retval) {\r\nprintk(KERN_ERR "Failed to register etb\n");\r\nreturn retval;\r\n}\r\nretval = amba_driver_register(&etm_driver);\r\nif (retval) {\r\namba_driver_unregister(&etb_driver);\r\nprintk(KERN_ERR "Failed to probe etm\n");\r\nreturn retval;\r\n}\r\n(void)register_sysrq_key('v', &sysrq_etm_op);\r\nreturn 0;\r\n}
