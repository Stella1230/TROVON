void ipath_disarm_senderrbufs(struct ipath_devdata *dd)\r\n{\r\nu32 piobcnt;\r\nunsigned long sbuf[4];\r\npiobcnt = dd->ipath_piobcnt2k + dd->ipath_piobcnt4k;\r\nsbuf[0] = ipath_read_kreg64(\r\ndd, dd->ipath_kregs->kr_sendbuffererror);\r\nsbuf[1] = ipath_read_kreg64(\r\ndd, dd->ipath_kregs->kr_sendbuffererror + 1);\r\nif (piobcnt > 128)\r\nsbuf[2] = ipath_read_kreg64(\r\ndd, dd->ipath_kregs->kr_sendbuffererror + 2);\r\nif (piobcnt > 192)\r\nsbuf[3] = ipath_read_kreg64(\r\ndd, dd->ipath_kregs->kr_sendbuffererror + 3);\r\nelse\r\nsbuf[3] = 0;\r\nif (sbuf[0] || sbuf[1] || (piobcnt > 128 && (sbuf[2] || sbuf[3]))) {\r\nint i;\r\nif (ipath_debug & (__IPATH_PKTDBG|__IPATH_DBG) &&\r\ndd->ipath_lastcancel > jiffies) {\r\n__IPATH_DBG_WHICH(__IPATH_PKTDBG|__IPATH_DBG,\r\n"SendbufErrs %lx %lx", sbuf[0],\r\nsbuf[1]);\r\nif (ipath_debug & __IPATH_PKTDBG && piobcnt > 128)\r\nprintk(" %lx %lx ", sbuf[2], sbuf[3]);\r\nprintk("\n");\r\n}\r\nfor (i = 0; i < piobcnt; i++)\r\nif (test_bit(i, sbuf))\r\nipath_disarm_piobufs(dd, i, 1);\r\ndd->ipath_lastcancel = jiffies+3;\r\n}\r\n}\r\nstatic u64 handle_e_sum_errs(struct ipath_devdata *dd, ipath_err_t errs)\r\n{\r\nu64 ignore_this_time = 0;\r\nipath_disarm_senderrbufs(dd);\r\nif ((errs & E_SUM_LINK_PKTERRS) &&\r\n!(dd->ipath_flags & IPATH_LINKACTIVE)) {\r\nipath_dbg("Ignoring packet errors %llx, because link not "\r\n"ACTIVE\n", (unsigned long long) errs);\r\nignore_this_time = errs & E_SUM_LINK_PKTERRS;\r\n}\r\nreturn ignore_this_time;\r\n}\r\nstatic void ipath_format_hwmsg(char *msg, size_t msgl, const char *hwmsg)\r\n{\r\nstrlcat(msg, "[", msgl);\r\nstrlcat(msg, hwmsg, msgl);\r\nstrlcat(msg, "]", msgl);\r\n}\r\nvoid ipath_format_hwerrors(u64 hwerrs,\r\nconst struct ipath_hwerror_msgs *hwerrmsgs,\r\nsize_t nhwerrmsgs,\r\nchar *msg, size_t msgl)\r\n{\r\nint i;\r\nconst int glen =\r\nsizeof(ipath_generic_hwerror_msgs) /\r\nsizeof(ipath_generic_hwerror_msgs[0]);\r\nfor (i=0; i<glen; i++) {\r\nif (hwerrs & ipath_generic_hwerror_msgs[i].mask) {\r\nipath_format_hwmsg(msg, msgl,\r\nipath_generic_hwerror_msgs[i].msg);\r\n}\r\n}\r\nfor (i=0; i<nhwerrmsgs; i++) {\r\nif (hwerrs & hwerrmsgs[i].mask) {\r\nipath_format_hwmsg(msg, msgl, hwerrmsgs[i].msg);\r\n}\r\n}\r\n}\r\nstatic char *ib_linkstate(struct ipath_devdata *dd, u64 ibcs)\r\n{\r\nchar *ret;\r\nu32 state;\r\nstate = ipath_ib_state(dd, ibcs);\r\nif (state == dd->ib_init)\r\nret = "Init";\r\nelse if (state == dd->ib_arm)\r\nret = "Arm";\r\nelse if (state == dd->ib_active)\r\nret = "Active";\r\nelse\r\nret = "Down";\r\nreturn ret;\r\n}\r\nvoid signal_ib_event(struct ipath_devdata *dd, enum ib_event_type ev)\r\n{\r\nstruct ib_event event;\r\nevent.device = &dd->verbs_dev->ibdev;\r\nevent.element.port_num = 1;\r\nevent.event = ev;\r\nib_dispatch_event(&event);\r\n}\r\nstatic void handle_e_ibstatuschanged(struct ipath_devdata *dd,\r\nipath_err_t errs)\r\n{\r\nu32 ltstate, lstate, ibstate, lastlstate;\r\nu32 init = dd->ib_init;\r\nu32 arm = dd->ib_arm;\r\nu32 active = dd->ib_active;\r\nconst u64 ibcs = ipath_read_kreg64(dd, dd->ipath_kregs->kr_ibcstatus);\r\nlstate = ipath_ib_linkstate(dd, ibcs);\r\nibstate = ipath_ib_state(dd, ibcs);\r\nlastlstate = ipath_ib_linkstate(dd, dd->ipath_lastibcstat);\r\nltstate = ipath_ib_linktrstate(dd, ibcs);\r\nif ((ltstate == INFINIPATH_IBCS_LT_STATE_RECOVERRETRAIN) ||\r\n(ltstate == INFINIPATH_IBCS_LT_STATE_RECOVERWAITRMT) ||\r\n(ltstate == INFINIPATH_IBCS_LT_STATE_RECOVERIDLE))\r\ngoto done;\r\nif (lstate >= INFINIPATH_IBCS_L_STATE_INIT &&\r\nlastlstate == INFINIPATH_IBCS_L_STATE_DOWN) {\r\nif (dd->ipath_f_ib_updown(dd, 1, ibcs)) {\r\ndd->ipath_flags &= ~IPATH_IB_LINK_DISABLED;\r\nipath_cdbg(LINKVERB, "LinkUp handled, skipped\n");\r\ngoto skip_ibchange;\r\n}\r\n} else if ((lastlstate >= INFINIPATH_IBCS_L_STATE_INIT ||\r\n(dd->ipath_flags & IPATH_IB_FORCE_NOTIFY)) &&\r\nltstate <= INFINIPATH_IBCS_LT_STATE_CFGWAITRMT &&\r\nltstate != INFINIPATH_IBCS_LT_STATE_LINKUP) {\r\nint handled;\r\nhandled = dd->ipath_f_ib_updown(dd, 0, ibcs);\r\ndd->ipath_flags &= ~IPATH_IB_FORCE_NOTIFY;\r\nif (handled) {\r\nipath_cdbg(LINKVERB, "LinkDown handled, skipped\n");\r\ngoto skip_ibchange;\r\n}\r\n}\r\nif ((ibstate != arm && ibstate != active) &&\r\n(dd->ipath_flags & (IPATH_LINKARMED | IPATH_LINKACTIVE))) {\r\ndev_info(&dd->pcidev->dev, "Link state changed from %s "\r\n"to %s\n", (dd->ipath_flags & IPATH_LINKARMED) ?\r\n"ARM" : "ACTIVE", ib_linkstate(dd, ibcs));\r\n}\r\nif (ltstate == INFINIPATH_IBCS_LT_STATE_POLLACTIVE ||\r\nltstate == INFINIPATH_IBCS_LT_STATE_POLLQUIET) {\r\nu32 lastlts;\r\nlastlts = ipath_ib_linktrstate(dd, dd->ipath_lastibcstat);\r\nif (lastlts == INFINIPATH_IBCS_LT_STATE_POLLACTIVE ||\r\nlastlts == INFINIPATH_IBCS_LT_STATE_POLLQUIET) {\r\nif (!(dd->ipath_flags & IPATH_IB_AUTONEG_INPROG) &&\r\n(++dd->ipath_ibpollcnt == 40)) {\r\ndd->ipath_flags |= IPATH_NOCABLE;\r\n*dd->ipath_statusp |=\r\nIPATH_STATUS_IB_NOCABLE;\r\nipath_cdbg(LINKVERB, "Set NOCABLE\n");\r\n}\r\nipath_cdbg(LINKVERB, "POLL change to %s (%x)\n",\r\nipath_ibcstatus_str[ltstate], ibstate);\r\ngoto skip_ibchange;\r\n}\r\n}\r\ndd->ipath_ibpollcnt = 0;\r\nipath_stats.sps_iblink++;\r\nif (ibstate != init && dd->ipath_lastlinkrecov && ipath_linkrecovery) {\r\nu64 linkrecov;\r\nlinkrecov = ipath_snap_cntr(dd,\r\ndd->ipath_cregs->cr_iblinkerrrecovcnt);\r\nif (linkrecov != dd->ipath_lastlinkrecov) {\r\nipath_dbg("IB linkrecov up %Lx (%s %s) recov %Lu\n",\r\n(unsigned long long) ibcs,\r\nib_linkstate(dd, ibcs),\r\nipath_ibcstatus_str[ltstate],\r\n(unsigned long long) linkrecov);\r\ndd->ipath_lastlinkrecov = 0;\r\nipath_set_linkstate(dd, IPATH_IB_LINKDOWN);\r\ngoto skip_ibchange;\r\n}\r\n}\r\nif (ibstate == init || ibstate == arm || ibstate == active) {\r\n*dd->ipath_statusp &= ~IPATH_STATUS_IB_NOCABLE;\r\nif (ibstate == init || ibstate == arm) {\r\n*dd->ipath_statusp &= ~IPATH_STATUS_IB_READY;\r\nif (dd->ipath_flags & IPATH_LINKACTIVE)\r\nsignal_ib_event(dd, IB_EVENT_PORT_ERR);\r\n}\r\nif (ibstate == arm) {\r\ndd->ipath_flags |= IPATH_LINKARMED;\r\ndd->ipath_flags &= ~(IPATH_LINKUNK |\r\nIPATH_LINKINIT | IPATH_LINKDOWN |\r\nIPATH_LINKACTIVE | IPATH_NOCABLE);\r\nipath_hol_down(dd);\r\n} else if (ibstate == init) {\r\ndd->ipath_flags |= IPATH_LINKINIT |\r\nIPATH_LINKDOWN;\r\ndd->ipath_flags &= ~(IPATH_LINKUNK |\r\nIPATH_LINKARMED | IPATH_LINKACTIVE |\r\nIPATH_NOCABLE);\r\nipath_hol_down(dd);\r\n} else {\r\ndd->ipath_lastlinkrecov = ipath_snap_cntr(dd,\r\ndd->ipath_cregs->cr_iblinkerrrecovcnt);\r\n*dd->ipath_statusp |=\r\nIPATH_STATUS_IB_READY | IPATH_STATUS_IB_CONF;\r\ndd->ipath_flags |= IPATH_LINKACTIVE;\r\ndd->ipath_flags &= ~(IPATH_LINKUNK | IPATH_LINKINIT\r\n| IPATH_LINKDOWN | IPATH_LINKARMED |\r\nIPATH_NOCABLE);\r\nif (dd->ipath_flags & IPATH_HAS_SEND_DMA)\r\nipath_restart_sdma(dd);\r\nsignal_ib_event(dd, IB_EVENT_PORT_ACTIVE);\r\ndd->ipath_f_setextled(dd, lstate, ltstate);\r\nipath_hol_up(dd);\r\n}\r\nif (lstate == lastlstate)\r\nipath_cdbg(LINKVERB, "Unchanged from last: %s "\r\n"(%x)\n", ib_linkstate(dd, ibcs), ibstate);\r\nelse\r\nipath_cdbg(VERBOSE, "Unit %u: link up to %s %s (%x)\n",\r\ndd->ipath_unit, ib_linkstate(dd, ibcs),\r\nipath_ibcstatus_str[ltstate], ibstate);\r\n} else {\r\nif (dd->ipath_flags & IPATH_LINKACTIVE)\r\nsignal_ib_event(dd, IB_EVENT_PORT_ERR);\r\ndd->ipath_flags |= IPATH_LINKDOWN;\r\ndd->ipath_flags &= ~(IPATH_LINKUNK | IPATH_LINKINIT\r\n| IPATH_LINKACTIVE |\r\nIPATH_LINKARMED);\r\n*dd->ipath_statusp &= ~IPATH_STATUS_IB_READY;\r\ndd->ipath_lli_counter = 0;\r\nif (lastlstate != INFINIPATH_IBCS_L_STATE_DOWN)\r\nipath_cdbg(VERBOSE, "Unit %u link state down "\r\n"(state 0x%x), from %s\n",\r\ndd->ipath_unit, lstate,\r\nib_linkstate(dd, dd->ipath_lastibcstat));\r\nelse\r\nipath_cdbg(LINKVERB, "Unit %u link state changed "\r\n"to %s (0x%x) from down (%x)\n",\r\ndd->ipath_unit,\r\nipath_ibcstatus_str[ltstate],\r\nibstate, lastlstate);\r\n}\r\nskip_ibchange:\r\ndd->ipath_lastibcstat = ibcs;\r\ndone:\r\nreturn;\r\n}\r\nstatic void handle_supp_msgs(struct ipath_devdata *dd,\r\nunsigned supp_msgs, char *msg, u32 msgsz)\r\n{\r\nif (dd->ipath_lasterror & ~INFINIPATH_E_IBSTATUSCHANGED) {\r\nint iserr;\r\nipath_err_t mask;\r\niserr = ipath_decode_err(dd, msg, msgsz,\r\ndd->ipath_lasterror &\r\n~INFINIPATH_E_IBSTATUSCHANGED);\r\nmask = INFINIPATH_E_RRCVEGRFULL | INFINIPATH_E_RRCVHDRFULL |\r\nINFINIPATH_E_PKTERRS | INFINIPATH_E_SDMADISABLED;\r\nif (ipath_debug & __IPATH_DBG)\r\nmask &= ~INFINIPATH_E_SDMADISABLED;\r\nif (dd->ipath_lasterror & ~mask)\r\nipath_dev_err(dd, "Suppressed %u messages for "\r\n"fast-repeating errors (%s) (%llx)\n",\r\nsupp_msgs, msg,\r\n(unsigned long long)\r\ndd->ipath_lasterror);\r\nelse {\r\nif (iserr)\r\nipath_dbg("Suppressed %u messages for %s\n",\r\nsupp_msgs, msg);\r\nelse\r\nipath_cdbg(ERRPKT,\r\n"Suppressed %u messages for %s\n",\r\nsupp_msgs, msg);\r\n}\r\n}\r\n}\r\nstatic unsigned handle_frequent_errors(struct ipath_devdata *dd,\r\nipath_err_t errs, char *msg,\r\nu32 msgsz, int *noprint)\r\n{\r\nunsigned long nc;\r\nstatic unsigned long nextmsg_time;\r\nstatic unsigned nmsgs, supp_msgs;\r\nnc = jiffies;\r\nif (nmsgs > 10) {\r\nif (time_before(nc, nextmsg_time)) {\r\n*noprint = 1;\r\nif (!supp_msgs++)\r\nnextmsg_time = nc + HZ * 3;\r\n}\r\nelse if (supp_msgs) {\r\nhandle_supp_msgs(dd, supp_msgs, msg, msgsz);\r\nsupp_msgs = 0;\r\nnmsgs = 0;\r\n}\r\n}\r\nelse if (!nmsgs++ || time_after(nc, nextmsg_time))\r\nnextmsg_time = nc + HZ / 2;\r\nreturn supp_msgs;\r\n}\r\nstatic void handle_sdma_errors(struct ipath_devdata *dd, ipath_err_t errs)\r\n{\r\nunsigned long flags;\r\nint expected;\r\nif (ipath_debug & __IPATH_DBG) {\r\nchar msg[128];\r\nipath_decode_err(dd, msg, sizeof msg, errs &\r\nINFINIPATH_E_SDMAERRS);\r\nipath_dbg("errors %lx (%s)\n", (unsigned long)errs, msg);\r\n}\r\nif (ipath_debug & __IPATH_VERBDBG) {\r\nunsigned long tl, hd, status, lengen;\r\ntl = ipath_read_kreg64(dd, dd->ipath_kregs->kr_senddmatail);\r\nhd = ipath_read_kreg64(dd, dd->ipath_kregs->kr_senddmahead);\r\nstatus = ipath_read_kreg64(dd\r\n, dd->ipath_kregs->kr_senddmastatus);\r\nlengen = ipath_read_kreg64(dd,\r\ndd->ipath_kregs->kr_senddmalengen);\r\nipath_cdbg(VERBOSE, "sdma tl 0x%lx hd 0x%lx status 0x%lx "\r\n"lengen 0x%lx\n", tl, hd, status, lengen);\r\n}\r\nspin_lock_irqsave(&dd->ipath_sdma_lock, flags);\r\n__set_bit(IPATH_SDMA_DISABLED, &dd->ipath_sdma_status);\r\nexpected = test_bit(IPATH_SDMA_ABORTING, &dd->ipath_sdma_status);\r\nspin_unlock_irqrestore(&dd->ipath_sdma_lock, flags);\r\nif (!expected)\r\nipath_cancel_sends(dd, 1);\r\n}\r\nstatic void handle_sdma_intr(struct ipath_devdata *dd, u64 istat)\r\n{\r\nunsigned long flags;\r\nint expected;\r\nif ((istat & INFINIPATH_I_SDMAINT) &&\r\n!test_bit(IPATH_SDMA_SHUTDOWN, &dd->ipath_sdma_status))\r\nipath_sdma_intr(dd);\r\nif (istat & INFINIPATH_I_SDMADISABLED) {\r\nexpected = test_bit(IPATH_SDMA_ABORTING,\r\n&dd->ipath_sdma_status);\r\nipath_dbg("%s SDmaDisabled intr\n",\r\nexpected ? "expected" : "unexpected");\r\nspin_lock_irqsave(&dd->ipath_sdma_lock, flags);\r\n__set_bit(IPATH_SDMA_DISABLED, &dd->ipath_sdma_status);\r\nspin_unlock_irqrestore(&dd->ipath_sdma_lock, flags);\r\nif (!expected)\r\nipath_cancel_sends(dd, 1);\r\nif (!test_bit(IPATH_SDMA_SHUTDOWN, &dd->ipath_sdma_status))\r\ntasklet_hi_schedule(&dd->ipath_sdma_abort_task);\r\n}\r\n}\r\nstatic int handle_hdrq_full(struct ipath_devdata *dd)\r\n{\r\nint chkerrpkts = 0;\r\nu32 hd, tl;\r\nu32 i;\r\nipath_stats.sps_hdrqfull++;\r\nfor (i = 0; i < dd->ipath_cfgports; i++) {\r\nstruct ipath_portdata *pd = dd->ipath_pd[i];\r\nif (i == 0) {\r\nif (pd->port_head != ipath_get_hdrqtail(pd))\r\nchkerrpkts |= 1 << i;\r\ncontinue;\r\n}\r\nif (!pd || !pd->port_cnt)\r\ncontinue;\r\nif (dd->ipath_flags & IPATH_NODMA_RTAIL)\r\ntl = ipath_read_ureg32(dd, ur_rcvhdrtail, i);\r\nelse\r\ntl = ipath_get_rcvhdrtail(pd);\r\nif (tl == pd->port_lastrcvhdrqtail)\r\ncontinue;\r\nhd = ipath_read_ureg32(dd, ur_rcvhdrhead, i);\r\nif (hd == (tl + 1) || (!hd && tl == dd->ipath_hdrqlast)) {\r\npd->port_lastrcvhdrqtail = tl;\r\npd->port_hdrqfull++;\r\nwmb();\r\nwake_up_interruptible(&pd->port_wait);\r\n}\r\n}\r\nreturn chkerrpkts;\r\n}\r\nstatic int handle_errors(struct ipath_devdata *dd, ipath_err_t errs)\r\n{\r\nchar msg[128];\r\nu64 ignore_this_time = 0;\r\nu64 iserr = 0;\r\nint chkerrpkts = 0, noprint = 0;\r\nunsigned supp_msgs;\r\nint log_idx;\r\nerrs &= dd->ipath_errormask & ~dd->ipath_maskederrs;\r\nsupp_msgs = handle_frequent_errors(dd, errs, msg, (u32)sizeof msg,\r\n&noprint);\r\nif (errs & INFINIPATH_E_HARDWARE) {\r\ndd->ipath_f_handle_hwerrors(dd, msg, sizeof msg);\r\n} else {\r\nu64 mask;\r\nfor (log_idx = 0; log_idx < IPATH_EEP_LOG_CNT; ++log_idx) {\r\nmask = dd->ipath_eep_st_masks[log_idx].errs_to_log;\r\nif (errs & mask)\r\nipath_inc_eeprom_err(dd, log_idx, 1);\r\n}\r\n}\r\nif (errs & INFINIPATH_E_SDMAERRS)\r\nhandle_sdma_errors(dd, errs);\r\nif (!noprint && (errs & ~dd->ipath_e_bitsextant))\r\nipath_dev_err(dd, "error interrupt with unknown errors "\r\n"%llx set\n", (unsigned long long)\r\n(errs & ~dd->ipath_e_bitsextant));\r\nif (errs & E_SUM_ERRS)\r\nignore_this_time = handle_e_sum_errs(dd, errs);\r\nelse if ((errs & E_SUM_LINK_PKTERRS) &&\r\n!(dd->ipath_flags & IPATH_LINKACTIVE)) {\r\nipath_dbg("Ignoring packet errors %llx, because link not "\r\n"ACTIVE\n", (unsigned long long) errs);\r\nignore_this_time = errs & E_SUM_LINK_PKTERRS;\r\n}\r\nif (supp_msgs == 250000) {\r\nint s_iserr;\r\ndd->ipath_maskederrs |= dd->ipath_lasterror | errs;\r\ndd->ipath_errormask &= ~dd->ipath_maskederrs;\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_errormask,\r\ndd->ipath_errormask);\r\ns_iserr = ipath_decode_err(dd, msg, sizeof msg,\r\ndd->ipath_maskederrs);\r\nif (dd->ipath_maskederrs &\r\n~(INFINIPATH_E_RRCVEGRFULL |\r\nINFINIPATH_E_RRCVHDRFULL | INFINIPATH_E_PKTERRS))\r\nipath_dev_err(dd, "Temporarily disabling "\r\n"error(s) %llx reporting; too frequent (%s)\n",\r\n(unsigned long long) dd->ipath_maskederrs,\r\nmsg);\r\nelse {\r\nif (s_iserr)\r\nipath_dbg("Temporarily disabling reporting "\r\n"too frequent queue full errors (%s)\n",\r\nmsg);\r\nelse\r\nipath_cdbg(ERRPKT,\r\n"Temporarily disabling reporting too"\r\n" frequent packet errors (%s)\n",\r\nmsg);\r\n}\r\ndd->ipath_unmasktime = jiffies + HZ * 180;\r\n}\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_errorclear, errs);\r\nif (ignore_this_time)\r\nerrs &= ~ignore_this_time;\r\nif (errs & ~dd->ipath_lasterror) {\r\nerrs &= ~dd->ipath_lasterror;\r\ndd->ipath_lasterror |= errs &\r\n~(INFINIPATH_E_HARDWARE |\r\nINFINIPATH_E_IBSTATUSCHANGED);\r\n}\r\nif (errs & INFINIPATH_E_SENDSPECIALTRIGGER) {\r\ndd->ipath_spectriggerhit++;\r\nipath_dbg("%lu special trigger hits\n",\r\ndd->ipath_spectriggerhit);\r\n}\r\nif ((errs & (INFINIPATH_E_SPKTLEN | INFINIPATH_E_SPIOARMLAUNCH)) &&\r\ndd->ipath_lastcancel > jiffies) {\r\nipath_cdbg(VERBOSE,\r\n"Suppressed %s error (%llx) after sendbuf cancel\n",\r\n(errs & INFINIPATH_E_SPIOARMLAUNCH) ?\r\n"armlaunch" : "sendpktlen", (unsigned long long)errs);\r\nerrs &= ~(INFINIPATH_E_SPIOARMLAUNCH | INFINIPATH_E_SPKTLEN);\r\n}\r\nif (!errs)\r\nreturn 0;\r\nif (!noprint) {\r\nipath_err_t mask;\r\nmask = INFINIPATH_E_IBSTATUSCHANGED |\r\nINFINIPATH_E_RRCVEGRFULL | INFINIPATH_E_RRCVHDRFULL |\r\nINFINIPATH_E_HARDWARE | INFINIPATH_E_SDMADISABLED;\r\nif (ipath_debug & __IPATH_DBG)\r\nmask &= ~INFINIPATH_E_SDMADISABLED;\r\nipath_decode_err(dd, msg, sizeof msg, errs & ~mask);\r\n} else\r\n*msg = 0;\r\nif (errs & E_SUM_PKTERRS) {\r\nipath_stats.sps_pkterrs++;\r\nchkerrpkts = 1;\r\n}\r\nif (errs & E_SUM_ERRS)\r\nipath_stats.sps_errs++;\r\nif (errs & (INFINIPATH_E_RICRC | INFINIPATH_E_RVCRC)) {\r\nipath_stats.sps_crcerrs++;\r\nchkerrpkts = 1;\r\n}\r\niserr = errs & ~(E_SUM_PKTERRS | INFINIPATH_E_PKTERRS);\r\nif (errs & INFINIPATH_E_RRCVHDRFULL)\r\nchkerrpkts |= handle_hdrq_full(dd);\r\nif (errs & INFINIPATH_E_RRCVEGRFULL) {\r\nstruct ipath_portdata *pd = dd->ipath_pd[0];\r\nipath_stats.sps_etidfull++;\r\nif (pd->port_head != ipath_get_hdrqtail(pd))\r\nchkerrpkts |= 1;\r\n}\r\nif (errs & INFINIPATH_E_RIBLOSTLINK) {\r\nerrs |= INFINIPATH_E_IBSTATUSCHANGED;\r\nipath_stats.sps_iblink++;\r\ndd->ipath_flags |= IPATH_LINKDOWN;\r\ndd->ipath_flags &= ~(IPATH_LINKUNK | IPATH_LINKINIT\r\n| IPATH_LINKARMED | IPATH_LINKACTIVE);\r\n*dd->ipath_statusp &= ~IPATH_STATUS_IB_READY;\r\nipath_dbg("Lost link, link now down (%s)\n",\r\nipath_ibcstatus_str[ipath_read_kreg64(dd,\r\ndd->ipath_kregs->kr_ibcstatus) & 0xf]);\r\n}\r\nif (errs & INFINIPATH_E_IBSTATUSCHANGED)\r\nhandle_e_ibstatuschanged(dd, errs);\r\nif (errs & INFINIPATH_E_RESET) {\r\nif (!noprint)\r\nipath_dev_err(dd, "Got reset, requires re-init "\r\n"(unload and reload driver)\n");\r\ndd->ipath_flags &= ~IPATH_INITTED;\r\n*dd->ipath_statusp |= IPATH_STATUS_HWERROR;\r\n*dd->ipath_statusp &= ~IPATH_STATUS_IB_CONF;\r\n}\r\nif (!noprint && *msg) {\r\nif (iserr)\r\nipath_dev_err(dd, "%s error\n", msg);\r\n}\r\nif (dd->ipath_state_wanted & dd->ipath_flags) {\r\nipath_cdbg(VERBOSE, "driver wanted state %x, iflags now %x, "\r\n"waking\n", dd->ipath_state_wanted,\r\ndd->ipath_flags);\r\nwake_up_interruptible(&ipath_state_wait);\r\n}\r\nreturn chkerrpkts;\r\n}\r\nvoid ipath_clear_freeze(struct ipath_devdata *dd)\r\n{\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_errormask, 0ULL);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_intmask, 0ULL);\r\nipath_cancel_sends(dd, 1);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_control,\r\ndd->ipath_control);\r\nipath_read_kreg64(dd, dd->ipath_kregs->kr_scratch);\r\nipath_force_pio_avail_update(dd);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrclear, 0ULL);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_errorclear,\r\nE_SPKT_ERRS_IGNORE);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_errormask,\r\ndd->ipath_errormask);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_intmask, -1LL);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_intclear, 0ULL);\r\n}\r\nstatic noinline void ipath_bad_intr(struct ipath_devdata *dd, u32 *unexpectp)\r\n{\r\nif (++*unexpectp > 100) {\r\nif (++*unexpectp > 105) {\r\nif (dd->pcidev && dd->ipath_irq) {\r\nipath_dev_err(dd, "Now %u unexpected "\r\n"interrupts, unregistering "\r\n"interrupt handler\n",\r\n*unexpectp);\r\nipath_dbg("free_irq of irq %d\n",\r\ndd->ipath_irq);\r\ndd->ipath_f_free_irq(dd);\r\n}\r\n}\r\nif (ipath_read_ireg(dd, dd->ipath_kregs->kr_intmask)) {\r\nipath_dev_err(dd, "%u unexpected interrupts, "\r\n"disabling interrupts completely\n",\r\n*unexpectp);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_intmask,\r\n0ULL);\r\n}\r\n} else if (*unexpectp > 1)\r\nipath_dbg("Interrupt when not ready, should not happen, "\r\n"ignoring\n");\r\n}\r\nstatic noinline void ipath_bad_regread(struct ipath_devdata *dd)\r\n{\r\nstatic int allbits;\r\nipath_dev_err(dd,\r\n"Read of interrupt status failed (all bits set)\n");\r\nif (allbits++) {\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_intmask, 0ULL);\r\nif (allbits == 2) {\r\nipath_dev_err(dd, "Still bad interrupt status, "\r\n"unregistering interrupt\n");\r\ndd->ipath_f_free_irq(dd);\r\n} else if (allbits > 2) {\r\nif ((allbits % 10000) == 0)\r\nprintk(".");\r\n} else\r\nipath_dev_err(dd, "Disabling interrupts, "\r\n"multiple errors\n");\r\n}\r\n}\r\nstatic void handle_layer_pioavail(struct ipath_devdata *dd)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nret = ipath_ib_piobufavail(dd->verbs_dev);\r\nif (ret > 0)\r\ngoto set;\r\nreturn;\r\nset:\r\nspin_lock_irqsave(&dd->ipath_sendctrl_lock, flags);\r\ndd->ipath_sendctrl |= INFINIPATH_S_PIOINTBUFAVAIL;\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_sendctrl,\r\ndd->ipath_sendctrl);\r\nipath_read_kreg64(dd, dd->ipath_kregs->kr_scratch);\r\nspin_unlock_irqrestore(&dd->ipath_sendctrl_lock, flags);\r\n}\r\nstatic void handle_urcv(struct ipath_devdata *dd, u64 istat)\r\n{\r\nu64 portr;\r\nint i;\r\nint rcvdint = 0;\r\nrmb();\r\nportr = ((istat >> dd->ipath_i_rcvavail_shift) &\r\ndd->ipath_i_rcvavail_mask) |\r\n((istat >> dd->ipath_i_rcvurg_shift) &\r\ndd->ipath_i_rcvurg_mask);\r\nfor (i = 1; i < dd->ipath_cfgports; i++) {\r\nstruct ipath_portdata *pd = dd->ipath_pd[i];\r\nif (portr & (1 << i) && pd && pd->port_cnt) {\r\nif (test_and_clear_bit(IPATH_PORT_WAITING_RCV,\r\n&pd->port_flag)) {\r\nclear_bit(i + dd->ipath_r_intravail_shift,\r\n&dd->ipath_rcvctrl);\r\nwake_up_interruptible(&pd->port_wait);\r\nrcvdint = 1;\r\n} else if (test_and_clear_bit(IPATH_PORT_WAITING_URG,\r\n&pd->port_flag)) {\r\npd->port_urgent++;\r\nwake_up_interruptible(&pd->port_wait);\r\n}\r\n}\r\n}\r\nif (rcvdint) {\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_rcvctrl,\r\ndd->ipath_rcvctrl);\r\n}\r\n}\r\nirqreturn_t ipath_intr(int irq, void *data)\r\n{\r\nstruct ipath_devdata *dd = data;\r\nu64 istat, chk0rcv = 0;\r\nipath_err_t estat = 0;\r\nirqreturn_t ret;\r\nstatic unsigned unexpected = 0;\r\nu64 kportrbits;\r\nipath_stats.sps_ints++;\r\nif (dd->ipath_int_counter != (u32) -1)\r\ndd->ipath_int_counter++;\r\nif (!(dd->ipath_flags & IPATH_PRESENT)) {\r\nreturn IRQ_HANDLED;\r\n}\r\nif (!(dd->ipath_flags & IPATH_INITTED)) {\r\nipath_bad_intr(dd, &unexpected);\r\nret = IRQ_NONE;\r\ngoto bail;\r\n}\r\nistat = ipath_read_ireg(dd, dd->ipath_kregs->kr_intstatus);\r\nif (unlikely(!istat)) {\r\nipath_stats.sps_nullintr++;\r\nret = IRQ_NONE;\r\ngoto bail;\r\n}\r\nif (unlikely(istat == -1)) {\r\nipath_bad_regread(dd);\r\nret = IRQ_NONE;\r\ngoto bail;\r\n}\r\nif (unexpected)\r\nunexpected = 0;\r\nif (unlikely(istat & ~dd->ipath_i_bitsextant))\r\nipath_dev_err(dd,\r\n"interrupt with unknown interrupts %Lx set\n",\r\n(unsigned long long)\r\nistat & ~dd->ipath_i_bitsextant);\r\nelse if (istat & ~INFINIPATH_I_ERROR)\r\nipath_cdbg(VERBOSE, "intr stat=0x%Lx\n",\r\n(unsigned long long) istat);\r\nif (istat & INFINIPATH_I_ERROR) {\r\nipath_stats.sps_errints++;\r\nestat = ipath_read_kreg64(dd,\r\ndd->ipath_kregs->kr_errorstatus);\r\nif (!estat)\r\ndev_info(&dd->pcidev->dev, "error interrupt (%Lx), "\r\n"but no error bits set!\n",\r\n(unsigned long long) istat);\r\nelse if (estat == -1LL)\r\nipath_dev_err(dd, "Read of error status failed "\r\n"(all bits set); ignoring\n");\r\nelse\r\nchk0rcv |= handle_errors(dd, estat);\r\n}\r\nif (istat & INFINIPATH_I_GPIO) {\r\nu32 gpiostatus;\r\nu32 to_clear = 0;\r\ngpiostatus = ipath_read_kreg32(\r\ndd, dd->ipath_kregs->kr_gpio_status);\r\nif ((gpiostatus & IPATH_GPIO_ERRINTR_MASK) &&\r\n(dd->ipath_flags & IPATH_GPIO_ERRINTRS)) {\r\nto_clear |= (gpiostatus & IPATH_GPIO_ERRINTR_MASK);\r\nif (gpiostatus & (1 << IPATH_GPIO_RXUVL_BIT)) {\r\nipath_dbg("FlowCtl on UnsupVL\n");\r\ndd->ipath_rxfc_unsupvl_errs++;\r\n}\r\nif (gpiostatus & (1 << IPATH_GPIO_OVRUN_BIT)) {\r\nipath_dbg("Overrun Threshold exceeded\n");\r\ndd->ipath_overrun_thresh_errs++;\r\n}\r\nif (gpiostatus & (1 << IPATH_GPIO_LLI_BIT)) {\r\nipath_dbg("Local Link Integrity error\n");\r\ndd->ipath_lli_errs++;\r\n}\r\ngpiostatus &= ~IPATH_GPIO_ERRINTR_MASK;\r\n}\r\nif ((gpiostatus & (1 << IPATH_GPIO_PORT0_BIT)) &&\r\n(dd->ipath_flags & IPATH_GPIO_INTR)) {\r\nto_clear |= (1 << IPATH_GPIO_PORT0_BIT);\r\ngpiostatus &= ~(1 << IPATH_GPIO_PORT0_BIT);\r\nchk0rcv = 1;\r\n}\r\nif (gpiostatus) {\r\nconst u32 mask = (u32) dd->ipath_gpio_mask;\r\nif (mask & gpiostatus) {\r\nipath_dbg("Unexpected GPIO IRQ bits %x\n",\r\ngpiostatus & mask);\r\nto_clear |= (gpiostatus & mask);\r\ndd->ipath_gpio_mask &= ~(gpiostatus & mask);\r\nipath_write_kreg(dd,\r\ndd->ipath_kregs->kr_gpio_mask,\r\ndd->ipath_gpio_mask);\r\n}\r\n}\r\nif (to_clear) {\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_gpio_clear,\r\n(u64) to_clear);\r\n}\r\n}\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_intclear, istat);\r\nkportrbits = (1ULL << dd->ipath_i_rcvavail_shift) |\r\n(1ULL << dd->ipath_i_rcvurg_shift);\r\nif (chk0rcv || (istat & kportrbits)) {\r\nistat &= ~kportrbits;\r\nipath_kreceive(dd->ipath_pd[0]);\r\n}\r\nif (istat & ((dd->ipath_i_rcvavail_mask << dd->ipath_i_rcvavail_shift) |\r\n(dd->ipath_i_rcvurg_mask << dd->ipath_i_rcvurg_shift)))\r\nhandle_urcv(dd, istat);\r\nif (istat & (INFINIPATH_I_SDMAINT | INFINIPATH_I_SDMADISABLED))\r\nhandle_sdma_intr(dd, istat);\r\nif (istat & INFINIPATH_I_SPIOBUFAVAIL) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&dd->ipath_sendctrl_lock, flags);\r\ndd->ipath_sendctrl &= ~INFINIPATH_S_PIOINTBUFAVAIL;\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_sendctrl,\r\ndd->ipath_sendctrl);\r\nipath_read_kreg64(dd, dd->ipath_kregs->kr_scratch);\r\nspin_unlock_irqrestore(&dd->ipath_sendctrl_lock, flags);\r\nhandle_layer_pioavail(dd);\r\n}\r\nret = IRQ_HANDLED;\r\nbail:\r\nreturn ret;\r\n}
