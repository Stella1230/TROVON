static int rotary_encoder_get_state(struct rotary_encoder_platform_data *pdata)\r\n{\r\nint a = !!gpio_get_value(pdata->gpio_a);\r\nint b = !!gpio_get_value(pdata->gpio_b);\r\na ^= pdata->inverted_a;\r\nb ^= pdata->inverted_b;\r\nreturn ((a << 1) | b);\r\n}\r\nstatic void rotary_encoder_report_event(struct rotary_encoder *encoder)\r\n{\r\nstruct rotary_encoder_platform_data *pdata = encoder->pdata;\r\nif (pdata->relative_axis) {\r\ninput_report_rel(encoder->input,\r\npdata->axis, encoder->dir ? -1 : 1);\r\n} else {\r\nunsigned int pos = encoder->pos;\r\nif (encoder->dir) {\r\nif (pdata->rollover)\r\npos += pdata->steps;\r\nif (pos)\r\npos--;\r\n} else {\r\nif (pdata->rollover || pos < pdata->steps)\r\npos++;\r\n}\r\nif (pdata->rollover)\r\npos %= pdata->steps;\r\nencoder->pos = pos;\r\ninput_report_abs(encoder->input, pdata->axis, encoder->pos);\r\n}\r\ninput_sync(encoder->input);\r\n}\r\nstatic irqreturn_t rotary_encoder_irq(int irq, void *dev_id)\r\n{\r\nstruct rotary_encoder *encoder = dev_id;\r\nint state;\r\nstate = rotary_encoder_get_state(encoder->pdata);\r\nswitch (state) {\r\ncase 0x0:\r\nif (encoder->armed) {\r\nrotary_encoder_report_event(encoder);\r\nencoder->armed = false;\r\n}\r\nbreak;\r\ncase 0x1:\r\ncase 0x2:\r\nif (encoder->armed)\r\nencoder->dir = state - 1;\r\nbreak;\r\ncase 0x3:\r\nencoder->armed = true;\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t rotary_encoder_half_period_irq(int irq, void *dev_id)\r\n{\r\nstruct rotary_encoder *encoder = dev_id;\r\nint state;\r\nstate = rotary_encoder_get_state(encoder->pdata);\r\nswitch (state) {\r\ncase 0x00:\r\ncase 0x03:\r\nif (state != encoder->last_stable) {\r\nrotary_encoder_report_event(encoder);\r\nencoder->last_stable = state;\r\n}\r\nbreak;\r\ncase 0x01:\r\ncase 0x02:\r\nencoder->dir = (encoder->last_stable + state) & 0x01;\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __devinit rotary_encoder_probe(struct platform_device *pdev)\r\n{\r\nstruct rotary_encoder_platform_data *pdata = pdev->dev.platform_data;\r\nstruct rotary_encoder *encoder;\r\nstruct input_dev *input;\r\nirq_handler_t handler;\r\nint err;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "missing platform data\n");\r\nreturn -ENOENT;\r\n}\r\nencoder = kzalloc(sizeof(struct rotary_encoder), GFP_KERNEL);\r\ninput = input_allocate_device();\r\nif (!encoder || !input) {\r\ndev_err(&pdev->dev, "failed to allocate memory for device\n");\r\nerr = -ENOMEM;\r\ngoto exit_free_mem;\r\n}\r\nencoder->input = input;\r\nencoder->pdata = pdata;\r\nencoder->irq_a = gpio_to_irq(pdata->gpio_a);\r\nencoder->irq_b = gpio_to_irq(pdata->gpio_b);\r\ninput->name = pdev->name;\r\ninput->id.bustype = BUS_HOST;\r\ninput->dev.parent = &pdev->dev;\r\nif (pdata->relative_axis) {\r\ninput->evbit[0] = BIT_MASK(EV_REL);\r\ninput->relbit[0] = BIT_MASK(pdata->axis);\r\n} else {\r\ninput->evbit[0] = BIT_MASK(EV_ABS);\r\ninput_set_abs_params(encoder->input,\r\npdata->axis, 0, pdata->steps, 0, 1);\r\n}\r\nerr = input_register_device(input);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to register input device\n");\r\ngoto exit_free_mem;\r\n}\r\nerr = gpio_request(pdata->gpio_a, DRV_NAME);\r\nif (err) {\r\ndev_err(&pdev->dev, "unable to request GPIO %d\n",\r\npdata->gpio_a);\r\ngoto exit_unregister_input;\r\n}\r\nerr = gpio_direction_input(pdata->gpio_a);\r\nif (err) {\r\ndev_err(&pdev->dev, "unable to set GPIO %d for input\n",\r\npdata->gpio_a);\r\ngoto exit_unregister_input;\r\n}\r\nerr = gpio_request(pdata->gpio_b, DRV_NAME);\r\nif (err) {\r\ndev_err(&pdev->dev, "unable to request GPIO %d\n",\r\npdata->gpio_b);\r\ngoto exit_free_gpio_a;\r\n}\r\nerr = gpio_direction_input(pdata->gpio_b);\r\nif (err) {\r\ndev_err(&pdev->dev, "unable to set GPIO %d for input\n",\r\npdata->gpio_b);\r\ngoto exit_free_gpio_a;\r\n}\r\nif (pdata->half_period) {\r\nhandler = &rotary_encoder_half_period_irq;\r\nencoder->last_stable = rotary_encoder_get_state(pdata);\r\n} else {\r\nhandler = &rotary_encoder_irq;\r\n}\r\nerr = request_irq(encoder->irq_a, handler,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\r\nDRV_NAME, encoder);\r\nif (err) {\r\ndev_err(&pdev->dev, "unable to request IRQ %d\n",\r\nencoder->irq_a);\r\ngoto exit_free_gpio_b;\r\n}\r\nerr = request_irq(encoder->irq_b, handler,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\r\nDRV_NAME, encoder);\r\nif (err) {\r\ndev_err(&pdev->dev, "unable to request IRQ %d\n",\r\nencoder->irq_b);\r\ngoto exit_free_irq_a;\r\n}\r\nplatform_set_drvdata(pdev, encoder);\r\nreturn 0;\r\nexit_free_irq_a:\r\nfree_irq(encoder->irq_a, encoder);\r\nexit_free_gpio_b:\r\ngpio_free(pdata->gpio_b);\r\nexit_free_gpio_a:\r\ngpio_free(pdata->gpio_a);\r\nexit_unregister_input:\r\ninput_unregister_device(input);\r\ninput = NULL;\r\nexit_free_mem:\r\ninput_free_device(input);\r\nkfree(encoder);\r\nreturn err;\r\n}\r\nstatic int __devexit rotary_encoder_remove(struct platform_device *pdev)\r\n{\r\nstruct rotary_encoder *encoder = platform_get_drvdata(pdev);\r\nstruct rotary_encoder_platform_data *pdata = pdev->dev.platform_data;\r\nfree_irq(encoder->irq_a, encoder);\r\nfree_irq(encoder->irq_b, encoder);\r\ngpio_free(pdata->gpio_a);\r\ngpio_free(pdata->gpio_b);\r\ninput_unregister_device(encoder->input);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(encoder);\r\nreturn 0;\r\n}
