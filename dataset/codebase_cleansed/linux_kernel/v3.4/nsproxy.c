static inline struct nsproxy *create_nsproxy(void)\r\n{\r\nstruct nsproxy *nsproxy;\r\nnsproxy = kmem_cache_alloc(nsproxy_cachep, GFP_KERNEL);\r\nif (nsproxy)\r\natomic_set(&nsproxy->count, 1);\r\nreturn nsproxy;\r\n}\r\nstatic struct nsproxy *create_new_namespaces(unsigned long flags,\r\nstruct task_struct *tsk, struct fs_struct *new_fs)\r\n{\r\nstruct nsproxy *new_nsp;\r\nint err;\r\nnew_nsp = create_nsproxy();\r\nif (!new_nsp)\r\nreturn ERR_PTR(-ENOMEM);\r\nnew_nsp->mnt_ns = copy_mnt_ns(flags, tsk->nsproxy->mnt_ns, new_fs);\r\nif (IS_ERR(new_nsp->mnt_ns)) {\r\nerr = PTR_ERR(new_nsp->mnt_ns);\r\ngoto out_ns;\r\n}\r\nnew_nsp->uts_ns = copy_utsname(flags, tsk);\r\nif (IS_ERR(new_nsp->uts_ns)) {\r\nerr = PTR_ERR(new_nsp->uts_ns);\r\ngoto out_uts;\r\n}\r\nnew_nsp->ipc_ns = copy_ipcs(flags, tsk);\r\nif (IS_ERR(new_nsp->ipc_ns)) {\r\nerr = PTR_ERR(new_nsp->ipc_ns);\r\ngoto out_ipc;\r\n}\r\nnew_nsp->pid_ns = copy_pid_ns(flags, task_active_pid_ns(tsk));\r\nif (IS_ERR(new_nsp->pid_ns)) {\r\nerr = PTR_ERR(new_nsp->pid_ns);\r\ngoto out_pid;\r\n}\r\nnew_nsp->net_ns = copy_net_ns(flags, tsk->nsproxy->net_ns);\r\nif (IS_ERR(new_nsp->net_ns)) {\r\nerr = PTR_ERR(new_nsp->net_ns);\r\ngoto out_net;\r\n}\r\nreturn new_nsp;\r\nout_net:\r\nif (new_nsp->pid_ns)\r\nput_pid_ns(new_nsp->pid_ns);\r\nout_pid:\r\nif (new_nsp->ipc_ns)\r\nput_ipc_ns(new_nsp->ipc_ns);\r\nout_ipc:\r\nif (new_nsp->uts_ns)\r\nput_uts_ns(new_nsp->uts_ns);\r\nout_uts:\r\nif (new_nsp->mnt_ns)\r\nput_mnt_ns(new_nsp->mnt_ns);\r\nout_ns:\r\nkmem_cache_free(nsproxy_cachep, new_nsp);\r\nreturn ERR_PTR(err);\r\n}\r\nint copy_namespaces(unsigned long flags, struct task_struct *tsk)\r\n{\r\nstruct nsproxy *old_ns = tsk->nsproxy;\r\nstruct nsproxy *new_ns;\r\nint err = 0;\r\nif (!old_ns)\r\nreturn 0;\r\nget_nsproxy(old_ns);\r\nif (!(flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |\r\nCLONE_NEWPID | CLONE_NEWNET)))\r\nreturn 0;\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nerr = -EPERM;\r\ngoto out;\r\n}\r\nif ((flags & CLONE_NEWIPC) && (flags & CLONE_SYSVSEM)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nnew_ns = create_new_namespaces(flags, tsk, tsk->fs);\r\nif (IS_ERR(new_ns)) {\r\nerr = PTR_ERR(new_ns);\r\ngoto out;\r\n}\r\ntsk->nsproxy = new_ns;\r\nout:\r\nput_nsproxy(old_ns);\r\nreturn err;\r\n}\r\nvoid free_nsproxy(struct nsproxy *ns)\r\n{\r\nif (ns->mnt_ns)\r\nput_mnt_ns(ns->mnt_ns);\r\nif (ns->uts_ns)\r\nput_uts_ns(ns->uts_ns);\r\nif (ns->ipc_ns)\r\nput_ipc_ns(ns->ipc_ns);\r\nif (ns->pid_ns)\r\nput_pid_ns(ns->pid_ns);\r\nput_net(ns->net_ns);\r\nkmem_cache_free(nsproxy_cachep, ns);\r\n}\r\nint unshare_nsproxy_namespaces(unsigned long unshare_flags,\r\nstruct nsproxy **new_nsp, struct fs_struct *new_fs)\r\n{\r\nint err = 0;\r\nif (!(unshare_flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |\r\nCLONE_NEWNET)))\r\nreturn 0;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\n*new_nsp = create_new_namespaces(unshare_flags, current,\r\nnew_fs ? new_fs : current->fs);\r\nif (IS_ERR(*new_nsp)) {\r\nerr = PTR_ERR(*new_nsp);\r\ngoto out;\r\n}\r\nout:\r\nreturn err;\r\n}\r\nvoid switch_task_namespaces(struct task_struct *p, struct nsproxy *new)\r\n{\r\nstruct nsproxy *ns;\r\nmight_sleep();\r\nns = p->nsproxy;\r\nrcu_assign_pointer(p->nsproxy, new);\r\nif (ns && atomic_dec_and_test(&ns->count)) {\r\nsynchronize_rcu();\r\nfree_nsproxy(ns);\r\n}\r\n}\r\nvoid exit_task_namespaces(struct task_struct *p)\r\n{\r\nswitch_task_namespaces(p, NULL);\r\n}\r\nint __init nsproxy_cache_init(void)\r\n{\r\nnsproxy_cachep = KMEM_CACHE(nsproxy, SLAB_PANIC);\r\nreturn 0;\r\n}
