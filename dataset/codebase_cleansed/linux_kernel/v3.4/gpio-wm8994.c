static inline struct wm8994_gpio *to_wm8994_gpio(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct wm8994_gpio, gpio_chip);\r\n}\r\nstatic int wm8994_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct wm8994_gpio *wm8994_gpio = to_wm8994_gpio(chip);\r\nstruct wm8994 *wm8994 = wm8994_gpio->wm8994;\r\nswitch (wm8994->type) {\r\ncase WM8958:\r\nswitch (offset) {\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\ncase 4:\r\ncase 6:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8994_gpio_direction_in(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct wm8994_gpio *wm8994_gpio = to_wm8994_gpio(chip);\r\nstruct wm8994 *wm8994 = wm8994_gpio->wm8994;\r\nreturn wm8994_set_bits(wm8994, WM8994_GPIO_1 + offset,\r\nWM8994_GPN_DIR, WM8994_GPN_DIR);\r\n}\r\nstatic int wm8994_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct wm8994_gpio *wm8994_gpio = to_wm8994_gpio(chip);\r\nstruct wm8994 *wm8994 = wm8994_gpio->wm8994;\r\nint ret;\r\nret = wm8994_reg_read(wm8994, WM8994_GPIO_1 + offset);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret & WM8994_GPN_LVL)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int wm8994_gpio_direction_out(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct wm8994_gpio *wm8994_gpio = to_wm8994_gpio(chip);\r\nstruct wm8994 *wm8994 = wm8994_gpio->wm8994;\r\nreturn wm8994_set_bits(wm8994, WM8994_GPIO_1 + offset,\r\nWM8994_GPN_DIR, 0);\r\n}\r\nstatic void wm8994_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct wm8994_gpio *wm8994_gpio = to_wm8994_gpio(chip);\r\nstruct wm8994 *wm8994 = wm8994_gpio->wm8994;\r\nif (value)\r\nvalue = WM8994_GPN_LVL;\r\nwm8994_set_bits(wm8994, WM8994_GPIO_1 + offset, WM8994_GPN_LVL, value);\r\n}\r\nstatic int wm8994_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct wm8994_gpio *wm8994_gpio = to_wm8994_gpio(chip);\r\nstruct wm8994 *wm8994 = wm8994_gpio->wm8994;\r\nif (!wm8994->irq_base)\r\nreturn -EINVAL;\r\nreturn wm8994->irq_base + offset;\r\n}\r\nstatic const char *wm8994_gpio_fn(u16 fn)\r\n{\r\nswitch (fn) {\r\ncase WM8994_GP_FN_PIN_SPECIFIC:\r\nreturn "pin-specific";\r\ncase WM8994_GP_FN_GPIO:\r\nreturn "GPIO";\r\ncase WM8994_GP_FN_SDOUT:\r\nreturn "SDOUT";\r\ncase WM8994_GP_FN_IRQ:\r\nreturn "IRQ";\r\ncase WM8994_GP_FN_TEMPERATURE:\r\nreturn "Temperature";\r\ncase WM8994_GP_FN_MICBIAS1_DET:\r\nreturn "MICBIAS1 detect";\r\ncase WM8994_GP_FN_MICBIAS1_SHORT:\r\nreturn "MICBIAS1 short";\r\ncase WM8994_GP_FN_MICBIAS2_DET:\r\nreturn "MICBIAS2 detect";\r\ncase WM8994_GP_FN_MICBIAS2_SHORT:\r\nreturn "MICBIAS2 short";\r\ncase WM8994_GP_FN_FLL1_LOCK:\r\nreturn "FLL1 lock";\r\ncase WM8994_GP_FN_FLL2_LOCK:\r\nreturn "FLL2 lock";\r\ncase WM8994_GP_FN_SRC1_LOCK:\r\nreturn "SRC1 lock";\r\ncase WM8994_GP_FN_SRC2_LOCK:\r\nreturn "SRC2 lock";\r\ncase WM8994_GP_FN_DRC1_ACT:\r\nreturn "DRC1 activity";\r\ncase WM8994_GP_FN_DRC2_ACT:\r\nreturn "DRC2 activity";\r\ncase WM8994_GP_FN_DRC3_ACT:\r\nreturn "DRC3 activity";\r\ncase WM8994_GP_FN_WSEQ_STATUS:\r\nreturn "Write sequencer";\r\ncase WM8994_GP_FN_FIFO_ERROR:\r\nreturn "FIFO error";\r\ncase WM8994_GP_FN_OPCLK:\r\nreturn "OPCLK";\r\ncase WM8994_GP_FN_THW:\r\nreturn "Thermal warning";\r\ncase WM8994_GP_FN_DCS_DONE:\r\nreturn "DC servo";\r\ncase WM8994_GP_FN_FLL1_OUT:\r\nreturn "FLL1 output";\r\ncase WM8994_GP_FN_FLL2_OUT:\r\nreturn "FLL1 output";\r\ndefault:\r\nreturn "Unknown";\r\n}\r\n}\r\nstatic void wm8994_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\r\n{\r\nstruct wm8994_gpio *wm8994_gpio = to_wm8994_gpio(chip);\r\nstruct wm8994 *wm8994 = wm8994_gpio->wm8994;\r\nint i;\r\nfor (i = 0; i < chip->ngpio; i++) {\r\nint gpio = i + chip->base;\r\nint reg;\r\nconst char *label;\r\nlabel = gpiochip_is_requested(chip, i);\r\nif (!label)\r\nlabel = "Unrequested";\r\nseq_printf(s, " gpio-%-3d (%-20.20s) ", gpio, label);\r\nreg = wm8994_reg_read(wm8994, WM8994_GPIO_1 + i);\r\nif (reg < 0) {\r\ndev_err(wm8994->dev,\r\n"GPIO control %d read failed: %d\n",\r\ngpio, reg);\r\nseq_printf(s, "\n");\r\ncontinue;\r\n}\r\nif (reg & WM8994_GPN_DIR)\r\nseq_printf(s, "in ");\r\nelse\r\nseq_printf(s, "out ");\r\nif (reg & WM8994_GPN_PU)\r\nseq_printf(s, "pull up ");\r\nif (reg & WM8994_GPN_PD)\r\nseq_printf(s, "pull down ");\r\nif (reg & WM8994_GPN_POL)\r\nseq_printf(s, "inverted ");\r\nelse\r\nseq_printf(s, "noninverted ");\r\nif (reg & WM8994_GPN_OP_CFG)\r\nseq_printf(s, "open drain ");\r\nelse\r\nseq_printf(s, "CMOS ");\r\nseq_printf(s, "%s (%x)\n",\r\nwm8994_gpio_fn(reg & WM8994_GPN_FN_MASK), reg);\r\n}\r\n}\r\nstatic int __devinit wm8994_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct wm8994 *wm8994 = dev_get_drvdata(pdev->dev.parent);\r\nstruct wm8994_pdata *pdata = wm8994->dev->platform_data;\r\nstruct wm8994_gpio *wm8994_gpio;\r\nint ret;\r\nwm8994_gpio = kzalloc(sizeof(*wm8994_gpio), GFP_KERNEL);\r\nif (wm8994_gpio == NULL)\r\nreturn -ENOMEM;\r\nwm8994_gpio->wm8994 = wm8994;\r\nwm8994_gpio->gpio_chip = template_chip;\r\nwm8994_gpio->gpio_chip.ngpio = WM8994_GPIO_MAX;\r\nwm8994_gpio->gpio_chip.dev = &pdev->dev;\r\nif (pdata && pdata->gpio_base)\r\nwm8994_gpio->gpio_chip.base = pdata->gpio_base;\r\nelse\r\nwm8994_gpio->gpio_chip.base = -1;\r\nret = gpiochip_add(&wm8994_gpio->gpio_chip);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Could not register gpiochip, %d\n",\r\nret);\r\ngoto err;\r\n}\r\nplatform_set_drvdata(pdev, wm8994_gpio);\r\nreturn ret;\r\nerr:\r\nkfree(wm8994_gpio);\r\nreturn ret;\r\n}\r\nstatic int __devexit wm8994_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct wm8994_gpio *wm8994_gpio = platform_get_drvdata(pdev);\r\nint ret;\r\nret = gpiochip_remove(&wm8994_gpio->gpio_chip);\r\nif (ret == 0)\r\nkfree(wm8994_gpio);\r\nreturn ret;\r\n}\r\nstatic int __init wm8994_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&wm8994_gpio_driver);\r\n}\r\nstatic void __exit wm8994_gpio_exit(void)\r\n{\r\nplatform_driver_unregister(&wm8994_gpio_driver);\r\n}
