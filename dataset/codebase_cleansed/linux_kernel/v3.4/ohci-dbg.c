static void __maybe_unused\r\nurb_print(struct urb * urb, char * str, int small, int status)\r\n{\r\nunsigned int pipe= urb->pipe;\r\nif (!urb->dev || !urb->dev->bus) {\r\ndbg("%s URB: no dev", str);\r\nreturn;\r\n}\r\n#ifndef OHCI_VERBOSE_DEBUG\r\nif (status != 0)\r\n#endif\r\ndbg("%s %p dev=%d ep=%d%s-%s flags=%x len=%d/%d stat=%d",\r\nstr,\r\nurb,\r\nusb_pipedevice (pipe),\r\nusb_pipeendpoint (pipe),\r\nusb_pipeout (pipe)? "out" : "in",\r\npipestring (pipe),\r\nurb->transfer_flags,\r\nurb->actual_length,\r\nurb->transfer_buffer_length,\r\nstatus);\r\n#ifdef OHCI_VERBOSE_DEBUG\r\nif (!small) {\r\nint i, len;\r\nif (usb_pipecontrol (pipe)) {\r\nprintk (KERN_DEBUG "%s: setup(8):", __FILE__);\r\nfor (i = 0; i < 8 ; i++)\r\nprintk (" %02x", ((__u8 *) urb->setup_packet) [i]);\r\nprintk ("\n");\r\n}\r\nif (urb->transfer_buffer_length > 0 && urb->transfer_buffer) {\r\nprintk (KERN_DEBUG "%s: data(%d/%d):", __FILE__,\r\nurb->actual_length,\r\nurb->transfer_buffer_length);\r\nlen = usb_pipeout (pipe)?\r\nurb->transfer_buffer_length: urb->actual_length;\r\nfor (i = 0; i < 16 && i < len; i++)\r\nprintk (" %02x", ((__u8 *) urb->transfer_buffer) [i]);\r\nprintk ("%s stat:%d\n", i < len? "...": "", status);\r\n}\r\n}\r\n#endif\r\n}\r\nstatic void ohci_dump_intr_mask (\r\nstruct ohci_hcd *ohci,\r\nchar *label,\r\nu32 mask,\r\nchar **next,\r\nunsigned *size)\r\n{\r\nohci_dbg_sw (ohci, next, size, "%s 0x%08x%s%s%s%s%s%s%s%s%s\n",\r\nlabel,\r\nmask,\r\n(mask & OHCI_INTR_MIE) ? " MIE" : "",\r\n(mask & OHCI_INTR_OC) ? " OC" : "",\r\n(mask & OHCI_INTR_RHSC) ? " RHSC" : "",\r\n(mask & OHCI_INTR_FNO) ? " FNO" : "",\r\n(mask & OHCI_INTR_UE) ? " UE" : "",\r\n(mask & OHCI_INTR_RD) ? " RD" : "",\r\n(mask & OHCI_INTR_SF) ? " SF" : "",\r\n(mask & OHCI_INTR_WDH) ? " WDH" : "",\r\n(mask & OHCI_INTR_SO) ? " SO" : ""\r\n);\r\n}\r\nstatic void maybe_print_eds (\r\nstruct ohci_hcd *ohci,\r\nchar *label,\r\nu32 value,\r\nchar **next,\r\nunsigned *size)\r\n{\r\nif (value)\r\nohci_dbg_sw (ohci, next, size, "%s %08x\n", label, value);\r\n}\r\nstatic char *hcfs2string (int state)\r\n{\r\nswitch (state) {\r\ncase OHCI_USB_RESET: return "reset";\r\ncase OHCI_USB_RESUME: return "resume";\r\ncase OHCI_USB_OPER: return "operational";\r\ncase OHCI_USB_SUSPEND: return "suspend";\r\n}\r\nreturn "?";\r\n}\r\nstatic const char *rh_state_string(struct ohci_hcd *ohci)\r\n{\r\nswitch (ohci->rh_state) {\r\ncase OHCI_RH_HALTED:\r\nreturn "halted";\r\ncase OHCI_RH_SUSPENDED:\r\nreturn "suspended";\r\ncase OHCI_RH_RUNNING:\r\nreturn "running";\r\n}\r\nreturn "?";\r\n}\r\nstatic void\r\nohci_dump_status (struct ohci_hcd *controller, char **next, unsigned *size)\r\n{\r\nstruct ohci_regs __iomem *regs = controller->regs;\r\nu32 temp;\r\ntemp = ohci_readl (controller, &regs->revision) & 0xff;\r\nohci_dbg_sw (controller, next, size,\r\n"OHCI %d.%d, %s legacy support registers, rh state %s\n",\r\n0x03 & (temp >> 4), (temp & 0x0f),\r\n(temp & 0x0100) ? "with" : "NO",\r\nrh_state_string(controller));\r\ntemp = ohci_readl (controller, &regs->control);\r\nohci_dbg_sw (controller, next, size,\r\n"control 0x%03x%s%s%s HCFS=%s%s%s%s%s CBSR=%d\n",\r\ntemp,\r\n(temp & OHCI_CTRL_RWE) ? " RWE" : "",\r\n(temp & OHCI_CTRL_RWC) ? " RWC" : "",\r\n(temp & OHCI_CTRL_IR) ? " IR" : "",\r\nhcfs2string (temp & OHCI_CTRL_HCFS),\r\n(temp & OHCI_CTRL_BLE) ? " BLE" : "",\r\n(temp & OHCI_CTRL_CLE) ? " CLE" : "",\r\n(temp & OHCI_CTRL_IE) ? " IE" : "",\r\n(temp & OHCI_CTRL_PLE) ? " PLE" : "",\r\ntemp & OHCI_CTRL_CBSR\r\n);\r\ntemp = ohci_readl (controller, &regs->cmdstatus);\r\nohci_dbg_sw (controller, next, size,\r\n"cmdstatus 0x%05x SOC=%d%s%s%s%s\n", temp,\r\n(temp & OHCI_SOC) >> 16,\r\n(temp & OHCI_OCR) ? " OCR" : "",\r\n(temp & OHCI_BLF) ? " BLF" : "",\r\n(temp & OHCI_CLF) ? " CLF" : "",\r\n(temp & OHCI_HCR) ? " HCR" : ""\r\n);\r\nohci_dump_intr_mask (controller, "intrstatus",\r\nohci_readl (controller, &regs->intrstatus),\r\nnext, size);\r\nohci_dump_intr_mask (controller, "intrenable",\r\nohci_readl (controller, &regs->intrenable),\r\nnext, size);\r\nmaybe_print_eds (controller, "ed_periodcurrent",\r\nohci_readl (controller, &regs->ed_periodcurrent),\r\nnext, size);\r\nmaybe_print_eds (controller, "ed_controlhead",\r\nohci_readl (controller, &regs->ed_controlhead),\r\nnext, size);\r\nmaybe_print_eds (controller, "ed_controlcurrent",\r\nohci_readl (controller, &regs->ed_controlcurrent),\r\nnext, size);\r\nmaybe_print_eds (controller, "ed_bulkhead",\r\nohci_readl (controller, &regs->ed_bulkhead),\r\nnext, size);\r\nmaybe_print_eds (controller, "ed_bulkcurrent",\r\nohci_readl (controller, &regs->ed_bulkcurrent),\r\nnext, size);\r\nmaybe_print_eds (controller, "donehead",\r\nohci_readl (controller, &regs->donehead), next, size);\r\n}\r\nstatic void\r\nohci_dump_roothub (\r\nstruct ohci_hcd *controller,\r\nint verbose,\r\nchar **next,\r\nunsigned *size)\r\n{\r\nu32 temp, i;\r\ntemp = roothub_a (controller);\r\nif (temp == ~(u32)0)\r\nreturn;\r\nif (verbose) {\r\nohci_dbg_sw (controller, next, size,\r\n"roothub.a %08x POTPGT=%d%s%s%s%s%s NDP=%d(%d)\n", temp,\r\n((temp & RH_A_POTPGT) >> 24) & 0xff,\r\n(temp & RH_A_NOCP) ? " NOCP" : "",\r\n(temp & RH_A_OCPM) ? " OCPM" : "",\r\n(temp & RH_A_DT) ? " DT" : "",\r\n(temp & RH_A_NPS) ? " NPS" : "",\r\n(temp & RH_A_PSM) ? " PSM" : "",\r\n(temp & RH_A_NDP), controller->num_ports\r\n);\r\ntemp = roothub_b (controller);\r\nohci_dbg_sw (controller, next, size,\r\n"roothub.b %08x PPCM=%04x DR=%04x\n",\r\ntemp,\r\n(temp & RH_B_PPCM) >> 16,\r\n(temp & RH_B_DR)\r\n);\r\ntemp = roothub_status (controller);\r\nohci_dbg_sw (controller, next, size,\r\n"roothub.status %08x%s%s%s%s%s%s\n",\r\ntemp,\r\n(temp & RH_HS_CRWE) ? " CRWE" : "",\r\n(temp & RH_HS_OCIC) ? " OCIC" : "",\r\n(temp & RH_HS_LPSC) ? " LPSC" : "",\r\n(temp & RH_HS_DRWE) ? " DRWE" : "",\r\n(temp & RH_HS_OCI) ? " OCI" : "",\r\n(temp & RH_HS_LPS) ? " LPS" : ""\r\n);\r\n}\r\nfor (i = 0; i < controller->num_ports; i++) {\r\ntemp = roothub_portstatus (controller, i);\r\ndbg_port_sw (controller, i, temp, next, size);\r\n}\r\n}\r\nstatic void ohci_dump (struct ohci_hcd *controller, int verbose)\r\n{\r\nohci_dbg (controller, "OHCI controller state\n");\r\nohci_dump_status (controller, NULL, NULL);\r\nif (controller->hcca)\r\nohci_dbg (controller,\r\n"hcca frame #%04x\n", ohci_frame_no(controller));\r\nohci_dump_roothub (controller, 1, NULL, NULL);\r\n}\r\nstatic void ohci_dump_td (const struct ohci_hcd *ohci, const char *label,\r\nconst struct td *td)\r\n{\r\nu32 tmp = hc32_to_cpup (ohci, &td->hwINFO);\r\nohci_dbg (ohci, "%s td %p%s; urb %p index %d; hw next td %08x\n",\r\nlabel, td,\r\n(tmp & TD_DONE) ? " (DONE)" : "",\r\ntd->urb, td->index,\r\nhc32_to_cpup (ohci, &td->hwNextTD));\r\nif ((tmp & TD_ISO) == 0) {\r\nconst char *toggle, *pid;\r\nu32 cbp, be;\r\nswitch (tmp & TD_T) {\r\ncase TD_T_DATA0: toggle = data0; break;\r\ncase TD_T_DATA1: toggle = data1; break;\r\ncase TD_T_TOGGLE: toggle = "(CARRY)"; break;\r\ndefault: toggle = "(?)"; break;\r\n}\r\nswitch (tmp & TD_DP) {\r\ncase TD_DP_SETUP: pid = "SETUP"; break;\r\ncase TD_DP_IN: pid = "IN"; break;\r\ncase TD_DP_OUT: pid = "OUT"; break;\r\ndefault: pid = "(bad pid)"; break;\r\n}\r\nohci_dbg (ohci, " info %08x CC=%x %s DI=%d %s %s\n", tmp,\r\nTD_CC_GET(tmp), toggle,\r\n(tmp & TD_DI) >> 21, pid,\r\n(tmp & TD_R) ? "R" : "");\r\ncbp = hc32_to_cpup (ohci, &td->hwCBP);\r\nbe = hc32_to_cpup (ohci, &td->hwBE);\r\nohci_dbg (ohci, " cbp %08x be %08x (len %d)\n", cbp, be,\r\ncbp ? (be + 1 - cbp) : 0);\r\n} else {\r\nunsigned i;\r\nohci_dbg (ohci, " info %08x CC=%x FC=%d DI=%d SF=%04x\n", tmp,\r\nTD_CC_GET(tmp),\r\n(tmp >> 24) & 0x07,\r\n(tmp & TD_DI) >> 21,\r\ntmp & 0x0000ffff);\r\nohci_dbg (ohci, " bp0 %08x be %08x\n",\r\nhc32_to_cpup (ohci, &td->hwCBP) & ~0x0fff,\r\nhc32_to_cpup (ohci, &td->hwBE));\r\nfor (i = 0; i < MAXPSW; i++) {\r\nu16 psw = ohci_hwPSW (ohci, td, i);\r\nint cc = (psw >> 12) & 0x0f;\r\nohci_dbg (ohci, " psw [%d] = %2x, CC=%x %s=%d\n", i,\r\npsw, cc,\r\n(cc >= 0x0e) ? "OFFSET" : "SIZE",\r\npsw & 0x0fff);\r\n}\r\n}\r\n}\r\nstatic void __maybe_unused\r\nohci_dump_ed (const struct ohci_hcd *ohci, const char *label,\r\nconst struct ed *ed, int verbose)\r\n{\r\nu32 tmp = hc32_to_cpu (ohci, ed->hwINFO);\r\nchar *type = "";\r\nohci_dbg (ohci, "%s, ed %p state 0x%x type %s; next ed %08x\n",\r\nlabel,\r\ned, ed->state, edstring (ed->type),\r\nhc32_to_cpup (ohci, &ed->hwNextED));\r\nswitch (tmp & (ED_IN|ED_OUT)) {\r\ncase ED_OUT: type = "-OUT"; break;\r\ncase ED_IN: type = "-IN"; break;\r\n}\r\nohci_dbg (ohci,\r\n" info %08x MAX=%d%s%s%s%s EP=%d%s DEV=%d\n", tmp,\r\n0x03ff & (tmp >> 16),\r\n(tmp & ED_DEQUEUE) ? " DQ" : "",\r\n(tmp & ED_ISO) ? " ISO" : "",\r\n(tmp & ED_SKIP) ? " SKIP" : "",\r\n(tmp & ED_LOWSPEED) ? " LOW" : "",\r\n0x000f & (tmp >> 7),\r\ntype,\r\n0x007f & tmp);\r\ntmp = hc32_to_cpup (ohci, &ed->hwHeadP);\r\nohci_dbg (ohci, " tds: head %08x %s%s tail %08x%s\n",\r\ntmp,\r\n(tmp & ED_C) ? data1 : data0,\r\n(tmp & ED_H) ? " HALT" : "",\r\nhc32_to_cpup (ohci, &ed->hwTailP),\r\nverbose ? "" : " (not listing)");\r\nif (verbose) {\r\nstruct list_head *tmp;\r\nlist_for_each (tmp, &ed->td_list) {\r\nstruct td *td;\r\ntd = list_entry (tmp, struct td, td_list);\r\nohci_dump_td (ohci, " ->", td);\r\n}\r\n}\r\n}\r\nstatic inline void ohci_dump (struct ohci_hcd *controller, int verbose) {}\r\nstatic inline void create_debug_files (struct ohci_hcd *bus) { }\r\nstatic inline void remove_debug_files (struct ohci_hcd *bus) { }\r\nstatic ssize_t\r\nshow_list (struct ohci_hcd *ohci, char *buf, size_t count, struct ed *ed)\r\n{\r\nunsigned temp, size = count;\r\nif (!ed)\r\nreturn 0;\r\nwhile (ed->ed_prev)\r\ned = ed->ed_prev;\r\nwhile (ed) {\r\nu32 info = hc32_to_cpu (ohci, ed->hwINFO);\r\nu32 headp = hc32_to_cpu (ohci, ed->hwHeadP);\r\nstruct list_head *entry;\r\nstruct td *td;\r\ntemp = scnprintf (buf, size,\r\n"ed/%p %cs dev%d ep%d%s max %d %08x%s%s %s",\r\ned,\r\n(info & ED_LOWSPEED) ? 'l' : 'f',\r\ninfo & 0x7f,\r\n(info >> 7) & 0xf,\r\n(info & ED_IN) ? "in" : "out",\r\n0x03ff & (info >> 16),\r\ninfo,\r\n(info & ED_SKIP) ? " s" : "",\r\n(headp & ED_H) ? " H" : "",\r\n(headp & ED_C) ? data1 : data0);\r\nsize -= temp;\r\nbuf += temp;\r\nlist_for_each (entry, &ed->td_list) {\r\nu32 cbp, be;\r\ntd = list_entry (entry, struct td, td_list);\r\ninfo = hc32_to_cpup (ohci, &td->hwINFO);\r\ncbp = hc32_to_cpup (ohci, &td->hwCBP);\r\nbe = hc32_to_cpup (ohci, &td->hwBE);\r\ntemp = scnprintf (buf, size,\r\n"\n\ttd %p %s %d cc=%x urb %p (%08x)",\r\ntd,\r\n({ char *pid;\r\nswitch (info & TD_DP) {\r\ncase TD_DP_SETUP: pid = "setup"; break;\r\ncase TD_DP_IN: pid = "in"; break;\r\ncase TD_DP_OUT: pid = "out"; break;\r\ndefault: pid = "(?)"; break;\r\n} pid;}),\r\ncbp ? (be + 1 - cbp) : 0,\r\nTD_CC_GET (info), td->urb, info);\r\nsize -= temp;\r\nbuf += temp;\r\n}\r\ntemp = scnprintf (buf, size, "\n");\r\nsize -= temp;\r\nbuf += temp;\r\ned = ed->ed_next;\r\n}\r\nreturn count - size;\r\n}\r\nstatic ssize_t fill_async_buffer(struct debug_buffer *buf)\r\n{\r\nstruct ohci_hcd *ohci;\r\nsize_t temp;\r\nunsigned long flags;\r\nohci = buf->ohci;\r\nspin_lock_irqsave (&ohci->lock, flags);\r\ntemp = show_list(ohci, buf->page, buf->count, ohci->ed_controltail);\r\ntemp += show_list(ohci, buf->page + temp, buf->count - temp,\r\nohci->ed_bulktail);\r\nspin_unlock_irqrestore (&ohci->lock, flags);\r\nreturn temp;\r\n}\r\nstatic ssize_t fill_periodic_buffer(struct debug_buffer *buf)\r\n{\r\nstruct ohci_hcd *ohci;\r\nstruct ed **seen, *ed;\r\nunsigned long flags;\r\nunsigned temp, size, seen_count;\r\nchar *next;\r\nunsigned i;\r\nif (!(seen = kmalloc (DBG_SCHED_LIMIT * sizeof *seen, GFP_ATOMIC)))\r\nreturn 0;\r\nseen_count = 0;\r\nohci = buf->ohci;\r\nnext = buf->page;\r\nsize = PAGE_SIZE;\r\ntemp = scnprintf (next, size, "size = %d\n", NUM_INTS);\r\nsize -= temp;\r\nnext += temp;\r\nspin_lock_irqsave (&ohci->lock, flags);\r\nfor (i = 0; i < NUM_INTS; i++) {\r\nif (!(ed = ohci->periodic [i]))\r\ncontinue;\r\ntemp = scnprintf (next, size, "%2d [%3d]:", i, ohci->load [i]);\r\nsize -= temp;\r\nnext += temp;\r\ndo {\r\ntemp = scnprintf (next, size, " ed%d/%p",\r\ned->interval, ed);\r\nsize -= temp;\r\nnext += temp;\r\nfor (temp = 0; temp < seen_count; temp++) {\r\nif (seen [temp] == ed)\r\nbreak;\r\n}\r\nif (temp == seen_count) {\r\nu32 info = hc32_to_cpu (ohci, ed->hwINFO);\r\nstruct list_head *entry;\r\nunsigned qlen = 0;\r\nlist_for_each (entry, &ed->td_list)\r\nqlen++;\r\ntemp = scnprintf (next, size,\r\n" (%cs dev%d ep%d%s-%s qlen %u"\r\n" max %d %08x%s%s)",\r\n(info & ED_LOWSPEED) ? 'l' : 'f',\r\ninfo & 0x7f,\r\n(info >> 7) & 0xf,\r\n(info & ED_IN) ? "in" : "out",\r\n(info & ED_ISO) ? "iso" : "int",\r\nqlen,\r\n0x03ff & (info >> 16),\r\ninfo,\r\n(info & ED_SKIP) ? " K" : "",\r\n(ed->hwHeadP &\r\ncpu_to_hc32(ohci, ED_H)) ?\r\n" H" : "");\r\nsize -= temp;\r\nnext += temp;\r\nif (seen_count < DBG_SCHED_LIMIT)\r\nseen [seen_count++] = ed;\r\ned = ed->ed_next;\r\n} else {\r\ntemp = 0;\r\ned = NULL;\r\n}\r\n} while (ed);\r\ntemp = scnprintf (next, size, "\n");\r\nsize -= temp;\r\nnext += temp;\r\n}\r\nspin_unlock_irqrestore (&ohci->lock, flags);\r\nkfree (seen);\r\nreturn PAGE_SIZE - size;\r\n}\r\nstatic ssize_t fill_registers_buffer(struct debug_buffer *buf)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct ohci_hcd *ohci;\r\nstruct ohci_regs __iomem *regs;\r\nunsigned long flags;\r\nunsigned temp, size;\r\nchar *next;\r\nu32 rdata;\r\nohci = buf->ohci;\r\nhcd = ohci_to_hcd(ohci);\r\nregs = ohci->regs;\r\nnext = buf->page;\r\nsize = PAGE_SIZE;\r\nspin_lock_irqsave (&ohci->lock, flags);\r\nohci_dbg_nosw(ohci, &next, &size,\r\n"bus %s, device %s\n"\r\n"%s\n"\r\n"%s\n",\r\nhcd->self.controller->bus->name,\r\ndev_name(hcd->self.controller),\r\nhcd->product_desc,\r\nhcd_name);\r\nif (!HCD_HW_ACCESSIBLE(hcd)) {\r\nsize -= scnprintf (next, size,\r\n"SUSPENDED (no register access)\n");\r\ngoto done;\r\n}\r\nohci_dump_status(ohci, &next, &size);\r\nif (ohci->hcca)\r\nohci_dbg_nosw(ohci, &next, &size,\r\n"hcca frame 0x%04x\n", ohci_frame_no(ohci));\r\nrdata = ohci_readl (ohci, &regs->fminterval);\r\ntemp = scnprintf (next, size,\r\n"fmintvl 0x%08x %sFSMPS=0x%04x FI=0x%04x\n",\r\nrdata, (rdata >> 31) ? "FIT " : "",\r\n(rdata >> 16) & 0xefff, rdata & 0xffff);\r\nsize -= temp;\r\nnext += temp;\r\nrdata = ohci_readl (ohci, &regs->fmremaining);\r\ntemp = scnprintf (next, size, "fmremaining 0x%08x %sFR=0x%04x\n",\r\nrdata, (rdata >> 31) ? "FRT " : "",\r\nrdata & 0x3fff);\r\nsize -= temp;\r\nnext += temp;\r\nrdata = ohci_readl (ohci, &regs->periodicstart);\r\ntemp = scnprintf (next, size, "periodicstart 0x%04x\n",\r\nrdata & 0x3fff);\r\nsize -= temp;\r\nnext += temp;\r\nrdata = ohci_readl (ohci, &regs->lsthresh);\r\ntemp = scnprintf (next, size, "lsthresh 0x%04x\n",\r\nrdata & 0x3fff);\r\nsize -= temp;\r\nnext += temp;\r\ntemp = scnprintf (next, size, "hub poll timer %s\n",\r\nHCD_POLL_RH(ohci_to_hcd(ohci)) ? "ON" : "off");\r\nsize -= temp;\r\nnext += temp;\r\nohci_dump_roothub (ohci, 1, &next, &size);\r\ndone:\r\nspin_unlock_irqrestore (&ohci->lock, flags);\r\nreturn PAGE_SIZE - size;\r\n}\r\nstatic struct debug_buffer *alloc_buffer(struct ohci_hcd *ohci,\r\nssize_t (*fill_func)(struct debug_buffer *))\r\n{\r\nstruct debug_buffer *buf;\r\nbuf = kzalloc(sizeof(struct debug_buffer), GFP_KERNEL);\r\nif (buf) {\r\nbuf->ohci = ohci;\r\nbuf->fill_func = fill_func;\r\nmutex_init(&buf->mutex);\r\n}\r\nreturn buf;\r\n}\r\nstatic int fill_buffer(struct debug_buffer *buf)\r\n{\r\nint ret = 0;\r\nif (!buf->page)\r\nbuf->page = (char *)get_zeroed_page(GFP_KERNEL);\r\nif (!buf->page) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = buf->fill_func(buf);\r\nif (ret >= 0) {\r\nbuf->count = ret;\r\nret = 0;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t debug_output(struct file *file, char __user *user_buf,\r\nsize_t len, loff_t *offset)\r\n{\r\nstruct debug_buffer *buf = file->private_data;\r\nint ret = 0;\r\nmutex_lock(&buf->mutex);\r\nif (buf->count == 0) {\r\nret = fill_buffer(buf);\r\nif (ret != 0) {\r\nmutex_unlock(&buf->mutex);\r\ngoto out;\r\n}\r\n}\r\nmutex_unlock(&buf->mutex);\r\nret = simple_read_from_buffer(user_buf, len, offset,\r\nbuf->page, buf->count);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int debug_close(struct inode *inode, struct file *file)\r\n{\r\nstruct debug_buffer *buf = file->private_data;\r\nif (buf) {\r\nif (buf->page)\r\nfree_page((unsigned long)buf->page);\r\nkfree(buf);\r\n}\r\nreturn 0;\r\n}\r\nstatic int debug_async_open(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = alloc_buffer(inode->i_private, fill_async_buffer);\r\nreturn file->private_data ? 0 : -ENOMEM;\r\n}\r\nstatic int debug_periodic_open(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = alloc_buffer(inode->i_private,\r\nfill_periodic_buffer);\r\nreturn file->private_data ? 0 : -ENOMEM;\r\n}\r\nstatic int debug_registers_open(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = alloc_buffer(inode->i_private,\r\nfill_registers_buffer);\r\nreturn file->private_data ? 0 : -ENOMEM;\r\n}\r\nstatic inline void create_debug_files (struct ohci_hcd *ohci)\r\n{\r\nstruct usb_bus *bus = &ohci_to_hcd(ohci)->self;\r\nohci->debug_dir = debugfs_create_dir(bus->bus_name, ohci_debug_root);\r\nif (!ohci->debug_dir)\r\ngoto dir_error;\r\nohci->debug_async = debugfs_create_file("async", S_IRUGO,\r\nohci->debug_dir, ohci,\r\n&debug_async_fops);\r\nif (!ohci->debug_async)\r\ngoto async_error;\r\nohci->debug_periodic = debugfs_create_file("periodic", S_IRUGO,\r\nohci->debug_dir, ohci,\r\n&debug_periodic_fops);\r\nif (!ohci->debug_periodic)\r\ngoto periodic_error;\r\nohci->debug_registers = debugfs_create_file("registers", S_IRUGO,\r\nohci->debug_dir, ohci,\r\n&debug_registers_fops);\r\nif (!ohci->debug_registers)\r\ngoto registers_error;\r\nohci_dbg (ohci, "created debug files\n");\r\nreturn;\r\nregisters_error:\r\ndebugfs_remove(ohci->debug_periodic);\r\nperiodic_error:\r\ndebugfs_remove(ohci->debug_async);\r\nasync_error:\r\ndebugfs_remove(ohci->debug_dir);\r\ndir_error:\r\nohci->debug_periodic = NULL;\r\nohci->debug_async = NULL;\r\nohci->debug_dir = NULL;\r\n}\r\nstatic inline void remove_debug_files (struct ohci_hcd *ohci)\r\n{\r\ndebugfs_remove(ohci->debug_registers);\r\ndebugfs_remove(ohci->debug_periodic);\r\ndebugfs_remove(ohci->debug_async);\r\ndebugfs_remove(ohci->debug_dir);\r\n}
