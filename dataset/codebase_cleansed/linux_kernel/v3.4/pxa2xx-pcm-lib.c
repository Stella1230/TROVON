int __pxa2xx_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct pxa2xx_runtime_data *rtd = runtime->private_data;\r\nsize_t totsize = params_buffer_bytes(params);\r\nsize_t period = params_period_bytes(params);\r\npxa_dma_desc *dma_desc;\r\ndma_addr_t dma_buff_phys, next_desc_phys;\r\nsnd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);\r\nruntime->dma_bytes = totsize;\r\ndma_desc = rtd->dma_desc_array;\r\nnext_desc_phys = rtd->dma_desc_array_phys;\r\ndma_buff_phys = runtime->dma_addr;\r\ndo {\r\nnext_desc_phys += sizeof(pxa_dma_desc);\r\ndma_desc->ddadr = next_desc_phys;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\ndma_desc->dsadr = dma_buff_phys;\r\ndma_desc->dtadr = rtd->params->dev_addr;\r\n} else {\r\ndma_desc->dsadr = rtd->params->dev_addr;\r\ndma_desc->dtadr = dma_buff_phys;\r\n}\r\nif (period > totsize)\r\nperiod = totsize;\r\ndma_desc->dcmd = rtd->params->dcmd | period | DCMD_ENDIRQEN;\r\ndma_desc++;\r\ndma_buff_phys += period;\r\n} while (totsize -= period);\r\ndma_desc[-1].ddadr = rtd->dma_desc_array_phys;\r\nreturn 0;\r\n}\r\nint __pxa2xx_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct pxa2xx_runtime_data *rtd = substream->runtime->private_data;\r\nif (rtd && rtd->params && rtd->params->drcmr)\r\n*rtd->params->drcmr = 0;\r\nsnd_pcm_set_runtime_buffer(substream, NULL);\r\nreturn 0;\r\n}\r\nint pxa2xx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct pxa2xx_runtime_data *prtd = substream->runtime->private_data;\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nDDADR(prtd->dma_ch) = prtd->dma_desc_array_phys;\r\nDCSR(prtd->dma_ch) = DCSR_RUN;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nDCSR(prtd->dma_ch) &= ~DCSR_RUN;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nDCSR(prtd->dma_ch) |= DCSR_RUN;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nDDADR(prtd->dma_ch) = prtd->dma_desc_array_phys;\r\nDCSR(prtd->dma_ch) |= DCSR_RUN;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nsnd_pcm_uframes_t\r\npxa2xx_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct pxa2xx_runtime_data *prtd = runtime->private_data;\r\ndma_addr_t ptr = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?\r\nDSADR(prtd->dma_ch) : DTADR(prtd->dma_ch);\r\nsnd_pcm_uframes_t x = bytes_to_frames(runtime, ptr - runtime->dma_addr);\r\nif (x == runtime->buffer_size)\r\nx = 0;\r\nreturn x;\r\n}\r\nint __pxa2xx_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct pxa2xx_runtime_data *prtd = substream->runtime->private_data;\r\nif (!prtd || !prtd->params)\r\nreturn 0;\r\nif (prtd->dma_ch == -1)\r\nreturn -EINVAL;\r\nDCSR(prtd->dma_ch) &= ~DCSR_RUN;\r\nDCSR(prtd->dma_ch) = 0;\r\nDCMD(prtd->dma_ch) = 0;\r\n*prtd->params->drcmr = prtd->dma_ch | DRCMR_MAPVLD;\r\nreturn 0;\r\n}\r\nvoid pxa2xx_pcm_dma_irq(int dma_ch, void *dev_id)\r\n{\r\nstruct snd_pcm_substream *substream = dev_id;\r\nstruct pxa2xx_runtime_data *rtd = substream->runtime->private_data;\r\nint dcsr;\r\ndcsr = DCSR(dma_ch);\r\nDCSR(dma_ch) = dcsr & ~DCSR_STOPIRQEN;\r\nif (dcsr & DCSR_ENDINTR) {\r\nsnd_pcm_period_elapsed(substream);\r\n} else {\r\nprintk(KERN_ERR "%s: DMA error on channel %d (DCSR=%#x)\n",\r\nrtd->params->name, dma_ch, dcsr);\r\nsnd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);\r\n}\r\n}\r\nint __pxa2xx_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct pxa2xx_runtime_data *rtd;\r\nint ret;\r\nruntime->hw = pxa2xx_pcm_hardware;\r\nret = snd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_BYTES, 32);\r\nif (ret)\r\ngoto out;\r\nret = snd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_BUFFER_BYTES, 32);\r\nif (ret)\r\ngoto out;\r\nret = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (ret < 0)\r\ngoto out;\r\nret = -ENOMEM;\r\nrtd = kzalloc(sizeof(*rtd), GFP_KERNEL);\r\nif (!rtd)\r\ngoto out;\r\nrtd->dma_desc_array =\r\ndma_alloc_writecombine(substream->pcm->card->dev, PAGE_SIZE,\r\n&rtd->dma_desc_array_phys, GFP_KERNEL);\r\nif (!rtd->dma_desc_array)\r\ngoto err1;\r\nrtd->dma_ch = -1;\r\nruntime->private_data = rtd;\r\nreturn 0;\r\nerr1:\r\nkfree(rtd);\r\nout:\r\nreturn ret;\r\n}\r\nint __pxa2xx_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct pxa2xx_runtime_data *rtd = runtime->private_data;\r\ndma_free_writecombine(substream->pcm->card->dev, PAGE_SIZE,\r\nrtd->dma_desc_array, rtd->dma_desc_array_phys);\r\nkfree(rtd);\r\nreturn 0;\r\n}\r\nint pxa2xx_pcm_mmap(struct snd_pcm_substream *substream,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nreturn dma_mmap_writecombine(substream->pcm->card->dev, vma,\r\nruntime->dma_area,\r\nruntime->dma_addr,\r\nruntime->dma_bytes);\r\n}\r\nint pxa2xx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)\r\n{\r\nstruct snd_pcm_substream *substream = pcm->streams[stream].substream;\r\nstruct snd_dma_buffer *buf = &substream->dma_buffer;\r\nsize_t size = pxa2xx_pcm_hardware.buffer_bytes_max;\r\nbuf->dev.type = SNDRV_DMA_TYPE_DEV;\r\nbuf->dev.dev = pcm->card->dev;\r\nbuf->private_data = NULL;\r\nbuf->area = dma_alloc_writecombine(pcm->card->dev, size,\r\n&buf->addr, GFP_KERNEL);\r\nif (!buf->area)\r\nreturn -ENOMEM;\r\nbuf->bytes = size;\r\nreturn 0;\r\n}\r\nvoid pxa2xx_pcm_free_dma_buffers(struct snd_pcm *pcm)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_dma_buffer *buf;\r\nint stream;\r\nfor (stream = 0; stream < 2; stream++) {\r\nsubstream = pcm->streams[stream].substream;\r\nif (!substream)\r\ncontinue;\r\nbuf = &substream->dma_buffer;\r\nif (!buf->area)\r\ncontinue;\r\ndma_free_writecombine(pcm->card->dev, buf->bytes,\r\nbuf->area, buf->addr);\r\nbuf->area = NULL;\r\n}\r\n}
