static void\r\nxt_socket_put_sk(struct sock *sk)\r\n{\r\nif (sk->sk_state == TCP_TIME_WAIT)\r\ninet_twsk_put(inet_twsk(sk));\r\nelse\r\nsock_put(sk);\r\n}\r\nstatic int\r\nextract_icmp4_fields(const struct sk_buff *skb,\r\nu8 *protocol,\r\n__be32 *raddr,\r\n__be32 *laddr,\r\n__be16 *rport,\r\n__be16 *lport)\r\n{\r\nunsigned int outside_hdrlen = ip_hdrlen(skb);\r\nstruct iphdr *inside_iph, _inside_iph;\r\nstruct icmphdr *icmph, _icmph;\r\n__be16 *ports, _ports[2];\r\nicmph = skb_header_pointer(skb, outside_hdrlen,\r\nsizeof(_icmph), &_icmph);\r\nif (icmph == NULL)\r\nreturn 1;\r\nswitch (icmph->type) {\r\ncase ICMP_DEST_UNREACH:\r\ncase ICMP_SOURCE_QUENCH:\r\ncase ICMP_REDIRECT:\r\ncase ICMP_TIME_EXCEEDED:\r\ncase ICMP_PARAMETERPROB:\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\ninside_iph = skb_header_pointer(skb, outside_hdrlen +\r\nsizeof(struct icmphdr),\r\nsizeof(_inside_iph), &_inside_iph);\r\nif (inside_iph == NULL)\r\nreturn 1;\r\nif (inside_iph->protocol != IPPROTO_TCP &&\r\ninside_iph->protocol != IPPROTO_UDP)\r\nreturn 1;\r\nports = skb_header_pointer(skb, outside_hdrlen +\r\nsizeof(struct icmphdr) +\r\n(inside_iph->ihl << 2),\r\nsizeof(_ports), &_ports);\r\nif (ports == NULL)\r\nreturn 1;\r\n*protocol = inside_iph->protocol;\r\n*laddr = inside_iph->saddr;\r\n*lport = ports[0];\r\n*raddr = inside_iph->daddr;\r\n*rport = ports[1];\r\nreturn 0;\r\n}\r\nstatic bool\r\nsocket_match(const struct sk_buff *skb, struct xt_action_param *par,\r\nconst struct xt_socket_mtinfo1 *info)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nstruct udphdr _hdr, *hp = NULL;\r\nstruct sock *sk;\r\n__be32 daddr, saddr;\r\n__be16 dport, sport;\r\nu8 protocol;\r\n#ifdef XT_SOCKET_HAVE_CONNTRACK\r\nstruct nf_conn const *ct;\r\nenum ip_conntrack_info ctinfo;\r\n#endif\r\nif (iph->protocol == IPPROTO_UDP || iph->protocol == IPPROTO_TCP) {\r\nhp = skb_header_pointer(skb, ip_hdrlen(skb),\r\nsizeof(_hdr), &_hdr);\r\nif (hp == NULL)\r\nreturn false;\r\nprotocol = iph->protocol;\r\nsaddr = iph->saddr;\r\nsport = hp->source;\r\ndaddr = iph->daddr;\r\ndport = hp->dest;\r\n} else if (iph->protocol == IPPROTO_ICMP) {\r\nif (extract_icmp4_fields(skb, &protocol, &saddr, &daddr,\r\n&sport, &dport))\r\nreturn false;\r\n} else {\r\nreturn false;\r\n}\r\n#ifdef XT_SOCKET_HAVE_CONNTRACK\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (ct && !nf_ct_is_untracked(ct) &&\r\n((iph->protocol != IPPROTO_ICMP &&\r\nctinfo == IP_CT_ESTABLISHED_REPLY) ||\r\n(iph->protocol == IPPROTO_ICMP &&\r\nctinfo == IP_CT_RELATED_REPLY)) &&\r\n(ct->status & IPS_SRC_NAT_DONE)) {\r\ndaddr = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;\r\ndport = (iph->protocol == IPPROTO_TCP) ?\r\nct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.tcp.port :\r\nct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.udp.port;\r\n}\r\n#endif\r\nsk = nf_tproxy_get_sock_v4(dev_net(skb->dev), protocol,\r\nsaddr, daddr, sport, dport, par->in, NFT_LOOKUP_ANY);\r\nif (sk != NULL) {\r\nbool wildcard;\r\nbool transparent = true;\r\nwildcard = (sk->sk_state != TCP_TIME_WAIT &&\r\ninet_sk(sk)->inet_rcv_saddr == 0);\r\nif (info && info->flags & XT_SOCKET_TRANSPARENT)\r\ntransparent = ((sk->sk_state != TCP_TIME_WAIT &&\r\ninet_sk(sk)->transparent) ||\r\n(sk->sk_state == TCP_TIME_WAIT &&\r\ninet_twsk(sk)->tw_transparent));\r\nxt_socket_put_sk(sk);\r\nif (wildcard || !transparent)\r\nsk = NULL;\r\n}\r\npr_debug("proto %hhu %pI4:%hu -> %pI4:%hu (orig %pI4:%hu) sock %p\n",\r\nprotocol, &saddr, ntohs(sport),\r\n&daddr, ntohs(dport),\r\n&iph->daddr, hp ? ntohs(hp->dest) : 0, sk);\r\nreturn (sk != NULL);\r\n}\r\nstatic bool\r\nsocket_mt4_v0(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nreturn socket_match(skb, par, NULL);\r\n}\r\nstatic bool\r\nsocket_mt4_v1(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nreturn socket_match(skb, par, par->matchinfo);\r\n}\r\nstatic int\r\nextract_icmp6_fields(const struct sk_buff *skb,\r\nunsigned int outside_hdrlen,\r\nint *protocol,\r\nstruct in6_addr **raddr,\r\nstruct in6_addr **laddr,\r\n__be16 *rport,\r\n__be16 *lport)\r\n{\r\nstruct ipv6hdr *inside_iph, _inside_iph;\r\nstruct icmp6hdr *icmph, _icmph;\r\n__be16 *ports, _ports[2];\r\nu8 inside_nexthdr;\r\n__be16 inside_fragoff;\r\nint inside_hdrlen;\r\nicmph = skb_header_pointer(skb, outside_hdrlen,\r\nsizeof(_icmph), &_icmph);\r\nif (icmph == NULL)\r\nreturn 1;\r\nif (icmph->icmp6_type & ICMPV6_INFOMSG_MASK)\r\nreturn 1;\r\ninside_iph = skb_header_pointer(skb, outside_hdrlen + sizeof(_icmph), sizeof(_inside_iph), &_inside_iph);\r\nif (inside_iph == NULL)\r\nreturn 1;\r\ninside_nexthdr = inside_iph->nexthdr;\r\ninside_hdrlen = ipv6_skip_exthdr(skb, outside_hdrlen + sizeof(_icmph) + sizeof(_inside_iph),\r\n&inside_nexthdr, &inside_fragoff);\r\nif (inside_hdrlen < 0)\r\nreturn 1;\r\nif (inside_nexthdr != IPPROTO_TCP &&\r\ninside_nexthdr != IPPROTO_UDP)\r\nreturn 1;\r\nports = skb_header_pointer(skb, inside_hdrlen,\r\nsizeof(_ports), &_ports);\r\nif (ports == NULL)\r\nreturn 1;\r\n*protocol = inside_nexthdr;\r\n*laddr = &inside_iph->saddr;\r\n*lport = ports[0];\r\n*raddr = &inside_iph->daddr;\r\n*rport = ports[1];\r\nreturn 0;\r\n}\r\nstatic bool\r\nsocket_mt6_v1(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nstruct ipv6hdr *iph = ipv6_hdr(skb);\r\nstruct udphdr _hdr, *hp = NULL;\r\nstruct sock *sk;\r\nstruct in6_addr *daddr, *saddr;\r\n__be16 dport, sport;\r\nint thoff, tproto;\r\nconst struct xt_socket_mtinfo1 *info = (struct xt_socket_mtinfo1 *) par->matchinfo;\r\ntproto = ipv6_find_hdr(skb, &thoff, -1, NULL);\r\nif (tproto < 0) {\r\npr_debug("unable to find transport header in IPv6 packet, dropping\n");\r\nreturn NF_DROP;\r\n}\r\nif (tproto == IPPROTO_UDP || tproto == IPPROTO_TCP) {\r\nhp = skb_header_pointer(skb, thoff,\r\nsizeof(_hdr), &_hdr);\r\nif (hp == NULL)\r\nreturn false;\r\nsaddr = &iph->saddr;\r\nsport = hp->source;\r\ndaddr = &iph->daddr;\r\ndport = hp->dest;\r\n} else if (tproto == IPPROTO_ICMPV6) {\r\nif (extract_icmp6_fields(skb, thoff, &tproto, &saddr, &daddr,\r\n&sport, &dport))\r\nreturn false;\r\n} else {\r\nreturn false;\r\n}\r\nsk = nf_tproxy_get_sock_v6(dev_net(skb->dev), tproto,\r\nsaddr, daddr, sport, dport, par->in, NFT_LOOKUP_ANY);\r\nif (sk != NULL) {\r\nbool wildcard;\r\nbool transparent = true;\r\nwildcard = (sk->sk_state != TCP_TIME_WAIT &&\r\nipv6_addr_any(&inet6_sk(sk)->rcv_saddr));\r\nif (info && info->flags & XT_SOCKET_TRANSPARENT)\r\ntransparent = ((sk->sk_state != TCP_TIME_WAIT &&\r\ninet_sk(sk)->transparent) ||\r\n(sk->sk_state == TCP_TIME_WAIT &&\r\ninet_twsk(sk)->tw_transparent));\r\nxt_socket_put_sk(sk);\r\nif (wildcard || !transparent)\r\nsk = NULL;\r\n}\r\npr_debug("proto %hhd %pI6:%hu -> %pI6:%hu "\r\n"(orig %pI6:%hu) sock %p\n",\r\ntproto, saddr, ntohs(sport),\r\ndaddr, ntohs(dport),\r\n&iph->daddr, hp ? ntohs(hp->dest) : 0, sk);\r\nreturn (sk != NULL);\r\n}\r\nstatic int __init socket_mt_init(void)\r\n{\r\nnf_defrag_ipv4_enable();\r\n#ifdef XT_SOCKET_HAVE_IPV6\r\nnf_defrag_ipv6_enable();\r\n#endif\r\nreturn xt_register_matches(socket_mt_reg, ARRAY_SIZE(socket_mt_reg));\r\n}\r\nstatic void __exit socket_mt_exit(void)\r\n{\r\nxt_unregister_matches(socket_mt_reg, ARRAY_SIZE(socket_mt_reg));\r\n}
