static int _clk_enable(struct clk *clk)\r\n{\r\nunsigned int reg;\r\nreg = __raw_readl(clk->enable_reg);\r\nreg |= 1 << clk->enable_shift;\r\n__raw_writel(reg, clk->enable_reg);\r\nreturn 0;\r\n}\r\nstatic void _clk_disable(struct clk *clk)\r\n{\r\nunsigned int reg;\r\nreg = __raw_readl(clk->enable_reg);\r\nreg &= ~(1 << clk->enable_shift);\r\n__raw_writel(reg, clk->enable_reg);\r\n}\r\nstatic int _clk_can_use_parent(const struct clk *clk_arr[], unsigned int size,\r\nstruct clk *parent)\r\n{\r\nint i;\r\nfor (i = 0; i < size; i++)\r\nif (parent == clk_arr[i])\r\nreturn i;\r\nreturn -EINVAL;\r\n}\r\nstatic unsigned long\r\n_clk_simple_round_rate(struct clk *clk, unsigned long rate, unsigned int limit)\r\n{\r\nint div;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\ndiv = parent_rate / rate;\r\nif (parent_rate % rate)\r\ndiv++;\r\nif (div > limit)\r\ndiv = limit;\r\nreturn parent_rate / div;\r\n}\r\nstatic unsigned long _clk_parent_round_rate(struct clk *clk, unsigned long rate)\r\n{\r\nreturn clk->parent->round_rate(clk->parent, rate);\r\n}\r\nstatic int _clk_parent_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nreturn clk->parent->set_rate(clk->parent, rate);\r\n}\r\nstatic unsigned long clk16m_get_rate(struct clk *clk)\r\n{\r\nreturn 16000000;\r\n}\r\nstatic unsigned long clk32_get_rate(struct clk *clk)\r\n{\r\nreturn clk32_rate;\r\n}\r\nstatic unsigned long clk32_premult_get_rate(struct clk *clk)\r\n{\r\nreturn clk_get_rate(clk->parent) * 512;\r\n}\r\nstatic int prem_clk_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nint i;\r\nunsigned int reg = __raw_readl(CCM_CSCR);\r\ni = _clk_can_use_parent(prem_clk_clocks, ARRAY_SIZE(prem_clk_clocks),\r\nparent);\r\nswitch (i) {\r\ncase 0:\r\nreg &= ~CCM_CSCR_SYSTEM_SEL;\r\nbreak;\r\ncase 1:\r\nreg |= CCM_CSCR_SYSTEM_SEL;\r\nbreak;\r\ndefault:\r\nreturn i;\r\n}\r\n__raw_writel(reg, CCM_CSCR);\r\nreturn 0;\r\n}\r\nstatic unsigned long system_clk_get_rate(struct clk *clk)\r\n{\r\nreturn mxc_decode_pll(__raw_readl(CCM_SPCTL0),\r\nclk_get_rate(clk->parent));\r\n}\r\nstatic unsigned long mcu_clk_get_rate(struct clk *clk)\r\n{\r\nreturn mxc_decode_pll(__raw_readl(CCM_MPCTL0),\r\nclk_get_rate(clk->parent));\r\n}\r\nstatic unsigned long fclk_get_rate(struct clk *clk)\r\n{\r\nunsigned long fclk = clk_get_rate(clk->parent);\r\nif (__raw_readl(CCM_CSCR) & CCM_CSCR_PRESC)\r\nfclk /= 2;\r\nreturn fclk;\r\n}\r\nstatic unsigned long hclk_get_rate(struct clk *clk)\r\n{\r\nreturn clk_get_rate(clk->parent) / (((__raw_readl(CCM_CSCR) &\r\nCCM_CSCR_BCLK_MASK) >> CCM_CSCR_BCLK_OFFSET) + 1);\r\n}\r\nstatic unsigned long hclk_round_rate(struct clk *clk, unsigned long rate)\r\n{\r\nreturn _clk_simple_round_rate(clk, rate, 16);\r\n}\r\nstatic int hclk_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nunsigned int div;\r\nunsigned int reg;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\ndiv = parent_rate / rate;\r\nif (div > 16 || div < 1 || ((parent_rate / div) != rate))\r\nreturn -EINVAL;\r\ndiv--;\r\nreg = __raw_readl(CCM_CSCR);\r\nreg &= ~CCM_CSCR_BCLK_MASK;\r\nreg |= div << CCM_CSCR_BCLK_OFFSET;\r\n__raw_writel(reg, CCM_CSCR);\r\nreturn 0;\r\n}\r\nstatic unsigned long clk48m_get_rate(struct clk *clk)\r\n{\r\nreturn clk_get_rate(clk->parent) / (((__raw_readl(CCM_CSCR) &\r\nCCM_CSCR_USB_MASK) >> CCM_CSCR_USB_OFFSET) + 1);\r\n}\r\nstatic unsigned long clk48m_round_rate(struct clk *clk, unsigned long rate)\r\n{\r\nreturn _clk_simple_round_rate(clk, rate, 8);\r\n}\r\nstatic int clk48m_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nunsigned int div;\r\nunsigned int reg;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\ndiv = parent_rate / rate;\r\nif (div > 8 || div < 1 || ((parent_rate / div) != rate))\r\nreturn -EINVAL;\r\ndiv--;\r\nreg = __raw_readl(CCM_CSCR);\r\nreg &= ~CCM_CSCR_USB_MASK;\r\nreg |= div << CCM_CSCR_USB_OFFSET;\r\n__raw_writel(reg, CCM_CSCR);\r\nreturn 0;\r\n}\r\nstatic unsigned long perclk1_get_rate(struct clk *clk)\r\n{\r\nreturn clk_get_rate(clk->parent) / (((__raw_readl(CCM_PCDR) &\r\nCCM_PCDR_PCLK1_MASK) >> CCM_PCDR_PCLK1_OFFSET) + 1);\r\n}\r\nstatic unsigned long perclk1_round_rate(struct clk *clk, unsigned long rate)\r\n{\r\nreturn _clk_simple_round_rate(clk, rate, 16);\r\n}\r\nstatic int perclk1_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nunsigned int div;\r\nunsigned int reg;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\ndiv = parent_rate / rate;\r\nif (div > 16 || div < 1 || ((parent_rate / div) != rate))\r\nreturn -EINVAL;\r\ndiv--;\r\nreg = __raw_readl(CCM_PCDR);\r\nreg &= ~CCM_PCDR_PCLK1_MASK;\r\nreg |= div << CCM_PCDR_PCLK1_OFFSET;\r\n__raw_writel(reg, CCM_PCDR);\r\nreturn 0;\r\n}\r\nstatic unsigned long perclk2_get_rate(struct clk *clk)\r\n{\r\nreturn clk_get_rate(clk->parent) / (((__raw_readl(CCM_PCDR) &\r\nCCM_PCDR_PCLK2_MASK) >> CCM_PCDR_PCLK2_OFFSET) + 1);\r\n}\r\nstatic unsigned long perclk2_round_rate(struct clk *clk, unsigned long rate)\r\n{\r\nreturn _clk_simple_round_rate(clk, rate, 16);\r\n}\r\nstatic int perclk2_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nunsigned int div;\r\nunsigned int reg;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\ndiv = parent_rate / rate;\r\nif (div > 16 || div < 1 || ((parent_rate / div) != rate))\r\nreturn -EINVAL;\r\ndiv--;\r\nreg = __raw_readl(CCM_PCDR);\r\nreg &= ~CCM_PCDR_PCLK2_MASK;\r\nreg |= div << CCM_PCDR_PCLK2_OFFSET;\r\n__raw_writel(reg, CCM_PCDR);\r\nreturn 0;\r\n}\r\nstatic unsigned long perclk3_get_rate(struct clk *clk)\r\n{\r\nreturn clk_get_rate(clk->parent) / (((__raw_readl(CCM_PCDR) &\r\nCCM_PCDR_PCLK3_MASK) >> CCM_PCDR_PCLK3_OFFSET) + 1);\r\n}\r\nstatic unsigned long perclk3_round_rate(struct clk *clk, unsigned long rate)\r\n{\r\nreturn _clk_simple_round_rate(clk, rate, 128);\r\n}\r\nstatic int perclk3_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nunsigned int div;\r\nunsigned int reg;\r\nunsigned long parent_rate;\r\nparent_rate = clk_get_rate(clk->parent);\r\ndiv = parent_rate / rate;\r\nif (div > 128 || div < 1 || ((parent_rate / div) != rate))\r\nreturn -EINVAL;\r\ndiv--;\r\nreg = __raw_readl(CCM_PCDR);\r\nreg &= ~CCM_PCDR_PCLK3_MASK;\r\nreg |= div << CCM_PCDR_PCLK3_OFFSET;\r\n__raw_writel(reg, CCM_PCDR);\r\nreturn 0;\r\n}\r\nstatic int clko_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nint i;\r\nunsigned int reg;\r\ni = _clk_can_use_parent(clko_clocks, ARRAY_SIZE(clko_clocks), parent);\r\nif (i < 0)\r\nreturn i;\r\nreg = __raw_readl(CCM_CSCR) & ~CCM_CSCR_CLKO_MASK;\r\nreg |= i << CCM_CSCR_CLKO_OFFSET;\r\n__raw_writel(reg, CCM_CSCR);\r\nif (clko_clocks[i]->set_rate && clko_clocks[i]->round_rate) {\r\nclk->set_rate = _clk_parent_set_rate;\r\nclk->round_rate = _clk_parent_round_rate;\r\n} else {\r\nclk->set_rate = NULL;\r\nclk->round_rate = NULL;\r\n}\r\nreturn 0;\r\n}\r\nint __init mx1_clocks_init(unsigned long fref)\r\n{\r\nunsigned int reg;\r\n__raw_writel(0, SCM_GCCR);\r\nclk32_rate = fref;\r\nreg = __raw_readl(CCM_CSCR);\r\nif (reg & CCM_CSCR_SYSTEM_SEL) {\r\nprem_clk.parent = &clk16m;\r\n} else {\r\nreg &= ~(1 << CCM_CSCR_OSC_EN_SHIFT);\r\n__raw_writel(reg, CCM_CSCR);\r\nprem_clk.parent = &clk32_premult;\r\n}\r\nreg = (reg & CCM_CSCR_CLKO_MASK) >> CCM_CSCR_CLKO_OFFSET;\r\nclko_clk.parent = (struct clk *)clko_clocks[reg];\r\nclkdev_add_table(lookups, ARRAY_SIZE(lookups));\r\nclk_enable(&hclk);\r\nclk_enable(&fclk);\r\nmxc_timer_init(&gpt_clk, MX1_IO_ADDRESS(MX1_TIM1_BASE_ADDR),\r\nMX1_TIM1_INT);\r\nreturn 0;\r\n}
