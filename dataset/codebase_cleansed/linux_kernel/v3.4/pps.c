static unsigned int pps_cdev_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct pps_device *pps = file->private_data;\r\npoll_wait(file, &pps->queue, wait);\r\nreturn POLLIN | POLLRDNORM;\r\n}\r\nstatic int pps_cdev_fasync(int fd, struct file *file, int on)\r\n{\r\nstruct pps_device *pps = file->private_data;\r\nreturn fasync_helper(fd, file, on, &pps->async_queue);\r\n}\r\nstatic long pps_cdev_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct pps_device *pps = file->private_data;\r\nstruct pps_kparams params;\r\nvoid __user *uarg = (void __user *) arg;\r\nint __user *iuarg = (int __user *) arg;\r\nint err;\r\nswitch (cmd) {\r\ncase PPS_GETPARAMS:\r\ndev_dbg(pps->dev, "PPS_GETPARAMS\n");\r\nspin_lock_irq(&pps->lock);\r\nparams = pps->params;\r\nspin_unlock_irq(&pps->lock);\r\nerr = copy_to_user(uarg, &params, sizeof(struct pps_kparams));\r\nif (err)\r\nreturn -EFAULT;\r\nbreak;\r\ncase PPS_SETPARAMS:\r\ndev_dbg(pps->dev, "PPS_SETPARAMS\n");\r\nif (!capable(CAP_SYS_TIME))\r\nreturn -EPERM;\r\nerr = copy_from_user(&params, uarg, sizeof(struct pps_kparams));\r\nif (err)\r\nreturn -EFAULT;\r\nif (!(params.mode & (PPS_CAPTUREASSERT | PPS_CAPTURECLEAR))) {\r\ndev_dbg(pps->dev, "capture mode unspecified (%x)\n",\r\nparams.mode);\r\nreturn -EINVAL;\r\n}\r\nif ((params.mode & ~pps->info.mode) != 0) {\r\ndev_dbg(pps->dev, "unsupported capabilities (%x)\n",\r\nparams.mode);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irq(&pps->lock);\r\npps->params = params;\r\nif ((params.mode & (PPS_TSFMT_TSPEC | PPS_TSFMT_NTPFP)) == 0) {\r\ndev_dbg(pps->dev, "time format unspecified (%x)\n",\r\nparams.mode);\r\npps->params.mode |= PPS_TSFMT_TSPEC;\r\n}\r\nif (pps->info.mode & PPS_CANWAIT)\r\npps->params.mode |= PPS_CANWAIT;\r\npps->params.api_version = PPS_API_VERS;\r\nspin_unlock_irq(&pps->lock);\r\nbreak;\r\ncase PPS_GETCAP:\r\ndev_dbg(pps->dev, "PPS_GETCAP\n");\r\nerr = put_user(pps->info.mode, iuarg);\r\nif (err)\r\nreturn -EFAULT;\r\nbreak;\r\ncase PPS_FETCH: {\r\nstruct pps_fdata fdata;\r\nunsigned int ev;\r\ndev_dbg(pps->dev, "PPS_FETCH\n");\r\nerr = copy_from_user(&fdata, uarg, sizeof(struct pps_fdata));\r\nif (err)\r\nreturn -EFAULT;\r\nev = pps->last_ev;\r\nif (fdata.timeout.flags & PPS_TIME_INVALID)\r\nerr = wait_event_interruptible(pps->queue,\r\nev != pps->last_ev);\r\nelse {\r\nunsigned long ticks;\r\ndev_dbg(pps->dev, "timeout %lld.%09d\n",\r\n(long long) fdata.timeout.sec,\r\nfdata.timeout.nsec);\r\nticks = fdata.timeout.sec * HZ;\r\nticks += fdata.timeout.nsec / (NSEC_PER_SEC / HZ);\r\nif (ticks != 0) {\r\nerr = wait_event_interruptible_timeout(\r\npps->queue,\r\nev != pps->last_ev,\r\nticks);\r\nif (err == 0)\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nif (err == -ERESTARTSYS) {\r\ndev_dbg(pps->dev, "pending signal caught\n");\r\nreturn -EINTR;\r\n}\r\nspin_lock_irq(&pps->lock);\r\nfdata.info.assert_sequence = pps->assert_sequence;\r\nfdata.info.clear_sequence = pps->clear_sequence;\r\nfdata.info.assert_tu = pps->assert_tu;\r\nfdata.info.clear_tu = pps->clear_tu;\r\nfdata.info.current_mode = pps->current_mode;\r\nspin_unlock_irq(&pps->lock);\r\nerr = copy_to_user(uarg, &fdata, sizeof(struct pps_fdata));\r\nif (err)\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase PPS_KC_BIND: {\r\nstruct pps_bind_args bind_args;\r\ndev_dbg(pps->dev, "PPS_KC_BIND\n");\r\nif (!capable(CAP_SYS_TIME))\r\nreturn -EPERM;\r\nif (copy_from_user(&bind_args, uarg,\r\nsizeof(struct pps_bind_args)))\r\nreturn -EFAULT;\r\nif ((bind_args.edge & ~pps->info.mode) != 0) {\r\ndev_err(pps->dev, "unsupported capabilities (%x)\n",\r\nbind_args.edge);\r\nreturn -EINVAL;\r\n}\r\nif (bind_args.tsformat != PPS_TSFMT_TSPEC ||\r\n(bind_args.edge & ~PPS_CAPTUREBOTH) != 0 ||\r\nbind_args.consumer != PPS_KC_HARDPPS) {\r\ndev_err(pps->dev, "invalid kernel consumer bind"\r\n" parameters (%x)\n", bind_args.edge);\r\nreturn -EINVAL;\r\n}\r\nerr = pps_kc_bind(pps, &bind_args);\r\nif (err < 0)\r\nreturn err;\r\nbreak;\r\n}\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pps_cdev_open(struct inode *inode, struct file *file)\r\n{\r\nstruct pps_device *pps = container_of(inode->i_cdev,\r\nstruct pps_device, cdev);\r\nfile->private_data = pps;\r\nreturn 0;\r\n}\r\nstatic int pps_cdev_release(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic void pps_device_destruct(struct device *dev)\r\n{\r\nstruct pps_device *pps = dev_get_drvdata(dev);\r\nmutex_lock(&pps_idr_lock);\r\nidr_remove(&pps_idr, pps->id);\r\nmutex_unlock(&pps_idr_lock);\r\nkfree(dev);\r\nkfree(pps);\r\n}\r\nint pps_register_cdev(struct pps_device *pps)\r\n{\r\nint err;\r\ndev_t devt;\r\nmutex_lock(&pps_idr_lock);\r\nif (idr_pre_get(&pps_idr, GFP_KERNEL) == 0) {\r\nmutex_unlock(&pps_idr_lock);\r\nreturn -ENOMEM;\r\n}\r\nerr = idr_get_new(&pps_idr, pps, &pps->id);\r\nmutex_unlock(&pps_idr_lock);\r\nif (err < 0)\r\nreturn err;\r\npps->id &= MAX_ID_MASK;\r\nif (pps->id >= PPS_MAX_SOURCES) {\r\npr_err("%s: too many PPS sources in the system\n",\r\npps->info.name);\r\nerr = -EBUSY;\r\ngoto free_idr;\r\n}\r\ndevt = MKDEV(MAJOR(pps_devt), pps->id);\r\ncdev_init(&pps->cdev, &pps_cdev_fops);\r\npps->cdev.owner = pps->info.owner;\r\nerr = cdev_add(&pps->cdev, devt, 1);\r\nif (err) {\r\npr_err("%s: failed to add char device %d:%d\n",\r\npps->info.name, MAJOR(pps_devt), pps->id);\r\ngoto free_idr;\r\n}\r\npps->dev = device_create(pps_class, pps->info.dev, devt, pps,\r\n"pps%d", pps->id);\r\nif (IS_ERR(pps->dev))\r\ngoto del_cdev;\r\npps->dev->release = pps_device_destruct;\r\npr_debug("source %s got cdev (%d:%d)\n", pps->info.name,\r\nMAJOR(pps_devt), pps->id);\r\nreturn 0;\r\ndel_cdev:\r\ncdev_del(&pps->cdev);\r\nfree_idr:\r\nmutex_lock(&pps_idr_lock);\r\nidr_remove(&pps_idr, pps->id);\r\nmutex_unlock(&pps_idr_lock);\r\nreturn err;\r\n}\r\nvoid pps_unregister_cdev(struct pps_device *pps)\r\n{\r\ndevice_destroy(pps_class, pps->dev->devt);\r\ncdev_del(&pps->cdev);\r\n}\r\nstatic void __exit pps_exit(void)\r\n{\r\nclass_destroy(pps_class);\r\nunregister_chrdev_region(pps_devt, PPS_MAX_SOURCES);\r\n}\r\nstatic int __init pps_init(void)\r\n{\r\nint err;\r\npps_class = class_create(THIS_MODULE, "pps");\r\nif (IS_ERR(pps_class)) {\r\npr_err("failed to allocate class\n");\r\nreturn PTR_ERR(pps_class);\r\n}\r\npps_class->dev_attrs = pps_attrs;\r\nerr = alloc_chrdev_region(&pps_devt, 0, PPS_MAX_SOURCES, "pps");\r\nif (err < 0) {\r\npr_err("failed to allocate char device region\n");\r\ngoto remove_class;\r\n}\r\npr_info("LinuxPPS API ver. %d registered\n", PPS_API_VERS);\r\npr_info("Software ver. %s - Copyright 2005-2007 Rodolfo Giometti "\r\n"<giometti@linux.it>\n", PPS_VERSION);\r\nreturn 0;\r\nremove_class:\r\nclass_destroy(pps_class);\r\nreturn err;\r\n}
