static void init_output(struct hda_codec *codec, hda_nid_t pin, hda_nid_t dac)\r\n{\r\nif (pin) {\r\nsnd_hda_codec_write(codec, pin, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL, PIN_HP);\r\nif (get_wcaps(codec, pin) & AC_WCAP_OUT_AMP)\r\nsnd_hda_codec_write(codec, pin, 0,\r\nAC_VERB_SET_AMP_GAIN_MUTE,\r\nAMP_OUT_UNMUTE);\r\n}\r\nif (dac)\r\nsnd_hda_codec_write(codec, dac, 0,\r\nAC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO);\r\n}\r\nstatic void init_input(struct hda_codec *codec, hda_nid_t pin, hda_nid_t adc)\r\n{\r\nif (pin) {\r\nsnd_hda_codec_write(codec, pin, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL,\r\nPIN_VREF80);\r\nif (get_wcaps(codec, pin) & AC_WCAP_IN_AMP)\r\nsnd_hda_codec_write(codec, pin, 0,\r\nAC_VERB_SET_AMP_GAIN_MUTE,\r\nAMP_IN_UNMUTE(0));\r\n}\r\nif (adc)\r\nsnd_hda_codec_write(codec, adc, 0, AC_VERB_SET_AMP_GAIN_MUTE,\r\nAMP_IN_UNMUTE(0));\r\n}\r\nstatic int _add_switch(struct hda_codec *codec, hda_nid_t nid, const char *pfx,\r\nint chan, int dir)\r\n{\r\nchar namestr[44];\r\nint type = dir ? HDA_INPUT : HDA_OUTPUT;\r\nstruct snd_kcontrol_new knew =\r\nHDA_CODEC_MUTE_MONO(namestr, nid, chan, 0, type);\r\nsprintf(namestr, "%s %s Switch", pfx, dirstr[dir]);\r\nreturn snd_hda_ctl_add(codec, nid, snd_ctl_new1(&knew, codec));\r\n}\r\nstatic int _add_volume(struct hda_codec *codec, hda_nid_t nid, const char *pfx,\r\nint chan, int dir)\r\n{\r\nchar namestr[44];\r\nint type = dir ? HDA_INPUT : HDA_OUTPUT;\r\nstruct snd_kcontrol_new knew =\r\nHDA_CODEC_VOLUME_MONO(namestr, nid, chan, 0, type);\r\nsprintf(namestr, "%s %s Volume", pfx, dirstr[dir]);\r\nreturn snd_hda_ctl_add(codec, nid, snd_ctl_new1(&knew, codec));\r\n}\r\nstatic int chipio_send(struct hda_codec *codec,\r\nunsigned int reg,\r\nunsigned int data)\r\n{\r\nunsigned int res;\r\nint retry = 50;\r\ndo {\r\nres = snd_hda_codec_read(codec, WIDGET_CHIP_CTRL, 0,\r\nreg, data);\r\nif (res == VENDOR_STATUS_CHIPIO_OK)\r\nreturn 0;\r\n} while (--retry);\r\nreturn -EIO;\r\n}\r\nstatic int chipio_write_address(struct hda_codec *codec,\r\nunsigned int chip_addx)\r\n{\r\nint res;\r\nres = chipio_send(codec, VENDOR_CHIPIO_ADDRESS_LOW,\r\nchip_addx & 0xffff);\r\nif (res != -EIO) {\r\nres = chipio_send(codec, VENDOR_CHIPIO_ADDRESS_HIGH,\r\nchip_addx >> 16);\r\n}\r\nreturn res;\r\n}\r\nstatic int chipio_write_data(struct hda_codec *codec, unsigned int data)\r\n{\r\nint res;\r\nres = chipio_send(codec, VENDOR_CHIPIO_DATA_LOW, data & 0xffff);\r\nif (res != -EIO) {\r\nres = chipio_send(codec, VENDOR_CHIPIO_DATA_HIGH,\r\ndata >> 16);\r\n}\r\nreturn res;\r\n}\r\nstatic int chipio_read_data(struct hda_codec *codec, unsigned int *data)\r\n{\r\nint res;\r\nres = chipio_send(codec, VENDOR_CHIPIO_HIC_POST_READ, 0);\r\nif (res != -EIO) {\r\nres = chipio_send(codec, VENDOR_CHIPIO_STATUS, 0);\r\n}\r\nif (res != -EIO) {\r\n*data = snd_hda_codec_read(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_HIC_READ_DATA,\r\n0);\r\n}\r\nreturn res;\r\n}\r\nstatic int chipio_write(struct hda_codec *codec,\r\nunsigned int chip_addx, const unsigned int data)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nint err;\r\nmutex_lock(&spec->chipio_mutex);\r\nerr = chipio_write_address(codec, chip_addx);\r\nif (err < 0)\r\ngoto exit;\r\nerr = chipio_write_data(codec, data);\r\nif (err < 0)\r\ngoto exit;\r\nexit:\r\nmutex_unlock(&spec->chipio_mutex);\r\nreturn err;\r\n}\r\nstatic int chipio_read(struct hda_codec *codec,\r\nunsigned int chip_addx, unsigned int *data)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nint err;\r\nmutex_lock(&spec->chipio_mutex);\r\nerr = chipio_write_address(codec, chip_addx);\r\nif (err < 0)\r\ngoto exit;\r\nerr = chipio_read_data(codec, data);\r\nif (err < 0)\r\ngoto exit;\r\nexit:\r\nmutex_unlock(&spec->chipio_mutex);\r\nreturn err;\r\n}\r\nstatic void ca0132_setup_stream(struct hda_codec *codec, hda_nid_t nid,\r\nu32 stream_tag,\r\nint channel_id, int format)\r\n{\r\nunsigned int oldval, newval;\r\nif (!nid)\r\nreturn;\r\nsnd_printdd("ca0132_setup_stream: "\r\n"NID=0x%x, stream=0x%x, channel=%d, format=0x%x\n",\r\nnid, stream_tag, channel_id, format);\r\noldval = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_STREAM_FORMAT,\r\n0);\r\nif (oldval != format) {\r\nmsleep(20);\r\nsnd_hda_codec_write(codec, nid, 0,\r\nAC_VERB_SET_STREAM_FORMAT,\r\nformat);\r\n}\r\noldval = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_CONV, 0);\r\nnewval = (stream_tag << 4) | channel_id;\r\nif (oldval != newval) {\r\nsnd_hda_codec_write(codec, nid, 0,\r\nAC_VERB_SET_CHANNEL_STREAMID,\r\nnewval);\r\n}\r\n}\r\nstatic void ca0132_cleanup_stream(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nsnd_hda_codec_write(codec, nid, 0, AC_VERB_SET_STREAM_FORMAT, 0);\r\nsnd_hda_codec_write(codec, nid, 0, AC_VERB_SET_CHANNEL_STREAMID, 0);\r\n}\r\nstatic int ca0132_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nca0132_setup_stream(codec, spec->dacs[0], stream_tag, 0, format);\r\nreturn 0;\r\n}\r\nstatic int ca0132_playback_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nca0132_cleanup_stream(codec, spec->dacs[0]);\r\nreturn 0;\r\n}\r\nstatic int ca0132_dig_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nca0132_setup_stream(codec, spec->dig_out, stream_tag, 0, format);\r\nreturn 0;\r\n}\r\nstatic int ca0132_dig_playback_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nca0132_cleanup_stream(codec, spec->dig_out);\r\nreturn 0;\r\n}\r\nstatic int ca0132_capture_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nca0132_setup_stream(codec, spec->adcs[substream->number],\r\nstream_tag, 0, format);\r\nreturn 0;\r\n}\r\nstatic int ca0132_capture_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nca0132_cleanup_stream(codec, spec->adcs[substream->number]);\r\nreturn 0;\r\n}\r\nstatic int ca0132_dig_capture_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nca0132_setup_stream(codec, spec->dig_in, stream_tag, 0, format);\r\nreturn 0;\r\n}\r\nstatic int ca0132_dig_capture_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nca0132_cleanup_stream(codec, spec->dig_in);\r\nreturn 0;\r\n}\r\nstatic int ca0132_build_pcms(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nstruct hda_pcm *info = spec->pcm_rec;\r\ncodec->pcm_info = info;\r\ncodec->num_pcms = 0;\r\ninfo->name = "CA0132 Analog";\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK] = ca0132_pcm_analog_playback;\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK].nid = spec->dacs[0];\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK].channels_max =\r\nspec->multiout.max_channels;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE] = ca0132_pcm_analog_capture;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE].substreams = spec->num_inputs;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->adcs[0];\r\ncodec->num_pcms++;\r\nif (!spec->dig_out && !spec->dig_in)\r\nreturn 0;\r\ninfo++;\r\ninfo->name = "CA0132 Digital";\r\ninfo->pcm_type = HDA_PCM_TYPE_SPDIF;\r\nif (spec->dig_out) {\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK] =\r\nca0132_pcm_digital_playback;\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK].nid = spec->dig_out;\r\n}\r\nif (spec->dig_in) {\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE] =\r\nca0132_pcm_digital_capture;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->dig_in;\r\n}\r\ncodec->num_pcms++;\r\nreturn 0;\r\n}\r\nstatic int ca0132_hp_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ca0132_spec *spec = codec->spec;\r\nlong *valp = ucontrol->value.integer.value;\r\n*valp = spec->curr_hp_switch;\r\nreturn 0;\r\n}\r\nstatic int ca0132_hp_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ca0132_spec *spec = codec->spec;\r\nlong *valp = ucontrol->value.integer.value;\r\nunsigned int data;\r\nint err;\r\nif (spec->curr_hp_switch == *valp)\r\nreturn 0;\r\nsnd_hda_power_up(codec);\r\nerr = chipio_read(codec, REG_CODEC_MUTE, &data);\r\nif (err < 0)\r\ngoto exit;\r\ndata = (data & 0x7f) | (*valp ? 0 : 0x80);\r\nerr = chipio_write(codec, REG_CODEC_MUTE, data);\r\nif (err < 0)\r\ngoto exit;\r\nspec->curr_hp_switch = *valp;\r\nexit:\r\nsnd_hda_power_down(codec);\r\nreturn err < 0 ? err : 1;\r\n}\r\nstatic int ca0132_speaker_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ca0132_spec *spec = codec->spec;\r\nlong *valp = ucontrol->value.integer.value;\r\n*valp = spec->curr_speaker_switch;\r\nreturn 0;\r\n}\r\nstatic int ca0132_speaker_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ca0132_spec *spec = codec->spec;\r\nlong *valp = ucontrol->value.integer.value;\r\nunsigned int data;\r\nint err;\r\nif (spec->curr_speaker_switch == *valp)\r\nreturn 0;\r\nsnd_hda_power_up(codec);\r\nerr = chipio_read(codec, REG_CODEC_MUTE, &data);\r\nif (err < 0)\r\ngoto exit;\r\ndata = (data & 0xef) | (*valp ? 0 : 0x10);\r\nerr = chipio_write(codec, REG_CODEC_MUTE, data);\r\nif (err < 0)\r\ngoto exit;\r\nspec->curr_speaker_switch = *valp;\r\nexit:\r\nsnd_hda_power_down(codec);\r\nreturn err < 0 ? err : 1;\r\n}\r\nstatic int ca0132_hp_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ca0132_spec *spec = codec->spec;\r\nlong *valp = ucontrol->value.integer.value;\r\n*valp++ = spec->curr_hp_volume[0];\r\n*valp = spec->curr_hp_volume[1];\r\nreturn 0;\r\n}\r\nstatic int ca0132_hp_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ca0132_spec *spec = codec->spec;\r\nlong *valp = ucontrol->value.integer.value;\r\nlong left_vol, right_vol;\r\nunsigned int data;\r\nint val;\r\nint err;\r\nleft_vol = *valp++;\r\nright_vol = *valp;\r\nif ((spec->curr_hp_volume[0] == left_vol) &&\r\n(spec->curr_hp_volume[1] == right_vol))\r\nreturn 0;\r\nsnd_hda_power_up(codec);\r\nerr = chipio_read(codec, REG_CODEC_HP_VOL_L, &data);\r\nif (err < 0)\r\ngoto exit;\r\nval = 31 - left_vol;\r\ndata = (data & 0xe0) | val;\r\nerr = chipio_write(codec, REG_CODEC_HP_VOL_L, data);\r\nif (err < 0)\r\ngoto exit;\r\nval = 31 - right_vol;\r\ndata = (data & 0xe0) | val;\r\nerr = chipio_write(codec, REG_CODEC_HP_VOL_R, data);\r\nif (err < 0)\r\ngoto exit;\r\nspec->curr_hp_volume[0] = left_vol;\r\nspec->curr_hp_volume[1] = right_vol;\r\nexit:\r\nsnd_hda_power_down(codec);\r\nreturn err < 0 ? err : 1;\r\n}\r\nstatic int add_hp_switch(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstruct snd_kcontrol_new knew =\r\nHDA_CODEC_MUTE_MONO("Headphone Playback Switch",\r\nnid, 1, 0, HDA_OUTPUT);\r\nknew.get = ca0132_hp_switch_get;\r\nknew.put = ca0132_hp_switch_put;\r\nreturn snd_hda_ctl_add(codec, nid, snd_ctl_new1(&knew, codec));\r\n}\r\nstatic int add_hp_volume(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstruct snd_kcontrol_new knew =\r\nHDA_CODEC_VOLUME_MONO("Headphone Playback Volume",\r\nnid, 3, 0, HDA_OUTPUT);\r\nknew.get = ca0132_hp_volume_get;\r\nknew.put = ca0132_hp_volume_put;\r\nreturn snd_hda_ctl_add(codec, nid, snd_ctl_new1(&knew, codec));\r\n}\r\nstatic int add_speaker_switch(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstruct snd_kcontrol_new knew =\r\nHDA_CODEC_MUTE_MONO("Speaker Playback Switch",\r\nnid, 1, 0, HDA_OUTPUT);\r\nknew.get = ca0132_speaker_switch_get;\r\nknew.put = ca0132_speaker_switch_put;\r\nreturn snd_hda_ctl_add(codec, nid, snd_ctl_new1(&knew, codec));\r\n}\r\nstatic void ca0132_fix_hp_caps(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nunsigned int caps;\r\ncaps = 0x80031f06;\r\nsnd_hda_override_amp_caps(codec, cfg->hp_pins[0], HDA_OUTPUT, caps);\r\n}\r\nstatic int ca0132_build_controls(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nint i, err;\r\nif (spec->multiout.num_dacs) {\r\nerr = add_speaker_switch(codec, spec->out_pins[0]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (cfg->hp_outs) {\r\nca0132_fix_hp_caps(codec);\r\nerr = add_hp_switch(codec, cfg->hp_pins[0]);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_hp_volume(codec, cfg->hp_pins[0]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < spec->num_inputs; i++) {\r\nconst char *label = spec->input_labels[i];\r\nerr = add_in_switch(codec, spec->adcs[i], label);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_in_volume(codec, spec->adcs[i], label);\r\nif (err < 0)\r\nreturn err;\r\nif (cfg->inputs[i].type == AUTO_PIN_MIC) {\r\nerr = add_in_mono_volume(codec, spec->input_pins[i],\r\n"Mic Boost", 1);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nif (spec->dig_out) {\r\nerr = snd_hda_create_spdif_out_ctls(codec, spec->dig_out,\r\nspec->dig_out);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_out_volume(codec, spec->dig_out, "IEC958");\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (spec->dig_in) {\r\nerr = snd_hda_create_spdif_in_ctls(codec, spec->dig_in);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_in_volume(codec, spec->dig_in, "IEC958");\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ca0132_set_ct_ext(struct hda_codec *codec, int enable)\r\n{\r\nsnd_printdd("SET CREATIVE EXTENSION\n");\r\nsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_CT_EXTENSIONS_ENABLE,\r\nenable);\r\nmsleep(20);\r\n}\r\nstatic void ca0132_config(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\ncfg->line_outs = 1;\r\ncfg->line_out_pins[0] = 0x0b;\r\ncfg->line_out_type = AUTO_PIN_LINE_OUT;\r\nspec->dacs[0] = 0x02;\r\nspec->out_pins[0] = 0x0b;\r\nspec->multiout.dac_nids = spec->dacs;\r\nspec->multiout.num_dacs = 1;\r\nspec->multiout.max_channels = 2;\r\ncfg->hp_outs = 1;\r\ncfg->hp_pins[0] = 0x0f;\r\nspec->hp_dac = 0;\r\nspec->multiout.hp_nid = 0;\r\ncfg->num_inputs = 2;\r\ncfg->inputs[0].pin = 0x12;\r\ncfg->inputs[0].type = AUTO_PIN_MIC;\r\ncfg->inputs[1].pin = 0x11;\r\ncfg->inputs[1].type = AUTO_PIN_LINE_IN;\r\nspec->input_pins[0] = 0x12;\r\nspec->input_labels[0] = "Mic-In";\r\nspec->adcs[0] = 0x07;\r\nspec->input_pins[1] = 0x11;\r\nspec->input_labels[1] = "Line-In";\r\nspec->adcs[1] = 0x08;\r\nspec->num_inputs = 2;\r\n}\r\nstatic void ca0132_init_chip(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nmutex_init(&spec->chipio_mutex);\r\n}\r\nstatic void ca0132_exit_chip(struct hda_codec *codec)\r\n{\r\n}\r\nstatic int ca0132_init(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nint i;\r\nfor (i = 0; i < spec->multiout.num_dacs; i++) {\r\ninit_output(codec, spec->out_pins[i],\r\nspec->multiout.dac_nids[i]);\r\n}\r\ninit_output(codec, cfg->hp_pins[0], spec->hp_dac);\r\ninit_output(codec, cfg->dig_out_pins[0], spec->dig_out);\r\nfor (i = 0; i < spec->num_inputs; i++)\r\ninit_input(codec, spec->input_pins[i], spec->adcs[i]);\r\ninit_input(codec, cfg->dig_in_pin, spec->dig_in);\r\nca0132_set_ct_ext(codec, 1);\r\nreturn 0;\r\n}\r\nstatic void ca0132_free(struct hda_codec *codec)\r\n{\r\nca0132_set_ct_ext(codec, 0);\r\nca0132_exit_chip(codec);\r\nkfree(codec->spec);\r\n}\r\nstatic int patch_ca0132(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec;\r\nsnd_printdd("patch_ca0132\n");\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\ncodec->spec = spec;\r\nca0132_init_chip(codec);\r\nca0132_config(codec);\r\ncodec->patch_ops = ca0132_patch_ops;\r\nreturn 0;\r\n}\r\nstatic int __init patch_ca0132_init(void)\r\n{\r\nreturn snd_hda_add_codec_preset(&ca0132_list);\r\n}\r\nstatic void __exit patch_ca0132_exit(void)\r\n{\r\nsnd_hda_delete_codec_preset(&ca0132_list);\r\n}
