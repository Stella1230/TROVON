static ssize_t overlay_name_show(struct omap_overlay *ovl, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", ovl->name);\r\n}\r\nstatic ssize_t overlay_manager_show(struct omap_overlay *ovl, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\novl->manager ? ovl->manager->name : "<none>");\r\n}\r\nstatic ssize_t overlay_manager_store(struct omap_overlay *ovl, const char *buf,\r\nsize_t size)\r\n{\r\nint i, r;\r\nstruct omap_overlay_manager *mgr = NULL;\r\nstruct omap_overlay_manager *old_mgr;\r\nint len = size;\r\nif (buf[size-1] == '\n')\r\n--len;\r\nif (len > 0) {\r\nfor (i = 0; i < omap_dss_get_num_overlay_managers(); ++i) {\r\nmgr = omap_dss_get_overlay_manager(i);\r\nif (sysfs_streq(buf, mgr->name))\r\nbreak;\r\nmgr = NULL;\r\n}\r\n}\r\nif (len > 0 && mgr == NULL)\r\nreturn -EINVAL;\r\nif (mgr)\r\nDSSDBG("manager %s found\n", mgr->name);\r\nif (mgr == ovl->manager)\r\nreturn size;\r\nold_mgr = ovl->manager;\r\nr = dispc_runtime_get();\r\nif (r)\r\nreturn r;\r\nif (old_mgr) {\r\nr = ovl->unset_manager(ovl);\r\nif (r) {\r\nDSSERR("detach failed\n");\r\ngoto err;\r\n}\r\nr = old_mgr->apply(old_mgr);\r\nif (r)\r\ngoto err;\r\n}\r\nif (mgr) {\r\nr = ovl->set_manager(ovl, mgr);\r\nif (r) {\r\nDSSERR("Failed to attach overlay\n");\r\ngoto err;\r\n}\r\nr = mgr->apply(mgr);\r\nif (r)\r\ngoto err;\r\n}\r\ndispc_runtime_put();\r\nreturn size;\r\nerr:\r\ndispc_runtime_put();\r\nreturn r;\r\n}\r\nstatic ssize_t overlay_input_size_show(struct omap_overlay *ovl, char *buf)\r\n{\r\nstruct omap_overlay_info info;\r\novl->get_overlay_info(ovl, &info);\r\nreturn snprintf(buf, PAGE_SIZE, "%d,%d\n",\r\ninfo.width, info.height);\r\n}\r\nstatic ssize_t overlay_screen_width_show(struct omap_overlay *ovl, char *buf)\r\n{\r\nstruct omap_overlay_info info;\r\novl->get_overlay_info(ovl, &info);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", info.screen_width);\r\n}\r\nstatic ssize_t overlay_position_show(struct omap_overlay *ovl, char *buf)\r\n{\r\nstruct omap_overlay_info info;\r\novl->get_overlay_info(ovl, &info);\r\nreturn snprintf(buf, PAGE_SIZE, "%d,%d\n",\r\ninfo.pos_x, info.pos_y);\r\n}\r\nstatic ssize_t overlay_position_store(struct omap_overlay *ovl,\r\nconst char *buf, size_t size)\r\n{\r\nint r;\r\nchar *last;\r\nstruct omap_overlay_info info;\r\novl->get_overlay_info(ovl, &info);\r\ninfo.pos_x = simple_strtoul(buf, &last, 10);\r\n++last;\r\nif (last - buf >= size)\r\nreturn -EINVAL;\r\ninfo.pos_y = simple_strtoul(last, &last, 10);\r\nr = ovl->set_overlay_info(ovl, &info);\r\nif (r)\r\nreturn r;\r\nif (ovl->manager) {\r\nr = ovl->manager->apply(ovl->manager);\r\nif (r)\r\nreturn r;\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t overlay_output_size_show(struct omap_overlay *ovl, char *buf)\r\n{\r\nstruct omap_overlay_info info;\r\novl->get_overlay_info(ovl, &info);\r\nreturn snprintf(buf, PAGE_SIZE, "%d,%d\n",\r\ninfo.out_width, info.out_height);\r\n}\r\nstatic ssize_t overlay_output_size_store(struct omap_overlay *ovl,\r\nconst char *buf, size_t size)\r\n{\r\nint r;\r\nchar *last;\r\nstruct omap_overlay_info info;\r\novl->get_overlay_info(ovl, &info);\r\ninfo.out_width = simple_strtoul(buf, &last, 10);\r\n++last;\r\nif (last - buf >= size)\r\nreturn -EINVAL;\r\ninfo.out_height = simple_strtoul(last, &last, 10);\r\nr = ovl->set_overlay_info(ovl, &info);\r\nif (r)\r\nreturn r;\r\nif (ovl->manager) {\r\nr = ovl->manager->apply(ovl->manager);\r\nif (r)\r\nreturn r;\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t overlay_enabled_show(struct omap_overlay *ovl, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ovl->is_enabled(ovl));\r\n}\r\nstatic ssize_t overlay_enabled_store(struct omap_overlay *ovl, const char *buf,\r\nsize_t size)\r\n{\r\nint r;\r\nbool enable;\r\nr = strtobool(buf, &enable);\r\nif (r)\r\nreturn r;\r\nif (enable)\r\nr = ovl->enable(ovl);\r\nelse\r\nr = ovl->disable(ovl);\r\nif (r)\r\nreturn r;\r\nreturn size;\r\n}\r\nstatic ssize_t overlay_global_alpha_show(struct omap_overlay *ovl, char *buf)\r\n{\r\nstruct omap_overlay_info info;\r\novl->get_overlay_info(ovl, &info);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\ninfo.global_alpha);\r\n}\r\nstatic ssize_t overlay_global_alpha_store(struct omap_overlay *ovl,\r\nconst char *buf, size_t size)\r\n{\r\nint r;\r\nu8 alpha;\r\nstruct omap_overlay_info info;\r\nif ((ovl->caps & OMAP_DSS_OVL_CAP_GLOBAL_ALPHA) == 0)\r\nreturn -ENODEV;\r\nr = kstrtou8(buf, 0, &alpha);\r\nif (r)\r\nreturn r;\r\novl->get_overlay_info(ovl, &info);\r\ninfo.global_alpha = alpha;\r\nr = ovl->set_overlay_info(ovl, &info);\r\nif (r)\r\nreturn r;\r\nif (ovl->manager) {\r\nr = ovl->manager->apply(ovl->manager);\r\nif (r)\r\nreturn r;\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t overlay_pre_mult_alpha_show(struct omap_overlay *ovl,\r\nchar *buf)\r\n{\r\nstruct omap_overlay_info info;\r\novl->get_overlay_info(ovl, &info);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\ninfo.pre_mult_alpha);\r\n}\r\nstatic ssize_t overlay_pre_mult_alpha_store(struct omap_overlay *ovl,\r\nconst char *buf, size_t size)\r\n{\r\nint r;\r\nu8 alpha;\r\nstruct omap_overlay_info info;\r\nif ((ovl->caps & OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA) == 0)\r\nreturn -ENODEV;\r\nr = kstrtou8(buf, 0, &alpha);\r\nif (r)\r\nreturn r;\r\novl->get_overlay_info(ovl, &info);\r\ninfo.pre_mult_alpha = alpha;\r\nr = ovl->set_overlay_info(ovl, &info);\r\nif (r)\r\nreturn r;\r\nif (ovl->manager) {\r\nr = ovl->manager->apply(ovl->manager);\r\nif (r)\r\nreturn r;\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t overlay_zorder_show(struct omap_overlay *ovl, char *buf)\r\n{\r\nstruct omap_overlay_info info;\r\novl->get_overlay_info(ovl, &info);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", info.zorder);\r\n}\r\nstatic ssize_t overlay_zorder_store(struct omap_overlay *ovl,\r\nconst char *buf, size_t size)\r\n{\r\nint r;\r\nu8 zorder;\r\nstruct omap_overlay_info info;\r\nif ((ovl->caps & OMAP_DSS_OVL_CAP_ZORDER) == 0)\r\nreturn -ENODEV;\r\nr = kstrtou8(buf, 0, &zorder);\r\nif (r)\r\nreturn r;\r\novl->get_overlay_info(ovl, &info);\r\ninfo.zorder = zorder;\r\nr = ovl->set_overlay_info(ovl, &info);\r\nif (r)\r\nreturn r;\r\nif (ovl->manager) {\r\nr = ovl->manager->apply(ovl->manager);\r\nif (r)\r\nreturn r;\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t overlay_attr_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct omap_overlay *overlay;\r\nstruct overlay_attribute *overlay_attr;\r\noverlay = container_of(kobj, struct omap_overlay, kobj);\r\noverlay_attr = container_of(attr, struct overlay_attribute, attr);\r\nif (!overlay_attr->show)\r\nreturn -ENOENT;\r\nreturn overlay_attr->show(overlay, buf);\r\n}\r\nstatic ssize_t overlay_attr_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct omap_overlay *overlay;\r\nstruct overlay_attribute *overlay_attr;\r\noverlay = container_of(kobj, struct omap_overlay, kobj);\r\noverlay_attr = container_of(attr, struct overlay_attribute, attr);\r\nif (!overlay_attr->store)\r\nreturn -ENOENT;\r\nreturn overlay_attr->store(overlay, buf, size);\r\n}\r\nint omap_dss_get_num_overlays(void)\r\n{\r\nreturn num_overlays;\r\n}\r\nstruct omap_overlay *omap_dss_get_overlay(int num)\r\n{\r\nif (num >= num_overlays)\r\nreturn NULL;\r\nreturn &overlays[num];\r\n}\r\nvoid dss_init_overlays(struct platform_device *pdev)\r\n{\r\nint i, r;\r\nnum_overlays = dss_feat_get_num_ovls();\r\noverlays = kzalloc(sizeof(struct omap_overlay) * num_overlays,\r\nGFP_KERNEL);\r\nBUG_ON(overlays == NULL);\r\nfor (i = 0; i < num_overlays; ++i) {\r\nstruct omap_overlay *ovl = &overlays[i];\r\nswitch (i) {\r\ncase 0:\r\novl->name = "gfx";\r\novl->id = OMAP_DSS_GFX;\r\nbreak;\r\ncase 1:\r\novl->name = "vid1";\r\novl->id = OMAP_DSS_VIDEO1;\r\nbreak;\r\ncase 2:\r\novl->name = "vid2";\r\novl->id = OMAP_DSS_VIDEO2;\r\nbreak;\r\ncase 3:\r\novl->name = "vid3";\r\novl->id = OMAP_DSS_VIDEO3;\r\nbreak;\r\n}\r\novl->is_enabled = &dss_ovl_is_enabled;\r\novl->enable = &dss_ovl_enable;\r\novl->disable = &dss_ovl_disable;\r\novl->set_manager = &dss_ovl_set_manager;\r\novl->unset_manager = &dss_ovl_unset_manager;\r\novl->set_overlay_info = &dss_ovl_set_info;\r\novl->get_overlay_info = &dss_ovl_get_info;\r\novl->wait_for_go = &dss_mgr_wait_for_go_ovl;\r\novl->caps = dss_feat_get_overlay_caps(ovl->id);\r\novl->supported_modes =\r\ndss_feat_get_supported_color_modes(ovl->id);\r\nr = kobject_init_and_add(&ovl->kobj, &overlay_ktype,\r\n&pdev->dev.kobj, "overlay%d", i);\r\nif (r)\r\nDSSERR("failed to create sysfs file\n");\r\n}\r\n}\r\nvoid dss_recheck_connections(struct omap_dss_device *dssdev, bool force)\r\n{\r\nint i;\r\nstruct omap_overlay_manager *lcd_mgr;\r\nstruct omap_overlay_manager *tv_mgr;\r\nstruct omap_overlay_manager *lcd2_mgr = NULL;\r\nstruct omap_overlay_manager *mgr = NULL;\r\nlcd_mgr = omap_dss_get_overlay_manager(OMAP_DSS_OVL_MGR_LCD);\r\ntv_mgr = omap_dss_get_overlay_manager(OMAP_DSS_OVL_MGR_TV);\r\nif (dss_has_feature(FEAT_MGR_LCD2))\r\nlcd2_mgr = omap_dss_get_overlay_manager(OMAP_DSS_OVL_MGR_LCD2);\r\nif (dssdev->channel == OMAP_DSS_CHANNEL_LCD2) {\r\nif (!lcd2_mgr->device || force) {\r\nif (lcd2_mgr->device)\r\nlcd2_mgr->unset_device(lcd2_mgr);\r\nlcd2_mgr->set_device(lcd2_mgr, dssdev);\r\nmgr = lcd2_mgr;\r\n}\r\n} else if (dssdev->type != OMAP_DISPLAY_TYPE_VENC\r\n&& dssdev->type != OMAP_DISPLAY_TYPE_HDMI) {\r\nif (!lcd_mgr->device || force) {\r\nif (lcd_mgr->device)\r\nlcd_mgr->unset_device(lcd_mgr);\r\nlcd_mgr->set_device(lcd_mgr, dssdev);\r\nmgr = lcd_mgr;\r\n}\r\n}\r\nif (dssdev->type == OMAP_DISPLAY_TYPE_VENC\r\n|| dssdev->type == OMAP_DISPLAY_TYPE_HDMI) {\r\nif (!tv_mgr->device || force) {\r\nif (tv_mgr->device)\r\ntv_mgr->unset_device(tv_mgr);\r\ntv_mgr->set_device(tv_mgr, dssdev);\r\nmgr = tv_mgr;\r\n}\r\n}\r\nif (mgr) {\r\ndispc_runtime_get();\r\nfor (i = 0; i < dss_feat_get_num_ovls(); i++) {\r\nstruct omap_overlay *ovl;\r\novl = omap_dss_get_overlay(i);\r\nif (!ovl->manager || force) {\r\nif (ovl->manager)\r\novl->unset_manager(ovl);\r\novl->set_manager(ovl, mgr);\r\n}\r\n}\r\ndispc_runtime_put();\r\n}\r\n}\r\nvoid dss_uninit_overlays(struct platform_device *pdev)\r\n{\r\nint i;\r\nfor (i = 0; i < num_overlays; ++i) {\r\nstruct omap_overlay *ovl = &overlays[i];\r\nkobject_del(&ovl->kobj);\r\nkobject_put(&ovl->kobj);\r\n}\r\nkfree(overlays);\r\noverlays = NULL;\r\nnum_overlays = 0;\r\n}\r\nint dss_ovl_simple_check(struct omap_overlay *ovl,\r\nconst struct omap_overlay_info *info)\r\n{\r\nif (info->paddr == 0) {\r\nDSSERR("check_overlay: paddr cannot be 0\n");\r\nreturn -EINVAL;\r\n}\r\nif ((ovl->caps & OMAP_DSS_OVL_CAP_SCALE) == 0) {\r\nif (info->out_width != 0 && info->width != info->out_width) {\r\nDSSERR("check_overlay: overlay %d doesn't support "\r\n"scaling\n", ovl->id);\r\nreturn -EINVAL;\r\n}\r\nif (info->out_height != 0 && info->height != info->out_height) {\r\nDSSERR("check_overlay: overlay %d doesn't support "\r\n"scaling\n", ovl->id);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif ((ovl->supported_modes & info->color_mode) == 0) {\r\nDSSERR("check_overlay: overlay %d doesn't support mode %d\n",\r\novl->id, info->color_mode);\r\nreturn -EINVAL;\r\n}\r\nif (info->zorder >= omap_dss_get_num_overlays()) {\r\nDSSERR("check_overlay: zorder %d too high\n", info->zorder);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint dss_ovl_check(struct omap_overlay *ovl,\r\nstruct omap_overlay_info *info, struct omap_dss_device *dssdev)\r\n{\r\nu16 outw, outh;\r\nu16 dw, dh;\r\nif (dssdev == NULL)\r\nreturn 0;\r\ndssdev->driver->get_resolution(dssdev, &dw, &dh);\r\nif ((ovl->caps & OMAP_DSS_OVL_CAP_SCALE) == 0) {\r\noutw = info->width;\r\nouth = info->height;\r\n} else {\r\nif (info->out_width == 0)\r\noutw = info->width;\r\nelse\r\noutw = info->out_width;\r\nif (info->out_height == 0)\r\nouth = info->height;\r\nelse\r\nouth = info->out_height;\r\n}\r\nif (dw < info->pos_x + outw) {\r\nDSSERR("overlay %d horizontally not inside the display area "\r\n"(%d + %d >= %d)\n",\r\novl->id, info->pos_x, outw, dw);\r\nreturn -EINVAL;\r\n}\r\nif (dh < info->pos_y + outh) {\r\nDSSERR("overlay %d vertically not inside the display area "\r\n"(%d + %d >= %d)\n",\r\novl->id, info->pos_y, outh, dh);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}
