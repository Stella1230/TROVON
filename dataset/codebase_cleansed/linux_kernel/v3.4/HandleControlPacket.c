static VOID handle_rx_control_packet(PMINI_ADAPTER Adapter, struct sk_buff *skb)\r\n{\r\nPPER_TARANG_DATA pTarang = NULL;\r\nBOOLEAN HighPriorityMessage = FALSE;\r\nstruct sk_buff *newPacket = NULL;\r\nCHAR cntrl_msg_mask_bit = 0;\r\nBOOLEAN drop_pkt_flag = TRUE;\r\nUSHORT usStatus = *(PUSHORT)(skb->data);\r\nif (netif_msg_pktdata(Adapter))\r\nprint_hex_dump(KERN_DEBUG, PFX "rx control: ", DUMP_PREFIX_NONE,\r\n16, 1, skb->data, skb->len, 0);\r\nswitch (usStatus) {\r\ncase CM_RESPONSES:\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CP_CTRL_PKT,\r\nDBG_LVL_ALL,\r\n"MAC Version Seems to be Non Multi-Classifier, rejected by Driver");\r\nHighPriorityMessage = TRUE;\r\nbreak;\r\ncase CM_CONTROL_NEWDSX_MULTICLASSIFIER_RESP:\r\nHighPriorityMessage = TRUE;\r\nif (Adapter->LinkStatus == LINKUP_DONE)\r\nCmControlResponseMessage(Adapter,\r\n(skb->data + sizeof(USHORT)));\r\nbreak;\r\ncase LINK_CONTROL_RESP:\r\ncase STATUS_RSP:\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CP_CTRL_PKT,\r\nDBG_LVL_ALL, "LINK_CONTROL_RESP");\r\nHighPriorityMessage = TRUE;\r\nLinkControlResponseMessage(Adapter,\r\n(skb->data + sizeof(USHORT)));\r\nbreak;\r\ncase STATS_POINTER_RESP:\r\nHighPriorityMessage = TRUE;\r\nStatisticsResponse(Adapter, (skb->data + sizeof(USHORT)));\r\nbreak;\r\ncase IDLE_MODE_STATUS:\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CP_CTRL_PKT,\r\nDBG_LVL_ALL,\r\n"IDLE_MODE_STATUS Type Message Got from F/W");\r\nInterfaceIdleModeRespond(Adapter, (PUINT)(skb->data +\r\nsizeof(USHORT)));\r\nHighPriorityMessage = TRUE;\r\nbreak;\r\ncase AUTH_SS_HOST_MSG:\r\nHighPriorityMessage = TRUE;\r\nbreak;\r\ndefault:\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CP_CTRL_PKT,\r\nDBG_LVL_ALL, "Got Default Response");\r\nbreak;\r\n}\r\ndown(&Adapter->RxAppControlQueuelock);\r\nfor (pTarang = Adapter->pTarangs; pTarang; pTarang = pTarang->next) {\r\nif (Adapter->device_removed)\r\nbreak;\r\ndrop_pkt_flag = TRUE;\r\ncntrl_msg_mask_bit = (usStatus & 0x1F);\r\nif (pTarang->RxCntrlMsgBitMask & (1 << cntrl_msg_mask_bit))\r\ndrop_pkt_flag = FALSE;\r\nif ((drop_pkt_flag == TRUE) ||\r\n(pTarang->AppCtrlQueueLen > MAX_APP_QUEUE_LEN)\r\n|| ((pTarang->AppCtrlQueueLen >\r\nMAX_APP_QUEUE_LEN / 2) &&\r\n(HighPriorityMessage == FALSE))) {\r\nswitch (*(PUSHORT)skb->data) {\r\ncase CM_RESPONSES:\r\npTarang->stDroppedAppCntrlMsgs.cm_responses++;\r\nbreak;\r\ncase CM_CONTROL_NEWDSX_MULTICLASSIFIER_RESP:\r\npTarang->stDroppedAppCntrlMsgs.cm_control_newdsx_multiclassifier_resp++;\r\nbreak;\r\ncase LINK_CONTROL_RESP:\r\npTarang->stDroppedAppCntrlMsgs.link_control_resp++;\r\nbreak;\r\ncase STATUS_RSP:\r\npTarang->stDroppedAppCntrlMsgs.status_rsp++;\r\nbreak;\r\ncase STATS_POINTER_RESP:\r\npTarang->stDroppedAppCntrlMsgs.stats_pointer_resp++;\r\nbreak;\r\ncase IDLE_MODE_STATUS:\r\npTarang->stDroppedAppCntrlMsgs.idle_mode_status++;\r\nbreak;\r\ncase AUTH_SS_HOST_MSG:\r\npTarang->stDroppedAppCntrlMsgs.auth_ss_host_msg++;\r\nbreak;\r\ndefault:\r\npTarang->stDroppedAppCntrlMsgs.low_priority_message++;\r\nbreak;\r\n}\r\ncontinue;\r\n}\r\nnewPacket = skb_clone(skb, GFP_KERNEL);\r\nif (!newPacket)\r\nbreak;\r\nENQUEUEPACKET(pTarang->RxAppControlHead,\r\npTarang->RxAppControlTail, newPacket);\r\npTarang->AppCtrlQueueLen++;\r\n}\r\nup(&Adapter->RxAppControlQueuelock);\r\nwake_up(&Adapter->process_read_wait_queue);\r\ndev_kfree_skb(skb);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CP_CTRL_PKT, DBG_LVL_ALL,\r\n"After wake_up_interruptible");\r\n}\r\nint control_packet_handler(PMINI_ADAPTER Adapter )\r\n{\r\nstruct sk_buff *ctrl_packet = NULL;\r\nunsigned long flags = 0;\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CP_CTRL_PKT, DBG_LVL_ALL,\r\n"Entering to make thread wait on control packet event!");\r\nwhile (1) {\r\nwait_event_interruptible(Adapter->process_rx_cntrlpkt,\r\natomic_read(&Adapter->cntrlpktCnt) ||\r\nAdapter->bWakeUpDevice ||\r\nkthread_should_stop());\r\nif (kthread_should_stop()) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, CP_CTRL_PKT,\r\nDBG_LVL_ALL, "Exiting\n");\r\nreturn 0;\r\n}\r\nif (TRUE == Adapter->bWakeUpDevice) {\r\nAdapter->bWakeUpDevice = FALSE;\r\nif ((FALSE == Adapter->bTriedToWakeUpFromlowPowerMode)\r\n&& ((TRUE == Adapter->IdleMode) ||\r\n(TRUE == Adapter->bShutStatus))) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS,\r\nCP_CTRL_PKT, DBG_LVL_ALL,\r\n"Calling InterfaceAbortIdlemode\n");\r\nInterfaceIdleModeWakeup(Adapter);\r\n}\r\ncontinue;\r\n}\r\nwhile (atomic_read(&Adapter->cntrlpktCnt)) {\r\nspin_lock_irqsave(&Adapter->control_queue_lock, flags);\r\nctrl_packet = Adapter->RxControlHead;\r\nif (ctrl_packet) {\r\nDEQUEUEPACKET(Adapter->RxControlHead,\r\nAdapter->RxControlTail);\r\n}\r\nspin_unlock_irqrestore(&Adapter->control_queue_lock,\r\nflags);\r\nhandle_rx_control_packet(Adapter, ctrl_packet);\r\natomic_dec(&Adapter->cntrlpktCnt);\r\n}\r\nSetUpTargetDsxBuffers(Adapter);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nINT flushAllAppQ(void)\r\n{\r\nPMINI_ADAPTER Adapter = GET_BCM_ADAPTER(gblpnetdev);\r\nPPER_TARANG_DATA pTarang = NULL;\r\nstruct sk_buff *PacketToDrop = NULL;\r\nfor (pTarang = Adapter->pTarangs; pTarang; pTarang = pTarang->next) {\r\nwhile (pTarang->RxAppControlHead != NULL) {\r\nPacketToDrop = pTarang->RxAppControlHead;\r\nDEQUEUEPACKET(pTarang->RxAppControlHead,\r\npTarang->RxAppControlTail);\r\ndev_kfree_skb(PacketToDrop);\r\n}\r\npTarang->AppCtrlQueueLen = 0;\r\nmemset((PVOID)&pTarang->stDroppedAppCntrlMsgs, 0,\r\nsizeof(S_MIBS_DROPPED_APP_CNTRL_MESSAGES));\r\n}\r\nreturn STATUS_SUCCESS;\r\n}
