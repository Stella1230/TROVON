void mmc_decode_cid(struct mmc_card *card)\r\n{\r\nu32 *resp = card->raw_cid;\r\nmemset(&card->cid, 0, sizeof(struct mmc_cid));\r\ncard->cid.manfid = UNSTUFF_BITS(resp, 120, 8);\r\ncard->cid.oemid = UNSTUFF_BITS(resp, 104, 16);\r\ncard->cid.prod_name[0] = UNSTUFF_BITS(resp, 96, 8);\r\ncard->cid.prod_name[1] = UNSTUFF_BITS(resp, 88, 8);\r\ncard->cid.prod_name[2] = UNSTUFF_BITS(resp, 80, 8);\r\ncard->cid.prod_name[3] = UNSTUFF_BITS(resp, 72, 8);\r\ncard->cid.prod_name[4] = UNSTUFF_BITS(resp, 64, 8);\r\ncard->cid.hwrev = UNSTUFF_BITS(resp, 60, 4);\r\ncard->cid.fwrev = UNSTUFF_BITS(resp, 56, 4);\r\ncard->cid.serial = UNSTUFF_BITS(resp, 24, 32);\r\ncard->cid.year = UNSTUFF_BITS(resp, 12, 8);\r\ncard->cid.month = UNSTUFF_BITS(resp, 8, 4);\r\ncard->cid.year += 2000;\r\n}\r\nstatic int mmc_decode_csd(struct mmc_card *card)\r\n{\r\nstruct mmc_csd *csd = &card->csd;\r\nunsigned int e, m, csd_struct;\r\nu32 *resp = card->raw_csd;\r\ncsd_struct = UNSTUFF_BITS(resp, 126, 2);\r\nswitch (csd_struct) {\r\ncase 0:\r\nm = UNSTUFF_BITS(resp, 115, 4);\r\ne = UNSTUFF_BITS(resp, 112, 3);\r\ncsd->tacc_ns = (tacc_exp[e] * tacc_mant[m] + 9) / 10;\r\ncsd->tacc_clks = UNSTUFF_BITS(resp, 104, 8) * 100;\r\nm = UNSTUFF_BITS(resp, 99, 4);\r\ne = UNSTUFF_BITS(resp, 96, 3);\r\ncsd->max_dtr = tran_exp[e] * tran_mant[m];\r\ncsd->cmdclass = UNSTUFF_BITS(resp, 84, 12);\r\ne = UNSTUFF_BITS(resp, 47, 3);\r\nm = UNSTUFF_BITS(resp, 62, 12);\r\ncsd->capacity = (1 + m) << (e + 2);\r\ncsd->read_blkbits = UNSTUFF_BITS(resp, 80, 4);\r\ncsd->read_partial = UNSTUFF_BITS(resp, 79, 1);\r\ncsd->write_misalign = UNSTUFF_BITS(resp, 78, 1);\r\ncsd->read_misalign = UNSTUFF_BITS(resp, 77, 1);\r\ncsd->r2w_factor = UNSTUFF_BITS(resp, 26, 3);\r\ncsd->write_blkbits = UNSTUFF_BITS(resp, 22, 4);\r\ncsd->write_partial = UNSTUFF_BITS(resp, 21, 1);\r\nif (UNSTUFF_BITS(resp, 46, 1)) {\r\ncsd->erase_size = 1;\r\n} else if (csd->write_blkbits >= 9) {\r\ncsd->erase_size = UNSTUFF_BITS(resp, 39, 7) + 1;\r\ncsd->erase_size <<= csd->write_blkbits - 9;\r\n}\r\nbreak;\r\ncase 1:\r\nmmc_card_set_blockaddr(card);\r\ncsd->tacc_ns = 0;\r\ncsd->tacc_clks = 0;\r\nm = UNSTUFF_BITS(resp, 99, 4);\r\ne = UNSTUFF_BITS(resp, 96, 3);\r\ncsd->max_dtr = tran_exp[e] * tran_mant[m];\r\ncsd->cmdclass = UNSTUFF_BITS(resp, 84, 12);\r\ncsd->c_size = UNSTUFF_BITS(resp, 48, 22);\r\nif (csd->c_size >= 0xFFFF)\r\nmmc_card_set_ext_capacity(card);\r\nm = UNSTUFF_BITS(resp, 48, 22);\r\ncsd->capacity = (1 + m) << 10;\r\ncsd->read_blkbits = 9;\r\ncsd->read_partial = 0;\r\ncsd->write_misalign = 0;\r\ncsd->read_misalign = 0;\r\ncsd->r2w_factor = 4;\r\ncsd->write_blkbits = 9;\r\ncsd->write_partial = 0;\r\ncsd->erase_size = 1;\r\nbreak;\r\ndefault:\r\npr_err("%s: unrecognised CSD structure version %d\n",\r\nmmc_hostname(card->host), csd_struct);\r\nreturn -EINVAL;\r\n}\r\ncard->erase_size = csd->erase_size;\r\nreturn 0;\r\n}\r\nstatic int mmc_decode_scr(struct mmc_card *card)\r\n{\r\nstruct sd_scr *scr = &card->scr;\r\nunsigned int scr_struct;\r\nu32 resp[4];\r\nresp[3] = card->raw_scr[1];\r\nresp[2] = card->raw_scr[0];\r\nscr_struct = UNSTUFF_BITS(resp, 60, 4);\r\nif (scr_struct != 0) {\r\npr_err("%s: unrecognised SCR structure version %d\n",\r\nmmc_hostname(card->host), scr_struct);\r\nreturn -EINVAL;\r\n}\r\nscr->sda_vsn = UNSTUFF_BITS(resp, 56, 4);\r\nscr->bus_widths = UNSTUFF_BITS(resp, 48, 4);\r\nif (scr->sda_vsn == SCR_SPEC_VER_2)\r\nscr->sda_spec3 = UNSTUFF_BITS(resp, 47, 1);\r\nif (UNSTUFF_BITS(resp, 55, 1))\r\ncard->erased_byte = 0xFF;\r\nelse\r\ncard->erased_byte = 0x0;\r\nif (scr->sda_spec3)\r\nscr->cmds = UNSTUFF_BITS(resp, 32, 2);\r\nreturn 0;\r\n}\r\nstatic int mmc_read_ssr(struct mmc_card *card)\r\n{\r\nunsigned int au, es, et, eo;\r\nint err, i;\r\nu32 *ssr;\r\nif (!(card->csd.cmdclass & CCC_APP_SPEC)) {\r\npr_warning("%s: card lacks mandatory SD Status "\r\n"function.\n", mmc_hostname(card->host));\r\nreturn 0;\r\n}\r\nssr = kmalloc(64, GFP_KERNEL);\r\nif (!ssr)\r\nreturn -ENOMEM;\r\nerr = mmc_app_sd_status(card, ssr);\r\nif (err) {\r\npr_warning("%s: problem reading SD Status "\r\n"register.\n", mmc_hostname(card->host));\r\nerr = 0;\r\ngoto out;\r\n}\r\nfor (i = 0; i < 16; i++)\r\nssr[i] = be32_to_cpu(ssr[i]);\r\nau = UNSTUFF_BITS(ssr, 428 - 384, 4);\r\nif (au > 0 || au <= 9) {\r\ncard->ssr.au = 1 << (au + 4);\r\nes = UNSTUFF_BITS(ssr, 408 - 384, 16);\r\net = UNSTUFF_BITS(ssr, 402 - 384, 6);\r\neo = UNSTUFF_BITS(ssr, 400 - 384, 2);\r\nif (es && et) {\r\ncard->ssr.erase_timeout = (et * 1000) / es;\r\ncard->ssr.erase_offset = eo * 1000;\r\n}\r\n} else {\r\npr_warning("%s: SD Status: Invalid Allocation Unit "\r\n"size.\n", mmc_hostname(card->host));\r\n}\r\nout:\r\nkfree(ssr);\r\nreturn err;\r\n}\r\nstatic int mmc_read_switch(struct mmc_card *card)\r\n{\r\nint err;\r\nu8 *status;\r\nif (card->scr.sda_vsn < SCR_SPEC_VER_1)\r\nreturn 0;\r\nif (!(card->csd.cmdclass & CCC_SWITCH)) {\r\npr_warning("%s: card lacks mandatory switch "\r\n"function, performance might suffer.\n",\r\nmmc_hostname(card->host));\r\nreturn 0;\r\n}\r\nerr = -EIO;\r\nstatus = kmalloc(64, GFP_KERNEL);\r\nif (!status) {\r\npr_err("%s: could not allocate a buffer for "\r\n"switch capabilities.\n",\r\nmmc_hostname(card->host));\r\nreturn -ENOMEM;\r\n}\r\nerr = mmc_sd_switch(card, 0, 0, 1, status);\r\nif (err) {\r\nif (err != -EINVAL && err != -ENOSYS && err != -EFAULT)\r\ngoto out;\r\npr_warning("%s: problem reading Bus Speed modes.\n",\r\nmmc_hostname(card->host));\r\nerr = 0;\r\ngoto out;\r\n}\r\nif (status[13] & SD_MODE_HIGH_SPEED)\r\ncard->sw_caps.hs_max_dtr = HIGH_SPEED_MAX_DTR;\r\nif (card->scr.sda_spec3) {\r\ncard->sw_caps.sd3_bus_mode = status[13];\r\nerr = mmc_sd_switch(card, 0, 2, 1, status);\r\nif (err) {\r\nif (err != -EINVAL && err != -ENOSYS && err != -EFAULT)\r\ngoto out;\r\npr_warning("%s: problem reading "\r\n"Driver Strength.\n",\r\nmmc_hostname(card->host));\r\nerr = 0;\r\ngoto out;\r\n}\r\ncard->sw_caps.sd3_drv_type = status[9];\r\nerr = mmc_sd_switch(card, 0, 3, 1, status);\r\nif (err) {\r\nif (err != -EINVAL && err != -ENOSYS && err != -EFAULT)\r\ngoto out;\r\npr_warning("%s: problem reading "\r\n"Current Limit.\n",\r\nmmc_hostname(card->host));\r\nerr = 0;\r\ngoto out;\r\n}\r\ncard->sw_caps.sd3_curr_limit = status[7];\r\n}\r\nout:\r\nkfree(status);\r\nreturn err;\r\n}\r\nint mmc_sd_switch_hs(struct mmc_card *card)\r\n{\r\nint err;\r\nu8 *status;\r\nif (card->scr.sda_vsn < SCR_SPEC_VER_1)\r\nreturn 0;\r\nif (!(card->csd.cmdclass & CCC_SWITCH))\r\nreturn 0;\r\nif (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))\r\nreturn 0;\r\nif (card->sw_caps.hs_max_dtr == 0)\r\nreturn 0;\r\nerr = -EIO;\r\nstatus = kmalloc(64, GFP_KERNEL);\r\nif (!status) {\r\npr_err("%s: could not allocate a buffer for "\r\n"switch capabilities.\n", mmc_hostname(card->host));\r\nreturn -ENOMEM;\r\n}\r\nerr = mmc_sd_switch(card, 1, 0, 1, status);\r\nif (err)\r\ngoto out;\r\nif ((status[16] & 0xF) != 1) {\r\npr_warning("%s: Problem switching card "\r\n"into high-speed mode!\n",\r\nmmc_hostname(card->host));\r\nerr = 0;\r\n} else {\r\nerr = 1;\r\n}\r\nout:\r\nkfree(status);\r\nreturn err;\r\n}\r\nstatic int sd_select_driver_type(struct mmc_card *card, u8 *status)\r\n{\r\nint host_drv_type = SD_DRIVER_TYPE_B;\r\nint card_drv_type = SD_DRIVER_TYPE_B;\r\nint drive_strength;\r\nint err;\r\nif (!(card->host->caps & (MMC_CAP_DRIVER_TYPE_A | MMC_CAP_DRIVER_TYPE_C\r\n| MMC_CAP_DRIVER_TYPE_D)))\r\nreturn 0;\r\nif (!card->host->ops->select_drive_strength)\r\nreturn 0;\r\nif (card->host->caps & MMC_CAP_DRIVER_TYPE_A)\r\nhost_drv_type |= SD_DRIVER_TYPE_A;\r\nif (card->host->caps & MMC_CAP_DRIVER_TYPE_C)\r\nhost_drv_type |= SD_DRIVER_TYPE_C;\r\nif (card->host->caps & MMC_CAP_DRIVER_TYPE_D)\r\nhost_drv_type |= SD_DRIVER_TYPE_D;\r\nif (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_A)\r\ncard_drv_type |= SD_DRIVER_TYPE_A;\r\nif (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_C)\r\ncard_drv_type |= SD_DRIVER_TYPE_C;\r\nif (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_D)\r\ncard_drv_type |= SD_DRIVER_TYPE_D;\r\nmmc_host_clk_hold(card->host);\r\ndrive_strength = card->host->ops->select_drive_strength(\r\ncard->sw_caps.uhs_max_dtr,\r\nhost_drv_type, card_drv_type);\r\nmmc_host_clk_release(card->host);\r\nerr = mmc_sd_switch(card, 1, 2, drive_strength, status);\r\nif (err)\r\nreturn err;\r\nif ((status[15] & 0xF) != drive_strength) {\r\npr_warning("%s: Problem setting drive strength!\n",\r\nmmc_hostname(card->host));\r\nreturn 0;\r\n}\r\nmmc_set_driver_type(card->host, drive_strength);\r\nreturn 0;\r\n}\r\nstatic void sd_update_bus_speed_mode(struct mmc_card *card)\r\n{\r\nif (!(card->host->caps & (MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |\r\nMMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 | MMC_CAP_UHS_DDR50))) {\r\ncard->sd_bus_speed = 0;\r\nreturn;\r\n}\r\nif ((card->host->caps & MMC_CAP_UHS_SDR104) &&\r\n(card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR104)) {\r\ncard->sd_bus_speed = UHS_SDR104_BUS_SPEED;\r\n} else if ((card->host->caps & MMC_CAP_UHS_DDR50) &&\r\n(card->sw_caps.sd3_bus_mode & SD_MODE_UHS_DDR50)) {\r\ncard->sd_bus_speed = UHS_DDR50_BUS_SPEED;\r\n} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |\r\nMMC_CAP_UHS_SDR50)) && (card->sw_caps.sd3_bus_mode &\r\nSD_MODE_UHS_SDR50)) {\r\ncard->sd_bus_speed = UHS_SDR50_BUS_SPEED;\r\n} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |\r\nMMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR25)) &&\r\n(card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR25)) {\r\ncard->sd_bus_speed = UHS_SDR25_BUS_SPEED;\r\n} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |\r\nMMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR25 |\r\nMMC_CAP_UHS_SDR12)) && (card->sw_caps.sd3_bus_mode &\r\nSD_MODE_UHS_SDR12)) {\r\ncard->sd_bus_speed = UHS_SDR12_BUS_SPEED;\r\n}\r\n}\r\nstatic int sd_set_bus_speed_mode(struct mmc_card *card, u8 *status)\r\n{\r\nint err;\r\nunsigned int timing = 0;\r\nswitch (card->sd_bus_speed) {\r\ncase UHS_SDR104_BUS_SPEED:\r\ntiming = MMC_TIMING_UHS_SDR104;\r\ncard->sw_caps.uhs_max_dtr = UHS_SDR104_MAX_DTR;\r\nbreak;\r\ncase UHS_DDR50_BUS_SPEED:\r\ntiming = MMC_TIMING_UHS_DDR50;\r\ncard->sw_caps.uhs_max_dtr = UHS_DDR50_MAX_DTR;\r\nbreak;\r\ncase UHS_SDR50_BUS_SPEED:\r\ntiming = MMC_TIMING_UHS_SDR50;\r\ncard->sw_caps.uhs_max_dtr = UHS_SDR50_MAX_DTR;\r\nbreak;\r\ncase UHS_SDR25_BUS_SPEED:\r\ntiming = MMC_TIMING_UHS_SDR25;\r\ncard->sw_caps.uhs_max_dtr = UHS_SDR25_MAX_DTR;\r\nbreak;\r\ncase UHS_SDR12_BUS_SPEED:\r\ntiming = MMC_TIMING_UHS_SDR12;\r\ncard->sw_caps.uhs_max_dtr = UHS_SDR12_MAX_DTR;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nerr = mmc_sd_switch(card, 1, 0, card->sd_bus_speed, status);\r\nif (err)\r\nreturn err;\r\nif ((status[16] & 0xF) != card->sd_bus_speed)\r\npr_warning("%s: Problem setting bus speed mode!\n",\r\nmmc_hostname(card->host));\r\nelse {\r\nmmc_set_timing(card->host, timing);\r\nmmc_set_clock(card->host, card->sw_caps.uhs_max_dtr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_set_current_limit(struct mmc_card *card, u8 *status)\r\n{\r\nint current_limit = 0;\r\nint err;\r\nif ((card->sd_bus_speed == UHS_SDR50_BUS_SPEED) ||\r\n(card->sd_bus_speed == UHS_SDR104_BUS_SPEED) ||\r\n(card->sd_bus_speed == UHS_DDR50_BUS_SPEED)) {\r\nif (card->host->caps & MMC_CAP_MAX_CURRENT_800) {\r\nif (card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_800)\r\ncurrent_limit = SD_SET_CURRENT_LIMIT_800;\r\nelse if (card->sw_caps.sd3_curr_limit &\r\nSD_MAX_CURRENT_600)\r\ncurrent_limit = SD_SET_CURRENT_LIMIT_600;\r\nelse if (card->sw_caps.sd3_curr_limit &\r\nSD_MAX_CURRENT_400)\r\ncurrent_limit = SD_SET_CURRENT_LIMIT_400;\r\nelse if (card->sw_caps.sd3_curr_limit &\r\nSD_MAX_CURRENT_200)\r\ncurrent_limit = SD_SET_CURRENT_LIMIT_200;\r\n} else if (card->host->caps & MMC_CAP_MAX_CURRENT_600) {\r\nif (card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_600)\r\ncurrent_limit = SD_SET_CURRENT_LIMIT_600;\r\nelse if (card->sw_caps.sd3_curr_limit &\r\nSD_MAX_CURRENT_400)\r\ncurrent_limit = SD_SET_CURRENT_LIMIT_400;\r\nelse if (card->sw_caps.sd3_curr_limit &\r\nSD_MAX_CURRENT_200)\r\ncurrent_limit = SD_SET_CURRENT_LIMIT_200;\r\n} else if (card->host->caps & MMC_CAP_MAX_CURRENT_400) {\r\nif (card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_400)\r\ncurrent_limit = SD_SET_CURRENT_LIMIT_400;\r\nelse if (card->sw_caps.sd3_curr_limit &\r\nSD_MAX_CURRENT_200)\r\ncurrent_limit = SD_SET_CURRENT_LIMIT_200;\r\n} else if (card->host->caps & MMC_CAP_MAX_CURRENT_200) {\r\nif (card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_200)\r\ncurrent_limit = SD_SET_CURRENT_LIMIT_200;\r\n}\r\n} else\r\ncurrent_limit = SD_SET_CURRENT_LIMIT_200;\r\nerr = mmc_sd_switch(card, 1, 3, current_limit, status);\r\nif (err)\r\nreturn err;\r\nif (((status[15] >> 4) & 0x0F) != current_limit)\r\npr_warning("%s: Problem setting current limit!\n",\r\nmmc_hostname(card->host));\r\nreturn 0;\r\n}\r\nstatic int mmc_sd_init_uhs_card(struct mmc_card *card)\r\n{\r\nint err;\r\nu8 *status;\r\nif (!card->scr.sda_spec3)\r\nreturn 0;\r\nif (!(card->csd.cmdclass & CCC_SWITCH))\r\nreturn 0;\r\nstatus = kmalloc(64, GFP_KERNEL);\r\nif (!status) {\r\npr_err("%s: could not allocate a buffer for "\r\n"switch capabilities.\n", mmc_hostname(card->host));\r\nreturn -ENOMEM;\r\n}\r\nif ((card->host->caps & MMC_CAP_4_BIT_DATA) &&\r\n(card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {\r\nerr = mmc_app_set_bus_width(card, MMC_BUS_WIDTH_4);\r\nif (err)\r\ngoto out;\r\nmmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);\r\n}\r\nsd_update_bus_speed_mode(card);\r\nerr = sd_select_driver_type(card, status);\r\nif (err)\r\ngoto out;\r\nerr = sd_set_current_limit(card, status);\r\nif (err)\r\ngoto out;\r\nerr = sd_set_bus_speed_mode(card, status);\r\nif (err)\r\ngoto out;\r\nif (!mmc_host_is_spi(card->host) && card->host->ops->execute_tuning) {\r\nmmc_host_clk_hold(card->host);\r\nerr = card->host->ops->execute_tuning(card->host,\r\nMMC_SEND_TUNING_BLOCK);\r\nmmc_host_clk_release(card->host);\r\n}\r\nout:\r\nkfree(status);\r\nreturn err;\r\n}\r\nint mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid, u32 *rocr)\r\n{\r\nint err;\r\nmmc_go_idle(host);\r\nerr = mmc_send_if_cond(host, ocr);\r\nif (!err)\r\nocr |= SD_OCR_CCS;\r\nif (host->caps & (MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |\r\nMMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR104 | MMC_CAP_UHS_DDR50))\r\nocr |= SD_OCR_S18R;\r\nif (host->caps & (MMC_CAP_SET_XPC_330 | MMC_CAP_SET_XPC_300 |\r\nMMC_CAP_SET_XPC_180))\r\nocr |= SD_OCR_XPC;\r\ntry_again:\r\nerr = mmc_send_app_op_cond(host, ocr, rocr);\r\nif (err)\r\nreturn err;\r\nif (!mmc_host_is_spi(host) && rocr &&\r\n((*rocr & 0x41000000) == 0x41000000)) {\r\nerr = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180, true);\r\nif (err) {\r\nocr &= ~SD_OCR_S18R;\r\ngoto try_again;\r\n}\r\n}\r\nif (mmc_host_is_spi(host))\r\nerr = mmc_send_cid(host, cid);\r\nelse\r\nerr = mmc_all_send_cid(host, cid);\r\nreturn err;\r\n}\r\nint mmc_sd_get_csd(struct mmc_host *host, struct mmc_card *card)\r\n{\r\nint err;\r\nerr = mmc_send_csd(card, card->raw_csd);\r\nif (err)\r\nreturn err;\r\nerr = mmc_decode_csd(card);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint mmc_sd_setup_card(struct mmc_host *host, struct mmc_card *card,\r\nbool reinit)\r\n{\r\nint err;\r\nif (!reinit) {\r\nerr = mmc_app_send_scr(card, card->raw_scr);\r\nif (err)\r\nreturn err;\r\nerr = mmc_decode_scr(card);\r\nif (err)\r\nreturn err;\r\nerr = mmc_read_ssr(card);\r\nif (err)\r\nreturn err;\r\nmmc_init_erase(card);\r\nerr = mmc_read_switch(card);\r\nif (err)\r\nreturn err;\r\n}\r\nif (mmc_host_is_spi(host)) {\r\nerr = mmc_spi_set_crc(host, use_spi_crc);\r\nif (err)\r\nreturn err;\r\n}\r\nif (!reinit) {\r\nint ro = -1;\r\nif (host->ops->get_ro) {\r\nmmc_host_clk_hold(card->host);\r\nro = host->ops->get_ro(host);\r\nmmc_host_clk_release(card->host);\r\n}\r\nif (ro < 0) {\r\npr_warning("%s: host does not "\r\n"support reading read-only "\r\n"switch. assuming write-enable.\n",\r\nmmc_hostname(host));\r\n} else if (ro > 0) {\r\nmmc_card_set_readonly(card);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nunsigned mmc_sd_get_max_clock(struct mmc_card *card)\r\n{\r\nunsigned max_dtr = (unsigned int)-1;\r\nif (mmc_card_highspeed(card)) {\r\nif (max_dtr > card->sw_caps.hs_max_dtr)\r\nmax_dtr = card->sw_caps.hs_max_dtr;\r\n} else if (max_dtr > card->csd.max_dtr) {\r\nmax_dtr = card->csd.max_dtr;\r\n}\r\nreturn max_dtr;\r\n}\r\nvoid mmc_sd_go_highspeed(struct mmc_card *card)\r\n{\r\nmmc_card_set_highspeed(card);\r\nmmc_set_timing(card->host, MMC_TIMING_SD_HS);\r\n}\r\nstatic int mmc_sd_init_card(struct mmc_host *host, u32 ocr,\r\nstruct mmc_card *oldcard)\r\n{\r\nstruct mmc_card *card;\r\nint err;\r\nu32 cid[4];\r\nu32 rocr = 0;\r\nBUG_ON(!host);\r\nWARN_ON(!host->claimed);\r\nmmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330, 0);\r\nerr = mmc_sd_get_cid(host, ocr, cid, &rocr);\r\nif (err)\r\nreturn err;\r\nif (oldcard) {\r\nif (memcmp(cid, oldcard->raw_cid, sizeof(cid)) != 0)\r\nreturn -ENOENT;\r\ncard = oldcard;\r\n} else {\r\ncard = mmc_alloc_card(host, &sd_type);\r\nif (IS_ERR(card))\r\nreturn PTR_ERR(card);\r\ncard->type = MMC_TYPE_SD;\r\nmemcpy(card->raw_cid, cid, sizeof(card->raw_cid));\r\n}\r\nif (!mmc_host_is_spi(host)) {\r\nerr = mmc_send_relative_addr(host, &card->rca);\r\nif (err)\r\nreturn err;\r\n}\r\nif (!oldcard) {\r\nerr = mmc_sd_get_csd(host, card);\r\nif (err)\r\nreturn err;\r\nmmc_decode_cid(card);\r\n}\r\nif (!mmc_host_is_spi(host)) {\r\nerr = mmc_select_card(card);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = mmc_sd_setup_card(host, card, oldcard != NULL);\r\nif (err)\r\ngoto free_card;\r\nif (rocr & SD_ROCR_S18A) {\r\nerr = mmc_sd_init_uhs_card(card);\r\nif (err)\r\ngoto free_card;\r\nmmc_card_set_uhs(card);\r\nif (host->ops->enable_preset_value) {\r\nmmc_host_clk_hold(card->host);\r\nhost->ops->enable_preset_value(host, true);\r\nmmc_host_clk_release(card->host);\r\n}\r\n} else {\r\nerr = mmc_sd_switch_hs(card);\r\nif (err > 0)\r\nmmc_sd_go_highspeed(card);\r\nelse if (err)\r\ngoto free_card;\r\nmmc_set_clock(host, mmc_sd_get_max_clock(card));\r\nif ((host->caps & MMC_CAP_4_BIT_DATA) &&\r\n(card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {\r\nerr = mmc_app_set_bus_width(card, MMC_BUS_WIDTH_4);\r\nif (err)\r\ngoto free_card;\r\nmmc_set_bus_width(host, MMC_BUS_WIDTH_4);\r\n}\r\n}\r\nhost->card = card;\r\nreturn 0;\r\nfree_card:\r\nif (!oldcard)\r\nmmc_remove_card(card);\r\nreturn err;\r\n}\r\nstatic void mmc_sd_remove(struct mmc_host *host)\r\n{\r\nBUG_ON(!host);\r\nBUG_ON(!host->card);\r\nmmc_remove_card(host->card);\r\nhost->card = NULL;\r\n}\r\nstatic int mmc_sd_alive(struct mmc_host *host)\r\n{\r\nreturn mmc_send_status(host->card, NULL);\r\n}\r\nstatic void mmc_sd_detect(struct mmc_host *host)\r\n{\r\nint err;\r\nBUG_ON(!host);\r\nBUG_ON(!host->card);\r\nmmc_claim_host(host);\r\nerr = _mmc_detect_card_removed(host);\r\nmmc_release_host(host);\r\nif (err) {\r\nmmc_sd_remove(host);\r\nmmc_claim_host(host);\r\nmmc_detach_bus(host);\r\nmmc_power_off(host);\r\nmmc_release_host(host);\r\n}\r\n}\r\nstatic int mmc_sd_suspend(struct mmc_host *host)\r\n{\r\nBUG_ON(!host);\r\nBUG_ON(!host->card);\r\nmmc_claim_host(host);\r\nif (!mmc_host_is_spi(host))\r\nmmc_deselect_cards(host);\r\nhost->card->state &= ~MMC_STATE_HIGHSPEED;\r\nmmc_release_host(host);\r\nreturn 0;\r\n}\r\nstatic int mmc_sd_resume(struct mmc_host *host)\r\n{\r\nint err;\r\nBUG_ON(!host);\r\nBUG_ON(!host->card);\r\nmmc_claim_host(host);\r\nerr = mmc_sd_init_card(host, host->ocr, host->card);\r\nmmc_release_host(host);\r\nreturn err;\r\n}\r\nstatic int mmc_sd_power_restore(struct mmc_host *host)\r\n{\r\nint ret;\r\nhost->card->state &= ~MMC_STATE_HIGHSPEED;\r\nmmc_claim_host(host);\r\nret = mmc_sd_init_card(host, host->ocr, host->card);\r\nmmc_release_host(host);\r\nreturn ret;\r\n}\r\nstatic void mmc_sd_attach_bus_ops(struct mmc_host *host)\r\n{\r\nconst struct mmc_bus_ops *bus_ops;\r\nif (!mmc_card_is_removable(host))\r\nbus_ops = &mmc_sd_ops_unsafe;\r\nelse\r\nbus_ops = &mmc_sd_ops;\r\nmmc_attach_bus(host, bus_ops);\r\n}\r\nint mmc_attach_sd(struct mmc_host *host)\r\n{\r\nint err;\r\nu32 ocr;\r\nBUG_ON(!host);\r\nWARN_ON(!host->claimed);\r\nif (host->ops->enable_preset_value) {\r\nmmc_host_clk_hold(host);\r\nhost->ops->enable_preset_value(host, false);\r\nmmc_host_clk_release(host);\r\n}\r\nerr = mmc_send_app_op_cond(host, 0, &ocr);\r\nif (err)\r\nreturn err;\r\nmmc_sd_attach_bus_ops(host);\r\nif (host->ocr_avail_sd)\r\nhost->ocr_avail = host->ocr_avail_sd;\r\nif (mmc_host_is_spi(host)) {\r\nmmc_go_idle(host);\r\nerr = mmc_spi_read_ocr(host, 0, &ocr);\r\nif (err)\r\ngoto err;\r\n}\r\nif (ocr & 0x7F) {\r\npr_warning("%s: card claims to support voltages "\r\n"below the defined range. These will be ignored.\n",\r\nmmc_hostname(host));\r\nocr &= ~0x7F;\r\n}\r\nif ((ocr & MMC_VDD_165_195) &&\r\n!(host->ocr_avail_sd & MMC_VDD_165_195)) {\r\npr_warning("%s: SD card claims to support the "\r\n"incompletely defined 'low voltage range'. This "\r\n"will be ignored.\n", mmc_hostname(host));\r\nocr &= ~MMC_VDD_165_195;\r\n}\r\nhost->ocr = mmc_select_voltage(host, ocr);\r\nif (!host->ocr) {\r\nerr = -EINVAL;\r\ngoto err;\r\n}\r\nerr = mmc_sd_init_card(host, host->ocr, NULL);\r\nif (err)\r\ngoto err;\r\nmmc_release_host(host);\r\nerr = mmc_add_card(host->card);\r\nmmc_claim_host(host);\r\nif (err)\r\ngoto remove_card;\r\nreturn 0;\r\nremove_card:\r\nmmc_release_host(host);\r\nmmc_remove_card(host->card);\r\nhost->card = NULL;\r\nmmc_claim_host(host);\r\nerr:\r\nmmc_detach_bus(host);\r\npr_err("%s: error %d whilst initialising SD card\n",\r\nmmc_hostname(host), err);\r\nreturn err;\r\n}
