short ieee80211_is_54g(const struct ieee80211_network *net)\r\n{\r\nreturn (net->rates_ex_len > 0) || (net->rates_len > 4);\r\n}\r\nshort ieee80211_is_shortslot(const struct ieee80211_network *net)\r\n{\r\nreturn net->capability & WLAN_CAPABILITY_SHORT_SLOT;\r\n}\r\nunsigned int ieee80211_MFIE_rate_len(struct ieee80211_device *ieee)\r\n{\r\nunsigned int rate_len = 0;\r\nif (ieee->modulation & IEEE80211_CCK_MODULATION)\r\nrate_len = IEEE80211_CCK_RATE_LEN + 2;\r\nif (ieee->modulation & IEEE80211_OFDM_MODULATION)\r\nrate_len += IEEE80211_OFDM_RATE_LEN + 2;\r\nreturn rate_len;\r\n}\r\nvoid ieee80211_MFIE_Brate(struct ieee80211_device *ieee, u8 **tag_p)\r\n{\r\nu8 *tag = *tag_p;\r\nif (ieee->modulation & IEEE80211_CCK_MODULATION){\r\n*tag++ = MFIE_TYPE_RATES;\r\n*tag++ = 4;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_1MB;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_2MB;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_5MB;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_11MB;\r\n}\r\n*tag_p = tag;\r\n}\r\nvoid ieee80211_MFIE_Grate(struct ieee80211_device *ieee, u8 **tag_p)\r\n{\r\nu8 *tag = *tag_p;\r\nif (ieee->modulation & IEEE80211_OFDM_MODULATION){\r\n*tag++ = MFIE_TYPE_RATES_EX;\r\n*tag++ = 8;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_6MB;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_9MB;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_12MB;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_18MB;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_24MB;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_36MB;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_48MB;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_54MB;\r\n}\r\n*tag_p = tag;\r\n}\r\nvoid ieee80211_WMM_Info(struct ieee80211_device *ieee, u8 **tag_p) {\r\nu8 *tag = *tag_p;\r\n*tag++ = MFIE_TYPE_GENERIC;\r\n*tag++ = 7;\r\n*tag++ = 0x00;\r\n*tag++ = 0x50;\r\n*tag++ = 0xf2;\r\n*tag++ = 0x02;\r\n*tag++ = 0x00;\r\n*tag++ = 0x01;\r\n#ifdef SUPPORT_USPD\r\nif(ieee->current_network.wmm_info & 0x80) {\r\n*tag++ = 0x0f|MAX_SP_Len;\r\n} else {\r\n*tag++ = MAX_SP_Len;\r\n}\r\n#else\r\n*tag++ = MAX_SP_Len;\r\n#endif\r\n*tag_p = tag;\r\n}\r\nvoid ieee80211_TURBO_Info(struct ieee80211_device *ieee, u8 **tag_p) {\r\nu8 *tag = *tag_p;\r\n*tag++ = MFIE_TYPE_GENERIC;\r\n*tag++ = 7;\r\n*tag++ = 0x00;\r\n*tag++ = 0xe0;\r\n*tag++ = 0x4c;\r\n*tag++ = 0x01;\r\n*tag++ = 0x02;\r\n*tag++ = 0x11;\r\n*tag++ = 0x00;\r\n*tag_p = tag;\r\nprintk(KERN_ALERT "This is enable turbo mode IE process\n");\r\n}\r\nvoid enqueue_mgmt(struct ieee80211_device *ieee, struct sk_buff *skb)\r\n{\r\nint nh;\r\nnh = (ieee->mgmt_queue_head +1) % MGMT_QUEUE_NUM;\r\nieee->mgmt_queue_head = nh;\r\nieee->mgmt_queue_ring[nh] = skb;\r\n}\r\nstruct sk_buff *dequeue_mgmt(struct ieee80211_device *ieee)\r\n{\r\nstruct sk_buff *ret;\r\nif(ieee->mgmt_queue_tail == ieee->mgmt_queue_head)\r\nreturn NULL;\r\nret = ieee->mgmt_queue_ring[ieee->mgmt_queue_tail];\r\nieee->mgmt_queue_tail =\r\n(ieee->mgmt_queue_tail+1) % MGMT_QUEUE_NUM;\r\nreturn ret;\r\n}\r\nvoid init_mgmt_queue(struct ieee80211_device *ieee)\r\n{\r\nieee->mgmt_queue_tail = ieee->mgmt_queue_head = 0;\r\n}\r\ninline void softmac_mgmt_xmit(struct sk_buff *skb, struct ieee80211_device *ieee)\r\n{\r\nunsigned long flags;\r\nshort single = ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE;\r\nstruct ieee80211_hdr_3addr *header=\r\n(struct ieee80211_hdr_3addr *) skb->data;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nieee80211_sta_wakeup(ieee,0);\r\nif(single){\r\nif(ieee->queue_stop){\r\nenqueue_mgmt(ieee,skb);\r\n}else{\r\nheader->seq_ctrl = cpu_to_le16(ieee->seq_ctrl[0]<<4);\r\nif (ieee->seq_ctrl[0] == 0xFFF)\r\nieee->seq_ctrl[0] = 0;\r\nelse\r\nieee->seq_ctrl[0]++;\r\nieee->dev->trans_start = jiffies;\r\nieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}else{\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\nspin_lock_irqsave(&ieee->mgmt_tx_lock, flags);\r\nheader->seq_ctrl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\r\nif (ieee->seq_ctrl[0] == 0xFFF)\r\nieee->seq_ctrl[0] = 0;\r\nelse\r\nieee->seq_ctrl[0]++;\r\nieee->dev->trans_start = jiffies;\r\nieee->softmac_hard_start_xmit(skb,ieee->dev);\r\nspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags);\r\n}\r\n}\r\ninline void softmac_ps_mgmt_xmit(struct sk_buff *skb, struct ieee80211_device *ieee)\r\n{\r\nshort single = ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE;\r\nstruct ieee80211_hdr_3addr *header =\r\n(struct ieee80211_hdr_3addr *) skb->data;\r\nif(single){\r\nheader->seq_ctrl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\r\nif (ieee->seq_ctrl[0] == 0xFFF)\r\nieee->seq_ctrl[0] = 0;\r\nelse\r\nieee->seq_ctrl[0]++;\r\nieee->dev->trans_start = jiffies;\r\nieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);\r\n}else{\r\nheader->seq_ctrl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\r\nif (ieee->seq_ctrl[0] == 0xFFF)\r\nieee->seq_ctrl[0] = 0;\r\nelse\r\nieee->seq_ctrl[0]++;\r\nieee->dev->trans_start = jiffies;\r\nieee->softmac_hard_start_xmit(skb,ieee->dev);\r\n}\r\n}\r\ninline struct sk_buff *ieee80211_disassociate_skb(\r\nstruct ieee80211_network *beacon,\r\nstruct ieee80211_device *ieee,\r\nu8 asRsn)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ieee80211_disassoc_frame *disass;\r\nskb = dev_alloc_skb(sizeof(struct ieee80211_disassoc_frame));\r\nif (!skb)\r\nreturn NULL;\r\ndisass = (struct ieee80211_disassoc_frame *) skb_put(skb,sizeof(struct ieee80211_disassoc_frame));\r\ndisass->header.frame_control = cpu_to_le16(IEEE80211_STYPE_DISASSOC);\r\ndisass->header.duration_id = 0;\r\nmemcpy(disass->header.addr1, beacon->bssid, ETH_ALEN);\r\nmemcpy(disass->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\r\nmemcpy(disass->header.addr3, beacon->bssid, ETH_ALEN);\r\ndisass->reasoncode = asRsn;\r\nreturn skb;\r\n}\r\nvoid\r\nSendDisassociation(\r\nstruct ieee80211_device *ieee,\r\nu8* asSta,\r\nu8 asRsn\r\n)\r\n{\r\nstruct ieee80211_network *beacon = &ieee->current_network;\r\nstruct sk_buff *skb;\r\nskb = ieee80211_disassociate_skb(beacon,ieee,asRsn);\r\nif (skb){\r\nsoftmac_mgmt_xmit(skb, ieee);\r\n}\r\n}\r\ninline struct sk_buff *ieee80211_probe_req(struct ieee80211_device *ieee)\r\n{\r\nunsigned int len,rate_len;\r\nu8 *tag;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_probe_request *req;\r\nlen = ieee->current_network.ssid_len;\r\nrate_len = ieee80211_MFIE_rate_len(ieee);\r\nskb = dev_alloc_skb(sizeof(struct ieee80211_probe_request) +\r\n2 + len + rate_len);\r\nif (!skb)\r\nreturn NULL;\r\nreq = (struct ieee80211_probe_request *) skb_put(skb,sizeof(struct ieee80211_probe_request));\r\nreq->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_PROBE_REQ);\r\nreq->header.duration_id = 0;\r\nmemset(req->header.addr1, 0xff, ETH_ALEN);\r\nmemcpy(req->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\r\nmemset(req->header.addr3, 0xff, ETH_ALEN);\r\ntag = (u8 *) skb_put(skb,len+2+rate_len);\r\n*tag++ = MFIE_TYPE_SSID;\r\n*tag++ = len;\r\nmemcpy(tag, ieee->current_network.ssid, len);\r\ntag += len;\r\nieee80211_MFIE_Brate(ieee,&tag);\r\nieee80211_MFIE_Grate(ieee,&tag);\r\nreturn skb;\r\n}\r\nvoid ext_ieee80211_send_beacon_wq(struct ieee80211_device *ieee)\r\n{\r\nstruct sk_buff *skb;\r\nskb = ieee80211_get_beacon_(ieee);\r\nif (skb){\r\nsoftmac_mgmt_xmit(skb, ieee);\r\nieee->softmac_stats.tx_beacons++;\r\ndev_kfree_skb_any(skb);\r\n}\r\nieee->beacon_timer.expires = jiffies +\r\n(MSECS( ieee->current_network.beacon_interval -5));\r\nif(ieee->beacon_txing)\r\nadd_timer(&ieee->beacon_timer);\r\n}\r\nvoid ieee80211_send_beacon(struct ieee80211_device *ieee)\r\n{\r\nstruct sk_buff *skb;\r\nskb = ieee80211_get_beacon_(ieee);\r\nif (skb){\r\nsoftmac_mgmt_xmit(skb, ieee);\r\nieee->softmac_stats.tx_beacons++;\r\ndev_kfree_skb_any(skb);\r\n}\r\nieee->beacon_timer.expires = jiffies +\r\n(MSECS( ieee->current_network.beacon_interval -5));\r\nif(ieee->beacon_txing)\r\nadd_timer(&ieee->beacon_timer);\r\n}\r\nvoid ieee80211_send_beacon_cb(unsigned long _ieee)\r\n{\r\nstruct ieee80211_device *ieee =\r\n(struct ieee80211_device *) _ieee;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ieee->beacon_lock, flags);\r\nieee80211_send_beacon(ieee);\r\nspin_unlock_irqrestore(&ieee->beacon_lock, flags);\r\n}\r\nvoid ieee80211_send_probe(struct ieee80211_device *ieee)\r\n{\r\nstruct sk_buff *skb;\r\nskb = ieee80211_probe_req(ieee);\r\nif (skb){\r\nsoftmac_mgmt_xmit(skb, ieee);\r\nieee->softmac_stats.tx_probe_rq++;\r\n}\r\n}\r\nvoid ieee80211_send_probe_requests(struct ieee80211_device *ieee)\r\n{\r\nif (ieee->active_scan && (ieee->softmac_features & IEEE_SOFTMAC_PROBERQ)){\r\nieee80211_send_probe(ieee);\r\nieee80211_send_probe(ieee);\r\n}\r\n}\r\nvoid ieee80211_softmac_scan_syncro(struct ieee80211_device *ieee)\r\n{\r\nshort ch = 0;\r\nu8 channel_map[MAX_CHANNEL_NUMBER+1];\r\nmemcpy(channel_map, GET_DOT11D_INFO(ieee)->channel_map, MAX_CHANNEL_NUMBER+1);\r\ndown(&ieee->scan_sem);\r\nwhile(1)\r\n{\r\ndo{\r\nch++;\r\nif (ch > MAX_CHANNEL_NUMBER)\r\ngoto out;\r\n}while(!channel_map[ch]);\r\nif (ieee->state == IEEE80211_LINKED)\r\ngoto out;\r\nieee->set_chan(ieee->dev, ch);\r\nif(channel_map[ch] == 1)\r\n{\r\nieee80211_send_probe_requests(ieee);\r\n}\r\nif (ieee->sync_scan_hurryup)\r\ngoto out;\r\nmsleep_interruptible_rtl(IEEE80211_SOFTMAC_SCAN_TIME);\r\n}\r\nout:\r\nieee->sync_scan_hurryup = 0;\r\nup(&ieee->scan_sem);\r\nif(IS_DOT11D_ENABLE(ieee))\r\nDOT11D_ScanComplete(ieee);\r\n}\r\nvoid ieee80211_softmac_ips_scan_syncro(struct ieee80211_device *ieee)\r\n{\r\nint ch;\r\nunsigned int watch_dog = 0;\r\nu8 channel_map[MAX_CHANNEL_NUMBER+1];\r\nmemcpy(channel_map, GET_DOT11D_INFO(ieee)->channel_map, MAX_CHANNEL_NUMBER+1);\r\ndown(&ieee->scan_sem);\r\nch = ieee->current_network.channel;\r\nwhile(1)\r\n{\r\nif (ieee->state == IEEE80211_LINKED)\r\n{\r\ngoto out;\r\n}\r\nif(channel_map[ieee->current_network.channel] > 0)\r\n{\r\nieee->set_chan(ieee->dev, ieee->current_network.channel);\r\n}\r\nif(channel_map[ieee->current_network.channel] == 1)\r\n{\r\nieee80211_send_probe_requests(ieee);\r\n}\r\nmsleep_interruptible_rtl(IEEE80211_SOFTMAC_SCAN_TIME);\r\ndo{\r\nif (watch_dog++ >= MAX_CHANNEL_NUMBER)\r\ngoto out;\r\nieee->current_network.channel = (ieee->current_network.channel + 1)%MAX_CHANNEL_NUMBER;\r\n}while(!channel_map[ieee->current_network.channel]);\r\n}\r\nout:\r\nieee->actscanning = false;\r\nup(&ieee->scan_sem);\r\nif(IS_DOT11D_ENABLE(ieee))\r\nDOT11D_ScanComplete(ieee);\r\n}\r\nvoid ieee80211_softmac_scan_wq(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, softmac_scan_wq);\r\nstatic short watchdog = 0;\r\nu8 channel_map[MAX_CHANNEL_NUMBER+1];\r\nmemcpy(channel_map, GET_DOT11D_INFO(ieee)->channel_map, MAX_CHANNEL_NUMBER+1);\r\ndown(&ieee->scan_sem);\r\ndo{\r\nieee->current_network.channel =\r\n(ieee->current_network.channel + 1) % MAX_CHANNEL_NUMBER;\r\nif (watchdog++ > MAX_CHANNEL_NUMBER)\r\ngoto out;\r\n}while(!channel_map[ieee->current_network.channel]);\r\nif (ieee->scanning == 0 )\r\n{\r\nprintk("error out, scanning = 0\n");\r\ngoto out;\r\n}\r\nieee->set_chan(ieee->dev, ieee->current_network.channel);\r\nif(channel_map[ieee->current_network.channel] == 1)\r\nieee80211_send_probe_requests(ieee);\r\nqueue_delayed_work(ieee->wq, &ieee->softmac_scan_wq, IEEE80211_SOFTMAC_SCAN_TIME);\r\nup(&ieee->scan_sem);\r\nreturn;\r\nout:\r\nieee->actscanning = false;\r\nwatchdog = 0;\r\nieee->scanning = 0;\r\nup(&ieee->scan_sem);\r\nif(IS_DOT11D_ENABLE(ieee))\r\nDOT11D_ScanComplete(ieee);\r\nreturn;\r\n}\r\nvoid ieee80211_beacons_start(struct ieee80211_device *ieee)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ieee->beacon_lock,flags);\r\nieee->beacon_txing = 1;\r\nieee80211_send_beacon(ieee);\r\nspin_unlock_irqrestore(&ieee->beacon_lock,flags);\r\n}\r\nvoid ieee80211_beacons_stop(struct ieee80211_device *ieee)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ieee->beacon_lock,flags);\r\nieee->beacon_txing = 0;\r\ndel_timer_sync(&ieee->beacon_timer);\r\nspin_unlock_irqrestore(&ieee->beacon_lock,flags);\r\n}\r\nvoid ieee80211_stop_send_beacons(struct ieee80211_device *ieee)\r\n{\r\nif(ieee->stop_send_beacons)\r\nieee->stop_send_beacons(ieee->dev);\r\nif (ieee->softmac_features & IEEE_SOFTMAC_BEACONS)\r\nieee80211_beacons_stop(ieee);\r\n}\r\nvoid ieee80211_start_send_beacons(struct ieee80211_device *ieee)\r\n{\r\nif(ieee->start_send_beacons)\r\nieee->start_send_beacons(ieee->dev);\r\nif(ieee->softmac_features & IEEE_SOFTMAC_BEACONS)\r\nieee80211_beacons_start(ieee);\r\n}\r\nvoid ieee80211_softmac_stop_scan(struct ieee80211_device *ieee)\r\n{\r\ndown(&ieee->scan_sem);\r\nif (ieee->scanning == 1){\r\nieee->scanning = 0;\r\ncancel_delayed_work(&ieee->softmac_scan_wq);\r\n}\r\nup(&ieee->scan_sem);\r\n}\r\nvoid ieee80211_stop_scan(struct ieee80211_device *ieee)\r\n{\r\nif (ieee->softmac_features & IEEE_SOFTMAC_SCAN)\r\nieee80211_softmac_stop_scan(ieee);\r\nelse\r\nieee->stop_scan(ieee->dev);\r\n}\r\nvoid ieee80211_rtl_start_scan(struct ieee80211_device *ieee)\r\n{\r\nif(IS_DOT11D_ENABLE(ieee) )\r\n{\r\nif(IS_COUNTRY_IE_VALID(ieee))\r\n{\r\nRESET_CIE_WATCHDOG(ieee);\r\n}\r\n}\r\nif (ieee->softmac_features & IEEE_SOFTMAC_SCAN){\r\nif (ieee->scanning == 0)\r\n{\r\nieee->scanning = 1;\r\n#if 1\r\nqueue_delayed_work(ieee->wq, &ieee->softmac_scan_wq,0);\r\n#endif\r\n}\r\n}else\r\nieee->start_scan(ieee->dev);\r\n}\r\nvoid ieee80211_start_scan_syncro(struct ieee80211_device *ieee)\r\n{\r\nif(IS_DOT11D_ENABLE(ieee) )\r\n{\r\nif(IS_COUNTRY_IE_VALID(ieee))\r\n{\r\nRESET_CIE_WATCHDOG(ieee);\r\n}\r\n}\r\nieee->sync_scan_hurryup = 0;\r\nif (ieee->softmac_features & IEEE_SOFTMAC_SCAN)\r\nieee80211_softmac_scan_syncro(ieee);\r\nelse\r\nieee->scan_syncro(ieee->dev);\r\n}\r\ninline struct sk_buff *ieee80211_authentication_req(struct ieee80211_network *beacon,\r\nstruct ieee80211_device *ieee, int challengelen)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ieee80211_authentication *auth;\r\nskb = dev_alloc_skb(sizeof(struct ieee80211_authentication) + challengelen);\r\nif (!skb) return NULL;\r\nauth = (struct ieee80211_authentication *)\r\nskb_put(skb, sizeof(struct ieee80211_authentication));\r\nauth->header.frame_ctl = IEEE80211_STYPE_AUTH;\r\nif (challengelen) auth->header.frame_ctl |= IEEE80211_FCTL_WEP;\r\nauth->header.duration_id = 0x013a;\r\nmemcpy(auth->header.addr1, beacon->bssid, ETH_ALEN);\r\nmemcpy(auth->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\r\nmemcpy(auth->header.addr3, beacon->bssid, ETH_ALEN);\r\nauth->algorithm = ieee->open_wep ? WLAN_AUTH_OPEN : WLAN_AUTH_SHARED_KEY;\r\nauth->transaction = cpu_to_le16(ieee->associate_seq);\r\nieee->associate_seq++;\r\nauth->status = cpu_to_le16(WLAN_STATUS_SUCCESS);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff* ieee80211_probe_resp(struct ieee80211_device *ieee, u8 *dest)\r\n{\r\nu8 *tag;\r\nint beacon_size;\r\nstruct ieee80211_probe_response *beacon_buf;\r\nstruct sk_buff *skb;\r\nint encrypt;\r\nint atim_len,erp_len;\r\nstruct ieee80211_crypt_data* crypt;\r\nchar *ssid = ieee->current_network.ssid;\r\nint ssid_len = ieee->current_network.ssid_len;\r\nint rate_len = ieee->current_network.rates_len+2;\r\nint rate_ex_len = ieee->current_network.rates_ex_len;\r\nint wpa_ie_len = ieee->wpa_ie_len;\r\nif(rate_ex_len > 0) rate_ex_len+=2;\r\nif(ieee->current_network.capability & WLAN_CAPABILITY_IBSS)\r\natim_len = 4;\r\nelse\r\natim_len = 0;\r\nif(ieee80211_is_54g(&ieee->current_network))\r\nerp_len = 3;\r\nelse\r\nerp_len = 0;\r\nbeacon_size = sizeof(struct ieee80211_probe_response)+\r\nssid_len\r\n+3\r\n+rate_len\r\n+rate_ex_len\r\n+atim_len\r\n+wpa_ie_len\r\n+erp_len;\r\nskb = dev_alloc_skb(beacon_size);\r\nif (!skb)\r\nreturn NULL;\r\nbeacon_buf = (struct ieee80211_probe_response*) skb_put(skb, beacon_size);\r\nmemcpy (beacon_buf->header.addr1, dest,ETH_ALEN);\r\nmemcpy (beacon_buf->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\r\nmemcpy (beacon_buf->header.addr3, ieee->current_network.bssid, ETH_ALEN);\r\nbeacon_buf->header.duration_id = 0;\r\nbeacon_buf->beacon_interval =\r\ncpu_to_le16(ieee->current_network.beacon_interval);\r\nbeacon_buf->capability =\r\ncpu_to_le16(ieee->current_network.capability & WLAN_CAPABILITY_IBSS);\r\nif(ieee->short_slot && (ieee->current_network.capability & WLAN_CAPABILITY_SHORT_SLOT))\r\nbeacon_buf->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT);\r\ncrypt = ieee->crypt[ieee->tx_keyidx];\r\nencrypt = ieee->host_encrypt && crypt && crypt->ops &&\r\n((0 == strcmp(crypt->ops->name, "WEP")) || wpa_ie_len);\r\nif (encrypt)\r\nbeacon_buf->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);\r\nbeacon_buf->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_PROBE_RESP);\r\nbeacon_buf->info_element.id = MFIE_TYPE_SSID;\r\nbeacon_buf->info_element.len = ssid_len;\r\ntag = (u8*) beacon_buf->info_element.data;\r\nmemcpy(tag, ssid, ssid_len);\r\ntag += ssid_len;\r\n*(tag++) = MFIE_TYPE_RATES;\r\n*(tag++) = rate_len-2;\r\nmemcpy(tag,ieee->current_network.rates,rate_len-2);\r\ntag+=rate_len-2;\r\n*(tag++) = MFIE_TYPE_DS_SET;\r\n*(tag++) = 1;\r\n*(tag++) = ieee->current_network.channel;\r\nif(atim_len){\r\n*(tag++) = MFIE_TYPE_IBSS_SET;\r\n*(tag++) = 2;\r\n*((u16*)(tag)) = cpu_to_le16(ieee->current_network.atim_window);\r\ntag+=2;\r\n}\r\nif(erp_len){\r\n*(tag++) = MFIE_TYPE_ERP;\r\n*(tag++) = 1;\r\n*(tag++) = 0;\r\n}\r\nif(rate_ex_len){\r\n*(tag++) = MFIE_TYPE_RATES_EX;\r\n*(tag++) = rate_ex_len-2;\r\nmemcpy(tag,ieee->current_network.rates_ex,rate_ex_len-2);\r\ntag+=rate_ex_len-2;\r\n}\r\nif (wpa_ie_len)\r\n{\r\nif (ieee->iw_mode == IW_MODE_ADHOC)\r\n{\r\nmemcpy(&ieee->wpa_ie[14], &ieee->wpa_ie[8], 4);\r\n}\r\nmemcpy(tag, ieee->wpa_ie, ieee->wpa_ie_len);\r\n}\r\nskb->dev = ieee->dev;\r\nreturn skb;\r\n}\r\nstruct sk_buff* ieee80211_assoc_resp(struct ieee80211_device *ieee, u8 *dest)\r\n{\r\nstruct sk_buff *skb;\r\nu8* tag;\r\nstruct ieee80211_crypt_data* crypt;\r\nstruct ieee80211_assoc_response_frame *assoc;\r\nshort encrypt;\r\nunsigned int rate_len = ieee80211_MFIE_rate_len(ieee);\r\nint len = sizeof(struct ieee80211_assoc_response_frame) + rate_len;\r\nskb = dev_alloc_skb(len);\r\nif (!skb)\r\nreturn NULL;\r\nassoc = (struct ieee80211_assoc_response_frame *)\r\nskb_put(skb,sizeof(struct ieee80211_assoc_response_frame));\r\nassoc->header.frame_control = cpu_to_le16(IEEE80211_STYPE_ASSOC_RESP);\r\nmemcpy(assoc->header.addr1, dest,ETH_ALEN);\r\nmemcpy(assoc->header.addr3, ieee->dev->dev_addr, ETH_ALEN);\r\nmemcpy(assoc->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\r\nassoc->capability = cpu_to_le16(ieee->iw_mode == IW_MODE_MASTER ?\r\nWLAN_CAPABILITY_BSS : WLAN_CAPABILITY_IBSS);\r\nif(ieee->short_slot)\r\nassoc->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT);\r\nif (ieee->host_encrypt)\r\ncrypt = ieee->crypt[ieee->tx_keyidx];\r\nelse crypt = NULL;\r\nencrypt = ( crypt && crypt->ops);\r\nif (encrypt)\r\nassoc->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);\r\nassoc->status = 0;\r\nassoc->aid = cpu_to_le16(ieee->assoc_id);\r\nif (ieee->assoc_id == 0x2007) ieee->assoc_id=0;\r\nelse ieee->assoc_id++;\r\ntag = (u8*) skb_put(skb, rate_len);\r\nieee80211_MFIE_Brate(ieee, &tag);\r\nieee80211_MFIE_Grate(ieee, &tag);\r\nreturn skb;\r\n}\r\nstruct sk_buff* ieee80211_auth_resp(struct ieee80211_device *ieee,int status, u8 *dest)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ieee80211_authentication *auth;\r\nskb = dev_alloc_skb(sizeof(struct ieee80211_authentication)+1);\r\nif (!skb)\r\nreturn NULL;\r\nskb->len = sizeof(struct ieee80211_authentication);\r\nauth = (struct ieee80211_authentication *)skb->data;\r\nauth->status = cpu_to_le16(status);\r\nauth->transaction = cpu_to_le16(2);\r\nauth->algorithm = cpu_to_le16(WLAN_AUTH_OPEN);\r\nmemcpy(auth->header.addr3, ieee->dev->dev_addr, ETH_ALEN);\r\nmemcpy(auth->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\r\nmemcpy(auth->header.addr1, dest, ETH_ALEN);\r\nauth->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_AUTH);\r\nreturn skb;\r\n}\r\nstruct sk_buff* ieee80211_null_func(struct ieee80211_device *ieee,short pwr)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ieee80211_hdr_3addr* hdr;\r\nskb = dev_alloc_skb(sizeof(struct ieee80211_hdr_3addr));\r\nif (!skb)\r\nreturn NULL;\r\nhdr = (struct ieee80211_hdr_3addr*)skb_put(skb,sizeof(struct ieee80211_hdr_3addr));\r\nmemcpy(hdr->addr1, ieee->current_network.bssid, ETH_ALEN);\r\nmemcpy(hdr->addr2, ieee->dev->dev_addr, ETH_ALEN);\r\nmemcpy(hdr->addr3, ieee->current_network.bssid, ETH_ALEN);\r\nhdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |\r\nIEEE80211_STYPE_NULLFUNC | IEEE80211_FCTL_TODS |\r\n(pwr ? IEEE80211_FCTL_PM:0));\r\nreturn skb;\r\n}\r\nvoid ieee80211_resp_to_assoc_rq(struct ieee80211_device *ieee, u8* dest)\r\n{\r\nstruct sk_buff *buf = ieee80211_assoc_resp(ieee, dest);\r\nif (buf){\r\nsoftmac_mgmt_xmit(buf, ieee);\r\ndev_kfree_skb_any(buf);\r\n}\r\n}\r\nvoid ieee80211_resp_to_auth(struct ieee80211_device *ieee, int s, u8* dest)\r\n{\r\nstruct sk_buff *buf = ieee80211_auth_resp(ieee, s, dest);\r\nif (buf){\r\nsoftmac_mgmt_xmit(buf, ieee);\r\ndev_kfree_skb_any(buf);\r\n}\r\n}\r\nvoid ieee80211_resp_to_probe(struct ieee80211_device *ieee, u8 *dest)\r\n{\r\nstruct sk_buff *buf = ieee80211_probe_resp(ieee, dest);\r\nif (buf) {\r\nsoftmac_mgmt_xmit(buf, ieee);\r\ndev_kfree_skb_any(buf);\r\n}\r\n}\r\ninline struct sk_buff *ieee80211_association_req(struct ieee80211_network *beacon,struct ieee80211_device *ieee)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ieee80211_assoc_request_frame *hdr;\r\nu8 *tag;\r\nunsigned int wpa_len = beacon->wpa_ie_len;\r\n#if 1\r\nunsigned int rsn_len = beacon->rsn_ie_len;\r\n#else\r\nunsigned int rsn_len = beacon->rsn_ie_len - 4;\r\n#endif\r\nunsigned int rate_len = ieee80211_MFIE_rate_len(ieee);\r\nunsigned int wmm_info_len = beacon->QoS_Enable?9:0;\r\nunsigned int turbo_info_len = beacon->Turbo_Enable?9:0;\r\nu8 encry_proto = ieee->wpax_type_notify & 0xff;\r\nint len = 0;\r\nif(ieee->wpax_type_set) {\r\nif (IEEE_PROTO_WPA == encry_proto) {\r\nrsn_len = 0;\r\n} else if (IEEE_PROTO_RSN == encry_proto) {\r\nwpa_len = 0;\r\n}\r\n}\r\nlen = sizeof(struct ieee80211_assoc_request_frame)+\r\n+ beacon->ssid_len\r\n+ rate_len\r\n+ wpa_len\r\n+ rsn_len\r\n+ wmm_info_len\r\n+ turbo_info_len;\r\nskb = dev_alloc_skb(len);\r\nif (!skb)\r\nreturn NULL;\r\nhdr = (struct ieee80211_assoc_request_frame *)\r\nskb_put(skb, sizeof(struct ieee80211_assoc_request_frame));\r\nhdr->header.frame_control = IEEE80211_STYPE_ASSOC_REQ;\r\nhdr->header.duration_id= 37;\r\nmemcpy(hdr->header.addr1, beacon->bssid, ETH_ALEN);\r\nmemcpy(hdr->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\r\nmemcpy(hdr->header.addr3, beacon->bssid, ETH_ALEN);\r\nmemcpy(ieee->ap_mac_addr, beacon->bssid, ETH_ALEN);\r\nhdr->capability = cpu_to_le16(WLAN_CAPABILITY_BSS);\r\nif (beacon->capability & WLAN_CAPABILITY_PRIVACY )\r\nhdr->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);\r\nif (beacon->capability & WLAN_CAPABILITY_SHORT_PREAMBLE)\r\nhdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_PREAMBLE);\r\nif(ieee->short_slot)\r\nhdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT);\r\nhdr->listen_interval = 0xa;\r\nhdr->info_element.id = MFIE_TYPE_SSID;\r\nhdr->info_element.len = beacon->ssid_len;\r\ntag = skb_put(skb, beacon->ssid_len);\r\nmemcpy(tag, beacon->ssid, beacon->ssid_len);\r\ntag = skb_put(skb, rate_len);\r\nieee80211_MFIE_Brate(ieee, &tag);\r\nieee80211_MFIE_Grate(ieee, &tag);\r\ntag = skb_put(skb,ieee->wpa_ie_len);\r\nmemcpy(tag,ieee->wpa_ie,ieee->wpa_ie_len);\r\ntag = skb_put(skb,wmm_info_len);\r\nif(wmm_info_len) {\r\nieee80211_WMM_Info(ieee, &tag);\r\n}\r\ntag = skb_put(skb,turbo_info_len);\r\nif(turbo_info_len) {\r\nieee80211_TURBO_Info(ieee, &tag);\r\n}\r\nreturn skb;\r\n}\r\nvoid ieee80211_associate_abort(struct ieee80211_device *ieee)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nieee->associate_seq++;\r\nif (ieee->state == IEEE80211_ASSOCIATING_AUTHENTICATING){\r\nIEEE80211_DEBUG_MGMT("Authentication failed\n");\r\nieee->softmac_stats.no_auth_rs++;\r\n}else{\r\nIEEE80211_DEBUG_MGMT("Association failed\n");\r\nieee->softmac_stats.no_ass_rs++;\r\n}\r\nieee->state = IEEE80211_ASSOCIATING_RETRY;\r\nqueue_delayed_work(ieee->wq, &ieee->associate_retry_wq,IEEE80211_SOFTMAC_ASSOC_RETRY_TIME);\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\nvoid ieee80211_associate_abort_cb(unsigned long dev)\r\n{\r\nieee80211_associate_abort((struct ieee80211_device *) dev);\r\n}\r\nvoid ieee80211_associate_step1(struct ieee80211_device *ieee)\r\n{\r\nstruct ieee80211_network *beacon = &ieee->current_network;\r\nstruct sk_buff *skb;\r\nIEEE80211_DEBUG_MGMT("Stopping scan\n");\r\nieee->softmac_stats.tx_auth_rq++;\r\nskb=ieee80211_authentication_req(beacon, ieee, 0);\r\nif (!skb){\r\nieee80211_associate_abort(ieee);\r\n}\r\nelse{\r\nieee->state = IEEE80211_ASSOCIATING_AUTHENTICATING ;\r\nIEEE80211_DEBUG_MGMT("Sending authentication request\n");\r\nsoftmac_mgmt_xmit(skb, ieee);\r\nif(!timer_pending(&ieee->associate_timer)){\r\nieee->associate_timer.expires = jiffies + (HZ / 2);\r\nadd_timer(&ieee->associate_timer);\r\n}\r\n}\r\n}\r\nvoid ieee80211_rtl_auth_challenge(struct ieee80211_device *ieee, u8 *challenge, int chlen)\r\n{\r\nu8 *c;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_network *beacon = &ieee->current_network;\r\ndel_timer_sync(&ieee->associate_timer);\r\nieee->associate_seq++;\r\nieee->softmac_stats.tx_auth_rq++;\r\nskb = ieee80211_authentication_req(beacon, ieee, chlen+2);\r\nif (!skb)\r\nieee80211_associate_abort(ieee);\r\nelse{\r\nc = skb_put(skb, chlen+2);\r\n*(c++) = MFIE_TYPE_CHALLENGE;\r\n*(c++) = chlen;\r\nmemcpy(c, challenge, chlen);\r\nIEEE80211_DEBUG_MGMT("Sending authentication challenge response\n");\r\nieee80211_encrypt_fragment(ieee, skb, sizeof(struct ieee80211_hdr_3addr ));\r\nsoftmac_mgmt_xmit(skb, ieee);\r\nif (!timer_pending(&ieee->associate_timer)){\r\nieee->associate_timer.expires = jiffies + (HZ / 2);\r\nadd_timer(&ieee->associate_timer);\r\n}\r\ndev_kfree_skb_any(skb);\r\n}\r\nkfree(challenge);\r\n}\r\nvoid ieee80211_associate_step2(struct ieee80211_device *ieee)\r\n{\r\nstruct sk_buff* skb;\r\nstruct ieee80211_network *beacon = &ieee->current_network;\r\ndel_timer_sync(&ieee->associate_timer);\r\nIEEE80211_DEBUG_MGMT("Sending association request\n");\r\nieee->softmac_stats.tx_ass_rq++;\r\nskb=ieee80211_association_req(beacon, ieee);\r\nif (!skb)\r\nieee80211_associate_abort(ieee);\r\nelse{\r\nsoftmac_mgmt_xmit(skb, ieee);\r\nif (!timer_pending(&ieee->associate_timer)){\r\nieee->associate_timer.expires = jiffies + (HZ / 2);\r\nadd_timer(&ieee->associate_timer);\r\n}\r\n}\r\n}\r\nvoid ieee80211_associate_complete_wq(struct work_struct *work)\r\n{\r\nstruct ieee80211_device *ieee = container_of(work, struct ieee80211_device, associate_complete_wq);\r\nprintk(KERN_INFO "Associated successfully\n");\r\nif(ieee80211_is_54g(&ieee->current_network) &&\r\n(ieee->modulation & IEEE80211_OFDM_MODULATION)){\r\nieee->rate = 540;\r\nprintk(KERN_INFO"Using G rates\n");\r\n}else{\r\nieee->rate = 110;\r\nprintk(KERN_INFO"Using B rates\n");\r\n}\r\nieee->link_change(ieee->dev);\r\nnotify_wx_assoc_event(ieee);\r\nif (ieee->data_hard_resume)\r\nieee->data_hard_resume(ieee->dev);\r\nnetif_carrier_on(ieee->dev);\r\n}\r\nvoid ieee80211_associate_complete(struct ieee80211_device *ieee)\r\n{\r\nint i;\r\ndel_timer_sync(&ieee->associate_timer);\r\nfor(i = 0; i < 6; i++) {\r\n}\r\nieee->state = IEEE80211_LINKED;\r\nIEEE80211_DEBUG_MGMT("Successfully associated\n");\r\nqueue_work(ieee->wq, &ieee->associate_complete_wq);\r\n}\r\nvoid ieee80211_associate_procedure_wq(struct work_struct *work)\r\n{\r\nstruct ieee80211_device *ieee = container_of(work, struct ieee80211_device, associate_procedure_wq);\r\nieee->sync_scan_hurryup = 1;\r\ndown(&ieee->wx_sem);\r\nif (ieee->data_hard_stop)\r\nieee->data_hard_stop(ieee->dev);\r\nieee80211_stop_scan(ieee);\r\nieee->set_chan(ieee->dev, ieee->current_network.channel);\r\nieee->associate_seq = 1;\r\nieee80211_associate_step1(ieee);\r\nup(&ieee->wx_sem);\r\n}\r\ninline void ieee80211_softmac_new_net(struct ieee80211_device *ieee, struct ieee80211_network *net)\r\n{\r\nu8 tmp_ssid[IW_ESSID_MAX_SIZE+1];\r\nint tmp_ssid_len = 0;\r\nshort apset,ssidset,ssidbroad,apmatch,ssidmatch;\r\nif (ieee->state != IEEE80211_NOLINK)\r\nreturn;\r\nif ((ieee->iw_mode == IW_MODE_INFRA) && !(net->capability & WLAN_CAPABILITY_BSS))\r\nreturn;\r\nif ((ieee->iw_mode == IW_MODE_ADHOC) && !(net->capability & WLAN_CAPABILITY_IBSS))\r\nreturn;\r\nif (ieee->iw_mode == IW_MODE_INFRA || ieee->iw_mode == IW_MODE_ADHOC){\r\napset = ieee->wap_set;\r\nssidset = ieee->ssid_set;\r\nssidbroad = !(net->ssid_len == 0 || net->ssid[0]== '\0');\r\napmatch = (memcmp(ieee->current_network.bssid, net->bssid, ETH_ALEN)==0);\r\nif(ieee->current_network.ssid_len != net->ssid_len)\r\nssidmatch = 0;\r\nelse\r\nssidmatch = (0==strncmp(ieee->current_network.ssid, net->ssid, net->ssid_len));\r\nif (\r\n( apset && apmatch &&\r\n((ssidset && ssidbroad && ssidmatch) || (ssidbroad && !ssidset) || (!ssidbroad && ssidset)) ) ||\r\n(!apset && ssidset && ssidbroad && ssidmatch)\r\n){\r\nif (!ssidbroad){\r\nstrncpy(tmp_ssid, ieee->current_network.ssid, IW_ESSID_MAX_SIZE);\r\ntmp_ssid_len = ieee->current_network.ssid_len;\r\n}\r\nmemcpy(&ieee->current_network, net, sizeof(struct ieee80211_network));\r\nif (!ssidbroad){\r\nstrncpy(ieee->current_network.ssid, tmp_ssid, IW_ESSID_MAX_SIZE);\r\nieee->current_network.ssid_len = tmp_ssid_len;\r\n}\r\nprintk(KERN_INFO"Linking with %s: channel is %d\n",ieee->current_network.ssid,ieee->current_network.channel);\r\nif (ieee->iw_mode == IW_MODE_INFRA){\r\nieee->state = IEEE80211_ASSOCIATING;\r\nieee->beinretry = false;\r\nqueue_work(ieee->wq, &ieee->associate_procedure_wq);\r\n}else{\r\nif(ieee80211_is_54g(&ieee->current_network) &&\r\n(ieee->modulation & IEEE80211_OFDM_MODULATION)){\r\nieee->rate = 540;\r\nprintk(KERN_INFO"Using G rates\n");\r\n}else{\r\nieee->rate = 110;\r\nprintk(KERN_INFO"Using B rates\n");\r\n}\r\nieee->state = IEEE80211_LINKED;\r\nieee->beinretry = false;\r\n}\r\n}\r\n}\r\n}\r\nvoid ieee80211_softmac_check_all_nets(struct ieee80211_device *ieee)\r\n{\r\nunsigned long flags;\r\nstruct ieee80211_network *target;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nlist_for_each_entry(target, &ieee->network_list, list) {\r\nif (ieee->state != IEEE80211_NOLINK)\r\nbreak;\r\nif (ieee->scan_age == 0 || time_after(target->last_scanned + ieee->scan_age, jiffies))\r\nieee80211_softmac_new_net(ieee, target);\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\nstatic inline u16 auth_parse(struct sk_buff *skb, u8** challenge, int *chlen)\r\n{\r\nstruct ieee80211_authentication *a;\r\nu8 *t;\r\nif (skb->len < (sizeof(struct ieee80211_authentication)-sizeof(struct ieee80211_info_element))){\r\nIEEE80211_DEBUG_MGMT("invalid len in auth resp: %d\n",skb->len);\r\nreturn 0xcafe;\r\n}\r\n*challenge = NULL;\r\na = (struct ieee80211_authentication*) skb->data;\r\nif(skb->len > (sizeof(struct ieee80211_authentication) +3)){\r\nt = skb->data + sizeof(struct ieee80211_authentication);\r\nif(*(t++) == MFIE_TYPE_CHALLENGE){\r\n*chlen = *(t++);\r\n*challenge = kmemdup(t, *chlen, GFP_ATOMIC);\r\nif (!*challenge)\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn cpu_to_le16(a->status);\r\n}\r\nint auth_rq_parse(struct sk_buff *skb,u8* dest)\r\n{\r\nstruct ieee80211_authentication *a;\r\nif (skb->len < (sizeof(struct ieee80211_authentication)-sizeof(struct ieee80211_info_element))){\r\nIEEE80211_DEBUG_MGMT("invalid len in auth request: %d\n",skb->len);\r\nreturn -1;\r\n}\r\na = (struct ieee80211_authentication*) skb->data;\r\nmemcpy(dest,a->header.addr2, ETH_ALEN);\r\nif (le16_to_cpu(a->algorithm) != WLAN_AUTH_OPEN)\r\nreturn WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG;\r\nreturn WLAN_STATUS_SUCCESS;\r\n}\r\nstatic short probe_rq_parse(struct ieee80211_device *ieee, struct sk_buff *skb, u8 *src)\r\n{\r\nu8 *tag;\r\nu8 *skbend;\r\nu8 *ssid=NULL;\r\nu8 ssidlen = 0;\r\nstruct ieee80211_hdr_3addr *header =\r\n(struct ieee80211_hdr_3addr *) skb->data;\r\nif (skb->len < sizeof (struct ieee80211_hdr_3addr ))\r\nreturn -1;\r\nmemcpy(src,header->addr2, ETH_ALEN);\r\nskbend = (u8*)skb->data + skb->len;\r\ntag = skb->data + sizeof (struct ieee80211_hdr_3addr );\r\nwhile (tag+1 < skbend){\r\nif (*tag == 0){\r\nssid = tag+2;\r\nssidlen = *(tag+1);\r\nbreak;\r\n}\r\ntag++;\r\ntag = tag + *(tag);\r\ntag++;\r\n}\r\nif (ssidlen == 0) return 1;\r\nif (!ssid) return 1;\r\nreturn (!strncmp(ssid, ieee->current_network.ssid, ssidlen));\r\n}\r\nint assoc_rq_parse(struct sk_buff *skb,u8* dest)\r\n{\r\nstruct ieee80211_assoc_request_frame *a;\r\nif (skb->len < (sizeof(struct ieee80211_assoc_request_frame) -\r\nsizeof(struct ieee80211_info_element))) {\r\nIEEE80211_DEBUG_MGMT("invalid len in auth request:%d \n", skb->len);\r\nreturn -1;\r\n}\r\na = (struct ieee80211_assoc_request_frame*) skb->data;\r\nmemcpy(dest,a->header.addr2,ETH_ALEN);\r\nreturn 0;\r\n}\r\nstatic inline u16 assoc_parse(struct sk_buff *skb, int *aid)\r\n{\r\nstruct ieee80211_assoc_response_frame *a;\r\nif (skb->len < sizeof(struct ieee80211_assoc_response_frame)){\r\nIEEE80211_DEBUG_MGMT("invalid len in auth resp: %d\n", skb->len);\r\nreturn 0xcafe;\r\n}\r\na = (struct ieee80211_assoc_response_frame*) skb->data;\r\n*aid = le16_to_cpu(a->aid) & 0x3fff;\r\nreturn le16_to_cpu(a->status);\r\n}\r\nstatic inline void\r\nieee80211_rx_probe_rq(struct ieee80211_device *ieee, struct sk_buff *skb)\r\n{\r\nu8 dest[ETH_ALEN];\r\nieee->softmac_stats.rx_probe_rq++;\r\nif (probe_rq_parse(ieee, skb, dest)){\r\nieee->softmac_stats.tx_probe_rs++;\r\nieee80211_resp_to_probe(ieee, dest);\r\n}\r\n}\r\ninline void\r\nieee80211_rx_auth_rq(struct ieee80211_device *ieee, struct sk_buff *skb)\r\n{\r\nu8 dest[ETH_ALEN];\r\nint status;\r\nieee->softmac_stats.rx_auth_rq++;\r\nstatus = auth_rq_parse(skb, dest);\r\nif (status != -1) {\r\nieee80211_resp_to_auth(ieee, status, dest);\r\n}\r\n}\r\ninline void\r\nieee80211_rx_assoc_rq(struct ieee80211_device *ieee, struct sk_buff *skb)\r\n{\r\nu8 dest[ETH_ALEN];\r\nieee->softmac_stats.rx_ass_rq++;\r\nif (assoc_rq_parse(skb,dest) != -1){\r\nieee80211_resp_to_assoc_rq(ieee, dest);\r\n}\r\nprintk(KERN_INFO"New client associated: %pM\n", dest);\r\n}\r\nvoid ieee80211_sta_ps_send_null_frame(struct ieee80211_device *ieee, short pwr)\r\n{\r\nstruct sk_buff *buf = ieee80211_null_func(ieee, pwr);\r\nif (buf)\r\nsoftmac_ps_mgmt_xmit(buf, ieee);\r\n}\r\nshort ieee80211_sta_ps_sleep(struct ieee80211_device *ieee, u32 *time_h, u32 *time_l)\r\n{\r\nint timeout = 0;\r\nu8 dtim;\r\ndtim = ieee->current_network.dtim_data;\r\nif(!(dtim & IEEE80211_DTIM_VALID))\r\nreturn 0;\r\nelse\r\ntimeout = ieee->current_network.beacon_interval;\r\nieee->current_network.dtim_data = IEEE80211_DTIM_INVALID;\r\nif(dtim & ((IEEE80211_DTIM_UCAST | IEEE80211_DTIM_MBCAST)& ieee->ps))\r\nreturn 2;\r\nif(!time_after(jiffies, ieee->dev->trans_start + MSECS(timeout)))\r\nreturn 0;\r\nif(!time_after(jiffies, ieee->last_rx_ps_time + MSECS(timeout)))\r\nreturn 0;\r\nif((ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE ) &&\r\n(ieee->mgmt_queue_tail != ieee->mgmt_queue_head))\r\nreturn 0;\r\nif(time_l){\r\n*time_l = ieee->current_network.last_dtim_sta_time[0]\r\n+ MSECS((ieee->current_network.beacon_interval));\r\n}\r\nif(time_h){\r\n*time_h = ieee->current_network.last_dtim_sta_time[1];\r\nif(time_l && *time_l < ieee->current_network.last_dtim_sta_time[0])\r\n*time_h += 1;\r\n}\r\nreturn 1;\r\n}\r\ninline void ieee80211_sta_ps(struct ieee80211_device *ieee)\r\n{\r\nu32 th,tl;\r\nshort sleep;\r\nunsigned long flags,flags2;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nif((ieee->ps == IEEE80211_PS_DISABLED ||\r\nieee->iw_mode != IW_MODE_INFRA ||\r\nieee->state != IEEE80211_LINKED)){\r\nspin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);\r\nieee80211_sta_wakeup(ieee, 1);\r\nspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);\r\n}\r\nsleep = ieee80211_sta_ps_sleep(ieee,&th, &tl);\r\nif(sleep == 0)\r\ngoto out;\r\nif(sleep == 1){\r\nif(ieee->sta_sleep == 1)\r\nieee->enter_sleep_state(ieee->dev,th,tl);\r\nelse if(ieee->sta_sleep == 0){\r\nspin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);\r\nif(ieee->ps_is_queue_empty(ieee->dev)){\r\nieee->sta_sleep = 2;\r\nieee->ps_request_tx_ack(ieee->dev);\r\nieee80211_sta_ps_send_null_frame(ieee,1);\r\nieee->ps_th = th;\r\nieee->ps_tl = tl;\r\n}\r\nspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);\r\n}\r\n}else if(sleep == 2){\r\nspin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);\r\nieee80211_sta_wakeup(ieee,1);\r\nspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\nvoid ieee80211_sta_wakeup(struct ieee80211_device *ieee, short nl)\r\n{\r\nif(ieee->sta_sleep == 0){\r\nif(nl){\r\nieee->ps_request_tx_ack(ieee->dev);\r\nieee80211_sta_ps_send_null_frame(ieee, 0);\r\n}\r\nreturn;\r\n}\r\nif(ieee->sta_sleep == 1)\r\nieee->sta_wake_up(ieee->dev);\r\nieee->sta_sleep = 0;\r\nif(nl){\r\nieee->ps_request_tx_ack(ieee->dev);\r\nieee80211_sta_ps_send_null_frame(ieee, 0);\r\n}\r\n}\r\nvoid ieee80211_ps_tx_ack(struct ieee80211_device *ieee, short success)\r\n{\r\nunsigned long flags,flags2;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nif(ieee->sta_sleep == 2){\r\nif(success){\r\nieee->sta_sleep = 1;\r\nieee->enter_sleep_state(ieee->dev,ieee->ps_th,ieee->ps_tl);\r\n}\r\n}\r\nelse {\r\nif((ieee->sta_sleep == 0) && !success){\r\nspin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);\r\nieee80211_sta_ps_send_null_frame(ieee, 0);\r\nspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);\r\n}\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\ninline int\r\nieee80211_rx_frame_softmac(struct ieee80211_device *ieee, struct sk_buff *skb,\r\nstruct ieee80211_rx_stats *rx_stats, u16 type,\r\nu16 stype)\r\n{\r\nstruct ieee80211_hdr_3addr *header = (struct ieee80211_hdr_3addr *) skb->data;\r\nu16 errcode;\r\nu8* challenge=NULL;\r\nint chlen=0;\r\nint aid=0;\r\nstruct ieee80211_assoc_response_frame *assoc_resp;\r\nstruct ieee80211_info_element *info_element;\r\nif(!ieee->proto_started)\r\nreturn 0;\r\nif(ieee->sta_sleep || (ieee->ps != IEEE80211_PS_DISABLED &&\r\nieee->iw_mode == IW_MODE_INFRA &&\r\nieee->state == IEEE80211_LINKED))\r\ntasklet_schedule(&ieee->ps_task);\r\nif (WLAN_FC_GET_STYPE(header->frame_control) != IEEE80211_STYPE_PROBE_RESP &&\r\nWLAN_FC_GET_STYPE(header->frame_control) != IEEE80211_STYPE_BEACON)\r\nieee->last_rx_ps_time = jiffies;\r\nswitch (WLAN_FC_GET_STYPE(header->frame_control)) {\r\ncase IEEE80211_STYPE_ASSOC_RESP:\r\ncase IEEE80211_STYPE_REASSOC_RESP:\r\nIEEE80211_DEBUG_MGMT("received [RE]ASSOCIATION RESPONSE (%d)\n",\r\nWLAN_FC_GET_STYPE(header->frame_ctl));\r\nif ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&\r\nieee->state == IEEE80211_ASSOCIATING_AUTHENTICATED &&\r\nieee->iw_mode == IW_MODE_INFRA){\r\nif (0 == (errcode=assoc_parse(skb, &aid))){\r\nu16 left;\r\nieee->state=IEEE80211_LINKED;\r\nieee->assoc_id = aid;\r\nieee->softmac_stats.rx_ass_ok++;\r\nif(1 == rx_stats->nic_type)\r\n{\r\ngoto associate_complete;\r\n}\r\nassoc_resp = (struct ieee80211_assoc_response_frame*)skb->data;\r\ninfo_element = &assoc_resp->info_element;\r\nleft = skb->len - ((void*)info_element - (void*)assoc_resp);\r\nwhile (left >= sizeof(struct ieee80211_info_element_hdr)) {\r\nif (sizeof(struct ieee80211_info_element_hdr) + info_element->len > left) {\r\nprintk(KERN_WARNING "[re]associate reeponse error!");\r\nreturn 1;\r\n}\r\nswitch (info_element->id) {\r\ncase MFIE_TYPE_GENERIC:\r\nIEEE80211_DEBUG_SCAN("MFIE_TYPE_GENERIC: %d bytes\n", info_element->len);\r\nif (info_element->len >= 8 &&\r\ninfo_element->data[0] == 0x00 &&\r\ninfo_element->data[1] == 0x50 &&\r\ninfo_element->data[2] == 0xf2 &&\r\ninfo_element->data[3] == 0x02 &&\r\ninfo_element->data[4] == 0x01) {\r\nmemcpy(ieee->current_network.wmm_param,(u8*)(info_element->data\\r\n+ 8),(info_element->len - 8));\r\nif (((ieee->current_network.wmm_info^info_element->data[6])& \\r\n0x0f)||(!ieee->init_wmmparam_flag)) {\r\nieee->init_wmmparam_flag = 1;\r\nqueue_work(ieee->wq, &ieee->wmm_param_update_wq);\r\n}\r\nieee->current_network.wmm_info = info_element->data[6];\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nleft -= sizeof(struct ieee80211_info_element_hdr) +\r\ninfo_element->len;\r\ninfo_element = (struct ieee80211_info_element *)\r\n&info_element->data[info_element->len];\r\n}\r\nif(!ieee->init_wmmparam_flag)\r\n{\r\nqueue_work(ieee->wq,&ieee->wmm_param_update_wq);\r\nieee->init_wmmparam_flag = 1;\r\n}\r\nassociate_complete:\r\nieee80211_associate_complete(ieee);\r\n}else{\r\nieee->softmac_stats.rx_ass_err++;\r\nIEEE80211_DEBUG_MGMT(\r\n"Association response status code 0x%x\n",\r\nerrcode);\r\nieee80211_associate_abort(ieee);\r\n}\r\n}\r\nbreak;\r\ncase IEEE80211_STYPE_ASSOC_REQ:\r\ncase IEEE80211_STYPE_REASSOC_REQ:\r\nif ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&\r\nieee->iw_mode == IW_MODE_MASTER)\r\nieee80211_rx_assoc_rq(ieee, skb);\r\nbreak;\r\ncase IEEE80211_STYPE_AUTH:\r\nif (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE){\r\nif (ieee->state == IEEE80211_ASSOCIATING_AUTHENTICATING &&\r\nieee->iw_mode == IW_MODE_INFRA){\r\nIEEE80211_DEBUG_MGMT("Received authentication response");\r\nif (0 == (errcode=auth_parse(skb, &challenge, &chlen))){\r\nif(ieee->open_wep || !challenge){\r\nieee->state = IEEE80211_ASSOCIATING_AUTHENTICATED;\r\nieee->softmac_stats.rx_auth_rs_ok++;\r\nieee80211_associate_step2(ieee);\r\n}else{\r\nieee80211_rtl_auth_challenge(ieee, challenge, chlen);\r\n}\r\n}else{\r\nieee->softmac_stats.rx_auth_rs_err++;\r\nIEEE80211_DEBUG_MGMT("Authentication respose status code 0x%x",errcode);\r\nieee80211_associate_abort(ieee);\r\n}\r\n}else if (ieee->iw_mode == IW_MODE_MASTER){\r\nieee80211_rx_auth_rq(ieee, skb);\r\n}\r\n}\r\nbreak;\r\ncase IEEE80211_STYPE_PROBE_REQ:\r\nif ((ieee->softmac_features & IEEE_SOFTMAC_PROBERS) &&\r\n((ieee->iw_mode == IW_MODE_ADHOC ||\r\nieee->iw_mode == IW_MODE_MASTER) &&\r\nieee->state == IEEE80211_LINKED))\r\nieee80211_rx_probe_rq(ieee, skb);\r\nbreak;\r\ncase IEEE80211_STYPE_DISASSOC:\r\ncase IEEE80211_STYPE_DEAUTH:\r\nif ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&\r\n(ieee->state == IEEE80211_LINKED) &&\r\n(ieee->iw_mode == IW_MODE_INFRA) &&\r\n(!memcmp(header->addr2,ieee->current_network.bssid,ETH_ALEN))){\r\nieee->state = IEEE80211_ASSOCIATING;\r\nieee->softmac_stats.reassoc++;\r\nqueue_work(ieee->wq, &ieee->associate_procedure_wq);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -1;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid ieee80211_softmac_xmit(struct ieee80211_txb *txb, struct ieee80211_device *ieee)\r\n{\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&ieee->lock,flags);\r\nieee80211_sta_wakeup(ieee,0);\r\nfor(i = 0; i < txb->nr_frags; i++) {\r\nif (ieee->queue_stop){\r\nieee->tx_pending.txb = txb;\r\nieee->tx_pending.frag = i;\r\ngoto exit;\r\n}else{\r\nieee->softmac_data_hard_start_xmit(\r\ntxb->fragments[i],\r\nieee->dev,ieee->rate);\r\nieee->stats.tx_packets++;\r\nieee->stats.tx_bytes += txb->fragments[i]->len;\r\nieee->dev->trans_start = jiffies;\r\n}\r\n}\r\nieee80211_txb_free(txb);\r\nexit:\r\nspin_unlock_irqrestore(&ieee->lock,flags);\r\n}\r\nvoid ieee80211_resume_tx(struct ieee80211_device *ieee)\r\n{\r\nint i;\r\nfor(i = ieee->tx_pending.frag; i < ieee->tx_pending.txb->nr_frags; i++) {\r\nif (ieee->queue_stop){\r\nieee->tx_pending.frag = i;\r\nreturn;\r\n}else{\r\nieee->softmac_data_hard_start_xmit(\r\nieee->tx_pending.txb->fragments[i],\r\nieee->dev,ieee->rate);\r\nieee->stats.tx_packets++;\r\nieee->dev->trans_start = jiffies;\r\n}\r\n}\r\nieee80211_txb_free(ieee->tx_pending.txb);\r\nieee->tx_pending.txb = NULL;\r\n}\r\nvoid ieee80211_reset_queue(struct ieee80211_device *ieee)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ieee->lock,flags);\r\ninit_mgmt_queue(ieee);\r\nif (ieee->tx_pending.txb){\r\nieee80211_txb_free(ieee->tx_pending.txb);\r\nieee->tx_pending.txb = NULL;\r\n}\r\nieee->queue_stop = 0;\r\nspin_unlock_irqrestore(&ieee->lock,flags);\r\n}\r\nvoid ieee80211_rtl_wake_queue(struct ieee80211_device *ieee)\r\n{\r\nunsigned long flags;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_hdr_3addr *header;\r\nspin_lock_irqsave(&ieee->lock,flags);\r\nif (! ieee->queue_stop) goto exit;\r\nieee->queue_stop = 0;\r\nif(ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE){\r\nwhile (!ieee->queue_stop && (skb = dequeue_mgmt(ieee))){\r\nheader = (struct ieee80211_hdr_3addr *) skb->data;\r\nheader->seq_ctrl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\r\nif (ieee->seq_ctrl[0] == 0xFFF)\r\nieee->seq_ctrl[0] = 0;\r\nelse\r\nieee->seq_ctrl[0]++;\r\nieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);\r\ndev_kfree_skb_any(skb);\r\n}\r\n}\r\nif (!ieee->queue_stop && ieee->tx_pending.txb)\r\nieee80211_resume_tx(ieee);\r\nif (!ieee->queue_stop && netif_queue_stopped(ieee->dev)){\r\nieee->softmac_stats.swtxawake++;\r\nnetif_wake_queue(ieee->dev);\r\n}\r\nexit :\r\nspin_unlock_irqrestore(&ieee->lock,flags);\r\n}\r\nvoid ieee80211_rtl_stop_queue(struct ieee80211_device *ieee)\r\n{\r\nif (! netif_queue_stopped(ieee->dev)){\r\nnetif_stop_queue(ieee->dev);\r\nieee->softmac_stats.swtxstop++;\r\n}\r\nieee->queue_stop = 1;\r\n}\r\ninline void ieee80211_randomize_cell(struct ieee80211_device *ieee)\r\n{\r\nget_random_bytes(ieee->current_network.bssid, ETH_ALEN);\r\nieee->current_network.bssid[0] &= ~0x01;\r\nieee->current_network.bssid[0] |= 0x02;\r\n}\r\nvoid ieee80211_start_master_bss(struct ieee80211_device *ieee)\r\n{\r\nieee->assoc_id = 1;\r\nif (ieee->current_network.ssid_len == 0){\r\nstrncpy(ieee->current_network.ssid,\r\nIEEE80211_DEFAULT_TX_ESSID,\r\nIW_ESSID_MAX_SIZE);\r\nieee->current_network.ssid_len = strlen(IEEE80211_DEFAULT_TX_ESSID);\r\nieee->ssid_set = 1;\r\n}\r\nmemcpy(ieee->current_network.bssid, ieee->dev->dev_addr, ETH_ALEN);\r\nieee->set_chan(ieee->dev, ieee->current_network.channel);\r\nieee->state = IEEE80211_LINKED;\r\nieee->link_change(ieee->dev);\r\nnotify_wx_assoc_event(ieee);\r\nif (ieee->data_hard_resume)\r\nieee->data_hard_resume(ieee->dev);\r\nnetif_carrier_on(ieee->dev);\r\n}\r\nvoid ieee80211_start_monitor_mode(struct ieee80211_device *ieee)\r\n{\r\nif(ieee->raw_tx){\r\nif (ieee->data_hard_resume)\r\nieee->data_hard_resume(ieee->dev);\r\nnetif_carrier_on(ieee->dev);\r\n}\r\n}\r\nvoid ieee80211_start_ibss_wq(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, start_ibss_wq);\r\ndown(&ieee->wx_sem);\r\nif (ieee->current_network.ssid_len == 0){\r\nstrcpy(ieee->current_network.ssid,IEEE80211_DEFAULT_TX_ESSID);\r\nieee->current_network.ssid_len = strlen(IEEE80211_DEFAULT_TX_ESSID);\r\nieee->ssid_set = 1;\r\n}\r\nieee80211_softmac_check_all_nets(ieee);\r\nif(ieee->state == IEEE80211_NOLINK)\r\nieee->current_network.channel = 10;\r\nif (ieee->state == IEEE80211_NOLINK)\r\nieee80211_start_scan_syncro(ieee);\r\nif (ieee->state == IEEE80211_NOLINK){\r\nprintk("creating new IBSS cell\n");\r\nif(!ieee->wap_set)\r\nieee80211_randomize_cell(ieee);\r\nif(ieee->modulation & IEEE80211_CCK_MODULATION){\r\nieee->current_network.rates_len = 4;\r\nieee->current_network.rates[0] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_1MB;\r\nieee->current_network.rates[1] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_2MB;\r\nieee->current_network.rates[2] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_5MB;\r\nieee->current_network.rates[3] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_11MB;\r\n}else\r\nieee->current_network.rates_len = 0;\r\nif(ieee->modulation & IEEE80211_OFDM_MODULATION){\r\nieee->current_network.rates_ex_len = 8;\r\nieee->current_network.rates_ex[0] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_6MB;\r\nieee->current_network.rates_ex[1] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_9MB;\r\nieee->current_network.rates_ex[2] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_12MB;\r\nieee->current_network.rates_ex[3] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_18MB;\r\nieee->current_network.rates_ex[4] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_24MB;\r\nieee->current_network.rates_ex[5] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_36MB;\r\nieee->current_network.rates_ex[6] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_48MB;\r\nieee->current_network.rates_ex[7] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_54MB;\r\nieee->rate = 540;\r\n}else{\r\nieee->current_network.rates_ex_len = 0;\r\nieee->rate = 110;\r\n}\r\nieee->current_network.QoS_Enable = 0;\r\nieee->current_network.atim_window = 0;\r\nieee->current_network.capability = WLAN_CAPABILITY_IBSS;\r\nif(ieee->short_slot)\r\nieee->current_network.capability |= WLAN_CAPABILITY_SHORT_SLOT;\r\n}\r\nieee->state = IEEE80211_LINKED;\r\nieee->set_chan(ieee->dev, ieee->current_network.channel);\r\nieee->link_change(ieee->dev);\r\nnotify_wx_assoc_event(ieee);\r\nieee80211_start_send_beacons(ieee);\r\nprintk(KERN_WARNING "after sending beacon packet!\n");\r\nif (ieee->data_hard_resume)\r\nieee->data_hard_resume(ieee->dev);\r\nnetif_carrier_on(ieee->dev);\r\nup(&ieee->wx_sem);\r\n}\r\ninline void ieee80211_start_ibss(struct ieee80211_device *ieee)\r\n{\r\nqueue_delayed_work(ieee->wq, &ieee->start_ibss_wq, 100);\r\n}\r\nvoid ieee80211_start_bss(struct ieee80211_device *ieee)\r\n{\r\nunsigned long flags;\r\nif(IS_DOT11D_ENABLE(ieee) && !IS_COUNTRY_IE_VALID(ieee))\r\n{\r\nif(! ieee->bGlobalDomain)\r\n{\r\nreturn;\r\n}\r\n}\r\nieee80211_softmac_check_all_nets(ieee);\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nif (ieee->state == IEEE80211_NOLINK){\r\nieee->actscanning = true;\r\nieee80211_rtl_start_scan(ieee);\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\nvoid ieee80211_disassociate(struct ieee80211_device *ieee)\r\n{\r\nnetif_carrier_off(ieee->dev);\r\nif (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE)\r\nieee80211_reset_queue(ieee);\r\nif (ieee->data_hard_stop)\r\nieee->data_hard_stop(ieee->dev);\r\nif(IS_DOT11D_ENABLE(ieee))\r\nDot11d_Reset(ieee);\r\nieee->link_change(ieee->dev);\r\nif (ieee->state == IEEE80211_LINKED)\r\nnotify_wx_assoc_event(ieee);\r\nieee->state = IEEE80211_NOLINK;\r\n}\r\nvoid ieee80211_associate_retry_wq(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, associate_retry_wq);\r\nunsigned long flags;\r\ndown(&ieee->wx_sem);\r\nif(!ieee->proto_started)\r\ngoto exit;\r\nif(ieee->state != IEEE80211_ASSOCIATING_RETRY)\r\ngoto exit;\r\nieee->state = IEEE80211_NOLINK;\r\nieee->beinretry = true;\r\nieee80211_softmac_check_all_nets(ieee);\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nif(ieee->state == IEEE80211_NOLINK){\r\nieee->beinretry = false;\r\nieee->actscanning = true;\r\nieee80211_rtl_start_scan(ieee);\r\n}\r\nif(ieee->state == IEEE80211_NOLINK)\r\n{\r\nnotify_wx_assoc_event(ieee);\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\nexit:\r\nup(&ieee->wx_sem);\r\n}\r\nstruct sk_buff *ieee80211_get_beacon_(struct ieee80211_device *ieee)\r\n{\r\nu8 broadcast_addr[] = {0xff,0xff,0xff,0xff,0xff,0xff};\r\nstruct sk_buff *skb = NULL;\r\nstruct ieee80211_probe_response *b;\r\nskb = ieee80211_probe_resp(ieee, broadcast_addr);\r\nif (!skb)\r\nreturn NULL;\r\nb = (struct ieee80211_probe_response *) skb->data;\r\nb->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_BEACON);\r\nreturn skb;\r\n}\r\nstruct sk_buff *ieee80211_get_beacon(struct ieee80211_device *ieee)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ieee80211_probe_response *b;\r\nskb = ieee80211_get_beacon_(ieee);\r\nif(!skb)\r\nreturn NULL;\r\nb = (struct ieee80211_probe_response *) skb->data;\r\nb->header.seq_ctrl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\r\nif (ieee->seq_ctrl[0] == 0xFFF)\r\nieee->seq_ctrl[0] = 0;\r\nelse\r\nieee->seq_ctrl[0]++;\r\nreturn skb;\r\n}\r\nvoid ieee80211_softmac_stop_protocol(struct ieee80211_device *ieee)\r\n{\r\nieee->sync_scan_hurryup = 1;\r\ndown(&ieee->wx_sem);\r\nieee80211_stop_protocol(ieee);\r\nup(&ieee->wx_sem);\r\n}\r\nvoid ieee80211_stop_protocol(struct ieee80211_device *ieee)\r\n{\r\nif (!ieee->proto_started)\r\nreturn;\r\nieee->proto_started = 0;\r\nieee80211_stop_send_beacons(ieee);\r\nif((ieee->iw_mode == IW_MODE_INFRA)&&(ieee->state == IEEE80211_LINKED)) {\r\nSendDisassociation(ieee,NULL,WLAN_REASON_DISASSOC_STA_HAS_LEFT);\r\n}\r\ndel_timer_sync(&ieee->associate_timer);\r\ncancel_delayed_work(&ieee->associate_retry_wq);\r\ncancel_delayed_work(&ieee->start_ibss_wq);\r\nieee80211_stop_scan(ieee);\r\nieee80211_disassociate(ieee);\r\n}\r\nvoid ieee80211_softmac_start_protocol(struct ieee80211_device *ieee)\r\n{\r\nieee->sync_scan_hurryup = 0;\r\ndown(&ieee->wx_sem);\r\nieee80211_start_protocol(ieee);\r\nup(&ieee->wx_sem);\r\n}\r\nvoid ieee80211_start_protocol(struct ieee80211_device *ieee)\r\n{\r\nshort ch = 0;\r\nint i = 0;\r\nif (ieee->proto_started)\r\nreturn;\r\nieee->proto_started = 1;\r\nif (ieee->current_network.channel == 0){\r\ndo{\r\nch++;\r\nif (ch > MAX_CHANNEL_NUMBER)\r\nreturn;\r\n}while(!GET_DOT11D_INFO(ieee)->channel_map[ch]);\r\nieee->current_network.channel = ch;\r\n}\r\nif (ieee->current_network.beacon_interval == 0)\r\nieee->current_network.beacon_interval = 100;\r\nieee->set_chan(ieee->dev,ieee->current_network.channel);\r\nfor(i = 0; i < 17; i++) {\r\nieee->last_rxseq_num[i] = -1;\r\nieee->last_rxfrag_num[i] = -1;\r\nieee->last_packet_time[i] = 0;\r\n}\r\nieee->init_wmmparam_flag = 0;\r\nswitch (ieee->iw_mode) {\r\ncase IW_MODE_AUTO:\r\nieee->iw_mode = IW_MODE_INFRA;\r\ncase IW_MODE_INFRA:\r\nieee80211_start_bss(ieee);\r\nbreak;\r\ncase IW_MODE_ADHOC:\r\nieee80211_start_ibss(ieee);\r\nbreak;\r\ncase IW_MODE_MASTER:\r\nieee80211_start_master_bss(ieee);\r\nbreak;\r\ncase IW_MODE_MONITOR:\r\nieee80211_start_monitor_mode(ieee);\r\nbreak;\r\ndefault:\r\nieee->iw_mode = IW_MODE_INFRA;\r\nieee80211_start_bss(ieee);\r\nbreak;\r\n}\r\n}\r\nvoid ieee80211_softmac_init(struct ieee80211_device *ieee)\r\n{\r\nint i;\r\nmemset(&ieee->current_network, 0, sizeof(struct ieee80211_network));\r\nieee->state = IEEE80211_NOLINK;\r\nieee->sync_scan_hurryup = 0;\r\nfor(i = 0; i < 5; i++) {\r\nieee->seq_ctrl[i] = 0;\r\n}\r\nieee->assoc_id = 0;\r\nieee->queue_stop = 0;\r\nieee->scanning = 0;\r\nieee->softmac_features = 0;\r\nieee->wap_set = 0;\r\nieee->ssid_set = 0;\r\nieee->proto_started = 0;\r\nieee->basic_rate = IEEE80211_DEFAULT_BASIC_RATE;\r\nieee->rate = 3;\r\nieee->ps = IEEE80211_PS_MBCAST|IEEE80211_PS_UNICAST;\r\nieee->sta_sleep = 0;\r\nieee->bInactivePs = false;\r\nieee->actscanning = false;\r\nieee->ListenInterval = 2;\r\nieee->NumRxDataInPeriod = 0;\r\nieee->NumRxBcnInPeriod = 0;\r\nieee->NumRxOkTotal = 0;\r\nieee->NumRxUnicast = 0;\r\nieee->beinretry = false;\r\nieee->bHwRadioOff = false;\r\ninit_mgmt_queue(ieee);\r\nieee->tx_pending.txb = NULL;\r\ninit_timer(&ieee->associate_timer);\r\nieee->associate_timer.data = (unsigned long)ieee;\r\nieee->associate_timer.function = ieee80211_associate_abort_cb;\r\ninit_timer(&ieee->beacon_timer);\r\nieee->beacon_timer.data = (unsigned long) ieee;\r\nieee->beacon_timer.function = ieee80211_send_beacon_cb;\r\nieee->wq = create_workqueue(DRV_NAME);\r\nINIT_DELAYED_WORK(&ieee->start_ibss_wq,(void*) ieee80211_start_ibss_wq);\r\nINIT_WORK(&ieee->associate_complete_wq,(void*) ieee80211_associate_complete_wq);\r\nINIT_WORK(&ieee->associate_procedure_wq,(void*) ieee80211_associate_procedure_wq);\r\nINIT_DELAYED_WORK(&ieee->softmac_scan_wq,(void*) ieee80211_softmac_scan_wq);\r\nINIT_DELAYED_WORK(&ieee->associate_retry_wq,(void*) ieee80211_associate_retry_wq);\r\nINIT_WORK(&ieee->wx_sync_scan_wq,(void*) ieee80211_wx_sync_scan_wq);\r\nsema_init(&ieee->wx_sem, 1);\r\nsema_init(&ieee->scan_sem, 1);\r\nspin_lock_init(&ieee->mgmt_tx_lock);\r\nspin_lock_init(&ieee->beacon_lock);\r\ntasklet_init(&ieee->ps_task,\r\n(void(*)(unsigned long)) ieee80211_sta_ps,\r\n(unsigned long)ieee);\r\nieee->pDot11dInfo = kmalloc(sizeof(RT_DOT11D_INFO), GFP_ATOMIC);\r\n}\r\nvoid ieee80211_softmac_free(struct ieee80211_device *ieee)\r\n{\r\ndown(&ieee->wx_sem);\r\ndel_timer_sync(&ieee->associate_timer);\r\ncancel_delayed_work(&ieee->associate_retry_wq);\r\ncancel_delayed_work(&ieee->GPIOChangeRFWorkItem);\r\ndestroy_workqueue(ieee->wq);\r\nkfree(ieee->pDot11dInfo);\r\nup(&ieee->wx_sem);\r\n}\r\nstatic int ieee80211_wpa_enable(struct ieee80211_device *ieee, int value)\r\n{\r\nprintk("%s WPA\n",value ? "enabling" : "disabling");\r\nieee->wpa_enabled = value;\r\nreturn 0;\r\n}\r\nvoid ieee80211_wpa_assoc_frame(struct ieee80211_device *ieee, char *wpa_ie, int wpa_ie_len)\r\n{\r\nieee80211_wpa_enable(ieee, 1);\r\nieee80211_disassociate(ieee);\r\n}\r\nstatic int ieee80211_wpa_mlme(struct ieee80211_device *ieee, int command, int reason)\r\n{\r\nint ret = 0;\r\nswitch (command) {\r\ncase IEEE_MLME_STA_DEAUTH:\r\nbreak;\r\ncase IEEE_MLME_STA_DISASSOC:\r\nieee80211_disassociate(ieee);\r\nbreak;\r\ndefault:\r\nprintk("Unknown MLME request: %d\n", command);\r\nret = -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ieee80211_wpa_set_wpa_ie(struct ieee80211_device *ieee,\r\nstruct ieee_param *param, int plen)\r\n{\r\nu8 *buf;\r\nif (param->u.wpa_ie.len > MAX_WPA_IE_LEN ||\r\n(param->u.wpa_ie.len && param->u.wpa_ie.data == NULL))\r\nreturn -EINVAL;\r\nif (param->u.wpa_ie.len) {\r\nbuf = kmemdup(param->u.wpa_ie.data, param->u.wpa_ie.len,\r\nGFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nkfree(ieee->wpa_ie);\r\nieee->wpa_ie = buf;\r\nieee->wpa_ie_len = param->u.wpa_ie.len;\r\n} else {\r\nkfree(ieee->wpa_ie);\r\nieee->wpa_ie = NULL;\r\nieee->wpa_ie_len = 0;\r\n}\r\nieee80211_wpa_assoc_frame(ieee, ieee->wpa_ie, ieee->wpa_ie_len);\r\nreturn 0;\r\n}\r\nstatic int ieee80211_wpa_set_auth_algs(struct ieee80211_device *ieee, int value)\r\n{\r\nstruct ieee80211_security sec = {\r\n.flags = SEC_AUTH_MODE,\r\n};\r\nint ret = 0;\r\nif (value & AUTH_ALG_SHARED_KEY) {\r\nsec.auth_mode = WLAN_AUTH_SHARED_KEY;\r\nieee->open_wep = 0;\r\n} else {\r\nsec.auth_mode = WLAN_AUTH_OPEN;\r\nieee->open_wep = 1;\r\n}\r\nif (ieee->set_security)\r\nieee->set_security(ieee->dev, &sec);\r\nelse\r\nret = -EOPNOTSUPP;\r\nreturn ret;\r\n}\r\nstatic int ieee80211_wpa_set_param(struct ieee80211_device *ieee, u8 name, u32 value)\r\n{\r\nint ret=0;\r\nunsigned long flags;\r\nswitch (name) {\r\ncase IEEE_PARAM_WPA_ENABLED:\r\nret = ieee80211_wpa_enable(ieee, value);\r\nbreak;\r\ncase IEEE_PARAM_TKIP_COUNTERMEASURES:\r\nieee->tkip_countermeasures=value;\r\nbreak;\r\ncase IEEE_PARAM_DROP_UNENCRYPTED: {\r\nstruct ieee80211_security sec = {\r\n.flags = SEC_ENABLED,\r\n.enabled = value,\r\n};\r\nieee->drop_unencrypted = value;\r\nif (!value) {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_0;\r\n}\r\nelse {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_1;\r\n}\r\nif (ieee->set_security)\r\nieee->set_security(ieee->dev, &sec);\r\nbreak;\r\n}\r\ncase IEEE_PARAM_PRIVACY_INVOKED:\r\nieee->privacy_invoked=value;\r\nbreak;\r\ncase IEEE_PARAM_AUTH_ALGS:\r\nret = ieee80211_wpa_set_auth_algs(ieee, value);\r\nbreak;\r\ncase IEEE_PARAM_IEEE_802_1X:\r\nieee->ieee802_1x=value;\r\nbreak;\r\ncase IEEE_PARAM_WPAX_SELECT:\r\nspin_lock_irqsave(&ieee->wpax_suitlist_lock,flags);\r\nieee->wpax_type_set = 1;\r\nieee->wpax_type_notify = value;\r\nspin_unlock_irqrestore(&ieee->wpax_suitlist_lock,flags);\r\nbreak;\r\ndefault:\r\nprintk("Unknown WPA param: %d\n",name);\r\nret = -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ieee80211_wpa_set_encryption(struct ieee80211_device *ieee,\r\nstruct ieee_param *param, int param_len)\r\n{\r\nint ret = 0;\r\nstruct ieee80211_crypto_ops *ops;\r\nstruct ieee80211_crypt_data **crypt;\r\nstruct ieee80211_security sec = {\r\n.flags = 0,\r\n};\r\nparam->u.crypt.err = 0;\r\nparam->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';\r\nif (param_len !=\r\n(int) ((char *) param->u.crypt.key - (char *) param) +\r\nparam->u.crypt.key_len) {\r\nprintk("Len mismatch %d, %d\n", param_len,\r\nparam->u.crypt.key_len);\r\nreturn -EINVAL;\r\n}\r\nif (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&\r\nparam->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&\r\nparam->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {\r\nif (param->u.crypt.idx >= WEP_KEYS)\r\nreturn -EINVAL;\r\ncrypt = &ieee->crypt[param->u.crypt.idx];\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nif (strcmp(param->u.crypt.alg, "none") == 0) {\r\nif (crypt) {\r\nsec.enabled = 0;\r\nsec.level = SEC_LEVEL_0;\r\nsec.flags |= SEC_ENABLED | SEC_LEVEL;\r\nieee80211_crypt_delayed_deinit(ieee, crypt);\r\n}\r\ngoto done;\r\n}\r\nsec.enabled = 1;\r\nsec.flags |= SEC_ENABLED;\r\nif (!(ieee->host_encrypt || ieee->host_decrypt) &&\r\nstrcmp(param->u.crypt.alg, "TKIP"))\r\ngoto skip_host_crypt;\r\nops = ieee80211_get_crypto_ops(param->u.crypt.alg);\r\nif (ops == NULL && strcmp(param->u.crypt.alg, "WEP") == 0)\r\nops = ieee80211_get_crypto_ops(param->u.crypt.alg);\r\nelse if (ops == NULL && strcmp(param->u.crypt.alg, "TKIP") == 0)\r\nops = ieee80211_get_crypto_ops(param->u.crypt.alg);\r\nelse if (ops == NULL && strcmp(param->u.crypt.alg, "CCMP") == 0)\r\nops = ieee80211_get_crypto_ops(param->u.crypt.alg);\r\nif (ops == NULL) {\r\nprintk("unknown crypto alg '%s'\n", param->u.crypt.alg);\r\nparam->u.crypt.err = IEEE_CRYPT_ERR_UNKNOWN_ALG;\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (*crypt == NULL || (*crypt)->ops != ops) {\r\nstruct ieee80211_crypt_data *new_crypt;\r\nieee80211_crypt_delayed_deinit(ieee, crypt);\r\nnew_crypt = kmalloc(sizeof(*new_crypt), GFP_KERNEL);\r\nif (new_crypt == NULL) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nmemset(new_crypt, 0, sizeof(struct ieee80211_crypt_data));\r\nnew_crypt->ops = ops;\r\nif (new_crypt->ops)\r\nnew_crypt->priv =\r\nnew_crypt->ops->init(param->u.crypt.idx);\r\nif (new_crypt->priv == NULL) {\r\nkfree(new_crypt);\r\nparam->u.crypt.err = IEEE_CRYPT_ERR_CRYPT_INIT_FAILED;\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\n*crypt = new_crypt;\r\n}\r\nif (param->u.crypt.key_len > 0 && (*crypt)->ops->set_key &&\r\n(*crypt)->ops->set_key(param->u.crypt.key,\r\nparam->u.crypt.key_len, param->u.crypt.seq,\r\n(*crypt)->priv) < 0) {\r\nprintk("key setting failed\n");\r\nparam->u.crypt.err = IEEE_CRYPT_ERR_KEY_SET_FAILED;\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nskip_host_crypt:\r\nif (param->u.crypt.set_tx) {\r\nieee->tx_keyidx = param->u.crypt.idx;\r\nsec.active_key = param->u.crypt.idx;\r\nsec.flags |= SEC_ACTIVE_KEY;\r\n} else\r\nsec.flags &= ~SEC_ACTIVE_KEY;\r\nif (param->u.crypt.alg != NULL) {\r\nmemcpy(sec.keys[param->u.crypt.idx],\r\nparam->u.crypt.key,\r\nparam->u.crypt.key_len);\r\nsec.key_sizes[param->u.crypt.idx] = param->u.crypt.key_len;\r\nsec.flags |= (1 << param->u.crypt.idx);\r\nif (strcmp(param->u.crypt.alg, "WEP") == 0) {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_1;\r\n} else if (strcmp(param->u.crypt.alg, "TKIP") == 0) {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_2;\r\n} else if (strcmp(param->u.crypt.alg, "CCMP") == 0) {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_3;\r\n}\r\n}\r\ndone:\r\nif (ieee->set_security)\r\nieee->set_security(ieee->dev, &sec);\r\nif (ieee->reset_on_keychange &&\r\nieee->iw_mode != IW_MODE_INFRA &&\r\nieee->reset_port &&\r\nieee->reset_port(ieee->dev)) {\r\nprintk("reset_port failed\n");\r\nparam->u.crypt.err = IEEE_CRYPT_ERR_CARD_CONF_FAILED;\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nint ieee80211_wpa_supplicant_ioctl(struct ieee80211_device *ieee, struct iw_point *p)\r\n{\r\nstruct ieee_param *param;\r\nint ret=0;\r\ndown(&ieee->wx_sem);\r\nif (p->length < sizeof(struct ieee_param) || !p->pointer){\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nparam = kmalloc(p->length, GFP_KERNEL);\r\nif (param == NULL){\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (copy_from_user(param, p->pointer, p->length)) {\r\nkfree(param);\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nswitch (param->cmd) {\r\ncase IEEE_CMD_SET_WPA_PARAM:\r\nret = ieee80211_wpa_set_param(ieee, param->u.wpa_param.name,\r\nparam->u.wpa_param.value);\r\nbreak;\r\ncase IEEE_CMD_SET_WPA_IE:\r\nret = ieee80211_wpa_set_wpa_ie(ieee, param, p->length);\r\nbreak;\r\ncase IEEE_CMD_SET_ENCRYPTION:\r\nret = ieee80211_wpa_set_encryption(ieee, param, p->length);\r\nbreak;\r\ncase IEEE_CMD_MLME:\r\nret = ieee80211_wpa_mlme(ieee, param->u.mlme.command,\r\nparam->u.mlme.reason_code);\r\nbreak;\r\ndefault:\r\nprintk("Unknown WPA supplicant request: %d\n",param->cmd);\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nif (ret == 0 && copy_to_user(p->pointer, param, p->length))\r\nret = -EFAULT;\r\nkfree(param);\r\nout:\r\nup(&ieee->wx_sem);\r\nreturn ret;\r\n}\r\nvoid notify_wx_assoc_event(struct ieee80211_device *ieee)\r\n{\r\nunion iwreq_data wrqu;\r\nwrqu.ap_addr.sa_family = ARPHRD_ETHER;\r\nif (ieee->state == IEEE80211_LINKED)\r\nmemcpy(wrqu.ap_addr.sa_data, ieee->current_network.bssid, ETH_ALEN);\r\nelse\r\nmemset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);\r\nwireless_send_event(ieee->dev, SIOCGIWAP, &wrqu, NULL);\r\n}
