static void dbgp_ehci_status(char *str)\r\n{\r\nif (!ehci_debug)\r\nreturn;\r\ndbgp_printk("dbgp: %s\n", str);\r\ndbgp_printk(" Debug control: %08x", readl(&ehci_debug->control));\r\ndbgp_printk(" ehci cmd : %08x", readl(&ehci_regs->command));\r\ndbgp_printk(" ehci conf flg: %08x\n",\r\nreadl(&ehci_regs->configured_flag));\r\ndbgp_printk(" ehci status : %08x", readl(&ehci_regs->status));\r\ndbgp_printk(" ehci portsc : %08x\n",\r\nreadl(&ehci_regs->port_status[dbgp_phys_port - 1]));\r\n}\r\nstatic inline void dbgp_ehci_status(char *str) { }\r\nstatic inline void dbgp_printk(const char *fmt, ...) { }\r\nstatic inline u32 dbgp_len_update(u32 x, u32 len)\r\n{\r\nreturn (x & ~0x0f) | (len & 0x0f);\r\n}\r\nstatic inline u32 dbgp_pid_write_update(u32 x, u32 tok)\r\n{\r\nstatic int data0 = USB_PID_DATA1;\r\ndata0 ^= USB_PID_DATA_TOGGLE;\r\nreturn (x & 0xffff0000) | (data0 << 8) | (tok & 0xff);\r\n}\r\nstatic inline u32 dbgp_pid_read_update(u32 x, u32 tok)\r\n{\r\nreturn (x & 0xffff0000) | (USB_PID_DATA0 << 8) | (tok & 0xff);\r\n}\r\nstatic int dbgp_wait_until_complete(void)\r\n{\r\nu32 ctrl;\r\nint loop = DBGP_TIMEOUT;\r\ndo {\r\nctrl = readl(&ehci_debug->control);\r\nif (ctrl & DBGP_DONE)\r\nbreak;\r\nudelay(1);\r\n} while (--loop > 0);\r\nif (!loop)\r\nreturn -DBGP_TIMEOUT;\r\nwritel(ctrl | DBGP_DONE, &ehci_debug->control);\r\nreturn (ctrl & DBGP_ERROR) ? -DBGP_ERRCODE(ctrl) : DBGP_LEN(ctrl);\r\n}\r\nstatic inline void dbgp_mdelay(int ms)\r\n{\r\nint i;\r\nwhile (ms--) {\r\nfor (i = 0; i < 1000; i++)\r\noutb(0x1, 0x80);\r\n}\r\n}\r\nstatic void dbgp_breath(void)\r\n{\r\n}\r\nstatic int dbgp_wait_until_done(unsigned ctrl, int loop)\r\n{\r\nu32 pids, lpid;\r\nint ret;\r\nretry:\r\nwritel(ctrl | DBGP_GO, &ehci_debug->control);\r\nret = dbgp_wait_until_complete();\r\npids = readl(&ehci_debug->pids);\r\nlpid = DBGP_PID_GET(pids);\r\nif (ret < 0) {\r\nif (ret == -DBGP_TIMEOUT && !dbgp_not_safe)\r\ndbgp_not_safe = 1;\r\nif (ret == -DBGP_ERR_BAD && --loop > 0)\r\ngoto retry;\r\nreturn ret;\r\n}\r\nif ((lpid == USB_PID_NAK) || (lpid == USB_PID_NYET))\r\ndbgp_breath();\r\nif (lpid == USB_PID_NAK) {\r\nif (--loop > 0)\r\ngoto retry;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline void dbgp_set_data(const void *buf, int size)\r\n{\r\nconst unsigned char *bytes = buf;\r\nu32 lo, hi;\r\nint i;\r\nlo = hi = 0;\r\nfor (i = 0; i < 4 && i < size; i++)\r\nlo |= bytes[i] << (8*i);\r\nfor (; i < 8 && i < size; i++)\r\nhi |= bytes[i] << (8*(i - 4));\r\nwritel(lo, &ehci_debug->data03);\r\nwritel(hi, &ehci_debug->data47);\r\n}\r\nstatic inline void dbgp_get_data(void *buf, int size)\r\n{\r\nunsigned char *bytes = buf;\r\nu32 lo, hi;\r\nint i;\r\nlo = readl(&ehci_debug->data03);\r\nhi = readl(&ehci_debug->data47);\r\nfor (i = 0; i < 4 && i < size; i++)\r\nbytes[i] = (lo >> (8*i)) & 0xff;\r\nfor (; i < 8 && i < size; i++)\r\nbytes[i] = (hi >> (8*(i - 4))) & 0xff;\r\n}\r\nstatic int dbgp_bulk_write(unsigned devnum, unsigned endpoint,\r\nconst char *bytes, int size)\r\n{\r\nint ret;\r\nu32 addr;\r\nu32 pids, ctrl;\r\nif (size > DBGP_MAX_PACKET)\r\nreturn -1;\r\naddr = DBGP_EPADDR(devnum, endpoint);\r\npids = readl(&ehci_debug->pids);\r\npids = dbgp_pid_write_update(pids, USB_PID_OUT);\r\nctrl = readl(&ehci_debug->control);\r\nctrl = dbgp_len_update(ctrl, size);\r\nctrl |= DBGP_OUT;\r\nctrl |= DBGP_GO;\r\ndbgp_set_data(bytes, size);\r\nwritel(addr, &ehci_debug->address);\r\nwritel(pids, &ehci_debug->pids);\r\nret = dbgp_wait_until_done(ctrl, DBGP_LOOPS);\r\nreturn ret;\r\n}\r\nstatic int dbgp_bulk_read(unsigned devnum, unsigned endpoint, void *data,\r\nint size, int loops)\r\n{\r\nu32 pids, addr, ctrl;\r\nint ret;\r\nif (size > DBGP_MAX_PACKET)\r\nreturn -1;\r\naddr = DBGP_EPADDR(devnum, endpoint);\r\npids = readl(&ehci_debug->pids);\r\npids = dbgp_pid_read_update(pids, USB_PID_IN);\r\nctrl = readl(&ehci_debug->control);\r\nctrl = dbgp_len_update(ctrl, size);\r\nctrl &= ~DBGP_OUT;\r\nctrl |= DBGP_GO;\r\nwritel(addr, &ehci_debug->address);\r\nwritel(pids, &ehci_debug->pids);\r\nret = dbgp_wait_until_done(ctrl, loops);\r\nif (ret < 0)\r\nreturn ret;\r\nif (size > ret)\r\nsize = ret;\r\ndbgp_get_data(data, size);\r\nreturn ret;\r\n}\r\nstatic int dbgp_control_msg(unsigned devnum, int requesttype,\r\nint request, int value, int index, void *data, int size)\r\n{\r\nu32 pids, addr, ctrl;\r\nstruct usb_ctrlrequest req;\r\nint read;\r\nint ret;\r\nread = (requesttype & USB_DIR_IN) != 0;\r\nif (size > (read ? DBGP_MAX_PACKET:0))\r\nreturn -1;\r\nreq.bRequestType = requesttype;\r\nreq.bRequest = request;\r\nreq.wValue = cpu_to_le16(value);\r\nreq.wIndex = cpu_to_le16(index);\r\nreq.wLength = cpu_to_le16(size);\r\npids = DBGP_PID_SET(USB_PID_DATA0, USB_PID_SETUP);\r\naddr = DBGP_EPADDR(devnum, 0);\r\nctrl = readl(&ehci_debug->control);\r\nctrl = dbgp_len_update(ctrl, sizeof(req));\r\nctrl |= DBGP_OUT;\r\nctrl |= DBGP_GO;\r\ndbgp_set_data(&req, sizeof(req));\r\nwritel(addr, &ehci_debug->address);\r\nwritel(pids, &ehci_debug->pids);\r\nret = dbgp_wait_until_done(ctrl, DBGP_LOOPS);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn dbgp_bulk_read(devnum, 0, data, size, DBGP_LOOPS);\r\n}\r\nstatic u32 __init find_cap(u32 num, u32 slot, u32 func, int cap)\r\n{\r\nu8 pos;\r\nint bytes;\r\nif (!(read_pci_config_16(num, slot, func, PCI_STATUS) &\r\nPCI_STATUS_CAP_LIST))\r\nreturn 0;\r\npos = read_pci_config_byte(num, slot, func, PCI_CAPABILITY_LIST);\r\nfor (bytes = 0; bytes < 48 && pos >= 0x40; bytes++) {\r\nu8 id;\r\npos &= ~3;\r\nid = read_pci_config_byte(num, slot, func, pos+PCI_CAP_LIST_ID);\r\nif (id == 0xff)\r\nbreak;\r\nif (id == cap)\r\nreturn pos;\r\npos = read_pci_config_byte(num, slot, func,\r\npos+PCI_CAP_LIST_NEXT);\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 __init __find_dbgp(u32 bus, u32 slot, u32 func)\r\n{\r\nu32 class;\r\nclass = read_pci_config(bus, slot, func, PCI_CLASS_REVISION);\r\nif ((class >> 8) != PCI_CLASS_SERIAL_USB_EHCI)\r\nreturn 0;\r\nreturn find_cap(bus, slot, func, PCI_CAP_ID_EHCI_DEBUG);\r\n}\r\nstatic u32 __init find_dbgp(int ehci_num, u32 *rbus, u32 *rslot, u32 *rfunc)\r\n{\r\nu32 bus, slot, func;\r\nfor (bus = 0; bus < 256; bus++) {\r\nfor (slot = 0; slot < 32; slot++) {\r\nfor (func = 0; func < 8; func++) {\r\nunsigned cap;\r\ncap = __find_dbgp(bus, slot, func);\r\nif (!cap)\r\ncontinue;\r\nif (ehci_num-- != 0)\r\ncontinue;\r\n*rbus = bus;\r\n*rslot = slot;\r\n*rfunc = func;\r\nreturn cap;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dbgp_ehci_startup(void)\r\n{\r\nu32 ctrl, cmd, status;\r\nint loop;\r\nctrl = readl(&ehci_debug->control);\r\nctrl |= DBGP_OWNER;\r\nctrl &= ~(DBGP_ENABLED | DBGP_INUSE);\r\nwritel(ctrl, &ehci_debug->control);\r\nudelay(1);\r\ndbgp_ehci_status("EHCI startup");\r\ncmd = readl(&ehci_regs->command);\r\ncmd &= ~(CMD_LRESET | CMD_IAAD | CMD_PSE | CMD_ASE | CMD_RESET);\r\ncmd |= CMD_RUN;\r\nwritel(cmd, &ehci_regs->command);\r\nwritel(FLAG_CF, &ehci_regs->configured_flag);\r\nloop = 10;\r\ndo {\r\nstatus = readl(&ehci_regs->status);\r\nif (!(status & STS_HALT))\r\nbreak;\r\nudelay(1);\r\n} while (--loop > 0);\r\nif (!loop) {\r\ndbgp_printk("ehci can not be started\n");\r\nreturn -ENODEV;\r\n}\r\ndbgp_printk("ehci started\n");\r\nreturn 0;\r\n}\r\nstatic int dbgp_ehci_controller_reset(void)\r\n{\r\nint loop = 250 * 1000;\r\nu32 cmd;\r\ncmd = readl(&ehci_regs->command);\r\ncmd |= CMD_RESET;\r\nwritel(cmd, &ehci_regs->command);\r\ndo {\r\ncmd = readl(&ehci_regs->command);\r\n} while ((cmd & CMD_RESET) && (--loop > 0));\r\nif (!loop) {\r\ndbgp_printk("can not reset ehci\n");\r\nreturn -1;\r\n}\r\ndbgp_ehci_status("ehci reset done");\r\nreturn 0;\r\n}\r\nint dbgp_external_startup(void)\r\n{\r\nint devnum;\r\nstruct usb_debug_descriptor dbgp_desc;\r\nint ret;\r\nu32 ctrl, portsc, cmd;\r\nint dbg_port = dbgp_phys_port;\r\nint tries = 3;\r\nint reset_port_tries = 1;\r\nint try_hard_once = 1;\r\ntry_port_reset_again:\r\nret = dbgp_ehci_startup();\r\nif (ret)\r\nreturn ret;\r\nret = ehci_wait_for_port(dbg_port);\r\nif (ret < 0) {\r\nportsc = readl(&ehci_regs->port_status[dbg_port - 1]);\r\nif (!(portsc & PORT_CONNECT) && try_hard_once) {\r\ntry_hard_once = 0;\r\ncmd = readl(&ehci_regs->command);\r\ncmd &= ~CMD_RUN;\r\nwritel(cmd, &ehci_regs->command);\r\nportsc = readl(&ehci_regs->port_status[dbg_port - 1]);\r\nportsc |= PORT_TEST_PKT;\r\nwritel(portsc, &ehci_regs->port_status[dbg_port - 1]);\r\ndbgp_ehci_status("Trying to force debug port online");\r\nmdelay(50);\r\ndbgp_ehci_controller_reset();\r\ngoto try_port_reset_again;\r\n} else if (reset_port_tries--) {\r\ngoto try_port_reset_again;\r\n}\r\ndbgp_printk("No device found in debug port\n");\r\nreturn -EIO;\r\n}\r\ndbgp_ehci_status("wait for port done");\r\nctrl = readl(&ehci_debug->control);\r\nctrl |= DBGP_CLAIM;\r\nwritel(ctrl, &ehci_debug->control);\r\nctrl = readl(&ehci_debug->control);\r\nif ((ctrl & DBGP_CLAIM) != DBGP_CLAIM) {\r\ndbgp_printk("No device in debug port\n");\r\nwritel(ctrl & ~DBGP_CLAIM, &ehci_debug->control);\r\nreturn -ENODEV;\r\n}\r\ndbgp_ehci_status("debug ported enabled");\r\nportsc = readl(&ehci_regs->port_status[dbg_port - 1]);\r\nportsc &= ~PORT_PE;\r\nwritel(portsc, &ehci_regs->port_status[dbg_port - 1]);\r\ndbgp_mdelay(100);\r\ntry_again:\r\nfor (devnum = 0; devnum <= 127; devnum++) {\r\nret = dbgp_control_msg(devnum,\r\nUSB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE,\r\nUSB_REQ_GET_DESCRIPTOR, (USB_DT_DEBUG << 8), 0,\r\n&dbgp_desc, sizeof(dbgp_desc));\r\nif (ret > 0)\r\nbreak;\r\n}\r\nif (devnum > 127) {\r\ndbgp_printk("Could not find attached debug device\n");\r\ngoto err;\r\n}\r\nif (ret < 0) {\r\ndbgp_printk("Attached device is not a debug device\n");\r\ngoto err;\r\n}\r\ndbgp_endpoint_out = dbgp_desc.bDebugOutEndpoint;\r\ndbgp_endpoint_in = dbgp_desc.bDebugInEndpoint;\r\nif (devnum != USB_DEBUG_DEVNUM) {\r\nret = dbgp_control_msg(devnum,\r\nUSB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_DEVICE,\r\nUSB_REQ_SET_ADDRESS, USB_DEBUG_DEVNUM, 0, NULL, 0);\r\nif (ret < 0) {\r\ndbgp_printk("Could not move attached device to %d\n",\r\nUSB_DEBUG_DEVNUM);\r\ngoto err;\r\n}\r\ndevnum = USB_DEBUG_DEVNUM;\r\ndbgp_printk("debug device renamed to 127\n");\r\n}\r\nret = dbgp_control_msg(USB_DEBUG_DEVNUM,\r\nUSB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_DEVICE,\r\nUSB_REQ_SET_FEATURE, USB_DEVICE_DEBUG_MODE, 0, NULL, 0);\r\nif (ret < 0) {\r\ndbgp_printk(" Could not enable the debug device\n");\r\ngoto err;\r\n}\r\ndbgp_printk("debug interface enabled\n");\r\nret = dbgp_bulk_write(USB_DEBUG_DEVNUM, dbgp_endpoint_out, " ", 1);\r\nif (ret < 0) {\r\ndbgp_printk("dbgp_bulk_write failed: %d\n", ret);\r\ngoto err;\r\n}\r\ndbgp_printk("small write done\n");\r\ndbgp_not_safe = 0;\r\nreturn 0;\r\nerr:\r\nif (tries--)\r\ngoto try_again;\r\nreturn -ENODEV;\r\n}\r\nstatic int ehci_reset_port(int port)\r\n{\r\nu32 portsc;\r\nu32 delay_time, delay;\r\nint loop;\r\ndbgp_ehci_status("reset port");\r\nportsc = readl(&ehci_regs->port_status[port - 1]);\r\nportsc &= ~PORT_PE;\r\nportsc |= PORT_RESET;\r\nwritel(portsc, &ehci_regs->port_status[port - 1]);\r\ndelay = HUB_ROOT_RESET_TIME;\r\nfor (delay_time = 0; delay_time < HUB_RESET_TIMEOUT;\r\ndelay_time += delay) {\r\ndbgp_mdelay(delay);\r\nportsc = readl(&ehci_regs->port_status[port - 1]);\r\nif (!(portsc & PORT_RESET))\r\nbreak;\r\n}\r\nif (portsc & PORT_RESET) {\r\nloop = 100 * 1000;\r\nwritel(portsc & ~(PORT_RWC_BITS | PORT_RESET),\r\n&ehci_regs->port_status[port - 1]);\r\ndo {\r\nudelay(1);\r\nportsc = readl(&ehci_regs->port_status[port-1]);\r\n} while ((portsc & PORT_RESET) && (--loop > 0));\r\n}\r\nif (!(portsc & PORT_CONNECT))\r\nreturn -ENOTCONN;\r\nif ((portsc & PORT_CSC))\r\nreturn -EINVAL;\r\nif (!(portsc & PORT_RESET) && (portsc & PORT_PE))\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int ehci_wait_for_port(int port)\r\n{\r\nu32 status;\r\nint ret, reps;\r\nfor (reps = 0; reps < 300; reps++) {\r\nstatus = readl(&ehci_regs->status);\r\nif (status & STS_PCD)\r\nbreak;\r\ndbgp_mdelay(1);\r\n}\r\nret = ehci_reset_port(port);\r\nif (ret == 0)\r\nreturn 0;\r\nreturn -ENOTCONN;\r\n}\r\nstatic void __init default_set_debug_port(int port)\r\n{\r\n}\r\nstatic void __init nvidia_set_debug_port(int port)\r\n{\r\nu32 dword;\r\ndword = read_pci_config(ehci_dev.bus, ehci_dev.slot, ehci_dev.func,\r\n0x74);\r\ndword &= ~(0x0f<<12);\r\ndword |= ((port & 0x0f)<<12);\r\nwrite_pci_config(ehci_dev.bus, ehci_dev.slot, ehci_dev.func, 0x74,\r\ndword);\r\ndbgp_printk("set debug port to %d\n", port);\r\n}\r\nstatic void __init detect_set_debug_port(void)\r\n{\r\nu32 vendorid;\r\nvendorid = read_pci_config(ehci_dev.bus, ehci_dev.slot, ehci_dev.func,\r\n0x00);\r\nif ((vendorid & 0xffff) == 0x10de) {\r\ndbgp_printk("using nvidia set_debug_port\n");\r\nset_debug_port = nvidia_set_debug_port;\r\n}\r\n}\r\nstatic void __init early_ehci_bios_handoff(void)\r\n{\r\nu32 hcc_params = readl(&ehci_caps->hcc_params);\r\nint offset = (hcc_params >> 8) & 0xff;\r\nu32 cap;\r\nint msec;\r\nif (!offset)\r\nreturn;\r\ncap = read_pci_config(ehci_dev.bus, ehci_dev.slot,\r\nehci_dev.func, offset);\r\ndbgp_printk("dbgp: ehci BIOS state %08x\n", cap);\r\nif ((cap & 0xff) == 1 && (cap & EHCI_USBLEGSUP_BIOS)) {\r\ndbgp_printk("dbgp: BIOS handoff\n");\r\nwrite_pci_config_byte(ehci_dev.bus, ehci_dev.slot,\r\nehci_dev.func, offset + 3, 1);\r\n}\r\nmsec = 1000;\r\nwhile ((cap & EHCI_USBLEGSUP_BIOS) && (msec > 0)) {\r\nmdelay(10);\r\nmsec -= 10;\r\ncap = read_pci_config(ehci_dev.bus, ehci_dev.slot,\r\nehci_dev.func, offset);\r\n}\r\nif (cap & EHCI_USBLEGSUP_BIOS) {\r\ndbgp_printk("dbgp: BIOS handoff failed: %08x\n", cap);\r\nwrite_pci_config_byte(ehci_dev.bus, ehci_dev.slot,\r\nehci_dev.func, offset + 2, 0);\r\n}\r\nwrite_pci_config_byte(ehci_dev.bus, ehci_dev.slot, ehci_dev.func,\r\noffset + EHCI_USBLEGCTLSTS, 0);\r\n}\r\nstatic int __init ehci_setup(void)\r\n{\r\nu32 ctrl, portsc, hcs_params;\r\nu32 debug_port, new_debug_port = 0, n_ports;\r\nint ret, i;\r\nint port_map_tried;\r\nint playtimes = 3;\r\nearly_ehci_bios_handoff();\r\ntry_next_time:\r\nport_map_tried = 0;\r\ntry_next_port:\r\nhcs_params = readl(&ehci_caps->hcs_params);\r\ndebug_port = HCS_DEBUG_PORT(hcs_params);\r\ndbgp_phys_port = debug_port;\r\nn_ports = HCS_N_PORTS(hcs_params);\r\ndbgp_printk("debug_port: %d\n", debug_port);\r\ndbgp_printk("n_ports: %d\n", n_ports);\r\ndbgp_ehci_status("");\r\nfor (i = 1; i <= n_ports; i++) {\r\nportsc = readl(&ehci_regs->port_status[i-1]);\r\ndbgp_printk("portstatus%d: %08x\n", i, portsc);\r\n}\r\nif (port_map_tried && (new_debug_port != debug_port)) {\r\nif (--playtimes) {\r\nset_debug_port(new_debug_port);\r\ngoto try_next_time;\r\n}\r\nreturn -1;\r\n}\r\nif (!(readl(&ehci_regs->configured_flag) & FLAG_CF)) {\r\nif (dbgp_ehci_controller_reset() != 0)\r\nreturn -1;\r\n} else {\r\ndbgp_ehci_status("ehci skip - already configured");\r\n}\r\nret = dbgp_external_startup();\r\nif (ret == -EIO)\r\ngoto next_debug_port;\r\nif (ret < 0) {\r\nctrl = readl(&ehci_debug->control);\r\nctrl &= ~(DBGP_CLAIM | DBGP_OUT);\r\nwritel(ctrl, &ehci_debug->control);\r\nreturn -1;\r\n}\r\nreturn 0;\r\nnext_debug_port:\r\nport_map_tried |= (1<<(debug_port - 1));\r\nnew_debug_port = ((debug_port-1+1)%n_ports) + 1;\r\nif (port_map_tried != ((1<<n_ports) - 1)) {\r\nset_debug_port(new_debug_port);\r\ngoto try_next_port;\r\n}\r\nif (--playtimes) {\r\nset_debug_port(new_debug_port);\r\ngoto try_next_time;\r\n}\r\nreturn -1;\r\n}\r\nint __init early_dbgp_init(char *s)\r\n{\r\nu32 debug_port, bar, offset;\r\nu32 bus, slot, func, cap;\r\nvoid __iomem *ehci_bar;\r\nu32 dbgp_num;\r\nu32 bar_val;\r\nchar *e;\r\nint ret;\r\nu8 byte;\r\nif (!early_pci_allowed())\r\nreturn -1;\r\ndbgp_num = 0;\r\nif (*s)\r\ndbgp_num = simple_strtoul(s, &e, 10);\r\ndbgp_printk("dbgp_num: %d\n", dbgp_num);\r\ncap = find_dbgp(dbgp_num, &bus, &slot, &func);\r\nif (!cap)\r\nreturn -1;\r\ndbgp_printk("Found EHCI debug port on %02x:%02x.%1x\n", bus, slot,\r\nfunc);\r\ndebug_port = read_pci_config(bus, slot, func, cap);\r\nbar = (debug_port >> 29) & 0x7;\r\nbar = (bar * 4) + 0xc;\r\noffset = (debug_port >> 16) & 0xfff;\r\ndbgp_printk("bar: %02x offset: %03x\n", bar, offset);\r\nif (bar != PCI_BASE_ADDRESS_0) {\r\ndbgp_printk("only debug ports on bar 1 handled.\n");\r\nreturn -1;\r\n}\r\nbar_val = read_pci_config(bus, slot, func, PCI_BASE_ADDRESS_0);\r\ndbgp_printk("bar_val: %02x offset: %03x\n", bar_val, offset);\r\nif (bar_val & ~PCI_BASE_ADDRESS_MEM_MASK) {\r\ndbgp_printk("only simple 32bit mmio bars supported\n");\r\nreturn -1;\r\n}\r\nbyte = read_pci_config_byte(bus, slot, func, 0x04);\r\nif (!(byte & 0x2)) {\r\nbyte |= 0x02;\r\nwrite_pci_config_byte(bus, slot, func, 0x04, byte);\r\ndbgp_printk("mmio for ehci enabled\n");\r\n}\r\nset_fixmap_nocache(FIX_DBGP_BASE, bar_val & PAGE_MASK);\r\nehci_bar = (void __iomem *)__fix_to_virt(FIX_DBGP_BASE);\r\nehci_bar += bar_val & ~PAGE_MASK;\r\ndbgp_printk("ehci_bar: %p\n", ehci_bar);\r\nehci_caps = ehci_bar;\r\nehci_regs = ehci_bar + EARLY_HC_LENGTH(readl(&ehci_caps->hc_capbase));\r\nehci_debug = ehci_bar + offset;\r\nehci_dev.bus = bus;\r\nehci_dev.slot = slot;\r\nehci_dev.func = func;\r\ndetect_set_debug_port();\r\nret = ehci_setup();\r\nif (ret < 0) {\r\ndbgp_printk("ehci_setup failed\n");\r\nehci_debug = NULL;\r\nreturn -1;\r\n}\r\ndbgp_ehci_status("early_init_complete");\r\nreturn 0;\r\n}\r\nstatic void early_dbgp_write(struct console *con, const char *str, u32 n)\r\n{\r\nint chunk, ret;\r\nchar buf[DBGP_MAX_PACKET];\r\nint use_cr = 0;\r\nu32 cmd, ctrl;\r\nint reset_run = 0;\r\nif (!ehci_debug || dbgp_not_safe)\r\nreturn;\r\ncmd = readl(&ehci_regs->command);\r\nif (unlikely(!(cmd & CMD_RUN))) {\r\nctrl = readl(&ehci_debug->control);\r\nif (!(ctrl & DBGP_ENABLED)) {\r\ndbgp_not_safe = 1;\r\ndbgp_external_startup();\r\n} else {\r\ncmd |= CMD_RUN;\r\nwritel(cmd, &ehci_regs->command);\r\nreset_run = 1;\r\n}\r\n}\r\nwhile (n > 0) {\r\nfor (chunk = 0; chunk < DBGP_MAX_PACKET && n > 0;\r\nstr++, chunk++, n--) {\r\nif (!use_cr && *str == '\n') {\r\nuse_cr = 1;\r\nbuf[chunk] = '\r';\r\nstr--;\r\nn++;\r\ncontinue;\r\n}\r\nif (use_cr)\r\nuse_cr = 0;\r\nbuf[chunk] = *str;\r\n}\r\nif (chunk > 0) {\r\nret = dbgp_bulk_write(USB_DEBUG_DEVNUM,\r\ndbgp_endpoint_out, buf, chunk);\r\n}\r\n}\r\nif (unlikely(reset_run)) {\r\ncmd = readl(&ehci_regs->command);\r\ncmd &= ~CMD_RUN;\r\nwritel(cmd, &ehci_regs->command);\r\n}\r\n}\r\nint dbgp_reset_prep(void)\r\n{\r\nu32 ctrl;\r\ndbgp_not_safe = 1;\r\nif (!ehci_debug)\r\nreturn 0;\r\nif ((early_dbgp_console.index != -1 &&\r\n!(early_dbgp_console.flags & CON_BOOT)) ||\r\ndbgp_kgdb_mode)\r\nreturn 1;\r\nctrl = readl(&ehci_debug->control);\r\nif (ctrl & DBGP_ENABLED) {\r\nctrl &= ~(DBGP_CLAIM);\r\nwritel(ctrl, &ehci_debug->control);\r\n}\r\nreturn 0;\r\n}\r\nstatic int kgdbdbgp_read_char(void)\r\n{\r\nint ret;\r\nif (kgdbdbgp_buf_idx < kgdbdbgp_buf_sz) {\r\nchar ch = kgdbdbgp_buf[kgdbdbgp_buf_idx++];\r\nreturn ch;\r\n}\r\nret = dbgp_bulk_read(USB_DEBUG_DEVNUM, dbgp_endpoint_in,\r\n&kgdbdbgp_buf, DBGP_MAX_PACKET,\r\nkgdbdbgp_loop_cnt);\r\nif (ret <= 0)\r\nreturn NO_POLL_CHAR;\r\nkgdbdbgp_buf_sz = ret;\r\nkgdbdbgp_buf_idx = 1;\r\nreturn kgdbdbgp_buf[0];\r\n}\r\nstatic void kgdbdbgp_write_char(u8 chr)\r\n{\r\nearly_dbgp_write(NULL, &chr, 1);\r\n}\r\nstatic int __init kgdbdbgp_parse_config(char *str)\r\n{\r\nchar *ptr;\r\nif (!ehci_debug) {\r\nif (early_dbgp_init(str))\r\nreturn -1;\r\n}\r\nptr = strchr(str, ',');\r\nif (ptr) {\r\nptr++;\r\nkgdbdbgp_wait_time = simple_strtoul(ptr, &ptr, 10);\r\n}\r\nkgdb_register_io_module(&kgdbdbgp_io_ops);\r\nkgdbdbgp_io_ops.is_console = early_dbgp_console.index != -1;\r\nreturn 0;\r\n}\r\nstatic int kgdbdbgp_reader_thread(void *ptr)\r\n{\r\nint ret;\r\nwhile (readl(&ehci_debug->control) & DBGP_ENABLED) {\r\nkgdbdbgp_loop_cnt = 1;\r\nret = kgdbdbgp_read_char();\r\nkgdbdbgp_loop_cnt = DBGP_LOOPS;\r\nif (ret != NO_POLL_CHAR) {\r\nif (ret == 0x3 || ret == '$') {\r\nif (ret == '$')\r\nkgdbdbgp_buf_idx--;\r\nkgdb_breakpoint();\r\n}\r\ncontinue;\r\n}\r\nschedule_timeout_interruptible(kgdbdbgp_wait_time * HZ);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init kgdbdbgp_start_thread(void)\r\n{\r\nif (dbgp_kgdb_mode && kgdbdbgp_wait_time)\r\nkthread_run(kgdbdbgp_reader_thread, NULL, "%s", "dbgp");\r\nreturn 0;\r\n}
