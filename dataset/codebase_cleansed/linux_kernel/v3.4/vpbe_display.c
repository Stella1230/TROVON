static int venc_is_second_field(struct vpbe_display *disp_dev)\r\n{\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\nint ret;\r\nint val;\r\nret = v4l2_subdev_call(vpbe_dev->venc,\r\ncore,\r\nioctl,\r\nVENC_GET_FLD,\r\n&val);\r\nif (ret < 0) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Error in getting Field ID 0\n");\r\n}\r\nreturn val;\r\n}\r\nstatic void vpbe_isr_even_field(struct vpbe_display *disp_obj,\r\nstruct vpbe_layer *layer)\r\n{\r\nstruct timespec timevalue;\r\nif (layer->cur_frm == layer->next_frm)\r\nreturn;\r\nktime_get_ts(&timevalue);\r\nlayer->cur_frm->ts.tv_sec = timevalue.tv_sec;\r\nlayer->cur_frm->ts.tv_usec = timevalue.tv_nsec / NSEC_PER_USEC;\r\nlayer->cur_frm->state = VIDEOBUF_DONE;\r\nwake_up_interruptible(&layer->cur_frm->done);\r\nlayer->cur_frm = layer->next_frm;\r\n}\r\nstatic void vpbe_isr_odd_field(struct vpbe_display *disp_obj,\r\nstruct vpbe_layer *layer)\r\n{\r\nstruct osd_state *osd_device = disp_obj->osd_device;\r\nunsigned long addr;\r\nspin_lock(&disp_obj->dma_queue_lock);\r\nif (list_empty(&layer->dma_queue) ||\r\n(layer->cur_frm != layer->next_frm)) {\r\nspin_unlock(&disp_obj->dma_queue_lock);\r\nreturn;\r\n}\r\nlayer->next_frm = list_entry(\r\nlayer->dma_queue.next,\r\nstruct videobuf_buffer,\r\nqueue);\r\nlist_del(&layer->next_frm->queue);\r\nspin_unlock(&disp_obj->dma_queue_lock);\r\nlayer->next_frm->state = VIDEOBUF_ACTIVE;\r\naddr = videobuf_to_dma_contig(layer->next_frm);\r\nosd_device->ops.start_layer(osd_device,\r\nlayer->layer_info.id,\r\naddr,\r\ndisp_obj->cbcr_ofst);\r\n}\r\nstatic irqreturn_t venc_isr(int irq, void *arg)\r\n{\r\nstruct vpbe_display *disp_dev = (struct vpbe_display *)arg;\r\nstruct vpbe_layer *layer;\r\nstatic unsigned last_event;\r\nunsigned event = 0;\r\nint fid;\r\nint i;\r\nif ((NULL == arg) || (NULL == disp_dev->dev[0]))\r\nreturn IRQ_HANDLED;\r\nif (venc_is_second_field(disp_dev))\r\nevent |= VENC_SECOND_FIELD;\r\nelse\r\nevent |= VENC_FIRST_FIELD;\r\nif (event == (last_event & ~VENC_END_OF_FRAME)) {\r\nevent |= VENC_END_OF_FRAME;\r\n} else if (event == VENC_SECOND_FIELD) {\r\nevent |= VENC_END_OF_FRAME;\r\n}\r\nlast_event = event;\r\nfor (i = 0; i < VPBE_DISPLAY_MAX_DEVICES; i++) {\r\nlayer = disp_dev->dev[i];\r\nif (!layer->started)\r\ncontinue;\r\nif (layer->layer_first_int) {\r\nlayer->layer_first_int = 0;\r\ncontinue;\r\n}\r\nif ((V4L2_FIELD_NONE == layer->pix_fmt.field) &&\r\n(event & VENC_END_OF_FRAME)) {\r\nvpbe_isr_even_field(disp_dev, layer);\r\nvpbe_isr_odd_field(disp_dev, layer);\r\n} else {\r\nlayer->field_id ^= 1;\r\nif (event & VENC_FIRST_FIELD)\r\nfid = 0;\r\nelse\r\nfid = 1;\r\nif (fid != layer->field_id) {\r\nlayer->field_id = fid;\r\ncontinue;\r\n}\r\nif (0 == fid)\r\nvpbe_isr_even_field(disp_dev, layer);\r\nelse\r\nvpbe_isr_odd_field(disp_dev, layer);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int vpbe_buffer_prepare(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct vpbe_fh *fh = q->priv_data;\r\nstruct vpbe_layer *layer = fh->layer;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nunsigned long addr;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"vpbe_buffer_prepare\n");\r\nif (VIDEOBUF_NEEDS_INIT == vb->state) {\r\nvb->width = layer->pix_fmt.width;\r\nvb->height = layer->pix_fmt.height;\r\nvb->size = layer->pix_fmt.sizeimage;\r\nvb->field = field;\r\nret = videobuf_iolock(q, vb, NULL);\r\nif (ret < 0) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "Failed to map \\r\nuser address\n");\r\nreturn -EINVAL;\r\n}\r\naddr = videobuf_to_dma_contig(vb);\r\nif (q->streaming) {\r\nif (!IS_ALIGNED(addr, 8)) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"buffer_prepare:offset is \\r\nnot aligned to 32 bytes\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nvb->state = VIDEOBUF_PREPARED;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpbe_buffer_setup(struct videobuf_queue *q,\r\nunsigned int *count,\r\nunsigned int *size)\r\n{\r\nstruct vpbe_fh *fh = q->priv_data;\r\nstruct vpbe_layer *layer = fh->layer;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "vpbe_buffer_setup\n");\r\n*size = layer->pix_fmt.sizeimage;\r\nif (*count < VPBE_DEFAULT_NUM_BUFS)\r\n*count = layer->numbuffers = VPBE_DEFAULT_NUM_BUFS;\r\nreturn 0;\r\n}\r\nstatic void vpbe_buffer_queue(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct vpbe_fh *fh = q->priv_data;\r\nstruct vpbe_layer *layer = fh->layer;\r\nstruct vpbe_display *disp = fh->disp_dev;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nunsigned long flags;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"vpbe_buffer_queue\n");\r\nspin_lock_irqsave(&disp->dma_queue_lock, flags);\r\nlist_add_tail(&vb->queue, &layer->dma_queue);\r\nspin_unlock_irqrestore(&disp->dma_queue_lock, flags);\r\nvb->state = VIDEOBUF_QUEUED;\r\n}\r\nstatic void vpbe_buffer_release(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct vpbe_fh *fh = q->priv_data;\r\nstruct vpbe_layer *layer = fh->layer;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"vpbe_buffer_release\n");\r\nif (V4L2_MEMORY_USERPTR != layer->memory)\r\nvideobuf_dma_contig_free(q, vb);\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic\r\nstruct vpbe_layer*\r\n_vpbe_display_get_other_win_layer(struct vpbe_display *disp_dev,\r\nstruct vpbe_layer *layer)\r\n{\r\nenum vpbe_display_device_id thiswin, otherwin;\r\nthiswin = layer->device_id;\r\notherwin = (thiswin == VPBE_DISPLAY_DEVICE_0) ?\r\nVPBE_DISPLAY_DEVICE_1 : VPBE_DISPLAY_DEVICE_0;\r\nreturn disp_dev->dev[otherwin];\r\n}\r\nstatic int vpbe_set_osd_display_params(struct vpbe_display *disp_dev,\r\nstruct vpbe_layer *layer)\r\n{\r\nstruct osd_layer_config *cfg = &layer->layer_info.config;\r\nstruct osd_state *osd_device = disp_dev->osd_device;\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\nunsigned long addr;\r\nint ret;\r\naddr = videobuf_to_dma_contig(layer->cur_frm);\r\nosd_device->ops.start_layer(osd_device,\r\nlayer->layer_info.id,\r\naddr,\r\ndisp_dev->cbcr_ofst);\r\nret = osd_device->ops.enable_layer(osd_device,\r\nlayer->layer_info.id, 0);\r\nif (ret < 0) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Error in enabling osd window layer 0\n");\r\nreturn -1;\r\n}\r\nlayer->layer_info.enable = 1;\r\nif (cfg->pixfmt == PIXFMT_NV12) {\r\nstruct vpbe_layer *otherlayer =\r\n_vpbe_display_get_other_win_layer(disp_dev, layer);\r\nret = osd_device->ops.enable_layer(osd_device,\r\notherlayer->layer_info.id, 1);\r\nif (ret < 0) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Error in enabling osd window layer 1\n");\r\nreturn -1;\r\n}\r\notherlayer->layer_info.enable = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nvpbe_disp_calculate_scale_factor(struct vpbe_display *disp_dev,\r\nstruct vpbe_layer *layer,\r\nint expected_xsize, int expected_ysize)\r\n{\r\nstruct display_layer_info *layer_info = &layer->layer_info;\r\nstruct v4l2_pix_format *pixfmt = &layer->pix_fmt;\r\nstruct osd_layer_config *cfg = &layer->layer_info.config;\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\nint calculated_xsize;\r\nint h_exp = 0;\r\nint v_exp = 0;\r\nint h_scale;\r\nint v_scale;\r\nv4l2_std_id standard_id = vpbe_dev->current_timings.timings.std_id;\r\ncfg->xsize = pixfmt->width;\r\ncfg->ysize = pixfmt->height;\r\nlayer_info->h_zoom = ZOOM_X1;\r\nlayer_info->v_zoom = ZOOM_X1;\r\nlayer_info->h_exp = H_EXP_OFF;\r\nlayer_info->v_exp = V_EXP_OFF;\r\nif (pixfmt->width < expected_xsize) {\r\nh_scale = vpbe_dev->current_timings.xres / pixfmt->width;\r\nif (h_scale < 2)\r\nh_scale = 1;\r\nelse if (h_scale >= 4)\r\nh_scale = 4;\r\nelse\r\nh_scale = 2;\r\ncfg->xsize *= h_scale;\r\nif (cfg->xsize < expected_xsize) {\r\nif ((standard_id & V4L2_STD_525_60) ||\r\n(standard_id & V4L2_STD_625_50)) {\r\ncalculated_xsize = (cfg->xsize *\r\nVPBE_DISPLAY_H_EXP_RATIO_N) /\r\nVPBE_DISPLAY_H_EXP_RATIO_D;\r\nif (calculated_xsize <= expected_xsize) {\r\nh_exp = 1;\r\ncfg->xsize = calculated_xsize;\r\n}\r\n}\r\n}\r\nif (h_scale == 2)\r\nlayer_info->h_zoom = ZOOM_X2;\r\nelse if (h_scale == 4)\r\nlayer_info->h_zoom = ZOOM_X4;\r\nif (h_exp)\r\nlayer_info->h_exp = H_EXP_9_OVER_8;\r\n} else {\r\ncfg->xsize = expected_xsize;\r\n}\r\nif (pixfmt->height < expected_ysize) {\r\nv_scale = expected_ysize / pixfmt->height;\r\nif (v_scale < 2)\r\nv_scale = 1;\r\nelse if (v_scale >= 4)\r\nv_scale = 4;\r\nelse\r\nv_scale = 2;\r\ncfg->ysize *= v_scale;\r\nif (cfg->ysize < expected_ysize) {\r\nif ((standard_id & V4L2_STD_625_50)) {\r\ncalculated_xsize = (cfg->ysize *\r\nVPBE_DISPLAY_V_EXP_RATIO_N) /\r\nVPBE_DISPLAY_V_EXP_RATIO_D;\r\nif (calculated_xsize <= expected_ysize) {\r\nv_exp = 1;\r\ncfg->ysize = calculated_xsize;\r\n}\r\n}\r\n}\r\nif (v_scale == 2)\r\nlayer_info->v_zoom = ZOOM_X2;\r\nelse if (v_scale == 4)\r\nlayer_info->v_zoom = ZOOM_X4;\r\nif (v_exp)\r\nlayer_info->h_exp = V_EXP_6_OVER_5;\r\n} else {\r\ncfg->ysize = expected_ysize;\r\n}\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"crop display xsize = %d, ysize = %d\n",\r\ncfg->xsize, cfg->ysize);\r\n}\r\nstatic void vpbe_disp_adj_position(struct vpbe_display *disp_dev,\r\nstruct vpbe_layer *layer,\r\nint top, int left)\r\n{\r\nstruct osd_layer_config *cfg = &layer->layer_info.config;\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\ncfg->xpos = min((unsigned int)left,\r\nvpbe_dev->current_timings.xres - cfg->xsize);\r\ncfg->ypos = min((unsigned int)top,\r\nvpbe_dev->current_timings.yres - cfg->ysize);\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"new xpos = %d, ypos = %d\n",\r\ncfg->xpos, cfg->ypos);\r\n}\r\nstatic void vpbe_disp_check_window_params(struct vpbe_display *disp_dev,\r\nstruct v4l2_rect *c)\r\n{\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\nif ((c->width == 0) ||\r\n((c->width + c->left) > vpbe_dev->current_timings.xres))\r\nc->width = vpbe_dev->current_timings.xres - c->left;\r\nif ((c->height == 0) || ((c->height + c->top) >\r\nvpbe_dev->current_timings.yres))\r\nc->height = vpbe_dev->current_timings.yres - c->top;\r\nif (vpbe_dev->current_timings.interlaced)\r\nc->height &= (~0x01);\r\n}\r\nstatic int vpbe_try_format(struct vpbe_display *disp_dev,\r\nstruct v4l2_pix_format *pixfmt, int check)\r\n{\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\nint min_height = 1;\r\nint min_width = 32;\r\nint max_height;\r\nint max_width;\r\nint bpp;\r\nif ((pixfmt->pixelformat != V4L2_PIX_FMT_UYVY) &&\r\n(pixfmt->pixelformat != V4L2_PIX_FMT_NV12))\r\npixfmt->pixelformat = V4L2_PIX_FMT_UYVY;\r\nif ((pixfmt->field != V4L2_FIELD_INTERLACED) &&\r\n(pixfmt->field != V4L2_FIELD_NONE)) {\r\nif (vpbe_dev->current_timings.interlaced)\r\npixfmt->field = V4L2_FIELD_INTERLACED;\r\nelse\r\npixfmt->field = V4L2_FIELD_NONE;\r\n}\r\nif (pixfmt->field == V4L2_FIELD_INTERLACED)\r\nmin_height = 2;\r\nif (pixfmt->pixelformat == V4L2_PIX_FMT_NV12)\r\nbpp = 1;\r\nelse\r\nbpp = 2;\r\nmax_width = vpbe_dev->current_timings.xres;\r\nmax_height = vpbe_dev->current_timings.yres;\r\nmin_width /= bpp;\r\nif (!pixfmt->width || (pixfmt->width < min_width) ||\r\n(pixfmt->width > max_width)) {\r\npixfmt->width = vpbe_dev->current_timings.xres;\r\n}\r\nif (!pixfmt->height || (pixfmt->height < min_height) ||\r\n(pixfmt->height > max_height)) {\r\npixfmt->height = vpbe_dev->current_timings.yres;\r\n}\r\nif (pixfmt->bytesperline < (pixfmt->width * bpp))\r\npixfmt->bytesperline = pixfmt->width * bpp;\r\npixfmt->bytesperline = ((pixfmt->width * bpp + 31) & ~31);\r\nif (pixfmt->pixelformat == V4L2_PIX_FMT_NV12)\r\npixfmt->sizeimage = pixfmt->bytesperline * pixfmt->height +\r\n(pixfmt->bytesperline * pixfmt->height >> 1);\r\nelse\r\npixfmt->sizeimage = pixfmt->bytesperline * pixfmt->height;\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_g_priority(struct file *file, void *priv,\r\nenum v4l2_priority *p)\r\n{\r\nstruct vpbe_fh *fh = file->private_data;\r\nstruct vpbe_layer *layer = fh->layer;\r\n*p = v4l2_prio_max(&layer->prio);\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_s_priority(struct file *file, void *priv,\r\nenum v4l2_priority p)\r\n{\r\nstruct vpbe_fh *fh = file->private_data;\r\nstruct vpbe_layer *layer = fh->layer;\r\nint ret;\r\nret = v4l2_prio_change(&layer->prio, &fh->prio, p);\r\nreturn ret;\r\n}\r\nstatic int vpbe_display_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct vpbe_fh *fh = file->private_data;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\ncap->version = VPBE_DISPLAY_VERSION_CODE;\r\ncap->capabilities = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING;\r\nstrlcpy(cap->driver, VPBE_DISPLAY_DRIVER, sizeof(cap->driver));\r\nstrlcpy(cap->bus_info, "platform", sizeof(cap->bus_info));\r\nstrlcpy(cap->card, vpbe_dev->cfg->module_name, sizeof(cap->card));\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_s_crop(struct file *file, void *priv,\r\nstruct v4l2_crop *crop)\r\n{\r\nstruct vpbe_fh *fh = file->private_data;\r\nstruct vpbe_layer *layer = fh->layer;\r\nstruct vpbe_display *disp_dev = fh->disp_dev;\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\nstruct osd_layer_config *cfg = &layer->layer_info.config;\r\nstruct osd_state *osd_device = disp_dev->osd_device;\r\nstruct v4l2_rect *rect = &crop->c;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"VIDIOC_S_CROP, layer id = %d\n", layer->device_id);\r\nif (crop->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "Invalid buf type\n");\r\nreturn -EINVAL;\r\n}\r\nif (rect->top < 0)\r\nrect->top = 0;\r\nif (rect->left < 0)\r\nrect->left = 0;\r\nvpbe_disp_check_window_params(disp_dev, rect);\r\nosd_device->ops.get_layer_config(osd_device,\r\nlayer->layer_info.id, cfg);\r\nvpbe_disp_calculate_scale_factor(disp_dev, layer,\r\nrect->width,\r\nrect->height);\r\nvpbe_disp_adj_position(disp_dev, layer, rect->top,\r\nrect->left);\r\nret = osd_device->ops.set_layer_config(osd_device,\r\nlayer->layer_info.id, cfg);\r\nif (ret < 0) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Error in set layer config:\n");\r\nreturn -EINVAL;\r\n}\r\nosd_device->ops.set_zoom(osd_device,\r\nlayer->layer_info.id,\r\nlayer->layer_info.h_zoom,\r\nlayer->layer_info.v_zoom);\r\nret = osd_device->ops.set_vid_expansion(osd_device,\r\nlayer->layer_info.h_exp,\r\nlayer->layer_info.v_exp);\r\nif (ret < 0) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Error in set vid expansion:\n");\r\nreturn -EINVAL;\r\n}\r\nif ((layer->layer_info.h_zoom != ZOOM_X1) ||\r\n(layer->layer_info.v_zoom != ZOOM_X1) ||\r\n(layer->layer_info.h_exp != H_EXP_OFF) ||\r\n(layer->layer_info.v_exp != V_EXP_OFF))\r\nosd_device->ops.set_interpolation_filter(osd_device, 1);\r\nelse\r\nosd_device->ops.set_interpolation_filter(osd_device, 0);\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_g_crop(struct file *file, void *priv,\r\nstruct v4l2_crop *crop)\r\n{\r\nstruct vpbe_fh *fh = file->private_data;\r\nstruct vpbe_layer *layer = fh->layer;\r\nstruct osd_layer_config *cfg = &layer->layer_info.config;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nstruct osd_state *osd_device = fh->disp_dev->osd_device;\r\nstruct v4l2_rect *rect = &crop->c;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"VIDIOC_G_CROP, layer id = %d\n",\r\nlayer->device_id);\r\nif (crop->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "Invalid buf type\n");\r\nret = -EINVAL;\r\n}\r\nosd_device->ops.get_layer_config(osd_device,\r\nlayer->layer_info.id, cfg);\r\nrect->top = cfg->ypos;\r\nrect->left = cfg->xpos;\r\nrect->width = cfg->xsize;\r\nrect->height = cfg->ysize;\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_cropcap(struct file *file, void *priv,\r\nstruct v4l2_cropcap *cropcap)\r\n{\r\nstruct vpbe_fh *fh = file->private_data;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "VIDIOC_CROPCAP ioctl\n");\r\ncropcap->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\ncropcap->bounds.left = 0;\r\ncropcap->bounds.top = 0;\r\ncropcap->bounds.width = vpbe_dev->current_timings.xres;\r\ncropcap->bounds.height = vpbe_dev->current_timings.yres;\r\ncropcap->pixelaspect = vpbe_dev->current_timings.aspect;\r\ncropcap->defrect = cropcap->bounds;\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_g_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpbe_fh *fh = file->private_data;\r\nstruct vpbe_layer *layer = fh->layer;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"VIDIOC_G_FMT, layer id = %d\n",\r\nlayer->device_id);\r\nif (V4L2_BUF_TYPE_VIDEO_OUTPUT != fmt->type) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "invalid type\n");\r\nreturn -EINVAL;\r\n}\r\nfmt->fmt.pix = layer->pix_fmt;\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_enum_fmt(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nstruct vpbe_fh *fh = file->private_data;\r\nstruct vpbe_layer *layer = fh->layer;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nunsigned int index = 0;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"VIDIOC_ENUM_FMT, layer id = %d\n",\r\nlayer->device_id);\r\nif (fmt->index > 1) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "Invalid format index\n");\r\nreturn -EINVAL;\r\n}\r\nindex = fmt->index;\r\nmemset(fmt, 0, sizeof(*fmt));\r\nfmt->index = index;\r\nfmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nif (index == 0) {\r\nstrcpy(fmt->description, "YUV 4:2:2 - UYVY");\r\nfmt->pixelformat = V4L2_PIX_FMT_UYVY;\r\n} else {\r\nstrcpy(fmt->description, "Y/CbCr 4:2:0");\r\nfmt->pixelformat = V4L2_PIX_FMT_NV12;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_s_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpbe_fh *fh = file->private_data;\r\nstruct vpbe_layer *layer = fh->layer;\r\nstruct vpbe_display *disp_dev = fh->disp_dev;\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\nstruct osd_layer_config *cfg = &layer->layer_info.config;\r\nstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\r\nstruct osd_state *osd_device = disp_dev->osd_device;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"VIDIOC_S_FMT, layer id = %d\n",\r\nlayer->device_id);\r\nif (layer->started) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "Streaming is started\n");\r\nreturn -EBUSY;\r\n}\r\nif (V4L2_BUF_TYPE_VIDEO_OUTPUT != fmt->type) {\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "invalid type\n");\r\nreturn -EINVAL;\r\n}\r\nret = vpbe_try_format(disp_dev, pixfmt, 1);\r\nif (ret)\r\nreturn ret;\r\nlayer->pix_fmt = *pixfmt;\r\nosd_device->ops.get_layer_config(osd_device,\r\nlayer->layer_info.id, cfg);\r\ncfg->xsize = pixfmt->width;\r\ncfg->ysize = pixfmt->height;\r\ncfg->line_length = pixfmt->bytesperline;\r\ncfg->ypos = 0;\r\ncfg->xpos = 0;\r\ncfg->interlaced = vpbe_dev->current_timings.interlaced;\r\nif (V4L2_PIX_FMT_UYVY == pixfmt->pixelformat)\r\ncfg->pixfmt = PIXFMT_YCbCrI;\r\nif (V4L2_PIX_FMT_NV12 == pixfmt->pixelformat) {\r\nstruct vpbe_layer *otherlayer;\r\ncfg->pixfmt = PIXFMT_NV12;\r\notherlayer = _vpbe_display_get_other_win_layer(disp_dev,\r\nlayer);\r\notherlayer->layer_info.config.pixfmt = PIXFMT_NV12;\r\n}\r\nret = osd_device->ops.set_layer_config(osd_device,\r\nlayer->layer_info.id, cfg);\r\nif (ret < 0) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Error in S_FMT params:\n");\r\nreturn -EINVAL;\r\n}\r\nosd_device->ops.get_layer_config(osd_device,\r\nlayer->layer_info.id, cfg);\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_try_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpbe_fh *fh = file->private_data;\r\nstruct vpbe_display *disp_dev = fh->disp_dev;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "VIDIOC_TRY_FMT\n");\r\nif (V4L2_BUF_TYPE_VIDEO_OUTPUT != fmt->type) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "invalid type\n");\r\nreturn -EINVAL;\r\n}\r\nreturn vpbe_try_format(disp_dev, pixfmt, 0);\r\n}\r\nstatic int vpbe_display_s_std(struct file *file, void *priv,\r\nv4l2_std_id *std_id)\r\n{\r\nstruct vpbe_fh *fh = priv;\r\nstruct vpbe_layer *layer = fh->layer;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "VIDIOC_S_STD\n");\r\nif (layer->started) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "Streaming is started\n");\r\nreturn -EBUSY;\r\n}\r\nif (NULL != vpbe_dev->ops.s_std) {\r\nret = vpbe_dev->ops.s_std(vpbe_dev, std_id);\r\nif (ret) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Failed to set standard for sub devices\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_g_std(struct file *file, void *priv,\r\nv4l2_std_id *std_id)\r\n{\r\nstruct vpbe_fh *fh = priv;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "VIDIOC_G_STD\n");\r\nif (vpbe_dev->current_timings.timings_type & VPBE_ENC_STD) {\r\n*std_id = vpbe_dev->current_timings.timings.std_id;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vpbe_display_enum_output(struct file *file, void *priv,\r\nstruct v4l2_output *output)\r\n{\r\nstruct vpbe_fh *fh = priv;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "VIDIOC_ENUM_OUTPUT\n");\r\nif (NULL == vpbe_dev->ops.enum_outputs)\r\nreturn -EINVAL;\r\nret = vpbe_dev->ops.enum_outputs(vpbe_dev, output);\r\nif (ret) {\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"Failed to enumerate outputs\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_s_output(struct file *file, void *priv,\r\nunsigned int i)\r\n{\r\nstruct vpbe_fh *fh = priv;\r\nstruct vpbe_layer *layer = fh->layer;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "VIDIOC_S_OUTPUT\n");\r\nif (layer->started) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "Streaming is started\n");\r\nreturn -EBUSY;\r\n}\r\nif (NULL == vpbe_dev->ops.set_output)\r\nreturn -EINVAL;\r\nret = vpbe_dev->ops.set_output(vpbe_dev, i);\r\nif (ret) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Failed to set output for sub devices\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_g_output(struct file *file, void *priv,\r\nunsigned int *i)\r\n{\r\nstruct vpbe_fh *fh = priv;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "VIDIOC_G_OUTPUT\n");\r\n*i = vpbe_dev->current_out_index;\r\nreturn 0;\r\n}\r\nstatic int\r\nvpbe_display_enum_dv_presets(struct file *file, void *priv,\r\nstruct v4l2_dv_enum_preset *preset)\r\n{\r\nstruct vpbe_fh *fh = priv;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "VIDIOC_ENUM_DV_PRESETS\n");\r\nif (NULL == vpbe_dev->ops.enum_dv_presets)\r\nreturn -EINVAL;\r\nret = vpbe_dev->ops.enum_dv_presets(vpbe_dev, preset);\r\nif (ret) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Failed to enumerate dv presets info\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nvpbe_display_s_dv_preset(struct file *file, void *priv,\r\nstruct v4l2_dv_preset *preset)\r\n{\r\nstruct vpbe_fh *fh = priv;\r\nstruct vpbe_layer *layer = fh->layer;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "VIDIOC_S_DV_PRESETS\n");\r\nif (layer->started) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "Streaming is started\n");\r\nreturn -EBUSY;\r\n}\r\nif (NULL != vpbe_dev->ops.s_dv_preset)\r\nreturn -EINVAL;\r\nret = vpbe_dev->ops.s_dv_preset(vpbe_dev, preset);\r\nif (ret) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Failed to set the dv presets info\n");\r\nreturn -EINVAL;\r\n}\r\nlayer->video_dev.current_norm = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nvpbe_display_g_dv_preset(struct file *file, void *priv,\r\nstruct v4l2_dv_preset *dv_preset)\r\n{\r\nstruct vpbe_fh *fh = priv;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "VIDIOC_G_DV_PRESETS\n");\r\nif (vpbe_dev->current_timings.timings_type &\r\nVPBE_ENC_DV_PRESET) {\r\ndv_preset->preset =\r\nvpbe_dev->current_timings.timings.dv_preset;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type buf_type)\r\n{\r\nstruct vpbe_fh *fh = file->private_data;\r\nstruct vpbe_layer *layer = fh->layer;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nstruct osd_state *osd_device = fh->disp_dev->osd_device;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"VIDIOC_STREAMOFF,layer id = %d\n",\r\nlayer->device_id);\r\nif (V4L2_BUF_TYPE_VIDEO_OUTPUT != buf_type) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "Invalid buffer type\n");\r\nreturn -EINVAL;\r\n}\r\nif (!fh->io_allowed) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "No io_allowed\n");\r\nreturn -EACCES;\r\n}\r\nif (!layer->started) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "streaming not started in layer"\r\n" id = %d\n", layer->device_id);\r\nreturn -EINVAL;\r\n}\r\nosd_device->ops.disable_layer(osd_device,\r\nlayer->layer_info.id);\r\nlayer->started = 0;\r\nret = videobuf_streamoff(&layer->buffer_queue);\r\nreturn ret;\r\n}\r\nstatic int vpbe_display_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type buf_type)\r\n{\r\nstruct vpbe_fh *fh = file->private_data;\r\nstruct vpbe_layer *layer = fh->layer;\r\nstruct vpbe_display *disp_dev = fh->disp_dev;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nstruct osd_state *osd_device = disp_dev->osd_device;\r\nint ret;\r\nosd_device->ops.disable_layer(osd_device,\r\nlayer->layer_info.id);\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "VIDIOC_STREAMON, layerid=%d\n",\r\nlayer->device_id);\r\nif (V4L2_BUF_TYPE_VIDEO_OUTPUT != buf_type) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "Invalid buffer type\n");\r\nreturn -EINVAL;\r\n}\r\nif (!fh->io_allowed) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "No io_allowed\n");\r\nreturn -EACCES;\r\n}\r\nif (layer->started) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "layer is already streaming\n");\r\nreturn -EBUSY;\r\n}\r\nret = videobuf_streamon(&layer->buffer_queue);\r\nif (ret) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"error in videobuf_streamon\n");\r\nreturn ret;\r\n}\r\nif (list_empty(&layer->dma_queue)) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "buffer queue is empty\n");\r\ngoto streamoff;\r\n}\r\nlayer->next_frm = layer->cur_frm = list_entry(layer->dma_queue.next,\r\nstruct videobuf_buffer, queue);\r\nlist_del(&layer->cur_frm->queue);\r\nlayer->cur_frm->state = VIDEOBUF_ACTIVE;\r\nlayer->field_id = 0;\r\nret = vpbe_set_osd_display_params(disp_dev, layer);\r\nif (ret < 0)\r\ngoto streamoff;\r\nlayer->started = 1;\r\nlayer->layer_first_int = 1;\r\nreturn ret;\r\nstreamoff:\r\nret = videobuf_streamoff(&layer->buffer_queue);\r\nreturn ret;\r\n}\r\nstatic int vpbe_display_dqbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct vpbe_fh *fh = file->private_data;\r\nstruct vpbe_layer *layer = fh->layer;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"VIDIOC_DQBUF, layer id = %d\n",\r\nlayer->device_id);\r\nif (V4L2_BUF_TYPE_VIDEO_OUTPUT != buf->type) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "Invalid buffer type\n");\r\nreturn -EINVAL;\r\n}\r\nif (!fh->io_allowed) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "No io_allowed\n");\r\nreturn -EACCES;\r\n}\r\nif (file->f_flags & O_NONBLOCK)\r\nret = videobuf_dqbuf(&layer->buffer_queue, buf, 1);\r\nelse\r\nret = videobuf_dqbuf(&layer->buffer_queue, buf, 0);\r\nreturn ret;\r\n}\r\nstatic int vpbe_display_qbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nstruct vpbe_fh *fh = file->private_data;\r\nstruct vpbe_layer *layer = fh->layer;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"VIDIOC_QBUF, layer id = %d\n",\r\nlayer->device_id);\r\nif (V4L2_BUF_TYPE_VIDEO_OUTPUT != p->type) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "Invalid buffer type\n");\r\nreturn -EINVAL;\r\n}\r\nif (!fh->io_allowed) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "No io_allowed\n");\r\nreturn -EACCES;\r\n}\r\nreturn videobuf_qbuf(&layer->buffer_queue, p);\r\n}\r\nstatic int vpbe_display_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct vpbe_fh *fh = file->private_data;\r\nstruct vpbe_layer *layer = fh->layer;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"VIDIOC_QUERYBUF, layer id = %d\n",\r\nlayer->device_id);\r\nif (V4L2_BUF_TYPE_VIDEO_OUTPUT != buf->type) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "Invalid buffer type\n");\r\nreturn -EINVAL;\r\n}\r\nret = videobuf_querybuf(&layer->buffer_queue, buf);\r\nreturn ret;\r\n}\r\nstatic int vpbe_display_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *req_buf)\r\n{\r\nstruct vpbe_fh *fh = file->private_data;\r\nstruct vpbe_layer *layer = fh->layer;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "vpbe_display_reqbufs\n");\r\nif (V4L2_BUF_TYPE_VIDEO_OUTPUT != req_buf->type) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "Invalid buffer type\n");\r\nreturn -EINVAL;\r\n}\r\nif (0 != layer->io_usrs) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "not IO user\n");\r\nreturn -EBUSY;\r\n}\r\nvideobuf_queue_dma_contig_init(&layer->buffer_queue,\r\n&video_qops,\r\nvpbe_dev->pdev,\r\n&layer->irqlock,\r\nV4L2_BUF_TYPE_VIDEO_OUTPUT,\r\nlayer->pix_fmt.field,\r\nsizeof(struct videobuf_buffer),\r\nfh, NULL);\r\nfh->io_allowed = 1;\r\nlayer->io_usrs = 1;\r\nlayer->memory = req_buf->memory;\r\nINIT_LIST_HEAD(&layer->dma_queue);\r\nret = videobuf_reqbufs(&layer->buffer_queue, req_buf);\r\nreturn ret;\r\n}\r\nstatic int vpbe_display_mmap(struct file *filep, struct vm_area_struct *vma)\r\n{\r\nstruct vpbe_fh *fh = filep->private_data;\r\nstruct vpbe_layer *layer = fh->layer;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "vpbe_display_mmap\n");\r\nreturn videobuf_mmap_mapper(&layer->buffer_queue, vma);\r\n}\r\nstatic unsigned int vpbe_display_poll(struct file *filep, poll_table *wait)\r\n{\r\nstruct vpbe_fh *fh = filep->private_data;\r\nstruct vpbe_layer *layer = fh->layer;\r\nstruct vpbe_device *vpbe_dev = fh->disp_dev->vpbe_dev;\r\nunsigned int err = 0;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "vpbe_display_poll\n");\r\nif (layer->started)\r\nerr = videobuf_poll_stream(filep, &layer->buffer_queue, wait);\r\nreturn err;\r\n}\r\nstatic int vpbe_display_open(struct file *file)\r\n{\r\nstruct vpbe_fh *fh = NULL;\r\nstruct vpbe_layer *layer = video_drvdata(file);\r\nstruct vpbe_display *disp_dev = layer->disp_dev;\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\nstruct osd_state *osd_device = disp_dev->osd_device;\r\nint err;\r\nfh = kmalloc(sizeof(struct vpbe_fh), GFP_KERNEL);\r\nif (fh == NULL) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"unable to allocate memory for file handle object\n");\r\nreturn -ENOMEM;\r\n}\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"vpbe display open plane = %d\n",\r\nlayer->device_id);\r\nfile->private_data = fh;\r\nfh->layer = layer;\r\nfh->disp_dev = disp_dev;\r\nif (!layer->usrs) {\r\nerr = osd_device->ops.request_layer(osd_device,\r\nlayer->layer_info.id);\r\nif (err < 0) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Display Manager failed to allocate layer\n");\r\nkfree(fh);\r\nreturn -EINVAL;\r\n}\r\n}\r\nlayer->usrs++;\r\nfh->io_allowed = 0;\r\nfh->prio = V4L2_PRIORITY_UNSET;\r\nv4l2_prio_open(&layer->prio, &fh->prio);\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"vpbe display device opened successfully\n");\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_release(struct file *file)\r\n{\r\nstruct vpbe_fh *fh = file->private_data;\r\nstruct vpbe_layer *layer = fh->layer;\r\nstruct osd_layer_config *cfg = &layer->layer_info.config;\r\nstruct vpbe_display *disp_dev = fh->disp_dev;\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\nstruct osd_state *osd_device = disp_dev->osd_device;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "vpbe_display_release\n");\r\nif (fh->io_allowed) {\r\nlayer->io_usrs = 0;\r\nosd_device->ops.disable_layer(osd_device,\r\nlayer->layer_info.id);\r\nlayer->started = 0;\r\nvideobuf_queue_cancel(&layer->buffer_queue);\r\nvideobuf_mmap_free(&layer->buffer_queue);\r\n}\r\nlayer->usrs--;\r\nif (!layer->usrs) {\r\nif (cfg->pixfmt == PIXFMT_NV12) {\r\nstruct vpbe_layer *otherlayer;\r\notherlayer =\r\n_vpbe_display_get_other_win_layer(disp_dev, layer);\r\nosd_device->ops.disable_layer(osd_device,\r\notherlayer->layer_info.id);\r\nosd_device->ops.release_layer(osd_device,\r\notherlayer->layer_info.id);\r\n}\r\nosd_device->ops.disable_layer(osd_device,\r\nlayer->layer_info.id);\r\nosd_device->ops.release_layer(osd_device,\r\nlayer->layer_info.id);\r\n}\r\nv4l2_prio_close(&layer->prio, fh->prio);\r\nfile->private_data = NULL;\r\nkfree(fh);\r\ndisp_dev->cbcr_ofst = 0;\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_g_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct v4l2_dbg_match *match = &reg->match;\r\nif (match->type >= 2) {\r\nv4l2_subdev_call(vpbe_dev->venc,\r\ncore,\r\ng_register,\r\nreg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_s_register(struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vpbe_device_get(struct device *dev, void *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct vpbe_display *vpbe_disp = data;\r\nif (strcmp("vpbe_controller", pdev->name) == 0)\r\nvpbe_disp->vpbe_dev = platform_get_drvdata(pdev);\r\nif (strcmp("vpbe-osd", pdev->name) == 0)\r\nvpbe_disp->osd_device = platform_get_drvdata(pdev);\r\nreturn 0;\r\n}\r\nstatic __devinit int init_vpbe_layer(int i, struct vpbe_display *disp_dev,\r\nstruct platform_device *pdev)\r\n{\r\nstruct vpbe_layer *vpbe_display_layer = NULL;\r\nstruct video_device *vbd = NULL;\r\ndisp_dev->dev[i] =\r\nkzalloc(sizeof(struct vpbe_layer), GFP_KERNEL);\r\nif (!disp_dev->dev[i]) {\r\nprintk(KERN_ERR "ran out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&disp_dev->dev[i]->irqlock);\r\nmutex_init(&disp_dev->dev[i]->opslock);\r\nvpbe_display_layer = disp_dev->dev[i];\r\nvbd = &vpbe_display_layer->video_dev;\r\nvbd->release = video_device_release_empty;\r\nvbd->fops = &vpbe_fops;\r\nvbd->ioctl_ops = &vpbe_ioctl_ops;\r\nvbd->minor = -1;\r\nvbd->v4l2_dev = &disp_dev->vpbe_dev->v4l2_dev;\r\nvbd->lock = &vpbe_display_layer->opslock;\r\nif (disp_dev->vpbe_dev->current_timings.timings_type &\r\nVPBE_ENC_STD) {\r\nvbd->tvnorms = (V4L2_STD_525_60 | V4L2_STD_625_50);\r\nvbd->current_norm =\r\ndisp_dev->vpbe_dev->\r\ncurrent_timings.timings.std_id;\r\n} else\r\nvbd->current_norm = 0;\r\nsnprintf(vbd->name, sizeof(vbd->name),\r\n"DaVinci_VPBE Display_DRIVER_V%d.%d.%d",\r\n(VPBE_DISPLAY_VERSION_CODE >> 16) & 0xff,\r\n(VPBE_DISPLAY_VERSION_CODE >> 8) & 0xff,\r\n(VPBE_DISPLAY_VERSION_CODE) & 0xff);\r\nvpbe_display_layer->device_id = i;\r\nvpbe_display_layer->layer_info.id =\r\n((i == VPBE_DISPLAY_DEVICE_0) ? WIN_VID0 : WIN_VID1);\r\nv4l2_prio_init(&vpbe_display_layer->prio);\r\nreturn 0;\r\n}\r\nstatic __devinit int register_device(struct vpbe_layer *vpbe_display_layer,\r\nstruct vpbe_display *disp_dev,\r\nstruct platform_device *pdev) {\r\nint err;\r\nv4l2_info(&disp_dev->vpbe_dev->v4l2_dev,\r\n"Trying to register VPBE display device.\n");\r\nv4l2_info(&disp_dev->vpbe_dev->v4l2_dev,\r\n"layer=%x,layer->video_dev=%x\n",\r\n(int)vpbe_display_layer,\r\n(int)&vpbe_display_layer->video_dev);\r\nerr = video_register_device(&vpbe_display_layer->video_dev,\r\nVFL_TYPE_GRABBER,\r\n-1);\r\nif (err)\r\nreturn -ENODEV;\r\nvpbe_display_layer->disp_dev = disp_dev;\r\nplatform_set_drvdata(pdev, disp_dev);\r\nvideo_set_drvdata(&vpbe_display_layer->video_dev,\r\nvpbe_display_layer);\r\nreturn 0;\r\n}\r\nstatic __devinit int vpbe_display_probe(struct platform_device *pdev)\r\n{\r\nstruct vpbe_layer *vpbe_display_layer;\r\nstruct vpbe_display *disp_dev;\r\nstruct resource *res = NULL;\r\nint k;\r\nint i;\r\nint err;\r\nint irq;\r\nprintk(KERN_DEBUG "vpbe_display_probe\n");\r\ndisp_dev = kzalloc(sizeof(struct vpbe_display), GFP_KERNEL);\r\nif (!disp_dev) {\r\nprintk(KERN_ERR "ran out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&disp_dev->dma_queue_lock);\r\nerr = bus_for_each_dev(&platform_bus_type, NULL, disp_dev,\r\nvpbe_device_get);\r\nif (err < 0)\r\nreturn err;\r\nif (NULL != disp_dev->vpbe_dev->ops.initialize) {\r\nerr = disp_dev->vpbe_dev->ops.initialize(&pdev->dev,\r\ndisp_dev->vpbe_dev);\r\nif (err) {\r\nv4l2_err(&disp_dev->vpbe_dev->v4l2_dev,\r\n"Error initing vpbe\n");\r\nerr = -ENOMEM;\r\ngoto probe_out;\r\n}\r\n}\r\nfor (i = 0; i < VPBE_DISPLAY_MAX_DEVICES; i++) {\r\nif (init_vpbe_layer(i, disp_dev, pdev)) {\r\nerr = -ENODEV;\r\ngoto probe_out;\r\n}\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res) {\r\nv4l2_err(&disp_dev->vpbe_dev->v4l2_dev,\r\n"Unable to get VENC interrupt resource\n");\r\nerr = -ENODEV;\r\ngoto probe_out;\r\n}\r\nirq = res->start;\r\nif (request_irq(irq, venc_isr, IRQF_DISABLED, VPBE_DISPLAY_DRIVER,\r\ndisp_dev)) {\r\nv4l2_err(&disp_dev->vpbe_dev->v4l2_dev,\r\n"Unable to request interrupt\n");\r\nerr = -ENODEV;\r\ngoto probe_out;\r\n}\r\nfor (i = 0; i < VPBE_DISPLAY_MAX_DEVICES; i++) {\r\nif (register_device(disp_dev->dev[i], disp_dev, pdev)) {\r\nerr = -ENODEV;\r\ngoto probe_out_irq;\r\n}\r\n}\r\nprintk(KERN_DEBUG "Successfully completed the probing of vpbe v4l2 device\n");\r\nreturn 0;\r\nprobe_out_irq:\r\nfree_irq(res->start, disp_dev);\r\nprobe_out:\r\nfor (k = 0; k < VPBE_DISPLAY_MAX_DEVICES; k++) {\r\nvpbe_display_layer = disp_dev->dev[k];\r\nif (vpbe_display_layer) {\r\nvideo_unregister_device(\r\n&vpbe_display_layer->video_dev);\r\nkfree(disp_dev->dev[k]);\r\n}\r\n}\r\nkfree(disp_dev);\r\nreturn err;\r\n}\r\nstatic int vpbe_display_remove(struct platform_device *pdev)\r\n{\r\nstruct vpbe_layer *vpbe_display_layer;\r\nstruct vpbe_display *disp_dev = platform_get_drvdata(pdev);\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\nstruct resource *res;\r\nint i;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "vpbe_display_remove\n");\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nfree_irq(res->start, disp_dev);\r\nif (NULL != vpbe_dev->ops.deinitialize)\r\nvpbe_dev->ops.deinitialize(&pdev->dev, vpbe_dev);\r\nfor (i = 0; i < VPBE_DISPLAY_MAX_DEVICES; i++) {\r\nvpbe_display_layer = disp_dev->dev[i];\r\nvideo_unregister_device(&vpbe_display_layer->video_dev);\r\n}\r\nfor (i = 0; i < VPBE_DISPLAY_MAX_DEVICES; i++) {\r\nkfree(disp_dev->dev[i]);\r\ndisp_dev->dev[i] = NULL;\r\n}\r\nreturn 0;\r\n}
