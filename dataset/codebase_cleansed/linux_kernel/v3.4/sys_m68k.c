asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,\r\nunsigned long prot, unsigned long flags,\r\nunsigned long fd, unsigned long pgoff)\r\n{\r\nreturn sys_mmap_pgoff(addr, len, prot, flags, fd, pgoff);\r\n}\r\nstatic inline int\r\ncache_flush_040 (unsigned long addr, int scope, int cache, unsigned long len)\r\n{\r\nunsigned long paddr, i;\r\nswitch (scope)\r\n{\r\ncase FLUSH_SCOPE_ALL:\r\nswitch (cache)\r\n{\r\ncase FLUSH_CACHE_DATA:\r\n__asm__ __volatile__ ("nop\n\t"\r\n".chip 68040\n\t"\r\n"cpusha %dc\n\t"\r\n".chip 68k");\r\nbreak;\r\ncase FLUSH_CACHE_INSN:\r\n__asm__ __volatile__ ("nop\n\t"\r\n".chip 68040\n\t"\r\n"cpusha %ic\n\t"\r\n".chip 68k");\r\nbreak;\r\ndefault:\r\ncase FLUSH_CACHE_BOTH:\r\n__asm__ __volatile__ ("nop\n\t"\r\n".chip 68040\n\t"\r\n"cpusha %bc\n\t"\r\n".chip 68k");\r\nbreak;\r\n}\r\nbreak;\r\ncase FLUSH_SCOPE_LINE:\r\nif ((paddr = virt_to_phys_040(addr))) {\r\npaddr += addr & ~(PAGE_MASK | 15);\r\nlen = (len + (addr & 15) + 15) >> 4;\r\n} else {\r\nunsigned long tmp = PAGE_SIZE - (addr & ~PAGE_MASK);\r\nif (len <= tmp)\r\nreturn 0;\r\naddr += tmp;\r\nlen -= tmp;\r\ntmp = PAGE_SIZE;\r\nfor (;;)\r\n{\r\nif ((paddr = virt_to_phys_040(addr)))\r\nbreak;\r\nif (len <= tmp)\r\nreturn 0;\r\naddr += tmp;\r\nlen -= tmp;\r\n}\r\nlen = (len + 15) >> 4;\r\n}\r\ni = (PAGE_SIZE - (paddr & ~PAGE_MASK)) >> 4;\r\nwhile (len--)\r\n{\r\nswitch (cache)\r\n{\r\ncase FLUSH_CACHE_DATA:\r\n__asm__ __volatile__ ("nop\n\t"\r\n".chip 68040\n\t"\r\n"cpushl %%dc,(%0)\n\t"\r\n".chip 68k"\r\n: : "a" (paddr));\r\nbreak;\r\ncase FLUSH_CACHE_INSN:\r\n__asm__ __volatile__ ("nop\n\t"\r\n".chip 68040\n\t"\r\n"cpushl %%ic,(%0)\n\t"\r\n".chip 68k"\r\n: : "a" (paddr));\r\nbreak;\r\ndefault:\r\ncase FLUSH_CACHE_BOTH:\r\n__asm__ __volatile__ ("nop\n\t"\r\n".chip 68040\n\t"\r\n"cpushl %%bc,(%0)\n\t"\r\n".chip 68k"\r\n: : "a" (paddr));\r\nbreak;\r\n}\r\nif (!--i && len)\r\n{\r\naddr += PAGE_SIZE;\r\ni = PAGE_SIZE / 16;\r\nfor (;;)\r\n{\r\nif ((paddr = virt_to_phys_040(addr)))\r\nbreak;\r\nif (len <= i)\r\nreturn 0;\r\nlen -= i;\r\naddr += PAGE_SIZE;\r\n}\r\n}\r\nelse\r\npaddr += 16;\r\n}\r\nbreak;\r\ndefault:\r\ncase FLUSH_SCOPE_PAGE:\r\nlen += (addr & ~PAGE_MASK) + (PAGE_SIZE - 1);\r\nfor (len >>= PAGE_SHIFT; len--; addr += PAGE_SIZE)\r\n{\r\nif (!(paddr = virt_to_phys_040(addr)))\r\ncontinue;\r\nswitch (cache)\r\n{\r\ncase FLUSH_CACHE_DATA:\r\n__asm__ __volatile__ ("nop\n\t"\r\n".chip 68040\n\t"\r\n"cpushp %%dc,(%0)\n\t"\r\n".chip 68k"\r\n: : "a" (paddr));\r\nbreak;\r\ncase FLUSH_CACHE_INSN:\r\n__asm__ __volatile__ ("nop\n\t"\r\n".chip 68040\n\t"\r\n"cpushp %%ic,(%0)\n\t"\r\n".chip 68k"\r\n: : "a" (paddr));\r\nbreak;\r\ndefault:\r\ncase FLUSH_CACHE_BOTH:\r\n__asm__ __volatile__ ("nop\n\t"\r\n".chip 68040\n\t"\r\n"cpushp %%bc,(%0)\n\t"\r\n".chip 68k"\r\n: : "a" (paddr));\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int\r\ncache_flush_060 (unsigned long addr, int scope, int cache, unsigned long len)\r\n{\r\nunsigned long paddr, i;\r\nswitch (scope)\r\n{\r\ncase FLUSH_SCOPE_ALL:\r\nswitch (cache)\r\n{\r\ncase FLUSH_CACHE_DATA:\r\n__asm__ __volatile__ (".chip 68060\n\t"\r\n"cpusha %dc\n\t"\r\n".chip 68k");\r\nbreak;\r\ncase FLUSH_CACHE_INSN:\r\n__asm__ __volatile__ (".chip 68060\n\t"\r\n"cpusha %ic\n\t"\r\n".chip 68k");\r\nbreak;\r\ndefault:\r\ncase FLUSH_CACHE_BOTH:\r\n__asm__ __volatile__ (".chip 68060\n\t"\r\n"cpusha %bc\n\t"\r\n".chip 68k");\r\nbreak;\r\n}\r\nbreak;\r\ncase FLUSH_SCOPE_LINE:\r\nlen += addr & 15;\r\naddr &= -16;\r\nif (!(paddr = virt_to_phys_060(addr))) {\r\nunsigned long tmp = PAGE_SIZE - (addr & ~PAGE_MASK);\r\nif (len <= tmp)\r\nreturn 0;\r\naddr += tmp;\r\nlen -= tmp;\r\ntmp = PAGE_SIZE;\r\nfor (;;)\r\n{\r\nif ((paddr = virt_to_phys_060(addr)))\r\nbreak;\r\nif (len <= tmp)\r\nreturn 0;\r\naddr += tmp;\r\nlen -= tmp;\r\n}\r\n}\r\nlen = (len + 15) >> 4;\r\ni = (PAGE_SIZE - (paddr & ~PAGE_MASK)) >> 4;\r\nwhile (len--)\r\n{\r\nswitch (cache)\r\n{\r\ncase FLUSH_CACHE_DATA:\r\n__asm__ __volatile__ (".chip 68060\n\t"\r\n"cpushl %%dc,(%0)\n\t"\r\n".chip 68k"\r\n: : "a" (paddr));\r\nbreak;\r\ncase FLUSH_CACHE_INSN:\r\n__asm__ __volatile__ (".chip 68060\n\t"\r\n"cpushl %%ic,(%0)\n\t"\r\n".chip 68k"\r\n: : "a" (paddr));\r\nbreak;\r\ndefault:\r\ncase FLUSH_CACHE_BOTH:\r\n__asm__ __volatile__ (".chip 68060\n\t"\r\n"cpushl %%bc,(%0)\n\t"\r\n".chip 68k"\r\n: : "a" (paddr));\r\nbreak;\r\n}\r\nif (!--i && len)\r\n{\r\naddr += PAGE_SIZE;\r\naddr &= PAGE_MASK;\r\ni = PAGE_SIZE / 16;\r\nfor (;;)\r\n{\r\nif ((paddr = virt_to_phys_060(addr)))\r\nbreak;\r\nif (len <= i)\r\nreturn 0;\r\nlen -= i;\r\naddr += PAGE_SIZE;\r\n}\r\n}\r\nelse\r\npaddr += 16;\r\n}\r\nbreak;\r\ndefault:\r\ncase FLUSH_SCOPE_PAGE:\r\nlen += (addr & ~PAGE_MASK) + (PAGE_SIZE - 1);\r\naddr &= PAGE_MASK;\r\nfor (len >>= PAGE_SHIFT; len--; addr += PAGE_SIZE)\r\n{\r\nif (!(paddr = virt_to_phys_060(addr)))\r\ncontinue;\r\nswitch (cache)\r\n{\r\ncase FLUSH_CACHE_DATA:\r\n__asm__ __volatile__ (".chip 68060\n\t"\r\n"cpushp %%dc,(%0)\n\t"\r\n".chip 68k"\r\n: : "a" (paddr));\r\nbreak;\r\ncase FLUSH_CACHE_INSN:\r\n__asm__ __volatile__ (".chip 68060\n\t"\r\n"cpushp %%ic,(%0)\n\t"\r\n".chip 68k"\r\n: : "a" (paddr));\r\nbreak;\r\ndefault:\r\ncase FLUSH_CACHE_BOTH:\r\n__asm__ __volatile__ (".chip 68060\n\t"\r\n"cpushp %%bc,(%0)\n\t"\r\n".chip 68k"\r\n: : "a" (paddr));\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nasmlinkage int\r\nsys_cacheflush (unsigned long addr, int scope, int cache, unsigned long len)\r\n{\r\nstruct vm_area_struct *vma;\r\nint ret = -EINVAL;\r\nif (scope < FLUSH_SCOPE_LINE || scope > FLUSH_SCOPE_ALL ||\r\ncache & ~FLUSH_CACHE_BOTH)\r\ngoto out;\r\nif (scope == FLUSH_SCOPE_ALL) {\r\nret = -EPERM;\r\nif (!capable(CAP_SYS_ADMIN))\r\ngoto out;\r\n} else {\r\nvma = find_vma (current->mm, addr);\r\nret = -EINVAL;\r\nif (addr + len < addr)\r\ngoto out;\r\nif (vma == NULL || addr < vma->vm_start || addr + len > vma->vm_end)\r\ngoto out;\r\n}\r\nif (CPU_IS_020_OR_030) {\r\nif (scope == FLUSH_SCOPE_LINE && len < 256) {\r\nunsigned long cacr;\r\n__asm__ ("movec %%cacr, %0" : "=r" (cacr));\r\nif (cache & FLUSH_CACHE_INSN)\r\ncacr |= 4;\r\nif (cache & FLUSH_CACHE_DATA)\r\ncacr |= 0x400;\r\nlen >>= 2;\r\nwhile (len--) {\r\n__asm__ __volatile__ ("movec %1, %%caar\n\t"\r\n"movec %0, %%cacr"\r\n:\r\n: "r" (cacr), "r" (addr));\r\naddr += 4;\r\n}\r\n} else {\r\nunsigned long cacr;\r\n__asm__ ("movec %%cacr, %0" : "=r" (cacr));\r\nif (cache & FLUSH_CACHE_INSN)\r\ncacr |= 8;\r\nif (cache & FLUSH_CACHE_DATA)\r\ncacr |= 0x800;\r\n__asm__ __volatile__ ("movec %0, %%cacr" : : "r" (cacr));\r\n}\r\nret = 0;\r\ngoto out;\r\n} else {\r\nif (len>=3*PAGE_SIZE && scope<FLUSH_SCOPE_PAGE)\r\nscope=FLUSH_SCOPE_PAGE;\r\nif (len>=10*PAGE_SIZE && scope<FLUSH_SCOPE_ALL)\r\nscope=FLUSH_SCOPE_ALL;\r\nif (CPU_IS_040) {\r\nret = cache_flush_040 (addr, scope, cache, len);\r\n} else if (CPU_IS_060) {\r\nret = cache_flush_060 (addr, scope, cache, len);\r\n}\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nasmlinkage int\r\nsys_atomic_cmpxchg_32(unsigned long newval, int oldval, int d3, int d4, int d5,\r\nunsigned long __user * mem)\r\n{\r\nfor (;;) {\r\nstruct mm_struct *mm = current->mm;\r\npgd_t *pgd;\r\npmd_t *pmd;\r\npte_t *pte;\r\nspinlock_t *ptl;\r\nunsigned long mem_value;\r\ndown_read(&mm->mmap_sem);\r\npgd = pgd_offset(mm, (unsigned long)mem);\r\nif (!pgd_present(*pgd))\r\ngoto bad_access;\r\npmd = pmd_offset(pgd, (unsigned long)mem);\r\nif (!pmd_present(*pmd))\r\ngoto bad_access;\r\npte = pte_offset_map_lock(mm, pmd, (unsigned long)mem, &ptl);\r\nif (!pte_present(*pte) || !pte_dirty(*pte)\r\n|| !pte_write(*pte)) {\r\npte_unmap_unlock(pte, ptl);\r\ngoto bad_access;\r\n}\r\nmem_value = *mem;\r\nif (mem_value == oldval)\r\n*mem = newval;\r\npte_unmap_unlock(pte, ptl);\r\nup_read(&mm->mmap_sem);\r\nreturn mem_value;\r\nbad_access:\r\nup_read(&mm->mmap_sem);\r\n{\r\nstruct pt_regs *fp = (struct pt_regs *)&newval;\r\nif (do_page_fault(fp, (unsigned long)mem, 3))\r\nreturn 0xdeadbeef;\r\n}\r\n}\r\n}\r\nasmlinkage int\r\nsys_cacheflush (unsigned long addr, int scope, int cache, unsigned long len)\r\n{\r\nflush_cache_all();\r\nreturn 0;\r\n}\r\nasmlinkage int\r\nsys_atomic_cmpxchg_32(unsigned long newval, int oldval, int d3, int d4, int d5,\r\nunsigned long __user * mem)\r\n{\r\nstruct mm_struct *mm = current->mm;\r\nunsigned long mem_value;\r\ndown_read(&mm->mmap_sem);\r\nmem_value = *mem;\r\nif (mem_value == oldval)\r\n*mem = newval;\r\nup_read(&mm->mmap_sem);\r\nreturn mem_value;\r\n}\r\nasmlinkage int sys_getpagesize(void)\r\n{\r\nreturn PAGE_SIZE;\r\n}\r\nint kernel_execve(const char *filename,\r\nconst char *const argv[],\r\nconst char *const envp[])\r\n{\r\nregister long __res asm ("%d0") = __NR_execve;\r\nregister long __a asm ("%d1") = (long)(filename);\r\nregister long __b asm ("%d2") = (long)(argv);\r\nregister long __c asm ("%d3") = (long)(envp);\r\nasm volatile ("trap #0" : "+d" (__res)\r\n: "d" (__a), "d" (__b), "d" (__c));\r\nreturn __res;\r\n}\r\nasmlinkage unsigned long sys_get_thread_area(void)\r\n{\r\nreturn current_thread_info()->tp_value;\r\n}\r\nasmlinkage int sys_set_thread_area(unsigned long tp)\r\n{\r\ncurrent_thread_info()->tp_value = tp;\r\nreturn 0;\r\n}\r\nasmlinkage int sys_atomic_barrier(void)\r\n{\r\nreturn 0;\r\n}
