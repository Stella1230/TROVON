static void parport_ieee1284_wakeup (struct parport *port)\r\n{\r\nup (&port->physport->ieee1284.irq);\r\n}\r\nstatic void timeout_waiting_on_port (unsigned long cookie)\r\n{\r\nparport_ieee1284_wakeup (port_from_cookie[cookie % PARPORT_MAX]);\r\n}\r\nint parport_wait_event (struct parport *port, signed long timeout)\r\n{\r\nint ret;\r\nstruct timer_list timer;\r\nif (!port->physport->cad->timeout)\r\nreturn 1;\r\ninit_timer_on_stack(&timer);\r\ntimer.expires = jiffies + timeout;\r\ntimer.function = timeout_waiting_on_port;\r\nport_from_cookie[port->number % PARPORT_MAX] = port;\r\ntimer.data = port->number;\r\nadd_timer (&timer);\r\nret = down_interruptible (&port->physport->ieee1284.irq);\r\nif (!del_timer_sync(&timer) && !ret)\r\nret = 1;\r\ndestroy_timer_on_stack(&timer);\r\nreturn ret;\r\n}\r\nint parport_poll_peripheral(struct parport *port,\r\nunsigned char mask,\r\nunsigned char result,\r\nint usec)\r\n{\r\nint count = usec / 5 + 2;\r\nint i;\r\nunsigned char status;\r\nfor (i = 0; i < count; i++) {\r\nstatus = parport_read_status (port);\r\nif ((status & mask) == result)\r\nreturn 0;\r\nif (signal_pending (current))\r\nreturn -EINTR;\r\nif (need_resched())\r\nbreak;\r\nif (i >= 2)\r\nudelay (5);\r\n}\r\nreturn 1;\r\n}\r\nint parport_wait_peripheral(struct parport *port,\r\nunsigned char mask,\r\nunsigned char result)\r\n{\r\nint ret;\r\nint usec;\r\nunsigned long deadline;\r\nunsigned char status;\r\nusec = port->physport->spintime;\r\nif (!port->physport->cad->timeout)\r\nusec = 35000;\r\nret = parport_poll_peripheral (port, mask, result, usec);\r\nif (ret != 1)\r\nreturn ret;\r\nif (!port->physport->cad->timeout)\r\nreturn 1;\r\ndeadline = jiffies + msecs_to_jiffies(40);\r\nwhile (time_before (jiffies, deadline)) {\r\nif (signal_pending (current))\r\nreturn -EINTR;\r\nif ((ret = parport_wait_event (port, msecs_to_jiffies(10))) < 0)\r\nreturn ret;\r\nstatus = parport_read_status (port);\r\nif ((status & mask) == result)\r\nreturn 0;\r\nif (!ret) {\r\nschedule_timeout_interruptible(msecs_to_jiffies(10));\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void parport_ieee1284_terminate (struct parport *port)\r\n{\r\nint r;\r\nport = port->physport;\r\nswitch (port->ieee1284.mode) {\r\ncase IEEE1284_MODE_EPP:\r\ncase IEEE1284_MODE_EPPSL:\r\ncase IEEE1284_MODE_EPPSWE:\r\nparport_frob_control (port, PARPORT_CONTROL_INIT, 0);\r\nudelay (50);\r\nparport_frob_control (port,\r\nPARPORT_CONTROL_SELECT\r\n| PARPORT_CONTROL_INIT,\r\nPARPORT_CONTROL_SELECT\r\n| PARPORT_CONTROL_INIT);\r\nbreak;\r\ncase IEEE1284_MODE_ECP:\r\ncase IEEE1284_MODE_ECPRLE:\r\ncase IEEE1284_MODE_ECPSWE:\r\nif (port->ieee1284.phase != IEEE1284_PH_FWD_IDLE) {\r\nparport_frob_control (port,\r\nPARPORT_CONTROL_INIT\r\n| PARPORT_CONTROL_AUTOFD,\r\nPARPORT_CONTROL_INIT\r\n| PARPORT_CONTROL_AUTOFD);\r\nr = parport_wait_peripheral (port,\r\nPARPORT_STATUS_PAPEROUT,\r\nPARPORT_STATUS_PAPEROUT);\r\nif (r)\r\nDPRINTK (KERN_INFO "%s: Timeout at event 49\n",\r\nport->name);\r\nparport_data_forward (port);\r\nDPRINTK (KERN_DEBUG "%s: ECP direction: forward\n",\r\nport->name);\r\nport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\r\n}\r\ndefault:\r\nparport_frob_control (port,\r\nPARPORT_CONTROL_SELECT\r\n| PARPORT_CONTROL_AUTOFD,\r\nPARPORT_CONTROL_SELECT);\r\nr = parport_wait_peripheral (port, PARPORT_STATUS_ACK, 0);\r\nif (r)\r\nDPRINTK (KERN_INFO "%s: Timeout at event 24\n",\r\nport->name);\r\nparport_frob_control (port,\r\nPARPORT_CONTROL_AUTOFD,\r\nPARPORT_CONTROL_AUTOFD);\r\nr = parport_wait_peripheral (port,\r\nPARPORT_STATUS_ACK,\r\nPARPORT_STATUS_ACK);\r\nif (r)\r\nDPRINTK (KERN_INFO "%s: Timeout at event 27\n",\r\nport->name);\r\nparport_frob_control (port, PARPORT_CONTROL_AUTOFD, 0);\r\n}\r\nport->ieee1284.mode = IEEE1284_MODE_COMPAT;\r\nport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\r\nDPRINTK (KERN_DEBUG "%s: In compatibility (forward idle) mode\n",\r\nport->name);\r\n}\r\nint parport_negotiate (struct parport *port, int mode)\r\n{\r\n#ifndef CONFIG_PARPORT_1284\r\nif (mode == IEEE1284_MODE_COMPAT)\r\nreturn 0;\r\nprintk (KERN_ERR "parport: IEEE1284 not supported in this kernel\n");\r\nreturn -1;\r\n#else\r\nint m = mode & ~IEEE1284_ADDR;\r\nint r;\r\nunsigned char xflag;\r\nport = port->physport;\r\nif (port->ieee1284.mode == mode)\r\nreturn 0;\r\nif ((port->ieee1284.mode & ~IEEE1284_ADDR) == (mode & ~IEEE1284_ADDR)){\r\nport->ieee1284.mode = mode;\r\nreturn 0;\r\n}\r\nif (port->ieee1284.mode != IEEE1284_MODE_COMPAT)\r\nparport_ieee1284_terminate (port);\r\nif (mode == IEEE1284_MODE_COMPAT)\r\nreturn 0;\r\nswitch (mode) {\r\ncase IEEE1284_MODE_ECPSWE:\r\nm = IEEE1284_MODE_ECP;\r\nbreak;\r\ncase IEEE1284_MODE_EPPSL:\r\ncase IEEE1284_MODE_EPPSWE:\r\nm = IEEE1284_MODE_EPP;\r\nbreak;\r\ncase IEEE1284_MODE_BECP:\r\nreturn -ENOSYS;\r\n}\r\nif (mode & IEEE1284_EXT_LINK)\r\nm = 1<<7;\r\nport->ieee1284.phase = IEEE1284_PH_NEGOTIATION;\r\nparport_frob_control (port,\r\nPARPORT_CONTROL_STROBE\r\n| PARPORT_CONTROL_AUTOFD\r\n| PARPORT_CONTROL_SELECT,\r\nPARPORT_CONTROL_SELECT);\r\nudelay(1);\r\nparport_data_forward (port);\r\nparport_write_data (port, m);\r\nudelay (400);\r\nparport_frob_control (port,\r\nPARPORT_CONTROL_SELECT\r\n| PARPORT_CONTROL_AUTOFD,\r\nPARPORT_CONTROL_AUTOFD);\r\nif (parport_wait_peripheral (port,\r\nPARPORT_STATUS_ERROR\r\n| PARPORT_STATUS_SELECT\r\n| PARPORT_STATUS_PAPEROUT\r\n| PARPORT_STATUS_ACK,\r\nPARPORT_STATUS_ERROR\r\n| PARPORT_STATUS_SELECT\r\n| PARPORT_STATUS_PAPEROUT)) {\r\nparport_frob_control (port,\r\nPARPORT_CONTROL_SELECT\r\n| PARPORT_CONTROL_AUTOFD,\r\nPARPORT_CONTROL_SELECT);\r\nDPRINTK (KERN_DEBUG\r\n"%s: Peripheral not IEEE1284 compliant (0x%02X)\n",\r\nport->name, parport_read_status (port));\r\nport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\r\nreturn -1;\r\n}\r\nparport_frob_control (port,\r\nPARPORT_CONTROL_STROBE,\r\nPARPORT_CONTROL_STROBE);\r\nudelay (5);\r\nparport_frob_control (port,\r\nPARPORT_CONTROL_STROBE\r\n| PARPORT_CONTROL_AUTOFD,\r\n0);\r\nif (parport_wait_peripheral (port,\r\nPARPORT_STATUS_ACK,\r\nPARPORT_STATUS_ACK)) {\r\nDPRINTK (KERN_DEBUG\r\n"%s: Mode 0x%02x not supported? (0x%02x)\n",\r\nport->name, mode, port->ops->read_status (port));\r\nparport_ieee1284_terminate (port);\r\nreturn 1;\r\n}\r\nxflag = parport_read_status (port) & PARPORT_STATUS_SELECT;\r\nif (mode && !xflag) {\r\nDPRINTK (KERN_DEBUG "%s: Mode 0x%02x rejected by peripheral\n",\r\nport->name, mode);\r\nparport_ieee1284_terminate (port);\r\nreturn 1;\r\n}\r\nif (mode & IEEE1284_EXT_LINK) {\r\nm = mode & 0x7f;\r\nudelay (1);\r\nparport_write_data (port, m);\r\nudelay (1);\r\nparport_frob_control (port,\r\nPARPORT_CONTROL_STROBE,\r\nPARPORT_CONTROL_STROBE);\r\nif (parport_wait_peripheral (port, PARPORT_STATUS_ACK, 0)) {\r\nDPRINTK (KERN_DEBUG\r\n"%s: Event 52 didn't happen\n",\r\nport->name);\r\nparport_ieee1284_terminate (port);\r\nreturn 1;\r\n}\r\nparport_frob_control (port,\r\nPARPORT_CONTROL_STROBE,\r\n0);\r\nif (parport_wait_peripheral (port,\r\nPARPORT_STATUS_ACK,\r\nPARPORT_STATUS_ACK)) {\r\nDPRINTK (KERN_DEBUG\r\n"%s: Mode 0x%02x not supported? (0x%02x)\n",\r\nport->name, mode,\r\nport->ops->read_status (port));\r\nparport_ieee1284_terminate (port);\r\nreturn 1;\r\n}\r\nxflag = parport_read_status (port) & PARPORT_STATUS_SELECT;\r\nif (!xflag) {\r\nDPRINTK (KERN_DEBUG "%s: Extended mode 0x%02x not "\r\n"supported\n", port->name, mode);\r\nparport_ieee1284_terminate (port);\r\nreturn 1;\r\n}\r\n}\r\nDPRINTK (KERN_DEBUG "%s: In mode 0x%02x\n", port->name, mode);\r\nport->ieee1284.mode = mode;\r\nif (!(mode & IEEE1284_EXT_LINK) && (m & IEEE1284_MODE_ECP)) {\r\nport->ieee1284.phase = IEEE1284_PH_ECP_SETUP;\r\nparport_frob_control (port,\r\nPARPORT_CONTROL_AUTOFD,\r\nPARPORT_CONTROL_AUTOFD);\r\nr = parport_wait_peripheral (port,\r\nPARPORT_STATUS_PAPEROUT,\r\nPARPORT_STATUS_PAPEROUT);\r\nif (r) {\r\nDPRINTK (KERN_INFO "%s: Timeout at event 31\n",\r\nport->name);\r\n}\r\nport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\r\nDPRINTK (KERN_DEBUG "%s: ECP direction: forward\n",\r\nport->name);\r\n} else switch (mode) {\r\ncase IEEE1284_MODE_NIBBLE:\r\ncase IEEE1284_MODE_BYTE:\r\nport->ieee1284.phase = IEEE1284_PH_REV_IDLE;\r\nbreak;\r\ndefault:\r\nport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\r\n}\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int parport_ieee1284_ack_data_avail (struct parport *port)\r\n{\r\nif (parport_read_status (port) & PARPORT_STATUS_ERROR)\r\nreturn -1;\r\nport->ops->frob_control (port, PARPORT_CONTROL_AUTOFD, 0);\r\nport->ieee1284.phase = IEEE1284_PH_HBUSY_DAVAIL;\r\nreturn 0;\r\n}\r\nvoid parport_ieee1284_interrupt (void *handle)\r\n{\r\nstruct parport *port = handle;\r\nparport_ieee1284_wakeup (port);\r\n#ifdef CONFIG_PARPORT_1284\r\nif (port->ieee1284.phase == IEEE1284_PH_REV_IDLE) {\r\nDPRINTK (KERN_DEBUG "%s: Data available\n", port->name);\r\nparport_ieee1284_ack_data_avail (port);\r\n}\r\n#endif\r\n}\r\nssize_t parport_write (struct parport *port, const void *buffer, size_t len)\r\n{\r\n#ifndef CONFIG_PARPORT_1284\r\nreturn port->ops->compat_write_data (port, buffer, len, 0);\r\n#else\r\nssize_t retval;\r\nint mode = port->ieee1284.mode;\r\nint addr = mode & IEEE1284_ADDR;\r\nsize_t (*fn) (struct parport *, const void *, size_t, int);\r\nmode &= ~(IEEE1284_DEVICEID | IEEE1284_ADDR);\r\nswitch (mode) {\r\ncase IEEE1284_MODE_NIBBLE:\r\ncase IEEE1284_MODE_BYTE:\r\nparport_negotiate (port, IEEE1284_MODE_COMPAT);\r\ncase IEEE1284_MODE_COMPAT:\r\nDPRINTK (KERN_DEBUG "%s: Using compatibility mode\n",\r\nport->name);\r\nfn = port->ops->compat_write_data;\r\nbreak;\r\ncase IEEE1284_MODE_EPP:\r\nDPRINTK (KERN_DEBUG "%s: Using EPP mode\n", port->name);\r\nif (addr) {\r\nfn = port->ops->epp_write_addr;\r\n} else {\r\nfn = port->ops->epp_write_data;\r\n}\r\nbreak;\r\ncase IEEE1284_MODE_EPPSWE:\r\nDPRINTK (KERN_DEBUG "%s: Using software-emulated EPP mode\n",\r\nport->name);\r\nif (addr) {\r\nfn = parport_ieee1284_epp_write_addr;\r\n} else {\r\nfn = parport_ieee1284_epp_write_data;\r\n}\r\nbreak;\r\ncase IEEE1284_MODE_ECP:\r\ncase IEEE1284_MODE_ECPRLE:\r\nDPRINTK (KERN_DEBUG "%s: Using ECP mode\n", port->name);\r\nif (addr) {\r\nfn = port->ops->ecp_write_addr;\r\n} else {\r\nfn = port->ops->ecp_write_data;\r\n}\r\nbreak;\r\ncase IEEE1284_MODE_ECPSWE:\r\nDPRINTK (KERN_DEBUG "%s: Using software-emulated ECP mode\n",\r\nport->name);\r\nif (addr) {\r\nfn = parport_ieee1284_ecp_write_addr;\r\n} else {\r\nfn = parport_ieee1284_ecp_write_data;\r\n}\r\nbreak;\r\ndefault:\r\nDPRINTK (KERN_DEBUG "%s: Unknown mode 0x%02x\n", port->name,\r\nport->ieee1284.mode);\r\nreturn -ENOSYS;\r\n}\r\nretval = (*fn) (port, buffer, len, 0);\r\nDPRINTK (KERN_DEBUG "%s: wrote %d/%d bytes\n", port->name, retval, len);\r\nreturn retval;\r\n#endif\r\n}\r\nssize_t parport_read (struct parport *port, void *buffer, size_t len)\r\n{\r\n#ifndef CONFIG_PARPORT_1284\r\nprintk (KERN_ERR "parport: IEEE1284 not supported in this kernel\n");\r\nreturn -ENODEV;\r\n#else\r\nint mode = port->physport->ieee1284.mode;\r\nint addr = mode & IEEE1284_ADDR;\r\nsize_t (*fn) (struct parport *, void *, size_t, int);\r\nmode &= ~(IEEE1284_DEVICEID | IEEE1284_ADDR);\r\nswitch (mode) {\r\ncase IEEE1284_MODE_COMPAT:\r\nif ((port->physport->modes & PARPORT_MODE_TRISTATE) &&\r\n!parport_negotiate (port, IEEE1284_MODE_BYTE)) {\r\nDPRINTK (KERN_DEBUG "%s: Using byte mode\n", port->name);\r\nfn = port->ops->byte_read_data;\r\nbreak;\r\n}\r\nif (parport_negotiate (port, IEEE1284_MODE_NIBBLE)) {\r\nreturn -EIO;\r\n}\r\ncase IEEE1284_MODE_NIBBLE:\r\nDPRINTK (KERN_DEBUG "%s: Using nibble mode\n", port->name);\r\nfn = port->ops->nibble_read_data;\r\nbreak;\r\ncase IEEE1284_MODE_BYTE:\r\nDPRINTK (KERN_DEBUG "%s: Using byte mode\n", port->name);\r\nfn = port->ops->byte_read_data;\r\nbreak;\r\ncase IEEE1284_MODE_EPP:\r\nDPRINTK (KERN_DEBUG "%s: Using EPP mode\n", port->name);\r\nif (addr) {\r\nfn = port->ops->epp_read_addr;\r\n} else {\r\nfn = port->ops->epp_read_data;\r\n}\r\nbreak;\r\ncase IEEE1284_MODE_EPPSWE:\r\nDPRINTK (KERN_DEBUG "%s: Using software-emulated EPP mode\n",\r\nport->name);\r\nif (addr) {\r\nfn = parport_ieee1284_epp_read_addr;\r\n} else {\r\nfn = parport_ieee1284_epp_read_data;\r\n}\r\nbreak;\r\ncase IEEE1284_MODE_ECP:\r\ncase IEEE1284_MODE_ECPRLE:\r\nDPRINTK (KERN_DEBUG "%s: Using ECP mode\n", port->name);\r\nfn = port->ops->ecp_read_data;\r\nbreak;\r\ncase IEEE1284_MODE_ECPSWE:\r\nDPRINTK (KERN_DEBUG "%s: Using software-emulated ECP mode\n",\r\nport->name);\r\nfn = parport_ieee1284_ecp_read_data;\r\nbreak;\r\ndefault:\r\nDPRINTK (KERN_DEBUG "%s: Unknown mode 0x%02x\n", port->name,\r\nport->physport->ieee1284.mode);\r\nreturn -ENOSYS;\r\n}\r\nreturn (*fn) (port, buffer, len, 0);\r\n#endif\r\n}\r\nlong parport_set_timeout (struct pardevice *dev, long inactivity)\r\n{\r\nlong int old = dev->timeout;\r\ndev->timeout = inactivity;\r\nif (dev->port->physport->cad == dev)\r\nparport_ieee1284_wakeup (dev->port);\r\nreturn old;\r\n}
