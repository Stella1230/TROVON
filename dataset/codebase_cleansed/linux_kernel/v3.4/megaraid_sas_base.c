void\r\nmegasas_issue_dcmd(struct megasas_instance *instance, struct megasas_cmd *cmd)\r\n{\r\ninstance->instancet->fire_cmd(instance,\r\ncmd->frame_phys_addr, 0, instance->reg_set);\r\n}\r\nstruct megasas_cmd *megasas_get_cmd(struct megasas_instance\r\n*instance)\r\n{\r\nunsigned long flags;\r\nstruct megasas_cmd *cmd = NULL;\r\nspin_lock_irqsave(&instance->cmd_pool_lock, flags);\r\nif (!list_empty(&instance->cmd_pool)) {\r\ncmd = list_entry((&instance->cmd_pool)->next,\r\nstruct megasas_cmd, list);\r\nlist_del_init(&cmd->list);\r\n} else {\r\nprintk(KERN_ERR "megasas: Command pool empty!\n");\r\n}\r\nspin_unlock_irqrestore(&instance->cmd_pool_lock, flags);\r\nreturn cmd;\r\n}\r\ninline void\r\nmegasas_return_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&instance->cmd_pool_lock, flags);\r\ncmd->scmd = NULL;\r\ncmd->frame_count = 0;\r\nif ((instance->pdev->device != PCI_DEVICE_ID_LSI_FUSION) &&\r\n(instance->pdev->device != PCI_DEVICE_ID_LSI_INVADER) &&\r\n(reset_devices))\r\ncmd->frame->hdr.cmd = MFI_CMD_INVALID;\r\nlist_add_tail(&cmd->list, &instance->cmd_pool);\r\nspin_unlock_irqrestore(&instance->cmd_pool_lock, flags);\r\n}\r\nstatic inline void\r\nmegasas_enable_intr_xscale(struct megasas_register_set __iomem * regs)\r\n{\r\nwritel(0, &(regs)->outbound_intr_mask);\r\nreadl(&regs->outbound_intr_mask);\r\n}\r\nstatic inline void\r\nmegasas_disable_intr_xscale(struct megasas_register_set __iomem * regs)\r\n{\r\nu32 mask = 0x1f;\r\nwritel(mask, &regs->outbound_intr_mask);\r\nreadl(&regs->outbound_intr_mask);\r\n}\r\nstatic u32\r\nmegasas_read_fw_status_reg_xscale(struct megasas_register_set __iomem * regs)\r\n{\r\nreturn readl(&(regs)->outbound_msg_0);\r\n}\r\nstatic int\r\nmegasas_clear_intr_xscale(struct megasas_register_set __iomem * regs)\r\n{\r\nu32 status;\r\nu32 mfiStatus = 0;\r\nstatus = readl(&regs->outbound_intr_status);\r\nif (status & MFI_OB_INTR_STATUS_MASK)\r\nmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\r\nif (status & MFI_XSCALE_OMR0_CHANGE_INTERRUPT)\r\nmfiStatus |= MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\r\nif (mfiStatus)\r\nwritel(status, &regs->outbound_intr_status);\r\nreadl(&regs->outbound_intr_status);\r\nreturn mfiStatus;\r\n}\r\nstatic inline void\r\nmegasas_fire_cmd_xscale(struct megasas_instance *instance,\r\ndma_addr_t frame_phys_addr,\r\nu32 frame_count,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nwritel((frame_phys_addr >> 3)|(frame_count),\r\n&(regs)->inbound_queue_port);\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\n}\r\nstatic int\r\nmegasas_adp_reset_xscale(struct megasas_instance *instance,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nu32 i;\r\nu32 pcidata;\r\nwritel(MFI_ADP_RESET, &regs->inbound_doorbell);\r\nfor (i = 0; i < 3; i++)\r\nmsleep(1000);\r\npcidata = 0;\r\npci_read_config_dword(instance->pdev, MFI_1068_PCSR_OFFSET, &pcidata);\r\nprintk(KERN_NOTICE "pcidata = %x\n", pcidata);\r\nif (pcidata & 0x2) {\r\nprintk(KERN_NOTICE "mfi 1068 offset read=%x\n", pcidata);\r\npcidata &= ~0x2;\r\npci_write_config_dword(instance->pdev,\r\nMFI_1068_PCSR_OFFSET, pcidata);\r\nfor (i = 0; i < 2; i++)\r\nmsleep(1000);\r\npcidata = 0;\r\npci_read_config_dword(instance->pdev,\r\nMFI_1068_FW_HANDSHAKE_OFFSET, &pcidata);\r\nprintk(KERN_NOTICE "1068 offset handshake read=%x\n", pcidata);\r\nif ((pcidata & 0xffff0000) == MFI_1068_FW_READY) {\r\nprintk(KERN_NOTICE "1068 offset pcidt=%x\n", pcidata);\r\npcidata = 0;\r\npci_write_config_dword(instance->pdev,\r\nMFI_1068_FW_HANDSHAKE_OFFSET, pcidata);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmegasas_check_reset_xscale(struct megasas_instance *instance,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nu32 consumer;\r\nconsumer = *instance->consumer;\r\nif ((instance->adprecovery != MEGASAS_HBA_OPERATIONAL) &&\r\n(*instance->consumer == MEGASAS_ADPRESET_INPROG_SIGN)) {\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void\r\nmegasas_enable_intr_ppc(struct megasas_register_set __iomem * regs)\r\n{\r\nwritel(0xFFFFFFFF, &(regs)->outbound_doorbell_clear);\r\nwritel(~0x80000000, &(regs)->outbound_intr_mask);\r\nreadl(&regs->outbound_intr_mask);\r\n}\r\nstatic inline void\r\nmegasas_disable_intr_ppc(struct megasas_register_set __iomem * regs)\r\n{\r\nu32 mask = 0xFFFFFFFF;\r\nwritel(mask, &regs->outbound_intr_mask);\r\nreadl(&regs->outbound_intr_mask);\r\n}\r\nstatic u32\r\nmegasas_read_fw_status_reg_ppc(struct megasas_register_set __iomem * regs)\r\n{\r\nreturn readl(&(regs)->outbound_scratch_pad);\r\n}\r\nstatic int\r\nmegasas_clear_intr_ppc(struct megasas_register_set __iomem * regs)\r\n{\r\nu32 status, mfiStatus = 0;\r\nstatus = readl(&regs->outbound_intr_status);\r\nif (status & MFI_REPLY_1078_MESSAGE_INTERRUPT)\r\nmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\r\nif (status & MFI_G2_OUTBOUND_DOORBELL_CHANGE_INTERRUPT)\r\nmfiStatus |= MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\r\nwritel(status, &regs->outbound_doorbell_clear);\r\nreadl(&regs->outbound_doorbell_clear);\r\nreturn mfiStatus;\r\n}\r\nstatic inline void\r\nmegasas_fire_cmd_ppc(struct megasas_instance *instance,\r\ndma_addr_t frame_phys_addr,\r\nu32 frame_count,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nwritel((frame_phys_addr | (frame_count<<1))|1,\r\n&(regs)->inbound_queue_port);\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\n}\r\nstatic int\r\nmegasas_check_reset_ppc(struct megasas_instance *instance,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nif (instance->adprecovery != MEGASAS_HBA_OPERATIONAL)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline void\r\nmegasas_enable_intr_skinny(struct megasas_register_set __iomem *regs)\r\n{\r\nwritel(0xFFFFFFFF, &(regs)->outbound_intr_mask);\r\nwritel(~MFI_SKINNY_ENABLE_INTERRUPT_MASK, &(regs)->outbound_intr_mask);\r\nreadl(&regs->outbound_intr_mask);\r\n}\r\nstatic inline void\r\nmegasas_disable_intr_skinny(struct megasas_register_set __iomem *regs)\r\n{\r\nu32 mask = 0xFFFFFFFF;\r\nwritel(mask, &regs->outbound_intr_mask);\r\nreadl(&regs->outbound_intr_mask);\r\n}\r\nstatic u32\r\nmegasas_read_fw_status_reg_skinny(struct megasas_register_set __iomem *regs)\r\n{\r\nreturn readl(&(regs)->outbound_scratch_pad);\r\n}\r\nstatic int\r\nmegasas_clear_intr_skinny(struct megasas_register_set __iomem *regs)\r\n{\r\nu32 status;\r\nu32 mfiStatus = 0;\r\nstatus = readl(&regs->outbound_intr_status);\r\nif (!(status & MFI_SKINNY_ENABLE_INTERRUPT_MASK)) {\r\nreturn 0;\r\n}\r\nif ((megasas_read_fw_status_reg_gen2(regs) & MFI_STATE_MASK) ==\r\nMFI_STATE_FAULT) {\r\nmfiStatus = MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\r\n} else\r\nmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\r\nwritel(status, &regs->outbound_intr_status);\r\nreadl(&regs->outbound_intr_status);\r\nreturn mfiStatus;\r\n}\r\nstatic inline void\r\nmegasas_fire_cmd_skinny(struct megasas_instance *instance,\r\ndma_addr_t frame_phys_addr,\r\nu32 frame_count,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nwritel(0, &(regs)->inbound_high_queue_port);\r\nwritel((frame_phys_addr | (frame_count<<1))|1,\r\n&(regs)->inbound_low_queue_port);\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\n}\r\nstatic int\r\nmegasas_check_reset_skinny(struct megasas_instance *instance,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nif (instance->adprecovery != MEGASAS_HBA_OPERATIONAL)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline void\r\nmegasas_enable_intr_gen2(struct megasas_register_set __iomem *regs)\r\n{\r\nwritel(0xFFFFFFFF, &(regs)->outbound_doorbell_clear);\r\nwritel(~MFI_GEN2_ENABLE_INTERRUPT_MASK, &(regs)->outbound_intr_mask);\r\nreadl(&regs->outbound_intr_mask);\r\n}\r\nstatic inline void\r\nmegasas_disable_intr_gen2(struct megasas_register_set __iomem *regs)\r\n{\r\nu32 mask = 0xFFFFFFFF;\r\nwritel(mask, &regs->outbound_intr_mask);\r\nreadl(&regs->outbound_intr_mask);\r\n}\r\nstatic u32\r\nmegasas_read_fw_status_reg_gen2(struct megasas_register_set __iomem *regs)\r\n{\r\nreturn readl(&(regs)->outbound_scratch_pad);\r\n}\r\nstatic int\r\nmegasas_clear_intr_gen2(struct megasas_register_set __iomem *regs)\r\n{\r\nu32 status;\r\nu32 mfiStatus = 0;\r\nstatus = readl(&regs->outbound_intr_status);\r\nif (status & MFI_GEN2_ENABLE_INTERRUPT_MASK) {\r\nmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\r\n}\r\nif (status & MFI_G2_OUTBOUND_DOORBELL_CHANGE_INTERRUPT) {\r\nmfiStatus |= MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\r\n}\r\nif (mfiStatus)\r\nwritel(status, &regs->outbound_doorbell_clear);\r\nreadl(&regs->outbound_intr_status);\r\nreturn mfiStatus;\r\n}\r\nstatic inline void\r\nmegasas_fire_cmd_gen2(struct megasas_instance *instance,\r\ndma_addr_t frame_phys_addr,\r\nu32 frame_count,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nwritel((frame_phys_addr | (frame_count<<1))|1,\r\n&(regs)->inbound_queue_port);\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\n}\r\nstatic int\r\nmegasas_adp_reset_gen2(struct megasas_instance *instance,\r\nstruct megasas_register_set __iomem *reg_set)\r\n{\r\nu32 retry = 0 ;\r\nu32 HostDiag;\r\nu32 *seq_offset = &reg_set->seq_offset;\r\nu32 *hostdiag_offset = &reg_set->host_diag;\r\nif (instance->instancet == &megasas_instance_template_skinny) {\r\nseq_offset = &reg_set->fusion_seq_offset;\r\nhostdiag_offset = &reg_set->fusion_host_diag;\r\n}\r\nwritel(0, seq_offset);\r\nwritel(4, seq_offset);\r\nwritel(0xb, seq_offset);\r\nwritel(2, seq_offset);\r\nwritel(7, seq_offset);\r\nwritel(0xd, seq_offset);\r\nmsleep(1000);\r\nHostDiag = (u32)readl(hostdiag_offset);\r\nwhile ( !( HostDiag & DIAG_WRITE_ENABLE) ) {\r\nmsleep(100);\r\nHostDiag = (u32)readl(hostdiag_offset);\r\nprintk(KERN_NOTICE "RESETGEN2: retry=%x, hostdiag=%x\n",\r\nretry, HostDiag);\r\nif (retry++ >= 100)\r\nreturn 1;\r\n}\r\nprintk(KERN_NOTICE "ADP_RESET_GEN2: HostDiag=%x\n", HostDiag);\r\nwritel((HostDiag | DIAG_RESET_ADAPTER), hostdiag_offset);\r\nssleep(10);\r\nHostDiag = (u32)readl(hostdiag_offset);\r\nwhile ( ( HostDiag & DIAG_RESET_ADAPTER) ) {\r\nmsleep(100);\r\nHostDiag = (u32)readl(hostdiag_offset);\r\nprintk(KERN_NOTICE "RESET_GEN2: retry=%x, hostdiag=%x\n",\r\nretry, HostDiag);\r\nif (retry++ >= 1000)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmegasas_check_reset_gen2(struct megasas_instance *instance,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nif (instance->adprecovery != MEGASAS_HBA_OPERATIONAL) {\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nmegasas_issue_polled(struct megasas_instance *instance, struct megasas_cmd *cmd)\r\n{\r\nstruct megasas_header *frame_hdr = &cmd->frame->hdr;\r\nframe_hdr->cmd_status = 0xFF;\r\nframe_hdr->flags |= MFI_FRAME_DONT_POST_IN_REPLY_QUEUE;\r\ninstance->instancet->issue_dcmd(instance, cmd);\r\nreturn wait_and_poll(instance, cmd);\r\n}\r\nstatic int\r\nmegasas_issue_blocked_cmd(struct megasas_instance *instance,\r\nstruct megasas_cmd *cmd)\r\n{\r\ncmd->cmd_status = ENODATA;\r\ninstance->instancet->issue_dcmd(instance, cmd);\r\nwait_event(instance->int_cmd_wait_q, cmd->cmd_status != ENODATA);\r\nreturn 0;\r\n}\r\nstatic int\r\nmegasas_issue_blocked_abort_cmd(struct megasas_instance *instance,\r\nstruct megasas_cmd *cmd_to_abort)\r\n{\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_abort_frame *abort_fr;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd)\r\nreturn -1;\r\nabort_fr = &cmd->frame->abort;\r\nabort_fr->cmd = MFI_CMD_ABORT;\r\nabort_fr->cmd_status = 0xFF;\r\nabort_fr->flags = 0;\r\nabort_fr->abort_context = cmd_to_abort->index;\r\nabort_fr->abort_mfi_phys_addr_lo = cmd_to_abort->frame_phys_addr;\r\nabort_fr->abort_mfi_phys_addr_hi = 0;\r\ncmd->sync_cmd = 1;\r\ncmd->cmd_status = 0xFF;\r\ninstance->instancet->issue_dcmd(instance, cmd);\r\nwait_event(instance->abort_cmd_wait_q, cmd->cmd_status != 0xFF);\r\ncmd->sync_cmd = 0;\r\nmegasas_return_cmd(instance, cmd);\r\nreturn 0;\r\n}\r\nstatic int\r\nmegasas_make_sgl32(struct megasas_instance *instance, struct scsi_cmnd *scp,\r\nunion megasas_sgl *mfi_sgl)\r\n{\r\nint i;\r\nint sge_count;\r\nstruct scatterlist *os_sgl;\r\nsge_count = scsi_dma_map(scp);\r\nBUG_ON(sge_count < 0);\r\nif (sge_count) {\r\nscsi_for_each_sg(scp, os_sgl, sge_count, i) {\r\nmfi_sgl->sge32[i].length = sg_dma_len(os_sgl);\r\nmfi_sgl->sge32[i].phys_addr = sg_dma_address(os_sgl);\r\n}\r\n}\r\nreturn sge_count;\r\n}\r\nstatic int\r\nmegasas_make_sgl64(struct megasas_instance *instance, struct scsi_cmnd *scp,\r\nunion megasas_sgl *mfi_sgl)\r\n{\r\nint i;\r\nint sge_count;\r\nstruct scatterlist *os_sgl;\r\nsge_count = scsi_dma_map(scp);\r\nBUG_ON(sge_count < 0);\r\nif (sge_count) {\r\nscsi_for_each_sg(scp, os_sgl, sge_count, i) {\r\nmfi_sgl->sge64[i].length = sg_dma_len(os_sgl);\r\nmfi_sgl->sge64[i].phys_addr = sg_dma_address(os_sgl);\r\n}\r\n}\r\nreturn sge_count;\r\n}\r\nstatic int\r\nmegasas_make_sgl_skinny(struct megasas_instance *instance,\r\nstruct scsi_cmnd *scp, union megasas_sgl *mfi_sgl)\r\n{\r\nint i;\r\nint sge_count;\r\nstruct scatterlist *os_sgl;\r\nsge_count = scsi_dma_map(scp);\r\nif (sge_count) {\r\nscsi_for_each_sg(scp, os_sgl, sge_count, i) {\r\nmfi_sgl->sge_skinny[i].length = sg_dma_len(os_sgl);\r\nmfi_sgl->sge_skinny[i].phys_addr =\r\nsg_dma_address(os_sgl);\r\nmfi_sgl->sge_skinny[i].flag = 0;\r\n}\r\n}\r\nreturn sge_count;\r\n}\r\nstatic u32 megasas_get_frame_count(struct megasas_instance *instance,\r\nu8 sge_count, u8 frame_type)\r\n{\r\nint num_cnt;\r\nint sge_bytes;\r\nu32 sge_sz;\r\nu32 frame_count=0;\r\nsge_sz = (IS_DMA64) ? sizeof(struct megasas_sge64) :\r\nsizeof(struct megasas_sge32);\r\nif (instance->flag_ieee) {\r\nsge_sz = sizeof(struct megasas_sge_skinny);\r\n}\r\nif (unlikely(frame_type == PTHRU_FRAME)) {\r\nif (instance->flag_ieee == 1) {\r\nnum_cnt = sge_count - 1;\r\n} else if (IS_DMA64)\r\nnum_cnt = sge_count - 1;\r\nelse\r\nnum_cnt = sge_count - 2;\r\n} else {\r\nif (instance->flag_ieee == 1) {\r\nnum_cnt = sge_count - 1;\r\n} else if (IS_DMA64)\r\nnum_cnt = sge_count - 2;\r\nelse\r\nnum_cnt = sge_count - 3;\r\n}\r\nif(num_cnt>0){\r\nsge_bytes = sge_sz * num_cnt;\r\nframe_count = (sge_bytes / MEGAMFI_FRAME_SIZE) +\r\n((sge_bytes % MEGAMFI_FRAME_SIZE) ? 1 : 0) ;\r\n}\r\nframe_count +=1;\r\nif (frame_count > 7)\r\nframe_count = 8;\r\nreturn frame_count;\r\n}\r\nstatic int\r\nmegasas_build_dcdb(struct megasas_instance *instance, struct scsi_cmnd *scp,\r\nstruct megasas_cmd *cmd)\r\n{\r\nu32 is_logical;\r\nu32 device_id;\r\nu16 flags = 0;\r\nstruct megasas_pthru_frame *pthru;\r\nis_logical = MEGASAS_IS_LOGICAL(scp);\r\ndevice_id = MEGASAS_DEV_INDEX(instance, scp);\r\npthru = (struct megasas_pthru_frame *)cmd->frame;\r\nif (scp->sc_data_direction == PCI_DMA_TODEVICE)\r\nflags = MFI_FRAME_DIR_WRITE;\r\nelse if (scp->sc_data_direction == PCI_DMA_FROMDEVICE)\r\nflags = MFI_FRAME_DIR_READ;\r\nelse if (scp->sc_data_direction == PCI_DMA_NONE)\r\nflags = MFI_FRAME_DIR_NONE;\r\nif (instance->flag_ieee == 1) {\r\nflags |= MFI_FRAME_IEEE;\r\n}\r\npthru->cmd = (is_logical) ? MFI_CMD_LD_SCSI_IO : MFI_CMD_PD_SCSI_IO;\r\npthru->cmd_status = 0x0;\r\npthru->scsi_status = 0x0;\r\npthru->target_id = device_id;\r\npthru->lun = scp->device->lun;\r\npthru->cdb_len = scp->cmd_len;\r\npthru->timeout = 0;\r\npthru->pad_0 = 0;\r\npthru->flags = flags;\r\npthru->data_xfer_len = scsi_bufflen(scp);\r\nmemcpy(pthru->cdb, scp->cmnd, scp->cmd_len);\r\nif (scp->device->type == TYPE_TAPE) {\r\nif ((scp->request->timeout / HZ) > 0xFFFF)\r\npthru->timeout = 0xFFFF;\r\nelse\r\npthru->timeout = scp->request->timeout / HZ;\r\n}\r\nif (instance->flag_ieee == 1) {\r\npthru->flags |= MFI_FRAME_SGL64;\r\npthru->sge_count = megasas_make_sgl_skinny(instance, scp,\r\n&pthru->sgl);\r\n} else if (IS_DMA64) {\r\npthru->flags |= MFI_FRAME_SGL64;\r\npthru->sge_count = megasas_make_sgl64(instance, scp,\r\n&pthru->sgl);\r\n} else\r\npthru->sge_count = megasas_make_sgl32(instance, scp,\r\n&pthru->sgl);\r\nif (pthru->sge_count > instance->max_num_sge) {\r\nprintk(KERN_ERR "megasas: DCDB two many SGE NUM=%x\n",\r\npthru->sge_count);\r\nreturn 0;\r\n}\r\npthru->sense_len = SCSI_SENSE_BUFFERSIZE;\r\npthru->sense_buf_phys_addr_hi = 0;\r\npthru->sense_buf_phys_addr_lo = cmd->sense_phys_addr;\r\ncmd->frame_count = megasas_get_frame_count(instance, pthru->sge_count,\r\nPTHRU_FRAME);\r\nreturn cmd->frame_count;\r\n}\r\nstatic int\r\nmegasas_build_ldio(struct megasas_instance *instance, struct scsi_cmnd *scp,\r\nstruct megasas_cmd *cmd)\r\n{\r\nu32 device_id;\r\nu8 sc = scp->cmnd[0];\r\nu16 flags = 0;\r\nstruct megasas_io_frame *ldio;\r\ndevice_id = MEGASAS_DEV_INDEX(instance, scp);\r\nldio = (struct megasas_io_frame *)cmd->frame;\r\nif (scp->sc_data_direction == PCI_DMA_TODEVICE)\r\nflags = MFI_FRAME_DIR_WRITE;\r\nelse if (scp->sc_data_direction == PCI_DMA_FROMDEVICE)\r\nflags = MFI_FRAME_DIR_READ;\r\nif (instance->flag_ieee == 1) {\r\nflags |= MFI_FRAME_IEEE;\r\n}\r\nldio->cmd = (sc & 0x02) ? MFI_CMD_LD_WRITE : MFI_CMD_LD_READ;\r\nldio->cmd_status = 0x0;\r\nldio->scsi_status = 0x0;\r\nldio->target_id = device_id;\r\nldio->timeout = 0;\r\nldio->reserved_0 = 0;\r\nldio->pad_0 = 0;\r\nldio->flags = flags;\r\nldio->start_lba_hi = 0;\r\nldio->access_byte = (scp->cmd_len != 6) ? scp->cmnd[1] : 0;\r\nif (scp->cmd_len == 6) {\r\nldio->lba_count = (u32) scp->cmnd[4];\r\nldio->start_lba_lo = ((u32) scp->cmnd[1] << 16) |\r\n((u32) scp->cmnd[2] << 8) | (u32) scp->cmnd[3];\r\nldio->start_lba_lo &= 0x1FFFFF;\r\n}\r\nelse if (scp->cmd_len == 10) {\r\nldio->lba_count = (u32) scp->cmnd[8] |\r\n((u32) scp->cmnd[7] << 8);\r\nldio->start_lba_lo = ((u32) scp->cmnd[2] << 24) |\r\n((u32) scp->cmnd[3] << 16) |\r\n((u32) scp->cmnd[4] << 8) | (u32) scp->cmnd[5];\r\n}\r\nelse if (scp->cmd_len == 12) {\r\nldio->lba_count = ((u32) scp->cmnd[6] << 24) |\r\n((u32) scp->cmnd[7] << 16) |\r\n((u32) scp->cmnd[8] << 8) | (u32) scp->cmnd[9];\r\nldio->start_lba_lo = ((u32) scp->cmnd[2] << 24) |\r\n((u32) scp->cmnd[3] << 16) |\r\n((u32) scp->cmnd[4] << 8) | (u32) scp->cmnd[5];\r\n}\r\nelse if (scp->cmd_len == 16) {\r\nldio->lba_count = ((u32) scp->cmnd[10] << 24) |\r\n((u32) scp->cmnd[11] << 16) |\r\n((u32) scp->cmnd[12] << 8) | (u32) scp->cmnd[13];\r\nldio->start_lba_lo = ((u32) scp->cmnd[6] << 24) |\r\n((u32) scp->cmnd[7] << 16) |\r\n((u32) scp->cmnd[8] << 8) | (u32) scp->cmnd[9];\r\nldio->start_lba_hi = ((u32) scp->cmnd[2] << 24) |\r\n((u32) scp->cmnd[3] << 16) |\r\n((u32) scp->cmnd[4] << 8) | (u32) scp->cmnd[5];\r\n}\r\nif (instance->flag_ieee) {\r\nldio->flags |= MFI_FRAME_SGL64;\r\nldio->sge_count = megasas_make_sgl_skinny(instance, scp,\r\n&ldio->sgl);\r\n} else if (IS_DMA64) {\r\nldio->flags |= MFI_FRAME_SGL64;\r\nldio->sge_count = megasas_make_sgl64(instance, scp, &ldio->sgl);\r\n} else\r\nldio->sge_count = megasas_make_sgl32(instance, scp, &ldio->sgl);\r\nif (ldio->sge_count > instance->max_num_sge) {\r\nprintk(KERN_ERR "megasas: build_ld_io: sge_count = %x\n",\r\nldio->sge_count);\r\nreturn 0;\r\n}\r\nldio->sense_len = SCSI_SENSE_BUFFERSIZE;\r\nldio->sense_buf_phys_addr_hi = 0;\r\nldio->sense_buf_phys_addr_lo = cmd->sense_phys_addr;\r\ncmd->frame_count = megasas_get_frame_count(instance,\r\nldio->sge_count, IO_FRAME);\r\nreturn cmd->frame_count;\r\n}\r\ninline int megasas_is_ldio(struct scsi_cmnd *cmd)\r\n{\r\nif (!MEGASAS_IS_LOGICAL(cmd))\r\nreturn 0;\r\nswitch (cmd->cmnd[0]) {\r\ncase READ_10:\r\ncase WRITE_10:\r\ncase READ_12:\r\ncase WRITE_12:\r\ncase READ_6:\r\ncase WRITE_6:\r\ncase READ_16:\r\ncase WRITE_16:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic inline void\r\nmegasas_dump_pending_frames(struct megasas_instance *instance)\r\n{\r\nstruct megasas_cmd *cmd;\r\nint i,n;\r\nunion megasas_sgl *mfi_sgl;\r\nstruct megasas_io_frame *ldio;\r\nstruct megasas_pthru_frame *pthru;\r\nu32 sgcount;\r\nu32 max_cmd = instance->max_fw_cmds;\r\nprintk(KERN_ERR "\nmegasas[%d]: Dumping Frame Phys Address of all pending cmds in FW\n",instance->host->host_no);\r\nprintk(KERN_ERR "megasas[%d]: Total OS Pending cmds : %d\n",instance->host->host_no,atomic_read(&instance->fw_outstanding));\r\nif (IS_DMA64)\r\nprintk(KERN_ERR "\nmegasas[%d]: 64 bit SGLs were sent to FW\n",instance->host->host_no);\r\nelse\r\nprintk(KERN_ERR "\nmegasas[%d]: 32 bit SGLs were sent to FW\n",instance->host->host_no);\r\nprintk(KERN_ERR "megasas[%d]: Pending OS cmds in FW : \n",instance->host->host_no);\r\nfor (i = 0; i < max_cmd; i++) {\r\ncmd = instance->cmd_list[i];\r\nif(!cmd->scmd)\r\ncontinue;\r\nprintk(KERN_ERR "megasas[%d]: Frame addr :0x%08lx : ",instance->host->host_no,(unsigned long)cmd->frame_phys_addr);\r\nif (megasas_is_ldio(cmd->scmd)){\r\nldio = (struct megasas_io_frame *)cmd->frame;\r\nmfi_sgl = &ldio->sgl;\r\nsgcount = ldio->sge_count;\r\nprintk(KERN_ERR "megasas[%d]: frame count : 0x%x, Cmd : 0x%x, Tgt id : 0x%x, lba lo : 0x%x, lba_hi : 0x%x, sense_buf addr : 0x%x,sge count : 0x%x\n",instance->host->host_no, cmd->frame_count,ldio->cmd,ldio->target_id, ldio->start_lba_lo,ldio->start_lba_hi,ldio->sense_buf_phys_addr_lo,sgcount);\r\n}\r\nelse {\r\npthru = (struct megasas_pthru_frame *) cmd->frame;\r\nmfi_sgl = &pthru->sgl;\r\nsgcount = pthru->sge_count;\r\nprintk(KERN_ERR "megasas[%d]: frame count : 0x%x, Cmd : 0x%x, Tgt id : 0x%x, lun : 0x%x, cdb_len : 0x%x, data xfer len : 0x%x, sense_buf addr : 0x%x,sge count : 0x%x\n",instance->host->host_no,cmd->frame_count,pthru->cmd,pthru->target_id,pthru->lun,pthru->cdb_len , pthru->data_xfer_len,pthru->sense_buf_phys_addr_lo,sgcount);\r\n}\r\nif(megasas_dbg_lvl & MEGASAS_DBG_LVL){\r\nfor (n = 0; n < sgcount; n++){\r\nif (IS_DMA64)\r\nprintk(KERN_ERR "megasas: sgl len : 0x%x, sgl addr : 0x%08lx ",mfi_sgl->sge64[n].length , (unsigned long)mfi_sgl->sge64[n].phys_addr) ;\r\nelse\r\nprintk(KERN_ERR "megasas: sgl len : 0x%x, sgl addr : 0x%x ",mfi_sgl->sge32[n].length , mfi_sgl->sge32[n].phys_addr) ;\r\n}\r\n}\r\nprintk(KERN_ERR "\n");\r\n}\r\nprintk(KERN_ERR "\nmegasas[%d]: Pending Internal cmds in FW : \n",instance->host->host_no);\r\nfor (i = 0; i < max_cmd; i++) {\r\ncmd = instance->cmd_list[i];\r\nif(cmd->sync_cmd == 1){\r\nprintk(KERN_ERR "0x%08lx : ", (unsigned long)cmd->frame_phys_addr);\r\n}\r\n}\r\nprintk(KERN_ERR "megasas[%d]: Dumping Done.\n\n",instance->host->host_no);\r\n}\r\nu32\r\nmegasas_build_and_issue_cmd(struct megasas_instance *instance,\r\nstruct scsi_cmnd *scmd)\r\n{\r\nstruct megasas_cmd *cmd;\r\nu32 frame_count;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nif (megasas_is_ldio(scmd))\r\nframe_count = megasas_build_ldio(instance, scmd, cmd);\r\nelse\r\nframe_count = megasas_build_dcdb(instance, scmd, cmd);\r\nif (!frame_count)\r\ngoto out_return_cmd;\r\ncmd->scmd = scmd;\r\nscmd->SCp.ptr = (char *)cmd;\r\natomic_inc(&instance->fw_outstanding);\r\ninstance->instancet->fire_cmd(instance, cmd->frame_phys_addr,\r\ncmd->frame_count-1, instance->reg_set);\r\nreturn 0;\r\nout_return_cmd:\r\nmegasas_return_cmd(instance, cmd);\r\nreturn 1;\r\n}\r\nstatic int\r\nmegasas_queue_command_lck(struct scsi_cmnd *scmd, void (*done) (struct scsi_cmnd *))\r\n{\r\nstruct megasas_instance *instance;\r\nunsigned long flags;\r\ninstance = (struct megasas_instance *)\r\nscmd->device->host->hostdata;\r\nif (instance->issuepend_done == 0)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nif (instance->adprecovery != MEGASAS_HBA_OPERATIONAL) {\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nscmd->scsi_done = done;\r\nscmd->result = 0;\r\nif (MEGASAS_IS_LOGICAL(scmd) &&\r\n(scmd->device->id >= MEGASAS_MAX_LD || scmd->device->lun)) {\r\nscmd->result = DID_BAD_TARGET << 16;\r\ngoto out_done;\r\n}\r\nswitch (scmd->cmnd[0]) {\r\ncase SYNCHRONIZE_CACHE:\r\nscmd->result = DID_OK << 16;\r\ngoto out_done;\r\ndefault:\r\nbreak;\r\n}\r\nif (instance->instancet->build_and_issue_cmd(instance, scmd)) {\r\nprintk(KERN_ERR "megasas: Err returned from build_and_issue_cmd\n");\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nreturn 0;\r\nout_done:\r\ndone(scmd);\r\nreturn 0;\r\n}\r\nint megasas_slave_configure(struct scsi_device *sdev)\r\n{\r\nu16 pd_index = 0;\r\nstruct megasas_instance *instance ;\r\ninstance = megasas_lookup_instance(sdev->host->host_no);\r\nif (sdev->channel < MEGASAS_MAX_PD_CHANNELS &&\r\nsdev->type == TYPE_DISK) {\r\npd_index = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) +\r\nsdev->id;\r\nif (instance->pd_list[pd_index].driveState ==\r\nMR_PD_STATE_SYSTEM) {\r\nblk_queue_rq_timeout(sdev->request_queue,\r\nMEGASAS_DEFAULT_CMD_TIMEOUT * HZ);\r\nreturn 0;\r\n}\r\nreturn -ENXIO;\r\n}\r\nblk_queue_rq_timeout(sdev->request_queue,\r\nMEGASAS_DEFAULT_CMD_TIMEOUT * HZ);\r\nreturn 0;\r\n}\r\nstatic int megasas_slave_alloc(struct scsi_device *sdev)\r\n{\r\nu16 pd_index = 0;\r\nstruct megasas_instance *instance ;\r\ninstance = megasas_lookup_instance(sdev->host->host_no);\r\nif ((sdev->channel < MEGASAS_MAX_PD_CHANNELS) &&\r\n(sdev->type == TYPE_DISK)) {\r\npd_index =\r\n(sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) +\r\nsdev->id;\r\nif ((instance->pd_list[pd_index].driveState ==\r\nMR_PD_STATE_SYSTEM) &&\r\n(instance->pd_list[pd_index].driveType ==\r\nTYPE_DISK)) {\r\nreturn 0;\r\n}\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nvoid megaraid_sas_kill_hba(struct megasas_instance *instance)\r\n{\r\nif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_FUSION) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER)) {\r\nwritel(MFI_STOP_ADP, &instance->reg_set->doorbell);\r\n} else {\r\nwritel(MFI_STOP_ADP, &instance->reg_set->inbound_doorbell);\r\n}\r\n}\r\nvoid\r\nmegasas_check_and_restore_queue_depth(struct megasas_instance *instance)\r\n{\r\nunsigned long flags;\r\nif (instance->flag & MEGASAS_FW_BUSY\r\n&& time_after(jiffies, instance->last_time + 5 * HZ)\r\n&& atomic_read(&instance->fw_outstanding) < 17) {\r\nspin_lock_irqsave(instance->host->host_lock, flags);\r\ninstance->flag &= ~MEGASAS_FW_BUSY;\r\nif ((instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS0071SKINNY)) {\r\ninstance->host->can_queue =\r\ninstance->max_fw_cmds - MEGASAS_SKINNY_INT_CMDS;\r\n} else\r\ninstance->host->can_queue =\r\ninstance->max_fw_cmds - MEGASAS_INT_CMDS;\r\nspin_unlock_irqrestore(instance->host->host_lock, flags);\r\n}\r\n}\r\nstatic void megasas_complete_cmd_dpc(unsigned long instance_addr)\r\n{\r\nu32 producer;\r\nu32 consumer;\r\nu32 context;\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_instance *instance =\r\n(struct megasas_instance *)instance_addr;\r\nunsigned long flags;\r\nif (instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR )\r\nreturn;\r\nspin_lock_irqsave(&instance->completion_lock, flags);\r\nproducer = *instance->producer;\r\nconsumer = *instance->consumer;\r\nwhile (consumer != producer) {\r\ncontext = instance->reply_queue[consumer];\r\nif (context >= instance->max_fw_cmds) {\r\nprintk(KERN_ERR "Unexpected context value %x\n",\r\ncontext);\r\nBUG();\r\n}\r\ncmd = instance->cmd_list[context];\r\nmegasas_complete_cmd(instance, cmd, DID_OK);\r\nconsumer++;\r\nif (consumer == (instance->max_fw_cmds + 1)) {\r\nconsumer = 0;\r\n}\r\n}\r\n*instance->consumer = producer;\r\nspin_unlock_irqrestore(&instance->completion_lock, flags);\r\nmegasas_check_and_restore_queue_depth(instance);\r\n}\r\nvoid megasas_do_ocr(struct megasas_instance *instance)\r\n{\r\nif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS1064R) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_DELL_PERC5) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_VERDE_ZCR)) {\r\n*instance->consumer = MEGASAS_ADPRESET_INPROG_SIGN;\r\n}\r\ninstance->instancet->disable_intr(instance->reg_set);\r\ninstance->adprecovery = MEGASAS_ADPRESET_SM_INFAULT;\r\ninstance->issuepend_done = 0;\r\natomic_set(&instance->fw_outstanding, 0);\r\nmegasas_internal_reset_defer_cmds(instance);\r\nprocess_fw_state_change_wq(&instance->work_init);\r\n}\r\nstatic int megasas_wait_for_outstanding(struct megasas_instance *instance)\r\n{\r\nint i;\r\nu32 reset_index;\r\nu32 wait_time = MEGASAS_RESET_WAIT_TIME;\r\nu8 adprecovery;\r\nunsigned long flags;\r\nstruct list_head clist_local;\r\nstruct megasas_cmd *reset_cmd;\r\nu32 fw_state;\r\nu8 kill_adapter_flag;\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nadprecovery = instance->adprecovery;\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nif (adprecovery != MEGASAS_HBA_OPERATIONAL) {\r\nINIT_LIST_HEAD(&clist_local);\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nlist_splice_init(&instance->internal_reset_pending_q,\r\n&clist_local);\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nprintk(KERN_NOTICE "megasas: HBA reset wait ...\n");\r\nfor (i = 0; i < wait_time; i++) {\r\nmsleep(1000);\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nadprecovery = instance->adprecovery;\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nif (adprecovery == MEGASAS_HBA_OPERATIONAL)\r\nbreak;\r\n}\r\nif (adprecovery != MEGASAS_HBA_OPERATIONAL) {\r\nprintk(KERN_NOTICE "megasas: reset: Stopping HBA.\n");\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\ninstance->adprecovery = MEGASAS_HW_CRITICAL_ERROR;\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nreturn FAILED;\r\n}\r\nreset_index = 0;\r\nwhile (!list_empty(&clist_local)) {\r\nreset_cmd = list_entry((&clist_local)->next,\r\nstruct megasas_cmd, list);\r\nlist_del_init(&reset_cmd->list);\r\nif (reset_cmd->scmd) {\r\nreset_cmd->scmd->result = DID_RESET << 16;\r\nprintk(KERN_NOTICE "%d:%p reset [%02x]\n",\r\nreset_index, reset_cmd,\r\nreset_cmd->scmd->cmnd[0]);\r\nreset_cmd->scmd->scsi_done(reset_cmd->scmd);\r\nmegasas_return_cmd(instance, reset_cmd);\r\n} else if (reset_cmd->sync_cmd) {\r\nprintk(KERN_NOTICE "megasas:%p synch cmds"\r\n"reset queue\n",\r\nreset_cmd);\r\nreset_cmd->cmd_status = ENODATA;\r\ninstance->instancet->fire_cmd(instance,\r\nreset_cmd->frame_phys_addr,\r\n0, instance->reg_set);\r\n} else {\r\nprintk(KERN_NOTICE "megasas: %p unexpected"\r\n"cmds lst\n",\r\nreset_cmd);\r\n}\r\nreset_index++;\r\n}\r\nreturn SUCCESS;\r\n}\r\nfor (i = 0; i < wait_time; i++) {\r\nint outstanding = atomic_read(&instance->fw_outstanding);\r\nif (!outstanding)\r\nbreak;\r\nif (!(i % MEGASAS_RESET_NOTICE_INTERVAL)) {\r\nprintk(KERN_NOTICE "megasas: [%2d]waiting for %d "\r\n"commands to complete\n",i,outstanding);\r\nmegasas_complete_cmd_dpc((unsigned long)instance);\r\n}\r\nmsleep(1000);\r\n}\r\ni = 0;\r\nkill_adapter_flag = 0;\r\ndo {\r\nfw_state = instance->instancet->read_fw_status_reg(\r\ninstance->reg_set) & MFI_STATE_MASK;\r\nif ((fw_state == MFI_STATE_FAULT) &&\r\n(instance->disableOnlineCtrlReset == 0)) {\r\nif (i == 3) {\r\nkill_adapter_flag = 2;\r\nbreak;\r\n}\r\nmegasas_do_ocr(instance);\r\nkill_adapter_flag = 1;\r\nmsleep(1000);\r\n}\r\ni++;\r\n} while (i <= 3);\r\nif (atomic_read(&instance->fw_outstanding) &&\r\n!kill_adapter_flag) {\r\nif (instance->disableOnlineCtrlReset == 0) {\r\nmegasas_do_ocr(instance);\r\nfor (i = 0; i < wait_time; i++) {\r\nint outstanding =\r\natomic_read(&instance->fw_outstanding);\r\nif (!outstanding)\r\nreturn SUCCESS;\r\nmsleep(1000);\r\n}\r\n}\r\n}\r\nif (atomic_read(&instance->fw_outstanding) ||\r\n(kill_adapter_flag == 2)) {\r\nprintk(KERN_NOTICE "megaraid_sas: pending cmds after reset\n");\r\nif ((instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS0071SKINNY)) {\r\nwritel(MFI_STOP_ADP,\r\n&instance->reg_set->doorbell);\r\n} else {\r\nwritel(MFI_STOP_ADP,\r\n&instance->reg_set->inbound_doorbell);\r\n}\r\nmegasas_dump_pending_frames(instance);\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\ninstance->adprecovery = MEGASAS_HW_CRITICAL_ERROR;\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nreturn FAILED;\r\n}\r\nprintk(KERN_NOTICE "megaraid_sas: no pending cmds after reset\n");\r\nreturn SUCCESS;\r\n}\r\nstatic int megasas_generic_reset(struct scsi_cmnd *scmd)\r\n{\r\nint ret_val;\r\nstruct megasas_instance *instance;\r\ninstance = (struct megasas_instance *)scmd->device->host->hostdata;\r\nscmd_printk(KERN_NOTICE, scmd, "megasas: RESET cmd=%x retries=%x\n",\r\nscmd->cmnd[0], scmd->retries);\r\nif (instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR) {\r\nprintk(KERN_ERR "megasas: cannot recover from previous reset "\r\n"failures\n");\r\nreturn FAILED;\r\n}\r\nret_val = megasas_wait_for_outstanding(instance);\r\nif (ret_val == SUCCESS)\r\nprintk(KERN_NOTICE "megasas: reset successful \n");\r\nelse\r\nprintk(KERN_ERR "megasas: failed to do reset\n");\r\nreturn ret_val;\r\n}\r\nstatic enum\r\nblk_eh_timer_return megasas_reset_timer(struct scsi_cmnd *scmd)\r\n{\r\nstruct megasas_instance *instance;\r\nunsigned long flags;\r\nif (time_after(jiffies, scmd->jiffies_at_alloc +\r\n(MEGASAS_DEFAULT_CMD_TIMEOUT * 2) * HZ)) {\r\nreturn BLK_EH_NOT_HANDLED;\r\n}\r\ninstance = (struct megasas_instance *)scmd->device->host->hostdata;\r\nif (!(instance->flag & MEGASAS_FW_BUSY)) {\r\nspin_lock_irqsave(instance->host->host_lock, flags);\r\ninstance->host->can_queue = 16;\r\ninstance->last_time = jiffies;\r\ninstance->flag |= MEGASAS_FW_BUSY;\r\nspin_unlock_irqrestore(instance->host->host_lock, flags);\r\n}\r\nreturn BLK_EH_RESET_TIMER;\r\n}\r\nstatic int megasas_reset_device(struct scsi_cmnd *scmd)\r\n{\r\nint ret;\r\nret = megasas_generic_reset(scmd);\r\nreturn ret;\r\n}\r\nstatic int megasas_reset_bus_host(struct scsi_cmnd *scmd)\r\n{\r\nint ret;\r\nstruct megasas_instance *instance;\r\ninstance = (struct megasas_instance *)scmd->device->host->hostdata;\r\nif ((instance->pdev->device == PCI_DEVICE_ID_LSI_FUSION) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER))\r\nret = megasas_reset_fusion(scmd->device->host);\r\nelse\r\nret = megasas_generic_reset(scmd);\r\nreturn ret;\r\n}\r\nstatic int\r\nmegasas_bios_param(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int geom[])\r\n{\r\nint heads;\r\nint sectors;\r\nsector_t cylinders;\r\nunsigned long tmp;\r\nheads = 64;\r\nsectors = 32;\r\ntmp = heads * sectors;\r\ncylinders = capacity;\r\nsector_div(cylinders, tmp);\r\nif (capacity >= 0x200000) {\r\nheads = 255;\r\nsectors = 63;\r\ntmp = heads*sectors;\r\ncylinders = capacity;\r\nsector_div(cylinders, tmp);\r\n}\r\ngeom[0] = heads;\r\ngeom[1] = sectors;\r\ngeom[2] = cylinders;\r\nreturn 0;\r\n}\r\nstatic void\r\nmegasas_service_aen(struct megasas_instance *instance, struct megasas_cmd *cmd)\r\n{\r\nunsigned long flags;\r\nif ((!cmd->abort_aen) && (instance->unload == 0)) {\r\nspin_lock_irqsave(&poll_aen_lock, flags);\r\nmegasas_poll_wait_aen = 1;\r\nspin_unlock_irqrestore(&poll_aen_lock, flags);\r\nwake_up(&megasas_poll_wait);\r\nkill_fasync(&megasas_async_queue, SIGIO, POLL_IN);\r\n}\r\nelse\r\ncmd->abort_aen = 0;\r\ninstance->aen_cmd = NULL;\r\nmegasas_return_cmd(instance, cmd);\r\nif ((instance->unload == 0) &&\r\n((instance->issuepend_done == 1))) {\r\nstruct megasas_aen_event *ev;\r\nev = kzalloc(sizeof(*ev), GFP_ATOMIC);\r\nif (!ev) {\r\nprintk(KERN_ERR "megasas_service_aen: out of memory\n");\r\n} else {\r\nev->instance = instance;\r\ninstance->ev = ev;\r\nINIT_WORK(&ev->hotplug_work, megasas_aen_polling);\r\nschedule_delayed_work(\r\n(struct delayed_work *)&ev->hotplug_work, 0);\r\n}\r\n}\r\n}\r\nstatic int megasas_change_queue_depth(struct scsi_device *sdev,\r\nint queue_depth, int reason)\r\n{\r\nif (reason != SCSI_QDEPTH_DEFAULT)\r\nreturn -EOPNOTSUPP;\r\nif (queue_depth > sdev->host->can_queue)\r\nqueue_depth = sdev->host->can_queue;\r\nscsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev),\r\nqueue_depth);\r\nreturn queue_depth;\r\n}\r\nstatic void\r\nmegasas_complete_int_cmd(struct megasas_instance *instance,\r\nstruct megasas_cmd *cmd)\r\n{\r\ncmd->cmd_status = cmd->frame->io.cmd_status;\r\nif (cmd->cmd_status == ENODATA) {\r\ncmd->cmd_status = 0;\r\n}\r\nwake_up(&instance->int_cmd_wait_q);\r\n}\r\nstatic void\r\nmegasas_complete_abort(struct megasas_instance *instance,\r\nstruct megasas_cmd *cmd)\r\n{\r\nif (cmd->sync_cmd) {\r\ncmd->sync_cmd = 0;\r\ncmd->cmd_status = 0;\r\nwake_up(&instance->abort_cmd_wait_q);\r\n}\r\nreturn;\r\n}\r\nvoid\r\nmegasas_complete_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd,\r\nu8 alt_status)\r\n{\r\nint exception = 0;\r\nstruct megasas_header *hdr = &cmd->frame->hdr;\r\nunsigned long flags;\r\nstruct fusion_context *fusion = instance->ctrl_context;\r\ncmd->retry_for_fw_reset = 0;\r\nif (cmd->scmd)\r\ncmd->scmd->SCp.ptr = NULL;\r\nswitch (hdr->cmd) {\r\ncase MFI_CMD_INVALID:\r\nprintk(KERN_WARNING "megaraid_sas: MFI_CMD_INVALID command "\r\n"completed.\n");\r\nprintk(KERN_WARNING "megaraid_sas: If you have a controller "\r\n"other than PERC5, please upgrade your firmware.\n");\r\nbreak;\r\ncase MFI_CMD_PD_SCSI_IO:\r\ncase MFI_CMD_LD_SCSI_IO:\r\nif (cmd->sync_cmd) {\r\ncmd->sync_cmd = 0;\r\nmegasas_complete_int_cmd(instance, cmd);\r\nbreak;\r\n}\r\ncase MFI_CMD_LD_READ:\r\ncase MFI_CMD_LD_WRITE:\r\nif (alt_status) {\r\ncmd->scmd->result = alt_status << 16;\r\nexception = 1;\r\n}\r\nif (exception) {\r\natomic_dec(&instance->fw_outstanding);\r\nscsi_dma_unmap(cmd->scmd);\r\ncmd->scmd->scsi_done(cmd->scmd);\r\nmegasas_return_cmd(instance, cmd);\r\nbreak;\r\n}\r\nswitch (hdr->cmd_status) {\r\ncase MFI_STAT_OK:\r\ncmd->scmd->result = DID_OK << 16;\r\nbreak;\r\ncase MFI_STAT_SCSI_IO_FAILED:\r\ncase MFI_STAT_LD_INIT_IN_PROGRESS:\r\ncmd->scmd->result =\r\n(DID_ERROR << 16) | hdr->scsi_status;\r\nbreak;\r\ncase MFI_STAT_SCSI_DONE_WITH_ERROR:\r\ncmd->scmd->result = (DID_OK << 16) | hdr->scsi_status;\r\nif (hdr->scsi_status == SAM_STAT_CHECK_CONDITION) {\r\nmemset(cmd->scmd->sense_buffer, 0,\r\nSCSI_SENSE_BUFFERSIZE);\r\nmemcpy(cmd->scmd->sense_buffer, cmd->sense,\r\nhdr->sense_len);\r\ncmd->scmd->result |= DRIVER_SENSE << 24;\r\n}\r\nbreak;\r\ncase MFI_STAT_LD_OFFLINE:\r\ncase MFI_STAT_DEVICE_NOT_FOUND:\r\ncmd->scmd->result = DID_BAD_TARGET << 16;\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "megasas: MFI FW status %#x\n",\r\nhdr->cmd_status);\r\ncmd->scmd->result = DID_ERROR << 16;\r\nbreak;\r\n}\r\natomic_dec(&instance->fw_outstanding);\r\nscsi_dma_unmap(cmd->scmd);\r\ncmd->scmd->scsi_done(cmd->scmd);\r\nmegasas_return_cmd(instance, cmd);\r\nbreak;\r\ncase MFI_CMD_SMP:\r\ncase MFI_CMD_STP:\r\ncase MFI_CMD_DCMD:\r\nif ((cmd->frame->dcmd.opcode == MR_DCMD_LD_MAP_GET_INFO) &&\r\n(cmd->frame->dcmd.mbox.b[1] == 1)) {\r\nspin_lock_irqsave(instance->host->host_lock, flags);\r\nif (cmd->frame->hdr.cmd_status != 0) {\r\nif (cmd->frame->hdr.cmd_status !=\r\nMFI_STAT_NOT_FOUND)\r\nprintk(KERN_WARNING "megasas: map sync"\r\n"failed, status = 0x%x.\n",\r\ncmd->frame->hdr.cmd_status);\r\nelse {\r\nmegasas_return_cmd(instance, cmd);\r\nspin_unlock_irqrestore(\r\ninstance->host->host_lock,\r\nflags);\r\nbreak;\r\n}\r\n} else\r\ninstance->map_id++;\r\nmegasas_return_cmd(instance, cmd);\r\nif (MR_ValidateMapInfo(\r\nfusion->ld_map[(instance->map_id & 1)],\r\nfusion->load_balance_info))\r\nfusion->fast_path_io = 1;\r\nelse\r\nfusion->fast_path_io = 0;\r\nmegasas_sync_map_info(instance);\r\nspin_unlock_irqrestore(instance->host->host_lock,\r\nflags);\r\nbreak;\r\n}\r\nif (cmd->frame->dcmd.opcode == MR_DCMD_CTRL_EVENT_GET_INFO ||\r\ncmd->frame->dcmd.opcode == MR_DCMD_CTRL_EVENT_GET) {\r\nspin_lock_irqsave(&poll_aen_lock, flags);\r\nmegasas_poll_wait_aen = 0;\r\nspin_unlock_irqrestore(&poll_aen_lock, flags);\r\n}\r\nif (cmd->frame->dcmd.opcode == MR_DCMD_CTRL_EVENT_WAIT)\r\nmegasas_service_aen(instance, cmd);\r\nelse\r\nmegasas_complete_int_cmd(instance, cmd);\r\nbreak;\r\ncase MFI_CMD_ABORT:\r\nmegasas_complete_abort(instance, cmd);\r\nbreak;\r\ndefault:\r\nprintk("megasas: Unknown command completed! [0x%X]\n",\r\nhdr->cmd);\r\nbreak;\r\n}\r\n}\r\nstatic inline void\r\nmegasas_issue_pending_cmds_again(struct megasas_instance *instance)\r\n{\r\nstruct megasas_cmd *cmd;\r\nstruct list_head clist_local;\r\nunion megasas_evt_class_locale class_locale;\r\nunsigned long flags;\r\nu32 seq_num;\r\nINIT_LIST_HEAD(&clist_local);\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nlist_splice_init(&instance->internal_reset_pending_q, &clist_local);\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nwhile (!list_empty(&clist_local)) {\r\ncmd = list_entry((&clist_local)->next,\r\nstruct megasas_cmd, list);\r\nlist_del_init(&cmd->list);\r\nif (cmd->sync_cmd || cmd->scmd) {\r\nprintk(KERN_NOTICE "megaraid_sas: command %p, %p:%d"\r\n"detected to be pending while HBA reset.\n",\r\ncmd, cmd->scmd, cmd->sync_cmd);\r\ncmd->retry_for_fw_reset++;\r\nif (cmd->retry_for_fw_reset == 3) {\r\nprintk(KERN_NOTICE "megaraid_sas: cmd %p, %p:%d"\r\n"was tried multiple times during reset."\r\n"Shutting down the HBA\n",\r\ncmd, cmd->scmd, cmd->sync_cmd);\r\nmegaraid_sas_kill_hba(instance);\r\ninstance->adprecovery =\r\nMEGASAS_HW_CRITICAL_ERROR;\r\nreturn;\r\n}\r\n}\r\nif (cmd->sync_cmd == 1) {\r\nif (cmd->scmd) {\r\nprintk(KERN_NOTICE "megaraid_sas: unexpected"\r\n"cmd attached to internal command!\n");\r\n}\r\nprintk(KERN_NOTICE "megasas: %p synchronous cmd"\r\n"on the internal reset queue,"\r\n"issue it again.\n", cmd);\r\ncmd->cmd_status = ENODATA;\r\ninstance->instancet->fire_cmd(instance,\r\ncmd->frame_phys_addr ,\r\n0, instance->reg_set);\r\n} else if (cmd->scmd) {\r\nprintk(KERN_NOTICE "megasas: %p scsi cmd [%02x]"\r\n"detected on the internal queue, issue again.\n",\r\ncmd, cmd->scmd->cmnd[0]);\r\natomic_inc(&instance->fw_outstanding);\r\ninstance->instancet->fire_cmd(instance,\r\ncmd->frame_phys_addr,\r\ncmd->frame_count-1, instance->reg_set);\r\n} else {\r\nprintk(KERN_NOTICE "megasas: %p unexpected cmd on the"\r\n"internal reset defer list while re-issue!!\n",\r\ncmd);\r\n}\r\n}\r\nif (instance->aen_cmd) {\r\nprintk(KERN_NOTICE "megaraid_sas: aen_cmd in def process\n");\r\nmegasas_return_cmd(instance, instance->aen_cmd);\r\ninstance->aen_cmd = NULL;\r\n}\r\nseq_num = instance->last_seq_num;\r\nclass_locale.members.reserved = 0;\r\nclass_locale.members.locale = MR_EVT_LOCALE_ALL;\r\nclass_locale.members.class = MR_EVT_CLASS_DEBUG;\r\nmegasas_register_aen(instance, seq_num, class_locale.word);\r\n}\r\nstatic void\r\nmegasas_internal_reset_defer_cmds(struct megasas_instance *instance)\r\n{\r\nstruct megasas_cmd *cmd;\r\nint i;\r\nu32 max_cmd = instance->max_fw_cmds;\r\nu32 defer_index;\r\nunsigned long flags;\r\ndefer_index = 0;\r\nspin_lock_irqsave(&instance->cmd_pool_lock, flags);\r\nfor (i = 0; i < max_cmd; i++) {\r\ncmd = instance->cmd_list[i];\r\nif (cmd->sync_cmd == 1 || cmd->scmd) {\r\nprintk(KERN_NOTICE "megasas: moving cmd[%d]:%p:%d:%p"\r\n"on the defer queue as internal\n",\r\ndefer_index, cmd, cmd->sync_cmd, cmd->scmd);\r\nif (!list_empty(&cmd->list)) {\r\nprintk(KERN_NOTICE "megaraid_sas: ERROR while"\r\n" moving this cmd:%p, %d %p, it was"\r\n"discovered on some list?\n",\r\ncmd, cmd->sync_cmd, cmd->scmd);\r\nlist_del_init(&cmd->list);\r\n}\r\ndefer_index++;\r\nlist_add_tail(&cmd->list,\r\n&instance->internal_reset_pending_q);\r\n}\r\n}\r\nspin_unlock_irqrestore(&instance->cmd_pool_lock, flags);\r\n}\r\nstatic void\r\nprocess_fw_state_change_wq(struct work_struct *work)\r\n{\r\nstruct megasas_instance *instance =\r\ncontainer_of(work, struct megasas_instance, work_init);\r\nu32 wait;\r\nunsigned long flags;\r\nif (instance->adprecovery != MEGASAS_ADPRESET_SM_INFAULT) {\r\nprintk(KERN_NOTICE "megaraid_sas: error, recovery st %x \n",\r\ninstance->adprecovery);\r\nreturn ;\r\n}\r\nif (instance->adprecovery == MEGASAS_ADPRESET_SM_INFAULT) {\r\nprintk(KERN_NOTICE "megaraid_sas: FW detected to be in fault"\r\n"state, restarting it...\n");\r\ninstance->instancet->disable_intr(instance->reg_set);\r\natomic_set(&instance->fw_outstanding, 0);\r\natomic_set(&instance->fw_reset_no_pci_access, 1);\r\ninstance->instancet->adp_reset(instance, instance->reg_set);\r\natomic_set(&instance->fw_reset_no_pci_access, 0 );\r\nprintk(KERN_NOTICE "megaraid_sas: FW restarted successfully,"\r\n"initiating next stage...\n");\r\nprintk(KERN_NOTICE "megaraid_sas: HBA recovery state machine,"\r\n"state 2 starting...\n");\r\nfor (wait = 0; wait < 30; wait++) {\r\nmsleep(1000);\r\n}\r\nif (megasas_transition_to_ready(instance, 1)) {\r\nprintk(KERN_NOTICE "megaraid_sas:adapter not ready\n");\r\nmegaraid_sas_kill_hba(instance);\r\ninstance->adprecovery = MEGASAS_HW_CRITICAL_ERROR;\r\nreturn ;\r\n}\r\nif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS1064R) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_DELL_PERC5) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_VERDE_ZCR)\r\n) {\r\n*instance->consumer = *instance->producer;\r\n} else {\r\n*instance->consumer = 0;\r\n*instance->producer = 0;\r\n}\r\nmegasas_issue_init_mfi(instance);\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\ninstance->adprecovery = MEGASAS_HBA_OPERATIONAL;\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\ninstance->instancet->enable_intr(instance->reg_set);\r\nmegasas_issue_pending_cmds_again(instance);\r\ninstance->issuepend_done = 1;\r\n}\r\nreturn ;\r\n}\r\nstatic int\r\nmegasas_deplete_reply_queue(struct megasas_instance *instance,\r\nu8 alt_status)\r\n{\r\nu32 mfiStatus;\r\nu32 fw_state;\r\nif ((mfiStatus = instance->instancet->check_reset(instance,\r\ninstance->reg_set)) == 1) {\r\nreturn IRQ_HANDLED;\r\n}\r\nif ((mfiStatus = instance->instancet->clear_intr(\r\ninstance->reg_set)\r\n) == 0) {\r\nif (!instance->msix_vectors)\r\nreturn IRQ_NONE;\r\n}\r\ninstance->mfiStatus = mfiStatus;\r\nif ((mfiStatus & MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE)) {\r\nfw_state = instance->instancet->read_fw_status_reg(\r\ninstance->reg_set) & MFI_STATE_MASK;\r\nif (fw_state != MFI_STATE_FAULT) {\r\nprintk(KERN_NOTICE "megaraid_sas: fw state:%x\n",\r\nfw_state);\r\n}\r\nif ((fw_state == MFI_STATE_FAULT) &&\r\n(instance->disableOnlineCtrlReset == 0)) {\r\nprintk(KERN_NOTICE "megaraid_sas: wait adp restart\n");\r\nif ((instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS1064R) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_DELL_PERC5) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_VERDE_ZCR)) {\r\n*instance->consumer =\r\nMEGASAS_ADPRESET_INPROG_SIGN;\r\n}\r\ninstance->instancet->disable_intr(instance->reg_set);\r\ninstance->adprecovery = MEGASAS_ADPRESET_SM_INFAULT;\r\ninstance->issuepend_done = 0;\r\natomic_set(&instance->fw_outstanding, 0);\r\nmegasas_internal_reset_defer_cmds(instance);\r\nprintk(KERN_NOTICE "megasas: fwState=%x, stage:%d\n",\r\nfw_state, instance->adprecovery);\r\nschedule_work(&instance->work_init);\r\nreturn IRQ_HANDLED;\r\n} else {\r\nprintk(KERN_NOTICE "megasas: fwstate:%x, dis_OCR=%x\n",\r\nfw_state, instance->disableOnlineCtrlReset);\r\n}\r\n}\r\ntasklet_schedule(&instance->isr_tasklet);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t megasas_isr(int irq, void *devp)\r\n{\r\nstruct megasas_irq_context *irq_context = devp;\r\nstruct megasas_instance *instance = irq_context->instance;\r\nunsigned long flags;\r\nirqreturn_t rc;\r\nif (atomic_read(&instance->fw_reset_no_pci_access))\r\nreturn IRQ_HANDLED;\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nrc = megasas_deplete_reply_queue(instance, DID_OK);\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nreturn rc;\r\n}\r\nint\r\nmegasas_transition_to_ready(struct megasas_instance *instance, int ocr)\r\n{\r\nint i;\r\nu8 max_wait;\r\nu32 fw_state;\r\nu32 cur_state;\r\nu32 abs_state, curr_abs_state;\r\nfw_state = instance->instancet->read_fw_status_reg(instance->reg_set) & MFI_STATE_MASK;\r\nif (fw_state != MFI_STATE_READY)\r\nprintk(KERN_INFO "megasas: Waiting for FW to come to ready"\r\n" state\n");\r\nwhile (fw_state != MFI_STATE_READY) {\r\nabs_state =\r\ninstance->instancet->read_fw_status_reg(instance->reg_set);\r\nswitch (fw_state) {\r\ncase MFI_STATE_FAULT:\r\nprintk(KERN_DEBUG "megasas: FW in FAULT state!!\n");\r\nif (ocr) {\r\nmax_wait = MEGASAS_RESET_WAIT_TIME;\r\ncur_state = MFI_STATE_FAULT;\r\nbreak;\r\n} else\r\nreturn -ENODEV;\r\ncase MFI_STATE_WAIT_HANDSHAKE:\r\nif ((instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS0071SKINNY) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_FUSION) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_INVADER)) {\r\nwritel(\r\nMFI_INIT_CLEAR_HANDSHAKE|MFI_INIT_HOTPLUG,\r\n&instance->reg_set->doorbell);\r\n} else {\r\nwritel(\r\nMFI_INIT_CLEAR_HANDSHAKE|MFI_INIT_HOTPLUG,\r\n&instance->reg_set->inbound_doorbell);\r\n}\r\nmax_wait = MEGASAS_RESET_WAIT_TIME;\r\ncur_state = MFI_STATE_WAIT_HANDSHAKE;\r\nbreak;\r\ncase MFI_STATE_BOOT_MESSAGE_PENDING:\r\nif ((instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS0071SKINNY) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_FUSION) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_INVADER)) {\r\nwritel(MFI_INIT_HOTPLUG,\r\n&instance->reg_set->doorbell);\r\n} else\r\nwritel(MFI_INIT_HOTPLUG,\r\n&instance->reg_set->inbound_doorbell);\r\nmax_wait = MEGASAS_RESET_WAIT_TIME;\r\ncur_state = MFI_STATE_BOOT_MESSAGE_PENDING;\r\nbreak;\r\ncase MFI_STATE_OPERATIONAL:\r\ninstance->instancet->disable_intr(instance->reg_set);\r\nif ((instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS0071SKINNY) ||\r\n(instance->pdev->device\r\n== PCI_DEVICE_ID_LSI_FUSION) ||\r\n(instance->pdev->device\r\n== PCI_DEVICE_ID_LSI_INVADER)) {\r\nwritel(MFI_RESET_FLAGS,\r\n&instance->reg_set->doorbell);\r\nif ((instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_FUSION) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_INVADER)) {\r\nfor (i = 0; i < (10 * 1000); i += 20) {\r\nif (readl(\r\n&instance->\r\nreg_set->\r\ndoorbell) & 1)\r\nmsleep(20);\r\nelse\r\nbreak;\r\n}\r\n}\r\n} else\r\nwritel(MFI_RESET_FLAGS,\r\n&instance->reg_set->inbound_doorbell);\r\nmax_wait = MEGASAS_RESET_WAIT_TIME;\r\ncur_state = MFI_STATE_OPERATIONAL;\r\nbreak;\r\ncase MFI_STATE_UNDEFINED:\r\nmax_wait = MEGASAS_RESET_WAIT_TIME;\r\ncur_state = MFI_STATE_UNDEFINED;\r\nbreak;\r\ncase MFI_STATE_BB_INIT:\r\nmax_wait = MEGASAS_RESET_WAIT_TIME;\r\ncur_state = MFI_STATE_BB_INIT;\r\nbreak;\r\ncase MFI_STATE_FW_INIT:\r\nmax_wait = MEGASAS_RESET_WAIT_TIME;\r\ncur_state = MFI_STATE_FW_INIT;\r\nbreak;\r\ncase MFI_STATE_FW_INIT_2:\r\nmax_wait = MEGASAS_RESET_WAIT_TIME;\r\ncur_state = MFI_STATE_FW_INIT_2;\r\nbreak;\r\ncase MFI_STATE_DEVICE_SCAN:\r\nmax_wait = MEGASAS_RESET_WAIT_TIME;\r\ncur_state = MFI_STATE_DEVICE_SCAN;\r\nbreak;\r\ncase MFI_STATE_FLUSH_CACHE:\r\nmax_wait = MEGASAS_RESET_WAIT_TIME;\r\ncur_state = MFI_STATE_FLUSH_CACHE;\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "megasas: Unknown state 0x%x\n",\r\nfw_state);\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < (max_wait * 1000); i++) {\r\nfw_state = instance->instancet->read_fw_status_reg(instance->reg_set) &\r\nMFI_STATE_MASK ;\r\ncurr_abs_state =\r\ninstance->instancet->read_fw_status_reg(instance->reg_set);\r\nif (abs_state == curr_abs_state) {\r\nmsleep(1);\r\n} else\r\nbreak;\r\n}\r\nif (curr_abs_state == abs_state) {\r\nprintk(KERN_DEBUG "FW state [%d] hasn't changed "\r\n"in %d secs\n", fw_state, max_wait);\r\nreturn -ENODEV;\r\n}\r\n}\r\nprintk(KERN_INFO "megasas: FW now in Ready state\n");\r\nreturn 0;\r\n}\r\nstatic void megasas_teardown_frame_pool(struct megasas_instance *instance)\r\n{\r\nint i;\r\nu32 max_cmd = instance->max_mfi_cmds;\r\nstruct megasas_cmd *cmd;\r\nif (!instance->frame_dma_pool)\r\nreturn;\r\nfor (i = 0; i < max_cmd; i++) {\r\ncmd = instance->cmd_list[i];\r\nif (cmd->frame)\r\npci_pool_free(instance->frame_dma_pool, cmd->frame,\r\ncmd->frame_phys_addr);\r\nif (cmd->sense)\r\npci_pool_free(instance->sense_dma_pool, cmd->sense,\r\ncmd->sense_phys_addr);\r\n}\r\npci_pool_destroy(instance->frame_dma_pool);\r\npci_pool_destroy(instance->sense_dma_pool);\r\ninstance->frame_dma_pool = NULL;\r\ninstance->sense_dma_pool = NULL;\r\n}\r\nstatic int megasas_create_frame_pool(struct megasas_instance *instance)\r\n{\r\nint i;\r\nu32 max_cmd;\r\nu32 sge_sz;\r\nu32 sgl_sz;\r\nu32 total_sz;\r\nu32 frame_count;\r\nstruct megasas_cmd *cmd;\r\nmax_cmd = instance->max_mfi_cmds;\r\nsge_sz = (IS_DMA64) ? sizeof(struct megasas_sge64) :\r\nsizeof(struct megasas_sge32);\r\nif (instance->flag_ieee) {\r\nsge_sz = sizeof(struct megasas_sge_skinny);\r\n}\r\nsgl_sz = sge_sz * instance->max_num_sge;\r\nframe_count = (sgl_sz + MEGAMFI_FRAME_SIZE - 1) / MEGAMFI_FRAME_SIZE;\r\nframe_count = 15;\r\nframe_count++;\r\ntotal_sz = MEGAMFI_FRAME_SIZE * frame_count;\r\ninstance->frame_dma_pool = pci_pool_create("megasas frame pool",\r\ninstance->pdev, total_sz, 64,\r\n0);\r\nif (!instance->frame_dma_pool) {\r\nprintk(KERN_DEBUG "megasas: failed to setup frame pool\n");\r\nreturn -ENOMEM;\r\n}\r\ninstance->sense_dma_pool = pci_pool_create("megasas sense pool",\r\ninstance->pdev, 128, 4, 0);\r\nif (!instance->sense_dma_pool) {\r\nprintk(KERN_DEBUG "megasas: failed to setup sense pool\n");\r\npci_pool_destroy(instance->frame_dma_pool);\r\ninstance->frame_dma_pool = NULL;\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < max_cmd; i++) {\r\ncmd = instance->cmd_list[i];\r\ncmd->frame = pci_pool_alloc(instance->frame_dma_pool,\r\nGFP_KERNEL, &cmd->frame_phys_addr);\r\ncmd->sense = pci_pool_alloc(instance->sense_dma_pool,\r\nGFP_KERNEL, &cmd->sense_phys_addr);\r\nif (!cmd->frame || !cmd->sense) {\r\nprintk(KERN_DEBUG "megasas: pci_pool_alloc failed \n");\r\nmegasas_teardown_frame_pool(instance);\r\nreturn -ENOMEM;\r\n}\r\nmemset(cmd->frame, 0, total_sz);\r\ncmd->frame->io.context = cmd->index;\r\ncmd->frame->io.pad_0 = 0;\r\nif ((instance->pdev->device != PCI_DEVICE_ID_LSI_FUSION) &&\r\n(instance->pdev->device != PCI_DEVICE_ID_LSI_INVADER) &&\r\n(reset_devices))\r\ncmd->frame->hdr.cmd = MFI_CMD_INVALID;\r\n}\r\nreturn 0;\r\n}\r\nvoid megasas_free_cmds(struct megasas_instance *instance)\r\n{\r\nint i;\r\nmegasas_teardown_frame_pool(instance);\r\nfor (i = 0; i < instance->max_mfi_cmds; i++)\r\nkfree(instance->cmd_list[i]);\r\nkfree(instance->cmd_list);\r\ninstance->cmd_list = NULL;\r\nINIT_LIST_HEAD(&instance->cmd_pool);\r\n}\r\nint megasas_alloc_cmds(struct megasas_instance *instance)\r\n{\r\nint i;\r\nint j;\r\nu32 max_cmd;\r\nstruct megasas_cmd *cmd;\r\nmax_cmd = instance->max_mfi_cmds;\r\ninstance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);\r\nif (!instance->cmd_list) {\r\nprintk(KERN_DEBUG "megasas: out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);\r\nfor (i = 0; i < max_cmd; i++) {\r\ninstance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),\r\nGFP_KERNEL);\r\nif (!instance->cmd_list[i]) {\r\nfor (j = 0; j < i; j++)\r\nkfree(instance->cmd_list[j]);\r\nkfree(instance->cmd_list);\r\ninstance->cmd_list = NULL;\r\nreturn -ENOMEM;\r\n}\r\n}\r\nfor (i = 0; i < max_cmd; i++) {\r\ncmd = instance->cmd_list[i];\r\nmemset(cmd, 0, sizeof(struct megasas_cmd));\r\ncmd->index = i;\r\ncmd->scmd = NULL;\r\ncmd->instance = instance;\r\nlist_add_tail(&cmd->list, &instance->cmd_pool);\r\n}\r\nif (megasas_create_frame_pool(instance)) {\r\nprintk(KERN_DEBUG "megasas: Error creating frame DMA pool\n");\r\nmegasas_free_cmds(instance);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmegasas_get_pd_list(struct megasas_instance *instance)\r\n{\r\nint ret = 0, pd_index = 0;\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nstruct MR_PD_LIST *ci;\r\nstruct MR_PD_ADDRESS *pd_addr;\r\ndma_addr_t ci_h = 0;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\nprintk(KERN_DEBUG "megasas (get_pd_list): Failed to get cmd\n");\r\nreturn -ENOMEM;\r\n}\r\ndcmd = &cmd->frame->dcmd;\r\nci = pci_alloc_consistent(instance->pdev,\r\nMEGASAS_MAX_PD * sizeof(struct MR_PD_LIST), &ci_h);\r\nif (!ci) {\r\nprintk(KERN_DEBUG "Failed to alloc mem for pd_list\n");\r\nmegasas_return_cmd(instance, cmd);\r\nreturn -ENOMEM;\r\n}\r\nmemset(ci, 0, sizeof(*ci));\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\ndcmd->mbox.b[0] = MR_PD_QUERY_TYPE_EXPOSED_TO_HOST;\r\ndcmd->mbox.b[1] = 0;\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0xFF;\r\ndcmd->sge_count = 1;\r\ndcmd->flags = MFI_FRAME_DIR_READ;\r\ndcmd->timeout = 0;\r\ndcmd->pad_0 = 0;\r\ndcmd->data_xfer_len = MEGASAS_MAX_PD * sizeof(struct MR_PD_LIST);\r\ndcmd->opcode = MR_DCMD_PD_LIST_QUERY;\r\ndcmd->sgl.sge32[0].phys_addr = ci_h;\r\ndcmd->sgl.sge32[0].length = MEGASAS_MAX_PD * sizeof(struct MR_PD_LIST);\r\nif (!megasas_issue_polled(instance, cmd)) {\r\nret = 0;\r\n} else {\r\nret = -1;\r\n}\r\npd_addr = ci->addr;\r\nif ( ret == 0 &&\r\n(ci->count <\r\n(MEGASAS_MAX_PD_CHANNELS * MEGASAS_MAX_DEV_PER_CHANNEL))) {\r\nmemset(instance->pd_list, 0,\r\nMEGASAS_MAX_PD * sizeof(struct megasas_pd_list));\r\nfor (pd_index = 0; pd_index < ci->count; pd_index++) {\r\ninstance->pd_list[pd_addr->deviceId].tid =\r\npd_addr->deviceId;\r\ninstance->pd_list[pd_addr->deviceId].driveType =\r\npd_addr->scsiDevType;\r\ninstance->pd_list[pd_addr->deviceId].driveState =\r\nMR_PD_STATE_SYSTEM;\r\npd_addr++;\r\n}\r\n}\r\npci_free_consistent(instance->pdev,\r\nMEGASAS_MAX_PD * sizeof(struct MR_PD_LIST),\r\nci, ci_h);\r\nmegasas_return_cmd(instance, cmd);\r\nreturn ret;\r\n}\r\nstatic int\r\nmegasas_get_ld_list(struct megasas_instance *instance)\r\n{\r\nint ret = 0, ld_index = 0, ids = 0;\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nstruct MR_LD_LIST *ci;\r\ndma_addr_t ci_h = 0;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\nprintk(KERN_DEBUG "megasas_get_ld_list: Failed to get cmd\n");\r\nreturn -ENOMEM;\r\n}\r\ndcmd = &cmd->frame->dcmd;\r\nci = pci_alloc_consistent(instance->pdev,\r\nsizeof(struct MR_LD_LIST),\r\n&ci_h);\r\nif (!ci) {\r\nprintk(KERN_DEBUG "Failed to alloc mem in get_ld_list\n");\r\nmegasas_return_cmd(instance, cmd);\r\nreturn -ENOMEM;\r\n}\r\nmemset(ci, 0, sizeof(*ci));\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0xFF;\r\ndcmd->sge_count = 1;\r\ndcmd->flags = MFI_FRAME_DIR_READ;\r\ndcmd->timeout = 0;\r\ndcmd->data_xfer_len = sizeof(struct MR_LD_LIST);\r\ndcmd->opcode = MR_DCMD_LD_GET_LIST;\r\ndcmd->sgl.sge32[0].phys_addr = ci_h;\r\ndcmd->sgl.sge32[0].length = sizeof(struct MR_LD_LIST);\r\ndcmd->pad_0 = 0;\r\nif (!megasas_issue_polled(instance, cmd)) {\r\nret = 0;\r\n} else {\r\nret = -1;\r\n}\r\nif ((ret == 0) && (ci->ldCount <= MAX_LOGICAL_DRIVES)) {\r\nmemset(instance->ld_ids, 0xff, MEGASAS_MAX_LD_IDS);\r\nfor (ld_index = 0; ld_index < ci->ldCount; ld_index++) {\r\nif (ci->ldList[ld_index].state != 0) {\r\nids = ci->ldList[ld_index].ref.targetId;\r\ninstance->ld_ids[ids] =\r\nci->ldList[ld_index].ref.targetId;\r\n}\r\n}\r\n}\r\npci_free_consistent(instance->pdev,\r\nsizeof(struct MR_LD_LIST),\r\nci,\r\nci_h);\r\nmegasas_return_cmd(instance, cmd);\r\nreturn ret;\r\n}\r\nstatic int\r\nmegasas_get_ctrl_info(struct megasas_instance *instance,\r\nstruct megasas_ctrl_info *ctrl_info)\r\n{\r\nint ret = 0;\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nstruct megasas_ctrl_info *ci;\r\ndma_addr_t ci_h = 0;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\nprintk(KERN_DEBUG "megasas: Failed to get a free cmd\n");\r\nreturn -ENOMEM;\r\n}\r\ndcmd = &cmd->frame->dcmd;\r\nci = pci_alloc_consistent(instance->pdev,\r\nsizeof(struct megasas_ctrl_info), &ci_h);\r\nif (!ci) {\r\nprintk(KERN_DEBUG "Failed to alloc mem for ctrl info\n");\r\nmegasas_return_cmd(instance, cmd);\r\nreturn -ENOMEM;\r\n}\r\nmemset(ci, 0, sizeof(*ci));\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0xFF;\r\ndcmd->sge_count = 1;\r\ndcmd->flags = MFI_FRAME_DIR_READ;\r\ndcmd->timeout = 0;\r\ndcmd->pad_0 = 0;\r\ndcmd->data_xfer_len = sizeof(struct megasas_ctrl_info);\r\ndcmd->opcode = MR_DCMD_CTRL_GET_INFO;\r\ndcmd->sgl.sge32[0].phys_addr = ci_h;\r\ndcmd->sgl.sge32[0].length = sizeof(struct megasas_ctrl_info);\r\nif (!megasas_issue_polled(instance, cmd)) {\r\nret = 0;\r\nmemcpy(ctrl_info, ci, sizeof(struct megasas_ctrl_info));\r\n} else {\r\nret = -1;\r\n}\r\npci_free_consistent(instance->pdev, sizeof(struct megasas_ctrl_info),\r\nci, ci_h);\r\nmegasas_return_cmd(instance, cmd);\r\nreturn ret;\r\n}\r\nstatic int\r\nmegasas_issue_init_mfi(struct megasas_instance *instance)\r\n{\r\nu32 context;\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_init_frame *init_frame;\r\nstruct megasas_init_queue_info *initq_info;\r\ndma_addr_t init_frame_h;\r\ndma_addr_t initq_info_h;\r\ncmd = megasas_get_cmd(instance);\r\ninit_frame = (struct megasas_init_frame *)cmd->frame;\r\ninitq_info = (struct megasas_init_queue_info *)\r\n((unsigned long)init_frame + 64);\r\ninit_frame_h = cmd->frame_phys_addr;\r\ninitq_info_h = init_frame_h + 64;\r\ncontext = init_frame->context;\r\nmemset(init_frame, 0, MEGAMFI_FRAME_SIZE);\r\nmemset(initq_info, 0, sizeof(struct megasas_init_queue_info));\r\ninit_frame->context = context;\r\ninitq_info->reply_queue_entries = instance->max_fw_cmds + 1;\r\ninitq_info->reply_queue_start_phys_addr_lo = instance->reply_queue_h;\r\ninitq_info->producer_index_phys_addr_lo = instance->producer_h;\r\ninitq_info->consumer_index_phys_addr_lo = instance->consumer_h;\r\ninit_frame->cmd = MFI_CMD_INIT;\r\ninit_frame->cmd_status = 0xFF;\r\ninit_frame->queue_info_new_phys_addr_lo = initq_info_h;\r\ninit_frame->data_xfer_len = sizeof(struct megasas_init_queue_info);\r\ninstance->instancet->disable_intr(instance->reg_set);\r\nif (megasas_issue_polled(instance, cmd)) {\r\nprintk(KERN_ERR "megasas: Failed to init firmware\n");\r\nmegasas_return_cmd(instance, cmd);\r\ngoto fail_fw_init;\r\n}\r\nmegasas_return_cmd(instance, cmd);\r\nreturn 0;\r\nfail_fw_init:\r\nreturn -EINVAL;\r\n}\r\nstatic u32\r\nmegasas_init_adapter_mfi(struct megasas_instance *instance)\r\n{\r\nstruct megasas_register_set __iomem *reg_set;\r\nu32 context_sz;\r\nu32 reply_q_sz;\r\nreg_set = instance->reg_set;\r\ninstance->max_fw_cmds = instance->instancet->read_fw_status_reg(reg_set) & 0x00FFFF;\r\ninstance->max_fw_cmds = instance->max_fw_cmds-1;\r\ninstance->max_mfi_cmds = instance->max_fw_cmds;\r\ninstance->max_num_sge = (instance->instancet->read_fw_status_reg(reg_set) & 0xFF0000) >>\r\n0x10;\r\nif (megasas_alloc_cmds(instance))\r\ngoto fail_alloc_cmds;\r\ncontext_sz = sizeof(u32);\r\nreply_q_sz = context_sz * (instance->max_fw_cmds + 1);\r\ninstance->reply_queue = pci_alloc_consistent(instance->pdev,\r\nreply_q_sz,\r\n&instance->reply_queue_h);\r\nif (!instance->reply_queue) {\r\nprintk(KERN_DEBUG "megasas: Out of DMA mem for reply queue\n");\r\ngoto fail_reply_queue;\r\n}\r\nif (megasas_issue_init_mfi(instance))\r\ngoto fail_fw_init;\r\ninstance->fw_support_ieee = 0;\r\ninstance->fw_support_ieee =\r\n(instance->instancet->read_fw_status_reg(reg_set) &\r\n0x04000000);\r\nprintk(KERN_NOTICE "megasas_init_mfi: fw_support_ieee=%d",\r\ninstance->fw_support_ieee);\r\nif (instance->fw_support_ieee)\r\ninstance->flag_ieee = 1;\r\nreturn 0;\r\nfail_fw_init:\r\npci_free_consistent(instance->pdev, reply_q_sz,\r\ninstance->reply_queue, instance->reply_queue_h);\r\nfail_reply_queue:\r\nmegasas_free_cmds(instance);\r\nfail_alloc_cmds:\r\nreturn 1;\r\n}\r\nstatic int megasas_init_fw(struct megasas_instance *instance)\r\n{\r\nu32 max_sectors_1;\r\nu32 max_sectors_2;\r\nu32 tmp_sectors, msix_enable;\r\nstruct megasas_register_set __iomem *reg_set;\r\nstruct megasas_ctrl_info *ctrl_info;\r\nunsigned long bar_list;\r\nint i;\r\nbar_list = pci_select_bars(instance->pdev, IORESOURCE_MEM);\r\ninstance->bar = find_first_bit(&bar_list, sizeof(unsigned long));\r\ninstance->base_addr = pci_resource_start(instance->pdev, instance->bar);\r\nif (pci_request_selected_regions(instance->pdev, instance->bar,\r\n"megasas: LSI")) {\r\nprintk(KERN_DEBUG "megasas: IO memory region busy!\n");\r\nreturn -EBUSY;\r\n}\r\ninstance->reg_set = ioremap_nocache(instance->base_addr, 8192);\r\nif (!instance->reg_set) {\r\nprintk(KERN_DEBUG "megasas: Failed to map IO mem\n");\r\ngoto fail_ioremap;\r\n}\r\nreg_set = instance->reg_set;\r\nswitch (instance->pdev->device) {\r\ncase PCI_DEVICE_ID_LSI_FUSION:\r\ncase PCI_DEVICE_ID_LSI_INVADER:\r\ninstance->instancet = &megasas_instance_template_fusion;\r\nbreak;\r\ncase PCI_DEVICE_ID_LSI_SAS1078R:\r\ncase PCI_DEVICE_ID_LSI_SAS1078DE:\r\ninstance->instancet = &megasas_instance_template_ppc;\r\nbreak;\r\ncase PCI_DEVICE_ID_LSI_SAS1078GEN2:\r\ncase PCI_DEVICE_ID_LSI_SAS0079GEN2:\r\ninstance->instancet = &megasas_instance_template_gen2;\r\nbreak;\r\ncase PCI_DEVICE_ID_LSI_SAS0073SKINNY:\r\ncase PCI_DEVICE_ID_LSI_SAS0071SKINNY:\r\ninstance->instancet = &megasas_instance_template_skinny;\r\nbreak;\r\ncase PCI_DEVICE_ID_LSI_SAS1064R:\r\ncase PCI_DEVICE_ID_DELL_PERC5:\r\ndefault:\r\ninstance->instancet = &megasas_instance_template_xscale;\r\nbreak;\r\n}\r\nif (megasas_transition_to_ready(instance, 0))\r\ngoto fail_ready_state;\r\nmsix_enable = (instance->instancet->read_fw_status_reg(reg_set) &\r\n0x4000000) >> 0x1a;\r\nif (msix_enable && !msix_disable) {\r\nif ((instance->pdev->device == PCI_DEVICE_ID_LSI_FUSION) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER)) {\r\ninstance->msix_vectors = (readl(&instance->reg_set->\r\noutbound_scratch_pad_2\r\n) & 0x1F) + 1;\r\n} else\r\ninstance->msix_vectors = 1;\r\ninstance->msix_vectors = min(instance->msix_vectors,\r\n(unsigned int)num_online_cpus());\r\nfor (i = 0; i < instance->msix_vectors; i++)\r\ninstance->msixentry[i].entry = i;\r\ni = pci_enable_msix(instance->pdev, instance->msixentry,\r\ninstance->msix_vectors);\r\nif (i >= 0) {\r\nif (i) {\r\nif (!pci_enable_msix(instance->pdev,\r\ninstance->msixentry, i))\r\ninstance->msix_vectors = i;\r\nelse\r\ninstance->msix_vectors = 0;\r\n}\r\n} else\r\ninstance->msix_vectors = 0;\r\n}\r\nif (instance->instancet->init_adapter(instance))\r\ngoto fail_init_adapter;\r\nprintk(KERN_ERR "megasas: INIT adapter done\n");\r\nmemset(instance->pd_list, 0 ,\r\n(MEGASAS_MAX_PD * sizeof(struct megasas_pd_list)));\r\nmegasas_get_pd_list(instance);\r\nmemset(instance->ld_ids, 0xff, MEGASAS_MAX_LD_IDS);\r\nmegasas_get_ld_list(instance);\r\nctrl_info = kmalloc(sizeof(struct megasas_ctrl_info), GFP_KERNEL);\r\ntmp_sectors = 0;\r\nif (ctrl_info && !megasas_get_ctrl_info(instance, ctrl_info)) {\r\nmax_sectors_1 = (1 << ctrl_info->stripe_sz_ops.min) *\r\nctrl_info->max_strips_per_io;\r\nmax_sectors_2 = ctrl_info->max_request_size;\r\ntmp_sectors = min_t(u32, max_sectors_1 , max_sectors_2);\r\ninstance->disableOnlineCtrlReset =\r\nctrl_info->properties.OnOffProperties.disableOnlineCtrlReset;\r\n}\r\ninstance->max_sectors_per_req = instance->max_num_sge *\r\nPAGE_SIZE / 512;\r\nif (tmp_sectors && (instance->max_sectors_per_req > tmp_sectors))\r\ninstance->max_sectors_per_req = tmp_sectors;\r\nkfree(ctrl_info);\r\ntasklet_init(&instance->isr_tasklet, instance->instancet->tasklet,\r\n(unsigned long)instance);\r\nreturn 0;\r\nfail_init_adapter:\r\nfail_ready_state:\r\niounmap(instance->reg_set);\r\nfail_ioremap:\r\npci_release_selected_regions(instance->pdev, instance->bar);\r\nreturn -EINVAL;\r\n}\r\nstatic void megasas_release_mfi(struct megasas_instance *instance)\r\n{\r\nu32 reply_q_sz = sizeof(u32) *(instance->max_mfi_cmds + 1);\r\nif (instance->reply_queue)\r\npci_free_consistent(instance->pdev, reply_q_sz,\r\ninstance->reply_queue, instance->reply_queue_h);\r\nmegasas_free_cmds(instance);\r\niounmap(instance->reg_set);\r\npci_release_selected_regions(instance->pdev, instance->bar);\r\n}\r\nstatic int\r\nmegasas_get_seq_num(struct megasas_instance *instance,\r\nstruct megasas_evt_log_info *eli)\r\n{\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nstruct megasas_evt_log_info *el_info;\r\ndma_addr_t el_info_h = 0;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\nreturn -ENOMEM;\r\n}\r\ndcmd = &cmd->frame->dcmd;\r\nel_info = pci_alloc_consistent(instance->pdev,\r\nsizeof(struct megasas_evt_log_info),\r\n&el_info_h);\r\nif (!el_info) {\r\nmegasas_return_cmd(instance, cmd);\r\nreturn -ENOMEM;\r\n}\r\nmemset(el_info, 0, sizeof(*el_info));\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0x0;\r\ndcmd->sge_count = 1;\r\ndcmd->flags = MFI_FRAME_DIR_READ;\r\ndcmd->timeout = 0;\r\ndcmd->pad_0 = 0;\r\ndcmd->data_xfer_len = sizeof(struct megasas_evt_log_info);\r\ndcmd->opcode = MR_DCMD_CTRL_EVENT_GET_INFO;\r\ndcmd->sgl.sge32[0].phys_addr = el_info_h;\r\ndcmd->sgl.sge32[0].length = sizeof(struct megasas_evt_log_info);\r\nmegasas_issue_blocked_cmd(instance, cmd);\r\nmemcpy(eli, el_info, sizeof(struct megasas_evt_log_info));\r\npci_free_consistent(instance->pdev, sizeof(struct megasas_evt_log_info),\r\nel_info, el_info_h);\r\nmegasas_return_cmd(instance, cmd);\r\nreturn 0;\r\n}\r\nstatic int\r\nmegasas_register_aen(struct megasas_instance *instance, u32 seq_num,\r\nu32 class_locale_word)\r\n{\r\nint ret_val;\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nunion megasas_evt_class_locale curr_aen;\r\nunion megasas_evt_class_locale prev_aen;\r\ncurr_aen.word = class_locale_word;\r\nif (instance->aen_cmd) {\r\nprev_aen.word = instance->aen_cmd->frame->dcmd.mbox.w[1];\r\nif ((prev_aen.members.class <= curr_aen.members.class) &&\r\n!((prev_aen.members.locale & curr_aen.members.locale) ^\r\ncurr_aen.members.locale)) {\r\nreturn 0;\r\n} else {\r\ncurr_aen.members.locale |= prev_aen.members.locale;\r\nif (prev_aen.members.class < curr_aen.members.class)\r\ncurr_aen.members.class = prev_aen.members.class;\r\ninstance->aen_cmd->abort_aen = 1;\r\nret_val = megasas_issue_blocked_abort_cmd(instance,\r\ninstance->\r\naen_cmd);\r\nif (ret_val) {\r\nprintk(KERN_DEBUG "megasas: Failed to abort "\r\n"previous AEN command\n");\r\nreturn ret_val;\r\n}\r\n}\r\n}\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd)\r\nreturn -ENOMEM;\r\ndcmd = &cmd->frame->dcmd;\r\nmemset(instance->evt_detail, 0, sizeof(struct megasas_evt_detail));\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0x0;\r\ndcmd->sge_count = 1;\r\ndcmd->flags = MFI_FRAME_DIR_READ;\r\ndcmd->timeout = 0;\r\ndcmd->pad_0 = 0;\r\ninstance->last_seq_num = seq_num;\r\ndcmd->data_xfer_len = sizeof(struct megasas_evt_detail);\r\ndcmd->opcode = MR_DCMD_CTRL_EVENT_WAIT;\r\ndcmd->mbox.w[0] = seq_num;\r\ndcmd->mbox.w[1] = curr_aen.word;\r\ndcmd->sgl.sge32[0].phys_addr = (u32) instance->evt_detail_h;\r\ndcmd->sgl.sge32[0].length = sizeof(struct megasas_evt_detail);\r\nif (instance->aen_cmd != NULL) {\r\nmegasas_return_cmd(instance, cmd);\r\nreturn 0;\r\n}\r\ninstance->aen_cmd = cmd;\r\ninstance->instancet->issue_dcmd(instance, cmd);\r\nreturn 0;\r\n}\r\nstatic int megasas_start_aen(struct megasas_instance *instance)\r\n{\r\nstruct megasas_evt_log_info eli;\r\nunion megasas_evt_class_locale class_locale;\r\nmemset(&eli, 0, sizeof(eli));\r\nif (megasas_get_seq_num(instance, &eli))\r\nreturn -1;\r\nclass_locale.members.reserved = 0;\r\nclass_locale.members.locale = MR_EVT_LOCALE_ALL;\r\nclass_locale.members.class = MR_EVT_CLASS_DEBUG;\r\nreturn megasas_register_aen(instance, eli.newest_seq_num + 1,\r\nclass_locale.word);\r\n}\r\nstatic int megasas_io_attach(struct megasas_instance *instance)\r\n{\r\nstruct Scsi_Host *host = instance->host;\r\nhost->irq = instance->pdev->irq;\r\nhost->unique_id = instance->unique_id;\r\nif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY)) {\r\nhost->can_queue =\r\ninstance->max_fw_cmds - MEGASAS_SKINNY_INT_CMDS;\r\n} else\r\nhost->can_queue =\r\ninstance->max_fw_cmds - MEGASAS_INT_CMDS;\r\nhost->this_id = instance->init_id;\r\nhost->sg_tablesize = instance->max_num_sge;\r\nif (instance->fw_support_ieee)\r\ninstance->max_sectors_per_req = MEGASAS_MAX_SECTORS_IEEE;\r\nif (max_sectors && max_sectors < instance->max_sectors_per_req)\r\ninstance->max_sectors_per_req = max_sectors;\r\nelse {\r\nif (max_sectors) {\r\nif (((instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS1078GEN2) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS0079GEN2)) &&\r\n(max_sectors <= MEGASAS_MAX_SECTORS)) {\r\ninstance->max_sectors_per_req = max_sectors;\r\n} else {\r\nprintk(KERN_INFO "megasas: max_sectors should be > 0"\r\n"and <= %d (or < 1MB for GEN2 controller)\n",\r\ninstance->max_sectors_per_req);\r\n}\r\n}\r\n}\r\nhost->max_sectors = instance->max_sectors_per_req;\r\nhost->cmd_per_lun = MEGASAS_DEFAULT_CMD_PER_LUN;\r\nhost->max_channel = MEGASAS_MAX_CHANNELS - 1;\r\nhost->max_id = MEGASAS_MAX_DEV_PER_CHANNEL;\r\nhost->max_lun = MEGASAS_MAX_LUN;\r\nhost->max_cmd_len = 16;\r\nif ((instance->pdev->device == PCI_DEVICE_ID_LSI_FUSION) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER)) {\r\nhost->hostt->eh_device_reset_handler = NULL;\r\nhost->hostt->eh_bus_reset_handler = NULL;\r\n}\r\nif (scsi_add_host(host, &instance->pdev->dev)) {\r\nprintk(KERN_DEBUG "megasas: scsi_add_host failed\n");\r\nreturn -ENODEV;\r\n}\r\nscsi_scan_host(host);\r\nreturn 0;\r\n}\r\nstatic int\r\nmegasas_set_dma_mask(struct pci_dev *pdev)\r\n{\r\nif (IS_DMA64) {\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(64)) != 0) {\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) != 0)\r\ngoto fail_set_dma_mask;\r\n}\r\n} else {\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) != 0)\r\ngoto fail_set_dma_mask;\r\n}\r\nreturn 0;\r\nfail_set_dma_mask:\r\nreturn 1;\r\n}\r\nstatic int __devinit\r\nmegasas_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nint rval, pos, i, j;\r\nstruct Scsi_Host *host;\r\nstruct megasas_instance *instance;\r\nu16 control = 0;\r\nif (reset_devices) {\r\npos = pci_find_capability(pdev, PCI_CAP_ID_MSIX);\r\nif (pos) {\r\npci_read_config_word(pdev, msi_control_reg(pos),\r\n&control);\r\nif (control & PCI_MSIX_FLAGS_ENABLE) {\r\ndev_info(&pdev->dev, "resetting MSI-X\n");\r\npci_write_config_word(pdev,\r\nmsi_control_reg(pos),\r\ncontrol &\r\n~PCI_MSIX_FLAGS_ENABLE);\r\n}\r\n}\r\n}\r\nprintk(KERN_INFO "megasas: %#4.04x:%#4.04x:%#4.04x:%#4.04x: ",\r\npdev->vendor, pdev->device, pdev->subsystem_vendor,\r\npdev->subsystem_device);\r\nprintk("bus %d:slot %d:func %d\n",\r\npdev->bus->number, PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));\r\nrval = pci_enable_device_mem(pdev);\r\nif (rval) {\r\nreturn rval;\r\n}\r\npci_set_master(pdev);\r\nif (megasas_set_dma_mask(pdev))\r\ngoto fail_set_dma_mask;\r\nhost = scsi_host_alloc(&megasas_template,\r\nsizeof(struct megasas_instance));\r\nif (!host) {\r\nprintk(KERN_DEBUG "megasas: scsi_host_alloc failed\n");\r\ngoto fail_alloc_instance;\r\n}\r\ninstance = (struct megasas_instance *)host->hostdata;\r\nmemset(instance, 0, sizeof(*instance));\r\natomic_set( &instance->fw_reset_no_pci_access, 0 );\r\ninstance->pdev = pdev;\r\nswitch (instance->pdev->device) {\r\ncase PCI_DEVICE_ID_LSI_FUSION:\r\ncase PCI_DEVICE_ID_LSI_INVADER:\r\n{\r\nstruct fusion_context *fusion;\r\ninstance->ctrl_context =\r\nkzalloc(sizeof(struct fusion_context), GFP_KERNEL);\r\nif (!instance->ctrl_context) {\r\nprintk(KERN_DEBUG "megasas: Failed to allocate "\r\n"memory for Fusion context info\n");\r\ngoto fail_alloc_dma_buf;\r\n}\r\nfusion = instance->ctrl_context;\r\nINIT_LIST_HEAD(&fusion->cmd_pool);\r\nspin_lock_init(&fusion->cmd_pool_lock);\r\n}\r\nbreak;\r\ndefault:\r\ninstance->producer =\r\npci_alloc_consistent(pdev, sizeof(u32),\r\n&instance->producer_h);\r\ninstance->consumer =\r\npci_alloc_consistent(pdev, sizeof(u32),\r\n&instance->consumer_h);\r\nif (!instance->producer || !instance->consumer) {\r\nprintk(KERN_DEBUG "megasas: Failed to allocate"\r\n"memory for producer, consumer\n");\r\ngoto fail_alloc_dma_buf;\r\n}\r\n*instance->producer = 0;\r\n*instance->consumer = 0;\r\nbreak;\r\n}\r\nmegasas_poll_wait_aen = 0;\r\ninstance->flag_ieee = 0;\r\ninstance->ev = NULL;\r\ninstance->issuepend_done = 1;\r\ninstance->adprecovery = MEGASAS_HBA_OPERATIONAL;\r\nmegasas_poll_wait_aen = 0;\r\ninstance->evt_detail = pci_alloc_consistent(pdev,\r\nsizeof(struct\r\nmegasas_evt_detail),\r\n&instance->evt_detail_h);\r\nif (!instance->evt_detail) {\r\nprintk(KERN_DEBUG "megasas: Failed to allocate memory for "\r\n"event detail structure\n");\r\ngoto fail_alloc_dma_buf;\r\n}\r\nINIT_LIST_HEAD(&instance->cmd_pool);\r\nINIT_LIST_HEAD(&instance->internal_reset_pending_q);\r\natomic_set(&instance->fw_outstanding,0);\r\ninit_waitqueue_head(&instance->int_cmd_wait_q);\r\ninit_waitqueue_head(&instance->abort_cmd_wait_q);\r\nspin_lock_init(&instance->cmd_pool_lock);\r\nspin_lock_init(&instance->hba_lock);\r\nspin_lock_init(&instance->completion_lock);\r\nspin_lock_init(&poll_aen_lock);\r\nmutex_init(&instance->aen_mutex);\r\nmutex_init(&instance->reset_mutex);\r\ninstance->host = host;\r\ninstance->unique_id = pdev->bus->number << 8 | pdev->devfn;\r\ninstance->init_id = MEGASAS_DEFAULT_INIT_ID;\r\nif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY)) {\r\ninstance->flag_ieee = 1;\r\nsema_init(&instance->ioctl_sem, MEGASAS_SKINNY_INT_CMDS);\r\n} else\r\nsema_init(&instance->ioctl_sem, MEGASAS_INT_CMDS);\r\nmegasas_dbg_lvl = 0;\r\ninstance->flag = 0;\r\ninstance->unload = 1;\r\ninstance->last_time = 0;\r\ninstance->disableOnlineCtrlReset = 1;\r\nif ((instance->pdev->device == PCI_DEVICE_ID_LSI_FUSION) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER))\r\nINIT_WORK(&instance->work_init, megasas_fusion_ocr_wq);\r\nelse\r\nINIT_WORK(&instance->work_init, process_fw_state_change_wq);\r\nif (megasas_init_fw(instance))\r\ngoto fail_init_mfi;\r\nif (instance->msix_vectors) {\r\nfor (i = 0 ; i < instance->msix_vectors; i++) {\r\ninstance->irq_context[i].instance = instance;\r\ninstance->irq_context[i].MSIxIndex = i;\r\nif (request_irq(instance->msixentry[i].vector,\r\ninstance->instancet->service_isr, 0,\r\n"megasas",\r\n&instance->irq_context[i])) {\r\nprintk(KERN_DEBUG "megasas: Failed to "\r\n"register IRQ for vector %d.\n", i);\r\nfor (j = 0 ; j < i ; j++)\r\nfree_irq(\r\ninstance->msixentry[j].vector,\r\n&instance->irq_context[j]);\r\ngoto fail_irq;\r\n}\r\n}\r\n} else {\r\ninstance->irq_context[0].instance = instance;\r\ninstance->irq_context[0].MSIxIndex = 0;\r\nif (request_irq(pdev->irq, instance->instancet->service_isr,\r\nIRQF_SHARED, "megasas",\r\n&instance->irq_context[0])) {\r\nprintk(KERN_DEBUG "megasas: Failed to register IRQ\n");\r\ngoto fail_irq;\r\n}\r\n}\r\ninstance->instancet->enable_intr(instance->reg_set);\r\npci_set_drvdata(pdev, instance);\r\nmegasas_mgmt_info.count++;\r\nmegasas_mgmt_info.instance[megasas_mgmt_info.max_index] = instance;\r\nmegasas_mgmt_info.max_index++;\r\nif (megasas_io_attach(instance))\r\ngoto fail_io_attach;\r\ninstance->unload = 0;\r\nif (megasas_start_aen(instance)) {\r\nprintk(KERN_DEBUG "megasas: start aen failed\n");\r\ngoto fail_start_aen;\r\n}\r\nreturn 0;\r\nfail_start_aen:\r\nfail_io_attach:\r\nmegasas_mgmt_info.count--;\r\nmegasas_mgmt_info.instance[megasas_mgmt_info.max_index] = NULL;\r\nmegasas_mgmt_info.max_index--;\r\npci_set_drvdata(pdev, NULL);\r\ninstance->instancet->disable_intr(instance->reg_set);\r\nif (instance->msix_vectors)\r\nfor (i = 0 ; i < instance->msix_vectors; i++)\r\nfree_irq(instance->msixentry[i].vector,\r\n&instance->irq_context[i]);\r\nelse\r\nfree_irq(instance->pdev->irq, &instance->irq_context[0]);\r\nfail_irq:\r\nif ((instance->pdev->device == PCI_DEVICE_ID_LSI_FUSION) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER))\r\nmegasas_release_fusion(instance);\r\nelse\r\nmegasas_release_mfi(instance);\r\nfail_init_mfi:\r\nif (instance->msix_vectors)\r\npci_disable_msix(instance->pdev);\r\nfail_alloc_dma_buf:\r\nif (instance->evt_detail)\r\npci_free_consistent(pdev, sizeof(struct megasas_evt_detail),\r\ninstance->evt_detail,\r\ninstance->evt_detail_h);\r\nif (instance->producer)\r\npci_free_consistent(pdev, sizeof(u32), instance->producer,\r\ninstance->producer_h);\r\nif (instance->consumer)\r\npci_free_consistent(pdev, sizeof(u32), instance->consumer,\r\ninstance->consumer_h);\r\nscsi_host_put(host);\r\nfail_alloc_instance:\r\nfail_set_dma_mask:\r\npci_disable_device(pdev);\r\nreturn -ENODEV;\r\n}\r\nstatic void megasas_flush_cache(struct megasas_instance *instance)\r\n{\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nif (instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR)\r\nreturn;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd)\r\nreturn;\r\ndcmd = &cmd->frame->dcmd;\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0x0;\r\ndcmd->sge_count = 0;\r\ndcmd->flags = MFI_FRAME_DIR_NONE;\r\ndcmd->timeout = 0;\r\ndcmd->pad_0 = 0;\r\ndcmd->data_xfer_len = 0;\r\ndcmd->opcode = MR_DCMD_CTRL_CACHE_FLUSH;\r\ndcmd->mbox.b[0] = MR_FLUSH_CTRL_CACHE | MR_FLUSH_DISK_CACHE;\r\nmegasas_issue_blocked_cmd(instance, cmd);\r\nmegasas_return_cmd(instance, cmd);\r\nreturn;\r\n}\r\nstatic void megasas_shutdown_controller(struct megasas_instance *instance,\r\nu32 opcode)\r\n{\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nif (instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR)\r\nreturn;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd)\r\nreturn;\r\nif (instance->aen_cmd)\r\nmegasas_issue_blocked_abort_cmd(instance, instance->aen_cmd);\r\nif (instance->map_update_cmd)\r\nmegasas_issue_blocked_abort_cmd(instance,\r\ninstance->map_update_cmd);\r\ndcmd = &cmd->frame->dcmd;\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0x0;\r\ndcmd->sge_count = 0;\r\ndcmd->flags = MFI_FRAME_DIR_NONE;\r\ndcmd->timeout = 0;\r\ndcmd->pad_0 = 0;\r\ndcmd->data_xfer_len = 0;\r\ndcmd->opcode = opcode;\r\nmegasas_issue_blocked_cmd(instance, cmd);\r\nmegasas_return_cmd(instance, cmd);\r\nreturn;\r\n}\r\nstatic int\r\nmegasas_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct Scsi_Host *host;\r\nstruct megasas_instance *instance;\r\nint i;\r\ninstance = pci_get_drvdata(pdev);\r\nhost = instance->host;\r\ninstance->unload = 1;\r\nmegasas_flush_cache(instance);\r\nmegasas_shutdown_controller(instance, MR_DCMD_HIBERNATE_SHUTDOWN);\r\nif (instance->ev != NULL) {\r\nstruct megasas_aen_event *ev = instance->ev;\r\ncancel_delayed_work_sync(\r\n(struct delayed_work *)&ev->hotplug_work);\r\ninstance->ev = NULL;\r\n}\r\ntasklet_kill(&instance->isr_tasklet);\r\npci_set_drvdata(instance->pdev, instance);\r\ninstance->instancet->disable_intr(instance->reg_set);\r\nif (instance->msix_vectors)\r\nfor (i = 0 ; i < instance->msix_vectors; i++)\r\nfree_irq(instance->msixentry[i].vector,\r\n&instance->irq_context[i]);\r\nelse\r\nfree_irq(instance->pdev->irq, &instance->irq_context[0]);\r\nif (instance->msix_vectors)\r\npci_disable_msix(instance->pdev);\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int\r\nmegasas_resume(struct pci_dev *pdev)\r\n{\r\nint rval, i, j;\r\nstruct Scsi_Host *host;\r\nstruct megasas_instance *instance;\r\ninstance = pci_get_drvdata(pdev);\r\nhost = instance->host;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_enable_wake(pdev, PCI_D0, 0);\r\npci_restore_state(pdev);\r\nrval = pci_enable_device_mem(pdev);\r\nif (rval) {\r\nprintk(KERN_ERR "megasas: Enable device failed\n");\r\nreturn rval;\r\n}\r\npci_set_master(pdev);\r\nif (megasas_set_dma_mask(pdev))\r\ngoto fail_set_dma_mask;\r\natomic_set(&instance->fw_outstanding, 0);\r\nif (megasas_transition_to_ready(instance, 0))\r\ngoto fail_ready_state;\r\nif (instance->msix_vectors)\r\npci_enable_msix(instance->pdev, instance->msixentry,\r\ninstance->msix_vectors);\r\nswitch (instance->pdev->device) {\r\ncase PCI_DEVICE_ID_LSI_FUSION:\r\ncase PCI_DEVICE_ID_LSI_INVADER:\r\n{\r\nmegasas_reset_reply_desc(instance);\r\nif (megasas_ioc_init_fusion(instance)) {\r\nmegasas_free_cmds(instance);\r\nmegasas_free_cmds_fusion(instance);\r\ngoto fail_init_mfi;\r\n}\r\nif (!megasas_get_map_info(instance))\r\nmegasas_sync_map_info(instance);\r\n}\r\nbreak;\r\ndefault:\r\n*instance->producer = 0;\r\n*instance->consumer = 0;\r\nif (megasas_issue_init_mfi(instance))\r\ngoto fail_init_mfi;\r\nbreak;\r\n}\r\ntasklet_init(&instance->isr_tasklet, instance->instancet->tasklet,\r\n(unsigned long)instance);\r\nif (instance->msix_vectors) {\r\nfor (i = 0 ; i < instance->msix_vectors; i++) {\r\ninstance->irq_context[i].instance = instance;\r\ninstance->irq_context[i].MSIxIndex = i;\r\nif (request_irq(instance->msixentry[i].vector,\r\ninstance->instancet->service_isr, 0,\r\n"megasas",\r\n&instance->irq_context[i])) {\r\nprintk(KERN_DEBUG "megasas: Failed to "\r\n"register IRQ for vector %d.\n", i);\r\nfor (j = 0 ; j < i ; j++)\r\nfree_irq(\r\ninstance->msixentry[j].vector,\r\n&instance->irq_context[j]);\r\ngoto fail_irq;\r\n}\r\n}\r\n} else {\r\ninstance->irq_context[0].instance = instance;\r\ninstance->irq_context[0].MSIxIndex = 0;\r\nif (request_irq(pdev->irq, instance->instancet->service_isr,\r\nIRQF_SHARED, "megasas",\r\n&instance->irq_context[0])) {\r\nprintk(KERN_DEBUG "megasas: Failed to register IRQ\n");\r\ngoto fail_irq;\r\n}\r\n}\r\ninstance->instancet->enable_intr(instance->reg_set);\r\ninstance->unload = 0;\r\nif (megasas_start_aen(instance))\r\nprintk(KERN_ERR "megasas: Start AEN failed\n");\r\nreturn 0;\r\nfail_irq:\r\nfail_init_mfi:\r\nif (instance->evt_detail)\r\npci_free_consistent(pdev, sizeof(struct megasas_evt_detail),\r\ninstance->evt_detail,\r\ninstance->evt_detail_h);\r\nif (instance->producer)\r\npci_free_consistent(pdev, sizeof(u32), instance->producer,\r\ninstance->producer_h);\r\nif (instance->consumer)\r\npci_free_consistent(pdev, sizeof(u32), instance->consumer,\r\ninstance->consumer_h);\r\nscsi_host_put(host);\r\nfail_set_dma_mask:\r\nfail_ready_state:\r\npci_disable_device(pdev);\r\nreturn -ENODEV;\r\n}\r\nstatic void __devexit megasas_detach_one(struct pci_dev *pdev)\r\n{\r\nint i;\r\nstruct Scsi_Host *host;\r\nstruct megasas_instance *instance;\r\nstruct fusion_context *fusion;\r\ninstance = pci_get_drvdata(pdev);\r\ninstance->unload = 1;\r\nhost = instance->host;\r\nfusion = instance->ctrl_context;\r\nscsi_remove_host(instance->host);\r\nmegasas_flush_cache(instance);\r\nmegasas_shutdown_controller(instance, MR_DCMD_CTRL_SHUTDOWN);\r\nif (instance->ev != NULL) {\r\nstruct megasas_aen_event *ev = instance->ev;\r\ncancel_delayed_work_sync(\r\n(struct delayed_work *)&ev->hotplug_work);\r\ninstance->ev = NULL;\r\n}\r\ntasklet_kill(&instance->isr_tasklet);\r\nfor (i = 0; i < megasas_mgmt_info.max_index; i++) {\r\nif (megasas_mgmt_info.instance[i] == instance) {\r\nmegasas_mgmt_info.count--;\r\nmegasas_mgmt_info.instance[i] = NULL;\r\nbreak;\r\n}\r\n}\r\npci_set_drvdata(instance->pdev, NULL);\r\ninstance->instancet->disable_intr(instance->reg_set);\r\nif (instance->msix_vectors)\r\nfor (i = 0 ; i < instance->msix_vectors; i++)\r\nfree_irq(instance->msixentry[i].vector,\r\n&instance->irq_context[i]);\r\nelse\r\nfree_irq(instance->pdev->irq, &instance->irq_context[0]);\r\nif (instance->msix_vectors)\r\npci_disable_msix(instance->pdev);\r\nswitch (instance->pdev->device) {\r\ncase PCI_DEVICE_ID_LSI_FUSION:\r\ncase PCI_DEVICE_ID_LSI_INVADER:\r\nmegasas_release_fusion(instance);\r\nfor (i = 0; i < 2 ; i++)\r\nif (fusion->ld_map[i])\r\ndma_free_coherent(&instance->pdev->dev,\r\nfusion->map_sz,\r\nfusion->ld_map[i],\r\nfusion->\r\nld_map_phys[i]);\r\nkfree(instance->ctrl_context);\r\nbreak;\r\ndefault:\r\nmegasas_release_mfi(instance);\r\npci_free_consistent(pdev,\r\nsizeof(struct megasas_evt_detail),\r\ninstance->evt_detail,\r\ninstance->evt_detail_h);\r\npci_free_consistent(pdev, sizeof(u32),\r\ninstance->producer,\r\ninstance->producer_h);\r\npci_free_consistent(pdev, sizeof(u32),\r\ninstance->consumer,\r\ninstance->consumer_h);\r\nbreak;\r\n}\r\nscsi_host_put(host);\r\npci_set_drvdata(pdev, NULL);\r\npci_disable_device(pdev);\r\nreturn;\r\n}\r\nstatic void megasas_shutdown(struct pci_dev *pdev)\r\n{\r\nint i;\r\nstruct megasas_instance *instance = pci_get_drvdata(pdev);\r\ninstance->unload = 1;\r\nmegasas_flush_cache(instance);\r\nmegasas_shutdown_controller(instance, MR_DCMD_CTRL_SHUTDOWN);\r\ninstance->instancet->disable_intr(instance->reg_set);\r\nif (instance->msix_vectors)\r\nfor (i = 0 ; i < instance->msix_vectors; i++)\r\nfree_irq(instance->msixentry[i].vector,\r\n&instance->irq_context[i]);\r\nelse\r\nfree_irq(instance->pdev->irq, &instance->irq_context[0]);\r\nif (instance->msix_vectors)\r\npci_disable_msix(instance->pdev);\r\n}\r\nstatic int megasas_mgmt_open(struct inode *inode, struct file *filep)\r\n{\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nreturn 0;\r\n}\r\nstatic int megasas_mgmt_fasync(int fd, struct file *filep, int mode)\r\n{\r\nint rc;\r\nmutex_lock(&megasas_async_queue_mutex);\r\nrc = fasync_helper(fd, filep, mode, &megasas_async_queue);\r\nmutex_unlock(&megasas_async_queue_mutex);\r\nif (rc >= 0) {\r\nfilep->private_data = filep;\r\nreturn 0;\r\n}\r\nprintk(KERN_DEBUG "megasas: fasync_helper failed [%d]\n", rc);\r\nreturn rc;\r\n}\r\nstatic unsigned int megasas_mgmt_poll(struct file *file, poll_table *wait)\r\n{\r\nunsigned int mask;\r\nunsigned long flags;\r\npoll_wait(file, &megasas_poll_wait, wait);\r\nspin_lock_irqsave(&poll_aen_lock, flags);\r\nif (megasas_poll_wait_aen)\r\nmask = (POLLIN | POLLRDNORM);\r\nelse\r\nmask = 0;\r\nspin_unlock_irqrestore(&poll_aen_lock, flags);\r\nreturn mask;\r\n}\r\nstatic int\r\nmegasas_mgmt_fw_ioctl(struct megasas_instance *instance,\r\nstruct megasas_iocpacket __user * user_ioc,\r\nstruct megasas_iocpacket *ioc)\r\n{\r\nstruct megasas_sge32 *kern_sge32;\r\nstruct megasas_cmd *cmd;\r\nvoid *kbuff_arr[MAX_IOCTL_SGE];\r\ndma_addr_t buf_handle = 0;\r\nint error = 0, i;\r\nvoid *sense = NULL;\r\ndma_addr_t sense_handle;\r\nunsigned long *sense_ptr;\r\nmemset(kbuff_arr, 0, sizeof(kbuff_arr));\r\nif (ioc->sge_count > MAX_IOCTL_SGE) {\r\nprintk(KERN_DEBUG "megasas: SGE count [%d] > max limit [%d]\n",\r\nioc->sge_count, MAX_IOCTL_SGE);\r\nreturn -EINVAL;\r\n}\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\nprintk(KERN_DEBUG "megasas: Failed to get a cmd packet\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(cmd->frame, ioc->frame.raw, 2 * MEGAMFI_FRAME_SIZE);\r\ncmd->frame->hdr.context = cmd->index;\r\ncmd->frame->hdr.pad_0 = 0;\r\ncmd->frame->hdr.flags &= ~(MFI_FRAME_IEEE | MFI_FRAME_SGL64 |\r\nMFI_FRAME_SENSE64);\r\nkern_sge32 = (struct megasas_sge32 *)\r\n((unsigned long)cmd->frame + ioc->sgl_off);\r\nfor (i = 0; i < ioc->sge_count; i++) {\r\nif (!ioc->sgl[i].iov_len)\r\ncontinue;\r\nkbuff_arr[i] = dma_alloc_coherent(&instance->pdev->dev,\r\nioc->sgl[i].iov_len,\r\n&buf_handle, GFP_KERNEL);\r\nif (!kbuff_arr[i]) {\r\nprintk(KERN_DEBUG "megasas: Failed to alloc "\r\n"kernel SGL buffer for IOCTL \n");\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\nkern_sge32[i].phys_addr = (u32) buf_handle;\r\nkern_sge32[i].length = ioc->sgl[i].iov_len;\r\nif (copy_from_user(kbuff_arr[i], ioc->sgl[i].iov_base,\r\n(u32) (ioc->sgl[i].iov_len))) {\r\nerror = -EFAULT;\r\ngoto out;\r\n}\r\n}\r\nif (ioc->sense_len) {\r\nsense = dma_alloc_coherent(&instance->pdev->dev, ioc->sense_len,\r\n&sense_handle, GFP_KERNEL);\r\nif (!sense) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\nsense_ptr =\r\n(unsigned long *) ((unsigned long)cmd->frame + ioc->sense_off);\r\n*sense_ptr = sense_handle;\r\n}\r\ncmd->sync_cmd = 1;\r\nmegasas_issue_blocked_cmd(instance, cmd);\r\ncmd->sync_cmd = 0;\r\nfor (i = 0; i < ioc->sge_count; i++) {\r\nif (copy_to_user(ioc->sgl[i].iov_base, kbuff_arr[i],\r\nioc->sgl[i].iov_len)) {\r\nerror = -EFAULT;\r\ngoto out;\r\n}\r\n}\r\nif (ioc->sense_len) {\r\nsense_ptr = (unsigned long *) ((unsigned long)ioc->frame.raw +\r\nioc->sense_off);\r\nif (copy_to_user((void __user *)((unsigned long)(*sense_ptr)),\r\nsense, ioc->sense_len)) {\r\nprintk(KERN_ERR "megasas: Failed to copy out to user "\r\n"sense data\n");\r\nerror = -EFAULT;\r\ngoto out;\r\n}\r\n}\r\nif (copy_to_user(&user_ioc->frame.hdr.cmd_status,\r\n&cmd->frame->hdr.cmd_status, sizeof(u8))) {\r\nprintk(KERN_DEBUG "megasas: Error copying out cmd_status\n");\r\nerror = -EFAULT;\r\n}\r\nout:\r\nif (sense) {\r\ndma_free_coherent(&instance->pdev->dev, ioc->sense_len,\r\nsense, sense_handle);\r\n}\r\nfor (i = 0; i < ioc->sge_count && kbuff_arr[i]; i++) {\r\ndma_free_coherent(&instance->pdev->dev,\r\nkern_sge32[i].length,\r\nkbuff_arr[i], kern_sge32[i].phys_addr);\r\n}\r\nmegasas_return_cmd(instance, cmd);\r\nreturn error;\r\n}\r\nstatic int megasas_mgmt_ioctl_fw(struct file *file, unsigned long arg)\r\n{\r\nstruct megasas_iocpacket __user *user_ioc =\r\n(struct megasas_iocpacket __user *)arg;\r\nstruct megasas_iocpacket *ioc;\r\nstruct megasas_instance *instance;\r\nint error;\r\nint i;\r\nunsigned long flags;\r\nu32 wait_time = MEGASAS_RESET_WAIT_TIME;\r\nioc = kmalloc(sizeof(*ioc), GFP_KERNEL);\r\nif (!ioc)\r\nreturn -ENOMEM;\r\nif (copy_from_user(ioc, user_ioc, sizeof(*ioc))) {\r\nerror = -EFAULT;\r\ngoto out_kfree_ioc;\r\n}\r\ninstance = megasas_lookup_instance(ioc->host_no);\r\nif (!instance) {\r\nerror = -ENODEV;\r\ngoto out_kfree_ioc;\r\n}\r\nif (instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR) {\r\nprintk(KERN_ERR "Controller in crit error\n");\r\nerror = -ENODEV;\r\ngoto out_kfree_ioc;\r\n}\r\nif (instance->unload == 1) {\r\nerror = -ENODEV;\r\ngoto out_kfree_ioc;\r\n}\r\nif (down_interruptible(&instance->ioctl_sem)) {\r\nerror = -ERESTARTSYS;\r\ngoto out_kfree_ioc;\r\n}\r\nfor (i = 0; i < wait_time; i++) {\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nif (instance->adprecovery == MEGASAS_HBA_OPERATIONAL) {\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nif (!(i % MEGASAS_RESET_NOTICE_INTERVAL)) {\r\nprintk(KERN_NOTICE "megasas: waiting"\r\n"for controller reset to finish\n");\r\n}\r\nmsleep(1000);\r\n}\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nif (instance->adprecovery != MEGASAS_HBA_OPERATIONAL) {\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nprintk(KERN_ERR "megaraid_sas: timed out while"\r\n"waiting for HBA to recover\n");\r\nerror = -ENODEV;\r\ngoto out_kfree_ioc;\r\n}\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nerror = megasas_mgmt_fw_ioctl(instance, user_ioc, ioc);\r\nup(&instance->ioctl_sem);\r\nout_kfree_ioc:\r\nkfree(ioc);\r\nreturn error;\r\n}\r\nstatic int megasas_mgmt_ioctl_aen(struct file *file, unsigned long arg)\r\n{\r\nstruct megasas_instance *instance;\r\nstruct megasas_aen aen;\r\nint error;\r\nint i;\r\nunsigned long flags;\r\nu32 wait_time = MEGASAS_RESET_WAIT_TIME;\r\nif (file->private_data != file) {\r\nprintk(KERN_DEBUG "megasas: fasync_helper was not "\r\n"called first\n");\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&aen, (void __user *)arg, sizeof(aen)))\r\nreturn -EFAULT;\r\ninstance = megasas_lookup_instance(aen.host_no);\r\nif (!instance)\r\nreturn -ENODEV;\r\nif (instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR) {\r\nreturn -ENODEV;\r\n}\r\nif (instance->unload == 1) {\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < wait_time; i++) {\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nif (instance->adprecovery == MEGASAS_HBA_OPERATIONAL) {\r\nspin_unlock_irqrestore(&instance->hba_lock,\r\nflags);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nif (!(i % MEGASAS_RESET_NOTICE_INTERVAL)) {\r\nprintk(KERN_NOTICE "megasas: waiting for"\r\n"controller reset to finish\n");\r\n}\r\nmsleep(1000);\r\n}\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nif (instance->adprecovery != MEGASAS_HBA_OPERATIONAL) {\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nprintk(KERN_ERR "megaraid_sas: timed out while waiting"\r\n"for HBA to recover.\n");\r\nreturn -ENODEV;\r\n}\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nmutex_lock(&instance->aen_mutex);\r\nerror = megasas_register_aen(instance, aen.seq_num,\r\naen.class_locale_word);\r\nmutex_unlock(&instance->aen_mutex);\r\nreturn error;\r\n}\r\nstatic long\r\nmegasas_mgmt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase MEGASAS_IOC_FIRMWARE:\r\nreturn megasas_mgmt_ioctl_fw(file, arg);\r\ncase MEGASAS_IOC_GET_AEN:\r\nreturn megasas_mgmt_ioctl_aen(file, arg);\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic int megasas_mgmt_compat_ioctl_fw(struct file *file, unsigned long arg)\r\n{\r\nstruct compat_megasas_iocpacket __user *cioc =\r\n(struct compat_megasas_iocpacket __user *)arg;\r\nstruct megasas_iocpacket __user *ioc =\r\ncompat_alloc_user_space(sizeof(struct megasas_iocpacket));\r\nint i;\r\nint error = 0;\r\ncompat_uptr_t ptr;\r\nif (clear_user(ioc, sizeof(*ioc)))\r\nreturn -EFAULT;\r\nif (copy_in_user(&ioc->host_no, &cioc->host_no, sizeof(u16)) ||\r\ncopy_in_user(&ioc->sgl_off, &cioc->sgl_off, sizeof(u32)) ||\r\ncopy_in_user(&ioc->sense_off, &cioc->sense_off, sizeof(u32)) ||\r\ncopy_in_user(&ioc->sense_len, &cioc->sense_len, sizeof(u32)) ||\r\ncopy_in_user(ioc->frame.raw, cioc->frame.raw, 128) ||\r\ncopy_in_user(&ioc->sge_count, &cioc->sge_count, sizeof(u32)))\r\nreturn -EFAULT;\r\nif (ioc->sense_len) {\r\nvoid __user **sense_ioc_ptr =\r\n(void __user **)(ioc->frame.raw + ioc->sense_off);\r\ncompat_uptr_t *sense_cioc_ptr =\r\n(compat_uptr_t *)(cioc->frame.raw + cioc->sense_off);\r\nif (get_user(ptr, sense_cioc_ptr) ||\r\nput_user(compat_ptr(ptr), sense_ioc_ptr))\r\nreturn -EFAULT;\r\n}\r\nfor (i = 0; i < MAX_IOCTL_SGE; i++) {\r\nif (get_user(ptr, &cioc->sgl[i].iov_base) ||\r\nput_user(compat_ptr(ptr), &ioc->sgl[i].iov_base) ||\r\ncopy_in_user(&ioc->sgl[i].iov_len,\r\n&cioc->sgl[i].iov_len, sizeof(compat_size_t)))\r\nreturn -EFAULT;\r\n}\r\nerror = megasas_mgmt_ioctl_fw(file, (unsigned long)ioc);\r\nif (copy_in_user(&cioc->frame.hdr.cmd_status,\r\n&ioc->frame.hdr.cmd_status, sizeof(u8))) {\r\nprintk(KERN_DEBUG "megasas: error copy_in_user cmd_status\n");\r\nreturn -EFAULT;\r\n}\r\nreturn error;\r\n}\r\nstatic long\r\nmegasas_mgmt_compat_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase MEGASAS_IOC_FIRMWARE32:\r\nreturn megasas_mgmt_compat_ioctl_fw(file, arg);\r\ncase MEGASAS_IOC_GET_AEN:\r\nreturn megasas_mgmt_ioctl_aen(file, arg);\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic ssize_t megasas_sysfs_show_version(struct device_driver *dd, char *buf)\r\n{\r\nreturn snprintf(buf, strlen(MEGASAS_VERSION) + 2, "%s\n",\r\nMEGASAS_VERSION);\r\n}\r\nstatic ssize_t\r\nmegasas_sysfs_show_release_date(struct device_driver *dd, char *buf)\r\n{\r\nreturn snprintf(buf, strlen(MEGASAS_RELDATE) + 2, "%s\n",\r\nMEGASAS_RELDATE);\r\n}\r\nstatic ssize_t\r\nmegasas_sysfs_show_support_poll_for_event(struct device_driver *dd, char *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", support_poll_for_event);\r\n}\r\nstatic ssize_t\r\nmegasas_sysfs_show_support_device_change(struct device_driver *dd, char *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", support_device_change);\r\n}\r\nstatic ssize_t\r\nmegasas_sysfs_show_dbg_lvl(struct device_driver *dd, char *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", megasas_dbg_lvl);\r\n}\r\nstatic ssize_t\r\nmegasas_sysfs_set_dbg_lvl(struct device_driver *dd, const char *buf, size_t count)\r\n{\r\nint retval = count;\r\nif(sscanf(buf,"%u",&megasas_dbg_lvl)<1){\r\nprintk(KERN_ERR "megasas: could not set dbg_lvl\n");\r\nretval = -EINVAL;\r\n}\r\nreturn retval;\r\n}\r\nstatic void\r\nmegasas_aen_polling(struct work_struct *work)\r\n{\r\nstruct megasas_aen_event *ev =\r\ncontainer_of(work, struct megasas_aen_event, hotplug_work);\r\nstruct megasas_instance *instance = ev->instance;\r\nunion megasas_evt_class_locale class_locale;\r\nstruct Scsi_Host *host;\r\nstruct scsi_device *sdev1;\r\nu16 pd_index = 0;\r\nu16 ld_index = 0;\r\nint i, j, doscan = 0;\r\nu32 seq_num;\r\nint error;\r\nif (!instance) {\r\nprintk(KERN_ERR "invalid instance!\n");\r\nkfree(ev);\r\nreturn;\r\n}\r\ninstance->ev = NULL;\r\nhost = instance->host;\r\nif (instance->evt_detail) {\r\nswitch (instance->evt_detail->code) {\r\ncase MR_EVT_PD_INSERTED:\r\nif (megasas_get_pd_list(instance) == 0) {\r\nfor (i = 0; i < MEGASAS_MAX_PD_CHANNELS; i++) {\r\nfor (j = 0;\r\nj < MEGASAS_MAX_DEV_PER_CHANNEL;\r\nj++) {\r\npd_index =\r\n(i * MEGASAS_MAX_DEV_PER_CHANNEL) + j;\r\nsdev1 =\r\nscsi_device_lookup(host, i, j, 0);\r\nif (instance->pd_list[pd_index].driveState\r\n== MR_PD_STATE_SYSTEM) {\r\nif (!sdev1) {\r\nscsi_add_device(host, i, j, 0);\r\n}\r\nif (sdev1)\r\nscsi_device_put(sdev1);\r\n}\r\n}\r\n}\r\n}\r\ndoscan = 0;\r\nbreak;\r\ncase MR_EVT_PD_REMOVED:\r\nif (megasas_get_pd_list(instance) == 0) {\r\nmegasas_get_pd_list(instance);\r\nfor (i = 0; i < MEGASAS_MAX_PD_CHANNELS; i++) {\r\nfor (j = 0;\r\nj < MEGASAS_MAX_DEV_PER_CHANNEL;\r\nj++) {\r\npd_index =\r\n(i * MEGASAS_MAX_DEV_PER_CHANNEL) + j;\r\nsdev1 =\r\nscsi_device_lookup(host, i, j, 0);\r\nif (instance->pd_list[pd_index].driveState\r\n== MR_PD_STATE_SYSTEM) {\r\nif (sdev1) {\r\nscsi_device_put(sdev1);\r\n}\r\n} else {\r\nif (sdev1) {\r\nscsi_remove_device(sdev1);\r\nscsi_device_put(sdev1);\r\n}\r\n}\r\n}\r\n}\r\n}\r\ndoscan = 0;\r\nbreak;\r\ncase MR_EVT_LD_OFFLINE:\r\ncase MR_EVT_CFG_CLEARED:\r\ncase MR_EVT_LD_DELETED:\r\nmegasas_get_ld_list(instance);\r\nfor (i = 0; i < MEGASAS_MAX_LD_CHANNELS; i++) {\r\nfor (j = 0;\r\nj < MEGASAS_MAX_DEV_PER_CHANNEL;\r\nj++) {\r\nld_index =\r\n(i * MEGASAS_MAX_DEV_PER_CHANNEL) + j;\r\nsdev1 = scsi_device_lookup(host,\r\ni + MEGASAS_MAX_LD_CHANNELS,\r\nj,\r\n0);\r\nif (instance->ld_ids[ld_index] != 0xff) {\r\nif (sdev1) {\r\nscsi_device_put(sdev1);\r\n}\r\n} else {\r\nif (sdev1) {\r\nscsi_remove_device(sdev1);\r\nscsi_device_put(sdev1);\r\n}\r\n}\r\n}\r\n}\r\ndoscan = 0;\r\nbreak;\r\ncase MR_EVT_LD_CREATED:\r\nmegasas_get_ld_list(instance);\r\nfor (i = 0; i < MEGASAS_MAX_LD_CHANNELS; i++) {\r\nfor (j = 0;\r\nj < MEGASAS_MAX_DEV_PER_CHANNEL;\r\nj++) {\r\nld_index =\r\n(i * MEGASAS_MAX_DEV_PER_CHANNEL) + j;\r\nsdev1 = scsi_device_lookup(host,\r\ni+MEGASAS_MAX_LD_CHANNELS,\r\nj, 0);\r\nif (instance->ld_ids[ld_index] !=\r\n0xff) {\r\nif (!sdev1) {\r\nscsi_add_device(host,\r\ni + 2,\r\nj, 0);\r\n}\r\n}\r\nif (sdev1) {\r\nscsi_device_put(sdev1);\r\n}\r\n}\r\n}\r\ndoscan = 0;\r\nbreak;\r\ncase MR_EVT_CTRL_HOST_BUS_SCAN_REQUESTED:\r\ncase MR_EVT_FOREIGN_CFG_IMPORTED:\r\ncase MR_EVT_LD_STATE_CHANGE:\r\ndoscan = 1;\r\nbreak;\r\ndefault:\r\ndoscan = 0;\r\nbreak;\r\n}\r\n} else {\r\nprintk(KERN_ERR "invalid evt_detail!\n");\r\nkfree(ev);\r\nreturn;\r\n}\r\nif (doscan) {\r\nprintk(KERN_INFO "scanning ...\n");\r\nmegasas_get_pd_list(instance);\r\nfor (i = 0; i < MEGASAS_MAX_PD_CHANNELS; i++) {\r\nfor (j = 0; j < MEGASAS_MAX_DEV_PER_CHANNEL; j++) {\r\npd_index = i*MEGASAS_MAX_DEV_PER_CHANNEL + j;\r\nsdev1 = scsi_device_lookup(host, i, j, 0);\r\nif (instance->pd_list[pd_index].driveState ==\r\nMR_PD_STATE_SYSTEM) {\r\nif (!sdev1) {\r\nscsi_add_device(host, i, j, 0);\r\n}\r\nif (sdev1)\r\nscsi_device_put(sdev1);\r\n} else {\r\nif (sdev1) {\r\nscsi_remove_device(sdev1);\r\nscsi_device_put(sdev1);\r\n}\r\n}\r\n}\r\n}\r\nmegasas_get_ld_list(instance);\r\nfor (i = 0; i < MEGASAS_MAX_LD_CHANNELS; i++) {\r\nfor (j = 0; j < MEGASAS_MAX_DEV_PER_CHANNEL; j++) {\r\nld_index =\r\n(i * MEGASAS_MAX_DEV_PER_CHANNEL) + j;\r\nsdev1 = scsi_device_lookup(host,\r\ni+MEGASAS_MAX_LD_CHANNELS, j, 0);\r\nif (instance->ld_ids[ld_index] != 0xff) {\r\nif (!sdev1) {\r\nscsi_add_device(host,\r\ni+2,\r\nj, 0);\r\n} else {\r\nscsi_device_put(sdev1);\r\n}\r\n} else {\r\nif (sdev1) {\r\nscsi_remove_device(sdev1);\r\nscsi_device_put(sdev1);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif ( instance->aen_cmd != NULL ) {\r\nkfree(ev);\r\nreturn ;\r\n}\r\nseq_num = instance->evt_detail->seq_num + 1;\r\nclass_locale.members.reserved = 0;\r\nclass_locale.members.locale = MR_EVT_LOCALE_ALL;\r\nclass_locale.members.class = MR_EVT_CLASS_DEBUG;\r\nmutex_lock(&instance->aen_mutex);\r\nerror = megasas_register_aen(instance, seq_num,\r\nclass_locale.word);\r\nmutex_unlock(&instance->aen_mutex);\r\nif (error)\r\nprintk(KERN_ERR "register aen failed error %x\n", error);\r\nkfree(ev);\r\n}\r\nstatic int __init megasas_init(void)\r\n{\r\nint rval;\r\nprintk(KERN_INFO "megasas: %s %s\n", MEGASAS_VERSION,\r\nMEGASAS_EXT_VERSION);\r\nsupport_poll_for_event = 2;\r\nsupport_device_change = 1;\r\nmemset(&megasas_mgmt_info, 0, sizeof(megasas_mgmt_info));\r\nrval = register_chrdev(0, "megaraid_sas_ioctl", &megasas_mgmt_fops);\r\nif (rval < 0) {\r\nprintk(KERN_DEBUG "megasas: failed to open device node\n");\r\nreturn rval;\r\n}\r\nmegasas_mgmt_majorno = rval;\r\nrval = pci_register_driver(&megasas_pci_driver);\r\nif (rval) {\r\nprintk(KERN_DEBUG "megasas: PCI hotplug regisration failed \n");\r\ngoto err_pcidrv;\r\n}\r\nrval = driver_create_file(&megasas_pci_driver.driver,\r\n&driver_attr_version);\r\nif (rval)\r\ngoto err_dcf_attr_ver;\r\nrval = driver_create_file(&megasas_pci_driver.driver,\r\n&driver_attr_release_date);\r\nif (rval)\r\ngoto err_dcf_rel_date;\r\nrval = driver_create_file(&megasas_pci_driver.driver,\r\n&driver_attr_support_poll_for_event);\r\nif (rval)\r\ngoto err_dcf_support_poll_for_event;\r\nrval = driver_create_file(&megasas_pci_driver.driver,\r\n&driver_attr_dbg_lvl);\r\nif (rval)\r\ngoto err_dcf_dbg_lvl;\r\nrval = driver_create_file(&megasas_pci_driver.driver,\r\n&driver_attr_support_device_change);\r\nif (rval)\r\ngoto err_dcf_support_device_change;\r\nreturn rval;\r\nerr_dcf_support_device_change:\r\ndriver_remove_file(&megasas_pci_driver.driver,\r\n&driver_attr_dbg_lvl);\r\nerr_dcf_dbg_lvl:\r\ndriver_remove_file(&megasas_pci_driver.driver,\r\n&driver_attr_support_poll_for_event);\r\nerr_dcf_support_poll_for_event:\r\ndriver_remove_file(&megasas_pci_driver.driver,\r\n&driver_attr_release_date);\r\nerr_dcf_rel_date:\r\ndriver_remove_file(&megasas_pci_driver.driver, &driver_attr_version);\r\nerr_dcf_attr_ver:\r\npci_unregister_driver(&megasas_pci_driver);\r\nerr_pcidrv:\r\nunregister_chrdev(megasas_mgmt_majorno, "megaraid_sas_ioctl");\r\nreturn rval;\r\n}\r\nstatic void __exit megasas_exit(void)\r\n{\r\ndriver_remove_file(&megasas_pci_driver.driver,\r\n&driver_attr_dbg_lvl);\r\ndriver_remove_file(&megasas_pci_driver.driver,\r\n&driver_attr_support_poll_for_event);\r\ndriver_remove_file(&megasas_pci_driver.driver,\r\n&driver_attr_support_device_change);\r\ndriver_remove_file(&megasas_pci_driver.driver,\r\n&driver_attr_release_date);\r\ndriver_remove_file(&megasas_pci_driver.driver, &driver_attr_version);\r\npci_unregister_driver(&megasas_pci_driver);\r\nunregister_chrdev(megasas_mgmt_majorno, "megaraid_sas_ioctl");\r\n}
