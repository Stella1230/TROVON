static char __devinit *adapter_def(char type)\r\n{\r\nswitch (type) {\r\ncase 0xF: return "PC Adapter | PC Adapter II | Adapter/A";\r\ncase 0xE: return "16/4 Adapter | 16/4 Adapter/A (long)";\r\ncase 0xD: return "16/4 Adapter/A (short) | 16/4 ISA-16 Adapter";\r\ncase 0xC: return "Auto 16/4 Adapter";\r\ndefault: return "adapter (unknown type)";\r\n}\r\n}\r\nstatic void __devinit PrtChanID(char *pcid, short stride)\r\n{\r\nshort i, j;\r\nfor (i = 0, j = 0; i < 24; i++, j += stride)\r\nprintk("%1x", ((int) pcid[j]) & 0x0f);\r\nprintk("\n");\r\n}\r\nstatic void __devinit HWPrtChanID(void __iomem *pcid, short stride)\r\n{\r\nshort i, j;\r\nfor (i = 0, j = 0; i < 24; i++, j += stride)\r\nprintk("%1x", ((int) readb(pcid + j)) & 0x0f);\r\nprintk("\n");\r\n}\r\nstatic void __devinit find_turbo_adapters(int *iolist)\r\n{\r\nint ram_addr;\r\nint index=0;\r\nvoid __iomem *chanid;\r\nint found_turbo=0;\r\nunsigned char *tchanid, ctemp;\r\nint i, j;\r\nunsigned long jif;\r\nvoid __iomem *ram_mapped ;\r\nif (turbo_searched == 1) return;\r\nturbo_searched=1;\r\nfor (ram_addr=0xC0000; ram_addr < 0xE0000; ram_addr+=0x2000) {\r\n__u32 intf_tbl=0;\r\nfound_turbo=1;\r\nram_mapped = ioremap((u32)ram_addr,0x1fff) ;\r\nif (ram_mapped==NULL)\r\ncontinue ;\r\nchanid=(CHANNEL_ID + ram_mapped);\r\ntchanid=pcchannelid;\r\nctemp=readb(chanid) & 0x0f;\r\nif (ctemp != *tchanid) continue;\r\nfor (i=2,j=1; i<=46; i=i+2,j++) {\r\nif ((readb(chanid+i) & 0x0f) != tchanid[j]){\r\nfound_turbo=0;\r\nbreak;\r\n}\r\n}\r\nif (!found_turbo) continue;\r\nwriteb(0x90, ram_mapped+0x1E01);\r\nfor(i=2; i<0x0f; i++) {\r\nwriteb(0x00, ram_mapped+0x1E01+i);\r\n}\r\nwriteb(0x00, ram_mapped+0x1E01);\r\nfor(jif=jiffies+TR_BUSY_INTERVAL; time_before_eq(jiffies,jif););\r\nintf_tbl=ntohs(readw(ram_mapped+ACA_OFFSET+ACA_RW+WRBR_EVEN));\r\nif (intf_tbl) {\r\n#if IBMTR_DEBUG_MESSAGES\r\nprintk("ibmtr::find_turbo_adapters, Turbo found at "\r\n"ram_addr %x\n",ram_addr);\r\nprintk("ibmtr::find_turbo_adapters, interface_table ");\r\nfor(i=0; i<6; i++) {\r\nprintk("%x:",readb(ram_addr+intf_tbl+i));\r\n}\r\nprintk("\n");\r\n#endif\r\nturbo_io[index]=ntohs(readw(ram_mapped+intf_tbl+4));\r\nturbo_irq[index]=readb(ram_mapped+intf_tbl+3);\r\noutb(0, turbo_io[index] + ADAPTRESET);\r\nfor(jif=jiffies+TR_RST_TIME;time_before_eq(jiffies,jif););\r\noutb(0, turbo_io[index] + ADAPTRESETREL);\r\nindex++;\r\ncontinue;\r\n}\r\n#if IBMTR_DEBUG_MESSAGES\r\nprintk("ibmtr::find_turbo_adapters, ibmtr card found at"\r\n" %x but not a Turbo model\n",ram_addr);\r\n#endif\r\niounmap(ram_mapped) ;\r\n}\r\nfor(i=0; i<IBMTR_MAX_ADAPTERS; i++) {\r\nif(!turbo_io[i]) break;\r\nfor (j=0; j<IBMTR_MAX_ADAPTERS; j++) {\r\nif ( iolist[j] && iolist[j] != turbo_io[i]) continue;\r\niolist[j]=turbo_io[i];\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void ibmtr_cleanup_card(struct net_device *dev)\r\n{\r\nif (dev->base_addr) {\r\noutb(0,dev->base_addr+ADAPTRESET);\r\nschedule_timeout_uninterruptible(TR_RST_TIME);\r\noutb(0,dev->base_addr+ADAPTRESETREL);\r\n}\r\n#ifndef PCMCIA\r\nfree_irq(dev->irq, dev);\r\nrelease_region(dev->base_addr, IBMTR_IO_EXTENT);\r\n{\r\nstruct tok_info *ti = netdev_priv(dev);\r\niounmap(ti->mmio);\r\niounmap(ti->sram_virt);\r\n}\r\n#endif\r\n}\r\nstatic int __devinit ibmtr_probe(struct net_device *dev)\r\n{\r\nint i;\r\nint base_addr = dev->base_addr;\r\nif (base_addr && base_addr <= 0x1ff)\r\nreturn -ENXIO;\r\nif (base_addr > 0x1ff) {\r\nif (!ibmtr_probe1(dev, base_addr)) return 0;\r\nreturn -ENODEV;\r\n}\r\nfind_turbo_adapters(ibmtr_portlist);\r\nfor (i = 0; ibmtr_portlist[i]; i++) {\r\nint ioaddr = ibmtr_portlist[i];\r\nif (!ibmtr_probe1(dev, ioaddr)) return 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nint __devinit ibmtr_probe_card(struct net_device *dev)\r\n{\r\nint err = ibmtr_probe(dev);\r\nif (!err) {\r\nerr = register_netdev(dev);\r\nif (err)\r\nibmtr_cleanup_card(dev);\r\n}\r\nreturn err;\r\n}\r\nstatic int __devinit ibmtr_probe1(struct net_device *dev, int PIOaddr)\r\n{\r\nunsigned char segment, intr=0, irq=0, i, j, cardpresent=NOTOK, temp=0;\r\nvoid __iomem * t_mmio = NULL;\r\nstruct tok_info *ti = netdev_priv(dev);\r\nvoid __iomem *cd_chanid;\r\nunsigned char *tchanid, ctemp;\r\n#ifndef PCMCIA\r\nunsigned char t_irq=0;\r\nunsigned long timeout;\r\nstatic int version_printed;\r\n#endif\r\nsegment = inb(PIOaddr);\r\nif (segment < 0x40 || segment > 0xe0) {\r\n#if IBMTR_DEBUG_MESSAGES\r\nDPRINTK("ibmtr_probe1(): unhappy that inb(0x%X) == 0x%X, "\r\n"Hardware Problem?\n",PIOaddr,segment);\r\n#endif\r\nreturn -ENODEV;\r\n}\r\nt_mmio = ioremap(((__u32) (segment & 0xfc) << 11) + 0x80000,2048);\r\nif (!t_mmio) {\r\nDPRINTK("Cannot remap mmiobase memory area") ;\r\nreturn -ENODEV ;\r\n}\r\nintr = segment & 0x03;\r\nif (ibmtr_debug_trace & TRC_INIT)\r\nDPRINTK("PIOaddr: %4hx seg/intr: %2x mmio base: %p intr: %d\n"\r\n, PIOaddr, (int) segment, t_mmio, (int) intr);\r\n#ifdef PCMCIA\r\niounmap(t_mmio);\r\nt_mmio = ti->mmio;\r\nirq = ti->irq;\r\n#endif\r\ncd_chanid = (CHANNEL_ID + t_mmio);\r\ntchanid = pcchannelid;\r\ncardpresent = TR_ISA;\r\nctemp = readb(cd_chanid) & 0x0f;\r\nif (ctemp != *tchanid) {\r\ntchanid = mcchannelid;\r\ncardpresent = TR_MCA;\r\nif (ctemp != *tchanid)\r\ncardpresent = NOTOK;\r\n}\r\nif (cardpresent != NOTOK) {\r\nfor (i = 2, j = 1; i <= 46; i = i + 2, j++) {\r\nif( (readb(cd_chanid+i)&0x0f) == tchanid[j]) continue;\r\ncardpresent = NOTOK;\r\nbreak;\r\n}\r\n}\r\nif (cardpresent == TR_ISA && (readb(AIPFID + t_mmio) == 0x0e))\r\ncardpresent = TR_ISAPNP;\r\nif (cardpresent == NOTOK) {\r\nif (!(ibmtr_debug_trace & TRC_INIT)) {\r\n#ifndef PCMCIA\r\niounmap(t_mmio);\r\n#endif\r\nreturn -ENODEV;\r\n}\r\nDPRINTK( "Channel ID string not found for PIOaddr: %4hx\n",\r\nPIOaddr);\r\nDPRINTK("Expected for ISA: ");\r\nPrtChanID(pcchannelid, 1);\r\nDPRINTK(" found: ");\r\nHWPrtChanID(cd_chanid, 2);\r\nDPRINTK("Expected for MCA: ");\r\nPrtChanID(mcchannelid, 1);\r\n}\r\n#ifndef PCMCIA\r\nti->mmio = t_mmio;\r\nfor (i = 0; i < IBMTR_MAX_ADAPTERS; i++) {\r\nif (turbo_io[i] != PIOaddr)\r\ncontinue;\r\n#if IBMTR_DEBUG_MESSAGES\r\nprintk("ibmtr::tr_probe1, setting PIOaddr %x to Turbo\n",\r\nPIOaddr);\r\n#endif\r\nti->turbo = 1;\r\nt_irq = turbo_irq[i];\r\n}\r\n#endif\r\nti->readlog_pending = 0;\r\ninit_waitqueue_head(&ti->wait_for_reset);\r\n#ifndef PCMCIA\r\nswitch (cardpresent) {\r\ncase TR_ISA:\r\nif (intr == 0) irq = 9;\r\nif (intr == 1) irq = 3;\r\nif (intr == 2) irq = 6;\r\nif (intr == 3) irq = 7;\r\nti->adapter_int_enable = PIOaddr + ADAPTINTREL;\r\nbreak;\r\ncase TR_MCA:\r\nif (intr == 0) irq = 9;\r\nif (intr == 1) irq = 3;\r\nif (intr == 2) irq = 10;\r\nif (intr == 3) irq = 11;\r\nti->global_int_enable = 0;\r\nti->adapter_int_enable = 0;\r\nti->sram_phys=(__u32)(inb(PIOaddr+ADAPTRESETREL) & 0xfe) << 12;\r\nbreak;\r\ncase TR_ISAPNP:\r\nif (!t_irq) {\r\nif (intr == 0) irq = 9;\r\nif (intr == 1) irq = 3;\r\nif (intr == 2) irq = 10;\r\nif (intr == 3) irq = 11;\r\n} else\r\nirq=t_irq;\r\ntimeout = jiffies + TR_SPIN_INTERVAL;\r\nwhile (!readb(ti->mmio + ACA_OFFSET + ACA_RW + RRR_EVEN)){\r\nif (!time_after(jiffies, timeout)) continue;\r\nDPRINTK( "Hardware timeout during initialization.\n");\r\niounmap(t_mmio);\r\nreturn -ENODEV;\r\n}\r\nti->sram_phys =\r\n((__u32)readb(ti->mmio+ACA_OFFSET+ACA_RW+RRR_EVEN)<<12);\r\nti->adapter_int_enable = PIOaddr + ADAPTINTREL;\r\nbreak;\r\n}\r\n#endif\r\nif (ibmtr_debug_trace & TRC_INIT) {\r\nDPRINTK("irq=%d", irq);\r\nprintk(", sram_phys=0x%x", ti->sram_phys);\r\nif(ibmtr_debug_trace&TRC_INITV){\r\nDPRINTK(", ti->mmio=%p", ti->mmio);\r\nprintk(", segment=%02X", segment);\r\n}\r\nprintk(".\n");\r\n}\r\nj = 0;\r\nfor (i = 0; i < 0x18; i = i + 2) {\r\ntemp = readb(ti->mmio + AIP + i) & 0x0f;\r\nti->hw_address[j] = temp;\r\nif (j & 1)\r\ndev->dev_addr[(j / 2)] =\r\nti->hw_address[j]+ (ti->hw_address[j - 1] << 4);\r\n++j;\r\n}\r\nti->adapter_type = readb(ti->mmio + AIPADAPTYPE);\r\nti->data_rate = readb(ti->mmio + AIPDATARATE);\r\nti->token_release = readb(ti->mmio + AIPEARLYTOKEN);\r\nif (ti->turbo) {\r\nti->avail_shared_ram=127;\r\n} else {\r\nti->avail_shared_ram = get_sram_size(ti);\r\n}\r\nti->shared_ram_paging = readb(ti->mmio + AIPSHRAMPAGE);\r\nswitch (readb(ti->mmio + AIP4MBDHB)) {\r\ncase 0xe: ti->dhb_size4mb = 4096; break;\r\ncase 0xd: ti->dhb_size4mb = 4464; break;\r\ndefault: ti->dhb_size4mb = 2048; break;\r\n}\r\nswitch (readb(ti->mmio + AIP16MBDHB)) {\r\ncase 0xe: ti->dhb_size16mb = 4096; break;\r\ncase 0xd: ti->dhb_size16mb = 8192; break;\r\ncase 0xc: ti->dhb_size16mb = 16384; break;\r\ncase 0xb: ti->dhb_size16mb = 17960; break;\r\ndefault: ti->dhb_size16mb = 2048; break;\r\n}\r\nti->mapped_ram_size=\r\n1<< ((readb(ti->mmio+ACA_OFFSET+ACA_RW+RRR_ODD) >> 2 & 0x03) + 4);\r\nti->page_mask = 0;\r\nif (ti->turbo) ti->page_mask=0xf0;\r\nelse if (ti->shared_ram_paging == 0xf);\r\nelse {\r\n#ifdef ENABLE_PAGING\r\nunsigned char pg_size = 0;\r\nswitch (ti->shared_ram_paging) {\r\ncase 0xf:\r\nbreak;\r\ncase 0xe:\r\nti->page_mask = (ti->mapped_ram_size == 32) ? 0xc0 : 0;\r\npg_size = 32;\r\nbreak;\r\ncase 0xd:\r\nti->page_mask = (ti->mapped_ram_size == 64) ? 0x80 : 0;\r\npg_size = 64;\r\nbreak;\r\ncase 0xc:\r\nswitch (ti->mapped_ram_size) {\r\ncase 32:\r\nti->page_mask = 0xc0;\r\npg_size = 32;\r\nbreak;\r\ncase 64:\r\nti->page_mask = 0x80;\r\npg_size = 64;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nDPRINTK("Unknown shared ram paging info %01X\n",\r\nti->shared_ram_paging);\r\niounmap(t_mmio);\r\nreturn -ENODEV;\r\nbreak;\r\n}\r\nif (ibmtr_debug_trace & TRC_INIT)\r\nDPRINTK("Shared RAM paging code: %02X, "\r\n"mapped RAM size: %dK, shared RAM size: %dK, "\r\n"page mask: %02X\n:",\r\nti->shared_ram_paging, ti->mapped_ram_size / 2,\r\nti->avail_shared_ram / 2, ti->page_mask);\r\n#endif\r\n}\r\n#ifndef PCMCIA\r\nif (cardpresent == TR_ISA) {\r\nstatic const __u32 ram_bndry_mask[] = {\r\n0xffffe000, 0xffffc000, 0xffff8000, 0xffff0000\r\n};\r\n__u32 new_base, rrr_32, chk_base, rbm;\r\nrrr_32=readb(ti->mmio+ACA_OFFSET+ACA_RW+RRR_ODD) >> 2 & 0x03;\r\nrbm = ram_bndry_mask[rrr_32];\r\nnew_base = (ibmtr_mem_base + (~rbm)) & rbm;\r\nchk_base = new_base + (ti->mapped_ram_size << 9);\r\nif (chk_base > (ibmtr_mem_base + IBMTR_SHARED_RAM_SIZE)) {\r\nDPRINTK("Shared RAM for this adapter (%05x) exceeds "\r\n"driver limit (%05x), adapter not started.\n",\r\nchk_base, ibmtr_mem_base + IBMTR_SHARED_RAM_SIZE);\r\niounmap(t_mmio);\r\nreturn -ENODEV;\r\n} else {\r\nti->sram_base = new_base >> 12;\r\nibmtr_mem_base = chk_base;\r\n}\r\n}\r\nelse ti->sram_base = ti->sram_phys >> 12;\r\nif (request_irq(dev->irq = irq, tok_interrupt, 0, "ibmtr", dev) != 0) {\r\nDPRINTK("Could not grab irq %d. Halting Token Ring driver.\n",\r\nirq);\r\niounmap(t_mmio);\r\nreturn -ENODEV;\r\n}\r\nif (!request_region(PIOaddr, IBMTR_IO_EXTENT, "ibmtr")) {\r\nDPRINTK("Could not grab PIO range. Halting driver.\n");\r\nfree_irq(dev->irq, dev);\r\niounmap(t_mmio);\r\nreturn -EBUSY;\r\n}\r\nif (!version_printed++) {\r\nprintk(version);\r\n}\r\n#endif\r\nDPRINTK("%s %s found\n",\r\nchannel_def[cardpresent - 1], adapter_def(ti->adapter_type));\r\nDPRINTK("using irq %d, PIOaddr %hx, %dK shared RAM.\n",\r\nirq, PIOaddr, ti->mapped_ram_size / 2);\r\nDPRINTK("Hardware address : %pM\n", dev->dev_addr);\r\nif (ti->page_mask)\r\nDPRINTK("Shared RAM paging enabled. "\r\n"Page size: %uK Shared Ram size %dK\n",\r\n((ti->page_mask^0xff)+1) >>2, ti->avail_shared_ram / 2);\r\nelse\r\nDPRINTK("Shared RAM paging disabled. ti->page_mask %x\n",\r\nti->page_mask);\r\nif (!ti->page_mask) {\r\nti->avail_shared_ram=\r\nmin(ti->mapped_ram_size,ti->avail_shared_ram);\r\n}\r\nswitch (ti->avail_shared_ram) {\r\ncase 16:\r\nti->dhb_size4mb = min(ti->dhb_size4mb, (unsigned short)2048);\r\nti->rbuf_len4 = 1032;\r\nti->rbuf_cnt4=2;\r\nti->dhb_size16mb = min(ti->dhb_size16mb, (unsigned short)2048);\r\nti->rbuf_len16 = 1032;\r\nti->rbuf_cnt16=2;\r\nbreak;\r\ncase 32:\r\nti->dhb_size4mb = min(ti->dhb_size4mb, (unsigned short)4464);\r\nti->rbuf_len4 = 1032;\r\nti->rbuf_cnt4=4;\r\nti->dhb_size16mb = min(ti->dhb_size16mb, (unsigned short)4096);\r\nti->rbuf_len16 = 1032;\r\nti->rbuf_cnt16=4;\r\nbreak;\r\ncase 64:\r\nti->dhb_size4mb = min(ti->dhb_size4mb, (unsigned short)4464);\r\nti->rbuf_len4 = 1032;\r\nti->rbuf_cnt4=6;\r\nti->dhb_size16mb = min(ti->dhb_size16mb, (unsigned short)10240);\r\nti->rbuf_len16 = 1032;\r\nti->rbuf_cnt16=6;\r\nbreak;\r\ncase 127:\r\nti->dhb_size4mb = min(ti->dhb_size4mb, (unsigned short)4464);\r\nti->rbuf_len4 = 1032;\r\nti->rbuf_cnt4=6;\r\nti->dhb_size16mb = min(ti->dhb_size16mb, (unsigned short)16384);\r\nti->rbuf_len16 = 1032;\r\nti->rbuf_cnt16=16;\r\nbreak;\r\ncase 128:\r\nti->dhb_size4mb = min(ti->dhb_size4mb, (unsigned short)4464);\r\nti->rbuf_len4 = 1032;\r\nti->rbuf_cnt4=6;\r\nti->dhb_size16mb = min(ti->dhb_size16mb, (unsigned short)17960);\r\nti->rbuf_len16 = 1032;\r\nti->rbuf_cnt16=16;\r\nbreak;\r\ndefault:\r\nti->dhb_size4mb = 2048;\r\nti->rbuf_len4 = 1032;\r\nti->rbuf_cnt4=2;\r\nti->dhb_size16mb = 2048;\r\nti->rbuf_len16 = 1032;\r\nti->rbuf_cnt16=2;\r\nbreak;\r\n}\r\nti->maxmtu16 = (ti->rbuf_len16 - 8) * ti->rbuf_cnt16 - TR_HLEN;\r\nti->maxmtu4 = (ti->rbuf_len4 - 8) * ti->rbuf_cnt4 - TR_HLEN;\r\nDPRINTK("Maximum Receive Internet Protocol MTU 16Mbps: %d, 4Mbps: %d\n",\r\nti->maxmtu16, ti->maxmtu4);\r\ndev->base_addr = PIOaddr;\r\ndev->mem_start = ti->sram_base << 12;\r\ndev->mem_end = dev->mem_start + (ti->mapped_ram_size << 9) - 1;\r\ntrdev_init(dev);\r\nreturn 0;\r\n}\r\nstatic unsigned char __devinit get_sram_size(struct tok_info *adapt_info)\r\n{\r\nunsigned char avail_sram_code;\r\nstatic unsigned char size_code[] = { 0, 16, 32, 64, 127, 128 };\r\navail_sram_code = 0xf - readb(adapt_info->mmio + AIPAVAILSHRAM);\r\nif (avail_sram_code) return size_code[avail_sram_code];\r\nelse\r\nreturn 1 <<\r\n((readb(adapt_info->mmio+ACA_OFFSET+ACA_RW+RRR_ODD)>>2&3)+4);\r\n}\r\nstatic int __devinit trdev_init(struct net_device *dev)\r\n{\r\nstruct tok_info *ti = netdev_priv(dev);\r\nSET_PAGE(ti->srb_page);\r\nti->open_failure = NO ;\r\ndev->netdev_ops = &trdev_netdev_ops;\r\nreturn 0;\r\n}\r\nstatic int tok_init_card(struct net_device *dev)\r\n{\r\nstruct tok_info *ti;\r\nshort PIOaddr;\r\nunsigned long i;\r\nPIOaddr = dev->base_addr;\r\nti = netdev_priv(dev);\r\nti->do_tok_int = FIRST_INT;\r\nwriteb(~INT_ENABLE, ti->mmio + ACA_OFFSET + ACA_RESET + ISRP_EVEN);\r\noutb(0, PIOaddr + ADAPTRESET);\r\nschedule_timeout_uninterruptible(TR_RST_TIME);\r\noutb(0, PIOaddr + ADAPTRESETREL);\r\n#ifdef ENABLE_PAGING\r\nif (ti->page_mask)\r\nwriteb(SRPR_ENABLE_PAGING,ti->mmio+ACA_OFFSET+ACA_RW+SRPR_EVEN);\r\n#endif\r\nwriteb(INT_ENABLE, ti->mmio + ACA_OFFSET + ACA_SET + ISRP_EVEN);\r\ni = sleep_on_timeout(&ti->wait_for_reset, 4 * HZ);\r\nreturn i? 0 : -EAGAIN;\r\n}\r\nstatic int tok_open(struct net_device *dev)\r\n{\r\nstruct tok_info *ti = netdev_priv(dev);\r\nint i;\r\nif (ti->open_failure == YES) {\r\nDPRINTK("Last time you were disconnected, how about now?\n");\r\nprintk("You can't insert with an ICS connector half-cocked.\n");\r\n}\r\nti->open_status = CLOSED;\r\nti->sap_status = CLOSED;\r\nti->open_failure = NO;\r\nti->open_mode = MANUAL;\r\nti->sram_phys &= ~1;\r\nspin_lock_init(&ti->lock);\r\ninit_timer(&ti->tr_timer);\r\ni = tok_init_card(dev);\r\nif (i) return i;\r\nwhile (1){\r\ntok_open_adapter((unsigned long) dev);\r\ni= interruptible_sleep_on_timeout(&ti->wait_for_reset, 25 * HZ);\r\nif (i>(245*HZ)/10) break;\r\nif (i==0) break;\r\nif (ti->open_status == OPEN && ti->sap_status==OPEN) {\r\nnetif_start_queue(dev);\r\nDPRINTK("Adapter is up and running\n");\r\nreturn 0;\r\n}\r\ni=schedule_timeout_interruptible(TR_RETRY_INTERVAL);\r\nif(i!=0) break;\r\n}\r\noutb(0, dev->base_addr + ADAPTRESET);\r\nDPRINTK("TERMINATED via signal\n");\r\nreturn -EAGAIN;\r\n}\r\nstatic void tok_open_adapter(unsigned long dev_addr)\r\n{\r\nstruct net_device *dev = (struct net_device *) dev_addr;\r\nstruct tok_info *ti;\r\nint i;\r\nti = netdev_priv(dev);\r\nSET_PAGE(ti->init_srb_page);\r\nwriteb(~SRB_RESP_INT, ti->mmio + ACA_OFFSET + ACA_RESET + ISRP_ODD);\r\nfor (i = 0; i < sizeof(struct dir_open_adapter); i++)\r\nwriteb(0, ti->init_srb + i);\r\nwriteb(DIR_OPEN_ADAPTER, ti->init_srb + COMMAND_OFST);\r\nwritew(htons(OPEN_PASS_BCON_MAC), ti->init_srb + OPEN_OPTIONS_OFST);\r\nif (ti->ring_speed == 16) {\r\nwritew(htons(ti->dhb_size16mb), ti->init_srb + DHB_LENGTH_OFST);\r\nwritew(htons(ti->rbuf_cnt16), ti->init_srb + NUM_RCV_BUF_OFST);\r\nwritew(htons(ti->rbuf_len16), ti->init_srb + RCV_BUF_LEN_OFST);\r\n} else {\r\nwritew(htons(ti->dhb_size4mb), ti->init_srb + DHB_LENGTH_OFST);\r\nwritew(htons(ti->rbuf_cnt4), ti->init_srb + NUM_RCV_BUF_OFST);\r\nwritew(htons(ti->rbuf_len4), ti->init_srb + RCV_BUF_LEN_OFST);\r\n}\r\nwriteb(NUM_DHB, ti->init_srb + NUM_DHB_OFST);\r\nwriteb(DLC_MAX_SAP, ti->init_srb + DLC_MAX_SAP_OFST);\r\nwriteb(DLC_MAX_STA, ti->init_srb + DLC_MAX_STA_OFST);\r\nti->srb = ti->init_srb;\r\nti->srb_page = ti->init_srb_page;\r\nDPRINTK("Opening adapter: Xmit bfrs: %d X %d, Rcv bfrs: %d X %d\n",\r\nreadb(ti->init_srb + NUM_DHB_OFST),\r\nntohs(readw(ti->init_srb + DHB_LENGTH_OFST)),\r\nntohs(readw(ti->init_srb + NUM_RCV_BUF_OFST)),\r\nntohs(readw(ti->init_srb + RCV_BUF_LEN_OFST)));\r\nwriteb(INT_ENABLE, ti->mmio + ACA_OFFSET + ACA_SET + ISRP_EVEN);\r\nwriteb(CMD_IN_SRB, ti->mmio + ACA_OFFSET + ACA_SET + ISRA_ODD);\r\n}\r\nstatic void open_sap(unsigned char type, struct net_device *dev)\r\n{\r\nint i;\r\nstruct tok_info *ti = netdev_priv(dev);\r\nSET_PAGE(ti->srb_page);\r\nfor (i = 0; i < sizeof(struct dlc_open_sap); i++)\r\nwriteb(0, ti->srb + i);\r\n#define MAX_I_FIELD_OFST 14\r\n#define SAP_VALUE_OFST 16\r\n#define SAP_OPTIONS_OFST 17\r\n#define STATION_COUNT_OFST 18\r\nwriteb(DLC_OPEN_SAP, ti->srb + COMMAND_OFST);\r\nwritew(htons(MAX_I_FIELD), ti->srb + MAX_I_FIELD_OFST);\r\nwriteb(SAP_OPEN_IND_SAP | SAP_OPEN_PRIORITY, ti->srb+ SAP_OPTIONS_OFST);\r\nwriteb(SAP_OPEN_STATION_CNT, ti->srb + STATION_COUNT_OFST);\r\nwriteb(type, ti->srb + SAP_VALUE_OFST);\r\nwriteb(CMD_IN_SRB, ti->mmio + ACA_OFFSET + ACA_SET + ISRA_ODD);\r\n}\r\nstatic void tok_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct tok_info *ti = netdev_priv(dev);\r\nstruct netdev_hw_addr *ha;\r\nunsigned char address[4];\r\nint i;\r\nif ( ti->open_status != OPEN) return;\r\naddress[0] = address[1] = address[2] = address[3] = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\naddress[0] |= ha->addr[2];\r\naddress[1] |= ha->addr[3];\r\naddress[2] |= ha->addr[4];\r\naddress[3] |= ha->addr[5];\r\n}\r\nSET_PAGE(ti->srb_page);\r\nfor (i = 0; i < sizeof(struct srb_set_funct_addr); i++)\r\nwriteb(0, ti->srb + i);\r\n#define FUNCT_ADDRESS_OFST 6\r\nwriteb(DIR_SET_FUNC_ADDR, ti->srb + COMMAND_OFST);\r\nfor (i = 0; i < 4; i++)\r\nwriteb(address[i], ti->srb + FUNCT_ADDRESS_OFST + i);\r\nwriteb(CMD_IN_SRB, ti->mmio + ACA_OFFSET + ACA_SET + ISRA_ODD);\r\n#if TR_VERBOSE\r\nDPRINTK("Setting functional address: ");\r\nfor (i=0;i<4;i++) printk("%02X ", address[i]);\r\nprintk("\n");\r\n#endif\r\n}\r\nstatic netdev_tx_t tok_send_packet(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct tok_info *ti;\r\nunsigned long flags;\r\nti = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nspin_lock_irqsave(&(ti->lock), flags);\r\nti->current_skb = skb;\r\nSET_PAGE(ti->srb_page);\r\nwriteb(XMIT_UI_FRAME, ti->srb + COMMAND_OFST);\r\nwritew(ti->exsap_station_id, ti->srb + STATION_ID_OFST);\r\nwriteb(CMD_IN_SRB, ti->mmio + ACA_OFFSET + ACA_SET + ISRA_ODD);\r\nspin_unlock_irqrestore(&(ti->lock), flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int tok_close(struct net_device *dev)\r\n{\r\nstruct tok_info *ti = netdev_priv(dev);\r\ndel_timer_sync(&ti->tr_timer);\r\noutb(0, dev->base_addr + ADAPTRESET);\r\nti->sram_phys |= 1;\r\nti->open_status = CLOSED;\r\nnetif_stop_queue(dev);\r\nDPRINTK("Adapter is closed.\n");\r\nreturn 0;\r\n}\r\nstatic void __iomem *map_address(struct tok_info *ti, unsigned index, __u8 *page)\r\n{\r\nif (ti->page_mask) {\r\n*page = (index >> 8) & ti->page_mask;\r\nindex &= ~(ti->page_mask << 8);\r\n}\r\nreturn ti->sram_virt + index;\r\n}\r\nstatic void dir_open_adapter (struct net_device *dev)\r\n{\r\nstruct tok_info *ti = netdev_priv(dev);\r\nunsigned char ret_code;\r\n__u16 err;\r\nti->srb = map_address(ti,\r\nntohs(readw(ti->init_srb + SRB_ADDRESS_OFST)),\r\n&ti->srb_page);\r\nti->ssb = map_address(ti,\r\nntohs(readw(ti->init_srb + SSB_ADDRESS_OFST)),\r\n&ti->ssb_page);\r\nti->arb = map_address(ti,\r\nntohs(readw(ti->init_srb + ARB_ADDRESS_OFST)),\r\n&ti->arb_page);\r\nti->asb = map_address(ti,\r\nntohs(readw(ti->init_srb + ASB_ADDRESS_OFST)),\r\n&ti->asb_page);\r\nti->current_skb = NULL;\r\nret_code = readb(ti->init_srb + RETCODE_OFST);\r\nerr = ntohs(readw(ti->init_srb + OPEN_ERROR_CODE_OFST));\r\nif (!ret_code) {\r\nti->open_status = OPEN;\r\nif (ti->open_mode == AUTOMATIC) {\r\nDPRINTK("Adapter reopened.\n");\r\n}\r\nwriteb(~SRB_RESP_INT, ti->mmio+ACA_OFFSET+ACA_RESET+ISRP_ODD);\r\nopen_sap(EXTENDED_SAP, dev);\r\nreturn;\r\n}\r\nti->open_failure = YES;\r\nif (ret_code == 7){\r\nif (err == 0x24) {\r\nif (!ti->auto_speedsave) {\r\nDPRINTK("Open failed: Adapter speed must match "\r\n"ring speed if Automatic Ring Speed Save is "\r\n"disabled.\n");\r\nti->open_action = FAIL;\r\n}else\r\nDPRINTK("Retrying open to adjust to "\r\n"ring speed, ");\r\n} else if (err == 0x2d) {\r\nDPRINTK("Physical Insertion: No Monitor Detected, ");\r\nprintk("retrying after %ds delay...\n",\r\nTR_RETRY_INTERVAL/HZ);\r\n} else if (err == 0x11) {\r\nDPRINTK("Lobe Media Function Failure (0x11), ");\r\nprintk(" retrying after %ds delay...\n",\r\nTR_RETRY_INTERVAL/HZ);\r\n} else {\r\nchar **prphase = printphase;\r\nchar **prerror = printerror;\r\nint pnr = err / 16 - 1;\r\nint enr = err % 16 - 1;\r\nDPRINTK("TR Adapter misc open failure, error code = ");\r\nif (pnr < 0 || pnr >= ARRAY_SIZE(printphase) ||\r\nenr < 0 ||\r\nenr >= ARRAY_SIZE(printerror))\r\nprintk("0x%x, invalid Phase/Error.", err);\r\nelse\r\nprintk("0x%x, Phase: %s, Error: %s\n", err,\r\nprphase[pnr], prerror[enr]);\r\nprintk(" retrying after %ds delay...\n",\r\nTR_RETRY_INTERVAL/HZ);\r\n}\r\n} else DPRINTK("open failed: ret_code = %02X..., ", ret_code);\r\nif (ti->open_action != FAIL) {\r\nif (ti->open_mode==AUTOMATIC){\r\nti->open_action = REOPEN;\r\nibmtr_reset_timer(&(ti->tr_timer), dev);\r\nreturn;\r\n}\r\nwake_up(&ti->wait_for_reset);\r\nreturn;\r\n}\r\nDPRINTK("FAILURE, CAPUT\n");\r\n}\r\nstatic irqreturn_t tok_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned char status;\r\nstruct tok_info *ti;\r\nstruct net_device *dev;\r\n#ifdef ENABLE_PAGING\r\nunsigned char save_srpr;\r\n#endif\r\ndev = dev_id;\r\n#if TR_VERBOSE\r\nDPRINTK("Int from tok_driver, dev : %p irq%d\n", dev,irq);\r\n#endif\r\nti = netdev_priv(dev);\r\nif (ti->sram_phys & 1)\r\nreturn IRQ_NONE;\r\nspin_lock(&(ti->lock));\r\n#ifdef ENABLE_PAGING\r\nsave_srpr = readb(ti->mmio + ACA_OFFSET + ACA_RW + SRPR_EVEN);\r\n#endif\r\nwriteb((~INT_ENABLE), ti->mmio + ACA_OFFSET + ACA_RESET + ISRP_EVEN);\r\nif (ti->adapter_int_enable)\r\noutb(0, ti->adapter_int_enable);\r\nelse\r\noutb(0, ti->global_int_enable);\r\nif (ti->do_tok_int == FIRST_INT){\r\ninitial_tok_int(dev);\r\n#ifdef ENABLE_PAGING\r\nwriteb(save_srpr, ti->mmio + ACA_OFFSET + ACA_RW + SRPR_EVEN);\r\n#endif\r\nspin_unlock(&(ti->lock));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatus = readb(ti->mmio + ACA_OFFSET + ACA_RW + ISRP_ODD);\r\nif (status & ADAP_CHK_INT) {\r\nint i;\r\nvoid __iomem *check_reason;\r\n__u8 check_reason_page = 0;\r\ncheck_reason = map_address(ti,\r\nntohs(readw(ti->mmio+ ACA_OFFSET+ACA_RW + WWCR_EVEN)),\r\n&check_reason_page);\r\nSET_PAGE(check_reason_page);\r\nDPRINTK("Adapter check interrupt\n");\r\nDPRINTK("8 reason bytes follow: ");\r\nfor (i = 0; i < 8; i++, check_reason++)\r\nprintk("%02X ", (int) readb(check_reason));\r\nprintk("\n");\r\nwriteb(~ADAP_CHK_INT, ti->mmio+ ACA_OFFSET+ACA_RESET+ ISRP_ODD);\r\nstatus = readb(ti->mmio + ACA_OFFSET + ACA_RW + ISRA_EVEN);\r\nDPRINTK("ISRA_EVEN == 0x02%x\n",status);\r\nti->open_status = CLOSED;\r\nti->sap_status = CLOSED;\r\nti->open_mode = AUTOMATIC;\r\nnetif_carrier_off(dev);\r\nnetif_stop_queue(dev);\r\nti->open_action = RESTART;\r\noutb(0, dev->base_addr + ADAPTRESET);\r\nibmtr_reset_timer(&(ti->tr_timer), dev);\r\nspin_unlock(&(ti->lock));\r\nreturn IRQ_HANDLED;\r\n}\r\nif (readb(ti->mmio + ACA_OFFSET + ACA_RW + ISRP_EVEN)\r\n& (TCR_INT | ERR_INT | ACCESS_INT)) {\r\nDPRINTK("adapter error: ISRP_EVEN : %02x\n",\r\n(int)readb(ti->mmio+ ACA_OFFSET + ACA_RW + ISRP_EVEN));\r\nwriteb(~(TCR_INT | ERR_INT | ACCESS_INT),\r\nti->mmio + ACA_OFFSET + ACA_RESET + ISRP_EVEN);\r\nstatus= readb(ti->mmio+ ACA_OFFSET + ACA_RW + ISRA_EVEN);\r\nDPRINTK("ISRA_EVEN == 0x02%x\n",status);\r\nwriteb(INT_ENABLE, ti->mmio + ACA_OFFSET + ACA_SET + ISRP_EVEN);\r\n#ifdef ENABLE_PAGING\r\nwriteb(save_srpr, ti->mmio + ACA_OFFSET + ACA_RW + SRPR_EVEN);\r\n#endif\r\nspin_unlock(&(ti->lock));\r\nreturn IRQ_HANDLED;\r\n}\r\nif (status & SRB_RESP_INT) {\r\nSET_PAGE(ti->srb_page);\r\n#if TR_VERBOSE\r\nDPRINTK("SRB resp: cmd=%02X rsp=%02X\n",\r\nreadb(ti->srb), readb(ti->srb + RETCODE_OFST));\r\n#endif\r\nswitch (readb(ti->srb)) {\r\ncase XMIT_DIR_FRAME:{\r\nunsigned char xmit_ret_code;\r\nxmit_ret_code = readb(ti->srb + RETCODE_OFST);\r\nif (xmit_ret_code == 0xff) break;\r\nDPRINTK("error on xmit_dir_frame request: %02X\n",\r\nxmit_ret_code);\r\nif (ti->current_skb) {\r\ndev_kfree_skb_irq(ti->current_skb);\r\nti->current_skb = NULL;\r\n}\r\nnetif_wake_queue(dev);\r\nif (ti->readlog_pending)\r\nibmtr_readlog(dev);\r\nbreak;\r\n}\r\ncase XMIT_UI_FRAME:{\r\nunsigned char xmit_ret_code;\r\nxmit_ret_code = readb(ti->srb + RETCODE_OFST);\r\nif (xmit_ret_code == 0xff) break;\r\nDPRINTK("error on xmit_ui_frame request: %02X\n",\r\nxmit_ret_code);\r\nif (ti->current_skb) {\r\ndev_kfree_skb_irq(ti->current_skb);\r\nti->current_skb = NULL;\r\n}\r\nnetif_wake_queue(dev);\r\nif (ti->readlog_pending)\r\nibmtr_readlog(dev);\r\nbreak;\r\n}\r\ncase DIR_OPEN_ADAPTER:\r\ndir_open_adapter(dev);\r\nbreak;\r\ncase DLC_OPEN_SAP:\r\nif (readb(ti->srb + RETCODE_OFST)) {\r\nDPRINTK("open_sap failed: ret_code = %02X, "\r\n"retrying\n",\r\n(int) readb(ti->srb + RETCODE_OFST));\r\nti->open_action = REOPEN;\r\nibmtr_reset_timer(&(ti->tr_timer), dev);\r\nbreak;\r\n}\r\nti->exsap_station_id = readw(ti->srb + STATION_ID_OFST);\r\nti->sap_status = OPEN;\r\nif (ti->open_mode==MANUAL){\r\nwake_up(&ti->wait_for_reset);\r\nbreak;\r\n}\r\nnetif_wake_queue(dev);\r\nnetif_carrier_on(dev);\r\nbreak;\r\ncase DIR_INTERRUPT:\r\ncase DIR_MOD_OPEN_PARAMS:\r\ncase DIR_SET_GRP_ADDR:\r\ncase DIR_SET_FUNC_ADDR:\r\ncase DLC_CLOSE_SAP:\r\nif (readb(ti->srb + RETCODE_OFST))\r\nDPRINTK("error on %02X: %02X\n",\r\n(int) readb(ti->srb + COMMAND_OFST),\r\n(int) readb(ti->srb + RETCODE_OFST));\r\nbreak;\r\ncase DIR_READ_LOG:\r\nif (readb(ti->srb + RETCODE_OFST)){\r\nDPRINTK("error on dir_read_log: %02X\n",\r\n(int) readb(ti->srb + RETCODE_OFST));\r\nnetif_wake_queue(dev);\r\nbreak;\r\n}\r\n#if IBMTR_DEBUG_MESSAGES\r\n#define LINE_ERRORS_OFST 0\r\n#define INTERNAL_ERRORS_OFST 1\r\n#define BURST_ERRORS_OFST 2\r\n#define AC_ERRORS_OFST 3\r\n#define ABORT_DELIMITERS_OFST 4\r\n#define LOST_FRAMES_OFST 6\r\n#define RECV_CONGEST_COUNT_OFST 7\r\n#define FRAME_COPIED_ERRORS_OFST 8\r\n#define FREQUENCY_ERRORS_OFST 9\r\n#define TOKEN_ERRORS_OFST 10\r\nDPRINTK("Line errors %02X, Internal errors %02X, "\r\n"Burst errors %02X\n" "A/C errors %02X, "\r\n"Abort delimiters %02X, Lost frames %02X\n"\r\n"Receive congestion count %02X, "\r\n"Frame copied errors %02X\nFrequency errors %02X, "\r\n"Token errors %02X\n",\r\n(int) readb(ti->srb + LINE_ERRORS_OFST),\r\n(int) readb(ti->srb + INTERNAL_ERRORS_OFST),\r\n(int) readb(ti->srb + BURST_ERRORS_OFST),\r\n(int) readb(ti->srb + AC_ERRORS_OFST),\r\n(int) readb(ti->srb + ABORT_DELIMITERS_OFST),\r\n(int) readb(ti->srb + LOST_FRAMES_OFST),\r\n(int) readb(ti->srb + RECV_CONGEST_COUNT_OFST),\r\n(int) readb(ti->srb + FRAME_COPIED_ERRORS_OFST),\r\n(int) readb(ti->srb + FREQUENCY_ERRORS_OFST),\r\n(int) readb(ti->srb + TOKEN_ERRORS_OFST));\r\n#endif\r\nnetif_wake_queue(dev);\r\nbreak;\r\ndefault:\r\nDPRINTK("Unknown command %02X encountered\n",\r\n(int) readb(ti->srb));\r\n}\r\nwriteb(~SRB_RESP_INT, ti->mmio+ ACA_OFFSET+ACA_RESET+ ISRP_ODD);\r\n}\r\nif (status & ASB_FREE_INT) {\r\nSET_PAGE(ti->asb_page);\r\n#if TR_VERBOSE\r\nDPRINTK("ASB resp: cmd=%02X\n", readb(ti->asb));\r\n#endif\r\nswitch (readb(ti->asb)) {\r\ncase REC_DATA:\r\ncase XMIT_UI_FRAME:\r\ncase XMIT_DIR_FRAME:\r\nbreak;\r\ndefault:\r\nDPRINTK("unknown command in asb %02X\n",\r\n(int) readb(ti->asb));\r\n}\r\nif (readb(ti->asb + 2) != 0xff)\r\nDPRINTK("ASB error %02X in cmd %02X\n",\r\n(int) readb(ti->asb + 2), (int) readb(ti->asb));\r\nwriteb(~ASB_FREE_INT, ti->mmio+ ACA_OFFSET+ACA_RESET+ ISRP_ODD);\r\n}\r\n#define STATUS_OFST 6\r\n#define NETW_STATUS_OFST 6\r\nif (status & ARB_CMD_INT) {\r\nSET_PAGE(ti->arb_page);\r\n#if TR_VERBOSE\r\nDPRINTK("ARB resp: cmd=%02X\n", readb(ti->arb));\r\n#endif\r\nswitch (readb(ti->arb)) {\r\ncase DLC_STATUS:\r\nDPRINTK("DLC_STATUS new status: %02X on station %02X\n",\r\nntohs(readw(ti->arb + STATUS_OFST)),\r\nntohs(readw(ti->arb+ STATION_ID_OFST)));\r\nbreak;\r\ncase REC_DATA:\r\ntr_rx(dev);\r\nbreak;\r\ncase RING_STAT_CHANGE:{\r\nunsigned short ring_status;\r\nring_status= ntohs(readw(ti->arb + NETW_STATUS_OFST));\r\nif (ibmtr_debug_trace & TRC_INIT)\r\nDPRINTK("Ring Status Change...(0x%x)\n",\r\nring_status);\r\nif(ring_status& (REMOVE_RECV|AUTO_REMOVAL|LOBE_FAULT)){\r\nnetif_stop_queue(dev);\r\nnetif_carrier_off(dev);\r\nDPRINTK("Remove received, or Auto-removal error"\r\n", or Lobe fault\n");\r\nDPRINTK("We'll try to reopen the closed adapter"\r\n" after a %d second delay.\n",\r\nTR_RETRY_INTERVAL/HZ);\r\nti->open_mode = AUTOMATIC;\r\nti->open_status = CLOSED;\r\nti->open_action = REOPEN;\r\nibmtr_reset_timer(&(ti->tr_timer), dev);\r\n} else if (ring_status & LOG_OVERFLOW) {\r\nif(netif_queue_stopped(dev))\r\nti->readlog_pending = 1;\r\nelse\r\nibmtr_readlog(dev);\r\n}\r\nbreak;\r\n}\r\ncase XMIT_DATA_REQ:\r\ntr_tx(dev);\r\nbreak;\r\ndefault:\r\nDPRINTK("Unknown command %02X in arb\n",\r\n(int) readb(ti->arb));\r\nbreak;\r\n}\r\nwriteb(~ARB_CMD_INT, ti->mmio+ ACA_OFFSET+ACA_RESET + ISRP_ODD);\r\nwriteb(ARB_FREE, ti->mmio + ACA_OFFSET + ACA_SET + ISRA_ODD);\r\n}\r\nif (status & SSB_RESP_INT) {\r\nunsigned char retcode;\r\nSET_PAGE(ti->ssb_page);\r\n#if TR_VERBOSE\r\nDPRINTK("SSB resp: cmd=%02X rsp=%02X\n",\r\nreadb(ti->ssb), readb(ti->ssb + 2));\r\n#endif\r\nswitch (readb(ti->ssb)) {\r\ncase XMIT_DIR_FRAME:\r\ncase XMIT_UI_FRAME:\r\nretcode = readb(ti->ssb + 2);\r\nif (retcode && (retcode != 0x22))\r\nDPRINTK("xmit ret_code: %02X xmit error code: "\r\n"%02X\n",\r\n(int)retcode, (int)readb(ti->ssb + 6));\r\nelse\r\ndev->stats.tx_packets++;\r\nbreak;\r\ncase XMIT_XID_CMD:\r\nDPRINTK("xmit xid ret_code: %02X\n",\r\n(int) readb(ti->ssb + 2));\r\ndefault:\r\nDPRINTK("Unknown command %02X in ssb\n",\r\n(int) readb(ti->ssb));\r\n}\r\nwriteb(~SSB_RESP_INT, ti->mmio+ ACA_OFFSET+ACA_RESET+ ISRP_ODD);\r\nwriteb(SSB_FREE, ti->mmio + ACA_OFFSET + ACA_SET + ISRA_ODD);\r\n}\r\n#ifdef ENABLE_PAGING\r\nwriteb(save_srpr, ti->mmio + ACA_OFFSET + ACA_RW + SRPR_EVEN);\r\n#endif\r\nwriteb(INT_ENABLE, ti->mmio + ACA_OFFSET + ACA_SET + ISRP_EVEN);\r\nspin_unlock(&(ti->lock));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void initial_tok_int(struct net_device *dev)\r\n{\r\n__u32 encoded_addr, hw_encoded_addr;\r\nstruct tok_info *ti;\r\nunsigned char init_status;\r\nti = netdev_priv(dev);\r\nti->do_tok_int = NOT_FIRST;\r\nwriteb(ti->sram_base, ti->mmio + ACA_OFFSET + ACA_RW + RRR_EVEN);\r\n#ifndef PCMCIA\r\nti->sram_virt = ioremap(((__u32)ti->sram_base << 12), ti->avail_shared_ram);\r\n#endif\r\nti->init_srb = map_address(ti,\r\nntohs(readw(ti->mmio + ACA_OFFSET + WRBR_EVEN)),\r\n&ti->init_srb_page);\r\nif (ti->page_mask && ti->avail_shared_ram == 127) {\r\nvoid __iomem *last_512;\r\n__u8 last_512_page=0;\r\nint i;\r\nlast_512 = map_address(ti, 0xfe00, &last_512_page);\r\nSET_PAGE(last_512_page);\r\nfor (i = 0; i < 512; i++)\r\nwriteb(0, last_512 + i);\r\n}\r\nSET_PAGE(ti->init_srb_page);\r\n#if TR_VERBOSE\r\n{\r\nint i;\r\nDPRINTK("ti->init_srb_page=0x%x\n", ti->init_srb_page);\r\nDPRINTK("init_srb(%p):", ti->init_srb );\r\nfor (i = 0; i < 20; i++)\r\nprintk("%02X ", (int) readb(ti->init_srb + i));\r\nprintk("\n");\r\n}\r\n#endif\r\nhw_encoded_addr = readw(ti->init_srb + ENCODED_ADDRESS_OFST);\r\nencoded_addr = ntohs(hw_encoded_addr);\r\ninit_status=\r\nreadb(ti->init_srb+offsetof(struct srb_init_response,init_status));\r\nti->ring_speed = init_status & 0x01 ? 16 : 4;\r\nDPRINTK("Initial interrupt : %d Mbps, shared RAM base %08x.\n",\r\nti->ring_speed, (unsigned int)dev->mem_start);\r\nti->auto_speedsave = (readb(ti->init_srb+INIT_STATUS_2_OFST) & 4) != 0;\r\nif (ti->open_mode == MANUAL) wake_up(&ti->wait_for_reset);\r\nelse tok_open_adapter((unsigned long)dev);\r\n}\r\nstatic void tr_tx(struct net_device *dev)\r\n{\r\nstruct tok_info *ti = netdev_priv(dev);\r\nstruct trh_hdr *trhdr = (struct trh_hdr *) ti->current_skb->data;\r\nunsigned int hdr_len;\r\n__u32 dhb=0,dhb_base;\r\nvoid __iomem *dhbuf = NULL;\r\nunsigned char xmit_command;\r\nint i,dhb_len=0x4000,src_len,src_offset;\r\nstruct trllc *llc;\r\nstruct srb_xmit xsrb;\r\n__u8 dhb_page = 0;\r\n__u8 llc_ssap;\r\nSET_PAGE(ti->asb_page);\r\nif (readb(ti->asb+RETCODE_OFST) != 0xFF) DPRINTK("ASB not free !!!\n");\r\nSET_PAGE(ti->arb_page);\r\ndhb=dhb_base=ntohs(readw(ti->arb + DHB_ADDRESS_OFST));\r\nif (ti->page_mask) {\r\ndhb_page = (dhb_base >> 8) & ti->page_mask;\r\ndhb=dhb_base & ~(ti->page_mask << 8);\r\n}\r\ndhbuf = ti->sram_virt + dhb;\r\nif (!(trhdr->saddr[0] & 0x80))\r\nhdr_len = sizeof(struct trh_hdr) - TR_MAXRIFLEN;\r\nelse\r\nhdr_len = ((ntohs(trhdr->rcf) & TR_RCF_LEN_MASK) >> 8)\r\n+ sizeof(struct trh_hdr) - TR_MAXRIFLEN;\r\nllc = (struct trllc *) (ti->current_skb->data + hdr_len);\r\nllc_ssap = llc->ssap;\r\nSET_PAGE(ti->srb_page);\r\nmemcpy_fromio(&xsrb, ti->srb, sizeof(xsrb));\r\nSET_PAGE(ti->asb_page);\r\nxmit_command = xsrb.command;\r\nwriteb(xmit_command, ti->asb + COMMAND_OFST);\r\nwritew(xsrb.station_id, ti->asb + STATION_ID_OFST);\r\nwriteb(llc_ssap, ti->asb + RSAP_VALUE_OFST);\r\nwriteb(xsrb.cmd_corr, ti->asb + CMD_CORRELATE_OFST);\r\nwriteb(0, ti->asb + RETCODE_OFST);\r\nif ((xmit_command == XMIT_XID_CMD) || (xmit_command == XMIT_TEST_CMD)) {\r\nwritew(htons(0x11), ti->asb + FRAME_LENGTH_OFST);\r\nwriteb(0x0e, ti->asb + HEADER_LENGTH_OFST);\r\nSET_PAGE(dhb_page);\r\nwriteb(AC, dhbuf);\r\nwriteb(LLC_FRAME, dhbuf + 1);\r\nfor (i = 0; i < TR_ALEN; i++)\r\nwriteb((int) 0x0FF, dhbuf + i + 2);\r\nfor (i = 0; i < TR_ALEN; i++)\r\nwriteb(0, dhbuf + i + TR_ALEN + 2);\r\nwriteb(RESP_IN_ASB, ti->mmio + ACA_OFFSET + ACA_SET + ISRA_ODD);\r\nreturn;\r\n}\r\nwriteb(hdr_len, ti->asb + HEADER_LENGTH_OFST);\r\nwritew(htons(ti->current_skb->len), ti->asb + FRAME_LENGTH_OFST);\r\nsrc_len=ti->current_skb->len;\r\nsrc_offset=0;\r\ndhb=dhb_base;\r\nwhile(1) {\r\nif (ti->page_mask) {\r\ndhb_page=(dhb >> 8) & ti->page_mask;\r\ndhb=dhb & ~(ti->page_mask << 8);\r\ndhb_len=0x4000-dhb;\r\n}\r\ndhbuf = ti->sram_virt + dhb;\r\nSET_PAGE(dhb_page);\r\nif (src_len > dhb_len) {\r\nmemcpy_toio(dhbuf,&ti->current_skb->data[src_offset],\r\ndhb_len);\r\nsrc_len -= dhb_len;\r\nsrc_offset += dhb_len;\r\ndhb_base+=dhb_len;\r\ndhb=dhb_base;\r\ncontinue;\r\n}\r\nmemcpy_toio(dhbuf, &ti->current_skb->data[src_offset], src_len);\r\nbreak;\r\n}\r\nwriteb(RESP_IN_ASB, ti->mmio + ACA_OFFSET + ACA_SET + ISRA_ODD);\r\ndev->stats.tx_bytes += ti->current_skb->len;\r\ndev_kfree_skb_irq(ti->current_skb);\r\nti->current_skb = NULL;\r\nnetif_wake_queue(dev);\r\nif (ti->readlog_pending)\r\nibmtr_readlog(dev);\r\n}\r\nstatic void tr_rx(struct net_device *dev)\r\n{\r\nstruct tok_info *ti = netdev_priv(dev);\r\n__u32 rbuffer;\r\nvoid __iomem *rbuf, *rbufdata, *llc;\r\n__u8 rbuffer_page = 0;\r\nunsigned char *data;\r\nunsigned int rbuffer_len, lan_hdr_len, hdr_len, ip_len, length;\r\nunsigned char dlc_hdr_len;\r\nstruct sk_buff *skb;\r\nunsigned int skb_size = 0;\r\nint IPv4_p = 0;\r\nunsigned int chksum = 0;\r\nstruct iphdr *iph;\r\nstruct arb_rec_req rarb;\r\nSET_PAGE(ti->arb_page);\r\nmemcpy_fromio(&rarb, ti->arb, sizeof(rarb));\r\nrbuffer = ntohs(rarb.rec_buf_addr) ;\r\nrbuf = map_address(ti, rbuffer, &rbuffer_page);\r\nSET_PAGE(ti->asb_page);\r\nif (readb(ti->asb + RETCODE_OFST) !=0xFF) DPRINTK("ASB not free !!!\n");\r\nwriteb(REC_DATA, ti->asb + COMMAND_OFST);\r\nwritew(rarb.station_id, ti->asb + STATION_ID_OFST);\r\nwritew(rarb.rec_buf_addr, ti->asb + RECEIVE_BUFFER_OFST);\r\nlan_hdr_len = rarb.lan_hdr_len;\r\nif (lan_hdr_len > sizeof(struct trh_hdr)) {\r\nDPRINTK("Linux cannot handle greater than 18 bytes RIF\n");\r\nreturn;\r\n}\r\ndlc_hdr_len = readb(ti->arb + DLC_HDR_LENGTH_OFST);\r\nhdr_len = lan_hdr_len + sizeof(struct trllc) + sizeof(struct iphdr);\r\nSET_PAGE(rbuffer_page);\r\nllc = rbuf + offsetof(struct rec_buf, data) + lan_hdr_len;\r\n#if TR_VERBOSE\r\nDPRINTK("offsetof data: %02X lan_hdr_len: %02X\n",\r\n(__u32) offsetof(struct rec_buf, data), (unsigned int) lan_hdr_len);\r\nDPRINTK("llc: %08X rec_buf_addr: %04X dev->mem_start: %lX\n",\r\nllc, ntohs(rarb.rec_buf_addr), dev->mem_start);\r\nDPRINTK("dsap: %02X, ssap: %02X, llc: %02X, protid: %02X%02X%02X, "\r\n"ethertype: %04X\n",\r\n(int) readb(llc + DSAP_OFST), (int) readb(llc + SSAP_OFST),\r\n(int) readb(llc + LLC_OFST), (int) readb(llc + PROTID_OFST),\r\n(int) readb(llc+PROTID_OFST+1),(int)readb(llc+PROTID_OFST + 2),\r\n(int) ntohs(readw(llc + ETHERTYPE_OFST)));\r\n#endif\r\nif (readb(llc + offsetof(struct trllc, llc)) != UI_CMD) {\r\nSET_PAGE(ti->asb_page);\r\nwriteb(DATA_LOST, ti->asb + RETCODE_OFST);\r\ndev->stats.rx_dropped++;\r\nwriteb(RESP_IN_ASB, ti->mmio + ACA_OFFSET + ACA_SET + ISRA_ODD);\r\nreturn;\r\n}\r\nlength = ntohs(rarb.frame_len);\r\nif (readb(llc + DSAP_OFST) == EXTENDED_SAP &&\r\nreadb(llc + SSAP_OFST) == EXTENDED_SAP &&\r\nlength >= hdr_len) IPv4_p = 1;\r\n#if TR_VERBOSE\r\n#define SADDR_OFST 8\r\n#define DADDR_OFST 2\r\nif (!IPv4_p) {\r\nvoid __iomem *trhhdr = rbuf + offsetof(struct rec_buf, data);\r\nu8 saddr[6];\r\nu8 daddr[6];\r\nint i;\r\nfor (i = 0 ; i < 6 ; i++)\r\nsaddr[i] = readb(trhhdr + SADDR_OFST + i);\r\nfor (i = 0 ; i < 6 ; i++)\r\ndaddr[i] = readb(trhhdr + DADDR_OFST + i);\r\nDPRINTK("Probably non-IP frame received.\n");\r\nDPRINTK("ssap: %02X dsap: %02X "\r\n"saddr: %pM daddr: %pM\n",\r\nreadb(llc + SSAP_OFST), readb(llc + DSAP_OFST),\r\nsaddr, daddr);\r\n}\r\n#endif\r\nskb_size=length-lan_hdr_len+sizeof(struct trh_hdr)+sizeof(struct trllc);\r\nif (!(skb = dev_alloc_skb(skb_size))) {\r\nDPRINTK("out of memory. frame dropped.\n");\r\ndev->stats.rx_dropped++;\r\nSET_PAGE(ti->asb_page);\r\nwriteb(DATA_LOST, ti->asb + offsetof(struct asb_rec, ret_code));\r\nwriteb(RESP_IN_ASB, ti->mmio + ACA_OFFSET + ACA_SET + ISRA_ODD);\r\nreturn;\r\n}\r\nskb_reserve(skb, sizeof(struct trh_hdr) - lan_hdr_len);\r\nskb_put(skb, length);\r\ndata = skb->data;\r\nrbuffer_len = ntohs(readw(rbuf + offsetof(struct rec_buf, buf_len)));\r\nrbufdata = rbuf + offsetof(struct rec_buf, data);\r\nif (IPv4_p) {\r\nmemcpy_fromio(data, rbufdata, hdr_len);\r\niph= (struct iphdr *)(data+ lan_hdr_len + sizeof(struct trllc));\r\nip_len = ntohs(iph->tot_len) - sizeof(struct iphdr);\r\nlength -= hdr_len;\r\nif ((ip_len <= length) && (ip_len > 7))\r\nlength = ip_len;\r\ndata += hdr_len;\r\nrbuffer_len -= hdr_len;\r\nrbufdata += hdr_len;\r\n}\r\n#define BUFFER_POINTER_OFST 2\r\n#define BUFFER_LENGTH_OFST 6\r\nfor (;;) {\r\nif (ibmtr_debug_trace&TRC_INITV && length < rbuffer_len)\r\nDPRINTK("CURIOUS, length=%d < rbuffer_len=%d\n",\r\nlength,rbuffer_len);\r\nif (IPv4_p)\r\nchksum=csum_partial_copy_nocheck((void*)rbufdata,\r\ndata,length<rbuffer_len?length:rbuffer_len,chksum);\r\nelse\r\nmemcpy_fromio(data, rbufdata, rbuffer_len);\r\nrbuffer = ntohs(readw(rbuf+BUFFER_POINTER_OFST)) ;\r\nif (!rbuffer)\r\nbreak;\r\nrbuffer -= 2;\r\nlength -= rbuffer_len;\r\ndata += rbuffer_len;\r\nrbuf = map_address(ti, rbuffer, &rbuffer_page);\r\nSET_PAGE(rbuffer_page);\r\nrbuffer_len = ntohs(readw(rbuf + BUFFER_LENGTH_OFST));\r\nrbufdata = rbuf + offsetof(struct rec_buf, data);\r\n}\r\nSET_PAGE(ti->asb_page);\r\nwriteb(0, ti->asb + offsetof(struct asb_rec, ret_code));\r\nwriteb(RESP_IN_ASB, ti->mmio + ACA_OFFSET + ACA_SET + ISRA_ODD);\r\ndev->stats.rx_bytes += skb->len;\r\ndev->stats.rx_packets++;\r\nskb->protocol = tr_type_trans(skb, dev);\r\nif (IPv4_p) {\r\nskb->csum = chksum;\r\nskb->ip_summed = CHECKSUM_COMPLETE;\r\n}\r\nnetif_rx(skb);\r\n}\r\nstatic void ibmtr_reset_timer(struct timer_list *tmr, struct net_device *dev)\r\n{\r\ntmr->expires = jiffies + TR_RETRY_INTERVAL;\r\ntmr->data = (unsigned long) dev;\r\ntmr->function = tok_rerun;\r\ninit_timer(tmr);\r\nadd_timer(tmr);\r\n}\r\nstatic void tok_rerun(unsigned long dev_addr)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_addr;\r\nstruct tok_info *ti = netdev_priv(dev);\r\nif ( ti->open_action == RESTART){\r\nti->do_tok_int = FIRST_INT;\r\noutb(0, dev->base_addr + ADAPTRESETREL);\r\n#ifdef ENABLE_PAGING\r\nif (ti->page_mask)\r\nwriteb(SRPR_ENABLE_PAGING,\r\nti->mmio + ACA_OFFSET + ACA_RW + SRPR_EVEN);\r\n#endif\r\nwriteb(INT_ENABLE, ti->mmio + ACA_OFFSET + ACA_SET + ISRP_EVEN);\r\n} else\r\ntok_open_adapter(dev_addr);\r\n}\r\nstatic void ibmtr_readlog(struct net_device *dev)\r\n{\r\nstruct tok_info *ti;\r\nti = netdev_priv(dev);\r\nti->readlog_pending = 0;\r\nSET_PAGE(ti->srb_page);\r\nwriteb(DIR_READ_LOG, ti->srb);\r\nwriteb(INT_ENABLE, ti->mmio + ACA_OFFSET + ACA_SET + ISRP_EVEN);\r\nwriteb(CMD_IN_SRB, ti->mmio + ACA_OFFSET + ACA_SET + ISRA_ODD);\r\nnetif_stop_queue(dev);\r\n}\r\nstatic int ibmtr_change_mtu(struct net_device *dev, int mtu)\r\n{\r\nstruct tok_info *ti = netdev_priv(dev);\r\nif (ti->ring_speed == 16 && mtu > ti->maxmtu16)\r\nreturn -EINVAL;\r\nif (ti->ring_speed == 4 && mtu > ti->maxmtu4)\r\nreturn -EINVAL;\r\ndev->mtu = mtu;\r\nreturn 0;\r\n}\r\nstatic int __init ibmtr_init(void)\r\n{\r\nint i;\r\nint count=0;\r\nfind_turbo_adapters(io);\r\nfor (i = 0; i < IBMTR_MAX_ADAPTERS && io[i]; i++) {\r\nstruct net_device *dev;\r\nirq[i] = 0;\r\nmem[i] = 0;\r\ndev = alloc_trdev(sizeof(struct tok_info));\r\nif (dev == NULL) {\r\nif (i == 0)\r\nreturn -ENOMEM;\r\nbreak;\r\n}\r\ndev->base_addr = io[i];\r\ndev->irq = irq[i];\r\ndev->mem_start = mem[i];\r\nif (ibmtr_probe_card(dev)) {\r\nfree_netdev(dev);\r\ncontinue;\r\n}\r\ndev_ibmtr[i] = dev;\r\ncount++;\r\n}\r\nif (count) return 0;\r\nprintk("ibmtr: register_netdev() returned non-zero.\n");\r\nreturn -EIO;\r\n}\r\nstatic void __exit ibmtr_cleanup(void)\r\n{\r\nint i;\r\nfor (i = 0; i < IBMTR_MAX_ADAPTERS; i++){\r\nif (!dev_ibmtr[i])\r\ncontinue;\r\nunregister_netdev(dev_ibmtr[i]);\r\nibmtr_cleanup_card(dev_ibmtr[i]);\r\nfree_netdev(dev_ibmtr[i]);\r\n}\r\n}
