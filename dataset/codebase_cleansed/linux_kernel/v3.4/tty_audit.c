static struct tty_audit_buf *tty_audit_buf_alloc(int major, int minor,\r\nint icanon)\r\n{\r\nstruct tty_audit_buf *buf;\r\nbuf = kmalloc(sizeof(*buf), GFP_KERNEL);\r\nif (!buf)\r\ngoto err;\r\nbuf->data = kmalloc(N_TTY_BUF_SIZE, GFP_KERNEL);\r\nif (!buf->data)\r\ngoto err_buf;\r\natomic_set(&buf->count, 1);\r\nmutex_init(&buf->mutex);\r\nbuf->major = major;\r\nbuf->minor = minor;\r\nbuf->icanon = icanon;\r\nbuf->valid = 0;\r\nreturn buf;\r\nerr_buf:\r\nkfree(buf);\r\nerr:\r\nreturn NULL;\r\n}\r\nstatic void tty_audit_buf_free(struct tty_audit_buf *buf)\r\n{\r\nWARN_ON(buf->valid != 0);\r\nkfree(buf->data);\r\nkfree(buf);\r\n}\r\nstatic void tty_audit_buf_put(struct tty_audit_buf *buf)\r\n{\r\nif (atomic_dec_and_test(&buf->count))\r\ntty_audit_buf_free(buf);\r\n}\r\nstatic void tty_audit_log(const char *description, struct task_struct *tsk,\r\nuid_t loginuid, unsigned sessionid, int major,\r\nint minor, unsigned char *data, size_t size)\r\n{\r\nstruct audit_buffer *ab;\r\nab = audit_log_start(NULL, GFP_KERNEL, AUDIT_TTY);\r\nif (ab) {\r\nchar name[sizeof(tsk->comm)];\r\nuid_t uid = task_uid(tsk);\r\naudit_log_format(ab, "%s pid=%u uid=%u auid=%u ses=%u "\r\n"major=%d minor=%d comm=", description,\r\ntsk->pid, uid, loginuid, sessionid,\r\nmajor, minor);\r\nget_task_comm(name, tsk);\r\naudit_log_untrustedstring(ab, name);\r\naudit_log_format(ab, " data=");\r\naudit_log_n_hex(ab, data, size);\r\naudit_log_end(ab);\r\n}\r\n}\r\nstatic void tty_audit_buf_push(struct task_struct *tsk, uid_t loginuid,\r\nunsigned int sessionid,\r\nstruct tty_audit_buf *buf)\r\n{\r\nif (buf->valid == 0)\r\nreturn;\r\nif (audit_enabled == 0) {\r\nbuf->valid = 0;\r\nreturn;\r\n}\r\ntty_audit_log("tty", tsk, loginuid, sessionid, buf->major, buf->minor,\r\nbuf->data, buf->valid);\r\nbuf->valid = 0;\r\n}\r\nstatic void tty_audit_buf_push_current(struct tty_audit_buf *buf)\r\n{\r\nuid_t auid = audit_get_loginuid(current);\r\nunsigned int sessionid = audit_get_sessionid(current);\r\ntty_audit_buf_push(current, auid, sessionid, buf);\r\n}\r\nvoid tty_audit_exit(void)\r\n{\r\nstruct tty_audit_buf *buf;\r\nspin_lock_irq(&current->sighand->siglock);\r\nbuf = current->signal->tty_audit_buf;\r\ncurrent->signal->tty_audit_buf = NULL;\r\nspin_unlock_irq(&current->sighand->siglock);\r\nif (!buf)\r\nreturn;\r\nmutex_lock(&buf->mutex);\r\ntty_audit_buf_push_current(buf);\r\nmutex_unlock(&buf->mutex);\r\ntty_audit_buf_put(buf);\r\n}\r\nvoid tty_audit_fork(struct signal_struct *sig)\r\n{\r\nspin_lock_irq(&current->sighand->siglock);\r\nsig->audit_tty = current->signal->audit_tty;\r\nspin_unlock_irq(&current->sighand->siglock);\r\n}\r\nvoid tty_audit_tiocsti(struct tty_struct *tty, char ch)\r\n{\r\nstruct tty_audit_buf *buf;\r\nint major, minor, should_audit;\r\nspin_lock_irq(&current->sighand->siglock);\r\nshould_audit = current->signal->audit_tty;\r\nbuf = current->signal->tty_audit_buf;\r\nif (buf)\r\natomic_inc(&buf->count);\r\nspin_unlock_irq(&current->sighand->siglock);\r\nmajor = tty->driver->major;\r\nminor = tty->driver->minor_start + tty->index;\r\nif (buf) {\r\nmutex_lock(&buf->mutex);\r\nif (buf->major == major && buf->minor == minor)\r\ntty_audit_buf_push_current(buf);\r\nmutex_unlock(&buf->mutex);\r\ntty_audit_buf_put(buf);\r\n}\r\nif (should_audit && audit_enabled) {\r\nuid_t auid;\r\nunsigned int sessionid;\r\nauid = audit_get_loginuid(current);\r\nsessionid = audit_get_sessionid(current);\r\ntty_audit_log("ioctl=TIOCSTI", current, auid, sessionid, major,\r\nminor, &ch, 1);\r\n}\r\n}\r\nint tty_audit_push_task(struct task_struct *tsk, uid_t loginuid, u32 sessionid)\r\n{\r\nstruct tty_audit_buf *buf = ERR_PTR(-EPERM);\r\nunsigned long flags;\r\nif (!lock_task_sighand(tsk, &flags))\r\nreturn -ESRCH;\r\nif (tsk->signal->audit_tty) {\r\nbuf = tsk->signal->tty_audit_buf;\r\nif (buf)\r\natomic_inc(&buf->count);\r\n}\r\nunlock_task_sighand(tsk, &flags);\r\nif (!buf || IS_ERR(buf))\r\nreturn PTR_ERR(buf);\r\nmutex_lock(&buf->mutex);\r\ntty_audit_buf_push(tsk, loginuid, sessionid, buf);\r\nmutex_unlock(&buf->mutex);\r\ntty_audit_buf_put(buf);\r\nreturn 0;\r\n}\r\nstatic struct tty_audit_buf *tty_audit_buf_get(struct tty_struct *tty)\r\n{\r\nstruct tty_audit_buf *buf, *buf2;\r\nbuf = NULL;\r\nbuf2 = NULL;\r\nspin_lock_irq(&current->sighand->siglock);\r\nif (likely(!current->signal->audit_tty))\r\ngoto out;\r\nbuf = current->signal->tty_audit_buf;\r\nif (buf) {\r\natomic_inc(&buf->count);\r\ngoto out;\r\n}\r\nspin_unlock_irq(&current->sighand->siglock);\r\nbuf2 = tty_audit_buf_alloc(tty->driver->major,\r\ntty->driver->minor_start + tty->index,\r\ntty->icanon);\r\nif (buf2 == NULL) {\r\naudit_log_lost("out of memory in TTY auditing");\r\nreturn NULL;\r\n}\r\nspin_lock_irq(&current->sighand->siglock);\r\nif (!current->signal->audit_tty)\r\ngoto out;\r\nbuf = current->signal->tty_audit_buf;\r\nif (!buf) {\r\ncurrent->signal->tty_audit_buf = buf2;\r\nbuf = buf2;\r\nbuf2 = NULL;\r\n}\r\natomic_inc(&buf->count);\r\nout:\r\nspin_unlock_irq(&current->sighand->siglock);\r\nif (buf2)\r\ntty_audit_buf_free(buf2);\r\nreturn buf;\r\n}\r\nvoid tty_audit_add_data(struct tty_struct *tty, unsigned char *data,\r\nsize_t size)\r\n{\r\nstruct tty_audit_buf *buf;\r\nint major, minor;\r\nif (unlikely(size == 0))\r\nreturn;\r\nif (tty->driver->type == TTY_DRIVER_TYPE_PTY\r\n&& tty->driver->subtype == PTY_TYPE_MASTER)\r\nreturn;\r\nbuf = tty_audit_buf_get(tty);\r\nif (!buf)\r\nreturn;\r\nmutex_lock(&buf->mutex);\r\nmajor = tty->driver->major;\r\nminor = tty->driver->minor_start + tty->index;\r\nif (buf->major != major || buf->minor != minor\r\n|| buf->icanon != tty->icanon) {\r\ntty_audit_buf_push_current(buf);\r\nbuf->major = major;\r\nbuf->minor = minor;\r\nbuf->icanon = tty->icanon;\r\n}\r\ndo {\r\nsize_t run;\r\nrun = N_TTY_BUF_SIZE - buf->valid;\r\nif (run > size)\r\nrun = size;\r\nmemcpy(buf->data + buf->valid, data, run);\r\nbuf->valid += run;\r\ndata += run;\r\nsize -= run;\r\nif (buf->valid == N_TTY_BUF_SIZE)\r\ntty_audit_buf_push_current(buf);\r\n} while (size != 0);\r\nmutex_unlock(&buf->mutex);\r\ntty_audit_buf_put(buf);\r\n}\r\nvoid tty_audit_push(struct tty_struct *tty)\r\n{\r\nstruct tty_audit_buf *buf;\r\nspin_lock_irq(&current->sighand->siglock);\r\nif (likely(!current->signal->audit_tty)) {\r\nspin_unlock_irq(&current->sighand->siglock);\r\nreturn;\r\n}\r\nbuf = current->signal->tty_audit_buf;\r\nif (buf)\r\natomic_inc(&buf->count);\r\nspin_unlock_irq(&current->sighand->siglock);\r\nif (buf) {\r\nint major, minor;\r\nmajor = tty->driver->major;\r\nminor = tty->driver->minor_start + tty->index;\r\nmutex_lock(&buf->mutex);\r\nif (buf->major == major && buf->minor == minor)\r\ntty_audit_buf_push_current(buf);\r\nmutex_unlock(&buf->mutex);\r\ntty_audit_buf_put(buf);\r\n}\r\n}
