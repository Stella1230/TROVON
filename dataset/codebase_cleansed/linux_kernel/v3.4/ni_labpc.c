static inline unsigned int labpc_inb(unsigned long address)\r\n{\r\nreturn inb(address);\r\n}\r\nstatic inline void labpc_outb(unsigned int byte, unsigned long address)\r\n{\r\noutb(byte, address);\r\n}\r\nstatic inline unsigned int labpc_readb(unsigned long address)\r\n{\r\nreturn readb((void *)address);\r\n}\r\nstatic inline void labpc_writeb(unsigned int byte, unsigned long address)\r\n{\r\nwriteb(byte, (void *)address);\r\n}\r\nstatic inline int labpc_counter_load(struct comedi_device *dev,\r\nunsigned long base_address,\r\nunsigned int counter_number,\r\nunsigned int count, unsigned int mode)\r\n{\r\nif (thisboard->memory_mapped_io)\r\nreturn i8254_mm_load((void *)base_address, 0, counter_number,\r\ncount, mode);\r\nelse\r\nreturn i8254_load(base_address, 0, counter_number, count, mode);\r\n}\r\nint labpc_common_attach(struct comedi_device *dev, unsigned long iobase,\r\nunsigned int irq, unsigned int dma_chan)\r\n{\r\nstruct comedi_subdevice *s;\r\nint i;\r\nunsigned long isr_flags;\r\n#ifdef CONFIG_ISA_DMA_API\r\nunsigned long dma_flags;\r\n#endif\r\nshort lsb, msb;\r\nprintk(KERN_ERR "comedi%d: ni_labpc: %s, io 0x%lx", dev->minor,\r\nthisboard->name,\r\niobase);\r\nif (irq)\r\nprintk(", irq %u", irq);\r\nif (dma_chan)\r\nprintk(", dma %u", dma_chan);\r\nprintk("\n");\r\nif (iobase == 0) {\r\nprintk(KERN_ERR "io base address is zero!\n");\r\nreturn -EINVAL;\r\n}\r\nif (thisboard->bustype == isa_bustype) {\r\nif (!request_region(iobase, LABPC_SIZE,\r\ndriver_labpc.driver_name)) {\r\nprintk(KERN_ERR "I/O port conflict\n");\r\nreturn -EIO;\r\n}\r\n}\r\ndev->iobase = iobase;\r\nif (thisboard->memory_mapped_io) {\r\ndevpriv->read_byte = labpc_readb;\r\ndevpriv->write_byte = labpc_writeb;\r\n} else {\r\ndevpriv->read_byte = labpc_inb;\r\ndevpriv->write_byte = labpc_outb;\r\n}\r\ndevpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);\r\ndevpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);\r\ndevpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);\r\ndevpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);\r\nif (thisboard->register_layout == labpc_1200_layout) {\r\ndevpriv->write_byte(devpriv->command5_bits,\r\ndev->iobase + COMMAND5_REG);\r\ndevpriv->write_byte(devpriv->command6_bits,\r\ndev->iobase + COMMAND6_REG);\r\n}\r\nif (irq) {\r\nisr_flags = 0;\r\nif (thisboard->bustype == pci_bustype\r\n|| thisboard->bustype == pcmcia_bustype)\r\nisr_flags |= IRQF_SHARED;\r\nif (request_irq(irq, labpc_interrupt, isr_flags,\r\ndriver_labpc.driver_name, dev)) {\r\nprintk(KERN_ERR "unable to allocate irq %u\n", irq);\r\nreturn -EINVAL;\r\n}\r\n}\r\ndev->irq = irq;\r\n#ifdef CONFIG_ISA_DMA_API\r\nif (dma_chan > 3) {\r\nprintk(KERN_ERR " invalid dma channel %u\n", dma_chan);\r\nreturn -EINVAL;\r\n} else if (dma_chan) {\r\ndevpriv->dma_buffer =\r\nkmalloc(dma_buffer_size, GFP_KERNEL | GFP_DMA);\r\nif (devpriv->dma_buffer == NULL) {\r\nprintk(KERN_ERR " failed to allocate dma buffer\n");\r\nreturn -ENOMEM;\r\n}\r\nif (request_dma(dma_chan, driver_labpc.driver_name)) {\r\nprintk(KERN_ERR " failed to allocate dma channel %u\n",\r\ndma_chan);\r\nreturn -EINVAL;\r\n}\r\ndevpriv->dma_chan = dma_chan;\r\ndma_flags = claim_dma_lock();\r\ndisable_dma(devpriv->dma_chan);\r\nset_dma_mode(devpriv->dma_chan, DMA_MODE_READ);\r\nrelease_dma_lock(dma_flags);\r\n}\r\n#endif\r\ndev->board_name = thisboard->name;\r\nif (alloc_subdevices(dev, 5) < 0)\r\nreturn -ENOMEM;\r\ns = dev->subdevices + 0;\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags =\r\nSDF_READABLE | SDF_GROUND | SDF_COMMON | SDF_DIFF | SDF_CMD_READ;\r\ns->n_chan = 8;\r\ns->len_chanlist = 8;\r\ns->maxdata = (1 << 12) - 1;\r\ns->range_table = thisboard->ai_range_table;\r\ns->do_cmd = labpc_ai_cmd;\r\ns->do_cmdtest = labpc_ai_cmdtest;\r\ns->insn_read = labpc_ai_rinsn;\r\ns->cancel = labpc_cancel;\r\ns = dev->subdevices + 1;\r\nif (thisboard->has_ao) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;\r\ns->n_chan = NUM_AO_CHAN;\r\ns->maxdata = (1 << 12) - 1;\r\ns->range_table = &range_labpc_ao;\r\ns->insn_read = labpc_ao_rinsn;\r\ns->insn_write = labpc_ao_winsn;\r\nfor (i = 0; i < s->n_chan; i++) {\r\ndevpriv->ao_value[i] = s->maxdata / 2;\r\nlsb = devpriv->ao_value[i] & 0xff;\r\nmsb = (devpriv->ao_value[i] >> 8) & 0xff;\r\ndevpriv->write_byte(lsb, dev->iobase + DAC_LSB_REG(i));\r\ndevpriv->write_byte(msb, dev->iobase + DAC_MSB_REG(i));\r\n}\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = dev->subdevices + 2;\r\nif (thisboard->memory_mapped_io)\r\nsubdev_8255_init(dev, s, labpc_dio_mem_callback,\r\n(unsigned long)(dev->iobase + DIO_BASE_REG));\r\nelse\r\nsubdev_8255_init(dev, s, NULL, dev->iobase + DIO_BASE_REG);\r\ns = dev->subdevices + 3;\r\nif (thisboard->register_layout == labpc_1200_layout) {\r\ns->type = COMEDI_SUBD_CALIB;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\r\ns->n_chan = 16;\r\ns->maxdata = 0xff;\r\ns->insn_read = labpc_calib_read_insn;\r\ns->insn_write = labpc_calib_write_insn;\r\nfor (i = 0; i < s->n_chan; i++)\r\nwrite_caldac(dev, i, s->maxdata / 2);\r\n} else\r\ns->type = COMEDI_SUBD_UNUSED;\r\ns = dev->subdevices + 4;\r\nif (thisboard->register_layout == labpc_1200_layout) {\r\ns->type = COMEDI_SUBD_MEMORY;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\r\ns->n_chan = EEPROM_SIZE;\r\ns->maxdata = 0xff;\r\ns->insn_read = labpc_eeprom_read_insn;\r\ns->insn_write = labpc_eeprom_write_insn;\r\nfor (i = 0; i < EEPROM_SIZE; i++)\r\ndevpriv->eeprom_data[i] = labpc_eeprom_read(dev, i);\r\n#ifdef LABPC_DEBUG\r\nprintk(KERN_ERR " eeprom:");\r\nfor (i = 0; i < EEPROM_SIZE; i++)\r\nprintk(" %i:0x%x ", i, devpriv->eeprom_data[i]);\r\nprintk("\n");\r\n#endif\r\n} else\r\ns->type = COMEDI_SUBD_UNUSED;\r\nreturn 0;\r\n}\r\nstatic int labpc_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nunsigned long iobase = 0;\r\nunsigned int irq = 0;\r\nunsigned int dma_chan = 0;\r\n#ifdef CONFIG_COMEDI_PCI_DRIVERS\r\nint retval;\r\n#endif\r\nif (alloc_private(dev, sizeof(struct labpc_private)) < 0)\r\nreturn -ENOMEM;\r\nswitch (thisboard->bustype) {\r\ncase isa_bustype:\r\n#ifdef CONFIG_ISA_DMA_API\r\niobase = it->options[0];\r\nirq = it->options[1];\r\ndma_chan = it->options[2];\r\n#else\r\nprintk(KERN_ERR " this driver has not been built with ISA DMA "\r\n"support.\n");\r\nreturn -EINVAL;\r\n#endif\r\nbreak;\r\ncase pci_bustype:\r\n#ifdef CONFIG_COMEDI_PCI_DRIVERS\r\nretval = labpc_find_device(dev, it->options[0], it->options[1]);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = mite_setup(devpriv->mite);\r\nif (retval < 0)\r\nreturn retval;\r\niobase = (unsigned long)devpriv->mite->daq_io_addr;\r\nirq = mite_irq(devpriv->mite);\r\n#else\r\nprintk(KERN_ERR " this driver has not been built with PCI "\r\n"support.\n");\r\nreturn -EINVAL;\r\n#endif\r\nbreak;\r\ncase pcmcia_bustype:\r\nprintk\r\n(" this driver does not support pcmcia cards, use ni_labpc_cs.o\n");\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "bug! couldn't determine board type\n");\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn labpc_common_attach(dev, iobase, irq, dma_chan);\r\n}\r\nstatic int labpc_find_device(struct comedi_device *dev, int bus, int slot)\r\n{\r\nstruct mite_struct *mite;\r\nint i;\r\nfor (mite = mite_devices; mite; mite = mite->next) {\r\nif (mite->used)\r\ncontinue;\r\nif (bus || slot) {\r\nif (bus != mite->pcidev->bus->number\r\n|| slot != PCI_SLOT(mite->pcidev->devfn))\r\ncontinue;\r\n}\r\nfor (i = 0; i < driver_labpc.num_names; i++) {\r\nif (labpc_boards[i].bustype != pci_bustype)\r\ncontinue;\r\nif (mite_device_id(mite) == labpc_boards[i].device_id) {\r\ndevpriv->mite = mite;\r\ndev->board_ptr = &labpc_boards[i];\r\nreturn 0;\r\n}\r\n}\r\n}\r\nprintk(KERN_ERR "no device found\n");\r\nmite_list_devices();\r\nreturn -EIO;\r\n}\r\nint labpc_common_detach(struct comedi_device *dev)\r\n{\r\nprintk(KERN_ERR "comedi%d: ni_labpc: detach\n", dev->minor);\r\nif (dev->subdevices)\r\nsubdev_8255_cleanup(dev, dev->subdevices + 2);\r\n#ifdef CONFIG_ISA_DMA_API\r\nkfree(devpriv->dma_buffer);\r\nif (devpriv->dma_chan)\r\nfree_dma(devpriv->dma_chan);\r\n#endif\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (thisboard->bustype == isa_bustype && dev->iobase)\r\nrelease_region(dev->iobase, LABPC_SIZE);\r\n#ifdef CONFIG_COMEDI_PCI_DRIVERS\r\nif (devpriv->mite)\r\nmite_unsetup(devpriv->mite);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void labpc_clear_adc_fifo(const struct comedi_device *dev)\r\n{\r\ndevpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);\r\ndevpriv->read_byte(dev->iobase + ADC_FIFO_REG);\r\ndevpriv->read_byte(dev->iobase + ADC_FIFO_REG);\r\n}\r\nstatic int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;\r\ndevpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\ndevpriv->command3_bits = 0;\r\ndevpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);\r\nreturn 0;\r\n}\r\nstatic enum scan_mode labpc_ai_scan_mode(const struct comedi_cmd *cmd)\r\n{\r\nif (cmd->chanlist_len == 1)\r\nreturn MODE_SINGLE_CHAN;\r\nif (cmd->chanlist == NULL)\r\nreturn MODE_MULT_CHAN_UP;\r\nif (CR_CHAN(cmd->chanlist[0]) == CR_CHAN(cmd->chanlist[1]))\r\nreturn MODE_SINGLE_CHAN_INTERVAL;\r\nif (CR_CHAN(cmd->chanlist[0]) < CR_CHAN(cmd->chanlist[1]))\r\nreturn MODE_MULT_CHAN_UP;\r\nif (CR_CHAN(cmd->chanlist[0]) > CR_CHAN(cmd->chanlist[1]))\r\nreturn MODE_MULT_CHAN_DOWN;\r\nprintk(KERN_ERR "ni_labpc: bug! this should never happen\n");\r\nreturn 0;\r\n}\r\nstatic int labpc_ai_chanlist_invalid(const struct comedi_device *dev,\r\nconst struct comedi_cmd *cmd)\r\n{\r\nint mode, channel, range, aref, i;\r\nif (cmd->chanlist == NULL)\r\nreturn 0;\r\nmode = labpc_ai_scan_mode(cmd);\r\nif (mode == MODE_SINGLE_CHAN)\r\nreturn 0;\r\nif (mode == MODE_SINGLE_CHAN_INTERVAL) {\r\nif (cmd->chanlist_len > 0xff) {\r\ncomedi_error(dev,\r\n"ni_labpc: chanlist too long for single channel interval mode\n");\r\nreturn 1;\r\n}\r\n}\r\nchannel = CR_CHAN(cmd->chanlist[0]);\r\nrange = CR_RANGE(cmd->chanlist[0]);\r\naref = CR_AREF(cmd->chanlist[0]);\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nswitch (mode) {\r\ncase MODE_SINGLE_CHAN_INTERVAL:\r\nif (CR_CHAN(cmd->chanlist[i]) != channel) {\r\ncomedi_error(dev,\r\n"channel scanning order specified in chanlist is not supported by hardware.\n");\r\nreturn 1;\r\n}\r\nbreak;\r\ncase MODE_MULT_CHAN_UP:\r\nif (CR_CHAN(cmd->chanlist[i]) != i) {\r\ncomedi_error(dev,\r\n"channel scanning order specified in chanlist is not supported by hardware.\n");\r\nreturn 1;\r\n}\r\nbreak;\r\ncase MODE_MULT_CHAN_DOWN:\r\nif (CR_CHAN(cmd->chanlist[i]) !=\r\ncmd->chanlist_len - i - 1) {\r\ncomedi_error(dev,\r\n"channel scanning order specified in chanlist is not supported by hardware.\n");\r\nreturn 1;\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "ni_labpc: bug! in chanlist check\n");\r\nreturn 1;\r\nbreak;\r\n}\r\nif (CR_RANGE(cmd->chanlist[i]) != range) {\r\ncomedi_error(dev,\r\n"entries in chanlist must all have the same range\n");\r\nreturn 1;\r\n}\r\nif (CR_AREF(cmd->chanlist[i]) != aref) {\r\ncomedi_error(dev,\r\n"entries in chanlist must all have the same reference\n");\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int labpc_use_continuous_mode(const struct comedi_cmd *cmd)\r\n{\r\nif (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN)\r\nreturn 1;\r\nif (cmd->scan_begin_src == TRIG_FOLLOW)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic unsigned int labpc_ai_convert_period(const struct comedi_cmd *cmd)\r\n{\r\nif (cmd->convert_src != TRIG_TIMER)\r\nreturn 0;\r\nif (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN &&\r\ncmd->scan_begin_src == TRIG_TIMER)\r\nreturn cmd->scan_begin_arg;\r\nreturn cmd->convert_arg;\r\n}\r\nstatic void labpc_set_ai_convert_period(struct comedi_cmd *cmd, unsigned int ns)\r\n{\r\nif (cmd->convert_src != TRIG_TIMER)\r\nreturn;\r\nif (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN &&\r\ncmd->scan_begin_src == TRIG_TIMER) {\r\ncmd->scan_begin_arg = ns;\r\nif (cmd->convert_arg > cmd->scan_begin_arg)\r\ncmd->convert_arg = cmd->scan_begin_arg;\r\n} else\r\ncmd->convert_arg = ns;\r\n}\r\nstatic unsigned int labpc_ai_scan_period(const struct comedi_cmd *cmd)\r\n{\r\nif (cmd->scan_begin_src != TRIG_TIMER)\r\nreturn 0;\r\nif (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN &&\r\ncmd->convert_src == TRIG_TIMER)\r\nreturn 0;\r\nreturn cmd->scan_begin_arg;\r\n}\r\nstatic void labpc_set_ai_scan_period(struct comedi_cmd *cmd, unsigned int ns)\r\n{\r\nif (cmd->scan_begin_src != TRIG_TIMER)\r\nreturn;\r\nif (labpc_ai_scan_mode(cmd) == MODE_SINGLE_CHAN &&\r\ncmd->convert_src == TRIG_TIMER)\r\nreturn;\r\ncmd->scan_begin_arg = ns;\r\n}\r\nstatic int labpc_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp, tmp2;\r\nint stop_mask;\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW | TRIG_EXT;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_TIMER | TRIG_FOLLOW | TRIG_EXT;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_TIMER | TRIG_EXT;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\nstop_mask = TRIG_COUNT | TRIG_NONE;\r\nif (thisboard->register_layout == labpc_1200_layout)\r\nstop_mask |= TRIG_EXT;\r\ncmd->stop_src &= stop_mask;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->scan_begin_src != TRIG_TIMER &&\r\ncmd->scan_begin_src != TRIG_FOLLOW &&\r\ncmd->scan_begin_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->stop_src != TRIG_COUNT &&\r\ncmd->stop_src != TRIG_EXT && cmd->stop_src != TRIG_NONE)\r\nerr++;\r\nif (cmd->start_src == TRIG_EXT && cmd->stop_src == TRIG_EXT)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_arg == TRIG_NOW && cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\nif (!cmd->chanlist_len)\r\nerr++;\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (cmd->convert_arg < thisboard->ai_speed) {\r\ncmd->convert_arg = thisboard->ai_speed;\r\nerr++;\r\n}\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (cmd->convert_src == TRIG_TIMER &&\r\ncmd->scan_begin_arg <\r\ncmd->convert_arg * cmd->chanlist_len) {\r\ncmd->scan_begin_arg =\r\ncmd->convert_arg * cmd->chanlist_len;\r\nerr++;\r\n}\r\nif (cmd->scan_begin_arg <\r\nthisboard->ai_speed * cmd->chanlist_len) {\r\ncmd->scan_begin_arg =\r\nthisboard->ai_speed * cmd->chanlist_len;\r\nerr++;\r\n}\r\n}\r\nswitch (cmd->stop_src) {\r\ncase TRIG_COUNT:\r\nif (!cmd->stop_arg) {\r\ncmd->stop_arg = 1;\r\nerr++;\r\n}\r\nbreak;\r\ncase TRIG_NONE:\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (err)\r\nreturn 3;\r\ntmp = cmd->convert_arg;\r\ntmp2 = cmd->scan_begin_arg;\r\nlabpc_adc_timing(dev, cmd);\r\nif (tmp != cmd->convert_arg || tmp2 != cmd->scan_begin_arg)\r\nerr++;\r\nif (err)\r\nreturn 4;\r\nif (labpc_ai_chanlist_invalid(dev, cmd))\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nint channel, range, aref;\r\n#ifdef CONFIG_ISA_DMA_API\r\nunsigned long irq_flags;\r\n#endif\r\nint ret;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nenum transfer_type xfer;\r\nunsigned long flags;\r\nif (!dev->irq) {\r\ncomedi_error(dev, "no irq assigned, cannot perform command");\r\nreturn -1;\r\n}\r\nrange = CR_RANGE(cmd->chanlist[0]);\r\naref = CR_AREF(cmd->chanlist[0]);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;\r\ndevpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\ndevpriv->command3_bits = 0;\r\ndevpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);\r\nif (cmd->stop_src == TRIG_COUNT)\r\ndevpriv->count = cmd->stop_arg * cmd->chanlist_len;\r\nif (cmd->stop_src == TRIG_EXT) {\r\nret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,\r\n1, 3, 0);\r\nif (ret < 0) {\r\ncomedi_error(dev, "error loading counter a1");\r\nreturn -1;\r\n}\r\n} else\r\ndevpriv->write_byte(INIT_A1_BITS,\r\ndev->iobase + COUNTER_A_CONTROL_REG);\r\n#ifdef CONFIG_ISA_DMA_API\r\nif (devpriv->dma_chan &&\r\n(cmd->flags & (TRIG_WAKE_EOS | TRIG_RT)) == 0 &&\r\nthisboard->bustype == isa_bustype) {\r\nxfer = isa_dma_transfer;\r\n} else\r\n#endif\r\nif (thisboard->register_layout == labpc_1200_layout &&\r\n(cmd->flags & TRIG_WAKE_EOS) == 0 &&\r\n(cmd->stop_src != TRIG_COUNT || devpriv->count > 256)) {\r\nxfer = fifo_half_full_transfer;\r\n} else\r\nxfer = fifo_not_empty_transfer;\r\ndevpriv->current_transfer = xfer;\r\nif (thisboard->register_layout == labpc_1200_layout) {\r\nif (aref != AREF_GROUND)\r\ndevpriv->command6_bits |= ADC_COMMON_BIT;\r\nelse\r\ndevpriv->command6_bits &= ~ADC_COMMON_BIT;\r\nif (thisboard->ai_range_is_unipolar[range])\r\ndevpriv->command6_bits |= ADC_UNIP_BIT;\r\nelse\r\ndevpriv->command6_bits &= ~ADC_UNIP_BIT;\r\nif (xfer == fifo_half_full_transfer)\r\ndevpriv->command6_bits |= ADC_FHF_INTR_EN_BIT;\r\nelse\r\ndevpriv->command6_bits &= ~ADC_FHF_INTR_EN_BIT;\r\nif (cmd->stop_src == TRIG_EXT)\r\ndevpriv->command6_bits |= A1_INTR_EN_BIT;\r\nelse\r\ndevpriv->command6_bits &= ~A1_INTR_EN_BIT;\r\nif (labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_UP)\r\ndevpriv->command6_bits |= ADC_SCAN_UP_BIT;\r\nelse\r\ndevpriv->command6_bits &= ~ADC_SCAN_UP_BIT;\r\ndevpriv->write_byte(devpriv->command6_bits,\r\ndev->iobase + COMMAND6_REG);\r\n}\r\ndevpriv->command1_bits = 0;\r\nif (labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_UP)\r\nchannel = CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]);\r\nelse\r\nchannel = CR_CHAN(cmd->chanlist[0]);\r\nif (labpc_ai_scan_mode(cmd) != MODE_SINGLE_CHAN && aref == AREF_DIFF)\r\nchannel *= 2;\r\ndevpriv->command1_bits |= ADC_CHAN_BITS(channel);\r\ndevpriv->command1_bits |= thisboard->ai_range_code[range];\r\ndevpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);\r\nif (labpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_UP ||\r\nlabpc_ai_scan_mode(cmd) == MODE_MULT_CHAN_DOWN) {\r\ndevpriv->command1_bits |= ADC_SCAN_EN_BIT;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->command1_bits,\r\ndev->iobase + COMMAND1_REG);\r\n}\r\ndevpriv->command4_bits = 0;\r\nif (cmd->convert_src != TRIG_EXT)\r\ndevpriv->command4_bits |= EXT_CONVERT_DISABLE_BIT;\r\nif (labpc_use_continuous_mode(cmd) == 0) {\r\ndevpriv->command4_bits |= INTERVAL_SCAN_EN_BIT;\r\nif (cmd->scan_begin_src == TRIG_EXT)\r\ndevpriv->command4_bits |= EXT_SCAN_EN_BIT;\r\n}\r\nif (aref == AREF_DIFF)\r\ndevpriv->command4_bits |= ADC_DIFF_BIT;\r\ndevpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);\r\ndevpriv->write_byte(cmd->chanlist_len,\r\ndev->iobase + INTERVAL_COUNT_REG);\r\ndevpriv->write_byte(INTERVAL_LOAD_BITS,\r\ndev->iobase + INTERVAL_LOAD_REG);\r\nif (cmd->convert_src == TRIG_TIMER || cmd->scan_begin_src == TRIG_TIMER) {\r\nlabpc_adc_timing(dev, cmd);\r\nret = labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,\r\n0, devpriv->divisor_b0, 3);\r\nif (ret < 0) {\r\ncomedi_error(dev, "error loading counter b0");\r\nreturn -1;\r\n}\r\n}\r\nif (labpc_ai_convert_period(cmd)) {\r\nret = labpc_counter_load(dev, dev->iobase + COUNTER_A_BASE_REG,\r\n0, devpriv->divisor_a0, 2);\r\nif (ret < 0) {\r\ncomedi_error(dev, "error loading counter a0");\r\nreturn -1;\r\n}\r\n} else\r\ndevpriv->write_byte(INIT_A0_BITS,\r\ndev->iobase + COUNTER_A_CONTROL_REG);\r\nif (labpc_ai_scan_period(cmd)) {\r\nret = labpc_counter_load(dev, dev->iobase + COUNTER_B_BASE_REG,\r\n1, devpriv->divisor_b1, 2);\r\nif (ret < 0) {\r\ncomedi_error(dev, "error loading counter b1");\r\nreturn -1;\r\n}\r\n}\r\nlabpc_clear_adc_fifo(dev);\r\n#ifdef CONFIG_ISA_DMA_API\r\nif (xfer == isa_dma_transfer) {\r\nirq_flags = claim_dma_lock();\r\ndisable_dma(devpriv->dma_chan);\r\nclear_dma_ff(devpriv->dma_chan);\r\nset_dma_addr(devpriv->dma_chan,\r\nvirt_to_bus(devpriv->dma_buffer));\r\ndevpriv->dma_transfer_size = labpc_suggest_transfer_size(*cmd);\r\nif (cmd->stop_src == TRIG_COUNT &&\r\ndevpriv->count * sample_size < devpriv->dma_transfer_size) {\r\ndevpriv->dma_transfer_size =\r\ndevpriv->count * sample_size;\r\n}\r\nset_dma_count(devpriv->dma_chan, devpriv->dma_transfer_size);\r\nenable_dma(devpriv->dma_chan);\r\nrelease_dma_lock(irq_flags);\r\ndevpriv->command3_bits |= DMA_EN_BIT | DMATC_INTR_EN_BIT;\r\n} else\r\ndevpriv->command3_bits &= ~DMA_EN_BIT & ~DMATC_INTR_EN_BIT;\r\n#endif\r\ndevpriv->command3_bits |= ERR_INTR_EN_BIT;\r\nif (xfer == fifo_not_empty_transfer)\r\ndevpriv->command3_bits |= ADC_FNE_INTR_EN_BIT;\r\nelse\r\ndevpriv->command3_bits &= ~ADC_FNE_INTR_EN_BIT;\r\ndevpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->command2_bits |= CASCADE_BIT;\r\nswitch (cmd->start_src) {\r\ncase TRIG_EXT:\r\ndevpriv->command2_bits |= HWTRIG_BIT;\r\ndevpriv->command2_bits &= ~PRETRIG_BIT & ~SWTRIG_BIT;\r\nbreak;\r\ncase TRIG_NOW:\r\ndevpriv->command2_bits |= SWTRIG_BIT;\r\ndevpriv->command2_bits &= ~PRETRIG_BIT & ~HWTRIG_BIT;\r\nbreak;\r\ndefault:\r\ncomedi_error(dev, "bug with start_src");\r\nreturn -1;\r\nbreak;\r\n}\r\nswitch (cmd->stop_src) {\r\ncase TRIG_EXT:\r\ndevpriv->command2_bits |= HWTRIG_BIT | PRETRIG_BIT;\r\nbreak;\r\ncase TRIG_COUNT:\r\ncase TRIG_NONE:\r\nbreak;\r\ndefault:\r\ncomedi_error(dev, "bug with stop_src");\r\nreturn -1;\r\n}\r\ndevpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t labpc_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async;\r\nstruct comedi_cmd *cmd;\r\nif (dev->attached == 0) {\r\ncomedi_error(dev, "premature interrupt");\r\nreturn IRQ_HANDLED;\r\n}\r\nasync = s->async;\r\ncmd = &async->cmd;\r\nasync->events = 0;\r\ndevpriv->status1_bits = devpriv->read_byte(dev->iobase + STATUS1_REG);\r\nif (thisboard->register_layout == labpc_1200_layout)\r\ndevpriv->status2_bits =\r\ndevpriv->read_byte(dev->iobase + STATUS2_REG);\r\nif ((devpriv->status1_bits & (DMATC_BIT | TIMER_BIT | OVERFLOW_BIT |\r\nOVERRUN_BIT | DATA_AVAIL_BIT)) == 0\r\n&& (devpriv->status2_bits & A1_TC_BIT) == 0\r\n&& (devpriv->status2_bits & FNHF_BIT)) {\r\nreturn IRQ_NONE;\r\n}\r\nif (devpriv->status1_bits & OVERRUN_BIT) {\r\ndevpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);\r\nasync->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;\r\ncomedi_event(dev, s);\r\ncomedi_error(dev, "overrun");\r\nreturn IRQ_HANDLED;\r\n}\r\n#ifdef CONFIG_ISA_DMA_API\r\nif (devpriv->current_transfer == isa_dma_transfer) {\r\nif (devpriv->status1_bits & DMATC_BIT ||\r\n(thisboard->register_layout == labpc_1200_layout\r\n&& devpriv->status2_bits & A1_TC_BIT)) {\r\nhandle_isa_dma(dev);\r\n}\r\n} else\r\n#endif\r\nlabpc_drain_fifo(dev);\r\nif (devpriv->status1_bits & TIMER_BIT) {\r\ncomedi_error(dev, "handled timer interrupt?");\r\ndevpriv->write_byte(0x1, dev->iobase + TIMER_CLEAR_REG);\r\n}\r\nif (devpriv->status1_bits & OVERFLOW_BIT) {\r\ndevpriv->write_byte(0x1, dev->iobase + ADC_CLEAR_REG);\r\nasync->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;\r\ncomedi_event(dev, s);\r\ncomedi_error(dev, "overflow");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (cmd->stop_src == TRIG_EXT) {\r\nif (devpriv->status2_bits & A1_TC_BIT) {\r\nlabpc_drain_dregs(dev);\r\nlabpc_cancel(dev, s);\r\nasync->events |= COMEDI_CB_EOA;\r\n}\r\n}\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (devpriv->count == 0) {\r\nlabpc_cancel(dev, s);\r\nasync->events |= COMEDI_CB_EOA;\r\n}\r\n}\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int labpc_drain_fifo(struct comedi_device *dev)\r\n{\r\nunsigned int lsb, msb;\r\nshort data;\r\nstruct comedi_async *async = dev->read_subdev->async;\r\nconst int timeout = 10000;\r\nunsigned int i;\r\ndevpriv->status1_bits = devpriv->read_byte(dev->iobase + STATUS1_REG);\r\nfor (i = 0; (devpriv->status1_bits & DATA_AVAIL_BIT) && i < timeout;\r\ni++) {\r\nif (async->cmd.stop_src == TRIG_COUNT) {\r\nif (devpriv->count == 0)\r\nbreak;\r\ndevpriv->count--;\r\n}\r\nlsb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);\r\nmsb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);\r\ndata = (msb << 8) | lsb;\r\ncfc_write_to_buffer(dev->read_subdev, data);\r\ndevpriv->status1_bits =\r\ndevpriv->read_byte(dev->iobase + STATUS1_REG);\r\n}\r\nif (i == timeout) {\r\ncomedi_error(dev, "ai timeout, fifo never empties");\r\nasync->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void labpc_drain_dma(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async = s->async;\r\nint status;\r\nunsigned long flags;\r\nunsigned int max_points, num_points, residue, leftover;\r\nint i;\r\nstatus = devpriv->status1_bits;\r\nflags = claim_dma_lock();\r\ndisable_dma(devpriv->dma_chan);\r\nclear_dma_ff(devpriv->dma_chan);\r\nmax_points = devpriv->dma_transfer_size / sample_size;\r\nresidue = get_dma_residue(devpriv->dma_chan) / sample_size;\r\nnum_points = max_points - residue;\r\nif (devpriv->count < num_points && async->cmd.stop_src == TRIG_COUNT)\r\nnum_points = devpriv->count;\r\nleftover = 0;\r\nif (async->cmd.stop_src != TRIG_COUNT) {\r\nleftover = devpriv->dma_transfer_size / sample_size;\r\n} else if (devpriv->count > num_points) {\r\nleftover = devpriv->count - num_points;\r\nif (leftover > max_points)\r\nleftover = max_points;\r\n}\r\nfor (i = 0; i < num_points; i++)\r\ncfc_write_to_buffer(s, devpriv->dma_buffer[i]);\r\nif (async->cmd.stop_src == TRIG_COUNT)\r\ndevpriv->count -= num_points;\r\nset_dma_addr(devpriv->dma_chan, virt_to_bus(devpriv->dma_buffer));\r\nset_dma_count(devpriv->dma_chan, leftover * sample_size);\r\nrelease_dma_lock(flags);\r\nasync->events |= COMEDI_CB_BLOCK;\r\n}\r\nstatic void handle_isa_dma(struct comedi_device *dev)\r\n{\r\nlabpc_drain_dma(dev);\r\nenable_dma(devpriv->dma_chan);\r\ndevpriv->write_byte(0x1, dev->iobase + DMATC_CLEAR_REG);\r\n}\r\nstatic void labpc_drain_dregs(struct comedi_device *dev)\r\n{\r\n#ifdef CONFIG_ISA_DMA_API\r\nif (devpriv->current_transfer == isa_dma_transfer)\r\nlabpc_drain_dma(dev);\r\n#endif\r\nlabpc_drain_fifo(dev);\r\n}\r\nstatic int labpc_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i, n;\r\nint chan, range;\r\nint lsb, msb;\r\nint timeout = 1000;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->command2_bits &= ~SWTRIG_BIT & ~HWTRIG_BIT & ~PRETRIG_BIT;\r\ndevpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\ndevpriv->command3_bits = 0;\r\ndevpriv->write_byte(devpriv->command3_bits, dev->iobase + COMMAND3_REG);\r\ndevpriv->command1_bits = 0;\r\nchan = CR_CHAN(insn->chanspec);\r\nrange = CR_RANGE(insn->chanspec);\r\ndevpriv->command1_bits |= thisboard->ai_range_code[range];\r\nif (CR_AREF(insn->chanspec) == AREF_DIFF)\r\nchan *= 2;\r\ndevpriv->command1_bits |= ADC_CHAN_BITS(chan);\r\ndevpriv->write_byte(devpriv->command1_bits, dev->iobase + COMMAND1_REG);\r\nif (thisboard->register_layout == labpc_1200_layout) {\r\nif (CR_AREF(insn->chanspec) != AREF_GROUND)\r\ndevpriv->command6_bits |= ADC_COMMON_BIT;\r\nelse\r\ndevpriv->command6_bits &= ~ADC_COMMON_BIT;\r\nif (thisboard->ai_range_is_unipolar[range])\r\ndevpriv->command6_bits |= ADC_UNIP_BIT;\r\nelse\r\ndevpriv->command6_bits &= ~ADC_UNIP_BIT;\r\ndevpriv->command6_bits &= ~ADC_FHF_INTR_EN_BIT;\r\ndevpriv->command6_bits &= ~A1_INTR_EN_BIT;\r\ndevpriv->write_byte(devpriv->command6_bits,\r\ndev->iobase + COMMAND6_REG);\r\n}\r\ndevpriv->command4_bits = 0;\r\ndevpriv->command4_bits |= EXT_CONVERT_DISABLE_BIT;\r\nif (CR_AREF(insn->chanspec) == AREF_DIFF)\r\ndevpriv->command4_bits |= ADC_DIFF_BIT;\r\ndevpriv->write_byte(devpriv->command4_bits, dev->iobase + COMMAND4_REG);\r\ndevpriv->write_byte(INIT_A0_BITS, dev->iobase + COUNTER_A_CONTROL_REG);\r\nlabpc_clear_adc_fifo(dev);\r\nfor (n = 0; n < insn->n; n++) {\r\ndevpriv->write_byte(0x1, dev->iobase + ADC_CONVERT_REG);\r\nfor (i = 0; i < timeout; i++) {\r\nif (devpriv->read_byte(dev->iobase +\r\nSTATUS1_REG) & DATA_AVAIL_BIT)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (i == timeout) {\r\ncomedi_error(dev, "timeout");\r\nreturn -ETIME;\r\n}\r\nlsb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);\r\nmsb = devpriv->read_byte(dev->iobase + ADC_FIFO_REG);\r\ndata[n] = (msb << 8) | lsb;\r\n}\r\nreturn n;\r\n}\r\nstatic int labpc_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint channel, range;\r\nunsigned long flags;\r\nint lsb, msb;\r\nchannel = CR_CHAN(insn->chanspec);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndevpriv->command2_bits &= ~DAC_PACED_BIT(channel);\r\ndevpriv->write_byte(devpriv->command2_bits, dev->iobase + COMMAND2_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nif (thisboard->register_layout == labpc_1200_layout) {\r\nrange = CR_RANGE(insn->chanspec);\r\nif (range & AO_RANGE_IS_UNIPOLAR)\r\ndevpriv->command6_bits |= DAC_UNIP_BIT(channel);\r\nelse\r\ndevpriv->command6_bits &= ~DAC_UNIP_BIT(channel);\r\ndevpriv->write_byte(devpriv->command6_bits,\r\ndev->iobase + COMMAND6_REG);\r\n}\r\nlsb = data[0] & 0xff;\r\nmsb = (data[0] >> 8) & 0xff;\r\ndevpriv->write_byte(lsb, dev->iobase + DAC_LSB_REG(channel));\r\ndevpriv->write_byte(msb, dev->iobase + DAC_MSB_REG(channel));\r\ndevpriv->ao_value[channel] = data[0];\r\nreturn 1;\r\n}\r\nstatic int labpc_ao_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[0] = devpriv->ao_value[CR_CHAN(insn->chanspec)];\r\nreturn 1;\r\n}\r\nstatic int labpc_calib_read_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[0] = devpriv->caldac[CR_CHAN(insn->chanspec)];\r\nreturn 1;\r\n}\r\nstatic int labpc_calib_write_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint channel = CR_CHAN(insn->chanspec);\r\nwrite_caldac(dev, channel, data[0]);\r\nreturn 1;\r\n}\r\nstatic int labpc_eeprom_read_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[0] = devpriv->eeprom_data[CR_CHAN(insn->chanspec)];\r\nreturn 1;\r\n}\r\nstatic int labpc_eeprom_write_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint channel = CR_CHAN(insn->chanspec);\r\nint ret;\r\nif (channel < 16 || channel > 127) {\r\nprintk\r\n("eeprom writes are only allowed to channels 16 through 127 (the pointer and user areas)");\r\nreturn -EINVAL;\r\n}\r\nret = labpc_eeprom_write(dev, channel, data[0]);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 1;\r\n}\r\nstatic unsigned int labpc_suggest_transfer_size(struct comedi_cmd cmd)\r\n{\r\nunsigned int size;\r\nunsigned int freq;\r\nif (cmd.convert_src == TRIG_TIMER)\r\nfreq = 1000000000 / cmd.convert_arg;\r\nelse\r\nfreq = 0xffffffff;\r\nsize = (freq / 3) * sample_size;\r\nif (size > dma_buffer_size)\r\nsize = dma_buffer_size - dma_buffer_size % sample_size;\r\nelse if (size < sample_size)\r\nsize = sample_size;\r\nreturn size;\r\n}\r\nstatic void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)\r\n{\r\nconst int max_counter_value = 0x10000;\r\nconst int min_counter_value = 2;\r\nunsigned int base_period;\r\nif (labpc_ai_convert_period(cmd) && labpc_ai_scan_period(cmd)) {\r\ndevpriv->divisor_b0 = (labpc_ai_scan_period(cmd) - 1) /\r\n(LABPC_TIMER_BASE * max_counter_value) + 1;\r\nif (devpriv->divisor_b0 < min_counter_value)\r\ndevpriv->divisor_b0 = min_counter_value;\r\nif (devpriv->divisor_b0 > max_counter_value)\r\ndevpriv->divisor_b0 = max_counter_value;\r\nbase_period = LABPC_TIMER_BASE * devpriv->divisor_b0;\r\nswitch (cmd->flags & TRIG_ROUND_MASK) {\r\ndefault:\r\ncase TRIG_ROUND_NEAREST:\r\ndevpriv->divisor_a0 =\r\n(labpc_ai_convert_period(cmd) +\r\n(base_period / 2)) / base_period;\r\ndevpriv->divisor_b1 =\r\n(labpc_ai_scan_period(cmd) +\r\n(base_period / 2)) / base_period;\r\nbreak;\r\ncase TRIG_ROUND_UP:\r\ndevpriv->divisor_a0 =\r\n(labpc_ai_convert_period(cmd) + (base_period -\r\n1)) / base_period;\r\ndevpriv->divisor_b1 =\r\n(labpc_ai_scan_period(cmd) + (base_period -\r\n1)) / base_period;\r\nbreak;\r\ncase TRIG_ROUND_DOWN:\r\ndevpriv->divisor_a0 =\r\nlabpc_ai_convert_period(cmd) / base_period;\r\ndevpriv->divisor_b1 =\r\nlabpc_ai_scan_period(cmd) / base_period;\r\nbreak;\r\n}\r\nif (devpriv->divisor_a0 < min_counter_value)\r\ndevpriv->divisor_a0 = min_counter_value;\r\nif (devpriv->divisor_a0 > max_counter_value)\r\ndevpriv->divisor_a0 = max_counter_value;\r\nif (devpriv->divisor_b1 < min_counter_value)\r\ndevpriv->divisor_b1 = min_counter_value;\r\nif (devpriv->divisor_b1 > max_counter_value)\r\ndevpriv->divisor_b1 = max_counter_value;\r\nlabpc_set_ai_convert_period(cmd,\r\nbase_period * devpriv->divisor_a0);\r\nlabpc_set_ai_scan_period(cmd,\r\nbase_period * devpriv->divisor_b1);\r\n} else if (labpc_ai_scan_period(cmd)) {\r\nunsigned int scan_period;\r\nscan_period = labpc_ai_scan_period(cmd);\r\ni8253_cascade_ns_to_timer_2div(LABPC_TIMER_BASE,\r\n&(devpriv->divisor_b1),\r\n&(devpriv->divisor_b0),\r\n&scan_period,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nlabpc_set_ai_scan_period(cmd, scan_period);\r\n} else if (labpc_ai_convert_period(cmd)) {\r\nunsigned int convert_period;\r\nconvert_period = labpc_ai_convert_period(cmd);\r\ni8253_cascade_ns_to_timer_2div(LABPC_TIMER_BASE,\r\n&(devpriv->divisor_a0),\r\n&(devpriv->divisor_b0),\r\n&convert_period,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nlabpc_set_ai_convert_period(cmd, convert_period);\r\n}\r\n}\r\nstatic int labpc_dio_mem_callback(int dir, int port, int data,\r\nunsigned long iobase)\r\n{\r\nif (dir) {\r\nwriteb(data, (void *)(iobase + port));\r\nreturn 0;\r\n} else {\r\nreturn readb((void *)(iobase + port));\r\n}\r\n}\r\nstatic void labpc_serial_out(struct comedi_device *dev, unsigned int value,\r\nunsigned int value_width)\r\n{\r\nint i;\r\nfor (i = 1; i <= value_width; i++) {\r\ndevpriv->command5_bits &= ~SCLOCK_BIT;\r\nif (value & (1 << (value_width - i)))\r\ndevpriv->command5_bits |= SDATA_BIT;\r\nelse\r\ndevpriv->command5_bits &= ~SDATA_BIT;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->command5_bits,\r\ndev->iobase + COMMAND5_REG);\r\ndevpriv->command5_bits |= SCLOCK_BIT;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->command5_bits,\r\ndev->iobase + COMMAND5_REG);\r\n}\r\n}\r\nstatic unsigned int labpc_serial_in(struct comedi_device *dev)\r\n{\r\nunsigned int value = 0;\r\nint i;\r\nconst int value_width = 8;\r\nfor (i = 1; i <= value_width; i++) {\r\ndevpriv->command5_bits |= SCLOCK_BIT;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->command5_bits,\r\ndev->iobase + COMMAND5_REG);\r\ndevpriv->command5_bits &= ~SCLOCK_BIT;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->command5_bits,\r\ndev->iobase + COMMAND5_REG);\r\nudelay(1);\r\ndevpriv->status2_bits =\r\ndevpriv->read_byte(dev->iobase + STATUS2_REG);\r\nif (devpriv->status2_bits & EEPROM_OUT_BIT)\r\nvalue |= 1 << (value_width - i);\r\n}\r\nreturn value;\r\n}\r\nstatic unsigned int labpc_eeprom_read(struct comedi_device *dev,\r\nunsigned int address)\r\n{\r\nunsigned int value;\r\nconst int read_instruction = 0x3;\r\nconst int write_length = 8;\r\ndevpriv->command5_bits &= ~EEPROM_EN_BIT;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);\r\ndevpriv->command5_bits |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);\r\nlabpc_serial_out(dev, read_instruction, write_length);\r\nlabpc_serial_out(dev, address, write_length);\r\nvalue = labpc_serial_in(dev);\r\ndevpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);\r\nreturn value;\r\n}\r\nstatic int labpc_eeprom_write(struct comedi_device *dev,\r\nunsigned int address, unsigned int value)\r\n{\r\nconst int write_enable_instruction = 0x6;\r\nconst int write_instruction = 0x2;\r\nconst int write_length = 8;\r\nconst int write_in_progress_bit = 0x1;\r\nconst int timeout = 10000;\r\nint i;\r\nfor (i = 0; i < timeout; i++) {\r\nif ((labpc_eeprom_read_status(dev) & write_in_progress_bit) ==\r\n0)\r\nbreak;\r\n}\r\nif (i == timeout) {\r\ncomedi_error(dev, "eeprom write timed out");\r\nreturn -ETIME;\r\n}\r\ndevpriv->eeprom_data[address] = value;\r\ndevpriv->command5_bits &= ~EEPROM_EN_BIT;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);\r\ndevpriv->command5_bits |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);\r\nlabpc_serial_out(dev, write_enable_instruction, write_length);\r\ndevpriv->command5_bits &= ~EEPROM_EN_BIT;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);\r\ndevpriv->command5_bits |= EEPROM_EN_BIT;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);\r\nlabpc_serial_out(dev, write_instruction, write_length);\r\nlabpc_serial_out(dev, address, write_length);\r\nlabpc_serial_out(dev, value, write_length);\r\ndevpriv->command5_bits &= ~EEPROM_EN_BIT;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);\r\ndevpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);\r\nreturn 0;\r\n}\r\nstatic unsigned int labpc_eeprom_read_status(struct comedi_device *dev)\r\n{\r\nunsigned int value;\r\nconst int read_status_instruction = 0x5;\r\nconst int write_length = 8;\r\ndevpriv->command5_bits &= ~EEPROM_EN_BIT;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);\r\ndevpriv->command5_bits |= EEPROM_EN_BIT | EEPROM_WRITE_UNPROTECT_BIT;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);\r\nlabpc_serial_out(dev, read_status_instruction, write_length);\r\nvalue = labpc_serial_in(dev);\r\ndevpriv->command5_bits &= ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);\r\nreturn value;\r\n}\r\nstatic void write_caldac(struct comedi_device *dev, unsigned int channel,\r\nunsigned int value)\r\n{\r\nif (value == devpriv->caldac[channel])\r\nreturn;\r\ndevpriv->caldac[channel] = value;\r\ndevpriv->command5_bits &=\r\n~CALDAC_LOAD_BIT & ~EEPROM_EN_BIT & ~EEPROM_WRITE_UNPROTECT_BIT;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);\r\nlabpc_serial_out(dev, channel, 4);\r\nlabpc_serial_out(dev, value, 8);\r\ndevpriv->command5_bits |= CALDAC_LOAD_BIT;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);\r\ndevpriv->command5_bits &= ~CALDAC_LOAD_BIT;\r\nudelay(1);\r\ndevpriv->write_byte(devpriv->command5_bits, dev->iobase + COMMAND5_REG);\r\n}\r\nstatic int __devinit driver_labpc_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nreturn comedi_pci_auto_config(dev, driver_labpc.driver_name);\r\n}\r\nstatic void __devexit driver_labpc_pci_remove(struct pci_dev *dev)\r\n{\r\ncomedi_pci_auto_unconfig(dev);\r\n}\r\nstatic int __init driver_labpc_init_module(void)\r\n{\r\nint retval;\r\nretval = comedi_driver_register(&driver_labpc);\r\nif (retval < 0)\r\nreturn retval;\r\ndriver_labpc_pci_driver.name = (char *)driver_labpc.driver_name;\r\nreturn pci_register_driver(&driver_labpc_pci_driver);\r\n}\r\nstatic void __exit driver_labpc_cleanup_module(void)\r\n{\r\npci_unregister_driver(&driver_labpc_pci_driver);\r\ncomedi_driver_unregister(&driver_labpc);\r\n}\r\nstatic int __init driver_labpc_init_module(void)\r\n{\r\nreturn comedi_driver_register(&driver_labpc);\r\n}\r\nstatic void __exit driver_labpc_cleanup_module(void)\r\n{\r\ncomedi_driver_unregister(&driver_labpc);\r\n}
