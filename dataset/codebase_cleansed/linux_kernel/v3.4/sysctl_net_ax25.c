void ax25_register_sysctl(void)\r\n{\r\nax25_dev *ax25_dev;\r\nint n, k;\r\nspin_lock_bh(&ax25_dev_lock);\r\nfor (ax25_table_size = sizeof(ctl_table), ax25_dev = ax25_dev_list; ax25_dev != NULL; ax25_dev = ax25_dev->next)\r\nax25_table_size += sizeof(ctl_table);\r\nif ((ax25_table = kzalloc(ax25_table_size, GFP_ATOMIC)) == NULL) {\r\nspin_unlock_bh(&ax25_dev_lock);\r\nreturn;\r\n}\r\nfor (n = 0, ax25_dev = ax25_dev_list; ax25_dev != NULL; ax25_dev = ax25_dev->next) {\r\nstruct ctl_table *child = kmemdup(ax25_param_table,\r\nsizeof(ax25_param_table),\r\nGFP_ATOMIC);\r\nif (!child) {\r\nwhile (n--)\r\nkfree(ax25_table[n].child);\r\nkfree(ax25_table);\r\nspin_unlock_bh(&ax25_dev_lock);\r\nreturn;\r\n}\r\nax25_table[n].child = ax25_dev->systable = child;\r\nax25_table[n].procname = ax25_dev->dev->name;\r\nax25_table[n].mode = 0555;\r\nfor (k = 0; k < AX25_MAX_VALUES; k++)\r\nchild[k].data = &ax25_dev->values[k];\r\nn++;\r\n}\r\nspin_unlock_bh(&ax25_dev_lock);\r\nax25_table_header = register_sysctl_paths(ax25_path, ax25_table);\r\n}\r\nvoid ax25_unregister_sysctl(void)\r\n{\r\nctl_table *p;\r\nunregister_sysctl_table(ax25_table_header);\r\nfor (p = ax25_table; p->procname; p++)\r\nkfree(p->child);\r\nkfree(ax25_table);\r\n}
