static ssize_t state_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct switch_dev *sdev = (struct switch_dev *)\r\ndev_get_drvdata(dev);\r\nif (sdev->print_state) {\r\nint ret = sdev->print_state(sdev, buf);\r\nif (ret >= 0)\r\nreturn ret;\r\n}\r\nreturn sprintf(buf, "%d\n", sdev->state);\r\n}\r\nstatic ssize_t name_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct switch_dev *sdev = (struct switch_dev *)\r\ndev_get_drvdata(dev);\r\nif (sdev->print_name) {\r\nint ret = sdev->print_name(sdev, buf);\r\nif (ret >= 0)\r\nreturn ret;\r\n}\r\nreturn sprintf(buf, "%s\n", sdev->name);\r\n}\r\nvoid switch_set_state(struct switch_dev *sdev, int state)\r\n{\r\nchar name_buf[120];\r\nchar state_buf[120];\r\nchar *prop_buf;\r\nchar *envp[3];\r\nint env_offset = 0;\r\nint length;\r\nif (sdev->state != state) {\r\nsdev->state = state;\r\nprop_buf = (char *)get_zeroed_page(GFP_KERNEL);\r\nif (prop_buf) {\r\nlength = name_show(sdev->dev, NULL, prop_buf);\r\nif (length > 0) {\r\nif (prop_buf[length - 1] == '\n')\r\nprop_buf[length - 1] = 0;\r\nsnprintf(name_buf, sizeof(name_buf),\r\n"SWITCH_NAME=%s", prop_buf);\r\nenvp[env_offset++] = name_buf;\r\n}\r\nlength = state_show(sdev->dev, NULL, prop_buf);\r\nif (length > 0) {\r\nif (prop_buf[length - 1] == '\n')\r\nprop_buf[length - 1] = 0;\r\nsnprintf(state_buf, sizeof(state_buf),\r\n"SWITCH_STATE=%s", prop_buf);\r\nenvp[env_offset++] = state_buf;\r\n}\r\nenvp[env_offset] = NULL;\r\nkobject_uevent_env(&sdev->dev->kobj, KOBJ_CHANGE, envp);\r\nfree_page((unsigned long)prop_buf);\r\n} else {\r\nprintk(KERN_ERR "out of memory in switch_set_state\n");\r\nkobject_uevent(&sdev->dev->kobj, KOBJ_CHANGE);\r\n}\r\n}\r\n}\r\nstatic int create_switch_class(void)\r\n{\r\nif (!switch_class) {\r\nswitch_class = class_create(THIS_MODULE, "switch");\r\nif (IS_ERR(switch_class))\r\nreturn PTR_ERR(switch_class);\r\natomic_set(&device_count, 0);\r\n}\r\nreturn 0;\r\n}\r\nint switch_dev_register(struct switch_dev *sdev)\r\n{\r\nint ret;\r\nif (!switch_class) {\r\nret = create_switch_class();\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nsdev->index = atomic_inc_return(&device_count);\r\nsdev->dev = device_create(switch_class, NULL,\r\nMKDEV(0, sdev->index), NULL, sdev->name);\r\nif (IS_ERR(sdev->dev))\r\nreturn PTR_ERR(sdev->dev);\r\nret = device_create_file(sdev->dev, &dev_attr_state);\r\nif (ret < 0)\r\ngoto err_create_file_1;\r\nret = device_create_file(sdev->dev, &dev_attr_name);\r\nif (ret < 0)\r\ngoto err_create_file_2;\r\ndev_set_drvdata(sdev->dev, sdev);\r\nsdev->state = 0;\r\nreturn 0;\r\nerr_create_file_2:\r\ndevice_remove_file(sdev->dev, &dev_attr_state);\r\nerr_create_file_1:\r\ndevice_destroy(switch_class, MKDEV(0, sdev->index));\r\nprintk(KERN_ERR "switch: Failed to register driver %s\n", sdev->name);\r\nreturn ret;\r\n}\r\nvoid switch_dev_unregister(struct switch_dev *sdev)\r\n{\r\ndevice_remove_file(sdev->dev, &dev_attr_name);\r\ndevice_remove_file(sdev->dev, &dev_attr_state);\r\ndevice_destroy(switch_class, MKDEV(0, sdev->index));\r\ndev_set_drvdata(sdev->dev, NULL);\r\n}\r\nstatic int __init switch_class_init(void)\r\n{\r\nreturn create_switch_class();\r\n}\r\nstatic void __exit switch_class_exit(void)\r\n{\r\nclass_destroy(switch_class);\r\n}
