static void nes_replenish_mgt_rq(struct nes_vnic_mgt *mgtvnic)\r\n{\r\nunsigned long flags;\r\ndma_addr_t bus_address;\r\nstruct sk_buff *skb;\r\nstruct nes_hw_nic_rq_wqe *nic_rqe;\r\nstruct nes_hw_mgt *nesmgt;\r\nstruct nes_device *nesdev;\r\nstruct nes_rskb_cb *cb;\r\nu32 rx_wqes_posted = 0;\r\nnesmgt = &mgtvnic->mgt;\r\nnesdev = mgtvnic->nesvnic->nesdev;\r\nspin_lock_irqsave(&nesmgt->rq_lock, flags);\r\nif (nesmgt->replenishing_rq != 0) {\r\nif (((nesmgt->rq_size - 1) == atomic_read(&mgtvnic->rx_skbs_needed)) &&\r\n(atomic_read(&mgtvnic->rx_skb_timer_running) == 0)) {\r\natomic_set(&mgtvnic->rx_skb_timer_running, 1);\r\nspin_unlock_irqrestore(&nesmgt->rq_lock, flags);\r\nmgtvnic->rq_wqes_timer.expires = jiffies + (HZ / 2);\r\nadd_timer(&mgtvnic->rq_wqes_timer);\r\n} else {\r\nspin_unlock_irqrestore(&nesmgt->rq_lock, flags);\r\n}\r\nreturn;\r\n}\r\nnesmgt->replenishing_rq = 1;\r\nspin_unlock_irqrestore(&nesmgt->rq_lock, flags);\r\ndo {\r\nskb = dev_alloc_skb(mgtvnic->nesvnic->max_frame_size);\r\nif (skb) {\r\nskb->dev = mgtvnic->nesvnic->netdev;\r\nbus_address = pci_map_single(nesdev->pcidev,\r\nskb->data, mgtvnic->nesvnic->max_frame_size, PCI_DMA_FROMDEVICE);\r\ncb = (struct nes_rskb_cb *)&skb->cb[0];\r\ncb->busaddr = bus_address;\r\ncb->maplen = mgtvnic->nesvnic->max_frame_size;\r\nnic_rqe = &nesmgt->rq_vbase[mgtvnic->mgt.rq_head];\r\nnic_rqe->wqe_words[NES_NIC_RQ_WQE_LENGTH_1_0_IDX] =\r\ncpu_to_le32(mgtvnic->nesvnic->max_frame_size);\r\nnic_rqe->wqe_words[NES_NIC_RQ_WQE_LENGTH_3_2_IDX] = 0;\r\nnic_rqe->wqe_words[NES_NIC_RQ_WQE_FRAG0_LOW_IDX] =\r\ncpu_to_le32((u32)bus_address);\r\nnic_rqe->wqe_words[NES_NIC_RQ_WQE_FRAG0_HIGH_IDX] =\r\ncpu_to_le32((u32)((u64)bus_address >> 32));\r\nnesmgt->rx_skb[nesmgt->rq_head] = skb;\r\nnesmgt->rq_head++;\r\nnesmgt->rq_head &= nesmgt->rq_size - 1;\r\natomic_dec(&mgtvnic->rx_skbs_needed);\r\nbarrier();\r\nif (++rx_wqes_posted == 255) {\r\nnes_write32(nesdev->regs + NES_WQE_ALLOC, (rx_wqes_posted << 24) | nesmgt->qp_id);\r\nrx_wqes_posted = 0;\r\n}\r\n} else {\r\nspin_lock_irqsave(&nesmgt->rq_lock, flags);\r\nif (((nesmgt->rq_size - 1) == atomic_read(&mgtvnic->rx_skbs_needed)) &&\r\n(atomic_read(&mgtvnic->rx_skb_timer_running) == 0)) {\r\natomic_set(&mgtvnic->rx_skb_timer_running, 1);\r\nspin_unlock_irqrestore(&nesmgt->rq_lock, flags);\r\nmgtvnic->rq_wqes_timer.expires = jiffies + (HZ / 2);\r\nadd_timer(&mgtvnic->rq_wqes_timer);\r\n} else {\r\nspin_unlock_irqrestore(&nesmgt->rq_lock, flags);\r\n}\r\nbreak;\r\n}\r\n} while (atomic_read(&mgtvnic->rx_skbs_needed));\r\nbarrier();\r\nif (rx_wqes_posted)\r\nnes_write32(nesdev->regs + NES_WQE_ALLOC, (rx_wqes_posted << 24) | nesmgt->qp_id);\r\nnesmgt->replenishing_rq = 0;\r\n}\r\nstatic void nes_mgt_rq_wqes_timeout(unsigned long parm)\r\n{\r\nstruct nes_vnic_mgt *mgtvnic = (struct nes_vnic_mgt *)parm;\r\natomic_set(&mgtvnic->rx_skb_timer_running, 0);\r\nif (atomic_read(&mgtvnic->rx_skbs_needed))\r\nnes_replenish_mgt_rq(mgtvnic);\r\n}\r\nstatic void nes_mgt_free_skb(struct nes_device *nesdev, struct sk_buff *skb, u32 dir)\r\n{\r\nstruct nes_rskb_cb *cb;\r\ncb = (struct nes_rskb_cb *)&skb->cb[0];\r\npci_unmap_single(nesdev->pcidev, cb->busaddr, cb->maplen, dir);\r\ncb->busaddr = 0;\r\ndev_kfree_skb_any(skb);\r\n}\r\nstatic void nes_download_callback(struct nes_device *nesdev, struct nes_cqp_request *cqp_request)\r\n{\r\nstruct pau_fpdu_info *fpdu_info = cqp_request->cqp_callback_pointer;\r\nstruct nes_qp *nesqp = fpdu_info->nesqp;\r\nstruct sk_buff *skb;\r\nint i;\r\nfor (i = 0; i < fpdu_info->frag_cnt; i++) {\r\nskb = fpdu_info->frags[i].skb;\r\nif (fpdu_info->frags[i].cmplt) {\r\nnes_mgt_free_skb(nesdev, skb, PCI_DMA_TODEVICE);\r\nnes_rem_ref_cm_node(nesqp->cm_node);\r\n}\r\n}\r\nif (fpdu_info->hdr_vbase)\r\npci_free_consistent(nesdev->pcidev, fpdu_info->hdr_len,\r\nfpdu_info->hdr_vbase, fpdu_info->hdr_pbase);\r\nkfree(fpdu_info);\r\n}\r\nstatic u32 nes_get_seq(struct sk_buff *skb, u32 *ack, u16 *wnd, u32 *fin_rcvd, u32 *rst_rcvd)\r\n{\r\nstruct nes_rskb_cb *cb = (struct nes_rskb_cb *)&skb->cb[0];\r\nstruct iphdr *iph = (struct iphdr *)(cb->data_start + ETH_HLEN);\r\nstruct tcphdr *tcph = (struct tcphdr *)(((char *)iph) + (4 * iph->ihl));\r\n*ack = be32_to_cpu(tcph->ack_seq);\r\n*wnd = be16_to_cpu(tcph->window);\r\n*fin_rcvd = tcph->fin;\r\n*rst_rcvd = tcph->rst;\r\nreturn be32_to_cpu(tcph->seq);\r\n}\r\nstatic struct sk_buff *nes_get_next_skb(struct nes_device *nesdev, struct nes_qp *nesqp,\r\nstruct sk_buff *skb, u32 nextseq, u32 *ack,\r\nu16 *wnd, u32 *fin_rcvd, u32 *rst_rcvd)\r\n{\r\nu32 seq;\r\nbool processacks;\r\nstruct sk_buff *old_skb;\r\nif (skb) {\r\nif (skb->next == (struct sk_buff *)&nesqp->pau_list)\r\ngoto out;\r\nskb = skb->next;\r\nprocessacks = false;\r\n} else {\r\nif (skb_queue_empty(&nesqp->pau_list))\r\ngoto out;\r\nskb = skb_peek(&nesqp->pau_list);\r\nprocessacks = true;\r\n}\r\nwhile (1) {\r\nseq = nes_get_seq(skb, ack, wnd, fin_rcvd, rst_rcvd);\r\nif (seq == nextseq) {\r\nif (skb->len || processacks)\r\nbreak;\r\n} else if (after(seq, nextseq)) {\r\ngoto out;\r\n}\r\nif (skb->next == (struct sk_buff *)&nesqp->pau_list)\r\ngoto out;\r\nold_skb = skb;\r\nskb = skb->next;\r\nskb_unlink(old_skb, &nesqp->pau_list);\r\nnes_mgt_free_skb(nesdev, old_skb, PCI_DMA_TODEVICE);\r\nnes_rem_ref_cm_node(nesqp->cm_node);\r\n}\r\nreturn skb;\r\nout:\r\nreturn NULL;\r\n}\r\nstatic int get_fpdu_info(struct nes_device *nesdev, struct nes_qp *nesqp,\r\nstruct pau_fpdu_info **pau_fpdu_info)\r\n{\r\nstruct sk_buff *skb;\r\nstruct iphdr *iph;\r\nstruct tcphdr *tcph;\r\nstruct nes_rskb_cb *cb;\r\nstruct pau_fpdu_info *fpdu_info = NULL;\r\nstruct pau_fpdu_frag frags[MAX_FPDU_FRAGS];\r\nunsigned long flags;\r\nu32 fpdu_len = 0;\r\nu32 tmp_len;\r\nint frag_cnt = 0;\r\nu32 tot_len;\r\nu32 frag_tot;\r\nu32 ack;\r\nu32 fin_rcvd;\r\nu32 rst_rcvd;\r\nu16 wnd;\r\nint i;\r\nint rc = 0;\r\n*pau_fpdu_info = NULL;\r\nspin_lock_irqsave(&nesqp->pau_lock, flags);\r\nskb = nes_get_next_skb(nesdev, nesqp, NULL, nesqp->pau_rcv_nxt, &ack, &wnd, &fin_rcvd, &rst_rcvd);\r\nif (!skb) {\r\nspin_unlock_irqrestore(&nesqp->pau_lock, flags);\r\ngoto out;\r\n}\r\ncb = (struct nes_rskb_cb *)&skb->cb[0];\r\nif (skb->len) {\r\nfpdu_len = be16_to_cpu(*(__be16 *) skb->data) + MPA_FRAMING;\r\nfpdu_len = (fpdu_len + 3) & 0xfffffffc;\r\ntmp_len = fpdu_len;\r\nfrag_tot = 0;\r\nmemset(&frags, 0, sizeof frags);\r\nfor (i = 0; i < MAX_FPDU_FRAGS; i++) {\r\nfrags[i].physaddr = cb->busaddr;\r\nfrags[i].physaddr += skb->data - cb->data_start;\r\nfrags[i].frag_len = min(tmp_len, skb->len);\r\nfrags[i].skb = skb;\r\nfrags[i].cmplt = (skb->len == frags[i].frag_len);\r\nfrag_tot += frags[i].frag_len;\r\nfrag_cnt++;\r\ntmp_len -= frags[i].frag_len;\r\nif (tmp_len == 0)\r\nbreak;\r\nskb = nes_get_next_skb(nesdev, nesqp, skb,\r\nnesqp->pau_rcv_nxt + frag_tot, &ack, &wnd, &fin_rcvd, &rst_rcvd);\r\nif (!skb) {\r\nspin_unlock_irqrestore(&nesqp->pau_lock, flags);\r\ngoto out;\r\n} else if (rst_rcvd) {\r\nfor (; i >= 0; i--) {\r\nskb_unlink(frags[i].skb, &nesqp->pau_list);\r\nnes_mgt_free_skb(nesdev, frags[i].skb, PCI_DMA_TODEVICE);\r\n}\r\ncb = (struct nes_rskb_cb *)&skb->cb[0];\r\nfrags[0].physaddr = cb->busaddr;\r\nfrags[0].physaddr += skb->data - cb->data_start;\r\nfrags[0].frag_len = skb->len;\r\nfrags[0].skb = skb;\r\nfrags[0].cmplt = true;\r\nfrag_cnt = 1;\r\nbreak;\r\n}\r\ncb = (struct nes_rskb_cb *)&skb->cb[0];\r\n}\r\n} else {\r\nfrags[0].physaddr = cb->busaddr;\r\nfrags[0].frag_len = 0;\r\nfrags[0].skb = skb;\r\nfrags[0].cmplt = true;\r\nfrag_cnt = 1;\r\n}\r\nspin_unlock_irqrestore(&nesqp->pau_lock, flags);\r\nfpdu_info = kzalloc(sizeof(*fpdu_info), GFP_ATOMIC);\r\nif (fpdu_info == NULL) {\r\nnes_debug(NES_DBG_PAU, "Failed to alloc a fpdu_info.\n");\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nfpdu_info->cqp_request = nes_get_cqp_request(nesdev);\r\nif (fpdu_info->cqp_request == NULL) {\r\nnes_debug(NES_DBG_PAU, "Failed to get a cqp_request.\n");\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\ncb = (struct nes_rskb_cb *)&frags[0].skb->cb[0];\r\niph = (struct iphdr *)(cb->data_start + ETH_HLEN);\r\ntcph = (struct tcphdr *)(((char *)iph) + (4 * iph->ihl));\r\nfpdu_info->hdr_len = (((unsigned char *)tcph) + 4 * (tcph->doff)) - cb->data_start;\r\nfpdu_info->data_len = fpdu_len;\r\ntot_len = fpdu_info->hdr_len + fpdu_len - ETH_HLEN;\r\nif (frags[0].cmplt) {\r\nfpdu_info->hdr_pbase = cb->busaddr;\r\nfpdu_info->hdr_vbase = NULL;\r\n} else {\r\nfpdu_info->hdr_vbase = pci_alloc_consistent(nesdev->pcidev,\r\nfpdu_info->hdr_len, &fpdu_info->hdr_pbase);\r\nif (!fpdu_info->hdr_vbase) {\r\nnes_debug(NES_DBG_PAU, "Unable to allocate memory for pau first frag\n");\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nmemcpy(fpdu_info->hdr_vbase, cb->data_start, fpdu_info->hdr_len);\r\niph = (struct iphdr *)(fpdu_info->hdr_vbase + ETH_HLEN);\r\ntcph = (struct tcphdr *)(((char *)iph) + (4 * iph->ihl));\r\n}\r\niph->tot_len = cpu_to_be16(tot_len);\r\niph->saddr = cpu_to_be32(0x7f000001);\r\ntcph->seq = cpu_to_be32(nesqp->pau_rcv_nxt);\r\ntcph->ack_seq = cpu_to_be32(ack);\r\ntcph->window = cpu_to_be16(wnd);\r\nnesqp->pau_rcv_nxt += fpdu_len + fin_rcvd;\r\nmemcpy(fpdu_info->frags, frags, sizeof(fpdu_info->frags));\r\nfpdu_info->frag_cnt = frag_cnt;\r\nfpdu_info->nesqp = nesqp;\r\n*pau_fpdu_info = fpdu_info;\r\nfor (i = 0; i < frag_cnt; i++) {\r\ncb = (struct nes_rskb_cb *)&frags[i].skb->cb[0];\r\nskb_pull(frags[i].skb, frags[i].frag_len);\r\nif (frags[i].skb->len == 0) {\r\nspin_lock_irqsave(&nesqp->pau_lock, flags);\r\nskb_unlink(frags[i].skb, &nesqp->pau_list);\r\nspin_unlock_irqrestore(&nesqp->pau_lock, flags);\r\n} else {\r\niph = (struct iphdr *)(cb->data_start + ETH_HLEN);\r\ntcph = (struct tcphdr *)(((char *)iph) + (4 * iph->ihl));\r\ntcph->seq = cpu_to_be32(nesqp->pau_rcv_nxt);\r\n}\r\n}\r\nout:\r\nif (rc) {\r\nif (fpdu_info) {\r\nif (fpdu_info->cqp_request)\r\nnes_put_cqp_request(nesdev, fpdu_info->cqp_request);\r\nkfree(fpdu_info);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int forward_fpdus(struct nes_vnic *nesvnic, struct nes_qp *nesqp)\r\n{\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct pau_fpdu_info *fpdu_info;\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nstruct nes_cqp_request *cqp_request;\r\nu64 u64tmp;\r\nu32 u32tmp;\r\nint rc;\r\nwhile (1) {\r\nrc = get_fpdu_info(nesdev, nesqp, &fpdu_info);\r\nif (fpdu_info == NULL)\r\nreturn rc;\r\ncqp_request = fpdu_info->cqp_request;\r\ncqp_wqe = &cqp_request->cqp_wqe;\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_DL_OPCODE_IDX,\r\nNES_CQP_DOWNLOAD_SEGMENT |\r\n(((u32)nesvnic->logical_port) << NES_CQP_OP_LOGICAL_PORT_SHIFT));\r\nu32tmp = fpdu_info->hdr_len << 16;\r\nu32tmp |= fpdu_info->hdr_len + (u32)fpdu_info->data_len;\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_DL_LENGTH_0_TOTAL_IDX,\r\nu32tmp);\r\nu32tmp = (fpdu_info->frags[1].frag_len << 16) | fpdu_info->frags[0].frag_len;\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_NIC_SQ_WQE_LENGTH_2_1_IDX,\r\nu32tmp);\r\nu32tmp = (fpdu_info->frags[3].frag_len << 16) | fpdu_info->frags[2].frag_len;\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_NIC_SQ_WQE_LENGTH_4_3_IDX,\r\nu32tmp);\r\nu64tmp = (u64)fpdu_info->hdr_pbase;\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_NIC_SQ_WQE_FRAG0_LOW_IDX,\r\nlower_32_bits(u64tmp));\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_NIC_SQ_WQE_FRAG0_HIGH_IDX,\r\nupper_32_bits(u64tmp >> 32));\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_NIC_SQ_WQE_FRAG1_LOW_IDX,\r\nlower_32_bits(fpdu_info->frags[0].physaddr));\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_NIC_SQ_WQE_FRAG1_HIGH_IDX,\r\nupper_32_bits(fpdu_info->frags[0].physaddr));\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_NIC_SQ_WQE_FRAG2_LOW_IDX,\r\nlower_32_bits(fpdu_info->frags[1].physaddr));\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_NIC_SQ_WQE_FRAG2_HIGH_IDX,\r\nupper_32_bits(fpdu_info->frags[1].physaddr));\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_NIC_SQ_WQE_FRAG3_LOW_IDX,\r\nlower_32_bits(fpdu_info->frags[2].physaddr));\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_NIC_SQ_WQE_FRAG3_HIGH_IDX,\r\nupper_32_bits(fpdu_info->frags[2].physaddr));\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_NIC_SQ_WQE_FRAG4_LOW_IDX,\r\nlower_32_bits(fpdu_info->frags[3].physaddr));\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_NIC_SQ_WQE_FRAG4_HIGH_IDX,\r\nupper_32_bits(fpdu_info->frags[3].physaddr));\r\ncqp_request->cqp_callback_pointer = fpdu_info;\r\ncqp_request->callback = 1;\r\ncqp_request->cqp_callback = nes_download_callback;\r\natomic_set(&cqp_request->refcount, 1);\r\nnes_post_cqp_request(nesdev, cqp_request);\r\n}\r\nreturn 0;\r\n}\r\nstatic void process_fpdus(struct nes_vnic *nesvnic, struct nes_qp *nesqp)\r\n{\r\nint again = 1;\r\nunsigned long flags;\r\ndo {\r\nforward_fpdus(nesvnic, nesqp);\r\nspin_lock_irqsave(&nesqp->pau_lock, flags);\r\nif (nesqp->pau_pending) {\r\nnesqp->pau_pending = 0;\r\n} else {\r\nnesqp->pau_busy = 0;\r\nagain = 0;\r\n}\r\nspin_unlock_irqrestore(&nesqp->pau_lock, flags);\r\n} while (again);\r\n}\r\nstatic void queue_fpdus(struct sk_buff *skb, struct nes_vnic *nesvnic, struct nes_qp *nesqp)\r\n{\r\nstruct sk_buff *tmpskb;\r\nstruct nes_rskb_cb *cb;\r\nstruct iphdr *iph;\r\nstruct tcphdr *tcph;\r\nunsigned char *tcph_end;\r\nu32 rcv_nxt;\r\nu32 rcv_wnd;\r\nu32 seqnum;\r\nu32 len;\r\nbool process_it = false;\r\nunsigned long flags;\r\niph = (struct iphdr *)skb->data;\r\ntcph = (struct tcphdr *)(((char *)iph) + (4 * iph->ihl));\r\nseqnum = be32_to_cpu(tcph->seq);\r\ntcph_end = (((char *)tcph) + (4 * tcph->doff));\r\nlen = be16_to_cpu(iph->tot_len);\r\nif (skb->len > len)\r\nskb_trim(skb, len);\r\nskb_pull(skb, tcph_end - skb->data);\r\ncb = (struct nes_rskb_cb *)&skb->cb[0];\r\ncb->seqnum = seqnum;\r\nrcv_nxt = nesqp->pau_rcv_nxt;\r\nrcv_wnd = le32_to_cpu(nesqp->nesqp_context->rcv_wnd);\r\nif (!between(seqnum, rcv_nxt, (rcv_nxt + rcv_wnd))) {\r\nnes_mgt_free_skb(nesvnic->nesdev, skb, PCI_DMA_TODEVICE);\r\nnes_rem_ref_cm_node(nesqp->cm_node);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&nesqp->pau_lock, flags);\r\nif (nesqp->pau_busy)\r\nnesqp->pau_pending = 1;\r\nelse\r\nnesqp->pau_busy = 1;\r\nif (skb_queue_len(&nesqp->pau_list) == 0) {\r\nskb_queue_head(&nesqp->pau_list, skb);\r\n} else {\r\ntmpskb = nesqp->pau_list.next;\r\nwhile (tmpskb != (struct sk_buff *)&nesqp->pau_list) {\r\ncb = (struct nes_rskb_cb *)&tmpskb->cb[0];\r\nif (before(seqnum, cb->seqnum))\r\nbreak;\r\ntmpskb = tmpskb->next;\r\n}\r\nskb_insert(tmpskb, skb, &nesqp->pau_list);\r\n}\r\nif (nesqp->pau_state == PAU_READY)\r\nprocess_it = true;\r\nspin_unlock_irqrestore(&nesqp->pau_lock, flags);\r\nif (process_it)\r\nprocess_fpdus(nesvnic, nesqp);\r\nreturn;\r\n}\r\nstatic int mgt_thread(void *context)\r\n{\r\nstruct nes_vnic *nesvnic = context;\r\nstruct sk_buff *skb;\r\nstruct nes_rskb_cb *cb;\r\nwhile (!kthread_should_stop()) {\r\nwait_event_interruptible(nesvnic->mgt_wait_queue,\r\nskb_queue_len(&nesvnic->mgt_skb_list) || kthread_should_stop());\r\nwhile ((skb_queue_len(&nesvnic->mgt_skb_list)) && !kthread_should_stop()) {\r\nskb = skb_dequeue(&nesvnic->mgt_skb_list);\r\ncb = (struct nes_rskb_cb *)&skb->cb[0];\r\ncb->data_start = skb->data - ETH_HLEN;\r\ncb->busaddr = pci_map_single(nesvnic->nesdev->pcidev, cb->data_start,\r\nnesvnic->max_frame_size, PCI_DMA_TODEVICE);\r\nqueue_fpdus(skb, nesvnic, cb->nesqp);\r\n}\r\n}\r\nwhile (skb_queue_len(&nesvnic->mgt_skb_list)) {\r\nskb = skb_dequeue(&nesvnic->mgt_skb_list);\r\ncb = (struct nes_rskb_cb *)&skb->cb[0];\r\nnes_rem_ref_cm_node(cb->nesqp->cm_node);\r\ndev_kfree_skb_any(skb);\r\n}\r\nreturn 0;\r\n}\r\nvoid nes_queue_mgt_skbs(struct sk_buff *skb, struct nes_vnic *nesvnic, struct nes_qp *nesqp)\r\n{\r\nstruct nes_rskb_cb *cb;\r\ncb = (struct nes_rskb_cb *)&skb->cb[0];\r\ncb->nesqp = nesqp;\r\nskb_queue_tail(&nesvnic->mgt_skb_list, skb);\r\nwake_up_interruptible(&nesvnic->mgt_wait_queue);\r\n}\r\nvoid nes_destroy_pau_qp(struct nes_device *nesdev, struct nes_qp *nesqp)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\natomic_inc(&pau_qps_destroyed);\r\nspin_lock_irqsave(&nesqp->pau_lock, flags);\r\nwhile (skb_queue_len(&nesqp->pau_list)) {\r\nskb = skb_dequeue(&nesqp->pau_list);\r\nnes_mgt_free_skb(nesdev, skb, PCI_DMA_TODEVICE);\r\nnes_rem_ref_cm_node(nesqp->cm_node);\r\n}\r\nspin_unlock_irqrestore(&nesqp->pau_lock, flags);\r\n}\r\nstatic void nes_chg_qh_handler(struct nes_device *nesdev, struct nes_cqp_request *cqp_request)\r\n{\r\nstruct pau_qh_chg *qh_chg = cqp_request->cqp_callback_pointer;\r\nstruct nes_cqp_request *new_request;\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nstruct nes_adapter *nesadapter;\r\nstruct nes_qp *nesqp;\r\nstruct nes_v4_quad nes_quad;\r\nu32 crc_value;\r\nu64 u64temp;\r\nnesadapter = nesdev->nesadapter;\r\nnesqp = qh_chg->nesqp;\r\nif (cqp_request->major_code) {\r\nprintk(KERN_ERR PFX "Invalid cqp_request major_code=0x%x\n",\r\ncqp_request->major_code);\r\nWARN_ON(1);\r\n}\r\nswitch (nesqp->pau_state) {\r\ncase PAU_DEL_QH:\r\nnesqp->pau_state = PAU_ADD_LB_QH;\r\nnew_request = nes_get_cqp_request(nesdev);\r\nif (new_request == NULL) {\r\nnes_debug(NES_DBG_PAU, "Failed to get a new_request.\n");\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nmemset(&nes_quad, 0, sizeof(nes_quad));\r\nnes_quad.DstIpAdrIndex =\r\ncpu_to_le32((u32)PCI_FUNC(nesdev->pcidev->devfn) << 24);\r\nnes_quad.SrcIpadr = cpu_to_be32(0x7f000001);\r\nnes_quad.TcpPorts[0] = swab16(nesqp->nesqp_context->tcpPorts[1]);\r\nnes_quad.TcpPorts[1] = swab16(nesqp->nesqp_context->tcpPorts[0]);\r\ncrc_value = get_crc_value(&nes_quad);\r\nnesqp->hte_index = cpu_to_be32(crc_value ^ 0xffffffff);\r\nnes_debug(NES_DBG_PAU, "new HTE Index = 0x%08X, CRC = 0x%08X\n",\r\nnesqp->hte_index, nesqp->hte_index & nesadapter->hte_index_mask);\r\nnesqp->hte_index &= nesadapter->hte_index_mask;\r\nnesqp->nesqp_context->hte_index = cpu_to_le32(nesqp->hte_index);\r\nnesqp->nesqp_context->ip0 = cpu_to_le32(0x7f000001);\r\nnesqp->nesqp_context->rcv_nxt = cpu_to_le32(nesqp->pau_rcv_nxt);\r\ncqp_wqe = &new_request->cqp_wqe;\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words,\r\nNES_CQP_WQE_OPCODE_IDX, NES_CQP_MANAGE_QUAD_HASH |\r\nNES_CQP_QP_TYPE_IWARP | NES_CQP_QP_CONTEXT_VALID | NES_CQP_QP_IWARP_STATE_RTS);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_ID_IDX, nesqp->hwqp.qp_id);\r\nu64temp = (u64)nesqp->nesqp_context_pbase;\r\nset_wqe_64bit_value(cqp_wqe->wqe_words, NES_CQP_QP_WQE_CONTEXT_LOW_IDX, u64temp);\r\nnes_debug(NES_DBG_PAU, "Waiting for CQP completion for adding the quad hash.\n");\r\nnew_request->cqp_callback_pointer = qh_chg;\r\nnew_request->callback = 1;\r\nnew_request->cqp_callback = nes_chg_qh_handler;\r\natomic_set(&new_request->refcount, 1);\r\nnes_post_cqp_request(nesdev, new_request);\r\nbreak;\r\ncase PAU_ADD_LB_QH:\r\nnesqp->pau_state = PAU_READY;\r\nprocess_fpdus(qh_chg->nesvnic, qh_chg->nesqp);\r\nkfree(qh_chg);\r\nbreak;\r\n}\r\n}\r\nstatic int nes_change_quad_hash(struct nes_device *nesdev,\r\nstruct nes_vnic *nesvnic, struct nes_qp *nesqp)\r\n{\r\nstruct nes_cqp_request *cqp_request = NULL;\r\nstruct pau_qh_chg *qh_chg = NULL;\r\nu64 u64temp;\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nint ret = 0;\r\ncqp_request = nes_get_cqp_request(nesdev);\r\nif (cqp_request == NULL) {\r\nnes_debug(NES_DBG_PAU, "Failed to get a cqp_request.\n");\r\nret = -ENOMEM;\r\ngoto chg_qh_err;\r\n}\r\nqh_chg = kmalloc(sizeof *qh_chg, GFP_ATOMIC);\r\nif (qh_chg == NULL) {\r\nnes_debug(NES_DBG_PAU, "Failed to get a cqp_request.\n");\r\nret = -ENOMEM;\r\ngoto chg_qh_err;\r\n}\r\nqh_chg->nesdev = nesdev;\r\nqh_chg->nesvnic = nesvnic;\r\nqh_chg->nesqp = nesqp;\r\nnesqp->pau_state = PAU_DEL_QH;\r\ncqp_wqe = &cqp_request->cqp_wqe;\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words,\r\nNES_CQP_WQE_OPCODE_IDX, NES_CQP_MANAGE_QUAD_HASH | NES_CQP_QP_DEL_HTE |\r\nNES_CQP_QP_TYPE_IWARP | NES_CQP_QP_CONTEXT_VALID | NES_CQP_QP_IWARP_STATE_RTS);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_ID_IDX, nesqp->hwqp.qp_id);\r\nu64temp = (u64)nesqp->nesqp_context_pbase;\r\nset_wqe_64bit_value(cqp_wqe->wqe_words, NES_CQP_QP_WQE_CONTEXT_LOW_IDX, u64temp);\r\nnes_debug(NES_DBG_PAU, "Waiting for CQP completion for deleting the quad hash.\n");\r\ncqp_request->cqp_callback_pointer = qh_chg;\r\ncqp_request->callback = 1;\r\ncqp_request->cqp_callback = nes_chg_qh_handler;\r\natomic_set(&cqp_request->refcount, 1);\r\nnes_post_cqp_request(nesdev, cqp_request);\r\nreturn ret;\r\nchg_qh_err:\r\nkfree(qh_chg);\r\nif (cqp_request)\r\nnes_put_cqp_request(nesdev, cqp_request);\r\nreturn ret;\r\n}\r\nstatic void nes_mgt_ce_handler(struct nes_device *nesdev, struct nes_hw_nic_cq *cq)\r\n{\r\nstruct nes_vnic_mgt *mgtvnic = container_of(cq, struct nes_vnic_mgt, mgt_cq);\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nu32 head;\r\nu32 cq_size;\r\nu32 cqe_count = 0;\r\nu32 cqe_misc;\r\nu32 qp_id = 0;\r\nu32 skbs_needed;\r\nunsigned long context;\r\nstruct nes_qp *nesqp;\r\nstruct sk_buff *rx_skb;\r\nstruct nes_rskb_cb *cb;\r\nhead = cq->cq_head;\r\ncq_size = cq->cq_size;\r\nwhile (1) {\r\ncqe_misc = le32_to_cpu(cq->cq_vbase[head].cqe_words[NES_NIC_CQE_MISC_IDX]);\r\nif (!(cqe_misc & NES_NIC_CQE_VALID))\r\nbreak;\r\nnesqp = NULL;\r\nif (cqe_misc & NES_NIC_CQE_ACCQP_VALID) {\r\nqp_id = le32_to_cpu(cq->cq_vbase[head].cqe_words[NES_NIC_CQE_ACCQP_ID_IDX]);\r\nqp_id &= 0x001fffff;\r\nif (qp_id < nesadapter->max_qp) {\r\ncontext = (unsigned long)nesadapter->qp_table[qp_id - NES_FIRST_QPN];\r\nnesqp = (struct nes_qp *)context;\r\n}\r\n}\r\nif (nesqp) {\r\nif (nesqp->pau_mode == false) {\r\nnesqp->pau_mode = true;\r\nnesqp->pau_rcv_nxt = le32_to_cpu(\r\ncq->cq_vbase[head].cqe_words[NES_NIC_CQE_HASH_RCVNXT]);\r\nskb_queue_head_init(&nesqp->pau_list);\r\nspin_lock_init(&nesqp->pau_lock);\r\natomic_inc(&pau_qps_created);\r\nnes_change_quad_hash(nesdev, mgtvnic->nesvnic, nesqp);\r\n}\r\nrx_skb = mgtvnic->mgt.rx_skb[mgtvnic->mgt.rq_tail];\r\nrx_skb->len = 0;\r\nskb_put(rx_skb, cqe_misc & 0x0000ffff);\r\nrx_skb->protocol = eth_type_trans(rx_skb, mgtvnic->nesvnic->netdev);\r\ncb = (struct nes_rskb_cb *)&rx_skb->cb[0];\r\npci_unmap_single(nesdev->pcidev, cb->busaddr, cb->maplen, PCI_DMA_FROMDEVICE);\r\ncb->busaddr = 0;\r\nmgtvnic->mgt.rq_tail++;\r\nmgtvnic->mgt.rq_tail &= mgtvnic->mgt.rq_size - 1;\r\nnes_add_ref_cm_node(nesqp->cm_node);\r\nnes_queue_mgt_skbs(rx_skb, mgtvnic->nesvnic, nesqp);\r\n} else {\r\nprintk(KERN_ERR PFX "Invalid QP %d for packed/unaligned handling\n", qp_id);\r\n}\r\ncq->cq_vbase[head].cqe_words[NES_NIC_CQE_MISC_IDX] = 0;\r\ncqe_count++;\r\nif (++head >= cq_size)\r\nhead = 0;\r\nif (cqe_count == 255) {\r\nnes_write32(nesdev->regs + NES_CQE_ALLOC, cq->cq_number | (cqe_count << 16));\r\nnesdev->currcq_count += cqe_count;\r\ncqe_count = 0;\r\n}\r\nskbs_needed = atomic_inc_return(&mgtvnic->rx_skbs_needed);\r\nif (skbs_needed > (mgtvnic->mgt.rq_size >> 1))\r\nnes_replenish_mgt_rq(mgtvnic);\r\n}\r\ncq->cq_head = head;\r\nnes_write32(nesdev->regs + NES_CQE_ALLOC, NES_CQE_ALLOC_NOTIFY_NEXT |\r\ncq->cq_number | (cqe_count << 16));\r\nnes_read32(nesdev->regs + NES_CQE_ALLOC);\r\nnesdev->currcq_count += cqe_count;\r\n}\r\nint nes_init_mgt_qp(struct nes_device *nesdev, struct net_device *netdev, struct nes_vnic *nesvnic)\r\n{\r\nstruct nes_vnic_mgt *mgtvnic;\r\nu32 counter;\r\nvoid *vmem;\r\ndma_addr_t pmem;\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nu32 cqp_head;\r\nunsigned long flags;\r\nstruct nes_hw_nic_qp_context *mgt_context;\r\nu64 u64temp;\r\nstruct nes_hw_nic_rq_wqe *mgt_rqe;\r\nstruct sk_buff *skb;\r\nu32 wqe_count;\r\nstruct nes_rskb_cb *cb;\r\nu32 mgt_mem_size;\r\nvoid *mgt_vbase;\r\ndma_addr_t mgt_pbase;\r\nint i;\r\nint ret;\r\nmgtvnic = kzalloc(NES_MGT_QP_COUNT * sizeof(struct nes_vnic_mgt), GFP_KERNEL);\r\nif (mgtvnic == NULL) {\r\nnes_debug(NES_DBG_INIT, "Unable to allocate memory for mgt structure\n");\r\nreturn -ENOMEM;\r\n}\r\nmgt_mem_size = 256 +\r\n(NES_MGT_WQ_COUNT * sizeof(struct nes_hw_nic_rq_wqe)) +\r\n(NES_MGT_WQ_COUNT * sizeof(struct nes_hw_nic_cqe)) +\r\nsizeof(struct nes_hw_nic_qp_context);\r\nmgt_mem_size = (mgt_mem_size + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);\r\nmgt_vbase = pci_alloc_consistent(nesdev->pcidev, NES_MGT_QP_COUNT * mgt_mem_size, &mgt_pbase);\r\nif (!mgt_vbase) {\r\nkfree(mgtvnic);\r\nnes_debug(NES_DBG_INIT, "Unable to allocate memory for mgt host descriptor rings\n");\r\nreturn -ENOMEM;\r\n}\r\nnesvnic->mgt_mem_size = NES_MGT_QP_COUNT * mgt_mem_size;\r\nnesvnic->mgt_vbase = mgt_vbase;\r\nnesvnic->mgt_pbase = mgt_pbase;\r\nskb_queue_head_init(&nesvnic->mgt_skb_list);\r\ninit_waitqueue_head(&nesvnic->mgt_wait_queue);\r\nnesvnic->mgt_thread = kthread_run(mgt_thread, nesvnic, "nes_mgt_thread");\r\nfor (i = 0; i < NES_MGT_QP_COUNT; i++) {\r\nmgtvnic->nesvnic = nesvnic;\r\nmgtvnic->mgt.qp_id = nesdev->mac_index + NES_MGT_QP_OFFSET + i;\r\nmemset(mgt_vbase, 0, mgt_mem_size);\r\nnes_debug(NES_DBG_INIT, "Allocated mgt QP structures at %p (phys = %016lX), size = %u.\n",\r\nmgt_vbase, (unsigned long)mgt_pbase, mgt_mem_size);\r\nvmem = (void *)(((unsigned long)mgt_vbase + (256 - 1)) &\r\n~(unsigned long)(256 - 1));\r\npmem = (dma_addr_t)(((unsigned long long)mgt_pbase + (256 - 1)) &\r\n~(unsigned long long)(256 - 1));\r\nspin_lock_init(&mgtvnic->mgt.rq_lock);\r\nmgtvnic->mgt.rq_vbase = vmem;\r\nmgtvnic->mgt.rq_pbase = pmem;\r\nmgtvnic->mgt.rq_head = 0;\r\nmgtvnic->mgt.rq_tail = 0;\r\nmgtvnic->mgt.rq_size = NES_MGT_WQ_COUNT;\r\nvmem += (NES_MGT_WQ_COUNT * sizeof(struct nes_hw_nic_rq_wqe));\r\npmem += (NES_MGT_WQ_COUNT * sizeof(struct nes_hw_nic_rq_wqe));\r\nmgtvnic->mgt_cq.cq_number = mgtvnic->mgt.qp_id;\r\nmgtvnic->mgt_cq.cq_vbase = vmem;\r\nmgtvnic->mgt_cq.cq_pbase = pmem;\r\nmgtvnic->mgt_cq.cq_head = 0;\r\nmgtvnic->mgt_cq.cq_size = NES_MGT_WQ_COUNT;\r\nmgtvnic->mgt_cq.ce_handler = nes_mgt_ce_handler;\r\nspin_lock_irqsave(&nesdev->cqp.lock, flags);\r\ncqp_head = nesdev->cqp.sq_head;\r\ncqp_wqe = &nesdev->cqp.sq_vbase[cqp_head];\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\ncqp_wqe->wqe_words[NES_CQP_WQE_OPCODE_IDX] = cpu_to_le32(\r\nNES_CQP_CREATE_CQ | NES_CQP_CQ_CEQ_VALID |\r\n((u32)mgtvnic->mgt_cq.cq_size << 16));\r\ncqp_wqe->wqe_words[NES_CQP_WQE_ID_IDX] = cpu_to_le32(\r\nmgtvnic->mgt_cq.cq_number | ((u32)nesdev->ceq_index << 16));\r\nu64temp = (u64)mgtvnic->mgt_cq.cq_pbase;\r\nset_wqe_64bit_value(cqp_wqe->wqe_words, NES_CQP_CQ_WQE_PBL_LOW_IDX, u64temp);\r\ncqp_wqe->wqe_words[NES_CQP_CQ_WQE_CQ_CONTEXT_HIGH_IDX] = 0;\r\nu64temp = (unsigned long)&mgtvnic->mgt_cq;\r\ncqp_wqe->wqe_words[NES_CQP_CQ_WQE_CQ_CONTEXT_LOW_IDX] = cpu_to_le32((u32)(u64temp >> 1));\r\ncqp_wqe->wqe_words[NES_CQP_CQ_WQE_CQ_CONTEXT_HIGH_IDX] =\r\ncpu_to_le32(((u32)((u64temp) >> 33)) & 0x7FFFFFFF);\r\ncqp_wqe->wqe_words[NES_CQP_CQ_WQE_DOORBELL_INDEX_HIGH_IDX] = 0;\r\nif (++cqp_head >= nesdev->cqp.sq_size)\r\ncqp_head = 0;\r\ncqp_wqe = &nesdev->cqp.sq_vbase[cqp_head];\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nmgt_context = (void *)(&mgtvnic->mgt_cq.cq_vbase[mgtvnic->mgt_cq.cq_size]);\r\nmgt_context->context_words[NES_NIC_CTX_MISC_IDX] =\r\ncpu_to_le32((u32)NES_MGT_CTX_SIZE |\r\n((u32)PCI_FUNC(nesdev->pcidev->devfn) << 12));\r\nnes_debug(NES_DBG_INIT, "RX_WINDOW_BUFFER_PAGE_TABLE_SIZE = 0x%08X, RX_WINDOW_BUFFER_SIZE = 0x%08X\n",\r\nnes_read_indexed(nesdev, NES_IDX_RX_WINDOW_BUFFER_PAGE_TABLE_SIZE),\r\nnes_read_indexed(nesdev, NES_IDX_RX_WINDOW_BUFFER_SIZE));\r\nif (nes_read_indexed(nesdev, NES_IDX_RX_WINDOW_BUFFER_SIZE) != 0)\r\nmgt_context->context_words[NES_NIC_CTX_MISC_IDX] |= cpu_to_le32(NES_NIC_BACK_STORE);\r\nu64temp = (u64)mgtvnic->mgt.rq_pbase;\r\nmgt_context->context_words[NES_NIC_CTX_SQ_LOW_IDX] = cpu_to_le32((u32)u64temp);\r\nmgt_context->context_words[NES_NIC_CTX_SQ_HIGH_IDX] = cpu_to_le32((u32)(u64temp >> 32));\r\nu64temp = (u64)mgtvnic->mgt.rq_pbase;\r\nmgt_context->context_words[NES_NIC_CTX_RQ_LOW_IDX] = cpu_to_le32((u32)u64temp);\r\nmgt_context->context_words[NES_NIC_CTX_RQ_HIGH_IDX] = cpu_to_le32((u32)(u64temp >> 32));\r\ncqp_wqe->wqe_words[NES_CQP_WQE_OPCODE_IDX] = cpu_to_le32(NES_CQP_CREATE_QP |\r\nNES_CQP_QP_TYPE_NIC);\r\ncqp_wqe->wqe_words[NES_CQP_WQE_ID_IDX] = cpu_to_le32(mgtvnic->mgt.qp_id);\r\nu64temp = (u64)mgtvnic->mgt_cq.cq_pbase +\r\n(mgtvnic->mgt_cq.cq_size * sizeof(struct nes_hw_nic_cqe));\r\nset_wqe_64bit_value(cqp_wqe->wqe_words, NES_CQP_QP_WQE_CONTEXT_LOW_IDX, u64temp);\r\nif (++cqp_head >= nesdev->cqp.sq_size)\r\ncqp_head = 0;\r\nnesdev->cqp.sq_head = cqp_head;\r\nbarrier();\r\nnes_write32(nesdev->regs + NES_WQE_ALLOC, 0x02800000 | nesdev->cqp.qp_id);\r\nspin_unlock_irqrestore(&nesdev->cqp.lock, flags);\r\nnes_debug(NES_DBG_INIT, "Waiting for create MGT QP%u to complete.\n",\r\nmgtvnic->mgt.qp_id);\r\nret = wait_event_timeout(nesdev->cqp.waitq, (nesdev->cqp.sq_tail == cqp_head),\r\nNES_EVENT_TIMEOUT);\r\nnes_debug(NES_DBG_INIT, "Create MGT QP%u completed, wait_event_timeout ret = %u.\n",\r\nmgtvnic->mgt.qp_id, ret);\r\nif (!ret) {\r\nnes_debug(NES_DBG_INIT, "MGT QP%u create timeout expired\n", mgtvnic->mgt.qp_id);\r\nif (i == 0) {\r\npci_free_consistent(nesdev->pcidev, nesvnic->mgt_mem_size, nesvnic->mgt_vbase,\r\nnesvnic->mgt_pbase);\r\nkfree(mgtvnic);\r\n} else {\r\nnes_destroy_mgt(nesvnic);\r\n}\r\nreturn -EIO;\r\n}\r\nfor (counter = 0; counter < (NES_MGT_WQ_COUNT - 1); counter++) {\r\nskb = dev_alloc_skb(nesvnic->max_frame_size);\r\nif (!skb) {\r\nnes_debug(NES_DBG_INIT, "%s: out of memory for receive skb\n", netdev->name);\r\nreturn -ENOMEM;\r\n}\r\nskb->dev = netdev;\r\npmem = pci_map_single(nesdev->pcidev, skb->data,\r\nnesvnic->max_frame_size, PCI_DMA_FROMDEVICE);\r\ncb = (struct nes_rskb_cb *)&skb->cb[0];\r\ncb->busaddr = pmem;\r\ncb->maplen = nesvnic->max_frame_size;\r\nmgt_rqe = &mgtvnic->mgt.rq_vbase[counter];\r\nmgt_rqe->wqe_words[NES_NIC_RQ_WQE_LENGTH_1_0_IDX] = cpu_to_le32((u32)nesvnic->max_frame_size);\r\nmgt_rqe->wqe_words[NES_NIC_RQ_WQE_LENGTH_3_2_IDX] = 0;\r\nmgt_rqe->wqe_words[NES_NIC_RQ_WQE_FRAG0_LOW_IDX] = cpu_to_le32((u32)pmem);\r\nmgt_rqe->wqe_words[NES_NIC_RQ_WQE_FRAG0_HIGH_IDX] = cpu_to_le32((u32)((u64)pmem >> 32));\r\nmgtvnic->mgt.rx_skb[counter] = skb;\r\n}\r\ninit_timer(&mgtvnic->rq_wqes_timer);\r\nmgtvnic->rq_wqes_timer.function = nes_mgt_rq_wqes_timeout;\r\nmgtvnic->rq_wqes_timer.data = (unsigned long)mgtvnic;\r\nwqe_count = NES_MGT_WQ_COUNT - 1;\r\nmgtvnic->mgt.rq_head = wqe_count;\r\nbarrier();\r\ndo {\r\ncounter = min(wqe_count, ((u32)255));\r\nwqe_count -= counter;\r\nnes_write32(nesdev->regs + NES_WQE_ALLOC, (counter << 24) | mgtvnic->mgt.qp_id);\r\n} while (wqe_count);\r\nnes_write32(nesdev->regs + NES_CQE_ALLOC, NES_CQE_ALLOC_NOTIFY_NEXT |\r\nmgtvnic->mgt_cq.cq_number);\r\nnes_read32(nesdev->regs + NES_CQE_ALLOC);\r\nmgt_vbase += mgt_mem_size;\r\nmgt_pbase += mgt_mem_size;\r\nnesvnic->mgtvnic[i] = mgtvnic++;\r\n}\r\nreturn 0;\r\n}\r\nvoid nes_destroy_mgt(struct nes_vnic *nesvnic)\r\n{\r\nstruct nes_device *nesdev = nesvnic->nesdev;\r\nstruct nes_vnic_mgt *mgtvnic;\r\nstruct nes_vnic_mgt *first_mgtvnic;\r\nunsigned long flags;\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nu32 cqp_head;\r\nstruct sk_buff *rx_skb;\r\nint i;\r\nint ret;\r\nkthread_stop(nesvnic->mgt_thread);\r\nfirst_mgtvnic = nesvnic->mgtvnic[0];\r\nfor (i = 0; i < NES_MGT_QP_COUNT; i++) {\r\nmgtvnic = nesvnic->mgtvnic[i];\r\nif (mgtvnic == NULL)\r\ncontinue;\r\nwhile (mgtvnic->mgt.rq_head != mgtvnic->mgt.rq_tail) {\r\nrx_skb = mgtvnic->mgt.rx_skb[mgtvnic->mgt.rq_tail];\r\nnes_mgt_free_skb(nesdev, rx_skb, PCI_DMA_FROMDEVICE);\r\nmgtvnic->mgt.rq_tail++;\r\nmgtvnic->mgt.rq_tail &= (mgtvnic->mgt.rq_size - 1);\r\n}\r\nspin_lock_irqsave(&nesdev->cqp.lock, flags);\r\ncqp_head = nesdev->cqp.sq_head;\r\ncqp_wqe = &nesdev->cqp.sq_vbase[cqp_head];\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_OPCODE_IDX,\r\n(NES_CQP_DESTROY_QP | NES_CQP_QP_TYPE_NIC));\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_ID_IDX,\r\nmgtvnic->mgt.qp_id);\r\nif (++cqp_head >= nesdev->cqp.sq_size)\r\ncqp_head = 0;\r\ncqp_wqe = &nesdev->cqp.sq_vbase[cqp_head];\r\nnes_fill_init_cqp_wqe(cqp_wqe, nesdev);\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_OPCODE_IDX,\r\n(NES_CQP_DESTROY_CQ | ((u32)mgtvnic->mgt_cq.cq_size << 16)));\r\nset_wqe_32bit_value(cqp_wqe->wqe_words, NES_CQP_WQE_ID_IDX,\r\n(mgtvnic->mgt_cq.cq_number | ((u32)nesdev->ceq_index << 16)));\r\nif (++cqp_head >= nesdev->cqp.sq_size)\r\ncqp_head = 0;\r\nnesdev->cqp.sq_head = cqp_head;\r\nbarrier();\r\nnes_write32(nesdev->regs + NES_WQE_ALLOC, 0x02800000 | nesdev->cqp.qp_id);\r\nspin_unlock_irqrestore(&nesdev->cqp.lock, flags);\r\nnes_debug(NES_DBG_SHUTDOWN, "Waiting for CQP, cqp_head=%u, cqp.sq_head=%u,"\r\n" cqp.sq_tail=%u, cqp.sq_size=%u\n",\r\ncqp_head, nesdev->cqp.sq_head,\r\nnesdev->cqp.sq_tail, nesdev->cqp.sq_size);\r\nret = wait_event_timeout(nesdev->cqp.waitq, (nesdev->cqp.sq_tail == cqp_head),\r\nNES_EVENT_TIMEOUT);\r\nnes_debug(NES_DBG_SHUTDOWN, "Destroy MGT QP returned, wait_event_timeout ret = %u, cqp_head=%u,"\r\n" cqp.sq_head=%u, cqp.sq_tail=%u\n",\r\nret, cqp_head, nesdev->cqp.sq_head, nesdev->cqp.sq_tail);\r\nif (!ret)\r\nnes_debug(NES_DBG_SHUTDOWN, "MGT QP%u destroy timeout expired\n",\r\nmgtvnic->mgt.qp_id);\r\nnesvnic->mgtvnic[i] = NULL;\r\n}\r\nif (nesvnic->mgt_vbase) {\r\npci_free_consistent(nesdev->pcidev, nesvnic->mgt_mem_size, nesvnic->mgt_vbase,\r\nnesvnic->mgt_pbase);\r\nnesvnic->mgt_vbase = NULL;\r\nnesvnic->mgt_pbase = 0;\r\n}\r\nkfree(first_mgtvnic);\r\n}
