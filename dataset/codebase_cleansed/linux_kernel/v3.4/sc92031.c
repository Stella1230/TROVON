static inline void _sc92031_dummy_read(void __iomem *port_base)\r\n{\r\nioread32(port_base + MAC0);\r\n}\r\nstatic u32 _sc92031_mii_wait(void __iomem *port_base)\r\n{\r\nu32 mii_status;\r\ndo {\r\nudelay(10);\r\nmii_status = ioread32(port_base + Miistatus);\r\n} while (mii_status & Mii_StatusBusy);\r\nreturn mii_status;\r\n}\r\nstatic u32 _sc92031_mii_cmd(void __iomem *port_base, u32 cmd0, u32 cmd1)\r\n{\r\niowrite32(Mii_Divider, port_base + Miicmd0);\r\n_sc92031_mii_wait(port_base);\r\niowrite32(cmd1, port_base + Miicmd1);\r\niowrite32(Mii_Divider | cmd0, port_base + Miicmd0);\r\nreturn _sc92031_mii_wait(port_base);\r\n}\r\nstatic void _sc92031_mii_scan(void __iomem *port_base)\r\n{\r\n_sc92031_mii_cmd(port_base, Mii_SCAN, 0x1 << 6);\r\n}\r\nstatic u16 _sc92031_mii_read(void __iomem *port_base, unsigned reg)\r\n{\r\nreturn _sc92031_mii_cmd(port_base, Mii_READ, reg << 6) >> 13;\r\n}\r\nstatic void _sc92031_mii_write(void __iomem *port_base, unsigned reg, u16 val)\r\n{\r\n_sc92031_mii_cmd(port_base, Mii_WRITE, (reg << 6) | ((u32)val << 11));\r\n}\r\nstatic void sc92031_disable_interrupts(struct net_device *dev)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nvoid __iomem *port_base = priv->port_base;\r\natomic_set(&priv->intr_mask, 0);\r\nwmb();\r\niowrite32(0, port_base + IntrMask);\r\n_sc92031_dummy_read(port_base);\r\nmmiowb();\r\nsynchronize_irq(dev->irq);\r\ntasklet_disable(&priv->tasklet);\r\n}\r\nstatic void sc92031_enable_interrupts(struct net_device *dev)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nvoid __iomem *port_base = priv->port_base;\r\ntasklet_enable(&priv->tasklet);\r\natomic_set(&priv->intr_mask, IntrBits);\r\nwmb();\r\niowrite32(IntrBits, port_base + IntrMask);\r\nmmiowb();\r\n}\r\nstatic void _sc92031_disable_tx_rx(struct net_device *dev)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nvoid __iomem *port_base = priv->port_base;\r\npriv->rx_config &= ~RxEnb;\r\npriv->tx_config &= ~TxEnb;\r\niowrite32(priv->rx_config, port_base + RxConfig);\r\niowrite32(priv->tx_config, port_base + TxConfig);\r\n}\r\nstatic void _sc92031_enable_tx_rx(struct net_device *dev)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nvoid __iomem *port_base = priv->port_base;\r\npriv->rx_config |= RxEnb;\r\npriv->tx_config |= TxEnb;\r\niowrite32(priv->rx_config, port_base + RxConfig);\r\niowrite32(priv->tx_config, port_base + TxConfig);\r\n}\r\nstatic void _sc92031_tx_clear(struct net_device *dev)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nwhile (priv->tx_head - priv->tx_tail > 0) {\r\npriv->tx_tail++;\r\ndev->stats.tx_dropped++;\r\n}\r\npriv->tx_head = priv->tx_tail = 0;\r\n}\r\nstatic void _sc92031_set_mar(struct net_device *dev)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nvoid __iomem *port_base = priv->port_base;\r\nu32 mar0 = 0, mar1 = 0;\r\nif ((dev->flags & IFF_PROMISC) ||\r\nnetdev_mc_count(dev) > multicast_filter_limit ||\r\n(dev->flags & IFF_ALLMULTI))\r\nmar0 = mar1 = 0xffffffff;\r\nelse if (dev->flags & IFF_MULTICAST) {\r\nstruct netdev_hw_addr *ha;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nu32 crc;\r\nunsigned bit = 0;\r\ncrc = ~ether_crc(ETH_ALEN, ha->addr);\r\ncrc >>= 24;\r\nif (crc & 0x01) bit |= 0x02;\r\nif (crc & 0x02) bit |= 0x01;\r\nif (crc & 0x10) bit |= 0x20;\r\nif (crc & 0x20) bit |= 0x10;\r\nif (crc & 0x40) bit |= 0x08;\r\nif (crc & 0x80) bit |= 0x04;\r\nif (bit > 31)\r\nmar0 |= 0x1 << (bit - 32);\r\nelse\r\nmar1 |= 0x1 << bit;\r\n}\r\n}\r\niowrite32(mar0, port_base + MAR0);\r\niowrite32(mar1, port_base + MAR0 + 4);\r\n}\r\nstatic void _sc92031_set_rx_config(struct net_device *dev)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nvoid __iomem *port_base = priv->port_base;\r\nunsigned int old_mc_flags;\r\nu32 rx_config_bits = 0;\r\nold_mc_flags = priv->mc_flags;\r\nif (dev->flags & IFF_PROMISC)\r\nrx_config_bits |= RxSmall | RxHuge | RxErr | RxBroadcast\r\n| RxMulticast | RxAllphys;\r\nif (dev->flags & (IFF_ALLMULTI | IFF_MULTICAST))\r\nrx_config_bits |= RxMulticast;\r\nif (dev->flags & IFF_BROADCAST)\r\nrx_config_bits |= RxBroadcast;\r\npriv->rx_config &= ~(RxSmall | RxHuge | RxErr | RxBroadcast\r\n| RxMulticast | RxAllphys);\r\npriv->rx_config |= rx_config_bits;\r\npriv->mc_flags = dev->flags & (IFF_PROMISC | IFF_ALLMULTI\r\n| IFF_MULTICAST | IFF_BROADCAST);\r\nif (netif_carrier_ok(dev) && priv->mc_flags != old_mc_flags)\r\niowrite32(priv->rx_config, port_base + RxConfig);\r\n}\r\nstatic bool _sc92031_check_media(struct net_device *dev)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nvoid __iomem *port_base = priv->port_base;\r\nu16 bmsr;\r\nbmsr = _sc92031_mii_read(port_base, MII_BMSR);\r\nrmb();\r\nif (bmsr & BMSR_LSTATUS) {\r\nbool speed_100, duplex_full;\r\nu32 flow_ctrl_config = 0;\r\nu16 output_status = _sc92031_mii_read(port_base,\r\nMII_OutputStatus);\r\n_sc92031_mii_scan(port_base);\r\nspeed_100 = output_status & 0x2;\r\nduplex_full = output_status & 0x4;\r\npriv->rx_config = (0x40 << LowThresholdShift) | (0x1c0 << HighThresholdShift);\r\npriv->tx_config = 0x48800000;\r\nif (!speed_100)\r\npriv->tx_config |= 0x80000;\r\n_sc92031_set_rx_config(dev);\r\nif (duplex_full) {\r\npriv->rx_config |= RxFullDx;\r\npriv->tx_config |= TxFullDx;\r\nflow_ctrl_config = FlowCtrlFullDX | FlowCtrlEnb;\r\n} else {\r\npriv->rx_config &= ~RxFullDx;\r\npriv->tx_config &= ~TxFullDx;\r\n}\r\n_sc92031_set_mar(dev);\r\n_sc92031_set_rx_config(dev);\r\n_sc92031_enable_tx_rx(dev);\r\niowrite32(flow_ctrl_config, port_base + FlowCtrlConfig);\r\nnetif_carrier_on(dev);\r\nif (printk_ratelimit())\r\nprintk(KERN_INFO "%s: link up, %sMbps, %s-duplex\n",\r\ndev->name,\r\nspeed_100 ? "100" : "10",\r\nduplex_full ? "full" : "half");\r\nreturn true;\r\n} else {\r\n_sc92031_mii_scan(port_base);\r\nnetif_carrier_off(dev);\r\n_sc92031_disable_tx_rx(dev);\r\nif (printk_ratelimit())\r\nprintk(KERN_INFO "%s: link down\n", dev->name);\r\nreturn false;\r\n}\r\n}\r\nstatic void _sc92031_phy_reset(struct net_device *dev)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nvoid __iomem *port_base = priv->port_base;\r\nu32 phy_ctrl;\r\nphy_ctrl = ioread32(port_base + PhyCtrl);\r\nphy_ctrl &= ~(PhyCtrlDux | PhyCtrlSpd100 | PhyCtrlSpd10);\r\nphy_ctrl |= PhyCtrlAne | PhyCtrlReset;\r\nswitch (media) {\r\ndefault:\r\ncase AUTOSELECT:\r\nphy_ctrl |= PhyCtrlDux | PhyCtrlSpd100 | PhyCtrlSpd10;\r\nbreak;\r\ncase M10_HALF:\r\nphy_ctrl |= PhyCtrlSpd10;\r\nbreak;\r\ncase M10_FULL:\r\nphy_ctrl |= PhyCtrlDux | PhyCtrlSpd10;\r\nbreak;\r\ncase M100_HALF:\r\nphy_ctrl |= PhyCtrlSpd100;\r\nbreak;\r\ncase M100_FULL:\r\nphy_ctrl |= PhyCtrlDux | PhyCtrlSpd100;\r\nbreak;\r\n}\r\niowrite32(phy_ctrl, port_base + PhyCtrl);\r\nmdelay(10);\r\nphy_ctrl &= ~PhyCtrlReset;\r\niowrite32(phy_ctrl, port_base + PhyCtrl);\r\nmdelay(1);\r\n_sc92031_mii_write(port_base, MII_JAB,\r\nPHY_16_JAB_ENB | PHY_16_PORT_ENB);\r\n_sc92031_mii_scan(port_base);\r\nnetif_carrier_off(dev);\r\nnetif_stop_queue(dev);\r\n}\r\nstatic void _sc92031_reset(struct net_device *dev)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nvoid __iomem *port_base = priv->port_base;\r\niowrite32(0, port_base + PMConfig);\r\niowrite32(Cfg0_Reset, port_base + Config0);\r\nmdelay(200);\r\niowrite32(0, port_base + Config0);\r\nmdelay(10);\r\niowrite32(0, port_base + IntrMask);\r\niowrite32(0, port_base + MAR0);\r\niowrite32(0, port_base + MAR0 + 4);\r\niowrite32(priv->rx_ring_dma_addr, port_base + RxbufAddr);\r\npriv->rx_ring_tail = priv->rx_ring_dma_addr;\r\n_sc92031_tx_clear(dev);\r\npriv->intr_status = 0;\r\natomic_set(&priv->intr_mask, 0);\r\npriv->rx_config = 0;\r\npriv->tx_config = 0;\r\npriv->mc_flags = 0;\r\niowrite32(Cfg1_Rcv64K, port_base + Config1);\r\n_sc92031_phy_reset(dev);\r\n_sc92031_check_media(dev);\r\npriv->rx_value = 0;\r\niowrite32(priv->pm_config, port_base + PMConfig);\r\nioread32(port_base + IntrStatus);\r\n}\r\nstatic void _sc92031_tx_tasklet(struct net_device *dev)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nvoid __iomem *port_base = priv->port_base;\r\nunsigned old_tx_tail;\r\nunsigned entry;\r\nu32 tx_status;\r\nold_tx_tail = priv->tx_tail;\r\nwhile (priv->tx_head - priv->tx_tail > 0) {\r\nentry = priv->tx_tail % NUM_TX_DESC;\r\ntx_status = ioread32(port_base + TxStatus0 + entry * 4);\r\nif (!(tx_status & (TxStatOK | TxUnderrun | TxAborted)))\r\nbreak;\r\npriv->tx_tail++;\r\nif (tx_status & TxStatOK) {\r\ndev->stats.tx_bytes += tx_status & 0x1fff;\r\ndev->stats.tx_packets++;\r\ndev->stats.collisions += (tx_status >> 22) & 0xf;\r\n}\r\nif (tx_status & (TxOutOfWindow | TxAborted)) {\r\ndev->stats.tx_errors++;\r\nif (tx_status & TxAborted)\r\ndev->stats.tx_aborted_errors++;\r\nif (tx_status & TxCarrierLost)\r\ndev->stats.tx_carrier_errors++;\r\nif (tx_status & TxOutOfWindow)\r\ndev->stats.tx_window_errors++;\r\n}\r\nif (tx_status & TxUnderrun)\r\ndev->stats.tx_fifo_errors++;\r\n}\r\nif (priv->tx_tail != old_tx_tail)\r\nif (netif_queue_stopped(dev))\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void _sc92031_rx_tasklet_error(struct net_device *dev,\r\nu32 rx_status, unsigned rx_size)\r\n{\r\nif(rx_size > (MAX_ETH_FRAME_SIZE + 4) || rx_size < 16) {\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_length_errors++;\r\n}\r\nif (!(rx_status & RxStatesOK)) {\r\ndev->stats.rx_errors++;\r\nif (rx_status & (RxHugeFrame | RxSmallFrame))\r\ndev->stats.rx_length_errors++;\r\nif (rx_status & RxBadAlign)\r\ndev->stats.rx_frame_errors++;\r\nif (!(rx_status & RxCRCOK))\r\ndev->stats.rx_crc_errors++;\r\n} else {\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\npriv->rx_loss++;\r\n}\r\n}\r\nstatic void _sc92031_rx_tasklet(struct net_device *dev)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nvoid __iomem *port_base = priv->port_base;\r\ndma_addr_t rx_ring_head;\r\nunsigned rx_len;\r\nunsigned rx_ring_offset;\r\nvoid *rx_ring = priv->rx_ring;\r\nrx_ring_head = ioread32(port_base + RxBufWPtr);\r\nrmb();\r\nrx_ring_head &= (dma_addr_t)(RX_BUF_LEN - 1);\r\nrx_ring_head |= priv->rx_ring_dma_addr & ~(dma_addr_t)(RX_BUF_LEN - 1);\r\nif (rx_ring_head < priv->rx_ring_dma_addr)\r\nrx_ring_head += RX_BUF_LEN;\r\nif (rx_ring_head >= priv->rx_ring_tail)\r\nrx_len = rx_ring_head - priv->rx_ring_tail;\r\nelse\r\nrx_len = RX_BUF_LEN - (priv->rx_ring_tail - rx_ring_head);\r\nif (!rx_len)\r\nreturn;\r\nif (unlikely(rx_len > RX_BUF_LEN)) {\r\nif (printk_ratelimit())\r\nprintk(KERN_ERR "%s: rx packets length > rx buffer\n",\r\ndev->name);\r\nreturn;\r\n}\r\nrx_ring_offset = (priv->rx_ring_tail - priv->rx_ring_dma_addr) % RX_BUF_LEN;\r\nwhile (rx_len) {\r\nu32 rx_status;\r\nunsigned rx_size, rx_size_align, pkt_size;\r\nstruct sk_buff *skb;\r\nrx_status = le32_to_cpup((__le32 *)(rx_ring + rx_ring_offset));\r\nrmb();\r\nrx_size = rx_status >> 20;\r\nrx_size_align = (rx_size + 3) & ~3;\r\npkt_size = rx_size - 4;\r\nrx_ring_offset = (rx_ring_offset + 4) % RX_BUF_LEN;\r\nif (unlikely(rx_status == 0 ||\r\nrx_size > (MAX_ETH_FRAME_SIZE + 4) ||\r\nrx_size < 16 ||\r\n!(rx_status & RxStatesOK))) {\r\n_sc92031_rx_tasklet_error(dev, rx_status, rx_size);\r\nbreak;\r\n}\r\nif (unlikely(rx_size_align + 4 > rx_len)) {\r\nif (printk_ratelimit())\r\nprintk(KERN_ERR "%s: rx_len is too small\n", dev->name);\r\nbreak;\r\n}\r\nrx_len -= rx_size_align + 4;\r\nskb = netdev_alloc_skb_ip_align(dev, pkt_size);\r\nif (unlikely(!skb)) {\r\nif (printk_ratelimit())\r\nprintk(KERN_ERR "%s: Couldn't allocate a skb_buff for a packet of size %u\n",\r\ndev->name, pkt_size);\r\ngoto next;\r\n}\r\nif ((rx_ring_offset + pkt_size) > RX_BUF_LEN) {\r\nmemcpy(skb_put(skb, RX_BUF_LEN - rx_ring_offset),\r\nrx_ring + rx_ring_offset, RX_BUF_LEN - rx_ring_offset);\r\nmemcpy(skb_put(skb, pkt_size - (RX_BUF_LEN - rx_ring_offset)),\r\nrx_ring, pkt_size - (RX_BUF_LEN - rx_ring_offset));\r\n} else {\r\nmemcpy(skb_put(skb, pkt_size), rx_ring + rx_ring_offset, pkt_size);\r\n}\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_bytes += pkt_size;\r\ndev->stats.rx_packets++;\r\nif (rx_status & Rx_Multicast)\r\ndev->stats.multicast++;\r\nnext:\r\nrx_ring_offset = (rx_ring_offset + rx_size_align) % RX_BUF_LEN;\r\n}\r\nmb();\r\npriv->rx_ring_tail = rx_ring_head;\r\niowrite32(priv->rx_ring_tail, port_base + RxBufRPtr);\r\n}\r\nstatic void _sc92031_link_tasklet(struct net_device *dev)\r\n{\r\nif (_sc92031_check_media(dev))\r\nnetif_wake_queue(dev);\r\nelse {\r\nnetif_stop_queue(dev);\r\ndev->stats.tx_carrier_errors++;\r\n}\r\n}\r\nstatic void sc92031_tasklet(unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device *)data;\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nvoid __iomem *port_base = priv->port_base;\r\nu32 intr_status, intr_mask;\r\nintr_status = priv->intr_status;\r\nspin_lock(&priv->lock);\r\nif (unlikely(!netif_running(dev)))\r\ngoto out;\r\nif (intr_status & TxOK)\r\n_sc92031_tx_tasklet(dev);\r\nif (intr_status & RxOK)\r\n_sc92031_rx_tasklet(dev);\r\nif (intr_status & RxOverflow)\r\ndev->stats.rx_errors++;\r\nif (intr_status & TimeOut) {\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_length_errors++;\r\n}\r\nif (intr_status & (LinkFail | LinkOK))\r\n_sc92031_link_tasklet(dev);\r\nout:\r\nintr_mask = atomic_read(&priv->intr_mask);\r\nrmb();\r\niowrite32(intr_mask, port_base + IntrMask);\r\nmmiowb();\r\nspin_unlock(&priv->lock);\r\n}\r\nstatic irqreturn_t sc92031_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nvoid __iomem *port_base = priv->port_base;\r\nu32 intr_status, intr_mask;\r\niowrite32(0, port_base + IntrMask);\r\n_sc92031_dummy_read(port_base);\r\nintr_status = ioread32(port_base + IntrStatus);\r\nif (unlikely(intr_status == 0xffffffff))\r\nreturn IRQ_NONE;\r\nintr_status &= IntrBits;\r\nif (!intr_status)\r\ngoto out_none;\r\npriv->intr_status = intr_status;\r\ntasklet_schedule(&priv->tasklet);\r\nreturn IRQ_HANDLED;\r\nout_none:\r\nintr_mask = atomic_read(&priv->intr_mask);\r\nrmb();\r\niowrite32(intr_mask, port_base + IntrMask);\r\nmmiowb();\r\nreturn IRQ_NONE;\r\n}\r\nstatic struct net_device_stats *sc92031_get_stats(struct net_device *dev)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nvoid __iomem *port_base = priv->port_base;\r\nif (netif_running(dev)) {\r\nint temp;\r\nspin_lock_bh(&priv->lock);\r\ntemp = (ioread32(port_base + RxStatus0) >> 16) & 0xffff;\r\nif (temp == 0xffff) {\r\npriv->rx_value += temp;\r\ndev->stats.rx_fifo_errors = priv->rx_value;\r\n} else\r\ndev->stats.rx_fifo_errors = temp + priv->rx_value;\r\nspin_unlock_bh(&priv->lock);\r\n}\r\nreturn &dev->stats;\r\n}\r\nstatic netdev_tx_t sc92031_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nvoid __iomem *port_base = priv->port_base;\r\nunsigned len;\r\nunsigned entry;\r\nu32 tx_status;\r\nif (unlikely(skb->len > TX_BUF_SIZE)) {\r\ndev->stats.tx_dropped++;\r\ngoto out;\r\n}\r\nspin_lock(&priv->lock);\r\nif (unlikely(!netif_carrier_ok(dev))) {\r\ndev->stats.tx_dropped++;\r\ngoto out_unlock;\r\n}\r\nBUG_ON(priv->tx_head - priv->tx_tail >= NUM_TX_DESC);\r\nentry = priv->tx_head++ % NUM_TX_DESC;\r\nskb_copy_and_csum_dev(skb, priv->tx_bufs + entry * TX_BUF_SIZE);\r\nlen = skb->len;\r\nif (len < ETH_ZLEN) {\r\nmemset(priv->tx_bufs + entry * TX_BUF_SIZE + len,\r\n0, ETH_ZLEN - len);\r\nlen = ETH_ZLEN;\r\n}\r\nwmb();\r\nif (len < 100)\r\ntx_status = len;\r\nelse if (len < 300)\r\ntx_status = 0x30000 | len;\r\nelse\r\ntx_status = 0x50000 | len;\r\niowrite32(priv->tx_bufs_dma_addr + entry * TX_BUF_SIZE,\r\nport_base + TxAddr0 + entry * 4);\r\niowrite32(tx_status, port_base + TxStatus0 + entry * 4);\r\nmmiowb();\r\nif (priv->tx_head - priv->tx_tail >= NUM_TX_DESC)\r\nnetif_stop_queue(dev);\r\nout_unlock:\r\nspin_unlock(&priv->lock);\r\nout:\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int sc92031_open(struct net_device *dev)\r\n{\r\nint err;\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nstruct pci_dev *pdev = priv->pdev;\r\npriv->rx_ring = pci_alloc_consistent(pdev, RX_BUF_LEN,\r\n&priv->rx_ring_dma_addr);\r\nif (unlikely(!priv->rx_ring)) {\r\nerr = -ENOMEM;\r\ngoto out_alloc_rx_ring;\r\n}\r\npriv->tx_bufs = pci_alloc_consistent(pdev, TX_BUF_TOT_LEN,\r\n&priv->tx_bufs_dma_addr);\r\nif (unlikely(!priv->tx_bufs)) {\r\nerr = -ENOMEM;\r\ngoto out_alloc_tx_bufs;\r\n}\r\npriv->tx_head = priv->tx_tail = 0;\r\nerr = request_irq(pdev->irq, sc92031_interrupt,\r\nIRQF_SHARED, dev->name, dev);\r\nif (unlikely(err < 0))\r\ngoto out_request_irq;\r\npriv->pm_config = 0;\r\nspin_lock_bh(&priv->lock);\r\n_sc92031_reset(dev);\r\nmmiowb();\r\nspin_unlock_bh(&priv->lock);\r\nsc92031_enable_interrupts(dev);\r\nif (netif_carrier_ok(dev))\r\nnetif_start_queue(dev);\r\nelse\r\nnetif_tx_disable(dev);\r\nreturn 0;\r\nout_request_irq:\r\npci_free_consistent(pdev, TX_BUF_TOT_LEN, priv->tx_bufs,\r\npriv->tx_bufs_dma_addr);\r\nout_alloc_tx_bufs:\r\npci_free_consistent(pdev, RX_BUF_LEN, priv->rx_ring,\r\npriv->rx_ring_dma_addr);\r\nout_alloc_rx_ring:\r\nreturn err;\r\n}\r\nstatic int sc92031_stop(struct net_device *dev)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nstruct pci_dev *pdev = priv->pdev;\r\nnetif_tx_disable(dev);\r\nsc92031_disable_interrupts(dev);\r\nspin_lock_bh(&priv->lock);\r\n_sc92031_disable_tx_rx(dev);\r\n_sc92031_tx_clear(dev);\r\nmmiowb();\r\nspin_unlock_bh(&priv->lock);\r\nfree_irq(pdev->irq, dev);\r\npci_free_consistent(pdev, TX_BUF_TOT_LEN, priv->tx_bufs,\r\npriv->tx_bufs_dma_addr);\r\npci_free_consistent(pdev, RX_BUF_LEN, priv->rx_ring,\r\npriv->rx_ring_dma_addr);\r\nreturn 0;\r\n}\r\nstatic void sc92031_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nspin_lock_bh(&priv->lock);\r\n_sc92031_set_mar(dev);\r\n_sc92031_set_rx_config(dev);\r\nmmiowb();\r\nspin_unlock_bh(&priv->lock);\r\n}\r\nstatic void sc92031_tx_timeout(struct net_device *dev)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nsc92031_disable_interrupts(dev);\r\nspin_lock(&priv->lock);\r\npriv->tx_timeouts++;\r\n_sc92031_reset(dev);\r\nmmiowb();\r\nspin_unlock(&priv->lock);\r\nsc92031_enable_interrupts(dev);\r\nif (netif_carrier_ok(dev))\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void sc92031_poll_controller(struct net_device *dev)\r\n{\r\ndisable_irq(dev->irq);\r\nif (sc92031_interrupt(dev->irq, dev) != IRQ_NONE)\r\nsc92031_tasklet((unsigned long)dev);\r\nenable_irq(dev->irq);\r\n}\r\nstatic int sc92031_ethtool_get_settings(struct net_device *dev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nvoid __iomem *port_base = priv->port_base;\r\nu8 phy_address;\r\nu32 phy_ctrl;\r\nu16 output_status;\r\nspin_lock_bh(&priv->lock);\r\nphy_address = ioread32(port_base + Miicmd1) >> 27;\r\nphy_ctrl = ioread32(port_base + PhyCtrl);\r\noutput_status = _sc92031_mii_read(port_base, MII_OutputStatus);\r\n_sc92031_mii_scan(port_base);\r\nmmiowb();\r\nspin_unlock_bh(&priv->lock);\r\ncmd->supported = SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full\r\n| SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full\r\n| SUPPORTED_Autoneg | SUPPORTED_TP | SUPPORTED_MII;\r\ncmd->advertising = ADVERTISED_TP | ADVERTISED_MII;\r\nif ((phy_ctrl & (PhyCtrlDux | PhyCtrlSpd100 | PhyCtrlSpd10))\r\n== (PhyCtrlDux | PhyCtrlSpd100 | PhyCtrlSpd10))\r\ncmd->advertising |= ADVERTISED_Autoneg;\r\nif ((phy_ctrl & PhyCtrlSpd10) == PhyCtrlSpd10)\r\ncmd->advertising |= ADVERTISED_10baseT_Half;\r\nif ((phy_ctrl & (PhyCtrlSpd10 | PhyCtrlDux))\r\n== (PhyCtrlSpd10 | PhyCtrlDux))\r\ncmd->advertising |= ADVERTISED_10baseT_Full;\r\nif ((phy_ctrl & PhyCtrlSpd100) == PhyCtrlSpd100)\r\ncmd->advertising |= ADVERTISED_100baseT_Half;\r\nif ((phy_ctrl & (PhyCtrlSpd100 | PhyCtrlDux))\r\n== (PhyCtrlSpd100 | PhyCtrlDux))\r\ncmd->advertising |= ADVERTISED_100baseT_Full;\r\nif (phy_ctrl & PhyCtrlAne)\r\ncmd->advertising |= ADVERTISED_Autoneg;\r\nethtool_cmd_speed_set(cmd,\r\n(output_status & 0x2) ? SPEED_100 : SPEED_10);\r\ncmd->duplex = (output_status & 0x4) ? DUPLEX_FULL : DUPLEX_HALF;\r\ncmd->port = PORT_MII;\r\ncmd->phy_address = phy_address;\r\ncmd->transceiver = XCVR_INTERNAL;\r\ncmd->autoneg = (phy_ctrl & PhyCtrlAne) ? AUTONEG_ENABLE : AUTONEG_DISABLE;\r\nreturn 0;\r\n}\r\nstatic int sc92031_ethtool_set_settings(struct net_device *dev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nvoid __iomem *port_base = priv->port_base;\r\nu32 speed = ethtool_cmd_speed(cmd);\r\nu32 phy_ctrl;\r\nu32 old_phy_ctrl;\r\nif (!(speed == SPEED_10 || speed == SPEED_100))\r\nreturn -EINVAL;\r\nif (!(cmd->duplex == DUPLEX_HALF || cmd->duplex == DUPLEX_FULL))\r\nreturn -EINVAL;\r\nif (!(cmd->port == PORT_MII))\r\nreturn -EINVAL;\r\nif (!(cmd->phy_address == 0x1f))\r\nreturn -EINVAL;\r\nif (!(cmd->transceiver == XCVR_INTERNAL))\r\nreturn -EINVAL;\r\nif (!(cmd->autoneg == AUTONEG_DISABLE || cmd->autoneg == AUTONEG_ENABLE))\r\nreturn -EINVAL;\r\nif (cmd->autoneg == AUTONEG_ENABLE) {\r\nif (!(cmd->advertising & (ADVERTISED_Autoneg\r\n| ADVERTISED_100baseT_Full\r\n| ADVERTISED_100baseT_Half\r\n| ADVERTISED_10baseT_Full\r\n| ADVERTISED_10baseT_Half)))\r\nreturn -EINVAL;\r\nphy_ctrl = PhyCtrlAne;\r\nif (cmd->advertising & ADVERTISED_Autoneg)\r\nphy_ctrl |= PhyCtrlDux | PhyCtrlSpd100 | PhyCtrlSpd10;\r\nif (cmd->advertising & ADVERTISED_100baseT_Full)\r\nphy_ctrl |= PhyCtrlDux | PhyCtrlSpd100;\r\nif (cmd->advertising & ADVERTISED_100baseT_Half)\r\nphy_ctrl |= PhyCtrlSpd100;\r\nif (cmd->advertising & ADVERTISED_10baseT_Full)\r\nphy_ctrl |= PhyCtrlSpd10 | PhyCtrlDux;\r\nif (cmd->advertising & ADVERTISED_10baseT_Half)\r\nphy_ctrl |= PhyCtrlSpd10;\r\n} else {\r\nphy_ctrl = 0;\r\nif (speed == SPEED_10)\r\nphy_ctrl |= PhyCtrlSpd10;\r\nelse\r\nphy_ctrl |= PhyCtrlSpd100;\r\nif (cmd->duplex == DUPLEX_FULL)\r\nphy_ctrl |= PhyCtrlDux;\r\n}\r\nspin_lock_bh(&priv->lock);\r\nold_phy_ctrl = ioread32(port_base + PhyCtrl);\r\nphy_ctrl |= old_phy_ctrl & ~(PhyCtrlAne | PhyCtrlDux\r\n| PhyCtrlSpd100 | PhyCtrlSpd10);\r\nif (phy_ctrl != old_phy_ctrl)\r\niowrite32(phy_ctrl, port_base + PhyCtrl);\r\nspin_unlock_bh(&priv->lock);\r\nreturn 0;\r\n}\r\nstatic void sc92031_ethtool_get_wol(struct net_device *dev,\r\nstruct ethtool_wolinfo *wolinfo)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nvoid __iomem *port_base = priv->port_base;\r\nu32 pm_config;\r\nspin_lock_bh(&priv->lock);\r\npm_config = ioread32(port_base + PMConfig);\r\nspin_unlock_bh(&priv->lock);\r\nwolinfo->supported = WAKE_PHY | WAKE_MAGIC\r\n| WAKE_UCAST | WAKE_MCAST | WAKE_BCAST;\r\nwolinfo->wolopts = 0;\r\nif (pm_config & PM_LinkUp)\r\nwolinfo->wolopts |= WAKE_PHY;\r\nif (pm_config & PM_Magic)\r\nwolinfo->wolopts |= WAKE_MAGIC;\r\nif (pm_config & PM_WakeUp)\r\nwolinfo->wolopts |= WAKE_UCAST | WAKE_MCAST | WAKE_BCAST;\r\n}\r\nstatic int sc92031_ethtool_set_wol(struct net_device *dev,\r\nstruct ethtool_wolinfo *wolinfo)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nvoid __iomem *port_base = priv->port_base;\r\nu32 pm_config;\r\nspin_lock_bh(&priv->lock);\r\npm_config = ioread32(port_base + PMConfig)\r\n& ~(PM_LinkUp | PM_Magic | PM_WakeUp);\r\nif (wolinfo->wolopts & WAKE_PHY)\r\npm_config |= PM_LinkUp;\r\nif (wolinfo->wolopts & WAKE_MAGIC)\r\npm_config |= PM_Magic;\r\nif (wolinfo->wolopts & (WAKE_UCAST | WAKE_MCAST | WAKE_BCAST))\r\npm_config |= PM_WakeUp;\r\npriv->pm_config = pm_config;\r\niowrite32(pm_config, port_base + PMConfig);\r\nmmiowb();\r\nspin_unlock_bh(&priv->lock);\r\nreturn 0;\r\n}\r\nstatic int sc92031_ethtool_nway_reset(struct net_device *dev)\r\n{\r\nint err = 0;\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nvoid __iomem *port_base = priv->port_base;\r\nu16 bmcr;\r\nspin_lock_bh(&priv->lock);\r\nbmcr = _sc92031_mii_read(port_base, MII_BMCR);\r\nif (!(bmcr & BMCR_ANENABLE)) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\n_sc92031_mii_write(port_base, MII_BMCR, bmcr | BMCR_ANRESTART);\r\nout:\r\n_sc92031_mii_scan(port_base);\r\nmmiowb();\r\nspin_unlock_bh(&priv->lock);\r\nreturn err;\r\n}\r\nstatic void sc92031_ethtool_get_strings(struct net_device *dev,\r\nu32 stringset, u8 *data)\r\n{\r\nif (stringset == ETH_SS_STATS)\r\nmemcpy(data, sc92031_ethtool_stats_strings,\r\nSILAN_STATS_NUM * ETH_GSTRING_LEN);\r\n}\r\nstatic int sc92031_ethtool_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn SILAN_STATS_NUM;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void sc92031_ethtool_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nspin_lock_bh(&priv->lock);\r\ndata[0] = priv->tx_timeouts;\r\ndata[1] = priv->rx_loss;\r\nspin_unlock_bh(&priv->lock);\r\n}\r\nstatic int __devinit sc92031_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nint err;\r\nvoid __iomem* port_base;\r\nstruct net_device *dev;\r\nstruct sc92031_priv *priv;\r\nu32 mac0, mac1;\r\nunsigned long base_addr;\r\nerr = pci_enable_device(pdev);\r\nif (unlikely(err < 0))\r\ngoto out_enable_device;\r\npci_set_master(pdev);\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (unlikely(err < 0))\r\ngoto out_set_dma_mask;\r\nerr = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (unlikely(err < 0))\r\ngoto out_set_dma_mask;\r\nerr = pci_request_regions(pdev, SC92031_NAME);\r\nif (unlikely(err < 0))\r\ngoto out_request_regions;\r\nport_base = pci_iomap(pdev, SC92031_USE_BAR, 0);\r\nif (unlikely(!port_base)) {\r\nerr = -EIO;\r\ngoto out_iomap;\r\n}\r\ndev = alloc_etherdev(sizeof(struct sc92031_priv));\r\nif (unlikely(!dev)) {\r\nerr = -ENOMEM;\r\ngoto out_alloc_etherdev;\r\n}\r\npci_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\n#if SC92031_USE_BAR == 0\r\ndev->mem_start = pci_resource_start(pdev, SC92031_USE_BAR);\r\ndev->mem_end = pci_resource_end(pdev, SC92031_USE_BAR);\r\n#elif SC92031_USE_BAR == 1\r\ndev->base_addr = pci_resource_start(pdev, SC92031_USE_BAR);\r\n#endif\r\ndev->irq = pdev->irq;\r\ndev->features = NETIF_F_SG | NETIF_F_HIGHDMA |\r\nNETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;\r\ndev->netdev_ops = &sc92031_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\ndev->ethtool_ops = &sc92031_ethtool_ops;\r\npriv = netdev_priv(dev);\r\nspin_lock_init(&priv->lock);\r\npriv->port_base = port_base;\r\npriv->pdev = pdev;\r\ntasklet_init(&priv->tasklet, sc92031_tasklet, (unsigned long)dev);\r\ntasklet_disable_nosync(&priv->tasklet);\r\niowrite32((~PM_LongWF & ~PM_LWPTN) | PM_Enable, port_base + PMConfig);\r\nmac0 = ioread32(port_base + MAC0);\r\nmac1 = ioread32(port_base + MAC0 + 4);\r\ndev->dev_addr[0] = dev->perm_addr[0] = mac0 >> 24;\r\ndev->dev_addr[1] = dev->perm_addr[1] = mac0 >> 16;\r\ndev->dev_addr[2] = dev->perm_addr[2] = mac0 >> 8;\r\ndev->dev_addr[3] = dev->perm_addr[3] = mac0;\r\ndev->dev_addr[4] = dev->perm_addr[4] = mac1 >> 8;\r\ndev->dev_addr[5] = dev->perm_addr[5] = mac1;\r\nerr = register_netdev(dev);\r\nif (err < 0)\r\ngoto out_register_netdev;\r\n#if SC92031_USE_BAR == 0\r\nbase_addr = dev->mem_start;\r\n#elif SC92031_USE_BAR == 1\r\nbase_addr = dev->base_addr;\r\n#endif\r\nprintk(KERN_INFO "%s: SC92031 at 0x%lx, %pM, IRQ %d\n", dev->name,\r\nbase_addr, dev->dev_addr, dev->irq);\r\nreturn 0;\r\nout_register_netdev:\r\nfree_netdev(dev);\r\nout_alloc_etherdev:\r\npci_iounmap(pdev, port_base);\r\nout_iomap:\r\npci_release_regions(pdev);\r\nout_request_regions:\r\nout_set_dma_mask:\r\npci_disable_device(pdev);\r\nout_enable_device:\r\nreturn err;\r\n}\r\nstatic void __devexit sc92031_remove(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\nvoid __iomem* port_base = priv->port_base;\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\npci_iounmap(pdev, port_base);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\n}\r\nstatic int sc92031_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\npci_save_state(pdev);\r\nif (!netif_running(dev))\r\ngoto out;\r\nnetif_device_detach(dev);\r\nsc92031_disable_interrupts(dev);\r\nspin_lock_bh(&priv->lock);\r\n_sc92031_disable_tx_rx(dev);\r\n_sc92031_tx_clear(dev);\r\nmmiowb();\r\nspin_unlock_bh(&priv->lock);\r\nout:\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int sc92031_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct sc92031_priv *priv = netdev_priv(dev);\r\npci_restore_state(pdev);\r\npci_set_power_state(pdev, PCI_D0);\r\nif (!netif_running(dev))\r\ngoto out;\r\nspin_lock_bh(&priv->lock);\r\n_sc92031_reset(dev);\r\nmmiowb();\r\nspin_unlock_bh(&priv->lock);\r\nsc92031_enable_interrupts(dev);\r\nnetif_device_attach(dev);\r\nif (netif_carrier_ok(dev))\r\nnetif_wake_queue(dev);\r\nelse\r\nnetif_tx_disable(dev);\r\nout:\r\nreturn 0;\r\n}\r\nstatic int __init sc92031_init(void)\r\n{\r\nreturn pci_register_driver(&sc92031_pci_driver);\r\n}\r\nstatic void __exit sc92031_exit(void)\r\n{\r\npci_unregister_driver(&sc92031_pci_driver);\r\n}
