static ssize_t mv64x60_hs_reg_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr, char *buf,\r\nloff_t off, size_t count)\r\n{\r\nstruct pci_dev *phb;\r\nu32 v;\r\nif (off > 0)\r\nreturn 0;\r\nif (count < MV64X60_VAL_LEN_MAX)\r\nreturn -EINVAL;\r\nphb = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0));\r\nif (!phb)\r\nreturn -ENODEV;\r\npci_read_config_dword(phb, MV64X60_PCICFG_CPCI_HOTSWAP, &v);\r\npci_dev_put(phb);\r\nreturn sprintf(buf, "0x%08x\n", v);\r\n}\r\nstatic ssize_t mv64x60_hs_reg_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr, char *buf,\r\nloff_t off, size_t count)\r\n{\r\nstruct pci_dev *phb;\r\nu32 v;\r\nif (off > 0)\r\nreturn 0;\r\nif (count <= 0)\r\nreturn -EINVAL;\r\nif (sscanf(buf, "%i", &v) != 1)\r\nreturn -EINVAL;\r\nphb = pci_get_bus_and_slot(0, PCI_DEVFN(0, 0));\r\nif (!phb)\r\nreturn -ENODEV;\r\npci_write_config_dword(phb, MV64X60_PCICFG_CPCI_HOTSWAP, v);\r\npci_dev_put(phb);\r\nreturn count;\r\n}\r\nstatic int __init mv64x60_sysfs_init(void)\r\n{\r\nstruct device_node *np;\r\nstruct platform_device *pdev;\r\nconst unsigned int *prop;\r\nnp = of_find_compatible_node(NULL, NULL, "marvell,mv64360");\r\nif (!np)\r\nreturn 0;\r\nprop = of_get_property(np, "hs_reg_valid", NULL);\r\nof_node_put(np);\r\npdev = platform_device_register_simple("marvell,mv64360", 0, NULL, 0);\r\nif (IS_ERR(pdev))\r\nreturn PTR_ERR(pdev);\r\nreturn sysfs_create_bin_file(&pdev->dev.kobj, &mv64x60_hs_reg_attr);\r\n}\r\nstatic void __init mv64x60_pci_fixup_early(struct pci_dev *dev)\r\n{\r\ndev->hdr_type = PCI_HEADER_TYPE_INVALID;\r\n}\r\nstatic int __init mv64x60_add_bridge(struct device_node *dev)\r\n{\r\nint len;\r\nstruct pci_controller *hose;\r\nstruct resource rsrc;\r\nconst int *bus_range;\r\nint primary;\r\nmemset(&rsrc, 0, sizeof(rsrc));\r\nif (of_address_to_resource(dev, 0, &rsrc)) {\r\nprintk(KERN_ERR "No PCI reg property in device tree\n");\r\nreturn -ENODEV;\r\n}\r\nbus_range = of_get_property(dev, "bus-range", &len);\r\nif (bus_range == NULL || len < 2 * sizeof(int))\r\nprintk(KERN_WARNING "Can't get bus-range for %s, assume"\r\n" bus 0\n", dev->full_name);\r\nhose = pcibios_alloc_controller(dev);\r\nif (!hose)\r\nreturn -ENOMEM;\r\nhose->first_busno = bus_range ? bus_range[0] : 0;\r\nhose->last_busno = bus_range ? bus_range[1] : 0xff;\r\nsetup_indirect_pci(hose, rsrc.start, rsrc.start + 4, 0);\r\nhose->self_busno = hose->first_busno;\r\nprintk(KERN_INFO "Found MV64x60 PCI host bridge at 0x%016llx. "\r\n"Firmware bus number: %d->%d\n",\r\n(unsigned long long)rsrc.start, hose->first_busno,\r\nhose->last_busno);\r\nprimary = (hose->first_busno == 0);\r\npci_process_bridge_OF_ranges(hose, dev, primary);\r\nreturn 0;\r\n}\r\nvoid __init mv64x60_pci_init(void)\r\n{\r\nstruct device_node *np;\r\nfor_each_compatible_node(np, "pci", "marvell,mv64360-pci")\r\nmv64x60_add_bridge(np);\r\n}
