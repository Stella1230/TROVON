void lock_memory_hotplug(void)\r\n{\r\nmutex_lock(&mem_hotplug_mutex);\r\nlock_system_sleep();\r\n}\r\nvoid unlock_memory_hotplug(void)\r\n{\r\nunlock_system_sleep();\r\nmutex_unlock(&mem_hotplug_mutex);\r\n}\r\nstatic struct resource *register_memory_resource(u64 start, u64 size)\r\n{\r\nstruct resource *res;\r\nres = kzalloc(sizeof(struct resource), GFP_KERNEL);\r\nBUG_ON(!res);\r\nres->name = "System RAM";\r\nres->start = start;\r\nres->end = start + size - 1;\r\nres->flags = IORESOURCE_MEM | IORESOURCE_BUSY;\r\nif (request_resource(&iomem_resource, res) < 0) {\r\nprintk("System RAM resource %llx - %llx cannot be added\n",\r\n(unsigned long long)res->start, (unsigned long long)res->end);\r\nkfree(res);\r\nres = NULL;\r\n}\r\nreturn res;\r\n}\r\nstatic void release_memory_resource(struct resource *res)\r\n{\r\nif (!res)\r\nreturn;\r\nrelease_resource(res);\r\nkfree(res);\r\nreturn;\r\n}\r\nstatic void get_page_bootmem(unsigned long info, struct page *page,\r\nunsigned long type)\r\n{\r\npage->lru.next = (struct list_head *) type;\r\nSetPagePrivate(page);\r\nset_page_private(page, info);\r\natomic_inc(&page->_count);\r\n}\r\nvoid __ref put_page_bootmem(struct page *page)\r\n{\r\nunsigned long type;\r\ntype = (unsigned long) page->lru.next;\r\nBUG_ON(type < MEMORY_HOTPLUG_MIN_BOOTMEM_TYPE ||\r\ntype > MEMORY_HOTPLUG_MAX_BOOTMEM_TYPE);\r\nif (atomic_dec_return(&page->_count) == 1) {\r\nClearPagePrivate(page);\r\nset_page_private(page, 0);\r\nINIT_LIST_HEAD(&page->lru);\r\n__free_pages_bootmem(page, 0);\r\n}\r\n}\r\nstatic void register_page_bootmem_info_section(unsigned long start_pfn)\r\n{\r\nunsigned long *usemap, mapsize, section_nr, i;\r\nstruct mem_section *ms;\r\nstruct page *page, *memmap;\r\nif (!pfn_valid(start_pfn))\r\nreturn;\r\nsection_nr = pfn_to_section_nr(start_pfn);\r\nms = __nr_to_section(section_nr);\r\nmemmap = sparse_decode_mem_map(ms->section_mem_map, section_nr);\r\npage = virt_to_page(memmap);\r\nmapsize = sizeof(struct page) * PAGES_PER_SECTION;\r\nmapsize = PAGE_ALIGN(mapsize) >> PAGE_SHIFT;\r\nfor (i = 0; i < mapsize; i++, page++)\r\nget_page_bootmem(section_nr, page, SECTION_INFO);\r\nusemap = __nr_to_section(section_nr)->pageblock_flags;\r\npage = virt_to_page(usemap);\r\nmapsize = PAGE_ALIGN(usemap_size()) >> PAGE_SHIFT;\r\nfor (i = 0; i < mapsize; i++, page++)\r\nget_page_bootmem(section_nr, page, MIX_SECTION_INFO);\r\n}\r\nvoid register_page_bootmem_info_node(struct pglist_data *pgdat)\r\n{\r\nunsigned long i, pfn, end_pfn, nr_pages;\r\nint node = pgdat->node_id;\r\nstruct page *page;\r\nstruct zone *zone;\r\nnr_pages = PAGE_ALIGN(sizeof(struct pglist_data)) >> PAGE_SHIFT;\r\npage = virt_to_page(pgdat);\r\nfor (i = 0; i < nr_pages; i++, page++)\r\nget_page_bootmem(node, page, NODE_INFO);\r\nzone = &pgdat->node_zones[0];\r\nfor (; zone < pgdat->node_zones + MAX_NR_ZONES - 1; zone++) {\r\nif (zone->wait_table) {\r\nnr_pages = zone->wait_table_hash_nr_entries\r\n* sizeof(wait_queue_head_t);\r\nnr_pages = PAGE_ALIGN(nr_pages) >> PAGE_SHIFT;\r\npage = virt_to_page(zone->wait_table);\r\nfor (i = 0; i < nr_pages; i++, page++)\r\nget_page_bootmem(node, page, NODE_INFO);\r\n}\r\n}\r\npfn = pgdat->node_start_pfn;\r\nend_pfn = pfn + pgdat->node_spanned_pages;\r\nfor (; pfn < end_pfn; pfn += PAGES_PER_SECTION)\r\nregister_page_bootmem_info_section(pfn);\r\n}\r\nstatic void grow_zone_span(struct zone *zone, unsigned long start_pfn,\r\nunsigned long end_pfn)\r\n{\r\nunsigned long old_zone_end_pfn;\r\nzone_span_writelock(zone);\r\nold_zone_end_pfn = zone->zone_start_pfn + zone->spanned_pages;\r\nif (start_pfn < zone->zone_start_pfn)\r\nzone->zone_start_pfn = start_pfn;\r\nzone->spanned_pages = max(old_zone_end_pfn, end_pfn) -\r\nzone->zone_start_pfn;\r\nzone_span_writeunlock(zone);\r\n}\r\nstatic void grow_pgdat_span(struct pglist_data *pgdat, unsigned long start_pfn,\r\nunsigned long end_pfn)\r\n{\r\nunsigned long old_pgdat_end_pfn =\r\npgdat->node_start_pfn + pgdat->node_spanned_pages;\r\nif (start_pfn < pgdat->node_start_pfn)\r\npgdat->node_start_pfn = start_pfn;\r\npgdat->node_spanned_pages = max(old_pgdat_end_pfn, end_pfn) -\r\npgdat->node_start_pfn;\r\n}\r\nstatic int __meminit __add_zone(struct zone *zone, unsigned long phys_start_pfn)\r\n{\r\nstruct pglist_data *pgdat = zone->zone_pgdat;\r\nint nr_pages = PAGES_PER_SECTION;\r\nint nid = pgdat->node_id;\r\nint zone_type;\r\nunsigned long flags;\r\nzone_type = zone - pgdat->node_zones;\r\nif (!zone->wait_table) {\r\nint ret;\r\nret = init_currently_empty_zone(zone, phys_start_pfn,\r\nnr_pages, MEMMAP_HOTPLUG);\r\nif (ret)\r\nreturn ret;\r\n}\r\npgdat_resize_lock(zone->zone_pgdat, &flags);\r\ngrow_zone_span(zone, phys_start_pfn, phys_start_pfn + nr_pages);\r\ngrow_pgdat_span(zone->zone_pgdat, phys_start_pfn,\r\nphys_start_pfn + nr_pages);\r\npgdat_resize_unlock(zone->zone_pgdat, &flags);\r\nmemmap_init_zone(nr_pages, nid, zone_type,\r\nphys_start_pfn, MEMMAP_HOTPLUG);\r\nreturn 0;\r\n}\r\nstatic int __meminit __add_section(int nid, struct zone *zone,\r\nunsigned long phys_start_pfn)\r\n{\r\nint nr_pages = PAGES_PER_SECTION;\r\nint ret;\r\nif (pfn_valid(phys_start_pfn))\r\nreturn -EEXIST;\r\nret = sparse_add_one_section(zone, phys_start_pfn, nr_pages);\r\nif (ret < 0)\r\nreturn ret;\r\nret = __add_zone(zone, phys_start_pfn);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn register_new_memory(nid, __pfn_to_section(phys_start_pfn));\r\n}\r\nstatic int __remove_section(struct zone *zone, struct mem_section *ms)\r\n{\r\nreturn -EBUSY;\r\n}\r\nstatic int __remove_section(struct zone *zone, struct mem_section *ms)\r\n{\r\nunsigned long flags;\r\nstruct pglist_data *pgdat = zone->zone_pgdat;\r\nint ret = -EINVAL;\r\nif (!valid_section(ms))\r\nreturn ret;\r\nret = unregister_memory_section(ms);\r\nif (ret)\r\nreturn ret;\r\npgdat_resize_lock(pgdat, &flags);\r\nsparse_remove_one_section(zone, ms);\r\npgdat_resize_unlock(pgdat, &flags);\r\nreturn 0;\r\n}\r\nint __ref __add_pages(int nid, struct zone *zone, unsigned long phys_start_pfn,\r\nunsigned long nr_pages)\r\n{\r\nunsigned long i;\r\nint err = 0;\r\nint start_sec, end_sec;\r\nstart_sec = pfn_to_section_nr(phys_start_pfn);\r\nend_sec = pfn_to_section_nr(phys_start_pfn + nr_pages - 1);\r\nfor (i = start_sec; i <= end_sec; i++) {\r\nerr = __add_section(nid, zone, i << PFN_SECTION_SHIFT);\r\nif (err && (err != -EEXIST))\r\nbreak;\r\nerr = 0;\r\n}\r\nreturn err;\r\n}\r\nint __remove_pages(struct zone *zone, unsigned long phys_start_pfn,\r\nunsigned long nr_pages)\r\n{\r\nunsigned long i, ret = 0;\r\nint sections_to_remove;\r\nBUG_ON(phys_start_pfn & ~PAGE_SECTION_MASK);\r\nBUG_ON(nr_pages % PAGES_PER_SECTION);\r\nsections_to_remove = nr_pages / PAGES_PER_SECTION;\r\nfor (i = 0; i < sections_to_remove; i++) {\r\nunsigned long pfn = phys_start_pfn + i*PAGES_PER_SECTION;\r\nrelease_mem_region(pfn << PAGE_SHIFT,\r\nPAGES_PER_SECTION << PAGE_SHIFT);\r\nret = __remove_section(zone, __pfn_to_section(pfn));\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint set_online_page_callback(online_page_callback_t callback)\r\n{\r\nint rc = -EINVAL;\r\nlock_memory_hotplug();\r\nif (online_page_callback == generic_online_page) {\r\nonline_page_callback = callback;\r\nrc = 0;\r\n}\r\nunlock_memory_hotplug();\r\nreturn rc;\r\n}\r\nint restore_online_page_callback(online_page_callback_t callback)\r\n{\r\nint rc = -EINVAL;\r\nlock_memory_hotplug();\r\nif (online_page_callback == callback) {\r\nonline_page_callback = generic_online_page;\r\nrc = 0;\r\n}\r\nunlock_memory_hotplug();\r\nreturn rc;\r\n}\r\nvoid __online_page_set_limits(struct page *page)\r\n{\r\nunsigned long pfn = page_to_pfn(page);\r\nif (pfn >= num_physpages)\r\nnum_physpages = pfn + 1;\r\n}\r\nvoid __online_page_increment_counters(struct page *page)\r\n{\r\ntotalram_pages++;\r\n#ifdef CONFIG_HIGHMEM\r\nif (PageHighMem(page))\r\ntotalhigh_pages++;\r\n#endif\r\n}\r\nvoid __online_page_free(struct page *page)\r\n{\r\nClearPageReserved(page);\r\ninit_page_count(page);\r\n__free_page(page);\r\n}\r\nstatic void generic_online_page(struct page *page)\r\n{\r\n__online_page_set_limits(page);\r\n__online_page_increment_counters(page);\r\n__online_page_free(page);\r\n}\r\nstatic int online_pages_range(unsigned long start_pfn, unsigned long nr_pages,\r\nvoid *arg)\r\n{\r\nunsigned long i;\r\nunsigned long onlined_pages = *(unsigned long *)arg;\r\nstruct page *page;\r\nif (PageReserved(pfn_to_page(start_pfn)))\r\nfor (i = 0; i < nr_pages; i++) {\r\npage = pfn_to_page(start_pfn + i);\r\n(*online_page_callback)(page);\r\nonlined_pages++;\r\n}\r\n*(unsigned long *)arg = onlined_pages;\r\nreturn 0;\r\n}\r\nint __ref online_pages(unsigned long pfn, unsigned long nr_pages)\r\n{\r\nunsigned long onlined_pages = 0;\r\nstruct zone *zone;\r\nint need_zonelists_rebuild = 0;\r\nint nid;\r\nint ret;\r\nstruct memory_notify arg;\r\nlock_memory_hotplug();\r\narg.start_pfn = pfn;\r\narg.nr_pages = nr_pages;\r\narg.status_change_nid = -1;\r\nnid = page_to_nid(pfn_to_page(pfn));\r\nif (node_present_pages(nid) == 0)\r\narg.status_change_nid = nid;\r\nret = memory_notify(MEM_GOING_ONLINE, &arg);\r\nret = notifier_to_errno(ret);\r\nif (ret) {\r\nmemory_notify(MEM_CANCEL_ONLINE, &arg);\r\nunlock_memory_hotplug();\r\nreturn ret;\r\n}\r\nzone = page_zone(pfn_to_page(pfn));\r\nmutex_lock(&zonelists_mutex);\r\nif (!populated_zone(zone))\r\nneed_zonelists_rebuild = 1;\r\nret = walk_system_ram_range(pfn, nr_pages, &onlined_pages,\r\nonline_pages_range);\r\nif (ret) {\r\nmutex_unlock(&zonelists_mutex);\r\nprintk(KERN_DEBUG "online_pages %lx at %lx failed\n",\r\nnr_pages, pfn);\r\nmemory_notify(MEM_CANCEL_ONLINE, &arg);\r\nunlock_memory_hotplug();\r\nreturn ret;\r\n}\r\nzone->present_pages += onlined_pages;\r\nzone->zone_pgdat->node_present_pages += onlined_pages;\r\nif (need_zonelists_rebuild)\r\nbuild_all_zonelists(zone);\r\nelse\r\nzone_pcp_update(zone);\r\nmutex_unlock(&zonelists_mutex);\r\ninit_per_zone_wmark_min();\r\nif (onlined_pages) {\r\nkswapd_run(zone_to_nid(zone));\r\nnode_set_state(zone_to_nid(zone), N_HIGH_MEMORY);\r\n}\r\nvm_total_pages = nr_free_pagecache_pages();\r\nwriteback_set_ratelimit();\r\nif (onlined_pages)\r\nmemory_notify(MEM_ONLINE, &arg);\r\nunlock_memory_hotplug();\r\nreturn 0;\r\n}\r\nstatic pg_data_t __ref *hotadd_new_pgdat(int nid, u64 start)\r\n{\r\nstruct pglist_data *pgdat;\r\nunsigned long zones_size[MAX_NR_ZONES] = {0};\r\nunsigned long zholes_size[MAX_NR_ZONES] = {0};\r\nunsigned long start_pfn = start >> PAGE_SHIFT;\r\npgdat = arch_alloc_nodedata(nid);\r\nif (!pgdat)\r\nreturn NULL;\r\narch_refresh_nodedata(nid, pgdat);\r\nfree_area_init_node(nid, zones_size, start_pfn, zholes_size);\r\nmutex_lock(&zonelists_mutex);\r\nbuild_all_zonelists(NULL);\r\nmutex_unlock(&zonelists_mutex);\r\nreturn pgdat;\r\n}\r\nstatic void rollback_node_hotadd(int nid, pg_data_t *pgdat)\r\n{\r\narch_refresh_nodedata(nid, NULL);\r\narch_free_nodedata(pgdat);\r\nreturn;\r\n}\r\nint mem_online_node(int nid)\r\n{\r\npg_data_t *pgdat;\r\nint ret;\r\nlock_memory_hotplug();\r\npgdat = hotadd_new_pgdat(nid, 0);\r\nif (!pgdat) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nnode_set_online(nid);\r\nret = register_one_node(nid);\r\nBUG_ON(ret);\r\nout:\r\nunlock_memory_hotplug();\r\nreturn ret;\r\n}\r\nint __ref add_memory(int nid, u64 start, u64 size)\r\n{\r\npg_data_t *pgdat = NULL;\r\nint new_pgdat = 0;\r\nstruct resource *res;\r\nint ret;\r\nlock_memory_hotplug();\r\nres = register_memory_resource(start, size);\r\nret = -EEXIST;\r\nif (!res)\r\ngoto out;\r\nif (!node_online(nid)) {\r\npgdat = hotadd_new_pgdat(nid, start);\r\nret = -ENOMEM;\r\nif (!pgdat)\r\ngoto out;\r\nnew_pgdat = 1;\r\n}\r\nret = arch_add_memory(nid, start, size);\r\nif (ret < 0)\r\ngoto error;\r\nnode_set_online(nid);\r\nif (new_pgdat) {\r\nret = register_one_node(nid);\r\nBUG_ON(ret);\r\n}\r\nfirmware_map_add_hotplug(start, start + size, "System RAM");\r\ngoto out;\r\nerror:\r\nif (new_pgdat)\r\nrollback_node_hotadd(nid, pgdat);\r\nif (res)\r\nrelease_memory_resource(res);\r\nout:\r\nunlock_memory_hotplug();\r\nreturn ret;\r\n}\r\nstatic inline int pageblock_free(struct page *page)\r\n{\r\nreturn PageBuddy(page) && page_order(page) >= pageblock_order;\r\n}\r\nstatic struct page *next_active_pageblock(struct page *page)\r\n{\r\nBUG_ON(page_to_pfn(page) & (pageblock_nr_pages - 1));\r\nif (pageblock_free(page)) {\r\nint order;\r\norder = page_order(page);\r\nif ((order < MAX_ORDER) && (order >= pageblock_order))\r\nreturn page + (1 << order);\r\n}\r\nreturn page + pageblock_nr_pages;\r\n}\r\nint is_mem_section_removable(unsigned long start_pfn, unsigned long nr_pages)\r\n{\r\nstruct page *page = pfn_to_page(start_pfn);\r\nstruct page *end_page = page + nr_pages;\r\nfor (; page < end_page; page = next_active_pageblock(page)) {\r\nif (!is_pageblock_removable_nolock(page))\r\nreturn 0;\r\ncond_resched();\r\n}\r\nreturn 1;\r\n}\r\nstatic int test_pages_in_a_zone(unsigned long start_pfn, unsigned long end_pfn)\r\n{\r\nunsigned long pfn;\r\nstruct zone *zone = NULL;\r\nstruct page *page;\r\nint i;\r\nfor (pfn = start_pfn;\r\npfn < end_pfn;\r\npfn += MAX_ORDER_NR_PAGES) {\r\ni = 0;\r\nwhile ((i < MAX_ORDER_NR_PAGES) && !pfn_valid_within(pfn + i))\r\ni++;\r\nif (i == MAX_ORDER_NR_PAGES)\r\ncontinue;\r\npage = pfn_to_page(pfn + i);\r\nif (zone && page_zone(page) != zone)\r\nreturn 0;\r\nzone = page_zone(page);\r\n}\r\nreturn 1;\r\n}\r\nstatic unsigned long scan_lru_pages(unsigned long start, unsigned long end)\r\n{\r\nunsigned long pfn;\r\nstruct page *page;\r\nfor (pfn = start; pfn < end; pfn++) {\r\nif (pfn_valid(pfn)) {\r\npage = pfn_to_page(pfn);\r\nif (PageLRU(page))\r\nreturn pfn;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct page *\r\nhotremove_migrate_alloc(struct page *page, unsigned long private, int **x)\r\n{\r\nreturn alloc_page(GFP_HIGHUSER_MOVABLE);\r\n}\r\nstatic int\r\ndo_migrate_range(unsigned long start_pfn, unsigned long end_pfn)\r\n{\r\nunsigned long pfn;\r\nstruct page *page;\r\nint move_pages = NR_OFFLINE_AT_ONCE_PAGES;\r\nint not_managed = 0;\r\nint ret = 0;\r\nLIST_HEAD(source);\r\nfor (pfn = start_pfn; pfn < end_pfn && move_pages > 0; pfn++) {\r\nif (!pfn_valid(pfn))\r\ncontinue;\r\npage = pfn_to_page(pfn);\r\nif (!get_page_unless_zero(page))\r\ncontinue;\r\nret = isolate_lru_page(page);\r\nif (!ret) {\r\nput_page(page);\r\nlist_add_tail(&page->lru, &source);\r\nmove_pages--;\r\ninc_zone_page_state(page, NR_ISOLATED_ANON +\r\npage_is_file_cache(page));\r\n} else {\r\n#ifdef CONFIG_DEBUG_VM\r\nprintk(KERN_ALERT "removing pfn %lx from LRU failed\n",\r\npfn);\r\ndump_page(page);\r\n#endif\r\nput_page(page);\r\nif (page_count(page)) {\r\nnot_managed++;\r\nret = -EBUSY;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!list_empty(&source)) {\r\nif (not_managed) {\r\nputback_lru_pages(&source);\r\ngoto out;\r\n}\r\nret = migrate_pages(&source, hotremove_migrate_alloc, 0,\r\ntrue, MIGRATE_SYNC);\r\nif (ret)\r\nputback_lru_pages(&source);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int\r\noffline_isolated_pages_cb(unsigned long start, unsigned long nr_pages,\r\nvoid *data)\r\n{\r\n__offline_isolated_pages(start, start + nr_pages);\r\nreturn 0;\r\n}\r\nstatic void\r\noffline_isolated_pages(unsigned long start_pfn, unsigned long end_pfn)\r\n{\r\nwalk_system_ram_range(start_pfn, end_pfn - start_pfn, NULL,\r\noffline_isolated_pages_cb);\r\n}\r\nstatic int\r\ncheck_pages_isolated_cb(unsigned long start_pfn, unsigned long nr_pages,\r\nvoid *data)\r\n{\r\nint ret;\r\nlong offlined = *(long *)data;\r\nret = test_pages_isolated(start_pfn, start_pfn + nr_pages);\r\nofflined = nr_pages;\r\nif (!ret)\r\n*(long *)data += offlined;\r\nreturn ret;\r\n}\r\nstatic long\r\ncheck_pages_isolated(unsigned long start_pfn, unsigned long end_pfn)\r\n{\r\nlong offlined = 0;\r\nint ret;\r\nret = walk_system_ram_range(start_pfn, end_pfn - start_pfn, &offlined,\r\ncheck_pages_isolated_cb);\r\nif (ret < 0)\r\nofflined = (long)ret;\r\nreturn offlined;\r\n}\r\nstatic int __ref offline_pages(unsigned long start_pfn,\r\nunsigned long end_pfn, unsigned long timeout)\r\n{\r\nunsigned long pfn, nr_pages, expire;\r\nlong offlined_pages;\r\nint ret, drain, retry_max, node;\r\nstruct zone *zone;\r\nstruct memory_notify arg;\r\nBUG_ON(start_pfn >= end_pfn);\r\nif (!IS_ALIGNED(start_pfn, pageblock_nr_pages))\r\nreturn -EINVAL;\r\nif (!IS_ALIGNED(end_pfn, pageblock_nr_pages))\r\nreturn -EINVAL;\r\nif (!test_pages_in_a_zone(start_pfn, end_pfn))\r\nreturn -EINVAL;\r\nlock_memory_hotplug();\r\nzone = page_zone(pfn_to_page(start_pfn));\r\nnode = zone_to_nid(zone);\r\nnr_pages = end_pfn - start_pfn;\r\nret = start_isolate_page_range(start_pfn, end_pfn);\r\nif (ret)\r\ngoto out;\r\narg.start_pfn = start_pfn;\r\narg.nr_pages = nr_pages;\r\narg.status_change_nid = -1;\r\nif (nr_pages >= node_present_pages(node))\r\narg.status_change_nid = node;\r\nret = memory_notify(MEM_GOING_OFFLINE, &arg);\r\nret = notifier_to_errno(ret);\r\nif (ret)\r\ngoto failed_removal;\r\npfn = start_pfn;\r\nexpire = jiffies + timeout;\r\ndrain = 0;\r\nretry_max = 5;\r\nrepeat:\r\nret = -EAGAIN;\r\nif (time_after(jiffies, expire))\r\ngoto failed_removal;\r\nret = -EINTR;\r\nif (signal_pending(current))\r\ngoto failed_removal;\r\nret = 0;\r\nif (drain) {\r\nlru_add_drain_all();\r\ncond_resched();\r\ndrain_all_pages();\r\n}\r\npfn = scan_lru_pages(start_pfn, end_pfn);\r\nif (pfn) {\r\nret = do_migrate_range(pfn, end_pfn);\r\nif (!ret) {\r\ndrain = 1;\r\ngoto repeat;\r\n} else {\r\nif (ret < 0)\r\nif (--retry_max == 0)\r\ngoto failed_removal;\r\nyield();\r\ndrain = 1;\r\ngoto repeat;\r\n}\r\n}\r\nlru_add_drain_all();\r\nyield();\r\ndrain_all_pages();\r\nofflined_pages = check_pages_isolated(start_pfn, end_pfn);\r\nif (offlined_pages < 0) {\r\nret = -EBUSY;\r\ngoto failed_removal;\r\n}\r\nprintk(KERN_INFO "Offlined Pages %ld\n", offlined_pages);\r\noffline_isolated_pages(start_pfn, end_pfn);\r\nundo_isolate_page_range(start_pfn, end_pfn);\r\nzone->present_pages -= offlined_pages;\r\nzone->zone_pgdat->node_present_pages -= offlined_pages;\r\ntotalram_pages -= offlined_pages;\r\ninit_per_zone_wmark_min();\r\nif (!node_present_pages(node)) {\r\nnode_clear_state(node, N_HIGH_MEMORY);\r\nkswapd_stop(node);\r\n}\r\nvm_total_pages = nr_free_pagecache_pages();\r\nwriteback_set_ratelimit();\r\nmemory_notify(MEM_OFFLINE, &arg);\r\nunlock_memory_hotplug();\r\nreturn 0;\r\nfailed_removal:\r\nprintk(KERN_INFO "memory offlining %lx to %lx failed\n",\r\nstart_pfn, end_pfn);\r\nmemory_notify(MEM_CANCEL_OFFLINE, &arg);\r\nundo_isolate_page_range(start_pfn, end_pfn);\r\nout:\r\nunlock_memory_hotplug();\r\nreturn ret;\r\n}\r\nint remove_memory(u64 start, u64 size)\r\n{\r\nunsigned long start_pfn, end_pfn;\r\nstart_pfn = PFN_DOWN(start);\r\nend_pfn = start_pfn + PFN_DOWN(size);\r\nreturn offline_pages(start_pfn, end_pfn, 120 * HZ);\r\n}\r\nint remove_memory(u64 start, u64 size)\r\n{\r\nreturn -EINVAL;\r\n}
