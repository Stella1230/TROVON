static loff_t eisa_eeprom_llseek(struct file *file, loff_t offset, int origin )\r\n{\r\nswitch (origin) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\noffset += file->f_pos;\r\nbreak;\r\ncase 2:\r\noffset += HPEE_MAX_LENGTH;\r\nbreak;\r\n}\r\nreturn (offset >= 0 && offset < HPEE_MAX_LENGTH) ? (file->f_pos = offset) : -EINVAL;\r\n}\r\nstatic ssize_t eisa_eeprom_read(struct file * file,\r\nchar __user *buf, size_t count, loff_t *ppos )\r\n{\r\nunsigned char *tmp;\r\nssize_t ret;\r\nint i;\r\nif (*ppos < 0 || *ppos >= HPEE_MAX_LENGTH)\r\nreturn 0;\r\ncount = *ppos + count < HPEE_MAX_LENGTH ? count : HPEE_MAX_LENGTH - *ppos;\r\ntmp = kmalloc(count, GFP_KERNEL);\r\nif (tmp) {\r\nfor (i = 0; i < count; i++)\r\ntmp[i] = readb(eisa_eeprom_addr+(*ppos)++);\r\nif (copy_to_user (buf, tmp, count))\r\nret = -EFAULT;\r\nelse\r\nret = count;\r\nkfree (tmp);\r\n} else\r\nret = -ENOMEM;\r\nreturn ret;\r\n}\r\nstatic int eisa_eeprom_open(struct inode *inode, struct file *file)\r\n{\r\nif (file->f_mode & FMODE_WRITE)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int eisa_eeprom_release(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init eisa_eeprom_init(void)\r\n{\r\nint retval;\r\nif (!eisa_eeprom_addr)\r\nreturn -ENODEV;\r\nretval = misc_register(&eisa_eeprom_dev);\r\nif (retval < 0) {\r\nprintk(KERN_ERR "EISA EEPROM: cannot register misc device.\n");\r\nreturn retval;\r\n}\r\nprintk(KERN_INFO "EISA EEPROM at 0x%p\n", eisa_eeprom_addr);\r\nreturn 0;\r\n}
