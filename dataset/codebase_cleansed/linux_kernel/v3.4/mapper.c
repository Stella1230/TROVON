int crush_find_rule(struct crush_map *map, int ruleset, int type, int size)\r\n{\r\nint i;\r\nfor (i = 0; i < map->max_rules; i++) {\r\nif (map->rules[i] &&\r\nmap->rules[i]->mask.ruleset == ruleset &&\r\nmap->rules[i]->mask.type == type &&\r\nmap->rules[i]->mask.min_size <= size &&\r\nmap->rules[i]->mask.max_size >= size)\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nstatic int bucket_perm_choose(struct crush_bucket *bucket,\r\nint x, int r)\r\n{\r\nunsigned pr = r % bucket->size;\r\nunsigned i, s;\r\nif (bucket->perm_x != x || bucket->perm_n == 0) {\r\ndprintk("bucket %d new x=%d\n", bucket->id, x);\r\nbucket->perm_x = x;\r\nif (pr == 0) {\r\ns = crush_hash32_3(bucket->hash, x, bucket->id, 0) %\r\nbucket->size;\r\nbucket->perm[0] = s;\r\nbucket->perm_n = 0xffff;\r\ngoto out;\r\n}\r\nfor (i = 0; i < bucket->size; i++)\r\nbucket->perm[i] = i;\r\nbucket->perm_n = 0;\r\n} else if (bucket->perm_n == 0xffff) {\r\nfor (i = 1; i < bucket->size; i++)\r\nbucket->perm[i] = i;\r\nbucket->perm[bucket->perm[0]] = 0;\r\nbucket->perm_n = 1;\r\n}\r\nfor (i = 0; i < bucket->perm_n; i++)\r\ndprintk(" perm_choose have %d: %d\n", i, bucket->perm[i]);\r\nwhile (bucket->perm_n <= pr) {\r\nunsigned p = bucket->perm_n;\r\nif (p < bucket->size - 1) {\r\ni = crush_hash32_3(bucket->hash, x, bucket->id, p) %\r\n(bucket->size - p);\r\nif (i) {\r\nunsigned t = bucket->perm[p + i];\r\nbucket->perm[p + i] = bucket->perm[p];\r\nbucket->perm[p] = t;\r\n}\r\ndprintk(" perm_choose swap %d with %d\n", p, p+i);\r\n}\r\nbucket->perm_n++;\r\n}\r\nfor (i = 0; i < bucket->size; i++)\r\ndprintk(" perm_choose %d: %d\n", i, bucket->perm[i]);\r\ns = bucket->perm[pr];\r\nout:\r\ndprintk(" perm_choose %d sz=%d x=%d r=%d (%d) s=%d\n", bucket->id,\r\nbucket->size, x, r, pr, s);\r\nreturn bucket->items[s];\r\n}\r\nstatic int bucket_uniform_choose(struct crush_bucket_uniform *bucket,\r\nint x, int r)\r\n{\r\nreturn bucket_perm_choose(&bucket->h, x, r);\r\n}\r\nstatic int bucket_list_choose(struct crush_bucket_list *bucket,\r\nint x, int r)\r\n{\r\nint i;\r\nfor (i = bucket->h.size-1; i >= 0; i--) {\r\n__u64 w = crush_hash32_4(bucket->h.hash,x, bucket->h.items[i],\r\nr, bucket->h.id);\r\nw &= 0xffff;\r\ndprintk("list_choose i=%d x=%d r=%d item %d weight %x "\r\n"sw %x rand %llx",\r\ni, x, r, bucket->h.items[i], bucket->item_weights[i],\r\nbucket->sum_weights[i], w);\r\nw *= bucket->sum_weights[i];\r\nw = w >> 16;\r\nif (w < bucket->item_weights[i])\r\nreturn bucket->h.items[i];\r\n}\r\nBUG_ON(1);\r\nreturn 0;\r\n}\r\nstatic int height(int n)\r\n{\r\nint h = 0;\r\nwhile ((n & 1) == 0) {\r\nh++;\r\nn = n >> 1;\r\n}\r\nreturn h;\r\n}\r\nstatic int left(int x)\r\n{\r\nint h = height(x);\r\nreturn x - (1 << (h-1));\r\n}\r\nstatic int right(int x)\r\n{\r\nint h = height(x);\r\nreturn x + (1 << (h-1));\r\n}\r\nstatic int terminal(int x)\r\n{\r\nreturn x & 1;\r\n}\r\nstatic int bucket_tree_choose(struct crush_bucket_tree *bucket,\r\nint x, int r)\r\n{\r\nint n, l;\r\n__u32 w;\r\n__u64 t;\r\nn = bucket->num_nodes >> 1;\r\nwhile (!terminal(n)) {\r\nw = bucket->node_weights[n];\r\nt = (__u64)crush_hash32_4(bucket->h.hash, x, n, r,\r\nbucket->h.id) * (__u64)w;\r\nt = t >> 32;\r\nl = left(n);\r\nif (t < bucket->node_weights[l])\r\nn = l;\r\nelse\r\nn = right(n);\r\n}\r\nreturn bucket->h.items[n >> 1];\r\n}\r\nstatic int bucket_straw_choose(struct crush_bucket_straw *bucket,\r\nint x, int r)\r\n{\r\nint i;\r\nint high = 0;\r\n__u64 high_draw = 0;\r\n__u64 draw;\r\nfor (i = 0; i < bucket->h.size; i++) {\r\ndraw = crush_hash32_3(bucket->h.hash, x, bucket->h.items[i], r);\r\ndraw &= 0xffff;\r\ndraw *= bucket->straws[i];\r\nif (i == 0 || draw > high_draw) {\r\nhigh = i;\r\nhigh_draw = draw;\r\n}\r\n}\r\nreturn bucket->h.items[high];\r\n}\r\nstatic int crush_bucket_choose(struct crush_bucket *in, int x, int r)\r\n{\r\ndprintk(" crush_bucket_choose %d x=%d r=%d\n", in->id, x, r);\r\nswitch (in->alg) {\r\ncase CRUSH_BUCKET_UNIFORM:\r\nreturn bucket_uniform_choose((struct crush_bucket_uniform *)in,\r\nx, r);\r\ncase CRUSH_BUCKET_LIST:\r\nreturn bucket_list_choose((struct crush_bucket_list *)in,\r\nx, r);\r\ncase CRUSH_BUCKET_TREE:\r\nreturn bucket_tree_choose((struct crush_bucket_tree *)in,\r\nx, r);\r\ncase CRUSH_BUCKET_STRAW:\r\nreturn bucket_straw_choose((struct crush_bucket_straw *)in,\r\nx, r);\r\ndefault:\r\nBUG_ON(1);\r\nreturn in->items[0];\r\n}\r\n}\r\nstatic int is_out(struct crush_map *map, __u32 *weight, int item, int x)\r\n{\r\nif (weight[item] >= 0x10000)\r\nreturn 0;\r\nif (weight[item] == 0)\r\nreturn 1;\r\nif ((crush_hash32_2(CRUSH_HASH_RJENKINS1, x, item) & 0xffff)\r\n< weight[item])\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int crush_choose(struct crush_map *map,\r\nstruct crush_bucket *bucket,\r\n__u32 *weight,\r\nint x, int numrep, int type,\r\nint *out, int outpos,\r\nint firstn, int recurse_to_leaf,\r\nint *out2)\r\n{\r\nint rep;\r\nint ftotal, flocal;\r\nint retry_descent, retry_bucket, skip_rep;\r\nstruct crush_bucket *in = bucket;\r\nint r;\r\nint i;\r\nint item = 0;\r\nint itemtype;\r\nint collide, reject;\r\nconst int orig_tries = 5;\r\ndprintk("CHOOSE%s bucket %d x %d outpos %d numrep %d\n", recurse_to_leaf ? "_LEAF" : "",\r\nbucket->id, x, outpos, numrep);\r\nfor (rep = outpos; rep < numrep; rep++) {\r\nftotal = 0;\r\nskip_rep = 0;\r\ndo {\r\nretry_descent = 0;\r\nin = bucket;\r\nflocal = 0;\r\ndo {\r\ncollide = 0;\r\nretry_bucket = 0;\r\nr = rep;\r\nif (in->alg == CRUSH_BUCKET_UNIFORM) {\r\nif (firstn || numrep >= in->size)\r\nr += ftotal;\r\nelse if (in->size % numrep == 0)\r\nr += (numrep+1) *\r\n(flocal+ftotal);\r\nelse\r\nr += numrep * (flocal+ftotal);\r\n} else {\r\nif (firstn)\r\nr += ftotal;\r\nelse\r\nr += numrep * (flocal+ftotal);\r\n}\r\nif (in->size == 0) {\r\nreject = 1;\r\ngoto reject;\r\n}\r\nif (flocal >= (in->size>>1) &&\r\nflocal > orig_tries)\r\nitem = bucket_perm_choose(in, x, r);\r\nelse\r\nitem = crush_bucket_choose(in, x, r);\r\nBUG_ON(item >= map->max_devices);\r\nif (item < 0)\r\nitemtype = map->buckets[-1-item]->type;\r\nelse\r\nitemtype = 0;\r\ndprintk(" item %d type %d\n", item, itemtype);\r\nif (itemtype != type) {\r\nBUG_ON(item >= 0 ||\r\n(-1-item) >= map->max_buckets);\r\nin = map->buckets[-1-item];\r\nretry_bucket = 1;\r\ncontinue;\r\n}\r\nfor (i = 0; i < outpos; i++) {\r\nif (out[i] == item) {\r\ncollide = 1;\r\nbreak;\r\n}\r\n}\r\nreject = 0;\r\nif (recurse_to_leaf) {\r\nif (item < 0) {\r\nif (crush_choose(map,\r\nmap->buckets[-1-item],\r\nweight,\r\nx, outpos+1, 0,\r\nout2, outpos,\r\nfirstn, 0,\r\nNULL) <= outpos)\r\nreject = 1;\r\n} else {\r\nout2[outpos] = item;\r\n}\r\n}\r\nif (!reject) {\r\nif (itemtype == 0)\r\nreject = is_out(map, weight,\r\nitem, x);\r\nelse\r\nreject = 0;\r\n}\r\nreject:\r\nif (reject || collide) {\r\nftotal++;\r\nflocal++;\r\nif (collide && flocal < 3)\r\nretry_bucket = 1;\r\nelse if (flocal < in->size + orig_tries)\r\nretry_bucket = 1;\r\nelse if (ftotal < 20)\r\nretry_descent = 1;\r\nelse\r\nskip_rep = 1;\r\ndprintk(" reject %d collide %d "\r\n"ftotal %d flocal %d\n",\r\nreject, collide, ftotal,\r\nflocal);\r\n}\r\n} while (retry_bucket);\r\n} while (retry_descent);\r\nif (skip_rep) {\r\ndprintk("skip rep\n");\r\ncontinue;\r\n}\r\ndprintk("CHOOSE got %d\n", item);\r\nout[outpos] = item;\r\noutpos++;\r\n}\r\ndprintk("CHOOSE returns %d\n", outpos);\r\nreturn outpos;\r\n}\r\nint crush_do_rule(struct crush_map *map,\r\nint ruleno, int x, int *result, int result_max,\r\nint force, __u32 *weight)\r\n{\r\nint result_len;\r\nint force_context[CRUSH_MAX_DEPTH];\r\nint force_pos = -1;\r\nint a[CRUSH_MAX_SET];\r\nint b[CRUSH_MAX_SET];\r\nint c[CRUSH_MAX_SET];\r\nint recurse_to_leaf;\r\nint *w;\r\nint wsize = 0;\r\nint *o;\r\nint osize;\r\nint *tmp;\r\nstruct crush_rule *rule;\r\nint step;\r\nint i, j;\r\nint numrep;\r\nint firstn;\r\nBUG_ON(ruleno >= map->max_rules);\r\nrule = map->rules[ruleno];\r\nresult_len = 0;\r\nw = a;\r\no = b;\r\nif (force >= 0 &&\r\nforce < map->max_devices &&\r\nmap->device_parents[force] != 0 &&\r\n!is_out(map, weight, force, x)) {\r\nwhile (1) {\r\nforce_context[++force_pos] = force;\r\nif (force >= 0)\r\nforce = map->device_parents[force];\r\nelse\r\nforce = map->bucket_parents[-1-force];\r\nif (force == 0)\r\nbreak;\r\n}\r\n}\r\nfor (step = 0; step < rule->len; step++) {\r\nfirstn = 0;\r\nswitch (rule->steps[step].op) {\r\ncase CRUSH_RULE_TAKE:\r\nw[0] = rule->steps[step].arg1;\r\nwhile (force_pos >= 0 &&\r\nforce_context[force_pos] != w[0])\r\nforce_pos--;\r\nif (force_pos >= 0)\r\nforce_pos--;\r\nwsize = 1;\r\nbreak;\r\ncase CRUSH_RULE_CHOOSE_LEAF_FIRSTN:\r\ncase CRUSH_RULE_CHOOSE_FIRSTN:\r\nfirstn = 1;\r\ncase CRUSH_RULE_CHOOSE_LEAF_INDEP:\r\ncase CRUSH_RULE_CHOOSE_INDEP:\r\nBUG_ON(wsize == 0);\r\nrecurse_to_leaf =\r\nrule->steps[step].op ==\r\nCRUSH_RULE_CHOOSE_LEAF_FIRSTN ||\r\nrule->steps[step].op ==\r\nCRUSH_RULE_CHOOSE_LEAF_INDEP;\r\nosize = 0;\r\nfor (i = 0; i < wsize; i++) {\r\nnumrep = rule->steps[step].arg1;\r\nif (numrep <= 0) {\r\nnumrep += result_max;\r\nif (numrep <= 0)\r\ncontinue;\r\n}\r\nj = 0;\r\nif (osize == 0 && force_pos >= 0) {\r\nwhile (force_pos &&\r\nforce_context[force_pos] < 0 &&\r\nrule->steps[step].arg2 !=\r\nmap->buckets[-1 -\r\nforce_context[force_pos]]->type)\r\nforce_pos--;\r\no[osize] = force_context[force_pos];\r\nif (recurse_to_leaf)\r\nc[osize] = force_context[0];\r\nj++;\r\nforce_pos--;\r\n}\r\nosize += crush_choose(map,\r\nmap->buckets[-1-w[i]],\r\nweight,\r\nx, numrep,\r\nrule->steps[step].arg2,\r\no+osize, j,\r\nfirstn,\r\nrecurse_to_leaf, c+osize);\r\n}\r\nif (recurse_to_leaf)\r\nmemcpy(o, c, osize*sizeof(*o));\r\ntmp = o;\r\no = w;\r\nw = tmp;\r\nwsize = osize;\r\nbreak;\r\ncase CRUSH_RULE_EMIT:\r\nfor (i = 0; i < wsize && result_len < result_max; i++) {\r\nresult[result_len] = w[i];\r\nresult_len++;\r\n}\r\nwsize = 0;\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\n}\r\n}\r\nreturn result_len;\r\n}
