static inline void\r\nregion_put(struct nouveau_mm *mm, struct nouveau_mm_node *a)\r\n{\r\nlist_del(&a->nl_entry);\r\nlist_del(&a->fl_entry);\r\nkfree(a);\r\n}\r\nstatic struct nouveau_mm_node *\r\nregion_split(struct nouveau_mm *mm, struct nouveau_mm_node *a, u32 size)\r\n{\r\nstruct nouveau_mm_node *b;\r\nif (a->length == size)\r\nreturn a;\r\nb = kmalloc(sizeof(*b), GFP_KERNEL);\r\nif (unlikely(b == NULL))\r\nreturn NULL;\r\nb->offset = a->offset;\r\nb->length = size;\r\nb->type = a->type;\r\na->offset += size;\r\na->length -= size;\r\nlist_add_tail(&b->nl_entry, &a->nl_entry);\r\nif (b->type == 0)\r\nlist_add_tail(&b->fl_entry, &a->fl_entry);\r\nreturn b;\r\n}\r\nvoid\r\nnouveau_mm_put(struct nouveau_mm *mm, struct nouveau_mm_node *this)\r\n{\r\nstruct nouveau_mm_node *prev = node(this, prev);\r\nstruct nouveau_mm_node *next = node(this, next);\r\nlist_add(&this->fl_entry, &mm->free);\r\nthis->type = 0;\r\nif (prev && prev->type == 0) {\r\nprev->length += this->length;\r\nregion_put(mm, this);\r\nthis = prev;\r\n}\r\nif (next && next->type == 0) {\r\nnext->offset = this->offset;\r\nnext->length += this->length;\r\nregion_put(mm, this);\r\n}\r\n}\r\nint\r\nnouveau_mm_get(struct nouveau_mm *mm, int type, u32 size, u32 size_nc,\r\nu32 align, struct nouveau_mm_node **pnode)\r\n{\r\nstruct nouveau_mm_node *prev, *this, *next;\r\nu32 min = size_nc ? size_nc : size;\r\nu32 align_mask = align - 1;\r\nu32 splitoff;\r\nu32 s, e;\r\nlist_for_each_entry(this, &mm->free, fl_entry) {\r\ne = this->offset + this->length;\r\ns = this->offset;\r\nprev = node(this, prev);\r\nif (prev && prev->type != type)\r\ns = roundup(s, mm->block_size);\r\nnext = node(this, next);\r\nif (next && next->type != type)\r\ne = rounddown(e, mm->block_size);\r\ns = (s + align_mask) & ~align_mask;\r\ne &= ~align_mask;\r\nif (s > e || e - s < min)\r\ncontinue;\r\nsplitoff = s - this->offset;\r\nif (splitoff && !region_split(mm, this, splitoff))\r\nreturn -ENOMEM;\r\nthis = region_split(mm, this, min(size, e - s));\r\nif (!this)\r\nreturn -ENOMEM;\r\nthis->type = type;\r\nlist_del(&this->fl_entry);\r\n*pnode = this;\r\nreturn 0;\r\n}\r\nreturn -ENOSPC;\r\n}\r\nint\r\nnouveau_mm_init(struct nouveau_mm *mm, u32 offset, u32 length, u32 block)\r\n{\r\nstruct nouveau_mm_node *node;\r\nif (block) {\r\nmutex_init(&mm->mutex);\r\nINIT_LIST_HEAD(&mm->nodes);\r\nINIT_LIST_HEAD(&mm->free);\r\nmm->block_size = block;\r\nmm->heap_nodes = 0;\r\n}\r\nnode = kzalloc(sizeof(*node), GFP_KERNEL);\r\nif (!node)\r\nreturn -ENOMEM;\r\nnode->offset = roundup(offset, mm->block_size);\r\nnode->length = rounddown(offset + length, mm->block_size) - node->offset;\r\nlist_add_tail(&node->nl_entry, &mm->nodes);\r\nlist_add_tail(&node->fl_entry, &mm->free);\r\nmm->heap_nodes++;\r\nreturn 0;\r\n}\r\nint\r\nnouveau_mm_fini(struct nouveau_mm *mm)\r\n{\r\nstruct nouveau_mm_node *node, *heap =\r\nlist_first_entry(&mm->nodes, struct nouveau_mm_node, nl_entry);\r\nint nodes = 0;\r\nlist_for_each_entry(node, &mm->nodes, nl_entry) {\r\nif (nodes++ == mm->heap_nodes) {\r\nprintk(KERN_ERR "nouveau_mm in use at destroy time!\n");\r\nlist_for_each_entry(node, &mm->nodes, nl_entry) {\r\nprintk(KERN_ERR "0x%02x: 0x%08x 0x%08x\n",\r\nnode->type, node->offset, node->length);\r\n}\r\nWARN_ON(1);\r\nreturn -EBUSY;\r\n}\r\n}\r\nkfree(heap);\r\nreturn 0;\r\n}
