static void stub_free_priv_and_urb(struct stub_priv *priv)\r\n{\r\nstruct urb *urb = priv->urb;\r\nkfree(urb->setup_packet);\r\nkfree(urb->transfer_buffer);\r\nlist_del(&priv->list);\r\nkmem_cache_free(stub_priv_cache, priv);\r\nusb_free_urb(urb);\r\n}\r\nvoid stub_enqueue_ret_unlink(struct stub_device *sdev, __u32 seqnum,\r\n__u32 status)\r\n{\r\nstruct stub_unlink *unlink;\r\nunlink = kzalloc(sizeof(struct stub_unlink), GFP_ATOMIC);\r\nif (!unlink) {\r\ndev_err(&sdev->interface->dev, "alloc stub_unlink\n");\r\nusbip_event_add(&sdev->ud, VDEV_EVENT_ERROR_MALLOC);\r\nreturn;\r\n}\r\nunlink->seqnum = seqnum;\r\nunlink->status = status;\r\nlist_add_tail(&unlink->list, &sdev->unlink_tx);\r\n}\r\nvoid stub_complete(struct urb *urb)\r\n{\r\nstruct stub_priv *priv = (struct stub_priv *) urb->context;\r\nstruct stub_device *sdev = priv->sdev;\r\nunsigned long flags;\r\nusbip_dbg_stub_tx("complete! status %d\n", urb->status);\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ENOENT:\r\ndev_info(&urb->dev->dev, "stopped by a call to usb_kill_urb() "\r\n"because of cleaning up a virtual connection\n");\r\nreturn;\r\ncase -ECONNRESET:\r\ndev_info(&urb->dev->dev, "unlinked by a call to "\r\n"usb_unlink_urb()\n");\r\nbreak;\r\ncase -EPIPE:\r\ndev_info(&urb->dev->dev, "endpoint %d is stalled\n",\r\nusb_pipeendpoint(urb->pipe));\r\nbreak;\r\ncase -ESHUTDOWN:\r\ndev_info(&urb->dev->dev, "device removed?\n");\r\nbreak;\r\ndefault:\r\ndev_info(&urb->dev->dev, "urb completion with non-zero status "\r\n"%d\n", urb->status);\r\nbreak;\r\n}\r\nspin_lock_irqsave(&sdev->priv_lock, flags);\r\nif (priv->unlinking) {\r\nstub_enqueue_ret_unlink(sdev, priv->seqnum, urb->status);\r\nstub_free_priv_and_urb(priv);\r\n} else {\r\nlist_move_tail(&priv->list, &sdev->priv_tx);\r\n}\r\nspin_unlock_irqrestore(&sdev->priv_lock, flags);\r\nwake_up(&sdev->tx_waitq);\r\n}\r\nstatic inline void setup_base_pdu(struct usbip_header_basic *base,\r\n__u32 command, __u32 seqnum)\r\n{\r\nbase->command = command;\r\nbase->seqnum = seqnum;\r\nbase->devid = 0;\r\nbase->ep = 0;\r\nbase->direction = 0;\r\n}\r\nstatic void setup_ret_submit_pdu(struct usbip_header *rpdu, struct urb *urb)\r\n{\r\nstruct stub_priv *priv = (struct stub_priv *) urb->context;\r\nsetup_base_pdu(&rpdu->base, USBIP_RET_SUBMIT, priv->seqnum);\r\nusbip_pack_pdu(rpdu, urb, USBIP_RET_SUBMIT, 1);\r\n}\r\nstatic void setup_ret_unlink_pdu(struct usbip_header *rpdu,\r\nstruct stub_unlink *unlink)\r\n{\r\nsetup_base_pdu(&rpdu->base, USBIP_RET_UNLINK, unlink->seqnum);\r\nrpdu->u.ret_unlink.status = unlink->status;\r\n}\r\nstatic struct stub_priv *dequeue_from_priv_tx(struct stub_device *sdev)\r\n{\r\nunsigned long flags;\r\nstruct stub_priv *priv, *tmp;\r\nspin_lock_irqsave(&sdev->priv_lock, flags);\r\nlist_for_each_entry_safe(priv, tmp, &sdev->priv_tx, list) {\r\nlist_move_tail(&priv->list, &sdev->priv_free);\r\nspin_unlock_irqrestore(&sdev->priv_lock, flags);\r\nreturn priv;\r\n}\r\nspin_unlock_irqrestore(&sdev->priv_lock, flags);\r\nreturn NULL;\r\n}\r\nstatic int stub_send_ret_submit(struct stub_device *sdev)\r\n{\r\nunsigned long flags;\r\nstruct stub_priv *priv, *tmp;\r\nstruct msghdr msg;\r\nsize_t txsize;\r\nsize_t total_size = 0;\r\nwhile ((priv = dequeue_from_priv_tx(sdev)) != NULL) {\r\nint ret;\r\nstruct urb *urb = priv->urb;\r\nstruct usbip_header pdu_header;\r\nvoid *iso_buffer = NULL;\r\nstruct kvec *iov = NULL;\r\nint iovnum = 0;\r\ntxsize = 0;\r\nmemset(&pdu_header, 0, sizeof(pdu_header));\r\nmemset(&msg, 0, sizeof(msg));\r\nif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS)\r\niovnum = 2 + urb->number_of_packets;\r\nelse\r\niovnum = 2;\r\niov = kzalloc(iovnum * sizeof(struct kvec), GFP_KERNEL);\r\nif (!iov) {\r\nusbip_event_add(&sdev->ud, SDEV_EVENT_ERROR_MALLOC);\r\nreturn -1;\r\n}\r\niovnum = 0;\r\nsetup_ret_submit_pdu(&pdu_header, urb);\r\nusbip_dbg_stub_tx("setup txdata seqnum: %d urb: %p\n",\r\npdu_header.base.seqnum, urb);\r\nusbip_header_correct_endian(&pdu_header, 1);\r\niov[iovnum].iov_base = &pdu_header;\r\niov[iovnum].iov_len = sizeof(pdu_header);\r\niovnum++;\r\ntxsize += sizeof(pdu_header);\r\nif (usb_pipein(urb->pipe) &&\r\nusb_pipetype(urb->pipe) != PIPE_ISOCHRONOUS &&\r\nurb->actual_length > 0) {\r\niov[iovnum].iov_base = urb->transfer_buffer;\r\niov[iovnum].iov_len = urb->actual_length;\r\niovnum++;\r\ntxsize += urb->actual_length;\r\n} else if (usb_pipein(urb->pipe) &&\r\nusb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {\r\nint i;\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\niov[iovnum].iov_base = urb->transfer_buffer +\r\nurb->iso_frame_desc[i].offset;\r\niov[iovnum].iov_len =\r\nurb->iso_frame_desc[i].actual_length;\r\niovnum++;\r\ntxsize += urb->iso_frame_desc[i].actual_length;\r\n}\r\nif (txsize != sizeof(pdu_header) + urb->actual_length) {\r\ndev_err(&sdev->interface->dev,\r\n"actual length of urb %d does not "\r\n"match iso packet sizes %zu\n",\r\nurb->actual_length,\r\ntxsize-sizeof(pdu_header));\r\nkfree(iov);\r\nusbip_event_add(&sdev->ud,\r\nSDEV_EVENT_ERROR_TCP);\r\nreturn -1;\r\n}\r\n}\r\nif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {\r\nssize_t len = 0;\r\niso_buffer = usbip_alloc_iso_desc_pdu(urb, &len);\r\nif (!iso_buffer) {\r\nusbip_event_add(&sdev->ud,\r\nSDEV_EVENT_ERROR_MALLOC);\r\nkfree(iov);\r\nreturn -1;\r\n}\r\niov[iovnum].iov_base = iso_buffer;\r\niov[iovnum].iov_len = len;\r\ntxsize += len;\r\niovnum++;\r\n}\r\nret = kernel_sendmsg(sdev->ud.tcp_socket, &msg,\r\niov, iovnum, txsize);\r\nif (ret != txsize) {\r\ndev_err(&sdev->interface->dev,\r\n"sendmsg failed!, retval %d for %zd\n",\r\nret, txsize);\r\nkfree(iov);\r\nkfree(iso_buffer);\r\nusbip_event_add(&sdev->ud, SDEV_EVENT_ERROR_TCP);\r\nreturn -1;\r\n}\r\nkfree(iov);\r\nkfree(iso_buffer);\r\ntotal_size += txsize;\r\n}\r\nspin_lock_irqsave(&sdev->priv_lock, flags);\r\nlist_for_each_entry_safe(priv, tmp, &sdev->priv_free, list) {\r\nstub_free_priv_and_urb(priv);\r\n}\r\nspin_unlock_irqrestore(&sdev->priv_lock, flags);\r\nreturn total_size;\r\n}\r\nstatic struct stub_unlink *dequeue_from_unlink_tx(struct stub_device *sdev)\r\n{\r\nunsigned long flags;\r\nstruct stub_unlink *unlink, *tmp;\r\nspin_lock_irqsave(&sdev->priv_lock, flags);\r\nlist_for_each_entry_safe(unlink, tmp, &sdev->unlink_tx, list) {\r\nlist_move_tail(&unlink->list, &sdev->unlink_free);\r\nspin_unlock_irqrestore(&sdev->priv_lock, flags);\r\nreturn unlink;\r\n}\r\nspin_unlock_irqrestore(&sdev->priv_lock, flags);\r\nreturn NULL;\r\n}\r\nstatic int stub_send_ret_unlink(struct stub_device *sdev)\r\n{\r\nunsigned long flags;\r\nstruct stub_unlink *unlink, *tmp;\r\nstruct msghdr msg;\r\nstruct kvec iov[1];\r\nsize_t txsize;\r\nsize_t total_size = 0;\r\nwhile ((unlink = dequeue_from_unlink_tx(sdev)) != NULL) {\r\nint ret;\r\nstruct usbip_header pdu_header;\r\ntxsize = 0;\r\nmemset(&pdu_header, 0, sizeof(pdu_header));\r\nmemset(&msg, 0, sizeof(msg));\r\nmemset(&iov, 0, sizeof(iov));\r\nusbip_dbg_stub_tx("setup ret unlink %lu\n", unlink->seqnum);\r\nsetup_ret_unlink_pdu(&pdu_header, unlink);\r\nusbip_header_correct_endian(&pdu_header, 1);\r\niov[0].iov_base = &pdu_header;\r\niov[0].iov_len = sizeof(pdu_header);\r\ntxsize += sizeof(pdu_header);\r\nret = kernel_sendmsg(sdev->ud.tcp_socket, &msg, iov,\r\n1, txsize);\r\nif (ret != txsize) {\r\ndev_err(&sdev->interface->dev,\r\n"sendmsg failed!, retval %d for %zd\n",\r\nret, txsize);\r\nusbip_event_add(&sdev->ud, SDEV_EVENT_ERROR_TCP);\r\nreturn -1;\r\n}\r\nusbip_dbg_stub_tx("send txdata\n");\r\ntotal_size += txsize;\r\n}\r\nspin_lock_irqsave(&sdev->priv_lock, flags);\r\nlist_for_each_entry_safe(unlink, tmp, &sdev->unlink_free, list) {\r\nlist_del(&unlink->list);\r\nkfree(unlink);\r\n}\r\nspin_unlock_irqrestore(&sdev->priv_lock, flags);\r\nreturn total_size;\r\n}\r\nint stub_tx_loop(void *data)\r\n{\r\nstruct usbip_device *ud = data;\r\nstruct stub_device *sdev = container_of(ud, struct stub_device, ud);\r\nwhile (!kthread_should_stop()) {\r\nif (usbip_event_happened(ud))\r\nbreak;\r\nif (stub_send_ret_submit(sdev) < 0)\r\nbreak;\r\nif (stub_send_ret_unlink(sdev) < 0)\r\nbreak;\r\nwait_event_interruptible(sdev->tx_waitq,\r\n(!list_empty(&sdev->priv_tx) ||\r\n!list_empty(&sdev->unlink_tx) ||\r\nkthread_should_stop()));\r\n}\r\nreturn 0;\r\n}
