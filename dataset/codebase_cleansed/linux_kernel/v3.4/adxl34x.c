static void adxl34x_get_triple(struct adxl34x *ac, struct axis_triple *axis)\r\n{\r\nshort buf[3];\r\nac->bops->read_block(ac->dev, DATAX0, DATAZ1 - DATAX0 + 1, buf);\r\nmutex_lock(&ac->mutex);\r\nac->saved.x = (s16) le16_to_cpu(buf[0]);\r\naxis->x = ac->saved.x;\r\nac->saved.y = (s16) le16_to_cpu(buf[1]);\r\naxis->y = ac->saved.y;\r\nac->saved.z = (s16) le16_to_cpu(buf[2]);\r\naxis->z = ac->saved.z;\r\nmutex_unlock(&ac->mutex);\r\n}\r\nstatic void adxl34x_service_ev_fifo(struct adxl34x *ac)\r\n{\r\nstruct adxl34x_platform_data *pdata = &ac->pdata;\r\nstruct axis_triple axis;\r\nadxl34x_get_triple(ac, &axis);\r\ninput_event(ac->input, pdata->ev_type, pdata->ev_code_x,\r\naxis.x - ac->swcal.x);\r\ninput_event(ac->input, pdata->ev_type, pdata->ev_code_y,\r\naxis.y - ac->swcal.y);\r\ninput_event(ac->input, pdata->ev_type, pdata->ev_code_z,\r\naxis.z - ac->swcal.z);\r\n}\r\nstatic void adxl34x_report_key_single(struct input_dev *input, int key)\r\n{\r\ninput_report_key(input, key, true);\r\ninput_sync(input);\r\ninput_report_key(input, key, false);\r\n}\r\nstatic void adxl34x_send_key_events(struct adxl34x *ac,\r\nstruct adxl34x_platform_data *pdata, int status, int press)\r\n{\r\nint i;\r\nfor (i = ADXL_X_AXIS; i <= ADXL_Z_AXIS; i++) {\r\nif (status & (1 << (ADXL_Z_AXIS - i)))\r\ninput_report_key(ac->input,\r\npdata->ev_code_tap[i], press);\r\n}\r\n}\r\nstatic void adxl34x_do_tap(struct adxl34x *ac,\r\nstruct adxl34x_platform_data *pdata, int status)\r\n{\r\nadxl34x_send_key_events(ac, pdata, status, true);\r\ninput_sync(ac->input);\r\nadxl34x_send_key_events(ac, pdata, status, false);\r\n}\r\nstatic irqreturn_t adxl34x_irq(int irq, void *handle)\r\n{\r\nstruct adxl34x *ac = handle;\r\nstruct adxl34x_platform_data *pdata = &ac->pdata;\r\nint int_stat, tap_stat, samples, orient, orient_code;\r\nif (pdata->tap_axis_control & (TAP_X_EN | TAP_Y_EN | TAP_Z_EN))\r\ntap_stat = AC_READ(ac, ACT_TAP_STATUS);\r\nelse\r\ntap_stat = 0;\r\nint_stat = AC_READ(ac, INT_SOURCE);\r\nif (int_stat & FREE_FALL)\r\nadxl34x_report_key_single(ac->input, pdata->ev_code_ff);\r\nif (int_stat & OVERRUN)\r\ndev_dbg(ac->dev, "OVERRUN\n");\r\nif (int_stat & (SINGLE_TAP | DOUBLE_TAP)) {\r\nadxl34x_do_tap(ac, pdata, tap_stat);\r\nif (int_stat & DOUBLE_TAP)\r\nadxl34x_do_tap(ac, pdata, tap_stat);\r\n}\r\nif (pdata->ev_code_act_inactivity) {\r\nif (int_stat & ACTIVITY)\r\ninput_report_key(ac->input,\r\npdata->ev_code_act_inactivity, 1);\r\nif (int_stat & INACTIVITY)\r\ninput_report_key(ac->input,\r\npdata->ev_code_act_inactivity, 0);\r\n}\r\nif (pdata->orientation_enable) {\r\norient = AC_READ(ac, ORIENT);\r\nif ((pdata->orientation_enable & ADXL_EN_ORIENTATION_2D) &&\r\n(orient & ADXL346_2D_VALID)) {\r\norient_code = ADXL346_2D_ORIENT(orient);\r\nif (ac->orient2d_saved != orient_code) {\r\nac->orient2d_saved = orient_code;\r\nadxl34x_report_key_single(ac->input,\r\npdata->ev_codes_orient_2d[orient_code]);\r\n}\r\n}\r\nif ((pdata->orientation_enable & ADXL_EN_ORIENTATION_3D) &&\r\n(orient & ADXL346_3D_VALID)) {\r\norient_code = ADXL346_3D_ORIENT(orient) - 1;\r\nif (ac->orient3d_saved != orient_code) {\r\nac->orient3d_saved = orient_code;\r\nadxl34x_report_key_single(ac->input,\r\npdata->ev_codes_orient_3d[orient_code]);\r\n}\r\n}\r\n}\r\nif (int_stat & (DATA_READY | WATERMARK)) {\r\nif (pdata->fifo_mode)\r\nsamples = ENTRIES(AC_READ(ac, FIFO_STATUS)) + 1;\r\nelse\r\nsamples = 1;\r\nfor (; samples > 0; samples--) {\r\nadxl34x_service_ev_fifo(ac);\r\nif (ac->fifo_delay && (samples > 1))\r\nudelay(3);\r\n}\r\n}\r\ninput_sync(ac->input);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void __adxl34x_disable(struct adxl34x *ac)\r\n{\r\nAC_WRITE(ac, POWER_CTL, 0);\r\n}\r\nstatic void __adxl34x_enable(struct adxl34x *ac)\r\n{\r\nAC_WRITE(ac, POWER_CTL, ac->pdata.power_mode | PCTL_MEASURE);\r\n}\r\nvoid adxl34x_suspend(struct adxl34x *ac)\r\n{\r\nmutex_lock(&ac->mutex);\r\nif (!ac->suspended && !ac->disabled && ac->opened)\r\n__adxl34x_disable(ac);\r\nac->suspended = true;\r\nmutex_unlock(&ac->mutex);\r\n}\r\nvoid adxl34x_resume(struct adxl34x *ac)\r\n{\r\nmutex_lock(&ac->mutex);\r\nif (ac->suspended && !ac->disabled && ac->opened)\r\n__adxl34x_enable(ac);\r\nac->suspended = false;\r\nmutex_unlock(&ac->mutex);\r\n}\r\nstatic ssize_t adxl34x_disable_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct adxl34x *ac = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", ac->disabled);\r\n}\r\nstatic ssize_t adxl34x_disable_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adxl34x *ac = dev_get_drvdata(dev);\r\nunsigned int val;\r\nint error;\r\nerror = kstrtouint(buf, 10, &val);\r\nif (error)\r\nreturn error;\r\nmutex_lock(&ac->mutex);\r\nif (!ac->suspended && ac->opened) {\r\nif (val) {\r\nif (!ac->disabled)\r\n__adxl34x_disable(ac);\r\n} else {\r\nif (ac->disabled)\r\n__adxl34x_enable(ac);\r\n}\r\n}\r\nac->disabled = !!val;\r\nmutex_unlock(&ac->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t adxl34x_calibrate_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct adxl34x *ac = dev_get_drvdata(dev);\r\nssize_t count;\r\nmutex_lock(&ac->mutex);\r\ncount = sprintf(buf, "%d,%d,%d\n",\r\nac->hwcal.x * 4 + ac->swcal.x,\r\nac->hwcal.y * 4 + ac->swcal.y,\r\nac->hwcal.z * 4 + ac->swcal.z);\r\nmutex_unlock(&ac->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t adxl34x_calibrate_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adxl34x *ac = dev_get_drvdata(dev);\r\nmutex_lock(&ac->mutex);\r\nac->hwcal.x -= (ac->saved.x / 4);\r\nac->swcal.x = ac->saved.x % 4;\r\nac->hwcal.y -= (ac->saved.y / 4);\r\nac->swcal.y = ac->saved.y % 4;\r\nac->hwcal.z -= (ac->saved.z / 4);\r\nac->swcal.z = ac->saved.z % 4;\r\nAC_WRITE(ac, OFSX, (s8) ac->hwcal.x);\r\nAC_WRITE(ac, OFSY, (s8) ac->hwcal.y);\r\nAC_WRITE(ac, OFSZ, (s8) ac->hwcal.z);\r\nmutex_unlock(&ac->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t adxl34x_rate_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct adxl34x *ac = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", RATE(ac->pdata.data_rate));\r\n}\r\nstatic ssize_t adxl34x_rate_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adxl34x *ac = dev_get_drvdata(dev);\r\nunsigned char val;\r\nint error;\r\nerror = kstrtou8(buf, 10, &val);\r\nif (error)\r\nreturn error;\r\nmutex_lock(&ac->mutex);\r\nac->pdata.data_rate = RATE(val);\r\nAC_WRITE(ac, BW_RATE,\r\nac->pdata.data_rate |\r\n(ac->pdata.low_power_mode ? LOW_POWER : 0));\r\nmutex_unlock(&ac->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t adxl34x_autosleep_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct adxl34x *ac = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n",\r\nac->pdata.power_mode & (PCTL_AUTO_SLEEP | PCTL_LINK) ? 1 : 0);\r\n}\r\nstatic ssize_t adxl34x_autosleep_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adxl34x *ac = dev_get_drvdata(dev);\r\nunsigned int val;\r\nint error;\r\nerror = kstrtouint(buf, 10, &val);\r\nif (error)\r\nreturn error;\r\nmutex_lock(&ac->mutex);\r\nif (val)\r\nac->pdata.power_mode |= (PCTL_AUTO_SLEEP | PCTL_LINK);\r\nelse\r\nac->pdata.power_mode &= ~(PCTL_AUTO_SLEEP | PCTL_LINK);\r\nif (!ac->disabled && !ac->suspended && ac->opened)\r\nAC_WRITE(ac, POWER_CTL, ac->pdata.power_mode | PCTL_MEASURE);\r\nmutex_unlock(&ac->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t adxl34x_position_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct adxl34x *ac = dev_get_drvdata(dev);\r\nssize_t count;\r\nmutex_lock(&ac->mutex);\r\ncount = sprintf(buf, "(%d, %d, %d)\n",\r\nac->saved.x, ac->saved.y, ac->saved.z);\r\nmutex_unlock(&ac->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t adxl34x_write_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adxl34x *ac = dev_get_drvdata(dev);\r\nunsigned int val;\r\nint error;\r\nerror = kstrtouint(buf, 16, &val);\r\nif (error)\r\nreturn error;\r\nmutex_lock(&ac->mutex);\r\nAC_WRITE(ac, val >> 8, val & 0xFF);\r\nmutex_unlock(&ac->mutex);\r\nreturn count;\r\n}\r\nstatic int adxl34x_input_open(struct input_dev *input)\r\n{\r\nstruct adxl34x *ac = input_get_drvdata(input);\r\nmutex_lock(&ac->mutex);\r\nif (!ac->suspended && !ac->disabled)\r\n__adxl34x_enable(ac);\r\nac->opened = true;\r\nmutex_unlock(&ac->mutex);\r\nreturn 0;\r\n}\r\nstatic void adxl34x_input_close(struct input_dev *input)\r\n{\r\nstruct adxl34x *ac = input_get_drvdata(input);\r\nmutex_lock(&ac->mutex);\r\nif (!ac->suspended && !ac->disabled)\r\n__adxl34x_disable(ac);\r\nac->opened = false;\r\nmutex_unlock(&ac->mutex);\r\n}\r\nstruct adxl34x *adxl34x_probe(struct device *dev, int irq,\r\nbool fifo_delay_default,\r\nconst struct adxl34x_bus_ops *bops)\r\n{\r\nstruct adxl34x *ac;\r\nstruct input_dev *input_dev;\r\nconst struct adxl34x_platform_data *pdata;\r\nint err, range, i;\r\nunsigned char revid;\r\nif (!irq) {\r\ndev_err(dev, "no IRQ?\n");\r\nerr = -ENODEV;\r\ngoto err_out;\r\n}\r\nac = kzalloc(sizeof(*ac), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!ac || !input_dev) {\r\nerr = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nac->fifo_delay = fifo_delay_default;\r\npdata = dev->platform_data;\r\nif (!pdata) {\r\ndev_dbg(dev,\r\n"No platform data: Using default initialization\n");\r\npdata = &adxl34x_default_init;\r\n}\r\nac->pdata = *pdata;\r\npdata = &ac->pdata;\r\nac->input = input_dev;\r\nac->dev = dev;\r\nac->irq = irq;\r\nac->bops = bops;\r\nmutex_init(&ac->mutex);\r\ninput_dev->name = "ADXL34x accelerometer";\r\nrevid = ac->bops->read(dev, DEVID);\r\nswitch (revid) {\r\ncase ID_ADXL345:\r\nac->model = 345;\r\nbreak;\r\ncase ID_ADXL346:\r\nac->model = 346;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Failed to probe %s\n", input_dev->name);\r\nerr = -ENODEV;\r\ngoto err_free_mem;\r\n}\r\nsnprintf(ac->phys, sizeof(ac->phys), "%s/input0", dev_name(dev));\r\ninput_dev->phys = ac->phys;\r\ninput_dev->dev.parent = dev;\r\ninput_dev->id.product = ac->model;\r\ninput_dev->id.bustype = bops->bustype;\r\ninput_dev->open = adxl34x_input_open;\r\ninput_dev->close = adxl34x_input_close;\r\ninput_set_drvdata(input_dev, ac);\r\n__set_bit(ac->pdata.ev_type, input_dev->evbit);\r\nif (ac->pdata.ev_type == EV_REL) {\r\n__set_bit(REL_X, input_dev->relbit);\r\n__set_bit(REL_Y, input_dev->relbit);\r\n__set_bit(REL_Z, input_dev->relbit);\r\n} else {\r\n__set_bit(ABS_X, input_dev->absbit);\r\n__set_bit(ABS_Y, input_dev->absbit);\r\n__set_bit(ABS_Z, input_dev->absbit);\r\nif (pdata->data_range & FULL_RES)\r\nrange = ADXL_FULLRES_MAX_VAL;\r\nelse\r\nrange = ADXL_FIXEDRES_MAX_VAL;\r\ninput_set_abs_params(input_dev, ABS_X, -range, range, 3, 3);\r\ninput_set_abs_params(input_dev, ABS_Y, -range, range, 3, 3);\r\ninput_set_abs_params(input_dev, ABS_Z, -range, range, 3, 3);\r\n}\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(pdata->ev_code_tap[ADXL_X_AXIS], input_dev->keybit);\r\n__set_bit(pdata->ev_code_tap[ADXL_Y_AXIS], input_dev->keybit);\r\n__set_bit(pdata->ev_code_tap[ADXL_Z_AXIS], input_dev->keybit);\r\nif (pdata->ev_code_ff) {\r\nac->int_mask = FREE_FALL;\r\n__set_bit(pdata->ev_code_ff, input_dev->keybit);\r\n}\r\nif (pdata->ev_code_act_inactivity)\r\n__set_bit(pdata->ev_code_act_inactivity, input_dev->keybit);\r\nac->int_mask |= ACTIVITY | INACTIVITY;\r\nif (pdata->watermark) {\r\nac->int_mask |= WATERMARK;\r\nif (!FIFO_MODE(pdata->fifo_mode))\r\nac->pdata.fifo_mode |= FIFO_STREAM;\r\n} else {\r\nac->int_mask |= DATA_READY;\r\n}\r\nif (pdata->tap_axis_control & (TAP_X_EN | TAP_Y_EN | TAP_Z_EN))\r\nac->int_mask |= SINGLE_TAP | DOUBLE_TAP;\r\nif (FIFO_MODE(pdata->fifo_mode) == FIFO_BYPASS)\r\nac->fifo_delay = false;\r\nac->bops->write(dev, POWER_CTL, 0);\r\nerr = request_threaded_irq(ac->irq, NULL, adxl34x_irq,\r\nIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\r\ndev_name(dev), ac);\r\nif (err) {\r\ndev_err(dev, "irq %d busy?\n", ac->irq);\r\ngoto err_free_mem;\r\n}\r\nerr = sysfs_create_group(&dev->kobj, &adxl34x_attr_group);\r\nif (err)\r\ngoto err_free_irq;\r\nerr = input_register_device(input_dev);\r\nif (err)\r\ngoto err_remove_attr;\r\nAC_WRITE(ac, THRESH_TAP, pdata->tap_threshold);\r\nAC_WRITE(ac, OFSX, pdata->x_axis_offset);\r\nac->hwcal.x = pdata->x_axis_offset;\r\nAC_WRITE(ac, OFSY, pdata->y_axis_offset);\r\nac->hwcal.y = pdata->y_axis_offset;\r\nAC_WRITE(ac, OFSZ, pdata->z_axis_offset);\r\nac->hwcal.z = pdata->z_axis_offset;\r\nAC_WRITE(ac, THRESH_TAP, pdata->tap_threshold);\r\nAC_WRITE(ac, DUR, pdata->tap_duration);\r\nAC_WRITE(ac, LATENT, pdata->tap_latency);\r\nAC_WRITE(ac, WINDOW, pdata->tap_window);\r\nAC_WRITE(ac, THRESH_ACT, pdata->activity_threshold);\r\nAC_WRITE(ac, THRESH_INACT, pdata->inactivity_threshold);\r\nAC_WRITE(ac, TIME_INACT, pdata->inactivity_time);\r\nAC_WRITE(ac, THRESH_FF, pdata->free_fall_threshold);\r\nAC_WRITE(ac, TIME_FF, pdata->free_fall_time);\r\nAC_WRITE(ac, TAP_AXES, pdata->tap_axis_control);\r\nAC_WRITE(ac, ACT_INACT_CTL, pdata->act_axis_control);\r\nAC_WRITE(ac, BW_RATE, RATE(ac->pdata.data_rate) |\r\n(pdata->low_power_mode ? LOW_POWER : 0));\r\nAC_WRITE(ac, DATA_FORMAT, pdata->data_range);\r\nAC_WRITE(ac, FIFO_CTL, FIFO_MODE(pdata->fifo_mode) |\r\nSAMPLES(pdata->watermark));\r\nif (pdata->use_int2) {\r\nAC_WRITE(ac, INT_MAP, ac->int_mask | OVERRUN);\r\n} else {\r\nAC_WRITE(ac, INT_MAP, 0);\r\n}\r\nif (ac->model == 346 && ac->pdata.orientation_enable) {\r\nAC_WRITE(ac, ORIENT_CONF,\r\nORIENT_DEADZONE(ac->pdata.deadzone_angle) |\r\nORIENT_DIVISOR(ac->pdata.divisor_length));\r\nac->orient2d_saved = 1234;\r\nac->orient3d_saved = 1234;\r\nif (pdata->orientation_enable & ADXL_EN_ORIENTATION_3D)\r\nfor (i = 0; i < ARRAY_SIZE(pdata->ev_codes_orient_3d); i++)\r\n__set_bit(pdata->ev_codes_orient_3d[i],\r\ninput_dev->keybit);\r\nif (pdata->orientation_enable & ADXL_EN_ORIENTATION_2D)\r\nfor (i = 0; i < ARRAY_SIZE(pdata->ev_codes_orient_2d); i++)\r\n__set_bit(pdata->ev_codes_orient_2d[i],\r\ninput_dev->keybit);\r\n} else {\r\nac->pdata.orientation_enable = 0;\r\n}\r\nAC_WRITE(ac, INT_ENABLE, ac->int_mask | OVERRUN);\r\nac->pdata.power_mode &= (PCTL_AUTO_SLEEP | PCTL_LINK);\r\nreturn ac;\r\nerr_remove_attr:\r\nsysfs_remove_group(&dev->kobj, &adxl34x_attr_group);\r\nerr_free_irq:\r\nfree_irq(ac->irq, ac);\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(ac);\r\nerr_out:\r\nreturn ERR_PTR(err);\r\n}\r\nint adxl34x_remove(struct adxl34x *ac)\r\n{\r\nsysfs_remove_group(&ac->dev->kobj, &adxl34x_attr_group);\r\nfree_irq(ac->irq, ac);\r\ninput_unregister_device(ac->input);\r\ndev_dbg(ac->dev, "unregistered accelerometer\n");\r\nkfree(ac);\r\nreturn 0;\r\n}
