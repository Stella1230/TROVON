static inline bool is_leap(unsigned int y)\r\n{\r\nreturn y % 4 == 0 && (y % 100 != 0 || y % 400 == 0);\r\n}\r\nstatic inline unsigned int localtime_1(struct xtm *r, time_t time)\r\n{\r\nunsigned int v, w;\r\nv = time % 86400;\r\nr->second = v % 60;\r\nw = v / 60;\r\nr->minute = w % 60;\r\nr->hour = w / 60;\r\nreturn v;\r\n}\r\nstatic inline void localtime_2(struct xtm *r, time_t time)\r\n{\r\nr->dse = time / 86400;\r\nr->weekday = (4 + r->dse - 1) % 7 + 1;\r\n}\r\nstatic void localtime_3(struct xtm *r, time_t time)\r\n{\r\nunsigned int year, i, w = r->dse;\r\nfor (i = 0, year = DSE_FIRST; days_since_epoch[i] > w;\r\n++i, --year)\r\n;\r\nw -= days_since_epoch[i];\r\nif (is_leap(year)) {\r\nfor (i = ARRAY_SIZE(days_since_leapyear) - 1;\r\ni > 0 && days_since_leapyear[i] > w; --i)\r\n;\r\nr->monthday = w - days_since_leapyear[i] + 1;\r\n} else {\r\nfor (i = ARRAY_SIZE(days_since_year) - 1;\r\ni > 0 && days_since_year[i] > w; --i)\r\n;\r\nr->monthday = w - days_since_year[i] + 1;\r\n}\r\nr->month = i + 1;\r\n}\r\nstatic bool\r\ntime_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_time_info *info = par->matchinfo;\r\nunsigned int packet_time;\r\nstruct xtm current_time;\r\ns64 stamp;\r\nif (skb->tstamp.tv64 == 0)\r\n__net_timestamp((struct sk_buff *)skb);\r\nstamp = ktime_to_ns(skb->tstamp);\r\nstamp = div_s64(stamp, NSEC_PER_SEC);\r\nif (info->flags & XT_TIME_LOCAL_TZ)\r\nstamp -= 60 * sys_tz.tz_minuteswest;\r\nif (stamp < info->date_start || stamp > info->date_stop)\r\nreturn false;\r\npacket_time = localtime_1(&current_time, stamp);\r\nif (info->daytime_start < info->daytime_stop) {\r\nif (packet_time < info->daytime_start ||\r\npacket_time > info->daytime_stop)\r\nreturn false;\r\n} else {\r\nif (packet_time < info->daytime_start &&\r\npacket_time > info->daytime_stop)\r\nreturn false;\r\n}\r\nlocaltime_2(&current_time, stamp);\r\nif (!(info->weekdays_match & (1 << current_time.weekday)))\r\nreturn false;\r\nif (info->monthdays_match != XT_TIME_ALL_MONTHDAYS) {\r\nlocaltime_3(&current_time, stamp);\r\nif (!(info->monthdays_match & (1 << current_time.monthday)))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int time_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_time_info *info = par->matchinfo;\r\nif (info->daytime_start > XT_TIME_MAX_DAYTIME ||\r\ninfo->daytime_stop > XT_TIME_MAX_DAYTIME) {\r\npr_info("invalid argument - start or "\r\n"stop time greater than 23:59:59\n");\r\nreturn -EDOM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init time_mt_init(void)\r\n{\r\nint minutes = sys_tz.tz_minuteswest;\r\nif (minutes < 0)\r\nprintk(KERN_INFO KBUILD_MODNAME\r\n": kernel timezone is +%02d%02d\n",\r\n-minutes / 60, -minutes % 60);\r\nelse\r\nprintk(KERN_INFO KBUILD_MODNAME\r\n": kernel timezone is -%02d%02d\n",\r\nminutes / 60, minutes % 60);\r\nreturn xt_register_match(&xt_time_mt_reg);\r\n}\r\nstatic void __exit time_mt_exit(void)\r\n{\r\nxt_unregister_match(&xt_time_mt_reg);\r\n}
