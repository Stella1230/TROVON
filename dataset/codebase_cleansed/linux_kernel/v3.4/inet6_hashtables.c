int __inet6_hash(struct sock *sk, struct inet_timewait_sock *tw)\r\n{\r\nstruct inet_hashinfo *hashinfo = sk->sk_prot->h.hashinfo;\r\nint twrefcnt = 0;\r\nWARN_ON(!sk_unhashed(sk));\r\nif (sk->sk_state == TCP_LISTEN) {\r\nstruct inet_listen_hashbucket *ilb;\r\nilb = &hashinfo->listening_hash[inet_sk_listen_hashfn(sk)];\r\nspin_lock(&ilb->lock);\r\n__sk_nulls_add_node_rcu(sk, &ilb->head);\r\nspin_unlock(&ilb->lock);\r\n} else {\r\nunsigned int hash;\r\nstruct hlist_nulls_head *list;\r\nspinlock_t *lock;\r\nsk->sk_hash = hash = inet6_sk_ehashfn(sk);\r\nlist = &inet_ehash_bucket(hashinfo, hash)->chain;\r\nlock = inet_ehash_lockp(hashinfo, hash);\r\nspin_lock(lock);\r\n__sk_nulls_add_node_rcu(sk, list);\r\nif (tw) {\r\nWARN_ON(sk->sk_hash != tw->tw_hash);\r\ntwrefcnt = inet_twsk_unhash(tw);\r\n}\r\nspin_unlock(lock);\r\n}\r\nsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\r\nreturn twrefcnt;\r\n}\r\nstruct sock *__inet6_lookup_established(struct net *net,\r\nstruct inet_hashinfo *hashinfo,\r\nconst struct in6_addr *saddr,\r\nconst __be16 sport,\r\nconst struct in6_addr *daddr,\r\nconst u16 hnum,\r\nconst int dif)\r\n{\r\nstruct sock *sk;\r\nconst struct hlist_nulls_node *node;\r\nconst __portpair ports = INET_COMBINED_PORTS(sport, hnum);\r\nunsigned int hash = inet6_ehashfn(net, daddr, hnum, saddr, sport);\r\nunsigned int slot = hash & hashinfo->ehash_mask;\r\nstruct inet_ehash_bucket *head = &hashinfo->ehash[slot];\r\nrcu_read_lock();\r\nbegin:\r\nsk_nulls_for_each_rcu(sk, node, &head->chain) {\r\nif (INET6_MATCH(sk, net, hash, saddr, daddr, ports, dif)) {\r\nif (unlikely(!atomic_inc_not_zero(&sk->sk_refcnt)))\r\ngoto begintw;\r\nif (!INET6_MATCH(sk, net, hash, saddr, daddr, ports, dif)) {\r\nsock_put(sk);\r\ngoto begin;\r\n}\r\ngoto out;\r\n}\r\n}\r\nif (get_nulls_value(node) != slot)\r\ngoto begin;\r\nbegintw:\r\nsk_nulls_for_each_rcu(sk, node, &head->twchain) {\r\nif (INET6_TW_MATCH(sk, net, hash, saddr, daddr, ports, dif)) {\r\nif (unlikely(!atomic_inc_not_zero(&sk->sk_refcnt))) {\r\nsk = NULL;\r\ngoto out;\r\n}\r\nif (!INET6_TW_MATCH(sk, net, hash, saddr, daddr, ports, dif)) {\r\nsock_put(sk);\r\ngoto begintw;\r\n}\r\ngoto out;\r\n}\r\n}\r\nif (get_nulls_value(node) != slot)\r\ngoto begintw;\r\nsk = NULL;\r\nout:\r\nrcu_read_unlock();\r\nreturn sk;\r\n}\r\nstatic inline int compute_score(struct sock *sk, struct net *net,\r\nconst unsigned short hnum,\r\nconst struct in6_addr *daddr,\r\nconst int dif)\r\n{\r\nint score = -1;\r\nif (net_eq(sock_net(sk), net) && inet_sk(sk)->inet_num == hnum &&\r\nsk->sk_family == PF_INET6) {\r\nconst struct ipv6_pinfo *np = inet6_sk(sk);\r\nscore = 1;\r\nif (!ipv6_addr_any(&np->rcv_saddr)) {\r\nif (!ipv6_addr_equal(&np->rcv_saddr, daddr))\r\nreturn -1;\r\nscore++;\r\n}\r\nif (sk->sk_bound_dev_if) {\r\nif (sk->sk_bound_dev_if != dif)\r\nreturn -1;\r\nscore++;\r\n}\r\n}\r\nreturn score;\r\n}\r\nstruct sock *inet6_lookup_listener(struct net *net,\r\nstruct inet_hashinfo *hashinfo, const struct in6_addr *daddr,\r\nconst unsigned short hnum, const int dif)\r\n{\r\nstruct sock *sk;\r\nconst struct hlist_nulls_node *node;\r\nstruct sock *result;\r\nint score, hiscore;\r\nunsigned int hash = inet_lhashfn(net, hnum);\r\nstruct inet_listen_hashbucket *ilb = &hashinfo->listening_hash[hash];\r\nrcu_read_lock();\r\nbegin:\r\nresult = NULL;\r\nhiscore = -1;\r\nsk_nulls_for_each(sk, node, &ilb->head) {\r\nscore = compute_score(sk, net, hnum, daddr, dif);\r\nif (score > hiscore) {\r\nhiscore = score;\r\nresult = sk;\r\n}\r\n}\r\nif (get_nulls_value(node) != hash + LISTENING_NULLS_BASE)\r\ngoto begin;\r\nif (result) {\r\nif (unlikely(!atomic_inc_not_zero(&result->sk_refcnt)))\r\nresult = NULL;\r\nelse if (unlikely(compute_score(result, net, hnum, daddr,\r\ndif) < hiscore)) {\r\nsock_put(result);\r\ngoto begin;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn result;\r\n}\r\nstruct sock *inet6_lookup(struct net *net, struct inet_hashinfo *hashinfo,\r\nconst struct in6_addr *saddr, const __be16 sport,\r\nconst struct in6_addr *daddr, const __be16 dport,\r\nconst int dif)\r\n{\r\nstruct sock *sk;\r\nlocal_bh_disable();\r\nsk = __inet6_lookup(net, hashinfo, saddr, sport, daddr, ntohs(dport), dif);\r\nlocal_bh_enable();\r\nreturn sk;\r\n}\r\nstatic int __inet6_check_established(struct inet_timewait_death_row *death_row,\r\nstruct sock *sk, const __u16 lport,\r\nstruct inet_timewait_sock **twp)\r\n{\r\nstruct inet_hashinfo *hinfo = death_row->hashinfo;\r\nstruct inet_sock *inet = inet_sk(sk);\r\nconst struct ipv6_pinfo *np = inet6_sk(sk);\r\nconst struct in6_addr *daddr = &np->rcv_saddr;\r\nconst struct in6_addr *saddr = &np->daddr;\r\nconst int dif = sk->sk_bound_dev_if;\r\nconst __portpair ports = INET_COMBINED_PORTS(inet->inet_dport, lport);\r\nstruct net *net = sock_net(sk);\r\nconst unsigned int hash = inet6_ehashfn(net, daddr, lport, saddr,\r\ninet->inet_dport);\r\nstruct inet_ehash_bucket *head = inet_ehash_bucket(hinfo, hash);\r\nspinlock_t *lock = inet_ehash_lockp(hinfo, hash);\r\nstruct sock *sk2;\r\nconst struct hlist_nulls_node *node;\r\nstruct inet_timewait_sock *tw;\r\nint twrefcnt = 0;\r\nspin_lock(lock);\r\nsk_nulls_for_each(sk2, node, &head->twchain) {\r\ntw = inet_twsk(sk2);\r\nif (INET6_TW_MATCH(sk2, net, hash, saddr, daddr, ports, dif)) {\r\nif (twsk_unique(sk, sk2, twp))\r\ngoto unique;\r\nelse\r\ngoto not_unique;\r\n}\r\n}\r\ntw = NULL;\r\nsk_nulls_for_each(sk2, node, &head->chain) {\r\nif (INET6_MATCH(sk2, net, hash, saddr, daddr, ports, dif))\r\ngoto not_unique;\r\n}\r\nunique:\r\ninet->inet_num = lport;\r\ninet->inet_sport = htons(lport);\r\nsk->sk_hash = hash;\r\nWARN_ON(!sk_unhashed(sk));\r\n__sk_nulls_add_node_rcu(sk, &head->chain);\r\nif (tw) {\r\ntwrefcnt = inet_twsk_unhash(tw);\r\nNET_INC_STATS_BH(net, LINUX_MIB_TIMEWAITRECYCLED);\r\n}\r\nspin_unlock(lock);\r\nif (twrefcnt)\r\ninet_twsk_put(tw);\r\nsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\r\nif (twp) {\r\n*twp = tw;\r\n} else if (tw) {\r\ninet_twsk_deschedule(tw, death_row);\r\ninet_twsk_put(tw);\r\n}\r\nreturn 0;\r\nnot_unique:\r\nspin_unlock(lock);\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nstatic inline u32 inet6_sk_port_offset(const struct sock *sk)\r\n{\r\nconst struct inet_sock *inet = inet_sk(sk);\r\nconst struct ipv6_pinfo *np = inet6_sk(sk);\r\nreturn secure_ipv6_port_ephemeral(np->rcv_saddr.s6_addr32,\r\nnp->daddr.s6_addr32,\r\ninet->inet_dport);\r\n}\r\nint inet6_hash_connect(struct inet_timewait_death_row *death_row,\r\nstruct sock *sk)\r\n{\r\nreturn __inet_hash_connect(death_row, sk, inet6_sk_port_offset(sk),\r\n__inet6_check_established, __inet6_hash);\r\n}
