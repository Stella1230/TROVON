static inline unsigned IOConfigReg(unsigned pfi_channel)\r\n{\r\nunsigned reg = IOConfigReg0_1 + pfi_channel / 2;\r\nBUG_ON(reg > IOConfigReg38_39);\r\nreturn reg;\r\n}\r\nstatic inline unsigned NI_660X_GPCT_SUBDEV(unsigned index)\r\n{\r\nreturn NI_660X_GPCT_SUBDEV_0 + index;\r\n}\r\nstatic inline unsigned ioconfig_bitshift(unsigned pfi_channel)\r\n{\r\nif (pfi_channel % 2)\r\nreturn 0;\r\nelse\r\nreturn 8;\r\n}\r\nstatic inline unsigned pfi_output_select_mask(unsigned pfi_channel)\r\n{\r\nreturn 0x3 << ioconfig_bitshift(pfi_channel);\r\n}\r\nstatic inline unsigned pfi_output_select_bits(unsigned pfi_channel,\r\nunsigned output_select)\r\n{\r\nreturn (output_select & 0x3) << ioconfig_bitshift(pfi_channel);\r\n}\r\nstatic inline unsigned pfi_input_select_mask(unsigned pfi_channel)\r\n{\r\nreturn 0x7 << (4 + ioconfig_bitshift(pfi_channel));\r\n}\r\nstatic inline unsigned pfi_input_select_bits(unsigned pfi_channel,\r\nunsigned input_select)\r\n{\r\nreturn (input_select & 0x7) << (4 + ioconfig_bitshift(pfi_channel));\r\n}\r\nstatic inline unsigned dma_select_mask(unsigned dma_channel)\r\n{\r\nBUG_ON(dma_channel >= MAX_DMA_CHANNEL);\r\nreturn 0x1f << (8 * dma_channel);\r\n}\r\nstatic inline unsigned dma_selection_counter(unsigned counter_index)\r\n{\r\nBUG_ON(counter_index >= counters_per_chip);\r\nreturn counter_index;\r\n}\r\nstatic inline unsigned dma_select_bits(unsigned dma_channel, unsigned selection)\r\n{\r\nBUG_ON(dma_channel >= MAX_DMA_CHANNEL);\r\nreturn (selection << (8 * dma_channel)) & dma_select_mask(dma_channel);\r\n}\r\nstatic inline unsigned dma_reset_bit(unsigned dma_channel)\r\n{\r\nBUG_ON(dma_channel >= MAX_DMA_CHANNEL);\r\nreturn 0x80 << (8 * dma_channel);\r\n}\r\nstatic inline struct ni_660x_private *private(struct comedi_device *dev)\r\n{\r\nreturn dev->private;\r\n}\r\nstatic inline const struct ni_660x_board *board(struct comedi_device *dev)\r\n{\r\nreturn dev->board_ptr;\r\n}\r\nstatic int __devinit driver_ni_660x_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nreturn comedi_pci_auto_config(dev, driver_ni_660x.driver_name);\r\n}\r\nstatic void __devexit driver_ni_660x_pci_remove(struct pci_dev *dev)\r\n{\r\ncomedi_pci_auto_unconfig(dev);\r\n}\r\nstatic int __init driver_ni_660x_init_module(void)\r\n{\r\nint retval;\r\nretval = comedi_driver_register(&driver_ni_660x);\r\nif (retval < 0)\r\nreturn retval;\r\ndriver_ni_660x_pci_driver.name = (char *)driver_ni_660x.driver_name;\r\nreturn pci_register_driver(&driver_ni_660x_pci_driver);\r\n}\r\nstatic void __exit driver_ni_660x_cleanup_module(void)\r\n{\r\npci_unregister_driver(&driver_ni_660x_pci_driver);\r\ncomedi_driver_unregister(&driver_ni_660x);\r\n}\r\nstatic inline unsigned ni_660x_num_counters(struct comedi_device *dev)\r\n{\r\nreturn board(dev)->n_chips * counters_per_chip;\r\n}\r\nstatic enum NI_660x_Register ni_gpct_to_660x_register(enum ni_gpct_register reg)\r\n{\r\nenum NI_660x_Register ni_660x_register;\r\nswitch (reg) {\r\ncase NITIO_G0_Autoincrement_Reg:\r\nni_660x_register = G0AutoincrementRegister;\r\nbreak;\r\ncase NITIO_G1_Autoincrement_Reg:\r\nni_660x_register = G1AutoincrementRegister;\r\nbreak;\r\ncase NITIO_G2_Autoincrement_Reg:\r\nni_660x_register = G2AutoincrementRegister;\r\nbreak;\r\ncase NITIO_G3_Autoincrement_Reg:\r\nni_660x_register = G3AutoincrementRegister;\r\nbreak;\r\ncase NITIO_G0_Command_Reg:\r\nni_660x_register = G0CommandRegister;\r\nbreak;\r\ncase NITIO_G1_Command_Reg:\r\nni_660x_register = G1CommandRegister;\r\nbreak;\r\ncase NITIO_G2_Command_Reg:\r\nni_660x_register = G2CommandRegister;\r\nbreak;\r\ncase NITIO_G3_Command_Reg:\r\nni_660x_register = G3CommandRegister;\r\nbreak;\r\ncase NITIO_G0_HW_Save_Reg:\r\nni_660x_register = G0HWSaveRegister;\r\nbreak;\r\ncase NITIO_G1_HW_Save_Reg:\r\nni_660x_register = G1HWSaveRegister;\r\nbreak;\r\ncase NITIO_G2_HW_Save_Reg:\r\nni_660x_register = G2HWSaveRegister;\r\nbreak;\r\ncase NITIO_G3_HW_Save_Reg:\r\nni_660x_register = G3HWSaveRegister;\r\nbreak;\r\ncase NITIO_G0_SW_Save_Reg:\r\nni_660x_register = G0SWSaveRegister;\r\nbreak;\r\ncase NITIO_G1_SW_Save_Reg:\r\nni_660x_register = G1SWSaveRegister;\r\nbreak;\r\ncase NITIO_G2_SW_Save_Reg:\r\nni_660x_register = G2SWSaveRegister;\r\nbreak;\r\ncase NITIO_G3_SW_Save_Reg:\r\nni_660x_register = G3SWSaveRegister;\r\nbreak;\r\ncase NITIO_G0_Mode_Reg:\r\nni_660x_register = G0ModeRegister;\r\nbreak;\r\ncase NITIO_G1_Mode_Reg:\r\nni_660x_register = G1ModeRegister;\r\nbreak;\r\ncase NITIO_G2_Mode_Reg:\r\nni_660x_register = G2ModeRegister;\r\nbreak;\r\ncase NITIO_G3_Mode_Reg:\r\nni_660x_register = G3ModeRegister;\r\nbreak;\r\ncase NITIO_G0_LoadA_Reg:\r\nni_660x_register = G0LoadARegister;\r\nbreak;\r\ncase NITIO_G1_LoadA_Reg:\r\nni_660x_register = G1LoadARegister;\r\nbreak;\r\ncase NITIO_G2_LoadA_Reg:\r\nni_660x_register = G2LoadARegister;\r\nbreak;\r\ncase NITIO_G3_LoadA_Reg:\r\nni_660x_register = G3LoadARegister;\r\nbreak;\r\ncase NITIO_G0_LoadB_Reg:\r\nni_660x_register = G0LoadBRegister;\r\nbreak;\r\ncase NITIO_G1_LoadB_Reg:\r\nni_660x_register = G1LoadBRegister;\r\nbreak;\r\ncase NITIO_G2_LoadB_Reg:\r\nni_660x_register = G2LoadBRegister;\r\nbreak;\r\ncase NITIO_G3_LoadB_Reg:\r\nni_660x_register = G3LoadBRegister;\r\nbreak;\r\ncase NITIO_G0_Input_Select_Reg:\r\nni_660x_register = G0InputSelectRegister;\r\nbreak;\r\ncase NITIO_G1_Input_Select_Reg:\r\nni_660x_register = G1InputSelectRegister;\r\nbreak;\r\ncase NITIO_G2_Input_Select_Reg:\r\nni_660x_register = G2InputSelectRegister;\r\nbreak;\r\ncase NITIO_G3_Input_Select_Reg:\r\nni_660x_register = G3InputSelectRegister;\r\nbreak;\r\ncase NITIO_G01_Status_Reg:\r\nni_660x_register = G01StatusRegister;\r\nbreak;\r\ncase NITIO_G23_Status_Reg:\r\nni_660x_register = G23StatusRegister;\r\nbreak;\r\ncase NITIO_G01_Joint_Reset_Reg:\r\nni_660x_register = G01JointResetRegister;\r\nbreak;\r\ncase NITIO_G23_Joint_Reset_Reg:\r\nni_660x_register = G23JointResetRegister;\r\nbreak;\r\ncase NITIO_G01_Joint_Status1_Reg:\r\nni_660x_register = G01JointStatus1Register;\r\nbreak;\r\ncase NITIO_G23_Joint_Status1_Reg:\r\nni_660x_register = G23JointStatus1Register;\r\nbreak;\r\ncase NITIO_G01_Joint_Status2_Reg:\r\nni_660x_register = G01JointStatus2Register;\r\nbreak;\r\ncase NITIO_G23_Joint_Status2_Reg:\r\nni_660x_register = G23JointStatus2Register;\r\nbreak;\r\ncase NITIO_G0_Counting_Mode_Reg:\r\nni_660x_register = G0CountingModeRegister;\r\nbreak;\r\ncase NITIO_G1_Counting_Mode_Reg:\r\nni_660x_register = G1CountingModeRegister;\r\nbreak;\r\ncase NITIO_G2_Counting_Mode_Reg:\r\nni_660x_register = G2CountingModeRegister;\r\nbreak;\r\ncase NITIO_G3_Counting_Mode_Reg:\r\nni_660x_register = G3CountingModeRegister;\r\nbreak;\r\ncase NITIO_G0_Second_Gate_Reg:\r\nni_660x_register = G0SecondGateRegister;\r\nbreak;\r\ncase NITIO_G1_Second_Gate_Reg:\r\nni_660x_register = G1SecondGateRegister;\r\nbreak;\r\ncase NITIO_G2_Second_Gate_Reg:\r\nni_660x_register = G2SecondGateRegister;\r\nbreak;\r\ncase NITIO_G3_Second_Gate_Reg:\r\nni_660x_register = G3SecondGateRegister;\r\nbreak;\r\ncase NITIO_G0_DMA_Config_Reg:\r\nni_660x_register = G0DMAConfigRegister;\r\nbreak;\r\ncase NITIO_G0_DMA_Status_Reg:\r\nni_660x_register = G0DMAStatusRegister;\r\nbreak;\r\ncase NITIO_G1_DMA_Config_Reg:\r\nni_660x_register = G1DMAConfigRegister;\r\nbreak;\r\ncase NITIO_G1_DMA_Status_Reg:\r\nni_660x_register = G1DMAStatusRegister;\r\nbreak;\r\ncase NITIO_G2_DMA_Config_Reg:\r\nni_660x_register = G2DMAConfigRegister;\r\nbreak;\r\ncase NITIO_G2_DMA_Status_Reg:\r\nni_660x_register = G2DMAStatusRegister;\r\nbreak;\r\ncase NITIO_G3_DMA_Config_Reg:\r\nni_660x_register = G3DMAConfigRegister;\r\nbreak;\r\ncase NITIO_G3_DMA_Status_Reg:\r\nni_660x_register = G3DMAStatusRegister;\r\nbreak;\r\ncase NITIO_G0_Interrupt_Acknowledge_Reg:\r\nni_660x_register = G0InterruptAcknowledge;\r\nbreak;\r\ncase NITIO_G1_Interrupt_Acknowledge_Reg:\r\nni_660x_register = G1InterruptAcknowledge;\r\nbreak;\r\ncase NITIO_G2_Interrupt_Acknowledge_Reg:\r\nni_660x_register = G2InterruptAcknowledge;\r\nbreak;\r\ncase NITIO_G3_Interrupt_Acknowledge_Reg:\r\nni_660x_register = G3InterruptAcknowledge;\r\nbreak;\r\ncase NITIO_G0_Status_Reg:\r\nni_660x_register = G0StatusRegister;\r\nbreak;\r\ncase NITIO_G1_Status_Reg:\r\nni_660x_register = G1StatusRegister;\r\nbreak;\r\ncase NITIO_G2_Status_Reg:\r\nni_660x_register = G2StatusRegister;\r\nbreak;\r\ncase NITIO_G3_Status_Reg:\r\nni_660x_register = G3StatusRegister;\r\nbreak;\r\ncase NITIO_G0_Interrupt_Enable_Reg:\r\nni_660x_register = G0InterruptEnable;\r\nbreak;\r\ncase NITIO_G1_Interrupt_Enable_Reg:\r\nni_660x_register = G1InterruptEnable;\r\nbreak;\r\ncase NITIO_G2_Interrupt_Enable_Reg:\r\nni_660x_register = G2InterruptEnable;\r\nbreak;\r\ncase NITIO_G3_Interrupt_Enable_Reg:\r\nni_660x_register = G3InterruptEnable;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: unhandled register 0x%x in switch.\n",\r\n__func__, reg);\r\nBUG();\r\nreturn 0;\r\nbreak;\r\n}\r\nreturn ni_660x_register;\r\n}\r\nstatic inline void ni_660x_write_register(struct comedi_device *dev,\r\nunsigned chip_index, unsigned bits,\r\nenum NI_660x_Register reg)\r\n{\r\nvoid *const write_address =\r\nprivate(dev)->mite->daq_io_addr + GPCT_OFFSET[chip_index] +\r\nregisterData[reg].offset;\r\nswitch (registerData[reg].size) {\r\ncase DATA_2B:\r\nwritew(bits, write_address);\r\nbreak;\r\ncase DATA_4B:\r\nwritel(bits, write_address);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: %s: bug! unhandled case (reg=0x%x) in switch.\n",\r\n__FILE__, __func__, reg);\r\nBUG();\r\nbreak;\r\n}\r\n}\r\nstatic inline unsigned ni_660x_read_register(struct comedi_device *dev,\r\nunsigned chip_index,\r\nenum NI_660x_Register reg)\r\n{\r\nvoid *const read_address =\r\nprivate(dev)->mite->daq_io_addr + GPCT_OFFSET[chip_index] +\r\nregisterData[reg].offset;\r\nswitch (registerData[reg].size) {\r\ncase DATA_2B:\r\nreturn readw(read_address);\r\nbreak;\r\ncase DATA_4B:\r\nreturn readl(read_address);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: %s: bug! unhandled case (reg=0x%x) in switch.\n",\r\n__FILE__, __func__, reg);\r\nBUG();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ni_gpct_write_register(struct ni_gpct *counter, unsigned bits,\r\nenum ni_gpct_register reg)\r\n{\r\nstruct comedi_device *dev = counter->counter_dev->dev;\r\nenum NI_660x_Register ni_660x_register = ni_gpct_to_660x_register(reg);\r\nni_660x_write_register(dev, counter->chip_index, bits,\r\nni_660x_register);\r\n}\r\nstatic unsigned ni_gpct_read_register(struct ni_gpct *counter,\r\nenum ni_gpct_register reg)\r\n{\r\nstruct comedi_device *dev = counter->counter_dev->dev;\r\nenum NI_660x_Register ni_660x_register = ni_gpct_to_660x_register(reg);\r\nreturn ni_660x_read_register(dev, counter->chip_index,\r\nni_660x_register);\r\n}\r\nstatic inline struct mite_dma_descriptor_ring *mite_ring(struct ni_660x_private\r\n*priv,\r\nstruct ni_gpct\r\n*counter)\r\n{\r\nreturn priv->mite_rings[counter->chip_index][counter->counter_index];\r\n}\r\nstatic inline void ni_660x_set_dma_channel(struct comedi_device *dev,\r\nunsigned mite_channel,\r\nstruct ni_gpct *counter)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&private(dev)->soft_reg_copy_lock, flags);\r\nprivate(dev)->dma_configuration_soft_copies[counter->chip_index] &=\r\n~dma_select_mask(mite_channel);\r\nprivate(dev)->dma_configuration_soft_copies[counter->chip_index] |=\r\ndma_select_bits(mite_channel,\r\ndma_selection_counter(counter->counter_index));\r\nni_660x_write_register(dev, counter->chip_index,\r\nprivate(dev)->\r\ndma_configuration_soft_copies\r\n[counter->chip_index] |\r\ndma_reset_bit(mite_channel), DMAConfigRegister);\r\nmmiowb();\r\nspin_unlock_irqrestore(&private(dev)->soft_reg_copy_lock, flags);\r\n}\r\nstatic inline void ni_660x_unset_dma_channel(struct comedi_device *dev,\r\nunsigned mite_channel,\r\nstruct ni_gpct *counter)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&private(dev)->soft_reg_copy_lock, flags);\r\nprivate(dev)->dma_configuration_soft_copies[counter->chip_index] &=\r\n~dma_select_mask(mite_channel);\r\nprivate(dev)->dma_configuration_soft_copies[counter->chip_index] |=\r\ndma_select_bits(mite_channel, dma_selection_none);\r\nni_660x_write_register(dev, counter->chip_index,\r\nprivate(dev)->\r\ndma_configuration_soft_copies\r\n[counter->chip_index], DMAConfigRegister);\r\nmmiowb();\r\nspin_unlock_irqrestore(&private(dev)->soft_reg_copy_lock, flags);\r\n}\r\nstatic int ni_660x_request_mite_channel(struct comedi_device *dev,\r\nstruct ni_gpct *counter,\r\nenum comedi_io_direction direction)\r\n{\r\nunsigned long flags;\r\nstruct mite_channel *mite_chan;\r\nspin_lock_irqsave(&private(dev)->mite_channel_lock, flags);\r\nBUG_ON(counter->mite_chan);\r\nmite_chan =\r\nmite_request_channel(private(dev)->mite, mite_ring(private(dev),\r\ncounter));\r\nif (mite_chan == NULL) {\r\nspin_unlock_irqrestore(&private(dev)->mite_channel_lock, flags);\r\ncomedi_error(dev,\r\n"failed to reserve mite dma channel for counter.");\r\nreturn -EBUSY;\r\n}\r\nmite_chan->dir = direction;\r\nni_tio_set_mite_channel(counter, mite_chan);\r\nni_660x_set_dma_channel(dev, mite_chan->channel, counter);\r\nspin_unlock_irqrestore(&private(dev)->mite_channel_lock, flags);\r\nreturn 0;\r\n}\r\nvoid ni_660x_release_mite_channel(struct comedi_device *dev,\r\nstruct ni_gpct *counter)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&private(dev)->mite_channel_lock, flags);\r\nif (counter->mite_chan) {\r\nstruct mite_channel *mite_chan = counter->mite_chan;\r\nni_660x_unset_dma_channel(dev, mite_chan->channel, counter);\r\nni_tio_set_mite_channel(counter, NULL);\r\nmite_release_channel(mite_chan);\r\n}\r\nspin_unlock_irqrestore(&private(dev)->mite_channel_lock, flags);\r\n}\r\nstatic int ni_660x_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nint retval;\r\nstruct ni_gpct *counter = subdev_to_counter(s);\r\nretval = ni_660x_request_mite_channel(dev, counter, COMEDI_INPUT);\r\nif (retval) {\r\ncomedi_error(dev,\r\n"no dma channel available for use by counter");\r\nreturn retval;\r\n}\r\nni_tio_acknowledge_and_confirm(counter, NULL, NULL, NULL, NULL);\r\nretval = ni_tio_cmd(counter, s->async);\r\nreturn retval;\r\n}\r\nstatic int ni_660x_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nstruct ni_gpct *counter = subdev_to_counter(s);\r\nreturn ni_tio_cmdtest(counter, cmd);\r\n}\r\nstatic int ni_660x_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct ni_gpct *counter = subdev_to_counter(s);\r\nint retval;\r\nretval = ni_tio_cancel(counter);\r\nni_660x_release_mite_channel(dev, counter);\r\nreturn retval;\r\n}\r\nstatic void set_tio_counterswap(struct comedi_device *dev, int chipset)\r\n{\r\nif (chipset)\r\nni_660x_write_register(dev, chipset, CounterSwap,\r\nClockConfigRegister);\r\nelse\r\nni_660x_write_register(dev, chipset, 0, ClockConfigRegister);\r\n}\r\nstatic void ni_660x_handle_gpct_interrupt(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nni_tio_handle_interrupt(subdev_to_counter(s), s);\r\nif (s->async->events) {\r\nif (s->async->events & (COMEDI_CB_EOA | COMEDI_CB_ERROR |\r\nCOMEDI_CB_OVERFLOW)) {\r\nni_660x_cancel(dev, s);\r\n}\r\ncomedi_event(dev, s);\r\n}\r\n}\r\nstatic irqreturn_t ni_660x_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s;\r\nunsigned i;\r\nunsigned long flags;\r\nif (dev->attached == 0)\r\nreturn IRQ_NONE;\r\nspin_lock_irqsave(&private(dev)->interrupt_lock, flags);\r\nsmp_mb();\r\nfor (i = 0; i < ni_660x_num_counters(dev); ++i) {\r\ns = dev->subdevices + NI_660X_GPCT_SUBDEV(i);\r\nni_660x_handle_gpct_interrupt(dev, s);\r\n}\r\nspin_unlock_irqrestore(&private(dev)->interrupt_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ni_660x_input_poll(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&private(dev)->interrupt_lock, flags);\r\nmite_sync_input_dma(subdev_to_counter(s)->mite_chan, s->async);\r\nspin_unlock_irqrestore(&private(dev)->interrupt_lock, flags);\r\nreturn comedi_buf_read_n_available(s->async);\r\n}\r\nstatic int ni_660x_buf_change(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned long new_size)\r\n{\r\nint ret;\r\nret = mite_buf_change(mite_ring(private(dev), subdev_to_counter(s)),\r\ns->async);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int ni_660x_allocate_private(struct comedi_device *dev)\r\n{\r\nint retval;\r\nunsigned i;\r\nretval = alloc_private(dev, sizeof(struct ni_660x_private));\r\nif (retval < 0)\r\nreturn retval;\r\nspin_lock_init(&private(dev)->mite_channel_lock);\r\nspin_lock_init(&private(dev)->interrupt_lock);\r\nspin_lock_init(&private(dev)->soft_reg_copy_lock);\r\nfor (i = 0; i < NUM_PFI_CHANNELS; ++i)\r\nprivate(dev)->pfi_output_selects[i] = pfi_output_select_counter;\r\nreturn 0;\r\n}\r\nstatic int ni_660x_alloc_mite_rings(struct comedi_device *dev)\r\n{\r\nunsigned i;\r\nunsigned j;\r\nfor (i = 0; i < board(dev)->n_chips; ++i) {\r\nfor (j = 0; j < counters_per_chip; ++j) {\r\nprivate(dev)->mite_rings[i][j] =\r\nmite_alloc_ring(private(dev)->mite);\r\nif (private(dev)->mite_rings[i][j] == NULL)\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ni_660x_free_mite_rings(struct comedi_device *dev)\r\n{\r\nunsigned i;\r\nunsigned j;\r\nfor (i = 0; i < board(dev)->n_chips; ++i) {\r\nfor (j = 0; j < counters_per_chip; ++j)\r\nmite_free_ring(private(dev)->mite_rings[i][j]);\r\n}\r\n}\r\nstatic int ni_660x_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nunsigned i;\r\nunsigned global_interrupt_config_bits;\r\nprintk(KERN_INFO "comedi%d: ni_660x: ", dev->minor);\r\nret = ni_660x_allocate_private(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ni_660x_find_device(dev, it->options[0], it->options[1]);\r\nif (ret < 0)\r\nreturn ret;\r\ndev->board_name = board(dev)->name;\r\nret = mite_setup2(private(dev)->mite, 1);\r\nif (ret < 0) {\r\nprintk(KERN_WARNING "error setting up mite\n");\r\nreturn ret;\r\n}\r\ncomedi_set_hw_dev(dev, &private(dev)->mite->pcidev->dev);\r\nret = ni_660x_alloc_mite_rings(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nprintk(KERN_INFO " %s ", dev->board_name);\r\ndev->n_subdevices = 2 + NI_660X_MAX_NUM_COUNTERS;\r\nif (alloc_subdevices(dev, dev->n_subdevices) < 0)\r\nreturn -ENOMEM;\r\ns = dev->subdevices + 0;\r\ns->type = COMEDI_SUBD_UNUSED;\r\ns = dev->subdevices + NI_660X_DIO_SUBDEV;\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = NUM_PFI_CHANNELS;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = ni_660x_dio_insn_bits;\r\ns->insn_config = ni_660x_dio_insn_config;\r\ns->io_bits = 0;\r\nni_660x_write_register(dev, 0, 0, STCDIOControl);\r\nprivate(dev)->counter_dev = ni_gpct_device_construct(dev,\r\n&ni_gpct_write_register,\r\n&ni_gpct_read_register,\r\nni_gpct_variant_660x,\r\nni_660x_num_counters\r\n(dev));\r\nif (private(dev)->counter_dev == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < NI_660X_MAX_NUM_COUNTERS; ++i) {\r\ns = dev->subdevices + NI_660X_GPCT_SUBDEV(i);\r\nif (i < ni_660x_num_counters(dev)) {\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags =\r\nSDF_READABLE | SDF_WRITABLE | SDF_LSAMPL |\r\nSDF_CMD_READ ;\r\ns->n_chan = 3;\r\ns->maxdata = 0xffffffff;\r\ns->insn_read = ni_660x_GPCT_rinsn;\r\ns->insn_write = ni_660x_GPCT_winsn;\r\ns->insn_config = ni_660x_GPCT_insn_config;\r\ns->do_cmd = &ni_660x_cmd;\r\ns->len_chanlist = 1;\r\ns->do_cmdtest = &ni_660x_cmdtest;\r\ns->cancel = &ni_660x_cancel;\r\ns->poll = &ni_660x_input_poll;\r\ns->async_dma_dir = DMA_BIDIRECTIONAL;\r\ns->buf_change = &ni_660x_buf_change;\r\ns->private = &private(dev)->counter_dev->counters[i];\r\nprivate(dev)->counter_dev->counters[i].chip_index =\r\ni / counters_per_chip;\r\nprivate(dev)->counter_dev->counters[i].counter_index =\r\ni % counters_per_chip;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\n}\r\nfor (i = 0; i < board(dev)->n_chips; ++i)\r\ninit_tio_chip(dev, i);\r\nfor (i = 0; i < ni_660x_num_counters(dev); ++i)\r\nni_tio_init_counter(&private(dev)->counter_dev->counters[i]);\r\nfor (i = 0; i < NUM_PFI_CHANNELS; ++i) {\r\nif (i < min_counter_pfi_chan)\r\nni_660x_set_pfi_routing(dev, i, pfi_output_select_do);\r\nelse\r\nni_660x_set_pfi_routing(dev, i,\r\npfi_output_select_counter);\r\nni_660x_select_pfi_output(dev, i, pfi_output_select_high_Z);\r\n}\r\nfor (i = 0; i < board(dev)->n_chips; ++i)\r\nset_tio_counterswap(dev, i);\r\nret = request_irq(mite_irq(private(dev)->mite), ni_660x_interrupt,\r\nIRQF_SHARED, "ni_660x", dev);\r\nif (ret < 0) {\r\nprintk(KERN_WARNING " irq not available\n");\r\nreturn ret;\r\n}\r\ndev->irq = mite_irq(private(dev)->mite);\r\nglobal_interrupt_config_bits = Global_Int_Enable_Bit;\r\nif (board(dev)->n_chips > 1)\r\nglobal_interrupt_config_bits |= Cascade_Int_Enable_Bit;\r\nni_660x_write_register(dev, 0, global_interrupt_config_bits,\r\nGlobalInterruptConfigRegister);\r\nprintk(KERN_INFO "attached\n");\r\nreturn 0;\r\n}\r\nstatic int ni_660x_detach(struct comedi_device *dev)\r\n{\r\nprintk(KERN_INFO "comedi%d: ni_660x: remove\n", dev->minor);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (dev->private) {\r\nif (private(dev)->counter_dev)\r\nni_gpct_device_destroy(private(dev)->counter_dev);\r\nif (private(dev)->mite) {\r\nni_660x_free_mite_rings(dev);\r\nmite_unsetup(private(dev)->mite);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nni_660x_GPCT_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nreturn ni_tio_rinsn(subdev_to_counter(s), insn, data);\r\n}\r\nstatic void init_tio_chip(struct comedi_device *dev, int chipset)\r\n{\r\nunsigned i;\r\nprivate(dev)->dma_configuration_soft_copies[chipset] = 0;\r\nfor (i = 0; i < MAX_DMA_CHANNEL; ++i) {\r\nprivate(dev)->dma_configuration_soft_copies[chipset] |=\r\ndma_select_bits(i, dma_selection_none) & dma_select_mask(i);\r\n}\r\nni_660x_write_register(dev, chipset,\r\nprivate(dev)->\r\ndma_configuration_soft_copies[chipset],\r\nDMAConfigRegister);\r\nfor (i = 0; i < NUM_PFI_CHANNELS; ++i)\r\nni_660x_write_register(dev, chipset, 0, IOConfigReg(i));\r\n}\r\nstatic int\r\nni_660x_GPCT_insn_config(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nreturn ni_tio_insn_config(subdev_to_counter(s), insn, data);\r\n}\r\nstatic int ni_660x_GPCT_winsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nreturn ni_tio_winsn(subdev_to_counter(s), insn, data);\r\n}\r\nstatic int ni_660x_find_device(struct comedi_device *dev, int bus, int slot)\r\n{\r\nstruct mite_struct *mite;\r\nint i;\r\nfor (mite = mite_devices; mite; mite = mite->next) {\r\nif (mite->used)\r\ncontinue;\r\nif (bus || slot) {\r\nif (bus != mite->pcidev->bus->number ||\r\nslot != PCI_SLOT(mite->pcidev->devfn))\r\ncontinue;\r\n}\r\nfor (i = 0; i < n_ni_660x_boards; i++) {\r\nif (mite_device_id(mite) == ni_660x_boards[i].dev_id) {\r\ndev->board_ptr = ni_660x_boards + i;\r\nprivate(dev)->mite = mite;\r\nreturn 0;\r\n}\r\n}\r\n}\r\nprintk(KERN_WARNING "no device found\n");\r\nmite_list_devices();\r\nreturn -EIO;\r\n}\r\nstatic int ni_660x_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned base_bitfield_channel = CR_CHAN(insn->chanspec);\r\nif (data[0]) {\r\ns->state &= ~(data[0] << base_bitfield_channel);\r\ns->state |= (data[0] & data[1]) << base_bitfield_channel;\r\nni_660x_write_register(dev, 0, s->state, DIO32Output);\r\n}\r\ndata[1] =\r\n(ni_660x_read_register(dev, 0,\r\nDIO32Input) >> base_bitfield_channel);\r\nreturn 2;\r\n}\r\nstatic void ni_660x_select_pfi_output(struct comedi_device *dev,\r\nunsigned pfi_channel,\r\nunsigned output_select)\r\n{\r\nstatic const unsigned counter_4_7_first_pfi = 8;\r\nstatic const unsigned counter_4_7_last_pfi = 23;\r\nunsigned active_chipset = 0;\r\nunsigned idle_chipset = 0;\r\nunsigned active_bits;\r\nunsigned idle_bits;\r\nif (board(dev)->n_chips > 1) {\r\nif (output_select == pfi_output_select_counter &&\r\npfi_channel >= counter_4_7_first_pfi &&\r\npfi_channel <= counter_4_7_last_pfi) {\r\nactive_chipset = 1;\r\nidle_chipset = 0;\r\n} else {\r\nactive_chipset = 0;\r\nidle_chipset = 1;\r\n}\r\n}\r\nif (idle_chipset != active_chipset) {\r\nidle_bits =\r\nni_660x_read_register(dev, idle_chipset,\r\nIOConfigReg(pfi_channel));\r\nidle_bits &= ~pfi_output_select_mask(pfi_channel);\r\nidle_bits |=\r\npfi_output_select_bits(pfi_channel,\r\npfi_output_select_high_Z);\r\nni_660x_write_register(dev, idle_chipset, idle_bits,\r\nIOConfigReg(pfi_channel));\r\n}\r\nactive_bits =\r\nni_660x_read_register(dev, active_chipset,\r\nIOConfigReg(pfi_channel));\r\nactive_bits &= ~pfi_output_select_mask(pfi_channel);\r\nactive_bits |= pfi_output_select_bits(pfi_channel, output_select);\r\nni_660x_write_register(dev, active_chipset, active_bits,\r\nIOConfigReg(pfi_channel));\r\n}\r\nstatic int ni_660x_set_pfi_routing(struct comedi_device *dev, unsigned chan,\r\nunsigned source)\r\n{\r\nif (source > num_pfi_output_selects)\r\nreturn -EINVAL;\r\nif (source == pfi_output_select_high_Z)\r\nreturn -EINVAL;\r\nif (chan < min_counter_pfi_chan) {\r\nif (source == pfi_output_select_counter)\r\nreturn -EINVAL;\r\n} else if (chan > max_dio_pfi_chan) {\r\nif (source == pfi_output_select_do)\r\nreturn -EINVAL;\r\n}\r\nBUG_ON(chan >= NUM_PFI_CHANNELS);\r\nprivate(dev)->pfi_output_selects[chan] = source;\r\nif (private(dev)->pfi_direction_bits & (((uint64_t) 1) << chan))\r\nni_660x_select_pfi_output(dev, chan,\r\nprivate(dev)->\r\npfi_output_selects[chan]);\r\nreturn 0;\r\n}\r\nstatic unsigned ni_660x_get_pfi_routing(struct comedi_device *dev,\r\nunsigned chan)\r\n{\r\nBUG_ON(chan >= NUM_PFI_CHANNELS);\r\nreturn private(dev)->pfi_output_selects[chan];\r\n}\r\nstatic void ni660x_config_filter(struct comedi_device *dev,\r\nunsigned pfi_channel,\r\nenum ni_gpct_filter_select filter)\r\n{\r\nunsigned bits = ni_660x_read_register(dev, 0, IOConfigReg(pfi_channel));\r\nbits &= ~pfi_input_select_mask(pfi_channel);\r\nbits |= pfi_input_select_bits(pfi_channel, filter);\r\nni_660x_write_register(dev, 0, bits, IOConfigReg(pfi_channel));\r\n}\r\nstatic int ni_660x_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint chan = CR_CHAN(insn->chanspec);\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIO_OUTPUT:\r\nprivate(dev)->pfi_direction_bits |= ((uint64_t) 1) << chan;\r\nni_660x_select_pfi_output(dev, chan,\r\nprivate(dev)->\r\npfi_output_selects[chan]);\r\nbreak;\r\ncase INSN_CONFIG_DIO_INPUT:\r\nprivate(dev)->pfi_direction_bits &= ~(((uint64_t) 1) << chan);\r\nni_660x_select_pfi_output(dev, chan, pfi_output_select_high_Z);\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\ndata[1] =\r\n(private(dev)->pfi_direction_bits &\r\n(((uint64_t) 1) << chan)) ? COMEDI_OUTPUT : COMEDI_INPUT;\r\nreturn 0;\r\ncase INSN_CONFIG_SET_ROUTING:\r\nreturn ni_660x_set_pfi_routing(dev, chan, data[1]);\r\nbreak;\r\ncase INSN_CONFIG_GET_ROUTING:\r\ndata[1] = ni_660x_get_pfi_routing(dev, chan);\r\nbreak;\r\ncase INSN_CONFIG_FILTER:\r\nni660x_config_filter(dev, chan, data[1]);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn 0;\r\n}
