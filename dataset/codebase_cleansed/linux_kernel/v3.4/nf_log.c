static struct nf_logger *__find_logger(int pf, const char *str_logger)\r\n{\r\nstruct nf_logger *t;\r\nlist_for_each_entry(t, &nf_loggers_l[pf], list[pf]) {\r\nif (!strnicmp(str_logger, t->name, strlen(t->name)))\r\nreturn t;\r\n}\r\nreturn NULL;\r\n}\r\nint nf_log_register(u_int8_t pf, struct nf_logger *logger)\r\n{\r\nconst struct nf_logger *llog;\r\nint i;\r\nif (pf >= ARRAY_SIZE(nf_loggers))\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(logger->list); i++)\r\nINIT_LIST_HEAD(&logger->list[i]);\r\nmutex_lock(&nf_log_mutex);\r\nif (pf == NFPROTO_UNSPEC) {\r\nfor (i = NFPROTO_UNSPEC; i < NFPROTO_NUMPROTO; i++)\r\nlist_add_tail(&(logger->list[i]), &(nf_loggers_l[i]));\r\n} else {\r\nlist_add_tail(&logger->list[pf], &nf_loggers_l[pf]);\r\nllog = rcu_dereference_protected(nf_loggers[pf],\r\nlockdep_is_held(&nf_log_mutex));\r\nif (llog == NULL)\r\nrcu_assign_pointer(nf_loggers[pf], logger);\r\n}\r\nmutex_unlock(&nf_log_mutex);\r\nreturn 0;\r\n}\r\nvoid nf_log_unregister(struct nf_logger *logger)\r\n{\r\nconst struct nf_logger *c_logger;\r\nint i;\r\nmutex_lock(&nf_log_mutex);\r\nfor (i = 0; i < ARRAY_SIZE(nf_loggers); i++) {\r\nc_logger = rcu_dereference_protected(nf_loggers[i],\r\nlockdep_is_held(&nf_log_mutex));\r\nif (c_logger == logger)\r\nRCU_INIT_POINTER(nf_loggers[i], NULL);\r\nlist_del(&logger->list[i]);\r\n}\r\nmutex_unlock(&nf_log_mutex);\r\nsynchronize_rcu();\r\n}\r\nint nf_log_bind_pf(u_int8_t pf, const struct nf_logger *logger)\r\n{\r\nif (pf >= ARRAY_SIZE(nf_loggers))\r\nreturn -EINVAL;\r\nmutex_lock(&nf_log_mutex);\r\nif (__find_logger(pf, logger->name) == NULL) {\r\nmutex_unlock(&nf_log_mutex);\r\nreturn -ENOENT;\r\n}\r\nrcu_assign_pointer(nf_loggers[pf], logger);\r\nmutex_unlock(&nf_log_mutex);\r\nreturn 0;\r\n}\r\nvoid nf_log_unbind_pf(u_int8_t pf)\r\n{\r\nif (pf >= ARRAY_SIZE(nf_loggers))\r\nreturn;\r\nmutex_lock(&nf_log_mutex);\r\nRCU_INIT_POINTER(nf_loggers[pf], NULL);\r\nmutex_unlock(&nf_log_mutex);\r\n}\r\nvoid nf_log_packet(u_int8_t pf,\r\nunsigned int hooknum,\r\nconst struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nconst struct nf_loginfo *loginfo,\r\nconst char *fmt, ...)\r\n{\r\nva_list args;\r\nchar prefix[NF_LOG_PREFIXLEN];\r\nconst struct nf_logger *logger;\r\nrcu_read_lock();\r\nlogger = rcu_dereference(nf_loggers[pf]);\r\nif (logger) {\r\nva_start(args, fmt);\r\nvsnprintf(prefix, sizeof(prefix), fmt, args);\r\nva_end(args);\r\nlogger->logfn(pf, hooknum, skb, in, out, loginfo, prefix);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void *seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nmutex_lock(&nf_log_mutex);\r\nif (*pos >= ARRAY_SIZE(nf_loggers))\r\nreturn NULL;\r\nreturn pos;\r\n}\r\nstatic void *seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nif (*pos >= ARRAY_SIZE(nf_loggers))\r\nreturn NULL;\r\nreturn pos;\r\n}\r\nstatic void seq_stop(struct seq_file *s, void *v)\r\n{\r\nmutex_unlock(&nf_log_mutex);\r\n}\r\nstatic int seq_show(struct seq_file *s, void *v)\r\n{\r\nloff_t *pos = v;\r\nconst struct nf_logger *logger;\r\nstruct nf_logger *t;\r\nint ret;\r\nlogger = rcu_dereference_protected(nf_loggers[*pos],\r\nlockdep_is_held(&nf_log_mutex));\r\nif (!logger)\r\nret = seq_printf(s, "%2lld NONE (", *pos);\r\nelse\r\nret = seq_printf(s, "%2lld %s (", *pos, logger->name);\r\nif (ret < 0)\r\nreturn ret;\r\nlist_for_each_entry(t, &nf_loggers_l[*pos], list[*pos]) {\r\nret = seq_printf(s, "%s", t->name);\r\nif (ret < 0)\r\nreturn ret;\r\nif (&t->list[*pos] != nf_loggers_l[*pos].prev) {\r\nret = seq_printf(s, ",");\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nreturn seq_printf(s, ")\n");\r\n}\r\nstatic int nflog_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &nflog_seq_ops);\r\n}\r\nstatic int nf_log_proc_dostring(ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nconst struct nf_logger *logger;\r\nchar buf[NFLOGGER_NAME_LEN];\r\nsize_t size = *lenp;\r\nint r = 0;\r\nint tindex = (unsigned long)table->extra1;\r\nif (write) {\r\nif (size > sizeof(buf))\r\nsize = sizeof(buf);\r\nif (copy_from_user(buf, buffer, size))\r\nreturn -EFAULT;\r\nif (!strcmp(buf, "NONE")) {\r\nnf_log_unbind_pf(tindex);\r\nreturn 0;\r\n}\r\nmutex_lock(&nf_log_mutex);\r\nlogger = __find_logger(tindex, buf);\r\nif (logger == NULL) {\r\nmutex_unlock(&nf_log_mutex);\r\nreturn -ENOENT;\r\n}\r\nrcu_assign_pointer(nf_loggers[tindex], logger);\r\nmutex_unlock(&nf_log_mutex);\r\n} else {\r\nmutex_lock(&nf_log_mutex);\r\nlogger = rcu_dereference_protected(nf_loggers[tindex],\r\nlockdep_is_held(&nf_log_mutex));\r\nif (!logger)\r\ntable->data = "NONE";\r\nelse\r\ntable->data = logger->name;\r\nr = proc_dostring(table, write, buffer, lenp, ppos);\r\nmutex_unlock(&nf_log_mutex);\r\n}\r\nreturn r;\r\n}\r\nstatic __init int netfilter_log_sysctl_init(void)\r\n{\r\nint i;\r\nfor (i = NFPROTO_UNSPEC; i < NFPROTO_NUMPROTO; i++) {\r\nsnprintf(nf_log_sysctl_fnames[i-NFPROTO_UNSPEC], 3, "%d", i);\r\nnf_log_sysctl_table[i].procname =\r\nnf_log_sysctl_fnames[i-NFPROTO_UNSPEC];\r\nnf_log_sysctl_table[i].data = NULL;\r\nnf_log_sysctl_table[i].maxlen =\r\nNFLOGGER_NAME_LEN * sizeof(char);\r\nnf_log_sysctl_table[i].mode = 0644;\r\nnf_log_sysctl_table[i].proc_handler = nf_log_proc_dostring;\r\nnf_log_sysctl_table[i].extra1 = (void *)(unsigned long) i;\r\n}\r\nnf_log_dir_header = register_sysctl_paths(nf_log_sysctl_path,\r\nnf_log_sysctl_table);\r\nif (!nf_log_dir_header)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic __init int netfilter_log_sysctl_init(void)\r\n{\r\nreturn 0;\r\n}\r\nint __init netfilter_log_init(void)\r\n{\r\nint i, r;\r\n#ifdef CONFIG_PROC_FS\r\nif (!proc_create("nf_log", S_IRUGO,\r\nproc_net_netfilter, &nflog_file_ops))\r\nreturn -1;\r\n#endif\r\nr = netfilter_log_sysctl_init();\r\nif (r < 0)\r\nreturn r;\r\nfor (i = NFPROTO_UNSPEC; i < NFPROTO_NUMPROTO; i++)\r\nINIT_LIST_HEAD(&(nf_loggers_l[i]));\r\nreturn 0;\r\n}
