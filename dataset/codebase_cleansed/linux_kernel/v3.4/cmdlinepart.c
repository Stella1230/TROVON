static struct mtd_partition * newpart(char *s,\r\nchar **retptr,\r\nint *num_parts,\r\nint this_part,\r\nunsigned char **extra_mem_ptr,\r\nint extra_mem_size)\r\n{\r\nstruct mtd_partition *parts;\r\nunsigned long size;\r\nunsigned long offset = OFFSET_CONTINUOUS;\r\nchar *name;\r\nint name_len;\r\nunsigned char *extra_mem;\r\nchar delim;\r\nunsigned int mask_flags;\r\nif (*s == '-')\r\n{\r\nsize = SIZE_REMAINING;\r\ns++;\r\n}\r\nelse\r\n{\r\nsize = memparse(s, &s);\r\nif (size < PAGE_SIZE)\r\n{\r\nprintk(KERN_ERR ERRP "partition size too small (%lx)\n", size);\r\nreturn NULL;\r\n}\r\n}\r\nmask_flags = 0;\r\ndelim = 0;\r\nif (*s == '@')\r\n{\r\ns++;\r\noffset = memparse(s, &s);\r\n}\r\nif (*s == '(')\r\n{\r\ndelim = ')';\r\n}\r\nif (delim)\r\n{\r\nchar *p;\r\nname = ++s;\r\np = strchr(name, delim);\r\nif (!p)\r\n{\r\nprintk(KERN_ERR ERRP "no closing %c found in partition name\n", delim);\r\nreturn NULL;\r\n}\r\nname_len = p - name;\r\ns = p + 1;\r\n}\r\nelse\r\n{\r\nname = NULL;\r\nname_len = 13;\r\n}\r\nextra_mem_size += name_len + 1;\r\nif (strncmp(s, "ro", 2) == 0)\r\n{\r\nmask_flags |= MTD_WRITEABLE;\r\ns += 2;\r\n}\r\nif (strncmp(s, "lk", 2) == 0)\r\n{\r\nmask_flags |= MTD_POWERUP_LOCK;\r\ns += 2;\r\n}\r\nif (*s == ',')\r\n{\r\nif (size == SIZE_REMAINING)\r\n{\r\nprintk(KERN_ERR ERRP "no partitions allowed after a fill-up partition\n");\r\nreturn NULL;\r\n}\r\nparts = newpart(s + 1, &s, num_parts, this_part + 1,\r\n&extra_mem, extra_mem_size);\r\nif (!parts)\r\nreturn NULL;\r\n}\r\nelse\r\n{\r\nint alloc_size;\r\n*num_parts = this_part + 1;\r\nalloc_size = *num_parts * sizeof(struct mtd_partition) +\r\nextra_mem_size;\r\nparts = kzalloc(alloc_size, GFP_KERNEL);\r\nif (!parts)\r\nreturn NULL;\r\nextra_mem = (unsigned char *)(parts + *num_parts);\r\n}\r\nparts[this_part].size = size;\r\nparts[this_part].offset = offset;\r\nparts[this_part].mask_flags = mask_flags;\r\nif (name)\r\n{\r\nstrlcpy(extra_mem, name, name_len + 1);\r\n}\r\nelse\r\n{\r\nsprintf(extra_mem, "Partition_%03d", this_part);\r\n}\r\nparts[this_part].name = extra_mem;\r\nextra_mem += name_len + 1;\r\ndbg(("partition %d: name <%s>, offset %llx, size %llx, mask flags %x\n",\r\nthis_part,\r\nparts[this_part].name,\r\nparts[this_part].offset,\r\nparts[this_part].size,\r\nparts[this_part].mask_flags));\r\nif (extra_mem_ptr)\r\n*extra_mem_ptr = extra_mem;\r\n*retptr = s;\r\nreturn parts;\r\n}\r\nstatic int mtdpart_setup_real(char *s)\r\n{\r\ncmdline_parsed = 1;\r\nfor( ; s != NULL; )\r\n{\r\nstruct cmdline_mtd_partition *this_mtd;\r\nstruct mtd_partition *parts;\r\nint mtd_id_len;\r\nint num_parts;\r\nchar *p, *mtd_id;\r\nmtd_id = s;\r\nif (!(p = strchr(s, ':')))\r\n{\r\nprintk(KERN_ERR ERRP "no mtd-id\n");\r\nreturn 0;\r\n}\r\nmtd_id_len = p - mtd_id;\r\ndbg(("parsing <%s>\n", p+1));\r\nparts = newpart(p + 1,\r\n&s,\r\n&num_parts,\r\n0,\r\n(unsigned char**)&this_mtd,\r\nmtd_id_len + 1 + sizeof(*this_mtd) +\r\nsizeof(void*)-1 );\r\nif(!parts)\r\n{\r\nreturn 0;\r\n}\r\nthis_mtd = (struct cmdline_mtd_partition *)\r\nALIGN((unsigned long)this_mtd, sizeof(void*));\r\nthis_mtd->parts = parts;\r\nthis_mtd->num_parts = num_parts;\r\nthis_mtd->mtd_id = (char*)(this_mtd + 1);\r\nstrlcpy(this_mtd->mtd_id, mtd_id, mtd_id_len + 1);\r\nthis_mtd->next = partitions;\r\npartitions = this_mtd;\r\ndbg(("mtdid=<%s> num_parts=<%d>\n",\r\nthis_mtd->mtd_id, this_mtd->num_parts));\r\nif (*s == 0)\r\nbreak;\r\nif (*s != ';')\r\n{\r\nprintk(KERN_ERR ERRP "bad character after partition (%c)\n", *s);\r\nreturn 0;\r\n}\r\ns++;\r\n}\r\nreturn 1;\r\n}\r\nstatic int parse_cmdline_partitions(struct mtd_info *master,\r\nstruct mtd_partition **pparts,\r\nstruct mtd_part_parser_data *data)\r\n{\r\nunsigned long offset;\r\nint i;\r\nstruct cmdline_mtd_partition *part;\r\nconst char *mtd_id = master->name;\r\nif (!cmdline_parsed)\r\nmtdpart_setup_real(cmdline);\r\nfor(part = partitions; part; part = part->next)\r\n{\r\nif ((!mtd_id) || (!strcmp(part->mtd_id, mtd_id)))\r\n{\r\nfor(i = 0, offset = 0; i < part->num_parts; i++)\r\n{\r\nif (part->parts[i].offset == OFFSET_CONTINUOUS)\r\npart->parts[i].offset = offset;\r\nelse\r\noffset = part->parts[i].offset;\r\nif (part->parts[i].size == SIZE_REMAINING)\r\npart->parts[i].size = master->size - offset;\r\nif (offset + part->parts[i].size > master->size)\r\n{\r\nprintk(KERN_WARNING ERRP\r\n"%s: partitioning exceeds flash size, truncating\n",\r\npart->mtd_id);\r\npart->parts[i].size = master->size - offset;\r\npart->num_parts = i;\r\n}\r\noffset += part->parts[i].size;\r\n}\r\n*pparts = kmemdup(part->parts,\r\nsizeof(*part->parts) * part->num_parts,\r\nGFP_KERNEL);\r\nif (!*pparts)\r\nreturn -ENOMEM;\r\nreturn part->num_parts;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mtdpart_setup(char *s)\r\n{\r\ncmdline = s;\r\nreturn 1;\r\n}\r\nstatic int __init cmdline_parser_init(void)\r\n{\r\nreturn register_mtd_parser(&cmdline_parser);\r\n}
