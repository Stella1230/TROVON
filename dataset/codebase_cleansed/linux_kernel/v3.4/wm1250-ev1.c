static int wm1250_ev1_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct wm1250_priv *wm1250 = dev_get_drvdata(codec->dev);\r\nint ena;\r\nif (wm1250)\r\nena = wm1250->gpios[WM1250_EV1_GPIO_CLK_ENA].gpio;\r\nelse\r\nena = -1;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (ena >= 0)\r\ngpio_set_value_cansleep(ena, 1);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nif (ena >= 0)\r\ngpio_set_value_cansleep(ena, 0);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int __devinit wm1250_ev1_pdata(struct i2c_client *i2c)\r\n{\r\nstruct wm1250_ev1_pdata *pdata = dev_get_platdata(&i2c->dev);\r\nstruct wm1250_priv *wm1250;\r\nint i, ret;\r\nif (!pdata)\r\nreturn 0;\r\nwm1250 = devm_kzalloc(&i2c->dev, sizeof(*wm1250), GFP_KERNEL);\r\nif (!wm1250) {\r\ndev_err(&i2c->dev, "Unable to allocate private data\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(wm1250->gpios); i++) {\r\nwm1250->gpios[i].gpio = pdata->gpios[i];\r\nwm1250->gpios[i].label = wm1250_gpio_names[i];\r\nwm1250->gpios[i].flags = GPIOF_OUT_INIT_LOW;\r\n}\r\nwm1250->gpios[WM1250_EV1_GPIO_CLK_SEL0].flags = GPIOF_OUT_INIT_HIGH;\r\nwm1250->gpios[WM1250_EV1_GPIO_CLK_SEL1].flags = GPIOF_OUT_INIT_HIGH;\r\nret = gpio_request_array(wm1250->gpios, ARRAY_SIZE(wm1250->gpios));\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to get GPIOs: %d\n", ret);\r\ngoto err;\r\n}\r\ndev_set_drvdata(&i2c->dev, wm1250);\r\nreturn ret;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void wm1250_ev1_free(struct i2c_client *i2c)\r\n{\r\nstruct wm1250_priv *wm1250 = dev_get_drvdata(&i2c->dev);\r\nif (wm1250)\r\ngpio_free_array(wm1250->gpios, ARRAY_SIZE(wm1250->gpios));\r\n}\r\nstatic int __devinit wm1250_ev1_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *i2c_id)\r\n{\r\nint id, board, rev, ret;\r\ndev_set_drvdata(&i2c->dev, NULL);\r\nboard = i2c_smbus_read_byte_data(i2c, 0);\r\nif (board < 0) {\r\ndev_err(&i2c->dev, "Failed to read ID: %d\n", board);\r\nreturn board;\r\n}\r\nid = (board & 0xfe) >> 2;\r\nrev = board & 0x3;\r\nif (id != 1) {\r\ndev_err(&i2c->dev, "Unknown board ID %d\n", id);\r\nreturn -ENODEV;\r\n}\r\ndev_info(&i2c->dev, "revision %d\n", rev + 1);\r\nret = wm1250_ev1_pdata(i2c);\r\nif (ret != 0)\r\nreturn ret;\r\nret = snd_soc_register_codec(&i2c->dev, &soc_codec_dev_wm1250_ev1,\r\n&wm1250_ev1_dai, 1);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to register CODEC: %d\n", ret);\r\nwm1250_ev1_free(i2c);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __devexit wm1250_ev1_remove(struct i2c_client *i2c)\r\n{\r\nsnd_soc_unregister_codec(&i2c->dev);\r\nwm1250_ev1_free(i2c);\r\nreturn 0;\r\n}\r\nstatic int __init wm1250_ev1_modinit(void)\r\n{\r\nint ret = 0;\r\nret = i2c_add_driver(&wm1250_ev1_i2c_driver);\r\nif (ret != 0)\r\npr_err("Failed to register WM1250-EV1 I2C driver: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void __exit wm1250_ev1_exit(void)\r\n{\r\ni2c_del_driver(&wm1250_ev1_i2c_driver);\r\n}
