static void reg_w(struct gspca_dev *gspca_dev, u16 value, u16 index)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\n0x02,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue,\r\nindex,\r\nNULL,\r\n0,\r\n1000);\r\nif (ret < 0) {\r\npr_err("reg_w err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void reg_r(struct gspca_dev *gspca_dev, u16 value, u16 index)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\n0x03,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue,\r\nindex,\r\ngspca_dev->usb_buf,\r\n2,\r\n1000);\r\nif (ret < 0) {\r\npr_err("reg_w err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void konica_stream_on(struct gspca_dev *gspca_dev)\r\n{\r\nreg_w(gspca_dev, 1, 0x0b);\r\n}\r\nstatic void konica_stream_off(struct gspca_dev *gspca_dev)\r\n{\r\nreg_w(gspca_dev, 0, 0x0b);\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ngspca_dev->cam.cam_mode = vga_mode;\r\ngspca_dev->cam.nmodes = ARRAY_SIZE(vga_mode);\r\ngspca_dev->cam.no_urb_create = 1;\r\nsd->brightness = BRIGHTNESS_DEFAULT;\r\nsd->contrast = CONTRAST_DEFAULT;\r\nsd->saturation = SATURATION_DEFAULT;\r\nsd->whitebal = WHITEBAL_DEFAULT;\r\nsd->sharpness = SHARPNESS_DEFAULT;\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nreg_r(gspca_dev, 0, 0x10);\r\nPDEBUG(D_PROBE, "Reg 0x10 reads: %02x %02x",\r\ngspca_dev->usb_buf[0], gspca_dev->usb_buf[1]);\r\nreg_r(gspca_dev, 0, 0x10);\r\nPDEBUG(D_PROBE, "Reg 0x10 reads: %02x %02x",\r\ngspca_dev->usb_buf[0], gspca_dev->usb_buf[1]);\r\nreg_w(gspca_dev, 0, 0x0d);\r\nreturn 0;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct urb *urb;\r\nint i, n, packet_size;\r\nstruct usb_host_interface *alt;\r\nstruct usb_interface *intf;\r\nintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\r\nalt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\r\nif (!alt) {\r\npr_err("Couldn't get altsetting\n");\r\nreturn -EIO;\r\n}\r\npacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\r\nreg_w(gspca_dev, sd->brightness, BRIGHTNESS_REG);\r\nreg_w(gspca_dev, sd->whitebal, WHITEBAL_REG);\r\nreg_w(gspca_dev, sd->contrast, CONTRAST_REG);\r\nreg_w(gspca_dev, sd->saturation, SATURATION_REG);\r\nreg_w(gspca_dev, sd->sharpness, SHARPNESS_REG);\r\nn = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].priv;\r\nreg_w(gspca_dev, n, 0x08);\r\nkonica_stream_on(gspca_dev);\r\nif (gspca_dev->usb_err)\r\nreturn gspca_dev->usb_err;\r\n#if MAX_NURBS < 4\r\n#error "Not enough URBs in the gspca table"\r\n#endif\r\n#define SD_NPKT 32\r\nfor (n = 0; n < 4; n++) {\r\ni = n & 1 ? 0 : 1;\r\npacket_size =\r\nle16_to_cpu(alt->endpoint[i].desc.wMaxPacketSize);\r\nurb = usb_alloc_urb(SD_NPKT, GFP_KERNEL);\r\nif (!urb) {\r\npr_err("usb_alloc_urb failed\n");\r\nreturn -ENOMEM;\r\n}\r\ngspca_dev->urb[n] = urb;\r\nurb->transfer_buffer = usb_alloc_coherent(gspca_dev->dev,\r\npacket_size * SD_NPKT,\r\nGFP_KERNEL,\r\n&urb->transfer_dma);\r\nif (urb->transfer_buffer == NULL) {\r\npr_err("usb_buffer_alloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nurb->dev = gspca_dev->dev;\r\nurb->context = gspca_dev;\r\nurb->transfer_buffer_length = packet_size * SD_NPKT;\r\nurb->pipe = usb_rcvisocpipe(gspca_dev->dev,\r\nn & 1 ? 0x81 : 0x82);\r\nurb->transfer_flags = URB_ISO_ASAP\r\n| URB_NO_TRANSFER_DMA_MAP;\r\nurb->interval = 1;\r\nurb->complete = sd_isoc_irq;\r\nurb->number_of_packets = SD_NPKT;\r\nfor (i = 0; i < SD_NPKT; i++) {\r\nurb->iso_frame_desc[i].length = packet_size;\r\nurb->iso_frame_desc[i].offset = packet_size * i;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nkonica_stream_off(gspca_dev);\r\n#if defined(CONFIG_INPUT) || defined(CONFIG_INPUT_MODULE)\r\nif (sd->snapshot_pressed) {\r\ninput_report_key(gspca_dev->input_dev, KEY_CAMERA, 0);\r\ninput_sync(gspca_dev->input_dev);\r\nsd->snapshot_pressed = 0;\r\n}\r\n#endif\r\n}\r\nstatic void sd_isoc_irq(struct urb *urb)\r\n{\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *) urb->context;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct urb *data_urb, *status_urb;\r\nu8 *data;\r\nint i, st;\r\nPDEBUG(D_PACK, "sd isoc irq");\r\nif (!gspca_dev->streaming)\r\nreturn;\r\nif (urb->status != 0) {\r\nif (urb->status == -ESHUTDOWN)\r\nreturn;\r\n#ifdef CONFIG_PM\r\nif (gspca_dev->frozen)\r\nreturn;\r\n#endif\r\nPDEBUG(D_ERR, "urb status: %d", urb->status);\r\nst = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (st < 0)\r\npr_err("resubmit urb error %d\n", st);\r\nreturn;\r\n}\r\nif (urb->transfer_buffer_length > 32) {\r\nsd->last_data_urb = urb;\r\nreturn;\r\n}\r\nstatus_urb = urb;\r\ndata_urb = sd->last_data_urb;\r\nsd->last_data_urb = NULL;\r\nif (!data_urb || data_urb->start_frame != status_urb->start_frame) {\r\nPDEBUG(D_ERR|D_PACK, "lost sync on frames");\r\ngoto resubmit;\r\n}\r\nif (data_urb->number_of_packets != status_urb->number_of_packets) {\r\nPDEBUG(D_ERR|D_PACK,\r\n"no packets does not match, data: %d, status: %d",\r\ndata_urb->number_of_packets,\r\nstatus_urb->number_of_packets);\r\ngoto resubmit;\r\n}\r\nfor (i = 0; i < status_urb->number_of_packets; i++) {\r\nif (data_urb->iso_frame_desc[i].status ||\r\nstatus_urb->iso_frame_desc[i].status) {\r\nPDEBUG(D_ERR|D_PACK,\r\n"pkt %d data-status %d, status-status %d", i,\r\ndata_urb->iso_frame_desc[i].status,\r\nstatus_urb->iso_frame_desc[i].status);\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\ncontinue;\r\n}\r\nif (status_urb->iso_frame_desc[i].actual_length != 1) {\r\nPDEBUG(D_ERR|D_PACK,\r\n"bad status packet length %d",\r\nstatus_urb->iso_frame_desc[i].actual_length);\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\ncontinue;\r\n}\r\nst = *((u8 *)status_urb->transfer_buffer\r\n+ status_urb->iso_frame_desc[i].offset);\r\ndata = (u8 *)data_urb->transfer_buffer\r\n+ data_urb->iso_frame_desc[i].offset;\r\nif (st & 0x80) {\r\ngspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\r\ngspca_frame_add(gspca_dev, FIRST_PACKET, NULL, 0);\r\n} else {\r\n#if defined(CONFIG_INPUT) || defined(CONFIG_INPUT_MODULE)\r\nu8 button_state = st & 0x40 ? 1 : 0;\r\nif (sd->snapshot_pressed != button_state) {\r\ninput_report_key(gspca_dev->input_dev,\r\nKEY_CAMERA,\r\nbutton_state);\r\ninput_sync(gspca_dev->input_dev);\r\nsd->snapshot_pressed = button_state;\r\n}\r\n#endif\r\nif (st & 0x01)\r\ncontinue;\r\n}\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data,\r\ndata_urb->iso_frame_desc[i].actual_length);\r\n}\r\nresubmit:\r\nif (data_urb) {\r\nst = usb_submit_urb(data_urb, GFP_ATOMIC);\r\nif (st < 0)\r\nPDEBUG(D_ERR|D_PACK,\r\n"usb_submit_urb(data_urb) ret %d", st);\r\n}\r\nst = usb_submit_urb(status_urb, GFP_ATOMIC);\r\nif (st < 0)\r\npr_err("usb_submit_urb(status_urb) ret %d\n", st);\r\n}\r\nstatic int sd_setbrightness(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->brightness = val;\r\nif (gspca_dev->streaming) {\r\nkonica_stream_off(gspca_dev);\r\nreg_w(gspca_dev, sd->brightness, BRIGHTNESS_REG);\r\nkonica_stream_on(gspca_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_getbrightness(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->brightness;\r\nreturn 0;\r\n}\r\nstatic int sd_setcontrast(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->contrast = val;\r\nif (gspca_dev->streaming) {\r\nkonica_stream_off(gspca_dev);\r\nreg_w(gspca_dev, sd->contrast, CONTRAST_REG);\r\nkonica_stream_on(gspca_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_getcontrast(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->contrast;\r\nreturn 0;\r\n}\r\nstatic int sd_setsaturation(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->saturation = val;\r\nif (gspca_dev->streaming) {\r\nkonica_stream_off(gspca_dev);\r\nreg_w(gspca_dev, sd->saturation, SATURATION_REG);\r\nkonica_stream_on(gspca_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_getsaturation(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->saturation;\r\nreturn 0;\r\n}\r\nstatic int sd_setwhitebal(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->whitebal = val;\r\nif (gspca_dev->streaming) {\r\nkonica_stream_off(gspca_dev);\r\nreg_w(gspca_dev, sd->whitebal, WHITEBAL_REG);\r\nkonica_stream_on(gspca_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_getwhitebal(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->whitebal;\r\nreturn 0;\r\n}\r\nstatic int sd_setsharpness(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nsd->sharpness = val;\r\nif (gspca_dev->streaming) {\r\nkonica_stream_off(gspca_dev);\r\nreg_w(gspca_dev, sd->sharpness, SHARPNESS_REG);\r\nkonica_stream_on(gspca_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_getsharpness(struct gspca_dev *gspca_dev, __s32 *val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n*val = sd->sharpness;\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
