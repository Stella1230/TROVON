static int __init octeon_cf_device_init(void)\r\n{\r\nunion cvmx_mio_boot_reg_cfgx mio_boot_reg_cfg;\r\nunsigned long base_ptr, region_base, region_size;\r\nstruct platform_device *pd;\r\nstruct resource cf_resources[3];\r\nunsigned int num_resources;\r\nint i;\r\nint ret = 0;\r\nbase_ptr = 0;\r\nif (octeon_bootinfo->major_version == 1\r\n&& octeon_bootinfo->minor_version >= 1) {\r\nif (octeon_bootinfo->compact_flash_common_base_addr)\r\nbase_ptr =\r\nocteon_bootinfo->compact_flash_common_base_addr;\r\n} else {\r\nbase_ptr = 0x1d000800;\r\n}\r\nif (!base_ptr)\r\nreturn ret;\r\nfor (i = 0; i < 8; i++) {\r\nmio_boot_reg_cfg.u64 = cvmx_read_csr(CVMX_MIO_BOOT_REG_CFGX(i));\r\nregion_base = mio_boot_reg_cfg.s.base << 16;\r\nregion_size = (mio_boot_reg_cfg.s.size + 1) << 16;\r\nif (mio_boot_reg_cfg.s.en && base_ptr >= region_base\r\n&& base_ptr < region_base + region_size)\r\nbreak;\r\n}\r\nif (i >= 7) {\r\ngoto out;\r\n}\r\nocteon_cf_data.base_region = i;\r\nocteon_cf_data.is16bit = mio_boot_reg_cfg.s.width;\r\nocteon_cf_data.base_region_bias = base_ptr - region_base;\r\nmemset(cf_resources, 0, sizeof(cf_resources));\r\nnum_resources = 0;\r\ncf_resources[num_resources].flags = IORESOURCE_MEM;\r\ncf_resources[num_resources].start = region_base;\r\ncf_resources[num_resources].end = region_base + region_size - 1;\r\nnum_resources++;\r\nif (!(base_ptr & 0xfffful)) {\r\nmio_boot_reg_cfg.u64 =\r\ncvmx_read_csr(CVMX_MIO_BOOT_REG_CFGX(i + 1));\r\nregion_base = mio_boot_reg_cfg.s.base << 16;\r\nregion_size = (mio_boot_reg_cfg.s.size + 1) << 16;\r\nif (!mio_boot_reg_cfg.s.en)\r\ngoto out;\r\ncf_resources[num_resources].flags = IORESOURCE_MEM;\r\ncf_resources[num_resources].start = region_base;\r\ncf_resources[num_resources].end = region_base + region_size - 1;\r\nnum_resources++;\r\nocteon_cf_data.dma_engine = 0;\r\ncf_resources[num_resources].flags = IORESOURCE_IRQ;\r\ncf_resources[num_resources].start = OCTEON_IRQ_BOOTDMA;\r\ncf_resources[num_resources].end = OCTEON_IRQ_BOOTDMA;\r\nnum_resources++;\r\n} else {\r\nocteon_cf_data.dma_engine = -1;\r\n}\r\npd = platform_device_alloc("pata_octeon_cf", -1);\r\nif (!pd) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\npd->dev.platform_data = &octeon_cf_data;\r\nret = platform_device_add_resources(pd, cf_resources, num_resources);\r\nif (ret)\r\ngoto fail;\r\nret = platform_device_add(pd);\r\nif (ret)\r\ngoto fail;\r\nreturn ret;\r\nfail:\r\nplatform_device_put(pd);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __init octeon_rng_device_init(void)\r\n{\r\nstruct platform_device *pd;\r\nint ret = 0;\r\nstruct resource rng_resources[] = {\r\n{\r\n.flags = IORESOURCE_MEM,\r\n.start = XKPHYS_TO_PHYS(CVMX_RNM_CTL_STATUS),\r\n.end = XKPHYS_TO_PHYS(CVMX_RNM_CTL_STATUS) + 0xf\r\n}, {\r\n.flags = IORESOURCE_MEM,\r\n.start = cvmx_build_io_address(8, 0),\r\n.end = cvmx_build_io_address(8, 0) + 0x7\r\n}\r\n};\r\npd = platform_device_alloc("octeon_rng", -1);\r\nif (!pd) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = platform_device_add_resources(pd, rng_resources,\r\nARRAY_SIZE(rng_resources));\r\nif (ret)\r\ngoto fail;\r\nret = platform_device_add(pd);\r\nif (ret)\r\ngoto fail;\r\nreturn ret;\r\nfail:\r\nplatform_device_put(pd);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __init octeon_i2c_devices_init(void)\r\n{\r\nreturn i2c_register_board_info(0, octeon_i2c_devices,\r\nARRAY_SIZE(octeon_i2c_devices));\r\n}\r\nstatic int __init octeon_i2c_device_init(void)\r\n{\r\nstruct platform_device *pd;\r\nint ret = 0;\r\nint port, num_ports;\r\nstruct resource i2c_resources[] = {\r\n{\r\n.flags = IORESOURCE_MEM,\r\n}, {\r\n.flags = IORESOURCE_IRQ,\r\n}\r\n};\r\nif (OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN52XX))\r\nnum_ports = 2;\r\nelse\r\nnum_ports = 1;\r\nfor (port = 0; port < num_ports; port++) {\r\nocteon_i2c_data[port].sys_freq = octeon_get_io_clock_rate();\r\nocteon_i2c_data[port].i2c_freq = 100000;\r\npd = platform_device_alloc("i2c-octeon", port);\r\nif (!pd) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\npd->dev.platform_data = octeon_i2c_data + port;\r\ni2c_resources[0].start =\r\nOCTEON_I2C_IO_BASE + (port * OCTEON_I2C_IO_UNIT_OFFSET);\r\ni2c_resources[0].end = i2c_resources[0].start + 0x1f;\r\nswitch (port) {\r\ncase 0:\r\ni2c_resources[1].start = OCTEON_IRQ_TWSI;\r\ni2c_resources[1].end = OCTEON_IRQ_TWSI;\r\nbreak;\r\ncase 1:\r\ni2c_resources[1].start = OCTEON_IRQ_TWSI2;\r\ni2c_resources[1].end = OCTEON_IRQ_TWSI2;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nret = platform_device_add_resources(pd,\r\ni2c_resources,\r\nARRAY_SIZE(i2c_resources));\r\nif (ret)\r\ngoto fail;\r\nret = platform_device_add(pd);\r\nif (ret)\r\ngoto fail;\r\n}\r\nreturn ret;\r\nfail:\r\nplatform_device_put(pd);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __init octeon_mdiobus_device_init(void)\r\n{\r\nstruct platform_device *pd;\r\nint ret = 0;\r\nif (octeon_is_simulation())\r\nreturn 0;\r\npd = platform_device_alloc("mdio-octeon", 0);\r\nif (!pd) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = platform_device_add(pd);\r\nif (ret)\r\ngoto fail;\r\nreturn ret;\r\nfail:\r\nplatform_device_put(pd);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __init octeon_mgmt_device_init(void)\r\n{\r\nstruct platform_device *pd;\r\nint ret = 0;\r\nint port, num_ports;\r\nstruct resource mgmt_port_resource = {\r\n.flags = IORESOURCE_IRQ,\r\n.start = -1,\r\n.end = -1\r\n};\r\nif (!OCTEON_IS_MODEL(OCTEON_CN56XX) && !OCTEON_IS_MODEL(OCTEON_CN52XX))\r\nreturn 0;\r\nif (OCTEON_IS_MODEL(OCTEON_CN56XX))\r\nnum_ports = 1;\r\nelse\r\nnum_ports = 2;\r\nfor (port = 0; port < num_ports; port++) {\r\npd = platform_device_alloc("octeon_mgmt", port);\r\nif (!pd) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\npd->dev.coherent_dma_mask = DMA_BIT_MASK(64);\r\npd->dev.dma_mask = &pd->dev.coherent_dma_mask;\r\nswitch (port) {\r\ncase 0:\r\nmgmt_port_resource.start = OCTEON_IRQ_MII0;\r\nbreak;\r\ncase 1:\r\nmgmt_port_resource.start = OCTEON_IRQ_MII1;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nmgmt_port_resource.end = mgmt_port_resource.start;\r\nret = platform_device_add_resources(pd, &mgmt_port_resource, 1);\r\nif (ret)\r\ngoto fail;\r\nret = platform_device_add(pd);\r\nif (ret)\r\ngoto fail;\r\n}\r\nreturn ret;\r\nfail:\r\nplatform_device_put(pd);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __init octeon_ehci_device_init(void)\r\n{\r\nstruct platform_device *pd;\r\nint ret = 0;\r\nstruct resource usb_resources[] = {\r\n{\r\n.flags = IORESOURCE_MEM,\r\n}, {\r\n.flags = IORESOURCE_IRQ,\r\n}\r\n};\r\nif (!OCTEON_IS_MODEL(OCTEON_CN63XX))\r\nreturn 0;\r\nif (octeon_is_simulation() || usb_disabled())\r\nreturn 0;\r\npd = platform_device_alloc("octeon-ehci", 0);\r\nif (!pd) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nusb_resources[0].start = 0x00016F0000000000ULL;\r\nusb_resources[0].end = usb_resources[0].start + 0x100;\r\nusb_resources[1].start = OCTEON_IRQ_USB0;\r\nusb_resources[1].end = OCTEON_IRQ_USB0;\r\nret = platform_device_add_resources(pd, usb_resources,\r\nARRAY_SIZE(usb_resources));\r\nif (ret)\r\ngoto fail;\r\nret = platform_device_add(pd);\r\nif (ret)\r\ngoto fail;\r\nreturn ret;\r\nfail:\r\nplatform_device_put(pd);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __init octeon_ohci_device_init(void)\r\n{\r\nstruct platform_device *pd;\r\nint ret = 0;\r\nstruct resource usb_resources[] = {\r\n{\r\n.flags = IORESOURCE_MEM,\r\n}, {\r\n.flags = IORESOURCE_IRQ,\r\n}\r\n};\r\nif (!OCTEON_IS_MODEL(OCTEON_CN63XX))\r\nreturn 0;\r\nif (octeon_is_simulation() || usb_disabled())\r\nreturn 0;\r\npd = platform_device_alloc("octeon-ohci", 0);\r\nif (!pd) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nusb_resources[0].start = 0x00016F0000000400ULL;\r\nusb_resources[0].end = usb_resources[0].start + 0x100;\r\nusb_resources[1].start = OCTEON_IRQ_USB0;\r\nusb_resources[1].end = OCTEON_IRQ_USB0;\r\nret = platform_device_add_resources(pd, usb_resources,\r\nARRAY_SIZE(usb_resources));\r\nif (ret)\r\ngoto fail;\r\nret = platform_device_add(pd);\r\nif (ret)\r\ngoto fail;\r\nreturn ret;\r\nfail:\r\nplatform_device_put(pd);\r\nout:\r\nreturn ret;\r\n}
