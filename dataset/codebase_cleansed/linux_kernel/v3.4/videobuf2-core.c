static int __vb2_buf_mem_alloc(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nvoid *mem_priv;\r\nint plane;\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nmem_priv = call_memop(q, alloc, q->alloc_ctx[plane],\r\nq->plane_sizes[plane]);\r\nif (IS_ERR_OR_NULL(mem_priv))\r\ngoto free;\r\nvb->planes[plane].mem_priv = mem_priv;\r\nvb->v4l2_planes[plane].length = q->plane_sizes[plane];\r\n}\r\nreturn 0;\r\nfree:\r\nfor (; plane > 0; --plane) {\r\ncall_memop(q, put, vb->planes[plane - 1].mem_priv);\r\nvb->planes[plane - 1].mem_priv = NULL;\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic void __vb2_buf_mem_free(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nunsigned int plane;\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\ncall_memop(q, put, vb->planes[plane].mem_priv);\r\nvb->planes[plane].mem_priv = NULL;\r\ndprintk(3, "Freed plane %d of buffer %d\n", plane,\r\nvb->v4l2_buf.index);\r\n}\r\n}\r\nstatic void __vb2_buf_userptr_put(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nunsigned int plane;\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nif (vb->planes[plane].mem_priv)\r\ncall_memop(q, put_userptr, vb->planes[plane].mem_priv);\r\nvb->planes[plane].mem_priv = NULL;\r\n}\r\n}\r\nstatic void __setup_offsets(struct vb2_queue *q, unsigned int n)\r\n{\r\nunsigned int buffer, plane;\r\nstruct vb2_buffer *vb;\r\nunsigned long off;\r\nif (q->num_buffers) {\r\nstruct v4l2_plane *p;\r\nvb = q->bufs[q->num_buffers - 1];\r\np = &vb->v4l2_planes[vb->num_planes - 1];\r\noff = PAGE_ALIGN(p->m.mem_offset + p->length);\r\n} else {\r\noff = 0;\r\n}\r\nfor (buffer = q->num_buffers; buffer < q->num_buffers + n; ++buffer) {\r\nvb = q->bufs[buffer];\r\nif (!vb)\r\ncontinue;\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nvb->v4l2_planes[plane].length = q->plane_sizes[plane];\r\nvb->v4l2_planes[plane].m.mem_offset = off;\r\ndprintk(3, "Buffer %d, plane %d offset 0x%08lx\n",\r\nbuffer, plane, off);\r\noff += vb->v4l2_planes[plane].length;\r\noff = PAGE_ALIGN(off);\r\n}\r\n}\r\n}\r\nstatic int __vb2_queue_alloc(struct vb2_queue *q, enum v4l2_memory memory,\r\nunsigned int num_buffers, unsigned int num_planes)\r\n{\r\nunsigned int buffer;\r\nstruct vb2_buffer *vb;\r\nint ret;\r\nfor (buffer = 0; buffer < num_buffers; ++buffer) {\r\nvb = kzalloc(q->buf_struct_size, GFP_KERNEL);\r\nif (!vb) {\r\ndprintk(1, "Memory alloc for buffer struct failed\n");\r\nbreak;\r\n}\r\nif (V4L2_TYPE_IS_MULTIPLANAR(q->type))\r\nvb->v4l2_buf.length = num_planes;\r\nvb->state = VB2_BUF_STATE_DEQUEUED;\r\nvb->vb2_queue = q;\r\nvb->num_planes = num_planes;\r\nvb->v4l2_buf.index = q->num_buffers + buffer;\r\nvb->v4l2_buf.type = q->type;\r\nvb->v4l2_buf.memory = memory;\r\nif (memory == V4L2_MEMORY_MMAP) {\r\nret = __vb2_buf_mem_alloc(vb);\r\nif (ret) {\r\ndprintk(1, "Failed allocating memory for "\r\n"buffer %d\n", buffer);\r\nkfree(vb);\r\nbreak;\r\n}\r\nret = call_qop(q, buf_init, vb);\r\nif (ret) {\r\ndprintk(1, "Buffer %d %p initialization"\r\n" failed\n", buffer, vb);\r\n__vb2_buf_mem_free(vb);\r\nkfree(vb);\r\nbreak;\r\n}\r\n}\r\nq->bufs[q->num_buffers + buffer] = vb;\r\n}\r\n__setup_offsets(q, buffer);\r\ndprintk(1, "Allocated %d buffers, %d plane(s) each\n",\r\nbuffer, num_planes);\r\nreturn buffer;\r\n}\r\nstatic void __vb2_free_mem(struct vb2_queue *q, unsigned int buffers)\r\n{\r\nunsigned int buffer;\r\nstruct vb2_buffer *vb;\r\nfor (buffer = q->num_buffers - buffers; buffer < q->num_buffers;\r\n++buffer) {\r\nvb = q->bufs[buffer];\r\nif (!vb)\r\ncontinue;\r\nif (q->memory == V4L2_MEMORY_MMAP)\r\n__vb2_buf_mem_free(vb);\r\nelse\r\n__vb2_buf_userptr_put(vb);\r\n}\r\n}\r\nstatic void __vb2_queue_free(struct vb2_queue *q, unsigned int buffers)\r\n{\r\nunsigned int buffer;\r\nif (q->ops->buf_cleanup) {\r\nfor (buffer = q->num_buffers - buffers; buffer < q->num_buffers;\r\n++buffer) {\r\nif (NULL == q->bufs[buffer])\r\ncontinue;\r\nq->ops->buf_cleanup(q->bufs[buffer]);\r\n}\r\n}\r\n__vb2_free_mem(q, buffers);\r\nfor (buffer = q->num_buffers - buffers; buffer < q->num_buffers;\r\n++buffer) {\r\nkfree(q->bufs[buffer]);\r\nq->bufs[buffer] = NULL;\r\n}\r\nq->num_buffers -= buffers;\r\nif (!q->num_buffers)\r\nq->memory = 0;\r\nINIT_LIST_HEAD(&q->queued_list);\r\n}\r\nstatic int __verify_planes_array(struct vb2_buffer *vb, const struct v4l2_buffer *b)\r\n{\r\nif (NULL == b->m.planes) {\r\ndprintk(1, "Multi-planar buffer passed but "\r\n"planes array not provided\n");\r\nreturn -EINVAL;\r\n}\r\nif (b->length < vb->num_planes || b->length > VIDEO_MAX_PLANES) {\r\ndprintk(1, "Incorrect planes array length, "\r\n"expected %d, got %d\n", vb->num_planes, b->length);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool __buffer_in_use(struct vb2_queue *q, struct vb2_buffer *vb)\r\n{\r\nunsigned int plane;\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nvoid *mem_priv = vb->planes[plane].mem_priv;\r\nif (mem_priv && call_memop(q, num_users, mem_priv) > 1)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool __buffers_in_use(struct vb2_queue *q)\r\n{\r\nunsigned int buffer;\r\nfor (buffer = 0; buffer < q->num_buffers; ++buffer) {\r\nif (__buffer_in_use(q, q->bufs[buffer]))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int __fill_v4l2_buffer(struct vb2_buffer *vb, struct v4l2_buffer *b)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nint ret;\r\nmemcpy(b, &vb->v4l2_buf, offsetof(struct v4l2_buffer, m));\r\nb->input = vb->v4l2_buf.input;\r\nb->reserved = vb->v4l2_buf.reserved;\r\nif (V4L2_TYPE_IS_MULTIPLANAR(q->type)) {\r\nret = __verify_planes_array(vb, b);\r\nif (ret)\r\nreturn ret;\r\nmemcpy(b->m.planes, vb->v4l2_planes,\r\nb->length * sizeof(struct v4l2_plane));\r\n} else {\r\nb->length = vb->v4l2_planes[0].length;\r\nb->bytesused = vb->v4l2_planes[0].bytesused;\r\nif (q->memory == V4L2_MEMORY_MMAP)\r\nb->m.offset = vb->v4l2_planes[0].m.mem_offset;\r\nelse if (q->memory == V4L2_MEMORY_USERPTR)\r\nb->m.userptr = vb->v4l2_planes[0].m.userptr;\r\n}\r\nb->flags &= ~V4L2_BUFFER_STATE_FLAGS;\r\nswitch (vb->state) {\r\ncase VB2_BUF_STATE_QUEUED:\r\ncase VB2_BUF_STATE_ACTIVE:\r\nb->flags |= V4L2_BUF_FLAG_QUEUED;\r\nbreak;\r\ncase VB2_BUF_STATE_ERROR:\r\nb->flags |= V4L2_BUF_FLAG_ERROR;\r\ncase VB2_BUF_STATE_DONE:\r\nb->flags |= V4L2_BUF_FLAG_DONE;\r\nbreak;\r\ncase VB2_BUF_STATE_PREPARED:\r\nb->flags |= V4L2_BUF_FLAG_PREPARED;\r\nbreak;\r\ncase VB2_BUF_STATE_DEQUEUED:\r\nbreak;\r\n}\r\nif (__buffer_in_use(q, vb))\r\nb->flags |= V4L2_BUF_FLAG_MAPPED;\r\nreturn 0;\r\n}\r\nint vb2_querybuf(struct vb2_queue *q, struct v4l2_buffer *b)\r\n{\r\nstruct vb2_buffer *vb;\r\nif (b->type != q->type) {\r\ndprintk(1, "querybuf: wrong buffer type\n");\r\nreturn -EINVAL;\r\n}\r\nif (b->index >= q->num_buffers) {\r\ndprintk(1, "querybuf: buffer index out of range\n");\r\nreturn -EINVAL;\r\n}\r\nvb = q->bufs[b->index];\r\nreturn __fill_v4l2_buffer(vb, b);\r\n}\r\nstatic int __verify_userptr_ops(struct vb2_queue *q)\r\n{\r\nif (!(q->io_modes & VB2_USERPTR) || !q->mem_ops->get_userptr ||\r\n!q->mem_ops->put_userptr)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int __verify_mmap_ops(struct vb2_queue *q)\r\n{\r\nif (!(q->io_modes & VB2_MMAP) || !q->mem_ops->alloc ||\r\n!q->mem_ops->put || !q->mem_ops->mmap)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint vb2_reqbufs(struct vb2_queue *q, struct v4l2_requestbuffers *req)\r\n{\r\nunsigned int num_buffers, allocated_buffers, num_planes = 0;\r\nint ret = 0;\r\nif (q->fileio) {\r\ndprintk(1, "reqbufs: file io in progress\n");\r\nreturn -EBUSY;\r\n}\r\nif (req->memory != V4L2_MEMORY_MMAP\r\n&& req->memory != V4L2_MEMORY_USERPTR) {\r\ndprintk(1, "reqbufs: unsupported memory type\n");\r\nreturn -EINVAL;\r\n}\r\nif (req->type != q->type) {\r\ndprintk(1, "reqbufs: requested type is incorrect\n");\r\nreturn -EINVAL;\r\n}\r\nif (q->streaming) {\r\ndprintk(1, "reqbufs: streaming active\n");\r\nreturn -EBUSY;\r\n}\r\nif (req->memory == V4L2_MEMORY_MMAP && __verify_mmap_ops(q)) {\r\ndprintk(1, "reqbufs: MMAP for current setup unsupported\n");\r\nreturn -EINVAL;\r\n}\r\nif (req->memory == V4L2_MEMORY_USERPTR && __verify_userptr_ops(q)) {\r\ndprintk(1, "reqbufs: USERPTR for current setup unsupported\n");\r\nreturn -EINVAL;\r\n}\r\nif (req->count == 0 || q->num_buffers != 0 || q->memory != req->memory) {\r\nif (q->memory == V4L2_MEMORY_MMAP && __buffers_in_use(q)) {\r\ndprintk(1, "reqbufs: memory in use, cannot free\n");\r\nreturn -EBUSY;\r\n}\r\n__vb2_queue_free(q, q->num_buffers);\r\nif (req->count == 0)\r\nreturn 0;\r\n}\r\nnum_buffers = min_t(unsigned int, req->count, VIDEO_MAX_FRAME);\r\nmemset(q->plane_sizes, 0, sizeof(q->plane_sizes));\r\nmemset(q->alloc_ctx, 0, sizeof(q->alloc_ctx));\r\nq->memory = req->memory;\r\nret = call_qop(q, queue_setup, q, NULL, &num_buffers, &num_planes,\r\nq->plane_sizes, q->alloc_ctx);\r\nif (ret)\r\nreturn ret;\r\nret = __vb2_queue_alloc(q, req->memory, num_buffers, num_planes);\r\nif (ret == 0) {\r\ndprintk(1, "Memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nallocated_buffers = ret;\r\nif (allocated_buffers < num_buffers) {\r\nnum_buffers = allocated_buffers;\r\nret = call_qop(q, queue_setup, q, NULL, &num_buffers,\r\n&num_planes, q->plane_sizes, q->alloc_ctx);\r\nif (!ret && allocated_buffers < num_buffers)\r\nret = -ENOMEM;\r\n}\r\nq->num_buffers = allocated_buffers;\r\nif (ret < 0) {\r\n__vb2_queue_free(q, allocated_buffers);\r\nreturn ret;\r\n}\r\nreq->count = allocated_buffers;\r\nreturn 0;\r\n}\r\nint vb2_create_bufs(struct vb2_queue *q, struct v4l2_create_buffers *create)\r\n{\r\nunsigned int num_planes = 0, num_buffers, allocated_buffers;\r\nint ret = 0;\r\nif (q->fileio) {\r\ndprintk(1, "%s(): file io in progress\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nif (create->memory != V4L2_MEMORY_MMAP\r\n&& create->memory != V4L2_MEMORY_USERPTR) {\r\ndprintk(1, "%s(): unsupported memory type\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (create->format.type != q->type) {\r\ndprintk(1, "%s(): requested type is incorrect\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (create->memory == V4L2_MEMORY_MMAP && __verify_mmap_ops(q)) {\r\ndprintk(1, "%s(): MMAP for current setup unsupported\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (create->memory == V4L2_MEMORY_USERPTR && __verify_userptr_ops(q)) {\r\ndprintk(1, "%s(): USERPTR for current setup unsupported\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (q->num_buffers == VIDEO_MAX_FRAME) {\r\ndprintk(1, "%s(): maximum number of buffers already allocated\n",\r\n__func__);\r\nreturn -ENOBUFS;\r\n}\r\ncreate->index = q->num_buffers;\r\nif (!q->num_buffers) {\r\nmemset(q->plane_sizes, 0, sizeof(q->plane_sizes));\r\nmemset(q->alloc_ctx, 0, sizeof(q->alloc_ctx));\r\nq->memory = create->memory;\r\n}\r\nnum_buffers = min(create->count, VIDEO_MAX_FRAME - q->num_buffers);\r\nret = call_qop(q, queue_setup, q, &create->format, &num_buffers,\r\n&num_planes, q->plane_sizes, q->alloc_ctx);\r\nif (ret)\r\nreturn ret;\r\nret = __vb2_queue_alloc(q, create->memory, num_buffers,\r\nnum_planes);\r\nif (ret < 0) {\r\ndprintk(1, "Memory allocation failed with error: %d\n", ret);\r\nreturn ret;\r\n}\r\nallocated_buffers = ret;\r\nif (ret < num_buffers) {\r\nnum_buffers = ret;\r\nret = call_qop(q, queue_setup, q, &create->format, &num_buffers,\r\n&num_planes, q->plane_sizes, q->alloc_ctx);\r\nif (!ret && allocated_buffers < num_buffers)\r\nret = -ENOMEM;\r\n}\r\nq->num_buffers += allocated_buffers;\r\nif (ret < 0) {\r\n__vb2_queue_free(q, allocated_buffers);\r\nreturn ret;\r\n}\r\ncreate->count = allocated_buffers;\r\nreturn 0;\r\n}\r\nvoid *vb2_plane_vaddr(struct vb2_buffer *vb, unsigned int plane_no)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nif (plane_no > vb->num_planes || !vb->planes[plane_no].mem_priv)\r\nreturn NULL;\r\nreturn call_memop(q, vaddr, vb->planes[plane_no].mem_priv);\r\n}\r\nvoid *vb2_plane_cookie(struct vb2_buffer *vb, unsigned int plane_no)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nif (plane_no > vb->num_planes || !vb->planes[plane_no].mem_priv)\r\nreturn NULL;\r\nreturn call_memop(q, cookie, vb->planes[plane_no].mem_priv);\r\n}\r\nvoid vb2_buffer_done(struct vb2_buffer *vb, enum vb2_buffer_state state)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nunsigned long flags;\r\nif (vb->state != VB2_BUF_STATE_ACTIVE)\r\nreturn;\r\nif (state != VB2_BUF_STATE_DONE && state != VB2_BUF_STATE_ERROR)\r\nreturn;\r\ndprintk(4, "Done processing on buffer %d, state: %d\n",\r\nvb->v4l2_buf.index, vb->state);\r\nspin_lock_irqsave(&q->done_lock, flags);\r\nvb->state = state;\r\nlist_add_tail(&vb->done_entry, &q->done_list);\r\natomic_dec(&q->queued_count);\r\nspin_unlock_irqrestore(&q->done_lock, flags);\r\nwake_up(&q->done_wq);\r\n}\r\nstatic int __fill_vb2_buffer(struct vb2_buffer *vb, const struct v4l2_buffer *b,\r\nstruct v4l2_plane *v4l2_planes)\r\n{\r\nunsigned int plane;\r\nint ret;\r\nif (V4L2_TYPE_IS_MULTIPLANAR(b->type)) {\r\nret = __verify_planes_array(vb, b);\r\nif (ret)\r\nreturn ret;\r\nif (V4L2_TYPE_IS_OUTPUT(b->type)) {\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nv4l2_planes[plane].bytesused =\r\nb->m.planes[plane].bytesused;\r\nv4l2_planes[plane].data_offset =\r\nb->m.planes[plane].data_offset;\r\n}\r\n}\r\nif (b->memory == V4L2_MEMORY_USERPTR) {\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nv4l2_planes[plane].m.userptr =\r\nb->m.planes[plane].m.userptr;\r\nv4l2_planes[plane].length =\r\nb->m.planes[plane].length;\r\n}\r\n}\r\n} else {\r\nif (V4L2_TYPE_IS_OUTPUT(b->type))\r\nv4l2_planes[0].bytesused = b->bytesused;\r\nif (b->memory == V4L2_MEMORY_USERPTR) {\r\nv4l2_planes[0].m.userptr = b->m.userptr;\r\nv4l2_planes[0].length = b->length;\r\n}\r\n}\r\nvb->v4l2_buf.field = b->field;\r\nvb->v4l2_buf.timestamp = b->timestamp;\r\nvb->v4l2_buf.input = b->input;\r\nvb->v4l2_buf.flags = b->flags & ~V4L2_BUFFER_STATE_FLAGS;\r\nreturn 0;\r\n}\r\nstatic int __qbuf_userptr(struct vb2_buffer *vb, const struct v4l2_buffer *b)\r\n{\r\nstruct v4l2_plane planes[VIDEO_MAX_PLANES];\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nvoid *mem_priv;\r\nunsigned int plane;\r\nint ret;\r\nint write = !V4L2_TYPE_IS_OUTPUT(q->type);\r\nret = __fill_vb2_buffer(vb, b, planes);\r\nif (ret)\r\nreturn ret;\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nif (vb->v4l2_planes[plane].m.userptr &&\r\nvb->v4l2_planes[plane].m.userptr == planes[plane].m.userptr\r\n&& vb->v4l2_planes[plane].length == planes[plane].length)\r\ncontinue;\r\ndprintk(3, "qbuf: userspace address for plane %d changed, "\r\n"reacquiring memory\n", plane);\r\nif (planes[plane].length < q->plane_sizes[plane]) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (vb->planes[plane].mem_priv)\r\ncall_memop(q, put_userptr, vb->planes[plane].mem_priv);\r\nvb->planes[plane].mem_priv = NULL;\r\nvb->v4l2_planes[plane].m.userptr = 0;\r\nvb->v4l2_planes[plane].length = 0;\r\nmem_priv = call_memop(q, get_userptr, q->alloc_ctx[plane],\r\nplanes[plane].m.userptr,\r\nplanes[plane].length, write);\r\nif (IS_ERR_OR_NULL(mem_priv)) {\r\ndprintk(1, "qbuf: failed acquiring userspace "\r\n"memory for plane %d\n", plane);\r\nret = mem_priv ? PTR_ERR(mem_priv) : -EINVAL;\r\ngoto err;\r\n}\r\nvb->planes[plane].mem_priv = mem_priv;\r\n}\r\nret = call_qop(q, buf_init, vb);\r\nif (ret) {\r\ndprintk(1, "qbuf: buffer initialization failed\n");\r\ngoto err;\r\n}\r\nfor (plane = 0; plane < vb->num_planes; ++plane)\r\nvb->v4l2_planes[plane] = planes[plane];\r\nreturn 0;\r\nerr:\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nif (vb->planes[plane].mem_priv)\r\ncall_memop(q, put_userptr, vb->planes[plane].mem_priv);\r\nvb->planes[plane].mem_priv = NULL;\r\nvb->v4l2_planes[plane].m.userptr = 0;\r\nvb->v4l2_planes[plane].length = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __qbuf_mmap(struct vb2_buffer *vb, const struct v4l2_buffer *b)\r\n{\r\nreturn __fill_vb2_buffer(vb, b, vb->v4l2_planes);\r\n}\r\nstatic void __enqueue_in_driver(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nvb->state = VB2_BUF_STATE_ACTIVE;\r\natomic_inc(&q->queued_count);\r\nq->ops->buf_queue(vb);\r\n}\r\nstatic int __buf_prepare(struct vb2_buffer *vb, const struct v4l2_buffer *b)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nint ret;\r\nswitch (q->memory) {\r\ncase V4L2_MEMORY_MMAP:\r\nret = __qbuf_mmap(vb, b);\r\nbreak;\r\ncase V4L2_MEMORY_USERPTR:\r\nret = __qbuf_userptr(vb, b);\r\nbreak;\r\ndefault:\r\nWARN(1, "Invalid queue type\n");\r\nret = -EINVAL;\r\n}\r\nif (!ret)\r\nret = call_qop(q, buf_prepare, vb);\r\nif (ret)\r\ndprintk(1, "qbuf: buffer preparation failed: %d\n", ret);\r\nelse\r\nvb->state = VB2_BUF_STATE_PREPARED;\r\nreturn ret;\r\n}\r\nint vb2_prepare_buf(struct vb2_queue *q, struct v4l2_buffer *b)\r\n{\r\nstruct vb2_buffer *vb;\r\nint ret;\r\nif (q->fileio) {\r\ndprintk(1, "%s(): file io in progress\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nif (b->type != q->type) {\r\ndprintk(1, "%s(): invalid buffer type\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (b->index >= q->num_buffers) {\r\ndprintk(1, "%s(): buffer index out of range\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nvb = q->bufs[b->index];\r\nif (NULL == vb) {\r\ndprintk(1, "%s(): buffer is NULL\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (b->memory != q->memory) {\r\ndprintk(1, "%s(): invalid memory type\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (vb->state != VB2_BUF_STATE_DEQUEUED) {\r\ndprintk(1, "%s(): invalid buffer state %d\n", __func__, vb->state);\r\nreturn -EINVAL;\r\n}\r\nret = __buf_prepare(vb, b);\r\nif (ret < 0)\r\nreturn ret;\r\n__fill_v4l2_buffer(vb, b);\r\nreturn 0;\r\n}\r\nint vb2_qbuf(struct vb2_queue *q, struct v4l2_buffer *b)\r\n{\r\nstruct rw_semaphore *mmap_sem = NULL;\r\nstruct vb2_buffer *vb;\r\nint ret = 0;\r\nif (q->memory == V4L2_MEMORY_USERPTR) {\r\nmmap_sem = &current->mm->mmap_sem;\r\ncall_qop(q, wait_prepare, q);\r\ndown_read(mmap_sem);\r\ncall_qop(q, wait_finish, q);\r\n}\r\nif (q->fileio) {\r\ndprintk(1, "qbuf: file io in progress\n");\r\nret = -EBUSY;\r\ngoto unlock;\r\n}\r\nif (b->type != q->type) {\r\ndprintk(1, "qbuf: invalid buffer type\n");\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\nif (b->index >= q->num_buffers) {\r\ndprintk(1, "qbuf: buffer index out of range\n");\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\nvb = q->bufs[b->index];\r\nif (NULL == vb) {\r\ndprintk(1, "qbuf: buffer is NULL\n");\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\nif (b->memory != q->memory) {\r\ndprintk(1, "qbuf: invalid memory type\n");\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\nswitch (vb->state) {\r\ncase VB2_BUF_STATE_DEQUEUED:\r\nret = __buf_prepare(vb, b);\r\nif (ret)\r\ngoto unlock;\r\ncase VB2_BUF_STATE_PREPARED:\r\nbreak;\r\ndefault:\r\ndprintk(1, "qbuf: buffer already in use\n");\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\nlist_add_tail(&vb->queued_entry, &q->queued_list);\r\nvb->state = VB2_BUF_STATE_QUEUED;\r\nif (q->streaming)\r\n__enqueue_in_driver(vb);\r\n__fill_v4l2_buffer(vb, b);\r\ndprintk(1, "qbuf of buffer %d succeeded\n", vb->v4l2_buf.index);\r\nunlock:\r\nif (mmap_sem)\r\nup_read(mmap_sem);\r\nreturn ret;\r\n}\r\nstatic int __vb2_wait_for_done_vb(struct vb2_queue *q, int nonblocking)\r\n{\r\nfor (;;) {\r\nint ret;\r\nif (!q->streaming) {\r\ndprintk(1, "Streaming off, will not wait for buffers\n");\r\nreturn -EINVAL;\r\n}\r\nif (!list_empty(&q->done_list)) {\r\nbreak;\r\n}\r\nif (nonblocking) {\r\ndprintk(1, "Nonblocking and no buffers to dequeue, "\r\n"will not wait\n");\r\nreturn -EAGAIN;\r\n}\r\ncall_qop(q, wait_prepare, q);\r\ndprintk(3, "Will sleep waiting for buffers\n");\r\nret = wait_event_interruptible(q->done_wq,\r\n!list_empty(&q->done_list) || !q->streaming);\r\ncall_qop(q, wait_finish, q);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __vb2_get_done_vb(struct vb2_queue *q, struct vb2_buffer **vb,\r\nint nonblocking)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nret = __vb2_wait_for_done_vb(q, nonblocking);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&q->done_lock, flags);\r\n*vb = list_first_entry(&q->done_list, struct vb2_buffer, done_entry);\r\nlist_del(&(*vb)->done_entry);\r\nspin_unlock_irqrestore(&q->done_lock, flags);\r\nreturn 0;\r\n}\r\nint vb2_wait_for_all_buffers(struct vb2_queue *q)\r\n{\r\nif (!q->streaming) {\r\ndprintk(1, "Streaming off, will not wait for buffers\n");\r\nreturn -EINVAL;\r\n}\r\nwait_event(q->done_wq, !atomic_read(&q->queued_count));\r\nreturn 0;\r\n}\r\nint vb2_dqbuf(struct vb2_queue *q, struct v4l2_buffer *b, bool nonblocking)\r\n{\r\nstruct vb2_buffer *vb = NULL;\r\nint ret;\r\nif (q->fileio) {\r\ndprintk(1, "dqbuf: file io in progress\n");\r\nreturn -EBUSY;\r\n}\r\nif (b->type != q->type) {\r\ndprintk(1, "dqbuf: invalid buffer type\n");\r\nreturn -EINVAL;\r\n}\r\nret = __vb2_get_done_vb(q, &vb, nonblocking);\r\nif (ret < 0) {\r\ndprintk(1, "dqbuf: error getting next done buffer\n");\r\nreturn ret;\r\n}\r\nret = call_qop(q, buf_finish, vb);\r\nif (ret) {\r\ndprintk(1, "dqbuf: buffer finish failed\n");\r\nreturn ret;\r\n}\r\nswitch (vb->state) {\r\ncase VB2_BUF_STATE_DONE:\r\ndprintk(3, "dqbuf: Returning done buffer\n");\r\nbreak;\r\ncase VB2_BUF_STATE_ERROR:\r\ndprintk(3, "dqbuf: Returning done buffer with errors\n");\r\nbreak;\r\ndefault:\r\ndprintk(1, "dqbuf: Invalid buffer state\n");\r\nreturn -EINVAL;\r\n}\r\n__fill_v4l2_buffer(vb, b);\r\nlist_del(&vb->queued_entry);\r\ndprintk(1, "dqbuf of buffer %d, with state %d\n",\r\nvb->v4l2_buf.index, vb->state);\r\nvb->state = VB2_BUF_STATE_DEQUEUED;\r\nreturn 0;\r\n}\r\nstatic void __vb2_queue_cancel(struct vb2_queue *q)\r\n{\r\nunsigned int i;\r\nif (q->streaming)\r\ncall_qop(q, stop_streaming, q);\r\nq->streaming = 0;\r\nINIT_LIST_HEAD(&q->queued_list);\r\nINIT_LIST_HEAD(&q->done_list);\r\natomic_set(&q->queued_count, 0);\r\nwake_up_all(&q->done_wq);\r\nfor (i = 0; i < q->num_buffers; ++i)\r\nq->bufs[i]->state = VB2_BUF_STATE_DEQUEUED;\r\n}\r\nint vb2_streamon(struct vb2_queue *q, enum v4l2_buf_type type)\r\n{\r\nstruct vb2_buffer *vb;\r\nint ret;\r\nif (q->fileio) {\r\ndprintk(1, "streamon: file io in progress\n");\r\nreturn -EBUSY;\r\n}\r\nif (type != q->type) {\r\ndprintk(1, "streamon: invalid stream type\n");\r\nreturn -EINVAL;\r\n}\r\nif (q->streaming) {\r\ndprintk(1, "streamon: already streaming\n");\r\nreturn -EBUSY;\r\n}\r\nlist_for_each_entry(vb, &q->queued_list, queued_entry)\r\n__enqueue_in_driver(vb);\r\nret = call_qop(q, start_streaming, q, atomic_read(&q->queued_count));\r\nif (ret) {\r\ndprintk(1, "streamon: driver refused to start streaming\n");\r\n__vb2_queue_cancel(q);\r\nreturn ret;\r\n}\r\nq->streaming = 1;\r\ndprintk(3, "Streamon successful\n");\r\nreturn 0;\r\n}\r\nint vb2_streamoff(struct vb2_queue *q, enum v4l2_buf_type type)\r\n{\r\nif (q->fileio) {\r\ndprintk(1, "streamoff: file io in progress\n");\r\nreturn -EBUSY;\r\n}\r\nif (type != q->type) {\r\ndprintk(1, "streamoff: invalid stream type\n");\r\nreturn -EINVAL;\r\n}\r\nif (!q->streaming) {\r\ndprintk(1, "streamoff: not streaming\n");\r\nreturn -EINVAL;\r\n}\r\n__vb2_queue_cancel(q);\r\ndprintk(3, "Streamoff successful\n");\r\nreturn 0;\r\n}\r\nstatic int __find_plane_by_offset(struct vb2_queue *q, unsigned long off,\r\nunsigned int *_buffer, unsigned int *_plane)\r\n{\r\nstruct vb2_buffer *vb;\r\nunsigned int buffer, plane;\r\nfor (buffer = 0; buffer < q->num_buffers; ++buffer) {\r\nvb = q->bufs[buffer];\r\nfor (plane = 0; plane < vb->num_planes; ++plane) {\r\nif (vb->v4l2_planes[plane].m.mem_offset == off) {\r\n*_buffer = buffer;\r\n*_plane = plane;\r\nreturn 0;\r\n}\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nint vb2_mmap(struct vb2_queue *q, struct vm_area_struct *vma)\r\n{\r\nunsigned long off = vma->vm_pgoff << PAGE_SHIFT;\r\nstruct vb2_buffer *vb;\r\nunsigned int buffer, plane;\r\nint ret;\r\nif (q->memory != V4L2_MEMORY_MMAP) {\r\ndprintk(1, "Queue is not currently set up for mmap\n");\r\nreturn -EINVAL;\r\n}\r\nif (!(vma->vm_flags & VM_SHARED)) {\r\ndprintk(1, "Invalid vma flags, VM_SHARED needed\n");\r\nreturn -EINVAL;\r\n}\r\nif (V4L2_TYPE_IS_OUTPUT(q->type)) {\r\nif (!(vma->vm_flags & VM_WRITE)) {\r\ndprintk(1, "Invalid vma flags, VM_WRITE needed\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (!(vma->vm_flags & VM_READ)) {\r\ndprintk(1, "Invalid vma flags, VM_READ needed\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nret = __find_plane_by_offset(q, off, &buffer, &plane);\r\nif (ret)\r\nreturn ret;\r\nvb = q->bufs[buffer];\r\nret = call_memop(q, mmap, vb->planes[plane].mem_priv, vma);\r\nif (ret)\r\nreturn ret;\r\ndprintk(3, "Buffer %d, plane %d successfully mapped\n", buffer, plane);\r\nreturn 0;\r\n}\r\nunsigned long vb2_get_unmapped_area(struct vb2_queue *q,\r\nunsigned long addr,\r\nunsigned long len,\r\nunsigned long pgoff,\r\nunsigned long flags)\r\n{\r\nunsigned long off = pgoff << PAGE_SHIFT;\r\nstruct vb2_buffer *vb;\r\nunsigned int buffer, plane;\r\nint ret;\r\nif (q->memory != V4L2_MEMORY_MMAP) {\r\ndprintk(1, "Queue is not currently set up for mmap\n");\r\nreturn -EINVAL;\r\n}\r\nret = __find_plane_by_offset(q, off, &buffer, &plane);\r\nif (ret)\r\nreturn ret;\r\nvb = q->bufs[buffer];\r\nreturn (unsigned long)vb2_plane_vaddr(vb, plane);\r\n}\r\nunsigned int vb2_poll(struct vb2_queue *q, struct file *file, poll_table *wait)\r\n{\r\nunsigned long flags;\r\nunsigned int ret;\r\nstruct vb2_buffer *vb = NULL;\r\nif (q->num_buffers == 0 && q->fileio == NULL) {\r\nif (!V4L2_TYPE_IS_OUTPUT(q->type) && (q->io_modes & VB2_READ)) {\r\nret = __vb2_init_fileio(q, 1);\r\nif (ret)\r\nreturn POLLERR;\r\n}\r\nif (V4L2_TYPE_IS_OUTPUT(q->type) && (q->io_modes & VB2_WRITE)) {\r\nret = __vb2_init_fileio(q, 0);\r\nif (ret)\r\nreturn POLLERR;\r\nreturn POLLOUT | POLLWRNORM;\r\n}\r\n}\r\nif (list_empty(&q->queued_list))\r\nreturn POLLERR;\r\npoll_wait(file, &q->done_wq, wait);\r\nspin_lock_irqsave(&q->done_lock, flags);\r\nif (!list_empty(&q->done_list))\r\nvb = list_first_entry(&q->done_list, struct vb2_buffer,\r\ndone_entry);\r\nspin_unlock_irqrestore(&q->done_lock, flags);\r\nif (vb && (vb->state == VB2_BUF_STATE_DONE\r\n|| vb->state == VB2_BUF_STATE_ERROR)) {\r\nreturn (V4L2_TYPE_IS_OUTPUT(q->type)) ? POLLOUT | POLLWRNORM :\r\nPOLLIN | POLLRDNORM;\r\n}\r\nreturn 0;\r\n}\r\nint vb2_queue_init(struct vb2_queue *q)\r\n{\r\nBUG_ON(!q);\r\nBUG_ON(!q->ops);\r\nBUG_ON(!q->mem_ops);\r\nBUG_ON(!q->type);\r\nBUG_ON(!q->io_modes);\r\nBUG_ON(!q->ops->queue_setup);\r\nBUG_ON(!q->ops->buf_queue);\r\nINIT_LIST_HEAD(&q->queued_list);\r\nINIT_LIST_HEAD(&q->done_list);\r\nspin_lock_init(&q->done_lock);\r\ninit_waitqueue_head(&q->done_wq);\r\nif (q->buf_struct_size == 0)\r\nq->buf_struct_size = sizeof(struct vb2_buffer);\r\nreturn 0;\r\n}\r\nvoid vb2_queue_release(struct vb2_queue *q)\r\n{\r\n__vb2_cleanup_fileio(q);\r\n__vb2_queue_cancel(q);\r\n__vb2_queue_free(q, q->num_buffers);\r\n}\r\nstatic int __vb2_init_fileio(struct vb2_queue *q, int read)\r\n{\r\nstruct vb2_fileio_data *fileio;\r\nint i, ret;\r\nunsigned int count = 0;\r\nif ((read && !(q->io_modes & VB2_READ)) ||\r\n(!read && !(q->io_modes & VB2_WRITE)))\r\nBUG();\r\nif (!q->mem_ops->vaddr)\r\nreturn -EBUSY;\r\nif (q->streaming || q->num_buffers > 0)\r\nreturn -EBUSY;\r\ncount = 1;\r\ndprintk(3, "setting up file io: mode %s, count %d, flags %08x\n",\r\n(read) ? "read" : "write", count, q->io_flags);\r\nfileio = kzalloc(sizeof(struct vb2_fileio_data), GFP_KERNEL);\r\nif (fileio == NULL)\r\nreturn -ENOMEM;\r\nfileio->flags = q->io_flags;\r\nfileio->req.count = count;\r\nfileio->req.memory = V4L2_MEMORY_MMAP;\r\nfileio->req.type = q->type;\r\nret = vb2_reqbufs(q, &fileio->req);\r\nif (ret)\r\ngoto err_kfree;\r\nif (q->bufs[0]->num_planes != 1) {\r\nfileio->req.count = 0;\r\nret = -EBUSY;\r\ngoto err_reqbufs;\r\n}\r\nfor (i = 0; i < q->num_buffers; i++) {\r\nfileio->bufs[i].vaddr = vb2_plane_vaddr(q->bufs[i], 0);\r\nif (fileio->bufs[i].vaddr == NULL)\r\ngoto err_reqbufs;\r\nfileio->bufs[i].size = vb2_plane_size(q->bufs[i], 0);\r\n}\r\nif (read) {\r\nfor (i = 0; i < q->num_buffers; i++) {\r\nstruct v4l2_buffer *b = &fileio->b;\r\nmemset(b, 0, sizeof(*b));\r\nb->type = q->type;\r\nb->memory = q->memory;\r\nb->index = i;\r\nret = vb2_qbuf(q, b);\r\nif (ret)\r\ngoto err_reqbufs;\r\nfileio->bufs[i].queued = 1;\r\n}\r\nret = vb2_streamon(q, q->type);\r\nif (ret)\r\ngoto err_reqbufs;\r\n}\r\nq->fileio = fileio;\r\nreturn ret;\r\nerr_reqbufs:\r\nvb2_reqbufs(q, &fileio->req);\r\nerr_kfree:\r\nkfree(fileio);\r\nreturn ret;\r\n}\r\nstatic int __vb2_cleanup_fileio(struct vb2_queue *q)\r\n{\r\nstruct vb2_fileio_data *fileio = q->fileio;\r\nif (fileio) {\r\nq->fileio = NULL;\r\nvb2_streamoff(q, q->type);\r\nfileio->req.count = 0;\r\nvb2_reqbufs(q, &fileio->req);\r\nkfree(fileio);\r\ndprintk(3, "file io emulator closed\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic size_t __vb2_perform_fileio(struct vb2_queue *q, char __user *data, size_t count,\r\nloff_t *ppos, int nonblock, int read)\r\n{\r\nstruct vb2_fileio_data *fileio;\r\nstruct vb2_fileio_buf *buf;\r\nint ret, index;\r\ndprintk(3, "file io: mode %s, offset %ld, count %zd, %sblocking\n",\r\nread ? "read" : "write", (long)*ppos, count,\r\nnonblock ? "non" : "");\r\nif (!data)\r\nreturn -EINVAL;\r\nif (!q->fileio) {\r\nret = __vb2_init_fileio(q, read);\r\ndprintk(3, "file io: vb2_init_fileio result: %d\n", ret);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfileio = q->fileio;\r\nq->fileio = NULL;\r\nindex = fileio->index;\r\nbuf = &fileio->bufs[index];\r\nif (buf->queued) {\r\nstruct vb2_buffer *vb;\r\nmemset(&fileio->b, 0, sizeof(fileio->b));\r\nfileio->b.type = q->type;\r\nfileio->b.memory = q->memory;\r\nfileio->b.index = index;\r\nret = vb2_dqbuf(q, &fileio->b, nonblock);\r\ndprintk(5, "file io: vb2_dqbuf result: %d\n", ret);\r\nif (ret)\r\ngoto end;\r\nfileio->dq_count += 1;\r\nvb = q->bufs[index];\r\nbuf->size = vb2_get_plane_payload(vb, 0);\r\nbuf->queued = 0;\r\n}\r\nif (buf->pos + count > buf->size) {\r\ncount = buf->size - buf->pos;\r\ndprintk(5, "reducing read count: %zd\n", count);\r\n}\r\ndprintk(3, "file io: copying %zd bytes - buffer %d, offset %u\n",\r\ncount, index, buf->pos);\r\nif (read)\r\nret = copy_to_user(data, buf->vaddr + buf->pos, count);\r\nelse\r\nret = copy_from_user(buf->vaddr + buf->pos, data, count);\r\nif (ret) {\r\ndprintk(3, "file io: error copying data\n");\r\nret = -EFAULT;\r\ngoto end;\r\n}\r\nbuf->pos += count;\r\n*ppos += count;\r\nif (buf->pos == buf->size ||\r\n(!read && (fileio->flags & VB2_FILEIO_WRITE_IMMEDIATELY))) {\r\nif (read && (fileio->flags & VB2_FILEIO_READ_ONCE) &&\r\nfileio->dq_count == 1) {\r\ndprintk(3, "file io: read limit reached\n");\r\nq->fileio = fileio;\r\nreturn __vb2_cleanup_fileio(q);\r\n}\r\nmemset(&fileio->b, 0, sizeof(fileio->b));\r\nfileio->b.type = q->type;\r\nfileio->b.memory = q->memory;\r\nfileio->b.index = index;\r\nfileio->b.bytesused = buf->pos;\r\nret = vb2_qbuf(q, &fileio->b);\r\ndprintk(5, "file io: vb2_dbuf result: %d\n", ret);\r\nif (ret)\r\ngoto end;\r\nbuf->pos = 0;\r\nbuf->queued = 1;\r\nbuf->size = q->bufs[0]->v4l2_planes[0].length;\r\nfileio->q_count += 1;\r\nfileio->index = (index + 1) % q->num_buffers;\r\nif (!read && !q->streaming) {\r\nret = vb2_streamon(q, q->type);\r\nif (ret)\r\ngoto end;\r\n}\r\n}\r\nif (ret == 0)\r\nret = count;\r\nend:\r\nq->fileio = fileio;\r\nreturn ret;\r\n}\r\nsize_t vb2_read(struct vb2_queue *q, char __user *data, size_t count,\r\nloff_t *ppos, int nonblocking)\r\n{\r\nreturn __vb2_perform_fileio(q, data, count, ppos, nonblocking, 1);\r\n}\r\nsize_t vb2_write(struct vb2_queue *q, char __user *data, size_t count,\r\nloff_t *ppos, int nonblocking)\r\n{\r\nreturn __vb2_perform_fileio(q, data, count, ppos, nonblocking, 0);\r\n}
