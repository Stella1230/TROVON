static inline void do_convert(struct linear_priv *data,\r\nunsigned char *dst, unsigned char *src)\r\n{\r\nunsigned int tmp = 0;\r\nunsigned char *p = (unsigned char *)&tmp;\r\nmemcpy(p + data->copy_ofs, src + data->src_ofs, data->copy_bytes);\r\nif (data->cvt_endian)\r\ntmp = swab32(tmp);\r\ntmp ^= data->flip;\r\nmemcpy(dst, p + data->dst_ofs, data->dst_bytes);\r\n}\r\nstatic void convert(struct snd_pcm_plugin *plugin,\r\nconst struct snd_pcm_plugin_channel *src_channels,\r\nstruct snd_pcm_plugin_channel *dst_channels,\r\nsnd_pcm_uframes_t frames)\r\n{\r\nstruct linear_priv *data = (struct linear_priv *)plugin->extra_data;\r\nint channel;\r\nint nchannels = plugin->src_format.channels;\r\nfor (channel = 0; channel < nchannels; ++channel) {\r\nchar *src;\r\nchar *dst;\r\nint src_step, dst_step;\r\nsnd_pcm_uframes_t frames1;\r\nif (!src_channels[channel].enabled) {\r\nif (dst_channels[channel].wanted)\r\nsnd_pcm_area_silence(&dst_channels[channel].area, 0, frames, plugin->dst_format.format);\r\ndst_channels[channel].enabled = 0;\r\ncontinue;\r\n}\r\ndst_channels[channel].enabled = 1;\r\nsrc = src_channels[channel].area.addr + src_channels[channel].area.first / 8;\r\ndst = dst_channels[channel].area.addr + dst_channels[channel].area.first / 8;\r\nsrc_step = src_channels[channel].area.step / 8;\r\ndst_step = dst_channels[channel].area.step / 8;\r\nframes1 = frames;\r\nwhile (frames1-- > 0) {\r\ndo_convert(data, dst, src);\r\nsrc += src_step;\r\ndst += dst_step;\r\n}\r\n}\r\n}\r\nstatic snd_pcm_sframes_t linear_transfer(struct snd_pcm_plugin *plugin,\r\nconst struct snd_pcm_plugin_channel *src_channels,\r\nstruct snd_pcm_plugin_channel *dst_channels,\r\nsnd_pcm_uframes_t frames)\r\n{\r\nif (snd_BUG_ON(!plugin || !src_channels || !dst_channels))\r\nreturn -ENXIO;\r\nif (frames == 0)\r\nreturn 0;\r\n#ifdef CONFIG_SND_DEBUG\r\n{\r\nunsigned int channel;\r\nfor (channel = 0; channel < plugin->src_format.channels; channel++) {\r\nif (snd_BUG_ON(src_channels[channel].area.first % 8 ||\r\nsrc_channels[channel].area.step % 8))\r\nreturn -ENXIO;\r\nif (snd_BUG_ON(dst_channels[channel].area.first % 8 ||\r\ndst_channels[channel].area.step % 8))\r\nreturn -ENXIO;\r\n}\r\n}\r\n#endif\r\nconvert(plugin, src_channels, dst_channels, frames);\r\nreturn frames;\r\n}\r\nstatic void init_data(struct linear_priv *data,\r\nsnd_pcm_format_t src_format, snd_pcm_format_t dst_format)\r\n{\r\nint src_le, dst_le, src_bytes, dst_bytes;\r\nsrc_bytes = snd_pcm_format_width(src_format) / 8;\r\ndst_bytes = snd_pcm_format_width(dst_format) / 8;\r\nsrc_le = snd_pcm_format_little_endian(src_format) > 0;\r\ndst_le = snd_pcm_format_little_endian(dst_format) > 0;\r\ndata->dst_bytes = dst_bytes;\r\ndata->cvt_endian = src_le != dst_le;\r\ndata->copy_bytes = src_bytes < dst_bytes ? src_bytes : dst_bytes;\r\nif (src_le) {\r\ndata->copy_ofs = 4 - data->copy_bytes;\r\ndata->src_ofs = src_bytes - data->copy_bytes;\r\n} else\r\ndata->src_ofs = snd_pcm_format_physical_width(src_format) / 8 -\r\nsrc_bytes;\r\nif (dst_le)\r\ndata->dst_ofs = 4 - data->dst_bytes;\r\nelse\r\ndata->dst_ofs = snd_pcm_format_physical_width(dst_format) / 8 -\r\ndst_bytes;\r\nif (snd_pcm_format_signed(src_format) !=\r\nsnd_pcm_format_signed(dst_format)) {\r\nif (dst_le)\r\ndata->flip = (__force u32)cpu_to_le32(0x80000000);\r\nelse\r\ndata->flip = (__force u32)cpu_to_be32(0x80000000);\r\n}\r\n}\r\nint snd_pcm_plugin_build_linear(struct snd_pcm_substream *plug,\r\nstruct snd_pcm_plugin_format *src_format,\r\nstruct snd_pcm_plugin_format *dst_format,\r\nstruct snd_pcm_plugin **r_plugin)\r\n{\r\nint err;\r\nstruct linear_priv *data;\r\nstruct snd_pcm_plugin *plugin;\r\nif (snd_BUG_ON(!r_plugin))\r\nreturn -ENXIO;\r\n*r_plugin = NULL;\r\nif (snd_BUG_ON(src_format->rate != dst_format->rate))\r\nreturn -ENXIO;\r\nif (snd_BUG_ON(src_format->channels != dst_format->channels))\r\nreturn -ENXIO;\r\nif (snd_BUG_ON(!snd_pcm_format_linear(src_format->format) ||\r\n!snd_pcm_format_linear(dst_format->format)))\r\nreturn -ENXIO;\r\nerr = snd_pcm_plugin_build(plug, "linear format conversion",\r\nsrc_format, dst_format,\r\nsizeof(struct linear_priv), &plugin);\r\nif (err < 0)\r\nreturn err;\r\ndata = (struct linear_priv *)plugin->extra_data;\r\ninit_data(data, src_format->format, dst_format->format);\r\nplugin->transfer = linear_transfer;\r\n*r_plugin = plugin;\r\nreturn 0;\r\n}
