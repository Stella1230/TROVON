int snd_soc_jack_new(struct snd_soc_codec *codec, const char *id, int type,\r\nstruct snd_soc_jack *jack)\r\n{\r\njack->codec = codec;\r\nINIT_LIST_HEAD(&jack->pins);\r\nINIT_LIST_HEAD(&jack->jack_zones);\r\nBLOCKING_INIT_NOTIFIER_HEAD(&jack->notifier);\r\nreturn snd_jack_new(codec->card->snd_card, id, type, &jack->jack);\r\n}\r\nvoid snd_soc_jack_report(struct snd_soc_jack *jack, int status, int mask)\r\n{\r\nstruct snd_soc_codec *codec;\r\nstruct snd_soc_dapm_context *dapm;\r\nstruct snd_soc_jack_pin *pin;\r\nint enable;\r\nint oldstatus;\r\ntrace_snd_soc_jack_report(jack, mask, status);\r\nif (!jack)\r\nreturn;\r\ncodec = jack->codec;\r\ndapm = &codec->dapm;\r\nmutex_lock(&codec->mutex);\r\noldstatus = jack->status;\r\njack->status &= ~mask;\r\njack->status |= status & mask;\r\nif (mask && (jack->status == oldstatus))\r\ngoto out;\r\ntrace_snd_soc_jack_notify(jack, status);\r\nlist_for_each_entry(pin, &jack->pins, list) {\r\nenable = pin->mask & jack->status;\r\nif (pin->invert)\r\nenable = !enable;\r\nif (enable)\r\nsnd_soc_dapm_enable_pin(dapm, pin->pin);\r\nelse\r\nsnd_soc_dapm_disable_pin(dapm, pin->pin);\r\n}\r\nblocking_notifier_call_chain(&jack->notifier, status, jack);\r\nsnd_soc_dapm_sync(dapm);\r\nsnd_jack_report(jack->jack, jack->status);\r\nout:\r\nmutex_unlock(&codec->mutex);\r\n}\r\nint snd_soc_jack_add_zones(struct snd_soc_jack *jack, int count,\r\nstruct snd_soc_jack_zone *zones)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nINIT_LIST_HEAD(&zones[i].list);\r\nlist_add(&(zones[i].list), &jack->jack_zones);\r\n}\r\nreturn 0;\r\n}\r\nint snd_soc_jack_get_type(struct snd_soc_jack *jack, int micbias_voltage)\r\n{\r\nstruct snd_soc_jack_zone *zone;\r\nlist_for_each_entry(zone, &jack->jack_zones, list) {\r\nif (micbias_voltage >= zone->min_mv &&\r\nmicbias_voltage < zone->max_mv)\r\nreturn zone->jack_type;\r\n}\r\nreturn 0;\r\n}\r\nint snd_soc_jack_add_pins(struct snd_soc_jack *jack, int count,\r\nstruct snd_soc_jack_pin *pins)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nif (!pins[i].pin) {\r\nprintk(KERN_ERR "No name for pin %d\n", i);\r\nreturn -EINVAL;\r\n}\r\nif (!pins[i].mask) {\r\nprintk(KERN_ERR "No mask for pin %d (%s)\n", i,\r\npins[i].pin);\r\nreturn -EINVAL;\r\n}\r\nINIT_LIST_HEAD(&pins[i].list);\r\nlist_add(&(pins[i].list), &jack->pins);\r\n}\r\nsnd_soc_dapm_new_widgets(&jack->codec->card->dapm);\r\nsnd_soc_jack_report(jack, 0, 0);\r\nreturn 0;\r\n}\r\nvoid snd_soc_jack_notifier_register(struct snd_soc_jack *jack,\r\nstruct notifier_block *nb)\r\n{\r\nblocking_notifier_chain_register(&jack->notifier, nb);\r\n}\r\nvoid snd_soc_jack_notifier_unregister(struct snd_soc_jack *jack,\r\nstruct notifier_block *nb)\r\n{\r\nblocking_notifier_chain_unregister(&jack->notifier, nb);\r\n}\r\nstatic void snd_soc_jack_gpio_detect(struct snd_soc_jack_gpio *gpio)\r\n{\r\nstruct snd_soc_jack *jack = gpio->jack;\r\nint enable;\r\nint report;\r\nenable = gpio_get_value_cansleep(gpio->gpio);\r\nif (gpio->invert)\r\nenable = !enable;\r\nif (enable)\r\nreport = gpio->report;\r\nelse\r\nreport = 0;\r\nif (gpio->jack_status_check)\r\nreport = gpio->jack_status_check();\r\nsnd_soc_jack_report(jack, report, gpio->report);\r\n}\r\nstatic irqreturn_t gpio_handler(int irq, void *data)\r\n{\r\nstruct snd_soc_jack_gpio *gpio = data;\r\nstruct device *dev = gpio->jack->codec->card->dev;\r\ntrace_snd_soc_jack_irq(gpio->name);\r\nif (device_may_wakeup(dev))\r\npm_wakeup_event(dev, gpio->debounce_time + 50);\r\nschedule_delayed_work(&gpio->work,\r\nmsecs_to_jiffies(gpio->debounce_time));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void gpio_work(struct work_struct *work)\r\n{\r\nstruct snd_soc_jack_gpio *gpio;\r\ngpio = container_of(work, struct snd_soc_jack_gpio, work.work);\r\nsnd_soc_jack_gpio_detect(gpio);\r\n}\r\nint snd_soc_jack_add_gpios(struct snd_soc_jack *jack, int count,\r\nstruct snd_soc_jack_gpio *gpios)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < count; i++) {\r\nif (!gpio_is_valid(gpios[i].gpio)) {\r\nprintk(KERN_ERR "Invalid gpio %d\n",\r\ngpios[i].gpio);\r\nret = -EINVAL;\r\ngoto undo;\r\n}\r\nif (!gpios[i].name) {\r\nprintk(KERN_ERR "No name for gpio %d\n",\r\ngpios[i].gpio);\r\nret = -EINVAL;\r\ngoto undo;\r\n}\r\nret = gpio_request(gpios[i].gpio, gpios[i].name);\r\nif (ret)\r\ngoto undo;\r\nret = gpio_direction_input(gpios[i].gpio);\r\nif (ret)\r\ngoto err;\r\nINIT_DELAYED_WORK(&gpios[i].work, gpio_work);\r\ngpios[i].jack = jack;\r\nret = request_any_context_irq(gpio_to_irq(gpios[i].gpio),\r\ngpio_handler,\r\nIRQF_TRIGGER_RISING |\r\nIRQF_TRIGGER_FALLING,\r\ngpios[i].name,\r\n&gpios[i]);\r\nif (ret < 0)\r\ngoto err;\r\nif (gpios[i].wake) {\r\nret = irq_set_irq_wake(gpio_to_irq(gpios[i].gpio), 1);\r\nif (ret != 0)\r\nprintk(KERN_ERR\r\n"Failed to mark GPIO %d as wake source: %d\n",\r\ngpios[i].gpio, ret);\r\n}\r\ngpio_export(gpios[i].gpio, false);\r\nsnd_soc_jack_gpio_detect(&gpios[i]);\r\n}\r\nreturn 0;\r\nerr:\r\ngpio_free(gpios[i].gpio);\r\nundo:\r\nsnd_soc_jack_free_gpios(jack, i, gpios);\r\nreturn ret;\r\n}\r\nvoid snd_soc_jack_free_gpios(struct snd_soc_jack *jack, int count,\r\nstruct snd_soc_jack_gpio *gpios)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\ngpio_unexport(gpios[i].gpio);\r\nfree_irq(gpio_to_irq(gpios[i].gpio), &gpios[i]);\r\ncancel_delayed_work_sync(&gpios[i].work);\r\ngpio_free(gpios[i].gpio);\r\ngpios[i].jack = NULL;\r\n}\r\n}
