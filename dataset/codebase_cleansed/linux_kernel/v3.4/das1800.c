static int __init driver_das1800_init_module(void)\r\n{\r\nreturn comedi_driver_register(&driver_das1800);\r\n}\r\nstatic void __exit driver_das1800_cleanup_module(void)\r\n{\r\ncomedi_driver_unregister(&driver_das1800);\r\n}\r\nstatic int das1800_init_dma(struct comedi_device *dev, unsigned int dma0,\r\nunsigned int dma1)\r\n{\r\nunsigned long flags;\r\nif (dev->irq && dma0) {\r\nswitch ((dma0 & 0x7) | (dma1 << 4)) {\r\ncase 0x5:\r\ndevpriv->dma_bits |= DMA_CH5;\r\nbreak;\r\ncase 0x6:\r\ndevpriv->dma_bits |= DMA_CH6;\r\nbreak;\r\ncase 0x7:\r\ndevpriv->dma_bits |= DMA_CH7;\r\nbreak;\r\ncase 0x65:\r\ndevpriv->dma_bits |= DMA_CH5_CH6;\r\nbreak;\r\ncase 0x76:\r\ndevpriv->dma_bits |= DMA_CH6_CH7;\r\nbreak;\r\ncase 0x57:\r\ndevpriv->dma_bits |= DMA_CH7_CH5;\r\nbreak;\r\ndefault:\r\ndev_err(dev->hw_dev, " only supports dma channels 5 through 7\n"\r\n" Dual dma only allows the following combinations:\n"\r\n" dma 5,6 / 6,7 / or 7,5\n");\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nif (request_dma(dma0, driver_das1800.driver_name)) {\r\ndev_err(dev->hw_dev, "failed to allocate dma channel %i\n",\r\ndma0);\r\nreturn -EINVAL;\r\n}\r\ndevpriv->dma0 = dma0;\r\ndevpriv->dma_current = dma0;\r\nif (dma1) {\r\nif (request_dma(dma1, driver_das1800.driver_name)) {\r\ndev_err(dev->hw_dev, "failed to allocate dma channel %i\n",\r\ndma1);\r\nreturn -EINVAL;\r\n}\r\ndevpriv->dma1 = dma1;\r\n}\r\ndevpriv->ai_buf0 = kmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);\r\nif (devpriv->ai_buf0 == NULL)\r\nreturn -ENOMEM;\r\ndevpriv->dma_current_buf = devpriv->ai_buf0;\r\nif (dma1) {\r\ndevpriv->ai_buf1 =\r\nkmalloc(DMA_BUF_SIZE, GFP_KERNEL | GFP_DMA);\r\nif (devpriv->ai_buf1 == NULL)\r\nreturn -ENOMEM;\r\n}\r\nflags = claim_dma_lock();\r\ndisable_dma(devpriv->dma0);\r\nset_dma_mode(devpriv->dma0, DMA_MODE_READ);\r\nif (dma1) {\r\ndisable_dma(devpriv->dma1);\r\nset_dma_mode(devpriv->dma1, DMA_MODE_READ);\r\n}\r\nrelease_dma_lock(flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int das1800_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct comedi_subdevice *s;\r\nunsigned long iobase = it->options[0];\r\nunsigned int irq = it->options[1];\r\nunsigned int dma0 = it->options[2];\r\nunsigned int dma1 = it->options[3];\r\nunsigned long iobase2;\r\nint board;\r\nint retval;\r\nif (alloc_private(dev, sizeof(struct das1800_private)) < 0)\r\nreturn -ENOMEM;\r\nprintk(KERN_DEBUG "comedi%d: %s: io 0x%lx", dev->minor,\r\ndriver_das1800.driver_name, iobase);\r\nif (irq) {\r\nprintk(KERN_CONT ", irq %u", irq);\r\nif (dma0) {\r\nprintk(KERN_CONT ", dma %u", dma0);\r\nif (dma1)\r\nprintk(KERN_CONT " and %u", dma1);\r\n}\r\n}\r\nprintk(KERN_CONT "\n");\r\nif (iobase == 0) {\r\ndev_err(dev->hw_dev, "io base address required\n");\r\nreturn -EINVAL;\r\n}\r\nif (!request_region(iobase, DAS1800_SIZE, driver_das1800.driver_name)) {\r\nprintk\r\n(" I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n",\r\niobase, iobase + DAS1800_SIZE - 1);\r\nreturn -EIO;\r\n}\r\ndev->iobase = iobase;\r\nboard = das1800_probe(dev);\r\nif (board < 0) {\r\ndev_err(dev->hw_dev, "unable to determine board type\n");\r\nreturn -ENODEV;\r\n}\r\ndev->board_ptr = das1800_boards + board;\r\ndev->board_name = thisboard->name;\r\nif (thisboard->ao_ability == 2) {\r\niobase2 = iobase + IOBASE2;\r\nif (!request_region(iobase2, DAS1800_SIZE,\r\ndriver_das1800.driver_name)) {\r\nprintk\r\n(" I/O port conflict: failed to allocate ports 0x%lx to 0x%lx\n",\r\niobase2, iobase2 + DAS1800_SIZE - 1);\r\nreturn -EIO;\r\n}\r\ndevpriv->iobase2 = iobase2;\r\n}\r\nif (irq) {\r\nif (request_irq(irq, das1800_interrupt, 0,\r\ndriver_das1800.driver_name, dev)) {\r\ndev_dbg(dev->hw_dev, "unable to allocate irq %u\n",\r\nirq);\r\nreturn -EINVAL;\r\n}\r\n}\r\ndev->irq = irq;\r\nswitch (irq) {\r\ncase 0:\r\nbreak;\r\ncase 3:\r\ndevpriv->irq_dma_bits |= 0x8;\r\nbreak;\r\ncase 5:\r\ndevpriv->irq_dma_bits |= 0x10;\r\nbreak;\r\ncase 7:\r\ndevpriv->irq_dma_bits |= 0x18;\r\nbreak;\r\ncase 10:\r\ndevpriv->irq_dma_bits |= 0x28;\r\nbreak;\r\ncase 11:\r\ndevpriv->irq_dma_bits |= 0x30;\r\nbreak;\r\ncase 15:\r\ndevpriv->irq_dma_bits |= 0x38;\r\nbreak;\r\ndefault:\r\ndev_err(dev->hw_dev, "irq out of range\n");\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nretval = das1800_init_dma(dev, dma0, dma1);\r\nif (retval < 0)\r\nreturn retval;\r\nif (devpriv->ai_buf0 == NULL) {\r\ndevpriv->ai_buf0 =\r\nkmalloc(FIFO_SIZE * sizeof(uint16_t), GFP_KERNEL);\r\nif (devpriv->ai_buf0 == NULL)\r\nreturn -ENOMEM;\r\n}\r\nif (alloc_subdevices(dev, 4) < 0)\r\nreturn -ENOMEM;\r\ns = dev->subdevices + 0;\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_GROUND | SDF_CMD_READ;\r\nif (thisboard->common)\r\ns->subdev_flags |= SDF_COMMON;\r\ns->n_chan = thisboard->qram_len;\r\ns->len_chanlist = thisboard->qram_len;\r\ns->maxdata = (1 << thisboard->resolution) - 1;\r\ns->range_table = thisboard->range_ai;\r\ns->do_cmd = das1800_ai_do_cmd;\r\ns->do_cmdtest = das1800_ai_do_cmdtest;\r\ns->insn_read = das1800_ai_rinsn;\r\ns->poll = das1800_ai_poll;\r\ns->cancel = das1800_cancel;\r\ns = dev->subdevices + 1;\r\nif (thisboard->ao_ability == 1) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = thisboard->ao_n_chan;\r\ns->maxdata = (1 << thisboard->resolution) - 1;\r\ns->range_table = &range_ao_1;\r\ns->insn_write = das1800_ao_winsn;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = dev->subdevices + 2;\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 4;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = das1800_di_rbits;\r\ns = dev->subdevices + 3;\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = thisboard->do_n_chan;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = das1800_do_wbits;\r\ndas1800_cancel(dev, dev->read_subdev);\r\noutb(devpriv->do_bits, dev->iobase + DAS1800_DIGITAL);\r\nif (thisboard->ao_ability == 1) {\r\noutb(DAC(thisboard->ao_n_chan - 1),\r\ndev->iobase + DAS1800_SELECT);\r\noutw(devpriv->ao_update_bits, dev->iobase + DAS1800_DAC);\r\n}\r\nreturn 0;\r\n}\r\nstatic int das1800_detach(struct comedi_device *dev)\r\n{\r\nif (dev->iobase)\r\nrelease_region(dev->iobase, DAS1800_SIZE);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (dev->private) {\r\nif (devpriv->iobase2)\r\nrelease_region(devpriv->iobase2, DAS1800_SIZE);\r\nif (devpriv->dma0)\r\nfree_dma(devpriv->dma0);\r\nif (devpriv->dma1)\r\nfree_dma(devpriv->dma1);\r\nkfree(devpriv->ai_buf0);\r\nkfree(devpriv->ai_buf1);\r\n}\r\ndev_dbg(dev->hw_dev, "comedi%d: %s: remove\n", dev->minor,\r\ndriver_das1800.driver_name);\r\nreturn 0;\r\n}\r\nstatic int das1800_probe(struct comedi_device *dev)\r\n{\r\nint id;\r\nint board;\r\nid = (inb(dev->iobase + DAS1800_DIGITAL) >> 4) & 0xf;\r\nboard = ((struct das1800_board *)dev->board_ptr) - das1800_boards;\r\nswitch (id) {\r\ncase 0x3:\r\nif (board == das1801st_da || board == das1802st_da ||\r\nboard == das1701st_da || board == das1702st_da) {\r\ndev_dbg(dev->hw_dev, "Board model: %s\n",\r\ndas1800_boards[board].name);\r\nreturn board;\r\n}\r\nprintk\r\n(" Board model (probed, not recommended): das-1800st-da series\n");\r\nreturn das1801st;\r\nbreak;\r\ncase 0x4:\r\nif (board == das1802hr_da || board == das1702hr_da) {\r\ndev_dbg(dev->hw_dev, "Board model: %s\n",\r\ndas1800_boards[board].name);\r\nreturn board;\r\n}\r\nprintk\r\n(" Board model (probed, not recommended): das-1802hr-da\n");\r\nreturn das1802hr;\r\nbreak;\r\ncase 0x5:\r\nif (board == das1801ao || board == das1802ao ||\r\nboard == das1701ao || board == das1702ao) {\r\ndev_dbg(dev->hw_dev, "Board model: %s\n",\r\ndas1800_boards[board].name);\r\nreturn board;\r\n}\r\nprintk\r\n(" Board model (probed, not recommended): das-1800ao series\n");\r\nreturn das1801ao;\r\nbreak;\r\ncase 0x6:\r\nif (board == das1802hr || board == das1702hr) {\r\ndev_dbg(dev->hw_dev, "Board model: %s\n",\r\ndas1800_boards[board].name);\r\nreturn board;\r\n}\r\nprintk\r\n(" Board model (probed, not recommended): das-1802hr\n");\r\nreturn das1802hr;\r\nbreak;\r\ncase 0x7:\r\nif (board == das1801st || board == das1802st ||\r\nboard == das1701st || board == das1702st) {\r\ndev_dbg(dev->hw_dev, "Board model: %s\n",\r\ndas1800_boards[board].name);\r\nreturn board;\r\n}\r\nprintk\r\n(" Board model (probed, not recommended): das-1800st series\n");\r\nreturn das1801st;\r\nbreak;\r\ncase 0x8:\r\nif (board == das1801hc || board == das1802hc) {\r\ndev_dbg(dev->hw_dev, "Board model: %s\n",\r\ndas1800_boards[board].name);\r\nreturn board;\r\n}\r\nprintk\r\n(" Board model (probed, not recommended): das-1800hc series\n");\r\nreturn das1801hc;\r\nbreak;\r\ndefault:\r\nprintk\r\n(" Board model: probe returned 0x%x (unknown, please report)\n",\r\nid);\r\nreturn board;\r\nbreak;\r\n}\r\nreturn -1;\r\n}\r\nstatic int das1800_ai_poll(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndas1800_ai_handler(dev);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn s->async->buf_write_count - s->async->buf_read_count;\r\n}\r\nstatic irqreturn_t das1800_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nunsigned int status;\r\nif (dev->attached == 0) {\r\ncomedi_error(dev, "premature interrupt");\r\nreturn IRQ_HANDLED;\r\n}\r\nspin_lock(&dev->spinlock);\r\nstatus = inb(dev->iobase + DAS1800_STATUS);\r\nif (!(status & INT)) {\r\nspin_unlock(&dev->spinlock);\r\nreturn IRQ_NONE;\r\n}\r\noutb(CLEAR_INTR_MASK & ~INT, dev->iobase + DAS1800_STATUS);\r\ndas1800_ai_handler(dev);\r\nspin_unlock(&dev->spinlock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void das1800_ai_handler(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s = dev->subdevices + 0;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int status = inb(dev->iobase + DAS1800_STATUS);\r\nasync->events = 0;\r\noutb(ADC, dev->iobase + DAS1800_SELECT);\r\nif (devpriv->irq_dma_bits & DMA_ENABLED) {\r\ndas1800_handle_dma(dev, s, status);\r\n} else if (status & FHF) {\r\ndas1800_handle_fifo_half_full(dev, s);\r\n} else if (status & FNE) {\r\ndas1800_handle_fifo_not_empty(dev, s);\r\n}\r\nasync->events |= COMEDI_CB_BLOCK;\r\nif (status & OVF) {\r\noutb(CLEAR_INTR_MASK & ~OVF, dev->iobase + DAS1800_STATUS);\r\ncomedi_error(dev, "DAS1800 FIFO overflow");\r\ndas1800_cancel(dev, s);\r\nasync->events |= COMEDI_CB_ERROR | COMEDI_CB_EOA;\r\ncomedi_event(dev, s);\r\nreturn;\r\n}\r\nif (status & CT0TC) {\r\noutb(CLEAR_INTR_MASK & ~CT0TC, dev->iobase + DAS1800_STATUS);\r\nif (devpriv->irq_dma_bits & DMA_ENABLED)\r\ndas1800_flush_dma(dev, s);\r\nelse\r\ndas1800_handle_fifo_not_empty(dev, s);\r\ndas1800_cancel(dev, s);\r\nasync->events |= COMEDI_CB_EOA;\r\n} else if (cmd->stop_src == TRIG_COUNT && devpriv->count == 0) {\r\ndas1800_cancel(dev, s);\r\nasync->events |= COMEDI_CB_EOA;\r\n}\r\ncomedi_event(dev, s);\r\nreturn;\r\n}\r\nstatic void das1800_handle_dma(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, unsigned int status)\r\n{\r\nunsigned long flags;\r\nconst int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;\r\nflags = claim_dma_lock();\r\ndas1800_flush_dma_channel(dev, s, devpriv->dma_current,\r\ndevpriv->dma_current_buf);\r\nset_dma_addr(devpriv->dma_current,\r\nvirt_to_bus(devpriv->dma_current_buf));\r\nset_dma_count(devpriv->dma_current, devpriv->dma_transfer_size);\r\nenable_dma(devpriv->dma_current);\r\nrelease_dma_lock(flags);\r\nif (status & DMATC) {\r\noutb(CLEAR_INTR_MASK & ~DMATC, dev->iobase + DAS1800_STATUS);\r\nif (dual_dma) {\r\nif (devpriv->dma_current == devpriv->dma0) {\r\ndevpriv->dma_current = devpriv->dma1;\r\ndevpriv->dma_current_buf = devpriv->ai_buf1;\r\n} else {\r\ndevpriv->dma_current = devpriv->dma0;\r\ndevpriv->dma_current_buf = devpriv->ai_buf0;\r\n}\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic inline uint16_t munge_bipolar_sample(const struct comedi_device *dev,\r\nuint16_t sample)\r\n{\r\nsample += 1 << (thisboard->resolution - 1);\r\nreturn sample;\r\n}\r\nstatic void munge_data(struct comedi_device *dev, uint16_t * array,\r\nunsigned int num_elements)\r\n{\r\nunsigned int i;\r\nint unipolar;\r\nunipolar = inb(dev->iobase + DAS1800_CONTROL_C) & UB;\r\nif (!unipolar) {\r\nfor (i = 0; i < num_elements; i++)\r\narray[i] = munge_bipolar_sample(dev, array[i]);\r\n}\r\n}\r\nstatic void das1800_flush_dma_channel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int channel, uint16_t *buffer)\r\n{\r\nunsigned int num_bytes, num_samples;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\ndisable_dma(channel);\r\nclear_dma_ff(channel);\r\nnum_bytes = devpriv->dma_transfer_size - get_dma_residue(channel);\r\nnum_samples = num_bytes / sizeof(short);\r\nif (cmd->stop_src == TRIG_COUNT && devpriv->count < num_samples)\r\nnum_samples = devpriv->count;\r\nmunge_data(dev, buffer, num_samples);\r\ncfc_write_array_to_buffer(s, buffer, num_bytes);\r\nif (s->async->cmd.stop_src == TRIG_COUNT)\r\ndevpriv->count -= num_samples;\r\nreturn;\r\n}\r\nstatic void das1800_flush_dma(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned long flags;\r\nconst int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;\r\nflags = claim_dma_lock();\r\ndas1800_flush_dma_channel(dev, s, devpriv->dma_current,\r\ndevpriv->dma_current_buf);\r\nif (dual_dma) {\r\nif (devpriv->dma_current == devpriv->dma0) {\r\ndevpriv->dma_current = devpriv->dma1;\r\ndevpriv->dma_current_buf = devpriv->ai_buf1;\r\n} else {\r\ndevpriv->dma_current = devpriv->dma0;\r\ndevpriv->dma_current_buf = devpriv->ai_buf0;\r\n}\r\ndas1800_flush_dma_channel(dev, s, devpriv->dma_current,\r\ndevpriv->dma_current_buf);\r\n}\r\nrelease_dma_lock(flags);\r\ndas1800_handle_fifo_not_empty(dev, s);\r\nreturn;\r\n}\r\nstatic void das1800_handle_fifo_half_full(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nint numPoints = 0;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nnumPoints = FIFO_SIZE / 2;\r\nif (cmd->stop_src == TRIG_COUNT && devpriv->count < numPoints)\r\nnumPoints = devpriv->count;\r\ninsw(dev->iobase + DAS1800_FIFO, devpriv->ai_buf0, numPoints);\r\nmunge_data(dev, devpriv->ai_buf0, numPoints);\r\ncfc_write_array_to_buffer(s, devpriv->ai_buf0,\r\nnumPoints * sizeof(devpriv->ai_buf0[0]));\r\nif (cmd->stop_src == TRIG_COUNT)\r\ndevpriv->count -= numPoints;\r\nreturn;\r\n}\r\nstatic void das1800_handle_fifo_not_empty(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nshort dpnt;\r\nint unipolar;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunipolar = inb(dev->iobase + DAS1800_CONTROL_C) & UB;\r\nwhile (inb(dev->iobase + DAS1800_STATUS) & FNE) {\r\nif (cmd->stop_src == TRIG_COUNT && devpriv->count == 0)\r\nbreak;\r\ndpnt = inw(dev->iobase + DAS1800_FIFO);\r\nif (!unipolar)\r\n;\r\ndpnt = munge_bipolar_sample(dev, dpnt);\r\ncfc_write_to_buffer(s, dpnt);\r\nif (cmd->stop_src == TRIG_COUNT)\r\ndevpriv->count--;\r\n}\r\nreturn;\r\n}\r\nstatic int das1800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\noutb(0x0, dev->iobase + DAS1800_STATUS);\r\noutb(0x0, dev->iobase + DAS1800_CONTROL_B);\r\noutb(0x0, dev->iobase + DAS1800_CONTROL_A);\r\nif (devpriv->dma0)\r\ndisable_dma(devpriv->dma0);\r\nif (devpriv->dma1)\r\ndisable_dma(devpriv->dma1);\r\nreturn 0;\r\n}\r\nstatic int das1800_ai_do_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp;\r\nunsigned int tmp_arg;\r\nint i;\r\nint unipolar;\r\ntmp = cmd->start_src;\r\ncmd->start_src &= TRIG_NOW | TRIG_EXT;\r\nif (!cmd->start_src || tmp != cmd->start_src)\r\nerr++;\r\ntmp = cmd->scan_begin_src;\r\ncmd->scan_begin_src &= TRIG_FOLLOW | TRIG_TIMER | TRIG_EXT;\r\nif (!cmd->scan_begin_src || tmp != cmd->scan_begin_src)\r\nerr++;\r\ntmp = cmd->convert_src;\r\ncmd->convert_src &= TRIG_TIMER | TRIG_EXT;\r\nif (!cmd->convert_src || tmp != cmd->convert_src)\r\nerr++;\r\ntmp = cmd->scan_end_src;\r\ncmd->scan_end_src &= TRIG_COUNT;\r\nif (!cmd->scan_end_src || tmp != cmd->scan_end_src)\r\nerr++;\r\ntmp = cmd->stop_src;\r\ncmd->stop_src &= TRIG_COUNT | TRIG_EXT | TRIG_NONE;\r\nif (!cmd->stop_src || tmp != cmd->stop_src)\r\nerr++;\r\nif (err)\r\nreturn 1;\r\nif (cmd->start_src != TRIG_NOW && cmd->start_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->scan_begin_src != TRIG_FOLLOW &&\r\ncmd->scan_begin_src != TRIG_TIMER &&\r\ncmd->scan_begin_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->convert_src != TRIG_TIMER && cmd->convert_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->stop_src != TRIG_COUNT &&\r\ncmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)\r\nerr++;\r\nif (cmd->scan_begin_src != TRIG_FOLLOW &&\r\ncmd->convert_src != TRIG_TIMER)\r\nerr++;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_arg != 0) {\r\ncmd->start_arg = 0;\r\nerr++;\r\n}\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (cmd->convert_arg < thisboard->ai_speed) {\r\ncmd->convert_arg = thisboard->ai_speed;\r\nerr++;\r\n}\r\n}\r\nif (!cmd->chanlist_len) {\r\ncmd->chanlist_len = 1;\r\nerr++;\r\n}\r\nif (cmd->scan_end_arg != cmd->chanlist_len) {\r\ncmd->scan_end_arg = cmd->chanlist_len;\r\nerr++;\r\n}\r\nswitch (cmd->stop_src) {\r\ncase TRIG_COUNT:\r\nif (!cmd->stop_arg) {\r\ncmd->stop_arg = 1;\r\nerr++;\r\n}\r\nbreak;\r\ncase TRIG_NONE:\r\nif (cmd->stop_arg != 0) {\r\ncmd->stop_arg = 0;\r\nerr++;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nif (cmd->scan_begin_src == TRIG_FOLLOW) {\r\ntmp_arg = cmd->convert_arg;\r\ni8253_cascade_ns_to_timer_2div(TIMER_BASE,\r\n&(devpriv->divisor1),\r\n&(devpriv->divisor2),\r\n&(cmd->convert_arg),\r\ncmd->\r\nflags & TRIG_ROUND_MASK);\r\nif (tmp_arg != cmd->convert_arg)\r\nerr++;\r\n}\r\nelse {\r\ntmp_arg = cmd->convert_arg;\r\ncmd->convert_arg =\r\nburst_convert_arg(cmd->convert_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (tmp_arg != cmd->convert_arg)\r\nerr++;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nif (cmd->convert_arg * cmd->chanlist_len >\r\ncmd->scan_begin_arg) {\r\ncmd->scan_begin_arg =\r\ncmd->convert_arg *\r\ncmd->chanlist_len;\r\nerr++;\r\n}\r\ntmp_arg = cmd->scan_begin_arg;\r\ni8253_cascade_ns_to_timer_2div(TIMER_BASE,\r\n&(devpriv->\r\ndivisor1),\r\n&(devpriv->\r\ndivisor2),\r\n&(cmd->\r\nscan_begin_arg),\r\ncmd->\r\nflags &\r\nTRIG_ROUND_MASK);\r\nif (tmp_arg != cmd->scan_begin_arg)\r\nerr++;\r\n}\r\n}\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist) {\r\nunipolar = CR_RANGE(cmd->chanlist[0]) & UNIPOLAR;\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nif (unipolar != (CR_RANGE(cmd->chanlist[i]) & UNIPOLAR)) {\r\ncomedi_error(dev,\r\n"unipolar and bipolar ranges cannot be mixed in the chanlist");\r\nerr++;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int control_a_bits(struct comedi_cmd cmd)\r\n{\r\nint control_a;\r\ncontrol_a = FFEN;\r\nif (cmd.stop_src == TRIG_EXT)\r\ncontrol_a |= ATEN;\r\nswitch (cmd.start_src) {\r\ncase TRIG_EXT:\r\ncontrol_a |= TGEN | CGSL;\r\nbreak;\r\ncase TRIG_NOW:\r\ncontrol_a |= CGEN;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn control_a;\r\n}\r\nstatic int control_c_bits(struct comedi_cmd cmd)\r\n{\r\nint control_c;\r\nint aref;\r\naref = CR_AREF(cmd.chanlist[0]);\r\ncontrol_c = UQEN;\r\nif (aref != AREF_DIFF)\r\ncontrol_c |= SD;\r\nif (aref == AREF_COMMON)\r\ncontrol_c |= CMEN;\r\nif (CR_RANGE(cmd.chanlist[0]) & UNIPOLAR)\r\ncontrol_c |= UB;\r\nswitch (cmd.scan_begin_src) {\r\ncase TRIG_FOLLOW:\r\nswitch (cmd.convert_src) {\r\ncase TRIG_TIMER:\r\ncontrol_c |= IPCLK;\r\nbreak;\r\ncase TRIG_EXT:\r\ncontrol_c |= XPCLK;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase TRIG_TIMER:\r\ncontrol_c |= BMDE | IPCLK;\r\nbreak;\r\ncase TRIG_EXT:\r\ncontrol_c |= BMDE | XPCLK;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn control_c;\r\n}\r\nstatic int setup_counters(struct comedi_device *dev, struct comedi_cmd cmd)\r\n{\r\nswitch (cmd.scan_begin_src) {\r\ncase TRIG_FOLLOW:\r\nif (cmd.convert_src == TRIG_TIMER) {\r\ni8253_cascade_ns_to_timer_2div(TIMER_BASE,\r\n&(devpriv->divisor1),\r\n&(devpriv->divisor2),\r\n&(cmd.convert_arg),\r\ncmd.\r\nflags & TRIG_ROUND_MASK);\r\nif (das1800_set_frequency(dev) < 0)\r\nreturn -1;\r\n}\r\nbreak;\r\ncase TRIG_TIMER:\r\ni8253_cascade_ns_to_timer_2div(TIMER_BASE, &(devpriv->divisor1),\r\n&(devpriv->divisor2),\r\n&(cmd.scan_begin_arg),\r\ncmd.flags & TRIG_ROUND_MASK);\r\nif (das1800_set_frequency(dev) < 0)\r\nreturn -1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (cmd.stop_src == TRIG_EXT) {\r\ni8254_load(dev->iobase + DAS1800_COUNTER, 0, 0, 1, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic void setup_dma(struct comedi_device *dev, struct comedi_cmd cmd)\r\n{\r\nunsigned long lock_flags;\r\nconst int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;\r\nif ((devpriv->irq_dma_bits & DMA_ENABLED) == 0)\r\nreturn;\r\ndevpriv->dma_transfer_size = suggest_transfer_size(&cmd);\r\nlock_flags = claim_dma_lock();\r\ndisable_dma(devpriv->dma0);\r\nclear_dma_ff(devpriv->dma0);\r\nset_dma_addr(devpriv->dma0, virt_to_bus(devpriv->ai_buf0));\r\nset_dma_count(devpriv->dma0, devpriv->dma_transfer_size);\r\ndevpriv->dma_current = devpriv->dma0;\r\ndevpriv->dma_current_buf = devpriv->ai_buf0;\r\nenable_dma(devpriv->dma0);\r\nif (dual_dma) {\r\ndisable_dma(devpriv->dma1);\r\nclear_dma_ff(devpriv->dma1);\r\nset_dma_addr(devpriv->dma1, virt_to_bus(devpriv->ai_buf1));\r\nset_dma_count(devpriv->dma1, devpriv->dma_transfer_size);\r\nenable_dma(devpriv->dma1);\r\n}\r\nrelease_dma_lock(lock_flags);\r\nreturn;\r\n}\r\nstatic void program_chanlist(struct comedi_device *dev, struct comedi_cmd cmd)\r\n{\r\nint i, n, chan_range;\r\nunsigned long irq_flags;\r\nconst int range_mask = 0x3;\r\nconst int range_bitshift = 8;\r\nn = cmd.chanlist_len;\r\nspin_lock_irqsave(&dev->spinlock, irq_flags);\r\noutb(QRAM, dev->iobase + DAS1800_SELECT);\r\noutb(n - 1, dev->iobase + DAS1800_QRAM_ADDRESS);\r\nfor (i = 0; i < n; i++) {\r\nchan_range =\r\nCR_CHAN(cmd.\r\nchanlist[i]) | ((CR_RANGE(cmd.chanlist[i]) &\r\nrange_mask) << range_bitshift);\r\noutw(chan_range, dev->iobase + DAS1800_QRAM);\r\n}\r\noutb(n - 1, dev->iobase + DAS1800_QRAM_ADDRESS);\r\nspin_unlock_irqrestore(&dev->spinlock, irq_flags);\r\nreturn;\r\n}\r\nstatic int das1800_ai_do_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nint ret;\r\nint control_a, control_c;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd cmd = async->cmd;\r\nif (!dev->irq) {\r\ncomedi_error(dev,\r\n"no irq assigned for das-1800, cannot do hardware conversions");\r\nreturn -1;\r\n}\r\nif (cmd.flags & (TRIG_WAKE_EOS | TRIG_RT))\r\ndevpriv->irq_dma_bits &= ~DMA_ENABLED;\r\nelse\r\ndevpriv->irq_dma_bits |= devpriv->dma_bits;\r\nif (cmd.flags & TRIG_WAKE_EOS) {\r\ndevpriv->irq_dma_bits &= ~FIMD;\r\n} else {\r\ndevpriv->irq_dma_bits |= FIMD;\r\n}\r\nif (cmd.stop_src == TRIG_COUNT)\r\ndevpriv->count = cmd.stop_arg * cmd.chanlist_len;\r\ndas1800_cancel(dev, s);\r\ncontrol_a = control_a_bits(cmd);\r\ncontrol_c = control_c_bits(cmd);\r\nprogram_chanlist(dev, cmd);\r\nret = setup_counters(dev, cmd);\r\nif (ret < 0) {\r\ncomedi_error(dev, "Error setting up counters");\r\nreturn ret;\r\n}\r\nsetup_dma(dev, cmd);\r\noutb(control_c, dev->iobase + DAS1800_CONTROL_C);\r\nif (control_c & BMDE) {\r\noutb(cmd.convert_arg / 1000 - 1,\r\ndev->iobase + DAS1800_BURST_RATE);\r\noutb(cmd.chanlist_len - 1, dev->iobase + DAS1800_BURST_LENGTH);\r\n}\r\noutb(devpriv->irq_dma_bits, dev->iobase + DAS1800_CONTROL_B);\r\noutb(control_a, dev->iobase + DAS1800_CONTROL_A);\r\noutb(CVEN, dev->iobase + DAS1800_STATUS);\r\nreturn 0;\r\n}\r\nstatic int das1800_ai_rinsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint i, n;\r\nint chan, range, aref, chan_range;\r\nint timeout = 1000;\r\nshort dpnt;\r\nint conv_flags = 0;\r\nunsigned long irq_flags;\r\naref = CR_AREF(insn->chanspec);\r\nconv_flags |= UQEN;\r\nif (aref != AREF_DIFF)\r\nconv_flags |= SD;\r\nif (aref == AREF_COMMON)\r\nconv_flags |= CMEN;\r\nif (CR_RANGE(insn->chanspec) & UNIPOLAR)\r\nconv_flags |= UB;\r\noutb(conv_flags, dev->iobase + DAS1800_CONTROL_C);\r\noutb(CVEN, dev->iobase + DAS1800_STATUS);\r\noutb(0x0, dev->iobase + DAS1800_CONTROL_A);\r\noutb(FFEN, dev->iobase + DAS1800_CONTROL_A);\r\nchan = CR_CHAN(insn->chanspec);\r\nrange = CR_RANGE(insn->chanspec) & 0x3;\r\nchan_range = chan | (range << 8);\r\nspin_lock_irqsave(&dev->spinlock, irq_flags);\r\noutb(QRAM, dev->iobase + DAS1800_SELECT);\r\noutb(0x0, dev->iobase + DAS1800_QRAM_ADDRESS);\r\noutw(chan_range, dev->iobase + DAS1800_QRAM);\r\noutb(0x0, dev->iobase + DAS1800_QRAM_ADDRESS);\r\noutb(ADC, dev->iobase + DAS1800_SELECT);\r\nfor (n = 0; n < insn->n; n++) {\r\noutb(0, dev->iobase + DAS1800_FIFO);\r\nfor (i = 0; i < timeout; i++) {\r\nif (inb(dev->iobase + DAS1800_STATUS) & FNE)\r\nbreak;\r\n}\r\nif (i == timeout) {\r\ncomedi_error(dev, "timeout");\r\nn = -ETIME;\r\ngoto exit;\r\n}\r\ndpnt = inw(dev->iobase + DAS1800_FIFO);\r\nif ((conv_flags & UB) == 0)\r\ndpnt += 1 << (thisboard->resolution - 1);\r\ndata[n] = dpnt;\r\n}\r\nexit:\r\nspin_unlock_irqrestore(&dev->spinlock, irq_flags);\r\nreturn n;\r\n}\r\nstatic int das1800_ao_winsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint chan = CR_CHAN(insn->chanspec);\r\nint update_chan = thisboard->ao_n_chan - 1;\r\nshort output;\r\nunsigned long irq_flags;\r\noutput = data[0] - (1 << (thisboard->resolution - 1));\r\nif (chan == update_chan)\r\ndevpriv->ao_update_bits = output;\r\nspin_lock_irqsave(&dev->spinlock, irq_flags);\r\noutb(DAC(chan), dev->iobase + DAS1800_SELECT);\r\noutw(output, dev->iobase + DAS1800_DAC);\r\nif (chan != update_chan) {\r\noutb(DAC(update_chan), dev->iobase + DAS1800_SELECT);\r\noutw(devpriv->ao_update_bits, dev->iobase + DAS1800_DAC);\r\n}\r\nspin_unlock_irqrestore(&dev->spinlock, irq_flags);\r\nreturn 1;\r\n}\r\nstatic int das1800_di_rbits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[1] = inb(dev->iobase + DAS1800_DIGITAL) & 0xf;\r\ndata[0] = 0;\r\nreturn 2;\r\n}\r\nstatic int das1800_do_wbits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int wbits;\r\ndata[0] &= (1 << s->n_chan) - 1;\r\nwbits = devpriv->do_bits;\r\nwbits &= ~data[0];\r\nwbits |= data[0] & data[1];\r\ndevpriv->do_bits = wbits;\r\noutb(devpriv->do_bits, dev->iobase + DAS1800_DIGITAL);\r\ndata[1] = devpriv->do_bits;\r\nreturn 2;\r\n}\r\nstatic int das1800_set_frequency(struct comedi_device *dev)\r\n{\r\nint err = 0;\r\nif (i8254_load(dev->iobase + DAS1800_COUNTER, 0, 1, devpriv->divisor1,\r\n2))\r\nerr++;\r\nif (i8254_load(dev->iobase + DAS1800_COUNTER, 0, 2, devpriv->divisor2,\r\n2))\r\nerr++;\r\nif (err)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode)\r\n{\r\nunsigned int micro_sec;\r\nif (convert_arg > 64000)\r\nconvert_arg = 64000;\r\nswitch (round_mode) {\r\ncase TRIG_ROUND_NEAREST:\r\ndefault:\r\nmicro_sec = (convert_arg + 500) / 1000;\r\nbreak;\r\ncase TRIG_ROUND_DOWN:\r\nmicro_sec = convert_arg / 1000;\r\nbreak;\r\ncase TRIG_ROUND_UP:\r\nmicro_sec = (convert_arg - 1) / 1000 + 1;\r\nbreak;\r\n}\r\nreturn micro_sec * 1000;\r\n}\r\nstatic unsigned int suggest_transfer_size(struct comedi_cmd *cmd)\r\n{\r\nunsigned int size = DMA_BUF_SIZE;\r\nstatic const int sample_size = 2;\r\nunsigned int fill_time = 300000000;\r\nunsigned int max_size;\r\nswitch (cmd->scan_begin_src) {\r\ncase TRIG_FOLLOW:\r\nif (cmd->convert_src == TRIG_TIMER)\r\nsize = (fill_time / cmd->convert_arg) * sample_size;\r\nbreak;\r\ncase TRIG_TIMER:\r\nsize = (fill_time / (cmd->scan_begin_arg * cmd->chanlist_len)) *\r\nsample_size;\r\nbreak;\r\ndefault:\r\nsize = DMA_BUF_SIZE;\r\nbreak;\r\n}\r\nmax_size = DMA_BUF_SIZE;\r\nif (cmd->stop_src == TRIG_COUNT &&\r\ncmd->stop_arg * cmd->chanlist_len * sample_size < max_size)\r\nmax_size = cmd->stop_arg * cmd->chanlist_len * sample_size;\r\nif (size > max_size)\r\nsize = max_size;\r\nif (size < sample_size)\r\nsize = sample_size;\r\nreturn size;\r\n}
