static inline size_t br_nlmsg_size(void)\r\n{\r\nreturn NLMSG_ALIGN(sizeof(struct ifinfomsg))\r\n+ nla_total_size(IFNAMSIZ)\r\n+ nla_total_size(MAX_ADDR_LEN)\r\n+ nla_total_size(4)\r\n+ nla_total_size(4)\r\n+ nla_total_size(4)\r\n+ nla_total_size(1)\r\n+ nla_total_size(1);\r\n}\r\nstatic int br_fill_ifinfo(struct sk_buff *skb, const struct net_bridge_port *port,\r\nu32 pid, u32 seq, int event, unsigned int flags)\r\n{\r\nconst struct net_bridge *br = port->br;\r\nconst struct net_device *dev = port->dev;\r\nstruct ifinfomsg *hdr;\r\nstruct nlmsghdr *nlh;\r\nu8 operstate = netif_running(dev) ? dev->operstate : IF_OPER_DOWN;\r\nbr_debug(br, "br_fill_info event %d port %s master %s\n",\r\nevent, dev->name, br->dev->name);\r\nnlh = nlmsg_put(skb, pid, seq, event, sizeof(*hdr), flags);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nhdr = nlmsg_data(nlh);\r\nhdr->ifi_family = AF_BRIDGE;\r\nhdr->__ifi_pad = 0;\r\nhdr->ifi_type = dev->type;\r\nhdr->ifi_index = dev->ifindex;\r\nhdr->ifi_flags = dev_get_flags(dev);\r\nhdr->ifi_change = 0;\r\nNLA_PUT_STRING(skb, IFLA_IFNAME, dev->name);\r\nNLA_PUT_U32(skb, IFLA_MASTER, br->dev->ifindex);\r\nNLA_PUT_U32(skb, IFLA_MTU, dev->mtu);\r\nNLA_PUT_U8(skb, IFLA_OPERSTATE, operstate);\r\nif (dev->addr_len)\r\nNLA_PUT(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr);\r\nif (dev->ifindex != dev->iflink)\r\nNLA_PUT_U32(skb, IFLA_LINK, dev->iflink);\r\nif (event == RTM_NEWLINK)\r\nNLA_PUT_U8(skb, IFLA_PROTINFO, port->state);\r\nreturn nlmsg_end(skb, nlh);\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nvoid br_ifinfo_notify(int event, struct net_bridge_port *port)\r\n{\r\nstruct net *net = dev_net(port->dev);\r\nstruct sk_buff *skb;\r\nint err = -ENOBUFS;\r\nbr_debug(port->br, "port %u(%s) event %d\n",\r\n(unsigned)port->port_no, port->dev->name, event);\r\nskb = nlmsg_new(br_nlmsg_size(), GFP_ATOMIC);\r\nif (skb == NULL)\r\ngoto errout;\r\nerr = br_fill_ifinfo(skb, port, 0, 0, event, 0);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nkfree_skb(skb);\r\ngoto errout;\r\n}\r\nrtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, GFP_ATOMIC);\r\nreturn;\r\nerrout:\r\nif (err < 0)\r\nrtnl_set_sk_err(net, RTNLGRP_LINK, err);\r\n}\r\nstatic int br_dump_ifinfo(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct net_device *dev;\r\nint idx;\r\nidx = 0;\r\nrcu_read_lock();\r\nfor_each_netdev_rcu(net, dev) {\r\nstruct net_bridge_port *port = br_port_get_rcu(dev);\r\nif (!port || idx < cb->args[0])\r\ngoto skip;\r\nif (br_fill_ifinfo(skb, port,\r\nNETLINK_CB(cb->skb).pid,\r\ncb->nlh->nlmsg_seq, RTM_NEWLINK,\r\nNLM_F_MULTI) < 0)\r\nbreak;\r\nskip:\r\n++idx;\r\n}\r\nrcu_read_unlock();\r\ncb->args[0] = idx;\r\nreturn skb->len;\r\n}\r\nstatic int br_rtm_setlink(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct ifinfomsg *ifm;\r\nstruct nlattr *protinfo;\r\nstruct net_device *dev;\r\nstruct net_bridge_port *p;\r\nu8 new_state;\r\nif (nlmsg_len(nlh) < sizeof(*ifm))\r\nreturn -EINVAL;\r\nifm = nlmsg_data(nlh);\r\nif (ifm->ifi_family != AF_BRIDGE)\r\nreturn -EPFNOSUPPORT;\r\nprotinfo = nlmsg_find_attr(nlh, sizeof(*ifm), IFLA_PROTINFO);\r\nif (!protinfo || nla_len(protinfo) < sizeof(u8))\r\nreturn -EINVAL;\r\nnew_state = nla_get_u8(protinfo);\r\nif (new_state > BR_STATE_BLOCKING)\r\nreturn -EINVAL;\r\ndev = __dev_get_by_index(net, ifm->ifi_index);\r\nif (!dev)\r\nreturn -ENODEV;\r\np = br_port_get_rtnl(dev);\r\nif (!p)\r\nreturn -EINVAL;\r\nif (p->br->stp_enabled == BR_KERNEL_STP)\r\nreturn -EBUSY;\r\nif (!netif_running(dev) ||\r\n(!netif_carrier_ok(dev) && new_state != BR_STATE_DISABLED))\r\nreturn -ENETDOWN;\r\np->state = new_state;\r\nbr_log_state(p);\r\nspin_lock_bh(&p->br->lock);\r\nbr_port_state_selection(p->br);\r\nspin_unlock_bh(&p->br->lock);\r\nbr_ifinfo_notify(RTM_NEWLINK, p);\r\nreturn 0;\r\n}\r\nstatic int br_validate(struct nlattr *tb[], struct nlattr *data[])\r\n{\r\nif (tb[IFLA_ADDRESS]) {\r\nif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\r\nreturn -EINVAL;\r\nif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nreturn 0;\r\n}\r\nint __init br_netlink_init(void)\r\n{\r\nint err;\r\nerr = rtnl_link_register(&br_link_ops);\r\nif (err < 0)\r\ngoto err1;\r\nerr = __rtnl_register(PF_BRIDGE, RTM_GETLINK, NULL,\r\nbr_dump_ifinfo, NULL);\r\nif (err)\r\ngoto err2;\r\nerr = __rtnl_register(PF_BRIDGE, RTM_SETLINK,\r\nbr_rtm_setlink, NULL, NULL);\r\nif (err)\r\ngoto err3;\r\nerr = __rtnl_register(PF_BRIDGE, RTM_NEWNEIGH,\r\nbr_fdb_add, NULL, NULL);\r\nif (err)\r\ngoto err3;\r\nerr = __rtnl_register(PF_BRIDGE, RTM_DELNEIGH,\r\nbr_fdb_delete, NULL, NULL);\r\nif (err)\r\ngoto err3;\r\nerr = __rtnl_register(PF_BRIDGE, RTM_GETNEIGH,\r\nNULL, br_fdb_dump, NULL);\r\nif (err)\r\ngoto err3;\r\nreturn 0;\r\nerr3:\r\nrtnl_unregister_all(PF_BRIDGE);\r\nerr2:\r\nrtnl_link_unregister(&br_link_ops);\r\nerr1:\r\nreturn err;\r\n}\r\nvoid __exit br_netlink_fini(void)\r\n{\r\nrtnl_link_unregister(&br_link_ops);\r\nrtnl_unregister_all(PF_BRIDGE);\r\n}
