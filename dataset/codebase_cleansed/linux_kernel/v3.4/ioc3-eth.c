static inline struct net_device *priv_netdev(struct ioc3_private *dev)\r\n{\r\nreturn (void *)dev - ((sizeof(struct net_device) + 31) & ~31);\r\n}\r\nstatic inline unsigned long aligned_rx_skb_addr(unsigned long addr)\r\n{\r\nreturn (~addr + 1) & (IOC3_CACHELINE - 1UL);\r\n}\r\nstatic inline struct sk_buff * ioc3_alloc_skb(unsigned long length,\r\nunsigned int gfp_mask)\r\n{\r\nstruct sk_buff *skb;\r\nskb = alloc_skb(length + IOC3_CACHELINE - 1, gfp_mask);\r\nif (likely(skb)) {\r\nint offset = aligned_rx_skb_addr((unsigned long) skb->data);\r\nif (offset)\r\nskb_reserve(skb, offset);\r\n}\r\nreturn skb;\r\n}\r\nstatic inline unsigned long ioc3_map(void *ptr, unsigned long vdev)\r\n{\r\n#ifdef CONFIG_SGI_IP27\r\nvdev <<= 57;\r\nreturn vdev | (0xaUL << PCI64_ATTR_TARG_SHFT) | PCI64_ATTR_PREF |\r\n((unsigned long)ptr & TO_PHYS_MASK);\r\n#else\r\nreturn virt_to_bus(ptr);\r\n#endif\r\n}\r\nstatic inline u32 mcr_pack(u32 pulse, u32 sample)\r\n{\r\nreturn (pulse << 10) | (sample << 2);\r\n}\r\nstatic int nic_wait(struct ioc3 *ioc3)\r\n{\r\nu32 mcr;\r\ndo {\r\nmcr = ioc3_r_mcr();\r\n} while (!(mcr & 2));\r\nreturn mcr & 1;\r\n}\r\nstatic int nic_reset(struct ioc3 *ioc3)\r\n{\r\nint presence;\r\nioc3_w_mcr(mcr_pack(500, 65));\r\npresence = nic_wait(ioc3);\r\nioc3_w_mcr(mcr_pack(0, 500));\r\nnic_wait(ioc3);\r\nreturn presence;\r\n}\r\nstatic inline int nic_read_bit(struct ioc3 *ioc3)\r\n{\r\nint result;\r\nioc3_w_mcr(mcr_pack(6, 13));\r\nresult = nic_wait(ioc3);\r\nioc3_w_mcr(mcr_pack(0, 100));\r\nnic_wait(ioc3);\r\nreturn result;\r\n}\r\nstatic inline void nic_write_bit(struct ioc3 *ioc3, int bit)\r\n{\r\nif (bit)\r\nioc3_w_mcr(mcr_pack(6, 110));\r\nelse\r\nioc3_w_mcr(mcr_pack(80, 30));\r\nnic_wait(ioc3);\r\n}\r\nstatic u32 nic_read_byte(struct ioc3 *ioc3)\r\n{\r\nu32 result = 0;\r\nint i;\r\nfor (i = 0; i < 8; i++)\r\nresult = (result >> 1) | (nic_read_bit(ioc3) << 7);\r\nreturn result;\r\n}\r\nstatic void nic_write_byte(struct ioc3 *ioc3, int byte)\r\n{\r\nint i, bit;\r\nfor (i = 8; i; i--) {\r\nbit = byte & 1;\r\nbyte >>= 1;\r\nnic_write_bit(ioc3, bit);\r\n}\r\n}\r\nstatic u64 nic_find(struct ioc3 *ioc3, int *last)\r\n{\r\nint a, b, index, disc;\r\nu64 address = 0;\r\nnic_reset(ioc3);\r\nnic_write_byte(ioc3, 0xf0);\r\nfor (index = 0, disc = 0; index < 64; index++) {\r\na = nic_read_bit(ioc3);\r\nb = nic_read_bit(ioc3);\r\nif (a && b) {\r\nprintk("NIC search failed (not fatal).\n");\r\n*last = 0;\r\nreturn 0;\r\n}\r\nif (!a && !b) {\r\nif (index == *last) {\r\naddress |= 1UL << index;\r\n} else if (index > *last) {\r\naddress &= ~(1UL << index);\r\ndisc = index;\r\n} else if ((address & (1UL << index)) == 0)\r\ndisc = index;\r\nnic_write_bit(ioc3, address & (1UL << index));\r\ncontinue;\r\n} else {\r\nif (a)\r\naddress |= 1UL << index;\r\nelse\r\naddress &= ~(1UL << index);\r\nnic_write_bit(ioc3, a);\r\ncontinue;\r\n}\r\n}\r\n*last = disc;\r\nreturn address;\r\n}\r\nstatic int nic_init(struct ioc3 *ioc3)\r\n{\r\nconst char *unknown = "unknown";\r\nconst char *type = unknown;\r\nu8 crc;\r\nu8 serial[6];\r\nint save = 0, i;\r\nwhile (1) {\r\nu64 reg;\r\nreg = nic_find(ioc3, &save);\r\nswitch (reg & 0xff) {\r\ncase 0x91:\r\ntype = "DS1981U";\r\nbreak;\r\ndefault:\r\nif (save == 0) {\r\nreturn -1;\r\n}\r\ncontinue;\r\n}\r\nnic_reset(ioc3);\r\nnic_write_byte(ioc3, 0x55);\r\nfor (i = 0; i < 8; i++)\r\nnic_write_byte(ioc3, (reg >> (i << 3)) & 0xff);\r\nreg >>= 8;\r\nfor (i = 0; i < 6; i++) {\r\nserial[i] = reg & 0xff;\r\nreg >>= 8;\r\n}\r\ncrc = reg & 0xff;\r\nbreak;\r\n}\r\nprintk("Found %s NIC", type);\r\nif (type != unknown)\r\nprintk (" registration number %pM, CRC %02x", serial, crc);\r\nprintk(".\n");\r\nreturn 0;\r\n}\r\nstatic void ioc3_get_eaddr_nic(struct ioc3_private *ip)\r\n{\r\nstruct ioc3 *ioc3 = ip->regs;\r\nu8 nic[14];\r\nint tries = 2;\r\nint i;\r\nioc3_w_gpcr_s(1 << 21);\r\nwhile (tries--) {\r\nif (!nic_init(ioc3))\r\nbreak;\r\nudelay(500);\r\n}\r\nif (tries < 0) {\r\nprintk("Failed to read MAC address\n");\r\nreturn;\r\n}\r\nnic_write_byte(ioc3, 0xf0);\r\nnic_write_byte(ioc3, 0x00);\r\nnic_write_byte(ioc3, 0x00);\r\nfor (i = 13; i >= 0; i--)\r\nnic[i] = nic_read_byte(ioc3);\r\nfor (i = 2; i < 8; i++)\r\npriv_netdev(ip)->dev_addr[i - 2] = nic[i];\r\n}\r\nstatic void ioc3_get_eaddr(struct ioc3_private *ip)\r\n{\r\nioc3_get_eaddr_nic(ip);\r\nprintk("Ethernet address is %pM.\n", priv_netdev(ip)->dev_addr);\r\n}\r\nstatic void __ioc3_set_mac_address(struct net_device *dev)\r\n{\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nstruct ioc3 *ioc3 = ip->regs;\r\nioc3_w_emar_h((dev->dev_addr[5] << 8) | dev->dev_addr[4]);\r\nioc3_w_emar_l((dev->dev_addr[3] << 24) | (dev->dev_addr[2] << 16) |\r\n(dev->dev_addr[1] << 8) | dev->dev_addr[0]);\r\n}\r\nstatic int ioc3_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nstruct sockaddr *sa = addr;\r\nmemcpy(dev->dev_addr, sa->sa_data, dev->addr_len);\r\nspin_lock_irq(&ip->ioc3_lock);\r\n__ioc3_set_mac_address(dev);\r\nspin_unlock_irq(&ip->ioc3_lock);\r\nreturn 0;\r\n}\r\nstatic int ioc3_mdio_read(struct net_device *dev, int phy, int reg)\r\n{\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nstruct ioc3 *ioc3 = ip->regs;\r\nwhile (ioc3_r_micr() & MICR_BUSY);\r\nioc3_w_micr((phy << MICR_PHYADDR_SHIFT) | reg | MICR_READTRIG);\r\nwhile (ioc3_r_micr() & MICR_BUSY);\r\nreturn ioc3_r_midr_r() & MIDR_DATA_MASK;\r\n}\r\nstatic void ioc3_mdio_write(struct net_device *dev, int phy, int reg, int data)\r\n{\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nstruct ioc3 *ioc3 = ip->regs;\r\nwhile (ioc3_r_micr() & MICR_BUSY);\r\nioc3_w_midr_w(data);\r\nioc3_w_micr((phy << MICR_PHYADDR_SHIFT) | reg);\r\nwhile (ioc3_r_micr() & MICR_BUSY);\r\n}\r\nstatic struct net_device_stats *ioc3_get_stats(struct net_device *dev)\r\n{\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nstruct ioc3 *ioc3 = ip->regs;\r\ndev->stats.collisions += (ioc3_r_etcdc() & ETCDC_COLLCNT_MASK);\r\nreturn &dev->stats;\r\n}\r\nstatic void ioc3_tcpudp_checksum(struct sk_buff *skb, uint32_t hwsum, int len)\r\n{\r\nstruct ethhdr *eh = eth_hdr(skb);\r\nuint32_t csum, ehsum;\r\nunsigned int proto;\r\nstruct iphdr *ih;\r\nuint16_t *ew;\r\nunsigned char *cp;\r\nif (eh->h_proto != htons(ETH_P_IP))\r\nreturn;\r\nih = (struct iphdr *) ((char *)eh + ETH_HLEN);\r\nif (ip_is_fragment(ih))\r\nreturn;\r\nproto = ih->protocol;\r\nif (proto != IPPROTO_TCP && proto != IPPROTO_UDP)\r\nreturn;\r\ncsum = hwsum +\r\n(ih->tot_len - (ih->ihl << 2)) +\r\nhtons((uint16_t)ih->protocol) +\r\n(ih->saddr >> 16) + (ih->saddr & 0xffff) +\r\n(ih->daddr >> 16) + (ih->daddr & 0xffff);\r\new = (uint16_t *) eh;\r\nehsum = ew[0] + ew[1] + ew[2] + ew[3] + ew[4] + ew[5] + ew[6];\r\nehsum = (ehsum & 0xffff) + (ehsum >> 16);\r\nehsum = (ehsum & 0xffff) + (ehsum >> 16);\r\ncsum += 0xffff ^ ehsum;\r\ncp = (char *)eh + len;\r\nif (len & 1) {\r\ncsum += 0xffff ^ (uint16_t) ((cp[1] << 8) | cp[0]);\r\ncsum += 0xffff ^ (uint16_t) ((cp[3] << 8) | cp[2]);\r\n} else {\r\ncsum += 0xffff ^ (uint16_t) ((cp[0] << 8) | cp[1]);\r\ncsum += 0xffff ^ (uint16_t) ((cp[2] << 8) | cp[3]);\r\n}\r\ncsum = (csum & 0xffff) + (csum >> 16);\r\ncsum = (csum & 0xffff) + (csum >> 16);\r\nif (csum == 0xffff)\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\n}\r\nstatic inline void ioc3_rx(struct net_device *dev)\r\n{\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nstruct sk_buff *skb, *new_skb;\r\nstruct ioc3 *ioc3 = ip->regs;\r\nint rx_entry, n_entry, len;\r\nstruct ioc3_erxbuf *rxb;\r\nunsigned long *rxr;\r\nu32 w0, err;\r\nrxr = (unsigned long *) ip->rxr;\r\nrx_entry = ip->rx_ci;\r\nn_entry = ip->rx_pi;\r\nskb = ip->rx_skbs[rx_entry];\r\nrxb = (struct ioc3_erxbuf *) (skb->data - RX_OFFSET);\r\nw0 = be32_to_cpu(rxb->w0);\r\nwhile (w0 & ERXBUF_V) {\r\nerr = be32_to_cpu(rxb->err);\r\nif (err & ERXBUF_GOODPKT) {\r\nlen = ((w0 >> ERXBUF_BYTECNT_SHIFT) & 0x7ff) - 4;\r\nskb_trim(skb, len);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnew_skb = ioc3_alloc_skb(RX_BUF_ALLOC_SIZE, GFP_ATOMIC);\r\nif (!new_skb) {\r\ndev->stats.rx_dropped++;\r\nnew_skb = skb;\r\ngoto next;\r\n}\r\nif (likely(dev->features & NETIF_F_RXCSUM))\r\nioc3_tcpudp_checksum(skb,\r\nw0 & ERXBUF_IPCKSUM_MASK, len);\r\nnetif_rx(skb);\r\nip->rx_skbs[rx_entry] = NULL;\r\nskb_put(new_skb, (1664 + RX_OFFSET));\r\nrxb = (struct ioc3_erxbuf *) new_skb->data;\r\nskb_reserve(new_skb, RX_OFFSET);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += len;\r\n} else {\r\nnew_skb = skb;\r\ndev->stats.rx_errors++;\r\n}\r\nif (err & ERXBUF_CRCERR)\r\ndev->stats.rx_crc_errors++;\r\nif (err & ERXBUF_FRAMERR)\r\ndev->stats.rx_frame_errors++;\r\nnext:\r\nip->rx_skbs[n_entry] = new_skb;\r\nrxr[n_entry] = cpu_to_be64(ioc3_map(rxb, 1));\r\nrxb->w0 = 0;\r\nn_entry = (n_entry + 1) & 511;\r\nrx_entry = (rx_entry + 1) & 511;\r\nskb = ip->rx_skbs[rx_entry];\r\nrxb = (struct ioc3_erxbuf *) (skb->data - RX_OFFSET);\r\nw0 = be32_to_cpu(rxb->w0);\r\n}\r\nioc3_w_erpir((n_entry << 3) | ERPIR_ARM);\r\nip->rx_pi = n_entry;\r\nip->rx_ci = rx_entry;\r\n}\r\nstatic inline void ioc3_tx(struct net_device *dev)\r\n{\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nunsigned long packets, bytes;\r\nstruct ioc3 *ioc3 = ip->regs;\r\nint tx_entry, o_entry;\r\nstruct sk_buff *skb;\r\nu32 etcir;\r\nspin_lock(&ip->ioc3_lock);\r\netcir = ioc3_r_etcir();\r\ntx_entry = (etcir >> 7) & 127;\r\no_entry = ip->tx_ci;\r\npackets = 0;\r\nbytes = 0;\r\nwhile (o_entry != tx_entry) {\r\npackets++;\r\nskb = ip->tx_skbs[o_entry];\r\nbytes += skb->len;\r\ndev_kfree_skb_irq(skb);\r\nip->tx_skbs[o_entry] = NULL;\r\no_entry = (o_entry + 1) & 127;\r\netcir = ioc3_r_etcir();\r\ntx_entry = (etcir >> 7) & 127;\r\n}\r\ndev->stats.tx_packets += packets;\r\ndev->stats.tx_bytes += bytes;\r\nip->txqlen -= packets;\r\nif (ip->txqlen < 128)\r\nnetif_wake_queue(dev);\r\nip->tx_ci = o_entry;\r\nspin_unlock(&ip->ioc3_lock);\r\n}\r\nstatic void ioc3_error(struct net_device *dev, u32 eisr)\r\n{\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nunsigned char *iface = dev->name;\r\nspin_lock(&ip->ioc3_lock);\r\nif (eisr & EISR_RXOFLO)\r\nprintk(KERN_ERR "%s: RX overflow.\n", iface);\r\nif (eisr & EISR_RXBUFOFLO)\r\nprintk(KERN_ERR "%s: RX buffer overflow.\n", iface);\r\nif (eisr & EISR_RXMEMERR)\r\nprintk(KERN_ERR "%s: RX PCI error.\n", iface);\r\nif (eisr & EISR_RXPARERR)\r\nprintk(KERN_ERR "%s: RX SSRAM parity error.\n", iface);\r\nif (eisr & EISR_TXBUFUFLO)\r\nprintk(KERN_ERR "%s: TX buffer underflow.\n", iface);\r\nif (eisr & EISR_TXMEMERR)\r\nprintk(KERN_ERR "%s: TX PCI error.\n", iface);\r\nioc3_stop(ip);\r\nioc3_init(dev);\r\nioc3_mii_init(ip);\r\nnetif_wake_queue(dev);\r\nspin_unlock(&ip->ioc3_lock);\r\n}\r\nstatic irqreturn_t ioc3_interrupt(int irq, void *_dev)\r\n{\r\nstruct net_device *dev = (struct net_device *)_dev;\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nstruct ioc3 *ioc3 = ip->regs;\r\nconst u32 enabled = EISR_RXTIMERINT | EISR_RXOFLO | EISR_RXBUFOFLO |\r\nEISR_RXMEMERR | EISR_RXPARERR | EISR_TXBUFUFLO |\r\nEISR_TXEXPLICIT | EISR_TXMEMERR;\r\nu32 eisr;\r\neisr = ioc3_r_eisr() & enabled;\r\nioc3_w_eisr(eisr);\r\n(void) ioc3_r_eisr();\r\nif (eisr & (EISR_RXOFLO | EISR_RXBUFOFLO | EISR_RXMEMERR |\r\nEISR_RXPARERR | EISR_TXBUFUFLO | EISR_TXMEMERR))\r\nioc3_error(dev, eisr);\r\nif (eisr & EISR_RXTIMERINT)\r\nioc3_rx(dev);\r\nif (eisr & EISR_TXEXPLICIT)\r\nioc3_tx(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline void ioc3_setup_duplex(struct ioc3_private *ip)\r\n{\r\nstruct ioc3 *ioc3 = ip->regs;\r\nif (ip->mii.full_duplex) {\r\nioc3_w_etcsr(ETCSR_FD);\r\nip->emcr |= EMCR_DUPLEX;\r\n} else {\r\nioc3_w_etcsr(ETCSR_HD);\r\nip->emcr &= ~EMCR_DUPLEX;\r\n}\r\nioc3_w_emcr(ip->emcr);\r\n}\r\nstatic void ioc3_timer(unsigned long data)\r\n{\r\nstruct ioc3_private *ip = (struct ioc3_private *) data;\r\nmii_check_media(&ip->mii, 1, 0);\r\nioc3_setup_duplex(ip);\r\nip->ioc3_timer.expires = jiffies + ((12 * HZ)/10);\r\nadd_timer(&ip->ioc3_timer);\r\n}\r\nstatic int ioc3_mii_init(struct ioc3_private *ip)\r\n{\r\nstruct net_device *dev = priv_netdev(ip);\r\nint i, found = 0, res = 0;\r\nint ioc3_phy_workaround = 1;\r\nu16 word;\r\nfor (i = 0; i < 32; i++) {\r\nword = ioc3_mdio_read(dev, i, MII_PHYSID1);\r\nif (word != 0xffff && word != 0x0000) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nif (ioc3_phy_workaround)\r\ni = 31;\r\nelse {\r\nip->mii.phy_id = -1;\r\nres = -ENODEV;\r\ngoto out;\r\n}\r\n}\r\nip->mii.phy_id = i;\r\nout:\r\nreturn res;\r\n}\r\nstatic void ioc3_mii_start(struct ioc3_private *ip)\r\n{\r\nip->ioc3_timer.expires = jiffies + (12 * HZ)/10;\r\nip->ioc3_timer.data = (unsigned long) ip;\r\nip->ioc3_timer.function = ioc3_timer;\r\nadd_timer(&ip->ioc3_timer);\r\n}\r\nstatic inline void ioc3_clean_rx_ring(struct ioc3_private *ip)\r\n{\r\nstruct sk_buff *skb;\r\nint i;\r\nfor (i = ip->rx_ci; i & 15; i++) {\r\nip->rx_skbs[ip->rx_pi] = ip->rx_skbs[ip->rx_ci];\r\nip->rxr[ip->rx_pi++] = ip->rxr[ip->rx_ci++];\r\n}\r\nip->rx_pi &= 511;\r\nip->rx_ci &= 511;\r\nfor (i = ip->rx_ci; i != ip->rx_pi; i = (i+1) & 511) {\r\nstruct ioc3_erxbuf *rxb;\r\nskb = ip->rx_skbs[i];\r\nrxb = (struct ioc3_erxbuf *) (skb->data - RX_OFFSET);\r\nrxb->w0 = 0;\r\n}\r\n}\r\nstatic inline void ioc3_clean_tx_ring(struct ioc3_private *ip)\r\n{\r\nstruct sk_buff *skb;\r\nint i;\r\nfor (i=0; i < 128; i++) {\r\nskb = ip->tx_skbs[i];\r\nif (skb) {\r\nip->tx_skbs[i] = NULL;\r\ndev_kfree_skb_any(skb);\r\n}\r\nip->txr[i].cmd = 0;\r\n}\r\nip->tx_pi = 0;\r\nip->tx_ci = 0;\r\n}\r\nstatic void ioc3_free_rings(struct ioc3_private *ip)\r\n{\r\nstruct sk_buff *skb;\r\nint rx_entry, n_entry;\r\nif (ip->txr) {\r\nioc3_clean_tx_ring(ip);\r\nfree_pages((unsigned long)ip->txr, 2);\r\nip->txr = NULL;\r\n}\r\nif (ip->rxr) {\r\nn_entry = ip->rx_ci;\r\nrx_entry = ip->rx_pi;\r\nwhile (n_entry != rx_entry) {\r\nskb = ip->rx_skbs[n_entry];\r\nif (skb)\r\ndev_kfree_skb_any(skb);\r\nn_entry = (n_entry + 1) & 511;\r\n}\r\nfree_page((unsigned long)ip->rxr);\r\nip->rxr = NULL;\r\n}\r\n}\r\nstatic void ioc3_alloc_rings(struct net_device *dev)\r\n{\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nstruct ioc3_erxbuf *rxb;\r\nunsigned long *rxr;\r\nint i;\r\nif (ip->rxr == NULL) {\r\nip->rxr = (unsigned long *) get_zeroed_page(GFP_ATOMIC);\r\nrxr = (unsigned long *) ip->rxr;\r\nif (!rxr)\r\nprintk("ioc3_alloc_rings(): get_zeroed_page() failed!\n");\r\nfor (i = 0; i < RX_BUFFS; i++) {\r\nstruct sk_buff *skb;\r\nskb = ioc3_alloc_skb(RX_BUF_ALLOC_SIZE, GFP_ATOMIC);\r\nif (!skb) {\r\nshow_free_areas(0);\r\ncontinue;\r\n}\r\nip->rx_skbs[i] = skb;\r\nskb_put(skb, (1664 + RX_OFFSET));\r\nrxb = (struct ioc3_erxbuf *) skb->data;\r\nrxr[i] = cpu_to_be64(ioc3_map(rxb, 1));\r\nskb_reserve(skb, RX_OFFSET);\r\n}\r\nip->rx_ci = 0;\r\nip->rx_pi = RX_BUFFS;\r\n}\r\nif (ip->txr == NULL) {\r\nip->txr = (struct ioc3_etxd *)__get_free_pages(GFP_KERNEL, 2);\r\nif (!ip->txr)\r\nprintk("ioc3_alloc_rings(): __get_free_pages() failed!\n");\r\nip->tx_pi = 0;\r\nip->tx_ci = 0;\r\n}\r\n}\r\nstatic void ioc3_init_rings(struct net_device *dev)\r\n{\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nstruct ioc3 *ioc3 = ip->regs;\r\nunsigned long ring;\r\nioc3_free_rings(ip);\r\nioc3_alloc_rings(dev);\r\nioc3_clean_rx_ring(ip);\r\nioc3_clean_tx_ring(ip);\r\nring = ioc3_map(ip->rxr, 0);\r\nioc3_w_erbr_h(ring >> 32);\r\nioc3_w_erbr_l(ring & 0xffffffff);\r\nioc3_w_ercir(ip->rx_ci << 3);\r\nioc3_w_erpir((ip->rx_pi << 3) | ERPIR_ARM);\r\nring = ioc3_map(ip->txr, 0);\r\nip->txqlen = 0;\r\nioc3_w_etbr_h(ring >> 32);\r\nioc3_w_etbr_l(ring & 0xffffffff);\r\nioc3_w_etpir(ip->tx_pi << 7);\r\nioc3_w_etcir(ip->tx_ci << 7);\r\n(void) ioc3_r_etcir();\r\n}\r\nstatic inline void ioc3_ssram_disc(struct ioc3_private *ip)\r\n{\r\nstruct ioc3 *ioc3 = ip->regs;\r\nvolatile u32 *ssram0 = &ioc3->ssram[0x0000];\r\nvolatile u32 *ssram1 = &ioc3->ssram[0x4000];\r\nunsigned int pattern = 0x5555;\r\nioc3_w_emcr(ioc3_r_emcr() | (EMCR_BUFSIZ | EMCR_RAMPAR));\r\n*ssram0 = pattern;\r\n*ssram1 = ~pattern & IOC3_SSRAM_DM;\r\nif ((*ssram0 & IOC3_SSRAM_DM) != pattern ||\r\n(*ssram1 & IOC3_SSRAM_DM) != (~pattern & IOC3_SSRAM_DM)) {\r\nip->emcr = EMCR_RAMPAR;\r\nioc3_w_emcr(ioc3_r_emcr() & ~EMCR_BUFSIZ);\r\n} else\r\nip->emcr = EMCR_BUFSIZ | EMCR_RAMPAR;\r\n}\r\nstatic void ioc3_init(struct net_device *dev)\r\n{\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nstruct ioc3 *ioc3 = ip->regs;\r\ndel_timer_sync(&ip->ioc3_timer);\r\nioc3_w_emcr(EMCR_RST);\r\n(void) ioc3_r_emcr();\r\nudelay(4);\r\nioc3_w_emcr(0);\r\n(void) ioc3_r_emcr();\r\n#ifdef CONFIG_SGI_IP27\r\nioc3_w_erbar(PCI64_ATTR_BAR >> 32);\r\n#else\r\nioc3_w_erbar(0);\r\n#endif\r\n(void) ioc3_r_etcdc();\r\nioc3_w_ercsr(15);\r\nioc3_w_ertr(0);\r\n__ioc3_set_mac_address(dev);\r\nioc3_w_ehar_h(ip->ehar_h);\r\nioc3_w_ehar_l(ip->ehar_l);\r\nioc3_w_ersr(42);\r\nioc3_init_rings(dev);\r\nip->emcr |= ((RX_OFFSET / 2) << EMCR_RXOFF_SHIFT) | EMCR_TXDMAEN |\r\nEMCR_TXEN | EMCR_RXDMAEN | EMCR_RXEN | EMCR_PADEN;\r\nioc3_w_emcr(ip->emcr);\r\nioc3_w_eier(EISR_RXTIMERINT | EISR_RXOFLO | EISR_RXBUFOFLO |\r\nEISR_RXMEMERR | EISR_RXPARERR | EISR_TXBUFUFLO |\r\nEISR_TXEXPLICIT | EISR_TXMEMERR);\r\n(void) ioc3_r_eier();\r\n}\r\nstatic inline void ioc3_stop(struct ioc3_private *ip)\r\n{\r\nstruct ioc3 *ioc3 = ip->regs;\r\nioc3_w_emcr(0);\r\nioc3_w_eier(0);\r\n(void) ioc3_r_eier();\r\n}\r\nstatic int ioc3_open(struct net_device *dev)\r\n{\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nif (request_irq(dev->irq, ioc3_interrupt, IRQF_SHARED, ioc3_str, dev)) {\r\nprintk(KERN_ERR "%s: Can't get irq %d\n", dev->name, dev->irq);\r\nreturn -EAGAIN;\r\n}\r\nip->ehar_h = 0;\r\nip->ehar_l = 0;\r\nioc3_init(dev);\r\nioc3_mii_start(ip);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int ioc3_close(struct net_device *dev)\r\n{\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\ndel_timer_sync(&ip->ioc3_timer);\r\nnetif_stop_queue(dev);\r\nioc3_stop(ip);\r\nfree_irq(dev->irq, dev);\r\nioc3_free_rings(ip);\r\nreturn 0;\r\n}\r\nstatic int ioc3_adjacent_is_ioc3(struct pci_dev *pdev, int slot)\r\n{\r\nstruct pci_dev *dev = pci_get_slot(pdev->bus, PCI_DEVFN(slot, 0));\r\nint ret = 0;\r\nif (dev) {\r\nif (dev->vendor == PCI_VENDOR_ID_SGI &&\r\ndev->device == PCI_DEVICE_ID_SGI_IOC3)\r\nret = 1;\r\npci_dev_put(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ioc3_is_menet(struct pci_dev *pdev)\r\n{\r\nreturn pdev->bus->parent == NULL &&\r\nioc3_adjacent_is_ioc3(pdev, 0) &&\r\nioc3_adjacent_is_ioc3(pdev, 1) &&\r\nioc3_adjacent_is_ioc3(pdev, 2);\r\n}\r\nstatic void __devinit ioc3_8250_register(struct ioc3_uartregs __iomem *uart)\r\n{\r\n#define COSMISC_CONSTANT 6\r\nstruct uart_port port = {\r\n.irq = 0,\r\n.flags = UPF_SKIP_TEST | UPF_BOOT_AUTOCONF,\r\n.iotype = UPIO_MEM,\r\n.regshift = 0,\r\n.uartclk = (22000000 << 1) / COSMISC_CONSTANT,\r\n.membase = (unsigned char __iomem *) uart,\r\n.mapbase = (unsigned long) uart,\r\n};\r\nunsigned char lcr;\r\nlcr = uart->iu_lcr;\r\nuart->iu_lcr = lcr | UART_LCR_DLAB;\r\nuart->iu_scr = COSMISC_CONSTANT,\r\nuart->iu_lcr = lcr;\r\nuart->iu_lcr;\r\nserial8250_register_port(&port);\r\n}\r\nstatic void __devinit ioc3_serial_probe(struct pci_dev *pdev, struct ioc3 *ioc3)\r\n{\r\nif (ioc3_is_menet(pdev) && PCI_SLOT(pdev->devfn) == 3)\r\nreturn;\r\nioc3->gpcr_s = GPCR_UARTA_MODESEL | GPCR_UARTB_MODESEL;\r\nioc3->gpcr_s;\r\nioc3->gppr_6 = 0;\r\nioc3->gppr_6;\r\nioc3->gppr_7 = 0;\r\nioc3->gppr_7;\r\nioc3->sscr_a = ioc3->sscr_a & ~SSCR_DMA_EN;\r\nioc3->sscr_a;\r\nioc3->sscr_b = ioc3->sscr_b & ~SSCR_DMA_EN;\r\nioc3->sscr_b;\r\nioc3->sio_iec &= ~ (SIO_IR_SA_TX_MT | SIO_IR_SA_RX_FULL |\r\nSIO_IR_SA_RX_HIGH | SIO_IR_SA_RX_TIMER |\r\nSIO_IR_SA_DELTA_DCD | SIO_IR_SA_DELTA_CTS |\r\nSIO_IR_SA_TX_EXPLICIT | SIO_IR_SA_MEMERR);\r\nioc3->sio_iec |= SIO_IR_SA_INT;\r\nioc3->sscr_a = 0;\r\nioc3->sio_iec &= ~ (SIO_IR_SB_TX_MT | SIO_IR_SB_RX_FULL |\r\nSIO_IR_SB_RX_HIGH | SIO_IR_SB_RX_TIMER |\r\nSIO_IR_SB_DELTA_DCD | SIO_IR_SB_DELTA_CTS |\r\nSIO_IR_SB_TX_EXPLICIT | SIO_IR_SB_MEMERR);\r\nioc3->sio_iec |= SIO_IR_SB_INT;\r\nioc3->sscr_b = 0;\r\nioc3_8250_register(&ioc3->sregs.uarta);\r\nioc3_8250_register(&ioc3->sregs.uartb);\r\n}\r\nstatic int __devinit ioc3_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nunsigned int sw_physid1, sw_physid2;\r\nstruct net_device *dev = NULL;\r\nstruct ioc3_private *ip;\r\nstruct ioc3 *ioc3;\r\nunsigned long ioc3_base, ioc3_size;\r\nu32 vendor, model, rev;\r\nint err, pci_using_dac;\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (!err) {\r\npci_using_dac = 1;\r\nerr = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (err < 0) {\r\nprintk(KERN_ERR "%s: Unable to obtain 64 bit DMA "\r\n"for consistent allocations\n", pci_name(pdev));\r\ngoto out;\r\n}\r\n} else {\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (err) {\r\nprintk(KERN_ERR "%s: No usable DMA configuration, "\r\n"aborting.\n", pci_name(pdev));\r\ngoto out;\r\n}\r\npci_using_dac = 0;\r\n}\r\nif (pci_enable_device(pdev))\r\nreturn -ENODEV;\r\ndev = alloc_etherdev(sizeof(struct ioc3_private));\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto out_disable;\r\n}\r\nif (pci_using_dac)\r\ndev->features |= NETIF_F_HIGHDMA;\r\nerr = pci_request_regions(pdev, "ioc3");\r\nif (err)\r\ngoto out_free;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nip = netdev_priv(dev);\r\ndev->irq = pdev->irq;\r\nioc3_base = pci_resource_start(pdev, 0);\r\nioc3_size = pci_resource_len(pdev, 0);\r\nioc3 = (struct ioc3 *) ioremap(ioc3_base, ioc3_size);\r\nif (!ioc3) {\r\nprintk(KERN_CRIT "ioc3eth(%s): ioremap failed, goodbye.\n",\r\npci_name(pdev));\r\nerr = -ENOMEM;\r\ngoto out_res;\r\n}\r\nip->regs = ioc3;\r\n#ifdef CONFIG_SERIAL_8250\r\nioc3_serial_probe(pdev, ioc3);\r\n#endif\r\nspin_lock_init(&ip->ioc3_lock);\r\ninit_timer(&ip->ioc3_timer);\r\nioc3_stop(ip);\r\nioc3_init(dev);\r\nip->pdev = pdev;\r\nip->mii.phy_id_mask = 0x1f;\r\nip->mii.reg_num_mask = 0x1f;\r\nip->mii.dev = dev;\r\nip->mii.mdio_read = ioc3_mdio_read;\r\nip->mii.mdio_write = ioc3_mdio_write;\r\nioc3_mii_init(ip);\r\nif (ip->mii.phy_id == -1) {\r\nprintk(KERN_CRIT "ioc3-eth(%s): Didn't find a PHY, goodbye.\n",\r\npci_name(pdev));\r\nerr = -ENODEV;\r\ngoto out_stop;\r\n}\r\nioc3_mii_start(ip);\r\nioc3_ssram_disc(ip);\r\nioc3_get_eaddr(ip);\r\ndev->watchdog_timeo = 5 * HZ;\r\ndev->netdev_ops = &ioc3_netdev_ops;\r\ndev->ethtool_ops = &ioc3_ethtool_ops;\r\ndev->hw_features = NETIF_F_IP_CSUM | NETIF_F_RXCSUM;\r\ndev->features = NETIF_F_IP_CSUM;\r\nsw_physid1 = ioc3_mdio_read(dev, ip->mii.phy_id, MII_PHYSID1);\r\nsw_physid2 = ioc3_mdio_read(dev, ip->mii.phy_id, MII_PHYSID2);\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out_stop;\r\nmii_check_media(&ip->mii, 1, 1);\r\nioc3_setup_duplex(ip);\r\nvendor = (sw_physid1 << 12) | (sw_physid2 >> 4);\r\nmodel = (sw_physid2 >> 4) & 0x3f;\r\nrev = sw_physid2 & 0xf;\r\nprintk(KERN_INFO "%s: Using PHY %d, vendor 0x%x, model %d, "\r\n"rev %d.\n", dev->name, ip->mii.phy_id, vendor, model, rev);\r\nprintk(KERN_INFO "%s: IOC3 SSRAM has %d kbyte.\n", dev->name,\r\nip->emcr & EMCR_BUFSIZ ? 128 : 64);\r\nreturn 0;\r\nout_stop:\r\nioc3_stop(ip);\r\ndel_timer_sync(&ip->ioc3_timer);\r\nioc3_free_rings(ip);\r\nout_res:\r\npci_release_regions(pdev);\r\nout_free:\r\nfree_netdev(dev);\r\nout_disable:\r\nout:\r\nreturn err;\r\n}\r\nstatic void __devexit ioc3_remove_one (struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nstruct ioc3 *ioc3 = ip->regs;\r\nunregister_netdev(dev);\r\ndel_timer_sync(&ip->ioc3_timer);\r\niounmap(ioc3);\r\npci_release_regions(pdev);\r\nfree_netdev(dev);\r\n}\r\nstatic int __init ioc3_init_module(void)\r\n{\r\nreturn pci_register_driver(&ioc3_driver);\r\n}\r\nstatic void __exit ioc3_cleanup_module(void)\r\n{\r\npci_unregister_driver(&ioc3_driver);\r\n}\r\nstatic int ioc3_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nunsigned long data;\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nstruct ioc3 *ioc3 = ip->regs;\r\nunsigned int len;\r\nstruct ioc3_etxd *desc;\r\nuint32_t w0 = 0;\r\nint produce;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nconst struct iphdr *ih = ip_hdr(skb);\r\nconst int proto = ntohs(ih->protocol);\r\nunsigned int csoff;\r\nuint32_t csum, ehsum;\r\nuint16_t *eh;\r\neh = (uint16_t *) skb->data;\r\nehsum = eh[0] + eh[1] + eh[2] + eh[3] + eh[4] + eh[5] + eh[6];\r\nehsum = (ehsum & 0xffff) + (ehsum >> 16);\r\nehsum = (ehsum & 0xffff) + (ehsum >> 16);\r\ncsum = csum_tcpudp_nofold(ih->saddr, ih->daddr,\r\nih->tot_len - (ih->ihl << 2),\r\nproto, 0xffff ^ ehsum);\r\ncsum = (csum & 0xffff) + (csum >> 16);\r\ncsum = (csum & 0xffff) + (csum >> 16);\r\ncsoff = ETH_HLEN + (ih->ihl << 2);\r\nif (proto == IPPROTO_UDP) {\r\ncsoff += offsetof(struct udphdr, check);\r\nudp_hdr(skb)->check = csum;\r\n}\r\nif (proto == IPPROTO_TCP) {\r\ncsoff += offsetof(struct tcphdr, check);\r\ntcp_hdr(skb)->check = csum;\r\n}\r\nw0 = ETXD_DOCHECKSUM | (csoff << ETXD_CHKOFF_SHIFT);\r\n}\r\nspin_lock_irq(&ip->ioc3_lock);\r\ndata = (unsigned long) skb->data;\r\nlen = skb->len;\r\nproduce = ip->tx_pi;\r\ndesc = &ip->txr[produce];\r\nif (len <= 104) {\r\nskb_copy_from_linear_data(skb, desc->data, skb->len);\r\nif (len < ETH_ZLEN) {\r\nmemset(desc->data + len, 0, ETH_ZLEN - len);\r\nlen = ETH_ZLEN;\r\n}\r\ndesc->cmd = cpu_to_be32(len | ETXD_INTWHENDONE | ETXD_D0V | w0);\r\ndesc->bufcnt = cpu_to_be32(len);\r\n} else if ((data ^ (data + len - 1)) & 0x4000) {\r\nunsigned long b2 = (data | 0x3fffUL) + 1UL;\r\nunsigned long s1 = b2 - data;\r\nunsigned long s2 = data + len - b2;\r\ndesc->cmd = cpu_to_be32(len | ETXD_INTWHENDONE |\r\nETXD_B1V | ETXD_B2V | w0);\r\ndesc->bufcnt = cpu_to_be32((s1 << ETXD_B1CNT_SHIFT) |\r\n(s2 << ETXD_B2CNT_SHIFT));\r\ndesc->p1 = cpu_to_be64(ioc3_map(skb->data, 1));\r\ndesc->p2 = cpu_to_be64(ioc3_map((void *) b2, 1));\r\n} else {\r\ndesc->cmd = cpu_to_be32(len | ETXD_INTWHENDONE | ETXD_B1V | w0);\r\ndesc->bufcnt = cpu_to_be32(len << ETXD_B1CNT_SHIFT);\r\ndesc->p1 = cpu_to_be64(ioc3_map(skb->data, 1));\r\n}\r\nBARRIER();\r\nip->tx_skbs[produce] = skb;\r\nproduce = (produce + 1) & 127;\r\nip->tx_pi = produce;\r\nioc3_w_etpir(produce << 7);\r\nip->txqlen++;\r\nif (ip->txqlen >= 127)\r\nnetif_stop_queue(dev);\r\nspin_unlock_irq(&ip->ioc3_lock);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void ioc3_timeout(struct net_device *dev)\r\n{\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nprintk(KERN_ERR "%s: transmit timed out, resetting\n", dev->name);\r\nspin_lock_irq(&ip->ioc3_lock);\r\nioc3_stop(ip);\r\nioc3_init(dev);\r\nioc3_mii_init(ip);\r\nioc3_mii_start(ip);\r\nspin_unlock_irq(&ip->ioc3_lock);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic inline unsigned int ioc3_hash(const unsigned char *addr)\r\n{\r\nunsigned int temp = 0;\r\nu32 crc;\r\nint bits;\r\ncrc = ether_crc_le(ETH_ALEN, addr);\r\ncrc &= 0x3f;\r\nfor (bits = 6; --bits >= 0; ) {\r\ntemp <<= 1;\r\ntemp |= (crc & 0x1);\r\ncrc >>= 1;\r\n}\r\nreturn temp;\r\n}\r\nstatic void ioc3_get_drvinfo (struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nstrcpy (info->driver, IOC3_NAME);\r\nstrcpy (info->version, IOC3_VERSION);\r\nstrcpy (info->bus_info, pci_name(ip->pdev));\r\n}\r\nstatic int ioc3_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nint rc;\r\nspin_lock_irq(&ip->ioc3_lock);\r\nrc = mii_ethtool_gset(&ip->mii, cmd);\r\nspin_unlock_irq(&ip->ioc3_lock);\r\nreturn rc;\r\n}\r\nstatic int ioc3_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nint rc;\r\nspin_lock_irq(&ip->ioc3_lock);\r\nrc = mii_ethtool_sset(&ip->mii, cmd);\r\nspin_unlock_irq(&ip->ioc3_lock);\r\nreturn rc;\r\n}\r\nstatic int ioc3_nway_reset(struct net_device *dev)\r\n{\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nint rc;\r\nspin_lock_irq(&ip->ioc3_lock);\r\nrc = mii_nway_restart(&ip->mii);\r\nspin_unlock_irq(&ip->ioc3_lock);\r\nreturn rc;\r\n}\r\nstatic u32 ioc3_get_link(struct net_device *dev)\r\n{\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nint rc;\r\nspin_lock_irq(&ip->ioc3_lock);\r\nrc = mii_link_ok(&ip->mii);\r\nspin_unlock_irq(&ip->ioc3_lock);\r\nreturn rc;\r\n}\r\nstatic int ioc3_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nint rc;\r\nspin_lock_irq(&ip->ioc3_lock);\r\nrc = generic_mii_ioctl(&ip->mii, if_mii(rq), cmd, NULL);\r\nspin_unlock_irq(&ip->ioc3_lock);\r\nreturn rc;\r\n}\r\nstatic void ioc3_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nstruct ioc3_private *ip = netdev_priv(dev);\r\nstruct ioc3 *ioc3 = ip->regs;\r\nu64 ehar = 0;\r\nnetif_stop_queue(dev);\r\nif (dev->flags & IFF_PROMISC) {\r\nip->emcr |= EMCR_PROMISC;\r\nioc3_w_emcr(ip->emcr);\r\n(void) ioc3_r_emcr();\r\n} else {\r\nip->emcr &= ~EMCR_PROMISC;\r\nioc3_w_emcr(ip->emcr);\r\n(void) ioc3_r_emcr();\r\nif ((dev->flags & IFF_ALLMULTI) ||\r\n(netdev_mc_count(dev) > 64)) {\r\nip->ehar_h = 0xffffffff;\r\nip->ehar_l = 0xffffffff;\r\n} else {\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nehar |= (1UL << ioc3_hash(ha->addr));\r\n}\r\nip->ehar_h = ehar >> 32;\r\nip->ehar_l = ehar & 0xffffffff;\r\n}\r\nioc3_w_ehar_h(ip->ehar_h);\r\nioc3_w_ehar_l(ip->ehar_l);\r\n}\r\nnetif_wake_queue(dev);\r\n}
