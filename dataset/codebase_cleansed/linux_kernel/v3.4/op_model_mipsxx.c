static inline unsigned int vpe_shift(void)\r\n{\r\nif (num_possible_cpus() > 1)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline unsigned int vpe_shift(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline unsigned int counters_total_to_per_cpu(unsigned int counters)\r\n{\r\nreturn counters >> vpe_shift();\r\n}\r\nstatic inline unsigned int counters_per_cpu_to_total(unsigned int counters)\r\n{\r\nreturn counters << vpe_shift();\r\n}\r\nstatic void mipsxx_reg_setup(struct op_counter_config *ctr)\r\n{\r\nunsigned int counters = op_model_mipsxx_ops.num_counters;\r\nint i;\r\nfor (i = 0; i < counters; i++) {\r\nreg.control[i] = 0;\r\nreg.counter[i] = 0;\r\nif (!ctr[i].enabled)\r\ncontinue;\r\nreg.control[i] = M_PERFCTL_EVENT(ctr[i].event) |\r\nM_PERFCTL_INTERRUPT_ENABLE;\r\nif (ctr[i].kernel)\r\nreg.control[i] |= M_PERFCTL_KERNEL;\r\nif (ctr[i].user)\r\nreg.control[i] |= M_PERFCTL_USER;\r\nif (ctr[i].exl)\r\nreg.control[i] |= M_PERFCTL_EXL;\r\nreg.counter[i] = 0x80000000 - ctr[i].count;\r\n}\r\n}\r\nstatic void mipsxx_cpu_setup(void *args)\r\n{\r\nunsigned int counters = op_model_mipsxx_ops.num_counters;\r\nswitch (counters) {\r\ncase 4:\r\nw_c0_perfctrl3(0);\r\nw_c0_perfcntr3(reg.counter[3]);\r\ncase 3:\r\nw_c0_perfctrl2(0);\r\nw_c0_perfcntr2(reg.counter[2]);\r\ncase 2:\r\nw_c0_perfctrl1(0);\r\nw_c0_perfcntr1(reg.counter[1]);\r\ncase 1:\r\nw_c0_perfctrl0(0);\r\nw_c0_perfcntr0(reg.counter[0]);\r\n}\r\n}\r\nstatic void mipsxx_cpu_start(void *args)\r\n{\r\nunsigned int counters = op_model_mipsxx_ops.num_counters;\r\nswitch (counters) {\r\ncase 4:\r\nw_c0_perfctrl3(WHAT | reg.control[3]);\r\ncase 3:\r\nw_c0_perfctrl2(WHAT | reg.control[2]);\r\ncase 2:\r\nw_c0_perfctrl1(WHAT | reg.control[1]);\r\ncase 1:\r\nw_c0_perfctrl0(WHAT | reg.control[0]);\r\n}\r\n}\r\nstatic void mipsxx_cpu_stop(void *args)\r\n{\r\nunsigned int counters = op_model_mipsxx_ops.num_counters;\r\nswitch (counters) {\r\ncase 4:\r\nw_c0_perfctrl3(0);\r\ncase 3:\r\nw_c0_perfctrl2(0);\r\ncase 2:\r\nw_c0_perfctrl1(0);\r\ncase 1:\r\nw_c0_perfctrl0(0);\r\n}\r\n}\r\nstatic int mipsxx_perfcount_handler(void)\r\n{\r\nunsigned int counters = op_model_mipsxx_ops.num_counters;\r\nunsigned int control;\r\nunsigned int counter;\r\nint handled = IRQ_NONE;\r\nif (cpu_has_mips_r2 && !(read_c0_cause() & (1 << 26)))\r\nreturn handled;\r\nswitch (counters) {\r\n#define HANDLE_COUNTER(n) \\r\ncase n + 1: \\r\ncontrol = r_c0_perfctrl ## n(); \\r\ncounter = r_c0_perfcntr ## n(); \\r\nif ((control & M_PERFCTL_INTERRUPT_ENABLE) && \\r\n(counter & M_COUNTER_OVERFLOW)) { \\r\noprofile_add_sample(get_irq_regs(), n); \\r\nw_c0_perfcntr ## n(reg.counter[n]); \\r\nhandled = IRQ_HANDLED; \\r\n}\r\nHANDLE_COUNTER(3)\r\nHANDLE_COUNTER(2)\r\nHANDLE_COUNTER(1)\r\nHANDLE_COUNTER(0)\r\n}\r\nreturn handled;\r\n}\r\nstatic inline int __n_counters(void)\r\n{\r\nif (!(read_c0_config1() & M_CONFIG1_PC))\r\nreturn 0;\r\nif (!(read_c0_perfctrl0() & M_PERFCTL_MORE))\r\nreturn 1;\r\nif (!(read_c0_perfctrl1() & M_PERFCTL_MORE))\r\nreturn 2;\r\nif (!(read_c0_perfctrl2() & M_PERFCTL_MORE))\r\nreturn 3;\r\nreturn 4;\r\n}\r\nstatic inline int n_counters(void)\r\n{\r\nint counters;\r\nswitch (current_cpu_type()) {\r\ncase CPU_R10000:\r\ncounters = 2;\r\nbreak;\r\ncase CPU_R12000:\r\ncase CPU_R14000:\r\ncounters = 4;\r\nbreak;\r\ndefault:\r\ncounters = __n_counters();\r\n}\r\nreturn counters;\r\n}\r\nstatic void reset_counters(void *arg)\r\n{\r\nint counters = (int)(long)arg;\r\nswitch (counters) {\r\ncase 4:\r\nw_c0_perfctrl3(0);\r\nw_c0_perfcntr3(0);\r\ncase 3:\r\nw_c0_perfctrl2(0);\r\nw_c0_perfcntr2(0);\r\ncase 2:\r\nw_c0_perfctrl1(0);\r\nw_c0_perfcntr1(0);\r\ncase 1:\r\nw_c0_perfctrl0(0);\r\nw_c0_perfcntr0(0);\r\n}\r\n}\r\nstatic int __init mipsxx_init(void)\r\n{\r\nint counters;\r\ncounters = n_counters();\r\nif (counters == 0) {\r\nprintk(KERN_ERR "Oprofile: CPU has no performance counters\n");\r\nreturn -ENODEV;\r\n}\r\n#ifdef CONFIG_MIPS_MT_SMP\r\ncpu_has_mipsmt_pertccounters = read_c0_config7() & (1<<19);\r\nif (!cpu_has_mipsmt_pertccounters)\r\ncounters = counters_total_to_per_cpu(counters);\r\n#endif\r\non_each_cpu(reset_counters, (void *)(long)counters, 1);\r\nop_model_mipsxx_ops.num_counters = counters;\r\nswitch (current_cpu_type()) {\r\ncase CPU_20KC:\r\nop_model_mipsxx_ops.cpu_type = "mips/20K";\r\nbreak;\r\ncase CPU_24K:\r\nop_model_mipsxx_ops.cpu_type = "mips/24K";\r\nbreak;\r\ncase CPU_25KF:\r\nop_model_mipsxx_ops.cpu_type = "mips/25K";\r\nbreak;\r\ncase CPU_1004K:\r\n#if 0\r\nop_model_mipsxx_ops.cpu_type = "mips/1004K";\r\nbreak;\r\n#endif\r\ncase CPU_34K:\r\nop_model_mipsxx_ops.cpu_type = "mips/34K";\r\nbreak;\r\ncase CPU_74K:\r\nop_model_mipsxx_ops.cpu_type = "mips/74K";\r\nbreak;\r\ncase CPU_5KC:\r\nop_model_mipsxx_ops.cpu_type = "mips/5K";\r\nbreak;\r\ncase CPU_R10000:\r\nif ((current_cpu_data.processor_id & 0xff) == 0x20)\r\nop_model_mipsxx_ops.cpu_type = "mips/r10000-v2.x";\r\nelse\r\nop_model_mipsxx_ops.cpu_type = "mips/r10000";\r\nbreak;\r\ncase CPU_R12000:\r\ncase CPU_R14000:\r\nop_model_mipsxx_ops.cpu_type = "mips/r12000";\r\nbreak;\r\ncase CPU_SB1:\r\ncase CPU_SB1A:\r\nop_model_mipsxx_ops.cpu_type = "mips/sb1";\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Profiling unsupported for this CPU\n");\r\nreturn -ENODEV;\r\n}\r\nsave_perf_irq = perf_irq;\r\nperf_irq = mipsxx_perfcount_handler;\r\nreturn 0;\r\n}\r\nstatic void mipsxx_exit(void)\r\n{\r\nint counters = op_model_mipsxx_ops.num_counters;\r\ncounters = counters_per_cpu_to_total(counters);\r\non_each_cpu(reset_counters, (void *)(long)counters, 1);\r\nperf_irq = save_perf_irq;\r\n}
