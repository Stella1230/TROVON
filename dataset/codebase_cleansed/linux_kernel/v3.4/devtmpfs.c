static int __init mount_param(char *str)\r\n{\r\nmount_dev = simple_strtoul(str, NULL, 0);\r\nreturn 1;\r\n}\r\nstatic struct dentry *dev_mount(struct file_system_type *fs_type, int flags,\r\nconst char *dev_name, void *data)\r\n{\r\n#ifdef CONFIG_TMPFS\r\nreturn mount_single(fs_type, flags, data, shmem_fill_super);\r\n#else\r\nreturn mount_single(fs_type, flags, data, ramfs_fill_super);\r\n#endif\r\n}\r\nstatic inline int is_blockdev(struct device *dev)\r\n{\r\nreturn dev->class == &block_class;\r\n}\r\nstatic inline int is_blockdev(struct device *dev) { return 0; }\r\nint devtmpfs_create_node(struct device *dev)\r\n{\r\nconst char *tmp = NULL;\r\nstruct req req;\r\nif (!thread)\r\nreturn 0;\r\nreq.mode = 0;\r\nreq.name = device_get_devnode(dev, &req.mode, &tmp);\r\nif (!req.name)\r\nreturn -ENOMEM;\r\nif (req.mode == 0)\r\nreq.mode = 0600;\r\nif (is_blockdev(dev))\r\nreq.mode |= S_IFBLK;\r\nelse\r\nreq.mode |= S_IFCHR;\r\nreq.dev = dev;\r\ninit_completion(&req.done);\r\nspin_lock(&req_lock);\r\nreq.next = requests;\r\nrequests = &req;\r\nspin_unlock(&req_lock);\r\nwake_up_process(thread);\r\nwait_for_completion(&req.done);\r\nkfree(tmp);\r\nreturn req.err;\r\n}\r\nint devtmpfs_delete_node(struct device *dev)\r\n{\r\nconst char *tmp = NULL;\r\nstruct req req;\r\nif (!thread)\r\nreturn 0;\r\nreq.name = device_get_devnode(dev, NULL, &tmp);\r\nif (!req.name)\r\nreturn -ENOMEM;\r\nreq.mode = 0;\r\nreq.dev = dev;\r\ninit_completion(&req.done);\r\nspin_lock(&req_lock);\r\nreq.next = requests;\r\nrequests = &req;\r\nspin_unlock(&req_lock);\r\nwake_up_process(thread);\r\nwait_for_completion(&req.done);\r\nkfree(tmp);\r\nreturn req.err;\r\n}\r\nstatic int dev_mkdir(const char *name, umode_t mode)\r\n{\r\nstruct dentry *dentry;\r\nstruct path path;\r\nint err;\r\ndentry = kern_path_create(AT_FDCWD, name, &path, 1);\r\nif (IS_ERR(dentry))\r\nreturn PTR_ERR(dentry);\r\nerr = vfs_mkdir(path.dentry->d_inode, dentry, mode);\r\nif (!err)\r\ndentry->d_inode->i_private = &thread;\r\ndput(dentry);\r\nmutex_unlock(&path.dentry->d_inode->i_mutex);\r\npath_put(&path);\r\nreturn err;\r\n}\r\nstatic int create_path(const char *nodepath)\r\n{\r\nchar *path;\r\nchar *s;\r\nint err = 0;\r\npath = kstrdup(nodepath, GFP_KERNEL);\r\nif (!path)\r\nreturn -ENOMEM;\r\ns = path;\r\nfor (;;) {\r\ns = strchr(s, '/');\r\nif (!s)\r\nbreak;\r\ns[0] = '\0';\r\nerr = dev_mkdir(path, 0755);\r\nif (err && err != -EEXIST)\r\nbreak;\r\ns[0] = '/';\r\ns++;\r\n}\r\nkfree(path);\r\nreturn err;\r\n}\r\nstatic int handle_create(const char *nodename, umode_t mode, struct device *dev)\r\n{\r\nstruct dentry *dentry;\r\nstruct path path;\r\nint err;\r\ndentry = kern_path_create(AT_FDCWD, nodename, &path, 0);\r\nif (dentry == ERR_PTR(-ENOENT)) {\r\ncreate_path(nodename);\r\ndentry = kern_path_create(AT_FDCWD, nodename, &path, 0);\r\n}\r\nif (IS_ERR(dentry))\r\nreturn PTR_ERR(dentry);\r\nerr = vfs_mknod(path.dentry->d_inode,\r\ndentry, mode, dev->devt);\r\nif (!err) {\r\nstruct iattr newattrs;\r\nnewattrs.ia_mode = mode;\r\nnewattrs.ia_valid = ATTR_MODE;\r\nmutex_lock(&dentry->d_inode->i_mutex);\r\nnotify_change(dentry, &newattrs);\r\nmutex_unlock(&dentry->d_inode->i_mutex);\r\ndentry->d_inode->i_private = &thread;\r\n}\r\ndput(dentry);\r\nmutex_unlock(&path.dentry->d_inode->i_mutex);\r\npath_put(&path);\r\nreturn err;\r\n}\r\nstatic int dev_rmdir(const char *name)\r\n{\r\nstruct nameidata nd;\r\nstruct dentry *dentry;\r\nint err;\r\nerr = kern_path_parent(name, &nd);\r\nif (err)\r\nreturn err;\r\nmutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);\r\ndentry = lookup_one_len(nd.last.name, nd.path.dentry, nd.last.len);\r\nif (!IS_ERR(dentry)) {\r\nif (dentry->d_inode) {\r\nif (dentry->d_inode->i_private == &thread)\r\nerr = vfs_rmdir(nd.path.dentry->d_inode,\r\ndentry);\r\nelse\r\nerr = -EPERM;\r\n} else {\r\nerr = -ENOENT;\r\n}\r\ndput(dentry);\r\n} else {\r\nerr = PTR_ERR(dentry);\r\n}\r\nmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\r\npath_put(&nd.path);\r\nreturn err;\r\n}\r\nstatic int delete_path(const char *nodepath)\r\n{\r\nconst char *path;\r\nint err = 0;\r\npath = kstrdup(nodepath, GFP_KERNEL);\r\nif (!path)\r\nreturn -ENOMEM;\r\nfor (;;) {\r\nchar *base;\r\nbase = strrchr(path, '/');\r\nif (!base)\r\nbreak;\r\nbase[0] = '\0';\r\nerr = dev_rmdir(path);\r\nif (err)\r\nbreak;\r\n}\r\nkfree(path);\r\nreturn err;\r\n}\r\nstatic int dev_mynode(struct device *dev, struct inode *inode, struct kstat *stat)\r\n{\r\nif (inode->i_private != &thread)\r\nreturn 0;\r\nif (is_blockdev(dev)) {\r\nif (!S_ISBLK(stat->mode))\r\nreturn 0;\r\n} else {\r\nif (!S_ISCHR(stat->mode))\r\nreturn 0;\r\n}\r\nif (stat->rdev != dev->devt)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int handle_remove(const char *nodename, struct device *dev)\r\n{\r\nstruct nameidata nd;\r\nstruct dentry *dentry;\r\nstruct kstat stat;\r\nint deleted = 1;\r\nint err;\r\nerr = kern_path_parent(nodename, &nd);\r\nif (err)\r\nreturn err;\r\nmutex_lock_nested(&nd.path.dentry->d_inode->i_mutex, I_MUTEX_PARENT);\r\ndentry = lookup_one_len(nd.last.name, nd.path.dentry, nd.last.len);\r\nif (!IS_ERR(dentry)) {\r\nif (dentry->d_inode) {\r\nerr = vfs_getattr(nd.path.mnt, dentry, &stat);\r\nif (!err && dev_mynode(dev, dentry->d_inode, &stat)) {\r\nstruct iattr newattrs;\r\nnewattrs.ia_uid = 0;\r\nnewattrs.ia_gid = 0;\r\nnewattrs.ia_mode = stat.mode & ~0777;\r\nnewattrs.ia_valid =\r\nATTR_UID|ATTR_GID|ATTR_MODE;\r\nmutex_lock(&dentry->d_inode->i_mutex);\r\nnotify_change(dentry, &newattrs);\r\nmutex_unlock(&dentry->d_inode->i_mutex);\r\nerr = vfs_unlink(nd.path.dentry->d_inode,\r\ndentry);\r\nif (!err || err == -ENOENT)\r\ndeleted = 1;\r\n}\r\n} else {\r\nerr = -ENOENT;\r\n}\r\ndput(dentry);\r\n} else {\r\nerr = PTR_ERR(dentry);\r\n}\r\nmutex_unlock(&nd.path.dentry->d_inode->i_mutex);\r\npath_put(&nd.path);\r\nif (deleted && strchr(nodename, '/'))\r\ndelete_path(nodename);\r\nreturn err;\r\n}\r\nint devtmpfs_mount(const char *mntdir)\r\n{\r\nint err;\r\nif (!mount_dev)\r\nreturn 0;\r\nif (!thread)\r\nreturn 0;\r\nerr = sys_mount("devtmpfs", (char *)mntdir, "devtmpfs", MS_SILENT, NULL);\r\nif (err)\r\nprintk(KERN_INFO "devtmpfs: error mounting %i\n", err);\r\nelse\r\nprintk(KERN_INFO "devtmpfs: mounted\n");\r\nreturn err;\r\n}\r\nstatic int handle(const char *name, umode_t mode, struct device *dev)\r\n{\r\nif (mode)\r\nreturn handle_create(name, mode, dev);\r\nelse\r\nreturn handle_remove(name, dev);\r\n}\r\nstatic int devtmpfsd(void *p)\r\n{\r\nchar options[] = "mode=0755";\r\nint *err = p;\r\n*err = sys_unshare(CLONE_NEWNS);\r\nif (*err)\r\ngoto out;\r\n*err = sys_mount("devtmpfs", "/", "devtmpfs", MS_SILENT, options);\r\nif (*err)\r\ngoto out;\r\nsys_chdir("/..");\r\nsys_chroot(".");\r\ncomplete(&setup_done);\r\nwhile (1) {\r\nspin_lock(&req_lock);\r\nwhile (requests) {\r\nstruct req *req = requests;\r\nrequests = NULL;\r\nspin_unlock(&req_lock);\r\nwhile (req) {\r\nstruct req *next = req->next;\r\nreq->err = handle(req->name, req->mode, req->dev);\r\ncomplete(&req->done);\r\nreq = next;\r\n}\r\nspin_lock(&req_lock);\r\n}\r\n__set_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock(&req_lock);\r\nschedule();\r\n}\r\nreturn 0;\r\nout:\r\ncomplete(&setup_done);\r\nreturn *err;\r\n}\r\nint __init devtmpfs_init(void)\r\n{\r\nint err = register_filesystem(&dev_fs_type);\r\nif (err) {\r\nprintk(KERN_ERR "devtmpfs: unable to register devtmpfs "\r\n"type %i\n", err);\r\nreturn err;\r\n}\r\nthread = kthread_run(devtmpfsd, &err, "kdevtmpfs");\r\nif (!IS_ERR(thread)) {\r\nwait_for_completion(&setup_done);\r\n} else {\r\nerr = PTR_ERR(thread);\r\nthread = NULL;\r\n}\r\nif (err) {\r\nprintk(KERN_ERR "devtmpfs: unable to create devtmpfs %i\n", err);\r\nunregister_filesystem(&dev_fs_type);\r\nreturn err;\r\n}\r\nprintk(KERN_INFO "devtmpfs: initialized\n");\r\nreturn 0;\r\n}
