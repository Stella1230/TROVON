static bool nsec_valid(long nsec)\r\n{\r\nif (nsec == UTIME_OMIT || nsec == UTIME_NOW)\r\nreturn true;\r\nreturn nsec >= 0 && nsec <= 999999999;\r\n}\r\nstatic int utimes_common(struct path *path, struct timespec *times)\r\n{\r\nint error;\r\nstruct iattr newattrs;\r\nstruct inode *inode = path->dentry->d_inode;\r\nerror = mnt_want_write(path->mnt);\r\nif (error)\r\ngoto out;\r\nif (times && times[0].tv_nsec == UTIME_NOW &&\r\ntimes[1].tv_nsec == UTIME_NOW)\r\ntimes = NULL;\r\nnewattrs.ia_valid = ATTR_CTIME | ATTR_MTIME | ATTR_ATIME;\r\nif (times) {\r\nif (times[0].tv_nsec == UTIME_OMIT)\r\nnewattrs.ia_valid &= ~ATTR_ATIME;\r\nelse if (times[0].tv_nsec != UTIME_NOW) {\r\nnewattrs.ia_atime.tv_sec = times[0].tv_sec;\r\nnewattrs.ia_atime.tv_nsec = times[0].tv_nsec;\r\nnewattrs.ia_valid |= ATTR_ATIME_SET;\r\n}\r\nif (times[1].tv_nsec == UTIME_OMIT)\r\nnewattrs.ia_valid &= ~ATTR_MTIME;\r\nelse if (times[1].tv_nsec != UTIME_NOW) {\r\nnewattrs.ia_mtime.tv_sec = times[1].tv_sec;\r\nnewattrs.ia_mtime.tv_nsec = times[1].tv_nsec;\r\nnewattrs.ia_valid |= ATTR_MTIME_SET;\r\n}\r\nnewattrs.ia_valid |= ATTR_TIMES_SET;\r\n} else {\r\nerror = -EACCES;\r\nif (IS_IMMUTABLE(inode))\r\ngoto mnt_drop_write_and_out;\r\nif (!inode_owner_or_capable(inode)) {\r\nerror = inode_permission(inode, MAY_WRITE);\r\nif (error)\r\ngoto mnt_drop_write_and_out;\r\n}\r\n}\r\nmutex_lock(&inode->i_mutex);\r\nerror = notify_change(path->dentry, &newattrs);\r\nmutex_unlock(&inode->i_mutex);\r\nmnt_drop_write_and_out:\r\nmnt_drop_write(path->mnt);\r\nout:\r\nreturn error;\r\n}\r\nlong do_utimes(int dfd, const char __user *filename, struct timespec *times,\r\nint flags)\r\n{\r\nint error = -EINVAL;\r\nif (times && (!nsec_valid(times[0].tv_nsec) ||\r\n!nsec_valid(times[1].tv_nsec))) {\r\ngoto out;\r\n}\r\nif (flags & ~AT_SYMLINK_NOFOLLOW)\r\ngoto out;\r\nif (filename == NULL && dfd != AT_FDCWD) {\r\nstruct file *file;\r\nif (flags & AT_SYMLINK_NOFOLLOW)\r\ngoto out;\r\nfile = fget(dfd);\r\nerror = -EBADF;\r\nif (!file)\r\ngoto out;\r\nerror = utimes_common(&file->f_path, times);\r\nfput(file);\r\n} else {\r\nstruct path path;\r\nint lookup_flags = 0;\r\nif (!(flags & AT_SYMLINK_NOFOLLOW))\r\nlookup_flags |= LOOKUP_FOLLOW;\r\nerror = user_path_at(dfd, filename, lookup_flags, &path);\r\nif (error)\r\ngoto out;\r\nerror = utimes_common(&path, times);\r\npath_put(&path);\r\n}\r\nout:\r\nreturn error;\r\n}
