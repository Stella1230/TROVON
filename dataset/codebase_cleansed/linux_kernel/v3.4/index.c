ntfs_index_context *ntfs_index_ctx_get(ntfs_inode *idx_ni)\r\n{\r\nntfs_index_context *ictx;\r\nictx = kmem_cache_alloc(ntfs_index_ctx_cache, GFP_NOFS);\r\nif (ictx)\r\n*ictx = (ntfs_index_context){ .idx_ni = idx_ni };\r\nreturn ictx;\r\n}\r\nvoid ntfs_index_ctx_put(ntfs_index_context *ictx)\r\n{\r\nif (ictx->entry) {\r\nif (ictx->is_in_root) {\r\nif (ictx->actx)\r\nntfs_attr_put_search_ctx(ictx->actx);\r\nif (ictx->base_ni)\r\nunmap_mft_record(ictx->base_ni);\r\n} else {\r\nstruct page *page = ictx->page;\r\nif (page) {\r\nBUG_ON(!PageLocked(page));\r\nunlock_page(page);\r\nntfs_unmap_page(page);\r\n}\r\n}\r\n}\r\nkmem_cache_free(ntfs_index_ctx_cache, ictx);\r\nreturn;\r\n}\r\nint ntfs_index_lookup(const void *key, const int key_len,\r\nntfs_index_context *ictx)\r\n{\r\nVCN vcn, old_vcn;\r\nntfs_inode *idx_ni = ictx->idx_ni;\r\nntfs_volume *vol = idx_ni->vol;\r\nstruct super_block *sb = vol->sb;\r\nntfs_inode *base_ni = idx_ni->ext.base_ntfs_ino;\r\nMFT_RECORD *m;\r\nINDEX_ROOT *ir;\r\nINDEX_ENTRY *ie;\r\nINDEX_ALLOCATION *ia;\r\nu8 *index_end, *kaddr;\r\nntfs_attr_search_ctx *actx;\r\nstruct address_space *ia_mapping;\r\nstruct page *page;\r\nint rc, err = 0;\r\nntfs_debug("Entering.");\r\nBUG_ON(!NInoAttr(idx_ni));\r\nBUG_ON(idx_ni->type != AT_INDEX_ALLOCATION);\r\nBUG_ON(idx_ni->nr_extents != -1);\r\nBUG_ON(!base_ni);\r\nBUG_ON(!key);\r\nBUG_ON(key_len <= 0);\r\nif (!ntfs_is_collation_rule_supported(\r\nidx_ni->itype.index.collation_rule)) {\r\nntfs_error(sb, "Index uses unsupported collation rule 0x%x. "\r\n"Aborting lookup.", le32_to_cpu(\r\nidx_ni->itype.index.collation_rule));\r\nreturn -EOPNOTSUPP;\r\n}\r\nm = map_mft_record(base_ni);\r\nif (IS_ERR(m)) {\r\nntfs_error(sb, "map_mft_record() failed with error code %ld.",\r\n-PTR_ERR(m));\r\nreturn PTR_ERR(m);\r\n}\r\nactx = ntfs_attr_get_search_ctx(base_ni, m);\r\nif (unlikely(!actx)) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nerr = ntfs_attr_lookup(AT_INDEX_ROOT, idx_ni->name, idx_ni->name_len,\r\nCASE_SENSITIVE, 0, NULL, 0, actx);\r\nif (unlikely(err)) {\r\nif (err == -ENOENT) {\r\nntfs_error(sb, "Index root attribute missing in inode "\r\n"0x%lx.", idx_ni->mft_no);\r\nerr = -EIO;\r\n}\r\ngoto err_out;\r\n}\r\nir = (INDEX_ROOT*)((u8*)actx->attr +\r\nle16_to_cpu(actx->attr->data.resident.value_offset));\r\nindex_end = (u8*)&ir->index + le32_to_cpu(ir->index.index_length);\r\nie = (INDEX_ENTRY*)((u8*)&ir->index +\r\nle32_to_cpu(ir->index.entries_offset));\r\nfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\r\nif ((u8*)ie < (u8*)actx->mrec || (u8*)ie +\r\nsizeof(INDEX_ENTRY_HEADER) > index_end ||\r\n(u8*)ie + le16_to_cpu(ie->length) > index_end)\r\ngoto idx_err_out;\r\nif (ie->flags & INDEX_ENTRY_END)\r\nbreak;\r\nif ((u32)sizeof(INDEX_ENTRY_HEADER) +\r\nle16_to_cpu(ie->key_length) >\r\nle16_to_cpu(ie->data.vi.data_offset) ||\r\n(u32)le16_to_cpu(ie->data.vi.data_offset) +\r\nle16_to_cpu(ie->data.vi.data_length) >\r\nle16_to_cpu(ie->length))\r\ngoto idx_err_out;\r\nif ((key_len == le16_to_cpu(ie->key_length)) && !memcmp(key,\r\n&ie->key, key_len)) {\r\nir_done:\r\nictx->is_in_root = true;\r\nictx->ir = ir;\r\nictx->actx = actx;\r\nictx->base_ni = base_ni;\r\nictx->ia = NULL;\r\nictx->page = NULL;\r\ndone:\r\nictx->entry = ie;\r\nictx->data = (u8*)ie +\r\nle16_to_cpu(ie->data.vi.data_offset);\r\nictx->data_len = le16_to_cpu(ie->data.vi.data_length);\r\nntfs_debug("Done.");\r\nreturn err;\r\n}\r\nrc = ntfs_collate(vol, idx_ni->itype.index.collation_rule, key,\r\nkey_len, &ie->key, le16_to_cpu(ie->key_length));\r\nif (rc == -1)\r\nbreak;\r\nif (!rc)\r\ngoto ir_done;\r\n}\r\nif (!(ie->flags & INDEX_ENTRY_NODE)) {\r\nntfs_debug("Entry not found.");\r\nerr = -ENOENT;\r\ngoto ir_done;\r\n}\r\nif (!NInoIndexAllocPresent(idx_ni)) {\r\nntfs_error(sb, "No index allocation attribute but index entry "\r\n"requires one. Inode 0x%lx is corrupt or "\r\n"driver bug.", idx_ni->mft_no);\r\ngoto err_out;\r\n}\r\nvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\r\nia_mapping = VFS_I(idx_ni)->i_mapping;\r\nntfs_attr_put_search_ctx(actx);\r\nunmap_mft_record(base_ni);\r\nm = NULL;\r\nactx = NULL;\r\ndescend_into_child_node:\r\npage = ntfs_map_page(ia_mapping, vcn <<\r\nidx_ni->itype.index.vcn_size_bits >> PAGE_CACHE_SHIFT);\r\nif (IS_ERR(page)) {\r\nntfs_error(sb, "Failed to map index page, error %ld.",\r\n-PTR_ERR(page));\r\nerr = PTR_ERR(page);\r\ngoto err_out;\r\n}\r\nlock_page(page);\r\nkaddr = (u8*)page_address(page);\r\nfast_descend_into_child_node:\r\nia = (INDEX_ALLOCATION*)(kaddr + ((vcn <<\r\nidx_ni->itype.index.vcn_size_bits) & ~PAGE_CACHE_MASK));\r\nif ((u8*)ia < kaddr || (u8*)ia > kaddr + PAGE_CACHE_SIZE) {\r\nntfs_error(sb, "Out of bounds check failed. Corrupt inode "\r\n"0x%lx or driver bug.", idx_ni->mft_no);\r\ngoto unm_err_out;\r\n}\r\nif (unlikely(!ntfs_is_indx_record(ia->magic))) {\r\nntfs_error(sb, "Index record with vcn 0x%llx is corrupt. "\r\n"Corrupt inode 0x%lx. Run chkdsk.",\r\n(long long)vcn, idx_ni->mft_no);\r\ngoto unm_err_out;\r\n}\r\nif (sle64_to_cpu(ia->index_block_vcn) != vcn) {\r\nntfs_error(sb, "Actual VCN (0x%llx) of index buffer is "\r\n"different from expected VCN (0x%llx). Inode "\r\n"0x%lx is corrupt or driver bug.",\r\n(unsigned long long)\r\nsle64_to_cpu(ia->index_block_vcn),\r\n(unsigned long long)vcn, idx_ni->mft_no);\r\ngoto unm_err_out;\r\n}\r\nif (le32_to_cpu(ia->index.allocated_size) + 0x18 !=\r\nidx_ni->itype.index.block_size) {\r\nntfs_error(sb, "Index buffer (VCN 0x%llx) of inode 0x%lx has "\r\n"a size (%u) differing from the index "\r\n"specified size (%u). Inode is corrupt or "\r\n"driver bug.", (unsigned long long)vcn,\r\nidx_ni->mft_no,\r\nle32_to_cpu(ia->index.allocated_size) + 0x18,\r\nidx_ni->itype.index.block_size);\r\ngoto unm_err_out;\r\n}\r\nindex_end = (u8*)ia + idx_ni->itype.index.block_size;\r\nif (index_end > kaddr + PAGE_CACHE_SIZE) {\r\nntfs_error(sb, "Index buffer (VCN 0x%llx) of inode 0x%lx "\r\n"crosses page boundary. Impossible! Cannot "\r\n"access! This is probably a bug in the "\r\n"driver.", (unsigned long long)vcn,\r\nidx_ni->mft_no);\r\ngoto unm_err_out;\r\n}\r\nindex_end = (u8*)&ia->index + le32_to_cpu(ia->index.index_length);\r\nif (index_end > (u8*)ia + idx_ni->itype.index.block_size) {\r\nntfs_error(sb, "Size of index buffer (VCN 0x%llx) of inode "\r\n"0x%lx exceeds maximum size.",\r\n(unsigned long long)vcn, idx_ni->mft_no);\r\ngoto unm_err_out;\r\n}\r\nie = (INDEX_ENTRY*)((u8*)&ia->index +\r\nle32_to_cpu(ia->index.entries_offset));\r\nfor (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {\r\nif ((u8*)ie < (u8*)ia || (u8*)ie +\r\nsizeof(INDEX_ENTRY_HEADER) > index_end ||\r\n(u8*)ie + le16_to_cpu(ie->length) > index_end) {\r\nntfs_error(sb, "Index entry out of bounds in inode "\r\n"0x%lx.", idx_ni->mft_no);\r\ngoto unm_err_out;\r\n}\r\nif (ie->flags & INDEX_ENTRY_END)\r\nbreak;\r\nif ((u32)sizeof(INDEX_ENTRY_HEADER) +\r\nle16_to_cpu(ie->key_length) >\r\nle16_to_cpu(ie->data.vi.data_offset) ||\r\n(u32)le16_to_cpu(ie->data.vi.data_offset) +\r\nle16_to_cpu(ie->data.vi.data_length) >\r\nle16_to_cpu(ie->length)) {\r\nntfs_error(sb, "Index entry out of bounds in inode "\r\n"0x%lx.", idx_ni->mft_no);\r\ngoto unm_err_out;\r\n}\r\nif ((key_len == le16_to_cpu(ie->key_length)) && !memcmp(key,\r\n&ie->key, key_len)) {\r\nia_done:\r\nictx->is_in_root = false;\r\nictx->actx = NULL;\r\nictx->base_ni = NULL;\r\nictx->ia = ia;\r\nictx->page = page;\r\ngoto done;\r\n}\r\nrc = ntfs_collate(vol, idx_ni->itype.index.collation_rule, key,\r\nkey_len, &ie->key, le16_to_cpu(ie->key_length));\r\nif (rc == -1)\r\nbreak;\r\nif (!rc)\r\ngoto ia_done;\r\n}\r\nif (!(ie->flags & INDEX_ENTRY_NODE)) {\r\nntfs_debug("Entry not found.");\r\nerr = -ENOENT;\r\ngoto ia_done;\r\n}\r\nif ((ia->index.flags & NODE_MASK) == LEAF_NODE) {\r\nntfs_error(sb, "Index entry with child node found in a leaf "\r\n"node in inode 0x%lx.", idx_ni->mft_no);\r\ngoto unm_err_out;\r\n}\r\nold_vcn = vcn;\r\nvcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie->length) - 8));\r\nif (vcn >= 0) {\r\nif (old_vcn << vol->cluster_size_bits >>\r\nPAGE_CACHE_SHIFT == vcn <<\r\nvol->cluster_size_bits >>\r\nPAGE_CACHE_SHIFT)\r\ngoto fast_descend_into_child_node;\r\nunlock_page(page);\r\nntfs_unmap_page(page);\r\ngoto descend_into_child_node;\r\n}\r\nntfs_error(sb, "Negative child node vcn in inode 0x%lx.",\r\nidx_ni->mft_no);\r\nunm_err_out:\r\nunlock_page(page);\r\nntfs_unmap_page(page);\r\nerr_out:\r\nif (!err)\r\nerr = -EIO;\r\nif (actx)\r\nntfs_attr_put_search_ctx(actx);\r\nif (m)\r\nunmap_mft_record(base_ni);\r\nreturn err;\r\nidx_err_out:\r\nntfs_error(sb, "Corrupt index. Aborting lookup.");\r\ngoto err_out;\r\n}
