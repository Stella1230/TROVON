static void keyspan_print(struct usb_keyspan* dev)\r\n{\r\nchar codes[4 * RECV_SIZE];\r\nint i;\r\nfor (i = 0; i < RECV_SIZE; i++)\r\nsnprintf(codes + i * 3, 4, "%02x ", dev->in_buffer[i]);\r\ndev_info(&dev->udev->dev, "%s\n", codes);\r\n}\r\nstatic int keyspan_load_tester(struct usb_keyspan* dev, int bits_needed)\r\n{\r\nif (dev->data.bits_left >= bits_needed)\r\nreturn 0;\r\nif (dev->data.pos >= dev->data.len) {\r\ndev_dbg(&dev->udev->dev,\r\n"%s - Error ran out of data. pos: %d, len: %d\n",\r\n__func__, dev->data.pos, dev->data.len);\r\nreturn -1;\r\n}\r\nwhile ((dev->data.bits_left + 7 < (sizeof(dev->data.tester) * 8)) &&\r\n(dev->data.pos < dev->data.len)) {\r\ndev->data.tester += (dev->data.buffer[dev->data.pos++] << dev->data.bits_left);\r\ndev->data.bits_left += 8;\r\n}\r\nreturn 0;\r\n}\r\nstatic void keyspan_report_button(struct usb_keyspan *remote, int button, int press)\r\n{\r\nstruct input_dev *input = remote->input;\r\ninput_event(input, EV_MSC, MSC_SCAN, button);\r\ninput_report_key(input, remote->keymap[button], press);\r\ninput_sync(input);\r\n}\r\nstatic void keyspan_check_data(struct usb_keyspan *remote)\r\n{\r\nint i;\r\nint found = 0;\r\nstruct keyspan_message message;\r\nswitch(remote->stage) {\r\ncase 0:\r\nfor (i = 0; i < RECV_SIZE && remote->in_buffer[i] == GAP; ++i);\r\nif (i < RECV_SIZE) {\r\nmemcpy(remote->data.buffer, remote->in_buffer, RECV_SIZE);\r\nremote->data.len = RECV_SIZE;\r\nremote->data.pos = 0;\r\nremote->data.tester = 0;\r\nremote->data.bits_left = 0;\r\nremote->stage = 1;\r\n}\r\nbreak;\r\ncase 1:\r\nmemcpy(remote->data.buffer + remote->data.len, remote->in_buffer, RECV_SIZE);\r\nremote->data.len += RECV_SIZE;\r\nfound = 0;\r\nwhile ((remote->data.bits_left >= 14 || remote->data.pos < remote->data.len) && !found) {\r\nfor (i = 0; i < 8; ++i) {\r\nif (keyspan_load_tester(remote, 14) != 0) {\r\nremote->stage = 0;\r\nreturn;\r\n}\r\nif ((remote->data.tester & SYNC_MASK) == SYNC) {\r\nremote->data.tester = remote->data.tester >> 14;\r\nremote->data.bits_left -= 14;\r\nfound = 1;\r\nbreak;\r\n} else {\r\nremote->data.tester = remote->data.tester >> 1;\r\n--remote->data.bits_left;\r\n}\r\n}\r\n}\r\nif (!found) {\r\nremote->stage = 0;\r\nremote->data.len = 0;\r\n} else {\r\nremote->stage = 2;\r\n}\r\nbreak;\r\ncase 2:\r\nmemcpy(remote->data.buffer + remote->data.len, remote->in_buffer, RECV_SIZE);\r\nremote->data.len += RECV_SIZE;\r\nmessage.system = 0;\r\nfor (i = 0; i < 9; i++) {\r\nkeyspan_load_tester(remote, 6);\r\nif ((remote->data.tester & ZERO_MASK) == ZERO) {\r\nmessage.system = message.system << 1;\r\nremote->data.tester = remote->data.tester >> 5;\r\nremote->data.bits_left -= 5;\r\n} else if ((remote->data.tester & ONE_MASK) == ONE) {\r\nmessage.system = (message.system << 1) + 1;\r\nremote->data.tester = remote->data.tester >> 6;\r\nremote->data.bits_left -= 6;\r\n} else {\r\nerr("%s - Unknown sequence found in system data.\n", __func__);\r\nremote->stage = 0;\r\nreturn;\r\n}\r\n}\r\nmessage.button = 0;\r\nfor (i = 0; i < 5; i++) {\r\nkeyspan_load_tester(remote, 6);\r\nif ((remote->data.tester & ZERO_MASK) == ZERO) {\r\nmessage.button = message.button << 1;\r\nremote->data.tester = remote->data.tester >> 5;\r\nremote->data.bits_left -= 5;\r\n} else if ((remote->data.tester & ONE_MASK) == ONE) {\r\nmessage.button = (message.button << 1) + 1;\r\nremote->data.tester = remote->data.tester >> 6;\r\nremote->data.bits_left -= 6;\r\n} else {\r\nerr("%s - Unknown sequence found in button data.\n", __func__);\r\nremote->stage = 0;\r\nreturn;\r\n}\r\n}\r\nkeyspan_load_tester(remote, 6);\r\nif ((remote->data.tester & ZERO_MASK) == ZERO) {\r\nmessage.toggle = 0;\r\nremote->data.tester = remote->data.tester >> 5;\r\nremote->data.bits_left -= 5;\r\n} else if ((remote->data.tester & ONE_MASK) == ONE) {\r\nmessage.toggle = 1;\r\nremote->data.tester = remote->data.tester >> 6;\r\nremote->data.bits_left -= 6;\r\n} else {\r\nerr("%s - Error in message, invalid toggle.\n", __func__);\r\nremote->stage = 0;\r\nreturn;\r\n}\r\nkeyspan_load_tester(remote, 5);\r\nif ((remote->data.tester & STOP_MASK) == STOP) {\r\nremote->data.tester = remote->data.tester >> 5;\r\nremote->data.bits_left -= 5;\r\n} else {\r\nerr("Bad message received, no stop bit found.\n");\r\n}\r\ndev_dbg(&remote->udev->dev,\r\n"%s found valid message: system: %d, button: %d, toggle: %d\n",\r\n__func__, message.system, message.button, message.toggle);\r\nif (message.toggle != remote->toggle) {\r\nkeyspan_report_button(remote, message.button, 1);\r\nkeyspan_report_button(remote, message.button, 0);\r\nremote->toggle = message.toggle;\r\n}\r\nremote->stage = 0;\r\nbreak;\r\n}\r\n}\r\nstatic int keyspan_setup(struct usb_device* dev)\r\n{\r\nint retval = 0;\r\nretval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\n0x11, 0x40, 0x5601, 0x0, NULL, 0, 0);\r\nif (retval) {\r\ndev_dbg(&dev->dev, "%s - failed to set bit rate due to error: %d\n",\r\n__func__, retval);\r\nreturn(retval);\r\n}\r\nretval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\n0x44, 0x40, 0x0, 0x0, NULL, 0, 0);\r\nif (retval) {\r\ndev_dbg(&dev->dev, "%s - failed to set resume sensitivity due to error: %d\n",\r\n__func__, retval);\r\nreturn(retval);\r\n}\r\nretval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\n0x22, 0x40, 0x0, 0x0, NULL, 0, 0);\r\nif (retval) {\r\ndev_dbg(&dev->dev, "%s - failed to turn receive on due to error: %d\n",\r\n__func__, retval);\r\nreturn(retval);\r\n}\r\ndev_dbg(&dev->dev, "%s - Setup complete.\n", __func__);\r\nreturn(retval);\r\n}\r\nstatic void keyspan_irq_recv(struct urb *urb)\r\n{\r\nstruct usb_keyspan *dev = urb->context;\r\nint retval;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ngoto resubmit;\r\nbreak;\r\n}\r\nif (debug)\r\nkeyspan_print(dev);\r\nkeyspan_check_data(dev);\r\nresubmit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\nerr ("%s - usb_submit_urb failed with result: %d", __func__, retval);\r\n}\r\nstatic int keyspan_open(struct input_dev *dev)\r\n{\r\nstruct usb_keyspan *remote = input_get_drvdata(dev);\r\nremote->irq_urb->dev = remote->udev;\r\nif (usb_submit_urb(remote->irq_urb, GFP_KERNEL))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void keyspan_close(struct input_dev *dev)\r\n{\r\nstruct usb_keyspan *remote = input_get_drvdata(dev);\r\nusb_kill_urb(remote->irq_urb);\r\n}\r\nstatic struct usb_endpoint_descriptor *keyspan_get_in_endpoint(struct usb_host_interface *iface)\r\n{\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint i;\r\nfor (i = 0; i < iface->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface->endpoint[i].desc;\r\nif (usb_endpoint_is_int_in(endpoint)) {\r\nreturn endpoint;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int keyspan_probe(struct usb_interface *interface, const struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(interface);\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct usb_keyspan *remote;\r\nstruct input_dev *input_dev;\r\nint i, error;\r\nendpoint = keyspan_get_in_endpoint(interface->cur_altsetting);\r\nif (!endpoint)\r\nreturn -ENODEV;\r\nremote = kzalloc(sizeof(*remote), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!remote || !input_dev) {\r\nerror = -ENOMEM;\r\ngoto fail1;\r\n}\r\nremote->udev = udev;\r\nremote->input = input_dev;\r\nremote->interface = interface;\r\nremote->in_endpoint = endpoint;\r\nremote->toggle = -1;\r\nremote->in_buffer = usb_alloc_coherent(udev, RECV_SIZE, GFP_ATOMIC, &remote->in_dma);\r\nif (!remote->in_buffer) {\r\nerror = -ENOMEM;\r\ngoto fail1;\r\n}\r\nremote->irq_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!remote->irq_urb) {\r\nerror = -ENOMEM;\r\ngoto fail2;\r\n}\r\nerror = keyspan_setup(udev);\r\nif (error) {\r\nerror = -ENODEV;\r\ngoto fail3;\r\n}\r\nif (udev->manufacturer)\r\nstrlcpy(remote->name, udev->manufacturer, sizeof(remote->name));\r\nif (udev->product) {\r\nif (udev->manufacturer)\r\nstrlcat(remote->name, " ", sizeof(remote->name));\r\nstrlcat(remote->name, udev->product, sizeof(remote->name));\r\n}\r\nif (!strlen(remote->name))\r\nsnprintf(remote->name, sizeof(remote->name),\r\n"USB Keyspan Remote %04x:%04x",\r\nle16_to_cpu(udev->descriptor.idVendor),\r\nle16_to_cpu(udev->descriptor.idProduct));\r\nusb_make_path(udev, remote->phys, sizeof(remote->phys));\r\nstrlcat(remote->phys, "/input0", sizeof(remote->phys));\r\nmemcpy(remote->keymap, keyspan_key_table, sizeof(remote->keymap));\r\ninput_dev->name = remote->name;\r\ninput_dev->phys = remote->phys;\r\nusb_to_input_id(udev, &input_dev->id);\r\ninput_dev->dev.parent = &interface->dev;\r\ninput_dev->keycode = remote->keymap;\r\ninput_dev->keycodesize = sizeof(unsigned short);\r\ninput_dev->keycodemax = ARRAY_SIZE(remote->keymap);\r\ninput_set_capability(input_dev, EV_MSC, MSC_SCAN);\r\n__set_bit(EV_KEY, input_dev->evbit);\r\nfor (i = 0; i < ARRAY_SIZE(keyspan_key_table); i++)\r\n__set_bit(keyspan_key_table[i], input_dev->keybit);\r\n__clear_bit(KEY_RESERVED, input_dev->keybit);\r\ninput_set_drvdata(input_dev, remote);\r\ninput_dev->open = keyspan_open;\r\ninput_dev->close = keyspan_close;\r\nusb_fill_int_urb(remote->irq_urb,\r\nremote->udev,\r\nusb_rcvintpipe(remote->udev, endpoint->bEndpointAddress),\r\nremote->in_buffer, RECV_SIZE, keyspan_irq_recv, remote,\r\nendpoint->bInterval);\r\nremote->irq_urb->transfer_dma = remote->in_dma;\r\nremote->irq_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nerror = input_register_device(remote->input);\r\nif (error)\r\ngoto fail3;\r\nusb_set_intfdata(interface, remote);\r\nreturn 0;\r\nfail3: usb_free_urb(remote->irq_urb);\r\nfail2: usb_free_coherent(udev, RECV_SIZE, remote->in_buffer, remote->in_dma);\r\nfail1: kfree(remote);\r\ninput_free_device(input_dev);\r\nreturn error;\r\n}\r\nstatic void keyspan_disconnect(struct usb_interface *interface)\r\n{\r\nstruct usb_keyspan *remote;\r\nremote = usb_get_intfdata(interface);\r\nusb_set_intfdata(interface, NULL);\r\nif (remote) {\r\ninput_unregister_device(remote->input);\r\nusb_kill_urb(remote->irq_urb);\r\nusb_free_urb(remote->irq_urb);\r\nusb_free_coherent(remote->udev, RECV_SIZE, remote->in_buffer, remote->in_dma);\r\nkfree(remote);\r\n}\r\n}
