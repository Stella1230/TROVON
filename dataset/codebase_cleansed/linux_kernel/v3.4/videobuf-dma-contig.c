static void\r\nvideobuf_vm_open(struct vm_area_struct *vma)\r\n{\r\nstruct videobuf_mapping *map = vma->vm_private_data;\r\ndev_dbg(map->q->dev, "vm_open %p [count=%u,vma=%08lx-%08lx]\n",\r\nmap, map->count, vma->vm_start, vma->vm_end);\r\nmap->count++;\r\n}\r\nstatic void videobuf_vm_close(struct vm_area_struct *vma)\r\n{\r\nstruct videobuf_mapping *map = vma->vm_private_data;\r\nstruct videobuf_queue *q = map->q;\r\nint i;\r\ndev_dbg(q->dev, "vm_close %p [count=%u,vma=%08lx-%08lx]\n",\r\nmap, map->count, vma->vm_start, vma->vm_end);\r\nmap->count--;\r\nif (0 == map->count) {\r\nstruct videobuf_dma_contig_memory *mem;\r\ndev_dbg(q->dev, "munmap %p q=%p\n", map, q);\r\nvideobuf_queue_lock(q);\r\nif (q->streaming)\r\nvideobuf_queue_cancel(q);\r\nfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\r\nif (NULL == q->bufs[i])\r\ncontinue;\r\nif (q->bufs[i]->map != map)\r\ncontinue;\r\nmem = q->bufs[i]->priv;\r\nif (mem) {\r\nMAGIC_CHECK(mem->magic, MAGIC_DC_MEM);\r\ndev_dbg(q->dev, "buf[%d] freeing %p\n",\r\ni, mem->vaddr);\r\ndma_free_coherent(q->dev, mem->size,\r\nmem->vaddr, mem->dma_handle);\r\nmem->vaddr = NULL;\r\n}\r\nq->bufs[i]->map = NULL;\r\nq->bufs[i]->baddr = 0;\r\n}\r\nkfree(map);\r\nvideobuf_queue_unlock(q);\r\n}\r\n}\r\nstatic void videobuf_dma_contig_user_put(struct videobuf_dma_contig_memory *mem)\r\n{\r\nmem->dma_handle = 0;\r\nmem->size = 0;\r\n}\r\nstatic int videobuf_dma_contig_user_get(struct videobuf_dma_contig_memory *mem,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct mm_struct *mm = current->mm;\r\nstruct vm_area_struct *vma;\r\nunsigned long prev_pfn, this_pfn;\r\nunsigned long pages_done, user_address;\r\nunsigned int offset;\r\nint ret;\r\noffset = vb->baddr & ~PAGE_MASK;\r\nmem->size = PAGE_ALIGN(vb->size + offset);\r\nret = -EINVAL;\r\ndown_read(&mm->mmap_sem);\r\nvma = find_vma(mm, vb->baddr);\r\nif (!vma)\r\ngoto out_up;\r\nif ((vb->baddr + mem->size) > vma->vm_end)\r\ngoto out_up;\r\npages_done = 0;\r\nprev_pfn = 0;\r\nuser_address = vb->baddr;\r\nwhile (pages_done < (mem->size >> PAGE_SHIFT)) {\r\nret = follow_pfn(vma, user_address, &this_pfn);\r\nif (ret)\r\nbreak;\r\nif (pages_done == 0)\r\nmem->dma_handle = (this_pfn << PAGE_SHIFT) + offset;\r\nelse if (this_pfn != (prev_pfn + 1))\r\nret = -EFAULT;\r\nif (ret)\r\nbreak;\r\nprev_pfn = this_pfn;\r\nuser_address += PAGE_SIZE;\r\npages_done++;\r\n}\r\nout_up:\r\nup_read(&current->mm->mmap_sem);\r\nreturn ret;\r\n}\r\nstatic struct videobuf_buffer *__videobuf_alloc_vb(size_t size)\r\n{\r\nstruct videobuf_dma_contig_memory *mem;\r\nstruct videobuf_buffer *vb;\r\nvb = kzalloc(size + sizeof(*mem), GFP_KERNEL);\r\nif (vb) {\r\nmem = vb->priv = ((char *)vb) + size;\r\nmem->magic = MAGIC_DC_MEM;\r\n}\r\nreturn vb;\r\n}\r\nstatic void *__videobuf_to_vaddr(struct videobuf_buffer *buf)\r\n{\r\nstruct videobuf_dma_contig_memory *mem = buf->priv;\r\nBUG_ON(!mem);\r\nMAGIC_CHECK(mem->magic, MAGIC_DC_MEM);\r\nreturn mem->vaddr;\r\n}\r\nstatic int __videobuf_iolock(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb,\r\nstruct v4l2_framebuffer *fbuf)\r\n{\r\nstruct videobuf_dma_contig_memory *mem = vb->priv;\r\nBUG_ON(!mem);\r\nMAGIC_CHECK(mem->magic, MAGIC_DC_MEM);\r\nswitch (vb->memory) {\r\ncase V4L2_MEMORY_MMAP:\r\ndev_dbg(q->dev, "%s memory method MMAP\n", __func__);\r\nif (!mem->vaddr) {\r\ndev_err(q->dev, "memory is not alloced/mmapped.\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase V4L2_MEMORY_USERPTR:\r\ndev_dbg(q->dev, "%s memory method USERPTR\n", __func__);\r\nif (vb->baddr)\r\nreturn videobuf_dma_contig_user_get(mem, vb);\r\nmem->size = PAGE_ALIGN(vb->size);\r\nmem->vaddr = dma_alloc_coherent(q->dev, mem->size,\r\n&mem->dma_handle, GFP_KERNEL);\r\nif (!mem->vaddr) {\r\ndev_err(q->dev, "dma_alloc_coherent %ld failed\n",\r\nmem->size);\r\nreturn -ENOMEM;\r\n}\r\ndev_dbg(q->dev, "dma_alloc_coherent data is at %p (%ld)\n",\r\nmem->vaddr, mem->size);\r\nbreak;\r\ncase V4L2_MEMORY_OVERLAY:\r\ndefault:\r\ndev_dbg(q->dev, "%s memory method OVERLAY/unknown\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __videobuf_mmap_mapper(struct videobuf_queue *q,\r\nstruct videobuf_buffer *buf,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct videobuf_dma_contig_memory *mem;\r\nstruct videobuf_mapping *map;\r\nint retval;\r\nunsigned long size;\r\ndev_dbg(q->dev, "%s\n", __func__);\r\nmap = kzalloc(sizeof(struct videobuf_mapping), GFP_KERNEL);\r\nif (!map)\r\nreturn -ENOMEM;\r\nbuf->map = map;\r\nmap->q = q;\r\nbuf->baddr = vma->vm_start;\r\nmem = buf->priv;\r\nBUG_ON(!mem);\r\nMAGIC_CHECK(mem->magic, MAGIC_DC_MEM);\r\nmem->size = PAGE_ALIGN(buf->bsize);\r\nmem->vaddr = dma_alloc_coherent(q->dev, mem->size,\r\n&mem->dma_handle, GFP_KERNEL);\r\nif (!mem->vaddr) {\r\ndev_err(q->dev, "dma_alloc_coherent size %ld failed\n",\r\nmem->size);\r\ngoto error;\r\n}\r\ndev_dbg(q->dev, "dma_alloc_coherent data is at addr %p (size %ld)\n",\r\nmem->vaddr, mem->size);\r\nsize = vma->vm_end - vma->vm_start;\r\nsize = (size < mem->size) ? size : mem->size;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nretval = remap_pfn_range(vma, vma->vm_start,\r\nmem->dma_handle >> PAGE_SHIFT,\r\nsize, vma->vm_page_prot);\r\nif (retval) {\r\ndev_err(q->dev, "mmap: remap failed with error %d. ", retval);\r\ndma_free_coherent(q->dev, mem->size,\r\nmem->vaddr, mem->dma_handle);\r\ngoto error;\r\n}\r\nvma->vm_ops = &videobuf_vm_ops;\r\nvma->vm_flags |= VM_DONTEXPAND;\r\nvma->vm_private_data = map;\r\ndev_dbg(q->dev, "mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\n",\r\nmap, q, vma->vm_start, vma->vm_end,\r\n(long int)buf->bsize,\r\nvma->vm_pgoff, buf->i);\r\nvideobuf_vm_open(vma);\r\nreturn 0;\r\nerror:\r\nkfree(map);\r\nreturn -ENOMEM;\r\n}\r\nvoid videobuf_queue_dma_contig_init(struct videobuf_queue *q,\r\nconst struct videobuf_queue_ops *ops,\r\nstruct device *dev,\r\nspinlock_t *irqlock,\r\nenum v4l2_buf_type type,\r\nenum v4l2_field field,\r\nunsigned int msize,\r\nvoid *priv,\r\nstruct mutex *ext_lock)\r\n{\r\nvideobuf_queue_core_init(q, ops, dev, irqlock, type, field, msize,\r\npriv, &qops, ext_lock);\r\n}\r\ndma_addr_t videobuf_to_dma_contig(struct videobuf_buffer *buf)\r\n{\r\nstruct videobuf_dma_contig_memory *mem = buf->priv;\r\nBUG_ON(!mem);\r\nMAGIC_CHECK(mem->magic, MAGIC_DC_MEM);\r\nreturn mem->dma_handle;\r\n}\r\nvoid videobuf_dma_contig_free(struct videobuf_queue *q,\r\nstruct videobuf_buffer *buf)\r\n{\r\nstruct videobuf_dma_contig_memory *mem = buf->priv;\r\nif (buf->memory != V4L2_MEMORY_USERPTR)\r\nreturn;\r\nif (!mem)\r\nreturn;\r\nMAGIC_CHECK(mem->magic, MAGIC_DC_MEM);\r\nif (buf->baddr) {\r\nvideobuf_dma_contig_user_put(mem);\r\nreturn;\r\n}\r\nif (mem->vaddr) {\r\ndma_free_coherent(q->dev, mem->size, mem->vaddr, mem->dma_handle);\r\nmem->vaddr = NULL;\r\n}\r\n}
