int ipath_parse_ushort(const char *str, unsigned short *valp)\r\n{\r\nunsigned long val;\r\nchar *end;\r\nint ret;\r\nif (!isdigit(str[0])) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nval = simple_strtoul(str, &end, 0);\r\nif (val > 0xffff) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\n*valp = val;\r\nret = end + 1 - str;\r\nif (ret == 0)\r\nret = -EINVAL;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t show_version(struct device_driver *dev, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%s", ib_ipath_version);\r\n}\r\nstatic ssize_t show_num_units(struct device_driver *dev, char *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n",\r\nipath_count_units(NULL, NULL, NULL));\r\n}\r\nstatic ssize_t show_status(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nssize_t ret;\r\nif (!dd->ipath_statusp) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nret = scnprintf(buf, PAGE_SIZE, "0x%llx\n",\r\n(unsigned long long) *(dd->ipath_statusp));\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t show_status_str(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nint i, any;\r\nu64 s;\r\nssize_t ret;\r\nif (!dd->ipath_statusp) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\ns = *(dd->ipath_statusp);\r\n*buf = '\0';\r\nfor (any = i = 0; s && ipath_status_str[i]; i++) {\r\nif (s & 1) {\r\nif (any && strlcat(buf, " ", PAGE_SIZE) >=\r\nPAGE_SIZE)\r\nbreak;\r\nif (strlcat(buf, ipath_status_str[i],\r\nPAGE_SIZE) >= PAGE_SIZE)\r\nbreak;\r\nany = 1;\r\n}\r\ns >>= 1;\r\n}\r\nif (any)\r\nstrlcat(buf, "\n", PAGE_SIZE);\r\nret = strlen(buf);\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t show_boardversion(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%s", dd->ipath_boardversion);\r\n}\r\nstatic ssize_t show_localbus_info(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%s", dd->ipath_lbus_info);\r\n}\r\nstatic ssize_t show_lmc(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", dd->ipath_lmc);\r\n}\r\nstatic ssize_t store_lmc(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nu16 lmc = 0;\r\nint ret;\r\nret = ipath_parse_ushort(buf, &lmc);\r\nif (ret < 0)\r\ngoto invalid;\r\nif (lmc > 7) {\r\nret = -EINVAL;\r\ngoto invalid;\r\n}\r\nipath_set_lid(dd, dd->ipath_lid, lmc);\r\ngoto bail;\r\ninvalid:\r\nipath_dev_err(dd, "attempt to set invalid LMC %u\n", lmc);\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t show_lid(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "0x%x\n", dd->ipath_lid);\r\n}\r\nstatic ssize_t store_lid(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nu16 lid = 0;\r\nint ret;\r\nret = ipath_parse_ushort(buf, &lid);\r\nif (ret < 0)\r\ngoto invalid;\r\nif (lid == 0 || lid >= IPATH_MULTICAST_LID_BASE) {\r\nret = -EINVAL;\r\ngoto invalid;\r\n}\r\nipath_set_lid(dd, lid, dd->ipath_lmc);\r\ngoto bail;\r\ninvalid:\r\nipath_dev_err(dd, "attempt to set invalid LID 0x%x\n", lid);\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t show_mlid(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "0x%x\n", dd->ipath_mlid);\r\n}\r\nstatic ssize_t store_mlid(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nu16 mlid;\r\nint ret;\r\nret = ipath_parse_ushort(buf, &mlid);\r\nif (ret < 0 || mlid < IPATH_MULTICAST_LID_BASE)\r\ngoto invalid;\r\ndd->ipath_mlid = mlid;\r\ngoto bail;\r\ninvalid:\r\nipath_dev_err(dd, "attempt to set invalid MLID\n");\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t show_guid(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nu8 *guid;\r\nguid = (u8 *) & (dd->ipath_guid);\r\nreturn scnprintf(buf, PAGE_SIZE,\r\n"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",\r\nguid[0], guid[1], guid[2], guid[3],\r\nguid[4], guid[5], guid[6], guid[7]);\r\n}\r\nstatic ssize_t store_guid(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nssize_t ret;\r\nunsigned short guid[8];\r\n__be64 new_guid;\r\nu8 *ng;\r\nint i;\r\nif (sscanf(buf, "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",\r\n&guid[0], &guid[1], &guid[2], &guid[3],\r\n&guid[4], &guid[5], &guid[6], &guid[7]) != 8)\r\ngoto invalid;\r\nng = (u8 *) &new_guid;\r\nfor (i = 0; i < 8; i++) {\r\nif (guid[i] > 0xff)\r\ngoto invalid;\r\nng[i] = guid[i];\r\n}\r\nif (new_guid == 0)\r\ngoto invalid;\r\ndd->ipath_guid = new_guid;\r\ndd->ipath_nguid = 1;\r\nif (dd->verbs_dev)\r\ndd->verbs_dev->ibdev.node_guid = new_guid;\r\nret = strlen(buf);\r\ngoto bail;\r\ninvalid:\r\nipath_dev_err(dd, "attempt to set invalid GUID\n");\r\nret = -EINVAL;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t show_nguid(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", dd->ipath_nguid);\r\n}\r\nstatic ssize_t show_nports(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", dd->ipath_cfgports - 1);\r\n}\r\nstatic ssize_t show_serial(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nbuf[sizeof dd->ipath_serial] = '\0';\r\nmemcpy(buf, dd->ipath_serial, sizeof dd->ipath_serial);\r\nstrcat(buf, "\n");\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t show_unit(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", dd->ipath_unit);\r\n}\r\nstatic ssize_t show_jint_max_packets(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%hu\n", dd->ipath_jint_max_packets);\r\n}\r\nstatic ssize_t store_jint_max_packets(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nu16 v = 0;\r\nint ret;\r\nret = ipath_parse_ushort(buf, &v);\r\nif (ret < 0)\r\nipath_dev_err(dd, "invalid jint_max_packets.\n");\r\nelse\r\ndd->ipath_f_config_jint(dd, dd->ipath_jint_idle_ticks, v);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_jint_idle_ticks(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%hu\n", dd->ipath_jint_idle_ticks);\r\n}\r\nstatic ssize_t store_jint_idle_ticks(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nu16 v = 0;\r\nint ret;\r\nret = ipath_parse_ushort(buf, &v);\r\nif (ret < 0)\r\nipath_dev_err(dd, "invalid jint_idle_ticks.\n");\r\nelse\r\ndd->ipath_f_config_jint(dd, v, dd->ipath_jint_max_packets);\r\nreturn ret;\r\n}\r\nstatic ssize_t store_reset(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nint ret;\r\nif (count < 5 || memcmp(buf, "reset", 5)) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nif (dd->ipath_flags & IPATH_DISABLED) {\r\ndev_info(dev,"Unit %d is disabled, can't reset\n",\r\ndd->ipath_unit);\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nret = ipath_reset_device(dd->ipath_unit);\r\nbail:\r\nreturn ret<0 ? ret : count;\r\n}\r\nstatic ssize_t store_link_state(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nint ret, r;\r\nu16 state;\r\nret = ipath_parse_ushort(buf, &state);\r\nif (ret < 0)\r\ngoto invalid;\r\nr = ipath_set_linkstate(dd, state);\r\nif (r < 0) {\r\nret = r;\r\ngoto bail;\r\n}\r\ngoto bail;\r\ninvalid:\r\nipath_dev_err(dd, "attempt to set invalid link state\n");\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t show_mtu(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", dd->ipath_ibmtu);\r\n}\r\nstatic ssize_t store_mtu(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nssize_t ret;\r\nu16 mtu = 0;\r\nint r;\r\nret = ipath_parse_ushort(buf, &mtu);\r\nif (ret < 0)\r\ngoto invalid;\r\nr = ipath_set_mtu(dd, mtu);\r\nif (r < 0)\r\nret = r;\r\ngoto bail;\r\ninvalid:\r\nipath_dev_err(dd, "attempt to set invalid MTU\n");\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t show_enabled(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n",\r\n(dd->ipath_flags & IPATH_DISABLED) ? 0 : 1);\r\n}\r\nstatic ssize_t store_enabled(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nssize_t ret;\r\nu16 enable = 0;\r\nret = ipath_parse_ushort(buf, &enable);\r\nif (ret < 0) {\r\nipath_dev_err(dd, "attempt to use non-numeric on enable\n");\r\ngoto bail;\r\n}\r\nif (enable) {\r\nif (!(dd->ipath_flags & IPATH_DISABLED))\r\ngoto bail;\r\ndev_info(dev, "Enabling unit %d\n", dd->ipath_unit);\r\nret = ipath_init_chip(dd, 1);\r\nif (ret)\r\nipath_dev_err(dd, "Failed to enable unit %d\n",\r\ndd->ipath_unit);\r\nelse {\r\ndd->ipath_flags &= ~IPATH_DISABLED;\r\n*dd->ipath_statusp &= ~IPATH_STATUS_ADMIN_DISABLED;\r\n}\r\n}\r\nelse if (!(dd->ipath_flags & IPATH_DISABLED)) {\r\ndev_info(dev, "Disabling unit %d\n", dd->ipath_unit);\r\nipath_shutdown_device(dd);\r\ndd->ipath_flags |= IPATH_DISABLED;\r\n*dd->ipath_statusp |= IPATH_STATUS_ADMIN_DISABLED;\r\n}\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t store_rx_pol_inv(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nint ret, r;\r\nu16 val;\r\nret = ipath_parse_ushort(buf, &val);\r\nif (ret < 0)\r\ngoto invalid;\r\nr = ipath_set_rx_pol_inv(dd, val);\r\nif (r < 0) {\r\nret = r;\r\ngoto bail;\r\n}\r\ngoto bail;\r\ninvalid:\r\nipath_dev_err(dd, "attempt to set invalid Rx Polarity invert\n");\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t store_led_override(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nint ret;\r\nu16 val;\r\nret = ipath_parse_ushort(buf, &val);\r\nif (ret > 0)\r\nipath_set_led_override(dd, val);\r\nelse\r\nipath_dev_err(dd, "attempt to set invalid LED override\n");\r\nreturn ret;\r\n}\r\nstatic ssize_t show_logged_errs(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nint idx, count;\r\nif (ipath_update_eeprom_log(dd) != 0)\r\nreturn -ENXIO;\r\ncount = 0;\r\nfor (idx = 0; idx < IPATH_EEP_LOG_CNT; ++idx) {\r\ncount += scnprintf(buf + count, PAGE_SIZE - count, "%d%c",\r\ndd->ipath_eep_st_errs[idx],\r\nidx == (IPATH_EEP_LOG_CNT - 1) ? '\n' : ' ');\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t show_hrtbt_enb(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nint ret;\r\nret = dd->ipath_f_get_ib_cfg(dd, IPATH_IB_CFG_HRTBT);\r\nif (ret >= 0)\r\nret = scnprintf(buf, PAGE_SIZE, "%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic ssize_t store_hrtbt_enb(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nint ret, r;\r\nu16 val;\r\nret = ipath_parse_ushort(buf, &val);\r\nif (ret >= 0 && val > 3)\r\nret = -EINVAL;\r\nif (ret < 0) {\r\nipath_dev_err(dd, "attempt to set invalid Heartbeat enable\n");\r\ngoto bail;\r\n}\r\nr = dd->ipath_f_set_ib_cfg(dd, IPATH_IB_CFG_HRTBT, val);\r\nif (r < 0)\r\nret = r;\r\nelse if (val == IPATH_IB_HRTBT_OFF)\r\ndd->ipath_flags |= IPATH_NO_HRTBT;\r\nelse\r\ndd->ipath_flags &= ~IPATH_NO_HRTBT;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t show_lwid_enb(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nint ret;\r\nret = dd->ipath_f_get_ib_cfg(dd, IPATH_IB_CFG_LWID_ENB);\r\nif (ret >= 0)\r\nret = scnprintf(buf, PAGE_SIZE, "%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic ssize_t store_lwid_enb(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nint ret, r;\r\nu16 val;\r\nret = ipath_parse_ushort(buf, &val);\r\nif (ret >= 0 && (val == 0 || val > 3))\r\nret = -EINVAL;\r\nif (ret < 0) {\r\nipath_dev_err(dd,\r\n"attempt to set invalid Link Width (enable)\n");\r\ngoto bail;\r\n}\r\nr = dd->ipath_f_set_ib_cfg(dd, IPATH_IB_CFG_LWID_ENB, val);\r\nif (r < 0)\r\nret = r;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t show_lwid(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nint ret;\r\nret = dd->ipath_f_get_ib_cfg(dd, IPATH_IB_CFG_LWID);\r\nif (ret >= 0)\r\nret = scnprintf(buf, PAGE_SIZE, "%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_spd_enb(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nint ret;\r\nret = dd->ipath_f_get_ib_cfg(dd, IPATH_IB_CFG_SPD_ENB);\r\nif (ret >= 0)\r\nret = scnprintf(buf, PAGE_SIZE, "%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic ssize_t store_spd_enb(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nint ret, r;\r\nu16 val;\r\nret = ipath_parse_ushort(buf, &val);\r\nif (ret >= 0 && (val == 0 || val > (IPATH_IB_SDR | IPATH_IB_DDR)))\r\nret = -EINVAL;\r\nif (ret < 0) {\r\nipath_dev_err(dd,\r\n"attempt to set invalid Link Speed (enable)\n");\r\ngoto bail;\r\n}\r\nr = dd->ipath_f_set_ib_cfg(dd, IPATH_IB_CFG_SPD_ENB, val);\r\nif (r < 0)\r\nret = r;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t show_spd(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nint ret;\r\nret = dd->ipath_f_get_ib_cfg(dd, IPATH_IB_CFG_SPD);\r\nif (ret >= 0)\r\nret = scnprintf(buf, PAGE_SIZE, "%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_rx_polinv_enb(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nint ret;\r\nret = dd->ipath_f_get_ib_cfg(dd, IPATH_IB_CFG_RXPOL_ENB);\r\nif (ret >= 0)\r\nret = scnprintf(buf, PAGE_SIZE, "%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic ssize_t store_rx_polinv_enb(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nint ret, r;\r\nu16 val;\r\nret = ipath_parse_ushort(buf, &val);\r\nif (ret >= 0 && val > 1) {\r\nipath_dev_err(dd,\r\n"attempt to set invalid Rx Polarity (enable)\n");\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nr = dd->ipath_f_set_ib_cfg(dd, IPATH_IB_CFG_RXPOL_ENB, val);\r\nif (r < 0)\r\nret = r;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t show_lanerev_enb(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nint ret;\r\nret = dd->ipath_f_get_ib_cfg(dd, IPATH_IB_CFG_LREV_ENB);\r\nif (ret >= 0)\r\nret = scnprintf(buf, PAGE_SIZE, "%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic ssize_t store_lanerev_enb(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nint ret, r;\r\nu16 val;\r\nret = ipath_parse_ushort(buf, &val);\r\nif (ret >= 0 && val > 1) {\r\nret = -EINVAL;\r\nipath_dev_err(dd,\r\n"attempt to set invalid Lane reversal (enable)\n");\r\ngoto bail;\r\n}\r\nr = dd->ipath_f_set_ib_cfg(dd, IPATH_IB_CFG_LREV_ENB, val);\r\nif (r < 0)\r\nret = r;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t store_tempsense(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nint ret, stat;\r\nu16 val;\r\nret = ipath_parse_ushort(buf, &val);\r\nif (ret <= 0) {\r\nipath_dev_err(dd, "attempt to set invalid tempsense config\n");\r\ngoto bail;\r\n}\r\nstat = ipath_tempsense_write(dd, 9, (val == 0x7f7f) ? 0x80 : 0);\r\nif (stat) {\r\nipath_dev_err(dd, "Unable to set tempsense config\n");\r\nret = -1;\r\ngoto bail;\r\n}\r\nstat = ipath_tempsense_write(dd, 0xB, (u8) (val & 0xFF));\r\nif (stat) {\r\nipath_dev_err(dd, "Unable to set local Tcrit\n");\r\nret = -1;\r\ngoto bail;\r\n}\r\nstat = ipath_tempsense_write(dd, 0xD, (u8) (val >> 8));\r\nif (stat) {\r\nipath_dev_err(dd, "Unable to set remote Tcrit\n");\r\nret = -1;\r\ngoto bail;\r\n}\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t show_tempsense(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ipath_devdata *dd = dev_get_drvdata(dev);\r\nint ret;\r\nint idx;\r\nu8 regvals[8];\r\nret = -ENXIO;\r\nfor (idx = 0; idx < 8; ++idx) {\r\nif (idx == 6)\r\ncontinue;\r\nret = ipath_tempsense_read(dd, idx);\r\nif (ret < 0)\r\nbreak;\r\nregvals[idx] = ret;\r\n}\r\nif (idx == 8)\r\nret = scnprintf(buf, PAGE_SIZE, "%d %d %02X %02X %d %d\n",\r\n*(signed char *)(regvals),\r\n*(signed char *)(regvals + 1),\r\nregvals[2], regvals[3],\r\n*(signed char *)(regvals + 5),\r\n*(signed char *)(regvals + 7));\r\nreturn ret;\r\n}\r\nint ipath_expose_reset(struct device *dev)\r\n{\r\nstatic int exposed;\r\nint ret;\r\nif (!exposed) {\r\nret = device_create_file(dev, &dev_attr_reset);\r\nexposed = 1;\r\n}\r\nelse\r\nret = 0;\r\nreturn ret;\r\n}\r\nint ipath_device_create_group(struct device *dev, struct ipath_devdata *dd)\r\n{\r\nint ret;\r\nret = sysfs_create_group(&dev->kobj, &dev_attr_group);\r\nif (ret)\r\ngoto bail;\r\nret = sysfs_create_group(&dev->kobj, &dev_counter_attr_group);\r\nif (ret)\r\ngoto bail_attrs;\r\nif (dd->ipath_flags & IPATH_HAS_MULT_IB_SPEED) {\r\nret = device_create_file(dev, &dev_attr_jint_idle_ticks);\r\nif (ret)\r\ngoto bail_counter;\r\nret = device_create_file(dev, &dev_attr_jint_max_packets);\r\nif (ret)\r\ngoto bail_idle;\r\nret = sysfs_create_group(&dev->kobj, &dev_ibcfg_attr_group);\r\nif (ret)\r\ngoto bail_max;\r\n}\r\nreturn 0;\r\nbail_max:\r\ndevice_remove_file(dev, &dev_attr_jint_max_packets);\r\nbail_idle:\r\ndevice_remove_file(dev, &dev_attr_jint_idle_ticks);\r\nbail_counter:\r\nsysfs_remove_group(&dev->kobj, &dev_counter_attr_group);\r\nbail_attrs:\r\nsysfs_remove_group(&dev->kobj, &dev_attr_group);\r\nbail:\r\nreturn ret;\r\n}\r\nvoid ipath_device_remove_group(struct device *dev, struct ipath_devdata *dd)\r\n{\r\nsysfs_remove_group(&dev->kobj, &dev_counter_attr_group);\r\nif (dd->ipath_flags & IPATH_HAS_MULT_IB_SPEED) {\r\nsysfs_remove_group(&dev->kobj, &dev_ibcfg_attr_group);\r\ndevice_remove_file(dev, &dev_attr_jint_idle_ticks);\r\ndevice_remove_file(dev, &dev_attr_jint_max_packets);\r\n}\r\nsysfs_remove_group(&dev->kobj, &dev_attr_group);\r\ndevice_remove_file(dev, &dev_attr_reset);\r\n}
