static inline unsigned int zfcp_dbf_plen(unsigned int offset)\r\n{\r\nreturn sizeof(struct zfcp_dbf_pay) + offset - ZFCP_DBF_PAY_MAX_REC;\r\n}\r\nstatic inline\r\nvoid zfcp_dbf_pl_write(struct zfcp_dbf *dbf, void *data, u16 length, char *area,\r\nu64 req_id)\r\n{\r\nstruct zfcp_dbf_pay *pl = &dbf->pay_buf;\r\nu16 offset = 0, rec_length;\r\nspin_lock(&dbf->pay_lock);\r\nmemset(pl, 0, sizeof(*pl));\r\npl->fsf_req_id = req_id;\r\nmemcpy(pl->area, area, ZFCP_DBF_TAG_LEN);\r\nwhile (offset < length) {\r\nrec_length = min((u16) ZFCP_DBF_PAY_MAX_REC,\r\n(u16) (length - offset));\r\nmemcpy(pl->data, data + offset, rec_length);\r\ndebug_event(dbf->pay, 1, pl, zfcp_dbf_plen(rec_length));\r\noffset += rec_length;\r\npl->counter++;\r\n}\r\nspin_unlock(&dbf->pay_lock);\r\n}\r\nvoid zfcp_dbf_hba_fsf_res(char *tag, struct zfcp_fsf_req *req)\r\n{\r\nstruct zfcp_dbf *dbf = req->adapter->dbf;\r\nstruct fsf_qtcb_prefix *q_pref = &req->qtcb->prefix;\r\nstruct fsf_qtcb_header *q_head = &req->qtcb->header;\r\nstruct zfcp_dbf_hba *rec = &dbf->hba_buf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dbf->hba_lock, flags);\r\nmemset(rec, 0, sizeof(*rec));\r\nmemcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);\r\nrec->id = ZFCP_DBF_HBA_RES;\r\nrec->fsf_req_id = req->req_id;\r\nrec->fsf_req_status = req->status;\r\nrec->fsf_cmd = req->fsf_command;\r\nrec->fsf_seq_no = req->seq_no;\r\nrec->u.res.req_issued = req->issued;\r\nrec->u.res.prot_status = q_pref->prot_status;\r\nrec->u.res.fsf_status = q_head->fsf_status;\r\nmemcpy(rec->u.res.prot_status_qual, &q_pref->prot_status_qual,\r\nFSF_PROT_STATUS_QUAL_SIZE);\r\nmemcpy(rec->u.res.fsf_status_qual, &q_head->fsf_status_qual,\r\nFSF_STATUS_QUALIFIER_SIZE);\r\nif (req->fsf_command != FSF_QTCB_FCP_CMND) {\r\nrec->pl_len = q_head->log_length;\r\nzfcp_dbf_pl_write(dbf, (char *)q_pref + q_head->log_start,\r\nrec->pl_len, "fsf_res", req->req_id);\r\n}\r\ndebug_event(dbf->hba, 1, rec, sizeof(*rec));\r\nspin_unlock_irqrestore(&dbf->hba_lock, flags);\r\n}\r\nvoid zfcp_dbf_hba_fsf_uss(char *tag, struct zfcp_fsf_req *req)\r\n{\r\nstruct zfcp_dbf *dbf = req->adapter->dbf;\r\nstruct fsf_status_read_buffer *srb = req->data;\r\nstruct zfcp_dbf_hba *rec = &dbf->hba_buf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dbf->hba_lock, flags);\r\nmemset(rec, 0, sizeof(*rec));\r\nmemcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);\r\nrec->id = ZFCP_DBF_HBA_USS;\r\nrec->fsf_req_id = req->req_id;\r\nrec->fsf_req_status = req->status;\r\nrec->fsf_cmd = req->fsf_command;\r\nif (!srb)\r\ngoto log;\r\nrec->u.uss.status_type = srb->status_type;\r\nrec->u.uss.status_subtype = srb->status_subtype;\r\nrec->u.uss.d_id = ntoh24(srb->d_id);\r\nrec->u.uss.lun = srb->fcp_lun;\r\nmemcpy(&rec->u.uss.queue_designator, &srb->queue_designator,\r\nsizeof(rec->u.uss.queue_designator));\r\nrec->pl_len = (!srb->length) ? 0 : srb->length -\r\noffsetof(struct fsf_status_read_buffer, payload);\r\nif (rec->pl_len)\r\nzfcp_dbf_pl_write(dbf, srb->payload.data, rec->pl_len,\r\n"fsf_uss", req->req_id);\r\nlog:\r\ndebug_event(dbf->hba, 2, rec, sizeof(*rec));\r\nspin_unlock_irqrestore(&dbf->hba_lock, flags);\r\n}\r\nvoid zfcp_dbf_hba_bit_err(char *tag, struct zfcp_fsf_req *req)\r\n{\r\nstruct zfcp_dbf *dbf = req->adapter->dbf;\r\nstruct zfcp_dbf_hba *rec = &dbf->hba_buf;\r\nstruct fsf_status_read_buffer *sr_buf = req->data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dbf->hba_lock, flags);\r\nmemset(rec, 0, sizeof(*rec));\r\nmemcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);\r\nrec->id = ZFCP_DBF_HBA_BIT;\r\nrec->fsf_req_id = req->req_id;\r\nrec->fsf_req_status = req->status;\r\nrec->fsf_cmd = req->fsf_command;\r\nmemcpy(&rec->u.be, &sr_buf->payload.bit_error,\r\nsizeof(struct fsf_bit_error_payload));\r\ndebug_event(dbf->hba, 1, rec, sizeof(*rec));\r\nspin_unlock_irqrestore(&dbf->hba_lock, flags);\r\n}\r\nvoid zfcp_dbf_hba_def_err(struct zfcp_adapter *adapter, u64 req_id, u16 scount,\r\nvoid **pl)\r\n{\r\nstruct zfcp_dbf *dbf = adapter->dbf;\r\nstruct zfcp_dbf_pay *payload = &dbf->pay_buf;\r\nunsigned long flags;\r\nu16 length;\r\nif (!pl)\r\nreturn;\r\nspin_lock_irqsave(&dbf->pay_lock, flags);\r\nmemset(payload, 0, sizeof(*payload));\r\nmemcpy(payload->area, "def_err", 7);\r\npayload->fsf_req_id = req_id;\r\npayload->counter = 0;\r\nlength = min((u16)sizeof(struct qdio_buffer),\r\n(u16)ZFCP_DBF_PAY_MAX_REC);\r\nwhile ((char *)pl[payload->counter] && payload->counter < scount) {\r\nmemcpy(payload->data, (char *)pl[payload->counter], length);\r\ndebug_event(dbf->pay, 1, payload, zfcp_dbf_plen(length));\r\npayload->counter++;\r\n}\r\nspin_unlock_irqrestore(&dbf->pay_lock, flags);\r\n}\r\nstatic void zfcp_dbf_set_common(struct zfcp_dbf_rec *rec,\r\nstruct zfcp_adapter *adapter,\r\nstruct zfcp_port *port,\r\nstruct scsi_device *sdev)\r\n{\r\nrec->adapter_status = atomic_read(&adapter->status);\r\nif (port) {\r\nrec->port_status = atomic_read(&port->status);\r\nrec->wwpn = port->wwpn;\r\nrec->d_id = port->d_id;\r\n}\r\nif (sdev) {\r\nrec->lun_status = atomic_read(&sdev_to_zfcp(sdev)->status);\r\nrec->lun = zfcp_scsi_dev_lun(sdev);\r\n}\r\n}\r\nvoid zfcp_dbf_rec_trig(char *tag, struct zfcp_adapter *adapter,\r\nstruct zfcp_port *port, struct scsi_device *sdev,\r\nu8 want, u8 need)\r\n{\r\nstruct zfcp_dbf *dbf = adapter->dbf;\r\nstruct zfcp_dbf_rec *rec = &dbf->rec_buf;\r\nstruct list_head *entry;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dbf->rec_lock, flags);\r\nmemset(rec, 0, sizeof(*rec));\r\nrec->id = ZFCP_DBF_REC_TRIG;\r\nmemcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);\r\nzfcp_dbf_set_common(rec, adapter, port, sdev);\r\nlist_for_each(entry, &adapter->erp_ready_head)\r\nrec->u.trig.ready++;\r\nlist_for_each(entry, &adapter->erp_running_head)\r\nrec->u.trig.running++;\r\nrec->u.trig.want = want;\r\nrec->u.trig.need = need;\r\ndebug_event(dbf->rec, 1, rec, sizeof(*rec));\r\nspin_unlock_irqrestore(&dbf->rec_lock, flags);\r\n}\r\nvoid zfcp_dbf_rec_run(char *tag, struct zfcp_erp_action *erp)\r\n{\r\nstruct zfcp_dbf *dbf = erp->adapter->dbf;\r\nstruct zfcp_dbf_rec *rec = &dbf->rec_buf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dbf->rec_lock, flags);\r\nmemset(rec, 0, sizeof(*rec));\r\nrec->id = ZFCP_DBF_REC_RUN;\r\nmemcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);\r\nzfcp_dbf_set_common(rec, erp->adapter, erp->port, erp->sdev);\r\nrec->u.run.fsf_req_id = erp->fsf_req_id;\r\nrec->u.run.rec_status = erp->status;\r\nrec->u.run.rec_step = erp->step;\r\nrec->u.run.rec_action = erp->action;\r\nif (erp->sdev)\r\nrec->u.run.rec_count =\r\natomic_read(&sdev_to_zfcp(erp->sdev)->erp_counter);\r\nelse if (erp->port)\r\nrec->u.run.rec_count = atomic_read(&erp->port->erp_counter);\r\nelse\r\nrec->u.run.rec_count = atomic_read(&erp->adapter->erp_counter);\r\ndebug_event(dbf->rec, 1, rec, sizeof(*rec));\r\nspin_unlock_irqrestore(&dbf->rec_lock, flags);\r\n}\r\nstatic inline\r\nvoid zfcp_dbf_san(char *tag, struct zfcp_dbf *dbf, void *data, u8 id, u16 len,\r\nu64 req_id, u32 d_id)\r\n{\r\nstruct zfcp_dbf_san *rec = &dbf->san_buf;\r\nu16 rec_len;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dbf->san_lock, flags);\r\nmemset(rec, 0, sizeof(*rec));\r\nrec->id = id;\r\nrec->fsf_req_id = req_id;\r\nrec->d_id = d_id;\r\nrec_len = min(len, (u16)ZFCP_DBF_SAN_MAX_PAYLOAD);\r\nmemcpy(rec->payload, data, rec_len);\r\nmemcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);\r\ndebug_event(dbf->san, 1, rec, sizeof(*rec));\r\nspin_unlock_irqrestore(&dbf->san_lock, flags);\r\n}\r\nvoid zfcp_dbf_san_req(char *tag, struct zfcp_fsf_req *fsf, u32 d_id)\r\n{\r\nstruct zfcp_dbf *dbf = fsf->adapter->dbf;\r\nstruct zfcp_fsf_ct_els *ct_els = fsf->data;\r\nu16 length;\r\nlength = (u16)(ct_els->req->length + FC_CT_HDR_LEN);\r\nzfcp_dbf_san(tag, dbf, sg_virt(ct_els->req), ZFCP_DBF_SAN_REQ, length,\r\nfsf->req_id, d_id);\r\n}\r\nvoid zfcp_dbf_san_res(char *tag, struct zfcp_fsf_req *fsf)\r\n{\r\nstruct zfcp_dbf *dbf = fsf->adapter->dbf;\r\nstruct zfcp_fsf_ct_els *ct_els = fsf->data;\r\nu16 length;\r\nlength = (u16)(ct_els->resp->length + FC_CT_HDR_LEN);\r\nzfcp_dbf_san(tag, dbf, sg_virt(ct_els->resp), ZFCP_DBF_SAN_RES, length,\r\nfsf->req_id, 0);\r\n}\r\nvoid zfcp_dbf_san_in_els(char *tag, struct zfcp_fsf_req *fsf)\r\n{\r\nstruct zfcp_dbf *dbf = fsf->adapter->dbf;\r\nstruct fsf_status_read_buffer *srb =\r\n(struct fsf_status_read_buffer *) fsf->data;\r\nu16 length;\r\nlength = (u16)(srb->length -\r\noffsetof(struct fsf_status_read_buffer, payload));\r\nzfcp_dbf_san(tag, dbf, srb->payload.data, ZFCP_DBF_SAN_ELS, length,\r\nfsf->req_id, ntoh24(srb->d_id));\r\n}\r\nvoid zfcp_dbf_scsi(char *tag, struct scsi_cmnd *sc, struct zfcp_fsf_req *fsf)\r\n{\r\nstruct zfcp_adapter *adapter =\r\n(struct zfcp_adapter *) sc->device->host->hostdata[0];\r\nstruct zfcp_dbf *dbf = adapter->dbf;\r\nstruct zfcp_dbf_scsi *rec = &dbf->scsi_buf;\r\nstruct fcp_resp_with_ext *fcp_rsp;\r\nstruct fcp_resp_rsp_info *fcp_rsp_info;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dbf->scsi_lock, flags);\r\nmemset(rec, 0, sizeof(*rec));\r\nmemcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);\r\nrec->id = ZFCP_DBF_SCSI_CMND;\r\nrec->scsi_result = sc->result;\r\nrec->scsi_retries = sc->retries;\r\nrec->scsi_allowed = sc->allowed;\r\nrec->scsi_id = sc->device->id;\r\nrec->scsi_lun = sc->device->lun;\r\nrec->host_scribble = (unsigned long)sc->host_scribble;\r\nmemcpy(rec->scsi_opcode, sc->cmnd,\r\nmin((int)sc->cmd_len, ZFCP_DBF_SCSI_OPCODE));\r\nif (fsf) {\r\nrec->fsf_req_id = fsf->req_id;\r\nfcp_rsp = (struct fcp_resp_with_ext *)\r\n&(fsf->qtcb->bottom.io.fcp_rsp);\r\nmemcpy(&rec->fcp_rsp, fcp_rsp, FCP_RESP_WITH_EXT);\r\nif (fcp_rsp->resp.fr_flags & FCP_RSP_LEN_VAL) {\r\nfcp_rsp_info = (struct fcp_resp_rsp_info *) &fcp_rsp[1];\r\nrec->fcp_rsp_info = fcp_rsp_info->rsp_code;\r\n}\r\nif (fcp_rsp->resp.fr_flags & FCP_SNS_LEN_VAL) {\r\nrec->pl_len = min((u16)SCSI_SENSE_BUFFERSIZE,\r\n(u16)ZFCP_DBF_PAY_MAX_REC);\r\nzfcp_dbf_pl_write(dbf, sc->sense_buffer, rec->pl_len,\r\n"fcp_sns", fsf->req_id);\r\n}\r\n}\r\ndebug_event(dbf->scsi, 1, rec, sizeof(*rec));\r\nspin_unlock_irqrestore(&dbf->scsi_lock, flags);\r\n}\r\nstatic debug_info_t *zfcp_dbf_reg(const char *name, int size, int rec_size)\r\n{\r\nstruct debug_info *d;\r\nd = debug_register(name, size, 1, rec_size);\r\nif (!d)\r\nreturn NULL;\r\ndebug_register_view(d, &debug_hex_ascii_view);\r\ndebug_set_level(d, 3);\r\nreturn d;\r\n}\r\nstatic void zfcp_dbf_unregister(struct zfcp_dbf *dbf)\r\n{\r\nif (!dbf)\r\nreturn;\r\ndebug_unregister(dbf->scsi);\r\ndebug_unregister(dbf->san);\r\ndebug_unregister(dbf->hba);\r\ndebug_unregister(dbf->pay);\r\ndebug_unregister(dbf->rec);\r\nkfree(dbf);\r\n}\r\nint zfcp_dbf_adapter_register(struct zfcp_adapter *adapter)\r\n{\r\nchar name[DEBUG_MAX_NAME_LEN];\r\nstruct zfcp_dbf *dbf;\r\ndbf = kzalloc(sizeof(struct zfcp_dbf), GFP_KERNEL);\r\nif (!dbf)\r\nreturn -ENOMEM;\r\nspin_lock_init(&dbf->pay_lock);\r\nspin_lock_init(&dbf->hba_lock);\r\nspin_lock_init(&dbf->san_lock);\r\nspin_lock_init(&dbf->scsi_lock);\r\nspin_lock_init(&dbf->rec_lock);\r\nsprintf(name, "zfcp_%s_rec", dev_name(&adapter->ccw_device->dev));\r\ndbf->rec = zfcp_dbf_reg(name, dbfsize, sizeof(struct zfcp_dbf_rec));\r\nif (!dbf->rec)\r\ngoto err_out;\r\nsprintf(name, "zfcp_%s_hba", dev_name(&adapter->ccw_device->dev));\r\ndbf->hba = zfcp_dbf_reg(name, dbfsize, sizeof(struct zfcp_dbf_hba));\r\nif (!dbf->hba)\r\ngoto err_out;\r\nsprintf(name, "zfcp_%s_pay", dev_name(&adapter->ccw_device->dev));\r\ndbf->pay = zfcp_dbf_reg(name, dbfsize * 2, sizeof(struct zfcp_dbf_pay));\r\nif (!dbf->pay)\r\ngoto err_out;\r\nsprintf(name, "zfcp_%s_san", dev_name(&adapter->ccw_device->dev));\r\ndbf->san = zfcp_dbf_reg(name, dbfsize, sizeof(struct zfcp_dbf_san));\r\nif (!dbf->san)\r\ngoto err_out;\r\nsprintf(name, "zfcp_%s_scsi", dev_name(&adapter->ccw_device->dev));\r\ndbf->scsi = zfcp_dbf_reg(name, dbfsize, sizeof(struct zfcp_dbf_scsi));\r\nif (!dbf->scsi)\r\ngoto err_out;\r\nadapter->dbf = dbf;\r\nreturn 0;\r\nerr_out:\r\nzfcp_dbf_unregister(dbf);\r\nreturn -ENOMEM;\r\n}\r\nvoid zfcp_dbf_adapter_unregister(struct zfcp_adapter *adapter)\r\n{\r\nstruct zfcp_dbf *dbf = adapter->dbf;\r\nadapter->dbf = NULL;\r\nzfcp_dbf_unregister(dbf);\r\n}
