static inline struct vmw_dma_buffer *\r\nvmw_dma_buffer(struct ttm_buffer_object *bo)\r\n{\r\nreturn container_of(bo, struct vmw_dma_buffer, base);\r\n}\r\nstatic inline struct vmw_user_dma_buffer *\r\nvmw_user_dma_buffer(struct ttm_buffer_object *bo)\r\n{\r\nstruct vmw_dma_buffer *vmw_bo = vmw_dma_buffer(bo);\r\nreturn container_of(vmw_bo, struct vmw_user_dma_buffer, dma);\r\n}\r\nstruct vmw_resource *vmw_resource_reference(struct vmw_resource *res)\r\n{\r\nkref_get(&res->kref);\r\nreturn res;\r\n}\r\nstatic void vmw_resource_release_id(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nwrite_lock(&dev_priv->resource_lock);\r\nif (res->id != -1)\r\nidr_remove(res->idr, res->id);\r\nres->id = -1;\r\nwrite_unlock(&dev_priv->resource_lock);\r\n}\r\nstatic void vmw_resource_release(struct kref *kref)\r\n{\r\nstruct vmw_resource *res =\r\ncontainer_of(kref, struct vmw_resource, kref);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nint id = res->id;\r\nstruct idr *idr = res->idr;\r\nres->avail = false;\r\nif (res->remove_from_lists != NULL)\r\nres->remove_from_lists(res);\r\nwrite_unlock(&dev_priv->resource_lock);\r\nif (likely(res->hw_destroy != NULL))\r\nres->hw_destroy(res);\r\nif (res->res_free != NULL)\r\nres->res_free(res);\r\nelse\r\nkfree(res);\r\nwrite_lock(&dev_priv->resource_lock);\r\nif (id != -1)\r\nidr_remove(idr, id);\r\n}\r\nvoid vmw_resource_unreference(struct vmw_resource **p_res)\r\n{\r\nstruct vmw_resource *res = *p_res;\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\n*p_res = NULL;\r\nwrite_lock(&dev_priv->resource_lock);\r\nkref_put(&res->kref, vmw_resource_release);\r\nwrite_unlock(&dev_priv->resource_lock);\r\n}\r\nstatic int vmw_resource_alloc_id(struct vmw_private *dev_priv,\r\nstruct vmw_resource *res)\r\n{\r\nint ret;\r\nBUG_ON(res->id != -1);\r\ndo {\r\nif (unlikely(idr_pre_get(res->idr, GFP_KERNEL) == 0))\r\nreturn -ENOMEM;\r\nwrite_lock(&dev_priv->resource_lock);\r\nret = idr_get_new_above(res->idr, res, 1, &res->id);\r\nwrite_unlock(&dev_priv->resource_lock);\r\n} while (ret == -EAGAIN);\r\nreturn ret;\r\n}\r\nstatic int vmw_resource_init(struct vmw_private *dev_priv,\r\nstruct vmw_resource *res,\r\nstruct idr *idr,\r\nenum ttm_object_type obj_type,\r\nbool delay_id,\r\nvoid (*res_free) (struct vmw_resource *res),\r\nvoid (*remove_from_lists)\r\n(struct vmw_resource *res))\r\n{\r\nkref_init(&res->kref);\r\nres->hw_destroy = NULL;\r\nres->res_free = res_free;\r\nres->remove_from_lists = remove_from_lists;\r\nres->res_type = obj_type;\r\nres->idr = idr;\r\nres->avail = false;\r\nres->dev_priv = dev_priv;\r\nINIT_LIST_HEAD(&res->query_head);\r\nINIT_LIST_HEAD(&res->validate_head);\r\nres->id = -1;\r\nif (delay_id)\r\nreturn 0;\r\nelse\r\nreturn vmw_resource_alloc_id(dev_priv, res);\r\n}\r\nstatic void vmw_resource_activate(struct vmw_resource *res,\r\nvoid (*hw_destroy) (struct vmw_resource *))\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nwrite_lock(&dev_priv->resource_lock);\r\nres->avail = true;\r\nres->hw_destroy = hw_destroy;\r\nwrite_unlock(&dev_priv->resource_lock);\r\n}\r\nstruct vmw_resource *vmw_resource_lookup(struct vmw_private *dev_priv,\r\nstruct idr *idr, int id)\r\n{\r\nstruct vmw_resource *res;\r\nread_lock(&dev_priv->resource_lock);\r\nres = idr_find(idr, id);\r\nif (res && res->avail)\r\nkref_get(&res->kref);\r\nelse\r\nres = NULL;\r\nread_unlock(&dev_priv->resource_lock);\r\nif (unlikely(res == NULL))\r\nreturn NULL;\r\nreturn res;\r\n}\r\nstatic void vmw_hw_context_destroy(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDestroyContext body;\r\n} *cmd;\r\nvmw_execbuf_release_pinned_bo(dev_priv, true, res->id);\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for surface "\r\n"destruction.\n");\r\nreturn;\r\n}\r\ncmd->header.id = cpu_to_le32(SVGA_3D_CMD_CONTEXT_DESTROY);\r\ncmd->header.size = cpu_to_le32(sizeof(cmd->body));\r\ncmd->body.cid = cpu_to_le32(res->id);\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nvmw_3d_resource_dec(dev_priv, false);\r\n}\r\nstatic int vmw_context_init(struct vmw_private *dev_priv,\r\nstruct vmw_resource *res,\r\nvoid (*res_free) (struct vmw_resource *res))\r\n{\r\nint ret;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdDefineContext body;\r\n} *cmd;\r\nret = vmw_resource_init(dev_priv, res, &dev_priv->context_idr,\r\nVMW_RES_CONTEXT, false, res_free, NULL);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed to allocate a resource id.\n");\r\ngoto out_early;\r\n}\r\nif (unlikely(res->id >= SVGA3D_MAX_CONTEXT_IDS)) {\r\nDRM_ERROR("Out of hw context ids.\n");\r\nvmw_resource_unreference(&res);\r\nreturn -ENOMEM;\r\n}\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Fifo reserve failed.\n");\r\nvmw_resource_unreference(&res);\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = cpu_to_le32(SVGA_3D_CMD_CONTEXT_DEFINE);\r\ncmd->header.size = cpu_to_le32(sizeof(cmd->body));\r\ncmd->body.cid = cpu_to_le32(res->id);\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\n(void) vmw_3d_resource_inc(dev_priv, false);\r\nvmw_resource_activate(res, vmw_hw_context_destroy);\r\nreturn 0;\r\nout_early:\r\nif (res_free == NULL)\r\nkfree(res);\r\nelse\r\nres_free(res);\r\nreturn ret;\r\n}\r\nstruct vmw_resource *vmw_context_alloc(struct vmw_private *dev_priv)\r\n{\r\nstruct vmw_resource *res = kmalloc(sizeof(*res), GFP_KERNEL);\r\nint ret;\r\nif (unlikely(res == NULL))\r\nreturn NULL;\r\nret = vmw_context_init(dev_priv, res, NULL);\r\nreturn (ret == 0) ? res : NULL;\r\n}\r\nstatic void vmw_user_context_free(struct vmw_resource *res)\r\n{\r\nstruct vmw_user_context *ctx =\r\ncontainer_of(res, struct vmw_user_context, res);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nkfree(ctx);\r\nttm_mem_global_free(vmw_mem_glob(dev_priv),\r\nvmw_user_context_size);\r\n}\r\nstatic void vmw_user_context_base_release(struct ttm_base_object **p_base)\r\n{\r\nstruct ttm_base_object *base = *p_base;\r\nstruct vmw_user_context *ctx =\r\ncontainer_of(base, struct vmw_user_context, base);\r\nstruct vmw_resource *res = &ctx->res;\r\n*p_base = NULL;\r\nvmw_resource_unreference(&res);\r\n}\r\nint vmw_context_destroy_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct vmw_resource *res;\r\nstruct vmw_user_context *ctx;\r\nstruct drm_vmw_context_arg *arg = (struct drm_vmw_context_arg *)data;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nint ret = 0;\r\nres = vmw_resource_lookup(dev_priv, &dev_priv->context_idr, arg->cid);\r\nif (unlikely(res == NULL))\r\nreturn -EINVAL;\r\nif (res->res_free != &vmw_user_context_free) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nctx = container_of(res, struct vmw_user_context, res);\r\nif (ctx->base.tfile != tfile && !ctx->base.shareable) {\r\nret = -EPERM;\r\ngoto out;\r\n}\r\nttm_ref_object_base_unref(tfile, ctx->base.hash.key, TTM_REF_USAGE);\r\nout:\r\nvmw_resource_unreference(&res);\r\nreturn ret;\r\n}\r\nint vmw_context_define_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct vmw_user_context *ctx;\r\nstruct vmw_resource *res;\r\nstruct vmw_resource *tmp;\r\nstruct drm_vmw_context_arg *arg = (struct drm_vmw_context_arg *)data;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nstruct vmw_master *vmaster = vmw_master(file_priv->master);\r\nint ret;\r\nif (unlikely(vmw_user_context_size == 0))\r\nvmw_user_context_size = ttm_round_pot(sizeof(*ctx)) + 128;\r\nret = ttm_read_lock(&vmaster->lock, true);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nret = ttm_mem_global_alloc(vmw_mem_glob(dev_priv),\r\nvmw_user_context_size,\r\nfalse, true);\r\nif (unlikely(ret != 0)) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("Out of graphics memory for context"\r\n" creation.\n");\r\ngoto out_unlock;\r\n}\r\nctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (unlikely(ctx == NULL)) {\r\nttm_mem_global_free(vmw_mem_glob(dev_priv),\r\nvmw_user_context_size);\r\nret = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nres = &ctx->res;\r\nctx->base.shareable = false;\r\nctx->base.tfile = NULL;\r\nret = vmw_context_init(dev_priv, res, vmw_user_context_free);\r\nif (unlikely(ret != 0))\r\ngoto out_unlock;\r\ntmp = vmw_resource_reference(&ctx->res);\r\nret = ttm_base_object_init(tfile, &ctx->base, false, VMW_RES_CONTEXT,\r\n&vmw_user_context_base_release, NULL);\r\nif (unlikely(ret != 0)) {\r\nvmw_resource_unreference(&tmp);\r\ngoto out_err;\r\n}\r\narg->cid = res->id;\r\nout_err:\r\nvmw_resource_unreference(&res);\r\nout_unlock:\r\nttm_read_unlock(&vmaster->lock);\r\nreturn ret;\r\n}\r\nint vmw_context_check(struct vmw_private *dev_priv,\r\nstruct ttm_object_file *tfile,\r\nint id,\r\nstruct vmw_resource **p_res)\r\n{\r\nstruct vmw_resource *res;\r\nint ret = 0;\r\nread_lock(&dev_priv->resource_lock);\r\nres = idr_find(&dev_priv->context_idr, id);\r\nif (res && res->avail) {\r\nstruct vmw_user_context *ctx =\r\ncontainer_of(res, struct vmw_user_context, res);\r\nif (ctx->base.tfile != tfile && !ctx->base.shareable)\r\nret = -EPERM;\r\nif (p_res)\r\n*p_res = vmw_resource_reference(res);\r\n} else\r\nret = -EINVAL;\r\nread_unlock(&dev_priv->resource_lock);\r\nreturn ret;\r\n}\r\nstatic inline uint32_t vmw_surface_dma_size(const struct vmw_surface *srf)\r\n{\r\nreturn srf->num_sizes * sizeof(struct vmw_surface_dma);\r\n}\r\nstatic inline uint32_t vmw_surface_define_size(const struct vmw_surface *srf)\r\n{\r\nreturn sizeof(struct vmw_surface_define) + srf->num_sizes *\r\nsizeof(SVGA3dSize);\r\n}\r\nstatic inline uint32_t vmw_surface_destroy_size(void)\r\n{\r\nreturn sizeof(struct vmw_surface_destroy);\r\n}\r\nstatic void vmw_surface_destroy_encode(uint32_t id,\r\nvoid *cmd_space)\r\n{\r\nstruct vmw_surface_destroy *cmd = (struct vmw_surface_destroy *)\r\ncmd_space;\r\ncmd->header.id = SVGA_3D_CMD_SURFACE_DESTROY;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.sid = id;\r\n}\r\nstatic void vmw_surface_define_encode(const struct vmw_surface *srf,\r\nvoid *cmd_space)\r\n{\r\nstruct vmw_surface_define *cmd = (struct vmw_surface_define *)\r\ncmd_space;\r\nstruct drm_vmw_size *src_size;\r\nSVGA3dSize *cmd_size;\r\nuint32_t cmd_len;\r\nint i;\r\ncmd_len = sizeof(cmd->body) + srf->num_sizes * sizeof(SVGA3dSize);\r\ncmd->header.id = SVGA_3D_CMD_SURFACE_DEFINE;\r\ncmd->header.size = cmd_len;\r\ncmd->body.sid = srf->res.id;\r\ncmd->body.surfaceFlags = srf->flags;\r\ncmd->body.format = cpu_to_le32(srf->format);\r\nfor (i = 0; i < DRM_VMW_MAX_SURFACE_FACES; ++i)\r\ncmd->body.face[i].numMipLevels = srf->mip_levels[i];\r\ncmd += 1;\r\ncmd_size = (SVGA3dSize *) cmd;\r\nsrc_size = srf->sizes;\r\nfor (i = 0; i < srf->num_sizes; ++i, cmd_size++, src_size++) {\r\ncmd_size->width = src_size->width;\r\ncmd_size->height = src_size->height;\r\ncmd_size->depth = src_size->depth;\r\n}\r\n}\r\nstatic void vmw_surface_dma_encode(struct vmw_surface *srf,\r\nvoid *cmd_space,\r\nconst SVGAGuestPtr *ptr,\r\nbool to_surface)\r\n{\r\nuint32_t i;\r\nuint32_t bpp = vmw_sf_bpp[srf->format].bpp;\r\nuint32_t stride_bpp = vmw_sf_bpp[srf->format].s_bpp;\r\nstruct vmw_surface_dma *cmd = (struct vmw_surface_dma *)cmd_space;\r\nfor (i = 0; i < srf->num_sizes; ++i) {\r\nSVGA3dCmdHeader *header = &cmd->header;\r\nSVGA3dCmdSurfaceDMA *body = &cmd->body;\r\nSVGA3dCopyBox *cb = &cmd->cb;\r\nSVGA3dCmdSurfaceDMASuffix *suffix = &cmd->suffix;\r\nconst struct vmw_surface_offset *cur_offset = &srf->offsets[i];\r\nconst struct drm_vmw_size *cur_size = &srf->sizes[i];\r\nheader->id = SVGA_3D_CMD_SURFACE_DMA;\r\nheader->size = sizeof(*body) + sizeof(*cb) + sizeof(*suffix);\r\nbody->guest.ptr = *ptr;\r\nbody->guest.ptr.offset += cur_offset->bo_offset;\r\nbody->guest.pitch = (cur_size->width * stride_bpp + 7) >> 3;\r\nbody->host.sid = srf->res.id;\r\nbody->host.face = cur_offset->face;\r\nbody->host.mipmap = cur_offset->mip;\r\nbody->transfer = ((to_surface) ? SVGA3D_WRITE_HOST_VRAM :\r\nSVGA3D_READ_HOST_VRAM);\r\ncb->x = 0;\r\ncb->y = 0;\r\ncb->z = 0;\r\ncb->srcx = 0;\r\ncb->srcy = 0;\r\ncb->srcz = 0;\r\ncb->w = cur_size->width;\r\ncb->h = cur_size->height;\r\ncb->d = cur_size->depth;\r\nsuffix->suffixSize = sizeof(*suffix);\r\nsuffix->maximumOffset = body->guest.pitch*cur_size->height*\r\ncur_size->depth*bpp / stride_bpp;\r\nsuffix->flags.discard = 0;\r\nsuffix->flags.unsynchronized = 0;\r\nsuffix->flags.reserved = 0;\r\n++cmd;\r\n}\r\n}\r\nstatic void vmw_hw_surface_destroy(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct vmw_surface *srf;\r\nvoid *cmd;\r\nif (res->id != -1) {\r\ncmd = vmw_fifo_reserve(dev_priv, vmw_surface_destroy_size());\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for surface "\r\n"destruction.\n");\r\nreturn;\r\n}\r\nvmw_surface_destroy_encode(res->id, cmd);\r\nvmw_fifo_commit(dev_priv, vmw_surface_destroy_size());\r\nmutex_lock(&dev_priv->cmdbuf_mutex);\r\nsrf = container_of(res, struct vmw_surface, res);\r\ndev_priv->used_memory_size -= srf->backup_size;\r\nmutex_unlock(&dev_priv->cmdbuf_mutex);\r\n}\r\nvmw_3d_resource_dec(dev_priv, false);\r\n}\r\nvoid vmw_surface_res_free(struct vmw_resource *res)\r\n{\r\nstruct vmw_surface *srf = container_of(res, struct vmw_surface, res);\r\nif (srf->backup)\r\nttm_bo_unref(&srf->backup);\r\nkfree(srf->offsets);\r\nkfree(srf->sizes);\r\nkfree(srf->snooper.image);\r\nkfree(srf);\r\n}\r\nint vmw_surface_do_validate(struct vmw_private *dev_priv,\r\nstruct vmw_surface *srf)\r\n{\r\nstruct vmw_resource *res = &srf->res;\r\nstruct list_head val_list;\r\nstruct ttm_validate_buffer val_buf;\r\nuint32_t submit_size;\r\nuint8_t *cmd;\r\nint ret;\r\nif (likely(res->id != -1))\r\nreturn 0;\r\nif (unlikely(dev_priv->used_memory_size + srf->backup_size >=\r\ndev_priv->memory_size))\r\nreturn -EBUSY;\r\nif (srf->backup) {\r\nINIT_LIST_HEAD(&val_list);\r\nval_buf.bo = ttm_bo_reference(srf->backup);\r\nval_buf.new_sync_obj_arg = (void *)((unsigned long)\r\nDRM_VMW_FENCE_FLAG_EXEC);\r\nlist_add_tail(&val_buf.head, &val_list);\r\nret = ttm_eu_reserve_buffers(&val_list);\r\nif (unlikely(ret != 0))\r\ngoto out_no_reserve;\r\nret = ttm_bo_validate(srf->backup, &vmw_srf_placement,\r\ntrue, false, false);\r\nif (unlikely(ret != 0))\r\ngoto out_no_validate;\r\n}\r\nret = vmw_resource_alloc_id(dev_priv, res);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Failed to allocate a surface id.\n");\r\ngoto out_no_id;\r\n}\r\nif (unlikely(res->id >= SVGA3D_MAX_SURFACE_IDS)) {\r\nret = -EBUSY;\r\ngoto out_no_fifo;\r\n}\r\nsubmit_size = vmw_surface_define_size(srf);\r\nif (srf->backup)\r\nsubmit_size += vmw_surface_dma_size(srf);\r\ncmd = vmw_fifo_reserve(dev_priv, submit_size);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for surface "\r\n"validation.\n");\r\nret = -ENOMEM;\r\ngoto out_no_fifo;\r\n}\r\nvmw_surface_define_encode(srf, cmd);\r\nif (srf->backup) {\r\nSVGAGuestPtr ptr;\r\ncmd += vmw_surface_define_size(srf);\r\nvmw_bo_get_guest_ptr(srf->backup, &ptr);\r\nvmw_surface_dma_encode(srf, cmd, &ptr, true);\r\n}\r\nvmw_fifo_commit(dev_priv, submit_size);\r\nif (srf->backup) {\r\nstruct vmw_fence_obj *fence;\r\n(void) vmw_execbuf_fence_commands(NULL, dev_priv,\r\n&fence, NULL);\r\nttm_eu_fence_buffer_objects(&val_list, fence);\r\nif (likely(fence != NULL))\r\nvmw_fence_obj_unreference(&fence);\r\nttm_bo_unref(&val_buf.bo);\r\nttm_bo_unref(&srf->backup);\r\n}\r\ndev_priv->used_memory_size += srf->backup_size;\r\nreturn 0;\r\nout_no_fifo:\r\nvmw_resource_release_id(res);\r\nout_no_id:\r\nout_no_validate:\r\nif (srf->backup)\r\nttm_eu_backoff_reservation(&val_list);\r\nout_no_reserve:\r\nif (srf->backup)\r\nttm_bo_unref(&val_buf.bo);\r\nreturn ret;\r\n}\r\nint vmw_surface_evict(struct vmw_private *dev_priv,\r\nstruct vmw_surface *srf)\r\n{\r\nstruct vmw_resource *res = &srf->res;\r\nstruct list_head val_list;\r\nstruct ttm_validate_buffer val_buf;\r\nuint32_t submit_size;\r\nuint8_t *cmd;\r\nint ret;\r\nstruct vmw_fence_obj *fence;\r\nSVGAGuestPtr ptr;\r\nBUG_ON(res->id == -1);\r\nif (!srf->backup) {\r\nret = ttm_bo_create(&dev_priv->bdev, srf->backup_size,\r\nttm_bo_type_device,\r\n&vmw_srf_placement, 0, 0, true,\r\nNULL, &srf->backup);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\n}\r\nINIT_LIST_HEAD(&val_list);\r\nval_buf.bo = ttm_bo_reference(srf->backup);\r\nval_buf.new_sync_obj_arg = (void *)(unsigned long)\r\nDRM_VMW_FENCE_FLAG_EXEC;\r\nlist_add_tail(&val_buf.head, &val_list);\r\nret = ttm_eu_reserve_buffers(&val_list);\r\nif (unlikely(ret != 0))\r\ngoto out_no_reserve;\r\nret = ttm_bo_validate(srf->backup, &vmw_srf_placement,\r\ntrue, false, false);\r\nif (unlikely(ret != 0))\r\ngoto out_no_validate;\r\nsubmit_size = vmw_surface_dma_size(srf) + vmw_surface_destroy_size();\r\ncmd = vmw_fifo_reserve(dev_priv, submit_size);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Failed reserving FIFO space for surface "\r\n"eviction.\n");\r\nret = -ENOMEM;\r\ngoto out_no_fifo;\r\n}\r\nvmw_bo_get_guest_ptr(srf->backup, &ptr);\r\nvmw_surface_dma_encode(srf, cmd, &ptr, false);\r\ncmd += vmw_surface_dma_size(srf);\r\nvmw_surface_destroy_encode(res->id, cmd);\r\nvmw_fifo_commit(dev_priv, submit_size);\r\ndev_priv->used_memory_size -= srf->backup_size;\r\n(void) vmw_execbuf_fence_commands(NULL, dev_priv,\r\n&fence, NULL);\r\nttm_eu_fence_buffer_objects(&val_list, fence);\r\nif (likely(fence != NULL))\r\nvmw_fence_obj_unreference(&fence);\r\nttm_bo_unref(&val_buf.bo);\r\nvmw_resource_release_id(res);\r\nreturn 0;\r\nout_no_fifo:\r\nout_no_validate:\r\nif (srf->backup)\r\nttm_eu_backoff_reservation(&val_list);\r\nout_no_reserve:\r\nttm_bo_unref(&val_buf.bo);\r\nttm_bo_unref(&srf->backup);\r\nreturn ret;\r\n}\r\nint vmw_surface_validate(struct vmw_private *dev_priv,\r\nstruct vmw_surface *srf)\r\n{\r\nint ret;\r\nstruct vmw_surface *evict_srf;\r\ndo {\r\nwrite_lock(&dev_priv->resource_lock);\r\nlist_del_init(&srf->lru_head);\r\nwrite_unlock(&dev_priv->resource_lock);\r\nret = vmw_surface_do_validate(dev_priv, srf);\r\nif (likely(ret != -EBUSY))\r\nbreak;\r\nwrite_lock(&dev_priv->resource_lock);\r\nif (list_empty(&dev_priv->surface_lru)) {\r\nDRM_ERROR("Out of device memory for surfaces.\n");\r\nret = -EBUSY;\r\nwrite_unlock(&dev_priv->resource_lock);\r\nbreak;\r\n}\r\nevict_srf = vmw_surface_reference\r\n(list_first_entry(&dev_priv->surface_lru,\r\nstruct vmw_surface,\r\nlru_head));\r\nlist_del_init(&evict_srf->lru_head);\r\nwrite_unlock(&dev_priv->resource_lock);\r\n(void) vmw_surface_evict(dev_priv, evict_srf);\r\nvmw_surface_unreference(&evict_srf);\r\n} while (1);\r\nif (unlikely(ret != 0 && srf->res.id != -1)) {\r\nwrite_lock(&dev_priv->resource_lock);\r\nlist_add_tail(&srf->lru_head, &dev_priv->surface_lru);\r\nwrite_unlock(&dev_priv->resource_lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic void vmw_surface_remove_from_lists(struct vmw_resource *res)\r\n{\r\nstruct vmw_surface *srf = container_of(res, struct vmw_surface, res);\r\nlist_del_init(&srf->lru_head);\r\n}\r\nint vmw_surface_init(struct vmw_private *dev_priv,\r\nstruct vmw_surface *srf,\r\nvoid (*res_free) (struct vmw_resource *res))\r\n{\r\nint ret;\r\nstruct vmw_resource *res = &srf->res;\r\nBUG_ON(res_free == NULL);\r\nINIT_LIST_HEAD(&srf->lru_head);\r\nret = vmw_resource_init(dev_priv, res, &dev_priv->surface_idr,\r\nVMW_RES_SURFACE, true, res_free,\r\nvmw_surface_remove_from_lists);\r\nif (unlikely(ret != 0))\r\nres_free(res);\r\n(void) vmw_3d_resource_inc(dev_priv, false);\r\nvmw_resource_activate(res, vmw_hw_surface_destroy);\r\nreturn ret;\r\n}\r\nstatic void vmw_user_surface_free(struct vmw_resource *res)\r\n{\r\nstruct vmw_surface *srf = container_of(res, struct vmw_surface, res);\r\nstruct vmw_user_surface *user_srf =\r\ncontainer_of(srf, struct vmw_user_surface, srf);\r\nstruct vmw_private *dev_priv = srf->res.dev_priv;\r\nuint32_t size = user_srf->size;\r\nif (srf->backup)\r\nttm_bo_unref(&srf->backup);\r\nkfree(srf->offsets);\r\nkfree(srf->sizes);\r\nkfree(srf->snooper.image);\r\nkfree(user_srf);\r\nttm_mem_global_free(vmw_mem_glob(dev_priv), size);\r\n}\r\nvoid vmw_resource_unreserve(struct list_head *list)\r\n{\r\nstruct vmw_resource *res;\r\nstruct vmw_surface *srf;\r\nrwlock_t *lock = NULL;\r\nlist_for_each_entry(res, list, validate_head) {\r\nif (res->res_free != &vmw_surface_res_free &&\r\nres->res_free != &vmw_user_surface_free)\r\ncontinue;\r\nif (unlikely(lock == NULL)) {\r\nlock = &res->dev_priv->resource_lock;\r\nwrite_lock(lock);\r\n}\r\nsrf = container_of(res, struct vmw_surface, res);\r\nlist_del_init(&srf->lru_head);\r\nlist_add_tail(&srf->lru_head, &res->dev_priv->surface_lru);\r\n}\r\nif (lock != NULL)\r\nwrite_unlock(lock);\r\n}\r\nint vmw_user_lookup_handle(struct vmw_private *dev_priv,\r\nstruct ttm_object_file *tfile,\r\nuint32_t handle,\r\nstruct vmw_surface **out_surf,\r\nstruct vmw_dma_buffer **out_buf)\r\n{\r\nint ret;\r\nBUG_ON(*out_surf || *out_buf);\r\nret = vmw_user_surface_lookup_handle(dev_priv, tfile, handle, out_surf);\r\nif (!ret)\r\nreturn 0;\r\nret = vmw_user_dmabuf_lookup(tfile, handle, out_buf);\r\nreturn ret;\r\n}\r\nint vmw_user_surface_lookup_handle(struct vmw_private *dev_priv,\r\nstruct ttm_object_file *tfile,\r\nuint32_t handle, struct vmw_surface **out)\r\n{\r\nstruct vmw_resource *res;\r\nstruct vmw_surface *srf;\r\nstruct vmw_user_surface *user_srf;\r\nstruct ttm_base_object *base;\r\nint ret = -EINVAL;\r\nbase = ttm_base_object_lookup(tfile, handle);\r\nif (unlikely(base == NULL))\r\nreturn -EINVAL;\r\nif (unlikely(base->object_type != VMW_RES_SURFACE))\r\ngoto out_bad_resource;\r\nuser_srf = container_of(base, struct vmw_user_surface, base);\r\nsrf = &user_srf->srf;\r\nres = &srf->res;\r\nread_lock(&dev_priv->resource_lock);\r\nif (!res->avail || res->res_free != &vmw_user_surface_free) {\r\nread_unlock(&dev_priv->resource_lock);\r\ngoto out_bad_resource;\r\n}\r\nkref_get(&res->kref);\r\nread_unlock(&dev_priv->resource_lock);\r\n*out = srf;\r\nret = 0;\r\nout_bad_resource:\r\nttm_base_object_unref(&base);\r\nreturn ret;\r\n}\r\nstatic void vmw_user_surface_base_release(struct ttm_base_object **p_base)\r\n{\r\nstruct ttm_base_object *base = *p_base;\r\nstruct vmw_user_surface *user_srf =\r\ncontainer_of(base, struct vmw_user_surface, base);\r\nstruct vmw_resource *res = &user_srf->srf.res;\r\n*p_base = NULL;\r\nvmw_resource_unreference(&res);\r\n}\r\nint vmw_surface_destroy_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_vmw_surface_arg *arg = (struct drm_vmw_surface_arg *)data;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nreturn ttm_ref_object_base_unref(tfile, arg->sid, TTM_REF_USAGE);\r\n}\r\nint vmw_surface_define_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct vmw_user_surface *user_srf;\r\nstruct vmw_surface *srf;\r\nstruct vmw_resource *res;\r\nstruct vmw_resource *tmp;\r\nunion drm_vmw_surface_create_arg *arg =\r\n(union drm_vmw_surface_create_arg *)data;\r\nstruct drm_vmw_surface_create_req *req = &arg->req;\r\nstruct drm_vmw_surface_arg *rep = &arg->rep;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nstruct drm_vmw_size __user *user_sizes;\r\nint ret;\r\nint i, j;\r\nuint32_t cur_bo_offset;\r\nstruct drm_vmw_size *cur_size;\r\nstruct vmw_surface_offset *cur_offset;\r\nuint32_t stride_bpp;\r\nuint32_t bpp;\r\nuint32_t num_sizes;\r\nuint32_t size;\r\nstruct vmw_master *vmaster = vmw_master(file_priv->master);\r\nif (unlikely(vmw_user_surface_size == 0))\r\nvmw_user_surface_size = ttm_round_pot(sizeof(*user_srf)) +\r\n128;\r\nnum_sizes = 0;\r\nfor (i = 0; i < DRM_VMW_MAX_SURFACE_FACES; ++i)\r\nnum_sizes += req->mip_levels[i];\r\nif (num_sizes > DRM_VMW_MAX_SURFACE_FACES *\r\nDRM_VMW_MAX_MIP_LEVELS)\r\nreturn -EINVAL;\r\nsize = vmw_user_surface_size + 128 +\r\nttm_round_pot(num_sizes * sizeof(struct drm_vmw_size)) +\r\nttm_round_pot(num_sizes * sizeof(struct vmw_surface_offset));\r\nret = ttm_read_lock(&vmaster->lock, true);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nret = ttm_mem_global_alloc(vmw_mem_glob(dev_priv),\r\nsize, false, true);\r\nif (unlikely(ret != 0)) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("Out of graphics memory for surface"\r\n" creation.\n");\r\ngoto out_unlock;\r\n}\r\nuser_srf = kmalloc(sizeof(*user_srf), GFP_KERNEL);\r\nif (unlikely(user_srf == NULL)) {\r\nret = -ENOMEM;\r\ngoto out_no_user_srf;\r\n}\r\nsrf = &user_srf->srf;\r\nres = &srf->res;\r\nsrf->flags = req->flags;\r\nsrf->format = req->format;\r\nsrf->scanout = req->scanout;\r\nsrf->backup = NULL;\r\nmemcpy(srf->mip_levels, req->mip_levels, sizeof(srf->mip_levels));\r\nsrf->num_sizes = num_sizes;\r\nuser_srf->size = size;\r\nsrf->sizes = kmalloc(srf->num_sizes * sizeof(*srf->sizes), GFP_KERNEL);\r\nif (unlikely(srf->sizes == NULL)) {\r\nret = -ENOMEM;\r\ngoto out_no_sizes;\r\n}\r\nsrf->offsets = kmalloc(srf->num_sizes * sizeof(*srf->offsets),\r\nGFP_KERNEL);\r\nif (unlikely(srf->sizes == NULL)) {\r\nret = -ENOMEM;\r\ngoto out_no_offsets;\r\n}\r\nuser_sizes = (struct drm_vmw_size __user *)(unsigned long)\r\nreq->size_addr;\r\nret = copy_from_user(srf->sizes, user_sizes,\r\nsrf->num_sizes * sizeof(*srf->sizes));\r\nif (unlikely(ret != 0)) {\r\nret = -EFAULT;\r\ngoto out_no_copy;\r\n}\r\ncur_bo_offset = 0;\r\ncur_offset = srf->offsets;\r\ncur_size = srf->sizes;\r\nbpp = vmw_sf_bpp[srf->format].bpp;\r\nstride_bpp = vmw_sf_bpp[srf->format].s_bpp;\r\nfor (i = 0; i < DRM_VMW_MAX_SURFACE_FACES; ++i) {\r\nfor (j = 0; j < srf->mip_levels[i]; ++j) {\r\nuint32_t stride =\r\n(cur_size->width * stride_bpp + 7) >> 3;\r\ncur_offset->face = i;\r\ncur_offset->mip = j;\r\ncur_offset->bo_offset = cur_bo_offset;\r\ncur_bo_offset += stride * cur_size->height *\r\ncur_size->depth * bpp / stride_bpp;\r\n++cur_offset;\r\n++cur_size;\r\n}\r\n}\r\nsrf->backup_size = cur_bo_offset;\r\nif (srf->scanout &&\r\nsrf->num_sizes == 1 &&\r\nsrf->sizes[0].width == 64 &&\r\nsrf->sizes[0].height == 64 &&\r\nsrf->format == SVGA3D_A8R8G8B8) {\r\nsrf->snooper.image = kzalloc(64 * 64 * 4, GFP_KERNEL);\r\nif (!srf->snooper.image) {\r\nDRM_ERROR("Failed to allocate cursor_image\n");\r\nret = -ENOMEM;\r\ngoto out_no_copy;\r\n}\r\n} else {\r\nsrf->snooper.image = NULL;\r\n}\r\nsrf->snooper.crtc = NULL;\r\nuser_srf->base.shareable = false;\r\nuser_srf->base.tfile = NULL;\r\nret = vmw_surface_init(dev_priv, srf, vmw_user_surface_free);\r\nif (unlikely(ret != 0))\r\ngoto out_unlock;\r\ntmp = vmw_resource_reference(&srf->res);\r\nret = ttm_base_object_init(tfile, &user_srf->base,\r\nreq->shareable, VMW_RES_SURFACE,\r\n&vmw_user_surface_base_release, NULL);\r\nif (unlikely(ret != 0)) {\r\nvmw_resource_unreference(&tmp);\r\nvmw_resource_unreference(&res);\r\ngoto out_unlock;\r\n}\r\nrep->sid = user_srf->base.hash.key;\r\nif (rep->sid == SVGA3D_INVALID_ID)\r\nDRM_ERROR("Created bad Surface ID.\n");\r\nvmw_resource_unreference(&res);\r\nttm_read_unlock(&vmaster->lock);\r\nreturn 0;\r\nout_no_copy:\r\nkfree(srf->offsets);\r\nout_no_offsets:\r\nkfree(srf->sizes);\r\nout_no_sizes:\r\nkfree(user_srf);\r\nout_no_user_srf:\r\nttm_mem_global_free(vmw_mem_glob(dev_priv), size);\r\nout_unlock:\r\nttm_read_unlock(&vmaster->lock);\r\nreturn ret;\r\n}\r\nint vmw_surface_reference_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nunion drm_vmw_surface_reference_arg *arg =\r\n(union drm_vmw_surface_reference_arg *)data;\r\nstruct drm_vmw_surface_arg *req = &arg->req;\r\nstruct drm_vmw_surface_create_req *rep = &arg->rep;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nstruct vmw_surface *srf;\r\nstruct vmw_user_surface *user_srf;\r\nstruct drm_vmw_size __user *user_sizes;\r\nstruct ttm_base_object *base;\r\nint ret = -EINVAL;\r\nbase = ttm_base_object_lookup(tfile, req->sid);\r\nif (unlikely(base == NULL)) {\r\nDRM_ERROR("Could not find surface to reference.\n");\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(base->object_type != VMW_RES_SURFACE))\r\ngoto out_bad_resource;\r\nuser_srf = container_of(base, struct vmw_user_surface, base);\r\nsrf = &user_srf->srf;\r\nret = ttm_ref_object_add(tfile, &user_srf->base, TTM_REF_USAGE, NULL);\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("Could not add a reference to a surface.\n");\r\ngoto out_no_reference;\r\n}\r\nrep->flags = srf->flags;\r\nrep->format = srf->format;\r\nmemcpy(rep->mip_levels, srf->mip_levels, sizeof(srf->mip_levels));\r\nuser_sizes = (struct drm_vmw_size __user *)(unsigned long)\r\nrep->size_addr;\r\nif (user_sizes)\r\nret = copy_to_user(user_sizes, srf->sizes,\r\nsrf->num_sizes * sizeof(*srf->sizes));\r\nif (unlikely(ret != 0)) {\r\nDRM_ERROR("copy_to_user failed %p %u\n",\r\nuser_sizes, srf->num_sizes);\r\nret = -EFAULT;\r\n}\r\nout_bad_resource:\r\nout_no_reference:\r\nttm_base_object_unref(&base);\r\nreturn ret;\r\n}\r\nint vmw_surface_check(struct vmw_private *dev_priv,\r\nstruct ttm_object_file *tfile,\r\nuint32_t handle, int *id)\r\n{\r\nstruct ttm_base_object *base;\r\nstruct vmw_user_surface *user_srf;\r\nint ret = -EPERM;\r\nbase = ttm_base_object_lookup(tfile, handle);\r\nif (unlikely(base == NULL))\r\nreturn -EINVAL;\r\nif (unlikely(base->object_type != VMW_RES_SURFACE))\r\ngoto out_bad_surface;\r\nuser_srf = container_of(base, struct vmw_user_surface, base);\r\n*id = user_srf->srf.res.id;\r\nret = 0;\r\nout_bad_surface:\r\nttm_base_object_unref(&base);\r\nreturn ret;\r\n}\r\nvoid vmw_dmabuf_bo_free(struct ttm_buffer_object *bo)\r\n{\r\nstruct vmw_dma_buffer *vmw_bo = vmw_dma_buffer(bo);\r\nkfree(vmw_bo);\r\n}\r\nint vmw_dmabuf_init(struct vmw_private *dev_priv,\r\nstruct vmw_dma_buffer *vmw_bo,\r\nsize_t size, struct ttm_placement *placement,\r\nbool interruptible,\r\nvoid (*bo_free) (struct ttm_buffer_object *bo))\r\n{\r\nstruct ttm_bo_device *bdev = &dev_priv->bdev;\r\nsize_t acc_size;\r\nint ret;\r\nBUG_ON(!bo_free);\r\nacc_size = ttm_bo_acc_size(bdev, size, sizeof(struct vmw_dma_buffer));\r\nmemset(vmw_bo, 0, sizeof(*vmw_bo));\r\nINIT_LIST_HEAD(&vmw_bo->validate_list);\r\nret = ttm_bo_init(bdev, &vmw_bo->base, size,\r\nttm_bo_type_device, placement,\r\n0, 0, interruptible,\r\nNULL, acc_size, bo_free);\r\nreturn ret;\r\n}\r\nstatic void vmw_user_dmabuf_destroy(struct ttm_buffer_object *bo)\r\n{\r\nstruct vmw_user_dma_buffer *vmw_user_bo = vmw_user_dma_buffer(bo);\r\nkfree(vmw_user_bo);\r\n}\r\nstatic void vmw_user_dmabuf_release(struct ttm_base_object **p_base)\r\n{\r\nstruct vmw_user_dma_buffer *vmw_user_bo;\r\nstruct ttm_base_object *base = *p_base;\r\nstruct ttm_buffer_object *bo;\r\n*p_base = NULL;\r\nif (unlikely(base == NULL))\r\nreturn;\r\nvmw_user_bo = container_of(base, struct vmw_user_dma_buffer, base);\r\nbo = &vmw_user_bo->dma.base;\r\nttm_bo_unref(&bo);\r\n}\r\nint vmw_dmabuf_alloc_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nunion drm_vmw_alloc_dmabuf_arg *arg =\r\n(union drm_vmw_alloc_dmabuf_arg *)data;\r\nstruct drm_vmw_alloc_dmabuf_req *req = &arg->req;\r\nstruct drm_vmw_dmabuf_rep *rep = &arg->rep;\r\nstruct vmw_user_dma_buffer *vmw_user_bo;\r\nstruct ttm_buffer_object *tmp;\r\nstruct vmw_master *vmaster = vmw_master(file_priv->master);\r\nint ret;\r\nvmw_user_bo = kzalloc(sizeof(*vmw_user_bo), GFP_KERNEL);\r\nif (unlikely(vmw_user_bo == NULL))\r\nreturn -ENOMEM;\r\nret = ttm_read_lock(&vmaster->lock, true);\r\nif (unlikely(ret != 0)) {\r\nkfree(vmw_user_bo);\r\nreturn ret;\r\n}\r\nret = vmw_dmabuf_init(dev_priv, &vmw_user_bo->dma, req->size,\r\n&vmw_vram_sys_placement, true,\r\n&vmw_user_dmabuf_destroy);\r\nif (unlikely(ret != 0))\r\ngoto out_no_dmabuf;\r\ntmp = ttm_bo_reference(&vmw_user_bo->dma.base);\r\nret = ttm_base_object_init(vmw_fpriv(file_priv)->tfile,\r\n&vmw_user_bo->base,\r\nfalse,\r\nttm_buffer_type,\r\n&vmw_user_dmabuf_release, NULL);\r\nif (unlikely(ret != 0))\r\ngoto out_no_base_object;\r\nelse {\r\nrep->handle = vmw_user_bo->base.hash.key;\r\nrep->map_handle = vmw_user_bo->dma.base.addr_space_offset;\r\nrep->cur_gmr_id = vmw_user_bo->base.hash.key;\r\nrep->cur_gmr_offset = 0;\r\n}\r\nout_no_base_object:\r\nttm_bo_unref(&tmp);\r\nout_no_dmabuf:\r\nttm_read_unlock(&vmaster->lock);\r\nreturn ret;\r\n}\r\nint vmw_dmabuf_unref_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_vmw_unref_dmabuf_arg *arg =\r\n(struct drm_vmw_unref_dmabuf_arg *)data;\r\nreturn ttm_ref_object_base_unref(vmw_fpriv(file_priv)->tfile,\r\narg->handle,\r\nTTM_REF_USAGE);\r\n}\r\nuint32_t vmw_dmabuf_validate_node(struct ttm_buffer_object *bo,\r\nuint32_t cur_validate_node)\r\n{\r\nstruct vmw_dma_buffer *vmw_bo = vmw_dma_buffer(bo);\r\nif (likely(vmw_bo->on_validate_list))\r\nreturn vmw_bo->cur_validate_node;\r\nvmw_bo->cur_validate_node = cur_validate_node;\r\nvmw_bo->on_validate_list = true;\r\nreturn cur_validate_node;\r\n}\r\nvoid vmw_dmabuf_validate_clear(struct ttm_buffer_object *bo)\r\n{\r\nstruct vmw_dma_buffer *vmw_bo = vmw_dma_buffer(bo);\r\nvmw_bo->on_validate_list = false;\r\n}\r\nint vmw_user_dmabuf_lookup(struct ttm_object_file *tfile,\r\nuint32_t handle, struct vmw_dma_buffer **out)\r\n{\r\nstruct vmw_user_dma_buffer *vmw_user_bo;\r\nstruct ttm_base_object *base;\r\nbase = ttm_base_object_lookup(tfile, handle);\r\nif (unlikely(base == NULL)) {\r\nprintk(KERN_ERR "Invalid buffer object handle 0x%08lx.\n",\r\n(unsigned long)handle);\r\nreturn -ESRCH;\r\n}\r\nif (unlikely(base->object_type != ttm_buffer_type)) {\r\nttm_base_object_unref(&base);\r\nprintk(KERN_ERR "Invalid buffer object handle 0x%08lx.\n",\r\n(unsigned long)handle);\r\nreturn -EINVAL;\r\n}\r\nvmw_user_bo = container_of(base, struct vmw_user_dma_buffer, base);\r\n(void)ttm_bo_reference(&vmw_user_bo->dma.base);\r\nttm_base_object_unref(&base);\r\n*out = &vmw_user_bo->dma;\r\nreturn 0;\r\n}\r\nstatic void vmw_stream_destroy(struct vmw_resource *res)\r\n{\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nstruct vmw_stream *stream;\r\nint ret;\r\nDRM_INFO("%s: unref\n", __func__);\r\nstream = container_of(res, struct vmw_stream, res);\r\nret = vmw_overlay_unref(dev_priv, stream->stream_id);\r\nWARN_ON(ret != 0);\r\n}\r\nstatic int vmw_stream_init(struct vmw_private *dev_priv,\r\nstruct vmw_stream *stream,\r\nvoid (*res_free) (struct vmw_resource *res))\r\n{\r\nstruct vmw_resource *res = &stream->res;\r\nint ret;\r\nret = vmw_resource_init(dev_priv, res, &dev_priv->stream_idr,\r\nVMW_RES_STREAM, false, res_free, NULL);\r\nif (unlikely(ret != 0)) {\r\nif (res_free == NULL)\r\nkfree(stream);\r\nelse\r\nres_free(&stream->res);\r\nreturn ret;\r\n}\r\nret = vmw_overlay_claim(dev_priv, &stream->stream_id);\r\nif (ret) {\r\nvmw_resource_unreference(&res);\r\nreturn ret;\r\n}\r\nDRM_INFO("%s: claimed\n", __func__);\r\nvmw_resource_activate(&stream->res, vmw_stream_destroy);\r\nreturn 0;\r\n}\r\nstatic void vmw_user_stream_free(struct vmw_resource *res)\r\n{\r\nstruct vmw_user_stream *stream =\r\ncontainer_of(res, struct vmw_user_stream, stream.res);\r\nstruct vmw_private *dev_priv = res->dev_priv;\r\nkfree(stream);\r\nttm_mem_global_free(vmw_mem_glob(dev_priv),\r\nvmw_user_stream_size);\r\n}\r\nstatic void vmw_user_stream_base_release(struct ttm_base_object **p_base)\r\n{\r\nstruct ttm_base_object *base = *p_base;\r\nstruct vmw_user_stream *stream =\r\ncontainer_of(base, struct vmw_user_stream, base);\r\nstruct vmw_resource *res = &stream->stream.res;\r\n*p_base = NULL;\r\nvmw_resource_unreference(&res);\r\n}\r\nint vmw_stream_unref_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct vmw_resource *res;\r\nstruct vmw_user_stream *stream;\r\nstruct drm_vmw_stream_arg *arg = (struct drm_vmw_stream_arg *)data;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nint ret = 0;\r\nres = vmw_resource_lookup(dev_priv, &dev_priv->stream_idr, arg->stream_id);\r\nif (unlikely(res == NULL))\r\nreturn -EINVAL;\r\nif (res->res_free != &vmw_user_stream_free) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nstream = container_of(res, struct vmw_user_stream, stream.res);\r\nif (stream->base.tfile != tfile) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nttm_ref_object_base_unref(tfile, stream->base.hash.key, TTM_REF_USAGE);\r\nout:\r\nvmw_resource_unreference(&res);\r\nreturn ret;\r\n}\r\nint vmw_stream_claim_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct vmw_user_stream *stream;\r\nstruct vmw_resource *res;\r\nstruct vmw_resource *tmp;\r\nstruct drm_vmw_stream_arg *arg = (struct drm_vmw_stream_arg *)data;\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nstruct vmw_master *vmaster = vmw_master(file_priv->master);\r\nint ret;\r\nif (unlikely(vmw_user_stream_size == 0))\r\nvmw_user_stream_size = ttm_round_pot(sizeof(*stream)) + 128;\r\nret = ttm_read_lock(&vmaster->lock, true);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nret = ttm_mem_global_alloc(vmw_mem_glob(dev_priv),\r\nvmw_user_stream_size,\r\nfalse, true);\r\nif (unlikely(ret != 0)) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("Out of graphics memory for stream"\r\n" creation.\n");\r\ngoto out_unlock;\r\n}\r\nstream = kmalloc(sizeof(*stream), GFP_KERNEL);\r\nif (unlikely(stream == NULL)) {\r\nttm_mem_global_free(vmw_mem_glob(dev_priv),\r\nvmw_user_stream_size);\r\nret = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nres = &stream->stream.res;\r\nstream->base.shareable = false;\r\nstream->base.tfile = NULL;\r\nret = vmw_stream_init(dev_priv, &stream->stream, vmw_user_stream_free);\r\nif (unlikely(ret != 0))\r\ngoto out_unlock;\r\ntmp = vmw_resource_reference(res);\r\nret = ttm_base_object_init(tfile, &stream->base, false, VMW_RES_STREAM,\r\n&vmw_user_stream_base_release, NULL);\r\nif (unlikely(ret != 0)) {\r\nvmw_resource_unreference(&tmp);\r\ngoto out_err;\r\n}\r\narg->stream_id = res->id;\r\nout_err:\r\nvmw_resource_unreference(&res);\r\nout_unlock:\r\nttm_read_unlock(&vmaster->lock);\r\nreturn ret;\r\n}\r\nint vmw_user_stream_lookup(struct vmw_private *dev_priv,\r\nstruct ttm_object_file *tfile,\r\nuint32_t *inout_id, struct vmw_resource **out)\r\n{\r\nstruct vmw_user_stream *stream;\r\nstruct vmw_resource *res;\r\nint ret;\r\nres = vmw_resource_lookup(dev_priv, &dev_priv->stream_idr, *inout_id);\r\nif (unlikely(res == NULL))\r\nreturn -EINVAL;\r\nif (res->res_free != &vmw_user_stream_free) {\r\nret = -EINVAL;\r\ngoto err_ref;\r\n}\r\nstream = container_of(res, struct vmw_user_stream, stream.res);\r\nif (stream->base.tfile != tfile) {\r\nret = -EPERM;\r\ngoto err_ref;\r\n}\r\n*inout_id = stream->stream.stream_id;\r\n*out = res;\r\nreturn 0;\r\nerr_ref:\r\nvmw_resource_unreference(&res);\r\nreturn ret;\r\n}
