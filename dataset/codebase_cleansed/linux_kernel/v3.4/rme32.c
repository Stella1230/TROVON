static inline unsigned int snd_rme32_pcm_byteptr(struct rme32 * rme32)\r\n{\r\nreturn (readl(rme32->iobase + RME32_IO_GET_POS)\r\n& RME32_RCR_AUDIO_ADDR_MASK);\r\n}\r\nstatic int snd_rme32_playback_silence(struct snd_pcm_substream *substream, int channel,\r\nsnd_pcm_uframes_t pos,\r\nsnd_pcm_uframes_t count)\r\n{\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\ncount <<= rme32->playback_frlog;\r\npos <<= rme32->playback_frlog;\r\nmemset_io(rme32->iobase + RME32_IO_DATA_BUFFER + pos, 0, count);\r\nreturn 0;\r\n}\r\nstatic int snd_rme32_playback_copy(struct snd_pcm_substream *substream, int channel,\r\nsnd_pcm_uframes_t pos,\r\nvoid __user *src, snd_pcm_uframes_t count)\r\n{\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\ncount <<= rme32->playback_frlog;\r\npos <<= rme32->playback_frlog;\r\nif (copy_from_user_toio(rme32->iobase + RME32_IO_DATA_BUFFER + pos,\r\nsrc, count))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int snd_rme32_capture_copy(struct snd_pcm_substream *substream, int channel,\r\nsnd_pcm_uframes_t pos,\r\nvoid __user *dst, snd_pcm_uframes_t count)\r\n{\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\ncount <<= rme32->capture_frlog;\r\npos <<= rme32->capture_frlog;\r\nif (copy_to_user_fromio(dst,\r\nrme32->iobase + RME32_IO_DATA_BUFFER + pos,\r\ncount))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic void snd_rme32_reset_dac(struct rme32 *rme32)\r\n{\r\nwritel(rme32->wcreg | RME32_WCR_PD,\r\nrme32->iobase + RME32_IO_CONTROL_REGISTER);\r\nwritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\r\n}\r\nstatic int snd_rme32_playback_getrate(struct rme32 * rme32)\r\n{\r\nint rate;\r\nrate = ((rme32->wcreg >> RME32_WCR_BITPOS_FREQ_0) & 1) +\r\n(((rme32->wcreg >> RME32_WCR_BITPOS_FREQ_1) & 1) << 1);\r\nswitch (rate) {\r\ncase 1:\r\nrate = 32000;\r\nbreak;\r\ncase 2:\r\nrate = 44100;\r\nbreak;\r\ncase 3:\r\nrate = 48000;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nreturn (rme32->wcreg & RME32_WCR_DS_BM) ? rate << 1 : rate;\r\n}\r\nstatic int snd_rme32_capture_getrate(struct rme32 * rme32, int *is_adat)\r\n{\r\nint n;\r\n*is_adat = 0;\r\nif (rme32->rcreg & RME32_RCR_LOCK) {\r\n*is_adat = 1;\r\n}\r\nif (rme32->rcreg & RME32_RCR_ERF) {\r\nreturn -1;\r\n}\r\nn = ((rme32->rcreg >> RME32_RCR_BITPOS_F0) & 1) +\r\n(((rme32->rcreg >> RME32_RCR_BITPOS_F1) & 1) << 1) +\r\n(((rme32->rcreg >> RME32_RCR_BITPOS_F2) & 1) << 2);\r\nif (RME32_PRO_WITH_8414(rme32))\r\nswitch (n) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\nreturn -1;\r\ncase 3:\r\nreturn 96000;\r\ncase 4:\r\nreturn 88200;\r\ncase 5:\r\nreturn 48000;\r\ncase 6:\r\nreturn 44100;\r\ncase 7:\r\nreturn 32000;\r\ndefault:\r\nreturn -1;\r\nbreak;\r\n}\r\nelse\r\nswitch (n) {\r\ncase 0:\r\nreturn -1;\r\ncase 1:\r\nreturn 48000;\r\ncase 2:\r\nreturn 44100;\r\ncase 3:\r\nreturn 32000;\r\ncase 4:\r\nreturn 48000;\r\ncase 5:\r\nreturn 44100;\r\ncase 6:\r\nreturn 44056;\r\ncase 7:\r\nreturn 32000;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -1;\r\n}\r\nstatic int snd_rme32_playback_setrate(struct rme32 * rme32, int rate)\r\n{\r\nint ds;\r\nds = rme32->wcreg & RME32_WCR_DS_BM;\r\nswitch (rate) {\r\ncase 32000:\r\nrme32->wcreg &= ~RME32_WCR_DS_BM;\r\nrme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) &\r\n~RME32_WCR_FREQ_1;\r\nbreak;\r\ncase 44100:\r\nrme32->wcreg &= ~RME32_WCR_DS_BM;\r\nrme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_1) &\r\n~RME32_WCR_FREQ_0;\r\nbreak;\r\ncase 48000:\r\nrme32->wcreg &= ~RME32_WCR_DS_BM;\r\nrme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) |\r\nRME32_WCR_FREQ_1;\r\nbreak;\r\ncase 64000:\r\nif (rme32->pci->device != PCI_DEVICE_ID_RME_DIGI32_PRO)\r\nreturn -EINVAL;\r\nrme32->wcreg |= RME32_WCR_DS_BM;\r\nrme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) &\r\n~RME32_WCR_FREQ_1;\r\nbreak;\r\ncase 88200:\r\nif (rme32->pci->device != PCI_DEVICE_ID_RME_DIGI32_PRO)\r\nreturn -EINVAL;\r\nrme32->wcreg |= RME32_WCR_DS_BM;\r\nrme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_1) &\r\n~RME32_WCR_FREQ_0;\r\nbreak;\r\ncase 96000:\r\nif (rme32->pci->device != PCI_DEVICE_ID_RME_DIGI32_PRO)\r\nreturn -EINVAL;\r\nrme32->wcreg |= RME32_WCR_DS_BM;\r\nrme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) |\r\nRME32_WCR_FREQ_1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((!ds && rme32->wcreg & RME32_WCR_DS_BM) ||\r\n(ds && !(rme32->wcreg & RME32_WCR_DS_BM)))\r\n{\r\nsnd_rme32_reset_dac(rme32);\r\n} else {\r\nwritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_rme32_setclockmode(struct rme32 * rme32, int mode)\r\n{\r\nswitch (mode) {\r\ncase RME32_CLOCKMODE_SLAVE:\r\nrme32->wcreg = (rme32->wcreg & ~RME32_WCR_FREQ_0) &\r\n~RME32_WCR_FREQ_1;\r\nbreak;\r\ncase RME32_CLOCKMODE_MASTER_32:\r\nrme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) &\r\n~RME32_WCR_FREQ_1;\r\nbreak;\r\ncase RME32_CLOCKMODE_MASTER_44:\r\nrme32->wcreg = (rme32->wcreg & ~RME32_WCR_FREQ_0) |\r\nRME32_WCR_FREQ_1;\r\nbreak;\r\ncase RME32_CLOCKMODE_MASTER_48:\r\nrme32->wcreg = (rme32->wcreg | RME32_WCR_FREQ_0) |\r\nRME32_WCR_FREQ_1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\r\nreturn 0;\r\n}\r\nstatic int snd_rme32_getclockmode(struct rme32 * rme32)\r\n{\r\nreturn ((rme32->wcreg >> RME32_WCR_BITPOS_FREQ_0) & 1) +\r\n(((rme32->wcreg >> RME32_WCR_BITPOS_FREQ_1) & 1) << 1);\r\n}\r\nstatic int snd_rme32_setinputtype(struct rme32 * rme32, int type)\r\n{\r\nswitch (type) {\r\ncase RME32_INPUT_OPTICAL:\r\nrme32->wcreg = (rme32->wcreg & ~RME32_WCR_INP_0) &\r\n~RME32_WCR_INP_1;\r\nbreak;\r\ncase RME32_INPUT_COAXIAL:\r\nrme32->wcreg = (rme32->wcreg | RME32_WCR_INP_0) &\r\n~RME32_WCR_INP_1;\r\nbreak;\r\ncase RME32_INPUT_INTERNAL:\r\nrme32->wcreg = (rme32->wcreg & ~RME32_WCR_INP_0) |\r\nRME32_WCR_INP_1;\r\nbreak;\r\ncase RME32_INPUT_XLR:\r\nrme32->wcreg = (rme32->wcreg | RME32_WCR_INP_0) |\r\nRME32_WCR_INP_1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\r\nreturn 0;\r\n}\r\nstatic int snd_rme32_getinputtype(struct rme32 * rme32)\r\n{\r\nreturn ((rme32->wcreg >> RME32_WCR_BITPOS_INP_0) & 1) +\r\n(((rme32->wcreg >> RME32_WCR_BITPOS_INP_1) & 1) << 1);\r\n}\r\nstatic void\r\nsnd_rme32_setframelog(struct rme32 * rme32, int n_channels, int is_playback)\r\n{\r\nint frlog;\r\nif (n_channels == 2) {\r\nfrlog = 1;\r\n} else {\r\nfrlog = 3;\r\n}\r\nif (is_playback) {\r\nfrlog += (rme32->wcreg & RME32_WCR_MODE24) ? 2 : 1;\r\nrme32->playback_frlog = frlog;\r\n} else {\r\nfrlog += (rme32->wcreg & RME32_WCR_MODE24) ? 2 : 1;\r\nrme32->capture_frlog = frlog;\r\n}\r\n}\r\nstatic int snd_rme32_setformat(struct rme32 * rme32, int format)\r\n{\r\nswitch (format) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nrme32->wcreg &= ~RME32_WCR_MODE24;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nrme32->wcreg |= RME32_WCR_MODE24;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme32_playback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nint err, rate, dummy;\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (rme32->fullduplex_mode) {\r\nerr = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));\r\nif (err < 0)\r\nreturn err;\r\n} else {\r\nruntime->dma_area = (void __force *)(rme32->iobase +\r\nRME32_IO_DATA_BUFFER);\r\nruntime->dma_addr = rme32->port + RME32_IO_DATA_BUFFER;\r\nruntime->dma_bytes = RME32_BUFFER_SIZE;\r\n}\r\nspin_lock_irq(&rme32->lock);\r\nif ((rme32->rcreg & RME32_RCR_KMODE) &&\r\n(rate = snd_rme32_capture_getrate(rme32, &dummy)) > 0) {\r\nif ((int)params_rate(params) != rate) {\r\nspin_unlock_irq(&rme32->lock);\r\nreturn -EIO;\r\n}\r\n} else if ((err = snd_rme32_playback_setrate(rme32, params_rate(params))) < 0) {\r\nspin_unlock_irq(&rme32->lock);\r\nreturn err;\r\n}\r\nif ((err = snd_rme32_setformat(rme32, params_format(params))) < 0) {\r\nspin_unlock_irq(&rme32->lock);\r\nreturn err;\r\n}\r\nsnd_rme32_setframelog(rme32, params_channels(params), 1);\r\nif (rme32->capture_periodsize != 0) {\r\nif (params_period_size(params) << rme32->playback_frlog != rme32->capture_periodsize) {\r\nspin_unlock_irq(&rme32->lock);\r\nreturn -EBUSY;\r\n}\r\n}\r\nrme32->playback_periodsize = params_period_size(params) << rme32->playback_frlog;\r\nif ((rme32->wcreg & RME32_WCR_ADAT) == 0) {\r\nrme32->wcreg &= ~(RME32_WCR_PRO | RME32_WCR_EMP);\r\nrme32->wcreg |= rme32->wcreg_spdif_stream;\r\nwritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\r\n}\r\nspin_unlock_irq(&rme32->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme32_capture_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nint err, isadat, rate;\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (rme32->fullduplex_mode) {\r\nerr = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));\r\nif (err < 0)\r\nreturn err;\r\n} else {\r\nruntime->dma_area = (void __force *)rme32->iobase +\r\nRME32_IO_DATA_BUFFER;\r\nruntime->dma_addr = rme32->port + RME32_IO_DATA_BUFFER;\r\nruntime->dma_bytes = RME32_BUFFER_SIZE;\r\n}\r\nspin_lock_irq(&rme32->lock);\r\nrme32->wcreg |= RME32_WCR_AUTOSYNC;\r\nwritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\r\nif ((err = snd_rme32_setformat(rme32, params_format(params))) < 0) {\r\nspin_unlock_irq(&rme32->lock);\r\nreturn err;\r\n}\r\nif ((err = snd_rme32_playback_setrate(rme32, params_rate(params))) < 0) {\r\nspin_unlock_irq(&rme32->lock);\r\nreturn err;\r\n}\r\nif ((rate = snd_rme32_capture_getrate(rme32, &isadat)) > 0) {\r\nif ((int)params_rate(params) != rate) {\r\nspin_unlock_irq(&rme32->lock);\r\nreturn -EIO;\r\n}\r\nif ((isadat && runtime->hw.channels_min == 2) ||\r\n(!isadat && runtime->hw.channels_min == 8)) {\r\nspin_unlock_irq(&rme32->lock);\r\nreturn -EIO;\r\n}\r\n}\r\nrme32->wcreg &= ~RME32_WCR_AUTOSYNC;\r\nwritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\r\nsnd_rme32_setframelog(rme32, params_channels(params), 0);\r\nif (rme32->playback_periodsize != 0) {\r\nif (params_period_size(params) << rme32->capture_frlog !=\r\nrme32->playback_periodsize) {\r\nspin_unlock_irq(&rme32->lock);\r\nreturn -EBUSY;\r\n}\r\n}\r\nrme32->capture_periodsize =\r\nparams_period_size(params) << rme32->capture_frlog;\r\nspin_unlock_irq(&rme32->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_rme32_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\nif (! rme32->fullduplex_mode)\r\nreturn 0;\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic void snd_rme32_pcm_start(struct rme32 * rme32, int from_pause)\r\n{\r\nif (!from_pause) {\r\nwritel(0, rme32->iobase + RME32_IO_RESET_POS);\r\n}\r\nrme32->wcreg |= RME32_WCR_START;\r\nwritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\r\n}\r\nstatic void snd_rme32_pcm_stop(struct rme32 * rme32, int to_pause)\r\n{\r\nrme32->rcreg = readl(rme32->iobase + RME32_IO_CONTROL_REGISTER);\r\nif (rme32->rcreg & RME32_RCR_IRQ) {\r\nwritel(0, rme32->iobase + RME32_IO_CONFIRM_ACTION_IRQ);\r\n}\r\nrme32->wcreg &= ~RME32_WCR_START;\r\nif (rme32->wcreg & RME32_WCR_SEL)\r\nrme32->wcreg |= RME32_WCR_MUTE;\r\nwritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\r\nif (! to_pause)\r\nwritel(0, rme32->iobase + RME32_IO_RESET_POS);\r\n}\r\nstatic irqreturn_t snd_rme32_interrupt(int irq, void *dev_id)\r\n{\r\nstruct rme32 *rme32 = (struct rme32 *) dev_id;\r\nrme32->rcreg = readl(rme32->iobase + RME32_IO_CONTROL_REGISTER);\r\nif (!(rme32->rcreg & RME32_RCR_IRQ)) {\r\nreturn IRQ_NONE;\r\n} else {\r\nif (rme32->capture_substream) {\r\nsnd_pcm_period_elapsed(rme32->capture_substream);\r\n}\r\nif (rme32->playback_substream) {\r\nsnd_pcm_period_elapsed(rme32->playback_substream);\r\n}\r\nwritel(0, rme32->iobase + RME32_IO_CONFIRM_ACTION_IRQ);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void snd_rme32_set_buffer_constraint(struct rme32 *rme32, struct snd_pcm_runtime *runtime)\r\n{\r\nif (! rme32->fullduplex_mode) {\r\nsnd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_BUFFER_BYTES,\r\nRME32_BUFFER_SIZE, RME32_BUFFER_SIZE);\r\nsnd_pcm_hw_constraint_list(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_BYTES,\r\n&hw_constraints_period_bytes);\r\n}\r\n}\r\nstatic int snd_rme32_playback_spdif_open(struct snd_pcm_substream *substream)\r\n{\r\nint rate, dummy;\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_set_sync(substream);\r\nspin_lock_irq(&rme32->lock);\r\nif (rme32->playback_substream != NULL) {\r\nspin_unlock_irq(&rme32->lock);\r\nreturn -EBUSY;\r\n}\r\nrme32->wcreg &= ~RME32_WCR_ADAT;\r\nwritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\r\nrme32->playback_substream = substream;\r\nspin_unlock_irq(&rme32->lock);\r\nif (rme32->fullduplex_mode)\r\nruntime->hw = snd_rme32_spdif_fd_info;\r\nelse\r\nruntime->hw = snd_rme32_spdif_info;\r\nif (rme32->pci->device == PCI_DEVICE_ID_RME_DIGI32_PRO) {\r\nruntime->hw.rates |= SNDRV_PCM_RATE_64000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000;\r\nruntime->hw.rate_max = 96000;\r\n}\r\nif ((rme32->rcreg & RME32_RCR_KMODE) &&\r\n(rate = snd_rme32_capture_getrate(rme32, &dummy)) > 0) {\r\nruntime->hw.rates = snd_pcm_rate_to_rate_bit(rate);\r\nruntime->hw.rate_min = rate;\r\nruntime->hw.rate_max = rate;\r\n}\r\nsnd_rme32_set_buffer_constraint(rme32, runtime);\r\nrme32->wcreg_spdif_stream = rme32->wcreg_spdif;\r\nrme32->spdif_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(rme32->card, SNDRV_CTL_EVENT_MASK_VALUE |\r\nSNDRV_CTL_EVENT_MASK_INFO, &rme32->spdif_ctl->id);\r\nreturn 0;\r\n}\r\nstatic int snd_rme32_capture_spdif_open(struct snd_pcm_substream *substream)\r\n{\r\nint isadat, rate;\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_set_sync(substream);\r\nspin_lock_irq(&rme32->lock);\r\nif (rme32->capture_substream != NULL) {\r\nspin_unlock_irq(&rme32->lock);\r\nreturn -EBUSY;\r\n}\r\nrme32->capture_substream = substream;\r\nspin_unlock_irq(&rme32->lock);\r\nif (rme32->fullduplex_mode)\r\nruntime->hw = snd_rme32_spdif_fd_info;\r\nelse\r\nruntime->hw = snd_rme32_spdif_info;\r\nif (RME32_PRO_WITH_8414(rme32)) {\r\nruntime->hw.rates |= SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000;\r\nruntime->hw.rate_max = 96000;\r\n}\r\nif ((rate = snd_rme32_capture_getrate(rme32, &isadat)) > 0) {\r\nif (isadat) {\r\nreturn -EIO;\r\n}\r\nruntime->hw.rates = snd_pcm_rate_to_rate_bit(rate);\r\nruntime->hw.rate_min = rate;\r\nruntime->hw.rate_max = rate;\r\n}\r\nsnd_rme32_set_buffer_constraint(rme32, runtime);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme32_playback_adat_open(struct snd_pcm_substream *substream)\r\n{\r\nint rate, dummy;\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_set_sync(substream);\r\nspin_lock_irq(&rme32->lock);\r\nif (rme32->playback_substream != NULL) {\r\nspin_unlock_irq(&rme32->lock);\r\nreturn -EBUSY;\r\n}\r\nrme32->wcreg |= RME32_WCR_ADAT;\r\nwritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\r\nrme32->playback_substream = substream;\r\nspin_unlock_irq(&rme32->lock);\r\nif (rme32->fullduplex_mode)\r\nruntime->hw = snd_rme32_adat_fd_info;\r\nelse\r\nruntime->hw = snd_rme32_adat_info;\r\nif ((rme32->rcreg & RME32_RCR_KMODE) &&\r\n(rate = snd_rme32_capture_getrate(rme32, &dummy)) > 0) {\r\nruntime->hw.rates = snd_pcm_rate_to_rate_bit(rate);\r\nruntime->hw.rate_min = rate;\r\nruntime->hw.rate_max = rate;\r\n}\r\nsnd_rme32_set_buffer_constraint(rme32, runtime);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme32_capture_adat_open(struct snd_pcm_substream *substream)\r\n{\r\nint isadat, rate;\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (rme32->fullduplex_mode)\r\nruntime->hw = snd_rme32_adat_fd_info;\r\nelse\r\nruntime->hw = snd_rme32_adat_info;\r\nif ((rate = snd_rme32_capture_getrate(rme32, &isadat)) > 0) {\r\nif (!isadat) {\r\nreturn -EIO;\r\n}\r\nruntime->hw.rates = snd_pcm_rate_to_rate_bit(rate);\r\nruntime->hw.rate_min = rate;\r\nruntime->hw.rate_max = rate;\r\n}\r\nsnd_pcm_set_sync(substream);\r\nspin_lock_irq(&rme32->lock);\r\nif (rme32->capture_substream != NULL) {\r\nspin_unlock_irq(&rme32->lock);\r\nreturn -EBUSY;\r\n}\r\nrme32->capture_substream = substream;\r\nspin_unlock_irq(&rme32->lock);\r\nsnd_rme32_set_buffer_constraint(rme32, runtime);\r\nreturn 0;\r\n}\r\nstatic int snd_rme32_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\nint spdif = 0;\r\nspin_lock_irq(&rme32->lock);\r\nrme32->playback_substream = NULL;\r\nrme32->playback_periodsize = 0;\r\nspdif = (rme32->wcreg & RME32_WCR_ADAT) == 0;\r\nspin_unlock_irq(&rme32->lock);\r\nif (spdif) {\r\nrme32->spdif_ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(rme32->card, SNDRV_CTL_EVENT_MASK_VALUE |\r\nSNDRV_CTL_EVENT_MASK_INFO,\r\n&rme32->spdif_ctl->id);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_rme32_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\nspin_lock_irq(&rme32->lock);\r\nrme32->capture_substream = NULL;\r\nrme32->capture_periodsize = 0;\r\nspin_unlock(&rme32->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_rme32_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\nspin_lock_irq(&rme32->lock);\r\nif (rme32->fullduplex_mode) {\r\nmemset(&rme32->playback_pcm, 0, sizeof(rme32->playback_pcm));\r\nrme32->playback_pcm.hw_buffer_size = RME32_BUFFER_SIZE;\r\nrme32->playback_pcm.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);\r\n} else {\r\nwritel(0, rme32->iobase + RME32_IO_RESET_POS);\r\n}\r\nif (rme32->wcreg & RME32_WCR_SEL)\r\nrme32->wcreg &= ~RME32_WCR_MUTE;\r\nwritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\r\nspin_unlock_irq(&rme32->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_rme32_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\nspin_lock_irq(&rme32->lock);\r\nif (rme32->fullduplex_mode) {\r\nmemset(&rme32->capture_pcm, 0, sizeof(rme32->capture_pcm));\r\nrme32->capture_pcm.hw_buffer_size = RME32_BUFFER_SIZE;\r\nrme32->capture_pcm.hw_queue_size = RME32_BUFFER_SIZE / 2;\r\nrme32->capture_pcm.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);\r\n} else {\r\nwritel(0, rme32->iobase + RME32_IO_RESET_POS);\r\n}\r\nspin_unlock_irq(&rme32->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme32_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_substream *s;\r\nspin_lock(&rme32->lock);\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s != rme32->playback_substream &&\r\ns != rme32->capture_substream)\r\ncontinue;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nrme32->running |= (1 << s->stream);\r\nif (rme32->fullduplex_mode) {\r\nif (s == rme32->playback_substream) {\r\nrme32->playback_pcm.hw_io =\r\nrme32->playback_pcm.hw_data = snd_rme32_pcm_byteptr(rme32);\r\n} else {\r\nrme32->capture_pcm.hw_io =\r\nrme32->capture_pcm.hw_data = snd_rme32_pcm_byteptr(rme32);\r\n}\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nrme32->running &= ~(1 << s->stream);\r\nbreak;\r\n}\r\nsnd_pcm_trigger_done(s, substream);\r\n}\r\nif (cmd == SNDRV_PCM_TRIGGER_START && rme32->fullduplex_mode) {\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s == rme32->playback_substream) {\r\ns->ops->ack(s);\r\nbreak;\r\n}\r\n}\r\n}\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nif (rme32->running && ! RME32_ISWORKING(rme32))\r\nsnd_rme32_pcm_start(rme32, 0);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nif (! rme32->running && RME32_ISWORKING(rme32))\r\nsnd_rme32_pcm_stop(rme32, 0);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (rme32->running && RME32_ISWORKING(rme32))\r\nsnd_rme32_pcm_stop(rme32, 1);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (rme32->running && ! RME32_ISWORKING(rme32))\r\nsnd_rme32_pcm_start(rme32, 1);\r\nbreak;\r\n}\r\nspin_unlock(&rme32->lock);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_rme32_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\nreturn snd_rme32_pcm_byteptr(rme32) >> rme32->playback_frlog;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_rme32_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\nreturn snd_rme32_pcm_byteptr(rme32) >> rme32->capture_frlog;\r\n}\r\nstatic void snd_rme32_pb_trans_copy(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_indirect *rec, size_t bytes)\r\n{\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\nmemcpy_toio(rme32->iobase + RME32_IO_DATA_BUFFER + rec->hw_data,\r\nsubstream->runtime->dma_area + rec->sw_data, bytes);\r\n}\r\nstatic int snd_rme32_playback_fd_ack(struct snd_pcm_substream *substream)\r\n{\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_indirect *rec, *cprec;\r\nrec = &rme32->playback_pcm;\r\ncprec = &rme32->capture_pcm;\r\nspin_lock(&rme32->lock);\r\nrec->hw_queue_size = RME32_BUFFER_SIZE;\r\nif (rme32->running & (1 << SNDRV_PCM_STREAM_CAPTURE))\r\nrec->hw_queue_size -= cprec->hw_ready;\r\nspin_unlock(&rme32->lock);\r\nsnd_pcm_indirect_playback_transfer(substream, rec,\r\nsnd_rme32_pb_trans_copy);\r\nreturn 0;\r\n}\r\nstatic void snd_rme32_cp_trans_copy(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_indirect *rec, size_t bytes)\r\n{\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\nmemcpy_fromio(substream->runtime->dma_area + rec->sw_data,\r\nrme32->iobase + RME32_IO_DATA_BUFFER + rec->hw_data,\r\nbytes);\r\n}\r\nstatic int snd_rme32_capture_fd_ack(struct snd_pcm_substream *substream)\r\n{\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\nsnd_pcm_indirect_capture_transfer(substream, &rme32->capture_pcm,\r\nsnd_rme32_cp_trans_copy);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_rme32_playback_fd_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\nreturn snd_pcm_indirect_playback_pointer(substream, &rme32->playback_pcm,\r\nsnd_rme32_pcm_byteptr(rme32));\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_rme32_capture_fd_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct rme32 *rme32 = snd_pcm_substream_chip(substream);\r\nreturn snd_pcm_indirect_capture_pointer(substream, &rme32->capture_pcm,\r\nsnd_rme32_pcm_byteptr(rme32));\r\n}\r\nstatic void snd_rme32_free(void *private_data)\r\n{\r\nstruct rme32 *rme32 = (struct rme32 *) private_data;\r\nif (rme32 == NULL) {\r\nreturn;\r\n}\r\nif (rme32->irq >= 0) {\r\nsnd_rme32_pcm_stop(rme32, 0);\r\nfree_irq(rme32->irq, (void *) rme32);\r\nrme32->irq = -1;\r\n}\r\nif (rme32->iobase) {\r\niounmap(rme32->iobase);\r\nrme32->iobase = NULL;\r\n}\r\nif (rme32->port) {\r\npci_release_regions(rme32->pci);\r\nrme32->port = 0;\r\n}\r\npci_disable_device(rme32->pci);\r\n}\r\nstatic void snd_rme32_free_spdif_pcm(struct snd_pcm *pcm)\r\n{\r\nstruct rme32 *rme32 = (struct rme32 *) pcm->private_data;\r\nrme32->spdif_pcm = NULL;\r\n}\r\nstatic void\r\nsnd_rme32_free_adat_pcm(struct snd_pcm *pcm)\r\n{\r\nstruct rme32 *rme32 = (struct rme32 *) pcm->private_data;\r\nrme32->adat_pcm = NULL;\r\n}\r\nstatic int __devinit snd_rme32_create(struct rme32 * rme32)\r\n{\r\nstruct pci_dev *pci = rme32->pci;\r\nint err;\r\nrme32->irq = -1;\r\nspin_lock_init(&rme32->lock);\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nif ((err = pci_request_regions(pci, "RME32")) < 0)\r\nreturn err;\r\nrme32->port = pci_resource_start(rme32->pci, 0);\r\nrme32->iobase = ioremap_nocache(rme32->port, RME32_IO_SIZE);\r\nif (!rme32->iobase) {\r\nsnd_printk(KERN_ERR "unable to remap memory region 0x%lx-0x%lx\n",\r\nrme32->port, rme32->port + RME32_IO_SIZE - 1);\r\nreturn -ENOMEM;\r\n}\r\nif (request_irq(pci->irq, snd_rme32_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, rme32)) {\r\nsnd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);\r\nreturn -EBUSY;\r\n}\r\nrme32->irq = pci->irq;\r\npci_read_config_byte(pci, 8, &rme32->rev);\r\nif ((err = snd_pcm_new(rme32->card, "Digi32 IEC958", 0, 1, 1, &rme32->spdif_pcm)) < 0) {\r\nreturn err;\r\n}\r\nrme32->spdif_pcm->private_data = rme32;\r\nrme32->spdif_pcm->private_free = snd_rme32_free_spdif_pcm;\r\nstrcpy(rme32->spdif_pcm->name, "Digi32 IEC958");\r\nif (rme32->fullduplex_mode) {\r\nsnd_pcm_set_ops(rme32->spdif_pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_rme32_playback_spdif_fd_ops);\r\nsnd_pcm_set_ops(rme32->spdif_pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&snd_rme32_capture_spdif_fd_ops);\r\nsnd_pcm_lib_preallocate_pages_for_all(rme32->spdif_pcm, SNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL),\r\n0, RME32_MID_BUFFER_SIZE);\r\nrme32->spdif_pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;\r\n} else {\r\nsnd_pcm_set_ops(rme32->spdif_pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_rme32_playback_spdif_ops);\r\nsnd_pcm_set_ops(rme32->spdif_pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&snd_rme32_capture_spdif_ops);\r\nrme32->spdif_pcm->info_flags = SNDRV_PCM_INFO_HALF_DUPLEX;\r\n}\r\nif ((pci->device == PCI_DEVICE_ID_RME_DIGI32) ||\r\n(pci->device == PCI_DEVICE_ID_RME_DIGI32_PRO)) {\r\nrme32->adat_pcm = NULL;\r\n}\r\nelse {\r\nif ((err = snd_pcm_new(rme32->card, "Digi32 ADAT", 1,\r\n1, 1, &rme32->adat_pcm)) < 0)\r\n{\r\nreturn err;\r\n}\r\nrme32->adat_pcm->private_data = rme32;\r\nrme32->adat_pcm->private_free = snd_rme32_free_adat_pcm;\r\nstrcpy(rme32->adat_pcm->name, "Digi32 ADAT");\r\nif (rme32->fullduplex_mode) {\r\nsnd_pcm_set_ops(rme32->adat_pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_rme32_playback_adat_fd_ops);\r\nsnd_pcm_set_ops(rme32->adat_pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&snd_rme32_capture_adat_fd_ops);\r\nsnd_pcm_lib_preallocate_pages_for_all(rme32->adat_pcm, SNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL),\r\n0, RME32_MID_BUFFER_SIZE);\r\nrme32->adat_pcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;\r\n} else {\r\nsnd_pcm_set_ops(rme32->adat_pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_rme32_playback_adat_ops);\r\nsnd_pcm_set_ops(rme32->adat_pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&snd_rme32_capture_adat_ops);\r\nrme32->adat_pcm->info_flags = SNDRV_PCM_INFO_HALF_DUPLEX;\r\n}\r\n}\r\nrme32->playback_periodsize = 0;\r\nrme32->capture_periodsize = 0;\r\nsnd_rme32_pcm_stop(rme32, 0);\r\nsnd_rme32_reset_dac(rme32);\r\nwritel(0, rme32->iobase + RME32_IO_RESET_POS);\r\nrme32->wcreg = RME32_WCR_SEL |\r\nRME32_WCR_INP_0 |\r\nRME32_WCR_MUTE;\r\nwritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\r\nif ((err = snd_rme32_create_switches(rme32->card, rme32)) < 0) {\r\nreturn err;\r\n}\r\nsnd_rme32_proc_init(rme32);\r\nrme32->capture_substream = NULL;\r\nrme32->playback_substream = NULL;\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_rme32_proc_read(struct snd_info_entry * entry, struct snd_info_buffer *buffer)\r\n{\r\nint n;\r\nstruct rme32 *rme32 = (struct rme32 *) entry->private_data;\r\nrme32->rcreg = readl(rme32->iobase + RME32_IO_CONTROL_REGISTER);\r\nsnd_iprintf(buffer, rme32->card->longname);\r\nsnd_iprintf(buffer, " (index #%d)\n", rme32->card->number + 1);\r\nsnd_iprintf(buffer, "\nGeneral settings\n");\r\nif (rme32->fullduplex_mode)\r\nsnd_iprintf(buffer, " Full-duplex mode\n");\r\nelse\r\nsnd_iprintf(buffer, " Half-duplex mode\n");\r\nif (RME32_PRO_WITH_8414(rme32)) {\r\nsnd_iprintf(buffer, " receiver: CS8414\n");\r\n} else {\r\nsnd_iprintf(buffer, " receiver: CS8412\n");\r\n}\r\nif (rme32->wcreg & RME32_WCR_MODE24) {\r\nsnd_iprintf(buffer, " format: 24 bit");\r\n} else {\r\nsnd_iprintf(buffer, " format: 16 bit");\r\n}\r\nif (rme32->wcreg & RME32_WCR_MONO) {\r\nsnd_iprintf(buffer, ", Mono\n");\r\n} else {\r\nsnd_iprintf(buffer, ", Stereo\n");\r\n}\r\nsnd_iprintf(buffer, "\nInput settings\n");\r\nswitch (snd_rme32_getinputtype(rme32)) {\r\ncase RME32_INPUT_OPTICAL:\r\nsnd_iprintf(buffer, " input: optical");\r\nbreak;\r\ncase RME32_INPUT_COAXIAL:\r\nsnd_iprintf(buffer, " input: coaxial");\r\nbreak;\r\ncase RME32_INPUT_INTERNAL:\r\nsnd_iprintf(buffer, " input: internal");\r\nbreak;\r\ncase RME32_INPUT_XLR:\r\nsnd_iprintf(buffer, " input: XLR");\r\nbreak;\r\n}\r\nif (snd_rme32_capture_getrate(rme32, &n) < 0) {\r\nsnd_iprintf(buffer, "\n sample rate: no valid signal\n");\r\n} else {\r\nif (n) {\r\nsnd_iprintf(buffer, " (8 channels)\n");\r\n} else {\r\nsnd_iprintf(buffer, " (2 channels)\n");\r\n}\r\nsnd_iprintf(buffer, " sample rate: %d Hz\n",\r\nsnd_rme32_capture_getrate(rme32, &n));\r\n}\r\nsnd_iprintf(buffer, "\nOutput settings\n");\r\nif (rme32->wcreg & RME32_WCR_SEL) {\r\nsnd_iprintf(buffer, " output signal: normal playback");\r\n} else {\r\nsnd_iprintf(buffer, " output signal: same as input");\r\n}\r\nif (rme32->wcreg & RME32_WCR_MUTE) {\r\nsnd_iprintf(buffer, " (muted)\n");\r\n} else {\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nif (!\r\n((!(rme32->wcreg & RME32_WCR_FREQ_0))\r\n&& (!(rme32->wcreg & RME32_WCR_FREQ_1)))) {\r\nsnd_iprintf(buffer, " sample rate: %d Hz\n",\r\nsnd_rme32_playback_getrate(rme32));\r\n}\r\nif (rme32->rcreg & RME32_RCR_KMODE) {\r\nsnd_iprintf(buffer, " sample clock source: AutoSync\n");\r\n} else {\r\nsnd_iprintf(buffer, " sample clock source: Internal\n");\r\n}\r\nif (rme32->wcreg & RME32_WCR_PRO) {\r\nsnd_iprintf(buffer, " format: AES/EBU (professional)\n");\r\n} else {\r\nsnd_iprintf(buffer, " format: IEC958 (consumer)\n");\r\n}\r\nif (rme32->wcreg & RME32_WCR_EMP) {\r\nsnd_iprintf(buffer, " emphasis: on\n");\r\n} else {\r\nsnd_iprintf(buffer, " emphasis: off\n");\r\n}\r\n}\r\nstatic void __devinit snd_rme32_proc_init(struct rme32 * rme32)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (! snd_card_proc_new(rme32->card, "rme32", &entry))\r\nsnd_info_set_text_ops(entry, rme32, snd_rme32_proc_read);\r\n}\r\nstatic int\r\nsnd_rme32_get_loopback_control(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&rme32->lock);\r\nucontrol->value.integer.value[0] =\r\nrme32->wcreg & RME32_WCR_SEL ? 0 : 1;\r\nspin_unlock_irq(&rme32->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme32_put_loopback_control(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint change;\r\nval = ucontrol->value.integer.value[0] ? 0 : RME32_WCR_SEL;\r\nspin_lock_irq(&rme32->lock);\r\nval = (rme32->wcreg & ~RME32_WCR_SEL) | val;\r\nchange = val != rme32->wcreg;\r\nif (ucontrol->value.integer.value[0])\r\nval &= ~RME32_WCR_MUTE;\r\nelse\r\nval |= RME32_WCR_MUTE;\r\nrme32->wcreg = val;\r\nwritel(val, rme32->iobase + RME32_IO_CONTROL_REGISTER);\r\nspin_unlock_irq(&rme32->lock);\r\nreturn change;\r\n}\r\nstatic int\r\nsnd_rme32_info_inputtype_control(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\r\nstatic char *texts[4] = { "Optical", "Coaxial", "Internal", "XLR" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nswitch (rme32->pci->device) {\r\ncase PCI_DEVICE_ID_RME_DIGI32:\r\ncase PCI_DEVICE_ID_RME_DIGI32_8:\r\nuinfo->value.enumerated.items = 3;\r\nbreak;\r\ncase PCI_DEVICE_ID_RME_DIGI32_PRO:\r\nuinfo->value.enumerated.items = 4;\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nbreak;\r\n}\r\nif (uinfo->value.enumerated.item >\r\nuinfo->value.enumerated.items - 1) {\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\n}\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme32_get_inputtype_control(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\r\nunsigned int items = 3;\r\nspin_lock_irq(&rme32->lock);\r\nucontrol->value.enumerated.item[0] = snd_rme32_getinputtype(rme32);\r\nswitch (rme32->pci->device) {\r\ncase PCI_DEVICE_ID_RME_DIGI32:\r\ncase PCI_DEVICE_ID_RME_DIGI32_8:\r\nitems = 3;\r\nbreak;\r\ncase PCI_DEVICE_ID_RME_DIGI32_PRO:\r\nitems = 4;\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nbreak;\r\n}\r\nif (ucontrol->value.enumerated.item[0] >= items) {\r\nucontrol->value.enumerated.item[0] = items - 1;\r\n}\r\nspin_unlock_irq(&rme32->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme32_put_inputtype_control(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint change, items = 3;\r\nswitch (rme32->pci->device) {\r\ncase PCI_DEVICE_ID_RME_DIGI32:\r\ncase PCI_DEVICE_ID_RME_DIGI32_8:\r\nitems = 3;\r\nbreak;\r\ncase PCI_DEVICE_ID_RME_DIGI32_PRO:\r\nitems = 4;\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nbreak;\r\n}\r\nval = ucontrol->value.enumerated.item[0] % items;\r\nspin_lock_irq(&rme32->lock);\r\nchange = val != (unsigned int)snd_rme32_getinputtype(rme32);\r\nsnd_rme32_setinputtype(rme32, val);\r\nspin_unlock_irq(&rme32->lock);\r\nreturn change;\r\n}\r\nstatic int\r\nsnd_rme32_info_clockmode_control(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[4] = { "AutoSync",\r\n"Internal 32.0kHz",\r\n"Internal 44.1kHz",\r\n"Internal 48.0kHz" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 4;\r\nif (uinfo->value.enumerated.item > 3) {\r\nuinfo->value.enumerated.item = 3;\r\n}\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme32_get_clockmode_control(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&rme32->lock);\r\nucontrol->value.enumerated.item[0] = snd_rme32_getclockmode(rme32);\r\nspin_unlock_irq(&rme32->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_rme32_put_clockmode_control(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint change;\r\nval = ucontrol->value.enumerated.item[0] % 3;\r\nspin_lock_irq(&rme32->lock);\r\nchange = val != (unsigned int)snd_rme32_getclockmode(rme32);\r\nsnd_rme32_setclockmode(rme32, val);\r\nspin_unlock_irq(&rme32->lock);\r\nreturn change;\r\n}\r\nstatic u32 snd_rme32_convert_from_aes(struct snd_aes_iec958 * aes)\r\n{\r\nu32 val = 0;\r\nval |= (aes->status[0] & IEC958_AES0_PROFESSIONAL) ? RME32_WCR_PRO : 0;\r\nif (val & RME32_WCR_PRO)\r\nval |= (aes->status[0] & IEC958_AES0_PRO_EMPHASIS_5015) ? RME32_WCR_EMP : 0;\r\nelse\r\nval |= (aes->status[0] & IEC958_AES0_CON_EMPHASIS_5015) ? RME32_WCR_EMP : 0;\r\nreturn val;\r\n}\r\nstatic void snd_rme32_convert_to_aes(struct snd_aes_iec958 * aes, u32 val)\r\n{\r\naes->status[0] = ((val & RME32_WCR_PRO) ? IEC958_AES0_PROFESSIONAL : 0);\r\nif (val & RME32_WCR_PRO)\r\naes->status[0] |= (val & RME32_WCR_EMP) ? IEC958_AES0_PRO_EMPHASIS_5015 : 0;\r\nelse\r\naes->status[0] |= (val & RME32_WCR_EMP) ? IEC958_AES0_CON_EMPHASIS_5015 : 0;\r\n}\r\nstatic int snd_rme32_control_spdif_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_rme32_control_spdif_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\r\nsnd_rme32_convert_to_aes(&ucontrol->value.iec958,\r\nrme32->wcreg_spdif);\r\nreturn 0;\r\n}\r\nstatic int snd_rme32_control_spdif_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nu32 val;\r\nval = snd_rme32_convert_from_aes(&ucontrol->value.iec958);\r\nspin_lock_irq(&rme32->lock);\r\nchange = val != rme32->wcreg_spdif;\r\nrme32->wcreg_spdif = val;\r\nspin_unlock_irq(&rme32->lock);\r\nreturn change;\r\n}\r\nstatic int snd_rme32_control_spdif_stream_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_rme32_control_spdif_stream_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *\r\nucontrol)\r\n{\r\nstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\r\nsnd_rme32_convert_to_aes(&ucontrol->value.iec958,\r\nrme32->wcreg_spdif_stream);\r\nreturn 0;\r\n}\r\nstatic int snd_rme32_control_spdif_stream_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *\r\nucontrol)\r\n{\r\nstruct rme32 *rme32 = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nu32 val;\r\nval = snd_rme32_convert_from_aes(&ucontrol->value.iec958);\r\nspin_lock_irq(&rme32->lock);\r\nchange = val != rme32->wcreg_spdif_stream;\r\nrme32->wcreg_spdif_stream = val;\r\nrme32->wcreg &= ~(RME32_WCR_PRO | RME32_WCR_EMP);\r\nrme32->wcreg |= val;\r\nwritel(rme32->wcreg, rme32->iobase + RME32_IO_CONTROL_REGISTER);\r\nspin_unlock_irq(&rme32->lock);\r\nreturn change;\r\n}\r\nstatic int snd_rme32_control_spdif_mask_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_rme32_control_spdif_mask_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *\r\nucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = kcontrol->private_value;\r\nreturn 0;\r\n}\r\nstatic int snd_rme32_create_switches(struct snd_card *card, struct rme32 * rme32)\r\n{\r\nint idx, err;\r\nstruct snd_kcontrol *kctl;\r\nfor (idx = 0; idx < (int)ARRAY_SIZE(snd_rme32_controls); idx++) {\r\nif ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_rme32_controls[idx], rme32))) < 0)\r\nreturn err;\r\nif (idx == 1)\r\nrme32->spdif_ctl = kctl;\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_rme32_card_free(struct snd_card *card)\r\n{\r\nsnd_rme32_free(card->private_data);\r\n}\r\nstatic int __devinit\r\nsnd_rme32_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct rme32 *rme32;\r\nstruct snd_card *card;\r\nint err;\r\nif (dev >= SNDRV_CARDS) {\r\nreturn -ENODEV;\r\n}\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE,\r\nsizeof(struct rme32), &card);\r\nif (err < 0)\r\nreturn err;\r\ncard->private_free = snd_rme32_card_free;\r\nrme32 = (struct rme32 *) card->private_data;\r\nrme32->card = card;\r\nrme32->pci = pci;\r\nsnd_card_set_dev(card, &pci->dev);\r\nif (fullduplex[dev])\r\nrme32->fullduplex_mode = 1;\r\nif ((err = snd_rme32_create(rme32)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstrcpy(card->driver, "Digi32");\r\nswitch (rme32->pci->device) {\r\ncase PCI_DEVICE_ID_RME_DIGI32:\r\nstrcpy(card->shortname, "RME Digi32");\r\nbreak;\r\ncase PCI_DEVICE_ID_RME_DIGI32_8:\r\nstrcpy(card->shortname, "RME Digi32/8");\r\nbreak;\r\ncase PCI_DEVICE_ID_RME_DIGI32_PRO:\r\nstrcpy(card->shortname, "RME Digi32 PRO");\r\nbreak;\r\n}\r\nsprintf(card->longname, "%s (Rev. %d) at 0x%lx, irq %d",\r\ncard->shortname, rme32->rev, rme32->port, rme32->irq);\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void __devexit snd_rme32_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\npci_set_drvdata(pci, NULL);\r\n}\r\nstatic int __init alsa_card_rme32_init(void)\r\n{\r\nreturn pci_register_driver(&driver);\r\n}\r\nstatic void __exit alsa_card_rme32_exit(void)\r\n{\r\npci_unregister_driver(&driver);\r\n}
