static struct clockdomain *_clkdm_lookup(const char *name)\r\n{\r\nstruct clockdomain *clkdm, *temp_clkdm;\r\nif (!name)\r\nreturn NULL;\r\nclkdm = NULL;\r\nlist_for_each_entry(temp_clkdm, &clkdm_list, node) {\r\nif (!strcmp(name, temp_clkdm->name)) {\r\nclkdm = temp_clkdm;\r\nbreak;\r\n}\r\n}\r\nreturn clkdm;\r\n}\r\nstatic int _clkdm_register(struct clockdomain *clkdm)\r\n{\r\nstruct powerdomain *pwrdm;\r\nif (!clkdm || !clkdm->name)\r\nreturn -EINVAL;\r\npwrdm = pwrdm_lookup(clkdm->pwrdm.name);\r\nif (!pwrdm) {\r\npr_err("clockdomain: %s: powerdomain %s does not exist\n",\r\nclkdm->name, clkdm->pwrdm.name);\r\nreturn -EINVAL;\r\n}\r\nclkdm->pwrdm.ptr = pwrdm;\r\nif (_clkdm_lookup(clkdm->name))\r\nreturn -EEXIST;\r\nlist_add(&clkdm->node, &clkdm_list);\r\npwrdm_add_clkdm(pwrdm, clkdm);\r\nspin_lock_init(&clkdm->lock);\r\npr_debug("clockdomain: registered %s\n", clkdm->name);\r\nreturn 0;\r\n}\r\nstatic struct clkdm_dep *_clkdm_deps_lookup(struct clockdomain *clkdm,\r\nstruct clkdm_dep *deps)\r\n{\r\nstruct clkdm_dep *cd;\r\nif (!clkdm || !deps)\r\nreturn ERR_PTR(-EINVAL);\r\nfor (cd = deps; cd->clkdm_name; cd++) {\r\nif (!cd->clkdm && cd->clkdm_name)\r\ncd->clkdm = _clkdm_lookup(cd->clkdm_name);\r\nif (cd->clkdm == clkdm)\r\nbreak;\r\n}\r\nif (!cd->clkdm_name)\r\nreturn ERR_PTR(-ENOENT);\r\nreturn cd;\r\n}\r\nstatic void _autodep_lookup(struct clkdm_autodep *autodep)\r\n{\r\nstruct clockdomain *clkdm;\r\nif (!autodep)\r\nreturn;\r\nclkdm = clkdm_lookup(autodep->clkdm.name);\r\nif (!clkdm) {\r\npr_err("clockdomain: autodeps: clockdomain %s does not exist\n",\r\nautodep->clkdm.name);\r\nclkdm = ERR_PTR(-ENOENT);\r\n}\r\nautodep->clkdm.ptr = clkdm;\r\n}\r\nvoid _clkdm_add_autodeps(struct clockdomain *clkdm)\r\n{\r\nstruct clkdm_autodep *autodep;\r\nif (!autodeps || clkdm->flags & CLKDM_NO_AUTODEPS)\r\nreturn;\r\nfor (autodep = autodeps; autodep->clkdm.ptr; autodep++) {\r\nif (IS_ERR(autodep->clkdm.ptr))\r\ncontinue;\r\npr_debug("clockdomain: adding %s sleepdep/wkdep for "\r\n"clkdm %s\n", autodep->clkdm.ptr->name,\r\nclkdm->name);\r\nclkdm_add_sleepdep(clkdm, autodep->clkdm.ptr);\r\nclkdm_add_wkdep(clkdm, autodep->clkdm.ptr);\r\n}\r\n}\r\nvoid _clkdm_del_autodeps(struct clockdomain *clkdm)\r\n{\r\nstruct clkdm_autodep *autodep;\r\nif (!autodeps || clkdm->flags & CLKDM_NO_AUTODEPS)\r\nreturn;\r\nfor (autodep = autodeps; autodep->clkdm.ptr; autodep++) {\r\nif (IS_ERR(autodep->clkdm.ptr))\r\ncontinue;\r\npr_debug("clockdomain: removing %s sleepdep/wkdep for "\r\n"clkdm %s\n", autodep->clkdm.ptr->name,\r\nclkdm->name);\r\nclkdm_del_sleepdep(clkdm, autodep->clkdm.ptr);\r\nclkdm_del_wkdep(clkdm, autodep->clkdm.ptr);\r\n}\r\n}\r\nstatic void _resolve_clkdm_deps(struct clockdomain *clkdm,\r\nstruct clkdm_dep *clkdm_deps)\r\n{\r\nstruct clkdm_dep *cd;\r\nfor (cd = clkdm_deps; cd && cd->clkdm_name; cd++) {\r\nif (cd->clkdm)\r\ncontinue;\r\ncd->clkdm = _clkdm_lookup(cd->clkdm_name);\r\nWARN(!cd->clkdm, "clockdomain: %s: could not find clkdm %s while resolving dependencies - should never happen",\r\nclkdm->name, cd->clkdm_name);\r\n}\r\n}\r\nint clkdm_register_platform_funcs(struct clkdm_ops *co)\r\n{\r\nif (!co)\r\nreturn -EINVAL;\r\nif (arch_clkdm)\r\nreturn -EEXIST;\r\narch_clkdm = co;\r\nreturn 0;\r\n}\r\nint clkdm_register_clkdms(struct clockdomain **cs)\r\n{\r\nstruct clockdomain **c = NULL;\r\nif (!arch_clkdm)\r\nreturn -EACCES;\r\nif (!cs)\r\nreturn -EINVAL;\r\nfor (c = cs; *c; c++)\r\n_clkdm_register(*c);\r\nreturn 0;\r\n}\r\nint clkdm_register_autodeps(struct clkdm_autodep *ia)\r\n{\r\nstruct clkdm_autodep *a = NULL;\r\nif (list_empty(&clkdm_list))\r\nreturn -EACCES;\r\nif (!ia)\r\nreturn -EINVAL;\r\nif (autodeps)\r\nreturn -EEXIST;\r\nautodeps = ia;\r\nfor (a = autodeps; a->clkdm.ptr; a++)\r\n_autodep_lookup(a);\r\nreturn 0;\r\n}\r\nint clkdm_complete_init(void)\r\n{\r\nstruct clockdomain *clkdm;\r\nif (list_empty(&clkdm_list))\r\nreturn -EACCES;\r\nlist_for_each_entry(clkdm, &clkdm_list, node) {\r\nif (clkdm->flags & CLKDM_CAN_FORCE_WAKEUP)\r\nclkdm_wakeup(clkdm);\r\nelse if (clkdm->flags & CLKDM_CAN_DISABLE_AUTO)\r\nclkdm_deny_idle(clkdm);\r\n_resolve_clkdm_deps(clkdm, clkdm->wkdep_srcs);\r\nclkdm_clear_all_wkdeps(clkdm);\r\n_resolve_clkdm_deps(clkdm, clkdm->sleepdep_srcs);\r\nclkdm_clear_all_sleepdeps(clkdm);\r\n}\r\nreturn 0;\r\n}\r\nstruct clockdomain *clkdm_lookup(const char *name)\r\n{\r\nstruct clockdomain *clkdm, *temp_clkdm;\r\nif (!name)\r\nreturn NULL;\r\nclkdm = NULL;\r\nlist_for_each_entry(temp_clkdm, &clkdm_list, node) {\r\nif (!strcmp(name, temp_clkdm->name)) {\r\nclkdm = temp_clkdm;\r\nbreak;\r\n}\r\n}\r\nreturn clkdm;\r\n}\r\nint clkdm_for_each(int (*fn)(struct clockdomain *clkdm, void *user),\r\nvoid *user)\r\n{\r\nstruct clockdomain *clkdm;\r\nint ret = 0;\r\nif (!fn)\r\nreturn -EINVAL;\r\nlist_for_each_entry(clkdm, &clkdm_list, node) {\r\nret = (*fn)(clkdm, user);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstruct powerdomain *clkdm_get_pwrdm(struct clockdomain *clkdm)\r\n{\r\nif (!clkdm)\r\nreturn NULL;\r\nreturn clkdm->pwrdm.ptr;\r\n}\r\nint clkdm_add_wkdep(struct clockdomain *clkdm1, struct clockdomain *clkdm2)\r\n{\r\nstruct clkdm_dep *cd;\r\nint ret = 0;\r\nif (!clkdm1 || !clkdm2)\r\nreturn -EINVAL;\r\ncd = _clkdm_deps_lookup(clkdm2, clkdm1->wkdep_srcs);\r\nif (IS_ERR(cd))\r\nret = PTR_ERR(cd);\r\nif (!arch_clkdm || !arch_clkdm->clkdm_add_wkdep)\r\nret = -EINVAL;\r\nif (ret) {\r\npr_debug("clockdomain: hardware cannot set/clear wake up of "\r\n"%s when %s wakes up\n", clkdm1->name, clkdm2->name);\r\nreturn ret;\r\n}\r\nif (atomic_inc_return(&cd->wkdep_usecount) == 1) {\r\npr_debug("clockdomain: hardware will wake up %s when %s wakes "\r\n"up\n", clkdm1->name, clkdm2->name);\r\nret = arch_clkdm->clkdm_add_wkdep(clkdm1, clkdm2);\r\n}\r\nreturn ret;\r\n}\r\nint clkdm_del_wkdep(struct clockdomain *clkdm1, struct clockdomain *clkdm2)\r\n{\r\nstruct clkdm_dep *cd;\r\nint ret = 0;\r\nif (!clkdm1 || !clkdm2)\r\nreturn -EINVAL;\r\ncd = _clkdm_deps_lookup(clkdm2, clkdm1->wkdep_srcs);\r\nif (IS_ERR(cd))\r\nret = PTR_ERR(cd);\r\nif (!arch_clkdm || !arch_clkdm->clkdm_del_wkdep)\r\nret = -EINVAL;\r\nif (ret) {\r\npr_debug("clockdomain: hardware cannot set/clear wake up of "\r\n"%s when %s wakes up\n", clkdm1->name, clkdm2->name);\r\nreturn ret;\r\n}\r\nif (atomic_dec_return(&cd->wkdep_usecount) == 0) {\r\npr_debug("clockdomain: hardware will no longer wake up %s "\r\n"after %s wakes up\n", clkdm1->name, clkdm2->name);\r\nret = arch_clkdm->clkdm_del_wkdep(clkdm1, clkdm2);\r\n}\r\nreturn ret;\r\n}\r\nint clkdm_read_wkdep(struct clockdomain *clkdm1, struct clockdomain *clkdm2)\r\n{\r\nstruct clkdm_dep *cd;\r\nint ret = 0;\r\nif (!clkdm1 || !clkdm2)\r\nreturn -EINVAL;\r\ncd = _clkdm_deps_lookup(clkdm2, clkdm1->wkdep_srcs);\r\nif (IS_ERR(cd))\r\nret = PTR_ERR(cd);\r\nif (!arch_clkdm || !arch_clkdm->clkdm_read_wkdep)\r\nret = -EINVAL;\r\nif (ret) {\r\npr_debug("clockdomain: hardware cannot set/clear wake up of "\r\n"%s when %s wakes up\n", clkdm1->name, clkdm2->name);\r\nreturn ret;\r\n}\r\nreturn arch_clkdm->clkdm_read_wkdep(clkdm1, clkdm2);\r\n}\r\nint clkdm_clear_all_wkdeps(struct clockdomain *clkdm)\r\n{\r\nif (!clkdm)\r\nreturn -EINVAL;\r\nif (!arch_clkdm || !arch_clkdm->clkdm_clear_all_wkdeps)\r\nreturn -EINVAL;\r\nreturn arch_clkdm->clkdm_clear_all_wkdeps(clkdm);\r\n}\r\nint clkdm_add_sleepdep(struct clockdomain *clkdm1, struct clockdomain *clkdm2)\r\n{\r\nstruct clkdm_dep *cd;\r\nint ret = 0;\r\nif (!clkdm1 || !clkdm2)\r\nreturn -EINVAL;\r\ncd = _clkdm_deps_lookup(clkdm2, clkdm1->sleepdep_srcs);\r\nif (IS_ERR(cd))\r\nret = PTR_ERR(cd);\r\nif (!arch_clkdm || !arch_clkdm->clkdm_add_sleepdep)\r\nret = -EINVAL;\r\nif (ret) {\r\npr_debug("clockdomain: hardware cannot set/clear sleep "\r\n"dependency affecting %s from %s\n", clkdm1->name,\r\nclkdm2->name);\r\nreturn ret;\r\n}\r\nif (atomic_inc_return(&cd->sleepdep_usecount) == 1) {\r\npr_debug("clockdomain: will prevent %s from sleeping if %s "\r\n"is active\n", clkdm1->name, clkdm2->name);\r\nret = arch_clkdm->clkdm_add_sleepdep(clkdm1, clkdm2);\r\n}\r\nreturn ret;\r\n}\r\nint clkdm_del_sleepdep(struct clockdomain *clkdm1, struct clockdomain *clkdm2)\r\n{\r\nstruct clkdm_dep *cd;\r\nint ret = 0;\r\nif (!clkdm1 || !clkdm2)\r\nreturn -EINVAL;\r\ncd = _clkdm_deps_lookup(clkdm2, clkdm1->sleepdep_srcs);\r\nif (IS_ERR(cd))\r\nret = PTR_ERR(cd);\r\nif (!arch_clkdm || !arch_clkdm->clkdm_del_sleepdep)\r\nret = -EINVAL;\r\nif (ret) {\r\npr_debug("clockdomain: hardware cannot set/clear sleep "\r\n"dependency affecting %s from %s\n", clkdm1->name,\r\nclkdm2->name);\r\nreturn ret;\r\n}\r\nif (atomic_dec_return(&cd->sleepdep_usecount) == 0) {\r\npr_debug("clockdomain: will no longer prevent %s from "\r\n"sleeping if %s is active\n", clkdm1->name,\r\nclkdm2->name);\r\nret = arch_clkdm->clkdm_del_sleepdep(clkdm1, clkdm2);\r\n}\r\nreturn ret;\r\n}\r\nint clkdm_read_sleepdep(struct clockdomain *clkdm1, struct clockdomain *clkdm2)\r\n{\r\nstruct clkdm_dep *cd;\r\nint ret = 0;\r\nif (!clkdm1 || !clkdm2)\r\nreturn -EINVAL;\r\ncd = _clkdm_deps_lookup(clkdm2, clkdm1->sleepdep_srcs);\r\nif (IS_ERR(cd))\r\nret = PTR_ERR(cd);\r\nif (!arch_clkdm || !arch_clkdm->clkdm_read_sleepdep)\r\nret = -EINVAL;\r\nif (ret) {\r\npr_debug("clockdomain: hardware cannot set/clear sleep "\r\n"dependency affecting %s from %s\n", clkdm1->name,\r\nclkdm2->name);\r\nreturn ret;\r\n}\r\nreturn arch_clkdm->clkdm_read_sleepdep(clkdm1, clkdm2);\r\n}\r\nint clkdm_clear_all_sleepdeps(struct clockdomain *clkdm)\r\n{\r\nif (!clkdm)\r\nreturn -EINVAL;\r\nif (!arch_clkdm || !arch_clkdm->clkdm_clear_all_sleepdeps)\r\nreturn -EINVAL;\r\nreturn arch_clkdm->clkdm_clear_all_sleepdeps(clkdm);\r\n}\r\nint clkdm_sleep(struct clockdomain *clkdm)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nif (!clkdm)\r\nreturn -EINVAL;\r\nif (!(clkdm->flags & CLKDM_CAN_FORCE_SLEEP)) {\r\npr_debug("clockdomain: %s does not support forcing "\r\n"sleep via software\n", clkdm->name);\r\nreturn -EINVAL;\r\n}\r\nif (!arch_clkdm || !arch_clkdm->clkdm_sleep)\r\nreturn -EINVAL;\r\npr_debug("clockdomain: forcing sleep on %s\n", clkdm->name);\r\nspin_lock_irqsave(&clkdm->lock, flags);\r\nclkdm->_flags &= ~_CLKDM_FLAG_HWSUP_ENABLED;\r\nret = arch_clkdm->clkdm_sleep(clkdm);\r\nspin_unlock_irqrestore(&clkdm->lock, flags);\r\nreturn ret;\r\n}\r\nint clkdm_wakeup(struct clockdomain *clkdm)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nif (!clkdm)\r\nreturn -EINVAL;\r\nif (!(clkdm->flags & CLKDM_CAN_FORCE_WAKEUP)) {\r\npr_debug("clockdomain: %s does not support forcing "\r\n"wakeup via software\n", clkdm->name);\r\nreturn -EINVAL;\r\n}\r\nif (!arch_clkdm || !arch_clkdm->clkdm_wakeup)\r\nreturn -EINVAL;\r\npr_debug("clockdomain: forcing wakeup on %s\n", clkdm->name);\r\nspin_lock_irqsave(&clkdm->lock, flags);\r\nclkdm->_flags &= ~_CLKDM_FLAG_HWSUP_ENABLED;\r\nret = arch_clkdm->clkdm_wakeup(clkdm);\r\nret |= pwrdm_state_switch(clkdm->pwrdm.ptr);\r\nspin_unlock_irqrestore(&clkdm->lock, flags);\r\nreturn ret;\r\n}\r\nvoid clkdm_allow_idle(struct clockdomain *clkdm)\r\n{\r\nunsigned long flags;\r\nif (!clkdm)\r\nreturn;\r\nif (!(clkdm->flags & CLKDM_CAN_ENABLE_AUTO)) {\r\npr_debug("clock: automatic idle transitions cannot be enabled "\r\n"on clockdomain %s\n", clkdm->name);\r\nreturn;\r\n}\r\nif (!arch_clkdm || !arch_clkdm->clkdm_allow_idle)\r\nreturn;\r\npr_debug("clockdomain: enabling automatic idle transitions for %s\n",\r\nclkdm->name);\r\nspin_lock_irqsave(&clkdm->lock, flags);\r\nclkdm->_flags |= _CLKDM_FLAG_HWSUP_ENABLED;\r\narch_clkdm->clkdm_allow_idle(clkdm);\r\npwrdm_clkdm_state_switch(clkdm);\r\nspin_unlock_irqrestore(&clkdm->lock, flags);\r\n}\r\nvoid clkdm_deny_idle(struct clockdomain *clkdm)\r\n{\r\nunsigned long flags;\r\nif (!clkdm)\r\nreturn;\r\nif (!(clkdm->flags & CLKDM_CAN_DISABLE_AUTO)) {\r\npr_debug("clockdomain: automatic idle transitions cannot be "\r\n"disabled on %s\n", clkdm->name);\r\nreturn;\r\n}\r\nif (!arch_clkdm || !arch_clkdm->clkdm_deny_idle)\r\nreturn;\r\npr_debug("clockdomain: disabling automatic idle transitions for %s\n",\r\nclkdm->name);\r\nspin_lock_irqsave(&clkdm->lock, flags);\r\nclkdm->_flags &= ~_CLKDM_FLAG_HWSUP_ENABLED;\r\narch_clkdm->clkdm_deny_idle(clkdm);\r\npwrdm_state_switch(clkdm->pwrdm.ptr);\r\nspin_unlock_irqrestore(&clkdm->lock, flags);\r\n}\r\nbool clkdm_in_hwsup(struct clockdomain *clkdm)\r\n{\r\nbool ret;\r\nunsigned long flags;\r\nif (!clkdm)\r\nreturn false;\r\nspin_lock_irqsave(&clkdm->lock, flags);\r\nret = (clkdm->_flags & _CLKDM_FLAG_HWSUP_ENABLED) ? true : false;\r\nspin_unlock_irqrestore(&clkdm->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int _clkdm_clk_hwmod_enable(struct clockdomain *clkdm)\r\n{\r\nunsigned long flags;\r\nif (!clkdm || !arch_clkdm || !arch_clkdm->clkdm_clk_enable)\r\nreturn -EINVAL;\r\nif ((atomic_inc_return(&clkdm->usecount) > 1) && autodeps)\r\nreturn 0;\r\nspin_lock_irqsave(&clkdm->lock, flags);\r\narch_clkdm->clkdm_clk_enable(clkdm);\r\npwrdm_wait_transition(clkdm->pwrdm.ptr);\r\npwrdm_clkdm_state_switch(clkdm);\r\nspin_unlock_irqrestore(&clkdm->lock, flags);\r\npr_debug("clockdomain: clkdm %s: enabled\n", clkdm->name);\r\nreturn 0;\r\n}\r\nstatic int _clkdm_clk_hwmod_disable(struct clockdomain *clkdm)\r\n{\r\nunsigned long flags;\r\nif (!clkdm || !arch_clkdm || !arch_clkdm->clkdm_clk_disable)\r\nreturn -EINVAL;\r\nif (atomic_read(&clkdm->usecount) == 0) {\r\nWARN_ON(1);\r\nreturn -ERANGE;\r\n}\r\nif (atomic_dec_return(&clkdm->usecount) > 0)\r\nreturn 0;\r\nspin_lock_irqsave(&clkdm->lock, flags);\r\narch_clkdm->clkdm_clk_disable(clkdm);\r\npwrdm_clkdm_state_switch(clkdm);\r\nspin_unlock_irqrestore(&clkdm->lock, flags);\r\npr_debug("clockdomain: clkdm %s: disabled\n", clkdm->name);\r\nreturn 0;\r\n}\r\nint clkdm_clk_enable(struct clockdomain *clkdm, struct clk *clk)\r\n{\r\nif (!clk)\r\nreturn -EINVAL;\r\nreturn _clkdm_clk_hwmod_enable(clkdm);\r\n}\r\nint clkdm_clk_disable(struct clockdomain *clkdm, struct clk *clk)\r\n{\r\nif (!clk)\r\nreturn -EINVAL;\r\nreturn _clkdm_clk_hwmod_disable(clkdm);\r\n}\r\nint clkdm_hwmod_enable(struct clockdomain *clkdm, struct omap_hwmod *oh)\r\n{\r\nif (cpu_is_omap24xx() || cpu_is_omap34xx())\r\nreturn 0;\r\nif (!oh)\r\nreturn -EINVAL;\r\nreturn _clkdm_clk_hwmod_enable(clkdm);\r\n}\r\nint clkdm_hwmod_disable(struct clockdomain *clkdm, struct omap_hwmod *oh)\r\n{\r\nif (cpu_is_omap24xx() || cpu_is_omap34xx())\r\nreturn 0;\r\nif (!oh)\r\nreturn -EINVAL;\r\nreturn _clkdm_clk_hwmod_disable(clkdm);\r\n}
