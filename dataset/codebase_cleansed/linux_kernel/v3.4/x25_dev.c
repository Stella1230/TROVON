static int x25_receive_data(struct sk_buff *skb, struct x25_neigh *nb)\r\n{\r\nstruct sock *sk;\r\nunsigned short frametype;\r\nunsigned int lci;\r\nif (!pskb_may_pull(skb, X25_STD_MIN_LEN))\r\nreturn 0;\r\nframetype = skb->data[2];\r\nlci = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\r\nif (lci == 0) {\r\nx25_link_control(skb, nb, frametype);\r\nreturn 0;\r\n}\r\nif ((sk = x25_find_socket(lci, nb)) != NULL) {\r\nint queued = 1;\r\nskb_reset_transport_header(skb);\r\nbh_lock_sock(sk);\r\nif (!sock_owned_by_user(sk)) {\r\nqueued = x25_process_rx_frame(sk, skb);\r\n} else {\r\nqueued = !sk_add_backlog(sk, skb);\r\n}\r\nbh_unlock_sock(sk);\r\nsock_put(sk);\r\nreturn queued;\r\n}\r\nif (frametype == X25_CALL_REQUEST)\r\nreturn x25_rx_call_request(skb, nb, lci);\r\nif (x25_forward_data(lci, nb, skb)) {\r\nif (frametype == X25_CLEAR_CONFIRMATION) {\r\nx25_clear_forward_by_lci(lci);\r\n}\r\nkfree_skb(skb);\r\nreturn 1;\r\n}\r\nif (frametype != X25_CLEAR_CONFIRMATION)\r\nprintk(KERN_DEBUG "x25_receive_data(): unknown frame type %2x\n",frametype);\r\nreturn 0;\r\n}\r\nint x25_lapb_receive_frame(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *ptype, struct net_device *orig_dev)\r\n{\r\nstruct sk_buff *nskb;\r\nstruct x25_neigh *nb;\r\nif (!net_eq(dev_net(dev), &init_net))\r\ngoto drop;\r\nnskb = skb_copy(skb, GFP_ATOMIC);\r\nif (!nskb)\r\ngoto drop;\r\nkfree_skb(skb);\r\nskb = nskb;\r\nnb = x25_get_neigh(dev);\r\nif (!nb) {\r\nprintk(KERN_DEBUG "X.25: unknown neighbour - %s\n", dev->name);\r\ngoto drop;\r\n}\r\nif (!pskb_may_pull(skb, 1))\r\nreturn 0;\r\nswitch (skb->data[0]) {\r\ncase X25_IFACE_DATA:\r\nskb_pull(skb, 1);\r\nif (x25_receive_data(skb, nb)) {\r\nx25_neigh_put(nb);\r\ngoto out;\r\n}\r\nbreak;\r\ncase X25_IFACE_CONNECT:\r\nx25_link_established(nb);\r\nbreak;\r\ncase X25_IFACE_DISCONNECT:\r\nx25_link_terminated(nb);\r\nbreak;\r\n}\r\nx25_neigh_put(nb);\r\ndrop:\r\nkfree_skb(skb);\r\nout:\r\nreturn 0;\r\n}\r\nvoid x25_establish_link(struct x25_neigh *nb)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned char *ptr;\r\nswitch (nb->dev->type) {\r\ncase ARPHRD_X25:\r\nif ((skb = alloc_skb(1, GFP_ATOMIC)) == NULL) {\r\nprintk(KERN_ERR "x25_dev: out of memory\n");\r\nreturn;\r\n}\r\nptr = skb_put(skb, 1);\r\n*ptr = X25_IFACE_CONNECT;\r\nbreak;\r\n#if IS_ENABLED(CONFIG_LLC)\r\ncase ARPHRD_ETHER:\r\nreturn;\r\n#endif\r\ndefault:\r\nreturn;\r\n}\r\nskb->protocol = htons(ETH_P_X25);\r\nskb->dev = nb->dev;\r\ndev_queue_xmit(skb);\r\n}\r\nvoid x25_terminate_link(struct x25_neigh *nb)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned char *ptr;\r\n#if IS_ENABLED(CONFIG_LLC)\r\nif (nb->dev->type == ARPHRD_ETHER)\r\nreturn;\r\n#endif\r\nif (nb->dev->type != ARPHRD_X25)\r\nreturn;\r\nskb = alloc_skb(1, GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_ERR "x25_dev: out of memory\n");\r\nreturn;\r\n}\r\nptr = skb_put(skb, 1);\r\n*ptr = X25_IFACE_DISCONNECT;\r\nskb->protocol = htons(ETH_P_X25);\r\nskb->dev = nb->dev;\r\ndev_queue_xmit(skb);\r\n}\r\nvoid x25_send_frame(struct sk_buff *skb, struct x25_neigh *nb)\r\n{\r\nunsigned char *dptr;\r\nskb_reset_network_header(skb);\r\nswitch (nb->dev->type) {\r\ncase ARPHRD_X25:\r\ndptr = skb_push(skb, 1);\r\n*dptr = X25_IFACE_DATA;\r\nbreak;\r\n#if IS_ENABLED(CONFIG_LLC)\r\ncase ARPHRD_ETHER:\r\nkfree_skb(skb);\r\nreturn;\r\n#endif\r\ndefault:\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nskb->protocol = htons(ETH_P_X25);\r\nskb->dev = nb->dev;\r\ndev_queue_xmit(skb);\r\n}
