static void powermate_irq(struct urb *urb)\r\n{\r\nstruct powermate_device *pm = urb->context;\r\nint retval;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndbg("%s - urb shutting down with status: %d", __func__, urb->status);\r\nreturn;\r\ndefault:\r\ndbg("%s - nonzero urb status received: %d", __func__, urb->status);\r\ngoto exit;\r\n}\r\ninput_report_key(pm->input, BTN_0, pm->data[0] & 0x01);\r\ninput_report_rel(pm->input, REL_DIAL, pm->data[1]);\r\ninput_sync(pm->input);\r\nexit:\r\nretval = usb_submit_urb (urb, GFP_ATOMIC);\r\nif (retval)\r\nerr ("%s - usb_submit_urb failed with result %d",\r\n__func__, retval);\r\n}\r\nstatic void powermate_sync_state(struct powermate_device *pm)\r\n{\r\nif (pm->requires_update == 0)\r\nreturn;\r\nif (pm->config->status == -EINPROGRESS)\r\nreturn;\r\nif (pm->requires_update & UPDATE_PULSE_ASLEEP){\r\npm->configcr->wValue = cpu_to_le16( SET_PULSE_ASLEEP );\r\npm->configcr->wIndex = cpu_to_le16( pm->pulse_asleep ? 1 : 0 );\r\npm->requires_update &= ~UPDATE_PULSE_ASLEEP;\r\n}else if (pm->requires_update & UPDATE_PULSE_AWAKE){\r\npm->configcr->wValue = cpu_to_le16( SET_PULSE_AWAKE );\r\npm->configcr->wIndex = cpu_to_le16( pm->pulse_awake ? 1 : 0 );\r\npm->requires_update &= ~UPDATE_PULSE_AWAKE;\r\n}else if (pm->requires_update & UPDATE_PULSE_MODE){\r\nint op, arg;\r\nif (pm->pulse_speed < 255) {\r\nop = 0;\r\narg = 255 - pm->pulse_speed;\r\n} else if (pm->pulse_speed > 255) {\r\nop = 2;\r\narg = pm->pulse_speed - 255;\r\n} else {\r\nop = 1;\r\narg = 0;\r\n}\r\npm->configcr->wValue = cpu_to_le16( (pm->pulse_table << 8) | SET_PULSE_MODE );\r\npm->configcr->wIndex = cpu_to_le16( (arg << 8) | op );\r\npm->requires_update &= ~UPDATE_PULSE_MODE;\r\n} else if (pm->requires_update & UPDATE_STATIC_BRIGHTNESS) {\r\npm->configcr->wValue = cpu_to_le16( SET_STATIC_BRIGHTNESS );\r\npm->configcr->wIndex = cpu_to_le16( pm->static_brightness );\r\npm->requires_update &= ~UPDATE_STATIC_BRIGHTNESS;\r\n} else {\r\nprintk(KERN_ERR "powermate: unknown update required");\r\npm->requires_update = 0;\r\nreturn;\r\n}\r\npm->configcr->bRequestType = 0x41;\r\npm->configcr->bRequest = 0x01;\r\npm->configcr->wLength = 0;\r\nusb_fill_control_urb(pm->config, pm->udev, usb_sndctrlpipe(pm->udev, 0),\r\n(void *) pm->configcr, NULL, 0,\r\npowermate_config_complete, pm);\r\nif (usb_submit_urb(pm->config, GFP_ATOMIC))\r\nprintk(KERN_ERR "powermate: usb_submit_urb(config) failed");\r\n}\r\nstatic void powermate_config_complete(struct urb *urb)\r\n{\r\nstruct powermate_device *pm = urb->context;\r\nunsigned long flags;\r\nif (urb->status)\r\nprintk(KERN_ERR "powermate: config urb returned %d\n", urb->status);\r\nspin_lock_irqsave(&pm->lock, flags);\r\npowermate_sync_state(pm);\r\nspin_unlock_irqrestore(&pm->lock, flags);\r\n}\r\nstatic void powermate_pulse_led(struct powermate_device *pm, int static_brightness, int pulse_speed,\r\nint pulse_table, int pulse_asleep, int pulse_awake)\r\n{\r\nunsigned long flags;\r\nif (pulse_speed < 0)\r\npulse_speed = 0;\r\nif (pulse_table < 0)\r\npulse_table = 0;\r\nif (pulse_speed > 510)\r\npulse_speed = 510;\r\nif (pulse_table > 2)\r\npulse_table = 2;\r\npulse_asleep = !!pulse_asleep;\r\npulse_awake = !!pulse_awake;\r\nspin_lock_irqsave(&pm->lock, flags);\r\nif (static_brightness != pm->static_brightness) {\r\npm->static_brightness = static_brightness;\r\npm->requires_update |= UPDATE_STATIC_BRIGHTNESS;\r\n}\r\nif (pulse_asleep != pm->pulse_asleep) {\r\npm->pulse_asleep = pulse_asleep;\r\npm->requires_update |= (UPDATE_PULSE_ASLEEP | UPDATE_STATIC_BRIGHTNESS);\r\n}\r\nif (pulse_awake != pm->pulse_awake) {\r\npm->pulse_awake = pulse_awake;\r\npm->requires_update |= (UPDATE_PULSE_AWAKE | UPDATE_STATIC_BRIGHTNESS);\r\n}\r\nif (pulse_speed != pm->pulse_speed || pulse_table != pm->pulse_table) {\r\npm->pulse_speed = pulse_speed;\r\npm->pulse_table = pulse_table;\r\npm->requires_update |= UPDATE_PULSE_MODE;\r\n}\r\npowermate_sync_state(pm);\r\nspin_unlock_irqrestore(&pm->lock, flags);\r\n}\r\nstatic int powermate_input_event(struct input_dev *dev, unsigned int type, unsigned int code, int _value)\r\n{\r\nunsigned int command = (unsigned int)_value;\r\nstruct powermate_device *pm = input_get_drvdata(dev);\r\nif (type == EV_MSC && code == MSC_PULSELED){\r\nint static_brightness = command & 0xFF;\r\nint pulse_speed = (command >> 8) & 0x1FF;\r\nint pulse_table = (command >> 17) & 0x3;\r\nint pulse_asleep = (command >> 19) & 0x1;\r\nint pulse_awake = (command >> 20) & 0x1;\r\npowermate_pulse_led(pm, static_brightness, pulse_speed, pulse_table, pulse_asleep, pulse_awake);\r\n}\r\nreturn 0;\r\n}\r\nstatic int powermate_alloc_buffers(struct usb_device *udev, struct powermate_device *pm)\r\n{\r\npm->data = usb_alloc_coherent(udev, POWERMATE_PAYLOAD_SIZE_MAX,\r\nGFP_ATOMIC, &pm->data_dma);\r\nif (!pm->data)\r\nreturn -1;\r\npm->configcr = kmalloc(sizeof(*(pm->configcr)), GFP_KERNEL);\r\nif (!pm->configcr)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void powermate_free_buffers(struct usb_device *udev, struct powermate_device *pm)\r\n{\r\nusb_free_coherent(udev, POWERMATE_PAYLOAD_SIZE_MAX,\r\npm->data, pm->data_dma);\r\nkfree(pm->configcr);\r\n}\r\nstatic int powermate_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev (intf);\r\nstruct usb_host_interface *interface;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct powermate_device *pm;\r\nstruct input_dev *input_dev;\r\nint pipe, maxp;\r\nint error = -ENOMEM;\r\ninterface = intf->cur_altsetting;\r\nendpoint = &interface->endpoint[0].desc;\r\nif (!usb_endpoint_is_int_in(endpoint))\r\nreturn -EIO;\r\nusb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\n0x0a, USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n0, interface->desc.bInterfaceNumber, NULL, 0,\r\nUSB_CTRL_SET_TIMEOUT);\r\npm = kzalloc(sizeof(struct powermate_device), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!pm || !input_dev)\r\ngoto fail1;\r\nif (powermate_alloc_buffers(udev, pm))\r\ngoto fail2;\r\npm->irq = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!pm->irq)\r\ngoto fail2;\r\npm->config = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!pm->config)\r\ngoto fail3;\r\npm->udev = udev;\r\npm->input = input_dev;\r\nusb_make_path(udev, pm->phys, sizeof(pm->phys));\r\nstrlcat(pm->phys, "/input0", sizeof(pm->phys));\r\nspin_lock_init(&pm->lock);\r\nswitch (le16_to_cpu(udev->descriptor.idProduct)) {\r\ncase POWERMATE_PRODUCT_NEW:\r\ninput_dev->name = pm_name_powermate;\r\nbreak;\r\ncase POWERMATE_PRODUCT_OLD:\r\ninput_dev->name = pm_name_soundknob;\r\nbreak;\r\ndefault:\r\ninput_dev->name = pm_name_soundknob;\r\nprintk(KERN_WARNING "powermate: unknown product id %04x\n",\r\nle16_to_cpu(udev->descriptor.idProduct));\r\n}\r\ninput_dev->phys = pm->phys;\r\nusb_to_input_id(udev, &input_dev->id);\r\ninput_dev->dev.parent = &intf->dev;\r\ninput_set_drvdata(input_dev, pm);\r\ninput_dev->event = powermate_input_event;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL) |\r\nBIT_MASK(EV_MSC);\r\ninput_dev->keybit[BIT_WORD(BTN_0)] = BIT_MASK(BTN_0);\r\ninput_dev->relbit[BIT_WORD(REL_DIAL)] = BIT_MASK(REL_DIAL);\r\ninput_dev->mscbit[BIT_WORD(MSC_PULSELED)] = BIT_MASK(MSC_PULSELED);\r\npipe = usb_rcvintpipe(udev, endpoint->bEndpointAddress);\r\nmaxp = usb_maxpacket(udev, pipe, usb_pipeout(pipe));\r\nif (maxp < POWERMATE_PAYLOAD_SIZE_MIN || maxp > POWERMATE_PAYLOAD_SIZE_MAX) {\r\nprintk(KERN_WARNING "powermate: Expected payload of %d--%d bytes, found %d bytes!\n",\r\nPOWERMATE_PAYLOAD_SIZE_MIN, POWERMATE_PAYLOAD_SIZE_MAX, maxp);\r\nmaxp = POWERMATE_PAYLOAD_SIZE_MAX;\r\n}\r\nusb_fill_int_urb(pm->irq, udev, pipe, pm->data,\r\nmaxp, powermate_irq,\r\npm, endpoint->bInterval);\r\npm->irq->transfer_dma = pm->data_dma;\r\npm->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nif (usb_submit_urb(pm->irq, GFP_KERNEL)) {\r\nerror = -EIO;\r\ngoto fail4;\r\n}\r\nerror = input_register_device(pm->input);\r\nif (error)\r\ngoto fail5;\r\npm->requires_update = UPDATE_PULSE_ASLEEP | UPDATE_PULSE_AWAKE | UPDATE_PULSE_MODE | UPDATE_STATIC_BRIGHTNESS;\r\npowermate_pulse_led(pm, 0x80, 255, 0, 1, 0);\r\nusb_set_intfdata(intf, pm);\r\nreturn 0;\r\nfail5: usb_kill_urb(pm->irq);\r\nfail4: usb_free_urb(pm->config);\r\nfail3: usb_free_urb(pm->irq);\r\nfail2: powermate_free_buffers(udev, pm);\r\nfail1: input_free_device(input_dev);\r\nkfree(pm);\r\nreturn error;\r\n}\r\nstatic void powermate_disconnect(struct usb_interface *intf)\r\n{\r\nstruct powermate_device *pm = usb_get_intfdata (intf);\r\nusb_set_intfdata(intf, NULL);\r\nif (pm) {\r\npm->requires_update = 0;\r\nusb_kill_urb(pm->irq);\r\ninput_unregister_device(pm->input);\r\nusb_free_urb(pm->irq);\r\nusb_free_urb(pm->config);\r\npowermate_free_buffers(interface_to_usbdev(intf), pm);\r\nkfree(pm);\r\n}\r\n}
