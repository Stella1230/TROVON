INT InterfaceRDM(PS_INTERFACE_ADAPTER psIntfAdapter,\r\nUINT addr,\r\nPVOID buff,\r\nINT len)\r\n{\r\nint bytes;\r\nUSHORT usRetries = 0;\r\nif (psIntfAdapter == NULL) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_PRINTK, 0, 0, "Interface Adapter is NULL");\r\nreturn -EINVAL;\r\n}\r\nif (psIntfAdapter->psAdapter->device_removed == TRUE) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_PRINTK, 0, 0, "Device got removed");\r\nreturn -ENODEV;\r\n}\r\nif ((psIntfAdapter->psAdapter->StopAllXaction == TRUE) && (psIntfAdapter->psAdapter->chip_id >= T3LPB)) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_OTHERS, RDM, DBG_LVL_ALL, "Currently Xaction is not allowed on the bus");\r\nreturn -EACCES;\r\n}\r\nif (psIntfAdapter->bSuspended == TRUE || psIntfAdapter->bPreparingForBusSuspend == TRUE) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_OTHERS, RDM, DBG_LVL_ALL, "Bus is in suspended states hence RDM not allowed..");\r\nreturn -EACCES;\r\n}\r\npsIntfAdapter->psAdapter->DeviceAccess = TRUE;\r\ndo {\r\nbytes = usb_control_msg(psIntfAdapter->udev,\r\nusb_rcvctrlpipe(psIntfAdapter->udev, 0),\r\n0x02,\r\n0xC2,\r\n(addr & 0xFFFF),\r\n((addr >> 16) & 0xFFFF),\r\nbuff,\r\nlen,\r\n5000);\r\nusRetries++;\r\nif (-ENODEV == bytes) {\r\npsIntfAdapter->psAdapter->device_removed = TRUE;\r\nbreak;\r\n}\r\n} while ((bytes < 0) && (usRetries < MAX_RDM_WRM_RETIRES));\r\nif (bytes < 0)\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_OTHERS, RDM, DBG_LVL_ALL, "RDM failed status :%d, retires :%d", bytes, usRetries);\r\nelse\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_OTHERS, RDM, DBG_LVL_ALL, "RDM sent %d", bytes);\r\npsIntfAdapter->psAdapter->DeviceAccess = FALSE;\r\nreturn bytes;\r\n}\r\nINT InterfaceWRM(PS_INTERFACE_ADAPTER psIntfAdapter,\r\nUINT addr,\r\nPVOID buff,\r\nINT len)\r\n{\r\nint retval = 0;\r\nUSHORT usRetries = 0;\r\nif (psIntfAdapter == NULL) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_PRINTK, 0, 0, "Interface Adapter is NULL");\r\nreturn -EINVAL;\r\n}\r\nif (psIntfAdapter->psAdapter->device_removed == TRUE) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_PRINTK, 0, 0, "Device got removed");\r\nreturn -ENODEV;\r\n}\r\nif ((psIntfAdapter->psAdapter->StopAllXaction == TRUE) && (psIntfAdapter->psAdapter->chip_id >= T3LPB)) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_OTHERS, WRM, DBG_LVL_ALL, "Currently Xaction is not allowed on the bus...");\r\nreturn -EACCES;\r\n}\r\nif (psIntfAdapter->bSuspended == TRUE || psIntfAdapter->bPreparingForBusSuspend == TRUE) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_OTHERS, WRM, DBG_LVL_ALL, "Bus is in suspended states hence RDM not allowed..");\r\nreturn -EACCES;\r\n}\r\npsIntfAdapter->psAdapter->DeviceAccess = TRUE;\r\ndo {\r\nretval = usb_control_msg(psIntfAdapter->udev,\r\nusb_sndctrlpipe(psIntfAdapter->udev, 0),\r\n0x01,\r\n0x42,\r\n(addr & 0xFFFF),\r\n((addr >> 16) & 0xFFFF),\r\nbuff,\r\nlen,\r\n5000);\r\nusRetries++;\r\nif (-ENODEV == retval) {\r\npsIntfAdapter->psAdapter->device_removed = TRUE;\r\nbreak;\r\n}\r\n} while ((retval < 0) && (usRetries < MAX_RDM_WRM_RETIRES));\r\nif (retval < 0) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_OTHERS, WRM, DBG_LVL_ALL, "WRM failed status :%d, retires :%d", retval, usRetries);\r\npsIntfAdapter->psAdapter->DeviceAccess = FALSE;\r\nreturn retval;\r\n} else {\r\npsIntfAdapter->psAdapter->DeviceAccess = FALSE;\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_OTHERS, WRM, DBG_LVL_ALL, "WRM sent %d", retval);\r\nreturn STATUS_SUCCESS;\r\n}\r\n}\r\nINT BcmRDM(PVOID arg,\r\nUINT addr,\r\nPVOID buff,\r\nINT len)\r\n{\r\nreturn InterfaceRDM((PS_INTERFACE_ADAPTER)arg, addr, buff, len);\r\n}\r\nINT BcmWRM(PVOID arg,\r\nUINT addr,\r\nPVOID buff,\r\nINT len)\r\n{\r\nreturn InterfaceWRM((PS_INTERFACE_ADAPTER)arg, addr, buff, len);\r\n}\r\nINT Bcm_clear_halt_of_endpoints(PMINI_ADAPTER Adapter)\r\n{\r\nPS_INTERFACE_ADAPTER psIntfAdapter = (PS_INTERFACE_ADAPTER)(Adapter->pvInterfaceAdapter);\r\nINT status = STATUS_SUCCESS;\r\nBcm_kill_all_URBs(psIntfAdapter);\r\nstatus = usb_clear_halt(psIntfAdapter->udev, psIntfAdapter->sIntrIn.int_in_pipe);\r\nif (status != STATUS_SUCCESS)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, INTF_INIT, DBG_LVL_ALL, "Unable to Clear Halt of Interrupt IN end point. :%d ", status);\r\nstatus = usb_clear_halt(psIntfAdapter->udev, psIntfAdapter->sBulkIn.bulk_in_pipe);\r\nif (status != STATUS_SUCCESS)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, INTF_INIT, DBG_LVL_ALL, "Unable to Clear Halt of Bulk IN end point. :%d ", status);\r\nstatus = usb_clear_halt(psIntfAdapter->udev, psIntfAdapter->sBulkOut.bulk_out_pipe);\r\nif (status != STATUS_SUCCESS)\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, INTF_INIT, DBG_LVL_ALL, "Unable to Clear Halt of Bulk OUT end point. :%d ", status);\r\nreturn status;\r\n}\r\nVOID Bcm_kill_all_URBs(PS_INTERFACE_ADAPTER psIntfAdapter)\r\n{\r\nstruct urb *tempUrb = NULL;\r\nUINT i;\r\nif (psIntfAdapter->psInterruptUrb != NULL) {\r\nif (psIntfAdapter->psInterruptUrb->status == -EINPROGRESS)\r\nusb_kill_urb(psIntfAdapter->psInterruptUrb);\r\n}\r\nfor (i = 0; i < MAXIMUM_USB_TCB; i++) {\r\ntempUrb = psIntfAdapter->asUsbTcb[i].urb;\r\nif (tempUrb) {\r\nif (tempUrb->status == -EINPROGRESS)\r\nusb_kill_urb(tempUrb);\r\n}\r\n}\r\nfor (i = 0; i < MAXIMUM_USB_RCB; i++) {\r\ntempUrb = psIntfAdapter->asUsbRcb[i].urb;\r\nif (tempUrb) {\r\nif (tempUrb->status == -EINPROGRESS)\r\nusb_kill_urb(tempUrb);\r\n}\r\n}\r\natomic_set(&psIntfAdapter->uNumTcbUsed, 0);\r\natomic_set(&psIntfAdapter->uCurrTcb, 0);\r\natomic_set(&psIntfAdapter->uNumRcbUsed, 0);\r\natomic_set(&psIntfAdapter->uCurrRcb, 0);\r\n}\r\nVOID putUsbSuspend(struct work_struct *work)\r\n{\r\nPS_INTERFACE_ADAPTER psIntfAdapter = NULL;\r\nstruct usb_interface *intf = NULL;\r\npsIntfAdapter = container_of(work, S_INTERFACE_ADAPTER, usbSuspendWork);\r\nintf = psIntfAdapter->interface;\r\nif (psIntfAdapter->bSuspended == FALSE)\r\nusb_autopm_put_interface(intf);\r\n}
