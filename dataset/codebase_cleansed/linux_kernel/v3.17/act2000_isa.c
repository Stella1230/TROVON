static int\r\nact2000_isa_reset(unsigned short portbase)\r\n{\r\nunsigned char reg;\r\nint i;\r\nint found;\r\nint serial = 0;\r\nfound = 0;\r\nif ((reg = inb(portbase + ISA_COR)) != 0xff) {\r\noutb(reg | ISA_COR_RESET, portbase + ISA_COR);\r\nmdelay(10);\r\noutb(reg, portbase + ISA_COR);\r\nmdelay(10);\r\nfor (i = 0; i < 16; i++) {\r\nif (inb(portbase + ISA_ISR) & ISA_ISR_SERIAL)\r\nserial |= 0x10000;\r\nserial >>= 1;\r\n}\r\nif (serial == ISA_SER_ID)\r\nfound++;\r\n}\r\nreturn found;\r\n}\r\nint\r\nact2000_isa_detect(unsigned short portbase)\r\n{\r\nint ret = 0;\r\nif (request_region(portbase, ACT2000_PORTLEN, "act2000isa")) {\r\nret = act2000_isa_reset(portbase);\r\nrelease_region(portbase, ISA_REGION);\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t\r\nact2000_isa_interrupt(int dummy, void *dev_id)\r\n{\r\nact2000_card *card = dev_id;\r\nu_char istatus;\r\nistatus = (inb(ISA_PORT_ISR) & 0x07);\r\nif (istatus & ISA_ISR_OUT) {\r\nistatus &= ISA_ISR_OUT_MASK;\r\noutb(0, ISA_PORT_SIS);\r\nact2000_isa_receive(card);\r\noutb(ISA_SIS_INT, ISA_PORT_SIS);\r\n}\r\nif (istatus & ISA_ISR_ERR) {\r\nistatus &= ISA_ISR_ERR_MASK;\r\nprintk(KERN_WARNING "act2000: errIRQ\n");\r\n}\r\nif (istatus)\r\nprintk(KERN_DEBUG "act2000: ?IRQ %d %02x\n", card->irq, istatus);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nact2000_isa_select_irq(act2000_card *card)\r\n{\r\nunsigned char reg;\r\nreg = (inb(ISA_PORT_COR) & ~ISA_COR_IRQOFF) | ISA_COR_PERR;\r\nswitch (card->irq) {\r\ncase 3:\r\nreg = ISA_COR_IRQ03;\r\nbreak;\r\ncase 5:\r\nreg = ISA_COR_IRQ05;\r\nbreak;\r\ncase 7:\r\nreg = ISA_COR_IRQ07;\r\nbreak;\r\ncase 10:\r\nreg = ISA_COR_IRQ10;\r\nbreak;\r\ncase 11:\r\nreg = ISA_COR_IRQ11;\r\nbreak;\r\ncase 12:\r\nreg = ISA_COR_IRQ12;\r\nbreak;\r\ncase 15:\r\nreg = ISA_COR_IRQ15;\r\nbreak;\r\n}\r\noutb(reg, ISA_PORT_COR);\r\n}\r\nstatic void\r\nact2000_isa_enable_irq(act2000_card *card)\r\n{\r\nact2000_isa_select_irq(card);\r\noutb(ISA_SIS_INT, ISA_PORT_SIS);\r\n}\r\nint\r\nact2000_isa_config_irq(act2000_card *card, short irq)\r\n{\r\nint old_irq;\r\nif (card->flags & ACT2000_FLAGS_IVALID) {\r\nfree_irq(card->irq, card);\r\n}\r\ncard->flags &= ~ACT2000_FLAGS_IVALID;\r\noutb(ISA_COR_IRQOFF, ISA_PORT_COR);\r\nif (!irq)\r\nreturn 0;\r\nold_irq = card->irq;\r\ncard->irq = irq;\r\nif (request_irq(irq, &act2000_isa_interrupt, 0, card->regname, card)) {\r\ncard->irq = old_irq;\r\ncard->flags |= ACT2000_FLAGS_IVALID;\r\nprintk(KERN_WARNING\r\n"act2000: Could not request irq %d\n", irq);\r\nreturn -EBUSY;\r\n} else {\r\nact2000_isa_select_irq(card);\r\noutb(0, ISA_PORT_SIS);\r\noutb(0, ISA_PORT_SOS);\r\n}\r\nreturn 0;\r\n}\r\nint\r\nact2000_isa_config_port(act2000_card *card, unsigned short portbase)\r\n{\r\nif (card->flags & ACT2000_FLAGS_PVALID) {\r\nrelease_region(card->port, ISA_REGION);\r\ncard->flags &= ~ACT2000_FLAGS_PVALID;\r\n}\r\nif (request_region(portbase, ACT2000_PORTLEN, card->regname) == NULL)\r\nreturn -EBUSY;\r\nelse {\r\ncard->port = portbase;\r\ncard->flags |= ACT2000_FLAGS_PVALID;\r\nreturn 0;\r\n}\r\n}\r\nvoid\r\nact2000_isa_release(act2000_card *card)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (card->flags & ACT2000_FLAGS_IVALID)\r\nfree_irq(card->irq, card);\r\ncard->flags &= ~ACT2000_FLAGS_IVALID;\r\nif (card->flags & ACT2000_FLAGS_PVALID)\r\nrelease_region(card->port, ISA_REGION);\r\ncard->flags &= ~ACT2000_FLAGS_PVALID;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}\r\nstatic int\r\nact2000_isa_writeb(act2000_card *card, u_char data)\r\n{\r\nu_char timeout = 40;\r\nwhile (timeout) {\r\nif (inb(ISA_PORT_SOS) & ISA_SOS_READY) {\r\noutb(data, ISA_PORT_SDO);\r\nreturn 0;\r\n} else {\r\ntimeout--;\r\nudelay(10);\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\nact2000_isa_readb(act2000_card *card, u_char *data)\r\n{\r\nu_char timeout = 40;\r\nwhile (timeout) {\r\nif (inb(ISA_PORT_SIS) & ISA_SIS_READY) {\r\n*data = inb(ISA_PORT_SDI);\r\nreturn 0;\r\n} else {\r\ntimeout--;\r\nudelay(10);\r\n}\r\n}\r\nreturn 1;\r\n}\r\nvoid\r\nact2000_isa_receive(act2000_card *card)\r\n{\r\nu_char c;\r\nif (test_and_set_bit(ACT2000_LOCK_RX, (void *) &card->ilock) != 0)\r\nreturn;\r\nwhile (!act2000_isa_readb(card, &c)) {\r\nif (card->idat.isa.rcvidx < 8) {\r\ncard->idat.isa.rcvhdr[card->idat.isa.rcvidx++] = c;\r\nif (card->idat.isa.rcvidx == 8) {\r\nint valid = actcapi_chkhdr(card, (actcapi_msghdr *)&card->idat.isa.rcvhdr);\r\nif (valid) {\r\ncard->idat.isa.rcvlen = ((actcapi_msghdr *)&card->idat.isa.rcvhdr)->len;\r\ncard->idat.isa.rcvskb = dev_alloc_skb(card->idat.isa.rcvlen);\r\nif (card->idat.isa.rcvskb == NULL) {\r\ncard->idat.isa.rcvignore = 1;\r\nprintk(KERN_WARNING\r\n"act2000_isa_receive: no memory\n");\r\ntest_and_clear_bit(ACT2000_LOCK_RX, (void *) &card->ilock);\r\nreturn;\r\n}\r\nmemcpy(skb_put(card->idat.isa.rcvskb, 8), card->idat.isa.rcvhdr, 8);\r\ncard->idat.isa.rcvptr = skb_put(card->idat.isa.rcvskb, card->idat.isa.rcvlen - 8);\r\n} else {\r\ncard->idat.isa.rcvidx = 0;\r\nprintk(KERN_WARNING\r\n"act2000_isa_receive: Invalid CAPI msg\n");\r\n{\r\nint i; __u8 *p; __u8 *t; __u8 tmp[30];\r\nfor (i = 0, p = (__u8 *)&card->idat.isa.rcvhdr, t = tmp; i < 8; i++)\r\nt += sprintf(t, "%02x ", *(p++));\r\nprintk(KERN_WARNING "act2000_isa_receive: %s\n", tmp);\r\n}\r\n}\r\n}\r\n} else {\r\nif (!card->idat.isa.rcvignore)\r\n*card->idat.isa.rcvptr++ = c;\r\nif (++card->idat.isa.rcvidx >= card->idat.isa.rcvlen) {\r\nif (!card->idat.isa.rcvignore) {\r\nskb_queue_tail(&card->rcvq, card->idat.isa.rcvskb);\r\nact2000_schedule_rx(card);\r\n}\r\ncard->idat.isa.rcvidx = 0;\r\ncard->idat.isa.rcvlen = 8;\r\ncard->idat.isa.rcvignore = 0;\r\ncard->idat.isa.rcvskb = NULL;\r\ncard->idat.isa.rcvptr = card->idat.isa.rcvhdr;\r\n}\r\n}\r\n}\r\nif (!(card->flags & ACT2000_FLAGS_IVALID)) {\r\nif ((card->idat.isa.rcvidx) &&\r\n(card->idat.isa.rcvignore ||\r\n(card->idat.isa.rcvidx < card->idat.isa.rcvlen)))\r\nact2000_schedule_poll(card);\r\n}\r\ntest_and_clear_bit(ACT2000_LOCK_RX, (void *) &card->ilock);\r\n}\r\nvoid\r\nact2000_isa_send(act2000_card *card)\r\n{\r\nunsigned long flags;\r\nstruct sk_buff *skb;\r\nactcapi_msg *msg;\r\nint l;\r\nif (test_and_set_bit(ACT2000_LOCK_TX, (void *) &card->ilock) != 0)\r\nreturn;\r\nwhile (1) {\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (!(card->sbuf)) {\r\nif ((card->sbuf = skb_dequeue(&card->sndq))) {\r\ncard->ack_msg = card->sbuf->data;\r\nmsg = (actcapi_msg *)card->sbuf->data;\r\nif ((msg->hdr.cmd.cmd == 0x86) &&\r\n(msg->hdr.cmd.subcmd == 0)) {\r\ncard->need_b3ack = msg->msg.data_b3_req.flags;\r\nmsg->msg.data_b3_req.flags = 0;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nif (!(card->sbuf)) {\r\ntest_and_clear_bit(ACT2000_LOCK_TX, (void *) &card->ilock);\r\nreturn;\r\n}\r\nskb = card->sbuf;\r\nl = 0;\r\nwhile (skb->len) {\r\nif (act2000_isa_writeb(card, *(skb->data))) {\r\ntest_and_clear_bit(ACT2000_LOCK_TX, (void *) &card->ilock);\r\nact2000_schedule_tx(card);\r\nreturn;\r\n}\r\nskb_pull(skb, 1);\r\nl++;\r\n}\r\nmsg = (actcapi_msg *)card->ack_msg;\r\nif ((msg->hdr.cmd.cmd == 0x86) &&\r\n(msg->hdr.cmd.subcmd == 0)) {\r\nskb->data = card->ack_msg;\r\nmsg->msg.data_b3_req.flags = card->need_b3ack;\r\nskb_queue_tail(&card->ackq, skb);\r\n} else\r\ndev_kfree_skb(skb);\r\ncard->sbuf = NULL;\r\n}\r\n}\r\nstatic int\r\nact2000_isa_getid(act2000_card *card)\r\n{\r\nact2000_fwid fid;\r\nu_char *p = (u_char *)&fid;\r\nint count = 0;\r\nwhile (1) {\r\nif (count > 510)\r\nreturn -EPROTO;\r\nif (act2000_isa_readb(card, p++))\r\nbreak;\r\ncount++;\r\n}\r\nif (count <= 20) {\r\nprintk(KERN_WARNING "act2000: No Firmware-ID!\n");\r\nreturn -ETIME;\r\n}\r\n*p = '\0';\r\nfid.revlen[0] = '\0';\r\nif (strcmp(fid.isdn, "ISDN")) {\r\nprintk(KERN_WARNING "act2000: Wrong Firmware-ID!\n");\r\nreturn -EPROTO;\r\n}\r\nif ((p = strchr(fid.revision, '\n')))\r\n*p = '\0';\r\nprintk(KERN_INFO "act2000: Firmware-ID: %s\n", fid.revision);\r\nif (card->flags & ACT2000_FLAGS_IVALID) {\r\nprintk(KERN_DEBUG "Enabling Interrupts ...\n");\r\nact2000_isa_enable_irq(card);\r\n}\r\nreturn 0;\r\n}\r\nint\r\nact2000_isa_download(act2000_card *card, act2000_ddef __user *cb)\r\n{\r\nunsigned int length;\r\nint l;\r\nint c;\r\nlong timeout;\r\nu_char *b;\r\nu_char __user *p;\r\nu_char *buf;\r\nact2000_ddef cblock;\r\nif (!act2000_isa_reset(card->port))\r\nreturn -ENXIO;\r\nmsleep_interruptible(500);\r\nif (copy_from_user(&cblock, cb, sizeof(cblock)))\r\nreturn -EFAULT;\r\nlength = cblock.length;\r\np = cblock.buffer;\r\nif (!access_ok(VERIFY_READ, p, length))\r\nreturn -EFAULT;\r\nbuf = kmalloc(1024, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\ntimeout = 0;\r\nwhile (length) {\r\nl = (length > 1024) ? 1024 : length;\r\nc = 0;\r\nb = buf;\r\nif (copy_from_user(buf, p, l)) {\r\nkfree(buf);\r\nreturn -EFAULT;\r\n}\r\nwhile (c < l) {\r\nif (act2000_isa_writeb(card, *b++)) {\r\nprintk(KERN_WARNING\r\n"act2000: loader timed out"\r\n" len=%d c=%d\n", length, c);\r\nkfree(buf);\r\nreturn -ETIME;\r\n}\r\nc++;\r\n}\r\nlength -= l;\r\np += l;\r\n}\r\nkfree(buf);\r\nmsleep_interruptible(500);\r\nreturn (act2000_isa_getid(card));\r\n}
