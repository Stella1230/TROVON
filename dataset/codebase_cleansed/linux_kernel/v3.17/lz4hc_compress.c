static inline int lz4hc_init(struct lz4hc_data *hc4, const u8 *base)\r\n{\r\nmemset((void *)hc4->hashtable, 0, sizeof(hc4->hashtable));\r\nmemset(hc4->chaintable, 0xFF, sizeof(hc4->chaintable));\r\n#if LZ4_ARCH64\r\nhc4->nexttoupdate = base + 1;\r\n#else\r\nhc4->nexttoupdate = base;\r\n#endif\r\nhc4->base = base;\r\nreturn 1;\r\n}\r\nstatic inline void lz4hc_insert(struct lz4hc_data *hc4, const u8 *ip)\r\n{\r\nu16 *chaintable = hc4->chaintable;\r\nHTYPE *hashtable = hc4->hashtable;\r\n#if LZ4_ARCH64\r\nconst BYTE * const base = hc4->base;\r\n#else\r\nconst int base = 0;\r\n#endif\r\nwhile (hc4->nexttoupdate < ip) {\r\nconst u8 *p = hc4->nexttoupdate;\r\nsize_t delta = p - (hashtable[HASH_VALUE(p)] + base);\r\nif (delta > MAX_DISTANCE)\r\ndelta = MAX_DISTANCE;\r\nchaintable[(size_t)(p) & MAXD_MASK] = (u16)delta;\r\nhashtable[HASH_VALUE(p)] = (p) - base;\r\nhc4->nexttoupdate++;\r\n}\r\n}\r\nstatic inline size_t lz4hc_commonlength(const u8 *p1, const u8 *p2,\r\nconst u8 *const matchlimit)\r\n{\r\nconst u8 *p1t = p1;\r\nwhile (p1t < matchlimit - (STEPSIZE - 1)) {\r\n#if LZ4_ARCH64\r\nu64 diff = A64(p2) ^ A64(p1t);\r\n#else\r\nu32 diff = A32(p2) ^ A32(p1t);\r\n#endif\r\nif (!diff) {\r\np1t += STEPSIZE;\r\np2 += STEPSIZE;\r\ncontinue;\r\n}\r\np1t += LZ4_NBCOMMONBYTES(diff);\r\nreturn p1t - p1;\r\n}\r\n#if LZ4_ARCH64\r\nif ((p1t < (matchlimit-3)) && (A32(p2) == A32(p1t))) {\r\np1t += 4;\r\np2 += 4;\r\n}\r\n#endif\r\nif ((p1t < (matchlimit - 1)) && (A16(p2) == A16(p1t))) {\r\np1t += 2;\r\np2 += 2;\r\n}\r\nif ((p1t < matchlimit) && (*p2 == *p1t))\r\np1t++;\r\nreturn p1t - p1;\r\n}\r\nstatic inline int lz4hc_insertandfindbestmatch(struct lz4hc_data *hc4,\r\nconst u8 *ip, const u8 *const matchlimit, const u8 **matchpos)\r\n{\r\nu16 *const chaintable = hc4->chaintable;\r\nHTYPE *const hashtable = hc4->hashtable;\r\nconst u8 *ref;\r\n#if LZ4_ARCH64\r\nconst BYTE * const base = hc4->base;\r\n#else\r\nconst int base = 0;\r\n#endif\r\nint nbattempts = MAX_NB_ATTEMPTS;\r\nsize_t repl = 0, ml = 0;\r\nu16 delta;\r\nlz4hc_insert(hc4, ip);\r\nref = hashtable[HASH_VALUE(ip)] + base;\r\nif (ref >= ip-4) {\r\nif (A32(ref) == A32(ip)) {\r\ndelta = (u16)(ip-ref);\r\nrepl = ml = lz4hc_commonlength(ip + MINMATCH,\r\nref + MINMATCH, matchlimit) + MINMATCH;\r\n*matchpos = ref;\r\n}\r\nref -= (size_t)chaintable[(size_t)(ref) & MAXD_MASK];\r\n}\r\nwhile ((ref >= ip - MAX_DISTANCE) && nbattempts) {\r\nnbattempts--;\r\nif (*(ref + ml) == *(ip + ml)) {\r\nif (A32(ref) == A32(ip)) {\r\nsize_t mlt =\r\nlz4hc_commonlength(ip + MINMATCH,\r\nref + MINMATCH, matchlimit) + MINMATCH;\r\nif (mlt > ml) {\r\nml = mlt;\r\n*matchpos = ref;\r\n}\r\n}\r\n}\r\nref -= (size_t)chaintable[(size_t)(ref) & MAXD_MASK];\r\n}\r\nif (repl) {\r\nconst BYTE *ptr = ip;\r\nconst BYTE *end;\r\nend = ip + repl - (MINMATCH-1);\r\nwhile (ptr < end - delta) {\r\nchaintable[(size_t)(ptr) & MAXD_MASK] = delta;\r\nptr++;\r\n}\r\ndo {\r\nchaintable[(size_t)(ptr) & MAXD_MASK] = delta;\r\nhashtable[HASH_VALUE(ptr)] = (ptr) - base;\r\nptr++;\r\n} while (ptr < end);\r\nhc4->nexttoupdate = end;\r\n}\r\nreturn (int)ml;\r\n}\r\nstatic inline int lz4hc_insertandgetwidermatch(struct lz4hc_data *hc4,\r\nconst u8 *ip, const u8 *startlimit, const u8 *matchlimit, int longest,\r\nconst u8 **matchpos, const u8 **startpos)\r\n{\r\nu16 *const chaintable = hc4->chaintable;\r\nHTYPE *const hashtable = hc4->hashtable;\r\n#if LZ4_ARCH64\r\nconst BYTE * const base = hc4->base;\r\n#else\r\nconst int base = 0;\r\n#endif\r\nconst u8 *ref;\r\nint nbattempts = MAX_NB_ATTEMPTS;\r\nint delta = (int)(ip - startlimit);\r\nlz4hc_insert(hc4, ip);\r\nref = hashtable[HASH_VALUE(ip)] + base;\r\nwhile ((ref >= ip - MAX_DISTANCE) && (ref >= hc4->base)\r\n&& (nbattempts)) {\r\nnbattempts--;\r\nif (*(startlimit + longest) == *(ref - delta + longest)) {\r\nif (A32(ref) == A32(ip)) {\r\nconst u8 *reft = ref + MINMATCH;\r\nconst u8 *ipt = ip + MINMATCH;\r\nconst u8 *startt = ip;\r\nwhile (ipt < matchlimit-(STEPSIZE - 1)) {\r\n#if LZ4_ARCH64\r\nu64 diff = A64(reft) ^ A64(ipt);\r\n#else\r\nu32 diff = A32(reft) ^ A32(ipt);\r\n#endif\r\nif (!diff) {\r\nipt += STEPSIZE;\r\nreft += STEPSIZE;\r\ncontinue;\r\n}\r\nipt += LZ4_NBCOMMONBYTES(diff);\r\ngoto _endcount;\r\n}\r\n#if LZ4_ARCH64\r\nif ((ipt < (matchlimit - 3))\r\n&& (A32(reft) == A32(ipt))) {\r\nipt += 4;\r\nreft += 4;\r\n}\r\nipt += 2;\r\n#endif\r\nif ((ipt < (matchlimit - 1))\r\n&& (A16(reft) == A16(ipt))) {\r\nreft += 2;\r\n}\r\nif ((ipt < matchlimit) && (*reft == *ipt))\r\nipt++;\r\n_endcount:\r\nreft = ref;\r\nwhile ((startt > startlimit)\r\n&& (reft > hc4->base)\r\n&& (startt[-1] == reft[-1])) {\r\nstartt--;\r\nreft--;\r\n}\r\nif ((ipt - startt) > longest) {\r\nlongest = (int)(ipt - startt);\r\n*matchpos = reft;\r\n*startpos = startt;\r\n}\r\n}\r\n}\r\nref -= (size_t)chaintable[(size_t)(ref) & MAXD_MASK];\r\n}\r\nreturn longest;\r\n}\r\nstatic inline int lz4_encodesequence(const u8 **ip, u8 **op, const u8 **anchor,\r\nint ml, const u8 *ref)\r\n{\r\nint length, len;\r\nu8 *token;\r\nlength = (int)(*ip - *anchor);\r\ntoken = (*op)++;\r\nif (length >= (int)RUN_MASK) {\r\n*token = (RUN_MASK << ML_BITS);\r\nlen = length - RUN_MASK;\r\nfor (; len > 254 ; len -= 255)\r\n*(*op)++ = 255;\r\n*(*op)++ = (u8)len;\r\n} else\r\n*token = (length << ML_BITS);\r\nLZ4_BLINDCOPY(*anchor, *op, length);\r\nLZ4_WRITE_LITTLEENDIAN_16(*op, (u16)(*ip - ref));\r\nlen = (int)(ml - MINMATCH);\r\nif (len >= (int)ML_MASK) {\r\n*token += ML_MASK;\r\nlen -= ML_MASK;\r\nfor (; len > 509 ; len -= 510) {\r\n*(*op)++ = 255;\r\n*(*op)++ = 255;\r\n}\r\nif (len > 254) {\r\nlen -= 255;\r\n*(*op)++ = 255;\r\n}\r\n*(*op)++ = (u8)len;\r\n} else\r\n*token += len;\r\n*ip += ml;\r\n*anchor = *ip;\r\nreturn 0;\r\n}\r\nstatic int lz4_compresshcctx(struct lz4hc_data *ctx,\r\nconst char *source,\r\nchar *dest,\r\nint isize)\r\n{\r\nconst u8 *ip = (const u8 *)source;\r\nconst u8 *anchor = ip;\r\nconst u8 *const iend = ip + isize;\r\nconst u8 *const mflimit = iend - MFLIMIT;\r\nconst u8 *const matchlimit = (iend - LASTLITERALS);\r\nu8 *op = (u8 *)dest;\r\nint ml, ml2, ml3, ml0;\r\nconst u8 *ref = NULL;\r\nconst u8 *start2 = NULL;\r\nconst u8 *ref2 = NULL;\r\nconst u8 *start3 = NULL;\r\nconst u8 *ref3 = NULL;\r\nconst u8 *start0;\r\nconst u8 *ref0;\r\nint lastrun;\r\nip++;\r\nwhile (ip < mflimit) {\r\nml = lz4hc_insertandfindbestmatch(ctx, ip, matchlimit, (&ref));\r\nif (!ml) {\r\nip++;\r\ncontinue;\r\n}\r\nstart0 = ip;\r\nref0 = ref;\r\nml0 = ml;\r\n_search2:\r\nif (ip+ml < mflimit)\r\nml2 = lz4hc_insertandgetwidermatch(ctx, ip + ml - 2,\r\nip + 1, matchlimit, ml, &ref2, &start2);\r\nelse\r\nml2 = ml;\r\nif (ml2 == ml) {\r\nlz4_encodesequence(&ip, &op, &anchor, ml, ref);\r\ncontinue;\r\n}\r\nif (start0 < ip) {\r\nif (start2 < ip + ml0) {\r\nip = start0;\r\nref = ref0;\r\nml = ml0;\r\n}\r\n}\r\nif ((start2 - ip) < 3) {\r\nml = ml2;\r\nip = start2;\r\nref = ref2;\r\ngoto _search2;\r\n}\r\n_search3:\r\nif ((start2 - ip) < OPTIMAL_ML) {\r\nint correction;\r\nint new_ml = ml;\r\nif (new_ml > OPTIMAL_ML)\r\nnew_ml = OPTIMAL_ML;\r\nif (ip + new_ml > start2 + ml2 - MINMATCH)\r\nnew_ml = (int)(start2 - ip) + ml2 - MINMATCH;\r\ncorrection = new_ml - (int)(start2 - ip);\r\nif (correction > 0) {\r\nstart2 += correction;\r\nref2 += correction;\r\nml2 -= correction;\r\n}\r\n}\r\nif (start2 + ml2 < mflimit)\r\nml3 = lz4hc_insertandgetwidermatch(ctx,\r\nstart2 + ml2 - 3, start2, matchlimit,\r\nml2, &ref3, &start3);\r\nelse\r\nml3 = ml2;\r\nif (ml3 == ml2) {\r\nif (start2 < ip+ml)\r\nml = (int)(start2 - ip);\r\nlz4_encodesequence(&ip, &op, &anchor, ml, ref);\r\nip = start2;\r\nlz4_encodesequence(&ip, &op, &anchor, ml2, ref2);\r\ncontinue;\r\n}\r\nif (start3 < ip + ml + 3) {\r\nif (start3 >= (ip + ml)) {\r\nif (start2 < ip + ml) {\r\nint correction =\r\n(int)(ip + ml - start2);\r\nstart2 += correction;\r\nref2 += correction;\r\nml2 -= correction;\r\nif (ml2 < MINMATCH) {\r\nstart2 = start3;\r\nref2 = ref3;\r\nml2 = ml3;\r\n}\r\n}\r\nlz4_encodesequence(&ip, &op, &anchor, ml, ref);\r\nip = start3;\r\nref = ref3;\r\nml = ml3;\r\nstart0 = start2;\r\nref0 = ref2;\r\nml0 = ml2;\r\ngoto _search2;\r\n}\r\nstart2 = start3;\r\nref2 = ref3;\r\nml2 = ml3;\r\ngoto _search3;\r\n}\r\nif (start2 < ip + ml) {\r\nif ((start2 - ip) < (int)ML_MASK) {\r\nint correction;\r\nif (ml > OPTIMAL_ML)\r\nml = OPTIMAL_ML;\r\nif (ip + ml > start2 + ml2 - MINMATCH)\r\nml = (int)(start2 - ip) + ml2\r\n- MINMATCH;\r\ncorrection = ml - (int)(start2 - ip);\r\nif (correction > 0) {\r\nstart2 += correction;\r\nref2 += correction;\r\nml2 -= correction;\r\n}\r\n} else\r\nml = (int)(start2 - ip);\r\n}\r\nlz4_encodesequence(&ip, &op, &anchor, ml, ref);\r\nip = start2;\r\nref = ref2;\r\nml = ml2;\r\nstart2 = start3;\r\nref2 = ref3;\r\nml2 = ml3;\r\ngoto _search3;\r\n}\r\nlastrun = (int)(iend - anchor);\r\nif (lastrun >= (int)RUN_MASK) {\r\n*op++ = (RUN_MASK << ML_BITS);\r\nlastrun -= RUN_MASK;\r\nfor (; lastrun > 254 ; lastrun -= 255)\r\n*op++ = 255;\r\n*op++ = (u8) lastrun;\r\n} else\r\n*op++ = (lastrun << ML_BITS);\r\nmemcpy(op, anchor, iend - anchor);\r\nop += iend - anchor;\r\nreturn (int) (((char *)op) - dest);\r\n}\r\nint lz4hc_compress(const unsigned char *src, size_t src_len,\r\nunsigned char *dst, size_t *dst_len, void *wrkmem)\r\n{\r\nint ret = -1;\r\nint out_len = 0;\r\nstruct lz4hc_data *hc4 = (struct lz4hc_data *)wrkmem;\r\nlz4hc_init(hc4, (const u8 *)src);\r\nout_len = lz4_compresshcctx((struct lz4hc_data *)hc4, (const u8 *)src,\r\n(char *)dst, (int)src_len);\r\nif (out_len < 0)\r\ngoto exit;\r\n*dst_len = out_len;\r\nreturn 0;\r\nexit:\r\nreturn ret;\r\n}
