static sector_t cchh2blk(struct vtoc_cchh *ptr, struct hd_geometry *geo)\r\n{\r\nsector_t cyl;\r\n__u16 head;\r\ncyl = ptr->hh & 0xFFF0;\r\ncyl <<= 12;\r\ncyl |= ptr->cc;\r\nhead = ptr->hh & 0x000F;\r\nreturn cyl * geo->heads * geo->sectors +\r\nhead * geo->sectors;\r\n}\r\nstatic sector_t cchhb2blk(struct vtoc_cchhb *ptr, struct hd_geometry *geo)\r\n{\r\nsector_t cyl;\r\n__u16 head;\r\ncyl = ptr->hh & 0xFFF0;\r\ncyl <<= 12;\r\ncyl |= ptr->cc;\r\nhead = ptr->hh & 0x000F;\r\nreturn cyl * geo->heads * geo->sectors +\r\nhead * geo->sectors +\r\nptr->b;\r\n}\r\nstatic int find_label(struct parsed_partitions *state,\r\ndasd_information2_t *info,\r\nstruct hd_geometry *geo,\r\nint blocksize,\r\nsector_t *labelsect,\r\nchar name[],\r\nchar type[],\r\nunion label_t *label)\r\n{\r\nSector sect;\r\nunsigned char *data;\r\nsector_t testsect[3];\r\nunsigned char temp[5];\r\nint found = 0;\r\nint i, testcount;\r\nif (info) {\r\nif ((info->cu_type == 0x6310 && info->dev_type == 0x9336) ||\r\n(info->cu_type == 0x3880 && info->dev_type == 0x3370))\r\ntestsect[0] = info->label_block;\r\nelse\r\ntestsect[0] = info->label_block * (blocksize >> 9);\r\ntestcount = 1;\r\n} else {\r\ntestsect[0] = 1;\r\ntestsect[1] = (blocksize >> 9);\r\ntestsect[2] = 2 * (blocksize >> 9);\r\ntestcount = 3;\r\n}\r\nfor (i = 0; i < testcount; ++i) {\r\ndata = read_part_sector(state, testsect[i], &sect);\r\nif (data == NULL)\r\ncontinue;\r\nmemcpy(label, data, sizeof(*label));\r\nmemcpy(temp, data, 4);\r\ntemp[4] = 0;\r\nEBCASC(temp, 4);\r\nput_dev_sector(sect);\r\nif (!strcmp(temp, "VOL1") ||\r\n!strcmp(temp, "LNX1") ||\r\n!strcmp(temp, "CMS1")) {\r\nif (!strcmp(temp, "VOL1")) {\r\nstrncpy(type, label->vol.vollbl, 4);\r\nstrncpy(name, label->vol.volid, 6);\r\n} else {\r\nstrncpy(type, label->lnx.vollbl, 4);\r\nstrncpy(name, label->lnx.volid, 6);\r\n}\r\nEBCASC(type, 4);\r\nEBCASC(name, 6);\r\n*labelsect = testsect[i];\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nmemset(label, 0, sizeof(*label));\r\nreturn found;\r\n}\r\nstatic int find_vol1_partitions(struct parsed_partitions *state,\r\nstruct hd_geometry *geo,\r\nint blocksize,\r\nchar name[],\r\nunion label_t *label)\r\n{\r\nsector_t blk;\r\nint counter;\r\nchar tmp[64];\r\nSector sect;\r\nunsigned char *data;\r\nloff_t offset, size;\r\nstruct vtoc_format1_label f1;\r\nint secperblk;\r\nsnprintf(tmp, sizeof(tmp), "VOL1/%8s:", name);\r\nstrlcat(state->pp_buf, tmp, PAGE_SIZE);\r\nsecperblk = blocksize >> 9;\r\nblk = cchhb2blk(&label->vol.vtoc, geo) + 1;\r\ncounter = 0;\r\ndata = read_part_sector(state, blk * secperblk, &sect);\r\nwhile (data != NULL) {\r\nmemcpy(&f1, data, sizeof(struct vtoc_format1_label));\r\nput_dev_sector(sect);\r\nif (f1.DS1FMTID == _ascebc['4']\r\n|| f1.DS1FMTID == _ascebc['5']\r\n|| f1.DS1FMTID == _ascebc['7']\r\n|| f1.DS1FMTID == _ascebc['9']) {\r\nblk++;\r\ndata = read_part_sector(state, blk * secperblk, &sect);\r\ncontinue;\r\n}\r\nif (f1.DS1FMTID != _ascebc['1'] &&\r\nf1.DS1FMTID != _ascebc['8'])\r\nbreak;\r\noffset = cchh2blk(&f1.DS1EXT1.llimit, geo);\r\nsize = cchh2blk(&f1.DS1EXT1.ulimit, geo) -\r\noffset + geo->sectors;\r\noffset *= secperblk;\r\nsize *= secperblk;\r\nif (counter >= state->limit)\r\nbreak;\r\nput_partition(state, counter + 1, offset, size);\r\ncounter++;\r\nblk++;\r\ndata = read_part_sector(state, blk * secperblk, &sect);\r\n}\r\nstrlcat(state->pp_buf, "\n", PAGE_SIZE);\r\nif (!data)\r\nreturn -1;\r\nreturn 1;\r\n}\r\nstatic int find_lnx1_partitions(struct parsed_partitions *state,\r\nstruct hd_geometry *geo,\r\nint blocksize,\r\nchar name[],\r\nunion label_t *label,\r\nsector_t labelsect,\r\nloff_t i_size,\r\ndasd_information2_t *info)\r\n{\r\nloff_t offset, geo_size, size;\r\nchar tmp[64];\r\nint secperblk;\r\nsnprintf(tmp, sizeof(tmp), "LNX1/%8s:", name);\r\nstrlcat(state->pp_buf, tmp, PAGE_SIZE);\r\nsecperblk = blocksize >> 9;\r\nif (label->lnx.ldl_version == 0xf2) {\r\nsize = label->lnx.formatted_blocks * secperblk;\r\n} else {\r\ngeo_size = geo->cylinders * geo->heads\r\n* geo->sectors * secperblk;\r\nsize = i_size >> 9;\r\nif (size != geo_size) {\r\nif (!info) {\r\nstrlcat(state->pp_buf, "\n", PAGE_SIZE);\r\nreturn 1;\r\n}\r\nif (!strcmp(info->type, "ECKD"))\r\nif (geo_size < size)\r\nsize = geo_size;\r\n}\r\n}\r\noffset = labelsect + secperblk;\r\nput_partition(state, 1, offset, size - offset);\r\nstrlcat(state->pp_buf, "\n", PAGE_SIZE);\r\nreturn 1;\r\n}\r\nstatic int find_cms1_partitions(struct parsed_partitions *state,\r\nstruct hd_geometry *geo,\r\nint blocksize,\r\nchar name[],\r\nunion label_t *label,\r\nsector_t labelsect)\r\n{\r\nloff_t offset, size;\r\nchar tmp[64];\r\nint secperblk;\r\nblocksize = label->cms.block_size;\r\nsecperblk = blocksize >> 9;\r\nif (label->cms.disk_offset != 0) {\r\nsnprintf(tmp, sizeof(tmp), "CMS1/%8s(MDSK):", name);\r\nstrlcat(state->pp_buf, tmp, PAGE_SIZE);\r\noffset = label->cms.disk_offset * secperblk;\r\nsize = (label->cms.block_count - 1) * secperblk;\r\n} else {\r\nsnprintf(tmp, sizeof(tmp), "CMS1/%8s:", name);\r\nstrlcat(state->pp_buf, tmp, PAGE_SIZE);\r\nif (labelsect == 1)\r\noffset = 2 * secperblk;\r\nelse\r\noffset = labelsect + secperblk;\r\nsize = label->cms.block_count * secperblk;\r\n}\r\nput_partition(state, 1, offset, size-offset);\r\nstrlcat(state->pp_buf, "\n", PAGE_SIZE);\r\nreturn 1;\r\n}\r\nint ibm_partition(struct parsed_partitions *state)\r\n{\r\nstruct block_device *bdev = state->bdev;\r\nint blocksize, res;\r\nloff_t i_size, offset, size;\r\ndasd_information2_t *info;\r\nstruct hd_geometry *geo;\r\nchar type[5] = {0,};\r\nchar name[7] = {0,};\r\nsector_t labelsect;\r\nunion label_t *label;\r\nres = 0;\r\nblocksize = bdev_logical_block_size(bdev);\r\nif (blocksize <= 0)\r\ngoto out_exit;\r\ni_size = i_size_read(bdev->bd_inode);\r\nif (i_size == 0)\r\ngoto out_exit;\r\ninfo = kmalloc(sizeof(dasd_information2_t), GFP_KERNEL);\r\nif (info == NULL)\r\ngoto out_exit;\r\ngeo = kmalloc(sizeof(struct hd_geometry), GFP_KERNEL);\r\nif (geo == NULL)\r\ngoto out_nogeo;\r\nlabel = kmalloc(sizeof(union label_t), GFP_KERNEL);\r\nif (label == NULL)\r\ngoto out_nolab;\r\nif (ioctl_by_bdev(bdev, HDIO_GETGEO, (unsigned long)geo) != 0)\r\ngoto out_freeall;\r\nif (ioctl_by_bdev(bdev, BIODASDINFO2, (unsigned long)info) != 0) {\r\nkfree(info);\r\ninfo = NULL;\r\n}\r\nif (find_label(state, info, geo, blocksize, &labelsect, name, type,\r\nlabel)) {\r\nif (!strncmp(type, "VOL1", 4)) {\r\nres = find_vol1_partitions(state, geo, blocksize, name,\r\nlabel);\r\n} else if (!strncmp(type, "LNX1", 4)) {\r\nres = find_lnx1_partitions(state, geo, blocksize, name,\r\nlabel, labelsect, i_size,\r\ninfo);\r\n} else if (!strncmp(type, "CMS1", 4)) {\r\nres = find_cms1_partitions(state, geo, blocksize, name,\r\nlabel, labelsect);\r\n}\r\n} else if (info) {\r\nres = 1;\r\nif (info->format == DASD_FORMAT_LDL) {\r\nstrlcat(state->pp_buf, "(nonl)", PAGE_SIZE);\r\nsize = i_size >> 9;\r\noffset = (info->label_block + 1) * (blocksize >> 9);\r\nput_partition(state, 1, offset, size-offset);\r\nstrlcat(state->pp_buf, "\n", PAGE_SIZE);\r\n}\r\n} else\r\nres = 0;\r\nout_freeall:\r\nkfree(label);\r\nout_nolab:\r\nkfree(geo);\r\nout_nogeo:\r\nkfree(info);\r\nout_exit:\r\nreturn res;\r\n}
