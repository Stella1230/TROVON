static func_desc_t func_desc(unsigned long addr)\r\n{\r\nreturn addr;\r\n}\r\nstatic unsigned long func_addr(unsigned long addr)\r\n{\r\nreturn addr;\r\n}\r\nstatic unsigned long stub_func_addr(func_desc_t func)\r\n{\r\nreturn func;\r\n}\r\nstatic unsigned int local_entry_offset(const Elf64_Sym *sym)\r\n{\r\nreturn PPC64_LOCAL_ENTRY_OFFSET(sym->st_other);\r\n}\r\nstatic func_desc_t func_desc(unsigned long addr)\r\n{\r\nreturn *(struct ppc64_opd_entry *)addr;\r\n}\r\nstatic unsigned long func_addr(unsigned long addr)\r\n{\r\nreturn func_desc(addr).funcaddr;\r\n}\r\nstatic unsigned long stub_func_addr(func_desc_t func)\r\n{\r\nreturn func.funcaddr;\r\n}\r\nstatic unsigned int local_entry_offset(const Elf64_Sym *sym)\r\n{\r\nreturn 0;\r\n}\r\nbool is_module_trampoline(u32 *p)\r\n{\r\nunsigned int i;\r\nu32 insns[ARRAY_SIZE(ppc64_stub_insns)];\r\nBUILD_BUG_ON(sizeof(ppc64_stub_insns) != sizeof(ppc64_stub_mask));\r\nif (probe_kernel_read(insns, p, sizeof(insns)))\r\nreturn -EFAULT;\r\nfor (i = 0; i < ARRAY_SIZE(ppc64_stub_insns); i++) {\r\nu32 insna = insns[i];\r\nu32 insnb = ppc64_stub_insns[i];\r\nu32 mask = ppc64_stub_mask[i];\r\nif ((insna & mask) != (insnb & mask))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nint module_trampoline_target(struct module *mod, u32 *trampoline,\r\nunsigned long *target)\r\n{\r\nu32 buf[2];\r\nu16 upper, lower;\r\nlong offset;\r\nvoid *toc_entry;\r\nif (probe_kernel_read(buf, trampoline, sizeof(buf)))\r\nreturn -EFAULT;\r\nupper = buf[0] & 0xffff;\r\nlower = buf[1] & 0xffff;\r\noffset = ((short)upper << 16) + (short)lower;\r\ntoc_entry = (void *)mod->arch.toc + offset + 32;\r\nif (probe_kernel_read(target, toc_entry, sizeof(*target)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic unsigned int count_relocs(const Elf64_Rela *rela, unsigned int num)\r\n{\r\nunsigned int i, r_info, r_addend, _count_relocs;\r\n_count_relocs = 0;\r\nr_info = 0;\r\nr_addend = 0;\r\nfor (i = 0; i < num; i++)\r\nif (ELF64_R_TYPE(rela[i].r_info) == R_PPC_REL24 &&\r\n(r_info != ELF64_R_SYM(rela[i].r_info) ||\r\nr_addend != rela[i].r_addend)) {\r\n_count_relocs++;\r\nr_info = ELF64_R_SYM(rela[i].r_info);\r\nr_addend = rela[i].r_addend;\r\n}\r\nreturn _count_relocs;\r\n}\r\nstatic int relacmp(const void *_x, const void *_y)\r\n{\r\nconst Elf64_Rela *x, *y;\r\ny = (Elf64_Rela *)_x;\r\nx = (Elf64_Rela *)_y;\r\nif (x->r_info < y->r_info)\r\nreturn -1;\r\nelse if (x->r_info > y->r_info)\r\nreturn 1;\r\nelse if (x->r_addend < y->r_addend)\r\nreturn -1;\r\nelse if (x->r_addend > y->r_addend)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void relaswap(void *_x, void *_y, int size)\r\n{\r\nuint64_t *x, *y, tmp;\r\nint i;\r\ny = (uint64_t *)_x;\r\nx = (uint64_t *)_y;\r\nfor (i = 0; i < sizeof(Elf64_Rela) / sizeof(uint64_t); i++) {\r\ntmp = x[i];\r\nx[i] = y[i];\r\ny[i] = tmp;\r\n}\r\n}\r\nstatic unsigned long get_stubs_size(const Elf64_Ehdr *hdr,\r\nconst Elf64_Shdr *sechdrs)\r\n{\r\nunsigned long relocs = 1;\r\nunsigned i;\r\nfor (i = 1; i < hdr->e_shnum; i++) {\r\nif (sechdrs[i].sh_type == SHT_RELA) {\r\nDEBUGP("Found relocations in section %u\n", i);\r\nDEBUGP("Ptr: %p. Number: %lu\n",\r\n(void *)sechdrs[i].sh_addr,\r\nsechdrs[i].sh_size / sizeof(Elf64_Rela));\r\nsort((void *)sechdrs[i].sh_addr,\r\nsechdrs[i].sh_size / sizeof(Elf64_Rela),\r\nsizeof(Elf64_Rela), relacmp, relaswap);\r\nrelocs += count_relocs((void *)sechdrs[i].sh_addr,\r\nsechdrs[i].sh_size\r\n/ sizeof(Elf64_Rela));\r\n}\r\n}\r\n#ifdef CONFIG_DYNAMIC_FTRACE\r\nrelocs++;\r\n#endif\r\nDEBUGP("Looks like a total of %lu stubs, max\n", relocs);\r\nreturn relocs * sizeof(struct ppc64_stub_entry);\r\n}\r\nstatic void dedotify_versions(struct modversion_info *vers,\r\nunsigned long size)\r\n{\r\nstruct modversion_info *end;\r\nfor (end = (void *)vers + size; vers < end; vers++)\r\nif (vers->name[0] == '.') {\r\nmemmove(vers->name, vers->name+1, strlen(vers->name));\r\n#ifdef ARCH_RELOCATES_KCRCTAB\r\nif (!strcmp(vers->name, "TOC."))\r\nvers->crc = -(unsigned long)reloc_start;\r\n#endif\r\n}\r\n}\r\nstatic void dedotify(Elf64_Sym *syms, unsigned int numsyms, char *strtab)\r\n{\r\nunsigned int i;\r\nfor (i = 1; i < numsyms; i++) {\r\nif (syms[i].st_shndx == SHN_UNDEF) {\r\nchar *name = strtab + syms[i].st_name;\r\nif (name[0] == '.')\r\nmemmove(name, name+1, strlen(name));\r\n}\r\n}\r\n}\r\nstatic Elf64_Sym *find_dot_toc(Elf64_Shdr *sechdrs,\r\nconst char *strtab,\r\nunsigned int symindex)\r\n{\r\nunsigned int i, numsyms;\r\nElf64_Sym *syms;\r\nsyms = (Elf64_Sym *)sechdrs[symindex].sh_addr;\r\nnumsyms = sechdrs[symindex].sh_size / sizeof(Elf64_Sym);\r\nfor (i = 1; i < numsyms; i++) {\r\nif (syms[i].st_shndx == SHN_UNDEF\r\n&& strcmp(strtab + syms[i].st_name, "TOC.") == 0)\r\nreturn &syms[i];\r\n}\r\nreturn NULL;\r\n}\r\nint module_frob_arch_sections(Elf64_Ehdr *hdr,\r\nElf64_Shdr *sechdrs,\r\nchar *secstrings,\r\nstruct module *me)\r\n{\r\nunsigned int i;\r\nfor (i = 1; i < hdr->e_shnum; i++) {\r\nchar *p;\r\nif (strcmp(secstrings + sechdrs[i].sh_name, ".stubs") == 0)\r\nme->arch.stubs_section = i;\r\nelse if (strcmp(secstrings + sechdrs[i].sh_name, ".toc") == 0)\r\nme->arch.toc_section = i;\r\nelse if (strcmp(secstrings+sechdrs[i].sh_name,"__versions")==0)\r\ndedotify_versions((void *)hdr + sechdrs[i].sh_offset,\r\nsechdrs[i].sh_size);\r\nwhile ((p = strstr(secstrings + sechdrs[i].sh_name, ".init")))\r\np[0] = '_';\r\nif (sechdrs[i].sh_type == SHT_SYMTAB)\r\ndedotify((void *)hdr + sechdrs[i].sh_offset,\r\nsechdrs[i].sh_size / sizeof(Elf64_Sym),\r\n(void *)hdr\r\n+ sechdrs[sechdrs[i].sh_link].sh_offset);\r\n}\r\nif (!me->arch.stubs_section) {\r\nprintk("%s: doesn't contain .stubs.\n", me->name);\r\nreturn -ENOEXEC;\r\n}\r\nif (!me->arch.toc_section)\r\nme->arch.toc_section = me->arch.stubs_section;\r\nsechdrs[me->arch.stubs_section].sh_size = get_stubs_size(hdr, sechdrs);\r\nreturn 0;\r\n}\r\nstatic inline unsigned long my_r2(Elf64_Shdr *sechdrs, struct module *me)\r\n{\r\nreturn sechdrs[me->arch.toc_section].sh_addr + 0x8000;\r\n}\r\nstatic inline int create_stub(Elf64_Shdr *sechdrs,\r\nstruct ppc64_stub_entry *entry,\r\nunsigned long addr,\r\nstruct module *me)\r\n{\r\nlong reladdr;\r\nmemcpy(entry->jump, ppc64_stub_insns, sizeof(ppc64_stub_insns));\r\nreladdr = (unsigned long)entry - my_r2(sechdrs, me);\r\nif (reladdr > 0x7FFFFFFF || reladdr < -(0x80000000L)) {\r\nprintk("%s: Address %p of stub out of range of %p.\n",\r\nme->name, (void *)reladdr, (void *)my_r2);\r\nreturn 0;\r\n}\r\nDEBUGP("Stub %p get data from reladdr %li\n", entry, reladdr);\r\nentry->jump[0] |= PPC_HA(reladdr);\r\nentry->jump[1] |= PPC_LO(reladdr);\r\nentry->funcdata = func_desc(addr);\r\nreturn 1;\r\n}\r\nstatic unsigned long stub_for_addr(Elf64_Shdr *sechdrs,\r\nunsigned long addr,\r\nstruct module *me)\r\n{\r\nstruct ppc64_stub_entry *stubs;\r\nunsigned int i, num_stubs;\r\nnum_stubs = sechdrs[me->arch.stubs_section].sh_size / sizeof(*stubs);\r\nstubs = (void *)sechdrs[me->arch.stubs_section].sh_addr;\r\nfor (i = 0; stub_func_addr(stubs[i].funcdata); i++) {\r\nBUG_ON(i >= num_stubs);\r\nif (stub_func_addr(stubs[i].funcdata) == func_addr(addr))\r\nreturn (unsigned long)&stubs[i];\r\n}\r\nif (!create_stub(sechdrs, &stubs[i], addr, me))\r\nreturn 0;\r\nreturn (unsigned long)&stubs[i];\r\n}\r\nstatic int restore_r2(u32 *instruction, struct module *me)\r\n{\r\nif (*instruction != PPC_INST_NOP) {\r\nprintk("%s: Expect noop after relocate, got %08x\n",\r\nme->name, *instruction);\r\nreturn 0;\r\n}\r\n*instruction = 0xe8410000 | R2_STACK_OFFSET;\r\nreturn 1;\r\n}\r\nint apply_relocate_add(Elf64_Shdr *sechdrs,\r\nconst char *strtab,\r\nunsigned int symindex,\r\nunsigned int relsec,\r\nstruct module *me)\r\n{\r\nunsigned int i;\r\nElf64_Rela *rela = (void *)sechdrs[relsec].sh_addr;\r\nElf64_Sym *sym;\r\nunsigned long *location;\r\nunsigned long value;\r\nDEBUGP("Applying ADD relocate section %u to %u\n", relsec,\r\nsechdrs[relsec].sh_info);\r\nif (!me->arch.toc_fixed) {\r\nsym = find_dot_toc(sechdrs, strtab, symindex);\r\nif (sym)\r\nsym->st_value = my_r2(sechdrs, me);\r\nme->arch.toc_fixed = true;\r\n}\r\nfor (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rela); i++) {\r\nlocation = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr\r\n+ rela[i].r_offset;\r\nsym = (Elf64_Sym *)sechdrs[symindex].sh_addr\r\n+ ELF64_R_SYM(rela[i].r_info);\r\nDEBUGP("RELOC at %p: %li-type as %s (%lu) + %li\n",\r\nlocation, (long)ELF64_R_TYPE(rela[i].r_info),\r\nstrtab + sym->st_name, (unsigned long)sym->st_value,\r\n(long)rela[i].r_addend);\r\nvalue = sym->st_value + rela[i].r_addend;\r\nswitch (ELF64_R_TYPE(rela[i].r_info)) {\r\ncase R_PPC64_ADDR32:\r\n*(u32 *)location = value;\r\nbreak;\r\ncase R_PPC64_ADDR64:\r\n*(unsigned long *)location = value;\r\nbreak;\r\ncase R_PPC64_TOC:\r\n*(unsigned long *)location = my_r2(sechdrs, me);\r\nbreak;\r\ncase R_PPC64_TOC16:\r\nvalue -= my_r2(sechdrs, me);\r\nif (value + 0x8000 > 0xffff) {\r\nprintk("%s: bad TOC16 relocation (%lu)\n",\r\nme->name, value);\r\nreturn -ENOEXEC;\r\n}\r\n*((uint16_t *) location)\r\n= (*((uint16_t *) location) & ~0xffff)\r\n| (value & 0xffff);\r\nbreak;\r\ncase R_PPC64_TOC16_LO:\r\nvalue -= my_r2(sechdrs, me);\r\n*((uint16_t *) location)\r\n= (*((uint16_t *) location) & ~0xffff)\r\n| (value & 0xffff);\r\nbreak;\r\ncase R_PPC64_TOC16_DS:\r\nvalue -= my_r2(sechdrs, me);\r\nif ((value & 3) != 0 || value + 0x8000 > 0xffff) {\r\nprintk("%s: bad TOC16_DS relocation (%lu)\n",\r\nme->name, value);\r\nreturn -ENOEXEC;\r\n}\r\n*((uint16_t *) location)\r\n= (*((uint16_t *) location) & ~0xfffc)\r\n| (value & 0xfffc);\r\nbreak;\r\ncase R_PPC64_TOC16_LO_DS:\r\nvalue -= my_r2(sechdrs, me);\r\nif ((value & 3) != 0) {\r\nprintk("%s: bad TOC16_LO_DS relocation (%lu)\n",\r\nme->name, value);\r\nreturn -ENOEXEC;\r\n}\r\n*((uint16_t *) location)\r\n= (*((uint16_t *) location) & ~0xfffc)\r\n| (value & 0xfffc);\r\nbreak;\r\ncase R_PPC64_TOC16_HA:\r\nvalue -= my_r2(sechdrs, me);\r\nvalue = ((value + 0x8000) >> 16);\r\n*((uint16_t *) location)\r\n= (*((uint16_t *) location) & ~0xffff)\r\n| (value & 0xffff);\r\nbreak;\r\ncase R_PPC_REL24:\r\nif (sym->st_shndx == SHN_UNDEF) {\r\nvalue = stub_for_addr(sechdrs, value, me);\r\nif (!value)\r\nreturn -ENOENT;\r\nif (!restore_r2((u32 *)location + 1, me))\r\nreturn -ENOEXEC;\r\n} else\r\nvalue += local_entry_offset(sym);\r\nvalue -= (unsigned long)location;\r\nif (value + 0x2000000 > 0x3ffffff || (value & 3) != 0){\r\nprintk("%s: REL24 %li out of range!\n",\r\nme->name, (long int)value);\r\nreturn -ENOEXEC;\r\n}\r\n*(uint32_t *)location\r\n= (*(uint32_t *)location & ~0x03fffffc)\r\n| (value & 0x03fffffc);\r\nbreak;\r\ncase R_PPC64_REL64:\r\n*location = value - (unsigned long)location;\r\nbreak;\r\ncase R_PPC64_TOCSAVE:\r\nbreak;\r\ncase R_PPC64_REL16_HA:\r\nvalue -= (unsigned long)location;\r\nvalue = ((value + 0x8000) >> 16);\r\n*((uint16_t *) location)\r\n= (*((uint16_t *) location) & ~0xffff)\r\n| (value & 0xffff);\r\nbreak;\r\ncase R_PPC64_REL16_LO:\r\nvalue -= (unsigned long)location;\r\n*((uint16_t *) location)\r\n= (*((uint16_t *) location) & ~0xffff)\r\n| (value & 0xffff);\r\nbreak;\r\ndefault:\r\nprintk("%s: Unknown ADD relocation: %lu\n",\r\nme->name,\r\n(unsigned long)ELF64_R_TYPE(rela[i].r_info));\r\nreturn -ENOEXEC;\r\n}\r\n}\r\n#ifdef CONFIG_DYNAMIC_FTRACE\r\nme->arch.toc = my_r2(sechdrs, me);\r\nme->arch.tramp = stub_for_addr(sechdrs,\r\n(unsigned long)ftrace_caller,\r\nme);\r\n#endif\r\nreturn 0;\r\n}
