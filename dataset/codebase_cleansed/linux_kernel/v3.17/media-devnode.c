static void media_devnode_release(struct device *cd)\r\n{\r\nstruct media_devnode *mdev = to_media_devnode(cd);\r\nmutex_lock(&media_devnode_lock);\r\ncdev_del(&mdev->cdev);\r\nclear_bit(mdev->minor, media_devnode_nums);\r\nmutex_unlock(&media_devnode_lock);\r\nif (mdev->release)\r\nmdev->release(mdev);\r\n}\r\nstatic ssize_t media_read(struct file *filp, char __user *buf,\r\nsize_t sz, loff_t *off)\r\n{\r\nstruct media_devnode *mdev = media_devnode_data(filp);\r\nif (!mdev->fops->read)\r\nreturn -EINVAL;\r\nif (!media_devnode_is_registered(mdev))\r\nreturn -EIO;\r\nreturn mdev->fops->read(filp, buf, sz, off);\r\n}\r\nstatic ssize_t media_write(struct file *filp, const char __user *buf,\r\nsize_t sz, loff_t *off)\r\n{\r\nstruct media_devnode *mdev = media_devnode_data(filp);\r\nif (!mdev->fops->write)\r\nreturn -EINVAL;\r\nif (!media_devnode_is_registered(mdev))\r\nreturn -EIO;\r\nreturn mdev->fops->write(filp, buf, sz, off);\r\n}\r\nstatic unsigned int media_poll(struct file *filp,\r\nstruct poll_table_struct *poll)\r\n{\r\nstruct media_devnode *mdev = media_devnode_data(filp);\r\nif (!media_devnode_is_registered(mdev))\r\nreturn POLLERR | POLLHUP;\r\nif (!mdev->fops->poll)\r\nreturn DEFAULT_POLLMASK;\r\nreturn mdev->fops->poll(filp, poll);\r\n}\r\nstatic long\r\n__media_ioctl(struct file *filp, unsigned int cmd, unsigned long arg,\r\nlong (*ioctl_func)(struct file *filp, unsigned int cmd,\r\nunsigned long arg))\r\n{\r\nstruct media_devnode *mdev = media_devnode_data(filp);\r\nif (!ioctl_func)\r\nreturn -ENOTTY;\r\nif (!media_devnode_is_registered(mdev))\r\nreturn -EIO;\r\nreturn ioctl_func(filp, cmd, arg);\r\n}\r\nstatic long media_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct media_devnode *mdev = media_devnode_data(filp);\r\nreturn __media_ioctl(filp, cmd, arg, mdev->fops->ioctl);\r\n}\r\nstatic long media_compat_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct media_devnode *mdev = media_devnode_data(filp);\r\nreturn __media_ioctl(filp, cmd, arg, mdev->fops->compat_ioctl);\r\n}\r\nstatic int media_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct media_devnode *mdev;\r\nint ret;\r\nmutex_lock(&media_devnode_lock);\r\nmdev = container_of(inode->i_cdev, struct media_devnode, cdev);\r\nif (!media_devnode_is_registered(mdev)) {\r\nmutex_unlock(&media_devnode_lock);\r\nreturn -ENXIO;\r\n}\r\nget_device(&mdev->dev);\r\nmutex_unlock(&media_devnode_lock);\r\nfilp->private_data = mdev;\r\nif (mdev->fops->open) {\r\nret = mdev->fops->open(filp);\r\nif (ret) {\r\nput_device(&mdev->dev);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int media_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct media_devnode *mdev = media_devnode_data(filp);\r\nint ret = 0;\r\nif (mdev->fops->release)\r\nmdev->fops->release(filp);\r\nput_device(&mdev->dev);\r\nfilp->private_data = NULL;\r\nreturn ret;\r\n}\r\nint __must_check media_devnode_register(struct media_devnode *mdev,\r\nstruct module *owner)\r\n{\r\nint minor;\r\nint ret;\r\nmutex_lock(&media_devnode_lock);\r\nminor = find_next_zero_bit(media_devnode_nums, MEDIA_NUM_DEVICES, 0);\r\nif (minor == MEDIA_NUM_DEVICES) {\r\nmutex_unlock(&media_devnode_lock);\r\npr_err("could not get a free minor\n");\r\nreturn -ENFILE;\r\n}\r\nset_bit(minor, media_devnode_nums);\r\nmutex_unlock(&media_devnode_lock);\r\nmdev->minor = minor;\r\ncdev_init(&mdev->cdev, &media_devnode_fops);\r\nmdev->cdev.owner = owner;\r\nret = cdev_add(&mdev->cdev, MKDEV(MAJOR(media_dev_t), mdev->minor), 1);\r\nif (ret < 0) {\r\npr_err("%s: cdev_add failed\n", __func__);\r\ngoto error;\r\n}\r\nmdev->dev.bus = &media_bus_type;\r\nmdev->dev.devt = MKDEV(MAJOR(media_dev_t), mdev->minor);\r\nmdev->dev.release = media_devnode_release;\r\nif (mdev->parent)\r\nmdev->dev.parent = mdev->parent;\r\ndev_set_name(&mdev->dev, "media%d", mdev->minor);\r\nret = device_register(&mdev->dev);\r\nif (ret < 0) {\r\npr_err("%s: device_register failed\n", __func__);\r\ngoto error;\r\n}\r\nset_bit(MEDIA_FLAG_REGISTERED, &mdev->flags);\r\nreturn 0;\r\nerror:\r\ncdev_del(&mdev->cdev);\r\nclear_bit(mdev->minor, media_devnode_nums);\r\nreturn ret;\r\n}\r\nvoid media_devnode_unregister(struct media_devnode *mdev)\r\n{\r\nif (!media_devnode_is_registered(mdev))\r\nreturn;\r\nmutex_lock(&media_devnode_lock);\r\nclear_bit(MEDIA_FLAG_REGISTERED, &mdev->flags);\r\nmutex_unlock(&media_devnode_lock);\r\ndevice_unregister(&mdev->dev);\r\n}\r\nstatic int __init media_devnode_init(void)\r\n{\r\nint ret;\r\npr_info("Linux media interface: v0.10\n");\r\nret = alloc_chrdev_region(&media_dev_t, 0, MEDIA_NUM_DEVICES,\r\nMEDIA_NAME);\r\nif (ret < 0) {\r\npr_warn("unable to allocate major\n");\r\nreturn ret;\r\n}\r\nret = bus_register(&media_bus_type);\r\nif (ret < 0) {\r\nunregister_chrdev_region(media_dev_t, MEDIA_NUM_DEVICES);\r\npr_warn("bus_register failed\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit media_devnode_exit(void)\r\n{\r\nbus_unregister(&media_bus_type);\r\nunregister_chrdev_region(media_dev_t, MEDIA_NUM_DEVICES);\r\n}
