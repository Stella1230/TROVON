static u32 htohl(u32 in, int swap)\r\n{\r\nreturn swap ? swab32(in) : in;\r\n}\r\nstatic void subscr_send_event(struct tipc_subscription *sub, u32 found_lower,\r\nu32 found_upper, u32 event, u32 port_ref,\r\nu32 node)\r\n{\r\nstruct tipc_subscriber *subscriber = sub->subscriber;\r\nstruct kvec msg_sect;\r\nmsg_sect.iov_base = (void *)&sub->evt;\r\nmsg_sect.iov_len = sizeof(struct tipc_event);\r\nsub->evt.event = htohl(event, sub->swap);\r\nsub->evt.found_lower = htohl(found_lower, sub->swap);\r\nsub->evt.found_upper = htohl(found_upper, sub->swap);\r\nsub->evt.port.ref = htohl(port_ref, sub->swap);\r\nsub->evt.port.node = htohl(node, sub->swap);\r\ntipc_conn_sendmsg(&topsrv, subscriber->conid, NULL, msg_sect.iov_base,\r\nmsg_sect.iov_len);\r\n}\r\nint tipc_subscr_overlap(struct tipc_subscription *sub, u32 found_lower,\r\nu32 found_upper)\r\n{\r\nif (found_lower < sub->seq.lower)\r\nfound_lower = sub->seq.lower;\r\nif (found_upper > sub->seq.upper)\r\nfound_upper = sub->seq.upper;\r\nif (found_lower > found_upper)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nvoid tipc_subscr_report_overlap(struct tipc_subscription *sub, u32 found_lower,\r\nu32 found_upper, u32 event, u32 port_ref,\r\nu32 node, int must)\r\n{\r\nif (!tipc_subscr_overlap(sub, found_lower, found_upper))\r\nreturn;\r\nif (!must && !(sub->filter & TIPC_SUB_PORTS))\r\nreturn;\r\nsubscr_send_event(sub, found_lower, found_upper, event, port_ref, node);\r\n}\r\nstatic void subscr_timeout(struct tipc_subscription *sub)\r\n{\r\nstruct tipc_subscriber *subscriber = sub->subscriber;\r\nspin_lock_bh(&subscriber->lock);\r\nif (sub->timeout == TIPC_WAIT_FOREVER) {\r\nspin_unlock_bh(&subscriber->lock);\r\nreturn;\r\n}\r\ntipc_nametbl_unsubscribe(sub);\r\nlist_del(&sub->subscription_list);\r\nspin_unlock_bh(&subscriber->lock);\r\nsubscr_send_event(sub, sub->evt.s.seq.lower, sub->evt.s.seq.upper,\r\nTIPC_SUBSCR_TIMEOUT, 0, 0);\r\nk_term_timer(&sub->timer);\r\nkfree(sub);\r\natomic_dec(&subscription_count);\r\n}\r\nstatic void subscr_del(struct tipc_subscription *sub)\r\n{\r\ntipc_nametbl_unsubscribe(sub);\r\nlist_del(&sub->subscription_list);\r\nkfree(sub);\r\natomic_dec(&subscription_count);\r\n}\r\nstatic void subscr_terminate(struct tipc_subscriber *subscriber)\r\n{\r\ntipc_conn_terminate(&topsrv, subscriber->conid);\r\n}\r\nstatic void subscr_release(struct tipc_subscriber *subscriber)\r\n{\r\nstruct tipc_subscription *sub;\r\nstruct tipc_subscription *sub_temp;\r\nspin_lock_bh(&subscriber->lock);\r\nlist_for_each_entry_safe(sub, sub_temp, &subscriber->subscription_list,\r\nsubscription_list) {\r\nif (sub->timeout != TIPC_WAIT_FOREVER) {\r\nspin_unlock_bh(&subscriber->lock);\r\nk_cancel_timer(&sub->timer);\r\nk_term_timer(&sub->timer);\r\nspin_lock_bh(&subscriber->lock);\r\n}\r\nsubscr_del(sub);\r\n}\r\nspin_unlock_bh(&subscriber->lock);\r\nkfree(subscriber);\r\n}\r\nstatic void subscr_cancel(struct tipc_subscr *s,\r\nstruct tipc_subscriber *subscriber)\r\n{\r\nstruct tipc_subscription *sub;\r\nstruct tipc_subscription *sub_temp;\r\nint found = 0;\r\nlist_for_each_entry_safe(sub, sub_temp, &subscriber->subscription_list,\r\nsubscription_list) {\r\nif (!memcmp(s, &sub->evt.s, sizeof(struct tipc_subscr))) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nreturn;\r\nif (sub->timeout != TIPC_WAIT_FOREVER) {\r\nsub->timeout = TIPC_WAIT_FOREVER;\r\nspin_unlock_bh(&subscriber->lock);\r\nk_cancel_timer(&sub->timer);\r\nk_term_timer(&sub->timer);\r\nspin_lock_bh(&subscriber->lock);\r\n}\r\nsubscr_del(sub);\r\n}\r\nstatic int subscr_subscribe(struct tipc_subscr *s,\r\nstruct tipc_subscriber *subscriber,\r\nstruct tipc_subscription **sub_p) {\r\nstruct tipc_subscription *sub;\r\nint swap;\r\nswap = !(s->filter & (TIPC_SUB_PORTS | TIPC_SUB_SERVICE));\r\nif (s->filter & htohl(TIPC_SUB_CANCEL, swap)) {\r\ns->filter &= ~htohl(TIPC_SUB_CANCEL, swap);\r\nsubscr_cancel(s, subscriber);\r\nreturn 0;\r\n}\r\nif (atomic_read(&subscription_count) >= TIPC_MAX_SUBSCRIPTIONS) {\r\npr_warn("Subscription rejected, limit reached (%u)\n",\r\nTIPC_MAX_SUBSCRIPTIONS);\r\nreturn -EINVAL;\r\n}\r\nsub = kmalloc(sizeof(*sub), GFP_ATOMIC);\r\nif (!sub) {\r\npr_warn("Subscription rejected, no memory\n");\r\nreturn -ENOMEM;\r\n}\r\nsub->seq.type = htohl(s->seq.type, swap);\r\nsub->seq.lower = htohl(s->seq.lower, swap);\r\nsub->seq.upper = htohl(s->seq.upper, swap);\r\nsub->timeout = htohl(s->timeout, swap);\r\nsub->filter = htohl(s->filter, swap);\r\nif ((!(sub->filter & TIPC_SUB_PORTS) ==\r\n!(sub->filter & TIPC_SUB_SERVICE)) ||\r\n(sub->seq.lower > sub->seq.upper)) {\r\npr_warn("Subscription rejected, illegal request\n");\r\nkfree(sub);\r\nreturn -EINVAL;\r\n}\r\nINIT_LIST_HEAD(&sub->nameseq_list);\r\nlist_add(&sub->subscription_list, &subscriber->subscription_list);\r\nsub->subscriber = subscriber;\r\nsub->swap = swap;\r\nmemcpy(&sub->evt.s, s, sizeof(struct tipc_subscr));\r\natomic_inc(&subscription_count);\r\nif (sub->timeout != TIPC_WAIT_FOREVER) {\r\nk_init_timer(&sub->timer,\r\n(Handler)subscr_timeout, (unsigned long)sub);\r\nk_start_timer(&sub->timer, sub->timeout);\r\n}\r\n*sub_p = sub;\r\nreturn 0;\r\n}\r\nstatic void subscr_conn_shutdown_event(int conid, void *usr_data)\r\n{\r\nsubscr_release((struct tipc_subscriber *)usr_data);\r\n}\r\nstatic void subscr_conn_msg_event(int conid, struct sockaddr_tipc *addr,\r\nvoid *usr_data, void *buf, size_t len)\r\n{\r\nstruct tipc_subscriber *subscriber = usr_data;\r\nstruct tipc_subscription *sub = NULL;\r\nspin_lock_bh(&subscriber->lock);\r\nif (subscr_subscribe((struct tipc_subscr *)buf, subscriber, &sub) < 0) {\r\nspin_unlock_bh(&subscriber->lock);\r\nsubscr_terminate(subscriber);\r\nreturn;\r\n}\r\nif (sub)\r\ntipc_nametbl_subscribe(sub);\r\nspin_unlock_bh(&subscriber->lock);\r\n}\r\nstatic void *subscr_named_msg_event(int conid)\r\n{\r\nstruct tipc_subscriber *subscriber;\r\nsubscriber = kzalloc(sizeof(struct tipc_subscriber), GFP_ATOMIC);\r\nif (subscriber == NULL) {\r\npr_warn("Subscriber rejected, no memory\n");\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&subscriber->subscription_list);\r\nsubscriber->conid = conid;\r\nspin_lock_init(&subscriber->lock);\r\nreturn (void *)subscriber;\r\n}\r\nint tipc_subscr_start(void)\r\n{\r\nreturn tipc_server_start(&topsrv);\r\n}\r\nvoid tipc_subscr_stop(void)\r\n{\r\ntipc_server_stop(&topsrv);\r\n}
