static int qlcnic_83xx_enable_vnic_mode(struct qlcnic_adapter *adapter, int lock)\r\n{\r\nif (lock) {\r\nif (qlcnic_83xx_lock_driver(adapter))\r\nreturn -EBUSY;\r\n}\r\nQLCWRX(adapter->ahw, QLC_83XX_VNIC_STATE, QLCNIC_DEV_NPAR_OPER);\r\nif (lock)\r\nqlcnic_83xx_unlock_driver(adapter);\r\nreturn 0;\r\n}\r\nint qlcnic_83xx_disable_vnic_mode(struct qlcnic_adapter *adapter, int lock)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nif (lock) {\r\nif (qlcnic_83xx_lock_driver(adapter))\r\nreturn -EBUSY;\r\n}\r\nQLCWRX(adapter->ahw, QLC_83XX_VNIC_STATE, QLCNIC_DEV_NPAR_NON_OPER);\r\nahw->idc.vnic_state = QLCNIC_DEV_NPAR_NON_OPER;\r\nif (lock)\r\nqlcnic_83xx_unlock_driver(adapter);\r\nreturn 0;\r\n}\r\nint qlcnic_83xx_set_vnic_opmode(struct qlcnic_adapter *adapter)\r\n{\r\nu8 id;\r\nint ret = -EBUSY;\r\nu32 data = QLCNIC_MGMT_FUNC;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nif (qlcnic_83xx_lock_driver(adapter))\r\nreturn ret;\r\nid = ahw->pci_func;\r\ndata = QLCRDX(adapter->ahw, QLC_83XX_DRV_OP_MODE);\r\ndata = (data & ~QLC_83XX_SET_FUNC_OPMODE(0x3, id)) |\r\nQLC_83XX_SET_FUNC_OPMODE(QLCNIC_MGMT_FUNC, id);\r\nQLCWRX(adapter->ahw, QLC_83XX_DRV_OP_MODE, data);\r\nqlcnic_83xx_unlock_driver(adapter);\r\nreturn 0;\r\n}\r\nstatic void\r\nqlcnic_83xx_config_vnic_buff_descriptors(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nif (ahw->port_type == QLCNIC_XGBE) {\r\nadapter->num_rxd = DEFAULT_RCV_DESCRIPTORS_VF;\r\nadapter->max_rxd = MAX_RCV_DESCRIPTORS_VF;\r\nadapter->num_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_10G;\r\nadapter->max_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_10G;\r\n} else if (ahw->port_type == QLCNIC_GBE) {\r\nadapter->num_rxd = DEFAULT_RCV_DESCRIPTORS_1G;\r\nadapter->num_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_1G;\r\nadapter->max_jumbo_rxd = MAX_JUMBO_RCV_DESCRIPTORS_1G;\r\nadapter->max_rxd = MAX_RCV_DESCRIPTORS_1G;\r\n}\r\nadapter->num_txd = MAX_CMD_DESCRIPTORS;\r\nadapter->max_rds_rings = MAX_RDS_RINGS;\r\n}\r\nstatic int qlcnic_83xx_init_mgmt_vnic(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct device *dev = &adapter->pdev->dev;\r\nstruct qlcnic_npar_info *npar;\r\nint i, err = -EIO;\r\nqlcnic_83xx_get_minidump_template(adapter);\r\nif (!(adapter->flags & QLCNIC_ADAPTER_INITIALIZED)) {\r\nif (qlcnic_init_pci_info(adapter))\r\nreturn err;\r\nnpar = adapter->npars;\r\nfor (i = 0; i < ahw->total_nic_func; i++, npar++) {\r\ndev_info(dev, "id:%d active:%d type:%d port:%d min_bw:%d max_bw:%d mac_addr:%pM\n",\r\nnpar->pci_func, npar->active, npar->type,\r\nnpar->phy_port, npar->min_bw, npar->max_bw,\r\nnpar->mac);\r\n}\r\ndev_info(dev, "Max functions = %d, active functions = %d\n",\r\nahw->max_pci_func, ahw->total_nic_func);\r\nif (qlcnic_83xx_set_vnic_opmode(adapter))\r\nreturn err;\r\nif (qlcnic_set_default_offload_settings(adapter))\r\nreturn err;\r\n} else {\r\nif (qlcnic_reset_npar_config(adapter))\r\nreturn err;\r\n}\r\nif (qlcnic_83xx_get_port_info(adapter))\r\nreturn err;\r\nqlcnic_83xx_config_vnic_buff_descriptors(adapter);\r\nahw->msix_supported = qlcnic_use_msi_x ? 1 : 0;\r\nadapter->flags |= QLCNIC_ADAPTER_INITIALIZED;\r\nqlcnic_83xx_enable_vnic_mode(adapter, 1);\r\ndev_info(dev, "HAL Version: %d, Management function\n",\r\nahw->fw_hal_version);\r\nreturn 0;\r\n}\r\nstatic int qlcnic_83xx_init_privileged_vnic(struct qlcnic_adapter *adapter)\r\n{\r\nint err = -EIO;\r\nqlcnic_83xx_get_minidump_template(adapter);\r\nif (qlcnic_83xx_get_port_info(adapter))\r\nreturn err;\r\nqlcnic_83xx_config_vnic_buff_descriptors(adapter);\r\nadapter->ahw->msix_supported = !!qlcnic_use_msi_x;\r\nadapter->flags |= QLCNIC_ADAPTER_INITIALIZED;\r\ndev_info(&adapter->pdev->dev,\r\n"HAL Version: %d, Privileged function\n",\r\nadapter->ahw->fw_hal_version);\r\nreturn 0;\r\n}\r\nstatic int qlcnic_83xx_init_non_privileged_vnic(struct qlcnic_adapter *adapter)\r\n{\r\nint err = -EIO;\r\nqlcnic_83xx_get_fw_version(adapter);\r\nif (qlcnic_set_eswitch_port_config(adapter))\r\nreturn err;\r\nif (qlcnic_83xx_get_port_info(adapter))\r\nreturn err;\r\nqlcnic_83xx_config_vnic_buff_descriptors(adapter);\r\nadapter->ahw->msix_supported = !!qlcnic_use_msi_x;\r\nadapter->flags |= QLCNIC_ADAPTER_INITIALIZED;\r\ndev_info(&adapter->pdev->dev, "HAL Version: %d, Virtual function\n",\r\nadapter->ahw->fw_hal_version);\r\nreturn 0;\r\n}\r\nint qlcnic_83xx_config_vnic_opmode(struct qlcnic_adapter *adapter)\r\n{\r\nu32 op_mode, priv_level;\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlcnic_nic_template *nic_ops = adapter->nic_ops;\r\nqlcnic_get_func_no(adapter);\r\nop_mode = QLCRDX(adapter->ahw, QLC_83XX_DRV_OP_MODE);\r\nif (op_mode == QLC_83XX_DEFAULT_OPMODE)\r\npriv_level = QLCNIC_MGMT_FUNC;\r\nelse\r\npriv_level = QLC_83XX_GET_FUNC_PRIVILEGE(op_mode,\r\nahw->pci_func);\r\nswitch (priv_level) {\r\ncase QLCNIC_NON_PRIV_FUNC:\r\nahw->op_mode = QLCNIC_NON_PRIV_FUNC;\r\nahw->idc.state_entry = qlcnic_83xx_idc_ready_state_entry;\r\nnic_ops->init_driver = qlcnic_83xx_init_non_privileged_vnic;\r\nbreak;\r\ncase QLCNIC_PRIV_FUNC:\r\nahw->op_mode = QLCNIC_PRIV_FUNC;\r\nahw->idc.state_entry = qlcnic_83xx_idc_vnic_pf_entry;\r\nnic_ops->init_driver = qlcnic_83xx_init_privileged_vnic;\r\nbreak;\r\ncase QLCNIC_MGMT_FUNC:\r\nahw->op_mode = QLCNIC_MGMT_FUNC;\r\nahw->idc.state_entry = qlcnic_83xx_idc_ready_state_entry;\r\nnic_ops->init_driver = qlcnic_83xx_init_mgmt_vnic;\r\nbreak;\r\ndefault:\r\ndev_err(&adapter->pdev->dev, "Invalid Virtual NIC opmode\n");\r\nreturn -EIO;\r\n}\r\nif (ahw->capabilities & QLC_83XX_ESWITCH_CAPABILITY) {\r\nadapter->flags |= QLCNIC_ESWITCH_ENABLED;\r\nif (adapter->drv_mac_learn)\r\nadapter->rx_mac_learn = true;\r\n} else {\r\nadapter->flags &= ~QLCNIC_ESWITCH_ENABLED;\r\nadapter->rx_mac_learn = false;\r\n}\r\nahw->idc.vnic_state = QLCNIC_DEV_NPAR_NON_OPER;\r\nahw->idc.vnic_wait_limit = QLCNIC_DEV_NPAR_OPER_TIMEO;\r\nreturn 0;\r\n}\r\nint qlcnic_83xx_check_vnic_state(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlc_83xx_idc *idc = &ahw->idc;\r\nu32 state;\r\nstate = QLCRDX(ahw, QLC_83XX_VNIC_STATE);\r\nwhile (state != QLCNIC_DEV_NPAR_OPER && idc->vnic_wait_limit--) {\r\nmsleep(1000);\r\nstate = QLCRDX(ahw, QLC_83XX_VNIC_STATE);\r\n}\r\nif (!idc->vnic_wait_limit) {\r\ndev_err(&adapter->pdev->dev,\r\n"vNIC mode not operational, state check timed out.\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint qlcnic_83xx_set_port_eswitch_status(struct qlcnic_adapter *adapter,\r\nint func, int *port_id)\r\n{\r\nstruct qlcnic_info nic_info;\r\nint err = 0;\r\nmemset(&nic_info, 0, sizeof(struct qlcnic_info));\r\nerr = qlcnic_get_nic_info(adapter, &nic_info, func);\r\nif (err)\r\nreturn err;\r\nif (nic_info.capabilities & QLC_83XX_ESWITCH_CAPABILITY)\r\n*port_id = nic_info.phys_port;\r\nelse\r\nerr = -EIO;\r\nif (!err)\r\nadapter->eswitch[*port_id].flags |= QLCNIC_SWITCH_ENABLE;\r\nreturn err;\r\n}
