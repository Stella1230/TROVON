static inline void vf610_adc_cfg_init(struct vf610_adc *info)\r\n{\r\ninfo->adc_feature.clk_sel = VF610_ADCIOC_BUSCLK_SET;\r\ninfo->adc_feature.vol_ref = VF610_ADCIOC_VR_VREF_SET;\r\ninfo->adc_feature.calibration = true;\r\ninfo->adc_feature.ovwren = true;\r\ninfo->adc_feature.clk_div = 1;\r\ninfo->adc_feature.res_mode = 12;\r\ninfo->adc_feature.sample_rate = 1;\r\ninfo->adc_feature.lpm = true;\r\n}\r\nstatic void vf610_adc_cfg_post_set(struct vf610_adc *info)\r\n{\r\nstruct vf610_adc_feature *adc_feature = &info->adc_feature;\r\nint cfg_data = 0;\r\nint gc_data = 0;\r\nswitch (adc_feature->clk_sel) {\r\ncase VF610_ADCIOC_ALTCLK_SET:\r\ncfg_data |= VF610_ADC_ALTCLK_SEL;\r\nbreak;\r\ncase VF610_ADCIOC_ADACK_SET:\r\ncfg_data |= VF610_ADC_ADACK_SEL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ncfg_data |= VF610_ADC_ADLPC_EN;\r\ncfg_data |= VF610_ADC_ADHSC_EN;\r\nswitch (adc_feature->vol_ref) {\r\ncase VF610_ADCIOC_VR_VREF_SET:\r\nbreak;\r\ncase VF610_ADCIOC_VR_VALT_SET:\r\ncfg_data |= VF610_ADC_REFSEL_VALT;\r\nbreak;\r\ncase VF610_ADCIOC_VR_VBG_SET:\r\ncfg_data |= VF610_ADC_REFSEL_VBG;\r\nbreak;\r\ndefault:\r\ndev_err(info->dev, "error voltage reference\n");\r\n}\r\nif (adc_feature->ovwren)\r\ncfg_data |= VF610_ADC_OVWREN;\r\nwritel(cfg_data, info->regs + VF610_REG_ADC_CFG);\r\nwritel(gc_data, info->regs + VF610_REG_ADC_GC);\r\n}\r\nstatic void vf610_adc_calibration(struct vf610_adc *info)\r\n{\r\nint adc_gc, hc_cfg;\r\nint timeout;\r\nif (!info->adc_feature.calibration)\r\nreturn;\r\nhc_cfg = VF610_ADC_AIEN | VF610_ADC_CONV_DISABLE;\r\nwritel(hc_cfg, info->regs + VF610_REG_ADC_HC0);\r\nadc_gc = readl(info->regs + VF610_REG_ADC_GC);\r\nwritel(adc_gc | VF610_ADC_CAL, info->regs + VF610_REG_ADC_GC);\r\ntimeout = wait_for_completion_timeout\r\n(&info->completion, VF610_ADC_TIMEOUT);\r\nif (timeout == 0)\r\ndev_err(info->dev, "Timeout for adc calibration\n");\r\nadc_gc = readl(info->regs + VF610_REG_ADC_GS);\r\nif (adc_gc & VF610_ADC_CALF)\r\ndev_err(info->dev, "ADC calibration failed\n");\r\ninfo->adc_feature.calibration = false;\r\n}\r\nstatic void vf610_adc_cfg_set(struct vf610_adc *info)\r\n{\r\nstruct vf610_adc_feature *adc_feature = &(info->adc_feature);\r\nint cfg_data;\r\ncfg_data = readl(info->regs + VF610_REG_ADC_CFG);\r\ncfg_data &= ~VF610_ADC_ADLPC_EN;\r\nif (adc_feature->lpm)\r\ncfg_data |= VF610_ADC_ADLPC_EN;\r\ncfg_data &= ~VF610_ADC_ADHSC_EN;\r\nwritel(cfg_data, info->regs + VF610_REG_ADC_CFG);\r\n}\r\nstatic void vf610_adc_sample_set(struct vf610_adc *info)\r\n{\r\nstruct vf610_adc_feature *adc_feature = &(info->adc_feature);\r\nint cfg_data, gc_data;\r\ncfg_data = readl(info->regs + VF610_REG_ADC_CFG);\r\ngc_data = readl(info->regs + VF610_REG_ADC_GC);\r\ncfg_data &= ~VF610_ADC_MODE_MASK;\r\nswitch (adc_feature->res_mode) {\r\ncase 8:\r\ncfg_data |= VF610_ADC_MODE_BIT8;\r\nbreak;\r\ncase 10:\r\ncfg_data |= VF610_ADC_MODE_BIT10;\r\nbreak;\r\ncase 12:\r\ncfg_data |= VF610_ADC_MODE_BIT12;\r\nbreak;\r\ndefault:\r\ndev_err(info->dev, "error resolution mode\n");\r\nbreak;\r\n}\r\ncfg_data &= ~(VF610_ADC_CLK_MASK | VF610_ADC_ADCCLK_MASK);\r\nswitch (adc_feature->clk_div) {\r\ncase 1:\r\nbreak;\r\ncase 2:\r\ncfg_data |= VF610_ADC_CLK_DIV2;\r\nbreak;\r\ncase 4:\r\ncfg_data |= VF610_ADC_CLK_DIV4;\r\nbreak;\r\ncase 8:\r\ncfg_data |= VF610_ADC_CLK_DIV8;\r\nbreak;\r\ncase 16:\r\nswitch (adc_feature->clk_sel) {\r\ncase VF610_ADCIOC_BUSCLK_SET:\r\ncfg_data |= VF610_ADC_BUSCLK2_SEL | VF610_ADC_CLK_DIV8;\r\nbreak;\r\ndefault:\r\ndev_err(info->dev, "error clk divider\n");\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncfg_data &= ~(VF610_ADC_ADLSMP_LONG | VF610_ADC_ADSTS_MASK);\r\ncfg_data &= ~VF610_ADC_AVGS_MASK;\r\ngc_data &= ~VF610_ADC_AVGEN;\r\nswitch (adc_feature->sample_rate) {\r\ncase VF610_ADC_SAMPLE_1:\r\nbreak;\r\ncase VF610_ADC_SAMPLE_4:\r\ngc_data |= VF610_ADC_AVGEN;\r\nbreak;\r\ncase VF610_ADC_SAMPLE_8:\r\ngc_data |= VF610_ADC_AVGEN;\r\ncfg_data |= VF610_ADC_AVGS_8;\r\nbreak;\r\ncase VF610_ADC_SAMPLE_16:\r\ngc_data |= VF610_ADC_AVGEN;\r\ncfg_data |= VF610_ADC_AVGS_16;\r\nbreak;\r\ncase VF610_ADC_SAMPLE_32:\r\ngc_data |= VF610_ADC_AVGEN;\r\ncfg_data |= VF610_ADC_AVGS_32;\r\nbreak;\r\ndefault:\r\ndev_err(info->dev,\r\n"error hardware sample average select\n");\r\n}\r\nwritel(cfg_data, info->regs + VF610_REG_ADC_CFG);\r\nwritel(gc_data, info->regs + VF610_REG_ADC_GC);\r\n}\r\nstatic void vf610_adc_hw_init(struct vf610_adc *info)\r\n{\r\nvf610_adc_cfg_post_set(info);\r\nvf610_adc_sample_set(info);\r\nvf610_adc_calibration(info);\r\nvf610_adc_cfg_set(info);\r\n}\r\nstatic int vf610_adc_read_data(struct vf610_adc *info)\r\n{\r\nint result;\r\nresult = readl(info->regs + VF610_REG_ADC_R0);\r\nswitch (info->adc_feature.res_mode) {\r\ncase 8:\r\nresult &= 0xFF;\r\nbreak;\r\ncase 10:\r\nresult &= 0x3FF;\r\nbreak;\r\ncase 12:\r\nresult &= 0xFFF;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic irqreturn_t vf610_adc_isr(int irq, void *dev_id)\r\n{\r\nstruct vf610_adc *info = (struct vf610_adc *)dev_id;\r\nint coco;\r\ncoco = readl(info->regs + VF610_REG_ADC_HS);\r\nif (coco & VF610_ADC_HS_COCO0) {\r\ninfo->value = vf610_adc_read_data(info);\r\ncomplete(&info->completion);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int vf610_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong mask)\r\n{\r\nstruct vf610_adc *info = iio_priv(indio_dev);\r\nunsigned int hc_cfg;\r\nlong ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nmutex_lock(&indio_dev->mlock);\r\nreinit_completion(&info->completion);\r\nhc_cfg = VF610_ADC_ADCHC(chan->channel);\r\nhc_cfg |= VF610_ADC_AIEN;\r\nwritel(hc_cfg, info->regs + VF610_REG_ADC_HC0);\r\nret = wait_for_completion_interruptible_timeout\r\n(&info->completion, VF610_ADC_TIMEOUT);\r\nif (ret == 0) {\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (ret < 0) {\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\n*val = info->value;\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = info->vref_uv / 1000;\r\n*val2 = info->adc_feature.res_mode;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\n*val = vf610_sample_freq_avail[info->adc_feature.sample_rate];\r\n*val2 = 0;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vf610_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val,\r\nint val2,\r\nlong mask)\r\n{\r\nstruct vf610_adc *info = iio_priv(indio_dev);\r\nint i;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nfor (i = 0;\r\ni < ARRAY_SIZE(vf610_sample_freq_avail);\r\ni++)\r\nif (val == vf610_sample_freq_avail[i]) {\r\ninfo->adc_feature.sample_rate = i;\r\nvf610_adc_sample_set(info);\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vf610_adc_reg_access(struct iio_dev *indio_dev,\r\nunsigned reg, unsigned writeval,\r\nunsigned *readval)\r\n{\r\nstruct vf610_adc *info = iio_priv(indio_dev);\r\nif ((readval == NULL) ||\r\n(!(reg % 4) || (reg > VF610_REG_ADC_PCTL)))\r\nreturn -EINVAL;\r\n*readval = readl(info->regs + reg);\r\nreturn 0;\r\n}\r\nstatic int vf610_adc_probe(struct platform_device *pdev)\r\n{\r\nstruct vf610_adc *info;\r\nstruct iio_dev *indio_dev;\r\nstruct resource *mem;\r\nint irq;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(struct vf610_adc));\r\nif (!indio_dev) {\r\ndev_err(&pdev->dev, "Failed allocating iio device\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo = iio_priv(indio_dev);\r\ninfo->dev = &pdev->dev;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ninfo->regs = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(info->regs))\r\nreturn PTR_ERR(info->regs);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0) {\r\ndev_err(&pdev->dev, "no irq resource?\n");\r\nreturn -EINVAL;\r\n}\r\nret = devm_request_irq(info->dev, irq,\r\nvf610_adc_isr, 0,\r\ndev_name(&pdev->dev), info);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed requesting irq, irq = %d\n", irq);\r\nreturn ret;\r\n}\r\ninfo->clk = devm_clk_get(&pdev->dev, "adc");\r\nif (IS_ERR(info->clk)) {\r\ndev_err(&pdev->dev, "failed getting clock, err = %ld\n",\r\nPTR_ERR(info->clk));\r\nret = PTR_ERR(info->clk);\r\nreturn ret;\r\n}\r\ninfo->vref = devm_regulator_get(&pdev->dev, "vref");\r\nif (IS_ERR(info->vref))\r\nreturn PTR_ERR(info->vref);\r\nret = regulator_enable(info->vref);\r\nif (ret)\r\nreturn ret;\r\ninfo->vref_uv = regulator_get_voltage(info->vref);\r\nplatform_set_drvdata(pdev, indio_dev);\r\ninit_completion(&info->completion);\r\nindio_dev->name = dev_name(&pdev->dev);\r\nindio_dev->dev.parent = &pdev->dev;\r\nindio_dev->dev.of_node = pdev->dev.of_node;\r\nindio_dev->info = &vf610_adc_iio_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = vf610_adc_iio_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(vf610_adc_iio_channels);\r\nret = clk_prepare_enable(info->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Could not prepare or enable the clock.\n");\r\ngoto error_adc_clk_enable;\r\n}\r\nvf610_adc_cfg_init(info);\r\nvf610_adc_hw_init(info);\r\nret = iio_device_register(indio_dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Couldn't register the device.\n");\r\ngoto error_iio_device_register;\r\n}\r\nreturn 0;\r\nerror_iio_device_register:\r\nclk_disable_unprepare(info->clk);\r\nerror_adc_clk_enable:\r\nregulator_disable(info->vref);\r\nreturn ret;\r\n}\r\nstatic int vf610_adc_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\nstruct vf610_adc *info = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nregulator_disable(info->vref);\r\nclk_disable_unprepare(info->clk);\r\nreturn 0;\r\n}\r\nstatic int vf610_adc_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct vf610_adc *info = iio_priv(indio_dev);\r\nint hc_cfg;\r\nhc_cfg = readl(info->regs + VF610_REG_ADC_HC0);\r\nhc_cfg |= VF610_ADC_CONV_DISABLE;\r\nwritel(hc_cfg, info->regs + VF610_REG_ADC_HC0);\r\nclk_disable_unprepare(info->clk);\r\nregulator_disable(info->vref);\r\nreturn 0;\r\n}\r\nstatic int vf610_adc_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct vf610_adc *info = iio_priv(indio_dev);\r\nint ret;\r\nret = regulator_enable(info->vref);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(info->clk);\r\nif (ret)\r\nreturn ret;\r\nvf610_adc_hw_init(info);\r\nreturn 0;\r\n}
