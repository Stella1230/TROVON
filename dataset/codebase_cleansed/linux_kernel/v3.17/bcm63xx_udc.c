static inline struct bcm63xx_udc *gadget_to_udc(struct usb_gadget *g)\r\n{\r\nreturn container_of(g, struct bcm63xx_udc, gadget);\r\n}\r\nstatic inline struct bcm63xx_ep *our_ep(struct usb_ep *ep)\r\n{\r\nreturn container_of(ep, struct bcm63xx_ep, ep);\r\n}\r\nstatic inline struct bcm63xx_req *our_req(struct usb_request *req)\r\n{\r\nreturn container_of(req, struct bcm63xx_req, req);\r\n}\r\nstatic inline u32 usbd_readl(struct bcm63xx_udc *udc, u32 off)\r\n{\r\nreturn bcm_readl(udc->usbd_regs + off);\r\n}\r\nstatic inline void usbd_writel(struct bcm63xx_udc *udc, u32 val, u32 off)\r\n{\r\nbcm_writel(val, udc->usbd_regs + off);\r\n}\r\nstatic inline u32 usb_dma_readl(struct bcm63xx_udc *udc, u32 off)\r\n{\r\nreturn bcm_readl(udc->iudma_regs + off);\r\n}\r\nstatic inline void usb_dma_writel(struct bcm63xx_udc *udc, u32 val, u32 off)\r\n{\r\nbcm_writel(val, udc->iudma_regs + off);\r\n}\r\nstatic inline u32 usb_dmac_readl(struct bcm63xx_udc *udc, u32 off, int chan)\r\n{\r\nreturn bcm_readl(udc->iudma_regs + IUDMA_DMAC_OFFSET + off +\r\n(ENETDMA_CHAN_WIDTH * chan));\r\n}\r\nstatic inline void usb_dmac_writel(struct bcm63xx_udc *udc, u32 val, u32 off,\r\nint chan)\r\n{\r\nbcm_writel(val, udc->iudma_regs + IUDMA_DMAC_OFFSET + off +\r\n(ENETDMA_CHAN_WIDTH * chan));\r\n}\r\nstatic inline u32 usb_dmas_readl(struct bcm63xx_udc *udc, u32 off, int chan)\r\n{\r\nreturn bcm_readl(udc->iudma_regs + IUDMA_DMAS_OFFSET + off +\r\n(ENETDMA_CHAN_WIDTH * chan));\r\n}\r\nstatic inline void usb_dmas_writel(struct bcm63xx_udc *udc, u32 val, u32 off,\r\nint chan)\r\n{\r\nbcm_writel(val, udc->iudma_regs + IUDMA_DMAS_OFFSET + off +\r\n(ENETDMA_CHAN_WIDTH * chan));\r\n}\r\nstatic inline void set_clocks(struct bcm63xx_udc *udc, bool is_enabled)\r\n{\r\nif (is_enabled) {\r\nclk_enable(udc->usbh_clk);\r\nclk_enable(udc->usbd_clk);\r\nudelay(10);\r\n} else {\r\nclk_disable(udc->usbd_clk);\r\nclk_disable(udc->usbh_clk);\r\n}\r\n}\r\nstatic void bcm63xx_ep_dma_select(struct bcm63xx_udc *udc, int idx)\r\n{\r\nu32 val = usbd_readl(udc, USBD_CONTROL_REG);\r\nval &= ~USBD_CONTROL_INIT_SEL_MASK;\r\nval |= idx << USBD_CONTROL_INIT_SEL_SHIFT;\r\nusbd_writel(udc, val, USBD_CONTROL_REG);\r\n}\r\nstatic void bcm63xx_set_stall(struct bcm63xx_udc *udc, struct bcm63xx_ep *bep,\r\nbool is_stalled)\r\n{\r\nu32 val;\r\nval = USBD_STALL_UPDATE_MASK |\r\n(is_stalled ? USBD_STALL_ENABLE_MASK : 0) |\r\n(bep->ep_num << USBD_STALL_EPNUM_SHIFT);\r\nusbd_writel(udc, val, USBD_STALL_REG);\r\n}\r\nstatic void bcm63xx_fifo_setup(struct bcm63xx_udc *udc)\r\n{\r\nint is_hs = udc->gadget.speed == USB_SPEED_HIGH;\r\nu32 i, val, rx_fifo_slot, tx_fifo_slot;\r\nrx_fifo_slot = tx_fifo_slot = 0;\r\nfor (i = 0; i < BCM63XX_NUM_IUDMA; i += 2) {\r\nconst struct iudma_ch_cfg *rx_cfg = &iudma_defaults[i];\r\nconst struct iudma_ch_cfg *tx_cfg = &iudma_defaults[i + 1];\r\nbcm63xx_ep_dma_select(udc, i >> 1);\r\nval = (rx_fifo_slot << USBD_RXFIFO_CONFIG_START_SHIFT) |\r\n((rx_fifo_slot + rx_cfg->n_fifo_slots - 1) <<\r\nUSBD_RXFIFO_CONFIG_END_SHIFT);\r\nrx_fifo_slot += rx_cfg->n_fifo_slots;\r\nusbd_writel(udc, val, USBD_RXFIFO_CONFIG_REG);\r\nusbd_writel(udc,\r\nis_hs ? rx_cfg->max_pkt_hs : rx_cfg->max_pkt_fs,\r\nUSBD_RXFIFO_EPSIZE_REG);\r\nval = (tx_fifo_slot << USBD_TXFIFO_CONFIG_START_SHIFT) |\r\n((tx_fifo_slot + tx_cfg->n_fifo_slots - 1) <<\r\nUSBD_TXFIFO_CONFIG_END_SHIFT);\r\ntx_fifo_slot += tx_cfg->n_fifo_slots;\r\nusbd_writel(udc, val, USBD_TXFIFO_CONFIG_REG);\r\nusbd_writel(udc,\r\nis_hs ? tx_cfg->max_pkt_hs : tx_cfg->max_pkt_fs,\r\nUSBD_TXFIFO_EPSIZE_REG);\r\nusbd_readl(udc, USBD_TXFIFO_EPSIZE_REG);\r\n}\r\n}\r\nstatic void bcm63xx_fifo_reset_ep(struct bcm63xx_udc *udc, int ep_num)\r\n{\r\nu32 val;\r\nbcm63xx_ep_dma_select(udc, ep_num);\r\nval = usbd_readl(udc, USBD_CONTROL_REG);\r\nval |= USBD_CONTROL_FIFO_RESET_MASK;\r\nusbd_writel(udc, val, USBD_CONTROL_REG);\r\nusbd_readl(udc, USBD_CONTROL_REG);\r\n}\r\nstatic void bcm63xx_fifo_reset(struct bcm63xx_udc *udc)\r\n{\r\nint i;\r\nfor (i = 0; i < BCM63XX_NUM_FIFO_PAIRS; i++)\r\nbcm63xx_fifo_reset_ep(udc, i);\r\n}\r\nstatic void bcm63xx_ep_init(struct bcm63xx_udc *udc)\r\n{\r\nu32 i, val;\r\nfor (i = 0; i < BCM63XX_NUM_IUDMA; i++) {\r\nconst struct iudma_ch_cfg *cfg = &iudma_defaults[i];\r\nif (cfg->ep_num < 0)\r\ncontinue;\r\nbcm63xx_ep_dma_select(udc, cfg->ep_num);\r\nval = (cfg->ep_type << USBD_EPNUM_TYPEMAP_TYPE_SHIFT) |\r\n((i >> 1) << USBD_EPNUM_TYPEMAP_DMA_CH_SHIFT);\r\nusbd_writel(udc, val, USBD_EPNUM_TYPEMAP_REG);\r\n}\r\n}\r\nstatic void bcm63xx_ep_setup(struct bcm63xx_udc *udc)\r\n{\r\nu32 val, i;\r\nusbd_writel(udc, USBD_CSR_SETUPADDR_DEF, USBD_CSR_SETUPADDR_REG);\r\nfor (i = 0; i < BCM63XX_NUM_IUDMA; i++) {\r\nconst struct iudma_ch_cfg *cfg = &iudma_defaults[i];\r\nint max_pkt = udc->gadget.speed == USB_SPEED_HIGH ?\r\ncfg->max_pkt_hs : cfg->max_pkt_fs;\r\nint idx = cfg->ep_num;\r\nudc->iudma[i].max_pkt = max_pkt;\r\nif (idx < 0)\r\ncontinue;\r\nusb_ep_set_maxpacket_limit(&udc->bep[idx].ep, max_pkt);\r\nval = (idx << USBD_CSR_EP_LOG_SHIFT) |\r\n(cfg->dir << USBD_CSR_EP_DIR_SHIFT) |\r\n(cfg->ep_type << USBD_CSR_EP_TYPE_SHIFT) |\r\n(udc->cfg << USBD_CSR_EP_CFG_SHIFT) |\r\n(udc->iface << USBD_CSR_EP_IFACE_SHIFT) |\r\n(udc->alt_iface << USBD_CSR_EP_ALTIFACE_SHIFT) |\r\n(max_pkt << USBD_CSR_EP_MAXPKT_SHIFT);\r\nusbd_writel(udc, val, USBD_CSR_EP_REG(idx));\r\n}\r\n}\r\nstatic void iudma_write(struct bcm63xx_udc *udc, struct iudma_ch *iudma,\r\nstruct bcm63xx_req *breq)\r\n{\r\nint first_bd = 1, last_bd = 0, extra_zero_pkt = 0;\r\nunsigned int bytes_left = breq->req.length - breq->offset;\r\nconst int max_bd_bytes = !irq_coalesce && !iudma->is_tx ?\r\niudma->max_pkt : IUDMA_MAX_FRAGMENT;\r\niudma->n_bds_used = 0;\r\nbreq->bd_bytes = 0;\r\nbreq->iudma = iudma;\r\nif ((bytes_left % iudma->max_pkt == 0) && bytes_left && breq->req.zero)\r\nextra_zero_pkt = 1;\r\ndo {\r\nstruct bcm_enet_desc *d = iudma->write_bd;\r\nu32 dmaflags = 0;\r\nunsigned int n_bytes;\r\nif (d == iudma->end_bd) {\r\ndmaflags |= DMADESC_WRAP_MASK;\r\niudma->write_bd = iudma->bd_ring;\r\n} else {\r\niudma->write_bd++;\r\n}\r\niudma->n_bds_used++;\r\nn_bytes = min_t(int, bytes_left, max_bd_bytes);\r\nif (n_bytes)\r\ndmaflags |= n_bytes << DMADESC_LENGTH_SHIFT;\r\nelse\r\ndmaflags |= (1 << DMADESC_LENGTH_SHIFT) |\r\nDMADESC_USB_ZERO_MASK;\r\ndmaflags |= DMADESC_OWNER_MASK;\r\nif (first_bd) {\r\ndmaflags |= DMADESC_SOP_MASK;\r\nfirst_bd = 0;\r\n}\r\nif (extra_zero_pkt && !bytes_left)\r\nextra_zero_pkt = 0;\r\nif (!iudma->is_tx || iudma->n_bds_used == iudma->n_bds ||\r\n(n_bytes == bytes_left && !extra_zero_pkt)) {\r\nlast_bd = 1;\r\ndmaflags |= DMADESC_EOP_MASK;\r\n}\r\nd->address = breq->req.dma + breq->offset;\r\nmb();\r\nd->len_stat = dmaflags;\r\nbreq->offset += n_bytes;\r\nbreq->bd_bytes += n_bytes;\r\nbytes_left -= n_bytes;\r\n} while (!last_bd);\r\nusb_dmac_writel(udc, ENETDMAC_CHANCFG_EN_MASK,\r\nENETDMAC_CHANCFG_REG, iudma->ch_idx);\r\n}\r\nstatic int iudma_read(struct bcm63xx_udc *udc, struct iudma_ch *iudma)\r\n{\r\nint i, actual_len = 0;\r\nstruct bcm_enet_desc *d = iudma->read_bd;\r\nif (!iudma->n_bds_used)\r\nreturn -EINVAL;\r\nfor (i = 0; i < iudma->n_bds_used; i++) {\r\nu32 dmaflags;\r\ndmaflags = d->len_stat;\r\nif (dmaflags & DMADESC_OWNER_MASK)\r\nreturn -EBUSY;\r\nactual_len += (dmaflags & DMADESC_LENGTH_MASK) >>\r\nDMADESC_LENGTH_SHIFT;\r\nif (d == iudma->end_bd)\r\nd = iudma->bd_ring;\r\nelse\r\nd++;\r\n}\r\niudma->read_bd = d;\r\niudma->n_bds_used = 0;\r\nreturn actual_len;\r\n}\r\nstatic void iudma_reset_channel(struct bcm63xx_udc *udc, struct iudma_ch *iudma)\r\n{\r\nint timeout = IUDMA_RESET_TIMEOUT_US;\r\nstruct bcm_enet_desc *d;\r\nint ch_idx = iudma->ch_idx;\r\nif (!iudma->is_tx)\r\nbcm63xx_fifo_reset_ep(udc, max(0, iudma->ep_num));\r\nusb_dmac_writel(udc, 0, ENETDMAC_CHANCFG_REG, ch_idx);\r\nwhile (usb_dmac_readl(udc, ENETDMAC_CHANCFG_REG, ch_idx) &\r\nENETDMAC_CHANCFG_EN_MASK) {\r\nudelay(1);\r\nif (iudma->is_tx && iudma->ep_num >= 0)\r\nbcm63xx_fifo_reset_ep(udc, iudma->ep_num);\r\nif (!timeout--) {\r\ndev_err(udc->dev, "can't reset IUDMA channel %d\n",\r\nch_idx);\r\nbreak;\r\n}\r\nif (timeout == IUDMA_RESET_TIMEOUT_US / 2) {\r\ndev_warn(udc->dev, "forcibly halting IUDMA channel %d\n",\r\nch_idx);\r\nusb_dmac_writel(udc, ENETDMAC_CHANCFG_BUFHALT_MASK,\r\nENETDMAC_CHANCFG_REG, ch_idx);\r\n}\r\n}\r\nusb_dmac_writel(udc, ~0, ENETDMAC_IR_REG, ch_idx);\r\nfor (d = iudma->bd_ring; d <= iudma->end_bd; d++)\r\nd->len_stat = 0;\r\nmb();\r\niudma->read_bd = iudma->write_bd = iudma->bd_ring;\r\niudma->n_bds_used = 0;\r\nusb_dmac_writel(udc, ENETDMAC_IR_BUFDONE_MASK,\r\nENETDMAC_IRMASK_REG, ch_idx);\r\nusb_dmac_writel(udc, 8, ENETDMAC_MAXBURST_REG, ch_idx);\r\nusb_dmas_writel(udc, iudma->bd_ring_dma, ENETDMAS_RSTART_REG, ch_idx);\r\nusb_dmas_writel(udc, 0, ENETDMAS_SRAM2_REG, ch_idx);\r\n}\r\nstatic int iudma_init_channel(struct bcm63xx_udc *udc, unsigned int ch_idx)\r\n{\r\nstruct iudma_ch *iudma = &udc->iudma[ch_idx];\r\nconst struct iudma_ch_cfg *cfg = &iudma_defaults[ch_idx];\r\nunsigned int n_bds = cfg->n_bds;\r\nstruct bcm63xx_ep *bep = NULL;\r\niudma->ep_num = cfg->ep_num;\r\niudma->ch_idx = ch_idx;\r\niudma->is_tx = !!(ch_idx & 0x01);\r\nif (iudma->ep_num >= 0) {\r\nbep = &udc->bep[iudma->ep_num];\r\nbep->iudma = iudma;\r\nINIT_LIST_HEAD(&bep->queue);\r\n}\r\niudma->bep = bep;\r\niudma->udc = udc;\r\nif (iudma->ep_num <= 0)\r\niudma->enabled = true;\r\niudma->n_bds = n_bds;\r\niudma->bd_ring = dmam_alloc_coherent(udc->dev,\r\nn_bds * sizeof(struct bcm_enet_desc),\r\n&iudma->bd_ring_dma, GFP_KERNEL);\r\nif (!iudma->bd_ring)\r\nreturn -ENOMEM;\r\niudma->end_bd = &iudma->bd_ring[n_bds - 1];\r\nreturn 0;\r\n}\r\nstatic int iudma_init(struct bcm63xx_udc *udc)\r\n{\r\nint i, rc;\r\nusb_dma_writel(udc, ENETDMA_CFG_EN_MASK, ENETDMA_CFG_REG);\r\nfor (i = 0; i < BCM63XX_NUM_IUDMA; i++) {\r\nrc = iudma_init_channel(udc, i);\r\nif (rc)\r\nreturn rc;\r\niudma_reset_channel(udc, &udc->iudma[i]);\r\n}\r\nusb_dma_writel(udc, BIT(BCM63XX_NUM_IUDMA)-1, ENETDMA_GLB_IRQMASK_REG);\r\nreturn 0;\r\n}\r\nstatic void iudma_uninit(struct bcm63xx_udc *udc)\r\n{\r\nint i;\r\nusb_dma_writel(udc, 0, ENETDMA_GLB_IRQMASK_REG);\r\nfor (i = 0; i < BCM63XX_NUM_IUDMA; i++)\r\niudma_reset_channel(udc, &udc->iudma[i]);\r\nusb_dma_writel(udc, 0, ENETDMA_CFG_REG);\r\n}\r\nstatic void bcm63xx_set_ctrl_irqs(struct bcm63xx_udc *udc, bool enable_irqs)\r\n{\r\nu32 val;\r\nusbd_writel(udc, 0, USBD_STATUS_REG);\r\nval = BIT(USBD_EVENT_IRQ_USB_RESET) |\r\nBIT(USBD_EVENT_IRQ_SETUP) |\r\nBIT(USBD_EVENT_IRQ_SETCFG) |\r\nBIT(USBD_EVENT_IRQ_SETINTF) |\r\nBIT(USBD_EVENT_IRQ_USB_LINK);\r\nusbd_writel(udc, enable_irqs ? val : 0, USBD_EVENT_IRQ_MASK_REG);\r\nusbd_writel(udc, val, USBD_EVENT_IRQ_STATUS_REG);\r\n}\r\nstatic void bcm63xx_select_phy_mode(struct bcm63xx_udc *udc, bool is_device)\r\n{\r\nu32 val, portmask = BIT(udc->pd->port_no);\r\nif (BCMCPU_IS_6328()) {\r\nval = bcm_gpio_readl(GPIO_PINMUX_OTHR_REG);\r\nval &= ~GPIO_PINMUX_OTHR_6328_USB_MASK;\r\nval |= is_device ? GPIO_PINMUX_OTHR_6328_USB_DEV :\r\nGPIO_PINMUX_OTHR_6328_USB_HOST;\r\nbcm_gpio_writel(val, GPIO_PINMUX_OTHR_REG);\r\n}\r\nval = bcm_rset_readl(RSET_USBH_PRIV, USBH_PRIV_UTMI_CTL_6368_REG);\r\nif (is_device) {\r\nval |= (portmask << USBH_PRIV_UTMI_CTL_HOSTB_SHIFT);\r\nval |= (portmask << USBH_PRIV_UTMI_CTL_NODRIV_SHIFT);\r\n} else {\r\nval &= ~(portmask << USBH_PRIV_UTMI_CTL_HOSTB_SHIFT);\r\nval &= ~(portmask << USBH_PRIV_UTMI_CTL_NODRIV_SHIFT);\r\n}\r\nbcm_rset_writel(RSET_USBH_PRIV, val, USBH_PRIV_UTMI_CTL_6368_REG);\r\nval = bcm_rset_readl(RSET_USBH_PRIV, USBH_PRIV_SWAP_6368_REG);\r\nif (is_device)\r\nval |= USBH_PRIV_SWAP_USBD_MASK;\r\nelse\r\nval &= ~USBH_PRIV_SWAP_USBD_MASK;\r\nbcm_rset_writel(RSET_USBH_PRIV, val, USBH_PRIV_SWAP_6368_REG);\r\n}\r\nstatic void bcm63xx_select_pullup(struct bcm63xx_udc *udc, bool is_on)\r\n{\r\nu32 val, portmask = BIT(udc->pd->port_no);\r\nval = bcm_rset_readl(RSET_USBH_PRIV, USBH_PRIV_UTMI_CTL_6368_REG);\r\nif (is_on)\r\nval &= ~(portmask << USBH_PRIV_UTMI_CTL_NODRIV_SHIFT);\r\nelse\r\nval |= (portmask << USBH_PRIV_UTMI_CTL_NODRIV_SHIFT);\r\nbcm_rset_writel(RSET_USBH_PRIV, val, USBH_PRIV_UTMI_CTL_6368_REG);\r\n}\r\nstatic void bcm63xx_uninit_udc_hw(struct bcm63xx_udc *udc)\r\n{\r\nset_clocks(udc, true);\r\niudma_uninit(udc);\r\nset_clocks(udc, false);\r\nclk_put(udc->usbd_clk);\r\nclk_put(udc->usbh_clk);\r\n}\r\nstatic int bcm63xx_init_udc_hw(struct bcm63xx_udc *udc)\r\n{\r\nint i, rc = 0;\r\nu32 val;\r\nudc->ep0_ctrl_buf = devm_kzalloc(udc->dev, BCM63XX_MAX_CTRL_PKT,\r\nGFP_KERNEL);\r\nif (!udc->ep0_ctrl_buf)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&udc->gadget.ep_list);\r\nfor (i = 0; i < BCM63XX_NUM_EP; i++) {\r\nstruct bcm63xx_ep *bep = &udc->bep[i];\r\nbep->ep.name = bcm63xx_ep_name[i];\r\nbep->ep_num = i;\r\nbep->ep.ops = &bcm63xx_udc_ep_ops;\r\nlist_add_tail(&bep->ep.ep_list, &udc->gadget.ep_list);\r\nbep->halted = 0;\r\nusb_ep_set_maxpacket_limit(&bep->ep, BCM63XX_MAX_CTRL_PKT);\r\nbep->udc = udc;\r\nbep->ep.desc = NULL;\r\nINIT_LIST_HEAD(&bep->queue);\r\n}\r\nudc->gadget.ep0 = &udc->bep[0].ep;\r\nlist_del(&udc->bep[0].ep.ep_list);\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nudc->ep0state = EP0_SHUTDOWN;\r\nudc->usbh_clk = clk_get(udc->dev, "usbh");\r\nif (IS_ERR(udc->usbh_clk))\r\nreturn -EIO;\r\nudc->usbd_clk = clk_get(udc->dev, "usbd");\r\nif (IS_ERR(udc->usbd_clk)) {\r\nclk_put(udc->usbh_clk);\r\nreturn -EIO;\r\n}\r\nset_clocks(udc, true);\r\nval = USBD_CONTROL_AUTO_CSRS_MASK |\r\nUSBD_CONTROL_DONE_CSRS_MASK |\r\n(irq_coalesce ? USBD_CONTROL_RXZSCFG_MASK : 0);\r\nusbd_writel(udc, val, USBD_CONTROL_REG);\r\nval = USBD_STRAPS_APP_SELF_PWR_MASK |\r\nUSBD_STRAPS_APP_RAM_IF_MASK |\r\nUSBD_STRAPS_APP_CSRPRGSUP_MASK |\r\nUSBD_STRAPS_APP_8BITPHY_MASK |\r\nUSBD_STRAPS_APP_RMTWKUP_MASK;\r\nif (udc->gadget.max_speed == USB_SPEED_HIGH)\r\nval |= (BCM63XX_SPD_HIGH << USBD_STRAPS_SPEED_SHIFT);\r\nelse\r\nval |= (BCM63XX_SPD_FULL << USBD_STRAPS_SPEED_SHIFT);\r\nusbd_writel(udc, val, USBD_STRAPS_REG);\r\nbcm63xx_set_ctrl_irqs(udc, false);\r\nusbd_writel(udc, 0, USBD_EVENT_IRQ_CFG_LO_REG);\r\nval = USBD_EVENT_IRQ_CFG_FALLING(USBD_EVENT_IRQ_ENUM_ON) |\r\nUSBD_EVENT_IRQ_CFG_FALLING(USBD_EVENT_IRQ_SET_CSRS);\r\nusbd_writel(udc, val, USBD_EVENT_IRQ_CFG_HI_REG);\r\nrc = iudma_init(udc);\r\nset_clocks(udc, false);\r\nif (rc)\r\nbcm63xx_uninit_udc_hw(udc);\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_ep_enable(struct usb_ep *ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct bcm63xx_ep *bep = our_ep(ep);\r\nstruct bcm63xx_udc *udc = bep->udc;\r\nstruct iudma_ch *iudma = bep->iudma;\r\nunsigned long flags;\r\nif (!ep || !desc || ep->name == bcm63xx_ep0name)\r\nreturn -EINVAL;\r\nif (!udc->driver)\r\nreturn -ESHUTDOWN;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (iudma->enabled) {\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn -EINVAL;\r\n}\r\niudma->enabled = true;\r\nBUG_ON(!list_empty(&bep->queue));\r\niudma_reset_channel(udc, iudma);\r\nbep->halted = 0;\r\nbcm63xx_set_stall(udc, bep, false);\r\nclear_bit(bep->ep_num, &udc->wedgemap);\r\nep->desc = desc;\r\nep->maxpacket = usb_endpoint_maxp(desc);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_ep_disable(struct usb_ep *ep)\r\n{\r\nstruct bcm63xx_ep *bep = our_ep(ep);\r\nstruct bcm63xx_udc *udc = bep->udc;\r\nstruct iudma_ch *iudma = bep->iudma;\r\nstruct list_head *pos, *n;\r\nunsigned long flags;\r\nif (!ep || !ep->desc)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (!iudma->enabled) {\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn -EINVAL;\r\n}\r\niudma->enabled = false;\r\niudma_reset_channel(udc, iudma);\r\nif (!list_empty(&bep->queue)) {\r\nlist_for_each_safe(pos, n, &bep->queue) {\r\nstruct bcm63xx_req *breq =\r\nlist_entry(pos, struct bcm63xx_req, queue);\r\nusb_gadget_unmap_request(&udc->gadget, &breq->req,\r\niudma->is_tx);\r\nlist_del(&breq->queue);\r\nbreq->req.status = -ESHUTDOWN;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nbreq->req.complete(&iudma->bep->ep, &breq->req);\r\nspin_lock_irqsave(&udc->lock, flags);\r\n}\r\n}\r\nep->desc = NULL;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct usb_request *bcm63xx_udc_alloc_request(struct usb_ep *ep,\r\ngfp_t mem_flags)\r\n{\r\nstruct bcm63xx_req *breq;\r\nbreq = kzalloc(sizeof(*breq), mem_flags);\r\nif (!breq)\r\nreturn NULL;\r\nreturn &breq->req;\r\n}\r\nstatic void bcm63xx_udc_free_request(struct usb_ep *ep,\r\nstruct usb_request *req)\r\n{\r\nstruct bcm63xx_req *breq = our_req(req);\r\nkfree(breq);\r\n}\r\nstatic int bcm63xx_udc_queue(struct usb_ep *ep, struct usb_request *req,\r\ngfp_t mem_flags)\r\n{\r\nstruct bcm63xx_ep *bep = our_ep(ep);\r\nstruct bcm63xx_udc *udc = bep->udc;\r\nstruct bcm63xx_req *breq = our_req(req);\r\nunsigned long flags;\r\nint rc = 0;\r\nif (unlikely(!req || !req->complete || !req->buf || !ep))\r\nreturn -EINVAL;\r\nreq->actual = 0;\r\nreq->status = 0;\r\nbreq->offset = 0;\r\nif (bep == &udc->bep[0]) {\r\nif (udc->ep0_reply)\r\nreturn -EINVAL;\r\nudc->ep0_reply = req;\r\nschedule_work(&udc->ep0_wq);\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (!bep->iudma->enabled) {\r\nrc = -ESHUTDOWN;\r\ngoto out;\r\n}\r\nrc = usb_gadget_map_request(&udc->gadget, req, bep->iudma->is_tx);\r\nif (rc == 0) {\r\nlist_add_tail(&breq->queue, &bep->queue);\r\nif (list_is_singular(&bep->queue))\r\niudma_write(udc, bep->iudma, breq);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn rc;\r\n}\r\nstatic int bcm63xx_udc_dequeue(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct bcm63xx_ep *bep = our_ep(ep);\r\nstruct bcm63xx_udc *udc = bep->udc;\r\nstruct bcm63xx_req *breq = our_req(req), *cur;\r\nunsigned long flags;\r\nint rc = 0;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (list_empty(&bep->queue)) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\ncur = list_first_entry(&bep->queue, struct bcm63xx_req, queue);\r\nusb_gadget_unmap_request(&udc->gadget, &breq->req, bep->iudma->is_tx);\r\nif (breq == cur) {\r\niudma_reset_channel(udc, bep->iudma);\r\nlist_del(&breq->queue);\r\nif (!list_empty(&bep->queue)) {\r\nstruct bcm63xx_req *next;\r\nnext = list_first_entry(&bep->queue,\r\nstruct bcm63xx_req, queue);\r\niudma_write(udc, bep->iudma, next);\r\n}\r\n} else {\r\nlist_del(&breq->queue);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreq->status = -ESHUTDOWN;\r\nreq->complete(ep, req);\r\nreturn rc;\r\n}\r\nstatic int bcm63xx_udc_set_halt(struct usb_ep *ep, int value)\r\n{\r\nstruct bcm63xx_ep *bep = our_ep(ep);\r\nstruct bcm63xx_udc *udc = bep->udc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nbcm63xx_set_stall(udc, bep, !!value);\r\nbep->halted = value;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_udc_set_wedge(struct usb_ep *ep)\r\n{\r\nstruct bcm63xx_ep *bep = our_ep(ep);\r\nstruct bcm63xx_udc *udc = bep->udc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nset_bit(bep->ep_num, &udc->wedgemap);\r\nbcm63xx_set_stall(udc, bep, true);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_ep0_setup_callback(struct bcm63xx_udc *udc,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nint rc;\r\nspin_unlock_irq(&udc->lock);\r\nrc = udc->driver->setup(&udc->gadget, ctrl);\r\nspin_lock_irq(&udc->lock);\r\nreturn rc;\r\n}\r\nstatic int bcm63xx_ep0_spoof_set_cfg(struct bcm63xx_udc *udc)\r\n{\r\nstruct usb_ctrlrequest ctrl;\r\nint rc;\r\nctrl.bRequestType = USB_DIR_OUT | USB_RECIP_DEVICE;\r\nctrl.bRequest = USB_REQ_SET_CONFIGURATION;\r\nctrl.wValue = cpu_to_le16(udc->cfg);\r\nctrl.wIndex = 0;\r\nctrl.wLength = 0;\r\nrc = bcm63xx_ep0_setup_callback(udc, &ctrl);\r\nif (rc < 0) {\r\ndev_warn_ratelimited(udc->dev,\r\n"hardware auto-acked bad SET_CONFIGURATION(%d) request\n",\r\nudc->cfg);\r\n}\r\nreturn rc;\r\n}\r\nstatic int bcm63xx_ep0_spoof_set_iface(struct bcm63xx_udc *udc)\r\n{\r\nstruct usb_ctrlrequest ctrl;\r\nint rc;\r\nctrl.bRequestType = USB_DIR_OUT | USB_RECIP_INTERFACE;\r\nctrl.bRequest = USB_REQ_SET_INTERFACE;\r\nctrl.wValue = cpu_to_le16(udc->alt_iface);\r\nctrl.wIndex = cpu_to_le16(udc->iface);\r\nctrl.wLength = 0;\r\nrc = bcm63xx_ep0_setup_callback(udc, &ctrl);\r\nif (rc < 0) {\r\ndev_warn_ratelimited(udc->dev,\r\n"hardware auto-acked bad SET_INTERFACE(%d,%d) request\n",\r\nudc->iface, udc->alt_iface);\r\n}\r\nreturn rc;\r\n}\r\nstatic void bcm63xx_ep0_map_write(struct bcm63xx_udc *udc, int ch_idx,\r\nstruct usb_request *req)\r\n{\r\nstruct bcm63xx_req *breq = our_req(req);\r\nstruct iudma_ch *iudma = &udc->iudma[ch_idx];\r\nBUG_ON(udc->ep0_request);\r\nudc->ep0_request = req;\r\nreq->actual = 0;\r\nbreq->offset = 0;\r\nusb_gadget_map_request(&udc->gadget, req, iudma->is_tx);\r\niudma_write(udc, iudma, breq);\r\n}\r\nstatic void bcm63xx_ep0_complete(struct bcm63xx_udc *udc,\r\nstruct usb_request *req, int status)\r\n{\r\nreq->status = status;\r\nif (status)\r\nreq->actual = 0;\r\nif (req->complete) {\r\nspin_unlock_irq(&udc->lock);\r\nreq->complete(&udc->bep[0].ep, req);\r\nspin_lock_irq(&udc->lock);\r\n}\r\n}\r\nstatic void bcm63xx_ep0_nuke_reply(struct bcm63xx_udc *udc, int is_tx)\r\n{\r\nstruct usb_request *req = udc->ep0_reply;\r\nudc->ep0_reply = NULL;\r\nusb_gadget_unmap_request(&udc->gadget, req, is_tx);\r\nif (udc->ep0_request == req) {\r\nudc->ep0_req_completed = 0;\r\nudc->ep0_request = NULL;\r\n}\r\nbcm63xx_ep0_complete(udc, req, -ESHUTDOWN);\r\n}\r\nstatic int bcm63xx_ep0_read_complete(struct bcm63xx_udc *udc)\r\n{\r\nstruct usb_request *req = udc->ep0_request;\r\nudc->ep0_req_completed = 0;\r\nudc->ep0_request = NULL;\r\nreturn req->actual;\r\n}\r\nstatic void bcm63xx_ep0_internal_request(struct bcm63xx_udc *udc, int ch_idx,\r\nint length)\r\n{\r\nstruct usb_request *req = &udc->ep0_ctrl_req.req;\r\nreq->buf = udc->ep0_ctrl_buf;\r\nreq->length = length;\r\nreq->complete = NULL;\r\nbcm63xx_ep0_map_write(udc, ch_idx, req);\r\n}\r\nstatic enum bcm63xx_ep0_state bcm63xx_ep0_do_setup(struct bcm63xx_udc *udc)\r\n{\r\nint rc;\r\nstruct usb_ctrlrequest *ctrl = (void *)udc->ep0_ctrl_buf;\r\nrc = bcm63xx_ep0_read_complete(udc);\r\nif (rc < 0) {\r\ndev_err(udc->dev, "missing SETUP packet\n");\r\nreturn EP0_IDLE;\r\n}\r\nif (rc == 0)\r\nreturn EP0_REQUEUE;\r\nif (rc != sizeof(*ctrl)) {\r\ndev_warn_ratelimited(udc->dev,\r\n"malformed SETUP packet (%d bytes)\n", rc);\r\nreturn EP0_REQUEUE;\r\n}\r\nrc = bcm63xx_ep0_setup_callback(udc, ctrl);\r\nif (rc < 0) {\r\nbcm63xx_set_stall(udc, &udc->bep[0], true);\r\nreturn EP0_REQUEUE;\r\n}\r\nif (!ctrl->wLength)\r\nreturn EP0_REQUEUE;\r\nelse if (ctrl->bRequestType & USB_DIR_IN)\r\nreturn EP0_IN_DATA_PHASE_SETUP;\r\nelse\r\nreturn EP0_OUT_DATA_PHASE_SETUP;\r\n}\r\nstatic int bcm63xx_ep0_do_idle(struct bcm63xx_udc *udc)\r\n{\r\nif (udc->ep0_req_reset) {\r\nudc->ep0_req_reset = 0;\r\n} else if (udc->ep0_req_set_cfg) {\r\nudc->ep0_req_set_cfg = 0;\r\nif (bcm63xx_ep0_spoof_set_cfg(udc) >= 0)\r\nudc->ep0state = EP0_IN_FAKE_STATUS_PHASE;\r\n} else if (udc->ep0_req_set_iface) {\r\nudc->ep0_req_set_iface = 0;\r\nif (bcm63xx_ep0_spoof_set_iface(udc) >= 0)\r\nudc->ep0state = EP0_IN_FAKE_STATUS_PHASE;\r\n} else if (udc->ep0_req_completed) {\r\nudc->ep0state = bcm63xx_ep0_do_setup(udc);\r\nreturn udc->ep0state == EP0_IDLE ? -EAGAIN : 0;\r\n} else if (udc->ep0_req_shutdown) {\r\nudc->ep0_req_shutdown = 0;\r\nudc->ep0_req_completed = 0;\r\nudc->ep0_request = NULL;\r\niudma_reset_channel(udc, &udc->iudma[IUDMA_EP0_RXCHAN]);\r\nusb_gadget_unmap_request(&udc->gadget,\r\n&udc->ep0_ctrl_req.req, 0);\r\nmb();\r\nudc->ep0state = EP0_SHUTDOWN;\r\n} else if (udc->ep0_reply) {\r\ndev_warn(udc->dev, "nuking unexpected reply\n");\r\nbcm63xx_ep0_nuke_reply(udc, 0);\r\n} else {\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_ep0_one_round(struct bcm63xx_udc *udc)\r\n{\r\nenum bcm63xx_ep0_state ep0state = udc->ep0state;\r\nbool shutdown = udc->ep0_req_reset || udc->ep0_req_shutdown;\r\nswitch (udc->ep0state) {\r\ncase EP0_REQUEUE:\r\nbcm63xx_ep0_internal_request(udc, IUDMA_EP0_RXCHAN,\r\nBCM63XX_MAX_CTRL_PKT);\r\nep0state = EP0_IDLE;\r\nbreak;\r\ncase EP0_IDLE:\r\nreturn bcm63xx_ep0_do_idle(udc);\r\ncase EP0_IN_DATA_PHASE_SETUP:\r\nif (udc->ep0_reply) {\r\nbcm63xx_ep0_map_write(udc, IUDMA_EP0_TXCHAN,\r\nudc->ep0_reply);\r\nep0state = EP0_IN_DATA_PHASE_COMPLETE;\r\n} else if (shutdown) {\r\nep0state = EP0_REQUEUE;\r\n}\r\nbreak;\r\ncase EP0_IN_DATA_PHASE_COMPLETE: {\r\nif (udc->ep0_req_completed) {\r\nudc->ep0_reply = NULL;\r\nbcm63xx_ep0_read_complete(udc);\r\nep0state = EP0_REQUEUE;\r\n} else if (shutdown) {\r\niudma_reset_channel(udc, &udc->iudma[IUDMA_EP0_TXCHAN]);\r\nbcm63xx_ep0_nuke_reply(udc, 1);\r\nep0state = EP0_REQUEUE;\r\n}\r\nbreak;\r\n}\r\ncase EP0_OUT_DATA_PHASE_SETUP:\r\nif (udc->ep0_reply) {\r\nbcm63xx_ep0_map_write(udc, IUDMA_EP0_RXCHAN,\r\nudc->ep0_reply);\r\nep0state = EP0_OUT_DATA_PHASE_COMPLETE;\r\n} else if (shutdown) {\r\nep0state = EP0_REQUEUE;\r\n}\r\nbreak;\r\ncase EP0_OUT_DATA_PHASE_COMPLETE: {\r\nif (udc->ep0_req_completed) {\r\nudc->ep0_reply = NULL;\r\nbcm63xx_ep0_read_complete(udc);\r\nbcm63xx_ep0_internal_request(udc, IUDMA_EP0_TXCHAN, 0);\r\nep0state = EP0_OUT_STATUS_PHASE;\r\n} else if (shutdown) {\r\niudma_reset_channel(udc, &udc->iudma[IUDMA_EP0_RXCHAN]);\r\nbcm63xx_ep0_nuke_reply(udc, 0);\r\nep0state = EP0_REQUEUE;\r\n}\r\nbreak;\r\n}\r\ncase EP0_OUT_STATUS_PHASE:\r\nif (udc->ep0_req_completed) {\r\nbcm63xx_ep0_read_complete(udc);\r\nep0state = EP0_REQUEUE;\r\n} else if (shutdown) {\r\niudma_reset_channel(udc, &udc->iudma[IUDMA_EP0_TXCHAN]);\r\nudc->ep0_request = NULL;\r\nep0state = EP0_REQUEUE;\r\n}\r\nbreak;\r\ncase EP0_IN_FAKE_STATUS_PHASE: {\r\nstruct usb_request *r = udc->ep0_reply;\r\nif (!r) {\r\nif (shutdown)\r\nep0state = EP0_IDLE;\r\nbreak;\r\n}\r\nbcm63xx_ep0_complete(udc, r, 0);\r\nudc->ep0_reply = NULL;\r\nep0state = EP0_IDLE;\r\nbreak;\r\n}\r\ncase EP0_SHUTDOWN:\r\nbreak;\r\n}\r\nif (udc->ep0state == ep0state)\r\nreturn -EAGAIN;\r\nudc->ep0state = ep0state;\r\nreturn 0;\r\n}\r\nstatic void bcm63xx_ep0_process(struct work_struct *w)\r\n{\r\nstruct bcm63xx_udc *udc = container_of(w, struct bcm63xx_udc, ep0_wq);\r\nspin_lock_irq(&udc->lock);\r\nwhile (bcm63xx_ep0_one_round(udc) == 0)\r\n;\r\nspin_unlock_irq(&udc->lock);\r\n}\r\nstatic int bcm63xx_udc_get_frame(struct usb_gadget *gadget)\r\n{\r\nstruct bcm63xx_udc *udc = gadget_to_udc(gadget);\r\nreturn (usbd_readl(udc, USBD_STATUS_REG) &\r\nUSBD_STATUS_SOF_MASK) >> USBD_STATUS_SOF_SHIFT;\r\n}\r\nstatic int bcm63xx_udc_pullup(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct bcm63xx_udc *udc = gadget_to_udc(gadget);\r\nunsigned long flags;\r\nint i, rc = -EINVAL;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (is_on && udc->ep0state == EP0_SHUTDOWN) {\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nudc->ep0state = EP0_REQUEUE;\r\nbcm63xx_fifo_setup(udc);\r\nbcm63xx_fifo_reset(udc);\r\nbcm63xx_ep_setup(udc);\r\nbitmap_zero(&udc->wedgemap, BCM63XX_NUM_EP);\r\nfor (i = 0; i < BCM63XX_NUM_EP; i++)\r\nbcm63xx_set_stall(udc, &udc->bep[i], false);\r\nbcm63xx_set_ctrl_irqs(udc, true);\r\nbcm63xx_select_pullup(gadget_to_udc(gadget), true);\r\nrc = 0;\r\n} else if (!is_on && udc->ep0state != EP0_SHUTDOWN) {\r\nbcm63xx_select_pullup(gadget_to_udc(gadget), false);\r\nudc->ep0_req_shutdown = 1;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nwhile (1) {\r\nschedule_work(&udc->ep0_wq);\r\nif (udc->ep0state == EP0_SHUTDOWN)\r\nbreak;\r\nmsleep(50);\r\n}\r\nbcm63xx_set_ctrl_irqs(udc, false);\r\ncancel_work_sync(&udc->ep0_wq);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn rc;\r\n}\r\nstatic int bcm63xx_udc_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct bcm63xx_udc *udc = gadget_to_udc(gadget);\r\nunsigned long flags;\r\nif (!driver || driver->max_speed < USB_SPEED_HIGH ||\r\n!driver->setup)\r\nreturn -EINVAL;\r\nif (!udc)\r\nreturn -ENODEV;\r\nif (udc->driver)\r\nreturn -EBUSY;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nset_clocks(udc, true);\r\nbcm63xx_fifo_setup(udc);\r\nbcm63xx_ep_init(udc);\r\nbcm63xx_ep_setup(udc);\r\nbcm63xx_fifo_reset(udc);\r\nbcm63xx_select_phy_mode(udc, true);\r\nudc->driver = driver;\r\ndriver->driver.bus = NULL;\r\nudc->gadget.dev.of_node = udc->dev->of_node;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_udc_stop(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct bcm63xx_udc *udc = gadget_to_udc(gadget);\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nudc->driver = NULL;\r\nmsleep(100);\r\nbcm63xx_select_phy_mode(udc, false);\r\nset_clocks(udc, false);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void bcm63xx_update_cfg_iface(struct bcm63xx_udc *udc)\r\n{\r\nu32 reg = usbd_readl(udc, USBD_STATUS_REG);\r\nudc->cfg = (reg & USBD_STATUS_CFG_MASK) >> USBD_STATUS_CFG_SHIFT;\r\nudc->iface = (reg & USBD_STATUS_INTF_MASK) >> USBD_STATUS_INTF_SHIFT;\r\nudc->alt_iface = (reg & USBD_STATUS_ALTINTF_MASK) >>\r\nUSBD_STATUS_ALTINTF_SHIFT;\r\nbcm63xx_ep_setup(udc);\r\n}\r\nstatic int bcm63xx_update_link_speed(struct bcm63xx_udc *udc)\r\n{\r\nu32 reg = usbd_readl(udc, USBD_STATUS_REG);\r\nenum usb_device_speed oldspeed = udc->gadget.speed;\r\nswitch ((reg & USBD_STATUS_SPD_MASK) >> USBD_STATUS_SPD_SHIFT) {\r\ncase BCM63XX_SPD_HIGH:\r\nudc->gadget.speed = USB_SPEED_HIGH;\r\nbreak;\r\ncase BCM63XX_SPD_FULL:\r\nudc->gadget.speed = USB_SPEED_FULL;\r\nbreak;\r\ndefault:\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\ndev_err(udc->dev,\r\n"received SETUP packet with invalid link speed\n");\r\nreturn 0;\r\n}\r\nif (udc->gadget.speed != oldspeed) {\r\ndev_info(udc->dev, "link up, %s-speed mode\n",\r\nudc->gadget.speed == USB_SPEED_HIGH ? "high" : "full");\r\nreturn 1;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic void bcm63xx_update_wedge(struct bcm63xx_udc *udc, bool new_status)\r\n{\r\nint i;\r\nfor_each_set_bit(i, &udc->wedgemap, BCM63XX_NUM_EP) {\r\nbcm63xx_set_stall(udc, &udc->bep[i], new_status);\r\nif (!new_status)\r\nclear_bit(i, &udc->wedgemap);\r\n}\r\n}\r\nstatic irqreturn_t bcm63xx_udc_ctrl_isr(int irq, void *dev_id)\r\n{\r\nstruct bcm63xx_udc *udc = dev_id;\r\nu32 stat;\r\nbool disconnected = false;\r\nstat = usbd_readl(udc, USBD_EVENT_IRQ_STATUS_REG) &\r\nusbd_readl(udc, USBD_EVENT_IRQ_MASK_REG);\r\nusbd_writel(udc, stat, USBD_EVENT_IRQ_STATUS_REG);\r\nspin_lock(&udc->lock);\r\nif (stat & BIT(USBD_EVENT_IRQ_USB_LINK)) {\r\nif (!(usbd_readl(udc, USBD_EVENTS_REG) &\r\nUSBD_EVENTS_USB_LINK_MASK) &&\r\nudc->gadget.speed != USB_SPEED_UNKNOWN)\r\ndev_info(udc->dev, "link down\n");\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\ndisconnected = true;\r\n}\r\nif (stat & BIT(USBD_EVENT_IRQ_USB_RESET)) {\r\nbcm63xx_fifo_setup(udc);\r\nbcm63xx_fifo_reset(udc);\r\nbcm63xx_ep_setup(udc);\r\nbcm63xx_update_wedge(udc, false);\r\nudc->ep0_req_reset = 1;\r\nschedule_work(&udc->ep0_wq);\r\ndisconnected = true;\r\n}\r\nif (stat & BIT(USBD_EVENT_IRQ_SETUP)) {\r\nif (bcm63xx_update_link_speed(udc)) {\r\nbcm63xx_fifo_setup(udc);\r\nbcm63xx_ep_setup(udc);\r\n}\r\nbcm63xx_update_wedge(udc, true);\r\n}\r\nif (stat & BIT(USBD_EVENT_IRQ_SETCFG)) {\r\nbcm63xx_update_cfg_iface(udc);\r\nudc->ep0_req_set_cfg = 1;\r\nschedule_work(&udc->ep0_wq);\r\n}\r\nif (stat & BIT(USBD_EVENT_IRQ_SETINTF)) {\r\nbcm63xx_update_cfg_iface(udc);\r\nudc->ep0_req_set_iface = 1;\r\nschedule_work(&udc->ep0_wq);\r\n}\r\nspin_unlock(&udc->lock);\r\nif (disconnected && udc->driver)\r\nudc->driver->disconnect(&udc->gadget);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t bcm63xx_udc_data_isr(int irq, void *dev_id)\r\n{\r\nstruct iudma_ch *iudma = dev_id;\r\nstruct bcm63xx_udc *udc = iudma->udc;\r\nstruct bcm63xx_ep *bep;\r\nstruct usb_request *req = NULL;\r\nstruct bcm63xx_req *breq = NULL;\r\nint rc;\r\nbool is_done = false;\r\nspin_lock(&udc->lock);\r\nusb_dmac_writel(udc, ENETDMAC_IR_BUFDONE_MASK,\r\nENETDMAC_IR_REG, iudma->ch_idx);\r\nbep = iudma->bep;\r\nrc = iudma_read(udc, iudma);\r\nif (iudma->ch_idx == IUDMA_EP0_RXCHAN ||\r\niudma->ch_idx == IUDMA_EP0_TXCHAN) {\r\nreq = udc->ep0_request;\r\nbreq = our_req(req);\r\nif (rc >= 0) {\r\nreq->actual += rc;\r\nif (req->actual >= req->length || breq->bd_bytes > rc) {\r\nudc->ep0_req_completed = 1;\r\nis_done = true;\r\nschedule_work(&udc->ep0_wq);\r\nreq->actual = min(req->actual, req->length);\r\n} else {\r\niudma_write(udc, iudma, breq);\r\n}\r\n}\r\n} else if (!list_empty(&bep->queue)) {\r\nbreq = list_first_entry(&bep->queue, struct bcm63xx_req, queue);\r\nreq = &breq->req;\r\nif (rc >= 0) {\r\nreq->actual += rc;\r\nif (req->actual >= req->length || breq->bd_bytes > rc) {\r\nis_done = true;\r\nlist_del(&breq->queue);\r\nreq->actual = min(req->actual, req->length);\r\nif (!list_empty(&bep->queue)) {\r\nstruct bcm63xx_req *next;\r\nnext = list_first_entry(&bep->queue,\r\nstruct bcm63xx_req, queue);\r\niudma_write(udc, iudma, next);\r\n}\r\n} else {\r\niudma_write(udc, iudma, breq);\r\n}\r\n}\r\n}\r\nspin_unlock(&udc->lock);\r\nif (is_done) {\r\nusb_gadget_unmap_request(&udc->gadget, req, iudma->is_tx);\r\nif (req->complete)\r\nreq->complete(&bep->ep, req);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bcm63xx_usbd_dbg_show(struct seq_file *s, void *p)\r\n{\r\nstruct bcm63xx_udc *udc = s->private;\r\nif (!udc->driver)\r\nreturn -ENODEV;\r\nseq_printf(s, "ep0 state: %s\n",\r\nbcm63xx_ep0_state_names[udc->ep0state]);\r\nseq_printf(s, " pending requests: %s%s%s%s%s%s%s\n",\r\nudc->ep0_req_reset ? "reset " : "",\r\nudc->ep0_req_set_cfg ? "set_cfg " : "",\r\nudc->ep0_req_set_iface ? "set_iface " : "",\r\nudc->ep0_req_shutdown ? "shutdown " : "",\r\nudc->ep0_request ? "pending " : "",\r\nudc->ep0_req_completed ? "completed " : "",\r\nudc->ep0_reply ? "reply " : "");\r\nseq_printf(s, "cfg: %d; iface: %d; alt_iface: %d\n",\r\nudc->cfg, udc->iface, udc->alt_iface);\r\nseq_printf(s, "regs:\n");\r\nseq_printf(s, " control: %08x; straps: %08x; status: %08x\n",\r\nusbd_readl(udc, USBD_CONTROL_REG),\r\nusbd_readl(udc, USBD_STRAPS_REG),\r\nusbd_readl(udc, USBD_STATUS_REG));\r\nseq_printf(s, " events: %08x; stall: %08x\n",\r\nusbd_readl(udc, USBD_EVENTS_REG),\r\nusbd_readl(udc, USBD_STALL_REG));\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_iudma_dbg_show(struct seq_file *s, void *p)\r\n{\r\nstruct bcm63xx_udc *udc = s->private;\r\nint ch_idx, i;\r\nu32 sram2, sram3;\r\nif (!udc->driver)\r\nreturn -ENODEV;\r\nfor (ch_idx = 0; ch_idx < BCM63XX_NUM_IUDMA; ch_idx++) {\r\nstruct iudma_ch *iudma = &udc->iudma[ch_idx];\r\nstruct list_head *pos;\r\nseq_printf(s, "IUDMA channel %d -- ", ch_idx);\r\nswitch (iudma_defaults[ch_idx].ep_type) {\r\ncase BCMEP_CTRL:\r\nseq_printf(s, "control");\r\nbreak;\r\ncase BCMEP_BULK:\r\nseq_printf(s, "bulk");\r\nbreak;\r\ncase BCMEP_INTR:\r\nseq_printf(s, "interrupt");\r\nbreak;\r\n}\r\nseq_printf(s, ch_idx & 0x01 ? " tx" : " rx");\r\nseq_printf(s, " [ep%d]:\n",\r\nmax_t(int, iudma_defaults[ch_idx].ep_num, 0));\r\nseq_printf(s, " cfg: %08x; irqstat: %08x; irqmask: %08x; maxburst: %08x\n",\r\nusb_dmac_readl(udc, ENETDMAC_CHANCFG_REG, ch_idx),\r\nusb_dmac_readl(udc, ENETDMAC_IR_REG, ch_idx),\r\nusb_dmac_readl(udc, ENETDMAC_IRMASK_REG, ch_idx),\r\nusb_dmac_readl(udc, ENETDMAC_MAXBURST_REG, ch_idx));\r\nsram2 = usb_dmas_readl(udc, ENETDMAS_SRAM2_REG, ch_idx);\r\nsram3 = usb_dmas_readl(udc, ENETDMAS_SRAM3_REG, ch_idx);\r\nseq_printf(s, " base: %08x; index: %04x_%04x; desc: %04x_%04x %08x\n",\r\nusb_dmas_readl(udc, ENETDMAS_RSTART_REG, ch_idx),\r\nsram2 >> 16, sram2 & 0xffff,\r\nsram3 >> 16, sram3 & 0xffff,\r\nusb_dmas_readl(udc, ENETDMAS_SRAM4_REG, ch_idx));\r\nseq_printf(s, " desc: %d/%d used", iudma->n_bds_used,\r\niudma->n_bds);\r\nif (iudma->bep) {\r\ni = 0;\r\nlist_for_each(pos, &iudma->bep->queue)\r\ni++;\r\nseq_printf(s, "; %d queued\n", i);\r\n} else {\r\nseq_printf(s, "\n");\r\n}\r\nfor (i = 0; i < iudma->n_bds; i++) {\r\nstruct bcm_enet_desc *d = &iudma->bd_ring[i];\r\nseq_printf(s, " %03x (%02x): len_stat: %04x_%04x; pa %08x",\r\ni * sizeof(*d), i,\r\nd->len_stat >> 16, d->len_stat & 0xffff,\r\nd->address);\r\nif (d == iudma->read_bd)\r\nseq_printf(s, " <<RD");\r\nif (d == iudma->write_bd)\r\nseq_printf(s, " <<WR");\r\nseq_printf(s, "\n");\r\n}\r\nseq_printf(s, "\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_usbd_dbg_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, bcm63xx_usbd_dbg_show, inode->i_private);\r\n}\r\nstatic int bcm63xx_iudma_dbg_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, bcm63xx_iudma_dbg_show, inode->i_private);\r\n}\r\nstatic void bcm63xx_udc_init_debugfs(struct bcm63xx_udc *udc)\r\n{\r\nstruct dentry *root, *usbd, *iudma;\r\nif (!IS_ENABLED(CONFIG_USB_GADGET_DEBUG_FS))\r\nreturn;\r\nroot = debugfs_create_dir(udc->gadget.name, NULL);\r\nif (IS_ERR(root) || !root)\r\ngoto err_root;\r\nusbd = debugfs_create_file("usbd", 0400, root, udc,\r\n&usbd_dbg_fops);\r\nif (!usbd)\r\ngoto err_usbd;\r\niudma = debugfs_create_file("iudma", 0400, root, udc,\r\n&iudma_dbg_fops);\r\nif (!iudma)\r\ngoto err_iudma;\r\nudc->debugfs_root = root;\r\nudc->debugfs_usbd = usbd;\r\nudc->debugfs_iudma = iudma;\r\nreturn;\r\nerr_iudma:\r\ndebugfs_remove(usbd);\r\nerr_usbd:\r\ndebugfs_remove(root);\r\nerr_root:\r\ndev_err(udc->dev, "debugfs is not available\n");\r\n}\r\nstatic void bcm63xx_udc_cleanup_debugfs(struct bcm63xx_udc *udc)\r\n{\r\ndebugfs_remove(udc->debugfs_iudma);\r\ndebugfs_remove(udc->debugfs_usbd);\r\ndebugfs_remove(udc->debugfs_root);\r\nudc->debugfs_iudma = NULL;\r\nudc->debugfs_usbd = NULL;\r\nudc->debugfs_root = NULL;\r\n}\r\nstatic int bcm63xx_udc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct bcm63xx_usbd_platform_data *pd = dev_get_platdata(dev);\r\nstruct bcm63xx_udc *udc;\r\nstruct resource *res;\r\nint rc = -ENOMEM, i, irq;\r\nudc = devm_kzalloc(dev, sizeof(*udc), GFP_KERNEL);\r\nif (!udc) {\r\ndev_err(dev, "cannot allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, udc);\r\nudc->dev = dev;\r\nudc->pd = pd;\r\nif (!pd) {\r\ndev_err(dev, "missing platform data\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nudc->usbd_regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(udc->usbd_regs))\r\nreturn PTR_ERR(udc->usbd_regs);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nudc->iudma_regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(udc->iudma_regs))\r\nreturn PTR_ERR(udc->iudma_regs);\r\nspin_lock_init(&udc->lock);\r\nINIT_WORK(&udc->ep0_wq, bcm63xx_ep0_process);\r\nudc->gadget.ops = &bcm63xx_udc_ops;\r\nudc->gadget.name = dev_name(dev);\r\nif (!pd->use_fullspeed && !use_fullspeed)\r\nudc->gadget.max_speed = USB_SPEED_HIGH;\r\nelse\r\nudc->gadget.max_speed = USB_SPEED_FULL;\r\nrc = bcm63xx_init_udc_hw(udc);\r\nif (rc)\r\nreturn rc;\r\nrc = -ENXIO;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "missing IRQ resource #0\n");\r\ngoto out_uninit;\r\n}\r\nif (devm_request_irq(dev, irq, &bcm63xx_udc_ctrl_isr, 0,\r\ndev_name(dev), udc) < 0) {\r\ndev_err(dev, "error requesting IRQ #%d\n", irq);\r\ngoto out_uninit;\r\n}\r\nfor (i = 0; i < BCM63XX_NUM_IUDMA; i++) {\r\nirq = platform_get_irq(pdev, i + 1);\r\nif (irq < 0) {\r\ndev_err(dev, "missing IRQ resource #%d\n", i + 1);\r\ngoto out_uninit;\r\n}\r\nif (devm_request_irq(dev, irq, &bcm63xx_udc_data_isr, 0,\r\ndev_name(dev), &udc->iudma[i]) < 0) {\r\ndev_err(dev, "error requesting IRQ #%d\n", irq);\r\ngoto out_uninit;\r\n}\r\n}\r\nbcm63xx_udc_init_debugfs(udc);\r\nrc = usb_add_gadget_udc(dev, &udc->gadget);\r\nif (!rc)\r\nreturn 0;\r\nbcm63xx_udc_cleanup_debugfs(udc);\r\nout_uninit:\r\nbcm63xx_uninit_udc_hw(udc);\r\nreturn rc;\r\n}\r\nstatic int bcm63xx_udc_remove(struct platform_device *pdev)\r\n{\r\nstruct bcm63xx_udc *udc = platform_get_drvdata(pdev);\r\nbcm63xx_udc_cleanup_debugfs(udc);\r\nusb_del_gadget_udc(&udc->gadget);\r\nBUG_ON(udc->driver);\r\nbcm63xx_uninit_udc_hw(udc);\r\nreturn 0;\r\n}
