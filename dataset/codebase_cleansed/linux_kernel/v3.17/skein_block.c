void skein_256_process_block(struct skein_256_ctx *ctx, const u8 *blk_ptr,\r\nsize_t blk_cnt, size_t byte_cnt_add)\r\n{\r\nenum {\r\nWCNT = SKEIN_256_STATE_WORDS\r\n};\r\n#undef RCNT\r\n#define RCNT (SKEIN_256_ROUNDS_TOTAL/8)\r\n#ifdef SKEIN_LOOP\r\n#define SKEIN_UNROLL_256 (((SKEIN_LOOP)/100)%10)\r\n#else\r\n#define SKEIN_UNROLL_256 (0)\r\n#endif\r\n#if SKEIN_UNROLL_256\r\n#if (RCNT % SKEIN_UNROLL_256)\r\n#error "Invalid SKEIN_UNROLL_256"\r\n#endif\r\nsize_t r;\r\nu64 kw[WCNT+4+RCNT*2];\r\n#else\r\nu64 kw[WCNT+4];\r\n#endif\r\nu64 X0, X1, X2, X3;\r\nu64 w[WCNT];\r\n#ifdef SKEIN_DEBUG\r\nconst u64 *X_ptr[4];\r\nX_ptr[0] = &X0; X_ptr[1] = &X1; X_ptr[2] = &X2; X_ptr[3] = &X3;\r\n#endif\r\nskein_assert(blk_cnt != 0);\r\nts[0] = ctx->h.tweak[0];\r\nts[1] = ctx->h.tweak[1];\r\ndo {\r\nts[0] += byte_cnt_add;\r\nks[0] = ctx->x[0];\r\nks[1] = ctx->x[1];\r\nks[2] = ctx->x[2];\r\nks[3] = ctx->x[3];\r\nks[4] = ks[0] ^ ks[1] ^ ks[2] ^ ks[3] ^ SKEIN_KS_PARITY;\r\nts[2] = ts[0] ^ ts[1];\r\nskein_get64_lsb_first(w, blk_ptr, WCNT);\r\ndebug_save_tweak(ctx);\r\nskein_show_block(BLK_BITS, &ctx->h, ctx->x, blk_ptr, w, ks, ts);\r\nX0 = w[0] + ks[0];\r\nX1 = w[1] + ks[1] + ts[0];\r\nX2 = w[2] + ks[2] + ts[1];\r\nX3 = w[3] + ks[3];\r\nskein_show_r_ptr(BLK_BITS, &ctx->h, SKEIN_RND_KEY_INITIAL,\r\nx_ptr);\r\nblk_ptr += SKEIN_256_BLOCK_BYTES;\r\n#define ROUND256(p0, p1, p2, p3, ROT, r_num) \\r\ndo { \\r\nX##p0 += X##p1; X##p1 = rotl_64(X##p1, ROT##_0); X##p1 ^= X##p0; \\r\nX##p2 += X##p3; X##p3 = rotl_64(X##p3, ROT##_1); X##p3 ^= X##p2; \\r\n} while (0)\r\n#if SKEIN_UNROLL_256 == 0\r\n#define R256(p0, p1, p2, p3, ROT, r_num) \\r\ndo { \\r\nROUND256(p0, p1, p2, p3, ROT, r_num); \\r\nskein_show_r_ptr(BLK_BITS, &ctx->h, r_num, X_ptr); \\r\n} while (0)\r\n#define I256(R) \\r\ndo { \\r\n\\r\nX0 += ks[((R)+1) % 5]; \\r\nX1 += ks[((R)+2) % 5] + ts[((R)+1) % 3]; \\r\nX2 += ks[((R)+3) % 5] + ts[((R)+2) % 3]; \\r\nX3 += ks[((R)+4) % 5] + (R)+1; \\r\nskein_show_r_ptr(BLK_BITS, &ctx->h, SKEIN_RND_KEY_INJECT, X_ptr); \\r\n} while (0)\r\n#else\r\n#define R256(p0, p1, p2, p3, ROT, r_num) \\r\ndo { \\r\nROUND256(p0, p1, p2, p3, ROT, r_num); \\r\nskein_show_r_ptr(BLK_BITS, &ctx->h, 4 * (r - 1) + r_num, X_ptr); \\r\n} while (0)\r\n#define I256(R) \\r\ndo { \\r\n\\r\nX0 += ks[r+(R)+0]; \\r\nX1 += ks[r+(R)+1] + ts[r+(R)+0]; \\r\nX2 += ks[r+(R)+2] + ts[r+(R)+1]; \\r\nX3 += ks[r+(R)+3] + r+(R); \\r\n\\r\nks[r + (R) + 4] = ks[r + (R) - 1]; \\r\nts[r + (R) + 2] = ts[r + (R) - 1]; \\r\nskein_show_r_ptr(BLK_BITS, &ctx->h, SKEIN_RND_KEY_INJECT, X_ptr); \\r\n} while (0)\r\nfor (r = 1; r < 2 * RCNT; r += 2 * SKEIN_UNROLL_256)\r\n#endif\r\n{\r\n#define R256_8_ROUNDS(R) \\r\ndo { \\r\nR256(0, 1, 2, 3, R_256_0, 8 * (R) + 1); \\r\nR256(0, 3, 2, 1, R_256_1, 8 * (R) + 2); \\r\nR256(0, 1, 2, 3, R_256_2, 8 * (R) + 3); \\r\nR256(0, 3, 2, 1, R_256_3, 8 * (R) + 4); \\r\nI256(2 * (R)); \\r\nR256(0, 1, 2, 3, R_256_4, 8 * (R) + 5); \\r\nR256(0, 3, 2, 1, R_256_5, 8 * (R) + 6); \\r\nR256(0, 1, 2, 3, R_256_6, 8 * (R) + 7); \\r\nR256(0, 3, 2, 1, R_256_7, 8 * (R) + 8); \\r\nI256(2 * (R) + 1); \\r\n} while (0)\r\nR256_8_ROUNDS(0);\r\n#define R256_UNROLL_R(NN) \\r\n((SKEIN_UNROLL_256 == 0 && \\r\nSKEIN_256_ROUNDS_TOTAL/8 > (NN)) || \\r\n(SKEIN_UNROLL_256 > (NN)))\r\n#if R256_UNROLL_R(1)\r\nR256_8_ROUNDS(1);\r\n#endif\r\n#if R256_UNROLL_R(2)\r\nR256_8_ROUNDS(2);\r\n#endif\r\n#if R256_UNROLL_R(3)\r\nR256_8_ROUNDS(3);\r\n#endif\r\n#if R256_UNROLL_R(4)\r\nR256_8_ROUNDS(4);\r\n#endif\r\n#if R256_UNROLL_R(5)\r\nR256_8_ROUNDS(5);\r\n#endif\r\n#if R256_UNROLL_R(6)\r\nR256_8_ROUNDS(6);\r\n#endif\r\n#if R256_UNROLL_R(7)\r\nR256_8_ROUNDS(7);\r\n#endif\r\n#if R256_UNROLL_R(8)\r\nR256_8_ROUNDS(8);\r\n#endif\r\n#if R256_UNROLL_R(9)\r\nR256_8_ROUNDS(9);\r\n#endif\r\n#if R256_UNROLL_R(10)\r\nR256_8_ROUNDS(10);\r\n#endif\r\n#if R256_UNROLL_R(11)\r\nR256_8_ROUNDS(11);\r\n#endif\r\n#if R256_UNROLL_R(12)\r\nR256_8_ROUNDS(12);\r\n#endif\r\n#if R256_UNROLL_R(13)\r\nR256_8_ROUNDS(13);\r\n#endif\r\n#if R256_UNROLL_R(14)\r\nR256_8_ROUNDS(14);\r\n#endif\r\n#if (SKEIN_UNROLL_256 > 14)\r\n#error "need more unrolling in skein_256_process_block"\r\n#endif\r\n}\r\nctx->x[0] = X0 ^ w[0];\r\nctx->x[1] = X1 ^ w[1];\r\nctx->x[2] = X2 ^ w[2];\r\nctx->x[3] = X3 ^ w[3];\r\nskein_show_round(BLK_BITS, &ctx->h, SKEIN_RND_FEED_FWD, ctx->x);\r\nts[1] &= ~SKEIN_T1_FLAG_FIRST;\r\n} while (--blk_cnt);\r\nctx->h.tweak[0] = ts[0];\r\nctx->h.tweak[1] = ts[1];\r\n}\r\nsize_t skein_256_process_block_code_size(void)\r\n{\r\nreturn ((u8 *) skein_256_process_block_code_size) -\r\n((u8 *) skein_256_process_block);\r\n}\r\nunsigned int skein_256_unroll_cnt(void)\r\n{\r\nreturn SKEIN_UNROLL_256;\r\n}\r\nvoid skein_512_process_block(struct skein_512_ctx *ctx, const u8 *blk_ptr,\r\nsize_t blk_cnt, size_t byte_cnt_add)\r\n{\r\nenum {\r\nWCNT = SKEIN_512_STATE_WORDS\r\n};\r\n#undef RCNT\r\n#define RCNT (SKEIN_512_ROUNDS_TOTAL/8)\r\n#ifdef SKEIN_LOOP\r\n#define SKEIN_UNROLL_512 (((SKEIN_LOOP)/10)%10)\r\n#else\r\n#define SKEIN_UNROLL_512 (0)\r\n#endif\r\n#if SKEIN_UNROLL_512\r\n#if (RCNT % SKEIN_UNROLL_512)\r\n#error "Invalid SKEIN_UNROLL_512"\r\n#endif\r\nsize_t r;\r\nu64 kw[WCNT+4+RCNT*2];\r\n#else\r\nu64 kw[WCNT+4];\r\n#endif\r\nu64 X0, X1, X2, X3, X4, X5, X6, X7;\r\nu64 w[WCNT];\r\n#ifdef SKEIN_DEBUG\r\nconst u64 *X_ptr[8];\r\nX_ptr[0] = &X0; X_ptr[1] = &X1; X_ptr[2] = &X2; X_ptr[3] = &X3;\r\nX_ptr[4] = &X4; X_ptr[5] = &X5; X_ptr[6] = &X6; X_ptr[7] = &X7;\r\n#endif\r\nskein_assert(blk_cnt != 0);\r\nts[0] = ctx->h.tweak[0];\r\nts[1] = ctx->h.tweak[1];\r\ndo {\r\nts[0] += byte_cnt_add;\r\nks[0] = ctx->x[0];\r\nks[1] = ctx->x[1];\r\nks[2] = ctx->x[2];\r\nks[3] = ctx->x[3];\r\nks[4] = ctx->x[4];\r\nks[5] = ctx->x[5];\r\nks[6] = ctx->x[6];\r\nks[7] = ctx->x[7];\r\nks[8] = ks[0] ^ ks[1] ^ ks[2] ^ ks[3] ^\r\nks[4] ^ ks[5] ^ ks[6] ^ ks[7] ^ SKEIN_KS_PARITY;\r\nts[2] = ts[0] ^ ts[1];\r\nskein_get64_lsb_first(w, blk_ptr, WCNT);\r\ndebug_save_tweak(ctx);\r\nskein_show_block(BLK_BITS, &ctx->h, ctx->x, blk_ptr, w, ks, ts);\r\nX0 = w[0] + ks[0];\r\nX1 = w[1] + ks[1];\r\nX2 = w[2] + ks[2];\r\nX3 = w[3] + ks[3];\r\nX4 = w[4] + ks[4];\r\nX5 = w[5] + ks[5] + ts[0];\r\nX6 = w[6] + ks[6] + ts[1];\r\nX7 = w[7] + ks[7];\r\nblk_ptr += SKEIN_512_BLOCK_BYTES;\r\nskein_show_r_ptr(BLK_BITS, &ctx->h, SKEIN_RND_KEY_INITIAL,\r\nX_ptr);\r\n#define ROUND512(p0, p1, p2, p3, p4, p5, p6, p7, ROT, r_num) \\r\ndo { \\r\nX##p0 += X##p1; X##p1 = rotl_64(X##p1, ROT##_0); X##p1 ^= X##p0; \\r\nX##p2 += X##p3; X##p3 = rotl_64(X##p3, ROT##_1); X##p3 ^= X##p2; \\r\nX##p4 += X##p5; X##p5 = rotl_64(X##p5, ROT##_2); X##p5 ^= X##p4; \\r\nX##p6 += X##p7; X##p7 = rotl_64(X##p7, ROT##_3); X##p7 ^= X##p6; \\r\n} while (0)\r\n#if SKEIN_UNROLL_512 == 0\r\n#define R512(p0, p1, p2, p3, p4, p5, p6, p7, ROT, r_num) \\r\ndo { \\r\nROUND512(p0, p1, p2, p3, p4, p5, p6, p7, ROT, r_num) \\r\nskein_show_r_ptr(BLK_BITS, &ctx->h, r_num, X_ptr); \\r\n} while (0)\r\n#define I512(R) \\r\ndo { \\r\n\\r\nX0 += ks[((R) + 1) % 9]; \\r\nX1 += ks[((R) + 2) % 9]; \\r\nX2 += ks[((R) + 3) % 9]; \\r\nX3 += ks[((R) + 4) % 9]; \\r\nX4 += ks[((R) + 5) % 9]; \\r\nX5 += ks[((R) + 6) % 9] + ts[((R) + 1) % 3]; \\r\nX6 += ks[((R) + 7) % 9] + ts[((R) + 2) % 3]; \\r\nX7 += ks[((R) + 8) % 9] + (R) + 1; \\r\nskein_show_r_ptr(BLK_BITS, &ctx->h, SKEIN_RND_KEY_INJECT, X_ptr); \\r\n} while (0)\r\n#else\r\n#define R512(p0, p1, p2, p3, p4, p5, p6, p7, ROT, r_num) \\r\ndo { \\r\nROUND512(p0, p1, p2, p3, p4, p5, p6, p7, ROT, r_num); \\r\nskein_show_r_ptr(BLK_BITS, &ctx->h, 4 * (r - 1) + r_num, X_ptr); \\r\n} while (0)\r\n#define I512(R) \\r\ndo { \\r\n\\r\nX0 += ks[r + (R) + 0]; \\r\nX1 += ks[r + (R) + 1]; \\r\nX2 += ks[r + (R) + 2]; \\r\nX3 += ks[r + (R) + 3]; \\r\nX4 += ks[r + (R) + 4]; \\r\nX5 += ks[r + (R) + 5] + ts[r + (R) + 0]; \\r\nX6 += ks[r + (R) + 6] + ts[r + (R) + 1]; \\r\nX7 += ks[r + (R) + 7] + r + (R); \\r\n\\r\nks[r + (R) + 8] = ks[r + (R) - 1]; \\r\nts[r + (R) + 2] = ts[r + (R) - 1]; \\r\nskein_show_r_ptr(BLK_BITS, &ctx->h, SKEIN_RND_KEY_INJECT, X_ptr); \\r\n} while (0)\r\nfor (r = 1; r < 2 * RCNT; r += 2 * SKEIN_UNROLL_512)\r\n#endif\r\n{\r\n#define R512_8_ROUNDS(R) \\r\ndo { \\r\nR512(0, 1, 2, 3, 4, 5, 6, 7, R_512_0, 8 * (R) + 1); \\r\nR512(2, 1, 4, 7, 6, 5, 0, 3, R_512_1, 8 * (R) + 2); \\r\nR512(4, 1, 6, 3, 0, 5, 2, 7, R_512_2, 8 * (R) + 3); \\r\nR512(6, 1, 0, 7, 2, 5, 4, 3, R_512_3, 8 * (R) + 4); \\r\nI512(2 * (R)); \\r\nR512(0, 1, 2, 3, 4, 5, 6, 7, R_512_4, 8 * (R) + 5); \\r\nR512(2, 1, 4, 7, 6, 5, 0, 3, R_512_5, 8 * (R) + 6); \\r\nR512(4, 1, 6, 3, 0, 5, 2, 7, R_512_6, 8 * (R) + 7); \\r\nR512(6, 1, 0, 7, 2, 5, 4, 3, R_512_7, 8 * (R) + 8); \\r\nI512(2 * (R) + 1); \\r\n} while (0)\r\nR512_8_ROUNDS(0);\r\n#define R512_UNROLL_R(NN) \\r\n((SKEIN_UNROLL_512 == 0 && \\r\nSKEIN_512_ROUNDS_TOTAL/8 > (NN)) || \\r\n(SKEIN_UNROLL_512 > (NN)))\r\n#if R512_UNROLL_R(1)\r\nR512_8_ROUNDS(1);\r\n#endif\r\n#if R512_UNROLL_R(2)\r\nR512_8_ROUNDS(2);\r\n#endif\r\n#if R512_UNROLL_R(3)\r\nR512_8_ROUNDS(3);\r\n#endif\r\n#if R512_UNROLL_R(4)\r\nR512_8_ROUNDS(4);\r\n#endif\r\n#if R512_UNROLL_R(5)\r\nR512_8_ROUNDS(5);\r\n#endif\r\n#if R512_UNROLL_R(6)\r\nR512_8_ROUNDS(6);\r\n#endif\r\n#if R512_UNROLL_R(7)\r\nR512_8_ROUNDS(7);\r\n#endif\r\n#if R512_UNROLL_R(8)\r\nR512_8_ROUNDS(8);\r\n#endif\r\n#if R512_UNROLL_R(9)\r\nR512_8_ROUNDS(9);\r\n#endif\r\n#if R512_UNROLL_R(10)\r\nR512_8_ROUNDS(10);\r\n#endif\r\n#if R512_UNROLL_R(11)\r\nR512_8_ROUNDS(11);\r\n#endif\r\n#if R512_UNROLL_R(12)\r\nR512_8_ROUNDS(12);\r\n#endif\r\n#if R512_UNROLL_R(13)\r\nR512_8_ROUNDS(13);\r\n#endif\r\n#if R512_UNROLL_R(14)\r\nR512_8_ROUNDS(14);\r\n#endif\r\n#if (SKEIN_UNROLL_512 > 14)\r\n#error "need more unrolling in skein_512_process_block"\r\n#endif\r\n}\r\nctx->x[0] = X0 ^ w[0];\r\nctx->x[1] = X1 ^ w[1];\r\nctx->x[2] = X2 ^ w[2];\r\nctx->x[3] = X3 ^ w[3];\r\nctx->x[4] = X4 ^ w[4];\r\nctx->x[5] = X5 ^ w[5];\r\nctx->x[6] = X6 ^ w[6];\r\nctx->x[7] = X7 ^ w[7];\r\nskein_show_round(BLK_BITS, &ctx->h, SKEIN_RND_FEED_FWD, ctx->x);\r\nts[1] &= ~SKEIN_T1_FLAG_FIRST;\r\n} while (--blk_cnt);\r\nctx->h.tweak[0] = ts[0];\r\nctx->h.tweak[1] = ts[1];\r\n}\r\nsize_t skein_512_process_block_code_size(void)\r\n{\r\nreturn ((u8 *) skein_512_process_block_code_size) -\r\n((u8 *) skein_512_process_block);\r\n}\r\nunsigned int skein_512_unroll_cnt(void)\r\n{\r\nreturn SKEIN_UNROLL_512;\r\n}\r\nvoid skein_1024_process_block(struct skein_1024_ctx *ctx, const u8 *blk_ptr,\r\nsize_t blk_cnt, size_t byte_cnt_add)\r\n{\r\nenum {\r\nWCNT = SKEIN_1024_STATE_WORDS\r\n};\r\n#undef RCNT\r\n#define RCNT (SKEIN_1024_ROUNDS_TOTAL/8)\r\n#ifdef SKEIN_LOOP\r\n#define SKEIN_UNROLL_1024 ((SKEIN_LOOP)%10)\r\n#else\r\n#define SKEIN_UNROLL_1024 (0)\r\n#endif\r\n#if (SKEIN_UNROLL_1024 != 0)\r\n#if (RCNT % SKEIN_UNROLL_1024)\r\n#error "Invalid SKEIN_UNROLL_1024"\r\n#endif\r\nsize_t r;\r\nu64 kw[WCNT+4+RCNT*2];\r\n#else\r\nu64 kw[WCNT+4];\r\n#endif\r\nu64 X00, X01, X02, X03, X04, X05, X06, X07,\r\nX08, X09, X10, X11, X12, X13, X14, X15;\r\nu64 w[WCNT];\r\n#ifdef SKEIN_DEBUG\r\nconst u64 *X_ptr[16];\r\nX_ptr[0] = &X00; X_ptr[1] = &X01; X_ptr[2] = &X02;\r\nX_ptr[3] = &X03; X_ptr[4] = &X04; X_ptr[5] = &X05;\r\nX_ptr[6] = &X06; X_ptr[7] = &X07; X_ptr[8] = &X08;\r\nX_ptr[9] = &X09; X_ptr[10] = &X10; X_ptr[11] = &X11;\r\nX_ptr[12] = &X12; X_ptr[13] = &X13; X_ptr[14] = &X14;\r\nX_ptr[15] = &X15;\r\n#endif\r\nskein_assert(blk_cnt != 0);\r\nts[0] = ctx->h.tweak[0];\r\nts[1] = ctx->h.tweak[1];\r\ndo {\r\nts[0] += byte_cnt_add;\r\nks[0] = ctx->x[0];\r\nks[1] = ctx->x[1];\r\nks[2] = ctx->x[2];\r\nks[3] = ctx->x[3];\r\nks[4] = ctx->x[4];\r\nks[5] = ctx->x[5];\r\nks[6] = ctx->x[6];\r\nks[7] = ctx->x[7];\r\nks[8] = ctx->x[8];\r\nks[9] = ctx->x[9];\r\nks[10] = ctx->x[10];\r\nks[11] = ctx->x[11];\r\nks[12] = ctx->x[12];\r\nks[13] = ctx->x[13];\r\nks[14] = ctx->x[14];\r\nks[15] = ctx->x[15];\r\nks[16] = ks[0] ^ ks[1] ^ ks[2] ^ ks[3] ^\r\nks[4] ^ ks[5] ^ ks[6] ^ ks[7] ^\r\nks[8] ^ ks[9] ^ ks[10] ^ ks[11] ^\r\nks[12] ^ ks[13] ^ ks[14] ^ ks[15] ^ SKEIN_KS_PARITY;\r\nts[2] = ts[0] ^ ts[1];\r\nskein_get64_lsb_first(w, blk_ptr, WCNT);\r\ndebug_save_tweak(ctx);\r\nskein_show_block(BLK_BITS, &ctx->h, ctx->x, blk_ptr, w, ks, ts);\r\nX00 = w[0] + ks[0];\r\nX01 = w[1] + ks[1];\r\nX02 = w[2] + ks[2];\r\nX03 = w[3] + ks[3];\r\nX04 = w[4] + ks[4];\r\nX05 = w[5] + ks[5];\r\nX06 = w[6] + ks[6];\r\nX07 = w[7] + ks[7];\r\nX08 = w[8] + ks[8];\r\nX09 = w[9] + ks[9];\r\nX10 = w[10] + ks[10];\r\nX11 = w[11] + ks[11];\r\nX12 = w[12] + ks[12];\r\nX13 = w[13] + ks[13] + ts[0];\r\nX14 = w[14] + ks[14] + ts[1];\r\nX15 = w[15] + ks[15];\r\nskein_show_r_ptr(BLK_BITS, &ctx->h, SKEIN_RND_KEY_INITIAL,\r\nX_ptr);\r\n#define ROUND1024(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pA, pB, pC, pD, pE, \\r\npF, ROT, r_num) \\r\ndo { \\r\nX##p0 += X##p1; X##p1 = rotl_64(X##p1, ROT##_0); X##p1 ^= X##p0; \\r\nX##p2 += X##p3; X##p3 = rotl_64(X##p3, ROT##_1); X##p3 ^= X##p2; \\r\nX##p4 += X##p5; X##p5 = rotl_64(X##p5, ROT##_2); X##p5 ^= X##p4; \\r\nX##p6 += X##p7; X##p7 = rotl_64(X##p7, ROT##_3); X##p7 ^= X##p6; \\r\nX##p8 += X##p9; X##p9 = rotl_64(X##p9, ROT##_4); X##p9 ^= X##p8; \\r\nX##pA += X##pB; X##pB = rotl_64(X##pB, ROT##_5); X##pB ^= X##pA; \\r\nX##pC += X##pD; X##pD = rotl_64(X##pD, ROT##_6); X##pD ^= X##pC; \\r\nX##pE += X##pF; X##pF = rotl_64(X##pF, ROT##_7); X##pF ^= X##pE; \\r\n} while (0)\r\n#if SKEIN_UNROLL_1024 == 0\r\n#define R1024(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pA, pB, pC, pD, pE, pF, \\r\nROT, rn) \\r\ndo { \\r\nROUND1024(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pA, pB, pC, pD, pE, \\r\npF, ROT, rn); \\r\nskein_show_r_ptr(BLK_BITS, &ctx->h, rn, X_ptr); \\r\n} while (0)\r\n#define I1024(R) \\r\ndo { \\r\n\\r\nX00 += ks[((R) + 1) % 17]; \\r\nX01 += ks[((R) + 2) % 17]; \\r\nX02 += ks[((R) + 3) % 17]; \\r\nX03 += ks[((R) + 4) % 17]; \\r\nX04 += ks[((R) + 5) % 17]; \\r\nX05 += ks[((R) + 6) % 17]; \\r\nX06 += ks[((R) + 7) % 17]; \\r\nX07 += ks[((R) + 8) % 17]; \\r\nX08 += ks[((R) + 9) % 17]; \\r\nX09 += ks[((R) + 10) % 17]; \\r\nX10 += ks[((R) + 11) % 17]; \\r\nX11 += ks[((R) + 12) % 17]; \\r\nX12 += ks[((R) + 13) % 17]; \\r\nX13 += ks[((R) + 14) % 17] + ts[((R) + 1) % 3]; \\r\nX14 += ks[((R) + 15) % 17] + ts[((R) + 2) % 3]; \\r\nX15 += ks[((R) + 16) % 17] + (R) + 1; \\r\nskein_show_r_ptr(BLK_BITS, &ctx->h, SKEIN_RND_KEY_INJECT, X_ptr); \\r\n} while (0)\r\n#else\r\n#define R1024(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pA, pB, pC, pD, pE, pF, \\r\nROT, rn) \\r\ndo { \\r\nROUND1024(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pA, pB, pC, pD, pE, \\r\npF, ROT, rn); \\r\nskein_show_r_ptr(BLK_BITS, &ctx->h, 4 * (r - 1) + rn, X_ptr); \\r\n} while (0)\r\n#define I1024(R) \\r\ndo { \\r\n\\r\nX00 += ks[r + (R) + 0]; \\r\nX01 += ks[r + (R) + 1]; \\r\nX02 += ks[r + (R) + 2]; \\r\nX03 += ks[r + (R) + 3]; \\r\nX04 += ks[r + (R) + 4]; \\r\nX05 += ks[r + (R) + 5]; \\r\nX06 += ks[r + (R) + 6]; \\r\nX07 += ks[r + (R) + 7]; \\r\nX08 += ks[r + (R) + 8]; \\r\nX09 += ks[r + (R) + 9]; \\r\nX10 += ks[r + (R) + 10]; \\r\nX11 += ks[r + (R) + 11]; \\r\nX12 += ks[r + (R) + 12]; \\r\nX13 += ks[r + (R) + 13] + ts[r + (R) + 0]; \\r\nX14 += ks[r + (R) + 14] + ts[r + (R) + 1]; \\r\nX15 += ks[r + (R) + 15] + r + (R); \\r\n\\r\nks[r + (R) + 16] = ks[r + (R) - 1]; \\r\nts[r + (R) + 2] = ts[r + (R) - 1]; \\r\nskein_show_r_ptr(BLK_BITSi, &ctx->h, SKEIN_RND_KEY_INJECT, X_ptr); \\r\n} while (0)\r\nfor (r = 1; r <= 2 * RCNT; r += 2 * SKEIN_UNROLL_1024)\r\n#endif\r\n{\r\n#define R1024_8_ROUNDS(R) \\r\ndo { \\r\nR1024(00, 01, 02, 03, 04, 05, 06, 07, 08, 09, 10, 11, 12, 13, 14, 15, \\r\nR1024_0, 8*(R) + 1); \\r\nR1024(00, 09, 02, 13, 06, 11, 04, 15, 10, 07, 12, 03, 14, 05, 08, 01, \\r\nR1024_1, 8*(R) + 2); \\r\nR1024(00, 07, 02, 05, 04, 03, 06, 01, 12, 15, 14, 13, 08, 11, 10, 09, \\r\nR1024_2, 8*(R) + 3); \\r\nR1024(00, 15, 02, 11, 06, 13, 04, 09, 14, 01, 08, 05, 10, 03, 12, 07, \\r\nR1024_3, 8*(R) + 4); \\r\nI1024(2*(R)); \\r\nR1024(00, 01, 02, 03, 04, 05, 06, 07, 08, 09, 10, 11, 12, 13, 14, 15, \\r\nR1024_4, 8*(R) + 5); \\r\nR1024(00, 09, 02, 13, 06, 11, 04, 15, 10, 07, 12, 03, 14, 05, 08, 01, \\r\nR1024_5, 8*(R) + 6); \\r\nR1024(00, 07, 02, 05, 04, 03, 06, 01, 12, 15, 14, 13, 08, 11, 10, 09, \\r\nR1024_6, 8*(R) + 7); \\r\nR1024(00, 15, 02, 11, 06, 13, 04, 09, 14, 01, 08, 05, 10, 03, 12, 07, \\r\nR1024_7, 8*(R) + 8); \\r\nI1024(2*(R)+1); \\r\n} while (0)\r\nR1024_8_ROUNDS(0);\r\n#define R1024_UNROLL_R(NN) \\r\n((SKEIN_UNROLL_1024 == 0 && \\r\nSKEIN_1024_ROUNDS_TOTAL/8 > (NN)) || \\r\n(SKEIN_UNROLL_1024 > (NN)))\r\n#if R1024_UNROLL_R(1)\r\nR1024_8_ROUNDS(1);\r\n#endif\r\n#if R1024_UNROLL_R(2)\r\nR1024_8_ROUNDS(2);\r\n#endif\r\n#if R1024_UNROLL_R(3)\r\nR1024_8_ROUNDS(3);\r\n#endif\r\n#if R1024_UNROLL_R(4)\r\nR1024_8_ROUNDS(4);\r\n#endif\r\n#if R1024_UNROLL_R(5)\r\nR1024_8_ROUNDS(5);\r\n#endif\r\n#if R1024_UNROLL_R(6)\r\nR1024_8_ROUNDS(6);\r\n#endif\r\n#if R1024_UNROLL_R(7)\r\nR1024_8_ROUNDS(7);\r\n#endif\r\n#if R1024_UNROLL_R(8)\r\nR1024_8_ROUNDS(8);\r\n#endif\r\n#if R1024_UNROLL_R(9)\r\nR1024_8_ROUNDS(9);\r\n#endif\r\n#if R1024_UNROLL_R(10)\r\nR1024_8_ROUNDS(10);\r\n#endif\r\n#if R1024_UNROLL_R(11)\r\nR1024_8_ROUNDS(11);\r\n#endif\r\n#if R1024_UNROLL_R(12)\r\nR1024_8_ROUNDS(12);\r\n#endif\r\n#if R1024_UNROLL_R(13)\r\nR1024_8_ROUNDS(13);\r\n#endif\r\n#if R1024_UNROLL_R(14)\r\nR1024_8_ROUNDS(14);\r\n#endif\r\n#if (SKEIN_UNROLL_1024 > 14)\r\n#error "need more unrolling in Skein_1024_Process_Block"\r\n#endif\r\n}\r\nctx->x[0] = X00 ^ w[0];\r\nctx->x[1] = X01 ^ w[1];\r\nctx->x[2] = X02 ^ w[2];\r\nctx->x[3] = X03 ^ w[3];\r\nctx->x[4] = X04 ^ w[4];\r\nctx->x[5] = X05 ^ w[5];\r\nctx->x[6] = X06 ^ w[6];\r\nctx->x[7] = X07 ^ w[7];\r\nctx->x[8] = X08 ^ w[8];\r\nctx->x[9] = X09 ^ w[9];\r\nctx->x[10] = X10 ^ w[10];\r\nctx->x[11] = X11 ^ w[11];\r\nctx->x[12] = X12 ^ w[12];\r\nctx->x[13] = X13 ^ w[13];\r\nctx->x[14] = X14 ^ w[14];\r\nctx->x[15] = X15 ^ w[15];\r\nskein_show_round(BLK_BITS, &ctx->h, SKEIN_RND_FEED_FWD, ctx->x);\r\nts[1] &= ~SKEIN_T1_FLAG_FIRST;\r\nblk_ptr += SKEIN_1024_BLOCK_BYTES;\r\n} while (--blk_cnt);\r\nctx->h.tweak[0] = ts[0];\r\nctx->h.tweak[1] = ts[1];\r\n}\r\nsize_t skein_1024_process_block_code_size(void)\r\n{\r\nreturn ((u8 *) skein_1024_process_block_code_size) -\r\n((u8 *) skein_1024_process_block);\r\n}\r\nunsigned int skein_1024_unroll_cnt(void)\r\n{\r\nreturn SKEIN_UNROLL_1024;\r\n}
