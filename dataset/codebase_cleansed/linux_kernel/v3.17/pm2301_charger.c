static void set_lpn_pin(struct pm2xxx_charger *pm2)\r\n{\r\nif (!pm2->ac.charger_connected && gpio_is_valid(pm2->lpn_pin)) {\r\ngpio_set_value(pm2->lpn_pin, 1);\r\nusleep_range(SLEEP_MIN, SLEEP_MAX);\r\n}\r\n}\r\nstatic void clear_lpn_pin(struct pm2xxx_charger *pm2)\r\n{\r\nif (!pm2->ac.charger_connected && gpio_is_valid(pm2->lpn_pin))\r\ngpio_set_value(pm2->lpn_pin, 0);\r\n}\r\nstatic int pm2xxx_reg_read(struct pm2xxx_charger *pm2, int reg, u8 *val)\r\n{\r\nint ret;\r\npm_runtime_get_sync(pm2->dev);\r\nret = i2c_smbus_read_i2c_block_data(pm2->config.pm2xxx_i2c, reg,\r\n1, val);\r\nif (ret < 0)\r\ndev_err(pm2->dev, "Error reading register at 0x%x\n", reg);\r\nelse\r\nret = 0;\r\npm_runtime_put_sync(pm2->dev);\r\nreturn ret;\r\n}\r\nstatic int pm2xxx_reg_write(struct pm2xxx_charger *pm2, int reg, u8 val)\r\n{\r\nint ret;\r\npm_runtime_get_sync(pm2->dev);\r\nret = i2c_smbus_write_i2c_block_data(pm2->config.pm2xxx_i2c, reg,\r\n1, &val);\r\nif (ret < 0)\r\ndev_err(pm2->dev, "Error writing register at 0x%x\n", reg);\r\nelse\r\nret = 0;\r\npm_runtime_put_sync(pm2->dev);\r\nreturn ret;\r\n}\r\nstatic int pm2xxx_charging_enable_mngt(struct pm2xxx_charger *pm2)\r\n{\r\nint ret;\r\nret = pm2xxx_reg_write(pm2, PM2XXX_BATT_CTRL_REG2,\r\n(PM2XXX_CH_AUTO_RESUME_EN | PM2XXX_CHARGER_ENA));\r\nreturn ret;\r\n}\r\nstatic int pm2xxx_charging_disable_mngt(struct pm2xxx_charger *pm2)\r\n{\r\nint ret;\r\nret = pm2xxx_reg_write(pm2, PM2XXX_SW_CTRL_REG, PM2XXX_SWCTRL_HW);\r\nif (ret < 0) {\r\ndev_err(pm2->dev, "%s pm2xxx write failed\n", __func__);\r\nreturn ret;\r\n}\r\nret = pm2xxx_reg_write(pm2, PM2XXX_BATT_CTRL_REG2,\r\n(PM2XXX_CH_AUTO_RESUME_DIS | PM2XXX_CHARGER_DIS));\r\nif (ret < 0) {\r\ndev_err(pm2->dev, "%s pm2xxx write failed\n", __func__);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm2xxx_charger_batt_therm_mngt(struct pm2xxx_charger *pm2, int val)\r\n{\r\nqueue_work(pm2->charger_wq, &pm2->check_main_thermal_prot_work);\r\nreturn 0;\r\n}\r\nstatic int pm2xxx_charger_die_therm_mngt(struct pm2xxx_charger *pm2, int val)\r\n{\r\nqueue_work(pm2->charger_wq, &pm2->check_main_thermal_prot_work);\r\nreturn 0;\r\n}\r\nstatic int pm2xxx_charger_ovv_mngt(struct pm2xxx_charger *pm2, int val)\r\n{\r\ndev_err(pm2->dev, "Overvoltage detected\n");\r\npm2->flags.ovv = true;\r\npower_supply_changed(&pm2->ac_chg.psy);\r\nqueue_delayed_work(pm2->charger_wq, &pm2->check_hw_failure_work, 0);\r\nreturn 0;\r\n}\r\nstatic int pm2xxx_charger_wd_exp_mngt(struct pm2xxx_charger *pm2, int val)\r\n{\r\ndev_dbg(pm2->dev , "20 minutes watchdog expired\n");\r\npm2->ac.wd_expired = true;\r\npower_supply_changed(&pm2->ac_chg.psy);\r\nreturn 0;\r\n}\r\nstatic int pm2xxx_charger_vbat_lsig_mngt(struct pm2xxx_charger *pm2, int val)\r\n{\r\nint ret;\r\nswitch (val) {\r\ncase PM2XXX_INT1_ITVBATLOWR:\r\ndev_dbg(pm2->dev, "VBAT grows above VBAT_LOW level\n");\r\nret = pm2xxx_reg_write(pm2, PM2XXX_SW_CTRL_REG,\r\nPM2XXX_SWCTRL_SW);\r\nif (ret < 0) {\r\ndev_err(pm2->dev, "%s pm2xxx write failed\n", __func__);\r\nreturn ret;\r\n}\r\nbreak;\r\ncase PM2XXX_INT1_ITVBATLOWF:\r\ndev_dbg(pm2->dev, "VBAT drops below VBAT_LOW level\n");\r\nret = pm2xxx_reg_write(pm2, PM2XXX_SW_CTRL_REG,\r\nPM2XXX_SWCTRL_HW);\r\nif (ret < 0) {\r\ndev_err(pm2->dev, "%s pm2xxx write failed\n", __func__);\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(pm2->dev, "Unknown VBAT level\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm2xxx_charger_bat_disc_mngt(struct pm2xxx_charger *pm2, int val)\r\n{\r\ndev_dbg(pm2->dev, "battery disconnected\n");\r\nreturn 0;\r\n}\r\nstatic int pm2xxx_charger_detection(struct pm2xxx_charger *pm2, u8 *val)\r\n{\r\nint ret;\r\nret = pm2xxx_reg_read(pm2, PM2XXX_SRCE_REG_INT2, val);\r\nif (ret < 0) {\r\ndev_err(pm2->dev, "Charger detection failed\n");\r\ngoto out;\r\n}\r\n*val &= (PM2XXX_INT2_S_ITVPWR1PLUG | PM2XXX_INT2_S_ITVPWR2PLUG);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int pm2xxx_charger_itv_pwr_plug_mngt(struct pm2xxx_charger *pm2, int val)\r\n{\r\nint ret;\r\nu8 read_val;\r\nret = pm2xxx_charger_detection(pm2, &read_val);\r\nif ((ret == 0) && read_val) {\r\npm2->ac.charger_connected = 1;\r\npm2->ac_conn = true;\r\nqueue_work(pm2->charger_wq, &pm2->ac_work);\r\n}\r\nreturn ret;\r\n}\r\nstatic int pm2xxx_charger_itv_pwr_unplug_mngt(struct pm2xxx_charger *pm2,\r\nint val)\r\n{\r\npm2->ac.charger_connected = 0;\r\nqueue_work(pm2->charger_wq, &pm2->ac_work);\r\nreturn 0;\r\n}\r\nstatic int pm2_int_reg0(void *pm2_data, int val)\r\n{\r\nstruct pm2xxx_charger *pm2 = pm2_data;\r\nint ret = 0;\r\nif (val & PM2XXX_INT1_ITVBATLOWR) {\r\nret = pm2xxx_charger_vbat_lsig_mngt(pm2,\r\nPM2XXX_INT1_ITVBATLOWR);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nif (val & PM2XXX_INT1_ITVBATLOWF) {\r\nret = pm2xxx_charger_vbat_lsig_mngt(pm2,\r\nPM2XXX_INT1_ITVBATLOWF);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nif (val & PM2XXX_INT1_ITVBATDISCONNECT) {\r\nret = pm2xxx_charger_bat_disc_mngt(pm2,\r\nPM2XXX_INT1_ITVBATDISCONNECT);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int pm2_int_reg1(void *pm2_data, int val)\r\n{\r\nstruct pm2xxx_charger *pm2 = pm2_data;\r\nint ret = 0;\r\nif (val & (PM2XXX_INT2_ITVPWR1PLUG | PM2XXX_INT2_ITVPWR2PLUG)) {\r\ndev_dbg(pm2->dev , "Main charger plugged\n");\r\nret = pm2xxx_charger_itv_pwr_plug_mngt(pm2, val &\r\n(PM2XXX_INT2_ITVPWR1PLUG | PM2XXX_INT2_ITVPWR2PLUG));\r\n}\r\nif (val &\r\n(PM2XXX_INT2_ITVPWR1UNPLUG | PM2XXX_INT2_ITVPWR2UNPLUG)) {\r\ndev_dbg(pm2->dev , "Main charger unplugged\n");\r\nret = pm2xxx_charger_itv_pwr_unplug_mngt(pm2, val &\r\n(PM2XXX_INT2_ITVPWR1UNPLUG |\r\nPM2XXX_INT2_ITVPWR2UNPLUG));\r\n}\r\nreturn ret;\r\n}\r\nstatic int pm2_int_reg2(void *pm2_data, int val)\r\n{\r\nstruct pm2xxx_charger *pm2 = pm2_data;\r\nint ret = 0;\r\nif (val & PM2XXX_INT3_ITAUTOTIMEOUTWD)\r\nret = pm2xxx_charger_wd_exp_mngt(pm2, val);\r\nif (val & (PM2XXX_INT3_ITCHPRECHARGEWD |\r\nPM2XXX_INT3_ITCHCCWD | PM2XXX_INT3_ITCHCVWD)) {\r\ndev_dbg(pm2->dev,\r\n"Watchdog occurred for precharge, CC and CV charge\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int pm2_int_reg3(void *pm2_data, int val)\r\n{\r\nstruct pm2xxx_charger *pm2 = pm2_data;\r\nint ret = 0;\r\nif (val & (PM2XXX_INT4_ITCHARGINGON)) {\r\ndev_dbg(pm2->dev ,\r\n"chargind operation has started\n");\r\n}\r\nif (val & (PM2XXX_INT4_ITVRESUME)) {\r\ndev_dbg(pm2->dev,\r\n"battery discharged down to VResume threshold\n");\r\n}\r\nif (val & (PM2XXX_INT4_ITBATTFULL)) {\r\ndev_dbg(pm2->dev , "battery fully detected\n");\r\n}\r\nif (val & (PM2XXX_INT4_ITCVPHASE)) {\r\ndev_dbg(pm2->dev, "CV phase enter with 0.5C charging\n");\r\n}\r\nif (val & (PM2XXX_INT4_ITVPWR2OVV | PM2XXX_INT4_ITVPWR1OVV)) {\r\npm2->failure_case = VPWR_OVV;\r\nret = pm2xxx_charger_ovv_mngt(pm2, val &\r\n(PM2XXX_INT4_ITVPWR2OVV | PM2XXX_INT4_ITVPWR1OVV));\r\ndev_dbg(pm2->dev, "VPWR/VSYSTEM overvoltage detected\n");\r\n}\r\nif (val & (PM2XXX_INT4_S_ITBATTEMPCOLD |\r\nPM2XXX_INT4_S_ITBATTEMPHOT)) {\r\nret = pm2xxx_charger_batt_therm_mngt(pm2, val &\r\n(PM2XXX_INT4_S_ITBATTEMPCOLD |\r\nPM2XXX_INT4_S_ITBATTEMPHOT));\r\ndev_dbg(pm2->dev, "BTEMP is too Low/High\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int pm2_int_reg4(void *pm2_data, int val)\r\n{\r\nstruct pm2xxx_charger *pm2 = pm2_data;\r\nint ret = 0;\r\nif (val & PM2XXX_INT5_ITVSYSTEMOVV) {\r\npm2->failure_case = VSYSTEM_OVV;\r\nret = pm2xxx_charger_ovv_mngt(pm2, val &\r\nPM2XXX_INT5_ITVSYSTEMOVV);\r\ndev_dbg(pm2->dev, "VSYSTEM overvoltage detected\n");\r\n}\r\nif (val & (PM2XXX_INT5_ITTHERMALWARNINGFALL |\r\nPM2XXX_INT5_ITTHERMALWARNINGRISE |\r\nPM2XXX_INT5_ITTHERMALSHUTDOWNFALL |\r\nPM2XXX_INT5_ITTHERMALSHUTDOWNRISE)) {\r\ndev_dbg(pm2->dev, "BTEMP die temperature is too Low/High\n");\r\nret = pm2xxx_charger_die_therm_mngt(pm2, val &\r\n(PM2XXX_INT5_ITTHERMALWARNINGFALL |\r\nPM2XXX_INT5_ITTHERMALWARNINGRISE |\r\nPM2XXX_INT5_ITTHERMALSHUTDOWNFALL |\r\nPM2XXX_INT5_ITTHERMALSHUTDOWNRISE));\r\n}\r\nreturn ret;\r\n}\r\nstatic int pm2_int_reg5(void *pm2_data, int val)\r\n{\r\nstruct pm2xxx_charger *pm2 = pm2_data;\r\nint ret = 0;\r\nif (val & (PM2XXX_INT6_ITVPWR2DROP | PM2XXX_INT6_ITVPWR1DROP)) {\r\ndev_dbg(pm2->dev, "VMPWR drop to VBAT level\n");\r\n}\r\nif (val & (PM2XXX_INT6_ITVPWR2VALIDRISE |\r\nPM2XXX_INT6_ITVPWR1VALIDRISE |\r\nPM2XXX_INT6_ITVPWR2VALIDFALL |\r\nPM2XXX_INT6_ITVPWR1VALIDFALL)) {\r\ndev_dbg(pm2->dev, "Falling/Rising edge on WPWR1/2\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t pm2xxx_irq_int(int irq, void *data)\r\n{\r\nstruct pm2xxx_charger *pm2 = data;\r\nstruct pm2xxx_interrupts *interrupt = pm2->pm2_int;\r\nint i;\r\npm_runtime_get_sync(pm2->dev);\r\ndo {\r\nfor (i = 0; i < PM2XXX_NUM_INT_REG; i++) {\r\npm2xxx_reg_read(pm2,\r\npm2xxx_interrupt_registers[i],\r\n&(interrupt->reg[i]));\r\nif (interrupt->reg[i] > 0)\r\ninterrupt->handler[i](pm2, interrupt->reg[i]);\r\n}\r\n} while (gpio_get_value(pm2->pdata->gpio_irq_number) == 0);\r\npm_runtime_mark_last_busy(pm2->dev);\r\npm_runtime_put_autosuspend(pm2->dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pm2xxx_charger_get_ac_cv(struct pm2xxx_charger *pm2)\r\n{\r\nint ret = 0;\r\nu8 val;\r\nif (pm2->ac.charger_connected && pm2->ac.charger_online) {\r\nret = pm2xxx_reg_read(pm2, PM2XXX_SRCE_REG_INT4, &val);\r\nif (ret < 0) {\r\ndev_err(pm2->dev, "%s pm2xxx read failed\n", __func__);\r\ngoto out;\r\n}\r\nif (val & PM2XXX_INT4_S_ITCVPHASE)\r\nret = PM2XXX_CONST_VOLT;\r\nelse\r\nret = PM2XXX_CONST_CURR;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int pm2xxx_current_to_regval(int curr)\r\n{\r\nint i;\r\nif (curr < pm2xxx_charger_current_map[0])\r\nreturn 0;\r\nfor (i = 1; i < ARRAY_SIZE(pm2xxx_charger_current_map); i++) {\r\nif (curr < pm2xxx_charger_current_map[i])\r\nreturn (i - 1);\r\n}\r\ni = ARRAY_SIZE(pm2xxx_charger_current_map) - 1;\r\nif (curr == pm2xxx_charger_current_map[i])\r\nreturn i;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int pm2xxx_voltage_to_regval(int curr)\r\n{\r\nint i;\r\nif (curr < pm2xxx_charger_voltage_map[0])\r\nreturn 0;\r\nfor (i = 1; i < ARRAY_SIZE(pm2xxx_charger_voltage_map); i++) {\r\nif (curr < pm2xxx_charger_voltage_map[i])\r\nreturn i - 1;\r\n}\r\ni = ARRAY_SIZE(pm2xxx_charger_voltage_map) - 1;\r\nif (curr == pm2xxx_charger_voltage_map[i])\r\nreturn i;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int pm2xxx_charger_update_charger_current(struct ux500_charger *charger,\r\nint ich_out)\r\n{\r\nint ret;\r\nint curr_index;\r\nstruct pm2xxx_charger *pm2;\r\nu8 val;\r\nif (charger->psy.type == POWER_SUPPLY_TYPE_MAINS)\r\npm2 = to_pm2xxx_charger_ac_device_info(charger);\r\nelse\r\nreturn -ENXIO;\r\ncurr_index = pm2xxx_current_to_regval(ich_out);\r\nif (curr_index < 0) {\r\ndev_err(pm2->dev,\r\n"Charger current too high, charging not started\n");\r\nreturn -ENXIO;\r\n}\r\nret = pm2xxx_reg_read(pm2, PM2XXX_BATT_CTRL_REG6, &val);\r\nif (ret >= 0) {\r\nval &= ~PM2XXX_DIR_CH_CC_CURRENT_MASK;\r\nval |= curr_index;\r\nret = pm2xxx_reg_write(pm2, PM2XXX_BATT_CTRL_REG6, val);\r\nif (ret < 0) {\r\ndev_err(pm2->dev,\r\n"%s write failed\n", __func__);\r\n}\r\n}\r\nelse\r\ndev_err(pm2->dev, "%s read failed\n", __func__);\r\nreturn ret;\r\n}\r\nstatic int pm2xxx_charger_ac_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct pm2xxx_charger *pm2;\r\npm2 = to_pm2xxx_charger_ac_device_info(psy_to_ux500_charger(psy));\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nif (pm2->flags.mainextchnotok)\r\nval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\r\nelse if (pm2->ac.wd_expired)\r\nval->intval = POWER_SUPPLY_HEALTH_DEAD;\r\nelse if (pm2->flags.main_thermal_prot)\r\nval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\r\nelse if (pm2->flags.ovv)\r\nval->intval = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\r\nelse\r\nval->intval = POWER_SUPPLY_HEALTH_GOOD;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = pm2->ac.charger_online;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nval->intval = pm2->ac.charger_connected;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_AVG:\r\npm2->ac.cv_active = pm2xxx_charger_get_ac_cv(pm2);\r\nval->intval = pm2->ac.cv_active;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm2xxx_charging_init(struct pm2xxx_charger *pm2)\r\n{\r\nint ret = 0;\r\nret = pm2xxx_reg_write(pm2, PM2XXX_BATT_CTRL_REG3,\r\n(PM2XXX_CH_WD_CV_PHASE_60MIN | PM2XXX_CH_WD_CC_PHASE_60MIN));\r\nif( ret < 0)\r\nreturn ret;\r\nret = pm2xxx_reg_write(pm2, PM2XXX_BATT_CTRL_REG4,\r\nPM2XXX_CH_WD_PRECH_PHASE_60MIN);\r\nret = pm2xxx_reg_write(pm2, PM2XXX_BATT_CTRL_REG5,\r\nPM2XXX_CH_WD_AUTO_TIMEOUT_20MIN);\r\nret = pm2xxx_reg_write(pm2, PM2XXX_BATT_CTRL_REG6,\r\n(PM2XXX_DIR_CH_CC_CURRENT_1000MA |\r\nPM2XXX_CH_PRECH_CURRENT_100MA |\r\nPM2XXX_CH_EOC_CURRENT_100MA));\r\nret = pm2xxx_reg_write(pm2, PM2XXX_BATT_CTRL_REG7,\r\n(PM2XXX_CH_PRECH_VOL_2_9 | PM2XXX_CH_VRESUME_VOL_3_8));\r\nret = pm2xxx_reg_write(pm2, PM2XXX_BATT_CTRL_REG8,\r\nPM2XXX_CH_VOLT_4_2);\r\nret = pm2xxx_reg_write(pm2, PM2XXX_BATT_CTRL_REG9,\r\n(PM2XXX_CH_150MV_DROP_300MV | PM2XXX_CHARCHING_INFO_DIS |\r\nPM2XXX_CH_CC_REDUCED_CURRENT_IDENT |\r\nPM2XXX_CH_CC_MODEDROP_DIS));\r\nret = pm2xxx_reg_write(pm2, PM2XXX_INP_VOLT_VPWR2,\r\nPM2XXX_VPWR2_OVV_10);\r\nret = pm2xxx_reg_write(pm2, PM2XXX_INP_VOLT_VPWR1,\r\nPM2XXX_VPWR1_OVV_10);\r\nret = pm2xxx_reg_write(pm2, PM2XXX_INP_DROP_VPWR2,\r\n(PM2XXX_VPWR2_HW_OPT_DIS | PM2XXX_VPWR2_VALID_DIS |\r\nPM2XXX_VPWR2_DROP_DIS));\r\nret = pm2xxx_reg_write(pm2, PM2XXX_INP_DROP_VPWR1,\r\n(PM2XXX_VPWR1_HW_OPT_DIS | PM2XXX_VPWR1_VALID_DIS |\r\nPM2XXX_VPWR1_DROP_DIS));\r\nret = pm2xxx_reg_write(pm2, PM2XXX_BATT_LOW_LEV_COMP_REG,\r\nPM2XXX_VBAT_LOW_MONITORING_ENA);\r\nreturn ret;\r\n}\r\nstatic int pm2xxx_charger_ac_en(struct ux500_charger *charger,\r\nint enable, int vset, int iset)\r\n{\r\nint ret;\r\nint volt_index;\r\nint curr_index;\r\nu8 val;\r\nstruct pm2xxx_charger *pm2 = to_pm2xxx_charger_ac_device_info(charger);\r\nif (enable) {\r\nif (!pm2->ac.charger_connected) {\r\ndev_dbg(pm2->dev, "AC charger not connected\n");\r\nreturn -ENXIO;\r\n}\r\ndev_dbg(pm2->dev, "Enable AC: %dmV %dmA\n", vset, iset);\r\nif (!pm2->vddadc_en_ac) {\r\nret = regulator_enable(pm2->regu);\r\nif (ret)\r\ndev_warn(pm2->dev,\r\n"Failed to enable vddadc regulator\n");\r\nelse\r\npm2->vddadc_en_ac = true;\r\n}\r\nret = pm2xxx_charging_init(pm2);\r\nif (ret < 0) {\r\ndev_err(pm2->dev, "%s charging init failed\n",\r\n__func__);\r\ngoto error_occured;\r\n}\r\nvolt_index = pm2xxx_voltage_to_regval(vset);\r\ncurr_index = pm2xxx_current_to_regval(iset);\r\nif (volt_index < 0 || curr_index < 0) {\r\ndev_err(pm2->dev,\r\n"Charger voltage or current too high, "\r\n"charging not started\n");\r\nreturn -ENXIO;\r\n}\r\nret = pm2xxx_reg_read(pm2, PM2XXX_BATT_CTRL_REG8, &val);\r\nif (ret < 0) {\r\ndev_err(pm2->dev, "%s pm2xxx read failed\n", __func__);\r\ngoto error_occured;\r\n}\r\nval &= ~PM2XXX_CH_VOLT_MASK;\r\nval |= volt_index;\r\nret = pm2xxx_reg_write(pm2, PM2XXX_BATT_CTRL_REG8, val);\r\nif (ret < 0) {\r\ndev_err(pm2->dev, "%s pm2xxx write failed\n", __func__);\r\ngoto error_occured;\r\n}\r\nret = pm2xxx_reg_read(pm2, PM2XXX_BATT_CTRL_REG6, &val);\r\nif (ret < 0) {\r\ndev_err(pm2->dev, "%s pm2xxx read failed\n", __func__);\r\ngoto error_occured;\r\n}\r\nval &= ~PM2XXX_DIR_CH_CC_CURRENT_MASK;\r\nval |= curr_index;\r\nret = pm2xxx_reg_write(pm2, PM2XXX_BATT_CTRL_REG6, val);\r\nif (ret < 0) {\r\ndev_err(pm2->dev, "%s pm2xxx write failed\n", __func__);\r\ngoto error_occured;\r\n}\r\nif (!pm2->bat->enable_overshoot) {\r\nret = pm2xxx_reg_read(pm2, PM2XXX_LED_CTRL_REG, &val);\r\nif (ret < 0) {\r\ndev_err(pm2->dev, "%s pm2xxx read failed\n",\r\n__func__);\r\ngoto error_occured;\r\n}\r\nval |= PM2XXX_ANTI_OVERSHOOT_EN;\r\nret = pm2xxx_reg_write(pm2, PM2XXX_LED_CTRL_REG, val);\r\nif (ret < 0) {\r\ndev_err(pm2->dev, "%s pm2xxx write failed\n",\r\n__func__);\r\ngoto error_occured;\r\n}\r\n}\r\nret = pm2xxx_charging_enable_mngt(pm2);\r\nif (ret < 0) {\r\ndev_err(pm2->dev, "Failed to enable"\r\n"pm2xxx ac charger\n");\r\ngoto error_occured;\r\n}\r\npm2->ac.charger_online = 1;\r\n} else {\r\npm2->ac.charger_online = 0;\r\npm2->ac.wd_expired = false;\r\nif (pm2->vddadc_en_ac) {\r\nregulator_disable(pm2->regu);\r\npm2->vddadc_en_ac = false;\r\n}\r\nret = pm2xxx_charging_disable_mngt(pm2);\r\nif (ret < 0) {\r\ndev_err(pm2->dev, "failed to disable"\r\n"pm2xxx ac charger\n");\r\ngoto error_occured;\r\n}\r\ndev_dbg(pm2->dev, "PM2301: " "Disabled AC charging\n");\r\n}\r\npower_supply_changed(&pm2->ac_chg.psy);\r\nerror_occured:\r\nreturn ret;\r\n}\r\nstatic int pm2xxx_charger_watchdog_kick(struct ux500_charger *charger)\r\n{\r\nint ret;\r\nstruct pm2xxx_charger *pm2;\r\nif (charger->psy.type == POWER_SUPPLY_TYPE_MAINS)\r\npm2 = to_pm2xxx_charger_ac_device_info(charger);\r\nelse\r\nreturn -ENXIO;\r\nret = pm2xxx_reg_write(pm2, PM2XXX_BATT_WD_KICK, WD_TIMER);\r\nif (ret)\r\ndev_err(pm2->dev, "Failed to kick WD!\n");\r\nreturn ret;\r\n}\r\nstatic void pm2xxx_charger_ac_work(struct work_struct *work)\r\n{\r\nstruct pm2xxx_charger *pm2 = container_of(work,\r\nstruct pm2xxx_charger, ac_work);\r\npower_supply_changed(&pm2->ac_chg.psy);\r\nsysfs_notify(&pm2->ac_chg.psy.dev->kobj, NULL, "present");\r\n}\r\nstatic void pm2xxx_charger_check_hw_failure_work(struct work_struct *work)\r\n{\r\nu8 reg_value;\r\nstruct pm2xxx_charger *pm2 = container_of(work,\r\nstruct pm2xxx_charger, check_hw_failure_work.work);\r\nif (pm2->flags.ovv) {\r\npm2xxx_reg_read(pm2, PM2XXX_SRCE_REG_INT4, &reg_value);\r\nif (!(reg_value & (PM2XXX_INT4_S_ITVPWR1OVV |\r\nPM2XXX_INT4_S_ITVPWR2OVV))) {\r\npm2->flags.ovv = false;\r\npower_supply_changed(&pm2->ac_chg.psy);\r\n}\r\n}\r\nif (pm2->flags.ovv) {\r\nqueue_delayed_work(pm2->charger_wq,\r\n&pm2->check_hw_failure_work, round_jiffies(HZ));\r\n}\r\n}\r\nstatic void pm2xxx_charger_check_main_thermal_prot_work(\r\nstruct work_struct *work)\r\n{\r\nint ret;\r\nu8 val;\r\nstruct pm2xxx_charger *pm2 = container_of(work, struct pm2xxx_charger,\r\ncheck_main_thermal_prot_work);\r\nret = pm2xxx_reg_read(pm2, PM2XXX_SRCE_REG_INT5, &val);\r\nif (ret < 0) {\r\ndev_err(pm2->dev, "%s pm2xxx read failed\n", __func__);\r\nreturn;\r\n}\r\nif (val & (PM2XXX_INT5_S_ITTHERMALWARNINGRISE\r\n| PM2XXX_INT5_S_ITTHERMALSHUTDOWNRISE))\r\npm2->flags.main_thermal_prot = true;\r\nelse if (val & (PM2XXX_INT5_S_ITTHERMALWARNINGFALL\r\n| PM2XXX_INT5_S_ITTHERMALSHUTDOWNFALL))\r\npm2->flags.main_thermal_prot = false;\r\npower_supply_changed(&pm2->ac_chg.psy);\r\n}\r\nstatic int pm2xxx_wall_charger_resume(struct device *dev)\r\n{\r\nstruct i2c_client *i2c_client = to_i2c_client(dev);\r\nstruct pm2xxx_charger *pm2;\r\npm2 = (struct pm2xxx_charger *)i2c_get_clientdata(i2c_client);\r\nset_lpn_pin(pm2);\r\nif (pm2->flags.ovv)\r\nqueue_delayed_work(pm2->charger_wq,\r\n&pm2->check_hw_failure_work, 0);\r\nreturn 0;\r\n}\r\nstatic int pm2xxx_wall_charger_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *i2c_client = to_i2c_client(dev);\r\nstruct pm2xxx_charger *pm2;\r\npm2 = (struct pm2xxx_charger *)i2c_get_clientdata(i2c_client);\r\nclear_lpn_pin(pm2);\r\nif (delayed_work_pending(&pm2->check_hw_failure_work))\r\ncancel_delayed_work(&pm2->check_hw_failure_work);\r\nflush_work(&pm2->ac_work);\r\nflush_work(&pm2->check_main_thermal_prot_work);\r\nreturn 0;\r\n}\r\nstatic int pm2xxx_runtime_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *pm2xxx_i2c_client = to_i2c_client(dev);\r\nstruct pm2xxx_charger *pm2;\r\npm2 = (struct pm2xxx_charger *)i2c_get_clientdata(pm2xxx_i2c_client);\r\nclear_lpn_pin(pm2);\r\nreturn 0;\r\n}\r\nstatic int pm2xxx_runtime_resume(struct device *dev)\r\n{\r\nstruct i2c_client *pm2xxx_i2c_client = to_i2c_client(dev);\r\nstruct pm2xxx_charger *pm2;\r\npm2 = (struct pm2xxx_charger *)i2c_get_clientdata(pm2xxx_i2c_client);\r\nif (gpio_is_valid(pm2->lpn_pin) && gpio_get_value(pm2->lpn_pin) == 0)\r\nset_lpn_pin(pm2);\r\nreturn 0;\r\n}\r\nstatic int pm2xxx_wall_charger_probe(struct i2c_client *i2c_client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct pm2xxx_platform_data *pl_data = i2c_client->dev.platform_data;\r\nstruct pm2xxx_charger *pm2;\r\nint ret = 0;\r\nu8 val;\r\nint i;\r\nif (!pl_data) {\r\ndev_err(&i2c_client->dev, "No platform data supplied\n");\r\nreturn -EINVAL;\r\n}\r\npm2 = kzalloc(sizeof(struct pm2xxx_charger), GFP_KERNEL);\r\nif (!pm2) {\r\ndev_err(&i2c_client->dev, "pm2xxx_charger allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\npm2->dev = &i2c_client->dev;\r\npm2->pm2_int = &pm2xxx_int;\r\nif (!pl_data->wall_charger) {\r\ndev_err(pm2->dev, "no charger platform data supplied\n");\r\nret = -EINVAL;\r\ngoto free_device_info;\r\n}\r\npm2->pdata = pl_data->wall_charger;\r\nif (!pl_data->battery) {\r\ndev_err(pm2->dev, "no battery platform data supplied\n");\r\nret = -EINVAL;\r\ngoto free_device_info;\r\n}\r\npm2->bat = pl_data->battery;\r\nif (!i2c_check_functionality(i2c_client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_READ_WORD_DATA)) {\r\nret = -ENODEV;\r\ndev_info(pm2->dev, "pm2301 i2c_check_functionality failed\n");\r\ngoto free_device_info;\r\n}\r\npm2->config.pm2xxx_i2c = i2c_client;\r\npm2->config.pm2xxx_id = (struct i2c_device_id *) id;\r\ni2c_set_clientdata(i2c_client, pm2);\r\npm2->ac_chg.psy.name = pm2->pdata->label;\r\npm2->ac_chg.psy.type = POWER_SUPPLY_TYPE_MAINS;\r\npm2->ac_chg.psy.properties = pm2xxx_charger_ac_props;\r\npm2->ac_chg.psy.num_properties = ARRAY_SIZE(pm2xxx_charger_ac_props);\r\npm2->ac_chg.psy.get_property = pm2xxx_charger_ac_get_property;\r\npm2->ac_chg.psy.supplied_to = pm2->pdata->supplied_to;\r\npm2->ac_chg.psy.num_supplicants = pm2->pdata->num_supplicants;\r\npm2->ac_chg.ops.enable = &pm2xxx_charger_ac_en;\r\npm2->ac_chg.ops.kick_wd = &pm2xxx_charger_watchdog_kick;\r\npm2->ac_chg.ops.update_curr = &pm2xxx_charger_update_charger_current;\r\npm2->ac_chg.max_out_volt = pm2xxx_charger_voltage_map[\r\nARRAY_SIZE(pm2xxx_charger_voltage_map) - 1];\r\npm2->ac_chg.max_out_curr = pm2xxx_charger_current_map[\r\nARRAY_SIZE(pm2xxx_charger_current_map) - 1];\r\npm2->ac_chg.wdt_refresh = WD_KICK_INTERVAL;\r\npm2->ac_chg.enabled = true;\r\npm2->ac_chg.external = true;\r\npm2->charger_wq = create_singlethread_workqueue("pm2xxx_charger_wq");\r\nif (pm2->charger_wq == NULL) {\r\nret = -ENOMEM;\r\ndev_err(pm2->dev, "failed to create work queue\n");\r\ngoto free_device_info;\r\n}\r\nINIT_WORK(&pm2->ac_work, pm2xxx_charger_ac_work);\r\nINIT_WORK(&pm2->check_main_thermal_prot_work,\r\npm2xxx_charger_check_main_thermal_prot_work);\r\nINIT_DEFERRABLE_WORK(&pm2->check_hw_failure_work,\r\npm2xxx_charger_check_hw_failure_work);\r\npm2->regu = regulator_get(pm2->dev, "vddadc");\r\nif (IS_ERR(pm2->regu)) {\r\nret = PTR_ERR(pm2->regu);\r\ndev_err(pm2->dev, "failed to get vddadc regulator\n");\r\ngoto free_charger_wq;\r\n}\r\nret = power_supply_register(pm2->dev, &pm2->ac_chg.psy);\r\nif (ret) {\r\ndev_err(pm2->dev, "failed to register AC charger\n");\r\ngoto free_regulator;\r\n}\r\nret = request_threaded_irq(gpio_to_irq(pm2->pdata->gpio_irq_number),\r\nNULL,\r\npm2xxx_charger_irq[0].isr,\r\npm2->pdata->irq_type,\r\npm2xxx_charger_irq[0].name, pm2);\r\nif (ret != 0) {\r\ndev_err(pm2->dev, "failed to request %s IRQ %d: %d\n",\r\npm2xxx_charger_irq[0].name,\r\ngpio_to_irq(pm2->pdata->gpio_irq_number), ret);\r\ngoto unregister_pm2xxx_charger;\r\n}\r\nret = pm_runtime_set_active(pm2->dev);\r\nif (ret)\r\ndev_err(pm2->dev, "set active Error\n");\r\npm_runtime_enable(pm2->dev);\r\npm_runtime_set_autosuspend_delay(pm2->dev, PM2XXX_AUTOSUSPEND_DELAY);\r\npm_runtime_use_autosuspend(pm2->dev);\r\npm_runtime_resume(pm2->dev);\r\nret = enable_irq_wake(gpio_to_irq(pm2->pdata->gpio_irq_number));\r\nif (ret) {\r\ndev_err(pm2->dev, "failed to set irq wake\n");\r\ngoto unregister_pm2xxx_interrupt;\r\n}\r\nmutex_init(&pm2->lock);\r\nif (gpio_is_valid(pm2->pdata->lpn_gpio)) {\r\npm2->lpn_pin = pm2->pdata->lpn_gpio;\r\nret = gpio_request(pm2->lpn_pin, "pm2301_lpm_gpio");\r\nif (ret < 0) {\r\ndev_err(pm2->dev, "pm2301_lpm_gpio request failed\n");\r\ngoto disable_pm2_irq_wake;\r\n}\r\nret = gpio_direction_output(pm2->lpn_pin, 0);\r\nif (ret < 0) {\r\ndev_err(pm2->dev, "pm2301_lpm_gpio direction failed\n");\r\ngoto free_gpio;\r\n}\r\nset_lpn_pin(pm2);\r\n}\r\nfor (i = 0; i < PM2XXX_NUM_INT_REG; i++)\r\npm2xxx_reg_read(pm2,\r\npm2xxx_interrupt_registers[i],\r\n&val);\r\nret = pm2xxx_charger_detection(pm2, &val);\r\nif ((ret == 0) && val) {\r\npm2->ac.charger_connected = 1;\r\nab8500_override_turn_on_stat(~AB8500_POW_KEY_1_ON,\r\nAB8500_MAIN_CH_DET);\r\npm2->ac_conn = true;\r\npower_supply_changed(&pm2->ac_chg.psy);\r\nsysfs_notify(&pm2->ac_chg.psy.dev->kobj, NULL, "present");\r\n}\r\nreturn 0;\r\nfree_gpio:\r\nif (gpio_is_valid(pm2->lpn_pin))\r\ngpio_free(pm2->lpn_pin);\r\ndisable_pm2_irq_wake:\r\ndisable_irq_wake(gpio_to_irq(pm2->pdata->gpio_irq_number));\r\nunregister_pm2xxx_interrupt:\r\nfree_irq(gpio_to_irq(pm2->pdata->gpio_irq_number), pm2);\r\nunregister_pm2xxx_charger:\r\npower_supply_unregister(&pm2->ac_chg.psy);\r\nfree_regulator:\r\nregulator_put(pm2->regu);\r\nfree_charger_wq:\r\ndestroy_workqueue(pm2->charger_wq);\r\nfree_device_info:\r\nkfree(pm2);\r\nreturn ret;\r\n}\r\nstatic int pm2xxx_wall_charger_remove(struct i2c_client *i2c_client)\r\n{\r\nstruct pm2xxx_charger *pm2 = i2c_get_clientdata(i2c_client);\r\npm_runtime_disable(pm2->dev);\r\npm2xxx_charger_ac_en(&pm2->ac_chg, false, 0, 0);\r\ndisable_irq_wake(gpio_to_irq(pm2->pdata->gpio_irq_number));\r\nfree_irq(gpio_to_irq(pm2->pdata->gpio_irq_number), pm2);\r\ndestroy_workqueue(pm2->charger_wq);\r\nflush_scheduled_work();\r\nregulator_put(pm2->regu);\r\npower_supply_unregister(&pm2->ac_chg.psy);\r\nif (gpio_is_valid(pm2->lpn_pin))\r\ngpio_free(pm2->lpn_pin);\r\nkfree(pm2);\r\nreturn 0;\r\n}\r\nstatic int __init pm2xxx_charger_init(void)\r\n{\r\nreturn i2c_add_driver(&pm2xxx_charger_driver);\r\n}\r\nstatic void __exit pm2xxx_charger_exit(void)\r\n{\r\ni2c_del_driver(&pm2xxx_charger_driver);\r\n}
