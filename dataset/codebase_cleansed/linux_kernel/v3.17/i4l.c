static int writebuf_from_LL(int driverID, int channel, int ack,\r\nstruct sk_buff *skb)\r\n{\r\nstruct cardstate *cs = gigaset_get_cs_by_id(driverID);\r\nstruct bc_state *bcs;\r\nunsigned char *ack_header;\r\nunsigned len;\r\nif (!cs) {\r\npr_err("%s: invalid driver ID (%d)\n", __func__, driverID);\r\nreturn -ENODEV;\r\n}\r\nif (channel < 0 || channel >= cs->channels) {\r\ndev_err(cs->dev, "%s: invalid channel ID (%d)\n",\r\n__func__, channel);\r\nreturn -ENODEV;\r\n}\r\nbcs = &cs->bcs[channel];\r\nif (skb_linearize(skb) < 0) {\r\ndev_err(cs->dev, "%s: skb_linearize failed\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nlen = skb->len;\r\ngig_dbg(DEBUG_LLDATA,\r\n"Receiving data from LL (id: %d, ch: %d, ack: %d, sz: %d)",\r\ndriverID, channel, ack, len);\r\nif (!len) {\r\nif (ack)\r\ndev_notice(cs->dev, "%s: not ACKing empty packet\n",\r\n__func__);\r\nreturn 0;\r\n}\r\nif (len > MAX_BUF_SIZE) {\r\ndev_err(cs->dev, "%s: packet too large (%d bytes)\n",\r\n__func__, len);\r\nreturn -EINVAL;\r\n}\r\nif (skb_headroom(skb) < HW_HDR_LEN) {\r\ndev_err(cs->dev, "%s: insufficient skb headroom\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nskb_set_mac_header(skb, -HW_HDR_LEN);\r\nskb->mac_len = HW_HDR_LEN;\r\nack_header = skb_mac_header(skb);\r\nif (ack) {\r\nack_header[0] = len & 0xff;\r\nack_header[1] = len >> 8;\r\n} else {\r\nack_header[0] = ack_header[1] = 0;\r\n}\r\ngig_dbg(DEBUG_MCMD, "skb: len=%u, ack=%d: %02x %02x",\r\nlen, ack, ack_header[0], ack_header[1]);\r\nreturn cs->ops->send_skb(bcs, skb);\r\n}\r\nvoid gigaset_skb_sent(struct bc_state *bcs, struct sk_buff *skb)\r\n{\r\nisdn_if *iif = bcs->cs->iif;\r\nunsigned char *ack_header = skb_mac_header(skb);\r\nunsigned len;\r\nisdn_ctrl response;\r\n++bcs->trans_up;\r\nif (skb->len)\r\ndev_warn(bcs->cs->dev, "%s: skb->len==%d\n",\r\n__func__, skb->len);\r\nlen = ack_header[0] + ((unsigned) ack_header[1] << 8);\r\nif (len) {\r\ngig_dbg(DEBUG_MCMD, "ACKing to LL (id: %d, ch: %d, sz: %u)",\r\nbcs->cs->myid, bcs->channel, len);\r\nresponse.driver = bcs->cs->myid;\r\nresponse.command = ISDN_STAT_BSENT;\r\nresponse.arg = bcs->channel;\r\nresponse.parm.length = len;\r\niif->statcallb(&response);\r\n}\r\n}\r\nvoid gigaset_skb_rcvd(struct bc_state *bcs, struct sk_buff *skb)\r\n{\r\nisdn_if *iif = bcs->cs->iif;\r\niif->rcvcallb_skb(bcs->cs->myid, bcs->channel, skb);\r\nbcs->trans_down++;\r\n}\r\nvoid gigaset_isdn_rcv_err(struct bc_state *bcs)\r\n{\r\nisdn_if *iif = bcs->cs->iif;\r\nisdn_ctrl response;\r\nif (bcs->ignore) {\r\nbcs->ignore--;\r\nreturn;\r\n}\r\nbcs->corrupted++;\r\ngig_dbg(DEBUG_CMD, "sending L1ERR");\r\nresponse.driver = bcs->cs->myid;\r\nresponse.command = ISDN_STAT_L1ERR;\r\nresponse.arg = bcs->channel;\r\nresponse.parm.errcode = ISDN_STAT_L1ERR_RECV;\r\niif->statcallb(&response);\r\n}\r\nstatic int command_from_LL(isdn_ctrl *cntrl)\r\n{\r\nstruct cardstate *cs;\r\nstruct bc_state *bcs;\r\nint retval = 0;\r\nchar **commands;\r\nint ch;\r\nint i;\r\nsize_t l;\r\ngig_dbg(DEBUG_CMD, "driver: %d, command: %d, arg: 0x%lx",\r\ncntrl->driver, cntrl->command, cntrl->arg);\r\ncs = gigaset_get_cs_by_id(cntrl->driver);\r\nif (cs == NULL) {\r\npr_err("%s: invalid driver ID (%d)\n", __func__, cntrl->driver);\r\nreturn -ENODEV;\r\n}\r\nch = cntrl->arg & 0xff;\r\nswitch (cntrl->command) {\r\ncase ISDN_CMD_IOCTL:\r\ndev_warn(cs->dev, "ISDN_CMD_IOCTL not supported\n");\r\nreturn -EINVAL;\r\ncase ISDN_CMD_DIAL:\r\ngig_dbg(DEBUG_CMD,\r\n"ISDN_CMD_DIAL (phone: %s, msn: %s, si1: %d, si2: %d)",\r\ncntrl->parm.setup.phone, cntrl->parm.setup.eazmsn,\r\ncntrl->parm.setup.si1, cntrl->parm.setup.si2);\r\nif (ch >= cs->channels) {\r\ndev_err(cs->dev,\r\n"ISDN_CMD_DIAL: invalid channel (%d)\n", ch);\r\nreturn -EINVAL;\r\n}\r\nbcs = cs->bcs + ch;\r\nif (gigaset_get_channel(bcs) < 0) {\r\ndev_err(cs->dev, "ISDN_CMD_DIAL: channel not free\n");\r\nreturn -EBUSY;\r\n}\r\nswitch (bcs->proto2) {\r\ncase L2_HDLC:\r\nbcs->rx_bufsize = SBUFSIZE;\r\nbreak;\r\ndefault:\r\nbcs->rx_bufsize = TRANSBUFSIZE;\r\n}\r\ndev_kfree_skb(bcs->rx_skb);\r\ngigaset_new_rx_skb(bcs);\r\ncommands = kzalloc(AT_NUM * (sizeof *commands), GFP_ATOMIC);\r\nif (!commands) {\r\ngigaset_free_channel(bcs);\r\ndev_err(cs->dev, "ISDN_CMD_DIAL: out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nl = 3 + strlen(cntrl->parm.setup.phone);\r\ncommands[AT_DIAL] = kmalloc(l, GFP_ATOMIC);\r\nif (!commands[AT_DIAL])\r\ngoto oom;\r\nif (cntrl->parm.setup.phone[0] == '*' &&\r\ncntrl->parm.setup.phone[1] == '*') {\r\ncommands[AT_TYPE] = kstrdup("^SCTP=0\r", GFP_ATOMIC);\r\nif (!commands[AT_TYPE])\r\ngoto oom;\r\nsnprintf(commands[AT_DIAL], l,\r\n"D%s\r", cntrl->parm.setup.phone + 2);\r\n} else {\r\ncommands[AT_TYPE] = kstrdup("^SCTP=1\r", GFP_ATOMIC);\r\nif (!commands[AT_TYPE])\r\ngoto oom;\r\nsnprintf(commands[AT_DIAL], l,\r\n"D%s\r", cntrl->parm.setup.phone);\r\n}\r\nl = strlen(cntrl->parm.setup.eazmsn);\r\nif (l) {\r\nl += 8;\r\ncommands[AT_MSN] = kmalloc(l, GFP_ATOMIC);\r\nif (!commands[AT_MSN])\r\ngoto oom;\r\nsnprintf(commands[AT_MSN], l, "^SMSN=%s\r",\r\ncntrl->parm.setup.eazmsn);\r\n}\r\nswitch (cntrl->parm.setup.si1) {\r\ncase 1:\r\ncommands[AT_BC] = kstrdup("^SBC=9090A3\r", GFP_ATOMIC);\r\nif (!commands[AT_BC])\r\ngoto oom;\r\nbreak;\r\ncase 7:\r\ndefault:\r\ncommands[AT_BC] = kstrdup("^SBC=8890\r", GFP_ATOMIC);\r\nif (!commands[AT_BC])\r\ngoto oom;\r\n}\r\ncommands[AT_PROTO] = kmalloc(9, GFP_ATOMIC);\r\nif (!commands[AT_PROTO])\r\ngoto oom;\r\nsnprintf(commands[AT_PROTO], 9, "^SBPR=%u\r", bcs->proto2);\r\ncommands[AT_ISO] = kmalloc(9, GFP_ATOMIC);\r\nif (!commands[AT_ISO])\r\ngoto oom;\r\nsnprintf(commands[AT_ISO], 9, "^SISO=%u\r",\r\n(unsigned) bcs->channel + 1);\r\nif (!gigaset_add_event(cs, &bcs->at_state, EV_DIAL, commands,\r\nbcs->at_state.seq_index, NULL)) {\r\nfor (i = 0; i < AT_NUM; ++i)\r\nkfree(commands[i]);\r\nkfree(commands);\r\ngigaset_free_channel(bcs);\r\nreturn -ENOMEM;\r\n}\r\ngigaset_schedule_event(cs);\r\nbreak;\r\ncase ISDN_CMD_ACCEPTD:\r\ngig_dbg(DEBUG_CMD, "ISDN_CMD_ACCEPTD");\r\nif (ch >= cs->channels) {\r\ndev_err(cs->dev,\r\n"ISDN_CMD_ACCEPTD: invalid channel (%d)\n", ch);\r\nreturn -EINVAL;\r\n}\r\nbcs = cs->bcs + ch;\r\nswitch (bcs->proto2) {\r\ncase L2_HDLC:\r\nbcs->rx_bufsize = SBUFSIZE;\r\nbreak;\r\ndefault:\r\nbcs->rx_bufsize = TRANSBUFSIZE;\r\n}\r\ndev_kfree_skb(bcs->rx_skb);\r\ngigaset_new_rx_skb(bcs);\r\nif (!gigaset_add_event(cs, &bcs->at_state,\r\nEV_ACCEPT, NULL, 0, NULL))\r\nreturn -ENOMEM;\r\ngigaset_schedule_event(cs);\r\nbreak;\r\ncase ISDN_CMD_HANGUP:\r\ngig_dbg(DEBUG_CMD, "ISDN_CMD_HANGUP");\r\nif (ch >= cs->channels) {\r\ndev_err(cs->dev,\r\n"ISDN_CMD_HANGUP: invalid channel (%d)\n", ch);\r\nreturn -EINVAL;\r\n}\r\nbcs = cs->bcs + ch;\r\nif (!gigaset_add_event(cs, &bcs->at_state,\r\nEV_HUP, NULL, 0, NULL))\r\nreturn -ENOMEM;\r\ngigaset_schedule_event(cs);\r\nbreak;\r\ncase ISDN_CMD_CLREAZ:\r\ndev_info(cs->dev, "ignoring ISDN_CMD_CLREAZ\n");\r\nbreak;\r\ncase ISDN_CMD_SETEAZ:\r\ndev_info(cs->dev, "ignoring ISDN_CMD_SETEAZ (%s)\n",\r\ncntrl->parm.num);\r\nbreak;\r\ncase ISDN_CMD_SETL2:\r\nif (ch >= cs->channels) {\r\ndev_err(cs->dev,\r\n"ISDN_CMD_SETL2: invalid channel (%d)\n", ch);\r\nreturn -EINVAL;\r\n}\r\nbcs = cs->bcs + ch;\r\nif (bcs->chstate & CHS_D_UP) {\r\ndev_err(cs->dev,\r\n"ISDN_CMD_SETL2: channel active (%d)\n", ch);\r\nreturn -EINVAL;\r\n}\r\nswitch (cntrl->arg >> 8) {\r\ncase ISDN_PROTO_L2_HDLC:\r\ngig_dbg(DEBUG_CMD, "ISDN_CMD_SETL2: setting L2_HDLC");\r\nbcs->proto2 = L2_HDLC;\r\nbreak;\r\ncase ISDN_PROTO_L2_TRANS:\r\ngig_dbg(DEBUG_CMD, "ISDN_CMD_SETL2: setting L2_VOICE");\r\nbcs->proto2 = L2_VOICE;\r\nbreak;\r\ndefault:\r\ndev_err(cs->dev,\r\n"ISDN_CMD_SETL2: unsupported protocol (%lu)\n",\r\ncntrl->arg >> 8);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase ISDN_CMD_SETL3:\r\ngig_dbg(DEBUG_CMD, "ISDN_CMD_SETL3");\r\nif (ch >= cs->channels) {\r\ndev_err(cs->dev,\r\n"ISDN_CMD_SETL3: invalid channel (%d)\n", ch);\r\nreturn -EINVAL;\r\n}\r\nif (cntrl->arg >> 8 != ISDN_PROTO_L3_TRANS) {\r\ndev_err(cs->dev,\r\n"ISDN_CMD_SETL3: unsupported protocol (%lu)\n",\r\ncntrl->arg >> 8);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\ngig_dbg(DEBUG_CMD, "unknown command %d from LL",\r\ncntrl->command);\r\nreturn -EINVAL;\r\n}\r\nreturn retval;\r\noom:\r\ndev_err(bcs->cs->dev, "out of memory\n");\r\nfor (i = 0; i < AT_NUM; ++i)\r\nkfree(commands[i]);\r\nkfree(commands);\r\ngigaset_free_channel(bcs);\r\nreturn -ENOMEM;\r\n}\r\nstatic void gigaset_i4l_cmd(struct cardstate *cs, int cmd)\r\n{\r\nisdn_if *iif = cs->iif;\r\nisdn_ctrl command;\r\ncommand.driver = cs->myid;\r\ncommand.command = cmd;\r\ncommand.arg = 0;\r\niif->statcallb(&command);\r\n}\r\nstatic void gigaset_i4l_channel_cmd(struct bc_state *bcs, int cmd)\r\n{\r\nisdn_if *iif = bcs->cs->iif;\r\nisdn_ctrl command;\r\ncommand.driver = bcs->cs->myid;\r\ncommand.command = cmd;\r\ncommand.arg = bcs->channel;\r\niif->statcallb(&command);\r\n}\r\nint gigaset_isdn_icall(struct at_state_t *at_state)\r\n{\r\nstruct cardstate *cs = at_state->cs;\r\nstruct bc_state *bcs = at_state->bcs;\r\nisdn_if *iif = cs->iif;\r\nisdn_ctrl response;\r\nint retval;\r\nresponse.parm.setup.si1 = 0;\r\nresponse.parm.setup.si2 = 0;\r\nresponse.parm.setup.screen = 0;\r\nresponse.parm.setup.plan = 0;\r\nif (!at_state->str_var[STR_ZBC]) {\r\nresponse.parm.setup.si1 = 1;\r\n} else if (!strcmp(at_state->str_var[STR_ZBC], "8890")) {\r\nresponse.parm.setup.si1 = 7;\r\n} else if (!strcmp(at_state->str_var[STR_ZBC], "8090A3")) {\r\nresponse.parm.setup.si1 = 1;\r\n} else if (!strcmp(at_state->str_var[STR_ZBC], "9090A3")) {\r\nresponse.parm.setup.si1 = 1;\r\nresponse.parm.setup.si2 = 2;\r\n} else {\r\ndev_warn(cs->dev, "RING ignored - unsupported BC %s\n",\r\nat_state->str_var[STR_ZBC]);\r\nreturn ICALL_IGNORE;\r\n}\r\nif (at_state->str_var[STR_NMBR]) {\r\nstrlcpy(response.parm.setup.phone, at_state->str_var[STR_NMBR],\r\nsizeof response.parm.setup.phone);\r\n} else\r\nresponse.parm.setup.phone[0] = 0;\r\nif (at_state->str_var[STR_ZCPN]) {\r\nstrlcpy(response.parm.setup.eazmsn, at_state->str_var[STR_ZCPN],\r\nsizeof response.parm.setup.eazmsn);\r\n} else\r\nresponse.parm.setup.eazmsn[0] = 0;\r\nif (!bcs) {\r\ndev_notice(cs->dev, "no channel for incoming call\n");\r\nresponse.command = ISDN_STAT_ICALLW;\r\nresponse.arg = 0;\r\n} else {\r\ngig_dbg(DEBUG_CMD, "Sending ICALL");\r\nresponse.command = ISDN_STAT_ICALL;\r\nresponse.arg = bcs->channel;\r\n}\r\nresponse.driver = cs->myid;\r\nretval = iif->statcallb(&response);\r\ngig_dbg(DEBUG_CMD, "Response: %d", retval);\r\nswitch (retval) {\r\ncase 0:\r\nreturn ICALL_IGNORE;\r\ncase 1:\r\nbcs->chstate |= CHS_NOTIFY_LL;\r\nreturn ICALL_ACCEPT;\r\ncase 2:\r\nreturn ICALL_REJECT;\r\ncase 3:\r\ndev_warn(cs->dev,\r\n"LL requested unsupported feature: Incomplete Number\n");\r\nreturn ICALL_IGNORE;\r\ncase 4:\r\nreturn ICALL_ACCEPT;\r\ncase 5:\r\ndev_warn(cs->dev,\r\n"LL requested unsupported feature: Call Deflection\n");\r\nreturn ICALL_IGNORE;\r\ndefault:\r\ndev_err(cs->dev, "LL error %d on ICALL\n", retval);\r\nreturn ICALL_IGNORE;\r\n}\r\n}\r\nvoid gigaset_isdn_connD(struct bc_state *bcs)\r\n{\r\ngig_dbg(DEBUG_CMD, "sending DCONN");\r\ngigaset_i4l_channel_cmd(bcs, ISDN_STAT_DCONN);\r\n}\r\nvoid gigaset_isdn_hupD(struct bc_state *bcs)\r\n{\r\ngig_dbg(DEBUG_CMD, "sending DHUP");\r\ngigaset_i4l_channel_cmd(bcs, ISDN_STAT_DHUP);\r\n}\r\nvoid gigaset_isdn_connB(struct bc_state *bcs)\r\n{\r\ngig_dbg(DEBUG_CMD, "sending BCONN");\r\ngigaset_i4l_channel_cmd(bcs, ISDN_STAT_BCONN);\r\n}\r\nvoid gigaset_isdn_hupB(struct bc_state *bcs)\r\n{\r\ngig_dbg(DEBUG_CMD, "sending BHUP");\r\ngigaset_i4l_channel_cmd(bcs, ISDN_STAT_BHUP);\r\n}\r\nvoid gigaset_isdn_start(struct cardstate *cs)\r\n{\r\ngig_dbg(DEBUG_CMD, "sending RUN");\r\ngigaset_i4l_cmd(cs, ISDN_STAT_RUN);\r\n}\r\nvoid gigaset_isdn_stop(struct cardstate *cs)\r\n{\r\ngig_dbg(DEBUG_CMD, "sending STOP");\r\ngigaset_i4l_cmd(cs, ISDN_STAT_STOP);\r\n}\r\nint gigaset_isdn_regdev(struct cardstate *cs, const char *isdnid)\r\n{\r\nisdn_if *iif;\r\niif = kmalloc(sizeof *iif, GFP_KERNEL);\r\nif (!iif) {\r\npr_err("out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nif (snprintf(iif->id, sizeof iif->id, "%s_%u", isdnid, cs->minor_index)\r\n>= sizeof iif->id) {\r\npr_err("ID too long: %s\n", isdnid);\r\nkfree(iif);\r\nreturn -EINVAL;\r\n}\r\niif->owner = THIS_MODULE;\r\niif->channels = cs->channels;\r\niif->maxbufsize = MAX_BUF_SIZE;\r\niif->features = ISDN_FEATURE_L2_TRANS |\r\nISDN_FEATURE_L2_HDLC |\r\nISDN_FEATURE_L2_X75I |\r\nISDN_FEATURE_L3_TRANS |\r\nISDN_FEATURE_P_EURO;\r\niif->hl_hdrlen = HW_HDR_LEN;\r\niif->command = command_from_LL;\r\niif->writebuf_skb = writebuf_from_LL;\r\niif->writecmd = NULL;\r\niif->readstat = NULL;\r\niif->rcvcallb_skb = NULL;\r\niif->statcallb = NULL;\r\nif (!register_isdn(iif)) {\r\npr_err("register_isdn failed\n");\r\nkfree(iif);\r\nreturn -EINVAL;\r\n}\r\ncs->iif = iif;\r\ncs->myid = iif->channels;\r\ncs->hw_hdr_len = HW_HDR_LEN;\r\nreturn 0;\r\n}\r\nvoid gigaset_isdn_unregdev(struct cardstate *cs)\r\n{\r\ngig_dbg(DEBUG_CMD, "sending UNLOAD");\r\ngigaset_i4l_cmd(cs, ISDN_STAT_UNLOAD);\r\nkfree(cs->iif);\r\ncs->iif = NULL;\r\n}\r\nvoid gigaset_isdn_regdrv(void)\r\n{\r\npr_info("ISDN4Linux interface\n");\r\n}\r\nvoid gigaset_isdn_unregdrv(void)\r\n{\r\n}
