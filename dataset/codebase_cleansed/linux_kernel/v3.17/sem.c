void sem_init_ns(struct ipc_namespace *ns)\r\n{\r\nns->sc_semmsl = SEMMSL;\r\nns->sc_semmns = SEMMNS;\r\nns->sc_semopm = SEMOPM;\r\nns->sc_semmni = SEMMNI;\r\nns->used_sems = 0;\r\nipc_init_ids(&ns->ids[IPC_SEM_IDS]);\r\n}\r\nvoid sem_exit_ns(struct ipc_namespace *ns)\r\n{\r\nfree_ipcs(ns, &sem_ids(ns), freeary);\r\nidr_destroy(&ns->ids[IPC_SEM_IDS].ipcs_idr);\r\n}\r\nvoid __init sem_init(void)\r\n{\r\nsem_init_ns(&init_ipc_ns);\r\nipc_init_proc_interface("sysvipc/sem",\r\n" key semid perms nsems uid gid cuid cgid otime ctime\n",\r\nIPC_SEM_IDS, sysvipc_sem_proc_show);\r\n}\r\nstatic void unmerge_queues(struct sem_array *sma)\r\n{\r\nstruct sem_queue *q, *tq;\r\nif (sma->complex_count)\r\nreturn;\r\nlist_for_each_entry_safe(q, tq, &sma->pending_alter, list) {\r\nstruct sem *curr;\r\ncurr = &sma->sem_base[q->sops[0].sem_num];\r\nlist_add_tail(&q->list, &curr->pending_alter);\r\n}\r\nINIT_LIST_HEAD(&sma->pending_alter);\r\n}\r\nstatic void merge_queues(struct sem_array *sma)\r\n{\r\nint i;\r\nfor (i = 0; i < sma->sem_nsems; i++) {\r\nstruct sem *sem = sma->sem_base + i;\r\nlist_splice_init(&sem->pending_alter, &sma->pending_alter);\r\n}\r\n}\r\nstatic void sem_rcu_free(struct rcu_head *head)\r\n{\r\nstruct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);\r\nstruct sem_array *sma = ipc_rcu_to_struct(p);\r\nsecurity_sem_free(sma);\r\nipc_rcu_free(head);\r\n}\r\nstatic void sem_wait_array(struct sem_array *sma)\r\n{\r\nint i;\r\nstruct sem *sem;\r\nif (sma->complex_count) {\r\nreturn;\r\n}\r\nfor (i = 0; i < sma->sem_nsems; i++) {\r\nsem = sma->sem_base + i;\r\nspin_unlock_wait(&sem->lock);\r\n}\r\n}\r\nstatic inline int sem_lock(struct sem_array *sma, struct sembuf *sops,\r\nint nsops)\r\n{\r\nstruct sem *sem;\r\nif (nsops != 1) {\r\nipc_lock_object(&sma->sem_perm);\r\nsem_wait_array(sma);\r\nreturn -1;\r\n}\r\nsem = sma->sem_base + sops->sem_num;\r\nif (sma->complex_count == 0) {\r\nspin_lock(&sem->lock);\r\nif (!spin_is_locked(&sma->sem_perm.lock)) {\r\nsmp_mb();\r\nif (sma->complex_count == 0) {\r\nreturn sops->sem_num;\r\n}\r\n}\r\nspin_unlock(&sem->lock);\r\n}\r\nipc_lock_object(&sma->sem_perm);\r\nif (sma->complex_count == 0) {\r\nspin_lock(&sem->lock);\r\nipc_unlock_object(&sma->sem_perm);\r\nreturn sops->sem_num;\r\n} else {\r\nsem_wait_array(sma);\r\nreturn -1;\r\n}\r\n}\r\nstatic inline void sem_unlock(struct sem_array *sma, int locknum)\r\n{\r\nif (locknum == -1) {\r\nunmerge_queues(sma);\r\nipc_unlock_object(&sma->sem_perm);\r\n} else {\r\nstruct sem *sem = sma->sem_base + locknum;\r\nspin_unlock(&sem->lock);\r\n}\r\n}\r\nstatic inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns,\r\nint id, struct sembuf *sops, int nsops, int *locknum)\r\n{\r\nstruct kern_ipc_perm *ipcp;\r\nstruct sem_array *sma;\r\nipcp = ipc_obtain_object(&sem_ids(ns), id);\r\nif (IS_ERR(ipcp))\r\nreturn ERR_CAST(ipcp);\r\nsma = container_of(ipcp, struct sem_array, sem_perm);\r\n*locknum = sem_lock(sma, sops, nsops);\r\nif (ipc_valid_object(ipcp))\r\nreturn container_of(ipcp, struct sem_array, sem_perm);\r\nsem_unlock(sma, *locknum);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic inline struct sem_array *sem_obtain_object(struct ipc_namespace *ns, int id)\r\n{\r\nstruct kern_ipc_perm *ipcp = ipc_obtain_object(&sem_ids(ns), id);\r\nif (IS_ERR(ipcp))\r\nreturn ERR_CAST(ipcp);\r\nreturn container_of(ipcp, struct sem_array, sem_perm);\r\n}\r\nstatic inline struct sem_array *sem_obtain_object_check(struct ipc_namespace *ns,\r\nint id)\r\n{\r\nstruct kern_ipc_perm *ipcp = ipc_obtain_object_check(&sem_ids(ns), id);\r\nif (IS_ERR(ipcp))\r\nreturn ERR_CAST(ipcp);\r\nreturn container_of(ipcp, struct sem_array, sem_perm);\r\n}\r\nstatic inline void sem_lock_and_putref(struct sem_array *sma)\r\n{\r\nsem_lock(sma, NULL, -1);\r\nipc_rcu_putref(sma, ipc_rcu_free);\r\n}\r\nstatic inline void sem_rmid(struct ipc_namespace *ns, struct sem_array *s)\r\n{\r\nipc_rmid(&sem_ids(ns), &s->sem_perm);\r\n}\r\nstatic int newary(struct ipc_namespace *ns, struct ipc_params *params)\r\n{\r\nint id;\r\nint retval;\r\nstruct sem_array *sma;\r\nint size;\r\nkey_t key = params->key;\r\nint nsems = params->u.nsems;\r\nint semflg = params->flg;\r\nint i;\r\nif (!nsems)\r\nreturn -EINVAL;\r\nif (ns->used_sems + nsems > ns->sc_semmns)\r\nreturn -ENOSPC;\r\nsize = sizeof(*sma) + nsems * sizeof(struct sem);\r\nsma = ipc_rcu_alloc(size);\r\nif (!sma)\r\nreturn -ENOMEM;\r\nmemset(sma, 0, size);\r\nsma->sem_perm.mode = (semflg & S_IRWXUGO);\r\nsma->sem_perm.key = key;\r\nsma->sem_perm.security = NULL;\r\nretval = security_sem_alloc(sma);\r\nif (retval) {\r\nipc_rcu_putref(sma, ipc_rcu_free);\r\nreturn retval;\r\n}\r\nid = ipc_addid(&sem_ids(ns), &sma->sem_perm, ns->sc_semmni);\r\nif (id < 0) {\r\nipc_rcu_putref(sma, sem_rcu_free);\r\nreturn id;\r\n}\r\nns->used_sems += nsems;\r\nsma->sem_base = (struct sem *) &sma[1];\r\nfor (i = 0; i < nsems; i++) {\r\nINIT_LIST_HEAD(&sma->sem_base[i].pending_alter);\r\nINIT_LIST_HEAD(&sma->sem_base[i].pending_const);\r\nspin_lock_init(&sma->sem_base[i].lock);\r\n}\r\nsma->complex_count = 0;\r\nINIT_LIST_HEAD(&sma->pending_alter);\r\nINIT_LIST_HEAD(&sma->pending_const);\r\nINIT_LIST_HEAD(&sma->list_id);\r\nsma->sem_nsems = nsems;\r\nsma->sem_ctime = get_seconds();\r\nsem_unlock(sma, -1);\r\nrcu_read_unlock();\r\nreturn sma->sem_perm.id;\r\n}\r\nstatic inline int sem_security(struct kern_ipc_perm *ipcp, int semflg)\r\n{\r\nstruct sem_array *sma;\r\nsma = container_of(ipcp, struct sem_array, sem_perm);\r\nreturn security_sem_associate(sma, semflg);\r\n}\r\nstatic inline int sem_more_checks(struct kern_ipc_perm *ipcp,\r\nstruct ipc_params *params)\r\n{\r\nstruct sem_array *sma;\r\nsma = container_of(ipcp, struct sem_array, sem_perm);\r\nif (params->u.nsems > sma->sem_nsems)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int perform_atomic_semop(struct sem_array *sma, struct sem_queue *q)\r\n{\r\nint result, sem_op, nsops, pid;\r\nstruct sembuf *sop;\r\nstruct sem *curr;\r\nstruct sembuf *sops;\r\nstruct sem_undo *un;\r\nsops = q->sops;\r\nnsops = q->nsops;\r\nun = q->undo;\r\nfor (sop = sops; sop < sops + nsops; sop++) {\r\ncurr = sma->sem_base + sop->sem_num;\r\nsem_op = sop->sem_op;\r\nresult = curr->semval;\r\nif (!sem_op && result)\r\ngoto would_block;\r\nresult += sem_op;\r\nif (result < 0)\r\ngoto would_block;\r\nif (result > SEMVMX)\r\ngoto out_of_range;\r\nif (sop->sem_flg & SEM_UNDO) {\r\nint undo = un->semadj[sop->sem_num] - sem_op;\r\nif (undo < (-SEMAEM - 1) || undo > SEMAEM)\r\ngoto out_of_range;\r\nun->semadj[sop->sem_num] = undo;\r\n}\r\ncurr->semval = result;\r\n}\r\nsop--;\r\npid = q->pid;\r\nwhile (sop >= sops) {\r\nsma->sem_base[sop->sem_num].sempid = pid;\r\nsop--;\r\n}\r\nreturn 0;\r\nout_of_range:\r\nresult = -ERANGE;\r\ngoto undo;\r\nwould_block:\r\nq->blocking = sop;\r\nif (sop->sem_flg & IPC_NOWAIT)\r\nresult = -EAGAIN;\r\nelse\r\nresult = 1;\r\nundo:\r\nsop--;\r\nwhile (sop >= sops) {\r\nsem_op = sop->sem_op;\r\nsma->sem_base[sop->sem_num].semval -= sem_op;\r\nif (sop->sem_flg & SEM_UNDO)\r\nun->semadj[sop->sem_num] += sem_op;\r\nsop--;\r\n}\r\nreturn result;\r\n}\r\nstatic void wake_up_sem_queue_prepare(struct list_head *pt,\r\nstruct sem_queue *q, int error)\r\n{\r\nif (list_empty(pt)) {\r\npreempt_disable();\r\n}\r\nq->status = IN_WAKEUP;\r\nq->pid = error;\r\nlist_add_tail(&q->list, pt);\r\n}\r\nstatic void wake_up_sem_queue_do(struct list_head *pt)\r\n{\r\nstruct sem_queue *q, *t;\r\nint did_something;\r\ndid_something = !list_empty(pt);\r\nlist_for_each_entry_safe(q, t, pt, list) {\r\nwake_up_process(q->sleeper);\r\nsmp_wmb();\r\nq->status = q->pid;\r\n}\r\nif (did_something)\r\npreempt_enable();\r\n}\r\nstatic void unlink_queue(struct sem_array *sma, struct sem_queue *q)\r\n{\r\nlist_del(&q->list);\r\nif (q->nsops > 1)\r\nsma->complex_count--;\r\n}\r\nstatic int check_restart(struct sem_array *sma, struct sem_queue *q)\r\n{\r\nif (!list_empty(&sma->pending_alter))\r\nreturn 1;\r\nif (q->nsops > 1)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int wake_const_ops(struct sem_array *sma, int semnum,\r\nstruct list_head *pt)\r\n{\r\nstruct sem_queue *q;\r\nstruct list_head *walk;\r\nstruct list_head *pending_list;\r\nint semop_completed = 0;\r\nif (semnum == -1)\r\npending_list = &sma->pending_const;\r\nelse\r\npending_list = &sma->sem_base[semnum].pending_const;\r\nwalk = pending_list->next;\r\nwhile (walk != pending_list) {\r\nint error;\r\nq = container_of(walk, struct sem_queue, list);\r\nwalk = walk->next;\r\nerror = perform_atomic_semop(sma, q);\r\nif (error <= 0) {\r\nunlink_queue(sma, q);\r\nwake_up_sem_queue_prepare(pt, q, error);\r\nif (error == 0)\r\nsemop_completed = 1;\r\n}\r\n}\r\nreturn semop_completed;\r\n}\r\nstatic int do_smart_wakeup_zero(struct sem_array *sma, struct sembuf *sops,\r\nint nsops, struct list_head *pt)\r\n{\r\nint i;\r\nint semop_completed = 0;\r\nint got_zero = 0;\r\nif (sops) {\r\nfor (i = 0; i < nsops; i++) {\r\nint num = sops[i].sem_num;\r\nif (sma->sem_base[num].semval == 0) {\r\ngot_zero = 1;\r\nsemop_completed |= wake_const_ops(sma, num, pt);\r\n}\r\n}\r\n} else {\r\nfor (i = 0; i < sma->sem_nsems; i++) {\r\nif (sma->sem_base[i].semval == 0) {\r\ngot_zero = 1;\r\nsemop_completed |= wake_const_ops(sma, i, pt);\r\n}\r\n}\r\n}\r\nif (got_zero)\r\nsemop_completed |= wake_const_ops(sma, -1, pt);\r\nreturn semop_completed;\r\n}\r\nstatic int update_queue(struct sem_array *sma, int semnum, struct list_head *pt)\r\n{\r\nstruct sem_queue *q;\r\nstruct list_head *walk;\r\nstruct list_head *pending_list;\r\nint semop_completed = 0;\r\nif (semnum == -1)\r\npending_list = &sma->pending_alter;\r\nelse\r\npending_list = &sma->sem_base[semnum].pending_alter;\r\nagain:\r\nwalk = pending_list->next;\r\nwhile (walk != pending_list) {\r\nint error, restart;\r\nq = container_of(walk, struct sem_queue, list);\r\nwalk = walk->next;\r\nif (semnum != -1 && sma->sem_base[semnum].semval == 0)\r\nbreak;\r\nerror = perform_atomic_semop(sma, q);\r\nif (error > 0)\r\ncontinue;\r\nunlink_queue(sma, q);\r\nif (error) {\r\nrestart = 0;\r\n} else {\r\nsemop_completed = 1;\r\ndo_smart_wakeup_zero(sma, q->sops, q->nsops, pt);\r\nrestart = check_restart(sma, q);\r\n}\r\nwake_up_sem_queue_prepare(pt, q, error);\r\nif (restart)\r\ngoto again;\r\n}\r\nreturn semop_completed;\r\n}\r\nstatic void set_semotime(struct sem_array *sma, struct sembuf *sops)\r\n{\r\nif (sops == NULL) {\r\nsma->sem_base[0].sem_otime = get_seconds();\r\n} else {\r\nsma->sem_base[sops[0].sem_num].sem_otime =\r\nget_seconds();\r\n}\r\n}\r\nstatic void do_smart_update(struct sem_array *sma, struct sembuf *sops, int nsops,\r\nint otime, struct list_head *pt)\r\n{\r\nint i;\r\notime |= do_smart_wakeup_zero(sma, sops, nsops, pt);\r\nif (!list_empty(&sma->pending_alter)) {\r\notime |= update_queue(sma, -1, pt);\r\n} else {\r\nif (!sops) {\r\nfor (i = 0; i < sma->sem_nsems; i++)\r\notime |= update_queue(sma, i, pt);\r\n} else {\r\nfor (i = 0; i < nsops; i++) {\r\nif (sops[i].sem_op > 0) {\r\notime |= update_queue(sma,\r\nsops[i].sem_num, pt);\r\n}\r\n}\r\n}\r\n}\r\nif (otime)\r\nset_semotime(sma, sops);\r\n}\r\nstatic int check_qop(struct sem_array *sma, int semnum, struct sem_queue *q,\r\nbool count_zero)\r\n{\r\nstruct sembuf *sop = q->blocking;\r\npr_info_once("semctl(GETNCNT/GETZCNT) is since 3.16 Single Unix Specification compliant.\n"\r\n"The task %s (%d) triggered the difference, watch for misbehavior.\n",\r\ncurrent->comm, task_pid_nr(current));\r\nif (sop->sem_num != semnum)\r\nreturn 0;\r\nif (count_zero && sop->sem_op == 0)\r\nreturn 1;\r\nif (!count_zero && sop->sem_op < 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int count_semcnt(struct sem_array *sma, ushort semnum,\r\nbool count_zero)\r\n{\r\nstruct list_head *l;\r\nstruct sem_queue *q;\r\nint semcnt;\r\nsemcnt = 0;\r\nif (count_zero)\r\nl = &sma->sem_base[semnum].pending_const;\r\nelse\r\nl = &sma->sem_base[semnum].pending_alter;\r\nlist_for_each_entry(q, l, list) {\r\nsemcnt++;\r\n}\r\nlist_for_each_entry(q, &sma->pending_alter, list) {\r\nsemcnt += check_qop(sma, semnum, q, count_zero);\r\n}\r\nif (count_zero) {\r\nlist_for_each_entry(q, &sma->pending_const, list) {\r\nsemcnt += check_qop(sma, semnum, q, count_zero);\r\n}\r\n}\r\nreturn semcnt;\r\n}\r\nstatic void freeary(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)\r\n{\r\nstruct sem_undo *un, *tu;\r\nstruct sem_queue *q, *tq;\r\nstruct sem_array *sma = container_of(ipcp, struct sem_array, sem_perm);\r\nstruct list_head tasks;\r\nint i;\r\nipc_assert_locked_object(&sma->sem_perm);\r\nlist_for_each_entry_safe(un, tu, &sma->list_id, list_id) {\r\nlist_del(&un->list_id);\r\nspin_lock(&un->ulp->lock);\r\nun->semid = -1;\r\nlist_del_rcu(&un->list_proc);\r\nspin_unlock(&un->ulp->lock);\r\nkfree_rcu(un, rcu);\r\n}\r\nINIT_LIST_HEAD(&tasks);\r\nlist_for_each_entry_safe(q, tq, &sma->pending_const, list) {\r\nunlink_queue(sma, q);\r\nwake_up_sem_queue_prepare(&tasks, q, -EIDRM);\r\n}\r\nlist_for_each_entry_safe(q, tq, &sma->pending_alter, list) {\r\nunlink_queue(sma, q);\r\nwake_up_sem_queue_prepare(&tasks, q, -EIDRM);\r\n}\r\nfor (i = 0; i < sma->sem_nsems; i++) {\r\nstruct sem *sem = sma->sem_base + i;\r\nlist_for_each_entry_safe(q, tq, &sem->pending_const, list) {\r\nunlink_queue(sma, q);\r\nwake_up_sem_queue_prepare(&tasks, q, -EIDRM);\r\n}\r\nlist_for_each_entry_safe(q, tq, &sem->pending_alter, list) {\r\nunlink_queue(sma, q);\r\nwake_up_sem_queue_prepare(&tasks, q, -EIDRM);\r\n}\r\n}\r\nsem_rmid(ns, sma);\r\nsem_unlock(sma, -1);\r\nrcu_read_unlock();\r\nwake_up_sem_queue_do(&tasks);\r\nns->used_sems -= sma->sem_nsems;\r\nipc_rcu_putref(sma, sem_rcu_free);\r\n}\r\nstatic unsigned long copy_semid_to_user(void __user *buf, struct semid64_ds *in, int version)\r\n{\r\nswitch (version) {\r\ncase IPC_64:\r\nreturn copy_to_user(buf, in, sizeof(*in));\r\ncase IPC_OLD:\r\n{\r\nstruct semid_ds out;\r\nmemset(&out, 0, sizeof(out));\r\nipc64_perm_to_ipc_perm(&in->sem_perm, &out.sem_perm);\r\nout.sem_otime = in->sem_otime;\r\nout.sem_ctime = in->sem_ctime;\r\nout.sem_nsems = in->sem_nsems;\r\nreturn copy_to_user(buf, &out, sizeof(out));\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic time_t get_semotime(struct sem_array *sma)\r\n{\r\nint i;\r\ntime_t res;\r\nres = sma->sem_base[0].sem_otime;\r\nfor (i = 1; i < sma->sem_nsems; i++) {\r\ntime_t to = sma->sem_base[i].sem_otime;\r\nif (to > res)\r\nres = to;\r\n}\r\nreturn res;\r\n}\r\nstatic int semctl_nolock(struct ipc_namespace *ns, int semid,\r\nint cmd, int version, void __user *p)\r\n{\r\nint err;\r\nstruct sem_array *sma;\r\nswitch (cmd) {\r\ncase IPC_INFO:\r\ncase SEM_INFO:\r\n{\r\nstruct seminfo seminfo;\r\nint max_id;\r\nerr = security_sem_semctl(NULL, cmd);\r\nif (err)\r\nreturn err;\r\nmemset(&seminfo, 0, sizeof(seminfo));\r\nseminfo.semmni = ns->sc_semmni;\r\nseminfo.semmns = ns->sc_semmns;\r\nseminfo.semmsl = ns->sc_semmsl;\r\nseminfo.semopm = ns->sc_semopm;\r\nseminfo.semvmx = SEMVMX;\r\nseminfo.semmnu = SEMMNU;\r\nseminfo.semmap = SEMMAP;\r\nseminfo.semume = SEMUME;\r\ndown_read(&sem_ids(ns).rwsem);\r\nif (cmd == SEM_INFO) {\r\nseminfo.semusz = sem_ids(ns).in_use;\r\nseminfo.semaem = ns->used_sems;\r\n} else {\r\nseminfo.semusz = SEMUSZ;\r\nseminfo.semaem = SEMAEM;\r\n}\r\nmax_id = ipc_get_maxid(&sem_ids(ns));\r\nup_read(&sem_ids(ns).rwsem);\r\nif (copy_to_user(p, &seminfo, sizeof(struct seminfo)))\r\nreturn -EFAULT;\r\nreturn (max_id < 0) ? 0 : max_id;\r\n}\r\ncase IPC_STAT:\r\ncase SEM_STAT:\r\n{\r\nstruct semid64_ds tbuf;\r\nint id = 0;\r\nmemset(&tbuf, 0, sizeof(tbuf));\r\nrcu_read_lock();\r\nif (cmd == SEM_STAT) {\r\nsma = sem_obtain_object(ns, semid);\r\nif (IS_ERR(sma)) {\r\nerr = PTR_ERR(sma);\r\ngoto out_unlock;\r\n}\r\nid = sma->sem_perm.id;\r\n} else {\r\nsma = sem_obtain_object_check(ns, semid);\r\nif (IS_ERR(sma)) {\r\nerr = PTR_ERR(sma);\r\ngoto out_unlock;\r\n}\r\n}\r\nerr = -EACCES;\r\nif (ipcperms(ns, &sma->sem_perm, S_IRUGO))\r\ngoto out_unlock;\r\nerr = security_sem_semctl(sma, cmd);\r\nif (err)\r\ngoto out_unlock;\r\nkernel_to_ipc64_perm(&sma->sem_perm, &tbuf.sem_perm);\r\ntbuf.sem_otime = get_semotime(sma);\r\ntbuf.sem_ctime = sma->sem_ctime;\r\ntbuf.sem_nsems = sma->sem_nsems;\r\nrcu_read_unlock();\r\nif (copy_semid_to_user(p, &tbuf, version))\r\nreturn -EFAULT;\r\nreturn id;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nout_unlock:\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nstatic int semctl_setval(struct ipc_namespace *ns, int semid, int semnum,\r\nunsigned long arg)\r\n{\r\nstruct sem_undo *un;\r\nstruct sem_array *sma;\r\nstruct sem *curr;\r\nint err;\r\nstruct list_head tasks;\r\nint val;\r\n#if defined(CONFIG_64BIT) && defined(__BIG_ENDIAN)\r\nval = arg >> 32;\r\n#else\r\nval = arg;\r\n#endif\r\nif (val > SEMVMX || val < 0)\r\nreturn -ERANGE;\r\nINIT_LIST_HEAD(&tasks);\r\nrcu_read_lock();\r\nsma = sem_obtain_object_check(ns, semid);\r\nif (IS_ERR(sma)) {\r\nrcu_read_unlock();\r\nreturn PTR_ERR(sma);\r\n}\r\nif (semnum < 0 || semnum >= sma->sem_nsems) {\r\nrcu_read_unlock();\r\nreturn -EINVAL;\r\n}\r\nif (ipcperms(ns, &sma->sem_perm, S_IWUGO)) {\r\nrcu_read_unlock();\r\nreturn -EACCES;\r\n}\r\nerr = security_sem_semctl(sma, SETVAL);\r\nif (err) {\r\nrcu_read_unlock();\r\nreturn -EACCES;\r\n}\r\nsem_lock(sma, NULL, -1);\r\nif (!ipc_valid_object(&sma->sem_perm)) {\r\nsem_unlock(sma, -1);\r\nrcu_read_unlock();\r\nreturn -EIDRM;\r\n}\r\ncurr = &sma->sem_base[semnum];\r\nipc_assert_locked_object(&sma->sem_perm);\r\nlist_for_each_entry(un, &sma->list_id, list_id)\r\nun->semadj[semnum] = 0;\r\ncurr->semval = val;\r\ncurr->sempid = task_tgid_vnr(current);\r\nsma->sem_ctime = get_seconds();\r\ndo_smart_update(sma, NULL, 0, 0, &tasks);\r\nsem_unlock(sma, -1);\r\nrcu_read_unlock();\r\nwake_up_sem_queue_do(&tasks);\r\nreturn 0;\r\n}\r\nstatic int semctl_main(struct ipc_namespace *ns, int semid, int semnum,\r\nint cmd, void __user *p)\r\n{\r\nstruct sem_array *sma;\r\nstruct sem *curr;\r\nint err, nsems;\r\nushort fast_sem_io[SEMMSL_FAST];\r\nushort *sem_io = fast_sem_io;\r\nstruct list_head tasks;\r\nINIT_LIST_HEAD(&tasks);\r\nrcu_read_lock();\r\nsma = sem_obtain_object_check(ns, semid);\r\nif (IS_ERR(sma)) {\r\nrcu_read_unlock();\r\nreturn PTR_ERR(sma);\r\n}\r\nnsems = sma->sem_nsems;\r\nerr = -EACCES;\r\nif (ipcperms(ns, &sma->sem_perm, cmd == SETALL ? S_IWUGO : S_IRUGO))\r\ngoto out_rcu_wakeup;\r\nerr = security_sem_semctl(sma, cmd);\r\nif (err)\r\ngoto out_rcu_wakeup;\r\nerr = -EACCES;\r\nswitch (cmd) {\r\ncase GETALL:\r\n{\r\nushort __user *array = p;\r\nint i;\r\nsem_lock(sma, NULL, -1);\r\nif (!ipc_valid_object(&sma->sem_perm)) {\r\nerr = -EIDRM;\r\ngoto out_unlock;\r\n}\r\nif (nsems > SEMMSL_FAST) {\r\nif (!ipc_rcu_getref(sma)) {\r\nerr = -EIDRM;\r\ngoto out_unlock;\r\n}\r\nsem_unlock(sma, -1);\r\nrcu_read_unlock();\r\nsem_io = ipc_alloc(sizeof(ushort)*nsems);\r\nif (sem_io == NULL) {\r\nipc_rcu_putref(sma, ipc_rcu_free);\r\nreturn -ENOMEM;\r\n}\r\nrcu_read_lock();\r\nsem_lock_and_putref(sma);\r\nif (!ipc_valid_object(&sma->sem_perm)) {\r\nerr = -EIDRM;\r\ngoto out_unlock;\r\n}\r\n}\r\nfor (i = 0; i < sma->sem_nsems; i++)\r\nsem_io[i] = sma->sem_base[i].semval;\r\nsem_unlock(sma, -1);\r\nrcu_read_unlock();\r\nerr = 0;\r\nif (copy_to_user(array, sem_io, nsems*sizeof(ushort)))\r\nerr = -EFAULT;\r\ngoto out_free;\r\n}\r\ncase SETALL:\r\n{\r\nint i;\r\nstruct sem_undo *un;\r\nif (!ipc_rcu_getref(sma)) {\r\nerr = -EIDRM;\r\ngoto out_rcu_wakeup;\r\n}\r\nrcu_read_unlock();\r\nif (nsems > SEMMSL_FAST) {\r\nsem_io = ipc_alloc(sizeof(ushort)*nsems);\r\nif (sem_io == NULL) {\r\nipc_rcu_putref(sma, ipc_rcu_free);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (copy_from_user(sem_io, p, nsems*sizeof(ushort))) {\r\nipc_rcu_putref(sma, ipc_rcu_free);\r\nerr = -EFAULT;\r\ngoto out_free;\r\n}\r\nfor (i = 0; i < nsems; i++) {\r\nif (sem_io[i] > SEMVMX) {\r\nipc_rcu_putref(sma, ipc_rcu_free);\r\nerr = -ERANGE;\r\ngoto out_free;\r\n}\r\n}\r\nrcu_read_lock();\r\nsem_lock_and_putref(sma);\r\nif (!ipc_valid_object(&sma->sem_perm)) {\r\nerr = -EIDRM;\r\ngoto out_unlock;\r\n}\r\nfor (i = 0; i < nsems; i++)\r\nsma->sem_base[i].semval = sem_io[i];\r\nipc_assert_locked_object(&sma->sem_perm);\r\nlist_for_each_entry(un, &sma->list_id, list_id) {\r\nfor (i = 0; i < nsems; i++)\r\nun->semadj[i] = 0;\r\n}\r\nsma->sem_ctime = get_seconds();\r\ndo_smart_update(sma, NULL, 0, 0, &tasks);\r\nerr = 0;\r\ngoto out_unlock;\r\n}\r\n}\r\nerr = -EINVAL;\r\nif (semnum < 0 || semnum >= nsems)\r\ngoto out_rcu_wakeup;\r\nsem_lock(sma, NULL, -1);\r\nif (!ipc_valid_object(&sma->sem_perm)) {\r\nerr = -EIDRM;\r\ngoto out_unlock;\r\n}\r\ncurr = &sma->sem_base[semnum];\r\nswitch (cmd) {\r\ncase GETVAL:\r\nerr = curr->semval;\r\ngoto out_unlock;\r\ncase GETPID:\r\nerr = curr->sempid;\r\ngoto out_unlock;\r\ncase GETNCNT:\r\nerr = count_semcnt(sma, semnum, 0);\r\ngoto out_unlock;\r\ncase GETZCNT:\r\nerr = count_semcnt(sma, semnum, 1);\r\ngoto out_unlock;\r\n}\r\nout_unlock:\r\nsem_unlock(sma, -1);\r\nout_rcu_wakeup:\r\nrcu_read_unlock();\r\nwake_up_sem_queue_do(&tasks);\r\nout_free:\r\nif (sem_io != fast_sem_io)\r\nipc_free(sem_io, sizeof(ushort)*nsems);\r\nreturn err;\r\n}\r\nstatic inline unsigned long\r\ncopy_semid_from_user(struct semid64_ds *out, void __user *buf, int version)\r\n{\r\nswitch (version) {\r\ncase IPC_64:\r\nif (copy_from_user(out, buf, sizeof(*out)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase IPC_OLD:\r\n{\r\nstruct semid_ds tbuf_old;\r\nif (copy_from_user(&tbuf_old, buf, sizeof(tbuf_old)))\r\nreturn -EFAULT;\r\nout->sem_perm.uid = tbuf_old.sem_perm.uid;\r\nout->sem_perm.gid = tbuf_old.sem_perm.gid;\r\nout->sem_perm.mode = tbuf_old.sem_perm.mode;\r\nreturn 0;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int semctl_down(struct ipc_namespace *ns, int semid,\r\nint cmd, int version, void __user *p)\r\n{\r\nstruct sem_array *sma;\r\nint err;\r\nstruct semid64_ds semid64;\r\nstruct kern_ipc_perm *ipcp;\r\nif (cmd == IPC_SET) {\r\nif (copy_semid_from_user(&semid64, p, version))\r\nreturn -EFAULT;\r\n}\r\ndown_write(&sem_ids(ns).rwsem);\r\nrcu_read_lock();\r\nipcp = ipcctl_pre_down_nolock(ns, &sem_ids(ns), semid, cmd,\r\n&semid64.sem_perm, 0);\r\nif (IS_ERR(ipcp)) {\r\nerr = PTR_ERR(ipcp);\r\ngoto out_unlock1;\r\n}\r\nsma = container_of(ipcp, struct sem_array, sem_perm);\r\nerr = security_sem_semctl(sma, cmd);\r\nif (err)\r\ngoto out_unlock1;\r\nswitch (cmd) {\r\ncase IPC_RMID:\r\nsem_lock(sma, NULL, -1);\r\nfreeary(ns, ipcp);\r\ngoto out_up;\r\ncase IPC_SET:\r\nsem_lock(sma, NULL, -1);\r\nerr = ipc_update_perm(&semid64.sem_perm, ipcp);\r\nif (err)\r\ngoto out_unlock0;\r\nsma->sem_ctime = get_seconds();\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto out_unlock1;\r\n}\r\nout_unlock0:\r\nsem_unlock(sma, -1);\r\nout_unlock1:\r\nrcu_read_unlock();\r\nout_up:\r\nup_write(&sem_ids(ns).rwsem);\r\nreturn err;\r\n}\r\nstatic inline int get_undo_list(struct sem_undo_list **undo_listp)\r\n{\r\nstruct sem_undo_list *undo_list;\r\nundo_list = current->sysvsem.undo_list;\r\nif (!undo_list) {\r\nundo_list = kzalloc(sizeof(*undo_list), GFP_KERNEL);\r\nif (undo_list == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_init(&undo_list->lock);\r\natomic_set(&undo_list->refcnt, 1);\r\nINIT_LIST_HEAD(&undo_list->list_proc);\r\ncurrent->sysvsem.undo_list = undo_list;\r\n}\r\n*undo_listp = undo_list;\r\nreturn 0;\r\n}\r\nstatic struct sem_undo *__lookup_undo(struct sem_undo_list *ulp, int semid)\r\n{\r\nstruct sem_undo *un;\r\nlist_for_each_entry_rcu(un, &ulp->list_proc, list_proc) {\r\nif (un->semid == semid)\r\nreturn un;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct sem_undo *lookup_undo(struct sem_undo_list *ulp, int semid)\r\n{\r\nstruct sem_undo *un;\r\nassert_spin_locked(&ulp->lock);\r\nun = __lookup_undo(ulp, semid);\r\nif (un) {\r\nlist_del_rcu(&un->list_proc);\r\nlist_add_rcu(&un->list_proc, &ulp->list_proc);\r\n}\r\nreturn un;\r\n}\r\nstatic struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\r\n{\r\nstruct sem_array *sma;\r\nstruct sem_undo_list *ulp;\r\nstruct sem_undo *un, *new;\r\nint nsems, error;\r\nerror = get_undo_list(&ulp);\r\nif (error)\r\nreturn ERR_PTR(error);\r\nrcu_read_lock();\r\nspin_lock(&ulp->lock);\r\nun = lookup_undo(ulp, semid);\r\nspin_unlock(&ulp->lock);\r\nif (likely(un != NULL))\r\ngoto out;\r\nsma = sem_obtain_object_check(ns, semid);\r\nif (IS_ERR(sma)) {\r\nrcu_read_unlock();\r\nreturn ERR_CAST(sma);\r\n}\r\nnsems = sma->sem_nsems;\r\nif (!ipc_rcu_getref(sma)) {\r\nrcu_read_unlock();\r\nun = ERR_PTR(-EIDRM);\r\ngoto out;\r\n}\r\nrcu_read_unlock();\r\nnew = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);\r\nif (!new) {\r\nipc_rcu_putref(sma, ipc_rcu_free);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nrcu_read_lock();\r\nsem_lock_and_putref(sma);\r\nif (!ipc_valid_object(&sma->sem_perm)) {\r\nsem_unlock(sma, -1);\r\nrcu_read_unlock();\r\nkfree(new);\r\nun = ERR_PTR(-EIDRM);\r\ngoto out;\r\n}\r\nspin_lock(&ulp->lock);\r\nun = lookup_undo(ulp, semid);\r\nif (un) {\r\nkfree(new);\r\ngoto success;\r\n}\r\nnew->semadj = (short *) &new[1];\r\nnew->ulp = ulp;\r\nnew->semid = semid;\r\nassert_spin_locked(&ulp->lock);\r\nlist_add_rcu(&new->list_proc, &ulp->list_proc);\r\nipc_assert_locked_object(&sma->sem_perm);\r\nlist_add(&new->list_id, &sma->list_id);\r\nun = new;\r\nsuccess:\r\nspin_unlock(&ulp->lock);\r\nsem_unlock(sma, -1);\r\nout:\r\nreturn un;\r\n}\r\nstatic int get_queue_result(struct sem_queue *q)\r\n{\r\nint error;\r\nerror = q->status;\r\nwhile (unlikely(error == IN_WAKEUP)) {\r\ncpu_relax();\r\nerror = q->status;\r\n}\r\nreturn error;\r\n}\r\nint copy_semundo(unsigned long clone_flags, struct task_struct *tsk)\r\n{\r\nstruct sem_undo_list *undo_list;\r\nint error;\r\nif (clone_flags & CLONE_SYSVSEM) {\r\nerror = get_undo_list(&undo_list);\r\nif (error)\r\nreturn error;\r\natomic_inc(&undo_list->refcnt);\r\ntsk->sysvsem.undo_list = undo_list;\r\n} else\r\ntsk->sysvsem.undo_list = NULL;\r\nreturn 0;\r\n}\r\nvoid exit_sem(struct task_struct *tsk)\r\n{\r\nstruct sem_undo_list *ulp;\r\nulp = tsk->sysvsem.undo_list;\r\nif (!ulp)\r\nreturn;\r\ntsk->sysvsem.undo_list = NULL;\r\nif (!atomic_dec_and_test(&ulp->refcnt))\r\nreturn;\r\nfor (;;) {\r\nstruct sem_array *sma;\r\nstruct sem_undo *un;\r\nstruct list_head tasks;\r\nint semid, i;\r\nrcu_read_lock();\r\nun = list_entry_rcu(ulp->list_proc.next,\r\nstruct sem_undo, list_proc);\r\nif (&un->list_proc == &ulp->list_proc)\r\nsemid = -1;\r\nelse\r\nsemid = un->semid;\r\nif (semid == -1) {\r\nrcu_read_unlock();\r\nbreak;\r\n}\r\nsma = sem_obtain_object_check(tsk->nsproxy->ipc_ns, un->semid);\r\nif (IS_ERR(sma)) {\r\nrcu_read_unlock();\r\ncontinue;\r\n}\r\nsem_lock(sma, NULL, -1);\r\nif (!ipc_valid_object(&sma->sem_perm)) {\r\nsem_unlock(sma, -1);\r\nrcu_read_unlock();\r\ncontinue;\r\n}\r\nun = __lookup_undo(ulp, semid);\r\nif (un == NULL) {\r\nsem_unlock(sma, -1);\r\nrcu_read_unlock();\r\ncontinue;\r\n}\r\nipc_assert_locked_object(&sma->sem_perm);\r\nlist_del(&un->list_id);\r\nspin_lock(&ulp->lock);\r\nlist_del_rcu(&un->list_proc);\r\nspin_unlock(&ulp->lock);\r\nfor (i = 0; i < sma->sem_nsems; i++) {\r\nstruct sem *semaphore = &sma->sem_base[i];\r\nif (un->semadj[i]) {\r\nsemaphore->semval += un->semadj[i];\r\nif (semaphore->semval < 0)\r\nsemaphore->semval = 0;\r\nif (semaphore->semval > SEMVMX)\r\nsemaphore->semval = SEMVMX;\r\nsemaphore->sempid = task_tgid_vnr(current);\r\n}\r\n}\r\nINIT_LIST_HEAD(&tasks);\r\ndo_smart_update(sma, NULL, 0, 1, &tasks);\r\nsem_unlock(sma, -1);\r\nrcu_read_unlock();\r\nwake_up_sem_queue_do(&tasks);\r\nkfree_rcu(un, rcu);\r\n}\r\nkfree(ulp);\r\n}\r\nstatic int sysvipc_sem_proc_show(struct seq_file *s, void *it)\r\n{\r\nstruct user_namespace *user_ns = seq_user_ns(s);\r\nstruct sem_array *sma = it;\r\ntime_t sem_otime;\r\nsem_wait_array(sma);\r\nsem_otime = get_semotime(sma);\r\nreturn seq_printf(s,\r\n"%10d %10d %4o %10u %5u %5u %5u %5u %10lu %10lu\n",\r\nsma->sem_perm.key,\r\nsma->sem_perm.id,\r\nsma->sem_perm.mode,\r\nsma->sem_nsems,\r\nfrom_kuid_munged(user_ns, sma->sem_perm.uid),\r\nfrom_kgid_munged(user_ns, sma->sem_perm.gid),\r\nfrom_kuid_munged(user_ns, sma->sem_perm.cuid),\r\nfrom_kgid_munged(user_ns, sma->sem_perm.cgid),\r\nsem_otime,\r\nsma->sem_ctime);\r\n}
