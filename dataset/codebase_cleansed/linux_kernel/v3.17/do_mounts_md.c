static int __init md_setup(char *str)\r\n{\r\nint minor, level, factor, fault, partitioned = 0;\r\nchar *pername = "";\r\nchar *str1;\r\nint ent;\r\nif (*str == 'd') {\r\npartitioned = 1;\r\nstr++;\r\n}\r\nif (get_option(&str, &minor) != 2) {\r\nprintk(KERN_WARNING "md: Too few arguments supplied to md=.\n");\r\nreturn 0;\r\n}\r\nstr1 = str;\r\nfor (ent=0 ; ent< md_setup_ents ; ent++)\r\nif (md_setup_args[ent].minor == minor &&\r\nmd_setup_args[ent].partitioned == partitioned) {\r\nprintk(KERN_WARNING "md: md=%s%d, Specified more than once. "\r\n"Replacing previous definition.\n", partitioned?"d":"", minor);\r\nbreak;\r\n}\r\nif (ent >= ARRAY_SIZE(md_setup_args)) {\r\nprintk(KERN_WARNING "md: md=%s%d - too many md initialisations\n", partitioned?"d":"", minor);\r\nreturn 0;\r\n}\r\nif (ent >= md_setup_ents)\r\nmd_setup_ents++;\r\nswitch (get_option(&str, &level)) {\r\ncase 2:\r\nif (level == 0 || level == LEVEL_LINEAR) {\r\nif (get_option(&str, &factor) != 2 ||\r\nget_option(&str, &fault) != 2) {\r\nprintk(KERN_WARNING "md: Too few arguments supplied to md=.\n");\r\nreturn 0;\r\n}\r\nmd_setup_args[ent].level = level;\r\nmd_setup_args[ent].chunk = 1 << (factor+12);\r\nif (level == LEVEL_LINEAR)\r\npername = "linear";\r\nelse\r\npername = "raid0";\r\nbreak;\r\n}\r\ncase 1:\r\nstr = str1;\r\ncase 0:\r\nmd_setup_args[ent].level = LEVEL_NONE;\r\npername="super-block";\r\n}\r\nprintk(KERN_INFO "md: Will configure md%d (%s) from %s, below.\n",\r\nminor, pername, str);\r\nmd_setup_args[ent].device_names = str;\r\nmd_setup_args[ent].partitioned = partitioned;\r\nmd_setup_args[ent].minor = minor;\r\nreturn 1;\r\n}\r\nstatic void __init md_setup_drive(void)\r\n{\r\nint minor, i, ent, partitioned;\r\ndev_t dev;\r\ndev_t devices[MD_SB_DISKS+1];\r\nfor (ent = 0; ent < md_setup_ents ; ent++) {\r\nint fd;\r\nint err = 0;\r\nchar *devname;\r\nmdu_disk_info_t dinfo;\r\nchar name[16];\r\nminor = md_setup_args[ent].minor;\r\npartitioned = md_setup_args[ent].partitioned;\r\ndevname = md_setup_args[ent].device_names;\r\nsprintf(name, "/dev/md%s%d", partitioned?"_d":"", minor);\r\nif (partitioned)\r\ndev = MKDEV(mdp_major, minor << MdpMinorShift);\r\nelse\r\ndev = MKDEV(MD_MAJOR, minor);\r\ncreate_dev(name, dev);\r\nfor (i = 0; i < MD_SB_DISKS && devname != NULL; i++) {\r\nchar *p;\r\nchar comp_name[64];\r\nu32 rdev;\r\np = strchr(devname, ',');\r\nif (p)\r\n*p++ = 0;\r\ndev = name_to_dev_t(devname);\r\nif (strncmp(devname, "/dev/", 5) == 0)\r\ndevname += 5;\r\nsnprintf(comp_name, 63, "/dev/%s", devname);\r\nrdev = bstat(comp_name);\r\nif (rdev)\r\ndev = new_decode_dev(rdev);\r\nif (!dev) {\r\nprintk(KERN_WARNING "md: Unknown device name: %s\n", devname);\r\nbreak;\r\n}\r\ndevices[i] = dev;\r\ndevname = p;\r\n}\r\ndevices[i] = 0;\r\nif (!i)\r\ncontinue;\r\nprintk(KERN_INFO "md: Loading md%s%d: %s\n",\r\npartitioned ? "_d" : "", minor,\r\nmd_setup_args[ent].device_names);\r\nfd = sys_open(name, 0, 0);\r\nif (fd < 0) {\r\nprintk(KERN_ERR "md: open failed - cannot start "\r\n"array %s\n", name);\r\ncontinue;\r\n}\r\nif (sys_ioctl(fd, SET_ARRAY_INFO, 0) == -EBUSY) {\r\nprintk(KERN_WARNING\r\n"md: Ignoring md=%d, already autodetected. (Use raid=noautodetect)\n",\r\nminor);\r\nsys_close(fd);\r\ncontinue;\r\n}\r\nif (md_setup_args[ent].level != LEVEL_NONE) {\r\nmdu_array_info_t ainfo;\r\nainfo.level = md_setup_args[ent].level;\r\nainfo.size = 0;\r\nainfo.nr_disks =0;\r\nainfo.raid_disks =0;\r\nwhile (devices[ainfo.raid_disks])\r\nainfo.raid_disks++;\r\nainfo.md_minor =minor;\r\nainfo.not_persistent = 1;\r\nainfo.state = (1 << MD_SB_CLEAN);\r\nainfo.layout = 0;\r\nainfo.chunk_size = md_setup_args[ent].chunk;\r\nerr = sys_ioctl(fd, SET_ARRAY_INFO, (long)&ainfo);\r\nfor (i = 0; !err && i <= MD_SB_DISKS; i++) {\r\ndev = devices[i];\r\nif (!dev)\r\nbreak;\r\ndinfo.number = i;\r\ndinfo.raid_disk = i;\r\ndinfo.state = (1<<MD_DISK_ACTIVE)|(1<<MD_DISK_SYNC);\r\ndinfo.major = MAJOR(dev);\r\ndinfo.minor = MINOR(dev);\r\nerr = sys_ioctl(fd, ADD_NEW_DISK, (long)&dinfo);\r\n}\r\n} else {\r\nfor (i = 0; i <= MD_SB_DISKS; i++) {\r\ndev = devices[i];\r\nif (!dev)\r\nbreak;\r\ndinfo.major = MAJOR(dev);\r\ndinfo.minor = MINOR(dev);\r\nsys_ioctl(fd, ADD_NEW_DISK, (long)&dinfo);\r\n}\r\n}\r\nif (!err)\r\nerr = sys_ioctl(fd, RUN_ARRAY, 0);\r\nif (err)\r\nprintk(KERN_WARNING "md: starting md%d failed\n", minor);\r\nelse {\r\nsys_close(fd);\r\nfd = sys_open(name, 0, 0);\r\nsys_ioctl(fd, BLKRRPART, 0);\r\n}\r\nsys_close(fd);\r\n}\r\n}\r\nstatic int __init raid_setup(char *str)\r\n{\r\nint len, pos;\r\nlen = strlen(str) + 1;\r\npos = 0;\r\nwhile (pos < len) {\r\nchar *comma = strchr(str+pos, ',');\r\nint wlen;\r\nif (comma)\r\nwlen = (comma-str)-pos;\r\nelse wlen = (len-1)-pos;\r\nif (!strncmp(str, "noautodetect", wlen))\r\nraid_noautodetect = 1;\r\nif (!strncmp(str, "autodetect", wlen))\r\nraid_noautodetect = 0;\r\nif (strncmp(str, "partitionable", wlen)==0)\r\nraid_autopart = 1;\r\nif (strncmp(str, "part", wlen)==0)\r\nraid_autopart = 1;\r\npos += wlen+1;\r\n}\r\nreturn 1;\r\n}\r\nstatic void __init autodetect_raid(void)\r\n{\r\nint fd;\r\nprintk(KERN_INFO "md: Waiting for all devices to be available before autodetect\n");\r\nprintk(KERN_INFO "md: If you don't use raid, use raid=noautodetect\n");\r\nwait_for_device_probe();\r\nfd = sys_open("/dev/md0", 0, 0);\r\nif (fd >= 0) {\r\nsys_ioctl(fd, RAID_AUTORUN, raid_autopart);\r\nsys_close(fd);\r\n}\r\n}\r\nvoid __init md_run_setup(void)\r\n{\r\ncreate_dev("/dev/md0", MKDEV(MD_MAJOR, 0));\r\nif (raid_noautodetect)\r\nprintk(KERN_INFO "md: Skipping autodetection of RAID arrays. (raid=autodetect will force)\n");\r\nelse\r\nautodetect_raid();\r\nmd_setup_drive();\r\n}
