static int thingm_send(struct thingm_device *tdev, u8 buf[REPORT_SIZE])\r\n{\r\nint ret;\r\nhid_dbg(tdev->hdev, "-> %d %c %02hhx %02hhx %02hhx %02hhx %02hhx %02hhx %02hhx\n",\r\nbuf[0], buf[1], buf[2], buf[3], buf[4],\r\nbuf[5], buf[6], buf[7], buf[8]);\r\nret = hid_hw_raw_request(tdev->hdev, buf[0], buf, REPORT_SIZE,\r\nHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic int thingm_recv(struct thingm_device *tdev, u8 buf[REPORT_SIZE])\r\n{\r\nint ret;\r\nret = hid_hw_raw_request(tdev->hdev, buf[0], buf, REPORT_SIZE,\r\nHID_FEATURE_REPORT, HID_REQ_GET_REPORT);\r\nif (ret < 0)\r\nreturn ret;\r\nhid_dbg(tdev->hdev, "<- %d %c %02hhx %02hhx %02hhx %02hhx %02hhx %02hhx %02hhx\n",\r\nbuf[0], buf[1], buf[2], buf[3], buf[4],\r\nbuf[5], buf[6], buf[7], buf[8]);\r\nreturn 0;\r\n}\r\nstatic int thingm_version(struct thingm_device *tdev)\r\n{\r\nu8 buf[REPORT_SIZE] = { REPORT_ID, 'v', 0, 0, 0, 0, 0, 0, 0 };\r\nint err;\r\nerr = thingm_send(tdev, buf);\r\nif (err)\r\nreturn err;\r\nerr = thingm_recv(tdev, buf);\r\nif (err)\r\nreturn err;\r\ntdev->version.major = buf[3];\r\ntdev->version.minor = buf[4];\r\nreturn 0;\r\n}\r\nstatic int thingm_write_color(struct thingm_rgb *rgb)\r\n{\r\nu8 buf[REPORT_SIZE] = { REPORT_ID, 'c', 0, 0, 0, 0, 0, rgb->num, 0 };\r\nbuf[2] = rgb->red.ldev.brightness;\r\nbuf[3] = rgb->green.ldev.brightness;\r\nbuf[4] = rgb->blue.ldev.brightness;\r\nreturn thingm_send(rgb->tdev, buf);\r\n}\r\nstatic void thingm_work(struct work_struct *work)\r\n{\r\nstruct thingm_rgb *rgb = container_of(work, struct thingm_rgb, work);\r\nmutex_lock(&rgb->tdev->lock);\r\nif (thingm_write_color(rgb))\r\nhid_err(rgb->tdev->hdev, "failed to write color\n");\r\nmutex_unlock(&rgb->tdev->lock);\r\n}\r\nstatic void thingm_led_set(struct led_classdev *ldev,\r\nenum led_brightness brightness)\r\n{\r\nstruct thingm_led *led = container_of(ldev, struct thingm_led, ldev);\r\nschedule_work(&led->rgb->work);\r\n}\r\nstatic int thingm_init_rgb(struct thingm_rgb *rgb)\r\n{\r\nconst int minor = ((struct hidraw *) rgb->tdev->hdev->hidraw)->minor;\r\nint err;\r\nsnprintf(rgb->red.name, sizeof(rgb->red.name),\r\n"thingm%d:red:led%d", minor, rgb->num);\r\nrgb->red.ldev.name = rgb->red.name;\r\nrgb->red.ldev.max_brightness = 255;\r\nrgb->red.ldev.brightness_set = thingm_led_set;\r\nrgb->red.rgb = rgb;\r\nerr = led_classdev_register(&rgb->tdev->hdev->dev, &rgb->red.ldev);\r\nif (err)\r\nreturn err;\r\nsnprintf(rgb->green.name, sizeof(rgb->green.name),\r\n"thingm%d:green:led%d", minor, rgb->num);\r\nrgb->green.ldev.name = rgb->green.name;\r\nrgb->green.ldev.max_brightness = 255;\r\nrgb->green.ldev.brightness_set = thingm_led_set;\r\nrgb->green.rgb = rgb;\r\nerr = led_classdev_register(&rgb->tdev->hdev->dev, &rgb->green.ldev);\r\nif (err)\r\ngoto unregister_red;\r\nsnprintf(rgb->blue.name, sizeof(rgb->blue.name),\r\n"thingm%d:blue:led%d", minor, rgb->num);\r\nrgb->blue.ldev.name = rgb->blue.name;\r\nrgb->blue.ldev.max_brightness = 255;\r\nrgb->blue.ldev.brightness_set = thingm_led_set;\r\nrgb->blue.rgb = rgb;\r\nerr = led_classdev_register(&rgb->tdev->hdev->dev, &rgb->blue.ldev);\r\nif (err)\r\ngoto unregister_green;\r\nINIT_WORK(&rgb->work, thingm_work);\r\nreturn 0;\r\nunregister_green:\r\nled_classdev_unregister(&rgb->green.ldev);\r\nunregister_red:\r\nled_classdev_unregister(&rgb->red.ldev);\r\nreturn err;\r\n}\r\nstatic void thingm_remove_rgb(struct thingm_rgb *rgb)\r\n{\r\nflush_work(&rgb->work);\r\nled_classdev_unregister(&rgb->red.ldev);\r\nled_classdev_unregister(&rgb->green.ldev);\r\nled_classdev_unregister(&rgb->blue.ldev);\r\n}\r\nstatic int thingm_probe(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nstruct thingm_device *tdev;\r\nint i, err;\r\ntdev = devm_kzalloc(&hdev->dev, sizeof(struct thingm_device),\r\nGFP_KERNEL);\r\nif (!tdev)\r\nreturn -ENOMEM;\r\ntdev->hdev = hdev;\r\nhid_set_drvdata(hdev, tdev);\r\nerr = hid_parse(hdev);\r\nif (err)\r\ngoto error;\r\nerr = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\r\nif (err)\r\ngoto error;\r\nmutex_init(&tdev->lock);\r\nerr = thingm_version(tdev);\r\nif (err)\r\ngoto stop;\r\nhid_dbg(hdev, "firmware version: %c.%c\n",\r\ntdev->version.major, tdev->version.minor);\r\nfor (i = 0; i < ARRAY_SIZE(thingm_fwinfo) && !tdev->fwinfo; ++i)\r\nif (thingm_fwinfo[i].major == tdev->version.major)\r\ntdev->fwinfo = &thingm_fwinfo[i];\r\nif (!tdev->fwinfo) {\r\nhid_err(hdev, "unsupported firmware %c\n", tdev->version.major);\r\ngoto stop;\r\n}\r\ntdev->rgb = devm_kzalloc(&hdev->dev,\r\nsizeof(struct thingm_rgb) * tdev->fwinfo->numrgb,\r\nGFP_KERNEL);\r\nif (!tdev->rgb) {\r\nerr = -ENOMEM;\r\ngoto stop;\r\n}\r\nfor (i = 0; i < tdev->fwinfo->numrgb; ++i) {\r\nstruct thingm_rgb *rgb = tdev->rgb + i;\r\nrgb->tdev = tdev;\r\nrgb->num = tdev->fwinfo->first + i;\r\nerr = thingm_init_rgb(rgb);\r\nif (err) {\r\nwhile (--i >= 0)\r\nthingm_remove_rgb(tdev->rgb + i);\r\ngoto stop;\r\n}\r\n}\r\nreturn 0;\r\nstop:\r\nhid_hw_stop(hdev);\r\nerror:\r\nreturn err;\r\n}\r\nstatic void thingm_remove(struct hid_device *hdev)\r\n{\r\nstruct thingm_device *tdev = hid_get_drvdata(hdev);\r\nint i;\r\nfor (i = 0; i < tdev->fwinfo->numrgb; ++i)\r\nthingm_remove_rgb(tdev->rgb + i);\r\nhid_hw_stop(hdev);\r\n}
