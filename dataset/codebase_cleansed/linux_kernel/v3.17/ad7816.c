static int ad7816_spi_read(struct ad7816_chip_info *chip, u16 *data)\r\n{\r\nstruct spi_device *spi_dev = chip->spi_dev;\r\nint ret = 0;\r\ngpio_set_value(chip->rdwr_pin, 1);\r\ngpio_set_value(chip->rdwr_pin, 0);\r\nret = spi_write(spi_dev, &chip->channel_id, sizeof(chip->channel_id));\r\nif (ret < 0) {\r\ndev_err(&spi_dev->dev, "SPI channel setting error\n");\r\nreturn ret;\r\n}\r\ngpio_set_value(chip->rdwr_pin, 1);\r\nif (chip->mode == AD7816_PD) {\r\ngpio_set_value(chip->convert_pin, 1);\r\ngpio_set_value(chip->convert_pin, 0);\r\n} else {\r\ngpio_set_value(chip->convert_pin, 0);\r\ngpio_set_value(chip->convert_pin, 1);\r\n}\r\nwhile (gpio_get_value(chip->busy_pin))\r\ncpu_relax();\r\ngpio_set_value(chip->rdwr_pin, 0);\r\ngpio_set_value(chip->rdwr_pin, 1);\r\nret = spi_read(spi_dev, (u8 *)data, sizeof(*data));\r\nif (ret < 0) {\r\ndev_err(&spi_dev->dev, "SPI data read error\n");\r\nreturn ret;\r\n}\r\n*data = be16_to_cpu(*data);\r\nreturn ret;\r\n}\r\nstatic int ad7816_spi_write(struct ad7816_chip_info *chip, u8 data)\r\n{\r\nstruct spi_device *spi_dev = chip->spi_dev;\r\nint ret = 0;\r\ngpio_set_value(chip->rdwr_pin, 1);\r\ngpio_set_value(chip->rdwr_pin, 0);\r\nret = spi_write(spi_dev, &data, sizeof(data));\r\nif (ret < 0)\r\ndev_err(&spi_dev->dev, "SPI oti data write error\n");\r\nreturn ret;\r\n}\r\nstatic ssize_t ad7816_show_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad7816_chip_info *chip = iio_priv(indio_dev);\r\nif (chip->mode)\r\nreturn sprintf(buf, "power-save\n");\r\nelse\r\nreturn sprintf(buf, "full\n");\r\n}\r\nstatic ssize_t ad7816_store_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad7816_chip_info *chip = iio_priv(indio_dev);\r\nif (strcmp(buf, "full")) {\r\ngpio_set_value(chip->rdwr_pin, 1);\r\nchip->mode = AD7816_FULL;\r\n} else {\r\ngpio_set_value(chip->rdwr_pin, 0);\r\nchip->mode = AD7816_PD;\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t ad7816_show_available_modes(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "full\npower-save\n");\r\n}\r\nstatic ssize_t ad7816_show_channel(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad7816_chip_info *chip = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%d\n", chip->channel_id);\r\n}\r\nstatic ssize_t ad7816_store_channel(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad7816_chip_info *chip = iio_priv(indio_dev);\r\nunsigned long data;\r\nint ret;\r\nret = kstrtoul(buf, 10, &data);\r\nif (ret)\r\nreturn ret;\r\nif (data > AD7816_CS_MAX && data != AD7816_CS_MASK) {\r\ndev_err(&chip->spi_dev->dev, "Invalid channel id %lu for %s.\n",\r\ndata, indio_dev->name);\r\nreturn -EINVAL;\r\n} else if (strcmp(indio_dev->name, "ad7818") == 0 && data > 1) {\r\ndev_err(&chip->spi_dev->dev,\r\n"Invalid channel id %lu for ad7818.\n", data);\r\nreturn -EINVAL;\r\n} else if (strcmp(indio_dev->name, "ad7816") == 0 && data > 0) {\r\ndev_err(&chip->spi_dev->dev,\r\n"Invalid channel id %lu for ad7816.\n", data);\r\nreturn -EINVAL;\r\n}\r\nchip->channel_id = data;\r\nreturn len;\r\n}\r\nstatic ssize_t ad7816_show_value(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad7816_chip_info *chip = iio_priv(indio_dev);\r\nu16 data;\r\ns8 value;\r\nint ret;\r\nret = ad7816_spi_read(chip, &data);\r\nif (ret)\r\nreturn -EIO;\r\ndata >>= AD7816_VALUE_OFFSET;\r\nif (chip->channel_id == 0) {\r\nvalue = (s8)((data >> AD7816_TEMP_FLOAT_OFFSET) - 103);\r\ndata &= AD7816_TEMP_FLOAT_MASK;\r\nif (value < 0)\r\ndata = (1 << AD7816_TEMP_FLOAT_OFFSET) - data;\r\nreturn sprintf(buf, "%d.%.2d\n", value, data * 25);\r\n} else\r\nreturn sprintf(buf, "%u\n", data);\r\n}\r\nstatic irqreturn_t ad7816_event_handler(int irq, void *private)\r\n{\r\niio_push_event(private, IIO_EVENT_CODE_AD7816_OTI, iio_get_time_ns());\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic ssize_t ad7816_show_oti(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad7816_chip_info *chip = iio_priv(indio_dev);\r\nint value;\r\nif (chip->channel_id > AD7816_CS_MAX) {\r\ndev_err(dev, "Invalid oti channel id %d.\n", chip->channel_id);\r\nreturn -EINVAL;\r\n} else if (chip->channel_id == 0) {\r\nvalue = AD7816_BOUND_VALUE_MIN +\r\n(chip->oti_data[chip->channel_id] -\r\nAD7816_BOUND_VALUE_BASE);\r\nreturn sprintf(buf, "%d\n", value);\r\n} else\r\nreturn sprintf(buf, "%u\n", chip->oti_data[chip->channel_id]);\r\n}\r\nstatic inline ssize_t ad7816_set_oti(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad7816_chip_info *chip = iio_priv(indio_dev);\r\nlong value;\r\nu8 data;\r\nint ret;\r\nret = kstrtol(buf, 10, &value);\r\nif (ret)\r\nreturn ret;\r\nif (chip->channel_id > AD7816_CS_MAX) {\r\ndev_err(dev, "Invalid oti channel id %d.\n", chip->channel_id);\r\nreturn -EINVAL;\r\n} else if (chip->channel_id == 0) {\r\nif (ret || value < AD7816_BOUND_VALUE_MIN ||\r\nvalue > AD7816_BOUND_VALUE_MAX)\r\nreturn -EINVAL;\r\ndata = (u8)(value - AD7816_BOUND_VALUE_MIN +\r\nAD7816_BOUND_VALUE_BASE);\r\n} else {\r\nif (ret || value < AD7816_BOUND_VALUE_BASE || value > 255)\r\nreturn -EINVAL;\r\ndata = (u8)value;\r\n}\r\nret = ad7816_spi_write(chip, data);\r\nif (ret)\r\nreturn -EIO;\r\nchip->oti_data[chip->channel_id] = data;\r\nreturn len;\r\n}\r\nstatic int ad7816_probe(struct spi_device *spi_dev)\r\n{\r\nstruct ad7816_chip_info *chip;\r\nstruct iio_dev *indio_dev;\r\nunsigned short *pins = spi_dev->dev.platform_data;\r\nint ret = 0;\r\nint i;\r\nif (!pins) {\r\ndev_err(&spi_dev->dev, "No necessary GPIO platform data.\n");\r\nreturn -EINVAL;\r\n}\r\nindio_dev = devm_iio_device_alloc(&spi_dev->dev, sizeof(*chip));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nchip = iio_priv(indio_dev);\r\ndev_set_drvdata(&spi_dev->dev, indio_dev);\r\nchip->spi_dev = spi_dev;\r\nfor (i = 0; i <= AD7816_CS_MAX; i++)\r\nchip->oti_data[i] = 203;\r\nchip->rdwr_pin = pins[0];\r\nchip->convert_pin = pins[1];\r\nchip->busy_pin = pins[2];\r\nret = devm_gpio_request(&spi_dev->dev, chip->rdwr_pin,\r\nspi_get_device_id(spi_dev)->name);\r\nif (ret) {\r\ndev_err(&spi_dev->dev, "Fail to request rdwr gpio PIN %d.\n",\r\nchip->rdwr_pin);\r\nreturn ret;\r\n}\r\ngpio_direction_input(chip->rdwr_pin);\r\nret = devm_gpio_request(&spi_dev->dev, chip->convert_pin,\r\nspi_get_device_id(spi_dev)->name);\r\nif (ret) {\r\ndev_err(&spi_dev->dev, "Fail to request convert gpio PIN %d.\n",\r\nchip->convert_pin);\r\nreturn ret;\r\n}\r\ngpio_direction_input(chip->convert_pin);\r\nret = devm_gpio_request(&spi_dev->dev, chip->busy_pin,\r\nspi_get_device_id(spi_dev)->name);\r\nif (ret) {\r\ndev_err(&spi_dev->dev, "Fail to request busy gpio PIN %d.\n",\r\nchip->busy_pin);\r\nreturn ret;\r\n}\r\ngpio_direction_input(chip->busy_pin);\r\nindio_dev->name = spi_get_device_id(spi_dev)->name;\r\nindio_dev->dev.parent = &spi_dev->dev;\r\nindio_dev->info = &ad7816_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nif (spi_dev->irq) {\r\nret = devm_request_threaded_irq(&spi_dev->dev, spi_dev->irq,\r\nNULL,\r\n&ad7816_event_handler,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\nindio_dev->name,\r\nindio_dev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = devm_iio_device_register(&spi_dev->dev, indio_dev);\r\nif (ret)\r\nreturn ret;\r\ndev_info(&spi_dev->dev, "%s temperature sensor and ADC registered.\n",\r\nindio_dev->name);\r\nreturn 0;\r\n}
