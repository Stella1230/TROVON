static void\r\ncleanup(void)\r\n{\r\nif (!mmap_failed)\r\nmunmap(ehdr_curr, sb.st_size);\r\nelse\r\nfree(ehdr_curr);\r\nclose(fd_map);\r\n}\r\nstatic off_t\r\nulseek(int const fd, off_t const offset, int const whence)\r\n{\r\noff_t const w = lseek(fd, offset, whence);\r\nif (w == (off_t)-1) {\r\nperror("lseek");\r\nfail_file();\r\n}\r\nreturn w;\r\n}\r\nstatic size_t\r\nuread(int const fd, void *const buf, size_t const count)\r\n{\r\nsize_t const n = read(fd, buf, count);\r\nif (n != count) {\r\nperror("read");\r\nfail_file();\r\n}\r\nreturn n;\r\n}\r\nstatic size_t\r\nuwrite(int const fd, void const *const buf, size_t const count)\r\n{\r\nsize_t const n = write(fd, buf, count);\r\nif (n != count) {\r\nperror("write");\r\nfail_file();\r\n}\r\nreturn n;\r\n}\r\nstatic void *\r\numalloc(size_t size)\r\n{\r\nvoid *const addr = malloc(size);\r\nif (addr == 0) {\r\nfprintf(stderr, "malloc failed: %zu bytes\n", size);\r\nfail_file();\r\n}\r\nreturn addr;\r\n}\r\nstatic int make_nop_x86(void *map, size_t const offset)\r\n{\r\nuint32_t *ptr;\r\nunsigned char *op;\r\nptr = map + offset;\r\nif (*ptr != 0)\r\nreturn -1;\r\nop = map + offset - 1;\r\nif (*op != 0xe8)\r\nreturn -1;\r\nulseek(fd_map, offset - 1, SEEK_SET);\r\nuwrite(fd_map, ideal_nop, 5);\r\nreturn 0;\r\n}\r\nstatic void *mmap_file(char const *fname)\r\n{\r\nvoid *addr;\r\nfd_map = open(fname, O_RDWR);\r\nif (fd_map < 0 || fstat(fd_map, &sb) < 0) {\r\nperror(fname);\r\nfail_file();\r\n}\r\nif (!S_ISREG(sb.st_mode)) {\r\nfprintf(stderr, "not a regular file: %s\n", fname);\r\nfail_file();\r\n}\r\naddr = mmap(0, sb.st_size, PROT_READ|PROT_WRITE, MAP_PRIVATE,\r\nfd_map, 0);\r\nmmap_failed = 0;\r\nif (addr == MAP_FAILED) {\r\nmmap_failed = 1;\r\naddr = umalloc(sb.st_size);\r\nuread(fd_map, addr, sb.st_size);\r\n}\r\nreturn addr;\r\n}\r\nstatic uint64_t w8rev(uint64_t const x)\r\n{\r\nreturn ((0xff & (x >> (0 * 8))) << (7 * 8))\r\n| ((0xff & (x >> (1 * 8))) << (6 * 8))\r\n| ((0xff & (x >> (2 * 8))) << (5 * 8))\r\n| ((0xff & (x >> (3 * 8))) << (4 * 8))\r\n| ((0xff & (x >> (4 * 8))) << (3 * 8))\r\n| ((0xff & (x >> (5 * 8))) << (2 * 8))\r\n| ((0xff & (x >> (6 * 8))) << (1 * 8))\r\n| ((0xff & (x >> (7 * 8))) << (0 * 8));\r\n}\r\nstatic uint32_t w4rev(uint32_t const x)\r\n{\r\nreturn ((0xff & (x >> (0 * 8))) << (3 * 8))\r\n| ((0xff & (x >> (1 * 8))) << (2 * 8))\r\n| ((0xff & (x >> (2 * 8))) << (1 * 8))\r\n| ((0xff & (x >> (3 * 8))) << (0 * 8));\r\n}\r\nstatic uint32_t w2rev(uint16_t const x)\r\n{\r\nreturn ((0xff & (x >> (0 * 8))) << (1 * 8))\r\n| ((0xff & (x >> (1 * 8))) << (0 * 8));\r\n}\r\nstatic uint64_t w8nat(uint64_t const x)\r\n{\r\nreturn x;\r\n}\r\nstatic uint32_t w4nat(uint32_t const x)\r\n{\r\nreturn x;\r\n}\r\nstatic uint32_t w2nat(uint16_t const x)\r\n{\r\nreturn x;\r\n}\r\nstatic int\r\nis_mcounted_section_name(char const *const txtname)\r\n{\r\nreturn strcmp(".text", txtname) == 0 ||\r\nstrcmp(".ref.text", txtname) == 0 ||\r\nstrcmp(".sched.text", txtname) == 0 ||\r\nstrcmp(".spinlock.text", txtname) == 0 ||\r\nstrcmp(".irqentry.text", txtname) == 0 ||\r\nstrcmp(".kprobes.text", txtname) == 0 ||\r\nstrcmp(".text.unlikely", txtname) == 0;\r\n}\r\nstatic uint64_t MIPS64_r_sym(Elf64_Rel const *rp)\r\n{\r\nreturn w(((union mips_r_info){ .r_info = rp->r_info }).r_mips.r_sym);\r\n}\r\nstatic void MIPS64_r_info(Elf64_Rel *const rp, unsigned sym, unsigned type)\r\n{\r\nrp->r_info = ((union mips_r_info){\r\n.r_mips = { .r_sym = w(sym), .r_type = type }\r\n}).r_info;\r\n}\r\nstatic void\r\ndo_file(char const *const fname)\r\n{\r\nElf32_Ehdr *const ehdr = mmap_file(fname);\r\nunsigned int reltype = 0;\r\nehdr_curr = ehdr;\r\nw = w4nat;\r\nw2 = w2nat;\r\nw8 = w8nat;\r\nswitch (ehdr->e_ident[EI_DATA]) {\r\nstatic unsigned int const endian = 1;\r\ndefault:\r\nfprintf(stderr, "unrecognized ELF data encoding %d: %s\n",\r\nehdr->e_ident[EI_DATA], fname);\r\nfail_file();\r\nbreak;\r\ncase ELFDATA2LSB:\r\nif (*(unsigned char const *)&endian != 1) {\r\nw = w4rev;\r\nw2 = w2rev;\r\nw8 = w8rev;\r\n}\r\nbreak;\r\ncase ELFDATA2MSB:\r\nif (*(unsigned char const *)&endian != 0) {\r\nw = w4rev;\r\nw2 = w2rev;\r\nw8 = w8rev;\r\n}\r\nbreak;\r\n}\r\nif (memcmp(ELFMAG, ehdr->e_ident, SELFMAG) != 0\r\n|| w2(ehdr->e_type) != ET_REL\r\n|| ehdr->e_ident[EI_VERSION] != EV_CURRENT) {\r\nfprintf(stderr, "unrecognized ET_REL file %s\n", fname);\r\nfail_file();\r\n}\r\ngpfx = 0;\r\nswitch (w2(ehdr->e_machine)) {\r\ndefault:\r\nfprintf(stderr, "unrecognized e_machine %d %s\n",\r\nw2(ehdr->e_machine), fname);\r\nfail_file();\r\nbreak;\r\ncase EM_386:\r\nreltype = R_386_32;\r\nmake_nop = make_nop_x86;\r\nideal_nop = ideal_nop5_x86_32;\r\nmcount_adjust_32 = -1;\r\nbreak;\r\ncase EM_ARM: reltype = R_ARM_ABS32;\r\naltmcount = "__gnu_mcount_nc";\r\nbreak;\r\ncase EM_AARCH64:\r\nreltype = R_AARCH64_ABS64; gpfx = '_'; break;\r\ncase EM_IA_64: reltype = R_IA64_IMM64; gpfx = '_'; break;\r\ncase EM_METAG: reltype = R_METAG_ADDR32;\r\naltmcount = "_mcount_wrapper";\r\nrel_type_nop = R_METAG_NONE;\r\nis_fake_mcount32 = MIPS32_is_fake_mcount;\r\nbreak;\r\ncase EM_MIPS: gpfx = '_'; break;\r\ncase EM_PPC: reltype = R_PPC_ADDR32; gpfx = '_'; break;\r\ncase EM_PPC64: reltype = R_PPC64_ADDR64; gpfx = '_'; break;\r\ncase EM_S390: gpfx = '_'; break;\r\ncase EM_SH: reltype = R_SH_DIR32; break;\r\ncase EM_SPARCV9: reltype = R_SPARC_64; gpfx = '_'; break;\r\ncase EM_X86_64:\r\nmake_nop = make_nop_x86;\r\nideal_nop = ideal_nop5_x86_64;\r\nreltype = R_X86_64_64;\r\nmcount_adjust_64 = -1;\r\nbreak;\r\n}\r\nswitch (ehdr->e_ident[EI_CLASS]) {\r\ndefault:\r\nfprintf(stderr, "unrecognized ELF class %d %s\n",\r\nehdr->e_ident[EI_CLASS], fname);\r\nfail_file();\r\nbreak;\r\ncase ELFCLASS32:\r\nif (w2(ehdr->e_ehsize) != sizeof(Elf32_Ehdr)\r\n|| w2(ehdr->e_shentsize) != sizeof(Elf32_Shdr)) {\r\nfprintf(stderr,\r\n"unrecognized ET_REL file: %s\n", fname);\r\nfail_file();\r\n}\r\nif (w2(ehdr->e_machine) == EM_S390) {\r\nreltype = R_390_32;\r\nmcount_adjust_32 = -4;\r\n}\r\nif (w2(ehdr->e_machine) == EM_MIPS) {\r\nreltype = R_MIPS_32;\r\nis_fake_mcount32 = MIPS32_is_fake_mcount;\r\n}\r\ndo32(ehdr, fname, reltype);\r\nbreak;\r\ncase ELFCLASS64: {\r\nElf64_Ehdr *const ghdr = (Elf64_Ehdr *)ehdr;\r\nif (w2(ghdr->e_ehsize) != sizeof(Elf64_Ehdr)\r\n|| w2(ghdr->e_shentsize) != sizeof(Elf64_Shdr)) {\r\nfprintf(stderr,\r\n"unrecognized ET_REL file: %s\n", fname);\r\nfail_file();\r\n}\r\nif (w2(ghdr->e_machine) == EM_S390) {\r\nreltype = R_390_64;\r\nmcount_adjust_64 = -8;\r\n}\r\nif (w2(ghdr->e_machine) == EM_MIPS) {\r\nreltype = R_MIPS_64;\r\nElf64_r_sym = MIPS64_r_sym;\r\nElf64_r_info = MIPS64_r_info;\r\nis_fake_mcount64 = MIPS64_is_fake_mcount;\r\n}\r\ndo64(ghdr, fname, reltype);\r\nbreak;\r\n}\r\n}\r\ncleanup();\r\n}\r\nint\r\nmain(int argc, char *argv[])\r\n{\r\nconst char ftrace[] = "/ftrace.o";\r\nint ftrace_size = sizeof(ftrace) - 1;\r\nint n_error = 0;\r\nint c;\r\nint i;\r\nwhile ((c = getopt(argc, argv, "w")) >= 0) {\r\nswitch (c) {\r\ncase 'w':\r\nwarn_on_notrace_sect = 1;\r\nbreak;\r\ndefault:\r\nfprintf(stderr, "usage: recordmcount [-w] file.o...\n");\r\nreturn 0;\r\n}\r\n}\r\nif ((argc - optind) < 1) {\r\nfprintf(stderr, "usage: recordmcount [-w] file.o...\n");\r\nreturn 0;\r\n}\r\nfor (i = optind; i < argc; i++) {\r\nchar *file = argv[i];\r\nint const sjval = setjmp(jmpenv);\r\nint len;\r\nlen = strlen(file);\r\nif (len >= ftrace_size &&\r\nstrcmp(file + (len - ftrace_size), ftrace) == 0)\r\ncontinue;\r\nswitch (sjval) {\r\ndefault:\r\nfprintf(stderr, "internal error: %s\n", file);\r\nexit(1);\r\nbreak;\r\ncase SJ_SETJMP:\r\nfd_map = -1;\r\nehdr_curr = NULL;\r\nmmap_failed = 1;\r\ndo_file(file);\r\nbreak;\r\ncase SJ_FAIL:\r\n++n_error;\r\nbreak;\r\ncase SJ_SUCCEED:\r\nbreak;\r\n}\r\n}\r\nreturn !!n_error;\r\n}
