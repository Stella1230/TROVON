unsigned exofs_max_io_pages(struct ore_layout *layout,\r\nunsigned expected_pages)\r\n{\r\nunsigned pages = min_t(unsigned, expected_pages,\r\nlayout->max_io_length / PAGE_SIZE);\r\nreturn pages;\r\n}\r\nstatic void _pcol_init(struct page_collect *pcol, unsigned expected_pages,\r\nstruct inode *inode)\r\n{\r\nstruct exofs_sb_info *sbi = inode->i_sb->s_fs_info;\r\npcol->sbi = sbi;\r\npcol->inode = inode;\r\npcol->expected_pages = expected_pages;\r\npcol->ios = NULL;\r\npcol->pages = NULL;\r\npcol->alloc_pages = 0;\r\npcol->nr_pages = 0;\r\npcol->length = 0;\r\npcol->pg_first = -1;\r\npcol->read_4_write = false;\r\npcol->that_locked_page = NULL;\r\n}\r\nstatic void _pcol_reset(struct page_collect *pcol)\r\n{\r\npcol->expected_pages -= min(pcol->nr_pages, pcol->expected_pages);\r\npcol->pages = NULL;\r\npcol->alloc_pages = 0;\r\npcol->nr_pages = 0;\r\npcol->length = 0;\r\npcol->pg_first = -1;\r\npcol->ios = NULL;\r\npcol->that_locked_page = NULL;\r\nif (!pcol->expected_pages)\r\npcol->expected_pages =\r\nexofs_max_io_pages(&pcol->sbi->layout, ~0);\r\n}\r\nstatic int pcol_try_alloc(struct page_collect *pcol)\r\n{\r\nunsigned pages;\r\npages = exofs_max_io_pages(&pcol->sbi->layout, pcol->expected_pages);\r\nfor (; pages; pages >>= 1) {\r\npcol->pages = kmalloc(pages * sizeof(struct page *),\r\nGFP_KERNEL);\r\nif (likely(pcol->pages)) {\r\npcol->alloc_pages = pages;\r\nreturn 0;\r\n}\r\n}\r\nEXOFS_ERR("Failed to kmalloc expected_pages=%u\n",\r\npcol->expected_pages);\r\nreturn -ENOMEM;\r\n}\r\nstatic void pcol_free(struct page_collect *pcol)\r\n{\r\nkfree(pcol->pages);\r\npcol->pages = NULL;\r\nif (pcol->ios) {\r\nore_put_io_state(pcol->ios);\r\npcol->ios = NULL;\r\n}\r\n}\r\nstatic int pcol_add_page(struct page_collect *pcol, struct page *page,\r\nunsigned len)\r\n{\r\nif (unlikely(pcol->nr_pages >= pcol->alloc_pages))\r\nreturn -ENOMEM;\r\npcol->pages[pcol->nr_pages++] = page;\r\npcol->length += len;\r\nreturn 0;\r\n}\r\nstatic int update_read_page(struct page *page, int ret)\r\n{\r\nswitch (ret) {\r\ncase 0:\r\nSetPageUptodate(page);\r\nif (PageError(page))\r\nClearPageError(page);\r\nbreak;\r\ncase -EFAULT:\r\nclear_highpage(page);\r\nSetPageUptodate(page);\r\nif (PageError(page))\r\nClearPageError(page);\r\nEXOFS_DBGMSG("recovered read error\n");\r\ncase PAGE_WAS_NOT_IN_IO:\r\nret = 0;\r\nbreak;\r\ndefault:\r\nSetPageError(page);\r\n}\r\nreturn ret;\r\n}\r\nstatic void update_write_page(struct page *page, int ret)\r\n{\r\nif (unlikely(ret == PAGE_WAS_NOT_IN_IO))\r\nreturn;\r\nif (ret) {\r\nmapping_set_error(page->mapping, ret);\r\nSetPageError(page);\r\n}\r\nend_page_writeback(page);\r\n}\r\nstatic int __readpages_done(struct page_collect *pcol)\r\n{\r\nint i;\r\nu64 good_bytes;\r\nu64 length = 0;\r\nint ret = ore_check_io(pcol->ios, NULL);\r\nif (likely(!ret)) {\r\ngood_bytes = pcol->length;\r\nret = PAGE_WAS_NOT_IN_IO;\r\n} else {\r\ngood_bytes = 0;\r\n}\r\nEXOFS_DBGMSG2("readpages_done(0x%lx) good_bytes=0x%llx"\r\n" length=0x%lx nr_pages=%u\n",\r\npcol->inode->i_ino, _LLU(good_bytes), pcol->length,\r\npcol->nr_pages);\r\nfor (i = 0; i < pcol->nr_pages; i++) {\r\nstruct page *page = pcol->pages[i];\r\nstruct inode *inode = page->mapping->host;\r\nint page_stat;\r\nif (inode != pcol->inode)\r\ncontinue;\r\nif (likely(length < good_bytes))\r\npage_stat = 0;\r\nelse\r\npage_stat = ret;\r\nEXOFS_DBGMSG2(" readpages_done(0x%lx, 0x%lx) %s\n",\r\ninode->i_ino, page->index,\r\npage_stat ? "bad_bytes" : "good_bytes");\r\nret = update_read_page(page, page_stat);\r\nif (!pcol->read_4_write)\r\nunlock_page(page);\r\nlength += PAGE_SIZE;\r\n}\r\npcol_free(pcol);\r\nEXOFS_DBGMSG2("readpages_done END\n");\r\nreturn ret;\r\n}\r\nstatic void readpages_done(struct ore_io_state *ios, void *p)\r\n{\r\nstruct page_collect *pcol = p;\r\n__readpages_done(pcol);\r\natomic_dec(&pcol->sbi->s_curr_pending);\r\nkfree(pcol);\r\n}\r\nstatic void _unlock_pcol_pages(struct page_collect *pcol, int ret, int rw)\r\n{\r\nint i;\r\nfor (i = 0; i < pcol->nr_pages; i++) {\r\nstruct page *page = pcol->pages[i];\r\nif (rw == READ)\r\nupdate_read_page(page, ret);\r\nelse\r\nupdate_write_page(page, ret);\r\nunlock_page(page);\r\n}\r\n}\r\nstatic int _maybe_not_all_in_one_io(struct ore_io_state *ios,\r\nstruct page_collect *pcol_src, struct page_collect *pcol)\r\n{\r\nBUG_ON(pcol_src->nr_pages < ios->nr_pages);\r\nif (pcol_src->nr_pages > ios->nr_pages) {\r\nstruct page **src_page;\r\nunsigned pages_less = pcol_src->nr_pages - ios->nr_pages;\r\nunsigned long len_less = pcol_src->length - ios->length;\r\nunsigned i;\r\nint ret;\r\npcol_src->nr_pages = ios->nr_pages;\r\npcol_src->length = ios->length;\r\npcol->expected_pages += pages_less;\r\npcol->nr_pages = pages_less;\r\npcol->length = len_less;\r\nsrc_page = pcol_src->pages + pcol_src->nr_pages;\r\npcol->pg_first = (*src_page)->index;\r\nret = pcol_try_alloc(pcol);\r\nif (unlikely(ret))\r\nreturn ret;\r\nfor (i = 0; i < pages_less; ++i)\r\npcol->pages[i] = *src_page++;\r\nEXOFS_DBGMSG("Length was adjusted nr_pages=0x%x "\r\n"pages_less=0x%x expected_pages=0x%x "\r\n"next_offset=0x%llx next_len=0x%lx\n",\r\npcol_src->nr_pages, pages_less, pcol->expected_pages,\r\npcol->pg_first * PAGE_SIZE, pcol->length);\r\n}\r\nreturn 0;\r\n}\r\nstatic int read_exec(struct page_collect *pcol)\r\n{\r\nstruct exofs_i_info *oi = exofs_i(pcol->inode);\r\nstruct ore_io_state *ios;\r\nstruct page_collect *pcol_copy = NULL;\r\nint ret;\r\nif (!pcol->pages)\r\nreturn 0;\r\nif (!pcol->ios) {\r\nint ret = ore_get_rw_state(&pcol->sbi->layout, &oi->oc, true,\r\npcol->pg_first << PAGE_CACHE_SHIFT,\r\npcol->length, &pcol->ios);\r\nif (ret)\r\nreturn ret;\r\n}\r\nios = pcol->ios;\r\nios->pages = pcol->pages;\r\nif (pcol->read_4_write) {\r\nore_read(pcol->ios);\r\nreturn __readpages_done(pcol);\r\n}\r\npcol_copy = kmalloc(sizeof(*pcol_copy), GFP_KERNEL);\r\nif (!pcol_copy) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\n*pcol_copy = *pcol;\r\nios->done = readpages_done;\r\nios->private = pcol_copy;\r\n_pcol_reset(pcol);\r\nret = _maybe_not_all_in_one_io(ios, pcol_copy, pcol);\r\nif (unlikely(ret))\r\ngoto err;\r\nEXOFS_DBGMSG2("read_exec(0x%lx) offset=0x%llx length=0x%llx\n",\r\npcol->inode->i_ino, _LLU(ios->offset), _LLU(ios->length));\r\nret = ore_read(ios);\r\nif (unlikely(ret))\r\ngoto err;\r\natomic_inc(&pcol->sbi->s_curr_pending);\r\nreturn 0;\r\nerr:\r\nif (!pcol_copy)\r\npcol_copy = pcol;\r\n_unlock_pcol_pages(pcol_copy, ret, READ);\r\npcol_free(pcol_copy);\r\nkfree(pcol_copy);\r\nreturn ret;\r\n}\r\nstatic int readpage_strip(void *data, struct page *page)\r\n{\r\nstruct page_collect *pcol = data;\r\nstruct inode *inode = pcol->inode;\r\nstruct exofs_i_info *oi = exofs_i(inode);\r\nloff_t i_size = i_size_read(inode);\r\npgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\r\nsize_t len;\r\nint ret;\r\nBUG_ON(!PageLocked(page));\r\nif (PageUptodate(page))\r\nEXOFS_ERR("PageUptodate(0x%lx, 0x%lx)\n", pcol->inode->i_ino,\r\npage->index);\r\npcol->that_locked_page = page;\r\nif (page->index < end_index)\r\nlen = PAGE_CACHE_SIZE;\r\nelse if (page->index == end_index)\r\nlen = i_size & ~PAGE_CACHE_MASK;\r\nelse\r\nlen = 0;\r\nif (!len || !obj_created(oi)) {\r\nclear_highpage(page);\r\nSetPageUptodate(page);\r\nif (PageError(page))\r\nClearPageError(page);\r\nif (!pcol->read_4_write)\r\nunlock_page(page);\r\nEXOFS_DBGMSG("readpage_strip(0x%lx) empty page len=%zx "\r\n"read_4_write=%d index=0x%lx end_index=0x%lx "\r\n"splitting\n", inode->i_ino, len,\r\npcol->read_4_write, page->index, end_index);\r\nreturn read_exec(pcol);\r\n}\r\ntry_again:\r\nif (unlikely(pcol->pg_first == -1)) {\r\npcol->pg_first = page->index;\r\n} else if (unlikely((pcol->pg_first + pcol->nr_pages) !=\r\npage->index)) {\r\nret = read_exec(pcol);\r\nif (unlikely(ret))\r\ngoto fail;\r\ngoto try_again;\r\n}\r\nif (!pcol->pages) {\r\nret = pcol_try_alloc(pcol);\r\nif (unlikely(ret))\r\ngoto fail;\r\n}\r\nif (len != PAGE_CACHE_SIZE)\r\nzero_user(page, len, PAGE_CACHE_SIZE - len);\r\nEXOFS_DBGMSG2(" readpage_strip(0x%lx, 0x%lx) len=0x%zx\n",\r\ninode->i_ino, page->index, len);\r\nret = pcol_add_page(pcol, page, len);\r\nif (ret) {\r\nEXOFS_DBGMSG2("Failed pcol_add_page pages[i]=%p "\r\n"this_len=0x%zx nr_pages=%u length=0x%lx\n",\r\npage, len, pcol->nr_pages, pcol->length);\r\nret = read_exec(pcol);\r\nif (unlikely(ret))\r\ngoto fail;\r\ngoto try_again;\r\n}\r\nreturn 0;\r\nfail:\r\nunlock_page(page);\r\nreturn ret;\r\n}\r\nstatic int exofs_readpages(struct file *file, struct address_space *mapping,\r\nstruct list_head *pages, unsigned nr_pages)\r\n{\r\nstruct page_collect pcol;\r\nint ret;\r\n_pcol_init(&pcol, nr_pages, mapping->host);\r\nret = read_cache_pages(mapping, pages, readpage_strip, &pcol);\r\nif (ret) {\r\nEXOFS_ERR("read_cache_pages => %d\n", ret);\r\nreturn ret;\r\n}\r\nret = read_exec(&pcol);\r\nif (unlikely(ret))\r\nreturn ret;\r\nreturn read_exec(&pcol);\r\n}\r\nstatic int _readpage(struct page *page, bool read_4_write)\r\n{\r\nstruct page_collect pcol;\r\nint ret;\r\n_pcol_init(&pcol, 1, page->mapping->host);\r\npcol.read_4_write = read_4_write;\r\nret = readpage_strip(&pcol, page);\r\nif (ret) {\r\nEXOFS_ERR("_readpage => %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn read_exec(&pcol);\r\n}\r\nstatic int exofs_readpage(struct file *file, struct page *page)\r\n{\r\nreturn _readpage(page, false);\r\n}\r\nstatic void writepages_done(struct ore_io_state *ios, void *p)\r\n{\r\nstruct page_collect *pcol = p;\r\nint i;\r\nu64 good_bytes;\r\nu64 length = 0;\r\nint ret = ore_check_io(ios, NULL);\r\natomic_dec(&pcol->sbi->s_curr_pending);\r\nif (likely(!ret)) {\r\ngood_bytes = pcol->length;\r\nret = PAGE_WAS_NOT_IN_IO;\r\n} else {\r\ngood_bytes = 0;\r\n}\r\nEXOFS_DBGMSG2("writepages_done(0x%lx) good_bytes=0x%llx"\r\n" length=0x%lx nr_pages=%u\n",\r\npcol->inode->i_ino, _LLU(good_bytes), pcol->length,\r\npcol->nr_pages);\r\nfor (i = 0; i < pcol->nr_pages; i++) {\r\nstruct page *page = pcol->pages[i];\r\nstruct inode *inode = page->mapping->host;\r\nint page_stat;\r\nif (inode != pcol->inode)\r\ncontinue;\r\nif (likely(length < good_bytes))\r\npage_stat = 0;\r\nelse\r\npage_stat = ret;\r\nupdate_write_page(page, page_stat);\r\nunlock_page(page);\r\nEXOFS_DBGMSG2(" writepages_done(0x%lx, 0x%lx) status=%d\n",\r\ninode->i_ino, page->index, page_stat);\r\nlength += PAGE_SIZE;\r\n}\r\npcol_free(pcol);\r\nkfree(pcol);\r\nEXOFS_DBGMSG2("writepages_done END\n");\r\n}\r\nstatic struct page *__r4w_get_page(void *priv, u64 offset, bool *uptodate)\r\n{\r\nstruct page_collect *pcol = priv;\r\npgoff_t index = offset / PAGE_SIZE;\r\nif (!pcol->that_locked_page ||\r\n(pcol->that_locked_page->index != index)) {\r\nstruct page *page;\r\nloff_t i_size = i_size_read(pcol->inode);\r\nif (offset >= i_size) {\r\n*uptodate = true;\r\nEXOFS_DBGMSG2("offset >= i_size index=0x%lx\n", index);\r\nreturn ZERO_PAGE(0);\r\n}\r\npage = find_get_page(pcol->inode->i_mapping, index);\r\nif (!page) {\r\npage = find_or_create_page(pcol->inode->i_mapping,\r\nindex, GFP_NOFS);\r\nif (unlikely(!page)) {\r\nEXOFS_DBGMSG("grab_cache_page Failed "\r\n"index=0x%llx\n", _LLU(index));\r\nreturn NULL;\r\n}\r\nunlock_page(page);\r\n}\r\nif (PageDirty(page) || PageWriteback(page))\r\n*uptodate = true;\r\nelse\r\n*uptodate = PageUptodate(page);\r\nEXOFS_DBGMSG2("index=0x%lx uptodate=%d\n", index, *uptodate);\r\nreturn page;\r\n} else {\r\nEXOFS_DBGMSG2("YES that_locked_page index=0x%lx\n",\r\npcol->that_locked_page->index);\r\n*uptodate = true;\r\nreturn pcol->that_locked_page;\r\n}\r\n}\r\nstatic void __r4w_put_page(void *priv, struct page *page)\r\n{\r\nstruct page_collect *pcol = priv;\r\nif ((pcol->that_locked_page != page) && (ZERO_PAGE(0) != page)) {\r\nEXOFS_DBGMSG2("index=0x%lx\n", page->index);\r\npage_cache_release(page);\r\nreturn;\r\n}\r\nEXOFS_DBGMSG2("that_locked_page index=0x%lx\n",\r\nZERO_PAGE(0) == page ? -1 : page->index);\r\n}\r\nstatic int write_exec(struct page_collect *pcol)\r\n{\r\nstruct exofs_i_info *oi = exofs_i(pcol->inode);\r\nstruct ore_io_state *ios;\r\nstruct page_collect *pcol_copy = NULL;\r\nint ret;\r\nif (!pcol->pages)\r\nreturn 0;\r\nBUG_ON(pcol->ios);\r\nret = ore_get_rw_state(&pcol->sbi->layout, &oi->oc, false,\r\npcol->pg_first << PAGE_CACHE_SHIFT,\r\npcol->length, &pcol->ios);\r\nif (unlikely(ret))\r\ngoto err;\r\npcol_copy = kmalloc(sizeof(*pcol_copy), GFP_KERNEL);\r\nif (!pcol_copy) {\r\nEXOFS_ERR("write_exec: Failed to kmalloc(pcol)\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\n*pcol_copy = *pcol;\r\nios = pcol->ios;\r\nios->pages = pcol_copy->pages;\r\nios->done = writepages_done;\r\nios->r4w = &_r4w_op;\r\nios->private = pcol_copy;\r\n_pcol_reset(pcol);\r\nret = _maybe_not_all_in_one_io(ios, pcol_copy, pcol);\r\nif (unlikely(ret))\r\ngoto err;\r\nEXOFS_DBGMSG2("write_exec(0x%lx) offset=0x%llx length=0x%llx\n",\r\npcol->inode->i_ino, _LLU(ios->offset), _LLU(ios->length));\r\nret = ore_write(ios);\r\nif (unlikely(ret)) {\r\nEXOFS_ERR("write_exec: ore_write() Failed\n");\r\ngoto err;\r\n}\r\natomic_inc(&pcol->sbi->s_curr_pending);\r\nreturn 0;\r\nerr:\r\nif (!pcol_copy)\r\npcol_copy = pcol;\r\n_unlock_pcol_pages(pcol_copy, ret, WRITE);\r\npcol_free(pcol_copy);\r\nkfree(pcol_copy);\r\nreturn ret;\r\n}\r\nstatic int writepage_strip(struct page *page,\r\nstruct writeback_control *wbc_unused, void *data)\r\n{\r\nstruct page_collect *pcol = data;\r\nstruct inode *inode = pcol->inode;\r\nstruct exofs_i_info *oi = exofs_i(inode);\r\nloff_t i_size = i_size_read(inode);\r\npgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\r\nsize_t len;\r\nint ret;\r\nBUG_ON(!PageLocked(page));\r\nret = wait_obj_created(oi);\r\nif (unlikely(ret))\r\ngoto fail;\r\nif (page->index < end_index)\r\nlen = PAGE_CACHE_SIZE;\r\nelse {\r\nlen = i_size & ~PAGE_CACHE_MASK;\r\nif (page->index > end_index || !len) {\r\nret = write_exec(pcol);\r\nif (unlikely(ret))\r\ngoto fail;\r\nif (PageError(page))\r\nClearPageError(page);\r\nunlock_page(page);\r\nEXOFS_DBGMSG("writepage_strip(0x%lx, 0x%lx) "\r\n"outside the limits\n",\r\ninode->i_ino, page->index);\r\nreturn 0;\r\n}\r\n}\r\ntry_again:\r\nif (unlikely(pcol->pg_first == -1)) {\r\npcol->pg_first = page->index;\r\n} else if (unlikely((pcol->pg_first + pcol->nr_pages) !=\r\npage->index)) {\r\nret = write_exec(pcol);\r\nif (unlikely(ret))\r\ngoto fail;\r\nEXOFS_DBGMSG("writepage_strip(0x%lx, 0x%lx) Discontinuity\n",\r\ninode->i_ino, page->index);\r\ngoto try_again;\r\n}\r\nif (!pcol->pages) {\r\nret = pcol_try_alloc(pcol);\r\nif (unlikely(ret))\r\ngoto fail;\r\n}\r\nEXOFS_DBGMSG2(" writepage_strip(0x%lx, 0x%lx) len=0x%zx\n",\r\ninode->i_ino, page->index, len);\r\nret = pcol_add_page(pcol, page, len);\r\nif (unlikely(ret)) {\r\nEXOFS_DBGMSG2("Failed pcol_add_page "\r\n"nr_pages=%u total_length=0x%lx\n",\r\npcol->nr_pages, pcol->length);\r\nret = write_exec(pcol);\r\nif (unlikely(ret)) {\r\nEXOFS_DBGMSG("write_exec failed => %d", ret);\r\ngoto fail;\r\n}\r\ngoto try_again;\r\n}\r\nBUG_ON(PageWriteback(page));\r\nset_page_writeback(page);\r\nreturn 0;\r\nfail:\r\nEXOFS_DBGMSG("Error: writepage_strip(0x%lx, 0x%lx)=>%d\n",\r\ninode->i_ino, page->index, ret);\r\nset_bit(AS_EIO, &page->mapping->flags);\r\nunlock_page(page);\r\nreturn ret;\r\n}\r\nstatic int exofs_writepages(struct address_space *mapping,\r\nstruct writeback_control *wbc)\r\n{\r\nstruct page_collect pcol;\r\nlong start, end, expected_pages;\r\nint ret;\r\nstart = wbc->range_start >> PAGE_CACHE_SHIFT;\r\nend = (wbc->range_end == LLONG_MAX) ?\r\nstart + mapping->nrpages :\r\nwbc->range_end >> PAGE_CACHE_SHIFT;\r\nif (start || end)\r\nexpected_pages = end - start + 1;\r\nelse\r\nexpected_pages = mapping->nrpages;\r\nif (expected_pages < 32L)\r\nexpected_pages = 32L;\r\nEXOFS_DBGMSG2("inode(0x%lx) wbc->start=0x%llx wbc->end=0x%llx "\r\n"nrpages=%lu start=0x%lx end=0x%lx expected_pages=%ld\n",\r\nmapping->host->i_ino, wbc->range_start, wbc->range_end,\r\nmapping->nrpages, start, end, expected_pages);\r\n_pcol_init(&pcol, expected_pages, mapping->host);\r\nret = write_cache_pages(mapping, wbc, writepage_strip, &pcol);\r\nif (unlikely(ret)) {\r\nEXOFS_ERR("write_cache_pages => %d\n", ret);\r\nreturn ret;\r\n}\r\nret = write_exec(&pcol);\r\nif (unlikely(ret))\r\nreturn ret;\r\nif (wbc->sync_mode == WB_SYNC_ALL) {\r\nreturn write_exec(&pcol);\r\n} else if (pcol.nr_pages) {\r\nunsigned i;\r\nfor (i = 0; i < pcol.nr_pages; i++) {\r\nstruct page *page = pcol.pages[i];\r\nend_page_writeback(page);\r\nset_page_dirty(page);\r\nunlock_page(page);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void _write_failed(struct inode *inode, loff_t to)\r\n{\r\nif (to > inode->i_size)\r\ntruncate_pagecache(inode, inode->i_size);\r\n}\r\nint exofs_write_begin(struct file *file, struct address_space *mapping,\r\nloff_t pos, unsigned len, unsigned flags,\r\nstruct page **pagep, void **fsdata)\r\n{\r\nint ret = 0;\r\nstruct page *page;\r\npage = *pagep;\r\nif (page == NULL) {\r\nret = simple_write_begin(file, mapping, pos, len, flags, pagep,\r\nfsdata);\r\nif (ret) {\r\nEXOFS_DBGMSG("simple_write_begin failed\n");\r\ngoto out;\r\n}\r\npage = *pagep;\r\n}\r\nif (!PageUptodate(page) && (len != PAGE_CACHE_SIZE)) {\r\nloff_t i_size = i_size_read(mapping->host);\r\npgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\r\nsize_t rlen;\r\nif (page->index < end_index)\r\nrlen = PAGE_CACHE_SIZE;\r\nelse if (page->index == end_index)\r\nrlen = i_size & ~PAGE_CACHE_MASK;\r\nelse\r\nrlen = 0;\r\nif (!rlen) {\r\nclear_highpage(page);\r\nSetPageUptodate(page);\r\ngoto out;\r\n}\r\nret = _readpage(page, true);\r\nif (ret) {\r\nunlock_page(page);\r\nEXOFS_DBGMSG("__readpage failed\n");\r\n}\r\n}\r\nout:\r\nif (unlikely(ret))\r\n_write_failed(mapping->host, pos + len);\r\nreturn ret;\r\n}\r\nstatic int exofs_write_begin_export(struct file *file,\r\nstruct address_space *mapping,\r\nloff_t pos, unsigned len, unsigned flags,\r\nstruct page **pagep, void **fsdata)\r\n{\r\n*pagep = NULL;\r\nreturn exofs_write_begin(file, mapping, pos, len, flags, pagep,\r\nfsdata);\r\n}\r\nstatic int exofs_write_end(struct file *file, struct address_space *mapping,\r\nloff_t pos, unsigned len, unsigned copied,\r\nstruct page *page, void *fsdata)\r\n{\r\nstruct inode *inode = mapping->host;\r\nloff_t i_size = inode->i_size;\r\nint ret;\r\nret = simple_write_end(file, mapping,pos, len, copied, page, fsdata);\r\nif (unlikely(ret))\r\n_write_failed(inode, pos + len);\r\nif (i_size != inode->i_size)\r\nmark_inode_dirty(inode);\r\nreturn ret;\r\n}\r\nstatic int exofs_releasepage(struct page *page, gfp_t gfp)\r\n{\r\nEXOFS_DBGMSG("page 0x%lx\n", page->index);\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\nstatic void exofs_invalidatepage(struct page *page, unsigned int offset,\r\nunsigned int length)\r\n{\r\nEXOFS_DBGMSG("page 0x%lx offset 0x%x length 0x%x\n",\r\npage->index, offset, length);\r\nWARN_ON(1);\r\n}\r\nstatic ssize_t exofs_direct_IO(int rw, struct kiocb *iocb,\r\nstruct iov_iter *iter, loff_t offset)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int exofs_inode_is_fast_symlink(struct inode *inode)\r\n{\r\nstruct exofs_i_info *oi = exofs_i(inode);\r\nreturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\r\n}\r\nstatic int _do_truncate(struct inode *inode, loff_t newsize)\r\n{\r\nstruct exofs_i_info *oi = exofs_i(inode);\r\nstruct exofs_sb_info *sbi = inode->i_sb->s_fs_info;\r\nint ret;\r\ninode->i_mtime = inode->i_ctime = CURRENT_TIME;\r\nret = ore_truncate(&sbi->layout, &oi->oc, (u64)newsize);\r\nif (likely(!ret))\r\ntruncate_setsize(inode, newsize);\r\nEXOFS_DBGMSG2("(0x%lx) size=0x%llx ret=>%d\n",\r\ninode->i_ino, newsize, ret);\r\nreturn ret;\r\n}\r\nint exofs_setattr(struct dentry *dentry, struct iattr *iattr)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nint error;\r\nerror = wait_obj_created(exofs_i(inode));\r\nif (unlikely(error))\r\nreturn error;\r\nerror = inode_change_ok(inode, iattr);\r\nif (unlikely(error))\r\nreturn error;\r\nif ((iattr->ia_valid & ATTR_SIZE) &&\r\niattr->ia_size != i_size_read(inode)) {\r\nerror = _do_truncate(inode, iattr->ia_size);\r\nif (unlikely(error))\r\nreturn error;\r\n}\r\nsetattr_copy(inode, iattr);\r\nmark_inode_dirty(inode);\r\nreturn 0;\r\n}\r\nstatic int exofs_get_inode(struct super_block *sb, struct exofs_i_info *oi,\r\nstruct exofs_fcb *inode)\r\n{\r\nstruct exofs_sb_info *sbi = sb->s_fs_info;\r\nstruct osd_attr attrs[] = {\r\n[0] = g_attr_inode_data,\r\n[1] = g_attr_inode_file_layout,\r\n[2] = g_attr_inode_dir_layout,\r\n};\r\nstruct ore_io_state *ios;\r\nstruct exofs_on_disk_inode_layout *layout;\r\nint ret;\r\nret = ore_get_io_state(&sbi->layout, &oi->oc, &ios);\r\nif (unlikely(ret)) {\r\nEXOFS_ERR("%s: ore_get_io_state failed.\n", __func__);\r\nreturn ret;\r\n}\r\nattrs[1].len = exofs_on_disk_inode_layout_size(sbi->oc.numdevs);\r\nattrs[2].len = exofs_on_disk_inode_layout_size(sbi->oc.numdevs);\r\nios->in_attr = attrs;\r\nios->in_attr_len = ARRAY_SIZE(attrs);\r\nret = ore_read(ios);\r\nif (unlikely(ret)) {\r\nEXOFS_ERR("object(0x%llx) corrupted, return empty file=>%d\n",\r\n_LLU(oi->one_comp.obj.id), ret);\r\nmemset(inode, 0, sizeof(*inode));\r\ninode->i_mode = 0040000 | (0777 & ~022);\r\nret = 0;\r\ngoto out;\r\n}\r\nret = extract_attr_from_ios(ios, &attrs[0]);\r\nif (ret) {\r\nEXOFS_ERR("%s: extract_attr 0 of inode failed\n", __func__);\r\ngoto out;\r\n}\r\nWARN_ON(attrs[0].len != EXOFS_INO_ATTR_SIZE);\r\nmemcpy(inode, attrs[0].val_ptr, EXOFS_INO_ATTR_SIZE);\r\nret = extract_attr_from_ios(ios, &attrs[1]);\r\nif (ret) {\r\nEXOFS_ERR("%s: extract_attr 1 of inode failed\n", __func__);\r\ngoto out;\r\n}\r\nif (attrs[1].len) {\r\nlayout = attrs[1].val_ptr;\r\nif (layout->gen_func != cpu_to_le16(LAYOUT_MOVING_WINDOW)) {\r\nEXOFS_ERR("%s: unsupported files layout %d\n",\r\n__func__, layout->gen_func);\r\nret = -ENOTSUPP;\r\ngoto out;\r\n}\r\n}\r\nret = extract_attr_from_ios(ios, &attrs[2]);\r\nif (ret) {\r\nEXOFS_ERR("%s: extract_attr 2 of inode failed\n", __func__);\r\ngoto out;\r\n}\r\nif (attrs[2].len) {\r\nlayout = attrs[2].val_ptr;\r\nif (layout->gen_func != cpu_to_le16(LAYOUT_MOVING_WINDOW)) {\r\nEXOFS_ERR("%s: unsupported meta-data layout %d\n",\r\n__func__, layout->gen_func);\r\nret = -ENOTSUPP;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nore_put_io_state(ios);\r\nreturn ret;\r\n}\r\nstatic void __oi_init(struct exofs_i_info *oi)\r\n{\r\ninit_waitqueue_head(&oi->i_wq);\r\noi->i_flags = 0;\r\n}\r\nstruct inode *exofs_iget(struct super_block *sb, unsigned long ino)\r\n{\r\nstruct exofs_i_info *oi;\r\nstruct exofs_fcb fcb;\r\nstruct inode *inode;\r\nint ret;\r\ninode = iget_locked(sb, ino);\r\nif (!inode)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (!(inode->i_state & I_NEW))\r\nreturn inode;\r\noi = exofs_i(inode);\r\n__oi_init(oi);\r\nexofs_init_comps(&oi->oc, &oi->one_comp, sb->s_fs_info,\r\nexofs_oi_objno(oi));\r\nret = exofs_get_inode(sb, oi, &fcb);\r\nif (ret)\r\ngoto bad_inode;\r\nset_obj_created(oi);\r\ninode->i_mode = le16_to_cpu(fcb.i_mode);\r\ni_uid_write(inode, le32_to_cpu(fcb.i_uid));\r\ni_gid_write(inode, le32_to_cpu(fcb.i_gid));\r\nset_nlink(inode, le16_to_cpu(fcb.i_links_count));\r\ninode->i_ctime.tv_sec = (signed)le32_to_cpu(fcb.i_ctime);\r\ninode->i_atime.tv_sec = (signed)le32_to_cpu(fcb.i_atime);\r\ninode->i_mtime.tv_sec = (signed)le32_to_cpu(fcb.i_mtime);\r\ninode->i_ctime.tv_nsec =\r\ninode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = 0;\r\noi->i_commit_size = le64_to_cpu(fcb.i_size);\r\ni_size_write(inode, oi->i_commit_size);\r\ninode->i_blkbits = EXOFS_BLKSHIFT;\r\ninode->i_generation = le32_to_cpu(fcb.i_generation);\r\noi->i_dir_start_lookup = 0;\r\nif ((inode->i_nlink == 0) && (inode->i_mode == 0)) {\r\nret = -ESTALE;\r\ngoto bad_inode;\r\n}\r\nif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\r\nif (fcb.i_data[0])\r\ninode->i_rdev =\r\nold_decode_dev(le32_to_cpu(fcb.i_data[0]));\r\nelse\r\ninode->i_rdev =\r\nnew_decode_dev(le32_to_cpu(fcb.i_data[1]));\r\n} else {\r\nmemcpy(oi->i_data, fcb.i_data, sizeof(fcb.i_data));\r\n}\r\ninode->i_mapping->backing_dev_info = sb->s_bdi;\r\nif (S_ISREG(inode->i_mode)) {\r\ninode->i_op = &exofs_file_inode_operations;\r\ninode->i_fop = &exofs_file_operations;\r\ninode->i_mapping->a_ops = &exofs_aops;\r\n} else if (S_ISDIR(inode->i_mode)) {\r\ninode->i_op = &exofs_dir_inode_operations;\r\ninode->i_fop = &exofs_dir_operations;\r\ninode->i_mapping->a_ops = &exofs_aops;\r\n} else if (S_ISLNK(inode->i_mode)) {\r\nif (exofs_inode_is_fast_symlink(inode))\r\ninode->i_op = &exofs_fast_symlink_inode_operations;\r\nelse {\r\ninode->i_op = &exofs_symlink_inode_operations;\r\ninode->i_mapping->a_ops = &exofs_aops;\r\n}\r\n} else {\r\ninode->i_op = &exofs_special_inode_operations;\r\nif (fcb.i_data[0])\r\ninit_special_inode(inode, inode->i_mode,\r\nold_decode_dev(le32_to_cpu(fcb.i_data[0])));\r\nelse\r\ninit_special_inode(inode, inode->i_mode,\r\nnew_decode_dev(le32_to_cpu(fcb.i_data[1])));\r\n}\r\nunlock_new_inode(inode);\r\nreturn inode;\r\nbad_inode:\r\niget_failed(inode);\r\nreturn ERR_PTR(ret);\r\n}\r\nint __exofs_wait_obj_created(struct exofs_i_info *oi)\r\n{\r\nif (!obj_created(oi)) {\r\nEXOFS_DBGMSG("!obj_created\n");\r\nBUG_ON(!obj_2bcreated(oi));\r\nwait_event(oi->i_wq, obj_created(oi));\r\nEXOFS_DBGMSG("wait_event done\n");\r\n}\r\nreturn unlikely(is_bad_inode(&oi->vfs_inode)) ? -EIO : 0;\r\n}\r\nstatic void create_done(struct ore_io_state *ios, void *p)\r\n{\r\nstruct inode *inode = p;\r\nstruct exofs_i_info *oi = exofs_i(inode);\r\nstruct exofs_sb_info *sbi = inode->i_sb->s_fs_info;\r\nint ret;\r\nret = ore_check_io(ios, NULL);\r\nore_put_io_state(ios);\r\natomic_dec(&sbi->s_curr_pending);\r\nif (unlikely(ret)) {\r\nEXOFS_ERR("object=0x%llx creation failed in pid=0x%llx",\r\n_LLU(exofs_oi_objno(oi)),\r\n_LLU(oi->one_comp.obj.partition));\r\n}\r\nset_obj_created(oi);\r\nwake_up(&oi->i_wq);\r\n}\r\nstruct inode *exofs_new_inode(struct inode *dir, umode_t mode)\r\n{\r\nstruct super_block *sb = dir->i_sb;\r\nstruct exofs_sb_info *sbi = sb->s_fs_info;\r\nstruct inode *inode;\r\nstruct exofs_i_info *oi;\r\nstruct ore_io_state *ios;\r\nint ret;\r\ninode = new_inode(sb);\r\nif (!inode)\r\nreturn ERR_PTR(-ENOMEM);\r\noi = exofs_i(inode);\r\n__oi_init(oi);\r\nset_obj_2bcreated(oi);\r\ninode->i_mapping->backing_dev_info = sb->s_bdi;\r\ninode_init_owner(inode, dir, mode);\r\ninode->i_ino = sbi->s_nextid++;\r\ninode->i_blkbits = EXOFS_BLKSHIFT;\r\ninode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\r\noi->i_commit_size = inode->i_size = 0;\r\nspin_lock(&sbi->s_next_gen_lock);\r\ninode->i_generation = sbi->s_next_generation++;\r\nspin_unlock(&sbi->s_next_gen_lock);\r\ninsert_inode_hash(inode);\r\nexofs_init_comps(&oi->oc, &oi->one_comp, sb->s_fs_info,\r\nexofs_oi_objno(oi));\r\nexofs_sbi_write_stats(sbi);\r\nmark_inode_dirty(inode);\r\nret = ore_get_io_state(&sbi->layout, &oi->oc, &ios);\r\nif (unlikely(ret)) {\r\nEXOFS_ERR("exofs_new_inode: ore_get_io_state failed\n");\r\nreturn ERR_PTR(ret);\r\n}\r\nios->done = create_done;\r\nios->private = inode;\r\nret = ore_create(ios);\r\nif (ret) {\r\nore_put_io_state(ios);\r\nreturn ERR_PTR(ret);\r\n}\r\natomic_inc(&sbi->s_curr_pending);\r\nreturn inode;\r\n}\r\nstatic void updatei_done(struct ore_io_state *ios, void *p)\r\n{\r\nstruct updatei_args *args = p;\r\nore_put_io_state(ios);\r\natomic_dec(&args->sbi->s_curr_pending);\r\nkfree(args);\r\n}\r\nstatic int exofs_update_inode(struct inode *inode, int do_sync)\r\n{\r\nstruct exofs_i_info *oi = exofs_i(inode);\r\nstruct super_block *sb = inode->i_sb;\r\nstruct exofs_sb_info *sbi = sb->s_fs_info;\r\nstruct ore_io_state *ios;\r\nstruct osd_attr attr;\r\nstruct exofs_fcb *fcb;\r\nstruct updatei_args *args;\r\nint ret;\r\nargs = kzalloc(sizeof(*args), GFP_KERNEL);\r\nif (!args) {\r\nEXOFS_DBGMSG("Failed kzalloc of args\n");\r\nreturn -ENOMEM;\r\n}\r\nfcb = &args->fcb;\r\nfcb->i_mode = cpu_to_le16(inode->i_mode);\r\nfcb->i_uid = cpu_to_le32(i_uid_read(inode));\r\nfcb->i_gid = cpu_to_le32(i_gid_read(inode));\r\nfcb->i_links_count = cpu_to_le16(inode->i_nlink);\r\nfcb->i_ctime = cpu_to_le32(inode->i_ctime.tv_sec);\r\nfcb->i_atime = cpu_to_le32(inode->i_atime.tv_sec);\r\nfcb->i_mtime = cpu_to_le32(inode->i_mtime.tv_sec);\r\noi->i_commit_size = i_size_read(inode);\r\nfcb->i_size = cpu_to_le64(oi->i_commit_size);\r\nfcb->i_generation = cpu_to_le32(inode->i_generation);\r\nif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\r\nif (old_valid_dev(inode->i_rdev)) {\r\nfcb->i_data[0] =\r\ncpu_to_le32(old_encode_dev(inode->i_rdev));\r\nfcb->i_data[1] = 0;\r\n} else {\r\nfcb->i_data[0] = 0;\r\nfcb->i_data[1] =\r\ncpu_to_le32(new_encode_dev(inode->i_rdev));\r\nfcb->i_data[2] = 0;\r\n}\r\n} else\r\nmemcpy(fcb->i_data, oi->i_data, sizeof(fcb->i_data));\r\nret = ore_get_io_state(&sbi->layout, &oi->oc, &ios);\r\nif (unlikely(ret)) {\r\nEXOFS_ERR("%s: ore_get_io_state failed.\n", __func__);\r\ngoto free_args;\r\n}\r\nattr = g_attr_inode_data;\r\nattr.val_ptr = fcb;\r\nios->out_attr_len = 1;\r\nios->out_attr = &attr;\r\nwait_obj_created(oi);\r\nif (!do_sync) {\r\nargs->sbi = sbi;\r\nios->done = updatei_done;\r\nios->private = args;\r\n}\r\nret = ore_write(ios);\r\nif (!do_sync && !ret) {\r\natomic_inc(&sbi->s_curr_pending);\r\ngoto out;\r\n}\r\nore_put_io_state(ios);\r\nfree_args:\r\nkfree(args);\r\nout:\r\nEXOFS_DBGMSG("(0x%lx) do_sync=%d ret=>%d\n",\r\ninode->i_ino, do_sync, ret);\r\nreturn ret;\r\n}\r\nint exofs_write_inode(struct inode *inode, struct writeback_control *wbc)\r\n{\r\nreturn exofs_update_inode(inode, 1);\r\n}\r\nstatic void delete_done(struct ore_io_state *ios, void *p)\r\n{\r\nstruct exofs_sb_info *sbi = p;\r\nore_put_io_state(ios);\r\natomic_dec(&sbi->s_curr_pending);\r\n}\r\nvoid exofs_evict_inode(struct inode *inode)\r\n{\r\nstruct exofs_i_info *oi = exofs_i(inode);\r\nstruct super_block *sb = inode->i_sb;\r\nstruct exofs_sb_info *sbi = sb->s_fs_info;\r\nstruct ore_io_state *ios;\r\nint ret;\r\ntruncate_inode_pages_final(&inode->i_data);\r\nif (inode->i_nlink || is_bad_inode(inode))\r\ngoto no_delete;\r\ninode->i_size = 0;\r\nclear_inode(inode);\r\nwait_obj_created(oi);\r\nret = ore_get_io_state(&sbi->layout, &oi->oc, &ios);\r\nif (unlikely(ret)) {\r\nEXOFS_ERR("%s: ore_get_io_state failed\n", __func__);\r\nreturn;\r\n}\r\nios->done = delete_done;\r\nios->private = sbi;\r\nret = ore_remove(ios);\r\nif (ret) {\r\nEXOFS_ERR("%s: ore_remove failed\n", __func__);\r\nore_put_io_state(ios);\r\nreturn;\r\n}\r\natomic_inc(&sbi->s_curr_pending);\r\nreturn;\r\nno_delete:\r\nclear_inode(inode);\r\n}
