static inline struct scatterlist *sg_next_chained(struct scatterlist *sg,\r\nunsigned int *count)\r\n{\r\nreturn sg_next(sg);\r\n}\r\nstatic inline struct scatterlist *sg_next_arr(struct scatterlist *sg,\r\nunsigned int *count)\r\n{\r\nif (--(*count) == 0)\r\nreturn NULL;\r\nreturn sg + 1;\r\n}\r\nint virtqueue_add_sgs(struct virtqueue *_vq,\r\nstruct scatterlist *sgs[],\r\nunsigned int out_sgs,\r\nunsigned int in_sgs,\r\nvoid *data,\r\ngfp_t gfp)\r\n{\r\nunsigned int i, total_out, total_in;\r\nfor (i = total_out = total_in = 0; i < out_sgs; i++) {\r\nstruct scatterlist *sg;\r\nfor (sg = sgs[i]; sg; sg = sg_next(sg))\r\ntotal_out++;\r\n}\r\nfor (; i < out_sgs + in_sgs; i++) {\r\nstruct scatterlist *sg;\r\nfor (sg = sgs[i]; sg; sg = sg_next(sg))\r\ntotal_in++;\r\n}\r\nreturn virtqueue_add(_vq, sgs, sg_next_chained,\r\ntotal_out, total_in, out_sgs, in_sgs, data, gfp);\r\n}\r\nint virtqueue_add_outbuf(struct virtqueue *vq,\r\nstruct scatterlist sg[], unsigned int num,\r\nvoid *data,\r\ngfp_t gfp)\r\n{\r\nreturn virtqueue_add(vq, &sg, sg_next_arr, num, 0, 1, 0, data, gfp);\r\n}\r\nint virtqueue_add_inbuf(struct virtqueue *vq,\r\nstruct scatterlist sg[], unsigned int num,\r\nvoid *data,\r\ngfp_t gfp)\r\n{\r\nreturn virtqueue_add(vq, &sg, sg_next_arr, 0, num, 0, 1, data, gfp);\r\n}\r\nbool virtqueue_kick_prepare(struct virtqueue *_vq)\r\n{\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nu16 new, old;\r\nbool needs_kick;\r\nSTART_USE(vq);\r\nvirtio_mb(vq->weak_barriers);\r\nold = vq->vring.avail->idx - vq->num_added;\r\nnew = vq->vring.avail->idx;\r\nvq->num_added = 0;\r\n#ifdef DEBUG\r\nif (vq->last_add_time_valid) {\r\nWARN_ON(ktime_to_ms(ktime_sub(ktime_get(),\r\nvq->last_add_time)) > 100);\r\n}\r\nvq->last_add_time_valid = false;\r\n#endif\r\nif (vq->event) {\r\nneeds_kick = vring_need_event(vring_avail_event(&vq->vring),\r\nnew, old);\r\n} else {\r\nneeds_kick = !(vq->vring.used->flags & VRING_USED_F_NO_NOTIFY);\r\n}\r\nEND_USE(vq);\r\nreturn needs_kick;\r\n}\r\nbool virtqueue_notify(struct virtqueue *_vq)\r\n{\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nif (unlikely(vq->broken))\r\nreturn false;\r\nif (!vq->notify(_vq)) {\r\nvq->broken = true;\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nbool virtqueue_kick(struct virtqueue *vq)\r\n{\r\nif (virtqueue_kick_prepare(vq))\r\nreturn virtqueue_notify(vq);\r\nreturn true;\r\n}\r\nstatic void detach_buf(struct vring_virtqueue *vq, unsigned int head)\r\n{\r\nunsigned int i;\r\nvq->data[head] = NULL;\r\ni = head;\r\nif (vq->vring.desc[i].flags & VRING_DESC_F_INDIRECT)\r\nkfree(phys_to_virt(vq->vring.desc[i].addr));\r\nwhile (vq->vring.desc[i].flags & VRING_DESC_F_NEXT) {\r\ni = vq->vring.desc[i].next;\r\nvq->vq.num_free++;\r\n}\r\nvq->vring.desc[i].next = vq->free_head;\r\nvq->free_head = head;\r\nvq->vq.num_free++;\r\n}\r\nstatic inline bool more_used(const struct vring_virtqueue *vq)\r\n{\r\nreturn vq->last_used_idx != vq->vring.used->idx;\r\n}\r\nvoid *virtqueue_get_buf(struct virtqueue *_vq, unsigned int *len)\r\n{\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nvoid *ret;\r\nunsigned int i;\r\nu16 last_used;\r\nSTART_USE(vq);\r\nif (unlikely(vq->broken)) {\r\nEND_USE(vq);\r\nreturn NULL;\r\n}\r\nif (!more_used(vq)) {\r\npr_debug("No more buffers in queue\n");\r\nEND_USE(vq);\r\nreturn NULL;\r\n}\r\nvirtio_rmb(vq->weak_barriers);\r\nlast_used = (vq->last_used_idx & (vq->vring.num - 1));\r\ni = vq->vring.used->ring[last_used].id;\r\n*len = vq->vring.used->ring[last_used].len;\r\nif (unlikely(i >= vq->vring.num)) {\r\nBAD_RING(vq, "id %u out of range\n", i);\r\nreturn NULL;\r\n}\r\nif (unlikely(!vq->data[i])) {\r\nBAD_RING(vq, "id %u is not a head!\n", i);\r\nreturn NULL;\r\n}\r\nret = vq->data[i];\r\ndetach_buf(vq, i);\r\nvq->last_used_idx++;\r\nif (!(vq->vring.avail->flags & VRING_AVAIL_F_NO_INTERRUPT)) {\r\nvring_used_event(&vq->vring) = vq->last_used_idx;\r\nvirtio_mb(vq->weak_barriers);\r\n}\r\n#ifdef DEBUG\r\nvq->last_add_time_valid = false;\r\n#endif\r\nEND_USE(vq);\r\nreturn ret;\r\n}\r\nvoid virtqueue_disable_cb(struct virtqueue *_vq)\r\n{\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nvq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;\r\n}\r\nunsigned virtqueue_enable_cb_prepare(struct virtqueue *_vq)\r\n{\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nu16 last_used_idx;\r\nSTART_USE(vq);\r\nvq->vring.avail->flags &= ~VRING_AVAIL_F_NO_INTERRUPT;\r\nvring_used_event(&vq->vring) = last_used_idx = vq->last_used_idx;\r\nEND_USE(vq);\r\nreturn last_used_idx;\r\n}\r\nbool virtqueue_poll(struct virtqueue *_vq, unsigned last_used_idx)\r\n{\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nvirtio_mb(vq->weak_barriers);\r\nreturn (u16)last_used_idx != vq->vring.used->idx;\r\n}\r\nbool virtqueue_enable_cb(struct virtqueue *_vq)\r\n{\r\nunsigned last_used_idx = virtqueue_enable_cb_prepare(_vq);\r\nreturn !virtqueue_poll(_vq, last_used_idx);\r\n}\r\nbool virtqueue_enable_cb_delayed(struct virtqueue *_vq)\r\n{\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nu16 bufs;\r\nSTART_USE(vq);\r\nvq->vring.avail->flags &= ~VRING_AVAIL_F_NO_INTERRUPT;\r\nbufs = (u16)(vq->vring.avail->idx - vq->last_used_idx) * 3 / 4;\r\nvring_used_event(&vq->vring) = vq->last_used_idx + bufs;\r\nvirtio_mb(vq->weak_barriers);\r\nif (unlikely((u16)(vq->vring.used->idx - vq->last_used_idx) > bufs)) {\r\nEND_USE(vq);\r\nreturn false;\r\n}\r\nEND_USE(vq);\r\nreturn true;\r\n}\r\nvoid *virtqueue_detach_unused_buf(struct virtqueue *_vq)\r\n{\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nunsigned int i;\r\nvoid *buf;\r\nSTART_USE(vq);\r\nfor (i = 0; i < vq->vring.num; i++) {\r\nif (!vq->data[i])\r\ncontinue;\r\nbuf = vq->data[i];\r\ndetach_buf(vq, i);\r\nvq->vring.avail->idx--;\r\nEND_USE(vq);\r\nreturn buf;\r\n}\r\nBUG_ON(vq->vq.num_free != vq->vring.num);\r\nEND_USE(vq);\r\nreturn NULL;\r\n}\r\nirqreturn_t vring_interrupt(int irq, void *_vq)\r\n{\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nif (!more_used(vq)) {\r\npr_debug("virtqueue interrupt with no work for %p\n", vq);\r\nreturn IRQ_NONE;\r\n}\r\nif (unlikely(vq->broken))\r\nreturn IRQ_HANDLED;\r\npr_debug("virtqueue callback for %p (%p)\n", vq, vq->vq.callback);\r\nif (vq->vq.callback)\r\nvq->vq.callback(&vq->vq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstruct virtqueue *vring_new_virtqueue(unsigned int index,\r\nunsigned int num,\r\nunsigned int vring_align,\r\nstruct virtio_device *vdev,\r\nbool weak_barriers,\r\nvoid *pages,\r\nbool (*notify)(struct virtqueue *),\r\nvoid (*callback)(struct virtqueue *),\r\nconst char *name)\r\n{\r\nstruct vring_virtqueue *vq;\r\nunsigned int i;\r\nif (num & (num - 1)) {\r\ndev_warn(&vdev->dev, "Bad virtqueue length %u\n", num);\r\nreturn NULL;\r\n}\r\nvq = kmalloc(sizeof(*vq) + sizeof(void *)*num, GFP_KERNEL);\r\nif (!vq)\r\nreturn NULL;\r\nvring_init(&vq->vring, num, pages, vring_align);\r\nvq->vq.callback = callback;\r\nvq->vq.vdev = vdev;\r\nvq->vq.name = name;\r\nvq->vq.num_free = num;\r\nvq->vq.index = index;\r\nvq->notify = notify;\r\nvq->weak_barriers = weak_barriers;\r\nvq->broken = false;\r\nvq->last_used_idx = 0;\r\nvq->num_added = 0;\r\nlist_add_tail(&vq->vq.list, &vdev->vqs);\r\n#ifdef DEBUG\r\nvq->in_use = false;\r\nvq->last_add_time_valid = false;\r\n#endif\r\nvq->indirect = virtio_has_feature(vdev, VIRTIO_RING_F_INDIRECT_DESC);\r\nvq->event = virtio_has_feature(vdev, VIRTIO_RING_F_EVENT_IDX);\r\nif (!callback)\r\nvq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;\r\nvq->free_head = 0;\r\nfor (i = 0; i < num-1; i++) {\r\nvq->vring.desc[i].next = i+1;\r\nvq->data[i] = NULL;\r\n}\r\nvq->data[i] = NULL;\r\nreturn &vq->vq;\r\n}\r\nvoid vring_del_virtqueue(struct virtqueue *vq)\r\n{\r\nlist_del(&vq->list);\r\nkfree(to_vvq(vq));\r\n}\r\nvoid vring_transport_features(struct virtio_device *vdev)\r\n{\r\nunsigned int i;\r\nfor (i = VIRTIO_TRANSPORT_F_START; i < VIRTIO_TRANSPORT_F_END; i++) {\r\nswitch (i) {\r\ncase VIRTIO_RING_F_INDIRECT_DESC:\r\nbreak;\r\ncase VIRTIO_RING_F_EVENT_IDX:\r\nbreak;\r\ndefault:\r\nclear_bit(i, vdev->features);\r\n}\r\n}\r\n}\r\nunsigned int virtqueue_get_vring_size(struct virtqueue *_vq)\r\n{\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nreturn vq->vring.num;\r\n}\r\nbool virtqueue_is_broken(struct virtqueue *_vq)\r\n{\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nreturn vq->broken;\r\n}\r\nvoid virtio_break_device(struct virtio_device *dev)\r\n{\r\nstruct virtqueue *_vq;\r\nlist_for_each_entry(_vq, &dev->vqs, list) {\r\nstruct vring_virtqueue *vq = to_vvq(_vq);\r\nvq->broken = true;\r\n}\r\n}
