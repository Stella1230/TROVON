static int __init validate_parameters(void)\r\n{\r\nchar *str;\r\nchar *p;\r\nunsigned long tmp;\r\nif(!bridge) {\r\ninfo("not configured, disabling.");\r\nreturn -EINVAL;\r\n}\r\nstr = bridge;\r\nif(!*str)\r\nreturn -EINVAL;\r\ntmp = simple_strtoul(str, &p, 16);\r\nif(p == str || tmp > 0xff) {\r\nerr("Invalid hotplug bus bridge device bus number");\r\nreturn -EINVAL;\r\n}\r\nbridge_busnr = (u8) tmp;\r\ndbg("bridge_busnr = 0x%02x", bridge_busnr);\r\nif(*p != ':') {\r\nerr("Invalid hotplug bus bridge device");\r\nreturn -EINVAL;\r\n}\r\nstr = p + 1;\r\ntmp = simple_strtoul(str, &p, 16);\r\nif(p == str || tmp > 0x1f) {\r\nerr("Invalid hotplug bus bridge device slot number");\r\nreturn -EINVAL;\r\n}\r\nbridge_slot = (u8) tmp;\r\ndbg("bridge_slot = 0x%02x", bridge_slot);\r\ndbg("first_slot = 0x%02x", first_slot);\r\ndbg("last_slot = 0x%02x", last_slot);\r\nif(!(first_slot && last_slot)) {\r\nerr("Need to specify first_slot and last_slot");\r\nreturn -EINVAL;\r\n}\r\nif(last_slot < first_slot) {\r\nerr("first_slot must be less than last_slot");\r\nreturn -EINVAL;\r\n}\r\ndbg("port = 0x%04x", port);\r\ndbg("enum_bit = 0x%02x", enum_bit);\r\nif(enum_bit > 7) {\r\nerr("Invalid #ENUM bit");\r\nreturn -EINVAL;\r\n}\r\nenum_mask = 1 << enum_bit;\r\nreturn 0;\r\n}\r\nstatic int query_enum(void)\r\n{\r\nu8 value;\r\nvalue = inb_p(port);\r\nreturn ((value & enum_mask) == enum_mask);\r\n}\r\nstatic int __init cpcihp_generic_init(void)\r\n{\r\nint status;\r\nstruct resource *r;\r\nstruct pci_dev *dev;\r\ninfo(DRIVER_DESC " version: " DRIVER_VERSION);\r\nstatus = validate_parameters();\r\nif (status)\r\nreturn status;\r\nr = request_region(port, 1, "#ENUM hotswap signal register");\r\nif(!r)\r\nreturn -EBUSY;\r\ndev = pci_get_domain_bus_and_slot(0, bridge_busnr,\r\nPCI_DEVFN(bridge_slot, 0));\r\nif(!dev || dev->hdr_type != PCI_HEADER_TYPE_BRIDGE) {\r\nerr("Invalid bridge device %s", bridge);\r\npci_dev_put(dev);\r\nreturn -EINVAL;\r\n}\r\nbus = dev->subordinate;\r\npci_dev_put(dev);\r\nmemset(&generic_hpc, 0, sizeof (struct cpci_hp_controller));\r\ngeneric_hpc_ops.query_enum = query_enum;\r\ngeneric_hpc.ops = &generic_hpc_ops;\r\nstatus = cpci_hp_register_controller(&generic_hpc);\r\nif(status != 0) {\r\nerr("Could not register cPCI hotplug controller");\r\nreturn -ENODEV;\r\n}\r\ndbg("registered controller");\r\nstatus = cpci_hp_register_bus(bus, first_slot, last_slot);\r\nif(status != 0) {\r\nerr("Could not register cPCI hotplug bus");\r\ngoto init_bus_register_error;\r\n}\r\ndbg("registered bus");\r\nstatus = cpci_hp_start();\r\nif(status != 0) {\r\nerr("Could not started cPCI hotplug system");\r\ngoto init_start_error;\r\n}\r\ndbg("started cpci hp system");\r\nreturn 0;\r\ninit_start_error:\r\ncpci_hp_unregister_bus(bus);\r\ninit_bus_register_error:\r\ncpci_hp_unregister_controller(&generic_hpc);\r\nerr("status = %d", status);\r\nreturn status;\r\n}\r\nstatic void __exit cpcihp_generic_exit(void)\r\n{\r\ncpci_hp_stop();\r\ncpci_hp_unregister_bus(bus);\r\ncpci_hp_unregister_controller(&generic_hpc);\r\nrelease_region(port, 1);\r\n}
