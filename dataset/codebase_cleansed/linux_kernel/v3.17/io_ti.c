static int ti_vread_sync(struct usb_device *dev, __u8 request,\r\n__u16 value, __u16 index, u8 *data, int size)\r\n{\r\nint status;\r\nstatus = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,\r\n(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN),\r\nvalue, index, data, size, 1000);\r\nif (status < 0)\r\nreturn status;\r\nif (status != size) {\r\ndev_dbg(&dev->dev, "%s - wanted to write %d, but only wrote %d\n",\r\n__func__, size, status);\r\nreturn -ECOMM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ti_vsend_sync(struct usb_device *dev, __u8 request,\r\n__u16 value, __u16 index, u8 *data, int size)\r\n{\r\nint status;\r\nstatus = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), request,\r\n(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT),\r\nvalue, index, data, size, 1000);\r\nif (status < 0)\r\nreturn status;\r\nif (status != size) {\r\ndev_dbg(&dev->dev, "%s - wanted to write %d, but only wrote %d\n",\r\n__func__, size, status);\r\nreturn -ECOMM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int send_cmd(struct usb_device *dev, __u8 command,\r\n__u8 moduleid, __u16 value, u8 *data,\r\nint size)\r\n{\r\nreturn ti_vsend_sync(dev, command, value, moduleid, data, size);\r\n}\r\nstatic int purge_port(struct usb_serial_port *port, __u16 mask)\r\n{\r\nint port_number = port->port_number;\r\ndev_dbg(&port->dev, "%s - port %d, mask %x\n", __func__, port_number, mask);\r\nreturn send_cmd(port->serial->dev,\r\nUMPC_PURGE_PORT,\r\n(__u8)(UMPM_UART1_PORT + port_number),\r\nmask,\r\nNULL,\r\n0);\r\n}\r\nstatic int read_download_mem(struct usb_device *dev, int start_address,\r\nint length, __u8 address_type, __u8 *buffer)\r\n{\r\nint status = 0;\r\n__u8 read_length;\r\nu16 be_start_address;\r\ndev_dbg(&dev->dev, "%s - @ %x for %d\n", __func__, start_address, length);\r\nwhile (length) {\r\nif (length > 64)\r\nread_length = 64;\r\nelse\r\nread_length = (__u8)length;\r\nif (read_length > 1) {\r\ndev_dbg(&dev->dev, "%s - @ %x for %d\n", __func__, start_address, read_length);\r\n}\r\nbe_start_address = swab16((u16)start_address);\r\nstatus = ti_vread_sync(dev, UMPC_MEMORY_READ,\r\n(__u16)address_type,\r\nbe_start_address,\r\nbuffer, read_length);\r\nif (status) {\r\ndev_dbg(&dev->dev, "%s - ERROR %x\n", __func__, status);\r\nreturn status;\r\n}\r\nif (read_length > 1)\r\nusb_serial_debug_data(&dev->dev, __func__, read_length, buffer);\r\nstart_address += read_length;\r\nbuffer += read_length;\r\nlength -= read_length;\r\n}\r\nreturn status;\r\n}\r\nstatic int read_ram(struct usb_device *dev, int start_address,\r\nint length, __u8 *buffer)\r\n{\r\nreturn read_download_mem(dev, start_address, length,\r\nDTK_ADDR_SPACE_XDATA, buffer);\r\n}\r\nstatic int read_boot_mem(struct edgeport_serial *serial,\r\nint start_address, int length, __u8 *buffer)\r\n{\r\nint status = 0;\r\nint i;\r\nfor (i = 0; i < length; i++) {\r\nstatus = ti_vread_sync(serial->serial->dev,\r\nUMPC_MEMORY_READ, serial->TI_I2C_Type,\r\n(__u16)(start_address+i), &buffer[i], 0x01);\r\nif (status) {\r\ndev_dbg(&serial->serial->dev->dev, "%s - ERROR %x\n", __func__, status);\r\nreturn status;\r\n}\r\n}\r\ndev_dbg(&serial->serial->dev->dev, "%s - start_address = %x, length = %d\n",\r\n__func__, start_address, length);\r\nusb_serial_debug_data(&serial->serial->dev->dev, __func__, length, buffer);\r\nserial->TiReadI2C = 1;\r\nreturn status;\r\n}\r\nstatic int write_boot_mem(struct edgeport_serial *serial,\r\nint start_address, int length, __u8 *buffer)\r\n{\r\nint status = 0;\r\nint i;\r\nu8 *temp;\r\nif (!serial->TiReadI2C) {\r\ntemp = kmalloc(1, GFP_KERNEL);\r\nif (!temp)\r\nreturn -ENOMEM;\r\nstatus = read_boot_mem(serial, 0, 1, temp);\r\nkfree(temp);\r\nif (status)\r\nreturn status;\r\n}\r\nfor (i = 0; i < length; ++i) {\r\nstatus = ti_vsend_sync(serial->serial->dev,\r\nUMPC_MEMORY_WRITE, buffer[i],\r\n(__u16)(i + start_address), NULL, 0);\r\nif (status)\r\nreturn status;\r\n}\r\ndev_dbg(&serial->serial->dev->dev, "%s - start_sddr = %x, length = %d\n", __func__, start_address, length);\r\nusb_serial_debug_data(&serial->serial->dev->dev, __func__, length, buffer);\r\nreturn status;\r\n}\r\nstatic int write_i2c_mem(struct edgeport_serial *serial,\r\nint start_address, int length, __u8 address_type, __u8 *buffer)\r\n{\r\nstruct device *dev = &serial->serial->dev->dev;\r\nint status = 0;\r\nint write_length;\r\nu16 be_start_address;\r\nwrite_length = EPROM_PAGE_SIZE -\r\n(start_address & (EPROM_PAGE_SIZE - 1));\r\nif (write_length > length)\r\nwrite_length = length;\r\ndev_dbg(dev, "%s - BytesInFirstPage Addr = %x, length = %d\n",\r\n__func__, start_address, write_length);\r\nusb_serial_debug_data(dev, __func__, write_length, buffer);\r\nbe_start_address = swab16((u16)start_address);\r\nstatus = ti_vsend_sync(serial->serial->dev,\r\nUMPC_MEMORY_WRITE, (__u16)address_type,\r\nbe_start_address,\r\nbuffer, write_length);\r\nif (status) {\r\ndev_dbg(dev, "%s - ERROR %d\n", __func__, status);\r\nreturn status;\r\n}\r\nlength -= write_length;\r\nstart_address += write_length;\r\nbuffer += write_length;\r\nwhile (length) {\r\nif (length > EPROM_PAGE_SIZE)\r\nwrite_length = EPROM_PAGE_SIZE;\r\nelse\r\nwrite_length = length;\r\ndev_dbg(dev, "%s - Page Write Addr = %x, length = %d\n",\r\n__func__, start_address, write_length);\r\nusb_serial_debug_data(dev, __func__, write_length, buffer);\r\nbe_start_address = swab16((u16)start_address);\r\nstatus = ti_vsend_sync(serial->serial->dev, UMPC_MEMORY_WRITE,\r\n(__u16)address_type,\r\nbe_start_address,\r\nbuffer, write_length);\r\nif (status) {\r\ndev_err(dev, "%s - ERROR %d\n", __func__, status);\r\nreturn status;\r\n}\r\nlength -= write_length;\r\nstart_address += write_length;\r\nbuffer += write_length;\r\n}\r\nreturn status;\r\n}\r\nstatic int tx_active(struct edgeport_port *port)\r\n{\r\nint status;\r\nstruct out_endpoint_desc_block *oedb;\r\n__u8 *lsr;\r\nint bytes_left = 0;\r\noedb = kmalloc(sizeof(*oedb), GFP_KERNEL);\r\nif (!oedb)\r\nreturn -ENOMEM;\r\nlsr = kmalloc(1, GFP_KERNEL);\r\nif (!lsr) {\r\nkfree(oedb);\r\nreturn -ENOMEM;\r\n}\r\nstatus = read_ram(port->port->serial->dev, port->dma_address,\r\nsizeof(*oedb), (void *)oedb);\r\nif (status)\r\ngoto exit_is_tx_active;\r\ndev_dbg(&port->port->dev, "%s - XByteCount 0x%X\n", __func__, oedb->XByteCount);\r\nstatus = read_ram(port->port->serial->dev,\r\nport->uart_base + UMPMEM_OFFS_UART_LSR, 1, lsr);\r\nif (status)\r\ngoto exit_is_tx_active;\r\ndev_dbg(&port->port->dev, "%s - LSR = 0x%X\n", __func__, *lsr);\r\nif ((oedb->XByteCount & 0x80) != 0)\r\nbytes_left += 64;\r\nif ((*lsr & UMP_UART_LSR_TX_MASK) == 0)\r\nbytes_left += 1;\r\nexit_is_tx_active:\r\ndev_dbg(&port->port->dev, "%s - return %d\n", __func__, bytes_left);\r\nkfree(lsr);\r\nkfree(oedb);\r\nreturn bytes_left;\r\n}\r\nstatic int choose_config(struct usb_device *dev)\r\n{\r\ndev_dbg(&dev->dev, "%s - Number of Interfaces = %d\n",\r\n__func__, dev->config->desc.bNumInterfaces);\r\ndev_dbg(&dev->dev, "%s - MAX Power = %d\n",\r\n__func__, dev->config->desc.bMaxPower * 2);\r\nif (dev->config->desc.bNumInterfaces != 1) {\r\ndev_err(&dev->dev, "%s - bNumInterfaces is not 1, ERROR!\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int read_rom(struct edgeport_serial *serial,\r\nint start_address, int length, __u8 *buffer)\r\n{\r\nint status;\r\nif (serial->product_info.TiMode == TI_MODE_DOWNLOAD) {\r\nstatus = read_download_mem(serial->serial->dev,\r\nstart_address,\r\nlength,\r\nserial->TI_I2C_Type,\r\nbuffer);\r\n} else {\r\nstatus = read_boot_mem(serial, start_address, length,\r\nbuffer);\r\n}\r\nreturn status;\r\n}\r\nstatic int write_rom(struct edgeport_serial *serial, int start_address,\r\nint length, __u8 *buffer)\r\n{\r\nif (serial->product_info.TiMode == TI_MODE_BOOT)\r\nreturn write_boot_mem(serial, start_address, length,\r\nbuffer);\r\nif (serial->product_info.TiMode == TI_MODE_DOWNLOAD)\r\nreturn write_i2c_mem(serial, start_address, length,\r\nserial->TI_I2C_Type, buffer);\r\nreturn -EINVAL;\r\n}\r\nstatic int get_descriptor_addr(struct edgeport_serial *serial,\r\nint desc_type, struct ti_i2c_desc *rom_desc)\r\n{\r\nint start_address;\r\nint status;\r\nstart_address = 2;\r\ndo {\r\nstatus = read_rom(serial,\r\nstart_address,\r\nsizeof(struct ti_i2c_desc),\r\n(__u8 *)rom_desc);\r\nif (status)\r\nreturn 0;\r\nif (rom_desc->Type == desc_type)\r\nreturn start_address;\r\nstart_address = start_address + sizeof(struct ti_i2c_desc) +\r\nle16_to_cpu(rom_desc->Size);\r\n} while ((start_address < TI_MAX_I2C_SIZE) && rom_desc->Type);\r\nreturn 0;\r\n}\r\nstatic int valid_csum(struct ti_i2c_desc *rom_desc, __u8 *buffer)\r\n{\r\n__u16 i;\r\n__u8 cs = 0;\r\nfor (i = 0; i < le16_to_cpu(rom_desc->Size); i++)\r\ncs = (__u8)(cs + buffer[i]);\r\nif (cs != rom_desc->CheckSum) {\r\npr_debug("%s - Mismatch %x - %x", __func__, rom_desc->CheckSum, cs);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_i2c_image(struct edgeport_serial *serial)\r\n{\r\nstruct device *dev = &serial->serial->dev->dev;\r\nint status = 0;\r\nstruct ti_i2c_desc *rom_desc;\r\nint start_address = 2;\r\n__u8 *buffer;\r\n__u16 ttype;\r\nrom_desc = kmalloc(sizeof(*rom_desc), GFP_KERNEL);\r\nif (!rom_desc)\r\nreturn -ENOMEM;\r\nbuffer = kmalloc(TI_MAX_I2C_SIZE, GFP_KERNEL);\r\nif (!buffer) {\r\nkfree(rom_desc);\r\nreturn -ENOMEM;\r\n}\r\nstatus = read_rom(serial, 0, 1, buffer);\r\nif (status)\r\ngoto out;\r\nif (*buffer != UMP5152 && *buffer != UMP3410) {\r\ndev_err(dev, "%s - invalid buffer signature\n", __func__);\r\nstatus = -ENODEV;\r\ngoto out;\r\n}\r\ndo {\r\nstatus = read_rom(serial,\r\nstart_address,\r\nsizeof(struct ti_i2c_desc),\r\n(__u8 *)rom_desc);\r\nif (status)\r\nbreak;\r\nif ((start_address + sizeof(struct ti_i2c_desc) +\r\nle16_to_cpu(rom_desc->Size)) > TI_MAX_I2C_SIZE) {\r\nstatus = -ENODEV;\r\ndev_dbg(dev, "%s - structure too big, erroring out.\n", __func__);\r\nbreak;\r\n}\r\ndev_dbg(dev, "%s Type = 0x%x\n", __func__, rom_desc->Type);\r\nttype = rom_desc->Type & 0x0f;\r\nif (ttype != I2C_DESC_TYPE_FIRMWARE_BASIC\r\n&& ttype != I2C_DESC_TYPE_FIRMWARE_AUTO) {\r\nstatus = read_rom(serial, start_address +\r\nsizeof(struct ti_i2c_desc),\r\nle16_to_cpu(rom_desc->Size),\r\nbuffer);\r\nif (status)\r\nbreak;\r\nstatus = valid_csum(rom_desc, buffer);\r\nif (status)\r\nbreak;\r\n}\r\nstart_address = start_address + sizeof(struct ti_i2c_desc) +\r\nle16_to_cpu(rom_desc->Size);\r\n} while ((rom_desc->Type != I2C_DESC_TYPE_ION) &&\r\n(start_address < TI_MAX_I2C_SIZE));\r\nif ((rom_desc->Type != I2C_DESC_TYPE_ION) ||\r\n(start_address > TI_MAX_I2C_SIZE))\r\nstatus = -ENODEV;\r\nout:\r\nkfree(buffer);\r\nkfree(rom_desc);\r\nreturn status;\r\n}\r\nstatic int get_manuf_info(struct edgeport_serial *serial, __u8 *buffer)\r\n{\r\nint status;\r\nint start_address;\r\nstruct ti_i2c_desc *rom_desc;\r\nstruct edge_ti_manuf_descriptor *desc;\r\nstruct device *dev = &serial->serial->dev->dev;\r\nrom_desc = kmalloc(sizeof(*rom_desc), GFP_KERNEL);\r\nif (!rom_desc)\r\nreturn -ENOMEM;\r\nstart_address = get_descriptor_addr(serial, I2C_DESC_TYPE_ION,\r\nrom_desc);\r\nif (!start_address) {\r\ndev_dbg(dev, "%s - Edge Descriptor not found in I2C\n", __func__);\r\nstatus = -ENODEV;\r\ngoto exit;\r\n}\r\nstatus = read_rom(serial, start_address+sizeof(struct ti_i2c_desc),\r\nle16_to_cpu(rom_desc->Size), buffer);\r\nif (status)\r\ngoto exit;\r\nstatus = valid_csum(rom_desc, buffer);\r\ndesc = (struct edge_ti_manuf_descriptor *)buffer;\r\ndev_dbg(dev, "%s - IonConfig 0x%x\n", __func__, desc->IonConfig);\r\ndev_dbg(dev, "%s - Version %d\n", __func__, desc->Version);\r\ndev_dbg(dev, "%s - Cpu/Board 0x%x\n", __func__, desc->CpuRev_BoardRev);\r\ndev_dbg(dev, "%s - NumPorts %d\n", __func__, desc->NumPorts);\r\ndev_dbg(dev, "%s - NumVirtualPorts %d\n", __func__, desc->NumVirtualPorts);\r\ndev_dbg(dev, "%s - TotalPorts %d\n", __func__, desc->TotalPorts);\r\nexit:\r\nkfree(rom_desc);\r\nreturn status;\r\n}\r\nstatic int build_i2c_fw_hdr(__u8 *header, struct device *dev)\r\n{\r\n__u8 *buffer;\r\nint buffer_size;\r\nint i;\r\nint err;\r\n__u8 cs = 0;\r\nstruct ti_i2c_desc *i2c_header;\r\nstruct ti_i2c_image_header *img_header;\r\nstruct ti_i2c_firmware_rec *firmware_rec;\r\nconst struct firmware *fw;\r\nconst char *fw_name = "edgeport/down3.bin";\r\nbuffer_size = (((1024 * 16) - 512 ) +\r\nsizeof(struct ti_i2c_firmware_rec));\r\nbuffer = kmalloc(buffer_size, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nmemset(buffer, 0xff, buffer_size);\r\nerr = request_firmware(&fw, fw_name, dev);\r\nif (err) {\r\ndev_err(dev, "Failed to load image \"%s\" err %d\n",\r\nfw_name, err);\r\nkfree(buffer);\r\nreturn err;\r\n}\r\nOperationalMajorVersion = fw->data[0];\r\nOperationalMinorVersion = fw->data[1];\r\nOperationalBuildNumber = fw->data[2] | (fw->data[3] << 8);\r\nfirmware_rec = (struct ti_i2c_firmware_rec *)buffer;\r\nfirmware_rec->Ver_Major = OperationalMajorVersion;\r\nfirmware_rec->Ver_Minor = OperationalMinorVersion;\r\nimg_header = (struct ti_i2c_image_header *)&fw->data[4];\r\nmemcpy(buffer + sizeof(struct ti_i2c_firmware_rec),\r\n&fw->data[4 + sizeof(struct ti_i2c_image_header)],\r\nle16_to_cpu(img_header->Length));\r\nrelease_firmware(fw);\r\nfor (i=0; i < buffer_size; i++) {\r\ncs = (__u8)(cs + buffer[i]);\r\n}\r\nkfree(buffer);\r\ni2c_header = (struct ti_i2c_desc *)header;\r\nfirmware_rec = (struct ti_i2c_firmware_rec*)i2c_header->Data;\r\ni2c_header->Type = I2C_DESC_TYPE_FIRMWARE_BLANK;\r\ni2c_header->Size = cpu_to_le16(buffer_size);\r\ni2c_header->CheckSum = cs;\r\nfirmware_rec->Ver_Major = OperationalMajorVersion;\r\nfirmware_rec->Ver_Minor = OperationalMinorVersion;\r\nreturn 0;\r\n}\r\nstatic int i2c_type_bootmode(struct edgeport_serial *serial)\r\n{\r\nstruct device *dev = &serial->serial->dev->dev;\r\nint status;\r\nu8 *data;\r\ndata = kmalloc(1, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nstatus = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,\r\nDTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);\r\nif (status)\r\ndev_dbg(dev, "%s - read 2 status error = %d\n", __func__, status);\r\nelse\r\ndev_dbg(dev, "%s - read 2 data = 0x%x\n", __func__, *data);\r\nif ((!status) && (*data == UMP5152 || *data == UMP3410)) {\r\ndev_dbg(dev, "%s - ROM_TYPE_II\n", __func__);\r\nserial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;\r\ngoto out;\r\n}\r\nstatus = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,\r\nDTK_ADDR_SPACE_I2C_TYPE_III, 0, data, 0x01);\r\nif (status)\r\ndev_dbg(dev, "%s - read 3 status error = %d\n", __func__, status);\r\nelse\r\ndev_dbg(dev, "%s - read 2 data = 0x%x\n", __func__, *data);\r\nif ((!status) && (*data == UMP5152 || *data == UMP3410)) {\r\ndev_dbg(dev, "%s - ROM_TYPE_III\n", __func__);\r\nserial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_III;\r\ngoto out;\r\n}\r\ndev_dbg(dev, "%s - Unknown\n", __func__);\r\nserial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;\r\nstatus = -ENODEV;\r\nout:\r\nkfree(data);\r\nreturn status;\r\n}\r\nstatic int bulk_xfer(struct usb_serial *serial, void *buffer,\r\nint length, int *num_sent)\r\n{\r\nint status;\r\nstatus = usb_bulk_msg(serial->dev,\r\nusb_sndbulkpipe(serial->dev,\r\nserial->port[0]->bulk_out_endpointAddress),\r\nbuffer, length, num_sent, 1000);\r\nreturn status;\r\n}\r\nstatic int download_code(struct edgeport_serial *serial, __u8 *image,\r\nint image_length)\r\n{\r\nint status = 0;\r\nint pos;\r\nint transfer;\r\nint done;\r\nfor (pos = 0; pos < image_length; ) {\r\ntransfer = image_length - pos;\r\nif (transfer > EDGE_FW_BULK_MAX_PACKET_SIZE)\r\ntransfer = EDGE_FW_BULK_MAX_PACKET_SIZE;\r\nstatus = bulk_xfer(serial->serial, &image[pos],\r\ntransfer, &done);\r\nif (status)\r\nbreak;\r\npos += done;\r\n}\r\nreturn status;\r\n}\r\nstatic int config_boot_dev(struct usb_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ti_cpu_rev(struct edge_ti_manuf_descriptor *desc)\r\n{\r\nreturn TI_GET_CPU_REVISION(desc->CpuRev_BoardRev);\r\n}\r\nstatic int download_fw(struct edgeport_serial *serial)\r\n{\r\nstruct device *dev = &serial->serial->dev->dev;\r\nint status = 0;\r\nint start_address;\r\nstruct edge_ti_manuf_descriptor *ti_manuf_desc;\r\nstruct usb_interface_descriptor *interface;\r\nint download_cur_ver;\r\nint download_new_ver;\r\nserial->product_info.hardware_type = HARDWARE_TYPE_TIUMP;\r\nserial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;\r\nstatus = choose_config(serial->serial->dev);\r\nif (status)\r\nreturn status;\r\ninterface = &serial->serial->interface->cur_altsetting->desc;\r\nif (!interface) {\r\ndev_err(dev, "%s - no interface set, error!\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nif (interface->bNumEndpoints > 1)\r\nserial->product_info.TiMode = TI_MODE_DOWNLOAD;\r\nelse\r\nserial->product_info.TiMode = TI_MODE_CONFIGURING;\r\nif (serial->product_info.TiMode == TI_MODE_DOWNLOAD) {\r\nstruct ti_i2c_desc *rom_desc;\r\ndev_dbg(dev, "%s - RUNNING IN DOWNLOAD MODE\n", __func__);\r\nstatus = check_i2c_image(serial);\r\nif (status) {\r\ndev_dbg(dev, "%s - DOWNLOAD MODE -- BAD I2C\n", __func__);\r\nreturn status;\r\n}\r\nti_manuf_desc = kmalloc(sizeof(*ti_manuf_desc), GFP_KERNEL);\r\nif (!ti_manuf_desc)\r\nreturn -ENOMEM;\r\nstatus = get_manuf_info(serial, (__u8 *)ti_manuf_desc);\r\nif (status) {\r\nkfree(ti_manuf_desc);\r\nreturn status;\r\n}\r\nif (!ignore_cpu_rev && ti_cpu_rev(ti_manuf_desc) < 2) {\r\ndev_dbg(dev, "%s - Wrong CPU Rev %d (Must be 2)\n",\r\n__func__, ti_cpu_rev(ti_manuf_desc));\r\nkfree(ti_manuf_desc);\r\nreturn -EINVAL;\r\n}\r\nrom_desc = kmalloc(sizeof(*rom_desc), GFP_KERNEL);\r\nif (!rom_desc) {\r\nkfree(ti_manuf_desc);\r\nreturn -ENOMEM;\r\n}\r\nstart_address = get_descriptor_addr(serial,\r\nI2C_DESC_TYPE_FIRMWARE_BASIC, rom_desc);\r\nif (start_address != 0) {\r\nstruct ti_i2c_firmware_rec *firmware_version;\r\nu8 *record;\r\ndev_dbg(dev, "%s - Found Type FIRMWARE (Type 2) record\n", __func__);\r\nfirmware_version = kmalloc(sizeof(*firmware_version),\r\nGFP_KERNEL);\r\nif (!firmware_version) {\r\nkfree(rom_desc);\r\nkfree(ti_manuf_desc);\r\nreturn -ENOMEM;\r\n}\r\nstatus = read_rom(serial, start_address +\r\nsizeof(struct ti_i2c_desc),\r\nsizeof(struct ti_i2c_firmware_rec),\r\n(__u8 *)firmware_version);\r\nif (status) {\r\nkfree(firmware_version);\r\nkfree(rom_desc);\r\nkfree(ti_manuf_desc);\r\nreturn status;\r\n}\r\ndownload_cur_ver = (firmware_version->Ver_Major << 8) +\r\n(firmware_version->Ver_Minor);\r\ndownload_new_ver = (OperationalMajorVersion << 8) +\r\n(OperationalMinorVersion);\r\ndev_dbg(dev, "%s - >> FW Versions Device %d.%d Driver %d.%d\n",\r\n__func__, firmware_version->Ver_Major,\r\nfirmware_version->Ver_Minor,\r\nOperationalMajorVersion,\r\nOperationalMinorVersion);\r\nif (download_cur_ver < download_new_ver) {\r\ndev_dbg(dev, "%s - Update I2C dld from %d.%d to %d.%d\n",\r\n__func__,\r\nfirmware_version->Ver_Major,\r\nfirmware_version->Ver_Minor,\r\nOperationalMajorVersion,\r\nOperationalMinorVersion);\r\nrecord = kmalloc(1, GFP_KERNEL);\r\nif (!record) {\r\nkfree(firmware_version);\r\nkfree(rom_desc);\r\nkfree(ti_manuf_desc);\r\nreturn -ENOMEM;\r\n}\r\n*record = I2C_DESC_TYPE_FIRMWARE_BLANK;\r\nstatus = write_rom(serial, start_address,\r\nsizeof(*record), record);\r\nif (status) {\r\nkfree(record);\r\nkfree(firmware_version);\r\nkfree(rom_desc);\r\nkfree(ti_manuf_desc);\r\nreturn status;\r\n}\r\nstatus = read_rom(serial,\r\nstart_address,\r\nsizeof(*record),\r\nrecord);\r\nif (status) {\r\nkfree(record);\r\nkfree(firmware_version);\r\nkfree(rom_desc);\r\nkfree(ti_manuf_desc);\r\nreturn status;\r\n}\r\nif (*record != I2C_DESC_TYPE_FIRMWARE_BLANK) {\r\ndev_err(dev, "%s - error resetting device\n", __func__);\r\nkfree(record);\r\nkfree(firmware_version);\r\nkfree(rom_desc);\r\nkfree(ti_manuf_desc);\r\nreturn -ENODEV;\r\n}\r\ndev_dbg(dev, "%s - HARDWARE RESET\n", __func__);\r\nstatus = ti_vsend_sync(serial->serial->dev,\r\nUMPC_HARDWARE_RESET,\r\n0, 0, NULL, 0);\r\ndev_dbg(dev, "%s - HARDWARE RESET return %d\n", __func__, status);\r\nkfree(record);\r\nkfree(firmware_version);\r\nkfree(rom_desc);\r\nkfree(ti_manuf_desc);\r\nreturn -ENODEV;\r\n}\r\nkfree(firmware_version);\r\n}\r\nelse if ((start_address = get_descriptor_addr(serial, I2C_DESC_TYPE_FIRMWARE_BLANK, rom_desc)) != 0) {\r\n#define HEADER_SIZE (sizeof(struct ti_i2c_desc) + \\r\nsizeof(struct ti_i2c_firmware_rec))\r\n__u8 *header;\r\n__u8 *vheader;\r\nheader = kmalloc(HEADER_SIZE, GFP_KERNEL);\r\nif (!header) {\r\nkfree(rom_desc);\r\nkfree(ti_manuf_desc);\r\nreturn -ENOMEM;\r\n}\r\nvheader = kmalloc(HEADER_SIZE, GFP_KERNEL);\r\nif (!vheader) {\r\nkfree(header);\r\nkfree(rom_desc);\r\nkfree(ti_manuf_desc);\r\nreturn -ENOMEM;\r\n}\r\ndev_dbg(dev, "%s - Found Type BLANK FIRMWARE (Type F2) record\n", __func__);\r\nstatus = build_i2c_fw_hdr(header, dev);\r\nif (status) {\r\nkfree(vheader);\r\nkfree(header);\r\nkfree(rom_desc);\r\nkfree(ti_manuf_desc);\r\nreturn -EINVAL;\r\n}\r\nstatus = write_rom(serial,\r\nstart_address,\r\nHEADER_SIZE,\r\nheader);\r\nif (status) {\r\nkfree(vheader);\r\nkfree(header);\r\nkfree(rom_desc);\r\nkfree(ti_manuf_desc);\r\nreturn -EINVAL;\r\n}\r\nstatus = read_rom(serial, start_address,\r\nHEADER_SIZE, vheader);\r\nif (status) {\r\ndev_dbg(dev, "%s - can't read header back\n", __func__);\r\nkfree(vheader);\r\nkfree(header);\r\nkfree(rom_desc);\r\nkfree(ti_manuf_desc);\r\nreturn status;\r\n}\r\nif (memcmp(vheader, header, HEADER_SIZE)) {\r\ndev_dbg(dev, "%s - write download record failed\n", __func__);\r\nkfree(vheader);\r\nkfree(header);\r\nkfree(rom_desc);\r\nkfree(ti_manuf_desc);\r\nreturn -EINVAL;\r\n}\r\nkfree(vheader);\r\nkfree(header);\r\ndev_dbg(dev, "%s - Start firmware update\n", __func__);\r\nstatus = ti_vsend_sync(serial->serial->dev,\r\nUMPC_COPY_DNLD_TO_I2C, 0, 0, NULL, 0);\r\ndev_dbg(dev, "%s - Update complete 0x%x\n", __func__, status);\r\nif (status) {\r\ndev_err(dev,\r\n"%s - UMPC_COPY_DNLD_TO_I2C failed\n",\r\n__func__);\r\nkfree(rom_desc);\r\nkfree(ti_manuf_desc);\r\nreturn status;\r\n}\r\n}\r\nkfree(rom_desc);\r\nkfree(ti_manuf_desc);\r\nreturn 0;\r\n}\r\ndev_dbg(dev, "%s - RUNNING IN BOOT MODE\n", __func__);\r\nstatus = config_boot_dev(serial->serial->dev);\r\nif (status)\r\nreturn status;\r\nif (le16_to_cpu(serial->serial->dev->descriptor.idVendor)\r\n!= USB_VENDOR_ID_ION) {\r\ndev_dbg(dev, "%s - VID = 0x%x\n", __func__,\r\nle16_to_cpu(serial->serial->dev->descriptor.idVendor));\r\nserial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;\r\ngoto stayinbootmode;\r\n}\r\nif (i2c_type_bootmode(serial))\r\ngoto stayinbootmode;\r\nif (!check_i2c_image(serial)) {\r\nstruct ti_i2c_image_header *header;\r\nint i;\r\n__u8 cs = 0;\r\n__u8 *buffer;\r\nint buffer_size;\r\nint err;\r\nconst struct firmware *fw;\r\nconst char *fw_name = "edgeport/down3.bin";\r\nti_manuf_desc = kmalloc(sizeof(*ti_manuf_desc), GFP_KERNEL);\r\nif (!ti_manuf_desc)\r\nreturn -ENOMEM;\r\nstatus = get_manuf_info(serial, (__u8 *)ti_manuf_desc);\r\nif (status) {\r\nkfree(ti_manuf_desc);\r\ngoto stayinbootmode;\r\n}\r\nif (!ignore_cpu_rev && ti_cpu_rev(ti_manuf_desc) < 2) {\r\ndev_dbg(dev, "%s - Wrong CPU Rev %d (Must be 2)\n",\r\n__func__, ti_cpu_rev(ti_manuf_desc));\r\nkfree(ti_manuf_desc);\r\ngoto stayinbootmode;\r\n}\r\nkfree(ti_manuf_desc);\r\nbuffer_size = (((1024 * 16) - 512) +\r\nsizeof(struct ti_i2c_image_header));\r\nbuffer = kmalloc(buffer_size, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nmemset(buffer, 0xff, buffer_size);\r\nerr = request_firmware(&fw, fw_name, dev);\r\nif (err) {\r\ndev_err(dev, "Failed to load image \"%s\" err %d\n",\r\nfw_name, err);\r\nkfree(buffer);\r\nreturn err;\r\n}\r\nmemcpy(buffer, &fw->data[4], fw->size - 4);\r\nrelease_firmware(fw);\r\nfor (i = sizeof(struct ti_i2c_image_header);\r\ni < buffer_size; i++) {\r\ncs = (__u8)(cs + buffer[i]);\r\n}\r\nheader = (struct ti_i2c_image_header *)buffer;\r\nheader->Length = cpu_to_le16((__u16)(buffer_size -\r\nsizeof(struct ti_i2c_image_header)));\r\nheader->CheckSum = cs;\r\ndev_dbg(dev, "%s - Downloading operational code image (TI UMP)\n", __func__);\r\nstatus = download_code(serial, buffer, buffer_size);\r\nkfree(buffer);\r\nif (status) {\r\ndev_dbg(dev, "%s - Error downloading operational code image\n", __func__);\r\nreturn status;\r\n}\r\nserial->product_info.TiMode = TI_MODE_TRANSITIONING;\r\ndev_dbg(dev, "%s - Download successful -- Device rebooting...\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nstayinbootmode:\r\ndev_dbg(dev, "%s - STAYING IN BOOT MODE\n", __func__);\r\nserial->product_info.TiMode = TI_MODE_BOOT;\r\nreturn 0;\r\n}\r\nstatic int ti_do_config(struct edgeport_port *port, int feature, int on)\r\n{\r\nint port_number = port->port->port_number;\r\non = !!on;\r\nreturn send_cmd(port->port->serial->dev,\r\nfeature, (__u8)(UMPM_UART1_PORT + port_number),\r\non, NULL, 0);\r\n}\r\nstatic int restore_mcr(struct edgeport_port *port, __u8 mcr)\r\n{\r\nint status = 0;\r\ndev_dbg(&port->port->dev, "%s - %x\n", __func__, mcr);\r\nstatus = ti_do_config(port, UMPC_SET_CLR_DTR, mcr & MCR_DTR);\r\nif (status)\r\nreturn status;\r\nstatus = ti_do_config(port, UMPC_SET_CLR_RTS, mcr & MCR_RTS);\r\nif (status)\r\nreturn status;\r\nreturn ti_do_config(port, UMPC_SET_CLR_LOOPBACK, mcr & MCR_LOOPBACK);\r\n}\r\nstatic __u8 map_line_status(__u8 ti_lsr)\r\n{\r\n__u8 lsr = 0;\r\n#define MAP_FLAG(flagUmp, flagUart) \\r\nif (ti_lsr & flagUmp) \\r\nlsr |= flagUart;\r\nMAP_FLAG(UMP_UART_LSR_OV_MASK, LSR_OVER_ERR)\r\nMAP_FLAG(UMP_UART_LSR_PE_MASK, LSR_PAR_ERR)\r\nMAP_FLAG(UMP_UART_LSR_FE_MASK, LSR_FRM_ERR)\r\nMAP_FLAG(UMP_UART_LSR_BR_MASK, LSR_BREAK)\r\nMAP_FLAG(UMP_UART_LSR_RX_MASK, LSR_RX_AVAIL)\r\nMAP_FLAG(UMP_UART_LSR_TX_MASK, LSR_TX_EMPTY)\r\n#undef MAP_FLAG\r\nreturn lsr;\r\n}\r\nstatic void handle_new_msr(struct edgeport_port *edge_port, __u8 msr)\r\n{\r\nstruct async_icount *icount;\r\nstruct tty_struct *tty;\r\ndev_dbg(&edge_port->port->dev, "%s - %02x\n", __func__, msr);\r\nif (msr & (EDGEPORT_MSR_DELTA_CTS | EDGEPORT_MSR_DELTA_DSR |\r\nEDGEPORT_MSR_DELTA_RI | EDGEPORT_MSR_DELTA_CD)) {\r\nicount = &edge_port->port->icount;\r\nif (msr & EDGEPORT_MSR_DELTA_CTS)\r\nicount->cts++;\r\nif (msr & EDGEPORT_MSR_DELTA_DSR)\r\nicount->dsr++;\r\nif (msr & EDGEPORT_MSR_DELTA_CD)\r\nicount->dcd++;\r\nif (msr & EDGEPORT_MSR_DELTA_RI)\r\nicount->rng++;\r\nwake_up_interruptible(&edge_port->port->port.delta_msr_wait);\r\n}\r\nedge_port->shadow_msr = msr & 0xf0;\r\ntty = tty_port_tty_get(&edge_port->port->port);\r\nif (tty && C_CRTSCTS(tty)) {\r\nif (msr & EDGEPORT_MSR_CTS) {\r\ntty->hw_stopped = 0;\r\ntty_wakeup(tty);\r\n} else {\r\ntty->hw_stopped = 1;\r\n}\r\n}\r\ntty_kref_put(tty);\r\n}\r\nstatic void handle_new_lsr(struct edgeport_port *edge_port, int lsr_data,\r\n__u8 lsr, __u8 data)\r\n{\r\nstruct async_icount *icount;\r\n__u8 new_lsr = (__u8)(lsr & (__u8)(LSR_OVER_ERR | LSR_PAR_ERR |\r\nLSR_FRM_ERR | LSR_BREAK));\r\ndev_dbg(&edge_port->port->dev, "%s - %02x\n", __func__, new_lsr);\r\nedge_port->shadow_lsr = lsr;\r\nif (new_lsr & LSR_BREAK)\r\nnew_lsr &= (__u8)(LSR_OVER_ERR | LSR_BREAK);\r\nif (lsr_data)\r\nedge_tty_recv(edge_port->port, &data, 1);\r\nicount = &edge_port->port->icount;\r\nif (new_lsr & LSR_BREAK)\r\nicount->brk++;\r\nif (new_lsr & LSR_OVER_ERR)\r\nicount->overrun++;\r\nif (new_lsr & LSR_PAR_ERR)\r\nicount->parity++;\r\nif (new_lsr & LSR_FRM_ERR)\r\nicount->frame++;\r\n}\r\nstatic void edge_interrupt_callback(struct urb *urb)\r\n{\r\nstruct edgeport_serial *edge_serial = urb->context;\r\nstruct usb_serial_port *port;\r\nstruct edgeport_port *edge_port;\r\nstruct device *dev;\r\nunsigned char *data = urb->transfer_buffer;\r\nint length = urb->actual_length;\r\nint port_number;\r\nint function;\r\nint retval;\r\n__u8 lsr;\r\n__u8 msr;\r\nint status = urb->status;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&urb->dev->dev, "%s - urb shutting down with status: %d\n",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndev_err(&urb->dev->dev, "%s - nonzero urb status received: "\r\n"%d\n", __func__, status);\r\ngoto exit;\r\n}\r\nif (!length) {\r\ndev_dbg(&urb->dev->dev, "%s - no data in urb\n", __func__);\r\ngoto exit;\r\n}\r\ndev = &edge_serial->serial->dev->dev;\r\nusb_serial_debug_data(dev, __func__, length, data);\r\nif (length != 2) {\r\ndev_dbg(dev, "%s - expecting packet of size 2, got %d\n", __func__, length);\r\ngoto exit;\r\n}\r\nport_number = TIUMP_GET_PORT_FROM_CODE(data[0]);\r\nfunction = TIUMP_GET_FUNC_FROM_CODE(data[0]);\r\ndev_dbg(dev, "%s - port_number %d, function %d, info 0x%x\n", __func__,\r\nport_number, function, data[1]);\r\nport = edge_serial->serial->port[port_number];\r\nedge_port = usb_get_serial_port_data(port);\r\nif (!edge_port) {\r\ndev_dbg(dev, "%s - edge_port not found\n", __func__);\r\nreturn;\r\n}\r\nswitch (function) {\r\ncase TIUMP_INTERRUPT_CODE_LSR:\r\nlsr = map_line_status(data[1]);\r\nif (lsr & UMP_UART_LSR_DATA_MASK) {\r\ndev_dbg(dev, "%s - LSR Event Port %u LSR Status = %02x\n",\r\n__func__, port_number, lsr);\r\nedge_port->lsr_event = 1;\r\nedge_port->lsr_mask = lsr;\r\n} else {\r\ndev_dbg(dev, "%s - ===== Port %d LSR Status = %02x ======\n",\r\n__func__, port_number, lsr);\r\nhandle_new_lsr(edge_port, 0, lsr, 0);\r\n}\r\nbreak;\r\ncase TIUMP_INTERRUPT_CODE_MSR:\r\nmsr = data[1];\r\ndev_dbg(dev, "%s - ===== Port %u MSR Status = %02x ======\n",\r\n__func__, port_number, msr);\r\nhandle_new_msr(edge_port, msr);\r\nbreak;\r\ndefault:\r\ndev_err(&urb->dev->dev,\r\n"%s - Unknown Interrupt code from UMP %x\n",\r\n__func__, data[1]);\r\nbreak;\r\n}\r\nexit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(&urb->dev->dev,\r\n"%s - usb_submit_urb failed with result %d\n",\r\n__func__, retval);\r\n}\r\nstatic void edge_bulk_in_callback(struct urb *urb)\r\n{\r\nstruct edgeport_port *edge_port = urb->context;\r\nstruct device *dev = &edge_port->port->dev;\r\nunsigned char *data = urb->transfer_buffer;\r\nint retval = 0;\r\nint port_number;\r\nint status = urb->status;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&urb->dev->dev, "%s - urb shutting down with status: %d\n", __func__, status);\r\nreturn;\r\ndefault:\r\ndev_err(&urb->dev->dev, "%s - nonzero read bulk status received: %d\n", __func__, status);\r\n}\r\nif (status == -EPIPE)\r\ngoto exit;\r\nif (status) {\r\ndev_err(&urb->dev->dev, "%s - stopping read!\n", __func__);\r\nreturn;\r\n}\r\nport_number = edge_port->port->port_number;\r\nif (edge_port->lsr_event) {\r\nedge_port->lsr_event = 0;\r\ndev_dbg(dev, "%s ===== Port %u LSR Status = %02x, Data = %02x ======\n",\r\n__func__, port_number, edge_port->lsr_mask, *data);\r\nhandle_new_lsr(edge_port, 1, edge_port->lsr_mask, *data);\r\n--urb->actual_length;\r\n++data;\r\n}\r\nif (urb->actual_length) {\r\nusb_serial_debug_data(dev, __func__, urb->actual_length, data);\r\nif (edge_port->close_pending)\r\ndev_dbg(dev, "%s - close pending, dropping data on the floor\n",\r\n__func__);\r\nelse\r\nedge_tty_recv(edge_port->port, data,\r\nurb->actual_length);\r\nedge_port->port->icount.rx += urb->actual_length;\r\n}\r\nexit:\r\nspin_lock(&edge_port->ep_lock);\r\nif (edge_port->ep_read_urb_state == EDGE_READ_URB_RUNNING)\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nelse if (edge_port->ep_read_urb_state == EDGE_READ_URB_STOPPING)\r\nedge_port->ep_read_urb_state = EDGE_READ_URB_STOPPED;\r\nspin_unlock(&edge_port->ep_lock);\r\nif (retval)\r\ndev_err(dev, "%s - usb_submit_urb failed with result %d\n", __func__, retval);\r\n}\r\nstatic void edge_tty_recv(struct usb_serial_port *port, unsigned char *data,\r\nint length)\r\n{\r\nint queued;\r\nqueued = tty_insert_flip_string(&port->port, data, length);\r\nif (queued < length)\r\ndev_err(&port->dev, "%s - dropping data, %d bytes lost\n",\r\n__func__, length - queued);\r\ntty_flip_buffer_push(&port->port);\r\n}\r\nstatic void edge_bulk_out_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nint status = urb->status;\r\nstruct tty_struct *tty;\r\nedge_port->ep_write_urb_in_use = 0;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&urb->dev->dev, "%s - urb shutting down with status: %d\n",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndev_err_console(port, "%s - nonzero write bulk status "\r\n"received: %d\n", __func__, status);\r\n}\r\ntty = tty_port_tty_get(&port->port);\r\nedge_send(port, tty);\r\ntty_kref_put(tty);\r\n}\r\nstatic int edge_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nstruct edgeport_serial *edge_serial;\r\nstruct usb_device *dev;\r\nstruct urb *urb;\r\nint port_number;\r\nint status;\r\nu16 open_settings;\r\nu8 transaction_timeout;\r\nif (edge_port == NULL)\r\nreturn -ENODEV;\r\nport_number = port->port_number;\r\ndev = port->serial->dev;\r\nstatus = ti_do_config(edge_port, UMPC_SET_CLR_LOOPBACK, 0);\r\nif (status) {\r\ndev_err(&port->dev,\r\n"%s - cannot send clear loopback command, %d\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\nif (tty)\r\nedge_set_termios(tty, port, &tty->termios);\r\ntransaction_timeout = 2;\r\nedge_port->ump_read_timeout =\r\nmax(20, ((transaction_timeout * 3) / 2));\r\nopen_settings = (u8)(UMP_DMA_MODE_CONTINOUS |\r\nUMP_PIPE_TRANS_TIMEOUT_ENA |\r\n(transaction_timeout << 2));\r\ndev_dbg(&port->dev, "%s - Sending UMPC_OPEN_PORT\n", __func__);\r\nstatus = send_cmd(dev, UMPC_OPEN_PORT,\r\n(u8)(UMPM_UART1_PORT + port_number), open_settings, NULL, 0);\r\nif (status) {\r\ndev_err(&port->dev, "%s - cannot send open command, %d\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\nstatus = send_cmd(dev, UMPC_START_PORT,\r\n(u8)(UMPM_UART1_PORT + port_number), 0, NULL, 0);\r\nif (status) {\r\ndev_err(&port->dev, "%s - cannot send start DMA command, %d\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\nstatus = purge_port(port, UMP_PORT_DIR_OUT | UMP_PORT_DIR_IN);\r\nif (status) {\r\ndev_err(&port->dev,\r\n"%s - cannot send clear buffers command, %d\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\nstatus = ti_vread_sync(dev, UMPC_READ_MSR, 0,\r\n(__u16)(UMPM_UART1_PORT + port_number),\r\n&edge_port->shadow_msr, 1);\r\nif (status) {\r\ndev_err(&port->dev, "%s - cannot send read MSR command, %d\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\ndev_dbg(&port->dev, "ShadowMSR 0x%X\n", edge_port->shadow_msr);\r\nedge_port->shadow_mcr = MCR_RTS | MCR_DTR;\r\ndev_dbg(&port->dev, "ShadowMCR 0x%X\n", edge_port->shadow_mcr);\r\nedge_serial = edge_port->edge_serial;\r\nif (mutex_lock_interruptible(&edge_serial->es_lock))\r\nreturn -ERESTARTSYS;\r\nif (edge_serial->num_ports_open == 0) {\r\nurb = edge_serial->serial->port[0]->interrupt_in_urb;\r\nif (!urb) {\r\ndev_err(&port->dev,\r\n"%s - no interrupt urb present, exiting\n",\r\n__func__);\r\nstatus = -EINVAL;\r\ngoto release_es_lock;\r\n}\r\nurb->context = edge_serial;\r\nstatus = usb_submit_urb(urb, GFP_KERNEL);\r\nif (status) {\r\ndev_err(&port->dev,\r\n"%s - usb_submit_urb failed with value %d\n",\r\n__func__, status);\r\ngoto release_es_lock;\r\n}\r\n}\r\nusb_clear_halt(dev, port->write_urb->pipe);\r\nusb_clear_halt(dev, port->read_urb->pipe);\r\nurb = port->read_urb;\r\nif (!urb) {\r\ndev_err(&port->dev, "%s - no read urb present, exiting\n",\r\n__func__);\r\nstatus = -EINVAL;\r\ngoto unlink_int_urb;\r\n}\r\nedge_port->ep_read_urb_state = EDGE_READ_URB_RUNNING;\r\nurb->context = edge_port;\r\nstatus = usb_submit_urb(urb, GFP_KERNEL);\r\nif (status) {\r\ndev_err(&port->dev,\r\n"%s - read bulk usb_submit_urb failed with value %d\n",\r\n__func__, status);\r\ngoto unlink_int_urb;\r\n}\r\n++edge_serial->num_ports_open;\r\ngoto release_es_lock;\r\nunlink_int_urb:\r\nif (edge_port->edge_serial->num_ports_open == 0)\r\nusb_kill_urb(port->serial->port[0]->interrupt_in_urb);\r\nrelease_es_lock:\r\nmutex_unlock(&edge_serial->es_lock);\r\nreturn status;\r\n}\r\nstatic void edge_close(struct usb_serial_port *port)\r\n{\r\nstruct edgeport_serial *edge_serial;\r\nstruct edgeport_port *edge_port;\r\nstruct usb_serial *serial = port->serial;\r\nunsigned long flags;\r\nint port_number;\r\nedge_serial = usb_get_serial_data(port->serial);\r\nedge_port = usb_get_serial_port_data(port);\r\nif (edge_serial == NULL || edge_port == NULL)\r\nreturn;\r\nedge_port->close_pending = 1;\r\nusb_kill_urb(port->read_urb);\r\nusb_kill_urb(port->write_urb);\r\nedge_port->ep_write_urb_in_use = 0;\r\nspin_lock_irqsave(&edge_port->ep_lock, flags);\r\nkfifo_reset_out(&port->write_fifo);\r\nspin_unlock_irqrestore(&edge_port->ep_lock, flags);\r\ndev_dbg(&port->dev, "%s - send umpc_close_port\n", __func__);\r\nport_number = port->port_number;\r\nsend_cmd(serial->dev, UMPC_CLOSE_PORT,\r\n(__u8)(UMPM_UART1_PORT + port_number), 0, NULL, 0);\r\nmutex_lock(&edge_serial->es_lock);\r\n--edge_port->edge_serial->num_ports_open;\r\nif (edge_port->edge_serial->num_ports_open <= 0) {\r\nusb_kill_urb(port->serial->port[0]->interrupt_in_urb);\r\nedge_port->edge_serial->num_ports_open = 0;\r\n}\r\nmutex_unlock(&edge_serial->es_lock);\r\nedge_port->close_pending = 0;\r\n}\r\nstatic int edge_write(struct tty_struct *tty, struct usb_serial_port *port,\r\nconst unsigned char *data, int count)\r\n{\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nif (count == 0) {\r\ndev_dbg(&port->dev, "%s - write request of 0 bytes\n", __func__);\r\nreturn 0;\r\n}\r\nif (edge_port == NULL)\r\nreturn -ENODEV;\r\nif (edge_port->close_pending == 1)\r\nreturn -ENODEV;\r\ncount = kfifo_in_locked(&port->write_fifo, data, count,\r\n&edge_port->ep_lock);\r\nedge_send(port, tty);\r\nreturn count;\r\n}\r\nstatic void edge_send(struct usb_serial_port *port, struct tty_struct *tty)\r\n{\r\nint count, result;\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&edge_port->ep_lock, flags);\r\nif (edge_port->ep_write_urb_in_use) {\r\nspin_unlock_irqrestore(&edge_port->ep_lock, flags);\r\nreturn;\r\n}\r\ncount = kfifo_out(&port->write_fifo,\r\nport->write_urb->transfer_buffer,\r\nport->bulk_out_size);\r\nif (count == 0) {\r\nspin_unlock_irqrestore(&edge_port->ep_lock, flags);\r\nreturn;\r\n}\r\nedge_port->ep_write_urb_in_use = 1;\r\nspin_unlock_irqrestore(&edge_port->ep_lock, flags);\r\nusb_serial_debug_data(&port->dev, __func__, count, port->write_urb->transfer_buffer);\r\nport->write_urb->transfer_buffer_length = count;\r\nresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\r\nif (result) {\r\ndev_err_console(port,\r\n"%s - failed submitting write urb, error %d\n",\r\n__func__, result);\r\nedge_port->ep_write_urb_in_use = 0;\r\n} else\r\nedge_port->port->icount.tx += count;\r\nif (tty)\r\ntty_wakeup(tty);\r\n}\r\nstatic int edge_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nint room = 0;\r\nunsigned long flags;\r\nif (edge_port == NULL)\r\nreturn 0;\r\nif (edge_port->close_pending == 1)\r\nreturn 0;\r\nspin_lock_irqsave(&edge_port->ep_lock, flags);\r\nroom = kfifo_avail(&port->write_fifo);\r\nspin_unlock_irqrestore(&edge_port->ep_lock, flags);\r\ndev_dbg(&port->dev, "%s - returns %d\n", __func__, room);\r\nreturn room;\r\n}\r\nstatic int edge_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nint chars = 0;\r\nunsigned long flags;\r\nif (edge_port == NULL)\r\nreturn 0;\r\nspin_lock_irqsave(&edge_port->ep_lock, flags);\r\nchars = kfifo_len(&port->write_fifo);\r\nspin_unlock_irqrestore(&edge_port->ep_lock, flags);\r\ndev_dbg(&port->dev, "%s - returns %d\n", __func__, chars);\r\nreturn chars;\r\n}\r\nstatic bool edge_tx_empty(struct usb_serial_port *port)\r\n{\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nint ret;\r\nret = tx_active(edge_port);\r\nif (ret > 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void edge_throttle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nint status;\r\nif (edge_port == NULL)\r\nreturn;\r\nif (I_IXOFF(tty)) {\r\nunsigned char stop_char = STOP_CHAR(tty);\r\nstatus = edge_write(tty, port, &stop_char, 1);\r\nif (status <= 0) {\r\ndev_err(&port->dev, "%s - failed to write stop character, %d\n", __func__, status);\r\n}\r\n}\r\nif (C_CRTSCTS(tty))\r\nstop_read(edge_port);\r\n}\r\nstatic void edge_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nint status;\r\nif (edge_port == NULL)\r\nreturn;\r\nif (I_IXOFF(tty)) {\r\nunsigned char start_char = START_CHAR(tty);\r\nstatus = edge_write(tty, port, &start_char, 1);\r\nif (status <= 0) {\r\ndev_err(&port->dev, "%s - failed to write start character, %d\n", __func__, status);\r\n}\r\n}\r\nif (C_CRTSCTS(tty)) {\r\nstatus = restart_read(edge_port);\r\nif (status)\r\ndev_err(&port->dev,\r\n"%s - read bulk usb_submit_urb failed: %d\n",\r\n__func__, status);\r\n}\r\n}\r\nstatic void stop_read(struct edgeport_port *edge_port)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&edge_port->ep_lock, flags);\r\nif (edge_port->ep_read_urb_state == EDGE_READ_URB_RUNNING)\r\nedge_port->ep_read_urb_state = EDGE_READ_URB_STOPPING;\r\nedge_port->shadow_mcr &= ~MCR_RTS;\r\nspin_unlock_irqrestore(&edge_port->ep_lock, flags);\r\n}\r\nstatic int restart_read(struct edgeport_port *edge_port)\r\n{\r\nstruct urb *urb;\r\nint status = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&edge_port->ep_lock, flags);\r\nif (edge_port->ep_read_urb_state == EDGE_READ_URB_STOPPED) {\r\nurb = edge_port->port->read_urb;\r\nstatus = usb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\nedge_port->ep_read_urb_state = EDGE_READ_URB_RUNNING;\r\nedge_port->shadow_mcr |= MCR_RTS;\r\nspin_unlock_irqrestore(&edge_port->ep_lock, flags);\r\nreturn status;\r\n}\r\nstatic void change_port_settings(struct tty_struct *tty,\r\nstruct edgeport_port *edge_port, struct ktermios *old_termios)\r\n{\r\nstruct device *dev = &edge_port->port->dev;\r\nstruct ump_uart_config *config;\r\nint baud;\r\nunsigned cflag;\r\nint status;\r\nint port_number = edge_port->port->port_number;\r\nconfig = kmalloc (sizeof (*config), GFP_KERNEL);\r\nif (!config) {\r\ntty->termios = *old_termios;\r\nreturn;\r\n}\r\ncflag = tty->termios.c_cflag;\r\nconfig->wFlags = 0;\r\nconfig->wFlags |= UMP_MASK_UART_FLAGS_RECEIVE_MS_INT;\r\nconfig->wFlags |= UMP_MASK_UART_FLAGS_AUTO_START_ON_ERR;\r\nconfig->bUartMode = (__u8)(edge_port->bUartMode);\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nconfig->bDataBits = UMP_UART_CHAR5BITS;\r\ndev_dbg(dev, "%s - data bits = 5\n", __func__);\r\nbreak;\r\ncase CS6:\r\nconfig->bDataBits = UMP_UART_CHAR6BITS;\r\ndev_dbg(dev, "%s - data bits = 6\n", __func__);\r\nbreak;\r\ncase CS7:\r\nconfig->bDataBits = UMP_UART_CHAR7BITS;\r\ndev_dbg(dev, "%s - data bits = 7\n", __func__);\r\nbreak;\r\ndefault:\r\ncase CS8:\r\nconfig->bDataBits = UMP_UART_CHAR8BITS;\r\ndev_dbg(dev, "%s - data bits = 8\n", __func__);\r\nbreak;\r\n}\r\nif (cflag & PARENB) {\r\nif (cflag & PARODD) {\r\nconfig->wFlags |= UMP_MASK_UART_FLAGS_PARITY;\r\nconfig->bParity = UMP_UART_ODDPARITY;\r\ndev_dbg(dev, "%s - parity = odd\n", __func__);\r\n} else {\r\nconfig->wFlags |= UMP_MASK_UART_FLAGS_PARITY;\r\nconfig->bParity = UMP_UART_EVENPARITY;\r\ndev_dbg(dev, "%s - parity = even\n", __func__);\r\n}\r\n} else {\r\nconfig->bParity = UMP_UART_NOPARITY;\r\ndev_dbg(dev, "%s - parity = none\n", __func__);\r\n}\r\nif (cflag & CSTOPB) {\r\nconfig->bStopBits = UMP_UART_STOPBIT2;\r\ndev_dbg(dev, "%s - stop bits = 2\n", __func__);\r\n} else {\r\nconfig->bStopBits = UMP_UART_STOPBIT1;\r\ndev_dbg(dev, "%s - stop bits = 1\n", __func__);\r\n}\r\nif (cflag & CRTSCTS) {\r\nconfig->wFlags |= UMP_MASK_UART_FLAGS_OUT_X_CTS_FLOW;\r\nconfig->wFlags |= UMP_MASK_UART_FLAGS_RTS_FLOW;\r\ndev_dbg(dev, "%s - RTS/CTS is enabled\n", __func__);\r\n} else {\r\ndev_dbg(dev, "%s - RTS/CTS is disabled\n", __func__);\r\ntty->hw_stopped = 0;\r\nrestart_read(edge_port);\r\n}\r\nconfig->cXon = START_CHAR(tty);\r\nconfig->cXoff = STOP_CHAR(tty);\r\nif (I_IXOFF(tty)) {\r\nconfig->wFlags |= UMP_MASK_UART_FLAGS_IN_X;\r\ndev_dbg(dev, "%s - INBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x\n",\r\n__func__, config->cXon, config->cXoff);\r\n} else\r\ndev_dbg(dev, "%s - INBOUND XON/XOFF is disabled\n", __func__);\r\nif (I_IXON(tty)) {\r\nconfig->wFlags |= UMP_MASK_UART_FLAGS_OUT_X;\r\ndev_dbg(dev, "%s - OUTBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x\n",\r\n__func__, config->cXon, config->cXoff);\r\n} else\r\ndev_dbg(dev, "%s - OUTBOUND XON/XOFF is disabled\n", __func__);\r\ntty->termios.c_cflag &= ~CMSPAR;\r\nbaud = tty_get_baud_rate(tty);\r\nif (!baud) {\r\nbaud = 9600;\r\n} else\r\ntty_encode_baud_rate(tty, baud, baud);\r\nedge_port->baud_rate = baud;\r\nconfig->wBaudRate = (__u16)((461550L + baud/2) / baud);\r\ndev_dbg(dev, "%s - baud rate = %d, wBaudRate = %d\n", __func__, baud, config->wBaudRate);\r\ndev_dbg(dev, "wBaudRate: %d\n", (int)(461550L / config->wBaudRate));\r\ndev_dbg(dev, "wFlags: 0x%x\n", config->wFlags);\r\ndev_dbg(dev, "bDataBits: %d\n", config->bDataBits);\r\ndev_dbg(dev, "bParity: %d\n", config->bParity);\r\ndev_dbg(dev, "bStopBits: %d\n", config->bStopBits);\r\ndev_dbg(dev, "cXon: %d\n", config->cXon);\r\ndev_dbg(dev, "cXoff: %d\n", config->cXoff);\r\ndev_dbg(dev, "bUartMode: %d\n", config->bUartMode);\r\ncpu_to_be16s(&config->wFlags);\r\ncpu_to_be16s(&config->wBaudRate);\r\nstatus = send_cmd(edge_port->port->serial->dev, UMPC_SET_CONFIG,\r\n(__u8)(UMPM_UART1_PORT + port_number),\r\n0, (__u8 *)config, sizeof(*config));\r\nif (status)\r\ndev_dbg(dev, "%s - error %d when trying to write config to device\n",\r\n__func__, status);\r\nkfree(config);\r\n}\r\nstatic void edge_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nunsigned int cflag;\r\ncflag = tty->termios.c_cflag;\r\ndev_dbg(&port->dev, "%s - clfag %08x iflag %08x\n", __func__,\r\ntty->termios.c_cflag, tty->termios.c_iflag);\r\ndev_dbg(&port->dev, "%s - old clfag %08x old iflag %08x\n", __func__,\r\nold_termios->c_cflag, old_termios->c_iflag);\r\nif (edge_port == NULL)\r\nreturn;\r\nchange_port_settings(tty, edge_port, old_termios);\r\n}\r\nstatic int edge_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nunsigned int mcr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&edge_port->ep_lock, flags);\r\nmcr = edge_port->shadow_mcr;\r\nif (set & TIOCM_RTS)\r\nmcr |= MCR_RTS;\r\nif (set & TIOCM_DTR)\r\nmcr |= MCR_DTR;\r\nif (set & TIOCM_LOOP)\r\nmcr |= MCR_LOOPBACK;\r\nif (clear & TIOCM_RTS)\r\nmcr &= ~MCR_RTS;\r\nif (clear & TIOCM_DTR)\r\nmcr &= ~MCR_DTR;\r\nif (clear & TIOCM_LOOP)\r\nmcr &= ~MCR_LOOPBACK;\r\nedge_port->shadow_mcr = mcr;\r\nspin_unlock_irqrestore(&edge_port->ep_lock, flags);\r\nrestore_mcr(edge_port, mcr);\r\nreturn 0;\r\n}\r\nstatic int edge_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nunsigned int result = 0;\r\nunsigned int msr;\r\nunsigned int mcr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&edge_port->ep_lock, flags);\r\nmsr = edge_port->shadow_msr;\r\nmcr = edge_port->shadow_mcr;\r\nresult = ((mcr & MCR_DTR) ? TIOCM_DTR: 0)\r\n| ((mcr & MCR_RTS) ? TIOCM_RTS: 0)\r\n| ((msr & EDGEPORT_MSR_CTS) ? TIOCM_CTS: 0)\r\n| ((msr & EDGEPORT_MSR_CD) ? TIOCM_CAR: 0)\r\n| ((msr & EDGEPORT_MSR_RI) ? TIOCM_RI: 0)\r\n| ((msr & EDGEPORT_MSR_DSR) ? TIOCM_DSR: 0);\r\ndev_dbg(&port->dev, "%s -- %x\n", __func__, result);\r\nspin_unlock_irqrestore(&edge_port->ep_lock, flags);\r\nreturn result;\r\n}\r\nstatic int get_serial_info(struct edgeport_port *edge_port,\r\nstruct serial_struct __user *retinfo)\r\n{\r\nstruct serial_struct tmp;\r\nunsigned cwait;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\ncwait = edge_port->port->port.closing_wait;\r\nif (cwait != ASYNC_CLOSING_WAIT_NONE)\r\ncwait = jiffies_to_msecs(cwait) / 10;\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntmp.type = PORT_16550A;\r\ntmp.line = edge_port->port->minor;\r\ntmp.port = edge_port->port->port_number;\r\ntmp.irq = 0;\r\ntmp.flags = ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;\r\ntmp.xmit_fifo_size = edge_port->port->bulk_out_size;\r\ntmp.baud_base = 9600;\r\ntmp.close_delay = 5*HZ;\r\ntmp.closing_wait = cwait;\r\nif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int edge_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\ndev_dbg(&port->dev, "%s - TIOCGSERIAL\n", __func__);\r\nreturn get_serial_info(edge_port,\r\n(struct serial_struct __user *) arg);\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic void edge_break(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nint status;\r\nint bv = 0;\r\nif (break_state == -1)\r\nbv = 1;\r\nstatus = ti_do_config(edge_port, UMPC_SET_CLR_BREAK, bv);\r\nif (status)\r\ndev_dbg(&port->dev, "%s - error %d sending break set/clear command.\n",\r\n__func__, status);\r\n}\r\nstatic int edge_startup(struct usb_serial *serial)\r\n{\r\nstruct edgeport_serial *edge_serial;\r\nint status;\r\nedge_serial = kzalloc(sizeof(struct edgeport_serial), GFP_KERNEL);\r\nif (!edge_serial)\r\nreturn -ENOMEM;\r\nmutex_init(&edge_serial->es_lock);\r\nedge_serial->serial = serial;\r\nusb_set_serial_data(serial, edge_serial);\r\nstatus = download_fw(edge_serial);\r\nif (status) {\r\nkfree(edge_serial);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nstatic void edge_disconnect(struct usb_serial *serial)\r\n{\r\n}\r\nstatic void edge_release(struct usb_serial *serial)\r\n{\r\nkfree(usb_get_serial_data(serial));\r\n}\r\nstatic int edge_port_probe(struct usb_serial_port *port)\r\n{\r\nstruct edgeport_port *edge_port;\r\nint ret;\r\nedge_port = kzalloc(sizeof(*edge_port), GFP_KERNEL);\r\nif (!edge_port)\r\nreturn -ENOMEM;\r\nspin_lock_init(&edge_port->ep_lock);\r\nedge_port->port = port;\r\nedge_port->edge_serial = usb_get_serial_data(port->serial);\r\nedge_port->bUartMode = default_uart_mode;\r\nswitch (port->port_number) {\r\ncase 0:\r\nedge_port->uart_base = UMPMEM_BASE_UART1;\r\nedge_port->dma_address = UMPD_OEDB1_ADDRESS;\r\nbreak;\r\ncase 1:\r\nedge_port->uart_base = UMPMEM_BASE_UART2;\r\nedge_port->dma_address = UMPD_OEDB2_ADDRESS;\r\nbreak;\r\ndefault:\r\ndev_err(&port->dev, "unknown port number\n");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\ndev_dbg(&port->dev,\r\n"%s - port_number = %d, uart_base = %04x, dma_address = %04x\n",\r\n__func__, port->port_number, edge_port->uart_base,\r\nedge_port->dma_address);\r\nusb_set_serial_port_data(port, edge_port);\r\nret = edge_create_sysfs_attrs(port);\r\nif (ret)\r\ngoto err;\r\nport->port.closing_wait = msecs_to_jiffies(closing_wait * 10);\r\nport->port.drain_delay = 1;\r\nreturn 0;\r\nerr:\r\nkfree(edge_port);\r\nreturn ret;\r\n}\r\nstatic int edge_port_remove(struct usb_serial_port *port)\r\n{\r\nstruct edgeport_port *edge_port;\r\nedge_port = usb_get_serial_port_data(port);\r\nedge_remove_sysfs_attrs(port);\r\nkfree(edge_port);\r\nreturn 0;\r\n}\r\nstatic ssize_t uart_mode_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_serial_port *port = to_usb_serial_port(dev);\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nreturn sprintf(buf, "%d\n", edge_port->bUartMode);\r\n}\r\nstatic ssize_t uart_mode_store(struct device *dev,\r\nstruct device_attribute *attr, const char *valbuf, size_t count)\r\n{\r\nstruct usb_serial_port *port = to_usb_serial_port(dev);\r\nstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\r\nunsigned int v = simple_strtoul(valbuf, NULL, 0);\r\ndev_dbg(dev, "%s: setting uart_mode = %d\n", __func__, v);\r\nif (v < 256)\r\nedge_port->bUartMode = v;\r\nelse\r\ndev_err(dev, "%s - uart_mode %d is invalid\n", __func__, v);\r\nreturn count;\r\n}\r\nstatic int edge_create_sysfs_attrs(struct usb_serial_port *port)\r\n{\r\nreturn device_create_file(&port->dev, &dev_attr_uart_mode);\r\n}\r\nstatic int edge_remove_sysfs_attrs(struct usb_serial_port *port)\r\n{\r\ndevice_remove_file(&port->dev, &dev_attr_uart_mode);\r\nreturn 0;\r\n}
