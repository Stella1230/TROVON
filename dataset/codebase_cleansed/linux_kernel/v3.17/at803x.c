static void at803x_context_save(struct phy_device *phydev,\r\nstruct at803x_context *context)\r\n{\r\ncontext->bmcr = phy_read(phydev, MII_BMCR);\r\ncontext->advertise = phy_read(phydev, MII_ADVERTISE);\r\ncontext->control1000 = phy_read(phydev, MII_CTRL1000);\r\ncontext->int_enable = phy_read(phydev, AT803X_INTR_ENABLE);\r\ncontext->smart_speed = phy_read(phydev, AT803X_SMART_SPEED);\r\ncontext->led_control = phy_read(phydev, AT803X_LED_CONTROL);\r\n}\r\nstatic void at803x_context_restore(struct phy_device *phydev,\r\nconst struct at803x_context *context)\r\n{\r\nphy_write(phydev, MII_BMCR, context->bmcr);\r\nphy_write(phydev, MII_ADVERTISE, context->advertise);\r\nphy_write(phydev, MII_CTRL1000, context->control1000);\r\nphy_write(phydev, AT803X_INTR_ENABLE, context->int_enable);\r\nphy_write(phydev, AT803X_SMART_SPEED, context->smart_speed);\r\nphy_write(phydev, AT803X_LED_CONTROL, context->led_control);\r\n}\r\nstatic int at803x_set_wol(struct phy_device *phydev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nstruct net_device *ndev = phydev->attached_dev;\r\nconst u8 *mac;\r\nint ret;\r\nu32 value;\r\nunsigned int i, offsets[] = {\r\nAT803X_LOC_MAC_ADDR_32_47_OFFSET,\r\nAT803X_LOC_MAC_ADDR_16_31_OFFSET,\r\nAT803X_LOC_MAC_ADDR_0_15_OFFSET,\r\n};\r\nif (!ndev)\r\nreturn -ENODEV;\r\nif (wol->wolopts & WAKE_MAGIC) {\r\nmac = (const u8 *) ndev->dev_addr;\r\nif (!is_valid_ether_addr(mac))\r\nreturn -EFAULT;\r\nfor (i = 0; i < 3; i++) {\r\nphy_write(phydev, AT803X_MMD_ACCESS_CONTROL,\r\nAT803X_DEVICE_ADDR);\r\nphy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA,\r\noffsets[i]);\r\nphy_write(phydev, AT803X_MMD_ACCESS_CONTROL,\r\nAT803X_FUNC_DATA);\r\nphy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA,\r\nmac[(i * 2) + 1] | (mac[(i * 2)] << 8));\r\n}\r\nvalue = phy_read(phydev, AT803X_INTR_ENABLE);\r\nvalue |= AT803X_WOL_ENABLE;\r\nret = phy_write(phydev, AT803X_INTR_ENABLE, value);\r\nif (ret)\r\nreturn ret;\r\nvalue = phy_read(phydev, AT803X_INTR_STATUS);\r\n} else {\r\nvalue = phy_read(phydev, AT803X_INTR_ENABLE);\r\nvalue &= (~AT803X_WOL_ENABLE);\r\nret = phy_write(phydev, AT803X_INTR_ENABLE, value);\r\nif (ret)\r\nreturn ret;\r\nvalue = phy_read(phydev, AT803X_INTR_STATUS);\r\n}\r\nreturn ret;\r\n}\r\nstatic void at803x_get_wol(struct phy_device *phydev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nu32 value;\r\nwol->supported = WAKE_MAGIC;\r\nwol->wolopts = 0;\r\nvalue = phy_read(phydev, AT803X_INTR_ENABLE);\r\nif (value & AT803X_WOL_ENABLE)\r\nwol->wolopts |= WAKE_MAGIC;\r\n}\r\nstatic int at803x_suspend(struct phy_device *phydev)\r\n{\r\nint value;\r\nint wol_enabled;\r\nmutex_lock(&phydev->lock);\r\nvalue = phy_read(phydev, AT803X_INTR_ENABLE);\r\nwol_enabled = value & AT803X_WOL_ENABLE;\r\nvalue = phy_read(phydev, MII_BMCR);\r\nif (wol_enabled)\r\nvalue |= BMCR_ISOLATE;\r\nelse\r\nvalue |= BMCR_PDOWN;\r\nphy_write(phydev, MII_BMCR, value);\r\nmutex_unlock(&phydev->lock);\r\nreturn 0;\r\n}\r\nstatic int at803x_resume(struct phy_device *phydev)\r\n{\r\nint value;\r\nmutex_lock(&phydev->lock);\r\nvalue = phy_read(phydev, MII_BMCR);\r\nvalue &= ~(BMCR_PDOWN | BMCR_ISOLATE);\r\nphy_write(phydev, MII_BMCR, value);\r\nmutex_unlock(&phydev->lock);\r\nreturn 0;\r\n}\r\nstatic int at803x_probe(struct phy_device *phydev)\r\n{\r\nstruct device *dev = &phydev->dev;\r\nstruct at803x_priv *priv;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->gpiod_reset = devm_gpiod_get(dev, "reset");\r\nif (IS_ERR(priv->gpiod_reset))\r\npriv->gpiod_reset = NULL;\r\nelse\r\ngpiod_direction_output(priv->gpiod_reset, 1);\r\nphydev->priv = priv;\r\nreturn 0;\r\n}\r\nstatic int at803x_config_init(struct phy_device *phydev)\r\n{\r\nint ret;\r\nret = genphy_config_init(phydev);\r\nif (ret < 0)\r\nreturn ret;\r\nif (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID) {\r\nret = phy_write(phydev, AT803X_DEBUG_ADDR,\r\nAT803X_DEBUG_SYSTEM_MODE_CTRL);\r\nif (ret)\r\nreturn ret;\r\nret = phy_write(phydev, AT803X_DEBUG_DATA,\r\nAT803X_DEBUG_RGMII_TX_CLK_DLY);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int at803x_ack_interrupt(struct phy_device *phydev)\r\n{\r\nint err;\r\nerr = phy_read(phydev, AT803X_INSR);\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic int at803x_config_intr(struct phy_device *phydev)\r\n{\r\nint err;\r\nint value;\r\nvalue = phy_read(phydev, AT803X_INER);\r\nif (phydev->interrupts == PHY_INTERRUPT_ENABLED)\r\nerr = phy_write(phydev, AT803X_INER,\r\nvalue | AT803X_INER_INIT);\r\nelse\r\nerr = phy_write(phydev, AT803X_INER, 0);\r\nreturn err;\r\n}\r\nstatic void at803x_link_change_notify(struct phy_device *phydev)\r\n{\r\nstruct at803x_priv *priv = phydev->priv;\r\nif (phydev->drv->phy_id == ATH8030_PHY_ID) {\r\nif (phydev->state == PHY_NOLINK) {\r\nif (priv->gpiod_reset && !priv->phy_reset) {\r\nstruct at803x_context context;\r\nat803x_context_save(phydev, &context);\r\ngpiod_set_value(priv->gpiod_reset, 0);\r\nmsleep(1);\r\ngpiod_set_value(priv->gpiod_reset, 1);\r\nmsleep(1);\r\nat803x_context_restore(phydev, &context);\r\ndev_dbg(&phydev->dev, "%s(): phy was reset\n",\r\n__func__);\r\npriv->phy_reset = true;\r\n}\r\n} else {\r\npriv->phy_reset = false;\r\n}\r\n}\r\n}\r\nstatic int __init atheros_init(void)\r\n{\r\nreturn phy_drivers_register(at803x_driver,\r\nARRAY_SIZE(at803x_driver));\r\n}\r\nstatic void __exit atheros_exit(void)\r\n{\r\nphy_drivers_unregister(at803x_driver, ARRAY_SIZE(at803x_driver));\r\n}
