static int\r\nname_device(struct snd_bebob *bebob, unsigned int vendor_id)\r\n{\r\nstruct fw_device *fw_dev = fw_parent_device(bebob->unit);\r\nchar vendor[24] = {0};\r\nchar model[32] = {0};\r\nu32 hw_id;\r\nu32 data[2] = {0};\r\nu32 revision;\r\nint err;\r\nerr = fw_csr_string(fw_dev->config_rom + 5, CSR_VENDOR,\r\nvendor, sizeof(vendor));\r\nif (err < 0)\r\ngoto end;\r\nerr = fw_csr_string(bebob->unit->directory, CSR_MODEL,\r\nmodel, sizeof(model));\r\nif (err < 0)\r\ngoto end;\r\nerr = snd_bebob_read_quad(bebob->unit, INFO_OFFSET_HW_MODEL_ID,\r\n&hw_id);\r\nif (err < 0)\r\ngoto end;\r\nerr = snd_bebob_read_quad(bebob->unit, INFO_OFFSET_HW_MODEL_REVISION,\r\n&revision);\r\nif (err < 0)\r\ngoto end;\r\nerr = snd_bebob_read_block(bebob->unit, INFO_OFFSET_GUID,\r\ndata, sizeof(data));\r\nif (err < 0)\r\ngoto end;\r\nstrcpy(bebob->card->driver, "BeBoB");\r\nstrcpy(bebob->card->shortname, model);\r\nstrcpy(bebob->card->mixername, model);\r\nsnprintf(bebob->card->longname, sizeof(bebob->card->longname),\r\n"%s %s (id:%d, rev:%d), GUID %08x%08x at %s, S%d",\r\nvendor, model, hw_id, revision,\r\ndata[0], data[1], dev_name(&bebob->unit->device),\r\n100 << fw_dev->max_speed);\r\nend:\r\nreturn err;\r\n}\r\nstatic void\r\nbebob_card_free(struct snd_card *card)\r\n{\r\nstruct snd_bebob *bebob = card->private_data;\r\nif (bebob->card_index >= 0) {\r\nmutex_lock(&devices_mutex);\r\nclear_bit(bebob->card_index, devices_used);\r\nmutex_unlock(&devices_mutex);\r\n}\r\nmutex_destroy(&bebob->mutex);\r\n}\r\nstatic const struct snd_bebob_spec *\r\nget_saffire_spec(struct fw_unit *unit)\r\n{\r\nchar name[24] = {0};\r\nif (fw_csr_string(unit->directory, CSR_MODEL, name, sizeof(name)) < 0)\r\nreturn NULL;\r\nif (strcmp(name, "SaffireLE") == 0)\r\nreturn &saffire_le_spec;\r\nelse\r\nreturn &saffire_spec;\r\n}\r\nstatic bool\r\ncheck_audiophile_booted(struct fw_unit *unit)\r\n{\r\nchar name[24] = {0};\r\nif (fw_csr_string(unit->directory, CSR_MODEL, name, sizeof(name)) < 0)\r\nreturn false;\r\nreturn strncmp(name, "FW Audiophile Bootloader", 15) != 0;\r\n}\r\nstatic int\r\nbebob_probe(struct fw_unit *unit,\r\nconst struct ieee1394_device_id *entry)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_bebob *bebob;\r\nconst struct snd_bebob_spec *spec;\r\nunsigned int card_index;\r\nint err;\r\nmutex_lock(&devices_mutex);\r\nfor (card_index = 0; card_index < SNDRV_CARDS; card_index++) {\r\nif (!test_bit(card_index, devices_used) && enable[card_index])\r\nbreak;\r\n}\r\nif (card_index >= SNDRV_CARDS) {\r\nerr = -ENOENT;\r\ngoto end;\r\n}\r\nif ((entry->vendor_id == VEN_FOCUSRITE) &&\r\n(entry->model_id == MODEL_FOCUSRITE_SAFFIRE_BOTH))\r\nspec = get_saffire_spec(unit);\r\nelse if ((entry->vendor_id == VEN_MAUDIO1) &&\r\n(entry->model_id == MODEL_MAUDIO_AUDIOPHILE_BOTH) &&\r\n!check_audiophile_booted(unit))\r\nspec = NULL;\r\nelse\r\nspec = (const struct snd_bebob_spec *)entry->driver_data;\r\nif (spec == NULL) {\r\nif ((entry->vendor_id == VEN_MAUDIO1) ||\r\n(entry->vendor_id == VEN_MAUDIO2))\r\nerr = snd_bebob_maudio_load_firmware(unit);\r\nelse\r\nerr = -ENOSYS;\r\ngoto end;\r\n}\r\nerr = snd_card_new(&unit->device, index[card_index], id[card_index],\r\nTHIS_MODULE, sizeof(struct snd_bebob), &card);\r\nif (err < 0)\r\ngoto end;\r\nbebob = card->private_data;\r\nbebob->card_index = card_index;\r\nset_bit(card_index, devices_used);\r\ncard->private_free = bebob_card_free;\r\nbebob->card = card;\r\nbebob->unit = unit;\r\nbebob->spec = spec;\r\nmutex_init(&bebob->mutex);\r\nspin_lock_init(&bebob->lock);\r\ninit_waitqueue_head(&bebob->hwdep_wait);\r\nerr = name_device(bebob, entry->vendor_id);\r\nif (err < 0)\r\ngoto error;\r\nif ((entry->vendor_id == VEN_MAUDIO1) &&\r\n(entry->model_id == MODEL_MAUDIO_FW1814))\r\nerr = snd_bebob_maudio_special_discover(bebob, true);\r\nelse if ((entry->vendor_id == VEN_MAUDIO1) &&\r\n(entry->model_id == MODEL_MAUDIO_PROJECTMIX))\r\nerr = snd_bebob_maudio_special_discover(bebob, false);\r\nelse\r\nerr = snd_bebob_stream_discover(bebob);\r\nif (err < 0)\r\ngoto error;\r\nsnd_bebob_proc_init(bebob);\r\nif ((bebob->midi_input_ports > 0) ||\r\n(bebob->midi_output_ports > 0)) {\r\nerr = snd_bebob_create_midi_devices(bebob);\r\nif (err < 0)\r\ngoto error;\r\n}\r\nerr = snd_bebob_create_pcm_devices(bebob);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_bebob_create_hwdep_device(bebob);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_bebob_stream_init_duplex(bebob);\r\nif (err < 0)\r\ngoto error;\r\nif (!bebob->maudio_special_quirk) {\r\nerr = snd_card_register(card);\r\nif (err < 0) {\r\nsnd_bebob_stream_destroy_duplex(bebob);\r\ngoto error;\r\n}\r\n} else {\r\nbebob->deferred_registration = true;\r\nfw_schedule_bus_reset(fw_parent_device(bebob->unit)->card,\r\nfalse, true);\r\n}\r\ndev_set_drvdata(&unit->device, bebob);\r\nend:\r\nmutex_unlock(&devices_mutex);\r\nreturn err;\r\nerror:\r\nmutex_unlock(&devices_mutex);\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic void\r\nbebob_update(struct fw_unit *unit)\r\n{\r\nstruct snd_bebob *bebob = dev_get_drvdata(&unit->device);\r\nif (bebob == NULL)\r\nreturn;\r\nfcp_bus_reset(bebob->unit);\r\nsnd_bebob_stream_update_duplex(bebob);\r\nif (bebob->deferred_registration) {\r\nif (snd_card_register(bebob->card) < 0) {\r\nsnd_bebob_stream_destroy_duplex(bebob);\r\nsnd_card_free(bebob->card);\r\n}\r\nbebob->deferred_registration = false;\r\n}\r\n}\r\nstatic void bebob_remove(struct fw_unit *unit)\r\n{\r\nstruct snd_bebob *bebob = dev_get_drvdata(&unit->device);\r\nif (bebob == NULL)\r\nreturn;\r\nkfree(bebob->maudio_special_quirk);\r\nsnd_bebob_stream_destroy_duplex(bebob);\r\nsnd_card_disconnect(bebob->card);\r\nsnd_card_free_when_closed(bebob->card);\r\n}\r\nstatic int __init\r\nsnd_bebob_init(void)\r\n{\r\nreturn driver_register(&bebob_driver.driver);\r\n}\r\nstatic void __exit\r\nsnd_bebob_exit(void)\r\n{\r\ndriver_unregister(&bebob_driver.driver);\r\n}
