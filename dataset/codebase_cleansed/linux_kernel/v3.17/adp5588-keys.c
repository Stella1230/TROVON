static int adp5588_read(struct i2c_client *client, u8 reg)\r\n{\r\nint ret = i2c_smbus_read_byte_data(client, reg);\r\nif (ret < 0)\r\ndev_err(&client->dev, "Read Error\n");\r\nreturn ret;\r\n}\r\nstatic int adp5588_write(struct i2c_client *client, u8 reg, u8 val)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, reg, val);\r\n}\r\nstatic int adp5588_gpio_get_value(struct gpio_chip *chip, unsigned off)\r\n{\r\nstruct adp5588_kpad *kpad = container_of(chip, struct adp5588_kpad, gc);\r\nunsigned int bank = ADP5588_BANK(kpad->gpiomap[off]);\r\nunsigned int bit = ADP5588_BIT(kpad->gpiomap[off]);\r\nint val;\r\nmutex_lock(&kpad->gpio_lock);\r\nif (kpad->dir[bank] & bit)\r\nval = kpad->dat_out[bank];\r\nelse\r\nval = adp5588_read(kpad->client, GPIO_DAT_STAT1 + bank);\r\nmutex_unlock(&kpad->gpio_lock);\r\nreturn !!(val & bit);\r\n}\r\nstatic void adp5588_gpio_set_value(struct gpio_chip *chip,\r\nunsigned off, int val)\r\n{\r\nstruct adp5588_kpad *kpad = container_of(chip, struct adp5588_kpad, gc);\r\nunsigned int bank = ADP5588_BANK(kpad->gpiomap[off]);\r\nunsigned int bit = ADP5588_BIT(kpad->gpiomap[off]);\r\nmutex_lock(&kpad->gpio_lock);\r\nif (val)\r\nkpad->dat_out[bank] |= bit;\r\nelse\r\nkpad->dat_out[bank] &= ~bit;\r\nadp5588_write(kpad->client, GPIO_DAT_OUT1 + bank,\r\nkpad->dat_out[bank]);\r\nmutex_unlock(&kpad->gpio_lock);\r\n}\r\nstatic int adp5588_gpio_direction_input(struct gpio_chip *chip, unsigned off)\r\n{\r\nstruct adp5588_kpad *kpad = container_of(chip, struct adp5588_kpad, gc);\r\nunsigned int bank = ADP5588_BANK(kpad->gpiomap[off]);\r\nunsigned int bit = ADP5588_BIT(kpad->gpiomap[off]);\r\nint ret;\r\nmutex_lock(&kpad->gpio_lock);\r\nkpad->dir[bank] &= ~bit;\r\nret = adp5588_write(kpad->client, GPIO_DIR1 + bank, kpad->dir[bank]);\r\nmutex_unlock(&kpad->gpio_lock);\r\nreturn ret;\r\n}\r\nstatic int adp5588_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned off, int val)\r\n{\r\nstruct adp5588_kpad *kpad = container_of(chip, struct adp5588_kpad, gc);\r\nunsigned int bank = ADP5588_BANK(kpad->gpiomap[off]);\r\nunsigned int bit = ADP5588_BIT(kpad->gpiomap[off]);\r\nint ret;\r\nmutex_lock(&kpad->gpio_lock);\r\nkpad->dir[bank] |= bit;\r\nif (val)\r\nkpad->dat_out[bank] |= bit;\r\nelse\r\nkpad->dat_out[bank] &= ~bit;\r\nret = adp5588_write(kpad->client, GPIO_DAT_OUT1 + bank,\r\nkpad->dat_out[bank]);\r\nret |= adp5588_write(kpad->client, GPIO_DIR1 + bank,\r\nkpad->dir[bank]);\r\nmutex_unlock(&kpad->gpio_lock);\r\nreturn ret;\r\n}\r\nstatic int adp5588_build_gpiomap(struct adp5588_kpad *kpad,\r\nconst struct adp5588_kpad_platform_data *pdata)\r\n{\r\nbool pin_used[ADP5588_MAXGPIO];\r\nint n_unused = 0;\r\nint i;\r\nmemset(pin_used, 0, sizeof(pin_used));\r\nfor (i = 0; i < pdata->rows; i++)\r\npin_used[i] = true;\r\nfor (i = 0; i < pdata->cols; i++)\r\npin_used[i + GPI_PIN_COL_BASE - GPI_PIN_BASE] = true;\r\nfor (i = 0; i < kpad->gpimapsize; i++)\r\npin_used[kpad->gpimap[i].pin - GPI_PIN_BASE] = true;\r\nfor (i = 0; i < ADP5588_MAXGPIO; i++)\r\nif (!pin_used[i])\r\nkpad->gpiomap[n_unused++] = i;\r\nreturn n_unused;\r\n}\r\nstatic int adp5588_gpio_add(struct adp5588_kpad *kpad)\r\n{\r\nstruct device *dev = &kpad->client->dev;\r\nconst struct adp5588_kpad_platform_data *pdata = dev_get_platdata(dev);\r\nconst struct adp5588_gpio_platform_data *gpio_data = pdata->gpio_data;\r\nint i, error;\r\nif (!gpio_data)\r\nreturn 0;\r\nkpad->gc.ngpio = adp5588_build_gpiomap(kpad, pdata);\r\nif (kpad->gc.ngpio == 0) {\r\ndev_info(dev, "No unused gpios left to export\n");\r\nreturn 0;\r\n}\r\nkpad->export_gpio = true;\r\nkpad->gc.direction_input = adp5588_gpio_direction_input;\r\nkpad->gc.direction_output = adp5588_gpio_direction_output;\r\nkpad->gc.get = adp5588_gpio_get_value;\r\nkpad->gc.set = adp5588_gpio_set_value;\r\nkpad->gc.can_sleep = 1;\r\nkpad->gc.base = gpio_data->gpio_start;\r\nkpad->gc.label = kpad->client->name;\r\nkpad->gc.owner = THIS_MODULE;\r\nkpad->gc.names = gpio_data->names;\r\nmutex_init(&kpad->gpio_lock);\r\nerror = gpiochip_add(&kpad->gc);\r\nif (error) {\r\ndev_err(dev, "gpiochip_add failed, err: %d\n", error);\r\nreturn error;\r\n}\r\nfor (i = 0; i <= ADP5588_BANK(ADP5588_MAXGPIO); i++) {\r\nkpad->dat_out[i] = adp5588_read(kpad->client,\r\nGPIO_DAT_OUT1 + i);\r\nkpad->dir[i] = adp5588_read(kpad->client, GPIO_DIR1 + i);\r\n}\r\nif (gpio_data->setup) {\r\nerror = gpio_data->setup(kpad->client,\r\nkpad->gc.base, kpad->gc.ngpio,\r\ngpio_data->context);\r\nif (error)\r\ndev_warn(dev, "setup failed, %d\n", error);\r\n}\r\nreturn 0;\r\n}\r\nstatic void adp5588_gpio_remove(struct adp5588_kpad *kpad)\r\n{\r\nstruct device *dev = &kpad->client->dev;\r\nconst struct adp5588_kpad_platform_data *pdata = dev_get_platdata(dev);\r\nconst struct adp5588_gpio_platform_data *gpio_data = pdata->gpio_data;\r\nint error;\r\nif (!kpad->export_gpio)\r\nreturn;\r\nif (gpio_data->teardown) {\r\nerror = gpio_data->teardown(kpad->client,\r\nkpad->gc.base, kpad->gc.ngpio,\r\ngpio_data->context);\r\nif (error)\r\ndev_warn(dev, "teardown failed %d\n", error);\r\n}\r\nerror = gpiochip_remove(&kpad->gc);\r\nif (error)\r\ndev_warn(dev, "gpiochip_remove failed %d\n", error);\r\n}\r\nstatic inline int adp5588_gpio_add(struct adp5588_kpad *kpad)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void adp5588_gpio_remove(struct adp5588_kpad *kpad)\r\n{\r\n}\r\nstatic void adp5588_report_events(struct adp5588_kpad *kpad, int ev_cnt)\r\n{\r\nint i, j;\r\nfor (i = 0; i < ev_cnt; i++) {\r\nint key = adp5588_read(kpad->client, Key_EVENTA + i);\r\nint key_val = key & KEY_EV_MASK;\r\nif (key_val >= GPI_PIN_BASE && key_val <= GPI_PIN_END) {\r\nfor (j = 0; j < kpad->gpimapsize; j++) {\r\nif (key_val == kpad->gpimap[j].pin) {\r\ninput_report_switch(kpad->input,\r\nkpad->gpimap[j].sw_evt,\r\nkey & KEY_EV_PRESSED);\r\nbreak;\r\n}\r\n}\r\n} else {\r\ninput_report_key(kpad->input,\r\nkpad->keycode[key_val - 1],\r\nkey & KEY_EV_PRESSED);\r\n}\r\n}\r\n}\r\nstatic void adp5588_work(struct work_struct *work)\r\n{\r\nstruct adp5588_kpad *kpad = container_of(work,\r\nstruct adp5588_kpad, work.work);\r\nstruct i2c_client *client = kpad->client;\r\nint status, ev_cnt;\r\nstatus = adp5588_read(client, INT_STAT);\r\nif (status & ADP5588_OVR_FLOW_INT)\r\ndev_err(&client->dev, "Event Overflow Error\n");\r\nif (status & ADP5588_KE_INT) {\r\nev_cnt = adp5588_read(client, KEY_LCK_EC_STAT) & ADP5588_KEC;\r\nif (ev_cnt) {\r\nadp5588_report_events(kpad, ev_cnt);\r\ninput_sync(kpad->input);\r\n}\r\n}\r\nadp5588_write(client, INT_STAT, status);\r\n}\r\nstatic irqreturn_t adp5588_irq(int irq, void *handle)\r\n{\r\nstruct adp5588_kpad *kpad = handle;\r\nschedule_delayed_work(&kpad->work, kpad->delay);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int adp5588_setup(struct i2c_client *client)\r\n{\r\nconst struct adp5588_kpad_platform_data *pdata =\r\ndev_get_platdata(&client->dev);\r\nconst struct adp5588_gpio_platform_data *gpio_data = pdata->gpio_data;\r\nint i, ret;\r\nunsigned char evt_mode1 = 0, evt_mode2 = 0, evt_mode3 = 0;\r\nret = adp5588_write(client, KP_GPIO1, KP_SEL(pdata->rows));\r\nret |= adp5588_write(client, KP_GPIO2, KP_SEL(pdata->cols) & 0xFF);\r\nret |= adp5588_write(client, KP_GPIO3, KP_SEL(pdata->cols) >> 8);\r\nif (pdata->en_keylock) {\r\nret |= adp5588_write(client, UNLOCK1, pdata->unlock_key1);\r\nret |= adp5588_write(client, UNLOCK2, pdata->unlock_key2);\r\nret |= adp5588_write(client, KEY_LCK_EC_STAT, ADP5588_K_LCK_EN);\r\n}\r\nfor (i = 0; i < KEYP_MAX_EVENT; i++)\r\nret |= adp5588_read(client, Key_EVENTA);\r\nfor (i = 0; i < pdata->gpimapsize; i++) {\r\nunsigned short pin = pdata->gpimap[i].pin;\r\nif (pin <= GPI_PIN_ROW_END) {\r\nevt_mode1 |= (1 << (pin - GPI_PIN_ROW_BASE));\r\n} else {\r\nevt_mode2 |= ((1 << (pin - GPI_PIN_COL_BASE)) & 0xFF);\r\nevt_mode3 |= ((1 << (pin - GPI_PIN_COL_BASE)) >> 8);\r\n}\r\n}\r\nif (pdata->gpimapsize) {\r\nret |= adp5588_write(client, GPI_EM1, evt_mode1);\r\nret |= adp5588_write(client, GPI_EM2, evt_mode2);\r\nret |= adp5588_write(client, GPI_EM3, evt_mode3);\r\n}\r\nif (gpio_data) {\r\nfor (i = 0; i <= ADP5588_BANK(ADP5588_MAXGPIO); i++) {\r\nint pull_mask = gpio_data->pullup_dis_mask;\r\nret |= adp5588_write(client, GPIO_PULL1 + i,\r\n(pull_mask >> (8 * i)) & 0xFF);\r\n}\r\n}\r\nret |= adp5588_write(client, INT_STAT,\r\nADP5588_CMP2_INT | ADP5588_CMP1_INT |\r\nADP5588_OVR_FLOW_INT | ADP5588_K_LCK_INT |\r\nADP5588_GPI_INT | ADP5588_KE_INT);\r\nret |= adp5588_write(client, CFG, ADP5588_INT_CFG |\r\nADP5588_OVR_FLOW_IEN |\r\nADP5588_KE_IEN);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Write Error\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void adp5588_report_switch_state(struct adp5588_kpad *kpad)\r\n{\r\nint gpi_stat1 = adp5588_read(kpad->client, GPIO_DAT_STAT1);\r\nint gpi_stat2 = adp5588_read(kpad->client, GPIO_DAT_STAT2);\r\nint gpi_stat3 = adp5588_read(kpad->client, GPIO_DAT_STAT3);\r\nint gpi_stat_tmp, pin_loc;\r\nint i;\r\nfor (i = 0; i < kpad->gpimapsize; i++) {\r\nunsigned short pin = kpad->gpimap[i].pin;\r\nif (pin <= GPI_PIN_ROW_END) {\r\ngpi_stat_tmp = gpi_stat1;\r\npin_loc = pin - GPI_PIN_ROW_BASE;\r\n} else if ((pin - GPI_PIN_COL_BASE) < 8) {\r\ngpi_stat_tmp = gpi_stat2;\r\npin_loc = pin - GPI_PIN_COL_BASE;\r\n} else {\r\ngpi_stat_tmp = gpi_stat3;\r\npin_loc = pin - GPI_PIN_COL_BASE - 8;\r\n}\r\nif (gpi_stat_tmp < 0) {\r\ndev_err(&kpad->client->dev,\r\n"Can't read GPIO_DAT_STAT switch %d default to OFF\n",\r\npin);\r\ngpi_stat_tmp = 0;\r\n}\r\ninput_report_switch(kpad->input,\r\nkpad->gpimap[i].sw_evt,\r\n!(gpi_stat_tmp & (1 << pin_loc)));\r\n}\r\ninput_sync(kpad->input);\r\n}\r\nstatic int adp5588_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct adp5588_kpad *kpad;\r\nconst struct adp5588_kpad_platform_data *pdata =\r\ndev_get_platdata(&client->dev);\r\nstruct input_dev *input;\r\nunsigned int revid;\r\nint ret, i;\r\nint error;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(&client->dev, "SMBUS Byte Data not Supported\n");\r\nreturn -EIO;\r\n}\r\nif (!pdata) {\r\ndev_err(&client->dev, "no platform data?\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pdata->rows || !pdata->cols || !pdata->keymap) {\r\ndev_err(&client->dev, "no rows, cols or keymap from pdata\n");\r\nreturn -EINVAL;\r\n}\r\nif (pdata->keymapsize != ADP5588_KEYMAPSIZE) {\r\ndev_err(&client->dev, "invalid keymapsize\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pdata->gpimap && pdata->gpimapsize) {\r\ndev_err(&client->dev, "invalid gpimap from pdata\n");\r\nreturn -EINVAL;\r\n}\r\nif (pdata->gpimapsize > ADP5588_GPIMAPSIZE_MAX) {\r\ndev_err(&client->dev, "invalid gpimapsize\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < pdata->gpimapsize; i++) {\r\nunsigned short pin = pdata->gpimap[i].pin;\r\nif (pin < GPI_PIN_BASE || pin > GPI_PIN_END) {\r\ndev_err(&client->dev, "invalid gpi pin data\n");\r\nreturn -EINVAL;\r\n}\r\nif (pin <= GPI_PIN_ROW_END) {\r\nif (pin - GPI_PIN_ROW_BASE + 1 <= pdata->rows) {\r\ndev_err(&client->dev, "invalid gpi row data\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (pin - GPI_PIN_COL_BASE + 1 <= pdata->cols) {\r\ndev_err(&client->dev, "invalid gpi col data\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nif (!client->irq) {\r\ndev_err(&client->dev, "no IRQ?\n");\r\nreturn -EINVAL;\r\n}\r\nkpad = kzalloc(sizeof(*kpad), GFP_KERNEL);\r\ninput = input_allocate_device();\r\nif (!kpad || !input) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nkpad->client = client;\r\nkpad->input = input;\r\nINIT_DELAYED_WORK(&kpad->work, adp5588_work);\r\nret = adp5588_read(client, DEV_ID);\r\nif (ret < 0) {\r\nerror = ret;\r\ngoto err_free_mem;\r\n}\r\nrevid = (u8) ret & ADP5588_DEVICE_ID_MASK;\r\nif (WA_DELAYED_READOUT_REVID(revid))\r\nkpad->delay = msecs_to_jiffies(30);\r\ninput->name = client->name;\r\ninput->phys = "adp5588-keys/input0";\r\ninput->dev.parent = &client->dev;\r\ninput_set_drvdata(input, kpad);\r\ninput->id.bustype = BUS_I2C;\r\ninput->id.vendor = 0x0001;\r\ninput->id.product = 0x0001;\r\ninput->id.version = revid;\r\ninput->keycodesize = sizeof(kpad->keycode[0]);\r\ninput->keycodemax = pdata->keymapsize;\r\ninput->keycode = kpad->keycode;\r\nmemcpy(kpad->keycode, pdata->keymap,\r\npdata->keymapsize * input->keycodesize);\r\nkpad->gpimap = pdata->gpimap;\r\nkpad->gpimapsize = pdata->gpimapsize;\r\n__set_bit(EV_KEY, input->evbit);\r\nif (pdata->repeat)\r\n__set_bit(EV_REP, input->evbit);\r\nfor (i = 0; i < input->keycodemax; i++)\r\nif (kpad->keycode[i] <= KEY_MAX)\r\n__set_bit(kpad->keycode[i], input->keybit);\r\n__clear_bit(KEY_RESERVED, input->keybit);\r\nif (kpad->gpimapsize)\r\n__set_bit(EV_SW, input->evbit);\r\nfor (i = 0; i < kpad->gpimapsize; i++)\r\n__set_bit(kpad->gpimap[i].sw_evt, input->swbit);\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(&client->dev, "unable to register input device\n");\r\ngoto err_free_mem;\r\n}\r\nerror = request_irq(client->irq, adp5588_irq,\r\nIRQF_TRIGGER_FALLING,\r\nclient->dev.driver->name, kpad);\r\nif (error) {\r\ndev_err(&client->dev, "irq %d busy?\n", client->irq);\r\ngoto err_unreg_dev;\r\n}\r\nerror = adp5588_setup(client);\r\nif (error)\r\ngoto err_free_irq;\r\nif (kpad->gpimapsize)\r\nadp5588_report_switch_state(kpad);\r\nerror = adp5588_gpio_add(kpad);\r\nif (error)\r\ngoto err_free_irq;\r\ndevice_init_wakeup(&client->dev, 1);\r\ni2c_set_clientdata(client, kpad);\r\ndev_info(&client->dev, "Rev.%d keypad, irq %d\n", revid, client->irq);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(client->irq, kpad);\r\nerr_unreg_dev:\r\ninput_unregister_device(input);\r\ninput = NULL;\r\nerr_free_mem:\r\ninput_free_device(input);\r\nkfree(kpad);\r\nreturn error;\r\n}\r\nstatic int adp5588_remove(struct i2c_client *client)\r\n{\r\nstruct adp5588_kpad *kpad = i2c_get_clientdata(client);\r\nadp5588_write(client, CFG, 0);\r\nfree_irq(client->irq, kpad);\r\ncancel_delayed_work_sync(&kpad->work);\r\ninput_unregister_device(kpad->input);\r\nadp5588_gpio_remove(kpad);\r\nkfree(kpad);\r\nreturn 0;\r\n}\r\nstatic int adp5588_suspend(struct device *dev)\r\n{\r\nstruct adp5588_kpad *kpad = dev_get_drvdata(dev);\r\nstruct i2c_client *client = kpad->client;\r\ndisable_irq(client->irq);\r\ncancel_delayed_work_sync(&kpad->work);\r\nif (device_may_wakeup(&client->dev))\r\nenable_irq_wake(client->irq);\r\nreturn 0;\r\n}\r\nstatic int adp5588_resume(struct device *dev)\r\n{\r\nstruct adp5588_kpad *kpad = dev_get_drvdata(dev);\r\nstruct i2c_client *client = kpad->client;\r\nif (device_may_wakeup(&client->dev))\r\ndisable_irq_wake(client->irq);\r\nenable_irq(client->irq);\r\nreturn 0;\r\n}
