static ssize_t ima_show_htable_value(char __user *buf, size_t count,\r\nloff_t *ppos, atomic_long_t *val)\r\n{\r\nchar tmpbuf[TMPBUFLEN];\r\nssize_t len;\r\nlen = scnprintf(tmpbuf, TMPBUFLEN, "%li\n", atomic_long_read(val));\r\nreturn simple_read_from_buffer(buf, count, ppos, tmpbuf, len);\r\n}\r\nstatic ssize_t ima_show_htable_violations(struct file *filp,\r\nchar __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn ima_show_htable_value(buf, count, ppos, &ima_htable.violations);\r\n}\r\nstatic ssize_t ima_show_measurements_count(struct file *filp,\r\nchar __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn ima_show_htable_value(buf, count, ppos, &ima_htable.len);\r\n}\r\nstatic void *ima_measurements_start(struct seq_file *m, loff_t *pos)\r\n{\r\nloff_t l = *pos;\r\nstruct ima_queue_entry *qe;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(qe, &ima_measurements, later) {\r\nif (!l--) {\r\nrcu_read_unlock();\r\nreturn qe;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nstatic void *ima_measurements_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\nstruct ima_queue_entry *qe = v;\r\nrcu_read_lock();\r\nqe = list_entry_rcu(qe->later.next, struct ima_queue_entry, later);\r\nrcu_read_unlock();\r\n(*pos)++;\r\nreturn (&qe->later == &ima_measurements) ? NULL : qe;\r\n}\r\nstatic void ima_measurements_stop(struct seq_file *m, void *v)\r\n{\r\n}\r\nvoid ima_putc(struct seq_file *m, void *data, int datalen)\r\n{\r\nwhile (datalen--)\r\nseq_putc(m, *(char *)data++);\r\n}\r\nstatic int ima_measurements_show(struct seq_file *m, void *v)\r\n{\r\nstruct ima_queue_entry *qe = v;\r\nstruct ima_template_entry *e;\r\nint namelen;\r\nu32 pcr = CONFIG_IMA_MEASURE_PCR_IDX;\r\nbool is_ima_template = false;\r\nint i;\r\ne = qe->entry;\r\nif (e == NULL)\r\nreturn -1;\r\nima_putc(m, &pcr, sizeof(pcr));\r\nima_putc(m, e->digest, TPM_DIGEST_SIZE);\r\nnamelen = strlen(e->template_desc->name);\r\nima_putc(m, &namelen, sizeof(namelen));\r\nima_putc(m, e->template_desc->name, namelen);\r\nif (strcmp(e->template_desc->name, IMA_TEMPLATE_IMA_NAME) == 0)\r\nis_ima_template = true;\r\nif (!is_ima_template)\r\nima_putc(m, &e->template_data_len,\r\nsizeof(e->template_data_len));\r\nfor (i = 0; i < e->template_desc->num_fields; i++) {\r\nenum ima_show_type show = IMA_SHOW_BINARY;\r\nstruct ima_template_field *field = e->template_desc->fields[i];\r\nif (is_ima_template && strcmp(field->field_id, "d") == 0)\r\nshow = IMA_SHOW_BINARY_NO_FIELD_LEN;\r\nif (is_ima_template && strcmp(field->field_id, "n") == 0)\r\nshow = IMA_SHOW_BINARY_OLD_STRING_FMT;\r\nfield->field_show(m, show, &e->template_data[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ima_measurements_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &ima_measurments_seqops);\r\n}\r\nvoid ima_print_digest(struct seq_file *m, u8 *digest, int size)\r\n{\r\nint i;\r\nfor (i = 0; i < size; i++)\r\nseq_printf(m, "%02x", *(digest + i));\r\n}\r\nstatic int ima_ascii_measurements_show(struct seq_file *m, void *v)\r\n{\r\nstruct ima_queue_entry *qe = v;\r\nstruct ima_template_entry *e;\r\nint i;\r\ne = qe->entry;\r\nif (e == NULL)\r\nreturn -1;\r\nseq_printf(m, "%2d ", CONFIG_IMA_MEASURE_PCR_IDX);\r\nima_print_digest(m, e->digest, TPM_DIGEST_SIZE);\r\nseq_printf(m, " %s", e->template_desc->name);\r\nfor (i = 0; i < e->template_desc->num_fields; i++) {\r\nseq_puts(m, " ");\r\nif (e->template_data[i].len == 0)\r\ncontinue;\r\ne->template_desc->fields[i]->field_show(m, IMA_SHOW_ASCII,\r\n&e->template_data[i]);\r\n}\r\nseq_puts(m, "\n");\r\nreturn 0;\r\n}\r\nstatic int ima_ascii_measurements_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &ima_ascii_measurements_seqops);\r\n}\r\nstatic ssize_t ima_write_policy(struct file *file, const char __user *buf,\r\nsize_t datalen, loff_t *ppos)\r\n{\r\nchar *data = NULL;\r\nssize_t result;\r\nif (datalen >= PAGE_SIZE)\r\ndatalen = PAGE_SIZE - 1;\r\nresult = -EINVAL;\r\nif (*ppos != 0)\r\ngoto out;\r\nresult = -ENOMEM;\r\ndata = kmalloc(datalen + 1, GFP_KERNEL);\r\nif (!data)\r\ngoto out;\r\n*(data + datalen) = '\0';\r\nresult = -EFAULT;\r\nif (copy_from_user(data, buf, datalen))\r\ngoto out;\r\nresult = ima_parse_add_rule(data);\r\nout:\r\nif (result < 0)\r\nvalid_policy = 0;\r\nkfree(data);\r\nreturn result;\r\n}\r\nstatic int ima_open_policy(struct inode *inode, struct file *filp)\r\n{\r\nif (!(filp->f_flags & O_WRONLY))\r\nreturn -EACCES;\r\nif (atomic_dec_and_test(&policy_opencount))\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int ima_release_policy(struct inode *inode, struct file *file)\r\n{\r\nif (!valid_policy) {\r\nima_delete_rules();\r\nvalid_policy = 1;\r\natomic_set(&policy_opencount, 1);\r\nreturn 0;\r\n}\r\nima_update_policy();\r\nsecurityfs_remove(ima_policy);\r\nima_policy = NULL;\r\nreturn 0;\r\n}\r\nint __init ima_fs_init(void)\r\n{\r\nima_dir = securityfs_create_dir("ima", NULL);\r\nif (IS_ERR(ima_dir))\r\nreturn -1;\r\nbinary_runtime_measurements =\r\nsecurityfs_create_file("binary_runtime_measurements",\r\nS_IRUSR | S_IRGRP, ima_dir, NULL,\r\n&ima_measurements_ops);\r\nif (IS_ERR(binary_runtime_measurements))\r\ngoto out;\r\nascii_runtime_measurements =\r\nsecurityfs_create_file("ascii_runtime_measurements",\r\nS_IRUSR | S_IRGRP, ima_dir, NULL,\r\n&ima_ascii_measurements_ops);\r\nif (IS_ERR(ascii_runtime_measurements))\r\ngoto out;\r\nruntime_measurements_count =\r\nsecurityfs_create_file("runtime_measurements_count",\r\nS_IRUSR | S_IRGRP, ima_dir, NULL,\r\n&ima_measurements_count_ops);\r\nif (IS_ERR(runtime_measurements_count))\r\ngoto out;\r\nviolations =\r\nsecurityfs_create_file("violations", S_IRUSR | S_IRGRP,\r\nima_dir, NULL, &ima_htable_violations_ops);\r\nif (IS_ERR(violations))\r\ngoto out;\r\nima_policy = securityfs_create_file("policy",\r\nS_IWUSR,\r\nima_dir, NULL,\r\n&ima_measure_policy_ops);\r\nif (IS_ERR(ima_policy))\r\ngoto out;\r\nreturn 0;\r\nout:\r\nsecurityfs_remove(violations);\r\nsecurityfs_remove(runtime_measurements_count);\r\nsecurityfs_remove(ascii_runtime_measurements);\r\nsecurityfs_remove(binary_runtime_measurements);\r\nsecurityfs_remove(ima_dir);\r\nsecurityfs_remove(ima_policy);\r\nreturn -1;\r\n}
