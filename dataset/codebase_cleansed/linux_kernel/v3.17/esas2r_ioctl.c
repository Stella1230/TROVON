static void complete_fm_api_req(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\na->fm_api_command_done = 1;\r\nwake_up_interruptible(&a->fm_api_waiter);\r\n}\r\nstatic u32 get_physaddr_fm_api(struct esas2r_sg_context *sgc, u64 *addr)\r\n{\r\nstruct esas2r_adapter *a = (struct esas2r_adapter *)sgc->adapter;\r\nint offset = sgc->cur_offset - a->save_offset;\r\n(*addr) = a->firmware.phys + offset;\r\nreturn a->firmware.orig_len - offset;\r\n}\r\nstatic u32 get_physaddr_fm_api_header(struct esas2r_sg_context *sgc, u64 *addr)\r\n{\r\nstruct esas2r_adapter *a = (struct esas2r_adapter *)sgc->adapter;\r\nint offset = sgc->cur_offset - a->save_offset;\r\n(*addr) = a->firmware.header_buff_phys + offset;\r\nreturn sizeof(struct esas2r_flash_img) - offset;\r\n}\r\nstatic void do_fm_api(struct esas2r_adapter *a, struct esas2r_flash_img *fi)\r\n{\r\nstruct esas2r_request *rq;\r\nif (down_interruptible(&a->fm_api_semaphore)) {\r\nfi->status = FI_STAT_BUSY;\r\nreturn;\r\n}\r\nrq = esas2r_alloc_request(a);\r\nif (rq == NULL) {\r\nup(&a->fm_api_semaphore);\r\nfi->status = FI_STAT_BUSY;\r\nreturn;\r\n}\r\nif (fi == &a->firmware.header) {\r\na->firmware.header_buff = dma_alloc_coherent(&a->pcid->dev,\r\n(size_t)sizeof(\r\nstruct\r\nesas2r_flash_img),\r\n(dma_addr_t *)&a->\r\nfirmware.\r\nheader_buff_phys,\r\nGFP_KERNEL);\r\nif (a->firmware.header_buff == NULL) {\r\nesas2r_debug("failed to allocate header buffer!");\r\nfi->status = FI_STAT_BUSY;\r\nreturn;\r\n}\r\nmemcpy(a->firmware.header_buff, fi,\r\nsizeof(struct esas2r_flash_img));\r\na->save_offset = a->firmware.header_buff;\r\na->fm_api_sgc.get_phys_addr =\r\n(PGETPHYSADDR)get_physaddr_fm_api_header;\r\n} else {\r\na->save_offset = (u8 *)fi;\r\na->fm_api_sgc.get_phys_addr =\r\n(PGETPHYSADDR)get_physaddr_fm_api;\r\n}\r\nrq->comp_cb = complete_fm_api_req;\r\na->fm_api_command_done = 0;\r\na->fm_api_sgc.cur_offset = a->save_offset;\r\nif (!esas2r_fm_api(a, (struct esas2r_flash_img *)a->save_offset, rq,\r\n&a->fm_api_sgc))\r\ngoto all_done;\r\nwhile (!a->fm_api_command_done)\r\nwait_event_interruptible(a->fm_api_waiter,\r\na->fm_api_command_done);\r\nall_done:\r\nif (fi == &a->firmware.header) {\r\nmemcpy(fi, a->firmware.header_buff,\r\nsizeof(struct esas2r_flash_img));\r\ndma_free_coherent(&a->pcid->dev,\r\n(size_t)sizeof(struct esas2r_flash_img),\r\na->firmware.header_buff,\r\n(dma_addr_t)a->firmware.header_buff_phys);\r\n}\r\nup(&a->fm_api_semaphore);\r\nesas2r_free_request(a, (struct esas2r_request *)rq);\r\nreturn;\r\n}\r\nstatic void complete_nvr_req(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\na->nvram_command_done = 1;\r\nwake_up_interruptible(&a->nvram_waiter);\r\n}\r\nstatic u32 get_physaddr_buffered_ioctl(struct esas2r_sg_context *sgc,\r\nu64 *addr)\r\n{\r\nint offset = (u8 *)sgc->cur_offset - esas2r_buffered_ioctl;\r\n(*addr) = esas2r_buffered_ioctl_addr + offset;\r\nreturn esas2r_buffered_ioctl_size - offset;\r\n}\r\nstatic void complete_buffered_ioctl_req(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\na->buffered_ioctl_done = 1;\r\nwake_up_interruptible(&a->buffered_ioctl_waiter);\r\n}\r\nstatic u8 handle_buffered_ioctl(struct esas2r_buffered_ioctl *bi)\r\n{\r\nstruct esas2r_adapter *a = bi->a;\r\nstruct esas2r_request *rq;\r\nstruct esas2r_sg_context sgc;\r\nu8 result = IOCTL_SUCCESS;\r\nif (down_interruptible(&buffered_ioctl_semaphore))\r\nreturn IOCTL_OUT_OF_RESOURCES;\r\nif (esas2r_buffered_ioctl) {\r\nif (esas2r_buffered_ioctl_size < bi->length) {\r\ndma_free_coherent(&a->pcid->dev,\r\n(size_t)esas2r_buffered_ioctl_size,\r\nesas2r_buffered_ioctl,\r\nesas2r_buffered_ioctl_addr);\r\ngoto allocate_buffer;\r\n}\r\n} else {\r\nallocate_buffer:\r\nesas2r_buffered_ioctl_size = bi->length;\r\nesas2r_buffered_ioctl_pcid = a->pcid;\r\nesas2r_buffered_ioctl = dma_alloc_coherent(&a->pcid->dev,\r\n(size_t)\r\nesas2r_buffered_ioctl_size,\r\n&\r\nesas2r_buffered_ioctl_addr,\r\nGFP_KERNEL);\r\n}\r\nif (!esas2r_buffered_ioctl) {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"could not allocate %d bytes of consistent memory "\r\n"for a buffered ioctl!",\r\nbi->length);\r\nesas2r_debug("buffered ioctl alloc failure");\r\nresult = IOCTL_OUT_OF_RESOURCES;\r\ngoto exit_cleanly;\r\n}\r\nmemcpy(esas2r_buffered_ioctl, bi->ioctl, bi->length);\r\nrq = esas2r_alloc_request(a);\r\nif (rq == NULL) {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"could not allocate an internal request");\r\nresult = IOCTL_OUT_OF_RESOURCES;\r\nesas2r_debug("buffered ioctl - no requests");\r\ngoto exit_cleanly;\r\n}\r\na->buffered_ioctl_done = 0;\r\nrq->comp_cb = complete_buffered_ioctl_req;\r\nsgc.cur_offset = esas2r_buffered_ioctl + bi->offset;\r\nsgc.get_phys_addr = (PGETPHYSADDR)get_physaddr_buffered_ioctl;\r\nsgc.length = esas2r_buffered_ioctl_size;\r\nif (!(*bi->callback)(a, rq, &sgc, bi->context)) {\r\na->buffered_ioctl_done = 0;\r\ngoto free_andexit_cleanly;\r\n}\r\nwhile (!a->buffered_ioctl_done)\r\nwait_event_interruptible(a->buffered_ioctl_waiter,\r\na->buffered_ioctl_done);\r\nfree_andexit_cleanly:\r\nif (result == IOCTL_SUCCESS && bi->done_callback)\r\n(*bi->done_callback)(a, rq, bi->done_context);\r\nesas2r_free_request(a, rq);\r\nexit_cleanly:\r\nif (result == IOCTL_SUCCESS)\r\nmemcpy(bi->ioctl, esas2r_buffered_ioctl, bi->length);\r\nup(&buffered_ioctl_semaphore);\r\nreturn result;\r\n}\r\nstatic int smp_ioctl_callback(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq,\r\nstruct esas2r_sg_context *sgc, void *context)\r\n{\r\nstruct atto_ioctl_smp *si =\r\n(struct atto_ioctl_smp *)esas2r_buffered_ioctl;\r\nesas2r_sgc_init(sgc, a, rq, rq->vrq->ioctl.sge);\r\nesas2r_build_ioctl_req(a, rq, sgc->length, VDA_IOCTL_SMP);\r\nif (!esas2r_build_sg_list(a, rq, sgc)) {\r\nsi->status = ATTO_STS_OUT_OF_RSRC;\r\nreturn false;\r\n}\r\nesas2r_start_request(a, rq);\r\nreturn true;\r\n}\r\nstatic u8 handle_smp_ioctl(struct esas2r_adapter *a, struct atto_ioctl_smp *si)\r\n{\r\nstruct esas2r_buffered_ioctl bi;\r\nmemset(&bi, 0, sizeof(bi));\r\nbi.a = a;\r\nbi.ioctl = si;\r\nbi.length = sizeof(struct atto_ioctl_smp)\r\n+ le32_to_cpu(si->req_length)\r\n+ le32_to_cpu(si->rsp_length);\r\nbi.offset = 0;\r\nbi.callback = smp_ioctl_callback;\r\nreturn handle_buffered_ioctl(&bi);\r\n}\r\nstatic void esas2r_csmi_ioctl_tunnel_comp_cb(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nrq->target_id = le16_to_cpu(rq->func_rsp.ioctl_rsp.csmi.target_id);\r\nrq->vrq->scsi.flags |= cpu_to_le32(rq->func_rsp.ioctl_rsp.csmi.lun);\r\n(*rq->aux_req_cb)(a, rq);\r\n}\r\nstatic bool csmi_ioctl_tunnel(struct esas2r_adapter *a,\r\nunion atto_ioctl_csmi *ci,\r\nstruct esas2r_request *rq,\r\nstruct esas2r_sg_context *sgc,\r\nu32 ctrl_code,\r\nu16 target_id)\r\n{\r\nstruct atto_vda_ioctl_req *ioctl = &rq->vrq->ioctl;\r\nif (test_bit(AF_DEGRADED_MODE, &a->flags))\r\nreturn false;\r\nesas2r_sgc_init(sgc, a, rq, rq->vrq->ioctl.sge);\r\nesas2r_build_ioctl_req(a, rq, sgc->length, VDA_IOCTL_CSMI);\r\nioctl->csmi.ctrl_code = cpu_to_le32(ctrl_code);\r\nioctl->csmi.target_id = cpu_to_le16(target_id);\r\nioctl->csmi.lun = (u8)le32_to_cpu(rq->vrq->scsi.flags);\r\nrq->aux_req_cx = ci;\r\nrq->aux_req_cb = rq->comp_cb;\r\nrq->comp_cb = esas2r_csmi_ioctl_tunnel_comp_cb;\r\nif (!esas2r_build_sg_list(a, rq, sgc))\r\nreturn false;\r\nesas2r_start_request(a, rq);\r\nreturn true;\r\n}\r\nstatic bool check_lun(struct scsi_lun lun)\r\n{\r\nbool result;\r\nresult = ((lun.scsi_lun[7] == 0) &&\r\n(lun.scsi_lun[6] == 0) &&\r\n(lun.scsi_lun[5] == 0) &&\r\n(lun.scsi_lun[4] == 0) &&\r\n(lun.scsi_lun[3] == 0) &&\r\n(lun.scsi_lun[2] == 0) &&\r\n(lun.scsi_lun[0] == 0));\r\nreturn result;\r\n}\r\nstatic int csmi_ioctl_callback(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq,\r\nstruct esas2r_sg_context *sgc, void *context)\r\n{\r\nstruct atto_csmi *ci = (struct atto_csmi *)context;\r\nunion atto_ioctl_csmi *ioctl_csmi =\r\n(union atto_ioctl_csmi *)esas2r_buffered_ioctl;\r\nu8 path = 0;\r\nu8 tid = 0;\r\nu8 lun = 0;\r\nu32 sts = CSMI_STS_SUCCESS;\r\nstruct esas2r_target *t;\r\nunsigned long flags;\r\nif (ci->control_code == CSMI_CC_GET_DEV_ADDR) {\r\nstruct atto_csmi_get_dev_addr *gda = &ci->data.dev_addr;\r\npath = gda->path_id;\r\ntid = gda->target_id;\r\nlun = gda->lun;\r\n} else if (ci->control_code == CSMI_CC_TASK_MGT) {\r\nstruct atto_csmi_task_mgmt *tm = &ci->data.tsk_mgt;\r\npath = tm->path_id;\r\ntid = tm->target_id;\r\nlun = tm->lun;\r\n}\r\nif (path > 0) {\r\nrq->func_rsp.ioctl_rsp.csmi.csmi_status = cpu_to_le32(\r\nCSMI_STS_INV_PARAM);\r\nreturn false;\r\n}\r\nrq->target_id = tid;\r\nrq->vrq->scsi.flags |= cpu_to_le32(lun);\r\nswitch (ci->control_code) {\r\ncase CSMI_CC_GET_DRVR_INFO:\r\n{\r\nstruct atto_csmi_get_driver_info *gdi = &ioctl_csmi->drvr_info;\r\nstrcpy(gdi->description, esas2r_get_model_name(a));\r\ngdi->csmi_major_rev = CSMI_MAJOR_REV;\r\ngdi->csmi_minor_rev = CSMI_MINOR_REV;\r\nbreak;\r\n}\r\ncase CSMI_CC_GET_CNTLR_CFG:\r\n{\r\nstruct atto_csmi_get_cntlr_cfg *gcc = &ioctl_csmi->cntlr_cfg;\r\ngcc->base_io_addr = 0;\r\npci_read_config_dword(a->pcid, PCI_BASE_ADDRESS_2,\r\n&gcc->base_memaddr_lo);\r\npci_read_config_dword(a->pcid, PCI_BASE_ADDRESS_3,\r\n&gcc->base_memaddr_hi);\r\ngcc->board_id = MAKEDWORD(a->pcid->subsystem_device,\r\na->pcid->subsystem_vendor);\r\ngcc->slot_num = CSMI_SLOT_NUM_UNKNOWN;\r\ngcc->cntlr_class = CSMI_CNTLR_CLASS_HBA;\r\ngcc->io_bus_type = CSMI_BUS_TYPE_PCI;\r\ngcc->pci_addr.bus_num = a->pcid->bus->number;\r\ngcc->pci_addr.device_num = PCI_SLOT(a->pcid->devfn);\r\ngcc->pci_addr.function_num = PCI_FUNC(a->pcid->devfn);\r\nmemset(gcc->serial_num, 0, sizeof(gcc->serial_num));\r\ngcc->major_rev = LOBYTE(LOWORD(a->fw_version));\r\ngcc->minor_rev = HIBYTE(LOWORD(a->fw_version));\r\ngcc->build_rev = LOBYTE(HIWORD(a->fw_version));\r\ngcc->release_rev = HIBYTE(HIWORD(a->fw_version));\r\ngcc->bios_major_rev = HIBYTE(HIWORD(a->flash_ver));\r\ngcc->bios_minor_rev = LOBYTE(HIWORD(a->flash_ver));\r\ngcc->bios_build_rev = LOWORD(a->flash_ver);\r\nif (test_bit(AF2_THUNDERLINK, &a->flags2))\r\ngcc->cntlr_flags = CSMI_CNTLRF_SAS_HBA\r\n| CSMI_CNTLRF_SATA_HBA;\r\nelse\r\ngcc->cntlr_flags = CSMI_CNTLRF_SAS_RAID\r\n| CSMI_CNTLRF_SATA_RAID;\r\ngcc->rrom_major_rev = 0;\r\ngcc->rrom_minor_rev = 0;\r\ngcc->rrom_build_rev = 0;\r\ngcc->rrom_release_rev = 0;\r\ngcc->rrom_biosmajor_rev = 0;\r\ngcc->rrom_biosminor_rev = 0;\r\ngcc->rrom_biosbuild_rev = 0;\r\ngcc->rrom_biosrelease_rev = 0;\r\nbreak;\r\n}\r\ncase CSMI_CC_GET_CNTLR_STS:\r\n{\r\nstruct atto_csmi_get_cntlr_sts *gcs = &ioctl_csmi->cntlr_sts;\r\nif (test_bit(AF_DEGRADED_MODE, &a->flags))\r\ngcs->status = CSMI_CNTLR_STS_FAILED;\r\nelse\r\ngcs->status = CSMI_CNTLR_STS_GOOD;\r\ngcs->offline_reason = CSMI_OFFLINE_NO_REASON;\r\nbreak;\r\n}\r\ncase CSMI_CC_FW_DOWNLOAD:\r\ncase CSMI_CC_GET_RAID_INFO:\r\ncase CSMI_CC_GET_RAID_CFG:\r\nsts = CSMI_STS_BAD_CTRL_CODE;\r\nbreak;\r\ncase CSMI_CC_SMP_PASSTHRU:\r\ncase CSMI_CC_SSP_PASSTHRU:\r\ncase CSMI_CC_STP_PASSTHRU:\r\ncase CSMI_CC_GET_PHY_INFO:\r\ncase CSMI_CC_SET_PHY_INFO:\r\ncase CSMI_CC_GET_LINK_ERRORS:\r\ncase CSMI_CC_GET_SATA_SIG:\r\ncase CSMI_CC_GET_CONN_INFO:\r\ncase CSMI_CC_PHY_CTRL:\r\nif (!csmi_ioctl_tunnel(a, ioctl_csmi, rq, sgc,\r\nci->control_code,\r\nESAS2R_TARG_ID_INV)) {\r\nsts = CSMI_STS_FAILED;\r\nbreak;\r\n}\r\nreturn true;\r\ncase CSMI_CC_GET_SCSI_ADDR:\r\n{\r\nstruct atto_csmi_get_scsi_addr *gsa = &ioctl_csmi->scsi_addr;\r\nstruct scsi_lun lun;\r\nmemcpy(&lun, gsa->sas_lun, sizeof(struct scsi_lun));\r\nif (!check_lun(lun)) {\r\nsts = CSMI_STS_NO_SCSI_ADDR;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&a->mem_lock, flags);\r\nt = esas2r_targ_db_find_by_sas_addr(a, (u64 *)gsa->sas_addr);\r\nspin_unlock_irqrestore(&a->mem_lock, flags);\r\nif (t == NULL) {\r\nsts = CSMI_STS_NO_SCSI_ADDR;\r\nbreak;\r\n}\r\ngsa->host_index = 0xFF;\r\ngsa->lun = gsa->sas_lun[1];\r\nrq->target_id = esas2r_targ_get_id(t, a);\r\nbreak;\r\n}\r\ncase CSMI_CC_GET_DEV_ADDR:\r\n{\r\nstruct atto_csmi_get_dev_addr *gda = &ioctl_csmi->dev_addr;\r\nt = a->targetdb + rq->target_id;\r\nif (t >= a->targetdb_end\r\n|| t->target_state != TS_PRESENT\r\n|| t->sas_addr == 0) {\r\nsts = CSMI_STS_NO_DEV_ADDR;\r\nbreak;\r\n}\r\n*(u64 *)gda->sas_addr = t->sas_addr;\r\nmemset(gda->sas_lun, 0, sizeof(gda->sas_lun));\r\ngda->sas_lun[1] = (u8)le32_to_cpu(rq->vrq->scsi.flags);\r\nbreak;\r\n}\r\ncase CSMI_CC_TASK_MGT:\r\nt = a->targetdb + rq->target_id;\r\nif (t >= a->targetdb_end\r\n|| t->target_state != TS_PRESENT\r\n|| !(t->flags & TF_PASS_THRU)) {\r\nsts = CSMI_STS_NO_DEV_ADDR;\r\nbreak;\r\n}\r\nif (!csmi_ioctl_tunnel(a, ioctl_csmi, rq, sgc,\r\nci->control_code,\r\nt->phys_targ_id)) {\r\nsts = CSMI_STS_FAILED;\r\nbreak;\r\n}\r\nreturn true;\r\ndefault:\r\nsts = CSMI_STS_BAD_CTRL_CODE;\r\nbreak;\r\n}\r\nrq->func_rsp.ioctl_rsp.csmi.csmi_status = cpu_to_le32(sts);\r\nreturn false;\r\n}\r\nstatic void csmi_ioctl_done_callback(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq, void *context)\r\n{\r\nstruct atto_csmi *ci = (struct atto_csmi *)context;\r\nunion atto_ioctl_csmi *ioctl_csmi =\r\n(union atto_ioctl_csmi *)esas2r_buffered_ioctl;\r\nswitch (ci->control_code) {\r\ncase CSMI_CC_GET_DRVR_INFO:\r\n{\r\nstruct atto_csmi_get_driver_info *gdi =\r\n&ioctl_csmi->drvr_info;\r\nstrcpy(gdi->name, ESAS2R_VERSION_STR);\r\ngdi->major_rev = ESAS2R_MAJOR_REV;\r\ngdi->minor_rev = ESAS2R_MINOR_REV;\r\ngdi->build_rev = 0;\r\ngdi->release_rev = 0;\r\nbreak;\r\n}\r\ncase CSMI_CC_GET_SCSI_ADDR:\r\n{\r\nstruct atto_csmi_get_scsi_addr *gsa = &ioctl_csmi->scsi_addr;\r\nif (le32_to_cpu(rq->func_rsp.ioctl_rsp.csmi.csmi_status) ==\r\nCSMI_STS_SUCCESS) {\r\ngsa->target_id = rq->target_id;\r\ngsa->path_id = 0;\r\n}\r\nbreak;\r\n}\r\n}\r\nci->status = le32_to_cpu(rq->func_rsp.ioctl_rsp.csmi.csmi_status);\r\n}\r\nstatic u8 handle_csmi_ioctl(struct esas2r_adapter *a, struct atto_csmi *ci)\r\n{\r\nstruct esas2r_buffered_ioctl bi;\r\nmemset(&bi, 0, sizeof(bi));\r\nbi.a = a;\r\nbi.ioctl = &ci->data;\r\nbi.length = sizeof(union atto_ioctl_csmi);\r\nbi.offset = 0;\r\nbi.callback = csmi_ioctl_callback;\r\nbi.context = ci;\r\nbi.done_callback = csmi_ioctl_done_callback;\r\nbi.done_context = ci;\r\nreturn handle_buffered_ioctl(&bi);\r\n}\r\nstatic bool hba_ioctl_tunnel(struct esas2r_adapter *a,\r\nstruct atto_ioctl *hi,\r\nstruct esas2r_request *rq,\r\nstruct esas2r_sg_context *sgc)\r\n{\r\nesas2r_sgc_init(sgc, a, rq, rq->vrq->ioctl.sge);\r\nesas2r_build_ioctl_req(a, rq, sgc->length, VDA_IOCTL_HBA);\r\nif (!esas2r_build_sg_list(a, rq, sgc)) {\r\nhi->status = ATTO_STS_OUT_OF_RSRC;\r\nreturn false;\r\n}\r\nesas2r_start_request(a, rq);\r\nreturn true;\r\n}\r\nstatic void scsi_passthru_comp_cb(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct atto_ioctl *hi = (struct atto_ioctl *)rq->aux_req_cx;\r\nstruct atto_hba_scsi_pass_thru *spt = &hi->data.scsi_pass_thru;\r\nu8 sts = ATTO_SPT_RS_FAILED;\r\nspt->scsi_status = rq->func_rsp.scsi_rsp.scsi_stat;\r\nspt->sense_length = rq->sense_len;\r\nspt->residual_length =\r\nle32_to_cpu(rq->func_rsp.scsi_rsp.residual_length);\r\nswitch (rq->req_stat) {\r\ncase RS_SUCCESS:\r\ncase RS_SCSI_ERROR:\r\nsts = ATTO_SPT_RS_SUCCESS;\r\nbreak;\r\ncase RS_UNDERRUN:\r\nsts = ATTO_SPT_RS_UNDERRUN;\r\nbreak;\r\ncase RS_OVERRUN:\r\nsts = ATTO_SPT_RS_OVERRUN;\r\nbreak;\r\ncase RS_SEL:\r\ncase RS_SEL2:\r\nsts = ATTO_SPT_RS_NO_DEVICE;\r\nbreak;\r\ncase RS_NO_LUN:\r\nsts = ATTO_SPT_RS_NO_LUN;\r\nbreak;\r\ncase RS_TIMEOUT:\r\nsts = ATTO_SPT_RS_TIMEOUT;\r\nbreak;\r\ncase RS_DEGRADED:\r\nsts = ATTO_SPT_RS_DEGRADED;\r\nbreak;\r\ncase RS_BUSY:\r\nsts = ATTO_SPT_RS_BUSY;\r\nbreak;\r\ncase RS_ABORTED:\r\nsts = ATTO_SPT_RS_ABORTED;\r\nbreak;\r\ncase RS_RESET:\r\nsts = ATTO_SPT_RS_BUS_RESET;\r\nbreak;\r\n}\r\nspt->req_status = sts;\r\nspt->target_id =\r\nesas2r_targ_db_find_next_present(a, (u16)spt->target_id);\r\n(*rq->aux_req_cb)(a, rq);\r\n}\r\nstatic int hba_ioctl_callback(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq,\r\nstruct esas2r_sg_context *sgc,\r\nvoid *context)\r\n{\r\nstruct atto_ioctl *hi = (struct atto_ioctl *)esas2r_buffered_ioctl;\r\nhi->status = ATTO_STS_SUCCESS;\r\nswitch (hi->function) {\r\ncase ATTO_FUNC_GET_ADAP_INFO:\r\n{\r\nu8 *class_code = (u8 *)&a->pcid->class;\r\nstruct atto_hba_get_adapter_info *gai =\r\n&hi->data.get_adap_info;\r\nint pcie_cap_reg;\r\nif (hi->flags & HBAF_TUNNEL) {\r\nhi->status = ATTO_STS_UNSUPPORTED;\r\nbreak;\r\n}\r\nif (hi->version > ATTO_VER_GET_ADAP_INFO0) {\r\nhi->status = ATTO_STS_INV_VERSION;\r\nhi->version = ATTO_VER_GET_ADAP_INFO0;\r\nbreak;\r\n}\r\nmemset(gai, 0, sizeof(*gai));\r\ngai->pci.vendor_id = a->pcid->vendor;\r\ngai->pci.device_id = a->pcid->device;\r\ngai->pci.ss_vendor_id = a->pcid->subsystem_vendor;\r\ngai->pci.ss_device_id = a->pcid->subsystem_device;\r\ngai->pci.class_code[0] = class_code[0];\r\ngai->pci.class_code[1] = class_code[1];\r\ngai->pci.class_code[2] = class_code[2];\r\ngai->pci.rev_id = a->pcid->revision;\r\ngai->pci.bus_num = a->pcid->bus->number;\r\ngai->pci.dev_num = PCI_SLOT(a->pcid->devfn);\r\ngai->pci.func_num = PCI_FUNC(a->pcid->devfn);\r\npcie_cap_reg = pci_find_capability(a->pcid, PCI_CAP_ID_EXP);\r\nif (pcie_cap_reg) {\r\nu16 stat;\r\nu32 caps;\r\npci_read_config_word(a->pcid,\r\npcie_cap_reg + PCI_EXP_LNKSTA,\r\n&stat);\r\npci_read_config_dword(a->pcid,\r\npcie_cap_reg + PCI_EXP_LNKCAP,\r\n&caps);\r\ngai->pci.link_speed_curr =\r\n(u8)(stat & PCI_EXP_LNKSTA_CLS);\r\ngai->pci.link_speed_max =\r\n(u8)(caps & PCI_EXP_LNKCAP_SLS);\r\ngai->pci.link_width_curr =\r\n(u8)((stat & PCI_EXP_LNKSTA_NLW)\r\n>> PCI_EXP_LNKSTA_NLW_SHIFT);\r\ngai->pci.link_width_max =\r\n(u8)((caps & PCI_EXP_LNKCAP_MLW)\r\n>> 4);\r\n}\r\ngai->pci.msi_vector_cnt = 1;\r\nif (a->pcid->msix_enabled)\r\ngai->pci.interrupt_mode = ATTO_GAI_PCIIM_MSIX;\r\nelse if (a->pcid->msi_enabled)\r\ngai->pci.interrupt_mode = ATTO_GAI_PCIIM_MSI;\r\nelse\r\ngai->pci.interrupt_mode = ATTO_GAI_PCIIM_LEGACY;\r\ngai->adap_type = ATTO_GAI_AT_ESASRAID2;\r\nif (test_bit(AF2_THUNDERLINK, &a->flags2))\r\ngai->adap_type = ATTO_GAI_AT_TLSASHBA;\r\nif (test_bit(AF_DEGRADED_MODE, &a->flags))\r\ngai->adap_flags |= ATTO_GAI_AF_DEGRADED;\r\ngai->adap_flags |= ATTO_GAI_AF_SPT_SUPP |\r\nATTO_GAI_AF_DEVADDR_SUPP;\r\nif (a->pcid->subsystem_device == ATTO_ESAS_R60F\r\n|| a->pcid->subsystem_device == ATTO_ESAS_R608\r\n|| a->pcid->subsystem_device == ATTO_ESAS_R644\r\n|| a->pcid->subsystem_device == ATTO_TSSC_3808E)\r\ngai->adap_flags |= ATTO_GAI_AF_VIRT_SES;\r\ngai->num_ports = ESAS2R_NUM_PHYS;\r\ngai->num_phys = ESAS2R_NUM_PHYS;\r\nstrcpy(gai->firmware_rev, a->fw_rev);\r\nstrcpy(gai->flash_rev, a->flash_rev);\r\nstrcpy(gai->model_name_short, esas2r_get_model_name_short(a));\r\nstrcpy(gai->model_name, esas2r_get_model_name(a));\r\ngai->num_targets = ESAS2R_MAX_TARGETS;\r\ngai->num_busses = 1;\r\ngai->num_targsper_bus = gai->num_targets;\r\ngai->num_lunsper_targ = 256;\r\nif (a->pcid->subsystem_device == ATTO_ESAS_R6F0\r\n|| a->pcid->subsystem_device == ATTO_ESAS_R60F)\r\ngai->num_connectors = 4;\r\nelse\r\ngai->num_connectors = 2;\r\ngai->adap_flags2 |= ATTO_GAI_AF2_ADAP_CTRL_SUPP;\r\ngai->num_targets_backend = a->num_targets_backend;\r\ngai->tunnel_flags = a->ioctl_tunnel\r\n& (ATTO_GAI_TF_MEM_RW\r\n| ATTO_GAI_TF_TRACE\r\n| ATTO_GAI_TF_SCSI_PASS_THRU\r\n| ATTO_GAI_TF_GET_DEV_ADDR\r\n| ATTO_GAI_TF_PHY_CTRL\r\n| ATTO_GAI_TF_CONN_CTRL\r\n| ATTO_GAI_TF_GET_DEV_INFO);\r\nbreak;\r\n}\r\ncase ATTO_FUNC_GET_ADAP_ADDR:\r\n{\r\nstruct atto_hba_get_adapter_address *gaa =\r\n&hi->data.get_adap_addr;\r\nif (hi->flags & HBAF_TUNNEL) {\r\nhi->status = ATTO_STS_UNSUPPORTED;\r\nbreak;\r\n}\r\nif (hi->version > ATTO_VER_GET_ADAP_ADDR0) {\r\nhi->status = ATTO_STS_INV_VERSION;\r\nhi->version = ATTO_VER_GET_ADAP_ADDR0;\r\n} else if (gaa->addr_type == ATTO_GAA_AT_PORT\r\n|| gaa->addr_type == ATTO_GAA_AT_NODE) {\r\nif (gaa->addr_type == ATTO_GAA_AT_PORT\r\n&& gaa->port_id >= ESAS2R_NUM_PHYS) {\r\nhi->status = ATTO_STS_NOT_APPL;\r\n} else {\r\nmemcpy((u64 *)gaa->address,\r\n&a->nvram->sas_addr[0], sizeof(u64));\r\ngaa->addr_len = sizeof(u64);\r\n}\r\n} else {\r\nhi->status = ATTO_STS_INV_PARAM;\r\n}\r\nbreak;\r\n}\r\ncase ATTO_FUNC_MEM_RW:\r\n{\r\nif (hi->flags & HBAF_TUNNEL) {\r\nif (hba_ioctl_tunnel(a, hi, rq, sgc))\r\nreturn true;\r\nbreak;\r\n}\r\nhi->status = ATTO_STS_UNSUPPORTED;\r\nbreak;\r\n}\r\ncase ATTO_FUNC_TRACE:\r\n{\r\nstruct atto_hba_trace *trc = &hi->data.trace;\r\nif (hi->flags & HBAF_TUNNEL) {\r\nif (hba_ioctl_tunnel(a, hi, rq, sgc))\r\nreturn true;\r\nbreak;\r\n}\r\nif (hi->version > ATTO_VER_TRACE1) {\r\nhi->status = ATTO_STS_INV_VERSION;\r\nhi->version = ATTO_VER_TRACE1;\r\nbreak;\r\n}\r\nif (trc->trace_type == ATTO_TRC_TT_FWCOREDUMP\r\n&& hi->version >= ATTO_VER_TRACE1) {\r\nif (trc->trace_func == ATTO_TRC_TF_UPLOAD) {\r\nu32 len = hi->data_length;\r\nu32 offset = trc->current_offset;\r\nu32 total_len = ESAS2R_FWCOREDUMP_SZ;\r\nif (!test_bit(AF2_COREDUMP_SAVED, &a->flags2))\r\ntotal_len = 0;\r\nif (len > total_len)\r\nlen = total_len;\r\nif (offset >= total_len\r\n|| offset + len > total_len\r\n|| len == 0) {\r\nhi->status = ATTO_STS_INV_PARAM;\r\nbreak;\r\n}\r\nmemcpy(trc + 1,\r\na->fw_coredump_buff + offset,\r\nlen);\r\nhi->data_length = len;\r\n} else if (trc->trace_func == ATTO_TRC_TF_RESET) {\r\nmemset(a->fw_coredump_buff, 0,\r\nESAS2R_FWCOREDUMP_SZ);\r\nclear_bit(AF2_COREDUMP_SAVED, &a->flags2);\r\n} else if (trc->trace_func != ATTO_TRC_TF_GET_INFO) {\r\nhi->status = ATTO_STS_UNSUPPORTED;\r\nbreak;\r\n}\r\ntrc->trace_mask = 0;\r\ntrc->current_offset = 0;\r\ntrc->total_length = ESAS2R_FWCOREDUMP_SZ;\r\nif (!test_bit(AF2_COREDUMP_SAVED, &a->flags2))\r\ntrc->total_length = 0;\r\n} else {\r\nhi->status = ATTO_STS_UNSUPPORTED;\r\n}\r\nbreak;\r\n}\r\ncase ATTO_FUNC_SCSI_PASS_THRU:\r\n{\r\nstruct atto_hba_scsi_pass_thru *spt = &hi->data.scsi_pass_thru;\r\nstruct scsi_lun lun;\r\nmemcpy(&lun, spt->lun, sizeof(struct scsi_lun));\r\nif (hi->flags & HBAF_TUNNEL) {\r\nif (hba_ioctl_tunnel(a, hi, rq, sgc))\r\nreturn true;\r\nbreak;\r\n}\r\nif (hi->version > ATTO_VER_SCSI_PASS_THRU0) {\r\nhi->status = ATTO_STS_INV_VERSION;\r\nhi->version = ATTO_VER_SCSI_PASS_THRU0;\r\nbreak;\r\n}\r\nif (spt->target_id >= ESAS2R_MAX_TARGETS || !check_lun(lun)) {\r\nhi->status = ATTO_STS_INV_PARAM;\r\nbreak;\r\n}\r\nesas2r_sgc_init(sgc, a, rq, NULL);\r\nsgc->length = hi->data_length;\r\nsgc->cur_offset += offsetof(struct atto_ioctl, data.byte)\r\n+ sizeof(struct atto_hba_scsi_pass_thru);\r\nrq->target_id = (u16)spt->target_id;\r\nrq->vrq->scsi.flags |= cpu_to_le32(spt->lun[1]);\r\nmemcpy(rq->vrq->scsi.cdb, spt->cdb, 16);\r\nrq->vrq->scsi.length = cpu_to_le32(hi->data_length);\r\nrq->sense_len = spt->sense_length;\r\nrq->sense_buf = (u8 *)spt->sense_data;\r\nrq->aux_req_cx = hi;\r\nrq->aux_req_cb = rq->comp_cb;\r\nrq->comp_cb = scsi_passthru_comp_cb;\r\nif (spt->flags & ATTO_SPTF_DATA_IN) {\r\nrq->vrq->scsi.flags |= cpu_to_le32(FCP_CMND_RDD);\r\n} else if (spt->flags & ATTO_SPTF_DATA_OUT) {\r\nrq->vrq->scsi.flags |= cpu_to_le32(FCP_CMND_WRD);\r\n} else {\r\nif (sgc->length) {\r\nhi->status = ATTO_STS_INV_PARAM;\r\nbreak;\r\n}\r\n}\r\nif (spt->flags & ATTO_SPTF_ORDERED_Q)\r\nrq->vrq->scsi.flags |=\r\ncpu_to_le32(FCP_CMND_TA_ORDRD_Q);\r\nelse if (spt->flags & ATTO_SPTF_HEAD_OF_Q)\r\nrq->vrq->scsi.flags |= cpu_to_le32(FCP_CMND_TA_HEAD_Q);\r\nif (!esas2r_build_sg_list(a, rq, sgc)) {\r\nhi->status = ATTO_STS_OUT_OF_RSRC;\r\nbreak;\r\n}\r\nesas2r_start_request(a, rq);\r\nreturn true;\r\n}\r\ncase ATTO_FUNC_GET_DEV_ADDR:\r\n{\r\nstruct atto_hba_get_device_address *gda =\r\n&hi->data.get_dev_addr;\r\nstruct esas2r_target *t;\r\nif (hi->flags & HBAF_TUNNEL) {\r\nif (hba_ioctl_tunnel(a, hi, rq, sgc))\r\nreturn true;\r\nbreak;\r\n}\r\nif (hi->version > ATTO_VER_GET_DEV_ADDR0) {\r\nhi->status = ATTO_STS_INV_VERSION;\r\nhi->version = ATTO_VER_GET_DEV_ADDR0;\r\nbreak;\r\n}\r\nif (gda->target_id >= ESAS2R_MAX_TARGETS) {\r\nhi->status = ATTO_STS_INV_PARAM;\r\nbreak;\r\n}\r\nt = a->targetdb + (u16)gda->target_id;\r\nif (t->target_state != TS_PRESENT) {\r\nhi->status = ATTO_STS_FAILED;\r\n} else if (gda->addr_type == ATTO_GDA_AT_PORT) {\r\nif (t->sas_addr == 0) {\r\nhi->status = ATTO_STS_UNSUPPORTED;\r\n} else {\r\n*(u64 *)gda->address = t->sas_addr;\r\ngda->addr_len = sizeof(u64);\r\n}\r\n} else if (gda->addr_type == ATTO_GDA_AT_NODE) {\r\nhi->status = ATTO_STS_NOT_APPL;\r\n} else {\r\nhi->status = ATTO_STS_INV_PARAM;\r\n}\r\ngda->target_id =\r\nesas2r_targ_db_find_next_present(a,\r\n(u16)gda->target_id);\r\nbreak;\r\n}\r\ncase ATTO_FUNC_PHY_CTRL:\r\ncase ATTO_FUNC_CONN_CTRL:\r\n{\r\nif (hba_ioctl_tunnel(a, hi, rq, sgc))\r\nreturn true;\r\nbreak;\r\n}\r\ncase ATTO_FUNC_ADAP_CTRL:\r\n{\r\nstruct atto_hba_adap_ctrl *ac = &hi->data.adap_ctrl;\r\nif (hi->flags & HBAF_TUNNEL) {\r\nhi->status = ATTO_STS_UNSUPPORTED;\r\nbreak;\r\n}\r\nif (hi->version > ATTO_VER_ADAP_CTRL0) {\r\nhi->status = ATTO_STS_INV_VERSION;\r\nhi->version = ATTO_VER_ADAP_CTRL0;\r\nbreak;\r\n}\r\nif (ac->adap_func == ATTO_AC_AF_HARD_RST) {\r\nesas2r_reset_adapter(a);\r\n} else if (ac->adap_func != ATTO_AC_AF_GET_STATE) {\r\nhi->status = ATTO_STS_UNSUPPORTED;\r\nbreak;\r\n}\r\nif (test_bit(AF_CHPRST_NEEDED, &a->flags))\r\nac->adap_state = ATTO_AC_AS_RST_SCHED;\r\nelse if (test_bit(AF_CHPRST_PENDING, &a->flags))\r\nac->adap_state = ATTO_AC_AS_RST_IN_PROG;\r\nelse if (test_bit(AF_DISC_PENDING, &a->flags))\r\nac->adap_state = ATTO_AC_AS_RST_DISC;\r\nelse if (test_bit(AF_DISABLED, &a->flags))\r\nac->adap_state = ATTO_AC_AS_DISABLED;\r\nelse if (test_bit(AF_DEGRADED_MODE, &a->flags))\r\nac->adap_state = ATTO_AC_AS_DEGRADED;\r\nelse\r\nac->adap_state = ATTO_AC_AS_OK;\r\nbreak;\r\n}\r\ncase ATTO_FUNC_GET_DEV_INFO:\r\n{\r\nstruct atto_hba_get_device_info *gdi = &hi->data.get_dev_info;\r\nstruct esas2r_target *t;\r\nif (hi->flags & HBAF_TUNNEL) {\r\nif (hba_ioctl_tunnel(a, hi, rq, sgc))\r\nreturn true;\r\nbreak;\r\n}\r\nif (hi->version > ATTO_VER_GET_DEV_INFO0) {\r\nhi->status = ATTO_STS_INV_VERSION;\r\nhi->version = ATTO_VER_GET_DEV_INFO0;\r\nbreak;\r\n}\r\nif (gdi->target_id >= ESAS2R_MAX_TARGETS) {\r\nhi->status = ATTO_STS_INV_PARAM;\r\nbreak;\r\n}\r\nt = a->targetdb + (u16)gdi->target_id;\r\ngdi->target_id =\r\nesas2r_targ_db_find_next_present(a,\r\n(u16)gdi->target_id);\r\nif (t->target_state != TS_PRESENT) {\r\nhi->status = ATTO_STS_FAILED;\r\nbreak;\r\n}\r\nhi->status = ATTO_STS_UNSUPPORTED;\r\nbreak;\r\n}\r\ndefault:\r\nhi->status = ATTO_STS_INV_FUNC;\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nstatic void hba_ioctl_done_callback(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq, void *context)\r\n{\r\nstruct atto_ioctl *ioctl_hba =\r\n(struct atto_ioctl *)esas2r_buffered_ioctl;\r\nesas2r_debug("hba_ioctl_done_callback %d", a->index);\r\nif (ioctl_hba->function == ATTO_FUNC_GET_ADAP_INFO) {\r\nstruct atto_hba_get_adapter_info *gai =\r\n&ioctl_hba->data.get_adap_info;\r\nesas2r_debug("ATTO_FUNC_GET_ADAP_INFO");\r\ngai->drvr_rev_major = ESAS2R_MAJOR_REV;\r\ngai->drvr_rev_minor = ESAS2R_MINOR_REV;\r\nstrcpy(gai->drvr_rev_ascii, ESAS2R_VERSION_STR);\r\nstrcpy(gai->drvr_name, ESAS2R_DRVR_NAME);\r\ngai->num_busses = 1;\r\ngai->num_targsper_bus = ESAS2R_MAX_ID + 1;\r\ngai->num_lunsper_targ = 1;\r\n}\r\n}\r\nu8 handle_hba_ioctl(struct esas2r_adapter *a,\r\nstruct atto_ioctl *ioctl_hba)\r\n{\r\nstruct esas2r_buffered_ioctl bi;\r\nmemset(&bi, 0, sizeof(bi));\r\nbi.a = a;\r\nbi.ioctl = ioctl_hba;\r\nbi.length = sizeof(struct atto_ioctl) + ioctl_hba->data_length;\r\nbi.callback = hba_ioctl_callback;\r\nbi.context = NULL;\r\nbi.done_callback = hba_ioctl_done_callback;\r\nbi.done_context = NULL;\r\nbi.offset = 0;\r\nreturn handle_buffered_ioctl(&bi);\r\n}\r\nint esas2r_write_params(struct esas2r_adapter *a, struct esas2r_request *rq,\r\nstruct esas2r_sas_nvram *data)\r\n{\r\nint result = 0;\r\na->nvram_command_done = 0;\r\nrq->comp_cb = complete_nvr_req;\r\nif (esas2r_nvram_write(a, rq, data)) {\r\nwhile (!a->nvram_command_done)\r\nwait_event_interruptible(a->nvram_waiter,\r\na->nvram_command_done);\r\n;\r\nif (rq->req_stat == RS_SUCCESS)\r\nresult = 1;\r\n}\r\nreturn result;\r\n}\r\nint esas2r_ioctl_handler(void *hostdata, int cmd, void __user *arg)\r\n{\r\nstruct atto_express_ioctl *ioctl = NULL;\r\nstruct esas2r_adapter *a;\r\nstruct esas2r_request *rq;\r\nu16 code;\r\nint err;\r\nesas2r_log(ESAS2R_LOG_DEBG, "ioctl (%p, %x, %p)", hostdata, cmd, arg);\r\nif ((arg == NULL)\r\n|| (cmd < EXPRESS_IOCTL_MIN)\r\n|| (cmd > EXPRESS_IOCTL_MAX))\r\nreturn -ENOTSUPP;\r\nif (!access_ok(VERIFY_WRITE, arg, sizeof(struct atto_express_ioctl))) {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"ioctl_handler access_ok failed for cmd %d, "\r\n"address %p", cmd,\r\narg);\r\nreturn -EFAULT;\r\n}\r\nioctl = kzalloc(sizeof(struct atto_express_ioctl), GFP_KERNEL);\r\nif (ioctl == NULL) {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"ioctl_handler kzalloc failed for %d bytes",\r\nsizeof(struct atto_express_ioctl));\r\nreturn -ENOMEM;\r\n}\r\nerr = __copy_from_user(ioctl, arg, sizeof(struct atto_express_ioctl));\r\nif (err != 0) {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"copy_from_user didn't copy everything (err %d, cmd %d)",\r\nerr,\r\ncmd);\r\nkfree(ioctl);\r\nreturn -EFAULT;\r\n}\r\nif (memcmp(ioctl->header.signature,\r\nEXPRESS_IOCTL_SIGNATURE,\r\nEXPRESS_IOCTL_SIGNATURE_SIZE) != 0) {\r\nesas2r_log(ESAS2R_LOG_WARN, "invalid signature");\r\nkfree(ioctl);\r\nreturn -ENOTSUPP;\r\n}\r\nioctl->header.return_code = IOCTL_SUCCESS;\r\nerr = 0;\r\nif (cmd == EXPRESS_IOCTL_GET_CHANNELS) {\r\nint i = 0, k = 0;\r\nioctl->data.chanlist.num_channels = 0;\r\nwhile (i < MAX_ADAPTERS) {\r\nif (esas2r_adapters[i]) {\r\nioctl->data.chanlist.num_channels++;\r\nioctl->data.chanlist.channel[k] = i;\r\nk++;\r\n}\r\ni++;\r\n}\r\ngoto ioctl_done;\r\n}\r\nif (ioctl->header.channel == 0xFF) {\r\na = (struct esas2r_adapter *)hostdata;\r\n} else {\r\na = esas2r_adapters[ioctl->header.channel];\r\nif (ioctl->header.channel >= MAX_ADAPTERS || (a == NULL)) {\r\nioctl->header.return_code = IOCTL_BAD_CHANNEL;\r\nesas2r_log(ESAS2R_LOG_WARN, "bad channel value");\r\nkfree(ioctl);\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nswitch (cmd) {\r\ncase EXPRESS_IOCTL_RW_FIRMWARE:\r\nif (ioctl->data.fwrw.img_type == FW_IMG_FM_API) {\r\nerr = esas2r_write_fw(a,\r\n(char *)ioctl->data.fwrw.image,\r\n0,\r\nsizeof(struct\r\natto_express_ioctl));\r\nif (err >= 0) {\r\nerr = esas2r_read_fw(a,\r\n(char *)ioctl->data.fwrw.\r\nimage,\r\n0,\r\nsizeof(struct\r\natto_express_ioctl));\r\n}\r\n} else if (ioctl->data.fwrw.img_type == FW_IMG_FS_API) {\r\nerr = esas2r_write_fs(a,\r\n(char *)ioctl->data.fwrw.image,\r\n0,\r\nsizeof(struct\r\natto_express_ioctl));\r\nif (err >= 0) {\r\nerr = esas2r_read_fs(a,\r\n(char *)ioctl->data.fwrw.\r\nimage,\r\n0,\r\nsizeof(struct\r\natto_express_ioctl));\r\n}\r\n} else {\r\nioctl->header.return_code = IOCTL_BAD_FLASH_IMGTYPE;\r\n}\r\nbreak;\r\ncase EXPRESS_IOCTL_READ_PARAMS:\r\nmemcpy(ioctl->data.prw.data_buffer, a->nvram,\r\nsizeof(struct esas2r_sas_nvram));\r\nioctl->data.prw.code = 1;\r\nbreak;\r\ncase EXPRESS_IOCTL_WRITE_PARAMS:\r\nrq = esas2r_alloc_request(a);\r\nif (rq == NULL) {\r\nup(&a->nvram_semaphore);\r\nioctl->data.prw.code = 0;\r\nbreak;\r\n}\r\ncode = esas2r_write_params(a, rq,\r\n(struct esas2r_sas_nvram *)ioctl->data.prw.data_buffer);\r\nioctl->data.prw.code = code;\r\nesas2r_free_request(a, rq);\r\nbreak;\r\ncase EXPRESS_IOCTL_DEFAULT_PARAMS:\r\nesas2r_nvram_get_defaults(a,\r\n(struct esas2r_sas_nvram *)ioctl->data.prw.data_buffer);\r\nioctl->data.prw.code = 1;\r\nbreak;\r\ncase EXPRESS_IOCTL_CHAN_INFO:\r\nioctl->data.chaninfo.major_rev = ESAS2R_MAJOR_REV;\r\nioctl->data.chaninfo.minor_rev = ESAS2R_MINOR_REV;\r\nioctl->data.chaninfo.IRQ = a->pcid->irq;\r\nioctl->data.chaninfo.device_id = a->pcid->device;\r\nioctl->data.chaninfo.vendor_id = a->pcid->vendor;\r\nioctl->data.chaninfo.ven_dev_id = a->pcid->subsystem_device;\r\nioctl->data.chaninfo.revision_id = a->pcid->revision;\r\nioctl->data.chaninfo.pci_bus = a->pcid->bus->number;\r\nioctl->data.chaninfo.pci_dev_func = a->pcid->devfn;\r\nioctl->data.chaninfo.core_rev = 0;\r\nioctl->data.chaninfo.host_no = a->host->host_no;\r\nioctl->data.chaninfo.hbaapi_rev = 0;\r\nbreak;\r\ncase EXPRESS_IOCTL_SMP:\r\nioctl->header.return_code = handle_smp_ioctl(a,\r\n&ioctl->data.\r\nioctl_smp);\r\nbreak;\r\ncase EXPRESS_CSMI:\r\nioctl->header.return_code =\r\nhandle_csmi_ioctl(a, &ioctl->data.csmi);\r\nbreak;\r\ncase EXPRESS_IOCTL_HBA:\r\nioctl->header.return_code = handle_hba_ioctl(a,\r\n&ioctl->data.\r\nioctl_hba);\r\nbreak;\r\ncase EXPRESS_IOCTL_VDA:\r\nerr = esas2r_write_vda(a,\r\n(char *)&ioctl->data.ioctl_vda,\r\n0,\r\nsizeof(struct atto_ioctl_vda) +\r\nioctl->data.ioctl_vda.data_length);\r\nif (err >= 0) {\r\nerr = esas2r_read_vda(a,\r\n(char *)&ioctl->data.ioctl_vda,\r\n0,\r\nsizeof(struct atto_ioctl_vda) +\r\nioctl->data.ioctl_vda.data_length);\r\n}\r\nbreak;\r\ncase EXPRESS_IOCTL_GET_MOD_INFO:\r\nioctl->data.modinfo.adapter = a;\r\nioctl->data.modinfo.pci_dev = a->pcid;\r\nioctl->data.modinfo.scsi_host = a->host;\r\nioctl->data.modinfo.host_no = a->host->host_no;\r\nbreak;\r\ndefault:\r\nesas2r_debug("esas2r_ioctl invalid cmd %p!", cmd);\r\nioctl->header.return_code = IOCTL_ERR_INVCMD;\r\n}\r\nioctl_done:\r\nif (err < 0) {\r\nesas2r_log(ESAS2R_LOG_WARN, "err %d on ioctl cmd %d", err,\r\ncmd);\r\nswitch (err) {\r\ncase -ENOMEM:\r\ncase -EBUSY:\r\nioctl->header.return_code = IOCTL_OUT_OF_RESOURCES;\r\nbreak;\r\ncase -ENOSYS:\r\ncase -EINVAL:\r\nioctl->header.return_code = IOCTL_INVALID_PARAM;\r\nbreak;\r\n}\r\nioctl->header.return_code = IOCTL_GENERAL_ERROR;\r\n}\r\nerr = __copy_to_user(arg, ioctl, sizeof(struct atto_express_ioctl));\r\nif (err != 0) {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"ioctl_handler copy_to_user didn't copy "\r\n"everything (err %d, cmd %d)", err,\r\ncmd);\r\nkfree(ioctl);\r\nreturn -EFAULT;\r\n}\r\nkfree(ioctl);\r\nreturn 0;\r\n}\r\nint esas2r_ioctl(struct scsi_device *sd, int cmd, void __user *arg)\r\n{\r\nreturn esas2r_ioctl_handler(sd->host->hostdata, cmd, arg);\r\n}\r\nstatic void free_fw_buffers(struct esas2r_adapter *a)\r\n{\r\nif (a->firmware.data) {\r\ndma_free_coherent(&a->pcid->dev,\r\n(size_t)a->firmware.orig_len,\r\na->firmware.data,\r\n(dma_addr_t)a->firmware.phys);\r\na->firmware.data = NULL;\r\n}\r\n}\r\nstatic int allocate_fw_buffers(struct esas2r_adapter *a, u32 length)\r\n{\r\nfree_fw_buffers(a);\r\na->firmware.orig_len = length;\r\na->firmware.data = (u8 *)dma_alloc_coherent(&a->pcid->dev,\r\n(size_t)length,\r\n(dma_addr_t *)&a->firmware.\r\nphys,\r\nGFP_KERNEL);\r\nif (!a->firmware.data) {\r\nesas2r_debug("buffer alloc failed!");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint esas2r_read_fw(struct esas2r_adapter *a, char *buf, long off, int count)\r\n{\r\nesas2r_trace_enter();\r\nif (a->firmware.state == FW_STATUS_ST) {\r\nint size = min_t(int, count, sizeof(a->firmware.header));\r\nesas2r_trace_exit();\r\nmemcpy(buf, &a->firmware.header, size);\r\nesas2r_debug("esas2r_read_fw: STATUS size %d", size);\r\nreturn size;\r\n}\r\nif (a->firmware.state == FW_COMMAND_ST) {\r\nu32 length = a->firmware.header.length;\r\nesas2r_trace_exit();\r\nesas2r_debug("esas2r_read_fw: COMMAND length %d off %d",\r\nlength,\r\noff);\r\nif (off == 0) {\r\nif (a->firmware.header.action == FI_ACT_UP) {\r\nif (!allocate_fw_buffers(a, length))\r\nreturn -ENOMEM;\r\nmemcpy(a->firmware.data,\r\n&a->firmware.header,\r\nsizeof(a->firmware.header));\r\ndo_fm_api(a,\r\n(struct esas2r_flash_img *)a->firmware.data);\r\n} else if (a->firmware.header.action == FI_ACT_UPSZ) {\r\nint size =\r\nmin((int)count,\r\n(int)sizeof(a->firmware.header));\r\ndo_fm_api(a, &a->firmware.header);\r\nmemcpy(buf, &a->firmware.header, size);\r\nesas2r_debug("FI_ACT_UPSZ size %d", size);\r\nreturn size;\r\n} else {\r\nesas2r_debug("invalid action %d",\r\na->firmware.header.action);\r\nreturn -ENOSYS;\r\n}\r\n}\r\nif (count + off > length)\r\ncount = length - off;\r\nif (count < 0)\r\nreturn 0;\r\nif (!a->firmware.data) {\r\nesas2r_debug(\r\n"read: nonzero offset but no buffer available!");\r\nreturn -ENOMEM;\r\n}\r\nesas2r_debug("esas2r_read_fw: off %d count %d length %d ", off,\r\ncount,\r\nlength);\r\nmemcpy(buf, &a->firmware.data[off], count);\r\nif (length <= off + count) {\r\nesas2r_debug("esas2r_read_fw: freeing buffer!");\r\nfree_fw_buffers(a);\r\n}\r\nreturn count;\r\n}\r\nesas2r_trace_exit();\r\nesas2r_debug("esas2r_read_fw: invalid firmware state %d",\r\na->firmware.state);\r\nreturn -EINVAL;\r\n}\r\nint esas2r_write_fw(struct esas2r_adapter *a, const char *buf, long off,\r\nint count)\r\n{\r\nu32 length;\r\nif (off == 0) {\r\nstruct esas2r_flash_img *header =\r\n(struct esas2r_flash_img *)buf;\r\nint min_size = sizeof(struct esas2r_flash_img_v0);\r\na->firmware.state = FW_INVALID_ST;\r\nif (count < 4\r\n|| header->fi_version > FI_VERSION_1) {\r\nesas2r_debug(\r\n"esas2r_write_fw: short header or invalid version");\r\nreturn -EINVAL;\r\n}\r\nif (header->fi_version == FI_VERSION_1)\r\nmin_size = sizeof(struct esas2r_flash_img);\r\nif (count < min_size) {\r\nesas2r_debug("esas2r_write_fw: short header, aborting");\r\nreturn -EINVAL;\r\n}\r\nlength = header->length;\r\nif (length > 1024 * 1024) {\r\nesas2r_debug(\r\n"esas2r_write_fw: hosed, length %d fi_version %d",\r\nlength, header->fi_version);\r\nreturn -EINVAL;\r\n}\r\nif (header->action == FI_ACT_DOWN) {\r\nif (!allocate_fw_buffers(a, length))\r\nreturn -ENOMEM;\r\nmemcpy(&a->firmware.header,\r\nbuf,\r\nsizeof(*header));\r\n} else if (header->action == FI_ACT_UP\r\n|| header->action == FI_ACT_UPSZ) {\r\nmemcpy(&a->firmware.header,\r\nbuf,\r\nsizeof(*header));\r\na->firmware.state = FW_COMMAND_ST;\r\nesas2r_debug(\r\n"esas2r_write_fw: COMMAND, count %d, action %d ",\r\ncount, header->action);\r\nreturn count;\r\n} else {\r\nesas2r_debug("esas2r_write_fw: invalid action %d ",\r\na->firmware.header.action);\r\nreturn -ENOSYS;\r\n}\r\n} else {\r\nlength = a->firmware.header.length;\r\n}\r\nif (off + count > length)\r\ncount = length - off;\r\nif (count > 0) {\r\nesas2r_debug("esas2r_write_fw: off %d count %d length %d", off,\r\ncount,\r\nlength);\r\nif (a->firmware.header.action == FI_ACT_UP)\r\nreturn count;\r\nif (!a->firmware.data) {\r\nesas2r_debug(\r\n"write: nonzero offset but no buffer available!");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(&a->firmware.data[off], buf, count);\r\nif (length == off + count) {\r\ndo_fm_api(a,\r\n(struct esas2r_flash_img *)a->firmware.data);\r\nmemcpy(&a->firmware.header,\r\na->firmware.data,\r\nsizeof(a->firmware.header));\r\na->firmware.state = FW_STATUS_ST;\r\nesas2r_debug("write completed");\r\nfree_fw_buffers(a);\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic void vda_complete_req(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\na->vda_command_done = 1;\r\nwake_up_interruptible(&a->vda_waiter);\r\n}\r\nstatic u32 get_physaddr_vda(struct esas2r_sg_context *sgc, u64 *addr)\r\n{\r\nstruct esas2r_adapter *a = (struct esas2r_adapter *)sgc->adapter;\r\nint offset = (u8 *)sgc->cur_offset - (u8 *)a->vda_buffer;\r\n(*addr) = a->ppvda_buffer + offset;\r\nreturn VDA_MAX_BUFFER_SIZE - offset;\r\n}\r\nint esas2r_read_vda(struct esas2r_adapter *a, char *buf, long off, int count)\r\n{\r\nif (!a->vda_buffer)\r\nreturn -ENOMEM;\r\nif (off == 0) {\r\nstruct esas2r_request *rq;\r\nstruct atto_ioctl_vda *vi =\r\n(struct atto_ioctl_vda *)a->vda_buffer;\r\nstruct esas2r_sg_context sgc;\r\nbool wait_for_completion;\r\nrq = esas2r_alloc_request(a);\r\nif (rq == NULL) {\r\nesas2r_debug("esas2r_read_vda: out of requestss");\r\nreturn -EBUSY;\r\n}\r\nrq->comp_cb = vda_complete_req;\r\nsgc.first_req = rq;\r\nsgc.adapter = a;\r\nsgc.cur_offset = a->vda_buffer + VDA_BUFFER_HEADER_SZ;\r\nsgc.get_phys_addr = (PGETPHYSADDR)get_physaddr_vda;\r\na->vda_command_done = 0;\r\nwait_for_completion =\r\nesas2r_process_vda_ioctl(a, vi, rq, &sgc);\r\nif (wait_for_completion) {\r\nwhile (!a->vda_command_done)\r\nwait_event_interruptible(a->vda_waiter,\r\na->vda_command_done);\r\n}\r\nesas2r_free_request(a, (struct esas2r_request *)rq);\r\n}\r\nif (off > VDA_MAX_BUFFER_SIZE)\r\nreturn 0;\r\nif (count + off > VDA_MAX_BUFFER_SIZE)\r\ncount = VDA_MAX_BUFFER_SIZE - off;\r\nif (count < 0)\r\nreturn 0;\r\nmemcpy(buf, a->vda_buffer + off, count);\r\nreturn count;\r\n}\r\nint esas2r_write_vda(struct esas2r_adapter *a, const char *buf, long off,\r\nint count)\r\n{\r\nif (!a->vda_buffer) {\r\ndma_addr_t dma_addr;\r\na->vda_buffer = (u8 *)dma_alloc_coherent(&a->pcid->dev,\r\n(size_t)\r\nVDA_MAX_BUFFER_SIZE,\r\n&dma_addr,\r\nGFP_KERNEL);\r\na->ppvda_buffer = dma_addr;\r\n}\r\nif (!a->vda_buffer)\r\nreturn -ENOMEM;\r\nif (off > VDA_MAX_BUFFER_SIZE)\r\nreturn 0;\r\nif (count + off > VDA_MAX_BUFFER_SIZE)\r\ncount = VDA_MAX_BUFFER_SIZE - off;\r\nif (count < 1)\r\nreturn 0;\r\nmemcpy(a->vda_buffer + off, buf, count);\r\nreturn count;\r\n}\r\nstatic void fs_api_complete_req(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\na->fs_api_command_done = 1;\r\nwake_up_interruptible(&a->fs_api_waiter);\r\n}\r\nstatic u32 get_physaddr_fs_api(struct esas2r_sg_context *sgc, u64 *addr)\r\n{\r\nstruct esas2r_adapter *a = (struct esas2r_adapter *)sgc->adapter;\r\nstruct esas2r_ioctl_fs *fs =\r\n(struct esas2r_ioctl_fs *)a->fs_api_buffer;\r\nu32 offset = (u8 *)sgc->cur_offset - (u8 *)fs;\r\n(*addr) = a->ppfs_api_buffer + offset;\r\nreturn a->fs_api_buffer_size - offset;\r\n}\r\nint esas2r_read_fs(struct esas2r_adapter *a, char *buf, long off, int count)\r\n{\r\nif (!a->fs_api_buffer)\r\nreturn -ENOMEM;\r\nif (off == 0) {\r\nstruct esas2r_request *rq;\r\nstruct esas2r_sg_context sgc;\r\nstruct esas2r_ioctl_fs *fs =\r\n(struct esas2r_ioctl_fs *)a->fs_api_buffer;\r\nif (down_interruptible(&a->fs_api_semaphore)) {\r\nbusy:\r\nfs->status = ATTO_STS_OUT_OF_RSRC;\r\nreturn -EBUSY;\r\n}\r\nrq = esas2r_alloc_request(a);\r\nif (rq == NULL) {\r\nesas2r_debug("esas2r_read_fs: out of requests");\r\nup(&a->fs_api_semaphore);\r\ngoto busy;\r\n}\r\nrq->comp_cb = fs_api_complete_req;\r\nsgc.cur_offset = fs->data;\r\nsgc.get_phys_addr = (PGETPHYSADDR)get_physaddr_fs_api;\r\na->fs_api_command_done = 0;\r\nif (!esas2r_process_fs_ioctl(a, fs, rq, &sgc)) {\r\nif (fs->status == ATTO_STS_OUT_OF_RSRC)\r\ncount = -EBUSY;\r\ngoto dont_wait;\r\n}\r\nwhile (!a->fs_api_command_done)\r\nwait_event_interruptible(a->fs_api_waiter,\r\na->fs_api_command_done);\r\n;\r\ndont_wait:\r\nup(&a->fs_api_semaphore);\r\nesas2r_free_request(a, (struct esas2r_request *)rq);\r\nif (count < 0)\r\nreturn count;\r\n}\r\nif (off > a->fs_api_buffer_size)\r\nreturn 0;\r\nif (count + off > a->fs_api_buffer_size)\r\ncount = a->fs_api_buffer_size - off;\r\nif (count < 0)\r\nreturn 0;\r\nmemcpy(buf, a->fs_api_buffer + off, count);\r\nreturn count;\r\n}\r\nint esas2r_write_fs(struct esas2r_adapter *a, const char *buf, long off,\r\nint count)\r\n{\r\nif (off == 0) {\r\nstruct esas2r_ioctl_fs *fs = (struct esas2r_ioctl_fs *)buf;\r\nu32 length = fs->command.length + offsetof(\r\nstruct esas2r_ioctl_fs,\r\ndata);\r\nif (fs->command.command == ESAS2R_FS_CMD_BEGINW)\r\nlength = offsetof(struct esas2r_ioctl_fs, data);\r\nif (count < offsetof(struct esas2r_ioctl_fs, data))\r\nreturn -EINVAL;\r\nif (a->fs_api_buffer) {\r\nif (a->fs_api_buffer_size < length) {\r\ndma_free_coherent(&a->pcid->dev,\r\n(size_t)a->fs_api_buffer_size,\r\na->fs_api_buffer,\r\n(dma_addr_t)a->ppfs_api_buffer);\r\ngoto re_allocate_buffer;\r\n}\r\n} else {\r\nre_allocate_buffer:\r\na->fs_api_buffer_size = length;\r\na->fs_api_buffer = (u8 *)dma_alloc_coherent(\r\n&a->pcid->dev,\r\n(size_t)a->fs_api_buffer_size,\r\n(dma_addr_t *)&a->ppfs_api_buffer,\r\nGFP_KERNEL);\r\n}\r\n}\r\nif (!a->fs_api_buffer)\r\nreturn -ENOMEM;\r\nif (off > a->fs_api_buffer_size)\r\nreturn 0;\r\nif (count + off > a->fs_api_buffer_size)\r\ncount = a->fs_api_buffer_size - off;\r\nif (count < 1)\r\nreturn 0;\r\nmemcpy(a->fs_api_buffer + off, buf, count);\r\nreturn count;\r\n}
