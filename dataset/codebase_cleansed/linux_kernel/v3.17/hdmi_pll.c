void hdmi_pll_dump(struct hdmi_pll_data *pll, struct seq_file *s)\r\n{\r\n#define DUMPPLL(r) seq_printf(s, "%-35s %08x\n", #r,\\r\nhdmi_read_reg(pll->base, r))\r\nDUMPPLL(PLLCTRL_PLL_CONTROL);\r\nDUMPPLL(PLLCTRL_PLL_STATUS);\r\nDUMPPLL(PLLCTRL_PLL_GO);\r\nDUMPPLL(PLLCTRL_CFG1);\r\nDUMPPLL(PLLCTRL_CFG2);\r\nDUMPPLL(PLLCTRL_CFG3);\r\nDUMPPLL(PLLCTRL_SSC_CFG1);\r\nDUMPPLL(PLLCTRL_SSC_CFG2);\r\nDUMPPLL(PLLCTRL_CFG4);\r\n}\r\nvoid hdmi_pll_compute(struct hdmi_pll_data *pll, unsigned long clkin, int phy)\r\n{\r\nstruct hdmi_pll_info *pi = &pll->info;\r\nunsigned long refclk;\r\nu32 mf;\r\nclkin /= 10000;\r\npi->regn = HDMI_DEFAULT_REGN;\r\nrefclk = clkin / pi->regn;\r\nif (pll_feat->bound_dcofreq && phy <= 65000)\r\npi->regm2 = 3;\r\nelse\r\npi->regm2 = HDMI_DEFAULT_REGM2;\r\npi->regm = phy * pi->regm2 / refclk;\r\nmf = (phy - pi->regm / pi->regm2 * refclk) * 262144;\r\npi->regmf = pi->regm2 * mf / refclk;\r\npi->dcofreq = phy > 1000 * 100;\r\npi->regsd = ((pi->regm * clkin / 10) / (pi->regn * 250) + 5) / 10;\r\npi->refsel = HDMI_REFSEL_SYSCLK;\r\nDSSDBG("M = %d Mf = %d\n", pi->regm, pi->regmf);\r\nDSSDBG("range = %d sd = %d\n", pi->dcofreq, pi->regsd);\r\n}\r\nstatic int hdmi_pll_config(struct hdmi_pll_data *pll)\r\n{\r\nu32 r;\r\nstruct hdmi_pll_info *fmt = &pll->info;\r\nREG_FLD_MOD(pll->base, PLLCTRL_PLL_CONTROL, 0x0, 0, 0);\r\nr = hdmi_read_reg(pll->base, PLLCTRL_CFG1);\r\nr = FLD_MOD(r, fmt->regm, 20, 9);\r\nr = FLD_MOD(r, fmt->regn - 1, 8, 1);\r\nhdmi_write_reg(pll->base, PLLCTRL_CFG1, r);\r\nr = hdmi_read_reg(pll->base, PLLCTRL_CFG2);\r\nr = FLD_MOD(r, 0x0, 12, 12);\r\nr = FLD_MOD(r, 0x1, 13, 13);\r\nr = FLD_MOD(r, 0x0, 14, 14);\r\nr = FLD_MOD(r, fmt->refsel, 22, 21);\r\nif (fmt->dcofreq) {\r\nREG_FLD_MOD(pll->base, PLLCTRL_CFG3, fmt->regsd, 17, 10);\r\nr = FLD_MOD(r, 0x4, 3, 1);\r\n} else {\r\nr = FLD_MOD(r, 0x2, 3, 1);\r\n}\r\nhdmi_write_reg(pll->base, PLLCTRL_CFG2, r);\r\nr = hdmi_read_reg(pll->base, PLLCTRL_CFG4);\r\nr = FLD_MOD(r, fmt->regm2, 24, 18);\r\nr = FLD_MOD(r, fmt->regmf, 17, 0);\r\nhdmi_write_reg(pll->base, PLLCTRL_CFG4, r);\r\nREG_FLD_MOD(pll->base, PLLCTRL_PLL_GO, 0x1, 0, 0);\r\nif (hdmi_wait_for_bit_change(pll->base, PLLCTRL_PLL_GO,\r\n0, 0, 1) != 1) {\r\nDSSERR("PLL GO bit not set\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nif (hdmi_wait_for_bit_change(pll->base,\r\nPLLCTRL_PLL_STATUS, 1, 1, 1) != 1) {\r\nDSSERR("cannot lock PLL\n");\r\nDSSERR("CFG1 0x%x\n",\r\nhdmi_read_reg(pll->base, PLLCTRL_CFG1));\r\nDSSERR("CFG2 0x%x\n",\r\nhdmi_read_reg(pll->base, PLLCTRL_CFG2));\r\nDSSERR("CFG4 0x%x\n",\r\nhdmi_read_reg(pll->base, PLLCTRL_CFG4));\r\nreturn -ETIMEDOUT;\r\n}\r\nDSSDBG("PLL locked!\n");\r\nreturn 0;\r\n}\r\nstatic int hdmi_pll_reset(struct hdmi_pll_data *pll)\r\n{\r\nREG_FLD_MOD(pll->base, PLLCTRL_PLL_CONTROL, pll_feat->sys_reset, 3, 3);\r\nif (hdmi_wait_for_bit_change(pll->base, PLLCTRL_PLL_STATUS, 0, 0, 1)\r\n!= 1) {\r\nDSSERR("Failed to sysreset PLL\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nint hdmi_pll_enable(struct hdmi_pll_data *pll, struct hdmi_wp_data *wp)\r\n{\r\nu16 r = 0;\r\nr = hdmi_wp_set_pll_pwr(wp, HDMI_PLLPWRCMD_ALLOFF);\r\nif (r)\r\nreturn r;\r\nr = hdmi_wp_set_pll_pwr(wp, HDMI_PLLPWRCMD_BOTHON_ALLCLKS);\r\nif (r)\r\nreturn r;\r\nr = hdmi_pll_reset(pll);\r\nif (r)\r\nreturn r;\r\nr = hdmi_pll_config(pll);\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}\r\nvoid hdmi_pll_disable(struct hdmi_pll_data *pll, struct hdmi_wp_data *wp)\r\n{\r\nhdmi_wp_set_pll_pwr(wp, HDMI_PLLPWRCMD_ALLOFF);\r\n}\r\nstatic int hdmi_pll_init_features(struct platform_device *pdev)\r\n{\r\nstruct hdmi_pll_features *dst;\r\nconst struct hdmi_pll_features *src;\r\ndst = devm_kzalloc(&pdev->dev, sizeof(*dst), GFP_KERNEL);\r\nif (!dst) {\r\ndev_err(&pdev->dev, "Failed to allocate HDMI PHY Features\n");\r\nreturn -ENOMEM;\r\n}\r\nswitch (omapdss_get_version()) {\r\ncase OMAPDSS_VER_OMAP4430_ES1:\r\ncase OMAPDSS_VER_OMAP4430_ES2:\r\ncase OMAPDSS_VER_OMAP4:\r\nsrc = &omap44xx_pll_feats;\r\nbreak;\r\ncase OMAPDSS_VER_OMAP5:\r\nsrc = &omap54xx_pll_feats;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nmemcpy(dst, src, sizeof(*dst));\r\npll_feat = dst;\r\nreturn 0;\r\n}\r\nint hdmi_pll_init(struct platform_device *pdev, struct hdmi_pll_data *pll)\r\n{\r\nint r;\r\nstruct resource *res;\r\nr = hdmi_pll_init_features(pdev);\r\nif (r)\r\nreturn r;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "pll");\r\nif (!res) {\r\nDSSERR("can't get PLL mem resource\n");\r\nreturn -EINVAL;\r\n}\r\npll->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pll->base)) {\r\nDSSERR("can't ioremap PLLCTRL\n");\r\nreturn PTR_ERR(pll->base);\r\n}\r\nreturn 0;\r\n}
