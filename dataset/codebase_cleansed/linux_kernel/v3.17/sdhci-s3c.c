static inline struct sdhci_s3c *to_s3c(struct sdhci_host *host)\r\n{\r\nreturn sdhci_priv(host);\r\n}\r\nstatic unsigned int sdhci_s3c_get_max_clk(struct sdhci_host *host)\r\n{\r\nstruct sdhci_s3c *ourhost = to_s3c(host);\r\nunsigned long rate, max = 0;\r\nint src;\r\nfor (src = 0; src < MAX_BUS_CLK; src++) {\r\nrate = ourhost->clk_rates[src];\r\nif (rate > max)\r\nmax = rate;\r\n}\r\nreturn max;\r\n}\r\nstatic unsigned int sdhci_s3c_consider_clock(struct sdhci_s3c *ourhost,\r\nunsigned int src,\r\nunsigned int wanted)\r\n{\r\nunsigned long rate;\r\nstruct clk *clksrc = ourhost->clk_bus[src];\r\nint shift;\r\nif (IS_ERR(clksrc))\r\nreturn UINT_MAX;\r\nif (ourhost->no_divider) {\r\nrate = clk_round_rate(clksrc, wanted);\r\nreturn wanted - rate;\r\n}\r\nrate = ourhost->clk_rates[src];\r\nfor (shift = 0; shift <= 8; ++shift) {\r\nif ((rate >> shift) <= wanted)\r\nbreak;\r\n}\r\nif (shift > 8) {\r\ndev_dbg(&ourhost->pdev->dev,\r\n"clk %d: rate %ld, min rate %lu > wanted %u\n",\r\nsrc, rate, rate / 256, wanted);\r\nreturn UINT_MAX;\r\n}\r\ndev_dbg(&ourhost->pdev->dev, "clk %d: rate %ld, want %d, got %ld\n",\r\nsrc, rate, wanted, rate >> shift);\r\nreturn wanted - (rate >> shift);\r\n}\r\nstatic void sdhci_s3c_set_clock(struct sdhci_host *host, unsigned int clock)\r\n{\r\nstruct sdhci_s3c *ourhost = to_s3c(host);\r\nunsigned int best = UINT_MAX;\r\nunsigned int delta;\r\nint best_src = 0;\r\nint src;\r\nu32 ctrl;\r\nhost->mmc->actual_clock = 0;\r\nif (clock == 0) {\r\nsdhci_set_clock(host, clock);\r\nreturn;\r\n}\r\nfor (src = 0; src < MAX_BUS_CLK; src++) {\r\ndelta = sdhci_s3c_consider_clock(ourhost, src, clock);\r\nif (delta < best) {\r\nbest = delta;\r\nbest_src = src;\r\n}\r\n}\r\ndev_dbg(&ourhost->pdev->dev,\r\n"selected source %d, clock %d, delta %d\n",\r\nbest_src, clock, best);\r\nif (ourhost->cur_clk != best_src) {\r\nstruct clk *clk = ourhost->clk_bus[best_src];\r\nclk_prepare_enable(clk);\r\nif (ourhost->cur_clk >= 0)\r\nclk_disable_unprepare(\r\nourhost->clk_bus[ourhost->cur_clk]);\r\nourhost->cur_clk = best_src;\r\nhost->max_clk = ourhost->clk_rates[best_src];\r\n}\r\nwritew(0, host->ioaddr + SDHCI_CLOCK_CONTROL);\r\nctrl = readl(host->ioaddr + S3C_SDHCI_CONTROL2);\r\nctrl &= ~S3C_SDHCI_CTRL2_SELBASECLK_MASK;\r\nctrl |= best_src << S3C_SDHCI_CTRL2_SELBASECLK_SHIFT;\r\nwritel(ctrl, host->ioaddr + S3C_SDHCI_CONTROL2);\r\nwritel(S3C64XX_SDHCI_CONTROL4_DRIVE_9mA,\r\nhost->ioaddr + S3C64XX_SDHCI_CONTROL4);\r\nctrl = readl(host->ioaddr + S3C_SDHCI_CONTROL2);\r\nctrl |= (S3C64XX_SDHCI_CTRL2_ENSTAASYNCCLR |\r\nS3C64XX_SDHCI_CTRL2_ENCMDCNFMSK |\r\nS3C_SDHCI_CTRL2_ENFBCLKRX |\r\nS3C_SDHCI_CTRL2_DFCNT_NONE |\r\nS3C_SDHCI_CTRL2_ENCLKOUTHOLD);\r\nwritel(ctrl, host->ioaddr + S3C_SDHCI_CONTROL2);\r\nctrl = (S3C_SDHCI_CTRL3_FCSEL1 | S3C_SDHCI_CTRL3_FCSEL0);\r\nif (clock < 25 * 1000000)\r\nctrl |= (S3C_SDHCI_CTRL3_FCSEL3 | S3C_SDHCI_CTRL3_FCSEL2);\r\nwritel(ctrl, host->ioaddr + S3C_SDHCI_CONTROL3);\r\nsdhci_set_clock(host, clock);\r\n}\r\nstatic unsigned int sdhci_s3c_get_min_clock(struct sdhci_host *host)\r\n{\r\nstruct sdhci_s3c *ourhost = to_s3c(host);\r\nunsigned long rate, min = ULONG_MAX;\r\nint src;\r\nfor (src = 0; src < MAX_BUS_CLK; src++) {\r\nrate = ourhost->clk_rates[src] / 256;\r\nif (!rate)\r\ncontinue;\r\nif (rate < min)\r\nmin = rate;\r\n}\r\nreturn min;\r\n}\r\nstatic unsigned int sdhci_cmu_get_max_clock(struct sdhci_host *host)\r\n{\r\nstruct sdhci_s3c *ourhost = to_s3c(host);\r\nunsigned long rate, max = 0;\r\nint src;\r\nfor (src = 0; src < MAX_BUS_CLK; src++) {\r\nstruct clk *clk;\r\nclk = ourhost->clk_bus[src];\r\nif (IS_ERR(clk))\r\ncontinue;\r\nrate = clk_round_rate(clk, ULONG_MAX);\r\nif (rate > max)\r\nmax = rate;\r\n}\r\nreturn max;\r\n}\r\nstatic unsigned int sdhci_cmu_get_min_clock(struct sdhci_host *host)\r\n{\r\nstruct sdhci_s3c *ourhost = to_s3c(host);\r\nunsigned long rate, min = ULONG_MAX;\r\nint src;\r\nfor (src = 0; src < MAX_BUS_CLK; src++) {\r\nstruct clk *clk;\r\nclk = ourhost->clk_bus[src];\r\nif (IS_ERR(clk))\r\ncontinue;\r\nrate = clk_round_rate(clk, 0);\r\nif (rate < min)\r\nmin = rate;\r\n}\r\nreturn min;\r\n}\r\nstatic void sdhci_cmu_set_clock(struct sdhci_host *host, unsigned int clock)\r\n{\r\nstruct sdhci_s3c *ourhost = to_s3c(host);\r\nstruct device *dev = &ourhost->pdev->dev;\r\nunsigned long timeout;\r\nu16 clk = 0;\r\nhost->mmc->actual_clock = 0;\r\nif (clock == 0) {\r\nsdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);\r\nreturn;\r\n}\r\nsdhci_s3c_set_clock(host, clock);\r\nclk_set_rate(ourhost->clk_bus[ourhost->cur_clk], clock);\r\nclk = SDHCI_CLOCK_INT_EN;\r\nsdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);\r\ntimeout = 20;\r\nwhile (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))\r\n& SDHCI_CLOCK_INT_STABLE)) {\r\nif (timeout == 0) {\r\ndev_err(dev, "%s: Internal clock never stabilised.\n",\r\nmmc_hostname(host->mmc));\r\nreturn;\r\n}\r\ntimeout--;\r\nmdelay(1);\r\n}\r\nclk |= SDHCI_CLOCK_CARD_EN;\r\nsdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);\r\n}\r\nstatic void sdhci_s3c_set_bus_width(struct sdhci_host *host, int width)\r\n{\r\nu8 ctrl;\r\nctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);\r\nswitch (width) {\r\ncase MMC_BUS_WIDTH_8:\r\nctrl |= SDHCI_CTRL_8BITBUS;\r\nctrl &= ~SDHCI_CTRL_4BITBUS;\r\nbreak;\r\ncase MMC_BUS_WIDTH_4:\r\nctrl |= SDHCI_CTRL_4BITBUS;\r\nctrl &= ~SDHCI_CTRL_8BITBUS;\r\nbreak;\r\ndefault:\r\nctrl &= ~SDHCI_CTRL_4BITBUS;\r\nctrl &= ~SDHCI_CTRL_8BITBUS;\r\nbreak;\r\n}\r\nsdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);\r\n}\r\nstatic int sdhci_s3c_parse_dt(struct device *dev,\r\nstruct sdhci_host *host, struct s3c_sdhci_platdata *pdata)\r\n{\r\nstruct device_node *node = dev->of_node;\r\nu32 max_width;\r\nif (of_property_read_u32(node, "bus-width", &max_width))\r\nmax_width = 1;\r\npdata->max_width = max_width;\r\nif (of_get_property(node, "broken-cd", NULL)) {\r\npdata->cd_type = S3C_SDHCI_CD_NONE;\r\nreturn 0;\r\n}\r\nif (of_get_property(node, "non-removable", NULL)) {\r\npdata->cd_type = S3C_SDHCI_CD_PERMANENT;\r\nreturn 0;\r\n}\r\nif (of_get_named_gpio(node, "cd-gpios", 0))\r\nreturn 0;\r\npdata->cd_type = S3C_SDHCI_CD_INTERNAL;\r\nreturn 0;\r\n}\r\nstatic int sdhci_s3c_parse_dt(struct device *dev,\r\nstruct sdhci_host *host, struct s3c_sdhci_platdata *pdata)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic inline struct sdhci_s3c_drv_data *sdhci_s3c_get_driver_data(\r\nstruct platform_device *pdev)\r\n{\r\n#ifdef CONFIG_OF\r\nif (pdev->dev.of_node) {\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(sdhci_s3c_dt_match, pdev->dev.of_node);\r\nreturn (struct sdhci_s3c_drv_data *)match->data;\r\n}\r\n#endif\r\nreturn (struct sdhci_s3c_drv_data *)\r\nplatform_get_device_id(pdev)->driver_data;\r\n}\r\nstatic int sdhci_s3c_probe(struct platform_device *pdev)\r\n{\r\nstruct s3c_sdhci_platdata *pdata;\r\nstruct sdhci_s3c_drv_data *drv_data;\r\nstruct device *dev = &pdev->dev;\r\nstruct sdhci_host *host;\r\nstruct sdhci_s3c *sc;\r\nstruct resource *res;\r\nint ret, irq, ptr, clks;\r\nif (!pdev->dev.platform_data && !pdev->dev.of_node) {\r\ndev_err(dev, "no device data specified\n");\r\nreturn -ENOENT;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "no irq specified\n");\r\nreturn irq;\r\n}\r\nhost = sdhci_alloc_host(dev, sizeof(struct sdhci_s3c));\r\nif (IS_ERR(host)) {\r\ndev_err(dev, "sdhci_alloc_host() failed\n");\r\nreturn PTR_ERR(host);\r\n}\r\nsc = sdhci_priv(host);\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata) {\r\nret = -ENOMEM;\r\ngoto err_pdata_io_clk;\r\n}\r\nif (pdev->dev.of_node) {\r\nret = sdhci_s3c_parse_dt(&pdev->dev, host, pdata);\r\nif (ret)\r\ngoto err_pdata_io_clk;\r\n} else {\r\nmemcpy(pdata, pdev->dev.platform_data, sizeof(*pdata));\r\nsc->ext_cd_gpio = -1;\r\n}\r\ndrv_data = sdhci_s3c_get_driver_data(pdev);\r\nsc->host = host;\r\nsc->pdev = pdev;\r\nsc->pdata = pdata;\r\nsc->cur_clk = -1;\r\nplatform_set_drvdata(pdev, host);\r\nsc->clk_io = devm_clk_get(dev, "hsmmc");\r\nif (IS_ERR(sc->clk_io)) {\r\ndev_err(dev, "failed to get io clock\n");\r\nret = PTR_ERR(sc->clk_io);\r\ngoto err_pdata_io_clk;\r\n}\r\nclk_prepare_enable(sc->clk_io);\r\nfor (clks = 0, ptr = 0; ptr < MAX_BUS_CLK; ptr++) {\r\nchar name[14];\r\nsnprintf(name, 14, "mmc_busclk.%d", ptr);\r\nsc->clk_bus[ptr] = devm_clk_get(dev, name);\r\nif (IS_ERR(sc->clk_bus[ptr]))\r\ncontinue;\r\nclks++;\r\nsc->clk_rates[ptr] = clk_get_rate(sc->clk_bus[ptr]);\r\ndev_info(dev, "clock source %d: %s (%ld Hz)\n",\r\nptr, name, sc->clk_rates[ptr]);\r\n}\r\nif (clks == 0) {\r\ndev_err(dev, "failed to find any bus clocks\n");\r\nret = -ENOENT;\r\ngoto err_no_busclks;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhost->ioaddr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(host->ioaddr)) {\r\nret = PTR_ERR(host->ioaddr);\r\ngoto err_req_regs;\r\n}\r\nif (pdata->cfg_gpio)\r\npdata->cfg_gpio(pdev, pdata->max_width);\r\nhost->hw_name = "samsung-hsmmc";\r\nhost->ops = &sdhci_s3c_ops;\r\nhost->quirks = 0;\r\nhost->quirks2 = 0;\r\nhost->irq = irq;\r\nhost->quirks |= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC;\r\nhost->quirks |= SDHCI_QUIRK_NO_HISPD_BIT;\r\nif (drv_data) {\r\nhost->quirks |= drv_data->sdhci_quirks;\r\nsc->no_divider = drv_data->no_divider;\r\n}\r\n#ifndef CONFIG_MMC_SDHCI_S3C_DMA\r\nhost->quirks |= SDHCI_QUIRK_BROKEN_DMA;\r\n#endif\r\nhost->quirks |= SDHCI_QUIRK_NO_BUSY_IRQ;\r\nhost->quirks |= SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12;\r\nhost->quirks |= SDHCI_QUIRK_BROKEN_ADMA_ZEROLEN_DESC;\r\nif (pdata->cd_type == S3C_SDHCI_CD_NONE ||\r\npdata->cd_type == S3C_SDHCI_CD_PERMANENT)\r\nhost->quirks |= SDHCI_QUIRK_BROKEN_CARD_DETECTION;\r\nif (pdata->cd_type == S3C_SDHCI_CD_PERMANENT)\r\nhost->mmc->caps = MMC_CAP_NONREMOVABLE;\r\nswitch (pdata->max_width) {\r\ncase 8:\r\nhost->mmc->caps |= MMC_CAP_8_BIT_DATA;\r\ncase 4:\r\nhost->mmc->caps |= MMC_CAP_4_BIT_DATA;\r\nbreak;\r\n}\r\nif (pdata->pm_caps)\r\nhost->mmc->pm_caps |= pdata->pm_caps;\r\nhost->quirks |= (SDHCI_QUIRK_32BIT_DMA_ADDR |\r\nSDHCI_QUIRK_32BIT_DMA_SIZE);\r\nhost->quirks |= SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK;\r\nif (sc->no_divider) {\r\nsdhci_s3c_ops.set_clock = sdhci_cmu_set_clock;\r\nsdhci_s3c_ops.get_min_clock = sdhci_cmu_get_min_clock;\r\nsdhci_s3c_ops.get_max_clock = sdhci_cmu_get_max_clock;\r\n}\r\nif (pdata->host_caps)\r\nhost->mmc->caps |= pdata->host_caps;\r\nif (pdata->host_caps2)\r\nhost->mmc->caps2 |= pdata->host_caps2;\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_set_autosuspend_delay(&pdev->dev, 50);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_suspend_ignore_children(&pdev->dev, 1);\r\nmmc_of_parse(host->mmc);\r\nret = sdhci_add_host(host);\r\nif (ret) {\r\ndev_err(dev, "sdhci_add_host() failed\n");\r\npm_runtime_forbid(&pdev->dev);\r\npm_runtime_get_noresume(&pdev->dev);\r\ngoto err_req_regs;\r\n}\r\n#ifdef CONFIG_PM_RUNTIME\r\nif (pdata->cd_type != S3C_SDHCI_CD_INTERNAL)\r\nclk_disable_unprepare(sc->clk_io);\r\n#endif\r\nreturn 0;\r\nerr_req_regs:\r\nerr_no_busclks:\r\nclk_disable_unprepare(sc->clk_io);\r\nerr_pdata_io_clk:\r\nsdhci_free_host(host);\r\nreturn ret;\r\n}\r\nstatic int sdhci_s3c_remove(struct platform_device *pdev)\r\n{\r\nstruct sdhci_host *host = platform_get_drvdata(pdev);\r\nstruct sdhci_s3c *sc = sdhci_priv(host);\r\nif (sc->ext_cd_irq)\r\nfree_irq(sc->ext_cd_irq, sc);\r\n#ifdef CONFIG_PM_RUNTIME\r\nif (sc->pdata->cd_type != S3C_SDHCI_CD_INTERNAL)\r\nclk_prepare_enable(sc->clk_io);\r\n#endif\r\nsdhci_remove_host(host, 1);\r\npm_runtime_dont_use_autosuspend(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nclk_disable_unprepare(sc->clk_io);\r\nsdhci_free_host(host);\r\nreturn 0;\r\n}\r\nstatic int sdhci_s3c_suspend(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nreturn sdhci_suspend_host(host);\r\n}\r\nstatic int sdhci_s3c_resume(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nreturn sdhci_resume_host(host);\r\n}\r\nstatic int sdhci_s3c_runtime_suspend(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nstruct sdhci_s3c *ourhost = to_s3c(host);\r\nstruct clk *busclk = ourhost->clk_io;\r\nint ret;\r\nret = sdhci_runtime_suspend_host(host);\r\nif (ourhost->cur_clk >= 0)\r\nclk_disable_unprepare(ourhost->clk_bus[ourhost->cur_clk]);\r\nclk_disable_unprepare(busclk);\r\nreturn ret;\r\n}\r\nstatic int sdhci_s3c_runtime_resume(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nstruct sdhci_s3c *ourhost = to_s3c(host);\r\nstruct clk *busclk = ourhost->clk_io;\r\nint ret;\r\nclk_prepare_enable(busclk);\r\nif (ourhost->cur_clk >= 0)\r\nclk_prepare_enable(ourhost->clk_bus[ourhost->cur_clk]);\r\nret = sdhci_runtime_resume_host(host);\r\nreturn ret;\r\n}
