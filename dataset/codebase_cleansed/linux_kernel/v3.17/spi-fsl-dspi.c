static inline int is_double_byte_mode(struct fsl_dspi *dspi)\r\n{\r\nunsigned int val;\r\nregmap_read(dspi->regmap, SPI_CTAR(dspi->cs), &val);\r\nreturn ((val & SPI_FRAME_BITS_MASK) == SPI_FRAME_BITS(8)) ? 0 : 1;\r\n}\r\nstatic void hz_to_spi_baud(char *pbr, char *br, int speed_hz,\r\nunsigned long clkrate)\r\n{\r\nint pbr_tbl[4] = {2, 3, 5, 7};\r\nint brs[16] = { 2, 4, 6, 8,\r\n16, 32, 64, 128,\r\n256, 512, 1024, 2048,\r\n4096, 8192, 16384, 32768 };\r\nint temp, i = 0, j = 0;\r\ntemp = clkrate / 2 / speed_hz;\r\nfor (i = 0; i < ARRAY_SIZE(pbr_tbl); i++)\r\nfor (j = 0; j < ARRAY_SIZE(brs); j++) {\r\nif (pbr_tbl[i] * brs[j] >= temp) {\r\n*pbr = i;\r\n*br = j;\r\nreturn;\r\n}\r\n}\r\npr_warn("Can not find valid baud rate,speed_hz is %d,clkrate is %ld\\r\n,we use the max prescaler value.\n", speed_hz, clkrate);\r\n*pbr = ARRAY_SIZE(pbr_tbl) - 1;\r\n*br = ARRAY_SIZE(brs) - 1;\r\n}\r\nstatic int dspi_transfer_write(struct fsl_dspi *dspi)\r\n{\r\nint tx_count = 0;\r\nint tx_word;\r\nu16 d16;\r\nu8 d8;\r\nu32 dspi_pushr = 0;\r\nint first = 1;\r\ntx_word = is_double_byte_mode(dspi);\r\nif (tx_word && (dspi->len == 1)) {\r\ndspi->dataflags |= TRAN_STATE_WORD_ODD_NUM;\r\nregmap_update_bits(dspi->regmap, SPI_CTAR(dspi->cs),\r\nSPI_FRAME_BITS_MASK, SPI_FRAME_BITS(8));\r\ntx_word = 0;\r\n}\r\nwhile (dspi->len && (tx_count < DSPI_FIFO_SIZE)) {\r\nif (tx_word) {\r\nif (dspi->len == 1)\r\nbreak;\r\nif (!(dspi->dataflags & TRAN_STATE_TX_VOID)) {\r\nd16 = *(u16 *)dspi->tx;\r\ndspi->tx += 2;\r\n} else {\r\nd16 = dspi->void_write_data;\r\n}\r\ndspi_pushr = SPI_PUSHR_TXDATA(d16) |\r\nSPI_PUSHR_PCS(dspi->cs) |\r\nSPI_PUSHR_CTAS(dspi->cs) |\r\nSPI_PUSHR_CONT;\r\ndspi->len -= 2;\r\n} else {\r\nif (!(dspi->dataflags & TRAN_STATE_TX_VOID)) {\r\nd8 = *(u8 *)dspi->tx;\r\ndspi->tx++;\r\n} else {\r\nd8 = (u8)dspi->void_write_data;\r\n}\r\ndspi_pushr = SPI_PUSHR_TXDATA(d8) |\r\nSPI_PUSHR_PCS(dspi->cs) |\r\nSPI_PUSHR_CTAS(dspi->cs) |\r\nSPI_PUSHR_CONT;\r\ndspi->len--;\r\n}\r\nif (dspi->len == 0 || tx_count == DSPI_FIFO_SIZE - 1) {\r\ndspi_pushr |= SPI_PUSHR_EOQ;\r\n} else if (tx_word && (dspi->len == 1))\r\ndspi_pushr |= SPI_PUSHR_EOQ;\r\nif (first) {\r\nfirst = 0;\r\ndspi_pushr |= SPI_PUSHR_CTCNT;\r\n}\r\nregmap_write(dspi->regmap, SPI_PUSHR, dspi_pushr);\r\ntx_count++;\r\n}\r\nreturn tx_count * (tx_word + 1);\r\n}\r\nstatic int dspi_transfer_read(struct fsl_dspi *dspi)\r\n{\r\nint rx_count = 0;\r\nint rx_word = is_double_byte_mode(dspi);\r\nu16 d;\r\nwhile ((dspi->rx < dspi->rx_end)\r\n&& (rx_count < DSPI_FIFO_SIZE)) {\r\nif (rx_word) {\r\nunsigned int val;\r\nif ((dspi->rx_end - dspi->rx) == 1)\r\nbreak;\r\nregmap_read(dspi->regmap, SPI_POPR, &val);\r\nd = SPI_POPR_RXDATA(val);\r\nif (!(dspi->dataflags & TRAN_STATE_RX_VOID))\r\n*(u16 *)dspi->rx = d;\r\ndspi->rx += 2;\r\n} else {\r\nunsigned int val;\r\nregmap_read(dspi->regmap, SPI_POPR, &val);\r\nd = SPI_POPR_RXDATA(val);\r\nif (!(dspi->dataflags & TRAN_STATE_RX_VOID))\r\n*(u8 *)dspi->rx = d;\r\ndspi->rx++;\r\n}\r\nrx_count++;\r\n}\r\nreturn rx_count;\r\n}\r\nstatic int dspi_txrx_transfer(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct fsl_dspi *dspi = spi_master_get_devdata(spi->master);\r\ndspi->cur_transfer = t;\r\ndspi->cur_chip = spi_get_ctldata(spi);\r\ndspi->cs = spi->chip_select;\r\ndspi->void_write_data = dspi->cur_chip->void_write_data;\r\ndspi->dataflags = 0;\r\ndspi->tx = (void *)t->tx_buf;\r\ndspi->tx_end = dspi->tx + t->len;\r\ndspi->rx = t->rx_buf;\r\ndspi->rx_end = dspi->rx + t->len;\r\ndspi->len = t->len;\r\nif (!dspi->rx)\r\ndspi->dataflags |= TRAN_STATE_RX_VOID;\r\nif (!dspi->tx)\r\ndspi->dataflags |= TRAN_STATE_TX_VOID;\r\nregmap_write(dspi->regmap, SPI_MCR, dspi->cur_chip->mcr_val);\r\nregmap_write(dspi->regmap, SPI_CTAR(dspi->cs), dspi->cur_chip->ctar_val);\r\nregmap_write(dspi->regmap, SPI_RSER, SPI_RSER_EOQFE);\r\nif (t->speed_hz)\r\nregmap_write(dspi->regmap, SPI_CTAR(dspi->cs),\r\ndspi->cur_chip->ctar_val);\r\ndspi_transfer_write(dspi);\r\nif (wait_event_interruptible(dspi->waitq, dspi->waitflags))\r\ndev_err(&dspi->pdev->dev, "wait transfer complete fail!\n");\r\ndspi->waitflags = 0;\r\nreturn t->len - dspi->len;\r\n}\r\nstatic void dspi_chipselect(struct spi_device *spi, int value)\r\n{\r\nstruct fsl_dspi *dspi = spi_master_get_devdata(spi->master);\r\nunsigned int pushr;\r\nregmap_read(dspi->regmap, SPI_PUSHR, &pushr);\r\nswitch (value) {\r\ncase BITBANG_CS_ACTIVE:\r\npushr |= SPI_PUSHR_CONT;\r\nbreak;\r\ncase BITBANG_CS_INACTIVE:\r\npushr &= ~SPI_PUSHR_CONT;\r\nbreak;\r\n}\r\nregmap_write(dspi->regmap, SPI_PUSHR, pushr);\r\n}\r\nstatic int dspi_setup_transfer(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct chip_data *chip;\r\nstruct fsl_dspi *dspi = spi_master_get_devdata(spi->master);\r\nunsigned char br = 0, pbr = 0, fmsz = 0;\r\nchip = spi_get_ctldata(spi);\r\nif (chip == NULL) {\r\nchip = devm_kzalloc(&spi->dev, sizeof(struct chip_data),\r\nGFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\n}\r\nchip->mcr_val = SPI_MCR_MASTER | SPI_MCR_PCSIS |\r\nSPI_MCR_CLR_TXF | SPI_MCR_CLR_RXF;\r\nif ((spi->bits_per_word >= 4) && (spi->bits_per_word <= 16)) {\r\nfmsz = spi->bits_per_word - 1;\r\n} else {\r\npr_err("Invalid wordsize\n");\r\nreturn -ENODEV;\r\n}\r\nchip->void_write_data = 0;\r\nhz_to_spi_baud(&pbr, &br,\r\nspi->max_speed_hz, clk_get_rate(dspi->clk));\r\nchip->ctar_val = SPI_CTAR_FMSZ(fmsz)\r\n| SPI_CTAR_CPOL(spi->mode & SPI_CPOL ? 1 : 0)\r\n| SPI_CTAR_CPHA(spi->mode & SPI_CPHA ? 1 : 0)\r\n| SPI_CTAR_LSBFE(spi->mode & SPI_LSB_FIRST ? 1 : 0)\r\n| SPI_CTAR_PBR(pbr)\r\n| SPI_CTAR_BR(br);\r\nspi_set_ctldata(spi, chip);\r\nreturn 0;\r\n}\r\nstatic int dspi_setup(struct spi_device *spi)\r\n{\r\nif (!spi->max_speed_hz)\r\nreturn -EINVAL;\r\nreturn dspi_setup_transfer(spi, NULL);\r\n}\r\nstatic irqreturn_t dspi_interrupt(int irq, void *dev_id)\r\n{\r\nstruct fsl_dspi *dspi = (struct fsl_dspi *)dev_id;\r\nregmap_write(dspi->regmap, SPI_SR, SPI_SR_EOQF);\r\ndspi_transfer_read(dspi);\r\nif (!dspi->len) {\r\nif (dspi->dataflags & TRAN_STATE_WORD_ODD_NUM)\r\nregmap_update_bits(dspi->regmap, SPI_CTAR(dspi->cs),\r\nSPI_FRAME_BITS_MASK, SPI_FRAME_BITS(16));\r\ndspi->waitflags = 1;\r\nwake_up_interruptible(&dspi->waitq);\r\n} else {\r\ndspi_transfer_write(dspi);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int dspi_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct fsl_dspi *dspi = spi_master_get_devdata(master);\r\nspi_master_suspend(master);\r\nclk_disable_unprepare(dspi->clk);\r\nreturn 0;\r\n}\r\nstatic int dspi_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct fsl_dspi *dspi = spi_master_get_devdata(master);\r\nclk_prepare_enable(dspi->clk);\r\nspi_master_resume(master);\r\nreturn 0;\r\n}\r\nstatic int dspi_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct spi_master *master;\r\nstruct fsl_dspi *dspi;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nint ret = 0, cs_num, bus_num;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(struct fsl_dspi));\r\nif (!master)\r\nreturn -ENOMEM;\r\ndspi = spi_master_get_devdata(master);\r\ndspi->pdev = pdev;\r\ndspi->bitbang.master = master;\r\ndspi->bitbang.chipselect = dspi_chipselect;\r\ndspi->bitbang.setup_transfer = dspi_setup_transfer;\r\ndspi->bitbang.txrx_bufs = dspi_txrx_transfer;\r\ndspi->bitbang.master->setup = dspi_setup;\r\ndspi->bitbang.master->dev.of_node = pdev->dev.of_node;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(4) | SPI_BPW_MASK(8) |\r\nSPI_BPW_MASK(16);\r\nret = of_property_read_u32(np, "spi-num-chipselects", &cs_num);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "can't get spi-num-chipselects\n");\r\ngoto out_master_put;\r\n}\r\nmaster->num_chipselect = cs_num;\r\nret = of_property_read_u32(np, "bus-num", &bus_num);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "can't get bus-num\n");\r\ngoto out_master_put;\r\n}\r\nmaster->bus_num = bus_num;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base)) {\r\nret = PTR_ERR(base);\r\ngoto out_master_put;\r\n}\r\ndspi_regmap_config.lock_arg = dspi;\r\ndspi_regmap_config.val_format_endian =\r\nof_property_read_bool(np, "big-endian")\r\n? REGMAP_ENDIAN_BIG : REGMAP_ENDIAN_DEFAULT;\r\ndspi->regmap = devm_regmap_init_mmio_clk(&pdev->dev, "dspi", base,\r\n&dspi_regmap_config);\r\nif (IS_ERR(dspi->regmap)) {\r\ndev_err(&pdev->dev, "failed to init regmap: %ld\n",\r\nPTR_ERR(dspi->regmap));\r\nreturn PTR_ERR(dspi->regmap);\r\n}\r\ndspi->irq = platform_get_irq(pdev, 0);\r\nif (dspi->irq < 0) {\r\ndev_err(&pdev->dev, "can't get platform irq\n");\r\nret = dspi->irq;\r\ngoto out_master_put;\r\n}\r\nret = devm_request_irq(&pdev->dev, dspi->irq, dspi_interrupt, 0,\r\npdev->name, dspi);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Unable to attach DSPI interrupt\n");\r\ngoto out_master_put;\r\n}\r\ndspi->clk = devm_clk_get(&pdev->dev, "dspi");\r\nif (IS_ERR(dspi->clk)) {\r\nret = PTR_ERR(dspi->clk);\r\ndev_err(&pdev->dev, "unable to get clock\n");\r\ngoto out_master_put;\r\n}\r\nclk_prepare_enable(dspi->clk);\r\ninit_waitqueue_head(&dspi->waitq);\r\nplatform_set_drvdata(pdev, master);\r\nret = spi_bitbang_start(&dspi->bitbang);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "Problem registering DSPI master\n");\r\ngoto out_clk_put;\r\n}\r\npr_info(KERN_INFO "Freescale DSPI master initialized\n");\r\nreturn ret;\r\nout_clk_put:\r\nclk_disable_unprepare(dspi->clk);\r\nout_master_put:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int dspi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct fsl_dspi *dspi = spi_master_get_devdata(master);\r\nspi_bitbang_stop(&dspi->bitbang);\r\nclk_disable_unprepare(dspi->clk);\r\nspi_master_put(dspi->bitbang.master);\r\nreturn 0;\r\n}
