static int exynos_audss_clk_suspend(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(reg_save); i++)\r\nreg_save[i][1] = readl(reg_base + reg_save[i][0]);\r\nreturn 0;\r\n}\r\nstatic void exynos_audss_clk_resume(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(reg_save); i++)\r\nwritel(reg_save[i][1], reg_base + reg_save[i][0]);\r\n}\r\nstatic int exynos_audss_clk_probe(struct platform_device *pdev)\r\n{\r\nint i, ret = 0;\r\nstruct resource *res;\r\nconst char *mout_audss_p[] = {"fin_pll", "fout_epll"};\r\nconst char *mout_i2s_p[] = {"mout_audss", "cdclk0", "sclk_audio0"};\r\nconst char *sclk_pcm_p = "sclk_pcm0";\r\nstruct clk *pll_ref, *pll_in, *cdclk, *sclk_audio, *sclk_pcm_in;\r\nconst struct of_device_id *match;\r\nenum exynos_audss_clk_type variant;\r\nmatch = of_match_node(exynos_audss_clk_of_match, pdev->dev.of_node);\r\nif (!match)\r\nreturn -EINVAL;\r\nvariant = (enum exynos_audss_clk_type)match->data;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nreg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(reg_base)) {\r\ndev_err(&pdev->dev, "failed to map audss registers\n");\r\nreturn PTR_ERR(reg_base);\r\n}\r\nclk_table = devm_kzalloc(&pdev->dev,\r\nsizeof(struct clk *) * EXYNOS_AUDSS_MAX_CLKS,\r\nGFP_KERNEL);\r\nif (!clk_table)\r\nreturn -ENOMEM;\r\nclk_data.clks = clk_table;\r\nif (variant == TYPE_EXYNOS5420)\r\nclk_data.clk_num = EXYNOS_AUDSS_MAX_CLKS;\r\nelse\r\nclk_data.clk_num = EXYNOS_AUDSS_MAX_CLKS - 1;\r\npll_ref = devm_clk_get(&pdev->dev, "pll_ref");\r\npll_in = devm_clk_get(&pdev->dev, "pll_in");\r\nif (!IS_ERR(pll_ref))\r\nmout_audss_p[0] = __clk_get_name(pll_ref);\r\nif (!IS_ERR(pll_in))\r\nmout_audss_p[1] = __clk_get_name(pll_in);\r\nclk_table[EXYNOS_MOUT_AUDSS] = clk_register_mux(NULL, "mout_audss",\r\nmout_audss_p, ARRAY_SIZE(mout_audss_p),\r\nCLK_SET_RATE_NO_REPARENT,\r\nreg_base + ASS_CLK_SRC, 0, 1, 0, &lock);\r\ncdclk = devm_clk_get(&pdev->dev, "cdclk");\r\nsclk_audio = devm_clk_get(&pdev->dev, "sclk_audio");\r\nif (!IS_ERR(cdclk))\r\nmout_i2s_p[1] = __clk_get_name(cdclk);\r\nif (!IS_ERR(sclk_audio))\r\nmout_i2s_p[2] = __clk_get_name(sclk_audio);\r\nclk_table[EXYNOS_MOUT_I2S] = clk_register_mux(NULL, "mout_i2s",\r\nmout_i2s_p, ARRAY_SIZE(mout_i2s_p),\r\nCLK_SET_RATE_NO_REPARENT,\r\nreg_base + ASS_CLK_SRC, 2, 2, 0, &lock);\r\nclk_table[EXYNOS_DOUT_SRP] = clk_register_divider(NULL, "dout_srp",\r\n"mout_audss", 0, reg_base + ASS_CLK_DIV, 0, 4,\r\n0, &lock);\r\nclk_table[EXYNOS_DOUT_AUD_BUS] = clk_register_divider(NULL,\r\n"dout_aud_bus", "dout_srp", 0,\r\nreg_base + ASS_CLK_DIV, 4, 4, 0, &lock);\r\nclk_table[EXYNOS_DOUT_I2S] = clk_register_divider(NULL, "dout_i2s",\r\n"mout_i2s", 0, reg_base + ASS_CLK_DIV, 8, 4, 0,\r\n&lock);\r\nclk_table[EXYNOS_SRP_CLK] = clk_register_gate(NULL, "srp_clk",\r\n"dout_srp", CLK_SET_RATE_PARENT,\r\nreg_base + ASS_CLK_GATE, 0, 0, &lock);\r\nclk_table[EXYNOS_I2S_BUS] = clk_register_gate(NULL, "i2s_bus",\r\n"dout_aud_bus", CLK_SET_RATE_PARENT,\r\nreg_base + ASS_CLK_GATE, 2, 0, &lock);\r\nclk_table[EXYNOS_SCLK_I2S] = clk_register_gate(NULL, "sclk_i2s",\r\n"dout_i2s", CLK_SET_RATE_PARENT,\r\nreg_base + ASS_CLK_GATE, 3, 0, &lock);\r\nclk_table[EXYNOS_PCM_BUS] = clk_register_gate(NULL, "pcm_bus",\r\n"sclk_pcm", CLK_SET_RATE_PARENT,\r\nreg_base + ASS_CLK_GATE, 4, 0, &lock);\r\nsclk_pcm_in = devm_clk_get(&pdev->dev, "sclk_pcm_in");\r\nif (!IS_ERR(sclk_pcm_in))\r\nsclk_pcm_p = __clk_get_name(sclk_pcm_in);\r\nclk_table[EXYNOS_SCLK_PCM] = clk_register_gate(NULL, "sclk_pcm",\r\nsclk_pcm_p, CLK_SET_RATE_PARENT,\r\nreg_base + ASS_CLK_GATE, 5, 0, &lock);\r\nif (variant == TYPE_EXYNOS5420) {\r\nclk_table[EXYNOS_ADMA] = clk_register_gate(NULL, "adma",\r\n"dout_srp", CLK_SET_RATE_PARENT,\r\nreg_base + ASS_CLK_GATE, 9, 0, &lock);\r\n}\r\nfor (i = 0; i < clk_data.clk_num; i++) {\r\nif (IS_ERR(clk_table[i])) {\r\ndev_err(&pdev->dev, "failed to register clock %d\n", i);\r\nret = PTR_ERR(clk_table[i]);\r\ngoto unregister;\r\n}\r\n}\r\nret = of_clk_add_provider(pdev->dev.of_node, of_clk_src_onecell_get,\r\n&clk_data);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add clock provider\n");\r\ngoto unregister;\r\n}\r\n#ifdef CONFIG_PM_SLEEP\r\nregister_syscore_ops(&exynos_audss_clk_syscore_ops);\r\n#endif\r\ndev_info(&pdev->dev, "setup completed\n");\r\nreturn 0;\r\nunregister:\r\nfor (i = 0; i < clk_data.clk_num; i++) {\r\nif (!IS_ERR(clk_table[i]))\r\nclk_unregister(clk_table[i]);\r\n}\r\nreturn ret;\r\n}\r\nstatic int exynos_audss_clk_remove(struct platform_device *pdev)\r\n{\r\nint i;\r\nof_clk_del_provider(pdev->dev.of_node);\r\nfor (i = 0; i < clk_data.clk_num; i++) {\r\nif (!IS_ERR(clk_table[i]))\r\nclk_unregister(clk_table[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init exynos_audss_clk_init(void)\r\n{\r\nreturn platform_driver_register(&exynos_audss_clk_driver);\r\n}\r\nstatic void __exit exynos_audss_clk_exit(void)\r\n{\r\nplatform_driver_unregister(&exynos_audss_clk_driver);\r\n}
