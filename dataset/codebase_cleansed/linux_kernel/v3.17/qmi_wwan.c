static int qmi_wwan_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\n__be16 proto;\r\nif (skb->len < dev->net->hard_header_len)\r\nreturn 0;\r\nswitch (skb->data[0] & 0xf0) {\r\ncase 0x40:\r\nproto = htons(ETH_P_IP);\r\nbreak;\r\ncase 0x60:\r\nproto = htons(ETH_P_IPV6);\r\nbreak;\r\ncase 0x00:\r\nif (is_multicast_ether_addr(skb->data))\r\nreturn 1;\r\nskb_reset_mac_header(skb);\r\ngoto fix_dest;\r\ndefault:\r\nreturn 1;\r\n}\r\nif (skb_headroom(skb) < ETH_HLEN)\r\nreturn 0;\r\nskb_push(skb, ETH_HLEN);\r\nskb_reset_mac_header(skb);\r\neth_hdr(skb)->h_proto = proto;\r\nmemset(eth_hdr(skb)->h_source, 0, ETH_ALEN);\r\nfix_dest:\r\nmemcpy(eth_hdr(skb)->h_dest, dev->net->dev_addr, ETH_ALEN);\r\nreturn 1;\r\n}\r\nstatic bool possibly_iphdr(const char *data)\r\n{\r\nreturn (data[0] & 0xd0) == 0x40;\r\n}\r\nstatic int qmi_wwan_mac_addr(struct net_device *dev, void *p)\r\n{\r\nint ret;\r\nstruct sockaddr *addr = p;\r\nret = eth_prepare_mac_addr_change(dev, p);\r\nif (ret < 0)\r\nreturn ret;\r\nif (possibly_iphdr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\neth_commit_mac_addr_change(dev, p);\r\nreturn 0;\r\n}\r\nstatic int qmi_wwan_manage_power(struct usbnet *dev, int on)\r\n{\r\nstruct qmi_wwan_state *info = (void *)&dev->data;\r\nint rv;\r\ndev_dbg(&dev->intf->dev, "%s() pmcount=%d, on=%d\n", __func__,\r\natomic_read(&info->pmcount), on);\r\nif ((on && atomic_add_return(1, &info->pmcount) == 1) ||\r\n(!on && atomic_dec_and_test(&info->pmcount))) {\r\nrv = usb_autopm_get_interface(dev->intf);\r\ndev->intf->needs_remote_wakeup = on;\r\nif (!rv)\r\nusb_autopm_put_interface(dev->intf);\r\n}\r\nreturn 0;\r\n}\r\nstatic int qmi_wwan_cdc_wdm_manage_power(struct usb_interface *intf, int on)\r\n{\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nif (!dev)\r\nreturn 0;\r\nreturn qmi_wwan_manage_power(dev, on);\r\n}\r\nstatic int qmi_wwan_register_subdriver(struct usbnet *dev)\r\n{\r\nint rv;\r\nstruct usb_driver *subdriver = NULL;\r\nstruct qmi_wwan_state *info = (void *)&dev->data;\r\nrv = usbnet_get_endpoints(dev, info->data);\r\nif (rv < 0)\r\ngoto err;\r\nif (info->control != info->data)\r\ndev->status = &info->control->cur_altsetting->endpoint[0];\r\nif (!dev->status) {\r\nrv = -EINVAL;\r\ngoto err;\r\n}\r\natomic_set(&info->pmcount, 0);\r\nsubdriver = usb_cdc_wdm_register(info->control, &dev->status->desc,\r\n4096, &qmi_wwan_cdc_wdm_manage_power);\r\nif (IS_ERR(subdriver)) {\r\ndev_err(&info->control->dev, "subdriver registration failed\n");\r\nrv = PTR_ERR(subdriver);\r\ngoto err;\r\n}\r\ndev->status = NULL;\r\ninfo->subdriver = subdriver;\r\nerr:\r\nreturn rv;\r\n}\r\nstatic int qmi_wwan_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nint status = -1;\r\nu8 *buf = intf->cur_altsetting->extra;\r\nint len = intf->cur_altsetting->extralen;\r\nstruct usb_interface_descriptor *desc = &intf->cur_altsetting->desc;\r\nstruct usb_cdc_union_desc *cdc_union = NULL;\r\nstruct usb_cdc_ether_desc *cdc_ether = NULL;\r\nu32 found = 0;\r\nstruct usb_driver *driver = driver_of(intf);\r\nstruct qmi_wwan_state *info = (void *)&dev->data;\r\nBUILD_BUG_ON((sizeof(((struct usbnet *)0)->data) <\r\nsizeof(struct qmi_wwan_state)));\r\ninfo->control = intf;\r\ninfo->data = intf;\r\nwhile (len > 3) {\r\nstruct usb_descriptor_header *h = (void *)buf;\r\nif (h->bDescriptorType != USB_DT_CS_INTERFACE)\r\ngoto next_desc;\r\nswitch (buf[2]) {\r\ncase USB_CDC_HEADER_TYPE:\r\nif (found & 1 << USB_CDC_HEADER_TYPE) {\r\ndev_dbg(&intf->dev, "extra CDC header\n");\r\ngoto err;\r\n}\r\nif (h->bLength != sizeof(struct usb_cdc_header_desc)) {\r\ndev_dbg(&intf->dev, "CDC header len %u\n",\r\nh->bLength);\r\ngoto err;\r\n}\r\nbreak;\r\ncase USB_CDC_UNION_TYPE:\r\nif (found & 1 << USB_CDC_UNION_TYPE) {\r\ndev_dbg(&intf->dev, "extra CDC union\n");\r\ngoto err;\r\n}\r\nif (h->bLength != sizeof(struct usb_cdc_union_desc)) {\r\ndev_dbg(&intf->dev, "CDC union len %u\n",\r\nh->bLength);\r\ngoto err;\r\n}\r\ncdc_union = (struct usb_cdc_union_desc *)buf;\r\nbreak;\r\ncase USB_CDC_ETHERNET_TYPE:\r\nif (found & 1 << USB_CDC_ETHERNET_TYPE) {\r\ndev_dbg(&intf->dev, "extra CDC ether\n");\r\ngoto err;\r\n}\r\nif (h->bLength != sizeof(struct usb_cdc_ether_desc)) {\r\ndev_dbg(&intf->dev, "CDC ether len %u\n",\r\nh->bLength);\r\ngoto err;\r\n}\r\ncdc_ether = (struct usb_cdc_ether_desc *)buf;\r\nbreak;\r\n}\r\nif (buf[2] < 32)\r\nfound |= 1 << buf[2];\r\nnext_desc:\r\nlen -= h->bLength;\r\nbuf += h->bLength;\r\n}\r\nif (cdc_union) {\r\ninfo->data = usb_ifnum_to_if(dev->udev,\r\ncdc_union->bSlaveInterface0);\r\nif (desc->bInterfaceNumber != cdc_union->bMasterInterface0 ||\r\n!info->data) {\r\ndev_err(&intf->dev,\r\n"bogus CDC Union: master=%u, slave=%u\n",\r\ncdc_union->bMasterInterface0,\r\ncdc_union->bSlaveInterface0);\r\ngoto err;\r\n}\r\n}\r\nif (cdc_ether) {\r\ndev->hard_mtu = le16_to_cpu(cdc_ether->wMaxSegmentSize);\r\nusbnet_get_ethernet_addr(dev, cdc_ether->iMACAddress);\r\n}\r\nif (info->control != info->data) {\r\nstatus = usb_driver_claim_interface(driver, info->data, dev);\r\nif (status < 0)\r\ngoto err;\r\n}\r\nstatus = qmi_wwan_register_subdriver(dev);\r\nif (status < 0 && info->control != info->data) {\r\nusb_set_intfdata(info->data, NULL);\r\nusb_driver_release_interface(driver, info->data);\r\n}\r\nif (ether_addr_equal(dev->net->dev_addr, default_modem_addr))\r\neth_hw_addr_random(dev->net);\r\nif (possibly_iphdr(dev->net->dev_addr)) {\r\ndev->net->dev_addr[0] |= 0x02;\r\ndev->net->dev_addr[0] &= 0xbf;\r\n}\r\ndev->net->netdev_ops = &qmi_wwan_netdev_ops;\r\nerr:\r\nreturn status;\r\n}\r\nstatic void qmi_wwan_unbind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct qmi_wwan_state *info = (void *)&dev->data;\r\nstruct usb_driver *driver = driver_of(intf);\r\nstruct usb_interface *other;\r\nif (info->subdriver && info->subdriver->disconnect)\r\ninfo->subdriver->disconnect(info->control);\r\nif (intf == info->control)\r\nother = info->data;\r\nelse\r\nother = info->control;\r\nif (other && intf != other) {\r\nusb_set_intfdata(other, NULL);\r\nusb_driver_release_interface(driver, other);\r\n}\r\ninfo->subdriver = NULL;\r\ninfo->data = NULL;\r\ninfo->control = NULL;\r\n}\r\nstatic int qmi_wwan_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nstruct qmi_wwan_state *info = (void *)&dev->data;\r\nint ret;\r\nret = usbnet_suspend(intf, message);\r\nif (ret < 0)\r\ngoto err;\r\nif (intf == info->control && info->subdriver &&\r\ninfo->subdriver->suspend)\r\nret = info->subdriver->suspend(intf, message);\r\nif (ret < 0)\r\nusbnet_resume(intf);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int qmi_wwan_resume(struct usb_interface *intf)\r\n{\r\nstruct usbnet *dev = usb_get_intfdata(intf);\r\nstruct qmi_wwan_state *info = (void *)&dev->data;\r\nint ret = 0;\r\nbool callsub = (intf == info->control && info->subdriver &&\r\ninfo->subdriver->resume);\r\nif (callsub)\r\nret = info->subdriver->resume(intf);\r\nif (ret < 0)\r\ngoto err;\r\nret = usbnet_resume(intf);\r\nif (ret < 0 && callsub)\r\ninfo->subdriver->suspend(intf, PMSG_SUSPEND);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int qmi_wwan_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *prod)\r\n{\r\nstruct usb_device_id *id = (struct usb_device_id *)prod;\r\nif (!id->driver_info) {\r\ndev_dbg(&intf->dev, "setting defaults for dynamic device id\n");\r\nid->driver_info = (unsigned long)&qmi_wwan_info;\r\n}\r\nreturn usbnet_probe(intf, id);\r\n}
