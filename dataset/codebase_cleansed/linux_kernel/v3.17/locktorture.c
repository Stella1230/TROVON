static int torture_lock_busted_write_lock(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void torture_lock_busted_write_delay(struct torture_random_state *trsp)\r\n{\r\nconst unsigned long longdelay_us = 100;\r\nif (!(torture_random(trsp) %\r\n(nrealwriters_stress * 2000 * longdelay_us)))\r\nmdelay(longdelay_us);\r\n#ifdef CONFIG_PREEMPT\r\nif (!(torture_random(trsp) % (nrealwriters_stress * 20000)))\r\npreempt_schedule();\r\n#endif\r\n}\r\nstatic void torture_lock_busted_write_unlock(void)\r\n{\r\n}\r\nstatic int torture_spin_lock_write_lock(void) __acquires(torture_spinlock)\r\n{\r\nspin_lock(&torture_spinlock);\r\nreturn 0;\r\n}\r\nstatic void torture_spin_lock_write_delay(struct torture_random_state *trsp)\r\n{\r\nconst unsigned long shortdelay_us = 2;\r\nconst unsigned long longdelay_us = 100;\r\nif (!(torture_random(trsp) %\r\n(nrealwriters_stress * 2000 * longdelay_us)))\r\nmdelay(longdelay_us);\r\nif (!(torture_random(trsp) %\r\n(nrealwriters_stress * 2 * shortdelay_us)))\r\nudelay(shortdelay_us);\r\n#ifdef CONFIG_PREEMPT\r\nif (!(torture_random(trsp) % (nrealwriters_stress * 20000)))\r\npreempt_schedule();\r\n#endif\r\n}\r\nstatic void torture_spin_lock_write_unlock(void) __releases(torture_spinlock)\r\n{\r\nspin_unlock(&torture_spinlock);\r\n}\r\nstatic int torture_spin_lock_write_lock_irq(void)\r\n__acquires(torture_spinlock_irq)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&torture_spinlock, flags);\r\ncur_ops->flags = flags;\r\nreturn 0;\r\n}\r\nstatic void torture_lock_spin_write_unlock_irq(void)\r\n__releases(torture_spinlock)\r\n{\r\nspin_unlock_irqrestore(&torture_spinlock, cur_ops->flags);\r\n}\r\nstatic int lock_torture_writer(void *arg)\r\n{\r\nstruct lock_writer_stress_stats *lwsp = arg;\r\nstatic DEFINE_TORTURE_RANDOM(rand);\r\nVERBOSE_TOROUT_STRING("lock_torture_writer task started");\r\nset_user_nice(current, MAX_NICE);\r\ndo {\r\nif ((torture_random(&rand) & 0xfffff) == 0)\r\nschedule_timeout_uninterruptible(1);\r\ncur_ops->writelock();\r\nif (WARN_ON_ONCE(lock_is_write_held))\r\nlwsp->n_write_lock_fail++;\r\nlock_is_write_held = 1;\r\nlwsp->n_write_lock_acquired++;\r\ncur_ops->write_delay(&rand);\r\nlock_is_write_held = 0;\r\ncur_ops->writeunlock();\r\nstutter_wait("lock_torture_writer");\r\n} while (!torture_must_stop());\r\ntorture_kthread_stopping("lock_torture_writer");\r\nreturn 0;\r\n}\r\nstatic void lock_torture_printk(char *page)\r\n{\r\nbool fail = 0;\r\nint i;\r\nlong max = 0;\r\nlong min = lwsa[0].n_write_lock_acquired;\r\nlong long sum = 0;\r\nfor (i = 0; i < nrealwriters_stress; i++) {\r\nif (lwsa[i].n_write_lock_fail)\r\nfail = true;\r\nsum += lwsa[i].n_write_lock_acquired;\r\nif (max < lwsa[i].n_write_lock_fail)\r\nmax = lwsa[i].n_write_lock_fail;\r\nif (min > lwsa[i].n_write_lock_fail)\r\nmin = lwsa[i].n_write_lock_fail;\r\n}\r\npage += sprintf(page, "%s%s ", torture_type, TORTURE_FLAG);\r\npage += sprintf(page,\r\n"Writes: Total: %lld Max/Min: %ld/%ld %s Fail: %d %s\n",\r\nsum, max, min, max / 2 > min ? "???" : "",\r\nfail, fail ? "!!!" : "");\r\nif (fail)\r\natomic_inc(&n_lock_torture_errors);\r\n}\r\nstatic void lock_torture_stats_print(void)\r\n{\r\nint size = nrealwriters_stress * 200 + 8192;\r\nchar *buf;\r\nbuf = kmalloc(size, GFP_KERNEL);\r\nif (!buf) {\r\npr_err("lock_torture_stats_print: Out of memory, need: %d",\r\nsize);\r\nreturn;\r\n}\r\nlock_torture_printk(buf);\r\npr_alert("%s", buf);\r\nkfree(buf);\r\n}\r\nstatic int lock_torture_stats(void *arg)\r\n{\r\nVERBOSE_TOROUT_STRING("lock_torture_stats task started");\r\ndo {\r\nschedule_timeout_interruptible(stat_interval * HZ);\r\nlock_torture_stats_print();\r\ntorture_shutdown_absorb("lock_torture_stats");\r\n} while (!torture_must_stop());\r\ntorture_kthread_stopping("lock_torture_stats");\r\nreturn 0;\r\n}\r\nstatic inline void\r\nlock_torture_print_module_parms(struct lock_torture_ops *cur_ops,\r\nconst char *tag)\r\n{\r\npr_alert("%s" TORTURE_FLAG\r\n"--- %s: nwriters_stress=%d stat_interval=%d verbose=%d shuffle_interval=%d stutter=%d shutdown_secs=%d onoff_interval=%d onoff_holdoff=%d\n",\r\ntorture_type, tag, nrealwriters_stress, stat_interval, verbose,\r\nshuffle_interval, stutter, shutdown_secs,\r\nonoff_interval, onoff_holdoff);\r\n}\r\nstatic void lock_torture_cleanup(void)\r\n{\r\nint i;\r\nif (torture_cleanup())\r\nreturn;\r\nif (writer_tasks) {\r\nfor (i = 0; i < nrealwriters_stress; i++)\r\ntorture_stop_kthread(lock_torture_writer,\r\nwriter_tasks[i]);\r\nkfree(writer_tasks);\r\nwriter_tasks = NULL;\r\n}\r\ntorture_stop_kthread(lock_torture_stats, stats_task);\r\nlock_torture_stats_print();\r\nif (atomic_read(&n_lock_torture_errors))\r\nlock_torture_print_module_parms(cur_ops,\r\n"End of test: FAILURE");\r\nelse if (torture_onoff_failures())\r\nlock_torture_print_module_parms(cur_ops,\r\n"End of test: LOCK_HOTPLUG");\r\nelse\r\nlock_torture_print_module_parms(cur_ops,\r\n"End of test: SUCCESS");\r\n}\r\nstatic int __init lock_torture_init(void)\r\n{\r\nint i;\r\nint firsterr = 0;\r\nstatic struct lock_torture_ops *torture_ops[] = {\r\n&lock_busted_ops, &spin_lock_ops, &spin_lock_irq_ops,\r\n};\r\nif (!torture_init_begin(torture_type, verbose, &locktorture_runnable))\r\nreturn -EBUSY;\r\nfor (i = 0; i < ARRAY_SIZE(torture_ops); i++) {\r\ncur_ops = torture_ops[i];\r\nif (strcmp(torture_type, cur_ops->name) == 0)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(torture_ops)) {\r\npr_alert("lock-torture: invalid torture type: \"%s\"\n",\r\ntorture_type);\r\npr_alert("lock-torture types:");\r\nfor (i = 0; i < ARRAY_SIZE(torture_ops); i++)\r\npr_alert(" %s", torture_ops[i]->name);\r\npr_alert("\n");\r\ntorture_init_end();\r\nreturn -EINVAL;\r\n}\r\nif (cur_ops->init)\r\ncur_ops->init();\r\nif (nwriters_stress >= 0)\r\nnrealwriters_stress = nwriters_stress;\r\nelse\r\nnrealwriters_stress = 2 * num_online_cpus();\r\nlock_torture_print_module_parms(cur_ops, "Start of test");\r\nlock_is_write_held = 0;\r\nlwsa = kmalloc(sizeof(*lwsa) * nrealwriters_stress, GFP_KERNEL);\r\nif (lwsa == NULL) {\r\nVERBOSE_TOROUT_STRING("lwsa: Out of memory");\r\nfirsterr = -ENOMEM;\r\ngoto unwind;\r\n}\r\nfor (i = 0; i < nrealwriters_stress; i++) {\r\nlwsa[i].n_write_lock_fail = 0;\r\nlwsa[i].n_write_lock_acquired = 0;\r\n}\r\nif (onoff_interval > 0) {\r\nfirsterr = torture_onoff_init(onoff_holdoff * HZ,\r\nonoff_interval * HZ);\r\nif (firsterr)\r\ngoto unwind;\r\n}\r\nif (shuffle_interval > 0) {\r\nfirsterr = torture_shuffle_init(shuffle_interval);\r\nif (firsterr)\r\ngoto unwind;\r\n}\r\nif (shutdown_secs > 0) {\r\nfirsterr = torture_shutdown_init(shutdown_secs,\r\nlock_torture_cleanup);\r\nif (firsterr)\r\ngoto unwind;\r\n}\r\nif (stutter > 0) {\r\nfirsterr = torture_stutter_init(stutter);\r\nif (firsterr)\r\ngoto unwind;\r\n}\r\nwriter_tasks = kzalloc(nrealwriters_stress * sizeof(writer_tasks[0]),\r\nGFP_KERNEL);\r\nif (writer_tasks == NULL) {\r\nVERBOSE_TOROUT_ERRSTRING("writer_tasks: Out of memory");\r\nfirsterr = -ENOMEM;\r\ngoto unwind;\r\n}\r\nfor (i = 0; i < nrealwriters_stress; i++) {\r\nfirsterr = torture_create_kthread(lock_torture_writer, &lwsa[i],\r\nwriter_tasks[i]);\r\nif (firsterr)\r\ngoto unwind;\r\n}\r\nif (stat_interval > 0) {\r\nfirsterr = torture_create_kthread(lock_torture_stats, NULL,\r\nstats_task);\r\nif (firsterr)\r\ngoto unwind;\r\n}\r\ntorture_init_end();\r\nreturn 0;\r\nunwind:\r\ntorture_init_end();\r\nlock_torture_cleanup();\r\nreturn firsterr;\r\n}
