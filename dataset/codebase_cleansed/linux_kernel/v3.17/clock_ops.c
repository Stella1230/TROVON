static inline int __pm_clk_enable(struct device *dev, struct clk *clk)\r\n{\r\nint ret = clk_enable(clk);\r\nif (ret)\r\ndev_err(dev, "%s: failed to enable clk %p, error %d\n",\r\n__func__, clk, ret);\r\nreturn ret;\r\n}\r\nstatic void pm_clk_acquire(struct device *dev, struct pm_clock_entry *ce)\r\n{\r\nce->clk = clk_get(dev, ce->con_id);\r\nif (IS_ERR(ce->clk)) {\r\nce->status = PCE_STATUS_ERROR;\r\n} else {\r\nclk_prepare(ce->clk);\r\nce->status = PCE_STATUS_ACQUIRED;\r\ndev_dbg(dev, "Clock %s managed by runtime PM.\n", ce->con_id);\r\n}\r\n}\r\nint pm_clk_add(struct device *dev, const char *con_id)\r\n{\r\nstruct pm_subsys_data *psd = dev_to_psd(dev);\r\nstruct pm_clock_entry *ce;\r\nif (!psd)\r\nreturn -EINVAL;\r\nce = kzalloc(sizeof(*ce), GFP_KERNEL);\r\nif (!ce) {\r\ndev_err(dev, "Not enough memory for clock entry.\n");\r\nreturn -ENOMEM;\r\n}\r\nif (con_id) {\r\nce->con_id = kstrdup(con_id, GFP_KERNEL);\r\nif (!ce->con_id) {\r\ndev_err(dev,\r\n"Not enough memory for clock connection ID.\n");\r\nkfree(ce);\r\nreturn -ENOMEM;\r\n}\r\n}\r\npm_clk_acquire(dev, ce);\r\nspin_lock_irq(&psd->lock);\r\nlist_add_tail(&ce->node, &psd->clock_list);\r\nspin_unlock_irq(&psd->lock);\r\nreturn 0;\r\n}\r\nstatic void __pm_clk_remove(struct pm_clock_entry *ce)\r\n{\r\nif (!ce)\r\nreturn;\r\nif (ce->status < PCE_STATUS_ERROR) {\r\nif (ce->status == PCE_STATUS_ENABLED)\r\nclk_disable(ce->clk);\r\nif (ce->status >= PCE_STATUS_ACQUIRED) {\r\nclk_unprepare(ce->clk);\r\nclk_put(ce->clk);\r\n}\r\n}\r\nkfree(ce->con_id);\r\nkfree(ce);\r\n}\r\nvoid pm_clk_remove(struct device *dev, const char *con_id)\r\n{\r\nstruct pm_subsys_data *psd = dev_to_psd(dev);\r\nstruct pm_clock_entry *ce;\r\nif (!psd)\r\nreturn;\r\nspin_lock_irq(&psd->lock);\r\nlist_for_each_entry(ce, &psd->clock_list, node) {\r\nif (!con_id && !ce->con_id)\r\ngoto remove;\r\nelse if (!con_id || !ce->con_id)\r\ncontinue;\r\nelse if (!strcmp(con_id, ce->con_id))\r\ngoto remove;\r\n}\r\nspin_unlock_irq(&psd->lock);\r\nreturn;\r\nremove:\r\nlist_del(&ce->node);\r\nspin_unlock_irq(&psd->lock);\r\n__pm_clk_remove(ce);\r\n}\r\nvoid pm_clk_init(struct device *dev)\r\n{\r\nstruct pm_subsys_data *psd = dev_to_psd(dev);\r\nif (psd)\r\nINIT_LIST_HEAD(&psd->clock_list);\r\n}\r\nint pm_clk_create(struct device *dev)\r\n{\r\nreturn dev_pm_get_subsys_data(dev);\r\n}\r\nvoid pm_clk_destroy(struct device *dev)\r\n{\r\nstruct pm_subsys_data *psd = dev_to_psd(dev);\r\nstruct pm_clock_entry *ce, *c;\r\nstruct list_head list;\r\nif (!psd)\r\nreturn;\r\nINIT_LIST_HEAD(&list);\r\nspin_lock_irq(&psd->lock);\r\nlist_for_each_entry_safe_reverse(ce, c, &psd->clock_list, node)\r\nlist_move(&ce->node, &list);\r\nspin_unlock_irq(&psd->lock);\r\ndev_pm_put_subsys_data(dev);\r\nlist_for_each_entry_safe_reverse(ce, c, &list, node) {\r\nlist_del(&ce->node);\r\n__pm_clk_remove(ce);\r\n}\r\n}\r\nint pm_clk_suspend(struct device *dev)\r\n{\r\nstruct pm_subsys_data *psd = dev_to_psd(dev);\r\nstruct pm_clock_entry *ce;\r\nunsigned long flags;\r\ndev_dbg(dev, "%s()\n", __func__);\r\nif (!psd)\r\nreturn 0;\r\nspin_lock_irqsave(&psd->lock, flags);\r\nlist_for_each_entry_reverse(ce, &psd->clock_list, node) {\r\nif (ce->status < PCE_STATUS_ERROR) {\r\nif (ce->status == PCE_STATUS_ENABLED)\r\nclk_disable(ce->clk);\r\nce->status = PCE_STATUS_ACQUIRED;\r\n}\r\n}\r\nspin_unlock_irqrestore(&psd->lock, flags);\r\nreturn 0;\r\n}\r\nint pm_clk_resume(struct device *dev)\r\n{\r\nstruct pm_subsys_data *psd = dev_to_psd(dev);\r\nstruct pm_clock_entry *ce;\r\nunsigned long flags;\r\nint ret;\r\ndev_dbg(dev, "%s()\n", __func__);\r\nif (!psd)\r\nreturn 0;\r\nspin_lock_irqsave(&psd->lock, flags);\r\nlist_for_each_entry(ce, &psd->clock_list, node) {\r\nif (ce->status < PCE_STATUS_ERROR) {\r\nret = __pm_clk_enable(dev, ce->clk);\r\nif (!ret)\r\nce->status = PCE_STATUS_ENABLED;\r\n}\r\n}\r\nspin_unlock_irqrestore(&psd->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int pm_clk_notify(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct pm_clk_notifier_block *clknb;\r\nstruct device *dev = data;\r\nchar **con_id;\r\nint error;\r\ndev_dbg(dev, "%s() %ld\n", __func__, action);\r\nclknb = container_of(nb, struct pm_clk_notifier_block, nb);\r\nswitch (action) {\r\ncase BUS_NOTIFY_ADD_DEVICE:\r\nif (dev->pm_domain)\r\nbreak;\r\nerror = pm_clk_create(dev);\r\nif (error)\r\nbreak;\r\ndev->pm_domain = clknb->pm_domain;\r\nif (clknb->con_ids[0]) {\r\nfor (con_id = clknb->con_ids; *con_id; con_id++)\r\npm_clk_add(dev, *con_id);\r\n} else {\r\npm_clk_add(dev, NULL);\r\n}\r\nbreak;\r\ncase BUS_NOTIFY_DEL_DEVICE:\r\nif (dev->pm_domain != clknb->pm_domain)\r\nbreak;\r\ndev->pm_domain = NULL;\r\npm_clk_destroy(dev);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint pm_clk_suspend(struct device *dev)\r\n{\r\nstruct pm_subsys_data *psd = dev_to_psd(dev);\r\nstruct pm_clock_entry *ce;\r\nunsigned long flags;\r\ndev_dbg(dev, "%s()\n", __func__);\r\nif (!psd || !dev->driver)\r\nreturn 0;\r\nspin_lock_irqsave(&psd->lock, flags);\r\nlist_for_each_entry_reverse(ce, &psd->clock_list, node)\r\nclk_disable(ce->clk);\r\nspin_unlock_irqrestore(&psd->lock, flags);\r\nreturn 0;\r\n}\r\nint pm_clk_resume(struct device *dev)\r\n{\r\nstruct pm_subsys_data *psd = dev_to_psd(dev);\r\nstruct pm_clock_entry *ce;\r\nunsigned long flags;\r\ndev_dbg(dev, "%s()\n", __func__);\r\nif (!psd || !dev->driver)\r\nreturn 0;\r\nspin_lock_irqsave(&psd->lock, flags);\r\nlist_for_each_entry(ce, &psd->clock_list, node)\r\n__pm_clk_enable(dev, ce->clk);\r\nspin_unlock_irqrestore(&psd->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void enable_clock(struct device *dev, const char *con_id)\r\n{\r\nstruct clk *clk;\r\nclk = clk_get(dev, con_id);\r\nif (!IS_ERR(clk)) {\r\nclk_prepare_enable(clk);\r\nclk_put(clk);\r\ndev_info(dev, "Runtime PM disabled, clock forced on.\n");\r\n}\r\n}\r\nstatic void disable_clock(struct device *dev, const char *con_id)\r\n{\r\nstruct clk *clk;\r\nclk = clk_get(dev, con_id);\r\nif (!IS_ERR(clk)) {\r\nclk_disable_unprepare(clk);\r\nclk_put(clk);\r\ndev_info(dev, "Runtime PM disabled, clock forced off.\n");\r\n}\r\n}\r\nstatic int pm_clk_notify(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct pm_clk_notifier_block *clknb;\r\nstruct device *dev = data;\r\nchar **con_id;\r\ndev_dbg(dev, "%s() %ld\n", __func__, action);\r\nclknb = container_of(nb, struct pm_clk_notifier_block, nb);\r\nswitch (action) {\r\ncase BUS_NOTIFY_BIND_DRIVER:\r\nif (clknb->con_ids[0]) {\r\nfor (con_id = clknb->con_ids; *con_id; con_id++)\r\nenable_clock(dev, *con_id);\r\n} else {\r\nenable_clock(dev, NULL);\r\n}\r\nbreak;\r\ncase BUS_NOTIFY_UNBOUND_DRIVER:\r\nif (clknb->con_ids[0]) {\r\nfor (con_id = clknb->con_ids; *con_id; con_id++)\r\ndisable_clock(dev, *con_id);\r\n} else {\r\ndisable_clock(dev, NULL);\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid pm_clk_add_notifier(struct bus_type *bus,\r\nstruct pm_clk_notifier_block *clknb)\r\n{\r\nif (!bus || !clknb)\r\nreturn;\r\nclknb->nb.notifier_call = pm_clk_notify;\r\nbus_register_notifier(bus, &clknb->nb);\r\n}
