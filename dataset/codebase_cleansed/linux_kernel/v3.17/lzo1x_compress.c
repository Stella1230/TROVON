static noinline size_t\r\nlzo1x_1_do_compress(const unsigned char *in, size_t in_len,\r\nunsigned char *out, size_t *out_len,\r\nsize_t ti, void *wrkmem)\r\n{\r\nconst unsigned char *ip;\r\nunsigned char *op;\r\nconst unsigned char * const in_end = in + in_len;\r\nconst unsigned char * const ip_end = in + in_len - 20;\r\nconst unsigned char *ii;\r\nlzo_dict_t * const dict = (lzo_dict_t *) wrkmem;\r\nop = out;\r\nip = in;\r\nii = ip;\r\nip += ti < 4 ? 4 - ti : 0;\r\nfor (;;) {\r\nconst unsigned char *m_pos;\r\nsize_t t, m_len, m_off;\r\nu32 dv;\r\nliteral:\r\nip += 1 + ((ip - ii) >> 5);\r\nnext:\r\nif (unlikely(ip >= ip_end))\r\nbreak;\r\ndv = get_unaligned_le32(ip);\r\nt = ((dv * 0x1824429d) >> (32 - D_BITS)) & D_MASK;\r\nm_pos = in + dict[t];\r\ndict[t] = (lzo_dict_t) (ip - in);\r\nif (unlikely(dv != get_unaligned_le32(m_pos)))\r\ngoto literal;\r\nii -= ti;\r\nti = 0;\r\nt = ip - ii;\r\nif (t != 0) {\r\nif (t <= 3) {\r\nop[-2] |= t;\r\nCOPY4(op, ii);\r\nop += t;\r\n} else if (t <= 16) {\r\n*op++ = (t - 3);\r\nCOPY8(op, ii);\r\nCOPY8(op + 8, ii + 8);\r\nop += t;\r\n} else {\r\nif (t <= 18) {\r\n*op++ = (t - 3);\r\n} else {\r\nsize_t tt = t - 18;\r\n*op++ = 0;\r\nwhile (unlikely(tt > 255)) {\r\ntt -= 255;\r\n*op++ = 0;\r\n}\r\n*op++ = tt;\r\n}\r\ndo {\r\nCOPY8(op, ii);\r\nCOPY8(op + 8, ii + 8);\r\nop += 16;\r\nii += 16;\r\nt -= 16;\r\n} while (t >= 16);\r\nif (t > 0) do {\r\n*op++ = *ii++;\r\n} while (--t > 0);\r\n}\r\n}\r\nm_len = 4;\r\n{\r\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && defined(LZO_USE_CTZ64)\r\nu64 v;\r\nv = get_unaligned((const u64 *) (ip + m_len)) ^\r\nget_unaligned((const u64 *) (m_pos + m_len));\r\nif (unlikely(v == 0)) {\r\ndo {\r\nm_len += 8;\r\nv = get_unaligned((const u64 *) (ip + m_len)) ^\r\nget_unaligned((const u64 *) (m_pos + m_len));\r\nif (unlikely(ip + m_len >= ip_end))\r\ngoto m_len_done;\r\n} while (v == 0);\r\n}\r\n# if defined(__LITTLE_ENDIAN)\r\nm_len += (unsigned) __builtin_ctzll(v) / 8;\r\n# elif defined(__BIG_ENDIAN)\r\nm_len += (unsigned) __builtin_clzll(v) / 8;\r\n# else\r\n# error "missing endian definition"\r\n# endif\r\n#elif defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && defined(LZO_USE_CTZ32)\r\nu32 v;\r\nv = get_unaligned((const u32 *) (ip + m_len)) ^\r\nget_unaligned((const u32 *) (m_pos + m_len));\r\nif (unlikely(v == 0)) {\r\ndo {\r\nm_len += 4;\r\nv = get_unaligned((const u32 *) (ip + m_len)) ^\r\nget_unaligned((const u32 *) (m_pos + m_len));\r\nif (v != 0)\r\nbreak;\r\nm_len += 4;\r\nv = get_unaligned((const u32 *) (ip + m_len)) ^\r\nget_unaligned((const u32 *) (m_pos + m_len));\r\nif (unlikely(ip + m_len >= ip_end))\r\ngoto m_len_done;\r\n} while (v == 0);\r\n}\r\n# if defined(__LITTLE_ENDIAN)\r\nm_len += (unsigned) __builtin_ctz(v) / 8;\r\n# elif defined(__BIG_ENDIAN)\r\nm_len += (unsigned) __builtin_clz(v) / 8;\r\n# else\r\n# error "missing endian definition"\r\n# endif\r\n#else\r\nif (unlikely(ip[m_len] == m_pos[m_len])) {\r\ndo {\r\nm_len += 1;\r\nif (ip[m_len] != m_pos[m_len])\r\nbreak;\r\nm_len += 1;\r\nif (ip[m_len] != m_pos[m_len])\r\nbreak;\r\nm_len += 1;\r\nif (ip[m_len] != m_pos[m_len])\r\nbreak;\r\nm_len += 1;\r\nif (ip[m_len] != m_pos[m_len])\r\nbreak;\r\nm_len += 1;\r\nif (ip[m_len] != m_pos[m_len])\r\nbreak;\r\nm_len += 1;\r\nif (ip[m_len] != m_pos[m_len])\r\nbreak;\r\nm_len += 1;\r\nif (ip[m_len] != m_pos[m_len])\r\nbreak;\r\nm_len += 1;\r\nif (unlikely(ip + m_len >= ip_end))\r\ngoto m_len_done;\r\n} while (ip[m_len] == m_pos[m_len]);\r\n}\r\n#endif\r\n}\r\nm_len_done:\r\nm_off = ip - m_pos;\r\nip += m_len;\r\nii = ip;\r\nif (m_len <= M2_MAX_LEN && m_off <= M2_MAX_OFFSET) {\r\nm_off -= 1;\r\n*op++ = (((m_len - 1) << 5) | ((m_off & 7) << 2));\r\n*op++ = (m_off >> 3);\r\n} else if (m_off <= M3_MAX_OFFSET) {\r\nm_off -= 1;\r\nif (m_len <= M3_MAX_LEN)\r\n*op++ = (M3_MARKER | (m_len - 2));\r\nelse {\r\nm_len -= M3_MAX_LEN;\r\n*op++ = M3_MARKER | 0;\r\nwhile (unlikely(m_len > 255)) {\r\nm_len -= 255;\r\n*op++ = 0;\r\n}\r\n*op++ = (m_len);\r\n}\r\n*op++ = (m_off << 2);\r\n*op++ = (m_off >> 6);\r\n} else {\r\nm_off -= 0x4000;\r\nif (m_len <= M4_MAX_LEN)\r\n*op++ = (M4_MARKER | ((m_off >> 11) & 8)\r\n| (m_len - 2));\r\nelse {\r\nm_len -= M4_MAX_LEN;\r\n*op++ = (M4_MARKER | ((m_off >> 11) & 8));\r\nwhile (unlikely(m_len > 255)) {\r\nm_len -= 255;\r\n*op++ = 0;\r\n}\r\n*op++ = (m_len);\r\n}\r\n*op++ = (m_off << 2);\r\n*op++ = (m_off >> 6);\r\n}\r\ngoto next;\r\n}\r\n*out_len = op - out;\r\nreturn in_end - (ii - ti);\r\n}\r\nint lzo1x_1_compress(const unsigned char *in, size_t in_len,\r\nunsigned char *out, size_t *out_len,\r\nvoid *wrkmem)\r\n{\r\nconst unsigned char *ip = in;\r\nunsigned char *op = out;\r\nsize_t l = in_len;\r\nsize_t t = 0;\r\nwhile (l > 20) {\r\nsize_t ll = l <= (M4_MAX_OFFSET + 1) ? l : (M4_MAX_OFFSET + 1);\r\nuintptr_t ll_end = (uintptr_t) ip + ll;\r\nif ((ll_end + ((t + ll) >> 5)) <= ll_end)\r\nbreak;\r\nBUILD_BUG_ON(D_SIZE * sizeof(lzo_dict_t) > LZO1X_1_MEM_COMPRESS);\r\nmemset(wrkmem, 0, D_SIZE * sizeof(lzo_dict_t));\r\nt = lzo1x_1_do_compress(ip, ll, op, out_len, t, wrkmem);\r\nip += ll;\r\nop += *out_len;\r\nl -= ll;\r\n}\r\nt += l;\r\nif (t > 0) {\r\nconst unsigned char *ii = in + in_len - t;\r\nif (op == out && t <= 238) {\r\n*op++ = (17 + t);\r\n} else if (t <= 3) {\r\nop[-2] |= t;\r\n} else if (t <= 18) {\r\n*op++ = (t - 3);\r\n} else {\r\nsize_t tt = t - 18;\r\n*op++ = 0;\r\nwhile (tt > 255) {\r\ntt -= 255;\r\n*op++ = 0;\r\n}\r\n*op++ = tt;\r\n}\r\nif (t >= 16) do {\r\nCOPY8(op, ii);\r\nCOPY8(op + 8, ii + 8);\r\nop += 16;\r\nii += 16;\r\nt -= 16;\r\n} while (t >= 16);\r\nif (t > 0) do {\r\n*op++ = *ii++;\r\n} while (--t > 0);\r\n}\r\n*op++ = M4_MARKER | 1;\r\n*op++ = 0;\r\n*op++ = 0;\r\n*out_len = op - out;\r\nreturn LZO_E_OK;\r\n}
