static void comm_str__get(struct comm_str *cs)\r\n{\r\ncs->ref++;\r\n}\r\nstatic void comm_str__put(struct comm_str *cs)\r\n{\r\nif (!--cs->ref) {\r\nrb_erase(&cs->rb_node, &comm_str_root);\r\nzfree(&cs->str);\r\nfree(cs);\r\n}\r\n}\r\nstatic struct comm_str *comm_str__alloc(const char *str)\r\n{\r\nstruct comm_str *cs;\r\ncs = zalloc(sizeof(*cs));\r\nif (!cs)\r\nreturn NULL;\r\ncs->str = strdup(str);\r\nif (!cs->str) {\r\nfree(cs);\r\nreturn NULL;\r\n}\r\nreturn cs;\r\n}\r\nstatic struct comm_str *comm_str__findnew(const char *str, struct rb_root *root)\r\n{\r\nstruct rb_node **p = &root->rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct comm_str *iter, *new;\r\nint cmp;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\niter = rb_entry(parent, struct comm_str, rb_node);\r\ncmp = strcmp(str, iter->str);\r\nif (!cmp)\r\nreturn iter;\r\nif (cmp < 0)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\nnew = comm_str__alloc(str);\r\nif (!new)\r\nreturn NULL;\r\nrb_link_node(&new->rb_node, parent, p);\r\nrb_insert_color(&new->rb_node, root);\r\nreturn new;\r\n}\r\nstruct comm *comm__new(const char *str, u64 timestamp)\r\n{\r\nstruct comm *comm = zalloc(sizeof(*comm));\r\nif (!comm)\r\nreturn NULL;\r\ncomm->start = timestamp;\r\ncomm->comm_str = comm_str__findnew(str, &comm_str_root);\r\nif (!comm->comm_str) {\r\nfree(comm);\r\nreturn NULL;\r\n}\r\ncomm_str__get(comm->comm_str);\r\nreturn comm;\r\n}\r\nint comm__override(struct comm *comm, const char *str, u64 timestamp)\r\n{\r\nstruct comm_str *new, *old = comm->comm_str;\r\nnew = comm_str__findnew(str, &comm_str_root);\r\nif (!new)\r\nreturn -ENOMEM;\r\ncomm_str__get(new);\r\ncomm_str__put(old);\r\ncomm->comm_str = new;\r\ncomm->start = timestamp;\r\nreturn 0;\r\n}\r\nvoid comm__free(struct comm *comm)\r\n{\r\ncomm_str__put(comm->comm_str);\r\nfree(comm);\r\n}\r\nconst char *comm__str(const struct comm *comm)\r\n{\r\nreturn comm->comm_str->str;\r\n}
