const char *gcov_info_filename(struct gcov_info *info)\r\n{\r\nreturn info->filename;\r\n}\r\nunsigned int gcov_info_version(struct gcov_info *info)\r\n{\r\nreturn info->version;\r\n}\r\nstruct gcov_info *gcov_info_next(struct gcov_info *info)\r\n{\r\nif (!info)\r\nreturn gcov_info_head;\r\nreturn info->next;\r\n}\r\nvoid gcov_info_link(struct gcov_info *info)\r\n{\r\ninfo->next = gcov_info_head;\r\ngcov_info_head = info;\r\n}\r\nvoid gcov_info_unlink(struct gcov_info *prev, struct gcov_info *info)\r\n{\r\nif (prev)\r\nprev->next = info->next;\r\nelse\r\ngcov_info_head = info->next;\r\n}\r\nstatic int counter_active(struct gcov_info *info, unsigned int type)\r\n{\r\nreturn info->merge[type] ? 1 : 0;\r\n}\r\nstatic unsigned int num_counter_active(struct gcov_info *info)\r\n{\r\nunsigned int i;\r\nunsigned int result = 0;\r\nfor (i = 0; i < GCOV_COUNTERS; i++) {\r\nif (counter_active(info, i))\r\nresult++;\r\n}\r\nreturn result;\r\n}\r\nvoid gcov_info_reset(struct gcov_info *info)\r\n{\r\nstruct gcov_ctr_info *ci_ptr;\r\nunsigned int fi_idx;\r\nunsigned int ct_idx;\r\nfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\r\nci_ptr = info->functions[fi_idx]->ctrs;\r\nfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\r\nif (!counter_active(info, ct_idx))\r\ncontinue;\r\nmemset(ci_ptr->values, 0,\r\nsizeof(gcov_type) * ci_ptr->num);\r\nci_ptr++;\r\n}\r\n}\r\n}\r\nint gcov_info_is_compatible(struct gcov_info *info1, struct gcov_info *info2)\r\n{\r\nreturn (info1->stamp == info2->stamp);\r\n}\r\nvoid gcov_info_add(struct gcov_info *dst, struct gcov_info *src)\r\n{\r\nstruct gcov_ctr_info *dci_ptr;\r\nstruct gcov_ctr_info *sci_ptr;\r\nunsigned int fi_idx;\r\nunsigned int ct_idx;\r\nunsigned int val_idx;\r\nfor (fi_idx = 0; fi_idx < src->n_functions; fi_idx++) {\r\ndci_ptr = dst->functions[fi_idx]->ctrs;\r\nsci_ptr = src->functions[fi_idx]->ctrs;\r\nfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\r\nif (!counter_active(src, ct_idx))\r\ncontinue;\r\nfor (val_idx = 0; val_idx < sci_ptr->num; val_idx++)\r\ndci_ptr->values[val_idx] +=\r\nsci_ptr->values[val_idx];\r\ndci_ptr++;\r\nsci_ptr++;\r\n}\r\n}\r\n}\r\nstruct gcov_info *gcov_info_dup(struct gcov_info *info)\r\n{\r\nstruct gcov_info *dup;\r\nstruct gcov_ctr_info *dci_ptr;\r\nstruct gcov_ctr_info *sci_ptr;\r\nunsigned int active;\r\nunsigned int fi_idx;\r\nunsigned int ct_idx;\r\nsize_t fi_size;\r\nsize_t cv_size;\r\ndup = kmemdup(info, sizeof(*dup), GFP_KERNEL);\r\nif (!dup)\r\nreturn NULL;\r\ndup->next = NULL;\r\ndup->filename = NULL;\r\ndup->functions = NULL;\r\ndup->filename = kstrdup(info->filename, GFP_KERNEL);\r\nif (!dup->filename)\r\ngoto err_free;\r\ndup->functions = kcalloc(info->n_functions,\r\nsizeof(struct gcov_fn_info *), GFP_KERNEL);\r\nif (!dup->functions)\r\ngoto err_free;\r\nactive = num_counter_active(info);\r\nfi_size = sizeof(struct gcov_fn_info);\r\nfi_size += sizeof(struct gcov_ctr_info) * active;\r\nfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\r\ndup->functions[fi_idx] = kzalloc(fi_size, GFP_KERNEL);\r\nif (!dup->functions[fi_idx])\r\ngoto err_free;\r\n*(dup->functions[fi_idx]) = *(info->functions[fi_idx]);\r\nsci_ptr = info->functions[fi_idx]->ctrs;\r\ndci_ptr = dup->functions[fi_idx]->ctrs;\r\nfor (ct_idx = 0; ct_idx < active; ct_idx++) {\r\ncv_size = sizeof(gcov_type) * sci_ptr->num;\r\ndci_ptr->values = vmalloc(cv_size);\r\nif (!dci_ptr->values)\r\ngoto err_free;\r\ndci_ptr->num = sci_ptr->num;\r\nmemcpy(dci_ptr->values, sci_ptr->values, cv_size);\r\nsci_ptr++;\r\ndci_ptr++;\r\n}\r\n}\r\nreturn dup;\r\nerr_free:\r\ngcov_info_free(dup);\r\nreturn NULL;\r\n}\r\nvoid gcov_info_free(struct gcov_info *info)\r\n{\r\nunsigned int active;\r\nunsigned int fi_idx;\r\nunsigned int ct_idx;\r\nstruct gcov_ctr_info *ci_ptr;\r\nif (!info->functions)\r\ngoto free_info;\r\nactive = num_counter_active(info);\r\nfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\r\nif (!info->functions[fi_idx])\r\ncontinue;\r\nci_ptr = info->functions[fi_idx]->ctrs;\r\nfor (ct_idx = 0; ct_idx < active; ct_idx++, ci_ptr++)\r\nvfree(ci_ptr->values);\r\nkfree(info->functions[fi_idx]);\r\n}\r\nfree_info:\r\nkfree(info->functions);\r\nkfree(info->filename);\r\nkfree(info);\r\n}\r\nstatic size_t store_gcov_u32(void *buffer, size_t off, u32 v)\r\n{\r\nu32 *data;\r\nif (buffer) {\r\ndata = buffer + off;\r\n*data = v;\r\n}\r\nreturn sizeof(*data);\r\n}\r\nstatic size_t store_gcov_u64(void *buffer, size_t off, u64 v)\r\n{\r\nu32 *data;\r\nif (buffer) {\r\ndata = buffer + off;\r\ndata[0] = (v & 0xffffffffUL);\r\ndata[1] = (v >> 32);\r\n}\r\nreturn sizeof(*data) * 2;\r\n}\r\nstatic size_t convert_to_gcda(char *buffer, struct gcov_info *info)\r\n{\r\nstruct gcov_fn_info *fi_ptr;\r\nstruct gcov_ctr_info *ci_ptr;\r\nunsigned int fi_idx;\r\nunsigned int ct_idx;\r\nunsigned int cv_idx;\r\nsize_t pos = 0;\r\npos += store_gcov_u32(buffer, pos, GCOV_DATA_MAGIC);\r\npos += store_gcov_u32(buffer, pos, info->version);\r\npos += store_gcov_u32(buffer, pos, info->stamp);\r\nfor (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {\r\nfi_ptr = info->functions[fi_idx];\r\npos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION);\r\npos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION_LENGTH);\r\npos += store_gcov_u32(buffer, pos, fi_ptr->ident);\r\npos += store_gcov_u32(buffer, pos, fi_ptr->lineno_checksum);\r\npos += store_gcov_u32(buffer, pos, fi_ptr->cfg_checksum);\r\nci_ptr = fi_ptr->ctrs;\r\nfor (ct_idx = 0; ct_idx < GCOV_COUNTERS; ct_idx++) {\r\nif (!counter_active(info, ct_idx))\r\ncontinue;\r\npos += store_gcov_u32(buffer, pos,\r\nGCOV_TAG_FOR_COUNTER(ct_idx));\r\npos += store_gcov_u32(buffer, pos, ci_ptr->num * 2);\r\nfor (cv_idx = 0; cv_idx < ci_ptr->num; cv_idx++) {\r\npos += store_gcov_u64(buffer, pos,\r\nci_ptr->values[cv_idx]);\r\n}\r\nci_ptr++;\r\n}\r\n}\r\nreturn pos;\r\n}\r\nstruct gcov_iterator *gcov_iter_new(struct gcov_info *info)\r\n{\r\nstruct gcov_iterator *iter;\r\niter = kzalloc(sizeof(struct gcov_iterator), GFP_KERNEL);\r\nif (!iter)\r\ngoto err_free;\r\niter->info = info;\r\niter->size = convert_to_gcda(NULL, info);\r\niter->buffer = vmalloc(iter->size);\r\nif (!iter->buffer)\r\ngoto err_free;\r\nconvert_to_gcda(iter->buffer, info);\r\nreturn iter;\r\nerr_free:\r\nkfree(iter);\r\nreturn NULL;\r\n}\r\nvoid gcov_iter_free(struct gcov_iterator *iter)\r\n{\r\nvfree(iter->buffer);\r\nkfree(iter);\r\n}\r\nstruct gcov_info *gcov_iter_get_info(struct gcov_iterator *iter)\r\n{\r\nreturn iter->info;\r\n}\r\nvoid gcov_iter_start(struct gcov_iterator *iter)\r\n{\r\niter->pos = 0;\r\n}\r\nint gcov_iter_next(struct gcov_iterator *iter)\r\n{\r\nif (iter->pos < iter->size)\r\niter->pos += ITER_STRIDE;\r\nif (iter->pos >= iter->size)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint gcov_iter_write(struct gcov_iterator *iter, struct seq_file *seq)\r\n{\r\nsize_t len;\r\nif (iter->pos >= iter->size)\r\nreturn -EINVAL;\r\nlen = ITER_STRIDE;\r\nif (iter->pos + len > iter->size)\r\nlen = iter->size - iter->pos;\r\nseq_write(seq, iter->buffer + iter->pos, len);\r\nreturn 0;\r\n}
