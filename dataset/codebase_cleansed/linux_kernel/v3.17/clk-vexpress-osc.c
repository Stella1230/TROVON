static unsigned long vexpress_osc_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct vexpress_osc *osc = to_vexpress_osc(hw);\r\nu32 rate;\r\nregmap_read(osc->reg, 0, &rate);\r\nreturn rate;\r\n}\r\nstatic long vexpress_osc_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct vexpress_osc *osc = to_vexpress_osc(hw);\r\nif (WARN_ON(osc->rate_min && rate < osc->rate_min))\r\nrate = osc->rate_min;\r\nif (WARN_ON(osc->rate_max && rate > osc->rate_max))\r\nrate = osc->rate_max;\r\nreturn rate;\r\n}\r\nstatic int vexpress_osc_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct vexpress_osc *osc = to_vexpress_osc(hw);\r\nreturn regmap_write(osc->reg, 0, rate);\r\n}\r\nstatic int vexpress_osc_probe(struct platform_device *pdev)\r\n{\r\nstruct clk_lookup *cl = pdev->dev.platform_data;\r\nstruct clk_init_data init;\r\nstruct vexpress_osc *osc;\r\nstruct clk *clk;\r\nu32 range[2];\r\nosc = devm_kzalloc(&pdev->dev, sizeof(*osc), GFP_KERNEL);\r\nif (!osc)\r\nreturn -ENOMEM;\r\nosc->reg = devm_regmap_init_vexpress_config(&pdev->dev);\r\nif (IS_ERR(osc->reg))\r\nreturn PTR_ERR(osc->reg);\r\nif (of_property_read_u32_array(pdev->dev.of_node, "freq-range", range,\r\nARRAY_SIZE(range)) == 0) {\r\nosc->rate_min = range[0];\r\nosc->rate_max = range[1];\r\n}\r\nif (of_property_read_string(pdev->dev.of_node, "clock-output-names",\r\n&init.name) != 0)\r\ninit.name = dev_name(&pdev->dev);\r\ninit.ops = &vexpress_osc_ops;\r\ninit.flags = CLK_IS_ROOT;\r\ninit.num_parents = 0;\r\nosc->hw.init = &init;\r\nclk = clk_register(NULL, &osc->hw);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nof_clk_add_provider(pdev->dev.of_node, of_clk_src_simple_get, clk);\r\nif (cl) {\r\ncl->clk = clk;\r\nclkdev_add(cl);\r\n}\r\ndev_dbg(&pdev->dev, "Registered clock '%s'\n", init.name);\r\nreturn 0;\r\n}\r\nstatic int __init vexpress_osc_init(void)\r\n{\r\nreturn platform_driver_register(&vexpress_osc_driver);\r\n}
