u32 ethtool_op_get_link(struct net_device *dev)\r\n{\r\nreturn netif_carrier_ok(dev) ? 1 : 0;\r\n}\r\nint ethtool_op_get_ts_info(struct net_device *dev, struct ethtool_ts_info *info)\r\n{\r\ninfo->so_timestamping =\r\nSOF_TIMESTAMPING_TX_SOFTWARE |\r\nSOF_TIMESTAMPING_RX_SOFTWARE |\r\nSOF_TIMESTAMPING_SOFTWARE;\r\ninfo->phc_index = -1;\r\nreturn 0;\r\n}\r\nstatic int ethtool_get_features(struct net_device *dev, void __user *useraddr)\r\n{\r\nstruct ethtool_gfeatures cmd = {\r\n.cmd = ETHTOOL_GFEATURES,\r\n.size = ETHTOOL_DEV_FEATURE_WORDS,\r\n};\r\nstruct ethtool_get_features_block features[ETHTOOL_DEV_FEATURE_WORDS];\r\nu32 __user *sizeaddr;\r\nu32 copy_size;\r\nint i;\r\nBUILD_BUG_ON(ETHTOOL_DEV_FEATURE_WORDS * sizeof(u32) > sizeof(netdev_features_t));\r\nfor (i = 0; i < ETHTOOL_DEV_FEATURE_WORDS; ++i) {\r\nfeatures[i].available = (u32)(dev->hw_features >> (32 * i));\r\nfeatures[i].requested = (u32)(dev->wanted_features >> (32 * i));\r\nfeatures[i].active = (u32)(dev->features >> (32 * i));\r\nfeatures[i].never_changed =\r\n(u32)(NETIF_F_NEVER_CHANGE >> (32 * i));\r\n}\r\nsizeaddr = useraddr + offsetof(struct ethtool_gfeatures, size);\r\nif (get_user(copy_size, sizeaddr))\r\nreturn -EFAULT;\r\nif (copy_size > ETHTOOL_DEV_FEATURE_WORDS)\r\ncopy_size = ETHTOOL_DEV_FEATURE_WORDS;\r\nif (copy_to_user(useraddr, &cmd, sizeof(cmd)))\r\nreturn -EFAULT;\r\nuseraddr += sizeof(cmd);\r\nif (copy_to_user(useraddr, features, copy_size * sizeof(*features)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ethtool_set_features(struct net_device *dev, void __user *useraddr)\r\n{\r\nstruct ethtool_sfeatures cmd;\r\nstruct ethtool_set_features_block features[ETHTOOL_DEV_FEATURE_WORDS];\r\nnetdev_features_t wanted = 0, valid = 0;\r\nint i, ret = 0;\r\nif (copy_from_user(&cmd, useraddr, sizeof(cmd)))\r\nreturn -EFAULT;\r\nuseraddr += sizeof(cmd);\r\nif (cmd.size != ETHTOOL_DEV_FEATURE_WORDS)\r\nreturn -EINVAL;\r\nif (copy_from_user(features, useraddr, sizeof(features)))\r\nreturn -EFAULT;\r\nfor (i = 0; i < ETHTOOL_DEV_FEATURE_WORDS; ++i) {\r\nvalid |= (netdev_features_t)features[i].valid << (32 * i);\r\nwanted |= (netdev_features_t)features[i].requested << (32 * i);\r\n}\r\nif (valid & ~NETIF_F_ETHTOOL_BITS)\r\nreturn -EINVAL;\r\nif (valid & ~dev->hw_features) {\r\nvalid &= dev->hw_features;\r\nret |= ETHTOOL_F_UNSUPPORTED;\r\n}\r\ndev->wanted_features &= ~valid;\r\ndev->wanted_features |= wanted & valid;\r\n__netdev_update_features(dev);\r\nif ((dev->wanted_features ^ dev->features) & valid)\r\nret |= ETHTOOL_F_WISH;\r\nreturn ret;\r\n}\r\nstatic int __ethtool_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nconst struct ethtool_ops *ops = dev->ethtool_ops;\r\nif (sset == ETH_SS_FEATURES)\r\nreturn ARRAY_SIZE(netdev_features_strings);\r\nif (ops->get_sset_count && ops->get_strings)\r\nreturn ops->get_sset_count(dev, sset);\r\nelse\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void __ethtool_get_strings(struct net_device *dev,\r\nu32 stringset, u8 *data)\r\n{\r\nconst struct ethtool_ops *ops = dev->ethtool_ops;\r\nif (stringset == ETH_SS_FEATURES)\r\nmemcpy(data, netdev_features_strings,\r\nsizeof(netdev_features_strings));\r\nelse\r\nops->get_strings(dev, stringset, data);\r\n}\r\nstatic netdev_features_t ethtool_get_feature_mask(u32 eth_cmd)\r\n{\r\nswitch (eth_cmd) {\r\ncase ETHTOOL_GTXCSUM:\r\ncase ETHTOOL_STXCSUM:\r\nreturn NETIF_F_ALL_CSUM | NETIF_F_SCTP_CSUM;\r\ncase ETHTOOL_GRXCSUM:\r\ncase ETHTOOL_SRXCSUM:\r\nreturn NETIF_F_RXCSUM;\r\ncase ETHTOOL_GSG:\r\ncase ETHTOOL_SSG:\r\nreturn NETIF_F_SG;\r\ncase ETHTOOL_GTSO:\r\ncase ETHTOOL_STSO:\r\nreturn NETIF_F_ALL_TSO;\r\ncase ETHTOOL_GUFO:\r\ncase ETHTOOL_SUFO:\r\nreturn NETIF_F_UFO;\r\ncase ETHTOOL_GGSO:\r\ncase ETHTOOL_SGSO:\r\nreturn NETIF_F_GSO;\r\ncase ETHTOOL_GGRO:\r\ncase ETHTOOL_SGRO:\r\nreturn NETIF_F_GRO;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic int ethtool_get_one_feature(struct net_device *dev,\r\nchar __user *useraddr, u32 ethcmd)\r\n{\r\nnetdev_features_t mask = ethtool_get_feature_mask(ethcmd);\r\nstruct ethtool_value edata = {\r\n.cmd = ethcmd,\r\n.data = !!(dev->features & mask),\r\n};\r\nif (copy_to_user(useraddr, &edata, sizeof(edata)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ethtool_set_one_feature(struct net_device *dev,\r\nvoid __user *useraddr, u32 ethcmd)\r\n{\r\nstruct ethtool_value edata;\r\nnetdev_features_t mask;\r\nif (copy_from_user(&edata, useraddr, sizeof(edata)))\r\nreturn -EFAULT;\r\nmask = ethtool_get_feature_mask(ethcmd);\r\nmask &= dev->hw_features;\r\nif (!mask)\r\nreturn -EOPNOTSUPP;\r\nif (edata.data)\r\ndev->wanted_features |= mask;\r\nelse\r\ndev->wanted_features &= ~mask;\r\n__netdev_update_features(dev);\r\nreturn 0;\r\n}\r\nstatic u32 __ethtool_get_flags(struct net_device *dev)\r\n{\r\nu32 flags = 0;\r\nif (dev->features & NETIF_F_LRO)\r\nflags |= ETH_FLAG_LRO;\r\nif (dev->features & NETIF_F_HW_VLAN_CTAG_RX)\r\nflags |= ETH_FLAG_RXVLAN;\r\nif (dev->features & NETIF_F_HW_VLAN_CTAG_TX)\r\nflags |= ETH_FLAG_TXVLAN;\r\nif (dev->features & NETIF_F_NTUPLE)\r\nflags |= ETH_FLAG_NTUPLE;\r\nif (dev->features & NETIF_F_RXHASH)\r\nflags |= ETH_FLAG_RXHASH;\r\nreturn flags;\r\n}\r\nstatic int __ethtool_set_flags(struct net_device *dev, u32 data)\r\n{\r\nnetdev_features_t features = 0, changed;\r\nif (data & ~ETH_ALL_FLAGS)\r\nreturn -EINVAL;\r\nif (data & ETH_FLAG_LRO)\r\nfeatures |= NETIF_F_LRO;\r\nif (data & ETH_FLAG_RXVLAN)\r\nfeatures |= NETIF_F_HW_VLAN_CTAG_RX;\r\nif (data & ETH_FLAG_TXVLAN)\r\nfeatures |= NETIF_F_HW_VLAN_CTAG_TX;\r\nif (data & ETH_FLAG_NTUPLE)\r\nfeatures |= NETIF_F_NTUPLE;\r\nif (data & ETH_FLAG_RXHASH)\r\nfeatures |= NETIF_F_RXHASH;\r\nchanged = (features ^ dev->features) & ETH_ALL_FEATURES;\r\nif (changed & ~dev->hw_features)\r\nreturn (changed & dev->hw_features) ? -EINVAL : -EOPNOTSUPP;\r\ndev->wanted_features =\r\n(dev->wanted_features & ~changed) | (features & changed);\r\n__netdev_update_features(dev);\r\nreturn 0;\r\n}\r\nint __ethtool_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nASSERT_RTNL();\r\nif (!dev->ethtool_ops->get_settings)\r\nreturn -EOPNOTSUPP;\r\nmemset(cmd, 0, sizeof(struct ethtool_cmd));\r\ncmd->cmd = ETHTOOL_GSET;\r\nreturn dev->ethtool_ops->get_settings(dev, cmd);\r\n}\r\nstatic int ethtool_get_settings(struct net_device *dev, void __user *useraddr)\r\n{\r\nint err;\r\nstruct ethtool_cmd cmd;\r\nerr = __ethtool_get_settings(dev, &cmd);\r\nif (err < 0)\r\nreturn err;\r\nif (copy_to_user(useraddr, &cmd, sizeof(cmd)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ethtool_set_settings(struct net_device *dev, void __user *useraddr)\r\n{\r\nstruct ethtool_cmd cmd;\r\nif (!dev->ethtool_ops->set_settings)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&cmd, useraddr, sizeof(cmd)))\r\nreturn -EFAULT;\r\nreturn dev->ethtool_ops->set_settings(dev, &cmd);\r\n}\r\nstatic noinline_for_stack int ethtool_get_drvinfo(struct net_device *dev,\r\nvoid __user *useraddr)\r\n{\r\nstruct ethtool_drvinfo info;\r\nconst struct ethtool_ops *ops = dev->ethtool_ops;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.cmd = ETHTOOL_GDRVINFO;\r\nif (ops->get_drvinfo) {\r\nops->get_drvinfo(dev, &info);\r\n} else if (dev->dev.parent && dev->dev.parent->driver) {\r\nstrlcpy(info.bus_info, dev_name(dev->dev.parent),\r\nsizeof(info.bus_info));\r\nstrlcpy(info.driver, dev->dev.parent->driver->name,\r\nsizeof(info.driver));\r\n} else {\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (ops->get_sset_count) {\r\nint rc;\r\nrc = ops->get_sset_count(dev, ETH_SS_TEST);\r\nif (rc >= 0)\r\ninfo.testinfo_len = rc;\r\nrc = ops->get_sset_count(dev, ETH_SS_STATS);\r\nif (rc >= 0)\r\ninfo.n_stats = rc;\r\nrc = ops->get_sset_count(dev, ETH_SS_PRIV_FLAGS);\r\nif (rc >= 0)\r\ninfo.n_priv_flags = rc;\r\n}\r\nif (ops->get_regs_len)\r\ninfo.regdump_len = ops->get_regs_len(dev);\r\nif (ops->get_eeprom_len)\r\ninfo.eedump_len = ops->get_eeprom_len(dev);\r\nif (copy_to_user(useraddr, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic noinline_for_stack int ethtool_get_sset_info(struct net_device *dev,\r\nvoid __user *useraddr)\r\n{\r\nstruct ethtool_sset_info info;\r\nu64 sset_mask;\r\nint i, idx = 0, n_bits = 0, ret, rc;\r\nu32 *info_buf = NULL;\r\nif (copy_from_user(&info, useraddr, sizeof(info)))\r\nreturn -EFAULT;\r\nsset_mask = info.sset_mask;\r\nif (!sset_mask)\r\nreturn 0;\r\nn_bits = hweight64(sset_mask);\r\nmemset(&info, 0, sizeof(info));\r\ninfo.cmd = ETHTOOL_GSSET_INFO;\r\ninfo_buf = kzalloc(n_bits * sizeof(u32), GFP_USER);\r\nif (!info_buf)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < 64; i++) {\r\nif (!(sset_mask & (1ULL << i)))\r\ncontinue;\r\nrc = __ethtool_get_sset_count(dev, i);\r\nif (rc >= 0) {\r\ninfo.sset_mask |= (1ULL << i);\r\ninfo_buf[idx++] = rc;\r\n}\r\n}\r\nret = -EFAULT;\r\nif (copy_to_user(useraddr, &info, sizeof(info)))\r\ngoto out;\r\nuseraddr += offsetof(struct ethtool_sset_info, data);\r\nif (copy_to_user(useraddr, info_buf, idx * sizeof(u32)))\r\ngoto out;\r\nret = 0;\r\nout:\r\nkfree(info_buf);\r\nreturn ret;\r\n}\r\nstatic noinline_for_stack int ethtool_set_rxnfc(struct net_device *dev,\r\nu32 cmd, void __user *useraddr)\r\n{\r\nstruct ethtool_rxnfc info;\r\nsize_t info_size = sizeof(info);\r\nint rc;\r\nif (!dev->ethtool_ops->set_rxnfc)\r\nreturn -EOPNOTSUPP;\r\nif (cmd == ETHTOOL_SRXFH)\r\ninfo_size = (offsetof(struct ethtool_rxnfc, data) +\r\nsizeof(info.data));\r\nif (copy_from_user(&info, useraddr, info_size))\r\nreturn -EFAULT;\r\nrc = dev->ethtool_ops->set_rxnfc(dev, &info);\r\nif (rc)\r\nreturn rc;\r\nif (cmd == ETHTOOL_SRXCLSRLINS &&\r\ncopy_to_user(useraddr, &info, info_size))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic noinline_for_stack int ethtool_get_rxnfc(struct net_device *dev,\r\nu32 cmd, void __user *useraddr)\r\n{\r\nstruct ethtool_rxnfc info;\r\nsize_t info_size = sizeof(info);\r\nconst struct ethtool_ops *ops = dev->ethtool_ops;\r\nint ret;\r\nvoid *rule_buf = NULL;\r\nif (!ops->get_rxnfc)\r\nreturn -EOPNOTSUPP;\r\nif (cmd == ETHTOOL_GRXFH)\r\ninfo_size = (offsetof(struct ethtool_rxnfc, data) +\r\nsizeof(info.data));\r\nif (copy_from_user(&info, useraddr, info_size))\r\nreturn -EFAULT;\r\nif (info.cmd == ETHTOOL_GRXCLSRLALL) {\r\nif (info.rule_cnt > 0) {\r\nif (info.rule_cnt <= KMALLOC_MAX_SIZE / sizeof(u32))\r\nrule_buf = kzalloc(info.rule_cnt * sizeof(u32),\r\nGFP_USER);\r\nif (!rule_buf)\r\nreturn -ENOMEM;\r\n}\r\n}\r\nret = ops->get_rxnfc(dev, &info, rule_buf);\r\nif (ret < 0)\r\ngoto err_out;\r\nret = -EFAULT;\r\nif (copy_to_user(useraddr, &info, info_size))\r\ngoto err_out;\r\nif (rule_buf) {\r\nuseraddr += offsetof(struct ethtool_rxnfc, rule_locs);\r\nif (copy_to_user(useraddr, rule_buf,\r\ninfo.rule_cnt * sizeof(u32)))\r\ngoto err_out;\r\n}\r\nret = 0;\r\nerr_out:\r\nkfree(rule_buf);\r\nreturn ret;\r\n}\r\nstatic int ethtool_copy_validate_indir(u32 *indir, void __user *useraddr,\r\nstruct ethtool_rxnfc *rx_rings,\r\nu32 size)\r\n{\r\nint i;\r\nif (copy_from_user(indir, useraddr, size * sizeof(indir[0])))\r\nreturn -EFAULT;\r\nfor (i = 0; i < size; i++)\r\nif (indir[i] >= rx_rings->data)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic noinline_for_stack int ethtool_get_rxfh_indir(struct net_device *dev,\r\nvoid __user *useraddr)\r\n{\r\nu32 user_size, dev_size;\r\nu32 *indir;\r\nint ret;\r\nif (!dev->ethtool_ops->get_rxfh_indir_size ||\r\n!dev->ethtool_ops->get_rxfh)\r\nreturn -EOPNOTSUPP;\r\ndev_size = dev->ethtool_ops->get_rxfh_indir_size(dev);\r\nif (dev_size == 0)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&user_size,\r\nuseraddr + offsetof(struct ethtool_rxfh_indir, size),\r\nsizeof(user_size)))\r\nreturn -EFAULT;\r\nif (copy_to_user(useraddr + offsetof(struct ethtool_rxfh_indir, size),\r\n&dev_size, sizeof(dev_size)))\r\nreturn -EFAULT;\r\nif (user_size < dev_size)\r\nreturn user_size == 0 ? 0 : -EINVAL;\r\nindir = kcalloc(dev_size, sizeof(indir[0]), GFP_USER);\r\nif (!indir)\r\nreturn -ENOMEM;\r\nret = dev->ethtool_ops->get_rxfh(dev, indir, NULL);\r\nif (ret)\r\ngoto out;\r\nif (copy_to_user(useraddr +\r\noffsetof(struct ethtool_rxfh_indir, ring_index[0]),\r\nindir, dev_size * sizeof(indir[0])))\r\nret = -EFAULT;\r\nout:\r\nkfree(indir);\r\nreturn ret;\r\n}\r\nstatic noinline_for_stack int ethtool_set_rxfh_indir(struct net_device *dev,\r\nvoid __user *useraddr)\r\n{\r\nstruct ethtool_rxnfc rx_rings;\r\nu32 user_size, dev_size, i;\r\nu32 *indir;\r\nconst struct ethtool_ops *ops = dev->ethtool_ops;\r\nint ret;\r\nu32 ringidx_offset = offsetof(struct ethtool_rxfh_indir, ring_index[0]);\r\nif (!ops->get_rxfh_indir_size || !ops->set_rxfh ||\r\n!ops->get_rxnfc)\r\nreturn -EOPNOTSUPP;\r\ndev_size = ops->get_rxfh_indir_size(dev);\r\nif (dev_size == 0)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&user_size,\r\nuseraddr + offsetof(struct ethtool_rxfh_indir, size),\r\nsizeof(user_size)))\r\nreturn -EFAULT;\r\nif (user_size != 0 && user_size != dev_size)\r\nreturn -EINVAL;\r\nindir = kcalloc(dev_size, sizeof(indir[0]), GFP_USER);\r\nif (!indir)\r\nreturn -ENOMEM;\r\nrx_rings.cmd = ETHTOOL_GRXRINGS;\r\nret = ops->get_rxnfc(dev, &rx_rings, NULL);\r\nif (ret)\r\ngoto out;\r\nif (user_size == 0) {\r\nfor (i = 0; i < dev_size; i++)\r\nindir[i] = ethtool_rxfh_indir_default(i, rx_rings.data);\r\n} else {\r\nret = ethtool_copy_validate_indir(indir,\r\nuseraddr + ringidx_offset,\r\n&rx_rings,\r\ndev_size);\r\nif (ret)\r\ngoto out;\r\n}\r\nret = ops->set_rxfh(dev, indir, NULL);\r\nout:\r\nkfree(indir);\r\nreturn ret;\r\n}\r\nstatic noinline_for_stack int ethtool_get_rxfh(struct net_device *dev,\r\nvoid __user *useraddr)\r\n{\r\nint ret;\r\nconst struct ethtool_ops *ops = dev->ethtool_ops;\r\nu32 user_indir_size, user_key_size;\r\nu32 dev_indir_size = 0, dev_key_size = 0;\r\nstruct ethtool_rxfh rxfh;\r\nu32 total_size;\r\nu32 indir_bytes;\r\nu32 *indir = NULL;\r\nu8 *hkey = NULL;\r\nu8 *rss_config;\r\nif (!(dev->ethtool_ops->get_rxfh_indir_size ||\r\ndev->ethtool_ops->get_rxfh_key_size) ||\r\n!dev->ethtool_ops->get_rxfh)\r\nreturn -EOPNOTSUPP;\r\nif (ops->get_rxfh_indir_size)\r\ndev_indir_size = ops->get_rxfh_indir_size(dev);\r\nif (ops->get_rxfh_key_size)\r\ndev_key_size = ops->get_rxfh_key_size(dev);\r\nif ((dev_key_size + dev_indir_size) == 0)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&rxfh, useraddr, sizeof(rxfh)))\r\nreturn -EFAULT;\r\nuser_indir_size = rxfh.indir_size;\r\nuser_key_size = rxfh.key_size;\r\nif (rxfh.rss_context || rxfh.rsvd[0] || rxfh.rsvd[1])\r\nreturn -EINVAL;\r\nrxfh.indir_size = dev_indir_size;\r\nrxfh.key_size = dev_key_size;\r\nif (copy_to_user(useraddr, &rxfh, sizeof(rxfh)))\r\nreturn -EFAULT;\r\nif (!user_indir_size && !user_key_size)\r\nreturn 0;\r\nif ((user_indir_size && (user_indir_size != dev_indir_size)) ||\r\n(user_key_size && (user_key_size != dev_key_size)))\r\nreturn -EINVAL;\r\nindir_bytes = user_indir_size * sizeof(indir[0]);\r\ntotal_size = indir_bytes + user_key_size;\r\nrss_config = kzalloc(total_size, GFP_USER);\r\nif (!rss_config)\r\nreturn -ENOMEM;\r\nif (user_indir_size)\r\nindir = (u32 *)rss_config;\r\nif (user_key_size)\r\nhkey = rss_config + indir_bytes;\r\nret = dev->ethtool_ops->get_rxfh(dev, indir, hkey);\r\nif (!ret) {\r\nif (copy_to_user(useraddr +\r\noffsetof(struct ethtool_rxfh, rss_config[0]),\r\nrss_config, total_size))\r\nret = -EFAULT;\r\n}\r\nkfree(rss_config);\r\nreturn ret;\r\n}\r\nstatic noinline_for_stack int ethtool_set_rxfh(struct net_device *dev,\r\nvoid __user *useraddr)\r\n{\r\nint ret;\r\nconst struct ethtool_ops *ops = dev->ethtool_ops;\r\nstruct ethtool_rxnfc rx_rings;\r\nstruct ethtool_rxfh rxfh;\r\nu32 dev_indir_size = 0, dev_key_size = 0, i;\r\nu32 *indir = NULL, indir_bytes = 0;\r\nu8 *hkey = NULL;\r\nu8 *rss_config;\r\nu32 rss_cfg_offset = offsetof(struct ethtool_rxfh, rss_config[0]);\r\nif (!(ops->get_rxfh_indir_size || ops->get_rxfh_key_size) ||\r\n!ops->get_rxnfc || !ops->set_rxfh)\r\nreturn -EOPNOTSUPP;\r\nif (ops->get_rxfh_indir_size)\r\ndev_indir_size = ops->get_rxfh_indir_size(dev);\r\nif (ops->get_rxfh_key_size)\r\ndev_key_size = dev->ethtool_ops->get_rxfh_key_size(dev);\r\nif ((dev_key_size + dev_indir_size) == 0)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&rxfh, useraddr, sizeof(rxfh)))\r\nreturn -EFAULT;\r\nif (rxfh.rss_context || rxfh.rsvd[0] || rxfh.rsvd[1])\r\nreturn -EINVAL;\r\nif ((rxfh.indir_size &&\r\nrxfh.indir_size != ETH_RXFH_INDIR_NO_CHANGE &&\r\nrxfh.indir_size != dev_indir_size) ||\r\n(rxfh.key_size && (rxfh.key_size != dev_key_size)) ||\r\n(rxfh.indir_size == ETH_RXFH_INDIR_NO_CHANGE &&\r\nrxfh.key_size == 0))\r\nreturn -EINVAL;\r\nif (rxfh.indir_size != ETH_RXFH_INDIR_NO_CHANGE)\r\nindir_bytes = dev_indir_size * sizeof(indir[0]);\r\nrss_config = kzalloc(indir_bytes + rxfh.key_size, GFP_USER);\r\nif (!rss_config)\r\nreturn -ENOMEM;\r\nrx_rings.cmd = ETHTOOL_GRXRINGS;\r\nret = ops->get_rxnfc(dev, &rx_rings, NULL);\r\nif (ret)\r\ngoto out;\r\nif (rxfh.indir_size &&\r\nrxfh.indir_size != ETH_RXFH_INDIR_NO_CHANGE) {\r\nindir = (u32 *)rss_config;\r\nret = ethtool_copy_validate_indir(indir,\r\nuseraddr + rss_cfg_offset,\r\n&rx_rings,\r\nrxfh.indir_size);\r\nif (ret)\r\ngoto out;\r\n} else if (rxfh.indir_size == 0) {\r\nindir = (u32 *)rss_config;\r\nfor (i = 0; i < dev_indir_size; i++)\r\nindir[i] = ethtool_rxfh_indir_default(i, rx_rings.data);\r\n}\r\nif (rxfh.key_size) {\r\nhkey = rss_config + indir_bytes;\r\nif (copy_from_user(hkey,\r\nuseraddr + rss_cfg_offset + indir_bytes,\r\nrxfh.key_size)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\n}\r\nret = ops->set_rxfh(dev, indir, hkey);\r\nout:\r\nkfree(rss_config);\r\nreturn ret;\r\n}\r\nstatic int ethtool_get_regs(struct net_device *dev, char __user *useraddr)\r\n{\r\nstruct ethtool_regs regs;\r\nconst struct ethtool_ops *ops = dev->ethtool_ops;\r\nvoid *regbuf;\r\nint reglen, ret;\r\nif (!ops->get_regs || !ops->get_regs_len)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&regs, useraddr, sizeof(regs)))\r\nreturn -EFAULT;\r\nreglen = ops->get_regs_len(dev);\r\nif (regs.len > reglen)\r\nregs.len = reglen;\r\nregbuf = vzalloc(reglen);\r\nif (reglen && !regbuf)\r\nreturn -ENOMEM;\r\nops->get_regs(dev, &regs, regbuf);\r\nret = -EFAULT;\r\nif (copy_to_user(useraddr, &regs, sizeof(regs)))\r\ngoto out;\r\nuseraddr += offsetof(struct ethtool_regs, data);\r\nif (regbuf && copy_to_user(useraddr, regbuf, regs.len))\r\ngoto out;\r\nret = 0;\r\nout:\r\nvfree(regbuf);\r\nreturn ret;\r\n}\r\nstatic int ethtool_reset(struct net_device *dev, char __user *useraddr)\r\n{\r\nstruct ethtool_value reset;\r\nint ret;\r\nif (!dev->ethtool_ops->reset)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&reset, useraddr, sizeof(reset)))\r\nreturn -EFAULT;\r\nret = dev->ethtool_ops->reset(dev, &reset.data);\r\nif (ret)\r\nreturn ret;\r\nif (copy_to_user(useraddr, &reset, sizeof(reset)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ethtool_get_wol(struct net_device *dev, char __user *useraddr)\r\n{\r\nstruct ethtool_wolinfo wol = { .cmd = ETHTOOL_GWOL };\r\nif (!dev->ethtool_ops->get_wol)\r\nreturn -EOPNOTSUPP;\r\ndev->ethtool_ops->get_wol(dev, &wol);\r\nif (copy_to_user(useraddr, &wol, sizeof(wol)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ethtool_set_wol(struct net_device *dev, char __user *useraddr)\r\n{\r\nstruct ethtool_wolinfo wol;\r\nif (!dev->ethtool_ops->set_wol)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&wol, useraddr, sizeof(wol)))\r\nreturn -EFAULT;\r\nreturn dev->ethtool_ops->set_wol(dev, &wol);\r\n}\r\nstatic int ethtool_get_eee(struct net_device *dev, char __user *useraddr)\r\n{\r\nstruct ethtool_eee edata;\r\nint rc;\r\nif (!dev->ethtool_ops->get_eee)\r\nreturn -EOPNOTSUPP;\r\nmemset(&edata, 0, sizeof(struct ethtool_eee));\r\nedata.cmd = ETHTOOL_GEEE;\r\nrc = dev->ethtool_ops->get_eee(dev, &edata);\r\nif (rc)\r\nreturn rc;\r\nif (copy_to_user(useraddr, &edata, sizeof(edata)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ethtool_set_eee(struct net_device *dev, char __user *useraddr)\r\n{\r\nstruct ethtool_eee edata;\r\nif (!dev->ethtool_ops->set_eee)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&edata, useraddr, sizeof(edata)))\r\nreturn -EFAULT;\r\nreturn dev->ethtool_ops->set_eee(dev, &edata);\r\n}\r\nstatic int ethtool_nway_reset(struct net_device *dev)\r\n{\r\nif (!dev->ethtool_ops->nway_reset)\r\nreturn -EOPNOTSUPP;\r\nreturn dev->ethtool_ops->nway_reset(dev);\r\n}\r\nstatic int ethtool_get_link(struct net_device *dev, char __user *useraddr)\r\n{\r\nstruct ethtool_value edata = { .cmd = ETHTOOL_GLINK };\r\nif (!dev->ethtool_ops->get_link)\r\nreturn -EOPNOTSUPP;\r\nedata.data = netif_running(dev) && dev->ethtool_ops->get_link(dev);\r\nif (copy_to_user(useraddr, &edata, sizeof(edata)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ethtool_get_any_eeprom(struct net_device *dev, void __user *useraddr,\r\nint (*getter)(struct net_device *,\r\nstruct ethtool_eeprom *, u8 *),\r\nu32 total_len)\r\n{\r\nstruct ethtool_eeprom eeprom;\r\nvoid __user *userbuf = useraddr + sizeof(eeprom);\r\nu32 bytes_remaining;\r\nu8 *data;\r\nint ret = 0;\r\nif (copy_from_user(&eeprom, useraddr, sizeof(eeprom)))\r\nreturn -EFAULT;\r\nif (eeprom.offset + eeprom.len <= eeprom.offset)\r\nreturn -EINVAL;\r\nif (eeprom.offset + eeprom.len > total_len)\r\nreturn -EINVAL;\r\ndata = kmalloc(PAGE_SIZE, GFP_USER);\r\nif (!data)\r\nreturn -ENOMEM;\r\nbytes_remaining = eeprom.len;\r\nwhile (bytes_remaining > 0) {\r\neeprom.len = min(bytes_remaining, (u32)PAGE_SIZE);\r\nret = getter(dev, &eeprom, data);\r\nif (ret)\r\nbreak;\r\nif (copy_to_user(userbuf, data, eeprom.len)) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nuserbuf += eeprom.len;\r\neeprom.offset += eeprom.len;\r\nbytes_remaining -= eeprom.len;\r\n}\r\neeprom.len = userbuf - (useraddr + sizeof(eeprom));\r\neeprom.offset -= eeprom.len;\r\nif (copy_to_user(useraddr, &eeprom, sizeof(eeprom)))\r\nret = -EFAULT;\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic int ethtool_get_eeprom(struct net_device *dev, void __user *useraddr)\r\n{\r\nconst struct ethtool_ops *ops = dev->ethtool_ops;\r\nif (!ops->get_eeprom || !ops->get_eeprom_len)\r\nreturn -EOPNOTSUPP;\r\nreturn ethtool_get_any_eeprom(dev, useraddr, ops->get_eeprom,\r\nops->get_eeprom_len(dev));\r\n}\r\nstatic int ethtool_set_eeprom(struct net_device *dev, void __user *useraddr)\r\n{\r\nstruct ethtool_eeprom eeprom;\r\nconst struct ethtool_ops *ops = dev->ethtool_ops;\r\nvoid __user *userbuf = useraddr + sizeof(eeprom);\r\nu32 bytes_remaining;\r\nu8 *data;\r\nint ret = 0;\r\nif (!ops->set_eeprom || !ops->get_eeprom_len)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&eeprom, useraddr, sizeof(eeprom)))\r\nreturn -EFAULT;\r\nif (eeprom.offset + eeprom.len <= eeprom.offset)\r\nreturn -EINVAL;\r\nif (eeprom.offset + eeprom.len > ops->get_eeprom_len(dev))\r\nreturn -EINVAL;\r\ndata = kmalloc(PAGE_SIZE, GFP_USER);\r\nif (!data)\r\nreturn -ENOMEM;\r\nbytes_remaining = eeprom.len;\r\nwhile (bytes_remaining > 0) {\r\neeprom.len = min(bytes_remaining, (u32)PAGE_SIZE);\r\nif (copy_from_user(data, userbuf, eeprom.len)) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nret = ops->set_eeprom(dev, &eeprom, data);\r\nif (ret)\r\nbreak;\r\nuserbuf += eeprom.len;\r\neeprom.offset += eeprom.len;\r\nbytes_remaining -= eeprom.len;\r\n}\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic noinline_for_stack int ethtool_get_coalesce(struct net_device *dev,\r\nvoid __user *useraddr)\r\n{\r\nstruct ethtool_coalesce coalesce = { .cmd = ETHTOOL_GCOALESCE };\r\nif (!dev->ethtool_ops->get_coalesce)\r\nreturn -EOPNOTSUPP;\r\ndev->ethtool_ops->get_coalesce(dev, &coalesce);\r\nif (copy_to_user(useraddr, &coalesce, sizeof(coalesce)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic noinline_for_stack int ethtool_set_coalesce(struct net_device *dev,\r\nvoid __user *useraddr)\r\n{\r\nstruct ethtool_coalesce coalesce;\r\nif (!dev->ethtool_ops->set_coalesce)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&coalesce, useraddr, sizeof(coalesce)))\r\nreturn -EFAULT;\r\nreturn dev->ethtool_ops->set_coalesce(dev, &coalesce);\r\n}\r\nstatic int ethtool_get_ringparam(struct net_device *dev, void __user *useraddr)\r\n{\r\nstruct ethtool_ringparam ringparam = { .cmd = ETHTOOL_GRINGPARAM };\r\nif (!dev->ethtool_ops->get_ringparam)\r\nreturn -EOPNOTSUPP;\r\ndev->ethtool_ops->get_ringparam(dev, &ringparam);\r\nif (copy_to_user(useraddr, &ringparam, sizeof(ringparam)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ethtool_set_ringparam(struct net_device *dev, void __user *useraddr)\r\n{\r\nstruct ethtool_ringparam ringparam;\r\nif (!dev->ethtool_ops->set_ringparam)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&ringparam, useraddr, sizeof(ringparam)))\r\nreturn -EFAULT;\r\nreturn dev->ethtool_ops->set_ringparam(dev, &ringparam);\r\n}\r\nstatic noinline_for_stack int ethtool_get_channels(struct net_device *dev,\r\nvoid __user *useraddr)\r\n{\r\nstruct ethtool_channels channels = { .cmd = ETHTOOL_GCHANNELS };\r\nif (!dev->ethtool_ops->get_channels)\r\nreturn -EOPNOTSUPP;\r\ndev->ethtool_ops->get_channels(dev, &channels);\r\nif (copy_to_user(useraddr, &channels, sizeof(channels)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic noinline_for_stack int ethtool_set_channels(struct net_device *dev,\r\nvoid __user *useraddr)\r\n{\r\nstruct ethtool_channels channels;\r\nif (!dev->ethtool_ops->set_channels)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&channels, useraddr, sizeof(channels)))\r\nreturn -EFAULT;\r\nreturn dev->ethtool_ops->set_channels(dev, &channels);\r\n}\r\nstatic int ethtool_get_pauseparam(struct net_device *dev, void __user *useraddr)\r\n{\r\nstruct ethtool_pauseparam pauseparam = { ETHTOOL_GPAUSEPARAM };\r\nif (!dev->ethtool_ops->get_pauseparam)\r\nreturn -EOPNOTSUPP;\r\ndev->ethtool_ops->get_pauseparam(dev, &pauseparam);\r\nif (copy_to_user(useraddr, &pauseparam, sizeof(pauseparam)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ethtool_set_pauseparam(struct net_device *dev, void __user *useraddr)\r\n{\r\nstruct ethtool_pauseparam pauseparam;\r\nif (!dev->ethtool_ops->set_pauseparam)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&pauseparam, useraddr, sizeof(pauseparam)))\r\nreturn -EFAULT;\r\nreturn dev->ethtool_ops->set_pauseparam(dev, &pauseparam);\r\n}\r\nstatic int ethtool_self_test(struct net_device *dev, char __user *useraddr)\r\n{\r\nstruct ethtool_test test;\r\nconst struct ethtool_ops *ops = dev->ethtool_ops;\r\nu64 *data;\r\nint ret, test_len;\r\nif (!ops->self_test || !ops->get_sset_count)\r\nreturn -EOPNOTSUPP;\r\ntest_len = ops->get_sset_count(dev, ETH_SS_TEST);\r\nif (test_len < 0)\r\nreturn test_len;\r\nWARN_ON(test_len == 0);\r\nif (copy_from_user(&test, useraddr, sizeof(test)))\r\nreturn -EFAULT;\r\ntest.len = test_len;\r\ndata = kmalloc(test_len * sizeof(u64), GFP_USER);\r\nif (!data)\r\nreturn -ENOMEM;\r\nops->self_test(dev, &test, data);\r\nret = -EFAULT;\r\nif (copy_to_user(useraddr, &test, sizeof(test)))\r\ngoto out;\r\nuseraddr += sizeof(test);\r\nif (copy_to_user(useraddr, data, test.len * sizeof(u64)))\r\ngoto out;\r\nret = 0;\r\nout:\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic int ethtool_get_strings(struct net_device *dev, void __user *useraddr)\r\n{\r\nstruct ethtool_gstrings gstrings;\r\nu8 *data;\r\nint ret;\r\nif (copy_from_user(&gstrings, useraddr, sizeof(gstrings)))\r\nreturn -EFAULT;\r\nret = __ethtool_get_sset_count(dev, gstrings.string_set);\r\nif (ret < 0)\r\nreturn ret;\r\ngstrings.len = ret;\r\ndata = kmalloc(gstrings.len * ETH_GSTRING_LEN, GFP_USER);\r\nif (!data)\r\nreturn -ENOMEM;\r\n__ethtool_get_strings(dev, gstrings.string_set, data);\r\nret = -EFAULT;\r\nif (copy_to_user(useraddr, &gstrings, sizeof(gstrings)))\r\ngoto out;\r\nuseraddr += sizeof(gstrings);\r\nif (copy_to_user(useraddr, data, gstrings.len * ETH_GSTRING_LEN))\r\ngoto out;\r\nret = 0;\r\nout:\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic int ethtool_phys_id(struct net_device *dev, void __user *useraddr)\r\n{\r\nstruct ethtool_value id;\r\nstatic bool busy;\r\nconst struct ethtool_ops *ops = dev->ethtool_ops;\r\nint rc;\r\nif (!ops->set_phys_id)\r\nreturn -EOPNOTSUPP;\r\nif (busy)\r\nreturn -EBUSY;\r\nif (copy_from_user(&id, useraddr, sizeof(id)))\r\nreturn -EFAULT;\r\nrc = ops->set_phys_id(dev, ETHTOOL_ID_ACTIVE);\r\nif (rc < 0)\r\nreturn rc;\r\nbusy = true;\r\ndev_hold(dev);\r\nrtnl_unlock();\r\nif (rc == 0) {\r\nschedule_timeout_interruptible(\r\nid.data ? (id.data * HZ) : MAX_SCHEDULE_TIMEOUT);\r\n} else {\r\nint n = rc * 2, i, interval = HZ / n;\r\ndo {\r\ni = n;\r\ndo {\r\nrtnl_lock();\r\nrc = ops->set_phys_id(dev,\r\n(i & 1) ? ETHTOOL_ID_OFF : ETHTOOL_ID_ON);\r\nrtnl_unlock();\r\nif (rc)\r\nbreak;\r\nschedule_timeout_interruptible(interval);\r\n} while (!signal_pending(current) && --i != 0);\r\n} while (!signal_pending(current) &&\r\n(id.data == 0 || --id.data != 0));\r\n}\r\nrtnl_lock();\r\ndev_put(dev);\r\nbusy = false;\r\n(void) ops->set_phys_id(dev, ETHTOOL_ID_INACTIVE);\r\nreturn rc;\r\n}\r\nstatic int ethtool_get_stats(struct net_device *dev, void __user *useraddr)\r\n{\r\nstruct ethtool_stats stats;\r\nconst struct ethtool_ops *ops = dev->ethtool_ops;\r\nu64 *data;\r\nint ret, n_stats;\r\nif (!ops->get_ethtool_stats || !ops->get_sset_count)\r\nreturn -EOPNOTSUPP;\r\nn_stats = ops->get_sset_count(dev, ETH_SS_STATS);\r\nif (n_stats < 0)\r\nreturn n_stats;\r\nWARN_ON(n_stats == 0);\r\nif (copy_from_user(&stats, useraddr, sizeof(stats)))\r\nreturn -EFAULT;\r\nstats.n_stats = n_stats;\r\ndata = kmalloc(n_stats * sizeof(u64), GFP_USER);\r\nif (!data)\r\nreturn -ENOMEM;\r\nops->get_ethtool_stats(dev, &stats, data);\r\nret = -EFAULT;\r\nif (copy_to_user(useraddr, &stats, sizeof(stats)))\r\ngoto out;\r\nuseraddr += sizeof(stats);\r\nif (copy_to_user(useraddr, data, stats.n_stats * sizeof(u64)))\r\ngoto out;\r\nret = 0;\r\nout:\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic int ethtool_get_perm_addr(struct net_device *dev, void __user *useraddr)\r\n{\r\nstruct ethtool_perm_addr epaddr;\r\nif (copy_from_user(&epaddr, useraddr, sizeof(epaddr)))\r\nreturn -EFAULT;\r\nif (epaddr.size < dev->addr_len)\r\nreturn -ETOOSMALL;\r\nepaddr.size = dev->addr_len;\r\nif (copy_to_user(useraddr, &epaddr, sizeof(epaddr)))\r\nreturn -EFAULT;\r\nuseraddr += sizeof(epaddr);\r\nif (copy_to_user(useraddr, dev->perm_addr, epaddr.size))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ethtool_get_value(struct net_device *dev, char __user *useraddr,\r\nu32 cmd, u32 (*actor)(struct net_device *))\r\n{\r\nstruct ethtool_value edata = { .cmd = cmd };\r\nif (!actor)\r\nreturn -EOPNOTSUPP;\r\nedata.data = actor(dev);\r\nif (copy_to_user(useraddr, &edata, sizeof(edata)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ethtool_set_value_void(struct net_device *dev, char __user *useraddr,\r\nvoid (*actor)(struct net_device *, u32))\r\n{\r\nstruct ethtool_value edata;\r\nif (!actor)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&edata, useraddr, sizeof(edata)))\r\nreturn -EFAULT;\r\nactor(dev, edata.data);\r\nreturn 0;\r\n}\r\nstatic int ethtool_set_value(struct net_device *dev, char __user *useraddr,\r\nint (*actor)(struct net_device *, u32))\r\n{\r\nstruct ethtool_value edata;\r\nif (!actor)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&edata, useraddr, sizeof(edata)))\r\nreturn -EFAULT;\r\nreturn actor(dev, edata.data);\r\n}\r\nstatic noinline_for_stack int ethtool_flash_device(struct net_device *dev,\r\nchar __user *useraddr)\r\n{\r\nstruct ethtool_flash efl;\r\nif (copy_from_user(&efl, useraddr, sizeof(efl)))\r\nreturn -EFAULT;\r\nif (!dev->ethtool_ops->flash_device)\r\nreturn -EOPNOTSUPP;\r\nefl.data[ETHTOOL_FLASH_MAX_FILENAME - 1] = 0;\r\nreturn dev->ethtool_ops->flash_device(dev, &efl);\r\n}\r\nstatic int ethtool_set_dump(struct net_device *dev,\r\nvoid __user *useraddr)\r\n{\r\nstruct ethtool_dump dump;\r\nif (!dev->ethtool_ops->set_dump)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&dump, useraddr, sizeof(dump)))\r\nreturn -EFAULT;\r\nreturn dev->ethtool_ops->set_dump(dev, &dump);\r\n}\r\nstatic int ethtool_get_dump_flag(struct net_device *dev,\r\nvoid __user *useraddr)\r\n{\r\nint ret;\r\nstruct ethtool_dump dump;\r\nconst struct ethtool_ops *ops = dev->ethtool_ops;\r\nif (!ops->get_dump_flag)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&dump, useraddr, sizeof(dump)))\r\nreturn -EFAULT;\r\nret = ops->get_dump_flag(dev, &dump);\r\nif (ret)\r\nreturn ret;\r\nif (copy_to_user(useraddr, &dump, sizeof(dump)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ethtool_get_dump_data(struct net_device *dev,\r\nvoid __user *useraddr)\r\n{\r\nint ret;\r\n__u32 len;\r\nstruct ethtool_dump dump, tmp;\r\nconst struct ethtool_ops *ops = dev->ethtool_ops;\r\nvoid *data = NULL;\r\nif (!ops->get_dump_data || !ops->get_dump_flag)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&dump, useraddr, sizeof(dump)))\r\nreturn -EFAULT;\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntmp.cmd = ETHTOOL_GET_DUMP_FLAG;\r\nret = ops->get_dump_flag(dev, &tmp);\r\nif (ret)\r\nreturn ret;\r\nlen = min(tmp.len, dump.len);\r\nif (!len)\r\nreturn -EFAULT;\r\ndump.len = len;\r\ndata = vzalloc(tmp.len);\r\nif (!data)\r\nreturn -ENOMEM;\r\nret = ops->get_dump_data(dev, &dump, data);\r\nif (ret)\r\ngoto out;\r\nWARN_ON(dump.len != len && dump.len != tmp.len);\r\ndump.len = len;\r\nif (copy_to_user(useraddr, &dump, sizeof(dump))) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nuseraddr += offsetof(struct ethtool_dump, data);\r\nif (copy_to_user(useraddr, data, len))\r\nret = -EFAULT;\r\nout:\r\nvfree(data);\r\nreturn ret;\r\n}\r\nstatic int ethtool_get_ts_info(struct net_device *dev, void __user *useraddr)\r\n{\r\nint err = 0;\r\nstruct ethtool_ts_info info;\r\nconst struct ethtool_ops *ops = dev->ethtool_ops;\r\nstruct phy_device *phydev = dev->phydev;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.cmd = ETHTOOL_GET_TS_INFO;\r\nif (phydev && phydev->drv && phydev->drv->ts_info) {\r\nerr = phydev->drv->ts_info(phydev, &info);\r\n} else if (ops->get_ts_info) {\r\nerr = ops->get_ts_info(dev, &info);\r\n} else {\r\ninfo.so_timestamping =\r\nSOF_TIMESTAMPING_RX_SOFTWARE |\r\nSOF_TIMESTAMPING_SOFTWARE;\r\ninfo.phc_index = -1;\r\n}\r\nif (err)\r\nreturn err;\r\nif (copy_to_user(useraddr, &info, sizeof(info)))\r\nerr = -EFAULT;\r\nreturn err;\r\n}\r\nstatic int ethtool_get_module_info(struct net_device *dev,\r\nvoid __user *useraddr)\r\n{\r\nint ret;\r\nstruct ethtool_modinfo modinfo;\r\nconst struct ethtool_ops *ops = dev->ethtool_ops;\r\nif (!ops->get_module_info)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&modinfo, useraddr, sizeof(modinfo)))\r\nreturn -EFAULT;\r\nret = ops->get_module_info(dev, &modinfo);\r\nif (ret)\r\nreturn ret;\r\nif (copy_to_user(useraddr, &modinfo, sizeof(modinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ethtool_get_module_eeprom(struct net_device *dev,\r\nvoid __user *useraddr)\r\n{\r\nint ret;\r\nstruct ethtool_modinfo modinfo;\r\nconst struct ethtool_ops *ops = dev->ethtool_ops;\r\nif (!ops->get_module_info || !ops->get_module_eeprom)\r\nreturn -EOPNOTSUPP;\r\nret = ops->get_module_info(dev, &modinfo);\r\nif (ret)\r\nreturn ret;\r\nreturn ethtool_get_any_eeprom(dev, useraddr, ops->get_module_eeprom,\r\nmodinfo.eeprom_len);\r\n}\r\nint dev_ethtool(struct net *net, struct ifreq *ifr)\r\n{\r\nstruct net_device *dev = __dev_get_by_name(net, ifr->ifr_name);\r\nvoid __user *useraddr = ifr->ifr_data;\r\nu32 ethcmd;\r\nint rc;\r\nnetdev_features_t old_features;\r\nif (!dev || !netif_device_present(dev))\r\nreturn -ENODEV;\r\nif (copy_from_user(&ethcmd, useraddr, sizeof(ethcmd)))\r\nreturn -EFAULT;\r\nswitch (ethcmd) {\r\ncase ETHTOOL_GSET:\r\ncase ETHTOOL_GDRVINFO:\r\ncase ETHTOOL_GMSGLVL:\r\ncase ETHTOOL_GLINK:\r\ncase ETHTOOL_GCOALESCE:\r\ncase ETHTOOL_GRINGPARAM:\r\ncase ETHTOOL_GPAUSEPARAM:\r\ncase ETHTOOL_GRXCSUM:\r\ncase ETHTOOL_GTXCSUM:\r\ncase ETHTOOL_GSG:\r\ncase ETHTOOL_GSSET_INFO:\r\ncase ETHTOOL_GSTRINGS:\r\ncase ETHTOOL_GSTATS:\r\ncase ETHTOOL_GTSO:\r\ncase ETHTOOL_GPERMADDR:\r\ncase ETHTOOL_GUFO:\r\ncase ETHTOOL_GGSO:\r\ncase ETHTOOL_GGRO:\r\ncase ETHTOOL_GFLAGS:\r\ncase ETHTOOL_GPFLAGS:\r\ncase ETHTOOL_GRXFH:\r\ncase ETHTOOL_GRXRINGS:\r\ncase ETHTOOL_GRXCLSRLCNT:\r\ncase ETHTOOL_GRXCLSRULE:\r\ncase ETHTOOL_GRXCLSRLALL:\r\ncase ETHTOOL_GRXFHINDIR:\r\ncase ETHTOOL_GRSSH:\r\ncase ETHTOOL_GFEATURES:\r\ncase ETHTOOL_GCHANNELS:\r\ncase ETHTOOL_GET_TS_INFO:\r\ncase ETHTOOL_GEEE:\r\nbreak;\r\ndefault:\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\n}\r\nif (dev->ethtool_ops->begin) {\r\nrc = dev->ethtool_ops->begin(dev);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nold_features = dev->features;\r\nswitch (ethcmd) {\r\ncase ETHTOOL_GSET:\r\nrc = ethtool_get_settings(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_SSET:\r\nrc = ethtool_set_settings(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GDRVINFO:\r\nrc = ethtool_get_drvinfo(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GREGS:\r\nrc = ethtool_get_regs(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GWOL:\r\nrc = ethtool_get_wol(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_SWOL:\r\nrc = ethtool_set_wol(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GMSGLVL:\r\nrc = ethtool_get_value(dev, useraddr, ethcmd,\r\ndev->ethtool_ops->get_msglevel);\r\nbreak;\r\ncase ETHTOOL_SMSGLVL:\r\nrc = ethtool_set_value_void(dev, useraddr,\r\ndev->ethtool_ops->set_msglevel);\r\nbreak;\r\ncase ETHTOOL_GEEE:\r\nrc = ethtool_get_eee(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_SEEE:\r\nrc = ethtool_set_eee(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_NWAY_RST:\r\nrc = ethtool_nway_reset(dev);\r\nbreak;\r\ncase ETHTOOL_GLINK:\r\nrc = ethtool_get_link(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GEEPROM:\r\nrc = ethtool_get_eeprom(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_SEEPROM:\r\nrc = ethtool_set_eeprom(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GCOALESCE:\r\nrc = ethtool_get_coalesce(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_SCOALESCE:\r\nrc = ethtool_set_coalesce(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GRINGPARAM:\r\nrc = ethtool_get_ringparam(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_SRINGPARAM:\r\nrc = ethtool_set_ringparam(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GPAUSEPARAM:\r\nrc = ethtool_get_pauseparam(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_SPAUSEPARAM:\r\nrc = ethtool_set_pauseparam(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_TEST:\r\nrc = ethtool_self_test(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GSTRINGS:\r\nrc = ethtool_get_strings(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_PHYS_ID:\r\nrc = ethtool_phys_id(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GSTATS:\r\nrc = ethtool_get_stats(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GPERMADDR:\r\nrc = ethtool_get_perm_addr(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GFLAGS:\r\nrc = ethtool_get_value(dev, useraddr, ethcmd,\r\n__ethtool_get_flags);\r\nbreak;\r\ncase ETHTOOL_SFLAGS:\r\nrc = ethtool_set_value(dev, useraddr, __ethtool_set_flags);\r\nbreak;\r\ncase ETHTOOL_GPFLAGS:\r\nrc = ethtool_get_value(dev, useraddr, ethcmd,\r\ndev->ethtool_ops->get_priv_flags);\r\nbreak;\r\ncase ETHTOOL_SPFLAGS:\r\nrc = ethtool_set_value(dev, useraddr,\r\ndev->ethtool_ops->set_priv_flags);\r\nbreak;\r\ncase ETHTOOL_GRXFH:\r\ncase ETHTOOL_GRXRINGS:\r\ncase ETHTOOL_GRXCLSRLCNT:\r\ncase ETHTOOL_GRXCLSRULE:\r\ncase ETHTOOL_GRXCLSRLALL:\r\nrc = ethtool_get_rxnfc(dev, ethcmd, useraddr);\r\nbreak;\r\ncase ETHTOOL_SRXFH:\r\ncase ETHTOOL_SRXCLSRLDEL:\r\ncase ETHTOOL_SRXCLSRLINS:\r\nrc = ethtool_set_rxnfc(dev, ethcmd, useraddr);\r\nbreak;\r\ncase ETHTOOL_FLASHDEV:\r\nrc = ethtool_flash_device(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_RESET:\r\nrc = ethtool_reset(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GSSET_INFO:\r\nrc = ethtool_get_sset_info(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GRXFHINDIR:\r\nrc = ethtool_get_rxfh_indir(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_SRXFHINDIR:\r\nrc = ethtool_set_rxfh_indir(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GRSSH:\r\nrc = ethtool_get_rxfh(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_SRSSH:\r\nrc = ethtool_set_rxfh(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GFEATURES:\r\nrc = ethtool_get_features(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_SFEATURES:\r\nrc = ethtool_set_features(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GTXCSUM:\r\ncase ETHTOOL_GRXCSUM:\r\ncase ETHTOOL_GSG:\r\ncase ETHTOOL_GTSO:\r\ncase ETHTOOL_GUFO:\r\ncase ETHTOOL_GGSO:\r\ncase ETHTOOL_GGRO:\r\nrc = ethtool_get_one_feature(dev, useraddr, ethcmd);\r\nbreak;\r\ncase ETHTOOL_STXCSUM:\r\ncase ETHTOOL_SRXCSUM:\r\ncase ETHTOOL_SSG:\r\ncase ETHTOOL_STSO:\r\ncase ETHTOOL_SUFO:\r\ncase ETHTOOL_SGSO:\r\ncase ETHTOOL_SGRO:\r\nrc = ethtool_set_one_feature(dev, useraddr, ethcmd);\r\nbreak;\r\ncase ETHTOOL_GCHANNELS:\r\nrc = ethtool_get_channels(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_SCHANNELS:\r\nrc = ethtool_set_channels(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_SET_DUMP:\r\nrc = ethtool_set_dump(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GET_DUMP_FLAG:\r\nrc = ethtool_get_dump_flag(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GET_DUMP_DATA:\r\nrc = ethtool_get_dump_data(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GET_TS_INFO:\r\nrc = ethtool_get_ts_info(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GMODULEINFO:\r\nrc = ethtool_get_module_info(dev, useraddr);\r\nbreak;\r\ncase ETHTOOL_GMODULEEEPROM:\r\nrc = ethtool_get_module_eeprom(dev, useraddr);\r\nbreak;\r\ndefault:\r\nrc = -EOPNOTSUPP;\r\n}\r\nif (dev->ethtool_ops->complete)\r\ndev->ethtool_ops->complete(dev);\r\nif (old_features != dev->features)\r\nnetdev_features_change(dev);\r\nreturn rc;\r\n}
