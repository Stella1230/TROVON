void omap3isp_flush(struct isp_device *isp)\r\n{\r\nisp_reg_writel(isp, 0, OMAP3_ISP_IOMEM_MAIN, ISP_REVISION);\r\nisp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN, ISP_REVISION);\r\n}\r\nstatic void isp_xclk_update(struct isp_xclk *xclk, u32 divider)\r\n{\r\nswitch (xclk->id) {\r\ncase ISP_XCLK_A:\r\nisp_reg_clr_set(xclk->isp, OMAP3_ISP_IOMEM_MAIN, ISP_TCTRL_CTRL,\r\nISPTCTRL_CTRL_DIVA_MASK,\r\ndivider << ISPTCTRL_CTRL_DIVA_SHIFT);\r\nbreak;\r\ncase ISP_XCLK_B:\r\nisp_reg_clr_set(xclk->isp, OMAP3_ISP_IOMEM_MAIN, ISP_TCTRL_CTRL,\r\nISPTCTRL_CTRL_DIVB_MASK,\r\ndivider << ISPTCTRL_CTRL_DIVB_SHIFT);\r\nbreak;\r\n}\r\n}\r\nstatic int isp_xclk_prepare(struct clk_hw *hw)\r\n{\r\nstruct isp_xclk *xclk = to_isp_xclk(hw);\r\nomap3isp_get(xclk->isp);\r\nreturn 0;\r\n}\r\nstatic void isp_xclk_unprepare(struct clk_hw *hw)\r\n{\r\nstruct isp_xclk *xclk = to_isp_xclk(hw);\r\nomap3isp_put(xclk->isp);\r\n}\r\nstatic int isp_xclk_enable(struct clk_hw *hw)\r\n{\r\nstruct isp_xclk *xclk = to_isp_xclk(hw);\r\nunsigned long flags;\r\nspin_lock_irqsave(&xclk->lock, flags);\r\nisp_xclk_update(xclk, xclk->divider);\r\nxclk->enabled = true;\r\nspin_unlock_irqrestore(&xclk->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void isp_xclk_disable(struct clk_hw *hw)\r\n{\r\nstruct isp_xclk *xclk = to_isp_xclk(hw);\r\nunsigned long flags;\r\nspin_lock_irqsave(&xclk->lock, flags);\r\nisp_xclk_update(xclk, 0);\r\nxclk->enabled = false;\r\nspin_unlock_irqrestore(&xclk->lock, flags);\r\n}\r\nstatic unsigned long isp_xclk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct isp_xclk *xclk = to_isp_xclk(hw);\r\nreturn parent_rate / xclk->divider;\r\n}\r\nstatic u32 isp_xclk_calc_divider(unsigned long *rate, unsigned long parent_rate)\r\n{\r\nu32 divider;\r\nif (*rate >= parent_rate) {\r\n*rate = parent_rate;\r\nreturn ISPTCTRL_CTRL_DIV_BYPASS;\r\n}\r\ndivider = DIV_ROUND_CLOSEST(parent_rate, *rate);\r\nif (divider >= ISPTCTRL_CTRL_DIV_BYPASS)\r\ndivider = ISPTCTRL_CTRL_DIV_BYPASS - 1;\r\n*rate = parent_rate / divider;\r\nreturn divider;\r\n}\r\nstatic long isp_xclk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nisp_xclk_calc_divider(&rate, *parent_rate);\r\nreturn rate;\r\n}\r\nstatic int isp_xclk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct isp_xclk *xclk = to_isp_xclk(hw);\r\nunsigned long flags;\r\nu32 divider;\r\ndivider = isp_xclk_calc_divider(&rate, parent_rate);\r\nspin_lock_irqsave(&xclk->lock, flags);\r\nxclk->divider = divider;\r\nif (xclk->enabled)\r\nisp_xclk_update(xclk, divider);\r\nspin_unlock_irqrestore(&xclk->lock, flags);\r\ndev_dbg(xclk->isp->dev, "%s: cam_xclk%c set to %lu Hz (div %u)\n",\r\n__func__, xclk->id == ISP_XCLK_A ? 'a' : 'b', rate, divider);\r\nreturn 0;\r\n}\r\nstatic int isp_xclk_init(struct isp_device *isp)\r\n{\r\nstruct isp_platform_data *pdata = isp->pdata;\r\nstruct clk_init_data init;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(isp->xclks); ++i)\r\nisp->xclks[i].clk = ERR_PTR(-EINVAL);\r\nfor (i = 0; i < ARRAY_SIZE(isp->xclks); ++i) {\r\nstruct isp_xclk *xclk = &isp->xclks[i];\r\nxclk->isp = isp;\r\nxclk->id = i == 0 ? ISP_XCLK_A : ISP_XCLK_B;\r\nxclk->divider = 1;\r\nspin_lock_init(&xclk->lock);\r\ninit.name = i == 0 ? "cam_xclka" : "cam_xclkb";\r\ninit.ops = &isp_xclk_ops;\r\ninit.parent_names = &isp_xclk_parent_name;\r\ninit.num_parents = 1;\r\nxclk->hw.init = &init;\r\nxclk->clk = clk_register(NULL, &xclk->hw);\r\nif (IS_ERR(xclk->clk))\r\nreturn PTR_ERR(xclk->clk);\r\nif (pdata->xclks[i].con_id == NULL &&\r\npdata->xclks[i].dev_id == NULL)\r\ncontinue;\r\nxclk->lookup = kzalloc(sizeof(*xclk->lookup), GFP_KERNEL);\r\nif (xclk->lookup == NULL)\r\nreturn -ENOMEM;\r\nxclk->lookup->con_id = pdata->xclks[i].con_id;\r\nxclk->lookup->dev_id = pdata->xclks[i].dev_id;\r\nxclk->lookup->clk = xclk->clk;\r\nclkdev_add(xclk->lookup);\r\n}\r\nreturn 0;\r\n}\r\nstatic void isp_xclk_cleanup(struct isp_device *isp)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(isp->xclks); ++i) {\r\nstruct isp_xclk *xclk = &isp->xclks[i];\r\nif (!IS_ERR(xclk->clk))\r\nclk_unregister(xclk->clk);\r\nif (xclk->lookup)\r\nclkdev_drop(xclk->lookup);\r\n}\r\n}\r\nstatic void isp_enable_interrupts(struct isp_device *isp)\r\n{\r\nstatic const u32 irq = IRQ0ENABLE_CSIA_IRQ\r\n| IRQ0ENABLE_CSIB_IRQ\r\n| IRQ0ENABLE_CCDC_LSC_PREF_ERR_IRQ\r\n| IRQ0ENABLE_CCDC_LSC_DONE_IRQ\r\n| IRQ0ENABLE_CCDC_VD0_IRQ\r\n| IRQ0ENABLE_CCDC_VD1_IRQ\r\n| IRQ0ENABLE_HS_VS_IRQ\r\n| IRQ0ENABLE_HIST_DONE_IRQ\r\n| IRQ0ENABLE_H3A_AWB_DONE_IRQ\r\n| IRQ0ENABLE_H3A_AF_DONE_IRQ\r\n| IRQ0ENABLE_PRV_DONE_IRQ\r\n| IRQ0ENABLE_RSZ_DONE_IRQ;\r\nisp_reg_writel(isp, irq, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);\r\nisp_reg_writel(isp, irq, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE);\r\n}\r\nstatic void isp_disable_interrupts(struct isp_device *isp)\r\n{\r\nisp_reg_writel(isp, 0, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE);\r\n}\r\nstatic void isp_core_init(struct isp_device *isp, int idle)\r\n{\r\nisp_reg_writel(isp,\r\n((idle ? ISP_SYSCONFIG_MIDLEMODE_SMARTSTANDBY :\r\nISP_SYSCONFIG_MIDLEMODE_FORCESTANDBY) <<\r\nISP_SYSCONFIG_MIDLEMODE_SHIFT) |\r\n((isp->revision == ISP_REVISION_15_0) ?\r\nISP_SYSCONFIG_AUTOIDLE : 0),\r\nOMAP3_ISP_IOMEM_MAIN, ISP_SYSCONFIG);\r\nisp_reg_writel(isp,\r\n(isp->autoidle ? ISPCTRL_SBL_AUTOIDLE : 0) |\r\nISPCTRL_SYNC_DETECT_VSRISE,\r\nOMAP3_ISP_IOMEM_MAIN, ISP_CTRL);\r\n}\r\nvoid omap3isp_configure_bridge(struct isp_device *isp,\r\nenum ccdc_input_entity input,\r\nconst struct isp_parallel_platform_data *pdata,\r\nunsigned int shift, unsigned int bridge)\r\n{\r\nu32 ispctrl_val;\r\nispctrl_val = isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL);\r\nispctrl_val &= ~ISPCTRL_SHIFT_MASK;\r\nispctrl_val &= ~ISPCTRL_PAR_CLK_POL_INV;\r\nispctrl_val &= ~ISPCTRL_PAR_SER_CLK_SEL_MASK;\r\nispctrl_val &= ~ISPCTRL_PAR_BRIDGE_MASK;\r\nispctrl_val |= bridge;\r\nswitch (input) {\r\ncase CCDC_INPUT_PARALLEL:\r\nispctrl_val |= ISPCTRL_PAR_SER_CLK_SEL_PARALLEL;\r\nispctrl_val |= pdata->clk_pol << ISPCTRL_PAR_CLK_POL_SHIFT;\r\nshift += pdata->data_lane_shift * 2;\r\nbreak;\r\ncase CCDC_INPUT_CSI2A:\r\nispctrl_val |= ISPCTRL_PAR_SER_CLK_SEL_CSIA;\r\nbreak;\r\ncase CCDC_INPUT_CCP2B:\r\nispctrl_val |= ISPCTRL_PAR_SER_CLK_SEL_CSIB;\r\nbreak;\r\ncase CCDC_INPUT_CSI2C:\r\nispctrl_val |= ISPCTRL_PAR_SER_CLK_SEL_CSIC;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nispctrl_val |= ((shift/2) << ISPCTRL_SHIFT_SHIFT) & ISPCTRL_SHIFT_MASK;\r\nisp_reg_writel(isp, ispctrl_val, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL);\r\n}\r\nvoid omap3isp_hist_dma_done(struct isp_device *isp)\r\n{\r\nif (omap3isp_ccdc_busy(&isp->isp_ccdc) ||\r\nomap3isp_stat_pcr_busy(&isp->isp_hist)) {\r\natomic_set(&isp->isp_hist.buf_err, 1);\r\ndev_dbg(isp->dev, "hist: Out of synchronization with "\r\n"CCDC. Ignoring next buffer.\n");\r\n}\r\n}\r\nstatic inline void isp_isr_dbg(struct isp_device *isp, u32 irqstatus)\r\n{\r\nstatic const char *name[] = {\r\n"CSIA_IRQ",\r\n"res1",\r\n"res2",\r\n"CSIB_LCM_IRQ",\r\n"CSIB_IRQ",\r\n"res5",\r\n"res6",\r\n"res7",\r\n"CCDC_VD0_IRQ",\r\n"CCDC_VD1_IRQ",\r\n"CCDC_VD2_IRQ",\r\n"CCDC_ERR_IRQ",\r\n"H3A_AF_DONE_IRQ",\r\n"H3A_AWB_DONE_IRQ",\r\n"res14",\r\n"res15",\r\n"HIST_DONE_IRQ",\r\n"CCDC_LSC_DONE",\r\n"CCDC_LSC_PREFETCH_COMPLETED",\r\n"CCDC_LSC_PREFETCH_ERROR",\r\n"PRV_DONE_IRQ",\r\n"CBUFF_IRQ",\r\n"res22",\r\n"res23",\r\n"RSZ_DONE_IRQ",\r\n"OVF_IRQ",\r\n"res26",\r\n"res27",\r\n"MMU_ERR_IRQ",\r\n"OCP_ERR_IRQ",\r\n"SEC_ERR_IRQ",\r\n"HS_VS_IRQ",\r\n};\r\nint i;\r\ndev_dbg(isp->dev, "ISP IRQ: ");\r\nfor (i = 0; i < ARRAY_SIZE(name); i++) {\r\nif ((1 << i) & irqstatus)\r\nprintk(KERN_CONT "%s ", name[i]);\r\n}\r\nprintk(KERN_CONT "\n");\r\n}\r\nstatic void isp_isr_sbl(struct isp_device *isp)\r\n{\r\nstruct device *dev = isp->dev;\r\nstruct isp_pipeline *pipe;\r\nu32 sbl_pcr;\r\nsbl_pcr = isp_reg_readl(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_PCR);\r\nisp_reg_writel(isp, sbl_pcr, OMAP3_ISP_IOMEM_SBL, ISPSBL_PCR);\r\nsbl_pcr &= ~ISPSBL_PCR_CCDCPRV_2_RSZ_OVF;\r\nif (sbl_pcr)\r\ndev_dbg(dev, "SBL overflow (PCR = 0x%08x)\n", sbl_pcr);\r\nif (sbl_pcr & ISPSBL_PCR_CSIB_WBL_OVF) {\r\npipe = to_isp_pipeline(&isp->isp_ccp2.subdev.entity);\r\nif (pipe != NULL)\r\npipe->error = true;\r\n}\r\nif (sbl_pcr & ISPSBL_PCR_CSIA_WBL_OVF) {\r\npipe = to_isp_pipeline(&isp->isp_csi2a.subdev.entity);\r\nif (pipe != NULL)\r\npipe->error = true;\r\n}\r\nif (sbl_pcr & ISPSBL_PCR_CCDC_WBL_OVF) {\r\npipe = to_isp_pipeline(&isp->isp_ccdc.subdev.entity);\r\nif (pipe != NULL)\r\npipe->error = true;\r\n}\r\nif (sbl_pcr & ISPSBL_PCR_PRV_WBL_OVF) {\r\npipe = to_isp_pipeline(&isp->isp_prev.subdev.entity);\r\nif (pipe != NULL)\r\npipe->error = true;\r\n}\r\nif (sbl_pcr & (ISPSBL_PCR_RSZ1_WBL_OVF\r\n| ISPSBL_PCR_RSZ2_WBL_OVF\r\n| ISPSBL_PCR_RSZ3_WBL_OVF\r\n| ISPSBL_PCR_RSZ4_WBL_OVF)) {\r\npipe = to_isp_pipeline(&isp->isp_res.subdev.entity);\r\nif (pipe != NULL)\r\npipe->error = true;\r\n}\r\nif (sbl_pcr & ISPSBL_PCR_H3A_AF_WBL_OVF)\r\nomap3isp_stat_sbl_overflow(&isp->isp_af);\r\nif (sbl_pcr & ISPSBL_PCR_H3A_AEAWB_WBL_OVF)\r\nomap3isp_stat_sbl_overflow(&isp->isp_aewb);\r\n}\r\nstatic irqreturn_t isp_isr(int irq, void *_isp)\r\n{\r\nstatic const u32 ccdc_events = IRQ0STATUS_CCDC_LSC_PREF_ERR_IRQ |\r\nIRQ0STATUS_CCDC_LSC_DONE_IRQ |\r\nIRQ0STATUS_CCDC_VD0_IRQ |\r\nIRQ0STATUS_CCDC_VD1_IRQ |\r\nIRQ0STATUS_HS_VS_IRQ;\r\nstruct isp_device *isp = _isp;\r\nu32 irqstatus;\r\nirqstatus = isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);\r\nisp_reg_writel(isp, irqstatus, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);\r\nisp_isr_sbl(isp);\r\nif (irqstatus & IRQ0STATUS_CSIA_IRQ)\r\nomap3isp_csi2_isr(&isp->isp_csi2a);\r\nif (irqstatus & IRQ0STATUS_CSIB_IRQ)\r\nomap3isp_ccp2_isr(&isp->isp_ccp2);\r\nif (irqstatus & IRQ0STATUS_CCDC_VD0_IRQ) {\r\nif (isp->isp_ccdc.output & CCDC_OUTPUT_PREVIEW)\r\nomap3isp_preview_isr_frame_sync(&isp->isp_prev);\r\nif (isp->isp_ccdc.output & CCDC_OUTPUT_RESIZER)\r\nomap3isp_resizer_isr_frame_sync(&isp->isp_res);\r\nomap3isp_stat_isr_frame_sync(&isp->isp_aewb);\r\nomap3isp_stat_isr_frame_sync(&isp->isp_af);\r\nomap3isp_stat_isr_frame_sync(&isp->isp_hist);\r\n}\r\nif (irqstatus & ccdc_events)\r\nomap3isp_ccdc_isr(&isp->isp_ccdc, irqstatus & ccdc_events);\r\nif (irqstatus & IRQ0STATUS_PRV_DONE_IRQ) {\r\nif (isp->isp_prev.output & PREVIEW_OUTPUT_RESIZER)\r\nomap3isp_resizer_isr_frame_sync(&isp->isp_res);\r\nomap3isp_preview_isr(&isp->isp_prev);\r\n}\r\nif (irqstatus & IRQ0STATUS_RSZ_DONE_IRQ)\r\nomap3isp_resizer_isr(&isp->isp_res);\r\nif (irqstatus & IRQ0STATUS_H3A_AWB_DONE_IRQ)\r\nomap3isp_stat_isr(&isp->isp_aewb);\r\nif (irqstatus & IRQ0STATUS_H3A_AF_DONE_IRQ)\r\nomap3isp_stat_isr(&isp->isp_af);\r\nif (irqstatus & IRQ0STATUS_HIST_DONE_IRQ)\r\nomap3isp_stat_isr(&isp->isp_hist);\r\nomap3isp_flush(isp);\r\n#if defined(DEBUG) && defined(ISP_ISR_DEBUG)\r\nisp_isr_dbg(isp, irqstatus);\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int isp_pipeline_pm_use_count(struct media_entity *entity)\r\n{\r\nstruct media_entity_graph graph;\r\nint use = 0;\r\nmedia_entity_graph_walk_start(&graph, entity);\r\nwhile ((entity = media_entity_graph_walk_next(&graph))) {\r\nif (media_entity_type(entity) == MEDIA_ENT_T_DEVNODE)\r\nuse += entity->use_count;\r\n}\r\nreturn use;\r\n}\r\nstatic int isp_pipeline_pm_power_one(struct media_entity *entity, int change)\r\n{\r\nstruct v4l2_subdev *subdev;\r\nint ret;\r\nsubdev = media_entity_type(entity) == MEDIA_ENT_T_V4L2_SUBDEV\r\n? media_entity_to_v4l2_subdev(entity) : NULL;\r\nif (entity->use_count == 0 && change > 0 && subdev != NULL) {\r\nret = v4l2_subdev_call(subdev, core, s_power, 1);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn ret;\r\n}\r\nentity->use_count += change;\r\nWARN_ON(entity->use_count < 0);\r\nif (entity->use_count == 0 && change < 0 && subdev != NULL)\r\nv4l2_subdev_call(subdev, core, s_power, 0);\r\nreturn 0;\r\n}\r\nstatic int isp_pipeline_pm_power(struct media_entity *entity, int change)\r\n{\r\nstruct media_entity_graph graph;\r\nstruct media_entity *first = entity;\r\nint ret = 0;\r\nif (!change)\r\nreturn 0;\r\nmedia_entity_graph_walk_start(&graph, entity);\r\nwhile (!ret && (entity = media_entity_graph_walk_next(&graph)))\r\nif (media_entity_type(entity) != MEDIA_ENT_T_DEVNODE)\r\nret = isp_pipeline_pm_power_one(entity, change);\r\nif (!ret)\r\nreturn 0;\r\nmedia_entity_graph_walk_start(&graph, first);\r\nwhile ((first = media_entity_graph_walk_next(&graph))\r\n&& first != entity)\r\nif (media_entity_type(first) != MEDIA_ENT_T_DEVNODE)\r\nisp_pipeline_pm_power_one(first, -change);\r\nreturn ret;\r\n}\r\nint omap3isp_pipeline_pm_use(struct media_entity *entity, int use)\r\n{\r\nint change = use ? 1 : -1;\r\nint ret;\r\nmutex_lock(&entity->parent->graph_mutex);\r\nentity->use_count += change;\r\nWARN_ON(entity->use_count < 0);\r\nret = isp_pipeline_pm_power(entity, change);\r\nif (ret < 0)\r\nentity->use_count -= change;\r\nmutex_unlock(&entity->parent->graph_mutex);\r\nreturn ret;\r\n}\r\nstatic int isp_pipeline_link_notify(struct media_link *link, u32 flags,\r\nunsigned int notification)\r\n{\r\nstruct media_entity *source = link->source->entity;\r\nstruct media_entity *sink = link->sink->entity;\r\nint source_use = isp_pipeline_pm_use_count(source);\r\nint sink_use = isp_pipeline_pm_use_count(sink);\r\nint ret;\r\nif (notification == MEDIA_DEV_NOTIFY_POST_LINK_CH &&\r\n!(link->flags & MEDIA_LNK_FL_ENABLED)) {\r\nisp_pipeline_pm_power(source, -sink_use);\r\nisp_pipeline_pm_power(sink, -source_use);\r\nreturn 0;\r\n}\r\nif (notification == MEDIA_DEV_NOTIFY_POST_LINK_CH &&\r\n(flags & MEDIA_LNK_FL_ENABLED)) {\r\nret = isp_pipeline_pm_power(source, sink_use);\r\nif (ret < 0)\r\nreturn ret;\r\nret = isp_pipeline_pm_power(sink, source_use);\r\nif (ret < 0)\r\nisp_pipeline_pm_power(source, -sink_use);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int isp_pipeline_enable(struct isp_pipeline *pipe,\r\nenum isp_pipeline_stream_state mode)\r\n{\r\nstruct isp_device *isp = pipe->output->isp;\r\nstruct media_entity *entity;\r\nstruct media_pad *pad;\r\nstruct v4l2_subdev *subdev;\r\nunsigned long flags;\r\nint ret;\r\nif (pipe->entities & isp->crashed)\r\nreturn -EIO;\r\nspin_lock_irqsave(&pipe->lock, flags);\r\npipe->state &= ~(ISP_PIPELINE_IDLE_INPUT | ISP_PIPELINE_IDLE_OUTPUT);\r\nspin_unlock_irqrestore(&pipe->lock, flags);\r\npipe->do_propagation = false;\r\nentity = &pipe->output->video.entity;\r\nwhile (1) {\r\npad = &entity->pads[0];\r\nif (!(pad->flags & MEDIA_PAD_FL_SINK))\r\nbreak;\r\npad = media_entity_remote_pad(pad);\r\nif (pad == NULL ||\r\nmedia_entity_type(pad->entity) != MEDIA_ENT_T_V4L2_SUBDEV)\r\nbreak;\r\nentity = pad->entity;\r\nsubdev = media_entity_to_v4l2_subdev(entity);\r\nret = v4l2_subdev_call(subdev, video, s_stream, mode);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn ret;\r\nif (subdev == &isp->isp_ccdc.subdev) {\r\nv4l2_subdev_call(&isp->isp_aewb.subdev, video,\r\ns_stream, mode);\r\nv4l2_subdev_call(&isp->isp_af.subdev, video,\r\ns_stream, mode);\r\nv4l2_subdev_call(&isp->isp_hist.subdev, video,\r\ns_stream, mode);\r\npipe->do_propagation = true;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int isp_pipeline_wait_resizer(struct isp_device *isp)\r\n{\r\nreturn omap3isp_resizer_busy(&isp->isp_res);\r\n}\r\nstatic int isp_pipeline_wait_preview(struct isp_device *isp)\r\n{\r\nreturn omap3isp_preview_busy(&isp->isp_prev);\r\n}\r\nstatic int isp_pipeline_wait_ccdc(struct isp_device *isp)\r\n{\r\nreturn omap3isp_stat_busy(&isp->isp_af)\r\n|| omap3isp_stat_busy(&isp->isp_aewb)\r\n|| omap3isp_stat_busy(&isp->isp_hist)\r\n|| omap3isp_ccdc_busy(&isp->isp_ccdc);\r\n}\r\nstatic int isp_pipeline_wait(struct isp_device *isp,\r\nint(*busy)(struct isp_device *isp))\r\n{\r\nunsigned long timeout = jiffies + ISP_STOP_TIMEOUT;\r\nwhile (!time_after(jiffies, timeout)) {\r\nif (!busy(isp))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int isp_pipeline_disable(struct isp_pipeline *pipe)\r\n{\r\nstruct isp_device *isp = pipe->output->isp;\r\nstruct media_entity *entity;\r\nstruct media_pad *pad;\r\nstruct v4l2_subdev *subdev;\r\nint failure = 0;\r\nint ret;\r\nentity = &pipe->output->video.entity;\r\nwhile (1) {\r\npad = &entity->pads[0];\r\nif (!(pad->flags & MEDIA_PAD_FL_SINK))\r\nbreak;\r\npad = media_entity_remote_pad(pad);\r\nif (pad == NULL ||\r\nmedia_entity_type(pad->entity) != MEDIA_ENT_T_V4L2_SUBDEV)\r\nbreak;\r\nentity = pad->entity;\r\nsubdev = media_entity_to_v4l2_subdev(entity);\r\nif (subdev == &isp->isp_ccdc.subdev) {\r\nv4l2_subdev_call(&isp->isp_aewb.subdev,\r\nvideo, s_stream, 0);\r\nv4l2_subdev_call(&isp->isp_af.subdev,\r\nvideo, s_stream, 0);\r\nv4l2_subdev_call(&isp->isp_hist.subdev,\r\nvideo, s_stream, 0);\r\n}\r\nv4l2_subdev_call(subdev, video, s_stream, 0);\r\nif (subdev == &isp->isp_res.subdev)\r\nret = isp_pipeline_wait(isp, isp_pipeline_wait_resizer);\r\nelse if (subdev == &isp->isp_prev.subdev)\r\nret = isp_pipeline_wait(isp, isp_pipeline_wait_preview);\r\nelse if (subdev == &isp->isp_ccdc.subdev)\r\nret = isp_pipeline_wait(isp, isp_pipeline_wait_ccdc);\r\nelse\r\nret = 0;\r\nif (ret) {\r\ndev_info(isp->dev, "Unable to stop %s\n", subdev->name);\r\nisp->stop_failure = true;\r\nif (subdev == &isp->isp_prev.subdev)\r\nisp->crashed |= 1U << subdev->entity.id;\r\nfailure = -ETIMEDOUT;\r\n}\r\n}\r\nreturn failure;\r\n}\r\nint omap3isp_pipeline_set_stream(struct isp_pipeline *pipe,\r\nenum isp_pipeline_stream_state state)\r\n{\r\nint ret;\r\nif (state == ISP_PIPELINE_STREAM_STOPPED)\r\nret = isp_pipeline_disable(pipe);\r\nelse\r\nret = isp_pipeline_enable(pipe, state);\r\nif (ret == 0 || state == ISP_PIPELINE_STREAM_STOPPED)\r\npipe->stream_state = state;\r\nreturn ret;\r\n}\r\nvoid omap3isp_pipeline_cancel_stream(struct isp_pipeline *pipe)\r\n{\r\nif (pipe->input)\r\nomap3isp_video_cancel_stream(pipe->input);\r\nif (pipe->output)\r\nomap3isp_video_cancel_stream(pipe->output);\r\n}\r\nstatic void isp_pipeline_resume(struct isp_pipeline *pipe)\r\n{\r\nint singleshot = pipe->stream_state == ISP_PIPELINE_STREAM_SINGLESHOT;\r\nomap3isp_video_resume(pipe->output, !singleshot);\r\nif (singleshot)\r\nomap3isp_video_resume(pipe->input, 0);\r\nisp_pipeline_enable(pipe, pipe->stream_state);\r\n}\r\nstatic void isp_pipeline_suspend(struct isp_pipeline *pipe)\r\n{\r\nisp_pipeline_disable(pipe);\r\n}\r\nstatic int isp_pipeline_is_last(struct media_entity *me)\r\n{\r\nstruct isp_pipeline *pipe;\r\nstruct media_pad *pad;\r\nif (!me->pipe)\r\nreturn 0;\r\npipe = to_isp_pipeline(me);\r\nif (pipe->stream_state == ISP_PIPELINE_STREAM_STOPPED)\r\nreturn 0;\r\npad = media_entity_remote_pad(&pipe->output->pad);\r\nreturn pad->entity == me;\r\n}\r\nstatic void isp_suspend_module_pipeline(struct media_entity *me)\r\n{\r\nif (isp_pipeline_is_last(me))\r\nisp_pipeline_suspend(to_isp_pipeline(me));\r\n}\r\nstatic void isp_resume_module_pipeline(struct media_entity *me)\r\n{\r\nif (isp_pipeline_is_last(me))\r\nisp_pipeline_resume(to_isp_pipeline(me));\r\n}\r\nstatic int isp_suspend_modules(struct isp_device *isp)\r\n{\r\nunsigned long timeout;\r\nomap3isp_stat_suspend(&isp->isp_aewb);\r\nomap3isp_stat_suspend(&isp->isp_af);\r\nomap3isp_stat_suspend(&isp->isp_hist);\r\nisp_suspend_module_pipeline(&isp->isp_res.subdev.entity);\r\nisp_suspend_module_pipeline(&isp->isp_prev.subdev.entity);\r\nisp_suspend_module_pipeline(&isp->isp_ccdc.subdev.entity);\r\nisp_suspend_module_pipeline(&isp->isp_csi2a.subdev.entity);\r\nisp_suspend_module_pipeline(&isp->isp_ccp2.subdev.entity);\r\ntimeout = jiffies + ISP_STOP_TIMEOUT;\r\nwhile (omap3isp_stat_busy(&isp->isp_af)\r\n|| omap3isp_stat_busy(&isp->isp_aewb)\r\n|| omap3isp_stat_busy(&isp->isp_hist)\r\n|| omap3isp_preview_busy(&isp->isp_prev)\r\n|| omap3isp_resizer_busy(&isp->isp_res)\r\n|| omap3isp_ccdc_busy(&isp->isp_ccdc)) {\r\nif (time_after(jiffies, timeout)) {\r\ndev_info(isp->dev, "can't stop modules.\n");\r\nreturn 1;\r\n}\r\nmsleep(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic void isp_resume_modules(struct isp_device *isp)\r\n{\r\nomap3isp_stat_resume(&isp->isp_aewb);\r\nomap3isp_stat_resume(&isp->isp_af);\r\nomap3isp_stat_resume(&isp->isp_hist);\r\nisp_resume_module_pipeline(&isp->isp_res.subdev.entity);\r\nisp_resume_module_pipeline(&isp->isp_prev.subdev.entity);\r\nisp_resume_module_pipeline(&isp->isp_ccdc.subdev.entity);\r\nisp_resume_module_pipeline(&isp->isp_csi2a.subdev.entity);\r\nisp_resume_module_pipeline(&isp->isp_ccp2.subdev.entity);\r\n}\r\nstatic int isp_reset(struct isp_device *isp)\r\n{\r\nunsigned long timeout = 0;\r\nisp_reg_writel(isp,\r\nisp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN, ISP_SYSCONFIG)\r\n| ISP_SYSCONFIG_SOFTRESET,\r\nOMAP3_ISP_IOMEM_MAIN, ISP_SYSCONFIG);\r\nwhile (!(isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN,\r\nISP_SYSSTATUS) & 0x1)) {\r\nif (timeout++ > 10000) {\r\ndev_alert(isp->dev, "cannot reset ISP\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nudelay(1);\r\n}\r\nisp->stop_failure = false;\r\nisp->crashed = 0;\r\nreturn 0;\r\n}\r\nstatic void\r\nisp_save_context(struct isp_device *isp, struct isp_reg *reg_list)\r\n{\r\nstruct isp_reg *next = reg_list;\r\nfor (; next->reg != ISP_TOK_TERM; next++)\r\nnext->val = isp_reg_readl(isp, next->mmio_range, next->reg);\r\n}\r\nstatic void\r\nisp_restore_context(struct isp_device *isp, struct isp_reg *reg_list)\r\n{\r\nstruct isp_reg *next = reg_list;\r\nfor (; next->reg != ISP_TOK_TERM; next++)\r\nisp_reg_writel(isp, next->val, next->mmio_range, next->reg);\r\n}\r\nstatic void isp_save_ctx(struct isp_device *isp)\r\n{\r\nisp_save_context(isp, isp_reg_list);\r\nomap_iommu_save_ctx(isp->dev);\r\n}\r\nstatic void isp_restore_ctx(struct isp_device *isp)\r\n{\r\nisp_restore_context(isp, isp_reg_list);\r\nomap_iommu_restore_ctx(isp->dev);\r\nomap3isp_ccdc_restore_context(isp);\r\nomap3isp_preview_restore_context(isp);\r\n}\r\nvoid omap3isp_sbl_enable(struct isp_device *isp, enum isp_sbl_resource res)\r\n{\r\nu32 sbl = 0;\r\nisp->sbl_resources |= res;\r\nif (isp->sbl_resources & OMAP3_ISP_SBL_CSI1_READ)\r\nsbl |= ISPCTRL_SBL_SHARED_RPORTA;\r\nif (isp->sbl_resources & OMAP3_ISP_SBL_CCDC_LSC_READ)\r\nsbl |= ISPCTRL_SBL_SHARED_RPORTB;\r\nif (isp->sbl_resources & OMAP3_ISP_SBL_CSI2C_WRITE)\r\nsbl |= ISPCTRL_SBL_SHARED_WPORTC;\r\nif (isp->sbl_resources & OMAP3_ISP_SBL_RESIZER_WRITE)\r\nsbl |= ISPCTRL_SBL_WR0_RAM_EN;\r\nif (isp->sbl_resources & OMAP3_ISP_SBL_WRITE)\r\nsbl |= ISPCTRL_SBL_WR1_RAM_EN;\r\nif (isp->sbl_resources & OMAP3_ISP_SBL_READ)\r\nsbl |= ISPCTRL_SBL_RD_RAM_EN;\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL, sbl);\r\n}\r\nvoid omap3isp_sbl_disable(struct isp_device *isp, enum isp_sbl_resource res)\r\n{\r\nu32 sbl = 0;\r\nisp->sbl_resources &= ~res;\r\nif (!(isp->sbl_resources & OMAP3_ISP_SBL_CSI1_READ))\r\nsbl |= ISPCTRL_SBL_SHARED_RPORTA;\r\nif (!(isp->sbl_resources & OMAP3_ISP_SBL_CCDC_LSC_READ))\r\nsbl |= ISPCTRL_SBL_SHARED_RPORTB;\r\nif (!(isp->sbl_resources & OMAP3_ISP_SBL_CSI2C_WRITE))\r\nsbl |= ISPCTRL_SBL_SHARED_WPORTC;\r\nif (!(isp->sbl_resources & OMAP3_ISP_SBL_RESIZER_WRITE))\r\nsbl |= ISPCTRL_SBL_WR0_RAM_EN;\r\nif (!(isp->sbl_resources & OMAP3_ISP_SBL_WRITE))\r\nsbl |= ISPCTRL_SBL_WR1_RAM_EN;\r\nif (!(isp->sbl_resources & OMAP3_ISP_SBL_READ))\r\nsbl |= ISPCTRL_SBL_RD_RAM_EN;\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL, sbl);\r\n}\r\nint omap3isp_module_sync_idle(struct media_entity *me, wait_queue_head_t *wait,\r\natomic_t *stopping)\r\n{\r\nstruct isp_pipeline *pipe = to_isp_pipeline(me);\r\nif (pipe->stream_state == ISP_PIPELINE_STREAM_STOPPED ||\r\n(pipe->stream_state == ISP_PIPELINE_STREAM_SINGLESHOT &&\r\n!isp_pipeline_ready(pipe)))\r\nreturn 0;\r\natomic_set(stopping, 1);\r\nsmp_mb();\r\nif (isp_pipeline_is_last(me)) {\r\nstruct isp_video *video = pipe->output;\r\nunsigned long flags;\r\nspin_lock_irqsave(&video->irqlock, flags);\r\nif (video->dmaqueue_flags & ISP_VIDEO_DMAQUEUE_UNDERRUN) {\r\nspin_unlock_irqrestore(&video->irqlock, flags);\r\natomic_set(stopping, 0);\r\nsmp_mb();\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&video->irqlock, flags);\r\nif (!wait_event_timeout(*wait, !atomic_read(stopping),\r\nmsecs_to_jiffies(1000))) {\r\natomic_set(stopping, 0);\r\nsmp_mb();\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint omap3isp_module_sync_is_stopping(wait_queue_head_t *wait,\r\natomic_t *stopping)\r\n{\r\nif (atomic_cmpxchg(stopping, 1, 0)) {\r\nwake_up(wait);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __isp_subclk_update(struct isp_device *isp)\r\n{\r\nu32 clk = 0;\r\nif (isp->subclk_resources &\r\n(OMAP3_ISP_SUBCLK_AEWB | OMAP3_ISP_SUBCLK_AF))\r\nclk |= ISPCTRL_H3A_CLK_EN;\r\nif (isp->subclk_resources & OMAP3_ISP_SUBCLK_HIST)\r\nclk |= ISPCTRL_HIST_CLK_EN;\r\nif (isp->subclk_resources & OMAP3_ISP_SUBCLK_RESIZER)\r\nclk |= ISPCTRL_RSZ_CLK_EN;\r\nif (isp->subclk_resources & OMAP3_ISP_SUBCLK_CCDC)\r\nclk |= ISPCTRL_CCDC_CLK_EN | ISPCTRL_CCDC_RAM_EN;\r\nif (isp->subclk_resources & OMAP3_ISP_SUBCLK_PREVIEW)\r\nclk |= ISPCTRL_PREV_CLK_EN | ISPCTRL_PREV_RAM_EN;\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL,\r\nISPCTRL_CLKS_MASK, clk);\r\n}\r\nvoid omap3isp_subclk_enable(struct isp_device *isp,\r\nenum isp_subclk_resource res)\r\n{\r\nisp->subclk_resources |= res;\r\n__isp_subclk_update(isp);\r\n}\r\nvoid omap3isp_subclk_disable(struct isp_device *isp,\r\nenum isp_subclk_resource res)\r\n{\r\nisp->subclk_resources &= ~res;\r\n__isp_subclk_update(isp);\r\n}\r\nstatic int isp_enable_clocks(struct isp_device *isp)\r\n{\r\nint r;\r\nunsigned long rate;\r\nr = clk_prepare_enable(isp->clock[ISP_CLK_CAM_ICK]);\r\nif (r) {\r\ndev_err(isp->dev, "failed to enable cam_ick clock\n");\r\ngoto out_clk_enable_ick;\r\n}\r\nr = clk_set_rate(isp->clock[ISP_CLK_CAM_MCLK], CM_CAM_MCLK_HZ);\r\nif (r) {\r\ndev_err(isp->dev, "clk_set_rate for cam_mclk failed\n");\r\ngoto out_clk_enable_mclk;\r\n}\r\nr = clk_prepare_enable(isp->clock[ISP_CLK_CAM_MCLK]);\r\nif (r) {\r\ndev_err(isp->dev, "failed to enable cam_mclk clock\n");\r\ngoto out_clk_enable_mclk;\r\n}\r\nrate = clk_get_rate(isp->clock[ISP_CLK_CAM_MCLK]);\r\nif (rate != CM_CAM_MCLK_HZ)\r\ndev_warn(isp->dev, "unexpected cam_mclk rate:\n"\r\n" expected : %d\n"\r\n" actual : %ld\n", CM_CAM_MCLK_HZ, rate);\r\nr = clk_prepare_enable(isp->clock[ISP_CLK_CSI2_FCK]);\r\nif (r) {\r\ndev_err(isp->dev, "failed to enable csi2_fck clock\n");\r\ngoto out_clk_enable_csi2_fclk;\r\n}\r\nreturn 0;\r\nout_clk_enable_csi2_fclk:\r\nclk_disable_unprepare(isp->clock[ISP_CLK_CAM_MCLK]);\r\nout_clk_enable_mclk:\r\nclk_disable_unprepare(isp->clock[ISP_CLK_CAM_ICK]);\r\nout_clk_enable_ick:\r\nreturn r;\r\n}\r\nstatic void isp_disable_clocks(struct isp_device *isp)\r\n{\r\nclk_disable_unprepare(isp->clock[ISP_CLK_CAM_ICK]);\r\nclk_disable_unprepare(isp->clock[ISP_CLK_CAM_MCLK]);\r\nclk_disable_unprepare(isp->clock[ISP_CLK_CSI2_FCK]);\r\n}\r\nstatic int isp_get_clocks(struct isp_device *isp)\r\n{\r\nstruct clk *clk;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(isp_clocks); ++i) {\r\nclk = devm_clk_get(isp->dev, isp_clocks[i]);\r\nif (IS_ERR(clk)) {\r\ndev_err(isp->dev, "clk_get %s failed\n", isp_clocks[i]);\r\nreturn PTR_ERR(clk);\r\n}\r\nisp->clock[i] = clk;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct isp_device *__omap3isp_get(struct isp_device *isp, bool irq)\r\n{\r\nstruct isp_device *__isp = isp;\r\nif (isp == NULL)\r\nreturn NULL;\r\nmutex_lock(&isp->isp_mutex);\r\nif (isp->ref_count > 0)\r\ngoto out;\r\nif (isp_enable_clocks(isp) < 0) {\r\n__isp = NULL;\r\ngoto out;\r\n}\r\nif (isp->has_context)\r\nisp_restore_ctx(isp);\r\nif (irq)\r\nisp_enable_interrupts(isp);\r\nout:\r\nif (__isp != NULL)\r\nisp->ref_count++;\r\nmutex_unlock(&isp->isp_mutex);\r\nreturn __isp;\r\n}\r\nstruct isp_device *omap3isp_get(struct isp_device *isp)\r\n{\r\nreturn __omap3isp_get(isp, true);\r\n}\r\nstatic void __omap3isp_put(struct isp_device *isp, bool save_ctx)\r\n{\r\nif (isp == NULL)\r\nreturn;\r\nmutex_lock(&isp->isp_mutex);\r\nBUG_ON(isp->ref_count == 0);\r\nif (--isp->ref_count == 0) {\r\nisp_disable_interrupts(isp);\r\nif (save_ctx) {\r\nisp_save_ctx(isp);\r\nisp->has_context = 1;\r\n}\r\nif (isp->crashed || isp->stop_failure)\r\nisp_reset(isp);\r\nisp_disable_clocks(isp);\r\n}\r\nmutex_unlock(&isp->isp_mutex);\r\n}\r\nvoid omap3isp_put(struct isp_device *isp)\r\n{\r\n__omap3isp_put(isp, true);\r\n}\r\nvoid omap3isp_print_status(struct isp_device *isp)\r\n{\r\ndev_dbg(isp->dev, "-------------ISP Register dump--------------\n");\r\nISP_PRINT_REGISTER(isp, SYSCONFIG);\r\nISP_PRINT_REGISTER(isp, SYSSTATUS);\r\nISP_PRINT_REGISTER(isp, IRQ0ENABLE);\r\nISP_PRINT_REGISTER(isp, IRQ0STATUS);\r\nISP_PRINT_REGISTER(isp, TCTRL_GRESET_LENGTH);\r\nISP_PRINT_REGISTER(isp, TCTRL_PSTRB_REPLAY);\r\nISP_PRINT_REGISTER(isp, CTRL);\r\nISP_PRINT_REGISTER(isp, TCTRL_CTRL);\r\nISP_PRINT_REGISTER(isp, TCTRL_FRAME);\r\nISP_PRINT_REGISTER(isp, TCTRL_PSTRB_DELAY);\r\nISP_PRINT_REGISTER(isp, TCTRL_STRB_DELAY);\r\nISP_PRINT_REGISTER(isp, TCTRL_SHUT_DELAY);\r\nISP_PRINT_REGISTER(isp, TCTRL_PSTRB_LENGTH);\r\nISP_PRINT_REGISTER(isp, TCTRL_STRB_LENGTH);\r\nISP_PRINT_REGISTER(isp, TCTRL_SHUT_LENGTH);\r\nSBL_PRINT_REGISTER(isp, PCR);\r\nSBL_PRINT_REGISTER(isp, SDR_REQ_EXP);\r\ndev_dbg(isp->dev, "--------------------------------------------\n");\r\n}\r\nstatic int isp_pm_prepare(struct device *dev)\r\n{\r\nstruct isp_device *isp = dev_get_drvdata(dev);\r\nint reset;\r\nWARN_ON(mutex_is_locked(&isp->isp_mutex));\r\nif (isp->ref_count == 0)\r\nreturn 0;\r\nreset = isp_suspend_modules(isp);\r\nisp_disable_interrupts(isp);\r\nisp_save_ctx(isp);\r\nif (reset)\r\nisp_reset(isp);\r\nreturn 0;\r\n}\r\nstatic int isp_pm_suspend(struct device *dev)\r\n{\r\nstruct isp_device *isp = dev_get_drvdata(dev);\r\nWARN_ON(mutex_is_locked(&isp->isp_mutex));\r\nif (isp->ref_count)\r\nisp_disable_clocks(isp);\r\nreturn 0;\r\n}\r\nstatic int isp_pm_resume(struct device *dev)\r\n{\r\nstruct isp_device *isp = dev_get_drvdata(dev);\r\nif (isp->ref_count == 0)\r\nreturn 0;\r\nreturn isp_enable_clocks(isp);\r\n}\r\nstatic void isp_pm_complete(struct device *dev)\r\n{\r\nstruct isp_device *isp = dev_get_drvdata(dev);\r\nif (isp->ref_count == 0)\r\nreturn;\r\nisp_restore_ctx(isp);\r\nisp_enable_interrupts(isp);\r\nisp_resume_modules(isp);\r\n}\r\nstatic void isp_unregister_entities(struct isp_device *isp)\r\n{\r\nomap3isp_csi2_unregister_entities(&isp->isp_csi2a);\r\nomap3isp_ccp2_unregister_entities(&isp->isp_ccp2);\r\nomap3isp_ccdc_unregister_entities(&isp->isp_ccdc);\r\nomap3isp_preview_unregister_entities(&isp->isp_prev);\r\nomap3isp_resizer_unregister_entities(&isp->isp_res);\r\nomap3isp_stat_unregister_entities(&isp->isp_aewb);\r\nomap3isp_stat_unregister_entities(&isp->isp_af);\r\nomap3isp_stat_unregister_entities(&isp->isp_hist);\r\nv4l2_device_unregister(&isp->v4l2_dev);\r\nmedia_device_unregister(&isp->media_dev);\r\n}\r\nstatic struct v4l2_subdev *\r\nisp_register_subdev_group(struct isp_device *isp,\r\nstruct isp_subdev_i2c_board_info *board_info)\r\n{\r\nstruct v4l2_subdev *sensor = NULL;\r\nunsigned int first;\r\nif (board_info->board_info == NULL)\r\nreturn NULL;\r\nfor (first = 1; board_info->board_info; ++board_info, first = 0) {\r\nstruct v4l2_subdev *subdev;\r\nstruct i2c_adapter *adapter;\r\nadapter = i2c_get_adapter(board_info->i2c_adapter_id);\r\nif (adapter == NULL) {\r\ndev_err(isp->dev, "%s: Unable to get I2C adapter %d for "\r\n"device %s\n", __func__,\r\nboard_info->i2c_adapter_id,\r\nboard_info->board_info->type);\r\ncontinue;\r\n}\r\nsubdev = v4l2_i2c_new_subdev_board(&isp->v4l2_dev, adapter,\r\nboard_info->board_info, NULL);\r\nif (subdev == NULL) {\r\ndev_err(isp->dev, "%s: Unable to register subdev %s\n",\r\n__func__, board_info->board_info->type);\r\ncontinue;\r\n}\r\nif (first)\r\nsensor = subdev;\r\n}\r\nreturn sensor;\r\n}\r\nstatic int isp_register_entities(struct isp_device *isp)\r\n{\r\nstruct isp_platform_data *pdata = isp->pdata;\r\nstruct isp_v4l2_subdevs_group *subdevs;\r\nint ret;\r\nisp->media_dev.dev = isp->dev;\r\nstrlcpy(isp->media_dev.model, "TI OMAP3 ISP",\r\nsizeof(isp->media_dev.model));\r\nisp->media_dev.hw_revision = isp->revision;\r\nisp->media_dev.link_notify = isp_pipeline_link_notify;\r\nret = media_device_register(&isp->media_dev);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "%s: Media device registration failed (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nisp->v4l2_dev.mdev = &isp->media_dev;\r\nret = v4l2_device_register(isp->dev, &isp->v4l2_dev);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "%s: V4L2 device registration failed (%d)\n",\r\n__func__, ret);\r\ngoto done;\r\n}\r\nret = omap3isp_ccp2_register_entities(&isp->isp_ccp2, &isp->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nret = omap3isp_csi2_register_entities(&isp->isp_csi2a, &isp->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nret = omap3isp_ccdc_register_entities(&isp->isp_ccdc, &isp->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nret = omap3isp_preview_register_entities(&isp->isp_prev,\r\n&isp->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nret = omap3isp_resizer_register_entities(&isp->isp_res, &isp->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nret = omap3isp_stat_register_entities(&isp->isp_aewb, &isp->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nret = omap3isp_stat_register_entities(&isp->isp_af, &isp->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nret = omap3isp_stat_register_entities(&isp->isp_hist, &isp->v4l2_dev);\r\nif (ret < 0)\r\ngoto done;\r\nfor (subdevs = pdata->subdevs; subdevs && subdevs->subdevs; ++subdevs) {\r\nstruct v4l2_subdev *sensor;\r\nstruct media_entity *input;\r\nunsigned int flags;\r\nunsigned int pad;\r\nunsigned int i;\r\nsensor = isp_register_subdev_group(isp, subdevs->subdevs);\r\nif (sensor == NULL)\r\ncontinue;\r\nsensor->host_priv = subdevs;\r\nswitch (subdevs->interface) {\r\ncase ISP_INTERFACE_PARALLEL:\r\ninput = &isp->isp_ccdc.subdev.entity;\r\npad = CCDC_PAD_SINK;\r\nflags = 0;\r\nbreak;\r\ncase ISP_INTERFACE_CSI2A_PHY2:\r\ninput = &isp->isp_csi2a.subdev.entity;\r\npad = CSI2_PAD_SINK;\r\nflags = MEDIA_LNK_FL_IMMUTABLE\r\n| MEDIA_LNK_FL_ENABLED;\r\nbreak;\r\ncase ISP_INTERFACE_CCP2B_PHY1:\r\ncase ISP_INTERFACE_CCP2B_PHY2:\r\ninput = &isp->isp_ccp2.subdev.entity;\r\npad = CCP2_PAD_SINK;\r\nflags = 0;\r\nbreak;\r\ncase ISP_INTERFACE_CSI2C_PHY1:\r\ninput = &isp->isp_csi2c.subdev.entity;\r\npad = CSI2_PAD_SINK;\r\nflags = MEDIA_LNK_FL_IMMUTABLE\r\n| MEDIA_LNK_FL_ENABLED;\r\nbreak;\r\ndefault:\r\ndev_err(isp->dev, "%s: invalid interface type %u\n",\r\n__func__, subdevs->interface);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nfor (i = 0; i < sensor->entity.num_pads; i++) {\r\nif (sensor->entity.pads[i].flags & MEDIA_PAD_FL_SOURCE)\r\nbreak;\r\n}\r\nif (i == sensor->entity.num_pads) {\r\ndev_err(isp->dev,\r\n"%s: no source pad in external entity\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nret = media_entity_create_link(&sensor->entity, i, input, pad,\r\nflags);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\nret = v4l2_device_register_subdev_nodes(&isp->v4l2_dev);\r\ndone:\r\nif (ret < 0)\r\nisp_unregister_entities(isp);\r\nreturn ret;\r\n}\r\nstatic void isp_cleanup_modules(struct isp_device *isp)\r\n{\r\nomap3isp_h3a_aewb_cleanup(isp);\r\nomap3isp_h3a_af_cleanup(isp);\r\nomap3isp_hist_cleanup(isp);\r\nomap3isp_resizer_cleanup(isp);\r\nomap3isp_preview_cleanup(isp);\r\nomap3isp_ccdc_cleanup(isp);\r\nomap3isp_ccp2_cleanup(isp);\r\nomap3isp_csi2_cleanup(isp);\r\n}\r\nstatic int isp_initialize_modules(struct isp_device *isp)\r\n{\r\nint ret;\r\nret = omap3isp_csiphy_init(isp);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "CSI PHY initialization failed\n");\r\ngoto error_csiphy;\r\n}\r\nret = omap3isp_csi2_init(isp);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "CSI2 initialization failed\n");\r\ngoto error_csi2;\r\n}\r\nret = omap3isp_ccp2_init(isp);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "CCP2 initialization failed\n");\r\ngoto error_ccp2;\r\n}\r\nret = omap3isp_ccdc_init(isp);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "CCDC initialization failed\n");\r\ngoto error_ccdc;\r\n}\r\nret = omap3isp_preview_init(isp);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "Preview initialization failed\n");\r\ngoto error_preview;\r\n}\r\nret = omap3isp_resizer_init(isp);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "Resizer initialization failed\n");\r\ngoto error_resizer;\r\n}\r\nret = omap3isp_hist_init(isp);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "Histogram initialization failed\n");\r\ngoto error_hist;\r\n}\r\nret = omap3isp_h3a_aewb_init(isp);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "H3A AEWB initialization failed\n");\r\ngoto error_h3a_aewb;\r\n}\r\nret = omap3isp_h3a_af_init(isp);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "H3A AF initialization failed\n");\r\ngoto error_h3a_af;\r\n}\r\nret = media_entity_create_link(\r\n&isp->isp_csi2a.subdev.entity, CSI2_PAD_SOURCE,\r\n&isp->isp_ccdc.subdev.entity, CCDC_PAD_SINK, 0);\r\nif (ret < 0)\r\ngoto error_link;\r\nret = media_entity_create_link(\r\n&isp->isp_ccp2.subdev.entity, CCP2_PAD_SOURCE,\r\n&isp->isp_ccdc.subdev.entity, CCDC_PAD_SINK, 0);\r\nif (ret < 0)\r\ngoto error_link;\r\nret = media_entity_create_link(\r\n&isp->isp_ccdc.subdev.entity, CCDC_PAD_SOURCE_VP,\r\n&isp->isp_prev.subdev.entity, PREV_PAD_SINK, 0);\r\nif (ret < 0)\r\ngoto error_link;\r\nret = media_entity_create_link(\r\n&isp->isp_ccdc.subdev.entity, CCDC_PAD_SOURCE_OF,\r\n&isp->isp_res.subdev.entity, RESZ_PAD_SINK, 0);\r\nif (ret < 0)\r\ngoto error_link;\r\nret = media_entity_create_link(\r\n&isp->isp_prev.subdev.entity, PREV_PAD_SOURCE,\r\n&isp->isp_res.subdev.entity, RESZ_PAD_SINK, 0);\r\nif (ret < 0)\r\ngoto error_link;\r\nret = media_entity_create_link(\r\n&isp->isp_ccdc.subdev.entity, CCDC_PAD_SOURCE_VP,\r\n&isp->isp_aewb.subdev.entity, 0,\r\nMEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);\r\nif (ret < 0)\r\ngoto error_link;\r\nret = media_entity_create_link(\r\n&isp->isp_ccdc.subdev.entity, CCDC_PAD_SOURCE_VP,\r\n&isp->isp_af.subdev.entity, 0,\r\nMEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);\r\nif (ret < 0)\r\ngoto error_link;\r\nret = media_entity_create_link(\r\n&isp->isp_ccdc.subdev.entity, CCDC_PAD_SOURCE_VP,\r\n&isp->isp_hist.subdev.entity, 0,\r\nMEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);\r\nif (ret < 0)\r\ngoto error_link;\r\nreturn 0;\r\nerror_link:\r\nomap3isp_h3a_af_cleanup(isp);\r\nerror_h3a_af:\r\nomap3isp_h3a_aewb_cleanup(isp);\r\nerror_h3a_aewb:\r\nomap3isp_hist_cleanup(isp);\r\nerror_hist:\r\nomap3isp_resizer_cleanup(isp);\r\nerror_resizer:\r\nomap3isp_preview_cleanup(isp);\r\nerror_preview:\r\nomap3isp_ccdc_cleanup(isp);\r\nerror_ccdc:\r\nomap3isp_ccp2_cleanup(isp);\r\nerror_ccp2:\r\nomap3isp_csi2_cleanup(isp);\r\nerror_csi2:\r\nerror_csiphy:\r\nreturn ret;\r\n}\r\nstatic void isp_detach_iommu(struct isp_device *isp)\r\n{\r\narm_iommu_release_mapping(isp->mapping);\r\nisp->mapping = NULL;\r\niommu_group_remove_device(isp->dev);\r\n}\r\nstatic int isp_attach_iommu(struct isp_device *isp)\r\n{\r\nstruct dma_iommu_mapping *mapping;\r\nstruct iommu_group *group;\r\nint ret;\r\ngroup = iommu_group_alloc();\r\nif (IS_ERR(group)) {\r\ndev_err(isp->dev, "failed to allocate IOMMU group\n");\r\nreturn PTR_ERR(group);\r\n}\r\nret = iommu_group_add_device(group, isp->dev);\r\niommu_group_put(group);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "failed to add device to IPMMU group\n");\r\nreturn ret;\r\n}\r\nmapping = arm_iommu_create_mapping(&platform_bus_type, SZ_1G, SZ_2G);\r\nif (IS_ERR(mapping)) {\r\ndev_err(isp->dev, "failed to create ARM IOMMU mapping\n");\r\nret = PTR_ERR(mapping);\r\ngoto error;\r\n}\r\nisp->mapping = mapping;\r\nret = arm_iommu_attach_device(isp->dev, mapping);\r\nif (ret < 0) {\r\ndev_err(isp->dev, "failed to attach device to VA mapping\n");\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nisp_detach_iommu(isp);\r\nreturn ret;\r\n}\r\nstatic int isp_remove(struct platform_device *pdev)\r\n{\r\nstruct isp_device *isp = platform_get_drvdata(pdev);\r\nisp_unregister_entities(isp);\r\nisp_cleanup_modules(isp);\r\nisp_xclk_cleanup(isp);\r\n__omap3isp_get(isp, false);\r\nisp_detach_iommu(isp);\r\n__omap3isp_put(isp, false);\r\nreturn 0;\r\n}\r\nstatic int isp_map_mem_resource(struct platform_device *pdev,\r\nstruct isp_device *isp,\r\nenum isp_mem_resources res)\r\n{\r\nstruct resource *mem;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, res);\r\nisp->mmio_base[res] = devm_ioremap_resource(isp->dev, mem);\r\nif (IS_ERR(isp->mmio_base[res]))\r\nreturn PTR_ERR(isp->mmio_base[res]);\r\nisp->mmio_base_phys[res] = mem->start;\r\nreturn 0;\r\n}\r\nstatic int isp_probe(struct platform_device *pdev)\r\n{\r\nstruct isp_platform_data *pdata = pdev->dev.platform_data;\r\nstruct isp_device *isp;\r\nint ret;\r\nint i, m;\r\nif (pdata == NULL)\r\nreturn -EINVAL;\r\nisp = devm_kzalloc(&pdev->dev, sizeof(*isp), GFP_KERNEL);\r\nif (!isp) {\r\ndev_err(&pdev->dev, "could not allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nisp->autoidle = autoidle;\r\nmutex_init(&isp->isp_mutex);\r\nspin_lock_init(&isp->stat_lock);\r\nisp->dev = &pdev->dev;\r\nisp->pdata = pdata;\r\nisp->ref_count = 0;\r\nret = dma_coerce_mask_and_coherent(isp->dev, DMA_BIT_MASK(32));\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, isp);\r\nisp->isp_csiphy1.vdd = devm_regulator_get(&pdev->dev, "VDD_CSIPHY1");\r\nisp->isp_csiphy2.vdd = devm_regulator_get(&pdev->dev, "VDD_CSIPHY2");\r\nret = isp_map_mem_resource(pdev, isp, OMAP3_ISP_IOMEM_MAIN);\r\nif (ret < 0)\r\ngoto error;\r\nret = isp_get_clocks(isp);\r\nif (ret < 0)\r\ngoto error;\r\nret = clk_enable(isp->clock[ISP_CLK_CAM_ICK]);\r\nif (ret < 0)\r\ngoto error;\r\nisp->revision = isp_reg_readl(isp, OMAP3_ISP_IOMEM_MAIN, ISP_REVISION);\r\ndev_info(isp->dev, "Revision %d.%d found\n",\r\n(isp->revision & 0xf0) >> 4, isp->revision & 0x0f);\r\nclk_disable(isp->clock[ISP_CLK_CAM_ICK]);\r\nif (__omap3isp_get(isp, false) == NULL) {\r\nret = -ENODEV;\r\ngoto error;\r\n}\r\nret = isp_reset(isp);\r\nif (ret < 0)\r\ngoto error_isp;\r\nret = isp_xclk_init(isp);\r\nif (ret < 0)\r\ngoto error_isp;\r\nfor (m = 0; m < ARRAY_SIZE(isp_res_maps); m++)\r\nif (isp->revision == isp_res_maps[m].isp_rev)\r\nbreak;\r\nif (m == ARRAY_SIZE(isp_res_maps)) {\r\ndev_err(isp->dev, "No resource map found for ISP rev %d.%d\n",\r\n(isp->revision & 0xf0) >> 4, isp->revision & 0xf);\r\nret = -ENODEV;\r\ngoto error_isp;\r\n}\r\nfor (i = 1; i < OMAP3_ISP_IOMEM_LAST; i++) {\r\nif (isp_res_maps[m].map & 1 << i) {\r\nret = isp_map_mem_resource(pdev, isp, i);\r\nif (ret)\r\ngoto error_isp;\r\n}\r\n}\r\nret = isp_attach_iommu(isp);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "unable to attach to IOMMU\n");\r\ngoto error_isp;\r\n}\r\nisp->irq_num = platform_get_irq(pdev, 0);\r\nif (isp->irq_num <= 0) {\r\ndev_err(isp->dev, "No IRQ resource\n");\r\nret = -ENODEV;\r\ngoto error_iommu;\r\n}\r\nif (devm_request_irq(isp->dev, isp->irq_num, isp_isr, IRQF_SHARED,\r\n"OMAP3 ISP", isp)) {\r\ndev_err(isp->dev, "Unable to request IRQ\n");\r\nret = -EINVAL;\r\ngoto error_iommu;\r\n}\r\nret = isp_initialize_modules(isp);\r\nif (ret < 0)\r\ngoto error_iommu;\r\nret = isp_register_entities(isp);\r\nif (ret < 0)\r\ngoto error_modules;\r\nisp_core_init(isp, 1);\r\nomap3isp_put(isp);\r\nreturn 0;\r\nerror_modules:\r\nisp_cleanup_modules(isp);\r\nerror_iommu:\r\nisp_detach_iommu(isp);\r\nerror_isp:\r\nisp_xclk_cleanup(isp);\r\n__omap3isp_put(isp, false);\r\nerror:\r\nmutex_destroy(&isp->isp_mutex);\r\nreturn ret;\r\n}
