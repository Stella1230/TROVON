int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\r\nstruct file *filp)\r\n{\r\nint ret;\r\nstruct iattr newattrs;\r\nif (length < 0)\r\nreturn -EINVAL;\r\nnewattrs.ia_size = length;\r\nnewattrs.ia_valid = ATTR_SIZE | time_attrs;\r\nif (filp) {\r\nnewattrs.ia_file = filp;\r\nnewattrs.ia_valid |= ATTR_FILE;\r\n}\r\nret = should_remove_suid(dentry);\r\nif (ret)\r\nnewattrs.ia_valid |= ret | ATTR_FORCE;\r\nmutex_lock(&dentry->d_inode->i_mutex);\r\nret = notify_change(dentry, &newattrs, NULL);\r\nmutex_unlock(&dentry->d_inode->i_mutex);\r\nreturn ret;\r\n}\r\nlong vfs_truncate(struct path *path, loff_t length)\r\n{\r\nstruct inode *inode;\r\nlong error;\r\ninode = path->dentry->d_inode;\r\nif (S_ISDIR(inode->i_mode))\r\nreturn -EISDIR;\r\nif (!S_ISREG(inode->i_mode))\r\nreturn -EINVAL;\r\nerror = mnt_want_write(path->mnt);\r\nif (error)\r\ngoto out;\r\nerror = inode_permission(inode, MAY_WRITE);\r\nif (error)\r\ngoto mnt_drop_write_and_out;\r\nerror = -EPERM;\r\nif (IS_APPEND(inode))\r\ngoto mnt_drop_write_and_out;\r\nerror = get_write_access(inode);\r\nif (error)\r\ngoto mnt_drop_write_and_out;\r\nerror = break_lease(inode, O_WRONLY);\r\nif (error)\r\ngoto put_write_and_out;\r\nerror = locks_verify_truncate(inode, NULL, length);\r\nif (!error)\r\nerror = security_path_truncate(path);\r\nif (!error)\r\nerror = do_truncate(path->dentry, length, 0, NULL);\r\nput_write_and_out:\r\nput_write_access(inode);\r\nmnt_drop_write_and_out:\r\nmnt_drop_write(path->mnt);\r\nout:\r\nreturn error;\r\n}\r\nstatic long do_sys_truncate(const char __user *pathname, loff_t length)\r\n{\r\nunsigned int lookup_flags = LOOKUP_FOLLOW;\r\nstruct path path;\r\nint error;\r\nif (length < 0)\r\nreturn -EINVAL;\r\nretry:\r\nerror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\r\nif (!error) {\r\nerror = vfs_truncate(&path, length);\r\npath_put(&path);\r\n}\r\nif (retry_estale(error, lookup_flags)) {\r\nlookup_flags |= LOOKUP_REVAL;\r\ngoto retry;\r\n}\r\nreturn error;\r\n}\r\nstatic long do_sys_ftruncate(unsigned int fd, loff_t length, int small)\r\n{\r\nstruct inode *inode;\r\nstruct dentry *dentry;\r\nstruct fd f;\r\nint error;\r\nerror = -EINVAL;\r\nif (length < 0)\r\ngoto out;\r\nerror = -EBADF;\r\nf = fdget(fd);\r\nif (!f.file)\r\ngoto out;\r\nif (f.file->f_flags & O_LARGEFILE)\r\nsmall = 0;\r\ndentry = f.file->f_path.dentry;\r\ninode = dentry->d_inode;\r\nerror = -EINVAL;\r\nif (!S_ISREG(inode->i_mode) || !(f.file->f_mode & FMODE_WRITE))\r\ngoto out_putf;\r\nerror = -EINVAL;\r\nif (small && length > MAX_NON_LFS)\r\ngoto out_putf;\r\nerror = -EPERM;\r\nif (IS_APPEND(inode))\r\ngoto out_putf;\r\nsb_start_write(inode->i_sb);\r\nerror = locks_verify_truncate(inode, f.file, length);\r\nif (!error)\r\nerror = security_path_truncate(&f.file->f_path);\r\nif (!error)\r\nerror = do_truncate(dentry, length, ATTR_MTIME|ATTR_CTIME, f.file);\r\nsb_end_write(inode->i_sb);\r\nout_putf:\r\nfdput(f);\r\nout:\r\nreturn error;\r\n}\r\nint do_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nlong ret;\r\nif (offset < 0 || len <= 0)\r\nreturn -EINVAL;\r\nif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |\r\nFALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_ZERO_RANGE))\r\nreturn -EOPNOTSUPP;\r\nif ((mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) ==\r\n(FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE))\r\nreturn -EOPNOTSUPP;\r\nif ((mode & FALLOC_FL_PUNCH_HOLE) &&\r\n!(mode & FALLOC_FL_KEEP_SIZE))\r\nreturn -EOPNOTSUPP;\r\nif ((mode & FALLOC_FL_COLLAPSE_RANGE) &&\r\n(mode & ~FALLOC_FL_COLLAPSE_RANGE))\r\nreturn -EINVAL;\r\nif (!(file->f_mode & FMODE_WRITE))\r\nreturn -EBADF;\r\nif ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))\r\nreturn -EPERM;\r\nif (IS_IMMUTABLE(inode))\r\nreturn -EPERM;\r\nif (IS_SWAPFILE(inode))\r\nreturn -ETXTBSY;\r\nret = security_file_permission(file, MAY_WRITE);\r\nif (ret)\r\nreturn ret;\r\nif (S_ISFIFO(inode->i_mode))\r\nreturn -ESPIPE;\r\nif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\r\nreturn -ENODEV;\r\nif (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))\r\nreturn -EFBIG;\r\nif (!file->f_op->fallocate)\r\nreturn -EOPNOTSUPP;\r\nsb_start_write(inode->i_sb);\r\nret = file->f_op->fallocate(file, mode, offset, len);\r\nsb_end_write(inode->i_sb);\r\nreturn ret;\r\n}\r\nstatic int chmod_common(struct path *path, umode_t mode)\r\n{\r\nstruct inode *inode = path->dentry->d_inode;\r\nstruct inode *delegated_inode = NULL;\r\nstruct iattr newattrs;\r\nint error;\r\nerror = mnt_want_write(path->mnt);\r\nif (error)\r\nreturn error;\r\nretry_deleg:\r\nmutex_lock(&inode->i_mutex);\r\nerror = security_path_chmod(path, mode);\r\nif (error)\r\ngoto out_unlock;\r\nnewattrs.ia_mode = (mode & S_IALLUGO) | (inode->i_mode & ~S_IALLUGO);\r\nnewattrs.ia_valid = ATTR_MODE | ATTR_CTIME;\r\nerror = notify_change(path->dentry, &newattrs, &delegated_inode);\r\nout_unlock:\r\nmutex_unlock(&inode->i_mutex);\r\nif (delegated_inode) {\r\nerror = break_deleg_wait(&delegated_inode);\r\nif (!error)\r\ngoto retry_deleg;\r\n}\r\nmnt_drop_write(path->mnt);\r\nreturn error;\r\n}\r\nstatic int chown_common(struct path *path, uid_t user, gid_t group)\r\n{\r\nstruct inode *inode = path->dentry->d_inode;\r\nstruct inode *delegated_inode = NULL;\r\nint error;\r\nstruct iattr newattrs;\r\nkuid_t uid;\r\nkgid_t gid;\r\nuid = make_kuid(current_user_ns(), user);\r\ngid = make_kgid(current_user_ns(), group);\r\nnewattrs.ia_valid = ATTR_CTIME;\r\nif (user != (uid_t) -1) {\r\nif (!uid_valid(uid))\r\nreturn -EINVAL;\r\nnewattrs.ia_valid |= ATTR_UID;\r\nnewattrs.ia_uid = uid;\r\n}\r\nif (group != (gid_t) -1) {\r\nif (!gid_valid(gid))\r\nreturn -EINVAL;\r\nnewattrs.ia_valid |= ATTR_GID;\r\nnewattrs.ia_gid = gid;\r\n}\r\nif (!S_ISDIR(inode->i_mode))\r\nnewattrs.ia_valid |=\r\nATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_KILL_PRIV;\r\nretry_deleg:\r\nmutex_lock(&inode->i_mutex);\r\nerror = security_path_chown(path, uid, gid);\r\nif (!error)\r\nerror = notify_change(path->dentry, &newattrs, &delegated_inode);\r\nmutex_unlock(&inode->i_mutex);\r\nif (delegated_inode) {\r\nerror = break_deleg_wait(&delegated_inode);\r\nif (!error)\r\ngoto retry_deleg;\r\n}\r\nreturn error;\r\n}\r\nint open_check_o_direct(struct file *f)\r\n{\r\nif (f->f_flags & O_DIRECT) {\r\nif (!f->f_mapping->a_ops ||\r\n((!f->f_mapping->a_ops->direct_IO) &&\r\n(!f->f_mapping->a_ops->get_xip_mem))) {\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_dentry_open(struct file *f,\r\nint (*open)(struct inode *, struct file *),\r\nconst struct cred *cred)\r\n{\r\nstatic const struct file_operations empty_fops = {};\r\nstruct inode *inode;\r\nint error;\r\nf->f_mode = OPEN_FMODE(f->f_flags) | FMODE_LSEEK |\r\nFMODE_PREAD | FMODE_PWRITE;\r\npath_get(&f->f_path);\r\ninode = f->f_inode = f->f_path.dentry->d_inode;\r\nf->f_mapping = inode->i_mapping;\r\nif (unlikely(f->f_flags & O_PATH)) {\r\nf->f_mode = FMODE_PATH;\r\nf->f_op = &empty_fops;\r\nreturn 0;\r\n}\r\nif (f->f_mode & FMODE_WRITE && !special_file(inode->i_mode)) {\r\nerror = get_write_access(inode);\r\nif (unlikely(error))\r\ngoto cleanup_file;\r\nerror = __mnt_want_write(f->f_path.mnt);\r\nif (unlikely(error)) {\r\nput_write_access(inode);\r\ngoto cleanup_file;\r\n}\r\nf->f_mode |= FMODE_WRITER;\r\n}\r\nif (S_ISREG(inode->i_mode))\r\nf->f_mode |= FMODE_ATOMIC_POS;\r\nf->f_op = fops_get(inode->i_fop);\r\nif (unlikely(WARN_ON(!f->f_op))) {\r\nerror = -ENODEV;\r\ngoto cleanup_all;\r\n}\r\nerror = security_file_open(f, cred);\r\nif (error)\r\ngoto cleanup_all;\r\nerror = break_lease(inode, f->f_flags);\r\nif (error)\r\ngoto cleanup_all;\r\nif (!open)\r\nopen = f->f_op->open;\r\nif (open) {\r\nerror = open(inode, f);\r\nif (error)\r\ngoto cleanup_all;\r\n}\r\nif ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\r\ni_readcount_inc(inode);\r\nif ((f->f_mode & FMODE_READ) &&\r\nlikely(f->f_op->read || f->f_op->aio_read || f->f_op->read_iter))\r\nf->f_mode |= FMODE_CAN_READ;\r\nif ((f->f_mode & FMODE_WRITE) &&\r\nlikely(f->f_op->write || f->f_op->aio_write || f->f_op->write_iter))\r\nf->f_mode |= FMODE_CAN_WRITE;\r\nf->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);\r\nfile_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping);\r\nreturn 0;\r\ncleanup_all:\r\nfops_put(f->f_op);\r\nif (f->f_mode & FMODE_WRITER) {\r\nput_write_access(inode);\r\n__mnt_drop_write(f->f_path.mnt);\r\n}\r\ncleanup_file:\r\npath_put(&f->f_path);\r\nf->f_path.mnt = NULL;\r\nf->f_path.dentry = NULL;\r\nf->f_inode = NULL;\r\nreturn error;\r\n}\r\nint finish_open(struct file *file, struct dentry *dentry,\r\nint (*open)(struct inode *, struct file *),\r\nint *opened)\r\n{\r\nint error;\r\nBUG_ON(*opened & FILE_OPENED);\r\nfile->f_path.dentry = dentry;\r\nerror = do_dentry_open(file, open, current_cred());\r\nif (!error)\r\n*opened |= FILE_OPENED;\r\nreturn error;\r\n}\r\nint finish_no_open(struct file *file, struct dentry *dentry)\r\n{\r\nfile->f_path.dentry = dentry;\r\nreturn 1;\r\n}\r\nstruct file *dentry_open(const struct path *path, int flags,\r\nconst struct cred *cred)\r\n{\r\nint error;\r\nstruct file *f;\r\nvalidate_creds(cred);\r\nBUG_ON(!path->mnt);\r\nf = get_empty_filp();\r\nif (!IS_ERR(f)) {\r\nf->f_flags = flags;\r\nf->f_path = *path;\r\nerror = do_dentry_open(f, NULL, cred);\r\nif (!error) {\r\nerror = open_check_o_direct(f);\r\nif (error) {\r\nfput(f);\r\nf = ERR_PTR(error);\r\n}\r\n} else {\r\nput_filp(f);\r\nf = ERR_PTR(error);\r\n}\r\n}\r\nreturn f;\r\n}\r\nstatic inline int build_open_flags(int flags, umode_t mode, struct open_flags *op)\r\n{\r\nint lookup_flags = 0;\r\nint acc_mode;\r\nif (flags & (O_CREAT | __O_TMPFILE))\r\nop->mode = (mode & S_IALLUGO) | S_IFREG;\r\nelse\r\nop->mode = 0;\r\nflags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;\r\nif (flags & __O_SYNC)\r\nflags |= O_DSYNC;\r\nif (flags & __O_TMPFILE) {\r\nif ((flags & O_TMPFILE_MASK) != O_TMPFILE)\r\nreturn -EINVAL;\r\nacc_mode = MAY_OPEN | ACC_MODE(flags);\r\nif (!(acc_mode & MAY_WRITE))\r\nreturn -EINVAL;\r\n} else if (flags & O_PATH) {\r\nflags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;\r\nacc_mode = 0;\r\n} else {\r\nacc_mode = MAY_OPEN | ACC_MODE(flags);\r\n}\r\nop->open_flag = flags;\r\nif (flags & O_TRUNC)\r\nacc_mode |= MAY_WRITE;\r\nif (flags & O_APPEND)\r\nacc_mode |= MAY_APPEND;\r\nop->acc_mode = acc_mode;\r\nop->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;\r\nif (flags & O_CREAT) {\r\nop->intent |= LOOKUP_CREATE;\r\nif (flags & O_EXCL)\r\nop->intent |= LOOKUP_EXCL;\r\n}\r\nif (flags & O_DIRECTORY)\r\nlookup_flags |= LOOKUP_DIRECTORY;\r\nif (!(flags & O_NOFOLLOW))\r\nlookup_flags |= LOOKUP_FOLLOW;\r\nop->lookup_flags = lookup_flags;\r\nreturn 0;\r\n}\r\nstruct file *file_open_name(struct filename *name, int flags, umode_t mode)\r\n{\r\nstruct open_flags op;\r\nint err = build_open_flags(flags, mode, &op);\r\nreturn err ? ERR_PTR(err) : do_filp_open(AT_FDCWD, name, &op);\r\n}\r\nstruct file *filp_open(const char *filename, int flags, umode_t mode)\r\n{\r\nstruct filename name = {.name = filename};\r\nreturn file_open_name(&name, flags, mode);\r\n}\r\nstruct file *file_open_root(struct dentry *dentry, struct vfsmount *mnt,\r\nconst char *filename, int flags)\r\n{\r\nstruct open_flags op;\r\nint err = build_open_flags(flags, 0, &op);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nif (flags & O_CREAT)\r\nreturn ERR_PTR(-EINVAL);\r\nif (!filename && (flags & O_DIRECTORY))\r\nif (!dentry->d_inode->i_op->lookup)\r\nreturn ERR_PTR(-ENOTDIR);\r\nreturn do_file_open_root(dentry, mnt, filename, &op);\r\n}\r\nlong do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)\r\n{\r\nstruct open_flags op;\r\nint fd = build_open_flags(flags, mode, &op);\r\nstruct filename *tmp;\r\nif (fd)\r\nreturn fd;\r\ntmp = getname(filename);\r\nif (IS_ERR(tmp))\r\nreturn PTR_ERR(tmp);\r\nfd = get_unused_fd_flags(flags);\r\nif (fd >= 0) {\r\nstruct file *f = do_filp_open(dfd, tmp, &op);\r\nif (IS_ERR(f)) {\r\nput_unused_fd(fd);\r\nfd = PTR_ERR(f);\r\n} else {\r\nfsnotify_open(f);\r\nfd_install(fd, f);\r\n}\r\n}\r\nputname(tmp);\r\nreturn fd;\r\n}\r\nint filp_close(struct file *filp, fl_owner_t id)\r\n{\r\nint retval = 0;\r\nif (!file_count(filp)) {\r\nprintk(KERN_ERR "VFS: Close: file count is 0\n");\r\nreturn 0;\r\n}\r\nif (filp->f_op->flush)\r\nretval = filp->f_op->flush(filp, id);\r\nif (likely(!(filp->f_mode & FMODE_PATH))) {\r\ndnotify_flush(filp, id);\r\nlocks_remove_posix(filp, id);\r\n}\r\nfput(filp);\r\nreturn retval;\r\n}\r\nint generic_file_open(struct inode * inode, struct file * filp)\r\n{\r\nif (!(filp->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\r\nreturn -EOVERFLOW;\r\nreturn 0;\r\n}\r\nint nonseekable_open(struct inode *inode, struct file *filp)\r\n{\r\nfilp->f_mode &= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE);\r\nreturn 0;\r\n}
