static void print_data(const char *data, int len)\r\n{\r\nint i;\r\nconst char *p = data;\r\nif (len == 0)\r\nreturn;\r\nif (util_is_printable_string(data, len)) {\r\nprintf(" = \"%s\"", (const char *)data);\r\n} else if ((len % 4) == 0) {\r\nprintf(" = <");\r\nfor (i = 0; i < len; i += 4)\r\nprintf("0x%08x%s", fdt32_to_cpu(GET_CELL(p)),\r\ni < (len - 4) ? " " : "");\r\nprintf(">");\r\n} else {\r\nprintf(" = [");\r\nfor (i = 0; i < len; i++)\r\nprintf("%02x%s", *p++, i < len - 1 ? " " : "");\r\nprintf("]");\r\n}\r\n}\r\nstatic void dump_blob(void *blob)\r\n{\r\nstruct fdt_header *bph = blob;\r\nuint32_t off_mem_rsvmap = fdt32_to_cpu(bph->off_mem_rsvmap);\r\nuint32_t off_dt = fdt32_to_cpu(bph->off_dt_struct);\r\nuint32_t off_str = fdt32_to_cpu(bph->off_dt_strings);\r\nstruct fdt_reserve_entry *p_rsvmap =\r\n(struct fdt_reserve_entry *)((char *)blob + off_mem_rsvmap);\r\nconst char *p_struct = (const char *)blob + off_dt;\r\nconst char *p_strings = (const char *)blob + off_str;\r\nuint32_t version = fdt32_to_cpu(bph->version);\r\nuint32_t totalsize = fdt32_to_cpu(bph->totalsize);\r\nuint32_t tag;\r\nconst char *p, *s, *t;\r\nint depth, sz, shift;\r\nint i;\r\nuint64_t addr, size;\r\ndepth = 0;\r\nshift = 4;\r\nprintf("/dts-v1/;\n");\r\nprintf("// magic:\t\t0x%x\n", fdt32_to_cpu(bph->magic));\r\nprintf("// totalsize:\t\t0x%x (%d)\n", totalsize, totalsize);\r\nprintf("// off_dt_struct:\t0x%x\n", off_dt);\r\nprintf("// off_dt_strings:\t0x%x\n", off_str);\r\nprintf("// off_mem_rsvmap:\t0x%x\n", off_mem_rsvmap);\r\nprintf("// version:\t\t%d\n", version);\r\nprintf("// last_comp_version:\t%d\n",\r\nfdt32_to_cpu(bph->last_comp_version));\r\nif (version >= 2)\r\nprintf("// boot_cpuid_phys:\t0x%x\n",\r\nfdt32_to_cpu(bph->boot_cpuid_phys));\r\nif (version >= 3)\r\nprintf("// size_dt_strings:\t0x%x\n",\r\nfdt32_to_cpu(bph->size_dt_strings));\r\nif (version >= 17)\r\nprintf("// size_dt_struct:\t0x%x\n",\r\nfdt32_to_cpu(bph->size_dt_struct));\r\nprintf("\n");\r\nfor (i = 0; ; i++) {\r\naddr = fdt64_to_cpu(p_rsvmap[i].address);\r\nsize = fdt64_to_cpu(p_rsvmap[i].size);\r\nif (addr == 0 && size == 0)\r\nbreak;\r\nprintf("/memreserve/ %llx %llx;\n",\r\n(unsigned long long)addr, (unsigned long long)size);\r\n}\r\np = p_struct;\r\nwhile ((tag = fdt32_to_cpu(GET_CELL(p))) != FDT_END) {\r\nif (tag == FDT_BEGIN_NODE) {\r\ns = p;\r\np = PALIGN(p + strlen(s) + 1, 4);\r\nif (*s == '\0')\r\ns = "/";\r\nprintf("%*s%s {\n", depth * shift, "", s);\r\ndepth++;\r\ncontinue;\r\n}\r\nif (tag == FDT_END_NODE) {\r\ndepth--;\r\nprintf("%*s};\n", depth * shift, "");\r\ncontinue;\r\n}\r\nif (tag == FDT_NOP) {\r\nprintf("%*s// [NOP]\n", depth * shift, "");\r\ncontinue;\r\n}\r\nif (tag != FDT_PROP) {\r\nfprintf(stderr, "%*s ** Unknown tag 0x%08x\n", depth * shift, "", tag);\r\nbreak;\r\n}\r\nsz = fdt32_to_cpu(GET_CELL(p));\r\ns = p_strings + fdt32_to_cpu(GET_CELL(p));\r\nif (version < 16 && sz >= 8)\r\np = PALIGN(p, 8);\r\nt = p;\r\np = PALIGN(p + sz, 4);\r\nprintf("%*s%s", depth * shift, "", s);\r\nprint_data(t, sz);\r\nprintf(";\n");\r\n}\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nchar *buf;\r\nif (argc < 2) {\r\nfprintf(stderr, "supply input filename\n");\r\nreturn 5;\r\n}\r\nbuf = utilfdt_read(argv[1]);\r\nif (buf)\r\ndump_blob(buf);\r\nelse\r\nreturn 10;\r\nreturn 0;\r\n}
