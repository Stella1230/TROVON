static void write_rreg(u_long base, u_int reg, u_int val)\r\n{\r\nasm volatile(\r\n"str%?h %1, [%2] @ NET_RAP\n\t"\r\n"str%?h %0, [%2, #-4] @ NET_RDP"\r\n:\r\n: "r" (val), "r" (reg), "r" (ISAIO_BASE + 0x0464));\r\n}\r\nstatic inline unsigned short read_rreg(u_long base_addr, u_int reg)\r\n{\r\nunsigned short v;\r\nasm volatile(\r\n"str%?h %1, [%2] @ NET_RAP\n\t"\r\n"ldr%?h %0, [%2, #-4] @ NET_RDP"\r\n: "=r" (v)\r\n: "r" (reg), "r" (ISAIO_BASE + 0x0464));\r\nreturn v;\r\n}\r\nstatic inline void write_ireg(u_long base, u_int reg, u_int val)\r\n{\r\nasm volatile(\r\n"str%?h %1, [%2] @ NET_RAP\n\t"\r\n"str%?h %0, [%2, #8] @ NET_IDP"\r\n:\r\n: "r" (val), "r" (reg), "r" (ISAIO_BASE + 0x0464));\r\n}\r\nstatic inline unsigned short read_ireg(u_long base_addr, u_int reg)\r\n{\r\nu_short v;\r\nasm volatile(\r\n"str%?h %1, [%2] @ NAT_RAP\n\t"\r\n"ldr%?h %0, [%2, #8] @ NET_IDP\n\t"\r\n: "=r" (v)\r\n: "r" (reg), "r" (ISAIO_BASE + 0x0464));\r\nreturn v;\r\n}\r\nstatic void\r\nam_writebuffer(struct net_device *dev, u_int offset, unsigned char *buf, unsigned int length)\r\n{\r\noffset = ISAMEM_BASE + (offset << 1);\r\nlength = (length + 1) & ~1;\r\nif ((int)buf & 2) {\r\nasm volatile("str%?h %2, [%0], #4"\r\n: "=&r" (offset) : "0" (offset), "r" (buf[0] | (buf[1] << 8)));\r\nbuf += 2;\r\nlength -= 2;\r\n}\r\nwhile (length > 8) {\r\nregister unsigned int tmp asm("r2"), tmp2 asm("r3");\r\nasm volatile(\r\n"ldm%?ia %0!, {%1, %2}"\r\n: "+r" (buf), "=&r" (tmp), "=&r" (tmp2));\r\nlength -= 8;\r\nasm volatile(\r\n"str%?h %1, [%0], #4\n\t"\r\n"mov%? %1, %1, lsr #16\n\t"\r\n"str%?h %1, [%0], #4\n\t"\r\n"str%?h %2, [%0], #4\n\t"\r\n"mov%? %2, %2, lsr #16\n\t"\r\n"str%?h %2, [%0], #4"\r\n: "+r" (offset), "=&r" (tmp), "=&r" (tmp2));\r\n}\r\nwhile (length > 0) {\r\nasm volatile("str%?h %2, [%0], #4"\r\n: "=&r" (offset) : "0" (offset), "r" (buf[0] | (buf[1] << 8)));\r\nbuf += 2;\r\nlength -= 2;\r\n}\r\n}\r\nstatic void\r\nam_readbuffer(struct net_device *dev, u_int offset, unsigned char *buf, unsigned int length)\r\n{\r\noffset = ISAMEM_BASE + (offset << 1);\r\nlength = (length + 1) & ~1;\r\nif ((int)buf & 2) {\r\nunsigned int tmp;\r\nasm volatile(\r\n"ldr%?h %2, [%0], #4\n\t"\r\n"str%?b %2, [%1], #1\n\t"\r\n"mov%? %2, %2, lsr #8\n\t"\r\n"str%?b %2, [%1], #1"\r\n: "=&r" (offset), "=&r" (buf), "=r" (tmp): "0" (offset), "1" (buf));\r\nlength -= 2;\r\n}\r\nwhile (length > 8) {\r\nregister unsigned int tmp asm("r2"), tmp2 asm("r3"), tmp3;\r\nasm volatile(\r\n"ldr%?h %2, [%0], #4\n\t"\r\n"ldr%?h %4, [%0], #4\n\t"\r\n"ldr%?h %3, [%0], #4\n\t"\r\n"orr%? %2, %2, %4, lsl #16\n\t"\r\n"ldr%?h %4, [%0], #4\n\t"\r\n"orr%? %3, %3, %4, lsl #16\n\t"\r\n"stm%?ia %1!, {%2, %3}"\r\n: "=&r" (offset), "=&r" (buf), "=r" (tmp), "=r" (tmp2), "=r" (tmp3)\r\n: "0" (offset), "1" (buf));\r\nlength -= 8;\r\n}\r\nwhile (length > 0) {\r\nunsigned int tmp;\r\nasm volatile(\r\n"ldr%?h %2, [%0], #4\n\t"\r\n"str%?b %2, [%1], #1\n\t"\r\n"mov%? %2, %2, lsr #8\n\t"\r\n"str%?b %2, [%1], #1"\r\n: "=&r" (offset), "=&r" (buf), "=r" (tmp) : "0" (offset), "1" (buf));\r\nlength -= 2;\r\n}\r\n}\r\nstatic int\r\nam79c961_ramtest(struct net_device *dev, unsigned int val)\r\n{\r\nunsigned char *buffer = kmalloc (65536, GFP_KERNEL);\r\nint i, error = 0, errorcount = 0;\r\nif (!buffer)\r\nreturn 0;\r\nmemset (buffer, val, 65536);\r\nam_writebuffer(dev, 0, buffer, 65536);\r\nmemset (buffer, val ^ 255, 65536);\r\nam_readbuffer(dev, 0, buffer, 65536);\r\nfor (i = 0; i < 65536; i++) {\r\nif (buffer[i] != val && !error) {\r\nprintk ("%s: buffer error (%02X %02X) %05X - ", dev->name, val, buffer[i], i);\r\nerror = 1;\r\nerrorcount ++;\r\n} else if (error && buffer[i] == val) {\r\nprintk ("%05X\n", i);\r\nerror = 0;\r\n}\r\n}\r\nif (error)\r\nprintk ("10000\n");\r\nkfree (buffer);\r\nreturn errorcount;\r\n}\r\nstatic void am79c961_mc_hash(char *addr, u16 *hash)\r\n{\r\nint idx, bit;\r\nu32 crc;\r\ncrc = ether_crc_le(ETH_ALEN, addr);\r\nidx = crc >> 30;\r\nbit = (crc >> 26) & 15;\r\nhash[idx] |= 1 << bit;\r\n}\r\nstatic unsigned int am79c961_get_rx_mode(struct net_device *dev, u16 *hash)\r\n{\r\nunsigned int mode = MODE_PORT_10BT;\r\nif (dev->flags & IFF_PROMISC) {\r\nmode |= MODE_PROMISC;\r\nmemset(hash, 0xff, 4 * sizeof(*hash));\r\n} else if (dev->flags & IFF_ALLMULTI) {\r\nmemset(hash, 0xff, 4 * sizeof(*hash));\r\n} else {\r\nstruct netdev_hw_addr *ha;\r\nmemset(hash, 0, 4 * sizeof(*hash));\r\nnetdev_for_each_mc_addr(ha, dev)\r\nam79c961_mc_hash(ha->addr, hash);\r\n}\r\nreturn mode;\r\n}\r\nstatic void\r\nam79c961_init_for_open(struct net_device *dev)\r\n{\r\nstruct dev_priv *priv = netdev_priv(dev);\r\nunsigned long flags;\r\nunsigned char *p;\r\nu_int hdr_addr, first_free_addr;\r\nu16 multi_hash[4], mode = am79c961_get_rx_mode(dev, multi_hash);\r\nint i;\r\nspin_lock_irqsave(&priv->chip_lock, flags);\r\nwrite_rreg (dev->base_addr, CSR0, CSR0_BABL|CSR0_CERR|CSR0_MISS|CSR0_MERR|CSR0_TINT|CSR0_RINT|CSR0_STOP);\r\nspin_unlock_irqrestore(&priv->chip_lock, flags);\r\nwrite_ireg (dev->base_addr, 5, 0x00a0);\r\nwrite_ireg (dev->base_addr, 6, 0x0081);\r\nwrite_ireg (dev->base_addr, 7, 0x0090);\r\nwrite_ireg (dev->base_addr, 2, 0x0000);\r\nfor (i = LADRL; i <= LADRH; i++)\r\nwrite_rreg (dev->base_addr, i, multi_hash[i - LADRL]);\r\nfor (i = PADRL, p = dev->dev_addr; i <= PADRH; i++, p += 2)\r\nwrite_rreg (dev->base_addr, i, p[0] | (p[1] << 8));\r\nwrite_rreg (dev->base_addr, MODE, mode);\r\nwrite_rreg (dev->base_addr, POLLINT, 0);\r\nwrite_rreg (dev->base_addr, SIZERXR, -RX_BUFFERS);\r\nwrite_rreg (dev->base_addr, SIZETXR, -TX_BUFFERS);\r\nfirst_free_addr = RX_BUFFERS * 8 + TX_BUFFERS * 8 + 16;\r\nhdr_addr = 0;\r\npriv->rxhead = 0;\r\npriv->rxtail = 0;\r\npriv->rxhdr = hdr_addr;\r\nfor (i = 0; i < RX_BUFFERS; i++) {\r\npriv->rxbuffer[i] = first_free_addr;\r\nam_writeword (dev, hdr_addr, first_free_addr);\r\nam_writeword (dev, hdr_addr + 2, RMD_OWN);\r\nam_writeword (dev, hdr_addr + 4, (-1600));\r\nam_writeword (dev, hdr_addr + 6, 0);\r\nfirst_free_addr += 1600;\r\nhdr_addr += 8;\r\n}\r\npriv->txhead = 0;\r\npriv->txtail = 0;\r\npriv->txhdr = hdr_addr;\r\nfor (i = 0; i < TX_BUFFERS; i++) {\r\npriv->txbuffer[i] = first_free_addr;\r\nam_writeword (dev, hdr_addr, first_free_addr);\r\nam_writeword (dev, hdr_addr + 2, TMD_STP|TMD_ENP);\r\nam_writeword (dev, hdr_addr + 4, 0xf000);\r\nam_writeword (dev, hdr_addr + 6, 0);\r\nfirst_free_addr += 1600;\r\nhdr_addr += 8;\r\n}\r\nwrite_rreg (dev->base_addr, BASERXL, priv->rxhdr);\r\nwrite_rreg (dev->base_addr, BASERXH, 0);\r\nwrite_rreg (dev->base_addr, BASETXL, priv->txhdr);\r\nwrite_rreg (dev->base_addr, BASERXH, 0);\r\nwrite_rreg (dev->base_addr, CSR0, CSR0_STOP);\r\nwrite_rreg (dev->base_addr, CSR3, CSR3_IDONM|CSR3_BABLM|CSR3_DXSUFLO);\r\nwrite_rreg (dev->base_addr, CSR4, CSR4_APAD_XMIT|CSR4_MFCOM|CSR4_RCVCCOM|CSR4_TXSTRTM|CSR4_JABM);\r\nwrite_rreg (dev->base_addr, CSR0, CSR0_IENA|CSR0_STRT);\r\n}\r\nstatic void am79c961_timer(unsigned long data)\r\n{\r\nstruct net_device *dev = (struct net_device *)data;\r\nstruct dev_priv *priv = netdev_priv(dev);\r\nunsigned int lnkstat, carrier;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->chip_lock, flags);\r\nlnkstat = read_ireg(dev->base_addr, ISALED0) & ISALED0_LNKST;\r\nspin_unlock_irqrestore(&priv->chip_lock, flags);\r\ncarrier = netif_carrier_ok(dev);\r\nif (lnkstat && !carrier) {\r\nnetif_carrier_on(dev);\r\nprintk("%s: link up\n", dev->name);\r\n} else if (!lnkstat && carrier) {\r\nnetif_carrier_off(dev);\r\nprintk("%s: link down\n", dev->name);\r\n}\r\nmod_timer(&priv->timer, jiffies + msecs_to_jiffies(500));\r\n}\r\nstatic int\r\nam79c961_open(struct net_device *dev)\r\n{\r\nstruct dev_priv *priv = netdev_priv(dev);\r\nint ret;\r\nret = request_irq(dev->irq, am79c961_interrupt, 0, dev->name, dev);\r\nif (ret)\r\nreturn ret;\r\nam79c961_init_for_open(dev);\r\nnetif_carrier_off(dev);\r\npriv->timer.expires = jiffies;\r\nadd_timer(&priv->timer);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int\r\nam79c961_close(struct net_device *dev)\r\n{\r\nstruct dev_priv *priv = netdev_priv(dev);\r\nunsigned long flags;\r\ndel_timer_sync(&priv->timer);\r\nnetif_stop_queue(dev);\r\nnetif_carrier_off(dev);\r\nspin_lock_irqsave(&priv->chip_lock, flags);\r\nwrite_rreg (dev->base_addr, CSR0, CSR0_STOP);\r\nwrite_rreg (dev->base_addr, CSR3, CSR3_MASKALL);\r\nspin_unlock_irqrestore(&priv->chip_lock, flags);\r\nfree_irq (dev->irq, dev);\r\nreturn 0;\r\n}\r\nstatic void am79c961_setmulticastlist (struct net_device *dev)\r\n{\r\nstruct dev_priv *priv = netdev_priv(dev);\r\nunsigned long flags;\r\nu16 multi_hash[4], mode = am79c961_get_rx_mode(dev, multi_hash);\r\nint i, stopped;\r\nspin_lock_irqsave(&priv->chip_lock, flags);\r\nstopped = read_rreg(dev->base_addr, CSR0) & CSR0_STOP;\r\nif (!stopped) {\r\nwrite_rreg(dev->base_addr, CTRL1, CTRL1_SPND);\r\nwhile ((read_rreg(dev->base_addr, CTRL1) & CTRL1_SPND) == 0) {\r\nspin_unlock_irqrestore(&priv->chip_lock, flags);\r\nnop();\r\nspin_lock_irqsave(&priv->chip_lock, flags);\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(multi_hash); i++)\r\nwrite_rreg(dev->base_addr, i + LADRL, multi_hash[i]);\r\nwrite_rreg(dev->base_addr, MODE, mode);\r\nif (!stopped) {\r\nwrite_rreg(dev->base_addr, CTRL1, 0);\r\n}\r\nspin_unlock_irqrestore(&priv->chip_lock, flags);\r\n}\r\nstatic void am79c961_timeout(struct net_device *dev)\r\n{\r\nprintk(KERN_WARNING "%s: transmit timed out, network cable problem?\n",\r\ndev->name);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int\r\nam79c961_sendpacket(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct dev_priv *priv = netdev_priv(dev);\r\nunsigned int hdraddr, bufaddr;\r\nunsigned int head;\r\nunsigned long flags;\r\nhead = priv->txhead;\r\nhdraddr = priv->txhdr + (head << 3);\r\nbufaddr = priv->txbuffer[head];\r\nhead += 1;\r\nif (head >= TX_BUFFERS)\r\nhead = 0;\r\nam_writebuffer (dev, bufaddr, skb->data, skb->len);\r\nam_writeword (dev, hdraddr + 4, -skb->len);\r\nam_writeword (dev, hdraddr + 2, TMD_OWN|TMD_STP|TMD_ENP);\r\npriv->txhead = head;\r\nspin_lock_irqsave(&priv->chip_lock, flags);\r\nwrite_rreg (dev->base_addr, CSR0, CSR0_TDMD|CSR0_IENA);\r\nspin_unlock_irqrestore(&priv->chip_lock, flags);\r\nif (am_readword(dev, priv->txhdr + (priv->txhead << 3) + 2) & TMD_OWN)\r\nnetif_stop_queue(dev);\r\ndev_consume_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void\r\nam79c961_rx(struct net_device *dev, struct dev_priv *priv)\r\n{\r\ndo {\r\nstruct sk_buff *skb;\r\nu_int hdraddr;\r\nu_int pktaddr;\r\nu_int status;\r\nint len;\r\nhdraddr = priv->rxhdr + (priv->rxtail << 3);\r\npktaddr = priv->rxbuffer[priv->rxtail];\r\nstatus = am_readword (dev, hdraddr + 2);\r\nif (status & RMD_OWN)\r\nbreak;\r\npriv->rxtail ++;\r\nif (priv->rxtail >= RX_BUFFERS)\r\npriv->rxtail = 0;\r\nif ((status & (RMD_ERR|RMD_STP|RMD_ENP)) != (RMD_STP|RMD_ENP)) {\r\nam_writeword (dev, hdraddr + 2, RMD_OWN);\r\ndev->stats.rx_errors++;\r\nif (status & RMD_ERR) {\r\nif (status & RMD_FRAM)\r\ndev->stats.rx_frame_errors++;\r\nif (status & RMD_CRC)\r\ndev->stats.rx_crc_errors++;\r\n} else if (status & RMD_STP)\r\ndev->stats.rx_length_errors++;\r\ncontinue;\r\n}\r\nlen = am_readword(dev, hdraddr + 6);\r\nskb = netdev_alloc_skb(dev, len + 2);\r\nif (skb) {\r\nskb_reserve(skb, 2);\r\nam_readbuffer(dev, pktaddr, skb_put(skb, len), len);\r\nam_writeword(dev, hdraddr + 2, RMD_OWN);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnetif_rx(skb);\r\ndev->stats.rx_bytes += len;\r\ndev->stats.rx_packets++;\r\n} else {\r\nam_writeword (dev, hdraddr + 2, RMD_OWN);\r\ndev->stats.rx_dropped++;\r\nbreak;\r\n}\r\n} while (1);\r\n}\r\nstatic void\r\nam79c961_tx(struct net_device *dev, struct dev_priv *priv)\r\n{\r\ndo {\r\nshort len;\r\nu_int hdraddr;\r\nu_int status;\r\nhdraddr = priv->txhdr + (priv->txtail << 3);\r\nstatus = am_readword (dev, hdraddr + 2);\r\nif (status & TMD_OWN)\r\nbreak;\r\npriv->txtail ++;\r\nif (priv->txtail >= TX_BUFFERS)\r\npriv->txtail = 0;\r\nif (status & TMD_ERR) {\r\nu_int status2;\r\ndev->stats.tx_errors++;\r\nstatus2 = am_readword (dev, hdraddr + 6);\r\nam_writeword (dev, hdraddr + 6, 0);\r\nif (status2 & TST_RTRY)\r\ndev->stats.collisions += 16;\r\nif (status2 & TST_LCOL)\r\ndev->stats.tx_window_errors++;\r\nif (status2 & TST_LCAR)\r\ndev->stats.tx_carrier_errors++;\r\nif (status2 & TST_UFLO)\r\ndev->stats.tx_fifo_errors++;\r\ncontinue;\r\n}\r\ndev->stats.tx_packets++;\r\nlen = am_readword (dev, hdraddr + 4);\r\ndev->stats.tx_bytes += -len;\r\n} while (priv->txtail != priv->txhead);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic irqreturn_t\r\nam79c961_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nstruct dev_priv *priv = netdev_priv(dev);\r\nu_int status, n = 100;\r\nint handled = 0;\r\ndo {\r\nstatus = read_rreg(dev->base_addr, CSR0);\r\nwrite_rreg(dev->base_addr, CSR0, status &\r\n(CSR0_IENA|CSR0_TINT|CSR0_RINT|\r\nCSR0_MERR|CSR0_MISS|CSR0_CERR|CSR0_BABL));\r\nif (status & CSR0_RINT) {\r\nhandled = 1;\r\nam79c961_rx(dev, priv);\r\n}\r\nif (status & CSR0_TINT) {\r\nhandled = 1;\r\nam79c961_tx(dev, priv);\r\n}\r\nif (status & CSR0_MISS) {\r\nhandled = 1;\r\ndev->stats.rx_dropped++;\r\n}\r\nif (status & CSR0_CERR) {\r\nhandled = 1;\r\nmod_timer(&priv->timer, jiffies);\r\n}\r\n} while (--n && status & (CSR0_RINT | CSR0_TINT));\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void am79c961_poll_controller(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nam79c961_interrupt(dev->irq, dev);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int\r\nam79c961_hw_init(struct net_device *dev)\r\n{\r\nstruct dev_priv *priv = netdev_priv(dev);\r\nspin_lock_irq(&priv->chip_lock);\r\nwrite_rreg (dev->base_addr, CSR0, CSR0_STOP);\r\nwrite_rreg (dev->base_addr, CSR3, CSR3_MASKALL);\r\nspin_unlock_irq(&priv->chip_lock);\r\nam79c961_ramtest(dev, 0x66);\r\nam79c961_ramtest(dev, 0x99);\r\nreturn 0;\r\n}\r\nstatic void __init am79c961_banner(void)\r\n{\r\nstatic unsigned version_printed;\r\nif (net_debug && version_printed++ == 0)\r\nprintk(KERN_INFO "%s", version);\r\n}\r\nstatic int am79c961_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct net_device *dev;\r\nstruct dev_priv *priv;\r\nint i, ret;\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\ndev = alloc_etherdev(sizeof(struct dev_priv));\r\nret = -ENOMEM;\r\nif (!dev)\r\ngoto out;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\npriv = netdev_priv(dev);\r\ndev->base_addr = res->start;\r\nret = platform_get_irq(pdev, 0);\r\nif (ret < 0) {\r\nret = -ENODEV;\r\ngoto nodev;\r\n}\r\ndev->irq = ret;\r\nret = -ENODEV;\r\nif (!request_region(dev->base_addr, 0x18, dev->name))\r\ngoto nodev;\r\ninb(dev->base_addr + NET_RESET);\r\nudelay(5);\r\nif (inb(dev->base_addr) != 0x08 ||\r\ninb(dev->base_addr + 2) != 0x00 ||\r\ninb(dev->base_addr + 4) != 0x2b)\r\ngoto release;\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = inb(dev->base_addr + i * 2) & 0xff;\r\nam79c961_banner();\r\nspin_lock_init(&priv->chip_lock);\r\ninit_timer(&priv->timer);\r\npriv->timer.data = (unsigned long)dev;\r\npriv->timer.function = am79c961_timer;\r\nif (am79c961_hw_init(dev))\r\ngoto release;\r\ndev->netdev_ops = &am79c961_netdev_ops;\r\nret = register_netdev(dev);\r\nif (ret == 0) {\r\nprintk(KERN_INFO "%s: ether address %pM\n",\r\ndev->name, dev->dev_addr);\r\nreturn 0;\r\n}\r\nrelease:\r\nrelease_region(dev->base_addr, 0x18);\r\nnodev:\r\nfree_netdev(dev);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __init am79c961_init(void)\r\n{\r\nreturn platform_driver_register(&am79c961_driver);\r\n}
