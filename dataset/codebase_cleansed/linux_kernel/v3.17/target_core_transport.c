int init_se_kmem_caches(void)\r\n{\r\nse_sess_cache = kmem_cache_create("se_sess_cache",\r\nsizeof(struct se_session), __alignof__(struct se_session),\r\n0, NULL);\r\nif (!se_sess_cache) {\r\npr_err("kmem_cache_create() for struct se_session"\r\n" failed\n");\r\ngoto out;\r\n}\r\nse_ua_cache = kmem_cache_create("se_ua_cache",\r\nsizeof(struct se_ua), __alignof__(struct se_ua),\r\n0, NULL);\r\nif (!se_ua_cache) {\r\npr_err("kmem_cache_create() for struct se_ua failed\n");\r\ngoto out_free_sess_cache;\r\n}\r\nt10_pr_reg_cache = kmem_cache_create("t10_pr_reg_cache",\r\nsizeof(struct t10_pr_registration),\r\n__alignof__(struct t10_pr_registration), 0, NULL);\r\nif (!t10_pr_reg_cache) {\r\npr_err("kmem_cache_create() for struct t10_pr_registration"\r\n" failed\n");\r\ngoto out_free_ua_cache;\r\n}\r\nt10_alua_lu_gp_cache = kmem_cache_create("t10_alua_lu_gp_cache",\r\nsizeof(struct t10_alua_lu_gp), __alignof__(struct t10_alua_lu_gp),\r\n0, NULL);\r\nif (!t10_alua_lu_gp_cache) {\r\npr_err("kmem_cache_create() for t10_alua_lu_gp_cache"\r\n" failed\n");\r\ngoto out_free_pr_reg_cache;\r\n}\r\nt10_alua_lu_gp_mem_cache = kmem_cache_create("t10_alua_lu_gp_mem_cache",\r\nsizeof(struct t10_alua_lu_gp_member),\r\n__alignof__(struct t10_alua_lu_gp_member), 0, NULL);\r\nif (!t10_alua_lu_gp_mem_cache) {\r\npr_err("kmem_cache_create() for t10_alua_lu_gp_mem_"\r\n"cache failed\n");\r\ngoto out_free_lu_gp_cache;\r\n}\r\nt10_alua_tg_pt_gp_cache = kmem_cache_create("t10_alua_tg_pt_gp_cache",\r\nsizeof(struct t10_alua_tg_pt_gp),\r\n__alignof__(struct t10_alua_tg_pt_gp), 0, NULL);\r\nif (!t10_alua_tg_pt_gp_cache) {\r\npr_err("kmem_cache_create() for t10_alua_tg_pt_gp_"\r\n"cache failed\n");\r\ngoto out_free_lu_gp_mem_cache;\r\n}\r\nt10_alua_tg_pt_gp_mem_cache = kmem_cache_create(\r\n"t10_alua_tg_pt_gp_mem_cache",\r\nsizeof(struct t10_alua_tg_pt_gp_member),\r\n__alignof__(struct t10_alua_tg_pt_gp_member),\r\n0, NULL);\r\nif (!t10_alua_tg_pt_gp_mem_cache) {\r\npr_err("kmem_cache_create() for t10_alua_tg_pt_gp_"\r\n"mem_t failed\n");\r\ngoto out_free_tg_pt_gp_cache;\r\n}\r\nt10_alua_lba_map_cache = kmem_cache_create(\r\n"t10_alua_lba_map_cache",\r\nsizeof(struct t10_alua_lba_map),\r\n__alignof__(struct t10_alua_lba_map), 0, NULL);\r\nif (!t10_alua_lba_map_cache) {\r\npr_err("kmem_cache_create() for t10_alua_lba_map_"\r\n"cache failed\n");\r\ngoto out_free_tg_pt_gp_mem_cache;\r\n}\r\nt10_alua_lba_map_mem_cache = kmem_cache_create(\r\n"t10_alua_lba_map_mem_cache",\r\nsizeof(struct t10_alua_lba_map_member),\r\n__alignof__(struct t10_alua_lba_map_member), 0, NULL);\r\nif (!t10_alua_lba_map_mem_cache) {\r\npr_err("kmem_cache_create() for t10_alua_lba_map_mem_"\r\n"cache failed\n");\r\ngoto out_free_lba_map_cache;\r\n}\r\ntarget_completion_wq = alloc_workqueue("target_completion",\r\nWQ_MEM_RECLAIM, 0);\r\nif (!target_completion_wq)\r\ngoto out_free_lba_map_mem_cache;\r\nreturn 0;\r\nout_free_lba_map_mem_cache:\r\nkmem_cache_destroy(t10_alua_lba_map_mem_cache);\r\nout_free_lba_map_cache:\r\nkmem_cache_destroy(t10_alua_lba_map_cache);\r\nout_free_tg_pt_gp_mem_cache:\r\nkmem_cache_destroy(t10_alua_tg_pt_gp_mem_cache);\r\nout_free_tg_pt_gp_cache:\r\nkmem_cache_destroy(t10_alua_tg_pt_gp_cache);\r\nout_free_lu_gp_mem_cache:\r\nkmem_cache_destroy(t10_alua_lu_gp_mem_cache);\r\nout_free_lu_gp_cache:\r\nkmem_cache_destroy(t10_alua_lu_gp_cache);\r\nout_free_pr_reg_cache:\r\nkmem_cache_destroy(t10_pr_reg_cache);\r\nout_free_ua_cache:\r\nkmem_cache_destroy(se_ua_cache);\r\nout_free_sess_cache:\r\nkmem_cache_destroy(se_sess_cache);\r\nout:\r\nreturn -ENOMEM;\r\n}\r\nvoid release_se_kmem_caches(void)\r\n{\r\ndestroy_workqueue(target_completion_wq);\r\nkmem_cache_destroy(se_sess_cache);\r\nkmem_cache_destroy(se_ua_cache);\r\nkmem_cache_destroy(t10_pr_reg_cache);\r\nkmem_cache_destroy(t10_alua_lu_gp_cache);\r\nkmem_cache_destroy(t10_alua_lu_gp_mem_cache);\r\nkmem_cache_destroy(t10_alua_tg_pt_gp_cache);\r\nkmem_cache_destroy(t10_alua_tg_pt_gp_mem_cache);\r\nkmem_cache_destroy(t10_alua_lba_map_cache);\r\nkmem_cache_destroy(t10_alua_lba_map_mem_cache);\r\n}\r\nu32 scsi_get_new_index(scsi_index_t type)\r\n{\r\nu32 new_index;\r\nBUG_ON((type < 0) || (type >= SCSI_INDEX_TYPE_MAX));\r\nspin_lock(&scsi_mib_index_lock);\r\nnew_index = ++scsi_mib_index[type];\r\nspin_unlock(&scsi_mib_index_lock);\r\nreturn new_index;\r\n}\r\nvoid transport_subsystem_check_init(void)\r\n{\r\nint ret;\r\nstatic int sub_api_initialized;\r\nif (sub_api_initialized)\r\nreturn;\r\nret = request_module("target_core_iblock");\r\nif (ret != 0)\r\npr_err("Unable to load target_core_iblock\n");\r\nret = request_module("target_core_file");\r\nif (ret != 0)\r\npr_err("Unable to load target_core_file\n");\r\nret = request_module("target_core_pscsi");\r\nif (ret != 0)\r\npr_err("Unable to load target_core_pscsi\n");\r\nsub_api_initialized = 1;\r\n}\r\nstruct se_session *transport_init_session(enum target_prot_op sup_prot_ops)\r\n{\r\nstruct se_session *se_sess;\r\nse_sess = kmem_cache_zalloc(se_sess_cache, GFP_KERNEL);\r\nif (!se_sess) {\r\npr_err("Unable to allocate struct se_session from"\r\n" se_sess_cache\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nINIT_LIST_HEAD(&se_sess->sess_list);\r\nINIT_LIST_HEAD(&se_sess->sess_acl_list);\r\nINIT_LIST_HEAD(&se_sess->sess_cmd_list);\r\nINIT_LIST_HEAD(&se_sess->sess_wait_list);\r\nspin_lock_init(&se_sess->sess_cmd_lock);\r\nkref_init(&se_sess->sess_kref);\r\nse_sess->sup_prot_ops = sup_prot_ops;\r\nreturn se_sess;\r\n}\r\nint transport_alloc_session_tags(struct se_session *se_sess,\r\nunsigned int tag_num, unsigned int tag_size)\r\n{\r\nint rc;\r\nse_sess->sess_cmd_map = kzalloc(tag_num * tag_size,\r\nGFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT);\r\nif (!se_sess->sess_cmd_map) {\r\nse_sess->sess_cmd_map = vzalloc(tag_num * tag_size);\r\nif (!se_sess->sess_cmd_map) {\r\npr_err("Unable to allocate se_sess->sess_cmd_map\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nrc = percpu_ida_init(&se_sess->sess_tag_pool, tag_num);\r\nif (rc < 0) {\r\npr_err("Unable to init se_sess->sess_tag_pool,"\r\n" tag_num: %u\n", tag_num);\r\nif (is_vmalloc_addr(se_sess->sess_cmd_map))\r\nvfree(se_sess->sess_cmd_map);\r\nelse\r\nkfree(se_sess->sess_cmd_map);\r\nse_sess->sess_cmd_map = NULL;\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstruct se_session *transport_init_session_tags(unsigned int tag_num,\r\nunsigned int tag_size,\r\nenum target_prot_op sup_prot_ops)\r\n{\r\nstruct se_session *se_sess;\r\nint rc;\r\nse_sess = transport_init_session(sup_prot_ops);\r\nif (IS_ERR(se_sess))\r\nreturn se_sess;\r\nrc = transport_alloc_session_tags(se_sess, tag_num, tag_size);\r\nif (rc < 0) {\r\ntransport_free_session(se_sess);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nreturn se_sess;\r\n}\r\nvoid __transport_register_session(\r\nstruct se_portal_group *se_tpg,\r\nstruct se_node_acl *se_nacl,\r\nstruct se_session *se_sess,\r\nvoid *fabric_sess_ptr)\r\n{\r\nunsigned char buf[PR_REG_ISID_LEN];\r\nse_sess->se_tpg = se_tpg;\r\nse_sess->fabric_sess_ptr = fabric_sess_ptr;\r\nif (se_nacl) {\r\nif (se_tpg->se_tpg_tfo->sess_get_initiator_sid != NULL) {\r\nmemset(&buf[0], 0, PR_REG_ISID_LEN);\r\nse_tpg->se_tpg_tfo->sess_get_initiator_sid(se_sess,\r\n&buf[0], PR_REG_ISID_LEN);\r\nse_sess->sess_bin_isid = get_unaligned_be64(&buf[0]);\r\n}\r\nkref_get(&se_nacl->acl_kref);\r\nspin_lock_irq(&se_nacl->nacl_sess_lock);\r\nse_nacl->nacl_sess = se_sess;\r\nlist_add_tail(&se_sess->sess_acl_list,\r\n&se_nacl->acl_sess_list);\r\nspin_unlock_irq(&se_nacl->nacl_sess_lock);\r\n}\r\nlist_add_tail(&se_sess->sess_list, &se_tpg->tpg_sess_list);\r\npr_debug("TARGET_CORE[%s]: Registered fabric_sess_ptr: %p\n",\r\nse_tpg->se_tpg_tfo->get_fabric_name(), se_sess->fabric_sess_ptr);\r\n}\r\nvoid transport_register_session(\r\nstruct se_portal_group *se_tpg,\r\nstruct se_node_acl *se_nacl,\r\nstruct se_session *se_sess,\r\nvoid *fabric_sess_ptr)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&se_tpg->session_lock, flags);\r\n__transport_register_session(se_tpg, se_nacl, se_sess, fabric_sess_ptr);\r\nspin_unlock_irqrestore(&se_tpg->session_lock, flags);\r\n}\r\nstatic void target_release_session(struct kref *kref)\r\n{\r\nstruct se_session *se_sess = container_of(kref,\r\nstruct se_session, sess_kref);\r\nstruct se_portal_group *se_tpg = se_sess->se_tpg;\r\nse_tpg->se_tpg_tfo->close_session(se_sess);\r\n}\r\nvoid target_get_session(struct se_session *se_sess)\r\n{\r\nkref_get(&se_sess->sess_kref);\r\n}\r\nvoid target_put_session(struct se_session *se_sess)\r\n{\r\nstruct se_portal_group *tpg = se_sess->se_tpg;\r\nif (tpg->se_tpg_tfo->put_session != NULL) {\r\ntpg->se_tpg_tfo->put_session(se_sess);\r\nreturn;\r\n}\r\nkref_put(&se_sess->sess_kref, target_release_session);\r\n}\r\nstatic void target_complete_nacl(struct kref *kref)\r\n{\r\nstruct se_node_acl *nacl = container_of(kref,\r\nstruct se_node_acl, acl_kref);\r\ncomplete(&nacl->acl_free_comp);\r\n}\r\nvoid target_put_nacl(struct se_node_acl *nacl)\r\n{\r\nkref_put(&nacl->acl_kref, target_complete_nacl);\r\n}\r\nvoid transport_deregister_session_configfs(struct se_session *se_sess)\r\n{\r\nstruct se_node_acl *se_nacl;\r\nunsigned long flags;\r\nse_nacl = se_sess->se_node_acl;\r\nif (se_nacl) {\r\nspin_lock_irqsave(&se_nacl->nacl_sess_lock, flags);\r\nif (se_nacl->acl_stop == 0)\r\nlist_del(&se_sess->sess_acl_list);\r\nif (list_empty(&se_nacl->acl_sess_list))\r\nse_nacl->nacl_sess = NULL;\r\nelse {\r\nse_nacl->nacl_sess = container_of(\r\nse_nacl->acl_sess_list.prev,\r\nstruct se_session, sess_acl_list);\r\n}\r\nspin_unlock_irqrestore(&se_nacl->nacl_sess_lock, flags);\r\n}\r\n}\r\nvoid transport_free_session(struct se_session *se_sess)\r\n{\r\nif (se_sess->sess_cmd_map) {\r\npercpu_ida_destroy(&se_sess->sess_tag_pool);\r\nif (is_vmalloc_addr(se_sess->sess_cmd_map))\r\nvfree(se_sess->sess_cmd_map);\r\nelse\r\nkfree(se_sess->sess_cmd_map);\r\n}\r\nkmem_cache_free(se_sess_cache, se_sess);\r\n}\r\nvoid transport_deregister_session(struct se_session *se_sess)\r\n{\r\nstruct se_portal_group *se_tpg = se_sess->se_tpg;\r\nstruct target_core_fabric_ops *se_tfo;\r\nstruct se_node_acl *se_nacl;\r\nunsigned long flags;\r\nbool comp_nacl = true;\r\nif (!se_tpg) {\r\ntransport_free_session(se_sess);\r\nreturn;\r\n}\r\nse_tfo = se_tpg->se_tpg_tfo;\r\nspin_lock_irqsave(&se_tpg->session_lock, flags);\r\nlist_del(&se_sess->sess_list);\r\nse_sess->se_tpg = NULL;\r\nse_sess->fabric_sess_ptr = NULL;\r\nspin_unlock_irqrestore(&se_tpg->session_lock, flags);\r\nse_nacl = se_sess->se_node_acl;\r\nspin_lock_irqsave(&se_tpg->acl_node_lock, flags);\r\nif (se_nacl && se_nacl->dynamic_node_acl) {\r\nif (!se_tfo->tpg_check_demo_mode_cache(se_tpg)) {\r\nlist_del(&se_nacl->acl_list);\r\nse_tpg->num_node_acls--;\r\nspin_unlock_irqrestore(&se_tpg->acl_node_lock, flags);\r\ncore_tpg_wait_for_nacl_pr_ref(se_nacl);\r\ncore_free_device_list_for_node(se_nacl, se_tpg);\r\nse_tfo->tpg_release_fabric_acl(se_tpg, se_nacl);\r\ncomp_nacl = false;\r\nspin_lock_irqsave(&se_tpg->acl_node_lock, flags);\r\n}\r\n}\r\nspin_unlock_irqrestore(&se_tpg->acl_node_lock, flags);\r\npr_debug("TARGET_CORE[%s]: Deregistered fabric_sess\n",\r\nse_tpg->se_tpg_tfo->get_fabric_name());\r\nif (se_nacl && comp_nacl)\r\ntarget_put_nacl(se_nacl);\r\ntransport_free_session(se_sess);\r\n}\r\nstatic void target_remove_from_state_list(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nunsigned long flags;\r\nif (!dev)\r\nreturn;\r\nif (cmd->transport_state & CMD_T_BUSY)\r\nreturn;\r\nspin_lock_irqsave(&dev->execute_task_lock, flags);\r\nif (cmd->state_active) {\r\nlist_del(&cmd->state_list);\r\ncmd->state_active = false;\r\n}\r\nspin_unlock_irqrestore(&dev->execute_task_lock, flags);\r\n}\r\nstatic int transport_cmd_check_stop(struct se_cmd *cmd, bool remove_from_lists,\r\nbool write_pending)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cmd->t_state_lock, flags);\r\nif (write_pending)\r\ncmd->t_state = TRANSPORT_WRITE_PENDING;\r\nif (remove_from_lists) {\r\ntarget_remove_from_state_list(cmd);\r\ncmd->se_lun = NULL;\r\n}\r\nif (cmd->transport_state & CMD_T_STOP) {\r\npr_debug("%s:%d CMD_T_STOP for ITT: 0x%08x\n",\r\n__func__, __LINE__,\r\ncmd->se_tfo->get_task_tag(cmd));\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\ncomplete_all(&cmd->t_transport_stop_comp);\r\nreturn 1;\r\n}\r\ncmd->transport_state &= ~CMD_T_ACTIVE;\r\nif (remove_from_lists) {\r\nif (cmd->se_tfo->check_stop_free != NULL) {\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nreturn cmd->se_tfo->check_stop_free(cmd);\r\n}\r\n}\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int transport_cmd_check_stop_to_fabric(struct se_cmd *cmd)\r\n{\r\nreturn transport_cmd_check_stop(cmd, true, false);\r\n}\r\nstatic void transport_lun_remove_cmd(struct se_cmd *cmd)\r\n{\r\nstruct se_lun *lun = cmd->se_lun;\r\nif (!lun)\r\nreturn;\r\nif (cmpxchg(&cmd->lun_ref_active, true, false))\r\npercpu_ref_put(&lun->lun_ref);\r\n}\r\nvoid transport_cmd_finish_abort(struct se_cmd *cmd, int remove)\r\n{\r\nif (cmd->se_cmd_flags & SCF_SE_LUN_CMD)\r\ntransport_lun_remove_cmd(cmd);\r\nif (remove)\r\ncmd->se_tfo->aborted_task(cmd);\r\nif (transport_cmd_check_stop_to_fabric(cmd))\r\nreturn;\r\nif (remove)\r\ntransport_put_cmd(cmd);\r\n}\r\nstatic void target_complete_failure_work(struct work_struct *work)\r\n{\r\nstruct se_cmd *cmd = container_of(work, struct se_cmd, work);\r\ntransport_generic_request_failure(cmd,\r\nTCM_LOGICAL_UNIT_COMMUNICATION_FAILURE);\r\n}\r\nstatic unsigned char *transport_get_sense_buffer(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nWARN_ON(!cmd->se_lun);\r\nif (!dev)\r\nreturn NULL;\r\nif (cmd->se_cmd_flags & SCF_SENT_CHECK_CONDITION)\r\nreturn NULL;\r\ncmd->scsi_sense_length = TRANSPORT_SENSE_BUFFER;\r\npr_debug("HBA_[%u]_PLUG[%s]: Requesting sense for SAM STATUS: 0x%02x\n",\r\ndev->se_hba->hba_id, dev->transport->name, cmd->scsi_status);\r\nreturn cmd->sense_buffer;\r\n}\r\nvoid target_complete_cmd(struct se_cmd *cmd, u8 scsi_status)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nint success = scsi_status == GOOD;\r\nunsigned long flags;\r\ncmd->scsi_status = scsi_status;\r\nspin_lock_irqsave(&cmd->t_state_lock, flags);\r\ncmd->transport_state &= ~CMD_T_BUSY;\r\nif (dev && dev->transport->transport_complete) {\r\ndev->transport->transport_complete(cmd,\r\ncmd->t_data_sg,\r\ntransport_get_sense_buffer(cmd));\r\nif (cmd->se_cmd_flags & SCF_TRANSPORT_TASK_SENSE)\r\nsuccess = 1;\r\n}\r\nif (cmd->transport_state & CMD_T_REQUEST_STOP) {\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\ncomplete(&cmd->task_stop_comp);\r\nreturn;\r\n}\r\nif (cmd->transport_state & CMD_T_ABORTED &&\r\ncmd->transport_state & CMD_T_STOP) {\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\ncomplete_all(&cmd->t_transport_stop_comp);\r\nreturn;\r\n} else if (!success) {\r\nINIT_WORK(&cmd->work, target_complete_failure_work);\r\n} else {\r\nINIT_WORK(&cmd->work, target_complete_ok_work);\r\n}\r\ncmd->t_state = TRANSPORT_COMPLETE;\r\ncmd->transport_state |= (CMD_T_COMPLETE | CMD_T_ACTIVE);\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nqueue_work(target_completion_wq, &cmd->work);\r\n}\r\nvoid target_complete_cmd_with_length(struct se_cmd *cmd, u8 scsi_status, int length)\r\n{\r\nif (scsi_status == SAM_STAT_GOOD && length < cmd->data_length) {\r\nif (cmd->se_cmd_flags & SCF_UNDERFLOW_BIT) {\r\ncmd->residual_count += cmd->data_length - length;\r\n} else {\r\ncmd->se_cmd_flags |= SCF_UNDERFLOW_BIT;\r\ncmd->residual_count = cmd->data_length - length;\r\n}\r\ncmd->data_length = length;\r\n}\r\ntarget_complete_cmd(cmd, scsi_status);\r\n}\r\nstatic void target_add_to_state_list(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->execute_task_lock, flags);\r\nif (!cmd->state_active) {\r\nlist_add_tail(&cmd->state_list, &dev->state_list);\r\ncmd->state_active = true;\r\n}\r\nspin_unlock_irqrestore(&dev->execute_task_lock, flags);\r\n}\r\nvoid target_qf_do_work(struct work_struct *work)\r\n{\r\nstruct se_device *dev = container_of(work, struct se_device,\r\nqf_work_queue);\r\nLIST_HEAD(qf_cmd_list);\r\nstruct se_cmd *cmd, *cmd_tmp;\r\nspin_lock_irq(&dev->qf_cmd_lock);\r\nlist_splice_init(&dev->qf_cmd_list, &qf_cmd_list);\r\nspin_unlock_irq(&dev->qf_cmd_lock);\r\nlist_for_each_entry_safe(cmd, cmd_tmp, &qf_cmd_list, se_qf_node) {\r\nlist_del(&cmd->se_qf_node);\r\natomic_dec(&dev->dev_qf_count);\r\nsmp_mb__after_atomic();\r\npr_debug("Processing %s cmd: %p QUEUE_FULL in work queue"\r\n" context: %s\n", cmd->se_tfo->get_fabric_name(), cmd,\r\n(cmd->t_state == TRANSPORT_COMPLETE_QF_OK) ? "COMPLETE_OK" :\r\n(cmd->t_state == TRANSPORT_COMPLETE_QF_WP) ? "WRITE_PENDING"\r\n: "UNKNOWN");\r\nif (cmd->t_state == TRANSPORT_COMPLETE_QF_WP)\r\ntransport_write_pending_qf(cmd);\r\nelse if (cmd->t_state == TRANSPORT_COMPLETE_QF_OK)\r\ntransport_complete_qf(cmd);\r\n}\r\n}\r\nunsigned char *transport_dump_cmd_direction(struct se_cmd *cmd)\r\n{\r\nswitch (cmd->data_direction) {\r\ncase DMA_NONE:\r\nreturn "NONE";\r\ncase DMA_FROM_DEVICE:\r\nreturn "READ";\r\ncase DMA_TO_DEVICE:\r\nreturn "WRITE";\r\ncase DMA_BIDIRECTIONAL:\r\nreturn "BIDI";\r\ndefault:\r\nbreak;\r\n}\r\nreturn "UNKNOWN";\r\n}\r\nvoid transport_dump_dev_state(\r\nstruct se_device *dev,\r\nchar *b,\r\nint *bl)\r\n{\r\n*bl += sprintf(b + *bl, "Status: ");\r\nif (dev->export_count)\r\n*bl += sprintf(b + *bl, "ACTIVATED");\r\nelse\r\n*bl += sprintf(b + *bl, "DEACTIVATED");\r\n*bl += sprintf(b + *bl, " Max Queue Depth: %d", dev->queue_depth);\r\n*bl += sprintf(b + *bl, " SectorSize: %u HwMaxSectors: %u\n",\r\ndev->dev_attrib.block_size,\r\ndev->dev_attrib.hw_max_sectors);\r\n*bl += sprintf(b + *bl, " ");\r\n}\r\nvoid transport_dump_vpd_proto_id(\r\nstruct t10_vpd *vpd,\r\nunsigned char *p_buf,\r\nint p_buf_len)\r\n{\r\nunsigned char buf[VPD_TMP_BUF_SIZE];\r\nint len;\r\nmemset(buf, 0, VPD_TMP_BUF_SIZE);\r\nlen = sprintf(buf, "T10 VPD Protocol Identifier: ");\r\nswitch (vpd->protocol_identifier) {\r\ncase 0x00:\r\nsprintf(buf+len, "Fibre Channel\n");\r\nbreak;\r\ncase 0x10:\r\nsprintf(buf+len, "Parallel SCSI\n");\r\nbreak;\r\ncase 0x20:\r\nsprintf(buf+len, "SSA\n");\r\nbreak;\r\ncase 0x30:\r\nsprintf(buf+len, "IEEE 1394\n");\r\nbreak;\r\ncase 0x40:\r\nsprintf(buf+len, "SCSI Remote Direct Memory Access"\r\n" Protocol\n");\r\nbreak;\r\ncase 0x50:\r\nsprintf(buf+len, "Internet SCSI (iSCSI)\n");\r\nbreak;\r\ncase 0x60:\r\nsprintf(buf+len, "SAS Serial SCSI Protocol\n");\r\nbreak;\r\ncase 0x70:\r\nsprintf(buf+len, "Automation/Drive Interface Transport"\r\n" Protocol\n");\r\nbreak;\r\ncase 0x80:\r\nsprintf(buf+len, "AT Attachment Interface ATA/ATAPI\n");\r\nbreak;\r\ndefault:\r\nsprintf(buf+len, "Unknown 0x%02x\n",\r\nvpd->protocol_identifier);\r\nbreak;\r\n}\r\nif (p_buf)\r\nstrncpy(p_buf, buf, p_buf_len);\r\nelse\r\npr_debug("%s", buf);\r\n}\r\nvoid\r\ntransport_set_vpd_proto_id(struct t10_vpd *vpd, unsigned char *page_83)\r\n{\r\nif (page_83[1] & 0x80) {\r\nvpd->protocol_identifier = (page_83[0] & 0xf0);\r\nvpd->protocol_identifier_set = 1;\r\ntransport_dump_vpd_proto_id(vpd, NULL, 0);\r\n}\r\n}\r\nint transport_dump_vpd_assoc(\r\nstruct t10_vpd *vpd,\r\nunsigned char *p_buf,\r\nint p_buf_len)\r\n{\r\nunsigned char buf[VPD_TMP_BUF_SIZE];\r\nint ret = 0;\r\nint len;\r\nmemset(buf, 0, VPD_TMP_BUF_SIZE);\r\nlen = sprintf(buf, "T10 VPD Identifier Association: ");\r\nswitch (vpd->association) {\r\ncase 0x00:\r\nsprintf(buf+len, "addressed logical unit\n");\r\nbreak;\r\ncase 0x10:\r\nsprintf(buf+len, "target port\n");\r\nbreak;\r\ncase 0x20:\r\nsprintf(buf+len, "SCSI target device\n");\r\nbreak;\r\ndefault:\r\nsprintf(buf+len, "Unknown 0x%02x\n", vpd->association);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (p_buf)\r\nstrncpy(p_buf, buf, p_buf_len);\r\nelse\r\npr_debug("%s", buf);\r\nreturn ret;\r\n}\r\nint transport_set_vpd_assoc(struct t10_vpd *vpd, unsigned char *page_83)\r\n{\r\nvpd->association = (page_83[1] & 0x30);\r\nreturn transport_dump_vpd_assoc(vpd, NULL, 0);\r\n}\r\nint transport_dump_vpd_ident_type(\r\nstruct t10_vpd *vpd,\r\nunsigned char *p_buf,\r\nint p_buf_len)\r\n{\r\nunsigned char buf[VPD_TMP_BUF_SIZE];\r\nint ret = 0;\r\nint len;\r\nmemset(buf, 0, VPD_TMP_BUF_SIZE);\r\nlen = sprintf(buf, "T10 VPD Identifier Type: ");\r\nswitch (vpd->device_identifier_type) {\r\ncase 0x00:\r\nsprintf(buf+len, "Vendor specific\n");\r\nbreak;\r\ncase 0x01:\r\nsprintf(buf+len, "T10 Vendor ID based\n");\r\nbreak;\r\ncase 0x02:\r\nsprintf(buf+len, "EUI-64 based\n");\r\nbreak;\r\ncase 0x03:\r\nsprintf(buf+len, "NAA\n");\r\nbreak;\r\ncase 0x04:\r\nsprintf(buf+len, "Relative target port identifier\n");\r\nbreak;\r\ncase 0x08:\r\nsprintf(buf+len, "SCSI name string\n");\r\nbreak;\r\ndefault:\r\nsprintf(buf+len, "Unsupported: 0x%02x\n",\r\nvpd->device_identifier_type);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (p_buf) {\r\nif (p_buf_len < strlen(buf)+1)\r\nreturn -EINVAL;\r\nstrncpy(p_buf, buf, p_buf_len);\r\n} else {\r\npr_debug("%s", buf);\r\n}\r\nreturn ret;\r\n}\r\nint transport_set_vpd_ident_type(struct t10_vpd *vpd, unsigned char *page_83)\r\n{\r\nvpd->device_identifier_type = (page_83[1] & 0x0f);\r\nreturn transport_dump_vpd_ident_type(vpd, NULL, 0);\r\n}\r\nint transport_dump_vpd_ident(\r\nstruct t10_vpd *vpd,\r\nunsigned char *p_buf,\r\nint p_buf_len)\r\n{\r\nunsigned char buf[VPD_TMP_BUF_SIZE];\r\nint ret = 0;\r\nmemset(buf, 0, VPD_TMP_BUF_SIZE);\r\nswitch (vpd->device_identifier_code_set) {\r\ncase 0x01:\r\nsnprintf(buf, sizeof(buf),\r\n"T10 VPD Binary Device Identifier: %s\n",\r\n&vpd->device_identifier[0]);\r\nbreak;\r\ncase 0x02:\r\nsnprintf(buf, sizeof(buf),\r\n"T10 VPD ASCII Device Identifier: %s\n",\r\n&vpd->device_identifier[0]);\r\nbreak;\r\ncase 0x03:\r\nsnprintf(buf, sizeof(buf),\r\n"T10 VPD UTF-8 Device Identifier: %s\n",\r\n&vpd->device_identifier[0]);\r\nbreak;\r\ndefault:\r\nsprintf(buf, "T10 VPD Device Identifier encoding unsupported:"\r\n" 0x%02x", vpd->device_identifier_code_set);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (p_buf)\r\nstrncpy(p_buf, buf, p_buf_len);\r\nelse\r\npr_debug("%s", buf);\r\nreturn ret;\r\n}\r\nint\r\ntransport_set_vpd_ident(struct t10_vpd *vpd, unsigned char *page_83)\r\n{\r\nstatic const char hex_str[] = "0123456789abcdef";\r\nint j = 0, i = 4;\r\nvpd->device_identifier_code_set = (page_83[0] & 0x0f);\r\nswitch (vpd->device_identifier_code_set) {\r\ncase 0x01:\r\nvpd->device_identifier[j++] =\r\nhex_str[vpd->device_identifier_type];\r\nwhile (i < (4 + page_83[3])) {\r\nvpd->device_identifier[j++] =\r\nhex_str[(page_83[i] & 0xf0) >> 4];\r\nvpd->device_identifier[j++] =\r\nhex_str[page_83[i] & 0x0f];\r\ni++;\r\n}\r\nbreak;\r\ncase 0x02:\r\ncase 0x03:\r\nwhile (i < (4 + page_83[3]))\r\nvpd->device_identifier[j++] = page_83[i++];\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn transport_dump_vpd_ident(vpd, NULL, 0);\r\n}\r\nsense_reason_t\r\ntarget_cmd_size_check(struct se_cmd *cmd, unsigned int size)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nif (cmd->unknown_data_length) {\r\ncmd->data_length = size;\r\n} else if (size != cmd->data_length) {\r\npr_warn("TARGET_CORE[%s]: Expected Transfer Length:"\r\n" %u does not match SCSI CDB Length: %u for SAM Opcode:"\r\n" 0x%02x\n", cmd->se_tfo->get_fabric_name(),\r\ncmd->data_length, size, cmd->t_task_cdb[0]);\r\nif (cmd->data_direction == DMA_TO_DEVICE) {\r\npr_err("Rejecting underflow/overflow"\r\n" WRITE data\n");\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nif (dev->dev_attrib.block_size != 512) {\r\npr_err("Failing OVERFLOW/UNDERFLOW for LBA op"\r\n" CDB on non 512-byte sector setup subsystem"\r\n" plugin: %s\n", dev->transport->name);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nif (size > cmd->data_length) {\r\ncmd->se_cmd_flags |= SCF_OVERFLOW_BIT;\r\ncmd->residual_count = (size - cmd->data_length);\r\n} else {\r\ncmd->se_cmd_flags |= SCF_UNDERFLOW_BIT;\r\ncmd->residual_count = (cmd->data_length - size);\r\ncmd->data_length = size;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid transport_init_se_cmd(\r\nstruct se_cmd *cmd,\r\nstruct target_core_fabric_ops *tfo,\r\nstruct se_session *se_sess,\r\nu32 data_length,\r\nint data_direction,\r\nint task_attr,\r\nunsigned char *sense_buffer)\r\n{\r\nINIT_LIST_HEAD(&cmd->se_delayed_node);\r\nINIT_LIST_HEAD(&cmd->se_qf_node);\r\nINIT_LIST_HEAD(&cmd->se_cmd_list);\r\nINIT_LIST_HEAD(&cmd->state_list);\r\ninit_completion(&cmd->t_transport_stop_comp);\r\ninit_completion(&cmd->cmd_wait_comp);\r\ninit_completion(&cmd->task_stop_comp);\r\nspin_lock_init(&cmd->t_state_lock);\r\nkref_init(&cmd->cmd_kref);\r\ncmd->transport_state = CMD_T_DEV_ACTIVE;\r\ncmd->se_tfo = tfo;\r\ncmd->se_sess = se_sess;\r\ncmd->data_length = data_length;\r\ncmd->data_direction = data_direction;\r\ncmd->sam_task_attr = task_attr;\r\ncmd->sense_buffer = sense_buffer;\r\ncmd->state_active = false;\r\n}\r\nstatic sense_reason_t\r\ntransport_check_alloc_task_attr(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nif (dev->transport->transport_type == TRANSPORT_PLUGIN_PHBA_PDEV)\r\nreturn 0;\r\nif (cmd->sam_task_attr == MSG_ACA_TAG) {\r\npr_debug("SAM Task Attribute ACA"\r\n" emulation is not supported\n");\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\ncmd->se_ordered_id = atomic_inc_return(&dev->dev_ordered_id);\r\nsmp_mb__after_atomic();\r\npr_debug("Allocated se_ordered_id: %u for Task Attr: 0x%02x on %s\n",\r\ncmd->se_ordered_id, cmd->sam_task_attr,\r\ndev->transport->name);\r\nreturn 0;\r\n}\r\nsense_reason_t\r\ntarget_setup_cmd_from_cdb(struct se_cmd *cmd, unsigned char *cdb)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nsense_reason_t ret;\r\nif (scsi_command_size(cdb) > SCSI_MAX_VARLEN_CDB_SIZE) {\r\npr_err("Received SCSI CDB with command_size: %d that"\r\n" exceeds SCSI_MAX_VARLEN_CDB_SIZE: %d\n",\r\nscsi_command_size(cdb), SCSI_MAX_VARLEN_CDB_SIZE);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nif (scsi_command_size(cdb) > sizeof(cmd->__t_task_cdb)) {\r\ncmd->t_task_cdb = kzalloc(scsi_command_size(cdb),\r\nGFP_KERNEL);\r\nif (!cmd->t_task_cdb) {\r\npr_err("Unable to allocate cmd->t_task_cdb"\r\n" %u > sizeof(cmd->__t_task_cdb): %lu ops\n",\r\nscsi_command_size(cdb),\r\n(unsigned long)sizeof(cmd->__t_task_cdb));\r\nreturn TCM_OUT_OF_RESOURCES;\r\n}\r\n} else\r\ncmd->t_task_cdb = &cmd->__t_task_cdb[0];\r\nmemcpy(cmd->t_task_cdb, cdb, scsi_command_size(cdb));\r\ntrace_target_sequencer_start(cmd);\r\nret = target_scsi3_ua_check(cmd);\r\nif (ret)\r\nreturn ret;\r\nret = target_alua_state_check(cmd);\r\nif (ret)\r\nreturn ret;\r\nret = target_check_reservation(cmd);\r\nif (ret) {\r\ncmd->scsi_status = SAM_STAT_RESERVATION_CONFLICT;\r\nreturn ret;\r\n}\r\nret = dev->transport->parse_cdb(cmd);\r\nif (ret)\r\nreturn ret;\r\nret = transport_check_alloc_task_attr(cmd);\r\nif (ret)\r\nreturn ret;\r\ncmd->se_cmd_flags |= SCF_SUPPORTED_SAM_OPCODE;\r\nspin_lock(&cmd->se_lun->lun_sep_lock);\r\nif (cmd->se_lun->lun_sep)\r\ncmd->se_lun->lun_sep->sep_stats.cmd_pdus++;\r\nspin_unlock(&cmd->se_lun->lun_sep_lock);\r\nreturn 0;\r\n}\r\nint transport_handle_cdb_direct(\r\nstruct se_cmd *cmd)\r\n{\r\nsense_reason_t ret;\r\nif (!cmd->se_lun) {\r\ndump_stack();\r\npr_err("cmd->se_lun is NULL\n");\r\nreturn -EINVAL;\r\n}\r\nif (in_interrupt()) {\r\ndump_stack();\r\npr_err("transport_generic_handle_cdb cannot be called"\r\n" from interrupt context\n");\r\nreturn -EINVAL;\r\n}\r\ncmd->t_state = TRANSPORT_NEW_CMD;\r\ncmd->transport_state |= CMD_T_ACTIVE;\r\nret = transport_generic_new_cmd(cmd);\r\nif (ret)\r\ntransport_generic_request_failure(cmd, ret);\r\nreturn 0;\r\n}\r\nsense_reason_t\r\ntransport_generic_map_mem_to_cmd(struct se_cmd *cmd, struct scatterlist *sgl,\r\nu32 sgl_count, struct scatterlist *sgl_bidi, u32 sgl_bidi_count)\r\n{\r\nif (!sgl || !sgl_count)\r\nreturn 0;\r\nif (cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {\r\npr_warn("Rejecting SCSI DATA overflow for fabric using"\r\n" SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC\n");\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\ncmd->t_data_sg = sgl;\r\ncmd->t_data_nents = sgl_count;\r\nif (sgl_bidi && sgl_bidi_count) {\r\ncmd->t_bidi_data_sg = sgl_bidi;\r\ncmd->t_bidi_data_nents = sgl_bidi_count;\r\n}\r\ncmd->se_cmd_flags |= SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC;\r\nreturn 0;\r\n}\r\nint target_submit_cmd_map_sgls(struct se_cmd *se_cmd, struct se_session *se_sess,\r\nunsigned char *cdb, unsigned char *sense, u32 unpacked_lun,\r\nu32 data_length, int task_attr, int data_dir, int flags,\r\nstruct scatterlist *sgl, u32 sgl_count,\r\nstruct scatterlist *sgl_bidi, u32 sgl_bidi_count,\r\nstruct scatterlist *sgl_prot, u32 sgl_prot_count)\r\n{\r\nstruct se_portal_group *se_tpg;\r\nsense_reason_t rc;\r\nint ret;\r\nse_tpg = se_sess->se_tpg;\r\nBUG_ON(!se_tpg);\r\nBUG_ON(se_cmd->se_tfo || se_cmd->se_sess);\r\nBUG_ON(in_interrupt());\r\ntransport_init_se_cmd(se_cmd, se_tpg->se_tpg_tfo, se_sess,\r\ndata_length, data_dir, task_attr, sense);\r\nif (flags & TARGET_SCF_UNKNOWN_SIZE)\r\nse_cmd->unknown_data_length = 1;\r\nret = target_get_sess_cmd(se_sess, se_cmd, (flags & TARGET_SCF_ACK_KREF));\r\nif (ret)\r\nreturn ret;\r\nif (flags & TARGET_SCF_BIDI_OP)\r\nse_cmd->se_cmd_flags |= SCF_BIDI;\r\nrc = transport_lookup_cmd_lun(se_cmd, unpacked_lun);\r\nif (rc) {\r\ntransport_send_check_condition_and_sense(se_cmd, rc, 0);\r\ntarget_put_sess_cmd(se_sess, se_cmd);\r\nreturn 0;\r\n}\r\nrc = target_setup_cmd_from_cdb(se_cmd, cdb);\r\nif (rc != 0) {\r\ntransport_generic_request_failure(se_cmd, rc);\r\nreturn 0;\r\n}\r\nif (sgl_prot_count) {\r\nse_cmd->t_prot_sg = sgl_prot;\r\nse_cmd->t_prot_nents = sgl_prot_count;\r\n}\r\nif (sgl_count != 0) {\r\nBUG_ON(!sgl);\r\nif (!(se_cmd->se_cmd_flags & SCF_SCSI_DATA_CDB) &&\r\nse_cmd->data_direction == DMA_FROM_DEVICE) {\r\nunsigned char *buf = NULL;\r\nif (sgl)\r\nbuf = kmap(sg_page(sgl)) + sgl->offset;\r\nif (buf) {\r\nmemset(buf, 0, sgl->length);\r\nkunmap(sg_page(sgl));\r\n}\r\n}\r\nrc = transport_generic_map_mem_to_cmd(se_cmd, sgl, sgl_count,\r\nsgl_bidi, sgl_bidi_count);\r\nif (rc != 0) {\r\ntransport_generic_request_failure(se_cmd, rc);\r\nreturn 0;\r\n}\r\n}\r\ncore_alua_check_nonop_delay(se_cmd);\r\ntransport_handle_cdb_direct(se_cmd);\r\nreturn 0;\r\n}\r\nint target_submit_cmd(struct se_cmd *se_cmd, struct se_session *se_sess,\r\nunsigned char *cdb, unsigned char *sense, u32 unpacked_lun,\r\nu32 data_length, int task_attr, int data_dir, int flags)\r\n{\r\nreturn target_submit_cmd_map_sgls(se_cmd, se_sess, cdb, sense,\r\nunpacked_lun, data_length, task_attr, data_dir,\r\nflags, NULL, 0, NULL, 0, NULL, 0);\r\n}\r\nstatic void target_complete_tmr_failure(struct work_struct *work)\r\n{\r\nstruct se_cmd *se_cmd = container_of(work, struct se_cmd, work);\r\nse_cmd->se_tmr_req->response = TMR_LUN_DOES_NOT_EXIST;\r\nse_cmd->se_tfo->queue_tm_rsp(se_cmd);\r\ntransport_cmd_check_stop_to_fabric(se_cmd);\r\n}\r\nint target_submit_tmr(struct se_cmd *se_cmd, struct se_session *se_sess,\r\nunsigned char *sense, u32 unpacked_lun,\r\nvoid *fabric_tmr_ptr, unsigned char tm_type,\r\ngfp_t gfp, unsigned int tag, int flags)\r\n{\r\nstruct se_portal_group *se_tpg;\r\nint ret;\r\nse_tpg = se_sess->se_tpg;\r\nBUG_ON(!se_tpg);\r\ntransport_init_se_cmd(se_cmd, se_tpg->se_tpg_tfo, se_sess,\r\n0, DMA_NONE, MSG_SIMPLE_TAG, sense);\r\nret = core_tmr_alloc_req(se_cmd, fabric_tmr_ptr, tm_type, gfp);\r\nif (ret < 0)\r\nreturn -ENOMEM;\r\nif (tm_type == TMR_ABORT_TASK)\r\nse_cmd->se_tmr_req->ref_task_tag = tag;\r\nret = target_get_sess_cmd(se_sess, se_cmd, (flags & TARGET_SCF_ACK_KREF));\r\nif (ret) {\r\ncore_tmr_release_req(se_cmd->se_tmr_req);\r\nreturn ret;\r\n}\r\nret = transport_lookup_tmr_lun(se_cmd, unpacked_lun);\r\nif (ret) {\r\nINIT_WORK(&se_cmd->work, target_complete_tmr_failure);\r\nschedule_work(&se_cmd->work);\r\nreturn 0;\r\n}\r\ntransport_generic_handle_tmr(se_cmd);\r\nreturn 0;\r\n}\r\nbool target_stop_cmd(struct se_cmd *cmd, unsigned long *flags)\r\n{\r\nbool was_active = false;\r\nif (cmd->transport_state & CMD_T_BUSY) {\r\ncmd->transport_state |= CMD_T_REQUEST_STOP;\r\nspin_unlock_irqrestore(&cmd->t_state_lock, *flags);\r\npr_debug("cmd %p waiting to complete\n", cmd);\r\nwait_for_completion(&cmd->task_stop_comp);\r\npr_debug("cmd %p stopped successfully\n", cmd);\r\nspin_lock_irqsave(&cmd->t_state_lock, *flags);\r\ncmd->transport_state &= ~CMD_T_REQUEST_STOP;\r\ncmd->transport_state &= ~CMD_T_BUSY;\r\nwas_active = true;\r\n}\r\nreturn was_active;\r\n}\r\nvoid transport_generic_request_failure(struct se_cmd *cmd,\r\nsense_reason_t sense_reason)\r\n{\r\nint ret = 0;\r\npr_debug("-----[ Storage Engine Exception for cmd: %p ITT: 0x%08x"\r\n" CDB: 0x%02x\n", cmd, cmd->se_tfo->get_task_tag(cmd),\r\ncmd->t_task_cdb[0]);\r\npr_debug("-----[ i_state: %d t_state: %d sense_reason: %d\n",\r\ncmd->se_tfo->get_cmd_state(cmd),\r\ncmd->t_state, sense_reason);\r\npr_debug("-----[ CMD_T_ACTIVE: %d CMD_T_STOP: %d CMD_T_SENT: %d\n",\r\n(cmd->transport_state & CMD_T_ACTIVE) != 0,\r\n(cmd->transport_state & CMD_T_STOP) != 0,\r\n(cmd->transport_state & CMD_T_SENT) != 0);\r\ntransport_complete_task_attr(cmd);\r\nif ((cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE) &&\r\ncmd->transport_complete_callback)\r\ncmd->transport_complete_callback(cmd);\r\nswitch (sense_reason) {\r\ncase TCM_NON_EXISTENT_LUN:\r\ncase TCM_UNSUPPORTED_SCSI_OPCODE:\r\ncase TCM_INVALID_CDB_FIELD:\r\ncase TCM_INVALID_PARAMETER_LIST:\r\ncase TCM_PARAMETER_LIST_LENGTH_ERROR:\r\ncase TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE:\r\ncase TCM_UNKNOWN_MODE_PAGE:\r\ncase TCM_WRITE_PROTECTED:\r\ncase TCM_ADDRESS_OUT_OF_RANGE:\r\ncase TCM_CHECK_CONDITION_ABORT_CMD:\r\ncase TCM_CHECK_CONDITION_UNIT_ATTENTION:\r\ncase TCM_CHECK_CONDITION_NOT_READY:\r\ncase TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED:\r\ncase TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED:\r\ncase TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED:\r\nbreak;\r\ncase TCM_OUT_OF_RESOURCES:\r\nsense_reason = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nbreak;\r\ncase TCM_RESERVATION_CONFLICT:\r\ncmd->scsi_status = SAM_STAT_RESERVATION_CONFLICT;\r\nif (cmd->se_sess &&\r\ncmd->se_dev->dev_attrib.emulate_ua_intlck_ctrl == 2)\r\ncore_scsi3_ua_allocate(cmd->se_sess->se_node_acl,\r\ncmd->orig_fe_lun, 0x2C,\r\nASCQ_2CH_PREVIOUS_RESERVATION_CONFLICT_STATUS);\r\ntrace_target_cmd_complete(cmd);\r\nret = cmd->se_tfo-> queue_status(cmd);\r\nif (ret == -EAGAIN || ret == -ENOMEM)\r\ngoto queue_full;\r\ngoto check_stop;\r\ndefault:\r\npr_err("Unknown transport error for CDB 0x%02x: %d\n",\r\ncmd->t_task_cdb[0], sense_reason);\r\nsense_reason = TCM_UNSUPPORTED_SCSI_OPCODE;\r\nbreak;\r\n}\r\nret = transport_send_check_condition_and_sense(cmd, sense_reason, 0);\r\nif (ret == -EAGAIN || ret == -ENOMEM)\r\ngoto queue_full;\r\ncheck_stop:\r\ntransport_lun_remove_cmd(cmd);\r\nif (!transport_cmd_check_stop_to_fabric(cmd))\r\n;\r\nreturn;\r\nqueue_full:\r\ncmd->t_state = TRANSPORT_COMPLETE_QF_OK;\r\ntransport_handle_queue_full(cmd, cmd->se_dev);\r\n}\r\nvoid __target_execute_cmd(struct se_cmd *cmd)\r\n{\r\nsense_reason_t ret;\r\nif (cmd->execute_cmd) {\r\nret = cmd->execute_cmd(cmd);\r\nif (ret) {\r\nspin_lock_irq(&cmd->t_state_lock);\r\ncmd->transport_state &= ~(CMD_T_BUSY|CMD_T_SENT);\r\nspin_unlock_irq(&cmd->t_state_lock);\r\ntransport_generic_request_failure(cmd, ret);\r\n}\r\n}\r\n}\r\nstatic bool target_handle_task_attr(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nif (dev->transport->transport_type == TRANSPORT_PLUGIN_PHBA_PDEV)\r\nreturn false;\r\nswitch (cmd->sam_task_attr) {\r\ncase MSG_HEAD_TAG:\r\npr_debug("Added HEAD_OF_QUEUE for CDB: 0x%02x, "\r\n"se_ordered_id: %u\n",\r\ncmd->t_task_cdb[0], cmd->se_ordered_id);\r\nreturn false;\r\ncase MSG_ORDERED_TAG:\r\natomic_inc(&dev->dev_ordered_sync);\r\nsmp_mb__after_atomic();\r\npr_debug("Added ORDERED for CDB: 0x%02x to ordered list, "\r\n" se_ordered_id: %u\n",\r\ncmd->t_task_cdb[0], cmd->se_ordered_id);\r\nif (!atomic_read(&dev->simple_cmds))\r\nreturn false;\r\nbreak;\r\ndefault:\r\natomic_inc(&dev->simple_cmds);\r\nsmp_mb__after_atomic();\r\nbreak;\r\n}\r\nif (atomic_read(&dev->dev_ordered_sync) == 0)\r\nreturn false;\r\nspin_lock(&dev->delayed_cmd_lock);\r\nlist_add_tail(&cmd->se_delayed_node, &dev->delayed_cmd_list);\r\nspin_unlock(&dev->delayed_cmd_lock);\r\npr_debug("Added CDB: 0x%02x Task Attr: 0x%02x to"\r\n" delayed CMD list, se_ordered_id: %u\n",\r\ncmd->t_task_cdb[0], cmd->sam_task_attr,\r\ncmd->se_ordered_id);\r\nreturn true;\r\n}\r\nvoid target_execute_cmd(struct se_cmd *cmd)\r\n{\r\nif (transport_check_aborted_status(cmd, 1))\r\nreturn;\r\nspin_lock_irq(&cmd->t_state_lock);\r\nif (cmd->transport_state & CMD_T_STOP) {\r\npr_debug("%s:%d CMD_T_STOP for ITT: 0x%08x\n",\r\n__func__, __LINE__,\r\ncmd->se_tfo->get_task_tag(cmd));\r\nspin_unlock_irq(&cmd->t_state_lock);\r\ncomplete_all(&cmd->t_transport_stop_comp);\r\nreturn;\r\n}\r\ncmd->t_state = TRANSPORT_PROCESSING;\r\ncmd->transport_state |= CMD_T_ACTIVE|CMD_T_BUSY|CMD_T_SENT;\r\nspin_unlock_irq(&cmd->t_state_lock);\r\nif (cmd->prot_op == TARGET_PROT_DOUT_INSERT) {\r\nif (!(cmd->se_sess->sup_prot_ops & TARGET_PROT_DOUT_INSERT))\r\nsbc_dif_generate(cmd);\r\n}\r\nif (target_handle_task_attr(cmd)) {\r\nspin_lock_irq(&cmd->t_state_lock);\r\ncmd->transport_state &= ~CMD_T_BUSY|CMD_T_SENT;\r\nspin_unlock_irq(&cmd->t_state_lock);\r\nreturn;\r\n}\r\n__target_execute_cmd(cmd);\r\n}\r\nstatic void target_restart_delayed_cmds(struct se_device *dev)\r\n{\r\nfor (;;) {\r\nstruct se_cmd *cmd;\r\nspin_lock(&dev->delayed_cmd_lock);\r\nif (list_empty(&dev->delayed_cmd_list)) {\r\nspin_unlock(&dev->delayed_cmd_lock);\r\nbreak;\r\n}\r\ncmd = list_entry(dev->delayed_cmd_list.next,\r\nstruct se_cmd, se_delayed_node);\r\nlist_del(&cmd->se_delayed_node);\r\nspin_unlock(&dev->delayed_cmd_lock);\r\n__target_execute_cmd(cmd);\r\nif (cmd->sam_task_attr == MSG_ORDERED_TAG)\r\nbreak;\r\n}\r\n}\r\nstatic void transport_complete_task_attr(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nif (dev->transport->transport_type == TRANSPORT_PLUGIN_PHBA_PDEV)\r\nreturn;\r\nif (cmd->sam_task_attr == MSG_SIMPLE_TAG) {\r\natomic_dec(&dev->simple_cmds);\r\nsmp_mb__after_atomic();\r\ndev->dev_cur_ordered_id++;\r\npr_debug("Incremented dev->dev_cur_ordered_id: %u for"\r\n" SIMPLE: %u\n", dev->dev_cur_ordered_id,\r\ncmd->se_ordered_id);\r\n} else if (cmd->sam_task_attr == MSG_HEAD_TAG) {\r\ndev->dev_cur_ordered_id++;\r\npr_debug("Incremented dev_cur_ordered_id: %u for"\r\n" HEAD_OF_QUEUE: %u\n", dev->dev_cur_ordered_id,\r\ncmd->se_ordered_id);\r\n} else if (cmd->sam_task_attr == MSG_ORDERED_TAG) {\r\natomic_dec(&dev->dev_ordered_sync);\r\nsmp_mb__after_atomic();\r\ndev->dev_cur_ordered_id++;\r\npr_debug("Incremented dev_cur_ordered_id: %u for ORDERED:"\r\n" %u\n", dev->dev_cur_ordered_id, cmd->se_ordered_id);\r\n}\r\ntarget_restart_delayed_cmds(dev);\r\n}\r\nstatic void transport_complete_qf(struct se_cmd *cmd)\r\n{\r\nint ret = 0;\r\ntransport_complete_task_attr(cmd);\r\nif (cmd->se_cmd_flags & SCF_TRANSPORT_TASK_SENSE) {\r\ntrace_target_cmd_complete(cmd);\r\nret = cmd->se_tfo->queue_status(cmd);\r\nif (ret)\r\ngoto out;\r\n}\r\nswitch (cmd->data_direction) {\r\ncase DMA_FROM_DEVICE:\r\ntrace_target_cmd_complete(cmd);\r\nret = cmd->se_tfo->queue_data_in(cmd);\r\nbreak;\r\ncase DMA_TO_DEVICE:\r\nif (cmd->se_cmd_flags & SCF_BIDI) {\r\nret = cmd->se_tfo->queue_data_in(cmd);\r\nif (ret < 0)\r\nbreak;\r\n}\r\ncase DMA_NONE:\r\ntrace_target_cmd_complete(cmd);\r\nret = cmd->se_tfo->queue_status(cmd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nif (ret < 0) {\r\ntransport_handle_queue_full(cmd, cmd->se_dev);\r\nreturn;\r\n}\r\ntransport_lun_remove_cmd(cmd);\r\ntransport_cmd_check_stop_to_fabric(cmd);\r\n}\r\nstatic void transport_handle_queue_full(\r\nstruct se_cmd *cmd,\r\nstruct se_device *dev)\r\n{\r\nspin_lock_irq(&dev->qf_cmd_lock);\r\nlist_add_tail(&cmd->se_qf_node, &cmd->se_dev->qf_cmd_list);\r\natomic_inc(&dev->dev_qf_count);\r\nsmp_mb__after_atomic();\r\nspin_unlock_irq(&cmd->se_dev->qf_cmd_lock);\r\nschedule_work(&cmd->se_dev->qf_work_queue);\r\n}\r\nstatic bool target_check_read_strip(struct se_cmd *cmd)\r\n{\r\nsense_reason_t rc;\r\nif (!(cmd->se_sess->sup_prot_ops & TARGET_PROT_DIN_STRIP)) {\r\nrc = sbc_dif_read_strip(cmd);\r\nif (rc) {\r\ncmd->pi_err = rc;\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic void target_complete_ok_work(struct work_struct *work)\r\n{\r\nstruct se_cmd *cmd = container_of(work, struct se_cmd, work);\r\nint ret;\r\ntransport_complete_task_attr(cmd);\r\nif (atomic_read(&cmd->se_dev->dev_qf_count) != 0)\r\nschedule_work(&cmd->se_dev->qf_work_queue);\r\nif (cmd->se_cmd_flags & SCF_TRANSPORT_TASK_SENSE) {\r\nWARN_ON(!cmd->scsi_status);\r\nret = transport_send_check_condition_and_sense(\r\ncmd, 0, 1);\r\nif (ret == -EAGAIN || ret == -ENOMEM)\r\ngoto queue_full;\r\ntransport_lun_remove_cmd(cmd);\r\ntransport_cmd_check_stop_to_fabric(cmd);\r\nreturn;\r\n}\r\nif (cmd->transport_complete_callback) {\r\nsense_reason_t rc;\r\nrc = cmd->transport_complete_callback(cmd);\r\nif (!rc && !(cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE_POST)) {\r\nreturn;\r\n} else if (rc) {\r\nret = transport_send_check_condition_and_sense(cmd,\r\nrc, 0);\r\nif (ret == -EAGAIN || ret == -ENOMEM)\r\ngoto queue_full;\r\ntransport_lun_remove_cmd(cmd);\r\ntransport_cmd_check_stop_to_fabric(cmd);\r\nreturn;\r\n}\r\n}\r\nswitch (cmd->data_direction) {\r\ncase DMA_FROM_DEVICE:\r\nspin_lock(&cmd->se_lun->lun_sep_lock);\r\nif (cmd->se_lun->lun_sep) {\r\ncmd->se_lun->lun_sep->sep_stats.tx_data_octets +=\r\ncmd->data_length;\r\n}\r\nspin_unlock(&cmd->se_lun->lun_sep_lock);\r\nif (cmd->prot_op == TARGET_PROT_DIN_STRIP &&\r\ntarget_check_read_strip(cmd)) {\r\nret = transport_send_check_condition_and_sense(cmd,\r\ncmd->pi_err, 0);\r\nif (ret == -EAGAIN || ret == -ENOMEM)\r\ngoto queue_full;\r\ntransport_lun_remove_cmd(cmd);\r\ntransport_cmd_check_stop_to_fabric(cmd);\r\nreturn;\r\n}\r\ntrace_target_cmd_complete(cmd);\r\nret = cmd->se_tfo->queue_data_in(cmd);\r\nif (ret == -EAGAIN || ret == -ENOMEM)\r\ngoto queue_full;\r\nbreak;\r\ncase DMA_TO_DEVICE:\r\nspin_lock(&cmd->se_lun->lun_sep_lock);\r\nif (cmd->se_lun->lun_sep) {\r\ncmd->se_lun->lun_sep->sep_stats.rx_data_octets +=\r\ncmd->data_length;\r\n}\r\nspin_unlock(&cmd->se_lun->lun_sep_lock);\r\nif (cmd->se_cmd_flags & SCF_BIDI) {\r\nspin_lock(&cmd->se_lun->lun_sep_lock);\r\nif (cmd->se_lun->lun_sep) {\r\ncmd->se_lun->lun_sep->sep_stats.tx_data_octets +=\r\ncmd->data_length;\r\n}\r\nspin_unlock(&cmd->se_lun->lun_sep_lock);\r\nret = cmd->se_tfo->queue_data_in(cmd);\r\nif (ret == -EAGAIN || ret == -ENOMEM)\r\ngoto queue_full;\r\nbreak;\r\n}\r\ncase DMA_NONE:\r\ntrace_target_cmd_complete(cmd);\r\nret = cmd->se_tfo->queue_status(cmd);\r\nif (ret == -EAGAIN || ret == -ENOMEM)\r\ngoto queue_full;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ntransport_lun_remove_cmd(cmd);\r\ntransport_cmd_check_stop_to_fabric(cmd);\r\nreturn;\r\nqueue_full:\r\npr_debug("Handling complete_ok QUEUE_FULL: se_cmd: %p,"\r\n" data_direction: %d\n", cmd, cmd->data_direction);\r\ncmd->t_state = TRANSPORT_COMPLETE_QF_OK;\r\ntransport_handle_queue_full(cmd, cmd->se_dev);\r\n}\r\nstatic inline void transport_free_sgl(struct scatterlist *sgl, int nents)\r\n{\r\nstruct scatterlist *sg;\r\nint count;\r\nfor_each_sg(sgl, sg, nents, count)\r\n__free_page(sg_page(sg));\r\nkfree(sgl);\r\n}\r\nstatic inline void transport_reset_sgl_orig(struct se_cmd *cmd)\r\n{\r\nif (!cmd->t_data_sg_orig)\r\nreturn;\r\nkfree(cmd->t_data_sg);\r\ncmd->t_data_sg = cmd->t_data_sg_orig;\r\ncmd->t_data_sg_orig = NULL;\r\ncmd->t_data_nents = cmd->t_data_nents_orig;\r\ncmd->t_data_nents_orig = 0;\r\n}\r\nstatic inline void transport_free_pages(struct se_cmd *cmd)\r\n{\r\nif (cmd->se_cmd_flags & SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC) {\r\ntransport_reset_sgl_orig(cmd);\r\nreturn;\r\n}\r\ntransport_reset_sgl_orig(cmd);\r\ntransport_free_sgl(cmd->t_data_sg, cmd->t_data_nents);\r\ncmd->t_data_sg = NULL;\r\ncmd->t_data_nents = 0;\r\ntransport_free_sgl(cmd->t_bidi_data_sg, cmd->t_bidi_data_nents);\r\ncmd->t_bidi_data_sg = NULL;\r\ncmd->t_bidi_data_nents = 0;\r\ntransport_free_sgl(cmd->t_prot_sg, cmd->t_prot_nents);\r\ncmd->t_prot_sg = NULL;\r\ncmd->t_prot_nents = 0;\r\n}\r\nstatic int transport_release_cmd(struct se_cmd *cmd)\r\n{\r\nBUG_ON(!cmd->se_tfo);\r\nif (cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)\r\ncore_tmr_release_req(cmd->se_tmr_req);\r\nif (cmd->t_task_cdb != cmd->__t_task_cdb)\r\nkfree(cmd->t_task_cdb);\r\nreturn target_put_sess_cmd(cmd->se_sess, cmd);\r\n}\r\nstatic int transport_put_cmd(struct se_cmd *cmd)\r\n{\r\ntransport_free_pages(cmd);\r\nreturn transport_release_cmd(cmd);\r\n}\r\nvoid *transport_kmap_data_sg(struct se_cmd *cmd)\r\n{\r\nstruct scatterlist *sg = cmd->t_data_sg;\r\nstruct page **pages;\r\nint i;\r\nif (!cmd->t_data_nents)\r\nreturn NULL;\r\nBUG_ON(!sg);\r\nif (cmd->t_data_nents == 1)\r\nreturn kmap(sg_page(sg)) + sg->offset;\r\npages = kmalloc(sizeof(*pages) * cmd->t_data_nents, GFP_KERNEL);\r\nif (!pages)\r\nreturn NULL;\r\nfor_each_sg(cmd->t_data_sg, sg, cmd->t_data_nents, i) {\r\npages[i] = sg_page(sg);\r\n}\r\ncmd->t_data_vmap = vmap(pages, cmd->t_data_nents, VM_MAP, PAGE_KERNEL);\r\nkfree(pages);\r\nif (!cmd->t_data_vmap)\r\nreturn NULL;\r\nreturn cmd->t_data_vmap + cmd->t_data_sg[0].offset;\r\n}\r\nvoid transport_kunmap_data_sg(struct se_cmd *cmd)\r\n{\r\nif (!cmd->t_data_nents) {\r\nreturn;\r\n} else if (cmd->t_data_nents == 1) {\r\nkunmap(sg_page(cmd->t_data_sg));\r\nreturn;\r\n}\r\nvunmap(cmd->t_data_vmap);\r\ncmd->t_data_vmap = NULL;\r\n}\r\nint\r\ntarget_alloc_sgl(struct scatterlist **sgl, unsigned int *nents, u32 length,\r\nbool zero_page)\r\n{\r\nstruct scatterlist *sg;\r\nstruct page *page;\r\ngfp_t zero_flag = (zero_page) ? __GFP_ZERO : 0;\r\nunsigned int nent;\r\nint i = 0;\r\nnent = DIV_ROUND_UP(length, PAGE_SIZE);\r\nsg = kmalloc(sizeof(struct scatterlist) * nent, GFP_KERNEL);\r\nif (!sg)\r\nreturn -ENOMEM;\r\nsg_init_table(sg, nent);\r\nwhile (length) {\r\nu32 page_len = min_t(u32, length, PAGE_SIZE);\r\npage = alloc_page(GFP_KERNEL | zero_flag);\r\nif (!page)\r\ngoto out;\r\nsg_set_page(&sg[i], page, page_len, 0);\r\nlength -= page_len;\r\ni++;\r\n}\r\n*sgl = sg;\r\n*nents = nent;\r\nreturn 0;\r\nout:\r\nwhile (i > 0) {\r\ni--;\r\n__free_page(sg_page(&sg[i]));\r\n}\r\nkfree(sg);\r\nreturn -ENOMEM;\r\n}\r\nsense_reason_t\r\ntransport_generic_new_cmd(struct se_cmd *cmd)\r\n{\r\nint ret = 0;\r\nif (!(cmd->se_cmd_flags & SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC) &&\r\ncmd->data_length) {\r\nbool zero_flag = !(cmd->se_cmd_flags & SCF_SCSI_DATA_CDB);\r\nif ((cmd->se_cmd_flags & SCF_BIDI) ||\r\n(cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE)) {\r\nu32 bidi_length;\r\nif (cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE)\r\nbidi_length = cmd->t_task_nolb *\r\ncmd->se_dev->dev_attrib.block_size;\r\nelse\r\nbidi_length = cmd->data_length;\r\nret = target_alloc_sgl(&cmd->t_bidi_data_sg,\r\n&cmd->t_bidi_data_nents,\r\nbidi_length, zero_flag);\r\nif (ret < 0)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\nif (cmd->prot_op != TARGET_PROT_NORMAL) {\r\nret = target_alloc_sgl(&cmd->t_prot_sg,\r\n&cmd->t_prot_nents,\r\ncmd->prot_length, true);\r\nif (ret < 0)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\nret = target_alloc_sgl(&cmd->t_data_sg, &cmd->t_data_nents,\r\ncmd->data_length, zero_flag);\r\nif (ret < 0)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\ntarget_add_to_state_list(cmd);\r\nif (cmd->data_direction != DMA_TO_DEVICE) {\r\ntarget_execute_cmd(cmd);\r\nreturn 0;\r\n}\r\ntransport_cmd_check_stop(cmd, false, true);\r\nret = cmd->se_tfo->write_pending(cmd);\r\nif (ret == -EAGAIN || ret == -ENOMEM)\r\ngoto queue_full;\r\nWARN_ON(ret);\r\nreturn (!ret) ? 0 : TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nqueue_full:\r\npr_debug("Handling write_pending QUEUE__FULL: se_cmd: %p\n", cmd);\r\ncmd->t_state = TRANSPORT_COMPLETE_QF_WP;\r\ntransport_handle_queue_full(cmd, cmd->se_dev);\r\nreturn 0;\r\n}\r\nstatic void transport_write_pending_qf(struct se_cmd *cmd)\r\n{\r\nint ret;\r\nret = cmd->se_tfo->write_pending(cmd);\r\nif (ret == -EAGAIN || ret == -ENOMEM) {\r\npr_debug("Handling write_pending QUEUE__FULL: se_cmd: %p\n",\r\ncmd);\r\ntransport_handle_queue_full(cmd, cmd->se_dev);\r\n}\r\n}\r\nint transport_generic_free_cmd(struct se_cmd *cmd, int wait_for_tasks)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nif (!(cmd->se_cmd_flags & SCF_SE_LUN_CMD)) {\r\nif (wait_for_tasks && (cmd->se_cmd_flags & SCF_SCSI_TMR_CDB))\r\ntransport_wait_for_tasks(cmd);\r\nret = transport_release_cmd(cmd);\r\n} else {\r\nif (wait_for_tasks)\r\ntransport_wait_for_tasks(cmd);\r\nif (cmd->state_active) {\r\nspin_lock_irqsave(&cmd->t_state_lock, flags);\r\ntarget_remove_from_state_list(cmd);\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\n}\r\nif (cmd->se_lun)\r\ntransport_lun_remove_cmd(cmd);\r\nret = transport_put_cmd(cmd);\r\n}\r\nreturn ret;\r\n}\r\nint target_get_sess_cmd(struct se_session *se_sess, struct se_cmd *se_cmd,\r\nbool ack_kref)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nif (ack_kref) {\r\nkref_get(&se_cmd->cmd_kref);\r\nse_cmd->se_cmd_flags |= SCF_ACK_KREF;\r\n}\r\nspin_lock_irqsave(&se_sess->sess_cmd_lock, flags);\r\nif (se_sess->sess_tearing_down) {\r\nret = -ESHUTDOWN;\r\ngoto out;\r\n}\r\nlist_add_tail(&se_cmd->se_cmd_list, &se_sess->sess_cmd_list);\r\nout:\r\nspin_unlock_irqrestore(&se_sess->sess_cmd_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void target_release_cmd_kref(struct kref *kref)\r\n{\r\nstruct se_cmd *se_cmd = container_of(kref, struct se_cmd, cmd_kref);\r\nstruct se_session *se_sess = se_cmd->se_sess;\r\nif (list_empty(&se_cmd->se_cmd_list)) {\r\nspin_unlock(&se_sess->sess_cmd_lock);\r\nse_cmd->se_tfo->release_cmd(se_cmd);\r\nreturn;\r\n}\r\nif (se_sess->sess_tearing_down && se_cmd->cmd_wait_set) {\r\nspin_unlock(&se_sess->sess_cmd_lock);\r\ncomplete(&se_cmd->cmd_wait_comp);\r\nreturn;\r\n}\r\nlist_del(&se_cmd->se_cmd_list);\r\nspin_unlock(&se_sess->sess_cmd_lock);\r\nse_cmd->se_tfo->release_cmd(se_cmd);\r\n}\r\nint target_put_sess_cmd(struct se_session *se_sess, struct se_cmd *se_cmd)\r\n{\r\nif (!se_sess) {\r\nse_cmd->se_tfo->release_cmd(se_cmd);\r\nreturn 1;\r\n}\r\nreturn kref_put_spinlock_irqsave(&se_cmd->cmd_kref, target_release_cmd_kref,\r\n&se_sess->sess_cmd_lock);\r\n}\r\nvoid target_sess_cmd_list_set_waiting(struct se_session *se_sess)\r\n{\r\nstruct se_cmd *se_cmd;\r\nunsigned long flags;\r\nspin_lock_irqsave(&se_sess->sess_cmd_lock, flags);\r\nif (se_sess->sess_tearing_down) {\r\nspin_unlock_irqrestore(&se_sess->sess_cmd_lock, flags);\r\nreturn;\r\n}\r\nse_sess->sess_tearing_down = 1;\r\nlist_splice_init(&se_sess->sess_cmd_list, &se_sess->sess_wait_list);\r\nlist_for_each_entry(se_cmd, &se_sess->sess_wait_list, se_cmd_list)\r\nse_cmd->cmd_wait_set = 1;\r\nspin_unlock_irqrestore(&se_sess->sess_cmd_lock, flags);\r\n}\r\nvoid target_wait_for_sess_cmds(struct se_session *se_sess)\r\n{\r\nstruct se_cmd *se_cmd, *tmp_cmd;\r\nunsigned long flags;\r\nlist_for_each_entry_safe(se_cmd, tmp_cmd,\r\n&se_sess->sess_wait_list, se_cmd_list) {\r\nlist_del(&se_cmd->se_cmd_list);\r\npr_debug("Waiting for se_cmd: %p t_state: %d, fabric state:"\r\n" %d\n", se_cmd, se_cmd->t_state,\r\nse_cmd->se_tfo->get_cmd_state(se_cmd));\r\nwait_for_completion(&se_cmd->cmd_wait_comp);\r\npr_debug("After cmd_wait_comp: se_cmd: %p t_state: %d"\r\n" fabric state: %d\n", se_cmd, se_cmd->t_state,\r\nse_cmd->se_tfo->get_cmd_state(se_cmd));\r\nse_cmd->se_tfo->release_cmd(se_cmd);\r\n}\r\nspin_lock_irqsave(&se_sess->sess_cmd_lock, flags);\r\nWARN_ON(!list_empty(&se_sess->sess_cmd_list));\r\nspin_unlock_irqrestore(&se_sess->sess_cmd_lock, flags);\r\n}\r\nstatic int transport_clear_lun_ref_thread(void *p)\r\n{\r\nstruct se_lun *lun = p;\r\npercpu_ref_kill(&lun->lun_ref);\r\nwait_for_completion(&lun->lun_ref_comp);\r\ncomplete(&lun->lun_shutdown_comp);\r\nreturn 0;\r\n}\r\nint transport_clear_lun_ref(struct se_lun *lun)\r\n{\r\nstruct task_struct *kt;\r\nkt = kthread_run(transport_clear_lun_ref_thread, lun,\r\n"tcm_cl_%u", lun->unpacked_lun);\r\nif (IS_ERR(kt)) {\r\npr_err("Unable to start clear_lun thread\n");\r\nreturn PTR_ERR(kt);\r\n}\r\nwait_for_completion(&lun->lun_shutdown_comp);\r\nreturn 0;\r\n}\r\nbool transport_wait_for_tasks(struct se_cmd *cmd)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cmd->t_state_lock, flags);\r\nif (!(cmd->se_cmd_flags & SCF_SE_LUN_CMD) &&\r\n!(cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)) {\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nreturn false;\r\n}\r\nif (!(cmd->se_cmd_flags & SCF_SUPPORTED_SAM_OPCODE) &&\r\n!(cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)) {\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nreturn false;\r\n}\r\nif (!(cmd->transport_state & CMD_T_ACTIVE)) {\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nreturn false;\r\n}\r\ncmd->transport_state |= CMD_T_STOP;\r\npr_debug("wait_for_tasks: Stopping %p ITT: 0x%08x"\r\n" i_state: %d, t_state: %d, CMD_T_STOP\n",\r\ncmd, cmd->se_tfo->get_task_tag(cmd),\r\ncmd->se_tfo->get_cmd_state(cmd), cmd->t_state);\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nwait_for_completion(&cmd->t_transport_stop_comp);\r\nspin_lock_irqsave(&cmd->t_state_lock, flags);\r\ncmd->transport_state &= ~(CMD_T_ACTIVE | CMD_T_STOP);\r\npr_debug("wait_for_tasks: Stopped wait_for_completion("\r\n"&cmd->t_transport_stop_comp) for ITT: 0x%08x\n",\r\ncmd->se_tfo->get_task_tag(cmd));\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nreturn true;\r\n}\r\nstatic int transport_get_sense_codes(\r\nstruct se_cmd *cmd,\r\nu8 *asc,\r\nu8 *ascq)\r\n{\r\n*asc = cmd->scsi_asc;\r\n*ascq = cmd->scsi_ascq;\r\nreturn 0;\r\n}\r\nstatic\r\nvoid transport_err_sector_info(unsigned char *buffer, sector_t bad_sector)\r\n{\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 0xc;\r\nbuffer[SPC_DESC_TYPE_OFFSET] = 0;\r\nbuffer[SPC_ADDITIONAL_DESC_LEN_OFFSET] = 0xa;\r\nbuffer[SPC_VALIDITY_OFFSET] = 0x80;\r\nput_unaligned_be64(bad_sector, &buffer[12]);\r\n}\r\nint\r\ntransport_send_check_condition_and_sense(struct se_cmd *cmd,\r\nsense_reason_t reason, int from_transport)\r\n{\r\nunsigned char *buffer = cmd->sense_buffer;\r\nunsigned long flags;\r\nu8 asc = 0, ascq = 0;\r\nspin_lock_irqsave(&cmd->t_state_lock, flags);\r\nif (cmd->se_cmd_flags & SCF_SENT_CHECK_CONDITION) {\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nreturn 0;\r\n}\r\ncmd->se_cmd_flags |= SCF_SENT_CHECK_CONDITION;\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nif (!reason && from_transport)\r\ngoto after_reason;\r\nif (!from_transport)\r\ncmd->se_cmd_flags |= SCF_EMULATED_TASK_SENSE;\r\nswitch (reason) {\r\ncase TCM_NO_SENSE:\r\nbuffer[0] = 0x70;\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;\r\nbuffer[SPC_SENSE_KEY_OFFSET] = NOT_READY;\r\nbuffer[SPC_ASC_KEY_OFFSET] = 0;\r\nbuffer[SPC_ASCQ_KEY_OFFSET] = 0;\r\nbreak;\r\ncase TCM_NON_EXISTENT_LUN:\r\nbuffer[0] = 0x70;\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;\r\nbuffer[SPC_SENSE_KEY_OFFSET] = ILLEGAL_REQUEST;\r\nbuffer[SPC_ASC_KEY_OFFSET] = 0x25;\r\nbreak;\r\ncase TCM_UNSUPPORTED_SCSI_OPCODE:\r\ncase TCM_SECTOR_COUNT_TOO_MANY:\r\nbuffer[0] = 0x70;\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;\r\nbuffer[SPC_SENSE_KEY_OFFSET] = ILLEGAL_REQUEST;\r\nbuffer[SPC_ASC_KEY_OFFSET] = 0x20;\r\nbreak;\r\ncase TCM_UNKNOWN_MODE_PAGE:\r\nbuffer[0] = 0x70;\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;\r\nbuffer[SPC_SENSE_KEY_OFFSET] = ILLEGAL_REQUEST;\r\nbuffer[SPC_ASC_KEY_OFFSET] = 0x24;\r\nbreak;\r\ncase TCM_CHECK_CONDITION_ABORT_CMD:\r\nbuffer[0] = 0x70;\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;\r\nbuffer[SPC_SENSE_KEY_OFFSET] = ABORTED_COMMAND;\r\nbuffer[SPC_ASC_KEY_OFFSET] = 0x29;\r\nbuffer[SPC_ASCQ_KEY_OFFSET] = 0x03;\r\nbreak;\r\ncase TCM_INCORRECT_AMOUNT_OF_DATA:\r\nbuffer[0] = 0x70;\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;\r\nbuffer[SPC_SENSE_KEY_OFFSET] = ABORTED_COMMAND;\r\nbuffer[SPC_ASC_KEY_OFFSET] = 0x0c;\r\nbuffer[SPC_ASCQ_KEY_OFFSET] = 0x0d;\r\nbreak;\r\ncase TCM_INVALID_CDB_FIELD:\r\nbuffer[0] = 0x70;\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;\r\nbuffer[SPC_SENSE_KEY_OFFSET] = ILLEGAL_REQUEST;\r\nbuffer[SPC_ASC_KEY_OFFSET] = 0x24;\r\nbreak;\r\ncase TCM_INVALID_PARAMETER_LIST:\r\nbuffer[0] = 0x70;\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;\r\nbuffer[SPC_SENSE_KEY_OFFSET] = ILLEGAL_REQUEST;\r\nbuffer[SPC_ASC_KEY_OFFSET] = 0x26;\r\nbreak;\r\ncase TCM_PARAMETER_LIST_LENGTH_ERROR:\r\nbuffer[0] = 0x70;\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;\r\nbuffer[SPC_SENSE_KEY_OFFSET] = ILLEGAL_REQUEST;\r\nbuffer[SPC_ASC_KEY_OFFSET] = 0x1a;\r\nbreak;\r\ncase TCM_UNEXPECTED_UNSOLICITED_DATA:\r\nbuffer[0] = 0x70;\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;\r\nbuffer[SPC_SENSE_KEY_OFFSET] = ABORTED_COMMAND;\r\nbuffer[SPC_ASC_KEY_OFFSET] = 0x0c;\r\nbuffer[SPC_ASCQ_KEY_OFFSET] = 0x0c;\r\nbreak;\r\ncase TCM_SERVICE_CRC_ERROR:\r\nbuffer[0] = 0x70;\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;\r\nbuffer[SPC_SENSE_KEY_OFFSET] = ABORTED_COMMAND;\r\nbuffer[SPC_ASC_KEY_OFFSET] = 0x47;\r\nbuffer[SPC_ASCQ_KEY_OFFSET] = 0x05;\r\nbreak;\r\ncase TCM_SNACK_REJECTED:\r\nbuffer[0] = 0x70;\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;\r\nbuffer[SPC_SENSE_KEY_OFFSET] = ABORTED_COMMAND;\r\nbuffer[SPC_ASC_KEY_OFFSET] = 0x11;\r\nbuffer[SPC_ASCQ_KEY_OFFSET] = 0x13;\r\nbreak;\r\ncase TCM_WRITE_PROTECTED:\r\nbuffer[0] = 0x70;\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;\r\nbuffer[SPC_SENSE_KEY_OFFSET] = DATA_PROTECT;\r\nbuffer[SPC_ASC_KEY_OFFSET] = 0x27;\r\nbreak;\r\ncase TCM_ADDRESS_OUT_OF_RANGE:\r\nbuffer[0] = 0x70;\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;\r\nbuffer[SPC_SENSE_KEY_OFFSET] = ILLEGAL_REQUEST;\r\nbuffer[SPC_ASC_KEY_OFFSET] = 0x21;\r\nbreak;\r\ncase TCM_CHECK_CONDITION_UNIT_ATTENTION:\r\nbuffer[0] = 0x70;\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;\r\nbuffer[SPC_SENSE_KEY_OFFSET] = UNIT_ATTENTION;\r\ncore_scsi3_ua_for_check_condition(cmd, &asc, &ascq);\r\nbuffer[SPC_ASC_KEY_OFFSET] = asc;\r\nbuffer[SPC_ASCQ_KEY_OFFSET] = ascq;\r\nbreak;\r\ncase TCM_CHECK_CONDITION_NOT_READY:\r\nbuffer[0] = 0x70;\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;\r\nbuffer[SPC_SENSE_KEY_OFFSET] = NOT_READY;\r\ntransport_get_sense_codes(cmd, &asc, &ascq);\r\nbuffer[SPC_ASC_KEY_OFFSET] = asc;\r\nbuffer[SPC_ASCQ_KEY_OFFSET] = ascq;\r\nbreak;\r\ncase TCM_MISCOMPARE_VERIFY:\r\nbuffer[0] = 0x70;\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;\r\nbuffer[SPC_SENSE_KEY_OFFSET] = MISCOMPARE;\r\nbuffer[SPC_ASC_KEY_OFFSET] = 0x1d;\r\nbuffer[SPC_ASCQ_KEY_OFFSET] = 0x00;\r\nbreak;\r\ncase TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED:\r\nbuffer[0] = 0x70;\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;\r\nbuffer[SPC_SENSE_KEY_OFFSET] = ILLEGAL_REQUEST;\r\nbuffer[SPC_ASC_KEY_OFFSET] = 0x10;\r\nbuffer[SPC_ASCQ_KEY_OFFSET] = 0x01;\r\ntransport_err_sector_info(buffer, cmd->bad_sector);\r\nbreak;\r\ncase TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED:\r\nbuffer[0] = 0x70;\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;\r\nbuffer[SPC_SENSE_KEY_OFFSET] = ILLEGAL_REQUEST;\r\nbuffer[SPC_ASC_KEY_OFFSET] = 0x10;\r\nbuffer[SPC_ASCQ_KEY_OFFSET] = 0x02;\r\ntransport_err_sector_info(buffer, cmd->bad_sector);\r\nbreak;\r\ncase TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED:\r\nbuffer[0] = 0x70;\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;\r\nbuffer[SPC_SENSE_KEY_OFFSET] = ILLEGAL_REQUEST;\r\nbuffer[SPC_ASC_KEY_OFFSET] = 0x10;\r\nbuffer[SPC_ASCQ_KEY_OFFSET] = 0x03;\r\ntransport_err_sector_info(buffer, cmd->bad_sector);\r\nbreak;\r\ncase TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE:\r\ndefault:\r\nbuffer[0] = 0x70;\r\nbuffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;\r\nbuffer[SPC_SENSE_KEY_OFFSET] = NOT_READY;\r\nbuffer[SPC_ASC_KEY_OFFSET] = 0x08;\r\nbreak;\r\n}\r\ncmd->scsi_status = SAM_STAT_CHECK_CONDITION;\r\ncmd->scsi_sense_length = TRANSPORT_SENSE_BUFFER;\r\nafter_reason:\r\ntrace_target_cmd_complete(cmd);\r\nreturn cmd->se_tfo->queue_status(cmd);\r\n}\r\nint transport_check_aborted_status(struct se_cmd *cmd, int send_status)\r\n{\r\nif (!(cmd->transport_state & CMD_T_ABORTED))\r\nreturn 0;\r\nif (!send_status || !(cmd->se_cmd_flags & SCF_SEND_DELAYED_TAS))\r\nreturn 1;\r\npr_debug("Sending delayed SAM_STAT_TASK_ABORTED status for CDB: 0x%02x ITT: 0x%08x\n",\r\ncmd->t_task_cdb[0], cmd->se_tfo->get_task_tag(cmd));\r\ncmd->se_cmd_flags &= ~SCF_SEND_DELAYED_TAS;\r\ncmd->scsi_status = SAM_STAT_TASK_ABORTED;\r\ntrace_target_cmd_complete(cmd);\r\ncmd->se_tfo->queue_status(cmd);\r\nreturn 1;\r\n}\r\nvoid transport_send_task_abort(struct se_cmd *cmd)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cmd->t_state_lock, flags);\r\nif (cmd->se_cmd_flags & (SCF_SENT_CHECK_CONDITION)) {\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nif (cmd->data_direction == DMA_TO_DEVICE) {\r\nif (cmd->se_tfo->write_pending_status(cmd) != 0) {\r\ncmd->transport_state |= CMD_T_ABORTED;\r\ncmd->se_cmd_flags |= SCF_SEND_DELAYED_TAS;\r\nsmp_mb__after_atomic();\r\nreturn;\r\n}\r\n}\r\ncmd->scsi_status = SAM_STAT_TASK_ABORTED;\r\ntransport_lun_remove_cmd(cmd);\r\npr_debug("Setting SAM_STAT_TASK_ABORTED status for CDB: 0x%02x,"\r\n" ITT: 0x%08x\n", cmd->t_task_cdb[0],\r\ncmd->se_tfo->get_task_tag(cmd));\r\ntrace_target_cmd_complete(cmd);\r\ncmd->se_tfo->queue_status(cmd);\r\n}\r\nstatic void target_tmr_work(struct work_struct *work)\r\n{\r\nstruct se_cmd *cmd = container_of(work, struct se_cmd, work);\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_tmr_req *tmr = cmd->se_tmr_req;\r\nint ret;\r\nswitch (tmr->function) {\r\ncase TMR_ABORT_TASK:\r\ncore_tmr_abort_task(dev, tmr, cmd->se_sess);\r\nbreak;\r\ncase TMR_ABORT_TASK_SET:\r\ncase TMR_CLEAR_ACA:\r\ncase TMR_CLEAR_TASK_SET:\r\ntmr->response = TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;\r\nbreak;\r\ncase TMR_LUN_RESET:\r\nret = core_tmr_lun_reset(dev, tmr, NULL, NULL);\r\ntmr->response = (!ret) ? TMR_FUNCTION_COMPLETE :\r\nTMR_FUNCTION_REJECTED;\r\nbreak;\r\ncase TMR_TARGET_WARM_RESET:\r\ntmr->response = TMR_FUNCTION_REJECTED;\r\nbreak;\r\ncase TMR_TARGET_COLD_RESET:\r\ntmr->response = TMR_FUNCTION_REJECTED;\r\nbreak;\r\ndefault:\r\npr_err("Uknown TMR function: 0x%02x.\n",\r\ntmr->function);\r\ntmr->response = TMR_FUNCTION_REJECTED;\r\nbreak;\r\n}\r\ncmd->t_state = TRANSPORT_ISTATE_PROCESSING;\r\ncmd->se_tfo->queue_tm_rsp(cmd);\r\ntransport_cmd_check_stop_to_fabric(cmd);\r\n}\r\nint transport_generic_handle_tmr(\r\nstruct se_cmd *cmd)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cmd->t_state_lock, flags);\r\ncmd->transport_state |= CMD_T_ACTIVE;\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\nINIT_WORK(&cmd->work, target_tmr_work);\r\nqueue_work(cmd->se_dev->tmr_wq, &cmd->work);\r\nreturn 0;\r\n}
