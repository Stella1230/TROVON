static void dce3_2_afmt_write_speaker_allocation(struct drm_encoder *encoder)\r\n{\r\nstruct radeon_device *rdev = encoder->dev->dev_private;\r\nstruct drm_connector *connector;\r\nstruct radeon_connector *radeon_connector = NULL;\r\nu32 tmp;\r\nu8 *sadb;\r\nint sad_count;\r\nlist_for_each_entry(connector, &encoder->dev->mode_config.connector_list, head) {\r\nif (connector->encoder == encoder) {\r\nradeon_connector = to_radeon_connector(connector);\r\nbreak;\r\n}\r\n}\r\nif (!radeon_connector) {\r\nDRM_ERROR("Couldn't find encoder's connector\n");\r\nreturn;\r\n}\r\nsad_count = drm_edid_to_speaker_allocation(radeon_connector->edid, &sadb);\r\nif (sad_count < 0) {\r\nDRM_ERROR("Couldn't read Speaker Allocation Data Block: %d\n", sad_count);\r\nreturn;\r\n}\r\ntmp = RREG32(AZ_F0_CODEC_PIN0_CONTROL_CHANNEL_SPEAKER);\r\ntmp &= ~(DP_CONNECTION | SPEAKER_ALLOCATION_MASK);\r\ntmp |= HDMI_CONNECTION;\r\nif (sad_count)\r\ntmp |= SPEAKER_ALLOCATION(sadb[0]);\r\nelse\r\ntmp |= SPEAKER_ALLOCATION(5);\r\nWREG32(AZ_F0_CODEC_PIN0_CONTROL_CHANNEL_SPEAKER, tmp);\r\nkfree(sadb);\r\n}\r\nstatic void dce3_2_afmt_write_sad_regs(struct drm_encoder *encoder)\r\n{\r\nstruct radeon_device *rdev = encoder->dev->dev_private;\r\nstruct drm_connector *connector;\r\nstruct radeon_connector *radeon_connector = NULL;\r\nstruct cea_sad *sads;\r\nint i, sad_count;\r\nstatic const u16 eld_reg_to_type[][2] = {\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR0, HDMI_AUDIO_CODING_TYPE_PCM },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR1, HDMI_AUDIO_CODING_TYPE_AC3 },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR2, HDMI_AUDIO_CODING_TYPE_MPEG1 },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR3, HDMI_AUDIO_CODING_TYPE_MP3 },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR4, HDMI_AUDIO_CODING_TYPE_MPEG2 },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR5, HDMI_AUDIO_CODING_TYPE_AAC_LC },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR6, HDMI_AUDIO_CODING_TYPE_DTS },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR7, HDMI_AUDIO_CODING_TYPE_ATRAC },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR9, HDMI_AUDIO_CODING_TYPE_EAC3 },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR10, HDMI_AUDIO_CODING_TYPE_DTS_HD },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR11, HDMI_AUDIO_CODING_TYPE_MLP },\r\n{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR13, HDMI_AUDIO_CODING_TYPE_WMA_PRO },\r\n};\r\nlist_for_each_entry(connector, &encoder->dev->mode_config.connector_list, head) {\r\nif (connector->encoder == encoder) {\r\nradeon_connector = to_radeon_connector(connector);\r\nbreak;\r\n}\r\n}\r\nif (!radeon_connector) {\r\nDRM_ERROR("Couldn't find encoder's connector\n");\r\nreturn;\r\n}\r\nsad_count = drm_edid_to_sad(radeon_connector->edid, &sads);\r\nif (sad_count < 0) {\r\nDRM_ERROR("Couldn't read SADs: %d\n", sad_count);\r\nreturn;\r\n}\r\nBUG_ON(!sads);\r\nfor (i = 0; i < ARRAY_SIZE(eld_reg_to_type); i++) {\r\nu32 value = 0;\r\nu8 stereo_freqs = 0;\r\nint max_channels = -1;\r\nint j;\r\nfor (j = 0; j < sad_count; j++) {\r\nstruct cea_sad *sad = &sads[j];\r\nif (sad->format == eld_reg_to_type[i][1]) {\r\nif (sad->channels > max_channels) {\r\nvalue = MAX_CHANNELS(sad->channels) |\r\nDESCRIPTOR_BYTE_2(sad->byte2) |\r\nSUPPORTED_FREQUENCIES(sad->freq);\r\nmax_channels = sad->channels;\r\n}\r\nif (sad->format == HDMI_AUDIO_CODING_TYPE_PCM)\r\nstereo_freqs |= sad->freq;\r\nelse\r\nbreak;\r\n}\r\n}\r\nvalue |= SUPPORTED_FREQUENCIES_STEREO(stereo_freqs);\r\nWREG32(eld_reg_to_type[i][0], value);\r\n}\r\nkfree(sads);\r\n}\r\nvoid dce3_1_hdmi_setmode(struct drm_encoder *encoder, struct drm_display_mode *mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nu8 buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AVI_INFOFRAME_SIZE];\r\nstruct hdmi_avi_infoframe frame;\r\nuint32_t offset;\r\nssize_t err;\r\nif (!dig || !dig->afmt)\r\nreturn;\r\nif (!dig->afmt->enabled)\r\nreturn;\r\noffset = dig->afmt->offset;\r\ndig->afmt->pin = r600_audio_get_pin(rdev);\r\nr600_audio_enable(rdev, dig->afmt->pin, false);\r\nr600_audio_set_dto(encoder, mode->clock);\r\nWREG32(HDMI0_VBI_PACKET_CONTROL + offset,\r\nHDMI0_NULL_SEND);\r\nWREG32(HDMI0_AUDIO_CRC_CONTROL + offset, 0x1000);\r\nif (ASIC_IS_DCE32(rdev)) {\r\nWREG32(HDMI0_AUDIO_PACKET_CONTROL + offset,\r\nHDMI0_AUDIO_DELAY_EN(1) |\r\nHDMI0_AUDIO_PACKETS_PER_LINE(3));\r\nWREG32(AFMT_AUDIO_PACKET_CONTROL + offset,\r\nAFMT_AUDIO_SAMPLE_SEND |\r\nAFMT_60958_CS_UPDATE);\r\n} else {\r\nWREG32(HDMI0_AUDIO_PACKET_CONTROL + offset,\r\nHDMI0_AUDIO_SAMPLE_SEND |\r\nHDMI0_AUDIO_DELAY_EN(1) |\r\nHDMI0_AUDIO_PACKETS_PER_LINE(3) |\r\nHDMI0_60958_CS_UPDATE);\r\n}\r\nif (ASIC_IS_DCE32(rdev)) {\r\ndce3_2_afmt_write_speaker_allocation(encoder);\r\ndce3_2_afmt_write_sad_regs(encoder);\r\n}\r\nWREG32(HDMI0_ACR_PACKET_CONTROL + offset,\r\nHDMI0_ACR_SOURCE |\r\nHDMI0_ACR_AUTO_SEND);\r\nWREG32(HDMI0_VBI_PACKET_CONTROL + offset,\r\nHDMI0_NULL_SEND |\r\nHDMI0_GC_SEND |\r\nHDMI0_GC_CONT);\r\nWREG32(HDMI0_INFOFRAME_CONTROL0 + offset,\r\nHDMI0_AVI_INFO_SEND |\r\nHDMI0_AVI_INFO_CONT |\r\nHDMI0_AUDIO_INFO_SEND |\r\nHDMI0_AUDIO_INFO_CONT);\r\nWREG32(HDMI0_INFOFRAME_CONTROL1 + offset,\r\nHDMI0_AVI_INFO_LINE(2) |\r\nHDMI0_AUDIO_INFO_LINE(2));\r\nWREG32(HDMI0_GC + offset, 0);\r\nerr = drm_hdmi_avi_infoframe_from_display_mode(&frame, mode);\r\nif (err < 0) {\r\nDRM_ERROR("failed to setup AVI infoframe: %zd\n", err);\r\nreturn;\r\n}\r\nerr = hdmi_avi_infoframe_pack(&frame, buffer, sizeof(buffer));\r\nif (err < 0) {\r\nDRM_ERROR("failed to pack AVI infoframe: %zd\n", err);\r\nreturn;\r\n}\r\nr600_hdmi_update_avi_infoframe(encoder, buffer, sizeof(buffer));\r\nr600_hdmi_update_ACR(encoder, mode->clock);\r\nWREG32(HDMI0_RAMP_CONTROL0 + offset, 0x00FFFFFF);\r\nWREG32(HDMI0_RAMP_CONTROL1 + offset, 0x007FFFFF);\r\nWREG32(HDMI0_RAMP_CONTROL2 + offset, 0x00000001);\r\nWREG32(HDMI0_RAMP_CONTROL3 + offset, 0x00000001);\r\nr600_hdmi_audio_workaround(encoder);\r\nr600_audio_enable(rdev, dig->afmt->pin, true);\r\n}
