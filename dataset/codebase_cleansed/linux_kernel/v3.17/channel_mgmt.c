bool vmbus_prep_negotiate_resp(struct icmsg_hdr *icmsghdrp,\r\nstruct icmsg_negotiate *negop, u8 *buf,\r\nint fw_version, int srv_version)\r\n{\r\nint icframe_major, icframe_minor;\r\nint icmsg_major, icmsg_minor;\r\nint fw_major, fw_minor;\r\nint srv_major, srv_minor;\r\nint i;\r\nbool found_match = false;\r\nicmsghdrp->icmsgsize = 0x10;\r\nfw_major = (fw_version >> 16);\r\nfw_minor = (fw_version & 0xFFFF);\r\nsrv_major = (srv_version >> 16);\r\nsrv_minor = (srv_version & 0xFFFF);\r\nnegop = (struct icmsg_negotiate *)&buf[\r\nsizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nicframe_major = negop->icframe_vercnt;\r\nicframe_minor = 0;\r\nicmsg_major = negop->icmsg_vercnt;\r\nicmsg_minor = 0;\r\nfor (i = 0; i < negop->icframe_vercnt; i++) {\r\nif ((negop->icversion_data[i].major == fw_major) &&\r\n(negop->icversion_data[i].minor == fw_minor)) {\r\nicframe_major = negop->icversion_data[i].major;\r\nicframe_minor = negop->icversion_data[i].minor;\r\nfound_match = true;\r\n}\r\n}\r\nif (!found_match)\r\ngoto fw_error;\r\nfound_match = false;\r\nfor (i = negop->icframe_vercnt;\r\n(i < negop->icframe_vercnt + negop->icmsg_vercnt); i++) {\r\nif ((negop->icversion_data[i].major == srv_major) &&\r\n(negop->icversion_data[i].minor == srv_minor)) {\r\nicmsg_major = negop->icversion_data[i].major;\r\nicmsg_minor = negop->icversion_data[i].minor;\r\nfound_match = true;\r\n}\r\n}\r\nfw_error:\r\nif (!found_match) {\r\nnegop->icframe_vercnt = 0;\r\nnegop->icmsg_vercnt = 0;\r\n} else {\r\nnegop->icframe_vercnt = 1;\r\nnegop->icmsg_vercnt = 1;\r\n}\r\nnegop->icversion_data[0].major = icframe_major;\r\nnegop->icversion_data[0].minor = icframe_minor;\r\nnegop->icversion_data[1].major = icmsg_major;\r\nnegop->icversion_data[1].minor = icmsg_minor;\r\nreturn found_match;\r\n}\r\nstatic struct vmbus_channel *alloc_channel(void)\r\n{\r\nstruct vmbus_channel *channel;\r\nchannel = kzalloc(sizeof(*channel), GFP_ATOMIC);\r\nif (!channel)\r\nreturn NULL;\r\nspin_lock_init(&channel->inbound_lock);\r\nspin_lock_init(&channel->sc_lock);\r\nINIT_LIST_HEAD(&channel->sc_list);\r\nINIT_LIST_HEAD(&channel->percpu_list);\r\nchannel->controlwq = create_workqueue("hv_vmbus_ctl");\r\nif (!channel->controlwq) {\r\nkfree(channel);\r\nreturn NULL;\r\n}\r\nreturn channel;\r\n}\r\nstatic void release_channel(struct work_struct *work)\r\n{\r\nstruct vmbus_channel *channel = container_of(work,\r\nstruct vmbus_channel,\r\nwork);\r\ndestroy_workqueue(channel->controlwq);\r\nkfree(channel);\r\n}\r\nstatic void free_channel(struct vmbus_channel *channel)\r\n{\r\nINIT_WORK(&channel->work, release_channel);\r\nqueue_work(vmbus_connection.work_queue, &channel->work);\r\n}\r\nstatic void percpu_channel_enq(void *arg)\r\n{\r\nstruct vmbus_channel *channel = arg;\r\nint cpu = smp_processor_id();\r\nlist_add_tail(&channel->percpu_list, &hv_context.percpu_list[cpu]);\r\n}\r\nstatic void percpu_channel_deq(void *arg)\r\n{\r\nstruct vmbus_channel *channel = arg;\r\nlist_del(&channel->percpu_list);\r\n}\r\nstatic void vmbus_process_rescind_offer(struct work_struct *work)\r\n{\r\nstruct vmbus_channel *channel = container_of(work,\r\nstruct vmbus_channel,\r\nwork);\r\nunsigned long flags;\r\nstruct vmbus_channel *primary_channel;\r\nstruct vmbus_channel_relid_released msg;\r\nif (channel->device_obj)\r\nvmbus_device_unregister(channel->device_obj);\r\nmemset(&msg, 0, sizeof(struct vmbus_channel_relid_released));\r\nmsg.child_relid = channel->offermsg.child_relid;\r\nmsg.header.msgtype = CHANNELMSG_RELID_RELEASED;\r\nvmbus_post_msg(&msg, sizeof(struct vmbus_channel_relid_released));\r\nif (channel->target_cpu != smp_processor_id())\r\nsmp_call_function_single(channel->target_cpu,\r\npercpu_channel_deq, channel, true);\r\nelse\r\npercpu_channel_deq(channel);\r\nif (channel->primary_channel == NULL) {\r\nspin_lock_irqsave(&vmbus_connection.channel_lock, flags);\r\nlist_del(&channel->listentry);\r\nspin_unlock_irqrestore(&vmbus_connection.channel_lock, flags);\r\n} else {\r\nprimary_channel = channel->primary_channel;\r\nspin_lock_irqsave(&primary_channel->sc_lock, flags);\r\nlist_del(&channel->sc_list);\r\nspin_unlock_irqrestore(&primary_channel->sc_lock, flags);\r\n}\r\nfree_channel(channel);\r\n}\r\nvoid vmbus_free_channels(void)\r\n{\r\nstruct vmbus_channel *channel;\r\nlist_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {\r\nvmbus_device_unregister(channel->device_obj);\r\nkfree(channel->device_obj);\r\nfree_channel(channel);\r\n}\r\n}\r\nstatic void vmbus_process_offer(struct work_struct *work)\r\n{\r\nstruct vmbus_channel *newchannel = container_of(work,\r\nstruct vmbus_channel,\r\nwork);\r\nstruct vmbus_channel *channel;\r\nbool fnew = true;\r\nbool enq = false;\r\nint ret;\r\nunsigned long flags;\r\nINIT_WORK(&newchannel->work, vmbus_process_rescind_offer);\r\nspin_lock_irqsave(&vmbus_connection.channel_lock, flags);\r\nlist_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {\r\nif (!uuid_le_cmp(channel->offermsg.offer.if_type,\r\nnewchannel->offermsg.offer.if_type) &&\r\n!uuid_le_cmp(channel->offermsg.offer.if_instance,\r\nnewchannel->offermsg.offer.if_instance)) {\r\nfnew = false;\r\nbreak;\r\n}\r\n}\r\nif (fnew) {\r\nlist_add_tail(&newchannel->listentry,\r\n&vmbus_connection.chn_list);\r\nenq = true;\r\n}\r\nspin_unlock_irqrestore(&vmbus_connection.channel_lock, flags);\r\nif (enq) {\r\nif (newchannel->target_cpu != smp_processor_id())\r\nsmp_call_function_single(newchannel->target_cpu,\r\npercpu_channel_enq,\r\nnewchannel, true);\r\nelse\r\npercpu_channel_enq(newchannel);\r\n}\r\nif (!fnew) {\r\nif (newchannel->offermsg.offer.sub_channel_index != 0) {\r\nnewchannel->primary_channel = channel;\r\nspin_lock_irqsave(&channel->sc_lock, flags);\r\nlist_add_tail(&newchannel->sc_list, &channel->sc_list);\r\nspin_unlock_irqrestore(&channel->sc_lock, flags);\r\nif (newchannel->target_cpu != smp_processor_id())\r\nsmp_call_function_single(newchannel->target_cpu,\r\npercpu_channel_enq,\r\nnewchannel, true);\r\nelse\r\npercpu_channel_enq(newchannel);\r\nnewchannel->state = CHANNEL_OPEN_STATE;\r\nif (channel->sc_creation_callback != NULL)\r\nchannel->sc_creation_callback(newchannel);\r\nreturn;\r\n}\r\nfree_channel(newchannel);\r\nreturn;\r\n}\r\nnewchannel->state = CHANNEL_OPEN_STATE;\r\nnewchannel->device_obj = vmbus_device_create(\r\n&newchannel->offermsg.offer.if_type,\r\n&newchannel->offermsg.offer.if_instance,\r\nnewchannel);\r\nret = vmbus_device_register(newchannel->device_obj);\r\nif (ret != 0) {\r\npr_err("unable to add child device object (relid %d)\n",\r\nnewchannel->offermsg.child_relid);\r\nspin_lock_irqsave(&vmbus_connection.channel_lock, flags);\r\nlist_del(&newchannel->listentry);\r\nspin_unlock_irqrestore(&vmbus_connection.channel_lock, flags);\r\nkfree(newchannel->device_obj);\r\nfree_channel(newchannel);\r\n}\r\n}\r\nstatic void init_vp_index(struct vmbus_channel *channel, const uuid_le *type_guid)\r\n{\r\nu32 cur_cpu;\r\nint i;\r\nbool perf_chn = false;\r\nu32 max_cpus = num_online_cpus();\r\nfor (i = IDE; i < MAX_PERF_CHN; i++) {\r\nif (!memcmp(type_guid->b, hp_devs[i].guid,\r\nsizeof(uuid_le))) {\r\nperf_chn = true;\r\nbreak;\r\n}\r\n}\r\nif ((vmbus_proto_version == VERSION_WS2008) ||\r\n(vmbus_proto_version == VERSION_WIN7) || (!perf_chn)) {\r\nchannel->target_cpu = 0;\r\nchannel->target_vp = 0;\r\nreturn;\r\n}\r\ncur_cpu = (++next_vp % max_cpus);\r\nchannel->target_cpu = cur_cpu;\r\nchannel->target_vp = hv_context.vp_index[cur_cpu];\r\n}\r\nstatic void vmbus_onoffer(struct vmbus_channel_message_header *hdr)\r\n{\r\nstruct vmbus_channel_offer_channel *offer;\r\nstruct vmbus_channel *newchannel;\r\noffer = (struct vmbus_channel_offer_channel *)hdr;\r\nnewchannel = alloc_channel();\r\nif (!newchannel) {\r\npr_err("Unable to allocate channel object\n");\r\nreturn;\r\n}\r\nnewchannel->batched_reading = true;\r\nnewchannel->sig_event = (struct hv_input_signal_event *)\r\n(ALIGN((unsigned long)\r\n&newchannel->sig_buf,\r\nHV_HYPERCALL_PARAM_ALIGN));\r\nnewchannel->sig_event->connectionid.asu32 = 0;\r\nnewchannel->sig_event->connectionid.u.id = VMBUS_EVENT_CONNECTION_ID;\r\nnewchannel->sig_event->flag_number = 0;\r\nnewchannel->sig_event->rsvdz = 0;\r\nif (vmbus_proto_version != VERSION_WS2008) {\r\nnewchannel->is_dedicated_interrupt =\r\n(offer->is_dedicated_interrupt != 0);\r\nnewchannel->sig_event->connectionid.u.id =\r\noffer->connection_id;\r\n}\r\ninit_vp_index(newchannel, &offer->offer.if_type);\r\nmemcpy(&newchannel->offermsg, offer,\r\nsizeof(struct vmbus_channel_offer_channel));\r\nnewchannel->monitor_grp = (u8)offer->monitorid / 32;\r\nnewchannel->monitor_bit = (u8)offer->monitorid % 32;\r\nINIT_WORK(&newchannel->work, vmbus_process_offer);\r\nqueue_work(newchannel->controlwq, &newchannel->work);\r\n}\r\nstatic void vmbus_onoffer_rescind(struct vmbus_channel_message_header *hdr)\r\n{\r\nstruct vmbus_channel_rescind_offer *rescind;\r\nstruct vmbus_channel *channel;\r\nrescind = (struct vmbus_channel_rescind_offer *)hdr;\r\nchannel = relid2channel(rescind->child_relid);\r\nif (channel == NULL)\r\nreturn;\r\nqueue_work(channel->controlwq, &channel->work);\r\n}\r\nstatic void vmbus_onoffers_delivered(\r\nstruct vmbus_channel_message_header *hdr)\r\n{\r\n}\r\nstatic void vmbus_onopen_result(struct vmbus_channel_message_header *hdr)\r\n{\r\nstruct vmbus_channel_open_result *result;\r\nstruct vmbus_channel_msginfo *msginfo;\r\nstruct vmbus_channel_message_header *requestheader;\r\nstruct vmbus_channel_open_channel *openmsg;\r\nunsigned long flags;\r\nresult = (struct vmbus_channel_open_result *)hdr;\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_for_each_entry(msginfo, &vmbus_connection.chn_msg_list,\r\nmsglistentry) {\r\nrequestheader =\r\n(struct vmbus_channel_message_header *)msginfo->msg;\r\nif (requestheader->msgtype == CHANNELMSG_OPENCHANNEL) {\r\nopenmsg =\r\n(struct vmbus_channel_open_channel *)msginfo->msg;\r\nif (openmsg->child_relid == result->child_relid &&\r\nopenmsg->openid == result->openid) {\r\nmemcpy(&msginfo->response.open_result,\r\nresult,\r\nsizeof(\r\nstruct vmbus_channel_open_result));\r\ncomplete(&msginfo->waitevent);\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\r\n}\r\nstatic void vmbus_ongpadl_created(struct vmbus_channel_message_header *hdr)\r\n{\r\nstruct vmbus_channel_gpadl_created *gpadlcreated;\r\nstruct vmbus_channel_msginfo *msginfo;\r\nstruct vmbus_channel_message_header *requestheader;\r\nstruct vmbus_channel_gpadl_header *gpadlheader;\r\nunsigned long flags;\r\ngpadlcreated = (struct vmbus_channel_gpadl_created *)hdr;\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_for_each_entry(msginfo, &vmbus_connection.chn_msg_list,\r\nmsglistentry) {\r\nrequestheader =\r\n(struct vmbus_channel_message_header *)msginfo->msg;\r\nif (requestheader->msgtype == CHANNELMSG_GPADL_HEADER) {\r\ngpadlheader =\r\n(struct vmbus_channel_gpadl_header *)requestheader;\r\nif ((gpadlcreated->child_relid ==\r\ngpadlheader->child_relid) &&\r\n(gpadlcreated->gpadl == gpadlheader->gpadl)) {\r\nmemcpy(&msginfo->response.gpadl_created,\r\ngpadlcreated,\r\nsizeof(\r\nstruct vmbus_channel_gpadl_created));\r\ncomplete(&msginfo->waitevent);\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\r\n}\r\nstatic void vmbus_ongpadl_torndown(\r\nstruct vmbus_channel_message_header *hdr)\r\n{\r\nstruct vmbus_channel_gpadl_torndown *gpadl_torndown;\r\nstruct vmbus_channel_msginfo *msginfo;\r\nstruct vmbus_channel_message_header *requestheader;\r\nstruct vmbus_channel_gpadl_teardown *gpadl_teardown;\r\nunsigned long flags;\r\ngpadl_torndown = (struct vmbus_channel_gpadl_torndown *)hdr;\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_for_each_entry(msginfo, &vmbus_connection.chn_msg_list,\r\nmsglistentry) {\r\nrequestheader =\r\n(struct vmbus_channel_message_header *)msginfo->msg;\r\nif (requestheader->msgtype == CHANNELMSG_GPADL_TEARDOWN) {\r\ngpadl_teardown =\r\n(struct vmbus_channel_gpadl_teardown *)requestheader;\r\nif (gpadl_torndown->gpadl == gpadl_teardown->gpadl) {\r\nmemcpy(&msginfo->response.gpadl_torndown,\r\ngpadl_torndown,\r\nsizeof(\r\nstruct vmbus_channel_gpadl_torndown));\r\ncomplete(&msginfo->waitevent);\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\r\n}\r\nstatic void vmbus_onversion_response(\r\nstruct vmbus_channel_message_header *hdr)\r\n{\r\nstruct vmbus_channel_msginfo *msginfo;\r\nstruct vmbus_channel_message_header *requestheader;\r\nstruct vmbus_channel_version_response *version_response;\r\nunsigned long flags;\r\nversion_response = (struct vmbus_channel_version_response *)hdr;\r\nspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\r\nlist_for_each_entry(msginfo, &vmbus_connection.chn_msg_list,\r\nmsglistentry) {\r\nrequestheader =\r\n(struct vmbus_channel_message_header *)msginfo->msg;\r\nif (requestheader->msgtype ==\r\nCHANNELMSG_INITIATE_CONTACT) {\r\nmemcpy(&msginfo->response.version_response,\r\nversion_response,\r\nsizeof(struct vmbus_channel_version_response));\r\ncomplete(&msginfo->waitevent);\r\n}\r\n}\r\nspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\r\n}\r\nvoid vmbus_onmessage(void *context)\r\n{\r\nstruct hv_message *msg = context;\r\nstruct vmbus_channel_message_header *hdr;\r\nint size;\r\nhdr = (struct vmbus_channel_message_header *)msg->u.payload;\r\nsize = msg->header.payload_size;\r\nif (hdr->msgtype >= CHANNELMSG_COUNT) {\r\npr_err("Received invalid channel message type %d size %d\n",\r\nhdr->msgtype, size);\r\nprint_hex_dump_bytes("", DUMP_PREFIX_NONE,\r\n(unsigned char *)msg->u.payload, size);\r\nreturn;\r\n}\r\nif (channel_message_table[hdr->msgtype].message_handler)\r\nchannel_message_table[hdr->msgtype].message_handler(hdr);\r\nelse\r\npr_err("Unhandled channel message type %d\n", hdr->msgtype);\r\n}\r\nint vmbus_request_offers(void)\r\n{\r\nstruct vmbus_channel_message_header *msg;\r\nstruct vmbus_channel_msginfo *msginfo;\r\nint ret, t;\r\nmsginfo = kmalloc(sizeof(*msginfo) +\r\nsizeof(struct vmbus_channel_message_header),\r\nGFP_KERNEL);\r\nif (!msginfo)\r\nreturn -ENOMEM;\r\ninit_completion(&msginfo->waitevent);\r\nmsg = (struct vmbus_channel_message_header *)msginfo->msg;\r\nmsg->msgtype = CHANNELMSG_REQUESTOFFERS;\r\nret = vmbus_post_msg(msg,\r\nsizeof(struct vmbus_channel_message_header));\r\nif (ret != 0) {\r\npr_err("Unable to request offers - %d\n", ret);\r\ngoto cleanup;\r\n}\r\nt = wait_for_completion_timeout(&msginfo->waitevent, 5*HZ);\r\nif (t == 0) {\r\nret = -ETIMEDOUT;\r\ngoto cleanup;\r\n}\r\ncleanup:\r\nkfree(msginfo);\r\nreturn ret;\r\n}\r\nstruct vmbus_channel *vmbus_get_outgoing_channel(struct vmbus_channel *primary)\r\n{\r\nstruct list_head *cur, *tmp;\r\nint cur_cpu = hv_context.vp_index[smp_processor_id()];\r\nstruct vmbus_channel *cur_channel;\r\nstruct vmbus_channel *outgoing_channel = primary;\r\nint cpu_distance, new_cpu_distance;\r\nif (list_empty(&primary->sc_list))\r\nreturn outgoing_channel;\r\nlist_for_each_safe(cur, tmp, &primary->sc_list) {\r\ncur_channel = list_entry(cur, struct vmbus_channel, sc_list);\r\nif (cur_channel->state != CHANNEL_OPENED_STATE)\r\ncontinue;\r\nif (cur_channel->target_vp == cur_cpu)\r\nreturn cur_channel;\r\ncpu_distance = ((outgoing_channel->target_vp > cur_cpu) ?\r\n(outgoing_channel->target_vp - cur_cpu) :\r\n(cur_cpu - outgoing_channel->target_vp));\r\nnew_cpu_distance = ((cur_channel->target_vp > cur_cpu) ?\r\n(cur_channel->target_vp - cur_cpu) :\r\n(cur_cpu - cur_channel->target_vp));\r\nif (cpu_distance < new_cpu_distance)\r\ncontinue;\r\noutgoing_channel = cur_channel;\r\n}\r\nreturn outgoing_channel;\r\n}\r\nstatic void invoke_sc_cb(struct vmbus_channel *primary_channel)\r\n{\r\nstruct list_head *cur, *tmp;\r\nstruct vmbus_channel *cur_channel;\r\nif (primary_channel->sc_creation_callback == NULL)\r\nreturn;\r\nlist_for_each_safe(cur, tmp, &primary_channel->sc_list) {\r\ncur_channel = list_entry(cur, struct vmbus_channel, sc_list);\r\nprimary_channel->sc_creation_callback(cur_channel);\r\n}\r\n}\r\nvoid vmbus_set_sc_create_callback(struct vmbus_channel *primary_channel,\r\nvoid (*sc_cr_cb)(struct vmbus_channel *new_sc))\r\n{\r\nprimary_channel->sc_creation_callback = sc_cr_cb;\r\n}\r\nbool vmbus_are_subchannels_present(struct vmbus_channel *primary)\r\n{\r\nbool ret;\r\nret = !list_empty(&primary->sc_list);\r\nif (ret) {\r\ninvoke_sc_cb(primary);\r\n}\r\nreturn ret;\r\n}
