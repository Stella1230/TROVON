static int __init mv64x60_mpsc_register_shared_pdev(struct device_node *np)\r\n{\r\nstruct platform_device *pdev;\r\nstruct resource r[2];\r\nstruct mpsc_shared_pdata pdata;\r\nconst phandle *ph;\r\nstruct device_node *mpscrouting, *mpscintr;\r\nint err;\r\nph = of_get_property(np, "mpscrouting", NULL);\r\nmpscrouting = of_find_node_by_phandle(*ph);\r\nif (!mpscrouting)\r\nreturn -ENODEV;\r\nerr = of_address_to_resource(mpscrouting, 0, &r[0]);\r\nof_node_put(mpscrouting);\r\nif (err)\r\nreturn err;\r\nph = of_get_property(np, "mpscintr", NULL);\r\nmpscintr = of_find_node_by_phandle(*ph);\r\nif (!mpscintr)\r\nreturn -ENODEV;\r\nerr = of_address_to_resource(mpscintr, 0, &r[1]);\r\nof_node_put(mpscintr);\r\nif (err)\r\nreturn err;\r\nmemset(&pdata, 0, sizeof(pdata));\r\npdev = platform_device_alloc(MPSC_SHARED_NAME, 0);\r\nif (!pdev)\r\nreturn -ENOMEM;\r\nerr = platform_device_add_resources(pdev, r, 2);\r\nif (err)\r\ngoto error;\r\nerr = platform_device_add_data(pdev, &pdata, sizeof(pdata));\r\nif (err)\r\ngoto error;\r\nerr = platform_device_add(pdev);\r\nif (err)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nplatform_device_put(pdev);\r\nreturn err;\r\n}\r\nstatic int __init mv64x60_mpsc_device_setup(struct device_node *np, int id)\r\n{\r\nstruct resource r[5];\r\nstruct mpsc_pdata pdata;\r\nstruct platform_device *pdev;\r\nconst unsigned int *prop;\r\nconst phandle *ph;\r\nstruct device_node *sdma, *brg;\r\nint err;\r\nint port_number;\r\nif (id == 0 && (err = mv64x60_mpsc_register_shared_pdev(np)))\r\nreturn err;\r\nmemset(r, 0, sizeof(r));\r\nerr = of_address_to_resource(np, 0, &r[0]);\r\nif (err)\r\nreturn err;\r\nof_irq_to_resource(np, 0, &r[4]);\r\nph = of_get_property(np, "sdma", NULL);\r\nsdma = of_find_node_by_phandle(*ph);\r\nif (!sdma)\r\nreturn -ENODEV;\r\nof_irq_to_resource(sdma, 0, &r[3]);\r\nerr = of_address_to_resource(sdma, 0, &r[1]);\r\nof_node_put(sdma);\r\nif (err)\r\nreturn err;\r\nph = of_get_property(np, "brg", NULL);\r\nbrg = of_find_node_by_phandle(*ph);\r\nif (!brg)\r\nreturn -ENODEV;\r\nerr = of_address_to_resource(brg, 0, &r[2]);\r\nof_node_put(brg);\r\nif (err)\r\nreturn err;\r\nprop = of_get_property(np, "cell-index", NULL);\r\nif (!prop)\r\nreturn -ENODEV;\r\nport_number = *(int *)prop;\r\nmemset(&pdata, 0, sizeof(pdata));\r\npdata.cache_mgmt = 1;\r\npdata.max_idle = 40;\r\nprop = of_get_property(np, "max_idle", NULL);\r\nif (prop)\r\npdata.max_idle = *prop;\r\nprop = of_get_property(brg, "current-speed", NULL);\r\nif (prop)\r\npdata.default_baud = *prop;\r\npdata.default_bits = 8;\r\npdata.default_parity = 'n';\r\npdata.default_flow = 'n';\r\nprop = of_get_property(np, "chr_1", NULL);\r\nif (prop)\r\npdata.chr_1_val = *prop;\r\nprop = of_get_property(np, "chr_2", NULL);\r\nif (prop)\r\npdata.chr_2_val = *prop;\r\nprop = of_get_property(np, "chr_10", NULL);\r\nif (prop)\r\npdata.chr_10_val = *prop;\r\nprop = of_get_property(np, "mpcr", NULL);\r\nif (prop)\r\npdata.mpcr_val = *prop;\r\nprop = of_get_property(brg, "bcr", NULL);\r\nif (prop)\r\npdata.bcr_val = *prop;\r\npdata.brg_can_tune = 1;\r\nprop = of_get_property(brg, "clock-src", NULL);\r\nif (prop)\r\npdata.brg_clk_src = *prop;\r\nprop = of_get_property(brg, "clock-frequency", NULL);\r\nif (prop)\r\npdata.brg_clk_freq = *prop;\r\npdev = platform_device_alloc(MPSC_CTLR_NAME, port_number);\r\nif (!pdev)\r\nreturn -ENOMEM;\r\npdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);\r\nerr = platform_device_add_resources(pdev, r, 5);\r\nif (err)\r\ngoto error;\r\nerr = platform_device_add_data(pdev, &pdata, sizeof(pdata));\r\nif (err)\r\ngoto error;\r\nerr = platform_device_add(pdev);\r\nif (err)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nplatform_device_put(pdev);\r\nreturn err;\r\n}\r\nstatic struct platform_device * __init mv64x60_eth_register_shared_pdev(\r\nstruct device_node *np, int id)\r\n{\r\nstruct platform_device *pdev;\r\nstruct resource r[2];\r\nint err;\r\nerr = of_address_to_resource(np, 0, &r[0]);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nr[1].start = r[0].start + 0x4;\r\nr[1].end = r[0].start + 0x84 - 1;\r\nr[1].flags = IORESOURCE_MEM;\r\nif (id == 0) {\r\npdev = platform_device_register_simple("orion-mdio", -1, &r[1], 1);\r\nif (IS_ERR(pdev))\r\nreturn pdev;\r\n}\r\npdev = platform_device_register_simple(MV643XX_ETH_SHARED_NAME, id,\r\n&r[0], 1);\r\nreturn pdev;\r\n}\r\nstatic int __init mv64x60_eth_device_setup(struct device_node *np, int id,\r\nstruct platform_device *shared_pdev)\r\n{\r\nstruct resource r[1];\r\nstruct mv643xx_eth_platform_data pdata;\r\nstruct platform_device *pdev;\r\nstruct device_node *phy;\r\nconst u8 *mac_addr;\r\nconst int *prop;\r\nconst phandle *ph;\r\nint err;\r\nmemset(r, 0, sizeof(r));\r\nof_irq_to_resource(np, 0, &r[0]);\r\nmemset(&pdata, 0, sizeof(pdata));\r\npdata.shared = shared_pdev;\r\nprop = of_get_property(np, "reg", NULL);\r\nif (!prop)\r\nreturn -ENODEV;\r\npdata.port_number = *prop;\r\nmac_addr = of_get_mac_address(np);\r\nif (mac_addr)\r\nmemcpy(pdata.mac_addr, mac_addr, 6);\r\nprop = of_get_property(np, "speed", NULL);\r\nif (prop)\r\npdata.speed = *prop;\r\nprop = of_get_property(np, "tx_queue_size", NULL);\r\nif (prop)\r\npdata.tx_queue_size = *prop;\r\nprop = of_get_property(np, "rx_queue_size", NULL);\r\nif (prop)\r\npdata.rx_queue_size = *prop;\r\nprop = of_get_property(np, "tx_sram_addr", NULL);\r\nif (prop)\r\npdata.tx_sram_addr = *prop;\r\nprop = of_get_property(np, "tx_sram_size", NULL);\r\nif (prop)\r\npdata.tx_sram_size = *prop;\r\nprop = of_get_property(np, "rx_sram_addr", NULL);\r\nif (prop)\r\npdata.rx_sram_addr = *prop;\r\nprop = of_get_property(np, "rx_sram_size", NULL);\r\nif (prop)\r\npdata.rx_sram_size = *prop;\r\nph = of_get_property(np, "phy", NULL);\r\nif (!ph)\r\nreturn -ENODEV;\r\nphy = of_find_node_by_phandle(*ph);\r\nif (phy == NULL)\r\nreturn -ENODEV;\r\nprop = of_get_property(phy, "reg", NULL);\r\nif (prop)\r\npdata.phy_addr = MV643XX_ETH_PHY_ADDR(*prop);\r\nof_node_put(phy);\r\npdev = platform_device_alloc(MV643XX_ETH_NAME, id);\r\nif (!pdev)\r\nreturn -ENOMEM;\r\npdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);\r\nerr = platform_device_add_resources(pdev, r, 1);\r\nif (err)\r\ngoto error;\r\nerr = platform_device_add_data(pdev, &pdata, sizeof(pdata));\r\nif (err)\r\ngoto error;\r\nerr = platform_device_add(pdev);\r\nif (err)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nplatform_device_put(pdev);\r\nreturn err;\r\n}\r\nstatic int __init mv64x60_i2c_device_setup(struct device_node *np, int id)\r\n{\r\nstruct resource r[2];\r\nstruct platform_device *pdev;\r\nstruct mv64xxx_i2c_pdata pdata;\r\nconst unsigned int *prop;\r\nint err;\r\nmemset(r, 0, sizeof(r));\r\nerr = of_address_to_resource(np, 0, &r[0]);\r\nif (err)\r\nreturn err;\r\nof_irq_to_resource(np, 0, &r[1]);\r\nmemset(&pdata, 0, sizeof(pdata));\r\npdata.freq_m = 8;\r\nprop = of_get_property(np, "freq_m", NULL);\r\nif (prop)\r\npdata.freq_m = *prop;\r\npdata.freq_n = 3;\r\nprop = of_get_property(np, "freq_n", NULL);\r\nif (prop)\r\npdata.freq_n = *prop;\r\npdata.timeout = 1000;\r\npdev = platform_device_alloc(MV64XXX_I2C_CTLR_NAME, id);\r\nif (!pdev)\r\nreturn -ENOMEM;\r\nerr = platform_device_add_resources(pdev, r, 2);\r\nif (err)\r\ngoto error;\r\nerr = platform_device_add_data(pdev, &pdata, sizeof(pdata));\r\nif (err)\r\ngoto error;\r\nerr = platform_device_add(pdev);\r\nif (err)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nplatform_device_put(pdev);\r\nreturn err;\r\n}\r\nstatic int __init mv64x60_wdt_device_setup(struct device_node *np, int id)\r\n{\r\nstruct resource r;\r\nstruct platform_device *pdev;\r\nstruct mv64x60_wdt_pdata pdata;\r\nconst unsigned int *prop;\r\nint err;\r\nerr = of_address_to_resource(np, 0, &r);\r\nif (err)\r\nreturn err;\r\nmemset(&pdata, 0, sizeof(pdata));\r\npdata.timeout = 10;\r\nnp = of_get_parent(np);\r\nif (!np)\r\nreturn -ENODEV;\r\nprop = of_get_property(np, "clock-frequency", NULL);\r\nof_node_put(np);\r\nif (!prop)\r\nreturn -ENODEV;\r\npdata.bus_clk = *prop / 1000000;\r\npdev = platform_device_alloc(MV64x60_WDT_NAME, id);\r\nif (!pdev)\r\nreturn -ENOMEM;\r\nerr = platform_device_add_resources(pdev, &r, 1);\r\nif (err)\r\ngoto error;\r\nerr = platform_device_add_data(pdev, &pdata, sizeof(pdata));\r\nif (err)\r\ngoto error;\r\nerr = platform_device_add(pdev);\r\nif (err)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nplatform_device_put(pdev);\r\nreturn err;\r\n}\r\nstatic int __init mv64x60_device_setup(void)\r\n{\r\nstruct device_node *np, *np2;\r\nstruct platform_device *pdev;\r\nint id, id2;\r\nint err;\r\nid = 0;\r\nfor_each_compatible_node(np, NULL, "marvell,mv64360-mpsc") {\r\nerr = mv64x60_mpsc_device_setup(np, id++);\r\nif (err)\r\nprintk(KERN_ERR "Failed to initialize MV64x60 "\r\n"serial device %s: error %d.\n",\r\nnp->full_name, err);\r\n}\r\nid = 0;\r\nid2 = 0;\r\nfor_each_compatible_node(np, NULL, "marvell,mv64360-eth-group") {\r\npdev = mv64x60_eth_register_shared_pdev(np, id++);\r\nif (IS_ERR(pdev)) {\r\nerr = PTR_ERR(pdev);\r\nprintk(KERN_ERR "Failed to initialize MV64x60 "\r\n"network block %s: error %d.\n",\r\nnp->full_name, err);\r\ncontinue;\r\n}\r\nfor_each_child_of_node(np, np2) {\r\nif (!of_device_is_compatible(np2,\r\n"marvell,mv64360-eth"))\r\ncontinue;\r\nerr = mv64x60_eth_device_setup(np2, id2++, pdev);\r\nif (err)\r\nprintk(KERN_ERR "Failed to initialize "\r\n"MV64x60 network device %s: "\r\n"error %d.\n",\r\nnp2->full_name, err);\r\n}\r\n}\r\nid = 0;\r\nfor_each_compatible_node(np, "i2c", "marvell,mv64360-i2c") {\r\nerr = mv64x60_i2c_device_setup(np, id++);\r\nif (err)\r\nprintk(KERN_ERR "Failed to initialize MV64x60 I2C "\r\n"bus %s: error %d.\n",\r\nnp->full_name, err);\r\n}\r\nnp = of_find_compatible_node(np, NULL, "marvell,mv64360-wdt");\r\nif (np) {\r\nif ((err = mv64x60_wdt_device_setup(np, id)))\r\nprintk(KERN_ERR "Failed to initialize MV64x60 "\r\n"Watchdog %s: error %d.\n",\r\nnp->full_name, err);\r\nof_node_put(np);\r\n}\r\nfor_each_compatible_node(np, NULL, "marvell,mv64360")\r\nof_platform_bus_probe(np, of_mv64x60_devices, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init mv64x60_add_mpsc_console(void)\r\n{\r\nstruct device_node *np = NULL;\r\nconst char *prop;\r\nprop = of_get_property(of_chosen, "linux,stdout-path", NULL);\r\nif (prop == NULL)\r\ngoto not_mpsc;\r\nnp = of_find_node_by_path(prop);\r\nif (!np)\r\ngoto not_mpsc;\r\nif (!of_device_is_compatible(np, "marvell,mv64360-mpsc"))\r\ngoto not_mpsc;\r\nprop = of_get_property(np, "cell-index", NULL);\r\nif (!prop)\r\ngoto not_mpsc;\r\nadd_preferred_console("ttyMM", *(int *)prop, NULL);\r\nnot_mpsc:\r\nreturn 0;\r\n}
