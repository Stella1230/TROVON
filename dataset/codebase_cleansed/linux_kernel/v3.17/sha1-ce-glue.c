static int sha1_init(struct shash_desc *desc)\r\n{\r\nstruct sha1_state *sctx = shash_desc_ctx(desc);\r\n*sctx = (struct sha1_state){\r\n.state = { SHA1_H0, SHA1_H1, SHA1_H2, SHA1_H3, SHA1_H4 },\r\n};\r\nreturn 0;\r\n}\r\nstatic int sha1_update(struct shash_desc *desc, const u8 *data,\r\nunsigned int len)\r\n{\r\nstruct sha1_state *sctx = shash_desc_ctx(desc);\r\nunsigned int partial = sctx->count % SHA1_BLOCK_SIZE;\r\nsctx->count += len;\r\nif ((partial + len) >= SHA1_BLOCK_SIZE) {\r\nint blocks;\r\nif (partial) {\r\nint p = SHA1_BLOCK_SIZE - partial;\r\nmemcpy(sctx->buffer + partial, data, p);\r\ndata += p;\r\nlen -= p;\r\n}\r\nblocks = len / SHA1_BLOCK_SIZE;\r\nlen %= SHA1_BLOCK_SIZE;\r\nkernel_neon_begin_partial(16);\r\nsha1_ce_transform(blocks, data, sctx->state,\r\npartial ? sctx->buffer : NULL, 0);\r\nkernel_neon_end();\r\ndata += blocks * SHA1_BLOCK_SIZE;\r\npartial = 0;\r\n}\r\nif (len)\r\nmemcpy(sctx->buffer + partial, data, len);\r\nreturn 0;\r\n}\r\nstatic int sha1_final(struct shash_desc *desc, u8 *out)\r\n{\r\nstatic const u8 padding[SHA1_BLOCK_SIZE] = { 0x80, };\r\nstruct sha1_state *sctx = shash_desc_ctx(desc);\r\n__be64 bits = cpu_to_be64(sctx->count << 3);\r\n__be32 *dst = (__be32 *)out;\r\nint i;\r\nu32 padlen = SHA1_BLOCK_SIZE\r\n- ((sctx->count + sizeof(bits)) % SHA1_BLOCK_SIZE);\r\nsha1_update(desc, padding, padlen);\r\nsha1_update(desc, (const u8 *)&bits, sizeof(bits));\r\nfor (i = 0; i < SHA1_DIGEST_SIZE / sizeof(__be32); i++)\r\nput_unaligned_be32(sctx->state[i], dst++);\r\n*sctx = (struct sha1_state){};\r\nreturn 0;\r\n}\r\nstatic int sha1_finup(struct shash_desc *desc, const u8 *data,\r\nunsigned int len, u8 *out)\r\n{\r\nstruct sha1_state *sctx = shash_desc_ctx(desc);\r\n__be32 *dst = (__be32 *)out;\r\nint blocks;\r\nint i;\r\nif (sctx->count || !len || (len % SHA1_BLOCK_SIZE)) {\r\nsha1_update(desc, data, len);\r\nreturn sha1_final(desc, out);\r\n}\r\nblocks = len / SHA1_BLOCK_SIZE;\r\nkernel_neon_begin_partial(16);\r\nsha1_ce_transform(blocks, data, sctx->state, NULL, len);\r\nkernel_neon_end();\r\nfor (i = 0; i < SHA1_DIGEST_SIZE / sizeof(__be32); i++)\r\nput_unaligned_be32(sctx->state[i], dst++);\r\n*sctx = (struct sha1_state){};\r\nreturn 0;\r\n}\r\nstatic int sha1_export(struct shash_desc *desc, void *out)\r\n{\r\nstruct sha1_state *sctx = shash_desc_ctx(desc);\r\nstruct sha1_state *dst = out;\r\n*dst = *sctx;\r\nreturn 0;\r\n}\r\nstatic int sha1_import(struct shash_desc *desc, const void *in)\r\n{\r\nstruct sha1_state *sctx = shash_desc_ctx(desc);\r\nstruct sha1_state const *src = in;\r\n*sctx = *src;\r\nreturn 0;\r\n}\r\nstatic int __init sha1_ce_mod_init(void)\r\n{\r\nreturn crypto_register_shash(&alg);\r\n}\r\nstatic void __exit sha1_ce_mod_fini(void)\r\n{\r\ncrypto_unregister_shash(&alg);\r\n}
