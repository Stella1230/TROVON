static void wusb_dev_free(struct wusb_dev *wusb_dev)\r\n{\r\nkfree(wusb_dev);\r\n}\r\nstatic struct wusb_dev *wusb_dev_alloc(struct wusbhc *wusbhc)\r\n{\r\nstruct wusb_dev *wusb_dev;\r\nwusb_dev = kzalloc(sizeof(*wusb_dev), GFP_KERNEL);\r\nif (wusb_dev == NULL)\r\ngoto err;\r\nwusb_dev->wusbhc = wusbhc;\r\nINIT_WORK(&wusb_dev->devconnect_acked_work, wusbhc_devconnect_acked_work);\r\nreturn wusb_dev;\r\nerr:\r\nwusb_dev_free(wusb_dev);\r\nreturn NULL;\r\n}\r\nstatic void wusbhc_fill_cack_ie(struct wusbhc *wusbhc)\r\n{\r\nunsigned cnt;\r\nstruct wusb_dev *dev_itr;\r\nstruct wuie_connect_ack *cack_ie;\r\ncack_ie = &wusbhc->cack_ie;\r\ncnt = 0;\r\nlist_for_each_entry(dev_itr, &wusbhc->cack_list, cack_node) {\r\ncack_ie->blk[cnt].CDID = dev_itr->cdid;\r\ncack_ie->blk[cnt].bDeviceAddress = dev_itr->addr;\r\nif (++cnt >= WUIE_ELT_MAX)\r\nbreak;\r\n}\r\ncack_ie->hdr.bLength = sizeof(cack_ie->hdr)\r\n+ cnt * sizeof(cack_ie->blk[0]);\r\n}\r\nstatic struct wusb_dev *wusbhc_cack_add(struct wusbhc *wusbhc,\r\nstruct wusb_dn_connect *dnc,\r\nconst char *pr_cdid, u8 port_idx)\r\n{\r\nstruct device *dev = wusbhc->dev;\r\nstruct wusb_dev *wusb_dev;\r\nint new_connection = wusb_dn_connect_new_connection(dnc);\r\nu8 dev_addr;\r\nint result;\r\nlist_for_each_entry(wusb_dev, &wusbhc->cack_list, cack_node)\r\nif (!memcmp(&wusb_dev->cdid, &dnc->CDID,\r\nsizeof(wusb_dev->cdid)))\r\nreturn wusb_dev;\r\nwusb_dev = wusb_dev_alloc(wusbhc);\r\nif (wusb_dev == NULL)\r\nreturn NULL;\r\nwusb_dev_init(wusb_dev);\r\nwusb_dev->cdid = dnc->CDID;\r\nwusb_dev->port_idx = port_idx;\r\nbitmap_fill(wusb_dev->availability.bm, UWB_NUM_MAS);\r\nif (1 && new_connection == 0)\r\nnew_connection = 1;\r\nif (new_connection) {\r\ndev_addr = (port_idx + 2) | WUSB_DEV_ADDR_UNAUTH;\r\ndev_info(dev, "Connecting new WUSB device to address %u, "\r\n"port %u\n", dev_addr, port_idx);\r\nresult = wusb_set_dev_addr(wusbhc, wusb_dev, dev_addr);\r\nif (result < 0)\r\nreturn NULL;\r\n}\r\nwusb_dev->entry_ts = jiffies;\r\nlist_add_tail(&wusb_dev->cack_node, &wusbhc->cack_list);\r\nwusbhc->cack_count++;\r\nwusbhc_fill_cack_ie(wusbhc);\r\nreturn wusb_dev;\r\n}\r\nstatic void wusbhc_cack_rm(struct wusbhc *wusbhc, struct wusb_dev *wusb_dev)\r\n{\r\nlist_del_init(&wusb_dev->cack_node);\r\nwusbhc->cack_count--;\r\nwusbhc_fill_cack_ie(wusbhc);\r\n}\r\nstatic\r\nvoid wusbhc_devconnect_acked(struct wusbhc *wusbhc, struct wusb_dev *wusb_dev)\r\n{\r\nwusbhc_cack_rm(wusbhc, wusb_dev);\r\nif (wusbhc->cack_count)\r\nwusbhc_mmcie_set(wusbhc, 0, 0, &wusbhc->cack_ie.hdr);\r\nelse\r\nwusbhc_mmcie_rm(wusbhc, &wusbhc->cack_ie.hdr);\r\n}\r\nstatic void wusbhc_devconnect_acked_work(struct work_struct *work)\r\n{\r\nstruct wusb_dev *wusb_dev = container_of(work, struct wusb_dev,\r\ndevconnect_acked_work);\r\nstruct wusbhc *wusbhc = wusb_dev->wusbhc;\r\nmutex_lock(&wusbhc->mutex);\r\nwusbhc_devconnect_acked(wusbhc, wusb_dev);\r\nmutex_unlock(&wusbhc->mutex);\r\nwusb_dev_put(wusb_dev);\r\n}\r\nstatic\r\nvoid wusbhc_devconnect_ack(struct wusbhc *wusbhc, struct wusb_dn_connect *dnc,\r\nconst char *pr_cdid)\r\n{\r\nint result;\r\nstruct device *dev = wusbhc->dev;\r\nstruct wusb_dev *wusb_dev;\r\nstruct wusb_port *port;\r\nunsigned idx;\r\nmutex_lock(&wusbhc->mutex);\r\nfor (idx = 0; idx < wusbhc->ports_max; idx++) {\r\nport = wusb_port_by_idx(wusbhc, idx);\r\nif (port->wusb_dev\r\n&& memcmp(&dnc->CDID, &port->wusb_dev->cdid, sizeof(dnc->CDID)) == 0)\r\ngoto error_unlock;\r\n}\r\nfor (idx = 0; idx < wusbhc->ports_max; idx++) {\r\nport = wusb_port_by_idx(wusbhc, idx);\r\nif ((port->status & USB_PORT_STAT_POWER)\r\n&& !(port->status & USB_PORT_STAT_CONNECTION))\r\nbreak;\r\n}\r\nif (idx >= wusbhc->ports_max) {\r\ndev_err(dev, "Host controller can't connect more devices "\r\n"(%u already connected); device %s rejected\n",\r\nwusbhc->ports_max, pr_cdid);\r\ngoto error_unlock;\r\n}\r\nwusbhc->set_ptk(wusbhc, idx, 0, NULL, 0);\r\nwusb_dev = wusbhc_cack_add(wusbhc, dnc, pr_cdid, idx);\r\nif (wusb_dev == NULL)\r\ngoto error_unlock;\r\nresult = wusbhc_mmcie_set(wusbhc, 0, 0, &wusbhc->cack_ie.hdr);\r\nif (result < 0)\r\ngoto error_unlock;\r\nmsleep(3);\r\nport->wusb_dev = wusb_dev;\r\nport->status |= USB_PORT_STAT_CONNECTION;\r\nport->change |= USB_PORT_STAT_C_CONNECTION;\r\nerror_unlock:\r\nmutex_unlock(&wusbhc->mutex);\r\nreturn;\r\n}\r\nstatic void __wusbhc_dev_disconnect(struct wusbhc *wusbhc,\r\nstruct wusb_port *port)\r\n{\r\nstruct wusb_dev *wusb_dev = port->wusb_dev;\r\nport->status &= ~(USB_PORT_STAT_CONNECTION | USB_PORT_STAT_ENABLE\r\n| USB_PORT_STAT_SUSPEND | USB_PORT_STAT_RESET\r\n| USB_PORT_STAT_LOW_SPEED | USB_PORT_STAT_HIGH_SPEED);\r\nport->change |= USB_PORT_STAT_C_CONNECTION | USB_PORT_STAT_C_ENABLE;\r\nif (wusb_dev) {\r\ndev_dbg(wusbhc->dev, "disconnecting device from port %d\n", wusb_dev->port_idx);\r\nif (!list_empty(&wusb_dev->cack_node))\r\nlist_del_init(&wusb_dev->cack_node);\r\nwusb_dev_put(wusb_dev);\r\n}\r\nport->wusb_dev = NULL;\r\nif (wusbhc->active)\r\nwusbhc_gtk_rekey(wusbhc);\r\n}\r\nstatic void __wusbhc_keep_alive(struct wusbhc *wusbhc)\r\n{\r\nstruct device *dev = wusbhc->dev;\r\nunsigned cnt;\r\nstruct wusb_dev *wusb_dev;\r\nstruct wusb_port *wusb_port;\r\nstruct wuie_keep_alive *ie = &wusbhc->keep_alive_ie;\r\nunsigned keep_alives, old_keep_alives;\r\nold_keep_alives = ie->hdr.bLength - sizeof(ie->hdr);\r\nkeep_alives = 0;\r\nfor (cnt = 0;\r\nkeep_alives < WUIE_ELT_MAX && cnt < wusbhc->ports_max;\r\ncnt++) {\r\nunsigned tt = msecs_to_jiffies(wusbhc->trust_timeout);\r\nwusb_port = wusb_port_by_idx(wusbhc, cnt);\r\nwusb_dev = wusb_port->wusb_dev;\r\nif (wusb_dev == NULL)\r\ncontinue;\r\nif (wusb_dev->usb_dev == NULL)\r\ncontinue;\r\nif (time_after(jiffies, wusb_dev->entry_ts + tt)) {\r\ndev_err(dev, "KEEPALIVE: device %u timed out\n",\r\nwusb_dev->addr);\r\n__wusbhc_dev_disconnect(wusbhc, wusb_port);\r\n} else if (time_after(jiffies, wusb_dev->entry_ts + tt/3)) {\r\nie->bDeviceAddress[keep_alives++] = wusb_dev->addr;\r\n}\r\n}\r\nif (keep_alives & 0x1)\r\nie->bDeviceAddress[keep_alives++] = 0x7f;\r\nie->hdr.bLength = sizeof(ie->hdr) +\r\nkeep_alives*sizeof(ie->bDeviceAddress[0]);\r\nif (keep_alives > 0)\r\nwusbhc_mmcie_set(wusbhc, 10, 5, &ie->hdr);\r\nelse if (old_keep_alives != 0)\r\nwusbhc_mmcie_rm(wusbhc, &ie->hdr);\r\n}\r\nstatic void wusbhc_keep_alive_run(struct work_struct *ws)\r\n{\r\nstruct delayed_work *dw = to_delayed_work(ws);\r\nstruct wusbhc *wusbhc = container_of(dw, struct wusbhc, keep_alive_timer);\r\nmutex_lock(&wusbhc->mutex);\r\n__wusbhc_keep_alive(wusbhc);\r\nmutex_unlock(&wusbhc->mutex);\r\nqueue_delayed_work(wusbd, &wusbhc->keep_alive_timer,\r\nmsecs_to_jiffies(wusbhc->trust_timeout / 2));\r\n}\r\nstatic struct wusb_dev *wusbhc_find_dev_by_addr(struct wusbhc *wusbhc, u8 addr)\r\n{\r\nint p;\r\nif (addr == 0xff)\r\nreturn NULL;\r\nif (addr > 0) {\r\nint port = (addr & ~0x80) - 2;\r\nif (port < 0 || port >= wusbhc->ports_max)\r\nreturn NULL;\r\nreturn wusb_port_by_idx(wusbhc, port)->wusb_dev;\r\n}\r\nfor (p = 0; p < wusbhc->ports_max; p++) {\r\nstruct wusb_dev *wusb_dev = wusb_port_by_idx(wusbhc, p)->wusb_dev;\r\nif (wusb_dev && wusb_dev->addr == addr)\r\nreturn wusb_dev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void wusbhc_handle_dn_alive(struct wusbhc *wusbhc, u8 srcaddr)\r\n{\r\nstruct wusb_dev *wusb_dev;\r\nmutex_lock(&wusbhc->mutex);\r\nwusb_dev = wusbhc_find_dev_by_addr(wusbhc, srcaddr);\r\nif (wusb_dev == NULL) {\r\ndev_dbg(wusbhc->dev, "ignoring DN_Alive from unconnected device %02x\n",\r\nsrcaddr);\r\n} else {\r\nwusb_dev->entry_ts = jiffies;\r\n__wusbhc_keep_alive(wusbhc);\r\n}\r\nmutex_unlock(&wusbhc->mutex);\r\n}\r\nstatic void wusbhc_handle_dn_connect(struct wusbhc *wusbhc,\r\nstruct wusb_dn_hdr *dn_hdr,\r\nsize_t size)\r\n{\r\nstruct device *dev = wusbhc->dev;\r\nstruct wusb_dn_connect *dnc;\r\nchar pr_cdid[WUSB_CKHDID_STRSIZE];\r\nstatic const char *beacon_behaviour[] = {\r\n"reserved",\r\n"self-beacon",\r\n"directed-beacon",\r\n"no-beacon"\r\n};\r\nif (size < sizeof(*dnc)) {\r\ndev_err(dev, "DN CONNECT: short notification (%zu < %zu)\n",\r\nsize, sizeof(*dnc));\r\nreturn;\r\n}\r\ndnc = container_of(dn_hdr, struct wusb_dn_connect, hdr);\r\nckhdid_printf(pr_cdid, sizeof(pr_cdid), &dnc->CDID);\r\ndev_info(dev, "DN CONNECT: device %s @ %x (%s) wants to %s\n",\r\npr_cdid,\r\nwusb_dn_connect_prev_dev_addr(dnc),\r\nbeacon_behaviour[wusb_dn_connect_beacon_behavior(dnc)],\r\nwusb_dn_connect_new_connection(dnc) ? "connect" : "reconnect");\r\nwusbhc_devconnect_ack(wusbhc, dnc, pr_cdid);\r\n}\r\nstatic void wusbhc_handle_dn_disconnect(struct wusbhc *wusbhc, u8 srcaddr)\r\n{\r\nstruct device *dev = wusbhc->dev;\r\nstruct wusb_dev *wusb_dev;\r\nmutex_lock(&wusbhc->mutex);\r\nwusb_dev = wusbhc_find_dev_by_addr(wusbhc, srcaddr);\r\nif (wusb_dev == NULL) {\r\ndev_dbg(dev, "ignoring DN DISCONNECT from unconnected device %02x\n",\r\nsrcaddr);\r\n} else {\r\ndev_info(dev, "DN DISCONNECT: device 0x%02x going down\n",\r\nwusb_dev->addr);\r\n__wusbhc_dev_disconnect(wusbhc, wusb_port_by_idx(wusbhc,\r\nwusb_dev->port_idx));\r\n}\r\nmutex_unlock(&wusbhc->mutex);\r\n}\r\nvoid wusbhc_handle_dn(struct wusbhc *wusbhc, u8 srcaddr,\r\nstruct wusb_dn_hdr *dn_hdr, size_t size)\r\n{\r\nstruct device *dev = wusbhc->dev;\r\nif (size < sizeof(struct wusb_dn_hdr)) {\r\ndev_err(dev, "DN data shorter than DN header (%d < %d)\n",\r\n(int)size, (int)sizeof(struct wusb_dn_hdr));\r\nreturn;\r\n}\r\nswitch (dn_hdr->bType) {\r\ncase WUSB_DN_CONNECT:\r\nwusbhc_handle_dn_connect(wusbhc, dn_hdr, size);\r\nbreak;\r\ncase WUSB_DN_ALIVE:\r\nwusbhc_handle_dn_alive(wusbhc, srcaddr);\r\nbreak;\r\ncase WUSB_DN_DISCONNECT:\r\nwusbhc_handle_dn_disconnect(wusbhc, srcaddr);\r\nbreak;\r\ncase WUSB_DN_MASAVAILCHANGED:\r\ncase WUSB_DN_RWAKE:\r\ncase WUSB_DN_SLEEP:\r\nbreak;\r\ncase WUSB_DN_EPRDY:\r\nbreak;\r\ndefault:\r\ndev_warn(dev, "unknown DN %u (%d octets) from %u\n",\r\ndn_hdr->bType, (int)size, srcaddr);\r\n}\r\n}\r\nvoid __wusbhc_dev_disable(struct wusbhc *wusbhc, u8 port_idx)\r\n{\r\nint result;\r\nstruct device *dev = wusbhc->dev;\r\nstruct wusb_dev *wusb_dev;\r\nstruct wuie_disconnect *ie;\r\nwusb_dev = wusb_port_by_idx(wusbhc, port_idx)->wusb_dev;\r\nif (wusb_dev == NULL) {\r\ndev_dbg(dev, "DISCONNECT: no device at port %u, ignoring\n",\r\nport_idx);\r\nreturn;\r\n}\r\n__wusbhc_dev_disconnect(wusbhc, wusb_port_by_idx(wusbhc, port_idx));\r\nie = kzalloc(sizeof(*ie), GFP_KERNEL);\r\nif (ie == NULL)\r\nreturn;\r\nie->hdr.bLength = sizeof(*ie);\r\nie->hdr.bIEIdentifier = WUIE_ID_DEVICE_DISCONNECT;\r\nie->bDeviceAddress = wusb_dev->addr;\r\nresult = wusbhc_mmcie_set(wusbhc, 0, 0, &ie->hdr);\r\nif (result < 0)\r\ndev_err(dev, "DISCONNECT: can't set MMC: %d\n", result);\r\nelse {\r\nmsleep(7*4);\r\nwusbhc_mmcie_rm(wusbhc, &ie->hdr);\r\n}\r\nkfree(ie);\r\n}\r\nstatic int wusb_dev_bos_grok(struct usb_device *usb_dev,\r\nstruct wusb_dev *wusb_dev,\r\nstruct usb_bos_descriptor *bos, size_t desc_size)\r\n{\r\nssize_t result;\r\nstruct device *dev = &usb_dev->dev;\r\nvoid *itr, *top;\r\nitr = (void *)bos + sizeof(*bos);\r\ntop = itr + desc_size - sizeof(*bos);\r\nwhile (itr < top) {\r\nstruct usb_dev_cap_header *cap_hdr = itr;\r\nsize_t cap_size;\r\nu8 cap_type;\r\nif (top - itr < sizeof(*cap_hdr)) {\r\ndev_err(dev, "Device BUG? premature end of BOS header "\r\n"data [offset 0x%02x]: only %zu bytes left\n",\r\n(int)(itr - (void *)bos), top - itr);\r\nresult = -ENOSPC;\r\ngoto error_bad_cap;\r\n}\r\ncap_size = cap_hdr->bLength;\r\ncap_type = cap_hdr->bDevCapabilityType;\r\nif (cap_size == 0)\r\nbreak;\r\nif (cap_size > top - itr) {\r\ndev_err(dev, "Device BUG? premature end of BOS data "\r\n"[offset 0x%02x cap %02x %zu bytes]: "\r\n"only %zu bytes left\n",\r\n(int)(itr - (void *)bos),\r\ncap_type, cap_size, top - itr);\r\nresult = -EBADF;\r\ngoto error_bad_cap;\r\n}\r\nswitch (cap_type) {\r\ncase USB_CAP_TYPE_WIRELESS_USB:\r\nif (cap_size != sizeof(*wusb_dev->wusb_cap_descr))\r\ndev_err(dev, "Device BUG? WUSB Capability "\r\n"descriptor is %zu bytes vs %zu "\r\n"needed\n", cap_size,\r\nsizeof(*wusb_dev->wusb_cap_descr));\r\nelse\r\nwusb_dev->wusb_cap_descr = itr;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "BUG? Unknown BOS capability 0x%02x "\r\n"(%zu bytes) at offset 0x%02x\n", cap_type,\r\ncap_size, (int)(itr - (void *)bos));\r\n}\r\nitr += cap_size;\r\n}\r\nresult = 0;\r\nerror_bad_cap:\r\nreturn result;\r\n}\r\nstatic int wusb_dev_bos_add(struct usb_device *usb_dev,\r\nstruct wusb_dev *wusb_dev)\r\n{\r\nssize_t result;\r\nstruct device *dev = &usb_dev->dev;\r\nstruct usb_bos_descriptor *bos;\r\nsize_t alloc_size = 32, desc_size = 4;\r\nbos = kmalloc(alloc_size, GFP_KERNEL);\r\nif (bos == NULL)\r\nreturn -ENOMEM;\r\nresult = usb_get_descriptor(usb_dev, USB_DT_BOS, 0, bos, desc_size);\r\nif (result < 4) {\r\ndev_err(dev, "Can't get BOS descriptor or too short: %zd\n",\r\nresult);\r\ngoto error_get_descriptor;\r\n}\r\ndesc_size = le16_to_cpu(bos->wTotalLength);\r\nif (desc_size >= alloc_size) {\r\nkfree(bos);\r\nalloc_size = desc_size;\r\nbos = kmalloc(alloc_size, GFP_KERNEL);\r\nif (bos == NULL)\r\nreturn -ENOMEM;\r\n}\r\nresult = usb_get_descriptor(usb_dev, USB_DT_BOS, 0, bos, desc_size);\r\nif (result < 0 || result != desc_size) {\r\ndev_err(dev, "Can't get BOS descriptor or too short (need "\r\n"%zu bytes): %zd\n", desc_size, result);\r\ngoto error_get_descriptor;\r\n}\r\nif (result < sizeof(*bos)\r\n|| le16_to_cpu(bos->wTotalLength) != desc_size) {\r\ndev_err(dev, "Can't get BOS descriptor or too short (need "\r\n"%zu bytes): %zd\n", desc_size, result);\r\ngoto error_get_descriptor;\r\n}\r\nresult = wusb_dev_bos_grok(usb_dev, wusb_dev, bos, result);\r\nif (result < 0)\r\ngoto error_bad_bos;\r\nwusb_dev->bos = bos;\r\nreturn 0;\r\nerror_bad_bos:\r\nerror_get_descriptor:\r\nkfree(bos);\r\nwusb_dev->wusb_cap_descr = NULL;\r\nreturn result;\r\n}\r\nstatic void wusb_dev_bos_rm(struct wusb_dev *wusb_dev)\r\n{\r\nkfree(wusb_dev->bos);\r\nwusb_dev->wusb_cap_descr = NULL;\r\n}\r\nstatic void wusb_dev_add_ncb(struct usb_device *usb_dev)\r\n{\r\nint result = 0;\r\nstruct wusb_dev *wusb_dev;\r\nstruct wusbhc *wusbhc;\r\nstruct device *dev = &usb_dev->dev;\r\nu8 port_idx;\r\nif (usb_dev->wusb == 0 || usb_dev->devnum == 1)\r\nreturn;\r\nusb_set_device_state(usb_dev, USB_STATE_UNAUTHENTICATED);\r\nwusbhc = wusbhc_get_by_usb_dev(usb_dev);\r\nif (wusbhc == NULL)\r\ngoto error_nodev;\r\nmutex_lock(&wusbhc->mutex);\r\nwusb_dev = __wusb_dev_get_by_usb_dev(wusbhc, usb_dev);\r\nport_idx = wusb_port_no_to_idx(usb_dev->portnum);\r\nmutex_unlock(&wusbhc->mutex);\r\nif (wusb_dev == NULL)\r\ngoto error_nodev;\r\nwusb_dev->usb_dev = usb_get_dev(usb_dev);\r\nusb_dev->wusb_dev = wusb_dev_get(wusb_dev);\r\nresult = wusb_dev_sec_add(wusbhc, usb_dev, wusb_dev);\r\nif (result < 0) {\r\ndev_err(dev, "Cannot enable security: %d\n", result);\r\ngoto error_sec_add;\r\n}\r\nresult = wusb_dev_bos_add(usb_dev, wusb_dev);\r\nif (result < 0) {\r\ndev_err(dev, "Cannot get BOS descriptors: %d\n", result);\r\ngoto error_bos_add;\r\n}\r\nresult = wusb_dev_sysfs_add(wusbhc, usb_dev, wusb_dev);\r\nif (result < 0)\r\ngoto error_add_sysfs;\r\nout:\r\nwusb_dev_put(wusb_dev);\r\nwusbhc_put(wusbhc);\r\nerror_nodev:\r\nreturn;\r\nwusb_dev_sysfs_rm(wusb_dev);\r\nerror_add_sysfs:\r\nwusb_dev_bos_rm(wusb_dev);\r\nerror_bos_add:\r\nwusb_dev_sec_rm(wusb_dev);\r\nerror_sec_add:\r\nmutex_lock(&wusbhc->mutex);\r\n__wusbhc_dev_disconnect(wusbhc, wusb_port_by_idx(wusbhc, port_idx));\r\nmutex_unlock(&wusbhc->mutex);\r\ngoto out;\r\n}\r\nstatic void wusb_dev_rm_ncb(struct usb_device *usb_dev)\r\n{\r\nstruct wusb_dev *wusb_dev = usb_dev->wusb_dev;\r\nif (usb_dev->wusb == 0 || usb_dev->devnum == 1)\r\nreturn;\r\nwusb_dev_sysfs_rm(wusb_dev);\r\nwusb_dev_bos_rm(wusb_dev);\r\nwusb_dev_sec_rm(wusb_dev);\r\nwusb_dev->usb_dev = NULL;\r\nusb_dev->wusb_dev = NULL;\r\nwusb_dev_put(wusb_dev);\r\nusb_put_dev(usb_dev);\r\n}\r\nint wusb_usb_ncb(struct notifier_block *nb, unsigned long val,\r\nvoid *priv)\r\n{\r\nint result = NOTIFY_OK;\r\nswitch (val) {\r\ncase USB_DEVICE_ADD:\r\nwusb_dev_add_ncb(priv);\r\nbreak;\r\ncase USB_DEVICE_REMOVE:\r\nwusb_dev_rm_ncb(priv);\r\nbreak;\r\ncase USB_BUS_ADD:\r\ncase USB_BUS_REMOVE:\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nresult = NOTIFY_BAD;\r\n}\r\nreturn result;\r\n}\r\nstruct wusb_dev *__wusb_dev_get_by_usb_dev(struct wusbhc *wusbhc,\r\nstruct usb_device *usb_dev)\r\n{\r\nstruct wusb_dev *wusb_dev;\r\nu8 port_idx;\r\nport_idx = wusb_port_no_to_idx(usb_dev->portnum);\r\nBUG_ON(port_idx > wusbhc->ports_max);\r\nwusb_dev = wusb_port_by_idx(wusbhc, port_idx)->wusb_dev;\r\nif (wusb_dev != NULL)\r\nwusb_dev_get(wusb_dev);\r\nreturn wusb_dev;\r\n}\r\nvoid wusb_dev_destroy(struct kref *_wusb_dev)\r\n{\r\nstruct wusb_dev *wusb_dev = container_of(_wusb_dev, struct wusb_dev, refcnt);\r\nlist_del_init(&wusb_dev->cack_node);\r\nwusb_dev_free(wusb_dev);\r\n}\r\nint wusbhc_devconnect_create(struct wusbhc *wusbhc)\r\n{\r\nwusbhc->keep_alive_ie.hdr.bIEIdentifier = WUIE_ID_KEEP_ALIVE;\r\nwusbhc->keep_alive_ie.hdr.bLength = sizeof(wusbhc->keep_alive_ie.hdr);\r\nINIT_DELAYED_WORK(&wusbhc->keep_alive_timer, wusbhc_keep_alive_run);\r\nwusbhc->cack_ie.hdr.bIEIdentifier = WUIE_ID_CONNECTACK;\r\nwusbhc->cack_ie.hdr.bLength = sizeof(wusbhc->cack_ie.hdr);\r\nINIT_LIST_HEAD(&wusbhc->cack_list);\r\nreturn 0;\r\n}\r\nvoid wusbhc_devconnect_destroy(struct wusbhc *wusbhc)\r\n{\r\n}\r\nint wusbhc_devconnect_start(struct wusbhc *wusbhc)\r\n{\r\nstruct device *dev = wusbhc->dev;\r\nstruct wuie_host_info *hi;\r\nint result;\r\nhi = kzalloc(sizeof(*hi), GFP_KERNEL);\r\nif (hi == NULL)\r\nreturn -ENOMEM;\r\nhi->hdr.bLength = sizeof(*hi);\r\nhi->hdr.bIEIdentifier = WUIE_ID_HOST_INFO;\r\nhi->attributes = cpu_to_le16((wusbhc->rsv->stream << 3) | WUIE_HI_CAP_ALL);\r\nhi->CHID = wusbhc->chid;\r\nresult = wusbhc_mmcie_set(wusbhc, 0, 0, &hi->hdr);\r\nif (result < 0) {\r\ndev_err(dev, "Cannot add Host Info MMCIE: %d\n", result);\r\ngoto error_mmcie_set;\r\n}\r\nwusbhc->wuie_host_info = hi;\r\nqueue_delayed_work(wusbd, &wusbhc->keep_alive_timer,\r\nmsecs_to_jiffies(wusbhc->trust_timeout / 2));\r\nreturn 0;\r\nerror_mmcie_set:\r\nkfree(hi);\r\nreturn result;\r\n}\r\nvoid wusbhc_devconnect_stop(struct wusbhc *wusbhc)\r\n{\r\nint i;\r\nmutex_lock(&wusbhc->mutex);\r\nfor (i = 0; i < wusbhc->ports_max; i++) {\r\nif (wusbhc->port[i].wusb_dev)\r\n__wusbhc_dev_disconnect(wusbhc, &wusbhc->port[i]);\r\n}\r\nmutex_unlock(&wusbhc->mutex);\r\ncancel_delayed_work_sync(&wusbhc->keep_alive_timer);\r\nwusbhc_mmcie_rm(wusbhc, &wusbhc->wuie_host_info->hdr);\r\nkfree(wusbhc->wuie_host_info);\r\nwusbhc->wuie_host_info = NULL;\r\n}\r\nint wusb_set_dev_addr(struct wusbhc *wusbhc, struct wusb_dev *wusb_dev, u8 addr)\r\n{\r\nint result;\r\nwusb_dev->addr = addr;\r\nresult = wusbhc->dev_info_set(wusbhc, wusb_dev);\r\nif (result < 0)\r\ndev_err(wusbhc->dev, "device %d: failed to set device "\r\n"address\n", wusb_dev->port_idx);\r\nelse\r\ndev_info(wusbhc->dev, "device %d: %s addr %u\n",\r\nwusb_dev->port_idx,\r\n(addr & WUSB_DEV_ADDR_UNAUTH) ? "unauth" : "auth",\r\nwusb_dev->addr);\r\nreturn result;\r\n}
