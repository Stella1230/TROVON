int tda18271_lookup_thermometer(struct dvb_frontend *fe)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nunsigned char *regs = priv->tda18271_regs;\r\nint val, i = 0;\r\nwhile (tda18271_thermometer[i].d < (regs[R_TM] & 0x0f)) {\r\nif (tda18271_thermometer[i + 1].d == 0)\r\nbreak;\r\ni++;\r\n}\r\nif ((regs[R_TM] & 0x20) == 0x20)\r\nval = tda18271_thermometer[i].r1;\r\nelse\r\nval = tda18271_thermometer[i].r0;\r\ntda_map("(%d) tm = %d\n", i, val);\r\nreturn val;\r\n}\r\nint tda18271_lookup_cid_target(struct dvb_frontend *fe,\r\nu32 *freq, u8 *cid_target, u16 *count_limit)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nint i = 0;\r\nwhile ((tda18271_cid_target[i].rfmax * 1000) < *freq) {\r\nif (tda18271_cid_target[i + 1].rfmax == 0)\r\nbreak;\r\ni++;\r\n}\r\n*cid_target = tda18271_cid_target[i].target;\r\n*count_limit = tda18271_cid_target[i].limit;\r\ntda_map("(%d) cid_target = %02x, count_limit = %d\n", i,\r\ntda18271_cid_target[i].target, tda18271_cid_target[i].limit);\r\nreturn 0;\r\n}\r\nint tda18271_lookup_rf_band(struct dvb_frontend *fe, u32 *freq, u8 *rf_band)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nstruct tda18271_rf_tracking_filter_cal *map = priv->rf_cal_state;\r\nint i = 0;\r\nwhile ((map[i].rfmax * 1000) < *freq) {\r\nif (tda18271_debug & DBG_ADV)\r\ntda_map("(%d) rfmax = %d < freq = %d, "\r\n"rf1_def = %d, rf2_def = %d, rf3_def = %d, "\r\n"rf1 = %d, rf2 = %d, rf3 = %d, "\r\n"rf_a1 = %d, rf_a2 = %d, "\r\n"rf_b1 = %d, rf_b2 = %d\n",\r\ni, map[i].rfmax * 1000, *freq,\r\nmap[i].rf1_def, map[i].rf2_def, map[i].rf3_def,\r\nmap[i].rf1, map[i].rf2, map[i].rf3,\r\nmap[i].rf_a1, map[i].rf_a2,\r\nmap[i].rf_b1, map[i].rf_b2);\r\nif (map[i].rfmax == 0)\r\nreturn -EINVAL;\r\ni++;\r\n}\r\nif (rf_band)\r\n*rf_band = map[i].rfband;\r\ntda_map("(%d) rf_band = %02x\n", i, map[i].rfband);\r\nreturn i;\r\n}\r\nint tda18271_lookup_pll_map(struct dvb_frontend *fe,\r\nenum tda18271_map_type map_type,\r\nu32 *freq, u8 *post_div, u8 *div)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nstruct tda18271_pll_map *map = NULL;\r\nunsigned int i = 0;\r\nchar *map_name;\r\nint ret = 0;\r\nBUG_ON(!priv->maps);\r\nswitch (map_type) {\r\ncase MAIN_PLL:\r\nmap = priv->maps->main_pll;\r\nmap_name = "main_pll";\r\nbreak;\r\ncase CAL_PLL:\r\nmap = priv->maps->cal_pll;\r\nmap_name = "cal_pll";\r\nbreak;\r\ndefault:\r\nmap_name = "undefined";\r\nbreak;\r\n}\r\nif (!map) {\r\ntda_warn("%s map is not set!\n", map_name);\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nwhile ((map[i].lomax * 1000) < *freq) {\r\nif (map[i + 1].lomax == 0) {\r\ntda_map("%s: frequency (%d) out of range\n",\r\nmap_name, *freq);\r\nret = -ERANGE;\r\nbreak;\r\n}\r\ni++;\r\n}\r\n*post_div = map[i].pd;\r\n*div = map[i].d;\r\ntda_map("(%d) %s: post div = 0x%02x, div = 0x%02x\n",\r\ni, map_name, *post_div, *div);\r\nfail:\r\nreturn ret;\r\n}\r\nint tda18271_lookup_map(struct dvb_frontend *fe,\r\nenum tda18271_map_type map_type,\r\nu32 *freq, u8 *val)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nstruct tda18271_map *map = NULL;\r\nunsigned int i = 0;\r\nchar *map_name;\r\nint ret = 0;\r\nBUG_ON(!priv->maps);\r\nswitch (map_type) {\r\ncase BP_FILTER:\r\nmap = priv->maps->bp_filter;\r\nmap_name = "bp_filter";\r\nbreak;\r\ncase RF_CAL_KMCO:\r\nmap = priv->maps->rf_cal_kmco;\r\nmap_name = "km";\r\nbreak;\r\ncase RF_BAND:\r\nmap = priv->maps->rf_band;\r\nmap_name = "rf_band";\r\nbreak;\r\ncase GAIN_TAPER:\r\nmap = priv->maps->gain_taper;\r\nmap_name = "gain_taper";\r\nbreak;\r\ncase RF_CAL:\r\nmap = priv->maps->rf_cal;\r\nmap_name = "rf_cal";\r\nbreak;\r\ncase IR_MEASURE:\r\nmap = priv->maps->ir_measure;\r\nmap_name = "ir_measure";\r\nbreak;\r\ncase RF_CAL_DC_OVER_DT:\r\nmap = priv->maps->rf_cal_dc_over_dt;\r\nmap_name = "rf_cal_dc_over_dt";\r\nbreak;\r\ndefault:\r\nmap_name = "undefined";\r\nbreak;\r\n}\r\nif (!map) {\r\ntda_warn("%s map is not set!\n", map_name);\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nwhile ((map[i].rfmax * 1000) < *freq) {\r\nif (map[i + 1].rfmax == 0) {\r\ntda_map("%s: frequency (%d) out of range\n",\r\nmap_name, *freq);\r\nret = -ERANGE;\r\nbreak;\r\n}\r\ni++;\r\n}\r\n*val = map[i].val;\r\ntda_map("(%d) %s: 0x%02x\n", i, map_name, *val);\r\nfail:\r\nreturn ret;\r\n}\r\nint tda18271_assign_map_layout(struct dvb_frontend *fe)\r\n{\r\nstruct tda18271_priv *priv = fe->tuner_priv;\r\nint ret = 0;\r\nswitch (priv->id) {\r\ncase TDA18271HDC1:\r\npriv->maps = &tda18271c1_map_layout;\r\npriv->std = tda18271c1_std_map;\r\nbreak;\r\ncase TDA18271HDC2:\r\npriv->maps = &tda18271c2_map_layout;\r\npriv->std = tda18271c2_std_map;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nmemcpy(priv->rf_cal_state, &tda18271_rf_band_template,\r\nsizeof(tda18271_rf_band_template));\r\nreturn ret;\r\n}
