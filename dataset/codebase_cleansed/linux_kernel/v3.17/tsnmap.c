struct sctp_tsnmap *sctp_tsnmap_init(struct sctp_tsnmap *map, __u16 len,\r\n__u32 initial_tsn, gfp_t gfp)\r\n{\r\nif (!map->tsn_map) {\r\nmap->tsn_map = kzalloc(len>>3, gfp);\r\nif (map->tsn_map == NULL)\r\nreturn NULL;\r\nmap->len = len;\r\n} else {\r\nbitmap_zero(map->tsn_map, map->len);\r\n}\r\nmap->base_tsn = initial_tsn;\r\nmap->cumulative_tsn_ack_point = initial_tsn - 1;\r\nmap->max_tsn_seen = map->cumulative_tsn_ack_point;\r\nmap->num_dup_tsns = 0;\r\nreturn map;\r\n}\r\nvoid sctp_tsnmap_free(struct sctp_tsnmap *map)\r\n{\r\nmap->len = 0;\r\nkfree(map->tsn_map);\r\n}\r\nint sctp_tsnmap_check(const struct sctp_tsnmap *map, __u32 tsn)\r\n{\r\nu32 gap;\r\nif (TSN_lte(tsn, map->cumulative_tsn_ack_point))\r\nreturn 1;\r\nif (!TSN_lt(tsn, map->base_tsn + SCTP_TSN_MAP_SIZE))\r\nreturn -1;\r\ngap = tsn - map->base_tsn;\r\nif (gap < map->len && test_bit(gap, map->tsn_map))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nint sctp_tsnmap_mark(struct sctp_tsnmap *map, __u32 tsn,\r\nstruct sctp_transport *trans)\r\n{\r\nu16 gap;\r\nif (TSN_lt(tsn, map->base_tsn))\r\nreturn 0;\r\ngap = tsn - map->base_tsn;\r\nif (gap >= map->len && !sctp_tsnmap_grow(map, gap + 1))\r\nreturn -ENOMEM;\r\nif (!sctp_tsnmap_has_gap(map) && gap == 0) {\r\nmap->max_tsn_seen++;\r\nmap->cumulative_tsn_ack_point++;\r\nif (trans)\r\ntrans->sack_generation =\r\ntrans->asoc->peer.sack_generation;\r\nmap->base_tsn++;\r\n} else {\r\nif (TSN_lt(map->max_tsn_seen, tsn))\r\nmap->max_tsn_seen = tsn;\r\nset_bit(gap, map->tsn_map);\r\nsctp_tsnmap_update(map);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sctp_tsnmap_iter_init(const struct sctp_tsnmap *map,\r\nstruct sctp_tsnmap_iter *iter)\r\n{\r\niter->start = map->cumulative_tsn_ack_point + 1;\r\n}\r\nstatic int sctp_tsnmap_next_gap_ack(const struct sctp_tsnmap *map,\r\nstruct sctp_tsnmap_iter *iter,\r\n__u16 *start, __u16 *end)\r\n{\r\nint ended = 0;\r\n__u16 start_ = 0, end_ = 0, offset;\r\nif (TSN_lte(map->max_tsn_seen, iter->start))\r\nreturn 0;\r\noffset = iter->start - map->base_tsn;\r\nsctp_tsnmap_find_gap_ack(map->tsn_map, offset, map->len,\r\n&start_, &end_);\r\nif (start_ && !end_)\r\nend_ = map->len - 1;\r\nif (end_) {\r\n*start = start_ + 1;\r\n*end = end_ + 1;\r\niter->start = map->cumulative_tsn_ack_point + *end + 1;\r\nended = 1;\r\n}\r\nreturn ended;\r\n}\r\nvoid sctp_tsnmap_skip(struct sctp_tsnmap *map, __u32 tsn)\r\n{\r\nu32 gap;\r\nif (TSN_lt(tsn, map->base_tsn))\r\nreturn;\r\nif (!TSN_lt(tsn, map->base_tsn + SCTP_TSN_MAP_SIZE))\r\nreturn;\r\nif (TSN_lt(map->max_tsn_seen, tsn))\r\nmap->max_tsn_seen = tsn;\r\ngap = tsn - map->base_tsn + 1;\r\nmap->base_tsn += gap;\r\nmap->cumulative_tsn_ack_point += gap;\r\nif (gap >= map->len) {\r\nbitmap_zero(map->tsn_map, map->len);\r\n} else {\r\nbitmap_shift_right(map->tsn_map, map->tsn_map, gap, map->len);\r\nsctp_tsnmap_update(map);\r\n}\r\n}\r\nstatic void sctp_tsnmap_update(struct sctp_tsnmap *map)\r\n{\r\nu16 len;\r\nunsigned long zero_bit;\r\nlen = map->max_tsn_seen - map->cumulative_tsn_ack_point;\r\nzero_bit = find_first_zero_bit(map->tsn_map, len);\r\nif (!zero_bit)\r\nreturn;\r\nmap->base_tsn += zero_bit;\r\nmap->cumulative_tsn_ack_point += zero_bit;\r\nbitmap_shift_right(map->tsn_map, map->tsn_map, zero_bit, map->len);\r\n}\r\n__u16 sctp_tsnmap_pending(struct sctp_tsnmap *map)\r\n{\r\n__u32 cum_tsn = map->cumulative_tsn_ack_point;\r\n__u32 max_tsn = map->max_tsn_seen;\r\n__u32 base_tsn = map->base_tsn;\r\n__u16 pending_data;\r\nu32 gap;\r\npending_data = max_tsn - cum_tsn;\r\ngap = max_tsn - base_tsn;\r\nif (gap == 0 || gap >= map->len)\r\ngoto out;\r\npending_data -= bitmap_weight(map->tsn_map, gap + 1);\r\nout:\r\nreturn pending_data;\r\n}\r\nstatic void sctp_tsnmap_find_gap_ack(unsigned long *map, __u16 off,\r\n__u16 len, __u16 *start, __u16 *end)\r\n{\r\nint i = off;\r\ni = find_next_bit(map, len, off);\r\nif (i < len)\r\n*start = i;\r\nif (*start) {\r\ni = find_next_zero_bit(map, len, i);\r\nif (i < len)\r\n*end = i - 1;\r\n}\r\n}\r\nvoid sctp_tsnmap_renege(struct sctp_tsnmap *map, __u32 tsn)\r\n{\r\nu32 gap;\r\nif (TSN_lt(tsn, map->base_tsn))\r\nreturn;\r\nif (!TSN_lt(tsn, map->base_tsn + map->len))\r\nreturn;\r\ngap = tsn - map->base_tsn;\r\nclear_bit(gap, map->tsn_map);\r\n}\r\n__u16 sctp_tsnmap_num_gabs(struct sctp_tsnmap *map,\r\nstruct sctp_gap_ack_block *gabs)\r\n{\r\nstruct sctp_tsnmap_iter iter;\r\nint ngaps = 0;\r\nif (sctp_tsnmap_has_gap(map)) {\r\n__u16 start = 0, end = 0;\r\nsctp_tsnmap_iter_init(map, &iter);\r\nwhile (sctp_tsnmap_next_gap_ack(map, &iter,\r\n&start,\r\n&end)) {\r\ngabs[ngaps].start = htons(start);\r\ngabs[ngaps].end = htons(end);\r\nngaps++;\r\nif (ngaps >= SCTP_MAX_GABS)\r\nbreak;\r\n}\r\n}\r\nreturn ngaps;\r\n}\r\nstatic int sctp_tsnmap_grow(struct sctp_tsnmap *map, u16 size)\r\n{\r\nunsigned long *new;\r\nunsigned long inc;\r\nu16 len;\r\nif (size > SCTP_TSN_MAP_SIZE)\r\nreturn 0;\r\ninc = ALIGN((size - map->len), BITS_PER_LONG) + SCTP_TSN_MAP_INCREMENT;\r\nlen = min_t(u16, map->len + inc, SCTP_TSN_MAP_SIZE);\r\nnew = kzalloc(len>>3, GFP_ATOMIC);\r\nif (!new)\r\nreturn 0;\r\nbitmap_copy(new, map->tsn_map,\r\nmap->max_tsn_seen - map->cumulative_tsn_ack_point);\r\nkfree(map->tsn_map);\r\nmap->tsn_map = new;\r\nmap->len = len;\r\nreturn 1;\r\n}
