static void arcfour_init(struct arc4context *parc4ctx, u8 *key, u32 key_len)\r\n{\r\nu32 t, u;\r\nu32 keyindex;\r\nu32 stateindex;\r\nu8 *state;\r\nu32 counter;\r\nstate = parc4ctx->state;\r\nparc4ctx->x = 0;\r\nparc4ctx->y = 0;\r\nfor (counter = 0; counter < 256; counter++)\r\nstate[counter] = (u8)counter;\r\nkeyindex = 0;\r\nstateindex = 0;\r\nfor (counter = 0; counter < 256; counter++) {\r\nt = state[counter];\r\nstateindex = (stateindex + key[keyindex] + t) & 0xff;\r\nu = state[stateindex];\r\nstate[stateindex] = (u8)t;\r\nstate[counter] = (u8)u;\r\nif (++keyindex >= key_len)\r\nkeyindex = 0;\r\n}\r\n}\r\nstatic u32 arcfour_byte(struct arc4context *parc4ctx)\r\n{\r\nu32 x;\r\nu32 y;\r\nu32 sx, sy;\r\nu8 *state;\r\nstate = parc4ctx->state;\r\nx = (parc4ctx->x + 1) & 0xff;\r\nsx = state[x];\r\ny = (sx + parc4ctx->y) & 0xff;\r\nsy = state[y];\r\nparc4ctx->x = x;\r\nparc4ctx->y = y;\r\nstate[y] = (u8)sx;\r\nstate[x] = (u8)sy;\r\nreturn state[(sx + sy) & 0xff];\r\n}\r\nstatic void arcfour_encrypt(struct arc4context *parc4ctx,\r\nu8 *dest, u8 *src, u32 len)\r\n{\r\nu32 i;\r\nfor (i = 0; i < len; i++)\r\ndest[i] = src[i] ^ (unsigned char)arcfour_byte(parc4ctx);\r\n}\r\nstatic u8 crc32_reverseBit(u8 data)\r\n{\r\nreturn ((u8)(data << 7) & 0x80) | ((data << 5) & 0x40) | ((data << 3)\r\n& 0x20) | ((data << 1) & 0x10) | ((data >> 1) & 0x08) |\r\n((data >> 3) & 0x04) | ((data >> 5) & 0x02) | ((data >> 7) &\r\n0x01);\r\n}\r\nstatic void crc32_init(void)\r\n{\r\nif (bcrc32initialized == 1)\r\nreturn;\r\nelse {\r\nsint i, j;\r\nu32 c;\r\nu8 *p = (u8 *)&c, *p1;\r\nu8 k;\r\nc = 0x12340000;\r\nfor (i = 0; i < 256; ++i) {\r\nk = crc32_reverseBit((u8)i);\r\nfor (c = ((u32)k) << 24, j = 8; j > 0; --j)\r\nc = c & 0x80000000 ? (c << 1) ^ CRC32_POLY :\r\n(c << 1);\r\np1 = (u8 *)&crc32_table[i];\r\np1[0] = crc32_reverseBit(p[3]);\r\np1[1] = crc32_reverseBit(p[2]);\r\np1[2] = crc32_reverseBit(p[1]);\r\np1[3] = crc32_reverseBit(p[0]);\r\n}\r\nbcrc32initialized = 1;\r\n}\r\n}\r\nstatic u32 getcrc32(u8 *buf, u32 len)\r\n{\r\nu8 *p;\r\nu32 crc;\r\nif (bcrc32initialized == 0)\r\ncrc32_init();\r\ncrc = 0xffffffff;\r\nfor (p = buf; len > 0; ++p, --len)\r\ncrc = crc32_table[(crc ^ *p) & 0xff] ^ (crc >> 8);\r\nreturn ~crc;\r\n}\r\nvoid r8712_wep_encrypt(struct _adapter *padapter, u8 *pxmitframe)\r\n{\r\nunsigned char crc[4];\r\nstruct arc4context mycontext;\r\nu32 curfragnum, length, keylength;\r\nu8 *pframe, *payload, *iv;\r\nu8 wepkey[16];\r\nstruct pkt_attrib *pattrib = &((struct xmit_frame *)\r\npxmitframe)->attrib;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nif (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)\r\nreturn;\r\npframe = ((struct xmit_frame *)pxmitframe)->buf_addr+TXDESC_OFFSET;\r\nif ((pattrib->encrypt == _WEP40_) || (pattrib->encrypt == _WEP104_)) {\r\nkeylength = psecuritypriv->DefKeylen[psecuritypriv->\r\nPrivacyKeyIndex];\r\nfor (curfragnum = 0; curfragnum < pattrib->nr_frags;\r\ncurfragnum++) {\r\niv = pframe+pattrib->hdrlen;\r\nmemcpy(&wepkey[0], iv, 3);\r\nmemcpy(&wepkey[3], &psecuritypriv->DefKey[\r\npsecuritypriv->PrivacyKeyIndex].skey[0],\r\nkeylength);\r\npayload = pframe+pattrib->iv_len+pattrib->hdrlen;\r\nif ((curfragnum + 1) == pattrib->nr_frags) {\r\nlength = pattrib->last_txcmdsz-pattrib->\r\nhdrlen-pattrib->iv_len -\r\npattrib->icv_len;\r\n*((u32 *)crc) = cpu_to_le32(getcrc32(\r\npayload, length));\r\narcfour_init(&mycontext, wepkey, 3 + keylength);\r\narcfour_encrypt(&mycontext, payload, payload,\r\nlength);\r\narcfour_encrypt(&mycontext, payload + length,\r\ncrc, 4);\r\n} else {\r\nlength = pxmitpriv->frag_len-pattrib->hdrlen -\r\npattrib->iv_len-pattrib->icv_len;\r\n*((u32 *)crc) = cpu_to_le32(getcrc32(\r\npayload, length));\r\narcfour_init(&mycontext, wepkey, 3 + keylength);\r\narcfour_encrypt(&mycontext, payload, payload,\r\nlength);\r\narcfour_encrypt(&mycontext, payload+length,\r\ncrc, 4);\r\npframe += pxmitpriv->frag_len;\r\npframe = (u8 *)RND4((addr_t)(pframe));\r\n}\r\n}\r\n}\r\n}\r\nvoid r8712_wep_decrypt(struct _adapter *padapter, u8 *precvframe)\r\n{\r\nu8 crc[4];\r\nstruct arc4context mycontext;\r\nu32 length, keylength;\r\nu8 *pframe, *payload, *iv, wepkey[16];\r\nu8 keyindex;\r\nstruct rx_pkt_attrib *prxattrib = &(((union recv_frame *)\r\nprecvframe)->u.hdr.attrib);\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\npframe = (unsigned char *)((union recv_frame *)precvframe)->\r\nu.hdr.rx_data;\r\nif ((prxattrib->encrypt == _WEP40_) || (prxattrib->encrypt ==\r\n_WEP104_)) {\r\niv = pframe + prxattrib->hdrlen;\r\nkeyindex = (iv[3] & 0x3);\r\nkeylength = psecuritypriv->DefKeylen[keyindex];\r\nmemcpy(&wepkey[0], iv, 3);\r\nmemcpy(&wepkey[3], &psecuritypriv->DefKey[\r\npsecuritypriv->PrivacyKeyIndex].skey[0],\r\nkeylength);\r\nlength = ((union recv_frame *)precvframe)->\r\nu.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;\r\npayload = pframe+prxattrib->iv_len+prxattrib->hdrlen;\r\narcfour_init(&mycontext, wepkey, 3 + keylength);\r\narcfour_encrypt(&mycontext, payload, payload, length);\r\n*((u32 *)crc) = cpu_to_le32(getcrc32(payload, length - 4));\r\n}\r\nreturn;\r\n}\r\nstatic u32 secmicgetuint32(u8 *p)\r\n{\r\ns32 i;\r\nu32 res = 0;\r\nfor (i = 0; i < 4; i++)\r\nres |= ((u32)(*p++)) << (8 * i);\r\nreturn res;\r\n}\r\nstatic void secmicputuint32(u8 *p, u32 val)\r\n{\r\nlong i;\r\nfor (i = 0; i < 4; i++) {\r\n*p++ = (u8) (val & 0xff);\r\nval >>= 8;\r\n}\r\n}\r\nstatic void secmicclear(struct mic_data *pmicdata)\r\n{\r\npmicdata->L = pmicdata->K0;\r\npmicdata->R = pmicdata->K1;\r\npmicdata->nBytesInM = 0;\r\npmicdata->M = 0;\r\n}\r\nvoid r8712_secmicsetkey(struct mic_data *pmicdata, u8 *key)\r\n{\r\npmicdata->K0 = secmicgetuint32(key);\r\npmicdata->K1 = secmicgetuint32(key + 4);\r\nsecmicclear(pmicdata);\r\n}\r\nstatic void secmicappendbyte(struct mic_data *pmicdata, u8 b)\r\n{\r\npmicdata->M |= ((u32)b) << (8 * pmicdata->nBytesInM);\r\npmicdata->nBytesInM++;\r\nif (pmicdata->nBytesInM >= 4) {\r\npmicdata->L ^= pmicdata->M;\r\npmicdata->R ^= ROL32(pmicdata->L, 17);\r\npmicdata->L += pmicdata->R;\r\npmicdata->R ^= ((pmicdata->L & 0xff00ff00) >> 8) |\r\n((pmicdata->L & 0x00ff00ff) << 8);\r\npmicdata->L += pmicdata->R;\r\npmicdata->R ^= ROL32(pmicdata->L, 3);\r\npmicdata->L += pmicdata->R;\r\npmicdata->R ^= ROR32(pmicdata->L, 2);\r\npmicdata->L += pmicdata->R;\r\npmicdata->M = 0;\r\npmicdata->nBytesInM = 0;\r\n}\r\n}\r\nvoid r8712_secmicappend(struct mic_data *pmicdata, u8 *src, u32 nbytes)\r\n{\r\nwhile (nbytes > 0) {\r\nsecmicappendbyte(pmicdata, *src++);\r\nnbytes--;\r\n}\r\n}\r\nvoid r8712_secgetmic(struct mic_data *pmicdata, u8 *dst)\r\n{\r\nsecmicappendbyte(pmicdata, 0x5a);\r\nsecmicappendbyte(pmicdata, 0);\r\nsecmicappendbyte(pmicdata, 0);\r\nsecmicappendbyte(pmicdata, 0);\r\nsecmicappendbyte(pmicdata, 0);\r\nwhile (pmicdata->nBytesInM != 0)\r\nsecmicappendbyte(pmicdata, 0);\r\nsecmicputuint32(dst, pmicdata->L);\r\nsecmicputuint32(dst + 4, pmicdata->R);\r\nsecmicclear(pmicdata);\r\n}\r\nvoid seccalctkipmic(u8 *key, u8 *header, u8 *data, u32 data_len, u8 *mic_code,\r\nu8 pri)\r\n{\r\nstruct mic_data micdata;\r\nu8 priority[4] = {0x0, 0x0, 0x0, 0x0};\r\nr8712_secmicsetkey(&micdata, key);\r\npriority[0] = pri;\r\nif (header[1] & 1) {\r\nr8712_secmicappend(&micdata, &header[16], 6);\r\nif (header[1] & 2)\r\nr8712_secmicappend(&micdata, &header[24], 6);\r\nelse\r\nr8712_secmicappend(&micdata, &header[10], 6);\r\n} else {\r\nr8712_secmicappend(&micdata, &header[4], 6);\r\nif (header[1] & 2)\r\nr8712_secmicappend(&micdata, &header[16], 6);\r\nelse\r\nr8712_secmicappend(&micdata, &header[10], 6);\r\n}\r\nr8712_secmicappend(&micdata, &priority[0], 4);\r\nr8712_secmicappend(&micdata, data, data_len);\r\nr8712_secgetmic(&micdata, mic_code);\r\n}\r\nstatic void phase1(u16 *p1k, const u8 *tk, const u8 *ta, u32 iv32)\r\n{\r\nsint i;\r\np1k[0] = Lo16(iv32);\r\np1k[1] = Hi16(iv32);\r\np1k[2] = Mk16(ta[1], ta[0]);\r\np1k[3] = Mk16(ta[3], ta[2]);\r\np1k[4] = Mk16(ta[5], ta[4]);\r\nfor (i = 0; i < PHASE1_LOOP_CNT; i++) {\r\np1k[0] += _S_(p1k[4] ^ TK16((i&1) + 0));\r\np1k[1] += _S_(p1k[0] ^ TK16((i&1) + 2));\r\np1k[2] += _S_(p1k[1] ^ TK16((i&1) + 4));\r\np1k[3] += _S_(p1k[2] ^ TK16((i&1) + 6));\r\np1k[4] += _S_(p1k[3] ^ TK16((i&1) + 0));\r\np1k[4] += (unsigned short)i;\r\n}\r\n}\r\nstatic void phase2(u8 *rc4key, const u8 *tk, const u16 *p1k, u16 iv16)\r\n{\r\nsint i;\r\nu16 PPK[6];\r\nfor (i = 0; i < 5; i++)\r\nPPK[i] = p1k[i];\r\nPPK[5] = p1k[4] + iv16;\r\nPPK[0] += _S_(PPK[5] ^ TK16(0));\r\nPPK[1] += _S_(PPK[0] ^ TK16(1));\r\nPPK[2] += _S_(PPK[1] ^ TK16(2));\r\nPPK[3] += _S_(PPK[2] ^ TK16(3));\r\nPPK[4] += _S_(PPK[3] ^ TK16(4));\r\nPPK[5] += _S_(PPK[4] ^ TK16(5));\r\nPPK[0] += RotR1(PPK[5] ^ TK16(6));\r\nPPK[1] += RotR1(PPK[0] ^ TK16(7));\r\nPPK[2] += RotR1(PPK[1]);\r\nPPK[3] += RotR1(PPK[2]);\r\nPPK[4] += RotR1(PPK[3]);\r\nPPK[5] += RotR1(PPK[4]);\r\nrc4key[0] = Hi8(iv16);\r\nrc4key[1] = (Hi8(iv16) | 0x20) & 0x7F;\r\nrc4key[2] = Lo8(iv16);\r\nrc4key[3] = Lo8((PPK[5] ^ TK16(0)) >> 1);\r\nfor (i = 0; i < 6; i++) {\r\nrc4key[4 + 2 * i] = Lo8(PPK[i]);\r\nrc4key[5 + 2 * i] = Hi8(PPK[i]);\r\n}\r\n}\r\nu32 r8712_tkip_encrypt(struct _adapter *padapter, u8 *pxmitframe)\r\n{\r\nu16 pnl;\r\nu32 pnh;\r\nu8 rc4key[16];\r\nu8 ttkey[16];\r\nu8 crc[4];\r\nstruct arc4context mycontext;\r\nu32 curfragnum, length, prwskeylen;\r\nu8 *pframe, *payload, *iv, *prwskey;\r\nunion pn48 txpn;\r\nstruct sta_info *stainfo;\r\nstruct pkt_attrib *pattrib = &((struct xmit_frame *)pxmitframe)->attrib;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nu32 res = _SUCCESS;\r\nif (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)\r\nreturn _FAIL;\r\npframe = ((struct xmit_frame *)pxmitframe)->buf_addr+TXDESC_OFFSET;\r\nif (pattrib->encrypt == _TKIP_) {\r\nif (pattrib->psta)\r\nstainfo = pattrib->psta;\r\nelse\r\nstainfo = r8712_get_stainfo(&padapter->stapriv,\r\n&pattrib->ra[0]);\r\nif (stainfo != NULL) {\r\nprwskey = &stainfo->x_UncstKey.skey[0];\r\nprwskeylen = 16;\r\nfor (curfragnum = 0; curfragnum < pattrib->nr_frags;\r\ncurfragnum++) {\r\niv = pframe + pattrib->hdrlen;\r\npayload = pframe+pattrib->iv_len +\r\npattrib->hdrlen;\r\nGET_TKIP_PN(iv, txpn);\r\npnl = (u16)(txpn.val);\r\npnh = (u32)(txpn.val >> 16);\r\nphase1((u16 *)&ttkey[0], prwskey, &pattrib->\r\nta[0], pnh);\r\nphase2(&rc4key[0], prwskey, (u16 *)&ttkey[0],\r\npnl);\r\nif ((curfragnum + 1) == pattrib->nr_frags) {\r\nlength = pattrib->last_txcmdsz -\r\npattrib->hdrlen-pattrib->iv_len -\r\npattrib->icv_len;\r\n*((u32 *)crc) = cpu_to_le32(\r\ngetcrc32(payload, length));\r\narcfour_init(&mycontext, rc4key, 16);\r\narcfour_encrypt(&mycontext, payload,\r\npayload, length);\r\narcfour_encrypt(&mycontext, payload +\r\nlength, crc, 4);\r\n} else {\r\nlength = pxmitpriv->frag_len-pattrib->\r\nhdrlen-pattrib->\r\niv_len-pattrib->icv_len;\r\n*((u32 *)crc) = cpu_to_le32(getcrc32(\r\npayload, length));\r\narcfour_init(&mycontext, rc4key, 16);\r\narcfour_encrypt(&mycontext, payload,\r\npayload, length);\r\narcfour_encrypt(&mycontext,\r\npayload+length, crc, 4);\r\npframe += pxmitpriv->frag_len;\r\npframe = (u8 *)RND4((addr_t)(pframe));\r\n}\r\n}\r\n} else\r\nres = _FAIL;\r\n}\r\nreturn res;\r\n}\r\nu32 r8712_tkip_decrypt(struct _adapter *padapter, u8 *precvframe)\r\n{\r\nu16 pnl;\r\nu32 pnh;\r\nu8 rc4key[16];\r\nu8 ttkey[16];\r\nu8 crc[4];\r\nstruct arc4context mycontext;\r\nu32 length, prwskeylen;\r\nu8 *pframe, *payload, *iv, *prwskey, idx = 0;\r\nunion pn48 txpn;\r\nstruct sta_info *stainfo;\r\nstruct rx_pkt_attrib *prxattrib = &((union recv_frame *)\r\nprecvframe)->u.hdr.attrib;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\npframe = (unsigned char *)((union recv_frame *)\r\nprecvframe)->u.hdr.rx_data;\r\nif (prxattrib->encrypt == _TKIP_) {\r\nstainfo = r8712_get_stainfo(&padapter->stapriv,\r\n&prxattrib->ta[0]);\r\nif (stainfo != NULL) {\r\niv = pframe+prxattrib->hdrlen;\r\npayload = pframe+prxattrib->iv_len + prxattrib->hdrlen;\r\nlength = ((union recv_frame *)precvframe)->\r\nu.hdr.len - prxattrib->hdrlen -\r\nprxattrib->iv_len;\r\nif (IS_MCAST(prxattrib->ra)) {\r\nidx = iv[3];\r\nprwskey = &psecuritypriv->XGrpKey[\r\n((idx >> 6) & 0x3) - 1].skey[0];\r\nif (psecuritypriv->binstallGrpkey == false)\r\nreturn _FAIL;\r\n} else\r\nprwskey = &stainfo->x_UncstKey.skey[0];\r\nprwskeylen = 16;\r\nGET_TKIP_PN(iv, txpn);\r\npnl = (u16)(txpn.val);\r\npnh = (u32)(txpn.val >> 16);\r\nphase1((u16 *)&ttkey[0], prwskey, &prxattrib->ta[0],\r\npnh);\r\nphase2(&rc4key[0], prwskey, (unsigned short *)\r\n&ttkey[0], pnl);\r\narcfour_init(&mycontext, rc4key, 16);\r\narcfour_encrypt(&mycontext, payload, payload, length);\r\n*((u32 *)crc) = cpu_to_le32(getcrc32(payload,\r\nlength - 4));\r\nif (crc[3] != payload[length - 1] ||\r\ncrc[2] != payload[length - 2] ||\r\ncrc[1] != payload[length - 3] ||\r\ncrc[0] != payload[length - 4])\r\nreturn _FAIL;\r\n} else\r\nreturn _FAIL;\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstatic void xor_128(u8 *a, u8 *b, u8 *out)\r\n{\r\nsint i;\r\nfor (i = 0; i < 16; i++)\r\nout[i] = a[i] ^ b[i];\r\n}\r\nstatic void xor_32(u8 *a, u8 *b, u8 *out)\r\n{\r\nsint i;\r\nfor (i = 0; i < 4; i++)\r\nout[i] = a[i] ^ b[i];\r\n}\r\nstatic u8 sbox(u8 a)\r\n{\r\nreturn sbox_table[(sint)a];\r\n}\r\nstatic void next_key(u8 *key, sint round)\r\n{\r\nu8 rcon;\r\nu8 sbox_key[4];\r\nu8 rcon_table[12] = {\r\n0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,\r\n0x1b, 0x36, 0x36, 0x36\r\n};\r\nsbox_key[0] = sbox(key[13]);\r\nsbox_key[1] = sbox(key[14]);\r\nsbox_key[2] = sbox(key[15]);\r\nsbox_key[3] = sbox(key[12]);\r\nrcon = rcon_table[round];\r\nxor_32(&key[0], sbox_key, &key[0]);\r\nkey[0] = key[0] ^ rcon;\r\nxor_32(&key[4], &key[0], &key[4]);\r\nxor_32(&key[8], &key[4], &key[8]);\r\nxor_32(&key[12], &key[8], &key[12]);\r\n}\r\nstatic void byte_sub(u8 *in, u8 *out)\r\n{\r\nsint i;\r\nfor (i = 0; i < 16; i++)\r\nout[i] = sbox(in[i]);\r\n}\r\nstatic void shift_row(u8 *in, u8 *out)\r\n{\r\nout[0] = in[0];\r\nout[1] = in[5];\r\nout[2] = in[10];\r\nout[3] = in[15];\r\nout[4] = in[4];\r\nout[5] = in[9];\r\nout[6] = in[14];\r\nout[7] = in[3];\r\nout[8] = in[8];\r\nout[9] = in[13];\r\nout[10] = in[2];\r\nout[11] = in[7];\r\nout[12] = in[12];\r\nout[13] = in[1];\r\nout[14] = in[6];\r\nout[15] = in[11];\r\n}\r\nstatic void mix_column(u8 *in, u8 *out)\r\n{\r\nsint i;\r\nu8 add1b[4];\r\nu8 add1bf7[4];\r\nu8 rotl[4];\r\nu8 swap_halfs[4];\r\nu8 andf7[4];\r\nu8 rotr[4];\r\nu8 temp[4];\r\nu8 tempb[4];\r\nfor (i = 0; i < 4; i++) {\r\nif ((in[i] & 0x80) == 0x80)\r\nadd1b[i] = 0x1b;\r\nelse\r\nadd1b[i] = 0x00;\r\n}\r\nswap_halfs[0] = in[2];\r\nswap_halfs[1] = in[3];\r\nswap_halfs[2] = in[0];\r\nswap_halfs[3] = in[1];\r\nrotl[0] = in[3];\r\nrotl[1] = in[0];\r\nrotl[2] = in[1];\r\nrotl[3] = in[2];\r\nandf7[0] = in[0] & 0x7f;\r\nandf7[1] = in[1] & 0x7f;\r\nandf7[2] = in[2] & 0x7f;\r\nandf7[3] = in[3] & 0x7f;\r\nfor (i = 3; i > 0; i--) {\r\nandf7[i] = andf7[i] << 1;\r\nif ((andf7[i-1] & 0x80) == 0x80)\r\nandf7[i] = (andf7[i] | 0x01);\r\n}\r\nandf7[0] = andf7[0] << 1;\r\nandf7[0] = andf7[0] & 0xfe;\r\nxor_32(add1b, andf7, add1bf7);\r\nxor_32(in, add1bf7, rotr);\r\ntemp[0] = rotr[0];\r\nrotr[0] = rotr[1];\r\nrotr[1] = rotr[2];\r\nrotr[2] = rotr[3];\r\nrotr[3] = temp[0];\r\nxor_32(add1bf7, rotr, temp);\r\nxor_32(swap_halfs, rotl, tempb);\r\nxor_32(temp, tempb, out);\r\n}\r\nstatic void aes128k128d(u8 *key, u8 *data, u8 *ciphertext)\r\n{\r\nsint round;\r\nsint i;\r\nu8 intermediatea[16];\r\nu8 intermediateb[16];\r\nu8 round_key[16];\r\nfor (i = 0; i < 16; i++)\r\nround_key[i] = key[i];\r\nfor (round = 0; round < 11; round++) {\r\nif (round == 0) {\r\nxor_128(round_key, data, ciphertext);\r\nnext_key(round_key, round);\r\n} else if (round == 10) {\r\nbyte_sub(ciphertext, intermediatea);\r\nshift_row(intermediatea, intermediateb);\r\nxor_128(intermediateb, round_key, ciphertext);\r\n} else {\r\nbyte_sub(ciphertext, intermediatea);\r\nshift_row(intermediatea, intermediateb);\r\nmix_column(&intermediateb[0], &intermediatea[0]);\r\nmix_column(&intermediateb[4], &intermediatea[4]);\r\nmix_column(&intermediateb[8], &intermediatea[8]);\r\nmix_column(&intermediateb[12], &intermediatea[12]);\r\nxor_128(intermediatea, round_key, ciphertext);\r\nnext_key(round_key, round);\r\n}\r\n}\r\n}\r\nstatic void construct_mic_iv(u8 *mic_iv, sint qc_exists, sint a4_exists,\r\nu8 *mpdu, uint payload_length, u8 *pn_vector)\r\n{\r\nsint i;\r\nmic_iv[0] = 0x59;\r\nif (qc_exists && a4_exists)\r\nmic_iv[1] = mpdu[30] & 0x0f;\r\nif (qc_exists && !a4_exists)\r\nmic_iv[1] = mpdu[24] & 0x0f;\r\nif (!qc_exists)\r\nmic_iv[1] = 0x00;\r\nfor (i = 2; i < 8; i++)\r\nmic_iv[i] = mpdu[i + 8];\r\nfor (i = 8; i < 14; i++)\r\nmic_iv[i] = pn_vector[13 - i];\r\nmic_iv[14] = (unsigned char) (payload_length / 256);\r\nmic_iv[15] = (unsigned char) (payload_length % 256);\r\n}\r\nstatic void construct_mic_header1(u8 *mic_header1, sint header_length, u8 *mpdu)\r\n{\r\nmic_header1[0] = (u8)((header_length - 2) / 256);\r\nmic_header1[1] = (u8)((header_length - 2) % 256);\r\nmic_header1[2] = mpdu[0] & 0xcf;\r\nmic_header1[3] = mpdu[1] & 0xc7;\r\nmic_header1[4] = mpdu[4];\r\nmic_header1[5] = mpdu[5];\r\nmic_header1[6] = mpdu[6];\r\nmic_header1[7] = mpdu[7];\r\nmic_header1[8] = mpdu[8];\r\nmic_header1[9] = mpdu[9];\r\nmic_header1[10] = mpdu[10];\r\nmic_header1[11] = mpdu[11];\r\nmic_header1[12] = mpdu[12];\r\nmic_header1[13] = mpdu[13];\r\nmic_header1[14] = mpdu[14];\r\nmic_header1[15] = mpdu[15];\r\n}\r\nstatic void construct_mic_header2(u8 *mic_header2, u8 *mpdu, sint a4_exists,\r\nsint qc_exists)\r\n{\r\nsint i;\r\nfor (i = 0; i < 16; i++)\r\nmic_header2[i] = 0x00;\r\nmic_header2[0] = mpdu[16];\r\nmic_header2[1] = mpdu[17];\r\nmic_header2[2] = mpdu[18];\r\nmic_header2[3] = mpdu[19];\r\nmic_header2[4] = mpdu[20];\r\nmic_header2[5] = mpdu[21];\r\nmic_header2[6] = 0x00;\r\nmic_header2[7] = 0x00;\r\nif (!qc_exists && a4_exists)\r\nfor (i = 0; i < 6; i++)\r\nmic_header2[8 + i] = mpdu[24 + i];\r\nif (qc_exists && !a4_exists) {\r\nmic_header2[8] = mpdu[24] & 0x0f;\r\nmic_header2[9] = mpdu[25] & 0x00;\r\n}\r\nif (qc_exists && a4_exists) {\r\nfor (i = 0; i < 6; i++)\r\nmic_header2[8 + i] = mpdu[24 + i];\r\nmic_header2[14] = mpdu[30] & 0x0f;\r\nmic_header2[15] = mpdu[31] & 0x00;\r\n}\r\n}\r\nstatic void construct_ctr_preload(u8 *ctr_preload, sint a4_exists, sint qc_exists,\r\nu8 *mpdu, u8 *pn_vector, sint c)\r\n{\r\nsint i;\r\nfor (i = 0; i < 16; i++)\r\nctr_preload[i] = 0x00;\r\ni = 0;\r\nctr_preload[0] = 0x01;\r\nif (qc_exists && a4_exists)\r\nctr_preload[1] = mpdu[30] & 0x0f;\r\nif (qc_exists && !a4_exists)\r\nctr_preload[1] = mpdu[24] & 0x0f;\r\nfor (i = 2; i < 8; i++)\r\nctr_preload[i] = mpdu[i + 8];\r\nfor (i = 8; i < 14; i++)\r\nctr_preload[i] = pn_vector[13 - i];\r\nctr_preload[14] = (unsigned char) (c / 256);\r\nctr_preload[15] = (unsigned char) (c % 256);\r\n}\r\nstatic void bitwise_xor(u8 *ina, u8 *inb, u8 *out)\r\n{\r\nsint i;\r\nfor (i = 0; i < 16; i++)\r\nout[i] = ina[i] ^ inb[i];\r\n}\r\nstatic sint aes_cipher(u8 *key, uint hdrlen,\r\nu8 *pframe, uint plen)\r\n{\r\nuint qc_exists, a4_exists, i, j, payload_remainder;\r\nuint num_blocks, payload_index;\r\nu8 pn_vector[6];\r\nu8 mic_iv[16];\r\nu8 mic_header1[16];\r\nu8 mic_header2[16];\r\nu8 ctr_preload[16];\r\nu8 chain_buffer[16];\r\nu8 aes_out[16];\r\nu8 padded_buffer[16];\r\nu8 mic[8];\r\nuint frtype = GetFrameType(pframe);\r\nuint frsubtype = GetFrameSubType(pframe);\r\nfrsubtype = frsubtype >> 4;\r\nmemset((void *)mic_iv, 0, 16);\r\nmemset((void *)mic_header1, 0, 16);\r\nmemset((void *)mic_header2, 0, 16);\r\nmemset((void *)ctr_preload, 0, 16);\r\nmemset((void *)chain_buffer, 0, 16);\r\nmemset((void *)aes_out, 0, 16);\r\nmemset((void *)padded_buffer, 0, 16);\r\nif ((hdrlen == WLAN_HDR_A3_LEN) || (hdrlen == WLAN_HDR_A3_QOS_LEN))\r\na4_exists = 0;\r\nelse\r\na4_exists = 1;\r\nif ((frtype == WIFI_DATA_CFACK) ||\r\n(frtype == WIFI_DATA_CFPOLL) ||\r\n(frtype == WIFI_DATA_CFACKPOLL)) {\r\nqc_exists = 1;\r\nif (hdrlen != WLAN_HDR_A3_QOS_LEN)\r\nhdrlen += 2;\r\n} else if ((frsubtype == 0x08) ||\r\n(frsubtype == 0x09) ||\r\n(frsubtype == 0x0a) ||\r\n(frsubtype == 0x0b)) {\r\nif (hdrlen != WLAN_HDR_A3_QOS_LEN)\r\nhdrlen += 2;\r\nqc_exists = 1;\r\n} else\r\nqc_exists = 0;\r\npn_vector[0] = pframe[hdrlen];\r\npn_vector[1] = pframe[hdrlen+1];\r\npn_vector[2] = pframe[hdrlen+4];\r\npn_vector[3] = pframe[hdrlen+5];\r\npn_vector[4] = pframe[hdrlen+6];\r\npn_vector[5] = pframe[hdrlen+7];\r\nconstruct_mic_iv(mic_iv, qc_exists, a4_exists, pframe, plen, pn_vector);\r\nconstruct_mic_header1(mic_header1, hdrlen, pframe);\r\nconstruct_mic_header2(mic_header2, pframe, a4_exists, qc_exists);\r\npayload_remainder = plen % 16;\r\nnum_blocks = plen / 16;\r\npayload_index = (hdrlen + 8);\r\naes128k128d(key, mic_iv, aes_out);\r\nbitwise_xor(aes_out, mic_header1, chain_buffer);\r\naes128k128d(key, chain_buffer, aes_out);\r\nbitwise_xor(aes_out, mic_header2, chain_buffer);\r\naes128k128d(key, chain_buffer, aes_out);\r\nfor (i = 0; i < num_blocks; i++) {\r\nbitwise_xor(aes_out, &pframe[payload_index], chain_buffer);\r\npayload_index += 16;\r\naes128k128d(key, chain_buffer, aes_out);\r\n}\r\nif (payload_remainder > 0) {\r\nfor (j = 0; j < 16; j++)\r\npadded_buffer[j] = 0x00;\r\nfor (j = 0; j < payload_remainder; j++)\r\npadded_buffer[j] = pframe[payload_index++];\r\nbitwise_xor(aes_out, padded_buffer, chain_buffer);\r\naes128k128d(key, chain_buffer, aes_out);\r\n}\r\nfor (j = 0; j < 8; j++)\r\nmic[j] = aes_out[j];\r\nfor (j = 0; j < 8; j++)\r\npframe[payload_index+j] = mic[j];\r\npayload_index = hdrlen + 8;\r\nfor (i = 0; i < num_blocks; i++) {\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists,\r\npframe, pn_vector, i + 1);\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, &pframe[payload_index], chain_buffer);\r\nfor (j = 0; j < 16; j++)\r\npframe[payload_index++] = chain_buffer[j];\r\n}\r\nif (payload_remainder > 0) {\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists,\r\npframe, pn_vector, num_blocks+1);\r\nfor (j = 0; j < 16; j++)\r\npadded_buffer[j] = 0x00;\r\nfor (j = 0; j < payload_remainder; j++)\r\npadded_buffer[j] = pframe[payload_index+j];\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, padded_buffer, chain_buffer);\r\nfor (j = 0; j < payload_remainder; j++)\r\npframe[payload_index++] = chain_buffer[j];\r\n}\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists,\r\npframe, pn_vector, 0);\r\nfor (j = 0; j < 16; j++)\r\npadded_buffer[j] = 0x00;\r\nfor (j = 0; j < 8; j++)\r\npadded_buffer[j] = pframe[j+hdrlen+8+plen];\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, padded_buffer, chain_buffer);\r\nfor (j = 0; j < 8; j++)\r\npframe[payload_index++] = chain_buffer[j];\r\nreturn _SUCCESS;\r\n}\r\nu32 r8712_aes_encrypt(struct _adapter *padapter, u8 *pxmitframe)\r\n{\r\nsint curfragnum, length;\r\nu32 prwskeylen;\r\nu8 *pframe, *prwskey;\r\nstruct sta_info *stainfo;\r\nstruct pkt_attrib *pattrib = &((struct xmit_frame *)\r\npxmitframe)->attrib;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nu32 res = _SUCCESS;\r\nif (((struct xmit_frame *)pxmitframe)->buf_addr == NULL)\r\nreturn _FAIL;\r\npframe = ((struct xmit_frame *)pxmitframe)->buf_addr + TXDESC_OFFSET;\r\nif (pattrib->encrypt == _AES_) {\r\nif (pattrib->psta)\r\nstainfo = pattrib->psta;\r\nelse\r\nstainfo = r8712_get_stainfo(&padapter->stapriv,\r\n&pattrib->ra[0]);\r\nif (stainfo != NULL) {\r\nprwskey = &stainfo->x_UncstKey.skey[0];\r\nprwskeylen = 16;\r\nfor (curfragnum = 0; curfragnum < pattrib->nr_frags;\r\ncurfragnum++) {\r\nif ((curfragnum + 1) == pattrib->nr_frags) {\r\nlength = pattrib->last_txcmdsz -\r\npattrib->hdrlen -\r\npattrib->iv_len -\r\npattrib->icv_len;\r\naes_cipher(prwskey, pattrib->\r\nhdrlen, pframe, length);\r\n} else {\r\nlength = pxmitpriv->frag_len -\r\npattrib->hdrlen -\r\npattrib->iv_len -\r\npattrib->icv_len;\r\naes_cipher(prwskey, pattrib->\r\nhdrlen, pframe, length);\r\npframe += pxmitpriv->frag_len;\r\npframe = (u8 *)RND4((addr_t)(pframe));\r\n}\r\n}\r\n} else\r\nres = _FAIL;\r\n}\r\nreturn res;\r\n}\r\nstatic sint aes_decipher(u8 *key, uint hdrlen,\r\nu8 *pframe, uint plen)\r\n{\r\nstatic u8 message[MAX_MSG_SIZE];\r\nuint qc_exists, a4_exists, i, j, payload_remainder;\r\nuint num_blocks, payload_index;\r\nu8 pn_vector[6];\r\nu8 mic_iv[16];\r\nu8 mic_header1[16];\r\nu8 mic_header2[16];\r\nu8 ctr_preload[16];\r\nu8 chain_buffer[16];\r\nu8 aes_out[16];\r\nu8 padded_buffer[16];\r\nu8 mic[8];\r\nuint frtype = GetFrameType(pframe);\r\nuint frsubtype = GetFrameSubType(pframe);\r\nfrsubtype = frsubtype >> 4;\r\nmemset((void *)mic_iv, 0, 16);\r\nmemset((void *)mic_header1, 0, 16);\r\nmemset((void *)mic_header2, 0, 16);\r\nmemset((void *)ctr_preload, 0, 16);\r\nmemset((void *)chain_buffer, 0, 16);\r\nmemset((void *)aes_out, 0, 16);\r\nmemset((void *)padded_buffer, 0, 16);\r\nnum_blocks = (plen - 8) / 16;\r\npayload_remainder = (plen-8) % 16;\r\npn_vector[0] = pframe[hdrlen];\r\npn_vector[1] = pframe[hdrlen+1];\r\npn_vector[2] = pframe[hdrlen+4];\r\npn_vector[3] = pframe[hdrlen+5];\r\npn_vector[4] = pframe[hdrlen+6];\r\npn_vector[5] = pframe[hdrlen+7];\r\nif ((hdrlen == WLAN_HDR_A3_LEN) || (hdrlen == WLAN_HDR_A3_QOS_LEN))\r\na4_exists = 0;\r\nelse\r\na4_exists = 1;\r\nif ((frtype == WIFI_DATA_CFACK) ||\r\n(frtype == WIFI_DATA_CFPOLL) ||\r\n(frtype == WIFI_DATA_CFACKPOLL)) {\r\nqc_exists = 1;\r\nif (hdrlen != WLAN_HDR_A3_QOS_LEN)\r\nhdrlen += 2;\r\n} else if ((frsubtype == 0x08) ||\r\n(frsubtype == 0x09) ||\r\n(frsubtype == 0x0a) ||\r\n(frsubtype == 0x0b)) {\r\nif (hdrlen != WLAN_HDR_A3_QOS_LEN)\r\nhdrlen += 2;\r\nqc_exists = 1;\r\n} else {\r\nqc_exists = 0;\r\n}\r\npayload_index = hdrlen + 8;\r\nfor (i = 0; i < num_blocks; i++) {\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists,\r\npframe, pn_vector, i + 1);\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, &pframe[payload_index], chain_buffer);\r\nfor (j = 0; j < 16; j++)\r\npframe[payload_index++] = chain_buffer[j];\r\n}\r\nif (payload_remainder > 0) {\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists,\r\npframe, pn_vector, num_blocks+1);\r\nfor (j = 0; j < 16; j++)\r\npadded_buffer[j] = 0x00;\r\nfor (j = 0; j < payload_remainder; j++)\r\npadded_buffer[j] = pframe[payload_index + j];\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, padded_buffer, chain_buffer);\r\nfor (j = 0; j < payload_remainder; j++)\r\npframe[payload_index++] = chain_buffer[j];\r\n}\r\nmemcpy((void *)message, pframe, (hdrlen + plen + 8));\r\npn_vector[0] = pframe[hdrlen];\r\npn_vector[1] = pframe[hdrlen+1];\r\npn_vector[2] = pframe[hdrlen+4];\r\npn_vector[3] = pframe[hdrlen+5];\r\npn_vector[4] = pframe[hdrlen+6];\r\npn_vector[5] = pframe[hdrlen+7];\r\nconstruct_mic_iv(mic_iv, qc_exists, a4_exists, message, plen-8,\r\npn_vector);\r\nconstruct_mic_header1(mic_header1, hdrlen, message);\r\nconstruct_mic_header2(mic_header2, message, a4_exists, qc_exists);\r\npayload_remainder = (plen - 8) % 16;\r\nnum_blocks = (plen - 8) / 16;\r\npayload_index = (hdrlen + 8);\r\naes128k128d(key, mic_iv, aes_out);\r\nbitwise_xor(aes_out, mic_header1, chain_buffer);\r\naes128k128d(key, chain_buffer, aes_out);\r\nbitwise_xor(aes_out, mic_header2, chain_buffer);\r\naes128k128d(key, chain_buffer, aes_out);\r\nfor (i = 0; i < num_blocks; i++) {\r\nbitwise_xor(aes_out, &message[payload_index], chain_buffer);\r\npayload_index += 16;\r\naes128k128d(key, chain_buffer, aes_out);\r\n}\r\nif (payload_remainder > 0) {\r\nfor (j = 0; j < 16; j++)\r\npadded_buffer[j] = 0x00;\r\nfor (j = 0; j < payload_remainder; j++)\r\npadded_buffer[j] = message[payload_index++];\r\nbitwise_xor(aes_out, padded_buffer, chain_buffer);\r\naes128k128d(key, chain_buffer, aes_out);\r\n}\r\nfor (j = 0; j < 8; j++)\r\nmic[j] = aes_out[j];\r\nfor (j = 0; j < 8; j++)\r\nmessage[payload_index+j] = mic[j];\r\npayload_index = hdrlen + 8;\r\nfor (i = 0; i < num_blocks; i++) {\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists,\r\nmessage, pn_vector, i + 1);\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, &message[payload_index], chain_buffer);\r\nfor (j = 0; j < 16; j++)\r\nmessage[payload_index++] = chain_buffer[j];\r\n}\r\nif (payload_remainder > 0) {\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists,\r\nmessage, pn_vector, num_blocks+1);\r\nfor (j = 0; j < 16; j++)\r\npadded_buffer[j] = 0x00;\r\nfor (j = 0; j < payload_remainder; j++)\r\npadded_buffer[j] = message[payload_index + j];\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, padded_buffer, chain_buffer);\r\nfor (j = 0; j < payload_remainder; j++)\r\nmessage[payload_index++] = chain_buffer[j];\r\n}\r\nconstruct_ctr_preload(ctr_preload, a4_exists, qc_exists, message,\r\npn_vector, 0);\r\nfor (j = 0; j < 16; j++)\r\npadded_buffer[j] = 0x00;\r\nfor (j = 0; j < 8; j++)\r\npadded_buffer[j] = message[j + hdrlen + plen];\r\naes128k128d(key, ctr_preload, aes_out);\r\nbitwise_xor(aes_out, padded_buffer, chain_buffer);\r\nfor (j = 0; j < 8; j++)\r\nmessage[payload_index++] = chain_buffer[j];\r\nreturn _SUCCESS;\r\n}\r\nu32 r8712_aes_decrypt(struct _adapter *padapter, u8 *precvframe)\r\n{\r\nsint length;\r\nu32 prwskeylen;\r\nu8 *pframe, *prwskey, *iv, idx;\r\nstruct sta_info *stainfo;\r\nstruct rx_pkt_attrib *prxattrib = &((union recv_frame *)\r\nprecvframe)->u.hdr.attrib;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\npframe = (unsigned char *)((union recv_frame *)precvframe)->\r\nu.hdr.rx_data;\r\nif (prxattrib->encrypt == _AES_) {\r\nstainfo = r8712_get_stainfo(&padapter->stapriv,\r\n&prxattrib->ta[0]);\r\nif (stainfo != NULL) {\r\nif (IS_MCAST(prxattrib->ra)) {\r\niv = pframe+prxattrib->hdrlen;\r\nidx = iv[3];\r\nprwskey = &psecuritypriv->XGrpKey[\r\n((idx >> 6) & 0x3) - 1].skey[0];\r\nif (psecuritypriv->binstallGrpkey == false)\r\nreturn _FAIL;\r\n} else\r\nprwskey = &stainfo->x_UncstKey.skey[0];\r\nprwskeylen = 16;\r\nlength = ((union recv_frame *)precvframe)->\r\nu.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;\r\naes_decipher(prwskey, prxattrib->hdrlen, pframe,\r\nlength);\r\n} else\r\nreturn _FAIL;\r\n}\r\nreturn _SUCCESS;\r\n}\r\nvoid r8712_use_tkipkey_handler(void *FunctionContext)\r\n{\r\nstruct _adapter *padapter = (struct _adapter *)FunctionContext;\r\npadapter->securitypriv.busetkipkey = true;\r\n}
