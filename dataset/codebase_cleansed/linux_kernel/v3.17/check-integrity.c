static void btrfsic_block_init(struct btrfsic_block *b)\r\n{\r\nb->magic_num = BTRFSIC_BLOCK_MAGIC_NUMBER;\r\nb->dev_state = NULL;\r\nb->dev_bytenr = 0;\r\nb->logical_bytenr = 0;\r\nb->generation = BTRFSIC_GENERATION_UNKNOWN;\r\nb->disk_key.objectid = 0;\r\nb->disk_key.type = 0;\r\nb->disk_key.offset = 0;\r\nb->is_metadata = 0;\r\nb->is_superblock = 0;\r\nb->is_iodone = 0;\r\nb->iodone_w_error = 0;\r\nb->never_written = 0;\r\nb->mirror_num = 0;\r\nb->next_in_same_bio = NULL;\r\nb->orig_bio_bh_private = NULL;\r\nb->orig_bio_bh_end_io.bio = NULL;\r\nINIT_LIST_HEAD(&b->collision_resolving_node);\r\nINIT_LIST_HEAD(&b->all_blocks_node);\r\nINIT_LIST_HEAD(&b->ref_to_list);\r\nINIT_LIST_HEAD(&b->ref_from_list);\r\nb->submit_bio_bh_rw = 0;\r\nb->flush_gen = 0;\r\n}\r\nstatic struct btrfsic_block *btrfsic_block_alloc(void)\r\n{\r\nstruct btrfsic_block *b;\r\nb = kzalloc(sizeof(*b), GFP_NOFS);\r\nif (NULL != b)\r\nbtrfsic_block_init(b);\r\nreturn b;\r\n}\r\nstatic void btrfsic_block_free(struct btrfsic_block *b)\r\n{\r\nBUG_ON(!(NULL == b || BTRFSIC_BLOCK_MAGIC_NUMBER == b->magic_num));\r\nkfree(b);\r\n}\r\nstatic void btrfsic_block_link_init(struct btrfsic_block_link *l)\r\n{\r\nl->magic_num = BTRFSIC_BLOCK_LINK_MAGIC_NUMBER;\r\nl->ref_cnt = 1;\r\nINIT_LIST_HEAD(&l->node_ref_to);\r\nINIT_LIST_HEAD(&l->node_ref_from);\r\nINIT_LIST_HEAD(&l->collision_resolving_node);\r\nl->block_ref_to = NULL;\r\nl->block_ref_from = NULL;\r\n}\r\nstatic struct btrfsic_block_link *btrfsic_block_link_alloc(void)\r\n{\r\nstruct btrfsic_block_link *l;\r\nl = kzalloc(sizeof(*l), GFP_NOFS);\r\nif (NULL != l)\r\nbtrfsic_block_link_init(l);\r\nreturn l;\r\n}\r\nstatic void btrfsic_block_link_free(struct btrfsic_block_link *l)\r\n{\r\nBUG_ON(!(NULL == l || BTRFSIC_BLOCK_LINK_MAGIC_NUMBER == l->magic_num));\r\nkfree(l);\r\n}\r\nstatic void btrfsic_dev_state_init(struct btrfsic_dev_state *ds)\r\n{\r\nds->magic_num = BTRFSIC_DEV2STATE_MAGIC_NUMBER;\r\nds->bdev = NULL;\r\nds->state = NULL;\r\nds->name[0] = '\0';\r\nINIT_LIST_HEAD(&ds->collision_resolving_node);\r\nds->last_flush_gen = 0;\r\nbtrfsic_block_init(&ds->dummy_block_for_bio_bh_flush);\r\nds->dummy_block_for_bio_bh_flush.is_iodone = 1;\r\nds->dummy_block_for_bio_bh_flush.dev_state = ds;\r\n}\r\nstatic struct btrfsic_dev_state *btrfsic_dev_state_alloc(void)\r\n{\r\nstruct btrfsic_dev_state *ds;\r\nds = kzalloc(sizeof(*ds), GFP_NOFS);\r\nif (NULL != ds)\r\nbtrfsic_dev_state_init(ds);\r\nreturn ds;\r\n}\r\nstatic void btrfsic_dev_state_free(struct btrfsic_dev_state *ds)\r\n{\r\nBUG_ON(!(NULL == ds ||\r\nBTRFSIC_DEV2STATE_MAGIC_NUMBER == ds->magic_num));\r\nkfree(ds);\r\n}\r\nstatic void btrfsic_block_hashtable_init(struct btrfsic_block_hashtable *h)\r\n{\r\nint i;\r\nfor (i = 0; i < BTRFSIC_BLOCK_HASHTABLE_SIZE; i++)\r\nINIT_LIST_HEAD(h->table + i);\r\n}\r\nstatic void btrfsic_block_hashtable_add(struct btrfsic_block *b,\r\nstruct btrfsic_block_hashtable *h)\r\n{\r\nconst unsigned int hashval =\r\n(((unsigned int)(b->dev_bytenr >> 16)) ^\r\n((unsigned int)((uintptr_t)b->dev_state->bdev))) &\r\n(BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\r\nlist_add(&b->collision_resolving_node, h->table + hashval);\r\n}\r\nstatic void btrfsic_block_hashtable_remove(struct btrfsic_block *b)\r\n{\r\nlist_del(&b->collision_resolving_node);\r\n}\r\nstatic struct btrfsic_block *btrfsic_block_hashtable_lookup(\r\nstruct block_device *bdev,\r\nu64 dev_bytenr,\r\nstruct btrfsic_block_hashtable *h)\r\n{\r\nconst unsigned int hashval =\r\n(((unsigned int)(dev_bytenr >> 16)) ^\r\n((unsigned int)((uintptr_t)bdev))) &\r\n(BTRFSIC_BLOCK_HASHTABLE_SIZE - 1);\r\nstruct list_head *elem;\r\nlist_for_each(elem, h->table + hashval) {\r\nstruct btrfsic_block *const b =\r\nlist_entry(elem, struct btrfsic_block,\r\ncollision_resolving_node);\r\nif (b->dev_state->bdev == bdev && b->dev_bytenr == dev_bytenr)\r\nreturn b;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void btrfsic_block_link_hashtable_init(\r\nstruct btrfsic_block_link_hashtable *h)\r\n{\r\nint i;\r\nfor (i = 0; i < BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE; i++)\r\nINIT_LIST_HEAD(h->table + i);\r\n}\r\nstatic void btrfsic_block_link_hashtable_add(\r\nstruct btrfsic_block_link *l,\r\nstruct btrfsic_block_link_hashtable *h)\r\n{\r\nconst unsigned int hashval =\r\n(((unsigned int)(l->block_ref_to->dev_bytenr >> 16)) ^\r\n((unsigned int)(l->block_ref_from->dev_bytenr >> 16)) ^\r\n((unsigned int)((uintptr_t)l->block_ref_to->dev_state->bdev)) ^\r\n((unsigned int)((uintptr_t)l->block_ref_from->dev_state->bdev)))\r\n& (BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE - 1);\r\nBUG_ON(NULL == l->block_ref_to);\r\nBUG_ON(NULL == l->block_ref_from);\r\nlist_add(&l->collision_resolving_node, h->table + hashval);\r\n}\r\nstatic void btrfsic_block_link_hashtable_remove(struct btrfsic_block_link *l)\r\n{\r\nlist_del(&l->collision_resolving_node);\r\n}\r\nstatic struct btrfsic_block_link *btrfsic_block_link_hashtable_lookup(\r\nstruct block_device *bdev_ref_to,\r\nu64 dev_bytenr_ref_to,\r\nstruct block_device *bdev_ref_from,\r\nu64 dev_bytenr_ref_from,\r\nstruct btrfsic_block_link_hashtable *h)\r\n{\r\nconst unsigned int hashval =\r\n(((unsigned int)(dev_bytenr_ref_to >> 16)) ^\r\n((unsigned int)(dev_bytenr_ref_from >> 16)) ^\r\n((unsigned int)((uintptr_t)bdev_ref_to)) ^\r\n((unsigned int)((uintptr_t)bdev_ref_from))) &\r\n(BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE - 1);\r\nstruct list_head *elem;\r\nlist_for_each(elem, h->table + hashval) {\r\nstruct btrfsic_block_link *const l =\r\nlist_entry(elem, struct btrfsic_block_link,\r\ncollision_resolving_node);\r\nBUG_ON(NULL == l->block_ref_to);\r\nBUG_ON(NULL == l->block_ref_from);\r\nif (l->block_ref_to->dev_state->bdev == bdev_ref_to &&\r\nl->block_ref_to->dev_bytenr == dev_bytenr_ref_to &&\r\nl->block_ref_from->dev_state->bdev == bdev_ref_from &&\r\nl->block_ref_from->dev_bytenr == dev_bytenr_ref_from)\r\nreturn l;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void btrfsic_dev_state_hashtable_init(\r\nstruct btrfsic_dev_state_hashtable *h)\r\n{\r\nint i;\r\nfor (i = 0; i < BTRFSIC_DEV2STATE_HASHTABLE_SIZE; i++)\r\nINIT_LIST_HEAD(h->table + i);\r\n}\r\nstatic void btrfsic_dev_state_hashtable_add(\r\nstruct btrfsic_dev_state *ds,\r\nstruct btrfsic_dev_state_hashtable *h)\r\n{\r\nconst unsigned int hashval =\r\n(((unsigned int)((uintptr_t)ds->bdev)) &\r\n(BTRFSIC_DEV2STATE_HASHTABLE_SIZE - 1));\r\nlist_add(&ds->collision_resolving_node, h->table + hashval);\r\n}\r\nstatic void btrfsic_dev_state_hashtable_remove(struct btrfsic_dev_state *ds)\r\n{\r\nlist_del(&ds->collision_resolving_node);\r\n}\r\nstatic struct btrfsic_dev_state *btrfsic_dev_state_hashtable_lookup(\r\nstruct block_device *bdev,\r\nstruct btrfsic_dev_state_hashtable *h)\r\n{\r\nconst unsigned int hashval =\r\n(((unsigned int)((uintptr_t)bdev)) &\r\n(BTRFSIC_DEV2STATE_HASHTABLE_SIZE - 1));\r\nstruct list_head *elem;\r\nlist_for_each(elem, h->table + hashval) {\r\nstruct btrfsic_dev_state *const ds =\r\nlist_entry(elem, struct btrfsic_dev_state,\r\ncollision_resolving_node);\r\nif (ds->bdev == bdev)\r\nreturn ds;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int btrfsic_process_superblock(struct btrfsic_state *state,\r\nstruct btrfs_fs_devices *fs_devices)\r\n{\r\nint ret = 0;\r\nstruct btrfs_super_block *selected_super;\r\nstruct list_head *dev_head = &fs_devices->devices;\r\nstruct btrfs_device *device;\r\nstruct btrfsic_dev_state *selected_dev_state = NULL;\r\nint pass;\r\nBUG_ON(NULL == state);\r\nselected_super = kzalloc(sizeof(*selected_super), GFP_NOFS);\r\nif (NULL == selected_super) {\r\nprintk(KERN_INFO "btrfsic: error, kmalloc failed!\n");\r\nreturn -1;\r\n}\r\nlist_for_each_entry(device, dev_head, dev_list) {\r\nint i;\r\nstruct btrfsic_dev_state *dev_state;\r\nif (!device->bdev || !device->name)\r\ncontinue;\r\ndev_state = btrfsic_dev_state_lookup(device->bdev);\r\nBUG_ON(NULL == dev_state);\r\nfor (i = 0; i < BTRFS_SUPER_MIRROR_MAX; i++) {\r\nret = btrfsic_process_superblock_dev_mirror(\r\nstate, dev_state, device, i,\r\n&selected_dev_state, selected_super);\r\nif (0 != ret && 0 == i) {\r\nkfree(selected_super);\r\nreturn ret;\r\n}\r\n}\r\n}\r\nif (NULL == state->latest_superblock) {\r\nprintk(KERN_INFO "btrfsic: no superblock found!\n");\r\nkfree(selected_super);\r\nreturn -1;\r\n}\r\nstate->csum_size = btrfs_super_csum_size(selected_super);\r\nfor (pass = 0; pass < 3; pass++) {\r\nint num_copies;\r\nint mirror_num;\r\nu64 next_bytenr;\r\nswitch (pass) {\r\ncase 0:\r\nnext_bytenr = btrfs_super_root(selected_super);\r\nif (state->print_mask &\r\nBTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\r\nprintk(KERN_INFO "root@%llu\n", next_bytenr);\r\nbreak;\r\ncase 1:\r\nnext_bytenr = btrfs_super_chunk_root(selected_super);\r\nif (state->print_mask &\r\nBTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\r\nprintk(KERN_INFO "chunk@%llu\n", next_bytenr);\r\nbreak;\r\ncase 2:\r\nnext_bytenr = btrfs_super_log_root(selected_super);\r\nif (0 == next_bytenr)\r\ncontinue;\r\nif (state->print_mask &\r\nBTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\r\nprintk(KERN_INFO "log@%llu\n", next_bytenr);\r\nbreak;\r\n}\r\nnum_copies =\r\nbtrfs_num_copies(state->root->fs_info,\r\nnext_bytenr, state->metablock_size);\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\r\nprintk(KERN_INFO "num_copies(log_bytenr=%llu) = %d\n",\r\nnext_bytenr, num_copies);\r\nfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\r\nstruct btrfsic_block *next_block;\r\nstruct btrfsic_block_data_ctx tmp_next_block_ctx;\r\nstruct btrfsic_block_link *l;\r\nret = btrfsic_map_block(state, next_bytenr,\r\nstate->metablock_size,\r\n&tmp_next_block_ctx,\r\nmirror_num);\r\nif (ret) {\r\nprintk(KERN_INFO "btrfsic:"\r\n" btrfsic_map_block(root @%llu,"\r\n" mirror %d) failed!\n",\r\nnext_bytenr, mirror_num);\r\nkfree(selected_super);\r\nreturn -1;\r\n}\r\nnext_block = btrfsic_block_hashtable_lookup(\r\ntmp_next_block_ctx.dev->bdev,\r\ntmp_next_block_ctx.dev_bytenr,\r\n&state->block_hashtable);\r\nBUG_ON(NULL == next_block);\r\nl = btrfsic_block_link_hashtable_lookup(\r\ntmp_next_block_ctx.dev->bdev,\r\ntmp_next_block_ctx.dev_bytenr,\r\nstate->latest_superblock->dev_state->\r\nbdev,\r\nstate->latest_superblock->dev_bytenr,\r\n&state->block_link_hashtable);\r\nBUG_ON(NULL == l);\r\nret = btrfsic_read_block(state, &tmp_next_block_ctx);\r\nif (ret < (int)PAGE_CACHE_SIZE) {\r\nprintk(KERN_INFO\r\n"btrfsic: read @logical %llu failed!\n",\r\ntmp_next_block_ctx.start);\r\nbtrfsic_release_block_ctx(&tmp_next_block_ctx);\r\nkfree(selected_super);\r\nreturn -1;\r\n}\r\nret = btrfsic_process_metablock(state,\r\nnext_block,\r\n&tmp_next_block_ctx,\r\nBTRFS_MAX_LEVEL + 3, 1);\r\nbtrfsic_release_block_ctx(&tmp_next_block_ctx);\r\n}\r\n}\r\nkfree(selected_super);\r\nreturn ret;\r\n}\r\nstatic int btrfsic_process_superblock_dev_mirror(\r\nstruct btrfsic_state *state,\r\nstruct btrfsic_dev_state *dev_state,\r\nstruct btrfs_device *device,\r\nint superblock_mirror_num,\r\nstruct btrfsic_dev_state **selected_dev_state,\r\nstruct btrfs_super_block *selected_super)\r\n{\r\nstruct btrfs_super_block *super_tmp;\r\nu64 dev_bytenr;\r\nstruct buffer_head *bh;\r\nstruct btrfsic_block *superblock_tmp;\r\nint pass;\r\nstruct block_device *const superblock_bdev = device->bdev;\r\ndev_bytenr = btrfs_sb_offset(superblock_mirror_num);\r\nif (dev_bytenr + BTRFS_SUPER_INFO_SIZE > device->total_bytes)\r\nreturn -1;\r\nbh = __bread(superblock_bdev, dev_bytenr / 4096,\r\nBTRFS_SUPER_INFO_SIZE);\r\nif (NULL == bh)\r\nreturn -1;\r\nsuper_tmp = (struct btrfs_super_block *)\r\n(bh->b_data + (dev_bytenr & 4095));\r\nif (btrfs_super_bytenr(super_tmp) != dev_bytenr ||\r\nbtrfs_super_magic(super_tmp) != BTRFS_MAGIC ||\r\nmemcmp(device->uuid, super_tmp->dev_item.uuid, BTRFS_UUID_SIZE) ||\r\nbtrfs_super_nodesize(super_tmp) != state->metablock_size ||\r\nbtrfs_super_leafsize(super_tmp) != state->metablock_size ||\r\nbtrfs_super_sectorsize(super_tmp) != state->datablock_size) {\r\nbrelse(bh);\r\nreturn 0;\r\n}\r\nsuperblock_tmp =\r\nbtrfsic_block_hashtable_lookup(superblock_bdev,\r\ndev_bytenr,\r\n&state->block_hashtable);\r\nif (NULL == superblock_tmp) {\r\nsuperblock_tmp = btrfsic_block_alloc();\r\nif (NULL == superblock_tmp) {\r\nprintk(KERN_INFO "btrfsic: error, kmalloc failed!\n");\r\nbrelse(bh);\r\nreturn -1;\r\n}\r\nsuperblock_tmp->dev_bytenr = dev_bytenr;\r\nsuperblock_tmp->dev_state = dev_state;\r\nsuperblock_tmp->logical_bytenr = dev_bytenr;\r\nsuperblock_tmp->generation = btrfs_super_generation(super_tmp);\r\nsuperblock_tmp->is_metadata = 1;\r\nsuperblock_tmp->is_superblock = 1;\r\nsuperblock_tmp->is_iodone = 1;\r\nsuperblock_tmp->never_written = 0;\r\nsuperblock_tmp->mirror_num = 1 + superblock_mirror_num;\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE)\r\nprintk_in_rcu(KERN_INFO "New initial S-block (bdev %p, %s)"\r\n" @%llu (%s/%llu/%d)\n",\r\nsuperblock_bdev,\r\nrcu_str_deref(device->name), dev_bytenr,\r\ndev_state->name, dev_bytenr,\r\nsuperblock_mirror_num);\r\nlist_add(&superblock_tmp->all_blocks_node,\r\n&state->all_blocks_list);\r\nbtrfsic_block_hashtable_add(superblock_tmp,\r\n&state->block_hashtable);\r\n}\r\nif (btrfs_super_generation(super_tmp) >\r\nstate->max_superblock_generation ||\r\n0 == state->max_superblock_generation) {\r\nmemcpy(selected_super, super_tmp, sizeof(*selected_super));\r\n*selected_dev_state = dev_state;\r\nstate->max_superblock_generation =\r\nbtrfs_super_generation(super_tmp);\r\nstate->latest_superblock = superblock_tmp;\r\n}\r\nfor (pass = 0; pass < 3; pass++) {\r\nu64 next_bytenr;\r\nint num_copies;\r\nint mirror_num;\r\nconst char *additional_string = NULL;\r\nstruct btrfs_disk_key tmp_disk_key;\r\ntmp_disk_key.type = BTRFS_ROOT_ITEM_KEY;\r\ntmp_disk_key.offset = 0;\r\nswitch (pass) {\r\ncase 0:\r\nbtrfs_set_disk_key_objectid(&tmp_disk_key,\r\nBTRFS_ROOT_TREE_OBJECTID);\r\nadditional_string = "initial root ";\r\nnext_bytenr = btrfs_super_root(super_tmp);\r\nbreak;\r\ncase 1:\r\nbtrfs_set_disk_key_objectid(&tmp_disk_key,\r\nBTRFS_CHUNK_TREE_OBJECTID);\r\nadditional_string = "initial chunk ";\r\nnext_bytenr = btrfs_super_chunk_root(super_tmp);\r\nbreak;\r\ncase 2:\r\nbtrfs_set_disk_key_objectid(&tmp_disk_key,\r\nBTRFS_TREE_LOG_OBJECTID);\r\nadditional_string = "initial log ";\r\nnext_bytenr = btrfs_super_log_root(super_tmp);\r\nif (0 == next_bytenr)\r\ncontinue;\r\nbreak;\r\n}\r\nnum_copies =\r\nbtrfs_num_copies(state->root->fs_info,\r\nnext_bytenr, state->metablock_size);\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\r\nprintk(KERN_INFO "num_copies(log_bytenr=%llu) = %d\n",\r\nnext_bytenr, num_copies);\r\nfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\r\nstruct btrfsic_block *next_block;\r\nstruct btrfsic_block_data_ctx tmp_next_block_ctx;\r\nstruct btrfsic_block_link *l;\r\nif (btrfsic_map_block(state, next_bytenr,\r\nstate->metablock_size,\r\n&tmp_next_block_ctx,\r\nmirror_num)) {\r\nprintk(KERN_INFO "btrfsic: btrfsic_map_block("\r\n"bytenr @%llu, mirror %d) failed!\n",\r\nnext_bytenr, mirror_num);\r\nbrelse(bh);\r\nreturn -1;\r\n}\r\nnext_block = btrfsic_block_lookup_or_add(\r\nstate, &tmp_next_block_ctx,\r\nadditional_string, 1, 1, 0,\r\nmirror_num, NULL);\r\nif (NULL == next_block) {\r\nbtrfsic_release_block_ctx(&tmp_next_block_ctx);\r\nbrelse(bh);\r\nreturn -1;\r\n}\r\nnext_block->disk_key = tmp_disk_key;\r\nnext_block->generation = BTRFSIC_GENERATION_UNKNOWN;\r\nl = btrfsic_block_link_lookup_or_add(\r\nstate, &tmp_next_block_ctx,\r\nnext_block, superblock_tmp,\r\nBTRFSIC_GENERATION_UNKNOWN);\r\nbtrfsic_release_block_ctx(&tmp_next_block_ctx);\r\nif (NULL == l) {\r\nbrelse(bh);\r\nreturn -1;\r\n}\r\n}\r\n}\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_INITIAL_ALL_TREES)\r\nbtrfsic_dump_tree_sub(state, superblock_tmp, 0);\r\nbrelse(bh);\r\nreturn 0;\r\n}\r\nstatic struct btrfsic_stack_frame *btrfsic_stack_frame_alloc(void)\r\n{\r\nstruct btrfsic_stack_frame *sf;\r\nsf = kzalloc(sizeof(*sf), GFP_NOFS);\r\nif (NULL == sf)\r\nprintk(KERN_INFO "btrfsic: alloc memory failed!\n");\r\nelse\r\nsf->magic = BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER;\r\nreturn sf;\r\n}\r\nstatic void btrfsic_stack_frame_free(struct btrfsic_stack_frame *sf)\r\n{\r\nBUG_ON(!(NULL == sf ||\r\nBTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER == sf->magic));\r\nkfree(sf);\r\n}\r\nstatic int btrfsic_process_metablock(\r\nstruct btrfsic_state *state,\r\nstruct btrfsic_block *const first_block,\r\nstruct btrfsic_block_data_ctx *const first_block_ctx,\r\nint first_limit_nesting, int force_iodone_flag)\r\n{\r\nstruct btrfsic_stack_frame initial_stack_frame = { 0 };\r\nstruct btrfsic_stack_frame *sf;\r\nstruct btrfsic_stack_frame *next_stack;\r\nstruct btrfs_header *const first_hdr =\r\n(struct btrfs_header *)first_block_ctx->datav[0];\r\nBUG_ON(!first_hdr);\r\nsf = &initial_stack_frame;\r\nsf->error = 0;\r\nsf->i = -1;\r\nsf->limit_nesting = first_limit_nesting;\r\nsf->block = first_block;\r\nsf->block_ctx = first_block_ctx;\r\nsf->next_block = NULL;\r\nsf->hdr = first_hdr;\r\nsf->prev = NULL;\r\ncontinue_with_new_stack_frame:\r\nsf->block->generation = le64_to_cpu(sf->hdr->generation);\r\nif (0 == sf->hdr->level) {\r\nstruct btrfs_leaf *const leafhdr =\r\n(struct btrfs_leaf *)sf->hdr;\r\nif (-1 == sf->i) {\r\nsf->nr = btrfs_stack_header_nritems(&leafhdr->header);\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nprintk(KERN_INFO\r\n"leaf %llu items %d generation %llu"\r\n" owner %llu\n",\r\nsf->block_ctx->start, sf->nr,\r\nbtrfs_stack_header_generation(\r\n&leafhdr->header),\r\nbtrfs_stack_header_owner(\r\n&leafhdr->header));\r\n}\r\ncontinue_with_current_leaf_stack_frame:\r\nif (0 == sf->num_copies || sf->mirror_num > sf->num_copies) {\r\nsf->i++;\r\nsf->num_copies = 0;\r\n}\r\nif (sf->i < sf->nr) {\r\nstruct btrfs_item disk_item;\r\nu32 disk_item_offset =\r\n(uintptr_t)(leafhdr->items + sf->i) -\r\n(uintptr_t)leafhdr;\r\nstruct btrfs_disk_key *disk_key;\r\nu8 type;\r\nu32 item_offset;\r\nu32 item_size;\r\nif (disk_item_offset + sizeof(struct btrfs_item) >\r\nsf->block_ctx->len) {\r\nleaf_item_out_of_bounce_error:\r\nprintk(KERN_INFO\r\n"btrfsic: leaf item out of bounce at logical %llu, dev %s\n",\r\nsf->block_ctx->start,\r\nsf->block_ctx->dev->name);\r\ngoto one_stack_frame_backwards;\r\n}\r\nbtrfsic_read_from_block_data(sf->block_ctx,\r\n&disk_item,\r\ndisk_item_offset,\r\nsizeof(struct btrfs_item));\r\nitem_offset = btrfs_stack_item_offset(&disk_item);\r\nitem_size = btrfs_stack_item_size(&disk_item);\r\ndisk_key = &disk_item.key;\r\ntype = btrfs_disk_key_type(disk_key);\r\nif (BTRFS_ROOT_ITEM_KEY == type) {\r\nstruct btrfs_root_item root_item;\r\nu32 root_item_offset;\r\nu64 next_bytenr;\r\nroot_item_offset = item_offset +\r\noffsetof(struct btrfs_leaf, items);\r\nif (root_item_offset + item_size >\r\nsf->block_ctx->len)\r\ngoto leaf_item_out_of_bounce_error;\r\nbtrfsic_read_from_block_data(\r\nsf->block_ctx, &root_item,\r\nroot_item_offset,\r\nitem_size);\r\nnext_bytenr = btrfs_root_bytenr(&root_item);\r\nsf->error =\r\nbtrfsic_create_link_to_next_block(\r\nstate,\r\nsf->block,\r\nsf->block_ctx,\r\nnext_bytenr,\r\nsf->limit_nesting,\r\n&sf->next_block_ctx,\r\n&sf->next_block,\r\nforce_iodone_flag,\r\n&sf->num_copies,\r\n&sf->mirror_num,\r\ndisk_key,\r\nbtrfs_root_generation(\r\n&root_item));\r\nif (sf->error)\r\ngoto one_stack_frame_backwards;\r\nif (NULL != sf->next_block) {\r\nstruct btrfs_header *const next_hdr =\r\n(struct btrfs_header *)\r\nsf->next_block_ctx.datav[0];\r\nnext_stack =\r\nbtrfsic_stack_frame_alloc();\r\nif (NULL == next_stack) {\r\nsf->error = -1;\r\nbtrfsic_release_block_ctx(\r\n&sf->\r\nnext_block_ctx);\r\ngoto one_stack_frame_backwards;\r\n}\r\nnext_stack->i = -1;\r\nnext_stack->block = sf->next_block;\r\nnext_stack->block_ctx =\r\n&sf->next_block_ctx;\r\nnext_stack->next_block = NULL;\r\nnext_stack->hdr = next_hdr;\r\nnext_stack->limit_nesting =\r\nsf->limit_nesting - 1;\r\nnext_stack->prev = sf;\r\nsf = next_stack;\r\ngoto continue_with_new_stack_frame;\r\n}\r\n} else if (BTRFS_EXTENT_DATA_KEY == type &&\r\nstate->include_extent_data) {\r\nsf->error = btrfsic_handle_extent_data(\r\nstate,\r\nsf->block,\r\nsf->block_ctx,\r\nitem_offset,\r\nforce_iodone_flag);\r\nif (sf->error)\r\ngoto one_stack_frame_backwards;\r\n}\r\ngoto continue_with_current_leaf_stack_frame;\r\n}\r\n} else {\r\nstruct btrfs_node *const nodehdr = (struct btrfs_node *)sf->hdr;\r\nif (-1 == sf->i) {\r\nsf->nr = btrfs_stack_header_nritems(&nodehdr->header);\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nprintk(KERN_INFO "node %llu level %d items %d"\r\n" generation %llu owner %llu\n",\r\nsf->block_ctx->start,\r\nnodehdr->header.level, sf->nr,\r\nbtrfs_stack_header_generation(\r\n&nodehdr->header),\r\nbtrfs_stack_header_owner(\r\n&nodehdr->header));\r\n}\r\ncontinue_with_current_node_stack_frame:\r\nif (0 == sf->num_copies || sf->mirror_num > sf->num_copies) {\r\nsf->i++;\r\nsf->num_copies = 0;\r\n}\r\nif (sf->i < sf->nr) {\r\nstruct btrfs_key_ptr key_ptr;\r\nu32 key_ptr_offset;\r\nu64 next_bytenr;\r\nkey_ptr_offset = (uintptr_t)(nodehdr->ptrs + sf->i) -\r\n(uintptr_t)nodehdr;\r\nif (key_ptr_offset + sizeof(struct btrfs_key_ptr) >\r\nsf->block_ctx->len) {\r\nprintk(KERN_INFO\r\n"btrfsic: node item out of bounce at logical %llu, dev %s\n",\r\nsf->block_ctx->start,\r\nsf->block_ctx->dev->name);\r\ngoto one_stack_frame_backwards;\r\n}\r\nbtrfsic_read_from_block_data(\r\nsf->block_ctx, &key_ptr, key_ptr_offset,\r\nsizeof(struct btrfs_key_ptr));\r\nnext_bytenr = btrfs_stack_key_blockptr(&key_ptr);\r\nsf->error = btrfsic_create_link_to_next_block(\r\nstate,\r\nsf->block,\r\nsf->block_ctx,\r\nnext_bytenr,\r\nsf->limit_nesting,\r\n&sf->next_block_ctx,\r\n&sf->next_block,\r\nforce_iodone_flag,\r\n&sf->num_copies,\r\n&sf->mirror_num,\r\n&key_ptr.key,\r\nbtrfs_stack_key_generation(&key_ptr));\r\nif (sf->error)\r\ngoto one_stack_frame_backwards;\r\nif (NULL != sf->next_block) {\r\nstruct btrfs_header *const next_hdr =\r\n(struct btrfs_header *)\r\nsf->next_block_ctx.datav[0];\r\nnext_stack = btrfsic_stack_frame_alloc();\r\nif (NULL == next_stack) {\r\nsf->error = -1;\r\ngoto one_stack_frame_backwards;\r\n}\r\nnext_stack->i = -1;\r\nnext_stack->block = sf->next_block;\r\nnext_stack->block_ctx = &sf->next_block_ctx;\r\nnext_stack->next_block = NULL;\r\nnext_stack->hdr = next_hdr;\r\nnext_stack->limit_nesting =\r\nsf->limit_nesting - 1;\r\nnext_stack->prev = sf;\r\nsf = next_stack;\r\ngoto continue_with_new_stack_frame;\r\n}\r\ngoto continue_with_current_node_stack_frame;\r\n}\r\n}\r\none_stack_frame_backwards:\r\nif (NULL != sf->prev) {\r\nstruct btrfsic_stack_frame *const prev = sf->prev;\r\nbtrfsic_release_block_ctx(sf->block_ctx);\r\nif (sf->error) {\r\nprev->error = sf->error;\r\nbtrfsic_stack_frame_free(sf);\r\nsf = prev;\r\ngoto one_stack_frame_backwards;\r\n}\r\nbtrfsic_stack_frame_free(sf);\r\nsf = prev;\r\ngoto continue_with_new_stack_frame;\r\n} else {\r\nBUG_ON(&initial_stack_frame != sf);\r\n}\r\nreturn sf->error;\r\n}\r\nstatic void btrfsic_read_from_block_data(\r\nstruct btrfsic_block_data_ctx *block_ctx,\r\nvoid *dstv, u32 offset, size_t len)\r\n{\r\nsize_t cur;\r\nsize_t offset_in_page;\r\nchar *kaddr;\r\nchar *dst = (char *)dstv;\r\nsize_t start_offset = block_ctx->start & ((u64)PAGE_CACHE_SIZE - 1);\r\nunsigned long i = (start_offset + offset) >> PAGE_CACHE_SHIFT;\r\nWARN_ON(offset + len > block_ctx->len);\r\noffset_in_page = (start_offset + offset) & (PAGE_CACHE_SIZE - 1);\r\nwhile (len > 0) {\r\ncur = min(len, ((size_t)PAGE_CACHE_SIZE - offset_in_page));\r\nBUG_ON(i >= (block_ctx->len + PAGE_CACHE_SIZE - 1) >>\r\nPAGE_CACHE_SHIFT);\r\nkaddr = block_ctx->datav[i];\r\nmemcpy(dst, kaddr + offset_in_page, cur);\r\ndst += cur;\r\nlen -= cur;\r\noffset_in_page = 0;\r\ni++;\r\n}\r\n}\r\nstatic int btrfsic_create_link_to_next_block(\r\nstruct btrfsic_state *state,\r\nstruct btrfsic_block *block,\r\nstruct btrfsic_block_data_ctx *block_ctx,\r\nu64 next_bytenr,\r\nint limit_nesting,\r\nstruct btrfsic_block_data_ctx *next_block_ctx,\r\nstruct btrfsic_block **next_blockp,\r\nint force_iodone_flag,\r\nint *num_copiesp, int *mirror_nump,\r\nstruct btrfs_disk_key *disk_key,\r\nu64 parent_generation)\r\n{\r\nstruct btrfsic_block *next_block = NULL;\r\nint ret;\r\nstruct btrfsic_block_link *l;\r\nint did_alloc_block_link;\r\nint block_was_created;\r\n*next_blockp = NULL;\r\nif (0 == *num_copiesp) {\r\n*num_copiesp =\r\nbtrfs_num_copies(state->root->fs_info,\r\nnext_bytenr, state->metablock_size);\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\r\nprintk(KERN_INFO "num_copies(log_bytenr=%llu) = %d\n",\r\nnext_bytenr, *num_copiesp);\r\n*mirror_nump = 1;\r\n}\r\nif (*mirror_nump > *num_copiesp)\r\nreturn 0;\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nprintk(KERN_INFO\r\n"btrfsic_create_link_to_next_block(mirror_num=%d)\n",\r\n*mirror_nump);\r\nret = btrfsic_map_block(state, next_bytenr,\r\nstate->metablock_size,\r\nnext_block_ctx, *mirror_nump);\r\nif (ret) {\r\nprintk(KERN_INFO\r\n"btrfsic: btrfsic_map_block(@%llu, mirror=%d) failed!\n",\r\nnext_bytenr, *mirror_nump);\r\nbtrfsic_release_block_ctx(next_block_ctx);\r\n*next_blockp = NULL;\r\nreturn -1;\r\n}\r\nnext_block = btrfsic_block_lookup_or_add(state,\r\nnext_block_ctx, "referenced ",\r\n1, force_iodone_flag,\r\n!force_iodone_flag,\r\n*mirror_nump,\r\n&block_was_created);\r\nif (NULL == next_block) {\r\nbtrfsic_release_block_ctx(next_block_ctx);\r\n*next_blockp = NULL;\r\nreturn -1;\r\n}\r\nif (block_was_created) {\r\nl = NULL;\r\nnext_block->generation = BTRFSIC_GENERATION_UNKNOWN;\r\n} else {\r\nif (next_block->logical_bytenr != next_bytenr &&\r\n!(!next_block->is_metadata &&\r\n0 == next_block->logical_bytenr)) {\r\nprintk(KERN_INFO\r\n"Referenced block @%llu (%s/%llu/%d)"\r\n" found in hash table, %c,"\r\n" bytenr mismatch (!= stored %llu).\n",\r\nnext_bytenr, next_block_ctx->dev->name,\r\nnext_block_ctx->dev_bytenr, *mirror_nump,\r\nbtrfsic_get_block_type(state, next_block),\r\nnext_block->logical_bytenr);\r\n} else if (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nprintk(KERN_INFO\r\n"Referenced block @%llu (%s/%llu/%d)"\r\n" found in hash table, %c.\n",\r\nnext_bytenr, next_block_ctx->dev->name,\r\nnext_block_ctx->dev_bytenr, *mirror_nump,\r\nbtrfsic_get_block_type(state, next_block));\r\nnext_block->logical_bytenr = next_bytenr;\r\nnext_block->mirror_num = *mirror_nump;\r\nl = btrfsic_block_link_hashtable_lookup(\r\nnext_block_ctx->dev->bdev,\r\nnext_block_ctx->dev_bytenr,\r\nblock_ctx->dev->bdev,\r\nblock_ctx->dev_bytenr,\r\n&state->block_link_hashtable);\r\n}\r\nnext_block->disk_key = *disk_key;\r\nif (NULL == l) {\r\nl = btrfsic_block_link_alloc();\r\nif (NULL == l) {\r\nprintk(KERN_INFO "btrfsic: error, kmalloc failed!\n");\r\nbtrfsic_release_block_ctx(next_block_ctx);\r\n*next_blockp = NULL;\r\nreturn -1;\r\n}\r\ndid_alloc_block_link = 1;\r\nl->block_ref_to = next_block;\r\nl->block_ref_from = block;\r\nl->ref_cnt = 1;\r\nl->parent_generation = parent_generation;\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nbtrfsic_print_add_link(state, l);\r\nlist_add(&l->node_ref_to, &block->ref_to_list);\r\nlist_add(&l->node_ref_from, &next_block->ref_from_list);\r\nbtrfsic_block_link_hashtable_add(l,\r\n&state->block_link_hashtable);\r\n} else {\r\ndid_alloc_block_link = 0;\r\nif (0 == limit_nesting) {\r\nl->ref_cnt++;\r\nl->parent_generation = parent_generation;\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nbtrfsic_print_add_link(state, l);\r\n}\r\n}\r\nif (limit_nesting > 0 && did_alloc_block_link) {\r\nret = btrfsic_read_block(state, next_block_ctx);\r\nif (ret < (int)next_block_ctx->len) {\r\nprintk(KERN_INFO\r\n"btrfsic: read block @logical %llu failed!\n",\r\nnext_bytenr);\r\nbtrfsic_release_block_ctx(next_block_ctx);\r\n*next_blockp = NULL;\r\nreturn -1;\r\n}\r\n*next_blockp = next_block;\r\n} else {\r\n*next_blockp = NULL;\r\n}\r\n(*mirror_nump)++;\r\nreturn 0;\r\n}\r\nstatic int btrfsic_handle_extent_data(\r\nstruct btrfsic_state *state,\r\nstruct btrfsic_block *block,\r\nstruct btrfsic_block_data_ctx *block_ctx,\r\nu32 item_offset, int force_iodone_flag)\r\n{\r\nint ret;\r\nstruct btrfs_file_extent_item file_extent_item;\r\nu64 file_extent_item_offset;\r\nu64 next_bytenr;\r\nu64 num_bytes;\r\nu64 generation;\r\nstruct btrfsic_block_link *l;\r\nfile_extent_item_offset = offsetof(struct btrfs_leaf, items) +\r\nitem_offset;\r\nif (file_extent_item_offset +\r\noffsetof(struct btrfs_file_extent_item, disk_num_bytes) >\r\nblock_ctx->len) {\r\nprintk(KERN_INFO\r\n"btrfsic: file item out of bounce at logical %llu, dev %s\n",\r\nblock_ctx->start, block_ctx->dev->name);\r\nreturn -1;\r\n}\r\nbtrfsic_read_from_block_data(block_ctx, &file_extent_item,\r\nfile_extent_item_offset,\r\noffsetof(struct btrfs_file_extent_item, disk_num_bytes));\r\nif (BTRFS_FILE_EXTENT_REG != file_extent_item.type ||\r\nbtrfs_stack_file_extent_disk_bytenr(&file_extent_item) == 0) {\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERY_VERBOSE)\r\nprintk(KERN_INFO "extent_data: type %u, disk_bytenr = %llu\n",\r\nfile_extent_item.type,\r\nbtrfs_stack_file_extent_disk_bytenr(\r\n&file_extent_item));\r\nreturn 0;\r\n}\r\nif (file_extent_item_offset + sizeof(struct btrfs_file_extent_item) >\r\nblock_ctx->len) {\r\nprintk(KERN_INFO\r\n"btrfsic: file item out of bounce at logical %llu, dev %s\n",\r\nblock_ctx->start, block_ctx->dev->name);\r\nreturn -1;\r\n}\r\nbtrfsic_read_from_block_data(block_ctx, &file_extent_item,\r\nfile_extent_item_offset,\r\nsizeof(struct btrfs_file_extent_item));\r\nnext_bytenr = btrfs_stack_file_extent_disk_bytenr(&file_extent_item);\r\nif (btrfs_stack_file_extent_compression(&file_extent_item) ==\r\nBTRFS_COMPRESS_NONE) {\r\nnext_bytenr += btrfs_stack_file_extent_offset(&file_extent_item);\r\nnum_bytes = btrfs_stack_file_extent_num_bytes(&file_extent_item);\r\n} else {\r\nnum_bytes = btrfs_stack_file_extent_disk_num_bytes(&file_extent_item);\r\n}\r\ngeneration = btrfs_stack_file_extent_generation(&file_extent_item);\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERY_VERBOSE)\r\nprintk(KERN_INFO "extent_data: type %u, disk_bytenr = %llu,"\r\n" offset = %llu, num_bytes = %llu\n",\r\nfile_extent_item.type,\r\nbtrfs_stack_file_extent_disk_bytenr(&file_extent_item),\r\nbtrfs_stack_file_extent_offset(&file_extent_item),\r\nnum_bytes);\r\nwhile (num_bytes > 0) {\r\nu32 chunk_len;\r\nint num_copies;\r\nint mirror_num;\r\nif (num_bytes > state->datablock_size)\r\nchunk_len = state->datablock_size;\r\nelse\r\nchunk_len = num_bytes;\r\nnum_copies =\r\nbtrfs_num_copies(state->root->fs_info,\r\nnext_bytenr, state->datablock_size);\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\r\nprintk(KERN_INFO "num_copies(log_bytenr=%llu) = %d\n",\r\nnext_bytenr, num_copies);\r\nfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\r\nstruct btrfsic_block_data_ctx next_block_ctx;\r\nstruct btrfsic_block *next_block;\r\nint block_was_created;\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nprintk(KERN_INFO "btrfsic_handle_extent_data("\r\n"mirror_num=%d)\n", mirror_num);\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERY_VERBOSE)\r\nprintk(KERN_INFO\r\n"\tdisk_bytenr = %llu, num_bytes %u\n",\r\nnext_bytenr, chunk_len);\r\nret = btrfsic_map_block(state, next_bytenr,\r\nchunk_len, &next_block_ctx,\r\nmirror_num);\r\nif (ret) {\r\nprintk(KERN_INFO\r\n"btrfsic: btrfsic_map_block(@%llu,"\r\n" mirror=%d) failed!\n",\r\nnext_bytenr, mirror_num);\r\nreturn -1;\r\n}\r\nnext_block = btrfsic_block_lookup_or_add(\r\nstate,\r\n&next_block_ctx,\r\n"referenced ",\r\n0,\r\nforce_iodone_flag,\r\n!force_iodone_flag,\r\nmirror_num,\r\n&block_was_created);\r\nif (NULL == next_block) {\r\nprintk(KERN_INFO\r\n"btrfsic: error, kmalloc failed!\n");\r\nbtrfsic_release_block_ctx(&next_block_ctx);\r\nreturn -1;\r\n}\r\nif (!block_was_created) {\r\nif (next_block->logical_bytenr != next_bytenr &&\r\n!(!next_block->is_metadata &&\r\n0 == next_block->logical_bytenr)) {\r\nprintk(KERN_INFO\r\n"Referenced block"\r\n" @%llu (%s/%llu/%d)"\r\n" found in hash table, D,"\r\n" bytenr mismatch"\r\n" (!= stored %llu).\n",\r\nnext_bytenr,\r\nnext_block_ctx.dev->name,\r\nnext_block_ctx.dev_bytenr,\r\nmirror_num,\r\nnext_block->logical_bytenr);\r\n}\r\nnext_block->logical_bytenr = next_bytenr;\r\nnext_block->mirror_num = mirror_num;\r\n}\r\nl = btrfsic_block_link_lookup_or_add(state,\r\n&next_block_ctx,\r\nnext_block, block,\r\ngeneration);\r\nbtrfsic_release_block_ctx(&next_block_ctx);\r\nif (NULL == l)\r\nreturn -1;\r\n}\r\nnext_bytenr += chunk_len;\r\nnum_bytes -= chunk_len;\r\n}\r\nreturn 0;\r\n}\r\nstatic int btrfsic_map_block(struct btrfsic_state *state, u64 bytenr, u32 len,\r\nstruct btrfsic_block_data_ctx *block_ctx_out,\r\nint mirror_num)\r\n{\r\nint ret;\r\nu64 length;\r\nstruct btrfs_bio *multi = NULL;\r\nstruct btrfs_device *device;\r\nlength = len;\r\nret = btrfs_map_block(state->root->fs_info, READ,\r\nbytenr, &length, &multi, mirror_num);\r\nif (ret) {\r\nblock_ctx_out->start = 0;\r\nblock_ctx_out->dev_bytenr = 0;\r\nblock_ctx_out->len = 0;\r\nblock_ctx_out->dev = NULL;\r\nblock_ctx_out->datav = NULL;\r\nblock_ctx_out->pagev = NULL;\r\nblock_ctx_out->mem_to_free = NULL;\r\nreturn ret;\r\n}\r\ndevice = multi->stripes[0].dev;\r\nblock_ctx_out->dev = btrfsic_dev_state_lookup(device->bdev);\r\nblock_ctx_out->dev_bytenr = multi->stripes[0].physical;\r\nblock_ctx_out->start = bytenr;\r\nblock_ctx_out->len = len;\r\nblock_ctx_out->datav = NULL;\r\nblock_ctx_out->pagev = NULL;\r\nblock_ctx_out->mem_to_free = NULL;\r\nkfree(multi);\r\nif (NULL == block_ctx_out->dev) {\r\nret = -ENXIO;\r\nprintk(KERN_INFO "btrfsic: error, cannot lookup dev (#1)!\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int btrfsic_map_superblock(struct btrfsic_state *state, u64 bytenr,\r\nu32 len, struct block_device *bdev,\r\nstruct btrfsic_block_data_ctx *block_ctx_out)\r\n{\r\nblock_ctx_out->dev = btrfsic_dev_state_lookup(bdev);\r\nblock_ctx_out->dev_bytenr = bytenr;\r\nblock_ctx_out->start = bytenr;\r\nblock_ctx_out->len = len;\r\nblock_ctx_out->datav = NULL;\r\nblock_ctx_out->pagev = NULL;\r\nblock_ctx_out->mem_to_free = NULL;\r\nif (NULL != block_ctx_out->dev) {\r\nreturn 0;\r\n} else {\r\nprintk(KERN_INFO "btrfsic: error, cannot lookup dev (#2)!\n");\r\nreturn -ENXIO;\r\n}\r\n}\r\nstatic void btrfsic_release_block_ctx(struct btrfsic_block_data_ctx *block_ctx)\r\n{\r\nif (block_ctx->mem_to_free) {\r\nunsigned int num_pages;\r\nBUG_ON(!block_ctx->datav);\r\nBUG_ON(!block_ctx->pagev);\r\nnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\r\nPAGE_CACHE_SHIFT;\r\nwhile (num_pages > 0) {\r\nnum_pages--;\r\nif (block_ctx->datav[num_pages]) {\r\nkunmap(block_ctx->pagev[num_pages]);\r\nblock_ctx->datav[num_pages] = NULL;\r\n}\r\nif (block_ctx->pagev[num_pages]) {\r\n__free_page(block_ctx->pagev[num_pages]);\r\nblock_ctx->pagev[num_pages] = NULL;\r\n}\r\n}\r\nkfree(block_ctx->mem_to_free);\r\nblock_ctx->mem_to_free = NULL;\r\nblock_ctx->pagev = NULL;\r\nblock_ctx->datav = NULL;\r\n}\r\n}\r\nstatic int btrfsic_read_block(struct btrfsic_state *state,\r\nstruct btrfsic_block_data_ctx *block_ctx)\r\n{\r\nunsigned int num_pages;\r\nunsigned int i;\r\nu64 dev_bytenr;\r\nint ret;\r\nBUG_ON(block_ctx->datav);\r\nBUG_ON(block_ctx->pagev);\r\nBUG_ON(block_ctx->mem_to_free);\r\nif (block_ctx->dev_bytenr & ((u64)PAGE_CACHE_SIZE - 1)) {\r\nprintk(KERN_INFO\r\n"btrfsic: read_block() with unaligned bytenr %llu\n",\r\nblock_ctx->dev_bytenr);\r\nreturn -1;\r\n}\r\nnum_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>\r\nPAGE_CACHE_SHIFT;\r\nblock_ctx->mem_to_free = kzalloc((sizeof(*block_ctx->datav) +\r\nsizeof(*block_ctx->pagev)) *\r\nnum_pages, GFP_NOFS);\r\nif (!block_ctx->mem_to_free)\r\nreturn -1;\r\nblock_ctx->datav = block_ctx->mem_to_free;\r\nblock_ctx->pagev = (struct page **)(block_ctx->datav + num_pages);\r\nfor (i = 0; i < num_pages; i++) {\r\nblock_ctx->pagev[i] = alloc_page(GFP_NOFS);\r\nif (!block_ctx->pagev[i])\r\nreturn -1;\r\n}\r\ndev_bytenr = block_ctx->dev_bytenr;\r\nfor (i = 0; i < num_pages;) {\r\nstruct bio *bio;\r\nunsigned int j;\r\nbio = btrfs_io_bio_alloc(GFP_NOFS, num_pages - i);\r\nif (!bio) {\r\nprintk(KERN_INFO\r\n"btrfsic: bio_alloc() for %u pages failed!\n",\r\nnum_pages - i);\r\nreturn -1;\r\n}\r\nbio->bi_bdev = block_ctx->dev->bdev;\r\nbio->bi_iter.bi_sector = dev_bytenr >> 9;\r\nfor (j = i; j < num_pages; j++) {\r\nret = bio_add_page(bio, block_ctx->pagev[j],\r\nPAGE_CACHE_SIZE, 0);\r\nif (PAGE_CACHE_SIZE != ret)\r\nbreak;\r\n}\r\nif (j == i) {\r\nprintk(KERN_INFO\r\n"btrfsic: error, failed to add a single page!\n");\r\nreturn -1;\r\n}\r\nif (submit_bio_wait(READ, bio)) {\r\nprintk(KERN_INFO\r\n"btrfsic: read error at logical %llu dev %s!\n",\r\nblock_ctx->start, block_ctx->dev->name);\r\nbio_put(bio);\r\nreturn -1;\r\n}\r\nbio_put(bio);\r\ndev_bytenr += (j - i) * PAGE_CACHE_SIZE;\r\ni = j;\r\n}\r\nfor (i = 0; i < num_pages; i++) {\r\nblock_ctx->datav[i] = kmap(block_ctx->pagev[i]);\r\nif (!block_ctx->datav[i]) {\r\nprintk(KERN_INFO "btrfsic: kmap() failed (dev %s)!\n",\r\nblock_ctx->dev->name);\r\nreturn -1;\r\n}\r\n}\r\nreturn block_ctx->len;\r\n}\r\nstatic void btrfsic_dump_database(struct btrfsic_state *state)\r\n{\r\nstruct list_head *elem_all;\r\nBUG_ON(NULL == state);\r\nprintk(KERN_INFO "all_blocks_list:\n");\r\nlist_for_each(elem_all, &state->all_blocks_list) {\r\nconst struct btrfsic_block *const b_all =\r\nlist_entry(elem_all, struct btrfsic_block,\r\nall_blocks_node);\r\nstruct list_head *elem_ref_to;\r\nstruct list_head *elem_ref_from;\r\nprintk(KERN_INFO "%c-block @%llu (%s/%llu/%d)\n",\r\nbtrfsic_get_block_type(state, b_all),\r\nb_all->logical_bytenr, b_all->dev_state->name,\r\nb_all->dev_bytenr, b_all->mirror_num);\r\nlist_for_each(elem_ref_to, &b_all->ref_to_list) {\r\nconst struct btrfsic_block_link *const l =\r\nlist_entry(elem_ref_to,\r\nstruct btrfsic_block_link,\r\nnode_ref_to);\r\nprintk(KERN_INFO " %c @%llu (%s/%llu/%d)"\r\n" refers %u* to"\r\n" %c @%llu (%s/%llu/%d)\n",\r\nbtrfsic_get_block_type(state, b_all),\r\nb_all->logical_bytenr, b_all->dev_state->name,\r\nb_all->dev_bytenr, b_all->mirror_num,\r\nl->ref_cnt,\r\nbtrfsic_get_block_type(state, l->block_ref_to),\r\nl->block_ref_to->logical_bytenr,\r\nl->block_ref_to->dev_state->name,\r\nl->block_ref_to->dev_bytenr,\r\nl->block_ref_to->mirror_num);\r\n}\r\nlist_for_each(elem_ref_from, &b_all->ref_from_list) {\r\nconst struct btrfsic_block_link *const l =\r\nlist_entry(elem_ref_from,\r\nstruct btrfsic_block_link,\r\nnode_ref_from);\r\nprintk(KERN_INFO " %c @%llu (%s/%llu/%d)"\r\n" is ref %u* from"\r\n" %c @%llu (%s/%llu/%d)\n",\r\nbtrfsic_get_block_type(state, b_all),\r\nb_all->logical_bytenr, b_all->dev_state->name,\r\nb_all->dev_bytenr, b_all->mirror_num,\r\nl->ref_cnt,\r\nbtrfsic_get_block_type(state, l->block_ref_from),\r\nl->block_ref_from->logical_bytenr,\r\nl->block_ref_from->dev_state->name,\r\nl->block_ref_from->dev_bytenr,\r\nl->block_ref_from->mirror_num);\r\n}\r\nprintk(KERN_INFO "\n");\r\n}\r\n}\r\nstatic int btrfsic_test_for_metadata(struct btrfsic_state *state,\r\nchar **datav, unsigned int num_pages)\r\n{\r\nstruct btrfs_header *h;\r\nu8 csum[BTRFS_CSUM_SIZE];\r\nu32 crc = ~(u32)0;\r\nunsigned int i;\r\nif (num_pages * PAGE_CACHE_SIZE < state->metablock_size)\r\nreturn 1;\r\nnum_pages = state->metablock_size >> PAGE_CACHE_SHIFT;\r\nh = (struct btrfs_header *)datav[0];\r\nif (memcmp(h->fsid, state->root->fs_info->fsid, BTRFS_UUID_SIZE))\r\nreturn 1;\r\nfor (i = 0; i < num_pages; i++) {\r\nu8 *data = i ? datav[i] : (datav[i] + BTRFS_CSUM_SIZE);\r\nsize_t sublen = i ? PAGE_CACHE_SIZE :\r\n(PAGE_CACHE_SIZE - BTRFS_CSUM_SIZE);\r\ncrc = btrfs_crc32c(crc, data, sublen);\r\n}\r\nbtrfs_csum_final(crc, csum);\r\nif (memcmp(csum, h->csum, state->csum_size))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void btrfsic_process_written_block(struct btrfsic_dev_state *dev_state,\r\nu64 dev_bytenr, char **mapped_datav,\r\nunsigned int num_pages,\r\nstruct bio *bio, int *bio_is_patched,\r\nstruct buffer_head *bh,\r\nint submit_bio_bh_rw)\r\n{\r\nint is_metadata;\r\nstruct btrfsic_block *block;\r\nstruct btrfsic_block_data_ctx block_ctx;\r\nint ret;\r\nstruct btrfsic_state *state = dev_state->state;\r\nstruct block_device *bdev = dev_state->bdev;\r\nunsigned int processed_len;\r\nif (NULL != bio_is_patched)\r\n*bio_is_patched = 0;\r\nagain:\r\nif (num_pages == 0)\r\nreturn;\r\nprocessed_len = 0;\r\nis_metadata = (0 == btrfsic_test_for_metadata(state, mapped_datav,\r\nnum_pages));\r\nblock = btrfsic_block_hashtable_lookup(bdev, dev_bytenr,\r\n&state->block_hashtable);\r\nif (NULL != block) {\r\nu64 bytenr = 0;\r\nstruct list_head *elem_ref_to;\r\nstruct list_head *tmp_ref_to;\r\nif (block->is_superblock) {\r\nbytenr = btrfs_super_bytenr((struct btrfs_super_block *)\r\nmapped_datav[0]);\r\nif (num_pages * PAGE_CACHE_SIZE <\r\nBTRFS_SUPER_INFO_SIZE) {\r\nprintk(KERN_INFO\r\n"btrfsic: cannot work with too short bios!\n");\r\nreturn;\r\n}\r\nis_metadata = 1;\r\nBUG_ON(BTRFS_SUPER_INFO_SIZE & (PAGE_CACHE_SIZE - 1));\r\nprocessed_len = BTRFS_SUPER_INFO_SIZE;\r\nif (state->print_mask &\r\nBTRFSIC_PRINT_MASK_TREE_BEFORE_SB_WRITE) {\r\nprintk(KERN_INFO\r\n"[before new superblock is written]:\n");\r\nbtrfsic_dump_tree_sub(state, block, 0);\r\n}\r\n}\r\nif (is_metadata) {\r\nif (!block->is_superblock) {\r\nif (num_pages * PAGE_CACHE_SIZE <\r\nstate->metablock_size) {\r\nprintk(KERN_INFO\r\n"btrfsic: cannot work with too short bios!\n");\r\nreturn;\r\n}\r\nprocessed_len = state->metablock_size;\r\nbytenr = btrfs_stack_header_bytenr(\r\n(struct btrfs_header *)\r\nmapped_datav[0]);\r\nbtrfsic_cmp_log_and_dev_bytenr(state, bytenr,\r\ndev_state,\r\ndev_bytenr);\r\n}\r\nif (block->logical_bytenr != bytenr &&\r\n!(!block->is_metadata &&\r\nblock->logical_bytenr == 0))\r\nprintk(KERN_INFO\r\n"Written block @%llu (%s/%llu/%d)"\r\n" found in hash table, %c,"\r\n" bytenr mismatch"\r\n" (!= stored %llu).\n",\r\nbytenr, dev_state->name, dev_bytenr,\r\nblock->mirror_num,\r\nbtrfsic_get_block_type(state, block),\r\nblock->logical_bytenr);\r\nelse if (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nprintk(KERN_INFO\r\n"Written block @%llu (%s/%llu/%d)"\r\n" found in hash table, %c.\n",\r\nbytenr, dev_state->name, dev_bytenr,\r\nblock->mirror_num,\r\nbtrfsic_get_block_type(state, block));\r\nblock->logical_bytenr = bytenr;\r\n} else {\r\nif (num_pages * PAGE_CACHE_SIZE <\r\nstate->datablock_size) {\r\nprintk(KERN_INFO\r\n"btrfsic: cannot work with too short bios!\n");\r\nreturn;\r\n}\r\nprocessed_len = state->datablock_size;\r\nbytenr = block->logical_bytenr;\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nprintk(KERN_INFO\r\n"Written block @%llu (%s/%llu/%d)"\r\n" found in hash table, %c.\n",\r\nbytenr, dev_state->name, dev_bytenr,\r\nblock->mirror_num,\r\nbtrfsic_get_block_type(state, block));\r\n}\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nprintk(KERN_INFO\r\n"ref_to_list: %cE, ref_from_list: %cE\n",\r\nlist_empty(&block->ref_to_list) ? ' ' : '!',\r\nlist_empty(&block->ref_from_list) ? ' ' : '!');\r\nif (btrfsic_is_block_ref_by_superblock(state, block, 0)) {\r\nprintk(KERN_INFO "btrfs: attempt to overwrite %c-block"\r\n" @%llu (%s/%llu/%d), old(gen=%llu,"\r\n" objectid=%llu, type=%d, offset=%llu),"\r\n" new(gen=%llu),"\r\n" which is referenced by most recent superblock"\r\n" (superblockgen=%llu)!\n",\r\nbtrfsic_get_block_type(state, block), bytenr,\r\ndev_state->name, dev_bytenr, block->mirror_num,\r\nblock->generation,\r\nbtrfs_disk_key_objectid(&block->disk_key),\r\nblock->disk_key.type,\r\nbtrfs_disk_key_offset(&block->disk_key),\r\nbtrfs_stack_header_generation(\r\n(struct btrfs_header *) mapped_datav[0]),\r\nstate->max_superblock_generation);\r\nbtrfsic_dump_tree(state);\r\n}\r\nif (!block->is_iodone && !block->never_written) {\r\nprintk(KERN_INFO "btrfs: attempt to overwrite %c-block"\r\n" @%llu (%s/%llu/%d), oldgen=%llu, newgen=%llu,"\r\n" which is not yet iodone!\n",\r\nbtrfsic_get_block_type(state, block), bytenr,\r\ndev_state->name, dev_bytenr, block->mirror_num,\r\nblock->generation,\r\nbtrfs_stack_header_generation(\r\n(struct btrfs_header *)\r\nmapped_datav[0]));\r\nbtrfsic_dump_tree(state);\r\ngoto continue_loop;\r\n}\r\nlist_for_each_safe(elem_ref_to, tmp_ref_to,\r\n&block->ref_to_list) {\r\nstruct btrfsic_block_link *const l =\r\nlist_entry(elem_ref_to,\r\nstruct btrfsic_block_link,\r\nnode_ref_to);\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nbtrfsic_print_rem_link(state, l);\r\nl->ref_cnt--;\r\nif (0 == l->ref_cnt) {\r\nlist_del(&l->node_ref_to);\r\nlist_del(&l->node_ref_from);\r\nbtrfsic_block_link_hashtable_remove(l);\r\nbtrfsic_block_link_free(l);\r\n}\r\n}\r\nif (block->is_superblock)\r\nret = btrfsic_map_superblock(state, bytenr,\r\nprocessed_len,\r\nbdev, &block_ctx);\r\nelse\r\nret = btrfsic_map_block(state, bytenr, processed_len,\r\n&block_ctx, 0);\r\nif (ret) {\r\nprintk(KERN_INFO\r\n"btrfsic: btrfsic_map_block(root @%llu)"\r\n" failed!\n", bytenr);\r\ngoto continue_loop;\r\n}\r\nblock_ctx.datav = mapped_datav;\r\nblock_ctx.dev = dev_state;\r\nblock_ctx.dev_bytenr = dev_bytenr;\r\nif (is_metadata || state->include_extent_data) {\r\nblock->never_written = 0;\r\nblock->iodone_w_error = 0;\r\nif (NULL != bio) {\r\nblock->is_iodone = 0;\r\nBUG_ON(NULL == bio_is_patched);\r\nif (!*bio_is_patched) {\r\nblock->orig_bio_bh_private =\r\nbio->bi_private;\r\nblock->orig_bio_bh_end_io.bio =\r\nbio->bi_end_io;\r\nblock->next_in_same_bio = NULL;\r\nbio->bi_private = block;\r\nbio->bi_end_io = btrfsic_bio_end_io;\r\n*bio_is_patched = 1;\r\n} else {\r\nstruct btrfsic_block *chained_block =\r\n(struct btrfsic_block *)\r\nbio->bi_private;\r\nBUG_ON(NULL == chained_block);\r\nblock->orig_bio_bh_private =\r\nchained_block->orig_bio_bh_private;\r\nblock->orig_bio_bh_end_io.bio =\r\nchained_block->orig_bio_bh_end_io.\r\nbio;\r\nblock->next_in_same_bio = chained_block;\r\nbio->bi_private = block;\r\n}\r\n} else if (NULL != bh) {\r\nblock->is_iodone = 0;\r\nblock->orig_bio_bh_private = bh->b_private;\r\nblock->orig_bio_bh_end_io.bh = bh->b_end_io;\r\nblock->next_in_same_bio = NULL;\r\nbh->b_private = block;\r\nbh->b_end_io = btrfsic_bh_end_io;\r\n} else {\r\nblock->is_iodone = 1;\r\nblock->orig_bio_bh_private = NULL;\r\nblock->orig_bio_bh_end_io.bio = NULL;\r\nblock->next_in_same_bio = NULL;\r\n}\r\n}\r\nblock->flush_gen = dev_state->last_flush_gen + 1;\r\nblock->submit_bio_bh_rw = submit_bio_bh_rw;\r\nif (is_metadata) {\r\nblock->logical_bytenr = bytenr;\r\nblock->is_metadata = 1;\r\nif (block->is_superblock) {\r\nBUG_ON(PAGE_CACHE_SIZE !=\r\nBTRFS_SUPER_INFO_SIZE);\r\nret = btrfsic_process_written_superblock(\r\nstate,\r\nblock,\r\n(struct btrfs_super_block *)\r\nmapped_datav[0]);\r\nif (state->print_mask &\r\nBTRFSIC_PRINT_MASK_TREE_AFTER_SB_WRITE) {\r\nprintk(KERN_INFO\r\n"[after new superblock is written]:\n");\r\nbtrfsic_dump_tree_sub(state, block, 0);\r\n}\r\n} else {\r\nblock->mirror_num = 0;\r\nret = btrfsic_process_metablock(\r\nstate,\r\nblock,\r\n&block_ctx,\r\n0, 0);\r\n}\r\nif (ret)\r\nprintk(KERN_INFO\r\n"btrfsic: btrfsic_process_metablock"\r\n"(root @%llu) failed!\n",\r\ndev_bytenr);\r\n} else {\r\nblock->is_metadata = 0;\r\nblock->mirror_num = 0;\r\nblock->generation = BTRFSIC_GENERATION_UNKNOWN;\r\nif (!state->include_extent_data\r\n&& list_empty(&block->ref_from_list)) {\r\nbtrfsic_block_hashtable_remove(block);\r\nlist_del(&block->all_blocks_node);\r\nbtrfsic_block_free(block);\r\n}\r\n}\r\nbtrfsic_release_block_ctx(&block_ctx);\r\n} else {\r\nu64 bytenr;\r\nif (!is_metadata) {\r\nprocessed_len = state->datablock_size;\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nprintk(KERN_INFO "Written block (%s/%llu/?)"\r\n" !found in hash table, D.\n",\r\ndev_state->name, dev_bytenr);\r\nif (!state->include_extent_data) {\r\ngoto continue_loop;\r\n}\r\nbytenr = 0;\r\nblock_ctx.start = bytenr;\r\nblock_ctx.len = processed_len;\r\nblock_ctx.mem_to_free = NULL;\r\nblock_ctx.pagev = NULL;\r\n} else {\r\nprocessed_len = state->metablock_size;\r\nbytenr = btrfs_stack_header_bytenr(\r\n(struct btrfs_header *)\r\nmapped_datav[0]);\r\nbtrfsic_cmp_log_and_dev_bytenr(state, bytenr, dev_state,\r\ndev_bytenr);\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nprintk(KERN_INFO\r\n"Written block @%llu (%s/%llu/?)"\r\n" !found in hash table, M.\n",\r\nbytenr, dev_state->name, dev_bytenr);\r\nret = btrfsic_map_block(state, bytenr, processed_len,\r\n&block_ctx, 0);\r\nif (ret) {\r\nprintk(KERN_INFO\r\n"btrfsic: btrfsic_map_block(root @%llu)"\r\n" failed!\n",\r\ndev_bytenr);\r\ngoto continue_loop;\r\n}\r\n}\r\nblock_ctx.datav = mapped_datav;\r\nblock_ctx.dev = dev_state;\r\nblock_ctx.dev_bytenr = dev_bytenr;\r\nblock = btrfsic_block_alloc();\r\nif (NULL == block) {\r\nprintk(KERN_INFO "btrfsic: error, kmalloc failed!\n");\r\nbtrfsic_release_block_ctx(&block_ctx);\r\ngoto continue_loop;\r\n}\r\nblock->dev_state = dev_state;\r\nblock->dev_bytenr = dev_bytenr;\r\nblock->logical_bytenr = bytenr;\r\nblock->is_metadata = is_metadata;\r\nblock->never_written = 0;\r\nblock->iodone_w_error = 0;\r\nblock->mirror_num = 0;\r\nblock->flush_gen = dev_state->last_flush_gen + 1;\r\nblock->submit_bio_bh_rw = submit_bio_bh_rw;\r\nif (NULL != bio) {\r\nblock->is_iodone = 0;\r\nBUG_ON(NULL == bio_is_patched);\r\nif (!*bio_is_patched) {\r\nblock->orig_bio_bh_private = bio->bi_private;\r\nblock->orig_bio_bh_end_io.bio = bio->bi_end_io;\r\nblock->next_in_same_bio = NULL;\r\nbio->bi_private = block;\r\nbio->bi_end_io = btrfsic_bio_end_io;\r\n*bio_is_patched = 1;\r\n} else {\r\nstruct btrfsic_block *chained_block =\r\n(struct btrfsic_block *)\r\nbio->bi_private;\r\nBUG_ON(NULL == chained_block);\r\nblock->orig_bio_bh_private =\r\nchained_block->orig_bio_bh_private;\r\nblock->orig_bio_bh_end_io.bio =\r\nchained_block->orig_bio_bh_end_io.bio;\r\nblock->next_in_same_bio = chained_block;\r\nbio->bi_private = block;\r\n}\r\n} else if (NULL != bh) {\r\nblock->is_iodone = 0;\r\nblock->orig_bio_bh_private = bh->b_private;\r\nblock->orig_bio_bh_end_io.bh = bh->b_end_io;\r\nblock->next_in_same_bio = NULL;\r\nbh->b_private = block;\r\nbh->b_end_io = btrfsic_bh_end_io;\r\n} else {\r\nblock->is_iodone = 1;\r\nblock->orig_bio_bh_private = NULL;\r\nblock->orig_bio_bh_end_io.bio = NULL;\r\nblock->next_in_same_bio = NULL;\r\n}\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nprintk(KERN_INFO\r\n"New written %c-block @%llu (%s/%llu/%d)\n",\r\nis_metadata ? 'M' : 'D',\r\nblock->logical_bytenr, block->dev_state->name,\r\nblock->dev_bytenr, block->mirror_num);\r\nlist_add(&block->all_blocks_node, &state->all_blocks_list);\r\nbtrfsic_block_hashtable_add(block, &state->block_hashtable);\r\nif (is_metadata) {\r\nret = btrfsic_process_metablock(state, block,\r\n&block_ctx, 0, 0);\r\nif (ret)\r\nprintk(KERN_INFO\r\n"btrfsic: process_metablock(root @%llu)"\r\n" failed!\n",\r\ndev_bytenr);\r\n}\r\nbtrfsic_release_block_ctx(&block_ctx);\r\n}\r\ncontinue_loop:\r\nBUG_ON(!processed_len);\r\ndev_bytenr += processed_len;\r\nmapped_datav += processed_len >> PAGE_CACHE_SHIFT;\r\nnum_pages -= processed_len >> PAGE_CACHE_SHIFT;\r\ngoto again;\r\n}\r\nstatic void btrfsic_bio_end_io(struct bio *bp, int bio_error_status)\r\n{\r\nstruct btrfsic_block *block = (struct btrfsic_block *)bp->bi_private;\r\nint iodone_w_error;\r\niodone_w_error = 0;\r\nif (bio_error_status)\r\niodone_w_error = 1;\r\nBUG_ON(NULL == block);\r\nbp->bi_private = block->orig_bio_bh_private;\r\nbp->bi_end_io = block->orig_bio_bh_end_io.bio;\r\ndo {\r\nstruct btrfsic_block *next_block;\r\nstruct btrfsic_dev_state *const dev_state = block->dev_state;\r\nif ((dev_state->state->print_mask &\r\nBTRFSIC_PRINT_MASK_END_IO_BIO_BH))\r\nprintk(KERN_INFO\r\n"bio_end_io(err=%d) for %c @%llu (%s/%llu/%d)\n",\r\nbio_error_status,\r\nbtrfsic_get_block_type(dev_state->state, block),\r\nblock->logical_bytenr, dev_state->name,\r\nblock->dev_bytenr, block->mirror_num);\r\nnext_block = block->next_in_same_bio;\r\nblock->iodone_w_error = iodone_w_error;\r\nif (block->submit_bio_bh_rw & REQ_FLUSH) {\r\ndev_state->last_flush_gen++;\r\nif ((dev_state->state->print_mask &\r\nBTRFSIC_PRINT_MASK_END_IO_BIO_BH))\r\nprintk(KERN_INFO\r\n"bio_end_io() new %s flush_gen=%llu\n",\r\ndev_state->name,\r\ndev_state->last_flush_gen);\r\n}\r\nif (block->submit_bio_bh_rw & REQ_FUA)\r\nblock->flush_gen = 0;\r\nblock->is_iodone = 1;\r\nblock = next_block;\r\n} while (NULL != block);\r\nbp->bi_end_io(bp, bio_error_status);\r\n}\r\nstatic void btrfsic_bh_end_io(struct buffer_head *bh, int uptodate)\r\n{\r\nstruct btrfsic_block *block = (struct btrfsic_block *)bh->b_private;\r\nint iodone_w_error = !uptodate;\r\nstruct btrfsic_dev_state *dev_state;\r\nBUG_ON(NULL == block);\r\ndev_state = block->dev_state;\r\nif ((dev_state->state->print_mask & BTRFSIC_PRINT_MASK_END_IO_BIO_BH))\r\nprintk(KERN_INFO\r\n"bh_end_io(error=%d) for %c @%llu (%s/%llu/%d)\n",\r\niodone_w_error,\r\nbtrfsic_get_block_type(dev_state->state, block),\r\nblock->logical_bytenr, block->dev_state->name,\r\nblock->dev_bytenr, block->mirror_num);\r\nblock->iodone_w_error = iodone_w_error;\r\nif (block->submit_bio_bh_rw & REQ_FLUSH) {\r\ndev_state->last_flush_gen++;\r\nif ((dev_state->state->print_mask &\r\nBTRFSIC_PRINT_MASK_END_IO_BIO_BH))\r\nprintk(KERN_INFO\r\n"bh_end_io() new %s flush_gen=%llu\n",\r\ndev_state->name, dev_state->last_flush_gen);\r\n}\r\nif (block->submit_bio_bh_rw & REQ_FUA)\r\nblock->flush_gen = 0;\r\nbh->b_private = block->orig_bio_bh_private;\r\nbh->b_end_io = block->orig_bio_bh_end_io.bh;\r\nblock->is_iodone = 1;\r\nbh->b_end_io(bh, uptodate);\r\n}\r\nstatic int btrfsic_process_written_superblock(\r\nstruct btrfsic_state *state,\r\nstruct btrfsic_block *const superblock,\r\nstruct btrfs_super_block *const super_hdr)\r\n{\r\nint pass;\r\nsuperblock->generation = btrfs_super_generation(super_hdr);\r\nif (!(superblock->generation > state->max_superblock_generation ||\r\n0 == state->max_superblock_generation)) {\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE)\r\nprintk(KERN_INFO\r\n"btrfsic: superblock @%llu (%s/%llu/%d)"\r\n" with old gen %llu <= %llu\n",\r\nsuperblock->logical_bytenr,\r\nsuperblock->dev_state->name,\r\nsuperblock->dev_bytenr, superblock->mirror_num,\r\nbtrfs_super_generation(super_hdr),\r\nstate->max_superblock_generation);\r\n} else {\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE)\r\nprintk(KERN_INFO\r\n"btrfsic: got new superblock @%llu (%s/%llu/%d)"\r\n" with new gen %llu > %llu\n",\r\nsuperblock->logical_bytenr,\r\nsuperblock->dev_state->name,\r\nsuperblock->dev_bytenr, superblock->mirror_num,\r\nbtrfs_super_generation(super_hdr),\r\nstate->max_superblock_generation);\r\nstate->max_superblock_generation =\r\nbtrfs_super_generation(super_hdr);\r\nstate->latest_superblock = superblock;\r\n}\r\nfor (pass = 0; pass < 3; pass++) {\r\nint ret;\r\nu64 next_bytenr;\r\nstruct btrfsic_block *next_block;\r\nstruct btrfsic_block_data_ctx tmp_next_block_ctx;\r\nstruct btrfsic_block_link *l;\r\nint num_copies;\r\nint mirror_num;\r\nconst char *additional_string = NULL;\r\nstruct btrfs_disk_key tmp_disk_key = {0};\r\nbtrfs_set_disk_key_objectid(&tmp_disk_key,\r\nBTRFS_ROOT_ITEM_KEY);\r\nbtrfs_set_disk_key_objectid(&tmp_disk_key, 0);\r\nswitch (pass) {\r\ncase 0:\r\nbtrfs_set_disk_key_objectid(&tmp_disk_key,\r\nBTRFS_ROOT_TREE_OBJECTID);\r\nadditional_string = "root ";\r\nnext_bytenr = btrfs_super_root(super_hdr);\r\nif (state->print_mask &\r\nBTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\r\nprintk(KERN_INFO "root@%llu\n", next_bytenr);\r\nbreak;\r\ncase 1:\r\nbtrfs_set_disk_key_objectid(&tmp_disk_key,\r\nBTRFS_CHUNK_TREE_OBJECTID);\r\nadditional_string = "chunk ";\r\nnext_bytenr = btrfs_super_chunk_root(super_hdr);\r\nif (state->print_mask &\r\nBTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\r\nprintk(KERN_INFO "chunk@%llu\n", next_bytenr);\r\nbreak;\r\ncase 2:\r\nbtrfs_set_disk_key_objectid(&tmp_disk_key,\r\nBTRFS_TREE_LOG_OBJECTID);\r\nadditional_string = "log ";\r\nnext_bytenr = btrfs_super_log_root(super_hdr);\r\nif (0 == next_bytenr)\r\ncontinue;\r\nif (state->print_mask &\r\nBTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION)\r\nprintk(KERN_INFO "log@%llu\n", next_bytenr);\r\nbreak;\r\n}\r\nnum_copies =\r\nbtrfs_num_copies(state->root->fs_info,\r\nnext_bytenr, BTRFS_SUPER_INFO_SIZE);\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_NUM_COPIES)\r\nprintk(KERN_INFO "num_copies(log_bytenr=%llu) = %d\n",\r\nnext_bytenr, num_copies);\r\nfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\r\nint was_created;\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nprintk(KERN_INFO\r\n"btrfsic_process_written_superblock("\r\n"mirror_num=%d)\n", mirror_num);\r\nret = btrfsic_map_block(state, next_bytenr,\r\nBTRFS_SUPER_INFO_SIZE,\r\n&tmp_next_block_ctx,\r\nmirror_num);\r\nif (ret) {\r\nprintk(KERN_INFO\r\n"btrfsic: btrfsic_map_block(@%llu,"\r\n" mirror=%d) failed!\n",\r\nnext_bytenr, mirror_num);\r\nreturn -1;\r\n}\r\nnext_block = btrfsic_block_lookup_or_add(\r\nstate,\r\n&tmp_next_block_ctx,\r\nadditional_string,\r\n1, 0, 1,\r\nmirror_num,\r\n&was_created);\r\nif (NULL == next_block) {\r\nprintk(KERN_INFO\r\n"btrfsic: error, kmalloc failed!\n");\r\nbtrfsic_release_block_ctx(&tmp_next_block_ctx);\r\nreturn -1;\r\n}\r\nnext_block->disk_key = tmp_disk_key;\r\nif (was_created)\r\nnext_block->generation =\r\nBTRFSIC_GENERATION_UNKNOWN;\r\nl = btrfsic_block_link_lookup_or_add(\r\nstate,\r\n&tmp_next_block_ctx,\r\nnext_block,\r\nsuperblock,\r\nBTRFSIC_GENERATION_UNKNOWN);\r\nbtrfsic_release_block_ctx(&tmp_next_block_ctx);\r\nif (NULL == l)\r\nreturn -1;\r\n}\r\n}\r\nif (WARN_ON(-1 == btrfsic_check_all_ref_blocks(state, superblock, 0)))\r\nbtrfsic_dump_tree(state);\r\nreturn 0;\r\n}\r\nstatic int btrfsic_check_all_ref_blocks(struct btrfsic_state *state,\r\nstruct btrfsic_block *const block,\r\nint recursion_level)\r\n{\r\nstruct list_head *elem_ref_to;\r\nint ret = 0;\r\nif (recursion_level >= 3 + BTRFS_MAX_LEVEL) {\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nprintk(KERN_INFO\r\n"btrfsic: abort cyclic linkage (case 1).\n");\r\nreturn ret;\r\n}\r\nlist_for_each(elem_ref_to, &block->ref_to_list) {\r\nconst struct btrfsic_block_link *const l =\r\nlist_entry(elem_ref_to, struct btrfsic_block_link,\r\nnode_ref_to);\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nprintk(KERN_INFO\r\n"rl=%d, %c @%llu (%s/%llu/%d)"\r\n" %u* refers to %c @%llu (%s/%llu/%d)\n",\r\nrecursion_level,\r\nbtrfsic_get_block_type(state, block),\r\nblock->logical_bytenr, block->dev_state->name,\r\nblock->dev_bytenr, block->mirror_num,\r\nl->ref_cnt,\r\nbtrfsic_get_block_type(state, l->block_ref_to),\r\nl->block_ref_to->logical_bytenr,\r\nl->block_ref_to->dev_state->name,\r\nl->block_ref_to->dev_bytenr,\r\nl->block_ref_to->mirror_num);\r\nif (l->block_ref_to->never_written) {\r\nprintk(KERN_INFO "btrfs: attempt to write superblock"\r\n" which references block %c @%llu (%s/%llu/%d)"\r\n" which is never written!\n",\r\nbtrfsic_get_block_type(state, l->block_ref_to),\r\nl->block_ref_to->logical_bytenr,\r\nl->block_ref_to->dev_state->name,\r\nl->block_ref_to->dev_bytenr,\r\nl->block_ref_to->mirror_num);\r\nret = -1;\r\n} else if (!l->block_ref_to->is_iodone) {\r\nprintk(KERN_INFO "btrfs: attempt to write superblock"\r\n" which references block %c @%llu (%s/%llu/%d)"\r\n" which is not yet iodone!\n",\r\nbtrfsic_get_block_type(state, l->block_ref_to),\r\nl->block_ref_to->logical_bytenr,\r\nl->block_ref_to->dev_state->name,\r\nl->block_ref_to->dev_bytenr,\r\nl->block_ref_to->mirror_num);\r\nret = -1;\r\n} else if (l->block_ref_to->iodone_w_error) {\r\nprintk(KERN_INFO "btrfs: attempt to write superblock"\r\n" which references block %c @%llu (%s/%llu/%d)"\r\n" which has write error!\n",\r\nbtrfsic_get_block_type(state, l->block_ref_to),\r\nl->block_ref_to->logical_bytenr,\r\nl->block_ref_to->dev_state->name,\r\nl->block_ref_to->dev_bytenr,\r\nl->block_ref_to->mirror_num);\r\nret = -1;\r\n} else if (l->parent_generation !=\r\nl->block_ref_to->generation &&\r\nBTRFSIC_GENERATION_UNKNOWN !=\r\nl->parent_generation &&\r\nBTRFSIC_GENERATION_UNKNOWN !=\r\nl->block_ref_to->generation) {\r\nprintk(KERN_INFO "btrfs: attempt to write superblock"\r\n" which references block %c @%llu (%s/%llu/%d)"\r\n" with generation %llu !="\r\n" parent generation %llu!\n",\r\nbtrfsic_get_block_type(state, l->block_ref_to),\r\nl->block_ref_to->logical_bytenr,\r\nl->block_ref_to->dev_state->name,\r\nl->block_ref_to->dev_bytenr,\r\nl->block_ref_to->mirror_num,\r\nl->block_ref_to->generation,\r\nl->parent_generation);\r\nret = -1;\r\n} else if (l->block_ref_to->flush_gen >\r\nl->block_ref_to->dev_state->last_flush_gen) {\r\nprintk(KERN_INFO "btrfs: attempt to write superblock"\r\n" which references block %c @%llu (%s/%llu/%d)"\r\n" which is not flushed out of disk's write cache"\r\n" (block flush_gen=%llu,"\r\n" dev->flush_gen=%llu)!\n",\r\nbtrfsic_get_block_type(state, l->block_ref_to),\r\nl->block_ref_to->logical_bytenr,\r\nl->block_ref_to->dev_state->name,\r\nl->block_ref_to->dev_bytenr,\r\nl->block_ref_to->mirror_num, block->flush_gen,\r\nl->block_ref_to->dev_state->last_flush_gen);\r\nret = -1;\r\n} else if (-1 == btrfsic_check_all_ref_blocks(state,\r\nl->block_ref_to,\r\nrecursion_level +\r\n1)) {\r\nret = -1;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int btrfsic_is_block_ref_by_superblock(\r\nconst struct btrfsic_state *state,\r\nconst struct btrfsic_block *block,\r\nint recursion_level)\r\n{\r\nstruct list_head *elem_ref_from;\r\nif (recursion_level >= 3 + BTRFS_MAX_LEVEL) {\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nprintk(KERN_INFO\r\n"btrfsic: abort cyclic linkage (case 2).\n");\r\nreturn 0;\r\n}\r\nlist_for_each(elem_ref_from, &block->ref_from_list) {\r\nconst struct btrfsic_block_link *const l =\r\nlist_entry(elem_ref_from, struct btrfsic_block_link,\r\nnode_ref_from);\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nprintk(KERN_INFO\r\n"rl=%d, %c @%llu (%s/%llu/%d)"\r\n" is ref %u* from %c @%llu (%s/%llu/%d)\n",\r\nrecursion_level,\r\nbtrfsic_get_block_type(state, block),\r\nblock->logical_bytenr, block->dev_state->name,\r\nblock->dev_bytenr, block->mirror_num,\r\nl->ref_cnt,\r\nbtrfsic_get_block_type(state, l->block_ref_from),\r\nl->block_ref_from->logical_bytenr,\r\nl->block_ref_from->dev_state->name,\r\nl->block_ref_from->dev_bytenr,\r\nl->block_ref_from->mirror_num);\r\nif (l->block_ref_from->is_superblock &&\r\nstate->latest_superblock->dev_bytenr ==\r\nl->block_ref_from->dev_bytenr &&\r\nstate->latest_superblock->dev_state->bdev ==\r\nl->block_ref_from->dev_state->bdev)\r\nreturn 1;\r\nelse if (btrfsic_is_block_ref_by_superblock(state,\r\nl->block_ref_from,\r\nrecursion_level +\r\n1))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void btrfsic_print_add_link(const struct btrfsic_state *state,\r\nconst struct btrfsic_block_link *l)\r\n{\r\nprintk(KERN_INFO\r\n"Add %u* link from %c @%llu (%s/%llu/%d)"\r\n" to %c @%llu (%s/%llu/%d).\n",\r\nl->ref_cnt,\r\nbtrfsic_get_block_type(state, l->block_ref_from),\r\nl->block_ref_from->logical_bytenr,\r\nl->block_ref_from->dev_state->name,\r\nl->block_ref_from->dev_bytenr, l->block_ref_from->mirror_num,\r\nbtrfsic_get_block_type(state, l->block_ref_to),\r\nl->block_ref_to->logical_bytenr,\r\nl->block_ref_to->dev_state->name, l->block_ref_to->dev_bytenr,\r\nl->block_ref_to->mirror_num);\r\n}\r\nstatic void btrfsic_print_rem_link(const struct btrfsic_state *state,\r\nconst struct btrfsic_block_link *l)\r\n{\r\nprintk(KERN_INFO\r\n"Rem %u* link from %c @%llu (%s/%llu/%d)"\r\n" to %c @%llu (%s/%llu/%d).\n",\r\nl->ref_cnt,\r\nbtrfsic_get_block_type(state, l->block_ref_from),\r\nl->block_ref_from->logical_bytenr,\r\nl->block_ref_from->dev_state->name,\r\nl->block_ref_from->dev_bytenr, l->block_ref_from->mirror_num,\r\nbtrfsic_get_block_type(state, l->block_ref_to),\r\nl->block_ref_to->logical_bytenr,\r\nl->block_ref_to->dev_state->name, l->block_ref_to->dev_bytenr,\r\nl->block_ref_to->mirror_num);\r\n}\r\nstatic char btrfsic_get_block_type(const struct btrfsic_state *state,\r\nconst struct btrfsic_block *block)\r\n{\r\nif (block->is_superblock &&\r\nstate->latest_superblock->dev_bytenr == block->dev_bytenr &&\r\nstate->latest_superblock->dev_state->bdev == block->dev_state->bdev)\r\nreturn 'S';\r\nelse if (block->is_superblock)\r\nreturn 's';\r\nelse if (block->is_metadata)\r\nreturn 'M';\r\nelse\r\nreturn 'D';\r\n}\r\nstatic void btrfsic_dump_tree(const struct btrfsic_state *state)\r\n{\r\nbtrfsic_dump_tree_sub(state, state->latest_superblock, 0);\r\n}\r\nstatic void btrfsic_dump_tree_sub(const struct btrfsic_state *state,\r\nconst struct btrfsic_block *block,\r\nint indent_level)\r\n{\r\nstruct list_head *elem_ref_to;\r\nint indent_add;\r\nstatic char buf[80];\r\nint cursor_position;\r\nindent_add = sprintf(buf, "%c-%llu(%s/%llu/%d)",\r\nbtrfsic_get_block_type(state, block),\r\nblock->logical_bytenr, block->dev_state->name,\r\nblock->dev_bytenr, block->mirror_num);\r\nif (indent_level + indent_add > BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\r\nprintk("[...]\n");\r\nreturn;\r\n}\r\nprintk(buf);\r\nindent_level += indent_add;\r\nif (list_empty(&block->ref_to_list)) {\r\nprintk("\n");\r\nreturn;\r\n}\r\nif (block->mirror_num > 1 &&\r\n!(state->print_mask & BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS)) {\r\nprintk(" [...]\n");\r\nreturn;\r\n}\r\ncursor_position = indent_level;\r\nlist_for_each(elem_ref_to, &block->ref_to_list) {\r\nconst struct btrfsic_block_link *const l =\r\nlist_entry(elem_ref_to, struct btrfsic_block_link,\r\nnode_ref_to);\r\nwhile (cursor_position < indent_level) {\r\nprintk(" ");\r\ncursor_position++;\r\n}\r\nif (l->ref_cnt > 1)\r\nindent_add = sprintf(buf, " %d*--> ", l->ref_cnt);\r\nelse\r\nindent_add = sprintf(buf, " --> ");\r\nif (indent_level + indent_add >\r\nBTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL) {\r\nprintk("[...]\n");\r\ncursor_position = 0;\r\ncontinue;\r\n}\r\nprintk(buf);\r\nbtrfsic_dump_tree_sub(state, l->block_ref_to,\r\nindent_level + indent_add);\r\ncursor_position = 0;\r\n}\r\n}\r\nstatic struct btrfsic_block_link *btrfsic_block_link_lookup_or_add(\r\nstruct btrfsic_state *state,\r\nstruct btrfsic_block_data_ctx *next_block_ctx,\r\nstruct btrfsic_block *next_block,\r\nstruct btrfsic_block *from_block,\r\nu64 parent_generation)\r\n{\r\nstruct btrfsic_block_link *l;\r\nl = btrfsic_block_link_hashtable_lookup(next_block_ctx->dev->bdev,\r\nnext_block_ctx->dev_bytenr,\r\nfrom_block->dev_state->bdev,\r\nfrom_block->dev_bytenr,\r\n&state->block_link_hashtable);\r\nif (NULL == l) {\r\nl = btrfsic_block_link_alloc();\r\nif (NULL == l) {\r\nprintk(KERN_INFO\r\n"btrfsic: error, kmalloc" " failed!\n");\r\nreturn NULL;\r\n}\r\nl->block_ref_to = next_block;\r\nl->block_ref_from = from_block;\r\nl->ref_cnt = 1;\r\nl->parent_generation = parent_generation;\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nbtrfsic_print_add_link(state, l);\r\nlist_add(&l->node_ref_to, &from_block->ref_to_list);\r\nlist_add(&l->node_ref_from, &next_block->ref_from_list);\r\nbtrfsic_block_link_hashtable_add(l,\r\n&state->block_link_hashtable);\r\n} else {\r\nl->ref_cnt++;\r\nl->parent_generation = parent_generation;\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nbtrfsic_print_add_link(state, l);\r\n}\r\nreturn l;\r\n}\r\nstatic struct btrfsic_block *btrfsic_block_lookup_or_add(\r\nstruct btrfsic_state *state,\r\nstruct btrfsic_block_data_ctx *block_ctx,\r\nconst char *additional_string,\r\nint is_metadata,\r\nint is_iodone,\r\nint never_written,\r\nint mirror_num,\r\nint *was_created)\r\n{\r\nstruct btrfsic_block *block;\r\nblock = btrfsic_block_hashtable_lookup(block_ctx->dev->bdev,\r\nblock_ctx->dev_bytenr,\r\n&state->block_hashtable);\r\nif (NULL == block) {\r\nstruct btrfsic_dev_state *dev_state;\r\nblock = btrfsic_block_alloc();\r\nif (NULL == block) {\r\nprintk(KERN_INFO "btrfsic: error, kmalloc failed!\n");\r\nreturn NULL;\r\n}\r\ndev_state = btrfsic_dev_state_lookup(block_ctx->dev->bdev);\r\nif (NULL == dev_state) {\r\nprintk(KERN_INFO\r\n"btrfsic: error, lookup dev_state failed!\n");\r\nbtrfsic_block_free(block);\r\nreturn NULL;\r\n}\r\nblock->dev_state = dev_state;\r\nblock->dev_bytenr = block_ctx->dev_bytenr;\r\nblock->logical_bytenr = block_ctx->start;\r\nblock->is_metadata = is_metadata;\r\nblock->is_iodone = is_iodone;\r\nblock->never_written = never_written;\r\nblock->mirror_num = mirror_num;\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nprintk(KERN_INFO\r\n"New %s%c-block @%llu (%s/%llu/%d)\n",\r\nadditional_string,\r\nbtrfsic_get_block_type(state, block),\r\nblock->logical_bytenr, dev_state->name,\r\nblock->dev_bytenr, mirror_num);\r\nlist_add(&block->all_blocks_node, &state->all_blocks_list);\r\nbtrfsic_block_hashtable_add(block, &state->block_hashtable);\r\nif (NULL != was_created)\r\n*was_created = 1;\r\n} else {\r\nif (NULL != was_created)\r\n*was_created = 0;\r\n}\r\nreturn block;\r\n}\r\nstatic void btrfsic_cmp_log_and_dev_bytenr(struct btrfsic_state *state,\r\nu64 bytenr,\r\nstruct btrfsic_dev_state *dev_state,\r\nu64 dev_bytenr)\r\n{\r\nint num_copies;\r\nint mirror_num;\r\nint ret;\r\nstruct btrfsic_block_data_ctx block_ctx;\r\nint match = 0;\r\nnum_copies = btrfs_num_copies(state->root->fs_info,\r\nbytenr, state->metablock_size);\r\nfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\r\nret = btrfsic_map_block(state, bytenr, state->metablock_size,\r\n&block_ctx, mirror_num);\r\nif (ret) {\r\nprintk(KERN_INFO "btrfsic:"\r\n" btrfsic_map_block(logical @%llu,"\r\n" mirror %d) failed!\n",\r\nbytenr, mirror_num);\r\ncontinue;\r\n}\r\nif (dev_state->bdev == block_ctx.dev->bdev &&\r\ndev_bytenr == block_ctx.dev_bytenr) {\r\nmatch++;\r\nbtrfsic_release_block_ctx(&block_ctx);\r\nbreak;\r\n}\r\nbtrfsic_release_block_ctx(&block_ctx);\r\n}\r\nif (WARN_ON(!match)) {\r\nprintk(KERN_INFO "btrfs: attempt to write M-block which contains logical bytenr that doesn't map to dev+physical bytenr of submit_bio,"\r\n" buffer->log_bytenr=%llu, submit_bio(bdev=%s,"\r\n" phys_bytenr=%llu)!\n",\r\nbytenr, dev_state->name, dev_bytenr);\r\nfor (mirror_num = 1; mirror_num <= num_copies; mirror_num++) {\r\nret = btrfsic_map_block(state, bytenr,\r\nstate->metablock_size,\r\n&block_ctx, mirror_num);\r\nif (ret)\r\ncontinue;\r\nprintk(KERN_INFO "Read logical bytenr @%llu maps to"\r\n" (%s/%llu/%d)\n",\r\nbytenr, block_ctx.dev->name,\r\nblock_ctx.dev_bytenr, mirror_num);\r\n}\r\n}\r\n}\r\nstatic struct btrfsic_dev_state *btrfsic_dev_state_lookup(\r\nstruct block_device *bdev)\r\n{\r\nstruct btrfsic_dev_state *ds;\r\nds = btrfsic_dev_state_hashtable_lookup(bdev,\r\n&btrfsic_dev_state_hashtable);\r\nreturn ds;\r\n}\r\nint btrfsic_submit_bh(int rw, struct buffer_head *bh)\r\n{\r\nstruct btrfsic_dev_state *dev_state;\r\nif (!btrfsic_is_initialized)\r\nreturn submit_bh(rw, bh);\r\nmutex_lock(&btrfsic_mutex);\r\ndev_state = btrfsic_dev_state_lookup(bh->b_bdev);\r\nif (NULL != dev_state &&\r\n(rw & WRITE) && bh->b_size > 0) {\r\nu64 dev_bytenr;\r\ndev_bytenr = 4096 * bh->b_blocknr;\r\nif (dev_state->state->print_mask &\r\nBTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\r\nprintk(KERN_INFO\r\n"submit_bh(rw=0x%x, blocknr=%llu (bytenr %llu),"\r\n" size=%zu, data=%p, bdev=%p)\n",\r\nrw, (unsigned long long)bh->b_blocknr,\r\ndev_bytenr, bh->b_size, bh->b_data, bh->b_bdev);\r\nbtrfsic_process_written_block(dev_state, dev_bytenr,\r\n&bh->b_data, 1, NULL,\r\nNULL, bh, rw);\r\n} else if (NULL != dev_state && (rw & REQ_FLUSH)) {\r\nif (dev_state->state->print_mask &\r\nBTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\r\nprintk(KERN_INFO\r\n"submit_bh(rw=0x%x FLUSH, bdev=%p)\n",\r\nrw, bh->b_bdev);\r\nif (!dev_state->dummy_block_for_bio_bh_flush.is_iodone) {\r\nif ((dev_state->state->print_mask &\r\n(BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH |\r\nBTRFSIC_PRINT_MASK_VERBOSE)))\r\nprintk(KERN_INFO\r\n"btrfsic_submit_bh(%s) with FLUSH"\r\n" but dummy block already in use"\r\n" (ignored)!\n",\r\ndev_state->name);\r\n} else {\r\nstruct btrfsic_block *const block =\r\n&dev_state->dummy_block_for_bio_bh_flush;\r\nblock->is_iodone = 0;\r\nblock->never_written = 0;\r\nblock->iodone_w_error = 0;\r\nblock->flush_gen = dev_state->last_flush_gen + 1;\r\nblock->submit_bio_bh_rw = rw;\r\nblock->orig_bio_bh_private = bh->b_private;\r\nblock->orig_bio_bh_end_io.bh = bh->b_end_io;\r\nblock->next_in_same_bio = NULL;\r\nbh->b_private = block;\r\nbh->b_end_io = btrfsic_bh_end_io;\r\n}\r\n}\r\nmutex_unlock(&btrfsic_mutex);\r\nreturn submit_bh(rw, bh);\r\n}\r\nstatic void __btrfsic_submit_bio(int rw, struct bio *bio)\r\n{\r\nstruct btrfsic_dev_state *dev_state;\r\nif (!btrfsic_is_initialized)\r\nreturn;\r\nmutex_lock(&btrfsic_mutex);\r\ndev_state = btrfsic_dev_state_lookup(bio->bi_bdev);\r\nif (NULL != dev_state &&\r\n(rw & WRITE) && NULL != bio->bi_io_vec) {\r\nunsigned int i;\r\nu64 dev_bytenr;\r\nu64 cur_bytenr;\r\nint bio_is_patched;\r\nchar **mapped_datav;\r\ndev_bytenr = 512 * bio->bi_iter.bi_sector;\r\nbio_is_patched = 0;\r\nif (dev_state->state->print_mask &\r\nBTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\r\nprintk(KERN_INFO\r\n"submit_bio(rw=0x%x, bi_vcnt=%u,"\r\n" bi_sector=%llu (bytenr %llu), bi_bdev=%p)\n",\r\nrw, bio->bi_vcnt,\r\n(unsigned long long)bio->bi_iter.bi_sector,\r\ndev_bytenr, bio->bi_bdev);\r\nmapped_datav = kmalloc(sizeof(*mapped_datav) * bio->bi_vcnt,\r\nGFP_NOFS);\r\nif (!mapped_datav)\r\ngoto leave;\r\ncur_bytenr = dev_bytenr;\r\nfor (i = 0; i < bio->bi_vcnt; i++) {\r\nBUG_ON(bio->bi_io_vec[i].bv_len != PAGE_CACHE_SIZE);\r\nmapped_datav[i] = kmap(bio->bi_io_vec[i].bv_page);\r\nif (!mapped_datav[i]) {\r\nwhile (i > 0) {\r\ni--;\r\nkunmap(bio->bi_io_vec[i].bv_page);\r\n}\r\nkfree(mapped_datav);\r\ngoto leave;\r\n}\r\nif (dev_state->state->print_mask &\r\nBTRFSIC_PRINT_MASK_SUBMIT_BIO_BH_VERBOSE)\r\nprintk(KERN_INFO\r\n"#%u: bytenr=%llu, len=%u, offset=%u\n",\r\ni, cur_bytenr, bio->bi_io_vec[i].bv_len,\r\nbio->bi_io_vec[i].bv_offset);\r\ncur_bytenr += bio->bi_io_vec[i].bv_len;\r\n}\r\nbtrfsic_process_written_block(dev_state, dev_bytenr,\r\nmapped_datav, bio->bi_vcnt,\r\nbio, &bio_is_patched,\r\nNULL, rw);\r\nwhile (i > 0) {\r\ni--;\r\nkunmap(bio->bi_io_vec[i].bv_page);\r\n}\r\nkfree(mapped_datav);\r\n} else if (NULL != dev_state && (rw & REQ_FLUSH)) {\r\nif (dev_state->state->print_mask &\r\nBTRFSIC_PRINT_MASK_SUBMIT_BIO_BH)\r\nprintk(KERN_INFO\r\n"submit_bio(rw=0x%x FLUSH, bdev=%p)\n",\r\nrw, bio->bi_bdev);\r\nif (!dev_state->dummy_block_for_bio_bh_flush.is_iodone) {\r\nif ((dev_state->state->print_mask &\r\n(BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH |\r\nBTRFSIC_PRINT_MASK_VERBOSE)))\r\nprintk(KERN_INFO\r\n"btrfsic_submit_bio(%s) with FLUSH"\r\n" but dummy block already in use"\r\n" (ignored)!\n",\r\ndev_state->name);\r\n} else {\r\nstruct btrfsic_block *const block =\r\n&dev_state->dummy_block_for_bio_bh_flush;\r\nblock->is_iodone = 0;\r\nblock->never_written = 0;\r\nblock->iodone_w_error = 0;\r\nblock->flush_gen = dev_state->last_flush_gen + 1;\r\nblock->submit_bio_bh_rw = rw;\r\nblock->orig_bio_bh_private = bio->bi_private;\r\nblock->orig_bio_bh_end_io.bio = bio->bi_end_io;\r\nblock->next_in_same_bio = NULL;\r\nbio->bi_private = block;\r\nbio->bi_end_io = btrfsic_bio_end_io;\r\n}\r\n}\r\nleave:\r\nmutex_unlock(&btrfsic_mutex);\r\n}\r\nvoid btrfsic_submit_bio(int rw, struct bio *bio)\r\n{\r\n__btrfsic_submit_bio(rw, bio);\r\nsubmit_bio(rw, bio);\r\n}\r\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\r\n{\r\n__btrfsic_submit_bio(rw, bio);\r\nreturn submit_bio_wait(rw, bio);\r\n}\r\nint btrfsic_mount(struct btrfs_root *root,\r\nstruct btrfs_fs_devices *fs_devices,\r\nint including_extent_data, u32 print_mask)\r\n{\r\nint ret;\r\nstruct btrfsic_state *state;\r\nstruct list_head *dev_head = &fs_devices->devices;\r\nstruct btrfs_device *device;\r\nif (root->nodesize != root->leafsize) {\r\nprintk(KERN_INFO\r\n"btrfsic: cannot handle nodesize %d != leafsize %d!\n",\r\nroot->nodesize, root->leafsize);\r\nreturn -1;\r\n}\r\nif (root->nodesize & ((u64)PAGE_CACHE_SIZE - 1)) {\r\nprintk(KERN_INFO\r\n"btrfsic: cannot handle nodesize %d not being a multiple of PAGE_CACHE_SIZE %ld!\n",\r\nroot->nodesize, PAGE_CACHE_SIZE);\r\nreturn -1;\r\n}\r\nif (root->leafsize & ((u64)PAGE_CACHE_SIZE - 1)) {\r\nprintk(KERN_INFO\r\n"btrfsic: cannot handle leafsize %d not being a multiple of PAGE_CACHE_SIZE %ld!\n",\r\nroot->leafsize, PAGE_CACHE_SIZE);\r\nreturn -1;\r\n}\r\nif (root->sectorsize & ((u64)PAGE_CACHE_SIZE - 1)) {\r\nprintk(KERN_INFO\r\n"btrfsic: cannot handle sectorsize %d not being a multiple of PAGE_CACHE_SIZE %ld!\n",\r\nroot->sectorsize, PAGE_CACHE_SIZE);\r\nreturn -1;\r\n}\r\nstate = kzalloc(sizeof(*state), GFP_NOFS);\r\nif (NULL == state) {\r\nprintk(KERN_INFO "btrfs check-integrity: kmalloc() failed!\n");\r\nreturn -1;\r\n}\r\nif (!btrfsic_is_initialized) {\r\nmutex_init(&btrfsic_mutex);\r\nbtrfsic_dev_state_hashtable_init(&btrfsic_dev_state_hashtable);\r\nbtrfsic_is_initialized = 1;\r\n}\r\nmutex_lock(&btrfsic_mutex);\r\nstate->root = root;\r\nstate->print_mask = print_mask;\r\nstate->include_extent_data = including_extent_data;\r\nstate->csum_size = 0;\r\nstate->metablock_size = root->nodesize;\r\nstate->datablock_size = root->sectorsize;\r\nINIT_LIST_HEAD(&state->all_blocks_list);\r\nbtrfsic_block_hashtable_init(&state->block_hashtable);\r\nbtrfsic_block_link_hashtable_init(&state->block_link_hashtable);\r\nstate->max_superblock_generation = 0;\r\nstate->latest_superblock = NULL;\r\nlist_for_each_entry(device, dev_head, dev_list) {\r\nstruct btrfsic_dev_state *ds;\r\nchar *p;\r\nif (!device->bdev || !device->name)\r\ncontinue;\r\nds = btrfsic_dev_state_alloc();\r\nif (NULL == ds) {\r\nprintk(KERN_INFO\r\n"btrfs check-integrity: kmalloc() failed!\n");\r\nmutex_unlock(&btrfsic_mutex);\r\nreturn -1;\r\n}\r\nds->bdev = device->bdev;\r\nds->state = state;\r\nbdevname(ds->bdev, ds->name);\r\nds->name[BDEVNAME_SIZE - 1] = '\0';\r\nfor (p = ds->name; *p != '\0'; p++);\r\nwhile (p > ds->name && *p != '/')\r\np--;\r\nif (*p == '/')\r\np++;\r\nstrlcpy(ds->name, p, sizeof(ds->name));\r\nbtrfsic_dev_state_hashtable_add(ds,\r\n&btrfsic_dev_state_hashtable);\r\n}\r\nret = btrfsic_process_superblock(state, fs_devices);\r\nif (0 != ret) {\r\nmutex_unlock(&btrfsic_mutex);\r\nbtrfsic_unmount(root, fs_devices);\r\nreturn ret;\r\n}\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_INITIAL_DATABASE)\r\nbtrfsic_dump_database(state);\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_INITIAL_TREE)\r\nbtrfsic_dump_tree(state);\r\nmutex_unlock(&btrfsic_mutex);\r\nreturn 0;\r\n}\r\nvoid btrfsic_unmount(struct btrfs_root *root,\r\nstruct btrfs_fs_devices *fs_devices)\r\n{\r\nstruct list_head *elem_all;\r\nstruct list_head *tmp_all;\r\nstruct btrfsic_state *state;\r\nstruct list_head *dev_head = &fs_devices->devices;\r\nstruct btrfs_device *device;\r\nif (!btrfsic_is_initialized)\r\nreturn;\r\nmutex_lock(&btrfsic_mutex);\r\nstate = NULL;\r\nlist_for_each_entry(device, dev_head, dev_list) {\r\nstruct btrfsic_dev_state *ds;\r\nif (!device->bdev || !device->name)\r\ncontinue;\r\nds = btrfsic_dev_state_hashtable_lookup(\r\ndevice->bdev,\r\n&btrfsic_dev_state_hashtable);\r\nif (NULL != ds) {\r\nstate = ds->state;\r\nbtrfsic_dev_state_hashtable_remove(ds);\r\nbtrfsic_dev_state_free(ds);\r\n}\r\n}\r\nif (NULL == state) {\r\nprintk(KERN_INFO\r\n"btrfsic: error, cannot find state information"\r\n" on umount!\n");\r\nmutex_unlock(&btrfsic_mutex);\r\nreturn;\r\n}\r\nlist_for_each_safe(elem_all, tmp_all, &state->all_blocks_list) {\r\nstruct btrfsic_block *const b_all =\r\nlist_entry(elem_all, struct btrfsic_block,\r\nall_blocks_node);\r\nstruct list_head *elem_ref_to;\r\nstruct list_head *tmp_ref_to;\r\nlist_for_each_safe(elem_ref_to, tmp_ref_to,\r\n&b_all->ref_to_list) {\r\nstruct btrfsic_block_link *const l =\r\nlist_entry(elem_ref_to,\r\nstruct btrfsic_block_link,\r\nnode_ref_to);\r\nif (state->print_mask & BTRFSIC_PRINT_MASK_VERBOSE)\r\nbtrfsic_print_rem_link(state, l);\r\nl->ref_cnt--;\r\nif (0 == l->ref_cnt)\r\nbtrfsic_block_link_free(l);\r\n}\r\nif (b_all->is_iodone || b_all->never_written)\r\nbtrfsic_block_free(b_all);\r\nelse\r\nprintk(KERN_INFO "btrfs: attempt to free %c-block"\r\n" @%llu (%s/%llu/%d) on umount which is"\r\n" not yet iodone!\n",\r\nbtrfsic_get_block_type(state, b_all),\r\nb_all->logical_bytenr, b_all->dev_state->name,\r\nb_all->dev_bytenr, b_all->mirror_num);\r\n}\r\nmutex_unlock(&btrfsic_mutex);\r\nkfree(state);\r\n}
