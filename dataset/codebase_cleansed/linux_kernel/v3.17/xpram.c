static int xpram_page_in (unsigned long page_addr, unsigned int xpage_index)\r\n{\r\nint cc = 2;\r\nasm volatile(\r\n" .insn rre,0xb22e0000,%1,%2\n"\r\n"0: ipm %0\n"\r\n" srl %0,28\n"\r\n"1:\n"\r\nEX_TABLE(0b,1b)\r\n: "+d" (cc) : "a" (__pa(page_addr)), "d" (xpage_index) : "cc");\r\nif (cc == 3)\r\nreturn -ENXIO;\r\nif (cc == 2)\r\nreturn -ENXIO;\r\nif (cc == 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic long xpram_page_out (unsigned long page_addr, unsigned int xpage_index)\r\n{\r\nint cc = 2;\r\nasm volatile(\r\n" .insn rre,0xb22f0000,%1,%2\n"\r\n"0: ipm %0\n"\r\n" srl %0,28\n"\r\n"1:\n"\r\nEX_TABLE(0b,1b)\r\n: "+d" (cc) : "a" (__pa(page_addr)), "d" (xpage_index) : "cc");\r\nif (cc == 3)\r\nreturn -ENXIO;\r\nif (cc == 2)\r\nreturn -ENXIO;\r\nif (cc == 1)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int xpram_present(void)\r\n{\r\nunsigned long mem_page;\r\nint rc;\r\nmem_page = (unsigned long) __get_free_page(GFP_KERNEL);\r\nif (!mem_page)\r\nreturn -ENOMEM;\r\nrc = xpram_page_in(mem_page, 0);\r\nfree_page(mem_page);\r\nreturn rc ? -ENXIO : 0;\r\n}\r\nstatic unsigned long xpram_highest_page_index(void)\r\n{\r\nunsigned int page_index, add_bit;\r\nunsigned long mem_page;\r\nmem_page = (unsigned long) __get_free_page(GFP_KERNEL);\r\nif (!mem_page)\r\nreturn 0;\r\npage_index = 0;\r\nadd_bit = 1ULL << (sizeof(unsigned int)*8 - 1);\r\nwhile (add_bit > 0) {\r\nif (xpram_page_in(mem_page, page_index | add_bit) == 0)\r\npage_index |= add_bit;\r\nadd_bit >>= 1;\r\n}\r\nfree_page (mem_page);\r\nreturn page_index;\r\n}\r\nstatic void xpram_make_request(struct request_queue *q, struct bio *bio)\r\n{\r\nxpram_device_t *xdev = bio->bi_bdev->bd_disk->private_data;\r\nstruct bio_vec bvec;\r\nstruct bvec_iter iter;\r\nunsigned int index;\r\nunsigned long page_addr;\r\nunsigned long bytes;\r\nif ((bio->bi_iter.bi_sector & 7) != 0 ||\r\n(bio->bi_iter.bi_size & 4095) != 0)\r\ngoto fail;\r\nif ((bio->bi_iter.bi_size >> 12) > xdev->size)\r\ngoto fail;\r\nif ((bio->bi_iter.bi_sector >> 3) > 0xffffffffU - xdev->offset)\r\ngoto fail;\r\nindex = (bio->bi_iter.bi_sector >> 3) + xdev->offset;\r\nbio_for_each_segment(bvec, bio, iter) {\r\npage_addr = (unsigned long)\r\nkmap(bvec.bv_page) + bvec.bv_offset;\r\nbytes = bvec.bv_len;\r\nif ((page_addr & 4095) != 0 || (bytes & 4095) != 0)\r\ngoto fail;\r\nwhile (bytes > 0) {\r\nif (bio_data_dir(bio) == READ) {\r\nif (xpram_page_in(page_addr, index) != 0)\r\ngoto fail;\r\n} else {\r\nif (xpram_page_out(page_addr, index) != 0)\r\ngoto fail;\r\n}\r\npage_addr += 4096;\r\nbytes -= 4096;\r\nindex++;\r\n}\r\n}\r\nset_bit(BIO_UPTODATE, &bio->bi_flags);\r\nbio_endio(bio, 0);\r\nreturn;\r\nfail:\r\nbio_io_error(bio);\r\n}\r\nstatic int xpram_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\nunsigned long size;\r\nsize = (xpram_pages * 8) & ~0x3f;\r\ngeo->cylinders = size >> 6;\r\ngeo->heads = 4;\r\ngeo->sectors = 16;\r\ngeo->start = 4;\r\nreturn 0;\r\n}\r\nstatic int __init xpram_setup_sizes(unsigned long pages)\r\n{\r\nunsigned long mem_needed;\r\nunsigned long mem_auto;\r\nunsigned long long size;\r\nchar *sizes_end;\r\nint mem_auto_no;\r\nint i;\r\nif (devs <= 0 || devs > XPRAM_MAX_DEVS) {\r\npr_err("%d is not a valid number of XPRAM devices\n",devs);\r\nreturn -EINVAL;\r\n}\r\nxpram_devs = devs;\r\nmem_needed = 0;\r\nmem_auto_no = 0;\r\nfor (i = 0; i < xpram_devs; i++) {\r\nif (sizes[i]) {\r\nsize = simple_strtoull(sizes[i], &sizes_end, 0);\r\nswitch (*sizes_end) {\r\ncase 'g':\r\ncase 'G':\r\nsize <<= 20;\r\nbreak;\r\ncase 'm':\r\ncase 'M':\r\nsize <<= 10;\r\n}\r\nxpram_sizes[i] = (size + 3) & -4UL;\r\n}\r\nif (xpram_sizes[i])\r\nmem_needed += xpram_sizes[i];\r\nelse\r\nmem_auto_no++;\r\n}\r\npr_info(" number of devices (partitions): %d \n", xpram_devs);\r\nfor (i = 0; i < xpram_devs; i++) {\r\nif (xpram_sizes[i])\r\npr_info(" size of partition %d: %u kB\n",\r\ni, xpram_sizes[i]);\r\nelse\r\npr_info(" size of partition %d to be set "\r\n"automatically\n",i);\r\n}\r\npr_info(" memory needed (for sized partitions): %lu kB\n",\r\nmem_needed);\r\npr_info(" partitions to be sized automatically: %d\n",\r\nmem_auto_no);\r\nif (mem_needed > pages * 4) {\r\npr_err("Not enough expanded memory available\n");\r\nreturn -EINVAL;\r\n}\r\nif (mem_auto_no) {\r\nmem_auto = ((pages - mem_needed / 4) / mem_auto_no) * 4;\r\npr_info(" automatically determined "\r\n"partition size: %lu kB\n", mem_auto);\r\nfor (i = 0; i < xpram_devs; i++)\r\nif (xpram_sizes[i] == 0)\r\nxpram_sizes[i] = mem_auto;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init xpram_setup_blkdev(void)\r\n{\r\nunsigned long offset;\r\nint i, rc = -ENOMEM;\r\nfor (i = 0; i < xpram_devs; i++) {\r\nxpram_disks[i] = alloc_disk(1);\r\nif (!xpram_disks[i])\r\ngoto out;\r\nxpram_queues[i] = blk_alloc_queue(GFP_KERNEL);\r\nif (!xpram_queues[i]) {\r\nput_disk(xpram_disks[i]);\r\ngoto out;\r\n}\r\nqueue_flag_set_unlocked(QUEUE_FLAG_NONROT, xpram_queues[i]);\r\nblk_queue_make_request(xpram_queues[i], xpram_make_request);\r\nblk_queue_logical_block_size(xpram_queues[i], 4096);\r\n}\r\nrc = register_blkdev(XPRAM_MAJOR, XPRAM_NAME);\r\nif (rc < 0)\r\ngoto out;\r\noffset = 0;\r\nfor (i = 0; i < xpram_devs; i++) {\r\nstruct gendisk *disk = xpram_disks[i];\r\nxpram_devices[i].size = xpram_sizes[i] / 4;\r\nxpram_devices[i].offset = offset;\r\noffset += xpram_devices[i].size;\r\ndisk->major = XPRAM_MAJOR;\r\ndisk->first_minor = i;\r\ndisk->fops = &xpram_devops;\r\ndisk->private_data = &xpram_devices[i];\r\ndisk->queue = xpram_queues[i];\r\nsprintf(disk->disk_name, "slram%d", i);\r\nset_capacity(disk, xpram_sizes[i] << 1);\r\nadd_disk(disk);\r\n}\r\nreturn 0;\r\nout:\r\nwhile (i--) {\r\nblk_cleanup_queue(xpram_queues[i]);\r\nput_disk(xpram_disks[i]);\r\n}\r\nreturn rc;\r\n}\r\nstatic void xpram_resume_error(const char *message)\r\n{\r\npr_err("Resuming the system failed: %s\n", message);\r\npanic("xpram resume error\n");\r\n}\r\nstatic int xpram_restore(struct device *dev)\r\n{\r\nif (!xpram_pages)\r\nreturn 0;\r\nif (xpram_present() != 0)\r\nxpram_resume_error("xpram disappeared");\r\nif (xpram_pages != xpram_highest_page_index() + 1)\r\nxpram_resume_error("Size of xpram changed");\r\nreturn 0;\r\n}\r\nstatic void __exit xpram_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < xpram_devs; i++) {\r\ndel_gendisk(xpram_disks[i]);\r\nblk_cleanup_queue(xpram_queues[i]);\r\nput_disk(xpram_disks[i]);\r\n}\r\nunregister_blkdev(XPRAM_MAJOR, XPRAM_NAME);\r\nplatform_device_unregister(xpram_pdev);\r\nplatform_driver_unregister(&xpram_pdrv);\r\n}\r\nstatic int __init xpram_init(void)\r\n{\r\nint rc;\r\nif (xpram_present() != 0) {\r\npr_err("No expanded memory available\n");\r\nreturn -ENODEV;\r\n}\r\nxpram_pages = xpram_highest_page_index() + 1;\r\npr_info(" %u pages expanded memory found (%lu KB).\n",\r\nxpram_pages, (unsigned long) xpram_pages*4);\r\nrc = xpram_setup_sizes(xpram_pages);\r\nif (rc)\r\nreturn rc;\r\nrc = platform_driver_register(&xpram_pdrv);\r\nif (rc)\r\nreturn rc;\r\nxpram_pdev = platform_device_register_simple(XPRAM_NAME, -1, NULL, 0);\r\nif (IS_ERR(xpram_pdev)) {\r\nrc = PTR_ERR(xpram_pdev);\r\ngoto fail_platform_driver_unregister;\r\n}\r\nrc = xpram_setup_blkdev();\r\nif (rc)\r\ngoto fail_platform_device_unregister;\r\nreturn 0;\r\nfail_platform_device_unregister:\r\nplatform_device_unregister(xpram_pdev);\r\nfail_platform_driver_unregister:\r\nplatform_driver_unregister(&xpram_pdrv);\r\nreturn rc;\r\n}
