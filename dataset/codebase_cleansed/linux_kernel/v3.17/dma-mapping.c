static pgprot_t __get_dma_pgprot(struct dma_attrs *attrs, pgprot_t prot,\r\nbool coherent)\r\n{\r\nif (!coherent || dma_get_attr(DMA_ATTR_WRITE_COMBINE, attrs))\r\nreturn pgprot_writecombine(prot);\r\nreturn prot;\r\n}\r\nstatic void *__dma_alloc_coherent(struct device *dev, size_t size,\r\ndma_addr_t *dma_handle, gfp_t flags,\r\nstruct dma_attrs *attrs)\r\n{\r\nif (dev == NULL) {\r\nWARN_ONCE(1, "Use an actual device structure for DMA allocation\n");\r\nreturn NULL;\r\n}\r\nif (IS_ENABLED(CONFIG_ZONE_DMA) &&\r\ndev->coherent_dma_mask <= DMA_BIT_MASK(32))\r\nflags |= GFP_DMA;\r\nif (IS_ENABLED(CONFIG_DMA_CMA)) {\r\nstruct page *page;\r\nsize = PAGE_ALIGN(size);\r\npage = dma_alloc_from_contiguous(dev, size >> PAGE_SHIFT,\r\nget_order(size));\r\nif (!page)\r\nreturn NULL;\r\n*dma_handle = phys_to_dma(dev, page_to_phys(page));\r\nreturn page_address(page);\r\n} else {\r\nreturn swiotlb_alloc_coherent(dev, size, dma_handle, flags);\r\n}\r\n}\r\nstatic void __dma_free_coherent(struct device *dev, size_t size,\r\nvoid *vaddr, dma_addr_t dma_handle,\r\nstruct dma_attrs *attrs)\r\n{\r\nif (dev == NULL) {\r\nWARN_ONCE(1, "Use an actual device structure for DMA allocation\n");\r\nreturn;\r\n}\r\nif (IS_ENABLED(CONFIG_DMA_CMA)) {\r\nphys_addr_t paddr = dma_to_phys(dev, dma_handle);\r\ndma_release_from_contiguous(dev,\r\nphys_to_page(paddr),\r\nsize >> PAGE_SHIFT);\r\n} else {\r\nswiotlb_free_coherent(dev, size, vaddr, dma_handle);\r\n}\r\n}\r\nstatic void *__dma_alloc_noncoherent(struct device *dev, size_t size,\r\ndma_addr_t *dma_handle, gfp_t flags,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct page *page, **map;\r\nvoid *ptr, *coherent_ptr;\r\nint order, i;\r\nsize = PAGE_ALIGN(size);\r\norder = get_order(size);\r\nptr = __dma_alloc_coherent(dev, size, dma_handle, flags, attrs);\r\nif (!ptr)\r\ngoto no_mem;\r\nmap = kmalloc(sizeof(struct page *) << order, flags & ~GFP_DMA);\r\nif (!map)\r\ngoto no_map;\r\n__dma_flush_range(ptr, ptr + size);\r\npage = virt_to_page(ptr);\r\nfor (i = 0; i < (size >> PAGE_SHIFT); i++)\r\nmap[i] = page + i;\r\ncoherent_ptr = vmap(map, size >> PAGE_SHIFT, VM_MAP,\r\n__get_dma_pgprot(attrs, __pgprot(PROT_NORMAL_NC), false));\r\nkfree(map);\r\nif (!coherent_ptr)\r\ngoto no_map;\r\nreturn coherent_ptr;\r\nno_map:\r\n__dma_free_coherent(dev, size, ptr, *dma_handle, attrs);\r\nno_mem:\r\n*dma_handle = ~0;\r\nreturn NULL;\r\n}\r\nstatic void __dma_free_noncoherent(struct device *dev, size_t size,\r\nvoid *vaddr, dma_addr_t dma_handle,\r\nstruct dma_attrs *attrs)\r\n{\r\nvoid *swiotlb_addr = phys_to_virt(dma_to_phys(dev, dma_handle));\r\nvunmap(vaddr);\r\n__dma_free_coherent(dev, size, swiotlb_addr, dma_handle, attrs);\r\n}\r\nstatic dma_addr_t __swiotlb_map_page(struct device *dev, struct page *page,\r\nunsigned long offset, size_t size,\r\nenum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\ndma_addr_t dev_addr;\r\ndev_addr = swiotlb_map_page(dev, page, offset, size, dir, attrs);\r\n__dma_map_area(phys_to_virt(dma_to_phys(dev, dev_addr)), size, dir);\r\nreturn dev_addr;\r\n}\r\nstatic void __swiotlb_unmap_page(struct device *dev, dma_addr_t dev_addr,\r\nsize_t size, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\n__dma_unmap_area(phys_to_virt(dma_to_phys(dev, dev_addr)), size, dir);\r\nswiotlb_unmap_page(dev, dev_addr, size, dir, attrs);\r\n}\r\nstatic int __swiotlb_map_sg_attrs(struct device *dev, struct scatterlist *sgl,\r\nint nelems, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct scatterlist *sg;\r\nint i, ret;\r\nret = swiotlb_map_sg_attrs(dev, sgl, nelems, dir, attrs);\r\nfor_each_sg(sgl, sg, ret, i)\r\n__dma_map_area(phys_to_virt(dma_to_phys(dev, sg->dma_address)),\r\nsg->length, dir);\r\nreturn ret;\r\n}\r\nstatic void __swiotlb_unmap_sg_attrs(struct device *dev,\r\nstruct scatterlist *sgl, int nelems,\r\nenum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct scatterlist *sg;\r\nint i;\r\nfor_each_sg(sgl, sg, nelems, i)\r\n__dma_unmap_area(phys_to_virt(dma_to_phys(dev, sg->dma_address)),\r\nsg->length, dir);\r\nswiotlb_unmap_sg_attrs(dev, sgl, nelems, dir, attrs);\r\n}\r\nstatic void __swiotlb_sync_single_for_cpu(struct device *dev,\r\ndma_addr_t dev_addr, size_t size,\r\nenum dma_data_direction dir)\r\n{\r\n__dma_unmap_area(phys_to_virt(dma_to_phys(dev, dev_addr)), size, dir);\r\nswiotlb_sync_single_for_cpu(dev, dev_addr, size, dir);\r\n}\r\nstatic void __swiotlb_sync_single_for_device(struct device *dev,\r\ndma_addr_t dev_addr, size_t size,\r\nenum dma_data_direction dir)\r\n{\r\nswiotlb_sync_single_for_device(dev, dev_addr, size, dir);\r\n__dma_map_area(phys_to_virt(dma_to_phys(dev, dev_addr)), size, dir);\r\n}\r\nstatic void __swiotlb_sync_sg_for_cpu(struct device *dev,\r\nstruct scatterlist *sgl, int nelems,\r\nenum dma_data_direction dir)\r\n{\r\nstruct scatterlist *sg;\r\nint i;\r\nfor_each_sg(sgl, sg, nelems, i)\r\n__dma_unmap_area(phys_to_virt(dma_to_phys(dev, sg->dma_address)),\r\nsg->length, dir);\r\nswiotlb_sync_sg_for_cpu(dev, sgl, nelems, dir);\r\n}\r\nstatic void __swiotlb_sync_sg_for_device(struct device *dev,\r\nstruct scatterlist *sgl, int nelems,\r\nenum dma_data_direction dir)\r\n{\r\nstruct scatterlist *sg;\r\nint i;\r\nswiotlb_sync_sg_for_device(dev, sgl, nelems, dir);\r\nfor_each_sg(sgl, sg, nelems, i)\r\n__dma_map_area(phys_to_virt(dma_to_phys(dev, sg->dma_address)),\r\nsg->length, dir);\r\n}\r\nstatic int __dma_common_mmap(struct device *dev, struct vm_area_struct *vma,\r\nvoid *cpu_addr, dma_addr_t dma_addr, size_t size)\r\n{\r\nint ret = -ENXIO;\r\nunsigned long nr_vma_pages = (vma->vm_end - vma->vm_start) >>\r\nPAGE_SHIFT;\r\nunsigned long nr_pages = PAGE_ALIGN(size) >> PAGE_SHIFT;\r\nunsigned long pfn = dma_to_phys(dev, dma_addr) >> PAGE_SHIFT;\r\nunsigned long off = vma->vm_pgoff;\r\nif (dma_mmap_from_coherent(dev, vma, cpu_addr, size, &ret))\r\nreturn ret;\r\nif (off < nr_pages && nr_vma_pages <= (nr_pages - off)) {\r\nret = remap_pfn_range(vma, vma->vm_start,\r\npfn + off,\r\nvma->vm_end - vma->vm_start,\r\nvma->vm_page_prot);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __swiotlb_mmap_noncoherent(struct device *dev,\r\nstruct vm_area_struct *vma,\r\nvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\r\nstruct dma_attrs *attrs)\r\n{\r\nvma->vm_page_prot = __get_dma_pgprot(attrs, vma->vm_page_prot, false);\r\nreturn __dma_common_mmap(dev, vma, cpu_addr, dma_addr, size);\r\n}\r\nstatic int __swiotlb_mmap_coherent(struct device *dev,\r\nstruct vm_area_struct *vma,\r\nvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\r\nstruct dma_attrs *attrs)\r\n{\r\nreturn __dma_common_mmap(dev, vma, cpu_addr, dma_addr, size);\r\n}\r\nstatic int dma_bus_notifier(struct notifier_block *nb,\r\nunsigned long event, void *_dev)\r\n{\r\nstruct device *dev = _dev;\r\nif (event != BUS_NOTIFY_ADD_DEVICE)\r\nreturn NOTIFY_DONE;\r\nif (of_property_read_bool(dev->of_node, "dma-coherent"))\r\nset_dma_ops(dev, &coherent_swiotlb_dma_ops);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init swiotlb_late_init(void)\r\n{\r\nsize_t swiotlb_size = min(SZ_64M, MAX_ORDER_NR_PAGES << PAGE_SHIFT);\r\nbus_register_notifier(&platform_bus_type, &platform_bus_nb);\r\nbus_register_notifier(&amba_bustype, &amba_bus_nb);\r\ndma_ops = &noncoherent_swiotlb_dma_ops;\r\nreturn swiotlb_late_init_with_default_size(swiotlb_size);\r\n}\r\nstatic int __init dma_debug_do_init(void)\r\n{\r\ndma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);\r\nreturn 0;\r\n}
