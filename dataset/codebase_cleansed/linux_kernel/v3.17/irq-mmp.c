static void icu_mask_ack_irq(struct irq_data *d)\r\n{\r\nstruct irq_domain *domain = d->domain;\r\nstruct icu_chip_data *data = (struct icu_chip_data *)domain->host_data;\r\nint hwirq;\r\nu32 r;\r\nhwirq = d->irq - data->virq_base;\r\nif (data == &icu_data[0]) {\r\nr = readl_relaxed(mmp_icu_base + (hwirq << 2));\r\nr &= ~data->conf_mask;\r\nr |= data->conf_disable;\r\nwritel_relaxed(r, mmp_icu_base + (hwirq << 2));\r\n} else {\r\n#ifdef CONFIG_CPU_MMP2\r\nif ((data->virq_base == data->clr_mfp_irq_base)\r\n&& (hwirq == data->clr_mfp_hwirq))\r\nmmp2_clear_pmic_int();\r\n#endif\r\nr = readl_relaxed(data->reg_mask) | (1 << hwirq);\r\nwritel_relaxed(r, data->reg_mask);\r\n}\r\n}\r\nstatic void icu_mask_irq(struct irq_data *d)\r\n{\r\nstruct irq_domain *domain = d->domain;\r\nstruct icu_chip_data *data = (struct icu_chip_data *)domain->host_data;\r\nint hwirq;\r\nu32 r;\r\nhwirq = d->irq - data->virq_base;\r\nif (data == &icu_data[0]) {\r\nr = readl_relaxed(mmp_icu_base + (hwirq << 2));\r\nr &= ~data->conf_mask;\r\nr |= data->conf_disable;\r\nwritel_relaxed(r, mmp_icu_base + (hwirq << 2));\r\n} else {\r\nr = readl_relaxed(data->reg_mask) | (1 << hwirq);\r\nwritel_relaxed(r, data->reg_mask);\r\n}\r\n}\r\nstatic void icu_unmask_irq(struct irq_data *d)\r\n{\r\nstruct irq_domain *domain = d->domain;\r\nstruct icu_chip_data *data = (struct icu_chip_data *)domain->host_data;\r\nint hwirq;\r\nu32 r;\r\nhwirq = d->irq - data->virq_base;\r\nif (data == &icu_data[0]) {\r\nr = readl_relaxed(mmp_icu_base + (hwirq << 2));\r\nr &= ~data->conf_mask;\r\nr |= data->conf_enable;\r\nwritel_relaxed(r, mmp_icu_base + (hwirq << 2));\r\n} else {\r\nr = readl_relaxed(data->reg_mask) & ~(1 << hwirq);\r\nwritel_relaxed(r, data->reg_mask);\r\n}\r\n}\r\nstatic void icu_mux_irq_demux(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct irq_domain *domain;\r\nstruct icu_chip_data *data;\r\nint i;\r\nunsigned long mask, status, n;\r\nfor (i = 1; i < max_icu_nr; i++) {\r\nif (irq == icu_data[i].cascade_irq) {\r\ndomain = icu_data[i].domain;\r\ndata = (struct icu_chip_data *)domain->host_data;\r\nbreak;\r\n}\r\n}\r\nif (i >= max_icu_nr) {\r\npr_err("Spurious irq %d in MMP INTC\n", irq);\r\nreturn;\r\n}\r\nmask = readl_relaxed(data->reg_mask);\r\nwhile (1) {\r\nstatus = readl_relaxed(data->reg_status) & ~mask;\r\nif (status == 0)\r\nbreak;\r\nfor_each_set_bit(n, &status, BITS_PER_LONG) {\r\ngeneric_handle_irq(icu_data[i].virq_base + n);\r\n}\r\n}\r\n}\r\nstatic int mmp_irq_domain_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hw)\r\n{\r\nirq_set_chip_and_handler(irq, &icu_irq_chip, handle_level_irq);\r\nset_irq_flags(irq, IRQF_VALID);\r\nreturn 0;\r\n}\r\nstatic int mmp_irq_domain_xlate(struct irq_domain *d, struct device_node *node,\r\nconst u32 *intspec, unsigned int intsize,\r\nunsigned long *out_hwirq,\r\nunsigned int *out_type)\r\n{\r\n*out_hwirq = intspec[0];\r\nreturn 0;\r\n}\r\nstatic void __exception_irq_entry mmp_handle_irq(struct pt_regs *regs)\r\n{\r\nint irq, hwirq;\r\nhwirq = readl_relaxed(mmp_icu_base + PJ1_INT_SEL);\r\nif (!(hwirq & SEL_INT_PENDING))\r\nreturn;\r\nhwirq &= SEL_INT_NUM_MASK;\r\nirq = irq_find_mapping(icu_data[0].domain, hwirq);\r\nhandle_IRQ(irq, regs);\r\n}\r\nstatic void __exception_irq_entry mmp2_handle_irq(struct pt_regs *regs)\r\n{\r\nint irq, hwirq;\r\nhwirq = readl_relaxed(mmp_icu_base + PJ4_INT_SEL);\r\nif (!(hwirq & SEL_INT_PENDING))\r\nreturn;\r\nhwirq &= SEL_INT_NUM_MASK;\r\nirq = irq_find_mapping(icu_data[0].domain, hwirq);\r\nhandle_IRQ(irq, regs);\r\n}\r\nvoid __init icu_init_irq(void)\r\n{\r\nint irq;\r\nmax_icu_nr = 1;\r\nmmp_icu_base = ioremap(0xd4282000, 0x1000);\r\nicu_data[0].conf_enable = mmp_conf.conf_enable;\r\nicu_data[0].conf_disable = mmp_conf.conf_disable;\r\nicu_data[0].conf_mask = mmp_conf.conf_mask;\r\nicu_data[0].nr_irqs = 64;\r\nicu_data[0].virq_base = 0;\r\nicu_data[0].domain = irq_domain_add_legacy(NULL, 64, 0, 0,\r\n&irq_domain_simple_ops,\r\n&icu_data[0]);\r\nfor (irq = 0; irq < 64; irq++) {\r\nicu_mask_irq(irq_get_irq_data(irq));\r\nirq_set_chip_and_handler(irq, &icu_irq_chip, handle_level_irq);\r\nset_irq_flags(irq, IRQF_VALID);\r\n}\r\nirq_set_default_host(icu_data[0].domain);\r\nset_handle_irq(mmp_handle_irq);\r\n}\r\nvoid __init mmp2_init_icu(void)\r\n{\r\nint irq, end;\r\nmax_icu_nr = 8;\r\nmmp_icu_base = ioremap(0xd4282000, 0x1000);\r\nicu_data[0].conf_enable = mmp2_conf.conf_enable;\r\nicu_data[0].conf_disable = mmp2_conf.conf_disable;\r\nicu_data[0].conf_mask = mmp2_conf.conf_mask;\r\nicu_data[0].nr_irqs = 64;\r\nicu_data[0].virq_base = 0;\r\nicu_data[0].domain = irq_domain_add_legacy(NULL, 64, 0, 0,\r\n&irq_domain_simple_ops,\r\n&icu_data[0]);\r\nicu_data[1].reg_status = mmp_icu_base + 0x150;\r\nicu_data[1].reg_mask = mmp_icu_base + 0x168;\r\nicu_data[1].clr_mfp_irq_base = icu_data[0].virq_base +\r\nicu_data[0].nr_irqs;\r\nicu_data[1].clr_mfp_hwirq = 1;\r\nicu_data[1].nr_irqs = 2;\r\nicu_data[1].cascade_irq = 4;\r\nicu_data[1].virq_base = icu_data[0].virq_base + icu_data[0].nr_irqs;\r\nicu_data[1].domain = irq_domain_add_legacy(NULL, icu_data[1].nr_irqs,\r\nicu_data[1].virq_base, 0,\r\n&irq_domain_simple_ops,\r\n&icu_data[1]);\r\nicu_data[2].reg_status = mmp_icu_base + 0x154;\r\nicu_data[2].reg_mask = mmp_icu_base + 0x16c;\r\nicu_data[2].nr_irqs = 2;\r\nicu_data[2].cascade_irq = 5;\r\nicu_data[2].virq_base = icu_data[1].virq_base + icu_data[1].nr_irqs;\r\nicu_data[2].domain = irq_domain_add_legacy(NULL, icu_data[2].nr_irqs,\r\nicu_data[2].virq_base, 0,\r\n&irq_domain_simple_ops,\r\n&icu_data[2]);\r\nicu_data[3].reg_status = mmp_icu_base + 0x180;\r\nicu_data[3].reg_mask = mmp_icu_base + 0x17c;\r\nicu_data[3].nr_irqs = 3;\r\nicu_data[3].cascade_irq = 9;\r\nicu_data[3].virq_base = icu_data[2].virq_base + icu_data[2].nr_irqs;\r\nicu_data[3].domain = irq_domain_add_legacy(NULL, icu_data[3].nr_irqs,\r\nicu_data[3].virq_base, 0,\r\n&irq_domain_simple_ops,\r\n&icu_data[3]);\r\nicu_data[4].reg_status = mmp_icu_base + 0x158;\r\nicu_data[4].reg_mask = mmp_icu_base + 0x170;\r\nicu_data[4].nr_irqs = 5;\r\nicu_data[4].cascade_irq = 17;\r\nicu_data[4].virq_base = icu_data[3].virq_base + icu_data[3].nr_irqs;\r\nicu_data[4].domain = irq_domain_add_legacy(NULL, icu_data[4].nr_irqs,\r\nicu_data[4].virq_base, 0,\r\n&irq_domain_simple_ops,\r\n&icu_data[4]);\r\nicu_data[5].reg_status = mmp_icu_base + 0x15c;\r\nicu_data[5].reg_mask = mmp_icu_base + 0x174;\r\nicu_data[5].nr_irqs = 15;\r\nicu_data[5].cascade_irq = 35;\r\nicu_data[5].virq_base = icu_data[4].virq_base + icu_data[4].nr_irqs;\r\nicu_data[5].domain = irq_domain_add_legacy(NULL, icu_data[5].nr_irqs,\r\nicu_data[5].virq_base, 0,\r\n&irq_domain_simple_ops,\r\n&icu_data[5]);\r\nicu_data[6].reg_status = mmp_icu_base + 0x160;\r\nicu_data[6].reg_mask = mmp_icu_base + 0x178;\r\nicu_data[6].nr_irqs = 2;\r\nicu_data[6].cascade_irq = 51;\r\nicu_data[6].virq_base = icu_data[5].virq_base + icu_data[5].nr_irqs;\r\nicu_data[6].domain = irq_domain_add_legacy(NULL, icu_data[6].nr_irqs,\r\nicu_data[6].virq_base, 0,\r\n&irq_domain_simple_ops,\r\n&icu_data[6]);\r\nicu_data[7].reg_status = mmp_icu_base + 0x188;\r\nicu_data[7].reg_mask = mmp_icu_base + 0x184;\r\nicu_data[7].nr_irqs = 2;\r\nicu_data[7].cascade_irq = 55;\r\nicu_data[7].virq_base = icu_data[6].virq_base + icu_data[6].nr_irqs;\r\nicu_data[7].domain = irq_domain_add_legacy(NULL, icu_data[7].nr_irqs,\r\nicu_data[7].virq_base, 0,\r\n&irq_domain_simple_ops,\r\n&icu_data[7]);\r\nend = icu_data[7].virq_base + icu_data[7].nr_irqs;\r\nfor (irq = 0; irq < end; irq++) {\r\nicu_mask_irq(irq_get_irq_data(irq));\r\nif (irq == icu_data[1].cascade_irq ||\r\nirq == icu_data[2].cascade_irq ||\r\nirq == icu_data[3].cascade_irq ||\r\nirq == icu_data[4].cascade_irq ||\r\nirq == icu_data[5].cascade_irq ||\r\nirq == icu_data[6].cascade_irq ||\r\nirq == icu_data[7].cascade_irq) {\r\nirq_set_chip(irq, &icu_irq_chip);\r\nirq_set_chained_handler(irq, icu_mux_irq_demux);\r\n} else {\r\nirq_set_chip_and_handler(irq, &icu_irq_chip,\r\nhandle_level_irq);\r\n}\r\nset_irq_flags(irq, IRQF_VALID);\r\n}\r\nirq_set_default_host(icu_data[0].domain);\r\nset_handle_irq(mmp2_handle_irq);\r\n}\r\nstatic int __init mmp_init_bases(struct device_node *node)\r\n{\r\nint ret, nr_irqs, irq, i = 0;\r\nret = of_property_read_u32(node, "mrvl,intc-nr-irqs", &nr_irqs);\r\nif (ret) {\r\npr_err("Not found mrvl,intc-nr-irqs property\n");\r\nreturn ret;\r\n}\r\nmmp_icu_base = of_iomap(node, 0);\r\nif (!mmp_icu_base) {\r\npr_err("Failed to get interrupt controller register\n");\r\nreturn -ENOMEM;\r\n}\r\nicu_data[0].virq_base = 0;\r\nicu_data[0].domain = irq_domain_add_linear(node, nr_irqs,\r\n&mmp_irq_domain_ops,\r\n&icu_data[0]);\r\nfor (irq = 0; irq < nr_irqs; irq++) {\r\nret = irq_create_mapping(icu_data[0].domain, irq);\r\nif (!ret) {\r\npr_err("Failed to mapping hwirq\n");\r\ngoto err;\r\n}\r\nif (!irq)\r\nicu_data[0].virq_base = ret;\r\n}\r\nicu_data[0].nr_irqs = nr_irqs;\r\nreturn 0;\r\nerr:\r\nif (icu_data[0].virq_base) {\r\nfor (i = 0; i < irq; i++)\r\nirq_dispose_mapping(icu_data[0].virq_base + i);\r\n}\r\nirq_domain_remove(icu_data[0].domain);\r\niounmap(mmp_icu_base);\r\nreturn -EINVAL;\r\n}\r\nstatic int __init mmp_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nint ret;\r\nret = mmp_init_bases(node);\r\nif (ret < 0)\r\nreturn ret;\r\nicu_data[0].conf_enable = mmp_conf.conf_enable;\r\nicu_data[0].conf_disable = mmp_conf.conf_disable;\r\nicu_data[0].conf_mask = mmp_conf.conf_mask;\r\nirq_set_default_host(icu_data[0].domain);\r\nset_handle_irq(mmp_handle_irq);\r\nmax_icu_nr = 1;\r\nreturn 0;\r\n}\r\nstatic int __init mmp2_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nint ret;\r\nret = mmp_init_bases(node);\r\nif (ret < 0)\r\nreturn ret;\r\nicu_data[0].conf_enable = mmp2_conf.conf_enable;\r\nicu_data[0].conf_disable = mmp2_conf.conf_disable;\r\nicu_data[0].conf_mask = mmp2_conf.conf_mask;\r\nirq_set_default_host(icu_data[0].domain);\r\nset_handle_irq(mmp2_handle_irq);\r\nmax_icu_nr = 1;\r\nreturn 0;\r\n}\r\nstatic int __init mmp2_mux_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nstruct resource res;\r\nint i, ret, irq, j = 0;\r\nu32 nr_irqs, mfp_irq;\r\nif (!parent)\r\nreturn -ENODEV;\r\ni = max_icu_nr;\r\nret = of_property_read_u32(node, "mrvl,intc-nr-irqs",\r\n&nr_irqs);\r\nif (ret) {\r\npr_err("Not found mrvl,intc-nr-irqs property\n");\r\nreturn -EINVAL;\r\n}\r\nret = of_address_to_resource(node, 0, &res);\r\nif (ret < 0) {\r\npr_err("Not found reg property\n");\r\nreturn -EINVAL;\r\n}\r\nicu_data[i].reg_status = mmp_icu_base + res.start;\r\nret = of_address_to_resource(node, 1, &res);\r\nif (ret < 0) {\r\npr_err("Not found reg property\n");\r\nreturn -EINVAL;\r\n}\r\nicu_data[i].reg_mask = mmp_icu_base + res.start;\r\nicu_data[i].cascade_irq = irq_of_parse_and_map(node, 0);\r\nif (!icu_data[i].cascade_irq)\r\nreturn -EINVAL;\r\nicu_data[i].virq_base = 0;\r\nicu_data[i].domain = irq_domain_add_linear(node, nr_irqs,\r\n&mmp_irq_domain_ops,\r\n&icu_data[i]);\r\nfor (irq = 0; irq < nr_irqs; irq++) {\r\nret = irq_create_mapping(icu_data[i].domain, irq);\r\nif (!ret) {\r\npr_err("Failed to mapping hwirq\n");\r\ngoto err;\r\n}\r\nif (!irq)\r\nicu_data[i].virq_base = ret;\r\n}\r\nicu_data[i].nr_irqs = nr_irqs;\r\nif (!of_property_read_u32(node, "mrvl,clr-mfp-irq",\r\n&mfp_irq)) {\r\nicu_data[i].clr_mfp_irq_base = icu_data[i].virq_base;\r\nicu_data[i].clr_mfp_hwirq = mfp_irq;\r\n}\r\nirq_set_chained_handler(icu_data[i].cascade_irq,\r\nicu_mux_irq_demux);\r\nmax_icu_nr++;\r\nreturn 0;\r\nerr:\r\nif (icu_data[i].virq_base) {\r\nfor (j = 0; j < irq; j++)\r\nirq_dispose_mapping(icu_data[i].virq_base + j);\r\n}\r\nirq_domain_remove(icu_data[i].domain);\r\nreturn -EINVAL;\r\n}
