static char *chstate(unsigned n)\r\n{\r\nswitch (n) {\r\ncase SMD_SS_CLOSED:\r\nreturn "CLOSED";\r\ncase SMD_SS_OPENING:\r\nreturn "OPENING";\r\ncase SMD_SS_OPENED:\r\nreturn "OPENED";\r\ncase SMD_SS_FLUSHING:\r\nreturn "FLUSHING";\r\ncase SMD_SS_CLOSING:\r\nreturn "CLOSING";\r\ncase SMD_SS_RESET:\r\nreturn "RESET";\r\ncase SMD_SS_RESET_OPENING:\r\nreturn "ROPENING";\r\ndefault:\r\nreturn "UNKNOWN";\r\n}\r\n}\r\nstatic int dump_ch(char *buf, int max, struct smd_channel *ch)\r\n{\r\nvolatile struct smd_half_channel *s = ch->send;\r\nvolatile struct smd_half_channel *r = ch->recv;\r\nreturn scnprintf(\r\nbuf, max,\r\n"ch%02d:"\r\n" %8s(%05d/%05d) %c%c%c%c%c%c%c <->"\r\n" %8s(%05d/%05d) %c%c%c%c%c%c%c '%s'\n", ch->n,\r\nchstate(s->state), s->tail, s->head,\r\ns->fDSR ? 'D' : 'd',\r\ns->fCTS ? 'C' : 'c',\r\ns->fCD ? 'C' : 'c',\r\ns->fRI ? 'I' : 'i',\r\ns->fHEAD ? 'W' : 'w',\r\ns->fTAIL ? 'R' : 'r',\r\ns->fSTATE ? 'S' : 's',\r\nchstate(r->state), r->tail, r->head,\r\nr->fDSR ? 'D' : 'd',\r\nr->fCTS ? 'R' : 'r',\r\nr->fCD ? 'C' : 'c',\r\nr->fRI ? 'I' : 'i',\r\nr->fHEAD ? 'W' : 'w',\r\nr->fTAIL ? 'R' : 'r',\r\nr->fSTATE ? 'S' : 's',\r\nch->name\r\n);\r\n}\r\nstatic int debug_read_stat(char *buf, int max)\r\n{\r\nchar *msg;\r\nint i = 0;\r\nmsg = smem_find(ID_DIAG_ERR_MSG, SZ_DIAG_ERR_MSG);\r\nif (raw_smsm_get_state(SMSM_STATE_MODEM) & SMSM_RESET)\r\ni += scnprintf(buf + i, max - i,\r\n"smsm: ARM9 HAS CRASHED\n");\r\ni += scnprintf(buf + i, max - i, "smsm: a9: %08x a11: %08x\n",\r\nraw_smsm_get_state(SMSM_STATE_MODEM),\r\nraw_smsm_get_state(SMSM_STATE_APPS));\r\n#ifdef CONFIG_ARCH_MSM_SCORPION\r\ni += scnprintf(buf + i, max - i, "smsm dem: apps: %08x modem: %08x "\r\n"qdsp6: %08x power: %08x time: %08x\n",\r\nraw_smsm_get_state(SMSM_STATE_APPS_DEM),\r\nraw_smsm_get_state(SMSM_STATE_MODEM_DEM),\r\nraw_smsm_get_state(SMSM_STATE_QDSP6_DEM),\r\nraw_smsm_get_state(SMSM_STATE_POWER_MASTER_DEM),\r\nraw_smsm_get_state(SMSM_STATE_TIME_MASTER_DEM));\r\n#endif\r\nif (msg) {\r\nmsg[SZ_DIAG_ERR_MSG - 1] = 0;\r\ni += scnprintf(buf + i, max - i, "diag: '%s'\n", msg);\r\n}\r\nreturn i;\r\n}\r\nstatic int debug_read_mem(char *buf, int max)\r\n{\r\nunsigned n;\r\nstruct smem_shared *shared = (void *) MSM_SHARED_RAM_BASE;\r\nstruct smem_heap_entry *toc = shared->heap_toc;\r\nint i = 0;\r\ni += scnprintf(buf + i, max - i,\r\n"heap: init=%d free=%d remain=%d\n",\r\nshared->heap_info.initialized,\r\nshared->heap_info.free_offset,\r\nshared->heap_info.heap_remaining);\r\nfor (n = 0; n < SMEM_NUM_ITEMS; n++) {\r\nif (toc[n].allocated == 0)\r\ncontinue;\r\ni += scnprintf(buf + i, max - i,\r\n"%04d: offset %08x size %08x\n",\r\nn, toc[n].offset, toc[n].size);\r\n}\r\nreturn i;\r\n}\r\nstatic int debug_read_ch(char *buf, int max)\r\n{\r\nstruct smd_channel *ch;\r\nunsigned long flags;\r\nint i = 0;\r\nspin_lock_irqsave(&smd_lock, flags);\r\nlist_for_each_entry(ch, &smd_ch_list_dsp, ch_list)\r\ni += dump_ch(buf + i, max - i, ch);\r\nlist_for_each_entry(ch, &smd_ch_list_modem, ch_list)\r\ni += dump_ch(buf + i, max - i, ch);\r\nlist_for_each_entry(ch, &smd_ch_closed_list, ch_list)\r\ni += dump_ch(buf + i, max - i, ch);\r\nspin_unlock_irqrestore(&smd_lock, flags);\r\nreturn i;\r\n}\r\nstatic int debug_read_version(char *buf, int max)\r\n{\r\nstruct smem_shared *shared = (void *) MSM_SHARED_RAM_BASE;\r\nunsigned version = shared->version[VERSION_MODEM];\r\nreturn sprintf(buf, "%d.%d\n", version >> 16, version & 0xffff);\r\n}\r\nstatic int debug_read_build_id(char *buf, int max)\r\n{\r\nunsigned size;\r\nvoid *data;\r\ndata = smem_item(SMEM_HW_SW_BUILD_ID, &size);\r\nif (!data)\r\nreturn 0;\r\nif (size >= max)\r\nsize = max;\r\nmemcpy(buf, data, size);\r\nreturn size;\r\n}\r\nstatic int debug_read_alloc_tbl(char *buf, int max)\r\n{\r\nstruct smd_alloc_elm *shared;\r\nint n, i = 0;\r\nshared = smem_find(ID_CH_ALLOC_TBL, sizeof(*shared) * 64);\r\nfor (n = 0; n < 64; n++) {\r\nif (shared[n].ref_count == 0)\r\ncontinue;\r\ni += scnprintf(buf + i, max - i,\r\n"%03d: %-20s cid=%02d type=%03d "\r\n"kind=%02d ref_count=%d\n",\r\nn, shared[n].name, shared[n].cid,\r\nshared[n].ctype & 0xff,\r\n(shared[n].ctype >> 8) & 0xf,\r\nshared[n].ref_count);\r\n}\r\nreturn i;\r\n}\r\nstatic ssize_t debug_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint (*fill)(char *buf, int max) = file->private_data;\r\nint bsize = fill(debug_buffer, DEBUG_BUFMAX);\r\nreturn simple_read_from_buffer(buf, count, ppos, debug_buffer, bsize);\r\n}\r\nstatic void debug_create(const char *name, umode_t mode,\r\nstruct dentry *dent,\r\nint (*fill)(char *buf, int max))\r\n{\r\ndebugfs_create_file(name, mode, dent, fill, &debug_ops);\r\n}\r\nint __init smd_debugfs_init(void)\r\n{\r\nstruct dentry *dent;\r\ndent = debugfs_create_dir("smd", 0);\r\nif (IS_ERR(dent))\r\nreturn 1;\r\ndebug_create("ch", 0444, dent, debug_read_ch);\r\ndebug_create("stat", 0444, dent, debug_read_stat);\r\ndebug_create("mem", 0444, dent, debug_read_mem);\r\ndebug_create("version", 0444, dent, debug_read_version);\r\ndebug_create("tbl", 0444, dent, debug_read_alloc_tbl);\r\ndebug_create("build", 0444, dent, debug_read_build_id);\r\nreturn 0;\r\n}\r\nvoid smsm_print_sleep_info(void)\r\n{\r\nunsigned long flags;\r\nuint32_t *ptr;\r\n#ifndef CONFIG_ARCH_MSM_SCORPION\r\nstruct tramp_gpio_smem *gpio;\r\nstruct smsm_interrupt_info *int_info;\r\n#endif\r\nspin_lock_irqsave(&smem_lock, flags);\r\nptr = smem_alloc(SMEM_SMSM_SLEEP_DELAY, sizeof(*ptr));\r\nif (ptr)\r\npr_info("SMEM_SMSM_SLEEP_DELAY: %x\n", *ptr);\r\nptr = smem_alloc(SMEM_SMSM_LIMIT_SLEEP, sizeof(*ptr));\r\nif (ptr)\r\npr_info("SMEM_SMSM_LIMIT_SLEEP: %x\n", *ptr);\r\nptr = smem_alloc(SMEM_SLEEP_POWER_COLLAPSE_DISABLED, sizeof(*ptr));\r\nif (ptr)\r\npr_info("SMEM_SLEEP_POWER_COLLAPSE_DISABLED: %x\n", *ptr);\r\n#ifndef CONFIG_ARCH_MSM_SCORPION\r\nint_info = smem_alloc(SMEM_SMSM_INT_INFO, sizeof(*int_info));\r\nif (int_info)\r\npr_info("SMEM_SMSM_INT_INFO %x %x %x\n",\r\nint_info->interrupt_mask,\r\nint_info->pending_interrupts,\r\nint_info->wakeup_reason);\r\ngpio = smem_alloc(SMEM_GPIO_INT, sizeof(*gpio));\r\nif (gpio) {\r\nint i;\r\nfor (i = 0; i < NUM_GPIO_INT_REGISTERS; i++)\r\npr_info("SMEM_GPIO_INT: %d: e %x d %x p %x\n",\r\ni, gpio->enabled[i], gpio->detection[i],\r\ngpio->polarity[i]);\r\nfor (i = 0; i < GPIO_SMEM_NUM_GROUPS; i++)\r\npr_info("SMEM_GPIO_INT: %d: f %d: %d %d...\n",\r\ni, gpio->num_fired[i], gpio->fired[i][0],\r\ngpio->fired[i][1]);\r\n}\r\n#else\r\n#endif\r\nspin_unlock_irqrestore(&smem_lock, flags);\r\n}
