static inline int oxygen_uart_input_ready(struct oxygen *chip)\r\n{\r\nreturn !(oxygen_read8(chip, OXYGEN_MPU401 + 1) & MPU401_RX_EMPTY);\r\n}\r\nstatic void oxygen_read_uart(struct oxygen *chip)\r\n{\r\nif (unlikely(!oxygen_uart_input_ready(chip))) {\r\noxygen_read8(chip, OXYGEN_MPU401);\r\nreturn;\r\n}\r\ndo {\r\nu8 data = oxygen_read8(chip, OXYGEN_MPU401);\r\nif (data == MPU401_ACK)\r\ncontinue;\r\nif (chip->uart_input_count >= ARRAY_SIZE(chip->uart_input))\r\nchip->uart_input_count = 0;\r\nchip->uart_input[chip->uart_input_count++] = data;\r\n} while (oxygen_uart_input_ready(chip));\r\nif (chip->model.uart_input)\r\nchip->model.uart_input(chip);\r\n}\r\nstatic irqreturn_t oxygen_interrupt(int dummy, void *dev_id)\r\n{\r\nstruct oxygen *chip = dev_id;\r\nunsigned int status, clear, elapsed_streams, i;\r\nstatus = oxygen_read16(chip, OXYGEN_INTERRUPT_STATUS);\r\nif (!status)\r\nreturn IRQ_NONE;\r\nspin_lock(&chip->reg_lock);\r\nclear = status & (OXYGEN_CHANNEL_A |\r\nOXYGEN_CHANNEL_B |\r\nOXYGEN_CHANNEL_C |\r\nOXYGEN_CHANNEL_SPDIF |\r\nOXYGEN_CHANNEL_MULTICH |\r\nOXYGEN_CHANNEL_AC97 |\r\nOXYGEN_INT_SPDIF_IN_DETECT |\r\nOXYGEN_INT_GPIO |\r\nOXYGEN_INT_AC97);\r\nif (clear) {\r\nif (clear & OXYGEN_INT_SPDIF_IN_DETECT)\r\nchip->interrupt_mask &= ~OXYGEN_INT_SPDIF_IN_DETECT;\r\noxygen_write16(chip, OXYGEN_INTERRUPT_MASK,\r\nchip->interrupt_mask & ~clear);\r\noxygen_write16(chip, OXYGEN_INTERRUPT_MASK,\r\nchip->interrupt_mask);\r\n}\r\nelapsed_streams = status & chip->pcm_running;\r\nspin_unlock(&chip->reg_lock);\r\nfor (i = 0; i < PCM_COUNT; ++i)\r\nif ((elapsed_streams & (1 << i)) && chip->streams[i])\r\nsnd_pcm_period_elapsed(chip->streams[i]);\r\nif (status & OXYGEN_INT_SPDIF_IN_DETECT) {\r\nspin_lock(&chip->reg_lock);\r\ni = oxygen_read32(chip, OXYGEN_SPDIF_CONTROL);\r\nif (i & (OXYGEN_SPDIF_SENSE_INT | OXYGEN_SPDIF_LOCK_INT |\r\nOXYGEN_SPDIF_RATE_INT)) {\r\noxygen_write32(chip, OXYGEN_SPDIF_CONTROL, i);\r\nschedule_work(&chip->spdif_input_bits_work);\r\n}\r\nspin_unlock(&chip->reg_lock);\r\n}\r\nif (status & OXYGEN_INT_GPIO)\r\nschedule_work(&chip->gpio_work);\r\nif (status & OXYGEN_INT_MIDI) {\r\nif (chip->midi)\r\nsnd_mpu401_uart_interrupt(0, chip->midi->private_data);\r\nelse\r\noxygen_read_uart(chip);\r\n}\r\nif (status & OXYGEN_INT_AC97)\r\nwake_up(&chip->ac97_waitqueue);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void oxygen_spdif_input_bits_changed(struct work_struct *work)\r\n{\r\nstruct oxygen *chip = container_of(work, struct oxygen,\r\nspdif_input_bits_work);\r\nu32 reg;\r\nmsleep(1);\r\nspin_lock_irq(&chip->reg_lock);\r\nreg = oxygen_read32(chip, OXYGEN_SPDIF_CONTROL);\r\nif ((reg & (OXYGEN_SPDIF_SENSE_STATUS |\r\nOXYGEN_SPDIF_LOCK_STATUS))\r\n== OXYGEN_SPDIF_SENSE_STATUS) {\r\nreg ^= OXYGEN_SPDIF_IN_CLOCK_MASK;\r\noxygen_write32(chip, OXYGEN_SPDIF_CONTROL, reg);\r\nspin_unlock_irq(&chip->reg_lock);\r\nmsleep(1);\r\nspin_lock_irq(&chip->reg_lock);\r\nreg = oxygen_read32(chip, OXYGEN_SPDIF_CONTROL);\r\nif ((reg & (OXYGEN_SPDIF_SENSE_STATUS |\r\nOXYGEN_SPDIF_LOCK_STATUS))\r\n== OXYGEN_SPDIF_SENSE_STATUS) {\r\nif ((reg & OXYGEN_SPDIF_IN_CLOCK_MASK)\r\n== OXYGEN_SPDIF_IN_CLOCK_192) {\r\nreg &= ~OXYGEN_SPDIF_IN_CLOCK_MASK;\r\nreg |= OXYGEN_SPDIF_IN_CLOCK_96;\r\noxygen_write32(chip, OXYGEN_SPDIF_CONTROL, reg);\r\n}\r\n}\r\n}\r\nspin_unlock_irq(&chip->reg_lock);\r\nif (chip->controls[CONTROL_SPDIF_INPUT_BITS]) {\r\nspin_lock_irq(&chip->reg_lock);\r\nchip->interrupt_mask |= OXYGEN_INT_SPDIF_IN_DETECT;\r\noxygen_write16(chip, OXYGEN_INTERRUPT_MASK,\r\nchip->interrupt_mask);\r\nspin_unlock_irq(&chip->reg_lock);\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->controls[CONTROL_SPDIF_INPUT_BITS]->id);\r\n}\r\n}\r\nstatic void oxygen_gpio_changed(struct work_struct *work)\r\n{\r\nstruct oxygen *chip = container_of(work, struct oxygen, gpio_work);\r\nif (chip->model.gpio_changed)\r\nchip->model.gpio_changed(chip);\r\n}\r\nstatic void oxygen_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct oxygen *chip = entry->private_data;\r\nint i, j;\r\nswitch (oxygen_read8(chip, OXYGEN_REVISION) & OXYGEN_PACKAGE_ID_MASK) {\r\ncase OXYGEN_PACKAGE_ID_8786: i = '6'; break;\r\ncase OXYGEN_PACKAGE_ID_8787: i = '7'; break;\r\ncase OXYGEN_PACKAGE_ID_8788: i = '8'; break;\r\ndefault: i = '?'; break;\r\n}\r\nsnd_iprintf(buffer, "CMI878%c:\n", i);\r\nfor (i = 0; i < OXYGEN_IO_SIZE; i += 0x10) {\r\nsnd_iprintf(buffer, "%02x:", i);\r\nfor (j = 0; j < 0x10; ++j)\r\nsnd_iprintf(buffer, " %02x", oxygen_read8(chip, i + j));\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nif (mutex_lock_interruptible(&chip->mutex) < 0)\r\nreturn;\r\nif (chip->has_ac97_0) {\r\nsnd_iprintf(buffer, "\nAC97:\n");\r\nfor (i = 0; i < 0x80; i += 0x10) {\r\nsnd_iprintf(buffer, "%02x:", i);\r\nfor (j = 0; j < 0x10; j += 2)\r\nsnd_iprintf(buffer, " %04x",\r\noxygen_read_ac97(chip, 0, i + j));\r\nsnd_iprintf(buffer, "\n");\r\n}\r\n}\r\nif (chip->has_ac97_1) {\r\nsnd_iprintf(buffer, "\nAC97 2:\n");\r\nfor (i = 0; i < 0x80; i += 0x10) {\r\nsnd_iprintf(buffer, "%02x:", i);\r\nfor (j = 0; j < 0x10; j += 2)\r\nsnd_iprintf(buffer, " %04x",\r\noxygen_read_ac97(chip, 1, i + j));\r\nsnd_iprintf(buffer, "\n");\r\n}\r\n}\r\nmutex_unlock(&chip->mutex);\r\nif (chip->model.dump_registers)\r\nchip->model.dump_registers(chip, buffer);\r\n}\r\nstatic void oxygen_proc_init(struct oxygen *chip)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (!snd_card_proc_new(chip->card, "oxygen", &entry))\r\nsnd_info_set_text_ops(entry, chip, oxygen_proc_read);\r\n}\r\nstatic const struct pci_device_id *\r\noxygen_search_pci_id(struct oxygen *chip, const struct pci_device_id ids[])\r\n{\r\nu16 subdevice;\r\noxygen_clear_bits8(chip, OXYGEN_FUNCTION,\r\nOXYGEN_FUNCTION_ENABLE_SPI_4_5);\r\nsubdevice = oxygen_read_eeprom(chip, 2);\r\nif (subdevice == 0xffff && oxygen_read_eeprom(chip, 1) == 0xffff)\r\nsubdevice = 0x8788;\r\nfor (; ids->vendor; ++ids)\r\nif (ids->subdevice == subdevice &&\r\nids->driver_data != BROKEN_EEPROM_DRIVER_DATA)\r\nreturn ids;\r\nreturn NULL;\r\n}\r\nstatic void oxygen_restore_eeprom(struct oxygen *chip,\r\nconst struct pci_device_id *id)\r\n{\r\nu16 eeprom_id;\r\neeprom_id = oxygen_read_eeprom(chip, 0);\r\nif (eeprom_id != OXYGEN_EEPROM_ID &&\r\n(eeprom_id != 0xffff || id->subdevice != 0x8788)) {\r\noxygen_write_eeprom(chip, 1, id->subvendor);\r\noxygen_write_eeprom(chip, 0, OXYGEN_EEPROM_ID);\r\noxygen_set_bits8(chip, OXYGEN_MISC,\r\nOXYGEN_MISC_WRITE_PCI_SUBID);\r\npci_write_config_word(chip->pci, PCI_SUBSYSTEM_VENDOR_ID,\r\nid->subvendor);\r\npci_write_config_word(chip->pci, PCI_SUBSYSTEM_ID,\r\nid->subdevice);\r\noxygen_clear_bits8(chip, OXYGEN_MISC,\r\nOXYGEN_MISC_WRITE_PCI_SUBID);\r\ndev_info(chip->card->dev, "EEPROM ID restored\n");\r\n}\r\n}\r\nstatic void configure_pcie_bridge(struct pci_dev *pci)\r\n{\r\nenum { PEX811X, PI7C9X110 };\r\nstatic const struct pci_device_id bridge_ids[] = {\r\n{ PCI_VDEVICE(PLX, 0x8111), .driver_data = PEX811X },\r\n{ PCI_VDEVICE(PLX, 0x8112), .driver_data = PEX811X },\r\n{ PCI_DEVICE(0x12d8, 0xe110), .driver_data = PI7C9X110 },\r\n{ }\r\n};\r\nstruct pci_dev *bridge;\r\nconst struct pci_device_id *id;\r\nu32 tmp;\r\nif (!pci->bus || !pci->bus->self)\r\nreturn;\r\nbridge = pci->bus->self;\r\nid = pci_match_id(bridge_ids, bridge);\r\nif (!id)\r\nreturn;\r\nswitch (id->driver_data) {\r\ncase PEX811X:\r\npci_read_config_dword(bridge, 0x48, &tmp);\r\ntmp |= 1;\r\ntmp |= 1 << 11;\r\npci_write_config_dword(bridge, 0x48, tmp);\r\npci_write_config_dword(bridge, 0x84, 0x0c);\r\npci_read_config_dword(bridge, 0x88, &tmp);\r\ntmp &= ~(7 << 27);\r\ntmp |= 2 << 27;\r\npci_write_config_dword(bridge, 0x88, tmp);\r\nbreak;\r\ncase PI7C9X110:\r\npci_read_config_dword(bridge, 0x40, &tmp);\r\ntmp |= 1;\r\npci_write_config_dword(bridge, 0x40, tmp);\r\nbreak;\r\n}\r\n}\r\nstatic void oxygen_init(struct oxygen *chip)\r\n{\r\nunsigned int i;\r\nchip->dac_routing = 1;\r\nfor (i = 0; i < 8; ++i)\r\nchip->dac_volume[i] = chip->model.dac_volume_min;\r\nchip->dac_mute = 1;\r\nchip->spdif_playback_enable = 1;\r\nchip->spdif_bits = OXYGEN_SPDIF_C | OXYGEN_SPDIF_ORIGINAL |\r\n(IEC958_AES1_CON_PCM_CODER << OXYGEN_SPDIF_CATEGORY_SHIFT);\r\nchip->spdif_pcm_bits = chip->spdif_bits;\r\nif (!(oxygen_read8(chip, OXYGEN_REVISION) & OXYGEN_REVISION_2))\r\noxygen_set_bits8(chip, OXYGEN_MISC,\r\nOXYGEN_MISC_PCI_MEM_W_1_CLOCK);\r\ni = oxygen_read16(chip, OXYGEN_AC97_CONTROL);\r\nchip->has_ac97_0 = (i & OXYGEN_AC97_CODEC_0) != 0;\r\nchip->has_ac97_1 = (i & OXYGEN_AC97_CODEC_1) != 0;\r\noxygen_write8_masked(chip, OXYGEN_FUNCTION,\r\nOXYGEN_FUNCTION_RESET_CODEC |\r\nchip->model.function_flags,\r\nOXYGEN_FUNCTION_RESET_CODEC |\r\nOXYGEN_FUNCTION_2WIRE_SPI_MASK |\r\nOXYGEN_FUNCTION_ENABLE_SPI_4_5);\r\noxygen_write8(chip, OXYGEN_DMA_STATUS, 0);\r\noxygen_write8(chip, OXYGEN_DMA_PAUSE, 0);\r\noxygen_write8(chip, OXYGEN_PLAY_CHANNELS,\r\nOXYGEN_PLAY_CHANNELS_2 |\r\nOXYGEN_DMA_A_BURST_8 |\r\nOXYGEN_DMA_MULTICH_BURST_8);\r\noxygen_write16(chip, OXYGEN_INTERRUPT_MASK, 0);\r\noxygen_write8_masked(chip, OXYGEN_MISC,\r\nchip->model.misc_flags,\r\nOXYGEN_MISC_WRITE_PCI_SUBID |\r\nOXYGEN_MISC_REC_C_FROM_SPDIF |\r\nOXYGEN_MISC_REC_B_FROM_AC97 |\r\nOXYGEN_MISC_REC_A_FROM_MULTICH |\r\nOXYGEN_MISC_MIDI);\r\noxygen_write8(chip, OXYGEN_REC_FORMAT,\r\n(OXYGEN_FORMAT_16 << OXYGEN_REC_FORMAT_A_SHIFT) |\r\n(OXYGEN_FORMAT_16 << OXYGEN_REC_FORMAT_B_SHIFT) |\r\n(OXYGEN_FORMAT_16 << OXYGEN_REC_FORMAT_C_SHIFT));\r\noxygen_write8(chip, OXYGEN_PLAY_FORMAT,\r\n(OXYGEN_FORMAT_16 << OXYGEN_SPDIF_FORMAT_SHIFT) |\r\n(OXYGEN_FORMAT_16 << OXYGEN_MULTICH_FORMAT_SHIFT));\r\noxygen_write8(chip, OXYGEN_REC_CHANNELS, OXYGEN_REC_CHANNELS_2_2_2);\r\noxygen_write16(chip, OXYGEN_I2S_MULTICH_FORMAT,\r\nOXYGEN_RATE_48000 |\r\nchip->model.dac_i2s_format |\r\nOXYGEN_I2S_MCLK(chip->model.dac_mclks) |\r\nOXYGEN_I2S_BITS_16 |\r\nOXYGEN_I2S_MASTER |\r\nOXYGEN_I2S_BCLK_64);\r\nif (chip->model.device_config & CAPTURE_0_FROM_I2S_1)\r\noxygen_write16(chip, OXYGEN_I2S_A_FORMAT,\r\nOXYGEN_RATE_48000 |\r\nchip->model.adc_i2s_format |\r\nOXYGEN_I2S_MCLK(chip->model.adc_mclks) |\r\nOXYGEN_I2S_BITS_16 |\r\nOXYGEN_I2S_MASTER |\r\nOXYGEN_I2S_BCLK_64);\r\nelse\r\noxygen_write16(chip, OXYGEN_I2S_A_FORMAT,\r\nOXYGEN_I2S_MASTER |\r\nOXYGEN_I2S_MUTE_MCLK);\r\nif (chip->model.device_config & (CAPTURE_0_FROM_I2S_2 |\r\nCAPTURE_2_FROM_I2S_2))\r\noxygen_write16(chip, OXYGEN_I2S_B_FORMAT,\r\nOXYGEN_RATE_48000 |\r\nchip->model.adc_i2s_format |\r\nOXYGEN_I2S_MCLK(chip->model.adc_mclks) |\r\nOXYGEN_I2S_BITS_16 |\r\nOXYGEN_I2S_MASTER |\r\nOXYGEN_I2S_BCLK_64);\r\nelse\r\noxygen_write16(chip, OXYGEN_I2S_B_FORMAT,\r\nOXYGEN_I2S_MASTER |\r\nOXYGEN_I2S_MUTE_MCLK);\r\noxygen_write16(chip, OXYGEN_I2S_C_FORMAT,\r\nOXYGEN_I2S_MASTER |\r\nOXYGEN_I2S_MUTE_MCLK);\r\noxygen_clear_bits32(chip, OXYGEN_SPDIF_CONTROL,\r\nOXYGEN_SPDIF_OUT_ENABLE |\r\nOXYGEN_SPDIF_LOOPBACK);\r\nif (chip->model.device_config & CAPTURE_1_FROM_SPDIF)\r\noxygen_write32_masked(chip, OXYGEN_SPDIF_CONTROL,\r\nOXYGEN_SPDIF_SENSE_MASK |\r\nOXYGEN_SPDIF_LOCK_MASK |\r\nOXYGEN_SPDIF_RATE_MASK |\r\nOXYGEN_SPDIF_LOCK_PAR |\r\nOXYGEN_SPDIF_IN_CLOCK_96,\r\nOXYGEN_SPDIF_SENSE_MASK |\r\nOXYGEN_SPDIF_LOCK_MASK |\r\nOXYGEN_SPDIF_RATE_MASK |\r\nOXYGEN_SPDIF_SENSE_PAR |\r\nOXYGEN_SPDIF_LOCK_PAR |\r\nOXYGEN_SPDIF_IN_CLOCK_MASK);\r\nelse\r\noxygen_clear_bits32(chip, OXYGEN_SPDIF_CONTROL,\r\nOXYGEN_SPDIF_SENSE_MASK |\r\nOXYGEN_SPDIF_LOCK_MASK |\r\nOXYGEN_SPDIF_RATE_MASK);\r\noxygen_write32(chip, OXYGEN_SPDIF_OUTPUT_BITS, chip->spdif_bits);\r\noxygen_write16(chip, OXYGEN_2WIRE_BUS_STATUS,\r\nOXYGEN_2WIRE_LENGTH_8 |\r\nOXYGEN_2WIRE_INTERRUPT_MASK |\r\nOXYGEN_2WIRE_SPEED_STANDARD);\r\noxygen_clear_bits8(chip, OXYGEN_MPU401_CONTROL, OXYGEN_MPU401_LOOPBACK);\r\noxygen_write8(chip, OXYGEN_GPI_INTERRUPT_MASK, 0);\r\noxygen_write16(chip, OXYGEN_GPIO_INTERRUPT_MASK, 0);\r\noxygen_write16(chip, OXYGEN_PLAY_ROUTING,\r\nOXYGEN_PLAY_MULTICH_I2S_DAC |\r\nOXYGEN_PLAY_SPDIF_SPDIF |\r\n(0 << OXYGEN_PLAY_DAC0_SOURCE_SHIFT) |\r\n(1 << OXYGEN_PLAY_DAC1_SOURCE_SHIFT) |\r\n(2 << OXYGEN_PLAY_DAC2_SOURCE_SHIFT) |\r\n(3 << OXYGEN_PLAY_DAC3_SOURCE_SHIFT));\r\noxygen_write8(chip, OXYGEN_REC_ROUTING,\r\nOXYGEN_REC_A_ROUTE_I2S_ADC_1 |\r\nOXYGEN_REC_B_ROUTE_I2S_ADC_2 |\r\nOXYGEN_REC_C_ROUTE_SPDIF);\r\noxygen_write8(chip, OXYGEN_ADC_MONITOR, 0);\r\noxygen_write8(chip, OXYGEN_A_MONITOR_ROUTING,\r\n(0 << OXYGEN_A_MONITOR_ROUTE_0_SHIFT) |\r\n(1 << OXYGEN_A_MONITOR_ROUTE_1_SHIFT) |\r\n(2 << OXYGEN_A_MONITOR_ROUTE_2_SHIFT) |\r\n(3 << OXYGEN_A_MONITOR_ROUTE_3_SHIFT));\r\nif (chip->has_ac97_0 | chip->has_ac97_1)\r\noxygen_write8(chip, OXYGEN_AC97_INTERRUPT_MASK,\r\nOXYGEN_AC97_INT_READ_DONE |\r\nOXYGEN_AC97_INT_WRITE_DONE);\r\nelse\r\noxygen_write8(chip, OXYGEN_AC97_INTERRUPT_MASK, 0);\r\noxygen_write32(chip, OXYGEN_AC97_OUT_CONFIG, 0);\r\noxygen_write32(chip, OXYGEN_AC97_IN_CONFIG, 0);\r\nif (!(chip->has_ac97_0 | chip->has_ac97_1))\r\noxygen_set_bits16(chip, OXYGEN_AC97_CONTROL,\r\nOXYGEN_AC97_CLOCK_DISABLE);\r\nif (!chip->has_ac97_0) {\r\noxygen_set_bits16(chip, OXYGEN_AC97_CONTROL,\r\nOXYGEN_AC97_NO_CODEC_0);\r\n} else {\r\noxygen_write_ac97(chip, 0, AC97_RESET, 0);\r\nmsleep(1);\r\noxygen_ac97_set_bits(chip, 0, CM9780_GPIO_SETUP,\r\nCM9780_GPIO0IO | CM9780_GPIO1IO);\r\noxygen_ac97_set_bits(chip, 0, CM9780_MIXER,\r\nCM9780_BSTSEL | CM9780_STRO_MIC |\r\nCM9780_MIX2FR | CM9780_PCBSW);\r\noxygen_ac97_set_bits(chip, 0, CM9780_JACK,\r\nCM9780_RSOE | CM9780_CBOE |\r\nCM9780_SSOE | CM9780_FROE |\r\nCM9780_MIC2MIC | CM9780_LI2LI);\r\noxygen_write_ac97(chip, 0, AC97_MASTER, 0x0000);\r\noxygen_write_ac97(chip, 0, AC97_PC_BEEP, 0x8000);\r\noxygen_write_ac97(chip, 0, AC97_MIC, 0x8808);\r\noxygen_write_ac97(chip, 0, AC97_LINE, 0x0808);\r\noxygen_write_ac97(chip, 0, AC97_CD, 0x8808);\r\noxygen_write_ac97(chip, 0, AC97_VIDEO, 0x8808);\r\noxygen_write_ac97(chip, 0, AC97_AUX, 0x8808);\r\noxygen_write_ac97(chip, 0, AC97_REC_GAIN, 0x8000);\r\noxygen_write_ac97(chip, 0, AC97_CENTER_LFE_MASTER, 0x8080);\r\noxygen_write_ac97(chip, 0, AC97_SURROUND_MASTER, 0x8080);\r\noxygen_ac97_clear_bits(chip, 0, CM9780_GPIO_STATUS,\r\nCM9780_GPO0);\r\noxygen_ac97_set_bits(chip, 0, AC97_POWERDOWN,\r\nAC97_PD_PR0 | AC97_PD_PR1);\r\noxygen_ac97_set_bits(chip, 0, AC97_EXTENDED_STATUS,\r\nAC97_EA_PRI | AC97_EA_PRJ | AC97_EA_PRK);\r\n}\r\nif (chip->has_ac97_1) {\r\noxygen_set_bits32(chip, OXYGEN_AC97_OUT_CONFIG,\r\nOXYGEN_AC97_CODEC1_SLOT3 |\r\nOXYGEN_AC97_CODEC1_SLOT4);\r\noxygen_write_ac97(chip, 1, AC97_RESET, 0);\r\nmsleep(1);\r\noxygen_write_ac97(chip, 1, AC97_MASTER, 0x0000);\r\noxygen_write_ac97(chip, 1, AC97_HEADPHONE, 0x8000);\r\noxygen_write_ac97(chip, 1, AC97_PC_BEEP, 0x8000);\r\noxygen_write_ac97(chip, 1, AC97_MIC, 0x8808);\r\noxygen_write_ac97(chip, 1, AC97_LINE, 0x8808);\r\noxygen_write_ac97(chip, 1, AC97_CD, 0x8808);\r\noxygen_write_ac97(chip, 1, AC97_VIDEO, 0x8808);\r\noxygen_write_ac97(chip, 1, AC97_AUX, 0x8808);\r\noxygen_write_ac97(chip, 1, AC97_PCM, 0x0808);\r\noxygen_write_ac97(chip, 1, AC97_REC_SEL, 0x0000);\r\noxygen_write_ac97(chip, 1, AC97_REC_GAIN, 0x0000);\r\noxygen_ac97_set_bits(chip, 1, 0x6a, 0x0040);\r\n}\r\n}\r\nstatic void oxygen_shutdown(struct oxygen *chip)\r\n{\r\nspin_lock_irq(&chip->reg_lock);\r\nchip->interrupt_mask = 0;\r\nchip->pcm_running = 0;\r\noxygen_write16(chip, OXYGEN_DMA_STATUS, 0);\r\noxygen_write16(chip, OXYGEN_INTERRUPT_MASK, 0);\r\nspin_unlock_irq(&chip->reg_lock);\r\n}\r\nstatic void oxygen_card_free(struct snd_card *card)\r\n{\r\nstruct oxygen *chip = card->private_data;\r\noxygen_shutdown(chip);\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\nflush_work(&chip->spdif_input_bits_work);\r\nflush_work(&chip->gpio_work);\r\nchip->model.cleanup(chip);\r\nkfree(chip->model_data);\r\nmutex_destroy(&chip->mutex);\r\npci_release_regions(chip->pci);\r\npci_disable_device(chip->pci);\r\n}\r\nint oxygen_pci_probe(struct pci_dev *pci, int index, char *id,\r\nstruct module *owner,\r\nconst struct pci_device_id *ids,\r\nint (*get_model)(struct oxygen *chip,\r\nconst struct pci_device_id *id\r\n)\r\n)\r\n{\r\nstruct snd_card *card;\r\nstruct oxygen *chip;\r\nconst struct pci_device_id *pci_id;\r\nint err;\r\nerr = snd_card_new(&pci->dev, index, id, owner,\r\nsizeof(*chip), &card);\r\nif (err < 0)\r\nreturn err;\r\nchip = card->private_data;\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\nspin_lock_init(&chip->reg_lock);\r\nmutex_init(&chip->mutex);\r\nINIT_WORK(&chip->spdif_input_bits_work,\r\noxygen_spdif_input_bits_changed);\r\nINIT_WORK(&chip->gpio_work, oxygen_gpio_changed);\r\ninit_waitqueue_head(&chip->ac97_waitqueue);\r\nerr = pci_enable_device(pci);\r\nif (err < 0)\r\ngoto err_card;\r\nerr = pci_request_regions(pci, DRIVER);\r\nif (err < 0) {\r\ndev_err(card->dev, "cannot reserve PCI resources\n");\r\ngoto err_pci_enable;\r\n}\r\nif (!(pci_resource_flags(pci, 0) & IORESOURCE_IO) ||\r\npci_resource_len(pci, 0) < OXYGEN_IO_SIZE) {\r\ndev_err(card->dev, "invalid PCI I/O range\n");\r\nerr = -ENXIO;\r\ngoto err_pci_regions;\r\n}\r\nchip->addr = pci_resource_start(pci, 0);\r\npci_id = oxygen_search_pci_id(chip, ids);\r\nif (!pci_id) {\r\nerr = -ENODEV;\r\ngoto err_pci_regions;\r\n}\r\noxygen_restore_eeprom(chip, pci_id);\r\nerr = get_model(chip, pci_id);\r\nif (err < 0)\r\ngoto err_pci_regions;\r\nif (chip->model.model_data_size) {\r\nchip->model_data = kzalloc(chip->model.model_data_size,\r\nGFP_KERNEL);\r\nif (!chip->model_data) {\r\nerr = -ENOMEM;\r\ngoto err_pci_regions;\r\n}\r\n}\r\npci_set_master(pci);\r\ncard->private_free = oxygen_card_free;\r\nconfigure_pcie_bridge(pci);\r\noxygen_init(chip);\r\nchip->model.init(chip);\r\nerr = request_irq(pci->irq, oxygen_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, chip);\r\nif (err < 0) {\r\ndev_err(card->dev, "cannot grab interrupt %d\n", pci->irq);\r\ngoto err_card;\r\n}\r\nchip->irq = pci->irq;\r\nstrcpy(card->driver, chip->model.chip);\r\nstrcpy(card->shortname, chip->model.shortname);\r\nsprintf(card->longname, "%s at %#lx, irq %i",\r\nchip->model.longname, chip->addr, chip->irq);\r\nstrcpy(card->mixername, chip->model.chip);\r\nsnd_component_add(card, chip->model.chip);\r\nerr = oxygen_pcm_init(chip);\r\nif (err < 0)\r\ngoto err_card;\r\nerr = oxygen_mixer_init(chip);\r\nif (err < 0)\r\ngoto err_card;\r\nif (chip->model.device_config & (MIDI_OUTPUT | MIDI_INPUT)) {\r\nunsigned int info_flags =\r\nMPU401_INFO_INTEGRATED | MPU401_INFO_IRQ_HOOK;\r\nif (chip->model.device_config & MIDI_OUTPUT)\r\ninfo_flags |= MPU401_INFO_OUTPUT;\r\nif (chip->model.device_config & MIDI_INPUT)\r\ninfo_flags |= MPU401_INFO_INPUT;\r\nerr = snd_mpu401_uart_new(card, 0, MPU401_HW_CMIPCI,\r\nchip->addr + OXYGEN_MPU401,\r\ninfo_flags, -1, &chip->midi);\r\nif (err < 0)\r\ngoto err_card;\r\n}\r\noxygen_proc_init(chip);\r\nspin_lock_irq(&chip->reg_lock);\r\nif (chip->model.device_config & CAPTURE_1_FROM_SPDIF)\r\nchip->interrupt_mask |= OXYGEN_INT_SPDIF_IN_DETECT;\r\nif (chip->has_ac97_0 | chip->has_ac97_1)\r\nchip->interrupt_mask |= OXYGEN_INT_AC97;\r\noxygen_write16(chip, OXYGEN_INTERRUPT_MASK, chip->interrupt_mask);\r\nspin_unlock_irq(&chip->reg_lock);\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto err_card;\r\npci_set_drvdata(pci, card);\r\nreturn 0;\r\nerr_pci_regions:\r\npci_release_regions(pci);\r\nerr_pci_enable:\r\npci_disable_device(pci);\r\nerr_card:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nvoid oxygen_pci_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\n}\r\nstatic int oxygen_pci_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct oxygen *chip = card->private_data;\r\nunsigned int i, saved_interrupt_mask;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nfor (i = 0; i < PCM_COUNT; ++i)\r\nif (chip->streams[i])\r\nsnd_pcm_suspend(chip->streams[i]);\r\nif (chip->model.suspend)\r\nchip->model.suspend(chip);\r\nspin_lock_irq(&chip->reg_lock);\r\nsaved_interrupt_mask = chip->interrupt_mask;\r\nchip->interrupt_mask = 0;\r\noxygen_write16(chip, OXYGEN_DMA_STATUS, 0);\r\noxygen_write16(chip, OXYGEN_INTERRUPT_MASK, 0);\r\nspin_unlock_irq(&chip->reg_lock);\r\nsynchronize_irq(chip->irq);\r\nflush_work(&chip->spdif_input_bits_work);\r\nflush_work(&chip->gpio_work);\r\nchip->interrupt_mask = saved_interrupt_mask;\r\npci_disable_device(pci);\r\npci_save_state(pci);\r\npci_set_power_state(pci, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic inline int is_bit_set(const u32 *bitmap, unsigned int bit)\r\n{\r\nreturn bitmap[bit / 32] & (1 << (bit & 31));\r\n}\r\nstatic void oxygen_restore_ac97(struct oxygen *chip, unsigned int codec)\r\n{\r\nunsigned int i;\r\noxygen_write_ac97(chip, codec, AC97_RESET, 0);\r\nmsleep(1);\r\nfor (i = 1; i < 0x40; ++i)\r\nif (is_bit_set(ac97_registers_to_restore[codec], i))\r\noxygen_write_ac97(chip, codec, i * 2,\r\nchip->saved_ac97_registers[codec][i]);\r\n}\r\nstatic int oxygen_pci_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct oxygen *chip = card->private_data;\r\nunsigned int i;\r\npci_set_power_state(pci, PCI_D0);\r\npci_restore_state(pci);\r\nif (pci_enable_device(pci) < 0) {\r\ndev_err(dev, "cannot reenable device");\r\nsnd_card_disconnect(card);\r\nreturn -EIO;\r\n}\r\npci_set_master(pci);\r\noxygen_write16(chip, OXYGEN_DMA_STATUS, 0);\r\noxygen_write16(chip, OXYGEN_INTERRUPT_MASK, 0);\r\nfor (i = 0; i < OXYGEN_IO_SIZE; ++i)\r\nif (is_bit_set(registers_to_restore, i))\r\noxygen_write8(chip, i, chip->saved_registers._8[i]);\r\nif (chip->has_ac97_0)\r\noxygen_restore_ac97(chip, 0);\r\nif (chip->has_ac97_1)\r\noxygen_restore_ac97(chip, 1);\r\nif (chip->model.resume)\r\nchip->model.resume(chip);\r\noxygen_write16(chip, OXYGEN_INTERRUPT_MASK, chip->interrupt_mask);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nvoid oxygen_pci_shutdown(struct pci_dev *pci)\r\n{\r\nstruct snd_card *card = pci_get_drvdata(pci);\r\nstruct oxygen *chip = card->private_data;\r\noxygen_shutdown(chip);\r\nchip->model.cleanup(chip);\r\n}
