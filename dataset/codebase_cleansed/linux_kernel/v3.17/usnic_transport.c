const char *usnic_transport_to_str(enum usnic_transport_type type)\r\n{\r\nswitch (type) {\r\ncase USNIC_TRANSPORT_UNKNOWN:\r\nreturn "Unknown";\r\ncase USNIC_TRANSPORT_ROCE_CUSTOM:\r\nreturn "roce custom";\r\ncase USNIC_TRANSPORT_IPV4_UDP:\r\nreturn "IPv4 UDP";\r\ncase USNIC_TRANSPORT_MAX:\r\nreturn "Max?";\r\ndefault:\r\nreturn "Not known";\r\n}\r\n}\r\nint usnic_transport_sock_to_str(char *buf, int buf_sz,\r\nstruct socket *sock)\r\n{\r\nint err;\r\nuint32_t addr;\r\nuint16_t port;\r\nint proto;\r\nmemset(buf, 0, buf_sz);\r\nerr = usnic_transport_sock_get_addr(sock, &proto, &addr, &port);\r\nif (err)\r\nreturn 0;\r\nreturn scnprintf(buf, buf_sz, "Proto:%u Addr:%pI4h Port:%hu",\r\nproto, &addr, port);\r\n}\r\nu16 usnic_transport_rsrv_port(enum usnic_transport_type type, u16 port_num)\r\n{\r\nif (type == USNIC_TRANSPORT_ROCE_CUSTOM) {\r\nspin_lock(&roce_bitmap_lock);\r\nif (!port_num) {\r\nport_num = bitmap_find_next_zero_area(roce_bitmap,\r\nROCE_BITMAP_SZ,\r\nroce_next_port ,\r\n1 ,\r\n0 );\r\nroce_next_port = (port_num & 4095) + 1;\r\n} else if (test_bit(port_num, roce_bitmap)) {\r\nusnic_err("Failed to allocate port for %s\n",\r\nusnic_transport_to_str(type));\r\nspin_unlock(&roce_bitmap_lock);\r\ngoto out_fail;\r\n}\r\nbitmap_set(roce_bitmap, port_num, 1);\r\nspin_unlock(&roce_bitmap_lock);\r\n} else {\r\nusnic_err("Failed to allocate port - transport %s unsupported\n",\r\nusnic_transport_to_str(type));\r\ngoto out_fail;\r\n}\r\nusnic_dbg("Allocating port %hu for %s\n", port_num,\r\nusnic_transport_to_str(type));\r\nreturn port_num;\r\nout_fail:\r\nreturn 0;\r\n}\r\nvoid usnic_transport_unrsrv_port(enum usnic_transport_type type, u16 port_num)\r\n{\r\nif (type == USNIC_TRANSPORT_ROCE_CUSTOM) {\r\nspin_lock(&roce_bitmap_lock);\r\nif (!port_num) {\r\nusnic_err("Unreserved unvalid port num 0 for %s\n",\r\nusnic_transport_to_str(type));\r\ngoto out_roce_custom;\r\n}\r\nif (!test_bit(port_num, roce_bitmap)) {\r\nusnic_err("Unreserving invalid %hu for %s\n",\r\nport_num,\r\nusnic_transport_to_str(type));\r\ngoto out_roce_custom;\r\n}\r\nbitmap_clear(roce_bitmap, port_num, 1);\r\nusnic_dbg("Freeing port %hu for %s\n", port_num,\r\nusnic_transport_to_str(type));\r\nout_roce_custom:\r\nspin_unlock(&roce_bitmap_lock);\r\n} else {\r\nusnic_err("Freeing invalid port %hu for %d\n", port_num, type);\r\n}\r\n}\r\nstruct socket *usnic_transport_get_socket(int sock_fd)\r\n{\r\nstruct socket *sock;\r\nint err;\r\nchar buf[25];\r\nsock = sockfd_lookup(sock_fd, &err);\r\nif (!sock) {\r\nusnic_err("Unable to lookup socket for fd %d with err %d\n",\r\nsock_fd, err);\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nusnic_transport_sock_to_str(buf, sizeof(buf), sock);\r\nusnic_dbg("Get sock %s\n", buf);\r\nreturn sock;\r\n}\r\nvoid usnic_transport_put_socket(struct socket *sock)\r\n{\r\nchar buf[100];\r\nusnic_transport_sock_to_str(buf, sizeof(buf), sock);\r\nusnic_dbg("Put sock %s\n", buf);\r\nsockfd_put(sock);\r\n}\r\nint usnic_transport_sock_get_addr(struct socket *sock, int *proto,\r\nuint32_t *addr, uint16_t *port)\r\n{\r\nint len;\r\nint err;\r\nstruct sockaddr_in sock_addr;\r\nerr = sock->ops->getname(sock,\r\n(struct sockaddr *)&sock_addr,\r\n&len, 0);\r\nif (err)\r\nreturn err;\r\nif (sock_addr.sin_family != AF_INET)\r\nreturn -EINVAL;\r\nif (proto)\r\n*proto = sock->sk->sk_protocol;\r\nif (port)\r\n*port = ntohs(((struct sockaddr_in *)&sock_addr)->sin_port);\r\nif (addr)\r\n*addr = ntohl(((struct sockaddr_in *)\r\n&sock_addr)->sin_addr.s_addr);\r\nreturn 0;\r\n}\r\nint usnic_transport_init(void)\r\n{\r\nroce_bitmap = kzalloc(ROCE_BITMAP_SZ, GFP_KERNEL);\r\nif (!roce_bitmap) {\r\nusnic_err("Failed to allocate bit map");\r\nreturn -ENOMEM;\r\n}\r\nbitmap_set(roce_bitmap, 0, 1);\r\nreturn 0;\r\n}\r\nvoid usnic_transport_fini(void)\r\n{\r\nkfree(roce_bitmap);\r\n}
