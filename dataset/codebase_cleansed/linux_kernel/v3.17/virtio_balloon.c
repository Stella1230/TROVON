static u32 page_to_balloon_pfn(struct page *page)\r\n{\r\nunsigned long pfn = page_to_pfn(page);\r\nBUILD_BUG_ON(PAGE_SHIFT < VIRTIO_BALLOON_PFN_SHIFT);\r\nreturn pfn * VIRTIO_BALLOON_PAGES_PER_PAGE;\r\n}\r\nstatic struct page *balloon_pfn_to_page(u32 pfn)\r\n{\r\nBUG_ON(pfn % VIRTIO_BALLOON_PAGES_PER_PAGE);\r\nreturn pfn_to_page(pfn / VIRTIO_BALLOON_PAGES_PER_PAGE);\r\n}\r\nstatic void balloon_ack(struct virtqueue *vq)\r\n{\r\nstruct virtio_balloon *vb = vq->vdev->priv;\r\nwake_up(&vb->acked);\r\n}\r\nstatic void tell_host(struct virtio_balloon *vb, struct virtqueue *vq)\r\n{\r\nstruct scatterlist sg;\r\nunsigned int len;\r\nsg_init_one(&sg, vb->pfns, sizeof(vb->pfns[0]) * vb->num_pfns);\r\nvirtqueue_add_outbuf(vq, &sg, 1, vb, GFP_KERNEL);\r\nvirtqueue_kick(vq);\r\nwait_event(vb->acked, virtqueue_get_buf(vq, &len));\r\n}\r\nstatic void set_page_pfns(u32 pfns[], struct page *page)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < VIRTIO_BALLOON_PAGES_PER_PAGE; i++)\r\npfns[i] = page_to_balloon_pfn(page) + i;\r\n}\r\nstatic void fill_balloon(struct virtio_balloon *vb, size_t num)\r\n{\r\nstruct balloon_dev_info *vb_dev_info = vb->vb_dev_info;\r\nnum = min(num, ARRAY_SIZE(vb->pfns));\r\nmutex_lock(&vb->balloon_lock);\r\nfor (vb->num_pfns = 0; vb->num_pfns < num;\r\nvb->num_pfns += VIRTIO_BALLOON_PAGES_PER_PAGE) {\r\nstruct page *page = balloon_page_enqueue(vb_dev_info);\r\nif (!page) {\r\ndev_info_ratelimited(&vb->vdev->dev,\r\n"Out of puff! Can't get %u pages\n",\r\nVIRTIO_BALLOON_PAGES_PER_PAGE);\r\nmsleep(200);\r\nbreak;\r\n}\r\nset_page_pfns(vb->pfns + vb->num_pfns, page);\r\nvb->num_pages += VIRTIO_BALLOON_PAGES_PER_PAGE;\r\nadjust_managed_page_count(page, -1);\r\n}\r\nif (vb->num_pfns != 0)\r\ntell_host(vb, vb->inflate_vq);\r\nmutex_unlock(&vb->balloon_lock);\r\n}\r\nstatic void release_pages_by_pfn(const u32 pfns[], unsigned int num)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < num; i += VIRTIO_BALLOON_PAGES_PER_PAGE) {\r\nstruct page *page = balloon_pfn_to_page(pfns[i]);\r\nballoon_page_free(page);\r\nadjust_managed_page_count(page, 1);\r\n}\r\n}\r\nstatic void leak_balloon(struct virtio_balloon *vb, size_t num)\r\n{\r\nstruct page *page;\r\nstruct balloon_dev_info *vb_dev_info = vb->vb_dev_info;\r\nnum = min(num, ARRAY_SIZE(vb->pfns));\r\nmutex_lock(&vb->balloon_lock);\r\nfor (vb->num_pfns = 0; vb->num_pfns < num;\r\nvb->num_pfns += VIRTIO_BALLOON_PAGES_PER_PAGE) {\r\npage = balloon_page_dequeue(vb_dev_info);\r\nif (!page)\r\nbreak;\r\nset_page_pfns(vb->pfns + vb->num_pfns, page);\r\nvb->num_pages -= VIRTIO_BALLOON_PAGES_PER_PAGE;\r\n}\r\nif (vb->num_pfns != 0)\r\ntell_host(vb, vb->deflate_vq);\r\nmutex_unlock(&vb->balloon_lock);\r\nrelease_pages_by_pfn(vb->pfns, vb->num_pfns);\r\n}\r\nstatic inline void update_stat(struct virtio_balloon *vb, int idx,\r\nu16 tag, u64 val)\r\n{\r\nBUG_ON(idx >= VIRTIO_BALLOON_S_NR);\r\nvb->stats[idx].tag = tag;\r\nvb->stats[idx].val = val;\r\n}\r\nstatic void update_balloon_stats(struct virtio_balloon *vb)\r\n{\r\nunsigned long events[NR_VM_EVENT_ITEMS];\r\nstruct sysinfo i;\r\nint idx = 0;\r\nall_vm_events(events);\r\nsi_meminfo(&i);\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_SWAP_IN,\r\npages_to_bytes(events[PSWPIN]));\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_SWAP_OUT,\r\npages_to_bytes(events[PSWPOUT]));\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_MAJFLT, events[PGMAJFAULT]);\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_MINFLT, events[PGFAULT]);\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_MEMFREE,\r\npages_to_bytes(i.freeram));\r\nupdate_stat(vb, idx++, VIRTIO_BALLOON_S_MEMTOT,\r\npages_to_bytes(i.totalram));\r\n}\r\nstatic void stats_request(struct virtqueue *vq)\r\n{\r\nstruct virtio_balloon *vb = vq->vdev->priv;\r\nvb->need_stats_update = 1;\r\nwake_up(&vb->config_change);\r\n}\r\nstatic void stats_handle_request(struct virtio_balloon *vb)\r\n{\r\nstruct virtqueue *vq;\r\nstruct scatterlist sg;\r\nunsigned int len;\r\nvb->need_stats_update = 0;\r\nupdate_balloon_stats(vb);\r\nvq = vb->stats_vq;\r\nif (!virtqueue_get_buf(vq, &len))\r\nreturn;\r\nsg_init_one(&sg, vb->stats, sizeof(vb->stats));\r\nvirtqueue_add_outbuf(vq, &sg, 1, vb, GFP_KERNEL);\r\nvirtqueue_kick(vq);\r\n}\r\nstatic void virtballoon_changed(struct virtio_device *vdev)\r\n{\r\nstruct virtio_balloon *vb = vdev->priv;\r\nwake_up(&vb->config_change);\r\n}\r\nstatic inline s64 towards_target(struct virtio_balloon *vb)\r\n{\r\n__le32 v;\r\ns64 target;\r\nvirtio_cread(vb->vdev, struct virtio_balloon_config, num_pages, &v);\r\ntarget = le32_to_cpu(v);\r\nreturn target - vb->num_pages;\r\n}\r\nstatic void update_balloon_size(struct virtio_balloon *vb)\r\n{\r\n__le32 actual = cpu_to_le32(vb->num_pages);\r\nvirtio_cwrite(vb->vdev, struct virtio_balloon_config, actual,\r\n&actual);\r\n}\r\nstatic int balloon(void *_vballoon)\r\n{\r\nstruct virtio_balloon *vb = _vballoon;\r\nset_freezable();\r\nwhile (!kthread_should_stop()) {\r\ns64 diff;\r\ntry_to_freeze();\r\nwait_event_interruptible(vb->config_change,\r\n(diff = towards_target(vb)) != 0\r\n|| vb->need_stats_update\r\n|| kthread_should_stop()\r\n|| freezing(current));\r\nif (vb->need_stats_update)\r\nstats_handle_request(vb);\r\nif (diff > 0)\r\nfill_balloon(vb, diff);\r\nelse if (diff < 0)\r\nleak_balloon(vb, -diff);\r\nupdate_balloon_size(vb);\r\ncond_resched();\r\n}\r\nreturn 0;\r\n}\r\nstatic int init_vqs(struct virtio_balloon *vb)\r\n{\r\nstruct virtqueue *vqs[3];\r\nvq_callback_t *callbacks[] = { balloon_ack, balloon_ack, stats_request };\r\nconst char *names[] = { "inflate", "deflate", "stats" };\r\nint err, nvqs;\r\nnvqs = virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_STATS_VQ) ? 3 : 2;\r\nerr = vb->vdev->config->find_vqs(vb->vdev, nvqs, vqs, callbacks, names);\r\nif (err)\r\nreturn err;\r\nvb->inflate_vq = vqs[0];\r\nvb->deflate_vq = vqs[1];\r\nif (virtio_has_feature(vb->vdev, VIRTIO_BALLOON_F_STATS_VQ)) {\r\nstruct scatterlist sg;\r\nvb->stats_vq = vqs[2];\r\nsg_init_one(&sg, vb->stats, sizeof vb->stats);\r\nif (virtqueue_add_outbuf(vb->stats_vq, &sg, 1, vb, GFP_KERNEL)\r\n< 0)\r\nBUG();\r\nvirtqueue_kick(vb->stats_vq);\r\n}\r\nreturn 0;\r\n}\r\nstatic int virtballoon_migratepage(struct address_space *mapping,\r\nstruct page *newpage, struct page *page, enum migrate_mode mode)\r\n{\r\nstruct balloon_dev_info *vb_dev_info = balloon_page_device(page);\r\nstruct virtio_balloon *vb;\r\nunsigned long flags;\r\nBUG_ON(!vb_dev_info);\r\nvb = vb_dev_info->balloon_device;\r\nif (!mutex_trylock(&vb->balloon_lock))\r\nreturn -EAGAIN;\r\nspin_lock_irqsave(&vb_dev_info->pages_lock, flags);\r\nballoon_page_insert(newpage, mapping, &vb_dev_info->pages);\r\nvb_dev_info->isolated_pages--;\r\nspin_unlock_irqrestore(&vb_dev_info->pages_lock, flags);\r\nvb->num_pfns = VIRTIO_BALLOON_PAGES_PER_PAGE;\r\nset_page_pfns(vb->pfns, newpage);\r\ntell_host(vb, vb->inflate_vq);\r\nballoon_page_delete(page);\r\nvb->num_pfns = VIRTIO_BALLOON_PAGES_PER_PAGE;\r\nset_page_pfns(vb->pfns, page);\r\ntell_host(vb, vb->deflate_vq);\r\nmutex_unlock(&vb->balloon_lock);\r\nreturn MIGRATEPAGE_BALLOON_SUCCESS;\r\n}\r\nstatic int virtballoon_probe(struct virtio_device *vdev)\r\n{\r\nstruct virtio_balloon *vb;\r\nstruct address_space *vb_mapping;\r\nstruct balloon_dev_info *vb_devinfo;\r\nint err;\r\nvdev->priv = vb = kmalloc(sizeof(*vb), GFP_KERNEL);\r\nif (!vb) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nvb->num_pages = 0;\r\nmutex_init(&vb->balloon_lock);\r\ninit_waitqueue_head(&vb->config_change);\r\ninit_waitqueue_head(&vb->acked);\r\nvb->vdev = vdev;\r\nvb->need_stats_update = 0;\r\nvb_devinfo = balloon_devinfo_alloc(vb);\r\nif (IS_ERR(vb_devinfo)) {\r\nerr = PTR_ERR(vb_devinfo);\r\ngoto out_free_vb;\r\n}\r\nvb_mapping = balloon_mapping_alloc(vb_devinfo,\r\n(balloon_compaction_check()) ?\r\n&virtio_balloon_aops : NULL);\r\nif (IS_ERR(vb_mapping)) {\r\nerr = PTR_ERR(vb_mapping);\r\nif (err != -EOPNOTSUPP)\r\ngoto out_free_vb_devinfo;\r\n}\r\nvb->vb_dev_info = vb_devinfo;\r\nerr = init_vqs(vb);\r\nif (err)\r\ngoto out_free_vb_mapping;\r\nvb->thread = kthread_run(balloon, vb, "vballoon");\r\nif (IS_ERR(vb->thread)) {\r\nerr = PTR_ERR(vb->thread);\r\ngoto out_del_vqs;\r\n}\r\nreturn 0;\r\nout_del_vqs:\r\nvdev->config->del_vqs(vdev);\r\nout_free_vb_mapping:\r\nballoon_mapping_free(vb_mapping);\r\nout_free_vb_devinfo:\r\nballoon_devinfo_free(vb_devinfo);\r\nout_free_vb:\r\nkfree(vb);\r\nout:\r\nreturn err;\r\n}\r\nstatic void remove_common(struct virtio_balloon *vb)\r\n{\r\nwhile (vb->num_pages)\r\nleak_balloon(vb, vb->num_pages);\r\nupdate_balloon_size(vb);\r\nvb->vdev->config->reset(vb->vdev);\r\nvb->vdev->config->del_vqs(vb->vdev);\r\n}\r\nstatic void virtballoon_remove(struct virtio_device *vdev)\r\n{\r\nstruct virtio_balloon *vb = vdev->priv;\r\nkthread_stop(vb->thread);\r\nremove_common(vb);\r\nballoon_mapping_free(vb->vb_dev_info->mapping);\r\nballoon_devinfo_free(vb->vb_dev_info);\r\nkfree(vb);\r\n}\r\nstatic int virtballoon_freeze(struct virtio_device *vdev)\r\n{\r\nstruct virtio_balloon *vb = vdev->priv;\r\nremove_common(vb);\r\nreturn 0;\r\n}\r\nstatic int virtballoon_restore(struct virtio_device *vdev)\r\n{\r\nstruct virtio_balloon *vb = vdev->priv;\r\nint ret;\r\nret = init_vqs(vdev->priv);\r\nif (ret)\r\nreturn ret;\r\nfill_balloon(vb, towards_target(vb));\r\nupdate_balloon_size(vb);\r\nreturn 0;\r\n}
