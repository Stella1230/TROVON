resource_size_t pcibios_align_resource(void *data, const struct resource *res,\r\nresource_size_t size, resource_size_t align)\r\n{\r\nresource_size_t start = res->start;\r\nif ((res->flags & IORESOURCE_IO) && (start & 0x300))\r\nstart = (start + 0x3ff) & ~0x3ff;\r\nstart = (start + align - 1) & ~(align - 1);\r\nreturn start;\r\n}\r\nint pcibios_enable_device(struct pci_dev *dev, int mask)\r\n{\r\nstruct resource *r;\r\nu16 cmd, newcmd;\r\nint idx;\r\npci_read_config_word(dev, PCI_COMMAND, &cmd);\r\nnewcmd = cmd;\r\nfor (idx = 0; idx < 6; idx++) {\r\nif (!(mask & (1 << idx)))\r\ncontinue;\r\nr = dev->resource + idx;\r\nif (!r->start && r->end) {\r\npr_err(KERN_ERR "PCI: Device %s not available because of resource collisions\n",\r\npci_name(dev));\r\nreturn -EINVAL;\r\n}\r\nif (r->flags & IORESOURCE_IO)\r\nnewcmd |= PCI_COMMAND_IO;\r\nif (r->flags & IORESOURCE_MEM)\r\nnewcmd |= PCI_COMMAND_MEMORY;\r\n}\r\nif ((dev->class >> 16) == PCI_BASE_CLASS_BRIDGE)\r\nnewcmd |= PCI_COMMAND_IO | PCI_COMMAND_MEMORY;\r\nif (newcmd != cmd) {\r\npr_info("PCI: enabling device %s (0x%04x -> 0x%04x)\n",\r\npci_name(dev), cmd, newcmd);\r\npci_write_config_word(dev, PCI_COMMAND, newcmd);\r\n}\r\nreturn 0;\r\n}\r\nvoid pcibios_fixup_bus(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\npci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 8);\r\npci_write_config_byte(dev, PCI_LATENCY_TIMER, 32);\r\n}\r\n}\r\nchar *pcibios_setup(char *str)\r\n{\r\nreturn str;\r\n}
