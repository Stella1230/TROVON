static int report__config(const char *var, const char *value, void *cb)\r\n{\r\nif (!strcmp(var, "report.group")) {\r\nsymbol_conf.event_group = perf_config_bool(var, value);\r\nreturn 0;\r\n}\r\nif (!strcmp(var, "report.percent-limit")) {\r\nstruct report *rep = cb;\r\nrep->min_percent = strtof(value, NULL);\r\nreturn 0;\r\n}\r\nif (!strcmp(var, "report.children")) {\r\nsymbol_conf.cumulate_callchain = perf_config_bool(var, value);\r\nreturn 0;\r\n}\r\nreturn perf_default_config(var, value, cb);\r\n}\r\nstatic void report__inc_stats(struct report *rep, struct hist_entry *he)\r\n{\r\nif (he->stat.nr_events == 1)\r\nrep->nr_entries++;\r\n}\r\nstatic int hist_iter__report_callback(struct hist_entry_iter *iter,\r\nstruct addr_location *al, bool single,\r\nvoid *arg)\r\n{\r\nint err = 0;\r\nstruct report *rep = arg;\r\nstruct hist_entry *he = iter->he;\r\nstruct perf_evsel *evsel = iter->evsel;\r\nstruct mem_info *mi;\r\nstruct branch_info *bi;\r\nreport__inc_stats(rep, he);\r\nif (!ui__has_annotation())\r\nreturn 0;\r\nif (sort__mode == SORT_MODE__BRANCH) {\r\nbi = he->branch_info;\r\nerr = addr_map_symbol__inc_samples(&bi->from, evsel->idx);\r\nif (err)\r\ngoto out;\r\nerr = addr_map_symbol__inc_samples(&bi->to, evsel->idx);\r\n} else if (rep->mem_mode) {\r\nmi = he->mem_info;\r\nerr = addr_map_symbol__inc_samples(&mi->daddr, evsel->idx);\r\nif (err)\r\ngoto out;\r\nerr = hist_entry__inc_addr_samples(he, evsel->idx, al->addr);\r\n} else if (symbol_conf.cumulate_callchain) {\r\nif (single)\r\nerr = hist_entry__inc_addr_samples(he, evsel->idx,\r\nal->addr);\r\n} else {\r\nerr = hist_entry__inc_addr_samples(he, evsel->idx, al->addr);\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic int process_sample_event(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine)\r\n{\r\nstruct report *rep = container_of(tool, struct report, tool);\r\nstruct addr_location al;\r\nstruct hist_entry_iter iter = {\r\n.hide_unresolved = rep->hide_unresolved,\r\n.add_entry_cb = hist_iter__report_callback,\r\n};\r\nint ret;\r\nif (perf_event__preprocess_sample(event, machine, &al, sample) < 0) {\r\npr_debug("problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\nreturn -1;\r\n}\r\nif (rep->hide_unresolved && al.sym == NULL)\r\nreturn 0;\r\nif (rep->cpu_list && !test_bit(sample->cpu, rep->cpu_bitmap))\r\nreturn 0;\r\nif (sort__mode == SORT_MODE__BRANCH)\r\niter.ops = &hist_iter_branch;\r\nelse if (rep->mem_mode)\r\niter.ops = &hist_iter_mem;\r\nelse if (symbol_conf.cumulate_callchain)\r\niter.ops = &hist_iter_cumulative;\r\nelse\r\niter.ops = &hist_iter_normal;\r\nif (al.map != NULL)\r\nal.map->dso->hit = 1;\r\nret = hist_entry_iter__add(&iter, &al, evsel, sample, rep->max_stack,\r\nrep);\r\nif (ret < 0)\r\npr_debug("problem adding hist entry, skipping event\n");\r\nreturn ret;\r\n}\r\nstatic int process_read_event(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample __maybe_unused,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine __maybe_unused)\r\n{\r\nstruct report *rep = container_of(tool, struct report, tool);\r\nif (rep->show_threads) {\r\nconst char *name = evsel ? perf_evsel__name(evsel) : "unknown";\r\nperf_read_values_add_value(&rep->show_threads_values,\r\nevent->read.pid, event->read.tid,\r\nevent->read.id,\r\nname,\r\nevent->read.value);\r\n}\r\ndump_printf(": %d %d %s %" PRIu64 "\n", event->read.pid, event->read.tid,\r\nevsel ? perf_evsel__name(evsel) : "FAIL",\r\nevent->read.value);\r\nreturn 0;\r\n}\r\nstatic int report__setup_sample_type(struct report *rep)\r\n{\r\nstruct perf_session *session = rep->session;\r\nu64 sample_type = perf_evlist__combined_sample_type(session->evlist);\r\nbool is_pipe = perf_data_file__is_pipe(session->file);\r\nif (!is_pipe && !(sample_type & PERF_SAMPLE_CALLCHAIN)) {\r\nif (sort__has_parent) {\r\nui__error("Selected --sort parent, but no "\r\n"callchain data. Did you call "\r\n"'perf record' without -g?\n");\r\nreturn -EINVAL;\r\n}\r\nif (symbol_conf.use_callchain) {\r\nui__error("Selected -g but no callchain data. Did "\r\n"you call 'perf record' without -g?\n");\r\nreturn -1;\r\n}\r\n} else if (!rep->dont_use_callchains &&\r\ncallchain_param.mode != CHAIN_NONE &&\r\n!symbol_conf.use_callchain) {\r\nsymbol_conf.use_callchain = true;\r\nif (callchain_register_param(&callchain_param) < 0) {\r\nui__error("Can't register callchain params.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (symbol_conf.cumulate_callchain) {\r\nif (!(sample_type & PERF_SAMPLE_CALLCHAIN)) {\r\nsymbol_conf.cumulate_callchain = false;\r\nperf_hpp__cancel_cumulate();\r\n}\r\n}\r\nif (sort__mode == SORT_MODE__BRANCH) {\r\nif (!is_pipe &&\r\n!(sample_type & PERF_SAMPLE_BRANCH_STACK)) {\r\nui__error("Selected -b but no branch data. "\r\n"Did you call perf record without -b?\n");\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void sig_handler(int sig __maybe_unused)\r\n{\r\nsession_done = 1;\r\n}\r\nstatic size_t hists__fprintf_nr_sample_events(struct hists *hists, struct report *rep,\r\nconst char *evname, FILE *fp)\r\n{\r\nsize_t ret;\r\nchar unit;\r\nunsigned long nr_samples = hists->stats.nr_events[PERF_RECORD_SAMPLE];\r\nu64 nr_events = hists->stats.total_period;\r\nstruct perf_evsel *evsel = hists_to_evsel(hists);\r\nchar buf[512];\r\nsize_t size = sizeof(buf);\r\nif (symbol_conf.filter_relative) {\r\nnr_samples = hists->stats.nr_non_filtered_samples;\r\nnr_events = hists->stats.total_non_filtered_period;\r\n}\r\nif (perf_evsel__is_group_event(evsel)) {\r\nstruct perf_evsel *pos;\r\nperf_evsel__group_desc(evsel, buf, size);\r\nevname = buf;\r\nfor_each_group_member(pos, evsel) {\r\nif (symbol_conf.filter_relative) {\r\nnr_samples += pos->hists.stats.nr_non_filtered_samples;\r\nnr_events += pos->hists.stats.total_non_filtered_period;\r\n} else {\r\nnr_samples += pos->hists.stats.nr_events[PERF_RECORD_SAMPLE];\r\nnr_events += pos->hists.stats.total_period;\r\n}\r\n}\r\n}\r\nnr_samples = convert_unit(nr_samples, &unit);\r\nret = fprintf(fp, "# Samples: %lu%c", nr_samples, unit);\r\nif (evname != NULL)\r\nret += fprintf(fp, " of event '%s'", evname);\r\nif (rep->mem_mode) {\r\nret += fprintf(fp, "\n# Total weight : %" PRIu64, nr_events);\r\nret += fprintf(fp, "\n# Sort order : %s", sort_order);\r\n} else\r\nret += fprintf(fp, "\n# Event count (approx.): %" PRIu64, nr_events);\r\nreturn ret + fprintf(fp, "\n#\n");\r\n}\r\nstatic int perf_evlist__tty_browse_hists(struct perf_evlist *evlist,\r\nstruct report *rep,\r\nconst char *help)\r\n{\r\nstruct perf_evsel *pos;\r\nevlist__for_each(evlist, pos) {\r\nstruct hists *hists = &pos->hists;\r\nconst char *evname = perf_evsel__name(pos);\r\nif (symbol_conf.event_group &&\r\n!perf_evsel__is_group_leader(pos))\r\ncontinue;\r\nhists__fprintf_nr_sample_events(hists, rep, evname, stdout);\r\nhists__fprintf(hists, true, 0, 0, rep->min_percent, stdout);\r\nfprintf(stdout, "\n\n");\r\n}\r\nif (sort_order == default_sort_order &&\r\nparent_pattern == default_parent_pattern) {\r\nfprintf(stdout, "#\n# (%s)\n#\n", help);\r\nif (rep->show_threads) {\r\nbool style = !strcmp(rep->pretty_printing_style, "raw");\r\nperf_read_values_display(stdout, &rep->show_threads_values,\r\nstyle);\r\nperf_read_values_destroy(&rep->show_threads_values);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void report__warn_kptr_restrict(const struct report *rep)\r\n{\r\nstruct map *kernel_map = rep->session->machines.host.vmlinux_maps[MAP__FUNCTION];\r\nstruct kmap *kernel_kmap = map__kmap(kernel_map);\r\nif (kernel_map == NULL ||\r\n(kernel_map->dso->hit &&\r\n(kernel_kmap->ref_reloc_sym == NULL ||\r\nkernel_kmap->ref_reloc_sym->addr == 0))) {\r\nconst char *desc =\r\n"As no suitable kallsyms nor vmlinux was found, kernel samples\n"\r\n"can't be resolved.";\r\nif (kernel_map) {\r\nconst struct dso *kdso = kernel_map->dso;\r\nif (!RB_EMPTY_ROOT(&kdso->symbols[MAP__FUNCTION])) {\r\ndesc = "If some relocation was applied (e.g. "\r\n"kexec) symbols may be misresolved.";\r\n}\r\n}\r\nui__warning(\r\n"Kernel address maps (/proc/{kallsyms,modules}) were restricted.\n\n"\r\n"Check /proc/sys/kernel/kptr_restrict before running 'perf record'.\n\n%s\n\n"\r\n"Samples in kernel modules can't be resolved as well.\n\n",\r\ndesc);\r\n}\r\n}\r\nstatic int report__gtk_browse_hists(struct report *rep, const char *help)\r\n{\r\nint (*hist_browser)(struct perf_evlist *evlist, const char *help,\r\nstruct hist_browser_timer *timer, float min_pcnt);\r\nhist_browser = dlsym(perf_gtk_handle, "perf_evlist__gtk_browse_hists");\r\nif (hist_browser == NULL) {\r\nui__error("GTK browser not found!\n");\r\nreturn -1;\r\n}\r\nreturn hist_browser(rep->session->evlist, help, NULL, rep->min_percent);\r\n}\r\nstatic int report__browse_hists(struct report *rep)\r\n{\r\nint ret;\r\nstruct perf_session *session = rep->session;\r\nstruct perf_evlist *evlist = session->evlist;\r\nconst char *help = "For a higher level overview, try: perf report --sort comm,dso";\r\nswitch (use_browser) {\r\ncase 1:\r\nret = perf_evlist__tui_browse_hists(evlist, help, NULL,\r\nrep->min_percent,\r\n&session->header.env);\r\nif (ret != K_SWITCH_INPUT_DATA)\r\nret = 0;\r\nbreak;\r\ncase 2:\r\nret = report__gtk_browse_hists(rep, help);\r\nbreak;\r\ndefault:\r\nret = perf_evlist__tty_browse_hists(evlist, rep, help);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void report__collapse_hists(struct report *rep)\r\n{\r\nstruct ui_progress prog;\r\nstruct perf_evsel *pos;\r\nui_progress__init(&prog, rep->nr_entries, "Merging related events...");\r\nevlist__for_each(rep->session->evlist, pos) {\r\nstruct hists *hists = &pos->hists;\r\nif (pos->idx == 0)\r\nhists->symbol_filter_str = rep->symbol_filter_str;\r\nhists__collapse_resort(hists, &prog);\r\nif (symbol_conf.event_group &&\r\n!perf_evsel__is_group_leader(pos)) {\r\nstruct hists *leader_hists = &pos->leader->hists;\r\nhists__match(leader_hists, hists);\r\nhists__link(leader_hists, hists);\r\n}\r\n}\r\nui_progress__finish();\r\n}\r\nstatic int __cmd_report(struct report *rep)\r\n{\r\nint ret;\r\nstruct perf_session *session = rep->session;\r\nstruct perf_evsel *pos;\r\nstruct perf_data_file *file = session->file;\r\nsignal(SIGINT, sig_handler);\r\nif (rep->cpu_list) {\r\nret = perf_session__cpu_bitmap(session, rep->cpu_list,\r\nrep->cpu_bitmap);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (rep->show_threads)\r\nperf_read_values_init(&rep->show_threads_values);\r\nret = report__setup_sample_type(rep);\r\nif (ret)\r\nreturn ret;\r\nret = perf_session__process_events(session, &rep->tool);\r\nif (ret)\r\nreturn ret;\r\nreport__warn_kptr_restrict(rep);\r\nif (use_browser == 0) {\r\nif (verbose > 3)\r\nperf_session__fprintf(session, stdout);\r\nif (verbose > 2)\r\nperf_session__fprintf_dsos(session, stdout);\r\nif (dump_trace) {\r\nperf_session__fprintf_nr_events(session, stdout);\r\nreturn 0;\r\n}\r\n}\r\nreport__collapse_hists(rep);\r\nif (session_done())\r\nreturn 0;\r\nif (rep->nr_entries == 0) {\r\nui__error("The %s file has no samples!\n", file->path);\r\nreturn 0;\r\n}\r\nevlist__for_each(session->evlist, pos)\r\nhists__output_resort(&pos->hists);\r\nreturn report__browse_hists(rep);\r\n}\r\nstatic int\r\nreport_parse_callchain_opt(const struct option *opt, const char *arg, int unset)\r\n{\r\nstruct report *rep = (struct report *)opt->value;\r\nif (unset) {\r\nrep->dont_use_callchains = true;\r\nreturn 0;\r\n}\r\nreturn parse_callchain_report_opt(arg);\r\n}\r\nint\r\nreport_parse_ignore_callees_opt(const struct option *opt __maybe_unused,\r\nconst char *arg, int unset __maybe_unused)\r\n{\r\nif (arg) {\r\nint err = regcomp(&ignore_callees_regex, arg, REG_EXTENDED);\r\nif (err) {\r\nchar buf[BUFSIZ];\r\nregerror(err, &ignore_callees_regex, buf, sizeof(buf));\r\npr_err("Invalid --ignore-callees regex: %s\n%s", arg, buf);\r\nreturn -1;\r\n}\r\nhave_ignore_callees = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nparse_branch_mode(const struct option *opt __maybe_unused,\r\nconst char *str __maybe_unused, int unset)\r\n{\r\nint *branch_mode = opt->value;\r\n*branch_mode = !unset;\r\nreturn 0;\r\n}\r\nstatic int\r\nparse_percent_limit(const struct option *opt, const char *str,\r\nint unset __maybe_unused)\r\n{\r\nstruct report *rep = opt->value;\r\nrep->min_percent = strtof(str, NULL);\r\nreturn 0;\r\n}\r\nint cmd_report(int argc, const char **argv, const char *prefix __maybe_unused)\r\n{\r\nstruct perf_session *session;\r\nstruct stat st;\r\nbool has_br_stack = false;\r\nint branch_mode = -1;\r\nint ret = -1;\r\nchar callchain_default_opt[] = "fractal,0.5,callee";\r\nconst char * const report_usage[] = {\r\n"perf report [<options>]",\r\nNULL\r\n};\r\nstruct report report = {\r\n.tool = {\r\n.sample = process_sample_event,\r\n.mmap = perf_event__process_mmap,\r\n.mmap2 = perf_event__process_mmap2,\r\n.comm = perf_event__process_comm,\r\n.exit = perf_event__process_exit,\r\n.fork = perf_event__process_fork,\r\n.lost = perf_event__process_lost,\r\n.read = process_read_event,\r\n.attr = perf_event__process_attr,\r\n.tracing_data = perf_event__process_tracing_data,\r\n.build_id = perf_event__process_build_id,\r\n.ordered_samples = true,\r\n.ordering_requires_timestamps = true,\r\n},\r\n.max_stack = PERF_MAX_STACK_DEPTH,\r\n.pretty_printing_style = "normal",\r\n};\r\nconst struct option options[] = {\r\nOPT_STRING('i', "input", &input_name, "file",\r\n"input file name"),\r\nOPT_INCR('v', "verbose", &verbose,\r\n"be more verbose (show symbol address, etc)"),\r\nOPT_BOOLEAN('D', "dump-raw-trace", &dump_trace,\r\n"dump raw trace in ASCII"),\r\nOPT_STRING('k', "vmlinux", &symbol_conf.vmlinux_name,\r\n"file", "vmlinux pathname"),\r\nOPT_STRING(0, "kallsyms", &symbol_conf.kallsyms_name,\r\n"file", "kallsyms pathname"),\r\nOPT_BOOLEAN('f', "force", &report.force, "don't complain, do it"),\r\nOPT_BOOLEAN('m', "modules", &symbol_conf.use_modules,\r\n"load module symbols - WARNING: use only with -k and LIVE kernel"),\r\nOPT_BOOLEAN('n', "show-nr-samples", &symbol_conf.show_nr_samples,\r\n"Show a column with the number of samples"),\r\nOPT_BOOLEAN('T', "threads", &report.show_threads,\r\n"Show per-thread event counters"),\r\nOPT_STRING(0, "pretty", &report.pretty_printing_style, "key",\r\n"pretty printing style key: normal raw"),\r\nOPT_BOOLEAN(0, "tui", &report.use_tui, "Use the TUI interface"),\r\nOPT_BOOLEAN(0, "gtk", &report.use_gtk, "Use the GTK2 interface"),\r\nOPT_BOOLEAN(0, "stdio", &report.use_stdio,\r\n"Use the stdio interface"),\r\nOPT_BOOLEAN(0, "header", &report.header, "Show data header."),\r\nOPT_BOOLEAN(0, "header-only", &report.header_only,\r\n"Show only data header."),\r\nOPT_STRING('s', "sort", &sort_order, "key[,key2...]",\r\n"sort by key(s): pid, comm, dso, symbol, parent, cpu, srcline, ..."\r\n" Please refer the man page for the complete list."),\r\nOPT_STRING('F', "fields", &field_order, "key[,keys...]",\r\n"output field(s): overhead, period, sample plus all of sort keys"),\r\nOPT_BOOLEAN(0, "showcpuutilization", &symbol_conf.show_cpu_utilization,\r\n"Show sample percentage for different cpu modes"),\r\nOPT_STRING('p', "parent", &parent_pattern, "regex",\r\n"regex filter to identify parent, see: '--sort parent'"),\r\nOPT_BOOLEAN('x', "exclude-other", &symbol_conf.exclude_other,\r\n"Only display entries with parent-match"),\r\nOPT_CALLBACK_DEFAULT('g', "call-graph", &report, "output_type,min_percent[,print_limit],call_order",\r\n"Display callchains using output_type (graph, flat, fractal, or none) , min percent threshold, optional print limit, callchain order, key (function or address). "\r\n"Default: fractal,0.5,callee,function", &report_parse_callchain_opt, callchain_default_opt),\r\nOPT_BOOLEAN(0, "children", &symbol_conf.cumulate_callchain,\r\n"Accumulate callchains of children and show total overhead as well"),\r\nOPT_INTEGER(0, "max-stack", &report.max_stack,\r\n"Set the maximum stack depth when parsing the callchain, "\r\n"anything beyond the specified depth will be ignored. "\r\n"Default: " __stringify(PERF_MAX_STACK_DEPTH)),\r\nOPT_BOOLEAN('G', "inverted", &report.inverted_callchain,\r\n"alias for inverted call graph"),\r\nOPT_CALLBACK(0, "ignore-callees", NULL, "regex",\r\n"ignore callees of these functions in call graphs",\r\nreport_parse_ignore_callees_opt),\r\nOPT_STRING('d', "dsos", &symbol_conf.dso_list_str, "dso[,dso...]",\r\n"only consider symbols in these dsos"),\r\nOPT_STRING('c', "comms", &symbol_conf.comm_list_str, "comm[,comm...]",\r\n"only consider symbols in these comms"),\r\nOPT_STRING('S', "symbols", &symbol_conf.sym_list_str, "symbol[,symbol...]",\r\n"only consider these symbols"),\r\nOPT_STRING(0, "symbol-filter", &report.symbol_filter_str, "filter",\r\n"only show symbols that (partially) match with this filter"),\r\nOPT_STRING('w', "column-widths", &symbol_conf.col_width_list_str,\r\n"width[,width...]",\r\n"don't try to adjust column width, use these fixed values"),\r\nOPT_STRING('t', "field-separator", &symbol_conf.field_sep, "separator",\r\n"separator for columns, no spaces will be added between "\r\n"columns '.' is reserved."),\r\nOPT_BOOLEAN('U', "hide-unresolved", &report.hide_unresolved,\r\n"Only display entries resolved to a symbol"),\r\nOPT_STRING(0, "symfs", &symbol_conf.symfs, "directory",\r\n"Look for files with symbols relative to this directory"),\r\nOPT_STRING('C', "cpu", &report.cpu_list, "cpu",\r\n"list of cpus to profile"),\r\nOPT_BOOLEAN('I', "show-info", &report.show_full_info,\r\n"Display extended information about perf.data file"),\r\nOPT_BOOLEAN(0, "source", &symbol_conf.annotate_src,\r\n"Interleave source code with assembly code (default)"),\r\nOPT_BOOLEAN(0, "asm-raw", &symbol_conf.annotate_asm_raw,\r\n"Display raw encoding of assembly instructions (default)"),\r\nOPT_STRING('M', "disassembler-style", &disassembler_style, "disassembler style",\r\n"Specify disassembler style (e.g. -M intel for intel syntax)"),\r\nOPT_BOOLEAN(0, "show-total-period", &symbol_conf.show_total_period,\r\n"Show a column with the sum of periods"),\r\nOPT_BOOLEAN(0, "group", &symbol_conf.event_group,\r\n"Show event group information together"),\r\nOPT_CALLBACK_NOOPT('b', "branch-stack", &branch_mode, "",\r\n"use branch records for histogram filling", parse_branch_mode),\r\nOPT_STRING(0, "objdump", &objdump_path, "path",\r\n"objdump binary to use for disassembly and annotations"),\r\nOPT_BOOLEAN(0, "demangle", &symbol_conf.demangle,\r\n"Disable symbol demangling"),\r\nOPT_BOOLEAN(0, "mem-mode", &report.mem_mode, "mem access profile"),\r\nOPT_CALLBACK(0, "percent-limit", &report, "percent",\r\n"Don't show entries under that percent", parse_percent_limit),\r\nOPT_CALLBACK(0, "percentage", NULL, "relative|absolute",\r\n"how to display percentage of filtered entries", parse_filter_percentage),\r\nOPT_END()\r\n};\r\nstruct perf_data_file file = {\r\n.mode = PERF_DATA_MODE_READ,\r\n};\r\nperf_config(report__config, &report);\r\nargc = parse_options(argc, argv, options, report_usage, 0);\r\nif (report.use_stdio)\r\nuse_browser = 0;\r\nelse if (report.use_tui)\r\nuse_browser = 1;\r\nelse if (report.use_gtk)\r\nuse_browser = 2;\r\nif (report.inverted_callchain)\r\ncallchain_param.order = ORDER_CALLER;\r\nif (!input_name || !strlen(input_name)) {\r\nif (!fstat(STDIN_FILENO, &st) && S_ISFIFO(st.st_mode))\r\ninput_name = "-";\r\nelse\r\ninput_name = "perf.data";\r\n}\r\nfile.path = input_name;\r\nfile.force = report.force;\r\nrepeat:\r\nsession = perf_session__new(&file, false, &report.tool);\r\nif (session == NULL)\r\nreturn -ENOMEM;\r\nreport.session = session;\r\nhas_br_stack = perf_header__has_feat(&session->header,\r\nHEADER_BRANCH_STACK);\r\nif (branch_mode == -1 && has_br_stack) {\r\nsort__mode = SORT_MODE__BRANCH;\r\nsymbol_conf.cumulate_callchain = false;\r\n}\r\nif (report.mem_mode) {\r\nif (sort__mode == SORT_MODE__BRANCH) {\r\npr_err("branch and mem mode incompatible\n");\r\ngoto error;\r\n}\r\nsort__mode = SORT_MODE__MEMORY;\r\nsymbol_conf.cumulate_callchain = false;\r\n}\r\nif (setup_sorting() < 0) {\r\nif (sort_order)\r\nparse_options_usage(report_usage, options, "s", 1);\r\nif (field_order)\r\nparse_options_usage(sort_order ? NULL : report_usage,\r\noptions, "F", 1);\r\ngoto error;\r\n}\r\nif (report.header || report.header_only)\r\nuse_browser = 0;\r\nif (strcmp(input_name, "-") != 0)\r\nsetup_browser(true);\r\nelse\r\nuse_browser = 0;\r\nif (report.header || report.header_only) {\r\nperf_session__fprintf_info(session, stdout,\r\nreport.show_full_info);\r\nif (report.header_only)\r\nreturn 0;\r\n} else if (use_browser == 0) {\r\nfputs("# To display the perf.data header info, please use --header/--header-only options.\n#\n",\r\nstdout);\r\n}\r\nif (ui__has_annotation()) {\r\nsymbol_conf.priv_size = sizeof(struct annotation);\r\nmachines__set_symbol_filter(&session->machines,\r\nsymbol__annotate_init);\r\nif (verbose) {\r\nsymbol_conf.priv_size += sizeof(u32);\r\nsymbol_conf.sort_by_name = true;\r\n}\r\n}\r\nif (symbol__init() < 0)\r\ngoto error;\r\nif (argc) {\r\nif (argc > 1)\r\nusage_with_options(report_usage, options);\r\nreport.symbol_filter_str = argv[0];\r\n}\r\nsort__setup_elide(stdout);\r\nret = __cmd_report(&report);\r\nif (ret == K_SWITCH_INPUT_DATA) {\r\nperf_session__delete(session);\r\ngoto repeat;\r\n} else\r\nret = 0;\r\nerror:\r\nperf_session__delete(session);\r\nreturn ret;\r\n}
