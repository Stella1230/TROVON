static int __init opt_kgdb_con(char *str)\r\n{\r\nkgdb_use_con = 1;\r\nreturn 0;\r\n}\r\nstatic int __init opt_nokgdbroundup(char *str)\r\n{\r\nkgdb_do_roundup = 0;\r\nreturn 0;\r\n}\r\nint __weak kgdb_arch_set_breakpoint(struct kgdb_bkpt *bpt)\r\n{\r\nint err;\r\nerr = probe_kernel_read(bpt->saved_instr, (char *)bpt->bpt_addr,\r\nBREAK_INSTR_SIZE);\r\nif (err)\r\nreturn err;\r\nerr = probe_kernel_write((char *)bpt->bpt_addr,\r\narch_kgdb_ops.gdb_bpt_instr, BREAK_INSTR_SIZE);\r\nreturn err;\r\n}\r\nint __weak kgdb_arch_remove_breakpoint(struct kgdb_bkpt *bpt)\r\n{\r\nreturn probe_kernel_write((char *)bpt->bpt_addr,\r\n(char *)bpt->saved_instr, BREAK_INSTR_SIZE);\r\n}\r\nint __weak kgdb_validate_break_address(unsigned long addr)\r\n{\r\nstruct kgdb_bkpt tmp;\r\nint err;\r\ntmp.bpt_addr = addr;\r\nerr = kgdb_arch_set_breakpoint(&tmp);\r\nif (err)\r\nreturn err;\r\nerr = kgdb_arch_remove_breakpoint(&tmp);\r\nif (err)\r\nprintk(KERN_ERR "KGDB: Critical breakpoint error, kernel "\r\n"memory destroyed at: %lx", addr);\r\nreturn err;\r\n}\r\nunsigned long __weak kgdb_arch_pc(int exception, struct pt_regs *regs)\r\n{\r\nreturn instruction_pointer(regs);\r\n}\r\nint __weak kgdb_arch_init(void)\r\n{\r\nreturn 0;\r\n}\r\nint __weak kgdb_skipexception(int exception, struct pt_regs *regs)\r\n{\r\nreturn 0;\r\n}\r\nstatic void kgdb_flush_swbreak_addr(unsigned long addr)\r\n{\r\nif (!CACHE_FLUSH_IS_SAFE)\r\nreturn;\r\nif (current->mm) {\r\nint i;\r\nfor (i = 0; i < VMACACHE_SIZE; i++) {\r\nif (!current->vmacache[i])\r\ncontinue;\r\nflush_cache_range(current->vmacache[i],\r\naddr, addr + BREAK_INSTR_SIZE);\r\n}\r\n}\r\nflush_icache_range(addr, addr + BREAK_INSTR_SIZE);\r\n}\r\nint dbg_activate_sw_breakpoints(void)\r\n{\r\nint error;\r\nint ret = 0;\r\nint i;\r\nfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\r\nif (kgdb_break[i].state != BP_SET)\r\ncontinue;\r\nerror = kgdb_arch_set_breakpoint(&kgdb_break[i]);\r\nif (error) {\r\nret = error;\r\nprintk(KERN_INFO "KGDB: BP install failed: %lx",\r\nkgdb_break[i].bpt_addr);\r\ncontinue;\r\n}\r\nkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\r\nkgdb_break[i].state = BP_ACTIVE;\r\n}\r\nreturn ret;\r\n}\r\nint dbg_set_sw_break(unsigned long addr)\r\n{\r\nint err = kgdb_validate_break_address(addr);\r\nint breakno = -1;\r\nint i;\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\r\nif ((kgdb_break[i].state == BP_SET) &&\r\n(kgdb_break[i].bpt_addr == addr))\r\nreturn -EEXIST;\r\n}\r\nfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\r\nif (kgdb_break[i].state == BP_REMOVED &&\r\nkgdb_break[i].bpt_addr == addr) {\r\nbreakno = i;\r\nbreak;\r\n}\r\n}\r\nif (breakno == -1) {\r\nfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\r\nif (kgdb_break[i].state == BP_UNDEFINED) {\r\nbreakno = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (breakno == -1)\r\nreturn -E2BIG;\r\nkgdb_break[breakno].state = BP_SET;\r\nkgdb_break[breakno].type = BP_BREAKPOINT;\r\nkgdb_break[breakno].bpt_addr = addr;\r\nreturn 0;\r\n}\r\nint dbg_deactivate_sw_breakpoints(void)\r\n{\r\nint error;\r\nint ret = 0;\r\nint i;\r\nfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\r\nif (kgdb_break[i].state != BP_ACTIVE)\r\ncontinue;\r\nerror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\r\nif (error) {\r\nprintk(KERN_INFO "KGDB: BP remove failed: %lx\n",\r\nkgdb_break[i].bpt_addr);\r\nret = error;\r\n}\r\nkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\r\nkgdb_break[i].state = BP_SET;\r\n}\r\nreturn ret;\r\n}\r\nint dbg_remove_sw_break(unsigned long addr)\r\n{\r\nint i;\r\nfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\r\nif ((kgdb_break[i].state == BP_SET) &&\r\n(kgdb_break[i].bpt_addr == addr)) {\r\nkgdb_break[i].state = BP_REMOVED;\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nint kgdb_isremovedbreak(unsigned long addr)\r\n{\r\nint i;\r\nfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\r\nif ((kgdb_break[i].state == BP_REMOVED) &&\r\n(kgdb_break[i].bpt_addr == addr))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint dbg_remove_all_break(void)\r\n{\r\nint error;\r\nint i;\r\nfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\r\nif (kgdb_break[i].state != BP_ACTIVE)\r\ngoto setundefined;\r\nerror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\r\nif (error)\r\nprintk(KERN_ERR "KGDB: breakpoint remove failed: %lx\n",\r\nkgdb_break[i].bpt_addr);\r\nsetundefined:\r\nkgdb_break[i].state = BP_UNDEFINED;\r\n}\r\nif (arch_kgdb_ops.remove_all_hw_break)\r\narch_kgdb_ops.remove_all_hw_break();\r\nreturn 0;\r\n}\r\nstatic int kgdb_io_ready(int print_wait)\r\n{\r\nif (!dbg_io_ops)\r\nreturn 0;\r\nif (kgdb_connected)\r\nreturn 1;\r\nif (atomic_read(&kgdb_setting_breakpoint))\r\nreturn 1;\r\nif (print_wait) {\r\n#ifdef CONFIG_KGDB_KDB\r\nif (!dbg_kdb_mode)\r\nprintk(KERN_CRIT "KGDB: waiting... or $3#33 for KDB\n");\r\n#else\r\nprintk(KERN_CRIT "KGDB: Waiting for remote debugger\n");\r\n#endif\r\n}\r\nreturn 1;\r\n}\r\nstatic int kgdb_reenter_check(struct kgdb_state *ks)\r\n{\r\nunsigned long addr;\r\nif (atomic_read(&kgdb_active) != raw_smp_processor_id())\r\nreturn 0;\r\nexception_level++;\r\naddr = kgdb_arch_pc(ks->ex_vector, ks->linux_regs);\r\ndbg_deactivate_sw_breakpoints();\r\nif (dbg_remove_sw_break(addr) == 0) {\r\nexception_level = 0;\r\nkgdb_skipexception(ks->ex_vector, ks->linux_regs);\r\ndbg_activate_sw_breakpoints();\r\nprintk(KERN_CRIT "KGDB: re-enter error: breakpoint removed %lx\n",\r\naddr);\r\nWARN_ON_ONCE(1);\r\nreturn 1;\r\n}\r\ndbg_remove_all_break();\r\nkgdb_skipexception(ks->ex_vector, ks->linux_regs);\r\nif (exception_level > 1) {\r\ndump_stack();\r\npanic("Recursive entry to debugger");\r\n}\r\nprintk(KERN_CRIT "KGDB: re-enter exception: ALL breakpoints killed\n");\r\n#ifdef CONFIG_KGDB_KDB\r\nreturn 0;\r\n#endif\r\ndump_stack();\r\npanic("Recursive entry to debugger");\r\nreturn 1;\r\n}\r\nstatic void dbg_touch_watchdogs(void)\r\n{\r\ntouch_softlockup_watchdog_sync();\r\nclocksource_touch_watchdog();\r\nrcu_cpu_stall_reset();\r\n}\r\nstatic int kgdb_cpu_enter(struct kgdb_state *ks, struct pt_regs *regs,\r\nint exception_state)\r\n{\r\nunsigned long flags;\r\nint sstep_tries = 100;\r\nint error;\r\nint cpu;\r\nint trace_on = 0;\r\nint online_cpus = num_online_cpus();\r\nkgdb_info[ks->cpu].enter_kgdb++;\r\nkgdb_info[ks->cpu].exception_state |= exception_state;\r\nif (exception_state == DCPU_WANT_MASTER)\r\natomic_inc(&masters_in_kgdb);\r\nelse\r\natomic_inc(&slaves_in_kgdb);\r\nif (arch_kgdb_ops.disable_hw_break)\r\narch_kgdb_ops.disable_hw_break(regs);\r\nacquirelock:\r\nlocal_irq_save(flags);\r\ncpu = ks->cpu;\r\nkgdb_info[cpu].debuggerinfo = regs;\r\nkgdb_info[cpu].task = current;\r\nkgdb_info[cpu].ret_state = 0;\r\nkgdb_info[cpu].irq_depth = hardirq_count() >> HARDIRQ_SHIFT;\r\nsmp_mb();\r\nif (exception_level == 1) {\r\nif (raw_spin_trylock(&dbg_master_lock))\r\natomic_xchg(&kgdb_active, cpu);\r\ngoto cpu_master_loop;\r\n}\r\nwhile (1) {\r\ncpu_loop:\r\nif (kgdb_info[cpu].exception_state & DCPU_NEXT_MASTER) {\r\nkgdb_info[cpu].exception_state &= ~DCPU_NEXT_MASTER;\r\ngoto cpu_master_loop;\r\n} else if (kgdb_info[cpu].exception_state & DCPU_WANT_MASTER) {\r\nif (raw_spin_trylock(&dbg_master_lock)) {\r\natomic_xchg(&kgdb_active, cpu);\r\nbreak;\r\n}\r\n} else if (kgdb_info[cpu].exception_state & DCPU_IS_SLAVE) {\r\nif (!raw_spin_is_locked(&dbg_slave_lock))\r\ngoto return_normal;\r\n} else {\r\nreturn_normal:\r\nif (arch_kgdb_ops.correct_hw_break)\r\narch_kgdb_ops.correct_hw_break();\r\nif (trace_on)\r\ntracing_on();\r\nkgdb_info[cpu].exception_state &=\r\n~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\r\nkgdb_info[cpu].enter_kgdb--;\r\nsmp_mb__before_atomic();\r\natomic_dec(&slaves_in_kgdb);\r\ndbg_touch_watchdogs();\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\ncpu_relax();\r\n}\r\nif (atomic_read(&kgdb_cpu_doing_single_step) != -1 &&\r\n(kgdb_info[cpu].task &&\r\nkgdb_info[cpu].task->pid != kgdb_sstep_pid) && --sstep_tries) {\r\natomic_set(&kgdb_active, -1);\r\nraw_spin_unlock(&dbg_master_lock);\r\ndbg_touch_watchdogs();\r\nlocal_irq_restore(flags);\r\ngoto acquirelock;\r\n}\r\nif (!kgdb_io_ready(1)) {\r\nkgdb_info[cpu].ret_state = 1;\r\ngoto kgdb_restore;\r\n}\r\nif (kgdb_skipexception(ks->ex_vector, ks->linux_regs))\r\ngoto kgdb_restore;\r\nif (dbg_io_ops->pre_exception)\r\ndbg_io_ops->pre_exception();\r\nif (!kgdb_single_step)\r\nraw_spin_lock(&dbg_slave_lock);\r\n#ifdef CONFIG_SMP\r\nif (ks->send_ready)\r\natomic_set(ks->send_ready, 1);\r\nelse if ((!kgdb_single_step) && kgdb_do_roundup)\r\nkgdb_roundup_cpus(flags);\r\n#endif\r\nwhile (kgdb_do_roundup && (atomic_read(&masters_in_kgdb) +\r\natomic_read(&slaves_in_kgdb)) != online_cpus)\r\ncpu_relax();\r\ndbg_deactivate_sw_breakpoints();\r\nkgdb_single_step = 0;\r\nkgdb_contthread = current;\r\nexception_level = 0;\r\ntrace_on = tracing_is_on();\r\nif (trace_on)\r\ntracing_off();\r\nwhile (1) {\r\ncpu_master_loop:\r\nif (dbg_kdb_mode) {\r\nkgdb_connected = 1;\r\nerror = kdb_stub(ks);\r\nif (error == -1)\r\ncontinue;\r\nkgdb_connected = 0;\r\n} else {\r\nerror = gdb_serial_stub(ks);\r\n}\r\nif (error == DBG_PASS_EVENT) {\r\ndbg_kdb_mode = !dbg_kdb_mode;\r\n} else if (error == DBG_SWITCH_CPU_EVENT) {\r\nkgdb_info[dbg_switch_cpu].exception_state |=\r\nDCPU_NEXT_MASTER;\r\ngoto cpu_loop;\r\n} else {\r\nkgdb_info[cpu].ret_state = error;\r\nbreak;\r\n}\r\n}\r\nif (dbg_io_ops->post_exception)\r\ndbg_io_ops->post_exception();\r\nif (!kgdb_single_step) {\r\nraw_spin_unlock(&dbg_slave_lock);\r\nwhile (kgdb_do_roundup && atomic_read(&slaves_in_kgdb))\r\ncpu_relax();\r\n}\r\nkgdb_restore:\r\nif (atomic_read(&kgdb_cpu_doing_single_step) != -1) {\r\nint sstep_cpu = atomic_read(&kgdb_cpu_doing_single_step);\r\nif (kgdb_info[sstep_cpu].task)\r\nkgdb_sstep_pid = kgdb_info[sstep_cpu].task->pid;\r\nelse\r\nkgdb_sstep_pid = 0;\r\n}\r\nif (arch_kgdb_ops.correct_hw_break)\r\narch_kgdb_ops.correct_hw_break();\r\nif (trace_on)\r\ntracing_on();\r\nkgdb_info[cpu].exception_state &=\r\n~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\r\nkgdb_info[cpu].enter_kgdb--;\r\nsmp_mb__before_atomic();\r\natomic_dec(&masters_in_kgdb);\r\natomic_set(&kgdb_active, -1);\r\nraw_spin_unlock(&dbg_master_lock);\r\ndbg_touch_watchdogs();\r\nlocal_irq_restore(flags);\r\nreturn kgdb_info[cpu].ret_state;\r\n}\r\nint\r\nkgdb_handle_exception(int evector, int signo, int ecode, struct pt_regs *regs)\r\n{\r\nstruct kgdb_state kgdb_var;\r\nstruct kgdb_state *ks = &kgdb_var;\r\nint ret = 0;\r\nif (arch_kgdb_ops.enable_nmi)\r\narch_kgdb_ops.enable_nmi(0);\r\nmemset(ks, 0, sizeof(struct kgdb_state));\r\nks->cpu = raw_smp_processor_id();\r\nks->ex_vector = evector;\r\nks->signo = signo;\r\nks->err_code = ecode;\r\nks->linux_regs = regs;\r\nif (kgdb_reenter_check(ks))\r\ngoto out;\r\nif (kgdb_info[ks->cpu].enter_kgdb != 0)\r\ngoto out;\r\nret = kgdb_cpu_enter(ks, regs, DCPU_WANT_MASTER);\r\nout:\r\nif (arch_kgdb_ops.enable_nmi)\r\narch_kgdb_ops.enable_nmi(1);\r\nreturn ret;\r\n}\r\nstatic int module_event(struct notifier_block *self, unsigned long val,\r\nvoid *data)\r\n{\r\nreturn 0;\r\n}\r\nint kgdb_nmicallback(int cpu, void *regs)\r\n{\r\n#ifdef CONFIG_SMP\r\nstruct kgdb_state kgdb_var;\r\nstruct kgdb_state *ks = &kgdb_var;\r\nmemset(ks, 0, sizeof(struct kgdb_state));\r\nks->cpu = cpu;\r\nks->linux_regs = regs;\r\nif (kgdb_info[ks->cpu].enter_kgdb == 0 &&\r\nraw_spin_is_locked(&dbg_master_lock)) {\r\nkgdb_cpu_enter(ks, regs, DCPU_IS_SLAVE);\r\nreturn 0;\r\n}\r\n#endif\r\nreturn 1;\r\n}\r\nint kgdb_nmicallin(int cpu, int trapnr, void *regs, int err_code,\r\natomic_t *send_ready)\r\n{\r\n#ifdef CONFIG_SMP\r\nif (!kgdb_io_ready(0) || !send_ready)\r\nreturn 1;\r\nif (kgdb_info[cpu].enter_kgdb == 0) {\r\nstruct kgdb_state kgdb_var;\r\nstruct kgdb_state *ks = &kgdb_var;\r\nmemset(ks, 0, sizeof(struct kgdb_state));\r\nks->cpu = cpu;\r\nks->ex_vector = trapnr;\r\nks->signo = SIGTRAP;\r\nks->err_code = err_code;\r\nks->linux_regs = regs;\r\nks->send_ready = send_ready;\r\nkgdb_cpu_enter(ks, regs, DCPU_WANT_MASTER);\r\nreturn 0;\r\n}\r\n#endif\r\nreturn 1;\r\n}\r\nstatic void kgdb_console_write(struct console *co, const char *s,\r\nunsigned count)\r\n{\r\nunsigned long flags;\r\nif (!kgdb_connected || atomic_read(&kgdb_active) != -1 || dbg_kdb_mode)\r\nreturn;\r\nlocal_irq_save(flags);\r\ngdbstub_msg_write(s, count);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void sysrq_handle_dbg(int key)\r\n{\r\nif (!dbg_io_ops) {\r\nprintk(KERN_CRIT "ERROR: No KGDB I/O module available\n");\r\nreturn;\r\n}\r\nif (!kgdb_connected) {\r\n#ifdef CONFIG_KGDB_KDB\r\nif (!dbg_kdb_mode)\r\nprintk(KERN_CRIT "KGDB or $3#33 for KDB\n");\r\n#else\r\nprintk(KERN_CRIT "Entering KGDB\n");\r\n#endif\r\n}\r\nkgdb_breakpoint();\r\n}\r\nstatic int kgdb_panic_event(struct notifier_block *self,\r\nunsigned long val,\r\nvoid *data)\r\n{\r\nif (dbg_kdb_mode)\r\nkdb_printf("PANIC: %s\n", (char *)data);\r\nkgdb_breakpoint();\r\nreturn NOTIFY_DONE;\r\n}\r\nvoid __weak kgdb_arch_late(void)\r\n{\r\n}\r\nvoid __init dbg_late_init(void)\r\n{\r\ndbg_is_early = false;\r\nif (kgdb_io_module_registered)\r\nkgdb_arch_late();\r\nkdb_init(KDB_INIT_FULL);\r\n}\r\nstatic int\r\ndbg_notify_reboot(struct notifier_block *this, unsigned long code, void *x)\r\n{\r\nswitch (kgdbreboot) {\r\ncase 1:\r\nkgdb_breakpoint();\r\ncase -1:\r\ngoto done;\r\n}\r\nif (!dbg_kdb_mode)\r\ngdbstub_exit(code);\r\ndone:\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void kgdb_register_callbacks(void)\r\n{\r\nif (!kgdb_io_module_registered) {\r\nkgdb_io_module_registered = 1;\r\nkgdb_arch_init();\r\nif (!dbg_is_early)\r\nkgdb_arch_late();\r\nregister_module_notifier(&dbg_module_load_nb);\r\nregister_reboot_notifier(&dbg_reboot_notifier);\r\natomic_notifier_chain_register(&panic_notifier_list,\r\n&kgdb_panic_event_nb);\r\n#ifdef CONFIG_MAGIC_SYSRQ\r\nregister_sysrq_key('g', &sysrq_dbg_op);\r\n#endif\r\nif (kgdb_use_con && !kgdb_con_registered) {\r\nregister_console(&kgdbcons);\r\nkgdb_con_registered = 1;\r\n}\r\n}\r\n}\r\nstatic void kgdb_unregister_callbacks(void)\r\n{\r\nif (kgdb_io_module_registered) {\r\nkgdb_io_module_registered = 0;\r\nunregister_reboot_notifier(&dbg_reboot_notifier);\r\nunregister_module_notifier(&dbg_module_load_nb);\r\natomic_notifier_chain_unregister(&panic_notifier_list,\r\n&kgdb_panic_event_nb);\r\nkgdb_arch_exit();\r\n#ifdef CONFIG_MAGIC_SYSRQ\r\nunregister_sysrq_key('g', &sysrq_dbg_op);\r\n#endif\r\nif (kgdb_con_registered) {\r\nunregister_console(&kgdbcons);\r\nkgdb_con_registered = 0;\r\n}\r\n}\r\n}\r\nstatic void kgdb_tasklet_bpt(unsigned long ing)\r\n{\r\nkgdb_breakpoint();\r\natomic_set(&kgdb_break_tasklet_var, 0);\r\n}\r\nvoid kgdb_schedule_breakpoint(void)\r\n{\r\nif (atomic_read(&kgdb_break_tasklet_var) ||\r\natomic_read(&kgdb_active) != -1 ||\r\natomic_read(&kgdb_setting_breakpoint))\r\nreturn;\r\natomic_inc(&kgdb_break_tasklet_var);\r\ntasklet_schedule(&kgdb_tasklet_breakpoint);\r\n}\r\nstatic void kgdb_initial_breakpoint(void)\r\n{\r\nkgdb_break_asap = 0;\r\nprintk(KERN_CRIT "kgdb: Waiting for connection from remote gdb...\n");\r\nkgdb_breakpoint();\r\n}\r\nint kgdb_register_io_module(struct kgdb_io *new_dbg_io_ops)\r\n{\r\nint err;\r\nspin_lock(&kgdb_registration_lock);\r\nif (dbg_io_ops) {\r\nspin_unlock(&kgdb_registration_lock);\r\nprintk(KERN_ERR "kgdb: Another I/O driver is already "\r\n"registered with KGDB.\n");\r\nreturn -EBUSY;\r\n}\r\nif (new_dbg_io_ops->init) {\r\nerr = new_dbg_io_ops->init();\r\nif (err) {\r\nspin_unlock(&kgdb_registration_lock);\r\nreturn err;\r\n}\r\n}\r\ndbg_io_ops = new_dbg_io_ops;\r\nspin_unlock(&kgdb_registration_lock);\r\nprintk(KERN_INFO "kgdb: Registered I/O driver %s.\n",\r\nnew_dbg_io_ops->name);\r\nkgdb_register_callbacks();\r\nif (kgdb_break_asap)\r\nkgdb_initial_breakpoint();\r\nreturn 0;\r\n}\r\nvoid kgdb_unregister_io_module(struct kgdb_io *old_dbg_io_ops)\r\n{\r\nBUG_ON(kgdb_connected);\r\nkgdb_unregister_callbacks();\r\nspin_lock(&kgdb_registration_lock);\r\nWARN_ON_ONCE(dbg_io_ops != old_dbg_io_ops);\r\ndbg_io_ops = NULL;\r\nspin_unlock(&kgdb_registration_lock);\r\nprintk(KERN_INFO\r\n"kgdb: Unregistered I/O driver %s, debugger disabled.\n",\r\nold_dbg_io_ops->name);\r\n}\r\nint dbg_io_get_char(void)\r\n{\r\nint ret = dbg_io_ops->read_char();\r\nif (ret == NO_POLL_CHAR)\r\nreturn -1;\r\nif (!dbg_kdb_mode)\r\nreturn ret;\r\nif (ret == 127)\r\nreturn 8;\r\nreturn ret;\r\n}\r\nnoinline void kgdb_breakpoint(void)\r\n{\r\natomic_inc(&kgdb_setting_breakpoint);\r\nwmb();\r\narch_kgdb_breakpoint();\r\nwmb();\r\natomic_dec(&kgdb_setting_breakpoint);\r\n}\r\nstatic int __init opt_kgdb_wait(char *str)\r\n{\r\nkgdb_break_asap = 1;\r\nkdb_init(KDB_INIT_EARLY);\r\nif (kgdb_io_module_registered)\r\nkgdb_initial_breakpoint();\r\nreturn 0;\r\n}
