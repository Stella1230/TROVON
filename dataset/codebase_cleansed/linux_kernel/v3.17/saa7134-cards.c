static void board_flyvideo(struct saa7134_dev *dev)\r\n{\r\nprintk("%s: there are different flyvideo cards with different tuners\n"\r\n"%s: out there, you might have to use the tuner=<nr> insmod\n"\r\n"%s: option to override the default value.\n",\r\ndev->name, dev->name, dev->name);\r\n}\r\nstatic int saa7134_xc2028_callback(struct saa7134_dev *dev,\r\nint command, int arg)\r\n{\r\nswitch (command) {\r\ncase XC2028_TUNER_RESET:\r\nsaa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, 0x00008000, 0x00000000);\r\nsaa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, 0x00008000, 0x00008000);\r\nswitch (dev->board) {\r\ncase SAA7134_BOARD_AVERMEDIA_CARDBUS_506:\r\ncase SAA7134_BOARD_AVERMEDIA_M103:\r\nsaa7134_set_gpio(dev, 23, 0);\r\nmsleep(10);\r\nsaa7134_set_gpio(dev, 23, 1);\r\nbreak;\r\ncase SAA7134_BOARD_AVERMEDIA_A16D:\r\nsaa7134_set_gpio(dev, 21, 0);\r\nmsleep(10);\r\nsaa7134_set_gpio(dev, 21, 1);\r\nbreak;\r\ncase SAA7134_BOARD_AVERMEDIA_A700_HYBRID:\r\nsaa7134_set_gpio(dev, 18, 0);\r\nmsleep(10);\r\nsaa7134_set_gpio(dev, 18, 1);\r\nbreak;\r\ncase SAA7134_BOARD_VIDEOMATE_T750:\r\nsaa7134_set_gpio(dev, 20, 0);\r\nmsleep(10);\r\nsaa7134_set_gpio(dev, 20, 1);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int saa7134_xc5000_callback(struct saa7134_dev *dev,\r\nint command, int arg)\r\n{\r\nswitch (dev->board) {\r\ncase SAA7134_BOARD_BEHOLD_X7:\r\ncase SAA7134_BOARD_BEHOLD_H7:\r\ncase SAA7134_BOARD_BEHOLD_A7:\r\nif (command == XC5000_TUNER_RESET) {\r\nsaa_writeb(SAA7134_SPECIAL_MODE, 0x00);\r\nmsleep(10);\r\nsaa_writeb(SAA7134_SPECIAL_MODE, 0x01);\r\nmsleep(10);\r\n}\r\nbreak;\r\ndefault:\r\nsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, 0x06e20000, 0x06e20000);\r\nsaa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, 0x06a20000, 0x06a20000);\r\nsaa_andorl(SAA7133_ANALOG_IO_SELECT >> 2, 0x02, 0x02);\r\nsaa_andorl(SAA7134_ANALOG_IN_CTRL1 >> 2, 0x81, 0x81);\r\nsaa_andorl(SAA7134_AUDIO_CLOCK0 >> 2, 0x03187de7, 0x03187de7);\r\nsaa_andorl(SAA7134_AUDIO_PLL_CTRL >> 2, 0x03, 0x03);\r\nsaa_andorl(SAA7134_AUDIO_CLOCKS_PER_FIELD0 >> 2,\r\n0x0001e000, 0x0001e000);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa7134_tda8290_827x_callback(struct saa7134_dev *dev,\r\nint command, int arg)\r\n{\r\nu8 sync_control;\r\nswitch (command) {\r\ncase 0:\r\nsaa7134_set_gpio(dev, 22, arg) ;\r\nbreak;\r\ncase 1:\r\nsaa_andorb(SAA7134_VIDEO_PORT_CTRL3, 0x80, 0x80);\r\nsaa_andorb(SAA7134_VIDEO_PORT_CTRL6, 0x0f, 0x03);\r\nif (arg == 1)\r\nsync_control = 11;\r\nelse\r\nsync_control = 17;\r\nsaa_writeb(SAA7134_VGATE_START, sync_control);\r\nsaa_writeb(SAA7134_VGATE_STOP, sync_control + 1);\r\nsaa_andorb(SAA7134_MISC_VGATE_MSB, 0x03, 0x00);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int saa7134_tda18271_hvr11x0_toggle_agc(struct saa7134_dev *dev,\r\nenum tda18271_mode mode)\r\n{\r\nswitch (mode) {\r\ncase TDA18271_ANALOG:\r\nsaa7134_set_gpio(dev, 26, 0);\r\nbreak;\r\ncase TDA18271_DIGITAL:\r\nsaa7134_set_gpio(dev, 26, 1);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int saa7134_kworld_sbtvd_toggle_agc(struct saa7134_dev *dev,\r\nenum tda18271_mode mode)\r\n{\r\nswitch (mode) {\r\ncase TDA18271_ANALOG:\r\nsaa_writel(SAA7134_GPIO_GPMODE0 >> 2, 0x4000);\r\nsaa_writel(SAA7134_GPIO_GPSTATUS0 >> 2, 0x4000);\r\nmsleep(20);\r\nbreak;\r\ncase TDA18271_DIGITAL:\r\nsaa_writel(SAA7134_GPIO_GPMODE0 >> 2, 0x14000);\r\nsaa_writel(SAA7134_GPIO_GPSTATUS0 >> 2, 0x14000);\r\nmsleep(20);\r\nsaa_writel(SAA7134_GPIO_GPMODE0 >> 2, 0x54000);\r\nsaa_writel(SAA7134_GPIO_GPSTATUS0 >> 2, 0x54000);\r\nmsleep(30);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa7134_kworld_pc150u_toggle_agc(struct saa7134_dev *dev,\r\nenum tda18271_mode mode)\r\n{\r\nswitch (mode) {\r\ncase TDA18271_ANALOG:\r\nsaa7134_set_gpio(dev, 18, 0);\r\nbreak;\r\ncase TDA18271_DIGITAL:\r\nsaa7134_set_gpio(dev, 18, 1);\r\nmsleep(30);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa7134_tda8290_18271_callback(struct saa7134_dev *dev,\r\nint command, int arg)\r\n{\r\nint ret = 0;\r\nswitch (command) {\r\ncase TDA18271_CALLBACK_CMD_AGC_ENABLE:\r\nswitch (dev->board) {\r\ncase SAA7134_BOARD_HAUPPAUGE_HVR1150:\r\ncase SAA7134_BOARD_HAUPPAUGE_HVR1120:\r\ncase SAA7134_BOARD_MAGICPRO_PROHDTV_PRO2:\r\nret = saa7134_tda18271_hvr11x0_toggle_agc(dev, arg);\r\nbreak;\r\ncase SAA7134_BOARD_KWORLD_PCI_SBTVD_FULLSEG:\r\nret = saa7134_kworld_sbtvd_toggle_agc(dev, arg);\r\nbreak;\r\ncase SAA7134_BOARD_KWORLD_PC150U:\r\nret = saa7134_kworld_pc150u_toggle_agc(dev, arg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int saa7134_tda8290_callback(struct saa7134_dev *dev,\r\nint command, int arg)\r\n{\r\nint ret;\r\nswitch (dev->board) {\r\ncase SAA7134_BOARD_HAUPPAUGE_HVR1150:\r\ncase SAA7134_BOARD_HAUPPAUGE_HVR1120:\r\ncase SAA7134_BOARD_AVERMEDIA_M733A:\r\ncase SAA7134_BOARD_KWORLD_PCI_SBTVD_FULLSEG:\r\ncase SAA7134_BOARD_KWORLD_PC150U:\r\ncase SAA7134_BOARD_MAGICPRO_PROHDTV_PRO2:\r\nret = saa7134_tda8290_18271_callback(dev, command, arg);\r\nbreak;\r\ndefault:\r\nret = saa7134_tda8290_827x_callback(dev, command, arg);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint saa7134_tuner_callback(void *priv, int component, int command, int arg)\r\n{\r\nstruct saa7134_dev *dev = priv;\r\nif (dev != NULL) {\r\nswitch (dev->tuner_type) {\r\ncase TUNER_PHILIPS_TDA8290:\r\nreturn saa7134_tda8290_callback(dev, command, arg);\r\ncase TUNER_XC2028:\r\nreturn saa7134_xc2028_callback(dev, command, arg);\r\ncase TUNER_XC5000:\r\nreturn saa7134_xc5000_callback(dev, command, arg);\r\n}\r\n} else {\r\nprintk(KERN_ERR "saa7134: Error - device struct undefined.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void hauppauge_eeprom(struct saa7134_dev *dev, u8 *eeprom_data)\r\n{\r\nstruct tveeprom tv;\r\ntveeprom_hauppauge_analog(&dev->i2c_client, &tv, eeprom_data);\r\nswitch (tv.model) {\r\ncase 67019:\r\ncase 67109:\r\ncase 67201:\r\ncase 67301:\r\ncase 67209:\r\ncase 67559:\r\ncase 67569:\r\ncase 67579:\r\ncase 67589:\r\ncase 67599:\r\ncase 67651:\r\ncase 67659:\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: warning: "\r\n"unknown hauppauge model #%d\n", dev->name, tv.model);\r\nbreak;\r\n}\r\nprintk(KERN_INFO "%s: hauppauge eeprom: model=%d\n",\r\ndev->name, tv.model);\r\n}\r\nint saa7134_board_init1(struct saa7134_dev *dev)\r\n{\r\nsaa_writel(SAA7134_GPIO_GPMODE0 >> 2, 0);\r\ndev->gpio_value = saa_readl(SAA7134_GPIO_GPSTATUS0 >> 2);\r\nprintk(KERN_INFO "%s: board init: gpio is %x\n", dev->name, dev->gpio_value);\r\nswitch (dev->board) {\r\ncase SAA7134_BOARD_FLYVIDEO2000:\r\ncase SAA7134_BOARD_FLYVIDEO3000:\r\ncase SAA7134_BOARD_FLYVIDEO3000_NTSC:\r\ndev->has_remote = SAA7134_REMOTE_GPIO;\r\nboard_flyvideo(dev);\r\nbreak;\r\ncase SAA7134_BOARD_FLYTVPLATINUM_MINI2:\r\ncase SAA7134_BOARD_FLYTVPLATINUM_FM:\r\ncase SAA7134_BOARD_CINERGY400:\r\ncase SAA7134_BOARD_CINERGY600:\r\ncase SAA7134_BOARD_CINERGY600_MK3:\r\ncase SAA7134_BOARD_ECS_TVP3XP:\r\ncase SAA7134_BOARD_ECS_TVP3XP_4CB5:\r\ncase SAA7134_BOARD_ECS_TVP3XP_4CB6:\r\ncase SAA7134_BOARD_MD2819:\r\ncase SAA7134_BOARD_KWORLD_VSTREAM_XPERT:\r\ncase SAA7134_BOARD_KWORLD_XPERT:\r\ncase SAA7134_BOARD_AVERMEDIA_STUDIO_305:\r\ncase SAA7134_BOARD_AVERMEDIA_STUDIO_505:\r\ncase SAA7134_BOARD_AVERMEDIA_305:\r\ncase SAA7134_BOARD_AVERMEDIA_STUDIO_307:\r\ncase SAA7134_BOARD_AVERMEDIA_307:\r\ncase SAA7134_BOARD_AVERMEDIA_STUDIO_507:\r\ncase SAA7134_BOARD_AVERMEDIA_GO_007_FM:\r\ncase SAA7134_BOARD_AVERMEDIA_777:\r\ncase SAA7134_BOARD_AVERMEDIA_M135A:\r\ncase SAA7134_BOARD_VIDEOMATE_TV_PVR:\r\ncase SAA7134_BOARD_VIDEOMATE_GOLD_PLUS:\r\ncase SAA7134_BOARD_VIDEOMATE_TV_GOLD_PLUSII:\r\ncase SAA7134_BOARD_VIDEOMATE_M1F:\r\ncase SAA7134_BOARD_VIDEOMATE_DVBT_300:\r\ncase SAA7134_BOARD_VIDEOMATE_DVBT_200:\r\ncase SAA7134_BOARD_VIDEOMATE_DVBT_200A:\r\ncase SAA7134_BOARD_MANLI_MTV001:\r\ncase SAA7134_BOARD_MANLI_MTV002:\r\ncase SAA7134_BOARD_BEHOLD_409FM:\r\ncase SAA7134_BOARD_AVACSSMARTTV:\r\ncase SAA7134_BOARD_GOTVIEW_7135:\r\ncase SAA7134_BOARD_KWORLD_TERMINATOR:\r\ncase SAA7134_BOARD_SEDNA_PC_TV_CARDBUS:\r\ncase SAA7134_BOARD_FLYDVBT_LR301:\r\ncase SAA7134_BOARD_ASUSTeK_PS3_100:\r\ncase SAA7134_BOARD_ASUSTeK_P7131_DUAL:\r\ncase SAA7134_BOARD_ASUSTeK_P7131_HYBRID_LNA:\r\ncase SAA7134_BOARD_ASUSTeK_P7131_ANALOG:\r\ncase SAA7134_BOARD_FLYDVBTDUO:\r\ncase SAA7134_BOARD_PROTEUS_2309:\r\ncase SAA7134_BOARD_AVERMEDIA_A16AR:\r\ncase SAA7134_BOARD_ENCORE_ENLTV:\r\ncase SAA7134_BOARD_ENCORE_ENLTV_FM:\r\ncase SAA7134_BOARD_ENCORE_ENLTV_FM53:\r\ncase SAA7134_BOARD_ENCORE_ENLTV_FM3:\r\ncase SAA7134_BOARD_10MOONSTVMASTER3:\r\ncase SAA7134_BOARD_BEHOLD_401:\r\ncase SAA7134_BOARD_BEHOLD_403:\r\ncase SAA7134_BOARD_BEHOLD_403FM:\r\ncase SAA7134_BOARD_BEHOLD_405:\r\ncase SAA7134_BOARD_BEHOLD_405FM:\r\ncase SAA7134_BOARD_BEHOLD_407:\r\ncase SAA7134_BOARD_BEHOLD_407FM:\r\ncase SAA7134_BOARD_BEHOLD_409:\r\ncase SAA7134_BOARD_BEHOLD_505FM:\r\ncase SAA7134_BOARD_BEHOLD_505RDS_MK5:\r\ncase SAA7134_BOARD_BEHOLD_505RDS_MK3:\r\ncase SAA7134_BOARD_BEHOLD_507_9FM:\r\ncase SAA7134_BOARD_BEHOLD_507RDS_MK3:\r\ncase SAA7134_BOARD_BEHOLD_507RDS_MK5:\r\ncase SAA7134_BOARD_GENIUS_TVGO_A11MCE:\r\ncase SAA7134_BOARD_REAL_ANGEL_220:\r\ncase SAA7134_BOARD_KWORLD_PLUS_TV_ANALOG:\r\ncase SAA7134_BOARD_AVERMEDIA_GO_007_FM_PLUS:\r\ncase SAA7134_BOARD_ROVERMEDIA_LINK_PRO_FM:\r\ncase SAA7134_BOARD_LEADTEK_WINFAST_DTV1000S:\r\ndev->has_remote = SAA7134_REMOTE_GPIO;\r\nbreak;\r\ncase SAA7134_BOARD_FLYDVBS_LR300:\r\nsaa_writeb(SAA7134_GPIO_GPMODE3, 0x80);\r\nsaa_writeb(SAA7134_GPIO_GPSTATUS2, 0x40);\r\ndev->has_remote = SAA7134_REMOTE_GPIO;\r\nbreak;\r\ncase SAA7134_BOARD_MD5044:\r\nprintk("%s: seems there are two different versions of the MD5044\n"\r\n"%s: (with the same ID) out there. If sound doesn't work for\n"\r\n"%s: you try the audio_clock_override=0x200000 insmod option.\n",\r\ndev->name,dev->name,dev->name);\r\nbreak;\r\ncase SAA7134_BOARD_CINERGY400_CARDBUS:\r\nsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, 0x00040000, 0x00040000);\r\nsaa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, 0x00040000, 0x00000000);\r\nbreak;\r\ncase SAA7134_BOARD_PINNACLE_300I_DVBT_PAL:\r\nsaa_writeb(SAA7134_GPIO_GPMODE1, 0x80);\r\nsaa_writeb(SAA7134_GPIO_GPSTATUS1, 0x80);\r\nbreak;\r\ncase SAA7134_BOARD_MONSTERTV_MOBILE:\r\nsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, 0x00040000, 0x00040000);\r\nsaa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, 0x00040000, 0x00000004);\r\nbreak;\r\ncase SAA7134_BOARD_FLYDVBT_DUO_CARDBUS:\r\nsaa_writeb(SAA7134_GPIO_GPMODE3, 0x08);\r\nsaa_writeb(SAA7134_GPIO_GPSTATUS3, 0x06);\r\nbreak;\r\ncase SAA7134_BOARD_ADS_DUO_CARDBUS_PTV331:\r\ncase SAA7134_BOARD_FLYDVBT_HYBRID_CARDBUS:\r\nsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, 0x08000000, 0x08000000);\r\nsaa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, 0x08000000, 0x00000000);\r\nbreak;\r\ncase SAA7134_BOARD_AVERMEDIA_CARDBUS:\r\ncase SAA7134_BOARD_AVERMEDIA_M115:\r\nsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, 0xffffffff, 0);\r\nsaa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, 0xffffffff, 0);\r\nmsleep(10);\r\nsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, 0xffffffff, 0xffffffff);\r\nsaa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, 0xffffffff, 0xffffffff);\r\nmsleep(10);\r\nbreak;\r\ncase SAA7134_BOARD_AVERMEDIA_CARDBUS_501:\r\nsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, 0x08400000, 0x08400000);\r\nsaa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, 0x08400000, 0);\r\nmsleep(10);\r\nsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, 0x08400000, 0x08400000);\r\nsaa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, 0x08400000, 0x08400000);\r\nmsleep(10);\r\ndev->has_remote = SAA7134_REMOTE_I2C;\r\nbreak;\r\ncase SAA7134_BOARD_AVERMEDIA_CARDBUS_506:\r\nsaa7134_set_gpio(dev, 23, 0);\r\nmsleep(10);\r\nsaa7134_set_gpio(dev, 23, 1);\r\ndev->has_remote = SAA7134_REMOTE_I2C;\r\nbreak;\r\ncase SAA7134_BOARD_AVERMEDIA_M103:\r\nsaa7134_set_gpio(dev, 23, 0);\r\nmsleep(10);\r\nsaa7134_set_gpio(dev, 23, 1);\r\nbreak;\r\ncase SAA7134_BOARD_AVERMEDIA_A16D:\r\nsaa7134_set_gpio(dev, 21, 0);\r\nmsleep(10);\r\nsaa7134_set_gpio(dev, 21, 1);\r\nmsleep(1);\r\ndev->has_remote = SAA7134_REMOTE_GPIO;\r\nbreak;\r\ncase SAA7134_BOARD_BEHOLD_COLUMBUS_TVFM:\r\nsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, 0x000A8004, 0x000A8004);\r\nsaa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, 0x000A8004, 0);\r\nmsleep(10);\r\nsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, 0x000A8004, 0x000A8004);\r\nsaa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, 0x000A8004, 0x000A8004);\r\nmsleep(10);\r\ndev->has_remote = SAA7134_REMOTE_GPIO;\r\nbreak;\r\ncase SAA7134_BOARD_RTD_VFG7350:\r\nsaa_writeb (SAA7134_PRODUCTION_TEST_MODE, 0x00);\r\nbreak;\r\ncase SAA7134_BOARD_HAUPPAUGE_HVR1150:\r\ncase SAA7134_BOARD_HAUPPAUGE_HVR1120:\r\ndev->has_remote = SAA7134_REMOTE_GPIO;\r\nsaa7134_set_gpio(dev, 26, 0);\r\nmsleep(1);\r\nsaa7134_set_gpio(dev, 22, 0);\r\nmsleep(10);\r\nsaa7134_set_gpio(dev, 22, 1);\r\nbreak;\r\ncase SAA7134_BOARD_PINNACLE_PCTV_110i:\r\ncase SAA7134_BOARD_PINNACLE_PCTV_310i:\r\ncase SAA7134_BOARD_UPMOST_PURPLE_TV:\r\ncase SAA7134_BOARD_MSI_TVATANYWHERE_PLUS:\r\ncase SAA7134_BOARD_HAUPPAUGE_HVR1110:\r\ncase SAA7134_BOARD_BEHOLD_607FM_MK3:\r\ncase SAA7134_BOARD_BEHOLD_607FM_MK5:\r\ncase SAA7134_BOARD_BEHOLD_609FM_MK3:\r\ncase SAA7134_BOARD_BEHOLD_609FM_MK5:\r\ncase SAA7134_BOARD_BEHOLD_607RDS_MK3:\r\ncase SAA7134_BOARD_BEHOLD_607RDS_MK5:\r\ncase SAA7134_BOARD_BEHOLD_609RDS_MK3:\r\ncase SAA7134_BOARD_BEHOLD_609RDS_MK5:\r\ncase SAA7134_BOARD_BEHOLD_M6:\r\ncase SAA7134_BOARD_BEHOLD_M63:\r\ncase SAA7134_BOARD_BEHOLD_M6_EXTRA:\r\ncase SAA7134_BOARD_BEHOLD_H6:\r\ncase SAA7134_BOARD_BEHOLD_X7:\r\ncase SAA7134_BOARD_BEHOLD_H7:\r\ncase SAA7134_BOARD_BEHOLD_A7:\r\ncase SAA7134_BOARD_KWORLD_PC150U:\r\ndev->has_remote = SAA7134_REMOTE_I2C;\r\nbreak;\r\ncase SAA7134_BOARD_AVERMEDIA_A169_B:\r\nprintk("%s: %s: dual saa713x broadcast decoders\n"\r\n"%s: Sorry, none of the inputs to this chip are supported yet.\n"\r\n"%s: Dual decoder functionality is disabled for now, use the other chip.\n",\r\ndev->name,card(dev).name,dev->name,dev->name);\r\nbreak;\r\ncase SAA7134_BOARD_AVERMEDIA_M102:\r\ndev->has_remote = SAA7134_REMOTE_GPIO;\r\nsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, 0x8c040007, 0x8c040007);\r\nsaa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, 0x0c0007cd, 0x0c0007cd);\r\nbreak;\r\ncase SAA7134_BOARD_AVERMEDIA_A700_HYBRID:\r\ncase SAA7134_BOARD_AVERMEDIA_A700_PRO:\r\nsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, 0x80040100, 0x80040100);\r\nsaa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, 0x80040100, 0x00040100);\r\nbreak;\r\ncase SAA7134_BOARD_AVERMEDIA_A706:\r\nsaa7134_set_gpio(dev, 12, 3);\r\nsaa7134_set_gpio(dev, 13, 3);\r\ndev->has_remote = SAA7134_REMOTE_I2C;\r\nsaa7134_set_gpio(dev, 23, 1);\r\nbreak;\r\ncase SAA7134_BOARD_VIDEOMATE_S350:\r\ndev->has_remote = SAA7134_REMOTE_GPIO;\r\nsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, 0x0000C000, 0x0000C000);\r\nsaa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, 0x0000C000, 0x0000C000);\r\nbreak;\r\ncase SAA7134_BOARD_AVERMEDIA_M733A:\r\nsaa7134_set_gpio(dev, 1, 1);\r\nmsleep(10);\r\nsaa7134_set_gpio(dev, 1, 0);\r\nmsleep(10);\r\nsaa7134_set_gpio(dev, 1, 1);\r\ndev->has_remote = SAA7134_REMOTE_GPIO;\r\nbreak;\r\ncase SAA7134_BOARD_MAGICPRO_PROHDTV_PRO2:\r\nsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, 0x0e050000, 0x0c050000);\r\nsaa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, 0x0e050000, 0x0c050000);\r\nbreak;\r\ncase SAA7134_BOARD_VIDEOMATE_T750:\r\nsaa_andorl(SAA7134_GPIO_GPMODE0 >> 2, 0x00008000, 0x00008000);\r\nsaa_andorl(SAA7134_GPIO_GPSTATUS0 >> 2, 0x00008000, 0x00008000);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void saa7134_tuner_setup(struct saa7134_dev *dev)\r\n{\r\nstruct tuner_setup tun_setup;\r\nunsigned int mode_mask = T_RADIO | T_ANALOG_TV;\r\nmemset(&tun_setup, 0, sizeof(tun_setup));\r\ntun_setup.tuner_callback = saa7134_tuner_callback;\r\nif (saa7134_boards[dev->board].radio_type != UNSET) {\r\ntun_setup.type = saa7134_boards[dev->board].radio_type;\r\ntun_setup.addr = saa7134_boards[dev->board].radio_addr;\r\ntun_setup.mode_mask = T_RADIO;\r\nsaa_call_all(dev, tuner, s_type_addr, &tun_setup);\r\nmode_mask &= ~T_RADIO;\r\n}\r\nif ((dev->tuner_type != TUNER_ABSENT) && (dev->tuner_type != UNSET)) {\r\ntun_setup.type = dev->tuner_type;\r\ntun_setup.addr = dev->tuner_addr;\r\ntun_setup.config = &saa7134_boards[dev->board].tda829x_conf;\r\ntun_setup.tuner_callback = saa7134_tuner_callback;\r\ntun_setup.mode_mask = mode_mask;\r\nsaa_call_all(dev, tuner, s_type_addr, &tun_setup);\r\n}\r\nif (dev->tda9887_conf) {\r\nstruct v4l2_priv_tun_config tda9887_cfg;\r\ntda9887_cfg.tuner = TUNER_TDA9887;\r\ntda9887_cfg.priv = &dev->tda9887_conf;\r\nsaa_call_all(dev, tuner, s_config, &tda9887_cfg);\r\n}\r\nif (dev->tuner_type == TUNER_XC2028) {\r\nstruct v4l2_priv_tun_config xc2028_cfg;\r\nstruct xc2028_ctrl ctl;\r\nmemset(&xc2028_cfg, 0, sizeof(xc2028_cfg));\r\nmemset(&ctl, 0, sizeof(ctl));\r\nctl.fname = XC2028_DEFAULT_FIRMWARE;\r\nctl.max_len = 64;\r\nswitch (dev->board) {\r\ncase SAA7134_BOARD_AVERMEDIA_A16D:\r\ncase SAA7134_BOARD_AVERMEDIA_CARDBUS_506:\r\ncase SAA7134_BOARD_AVERMEDIA_M103:\r\ncase SAA7134_BOARD_AVERMEDIA_A700_HYBRID:\r\nctl.demod = XC3028_FE_ZARLINK456;\r\nbreak;\r\ndefault:\r\nctl.demod = XC3028_FE_OREN538;\r\nctl.mts = 1;\r\n}\r\nxc2028_cfg.tuner = TUNER_XC2028;\r\nxc2028_cfg.priv = &ctl;\r\nsaa_call_all(dev, tuner, s_config, &xc2028_cfg);\r\n}\r\n}\r\nint saa7134_board_init2(struct saa7134_dev *dev)\r\n{\r\nunsigned char buf;\r\nint board;\r\nswitch (dev->board) {\r\ncase SAA7134_BOARD_BMK_MPEX_NOTUNER:\r\ncase SAA7134_BOARD_BMK_MPEX_TUNER:\r\ndev->i2c_client.addr = 0x60;\r\nboard = (i2c_master_recv(&dev->i2c_client, &buf, 0) < 0)\r\n? SAA7134_BOARD_BMK_MPEX_NOTUNER\r\n: SAA7134_BOARD_BMK_MPEX_TUNER;\r\nif (board == dev->board)\r\nbreak;\r\ndev->board = board;\r\nprintk("%s: board type fixup: %s\n", dev->name,\r\nsaa7134_boards[dev->board].name);\r\ndev->tuner_type = saa7134_boards[dev->board].tuner_type;\r\nbreak;\r\ncase SAA7134_BOARD_MD7134:\r\n{\r\nu8 subaddr;\r\nu8 data[3];\r\nint ret, tuner_t;\r\nstruct i2c_msg msg[] = {{.addr=0x50, .flags=0, .buf=&subaddr, .len = 1},\r\n{.addr=0x50, .flags=I2C_M_RD, .buf=data, .len = 3}};\r\nsubaddr= 0x14;\r\ntuner_t = 0;\r\nret = i2c_transfer(&dev->i2c_adap, msg, 2);\r\nif (ret != 2) {\r\nprintk(KERN_ERR "EEPROM read failure\n");\r\n} else if ((data[0] != 0) && (data[0] != 0xff)) {\r\nsubaddr = data[0] + 2;\r\nmsg[1].len = 2;\r\ni2c_transfer(&dev->i2c_adap, msg, 2);\r\ntuner_t = (data[0] << 8) + data[1];\r\nswitch (tuner_t){\r\ncase 0x0103:\r\ndev->tuner_type = TUNER_PHILIPS_PAL;\r\nbreak;\r\ncase 0x010C:\r\ndev->tuner_type = TUNER_PHILIPS_FM1216ME_MK3;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s Can't determine tuner type %x from EEPROM\n", dev->name, tuner_t);\r\n}\r\n} else if ((data[1] != 0) && (data[1] != 0xff)) {\r\nsubaddr = data[1] + 1;\r\nmsg[1].len = 1;\r\ni2c_transfer(&dev->i2c_adap, msg, 2);\r\nsubaddr = data[0] + 1;\r\nmsg[1].len = 2;\r\ni2c_transfer(&dev->i2c_adap, msg, 2);\r\ntuner_t = (data[1] << 8) + data[0];\r\nswitch (tuner_t) {\r\ncase 0x0005:\r\ndev->tuner_type = TUNER_PHILIPS_FM1216ME_MK3;\r\nbreak;\r\ncase 0x001d:\r\ndev->tuner_type = TUNER_PHILIPS_FMD1216ME_MK3;\r\nprintk(KERN_INFO "%s Board has DVB-T\n", dev->name);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s Can't determine tuner type %x from EEPROM\n", dev->name, tuner_t);\r\n}\r\n} else {\r\nprintk(KERN_ERR "%s unexpected config structure\n", dev->name);\r\n}\r\nprintk(KERN_INFO "%s Tuner type is %d\n", dev->name, dev->tuner_type);\r\nbreak;\r\n}\r\ncase SAA7134_BOARD_PHILIPS_EUROPA:\r\nif (dev->autodetected && (dev->eedata[0x41] == 0x1c)) {\r\ndev->board = SAA7134_BOARD_PHILIPS_SNAKE;\r\ndev->tuner_type = saa7134_boards[dev->board].tuner_type;\r\nprintk(KERN_INFO "%s: Reconfigured board as %s\n",\r\ndev->name, saa7134_boards[dev->board].name);\r\nbreak;\r\n}\r\ncase SAA7134_BOARD_VIDEOMATE_DVBT_300:\r\ncase SAA7134_BOARD_ASUS_EUROPA2_HYBRID:\r\ncase SAA7134_BOARD_ASUS_EUROPA_HYBRID:\r\ncase SAA7134_BOARD_TECHNOTREND_BUDGET_T3000:\r\n{\r\nu8 data[] = { 0x07, 0x02};\r\nstruct i2c_msg msg = {.addr=0x08, .flags=0, .buf=data, .len = sizeof(data)};\r\ni2c_transfer(&dev->i2c_adap, &msg, 1);\r\nbreak;\r\n}\r\ncase SAA7134_BOARD_PHILIPS_TIGER:\r\ncase SAA7134_BOARD_PHILIPS_TIGER_S:\r\n{\r\nu8 data[] = { 0x3c, 0x33, 0x60};\r\nstruct i2c_msg msg = {.addr=0x08, .flags=0, .buf=data, .len = sizeof(data)};\r\nif (dev->autodetected && (dev->eedata[0x49] == 0x50)) {\r\ndev->board = SAA7134_BOARD_PHILIPS_TIGER_S;\r\nprintk(KERN_INFO "%s: Reconfigured board as %s\n",\r\ndev->name, saa7134_boards[dev->board].name);\r\n}\r\nif (dev->board == SAA7134_BOARD_PHILIPS_TIGER_S) {\r\ndev->tuner_type = TUNER_PHILIPS_TDA8290;\r\ndata[2] = 0x68;\r\ni2c_transfer(&dev->i2c_adap, &msg, 1);\r\nbreak;\r\n}\r\ni2c_transfer(&dev->i2c_adap, &msg, 1);\r\nbreak;\r\n}\r\ncase SAA7134_BOARD_ASUSTeK_TVFM7135:\r\nif (dev->autodetected && (dev->eedata[0x27] == 0x03)) {\r\ndev->board = SAA7134_BOARD_ASUSTeK_P7131_ANALOG;\r\nprintk(KERN_INFO "%s: P7131 analog only, using "\r\n"entry of %s\n",\r\ndev->name, saa7134_boards[dev->board].name);\r\ndev->has_remote = SAA7134_REMOTE_GPIO;\r\nsaa7134_input_init1(dev);\r\n}\r\nbreak;\r\ncase SAA7134_BOARD_HAUPPAUGE_HVR1150:\r\ncase SAA7134_BOARD_HAUPPAUGE_HVR1120:\r\nhauppauge_eeprom(dev, dev->eedata+0x80);\r\nbreak;\r\ncase SAA7134_BOARD_HAUPPAUGE_HVR1110:\r\nhauppauge_eeprom(dev, dev->eedata+0x80);\r\ncase SAA7134_BOARD_PINNACLE_PCTV_310i:\r\ncase SAA7134_BOARD_KWORLD_DVBT_210:\r\ncase SAA7134_BOARD_TEVION_DVBT_220RF:\r\ncase SAA7134_BOARD_ASUSTeK_TIGER:\r\ncase SAA7134_BOARD_ASUSTeK_P7131_DUAL:\r\ncase SAA7134_BOARD_ASUSTeK_P7131_HYBRID_LNA:\r\ncase SAA7134_BOARD_MEDION_MD8800_QUADRO:\r\ncase SAA7134_BOARD_AVERMEDIA_SUPER_007:\r\ncase SAA7134_BOARD_TWINHAN_DTV_DVB_3056:\r\ncase SAA7134_BOARD_CREATIX_CTX953:\r\n{\r\nu8 data[] = { 0x3c, 0x33, 0x60};\r\nstruct i2c_msg msg = {.addr=0x08, .flags=0, .buf=data, .len = sizeof(data)};\r\ni2c_transfer(&dev->i2c_adap, &msg, 1);\r\nbreak;\r\n}\r\ncase SAA7134_BOARD_ASUSTeK_TIGER_3IN1:\r\n{\r\nu8 data[] = { 0x3c, 0x33, 0x60};\r\nstruct i2c_msg msg = {.addr = 0x0b, .flags = 0, .buf = data,\r\n.len = sizeof(data)};\r\ni2c_transfer(&dev->i2c_adap, &msg, 1);\r\nbreak;\r\n}\r\ncase SAA7134_BOARD_ASUSTeK_PS3_100:\r\n{\r\nu8 data[] = { 0x3c, 0x33, 0x60};\r\nstruct i2c_msg msg = {.addr = 0x0b, .flags = 0, .buf = data,\r\n.len = sizeof(data)};\r\ni2c_transfer(&dev->i2c_adap, &msg, 1);\r\nbreak;\r\n}\r\ncase SAA7134_BOARD_FLYDVB_TRIO:\r\n{\r\nu8 temp = 0;\r\nint rc;\r\nu8 data[] = { 0x3c, 0x33, 0x62};\r\nstruct i2c_msg msg = {.addr=0x09, .flags=0, .buf=data, .len = sizeof(data)};\r\ni2c_transfer(&dev->i2c_adap, &msg, 1);\r\nmsg.buf = &temp;\r\nmsg.addr = 0x0b;\r\nmsg.len = 1;\r\nif (1 != i2c_transfer(&dev->i2c_adap, &msg, 1)) {\r\nprintk(KERN_WARNING "%s: send wake up byte to pic16C505"\r\n"(IR chip) failed\n", dev->name);\r\n} else {\r\nmsg.flags = I2C_M_RD;\r\nrc = i2c_transfer(&dev->i2c_adap, &msg, 1);\r\nprintk(KERN_INFO "%s: probe IR chip @ i2c 0x%02x: %s\n",\r\ndev->name, msg.addr,\r\n(1 == rc) ? "yes" : "no");\r\nif (rc == 1)\r\ndev->has_remote = SAA7134_REMOTE_I2C;\r\n}\r\nbreak;\r\n}\r\ncase SAA7134_BOARD_ADS_DUO_CARDBUS_PTV331:\r\ncase SAA7134_BOARD_FLYDVBT_HYBRID_CARDBUS:\r\n{\r\nu8 data[] = { 0x3c, 0x33, 0x6a};\r\nstruct i2c_msg msg = {.addr=0x08, .flags=0, .buf=data, .len = sizeof(data)};\r\ni2c_transfer(&dev->i2c_adap, &msg, 1);\r\nbreak;\r\n}\r\ncase SAA7134_BOARD_CINERGY_HT_PCMCIA:\r\ncase SAA7134_BOARD_CINERGY_HT_PCI:\r\n{\r\nu8 data[] = { 0x3c, 0x33, 0x68};\r\nstruct i2c_msg msg = {.addr=0x08, .flags=0, .buf=data, .len = sizeof(data)};\r\ni2c_transfer(&dev->i2c_adap, &msg, 1);\r\nbreak;\r\n}\r\ncase SAA7134_BOARD_VIDEOMATE_DVBT_200:\r\ncase SAA7134_BOARD_VIDEOMATE_DVBT_200A:\r\nif (!dev->autodetected || (dev->eedata[0x41] == 0xd0))\r\nbreak;\r\nif (dev->eedata[0x41] == 0x02) {\r\ndev->board = SAA7134_BOARD_VIDEOMATE_DVBT_200A;\r\ndev->tuner_type = saa7134_boards[dev->board].tuner_type;\r\ndev->tda9887_conf = saa7134_boards[dev->board].tda9887_conf;\r\nprintk(KERN_INFO "%s: Reconfigured board as %s\n",\r\ndev->name, saa7134_boards[dev->board].name);\r\n} else {\r\nprintk(KERN_WARNING "%s: Unexpected tuner type info: %x in eeprom\n",\r\ndev->name, dev->eedata[0x41]);\r\nbreak;\r\n}\r\nbreak;\r\ncase SAA7134_BOARD_ADS_INSTANT_HDTV_PCI:\r\ncase SAA7134_BOARD_KWORLD_ATSC110:\r\n{\r\nstruct i2c_msg msg = { .addr = 0x0a, .flags = 0 };\r\nint i;\r\nstatic u8 buffer[][2] = {\r\n{ 0x10, 0x12 },\r\n{ 0x13, 0x04 },\r\n{ 0x16, 0x00 },\r\n{ 0x14, 0x04 },\r\n{ 0x17, 0x00 },\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(buffer); i++) {\r\nmsg.buf = &buffer[i][0];\r\nmsg.len = ARRAY_SIZE(buffer[0]);\r\nif (i2c_transfer(&dev->i2c_adap, &msg, 1) != 1)\r\nprintk(KERN_WARNING\r\n"%s: Unable to enable tuner(%i).\n",\r\ndev->name, i);\r\n}\r\nbreak;\r\n}\r\ncase SAA7134_BOARD_BEHOLD_H6:\r\n{\r\nu8 data[] = { 0x09, 0x9f, 0x86, 0x11};\r\nstruct i2c_msg msg = {.addr = 0x61, .flags = 0, .buf = data,\r\n.len = sizeof(data)};\r\nif (i2c_transfer(&dev->i2c_adap, &msg, 1) != 1)\r\nprintk(KERN_WARNING\r\n"%s: Unable to enable IF of the tuner.\n",\r\ndev->name);\r\nbreak;\r\n}\r\ncase SAA7134_BOARD_KWORLD_PCI_SBTVD_FULLSEG:\r\nsaa_writel(SAA7134_GPIO_GPMODE0 >> 2, 0x4000);\r\nsaa_writel(SAA7134_GPIO_GPSTATUS0 >> 2, 0x4000);\r\nsaa7134_set_gpio(dev, 27, 0);\r\nbreak;\r\n}\r\nif (!dev->insuspend && TUNER_ABSENT != dev->tuner_type) {\r\nint has_demod = (dev->tda9887_conf & TDA9887_PRESENT);\r\nif (dev->radio_type != UNSET)\r\nv4l2_i2c_new_subdev(&dev->v4l2_dev,\r\n&dev->i2c_adap, "tuner",\r\ndev->radio_addr, NULL);\r\nif (has_demod)\r\nv4l2_i2c_new_subdev(&dev->v4l2_dev,\r\n&dev->i2c_adap, "tuner",\r\n0, v4l2_i2c_tuner_addrs(ADDRS_DEMOD));\r\nif (dev->tuner_addr == ADDR_UNSET) {\r\nenum v4l2_i2c_tuner_type type =\r\nhas_demod ? ADDRS_TV_WITH_DEMOD : ADDRS_TV;\r\nv4l2_i2c_new_subdev(&dev->v4l2_dev,\r\n&dev->i2c_adap, "tuner",\r\n0, v4l2_i2c_tuner_addrs(type));\r\n} else {\r\nv4l2_i2c_new_subdev(&dev->v4l2_dev,\r\n&dev->i2c_adap, "tuner",\r\ndev->tuner_addr, NULL);\r\n}\r\n}\r\nsaa7134_tuner_setup(dev);\r\nswitch (dev->board) {\r\ncase SAA7134_BOARD_BEHOLD_COLUMBUS_TVFM:\r\ncase SAA7134_BOARD_AVERMEDIA_CARDBUS_501:\r\n{\r\nstruct v4l2_priv_tun_config tea5767_cfg;\r\nstruct tea5767_ctrl ctl;\r\ndev->i2c_client.addr = 0xC0;\r\nmemset(&ctl, 0, sizeof(ctl));\r\nctl.xtal_freq = TEA5767_HIGH_LO_13MHz;\r\ntea5767_cfg.tuner = TUNER_TEA5767;\r\ntea5767_cfg.priv = &ctl;\r\nsaa_call_all(dev, tuner, s_config, &tea5767_cfg);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}
