static inline int ap_using_interrupts(void)\r\n{\r\nreturn ap_airq_flag;\r\n}\r\nstatic inline int ap_instructions_available(void)\r\n{\r\nregister unsigned long reg0 asm ("0") = AP_MKQID(0,0);\r\nregister unsigned long reg1 asm ("1") = -ENODEV;\r\nregister unsigned long reg2 asm ("2") = 0UL;\r\nasm volatile(\r\n" .long 0xb2af0000\n"\r\n"0: la %1,0\n"\r\n"1:\n"\r\nEX_TABLE(0b, 1b)\r\n: "+d" (reg0), "+d" (reg1), "+d" (reg2) : : "cc" );\r\nreturn reg1;\r\n}\r\nstatic int ap_interrupts_available(void)\r\n{\r\nreturn test_facility(2) && test_facility(65);\r\n}\r\nstatic int ap_configuration_available(void)\r\n{\r\nreturn test_facility(2) && test_facility(12);\r\n}\r\nstatic inline struct ap_queue_status\r\nap_test_queue(ap_qid_t qid, int *queue_depth, int *device_type)\r\n{\r\nregister unsigned long reg0 asm ("0") = qid;\r\nregister struct ap_queue_status reg1 asm ("1");\r\nregister unsigned long reg2 asm ("2") = 0UL;\r\nasm volatile(".long 0xb2af0000"\r\n: "+d" (reg0), "=d" (reg1), "+d" (reg2) : : "cc");\r\n*device_type = (int) (reg2 >> 24);\r\n*queue_depth = (int) (reg2 & 0xff);\r\nreturn reg1;\r\n}\r\nstatic inline struct ap_queue_status ap_reset_queue(ap_qid_t qid)\r\n{\r\nregister unsigned long reg0 asm ("0") = qid | 0x01000000UL;\r\nregister struct ap_queue_status reg1 asm ("1");\r\nregister unsigned long reg2 asm ("2") = 0UL;\r\nasm volatile(\r\n".long 0xb2af0000"\r\n: "+d" (reg0), "=d" (reg1), "+d" (reg2) : : "cc");\r\nreturn reg1;\r\n}\r\nstatic inline struct ap_queue_status\r\nap_queue_interruption_control(ap_qid_t qid, void *ind)\r\n{\r\nregister unsigned long reg0 asm ("0") = qid | 0x03000000UL;\r\nregister unsigned long reg1_in asm ("1") = 0x0000800000000000UL | AP_ISC;\r\nregister struct ap_queue_status reg1_out asm ("1");\r\nregister void *reg2 asm ("2") = ind;\r\nasm volatile(\r\n".long 0xb2af0000"\r\n: "+d" (reg0), "+d" (reg1_in), "=d" (reg1_out), "+d" (reg2)\r\n:\r\n: "cc" );\r\nreturn reg1_out;\r\n}\r\nstatic inline struct ap_queue_status\r\n__ap_query_functions(ap_qid_t qid, unsigned int *functions)\r\n{\r\nregister unsigned long reg0 asm ("0") = 0UL | qid | (1UL << 23);\r\nregister struct ap_queue_status reg1 asm ("1") = AP_QUEUE_STATUS_INVALID;\r\nregister unsigned long reg2 asm ("2");\r\nasm volatile(\r\n".long 0xb2af0000\n"\r\n"0:\n"\r\nEX_TABLE(0b, 0b)\r\n: "+d" (reg0), "+d" (reg1), "=d" (reg2)\r\n:\r\n: "cc");\r\n*functions = (unsigned int)(reg2 >> 32);\r\nreturn reg1;\r\n}\r\nstatic inline int __ap_query_configuration(struct ap_config_info *config)\r\n{\r\nregister unsigned long reg0 asm ("0") = 0x04000000UL;\r\nregister unsigned long reg1 asm ("1") = -EINVAL;\r\nregister unsigned char *reg2 asm ("2") = (unsigned char *)config;\r\nasm volatile(\r\n".long 0xb2af0000\n"\r\n"0: la %1,0\n"\r\n"1:\n"\r\nEX_TABLE(0b, 1b)\r\n: "+d" (reg0), "+d" (reg1), "+d" (reg2)\r\n:\r\n: "cc");\r\nreturn reg1;\r\n}\r\nstatic int ap_query_functions(ap_qid_t qid, unsigned int *functions)\r\n{\r\n#ifdef CONFIG_64BIT\r\nstruct ap_queue_status status;\r\nint i;\r\nstatus = __ap_query_functions(qid, functions);\r\nfor (i = 0; i < AP_MAX_RESET; i++) {\r\nif (ap_queue_status_invalid_test(&status))\r\nreturn -ENODEV;\r\nswitch (status.response_code) {\r\ncase AP_RESPONSE_NORMAL:\r\nreturn 0;\r\ncase AP_RESPONSE_RESET_IN_PROGRESS:\r\ncase AP_RESPONSE_BUSY:\r\nbreak;\r\ncase AP_RESPONSE_Q_NOT_AVAIL:\r\ncase AP_RESPONSE_DECONFIGURED:\r\ncase AP_RESPONSE_CHECKSTOPPED:\r\ncase AP_RESPONSE_INVALID_ADDRESS:\r\nreturn -ENODEV;\r\ncase AP_RESPONSE_OTHERWISE_CHANGED:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (i < AP_MAX_RESET - 1) {\r\nudelay(5);\r\nstatus = __ap_query_functions(qid, functions);\r\n}\r\n}\r\nreturn -EBUSY;\r\n#else\r\nreturn -EINVAL;\r\n#endif\r\n}\r\nstatic int ap_queue_enable_interruption(ap_qid_t qid, void *ind)\r\n{\r\n#ifdef CONFIG_64BIT\r\nstruct ap_queue_status status;\r\nint t_depth, t_device_type, rc, i;\r\nrc = -EBUSY;\r\nstatus = ap_queue_interruption_control(qid, ind);\r\nfor (i = 0; i < AP_MAX_RESET; i++) {\r\nswitch (status.response_code) {\r\ncase AP_RESPONSE_NORMAL:\r\nif (status.int_enabled)\r\nreturn 0;\r\nbreak;\r\ncase AP_RESPONSE_RESET_IN_PROGRESS:\r\ncase AP_RESPONSE_BUSY:\r\nif (i < AP_MAX_RESET - 1) {\r\nudelay(5);\r\nstatus = ap_queue_interruption_control(qid,\r\nind);\r\ncontinue;\r\n}\r\nbreak;\r\ncase AP_RESPONSE_Q_NOT_AVAIL:\r\ncase AP_RESPONSE_DECONFIGURED:\r\ncase AP_RESPONSE_CHECKSTOPPED:\r\ncase AP_RESPONSE_INVALID_ADDRESS:\r\nreturn -ENODEV;\r\ncase AP_RESPONSE_OTHERWISE_CHANGED:\r\nif (status.int_enabled)\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (i < AP_MAX_RESET - 1) {\r\nudelay(5);\r\nstatus = ap_test_queue(qid, &t_depth, &t_device_type);\r\n}\r\n}\r\nreturn rc;\r\n#else\r\nreturn -EINVAL;\r\n#endif\r\n}\r\nstatic inline struct ap_queue_status\r\n__ap_send(ap_qid_t qid, unsigned long long psmid, void *msg, size_t length,\r\nunsigned int special)\r\n{\r\ntypedef struct { char _[length]; } msgblock;\r\nregister unsigned long reg0 asm ("0") = qid | 0x40000000UL;\r\nregister struct ap_queue_status reg1 asm ("1");\r\nregister unsigned long reg2 asm ("2") = (unsigned long) msg;\r\nregister unsigned long reg3 asm ("3") = (unsigned long) length;\r\nregister unsigned long reg4 asm ("4") = (unsigned int) (psmid >> 32);\r\nregister unsigned long reg5 asm ("5") = psmid & 0xffffffff;\r\nif (special == 1)\r\nreg0 |= 0x400000UL;\r\nasm volatile (\r\n"0: .long 0xb2ad0042\n"\r\n" brc 2,0b"\r\n: "+d" (reg0), "=d" (reg1), "+d" (reg2), "+d" (reg3)\r\n: "d" (reg4), "d" (reg5), "m" (*(msgblock *) msg)\r\n: "cc" );\r\nreturn reg1;\r\n}\r\nint ap_send(ap_qid_t qid, unsigned long long psmid, void *msg, size_t length)\r\n{\r\nstruct ap_queue_status status;\r\nstatus = __ap_send(qid, psmid, msg, length, 0);\r\nswitch (status.response_code) {\r\ncase AP_RESPONSE_NORMAL:\r\nreturn 0;\r\ncase AP_RESPONSE_Q_FULL:\r\ncase AP_RESPONSE_RESET_IN_PROGRESS:\r\nreturn -EBUSY;\r\ncase AP_RESPONSE_REQ_FAC_NOT_INST:\r\nreturn -EINVAL;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic inline struct ap_queue_status\r\n__ap_recv(ap_qid_t qid, unsigned long long *psmid, void *msg, size_t length)\r\n{\r\ntypedef struct { char _[length]; } msgblock;\r\nregister unsigned long reg0 asm("0") = qid | 0x80000000UL;\r\nregister struct ap_queue_status reg1 asm ("1");\r\nregister unsigned long reg2 asm("2") = 0UL;\r\nregister unsigned long reg4 asm("4") = (unsigned long) msg;\r\nregister unsigned long reg5 asm("5") = (unsigned long) length;\r\nregister unsigned long reg6 asm("6") = 0UL;\r\nregister unsigned long reg7 asm("7") = 0UL;\r\nasm volatile(\r\n"0: .long 0xb2ae0064\n"\r\n" brc 6,0b\n"\r\n: "+d" (reg0), "=d" (reg1), "+d" (reg2),\r\n"+d" (reg4), "+d" (reg5), "+d" (reg6), "+d" (reg7),\r\n"=m" (*(msgblock *) msg) : : "cc" );\r\n*psmid = (((unsigned long long) reg6) << 32) + reg7;\r\nreturn reg1;\r\n}\r\nint ap_recv(ap_qid_t qid, unsigned long long *psmid, void *msg, size_t length)\r\n{\r\nstruct ap_queue_status status;\r\nstatus = __ap_recv(qid, psmid, msg, length);\r\nswitch (status.response_code) {\r\ncase AP_RESPONSE_NORMAL:\r\nreturn 0;\r\ncase AP_RESPONSE_NO_PENDING_REPLY:\r\nif (status.queue_empty)\r\nreturn -ENOENT;\r\nreturn -EBUSY;\r\ncase AP_RESPONSE_RESET_IN_PROGRESS:\r\nreturn -EBUSY;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic int ap_query_queue(ap_qid_t qid, int *queue_depth, int *device_type)\r\n{\r\nstruct ap_queue_status status;\r\nint t_depth, t_device_type, rc, i;\r\nrc = -EBUSY;\r\nfor (i = 0; i < AP_MAX_RESET; i++) {\r\nstatus = ap_test_queue(qid, &t_depth, &t_device_type);\r\nswitch (status.response_code) {\r\ncase AP_RESPONSE_NORMAL:\r\n*queue_depth = t_depth + 1;\r\n*device_type = t_device_type;\r\nrc = 0;\r\nbreak;\r\ncase AP_RESPONSE_Q_NOT_AVAIL:\r\nrc = -ENODEV;\r\nbreak;\r\ncase AP_RESPONSE_RESET_IN_PROGRESS:\r\nbreak;\r\ncase AP_RESPONSE_DECONFIGURED:\r\nrc = -ENODEV;\r\nbreak;\r\ncase AP_RESPONSE_CHECKSTOPPED:\r\nrc = -ENODEV;\r\nbreak;\r\ncase AP_RESPONSE_INVALID_ADDRESS:\r\nrc = -ENODEV;\r\nbreak;\r\ncase AP_RESPONSE_OTHERWISE_CHANGED:\r\nbreak;\r\ncase AP_RESPONSE_BUSY:\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (rc != -EBUSY)\r\nbreak;\r\nif (i < AP_MAX_RESET - 1)\r\nudelay(5);\r\n}\r\nreturn rc;\r\n}\r\nstatic int ap_init_queue(ap_qid_t qid)\r\n{\r\nstruct ap_queue_status status;\r\nint rc, dummy, i;\r\nrc = -ENODEV;\r\nstatus = ap_reset_queue(qid);\r\nfor (i = 0; i < AP_MAX_RESET; i++) {\r\nswitch (status.response_code) {\r\ncase AP_RESPONSE_NORMAL:\r\nif (status.queue_empty)\r\nrc = 0;\r\nbreak;\r\ncase AP_RESPONSE_Q_NOT_AVAIL:\r\ncase AP_RESPONSE_DECONFIGURED:\r\ncase AP_RESPONSE_CHECKSTOPPED:\r\ni = AP_MAX_RESET;\r\nbreak;\r\ncase AP_RESPONSE_RESET_IN_PROGRESS:\r\nrc = -EBUSY;\r\ncase AP_RESPONSE_BUSY:\r\ndefault:\r\nbreak;\r\n}\r\nif (rc != -ENODEV && rc != -EBUSY)\r\nbreak;\r\nif (i < AP_MAX_RESET - 1) {\r\nschedule_timeout(AP_RESET_TIMEOUT);\r\nstatus = ap_test_queue(qid, &dummy, &dummy);\r\n}\r\n}\r\nif (rc == 0 && ap_using_interrupts()) {\r\nrc = ap_queue_enable_interruption(qid, ap_airq.lsi_ptr);\r\nif (rc)\r\npr_err("Registering adapter interrupts for "\r\n"AP %d failed\n", AP_QID_DEVICE(qid));\r\n}\r\nreturn rc;\r\n}\r\nstatic void ap_increase_queue_count(struct ap_device *ap_dev)\r\n{\r\nint timeout = ap_dev->drv->request_timeout;\r\nap_dev->queue_count++;\r\nif (ap_dev->queue_count == 1) {\r\nmod_timer(&ap_dev->timeout, jiffies + timeout);\r\nap_dev->reset = AP_RESET_ARMED;\r\n}\r\n}\r\nstatic void ap_decrease_queue_count(struct ap_device *ap_dev)\r\n{\r\nint timeout = ap_dev->drv->request_timeout;\r\nap_dev->queue_count--;\r\nif (ap_dev->queue_count > 0)\r\nmod_timer(&ap_dev->timeout, jiffies + timeout);\r\nelse\r\nap_dev->reset = AP_RESET_IGNORE;\r\n}\r\nstatic ssize_t ap_hwtype_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ap_dev->device_type);\r\n}\r\nstatic ssize_t ap_depth_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ap_dev->queue_depth);\r\n}\r\nstatic ssize_t ap_request_count_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nint rc;\r\nspin_lock_bh(&ap_dev->lock);\r\nrc = snprintf(buf, PAGE_SIZE, "%d\n", ap_dev->total_request_count);\r\nspin_unlock_bh(&ap_dev->lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t ap_requestq_count_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nint rc;\r\nspin_lock_bh(&ap_dev->lock);\r\nrc = snprintf(buf, PAGE_SIZE, "%d\n", ap_dev->requestq_count);\r\nspin_unlock_bh(&ap_dev->lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t ap_pendingq_count_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nint rc;\r\nspin_lock_bh(&ap_dev->lock);\r\nrc = snprintf(buf, PAGE_SIZE, "%d\n", ap_dev->pendingq_count);\r\nspin_unlock_bh(&ap_dev->lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t ap_modalias_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "ap:t%02X", to_ap_dev(dev)->device_type);\r\n}\r\nstatic ssize_t ap_functions_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "0x%08X\n", ap_dev->functions);\r\n}\r\nstatic int ap_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nstruct ap_driver *ap_drv = to_ap_drv(drv);\r\nstruct ap_device_id *id;\r\nfor (id = ap_drv->ids; id->match_flags; id++) {\r\nif ((id->match_flags & AP_DEVICE_ID_MATCH_DEVICE_TYPE) &&\r\n(id->dev_type != ap_dev->device_type))\r\ncontinue;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ap_uevent (struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nint retval = 0;\r\nif (!ap_dev)\r\nreturn -ENODEV;\r\nretval = add_uevent_var(env, "DEV_TYPE=%04X", ap_dev->device_type);\r\nif (retval)\r\nreturn retval;\r\nretval = add_uevent_var(env, "MODALIAS=ap:t%02X", ap_dev->device_type);\r\nreturn retval;\r\n}\r\nstatic int ap_bus_suspend(struct device *dev, pm_message_t state)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nunsigned long flags;\r\nif (!ap_suspend_flag) {\r\nap_suspend_flag = 1;\r\ndel_timer_sync(&ap_config_timer);\r\nif (ap_work_queue != NULL) {\r\ndestroy_workqueue(ap_work_queue);\r\nap_work_queue = NULL;\r\n}\r\ntasklet_disable(&ap_tasklet);\r\n}\r\ndo {\r\nflags = 0;\r\nspin_lock_bh(&ap_dev->lock);\r\n__ap_poll_device(ap_dev, &flags);\r\nspin_unlock_bh(&ap_dev->lock);\r\n} while ((flags & 1) || (flags & 2));\r\nspin_lock_bh(&ap_dev->lock);\r\nap_dev->unregistered = 1;\r\nspin_unlock_bh(&ap_dev->lock);\r\nreturn 0;\r\n}\r\nstatic int ap_bus_resume(struct device *dev)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nint rc;\r\nif (ap_suspend_flag) {\r\nap_suspend_flag = 0;\r\nif (ap_interrupts_available()) {\r\nif (!ap_using_interrupts()) {\r\nrc = register_adapter_interrupt(&ap_airq);\r\nap_airq_flag = (rc == 0);\r\n}\r\n} else {\r\nif (ap_using_interrupts()) {\r\nunregister_adapter_interrupt(&ap_airq);\r\nap_airq_flag = 0;\r\n}\r\n}\r\nap_query_configuration();\r\nif (!user_set_domain) {\r\nap_domain_index = -1;\r\nap_select_domain();\r\n}\r\ninit_timer(&ap_config_timer);\r\nap_config_timer.function = ap_config_timeout;\r\nap_config_timer.data = 0;\r\nap_config_timer.expires = jiffies + ap_config_time * HZ;\r\nadd_timer(&ap_config_timer);\r\nap_work_queue = create_singlethread_workqueue("kapwork");\r\nif (!ap_work_queue)\r\nreturn -ENOMEM;\r\ntasklet_enable(&ap_tasklet);\r\nif (!ap_using_interrupts())\r\nap_schedule_poll_timer();\r\nelse\r\ntasklet_schedule(&ap_tasklet);\r\nif (ap_thread_flag)\r\nrc = ap_poll_thread_start();\r\nelse\r\nrc = 0;\r\n} else\r\nrc = 0;\r\nif (AP_QID_QUEUE(ap_dev->qid) != ap_domain_index) {\r\nspin_lock_bh(&ap_dev->lock);\r\nap_dev->qid = AP_MKQID(AP_QID_DEVICE(ap_dev->qid),\r\nap_domain_index);\r\nspin_unlock_bh(&ap_dev->lock);\r\n}\r\nqueue_work(ap_work_queue, &ap_config_work);\r\nreturn rc;\r\n}\r\nstatic int ap_device_probe(struct device *dev)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nstruct ap_driver *ap_drv = to_ap_drv(dev->driver);\r\nint rc;\r\nap_dev->drv = ap_drv;\r\nspin_lock_bh(&ap_device_list_lock);\r\nlist_add(&ap_dev->list, &ap_device_list);\r\nspin_unlock_bh(&ap_device_list_lock);\r\nrc = ap_drv->probe ? ap_drv->probe(ap_dev) : -ENODEV;\r\nif (rc) {\r\nspin_lock_bh(&ap_device_list_lock);\r\nlist_del_init(&ap_dev->list);\r\nspin_unlock_bh(&ap_device_list_lock);\r\n}\r\nreturn rc;\r\n}\r\nstatic void __ap_flush_queue(struct ap_device *ap_dev)\r\n{\r\nstruct ap_message *ap_msg, *next;\r\nlist_for_each_entry_safe(ap_msg, next, &ap_dev->pendingq, list) {\r\nlist_del_init(&ap_msg->list);\r\nap_dev->pendingq_count--;\r\nap_msg->receive(ap_dev, ap_msg, ERR_PTR(-ENODEV));\r\n}\r\nlist_for_each_entry_safe(ap_msg, next, &ap_dev->requestq, list) {\r\nlist_del_init(&ap_msg->list);\r\nap_dev->requestq_count--;\r\nap_msg->receive(ap_dev, ap_msg, ERR_PTR(-ENODEV));\r\n}\r\n}\r\nvoid ap_flush_queue(struct ap_device *ap_dev)\r\n{\r\nspin_lock_bh(&ap_dev->lock);\r\n__ap_flush_queue(ap_dev);\r\nspin_unlock_bh(&ap_dev->lock);\r\n}\r\nstatic int ap_device_remove(struct device *dev)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nstruct ap_driver *ap_drv = ap_dev->drv;\r\nap_flush_queue(ap_dev);\r\ndel_timer_sync(&ap_dev->timeout);\r\nspin_lock_bh(&ap_device_list_lock);\r\nlist_del_init(&ap_dev->list);\r\nspin_unlock_bh(&ap_device_list_lock);\r\nif (ap_drv->remove)\r\nap_drv->remove(ap_dev);\r\nspin_lock_bh(&ap_dev->lock);\r\natomic_sub(ap_dev->queue_count, &ap_poll_requests);\r\nspin_unlock_bh(&ap_dev->lock);\r\nreturn 0;\r\n}\r\nint ap_driver_register(struct ap_driver *ap_drv, struct module *owner,\r\nchar *name)\r\n{\r\nstruct device_driver *drv = &ap_drv->driver;\r\ndrv->bus = &ap_bus_type;\r\ndrv->probe = ap_device_probe;\r\ndrv->remove = ap_device_remove;\r\ndrv->owner = owner;\r\ndrv->name = name;\r\nreturn driver_register(drv);\r\n}\r\nvoid ap_driver_unregister(struct ap_driver *ap_drv)\r\n{\r\ndriver_unregister(&ap_drv->driver);\r\n}\r\nvoid ap_bus_force_rescan(void)\r\n{\r\nmod_timer(&ap_config_timer, jiffies + ap_config_time * HZ);\r\nqueue_work(ap_work_queue, &ap_config_work);\r\nflush_work(&ap_config_work);\r\n}\r\nstatic ssize_t ap_domain_show(struct bus_type *bus, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ap_domain_index);\r\n}\r\nstatic ssize_t ap_control_domain_mask_show(struct bus_type *bus, char *buf)\r\n{\r\nif (ap_configuration != NULL) {\r\nif (test_facility(76)) {\r\nreturn snprintf(buf, PAGE_SIZE,\r\n"0x%08x%08x%08x%08x%08x%08x%08x%08x\n",\r\nap_configuration->adm[0], ap_configuration->adm[1],\r\nap_configuration->adm[2], ap_configuration->adm[3],\r\nap_configuration->adm[4], ap_configuration->adm[5],\r\nap_configuration->adm[6], ap_configuration->adm[7]);\r\n} else {\r\nreturn snprintf(buf, PAGE_SIZE, "%08x%08x\n",\r\nap_configuration->adm[0], ap_configuration->adm[1]);\r\n}\r\n} else {\r\nreturn snprintf(buf, PAGE_SIZE, "not supported\n");\r\n}\r\n}\r\nstatic ssize_t ap_config_time_show(struct bus_type *bus, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ap_config_time);\r\n}\r\nstatic ssize_t ap_interrupts_show(struct bus_type *bus, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\nap_using_interrupts() ? 1 : 0);\r\n}\r\nstatic ssize_t ap_config_time_store(struct bus_type *bus,\r\nconst char *buf, size_t count)\r\n{\r\nint time;\r\nif (sscanf(buf, "%d\n", &time) != 1 || time < 5 || time > 120)\r\nreturn -EINVAL;\r\nap_config_time = time;\r\nif (!timer_pending(&ap_config_timer) ||\r\n!mod_timer(&ap_config_timer, jiffies + ap_config_time * HZ)) {\r\nap_config_timer.expires = jiffies + ap_config_time * HZ;\r\nadd_timer(&ap_config_timer);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t ap_poll_thread_show(struct bus_type *bus, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ap_poll_kthread ? 1 : 0);\r\n}\r\nstatic ssize_t ap_poll_thread_store(struct bus_type *bus,\r\nconst char *buf, size_t count)\r\n{\r\nint flag, rc;\r\nif (sscanf(buf, "%d\n", &flag) != 1)\r\nreturn -EINVAL;\r\nif (flag) {\r\nrc = ap_poll_thread_start();\r\nif (rc)\r\nreturn rc;\r\n}\r\nelse\r\nap_poll_thread_stop();\r\nreturn count;\r\n}\r\nstatic ssize_t poll_timeout_show(struct bus_type *bus, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%llu\n", poll_timeout);\r\n}\r\nstatic ssize_t poll_timeout_store(struct bus_type *bus, const char *buf,\r\nsize_t count)\r\n{\r\nunsigned long long time;\r\nktime_t hr_time;\r\nif (sscanf(buf, "%llu\n", &time) != 1 || time < 1 ||\r\ntime > 120000000000ULL)\r\nreturn -EINVAL;\r\npoll_timeout = time;\r\nhr_time = ktime_set(0, poll_timeout);\r\nif (!hrtimer_is_queued(&ap_poll_timer) ||\r\n!hrtimer_forward(&ap_poll_timer, hrtimer_get_expires(&ap_poll_timer), hr_time)) {\r\nhrtimer_set_expires(&ap_poll_timer, hr_time);\r\nhrtimer_start_expires(&ap_poll_timer, HRTIMER_MODE_ABS);\r\n}\r\nreturn count;\r\n}\r\nstatic inline int ap_test_config(unsigned int *field, unsigned int nr)\r\n{\r\nif (nr > 0xFFu)\r\nreturn 0;\r\nreturn ap_test_bit((field + (nr >> 5)), (nr & 0x1f));\r\n}\r\nstatic inline int ap_test_config_card_id(unsigned int id)\r\n{\r\nif (!ap_configuration)\r\nreturn 1;\r\nreturn ap_test_config(ap_configuration->apm, id);\r\n}\r\nstatic inline int ap_test_config_domain(unsigned int domain)\r\n{\r\nif (!ap_configuration)\r\nreturn 1;\r\nreturn ap_test_config(ap_configuration->aqm, domain);\r\n}\r\nstatic void ap_query_configuration(void)\r\n{\r\n#ifdef CONFIG_64BIT\r\nif (ap_configuration_available()) {\r\nif (!ap_configuration)\r\nap_configuration =\r\nkzalloc(sizeof(struct ap_config_info),\r\nGFP_KERNEL);\r\nif (ap_configuration)\r\n__ap_query_configuration(ap_configuration);\r\n} else\r\nap_configuration = NULL;\r\n#else\r\nap_configuration = NULL;\r\n#endif\r\n}\r\nstatic int ap_select_domain(void)\r\n{\r\nint queue_depth, device_type, count, max_count, best_domain;\r\nap_qid_t qid;\r\nint rc, i, j;\r\nif (ap_domain_index >= 0 && ap_domain_index < AP_DOMAINS)\r\nreturn 0;\r\nbest_domain = -1;\r\nmax_count = 0;\r\nfor (i = 0; i < AP_DOMAINS; i++) {\r\nif (!ap_test_config_domain(i))\r\ncontinue;\r\ncount = 0;\r\nfor (j = 0; j < AP_DEVICES; j++) {\r\nif (!ap_test_config_card_id(j))\r\ncontinue;\r\nqid = AP_MKQID(j, i);\r\nrc = ap_query_queue(qid, &queue_depth, &device_type);\r\nif (rc)\r\ncontinue;\r\ncount++;\r\n}\r\nif (count > max_count) {\r\nmax_count = count;\r\nbest_domain = i;\r\n}\r\n}\r\nif (best_domain >= 0){\r\nap_domain_index = best_domain;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int ap_probe_device_type(struct ap_device *ap_dev)\r\n{\r\nstatic unsigned char msg[] = {\r\n0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x58,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x01,0x00,0x43,0x43,0x41,0x2d,0x41,0x50,\r\n0x50,0x4c,0x20,0x20,0x20,0x01,0x01,0x01,\r\n0x00,0x00,0x00,0x00,0x50,0x4b,0x00,0x00,\r\n0x00,0x00,0x01,0x1c,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x05,0xb8,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x70,0x00,0x41,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x54,0x32,0x01,0x00,0xa0,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0xb8,0x05,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x0a,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\r\n0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,\r\n0x49,0x43,0x53,0x46,0x20,0x20,0x20,0x20,\r\n0x50,0x4b,0x0a,0x00,0x50,0x4b,0x43,0x53,\r\n0x2d,0x31,0x2e,0x32,0x37,0x00,0x11,0x22,\r\n0x33,0x44,0x55,0x66,0x77,0x88,0x99,0x00,\r\n0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,\r\n0x99,0x00,0x11,0x22,0x33,0x44,0x55,0x66,\r\n0x77,0x88,0x99,0x00,0x11,0x22,0x33,0x44,\r\n0x55,0x66,0x77,0x88,0x99,0x00,0x11,0x22,\r\n0x33,0x44,0x55,0x66,0x77,0x88,0x99,0x00,\r\n0x11,0x22,0x33,0x5d,0x00,0x5b,0x00,0x77,\r\n0x88,0x1e,0x00,0x00,0x57,0x00,0x00,0x00,\r\n0x00,0x04,0x00,0x00,0x4f,0x00,0x00,0x00,\r\n0x03,0x02,0x00,0x00,0x40,0x01,0x00,0x01,\r\n0xce,0x02,0x68,0x2d,0x5f,0xa9,0xde,0x0c,\r\n0xf6,0xd2,0x7b,0x58,0x4b,0xf9,0x28,0x68,\r\n0x3d,0xb4,0xf4,0xef,0x78,0xd5,0xbe,0x66,\r\n0x63,0x42,0xef,0xf8,0xfd,0xa4,0xf8,0xb0,\r\n0x8e,0x29,0xc2,0xc9,0x2e,0xd8,0x45,0xb8,\r\n0x53,0x8c,0x6f,0x4e,0x72,0x8f,0x6c,0x04,\r\n0x9c,0x88,0xfc,0x1e,0xc5,0x83,0x55,0x57,\r\n0xf7,0xdd,0xfd,0x4f,0x11,0x36,0x95,0x5d,\r\n};\r\nstruct ap_queue_status status;\r\nunsigned long long psmid;\r\nchar *reply;\r\nint rc, i;\r\nreply = (void *) get_zeroed_page(GFP_KERNEL);\r\nif (!reply) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nstatus = __ap_send(ap_dev->qid, 0x0102030405060708ULL,\r\nmsg, sizeof(msg), 0);\r\nif (status.response_code != AP_RESPONSE_NORMAL) {\r\nrc = -ENODEV;\r\ngoto out_free;\r\n}\r\nfor (i = 0; i < 6; i++) {\r\nmdelay(300);\r\nstatus = __ap_recv(ap_dev->qid, &psmid, reply, 4096);\r\nif (status.response_code == AP_RESPONSE_NORMAL &&\r\npsmid == 0x0102030405060708ULL)\r\nbreak;\r\n}\r\nif (i < 6) {\r\nif (reply[0] == 0x00 && reply[1] == 0x86)\r\nap_dev->device_type = AP_DEVICE_TYPE_PCICC;\r\nelse\r\nap_dev->device_type = AP_DEVICE_TYPE_PCICA;\r\nrc = 0;\r\n} else\r\nrc = -ENODEV;\r\nout_free:\r\nfree_page((unsigned long) reply);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void ap_interrupt_handler(struct airq_struct *airq)\r\n{\r\ninc_irq_stat(IRQIO_APB);\r\ntasklet_schedule(&ap_tasklet);\r\n}\r\nstatic int __ap_scan_bus(struct device *dev, void *data)\r\n{\r\nreturn to_ap_dev(dev)->qid == (ap_qid_t)(unsigned long) data;\r\n}\r\nstatic void ap_device_release(struct device *dev)\r\n{\r\nstruct ap_device *ap_dev = to_ap_dev(dev);\r\nkfree(ap_dev);\r\n}\r\nstatic void ap_scan_bus(struct work_struct *unused)\r\n{\r\nstruct ap_device *ap_dev;\r\nstruct device *dev;\r\nap_qid_t qid;\r\nint queue_depth, device_type;\r\nunsigned int device_functions;\r\nint rc, i;\r\nap_query_configuration();\r\nif (ap_select_domain() != 0) {\r\nreturn;\r\n}\r\nfor (i = 0; i < AP_DEVICES; i++) {\r\nqid = AP_MKQID(i, ap_domain_index);\r\ndev = bus_find_device(&ap_bus_type, NULL,\r\n(void *)(unsigned long)qid,\r\n__ap_scan_bus);\r\nif (ap_test_config_card_id(i))\r\nrc = ap_query_queue(qid, &queue_depth, &device_type);\r\nelse\r\nrc = -ENODEV;\r\nif (dev) {\r\nif (rc == -EBUSY) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(AP_RESET_TIMEOUT);\r\nrc = ap_query_queue(qid, &queue_depth,\r\n&device_type);\r\n}\r\nap_dev = to_ap_dev(dev);\r\nspin_lock_bh(&ap_dev->lock);\r\nif (rc || ap_dev->unregistered) {\r\nspin_unlock_bh(&ap_dev->lock);\r\nif (ap_dev->unregistered)\r\ni--;\r\ndevice_unregister(dev);\r\nput_device(dev);\r\ncontinue;\r\n}\r\nspin_unlock_bh(&ap_dev->lock);\r\nput_device(dev);\r\ncontinue;\r\n}\r\nif (rc)\r\ncontinue;\r\nrc = ap_init_queue(qid);\r\nif (rc)\r\ncontinue;\r\nap_dev = kzalloc(sizeof(*ap_dev), GFP_KERNEL);\r\nif (!ap_dev)\r\nbreak;\r\nap_dev->qid = qid;\r\nap_dev->queue_depth = queue_depth;\r\nap_dev->unregistered = 1;\r\nspin_lock_init(&ap_dev->lock);\r\nINIT_LIST_HEAD(&ap_dev->pendingq);\r\nINIT_LIST_HEAD(&ap_dev->requestq);\r\nINIT_LIST_HEAD(&ap_dev->list);\r\nsetup_timer(&ap_dev->timeout, ap_request_timeout,\r\n(unsigned long) ap_dev);\r\nswitch (device_type) {\r\ncase 0:\r\nif (ap_probe_device_type(ap_dev)) {\r\nkfree(ap_dev);\r\ncontinue;\r\n}\r\nbreak;\r\ndefault:\r\nap_dev->device_type = device_type;\r\n}\r\nrc = ap_query_functions(qid, &device_functions);\r\nif (!rc)\r\nap_dev->functions = device_functions;\r\nelse\r\nap_dev->functions = 0u;\r\nap_dev->device.bus = &ap_bus_type;\r\nap_dev->device.parent = ap_root_device;\r\nif (dev_set_name(&ap_dev->device, "card%02x",\r\nAP_QID_DEVICE(ap_dev->qid))) {\r\nkfree(ap_dev);\r\ncontinue;\r\n}\r\nap_dev->device.release = ap_device_release;\r\nrc = device_register(&ap_dev->device);\r\nif (rc) {\r\nput_device(&ap_dev->device);\r\ncontinue;\r\n}\r\nrc = sysfs_create_group(&ap_dev->device.kobj,\r\n&ap_dev_attr_group);\r\nif (!rc) {\r\nspin_lock_bh(&ap_dev->lock);\r\nap_dev->unregistered = 0;\r\nspin_unlock_bh(&ap_dev->lock);\r\n}\r\nelse\r\ndevice_unregister(&ap_dev->device);\r\n}\r\n}\r\nstatic void\r\nap_config_timeout(unsigned long ptr)\r\n{\r\nqueue_work(ap_work_queue, &ap_config_work);\r\nap_config_timer.expires = jiffies + ap_config_time * HZ;\r\nadd_timer(&ap_config_timer);\r\n}\r\nstatic inline void __ap_schedule_poll_timer(void)\r\n{\r\nktime_t hr_time;\r\nspin_lock_bh(&ap_poll_timer_lock);\r\nif (hrtimer_is_queued(&ap_poll_timer) || ap_suspend_flag)\r\ngoto out;\r\nif (ktime_to_ns(hrtimer_expires_remaining(&ap_poll_timer)) <= 0) {\r\nhr_time = ktime_set(0, poll_timeout);\r\nhrtimer_forward_now(&ap_poll_timer, hr_time);\r\nhrtimer_restart(&ap_poll_timer);\r\n}\r\nout:\r\nspin_unlock_bh(&ap_poll_timer_lock);\r\n}\r\nstatic inline void ap_schedule_poll_timer(void)\r\n{\r\nif (ap_using_interrupts())\r\nreturn;\r\n__ap_schedule_poll_timer();\r\n}\r\nstatic int ap_poll_read(struct ap_device *ap_dev, unsigned long *flags)\r\n{\r\nstruct ap_queue_status status;\r\nstruct ap_message *ap_msg;\r\nif (ap_dev->queue_count <= 0)\r\nreturn 0;\r\nstatus = __ap_recv(ap_dev->qid, &ap_dev->reply->psmid,\r\nap_dev->reply->message, ap_dev->reply->length);\r\nswitch (status.response_code) {\r\ncase AP_RESPONSE_NORMAL:\r\natomic_dec(&ap_poll_requests);\r\nap_decrease_queue_count(ap_dev);\r\nlist_for_each_entry(ap_msg, &ap_dev->pendingq, list) {\r\nif (ap_msg->psmid != ap_dev->reply->psmid)\r\ncontinue;\r\nlist_del_init(&ap_msg->list);\r\nap_dev->pendingq_count--;\r\nap_msg->receive(ap_dev, ap_msg, ap_dev->reply);\r\nbreak;\r\n}\r\nif (ap_dev->queue_count > 0)\r\n*flags |= 1;\r\nbreak;\r\ncase AP_RESPONSE_NO_PENDING_REPLY:\r\nif (status.queue_empty) {\r\natomic_sub(ap_dev->queue_count, &ap_poll_requests);\r\nap_dev->queue_count = 0;\r\nlist_splice_init(&ap_dev->pendingq, &ap_dev->requestq);\r\nap_dev->requestq_count += ap_dev->pendingq_count;\r\nap_dev->pendingq_count = 0;\r\n} else\r\n*flags |= 2;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ap_poll_write(struct ap_device *ap_dev, unsigned long *flags)\r\n{\r\nstruct ap_queue_status status;\r\nstruct ap_message *ap_msg;\r\nif (ap_dev->requestq_count <= 0 ||\r\nap_dev->queue_count >= ap_dev->queue_depth)\r\nreturn 0;\r\nap_msg = list_entry(ap_dev->requestq.next, struct ap_message, list);\r\nstatus = __ap_send(ap_dev->qid, ap_msg->psmid,\r\nap_msg->message, ap_msg->length, ap_msg->special);\r\nswitch (status.response_code) {\r\ncase AP_RESPONSE_NORMAL:\r\natomic_inc(&ap_poll_requests);\r\nap_increase_queue_count(ap_dev);\r\nlist_move_tail(&ap_msg->list, &ap_dev->pendingq);\r\nap_dev->requestq_count--;\r\nap_dev->pendingq_count++;\r\nif (ap_dev->queue_count < ap_dev->queue_depth &&\r\nap_dev->requestq_count > 0)\r\n*flags |= 1;\r\n*flags |= 2;\r\nbreak;\r\ncase AP_RESPONSE_RESET_IN_PROGRESS:\r\n__ap_schedule_poll_timer();\r\ncase AP_RESPONSE_Q_FULL:\r\n*flags |= 2;\r\nbreak;\r\ncase AP_RESPONSE_MESSAGE_TOO_BIG:\r\ncase AP_RESPONSE_REQ_FAC_NOT_INST:\r\nreturn -EINVAL;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int ap_poll_queue(struct ap_device *ap_dev, unsigned long *flags)\r\n{\r\nint rc;\r\nrc = ap_poll_read(ap_dev, flags);\r\nif (rc)\r\nreturn rc;\r\nreturn ap_poll_write(ap_dev, flags);\r\n}\r\nstatic int __ap_queue_message(struct ap_device *ap_dev, struct ap_message *ap_msg)\r\n{\r\nstruct ap_queue_status status;\r\nif (list_empty(&ap_dev->requestq) &&\r\nap_dev->queue_count < ap_dev->queue_depth) {\r\nstatus = __ap_send(ap_dev->qid, ap_msg->psmid,\r\nap_msg->message, ap_msg->length,\r\nap_msg->special);\r\nswitch (status.response_code) {\r\ncase AP_RESPONSE_NORMAL:\r\nlist_add_tail(&ap_msg->list, &ap_dev->pendingq);\r\natomic_inc(&ap_poll_requests);\r\nap_dev->pendingq_count++;\r\nap_increase_queue_count(ap_dev);\r\nap_dev->total_request_count++;\r\nbreak;\r\ncase AP_RESPONSE_Q_FULL:\r\ncase AP_RESPONSE_RESET_IN_PROGRESS:\r\nlist_add_tail(&ap_msg->list, &ap_dev->requestq);\r\nap_dev->requestq_count++;\r\nap_dev->total_request_count++;\r\nreturn -EBUSY;\r\ncase AP_RESPONSE_REQ_FAC_NOT_INST:\r\ncase AP_RESPONSE_MESSAGE_TOO_BIG:\r\nap_msg->receive(ap_dev, ap_msg, ERR_PTR(-EINVAL));\r\nreturn -EINVAL;\r\ndefault:\r\nap_msg->receive(ap_dev, ap_msg, ERR_PTR(-ENODEV));\r\nreturn -ENODEV;\r\n}\r\n} else {\r\nlist_add_tail(&ap_msg->list, &ap_dev->requestq);\r\nap_dev->requestq_count++;\r\nap_dev->total_request_count++;\r\nreturn -EBUSY;\r\n}\r\nap_schedule_poll_timer();\r\nreturn 0;\r\n}\r\nvoid ap_queue_message(struct ap_device *ap_dev, struct ap_message *ap_msg)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nBUG_ON(!ap_msg->receive);\r\nspin_lock_bh(&ap_dev->lock);\r\nif (!ap_dev->unregistered) {\r\nrc = ap_poll_queue(ap_dev, &flags);\r\nif (!rc)\r\nrc = __ap_queue_message(ap_dev, ap_msg);\r\nif (!rc)\r\nwake_up(&ap_poll_wait);\r\nif (rc == -ENODEV)\r\nap_dev->unregistered = 1;\r\n} else {\r\nap_msg->receive(ap_dev, ap_msg, ERR_PTR(-ENODEV));\r\nrc = -ENODEV;\r\n}\r\nspin_unlock_bh(&ap_dev->lock);\r\nif (rc == -ENODEV)\r\ndevice_unregister(&ap_dev->device);\r\n}\r\nvoid ap_cancel_message(struct ap_device *ap_dev, struct ap_message *ap_msg)\r\n{\r\nstruct ap_message *tmp;\r\nspin_lock_bh(&ap_dev->lock);\r\nif (!list_empty(&ap_msg->list)) {\r\nlist_for_each_entry(tmp, &ap_dev->pendingq, list)\r\nif (tmp->psmid == ap_msg->psmid) {\r\nap_dev->pendingq_count--;\r\ngoto found;\r\n}\r\nap_dev->requestq_count--;\r\nfound:\r\nlist_del_init(&ap_msg->list);\r\n}\r\nspin_unlock_bh(&ap_dev->lock);\r\n}\r\nstatic enum hrtimer_restart ap_poll_timeout(struct hrtimer *unused)\r\n{\r\ntasklet_schedule(&ap_tasklet);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic void ap_reset(struct ap_device *ap_dev)\r\n{\r\nint rc;\r\nap_dev->reset = AP_RESET_IGNORE;\r\natomic_sub(ap_dev->queue_count, &ap_poll_requests);\r\nap_dev->queue_count = 0;\r\nlist_splice_init(&ap_dev->pendingq, &ap_dev->requestq);\r\nap_dev->requestq_count += ap_dev->pendingq_count;\r\nap_dev->pendingq_count = 0;\r\nrc = ap_init_queue(ap_dev->qid);\r\nif (rc == -ENODEV)\r\nap_dev->unregistered = 1;\r\nelse\r\n__ap_schedule_poll_timer();\r\n}\r\nstatic int __ap_poll_device(struct ap_device *ap_dev, unsigned long *flags)\r\n{\r\nif (!ap_dev->unregistered) {\r\nif (ap_poll_queue(ap_dev, flags))\r\nap_dev->unregistered = 1;\r\nif (ap_dev->reset == AP_RESET_DO)\r\nap_reset(ap_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ap_poll_all(unsigned long dummy)\r\n{\r\nunsigned long flags;\r\nstruct ap_device *ap_dev;\r\nif (ap_using_interrupts())\r\nxchg(ap_airq.lsi_ptr, 0);\r\ndo {\r\nflags = 0;\r\nspin_lock(&ap_device_list_lock);\r\nlist_for_each_entry(ap_dev, &ap_device_list, list) {\r\nspin_lock(&ap_dev->lock);\r\n__ap_poll_device(ap_dev, &flags);\r\nspin_unlock(&ap_dev->lock);\r\n}\r\nspin_unlock(&ap_device_list_lock);\r\n} while (flags & 1);\r\nif (flags & 2)\r\nap_schedule_poll_timer();\r\n}\r\nstatic int ap_poll_thread(void *data)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nunsigned long flags;\r\nint requests;\r\nstruct ap_device *ap_dev;\r\nset_user_nice(current, MAX_NICE);\r\nwhile (1) {\r\nif (ap_suspend_flag)\r\nreturn 0;\r\nif (need_resched()) {\r\nschedule();\r\ncontinue;\r\n}\r\nadd_wait_queue(&ap_poll_wait, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (kthread_should_stop())\r\nbreak;\r\nrequests = atomic_read(&ap_poll_requests);\r\nif (requests <= 0)\r\nschedule();\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&ap_poll_wait, &wait);\r\nflags = 0;\r\nspin_lock_bh(&ap_device_list_lock);\r\nlist_for_each_entry(ap_dev, &ap_device_list, list) {\r\nspin_lock(&ap_dev->lock);\r\n__ap_poll_device(ap_dev, &flags);\r\nspin_unlock(&ap_dev->lock);\r\n}\r\nspin_unlock_bh(&ap_device_list_lock);\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&ap_poll_wait, &wait);\r\nreturn 0;\r\n}\r\nstatic int ap_poll_thread_start(void)\r\n{\r\nint rc;\r\nif (ap_using_interrupts() || ap_suspend_flag)\r\nreturn 0;\r\nmutex_lock(&ap_poll_thread_mutex);\r\nif (!ap_poll_kthread) {\r\nap_poll_kthread = kthread_run(ap_poll_thread, NULL, "appoll");\r\nrc = PTR_RET(ap_poll_kthread);\r\nif (rc)\r\nap_poll_kthread = NULL;\r\n}\r\nelse\r\nrc = 0;\r\nmutex_unlock(&ap_poll_thread_mutex);\r\nreturn rc;\r\n}\r\nstatic void ap_poll_thread_stop(void)\r\n{\r\nmutex_lock(&ap_poll_thread_mutex);\r\nif (ap_poll_kthread) {\r\nkthread_stop(ap_poll_kthread);\r\nap_poll_kthread = NULL;\r\n}\r\nmutex_unlock(&ap_poll_thread_mutex);\r\n}\r\nstatic void ap_request_timeout(unsigned long data)\r\n{\r\nstruct ap_device *ap_dev = (struct ap_device *) data;\r\nif (ap_dev->reset == AP_RESET_ARMED) {\r\nap_dev->reset = AP_RESET_DO;\r\nif (ap_using_interrupts())\r\ntasklet_schedule(&ap_tasklet);\r\n}\r\n}\r\nstatic void ap_reset_domain(void)\r\n{\r\nint i;\r\nif (ap_domain_index != -1)\r\nfor (i = 0; i < AP_DEVICES; i++)\r\nap_reset_queue(AP_MKQID(i, ap_domain_index));\r\n}\r\nstatic void ap_reset_all(void)\r\n{\r\nint i, j;\r\nfor (i = 0; i < AP_DOMAINS; i++)\r\nfor (j = 0; j < AP_DEVICES; j++)\r\nap_reset_queue(AP_MKQID(j, i));\r\n}\r\nint __init ap_module_init(void)\r\n{\r\nint rc, i;\r\nif (ap_domain_index < -1 || ap_domain_index >= AP_DOMAINS) {\r\npr_warning("%d is not a valid cryptographic domain\n",\r\nap_domain_index);\r\nreturn -EINVAL;\r\n}\r\nif (ap_domain_index >= 0)\r\nuser_set_domain = 1;\r\nif (ap_instructions_available() != 0) {\r\npr_warning("The hardware system does not support "\r\n"AP instructions\n");\r\nreturn -ENODEV;\r\n}\r\nif (ap_interrupts_available()) {\r\nrc = register_adapter_interrupt(&ap_airq);\r\nap_airq_flag = (rc == 0);\r\n}\r\nregister_reset_call(&ap_reset_call);\r\nrc = bus_register(&ap_bus_type);\r\nif (rc)\r\ngoto out;\r\nfor (i = 0; ap_bus_attrs[i]; i++) {\r\nrc = bus_create_file(&ap_bus_type, ap_bus_attrs[i]);\r\nif (rc)\r\ngoto out_bus;\r\n}\r\nap_root_device = root_device_register("ap");\r\nrc = PTR_RET(ap_root_device);\r\nif (rc)\r\ngoto out_bus;\r\nap_work_queue = create_singlethread_workqueue("kapwork");\r\nif (!ap_work_queue) {\r\nrc = -ENOMEM;\r\ngoto out_root;\r\n}\r\nap_query_configuration();\r\nif (ap_select_domain() == 0)\r\nap_scan_bus(NULL);\r\ninit_timer(&ap_config_timer);\r\nap_config_timer.function = ap_config_timeout;\r\nap_config_timer.data = 0;\r\nap_config_timer.expires = jiffies + ap_config_time * HZ;\r\nadd_timer(&ap_config_timer);\r\nif (MACHINE_IS_VM)\r\npoll_timeout = 1500000;\r\nspin_lock_init(&ap_poll_timer_lock);\r\nhrtimer_init(&ap_poll_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\r\nap_poll_timer.function = ap_poll_timeout;\r\nif (ap_thread_flag) {\r\nrc = ap_poll_thread_start();\r\nif (rc)\r\ngoto out_work;\r\n}\r\nreturn 0;\r\nout_work:\r\ndel_timer_sync(&ap_config_timer);\r\nhrtimer_cancel(&ap_poll_timer);\r\ndestroy_workqueue(ap_work_queue);\r\nout_root:\r\nroot_device_unregister(ap_root_device);\r\nout_bus:\r\nwhile (i--)\r\nbus_remove_file(&ap_bus_type, ap_bus_attrs[i]);\r\nbus_unregister(&ap_bus_type);\r\nout:\r\nunregister_reset_call(&ap_reset_call);\r\nif (ap_using_interrupts())\r\nunregister_adapter_interrupt(&ap_airq);\r\nreturn rc;\r\n}\r\nstatic int __ap_match_all(struct device *dev, void *data)\r\n{\r\nreturn 1;\r\n}\r\nvoid ap_module_exit(void)\r\n{\r\nint i;\r\nstruct device *dev;\r\nap_reset_domain();\r\nap_poll_thread_stop();\r\ndel_timer_sync(&ap_config_timer);\r\nhrtimer_cancel(&ap_poll_timer);\r\ndestroy_workqueue(ap_work_queue);\r\ntasklet_kill(&ap_tasklet);\r\nroot_device_unregister(ap_root_device);\r\nwhile ((dev = bus_find_device(&ap_bus_type, NULL, NULL,\r\n__ap_match_all)))\r\n{\r\ndevice_unregister(dev);\r\nput_device(dev);\r\n}\r\nfor (i = 0; ap_bus_attrs[i]; i++)\r\nbus_remove_file(&ap_bus_type, ap_bus_attrs[i]);\r\nbus_unregister(&ap_bus_type);\r\nunregister_reset_call(&ap_reset_call);\r\nif (ap_using_interrupts())\r\nunregister_adapter_interrupt(&ap_airq);\r\n}
