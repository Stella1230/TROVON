static struct mx2_buffer *mx2_ibuf_to_buf(struct mx2_buf_internal *int_buf)\r\n{\r\nreturn container_of(int_buf, struct mx2_buffer, internal);\r\n}\r\nstatic struct mx2_fmt_cfg *mx27_emma_prp_get_format(\r\nenum v4l2_mbus_pixelcode in_fmt,\r\nu32 out_fmt)\r\n{\r\nint i;\r\nfor (i = 1; i < ARRAY_SIZE(mx27_emma_prp_table); i++)\r\nif ((mx27_emma_prp_table[i].in_fmt == in_fmt) &&\r\n(mx27_emma_prp_table[i].out_fmt == out_fmt)) {\r\nreturn &mx27_emma_prp_table[i];\r\n}\r\nreturn &mx27_emma_prp_table[0];\r\n}\r\nstatic void mx27_update_emma_buf(struct mx2_camera_dev *pcdev,\r\nunsigned long phys, int bufnum)\r\n{\r\nstruct mx2_fmt_cfg *prp = pcdev->emma_prp;\r\nif (prp->cfg.channel == 1) {\r\nwritel(phys, pcdev->base_emma +\r\nPRP_DEST_RGB1_PTR + 4 * bufnum);\r\n} else {\r\nwritel(phys, pcdev->base_emma +\r\nPRP_DEST_Y_PTR - 0x14 * bufnum);\r\nif (prp->out_fmt == V4L2_PIX_FMT_YUV420) {\r\nu32 imgsize = pcdev->soc_host.icd->user_height *\r\npcdev->soc_host.icd->user_width;\r\nwritel(phys + imgsize, pcdev->base_emma +\r\nPRP_DEST_CB_PTR - 0x14 * bufnum);\r\nwritel(phys + ((5 * imgsize) / 4), pcdev->base_emma +\r\nPRP_DEST_CR_PTR - 0x14 * bufnum);\r\n}\r\n}\r\n}\r\nstatic void mx2_camera_deactivate(struct mx2_camera_dev *pcdev)\r\n{\r\nclk_disable_unprepare(pcdev->clk_csi_ahb);\r\nclk_disable_unprepare(pcdev->clk_csi_per);\r\nwritel(0, pcdev->base_csi + CSICR1);\r\nwritel(0, pcdev->base_emma + PRP_CNTL);\r\n}\r\nstatic int mx2_camera_add_device(struct soc_camera_device *icd)\r\n{\r\ndev_info(icd->parent, "Camera driver attached to camera %d\n",\r\nicd->devnum);\r\nreturn 0;\r\n}\r\nstatic void mx2_camera_remove_device(struct soc_camera_device *icd)\r\n{\r\ndev_info(icd->parent, "Camera driver detached from camera %d\n",\r\nicd->devnum);\r\n}\r\nstatic int mx2_camera_clock_start(struct soc_camera_host *ici)\r\n{\r\nstruct mx2_camera_dev *pcdev = ici->priv;\r\nint ret;\r\nu32 csicr1;\r\nret = clk_prepare_enable(pcdev->clk_csi_ahb);\r\nif (ret < 0)\r\nreturn ret;\r\nret = clk_prepare_enable(pcdev->clk_csi_per);\r\nif (ret < 0)\r\ngoto exit_csi_ahb;\r\ncsicr1 = CSICR1_MCLKEN | CSICR1_PRP_IF_EN | CSICR1_FCC |\r\nCSICR1_RXFF_LEVEL(0);\r\npcdev->csicr1 = csicr1;\r\nwritel(pcdev->csicr1, pcdev->base_csi + CSICR1);\r\npcdev->frame_count = 0;\r\nreturn 0;\r\nexit_csi_ahb:\r\nclk_disable_unprepare(pcdev->clk_csi_ahb);\r\nreturn ret;\r\n}\r\nstatic void mx2_camera_clock_stop(struct soc_camera_host *ici)\r\n{\r\nstruct mx2_camera_dev *pcdev = ici->priv;\r\nmx2_camera_deactivate(pcdev);\r\n}\r\nstatic int mx2_videobuf_setup(struct vb2_queue *vq,\r\nconst struct v4l2_format *fmt,\r\nunsigned int *count, unsigned int *num_planes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(vq);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct mx2_camera_dev *pcdev = ici->priv;\r\ndev_dbg(icd->parent, "count=%d, size=%d\n", *count, sizes[0]);\r\nif (fmt != NULL)\r\nreturn -ENOTTY;\r\nalloc_ctxs[0] = pcdev->alloc_ctx;\r\nsizes[0] = icd->sizeimage;\r\nif (0 == *count)\r\n*count = 32;\r\nif (!*num_planes &&\r\nsizes[0] * *count > MAX_VIDEO_MEM * 1024 * 1024)\r\n*count = (MAX_VIDEO_MEM * 1024 * 1024) / sizes[0];\r\n*num_planes = 1;\r\nreturn 0;\r\n}\r\nstatic int mx2_videobuf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);\r\nint ret = 0;\r\ndev_dbg(icd->parent, "%s (vb=0x%p) 0x%p %lu\n", __func__,\r\nvb, vb2_plane_vaddr(vb, 0), vb2_get_plane_payload(vb, 0));\r\n#ifdef DEBUG\r\nmemset((void *)vb2_plane_vaddr(vb, 0),\r\n0xaa, vb2_get_plane_payload(vb, 0));\r\n#endif\r\nvb2_set_plane_payload(vb, 0, icd->sizeimage);\r\nif (vb2_plane_vaddr(vb, 0) &&\r\nvb2_get_plane_payload(vb, 0) > vb2_plane_size(vb, 0)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nreturn 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic void mx2_videobuf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(vb->vb2_queue);\r\nstruct soc_camera_host *ici =\r\nto_soc_camera_host(icd->parent);\r\nstruct mx2_camera_dev *pcdev = ici->priv;\r\nstruct mx2_buffer *buf = container_of(vb, struct mx2_buffer, vb);\r\nunsigned long flags;\r\ndev_dbg(icd->parent, "%s (vb=0x%p) 0x%p %lu\n", __func__,\r\nvb, vb2_plane_vaddr(vb, 0), vb2_get_plane_payload(vb, 0));\r\nspin_lock_irqsave(&pcdev->lock, flags);\r\nlist_add_tail(&buf->internal.queue, &pcdev->capture);\r\nspin_unlock_irqrestore(&pcdev->lock, flags);\r\n}\r\nstatic void mx27_camera_emma_buf_init(struct soc_camera_device *icd,\r\nint bytesperline)\r\n{\r\nstruct soc_camera_host *ici =\r\nto_soc_camera_host(icd->parent);\r\nstruct mx2_camera_dev *pcdev = ici->priv;\r\nstruct mx2_fmt_cfg *prp = pcdev->emma_prp;\r\nwritel((pcdev->s_width << 16) | pcdev->s_height,\r\npcdev->base_emma + PRP_SRC_FRAME_SIZE);\r\nwritel(prp->cfg.src_pixel,\r\npcdev->base_emma + PRP_SRC_PIXEL_FORMAT_CNTL);\r\nif (prp->cfg.channel == 1) {\r\nwritel((icd->user_width << 16) | icd->user_height,\r\npcdev->base_emma + PRP_CH1_OUT_IMAGE_SIZE);\r\nwritel(bytesperline,\r\npcdev->base_emma + PRP_DEST_CH1_LINE_STRIDE);\r\nwritel(prp->cfg.ch1_pixel,\r\npcdev->base_emma + PRP_CH1_PIXEL_FORMAT_CNTL);\r\n} else {\r\nwritel((icd->user_width << 16) | icd->user_height,\r\npcdev->base_emma + PRP_CH2_OUT_IMAGE_SIZE);\r\n}\r\nwritel(prp->cfg.irq_flags, pcdev->base_emma + PRP_INTR_CNTL);\r\n}\r\nstatic void mx2_prp_resize_commit(struct mx2_camera_dev *pcdev)\r\n{\r\nint dir;\r\nfor (dir = RESIZE_DIR_H; dir <= RESIZE_DIR_V; dir++) {\r\nunsigned char *s = pcdev->resizing[dir].s;\r\nint len = pcdev->resizing[dir].len;\r\nunsigned int coeff[2] = {0, 0};\r\nunsigned int valid = 0;\r\nint i;\r\nif (len == 0)\r\ncontinue;\r\nfor (i = RESIZE_NUM_MAX - 1; i >= 0; i--) {\r\nint j;\r\nj = i > 9 ? 1 : 0;\r\ncoeff[j] = (coeff[j] << BC_COEF) |\r\n(s[i] & (SZ_COEF - 1));\r\nif (i == 5 || i == 15)\r\ncoeff[j] <<= 1;\r\nvalid = (valid << 1) | (s[i] >> BC_COEF);\r\n}\r\nvalid |= PRP_RZ_VALID_TBL_LEN(len);\r\nif (pcdev->resizing[dir].algo == RESIZE_ALGO_BILINEAR)\r\nvalid |= PRP_RZ_VALID_BILINEAR;\r\nif (pcdev->emma_prp->cfg.channel == 1) {\r\nif (dir == RESIZE_DIR_H) {\r\nwritel(coeff[0], pcdev->base_emma +\r\nPRP_CH1_RZ_HORI_COEF1);\r\nwritel(coeff[1], pcdev->base_emma +\r\nPRP_CH1_RZ_HORI_COEF2);\r\nwritel(valid, pcdev->base_emma +\r\nPRP_CH1_RZ_HORI_VALID);\r\n} else {\r\nwritel(coeff[0], pcdev->base_emma +\r\nPRP_CH1_RZ_VERT_COEF1);\r\nwritel(coeff[1], pcdev->base_emma +\r\nPRP_CH1_RZ_VERT_COEF2);\r\nwritel(valid, pcdev->base_emma +\r\nPRP_CH1_RZ_VERT_VALID);\r\n}\r\n} else {\r\nif (dir == RESIZE_DIR_H) {\r\nwritel(coeff[0], pcdev->base_emma +\r\nPRP_CH2_RZ_HORI_COEF1);\r\nwritel(coeff[1], pcdev->base_emma +\r\nPRP_CH2_RZ_HORI_COEF2);\r\nwritel(valid, pcdev->base_emma +\r\nPRP_CH2_RZ_HORI_VALID);\r\n} else {\r\nwritel(coeff[0], pcdev->base_emma +\r\nPRP_CH2_RZ_VERT_COEF1);\r\nwritel(coeff[1], pcdev->base_emma +\r\nPRP_CH2_RZ_VERT_COEF2);\r\nwritel(valid, pcdev->base_emma +\r\nPRP_CH2_RZ_VERT_VALID);\r\n}\r\n}\r\n}\r\n}\r\nstatic int mx2_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(q);\r\nstruct soc_camera_host *ici =\r\nto_soc_camera_host(icd->parent);\r\nstruct mx2_camera_dev *pcdev = ici->priv;\r\nstruct mx2_fmt_cfg *prp = pcdev->emma_prp;\r\nstruct vb2_buffer *vb;\r\nstruct mx2_buffer *buf;\r\nunsigned long phys;\r\nint bytesperline;\r\nunsigned long flags;\r\nif (count < 2)\r\nreturn -ENOBUFS;\r\nspin_lock_irqsave(&pcdev->lock, flags);\r\nbuf = list_first_entry(&pcdev->capture, struct mx2_buffer,\r\ninternal.queue);\r\nbuf->internal.bufnum = 0;\r\nvb = &buf->vb;\r\nphys = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nmx27_update_emma_buf(pcdev, phys, buf->internal.bufnum);\r\nlist_move_tail(pcdev->capture.next, &pcdev->active_bufs);\r\nbuf = list_first_entry(&pcdev->capture, struct mx2_buffer,\r\ninternal.queue);\r\nbuf->internal.bufnum = 1;\r\nvb = &buf->vb;\r\nphys = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nmx27_update_emma_buf(pcdev, phys, buf->internal.bufnum);\r\nlist_move_tail(pcdev->capture.next, &pcdev->active_bufs);\r\nbytesperline = soc_mbus_bytes_per_line(icd->user_width,\r\nicd->current_fmt->host_fmt);\r\nif (bytesperline < 0) {\r\nspin_unlock_irqrestore(&pcdev->lock, flags);\r\nreturn bytesperline;\r\n}\r\npcdev->discard_size = icd->user_height * bytesperline;\r\npcdev->discard_buffer = dma_alloc_coherent(ici->v4l2_dev.dev,\r\npcdev->discard_size,\r\n&pcdev->discard_buffer_dma, GFP_ATOMIC);\r\nif (!pcdev->discard_buffer) {\r\nspin_unlock_irqrestore(&pcdev->lock, flags);\r\nreturn -ENOMEM;\r\n}\r\npcdev->buf_discard[0].discard = true;\r\nlist_add_tail(&pcdev->buf_discard[0].queue,\r\n&pcdev->discard);\r\npcdev->buf_discard[1].discard = true;\r\nlist_add_tail(&pcdev->buf_discard[1].queue,\r\n&pcdev->discard);\r\nmx2_prp_resize_commit(pcdev);\r\nmx27_camera_emma_buf_init(icd, bytesperline);\r\nif (prp->cfg.channel == 1) {\r\nwritel(PRP_CNTL_CH1EN |\r\nPRP_CNTL_CSIEN |\r\nprp->cfg.in_fmt |\r\nprp->cfg.out_fmt |\r\nPRP_CNTL_CH1_LEN |\r\nPRP_CNTL_CH1BYP |\r\nPRP_CNTL_CH1_TSKIP(0) |\r\nPRP_CNTL_IN_TSKIP(0),\r\npcdev->base_emma + PRP_CNTL);\r\n} else {\r\nwritel(PRP_CNTL_CH2EN |\r\nPRP_CNTL_CSIEN |\r\nprp->cfg.in_fmt |\r\nprp->cfg.out_fmt |\r\nPRP_CNTL_CH2_LEN |\r\nPRP_CNTL_CH2_TSKIP(0) |\r\nPRP_CNTL_IN_TSKIP(0),\r\npcdev->base_emma + PRP_CNTL);\r\n}\r\nspin_unlock_irqrestore(&pcdev->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void mx2_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct soc_camera_device *icd = soc_camera_from_vb2q(q);\r\nstruct soc_camera_host *ici =\r\nto_soc_camera_host(icd->parent);\r\nstruct mx2_camera_dev *pcdev = ici->priv;\r\nstruct mx2_fmt_cfg *prp = pcdev->emma_prp;\r\nunsigned long flags;\r\nvoid *b;\r\nu32 cntl;\r\nspin_lock_irqsave(&pcdev->lock, flags);\r\ncntl = readl(pcdev->base_emma + PRP_CNTL);\r\nif (prp->cfg.channel == 1) {\r\nwritel(cntl & ~PRP_CNTL_CH1EN,\r\npcdev->base_emma + PRP_CNTL);\r\n} else {\r\nwritel(cntl & ~PRP_CNTL_CH2EN,\r\npcdev->base_emma + PRP_CNTL);\r\n}\r\nINIT_LIST_HEAD(&pcdev->capture);\r\nINIT_LIST_HEAD(&pcdev->active_bufs);\r\nINIT_LIST_HEAD(&pcdev->discard);\r\nb = pcdev->discard_buffer;\r\npcdev->discard_buffer = NULL;\r\nspin_unlock_irqrestore(&pcdev->lock, flags);\r\ndma_free_coherent(ici->v4l2_dev.dev,\r\npcdev->discard_size, b, pcdev->discard_buffer_dma);\r\n}\r\nstatic int mx2_camera_init_videobuf(struct vb2_queue *q,\r\nstruct soc_camera_device *icd)\r\n{\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR;\r\nq->drv_priv = icd;\r\nq->ops = &mx2_videobuf_ops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->buf_struct_size = sizeof(struct mx2_buffer);\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nreturn vb2_queue_init(q);\r\n}\r\nstatic int mx27_camera_emma_prp_reset(struct mx2_camera_dev *pcdev)\r\n{\r\nu32 cntl;\r\nint count = 0;\r\ncntl = readl(pcdev->base_emma + PRP_CNTL);\r\nwritel(PRP_CNTL_SWRST, pcdev->base_emma + PRP_CNTL);\r\nwhile (count++ < 100) {\r\nif (!(readl(pcdev->base_emma + PRP_CNTL) & PRP_CNTL_SWRST))\r\nreturn 0;\r\nbarrier();\r\nudelay(1);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int mx2_camera_set_bus_param(struct soc_camera_device *icd)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct mx2_camera_dev *pcdev = ici->priv;\r\nstruct v4l2_mbus_config cfg = {.type = V4L2_MBUS_PARALLEL,};\r\nunsigned long common_flags;\r\nint ret;\r\nint bytesperline;\r\nu32 csicr1 = pcdev->csicr1;\r\nret = v4l2_subdev_call(sd, video, g_mbus_config, &cfg);\r\nif (!ret) {\r\ncommon_flags = soc_mbus_config_compatible(&cfg, MX2_BUS_FLAGS);\r\nif (!common_flags) {\r\ndev_warn(icd->parent,\r\n"Flags incompatible: camera 0x%x, host 0x%x\n",\r\ncfg.flags, MX2_BUS_FLAGS);\r\nreturn -EINVAL;\r\n}\r\n} else if (ret != -ENOIOCTLCMD) {\r\nreturn ret;\r\n} else {\r\ncommon_flags = MX2_BUS_FLAGS;\r\n}\r\nif ((common_flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH) &&\r\n(common_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)) {\r\nif (pcdev->platform_flags & MX2_CAMERA_HSYNC_HIGH)\r\ncommon_flags &= ~V4L2_MBUS_HSYNC_ACTIVE_LOW;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_HSYNC_ACTIVE_HIGH;\r\n}\r\nif ((common_flags & V4L2_MBUS_PCLK_SAMPLE_RISING) &&\r\n(common_flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)) {\r\nif (pcdev->platform_flags & MX2_CAMERA_PCLK_SAMPLE_RISING)\r\ncommon_flags &= ~V4L2_MBUS_PCLK_SAMPLE_FALLING;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_PCLK_SAMPLE_RISING;\r\n}\r\ncfg.flags = common_flags;\r\nret = v4l2_subdev_call(sd, video, s_mbus_config, &cfg);\r\nif (ret < 0 && ret != -ENOIOCTLCMD) {\r\ndev_dbg(icd->parent, "camera s_mbus_config(0x%lx) returned %d\n",\r\ncommon_flags, ret);\r\nreturn ret;\r\n}\r\ncsicr1 = (csicr1 & ~CSICR1_FMT_MASK) | pcdev->emma_prp->cfg.csicr1;\r\nif (common_flags & V4L2_MBUS_PCLK_SAMPLE_RISING)\r\ncsicr1 |= CSICR1_REDGE;\r\nif (common_flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)\r\ncsicr1 |= CSICR1_SOF_POL;\r\nif (common_flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)\r\ncsicr1 |= CSICR1_HSYNC_POL;\r\nif (pcdev->platform_flags & MX2_CAMERA_EXT_VSYNC)\r\ncsicr1 |= CSICR1_EXT_VSYNC;\r\nif (pcdev->platform_flags & MX2_CAMERA_CCIR)\r\ncsicr1 |= CSICR1_CCIR_EN;\r\nif (pcdev->platform_flags & MX2_CAMERA_CCIR_INTERLACE)\r\ncsicr1 |= CSICR1_CCIR_MODE;\r\nif (pcdev->platform_flags & MX2_CAMERA_GATED_CLOCK)\r\ncsicr1 |= CSICR1_GCLK_MODE;\r\nif (pcdev->platform_flags & MX2_CAMERA_INV_DATA)\r\ncsicr1 |= CSICR1_INV_DATA;\r\npcdev->csicr1 = csicr1;\r\nbytesperline = soc_mbus_bytes_per_line(icd->user_width,\r\nicd->current_fmt->host_fmt);\r\nif (bytesperline < 0)\r\nreturn bytesperline;\r\nret = mx27_camera_emma_prp_reset(pcdev);\r\nif (ret)\r\nreturn ret;\r\nwritel(pcdev->csicr1, pcdev->base_csi + CSICR1);\r\nreturn 0;\r\n}\r\nstatic int mx2_camera_set_crop(struct soc_camera_device *icd,\r\nconst struct v4l2_crop *a)\r\n{\r\nstruct v4l2_crop a_writable = *a;\r\nstruct v4l2_rect *rect = &a_writable.c;\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct v4l2_mbus_framefmt mf;\r\nint ret;\r\nsoc_camera_limit_side(&rect->left, &rect->width, 0, 2, 4096);\r\nsoc_camera_limit_side(&rect->top, &rect->height, 0, 2, 4096);\r\nret = v4l2_subdev_call(sd, video, s_crop, a);\r\nif (ret < 0)\r\nreturn ret;\r\nret = v4l2_subdev_call(sd, video, g_mbus_fmt, &mf);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_dbg(icd->parent, "Sensor cropped %dx%d\n",\r\nmf.width, mf.height);\r\nicd->user_width = mf.width;\r\nicd->user_height = mf.height;\r\nreturn ret;\r\n}\r\nstatic int mx2_camera_get_formats(struct soc_camera_device *icd,\r\nunsigned int idx,\r\nstruct soc_camera_format_xlate *xlate)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nconst struct soc_mbus_pixelfmt *fmt;\r\nstruct device *dev = icd->parent;\r\nenum v4l2_mbus_pixelcode code;\r\nint ret, formats = 0;\r\nret = v4l2_subdev_call(sd, video, enum_mbus_fmt, idx, &code);\r\nif (ret < 0)\r\nreturn 0;\r\nfmt = soc_mbus_get_fmtdesc(code);\r\nif (!fmt) {\r\ndev_err(dev, "Invalid format code #%u: %d\n", idx, code);\r\nreturn 0;\r\n}\r\nif (code == V4L2_MBUS_FMT_YUYV8_2X8 ||\r\ncode == V4L2_MBUS_FMT_UYVY8_2X8) {\r\nformats++;\r\nif (xlate) {\r\nxlate->host_fmt =\r\nsoc_mbus_get_fmtdesc(V4L2_MBUS_FMT_YUYV8_1_5X8);\r\nxlate->code = code;\r\ndev_dbg(dev, "Providing host format %s for sensor code %d\n",\r\nxlate->host_fmt->name, code);\r\nxlate++;\r\n}\r\n}\r\nif (code == V4L2_MBUS_FMT_UYVY8_2X8) {\r\nformats++;\r\nif (xlate) {\r\nxlate->host_fmt =\r\nsoc_mbus_get_fmtdesc(V4L2_MBUS_FMT_YUYV8_2X8);\r\nxlate->code = code;\r\ndev_dbg(dev, "Providing host format %s for sensor code %d\n",\r\nxlate->host_fmt->name, code);\r\nxlate++;\r\n}\r\n}\r\nformats++;\r\nif (xlate) {\r\nxlate->host_fmt = fmt;\r\nxlate->code = code;\r\nxlate++;\r\n}\r\nreturn formats;\r\n}\r\nstatic int mx2_emmaprp_resize(struct mx2_camera_dev *pcdev,\r\nstruct v4l2_mbus_framefmt *mf_in,\r\nstruct v4l2_pix_format *pix_out, bool apply)\r\n{\r\nint num, den;\r\nunsigned long m;\r\nint i, dir;\r\nfor (dir = RESIZE_DIR_H; dir <= RESIZE_DIR_V; dir++) {\r\nstruct emma_prp_resize tmprsz;\r\nunsigned char *s = tmprsz.s;\r\nint len = 0;\r\nint in, out;\r\nif (dir == RESIZE_DIR_H) {\r\nin = mf_in->width;\r\nout = pix_out->width;\r\n} else {\r\nin = mf_in->height;\r\nout = pix_out->height;\r\n}\r\nif (in < out)\r\nreturn -EINVAL;\r\nelse if (in == out)\r\ncontinue;\r\nm = gcd(in, out);\r\nnum = in / m;\r\nden = out / m;\r\nif (num > RESIZE_NUM_MAX)\r\nreturn -EINVAL;\r\nif ((num >= 2 * den) && (den == 1) &&\r\n(num < 9) && (!(num & 0x01))) {\r\nint sum = 0;\r\nint j;\r\ntmprsz.algo = RESIZE_ALGO_AVERAGING;\r\nlen = num;\r\nfor (i = 0; i < (len / 2); i++)\r\ns[i] = 8;\r\ndo {\r\nfor (i = 0; i < (len / 2); i++) {\r\ns[i] = s[i] >> 1;\r\nsum = 0;\r\nfor (j = 0; j < (len / 2); j++)\r\nsum += s[j];\r\nif (sum == 4)\r\nbreak;\r\n}\r\n} while (sum != 4);\r\nfor (i = (len / 2); i < len; i++)\r\ns[i] = s[len - i - 1];\r\ns[len - 1] |= SZ_COEF;\r\n} else {\r\nint v;\r\nint coeff, nxt;\r\nint in_pos_inc = 2 * den;\r\nint out_pos = num;\r\nint out_pos_inc = 2 * num;\r\nint init_carry = num - den;\r\nint carry = init_carry;\r\ntmprsz.algo = RESIZE_ALGO_BILINEAR;\r\nv = den + in_pos_inc;\r\ndo {\r\ncoeff = v - out_pos;\r\nout_pos += out_pos_inc;\r\ncarry += out_pos_inc;\r\nfor (nxt = 0; v < out_pos; nxt++) {\r\nv += in_pos_inc;\r\ncarry -= in_pos_inc;\r\n}\r\nif (len > RESIZE_NUM_MAX)\r\nreturn -EINVAL;\r\ncoeff = ((coeff << BC_COEF) +\r\n(in_pos_inc >> 1)) / in_pos_inc;\r\nif (coeff >= (SZ_COEF - 1))\r\ncoeff--;\r\ncoeff |= SZ_COEF;\r\ns[len] = (unsigned char)coeff;\r\nlen++;\r\nfor (i = 1; i < nxt; i++) {\r\nif (len >= RESIZE_NUM_MAX)\r\nreturn -EINVAL;\r\ns[len] = 0;\r\nlen++;\r\n}\r\n} while (carry != init_carry);\r\n}\r\ntmprsz.len = len;\r\nif (dir == RESIZE_DIR_H)\r\nmf_in->width = pix_out->width;\r\nelse\r\nmf_in->height = pix_out->height;\r\nif (apply)\r\nmemcpy(&pcdev->resizing[dir], &tmprsz, sizeof(tmprsz));\r\n}\r\nreturn 0;\r\n}\r\nstatic int mx2_camera_set_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_format *f)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct mx2_camera_dev *pcdev = ici->priv;\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nconst struct soc_camera_format_xlate *xlate;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_mbus_framefmt mf;\r\nint ret;\r\ndev_dbg(icd->parent, "%s: requested params: width = %d, height = %d\n",\r\n__func__, pix->width, pix->height);\r\nxlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);\r\nif (!xlate) {\r\ndev_warn(icd->parent, "Format %x not found\n",\r\npix->pixelformat);\r\nreturn -EINVAL;\r\n}\r\nmf.width = pix->width;\r\nmf.height = pix->height;\r\nmf.field = pix->field;\r\nmf.colorspace = pix->colorspace;\r\nmf.code = xlate->code;\r\nret = v4l2_subdev_call(sd, video, s_mbus_fmt, &mf);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn ret;\r\npcdev->s_width = mf.width;\r\npcdev->s_height = mf.height;\r\ndev_dbg(icd->parent, "%s: sensor params: width = %d, height = %d\n",\r\n__func__, pcdev->s_width, pcdev->s_height);\r\npcdev->emma_prp = mx27_emma_prp_get_format(xlate->code,\r\nxlate->host_fmt->fourcc);\r\nmemset(pcdev->resizing, 0, sizeof(pcdev->resizing));\r\nif ((mf.width != pix->width || mf.height != pix->height) &&\r\npcdev->emma_prp->cfg.in_fmt == PRP_CNTL_DATA_IN_YUV422) {\r\nif (mx2_emmaprp_resize(pcdev, &mf, pix, true) < 0)\r\ndev_dbg(icd->parent, "%s: can't resize\n", __func__);\r\n}\r\nif (mf.code != xlate->code)\r\nreturn -EINVAL;\r\npix->width = mf.width;\r\npix->height = mf.height;\r\npix->field = mf.field;\r\npix->colorspace = mf.colorspace;\r\nicd->current_fmt = xlate;\r\ndev_dbg(icd->parent, "%s: returned params: width = %d, height = %d\n",\r\n__func__, pix->width, pix->height);\r\nreturn 0;\r\n}\r\nstatic int mx2_camera_try_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_format *f)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nconst struct soc_camera_format_xlate *xlate;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_mbus_framefmt mf;\r\n__u32 pixfmt = pix->pixelformat;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct mx2_camera_dev *pcdev = ici->priv;\r\nstruct mx2_fmt_cfg *emma_prp;\r\nint ret;\r\ndev_dbg(icd->parent, "%s: requested params: width = %d, height = %d\n",\r\n__func__, pix->width, pix->height);\r\nxlate = soc_camera_xlate_by_fourcc(icd, pixfmt);\r\nif (pixfmt && !xlate) {\r\ndev_warn(icd->parent, "Format %x not found\n", pixfmt);\r\nreturn -EINVAL;\r\n}\r\npix->width &= ~0x7;\r\nmf.width = pix->width;\r\nmf.height = pix->height;\r\nmf.field = pix->field;\r\nmf.colorspace = pix->colorspace;\r\nmf.code = xlate->code;\r\nret = v4l2_subdev_call(sd, video, try_mbus_fmt, &mf);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_dbg(icd->parent, "%s: sensor params: width = %d, height = %d\n",\r\n__func__, pcdev->s_width, pcdev->s_height);\r\nemma_prp = mx27_emma_prp_get_format(xlate->code,\r\nxlate->host_fmt->fourcc);\r\nif ((mf.width != pix->width || mf.height != pix->height) &&\r\nemma_prp->cfg.in_fmt == PRP_CNTL_DATA_IN_YUV422) {\r\nif (mx2_emmaprp_resize(pcdev, &mf, pix, false) < 0)\r\ndev_dbg(icd->parent, "%s: can't resize\n", __func__);\r\n}\r\nif (mf.field == V4L2_FIELD_ANY)\r\nmf.field = V4L2_FIELD_NONE;\r\nif (mf.field != V4L2_FIELD_NONE && !V4L2_FIELD_HAS_BOTH(mf.field)) {\r\ndev_err(icd->parent, "Field type %d unsupported.\n",\r\nmf.field);\r\nreturn -EINVAL;\r\n}\r\npix->width = mf.width;\r\npix->height = mf.height;\r\npix->field = mf.field;\r\npix->colorspace = mf.colorspace;\r\ndev_dbg(icd->parent, "%s: returned params: width = %d, height = %d\n",\r\n__func__, pix->width, pix->height);\r\nreturn 0;\r\n}\r\nstatic int mx2_camera_querycap(struct soc_camera_host *ici,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrlcpy(cap->card, MX2_CAM_DRIVER_DESCRIPTION, sizeof(cap->card));\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\nreturn 0;\r\n}\r\nstatic unsigned int mx2_camera_poll(struct file *file, poll_table *pt)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nreturn vb2_poll(&icd->vb2_vidq, file, pt);\r\n}\r\nstatic void mx27_camera_frame_done_emma(struct mx2_camera_dev *pcdev,\r\nint bufnum, bool err)\r\n{\r\n#ifdef DEBUG\r\nstruct mx2_fmt_cfg *prp = pcdev->emma_prp;\r\n#endif\r\nstruct mx2_buf_internal *ibuf;\r\nstruct mx2_buffer *buf;\r\nstruct vb2_buffer *vb;\r\nunsigned long phys;\r\nibuf = list_first_entry(&pcdev->active_bufs, struct mx2_buf_internal,\r\nqueue);\r\nBUG_ON(ibuf->bufnum != bufnum);\r\nif (ibuf->discard) {\r\nlist_move_tail(pcdev->active_bufs.next, &pcdev->discard);\r\n} else {\r\nbuf = mx2_ibuf_to_buf(ibuf);\r\nvb = &buf->vb;\r\n#ifdef DEBUG\r\nphys = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nif (prp->cfg.channel == 1) {\r\nif (readl(pcdev->base_emma + PRP_DEST_RGB1_PTR +\r\n4 * bufnum) != phys) {\r\ndev_err(pcdev->dev, "%lx != %x\n", phys,\r\nreadl(pcdev->base_emma +\r\nPRP_DEST_RGB1_PTR + 4 * bufnum));\r\n}\r\n} else {\r\nif (readl(pcdev->base_emma + PRP_DEST_Y_PTR -\r\n0x14 * bufnum) != phys) {\r\ndev_err(pcdev->dev, "%lx != %x\n", phys,\r\nreadl(pcdev->base_emma +\r\nPRP_DEST_Y_PTR - 0x14 * bufnum));\r\n}\r\n}\r\n#endif\r\ndev_dbg(pcdev->dev, "%s (vb=0x%p) 0x%p %lu\n", __func__, vb,\r\nvb2_plane_vaddr(vb, 0),\r\nvb2_get_plane_payload(vb, 0));\r\nlist_del_init(&buf->internal.queue);\r\nv4l2_get_timestamp(&vb->v4l2_buf.timestamp);\r\nvb->v4l2_buf.sequence = pcdev->frame_count;\r\nif (err)\r\nvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\r\nelse\r\nvb2_buffer_done(vb, VB2_BUF_STATE_DONE);\r\n}\r\npcdev->frame_count++;\r\nif (list_empty(&pcdev->capture)) {\r\nif (list_empty(&pcdev->discard)) {\r\ndev_warn(pcdev->dev, "%s: trying to access empty discard list\n",\r\n__func__);\r\nreturn;\r\n}\r\nibuf = list_first_entry(&pcdev->discard,\r\nstruct mx2_buf_internal, queue);\r\nibuf->bufnum = bufnum;\r\nlist_move_tail(pcdev->discard.next, &pcdev->active_bufs);\r\nmx27_update_emma_buf(pcdev, pcdev->discard_buffer_dma, bufnum);\r\nreturn;\r\n}\r\nbuf = list_first_entry(&pcdev->capture, struct mx2_buffer,\r\ninternal.queue);\r\nbuf->internal.bufnum = bufnum;\r\nlist_move_tail(pcdev->capture.next, &pcdev->active_bufs);\r\nvb = &buf->vb;\r\nphys = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nmx27_update_emma_buf(pcdev, phys, bufnum);\r\n}\r\nstatic irqreturn_t mx27_camera_emma_irq(int irq_emma, void *data)\r\n{\r\nstruct mx2_camera_dev *pcdev = data;\r\nunsigned int status = readl(pcdev->base_emma + PRP_INTRSTATUS);\r\nstruct mx2_buf_internal *ibuf;\r\nspin_lock(&pcdev->lock);\r\nif (list_empty(&pcdev->active_bufs)) {\r\ndev_warn(pcdev->dev, "%s: called while active list is empty\n",\r\n__func__);\r\nif (!status) {\r\nspin_unlock(&pcdev->lock);\r\nreturn IRQ_NONE;\r\n}\r\n}\r\nif (status & (1 << 7)) {\r\nu32 cntl = readl(pcdev->base_emma + PRP_CNTL);\r\nwritel(cntl & ~(PRP_CNTL_CH1EN | PRP_CNTL_CH2EN),\r\npcdev->base_emma + PRP_CNTL);\r\nwritel(cntl, pcdev->base_emma + PRP_CNTL);\r\nibuf = list_first_entry(&pcdev->active_bufs,\r\nstruct mx2_buf_internal, queue);\r\nmx27_camera_frame_done_emma(pcdev,\r\nibuf->bufnum, true);\r\nstatus &= ~(1 << 7);\r\n} else if (((status & (3 << 5)) == (3 << 5)) ||\r\n((status & (3 << 3)) == (3 << 3))) {\r\nibuf = list_first_entry(&pcdev->active_bufs,\r\nstruct mx2_buf_internal, queue);\r\nmx27_camera_frame_done_emma(pcdev, ibuf->bufnum, false);\r\nstatus &= ~(1 << (6 - ibuf->bufnum));\r\n} else if ((status & (1 << 6)) || (status & (1 << 4))) {\r\nmx27_camera_frame_done_emma(pcdev, 0, false);\r\n} else if ((status & (1 << 5)) || (status & (1 << 3))) {\r\nmx27_camera_frame_done_emma(pcdev, 1, false);\r\n}\r\nspin_unlock(&pcdev->lock);\r\nwritel(status, pcdev->base_emma + PRP_INTRSTATUS);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mx27_camera_emma_init(struct platform_device *pdev)\r\n{\r\nstruct mx2_camera_dev *pcdev = platform_get_drvdata(pdev);\r\nstruct resource *res_emma;\r\nint irq_emma;\r\nint err = 0;\r\nres_emma = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nirq_emma = platform_get_irq(pdev, 1);\r\nif (!res_emma || !irq_emma) {\r\ndev_err(pcdev->dev, "no EMMA resources\n");\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\npcdev->base_emma = devm_ioremap_resource(pcdev->dev, res_emma);\r\nif (IS_ERR(pcdev->base_emma)) {\r\nerr = PTR_ERR(pcdev->base_emma);\r\ngoto out;\r\n}\r\nerr = devm_request_irq(pcdev->dev, irq_emma, mx27_camera_emma_irq, 0,\r\nMX2_CAM_DRV_NAME, pcdev);\r\nif (err) {\r\ndev_err(pcdev->dev, "Camera EMMA interrupt register failed\n");\r\ngoto out;\r\n}\r\npcdev->clk_emma_ipg = devm_clk_get(pcdev->dev, "emma-ipg");\r\nif (IS_ERR(pcdev->clk_emma_ipg)) {\r\nerr = PTR_ERR(pcdev->clk_emma_ipg);\r\ngoto out;\r\n}\r\nclk_prepare_enable(pcdev->clk_emma_ipg);\r\npcdev->clk_emma_ahb = devm_clk_get(pcdev->dev, "emma-ahb");\r\nif (IS_ERR(pcdev->clk_emma_ahb)) {\r\nerr = PTR_ERR(pcdev->clk_emma_ahb);\r\ngoto exit_clk_emma_ipg;\r\n}\r\nclk_prepare_enable(pcdev->clk_emma_ahb);\r\nerr = mx27_camera_emma_prp_reset(pcdev);\r\nif (err)\r\ngoto exit_clk_emma_ahb;\r\nreturn err;\r\nexit_clk_emma_ahb:\r\nclk_disable_unprepare(pcdev->clk_emma_ahb);\r\nexit_clk_emma_ipg:\r\nclk_disable_unprepare(pcdev->clk_emma_ipg);\r\nout:\r\nreturn err;\r\n}\r\nstatic int mx2_camera_probe(struct platform_device *pdev)\r\n{\r\nstruct mx2_camera_dev *pcdev;\r\nstruct resource *res_csi;\r\nint irq_csi;\r\nint err = 0;\r\ndev_dbg(&pdev->dev, "initialising\n");\r\nres_csi = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq_csi = platform_get_irq(pdev, 0);\r\nif (res_csi == NULL || irq_csi < 0) {\r\ndev_err(&pdev->dev, "Missing platform resources data\n");\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\npcdev = devm_kzalloc(&pdev->dev, sizeof(*pcdev), GFP_KERNEL);\r\nif (!pcdev) {\r\ndev_err(&pdev->dev, "Could not allocate pcdev\n");\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\npcdev->clk_csi_ahb = devm_clk_get(&pdev->dev, "ahb");\r\nif (IS_ERR(pcdev->clk_csi_ahb)) {\r\ndev_err(&pdev->dev, "Could not get csi ahb clock\n");\r\nerr = PTR_ERR(pcdev->clk_csi_ahb);\r\ngoto exit;\r\n}\r\npcdev->clk_csi_per = devm_clk_get(&pdev->dev, "per");\r\nif (IS_ERR(pcdev->clk_csi_per)) {\r\ndev_err(&pdev->dev, "Could not get csi per clock\n");\r\nerr = PTR_ERR(pcdev->clk_csi_per);\r\ngoto exit;\r\n}\r\npcdev->pdata = pdev->dev.platform_data;\r\nif (pcdev->pdata) {\r\nlong rate;\r\npcdev->platform_flags = pcdev->pdata->flags;\r\nrate = clk_round_rate(pcdev->clk_csi_per,\r\npcdev->pdata->clk * 2);\r\nif (rate <= 0) {\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\nerr = clk_set_rate(pcdev->clk_csi_per, rate);\r\nif (err < 0)\r\ngoto exit;\r\n}\r\nINIT_LIST_HEAD(&pcdev->capture);\r\nINIT_LIST_HEAD(&pcdev->active_bufs);\r\nINIT_LIST_HEAD(&pcdev->discard);\r\nspin_lock_init(&pcdev->lock);\r\npcdev->base_csi = devm_ioremap_resource(&pdev->dev, res_csi);\r\nif (IS_ERR(pcdev->base_csi)) {\r\nerr = PTR_ERR(pcdev->base_csi);\r\ngoto exit;\r\n}\r\npcdev->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, pcdev);\r\nerr = mx27_camera_emma_init(pdev);\r\nif (err)\r\ngoto exit;\r\nplatform_set_drvdata(pdev, NULL);\r\npcdev->soc_host.drv_name = MX2_CAM_DRV_NAME,\r\npcdev->soc_host.ops = &mx2_soc_camera_host_ops,\r\npcdev->soc_host.priv = pcdev;\r\npcdev->soc_host.v4l2_dev.dev = &pdev->dev;\r\npcdev->soc_host.nr = pdev->id;\r\npcdev->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);\r\nif (IS_ERR(pcdev->alloc_ctx)) {\r\nerr = PTR_ERR(pcdev->alloc_ctx);\r\ngoto eallocctx;\r\n}\r\nerr = soc_camera_host_register(&pcdev->soc_host);\r\nif (err)\r\ngoto exit_free_emma;\r\ndev_info(&pdev->dev, "MX2 Camera (CSI) driver probed, clock frequency: %ld\n",\r\nclk_get_rate(pcdev->clk_csi_per));\r\nreturn 0;\r\nexit_free_emma:\r\nvb2_dma_contig_cleanup_ctx(pcdev->alloc_ctx);\r\neallocctx:\r\nclk_disable_unprepare(pcdev->clk_emma_ipg);\r\nclk_disable_unprepare(pcdev->clk_emma_ahb);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int mx2_camera_remove(struct platform_device *pdev)\r\n{\r\nstruct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);\r\nstruct mx2_camera_dev *pcdev = container_of(soc_host,\r\nstruct mx2_camera_dev, soc_host);\r\nsoc_camera_host_unregister(&pcdev->soc_host);\r\nvb2_dma_contig_cleanup_ctx(pcdev->alloc_ctx);\r\nclk_disable_unprepare(pcdev->clk_emma_ipg);\r\nclk_disable_unprepare(pcdev->clk_emma_ahb);\r\ndev_info(&pdev->dev, "MX2 Camera driver unloaded\n");\r\nreturn 0;\r\n}
