static struct esas2r_adapter *esas2r_adapter_from_kobj(struct kobject *kobj)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct Scsi_Host *host = class_to_shost(dev);\r\nreturn (struct esas2r_adapter *)host->hostdata;\r\n}\r\nstatic ssize_t read_fw(struct file *file, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\r\nreturn esas2r_read_fw(a, buf, off, count);\r\n}\r\nstatic ssize_t write_fw(struct file *file, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\r\nreturn esas2r_write_fw(a, buf, off, count);\r\n}\r\nstatic ssize_t read_fs(struct file *file, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\r\nreturn esas2r_read_fs(a, buf, off, count);\r\n}\r\nstatic ssize_t write_fs(struct file *file, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\r\nint length = min(sizeof(struct esas2r_ioctl_fs), count);\r\nint result = 0;\r\nresult = esas2r_write_fs(a, buf, off, count);\r\nif (result < 0)\r\nresult = 0;\r\nreturn length;\r\n}\r\nstatic ssize_t read_vda(struct file *file, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\r\nreturn esas2r_read_vda(a, buf, off, count);\r\n}\r\nstatic ssize_t write_vda(struct file *file, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\r\nreturn esas2r_write_vda(a, buf, off, count);\r\n}\r\nstatic ssize_t read_live_nvram(struct file *file, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\r\nint length = min_t(size_t, sizeof(struct esas2r_sas_nvram), PAGE_SIZE);\r\nmemcpy(buf, a->nvram, length);\r\nreturn length;\r\n}\r\nstatic ssize_t write_live_nvram(struct file *file, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\r\nstruct esas2r_request *rq;\r\nint result = -EFAULT;\r\nrq = esas2r_alloc_request(a);\r\nif (rq == NULL)\r\nreturn -ENOMEM;\r\nif (esas2r_write_params(a, rq, (struct esas2r_sas_nvram *)buf))\r\nresult = count;\r\nesas2r_free_request(a, rq);\r\nreturn result;\r\n}\r\nstatic ssize_t read_default_nvram(struct file *file, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\r\nesas2r_nvram_get_defaults(a, (struct esas2r_sas_nvram *)buf);\r\nreturn sizeof(struct esas2r_sas_nvram);\r\n}\r\nstatic ssize_t read_hw(struct file *file, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\r\nint length = min_t(size_t, sizeof(struct atto_ioctl), PAGE_SIZE);\r\nif (!a->local_atto_ioctl)\r\nreturn -ENOMEM;\r\nif (handle_hba_ioctl(a, a->local_atto_ioctl) != IOCTL_SUCCESS)\r\nreturn -ENOMEM;\r\nmemcpy(buf, a->local_atto_ioctl, length);\r\nreturn length;\r\n}\r\nstatic ssize_t write_hw(struct file *file, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct esas2r_adapter *a = esas2r_adapter_from_kobj(kobj);\r\nint length = min(sizeof(struct atto_ioctl), count);\r\nif (!a->local_atto_ioctl) {\r\na->local_atto_ioctl = kzalloc(sizeof(struct atto_ioctl),\r\nGFP_KERNEL);\r\nif (a->local_atto_ioctl == NULL) {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"write_hw kzalloc failed for %d bytes",\r\nsizeof(struct atto_ioctl));\r\nreturn -ENOMEM;\r\n}\r\n}\r\nmemset(a->local_atto_ioctl, 0, sizeof(struct atto_ioctl));\r\nmemcpy(a->local_atto_ioctl, buf, length);\r\nreturn length;\r\n}\r\nstatic int esas2r_probe(struct pci_dev *pcid,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct Scsi_Host *host = NULL;\r\nstruct esas2r_adapter *a;\r\nint err;\r\nsize_t host_alloc_size = sizeof(struct esas2r_adapter)\r\n+ ((num_requests) +\r\n1) * sizeof(struct esas2r_request);\r\nesas2r_log_dev(ESAS2R_LOG_DEBG, &(pcid->dev),\r\n"esas2r_probe() 0x%02x 0x%02x 0x%02x 0x%02x",\r\npcid->vendor,\r\npcid->device,\r\npcid->subsystem_vendor,\r\npcid->subsystem_device);\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(pcid->dev),\r\n"before pci_enable_device() "\r\n"enable_cnt: %d",\r\npcid->enable_cnt.counter);\r\nerr = pci_enable_device(pcid);\r\nif (err != 0) {\r\nesas2r_log_dev(ESAS2R_LOG_CRIT, &(pcid->dev),\r\n"pci_enable_device() FAIL (%d)",\r\nerr);\r\nreturn -ENODEV;\r\n}\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(pcid->dev),\r\n"pci_enable_device() OK");\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(pcid->dev),\r\n"after pci_enable_device() enable_cnt: %d",\r\npcid->enable_cnt.counter);\r\nhost = scsi_host_alloc(&driver_template, host_alloc_size);\r\nif (host == NULL) {\r\nesas2r_log(ESAS2R_LOG_CRIT, "scsi_host_alloc() FAIL");\r\nreturn -ENODEV;\r\n}\r\nmemset(host->hostdata, 0, host_alloc_size);\r\na = (struct esas2r_adapter *)host->hostdata;\r\nesas2r_log(ESAS2R_LOG_INFO, "scsi_host_alloc() OK host: %p", host);\r\nhost->max_id = ESAS2R_MAX_ID + 1;\r\nhost->max_lun = 255;\r\nhost->max_cmd_len = 16;\r\nhost->can_queue = can_queue;\r\nhost->cmd_per_lun = cmd_per_lun;\r\nhost->this_id = host->max_id + 1;\r\nhost->max_channel = 0;\r\nhost->unique_id = found_adapters;\r\nhost->sg_tablesize = sg_tablesize;\r\nhost->max_sectors = esas2r_max_sectors;\r\nesas2r_log(ESAS2R_LOG_INFO, "pci_set_master() called");\r\npci_set_master(pcid);\r\nif (!esas2r_init_adapter(host, pcid, found_adapters)) {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"unable to initialize device at PCI bus %x:%x",\r\npcid->bus->number,\r\npcid->devfn);\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(host->shost_gendev),\r\n"scsi_host_put() called");\r\nscsi_host_put(host);\r\nreturn 0;\r\n}\r\nesas2r_log(ESAS2R_LOG_INFO, "pci_set_drvdata(%p, %p) called", pcid,\r\nhost->hostdata);\r\npci_set_drvdata(pcid, host);\r\nesas2r_log(ESAS2R_LOG_INFO, "scsi_add_host() called");\r\nerr = scsi_add_host(host, &pcid->dev);\r\nif (err) {\r\nesas2r_log(ESAS2R_LOG_CRIT, "scsi_add_host returned %d", err);\r\nesas2r_log_dev(ESAS2R_LOG_CRIT, &(host->shost_gendev),\r\n"scsi_add_host() FAIL");\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(host->shost_gendev),\r\n"scsi_host_put() called");\r\nscsi_host_put(host);\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(host->shost_gendev),\r\n"pci_set_drvdata(%p, NULL) called",\r\npcid);\r\npci_set_drvdata(pcid, NULL);\r\nreturn -ENODEV;\r\n}\r\nesas2r_fw_event_on(a);\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(host->shost_gendev),\r\n"scsi_scan_host() called");\r\nscsi_scan_host(host);\r\nif (sysfs_create_bin_file(&host->shost_dev.kobj, &bin_attr_fw))\r\nesas2r_log_dev(ESAS2R_LOG_WARN, &(host->shost_gendev),\r\n"Failed to create sysfs binary file: fw");\r\nelse\r\na->sysfs_fw_created = 1;\r\nif (sysfs_create_bin_file(&host->shost_dev.kobj, &bin_attr_fs))\r\nesas2r_log_dev(ESAS2R_LOG_WARN, &(host->shost_gendev),\r\n"Failed to create sysfs binary file: fs");\r\nelse\r\na->sysfs_fs_created = 1;\r\nif (sysfs_create_bin_file(&host->shost_dev.kobj, &bin_attr_vda))\r\nesas2r_log_dev(ESAS2R_LOG_WARN, &(host->shost_gendev),\r\n"Failed to create sysfs binary file: vda");\r\nelse\r\na->sysfs_vda_created = 1;\r\nif (sysfs_create_bin_file(&host->shost_dev.kobj, &bin_attr_hw))\r\nesas2r_log_dev(ESAS2R_LOG_WARN, &(host->shost_gendev),\r\n"Failed to create sysfs binary file: hw");\r\nelse\r\na->sysfs_hw_created = 1;\r\nif (sysfs_create_bin_file(&host->shost_dev.kobj, &bin_attr_live_nvram))\r\nesas2r_log_dev(ESAS2R_LOG_WARN, &(host->shost_gendev),\r\n"Failed to create sysfs binary file: live_nvram");\r\nelse\r\na->sysfs_live_nvram_created = 1;\r\nif (sysfs_create_bin_file(&host->shost_dev.kobj,\r\n&bin_attr_default_nvram))\r\nesas2r_log_dev(ESAS2R_LOG_WARN, &(host->shost_gendev),\r\n"Failed to create sysfs binary file: default_nvram");\r\nelse\r\na->sysfs_default_nvram_created = 1;\r\nfound_adapters++;\r\nreturn 0;\r\n}\r\nstatic void esas2r_remove(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *host;\r\nint index;\r\nif (pdev == NULL) {\r\nesas2r_log(ESAS2R_LOG_WARN, "esas2r_remove pdev==NULL");\r\nreturn;\r\n}\r\nhost = pci_get_drvdata(pdev);\r\nif (host == NULL) {\r\nreturn;\r\n}\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(pdev->dev),\r\n"esas2r_remove(%p) called; "\r\n"host:%p", pdev,\r\nhost);\r\nindex = esas2r_cleanup(host);\r\nif (index < 0)\r\nesas2r_log_dev(ESAS2R_LOG_WARN, &(pdev->dev),\r\n"unknown host in %s",\r\n__func__);\r\nfound_adapters--;\r\nif (found_adapters == 0)\r\nesas2r_cleanup(NULL);\r\n}\r\nstatic int __init esas2r_init(void)\r\n{\r\nint i;\r\nesas2r_log(ESAS2R_LOG_INFO, "%s called", __func__);\r\nif (can_queue < 1) {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"warning: can_queue must be at least 1, value "\r\n"forced.");\r\ncan_queue = 1;\r\n} else if (can_queue > 2048) {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"warning: can_queue must be no larger than 2048, "\r\n"value forced.");\r\ncan_queue = 2048;\r\n}\r\nif (cmd_per_lun < 1) {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"warning: cmd_per_lun must be at least 1, value "\r\n"forced.");\r\ncmd_per_lun = 1;\r\n} else if (cmd_per_lun > 2048) {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"warning: cmd_per_lun must be no larger than "\r\n"2048, value forced.");\r\ncmd_per_lun = 2048;\r\n}\r\nif (sg_tablesize < 32) {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"warning: sg_tablesize must be at least 32, "\r\n"value forced.");\r\nsg_tablesize = 32;\r\n}\r\nif (esas2r_max_sectors < 1) {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"warning: esas2r_max_sectors must be at least "\r\n"1, value forced.");\r\nesas2r_max_sectors = 1;\r\n} else if (esas2r_max_sectors > 0xffff) {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"warning: esas2r_max_sectors must be no larger "\r\n"than 0xffff, value forced.");\r\nesas2r_max_sectors = 0xffff;\r\n}\r\nsgl_page_size &= ~(ESAS2R_SGL_ALIGN - 1);\r\nif (sgl_page_size < SGL_PG_SZ_MIN)\r\nsgl_page_size = SGL_PG_SZ_MIN;\r\nelse if (sgl_page_size > SGL_PG_SZ_MAX)\r\nsgl_page_size = SGL_PG_SZ_MAX;\r\nif (num_sg_lists < NUM_SGL_MIN)\r\nnum_sg_lists = NUM_SGL_MIN;\r\nelse if (num_sg_lists > NUM_SGL_MAX)\r\nnum_sg_lists = NUM_SGL_MAX;\r\nif (num_requests < NUM_REQ_MIN)\r\nnum_requests = NUM_REQ_MIN;\r\nelse if (num_requests > NUM_REQ_MAX)\r\nnum_requests = NUM_REQ_MAX;\r\nif (num_ae_requests < NUM_AE_MIN)\r\nnum_ae_requests = NUM_AE_MIN;\r\nelse if (num_ae_requests > NUM_AE_MAX)\r\nnum_ae_requests = NUM_AE_MAX;\r\nfor (i = 0; i < MAX_ADAPTERS; i++)\r\nesas2r_adapters[i] = NULL;\r\ndriver_template.module = THIS_MODULE;\r\nif (pci_register_driver(&esas2r_pci_driver) != 0)\r\nesas2r_log(ESAS2R_LOG_CRIT, "pci_register_driver FAILED");\r\nelse\r\nesas2r_log(ESAS2R_LOG_INFO, "pci_register_driver() OK");\r\nif (!found_adapters) {\r\npci_unregister_driver(&esas2r_pci_driver);\r\nesas2r_cleanup(NULL);\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"driver will not be loaded because no ATTO "\r\n"%s devices were found",\r\nESAS2R_DRVR_NAME);\r\nreturn -1;\r\n} else {\r\nesas2r_log(ESAS2R_LOG_INFO, "found %d adapters",\r\nfound_adapters);\r\n}\r\nreturn 0;\r\n}\r\nlong esas2r_proc_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)\r\n{\r\nreturn esas2r_ioctl_handler(esas2r_proc_host->hostdata,\r\n(int)cmd, (void __user *)arg);\r\n}\r\nstatic void __exit esas2r_exit(void)\r\n{\r\nesas2r_log(ESAS2R_LOG_INFO, "%s called", __func__);\r\nif (esas2r_proc_major > 0) {\r\nesas2r_log(ESAS2R_LOG_INFO, "unregister proc");\r\nremove_proc_entry(ATTONODE_NAME,\r\nesas2r_proc_host->hostt->proc_dir);\r\nunregister_chrdev(esas2r_proc_major, ESAS2R_DRVR_NAME);\r\nesas2r_proc_major = 0;\r\n}\r\nesas2r_log(ESAS2R_LOG_INFO, "pci_unregister_driver() called");\r\npci_unregister_driver(&esas2r_pci_driver);\r\n}\r\nint esas2r_show_info(struct seq_file *m, struct Scsi_Host *sh)\r\n{\r\nstruct esas2r_adapter *a = (struct esas2r_adapter *)sh->hostdata;\r\nstruct esas2r_target *t;\r\nint dev_count = 0;\r\nesas2r_log(ESAS2R_LOG_DEBG, "esas2r_show_info (%p,%d)", m, sh->host_no);\r\nseq_printf(m, ESAS2R_LONGNAME "\n"\r\n"Driver version: "ESAS2R_VERSION_STR "\n"\r\n"Flash version: %s\n"\r\n"Firmware version: %s\n"\r\n"Copyright "ESAS2R_COPYRIGHT_YEARS "\n"\r\n"http://www.attotech.com\n"\r\n"\n",\r\na->flash_rev,\r\na->fw_rev[0] ? a->fw_rev : "(none)");\r\nseq_printf(m, "Adapter information:\n"\r\n"--------------------\n"\r\n"Model: %s\n"\r\n"SAS address: %02X%02X%02X%02X:%02X%02X%02X%02X\n",\r\nesas2r_get_model_name(a),\r\na->nvram->sas_addr[0],\r\na->nvram->sas_addr[1],\r\na->nvram->sas_addr[2],\r\na->nvram->sas_addr[3],\r\na->nvram->sas_addr[4],\r\na->nvram->sas_addr[5],\r\na->nvram->sas_addr[6],\r\na->nvram->sas_addr[7]);\r\nseq_puts(m, "\n"\r\n"Discovered devices:\n"\r\n"\n"\r\n" # Target ID\n"\r\n"---------------\n");\r\nfor (t = a->targetdb; t < a->targetdb_end; t++)\r\nif (t->buffered_target_state == TS_PRESENT) {\r\nseq_printf(m, " %3d %3d\n",\r\n++dev_count,\r\n(u16)(uintptr_t)(t - a->targetdb));\r\n}\r\nif (dev_count == 0)\r\nseq_puts(m, "none\n");\r\nseq_puts(m, "\n");\r\nreturn 0;\r\n}\r\nint esas2r_release(struct Scsi_Host *sh)\r\n{\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(sh->shost_gendev),\r\n"esas2r_release() called");\r\nesas2r_cleanup(sh);\r\nif (sh->irq)\r\nfree_irq(sh->irq, NULL);\r\nscsi_unregister(sh);\r\nreturn 0;\r\n}\r\nconst char *esas2r_info(struct Scsi_Host *sh)\r\n{\r\nstruct esas2r_adapter *a = (struct esas2r_adapter *)sh->hostdata;\r\nstatic char esas2r_info_str[512];\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(sh->shost_gendev),\r\n"esas2r_info() called");\r\nif (esas2r_proc_major <= 0) {\r\nesas2r_proc_host = sh;\r\nesas2r_proc_major = register_chrdev(0, ESAS2R_DRVR_NAME,\r\n&esas2r_proc_fops);\r\nesas2r_log_dev(ESAS2R_LOG_DEBG, &(sh->shost_gendev),\r\n"register_chrdev (major %d)",\r\nesas2r_proc_major);\r\nif (esas2r_proc_major > 0) {\r\nstruct proc_dir_entry *pde;\r\npde = proc_create(ATTONODE_NAME, 0,\r\nsh->hostt->proc_dir,\r\n&esas2r_proc_fops);\r\nif (!pde) {\r\nesas2r_log_dev(ESAS2R_LOG_WARN,\r\n&(sh->shost_gendev),\r\n"failed to create_proc_entry");\r\nesas2r_proc_major = -1;\r\n}\r\n}\r\n}\r\nsprintf(esas2r_info_str,\r\nESAS2R_LONGNAME " (bus 0x%02X, device 0x%02X, IRQ 0x%02X)"\r\n" driver version: "ESAS2R_VERSION_STR " firmware version: "\r\n"%s\n",\r\na->pcid->bus->number, a->pcid->devfn, a->pcid->irq,\r\na->fw_rev[0] ? a->fw_rev : "(none)");\r\nreturn esas2r_info_str;\r\n}\r\nstatic u32 get_physaddr_from_sgc(struct esas2r_sg_context *sgc, u64 *addr)\r\n{\r\nu32 len;\r\nif (likely(sgc->cur_offset == sgc->exp_offset)) {\r\nif (sgc->sgel_count < sgc->num_sgel) {\r\nif (sgc->exp_offset > (u8 *)0) {\r\nsgc->cur_sgel = sg_next(sgc->cur_sgel);\r\n++(sgc->sgel_count);\r\n}\r\nlen = sg_dma_len(sgc->cur_sgel);\r\n(*addr) = sg_dma_address(sgc->cur_sgel);\r\nsgc->exp_offset += len;\r\n} else {\r\nlen = 0;\r\n}\r\n} else if (sgc->cur_offset < sgc->exp_offset) {\r\nlen = sg_dma_len(sgc->cur_sgel);\r\n(*addr) = sg_dma_address(sgc->cur_sgel);\r\nsgc->exp_offset -= len;\r\n*addr = *addr +\r\n(sgc->cur_offset - sgc->exp_offset);\r\nsgc->exp_offset += len;\r\nlen = lower_32_bits(\r\nsgc->exp_offset - sgc->cur_offset);\r\n} else {\r\nlen = 0;\r\n}\r\nreturn len;\r\n}\r\nint esas2r_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmd)\r\n{\r\nstruct esas2r_adapter *a =\r\n(struct esas2r_adapter *)cmd->device->host->hostdata;\r\nstruct esas2r_request *rq;\r\nstruct esas2r_sg_context sgc;\r\nunsigned bufflen;\r\ncmd->result = DID_OK << 16;\r\nif (unlikely(test_bit(AF_DEGRADED_MODE, &a->flags))) {\r\ncmd->result = DID_NO_CONNECT << 16;\r\ncmd->scsi_done(cmd);\r\nreturn 0;\r\n}\r\nrq = esas2r_alloc_request(a);\r\nif (unlikely(rq == NULL)) {\r\nesas2r_debug("esas2r_alloc_request failed");\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nrq->cmd = cmd;\r\nbufflen = scsi_bufflen(cmd);\r\nif (likely(bufflen != 0)) {\r\nif (cmd->sc_data_direction == DMA_TO_DEVICE)\r\nrq->vrq->scsi.flags |= cpu_to_le32(FCP_CMND_WRD);\r\nelse if (cmd->sc_data_direction == DMA_FROM_DEVICE)\r\nrq->vrq->scsi.flags |= cpu_to_le32(FCP_CMND_RDD);\r\n}\r\nmemcpy(rq->vrq->scsi.cdb, cmd->cmnd, cmd->cmd_len);\r\nrq->vrq->scsi.length = cpu_to_le32(bufflen);\r\nrq->target_id = cmd->device->id;\r\nrq->vrq->scsi.flags |= cpu_to_le32(cmd->device->lun);\r\nrq->sense_buf = cmd->sense_buffer;\r\nrq->sense_len = SCSI_SENSE_BUFFERSIZE;\r\nesas2r_sgc_init(&sgc, a, rq, NULL);\r\nsgc.length = bufflen;\r\nsgc.cur_offset = NULL;\r\nsgc.cur_sgel = scsi_sglist(cmd);\r\nsgc.exp_offset = NULL;\r\nsgc.num_sgel = scsi_dma_map(cmd);\r\nsgc.sgel_count = 0;\r\nif (unlikely(sgc.num_sgel < 0)) {\r\nesas2r_free_request(a, rq);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nsgc.get_phys_addr = (PGETPHYSADDR)get_physaddr_from_sgc;\r\nif (unlikely(!esas2r_build_sg_list(a, rq, &sgc))) {\r\nscsi_dma_unmap(cmd);\r\nesas2r_free_request(a, rq);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nesas2r_debug("start request %p to %d:%d\n", rq, (int)cmd->device->id,\r\n(int)cmd->device->lun);\r\nesas2r_start_request(a, rq);\r\nreturn 0;\r\n}\r\nstatic void complete_task_management_request(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\n(*rq->task_management_status_ptr) = rq->req_stat;\r\nesas2r_free_request(a, rq);\r\n}\r\nstatic int esas2r_check_active_queue(struct esas2r_adapter *a,\r\nstruct esas2r_request **abort_request,\r\nstruct scsi_cmnd *cmd,\r\nstruct list_head *queue)\r\n{\r\nbool found = false;\r\nstruct esas2r_request *ar = *abort_request;\r\nstruct esas2r_request *rq;\r\nstruct list_head *element, *next;\r\nlist_for_each_safe(element, next, queue) {\r\nrq = list_entry(element, struct esas2r_request, req_list);\r\nif (rq->cmd == cmd) {\r\nif (queue == &a->active_list) {\r\nar = esas2r_alloc_request(a);\r\nif (ar == NULL) {\r\nesas2r_log_dev(ESAS2R_LOG_WARN,\r\n&(a->host->shost_gendev),\r\n"unable to allocate an abort request for cmd %p",\r\ncmd);\r\nreturn 0;\r\n}\r\nar->sense_len = 0;\r\nar->vrq->scsi.length = 0;\r\nar->target_id = rq->target_id;\r\nar->vrq->scsi.flags |= cpu_to_le32(\r\n(u8)le32_to_cpu(rq->vrq->scsi.flags));\r\nmemset(ar->vrq->scsi.cdb, 0,\r\nsizeof(ar->vrq->scsi.cdb));\r\nar->vrq->scsi.flags |= cpu_to_le32(\r\nFCP_CMND_TRM);\r\nar->vrq->scsi.u.abort_handle =\r\nrq->vrq->scsi.handle;\r\n} else {\r\nlist_del_init(&rq->req_list);\r\nesas2r_free_request(a, rq);\r\n}\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nreturn 1;\r\nreturn 2;\r\n}\r\nint esas2r_eh_abort(struct scsi_cmnd *cmd)\r\n{\r\nstruct esas2r_adapter *a =\r\n(struct esas2r_adapter *)cmd->device->host->hostdata;\r\nstruct esas2r_request *abort_request = NULL;\r\nunsigned long flags;\r\nstruct list_head *queue;\r\nint result;\r\nesas2r_log(ESAS2R_LOG_INFO, "eh_abort (%p)", cmd);\r\nif (test_bit(AF_DEGRADED_MODE, &a->flags)) {\r\ncmd->result = DID_ABORT << 16;\r\nscsi_set_resid(cmd, 0);\r\ncmd->scsi_done(cmd);\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&a->queue_lock, flags);\r\nqueue = &a->defer_list;\r\ncheck_active_queue:\r\nresult = esas2r_check_active_queue(a, &abort_request, cmd, queue);\r\nif (!result) {\r\nspin_unlock_irqrestore(&a->queue_lock, flags);\r\nreturn FAILED;\r\n} else if (result == 2 && (queue == &a->defer_list)) {\r\nqueue = &a->active_list;\r\ngoto check_active_queue;\r\n}\r\nspin_unlock_irqrestore(&a->queue_lock, flags);\r\nif (abort_request) {\r\nu8 task_management_status = RS_PENDING;\r\nabort_request->comp_cb = complete_task_management_request;\r\nabort_request->task_management_status_ptr =\r\n&task_management_status;\r\nesas2r_start_request(a, abort_request);\r\nif (atomic_read(&a->disable_cnt) == 0)\r\nesas2r_do_deferred_processes(a);\r\nwhile (task_management_status == RS_PENDING)\r\nmsleep(10);\r\nreturn SUCCESS;\r\n}\r\ncmd->result = DID_ABORT << 16;\r\nscsi_set_resid(cmd, 0);\r\ncmd->scsi_done(cmd);\r\nreturn SUCCESS;\r\n}\r\nstatic int esas2r_host_bus_reset(struct scsi_cmnd *cmd, bool host_reset)\r\n{\r\nstruct esas2r_adapter *a =\r\n(struct esas2r_adapter *)cmd->device->host->hostdata;\r\nif (test_bit(AF_DEGRADED_MODE, &a->flags))\r\nreturn FAILED;\r\nif (host_reset)\r\nesas2r_reset_adapter(a);\r\nelse\r\nesas2r_reset_bus(a);\r\nwhile (test_bit(AF_OS_RESET, &a->flags)) {\r\nmsleep(10);\r\nif (test_bit(AF_DEGRADED_MODE, &a->flags))\r\nreturn FAILED;\r\n}\r\nif (test_bit(AF_DEGRADED_MODE, &a->flags))\r\nreturn FAILED;\r\nreturn SUCCESS;\r\n}\r\nint esas2r_host_reset(struct scsi_cmnd *cmd)\r\n{\r\nesas2r_log(ESAS2R_LOG_INFO, "host_reset (%p)", cmd);\r\nreturn esas2r_host_bus_reset(cmd, true);\r\n}\r\nint esas2r_bus_reset(struct scsi_cmnd *cmd)\r\n{\r\nesas2r_log(ESAS2R_LOG_INFO, "bus_reset (%p)", cmd);\r\nreturn esas2r_host_bus_reset(cmd, false);\r\n}\r\nstatic int esas2r_dev_targ_reset(struct scsi_cmnd *cmd, bool target_reset)\r\n{\r\nstruct esas2r_adapter *a =\r\n(struct esas2r_adapter *)cmd->device->host->hostdata;\r\nstruct esas2r_request *rq;\r\nu8 task_management_status = RS_PENDING;\r\nbool completed;\r\nif (test_bit(AF_DEGRADED_MODE, &a->flags))\r\nreturn FAILED;\r\nretry:\r\nrq = esas2r_alloc_request(a);\r\nif (rq == NULL) {\r\nif (target_reset) {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"unable to allocate a request for a "\r\n"target reset (%d)!",\r\ncmd->device->id);\r\n} else {\r\nesas2r_log(ESAS2R_LOG_CRIT,\r\n"unable to allocate a request for a "\r\n"device reset (%d:%d)!",\r\ncmd->device->id,\r\ncmd->device->lun);\r\n}\r\nreturn FAILED;\r\n}\r\nrq->target_id = cmd->device->id;\r\nrq->vrq->scsi.flags |= cpu_to_le32(cmd->device->lun);\r\nrq->req_stat = RS_PENDING;\r\nrq->comp_cb = complete_task_management_request;\r\nrq->task_management_status_ptr = &task_management_status;\r\nif (target_reset) {\r\nesas2r_debug("issuing target reset (%p) to id %d", rq,\r\ncmd->device->id);\r\ncompleted = esas2r_send_task_mgmt(a, rq, 0x20);\r\n} else {\r\nesas2r_debug("issuing device reset (%p) to id %d lun %d", rq,\r\ncmd->device->id, cmd->device->lun);\r\ncompleted = esas2r_send_task_mgmt(a, rq, 0x10);\r\n}\r\nif (completed) {\r\nesas2r_free_request(a, rq);\r\n} else {\r\nwhile (task_management_status == RS_PENDING)\r\nmsleep(10);\r\n}\r\nif (test_bit(AF_DEGRADED_MODE, &a->flags))\r\nreturn FAILED;\r\nif (task_management_status == RS_BUSY) {\r\nmsleep(100);\r\ngoto retry;\r\n}\r\nreturn SUCCESS;\r\n}\r\nint esas2r_device_reset(struct scsi_cmnd *cmd)\r\n{\r\nesas2r_log(ESAS2R_LOG_INFO, "device_reset (%p)", cmd);\r\nreturn esas2r_dev_targ_reset(cmd, false);\r\n}\r\nint esas2r_target_reset(struct scsi_cmnd *cmd)\r\n{\r\nesas2r_log(ESAS2R_LOG_INFO, "target_reset (%p)", cmd);\r\nreturn esas2r_dev_targ_reset(cmd, true);\r\n}\r\nint esas2r_change_queue_depth(struct scsi_device *dev, int depth, int reason)\r\n{\r\nesas2r_log(ESAS2R_LOG_INFO, "change_queue_depth %p, %d", dev, depth);\r\nscsi_adjust_queue_depth(dev, scsi_get_tag_type(dev), depth);\r\nreturn dev->queue_depth;\r\n}\r\nint esas2r_change_queue_type(struct scsi_device *dev, int type)\r\n{\r\nesas2r_log(ESAS2R_LOG_INFO, "change_queue_type %p, %d", dev, type);\r\nif (dev->tagged_supported) {\r\nscsi_set_tag_type(dev, type);\r\nif (type)\r\nscsi_activate_tcq(dev, dev->queue_depth);\r\nelse\r\nscsi_deactivate_tcq(dev, dev->queue_depth);\r\n} else {\r\ntype = 0;\r\n}\r\nreturn type;\r\n}\r\nint esas2r_slave_alloc(struct scsi_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nint esas2r_slave_configure(struct scsi_device *dev)\r\n{\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(dev->sdev_gendev),\r\n"esas2r_slave_configure()");\r\nif (dev->tagged_supported) {\r\nscsi_set_tag_type(dev, MSG_SIMPLE_TAG);\r\nscsi_activate_tcq(dev, cmd_per_lun);\r\n} else {\r\nscsi_set_tag_type(dev, 0);\r\nscsi_deactivate_tcq(dev, cmd_per_lun);\r\n}\r\nreturn 0;\r\n}\r\nvoid esas2r_slave_destroy(struct scsi_device *dev)\r\n{\r\nesas2r_log_dev(ESAS2R_LOG_INFO, &(dev->sdev_gendev),\r\n"esas2r_slave_destroy()");\r\n}\r\nvoid esas2r_log_request_failure(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nu8 reqstatus = rq->req_stat;\r\nif (reqstatus == RS_SUCCESS)\r\nreturn;\r\nif (rq->vrq->scsi.function == VDA_FUNC_SCSI) {\r\nif (reqstatus == RS_SCSI_ERROR) {\r\nif (rq->func_rsp.scsi_rsp.sense_len >= 13) {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"request failure - SCSI error %x ASC:%x ASCQ:%x CDB:%x",\r\nrq->sense_buf[2], rq->sense_buf[12],\r\nrq->sense_buf[13],\r\nrq->vrq->scsi.cdb[0]);\r\n} else {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"request failure - SCSI error CDB:%x\n",\r\nrq->vrq->scsi.cdb[0]);\r\n}\r\n} else if ((rq->vrq->scsi.cdb[0] != INQUIRY\r\n&& rq->vrq->scsi.cdb[0] != REPORT_LUNS)\r\n|| (reqstatus != RS_SEL\r\n&& reqstatus != RS_SEL2)) {\r\nif ((reqstatus == RS_UNDERRUN) &&\r\n(rq->vrq->scsi.cdb[0] == INQUIRY)) {\r\n} else {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"request failure - cdb:%x reqstatus:%d target:%d",\r\nrq->vrq->scsi.cdb[0], reqstatus,\r\nrq->target_id);\r\n}\r\n}\r\n}\r\n}\r\nvoid esas2r_wait_request(struct esas2r_adapter *a, struct esas2r_request *rq)\r\n{\r\nu32 starttime;\r\nu32 timeout;\r\nstarttime = jiffies_to_msecs(jiffies);\r\ntimeout = rq->timeout ? rq->timeout : 5000;\r\nwhile (true) {\r\nesas2r_polled_interrupt(a);\r\nif (rq->req_stat != RS_STARTED)\r\nbreak;\r\nschedule_timeout_interruptible(msecs_to_jiffies(100));\r\nif ((jiffies_to_msecs(jiffies) - starttime) > timeout) {\r\nesas2r_hdebug("request TMO");\r\nesas2r_bugon();\r\nrq->req_stat = RS_TIMEOUT;\r\nesas2r_local_reset_adapter(a);\r\nreturn;\r\n}\r\n}\r\n}\r\nu32 esas2r_map_data_window(struct esas2r_adapter *a, u32 addr_lo)\r\n{\r\nu32 offset = addr_lo & (MW_DATA_WINDOW_SIZE - 1);\r\nu32 base = addr_lo & -(signed int)MW_DATA_WINDOW_SIZE;\r\nif (a->window_base != base) {\r\nesas2r_write_register_dword(a, MVR_PCI_WIN1_REMAP,\r\nbase | MVRPW1R_ENABLE);\r\nesas2r_flush_register_dword(a, MVR_PCI_WIN1_REMAP);\r\na->window_base = base;\r\n}\r\nreturn offset;\r\n}\r\nbool esas2r_read_mem_block(struct esas2r_adapter *a,\r\nvoid *to,\r\nu32 from,\r\nu32 size)\r\n{\r\nu8 *end = (u8 *)to;\r\nwhile (size) {\r\nu32 len;\r\nu32 offset;\r\nu32 iatvr;\r\niatvr = (from & -(signed int)MW_DATA_WINDOW_SIZE);\r\nesas2r_map_data_window(a, iatvr);\r\noffset = from & (MW_DATA_WINDOW_SIZE - 1);\r\nlen = size;\r\nif (len > MW_DATA_WINDOW_SIZE - offset)\r\nlen = MW_DATA_WINDOW_SIZE - offset;\r\nfrom += len;\r\nsize -= len;\r\nwhile (len--) {\r\n*end++ = esas2r_read_data_byte(a, offset);\r\noffset++;\r\n}\r\n}\r\nreturn true;\r\n}\r\nvoid esas2r_nuxi_mgt_data(u8 function, void *data)\r\n{\r\nstruct atto_vda_grp_info *g;\r\nstruct atto_vda_devinfo *d;\r\nstruct atto_vdapart_info *p;\r\nstruct atto_vda_dh_info *h;\r\nstruct atto_vda_metrics_info *m;\r\nstruct atto_vda_schedule_info *s;\r\nstruct atto_vda_buzzer_info *b;\r\nu8 i;\r\nswitch (function) {\r\ncase VDAMGT_BUZZER_INFO:\r\ncase VDAMGT_BUZZER_SET:\r\nb = (struct atto_vda_buzzer_info *)data;\r\nb->duration = le32_to_cpu(b->duration);\r\nbreak;\r\ncase VDAMGT_SCHEDULE_INFO:\r\ncase VDAMGT_SCHEDULE_EVENT:\r\ns = (struct atto_vda_schedule_info *)data;\r\ns->id = le32_to_cpu(s->id);\r\nbreak;\r\ncase VDAMGT_DEV_INFO:\r\ncase VDAMGT_DEV_CLEAN:\r\ncase VDAMGT_DEV_PT_INFO:\r\ncase VDAMGT_DEV_FEATURES:\r\ncase VDAMGT_DEV_PT_FEATURES:\r\ncase VDAMGT_DEV_OPERATION:\r\nd = (struct atto_vda_devinfo *)data;\r\nd->capacity = le64_to_cpu(d->capacity);\r\nd->block_size = le32_to_cpu(d->block_size);\r\nd->ses_dev_index = le16_to_cpu(d->ses_dev_index);\r\nd->target_id = le16_to_cpu(d->target_id);\r\nd->lun = le16_to_cpu(d->lun);\r\nd->features = le16_to_cpu(d->features);\r\nbreak;\r\ncase VDAMGT_GRP_INFO:\r\ncase VDAMGT_GRP_CREATE:\r\ncase VDAMGT_GRP_DELETE:\r\ncase VDAMGT_ADD_STORAGE:\r\ncase VDAMGT_MEMBER_ADD:\r\ncase VDAMGT_GRP_COMMIT:\r\ncase VDAMGT_GRP_REBUILD:\r\ncase VDAMGT_GRP_COMMIT_INIT:\r\ncase VDAMGT_QUICK_RAID:\r\ncase VDAMGT_GRP_FEATURES:\r\ncase VDAMGT_GRP_COMMIT_INIT_AUTOMAP:\r\ncase VDAMGT_QUICK_RAID_INIT_AUTOMAP:\r\ncase VDAMGT_SPARE_LIST:\r\ncase VDAMGT_SPARE_ADD:\r\ncase VDAMGT_SPARE_REMOVE:\r\ncase VDAMGT_LOCAL_SPARE_ADD:\r\ncase VDAMGT_GRP_OPERATION:\r\ng = (struct atto_vda_grp_info *)data;\r\ng->capacity = le64_to_cpu(g->capacity);\r\ng->block_size = le32_to_cpu(g->block_size);\r\ng->interleave = le32_to_cpu(g->interleave);\r\ng->features = le16_to_cpu(g->features);\r\nfor (i = 0; i < 32; i++)\r\ng->members[i] = le16_to_cpu(g->members[i]);\r\nbreak;\r\ncase VDAMGT_PART_INFO:\r\ncase VDAMGT_PART_MAP:\r\ncase VDAMGT_PART_UNMAP:\r\ncase VDAMGT_PART_AUTOMAP:\r\ncase VDAMGT_PART_SPLIT:\r\ncase VDAMGT_PART_MERGE:\r\np = (struct atto_vdapart_info *)data;\r\np->part_size = le64_to_cpu(p->part_size);\r\np->start_lba = le32_to_cpu(p->start_lba);\r\np->block_size = le32_to_cpu(p->block_size);\r\np->target_id = le16_to_cpu(p->target_id);\r\nbreak;\r\ncase VDAMGT_DEV_HEALTH_REQ:\r\nh = (struct atto_vda_dh_info *)data;\r\nh->med_defect_cnt = le32_to_cpu(h->med_defect_cnt);\r\nh->info_exc_cnt = le32_to_cpu(h->info_exc_cnt);\r\nbreak;\r\ncase VDAMGT_DEV_METRICS:\r\nm = (struct atto_vda_metrics_info *)data;\r\nfor (i = 0; i < 32; i++)\r\nm->dev_indexes[i] = le16_to_cpu(m->dev_indexes[i]);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid esas2r_nuxi_cfg_data(u8 function, void *data)\r\n{\r\nstruct atto_vda_cfg_init *ci;\r\nswitch (function) {\r\ncase VDA_CFG_INIT:\r\ncase VDA_CFG_GET_INIT:\r\ncase VDA_CFG_GET_INIT2:\r\nci = (struct atto_vda_cfg_init *)data;\r\nci->date_time.year = le16_to_cpu(ci->date_time.year);\r\nci->sgl_page_size = le32_to_cpu(ci->sgl_page_size);\r\nci->vda_version = le32_to_cpu(ci->vda_version);\r\nci->epoch_time = le32_to_cpu(ci->epoch_time);\r\nci->ioctl_tunnel = le32_to_cpu(ci->ioctl_tunnel);\r\nci->num_targets_backend = le32_to_cpu(ci->num_targets_backend);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid esas2r_nuxi_ae_data(union atto_vda_ae *ae)\r\n{\r\nstruct atto_vda_ae_raid *r = &ae->raid;\r\nstruct atto_vda_ae_lu *l = &ae->lu;\r\nswitch (ae->hdr.bytype) {\r\ncase VDAAE_HDR_TYPE_RAID:\r\nr->dwflags = le32_to_cpu(r->dwflags);\r\nbreak;\r\ncase VDAAE_HDR_TYPE_LU:\r\nl->dwevent = le32_to_cpu(l->dwevent);\r\nl->wphys_target_id = le16_to_cpu(l->wphys_target_id);\r\nl->id.tgtlun.wtarget_id = le16_to_cpu(l->id.tgtlun.wtarget_id);\r\nif (l->hdr.bylength >= offsetof(struct atto_vda_ae_lu, id)\r\n+ sizeof(struct atto_vda_ae_lu_tgt_lun_raid)) {\r\nl->id.tgtlun_raid.dwinterleave\r\n= le32_to_cpu(l->id.tgtlun_raid.dwinterleave);\r\nl->id.tgtlun_raid.dwblock_size\r\n= le32_to_cpu(l->id.tgtlun_raid.dwblock_size);\r\n}\r\nbreak;\r\ncase VDAAE_HDR_TYPE_DISK:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid esas2r_free_request(struct esas2r_adapter *a, struct esas2r_request *rq)\r\n{\r\nunsigned long flags;\r\nesas2r_rq_destroy_request(rq, a);\r\nspin_lock_irqsave(&a->request_lock, flags);\r\nlist_add(&rq->comp_list, &a->avail_request);\r\nspin_unlock_irqrestore(&a->request_lock, flags);\r\n}\r\nstruct esas2r_request *esas2r_alloc_request(struct esas2r_adapter *a)\r\n{\r\nstruct esas2r_request *rq;\r\nunsigned long flags;\r\nspin_lock_irqsave(&a->request_lock, flags);\r\nif (unlikely(list_empty(&a->avail_request))) {\r\nspin_unlock_irqrestore(&a->request_lock, flags);\r\nreturn NULL;\r\n}\r\nrq = list_first_entry(&a->avail_request, struct esas2r_request,\r\ncomp_list);\r\nlist_del(&rq->comp_list);\r\nspin_unlock_irqrestore(&a->request_lock, flags);\r\nesas2r_rq_init_request(rq, a);\r\nreturn rq;\r\n}\r\nvoid esas2r_complete_request_cb(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nesas2r_debug("completing request %p\n", rq);\r\nscsi_dma_unmap(rq->cmd);\r\nif (unlikely(rq->req_stat != RS_SUCCESS)) {\r\nesas2r_debug("[%x STATUS %x:%x (%x)]", rq->target_id,\r\nrq->req_stat,\r\nrq->func_rsp.scsi_rsp.scsi_stat,\r\nrq->cmd);\r\nrq->cmd->result =\r\n((esas2r_req_status_to_error(rq->req_stat) << 16)\r\n| (rq->func_rsp.scsi_rsp.scsi_stat & STATUS_MASK));\r\nif (rq->req_stat == RS_UNDERRUN)\r\nscsi_set_resid(rq->cmd,\r\nle32_to_cpu(rq->func_rsp.scsi_rsp.\r\nresidual_length));\r\nelse\r\nscsi_set_resid(rq->cmd, 0);\r\n}\r\nrq->cmd->scsi_done(rq->cmd);\r\nesas2r_free_request(a, rq);\r\n}\r\nvoid esas2r_adapter_tasklet(unsigned long context)\r\n{\r\nstruct esas2r_adapter *a = (struct esas2r_adapter *)context;\r\nif (unlikely(test_bit(AF2_TIMER_TICK, &a->flags2))) {\r\nclear_bit(AF2_TIMER_TICK, &a->flags2);\r\nesas2r_timer_tick(a);\r\n}\r\nif (likely(test_bit(AF2_INT_PENDING, &a->flags2))) {\r\nclear_bit(AF2_INT_PENDING, &a->flags2);\r\nesas2r_adapter_interrupt(a);\r\n}\r\nif (esas2r_is_tasklet_pending(a))\r\nesas2r_do_tasklet_tasks(a);\r\nif (esas2r_is_tasklet_pending(a)\r\n|| (test_bit(AF2_INT_PENDING, &a->flags2))\r\n|| (test_bit(AF2_TIMER_TICK, &a->flags2))) {\r\nclear_bit(AF_TASKLET_SCHEDULED, &a->flags);\r\nesas2r_schedule_tasklet(a);\r\n} else {\r\nclear_bit(AF_TASKLET_SCHEDULED, &a->flags);\r\n}\r\n}\r\nvoid esas2r_kickoff_timer(struct esas2r_adapter *a)\r\n{\r\ninit_timer(&a->timer);\r\na->timer.function = esas2r_timer_callback;\r\na->timer.data = (unsigned long)a;\r\na->timer.expires = jiffies +\r\nmsecs_to_jiffies(100);\r\nadd_timer(&a->timer);\r\n}\r\nstatic void esas2r_timer_callback(unsigned long context)\r\n{\r\nstruct esas2r_adapter *a = (struct esas2r_adapter *)context;\r\nset_bit(AF2_TIMER_TICK, &a->flags2);\r\nesas2r_schedule_tasklet(a);\r\nesas2r_kickoff_timer(a);\r\n}\r\nstatic void\r\nesas2r_free_fw_event(struct esas2r_fw_event_work *fw_event)\r\n{\r\nunsigned long flags;\r\nstruct esas2r_adapter *a = fw_event->a;\r\nspin_lock_irqsave(&a->fw_event_lock, flags);\r\nlist_del(&fw_event->list);\r\nkfree(fw_event);\r\nspin_unlock_irqrestore(&a->fw_event_lock, flags);\r\n}\r\nvoid\r\nesas2r_fw_event_off(struct esas2r_adapter *a)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&a->fw_event_lock, flags);\r\na->fw_events_off = 1;\r\nspin_unlock_irqrestore(&a->fw_event_lock, flags);\r\n}\r\nvoid\r\nesas2r_fw_event_on(struct esas2r_adapter *a)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&a->fw_event_lock, flags);\r\na->fw_events_off = 0;\r\nspin_unlock_irqrestore(&a->fw_event_lock, flags);\r\n}\r\nstatic void esas2r_add_device(struct esas2r_adapter *a, u16 target_id)\r\n{\r\nint ret;\r\nstruct scsi_device *scsi_dev;\r\nscsi_dev = scsi_device_lookup(a->host, 0, target_id, 0);\r\nif (scsi_dev) {\r\nesas2r_log_dev(\r\nESAS2R_LOG_WARN,\r\n&(scsi_dev->\r\nsdev_gendev),\r\n"scsi device already exists at id %d", target_id);\r\nscsi_device_put(scsi_dev);\r\n} else {\r\nesas2r_log_dev(\r\nESAS2R_LOG_INFO,\r\n&(a->host->\r\nshost_gendev),\r\n"scsi_add_device() called for 0:%d:0",\r\ntarget_id);\r\nret = scsi_add_device(a->host, 0, target_id, 0);\r\nif (ret) {\r\nesas2r_log_dev(\r\nESAS2R_LOG_CRIT,\r\n&(a->host->\r\nshost_gendev),\r\n"scsi_add_device failed with %d for id %d",\r\nret, target_id);\r\n}\r\n}\r\n}\r\nstatic void esas2r_remove_device(struct esas2r_adapter *a, u16 target_id)\r\n{\r\nstruct scsi_device *scsi_dev;\r\nscsi_dev = scsi_device_lookup(a->host, 0, target_id, 0);\r\nif (scsi_dev) {\r\nscsi_device_set_state(scsi_dev, SDEV_OFFLINE);\r\nesas2r_log_dev(\r\nESAS2R_LOG_INFO,\r\n&(scsi_dev->\r\nsdev_gendev),\r\n"scsi_remove_device() called for 0:%d:0",\r\ntarget_id);\r\nscsi_remove_device(scsi_dev);\r\nesas2r_log_dev(\r\nESAS2R_LOG_INFO,\r\n&(scsi_dev->\r\nsdev_gendev),\r\n"scsi_device_put() called");\r\nscsi_device_put(scsi_dev);\r\n} else {\r\nesas2r_log_dev(\r\nESAS2R_LOG_WARN,\r\n&(a->host->shost_gendev),\r\n"no target found at id %d",\r\ntarget_id);\r\n}\r\n}\r\nstatic void esas2r_send_ae_event(struct esas2r_fw_event_work *fw_event)\r\n{\r\nstruct esas2r_vda_ae *ae = (struct esas2r_vda_ae *)fw_event->data;\r\nchar *type;\r\nswitch (ae->vda_ae.hdr.bytype) {\r\ncase VDAAE_HDR_TYPE_RAID:\r\ntype = "RAID group state change";\r\nbreak;\r\ncase VDAAE_HDR_TYPE_LU:\r\ntype = "Mapped destination LU change";\r\nbreak;\r\ncase VDAAE_HDR_TYPE_DISK:\r\ntype = "Physical disk inventory change";\r\nbreak;\r\ncase VDAAE_HDR_TYPE_RESET:\r\ntype = "Firmware reset";\r\nbreak;\r\ncase VDAAE_HDR_TYPE_LOG_INFO:\r\ntype = "Event Log message (INFO level)";\r\nbreak;\r\ncase VDAAE_HDR_TYPE_LOG_WARN:\r\ntype = "Event Log message (WARN level)";\r\nbreak;\r\ncase VDAAE_HDR_TYPE_LOG_CRIT:\r\ntype = "Event Log message (CRIT level)";\r\nbreak;\r\ncase VDAAE_HDR_TYPE_LOG_FAIL:\r\ntype = "Event Log message (FAIL level)";\r\nbreak;\r\ncase VDAAE_HDR_TYPE_NVC:\r\ntype = "NVCache change";\r\nbreak;\r\ncase VDAAE_HDR_TYPE_TLG_INFO:\r\ntype = "Time stamped log message (INFO level)";\r\nbreak;\r\ncase VDAAE_HDR_TYPE_TLG_WARN:\r\ntype = "Time stamped log message (WARN level)";\r\nbreak;\r\ncase VDAAE_HDR_TYPE_TLG_CRIT:\r\ntype = "Time stamped log message (CRIT level)";\r\nbreak;\r\ncase VDAAE_HDR_TYPE_PWRMGT:\r\ntype = "Power management";\r\nbreak;\r\ncase VDAAE_HDR_TYPE_MUTE:\r\ntype = "Mute button pressed";\r\nbreak;\r\ncase VDAAE_HDR_TYPE_DEV:\r\ntype = "Device attribute change";\r\nbreak;\r\ndefault:\r\ntype = "Unknown";\r\nbreak;\r\n}\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"An async event of type \"%s\" was received from the firmware. The event contents are:",\r\ntype);\r\nesas2r_log_hexdump(ESAS2R_LOG_WARN, &ae->vda_ae,\r\nae->vda_ae.hdr.bylength);\r\n}\r\nstatic void\r\nesas2r_firmware_event_work(struct work_struct *work)\r\n{\r\nstruct esas2r_fw_event_work *fw_event =\r\ncontainer_of(work, struct esas2r_fw_event_work, work.work);\r\nstruct esas2r_adapter *a = fw_event->a;\r\nu16 target_id = *(u16 *)&fw_event->data[0];\r\nif (a->fw_events_off)\r\ngoto done;\r\nswitch (fw_event->type) {\r\ncase fw_event_null:\r\nbreak;\r\ncase fw_event_lun_change:\r\nesas2r_remove_device(a, target_id);\r\nesas2r_add_device(a, target_id);\r\nbreak;\r\ncase fw_event_present:\r\nesas2r_add_device(a, target_id);\r\nbreak;\r\ncase fw_event_not_present:\r\nesas2r_remove_device(a, target_id);\r\nbreak;\r\ncase fw_event_vda_ae:\r\nesas2r_send_ae_event(fw_event);\r\nbreak;\r\n}\r\ndone:\r\nesas2r_free_fw_event(fw_event);\r\n}\r\nvoid esas2r_queue_fw_event(struct esas2r_adapter *a,\r\nenum fw_event_type type,\r\nvoid *data,\r\nint data_sz)\r\n{\r\nstruct esas2r_fw_event_work *fw_event;\r\nunsigned long flags;\r\nfw_event = kzalloc(sizeof(struct esas2r_fw_event_work), GFP_ATOMIC);\r\nif (!fw_event) {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"esas2r_queue_fw_event failed to alloc");\r\nreturn;\r\n}\r\nif (type == fw_event_vda_ae) {\r\nstruct esas2r_vda_ae *ae =\r\n(struct esas2r_vda_ae *)fw_event->data;\r\nae->signature = ESAS2R_VDA_EVENT_SIG;\r\nae->bus_number = a->pcid->bus->number;\r\nae->devfn = a->pcid->devfn;\r\nmemcpy(&ae->vda_ae, data, sizeof(ae->vda_ae));\r\n} else {\r\nmemcpy(fw_event->data, data, data_sz);\r\n}\r\nfw_event->type = type;\r\nfw_event->a = a;\r\nspin_lock_irqsave(&a->fw_event_lock, flags);\r\nlist_add_tail(&fw_event->list, &a->fw_event_list);\r\nINIT_DELAYED_WORK(&fw_event->work, esas2r_firmware_event_work);\r\nqueue_delayed_work_on(\r\nsmp_processor_id(), a->fw_event_q, &fw_event->work,\r\nmsecs_to_jiffies(1));\r\nspin_unlock_irqrestore(&a->fw_event_lock, flags);\r\n}\r\nvoid esas2r_target_state_changed(struct esas2r_adapter *a, u16 targ_id,\r\nu8 state)\r\n{\r\nif (state == TS_LUN_CHANGE)\r\nesas2r_queue_fw_event(a, fw_event_lun_change, &targ_id,\r\nsizeof(targ_id));\r\nelse if (state == TS_PRESENT)\r\nesas2r_queue_fw_event(a, fw_event_present, &targ_id,\r\nsizeof(targ_id));\r\nelse if (state == TS_NOT_PRESENT)\r\nesas2r_queue_fw_event(a, fw_event_not_present, &targ_id,\r\nsizeof(targ_id));\r\n}\r\nint esas2r_req_status_to_error(u8 req_stat)\r\n{\r\nswitch (req_stat) {\r\ncase RS_OVERRUN:\r\ncase RS_UNDERRUN:\r\ncase RS_SUCCESS:\r\ncase RS_SCSI_ERROR:\r\nreturn DID_OK;\r\ncase RS_SEL:\r\ncase RS_SEL2:\r\nreturn DID_NO_CONNECT;\r\ncase RS_RESET:\r\nreturn DID_RESET;\r\ncase RS_ABORTED:\r\nreturn DID_ABORT;\r\ncase RS_BUSY:\r\nreturn DID_BUS_BUSY;\r\n}\r\nreturn DID_ERROR;\r\n}
