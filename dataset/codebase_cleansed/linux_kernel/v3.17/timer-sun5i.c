static void sun5i_clkevt_sync(void)\r\n{\r\nu32 old = readl(timer_base + TIMER_CNTVAL_LO_REG(1));\r\nwhile ((old - readl(timer_base + TIMER_CNTVAL_LO_REG(1))) < TIMER_SYNC_TICKS)\r\ncpu_relax();\r\n}\r\nstatic void sun5i_clkevt_time_stop(u8 timer)\r\n{\r\nu32 val = readl(timer_base + TIMER_CTL_REG(timer));\r\nwritel(val & ~TIMER_CTL_ENABLE, timer_base + TIMER_CTL_REG(timer));\r\nsun5i_clkevt_sync();\r\n}\r\nstatic void sun5i_clkevt_time_setup(u8 timer, u32 delay)\r\n{\r\nwritel(delay, timer_base + TIMER_INTVAL_LO_REG(timer));\r\n}\r\nstatic void sun5i_clkevt_time_start(u8 timer, bool periodic)\r\n{\r\nu32 val = readl(timer_base + TIMER_CTL_REG(timer));\r\nif (periodic)\r\nval &= ~TIMER_CTL_ONESHOT;\r\nelse\r\nval |= TIMER_CTL_ONESHOT;\r\nwritel(val | TIMER_CTL_ENABLE | TIMER_CTL_RELOAD,\r\ntimer_base + TIMER_CTL_REG(timer));\r\n}\r\nstatic void sun5i_clkevt_mode(enum clock_event_mode mode,\r\nstruct clock_event_device *clk)\r\n{\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\nsun5i_clkevt_time_stop(0);\r\nsun5i_clkevt_time_setup(0, ticks_per_jiffy);\r\nsun5i_clkevt_time_start(0, true);\r\nbreak;\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\nsun5i_clkevt_time_stop(0);\r\nsun5i_clkevt_time_start(0, false);\r\nbreak;\r\ncase CLOCK_EVT_MODE_UNUSED:\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\ndefault:\r\nsun5i_clkevt_time_stop(0);\r\nbreak;\r\n}\r\n}\r\nstatic int sun5i_clkevt_next_event(unsigned long evt,\r\nstruct clock_event_device *unused)\r\n{\r\nsun5i_clkevt_time_stop(0);\r\nsun5i_clkevt_time_setup(0, evt - TIMER_SYNC_TICKS);\r\nsun5i_clkevt_time_start(0, false);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t sun5i_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = (struct clock_event_device *)dev_id;\r\nwritel(0x1, timer_base + TIMER_IRQ_ST_REG);\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic u64 sun5i_timer_sched_read(void)\r\n{\r\nreturn ~readl(timer_base + TIMER_CNTVAL_LO_REG(1));\r\n}\r\nstatic void __init sun5i_timer_init(struct device_node *node)\r\n{\r\nstruct reset_control *rstc;\r\nunsigned long rate;\r\nstruct clk *clk;\r\nint ret, irq;\r\nu32 val;\r\ntimer_base = of_iomap(node, 0);\r\nif (!timer_base)\r\npanic("Can't map registers");\r\nirq = irq_of_parse_and_map(node, 0);\r\nif (irq <= 0)\r\npanic("Can't parse IRQ");\r\nclk = of_clk_get(node, 0);\r\nif (IS_ERR(clk))\r\npanic("Can't get timer clock");\r\nclk_prepare_enable(clk);\r\nrate = clk_get_rate(clk);\r\nrstc = of_reset_control_get(node, NULL);\r\nif (!IS_ERR(rstc))\r\nreset_control_deassert(rstc);\r\nwritel(~0, timer_base + TIMER_INTVAL_LO_REG(1));\r\nwritel(TIMER_CTL_ENABLE | TIMER_CTL_RELOAD,\r\ntimer_base + TIMER_CTL_REG(1));\r\nsched_clock_register(sun5i_timer_sched_read, 32, rate);\r\nclocksource_mmio_init(timer_base + TIMER_CNTVAL_LO_REG(1), node->name,\r\nrate, 340, 32, clocksource_mmio_readl_down);\r\nticks_per_jiffy = DIV_ROUND_UP(rate, HZ);\r\nret = setup_irq(irq, &sun5i_timer_irq);\r\nif (ret)\r\npr_warn("failed to setup irq %d\n", irq);\r\nval = readl(timer_base + TIMER_IRQ_EN_REG);\r\nwritel(val | TIMER_IRQ_EN(0), timer_base + TIMER_IRQ_EN_REG);\r\nsun5i_clockevent.cpumask = cpu_possible_mask;\r\nsun5i_clockevent.irq = irq;\r\nclockevents_config_and_register(&sun5i_clockevent, rate,\r\nTIMER_SYNC_TICKS, 0xffffffff);\r\n}
