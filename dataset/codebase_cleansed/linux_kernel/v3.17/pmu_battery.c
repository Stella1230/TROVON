static int pmu_get_ac_prop(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = (!!(pmu_power_flags & PMU_PWR_AC_PRESENT)) ||\r\n(pmu_battery_count == 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic char *pmu_bat_get_model_name(struct pmu_battery_info *pbi)\r\n{\r\nswitch (pbi->flags & PMU_BATT_TYPE_MASK) {\r\ncase PMU_BATT_TYPE_SMART:\r\nreturn pmu_batt_types[0];\r\ncase PMU_BATT_TYPE_COMET:\r\nreturn pmu_batt_types[1];\r\ncase PMU_BATT_TYPE_HOOPER:\r\nreturn pmu_batt_types[2];\r\ndefault: break;\r\n}\r\nreturn pmu_batt_types[3];\r\n}\r\nstatic int pmu_bat_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct pmu_battery_dev *pbat = to_pmu_battery_dev(psy);\r\nstruct pmu_battery_info *pbi = pbat->pbi;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nif (pbi->flags & PMU_BATT_CHARGING)\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\nelse if (pmu_power_flags & PMU_PWR_AC_PRESENT)\r\nval->intval = POWER_SUPPLY_STATUS_FULL;\r\nelse\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nval->intval = !!(pbi->flags & PMU_BATT_PRESENT);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MODEL_NAME:\r\nval->strval = pmu_bat_get_model_name(pbi);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ENERGY_AVG:\r\nval->intval = pbi->charge * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ENERGY_FULL:\r\nval->intval = pbi->max_charge * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_AVG:\r\nval->intval = pbi->amperage * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_AVG:\r\nval->intval = pbi->voltage * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:\r\nval->intval = pbi->time_remaining;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init pmu_bat_init(void)\r\n{\r\nint ret;\r\nint i;\r\nbat_pdev = platform_device_register_simple("pmu-battery",\r\n0, NULL, 0);\r\nif (IS_ERR(bat_pdev)) {\r\nret = PTR_ERR(bat_pdev);\r\ngoto pdev_register_failed;\r\n}\r\nret = power_supply_register(&bat_pdev->dev, &pmu_ac);\r\nif (ret)\r\ngoto ac_register_failed;\r\nfor (i = 0; i < pmu_battery_count; i++) {\r\nstruct pmu_battery_dev *pbat = kzalloc(sizeof(*pbat),\r\nGFP_KERNEL);\r\nif (!pbat)\r\nbreak;\r\nsprintf(pbat->name, "PMU_battery_%d", i);\r\npbat->bat.name = pbat->name;\r\npbat->bat.properties = pmu_bat_props;\r\npbat->bat.num_properties = ARRAY_SIZE(pmu_bat_props);\r\npbat->bat.get_property = pmu_bat_get_property;\r\npbat->pbi = &pmu_batteries[i];\r\nret = power_supply_register(&bat_pdev->dev, &pbat->bat);\r\nif (ret) {\r\nkfree(pbat);\r\ngoto battery_register_failed;\r\n}\r\npbats[i] = pbat;\r\n}\r\ngoto success;\r\nbattery_register_failed:\r\nwhile (i--) {\r\nif (!pbats[i])\r\ncontinue;\r\npower_supply_unregister(&pbats[i]->bat);\r\nkfree(pbats[i]);\r\n}\r\npower_supply_unregister(&pmu_ac);\r\nac_register_failed:\r\nplatform_device_unregister(bat_pdev);\r\npdev_register_failed:\r\nsuccess:\r\nreturn ret;\r\n}\r\nstatic void __exit pmu_bat_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < PMU_MAX_BATTERIES; i++) {\r\nif (!pbats[i])\r\ncontinue;\r\npower_supply_unregister(&pbats[i]->bat);\r\nkfree(pbats[i]);\r\n}\r\npower_supply_unregister(&pmu_ac);\r\nplatform_device_unregister(bat_pdev);\r\n}
