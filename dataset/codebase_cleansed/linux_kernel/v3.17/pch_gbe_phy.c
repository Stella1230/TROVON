s32 pch_gbe_phy_get_id(struct pch_gbe_hw *hw)\r\n{\r\nstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\r\nstruct pch_gbe_phy_info *phy = &hw->phy;\r\ns32 ret;\r\nu16 phy_id1;\r\nu16 phy_id2;\r\nret = pch_gbe_phy_read_reg_miic(hw, PHY_ID1, &phy_id1);\r\nif (ret)\r\nreturn ret;\r\nret = pch_gbe_phy_read_reg_miic(hw, PHY_ID2, &phy_id2);\r\nif (ret)\r\nreturn ret;\r\nphy->id = (u32)phy_id1;\r\nphy->id = ((phy->id << 6) | ((phy_id2 & 0xFC00) >> 10));\r\nphy->revision = (u32) (phy_id2 & 0x000F);\r\nnetdev_dbg(adapter->netdev,\r\n"phy->id : 0x%08x phy->revision : 0x%08x\n",\r\nphy->id, phy->revision);\r\nreturn 0;\r\n}\r\ns32 pch_gbe_phy_read_reg_miic(struct pch_gbe_hw *hw, u32 offset, u16 *data)\r\n{\r\nstruct pch_gbe_phy_info *phy = &hw->phy;\r\nif (offset > PHY_MAX_REG_ADDRESS) {\r\nstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\r\nnetdev_err(adapter->netdev, "PHY Address %d is out of range\n",\r\noffset);\r\nreturn -EINVAL;\r\n}\r\n*data = pch_gbe_mac_ctrl_miim(hw, phy->addr, PCH_GBE_HAL_MIIM_READ,\r\noffset, (u16)0);\r\nreturn 0;\r\n}\r\ns32 pch_gbe_phy_write_reg_miic(struct pch_gbe_hw *hw, u32 offset, u16 data)\r\n{\r\nstruct pch_gbe_phy_info *phy = &hw->phy;\r\nif (offset > PHY_MAX_REG_ADDRESS) {\r\nstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\r\nnetdev_err(adapter->netdev, "PHY Address %d is out of range\n",\r\noffset);\r\nreturn -EINVAL;\r\n}\r\npch_gbe_mac_ctrl_miim(hw, phy->addr, PCH_GBE_HAL_MIIM_WRITE,\r\noffset, data);\r\nreturn 0;\r\n}\r\nvoid pch_gbe_phy_sw_reset(struct pch_gbe_hw *hw)\r\n{\r\nu16 phy_ctrl;\r\npch_gbe_phy_read_reg_miic(hw, PHY_CONTROL, &phy_ctrl);\r\nphy_ctrl |= MII_CR_RESET;\r\npch_gbe_phy_write_reg_miic(hw, PHY_CONTROL, phy_ctrl);\r\nudelay(1);\r\n}\r\nvoid pch_gbe_phy_hw_reset(struct pch_gbe_hw *hw)\r\n{\r\npch_gbe_phy_write_reg_miic(hw, PHY_CONTROL, PHY_CONTROL_DEFAULT);\r\npch_gbe_phy_write_reg_miic(hw, PHY_AUTONEG_ADV,\r\nPHY_AUTONEG_ADV_DEFAULT);\r\npch_gbe_phy_write_reg_miic(hw, PHY_NEXT_PAGE_TX,\r\nPHY_NEXT_PAGE_TX_DEFAULT);\r\npch_gbe_phy_write_reg_miic(hw, PHY_1000T_CTRL, PHY_1000T_CTRL_DEFAULT);\r\npch_gbe_phy_write_reg_miic(hw, PHY_PHYSP_CONTROL,\r\nPHY_PHYSP_CONTROL_DEFAULT);\r\n}\r\nvoid pch_gbe_phy_power_up(struct pch_gbe_hw *hw)\r\n{\r\nu16 mii_reg;\r\nmii_reg = 0;\r\npch_gbe_phy_read_reg_miic(hw, PHY_CONTROL, &mii_reg);\r\nmii_reg &= ~MII_CR_POWER_DOWN;\r\npch_gbe_phy_write_reg_miic(hw, PHY_CONTROL, mii_reg);\r\n}\r\nvoid pch_gbe_phy_power_down(struct pch_gbe_hw *hw)\r\n{\r\nu16 mii_reg;\r\nmii_reg = 0;\r\npch_gbe_phy_read_reg_miic(hw, PHY_CONTROL, &mii_reg);\r\nmii_reg |= MII_CR_POWER_DOWN;\r\npch_gbe_phy_write_reg_miic(hw, PHY_CONTROL, mii_reg);\r\nmdelay(1);\r\n}\r\nvoid pch_gbe_phy_set_rgmii(struct pch_gbe_hw *hw)\r\n{\r\npch_gbe_phy_sw_reset(hw);\r\n}\r\nstatic int pch_gbe_phy_tx_clk_delay(struct pch_gbe_hw *hw)\r\n{\r\nstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\r\nu16 mii_reg;\r\nint ret = 0;\r\nswitch (hw->phy.id) {\r\ncase PHY_AR803X_ID:\r\nnetdev_dbg(adapter->netdev,\r\n"Configuring AR803X PHY for 2ns TX clock delay\n");\r\npch_gbe_phy_read_reg_miic(hw, PHY_AR8031_DBG_OFF, &mii_reg);\r\nret = pch_gbe_phy_write_reg_miic(hw, PHY_AR8031_DBG_OFF,\r\nPHY_AR8031_SERDES);\r\nif (ret)\r\nbreak;\r\npch_gbe_phy_read_reg_miic(hw, PHY_AR8031_DBG_DAT, &mii_reg);\r\nmii_reg |= PHY_AR8031_SERDES_TX_CLK_DLY;\r\nret = pch_gbe_phy_write_reg_miic(hw, PHY_AR8031_DBG_DAT,\r\nmii_reg);\r\nbreak;\r\ndefault:\r\nnetdev_err(adapter->netdev,\r\n"Unknown PHY (%x), could not set TX clock delay\n",\r\nhw->phy.id);\r\nreturn -EINVAL;\r\n}\r\nif (ret)\r\nnetdev_err(adapter->netdev,\r\n"Could not configure tx clock delay for PHY\n");\r\nreturn ret;\r\n}\r\nvoid pch_gbe_phy_init_setting(struct pch_gbe_hw *hw)\r\n{\r\nstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\r\nstruct ethtool_cmd cmd = { .cmd = ETHTOOL_GSET };\r\nint ret;\r\nu16 mii_reg;\r\nret = mii_ethtool_gset(&adapter->mii, &cmd);\r\nif (ret)\r\nnetdev_err(adapter->netdev, "Error: mii_ethtool_gset\n");\r\nethtool_cmd_speed_set(&cmd, hw->mac.link_speed);\r\ncmd.duplex = hw->mac.link_duplex;\r\ncmd.advertising = hw->phy.autoneg_advertised;\r\ncmd.autoneg = hw->mac.autoneg;\r\npch_gbe_phy_write_reg_miic(hw, MII_BMCR, BMCR_RESET);\r\nret = mii_ethtool_sset(&adapter->mii, &cmd);\r\nif (ret)\r\nnetdev_err(adapter->netdev, "Error: mii_ethtool_sset\n");\r\npch_gbe_phy_sw_reset(hw);\r\npch_gbe_phy_read_reg_miic(hw, PHY_PHYSP_CONTROL, &mii_reg);\r\nmii_reg |= PHYSP_CTRL_ASSERT_CRS_TX;\r\npch_gbe_phy_write_reg_miic(hw, PHY_PHYSP_CONTROL, mii_reg);\r\nif (adapter->pdata && adapter->pdata->phy_tx_clk_delay)\r\npch_gbe_phy_tx_clk_delay(hw);\r\n}\r\nint pch_gbe_phy_disable_hibernate(struct pch_gbe_hw *hw)\r\n{\r\nstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\r\nu16 mii_reg;\r\nint ret = 0;\r\nswitch (hw->phy.id) {\r\ncase PHY_AR803X_ID:\r\nnetdev_dbg(adapter->netdev,\r\n"Disabling hibernation for AR803X PHY\n");\r\nret = pch_gbe_phy_write_reg_miic(hw, PHY_AR8031_DBG_OFF,\r\nPHY_AR8031_HIBERNATE);\r\nif (ret)\r\nbreak;\r\npch_gbe_phy_read_reg_miic(hw, PHY_AR8031_DBG_DAT, &mii_reg);\r\nmii_reg &= ~PHY_AR8031_PS_HIB_EN;\r\nret = pch_gbe_phy_write_reg_miic(hw, PHY_AR8031_DBG_DAT,\r\nmii_reg);\r\nbreak;\r\ndefault:\r\nnetdev_err(adapter->netdev,\r\n"Unknown PHY (%x), could not disable hibernation\n",\r\nhw->phy.id);\r\nreturn -EINVAL;\r\n}\r\nif (ret)\r\nnetdev_err(adapter->netdev,\r\n"Could not disable PHY hibernation\n");\r\nreturn ret;\r\n}
