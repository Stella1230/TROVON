static void do_queue_select(struct rtw_adapter *padapter, struct pkt_attrib *pattrib)\r\n{\r\nu8 qsel;\r\nqsel = pattrib->priority;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,\r\n("### do_queue_select priority =%d , qsel = %d\n",\r\npattrib->priority, qsel));\r\npattrib->qsel = qsel;\r\n}\r\nstatic int urb_zero_packet_chk(struct rtw_adapter *padapter, int sz)\r\n{\r\nint blnSetTxDescOffset;\r\nstruct dvobj_priv *pdvobj = adapter_to_dvobj(padapter);\r\nif (pdvobj->ishighspeed) {\r\nif (((sz + TXDESC_SIZE) % 512) == 0)\r\nblnSetTxDescOffset = 1;\r\nelse\r\nblnSetTxDescOffset = 0;\r\n} else {\r\nif (((sz + TXDESC_SIZE) % 64) == 0)\r\nblnSetTxDescOffset = 1;\r\nelse\r\nblnSetTxDescOffset = 0;\r\n}\r\nreturn blnSetTxDescOffset;\r\n}\r\nstatic void rtl8192cu_cal_txdesc_chksum(struct tx_desc *ptxdesc)\r\n{\r\nu16 *usPtr = (u16 *)ptxdesc;\r\nu32 count = 16;\r\nu32 index;\r\nu16 checksum = 0;\r\nptxdesc->txdw7 &= cpu_to_le32(0xffff0000);\r\nfor (index = 0 ; index < count ; index++)\r\nchecksum = checksum ^ le16_to_cpu(*(usPtr + index));\r\nptxdesc->txdw7 |= cpu_to_le32(0x0000ffff&checksum);\r\n}\r\nstatic void fill_txdesc_sectype(struct pkt_attrib *pattrib, struct tx_desc *ptxdesc)\r\n{\r\nif ((pattrib->encrypt > 0) && !pattrib->bswenc) {\r\nswitch (pattrib->encrypt) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nptxdesc->txdw1 |= cpu_to_le32((0x01<<22)&0x00c00000);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nptxdesc->txdw1 |= cpu_to_le32((0x01<<22)&0x00c00000);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nptxdesc->txdw1 |= cpu_to_le32((0x03<<22)&0x00c00000);\r\nbreak;\r\ncase 0:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void fill_txdesc_vcs(struct pkt_attrib *pattrib, u32 *pdw)\r\n{\r\nswitch (pattrib->vcs_mode) {\r\ncase RTS_CTS:\r\n*pdw |= cpu_to_le32(BIT(12));\r\nbreak;\r\ncase CTS_TO_SELF:\r\n*pdw |= cpu_to_le32(BIT(11));\r\nbreak;\r\ncase NONE_VCS:\r\ndefault:\r\nbreak;\r\n}\r\nif (pattrib->vcs_mode) {\r\n*pdw |= cpu_to_le32(BIT(13));\r\nif (pattrib->ht_en) {\r\n*pdw |= (pattrib->bwmode&HT_CHANNEL_WIDTH_40) ? cpu_to_le32(BIT(27)) : 0;\r\nif (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_LOWER)\r\n*pdw |= cpu_to_le32((0x01<<28)&0x30000000);\r\nelse if (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_UPPER)\r\n*pdw |= cpu_to_le32((0x02<<28)&0x30000000);\r\nelse if (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE)\r\n*pdw |= 0;\r\nelse\r\n*pdw |= cpu_to_le32((0x03<<28)&0x30000000);\r\n}\r\n}\r\n}\r\nstatic void fill_txdesc_phy(struct pkt_attrib *pattrib, u32 *pdw)\r\n{\r\nif (pattrib->ht_en) {\r\n*pdw |= (pattrib->bwmode&HT_CHANNEL_WIDTH_40) ? cpu_to_le32(BIT(25)) : 0;\r\nif (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_LOWER)\r\n*pdw |= cpu_to_le32((0x01<<20)&0x003f0000);\r\nelse if (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_UPPER)\r\n*pdw |= cpu_to_le32((0x02<<20)&0x003f0000);\r\nelse if (pattrib->ch_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE)\r\n*pdw |= 0;\r\nelse\r\n*pdw |= cpu_to_le32((0x03<<20)&0x003f0000);\r\n}\r\n}\r\nstatic s32 update_txdesc(struct xmit_frame *pxmitframe, u8 *pmem, s32 sz, u8 bagg_pkt)\r\n{\r\nint pull = 0;\r\nuint qsel;\r\nstruct rtw_adapter *padapter = pxmitframe->padapter;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct dm_priv *pdmpriv = &pHalData->dmpriv;\r\nstruct tx_desc *ptxdesc = (struct tx_desc *)pmem;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nint bmcst = is_multicast_ether_addr(pattrib->ra);\r\nif ((!bagg_pkt) && (urb_zero_packet_chk(padapter, sz) == 0)) {\r\nptxdesc = (struct tx_desc *)(pmem+PACKET_OFFSET_SZ);\r\npull = 1;\r\npxmitframe->pkt_offset--;\r\n}\r\nmemset(ptxdesc, 0, sizeof(struct tx_desc));\r\nif ((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG) {\r\nptxdesc->txdw1 |= cpu_to_le32(pattrib->mac_id&0x1f);\r\nqsel = (uint)(pattrib->qsel & 0x0000001f);\r\nptxdesc->txdw1 |= cpu_to_le32((qsel << QSEL_SHT) & 0x00001f00);\r\nptxdesc->txdw1 |= cpu_to_le32((pattrib->raid<<16) & 0x000f0000);\r\nfill_txdesc_sectype(pattrib, ptxdesc);\r\nif (pattrib->ampdu_en)\r\nptxdesc->txdw1 |= cpu_to_le32(BIT(5));\r\nelse\r\nptxdesc->txdw1 |= cpu_to_le32(BIT(6));\r\nptxdesc->txdw3 |= cpu_to_le32((pattrib->seqnum<<16)&0xffff0000);\r\nif (pattrib->qos_en)\r\nptxdesc->txdw4 |= cpu_to_le32(BIT(6));\r\nif ((pattrib->ether_type != 0x888e) &&\r\n(pattrib->ether_type != 0x0806) &&\r\n(pattrib->dhcp_pkt != 1)) {\r\nfill_txdesc_vcs(pattrib, &ptxdesc->txdw4);\r\nfill_txdesc_phy(pattrib, &ptxdesc->txdw4);\r\nptxdesc->txdw4 |= cpu_to_le32(0x00000008);\r\nptxdesc->txdw5 |= cpu_to_le32(0x0001ff00);\r\nptxdesc->txdw5 |= cpu_to_le32(pdmpriv->INIDATA_RATE[pattrib->mac_id]);\r\n} else {\r\nptxdesc->txdw1 |= cpu_to_le32(BIT(6));\r\nptxdesc->txdw4 |= cpu_to_le32(BIT(8));\r\nif (pmlmeinfo->preamble_mode == PREAMBLE_SHORT)\r\nptxdesc->txdw4 |= cpu_to_le32(BIT(24));\r\nptxdesc->txdw5 |= cpu_to_le32(MRateToHwRate23a(pmlmeext->tx_rate));\r\n}\r\n} else if ((pxmitframe->frame_tag&0x0f) == MGNT_FRAMETAG) {\r\nptxdesc->txdw1 |= cpu_to_le32(pattrib->mac_id&0x1f);\r\nqsel = (uint)(pattrib->qsel&0x0000001f);\r\nptxdesc->txdw1 |= cpu_to_le32((qsel<<QSEL_SHT)&0x00001f00);\r\nptxdesc->txdw1 |= cpu_to_le32((pattrib->raid<<16) & 0x000f0000);\r\nif (pxmitframe->ack_report)\r\nptxdesc->txdw2 |= cpu_to_le32(BIT(19));\r\nptxdesc->txdw3 |= cpu_to_le32((pattrib->seqnum<<16)&0xffff0000);\r\nptxdesc->txdw4 |= cpu_to_le32(BIT(8));\r\nptxdesc->txdw5 |= cpu_to_le32(BIT(17));\r\nptxdesc->txdw5 |= cpu_to_le32(0x00180000);\r\nptxdesc->txdw5 |= cpu_to_le32(MRateToHwRate23a(pmlmeext->tx_rate));\r\n} else if ((pxmitframe->frame_tag&0x0f) == TXAGG_FRAMETAG) {\r\nDBG_8723A("pxmitframe->frame_tag == TXAGG_FRAMETAG\n");\r\n} else {\r\nDBG_8723A("pxmitframe->frame_tag = %d\n", pxmitframe->frame_tag);\r\nptxdesc->txdw1 |= cpu_to_le32((4)&0x1f);\r\nptxdesc->txdw1 |= cpu_to_le32((6<<16) & 0x000f0000);\r\nptxdesc->txdw3 |= cpu_to_le32((pattrib->seqnum<<16)&0xffff0000);\r\nptxdesc->txdw4 |= cpu_to_le32(BIT(8));\r\nptxdesc->txdw5 |= cpu_to_le32(MRateToHwRate23a(pmlmeext->tx_rate));\r\n}\r\nif (!pattrib->qos_en) {\r\nptxdesc->txdw4 |= cpu_to_le32(BIT(7));\r\nptxdesc->txdw3 |= cpu_to_le32((8 << 28));\r\n}\r\nptxdesc->txdw0 |= cpu_to_le32(sz&0x0000ffff);\r\nptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);\r\nptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE+OFFSET_SZ)<<OFFSET_SHT)&0x00ff0000);\r\nif (bmcst)\r\nptxdesc->txdw0 |= cpu_to_le32(BIT(24));\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("offset0-txdesc = 0x%x\n", ptxdesc->txdw0));\r\nif (pxmitframe->pkt_offset > 0)\r\nptxdesc->txdw1 |= cpu_to_le32((pxmitframe->pkt_offset << 26) & 0x7c000000);\r\nrtl8192cu_cal_txdesc_chksum(ptxdesc);\r\nreturn pull;\r\n}\r\nstatic int rtw_dump_xframe(struct rtw_adapter *padapter,\r\nstruct xmit_frame *pxmitframe)\r\n{\r\nint ret = _SUCCESS;\r\nint inner_ret = _SUCCESS;\r\nint t, sz, w_sz, pull = 0;\r\nu8 *mem_addr;\r\nu32 ff_hwaddr;\r\nstruct xmit_buf *pxmitbuf = pxmitframe->pxmitbuf;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nif ((pxmitframe->frame_tag == DATA_FRAMETAG) &&\r\n(pxmitframe->attrib.ether_type != 0x0806) &&\r\n(pxmitframe->attrib.ether_type != 0x888e) &&\r\n(pxmitframe->attrib.dhcp_pkt != 1))\r\nrtw_issue_addbareq_cmd23a(padapter, pxmitframe);\r\nmem_addr = pxmitframe->buf_addr;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("rtw_dump_xframe()\n"));\r\nfor (t = 0; t < pattrib->nr_frags; t++) {\r\nif (inner_ret != _SUCCESS && ret == _SUCCESS)\r\nret = _FAIL;\r\nif (t != (pattrib->nr_frags - 1)) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,\r\n("pattrib->nr_frags =%d\n", pattrib->nr_frags));\r\nsz = pxmitpriv->frag_len;\r\nsz = sz - 4 - pattrib->icv_len;\r\n} else {\r\nsz = pattrib->last_txcmdsz;\r\n}\r\npull = update_txdesc(pxmitframe, mem_addr, sz, false);\r\nif (pull) {\r\nmem_addr += PACKET_OFFSET_SZ;\r\npxmitframe->buf_addr = mem_addr;\r\nw_sz = sz + TXDESC_SIZE;\r\n} else {\r\nw_sz = sz + TXDESC_SIZE + PACKET_OFFSET_SZ;\r\n}\r\nff_hwaddr = rtw_get_ff_hwaddr23a(pxmitframe);\r\ninner_ret = rtl8723au_write_port(padapter, ff_hwaddr,\r\nw_sz, pxmitbuf);\r\nrtw_count_tx_stats23a(padapter, pxmitframe, sz);\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_,\r\n("rtw_write_port, w_sz =%d\n", w_sz));\r\nmem_addr += w_sz;\r\nmem_addr = PTR_ALIGN(mem_addr, 4);\r\n}\r\nrtw_free_xmitframe23a(pxmitpriv, pxmitframe);\r\nif (ret != _SUCCESS)\r\nrtw23a_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_UNKNOWN);\r\nreturn ret;\r\n}\r\nbool rtl8723au_xmitframe_complete(struct rtw_adapter *padapter,\r\nstruct xmit_priv *pxmitpriv,\r\nstruct xmit_buf *pxmitbuf)\r\n{\r\nstruct hw_xmit *phwxmits;\r\nstruct xmit_frame *pxmitframe;\r\nint hwentry;\r\nint res = _SUCCESS, xcnt = 0;\r\nphwxmits = pxmitpriv->hwxmits;\r\nhwentry = pxmitpriv->hwxmit_entry;\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("xmitframe_complete()\n"));\r\nif (pxmitbuf == NULL) {\r\npxmitbuf = rtw_alloc_xmitbuf23a(pxmitpriv);\r\nif (!pxmitbuf)\r\nreturn false;\r\n}\r\npxmitframe = rtw_dequeue_xframe23a(pxmitpriv, phwxmits, hwentry);\r\nif (pxmitframe) {\r\npxmitframe->pxmitbuf = pxmitbuf;\r\npxmitframe->buf_addr = pxmitbuf->pbuf;\r\npxmitbuf->priv_data = pxmitframe;\r\nif ((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG) {\r\nif (pxmitframe->attrib.priority <= 15)\r\nres = rtw_xmitframe_coalesce23a(padapter, pxmitframe->pkt, pxmitframe);\r\nrtw_os_xmit_complete23a(padapter, pxmitframe);\r\n}\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_info_, ("xmitframe_complete(): rtw_dump_xframe\n"));\r\nif (res == _SUCCESS) {\r\nrtw_dump_xframe(padapter, pxmitframe);\r\n} else {\r\nrtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);\r\nrtw_free_xmitframe23a(pxmitpriv, pxmitframe);\r\n}\r\nxcnt++;\r\n} else {\r\nrtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int xmitframe_direct(struct rtw_adapter *padapter,\r\nstruct xmit_frame *pxmitframe)\r\n{\r\nint res;\r\nres = rtw_xmitframe_coalesce23a(padapter, pxmitframe->pkt, pxmitframe);\r\nif (res == _SUCCESS)\r\nrtw_dump_xframe(padapter, pxmitframe);\r\nreturn res;\r\n}\r\nbool rtl8723au_hal_xmit(struct rtw_adapter *padapter,\r\nstruct xmit_frame *pxmitframe)\r\n{\r\nint res;\r\nstruct xmit_buf *pxmitbuf = NULL;\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\ndo_queue_select(padapter, pattrib);\r\nspin_lock_bh(&pxmitpriv->lock);\r\n#ifdef CONFIG_8723AU_AP_MODE\r\nif (xmitframe_enqueue_for_sleeping_sta23a(padapter, pxmitframe)) {\r\nstruct sta_info *psta;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nspin_unlock_bh(&pxmitpriv->lock);\r\nif (pattrib->psta)\r\npsta = pattrib->psta;\r\nelse\r\npsta = rtw_get_stainfo23a(pstapriv, pattrib->ra);\r\nif (psta) {\r\nif (psta->sleepq_len > (NR_XMITFRAME>>3))\r\nwakeup_sta_to_xmit23a(padapter, psta);\r\n}\r\nreturn false;\r\n}\r\n#endif\r\nif (rtw_txframes_sta_ac_pending23a(padapter, pattrib) > 0)\r\ngoto enqueue;\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)\r\ngoto enqueue;\r\npxmitbuf = rtw_alloc_xmitbuf23a(pxmitpriv);\r\nif (pxmitbuf == NULL)\r\ngoto enqueue;\r\nspin_unlock_bh(&pxmitpriv->lock);\r\npxmitframe->pxmitbuf = pxmitbuf;\r\npxmitframe->buf_addr = pxmitbuf->pbuf;\r\npxmitbuf->priv_data = pxmitframe;\r\nif (xmitframe_direct(padapter, pxmitframe) != _SUCCESS) {\r\nrtw_free_xmitbuf23a(pxmitpriv, pxmitbuf);\r\nrtw_free_xmitframe23a(pxmitpriv, pxmitframe);\r\n}\r\nreturn true;\r\nenqueue:\r\nres = rtw_xmitframe_enqueue23a(padapter, pxmitframe);\r\nspin_unlock_bh(&pxmitpriv->lock);\r\nif (res != _SUCCESS) {\r\nRT_TRACE(_module_xmit_osdep_c_, _drv_err_,\r\n("pre_xmitframe: enqueue xmitframe fail\n"));\r\nrtw_free_xmitframe23a(pxmitpriv, pxmitframe);\r\npxmitpriv->tx_pkts--;\r\npxmitpriv->tx_drop++;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nint rtl8723au_mgnt_xmit(struct rtw_adapter *padapter,\r\nstruct xmit_frame *pmgntframe)\r\n{\r\nreturn rtw_dump_xframe(padapter, pmgntframe);\r\n}\r\nint rtl8723au_hal_xmitframe_enqueue(struct rtw_adapter *padapter,\r\nstruct xmit_frame *pxmitframe)\r\n{\r\nstruct xmit_priv *pxmitpriv = &padapter->xmitpriv;\r\nint err;\r\nerr = rtw_xmitframe_enqueue23a(padapter, pxmitframe);\r\nif (err != _SUCCESS) {\r\nrtw_free_xmitframe23a(pxmitpriv, pxmitframe);\r\npxmitpriv->tx_pkts--;\r\npxmitpriv->tx_drop++;\r\n} else {\r\ntasklet_hi_schedule(&pxmitpriv->xmit_tasklet);\r\n}\r\nreturn err;\r\n}
