static inline void assert_server_locked(struct ncp_server *server)\r\n{\r\nif (server->lock == 0) {\r\nncp_dbg(1, "server not locked!\n");\r\n}\r\n}\r\nstatic void ncp_add_byte(struct ncp_server *server, __u8 x)\r\n{\r\nassert_server_locked(server);\r\n*(__u8 *) (&(server->packet[server->current_size])) = x;\r\nserver->current_size += 1;\r\nreturn;\r\n}\r\nstatic void ncp_add_word(struct ncp_server *server, __le16 x)\r\n{\r\nassert_server_locked(server);\r\nput_unaligned(x, (__le16 *) (&(server->packet[server->current_size])));\r\nserver->current_size += 2;\r\nreturn;\r\n}\r\nstatic void ncp_add_be16(struct ncp_server *server, __u16 x)\r\n{\r\nassert_server_locked(server);\r\nput_unaligned(cpu_to_be16(x), (__be16 *) (&(server->packet[server->current_size])));\r\nserver->current_size += 2;\r\n}\r\nstatic void ncp_add_dword(struct ncp_server *server, __le32 x)\r\n{\r\nassert_server_locked(server);\r\nput_unaligned(x, (__le32 *) (&(server->packet[server->current_size])));\r\nserver->current_size += 4;\r\nreturn;\r\n}\r\nstatic void ncp_add_be32(struct ncp_server *server, __u32 x)\r\n{\r\nassert_server_locked(server);\r\nput_unaligned(cpu_to_be32(x), (__be32 *)(&(server->packet[server->current_size])));\r\nserver->current_size += 4;\r\n}\r\nstatic inline void ncp_add_dword_lh(struct ncp_server *server, __u32 x) {\r\nncp_add_dword(server, cpu_to_le32(x));\r\n}\r\nstatic void ncp_add_mem(struct ncp_server *server, const void *source, int size)\r\n{\r\nassert_server_locked(server);\r\nmemcpy(&(server->packet[server->current_size]), source, size);\r\nserver->current_size += size;\r\nreturn;\r\n}\r\nstatic void ncp_add_pstring(struct ncp_server *server, const char *s)\r\n{\r\nint len = strlen(s);\r\nassert_server_locked(server);\r\nif (len > 255) {\r\nncp_dbg(1, "string too long: %s\n", s);\r\nlen = 255;\r\n}\r\nncp_add_byte(server, len);\r\nncp_add_mem(server, s, len);\r\nreturn;\r\n}\r\nstatic inline void ncp_init_request(struct ncp_server *server)\r\n{\r\nncp_lock_server(server);\r\nserver->current_size = sizeof(struct ncp_request_header);\r\nserver->has_subfunction = 0;\r\n}\r\nstatic inline void ncp_init_request_s(struct ncp_server *server, int subfunction)\r\n{\r\nncp_lock_server(server);\r\nserver->current_size = sizeof(struct ncp_request_header) + 2;\r\nncp_add_byte(server, subfunction);\r\nserver->has_subfunction = 1;\r\n}\r\nstatic inline char *\r\nncp_reply_data(struct ncp_server *server, int offset)\r\n{\r\nreturn &(server->packet[sizeof(struct ncp_reply_header) + offset]);\r\n}\r\nstatic inline u8 BVAL(const void *data)\r\n{\r\nreturn *(const u8 *)data;\r\n}\r\nstatic u8 ncp_reply_byte(struct ncp_server *server, int offset)\r\n{\r\nreturn *(const u8 *)ncp_reply_data(server, offset);\r\n}\r\nstatic inline u16 WVAL_LH(const void *data)\r\n{\r\nreturn get_unaligned_le16(data);\r\n}\r\nstatic u16\r\nncp_reply_le16(struct ncp_server *server, int offset)\r\n{\r\nreturn get_unaligned_le16(ncp_reply_data(server, offset));\r\n}\r\nstatic u16\r\nncp_reply_be16(struct ncp_server *server, int offset)\r\n{\r\nreturn get_unaligned_be16(ncp_reply_data(server, offset));\r\n}\r\nstatic inline u32 DVAL_LH(const void *data)\r\n{\r\nreturn get_unaligned_le32(data);\r\n}\r\nstatic __le32\r\nncp_reply_dword(struct ncp_server *server, int offset)\r\n{\r\nreturn get_unaligned((__le32 *)ncp_reply_data(server, offset));\r\n}\r\nstatic inline __u32 ncp_reply_dword_lh(struct ncp_server* server, int offset) {\r\nreturn le32_to_cpu(ncp_reply_dword(server, offset));\r\n}\r\nint\r\nncp_negotiate_buffersize(struct ncp_server *server, int size, int *target)\r\n{\r\nint result;\r\nncp_init_request(server);\r\nncp_add_be16(server, size);\r\nif ((result = ncp_request(server, 33)) != 0) {\r\nncp_unlock_server(server);\r\nreturn result;\r\n}\r\n*target = min_t(unsigned int, ncp_reply_be16(server, 0), size);\r\nncp_unlock_server(server);\r\nreturn 0;\r\n}\r\nint\r\nncp_negotiate_size_and_options(struct ncp_server *server,\r\nint size, int options, int *ret_size, int *ret_options) {\r\nint result;\r\nif (size < NCP_BLOCK_SIZE) size = NCP_BLOCK_SIZE;\r\nncp_init_request(server);\r\nncp_add_be16(server, size);\r\nncp_add_byte(server, options);\r\nif ((result = ncp_request(server, 0x61)) != 0)\r\n{\r\nncp_unlock_server(server);\r\nreturn result;\r\n}\r\nresult = ncp_reply_be16(server, 0);\r\nif (result >= NCP_BLOCK_SIZE)\r\nsize = min(result, size);\r\n*ret_size = size;\r\n*ret_options = ncp_reply_byte(server, 4);\r\nncp_unlock_server(server);\r\nreturn 0;\r\n}\r\nint ncp_get_volume_info_with_number(struct ncp_server* server,\r\nint n, struct ncp_volume_info* target) {\r\nint result;\r\nint len;\r\nncp_init_request_s(server, 44);\r\nncp_add_byte(server, n);\r\nif ((result = ncp_request(server, 22)) != 0) {\r\ngoto out;\r\n}\r\ntarget->total_blocks = ncp_reply_dword_lh(server, 0);\r\ntarget->free_blocks = ncp_reply_dword_lh(server, 4);\r\ntarget->purgeable_blocks = ncp_reply_dword_lh(server, 8);\r\ntarget->not_yet_purgeable_blocks = ncp_reply_dword_lh(server, 12);\r\ntarget->total_dir_entries = ncp_reply_dword_lh(server, 16);\r\ntarget->available_dir_entries = ncp_reply_dword_lh(server, 20);\r\ntarget->sectors_per_block = ncp_reply_byte(server, 28);\r\nmemset(&(target->volume_name), 0, sizeof(target->volume_name));\r\nresult = -EIO;\r\nlen = ncp_reply_byte(server, 29);\r\nif (len > NCP_VOLNAME_LEN) {\r\nncp_dbg(1, "volume name too long: %d\n", len);\r\ngoto out;\r\n}\r\nmemcpy(&(target->volume_name), ncp_reply_data(server, 30), len);\r\nresult = 0;\r\nout:\r\nncp_unlock_server(server);\r\nreturn result;\r\n}\r\nint ncp_get_directory_info(struct ncp_server* server, __u8 n,\r\nstruct ncp_volume_info* target) {\r\nint result;\r\nint len;\r\nncp_init_request_s(server, 45);\r\nncp_add_byte(server, n);\r\nif ((result = ncp_request(server, 22)) != 0) {\r\ngoto out;\r\n}\r\ntarget->total_blocks = ncp_reply_dword_lh(server, 0);\r\ntarget->free_blocks = ncp_reply_dword_lh(server, 4);\r\ntarget->purgeable_blocks = 0;\r\ntarget->not_yet_purgeable_blocks = 0;\r\ntarget->total_dir_entries = ncp_reply_dword_lh(server, 8);\r\ntarget->available_dir_entries = ncp_reply_dword_lh(server, 12);\r\ntarget->sectors_per_block = ncp_reply_byte(server, 20);\r\nmemset(&(target->volume_name), 0, sizeof(target->volume_name));\r\nresult = -EIO;\r\nlen = ncp_reply_byte(server, 21);\r\nif (len > NCP_VOLNAME_LEN) {\r\nncp_dbg(1, "volume name too long: %d\n", len);\r\ngoto out;\r\n}\r\nmemcpy(&(target->volume_name), ncp_reply_data(server, 22), len);\r\nresult = 0;\r\nout:\r\nncp_unlock_server(server);\r\nreturn result;\r\n}\r\nint\r\nncp_close_file(struct ncp_server *server, const char *file_id)\r\n{\r\nint result;\r\nncp_init_request(server);\r\nncp_add_byte(server, 0);\r\nncp_add_mem(server, file_id, 6);\r\nresult = ncp_request(server, 66);\r\nncp_unlock_server(server);\r\nreturn result;\r\n}\r\nint\r\nncp_make_closed(struct inode *inode)\r\n{\r\nint err;\r\nerr = 0;\r\nmutex_lock(&NCP_FINFO(inode)->open_mutex);\r\nif (atomic_read(&NCP_FINFO(inode)->opened) == 1) {\r\natomic_set(&NCP_FINFO(inode)->opened, 0);\r\nerr = ncp_close_file(NCP_SERVER(inode), NCP_FINFO(inode)->file_handle);\r\nif (!err)\r\nncp_vdbg("volnum=%d, dirent=%u, error=%d\n",\r\nNCP_FINFO(inode)->volNumber,\r\nNCP_FINFO(inode)->dirEntNum, err);\r\n}\r\nmutex_unlock(&NCP_FINFO(inode)->open_mutex);\r\nreturn err;\r\n}\r\nstatic void ncp_add_handle_path(struct ncp_server *server, __u8 vol_num,\r\n__le32 dir_base, int have_dir_base,\r\nconst char *path)\r\n{\r\nncp_add_byte(server, vol_num);\r\nncp_add_dword(server, dir_base);\r\nif (have_dir_base != 0) {\r\nncp_add_byte(server, 1);\r\n} else {\r\nncp_add_byte(server, 0xff);\r\n}\r\nif (path != NULL) {\r\nncp_add_byte(server, 1);\r\nncp_add_pstring(server, path);\r\n} else {\r\nncp_add_byte(server, 0);\r\n}\r\n}\r\nint ncp_dirhandle_alloc(struct ncp_server* server, __u8 volnum, __le32 dirent,\r\n__u8* dirhandle) {\r\nint result;\r\nncp_init_request(server);\r\nncp_add_byte(server, 12);\r\nncp_add_byte(server, NW_NS_DOS);\r\nncp_add_byte(server, 0);\r\nncp_add_word(server, 0);\r\nncp_add_handle_path(server, volnum, dirent, 1, NULL);\r\nif ((result = ncp_request(server, 87)) == 0) {\r\n*dirhandle = ncp_reply_byte(server, 0);\r\n}\r\nncp_unlock_server(server);\r\nreturn result;\r\n}\r\nint ncp_dirhandle_free(struct ncp_server* server, __u8 dirhandle) {\r\nint result;\r\nncp_init_request_s(server, 20);\r\nncp_add_byte(server, dirhandle);\r\nresult = ncp_request(server, 22);\r\nncp_unlock_server(server);\r\nreturn result;\r\n}\r\nvoid ncp_extract_file_info(const void *structure, struct nw_info_struct *target)\r\n{\r\nconst __u8 *name_len;\r\nconst int info_struct_size = offsetof(struct nw_info_struct, nameLen);\r\nmemcpy(target, structure, info_struct_size);\r\nname_len = structure + info_struct_size;\r\ntarget->nameLen = *name_len;\r\nmemcpy(target->entryName, name_len + 1, *name_len);\r\ntarget->entryName[*name_len] = '\0';\r\ntarget->volNumber = le32_to_cpu(target->volNumber);\r\nreturn;\r\n}\r\nstatic inline void ncp_extract_nfs_info(const unsigned char *structure,\r\nstruct nw_nfs_info *target)\r\n{\r\ntarget->mode = DVAL_LH(structure);\r\ntarget->rdev = DVAL_LH(structure + 8);\r\n}\r\nint ncp_obtain_nfs_info(struct ncp_server *server,\r\nstruct nw_info_struct *target)\r\n{\r\nint result = 0;\r\n#ifdef CONFIG_NCPFS_NFS_NS\r\n__u32 volnum = target->volNumber;\r\nif (ncp_is_nfs_extras(server, volnum)) {\r\nncp_init_request(server);\r\nncp_add_byte(server, 19);\r\nncp_add_byte(server, server->name_space[volnum]);\r\nncp_add_byte(server, NW_NS_NFS);\r\nncp_add_byte(server, 0);\r\nncp_add_byte(server, volnum);\r\nncp_add_dword(server, target->dirEntNum);\r\nncp_add_dword_lh(server, NSIBM_NFS_MODE | NSIBM_NFS_NLINKS | NSIBM_NFS_RDEV);\r\nif ((result = ncp_request(server, 87)) == 0) {\r\nncp_extract_nfs_info(ncp_reply_data(server, 0), &target->nfs);\r\nncp_dbg(1, "(%s) mode=0%o, rdev=0x%x\n",\r\ntarget->entryName, target->nfs.mode,\r\ntarget->nfs.rdev);\r\n} else {\r\ntarget->nfs.mode = 0;\r\ntarget->nfs.rdev = 0;\r\n}\r\nncp_unlock_server(server);\r\n} else\r\n#endif\r\n{\r\ntarget->nfs.mode = 0;\r\ntarget->nfs.rdev = 0;\r\n}\r\nreturn result;\r\n}\r\nint ncp_obtain_info(struct ncp_server *server, struct inode *dir, const char *path,\r\nstruct nw_info_struct *target)\r\n{\r\n__u8 volnum = NCP_FINFO(dir)->volNumber;\r\n__le32 dirent = NCP_FINFO(dir)->dirEntNum;\r\nint result;\r\nif (target == NULL) {\r\npr_err("%s: invalid call\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nncp_init_request(server);\r\nncp_add_byte(server, 6);\r\nncp_add_byte(server, server->name_space[volnum]);\r\nncp_add_byte(server, server->name_space[volnum]);\r\nncp_add_word(server, cpu_to_le16(0x8006));\r\nncp_add_dword(server, RIM_ALL);\r\nncp_add_handle_path(server, volnum, dirent, 1, path);\r\nif ((result = ncp_request(server, 87)) != 0)\r\ngoto out;\r\nncp_extract_file_info(ncp_reply_data(server, 0), target);\r\nncp_unlock_server(server);\r\nresult = ncp_obtain_nfs_info(server, target);\r\nreturn result;\r\nout:\r\nncp_unlock_server(server);\r\nreturn result;\r\n}\r\nstatic int\r\nncp_obtain_DOS_dir_base(struct ncp_server *server,\r\n__u8 ns, __u8 volnum, __le32 dirent,\r\nconst char *path,\r\n__le32 *DOS_dir_base)\r\n{\r\nint result;\r\nncp_init_request(server);\r\nncp_add_byte(server, 6);\r\nncp_add_byte(server, ns);\r\nncp_add_byte(server, ns);\r\nncp_add_word(server, cpu_to_le16(0x8006));\r\nncp_add_dword(server, RIM_DIRECTORY);\r\nncp_add_handle_path(server, volnum, dirent, 1, path);\r\nif ((result = ncp_request(server, 87)) == 0)\r\n{\r\nif (DOS_dir_base) *DOS_dir_base=ncp_reply_dword(server, 0x34);\r\n}\r\nncp_unlock_server(server);\r\nreturn result;\r\n}\r\nstatic inline int\r\nncp_get_known_namespace(struct ncp_server *server, __u8 volume)\r\n{\r\n#if defined(CONFIG_NCPFS_OS2_NS) || defined(CONFIG_NCPFS_NFS_NS)\r\nint result;\r\n__u8 *namespace;\r\n__u16 no_namespaces;\r\nncp_init_request(server);\r\nncp_add_byte(server, 24);\r\nncp_add_word(server, 0);\r\nncp_add_byte(server, volume);\r\nif ((result = ncp_request(server, 87)) != 0) {\r\nncp_unlock_server(server);\r\nreturn NW_NS_DOS;\r\n}\r\nresult = NW_NS_DOS;\r\nno_namespaces = ncp_reply_le16(server, 0);\r\nnamespace = ncp_reply_data(server, 2);\r\nwhile (no_namespaces > 0) {\r\nncp_dbg(1, "found %d on %d\n", *namespace, volume);\r\n#ifdef CONFIG_NCPFS_NFS_NS\r\nif ((*namespace == NW_NS_NFS) && !(server->m.flags&NCP_MOUNT_NO_NFS))\r\n{\r\nresult = NW_NS_NFS;\r\nbreak;\r\n}\r\n#endif\r\n#ifdef CONFIG_NCPFS_OS2_NS\r\nif ((*namespace == NW_NS_OS2) && !(server->m.flags&NCP_MOUNT_NO_OS2))\r\n{\r\nresult = NW_NS_OS2;\r\n}\r\n#endif\r\nnamespace += 1;\r\nno_namespaces -= 1;\r\n}\r\nncp_unlock_server(server);\r\nreturn result;\r\n#else\r\nreturn NW_NS_DOS;\r\n#endif\r\n}\r\nint\r\nncp_update_known_namespace(struct ncp_server *server, __u8 volume, int *ret_ns)\r\n{\r\nint ns = ncp_get_known_namespace(server, volume);\r\nif (ret_ns)\r\n*ret_ns = ns;\r\nncp_dbg(1, "namespace[%d] = %d\n", volume, server->name_space[volume]);\r\nif (server->name_space[volume] == ns)\r\nreturn 0;\r\nserver->name_space[volume] = ns;\r\nreturn 1;\r\n}\r\nstatic int\r\nncp_ObtainSpecificDirBase(struct ncp_server *server,\r\n__u8 nsSrc, __u8 nsDst, __u8 vol_num, __le32 dir_base,\r\nconst char *path,\r\n__le32 *dirEntNum, __le32 *DosDirNum)\r\n{\r\nint result;\r\nncp_init_request(server);\r\nncp_add_byte(server, 6);\r\nncp_add_byte(server, nsSrc);\r\nncp_add_byte(server, nsDst);\r\nncp_add_word(server, cpu_to_le16(0x8006));\r\nncp_add_dword(server, RIM_ALL);\r\nncp_add_handle_path(server, vol_num, dir_base, 1, path);\r\nif ((result = ncp_request(server, 87)) != 0)\r\n{\r\nncp_unlock_server(server);\r\nreturn result;\r\n}\r\nif (dirEntNum)\r\n*dirEntNum = ncp_reply_dword(server, 0x30);\r\nif (DosDirNum)\r\n*DosDirNum = ncp_reply_dword(server, 0x34);\r\nncp_unlock_server(server);\r\nreturn 0;\r\n}\r\nint\r\nncp_mount_subdir(struct ncp_server *server,\r\n__u8 volNumber, __u8 srcNS, __le32 dirEntNum,\r\n__u32* volume, __le32* newDirEnt, __le32* newDosEnt)\r\n{\r\nint dstNS;\r\nint result;\r\nncp_update_known_namespace(server, volNumber, &dstNS);\r\nif ((result = ncp_ObtainSpecificDirBase(server, srcNS, dstNS, volNumber,\r\ndirEntNum, NULL, newDirEnt, newDosEnt)) != 0)\r\n{\r\nreturn result;\r\n}\r\n*volume = volNumber;\r\nserver->m.mounted_vol[1] = 0;\r\nserver->m.mounted_vol[0] = 'X';\r\nreturn 0;\r\n}\r\nint\r\nncp_get_volume_root(struct ncp_server *server,\r\nconst char *volname, __u32* volume, __le32* dirent, __le32* dosdirent)\r\n{\r\nint result;\r\nncp_dbg(1, "looking up vol %s\n", volname);\r\nncp_init_request(server);\r\nncp_add_byte(server, 22);\r\nncp_add_byte(server, 0);\r\nncp_add_byte(server, 0);\r\nncp_add_byte(server, 0);\r\nncp_add_byte(server, 0);\r\nncp_add_byte(server, 0);\r\nncp_add_dword(server, 0);\r\nncp_add_byte(server, 0xff);\r\nncp_add_byte(server, 1);\r\nncp_add_pstring(server, volname);\r\nif ((result = ncp_request(server, 87)) != 0) {\r\nncp_unlock_server(server);\r\nreturn result;\r\n}\r\n*dirent = *dosdirent = ncp_reply_dword(server, 4);\r\n*volume = ncp_reply_byte(server, 8);\r\nncp_unlock_server(server);\r\nreturn 0;\r\n}\r\nint\r\nncp_lookup_volume(struct ncp_server *server,\r\nconst char *volname, struct nw_info_struct *target)\r\n{\r\nint result;\r\nmemset(target, 0, sizeof(*target));\r\nresult = ncp_get_volume_root(server, volname,\r\n&target->volNumber, &target->dirEntNum, &target->DosDirNum);\r\nif (result) {\r\nreturn result;\r\n}\r\nncp_update_known_namespace(server, target->volNumber, NULL);\r\ntarget->nameLen = strlen(volname);\r\nmemcpy(target->entryName, volname, target->nameLen+1);\r\ntarget->attributes = aDIR;\r\ntarget->creationTime = target->modifyTime = cpu_to_le16(0x0000);\r\ntarget->creationDate = target->modifyDate = target->lastAccessDate = cpu_to_le16(0x0C21);\r\ntarget->nfs.mode = 0;\r\nreturn 0;\r\n}\r\nint ncp_modify_file_or_subdir_dos_info_path(struct ncp_server *server,\r\nstruct inode *dir,\r\nconst char *path,\r\n__le32 info_mask,\r\nconst struct nw_modify_dos_info *info)\r\n{\r\n__u8 volnum = NCP_FINFO(dir)->volNumber;\r\n__le32 dirent = NCP_FINFO(dir)->dirEntNum;\r\nint result;\r\nncp_init_request(server);\r\nncp_add_byte(server, 7);\r\nncp_add_byte(server, server->name_space[volnum]);\r\nncp_add_byte(server, 0);\r\nncp_add_word(server, cpu_to_le16(0x8006));\r\nncp_add_dword(server, info_mask);\r\nncp_add_mem(server, info, sizeof(*info));\r\nncp_add_handle_path(server, volnum, dirent, 1, path);\r\nresult = ncp_request(server, 87);\r\nncp_unlock_server(server);\r\nreturn result;\r\n}\r\nint ncp_modify_file_or_subdir_dos_info(struct ncp_server *server,\r\nstruct inode *dir,\r\n__le32 info_mask,\r\nconst struct nw_modify_dos_info *info)\r\n{\r\nreturn ncp_modify_file_or_subdir_dos_info_path(server, dir, NULL,\r\ninfo_mask, info);\r\n}\r\nint ncp_modify_nfs_info(struct ncp_server *server, __u8 volnum, __le32 dirent,\r\n__u32 mode, __u32 rdev)\r\n{\r\nint result = 0;\r\nncp_init_request(server);\r\nif (server->name_space[volnum] == NW_NS_NFS) {\r\nncp_add_byte(server, 25);\r\nncp_add_byte(server, server->name_space[volnum]);\r\nncp_add_byte(server, NW_NS_NFS);\r\nncp_add_byte(server, volnum);\r\nncp_add_dword(server, dirent);\r\nncp_add_dword_lh(server, NSIBM_NFS_MODE | NSIBM_NFS_NLINKS | NSIBM_NFS_RDEV);\r\nncp_add_dword_lh(server, mode);\r\nncp_add_dword_lh(server, 1);\r\nncp_add_dword_lh(server, rdev);\r\nresult = ncp_request(server, 87);\r\n}\r\nncp_unlock_server(server);\r\nreturn result;\r\n}\r\nstatic int\r\nncp_DeleteNSEntry(struct ncp_server *server,\r\n__u8 have_dir_base, __u8 volnum, __le32 dirent,\r\nconst char* name, __u8 ns, __le16 attr)\r\n{\r\nint result;\r\nncp_init_request(server);\r\nncp_add_byte(server, 8);\r\nncp_add_byte(server, ns);\r\nncp_add_byte(server, 0);\r\nncp_add_word(server, attr);\r\nncp_add_handle_path(server, volnum, dirent, have_dir_base, name);\r\nresult = ncp_request(server, 87);\r\nncp_unlock_server(server);\r\nreturn result;\r\n}\r\nint\r\nncp_del_file_or_subdir2(struct ncp_server *server,\r\nstruct dentry *dentry)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\n__u8 volnum;\r\n__le32 dirent;\r\nif (!inode) {\r\nreturn 0xFF;\r\n}\r\nvolnum = NCP_FINFO(inode)->volNumber;\r\ndirent = NCP_FINFO(inode)->DosDirNum;\r\nreturn ncp_DeleteNSEntry(server, 1, volnum, dirent, NULL, NW_NS_DOS, cpu_to_le16(0x8006));\r\n}\r\nint\r\nncp_del_file_or_subdir(struct ncp_server *server,\r\nstruct inode *dir, const char *name)\r\n{\r\n__u8 volnum = NCP_FINFO(dir)->volNumber;\r\n__le32 dirent = NCP_FINFO(dir)->dirEntNum;\r\nint name_space;\r\nname_space = server->name_space[volnum];\r\n#ifdef CONFIG_NCPFS_NFS_NS\r\nif (name_space == NW_NS_NFS)\r\n{\r\nint result;\r\nresult=ncp_obtain_DOS_dir_base(server, name_space, volnum, dirent, name, &dirent);\r\nif (result) return result;\r\nname = NULL;\r\nname_space = NW_NS_DOS;\r\n}\r\n#endif\r\nreturn ncp_DeleteNSEntry(server, 1, volnum, dirent, name, name_space, cpu_to_le16(0x8006));\r\n}\r\nstatic inline void ConvertToNWfromDWORD(__u16 v0, __u16 v1, __u8 ret[6])\r\n{\r\n__le16 *dest = (__le16 *) ret;\r\ndest[1] = cpu_to_le16(v0);\r\ndest[2] = cpu_to_le16(v1);\r\ndest[0] = cpu_to_le16(v0 + 1);\r\nreturn;\r\n}\r\nint ncp_open_create_file_or_subdir(struct ncp_server *server,\r\nstruct inode *dir, const char *name,\r\nint open_create_mode,\r\n__le32 create_attributes,\r\n__le16 desired_acc_rights,\r\nstruct ncp_entry_info *target)\r\n{\r\n__le16 search_attribs = cpu_to_le16(0x0006);\r\n__u8 volnum;\r\n__le32 dirent;\r\nint result;\r\nvolnum = NCP_FINFO(dir)->volNumber;\r\ndirent = NCP_FINFO(dir)->dirEntNum;\r\nif ((create_attributes & aDIR) != 0) {\r\nsearch_attribs |= cpu_to_le16(0x8000);\r\n}\r\nncp_init_request(server);\r\nncp_add_byte(server, 1);\r\nncp_add_byte(server, server->name_space[volnum]);\r\nncp_add_byte(server, open_create_mode);\r\nncp_add_word(server, search_attribs);\r\nncp_add_dword(server, RIM_ALL);\r\nncp_add_dword(server, create_attributes);\r\nncp_add_word(server, desired_acc_rights);\r\nncp_add_handle_path(server, volnum, dirent, 1, name);\r\nif ((result = ncp_request(server, 87)) != 0)\r\ngoto out;\r\nif (!(create_attributes & aDIR))\r\ntarget->opened = 1;\r\nncp_extract_file_info(ncp_reply_data(server, 6), &(target->i));\r\ntarget->volume = target->i.volNumber;\r\nConvertToNWfromDWORD(ncp_reply_le16(server, 0),\r\nncp_reply_le16(server, 2),\r\ntarget->file_handle);\r\nncp_unlock_server(server);\r\n(void)ncp_obtain_nfs_info(server, &(target->i));\r\nreturn 0;\r\nout:\r\nncp_unlock_server(server);\r\nreturn result;\r\n}\r\nint\r\nncp_initialize_search(struct ncp_server *server, struct inode *dir,\r\nstruct nw_search_sequence *target)\r\n{\r\n__u8 volnum = NCP_FINFO(dir)->volNumber;\r\n__le32 dirent = NCP_FINFO(dir)->dirEntNum;\r\nint result;\r\nncp_init_request(server);\r\nncp_add_byte(server, 2);\r\nncp_add_byte(server, server->name_space[volnum]);\r\nncp_add_byte(server, 0);\r\nncp_add_handle_path(server, volnum, dirent, 1, NULL);\r\nresult = ncp_request(server, 87);\r\nif (result)\r\ngoto out;\r\nmemcpy(target, ncp_reply_data(server, 0), sizeof(*target));\r\nout:\r\nncp_unlock_server(server);\r\nreturn result;\r\n}\r\nint ncp_search_for_fileset(struct ncp_server *server,\r\nstruct nw_search_sequence *seq,\r\nint* more,\r\nint* cnt,\r\nchar* buffer,\r\nsize_t bufsize,\r\nchar** rbuf,\r\nsize_t* rsize)\r\n{\r\nint result;\r\nncp_init_request(server);\r\nncp_add_byte(server, 20);\r\nncp_add_byte(server, server->name_space[seq->volNumber]);\r\nncp_add_byte(server, 0);\r\nncp_add_word(server, cpu_to_le16(0x8006));\r\nncp_add_dword(server, RIM_ALL);\r\nncp_add_word(server, cpu_to_le16(32767));\r\nncp_add_mem(server, seq, 9);\r\n#ifdef CONFIG_NCPFS_NFS_NS\r\nif (server->name_space[seq->volNumber] == NW_NS_NFS) {\r\nncp_add_byte(server, 0);\r\n} else\r\n#endif\r\n{\r\nncp_add_byte(server, 2);\r\nncp_add_byte(server, 0xff);\r\nncp_add_byte(server, '*');\r\n}\r\nresult = ncp_request2(server, 87, buffer, bufsize);\r\nif (result) {\r\nncp_unlock_server(server);\r\nreturn result;\r\n}\r\nif (server->ncp_reply_size < 12) {\r\nncp_unlock_server(server);\r\nreturn 0xFF;\r\n}\r\n*rsize = server->ncp_reply_size - 12;\r\nncp_unlock_server(server);\r\nbuffer = buffer + sizeof(struct ncp_reply_header);\r\n*rbuf = buffer + 12;\r\n*cnt = WVAL_LH(buffer + 10);\r\n*more = BVAL(buffer + 9);\r\nmemcpy(seq, buffer, 9);\r\nreturn 0;\r\n}\r\nstatic int\r\nncp_RenameNSEntry(struct ncp_server *server,\r\nstruct inode *old_dir, const char *old_name, __le16 old_type,\r\nstruct inode *new_dir, const char *new_name)\r\n{\r\nint result = -EINVAL;\r\nif ((old_dir == NULL) || (old_name == NULL) ||\r\n(new_dir == NULL) || (new_name == NULL))\r\ngoto out;\r\nncp_init_request(server);\r\nncp_add_byte(server, 4);\r\nncp_add_byte(server, server->name_space[NCP_FINFO(old_dir)->volNumber]);\r\nncp_add_byte(server, 1);\r\nncp_add_word(server, old_type);\r\nncp_add_byte(server, NCP_FINFO(old_dir)->volNumber);\r\nncp_add_dword(server, NCP_FINFO(old_dir)->dirEntNum);\r\nncp_add_byte(server, 1);\r\nncp_add_byte(server, 1);\r\nncp_add_byte(server, NCP_FINFO(new_dir)->volNumber);\r\nncp_add_dword(server, NCP_FINFO(new_dir)->dirEntNum);\r\nncp_add_byte(server, 1);\r\nncp_add_byte(server, 1);\r\nncp_add_pstring(server, old_name);\r\nncp_add_pstring(server, new_name);\r\nresult = ncp_request(server, 87);\r\nncp_unlock_server(server);\r\nout:\r\nreturn result;\r\n}\r\nint ncp_ren_or_mov_file_or_subdir(struct ncp_server *server,\r\nstruct inode *old_dir, const char *old_name,\r\nstruct inode *new_dir, const char *new_name)\r\n{\r\nint result;\r\n__le16 old_type = cpu_to_le16(0x06);\r\nresult = ncp_RenameNSEntry(server, old_dir, old_name, old_type,\r\nnew_dir, new_name);\r\nif (result == 0xFF)\r\n{\r\nold_type = cpu_to_le16(0x16);\r\nresult = ncp_RenameNSEntry(server, old_dir, old_name, old_type,\r\nnew_dir, new_name);\r\n}\r\nif (result != 0x92) return result;\r\nresult = ncp_del_file_or_subdir(server, new_dir, new_name);\r\nif (result != 0) return -EACCES;\r\nresult = ncp_RenameNSEntry(server, old_dir, old_name, old_type,\r\nnew_dir, new_name);\r\nreturn result;\r\n}\r\nint\r\nncp_read_kernel(struct ncp_server *server, const char *file_id,\r\n__u32 offset, __u16 to_read, char *target, int *bytes_read)\r\n{\r\nconst char *source;\r\nint result;\r\nncp_init_request(server);\r\nncp_add_byte(server, 0);\r\nncp_add_mem(server, file_id, 6);\r\nncp_add_be32(server, offset);\r\nncp_add_be16(server, to_read);\r\nif ((result = ncp_request(server, 72)) != 0) {\r\ngoto out;\r\n}\r\n*bytes_read = ncp_reply_be16(server, 0);\r\nsource = ncp_reply_data(server, 2 + (offset & 1));\r\nmemcpy(target, source, *bytes_read);\r\nout:\r\nncp_unlock_server(server);\r\nreturn result;\r\n}\r\nint\r\nncp_read_bounce(struct ncp_server *server, const char *file_id,\r\n__u32 offset, __u16 to_read, char __user *target, int *bytes_read,\r\nvoid* bounce, __u32 bufsize)\r\n{\r\nint result;\r\nncp_init_request(server);\r\nncp_add_byte(server, 0);\r\nncp_add_mem(server, file_id, 6);\r\nncp_add_be32(server, offset);\r\nncp_add_be16(server, to_read);\r\nresult = ncp_request2(server, 72, bounce, bufsize);\r\nncp_unlock_server(server);\r\nif (!result) {\r\nint len = get_unaligned_be16((char *)bounce +\r\nsizeof(struct ncp_reply_header));\r\nresult = -EIO;\r\nif (len <= to_read) {\r\nchar* source;\r\nsource = (char*)bounce +\r\nsizeof(struct ncp_reply_header) + 2 +\r\n(offset & 1);\r\n*bytes_read = len;\r\nresult = 0;\r\nif (copy_to_user(target, source, len))\r\nresult = -EFAULT;\r\n}\r\n}\r\nreturn result;\r\n}\r\nint\r\nncp_write_kernel(struct ncp_server *server, const char *file_id,\r\n__u32 offset, __u16 to_write,\r\nconst char *source, int *bytes_written)\r\n{\r\nint result;\r\nncp_init_request(server);\r\nncp_add_byte(server, 0);\r\nncp_add_mem(server, file_id, 6);\r\nncp_add_be32(server, offset);\r\nncp_add_be16(server, to_write);\r\nncp_add_mem(server, source, to_write);\r\nif ((result = ncp_request(server, 73)) == 0)\r\n*bytes_written = to_write;\r\nncp_unlock_server(server);\r\nreturn result;\r\n}\r\nint\r\nncp_LogPhysicalRecord(struct ncp_server *server, const char *file_id,\r\n__u8 locktype, __u32 offset, __u32 length, __u16 timeout)\r\n{\r\nint result;\r\nncp_init_request(server);\r\nncp_add_byte(server, locktype);\r\nncp_add_mem(server, file_id, 6);\r\nncp_add_be32(server, offset);\r\nncp_add_be32(server, length);\r\nncp_add_be16(server, timeout);\r\nif ((result = ncp_request(server, 0x1A)) != 0)\r\n{\r\nncp_unlock_server(server);\r\nreturn result;\r\n}\r\nncp_unlock_server(server);\r\nreturn 0;\r\n}\r\nint\r\nncp_ClearPhysicalRecord(struct ncp_server *server, const char *file_id,\r\n__u32 offset, __u32 length)\r\n{\r\nint result;\r\nncp_init_request(server);\r\nncp_add_byte(server, 0);\r\nncp_add_mem(server, file_id, 6);\r\nncp_add_be32(server, offset);\r\nncp_add_be32(server, length);\r\nif ((result = ncp_request(server, 0x1E)) != 0)\r\n{\r\nncp_unlock_server(server);\r\nreturn result;\r\n}\r\nncp_unlock_server(server);\r\nreturn 0;\r\n}\r\nint\r\nncp__io2vol(struct ncp_server *server, unsigned char *vname, unsigned int *vlen,\r\nconst unsigned char *iname, unsigned int ilen, int cc)\r\n{\r\nstruct nls_table *in = server->nls_io;\r\nstruct nls_table *out = server->nls_vol;\r\nunsigned char *vname_start;\r\nunsigned char *vname_end;\r\nconst unsigned char *iname_end;\r\niname_end = iname + ilen;\r\nvname_start = vname;\r\nvname_end = vname + *vlen - 1;\r\nwhile (iname < iname_end) {\r\nint chl;\r\nwchar_t ec;\r\nif (NCP_IS_FLAG(server, NCP_FLAG_UTF8)) {\r\nint k;\r\nunicode_t u;\r\nk = utf8_to_utf32(iname, iname_end - iname, &u);\r\nif (k < 0 || u > MAX_WCHAR_T)\r\nreturn -EINVAL;\r\niname += k;\r\nec = u;\r\n} else {\r\nif (*iname == NCP_ESC) {\r\nint k;\r\nif (iname_end - iname < 5)\r\ngoto nospec;\r\nec = 0;\r\nfor (k = 1; k < 5; k++) {\r\nunsigned char nc;\r\nnc = iname[k] - '0';\r\nif (nc >= 10) {\r\nnc -= 'A' - '0' - 10;\r\nif ((nc < 10) || (nc > 15)) {\r\ngoto nospec;\r\n}\r\n}\r\nec = (ec << 4) | nc;\r\n}\r\niname += 5;\r\n} else {\r\nnospec:;\r\nif ( (chl = in->char2uni(iname, iname_end - iname, &ec)) < 0)\r\nreturn chl;\r\niname += chl;\r\n}\r\n}\r\nchl = out->uni2char(ec, vname, vname_end - vname);\r\nif (chl < 0)\r\nreturn chl;\r\nif (cc) {\r\nint chi;\r\nfor (chi = 0; chi < chl; chi++){\r\nvname[chi] = ncp_toupper(out, vname[chi]);\r\n}\r\n}\r\nvname += chl;\r\n}\r\n*vname = 0;\r\n*vlen = vname - vname_start;\r\nreturn 0;\r\n}\r\nint\r\nncp__vol2io(struct ncp_server *server, unsigned char *iname, unsigned int *ilen,\r\nconst unsigned char *vname, unsigned int vlen, int cc)\r\n{\r\nstruct nls_table *in = server->nls_vol;\r\nstruct nls_table *out = server->nls_io;\r\nconst unsigned char *vname_end;\r\nunsigned char *iname_start;\r\nunsigned char *iname_end;\r\nunsigned char *vname_cc;\r\nint err;\r\nvname_cc = NULL;\r\nif (cc) {\r\nint i;\r\nvname_cc = kmalloc(vlen, GFP_KERNEL);\r\nif (!vname_cc)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < vlen; i++)\r\nvname_cc[i] = ncp_tolower(in, vname[i]);\r\nvname = vname_cc;\r\n}\r\niname_start = iname;\r\niname_end = iname + *ilen - 1;\r\nvname_end = vname + vlen;\r\nwhile (vname < vname_end) {\r\nwchar_t ec;\r\nint chl;\r\nif ( (chl = in->char2uni(vname, vname_end - vname, &ec)) < 0) {\r\nerr = chl;\r\ngoto quit;\r\n}\r\nvname += chl;\r\nif (NCP_IS_FLAG(server, NCP_FLAG_UTF8)) {\r\nint k;\r\nk = utf32_to_utf8(ec, iname, iname_end - iname);\r\nif (k < 0) {\r\nerr = -ENAMETOOLONG;\r\ngoto quit;\r\n}\r\niname += k;\r\n} else {\r\nif ( (chl = out->uni2char(ec, iname, iname_end - iname)) >= 0) {\r\niname += chl;\r\n} else {\r\nint k;\r\nif (iname_end - iname < 5) {\r\nerr = -ENAMETOOLONG;\r\ngoto quit;\r\n}\r\n*iname = NCP_ESC;\r\nfor (k = 4; k > 0; k--) {\r\nunsigned char v;\r\nv = (ec & 0xF) + '0';\r\nif (v > '9') {\r\nv += 'A' - '9' - 1;\r\n}\r\niname[k] = v;\r\nec >>= 4;\r\n}\r\niname += 5;\r\n}\r\n}\r\n}\r\n*iname = 0;\r\n*ilen = iname - iname_start;\r\nerr = 0;\r\nquit:;\r\nif (cc)\r\nkfree(vname_cc);\r\nreturn err;\r\n}\r\nint\r\nncp__io2vol(unsigned char *vname, unsigned int *vlen,\r\nconst unsigned char *iname, unsigned int ilen, int cc)\r\n{\r\nint i;\r\nif (*vlen <= ilen)\r\nreturn -ENAMETOOLONG;\r\nif (cc)\r\nfor (i = 0; i < ilen; i++) {\r\n*vname = toupper(*iname);\r\nvname++;\r\niname++;\r\n}\r\nelse {\r\nmemmove(vname, iname, ilen);\r\nvname += ilen;\r\n}\r\n*vlen = ilen;\r\n*vname = 0;\r\nreturn 0;\r\n}\r\nint\r\nncp__vol2io(unsigned char *iname, unsigned int *ilen,\r\nconst unsigned char *vname, unsigned int vlen, int cc)\r\n{\r\nint i;\r\nif (*ilen <= vlen)\r\nreturn -ENAMETOOLONG;\r\nif (cc)\r\nfor (i = 0; i < vlen; i++) {\r\n*iname = tolower(*vname);\r\niname++;\r\nvname++;\r\n}\r\nelse {\r\nmemmove(iname, vname, vlen);\r\niname += vlen;\r\n}\r\n*ilen = vlen;\r\n*iname = 0;\r\nreturn 0;\r\n}
