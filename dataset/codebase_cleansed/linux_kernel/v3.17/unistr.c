bool ntfs_are_names_equal(const ntfschar *s1, size_t s1_len,\r\nconst ntfschar *s2, size_t s2_len, const IGNORE_CASE_BOOL ic,\r\nconst ntfschar *upcase, const u32 upcase_size)\r\n{\r\nif (s1_len != s2_len)\r\nreturn false;\r\nif (ic == CASE_SENSITIVE)\r\nreturn !ntfs_ucsncmp(s1, s2, s1_len);\r\nreturn !ntfs_ucsncasecmp(s1, s2, s1_len, upcase, upcase_size);\r\n}\r\nint ntfs_collate_names(const ntfschar *name1, const u32 name1_len,\r\nconst ntfschar *name2, const u32 name2_len,\r\nconst int err_val, const IGNORE_CASE_BOOL ic,\r\nconst ntfschar *upcase, const u32 upcase_len)\r\n{\r\nu32 cnt, min_len;\r\nu16 c1, c2;\r\nmin_len = name1_len;\r\nif (name1_len > name2_len)\r\nmin_len = name2_len;\r\nfor (cnt = 0; cnt < min_len; ++cnt) {\r\nc1 = le16_to_cpu(*name1++);\r\nc2 = le16_to_cpu(*name2++);\r\nif (ic) {\r\nif (c1 < upcase_len)\r\nc1 = le16_to_cpu(upcase[c1]);\r\nif (c2 < upcase_len)\r\nc2 = le16_to_cpu(upcase[c2]);\r\n}\r\nif (c1 < 64 && legal_ansi_char_array[c1] & 8)\r\nreturn err_val;\r\nif (c1 < c2)\r\nreturn -1;\r\nif (c1 > c2)\r\nreturn 1;\r\n}\r\nif (name1_len < name2_len)\r\nreturn -1;\r\nif (name1_len == name2_len)\r\nreturn 0;\r\nc1 = le16_to_cpu(*name1);\r\nif (c1 < 64 && legal_ansi_char_array[c1] & 8)\r\nreturn err_val;\r\nreturn 1;\r\n}\r\nint ntfs_ucsncmp(const ntfschar *s1, const ntfschar *s2, size_t n)\r\n{\r\nu16 c1, c2;\r\nsize_t i;\r\nfor (i = 0; i < n; ++i) {\r\nc1 = le16_to_cpu(s1[i]);\r\nc2 = le16_to_cpu(s2[i]);\r\nif (c1 < c2)\r\nreturn -1;\r\nif (c1 > c2)\r\nreturn 1;\r\nif (!c1)\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint ntfs_ucsncasecmp(const ntfschar *s1, const ntfschar *s2, size_t n,\r\nconst ntfschar *upcase, const u32 upcase_size)\r\n{\r\nsize_t i;\r\nu16 c1, c2;\r\nfor (i = 0; i < n; ++i) {\r\nif ((c1 = le16_to_cpu(s1[i])) < upcase_size)\r\nc1 = le16_to_cpu(upcase[c1]);\r\nif ((c2 = le16_to_cpu(s2[i])) < upcase_size)\r\nc2 = le16_to_cpu(upcase[c2]);\r\nif (c1 < c2)\r\nreturn -1;\r\nif (c1 > c2)\r\nreturn 1;\r\nif (!c1)\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid ntfs_upcase_name(ntfschar *name, u32 name_len, const ntfschar *upcase,\r\nconst u32 upcase_len)\r\n{\r\nu32 i;\r\nu16 u;\r\nfor (i = 0; i < name_len; i++)\r\nif ((u = le16_to_cpu(name[i])) < upcase_len)\r\nname[i] = upcase[u];\r\n}\r\nvoid ntfs_file_upcase_value(FILE_NAME_ATTR *file_name_attr,\r\nconst ntfschar *upcase, const u32 upcase_len)\r\n{\r\nntfs_upcase_name((ntfschar*)&file_name_attr->file_name,\r\nfile_name_attr->file_name_length, upcase, upcase_len);\r\n}\r\nint ntfs_file_compare_values(FILE_NAME_ATTR *file_name_attr1,\r\nFILE_NAME_ATTR *file_name_attr2,\r\nconst int err_val, const IGNORE_CASE_BOOL ic,\r\nconst ntfschar *upcase, const u32 upcase_len)\r\n{\r\nreturn ntfs_collate_names((ntfschar*)&file_name_attr1->file_name,\r\nfile_name_attr1->file_name_length,\r\n(ntfschar*)&file_name_attr2->file_name,\r\nfile_name_attr2->file_name_length,\r\nerr_val, ic, upcase, upcase_len);\r\n}\r\nint ntfs_nlstoucs(const ntfs_volume *vol, const char *ins,\r\nconst int ins_len, ntfschar **outs)\r\n{\r\nstruct nls_table *nls = vol->nls_map;\r\nntfschar *ucs;\r\nwchar_t wc;\r\nint i, o, wc_len;\r\nif (likely(ins)) {\r\nucs = kmem_cache_alloc(ntfs_name_cache, GFP_NOFS);\r\nif (likely(ucs)) {\r\nfor (i = o = 0; i < ins_len; i += wc_len) {\r\nwc_len = nls->char2uni(ins + i, ins_len - i,\r\n&wc);\r\nif (likely(wc_len >= 0 &&\r\no < NTFS_MAX_NAME_LEN)) {\r\nif (likely(wc)) {\r\nucs[o++] = cpu_to_le16(wc);\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\ngoto name_err;\r\n}\r\nucs[o] = 0;\r\n*outs = ucs;\r\nreturn o;\r\n}\r\nntfs_error(vol->sb, "Failed to allocate buffer for converted "\r\n"name from ntfs_name_cache.");\r\nreturn -ENOMEM;\r\n}\r\nntfs_error(vol->sb, "Received NULL pointer.");\r\nreturn -EINVAL;\r\nname_err:\r\nkmem_cache_free(ntfs_name_cache, ucs);\r\nif (wc_len < 0) {\r\nntfs_error(vol->sb, "Name using character set %s contains "\r\n"characters that cannot be converted to "\r\n"Unicode.", nls->charset);\r\ni = -EILSEQ;\r\n} else {\r\nntfs_error(vol->sb, "Name is too long (maximum length for a "\r\n"name on NTFS is %d Unicode characters.",\r\nNTFS_MAX_NAME_LEN);\r\ni = -ENAMETOOLONG;\r\n}\r\nreturn i;\r\n}\r\nint ntfs_ucstonls(const ntfs_volume *vol, const ntfschar *ins,\r\nconst int ins_len, unsigned char **outs, int outs_len)\r\n{\r\nstruct nls_table *nls = vol->nls_map;\r\nunsigned char *ns;\r\nint i, o, ns_len, wc;\r\nif (ins) {\r\nns = *outs;\r\nns_len = outs_len;\r\nif (ns && !ns_len) {\r\nwc = -ENAMETOOLONG;\r\ngoto conversion_err;\r\n}\r\nif (!ns) {\r\nns_len = ins_len * NLS_MAX_CHARSET_SIZE;\r\nns = kmalloc(ns_len + 1, GFP_NOFS);\r\nif (!ns)\r\ngoto mem_err_out;\r\n}\r\nfor (i = o = 0; i < ins_len; i++) {\r\nretry: wc = nls->uni2char(le16_to_cpu(ins[i]), ns + o,\r\nns_len - o);\r\nif (wc > 0) {\r\no += wc;\r\ncontinue;\r\n} else if (!wc)\r\nbreak;\r\nelse if (wc == -ENAMETOOLONG && ns != *outs) {\r\nunsigned char *tc;\r\ntc = kmalloc((ns_len + 64) &\r\n~63, GFP_NOFS);\r\nif (tc) {\r\nmemcpy(tc, ns, ns_len);\r\nns_len = ((ns_len + 64) & ~63) - 1;\r\nkfree(ns);\r\nns = tc;\r\ngoto retry;\r\n}\r\n}\r\ngoto conversion_err;\r\n}\r\nns[o] = 0;\r\n*outs = ns;\r\nreturn o;\r\n}\r\nntfs_error(vol->sb, "Received NULL pointer.");\r\nreturn -EINVAL;\r\nconversion_err:\r\nntfs_error(vol->sb, "Unicode name contains characters that cannot be "\r\n"converted to character set %s. You might want to "\r\n"try to use the mount option nls=utf8.", nls->charset);\r\nif (ns != *outs)\r\nkfree(ns);\r\nif (wc != -ENAMETOOLONG)\r\nwc = -EILSEQ;\r\nreturn wc;\r\nmem_err_out:\r\nntfs_error(vol->sb, "Failed to allocate name!");\r\nreturn -ENOMEM;\r\n}
