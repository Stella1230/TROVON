static u32 add_byte(u32 **p_buffer, u8 value, u32 *used, u32 *avail)\r\n{\r\nu8 **tByte;\r\nif ((*used + 1) > *avail)\r\nreturn(1);\r\n*((u8*)*p_buffer) = value;\r\ntByte = (u8**)p_buffer;\r\n(*tByte)++;\r\n*used+=1;\r\nreturn(0);\r\n}\r\nstatic u32 add_dword(u32 **p_buffer, u32 value, u32 *used, u32 *avail)\r\n{\r\nif ((*used + 4) > *avail)\r\nreturn(1);\r\n**p_buffer = value;\r\n(*p_buffer)++;\r\n*used+=4;\r\nreturn(0);\r\n}\r\nstatic int check_for_compaq_ROM (void __iomem *rom_start)\r\n{\r\nu8 temp1, temp2, temp3, temp4, temp5, temp6;\r\nint result = 0;\r\ntemp1 = readb(rom_start + 0xffea + 0);\r\ntemp2 = readb(rom_start + 0xffea + 1);\r\ntemp3 = readb(rom_start + 0xffea + 2);\r\ntemp4 = readb(rom_start + 0xffea + 3);\r\ntemp5 = readb(rom_start + 0xffea + 4);\r\ntemp6 = readb(rom_start + 0xffea + 5);\r\nif ((temp1 == 'C') &&\r\n(temp2 == 'O') &&\r\n(temp3 == 'M') &&\r\n(temp4 == 'P') &&\r\n(temp5 == 'A') &&\r\n(temp6 == 'Q')) {\r\nresult = 1;\r\n}\r\ndbg ("%s - returned %d\n", __func__, result);\r\nreturn result;\r\n}\r\nstatic u32 access_EV (u16 operation, u8 *ev_name, u8 *buffer, u32 *buf_size)\r\n{\r\nunsigned long flags;\r\nint op = operation;\r\nint ret_val;\r\nif (!compaq_int15_entry_point)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&int15_lock, flags);\r\n__asm__ (\r\n"xorl %%ebx,%%ebx\n" \\r\n"xorl %%edx,%%edx\n" \\r\n"pushf\n" \\r\n"push %%cs\n" \\r\n"cli\n" \\r\n"call *%6\n"\r\n: "=c" (*buf_size), "=a" (ret_val)\r\n: "a" (op), "c" (*buf_size), "S" (ev_name),\r\n"D" (buffer), "m" (compaq_int15_entry_point)\r\n: "%ebx", "%edx");\r\nspin_unlock_irqrestore(&int15_lock, flags);\r\nreturn((ret_val & 0xFF00) >> 8);\r\n}\r\nstatic int load_HRT (void __iomem *rom_start)\r\n{\r\nu32 available;\r\nu32 temp_dword;\r\nu8 temp_byte = 0xFF;\r\nu32 rc;\r\nif (!check_for_compaq_ROM(rom_start)) {\r\nreturn -ENODEV;\r\n}\r\navailable = 1024;\r\ntemp_dword = available;\r\nrc = access_EV(READ_EV, "CQTHPS", evbuffer, &temp_dword);\r\nevbuffer_length = temp_dword;\r\ntemp_dword = 1;\r\nrc = access_EV(WRITE_EV, "CQTHPS", &temp_byte, &temp_dword);\r\nreturn rc;\r\n}\r\nstatic u32 store_HRT (void __iomem *rom_start)\r\n{\r\nu32 *buffer;\r\nu32 *pFill;\r\nu32 usedbytes;\r\nu32 available;\r\nu32 temp_dword;\r\nu32 rc;\r\nu8 loop;\r\nu8 numCtrl = 0;\r\nstruct controller *ctrl;\r\nstruct pci_resource *resNode;\r\nstruct ev_hrt_header *p_EV_header;\r\nstruct ev_hrt_ctrl *p_ev_ctrl;\r\navailable = 1024;\r\nif (!check_for_compaq_ROM(rom_start)) {\r\nreturn(1);\r\n}\r\nbuffer = (u32*) evbuffer;\r\nif (!buffer)\r\nreturn(1);\r\npFill = buffer;\r\nusedbytes = 0;\r\np_EV_header = (struct ev_hrt_header *) pFill;\r\nctrl = cpqhp_ctrl_list;\r\nrc = add_byte(&pFill, 1 + ctrl->push_flag, &usedbytes, &available);\r\nif (rc)\r\nreturn(rc);\r\nrc = add_byte(&pFill, 1, &usedbytes, &available);\r\nif (rc)\r\nreturn(rc);\r\nwhile (ctrl) {\r\np_ev_ctrl = (struct ev_hrt_ctrl *) pFill;\r\nnumCtrl++;\r\nrc = add_byte(&pFill, ctrl->bus, &usedbytes, &available);\r\nif (rc)\r\nreturn(rc);\r\nrc = add_byte(&pFill, PCI_SLOT(ctrl->pci_dev->devfn), &usedbytes, &available);\r\nif (rc)\r\nreturn(rc);\r\nrc = add_byte(&pFill, PCI_FUNC(ctrl->pci_dev->devfn), &usedbytes, &available);\r\nif (rc)\r\nreturn(rc);\r\nrc = add_dword(&pFill, 0, &usedbytes, &available);\r\nif (rc)\r\nreturn(rc);\r\nresNode = ctrl->mem_head;\r\nloop = 0;\r\nwhile (resNode) {\r\nloop ++;\r\nrc = add_dword(&pFill, resNode->base, &usedbytes, &available);\r\nif (rc)\r\nreturn(rc);\r\nrc = add_dword(&pFill, resNode->length, &usedbytes, &available);\r\nif (rc)\r\nreturn(rc);\r\nresNode = resNode->next;\r\n}\r\np_ev_ctrl->mem_avail = loop;\r\nresNode = ctrl->p_mem_head;\r\nloop = 0;\r\nwhile (resNode) {\r\nloop ++;\r\nrc = add_dword(&pFill, resNode->base, &usedbytes, &available);\r\nif (rc)\r\nreturn(rc);\r\nrc = add_dword(&pFill, resNode->length, &usedbytes, &available);\r\nif (rc)\r\nreturn(rc);\r\nresNode = resNode->next;\r\n}\r\np_ev_ctrl->p_mem_avail = loop;\r\nresNode = ctrl->io_head;\r\nloop = 0;\r\nwhile (resNode) {\r\nloop ++;\r\nrc = add_dword(&pFill, resNode->base, &usedbytes, &available);\r\nif (rc)\r\nreturn(rc);\r\nrc = add_dword(&pFill, resNode->length, &usedbytes, &available);\r\nif (rc)\r\nreturn(rc);\r\nresNode = resNode->next;\r\n}\r\np_ev_ctrl->io_avail = loop;\r\nresNode = ctrl->bus_head;\r\nloop = 0;\r\nwhile (resNode) {\r\nloop ++;\r\nrc = add_dword(&pFill, resNode->base, &usedbytes, &available);\r\nif (rc)\r\nreturn(rc);\r\nrc = add_dword(&pFill, resNode->length, &usedbytes, &available);\r\nif (rc)\r\nreturn(rc);\r\nresNode = resNode->next;\r\n}\r\np_ev_ctrl->bus_avail = loop;\r\nctrl = ctrl->next;\r\n}\r\np_EV_header->num_of_ctrl = numCtrl;\r\ntemp_dword = usedbytes;\r\nrc = access_EV(WRITE_EV, "CQTHPS", (u8*) buffer, &temp_dword);\r\ndbg("usedbytes = 0x%x, length = 0x%x\n", usedbytes, temp_dword);\r\nevbuffer_length = temp_dword;\r\nif (rc) {\r\nerr(msg_unable_to_save);\r\nreturn(1);\r\n}\r\nreturn(0);\r\n}\r\nvoid compaq_nvram_init (void __iomem *rom_start)\r\n{\r\nif (rom_start) {\r\ncompaq_int15_entry_point = (rom_start + ROM_INT15_PHY_ADDR - ROM_PHY_ADDR);\r\n}\r\ndbg("int15 entry = %p\n", compaq_int15_entry_point);\r\nspin_lock_init(&int15_lock);\r\n}\r\nint compaq_nvram_load (void __iomem *rom_start, struct controller *ctrl)\r\n{\r\nu8 bus, device, function;\r\nu8 nummem, numpmem, numio, numbus;\r\nu32 rc;\r\nu8 *p_byte;\r\nstruct pci_resource *mem_node;\r\nstruct pci_resource *p_mem_node;\r\nstruct pci_resource *io_node;\r\nstruct pci_resource *bus_node;\r\nstruct ev_hrt_ctrl *p_ev_ctrl;\r\nstruct ev_hrt_header *p_EV_header;\r\nif (!evbuffer_init) {\r\nif (load_HRT(rom_start))\r\nmemset (evbuffer, 0, 1024);\r\nevbuffer_init = 1;\r\n}\r\np_EV_header = (struct ev_hrt_header *) evbuffer;\r\nif ((p_EV_header->Version == 2) ||\r\n((p_EV_header->Version == 1) && !ctrl->push_flag)) {\r\np_byte = &(p_EV_header->next);\r\np_ev_ctrl = (struct ev_hrt_ctrl *) &(p_EV_header->next);\r\np_byte += 3;\r\nif (p_byte > ((u8*)p_EV_header + evbuffer_length))\r\nreturn 2;\r\nbus = p_ev_ctrl->bus;\r\ndevice = p_ev_ctrl->device;\r\nfunction = p_ev_ctrl->function;\r\nwhile ((bus != ctrl->bus) ||\r\n(device != PCI_SLOT(ctrl->pci_dev->devfn)) ||\r\n(function != PCI_FUNC(ctrl->pci_dev->devfn))) {\r\nnummem = p_ev_ctrl->mem_avail;\r\nnumpmem = p_ev_ctrl->p_mem_avail;\r\nnumio = p_ev_ctrl->io_avail;\r\nnumbus = p_ev_ctrl->bus_avail;\r\np_byte += 4;\r\nif (p_byte > ((u8*)p_EV_header + evbuffer_length))\r\nreturn 2;\r\np_byte += (nummem + numpmem + numio + numbus) * 8;\r\nif (p_byte > ((u8*)p_EV_header + evbuffer_length))\r\nreturn 2;\r\np_ev_ctrl = (struct ev_hrt_ctrl *) p_byte;\r\np_byte += 3;\r\nif (p_byte > ((u8*)p_EV_header + evbuffer_length))\r\nreturn 2;\r\nbus = p_ev_ctrl->bus;\r\ndevice = p_ev_ctrl->device;\r\nfunction = p_ev_ctrl->function;\r\n}\r\nnummem = p_ev_ctrl->mem_avail;\r\nnumpmem = p_ev_ctrl->p_mem_avail;\r\nnumio = p_ev_ctrl->io_avail;\r\nnumbus = p_ev_ctrl->bus_avail;\r\np_byte += 4;\r\nif (p_byte > ((u8*)p_EV_header + evbuffer_length))\r\nreturn 2;\r\nwhile (nummem--) {\r\nmem_node = kmalloc(sizeof(struct pci_resource), GFP_KERNEL);\r\nif (!mem_node)\r\nbreak;\r\nmem_node->base = *(u32*)p_byte;\r\ndbg("mem base = %8.8x\n",mem_node->base);\r\np_byte += 4;\r\nif (p_byte > ((u8*)p_EV_header + evbuffer_length)) {\r\nkfree(mem_node);\r\nreturn 2;\r\n}\r\nmem_node->length = *(u32*)p_byte;\r\ndbg("mem length = %8.8x\n",mem_node->length);\r\np_byte += 4;\r\nif (p_byte > ((u8*)p_EV_header + evbuffer_length)) {\r\nkfree(mem_node);\r\nreturn 2;\r\n}\r\nmem_node->next = ctrl->mem_head;\r\nctrl->mem_head = mem_node;\r\n}\r\nwhile (numpmem--) {\r\np_mem_node = kmalloc(sizeof(struct pci_resource), GFP_KERNEL);\r\nif (!p_mem_node)\r\nbreak;\r\np_mem_node->base = *(u32*)p_byte;\r\ndbg("pre-mem base = %8.8x\n",p_mem_node->base);\r\np_byte += 4;\r\nif (p_byte > ((u8*)p_EV_header + evbuffer_length)) {\r\nkfree(p_mem_node);\r\nreturn 2;\r\n}\r\np_mem_node->length = *(u32*)p_byte;\r\ndbg("pre-mem length = %8.8x\n",p_mem_node->length);\r\np_byte += 4;\r\nif (p_byte > ((u8*)p_EV_header + evbuffer_length)) {\r\nkfree(p_mem_node);\r\nreturn 2;\r\n}\r\np_mem_node->next = ctrl->p_mem_head;\r\nctrl->p_mem_head = p_mem_node;\r\n}\r\nwhile (numio--) {\r\nio_node = kmalloc(sizeof(struct pci_resource), GFP_KERNEL);\r\nif (!io_node)\r\nbreak;\r\nio_node->base = *(u32*)p_byte;\r\ndbg("io base = %8.8x\n",io_node->base);\r\np_byte += 4;\r\nif (p_byte > ((u8*)p_EV_header + evbuffer_length)) {\r\nkfree(io_node);\r\nreturn 2;\r\n}\r\nio_node->length = *(u32*)p_byte;\r\ndbg("io length = %8.8x\n",io_node->length);\r\np_byte += 4;\r\nif (p_byte > ((u8*)p_EV_header + evbuffer_length)) {\r\nkfree(io_node);\r\nreturn 2;\r\n}\r\nio_node->next = ctrl->io_head;\r\nctrl->io_head = io_node;\r\n}\r\nwhile (numbus--) {\r\nbus_node = kmalloc(sizeof(struct pci_resource), GFP_KERNEL);\r\nif (!bus_node)\r\nbreak;\r\nbus_node->base = *(u32*)p_byte;\r\np_byte += 4;\r\nif (p_byte > ((u8*)p_EV_header + evbuffer_length)) {\r\nkfree(bus_node);\r\nreturn 2;\r\n}\r\nbus_node->length = *(u32*)p_byte;\r\np_byte += 4;\r\nif (p_byte > ((u8*)p_EV_header + evbuffer_length)) {\r\nkfree(bus_node);\r\nreturn 2;\r\n}\r\nbus_node->next = ctrl->bus_head;\r\nctrl->bus_head = bus_node;\r\n}\r\nrc = 1;\r\nrc &= cpqhp_resource_sort_and_combine(&(ctrl->mem_head));\r\nrc &= cpqhp_resource_sort_and_combine(&(ctrl->p_mem_head));\r\nrc &= cpqhp_resource_sort_and_combine(&(ctrl->io_head));\r\nrc &= cpqhp_resource_sort_and_combine(&(ctrl->bus_head));\r\nif (rc)\r\nreturn(rc);\r\n} else {\r\nif ((evbuffer[0] != 0) && (!ctrl->push_flag))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint compaq_nvram_store (void __iomem *rom_start)\r\n{\r\nint rc = 1;\r\nif (rom_start == NULL)\r\nreturn -ENODEV;\r\nif (evbuffer_init) {\r\nrc = store_HRT(rom_start);\r\nif (rc) {\r\nerr(msg_unable_to_save);\r\n}\r\n}\r\nreturn rc;\r\n}
