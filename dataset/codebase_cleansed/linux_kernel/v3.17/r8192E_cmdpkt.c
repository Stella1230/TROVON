bool cmpk_message_handle_tx(\r\nstruct net_device *dev,\r\nu8 *code_virtual_address,\r\nu32 packettype,\r\nu32 buffer_len)\r\n{\r\nbool rt_status = true;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu16 frag_threshold;\r\nu16 frag_length = 0, frag_offset = 0;\r\nstruct rt_firmware *pfirmware = priv->pFirmware;\r\nstruct sk_buff *skb;\r\nunsigned char *seg_ptr;\r\nstruct cb_desc *tcb_desc;\r\nu8 bLastIniPkt;\r\nstruct tx_fwinfo_8190pci *pTxFwInfo = NULL;\r\nRT_TRACE(COMP_CMDPKT, "%s(),buffer_len is %d\n", __func__, buffer_len);\r\nfirmware_init_param(dev);\r\nfrag_threshold = pfirmware->cmdpacket_frag_thresold;\r\ndo {\r\nif ((buffer_len - frag_offset) > frag_threshold) {\r\nfrag_length = frag_threshold ;\r\nbLastIniPkt = 0;\r\n} else {\r\nfrag_length = (u16)(buffer_len - frag_offset);\r\nbLastIniPkt = 1;\r\n}\r\nskb = dev_alloc_skb(frag_length +\r\npriv->rtllib->tx_headroom + 4);\r\nif (skb == NULL) {\r\nrt_status = false;\r\ngoto Failed;\r\n}\r\nmemcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));\r\ntcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\r\ntcb_desc->queue_index = TXCMD_QUEUE;\r\ntcb_desc->bCmdOrInit = DESC_PACKET_TYPE_NORMAL;\r\ntcb_desc->bLastIniPkt = bLastIniPkt;\r\ntcb_desc->pkt_size = frag_length;\r\nseg_ptr = skb_put(skb, priv->rtllib->tx_headroom);\r\npTxFwInfo = (struct tx_fwinfo_8190pci *)seg_ptr;\r\nmemset(pTxFwInfo, 0, sizeof(struct tx_fwinfo_8190pci));\r\nmemset(pTxFwInfo, 0x12, 8);\r\nseg_ptr = skb_put(skb, frag_length);\r\nmemcpy(seg_ptr, code_virtual_address, (u32)frag_length);\r\npriv->rtllib->softmac_hard_start_xmit(skb, dev);\r\ncode_virtual_address += frag_length;\r\nfrag_offset += frag_length;\r\n} while (frag_offset < buffer_len);\r\nwrite_nic_byte(dev, TPPoll, TPPoll_CQ);\r\nFailed:\r\nreturn rt_status;\r\n}\r\nstatic void\r\ncmpk_count_txstatistic(\r\nstruct net_device *dev,\r\nstruct cmpk_txfb *pstx_fb)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\n#ifdef ENABLE_PS\r\nenum rt_rf_power_state rtState;\r\npAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_RF_STATE,\r\n(pu1Byte)(&rtState));\r\nif (rtState == eRfOff)\r\nreturn;\r\n#endif\r\nif (pstx_fb->tok) {\r\npriv->stats.txfeedbackok++;\r\npriv->stats.txoktotal++;\r\npriv->stats.txokbytestotal += pstx_fb->pkt_length;\r\npriv->stats.txokinperiod++;\r\nif (pstx_fb->pkt_type == PACKET_MULTICAST) {\r\npriv->stats.txmulticast++;\r\npriv->stats.txbytesmulticast += pstx_fb->pkt_length;\r\n} else if (pstx_fb->pkt_type == PACKET_BROADCAST) {\r\npriv->stats.txbroadcast++;\r\npriv->stats.txbytesbroadcast += pstx_fb->pkt_length;\r\n} else {\r\npriv->stats.txunicast++;\r\npriv->stats.txbytesunicast += pstx_fb->pkt_length;\r\n}\r\n} else {\r\npriv->stats.txfeedbackfail++;\r\npriv->stats.txerrtotal++;\r\npriv->stats.txerrbytestotal += pstx_fb->pkt_length;\r\nif (pstx_fb->pkt_type == PACKET_MULTICAST)\r\npriv->stats.txerrmulticast++;\r\nelse if (pstx_fb->pkt_type == PACKET_BROADCAST)\r\npriv->stats.txerrbroadcast++;\r\nelse\r\npriv->stats.txerrunicast++;\r\n}\r\npriv->stats.txretrycount += pstx_fb->retry_cnt;\r\npriv->stats.txfeedbackretry += pstx_fb->retry_cnt;\r\n}\r\nstatic void cmpk_handle_tx_feedback(struct net_device *dev, u8 *pmsg)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct cmpk_txfb rx_tx_fb;\r\npriv->stats.txfeedback++;\r\nmemcpy((u8 *)&rx_tx_fb, pmsg, sizeof(struct cmpk_txfb));\r\ncmpk_count_txstatistic(dev, &rx_tx_fb);\r\n}\r\nstatic void cmdpkt_beacontimerinterrupt_819xusb(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu16 tx_rate;\r\nif ((priv->rtllib->current_network.mode == IEEE_A) ||\r\n(priv->rtllib->current_network.mode == IEEE_N_5G) ||\r\n((priv->rtllib->current_network.mode == IEEE_N_24G) &&\r\n(!priv->rtllib->pHTInfo->bCurSuppCCK))) {\r\ntx_rate = 60;\r\nDMESG("send beacon frame tx rate is 6Mbpm\n");\r\n} else {\r\ntx_rate = 10;\r\nDMESG("send beacon frame tx rate is 1Mbpm\n");\r\n}\r\n}\r\nstatic void cmpk_handle_interrupt_status(struct net_device *dev, u8 *pmsg)\r\n{\r\nstruct cmpk_intr_sta rx_intr_status;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nDMESG("---> cmpk_Handle_Interrupt_Status()\n");\r\nrx_intr_status.length = pmsg[1];\r\nif (rx_intr_status.length != (sizeof(struct cmpk_intr_sta) - 2)) {\r\nDMESG("cmpk_Handle_Interrupt_Status: wrong length!\n");\r\nreturn;\r\n}\r\nif (priv->rtllib->iw_mode == IW_MODE_ADHOC) {\r\nrx_intr_status.interrupt_status = *((u32 *)(pmsg + 4));\r\nDMESG("interrupt status = 0x%x\n",\r\nrx_intr_status.interrupt_status);\r\nif (rx_intr_status.interrupt_status & ISR_TxBcnOk) {\r\npriv->rtllib->bibsscoordinator = true;\r\npriv->stats.txbeaconokint++;\r\n} else if (rx_intr_status.interrupt_status & ISR_TxBcnErr) {\r\npriv->rtllib->bibsscoordinator = false;\r\npriv->stats.txbeaconerr++;\r\n}\r\nif (rx_intr_status.interrupt_status & ISR_BcnTimerIntr)\r\ncmdpkt_beacontimerinterrupt_819xusb(dev);\r\n}\r\nDMESG("<---- cmpk_handle_interrupt_status()\n");\r\n}\r\nstatic void cmpk_handle_query_config_rx(struct net_device *dev, u8 *pmsg)\r\n{\r\ncmpk_query_cfg_t rx_query_cfg;\r\nrx_query_cfg.cfg_action = (pmsg[4] & 0x80000000)>>31;\r\nrx_query_cfg.cfg_type = (pmsg[4] & 0x60) >> 5;\r\nrx_query_cfg.cfg_size = (pmsg[4] & 0x18) >> 3;\r\nrx_query_cfg.cfg_page = (pmsg[6] & 0x0F) >> 0;\r\nrx_query_cfg.cfg_offset = pmsg[7];\r\nrx_query_cfg.value = (pmsg[8] << 24) | (pmsg[9] << 16) |\r\n(pmsg[10] << 8) | (pmsg[11] << 0);\r\nrx_query_cfg.mask = (pmsg[12] << 24) | (pmsg[13] << 16) |\r\n(pmsg[14] << 8) | (pmsg[15] << 0);\r\n}\r\nstatic void cmpk_count_tx_status(struct net_device *dev,\r\nstruct cmpk_tx_status *pstx_status)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\n#ifdef ENABLE_PS\r\nenum rt_rf_power_state rtstate;\r\npAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_RF_STATE,\r\n(pu1Byte)(&rtState));\r\nif (rtState == eRfOff)\r\nreturn;\r\n#endif\r\npriv->stats.txfeedbackok += pstx_status->txok;\r\npriv->stats.txoktotal += pstx_status->txok;\r\npriv->stats.txfeedbackfail += pstx_status->txfail;\r\npriv->stats.txerrtotal += pstx_status->txfail;\r\npriv->stats.txretrycount += pstx_status->txretry;\r\npriv->stats.txfeedbackretry += pstx_status->txretry;\r\npriv->stats.txmulticast += pstx_status->txmcok;\r\npriv->stats.txbroadcast += pstx_status->txbcok;\r\npriv->stats.txunicast += pstx_status->txucok;\r\npriv->stats.txerrmulticast += pstx_status->txmcfail;\r\npriv->stats.txerrbroadcast += pstx_status->txbcfail;\r\npriv->stats.txerrunicast += pstx_status->txucfail;\r\npriv->stats.txbytesmulticast += pstx_status->txmclength;\r\npriv->stats.txbytesbroadcast += pstx_status->txbclength;\r\npriv->stats.txbytesunicast += pstx_status->txuclength;\r\npriv->stats.last_packet_rate = pstx_status->rate;\r\n}\r\nstatic void cmpk_handle_tx_status(struct net_device *dev, u8 *pmsg)\r\n{\r\nstruct cmpk_tx_status rx_tx_sts;\r\nmemcpy((void *)&rx_tx_sts, (void *)pmsg, sizeof(struct cmpk_tx_status));\r\ncmpk_count_tx_status(dev, &rx_tx_sts);\r\n}\r\nstatic void cmpk_handle_tx_rate_history(struct net_device *dev, u8 *pmsg)\r\n{\r\nstruct cmpk_tx_rahis *ptxrate;\r\nu8 i, j;\r\nu16 length = sizeof(struct cmpk_tx_rahis);\r\nu32 *ptemp;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\n#ifdef ENABLE_PS\r\npAdapter->HalFunc.GetHwRegHandler(pAdapter, HW_VAR_RF_STATE,\r\n(pu1Byte)(&rtState));\r\nif (rtState == eRfOff)\r\nreturn;\r\n#endif\r\nptemp = (u32 *)pmsg;\r\nfor (i = 0; i < (length / 4); i++) {\r\nu16 temp1, temp2;\r\ntemp1 = ptemp[i] & 0x0000FFFF;\r\ntemp2 = ptemp[i] >> 16;\r\nptemp[i] = (temp1 << 16) | temp2;\r\n}\r\nptxrate = (struct cmpk_tx_rahis *)pmsg;\r\nif (ptxrate == NULL)\r\nreturn;\r\nfor (i = 0; i < 16; i++) {\r\nif (i < 4)\r\npriv->stats.txrate.cck[i] += ptxrate->cck[i];\r\nif (i < 8)\r\npriv->stats.txrate.ofdm[i] += ptxrate->ofdm[i];\r\nfor (j = 0; j < 4; j++)\r\npriv->stats.txrate.ht_mcs[j][i] +=\r\nptxrate->ht_mcs[j][i];\r\n}\r\n}\r\nu32 cmpk_message_handle_rx(struct net_device *dev,\r\nstruct rtllib_rx_stats *pstats)\r\n{\r\nint total_length;\r\nu8 cmd_length, exe_cnt = 0;\r\nu8 element_id;\r\nu8 *pcmd_buff;\r\nRT_TRACE(COMP_CMDPKT, "---->cmpk_message_handle_rx()\n");\r\nif (pstats == NULL)\r\nreturn 0;\r\ntotal_length = pstats->Length;\r\npcmd_buff = pstats->virtual_address;\r\nelement_id = pcmd_buff[0];\r\nwhile (total_length > 0 || exe_cnt++ > 100) {\r\nelement_id = pcmd_buff[0];\r\nswitch (element_id) {\r\ncase RX_TX_FEEDBACK:\r\nRT_TRACE(COMP_CMDPKT, "---->cmpk_message_handle_rx():"\r\n"RX_TX_FEEDBACK\n");\r\ncmpk_handle_tx_feedback(dev, pcmd_buff);\r\ncmd_length = CMPK_RX_TX_FB_SIZE;\r\nbreak;\r\ncase RX_INTERRUPT_STATUS:\r\nRT_TRACE(COMP_CMDPKT, "---->cmpk_message_handle_rx():"\r\n"RX_INTERRUPT_STATUS\n");\r\ncmpk_handle_interrupt_status(dev, pcmd_buff);\r\ncmd_length = sizeof(struct cmpk_intr_sta);\r\nbreak;\r\ncase BOTH_QUERY_CONFIG:\r\nRT_TRACE(COMP_CMDPKT, "---->cmpk_message_handle_rx():"\r\n"BOTH_QUERY_CONFIG\n");\r\ncmpk_handle_query_config_rx(dev, pcmd_buff);\r\ncmd_length = CMPK_BOTH_QUERY_CONFIG_SIZE;\r\nbreak;\r\ncase RX_TX_STATUS:\r\nRT_TRACE(COMP_CMDPKT, "---->cmpk_message_handle_rx():"\r\n"RX_TX_STATUS\n");\r\ncmpk_handle_tx_status(dev, pcmd_buff);\r\ncmd_length = CMPK_RX_TX_STS_SIZE;\r\nbreak;\r\ncase RX_TX_PER_PKT_FEEDBACK:\r\nRT_TRACE(COMP_CMDPKT, "---->cmpk_message_handle_rx():"\r\n"RX_TX_PER_PKT_FEEDBACK\n");\r\ncmd_length = CMPK_RX_TX_FB_SIZE;\r\nbreak;\r\ncase RX_TX_RATE_HISTORY:\r\nRT_TRACE(COMP_CMDPKT, "---->cmpk_message_handle_rx():"\r\n"RX_TX_HISTORY\n");\r\ncmpk_handle_tx_rate_history(dev, pcmd_buff);\r\ncmd_length = CMPK_TX_RAHIS_SIZE;\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_CMDPKT, "---->cmpk_message_handle_rx():"\r\n"unknown CMD Element\n");\r\nreturn 1;\r\n}\r\ntotal_length -= cmd_length;\r\npcmd_buff += cmd_length;\r\n}\r\nreturn 1;\r\n}
