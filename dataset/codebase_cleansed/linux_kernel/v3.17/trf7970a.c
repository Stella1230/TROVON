static int trf7970a_cmd(struct trf7970a *trf, u8 opcode)\r\n{\r\nu8 cmd = TRF7970A_CMD_BIT_CTRL | TRF7970A_CMD_BIT_OPCODE(opcode);\r\nint ret;\r\ndev_dbg(trf->dev, "cmd: 0x%x\n", cmd);\r\nret = spi_write(trf->spi, &cmd, 1);\r\nif (ret)\r\ndev_err(trf->dev, "%s - cmd: 0x%x, ret: %d\n", __func__, cmd,\r\nret);\r\nreturn ret;\r\n}\r\nstatic int trf7970a_read(struct trf7970a *trf, u8 reg, u8 *val)\r\n{\r\nu8 addr = TRF7970A_CMD_BIT_RW | reg;\r\nint ret;\r\nret = spi_write_then_read(trf->spi, &addr, 1, val, 1);\r\nif (ret)\r\ndev_err(trf->dev, "%s - addr: 0x%x, ret: %d\n", __func__, addr,\r\nret);\r\ndev_dbg(trf->dev, "read(0x%x): 0x%x\n", addr, *val);\r\nreturn ret;\r\n}\r\nstatic int trf7970a_read_cont(struct trf7970a *trf, u8 reg,\r\nu8 *buf, size_t len)\r\n{\r\nu8 addr = reg | TRF7970A_CMD_BIT_RW | TRF7970A_CMD_BIT_CONTINUOUS;\r\nint ret;\r\ndev_dbg(trf->dev, "read_cont(0x%x, %zd)\n", addr, len);\r\nret = spi_write_then_read(trf->spi, &addr, 1, buf, len);\r\nif (ret)\r\ndev_err(trf->dev, "%s - addr: 0x%x, ret: %d\n", __func__, addr,\r\nret);\r\nreturn ret;\r\n}\r\nstatic int trf7970a_write(struct trf7970a *trf, u8 reg, u8 val)\r\n{\r\nu8 buf[2] = { reg, val };\r\nint ret;\r\ndev_dbg(trf->dev, "write(0x%x): 0x%x\n", reg, val);\r\nret = spi_write(trf->spi, buf, 2);\r\nif (ret)\r\ndev_err(trf->dev, "%s - write: 0x%x 0x%x, ret: %d\n", __func__,\r\nbuf[0], buf[1], ret);\r\nreturn ret;\r\n}\r\nstatic int trf7970a_read_irqstatus(struct trf7970a *trf, u8 *status)\r\n{\r\nint ret;\r\nu8 buf[2];\r\nu8 addr;\r\naddr = TRF7970A_IRQ_STATUS | TRF7970A_CMD_BIT_RW;\r\nif (trf->quirks & TRF7970A_QUIRK_IRQ_STATUS_READ_ERRATA) {\r\naddr |= TRF7970A_CMD_BIT_CONTINUOUS;\r\nret = spi_write_then_read(trf->spi, &addr, 1, buf, 2);\r\n} else {\r\nret = spi_write_then_read(trf->spi, &addr, 1, buf, 1);\r\n}\r\nif (ret)\r\ndev_err(trf->dev, "%s - irqstatus: Status read failed: %d\n",\r\n__func__, ret);\r\nelse\r\n*status = buf[0];\r\nreturn ret;\r\n}\r\nstatic void trf7970a_send_upstream(struct trf7970a *trf)\r\n{\r\nu8 rssi;\r\ndev_kfree_skb_any(trf->tx_skb);\r\ntrf->tx_skb = NULL;\r\nif (trf->rx_skb && !IS_ERR(trf->rx_skb) && !trf->aborting)\r\nprint_hex_dump_debug("trf7970a rx data: ", DUMP_PREFIX_NONE,\r\n16, 1, trf->rx_skb->data, trf->rx_skb->len,\r\nfalse);\r\ntrf7970a_cmd(trf, TRF7970A_CMD_FIFO_RESET);\r\ntrf7970a_read(trf, TRF7970A_RSSI_OSC_STATUS, &rssi);\r\ntrf->state = TRF7970A_ST_IDLE;\r\nif (trf->aborting) {\r\ndev_dbg(trf->dev, "Abort process complete\n");\r\nif (!IS_ERR(trf->rx_skb)) {\r\nkfree_skb(trf->rx_skb);\r\ntrf->rx_skb = ERR_PTR(-ECANCELED);\r\n}\r\ntrf->aborting = false;\r\n}\r\ntrf->cb(trf->ddev, trf->cb_arg, trf->rx_skb);\r\ntrf->rx_skb = NULL;\r\n}\r\nstatic void trf7970a_send_err_upstream(struct trf7970a *trf, int errno)\r\n{\r\ndev_dbg(trf->dev, "Error - state: %d, errno: %d\n", trf->state, errno);\r\nkfree_skb(trf->rx_skb);\r\ntrf->rx_skb = ERR_PTR(errno);\r\ntrf7970a_send_upstream(trf);\r\n}\r\nstatic int trf7970a_transmit(struct trf7970a *trf, struct sk_buff *skb,\r\nunsigned int len)\r\n{\r\nunsigned int timeout;\r\nint ret;\r\nprint_hex_dump_debug("trf7970a tx data: ", DUMP_PREFIX_NONE,\r\n16, 1, skb->data, len, false);\r\nret = spi_write(trf->spi, skb->data, len);\r\nif (ret) {\r\ndev_err(trf->dev, "%s - Can't send tx data: %d\n", __func__,\r\nret);\r\nreturn ret;\r\n}\r\nskb_pull(skb, len);\r\nif (skb->len > 0) {\r\ntrf->state = TRF7970A_ST_WAIT_FOR_TX_FIFO;\r\ntimeout = TRF7970A_WAIT_FOR_FIFO_DRAIN_TIMEOUT;\r\n} else {\r\nif (trf->issue_eof) {\r\ntrf->state = TRF7970A_ST_WAIT_TO_ISSUE_EOF;\r\ntimeout = TRF7970A_WAIT_TO_ISSUE_ISO15693_EOF;\r\n} else {\r\ntrf->state = TRF7970A_ST_WAIT_FOR_RX_DATA;\r\ntimeout = trf->timeout;\r\n}\r\n}\r\ndev_dbg(trf->dev, "Setting timeout for %d ms, state: %d\n", timeout,\r\ntrf->state);\r\nschedule_delayed_work(&trf->timeout_work, msecs_to_jiffies(timeout));\r\nreturn 0;\r\n}\r\nstatic void trf7970a_fill_fifo(struct trf7970a *trf)\r\n{\r\nstruct sk_buff *skb = trf->tx_skb;\r\nunsigned int len;\r\nint ret;\r\nu8 fifo_bytes;\r\nret = trf7970a_read(trf, TRF7970A_FIFO_STATUS, &fifo_bytes);\r\nif (ret) {\r\ntrf7970a_send_err_upstream(trf, ret);\r\nreturn;\r\n}\r\ndev_dbg(trf->dev, "Filling FIFO - fifo_bytes: 0x%x\n", fifo_bytes);\r\nif (fifo_bytes & TRF7970A_FIFO_STATUS_OVERFLOW) {\r\ndev_err(trf->dev, "%s - fifo overflow: 0x%x\n", __func__,\r\nfifo_bytes);\r\ntrf7970a_send_err_upstream(trf, -EIO);\r\nreturn;\r\n}\r\nlen = TRF7970A_FIFO_SIZE - fifo_bytes;\r\nlen = min(skb->len, len);\r\nret = trf7970a_transmit(trf, skb, len);\r\nif (ret)\r\ntrf7970a_send_err_upstream(trf, ret);\r\n}\r\nstatic void trf7970a_drain_fifo(struct trf7970a *trf, u8 status)\r\n{\r\nstruct sk_buff *skb = trf->rx_skb;\r\nint ret;\r\nu8 fifo_bytes;\r\nif (status & TRF7970A_IRQ_STATUS_ERROR) {\r\ntrf7970a_send_err_upstream(trf, -EIO);\r\nreturn;\r\n}\r\nret = trf7970a_read(trf, TRF7970A_FIFO_STATUS, &fifo_bytes);\r\nif (ret) {\r\ntrf7970a_send_err_upstream(trf, ret);\r\nreturn;\r\n}\r\ndev_dbg(trf->dev, "Draining FIFO - fifo_bytes: 0x%x\n", fifo_bytes);\r\nif (!fifo_bytes)\r\ngoto no_rx_data;\r\nif (fifo_bytes & TRF7970A_FIFO_STATUS_OVERFLOW) {\r\ndev_err(trf->dev, "%s - fifo overflow: 0x%x\n", __func__,\r\nfifo_bytes);\r\ntrf7970a_send_err_upstream(trf, -EIO);\r\nreturn;\r\n}\r\nif (fifo_bytes > skb_tailroom(skb)) {\r\nskb = skb_copy_expand(skb, skb_headroom(skb),\r\nmax_t(int, fifo_bytes,\r\nTRF7970A_RX_SKB_ALLOC_SIZE),\r\nGFP_KERNEL);\r\nif (!skb) {\r\ntrf7970a_send_err_upstream(trf, -ENOMEM);\r\nreturn;\r\n}\r\nkfree_skb(trf->rx_skb);\r\ntrf->rx_skb = skb;\r\n}\r\nret = trf7970a_read_cont(trf, TRF7970A_FIFO_IO_REGISTER,\r\nskb_put(skb, fifo_bytes), fifo_bytes);\r\nif (ret) {\r\ntrf7970a_send_err_upstream(trf, ret);\r\nreturn;\r\n}\r\nif ((trf->framing == NFC_DIGITAL_FRAMING_NFCA_T2T) && (skb->len == 1) &&\r\n(trf->special_fcn_reg1 ==\r\nTRF7970A_SPECIAL_FCN_REG1_4_BIT_RX)) {\r\nskb->data[0] >>= 4;\r\nstatus = TRF7970A_IRQ_STATUS_SRX;\r\n} else {\r\ntrf->state = TRF7970A_ST_WAIT_FOR_RX_DATA_CONT;\r\n}\r\nno_rx_data:\r\nif (status == TRF7970A_IRQ_STATUS_SRX) {\r\ntrf7970a_send_upstream(trf);\r\nreturn;\r\n}\r\ndev_dbg(trf->dev, "Setting timeout for %d ms\n",\r\nTRF7970A_WAIT_FOR_RX_DATA_TIMEOUT);\r\nschedule_delayed_work(&trf->timeout_work,\r\nmsecs_to_jiffies(TRF7970A_WAIT_FOR_RX_DATA_TIMEOUT));\r\n}\r\nstatic irqreturn_t trf7970a_irq(int irq, void *dev_id)\r\n{\r\nstruct trf7970a *trf = dev_id;\r\nint ret;\r\nu8 status;\r\nmutex_lock(&trf->lock);\r\nif (trf->state == TRF7970A_ST_OFF) {\r\nmutex_unlock(&trf->lock);\r\nreturn IRQ_NONE;\r\n}\r\nret = trf7970a_read_irqstatus(trf, &status);\r\nif (ret) {\r\nmutex_unlock(&trf->lock);\r\nreturn IRQ_NONE;\r\n}\r\ndev_dbg(trf->dev, "IRQ - state: %d, status: 0x%x\n", trf->state,\r\nstatus);\r\nif (!status) {\r\nmutex_unlock(&trf->lock);\r\nreturn IRQ_NONE;\r\n}\r\nswitch (trf->state) {\r\ncase TRF7970A_ST_IDLE:\r\ncase TRF7970A_ST_IDLE_RX_BLOCKED:\r\nif (status & TRF7970A_IRQ_STATUS_ERROR) {\r\ntrf7970a_cmd(trf, TRF7970A_CMD_BLOCK_RX);\r\ntrf->state = TRF7970A_ST_IDLE_RX_BLOCKED;\r\n}\r\ntrf7970a_cmd(trf, TRF7970A_CMD_FIFO_RESET);\r\nbreak;\r\ncase TRF7970A_ST_WAIT_FOR_TX_FIFO:\r\nif (status & TRF7970A_IRQ_STATUS_TX) {\r\ntrf->ignore_timeout =\r\n!cancel_delayed_work(&trf->timeout_work);\r\ntrf7970a_fill_fifo(trf);\r\n} else {\r\ntrf7970a_send_err_upstream(trf, -EIO);\r\n}\r\nbreak;\r\ncase TRF7970A_ST_WAIT_FOR_RX_DATA:\r\ncase TRF7970A_ST_WAIT_FOR_RX_DATA_CONT:\r\nif (status & TRF7970A_IRQ_STATUS_SRX) {\r\ntrf->ignore_timeout =\r\n!cancel_delayed_work(&trf->timeout_work);\r\ntrf7970a_drain_fifo(trf, status);\r\n} else if (status == TRF7970A_IRQ_STATUS_TX) {\r\ntrf7970a_cmd(trf, TRF7970A_CMD_FIFO_RESET);\r\n} else {\r\ntrf7970a_send_err_upstream(trf, -EIO);\r\n}\r\nbreak;\r\ncase TRF7970A_ST_WAIT_TO_ISSUE_EOF:\r\nif (status != TRF7970A_IRQ_STATUS_TX)\r\ntrf7970a_send_err_upstream(trf, -EIO);\r\nbreak;\r\ndefault:\r\ndev_err(trf->dev, "%s - Driver in invalid state: %d\n",\r\n__func__, trf->state);\r\n}\r\nmutex_unlock(&trf->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void trf7970a_issue_eof(struct trf7970a *trf)\r\n{\r\nint ret;\r\ndev_dbg(trf->dev, "Issuing EOF\n");\r\nret = trf7970a_cmd(trf, TRF7970A_CMD_FIFO_RESET);\r\nif (ret)\r\ntrf7970a_send_err_upstream(trf, ret);\r\nret = trf7970a_cmd(trf, TRF7970A_CMD_EOF);\r\nif (ret)\r\ntrf7970a_send_err_upstream(trf, ret);\r\ntrf->state = TRF7970A_ST_WAIT_FOR_RX_DATA;\r\ndev_dbg(trf->dev, "Setting timeout for %d ms, state: %d\n",\r\ntrf->timeout, trf->state);\r\nschedule_delayed_work(&trf->timeout_work,\r\nmsecs_to_jiffies(trf->timeout));\r\n}\r\nstatic void trf7970a_timeout_work_handler(struct work_struct *work)\r\n{\r\nstruct trf7970a *trf = container_of(work, struct trf7970a,\r\ntimeout_work.work);\r\ndev_dbg(trf->dev, "Timeout - state: %d, ignore_timeout: %d\n",\r\ntrf->state, trf->ignore_timeout);\r\nmutex_lock(&trf->lock);\r\nif (trf->ignore_timeout)\r\ntrf->ignore_timeout = false;\r\nelse if (trf->state == TRF7970A_ST_WAIT_FOR_RX_DATA_CONT)\r\ntrf7970a_send_upstream(trf);\r\nelse if (trf->state == TRF7970A_ST_WAIT_TO_ISSUE_EOF)\r\ntrf7970a_issue_eof(trf);\r\nelse\r\ntrf7970a_send_err_upstream(trf, -ETIMEDOUT);\r\nmutex_unlock(&trf->lock);\r\n}\r\nstatic int trf7970a_init(struct trf7970a *trf)\r\n{\r\nint ret;\r\ndev_dbg(trf->dev, "Initializing device - state: %d\n", trf->state);\r\nret = trf7970a_cmd(trf, TRF7970A_CMD_SOFT_INIT);\r\nif (ret)\r\ngoto err_out;\r\nret = trf7970a_cmd(trf, TRF7970A_CMD_IDLE);\r\nif (ret)\r\ngoto err_out;\r\nret = trf7970a_write(trf, TRF7970A_NFC_TARGET_LEVEL, 0);\r\nif (ret)\r\ngoto err_out;\r\nret = trf7970a_write(trf, TRF7970A_ADJUTABLE_FIFO_IRQ_LEVELS,\r\nTRF7970A_ADJUTABLE_FIFO_IRQ_LEVELS_WLH_96 |\r\nTRF7970A_ADJUTABLE_FIFO_IRQ_LEVELS_WLL_32);\r\nif (ret)\r\ngoto err_out;\r\nret = trf7970a_write(trf, TRF7970A_SPECIAL_FCN_REG1, 0);\r\nif (ret)\r\ngoto err_out;\r\ntrf->special_fcn_reg1 = 0;\r\ntrf->iso_ctrl = 0xff;\r\nreturn 0;\r\nerr_out:\r\ndev_dbg(trf->dev, "Couldn't init device: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void trf7970a_switch_rf_off(struct trf7970a *trf)\r\n{\r\ndev_dbg(trf->dev, "Switching rf off\n");\r\ntrf->chip_status_ctrl &= ~TRF7970A_CHIP_STATUS_RF_ON;\r\ntrf7970a_write(trf, TRF7970A_CHIP_STATUS_CTRL, trf->chip_status_ctrl);\r\ntrf->aborting = false;\r\ntrf->state = TRF7970A_ST_OFF;\r\npm_runtime_mark_last_busy(trf->dev);\r\npm_runtime_put_autosuspend(trf->dev);\r\n}\r\nstatic void trf7970a_switch_rf_on(struct trf7970a *trf)\r\n{\r\ndev_dbg(trf->dev, "Switching rf on\n");\r\npm_runtime_get_sync(trf->dev);\r\ntrf->state = TRF7970A_ST_IDLE;\r\n}\r\nstatic int trf7970a_switch_rf(struct nfc_digital_dev *ddev, bool on)\r\n{\r\nstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\r\ndev_dbg(trf->dev, "Switching RF - state: %d, on: %d\n", trf->state, on);\r\nmutex_lock(&trf->lock);\r\nif (on) {\r\nswitch (trf->state) {\r\ncase TRF7970A_ST_OFF:\r\ntrf7970a_switch_rf_on(trf);\r\nbreak;\r\ncase TRF7970A_ST_IDLE:\r\ncase TRF7970A_ST_IDLE_RX_BLOCKED:\r\nbreak;\r\ndefault:\r\ndev_err(trf->dev, "%s - Invalid request: %d %d\n",\r\n__func__, trf->state, on);\r\ntrf7970a_switch_rf_off(trf);\r\n}\r\n} else {\r\nswitch (trf->state) {\r\ncase TRF7970A_ST_OFF:\r\nbreak;\r\ndefault:\r\ndev_err(trf->dev, "%s - Invalid request: %d %d\n",\r\n__func__, trf->state, on);\r\ncase TRF7970A_ST_IDLE:\r\ncase TRF7970A_ST_IDLE_RX_BLOCKED:\r\ntrf7970a_switch_rf_off(trf);\r\n}\r\n}\r\nmutex_unlock(&trf->lock);\r\nreturn 0;\r\n}\r\nstatic int trf7970a_config_rf_tech(struct trf7970a *trf, int tech)\r\n{\r\nint ret = 0;\r\ndev_dbg(trf->dev, "rf technology: %d\n", tech);\r\nswitch (tech) {\r\ncase NFC_DIGITAL_RF_TECH_106A:\r\ntrf->iso_ctrl_tech = TRF7970A_ISO_CTRL_14443A_106;\r\ntrf->modulator_sys_clk_ctrl = TRF7970A_MODULATOR_DEPTH_OOK;\r\nbreak;\r\ncase NFC_DIGITAL_RF_TECH_106B:\r\ntrf->iso_ctrl_tech = TRF7970A_ISO_CTRL_14443B_106;\r\ntrf->modulator_sys_clk_ctrl = TRF7970A_MODULATOR_DEPTH_ASK10;\r\nbreak;\r\ncase NFC_DIGITAL_RF_TECH_212F:\r\ntrf->iso_ctrl_tech = TRF7970A_ISO_CTRL_FELICA_212;\r\ntrf->modulator_sys_clk_ctrl = TRF7970A_MODULATOR_DEPTH_ASK10;\r\nbreak;\r\ncase NFC_DIGITAL_RF_TECH_424F:\r\ntrf->iso_ctrl_tech = TRF7970A_ISO_CTRL_FELICA_424;\r\ntrf->modulator_sys_clk_ctrl = TRF7970A_MODULATOR_DEPTH_ASK10;\r\nbreak;\r\ncase NFC_DIGITAL_RF_TECH_ISO15693:\r\ntrf->iso_ctrl_tech = TRF7970A_ISO_CTRL_15693_SGL_1OF4_2648;\r\ntrf->modulator_sys_clk_ctrl = TRF7970A_MODULATOR_DEPTH_OOK;\r\nbreak;\r\ndefault:\r\ndev_dbg(trf->dev, "Unsupported rf technology: %d\n", tech);\r\nreturn -EINVAL;\r\n}\r\ntrf->technology = tech;\r\nreturn ret;\r\n}\r\nstatic int trf7970a_config_framing(struct trf7970a *trf, int framing)\r\n{\r\nu8 iso_ctrl = trf->iso_ctrl_tech;\r\nint ret;\r\ndev_dbg(trf->dev, "framing: %d\n", framing);\r\nswitch (framing) {\r\ncase NFC_DIGITAL_FRAMING_NFCA_SHORT:\r\ncase NFC_DIGITAL_FRAMING_NFCA_STANDARD:\r\ntrf->tx_cmd = TRF7970A_CMD_TRANSMIT_NO_CRC;\r\niso_ctrl |= TRF7970A_ISO_CTRL_RX_CRC_N;\r\nbreak;\r\ncase NFC_DIGITAL_FRAMING_NFCA_STANDARD_WITH_CRC_A:\r\ncase NFC_DIGITAL_FRAMING_NFCA_T4T:\r\ncase NFC_DIGITAL_FRAMING_NFCB:\r\ncase NFC_DIGITAL_FRAMING_NFCB_T4T:\r\ncase NFC_DIGITAL_FRAMING_NFCF:\r\ncase NFC_DIGITAL_FRAMING_NFCF_T3T:\r\ncase NFC_DIGITAL_FRAMING_ISO15693_INVENTORY:\r\ncase NFC_DIGITAL_FRAMING_ISO15693_T5T:\r\ntrf->tx_cmd = TRF7970A_CMD_TRANSMIT;\r\niso_ctrl &= ~TRF7970A_ISO_CTRL_RX_CRC_N;\r\nbreak;\r\ncase NFC_DIGITAL_FRAMING_NFCA_T2T:\r\ntrf->tx_cmd = TRF7970A_CMD_TRANSMIT;\r\niso_ctrl |= TRF7970A_ISO_CTRL_RX_CRC_N;\r\nbreak;\r\ndefault:\r\ndev_dbg(trf->dev, "Unsupported Framing: %d\n", framing);\r\nreturn -EINVAL;\r\n}\r\ntrf->framing = framing;\r\nif (iso_ctrl != trf->iso_ctrl) {\r\nret = trf7970a_write(trf, TRF7970A_ISO_CTRL, iso_ctrl);\r\nif (ret)\r\nreturn ret;\r\ntrf->iso_ctrl = iso_ctrl;\r\nret = trf7970a_write(trf, TRF7970A_MODULATOR_SYS_CLK_CTRL,\r\ntrf->modulator_sys_clk_ctrl);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (!(trf->chip_status_ctrl & TRF7970A_CHIP_STATUS_RF_ON)) {\r\nret = trf7970a_write(trf, TRF7970A_CHIP_STATUS_CTRL,\r\ntrf->chip_status_ctrl |\r\nTRF7970A_CHIP_STATUS_RF_ON);\r\nif (ret)\r\nreturn ret;\r\ntrf->chip_status_ctrl |= TRF7970A_CHIP_STATUS_RF_ON;\r\nusleep_range(5000, 6000);\r\n}\r\nreturn 0;\r\n}\r\nstatic int trf7970a_in_configure_hw(struct nfc_digital_dev *ddev, int type,\r\nint param)\r\n{\r\nstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\r\nint ret;\r\ndev_dbg(trf->dev, "Configure hw - type: %d, param: %d\n", type, param);\r\nmutex_lock(&trf->lock);\r\nif (trf->state == TRF7970A_ST_OFF)\r\ntrf7970a_switch_rf_on(trf);\r\nswitch (type) {\r\ncase NFC_DIGITAL_CONFIG_RF_TECH:\r\nret = trf7970a_config_rf_tech(trf, param);\r\nbreak;\r\ncase NFC_DIGITAL_CONFIG_FRAMING:\r\nret = trf7970a_config_framing(trf, param);\r\nbreak;\r\ndefault:\r\ndev_dbg(trf->dev, "Unknown type: %d\n", type);\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&trf->lock);\r\nreturn ret;\r\n}\r\nstatic int trf7970a_is_iso15693_write_or_lock(u8 cmd)\r\n{\r\nswitch (cmd) {\r\ncase ISO15693_CMD_WRITE_SINGLE_BLOCK:\r\ncase ISO15693_CMD_LOCK_BLOCK:\r\ncase ISO15693_CMD_WRITE_MULTIPLE_BLOCK:\r\ncase ISO15693_CMD_WRITE_AFI:\r\ncase ISO15693_CMD_LOCK_AFI:\r\ncase ISO15693_CMD_WRITE_DSFID:\r\ncase ISO15693_CMD_LOCK_DSFID:\r\nreturn 1;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int trf7970a_per_cmd_config(struct trf7970a *trf, struct sk_buff *skb)\r\n{\r\nu8 *req = skb->data;\r\nu8 special_fcn_reg1, iso_ctrl;\r\nint ret;\r\ntrf->issue_eof = false;\r\nif ((trf->technology == NFC_DIGITAL_RF_TECH_106A) &&\r\n(trf->framing == NFC_DIGITAL_FRAMING_NFCA_T2T)) {\r\nif (req[0] == NFC_T2T_CMD_READ)\r\nspecial_fcn_reg1 = 0;\r\nelse\r\nspecial_fcn_reg1 = TRF7970A_SPECIAL_FCN_REG1_4_BIT_RX;\r\nif (special_fcn_reg1 != trf->special_fcn_reg1) {\r\nret = trf7970a_write(trf, TRF7970A_SPECIAL_FCN_REG1,\r\nspecial_fcn_reg1);\r\nif (ret)\r\nreturn ret;\r\ntrf->special_fcn_reg1 = special_fcn_reg1;\r\n}\r\n} else if (trf->technology == NFC_DIGITAL_RF_TECH_ISO15693) {\r\niso_ctrl = trf->iso_ctrl & ~TRF7970A_ISO_CTRL_RFID_SPEED_MASK;\r\nswitch (req[0] & ISO15693_REQ_FLAG_SPEED_MASK) {\r\ncase 0x00:\r\niso_ctrl |= TRF7970A_ISO_CTRL_15693_SGL_1OF4_662;\r\nbreak;\r\ncase ISO15693_REQ_FLAG_SUB_CARRIER:\r\niso_ctrl |= TRF7970A_ISO_CTRL_15693_DBL_1OF4_667a;\r\nbreak;\r\ncase ISO15693_REQ_FLAG_DATA_RATE:\r\niso_ctrl |= TRF7970A_ISO_CTRL_15693_SGL_1OF4_2648;\r\nbreak;\r\ncase (ISO15693_REQ_FLAG_SUB_CARRIER |\r\nISO15693_REQ_FLAG_DATA_RATE):\r\niso_ctrl |= TRF7970A_ISO_CTRL_15693_DBL_1OF4_2669;\r\nbreak;\r\n}\r\nif (iso_ctrl != trf->iso_ctrl) {\r\nret = trf7970a_write(trf, TRF7970A_ISO_CTRL, iso_ctrl);\r\nif (ret)\r\nreturn ret;\r\ntrf->iso_ctrl = iso_ctrl;\r\n}\r\nif ((trf->framing == NFC_DIGITAL_FRAMING_ISO15693_T5T) &&\r\ntrf7970a_is_iso15693_write_or_lock(req[1]) &&\r\n(req[0] & ISO15693_REQ_FLAG_OPTION))\r\ntrf->issue_eof = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int trf7970a_in_send_cmd(struct nfc_digital_dev *ddev,\r\nstruct sk_buff *skb, u16 timeout,\r\nnfc_digital_cmd_complete_t cb, void *arg)\r\n{\r\nstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\r\nchar *prefix;\r\nunsigned int len;\r\nint ret;\r\ndev_dbg(trf->dev, "New request - state: %d, timeout: %d ms, len: %d\n",\r\ntrf->state, timeout, skb->len);\r\nif (skb->len > TRF7970A_TX_MAX)\r\nreturn -EINVAL;\r\nmutex_lock(&trf->lock);\r\nif ((trf->state != TRF7970A_ST_IDLE) &&\r\n(trf->state != TRF7970A_ST_IDLE_RX_BLOCKED)) {\r\ndev_err(trf->dev, "%s - Bogus state: %d\n", __func__,\r\ntrf->state);\r\nret = -EIO;\r\ngoto out_err;\r\n}\r\nif (trf->aborting) {\r\ndev_dbg(trf->dev, "Abort process complete\n");\r\ntrf->aborting = false;\r\nret = -ECANCELED;\r\ngoto out_err;\r\n}\r\ntrf->rx_skb = nfc_alloc_recv_skb(TRF7970A_RX_SKB_ALLOC_SIZE,\r\nGFP_KERNEL);\r\nif (!trf->rx_skb) {\r\ndev_dbg(trf->dev, "Can't alloc rx_skb\n");\r\nret = -ENOMEM;\r\ngoto out_err;\r\n}\r\nif (trf->state == TRF7970A_ST_IDLE_RX_BLOCKED) {\r\nret = trf7970a_cmd(trf, TRF7970A_CMD_ENABLE_RX);\r\nif (ret)\r\ngoto out_err;\r\ntrf->state = TRF7970A_ST_IDLE;\r\n}\r\nret = trf7970a_per_cmd_config(trf, skb);\r\nif (ret)\r\ngoto out_err;\r\ntrf->ddev = ddev;\r\ntrf->tx_skb = skb;\r\ntrf->cb = cb;\r\ntrf->cb_arg = arg;\r\ntrf->timeout = timeout;\r\ntrf->ignore_timeout = false;\r\nlen = skb->len;\r\nprefix = skb_push(skb, TRF7970A_TX_SKB_HEADROOM);\r\nprefix[0] = TRF7970A_CMD_BIT_CTRL |\r\nTRF7970A_CMD_BIT_OPCODE(TRF7970A_CMD_FIFO_RESET);\r\nprefix[1] = TRF7970A_CMD_BIT_CTRL |\r\nTRF7970A_CMD_BIT_OPCODE(trf->tx_cmd);\r\nprefix[2] = TRF7970A_CMD_BIT_CONTINUOUS | TRF7970A_TX_LENGTH_BYTE1;\r\nif (trf->framing == NFC_DIGITAL_FRAMING_NFCA_SHORT) {\r\nprefix[3] = 0x00;\r\nprefix[4] = 0x0f;\r\n} else {\r\nprefix[3] = (len & 0xf00) >> 4;\r\nprefix[3] |= ((len & 0xf0) >> 4);\r\nprefix[4] = ((len & 0x0f) << 4);\r\n}\r\nlen = min_t(int, skb->len, TRF7970A_FIFO_SIZE);\r\nusleep_range(1000, 2000);\r\nret = trf7970a_transmit(trf, skb, len);\r\nif (ret) {\r\nkfree_skb(trf->rx_skb);\r\ntrf->rx_skb = NULL;\r\n}\r\nout_err:\r\nmutex_unlock(&trf->lock);\r\nreturn ret;\r\n}\r\nstatic int trf7970a_tg_configure_hw(struct nfc_digital_dev *ddev,\r\nint type, int param)\r\n{\r\nstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\r\ndev_dbg(trf->dev, "Unsupported interface\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int trf7970a_tg_send_cmd(struct nfc_digital_dev *ddev,\r\nstruct sk_buff *skb, u16 timeout,\r\nnfc_digital_cmd_complete_t cb, void *arg)\r\n{\r\nstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\r\ndev_dbg(trf->dev, "Unsupported interface\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int trf7970a_tg_listen(struct nfc_digital_dev *ddev,\r\nu16 timeout, nfc_digital_cmd_complete_t cb, void *arg)\r\n{\r\nstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\r\ndev_dbg(trf->dev, "Unsupported interface\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int trf7970a_tg_listen_mdaa(struct nfc_digital_dev *ddev,\r\nstruct digital_tg_mdaa_params *mdaa_params,\r\nu16 timeout, nfc_digital_cmd_complete_t cb, void *arg)\r\n{\r\nstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\r\ndev_dbg(trf->dev, "Unsupported interface\n");\r\nreturn -EINVAL;\r\n}\r\nstatic void trf7970a_abort_cmd(struct nfc_digital_dev *ddev)\r\n{\r\nstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\r\ndev_dbg(trf->dev, "Abort process initiated\n");\r\nmutex_lock(&trf->lock);\r\nswitch (trf->state) {\r\ncase TRF7970A_ST_WAIT_FOR_TX_FIFO:\r\ncase TRF7970A_ST_WAIT_FOR_RX_DATA:\r\ncase TRF7970A_ST_WAIT_FOR_RX_DATA_CONT:\r\ncase TRF7970A_ST_WAIT_TO_ISSUE_EOF:\r\ntrf->aborting = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmutex_unlock(&trf->lock);\r\n}\r\nstatic int trf7970a_get_autosuspend_delay(struct device_node *np)\r\n{\r\nint autosuspend_delay, ret;\r\nret = of_property_read_u32(np, "autosuspend-delay", &autosuspend_delay);\r\nif (ret)\r\nautosuspend_delay = TRF7970A_AUTOSUSPEND_DELAY;\r\nof_node_put(np);\r\nreturn autosuspend_delay;\r\n}\r\nstatic int trf7970a_probe(struct spi_device *spi)\r\n{\r\nstruct device_node *np = spi->dev.of_node;\r\nconst struct spi_device_id *id = spi_get_device_id(spi);\r\nstruct trf7970a *trf;\r\nint uvolts, autosuspend_delay, ret;\r\nif (!np) {\r\ndev_err(&spi->dev, "No Device Tree entry\n");\r\nreturn -EINVAL;\r\n}\r\ntrf = devm_kzalloc(&spi->dev, sizeof(*trf), GFP_KERNEL);\r\nif (!trf)\r\nreturn -ENOMEM;\r\ntrf->state = TRF7970A_ST_OFF;\r\ntrf->dev = &spi->dev;\r\ntrf->spi = spi;\r\ntrf->quirks = id->driver_data;\r\nspi->mode = SPI_MODE_1;\r\nspi->bits_per_word = 8;\r\ntrf->en_gpio = of_get_named_gpio(np, "ti,enable-gpios", 0);\r\nif (!gpio_is_valid(trf->en_gpio)) {\r\ndev_err(trf->dev, "No EN GPIO property\n");\r\nreturn trf->en_gpio;\r\n}\r\nret = devm_gpio_request_one(trf->dev, trf->en_gpio,\r\nGPIOF_DIR_OUT | GPIOF_INIT_LOW, "EN");\r\nif (ret) {\r\ndev_err(trf->dev, "Can't request EN GPIO: %d\n", ret);\r\nreturn ret;\r\n}\r\ntrf->en2_gpio = of_get_named_gpio(np, "ti,enable-gpios", 1);\r\nif (!gpio_is_valid(trf->en2_gpio)) {\r\ndev_err(trf->dev, "No EN2 GPIO property\n");\r\nreturn trf->en2_gpio;\r\n}\r\nret = devm_gpio_request_one(trf->dev, trf->en2_gpio,\r\nGPIOF_DIR_OUT | GPIOF_INIT_LOW, "EN2");\r\nif (ret) {\r\ndev_err(trf->dev, "Can't request EN2 GPIO: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_request_threaded_irq(trf->dev, spi->irq, NULL,\r\ntrf7970a_irq, IRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\n"trf7970a", trf);\r\nif (ret) {\r\ndev_err(trf->dev, "Can't request IRQ#%d: %d\n", spi->irq, ret);\r\nreturn ret;\r\n}\r\nmutex_init(&trf->lock);\r\nINIT_DELAYED_WORK(&trf->timeout_work, trf7970a_timeout_work_handler);\r\ntrf->regulator = devm_regulator_get(&spi->dev, "vin");\r\nif (IS_ERR(trf->regulator)) {\r\nret = PTR_ERR(trf->regulator);\r\ndev_err(trf->dev, "Can't get VIN regulator: %d\n", ret);\r\ngoto err_destroy_lock;\r\n}\r\nret = regulator_enable(trf->regulator);\r\nif (ret) {\r\ndev_err(trf->dev, "Can't enable VIN: %d\n", ret);\r\ngoto err_destroy_lock;\r\n}\r\nuvolts = regulator_get_voltage(trf->regulator);\r\nif (uvolts > 4000000)\r\ntrf->chip_status_ctrl = TRF7970A_CHIP_STATUS_VRS5_3;\r\ntrf->ddev = nfc_digital_allocate_device(&trf7970a_nfc_ops,\r\nTRF7970A_SUPPORTED_PROTOCOLS,\r\nNFC_DIGITAL_DRV_CAPS_IN_CRC, TRF7970A_TX_SKB_HEADROOM,\r\n0);\r\nif (!trf->ddev) {\r\ndev_err(trf->dev, "Can't allocate NFC digital device\n");\r\nret = -ENOMEM;\r\ngoto err_disable_regulator;\r\n}\r\nnfc_digital_set_parent_dev(trf->ddev, trf->dev);\r\nnfc_digital_set_drvdata(trf->ddev, trf);\r\nspi_set_drvdata(spi, trf);\r\nautosuspend_delay = trf7970a_get_autosuspend_delay(np);\r\npm_runtime_set_autosuspend_delay(trf->dev, autosuspend_delay);\r\npm_runtime_use_autosuspend(trf->dev);\r\npm_runtime_enable(trf->dev);\r\nret = nfc_digital_register_device(trf->ddev);\r\nif (ret) {\r\ndev_err(trf->dev, "Can't register NFC digital device: %d\n",\r\nret);\r\ngoto err_free_ddev;\r\n}\r\nreturn 0;\r\nerr_free_ddev:\r\npm_runtime_disable(trf->dev);\r\nnfc_digital_free_device(trf->ddev);\r\nerr_disable_regulator:\r\nregulator_disable(trf->regulator);\r\nerr_destroy_lock:\r\nmutex_destroy(&trf->lock);\r\nreturn ret;\r\n}\r\nstatic int trf7970a_remove(struct spi_device *spi)\r\n{\r\nstruct trf7970a *trf = spi_get_drvdata(spi);\r\nmutex_lock(&trf->lock);\r\nswitch (trf->state) {\r\ncase TRF7970A_ST_WAIT_FOR_TX_FIFO:\r\ncase TRF7970A_ST_WAIT_FOR_RX_DATA:\r\ncase TRF7970A_ST_WAIT_FOR_RX_DATA_CONT:\r\ncase TRF7970A_ST_WAIT_TO_ISSUE_EOF:\r\ntrf7970a_send_err_upstream(trf, -ECANCELED);\r\ncase TRF7970A_ST_IDLE:\r\ncase TRF7970A_ST_IDLE_RX_BLOCKED:\r\npm_runtime_put_sync(trf->dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmutex_unlock(&trf->lock);\r\npm_runtime_disable(trf->dev);\r\nnfc_digital_unregister_device(trf->ddev);\r\nnfc_digital_free_device(trf->ddev);\r\nregulator_disable(trf->regulator);\r\nmutex_destroy(&trf->lock);\r\nreturn 0;\r\n}\r\nstatic int trf7970a_pm_runtime_suspend(struct device *dev)\r\n{\r\nstruct spi_device *spi = container_of(dev, struct spi_device, dev);\r\nstruct trf7970a *trf = spi_get_drvdata(spi);\r\nint ret;\r\ndev_dbg(dev, "Runtime suspend\n");\r\nif (trf->state != TRF7970A_ST_OFF) {\r\ndev_dbg(dev, "Can't suspend - not in OFF state (%d)\n",\r\ntrf->state);\r\nreturn -EBUSY;\r\n}\r\ngpio_set_value(trf->en_gpio, 0);\r\ngpio_set_value(trf->en2_gpio, 0);\r\nret = regulator_disable(trf->regulator);\r\nif (ret)\r\ndev_err(dev, "%s - Can't disable VIN: %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int trf7970a_pm_runtime_resume(struct device *dev)\r\n{\r\nstruct spi_device *spi = container_of(dev, struct spi_device, dev);\r\nstruct trf7970a *trf = spi_get_drvdata(spi);\r\nint ret;\r\ndev_dbg(dev, "Runtime resume\n");\r\nret = regulator_enable(trf->regulator);\r\nif (ret) {\r\ndev_err(dev, "%s - Can't enable VIN: %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nusleep_range(5000, 6000);\r\ngpio_set_value(trf->en2_gpio, 1);\r\nusleep_range(1000, 2000);\r\ngpio_set_value(trf->en_gpio, 1);\r\nusleep_range(20000, 21000);\r\nret = trf7970a_init(trf);\r\nif (ret) {\r\ndev_err(dev, "%s - Can't initialize: %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\npm_runtime_mark_last_busy(dev);\r\nreturn 0;\r\n}
