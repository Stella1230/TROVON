static uint32_t calc_nr_buckets(unsigned nr_cells)\r\n{\r\nuint32_t n = 128;\r\nnr_cells /= 4;\r\nnr_cells = min(nr_cells, 8192u);\r\nwhile (n < nr_cells)\r\nn <<= 1;\r\nreturn n;\r\n}\r\nstatic void init_bucket(struct bucket *b)\r\n{\r\nspin_lock_init(&b->lock);\r\nINIT_HLIST_HEAD(&b->cells);\r\n}\r\nstruct dm_bio_prison *dm_bio_prison_create(unsigned nr_cells)\r\n{\r\nunsigned i;\r\nuint32_t nr_buckets = calc_nr_buckets(nr_cells);\r\nsize_t len = sizeof(struct dm_bio_prison) +\r\n(sizeof(struct bucket) * nr_buckets);\r\nstruct dm_bio_prison *prison = kmalloc(len, GFP_KERNEL);\r\nif (!prison)\r\nreturn NULL;\r\nprison->cell_pool = mempool_create_slab_pool(nr_cells, _cell_cache);\r\nif (!prison->cell_pool) {\r\nkfree(prison);\r\nreturn NULL;\r\n}\r\nprison->nr_buckets = nr_buckets;\r\nprison->hash_mask = nr_buckets - 1;\r\nprison->buckets = (struct bucket *) (prison + 1);\r\nfor (i = 0; i < nr_buckets; i++)\r\ninit_bucket(prison->buckets + i);\r\nreturn prison;\r\n}\r\nvoid dm_bio_prison_destroy(struct dm_bio_prison *prison)\r\n{\r\nmempool_destroy(prison->cell_pool);\r\nkfree(prison);\r\n}\r\nstruct dm_bio_prison_cell *dm_bio_prison_alloc_cell(struct dm_bio_prison *prison, gfp_t gfp)\r\n{\r\nreturn mempool_alloc(prison->cell_pool, gfp);\r\n}\r\nvoid dm_bio_prison_free_cell(struct dm_bio_prison *prison,\r\nstruct dm_bio_prison_cell *cell)\r\n{\r\nmempool_free(cell, prison->cell_pool);\r\n}\r\nstatic uint32_t hash_key(struct dm_bio_prison *prison, struct dm_cell_key *key)\r\n{\r\nconst unsigned long BIG_PRIME = 4294967291UL;\r\nuint64_t hash = key->block * BIG_PRIME;\r\nreturn (uint32_t) (hash & prison->hash_mask);\r\n}\r\nstatic int keys_equal(struct dm_cell_key *lhs, struct dm_cell_key *rhs)\r\n{\r\nreturn (lhs->virtual == rhs->virtual) &&\r\n(lhs->dev == rhs->dev) &&\r\n(lhs->block == rhs->block);\r\n}\r\nstatic struct bucket *get_bucket(struct dm_bio_prison *prison,\r\nstruct dm_cell_key *key)\r\n{\r\nreturn prison->buckets + hash_key(prison, key);\r\n}\r\nstatic struct dm_bio_prison_cell *__search_bucket(struct bucket *b,\r\nstruct dm_cell_key *key)\r\n{\r\nstruct dm_bio_prison_cell *cell;\r\nhlist_for_each_entry(cell, &b->cells, list)\r\nif (keys_equal(&cell->key, key))\r\nreturn cell;\r\nreturn NULL;\r\n}\r\nstatic void __setup_new_cell(struct bucket *b,\r\nstruct dm_cell_key *key,\r\nstruct bio *holder,\r\nstruct dm_bio_prison_cell *cell)\r\n{\r\nmemcpy(&cell->key, key, sizeof(cell->key));\r\ncell->holder = holder;\r\nbio_list_init(&cell->bios);\r\nhlist_add_head(&cell->list, &b->cells);\r\n}\r\nstatic int __bio_detain(struct bucket *b,\r\nstruct dm_cell_key *key,\r\nstruct bio *inmate,\r\nstruct dm_bio_prison_cell *cell_prealloc,\r\nstruct dm_bio_prison_cell **cell_result)\r\n{\r\nstruct dm_bio_prison_cell *cell;\r\ncell = __search_bucket(b, key);\r\nif (cell) {\r\nif (inmate)\r\nbio_list_add(&cell->bios, inmate);\r\n*cell_result = cell;\r\nreturn 1;\r\n}\r\n__setup_new_cell(b, key, inmate, cell_prealloc);\r\n*cell_result = cell_prealloc;\r\nreturn 0;\r\n}\r\nstatic int bio_detain(struct dm_bio_prison *prison,\r\nstruct dm_cell_key *key,\r\nstruct bio *inmate,\r\nstruct dm_bio_prison_cell *cell_prealloc,\r\nstruct dm_bio_prison_cell **cell_result)\r\n{\r\nint r;\r\nunsigned long flags;\r\nstruct bucket *b = get_bucket(prison, key);\r\nspin_lock_irqsave(&b->lock, flags);\r\nr = __bio_detain(b, key, inmate, cell_prealloc, cell_result);\r\nspin_unlock_irqrestore(&b->lock, flags);\r\nreturn r;\r\n}\r\nint dm_bio_detain(struct dm_bio_prison *prison,\r\nstruct dm_cell_key *key,\r\nstruct bio *inmate,\r\nstruct dm_bio_prison_cell *cell_prealloc,\r\nstruct dm_bio_prison_cell **cell_result)\r\n{\r\nreturn bio_detain(prison, key, inmate, cell_prealloc, cell_result);\r\n}\r\nint dm_get_cell(struct dm_bio_prison *prison,\r\nstruct dm_cell_key *key,\r\nstruct dm_bio_prison_cell *cell_prealloc,\r\nstruct dm_bio_prison_cell **cell_result)\r\n{\r\nreturn bio_detain(prison, key, NULL, cell_prealloc, cell_result);\r\n}\r\nstatic void __cell_release(struct dm_bio_prison_cell *cell,\r\nstruct bio_list *inmates)\r\n{\r\nhlist_del(&cell->list);\r\nif (inmates) {\r\nif (cell->holder)\r\nbio_list_add(inmates, cell->holder);\r\nbio_list_merge(inmates, &cell->bios);\r\n}\r\n}\r\nvoid dm_cell_release(struct dm_bio_prison *prison,\r\nstruct dm_bio_prison_cell *cell,\r\nstruct bio_list *bios)\r\n{\r\nunsigned long flags;\r\nstruct bucket *b = get_bucket(prison, &cell->key);\r\nspin_lock_irqsave(&b->lock, flags);\r\n__cell_release(cell, bios);\r\nspin_unlock_irqrestore(&b->lock, flags);\r\n}\r\nstatic void __cell_release_no_holder(struct dm_bio_prison_cell *cell,\r\nstruct bio_list *inmates)\r\n{\r\nhlist_del(&cell->list);\r\nbio_list_merge(inmates, &cell->bios);\r\n}\r\nvoid dm_cell_release_no_holder(struct dm_bio_prison *prison,\r\nstruct dm_bio_prison_cell *cell,\r\nstruct bio_list *inmates)\r\n{\r\nunsigned long flags;\r\nstruct bucket *b = get_bucket(prison, &cell->key);\r\nspin_lock_irqsave(&b->lock, flags);\r\n__cell_release_no_holder(cell, inmates);\r\nspin_unlock_irqrestore(&b->lock, flags);\r\n}\r\nvoid dm_cell_error(struct dm_bio_prison *prison,\r\nstruct dm_bio_prison_cell *cell, int error)\r\n{\r\nstruct bio_list bios;\r\nstruct bio *bio;\r\nbio_list_init(&bios);\r\ndm_cell_release(prison, cell, &bios);\r\nwhile ((bio = bio_list_pop(&bios)))\r\nbio_endio(bio, error);\r\n}\r\nstruct dm_deferred_set *dm_deferred_set_create(void)\r\n{\r\nint i;\r\nstruct dm_deferred_set *ds;\r\nds = kmalloc(sizeof(*ds), GFP_KERNEL);\r\nif (!ds)\r\nreturn NULL;\r\nspin_lock_init(&ds->lock);\r\nds->current_entry = 0;\r\nds->sweeper = 0;\r\nfor (i = 0; i < DEFERRED_SET_SIZE; i++) {\r\nds->entries[i].ds = ds;\r\nds->entries[i].count = 0;\r\nINIT_LIST_HEAD(&ds->entries[i].work_items);\r\n}\r\nreturn ds;\r\n}\r\nvoid dm_deferred_set_destroy(struct dm_deferred_set *ds)\r\n{\r\nkfree(ds);\r\n}\r\nstruct dm_deferred_entry *dm_deferred_entry_inc(struct dm_deferred_set *ds)\r\n{\r\nunsigned long flags;\r\nstruct dm_deferred_entry *entry;\r\nspin_lock_irqsave(&ds->lock, flags);\r\nentry = ds->entries + ds->current_entry;\r\nentry->count++;\r\nspin_unlock_irqrestore(&ds->lock, flags);\r\nreturn entry;\r\n}\r\nstatic unsigned ds_next(unsigned index)\r\n{\r\nreturn (index + 1) % DEFERRED_SET_SIZE;\r\n}\r\nstatic void __sweep(struct dm_deferred_set *ds, struct list_head *head)\r\n{\r\nwhile ((ds->sweeper != ds->current_entry) &&\r\n!ds->entries[ds->sweeper].count) {\r\nlist_splice_init(&ds->entries[ds->sweeper].work_items, head);\r\nds->sweeper = ds_next(ds->sweeper);\r\n}\r\nif ((ds->sweeper == ds->current_entry) && !ds->entries[ds->sweeper].count)\r\nlist_splice_init(&ds->entries[ds->sweeper].work_items, head);\r\n}\r\nvoid dm_deferred_entry_dec(struct dm_deferred_entry *entry, struct list_head *head)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&entry->ds->lock, flags);\r\nBUG_ON(!entry->count);\r\n--entry->count;\r\n__sweep(entry->ds, head);\r\nspin_unlock_irqrestore(&entry->ds->lock, flags);\r\n}\r\nint dm_deferred_set_add_work(struct dm_deferred_set *ds, struct list_head *work)\r\n{\r\nint r = 1;\r\nunsigned long flags;\r\nunsigned next_entry;\r\nspin_lock_irqsave(&ds->lock, flags);\r\nif ((ds->sweeper == ds->current_entry) &&\r\n!ds->entries[ds->current_entry].count)\r\nr = 0;\r\nelse {\r\nlist_add(work, &ds->entries[ds->current_entry].work_items);\r\nnext_entry = ds_next(ds->current_entry);\r\nif (!ds->entries[next_entry].count)\r\nds->current_entry = next_entry;\r\n}\r\nspin_unlock_irqrestore(&ds->lock, flags);\r\nreturn r;\r\n}\r\nstatic int __init dm_bio_prison_init(void)\r\n{\r\n_cell_cache = KMEM_CACHE(dm_bio_prison_cell, 0);\r\nif (!_cell_cache)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __exit dm_bio_prison_exit(void)\r\n{\r\nkmem_cache_destroy(_cell_cache);\r\n_cell_cache = NULL;\r\n}
