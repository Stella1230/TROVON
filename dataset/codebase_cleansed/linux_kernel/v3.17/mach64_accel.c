static u32 rotation24bpp(u32 dx, u32 direction)\r\n{\r\nu32 rotation;\r\nif (direction & DST_X_LEFT_TO_RIGHT) {\r\nrotation = (dx / 4) % 6;\r\n} else {\r\nrotation = ((dx + 2) / 4) % 6;\r\n}\r\nreturn ((rotation << 8) | DST_24_ROTATION_ENABLE);\r\n}\r\nvoid aty_reset_engine(const struct atyfb_par *par)\r\n{\r\naty_st_le32(GEN_TEST_CNTL,\r\naty_ld_le32(GEN_TEST_CNTL, par) &\r\n~(GUI_ENGINE_ENABLE | HWCURSOR_ENABLE), par);\r\naty_st_le32(GEN_TEST_CNTL,\r\naty_ld_le32(GEN_TEST_CNTL, par) | GUI_ENGINE_ENABLE, par);\r\naty_st_le32(BUS_CNTL,\r\naty_ld_le32(BUS_CNTL, par) | BUS_HOST_ERR_ACK | BUS_FIFO_ERR_ACK, par);\r\n}\r\nstatic void reset_GTC_3D_engine(const struct atyfb_par *par)\r\n{\r\naty_st_le32(SCALE_3D_CNTL, 0xc0, par);\r\nmdelay(GTC_3D_RESET_DELAY);\r\naty_st_le32(SETUP_CNTL, 0x00, par);\r\nmdelay(GTC_3D_RESET_DELAY);\r\naty_st_le32(SCALE_3D_CNTL, 0x00, par);\r\nmdelay(GTC_3D_RESET_DELAY);\r\n}\r\nvoid aty_init_engine(struct atyfb_par *par, struct fb_info *info)\r\n{\r\nu32 pitch_value;\r\nu32 vxres;\r\npitch_value = info->fix.line_length / (info->var.bits_per_pixel / 8);\r\nvxres = info->var.xres_virtual;\r\nif (info->var.bits_per_pixel == 24) {\r\npitch_value *= 3;\r\nvxres *= 3;\r\n}\r\nif (M64_HAS(RESET_3D))\r\nreset_GTC_3D_engine(par);\r\naty_reset_engine(par);\r\naty_st_le32(MEM_VGA_WP_SEL, 0x00010000, par);\r\naty_st_le32(MEM_VGA_RP_SEL, 0x00010000, par);\r\nwait_for_fifo(14, par);\r\naty_st_le32(CONTEXT_MASK, 0xFFFFFFFF, par);\r\naty_st_le32(DST_OFF_PITCH, (pitch_value / 8) << 22, par);\r\naty_st_le32(DST_Y_X, 0, par);\r\naty_st_le32(DST_HEIGHT, 0, par);\r\naty_st_le32(DST_BRES_ERR, 0, par);\r\naty_st_le32(DST_BRES_INC, 0, par);\r\naty_st_le32(DST_BRES_DEC, 0, par);\r\naty_st_le32(DST_CNTL, DST_LAST_PEL | DST_Y_TOP_TO_BOTTOM |\r\nDST_X_LEFT_TO_RIGHT, par);\r\naty_st_le32(SRC_OFF_PITCH, (pitch_value / 8) << 22, par);\r\naty_st_le32(SRC_Y_X, 0, par);\r\naty_st_le32(SRC_HEIGHT1_WIDTH1, 1, par);\r\naty_st_le32(SRC_Y_X_START, 0, par);\r\naty_st_le32(SRC_HEIGHT2_WIDTH2, 1, par);\r\naty_st_le32(SRC_CNTL, SRC_LINE_X_LEFT_TO_RIGHT, par);\r\nwait_for_fifo(13, par);\r\naty_st_le32(HOST_CNTL, 0, par);\r\naty_st_le32(PAT_REG0, 0, par);\r\naty_st_le32(PAT_REG1, 0, par);\r\naty_st_le32(PAT_CNTL, 0, par);\r\naty_st_le32(SC_LEFT, 0, par);\r\naty_st_le32(SC_TOP, 0, par);\r\naty_st_le32(SC_BOTTOM, par->crtc.vyres - 1, par);\r\naty_st_le32(SC_RIGHT, vxres - 1, par);\r\naty_st_le32(DP_BKGD_CLR, 0, par);\r\naty_st_le32(DP_FRGD_CLR, 0xFFFFFFFF, par);\r\naty_st_le32(DP_WRITE_MASK, 0xFFFFFFFF, par);\r\naty_st_le32(DP_MIX, FRGD_MIX_S | BKGD_MIX_D, par);\r\naty_st_le32(DP_SRC, FRGD_SRC_FRGD_CLR, par);\r\nwait_for_fifo(3, par);\r\naty_st_le32(CLR_CMP_CLR, 0, par);\r\naty_st_le32(CLR_CMP_MASK, 0xFFFFFFFF, par);\r\naty_st_le32(CLR_CMP_CNTL, 0, par);\r\nwait_for_fifo(2, par);\r\naty_st_le32(DP_PIX_WIDTH, par->crtc.dp_pix_width, par);\r\naty_st_le32(DP_CHAIN_MASK, par->crtc.dp_chain_mask, par);\r\nwait_for_fifo(5, par);\r\naty_st_le32(SCALE_3D_CNTL, 0, par);\r\naty_st_le32(Z_CNTL, 0, par);\r\naty_st_le32(CRTC_INT_CNTL, aty_ld_le32(CRTC_INT_CNTL, par) & ~0x20,\r\npar);\r\naty_st_le32(GUI_TRAJ_CNTL, 0x100023, par);\r\nwait_for_idle(par);\r\n}\r\nstatic inline void draw_rect(s16 x, s16 y, u16 width, u16 height,\r\nstruct atyfb_par *par)\r\n{\r\nwait_for_fifo(2, par);\r\naty_st_le32(DST_Y_X, (x << 16) | y, par);\r\naty_st_le32(DST_HEIGHT_WIDTH, (width << 16) | height, par);\r\npar->blitter_may_be_busy = 1;\r\n}\r\nvoid atyfb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nu32 dy = area->dy, sy = area->sy, direction = DST_LAST_PEL;\r\nu32 sx = area->sx, dx = area->dx, width = area->width, rotation = 0;\r\nif (par->asleep)\r\nreturn;\r\nif (!area->width || !area->height)\r\nreturn;\r\nif (!par->accel_flags) {\r\ncfb_copyarea(info, area);\r\nreturn;\r\n}\r\nif (info->var.bits_per_pixel == 24) {\r\nsx *= 3;\r\ndx *= 3;\r\nwidth *= 3;\r\n}\r\nif (area->sy < area->dy) {\r\ndy += area->height - 1;\r\nsy += area->height - 1;\r\n} else\r\ndirection |= DST_Y_TOP_TO_BOTTOM;\r\nif (sx < dx) {\r\ndx += width - 1;\r\nsx += width - 1;\r\n} else\r\ndirection |= DST_X_LEFT_TO_RIGHT;\r\nif (info->var.bits_per_pixel == 24) {\r\nrotation = rotation24bpp(dx, direction);\r\n}\r\nwait_for_fifo(4, par);\r\naty_st_le32(DP_SRC, FRGD_SRC_BLIT, par);\r\naty_st_le32(SRC_Y_X, (sx << 16) | sy, par);\r\naty_st_le32(SRC_HEIGHT1_WIDTH1, (width << 16) | area->height, par);\r\naty_st_le32(DST_CNTL, direction | rotation, par);\r\ndraw_rect(dx, dy, width, area->height, par);\r\n}\r\nvoid atyfb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nu32 color, dx = rect->dx, width = rect->width, rotation = 0;\r\nif (par->asleep)\r\nreturn;\r\nif (!rect->width || !rect->height)\r\nreturn;\r\nif (!par->accel_flags) {\r\ncfb_fillrect(info, rect);\r\nreturn;\r\n}\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR ||\r\ninfo->fix.visual == FB_VISUAL_DIRECTCOLOR)\r\ncolor = ((u32 *)(info->pseudo_palette))[rect->color];\r\nelse\r\ncolor = rect->color;\r\nif (info->var.bits_per_pixel == 24) {\r\ndx *= 3;\r\nwidth *= 3;\r\nrotation = rotation24bpp(dx, DST_X_LEFT_TO_RIGHT);\r\n}\r\nwait_for_fifo(3, par);\r\naty_st_le32(DP_FRGD_CLR, color, par);\r\naty_st_le32(DP_SRC,\r\nBKGD_SRC_BKGD_CLR | FRGD_SRC_FRGD_CLR | MONO_SRC_ONE,\r\npar);\r\naty_st_le32(DST_CNTL,\r\nDST_LAST_PEL | DST_Y_TOP_TO_BOTTOM |\r\nDST_X_LEFT_TO_RIGHT | rotation, par);\r\ndraw_rect(dx, rect->dy, width, rect->height, par);\r\n}\r\nvoid atyfb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nu32 src_bytes, dx = image->dx, dy = image->dy, width = image->width;\r\nu32 pix_width_save, pix_width, host_cntl, rotation = 0, src, mix;\r\nif (par->asleep)\r\nreturn;\r\nif (!image->width || !image->height)\r\nreturn;\r\nif (!par->accel_flags ||\r\n(image->depth != 1 && info->var.bits_per_pixel != image->depth)) {\r\ncfb_imageblit(info, image);\r\nreturn;\r\n}\r\npix_width = pix_width_save = aty_ld_le32(DP_PIX_WIDTH, par);\r\nhost_cntl = aty_ld_le32(HOST_CNTL, par) | HOST_BYTE_ALIGN;\r\nswitch (image->depth) {\r\ncase 1:\r\npix_width &= ~(BYTE_ORDER_MASK | HOST_MASK);\r\npix_width |= (BYTE_ORDER_MSB_TO_LSB | HOST_1BPP);\r\nbreak;\r\ncase 4:\r\npix_width &= ~(BYTE_ORDER_MASK | HOST_MASK);\r\npix_width |= (BYTE_ORDER_MSB_TO_LSB | HOST_4BPP);\r\nbreak;\r\ncase 8:\r\npix_width &= ~HOST_MASK;\r\npix_width |= HOST_8BPP;\r\nbreak;\r\ncase 15:\r\npix_width &= ~HOST_MASK;\r\npix_width |= HOST_15BPP;\r\nbreak;\r\ncase 16:\r\npix_width &= ~HOST_MASK;\r\npix_width |= HOST_16BPP;\r\nbreak;\r\ncase 24:\r\npix_width &= ~HOST_MASK;\r\npix_width |= HOST_24BPP;\r\nbreak;\r\ncase 32:\r\npix_width &= ~HOST_MASK;\r\npix_width |= HOST_32BPP;\r\nbreak;\r\n}\r\nif (info->var.bits_per_pixel == 24) {\r\ndx *= 3;\r\nwidth *= 3;\r\nrotation = rotation24bpp(dx, DST_X_LEFT_TO_RIGHT);\r\npix_width &= ~DST_MASK;\r\npix_width |= DST_8BPP;\r\nif (M64_HAS(HW_TRIPLE) && image->width % 8 == 0)\r\npix_width |= DP_HOST_TRIPLE_EN;\r\n}\r\nif (image->depth == 1) {\r\nu32 fg, bg;\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR ||\r\ninfo->fix.visual == FB_VISUAL_DIRECTCOLOR) {\r\nfg = ((u32*)(info->pseudo_palette))[image->fg_color];\r\nbg = ((u32*)(info->pseudo_palette))[image->bg_color];\r\n} else {\r\nfg = image->fg_color;\r\nbg = image->bg_color;\r\n}\r\nwait_for_fifo(2, par);\r\naty_st_le32(DP_BKGD_CLR, bg, par);\r\naty_st_le32(DP_FRGD_CLR, fg, par);\r\nsrc = MONO_SRC_HOST | FRGD_SRC_FRGD_CLR | BKGD_SRC_BKGD_CLR;\r\nmix = FRGD_MIX_S | BKGD_MIX_S;\r\n} else {\r\nsrc = MONO_SRC_ONE | FRGD_SRC_HOST;\r\nmix = FRGD_MIX_D_XOR_S | BKGD_MIX_D;\r\n}\r\nwait_for_fifo(6, par);\r\naty_st_le32(DP_WRITE_MASK, 0xFFFFFFFF, par);\r\naty_st_le32(DP_PIX_WIDTH, pix_width, par);\r\naty_st_le32(DP_MIX, mix, par);\r\naty_st_le32(DP_SRC, src, par);\r\naty_st_le32(HOST_CNTL, host_cntl, par);\r\naty_st_le32(DST_CNTL, DST_Y_TOP_TO_BOTTOM | DST_X_LEFT_TO_RIGHT | rotation, par);\r\ndraw_rect(dx, dy, width, image->height, par);\r\nsrc_bytes = (((image->width * image->depth) + 7) / 8) * image->height;\r\nif (info->var.bits_per_pixel == 24 && !(pix_width & DP_HOST_TRIPLE_EN)) {\r\nint inbit, outbit, mult24, byte_id_in_dword, width;\r\nu8 *pbitmapin = (u8*)image->data, *pbitmapout;\r\nu32 hostdword;\r\nfor (width = image->width, inbit = 7, mult24 = 0; src_bytes; ) {\r\nfor (hostdword = 0, pbitmapout = (u8*)&hostdword, byte_id_in_dword = 0;\r\nbyte_id_in_dword < 4 && src_bytes;\r\nbyte_id_in_dword++, pbitmapout++) {\r\nfor (outbit = 7; outbit >= 0; outbit--) {\r\n*pbitmapout |= (((*pbitmapin >> inbit) & 1) << outbit);\r\nmult24++;\r\nif (mult24 == 3) {\r\nmult24 = 0;\r\ninbit--;\r\nwidth--;\r\n}\r\nif (inbit < 0 || width == 0) {\r\nsrc_bytes--;\r\npbitmapin++;\r\ninbit = 7;\r\nif (width == 0) {\r\nwidth = image->width;\r\noutbit = 0;\r\n}\r\n}\r\n}\r\n}\r\nwait_for_fifo(1, par);\r\naty_st_le32(HOST_DATA0, hostdword, par);\r\n}\r\n} else {\r\nu32 *pbitmap, dwords = (src_bytes + 3) / 4;\r\nfor (pbitmap = (u32*)(image->data); dwords; dwords--, pbitmap++) {\r\nwait_for_fifo(1, par);\r\naty_st_le32(HOST_DATA0, get_unaligned_le32(pbitmap), par);\r\n}\r\n}\r\nwait_for_fifo(1, par);\r\naty_st_le32(DP_PIX_WIDTH, pix_width_save, par);\r\n}
