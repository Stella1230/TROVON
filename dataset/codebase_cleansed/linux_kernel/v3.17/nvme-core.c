static inline void _nvme_check_size(void)\r\n{\r\nBUILD_BUG_ON(sizeof(struct nvme_rw_command) != 64);\r\nBUILD_BUG_ON(sizeof(struct nvme_create_cq) != 64);\r\nBUILD_BUG_ON(sizeof(struct nvme_create_sq) != 64);\r\nBUILD_BUG_ON(sizeof(struct nvme_delete_queue) != 64);\r\nBUILD_BUG_ON(sizeof(struct nvme_features) != 64);\r\nBUILD_BUG_ON(sizeof(struct nvme_format_cmd) != 64);\r\nBUILD_BUG_ON(sizeof(struct nvme_abort_cmd) != 64);\r\nBUILD_BUG_ON(sizeof(struct nvme_command) != 64);\r\nBUILD_BUG_ON(sizeof(struct nvme_id_ctrl) != 4096);\r\nBUILD_BUG_ON(sizeof(struct nvme_id_ns) != 4096);\r\nBUILD_BUG_ON(sizeof(struct nvme_lba_range_type) != 64);\r\nBUILD_BUG_ON(sizeof(struct nvme_smart_log) != 512);\r\n}\r\nstatic struct nvme_cmd_info *nvme_cmd_info(struct nvme_queue *nvmeq)\r\n{\r\nreturn (void *)&nvmeq->cmdid_data[BITS_TO_LONGS(nvmeq->q_depth)];\r\n}\r\nstatic unsigned nvme_queue_extra(int depth)\r\n{\r\nreturn DIV_ROUND_UP(depth, 8) + (depth * sizeof(struct nvme_cmd_info));\r\n}\r\nstatic int alloc_cmdid(struct nvme_queue *nvmeq, void *ctx,\r\nnvme_completion_fn handler, unsigned timeout)\r\n{\r\nint depth = nvmeq->q_depth - 1;\r\nstruct nvme_cmd_info *info = nvme_cmd_info(nvmeq);\r\nint cmdid;\r\ndo {\r\ncmdid = find_first_zero_bit(nvmeq->cmdid_data, depth);\r\nif (cmdid >= depth)\r\nreturn -EBUSY;\r\n} while (test_and_set_bit(cmdid, nvmeq->cmdid_data));\r\ninfo[cmdid].fn = handler;\r\ninfo[cmdid].ctx = ctx;\r\ninfo[cmdid].timeout = jiffies + timeout;\r\ninfo[cmdid].aborted = 0;\r\nreturn cmdid;\r\n}\r\nstatic int alloc_cmdid_killable(struct nvme_queue *nvmeq, void *ctx,\r\nnvme_completion_fn handler, unsigned timeout)\r\n{\r\nint cmdid;\r\nwait_event_killable(nvmeq->sq_full,\r\n(cmdid = alloc_cmdid(nvmeq, ctx, handler, timeout)) >= 0);\r\nreturn (cmdid < 0) ? -EINTR : cmdid;\r\n}\r\nstatic void special_completion(struct nvme_queue *nvmeq, void *ctx,\r\nstruct nvme_completion *cqe)\r\n{\r\nif (ctx == CMD_CTX_CANCELLED)\r\nreturn;\r\nif (ctx == CMD_CTX_ABORT) {\r\n++nvmeq->dev->abort_limit;\r\nreturn;\r\n}\r\nif (ctx == CMD_CTX_COMPLETED) {\r\ndev_warn(nvmeq->q_dmadev,\r\n"completed id %d twice on queue %d\n",\r\ncqe->command_id, le16_to_cpup(&cqe->sq_id));\r\nreturn;\r\n}\r\nif (ctx == CMD_CTX_INVALID) {\r\ndev_warn(nvmeq->q_dmadev,\r\n"invalid id %d completed on queue %d\n",\r\ncqe->command_id, le16_to_cpup(&cqe->sq_id));\r\nreturn;\r\n}\r\ndev_warn(nvmeq->q_dmadev, "Unknown special completion %p\n", ctx);\r\n}\r\nstatic void async_completion(struct nvme_queue *nvmeq, void *ctx,\r\nstruct nvme_completion *cqe)\r\n{\r\nstruct async_cmd_info *cmdinfo = ctx;\r\ncmdinfo->result = le32_to_cpup(&cqe->result);\r\ncmdinfo->status = le16_to_cpup(&cqe->status) >> 1;\r\nqueue_kthread_work(cmdinfo->worker, &cmdinfo->work);\r\n}\r\nstatic void *free_cmdid(struct nvme_queue *nvmeq, int cmdid,\r\nnvme_completion_fn *fn)\r\n{\r\nvoid *ctx;\r\nstruct nvme_cmd_info *info = nvme_cmd_info(nvmeq);\r\nif (cmdid >= nvmeq->q_depth || !info[cmdid].fn) {\r\nif (fn)\r\n*fn = special_completion;\r\nreturn CMD_CTX_INVALID;\r\n}\r\nif (fn)\r\n*fn = info[cmdid].fn;\r\nctx = info[cmdid].ctx;\r\ninfo[cmdid].fn = special_completion;\r\ninfo[cmdid].ctx = CMD_CTX_COMPLETED;\r\nclear_bit(cmdid, nvmeq->cmdid_data);\r\nwake_up(&nvmeq->sq_full);\r\nreturn ctx;\r\n}\r\nstatic void *cancel_cmdid(struct nvme_queue *nvmeq, int cmdid,\r\nnvme_completion_fn *fn)\r\n{\r\nvoid *ctx;\r\nstruct nvme_cmd_info *info = nvme_cmd_info(nvmeq);\r\nif (fn)\r\n*fn = info[cmdid].fn;\r\nctx = info[cmdid].ctx;\r\ninfo[cmdid].fn = special_completion;\r\ninfo[cmdid].ctx = CMD_CTX_CANCELLED;\r\nreturn ctx;\r\n}\r\nstatic struct nvme_queue *raw_nvmeq(struct nvme_dev *dev, int qid)\r\n{\r\nreturn rcu_dereference_raw(dev->queues[qid]);\r\n}\r\nstatic struct nvme_queue *get_nvmeq(struct nvme_dev *dev) __acquires(RCU)\r\n{\r\nstruct nvme_queue *nvmeq;\r\nunsigned queue_id = get_cpu_var(*dev->io_queue);\r\nrcu_read_lock();\r\nnvmeq = rcu_dereference(dev->queues[queue_id]);\r\nif (nvmeq)\r\nreturn nvmeq;\r\nrcu_read_unlock();\r\nput_cpu_var(*dev->io_queue);\r\nreturn NULL;\r\n}\r\nstatic void put_nvmeq(struct nvme_queue *nvmeq) __releases(RCU)\r\n{\r\nrcu_read_unlock();\r\nput_cpu_var(nvmeq->dev->io_queue);\r\n}\r\nstatic struct nvme_queue *lock_nvmeq(struct nvme_dev *dev, int q_idx)\r\n__acquires(RCU)\r\n{\r\nstruct nvme_queue *nvmeq;\r\nrcu_read_lock();\r\nnvmeq = rcu_dereference(dev->queues[q_idx]);\r\nif (nvmeq)\r\nreturn nvmeq;\r\nrcu_read_unlock();\r\nreturn NULL;\r\n}\r\nstatic void unlock_nvmeq(struct nvme_queue *nvmeq) __releases(RCU)\r\n{\r\nrcu_read_unlock();\r\n}\r\nstatic int nvme_submit_cmd(struct nvme_queue *nvmeq, struct nvme_command *cmd)\r\n{\r\nunsigned long flags;\r\nu16 tail;\r\nspin_lock_irqsave(&nvmeq->q_lock, flags);\r\nif (nvmeq->q_suspended) {\r\nspin_unlock_irqrestore(&nvmeq->q_lock, flags);\r\nreturn -EBUSY;\r\n}\r\ntail = nvmeq->sq_tail;\r\nmemcpy(&nvmeq->sq_cmds[tail], cmd, sizeof(*cmd));\r\nif (++tail == nvmeq->q_depth)\r\ntail = 0;\r\nwritel(tail, nvmeq->q_db);\r\nnvmeq->sq_tail = tail;\r\nspin_unlock_irqrestore(&nvmeq->q_lock, flags);\r\nreturn 0;\r\n}\r\nstatic __le64 **iod_list(struct nvme_iod *iod)\r\n{\r\nreturn ((void *)iod) + iod->offset;\r\n}\r\nstatic int nvme_npages(unsigned size)\r\n{\r\nunsigned nprps = DIV_ROUND_UP(size + PAGE_SIZE, PAGE_SIZE);\r\nreturn DIV_ROUND_UP(8 * nprps, PAGE_SIZE - 8);\r\n}\r\nstatic struct nvme_iod *\r\nnvme_alloc_iod(unsigned nseg, unsigned nbytes, gfp_t gfp)\r\n{\r\nstruct nvme_iod *iod = kmalloc(sizeof(struct nvme_iod) +\r\nsizeof(__le64 *) * nvme_npages(nbytes) +\r\nsizeof(struct scatterlist) * nseg, gfp);\r\nif (iod) {\r\niod->offset = offsetof(struct nvme_iod, sg[nseg]);\r\niod->npages = -1;\r\niod->length = nbytes;\r\niod->nents = 0;\r\niod->first_dma = 0ULL;\r\niod->start_time = jiffies;\r\n}\r\nreturn iod;\r\n}\r\nvoid nvme_free_iod(struct nvme_dev *dev, struct nvme_iod *iod)\r\n{\r\nconst int last_prp = PAGE_SIZE / 8 - 1;\r\nint i;\r\n__le64 **list = iod_list(iod);\r\ndma_addr_t prp_dma = iod->first_dma;\r\nif (iod->npages == 0)\r\ndma_pool_free(dev->prp_small_pool, list[0], prp_dma);\r\nfor (i = 0; i < iod->npages; i++) {\r\n__le64 *prp_list = list[i];\r\ndma_addr_t next_prp_dma = le64_to_cpu(prp_list[last_prp]);\r\ndma_pool_free(dev->prp_page_pool, prp_list, prp_dma);\r\nprp_dma = next_prp_dma;\r\n}\r\nkfree(iod);\r\n}\r\nstatic void nvme_start_io_acct(struct bio *bio)\r\n{\r\nstruct gendisk *disk = bio->bi_bdev->bd_disk;\r\nif (blk_queue_io_stat(disk->queue)) {\r\nconst int rw = bio_data_dir(bio);\r\nint cpu = part_stat_lock();\r\npart_round_stats(cpu, &disk->part0);\r\npart_stat_inc(cpu, &disk->part0, ios[rw]);\r\npart_stat_add(cpu, &disk->part0, sectors[rw],\r\nbio_sectors(bio));\r\npart_inc_in_flight(&disk->part0, rw);\r\npart_stat_unlock();\r\n}\r\n}\r\nstatic void nvme_end_io_acct(struct bio *bio, unsigned long start_time)\r\n{\r\nstruct gendisk *disk = bio->bi_bdev->bd_disk;\r\nif (blk_queue_io_stat(disk->queue)) {\r\nconst int rw = bio_data_dir(bio);\r\nunsigned long duration = jiffies - start_time;\r\nint cpu = part_stat_lock();\r\npart_stat_add(cpu, &disk->part0, ticks[rw], duration);\r\npart_round_stats(cpu, &disk->part0);\r\npart_dec_in_flight(&disk->part0, rw);\r\npart_stat_unlock();\r\n}\r\n}\r\nstatic void bio_completion(struct nvme_queue *nvmeq, void *ctx,\r\nstruct nvme_completion *cqe)\r\n{\r\nstruct nvme_iod *iod = ctx;\r\nstruct bio *bio = iod->private;\r\nu16 status = le16_to_cpup(&cqe->status) >> 1;\r\nint error = 0;\r\nif (unlikely(status)) {\r\nif (!(status & NVME_SC_DNR ||\r\nbio->bi_rw & REQ_FAILFAST_MASK) &&\r\n(jiffies - iod->start_time) < IOD_TIMEOUT) {\r\nif (!waitqueue_active(&nvmeq->sq_full))\r\nadd_wait_queue(&nvmeq->sq_full,\r\n&nvmeq->sq_cong_wait);\r\nlist_add_tail(&iod->node, &nvmeq->iod_bio);\r\nwake_up(&nvmeq->sq_full);\r\nreturn;\r\n}\r\nerror = -EIO;\r\n}\r\nif (iod->nents) {\r\ndma_unmap_sg(nvmeq->q_dmadev, iod->sg, iod->nents,\r\nbio_data_dir(bio) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\r\nnvme_end_io_acct(bio, iod->start_time);\r\n}\r\nnvme_free_iod(nvmeq->dev, iod);\r\ntrace_block_bio_complete(bdev_get_queue(bio->bi_bdev), bio, error);\r\nbio_endio(bio, error);\r\n}\r\nint nvme_setup_prps(struct nvme_dev *dev, struct nvme_iod *iod, int total_len,\r\ngfp_t gfp)\r\n{\r\nstruct dma_pool *pool;\r\nint length = total_len;\r\nstruct scatterlist *sg = iod->sg;\r\nint dma_len = sg_dma_len(sg);\r\nu64 dma_addr = sg_dma_address(sg);\r\nint offset = offset_in_page(dma_addr);\r\n__le64 *prp_list;\r\n__le64 **list = iod_list(iod);\r\ndma_addr_t prp_dma;\r\nint nprps, i;\r\nlength -= (PAGE_SIZE - offset);\r\nif (length <= 0)\r\nreturn total_len;\r\ndma_len -= (PAGE_SIZE - offset);\r\nif (dma_len) {\r\ndma_addr += (PAGE_SIZE - offset);\r\n} else {\r\nsg = sg_next(sg);\r\ndma_addr = sg_dma_address(sg);\r\ndma_len = sg_dma_len(sg);\r\n}\r\nif (length <= PAGE_SIZE) {\r\niod->first_dma = dma_addr;\r\nreturn total_len;\r\n}\r\nnprps = DIV_ROUND_UP(length, PAGE_SIZE);\r\nif (nprps <= (256 / 8)) {\r\npool = dev->prp_small_pool;\r\niod->npages = 0;\r\n} else {\r\npool = dev->prp_page_pool;\r\niod->npages = 1;\r\n}\r\nprp_list = dma_pool_alloc(pool, gfp, &prp_dma);\r\nif (!prp_list) {\r\niod->first_dma = dma_addr;\r\niod->npages = -1;\r\nreturn (total_len - length) + PAGE_SIZE;\r\n}\r\nlist[0] = prp_list;\r\niod->first_dma = prp_dma;\r\ni = 0;\r\nfor (;;) {\r\nif (i == PAGE_SIZE / 8) {\r\n__le64 *old_prp_list = prp_list;\r\nprp_list = dma_pool_alloc(pool, gfp, &prp_dma);\r\nif (!prp_list)\r\nreturn total_len - length;\r\nlist[iod->npages++] = prp_list;\r\nprp_list[0] = old_prp_list[i - 1];\r\nold_prp_list[i - 1] = cpu_to_le64(prp_dma);\r\ni = 1;\r\n}\r\nprp_list[i++] = cpu_to_le64(dma_addr);\r\ndma_len -= PAGE_SIZE;\r\ndma_addr += PAGE_SIZE;\r\nlength -= PAGE_SIZE;\r\nif (length <= 0)\r\nbreak;\r\nif (dma_len > 0)\r\ncontinue;\r\nBUG_ON(dma_len < 0);\r\nsg = sg_next(sg);\r\ndma_addr = sg_dma_address(sg);\r\ndma_len = sg_dma_len(sg);\r\n}\r\nreturn total_len;\r\n}\r\nstatic int nvme_split_and_submit(struct bio *bio, struct nvme_queue *nvmeq,\r\nint len)\r\n{\r\nstruct bio *split = bio_split(bio, len >> 9, GFP_ATOMIC, NULL);\r\nif (!split)\r\nreturn -ENOMEM;\r\ntrace_block_split(bdev_get_queue(bio->bi_bdev), bio,\r\nsplit->bi_iter.bi_sector);\r\nbio_chain(split, bio);\r\nif (!waitqueue_active(&nvmeq->sq_full))\r\nadd_wait_queue(&nvmeq->sq_full, &nvmeq->sq_cong_wait);\r\nbio_list_add(&nvmeq->sq_cong, split);\r\nbio_list_add(&nvmeq->sq_cong, bio);\r\nwake_up(&nvmeq->sq_full);\r\nreturn 0;\r\n}\r\nstatic int nvme_map_bio(struct nvme_queue *nvmeq, struct nvme_iod *iod,\r\nstruct bio *bio, enum dma_data_direction dma_dir, int psegs)\r\n{\r\nstruct bio_vec bvec, bvprv;\r\nstruct bvec_iter iter;\r\nstruct scatterlist *sg = NULL;\r\nint length = 0, nsegs = 0, split_len = bio->bi_iter.bi_size;\r\nint first = 1;\r\nif (nvmeq->dev->stripe_size)\r\nsplit_len = nvmeq->dev->stripe_size -\r\n((bio->bi_iter.bi_sector << 9) &\r\n(nvmeq->dev->stripe_size - 1));\r\nsg_init_table(iod->sg, psegs);\r\nbio_for_each_segment(bvec, bio, iter) {\r\nif (!first && BIOVEC_PHYS_MERGEABLE(&bvprv, &bvec)) {\r\nsg->length += bvec.bv_len;\r\n} else {\r\nif (!first && BIOVEC_NOT_VIRT_MERGEABLE(&bvprv, &bvec))\r\nreturn nvme_split_and_submit(bio, nvmeq,\r\nlength);\r\nsg = sg ? sg + 1 : iod->sg;\r\nsg_set_page(sg, bvec.bv_page,\r\nbvec.bv_len, bvec.bv_offset);\r\nnsegs++;\r\n}\r\nif (split_len - length < bvec.bv_len)\r\nreturn nvme_split_and_submit(bio, nvmeq, split_len);\r\nlength += bvec.bv_len;\r\nbvprv = bvec;\r\nfirst = 0;\r\n}\r\niod->nents = nsegs;\r\nsg_mark_end(sg);\r\nif (dma_map_sg(nvmeq->q_dmadev, iod->sg, iod->nents, dma_dir) == 0)\r\nreturn -ENOMEM;\r\nBUG_ON(length != bio->bi_iter.bi_size);\r\nreturn length;\r\n}\r\nstatic int nvme_submit_discard(struct nvme_queue *nvmeq, struct nvme_ns *ns,\r\nstruct bio *bio, struct nvme_iod *iod, int cmdid)\r\n{\r\nstruct nvme_dsm_range *range =\r\n(struct nvme_dsm_range *)iod_list(iod)[0];\r\nstruct nvme_command *cmnd = &nvmeq->sq_cmds[nvmeq->sq_tail];\r\nrange->cattr = cpu_to_le32(0);\r\nrange->nlb = cpu_to_le32(bio->bi_iter.bi_size >> ns->lba_shift);\r\nrange->slba = cpu_to_le64(nvme_block_nr(ns, bio->bi_iter.bi_sector));\r\nmemset(cmnd, 0, sizeof(*cmnd));\r\ncmnd->dsm.opcode = nvme_cmd_dsm;\r\ncmnd->dsm.command_id = cmdid;\r\ncmnd->dsm.nsid = cpu_to_le32(ns->ns_id);\r\ncmnd->dsm.prp1 = cpu_to_le64(iod->first_dma);\r\ncmnd->dsm.nr = 0;\r\ncmnd->dsm.attributes = cpu_to_le32(NVME_DSMGMT_AD);\r\nif (++nvmeq->sq_tail == nvmeq->q_depth)\r\nnvmeq->sq_tail = 0;\r\nwritel(nvmeq->sq_tail, nvmeq->q_db);\r\nreturn 0;\r\n}\r\nstatic int nvme_submit_flush(struct nvme_queue *nvmeq, struct nvme_ns *ns,\r\nint cmdid)\r\n{\r\nstruct nvme_command *cmnd = &nvmeq->sq_cmds[nvmeq->sq_tail];\r\nmemset(cmnd, 0, sizeof(*cmnd));\r\ncmnd->common.opcode = nvme_cmd_flush;\r\ncmnd->common.command_id = cmdid;\r\ncmnd->common.nsid = cpu_to_le32(ns->ns_id);\r\nif (++nvmeq->sq_tail == nvmeq->q_depth)\r\nnvmeq->sq_tail = 0;\r\nwritel(nvmeq->sq_tail, nvmeq->q_db);\r\nreturn 0;\r\n}\r\nstatic int nvme_submit_iod(struct nvme_queue *nvmeq, struct nvme_iod *iod)\r\n{\r\nstruct bio *bio = iod->private;\r\nstruct nvme_ns *ns = bio->bi_bdev->bd_disk->private_data;\r\nstruct nvme_command *cmnd;\r\nint cmdid;\r\nu16 control;\r\nu32 dsmgmt;\r\ncmdid = alloc_cmdid(nvmeq, iod, bio_completion, NVME_IO_TIMEOUT);\r\nif (unlikely(cmdid < 0))\r\nreturn cmdid;\r\nif (bio->bi_rw & REQ_DISCARD)\r\nreturn nvme_submit_discard(nvmeq, ns, bio, iod, cmdid);\r\nif (bio->bi_rw & REQ_FLUSH)\r\nreturn nvme_submit_flush(nvmeq, ns, cmdid);\r\ncontrol = 0;\r\nif (bio->bi_rw & REQ_FUA)\r\ncontrol |= NVME_RW_FUA;\r\nif (bio->bi_rw & (REQ_FAILFAST_DEV | REQ_RAHEAD))\r\ncontrol |= NVME_RW_LR;\r\ndsmgmt = 0;\r\nif (bio->bi_rw & REQ_RAHEAD)\r\ndsmgmt |= NVME_RW_DSM_FREQ_PREFETCH;\r\ncmnd = &nvmeq->sq_cmds[nvmeq->sq_tail];\r\nmemset(cmnd, 0, sizeof(*cmnd));\r\ncmnd->rw.opcode = bio_data_dir(bio) ? nvme_cmd_write : nvme_cmd_read;\r\ncmnd->rw.command_id = cmdid;\r\ncmnd->rw.nsid = cpu_to_le32(ns->ns_id);\r\ncmnd->rw.prp1 = cpu_to_le64(sg_dma_address(iod->sg));\r\ncmnd->rw.prp2 = cpu_to_le64(iod->first_dma);\r\ncmnd->rw.slba = cpu_to_le64(nvme_block_nr(ns, bio->bi_iter.bi_sector));\r\ncmnd->rw.length =\r\ncpu_to_le16((bio->bi_iter.bi_size >> ns->lba_shift) - 1);\r\ncmnd->rw.control = cpu_to_le16(control);\r\ncmnd->rw.dsmgmt = cpu_to_le32(dsmgmt);\r\nif (++nvmeq->sq_tail == nvmeq->q_depth)\r\nnvmeq->sq_tail = 0;\r\nwritel(nvmeq->sq_tail, nvmeq->q_db);\r\nreturn 0;\r\n}\r\nstatic int nvme_split_flush_data(struct nvme_queue *nvmeq, struct bio *bio)\r\n{\r\nstruct bio *split = bio_clone(bio, GFP_ATOMIC);\r\nif (!split)\r\nreturn -ENOMEM;\r\nsplit->bi_iter.bi_size = 0;\r\nsplit->bi_phys_segments = 0;\r\nbio->bi_rw &= ~REQ_FLUSH;\r\nbio_chain(split, bio);\r\nif (!waitqueue_active(&nvmeq->sq_full))\r\nadd_wait_queue(&nvmeq->sq_full, &nvmeq->sq_cong_wait);\r\nbio_list_add(&nvmeq->sq_cong, split);\r\nbio_list_add(&nvmeq->sq_cong, bio);\r\nwake_up_process(nvme_thread);\r\nreturn 0;\r\n}\r\nstatic int nvme_submit_bio_queue(struct nvme_queue *nvmeq, struct nvme_ns *ns,\r\nstruct bio *bio)\r\n{\r\nstruct nvme_iod *iod;\r\nint psegs = bio_phys_segments(ns->queue, bio);\r\nint result;\r\nif ((bio->bi_rw & REQ_FLUSH) && psegs)\r\nreturn nvme_split_flush_data(nvmeq, bio);\r\niod = nvme_alloc_iod(psegs, bio->bi_iter.bi_size, GFP_ATOMIC);\r\nif (!iod)\r\nreturn -ENOMEM;\r\niod->private = bio;\r\nif (bio->bi_rw & REQ_DISCARD) {\r\nvoid *range;\r\nrange = dma_pool_alloc(nvmeq->dev->prp_small_pool,\r\nGFP_ATOMIC,\r\n&iod->first_dma);\r\nif (!range) {\r\nresult = -ENOMEM;\r\ngoto free_iod;\r\n}\r\niod_list(iod)[0] = (__le64 *)range;\r\niod->npages = 0;\r\n} else if (psegs) {\r\nresult = nvme_map_bio(nvmeq, iod, bio,\r\nbio_data_dir(bio) ? DMA_TO_DEVICE : DMA_FROM_DEVICE,\r\npsegs);\r\nif (result <= 0)\r\ngoto free_iod;\r\nif (nvme_setup_prps(nvmeq->dev, iod, result, GFP_ATOMIC) !=\r\nresult) {\r\nresult = -ENOMEM;\r\ngoto free_iod;\r\n}\r\nnvme_start_io_acct(bio);\r\n}\r\nif (unlikely(nvme_submit_iod(nvmeq, iod))) {\r\nif (!waitqueue_active(&nvmeq->sq_full))\r\nadd_wait_queue(&nvmeq->sq_full, &nvmeq->sq_cong_wait);\r\nlist_add_tail(&iod->node, &nvmeq->iod_bio);\r\n}\r\nreturn 0;\r\nfree_iod:\r\nnvme_free_iod(nvmeq->dev, iod);\r\nreturn result;\r\n}\r\nstatic int nvme_process_cq(struct nvme_queue *nvmeq)\r\n{\r\nu16 head, phase;\r\nhead = nvmeq->cq_head;\r\nphase = nvmeq->cq_phase;\r\nfor (;;) {\r\nvoid *ctx;\r\nnvme_completion_fn fn;\r\nstruct nvme_completion cqe = nvmeq->cqes[head];\r\nif ((le16_to_cpu(cqe.status) & 1) != phase)\r\nbreak;\r\nnvmeq->sq_head = le16_to_cpu(cqe.sq_head);\r\nif (++head == nvmeq->q_depth) {\r\nhead = 0;\r\nphase = !phase;\r\n}\r\nctx = free_cmdid(nvmeq, cqe.command_id, &fn);\r\nfn(nvmeq, ctx, &cqe);\r\n}\r\nif (head == nvmeq->cq_head && phase == nvmeq->cq_phase)\r\nreturn 0;\r\nwritel(head, nvmeq->q_db + nvmeq->dev->db_stride);\r\nnvmeq->cq_head = head;\r\nnvmeq->cq_phase = phase;\r\nnvmeq->cqe_seen = 1;\r\nreturn 1;\r\n}\r\nstatic void nvme_make_request(struct request_queue *q, struct bio *bio)\r\n{\r\nstruct nvme_ns *ns = q->queuedata;\r\nstruct nvme_queue *nvmeq = get_nvmeq(ns->dev);\r\nint result = -EBUSY;\r\nif (!nvmeq) {\r\nbio_endio(bio, -EIO);\r\nreturn;\r\n}\r\nspin_lock_irq(&nvmeq->q_lock);\r\nif (!nvmeq->q_suspended && bio_list_empty(&nvmeq->sq_cong))\r\nresult = nvme_submit_bio_queue(nvmeq, ns, bio);\r\nif (unlikely(result)) {\r\nif (!waitqueue_active(&nvmeq->sq_full))\r\nadd_wait_queue(&nvmeq->sq_full, &nvmeq->sq_cong_wait);\r\nbio_list_add(&nvmeq->sq_cong, bio);\r\n}\r\nnvme_process_cq(nvmeq);\r\nspin_unlock_irq(&nvmeq->q_lock);\r\nput_nvmeq(nvmeq);\r\n}\r\nstatic irqreturn_t nvme_irq(int irq, void *data)\r\n{\r\nirqreturn_t result;\r\nstruct nvme_queue *nvmeq = data;\r\nspin_lock(&nvmeq->q_lock);\r\nnvme_process_cq(nvmeq);\r\nresult = nvmeq->cqe_seen ? IRQ_HANDLED : IRQ_NONE;\r\nnvmeq->cqe_seen = 0;\r\nspin_unlock(&nvmeq->q_lock);\r\nreturn result;\r\n}\r\nstatic irqreturn_t nvme_irq_check(int irq, void *data)\r\n{\r\nstruct nvme_queue *nvmeq = data;\r\nstruct nvme_completion cqe = nvmeq->cqes[nvmeq->cq_head];\r\nif ((le16_to_cpu(cqe.status) & 1) != nvmeq->cq_phase)\r\nreturn IRQ_NONE;\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic void nvme_abort_command(struct nvme_queue *nvmeq, int cmdid)\r\n{\r\nspin_lock_irq(&nvmeq->q_lock);\r\ncancel_cmdid(nvmeq, cmdid, NULL);\r\nspin_unlock_irq(&nvmeq->q_lock);\r\n}\r\nstatic void sync_completion(struct nvme_queue *nvmeq, void *ctx,\r\nstruct nvme_completion *cqe)\r\n{\r\nstruct sync_cmd_info *cmdinfo = ctx;\r\ncmdinfo->result = le32_to_cpup(&cqe->result);\r\ncmdinfo->status = le16_to_cpup(&cqe->status) >> 1;\r\nwake_up_process(cmdinfo->task);\r\n}\r\nstatic int nvme_submit_sync_cmd(struct nvme_dev *dev, int q_idx,\r\nstruct nvme_command *cmd,\r\nu32 *result, unsigned timeout)\r\n{\r\nint cmdid, ret;\r\nstruct sync_cmd_info cmdinfo;\r\nstruct nvme_queue *nvmeq;\r\nnvmeq = lock_nvmeq(dev, q_idx);\r\nif (!nvmeq)\r\nreturn -ENODEV;\r\ncmdinfo.task = current;\r\ncmdinfo.status = -EINTR;\r\ncmdid = alloc_cmdid(nvmeq, &cmdinfo, sync_completion, timeout);\r\nif (cmdid < 0) {\r\nunlock_nvmeq(nvmeq);\r\nreturn cmdid;\r\n}\r\ncmd->common.command_id = cmdid;\r\nset_current_state(TASK_KILLABLE);\r\nret = nvme_submit_cmd(nvmeq, cmd);\r\nif (ret) {\r\nfree_cmdid(nvmeq, cmdid, NULL);\r\nunlock_nvmeq(nvmeq);\r\nset_current_state(TASK_RUNNING);\r\nreturn ret;\r\n}\r\nunlock_nvmeq(nvmeq);\r\nschedule_timeout(timeout);\r\nif (cmdinfo.status == -EINTR) {\r\nnvmeq = lock_nvmeq(dev, q_idx);\r\nif (nvmeq) {\r\nnvme_abort_command(nvmeq, cmdid);\r\nunlock_nvmeq(nvmeq);\r\n}\r\nreturn -EINTR;\r\n}\r\nif (result)\r\n*result = cmdinfo.result;\r\nreturn cmdinfo.status;\r\n}\r\nstatic int nvme_submit_async_cmd(struct nvme_queue *nvmeq,\r\nstruct nvme_command *cmd,\r\nstruct async_cmd_info *cmdinfo, unsigned timeout)\r\n{\r\nint cmdid;\r\ncmdid = alloc_cmdid_killable(nvmeq, cmdinfo, async_completion, timeout);\r\nif (cmdid < 0)\r\nreturn cmdid;\r\ncmdinfo->status = -EINTR;\r\ncmd->common.command_id = cmdid;\r\nreturn nvme_submit_cmd(nvmeq, cmd);\r\n}\r\nint nvme_submit_admin_cmd(struct nvme_dev *dev, struct nvme_command *cmd,\r\nu32 *result)\r\n{\r\nreturn nvme_submit_sync_cmd(dev, 0, cmd, result, ADMIN_TIMEOUT);\r\n}\r\nint nvme_submit_io_cmd(struct nvme_dev *dev, struct nvme_command *cmd,\r\nu32 *result)\r\n{\r\nreturn nvme_submit_sync_cmd(dev, smp_processor_id() + 1, cmd, result,\r\nNVME_IO_TIMEOUT);\r\n}\r\nstatic int nvme_submit_admin_cmd_async(struct nvme_dev *dev,\r\nstruct nvme_command *cmd, struct async_cmd_info *cmdinfo)\r\n{\r\nreturn nvme_submit_async_cmd(raw_nvmeq(dev, 0), cmd, cmdinfo,\r\nADMIN_TIMEOUT);\r\n}\r\nstatic int adapter_delete_queue(struct nvme_dev *dev, u8 opcode, u16 id)\r\n{\r\nint status;\r\nstruct nvme_command c;\r\nmemset(&c, 0, sizeof(c));\r\nc.delete_queue.opcode = opcode;\r\nc.delete_queue.qid = cpu_to_le16(id);\r\nstatus = nvme_submit_admin_cmd(dev, &c, NULL);\r\nif (status)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int adapter_alloc_cq(struct nvme_dev *dev, u16 qid,\r\nstruct nvme_queue *nvmeq)\r\n{\r\nint status;\r\nstruct nvme_command c;\r\nint flags = NVME_QUEUE_PHYS_CONTIG | NVME_CQ_IRQ_ENABLED;\r\nmemset(&c, 0, sizeof(c));\r\nc.create_cq.opcode = nvme_admin_create_cq;\r\nc.create_cq.prp1 = cpu_to_le64(nvmeq->cq_dma_addr);\r\nc.create_cq.cqid = cpu_to_le16(qid);\r\nc.create_cq.qsize = cpu_to_le16(nvmeq->q_depth - 1);\r\nc.create_cq.cq_flags = cpu_to_le16(flags);\r\nc.create_cq.irq_vector = cpu_to_le16(nvmeq->cq_vector);\r\nstatus = nvme_submit_admin_cmd(dev, &c, NULL);\r\nif (status)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int adapter_alloc_sq(struct nvme_dev *dev, u16 qid,\r\nstruct nvme_queue *nvmeq)\r\n{\r\nint status;\r\nstruct nvme_command c;\r\nint flags = NVME_QUEUE_PHYS_CONTIG | NVME_SQ_PRIO_MEDIUM;\r\nmemset(&c, 0, sizeof(c));\r\nc.create_sq.opcode = nvme_admin_create_sq;\r\nc.create_sq.prp1 = cpu_to_le64(nvmeq->sq_dma_addr);\r\nc.create_sq.sqid = cpu_to_le16(qid);\r\nc.create_sq.qsize = cpu_to_le16(nvmeq->q_depth - 1);\r\nc.create_sq.sq_flags = cpu_to_le16(flags);\r\nc.create_sq.cqid = cpu_to_le16(qid);\r\nstatus = nvme_submit_admin_cmd(dev, &c, NULL);\r\nif (status)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int adapter_delete_cq(struct nvme_dev *dev, u16 cqid)\r\n{\r\nreturn adapter_delete_queue(dev, nvme_admin_delete_cq, cqid);\r\n}\r\nstatic int adapter_delete_sq(struct nvme_dev *dev, u16 sqid)\r\n{\r\nreturn adapter_delete_queue(dev, nvme_admin_delete_sq, sqid);\r\n}\r\nint nvme_identify(struct nvme_dev *dev, unsigned nsid, unsigned cns,\r\ndma_addr_t dma_addr)\r\n{\r\nstruct nvme_command c;\r\nmemset(&c, 0, sizeof(c));\r\nc.identify.opcode = nvme_admin_identify;\r\nc.identify.nsid = cpu_to_le32(nsid);\r\nc.identify.prp1 = cpu_to_le64(dma_addr);\r\nc.identify.cns = cpu_to_le32(cns);\r\nreturn nvme_submit_admin_cmd(dev, &c, NULL);\r\n}\r\nint nvme_get_features(struct nvme_dev *dev, unsigned fid, unsigned nsid,\r\ndma_addr_t dma_addr, u32 *result)\r\n{\r\nstruct nvme_command c;\r\nmemset(&c, 0, sizeof(c));\r\nc.features.opcode = nvme_admin_get_features;\r\nc.features.nsid = cpu_to_le32(nsid);\r\nc.features.prp1 = cpu_to_le64(dma_addr);\r\nc.features.fid = cpu_to_le32(fid);\r\nreturn nvme_submit_admin_cmd(dev, &c, result);\r\n}\r\nint nvme_set_features(struct nvme_dev *dev, unsigned fid, unsigned dword11,\r\ndma_addr_t dma_addr, u32 *result)\r\n{\r\nstruct nvme_command c;\r\nmemset(&c, 0, sizeof(c));\r\nc.features.opcode = nvme_admin_set_features;\r\nc.features.prp1 = cpu_to_le64(dma_addr);\r\nc.features.fid = cpu_to_le32(fid);\r\nc.features.dword11 = cpu_to_le32(dword11);\r\nreturn nvme_submit_admin_cmd(dev, &c, result);\r\n}\r\nstatic void nvme_abort_cmd(int cmdid, struct nvme_queue *nvmeq)\r\n{\r\nint a_cmdid;\r\nstruct nvme_command cmd;\r\nstruct nvme_dev *dev = nvmeq->dev;\r\nstruct nvme_cmd_info *info = nvme_cmd_info(nvmeq);\r\nstruct nvme_queue *adminq;\r\nif (!nvmeq->qid || info[cmdid].aborted) {\r\nif (work_busy(&dev->reset_work))\r\nreturn;\r\nlist_del_init(&dev->node);\r\ndev_warn(&dev->pci_dev->dev,\r\n"I/O %d QID %d timeout, reset controller\n", cmdid,\r\nnvmeq->qid);\r\ndev->reset_workfn = nvme_reset_failed_dev;\r\nqueue_work(nvme_workq, &dev->reset_work);\r\nreturn;\r\n}\r\nif (!dev->abort_limit)\r\nreturn;\r\nadminq = rcu_dereference(dev->queues[0]);\r\na_cmdid = alloc_cmdid(adminq, CMD_CTX_ABORT, special_completion,\r\nADMIN_TIMEOUT);\r\nif (a_cmdid < 0)\r\nreturn;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.abort.opcode = nvme_admin_abort_cmd;\r\ncmd.abort.cid = cmdid;\r\ncmd.abort.sqid = cpu_to_le16(nvmeq->qid);\r\ncmd.abort.command_id = a_cmdid;\r\n--dev->abort_limit;\r\ninfo[cmdid].aborted = 1;\r\ninfo[cmdid].timeout = jiffies + ADMIN_TIMEOUT;\r\ndev_warn(nvmeq->q_dmadev, "Aborting I/O %d QID %d\n", cmdid,\r\nnvmeq->qid);\r\nnvme_submit_cmd(adminq, &cmd);\r\n}\r\nstatic void nvme_cancel_ios(struct nvme_queue *nvmeq, bool timeout)\r\n{\r\nint depth = nvmeq->q_depth - 1;\r\nstruct nvme_cmd_info *info = nvme_cmd_info(nvmeq);\r\nunsigned long now = jiffies;\r\nint cmdid;\r\nfor_each_set_bit(cmdid, nvmeq->cmdid_data, depth) {\r\nvoid *ctx;\r\nnvme_completion_fn fn;\r\nstatic struct nvme_completion cqe = {\r\n.status = cpu_to_le16(NVME_SC_ABORT_REQ << 1),\r\n};\r\nif (timeout && !time_after(now, info[cmdid].timeout))\r\ncontinue;\r\nif (info[cmdid].ctx == CMD_CTX_CANCELLED)\r\ncontinue;\r\nif (timeout && nvmeq->dev->initialized) {\r\nnvme_abort_cmd(cmdid, nvmeq);\r\ncontinue;\r\n}\r\ndev_warn(nvmeq->q_dmadev, "Cancelling I/O %d QID %d\n", cmdid,\r\nnvmeq->qid);\r\nctx = cancel_cmdid(nvmeq, cmdid, &fn);\r\nfn(nvmeq, ctx, &cqe);\r\n}\r\n}\r\nstatic void nvme_free_queue(struct rcu_head *r)\r\n{\r\nstruct nvme_queue *nvmeq = container_of(r, struct nvme_queue, r_head);\r\nspin_lock_irq(&nvmeq->q_lock);\r\nwhile (bio_list_peek(&nvmeq->sq_cong)) {\r\nstruct bio *bio = bio_list_pop(&nvmeq->sq_cong);\r\nbio_endio(bio, -EIO);\r\n}\r\nwhile (!list_empty(&nvmeq->iod_bio)) {\r\nstatic struct nvme_completion cqe = {\r\n.status = cpu_to_le16(\r\n(NVME_SC_ABORT_REQ | NVME_SC_DNR) << 1),\r\n};\r\nstruct nvme_iod *iod = list_first_entry(&nvmeq->iod_bio,\r\nstruct nvme_iod,\r\nnode);\r\nlist_del(&iod->node);\r\nbio_completion(nvmeq, iod, &cqe);\r\n}\r\nspin_unlock_irq(&nvmeq->q_lock);\r\ndma_free_coherent(nvmeq->q_dmadev, CQ_SIZE(nvmeq->q_depth),\r\n(void *)nvmeq->cqes, nvmeq->cq_dma_addr);\r\ndma_free_coherent(nvmeq->q_dmadev, SQ_SIZE(nvmeq->q_depth),\r\nnvmeq->sq_cmds, nvmeq->sq_dma_addr);\r\nif (nvmeq->qid)\r\nfree_cpumask_var(nvmeq->cpu_mask);\r\nkfree(nvmeq);\r\n}\r\nstatic void nvme_free_queues(struct nvme_dev *dev, int lowest)\r\n{\r\nint i;\r\nfor (i = dev->queue_count - 1; i >= lowest; i--) {\r\nstruct nvme_queue *nvmeq = raw_nvmeq(dev, i);\r\nrcu_assign_pointer(dev->queues[i], NULL);\r\ncall_rcu(&nvmeq->r_head, nvme_free_queue);\r\ndev->queue_count--;\r\n}\r\n}\r\nstatic int nvme_suspend_queue(struct nvme_queue *nvmeq)\r\n{\r\nint vector = nvmeq->dev->entry[nvmeq->cq_vector].vector;\r\nspin_lock_irq(&nvmeq->q_lock);\r\nif (nvmeq->q_suspended) {\r\nspin_unlock_irq(&nvmeq->q_lock);\r\nreturn 1;\r\n}\r\nnvmeq->q_suspended = 1;\r\nnvmeq->dev->online_queues--;\r\nspin_unlock_irq(&nvmeq->q_lock);\r\nirq_set_affinity_hint(vector, NULL);\r\nfree_irq(vector, nvmeq);\r\nreturn 0;\r\n}\r\nstatic void nvme_clear_queue(struct nvme_queue *nvmeq)\r\n{\r\nspin_lock_irq(&nvmeq->q_lock);\r\nnvme_process_cq(nvmeq);\r\nnvme_cancel_ios(nvmeq, false);\r\nspin_unlock_irq(&nvmeq->q_lock);\r\n}\r\nstatic void nvme_disable_queue(struct nvme_dev *dev, int qid)\r\n{\r\nstruct nvme_queue *nvmeq = raw_nvmeq(dev, qid);\r\nif (!nvmeq)\r\nreturn;\r\nif (nvme_suspend_queue(nvmeq))\r\nreturn;\r\nif (qid && readl(&dev->bar->csts) != -1) {\r\nadapter_delete_sq(dev, qid);\r\nadapter_delete_cq(dev, qid);\r\n}\r\nnvme_clear_queue(nvmeq);\r\n}\r\nstatic struct nvme_queue *nvme_alloc_queue(struct nvme_dev *dev, int qid,\r\nint depth, int vector)\r\n{\r\nstruct device *dmadev = &dev->pci_dev->dev;\r\nunsigned extra = nvme_queue_extra(depth);\r\nstruct nvme_queue *nvmeq = kzalloc(sizeof(*nvmeq) + extra, GFP_KERNEL);\r\nif (!nvmeq)\r\nreturn NULL;\r\nnvmeq->cqes = dma_alloc_coherent(dmadev, CQ_SIZE(depth),\r\n&nvmeq->cq_dma_addr, GFP_KERNEL);\r\nif (!nvmeq->cqes)\r\ngoto free_nvmeq;\r\nmemset((void *)nvmeq->cqes, 0, CQ_SIZE(depth));\r\nnvmeq->sq_cmds = dma_alloc_coherent(dmadev, SQ_SIZE(depth),\r\n&nvmeq->sq_dma_addr, GFP_KERNEL);\r\nif (!nvmeq->sq_cmds)\r\ngoto free_cqdma;\r\nif (qid && !zalloc_cpumask_var(&nvmeq->cpu_mask, GFP_KERNEL))\r\ngoto free_sqdma;\r\nnvmeq->q_dmadev = dmadev;\r\nnvmeq->dev = dev;\r\nsnprintf(nvmeq->irqname, sizeof(nvmeq->irqname), "nvme%dq%d",\r\ndev->instance, qid);\r\nspin_lock_init(&nvmeq->q_lock);\r\nnvmeq->cq_head = 0;\r\nnvmeq->cq_phase = 1;\r\ninit_waitqueue_head(&nvmeq->sq_full);\r\ninit_waitqueue_entry(&nvmeq->sq_cong_wait, nvme_thread);\r\nbio_list_init(&nvmeq->sq_cong);\r\nINIT_LIST_HEAD(&nvmeq->iod_bio);\r\nnvmeq->q_db = &dev->dbs[qid * 2 * dev->db_stride];\r\nnvmeq->q_depth = depth;\r\nnvmeq->cq_vector = vector;\r\nnvmeq->qid = qid;\r\nnvmeq->q_suspended = 1;\r\ndev->queue_count++;\r\nrcu_assign_pointer(dev->queues[qid], nvmeq);\r\nreturn nvmeq;\r\nfree_sqdma:\r\ndma_free_coherent(dmadev, SQ_SIZE(depth), (void *)nvmeq->sq_cmds,\r\nnvmeq->sq_dma_addr);\r\nfree_cqdma:\r\ndma_free_coherent(dmadev, CQ_SIZE(depth), (void *)nvmeq->cqes,\r\nnvmeq->cq_dma_addr);\r\nfree_nvmeq:\r\nkfree(nvmeq);\r\nreturn NULL;\r\n}\r\nstatic int queue_request_irq(struct nvme_dev *dev, struct nvme_queue *nvmeq,\r\nconst char *name)\r\n{\r\nif (use_threaded_interrupts)\r\nreturn request_threaded_irq(dev->entry[nvmeq->cq_vector].vector,\r\nnvme_irq_check, nvme_irq, IRQF_SHARED,\r\nname, nvmeq);\r\nreturn request_irq(dev->entry[nvmeq->cq_vector].vector, nvme_irq,\r\nIRQF_SHARED, name, nvmeq);\r\n}\r\nstatic void nvme_init_queue(struct nvme_queue *nvmeq, u16 qid)\r\n{\r\nstruct nvme_dev *dev = nvmeq->dev;\r\nunsigned extra = nvme_queue_extra(nvmeq->q_depth);\r\nnvmeq->sq_tail = 0;\r\nnvmeq->cq_head = 0;\r\nnvmeq->cq_phase = 1;\r\nnvmeq->q_db = &dev->dbs[qid * 2 * dev->db_stride];\r\nmemset(nvmeq->cmdid_data, 0, extra);\r\nmemset((void *)nvmeq->cqes, 0, CQ_SIZE(nvmeq->q_depth));\r\nnvme_cancel_ios(nvmeq, false);\r\nnvmeq->q_suspended = 0;\r\ndev->online_queues++;\r\n}\r\nstatic int nvme_create_queue(struct nvme_queue *nvmeq, int qid)\r\n{\r\nstruct nvme_dev *dev = nvmeq->dev;\r\nint result;\r\nresult = adapter_alloc_cq(dev, qid, nvmeq);\r\nif (result < 0)\r\nreturn result;\r\nresult = adapter_alloc_sq(dev, qid, nvmeq);\r\nif (result < 0)\r\ngoto release_cq;\r\nresult = queue_request_irq(dev, nvmeq, nvmeq->irqname);\r\nif (result < 0)\r\ngoto release_sq;\r\nspin_lock_irq(&nvmeq->q_lock);\r\nnvme_init_queue(nvmeq, qid);\r\nspin_unlock_irq(&nvmeq->q_lock);\r\nreturn result;\r\nrelease_sq:\r\nadapter_delete_sq(dev, qid);\r\nrelease_cq:\r\nadapter_delete_cq(dev, qid);\r\nreturn result;\r\n}\r\nstatic int nvme_wait_ready(struct nvme_dev *dev, u64 cap, bool enabled)\r\n{\r\nunsigned long timeout;\r\nu32 bit = enabled ? NVME_CSTS_RDY : 0;\r\ntimeout = ((NVME_CAP_TIMEOUT(cap) + 1) * HZ / 2) + jiffies;\r\nwhile ((readl(&dev->bar->csts) & NVME_CSTS_RDY) != bit) {\r\nmsleep(100);\r\nif (fatal_signal_pending(current))\r\nreturn -EINTR;\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(&dev->pci_dev->dev,\r\n"Device not ready; aborting %s\n", enabled ?\r\n"initialisation" : "reset");\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int nvme_disable_ctrl(struct nvme_dev *dev, u64 cap)\r\n{\r\nu32 cc = readl(&dev->bar->cc);\r\nif (cc & NVME_CC_ENABLE)\r\nwritel(cc & ~NVME_CC_ENABLE, &dev->bar->cc);\r\nreturn nvme_wait_ready(dev, cap, false);\r\n}\r\nstatic int nvme_enable_ctrl(struct nvme_dev *dev, u64 cap)\r\n{\r\nreturn nvme_wait_ready(dev, cap, true);\r\n}\r\nstatic int nvme_shutdown_ctrl(struct nvme_dev *dev)\r\n{\r\nunsigned long timeout;\r\nu32 cc;\r\ncc = (readl(&dev->bar->cc) & ~NVME_CC_SHN_MASK) | NVME_CC_SHN_NORMAL;\r\nwritel(cc, &dev->bar->cc);\r\ntimeout = 2 * HZ + jiffies;\r\nwhile ((readl(&dev->bar->csts) & NVME_CSTS_SHST_MASK) !=\r\nNVME_CSTS_SHST_CMPLT) {\r\nmsleep(100);\r\nif (fatal_signal_pending(current))\r\nreturn -EINTR;\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(&dev->pci_dev->dev,\r\n"Device shutdown incomplete; abort shutdown\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int nvme_configure_admin_queue(struct nvme_dev *dev)\r\n{\r\nint result;\r\nu32 aqa;\r\nu64 cap = readq(&dev->bar->cap);\r\nstruct nvme_queue *nvmeq;\r\nresult = nvme_disable_ctrl(dev, cap);\r\nif (result < 0)\r\nreturn result;\r\nnvmeq = raw_nvmeq(dev, 0);\r\nif (!nvmeq) {\r\nnvmeq = nvme_alloc_queue(dev, 0, 64, 0);\r\nif (!nvmeq)\r\nreturn -ENOMEM;\r\n}\r\naqa = nvmeq->q_depth - 1;\r\naqa |= aqa << 16;\r\ndev->ctrl_config = NVME_CC_ENABLE | NVME_CC_CSS_NVM;\r\ndev->ctrl_config |= (PAGE_SHIFT - 12) << NVME_CC_MPS_SHIFT;\r\ndev->ctrl_config |= NVME_CC_ARB_RR | NVME_CC_SHN_NONE;\r\ndev->ctrl_config |= NVME_CC_IOSQES | NVME_CC_IOCQES;\r\nwritel(aqa, &dev->bar->aqa);\r\nwriteq(nvmeq->sq_dma_addr, &dev->bar->asq);\r\nwriteq(nvmeq->cq_dma_addr, &dev->bar->acq);\r\nwritel(dev->ctrl_config, &dev->bar->cc);\r\nresult = nvme_enable_ctrl(dev, cap);\r\nif (result)\r\nreturn result;\r\nresult = queue_request_irq(dev, nvmeq, nvmeq->irqname);\r\nif (result)\r\nreturn result;\r\nspin_lock_irq(&nvmeq->q_lock);\r\nnvme_init_queue(nvmeq, 0);\r\nspin_unlock_irq(&nvmeq->q_lock);\r\nreturn result;\r\n}\r\nstruct nvme_iod *nvme_map_user_pages(struct nvme_dev *dev, int write,\r\nunsigned long addr, unsigned length)\r\n{\r\nint i, err, count, nents, offset;\r\nstruct scatterlist *sg;\r\nstruct page **pages;\r\nstruct nvme_iod *iod;\r\nif (addr & 3)\r\nreturn ERR_PTR(-EINVAL);\r\nif (!length || length > INT_MAX - PAGE_SIZE)\r\nreturn ERR_PTR(-EINVAL);\r\noffset = offset_in_page(addr);\r\ncount = DIV_ROUND_UP(offset + length, PAGE_SIZE);\r\npages = kcalloc(count, sizeof(*pages), GFP_KERNEL);\r\nif (!pages)\r\nreturn ERR_PTR(-ENOMEM);\r\nerr = get_user_pages_fast(addr, count, 1, pages);\r\nif (err < count) {\r\ncount = err;\r\nerr = -EFAULT;\r\ngoto put_pages;\r\n}\r\nerr = -ENOMEM;\r\niod = nvme_alloc_iod(count, length, GFP_KERNEL);\r\nif (!iod)\r\ngoto put_pages;\r\nsg = iod->sg;\r\nsg_init_table(sg, count);\r\nfor (i = 0; i < count; i++) {\r\nsg_set_page(&sg[i], pages[i],\r\nmin_t(unsigned, length, PAGE_SIZE - offset),\r\noffset);\r\nlength -= (PAGE_SIZE - offset);\r\noffset = 0;\r\n}\r\nsg_mark_end(&sg[i - 1]);\r\niod->nents = count;\r\nnents = dma_map_sg(&dev->pci_dev->dev, sg, count,\r\nwrite ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\r\nif (!nents)\r\ngoto free_iod;\r\nkfree(pages);\r\nreturn iod;\r\nfree_iod:\r\nkfree(iod);\r\nput_pages:\r\nfor (i = 0; i < count; i++)\r\nput_page(pages[i]);\r\nkfree(pages);\r\nreturn ERR_PTR(err);\r\n}\r\nvoid nvme_unmap_user_pages(struct nvme_dev *dev, int write,\r\nstruct nvme_iod *iod)\r\n{\r\nint i;\r\ndma_unmap_sg(&dev->pci_dev->dev, iod->sg, iod->nents,\r\nwrite ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\r\nfor (i = 0; i < iod->nents; i++)\r\nput_page(sg_page(&iod->sg[i]));\r\n}\r\nstatic int nvme_submit_io(struct nvme_ns *ns, struct nvme_user_io __user *uio)\r\n{\r\nstruct nvme_dev *dev = ns->dev;\r\nstruct nvme_user_io io;\r\nstruct nvme_command c;\r\nunsigned length, meta_len;\r\nint status, i;\r\nstruct nvme_iod *iod, *meta_iod = NULL;\r\ndma_addr_t meta_dma_addr;\r\nvoid *meta, *uninitialized_var(meta_mem);\r\nif (copy_from_user(&io, uio, sizeof(io)))\r\nreturn -EFAULT;\r\nlength = (io.nblocks + 1) << ns->lba_shift;\r\nmeta_len = (io.nblocks + 1) * ns->ms;\r\nif (meta_len && ((io.metadata & 3) || !io.metadata))\r\nreturn -EINVAL;\r\nswitch (io.opcode) {\r\ncase nvme_cmd_write:\r\ncase nvme_cmd_read:\r\ncase nvme_cmd_compare:\r\niod = nvme_map_user_pages(dev, io.opcode & 1, io.addr, length);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (IS_ERR(iod))\r\nreturn PTR_ERR(iod);\r\nmemset(&c, 0, sizeof(c));\r\nc.rw.opcode = io.opcode;\r\nc.rw.flags = io.flags;\r\nc.rw.nsid = cpu_to_le32(ns->ns_id);\r\nc.rw.slba = cpu_to_le64(io.slba);\r\nc.rw.length = cpu_to_le16(io.nblocks);\r\nc.rw.control = cpu_to_le16(io.control);\r\nc.rw.dsmgmt = cpu_to_le32(io.dsmgmt);\r\nc.rw.reftag = cpu_to_le32(io.reftag);\r\nc.rw.apptag = cpu_to_le16(io.apptag);\r\nc.rw.appmask = cpu_to_le16(io.appmask);\r\nif (meta_len) {\r\nmeta_iod = nvme_map_user_pages(dev, io.opcode & 1, io.metadata,\r\nmeta_len);\r\nif (IS_ERR(meta_iod)) {\r\nstatus = PTR_ERR(meta_iod);\r\nmeta_iod = NULL;\r\ngoto unmap;\r\n}\r\nmeta_mem = dma_alloc_coherent(&dev->pci_dev->dev, meta_len,\r\n&meta_dma_addr, GFP_KERNEL);\r\nif (!meta_mem) {\r\nstatus = -ENOMEM;\r\ngoto unmap;\r\n}\r\nif (io.opcode & 1) {\r\nint meta_offset = 0;\r\nfor (i = 0; i < meta_iod->nents; i++) {\r\nmeta = kmap_atomic(sg_page(&meta_iod->sg[i])) +\r\nmeta_iod->sg[i].offset;\r\nmemcpy(meta_mem + meta_offset, meta,\r\nmeta_iod->sg[i].length);\r\nkunmap_atomic(meta);\r\nmeta_offset += meta_iod->sg[i].length;\r\n}\r\n}\r\nc.rw.metadata = cpu_to_le64(meta_dma_addr);\r\n}\r\nlength = nvme_setup_prps(dev, iod, length, GFP_KERNEL);\r\nc.rw.prp1 = cpu_to_le64(sg_dma_address(iod->sg));\r\nc.rw.prp2 = cpu_to_le64(iod->first_dma);\r\nif (length != (io.nblocks + 1) << ns->lba_shift)\r\nstatus = -ENOMEM;\r\nelse\r\nstatus = nvme_submit_io_cmd(dev, &c, NULL);\r\nif (meta_len) {\r\nif (status == NVME_SC_SUCCESS && !(io.opcode & 1)) {\r\nint meta_offset = 0;\r\nfor (i = 0; i < meta_iod->nents; i++) {\r\nmeta = kmap_atomic(sg_page(&meta_iod->sg[i])) +\r\nmeta_iod->sg[i].offset;\r\nmemcpy(meta, meta_mem + meta_offset,\r\nmeta_iod->sg[i].length);\r\nkunmap_atomic(meta);\r\nmeta_offset += meta_iod->sg[i].length;\r\n}\r\n}\r\ndma_free_coherent(&dev->pci_dev->dev, meta_len, meta_mem,\r\nmeta_dma_addr);\r\n}\r\nunmap:\r\nnvme_unmap_user_pages(dev, io.opcode & 1, iod);\r\nnvme_free_iod(dev, iod);\r\nif (meta_iod) {\r\nnvme_unmap_user_pages(dev, io.opcode & 1, meta_iod);\r\nnvme_free_iod(dev, meta_iod);\r\n}\r\nreturn status;\r\n}\r\nstatic int nvme_user_admin_cmd(struct nvme_dev *dev,\r\nstruct nvme_admin_cmd __user *ucmd)\r\n{\r\nstruct nvme_admin_cmd cmd;\r\nstruct nvme_command c;\r\nint status, length;\r\nstruct nvme_iod *uninitialized_var(iod);\r\nunsigned timeout;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (copy_from_user(&cmd, ucmd, sizeof(cmd)))\r\nreturn -EFAULT;\r\nmemset(&c, 0, sizeof(c));\r\nc.common.opcode = cmd.opcode;\r\nc.common.flags = cmd.flags;\r\nc.common.nsid = cpu_to_le32(cmd.nsid);\r\nc.common.cdw2[0] = cpu_to_le32(cmd.cdw2);\r\nc.common.cdw2[1] = cpu_to_le32(cmd.cdw3);\r\nc.common.cdw10[0] = cpu_to_le32(cmd.cdw10);\r\nc.common.cdw10[1] = cpu_to_le32(cmd.cdw11);\r\nc.common.cdw10[2] = cpu_to_le32(cmd.cdw12);\r\nc.common.cdw10[3] = cpu_to_le32(cmd.cdw13);\r\nc.common.cdw10[4] = cpu_to_le32(cmd.cdw14);\r\nc.common.cdw10[5] = cpu_to_le32(cmd.cdw15);\r\nlength = cmd.data_len;\r\nif (cmd.data_len) {\r\niod = nvme_map_user_pages(dev, cmd.opcode & 1, cmd.addr,\r\nlength);\r\nif (IS_ERR(iod))\r\nreturn PTR_ERR(iod);\r\nlength = nvme_setup_prps(dev, iod, length, GFP_KERNEL);\r\nc.common.prp1 = cpu_to_le64(sg_dma_address(iod->sg));\r\nc.common.prp2 = cpu_to_le64(iod->first_dma);\r\n}\r\ntimeout = cmd.timeout_ms ? msecs_to_jiffies(cmd.timeout_ms) :\r\nADMIN_TIMEOUT;\r\nif (length != cmd.data_len)\r\nstatus = -ENOMEM;\r\nelse\r\nstatus = nvme_submit_sync_cmd(dev, 0, &c, &cmd.result, timeout);\r\nif (cmd.data_len) {\r\nnvme_unmap_user_pages(dev, cmd.opcode & 1, iod);\r\nnvme_free_iod(dev, iod);\r\n}\r\nif ((status >= 0) && copy_to_user(&ucmd->result, &cmd.result,\r\nsizeof(cmd.result)))\r\nstatus = -EFAULT;\r\nreturn status;\r\n}\r\nstatic int nvme_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct nvme_ns *ns = bdev->bd_disk->private_data;\r\nswitch (cmd) {\r\ncase NVME_IOCTL_ID:\r\nforce_successful_syscall_return();\r\nreturn ns->ns_id;\r\ncase NVME_IOCTL_ADMIN_CMD:\r\nreturn nvme_user_admin_cmd(ns->dev, (void __user *)arg);\r\ncase NVME_IOCTL_SUBMIT_IO:\r\nreturn nvme_submit_io(ns, (void __user *)arg);\r\ncase SG_GET_VERSION_NUM:\r\nreturn nvme_sg_get_version_num((void __user *)arg);\r\ncase SG_IO:\r\nreturn nvme_sg_io(ns, (void __user *)arg);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int nvme_compat_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct nvme_ns *ns = bdev->bd_disk->private_data;\r\nswitch (cmd) {\r\ncase SG_IO:\r\nreturn nvme_sg_io32(ns, arg);\r\n}\r\nreturn nvme_ioctl(bdev, mode, cmd, arg);\r\n}\r\nstatic int nvme_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct nvme_ns *ns = bdev->bd_disk->private_data;\r\nstruct nvme_dev *dev = ns->dev;\r\nkref_get(&dev->kref);\r\nreturn 0;\r\n}\r\nstatic void nvme_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct nvme_ns *ns = disk->private_data;\r\nstruct nvme_dev *dev = ns->dev;\r\nkref_put(&dev->kref, nvme_free_dev);\r\n}\r\nstatic int nvme_getgeo(struct block_device *bd, struct hd_geometry *geo)\r\n{\r\ngeo->heads = 1 << 6;\r\ngeo->sectors = 1 << 5;\r\ngeo->cylinders = get_capacity(bd->bd_disk) >> 11;\r\nreturn 0;\r\n}\r\nstatic void nvme_resubmit_iods(struct nvme_queue *nvmeq)\r\n{\r\nstruct nvme_iod *iod, *next;\r\nlist_for_each_entry_safe(iod, next, &nvmeq->iod_bio, node) {\r\nif (unlikely(nvme_submit_iod(nvmeq, iod)))\r\nbreak;\r\nlist_del(&iod->node);\r\nif (bio_list_empty(&nvmeq->sq_cong) &&\r\nlist_empty(&nvmeq->iod_bio))\r\nremove_wait_queue(&nvmeq->sq_full,\r\n&nvmeq->sq_cong_wait);\r\n}\r\n}\r\nstatic void nvme_resubmit_bios(struct nvme_queue *nvmeq)\r\n{\r\nwhile (bio_list_peek(&nvmeq->sq_cong)) {\r\nstruct bio *bio = bio_list_pop(&nvmeq->sq_cong);\r\nstruct nvme_ns *ns = bio->bi_bdev->bd_disk->private_data;\r\nif (bio_list_empty(&nvmeq->sq_cong) &&\r\nlist_empty(&nvmeq->iod_bio))\r\nremove_wait_queue(&nvmeq->sq_full,\r\n&nvmeq->sq_cong_wait);\r\nif (nvme_submit_bio_queue(nvmeq, ns, bio)) {\r\nif (!waitqueue_active(&nvmeq->sq_full))\r\nadd_wait_queue(&nvmeq->sq_full,\r\n&nvmeq->sq_cong_wait);\r\nbio_list_add_head(&nvmeq->sq_cong, bio);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int nvme_kthread(void *data)\r\n{\r\nstruct nvme_dev *dev, *next;\r\nwhile (!kthread_should_stop()) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_lock(&dev_list_lock);\r\nlist_for_each_entry_safe(dev, next, &dev_list, node) {\r\nint i;\r\nif (readl(&dev->bar->csts) & NVME_CSTS_CFS &&\r\ndev->initialized) {\r\nif (work_busy(&dev->reset_work))\r\ncontinue;\r\nlist_del_init(&dev->node);\r\ndev_warn(&dev->pci_dev->dev,\r\n"Failed status, reset controller\n");\r\ndev->reset_workfn = nvme_reset_failed_dev;\r\nqueue_work(nvme_workq, &dev->reset_work);\r\ncontinue;\r\n}\r\nrcu_read_lock();\r\nfor (i = 0; i < dev->queue_count; i++) {\r\nstruct nvme_queue *nvmeq =\r\nrcu_dereference(dev->queues[i]);\r\nif (!nvmeq)\r\ncontinue;\r\nspin_lock_irq(&nvmeq->q_lock);\r\nif (nvmeq->q_suspended)\r\ngoto unlock;\r\nnvme_process_cq(nvmeq);\r\nnvme_cancel_ios(nvmeq, true);\r\nnvme_resubmit_bios(nvmeq);\r\nnvme_resubmit_iods(nvmeq);\r\nunlock:\r\nspin_unlock_irq(&nvmeq->q_lock);\r\n}\r\nrcu_read_unlock();\r\n}\r\nspin_unlock(&dev_list_lock);\r\nschedule_timeout(round_jiffies_relative(HZ));\r\n}\r\nreturn 0;\r\n}\r\nstatic void nvme_config_discard(struct nvme_ns *ns)\r\n{\r\nu32 logical_block_size = queue_logical_block_size(ns->queue);\r\nns->queue->limits.discard_zeroes_data = 0;\r\nns->queue->limits.discard_alignment = logical_block_size;\r\nns->queue->limits.discard_granularity = logical_block_size;\r\nns->queue->limits.max_discard_sectors = 0xffffffff;\r\nqueue_flag_set_unlocked(QUEUE_FLAG_DISCARD, ns->queue);\r\n}\r\nstatic struct nvme_ns *nvme_alloc_ns(struct nvme_dev *dev, unsigned nsid,\r\nstruct nvme_id_ns *id, struct nvme_lba_range_type *rt)\r\n{\r\nstruct nvme_ns *ns;\r\nstruct gendisk *disk;\r\nint lbaf;\r\nif (rt->attributes & NVME_LBART_ATTRIB_HIDE)\r\nreturn NULL;\r\nns = kzalloc(sizeof(*ns), GFP_KERNEL);\r\nif (!ns)\r\nreturn NULL;\r\nns->queue = blk_alloc_queue(GFP_KERNEL);\r\nif (!ns->queue)\r\ngoto out_free_ns;\r\nns->queue->queue_flags = QUEUE_FLAG_DEFAULT;\r\nqueue_flag_set_unlocked(QUEUE_FLAG_NOMERGES, ns->queue);\r\nqueue_flag_set_unlocked(QUEUE_FLAG_NONROT, ns->queue);\r\nblk_queue_make_request(ns->queue, nvme_make_request);\r\nns->dev = dev;\r\nns->queue->queuedata = ns;\r\ndisk = alloc_disk(0);\r\nif (!disk)\r\ngoto out_free_queue;\r\nns->ns_id = nsid;\r\nns->disk = disk;\r\nlbaf = id->flbas & 0xf;\r\nns->lba_shift = id->lbaf[lbaf].ds;\r\nns->ms = le16_to_cpu(id->lbaf[lbaf].ms);\r\nblk_queue_logical_block_size(ns->queue, 1 << ns->lba_shift);\r\nif (dev->max_hw_sectors)\r\nblk_queue_max_hw_sectors(ns->queue, dev->max_hw_sectors);\r\nif (dev->vwc & NVME_CTRL_VWC_PRESENT)\r\nblk_queue_flush(ns->queue, REQ_FLUSH | REQ_FUA);\r\ndisk->major = nvme_major;\r\ndisk->first_minor = 0;\r\ndisk->fops = &nvme_fops;\r\ndisk->private_data = ns;\r\ndisk->queue = ns->queue;\r\ndisk->driverfs_dev = &dev->pci_dev->dev;\r\ndisk->flags = GENHD_FL_EXT_DEVT;\r\nsprintf(disk->disk_name, "nvme%dn%d", dev->instance, nsid);\r\nset_capacity(disk, le64_to_cpup(&id->nsze) << (ns->lba_shift - 9));\r\nif (dev->oncs & NVME_CTRL_ONCS_DSM)\r\nnvme_config_discard(ns);\r\nreturn ns;\r\nout_free_queue:\r\nblk_cleanup_queue(ns->queue);\r\nout_free_ns:\r\nkfree(ns);\r\nreturn NULL;\r\n}\r\nstatic int nvme_find_closest_node(int node)\r\n{\r\nint n, val, min_val = INT_MAX, best_node = node;\r\nfor_each_online_node(n) {\r\nif (n == node)\r\ncontinue;\r\nval = node_distance(node, n);\r\nif (val < min_val) {\r\nmin_val = val;\r\nbest_node = n;\r\n}\r\n}\r\nreturn best_node;\r\n}\r\nstatic void nvme_set_queue_cpus(cpumask_t *qmask, struct nvme_queue *nvmeq,\r\nint count)\r\n{\r\nint cpu;\r\nfor_each_cpu(cpu, qmask) {\r\nif (cpumask_weight(nvmeq->cpu_mask) >= count)\r\nbreak;\r\nif (!cpumask_test_and_set_cpu(cpu, nvmeq->cpu_mask))\r\n*per_cpu_ptr(nvmeq->dev->io_queue, cpu) = nvmeq->qid;\r\n}\r\n}\r\nstatic void nvme_add_cpus(cpumask_t *mask, const cpumask_t *unassigned_cpus,\r\nconst cpumask_t *new_mask, struct nvme_queue *nvmeq, int cpus_per_queue)\r\n{\r\nint next_cpu;\r\nfor_each_cpu(next_cpu, new_mask) {\r\ncpumask_or(mask, mask, get_cpu_mask(next_cpu));\r\ncpumask_or(mask, mask, topology_thread_cpumask(next_cpu));\r\ncpumask_and(mask, mask, unassigned_cpus);\r\nnvme_set_queue_cpus(mask, nvmeq, cpus_per_queue);\r\n}\r\n}\r\nstatic void nvme_create_io_queues(struct nvme_dev *dev)\r\n{\r\nunsigned i, max;\r\nmax = min(dev->max_qid, num_online_cpus());\r\nfor (i = dev->queue_count; i <= max; i++)\r\nif (!nvme_alloc_queue(dev, i, dev->q_depth, i - 1))\r\nbreak;\r\nmax = min(dev->queue_count - 1, num_online_cpus());\r\nfor (i = dev->online_queues; i <= max; i++)\r\nif (nvme_create_queue(raw_nvmeq(dev, i), i))\r\nbreak;\r\n}\r\nstatic void nvme_assign_io_queues(struct nvme_dev *dev)\r\n{\r\nunsigned cpu, cpus_per_queue, queues, remainder, i;\r\ncpumask_var_t unassigned_cpus;\r\nnvme_create_io_queues(dev);\r\nqueues = min(dev->online_queues - 1, num_online_cpus());\r\nif (!queues)\r\nreturn;\r\ncpus_per_queue = num_online_cpus() / queues;\r\nremainder = queues - (num_online_cpus() - queues * cpus_per_queue);\r\nif (!alloc_cpumask_var(&unassigned_cpus, GFP_KERNEL))\r\nreturn;\r\ncpumask_copy(unassigned_cpus, cpu_online_mask);\r\ncpu = cpumask_first(unassigned_cpus);\r\nfor (i = 1; i <= queues; i++) {\r\nstruct nvme_queue *nvmeq = lock_nvmeq(dev, i);\r\ncpumask_t mask;\r\ncpumask_clear(nvmeq->cpu_mask);\r\nif (!cpumask_weight(unassigned_cpus)) {\r\nunlock_nvmeq(nvmeq);\r\nbreak;\r\n}\r\nmask = *get_cpu_mask(cpu);\r\nnvme_set_queue_cpus(&mask, nvmeq, cpus_per_queue);\r\nif (cpus_weight(mask) < cpus_per_queue)\r\nnvme_add_cpus(&mask, unassigned_cpus,\r\ntopology_thread_cpumask(cpu),\r\nnvmeq, cpus_per_queue);\r\nif (cpus_weight(mask) < cpus_per_queue)\r\nnvme_add_cpus(&mask, unassigned_cpus,\r\ntopology_core_cpumask(cpu),\r\nnvmeq, cpus_per_queue);\r\nif (cpus_weight(mask) < cpus_per_queue)\r\nnvme_add_cpus(&mask, unassigned_cpus,\r\ncpumask_of_node(cpu_to_node(cpu)),\r\nnvmeq, cpus_per_queue);\r\nif (cpus_weight(mask) < cpus_per_queue)\r\nnvme_add_cpus(&mask, unassigned_cpus,\r\ncpumask_of_node(\r\nnvme_find_closest_node(\r\ncpu_to_node(cpu))),\r\nnvmeq, cpus_per_queue);\r\nif (cpus_weight(mask) < cpus_per_queue)\r\nnvme_add_cpus(&mask, unassigned_cpus,\r\nunassigned_cpus,\r\nnvmeq, cpus_per_queue);\r\nWARN(cpumask_weight(nvmeq->cpu_mask) != cpus_per_queue,\r\n"nvme%d qid:%d mis-matched queue-to-cpu assignment\n",\r\ndev->instance, i);\r\nirq_set_affinity_hint(dev->entry[nvmeq->cq_vector].vector,\r\nnvmeq->cpu_mask);\r\ncpumask_andnot(unassigned_cpus, unassigned_cpus,\r\nnvmeq->cpu_mask);\r\ncpu = cpumask_next(cpu, unassigned_cpus);\r\nif (remainder && !--remainder)\r\ncpus_per_queue++;\r\nunlock_nvmeq(nvmeq);\r\n}\r\nWARN(cpumask_weight(unassigned_cpus), "nvme%d unassigned online cpus\n",\r\ndev->instance);\r\ni = 0;\r\ncpumask_andnot(unassigned_cpus, cpu_possible_mask, cpu_online_mask);\r\nfor_each_cpu(cpu, unassigned_cpus)\r\n*per_cpu_ptr(dev->io_queue, cpu) = (i++ % queues) + 1;\r\nfree_cpumask_var(unassigned_cpus);\r\n}\r\nstatic int set_queue_count(struct nvme_dev *dev, int count)\r\n{\r\nint status;\r\nu32 result;\r\nu32 q_count = (count - 1) | ((count - 1) << 16);\r\nstatus = nvme_set_features(dev, NVME_FEAT_NUM_QUEUES, q_count, 0,\r\n&result);\r\nif (status < 0)\r\nreturn status;\r\nif (status > 0) {\r\ndev_err(&dev->pci_dev->dev, "Could not set queue count (%d)\n",\r\nstatus);\r\nreturn -EBUSY;\r\n}\r\nreturn min(result & 0xffff, result >> 16) + 1;\r\n}\r\nstatic size_t db_bar_size(struct nvme_dev *dev, unsigned nr_io_queues)\r\n{\r\nreturn 4096 + ((nr_io_queues + 1) * 8 * dev->db_stride);\r\n}\r\nstatic void nvme_cpu_workfn(struct work_struct *work)\r\n{\r\nstruct nvme_dev *dev = container_of(work, struct nvme_dev, cpu_work);\r\nif (dev->initialized)\r\nnvme_assign_io_queues(dev);\r\n}\r\nstatic int nvme_cpu_notify(struct notifier_block *self,\r\nunsigned long action, void *hcpu)\r\n{\r\nstruct nvme_dev *dev;\r\nswitch (action) {\r\ncase CPU_ONLINE:\r\ncase CPU_DEAD:\r\nspin_lock(&dev_list_lock);\r\nlist_for_each_entry(dev, &dev_list, node)\r\nschedule_work(&dev->cpu_work);\r\nspin_unlock(&dev_list_lock);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int nvme_setup_io_queues(struct nvme_dev *dev)\r\n{\r\nstruct nvme_queue *adminq = raw_nvmeq(dev, 0);\r\nstruct pci_dev *pdev = dev->pci_dev;\r\nint result, i, vecs, nr_io_queues, size;\r\nnr_io_queues = num_possible_cpus();\r\nresult = set_queue_count(dev, nr_io_queues);\r\nif (result < 0)\r\nreturn result;\r\nif (result < nr_io_queues)\r\nnr_io_queues = result;\r\nsize = db_bar_size(dev, nr_io_queues);\r\nif (size > 8192) {\r\niounmap(dev->bar);\r\ndo {\r\ndev->bar = ioremap(pci_resource_start(pdev, 0), size);\r\nif (dev->bar)\r\nbreak;\r\nif (!--nr_io_queues)\r\nreturn -ENOMEM;\r\nsize = db_bar_size(dev, nr_io_queues);\r\n} while (1);\r\ndev->dbs = ((void __iomem *)dev->bar) + 4096;\r\nadminq->q_db = dev->dbs;\r\n}\r\nfree_irq(dev->entry[0].vector, adminq);\r\nfor (i = 0; i < nr_io_queues; i++)\r\ndev->entry[i].entry = i;\r\nvecs = pci_enable_msix_range(pdev, dev->entry, 1, nr_io_queues);\r\nif (vecs < 0) {\r\nvecs = pci_enable_msi_range(pdev, 1, min(nr_io_queues, 32));\r\nif (vecs < 0) {\r\nvecs = 1;\r\n} else {\r\nfor (i = 0; i < vecs; i++)\r\ndev->entry[i].vector = i + pdev->irq;\r\n}\r\n}\r\nnr_io_queues = vecs;\r\ndev->max_qid = nr_io_queues;\r\nresult = queue_request_irq(dev, adminq, adminq->irqname);\r\nif (result) {\r\nadminq->q_suspended = 1;\r\ngoto free_queues;\r\n}\r\nnvme_free_queues(dev, nr_io_queues + 1);\r\nnvme_assign_io_queues(dev);\r\nreturn 0;\r\nfree_queues:\r\nnvme_free_queues(dev, 1);\r\nreturn result;\r\n}\r\nstatic int nvme_dev_add(struct nvme_dev *dev)\r\n{\r\nstruct pci_dev *pdev = dev->pci_dev;\r\nint res;\r\nunsigned nn, i;\r\nstruct nvme_ns *ns;\r\nstruct nvme_id_ctrl *ctrl;\r\nstruct nvme_id_ns *id_ns;\r\nvoid *mem;\r\ndma_addr_t dma_addr;\r\nint shift = NVME_CAP_MPSMIN(readq(&dev->bar->cap)) + 12;\r\nmem = dma_alloc_coherent(&pdev->dev, 8192, &dma_addr, GFP_KERNEL);\r\nif (!mem)\r\nreturn -ENOMEM;\r\nres = nvme_identify(dev, 0, 1, dma_addr);\r\nif (res) {\r\ndev_err(&pdev->dev, "Identify Controller failed (%d)\n", res);\r\nres = -EIO;\r\ngoto out;\r\n}\r\nctrl = mem;\r\nnn = le32_to_cpup(&ctrl->nn);\r\ndev->oncs = le16_to_cpup(&ctrl->oncs);\r\ndev->abort_limit = ctrl->acl + 1;\r\ndev->vwc = ctrl->vwc;\r\nmemcpy(dev->serial, ctrl->sn, sizeof(ctrl->sn));\r\nmemcpy(dev->model, ctrl->mn, sizeof(ctrl->mn));\r\nmemcpy(dev->firmware_rev, ctrl->fr, sizeof(ctrl->fr));\r\nif (ctrl->mdts)\r\ndev->max_hw_sectors = 1 << (ctrl->mdts + shift - 9);\r\nif ((pdev->vendor == PCI_VENDOR_ID_INTEL) &&\r\n(pdev->device == 0x0953) && ctrl->vs[3])\r\ndev->stripe_size = 1 << (ctrl->vs[3] + shift);\r\nid_ns = mem;\r\nfor (i = 1; i <= nn; i++) {\r\nres = nvme_identify(dev, i, 0, dma_addr);\r\nif (res)\r\ncontinue;\r\nif (id_ns->ncap == 0)\r\ncontinue;\r\nres = nvme_get_features(dev, NVME_FEAT_LBA_RANGE, i,\r\ndma_addr + 4096, NULL);\r\nif (res)\r\nmemset(mem + 4096, 0, 4096);\r\nns = nvme_alloc_ns(dev, i, mem, mem + 4096);\r\nif (ns)\r\nlist_add_tail(&ns->list, &dev->namespaces);\r\n}\r\nlist_for_each_entry(ns, &dev->namespaces, list)\r\nadd_disk(ns->disk);\r\nres = 0;\r\nout:\r\ndma_free_coherent(&dev->pci_dev->dev, 8192, mem, dma_addr);\r\nreturn res;\r\n}\r\nstatic int nvme_dev_map(struct nvme_dev *dev)\r\n{\r\nu64 cap;\r\nint bars, result = -ENOMEM;\r\nstruct pci_dev *pdev = dev->pci_dev;\r\nif (pci_enable_device_mem(pdev))\r\nreturn result;\r\ndev->entry[0].vector = pdev->irq;\r\npci_set_master(pdev);\r\nbars = pci_select_bars(pdev, IORESOURCE_MEM);\r\nif (pci_request_selected_regions(pdev, bars, "nvme"))\r\ngoto disable_pci;\r\nif (dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64)) &&\r\ndma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32)))\r\ngoto disable;\r\ndev->bar = ioremap(pci_resource_start(pdev, 0), 8192);\r\nif (!dev->bar)\r\ngoto disable;\r\nif (readl(&dev->bar->csts) == -1) {\r\nresult = -ENODEV;\r\ngoto unmap;\r\n}\r\ncap = readq(&dev->bar->cap);\r\ndev->q_depth = min_t(int, NVME_CAP_MQES(cap) + 1, NVME_Q_DEPTH);\r\ndev->db_stride = 1 << NVME_CAP_STRIDE(cap);\r\ndev->dbs = ((void __iomem *)dev->bar) + 4096;\r\nreturn 0;\r\nunmap:\r\niounmap(dev->bar);\r\ndev->bar = NULL;\r\ndisable:\r\npci_release_regions(pdev);\r\ndisable_pci:\r\npci_disable_device(pdev);\r\nreturn result;\r\n}\r\nstatic void nvme_dev_unmap(struct nvme_dev *dev)\r\n{\r\nif (dev->pci_dev->msi_enabled)\r\npci_disable_msi(dev->pci_dev);\r\nelse if (dev->pci_dev->msix_enabled)\r\npci_disable_msix(dev->pci_dev);\r\nif (dev->bar) {\r\niounmap(dev->bar);\r\ndev->bar = NULL;\r\npci_release_regions(dev->pci_dev);\r\n}\r\nif (pci_is_enabled(dev->pci_dev))\r\npci_disable_device(dev->pci_dev);\r\n}\r\nstatic void nvme_wait_dq(struct nvme_delq_ctx *dq, struct nvme_dev *dev)\r\n{\r\ndq->waiter = current;\r\nmb();\r\nfor (;;) {\r\nset_current_state(TASK_KILLABLE);\r\nif (!atomic_read(&dq->refcount))\r\nbreak;\r\nif (!schedule_timeout(ADMIN_TIMEOUT) ||\r\nfatal_signal_pending(current)) {\r\nset_current_state(TASK_RUNNING);\r\nnvme_disable_ctrl(dev, readq(&dev->bar->cap));\r\nnvme_disable_queue(dev, 0);\r\nsend_sig(SIGKILL, dq->worker->task, 1);\r\nflush_kthread_worker(dq->worker);\r\nreturn;\r\n}\r\n}\r\nset_current_state(TASK_RUNNING);\r\n}\r\nstatic void nvme_put_dq(struct nvme_delq_ctx *dq)\r\n{\r\natomic_dec(&dq->refcount);\r\nif (dq->waiter)\r\nwake_up_process(dq->waiter);\r\n}\r\nstatic struct nvme_delq_ctx *nvme_get_dq(struct nvme_delq_ctx *dq)\r\n{\r\natomic_inc(&dq->refcount);\r\nreturn dq;\r\n}\r\nstatic void nvme_del_queue_end(struct nvme_queue *nvmeq)\r\n{\r\nstruct nvme_delq_ctx *dq = nvmeq->cmdinfo.ctx;\r\nnvme_clear_queue(nvmeq);\r\nnvme_put_dq(dq);\r\n}\r\nstatic int adapter_async_del_queue(struct nvme_queue *nvmeq, u8 opcode,\r\nkthread_work_func_t fn)\r\n{\r\nstruct nvme_command c;\r\nmemset(&c, 0, sizeof(c));\r\nc.delete_queue.opcode = opcode;\r\nc.delete_queue.qid = cpu_to_le16(nvmeq->qid);\r\ninit_kthread_work(&nvmeq->cmdinfo.work, fn);\r\nreturn nvme_submit_admin_cmd_async(nvmeq->dev, &c, &nvmeq->cmdinfo);\r\n}\r\nstatic void nvme_del_cq_work_handler(struct kthread_work *work)\r\n{\r\nstruct nvme_queue *nvmeq = container_of(work, struct nvme_queue,\r\ncmdinfo.work);\r\nnvme_del_queue_end(nvmeq);\r\n}\r\nstatic int nvme_delete_cq(struct nvme_queue *nvmeq)\r\n{\r\nreturn adapter_async_del_queue(nvmeq, nvme_admin_delete_cq,\r\nnvme_del_cq_work_handler);\r\n}\r\nstatic void nvme_del_sq_work_handler(struct kthread_work *work)\r\n{\r\nstruct nvme_queue *nvmeq = container_of(work, struct nvme_queue,\r\ncmdinfo.work);\r\nint status = nvmeq->cmdinfo.status;\r\nif (!status)\r\nstatus = nvme_delete_cq(nvmeq);\r\nif (status)\r\nnvme_del_queue_end(nvmeq);\r\n}\r\nstatic int nvme_delete_sq(struct nvme_queue *nvmeq)\r\n{\r\nreturn adapter_async_del_queue(nvmeq, nvme_admin_delete_sq,\r\nnvme_del_sq_work_handler);\r\n}\r\nstatic void nvme_del_queue_start(struct kthread_work *work)\r\n{\r\nstruct nvme_queue *nvmeq = container_of(work, struct nvme_queue,\r\ncmdinfo.work);\r\nallow_signal(SIGKILL);\r\nif (nvme_delete_sq(nvmeq))\r\nnvme_del_queue_end(nvmeq);\r\n}\r\nstatic void nvme_disable_io_queues(struct nvme_dev *dev)\r\n{\r\nint i;\r\nDEFINE_KTHREAD_WORKER_ONSTACK(worker);\r\nstruct nvme_delq_ctx dq;\r\nstruct task_struct *kworker_task = kthread_run(kthread_worker_fn,\r\n&worker, "nvme%d", dev->instance);\r\nif (IS_ERR(kworker_task)) {\r\ndev_err(&dev->pci_dev->dev,\r\n"Failed to create queue del task\n");\r\nfor (i = dev->queue_count - 1; i > 0; i--)\r\nnvme_disable_queue(dev, i);\r\nreturn;\r\n}\r\ndq.waiter = NULL;\r\natomic_set(&dq.refcount, 0);\r\ndq.worker = &worker;\r\nfor (i = dev->queue_count - 1; i > 0; i--) {\r\nstruct nvme_queue *nvmeq = raw_nvmeq(dev, i);\r\nif (nvme_suspend_queue(nvmeq))\r\ncontinue;\r\nnvmeq->cmdinfo.ctx = nvme_get_dq(&dq);\r\nnvmeq->cmdinfo.worker = dq.worker;\r\ninit_kthread_work(&nvmeq->cmdinfo.work, nvme_del_queue_start);\r\nqueue_kthread_work(dq.worker, &nvmeq->cmdinfo.work);\r\n}\r\nnvme_wait_dq(&dq, dev);\r\nkthread_stop(kworker_task);\r\n}\r\nstatic void nvme_dev_list_remove(struct nvme_dev *dev)\r\n{\r\nstruct task_struct *tmp = NULL;\r\nspin_lock(&dev_list_lock);\r\nlist_del_init(&dev->node);\r\nif (list_empty(&dev_list) && !IS_ERR_OR_NULL(nvme_thread)) {\r\ntmp = nvme_thread;\r\nnvme_thread = NULL;\r\n}\r\nspin_unlock(&dev_list_lock);\r\nif (tmp)\r\nkthread_stop(tmp);\r\n}\r\nstatic void nvme_dev_shutdown(struct nvme_dev *dev)\r\n{\r\nint i;\r\ndev->initialized = 0;\r\nnvme_dev_list_remove(dev);\r\nif (!dev->bar || (dev->bar && readl(&dev->bar->csts) == -1)) {\r\nfor (i = dev->queue_count - 1; i >= 0; i--) {\r\nstruct nvme_queue *nvmeq = raw_nvmeq(dev, i);\r\nnvme_suspend_queue(nvmeq);\r\nnvme_clear_queue(nvmeq);\r\n}\r\n} else {\r\nnvme_disable_io_queues(dev);\r\nnvme_shutdown_ctrl(dev);\r\nnvme_disable_queue(dev, 0);\r\n}\r\nnvme_dev_unmap(dev);\r\n}\r\nstatic void nvme_dev_remove(struct nvme_dev *dev)\r\n{\r\nstruct nvme_ns *ns;\r\nlist_for_each_entry(ns, &dev->namespaces, list) {\r\nif (ns->disk->flags & GENHD_FL_UP)\r\ndel_gendisk(ns->disk);\r\nif (!blk_queue_dying(ns->queue))\r\nblk_cleanup_queue(ns->queue);\r\n}\r\n}\r\nstatic int nvme_setup_prp_pools(struct nvme_dev *dev)\r\n{\r\nstruct device *dmadev = &dev->pci_dev->dev;\r\ndev->prp_page_pool = dma_pool_create("prp list page", dmadev,\r\nPAGE_SIZE, PAGE_SIZE, 0);\r\nif (!dev->prp_page_pool)\r\nreturn -ENOMEM;\r\ndev->prp_small_pool = dma_pool_create("prp list 256", dmadev,\r\n256, 256, 0);\r\nif (!dev->prp_small_pool) {\r\ndma_pool_destroy(dev->prp_page_pool);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void nvme_release_prp_pools(struct nvme_dev *dev)\r\n{\r\ndma_pool_destroy(dev->prp_page_pool);\r\ndma_pool_destroy(dev->prp_small_pool);\r\n}\r\nstatic int nvme_set_instance(struct nvme_dev *dev)\r\n{\r\nint instance, error;\r\ndo {\r\nif (!ida_pre_get(&nvme_instance_ida, GFP_KERNEL))\r\nreturn -ENODEV;\r\nspin_lock(&dev_list_lock);\r\nerror = ida_get_new(&nvme_instance_ida, &instance);\r\nspin_unlock(&dev_list_lock);\r\n} while (error == -EAGAIN);\r\nif (error)\r\nreturn -ENODEV;\r\ndev->instance = instance;\r\nreturn 0;\r\n}\r\nstatic void nvme_release_instance(struct nvme_dev *dev)\r\n{\r\nspin_lock(&dev_list_lock);\r\nida_remove(&nvme_instance_ida, dev->instance);\r\nspin_unlock(&dev_list_lock);\r\n}\r\nstatic void nvme_free_namespaces(struct nvme_dev *dev)\r\n{\r\nstruct nvme_ns *ns, *next;\r\nlist_for_each_entry_safe(ns, next, &dev->namespaces, list) {\r\nlist_del(&ns->list);\r\nput_disk(ns->disk);\r\nkfree(ns);\r\n}\r\n}\r\nstatic void nvme_free_dev(struct kref *kref)\r\n{\r\nstruct nvme_dev *dev = container_of(kref, struct nvme_dev, kref);\r\nnvme_free_namespaces(dev);\r\nfree_percpu(dev->io_queue);\r\nkfree(dev->queues);\r\nkfree(dev->entry);\r\nkfree(dev);\r\n}\r\nstatic int nvme_dev_open(struct inode *inode, struct file *f)\r\n{\r\nstruct nvme_dev *dev = container_of(f->private_data, struct nvme_dev,\r\nmiscdev);\r\nkref_get(&dev->kref);\r\nf->private_data = dev;\r\nreturn 0;\r\n}\r\nstatic int nvme_dev_release(struct inode *inode, struct file *f)\r\n{\r\nstruct nvme_dev *dev = f->private_data;\r\nkref_put(&dev->kref, nvme_free_dev);\r\nreturn 0;\r\n}\r\nstatic long nvme_dev_ioctl(struct file *f, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct nvme_dev *dev = f->private_data;\r\nswitch (cmd) {\r\ncase NVME_IOCTL_ADMIN_CMD:\r\nreturn nvme_user_admin_cmd(dev, (void __user *)arg);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int nvme_dev_start(struct nvme_dev *dev)\r\n{\r\nint result;\r\nbool start_thread = false;\r\nresult = nvme_dev_map(dev);\r\nif (result)\r\nreturn result;\r\nresult = nvme_configure_admin_queue(dev);\r\nif (result)\r\ngoto unmap;\r\nspin_lock(&dev_list_lock);\r\nif (list_empty(&dev_list) && IS_ERR_OR_NULL(nvme_thread)) {\r\nstart_thread = true;\r\nnvme_thread = NULL;\r\n}\r\nlist_add(&dev->node, &dev_list);\r\nspin_unlock(&dev_list_lock);\r\nif (start_thread) {\r\nnvme_thread = kthread_run(nvme_kthread, NULL, "nvme");\r\nwake_up(&nvme_kthread_wait);\r\n} else\r\nwait_event_killable(nvme_kthread_wait, nvme_thread);\r\nif (IS_ERR_OR_NULL(nvme_thread)) {\r\nresult = nvme_thread ? PTR_ERR(nvme_thread) : -EINTR;\r\ngoto disable;\r\n}\r\nresult = nvme_setup_io_queues(dev);\r\nif (result && result != -EBUSY)\r\ngoto disable;\r\nreturn result;\r\ndisable:\r\nnvme_disable_queue(dev, 0);\r\nnvme_dev_list_remove(dev);\r\nunmap:\r\nnvme_dev_unmap(dev);\r\nreturn result;\r\n}\r\nstatic int nvme_remove_dead_ctrl(void *arg)\r\n{\r\nstruct nvme_dev *dev = (struct nvme_dev *)arg;\r\nstruct pci_dev *pdev = dev->pci_dev;\r\nif (pci_get_drvdata(pdev))\r\npci_stop_and_remove_bus_device(pdev);\r\nkref_put(&dev->kref, nvme_free_dev);\r\nreturn 0;\r\n}\r\nstatic void nvme_remove_disks(struct work_struct *ws)\r\n{\r\nstruct nvme_dev *dev = container_of(ws, struct nvme_dev, reset_work);\r\nnvme_dev_remove(dev);\r\nnvme_free_queues(dev, 1);\r\n}\r\nstatic int nvme_dev_resume(struct nvme_dev *dev)\r\n{\r\nint ret;\r\nret = nvme_dev_start(dev);\r\nif (ret && ret != -EBUSY)\r\nreturn ret;\r\nif (ret == -EBUSY) {\r\nspin_lock(&dev_list_lock);\r\ndev->reset_workfn = nvme_remove_disks;\r\nqueue_work(nvme_workq, &dev->reset_work);\r\nspin_unlock(&dev_list_lock);\r\n}\r\ndev->initialized = 1;\r\nreturn 0;\r\n}\r\nstatic void nvme_dev_reset(struct nvme_dev *dev)\r\n{\r\nnvme_dev_shutdown(dev);\r\nif (nvme_dev_resume(dev)) {\r\ndev_err(&dev->pci_dev->dev, "Device failed to resume\n");\r\nkref_get(&dev->kref);\r\nif (IS_ERR(kthread_run(nvme_remove_dead_ctrl, dev, "nvme%d",\r\ndev->instance))) {\r\ndev_err(&dev->pci_dev->dev,\r\n"Failed to start controller remove task\n");\r\nkref_put(&dev->kref, nvme_free_dev);\r\n}\r\n}\r\n}\r\nstatic void nvme_reset_failed_dev(struct work_struct *ws)\r\n{\r\nstruct nvme_dev *dev = container_of(ws, struct nvme_dev, reset_work);\r\nnvme_dev_reset(dev);\r\n}\r\nstatic void nvme_reset_workfn(struct work_struct *work)\r\n{\r\nstruct nvme_dev *dev = container_of(work, struct nvme_dev, reset_work);\r\ndev->reset_workfn(work);\r\n}\r\nstatic int nvme_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nint result = -ENOMEM;\r\nstruct nvme_dev *dev;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->entry = kcalloc(num_possible_cpus(), sizeof(*dev->entry),\r\nGFP_KERNEL);\r\nif (!dev->entry)\r\ngoto free;\r\ndev->queues = kcalloc(num_possible_cpus() + 1, sizeof(void *),\r\nGFP_KERNEL);\r\nif (!dev->queues)\r\ngoto free;\r\ndev->io_queue = alloc_percpu(unsigned short);\r\nif (!dev->io_queue)\r\ngoto free;\r\nINIT_LIST_HEAD(&dev->namespaces);\r\ndev->reset_workfn = nvme_reset_failed_dev;\r\nINIT_WORK(&dev->reset_work, nvme_reset_workfn);\r\nINIT_WORK(&dev->cpu_work, nvme_cpu_workfn);\r\ndev->pci_dev = pdev;\r\npci_set_drvdata(pdev, dev);\r\nresult = nvme_set_instance(dev);\r\nif (result)\r\ngoto free;\r\nresult = nvme_setup_prp_pools(dev);\r\nif (result)\r\ngoto release;\r\nkref_init(&dev->kref);\r\nresult = nvme_dev_start(dev);\r\nif (result) {\r\nif (result == -EBUSY)\r\ngoto create_cdev;\r\ngoto release_pools;\r\n}\r\nresult = nvme_dev_add(dev);\r\nif (result)\r\ngoto shutdown;\r\ncreate_cdev:\r\nscnprintf(dev->name, sizeof(dev->name), "nvme%d", dev->instance);\r\ndev->miscdev.minor = MISC_DYNAMIC_MINOR;\r\ndev->miscdev.parent = &pdev->dev;\r\ndev->miscdev.name = dev->name;\r\ndev->miscdev.fops = &nvme_dev_fops;\r\nresult = misc_register(&dev->miscdev);\r\nif (result)\r\ngoto remove;\r\ndev->initialized = 1;\r\nreturn 0;\r\nremove:\r\nnvme_dev_remove(dev);\r\nnvme_free_namespaces(dev);\r\nshutdown:\r\nnvme_dev_shutdown(dev);\r\nrelease_pools:\r\nnvme_free_queues(dev, 0);\r\nnvme_release_prp_pools(dev);\r\nrelease:\r\nnvme_release_instance(dev);\r\nfree:\r\nfree_percpu(dev->io_queue);\r\nkfree(dev->queues);\r\nkfree(dev->entry);\r\nkfree(dev);\r\nreturn result;\r\n}\r\nstatic void nvme_reset_notify(struct pci_dev *pdev, bool prepare)\r\n{\r\nstruct nvme_dev *dev = pci_get_drvdata(pdev);\r\nif (prepare)\r\nnvme_dev_shutdown(dev);\r\nelse\r\nnvme_dev_resume(dev);\r\n}\r\nstatic void nvme_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct nvme_dev *dev = pci_get_drvdata(pdev);\r\nnvme_dev_shutdown(dev);\r\n}\r\nstatic void nvme_remove(struct pci_dev *pdev)\r\n{\r\nstruct nvme_dev *dev = pci_get_drvdata(pdev);\r\nspin_lock(&dev_list_lock);\r\nlist_del_init(&dev->node);\r\nspin_unlock(&dev_list_lock);\r\npci_set_drvdata(pdev, NULL);\r\nflush_work(&dev->reset_work);\r\nflush_work(&dev->cpu_work);\r\nmisc_deregister(&dev->miscdev);\r\nnvme_dev_remove(dev);\r\nnvme_dev_shutdown(dev);\r\nnvme_free_queues(dev, 0);\r\nrcu_barrier();\r\nnvme_release_instance(dev);\r\nnvme_release_prp_pools(dev);\r\nkref_put(&dev->kref, nvme_free_dev);\r\n}\r\nstatic int nvme_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct nvme_dev *ndev = pci_get_drvdata(pdev);\r\nnvme_dev_shutdown(ndev);\r\nreturn 0;\r\n}\r\nstatic int nvme_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct nvme_dev *ndev = pci_get_drvdata(pdev);\r\nif (nvme_dev_resume(ndev) && !work_busy(&ndev->reset_work)) {\r\nndev->reset_workfn = nvme_reset_failed_dev;\r\nqueue_work(nvme_workq, &ndev->reset_work);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init nvme_init(void)\r\n{\r\nint result;\r\ninit_waitqueue_head(&nvme_kthread_wait);\r\nnvme_workq = create_singlethread_workqueue("nvme");\r\nif (!nvme_workq)\r\nreturn -ENOMEM;\r\nresult = register_blkdev(nvme_major, "nvme");\r\nif (result < 0)\r\ngoto kill_workq;\r\nelse if (result > 0)\r\nnvme_major = result;\r\nnvme_nb.notifier_call = &nvme_cpu_notify;\r\nresult = register_hotcpu_notifier(&nvme_nb);\r\nif (result)\r\ngoto unregister_blkdev;\r\nresult = pci_register_driver(&nvme_driver);\r\nif (result)\r\ngoto unregister_hotcpu;\r\nreturn 0;\r\nunregister_hotcpu:\r\nunregister_hotcpu_notifier(&nvme_nb);\r\nunregister_blkdev:\r\nunregister_blkdev(nvme_major, "nvme");\r\nkill_workq:\r\ndestroy_workqueue(nvme_workq);\r\nreturn result;\r\n}\r\nstatic void __exit nvme_exit(void)\r\n{\r\npci_unregister_driver(&nvme_driver);\r\nunregister_hotcpu_notifier(&nvme_nb);\r\nunregister_blkdev(nvme_major, "nvme");\r\ndestroy_workqueue(nvme_workq);\r\nBUG_ON(nvme_thread && !IS_ERR(nvme_thread));\r\n_nvme_check_size();\r\n}
