static int oem_cable(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nif (pdev->subsystem_device & (1 << (ap->port_no + 14)))\r\nreturn ATA_CBL_PATA80;\r\nreturn ATA_CBL_PATA40;\r\n}\r\nstatic int serverworks_cable_detect(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nstruct sv_cable_table *cb = cable_detect;\r\nwhile(cb->device) {\r\nif (cb->device == pdev->device &&\r\n(cb->subvendor == pdev->subsystem_vendor ||\r\ncb->subvendor == PCI_ANY_ID)) {\r\nreturn cb->cable_detect(ap);\r\n}\r\ncb++;\r\n}\r\nBUG();\r\nreturn -1;\r\n}\r\nstatic u8 serverworks_is_csb(struct pci_dev *pdev)\r\n{\r\nswitch (pdev->device) {\r\ncase PCI_DEVICE_ID_SERVERWORKS_CSB5IDE:\r\ncase PCI_DEVICE_ID_SERVERWORKS_CSB6IDE:\r\ncase PCI_DEVICE_ID_SERVERWORKS_CSB6IDE2:\r\ncase PCI_DEVICE_ID_SERVERWORKS_HT1000IDE:\r\nreturn 1;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned long serverworks_osb4_filter(struct ata_device *adev, unsigned long mask)\r\n{\r\nif (adev->class == ATA_DEV_ATA)\r\nmask &= ~ATA_MASK_UDMA;\r\nreturn mask;\r\n}\r\nstatic unsigned long serverworks_csb_filter(struct ata_device *adev, unsigned long mask)\r\n{\r\nconst char *p;\r\nchar model_num[ATA_ID_PROD_LEN + 1];\r\nint i;\r\nif (adev->class != ATA_DEV_ATA)\r\nreturn mask;\r\nata_id_c_string(adev->id, model_num, ATA_ID_PROD, sizeof(model_num));\r\nfor (i = 0; (p = csb_bad_ata100[i]) != NULL; i++) {\r\nif (!strcmp(p, model_num))\r\nmask &= ~(0xE0 << ATA_SHIFT_UDMA);\r\n}\r\nreturn mask;\r\n}\r\nstatic void serverworks_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstatic const u8 pio_mode[] = { 0x5d, 0x47, 0x34, 0x22, 0x20 };\r\nint offset = 1 + 2 * ap->port_no - adev->devno;\r\nint devbits = (2 * ap->port_no + adev->devno) * 4;\r\nu16 csb5_pio;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nint pio = adev->pio_mode - XFER_PIO_0;\r\npci_write_config_byte(pdev, 0x40 + offset, pio_mode[pio]);\r\nif (serverworks_is_csb(pdev)) {\r\npci_read_config_word(pdev, 0x4A, &csb5_pio);\r\ncsb5_pio &= ~(0x0F << devbits);\r\npci_write_config_word(pdev, 0x4A, csb5_pio | (pio << devbits));\r\n}\r\n}\r\nstatic void serverworks_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstatic const u8 dma_mode[] = { 0x77, 0x21, 0x20 };\r\nint offset = 1 + 2 * ap->port_no - adev->devno;\r\nint devbits = 2 * ap->port_no + adev->devno;\r\nu8 ultra;\r\nu8 ultra_cfg;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\npci_read_config_byte(pdev, 0x54, &ultra_cfg);\r\npci_read_config_byte(pdev, 0x56 + ap->port_no, &ultra);\r\nultra &= ~(0x0F << (adev->devno * 4));\r\nif (adev->dma_mode >= XFER_UDMA_0) {\r\npci_write_config_byte(pdev, 0x44 + offset, 0x20);\r\nultra |= (adev->dma_mode - XFER_UDMA_0)\r\n<< (adev->devno * 4);\r\nultra_cfg |= (1 << devbits);\r\n} else {\r\npci_write_config_byte(pdev, 0x44 + offset,\r\ndma_mode[adev->dma_mode - XFER_MW_DMA_0]);\r\nultra_cfg &= ~(1 << devbits);\r\n}\r\npci_write_config_byte(pdev, 0x56 + ap->port_no, ultra);\r\npci_write_config_byte(pdev, 0x54, ultra_cfg);\r\n}\r\nstatic int serverworks_fixup_osb4(struct pci_dev *pdev)\r\n{\r\nu32 reg;\r\nstruct pci_dev *isa_dev = pci_get_device(PCI_VENDOR_ID_SERVERWORKS,\r\nPCI_DEVICE_ID_SERVERWORKS_OSB4, NULL);\r\nif (isa_dev) {\r\npci_read_config_dword(isa_dev, 0x64, &reg);\r\nreg &= ~0x00002000;\r\nif (!(reg & 0x00004000))\r\nprintk(KERN_DEBUG DRV_NAME ": UDMA not BIOS enabled.\n");\r\nreg |= 0x00004000;\r\npci_write_config_dword(isa_dev, 0x64, reg);\r\npci_dev_put(isa_dev);\r\nreturn 0;\r\n}\r\nprintk(KERN_WARNING DRV_NAME ": Unable to find bridge.\n");\r\nreturn -ENODEV;\r\n}\r\nstatic int serverworks_fixup_csb(struct pci_dev *pdev)\r\n{\r\nu8 btr;\r\nif (!(PCI_FUNC(pdev->devfn) & 1)) {\r\nstruct pci_dev * findev = NULL;\r\nu32 reg4c = 0;\r\nfindev = pci_get_device(PCI_VENDOR_ID_SERVERWORKS,\r\nPCI_DEVICE_ID_SERVERWORKS_CSB5, NULL);\r\nif (findev) {\r\npci_read_config_dword(findev, 0x4C, &reg4c);\r\nreg4c &= ~0x000007FF;\r\nreg4c |= 0x00000040;\r\nreg4c |= 0x00000020;\r\npci_write_config_dword(findev, 0x4C, reg4c);\r\npci_dev_put(findev);\r\n}\r\n} else {\r\nstruct pci_dev * findev = NULL;\r\nu8 reg41 = 0;\r\nfindev = pci_get_device(PCI_VENDOR_ID_SERVERWORKS,\r\nPCI_DEVICE_ID_SERVERWORKS_CSB6, NULL);\r\nif (findev) {\r\npci_read_config_byte(findev, 0x41, &reg41);\r\nreg41 &= ~0x40;\r\npci_write_config_byte(findev, 0x41, reg41);\r\npci_dev_put(findev);\r\n}\r\n}\r\npci_read_config_byte(pdev, 0x5A, &btr);\r\nbtr &= ~0x40;\r\nif (!(PCI_FUNC(pdev->devfn) & 1))\r\nbtr |= 0x2;\r\nelse\r\nbtr |= (pdev->revision >= SVWKS_CSB5_REVISION_NEW) ? 0x3 : 0x2;\r\npci_write_config_byte(pdev, 0x5A, btr);\r\nreturn btr;\r\n}\r\nstatic void serverworks_fixup_ht1000(struct pci_dev *pdev)\r\n{\r\nu8 btr;\r\npci_read_config_byte(pdev, 0x5A, &btr);\r\nbtr &= ~0x40;\r\nbtr |= 0x3;\r\npci_write_config_byte(pdev, 0x5A, btr);\r\n}\r\nstatic int serverworks_fixup(struct pci_dev *pdev)\r\n{\r\nint rc = 0;\r\npci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x40);\r\nswitch (pdev->device) {\r\ncase PCI_DEVICE_ID_SERVERWORKS_OSB4IDE:\r\nrc = serverworks_fixup_osb4(pdev);\r\nbreak;\r\ncase PCI_DEVICE_ID_SERVERWORKS_CSB5IDE:\r\nata_pci_bmdma_clear_simplex(pdev);\r\ncase PCI_DEVICE_ID_SERVERWORKS_CSB6IDE:\r\ncase PCI_DEVICE_ID_SERVERWORKS_CSB6IDE2:\r\nrc = serverworks_fixup_csb(pdev);\r\nbreak;\r\ncase PCI_DEVICE_ID_SERVERWORKS_HT1000IDE:\r\nserverworks_fixup_ht1000(pdev);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int serverworks_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstatic const struct ata_port_info info[4] = {\r\n{\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA2,\r\n.port_ops = &serverworks_osb4_port_ops\r\n}, {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.port_ops = &serverworks_osb4_port_ops\r\n}, {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA4,\r\n.port_ops = &serverworks_csb_port_ops\r\n}, {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA5,\r\n.port_ops = &serverworks_csb_port_ops\r\n}\r\n};\r\nconst struct ata_port_info *ppi[] = { &info[id->driver_data], NULL };\r\nint rc;\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nrc = serverworks_fixup(pdev);\r\nif (pdev->device == PCI_DEVICE_ID_SERVERWORKS_OSB4IDE) {\r\nif (rc < 0)\r\nppi[0] = &info[1];\r\n}\r\nelse if ((pdev->device == PCI_DEVICE_ID_SERVERWORKS_CSB5IDE) ||\r\n(pdev->device == PCI_DEVICE_ID_SERVERWORKS_CSB6IDE) ||\r\n(pdev->device == PCI_DEVICE_ID_SERVERWORKS_CSB6IDE2)) {\r\nif (rc == 3)\r\nppi[0] = &info[3];\r\nif (pdev->device == PCI_DEVICE_ID_SERVERWORKS_CSB6IDE2)\r\nppi[1] = &ata_dummy_port_info;\r\n}\r\nreturn ata_pci_bmdma_init_one(pdev, ppi, &serverworks_sht, NULL, 0);\r\n}\r\nstatic int serverworks_reinit_one(struct pci_dev *pdev)\r\n{\r\nstruct ata_host *host = pci_get_drvdata(pdev);\r\nint rc;\r\nrc = ata_pci_device_do_resume(pdev);\r\nif (rc)\r\nreturn rc;\r\n(void)serverworks_fixup(pdev);\r\nata_host_resume(host);\r\nreturn 0;\r\n}
