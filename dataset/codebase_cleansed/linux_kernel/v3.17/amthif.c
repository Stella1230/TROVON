void mei_amthif_reset_params(struct mei_device *dev)\r\n{\r\ndev->iamthif_current_cb = NULL;\r\ndev->iamthif_msg_buf_size = 0;\r\ndev->iamthif_msg_buf_index = 0;\r\ndev->iamthif_canceled = false;\r\ndev->iamthif_ioctl = false;\r\ndev->iamthif_state = MEI_IAMTHIF_IDLE;\r\ndev->iamthif_timer = 0;\r\ndev->iamthif_stall_timer = 0;\r\ndev->iamthif_open_count = 0;\r\n}\r\nint mei_amthif_host_init(struct mei_device *dev)\r\n{\r\nstruct mei_cl *cl = &dev->iamthif_cl;\r\nunsigned char *msg_buf;\r\nint ret, i;\r\ndev->iamthif_state = MEI_IAMTHIF_IDLE;\r\nmei_cl_init(cl, dev);\r\ni = mei_me_cl_by_uuid(dev, &mei_amthif_guid);\r\nif (i < 0) {\r\ndev_info(&dev->pdev->dev,\r\n"amthif: failed to find the client %d\n", i);\r\nreturn -ENOTTY;\r\n}\r\ncl->me_client_id = dev->me_clients[i].client_id;\r\ndev->iamthif_mtu = dev->me_clients[i].props.max_msg_length;\r\ndev_dbg(&dev->pdev->dev, "IAMTHIF_MTU = %d\n",\r\ndev->me_clients[i].props.max_msg_length);\r\nkfree(dev->iamthif_msg_buf);\r\ndev->iamthif_msg_buf = NULL;\r\nmsg_buf = kcalloc(dev->iamthif_mtu,\r\nsizeof(unsigned char), GFP_KERNEL);\r\nif (!msg_buf) {\r\ndev_err(&dev->pdev->dev, "amthif: memory allocation for ME message buffer failed.\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->iamthif_msg_buf = msg_buf;\r\nret = mei_cl_link(cl, MEI_IAMTHIF_HOST_CLIENT_ID);\r\nif (ret < 0) {\r\ndev_err(&dev->pdev->dev,\r\n"amthif: failed link client %d\n", ret);\r\nreturn ret;\r\n}\r\nret = mei_cl_connect(cl, NULL);\r\ndev->iamthif_state = MEI_IAMTHIF_IDLE;\r\nreturn ret;\r\n}\r\nstruct mei_cl_cb *mei_amthif_find_read_list_entry(struct mei_device *dev,\r\nstruct file *file)\r\n{\r\nstruct mei_cl_cb *cb;\r\nlist_for_each_entry(cb, &dev->amthif_rd_complete_list.list, list) {\r\nif (cb->cl && cb->cl == &dev->iamthif_cl &&\r\ncb->file_object == file)\r\nreturn cb;\r\n}\r\nreturn NULL;\r\n}\r\nint mei_amthif_read(struct mei_device *dev, struct file *file,\r\nchar __user *ubuf, size_t length, loff_t *offset)\r\n{\r\nint rets;\r\nint wait_ret;\r\nstruct mei_cl_cb *cb = NULL;\r\nstruct mei_cl *cl = file->private_data;\r\nunsigned long timeout;\r\nint i;\r\nif (!cl || cl != &dev->iamthif_cl) {\r\ndev_dbg(&dev->pdev->dev, "bad file ext.\n");\r\nreturn -ETIME;\r\n}\r\ni = mei_me_cl_by_id(dev, dev->iamthif_cl.me_client_id);\r\nif (i < 0) {\r\ndev_dbg(&dev->pdev->dev, "amthif client not found.\n");\r\nreturn -ENOTTY;\r\n}\r\ndev_dbg(&dev->pdev->dev, "checking amthif data\n");\r\ncb = mei_amthif_find_read_list_entry(dev, file);\r\nif (cb == NULL && file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\ndev_dbg(&dev->pdev->dev, "waiting for amthif data\n");\r\nwhile (cb == NULL) {\r\nmutex_unlock(&dev->device_lock);\r\nwait_ret = wait_event_interruptible(dev->iamthif_cl.wait,\r\n(cb = mei_amthif_find_read_list_entry(dev, file)));\r\nmutex_lock(&dev->device_lock);\r\nif (wait_ret)\r\nreturn -ERESTARTSYS;\r\ndev_dbg(&dev->pdev->dev, "woke up from sleep\n");\r\n}\r\ndev_dbg(&dev->pdev->dev, "Got amthif data\n");\r\ndev->iamthif_timer = 0;\r\nif (cb) {\r\ntimeout = cb->read_time +\r\nmei_secs_to_jiffies(MEI_IAMTHIF_READ_TIMER);\r\ndev_dbg(&dev->pdev->dev, "amthif timeout = %lud\n",\r\ntimeout);\r\nif (time_after(jiffies, timeout)) {\r\ndev_dbg(&dev->pdev->dev, "amthif Time out\n");\r\nlist_del(&cb->list);\r\nrets = -ETIME;\r\ngoto free;\r\n}\r\n}\r\nif (cb->buf_idx >= *offset && length >= (cb->buf_idx - *offset))\r\nlist_del(&cb->list);\r\nelse if (cb->buf_idx > 0 && cb->buf_idx <= *offset) {\r\nlist_del(&cb->list);\r\nrets = 0;\r\ngoto free;\r\n}\r\ndev_dbg(&dev->pdev->dev, "amthif cb->response_buffer size - %d\n",\r\ncb->response_buffer.size);\r\ndev_dbg(&dev->pdev->dev, "amthif cb->buf_idx - %lu\n", cb->buf_idx);\r\nlength = min_t(size_t, length, (cb->buf_idx - *offset));\r\nif (copy_to_user(ubuf, cb->response_buffer.data + *offset, length)) {\r\ndev_dbg(&dev->pdev->dev, "failed to copy data to userland\n");\r\nrets = -EFAULT;\r\n} else {\r\nrets = length;\r\nif ((*offset + length) < cb->buf_idx) {\r\n*offset += length;\r\ngoto out;\r\n}\r\n}\r\nfree:\r\ndev_dbg(&dev->pdev->dev, "free amthif cb memory.\n");\r\n*offset = 0;\r\nmei_io_cb_free(cb);\r\nout:\r\nreturn rets;\r\n}\r\nstatic int mei_amthif_send_cmd(struct mei_device *dev, struct mei_cl_cb *cb)\r\n{\r\nstruct mei_msg_hdr mei_hdr;\r\nint ret;\r\nif (!dev || !cb)\r\nreturn -ENODEV;\r\ndev_dbg(&dev->pdev->dev, "write data to amthif client.\n");\r\ndev->iamthif_state = MEI_IAMTHIF_WRITING;\r\ndev->iamthif_current_cb = cb;\r\ndev->iamthif_file_object = cb->file_object;\r\ndev->iamthif_canceled = false;\r\ndev->iamthif_ioctl = true;\r\ndev->iamthif_msg_buf_size = cb->request_buffer.size;\r\nmemcpy(dev->iamthif_msg_buf, cb->request_buffer.data,\r\ncb->request_buffer.size);\r\nret = mei_cl_flow_ctrl_creds(&dev->iamthif_cl);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret && mei_hbuf_acquire(dev)) {\r\nret = 0;\r\nif (cb->request_buffer.size > mei_hbuf_max_len(dev)) {\r\nmei_hdr.length = mei_hbuf_max_len(dev);\r\nmei_hdr.msg_complete = 0;\r\n} else {\r\nmei_hdr.length = cb->request_buffer.size;\r\nmei_hdr.msg_complete = 1;\r\n}\r\nmei_hdr.host_addr = dev->iamthif_cl.host_client_id;\r\nmei_hdr.me_addr = dev->iamthif_cl.me_client_id;\r\nmei_hdr.reserved = 0;\r\nmei_hdr.internal = 0;\r\ndev->iamthif_msg_buf_index += mei_hdr.length;\r\nret = mei_write_message(dev, &mei_hdr, dev->iamthif_msg_buf);\r\nif (ret)\r\nreturn ret;\r\nif (mei_hdr.msg_complete) {\r\nif (mei_cl_flow_ctrl_reduce(&dev->iamthif_cl))\r\nreturn -EIO;\r\ndev->iamthif_flow_control_pending = true;\r\ndev->iamthif_state = MEI_IAMTHIF_FLOW_CONTROL;\r\ndev_dbg(&dev->pdev->dev, "add amthif cb to write waiting list\n");\r\ndev->iamthif_current_cb = cb;\r\ndev->iamthif_file_object = cb->file_object;\r\nlist_add_tail(&cb->list, &dev->write_waiting_list.list);\r\n} else {\r\ndev_dbg(&dev->pdev->dev, "message does not complete, so add amthif cb to write list.\n");\r\nlist_add_tail(&cb->list, &dev->write_list.list);\r\n}\r\n} else {\r\nlist_add_tail(&cb->list, &dev->write_list.list);\r\n}\r\nreturn 0;\r\n}\r\nint mei_amthif_write(struct mei_device *dev, struct mei_cl_cb *cb)\r\n{\r\nint ret;\r\nif (!dev || !cb)\r\nreturn -ENODEV;\r\nret = mei_io_cb_alloc_resp_buf(cb, dev->iamthif_mtu);\r\nif (ret)\r\nreturn ret;\r\ncb->fop_type = MEI_FOP_WRITE;\r\nif (!list_empty(&dev->amthif_cmd_list.list) ||\r\ndev->iamthif_state != MEI_IAMTHIF_IDLE) {\r\ndev_dbg(&dev->pdev->dev,\r\n"amthif state = %d\n", dev->iamthif_state);\r\ndev_dbg(&dev->pdev->dev, "AMTHIF: add cb to the wait list\n");\r\nlist_add_tail(&cb->list, &dev->amthif_cmd_list.list);\r\nreturn 0;\r\n}\r\nreturn mei_amthif_send_cmd(dev, cb);\r\n}\r\nvoid mei_amthif_run_next_cmd(struct mei_device *dev)\r\n{\r\nstruct mei_cl_cb *pos = NULL;\r\nstruct mei_cl_cb *next = NULL;\r\nint status;\r\nif (!dev)\r\nreturn;\r\ndev->iamthif_msg_buf_size = 0;\r\ndev->iamthif_msg_buf_index = 0;\r\ndev->iamthif_canceled = false;\r\ndev->iamthif_ioctl = true;\r\ndev->iamthif_state = MEI_IAMTHIF_IDLE;\r\ndev->iamthif_timer = 0;\r\ndev->iamthif_file_object = NULL;\r\ndev_dbg(&dev->pdev->dev, "complete amthif cmd_list cb.\n");\r\nlist_for_each_entry_safe(pos, next, &dev->amthif_cmd_list.list, list) {\r\nlist_del(&pos->list);\r\nif (pos->cl && pos->cl == &dev->iamthif_cl) {\r\nstatus = mei_amthif_send_cmd(dev, pos);\r\nif (status) {\r\ndev_dbg(&dev->pdev->dev,\r\n"amthif write failed status = %d\n",\r\nstatus);\r\nreturn;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nunsigned int mei_amthif_poll(struct mei_device *dev,\r\nstruct file *file, poll_table *wait)\r\n{\r\nunsigned int mask = 0;\r\npoll_wait(file, &dev->iamthif_cl.wait, wait);\r\nmutex_lock(&dev->device_lock);\r\nif (!mei_cl_is_connected(&dev->iamthif_cl)) {\r\nmask = POLLERR;\r\n} else if (dev->iamthif_state == MEI_IAMTHIF_READ_COMPLETE &&\r\ndev->iamthif_file_object == file) {\r\nmask |= (POLLIN | POLLRDNORM);\r\ndev_dbg(&dev->pdev->dev, "run next amthif cb\n");\r\nmei_amthif_run_next_cmd(dev);\r\n}\r\nmutex_unlock(&dev->device_lock);\r\nreturn mask;\r\n}\r\nint mei_amthif_irq_write(struct mei_cl *cl, struct mei_cl_cb *cb,\r\nstruct mei_cl_cb *cmpl_list)\r\n{\r\nstruct mei_device *dev = cl->dev;\r\nstruct mei_msg_hdr mei_hdr;\r\nsize_t len = dev->iamthif_msg_buf_size - dev->iamthif_msg_buf_index;\r\nu32 msg_slots = mei_data2slots(len);\r\nint slots;\r\nint rets;\r\nrets = mei_cl_flow_ctrl_creds(cl);\r\nif (rets < 0)\r\nreturn rets;\r\nif (rets == 0) {\r\ncl_dbg(dev, cl, "No flow control credentials: not sending.\n");\r\nreturn 0;\r\n}\r\nmei_hdr.host_addr = cl->host_client_id;\r\nmei_hdr.me_addr = cl->me_client_id;\r\nmei_hdr.reserved = 0;\r\nmei_hdr.internal = 0;\r\nslots = mei_hbuf_empty_slots(dev);\r\nif (slots >= msg_slots) {\r\nmei_hdr.length = len;\r\nmei_hdr.msg_complete = 1;\r\n} else if (slots == dev->hbuf_depth) {\r\nmsg_slots = slots;\r\nlen = (slots * sizeof(u32)) - sizeof(struct mei_msg_hdr);\r\nmei_hdr.length = len;\r\nmei_hdr.msg_complete = 0;\r\n} else {\r\nreturn 0;\r\n}\r\ndev_dbg(&dev->pdev->dev, MEI_HDR_FMT, MEI_HDR_PRM(&mei_hdr));\r\nrets = mei_write_message(dev, &mei_hdr,\r\ndev->iamthif_msg_buf + dev->iamthif_msg_buf_index);\r\nif (rets) {\r\ndev->iamthif_state = MEI_IAMTHIF_IDLE;\r\ncl->status = rets;\r\nlist_del(&cb->list);\r\nreturn rets;\r\n}\r\nif (mei_cl_flow_ctrl_reduce(cl))\r\nreturn -EIO;\r\ndev->iamthif_msg_buf_index += mei_hdr.length;\r\ncl->status = 0;\r\nif (mei_hdr.msg_complete) {\r\ndev->iamthif_state = MEI_IAMTHIF_FLOW_CONTROL;\r\ndev->iamthif_flow_control_pending = true;\r\ncb->buf_idx = dev->iamthif_msg_buf_index;\r\ndev->iamthif_current_cb = cb;\r\nlist_move_tail(&cb->list, &dev->write_waiting_list.list);\r\n}\r\nreturn 0;\r\n}\r\nint mei_amthif_irq_read_msg(struct mei_device *dev,\r\nstruct mei_msg_hdr *mei_hdr,\r\nstruct mei_cl_cb *complete_list)\r\n{\r\nstruct mei_cl_cb *cb;\r\nunsigned char *buffer;\r\nBUG_ON(mei_hdr->me_addr != dev->iamthif_cl.me_client_id);\r\nBUG_ON(dev->iamthif_state != MEI_IAMTHIF_READING);\r\nbuffer = dev->iamthif_msg_buf + dev->iamthif_msg_buf_index;\r\nBUG_ON(dev->iamthif_mtu < dev->iamthif_msg_buf_index + mei_hdr->length);\r\nmei_read_slots(dev, buffer, mei_hdr->length);\r\ndev->iamthif_msg_buf_index += mei_hdr->length;\r\nif (!mei_hdr->msg_complete)\r\nreturn 0;\r\ndev_dbg(&dev->pdev->dev, "amthif_message_buffer_index =%d\n",\r\nmei_hdr->length);\r\ndev_dbg(&dev->pdev->dev, "completed amthif read.\n ");\r\nif (!dev->iamthif_current_cb)\r\nreturn -ENODEV;\r\ncb = dev->iamthif_current_cb;\r\ndev->iamthif_current_cb = NULL;\r\nif (!cb->cl)\r\nreturn -ENODEV;\r\ndev->iamthif_stall_timer = 0;\r\ncb->buf_idx = dev->iamthif_msg_buf_index;\r\ncb->read_time = jiffies;\r\nif (dev->iamthif_ioctl && cb->cl == &dev->iamthif_cl) {\r\ndev_dbg(&dev->pdev->dev, "complete the amthif read cb.\n ");\r\ndev_dbg(&dev->pdev->dev, "add the amthif read cb to complete.\n ");\r\nlist_add_tail(&cb->list, &complete_list->list);\r\n}\r\nreturn 0;\r\n}\r\nint mei_amthif_irq_read(struct mei_device *dev, s32 *slots)\r\n{\r\nu32 msg_slots = mei_data2slots(sizeof(struct hbm_flow_control));\r\nif (*slots < msg_slots)\r\nreturn -EMSGSIZE;\r\n*slots -= msg_slots;\r\nif (mei_hbm_cl_flow_control_req(dev, &dev->iamthif_cl)) {\r\ndev_dbg(&dev->pdev->dev, "iamthif flow control failed\n");\r\nreturn -EIO;\r\n}\r\ndev_dbg(&dev->pdev->dev, "iamthif flow control success\n");\r\ndev->iamthif_state = MEI_IAMTHIF_READING;\r\ndev->iamthif_flow_control_pending = false;\r\ndev->iamthif_msg_buf_index = 0;\r\ndev->iamthif_msg_buf_size = 0;\r\ndev->iamthif_stall_timer = MEI_IAMTHIF_STALL_TIMER;\r\ndev->hbuf_is_ready = mei_hbuf_is_ready(dev);\r\nreturn 0;\r\n}\r\nvoid mei_amthif_complete(struct mei_device *dev, struct mei_cl_cb *cb)\r\n{\r\nif (dev->iamthif_canceled != 1) {\r\ndev->iamthif_state = MEI_IAMTHIF_READ_COMPLETE;\r\ndev->iamthif_stall_timer = 0;\r\nmemcpy(cb->response_buffer.data,\r\ndev->iamthif_msg_buf,\r\ndev->iamthif_msg_buf_index);\r\nlist_add_tail(&cb->list, &dev->amthif_rd_complete_list.list);\r\ndev_dbg(&dev->pdev->dev, "amthif read completed\n");\r\ndev->iamthif_timer = jiffies;\r\ndev_dbg(&dev->pdev->dev, "dev->iamthif_timer = %ld\n",\r\ndev->iamthif_timer);\r\n} else {\r\nmei_amthif_run_next_cmd(dev);\r\n}\r\ndev_dbg(&dev->pdev->dev, "completing amthif call back.\n");\r\nwake_up_interruptible(&dev->iamthif_cl.wait);\r\n}\r\nstatic bool mei_clear_list(struct mei_device *dev,\r\nconst struct file *file, struct list_head *mei_cb_list)\r\n{\r\nstruct mei_cl_cb *cb_pos = NULL;\r\nstruct mei_cl_cb *cb_next = NULL;\r\nbool removed = false;\r\nlist_for_each_entry_safe(cb_pos, cb_next, mei_cb_list, list) {\r\nif (file == cb_pos->file_object) {\r\nlist_del(&cb_pos->list);\r\nif (dev->iamthif_current_cb == cb_pos) {\r\ndev->iamthif_current_cb = NULL;\r\nmei_hbm_cl_flow_control_req(dev,\r\n&dev->iamthif_cl);\r\n}\r\nmei_io_cb_free(cb_pos);\r\ncb_pos = NULL;\r\nremoved = true;\r\n}\r\n}\r\nreturn removed;\r\n}\r\nstatic bool mei_clear_lists(struct mei_device *dev, struct file *file)\r\n{\r\nbool removed = false;\r\nmei_clear_list(dev, file, &dev->amthif_cmd_list.list);\r\nif (mei_clear_list(dev, file, &dev->amthif_rd_complete_list.list))\r\nremoved = true;\r\nmei_clear_list(dev, file, &dev->ctrl_rd_list.list);\r\nif (mei_clear_list(dev, file, &dev->ctrl_wr_list.list))\r\nremoved = true;\r\nif (mei_clear_list(dev, file, &dev->write_waiting_list.list))\r\nremoved = true;\r\nif (mei_clear_list(dev, file, &dev->write_list.list))\r\nremoved = true;\r\nif (dev->iamthif_current_cb && !removed) {\r\nif (dev->iamthif_current_cb->file_object == file) {\r\nmei_io_cb_free(dev->iamthif_current_cb);\r\ndev->iamthif_current_cb = NULL;\r\nremoved = true;\r\n}\r\n}\r\nreturn removed;\r\n}\r\nint mei_amthif_release(struct mei_device *dev, struct file *file)\r\n{\r\nif (dev->iamthif_open_count > 0)\r\ndev->iamthif_open_count--;\r\nif (dev->iamthif_file_object == file &&\r\ndev->iamthif_state != MEI_IAMTHIF_IDLE) {\r\ndev_dbg(&dev->pdev->dev, "amthif canceled iamthif state %d\n",\r\ndev->iamthif_state);\r\ndev->iamthif_canceled = true;\r\nif (dev->iamthif_state == MEI_IAMTHIF_READ_COMPLETE) {\r\ndev_dbg(&dev->pdev->dev, "run next amthif iamthif cb\n");\r\nmei_amthif_run_next_cmd(dev);\r\n}\r\n}\r\nif (mei_clear_lists(dev, file))\r\ndev->iamthif_state = MEI_IAMTHIF_IDLE;\r\nreturn 0;\r\n}
