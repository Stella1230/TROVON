static void\r\nsetparam (struct zoran *zr,\r\nchar *name,\r\nchar *sval)\r\n{\r\nint i = 0, reg0, reg, val;\r\nwhile (zr67[i].name != NULL) {\r\nif (!strncmp(name, zr67[i].name, strlen(zr67[i].name))) {\r\nreg = reg0 = btread(zr67[i].reg);\r\nreg &= ~(zr67[i].mask << zr67[i].bit);\r\nif (!isdigit(sval[0]))\r\nbreak;\r\nval = simple_strtoul(sval, NULL, 0);\r\nif ((val & ~zr67[i].mask))\r\nbreak;\r\nreg |= (val & zr67[i].mask) << zr67[i].bit;\r\ndprintk(4,\r\nKERN_INFO\r\n"%s: setparam: setting ZR36067 register 0x%03x: 0x%08x=>0x%08x %s=%d\n",\r\nZR_DEVNAME(zr), zr67[i].reg, reg0, reg,\r\nzr67[i].name, val);\r\nbtwrite(reg, zr67[i].reg);\r\nbreak;\r\n}\r\ni++;\r\n}\r\n}\r\nstatic int zoran_show(struct seq_file *p, void *v)\r\n{\r\nstruct zoran *zr = p->private;\r\nint i;\r\nseq_printf(p, "ZR36067 registers:\n");\r\nfor (i = 0; i < 0x130; i += 16)\r\nseq_printf(p, "%03X %08X %08X %08X %08X \n", i,\r\nbtread(i), btread(i+4), btread(i+8), btread(i+12));\r\nreturn 0;\r\n}\r\nstatic int zoran_open(struct inode *inode, struct file *file)\r\n{\r\nstruct zoran *data = PDE_DATA(inode);\r\nreturn single_open(file, zoran_show, data);\r\n}\r\nstatic ssize_t zoran_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct zoran *zr = PDE_DATA(file_inode(file));\r\nchar *string, *sp;\r\nchar *line, *ldelim, *varname, *svar, *tdelim;\r\nif (count > 32768)\r\nreturn -EINVAL;\r\nstring = sp = vmalloc(count + 1);\r\nif (!string) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: write_proc: can not allocate memory\n",\r\nZR_DEVNAME(zr));\r\nreturn -ENOMEM;\r\n}\r\nif (copy_from_user(string, buffer, count)) {\r\nvfree (string);\r\nreturn -EFAULT;\r\n}\r\nstring[count] = 0;\r\ndprintk(4, KERN_INFO "%s: write_proc: name=%s count=%zu zr=%p\n",\r\nZR_DEVNAME(zr), file->f_path.dentry->d_name.name, count, zr);\r\nldelim = " \t\n";\r\ntdelim = "=";\r\nline = strpbrk(sp, ldelim);\r\nwhile (line) {\r\n*line = 0;\r\nsvar = strpbrk(sp, tdelim);\r\nif (svar) {\r\n*svar = 0;\r\nvarname = sp;\r\nsvar++;\r\nsetparam(zr, varname, svar);\r\n}\r\nsp = line + 1;\r\nline = strpbrk(sp, ldelim);\r\n}\r\nvfree(string);\r\nreturn count;\r\n}\r\nint\r\nzoran_proc_init (struct zoran *zr)\r\n{\r\n#ifdef CONFIG_PROC_FS\r\nchar name[8];\r\nsnprintf(name, 7, "zoran%d", zr->id);\r\nzr->zoran_proc = proc_create_data(name, 0, NULL, &zoran_operations, zr);\r\nif (zr->zoran_proc != NULL) {\r\ndprintk(2,\r\nKERN_INFO\r\n"%s: procfs entry /proc/%s allocated. data=%p\n",\r\nZR_DEVNAME(zr), name, zr);\r\n} else {\r\ndprintk(1, KERN_ERR "%s: Unable to initialise /proc/%s\n",\r\nZR_DEVNAME(zr), name);\r\nreturn 1;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nvoid\r\nzoran_proc_cleanup (struct zoran *zr)\r\n{\r\n#ifdef CONFIG_PROC_FS\r\nchar name[8];\r\nsnprintf(name, 7, "zoran%d", zr->id);\r\nif (zr->zoran_proc)\r\nremove_proc_entry(name, NULL);\r\nzr->zoran_proc = NULL;\r\n#endif\r\n}
