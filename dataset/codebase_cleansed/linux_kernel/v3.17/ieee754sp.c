int ieee754sp_class(union ieee754sp x)\r\n{\r\nCOMPXSP;\r\nEXPLODEXSP;\r\nreturn xc;\r\n}\r\nint ieee754sp_isnan(union ieee754sp x)\r\n{\r\nreturn ieee754sp_class(x) >= IEEE754_CLASS_SNAN;\r\n}\r\nstatic inline int ieee754sp_issnan(union ieee754sp x)\r\n{\r\nassert(ieee754sp_isnan(x));\r\nreturn (SPMANT(x) & SP_MBIT(SP_FBITS-1));\r\n}\r\nunion ieee754sp __cold ieee754sp_nanxcpt(union ieee754sp r)\r\n{\r\nassert(ieee754sp_isnan(r));\r\nif (!ieee754sp_issnan(r))\r\nreturn r;\r\nif (!ieee754_setandtestcx(IEEE754_INVALID_OPERATION)) {\r\nSPMANT(r) &= (~SP_MBIT(SP_FBITS-1));\r\nif (ieee754sp_isnan(r))\r\nreturn r;\r\nelse\r\nreturn ieee754sp_indef();\r\n}\r\nreturn r;\r\n}\r\nstatic unsigned ieee754sp_get_rounding(int sn, unsigned xm)\r\n{\r\nif (xm & (SP_MBIT(3) - 1)) {\r\nswitch (ieee754_csr.rm) {\r\ncase FPU_CSR_RZ:\r\nbreak;\r\ncase FPU_CSR_RN:\r\nxm += 0x3 + ((xm >> 3) & 1);\r\nbreak;\r\ncase FPU_CSR_RU:\r\nif (!sn)\r\nxm += 0x8;\r\nbreak;\r\ncase FPU_CSR_RD:\r\nif (sn)\r\nxm += 0x8;\r\nbreak;\r\n}\r\n}\r\nreturn xm;\r\n}\r\nunion ieee754sp ieee754sp_format(int sn, int xe, unsigned xm)\r\n{\r\nassert(xm);\r\nassert((xm >> (SP_FBITS + 1 + 3)) == 0);\r\nassert(xm & (SP_HIDDEN_BIT << 3));\r\nif (xe < SP_EMIN) {\r\nint es = SP_EMIN - xe;\r\nif (ieee754_csr.nod) {\r\nieee754_setcx(IEEE754_UNDERFLOW);\r\nieee754_setcx(IEEE754_INEXACT);\r\nswitch(ieee754_csr.rm) {\r\ncase FPU_CSR_RN:\r\ncase FPU_CSR_RZ:\r\nreturn ieee754sp_zero(sn);\r\ncase FPU_CSR_RU:\r\nif (sn == 0)\r\nreturn ieee754sp_min(0);\r\nelse\r\nreturn ieee754sp_zero(1);\r\ncase FPU_CSR_RD:\r\nif (sn == 0)\r\nreturn ieee754sp_zero(0);\r\nelse\r\nreturn ieee754sp_min(1);\r\n}\r\n}\r\nif (xe == SP_EMIN - 1 &&\r\nieee754sp_get_rounding(sn, xm) >> (SP_FBITS + 1 + 3))\r\n{\r\nieee754_setcx(IEEE754_INEXACT);\r\nxm = ieee754sp_get_rounding(sn, xm);\r\nxm >>= 1;\r\nxm &= ~(SP_MBIT(3) - 1);\r\nxe++;\r\n} else {\r\nSPXSRSXn(es);\r\nassert((xm & (SP_HIDDEN_BIT << 3)) == 0);\r\nassert(xe == SP_EMIN);\r\n}\r\n}\r\nif (xm & (SP_MBIT(3) - 1)) {\r\nieee754_setcx(IEEE754_INEXACT);\r\nif ((xm & (SP_HIDDEN_BIT << 3)) == 0) {\r\nieee754_setcx(IEEE754_UNDERFLOW);\r\n}\r\nxm = ieee754sp_get_rounding(sn, xm);\r\nif (xm >> (SP_FBITS + 1 + 3)) {\r\nxm >>= 1;\r\nxe++;\r\n}\r\n}\r\nxm >>= 3;\r\nassert((xm >> (SP_FBITS + 1)) == 0);\r\nassert(xe >= SP_EMIN);\r\nif (xe > SP_EMAX) {\r\nieee754_setcx(IEEE754_OVERFLOW);\r\nieee754_setcx(IEEE754_INEXACT);\r\nswitch (ieee754_csr.rm) {\r\ncase FPU_CSR_RN:\r\nreturn ieee754sp_inf(sn);\r\ncase FPU_CSR_RZ:\r\nreturn ieee754sp_max(sn);\r\ncase FPU_CSR_RU:\r\nif (sn == 0)\r\nreturn ieee754sp_inf(0);\r\nelse\r\nreturn ieee754sp_max(1);\r\ncase FPU_CSR_RD:\r\nif (sn == 0)\r\nreturn ieee754sp_max(0);\r\nelse\r\nreturn ieee754sp_inf(1);\r\n}\r\n}\r\nif ((xm & SP_HIDDEN_BIT) == 0) {\r\nassert(xe == SP_EMIN);\r\nif (ieee754_csr.mx & IEEE754_UNDERFLOW)\r\nieee754_setcx(IEEE754_UNDERFLOW);\r\nreturn buildsp(sn, SP_EMIN - 1 + SP_EBIAS, xm);\r\n} else {\r\nassert((xm >> (SP_FBITS + 1)) == 0);\r\nassert(xm & SP_HIDDEN_BIT);\r\nreturn buildsp(sn, xe + SP_EBIAS, xm & ~SP_HIDDEN_BIT);\r\n}\r\n}
