int usb_gadget_map_request(struct usb_gadget *gadget,\r\nstruct usb_request *req, int is_in)\r\n{\r\nif (req->length == 0)\r\nreturn 0;\r\nif (req->num_sgs) {\r\nint mapped;\r\nmapped = dma_map_sg(&gadget->dev, req->sg, req->num_sgs,\r\nis_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\r\nif (mapped == 0) {\r\ndev_err(&gadget->dev, "failed to map SGs\n");\r\nreturn -EFAULT;\r\n}\r\nreq->num_mapped_sgs = mapped;\r\n} else {\r\nreq->dma = dma_map_single(&gadget->dev, req->buf, req->length,\r\nis_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\r\nif (dma_mapping_error(&gadget->dev, req->dma)) {\r\ndev_err(&gadget->dev, "failed to map buffer\n");\r\nreturn -EFAULT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid usb_gadget_unmap_request(struct usb_gadget *gadget,\r\nstruct usb_request *req, int is_in)\r\n{\r\nif (req->length == 0)\r\nreturn;\r\nif (req->num_mapped_sgs) {\r\ndma_unmap_sg(&gadget->dev, req->sg, req->num_mapped_sgs,\r\nis_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\r\nreq->num_mapped_sgs = 0;\r\n} else {\r\ndma_unmap_single(&gadget->dev, req->dma, req->length,\r\nis_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\r\n}\r\n}\r\nstatic void usb_gadget_state_work(struct work_struct *work)\r\n{\r\nstruct usb_gadget *gadget = work_to_gadget(work);\r\nsysfs_notify(&gadget->dev.kobj, NULL, "state");\r\n}\r\nvoid usb_gadget_set_state(struct usb_gadget *gadget,\r\nenum usb_device_state state)\r\n{\r\ngadget->state = state;\r\nschedule_work(&gadget->work);\r\n}\r\nstatic inline int usb_gadget_udc_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nreturn gadget->ops->udc_start(gadget, driver);\r\n}\r\nstatic inline void usb_gadget_udc_stop(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\ngadget->ops->udc_stop(gadget, driver);\r\n}\r\nstatic void usb_udc_release(struct device *dev)\r\n{\r\nstruct usb_udc *udc;\r\nudc = container_of(dev, struct usb_udc, dev);\r\ndev_dbg(dev, "releasing '%s'\n", dev_name(dev));\r\nkfree(udc);\r\n}\r\nstatic void usb_udc_nop_release(struct device *dev)\r\n{\r\ndev_vdbg(dev, "%s\n", __func__);\r\n}\r\nint usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,\r\nvoid (*release)(struct device *dev))\r\n{\r\nstruct usb_udc *udc;\r\nint ret = -ENOMEM;\r\nudc = kzalloc(sizeof(*udc), GFP_KERNEL);\r\nif (!udc)\r\ngoto err1;\r\ndev_set_name(&gadget->dev, "gadget");\r\nINIT_WORK(&gadget->work, usb_gadget_state_work);\r\ngadget->dev.parent = parent;\r\n#ifdef CONFIG_HAS_DMA\r\ndma_set_coherent_mask(&gadget->dev, parent->coherent_dma_mask);\r\ngadget->dev.dma_parms = parent->dma_parms;\r\ngadget->dev.dma_mask = parent->dma_mask;\r\n#endif\r\nif (release)\r\ngadget->dev.release = release;\r\nelse\r\ngadget->dev.release = usb_udc_nop_release;\r\nret = device_register(&gadget->dev);\r\nif (ret)\r\ngoto err2;\r\ndevice_initialize(&udc->dev);\r\nudc->dev.release = usb_udc_release;\r\nudc->dev.class = udc_class;\r\nudc->dev.groups = usb_udc_attr_groups;\r\nudc->dev.parent = parent;\r\nret = dev_set_name(&udc->dev, "%s", kobject_name(&parent->kobj));\r\nif (ret)\r\ngoto err3;\r\nudc->gadget = gadget;\r\nmutex_lock(&udc_lock);\r\nlist_add_tail(&udc->list, &udc_list);\r\nret = device_add(&udc->dev);\r\nif (ret)\r\ngoto err4;\r\nusb_gadget_set_state(gadget, USB_STATE_NOTATTACHED);\r\nmutex_unlock(&udc_lock);\r\nreturn 0;\r\nerr4:\r\nlist_del(&udc->list);\r\nmutex_unlock(&udc_lock);\r\nerr3:\r\nput_device(&udc->dev);\r\nerr2:\r\nput_device(&gadget->dev);\r\nkfree(udc);\r\nerr1:\r\nreturn ret;\r\n}\r\nint usb_add_gadget_udc(struct device *parent, struct usb_gadget *gadget)\r\n{\r\nreturn usb_add_gadget_udc_release(parent, gadget, NULL);\r\n}\r\nstatic void usb_gadget_remove_driver(struct usb_udc *udc)\r\n{\r\ndev_dbg(&udc->dev, "unregistering UDC driver [%s]\n",\r\nudc->gadget->name);\r\nkobject_uevent(&udc->dev.kobj, KOBJ_CHANGE);\r\nusb_gadget_disconnect(udc->gadget);\r\nudc->driver->disconnect(udc->gadget);\r\nudc->driver->unbind(udc->gadget);\r\nusb_gadget_udc_stop(udc->gadget, NULL);\r\nudc->driver = NULL;\r\nudc->dev.driver = NULL;\r\nudc->gadget->dev.driver = NULL;\r\n}\r\nvoid usb_del_gadget_udc(struct usb_gadget *gadget)\r\n{\r\nstruct usb_udc *udc = NULL;\r\nmutex_lock(&udc_lock);\r\nlist_for_each_entry(udc, &udc_list, list)\r\nif (udc->gadget == gadget)\r\ngoto found;\r\ndev_err(gadget->dev.parent, "gadget not registered.\n");\r\nmutex_unlock(&udc_lock);\r\nreturn;\r\nfound:\r\ndev_vdbg(gadget->dev.parent, "unregistering gadget\n");\r\nlist_del(&udc->list);\r\nmutex_unlock(&udc_lock);\r\nif (udc->driver)\r\nusb_gadget_remove_driver(udc);\r\nkobject_uevent(&udc->dev.kobj, KOBJ_REMOVE);\r\nflush_work(&gadget->work);\r\ndevice_unregister(&udc->dev);\r\ndevice_unregister(&gadget->dev);\r\n}\r\nstatic int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *driver)\r\n{\r\nint ret;\r\ndev_dbg(&udc->dev, "registering UDC driver [%s]\n",\r\ndriver->function);\r\nudc->driver = driver;\r\nudc->dev.driver = &driver->driver;\r\nudc->gadget->dev.driver = &driver->driver;\r\nret = driver->bind(udc->gadget, driver);\r\nif (ret)\r\ngoto err1;\r\nret = usb_gadget_udc_start(udc->gadget, driver);\r\nif (ret) {\r\ndriver->unbind(udc->gadget);\r\ngoto err1;\r\n}\r\nusb_gadget_connect(udc->gadget);\r\nkobject_uevent(&udc->dev.kobj, KOBJ_CHANGE);\r\nreturn 0;\r\nerr1:\r\nif (ret != -EISNAM)\r\ndev_err(&udc->dev, "failed to start %s: %d\n",\r\nudc->driver->function, ret);\r\nudc->driver = NULL;\r\nudc->dev.driver = NULL;\r\nudc->gadget->dev.driver = NULL;\r\nreturn ret;\r\n}\r\nint udc_attach_driver(const char *name, struct usb_gadget_driver *driver)\r\n{\r\nstruct usb_udc *udc = NULL;\r\nint ret = -ENODEV;\r\nmutex_lock(&udc_lock);\r\nlist_for_each_entry(udc, &udc_list, list) {\r\nret = strcmp(name, dev_name(&udc->dev));\r\nif (!ret)\r\nbreak;\r\n}\r\nif (ret) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (udc->driver) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nret = udc_bind_to_driver(udc, driver);\r\nout:\r\nmutex_unlock(&udc_lock);\r\nreturn ret;\r\n}\r\nint usb_gadget_probe_driver(struct usb_gadget_driver *driver)\r\n{\r\nstruct usb_udc *udc = NULL;\r\nint ret;\r\nif (!driver || !driver->bind || !driver->setup)\r\nreturn -EINVAL;\r\nmutex_lock(&udc_lock);\r\nlist_for_each_entry(udc, &udc_list, list) {\r\nif (!udc->driver)\r\ngoto found;\r\n}\r\npr_debug("couldn't find an available UDC\n");\r\nmutex_unlock(&udc_lock);\r\nreturn -ENODEV;\r\nfound:\r\nret = udc_bind_to_driver(udc, driver);\r\nmutex_unlock(&udc_lock);\r\nreturn ret;\r\n}\r\nint usb_gadget_unregister_driver(struct usb_gadget_driver *driver)\r\n{\r\nstruct usb_udc *udc = NULL;\r\nint ret = -ENODEV;\r\nif (!driver || !driver->unbind)\r\nreturn -EINVAL;\r\nmutex_lock(&udc_lock);\r\nlist_for_each_entry(udc, &udc_list, list)\r\nif (udc->driver == driver) {\r\nusb_gadget_remove_driver(udc);\r\nusb_gadget_set_state(udc->gadget,\r\nUSB_STATE_NOTATTACHED);\r\nret = 0;\r\nbreak;\r\n}\r\nmutex_unlock(&udc_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t usb_udc_srp_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t n)\r\n{\r\nstruct usb_udc *udc = container_of(dev, struct usb_udc, dev);\r\nif (sysfs_streq(buf, "1"))\r\nusb_gadget_wakeup(udc->gadget);\r\nreturn n;\r\n}\r\nstatic ssize_t usb_udc_softconn_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t n)\r\n{\r\nstruct usb_udc *udc = container_of(dev, struct usb_udc, dev);\r\nif (sysfs_streq(buf, "connect")) {\r\nusb_gadget_udc_start(udc->gadget, udc->driver);\r\nusb_gadget_connect(udc->gadget);\r\n} else if (sysfs_streq(buf, "disconnect")) {\r\nusb_gadget_disconnect(udc->gadget);\r\nusb_gadget_udc_stop(udc->gadget, udc->driver);\r\n} else {\r\ndev_err(dev, "unsupported command '%s'\n", buf);\r\nreturn -EINVAL;\r\n}\r\nreturn n;\r\n}\r\nstatic ssize_t state_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct usb_udc *udc = container_of(dev, struct usb_udc, dev);\r\nstruct usb_gadget *gadget = udc->gadget;\r\nreturn sprintf(buf, "%s\n", usb_state_string(gadget->state));\r\n}\r\nstatic int usb_udc_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct usb_udc *udc = container_of(dev, struct usb_udc, dev);\r\nint ret;\r\nret = add_uevent_var(env, "USB_UDC_NAME=%s", udc->gadget->name);\r\nif (ret) {\r\ndev_err(dev, "failed to add uevent USB_UDC_NAME\n");\r\nreturn ret;\r\n}\r\nif (udc->driver) {\r\nret = add_uevent_var(env, "USB_UDC_DRIVER=%s",\r\nudc->driver->function);\r\nif (ret) {\r\ndev_err(dev, "failed to add uevent USB_UDC_DRIVER\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init usb_udc_init(void)\r\n{\r\nudc_class = class_create(THIS_MODULE, "udc");\r\nif (IS_ERR(udc_class)) {\r\npr_err("failed to create udc class --> %ld\n",\r\nPTR_ERR(udc_class));\r\nreturn PTR_ERR(udc_class);\r\n}\r\nudc_class->dev_uevent = usb_udc_uevent;\r\nreturn 0;\r\n}\r\nstatic void __exit usb_udc_exit(void)\r\n{\r\nclass_destroy(udc_class);\r\n}
