static void\r\nbsd_clear(struct bsd_db *db)\r\n{\r\ndb->clear_count++;\r\ndb->max_ent = FIRST-1;\r\ndb->n_bits = BSD_INIT_BITS;\r\ndb->bytes_out = 0;\r\ndb->in_count = 0;\r\ndb->ratio = 0;\r\ndb->checkpoint = CHECK_GAP;\r\n}\r\nstatic int bsd_check (struct bsd_db *db)\r\n{\r\nunsigned int new_ratio;\r\nif (db->in_count >= db->checkpoint)\r\n{\r\nif (db->in_count >= RATIO_MAX || db->bytes_out >= RATIO_MAX)\r\n{\r\ndb->in_count -= (db->in_count >> 2);\r\ndb->bytes_out -= (db->bytes_out >> 2);\r\n}\r\ndb->checkpoint = db->in_count + CHECK_GAP;\r\nif (db->max_ent >= db->maxmaxcode)\r\n{\r\nnew_ratio = db->in_count << RATIO_SCALE_LOG;\r\nif (db->bytes_out != 0)\r\n{\r\nnew_ratio /= db->bytes_out;\r\n}\r\nif (new_ratio < db->ratio || new_ratio < 1 * RATIO_SCALE)\r\n{\r\nbsd_clear (db);\r\nreturn 1;\r\n}\r\ndb->ratio = new_ratio;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void bsd_comp_stats (void *state, struct compstat *stats)\r\n{\r\nstruct bsd_db *db = (struct bsd_db *) state;\r\nstats->unc_bytes = db->uncomp_bytes;\r\nstats->unc_packets = db->uncomp_count;\r\nstats->comp_bytes = db->comp_bytes;\r\nstats->comp_packets = db->comp_count;\r\nstats->inc_bytes = db->incomp_bytes;\r\nstats->inc_packets = db->incomp_count;\r\nstats->in_count = db->in_count;\r\nstats->bytes_out = db->bytes_out;\r\n}\r\nstatic void bsd_reset (void *state)\r\n{\r\nstruct bsd_db *db = (struct bsd_db *) state;\r\nbsd_clear(db);\r\ndb->seqno = 0;\r\ndb->clear_count = 0;\r\n}\r\nstatic void bsd_free (void *state)\r\n{\r\nstruct bsd_db *db = state;\r\nif (!db)\r\nreturn;\r\nvfree(db->dict);\r\ndb->dict = NULL;\r\nvfree(db->lens);\r\ndb->lens = NULL;\r\nkfree(db);\r\n}\r\nstatic void *bsd_alloc (unsigned char *options, int opt_len, int decomp)\r\n{\r\nint bits;\r\nunsigned int hsize, hshift, maxmaxcode;\r\nstruct bsd_db *db;\r\nif (opt_len != 3 || options[0] != CI_BSD_COMPRESS || options[1] != 3\r\n|| BSD_VERSION(options[2]) != BSD_CURRENT_VERSION)\r\n{\r\nreturn NULL;\r\n}\r\nbits = BSD_NBITS(options[2]);\r\nswitch (bits)\r\n{\r\ncase 9:\r\ncase 10:\r\ncase 11:\r\ncase 12:\r\nhsize = 5003;\r\nhshift = 4;\r\nbreak;\r\ncase 13:\r\nhsize = 9001;\r\nhshift = 5;\r\nbreak;\r\ncase 14:\r\nhsize = 18013;\r\nhshift = 6;\r\nbreak;\r\ncase 15:\r\nhsize = 35023;\r\nhshift = 7;\r\nbreak;\r\ncase 16:\r\ndefault:\r\nreturn NULL;\r\n}\r\nmaxmaxcode = MAXCODE(bits);\r\ndb = kzalloc(sizeof (struct bsd_db),\r\nGFP_KERNEL);\r\nif (!db)\r\n{\r\nreturn NULL;\r\n}\r\ndb->dict = vmalloc(hsize * sizeof(struct bsd_dict));\r\nif (!db->dict)\r\n{\r\nbsd_free (db);\r\nreturn NULL;\r\n}\r\nif (!decomp)\r\n{\r\ndb->lens = NULL;\r\n}\r\nelse\r\n{\r\ndb->lens = vmalloc((maxmaxcode + 1) * sizeof(db->lens[0]));\r\nif (!db->lens)\r\n{\r\nbsd_free (db);\r\nreturn NULL;\r\n}\r\n}\r\ndb->totlen = sizeof (struct bsd_db) +\r\n(sizeof (struct bsd_dict) * hsize);\r\ndb->hsize = hsize;\r\ndb->hshift = hshift;\r\ndb->maxmaxcode = maxmaxcode;\r\ndb->maxbits = bits;\r\nreturn (void *) db;\r\n}\r\nstatic void *bsd_comp_alloc (unsigned char *options, int opt_len)\r\n{\r\nreturn bsd_alloc (options, opt_len, 0);\r\n}\r\nstatic void *bsd_decomp_alloc (unsigned char *options, int opt_len)\r\n{\r\nreturn bsd_alloc (options, opt_len, 1);\r\n}\r\nstatic int bsd_init (void *state, unsigned char *options,\r\nint opt_len, int unit, int debug, int decomp)\r\n{\r\nstruct bsd_db *db = state;\r\nint indx;\r\nif ((opt_len != 3) || (options[0] != CI_BSD_COMPRESS) || (options[1] != 3)\r\n|| (BSD_VERSION(options[2]) != BSD_CURRENT_VERSION)\r\n|| (BSD_NBITS(options[2]) != db->maxbits)\r\n|| (decomp && db->lens == NULL))\r\n{\r\nreturn 0;\r\n}\r\nif (decomp)\r\n{\r\nindx = LAST;\r\ndo\r\n{\r\ndb->lens[indx] = 1;\r\n}\r\nwhile (indx-- > 0);\r\n}\r\nindx = db->hsize;\r\nwhile (indx-- != 0)\r\n{\r\ndb->dict[indx].codem1 = BADCODEM1;\r\ndb->dict[indx].cptr = 0;\r\n}\r\ndb->unit = unit;\r\ndb->mru = 0;\r\n#ifndef DEBUG\r\nif (debug)\r\n#endif\r\ndb->debug = 1;\r\nbsd_reset(db);\r\nreturn 1;\r\n}\r\nstatic int bsd_comp_init (void *state, unsigned char *options,\r\nint opt_len, int unit, int opthdr, int debug)\r\n{\r\nreturn bsd_init (state, options, opt_len, unit, debug, 0);\r\n}\r\nstatic int bsd_decomp_init (void *state, unsigned char *options,\r\nint opt_len, int unit, int opthdr, int mru,\r\nint debug)\r\n{\r\nreturn bsd_init (state, options, opt_len, unit, debug, 1);\r\n}\r\nstatic unsigned short *lens_ptr(struct bsd_db *db, int idx)\r\n{\r\nif ((unsigned int) idx > (unsigned int) db->maxmaxcode)\r\n{\r\nprintk ("<9>ppp: lens_ptr(%d) > max\n", idx);\r\nidx = 0;\r\n}\r\nreturn lens_ptrx (db, idx);\r\n}\r\nstatic struct bsd_dict *dict_ptr(struct bsd_db *db, int idx)\r\n{\r\nif ((unsigned int) idx >= (unsigned int) db->hsize)\r\n{\r\nprintk ("<9>ppp: dict_ptr(%d) > max\n", idx);\r\nidx = 0;\r\n}\r\nreturn dict_ptrx (db, idx);\r\n}\r\nstatic int bsd_compress (void *state, unsigned char *rptr, unsigned char *obuf,\r\nint isize, int osize)\r\n{\r\nstruct bsd_db *db;\r\nint hshift;\r\nunsigned int max_ent;\r\nunsigned int n_bits;\r\nunsigned int bitno;\r\nunsigned long accm;\r\nint ent;\r\nunsigned long fcode;\r\nstruct bsd_dict *dictp;\r\nunsigned char c;\r\nint hval;\r\nint disp;\r\nint ilen;\r\nint mxcode;\r\nunsigned char *wptr;\r\nint olen;\r\n#define PUTBYTE(v) \\r\n{ \\r\n++olen; \\r\nif (wptr) \\r\n{ \\r\n*wptr++ = (unsigned char) (v); \\r\nif (olen >= osize) \\r\n{ \\r\nwptr = NULL; \\r\n} \\r\n} \\r\n}\r\n#define OUTPUT(ent) \\r\n{ \\r\nbitno -= n_bits; \\r\naccm |= ((ent) << bitno); \\r\ndo \\r\n{ \\r\nPUTBYTE(accm >> 24); \\r\naccm <<= 8; \\r\nbitno += 8; \\r\n} \\r\nwhile (bitno <= 24); \\r\n}\r\nent = PPP_PROTOCOL(rptr);\r\nif (ent < 0x21 || ent > 0xf9)\r\n{\r\nreturn 0;\r\n}\r\ndb = (struct bsd_db *) state;\r\nhshift = db->hshift;\r\nmax_ent = db->max_ent;\r\nn_bits = db->n_bits;\r\nbitno = 32;\r\naccm = 0;\r\nmxcode = MAXCODE (n_bits);\r\nwptr = obuf;\r\nolen = PPP_HDRLEN + BSD_OVHD;\r\nif (osize > isize)\r\n{\r\nosize = isize;\r\n}\r\nif (wptr)\r\n{\r\n*wptr++ = PPP_ADDRESS(rptr);\r\n*wptr++ = PPP_CONTROL(rptr);\r\n*wptr++ = 0;\r\n*wptr++ = PPP_COMP;\r\n*wptr++ = db->seqno >> 8;\r\n*wptr++ = db->seqno;\r\n}\r\nrptr += PPP_HDRLEN;\r\nisize -= PPP_HDRLEN;\r\nilen = ++isize;\r\nwhile (--ilen > 0)\r\n{\r\nc = *rptr++;\r\nfcode = BSD_KEY (ent, c);\r\nhval = BSD_HASH (ent, c, hshift);\r\ndictp = dict_ptr (db, hval);\r\nif (dictp->codem1 >= max_ent)\r\n{\r\ngoto nomatch;\r\n}\r\nif (dictp->f.fcode == fcode)\r\n{\r\nent = dictp->codem1 + 1;\r\ncontinue;\r\n}\r\ndisp = (hval == 0) ? 1 : hval;\r\ndo\r\n{\r\nhval += disp;\r\nif (hval >= db->hsize)\r\n{\r\nhval -= db->hsize;\r\n}\r\ndictp = dict_ptr (db, hval);\r\nif (dictp->codem1 >= max_ent)\r\n{\r\ngoto nomatch;\r\n}\r\n}\r\nwhile (dictp->f.fcode != fcode);\r\nent = dictp->codem1 + 1;\r\ncontinue;\r\nnomatch:\r\nOUTPUT(ent);\r\nif (max_ent < db->maxmaxcode)\r\n{\r\nstruct bsd_dict *dictp2;\r\nstruct bsd_dict *dictp3;\r\nint indx;\r\nif (max_ent >= mxcode)\r\n{\r\ndb->n_bits = ++n_bits;\r\nmxcode = MAXCODE (n_bits);\r\n}\r\ndictp2 = dict_ptr (db, max_ent + 1);\r\nindx = dictp2->cptr;\r\ndictp3 = dict_ptr (db, indx);\r\nif (dictp3->codem1 == max_ent)\r\n{\r\ndictp3->codem1 = BADCODEM1;\r\n}\r\ndictp2->cptr = hval;\r\ndictp->codem1 = max_ent;\r\ndictp->f.fcode = fcode;\r\ndb->max_ent = ++max_ent;\r\nif (db->lens)\r\n{\r\nunsigned short *len1 = lens_ptr (db, max_ent);\r\nunsigned short *len2 = lens_ptr (db, ent);\r\n*len1 = *len2 + 1;\r\n}\r\n}\r\nent = c;\r\n}\r\nOUTPUT(ent);\r\ndb->bytes_out += olen - PPP_HDRLEN - BSD_OVHD;\r\ndb->uncomp_bytes += isize;\r\ndb->in_count += isize;\r\n++db->uncomp_count;\r\n++db->seqno;\r\nif (bitno < 32)\r\n{\r\n++db->bytes_out;\r\n}\r\nif (bsd_check(db))\r\n{\r\nOUTPUT (CLEAR);\r\n}\r\nif (bitno != 32)\r\n{\r\nPUTBYTE((accm | (0xff << (bitno-8))) >> 24);\r\n}\r\nif (max_ent >= mxcode && max_ent < db->maxmaxcode)\r\n{\r\ndb->n_bits++;\r\n}\r\nif (wptr == NULL)\r\n{\r\n++db->incomp_count;\r\ndb->incomp_bytes += isize;\r\nolen = 0;\r\n}\r\nelse\r\n{\r\n++db->comp_count;\r\ndb->comp_bytes += olen;\r\n}\r\nreturn olen;\r\n#undef OUTPUT\r\n#undef PUTBYTE\r\n}\r\nstatic void bsd_incomp (void *state, unsigned char *ibuf, int icnt)\r\n{\r\n(void) bsd_compress (state, ibuf, (char *) 0, icnt, 0);\r\n}\r\nstatic int bsd_decompress (void *state, unsigned char *ibuf, int isize,\r\nunsigned char *obuf, int osize)\r\n{\r\nstruct bsd_db *db;\r\nunsigned int max_ent;\r\nunsigned long accm;\r\nunsigned int bitno;\r\nunsigned int n_bits;\r\nunsigned int tgtbitno;\r\nstruct bsd_dict *dictp;\r\nint explen;\r\nint seq;\r\nunsigned int incode;\r\nunsigned int oldcode;\r\nunsigned int finchar;\r\nunsigned char *p;\r\nunsigned char *wptr;\r\nint adrs;\r\nint ctrl;\r\nint ilen;\r\nint codelen;\r\nint extra;\r\ndb = (struct bsd_db *) state;\r\nmax_ent = db->max_ent;\r\naccm = 0;\r\nbitno = 32;\r\nn_bits = db->n_bits;\r\ntgtbitno = 32 - n_bits;\r\nadrs = PPP_ADDRESS (ibuf);\r\nctrl = PPP_CONTROL (ibuf);\r\nseq = (ibuf[4] << 8) + ibuf[5];\r\nibuf += (PPP_HDRLEN + 2);\r\nilen = isize - (PPP_HDRLEN + 2);\r\nif (seq != db->seqno)\r\n{\r\nif (db->debug)\r\n{\r\nprintk("bsd_decomp%d: bad sequence # %d, expected %d\n",\r\ndb->unit, seq, db->seqno - 1);\r\n}\r\nreturn DECOMP_ERROR;\r\n}\r\n++db->seqno;\r\ndb->bytes_out += ilen;\r\nwptr = obuf;\r\n*wptr++ = adrs;\r\n*wptr++ = ctrl;\r\n*wptr++ = 0;\r\noldcode = CLEAR;\r\nexplen = 3;\r\nfor (;;)\r\n{\r\nif (ilen-- <= 0)\r\n{\r\ndb->in_count += (explen - 3);\r\nbreak;\r\n}\r\nbitno -= 8;\r\naccm |= *ibuf++ << bitno;\r\nif (tgtbitno < bitno)\r\n{\r\ncontinue;\r\n}\r\nincode = accm >> tgtbitno;\r\naccm <<= n_bits;\r\nbitno += n_bits;\r\nif (incode == CLEAR)\r\n{\r\nif (ilen > 0)\r\n{\r\nif (db->debug)\r\n{\r\nprintk("bsd_decomp%d: bad CLEAR\n", db->unit);\r\n}\r\nreturn DECOMP_FATALERROR;\r\n}\r\nbsd_clear(db);\r\nbreak;\r\n}\r\nif ((incode > max_ent + 2) || (incode > db->maxmaxcode)\r\n|| (incode > max_ent && oldcode == CLEAR))\r\n{\r\nif (db->debug)\r\n{\r\nprintk("bsd_decomp%d: bad code 0x%x oldcode=0x%x ",\r\ndb->unit, incode, oldcode);\r\nprintk("max_ent=0x%x explen=%d seqno=%d\n",\r\nmax_ent, explen, db->seqno);\r\n}\r\nreturn DECOMP_FATALERROR;\r\n}\r\nif (incode > max_ent)\r\n{\r\nfinchar = oldcode;\r\nextra = 1;\r\n}\r\nelse\r\n{\r\nfinchar = incode;\r\nextra = 0;\r\n}\r\ncodelen = *(lens_ptr (db, finchar));\r\nexplen += codelen + extra;\r\nif (explen > osize)\r\n{\r\nif (db->debug)\r\n{\r\nprintk("bsd_decomp%d: ran out of mru\n", db->unit);\r\n#ifdef DEBUG\r\nprintk(" len=%d, finchar=0x%x, codelen=%d, explen=%d\n",\r\nilen, finchar, codelen, explen);\r\n#endif\r\n}\r\nreturn DECOMP_FATALERROR;\r\n}\r\nwptr += codelen;\r\np = wptr;\r\nwhile (finchar > LAST)\r\n{\r\nstruct bsd_dict *dictp2 = dict_ptr (db, finchar);\r\ndictp = dict_ptr (db, dictp2->cptr);\r\n#ifdef DEBUG\r\nif (--codelen <= 0 || dictp->codem1 != finchar-1)\r\n{\r\nif (codelen <= 0)\r\n{\r\nprintk("bsd_decomp%d: fell off end of chain ", db->unit);\r\nprintk("0x%x at 0x%x by 0x%x, max_ent=0x%x\n",\r\nincode, finchar, dictp2->cptr, max_ent);\r\n}\r\nelse\r\n{\r\nif (dictp->codem1 != finchar-1)\r\n{\r\nprintk("bsd_decomp%d: bad code chain 0x%x "\r\n"finchar=0x%x ",\r\ndb->unit, incode, finchar);\r\nprintk("oldcode=0x%x cptr=0x%x codem1=0x%x\n",\r\noldcode, dictp2->cptr, dictp->codem1);\r\n}\r\n}\r\nreturn DECOMP_FATALERROR;\r\n}\r\n#endif\r\n*--p = dictp->f.hs.suffix;\r\nfinchar = dictp->f.hs.prefix;\r\n}\r\n*--p = finchar;\r\n#ifdef DEBUG\r\nif (--codelen != 0)\r\n{\r\nprintk("bsd_decomp%d: short by %d after code 0x%x, max_ent=0x%x\n",\r\ndb->unit, codelen, incode, max_ent);\r\n}\r\n#endif\r\nif (extra)\r\n{\r\n*wptr++ = finchar;\r\n}\r\nif (oldcode != CLEAR && max_ent < db->maxmaxcode)\r\n{\r\nstruct bsd_dict *dictp2, *dictp3;\r\nunsigned short *lens1, *lens2;\r\nunsigned long fcode;\r\nint hval, disp, indx;\r\nfcode = BSD_KEY(oldcode,finchar);\r\nhval = BSD_HASH(oldcode,finchar,db->hshift);\r\ndictp = dict_ptr (db, hval);\r\nif (dictp->codem1 < max_ent)\r\n{\r\ndisp = (hval == 0) ? 1 : hval;\r\ndo\r\n{\r\nhval += disp;\r\nif (hval >= db->hsize)\r\n{\r\nhval -= db->hsize;\r\n}\r\ndictp = dict_ptr (db, hval);\r\n}\r\nwhile (dictp->codem1 < max_ent);\r\n}\r\ndictp2 = dict_ptr (db, max_ent + 1);\r\nindx = dictp2->cptr;\r\ndictp3 = dict_ptr (db, indx);\r\nif (dictp3->codem1 == max_ent)\r\n{\r\ndictp3->codem1 = BADCODEM1;\r\n}\r\ndictp2->cptr = hval;\r\ndictp->codem1 = max_ent;\r\ndictp->f.fcode = fcode;\r\ndb->max_ent = ++max_ent;\r\nlens1 = lens_ptr (db, max_ent);\r\nlens2 = lens_ptr (db, oldcode);\r\n*lens1 = *lens2 + 1;\r\nif (max_ent >= MAXCODE(n_bits) && max_ent < db->maxmaxcode)\r\n{\r\ndb->n_bits = ++n_bits;\r\ntgtbitno = 32-n_bits;\r\n}\r\n}\r\noldcode = incode;\r\n}\r\n++db->comp_count;\r\n++db->uncomp_count;\r\ndb->comp_bytes += isize - BSD_OVHD - PPP_HDRLEN;\r\ndb->uncomp_bytes += explen;\r\nif (bsd_check(db))\r\n{\r\nif (db->debug)\r\n{\r\nprintk("bsd_decomp%d: peer should have cleared dictionary on %d\n",\r\ndb->unit, db->seqno - 1);\r\n}\r\n}\r\nreturn explen;\r\n}\r\nstatic int __init bsdcomp_init(void)\r\n{\r\nint answer = ppp_register_compressor(&ppp_bsd_compress);\r\nif (answer == 0)\r\nprintk(KERN_INFO "PPP BSD Compression module registered\n");\r\nreturn answer;\r\n}\r\nstatic void __exit bsdcomp_cleanup(void)\r\n{\r\nppp_unregister_compressor(&ppp_bsd_compress);\r\n}
