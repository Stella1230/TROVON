static void mei_wd_set_start_timeout(struct mei_device *dev, u16 timeout)\r\n{\r\ndev_dbg(&dev->pdev->dev, "wd: set timeout=%d.\n", timeout);\r\nmemcpy(dev->wd_data, mei_start_wd_params, MEI_WD_HDR_SIZE);\r\nmemcpy(dev->wd_data + MEI_WD_HDR_SIZE, &timeout, sizeof(u16));\r\n}\r\nint mei_wd_host_init(struct mei_device *dev)\r\n{\r\nstruct mei_cl *cl = &dev->wd_cl;\r\nint id;\r\nint ret;\r\nmei_cl_init(cl, dev);\r\ndev->wd_timeout = MEI_WD_DEFAULT_TIMEOUT;\r\ndev->wd_state = MEI_WD_IDLE;\r\nid = mei_me_cl_by_uuid(dev, &mei_wd_guid);\r\nif (id < 0) {\r\ndev_info(&dev->pdev->dev, "wd: failed to find the client\n");\r\nreturn -ENOTTY;\r\n}\r\ncl->me_client_id = dev->me_clients[id].client_id;\r\nret = mei_cl_link(cl, MEI_WD_HOST_CLIENT_ID);\r\nif (ret < 0) {\r\ndev_info(&dev->pdev->dev, "wd: failed link client\n");\r\nreturn ret;\r\n}\r\nret = mei_cl_connect(cl, NULL);\r\nif (ret) {\r\ndev_err(&dev->pdev->dev, "wd: failed to connect = %d\n", ret);\r\nmei_cl_unlink(cl);\r\nreturn ret;\r\n}\r\nret = mei_watchdog_register(dev);\r\nif (ret) {\r\nmei_cl_disconnect(cl);\r\nmei_cl_unlink(cl);\r\n}\r\nreturn ret;\r\n}\r\nint mei_wd_send(struct mei_device *dev)\r\n{\r\nstruct mei_cl *cl = &dev->wd_cl;\r\nstruct mei_msg_hdr hdr;\r\nint ret;\r\nhdr.host_addr = cl->host_client_id;\r\nhdr.me_addr = cl->me_client_id;\r\nhdr.msg_complete = 1;\r\nhdr.reserved = 0;\r\nhdr.internal = 0;\r\nif (!memcmp(dev->wd_data, mei_start_wd_params, MEI_WD_HDR_SIZE))\r\nhdr.length = MEI_WD_START_MSG_SIZE;\r\nelse if (!memcmp(dev->wd_data, mei_stop_wd_params, MEI_WD_HDR_SIZE))\r\nhdr.length = MEI_WD_STOP_MSG_SIZE;\r\nelse {\r\ndev_err(&dev->pdev->dev, "wd: invalid message is to be sent, aborting\n");\r\nreturn -EINVAL;\r\n}\r\nret = mei_write_message(dev, &hdr, dev->wd_data);\r\nif (ret) {\r\ndev_err(&dev->pdev->dev, "wd: write message failed\n");\r\nreturn ret;\r\n}\r\nret = mei_cl_flow_ctrl_reduce(cl);\r\nif (ret) {\r\ndev_err(&dev->pdev->dev, "wd: flow_ctrl_reduce failed.\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint mei_wd_stop(struct mei_device *dev)\r\n{\r\nint ret;\r\nif (dev->wd_cl.state != MEI_FILE_CONNECTED ||\r\ndev->wd_state != MEI_WD_RUNNING)\r\nreturn 0;\r\nmemcpy(dev->wd_data, mei_stop_wd_params, MEI_WD_STOP_MSG_SIZE);\r\ndev->wd_state = MEI_WD_STOPPING;\r\nret = mei_cl_flow_ctrl_creds(&dev->wd_cl);\r\nif (ret < 0)\r\ngoto err;\r\nif (ret && mei_hbuf_acquire(dev)) {\r\nret = mei_wd_send(dev);\r\nif (ret)\r\ngoto err;\r\ndev->wd_pending = false;\r\n} else {\r\ndev->wd_pending = true;\r\n}\r\nmutex_unlock(&dev->device_lock);\r\nret = wait_event_timeout(dev->wait_stop_wd,\r\ndev->wd_state == MEI_WD_IDLE,\r\nmsecs_to_jiffies(MEI_WD_STOP_TIMEOUT));\r\nmutex_lock(&dev->device_lock);\r\nif (dev->wd_state != MEI_WD_IDLE) {\r\nret = -ETIME;\r\ndev_warn(&dev->pdev->dev,\r\n"wd: stop failed to complete ret=%d.\n", ret);\r\ngoto err;\r\n}\r\ndev_dbg(&dev->pdev->dev, "wd: stop completed after %u msec\n",\r\nMEI_WD_STOP_TIMEOUT - jiffies_to_msecs(ret));\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int mei_wd_ops_start(struct watchdog_device *wd_dev)\r\n{\r\nint err = -ENODEV;\r\nstruct mei_device *dev;\r\ndev = watchdog_get_drvdata(wd_dev);\r\nif (!dev)\r\nreturn -ENODEV;\r\nmutex_lock(&dev->device_lock);\r\nif (dev->dev_state != MEI_DEV_ENABLED) {\r\ndev_dbg(&dev->pdev->dev,\r\n"wd: dev_state != MEI_DEV_ENABLED dev_state = %s\n",\r\nmei_dev_state_str(dev->dev_state));\r\ngoto end_unlock;\r\n}\r\nif (dev->wd_cl.state != MEI_FILE_CONNECTED) {\r\ndev_dbg(&dev->pdev->dev,\r\n"MEI Driver is not connected to Watchdog Client\n");\r\ngoto end_unlock;\r\n}\r\nmei_wd_set_start_timeout(dev, dev->wd_timeout);\r\nerr = 0;\r\nend_unlock:\r\nmutex_unlock(&dev->device_lock);\r\nreturn err;\r\n}\r\nstatic int mei_wd_ops_stop(struct watchdog_device *wd_dev)\r\n{\r\nstruct mei_device *dev;\r\ndev = watchdog_get_drvdata(wd_dev);\r\nif (!dev)\r\nreturn -ENODEV;\r\nmutex_lock(&dev->device_lock);\r\nmei_wd_stop(dev);\r\nmutex_unlock(&dev->device_lock);\r\nreturn 0;\r\n}\r\nstatic int mei_wd_ops_ping(struct watchdog_device *wd_dev)\r\n{\r\nstruct mei_device *dev;\r\nint ret;\r\ndev = watchdog_get_drvdata(wd_dev);\r\nif (!dev)\r\nreturn -ENODEV;\r\nmutex_lock(&dev->device_lock);\r\nif (dev->wd_cl.state != MEI_FILE_CONNECTED) {\r\ndev_err(&dev->pdev->dev, "wd: not connected.\n");\r\nret = -ENODEV;\r\ngoto end;\r\n}\r\ndev->wd_state = MEI_WD_RUNNING;\r\nret = mei_cl_flow_ctrl_creds(&dev->wd_cl);\r\nif (ret < 0)\r\ngoto end;\r\nif (ret && mei_hbuf_acquire(dev)) {\r\ndev_dbg(&dev->pdev->dev, "wd: sending ping\n");\r\nret = mei_wd_send(dev);\r\nif (ret)\r\ngoto end;\r\ndev->wd_pending = false;\r\n} else {\r\ndev->wd_pending = true;\r\n}\r\nend:\r\nmutex_unlock(&dev->device_lock);\r\nreturn ret;\r\n}\r\nstatic int mei_wd_ops_set_timeout(struct watchdog_device *wd_dev,\r\nunsigned int timeout)\r\n{\r\nstruct mei_device *dev;\r\ndev = watchdog_get_drvdata(wd_dev);\r\nif (!dev)\r\nreturn -ENODEV;\r\nif (timeout < MEI_WD_MIN_TIMEOUT || timeout > MEI_WD_MAX_TIMEOUT)\r\nreturn -EINVAL;\r\nmutex_lock(&dev->device_lock);\r\ndev->wd_timeout = timeout;\r\nwd_dev->timeout = timeout;\r\nmei_wd_set_start_timeout(dev, dev->wd_timeout);\r\nmutex_unlock(&dev->device_lock);\r\nreturn 0;\r\n}\r\nint mei_watchdog_register(struct mei_device *dev)\r\n{\r\nint ret;\r\nmutex_unlock(&dev->device_lock);\r\nret = watchdog_register_device(&amt_wd_dev);\r\nmutex_lock(&dev->device_lock);\r\nif (ret) {\r\ndev_err(&dev->pdev->dev, "wd: unable to register watchdog device = %d.\n",\r\nret);\r\nreturn ret;\r\n}\r\ndev_dbg(&dev->pdev->dev,\r\n"wd: successfully register watchdog interface.\n");\r\nwatchdog_set_drvdata(&amt_wd_dev, dev);\r\nreturn 0;\r\n}\r\nvoid mei_watchdog_unregister(struct mei_device *dev)\r\n{\r\nif (watchdog_get_drvdata(&amt_wd_dev) == NULL)\r\nreturn;\r\nwatchdog_set_drvdata(&amt_wd_dev, NULL);\r\nwatchdog_unregister_device(&amt_wd_dev);\r\n}
