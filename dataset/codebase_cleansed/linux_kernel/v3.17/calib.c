int iwl_send_calib_results(struct iwl_priv *priv)\r\n{\r\nstruct iwl_host_cmd hcmd = {\r\n.id = REPLY_PHY_CALIBRATION_CMD,\r\n};\r\nstruct iwl_calib_result *res;\r\nlist_for_each_entry(res, &priv->calib_results, list) {\r\nint ret;\r\nhcmd.len[0] = res->cmd_len;\r\nhcmd.data[0] = &res->hdr;\r\nhcmd.dataflags[0] = IWL_HCMD_DFL_NOCOPY;\r\nret = iwl_dvm_send_cmd(priv, &hcmd);\r\nif (ret) {\r\nIWL_ERR(priv, "Error %d on calib cmd %d\n",\r\nret, res->hdr.op_code);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint iwl_calib_set(struct iwl_priv *priv,\r\nconst struct iwl_calib_hdr *cmd, int len)\r\n{\r\nstruct iwl_calib_result *res, *tmp;\r\nres = kmalloc(sizeof(*res) + len - sizeof(struct iwl_calib_hdr),\r\nGFP_ATOMIC);\r\nif (!res)\r\nreturn -ENOMEM;\r\nmemcpy(&res->hdr, cmd, len);\r\nres->cmd_len = len;\r\nlist_for_each_entry(tmp, &priv->calib_results, list) {\r\nif (tmp->hdr.op_code == res->hdr.op_code) {\r\nlist_replace(&tmp->list, &res->list);\r\nkfree(tmp);\r\nreturn 0;\r\n}\r\n}\r\nlist_add_tail(&res->list, &priv->calib_results);\r\nreturn 0;\r\n}\r\nvoid iwl_calib_free_results(struct iwl_priv *priv)\r\n{\r\nstruct iwl_calib_result *res, *tmp;\r\nlist_for_each_entry_safe(res, tmp, &priv->calib_results, list) {\r\nlist_del(&res->list);\r\nkfree(res);\r\n}\r\n}\r\nstatic int iwl_sens_energy_cck(struct iwl_priv *priv,\r\nu32 norm_fa,\r\nu32 rx_enable_time,\r\nstruct statistics_general_data *rx_info)\r\n{\r\nu32 max_nrg_cck = 0;\r\nint i = 0;\r\nu8 max_silence_rssi = 0;\r\nu32 silence_ref = 0;\r\nu8 silence_rssi_a = 0;\r\nu8 silence_rssi_b = 0;\r\nu8 silence_rssi_c = 0;\r\nu32 val;\r\nu32 false_alarms = norm_fa * 200 * 1024;\r\nu32 max_false_alarms = MAX_FA_CCK * rx_enable_time;\r\nu32 min_false_alarms = MIN_FA_CCK * rx_enable_time;\r\nstruct iwl_sensitivity_data *data = NULL;\r\nconst struct iwl_sensitivity_ranges *ranges = priv->hw_params.sens;\r\ndata = &(priv->sensitivity_data);\r\ndata->nrg_auto_corr_silence_diff = 0;\r\nsilence_rssi_a = (u8)((rx_info->beacon_silence_rssi_a &\r\nALL_BAND_FILTER) >> 8);\r\nsilence_rssi_b = (u8)((rx_info->beacon_silence_rssi_b &\r\nALL_BAND_FILTER) >> 8);\r\nsilence_rssi_c = (u8)((rx_info->beacon_silence_rssi_c &\r\nALL_BAND_FILTER) >> 8);\r\nval = max(silence_rssi_b, silence_rssi_c);\r\nmax_silence_rssi = max(silence_rssi_a, (u8) val);\r\ndata->nrg_silence_rssi[data->nrg_silence_idx] = max_silence_rssi;\r\ndata->nrg_silence_idx++;\r\nif (data->nrg_silence_idx >= NRG_NUM_PREV_STAT_L)\r\ndata->nrg_silence_idx = 0;\r\nfor (i = 0; i < NRG_NUM_PREV_STAT_L; i++) {\r\nval = data->nrg_silence_rssi[i];\r\nsilence_ref = max(silence_ref, val);\r\n}\r\nIWL_DEBUG_CALIB(priv, "silence a %u, b %u, c %u, 20-bcn max %u\n",\r\nsilence_rssi_a, silence_rssi_b, silence_rssi_c,\r\nsilence_ref);\r\ni = data->nrg_energy_idx;\r\nval = min(rx_info->beacon_energy_b, rx_info->beacon_energy_c);\r\ndata->nrg_value[i] = min(rx_info->beacon_energy_a, val);\r\ndata->nrg_energy_idx++;\r\nif (data->nrg_energy_idx >= 10)\r\ndata->nrg_energy_idx = 0;\r\nmax_nrg_cck = data->nrg_value[0];\r\nfor (i = 1; i < 10; i++)\r\nmax_nrg_cck = (u32) max(max_nrg_cck, (data->nrg_value[i]));\r\nmax_nrg_cck += 6;\r\nIWL_DEBUG_CALIB(priv, "rx energy a %u, b %u, c %u, 10-bcn max/min %u\n",\r\nrx_info->beacon_energy_a, rx_info->beacon_energy_b,\r\nrx_info->beacon_energy_c, max_nrg_cck - 6);\r\nif (false_alarms < min_false_alarms)\r\ndata->num_in_cck_no_fa++;\r\nelse\r\ndata->num_in_cck_no_fa = 0;\r\nIWL_DEBUG_CALIB(priv, "consecutive bcns with few false alarms = %u\n",\r\ndata->num_in_cck_no_fa);\r\nif ((false_alarms > max_false_alarms) &&\r\n(data->auto_corr_cck > AUTO_CORR_MAX_TH_CCK)) {\r\nIWL_DEBUG_CALIB(priv, "norm FA %u > max FA %u\n",\r\nfalse_alarms, max_false_alarms);\r\nIWL_DEBUG_CALIB(priv, "... reducing sensitivity\n");\r\ndata->nrg_curr_state = IWL_FA_TOO_MANY;\r\ndata->nrg_silence_ref = silence_ref;\r\ndata->nrg_th_cck = data->nrg_th_cck - NRG_STEP_CCK;\r\n} else if (false_alarms < min_false_alarms) {\r\ndata->nrg_curr_state = IWL_FA_TOO_FEW;\r\ndata->nrg_auto_corr_silence_diff = (s32)data->nrg_silence_ref -\r\n(s32)silence_ref;\r\nIWL_DEBUG_CALIB(priv, "norm FA %u < min FA %u, silence diff %d\n",\r\nfalse_alarms, min_false_alarms,\r\ndata->nrg_auto_corr_silence_diff);\r\nif ((data->nrg_prev_state != IWL_FA_TOO_MANY) &&\r\n((data->nrg_auto_corr_silence_diff > NRG_DIFF) ||\r\n(data->num_in_cck_no_fa > MAX_NUMBER_CCK_NO_FA))) {\r\nIWL_DEBUG_CALIB(priv, "... increasing sensitivity\n");\r\nval = data->nrg_th_cck + NRG_STEP_CCK;\r\ndata->nrg_th_cck = min((u32)ranges->min_nrg_cck, val);\r\n} else {\r\nIWL_DEBUG_CALIB(priv, "... but not changing sensitivity\n");\r\n}\r\n} else {\r\nIWL_DEBUG_CALIB(priv, " FA in safe zone\n");\r\ndata->nrg_curr_state = IWL_FA_GOOD_RANGE;\r\ndata->nrg_silence_ref = silence_ref;\r\nif (IWL_FA_TOO_MANY == data->nrg_prev_state) {\r\nIWL_DEBUG_CALIB(priv, "... increasing margin\n");\r\nif (data->nrg_th_cck > (max_nrg_cck + NRG_MARGIN))\r\ndata->nrg_th_cck -= NRG_MARGIN;\r\nelse\r\ndata->nrg_th_cck = max_nrg_cck;\r\n}\r\n}\r\ndata->nrg_th_cck = max(max_nrg_cck, data->nrg_th_cck);\r\nIWL_DEBUG_CALIB(priv, "new nrg_th_cck %u\n", data->nrg_th_cck);\r\ndata->nrg_prev_state = data->nrg_curr_state;\r\nif (false_alarms > min_false_alarms) {\r\nif (data->auto_corr_cck < AUTO_CORR_MAX_TH_CCK)\r\ndata->auto_corr_cck = AUTO_CORR_MAX_TH_CCK + 1;\r\nelse {\r\nval = data->auto_corr_cck + AUTO_CORR_STEP_CCK;\r\ndata->auto_corr_cck =\r\nmin((u32)ranges->auto_corr_max_cck, val);\r\n}\r\nval = data->auto_corr_cck_mrc + AUTO_CORR_STEP_CCK;\r\ndata->auto_corr_cck_mrc =\r\nmin((u32)ranges->auto_corr_max_cck_mrc, val);\r\n} else if ((false_alarms < min_false_alarms) &&\r\n((data->nrg_auto_corr_silence_diff > NRG_DIFF) ||\r\n(data->num_in_cck_no_fa > MAX_NUMBER_CCK_NO_FA))) {\r\nval = data->auto_corr_cck - AUTO_CORR_STEP_CCK;\r\ndata->auto_corr_cck =\r\nmax((u32)ranges->auto_corr_min_cck, val);\r\nval = data->auto_corr_cck_mrc - AUTO_CORR_STEP_CCK;\r\ndata->auto_corr_cck_mrc =\r\nmax((u32)ranges->auto_corr_min_cck_mrc, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iwl_sens_auto_corr_ofdm(struct iwl_priv *priv,\r\nu32 norm_fa,\r\nu32 rx_enable_time)\r\n{\r\nu32 val;\r\nu32 false_alarms = norm_fa * 200 * 1024;\r\nu32 max_false_alarms = MAX_FA_OFDM * rx_enable_time;\r\nu32 min_false_alarms = MIN_FA_OFDM * rx_enable_time;\r\nstruct iwl_sensitivity_data *data = NULL;\r\nconst struct iwl_sensitivity_ranges *ranges = priv->hw_params.sens;\r\ndata = &(priv->sensitivity_data);\r\nif (false_alarms > max_false_alarms) {\r\nIWL_DEBUG_CALIB(priv, "norm FA %u > max FA %u)\n",\r\nfalse_alarms, max_false_alarms);\r\nval = data->auto_corr_ofdm + AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm =\r\nmin((u32)ranges->auto_corr_max_ofdm, val);\r\nval = data->auto_corr_ofdm_mrc + AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm_mrc =\r\nmin((u32)ranges->auto_corr_max_ofdm_mrc, val);\r\nval = data->auto_corr_ofdm_x1 + AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm_x1 =\r\nmin((u32)ranges->auto_corr_max_ofdm_x1, val);\r\nval = data->auto_corr_ofdm_mrc_x1 + AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm_mrc_x1 =\r\nmin((u32)ranges->auto_corr_max_ofdm_mrc_x1, val);\r\n}\r\nelse if (false_alarms < min_false_alarms) {\r\nIWL_DEBUG_CALIB(priv, "norm FA %u < min FA %u\n",\r\nfalse_alarms, min_false_alarms);\r\nval = data->auto_corr_ofdm - AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm =\r\nmax((u32)ranges->auto_corr_min_ofdm, val);\r\nval = data->auto_corr_ofdm_mrc - AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm_mrc =\r\nmax((u32)ranges->auto_corr_min_ofdm_mrc, val);\r\nval = data->auto_corr_ofdm_x1 - AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm_x1 =\r\nmax((u32)ranges->auto_corr_min_ofdm_x1, val);\r\nval = data->auto_corr_ofdm_mrc_x1 - AUTO_CORR_STEP_OFDM;\r\ndata->auto_corr_ofdm_mrc_x1 =\r\nmax((u32)ranges->auto_corr_min_ofdm_mrc_x1, val);\r\n} else {\r\nIWL_DEBUG_CALIB(priv, "min FA %u < norm FA %u < max FA %u OK\n",\r\nmin_false_alarms, false_alarms, max_false_alarms);\r\n}\r\nreturn 0;\r\n}\r\nstatic void iwl_prepare_legacy_sensitivity_tbl(struct iwl_priv *priv,\r\nstruct iwl_sensitivity_data *data,\r\n__le16 *tbl)\r\n{\r\ntbl[HD_AUTO_CORR32_X4_TH_ADD_MIN_INDEX] =\r\ncpu_to_le16((u16)data->auto_corr_ofdm);\r\ntbl[HD_AUTO_CORR32_X4_TH_ADD_MIN_MRC_INDEX] =\r\ncpu_to_le16((u16)data->auto_corr_ofdm_mrc);\r\ntbl[HD_AUTO_CORR32_X1_TH_ADD_MIN_INDEX] =\r\ncpu_to_le16((u16)data->auto_corr_ofdm_x1);\r\ntbl[HD_AUTO_CORR32_X1_TH_ADD_MIN_MRC_INDEX] =\r\ncpu_to_le16((u16)data->auto_corr_ofdm_mrc_x1);\r\ntbl[HD_AUTO_CORR40_X4_TH_ADD_MIN_INDEX] =\r\ncpu_to_le16((u16)data->auto_corr_cck);\r\ntbl[HD_AUTO_CORR40_X4_TH_ADD_MIN_MRC_INDEX] =\r\ncpu_to_le16((u16)data->auto_corr_cck_mrc);\r\ntbl[HD_MIN_ENERGY_CCK_DET_INDEX] =\r\ncpu_to_le16((u16)data->nrg_th_cck);\r\ntbl[HD_MIN_ENERGY_OFDM_DET_INDEX] =\r\ncpu_to_le16((u16)data->nrg_th_ofdm);\r\ntbl[HD_BARKER_CORR_TH_ADD_MIN_INDEX] =\r\ncpu_to_le16(data->barker_corr_th_min);\r\ntbl[HD_BARKER_CORR_TH_ADD_MIN_MRC_INDEX] =\r\ncpu_to_le16(data->barker_corr_th_min_mrc);\r\ntbl[HD_OFDM_ENERGY_TH_IN_INDEX] =\r\ncpu_to_le16(data->nrg_th_cca);\r\nIWL_DEBUG_CALIB(priv, "ofdm: ac %u mrc %u x1 %u mrc_x1 %u thresh %u\n",\r\ndata->auto_corr_ofdm, data->auto_corr_ofdm_mrc,\r\ndata->auto_corr_ofdm_x1, data->auto_corr_ofdm_mrc_x1,\r\ndata->nrg_th_ofdm);\r\nIWL_DEBUG_CALIB(priv, "cck: ac %u mrc %u thresh %u\n",\r\ndata->auto_corr_cck, data->auto_corr_cck_mrc,\r\ndata->nrg_th_cck);\r\n}\r\nstatic int iwl_sensitivity_write(struct iwl_priv *priv)\r\n{\r\nstruct iwl_sensitivity_cmd cmd;\r\nstruct iwl_sensitivity_data *data = NULL;\r\nstruct iwl_host_cmd cmd_out = {\r\n.id = SENSITIVITY_CMD,\r\n.len = { sizeof(struct iwl_sensitivity_cmd), },\r\n.flags = CMD_ASYNC,\r\n.data = { &cmd, },\r\n};\r\ndata = &(priv->sensitivity_data);\r\nmemset(&cmd, 0, sizeof(cmd));\r\niwl_prepare_legacy_sensitivity_tbl(priv, data, &cmd.table[0]);\r\ncmd.control = SENSITIVITY_CMD_CONTROL_WORK_TABLE;\r\nif (!memcmp(&cmd.table[0], &(priv->sensitivity_tbl[0]),\r\nsizeof(u16)*HD_TABLE_SIZE)) {\r\nIWL_DEBUG_CALIB(priv, "No change in SENSITIVITY_CMD\n");\r\nreturn 0;\r\n}\r\nmemcpy(&(priv->sensitivity_tbl[0]), &(cmd.table[0]),\r\nsizeof(u16)*HD_TABLE_SIZE);\r\nreturn iwl_dvm_send_cmd(priv, &cmd_out);\r\n}\r\nstatic int iwl_enhance_sensitivity_write(struct iwl_priv *priv)\r\n{\r\nstruct iwl_enhance_sensitivity_cmd cmd;\r\nstruct iwl_sensitivity_data *data = NULL;\r\nstruct iwl_host_cmd cmd_out = {\r\n.id = SENSITIVITY_CMD,\r\n.len = { sizeof(struct iwl_enhance_sensitivity_cmd), },\r\n.flags = CMD_ASYNC,\r\n.data = { &cmd, },\r\n};\r\ndata = &(priv->sensitivity_data);\r\nmemset(&cmd, 0, sizeof(cmd));\r\niwl_prepare_legacy_sensitivity_tbl(priv, data, &cmd.enhance_table[0]);\r\nif (priv->lib->hd_v2) {\r\ncmd.enhance_table[HD_INA_NON_SQUARE_DET_OFDM_INDEX] =\r\nHD_INA_NON_SQUARE_DET_OFDM_DATA_V2;\r\ncmd.enhance_table[HD_INA_NON_SQUARE_DET_CCK_INDEX] =\r\nHD_INA_NON_SQUARE_DET_CCK_DATA_V2;\r\ncmd.enhance_table[HD_CORR_11_INSTEAD_OF_CORR_9_EN_INDEX] =\r\nHD_CORR_11_INSTEAD_OF_CORR_9_EN_DATA_V2;\r\ncmd.enhance_table[HD_OFDM_NON_SQUARE_DET_SLOPE_MRC_INDEX] =\r\nHD_OFDM_NON_SQUARE_DET_SLOPE_MRC_DATA_V2;\r\ncmd.enhance_table[HD_OFDM_NON_SQUARE_DET_INTERCEPT_MRC_INDEX] =\r\nHD_OFDM_NON_SQUARE_DET_INTERCEPT_MRC_DATA_V2;\r\ncmd.enhance_table[HD_OFDM_NON_SQUARE_DET_SLOPE_INDEX] =\r\nHD_OFDM_NON_SQUARE_DET_SLOPE_DATA_V2;\r\ncmd.enhance_table[HD_OFDM_NON_SQUARE_DET_INTERCEPT_INDEX] =\r\nHD_OFDM_NON_SQUARE_DET_INTERCEPT_DATA_V2;\r\ncmd.enhance_table[HD_CCK_NON_SQUARE_DET_SLOPE_MRC_INDEX] =\r\nHD_CCK_NON_SQUARE_DET_SLOPE_MRC_DATA_V2;\r\ncmd.enhance_table[HD_CCK_NON_SQUARE_DET_INTERCEPT_MRC_INDEX] =\r\nHD_CCK_NON_SQUARE_DET_INTERCEPT_MRC_DATA_V2;\r\ncmd.enhance_table[HD_CCK_NON_SQUARE_DET_SLOPE_INDEX] =\r\nHD_CCK_NON_SQUARE_DET_SLOPE_DATA_V2;\r\ncmd.enhance_table[HD_CCK_NON_SQUARE_DET_INTERCEPT_INDEX] =\r\nHD_CCK_NON_SQUARE_DET_INTERCEPT_DATA_V2;\r\n} else {\r\ncmd.enhance_table[HD_INA_NON_SQUARE_DET_OFDM_INDEX] =\r\nHD_INA_NON_SQUARE_DET_OFDM_DATA_V1;\r\ncmd.enhance_table[HD_INA_NON_SQUARE_DET_CCK_INDEX] =\r\nHD_INA_NON_SQUARE_DET_CCK_DATA_V1;\r\ncmd.enhance_table[HD_CORR_11_INSTEAD_OF_CORR_9_EN_INDEX] =\r\nHD_CORR_11_INSTEAD_OF_CORR_9_EN_DATA_V1;\r\ncmd.enhance_table[HD_OFDM_NON_SQUARE_DET_SLOPE_MRC_INDEX] =\r\nHD_OFDM_NON_SQUARE_DET_SLOPE_MRC_DATA_V1;\r\ncmd.enhance_table[HD_OFDM_NON_SQUARE_DET_INTERCEPT_MRC_INDEX] =\r\nHD_OFDM_NON_SQUARE_DET_INTERCEPT_MRC_DATA_V1;\r\ncmd.enhance_table[HD_OFDM_NON_SQUARE_DET_SLOPE_INDEX] =\r\nHD_OFDM_NON_SQUARE_DET_SLOPE_DATA_V1;\r\ncmd.enhance_table[HD_OFDM_NON_SQUARE_DET_INTERCEPT_INDEX] =\r\nHD_OFDM_NON_SQUARE_DET_INTERCEPT_DATA_V1;\r\ncmd.enhance_table[HD_CCK_NON_SQUARE_DET_SLOPE_MRC_INDEX] =\r\nHD_CCK_NON_SQUARE_DET_SLOPE_MRC_DATA_V1;\r\ncmd.enhance_table[HD_CCK_NON_SQUARE_DET_INTERCEPT_MRC_INDEX] =\r\nHD_CCK_NON_SQUARE_DET_INTERCEPT_MRC_DATA_V1;\r\ncmd.enhance_table[HD_CCK_NON_SQUARE_DET_SLOPE_INDEX] =\r\nHD_CCK_NON_SQUARE_DET_SLOPE_DATA_V1;\r\ncmd.enhance_table[HD_CCK_NON_SQUARE_DET_INTERCEPT_INDEX] =\r\nHD_CCK_NON_SQUARE_DET_INTERCEPT_DATA_V1;\r\n}\r\ncmd.control = SENSITIVITY_CMD_CONTROL_WORK_TABLE;\r\nif (!memcmp(&cmd.enhance_table[0], &(priv->sensitivity_tbl[0]),\r\nsizeof(u16)*HD_TABLE_SIZE) &&\r\n!memcmp(&cmd.enhance_table[HD_INA_NON_SQUARE_DET_OFDM_INDEX],\r\n&(priv->enhance_sensitivity_tbl[0]),\r\nsizeof(u16)*ENHANCE_HD_TABLE_ENTRIES)) {\r\nIWL_DEBUG_CALIB(priv, "No change in SENSITIVITY_CMD\n");\r\nreturn 0;\r\n}\r\nmemcpy(&(priv->sensitivity_tbl[0]), &(cmd.enhance_table[0]),\r\nsizeof(u16)*HD_TABLE_SIZE);\r\nmemcpy(&(priv->enhance_sensitivity_tbl[0]),\r\n&(cmd.enhance_table[HD_INA_NON_SQUARE_DET_OFDM_INDEX]),\r\nsizeof(u16)*ENHANCE_HD_TABLE_ENTRIES);\r\nreturn iwl_dvm_send_cmd(priv, &cmd_out);\r\n}\r\nvoid iwl_init_sensitivity(struct iwl_priv *priv)\r\n{\r\nint ret = 0;\r\nint i;\r\nstruct iwl_sensitivity_data *data = NULL;\r\nconst struct iwl_sensitivity_ranges *ranges = priv->hw_params.sens;\r\nif (priv->calib_disabled & IWL_SENSITIVITY_CALIB_DISABLED)\r\nreturn;\r\nIWL_DEBUG_CALIB(priv, "Start iwl_init_sensitivity\n");\r\ndata = &(priv->sensitivity_data);\r\nif (ranges == NULL)\r\nreturn;\r\nmemset(data, 0, sizeof(struct iwl_sensitivity_data));\r\ndata->num_in_cck_no_fa = 0;\r\ndata->nrg_curr_state = IWL_FA_TOO_MANY;\r\ndata->nrg_prev_state = IWL_FA_TOO_MANY;\r\ndata->nrg_silence_ref = 0;\r\ndata->nrg_silence_idx = 0;\r\ndata->nrg_energy_idx = 0;\r\nfor (i = 0; i < 10; i++)\r\ndata->nrg_value[i] = 0;\r\nfor (i = 0; i < NRG_NUM_PREV_STAT_L; i++)\r\ndata->nrg_silence_rssi[i] = 0;\r\ndata->auto_corr_ofdm = ranges->auto_corr_min_ofdm;\r\ndata->auto_corr_ofdm_mrc = ranges->auto_corr_min_ofdm_mrc;\r\ndata->auto_corr_ofdm_x1 = ranges->auto_corr_min_ofdm_x1;\r\ndata->auto_corr_ofdm_mrc_x1 = ranges->auto_corr_min_ofdm_mrc_x1;\r\ndata->auto_corr_cck = AUTO_CORR_CCK_MIN_VAL_DEF;\r\ndata->auto_corr_cck_mrc = ranges->auto_corr_min_cck_mrc;\r\ndata->nrg_th_cck = ranges->nrg_th_cck;\r\ndata->nrg_th_ofdm = ranges->nrg_th_ofdm;\r\ndata->barker_corr_th_min = ranges->barker_corr_th_min;\r\ndata->barker_corr_th_min_mrc = ranges->barker_corr_th_min_mrc;\r\ndata->nrg_th_cca = ranges->nrg_th_cca;\r\ndata->last_bad_plcp_cnt_ofdm = 0;\r\ndata->last_fa_cnt_ofdm = 0;\r\ndata->last_bad_plcp_cnt_cck = 0;\r\ndata->last_fa_cnt_cck = 0;\r\nif (priv->fw->enhance_sensitivity_table)\r\nret |= iwl_enhance_sensitivity_write(priv);\r\nelse\r\nret |= iwl_sensitivity_write(priv);\r\nIWL_DEBUG_CALIB(priv, "<<return 0x%X\n", ret);\r\n}\r\nvoid iwl_sensitivity_calibration(struct iwl_priv *priv)\r\n{\r\nu32 rx_enable_time;\r\nu32 fa_cck;\r\nu32 fa_ofdm;\r\nu32 bad_plcp_cck;\r\nu32 bad_plcp_ofdm;\r\nu32 norm_fa_ofdm;\r\nu32 norm_fa_cck;\r\nstruct iwl_sensitivity_data *data = NULL;\r\nstruct statistics_rx_non_phy *rx_info;\r\nstruct statistics_rx_phy *ofdm, *cck;\r\nstruct statistics_general_data statis;\r\nif (priv->calib_disabled & IWL_SENSITIVITY_CALIB_DISABLED)\r\nreturn;\r\ndata = &(priv->sensitivity_data);\r\nif (!iwl_is_any_associated(priv)) {\r\nIWL_DEBUG_CALIB(priv, "<< - not associated\n");\r\nreturn;\r\n}\r\nspin_lock_bh(&priv->statistics.lock);\r\nrx_info = &priv->statistics.rx_non_phy;\r\nofdm = &priv->statistics.rx_ofdm;\r\ncck = &priv->statistics.rx_cck;\r\nif (rx_info->interference_data_flag != INTERFERENCE_DATA_AVAILABLE) {\r\nIWL_DEBUG_CALIB(priv, "<< invalid data.\n");\r\nspin_unlock_bh(&priv->statistics.lock);\r\nreturn;\r\n}\r\nrx_enable_time = le32_to_cpu(rx_info->channel_load);\r\nfa_cck = le32_to_cpu(cck->false_alarm_cnt);\r\nfa_ofdm = le32_to_cpu(ofdm->false_alarm_cnt);\r\nbad_plcp_cck = le32_to_cpu(cck->plcp_err);\r\nbad_plcp_ofdm = le32_to_cpu(ofdm->plcp_err);\r\nstatis.beacon_silence_rssi_a =\r\nle32_to_cpu(rx_info->beacon_silence_rssi_a);\r\nstatis.beacon_silence_rssi_b =\r\nle32_to_cpu(rx_info->beacon_silence_rssi_b);\r\nstatis.beacon_silence_rssi_c =\r\nle32_to_cpu(rx_info->beacon_silence_rssi_c);\r\nstatis.beacon_energy_a =\r\nle32_to_cpu(rx_info->beacon_energy_a);\r\nstatis.beacon_energy_b =\r\nle32_to_cpu(rx_info->beacon_energy_b);\r\nstatis.beacon_energy_c =\r\nle32_to_cpu(rx_info->beacon_energy_c);\r\nspin_unlock_bh(&priv->statistics.lock);\r\nIWL_DEBUG_CALIB(priv, "rx_enable_time = %u usecs\n", rx_enable_time);\r\nif (!rx_enable_time) {\r\nIWL_DEBUG_CALIB(priv, "<< RX Enable Time == 0!\n");\r\nreturn;\r\n}\r\nif (data->last_bad_plcp_cnt_cck > bad_plcp_cck)\r\ndata->last_bad_plcp_cnt_cck = bad_plcp_cck;\r\nelse {\r\nbad_plcp_cck -= data->last_bad_plcp_cnt_cck;\r\ndata->last_bad_plcp_cnt_cck += bad_plcp_cck;\r\n}\r\nif (data->last_bad_plcp_cnt_ofdm > bad_plcp_ofdm)\r\ndata->last_bad_plcp_cnt_ofdm = bad_plcp_ofdm;\r\nelse {\r\nbad_plcp_ofdm -= data->last_bad_plcp_cnt_ofdm;\r\ndata->last_bad_plcp_cnt_ofdm += bad_plcp_ofdm;\r\n}\r\nif (data->last_fa_cnt_ofdm > fa_ofdm)\r\ndata->last_fa_cnt_ofdm = fa_ofdm;\r\nelse {\r\nfa_ofdm -= data->last_fa_cnt_ofdm;\r\ndata->last_fa_cnt_ofdm += fa_ofdm;\r\n}\r\nif (data->last_fa_cnt_cck > fa_cck)\r\ndata->last_fa_cnt_cck = fa_cck;\r\nelse {\r\nfa_cck -= data->last_fa_cnt_cck;\r\ndata->last_fa_cnt_cck += fa_cck;\r\n}\r\nnorm_fa_ofdm = fa_ofdm + bad_plcp_ofdm;\r\nnorm_fa_cck = fa_cck + bad_plcp_cck;\r\nIWL_DEBUG_CALIB(priv, "cck: fa %u badp %u ofdm: fa %u badp %u\n", fa_cck,\r\nbad_plcp_cck, fa_ofdm, bad_plcp_ofdm);\r\niwl_sens_auto_corr_ofdm(priv, norm_fa_ofdm, rx_enable_time);\r\niwl_sens_energy_cck(priv, norm_fa_cck, rx_enable_time, &statis);\r\nif (priv->fw->enhance_sensitivity_table)\r\niwl_enhance_sensitivity_write(priv);\r\nelse\r\niwl_sensitivity_write(priv);\r\n}\r\nstatic inline u8 find_first_chain(u8 mask)\r\n{\r\nif (mask & ANT_A)\r\nreturn CHAIN_A;\r\nif (mask & ANT_B)\r\nreturn CHAIN_B;\r\nreturn CHAIN_C;\r\n}\r\nstatic void iwl_find_disconn_antenna(struct iwl_priv *priv, u32* average_sig,\r\nstruct iwl_chain_noise_data *data)\r\n{\r\nu32 active_chains = 0;\r\nu32 max_average_sig;\r\nu16 max_average_sig_antenna_i;\r\nu8 num_tx_chains;\r\nu8 first_chain;\r\nu16 i = 0;\r\naverage_sig[0] = data->chain_signal_a / IWL_CAL_NUM_BEACONS;\r\naverage_sig[1] = data->chain_signal_b / IWL_CAL_NUM_BEACONS;\r\naverage_sig[2] = data->chain_signal_c / IWL_CAL_NUM_BEACONS;\r\nif (average_sig[0] >= average_sig[1]) {\r\nmax_average_sig = average_sig[0];\r\nmax_average_sig_antenna_i = 0;\r\nactive_chains = (1 << max_average_sig_antenna_i);\r\n} else {\r\nmax_average_sig = average_sig[1];\r\nmax_average_sig_antenna_i = 1;\r\nactive_chains = (1 << max_average_sig_antenna_i);\r\n}\r\nif (average_sig[2] >= max_average_sig) {\r\nmax_average_sig = average_sig[2];\r\nmax_average_sig_antenna_i = 2;\r\nactive_chains = (1 << max_average_sig_antenna_i);\r\n}\r\nIWL_DEBUG_CALIB(priv, "average_sig: a %d b %d c %d\n",\r\naverage_sig[0], average_sig[1], average_sig[2]);\r\nIWL_DEBUG_CALIB(priv, "max_average_sig = %d, antenna %d\n",\r\nmax_average_sig, max_average_sig_antenna_i);\r\nfor (i = 0; i < NUM_RX_CHAINS; i++) {\r\nif (i != max_average_sig_antenna_i) {\r\ns32 rssi_delta = (max_average_sig - average_sig[i]);\r\nif (rssi_delta > MAXIMUM_ALLOWED_PATHLOSS)\r\ndata->disconn_array[i] = 1;\r\nelse\r\nactive_chains |= (1 << i);\r\nIWL_DEBUG_CALIB(priv, "i = %d rssiDelta = %d "\r\n"disconn_array[i] = %d\n",\r\ni, rssi_delta, data->disconn_array[i]);\r\n}\r\n}\r\nactive_chains &= priv->nvm_data->valid_rx_ant;\r\nnum_tx_chains = 0;\r\nfor (i = 0; i < NUM_RX_CHAINS; i++) {\r\nu8 ant_msk = (1 << i);\r\nif (!(priv->nvm_data->valid_tx_ant & ant_msk))\r\ncontinue;\r\nnum_tx_chains++;\r\nif (data->disconn_array[i] == 0)\r\nbreak;\r\nif (num_tx_chains == priv->hw_params.tx_chains_num &&\r\ndata->disconn_array[i]) {\r\nfirst_chain =\r\nfind_first_chain(priv->nvm_data->valid_tx_ant);\r\ndata->disconn_array[first_chain] = 0;\r\nactive_chains |= BIT(first_chain);\r\nIWL_DEBUG_CALIB(priv,\r\n"All Tx chains are disconnected W/A - declare %d as connected\n",\r\nfirst_chain);\r\nbreak;\r\n}\r\n}\r\nif (active_chains != priv->nvm_data->valid_rx_ant &&\r\nactive_chains != priv->chain_noise_data.active_chains)\r\nIWL_DEBUG_CALIB(priv,\r\n"Detected that not all antennas are connected! "\r\n"Connected: %#x, valid: %#x.\n",\r\nactive_chains,\r\npriv->nvm_data->valid_rx_ant);\r\ndata->active_chains = active_chains;\r\nIWL_DEBUG_CALIB(priv, "active_chains (bitwise) = 0x%x\n",\r\nactive_chains);\r\n}\r\nstatic void iwlagn_gain_computation(struct iwl_priv *priv,\r\nu32 average_noise[NUM_RX_CHAINS],\r\nu8 default_chain)\r\n{\r\nint i;\r\ns32 delta_g;\r\nstruct iwl_chain_noise_data *data = &priv->chain_noise_data;\r\nfor (i = default_chain + 1; i < NUM_RX_CHAINS; i++) {\r\nif ((data->disconn_array[i])) {\r\ndata->delta_gain_code[i] = 0;\r\ncontinue;\r\n}\r\ndelta_g = (priv->lib->chain_noise_scale *\r\n((s32)average_noise[default_chain] -\r\n(s32)average_noise[i])) / 1500;\r\ndata->delta_gain_code[i] =\r\nmin(abs(delta_g),\r\n(long) CHAIN_NOISE_MAX_DELTA_GAIN_CODE);\r\nif (delta_g < 0)\r\ndata->delta_gain_code[i] |= (1 << 2);\r\n}\r\nIWL_DEBUG_CALIB(priv, "Delta gains: ANT_B = %d ANT_C = %d\n",\r\ndata->delta_gain_code[1], data->delta_gain_code[2]);\r\nif (!data->radio_write) {\r\nstruct iwl_calib_chain_noise_gain_cmd cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\niwl_set_calib_hdr(&cmd.hdr,\r\npriv->phy_calib_chain_noise_gain_cmd);\r\ncmd.delta_gain_1 = data->delta_gain_code[1];\r\ncmd.delta_gain_2 = data->delta_gain_code[2];\r\niwl_dvm_send_cmd_pdu(priv, REPLY_PHY_CALIBRATION_CMD,\r\nCMD_ASYNC, sizeof(cmd), &cmd);\r\ndata->radio_write = 1;\r\ndata->state = IWL_CHAIN_NOISE_CALIBRATED;\r\n}\r\n}\r\nvoid iwl_chain_noise_calibration(struct iwl_priv *priv)\r\n{\r\nstruct iwl_chain_noise_data *data = NULL;\r\nu32 chain_noise_a;\r\nu32 chain_noise_b;\r\nu32 chain_noise_c;\r\nu32 chain_sig_a;\r\nu32 chain_sig_b;\r\nu32 chain_sig_c;\r\nu32 average_sig[NUM_RX_CHAINS] = {INITIALIZATION_VALUE};\r\nu32 average_noise[NUM_RX_CHAINS] = {INITIALIZATION_VALUE};\r\nu32 min_average_noise = MIN_AVERAGE_NOISE_MAX_VALUE;\r\nu16 min_average_noise_antenna_i = INITIALIZATION_VALUE;\r\nu16 i = 0;\r\nu16 rxon_chnum = INITIALIZATION_VALUE;\r\nu16 stat_chnum = INITIALIZATION_VALUE;\r\nu8 rxon_band24;\r\nu8 stat_band24;\r\nstruct statistics_rx_non_phy *rx_info;\r\nstruct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];\r\nif (priv->calib_disabled & IWL_CHAIN_NOISE_CALIB_DISABLED)\r\nreturn;\r\ndata = &(priv->chain_noise_data);\r\nif (data->state != IWL_CHAIN_NOISE_ACCUMULATE) {\r\nif (data->state == IWL_CHAIN_NOISE_ALIVE)\r\nIWL_DEBUG_CALIB(priv, "Wait for noise calib reset\n");\r\nreturn;\r\n}\r\nspin_lock_bh(&priv->statistics.lock);\r\nrx_info = &priv->statistics.rx_non_phy;\r\nif (rx_info->interference_data_flag != INTERFERENCE_DATA_AVAILABLE) {\r\nIWL_DEBUG_CALIB(priv, " << Interference data unavailable\n");\r\nspin_unlock_bh(&priv->statistics.lock);\r\nreturn;\r\n}\r\nrxon_band24 = !!(ctx->staging.flags & RXON_FLG_BAND_24G_MSK);\r\nrxon_chnum = le16_to_cpu(ctx->staging.channel);\r\nstat_band24 =\r\n!!(priv->statistics.flag & STATISTICS_REPLY_FLG_BAND_24G_MSK);\r\nstat_chnum = le32_to_cpu(priv->statistics.flag) >> 16;\r\nif ((rxon_chnum != stat_chnum) || (rxon_band24 != stat_band24)) {\r\nIWL_DEBUG_CALIB(priv, "Stats not from chan=%d, band24=%d\n",\r\nrxon_chnum, rxon_band24);\r\nspin_unlock_bh(&priv->statistics.lock);\r\nreturn;\r\n}\r\nchain_noise_a = le32_to_cpu(rx_info->beacon_silence_rssi_a) &\r\nIN_BAND_FILTER;\r\nchain_noise_b = le32_to_cpu(rx_info->beacon_silence_rssi_b) &\r\nIN_BAND_FILTER;\r\nchain_noise_c = le32_to_cpu(rx_info->beacon_silence_rssi_c) &\r\nIN_BAND_FILTER;\r\nchain_sig_a = le32_to_cpu(rx_info->beacon_rssi_a) & IN_BAND_FILTER;\r\nchain_sig_b = le32_to_cpu(rx_info->beacon_rssi_b) & IN_BAND_FILTER;\r\nchain_sig_c = le32_to_cpu(rx_info->beacon_rssi_c) & IN_BAND_FILTER;\r\nspin_unlock_bh(&priv->statistics.lock);\r\ndata->beacon_count++;\r\ndata->chain_noise_a = (chain_noise_a + data->chain_noise_a);\r\ndata->chain_noise_b = (chain_noise_b + data->chain_noise_b);\r\ndata->chain_noise_c = (chain_noise_c + data->chain_noise_c);\r\ndata->chain_signal_a = (chain_sig_a + data->chain_signal_a);\r\ndata->chain_signal_b = (chain_sig_b + data->chain_signal_b);\r\ndata->chain_signal_c = (chain_sig_c + data->chain_signal_c);\r\nIWL_DEBUG_CALIB(priv, "chan=%d, band24=%d, beacon=%d\n",\r\nrxon_chnum, rxon_band24, data->beacon_count);\r\nIWL_DEBUG_CALIB(priv, "chain_sig: a %d b %d c %d\n",\r\nchain_sig_a, chain_sig_b, chain_sig_c);\r\nIWL_DEBUG_CALIB(priv, "chain_noise: a %d b %d c %d\n",\r\nchain_noise_a, chain_noise_b, chain_noise_c);\r\nif (data->beacon_count != IWL_CAL_NUM_BEACONS)\r\nreturn;\r\nif (priv->lib->bt_params &&\r\npriv->lib->bt_params->advanced_bt_coexist) {\r\ndata->active_chains = priv->nvm_data->valid_rx_ant;\r\nfor (i = 0; i < NUM_RX_CHAINS; i++)\r\nif (!(data->active_chains & (1<<i)))\r\ndata->disconn_array[i] = 1;\r\n} else\r\niwl_find_disconn_antenna(priv, average_sig, data);\r\naverage_noise[0] = data->chain_noise_a / IWL_CAL_NUM_BEACONS;\r\naverage_noise[1] = data->chain_noise_b / IWL_CAL_NUM_BEACONS;\r\naverage_noise[2] = data->chain_noise_c / IWL_CAL_NUM_BEACONS;\r\nfor (i = 0; i < NUM_RX_CHAINS; i++) {\r\nif (!(data->disconn_array[i]) &&\r\n(average_noise[i] <= min_average_noise)) {\r\nmin_average_noise = average_noise[i];\r\nmin_average_noise_antenna_i = i;\r\n}\r\n}\r\nIWL_DEBUG_CALIB(priv, "average_noise: a %d b %d c %d\n",\r\naverage_noise[0], average_noise[1],\r\naverage_noise[2]);\r\nIWL_DEBUG_CALIB(priv, "min_average_noise = %d, antenna %d\n",\r\nmin_average_noise, min_average_noise_antenna_i);\r\niwlagn_gain_computation(\r\npriv, average_noise,\r\nfind_first_chain(priv->nvm_data->valid_rx_ant));\r\niwl_update_chain_flags(priv);\r\ndata->state = IWL_CHAIN_NOISE_DONE;\r\niwl_power_update_mode(priv, false);\r\n}\r\nvoid iwl_reset_run_time_calib(struct iwl_priv *priv)\r\n{\r\nint i;\r\nmemset(&(priv->sensitivity_data), 0,\r\nsizeof(struct iwl_sensitivity_data));\r\nmemset(&(priv->chain_noise_data), 0,\r\nsizeof(struct iwl_chain_noise_data));\r\nfor (i = 0; i < NUM_RX_CHAINS; i++)\r\npriv->chain_noise_data.delta_gain_code[i] =\r\nCHAIN_NOISE_DELTA_GAIN_INIT_VAL;\r\niwl_send_statistics_request(priv, CMD_ASYNC, true);\r\n}
