static int get_ramp_delay(int ramp_delay)\r\n{\r\nunsigned char cnt = 0;\r\nramp_delay /= 6250;\r\nwhile (true) {\r\nramp_delay = ramp_delay >> 1;\r\nif (ramp_delay == 0)\r\nbreak;\r\ncnt++;\r\n}\r\nif (cnt > 3)\r\ncnt = 3;\r\nreturn cnt;\r\n}\r\nstatic int s2mpa01_regulator_set_voltage_time_sel(struct regulator_dev *rdev,\r\nunsigned int old_selector,\r\nunsigned int new_selector)\r\n{\r\nstruct s2mpa01_info *s2mpa01 = rdev_get_drvdata(rdev);\r\nunsigned int ramp_delay = 0;\r\nint old_volt, new_volt;\r\nswitch (rdev_get_id(rdev)) {\r\ncase S2MPA01_BUCK2:\r\ncase S2MPA01_BUCK4:\r\nramp_delay = s2mpa01->ramp_delay24;\r\nbreak;\r\ncase S2MPA01_BUCK3:\r\nramp_delay = s2mpa01->ramp_delay3;\r\nbreak;\r\ncase S2MPA01_BUCK5:\r\nramp_delay = s2mpa01->ramp_delay5;\r\nbreak;\r\ncase S2MPA01_BUCK1:\r\ncase S2MPA01_BUCK6:\r\nramp_delay = s2mpa01->ramp_delay16;\r\nbreak;\r\ncase S2MPA01_BUCK7:\r\nramp_delay = s2mpa01->ramp_delay7;\r\nbreak;\r\ncase S2MPA01_BUCK8:\r\ncase S2MPA01_BUCK9:\r\ncase S2MPA01_BUCK10:\r\nramp_delay = s2mpa01->ramp_delay8910;\r\nbreak;\r\n}\r\nif (ramp_delay == 0)\r\nramp_delay = rdev->desc->ramp_delay;\r\nold_volt = rdev->desc->min_uV + (rdev->desc->uV_step * old_selector);\r\nnew_volt = rdev->desc->min_uV + (rdev->desc->uV_step * new_selector);\r\nreturn DIV_ROUND_UP(abs(new_volt - old_volt), ramp_delay);\r\n}\r\nstatic int s2mpa01_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay)\r\n{\r\nstruct s2mpa01_info *s2mpa01 = rdev_get_drvdata(rdev);\r\nunsigned int ramp_val, ramp_shift, ramp_reg = S2MPA01_REG_RAMP2;\r\nunsigned int ramp_enable = 1, enable_shift = 0;\r\nint ret;\r\nswitch (rdev_get_id(rdev)) {\r\ncase S2MPA01_BUCK1:\r\nenable_shift = S2MPA01_BUCK1_RAMP_EN_SHIFT;\r\nif (!ramp_delay) {\r\nramp_enable = 0;\r\nbreak;\r\n}\r\nif (ramp_delay > s2mpa01->ramp_delay16)\r\ns2mpa01->ramp_delay16 = ramp_delay;\r\nelse\r\nramp_delay = s2mpa01->ramp_delay16;\r\nramp_shift = S2MPA01_BUCK16_RAMP_SHIFT;\r\nbreak;\r\ncase S2MPA01_BUCK2:\r\nenable_shift = S2MPA01_BUCK2_RAMP_EN_SHIFT;\r\nif (!ramp_delay) {\r\nramp_enable = 0;\r\nbreak;\r\n}\r\nif (ramp_delay > s2mpa01->ramp_delay24)\r\ns2mpa01->ramp_delay24 = ramp_delay;\r\nelse\r\nramp_delay = s2mpa01->ramp_delay24;\r\nramp_shift = S2MPA01_BUCK24_RAMP_SHIFT;\r\nramp_reg = S2MPA01_REG_RAMP1;\r\nbreak;\r\ncase S2MPA01_BUCK3:\r\nenable_shift = S2MPA01_BUCK3_RAMP_EN_SHIFT;\r\nif (!ramp_delay) {\r\nramp_enable = 0;\r\nbreak;\r\n}\r\ns2mpa01->ramp_delay3 = ramp_delay;\r\nramp_shift = S2MPA01_BUCK3_RAMP_SHIFT;\r\nramp_reg = S2MPA01_REG_RAMP1;\r\nbreak;\r\ncase S2MPA01_BUCK4:\r\nenable_shift = S2MPA01_BUCK4_RAMP_EN_SHIFT;\r\nif (!ramp_delay) {\r\nramp_enable = 0;\r\nbreak;\r\n}\r\nif (ramp_delay > s2mpa01->ramp_delay24)\r\ns2mpa01->ramp_delay24 = ramp_delay;\r\nelse\r\nramp_delay = s2mpa01->ramp_delay24;\r\nramp_shift = S2MPA01_BUCK24_RAMP_SHIFT;\r\nramp_reg = S2MPA01_REG_RAMP1;\r\nbreak;\r\ncase S2MPA01_BUCK5:\r\ns2mpa01->ramp_delay5 = ramp_delay;\r\nramp_shift = S2MPA01_BUCK5_RAMP_SHIFT;\r\nbreak;\r\ncase S2MPA01_BUCK6:\r\nif (ramp_delay > s2mpa01->ramp_delay16)\r\ns2mpa01->ramp_delay16 = ramp_delay;\r\nelse\r\nramp_delay = s2mpa01->ramp_delay16;\r\nramp_shift = S2MPA01_BUCK16_RAMP_SHIFT;\r\nbreak;\r\ncase S2MPA01_BUCK7:\r\ns2mpa01->ramp_delay7 = ramp_delay;\r\nramp_shift = S2MPA01_BUCK7_RAMP_SHIFT;\r\nbreak;\r\ncase S2MPA01_BUCK8:\r\ncase S2MPA01_BUCK9:\r\ncase S2MPA01_BUCK10:\r\nif (ramp_delay > s2mpa01->ramp_delay8910)\r\ns2mpa01->ramp_delay8910 = ramp_delay;\r\nelse\r\nramp_delay = s2mpa01->ramp_delay8910;\r\nramp_shift = S2MPA01_BUCK8910_RAMP_SHIFT;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (!ramp_enable)\r\ngoto ramp_disable;\r\nif (rdev_get_id(rdev) >= S2MPA01_BUCK1 &&\r\nrdev_get_id(rdev) <= S2MPA01_BUCK4) {\r\nret = regmap_update_bits(rdev->regmap, S2MPA01_REG_RAMP1,\r\n1 << enable_shift, 1 << enable_shift);\r\nif (ret) {\r\ndev_err(&rdev->dev, "failed to enable ramp rate\n");\r\nreturn ret;\r\n}\r\n}\r\nramp_val = get_ramp_delay(ramp_delay);\r\nreturn regmap_update_bits(rdev->regmap, ramp_reg, 0x3 << ramp_shift,\r\nramp_val << ramp_shift);\r\nramp_disable:\r\nreturn regmap_update_bits(rdev->regmap, S2MPA01_REG_RAMP1,\r\n1 << enable_shift, 0);\r\n}\r\nstatic int s2mpa01_pmic_probe(struct platform_device *pdev)\r\n{\r\nstruct sec_pmic_dev *iodev = dev_get_drvdata(pdev->dev.parent);\r\nstruct sec_platform_data *pdata = dev_get_platdata(iodev->dev);\r\nstruct of_regulator_match rdata[S2MPA01_REGULATOR_MAX];\r\nstruct device_node *reg_np = NULL;\r\nstruct regulator_config config = { };\r\nstruct s2mpa01_info *s2mpa01;\r\nint i;\r\ns2mpa01 = devm_kzalloc(&pdev->dev, sizeof(*s2mpa01), GFP_KERNEL);\r\nif (!s2mpa01)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < S2MPA01_REGULATOR_CNT; i++)\r\nrdata[i].name = regulators[i].name;\r\nif (iodev->dev->of_node) {\r\nreg_np = of_get_child_by_name(iodev->dev->of_node,\r\n"regulators");\r\nif (!reg_np) {\r\ndev_err(&pdev->dev,\r\n"could not find regulators sub-node\n");\r\nreturn -EINVAL;\r\n}\r\nof_regulator_match(&pdev->dev, reg_np, rdata,\r\nS2MPA01_REGULATOR_MAX);\r\nof_node_put(reg_np);\r\n}\r\nplatform_set_drvdata(pdev, s2mpa01);\r\nconfig.dev = &pdev->dev;\r\nconfig.regmap = iodev->regmap_pmic;\r\nconfig.driver_data = s2mpa01;\r\nfor (i = 0; i < S2MPA01_REGULATOR_MAX; i++) {\r\nstruct regulator_dev *rdev;\r\nif (pdata)\r\nconfig.init_data = pdata->regulators[i].initdata;\r\nelse\r\nconfig.init_data = rdata[i].init_data;\r\nif (reg_np)\r\nconfig.of_node = rdata[i].of_node;\r\nrdev = devm_regulator_register(&pdev->dev,\r\n&regulators[i], &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&pdev->dev, "regulator init failed for %d\n",\r\ni);\r\nreturn PTR_ERR(rdev);\r\n}\r\n}\r\nreturn 0;\r\n}
