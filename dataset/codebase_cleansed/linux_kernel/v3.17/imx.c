static inline unsigned uts_reg(struct imx_port *sport)\r\n{\r\nreturn sport->devdata->uts_reg;\r\n}\r\nstatic inline int is_imx1_uart(struct imx_port *sport)\r\n{\r\nreturn sport->devdata->devtype == IMX1_UART;\r\n}\r\nstatic inline int is_imx21_uart(struct imx_port *sport)\r\n{\r\nreturn sport->devdata->devtype == IMX21_UART;\r\n}\r\nstatic inline int is_imx6q_uart(struct imx_port *sport)\r\n{\r\nreturn sport->devdata->devtype == IMX6Q_UART;\r\n}\r\nstatic void imx_port_ucrs_save(struct uart_port *port,\r\nstruct imx_port_ucrs *ucr)\r\n{\r\nucr->ucr1 = readl(port->membase + UCR1);\r\nucr->ucr2 = readl(port->membase + UCR2);\r\nucr->ucr3 = readl(port->membase + UCR3);\r\n}\r\nstatic void imx_port_ucrs_restore(struct uart_port *port,\r\nstruct imx_port_ucrs *ucr)\r\n{\r\nwritel(ucr->ucr1, port->membase + UCR1);\r\nwritel(ucr->ucr2, port->membase + UCR2);\r\nwritel(ucr->ucr3, port->membase + UCR3);\r\n}\r\nstatic void imx_mctrl_check(struct imx_port *sport)\r\n{\r\nunsigned int status, changed;\r\nstatus = sport->port.ops->get_mctrl(&sport->port);\r\nchanged = status ^ sport->old_status;\r\nif (changed == 0)\r\nreturn;\r\nsport->old_status = status;\r\nif (changed & TIOCM_RI)\r\nsport->port.icount.rng++;\r\nif (changed & TIOCM_DSR)\r\nsport->port.icount.dsr++;\r\nif (changed & TIOCM_CAR)\r\nuart_handle_dcd_change(&sport->port, status & TIOCM_CAR);\r\nif (changed & TIOCM_CTS)\r\nuart_handle_cts_change(&sport->port, status & TIOCM_CTS);\r\nwake_up_interruptible(&sport->port.state->port.delta_msr_wait);\r\n}\r\nstatic void imx_timeout(unsigned long data)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)data;\r\nunsigned long flags;\r\nif (sport->port.state) {\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nimx_mctrl_check(sport);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nmod_timer(&sport->timer, jiffies + MCTRL_TIMEOUT);\r\n}\r\n}\r\nstatic void imx_stop_tx(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long temp;\r\nif (USE_IRDA(sport)) {\r\nint n = 256;\r\nwhile ((--n > 0) &&\r\n!(readl(sport->port.membase + USR2) & USR2_TXDC)) {\r\nudelay(5);\r\nbarrier();\r\n}\r\nudelay(sport->trcv_delay);\r\nif (readl(sport->port.membase + USR2) & USR2_TXDC) {\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp &= ~(UCR1_TXMPTYEN | UCR1_TRDYEN);\r\nwritel(temp, sport->port.membase + UCR1);\r\ntemp = readl(sport->port.membase + UCR4);\r\ntemp &= ~(UCR4_TCEN);\r\nwritel(temp, sport->port.membase + UCR4);\r\nwhile (readl(sport->port.membase + URXD0) &\r\nURXD_CHARRDY)\r\nbarrier();\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp |= UCR1_RRDYEN;\r\nwritel(temp, sport->port.membase + UCR1);\r\ntemp = readl(sport->port.membase + UCR4);\r\ntemp |= UCR4_DREN;\r\nwritel(temp, sport->port.membase + UCR4);\r\n}\r\nreturn;\r\n}\r\nif (sport->dma_is_enabled && sport->dma_is_txing)\r\nreturn;\r\ntemp = readl(sport->port.membase + UCR1);\r\nwritel(temp & ~UCR1_TXMPTYEN, sport->port.membase + UCR1);\r\n}\r\nstatic void imx_stop_rx(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long temp;\r\nif (sport->dma_is_enabled && sport->dma_is_rxing)\r\nreturn;\r\ntemp = readl(sport->port.membase + UCR2);\r\nwritel(temp & ~UCR2_RXEN, sport->port.membase + UCR2);\r\ntemp = readl(sport->port.membase + UCR1);\r\nwritel(temp & ~UCR1_RRDYEN, sport->port.membase + UCR1);\r\n}\r\nstatic void imx_enable_ms(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nmod_timer(&sport->timer, jiffies);\r\n}\r\nstatic inline void imx_transmit_buffer(struct imx_port *sport)\r\n{\r\nstruct circ_buf *xmit = &sport->port.state->xmit;\r\nwhile (!uart_circ_empty(xmit) &&\r\n!(readl(sport->port.membase + uts_reg(sport))\r\n& UTS_TXFULL)) {\r\nwritel(xmit->buf[xmit->tail], sport->port.membase + URTX0);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nsport->port.icount.tx++;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&sport->port);\r\nif (uart_circ_empty(xmit))\r\nimx_stop_tx(&sport->port);\r\n}\r\nstatic void dma_tx_callback(void *data)\r\n{\r\nstruct imx_port *sport = data;\r\nstruct scatterlist *sgl = &sport->tx_sgl[0];\r\nstruct circ_buf *xmit = &sport->port.state->xmit;\r\nunsigned long flags;\r\ndma_unmap_sg(sport->port.dev, sgl, sport->dma_tx_nents, DMA_TO_DEVICE);\r\nsport->dma_is_txing = 0;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nxmit->tail = (xmit->tail + sport->tx_bytes) & (UART_XMIT_SIZE - 1);\r\nsport->port.icount.tx += sport->tx_bytes;\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\ndev_dbg(sport->port.dev, "we finish the TX DMA.\n");\r\nuart_write_wakeup(&sport->port);\r\nif (waitqueue_active(&sport->dma_wait)) {\r\nwake_up(&sport->dma_wait);\r\ndev_dbg(sport->port.dev, "exit in %s.\n", __func__);\r\nreturn;\r\n}\r\n}\r\nstatic void imx_dma_tx(struct imx_port *sport)\r\n{\r\nstruct circ_buf *xmit = &sport->port.state->xmit;\r\nstruct scatterlist *sgl = sport->tx_sgl;\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct dma_chan *chan = sport->dma_chan_tx;\r\nstruct device *dev = sport->port.dev;\r\nenum dma_status status;\r\nint ret;\r\nstatus = dmaengine_tx_status(chan, (dma_cookie_t)0, NULL);\r\nif (DMA_IN_PROGRESS == status)\r\nreturn;\r\nsport->tx_bytes = uart_circ_chars_pending(xmit);\r\nif (xmit->tail > xmit->head && xmit->head > 0) {\r\nsport->dma_tx_nents = 2;\r\nsg_init_table(sgl, 2);\r\nsg_set_buf(sgl, xmit->buf + xmit->tail,\r\nUART_XMIT_SIZE - xmit->tail);\r\nsg_set_buf(sgl + 1, xmit->buf, xmit->head);\r\n} else {\r\nsport->dma_tx_nents = 1;\r\nsg_init_one(sgl, xmit->buf + xmit->tail, sport->tx_bytes);\r\n}\r\nret = dma_map_sg(dev, sgl, sport->dma_tx_nents, DMA_TO_DEVICE);\r\nif (ret == 0) {\r\ndev_err(dev, "DMA mapping error for TX.\n");\r\nreturn;\r\n}\r\ndesc = dmaengine_prep_slave_sg(chan, sgl, sport->dma_tx_nents,\r\nDMA_MEM_TO_DEV, DMA_PREP_INTERRUPT);\r\nif (!desc) {\r\ndev_err(dev, "We cannot prepare for the TX slave dma!\n");\r\nreturn;\r\n}\r\ndesc->callback = dma_tx_callback;\r\ndesc->callback_param = sport;\r\ndev_dbg(dev, "TX: prepare to send %lu bytes by DMA.\n",\r\nuart_circ_chars_pending(xmit));\r\nsport->dma_is_txing = 1;\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(chan);\r\nreturn;\r\n}\r\nstatic void imx_start_tx(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long temp;\r\nif (uart_circ_empty(&port->state->xmit))\r\nreturn;\r\nif (USE_IRDA(sport)) {\r\ntemp = readl(sport->port.membase + UCR4);\r\ntemp &= ~(UCR4_DREN);\r\nwritel(temp, sport->port.membase + UCR4);\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp &= ~(UCR1_RRDYEN);\r\nwritel(temp, sport->port.membase + UCR1);\r\n}\r\ntemp = readl(sport->port.membase + USR2);\r\nwritel(temp | USR2_ORE, sport->port.membase + USR2);\r\ntemp = readl(sport->port.membase + UCR4);\r\ntemp |= UCR4_OREN;\r\nwritel(temp, sport->port.membase + UCR4);\r\nif (!sport->dma_is_enabled) {\r\ntemp = readl(sport->port.membase + UCR1);\r\nwritel(temp | UCR1_TXMPTYEN, sport->port.membase + UCR1);\r\n}\r\nif (USE_IRDA(sport)) {\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp |= UCR1_TRDYEN;\r\nwritel(temp, sport->port.membase + UCR1);\r\ntemp = readl(sport->port.membase + UCR4);\r\ntemp |= UCR4_TCEN;\r\nwritel(temp, sport->port.membase + UCR4);\r\n}\r\nif (sport->dma_is_enabled) {\r\nimx_dma_tx(sport);\r\nreturn;\r\n}\r\nif (readl(sport->port.membase + uts_reg(sport)) & UTS_TXEMPTY)\r\nimx_transmit_buffer(sport);\r\n}\r\nstatic irqreturn_t imx_rtsint(int irq, void *dev_id)\r\n{\r\nstruct imx_port *sport = dev_id;\r\nunsigned int val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nwritel(USR1_RTSD, sport->port.membase + USR1);\r\nval = readl(sport->port.membase + USR1) & USR1_RTSS;\r\nuart_handle_cts_change(&sport->port, !!val);\r\nwake_up_interruptible(&sport->port.state->port.delta_msr_wait);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t imx_txint(int irq, void *dev_id)\r\n{\r\nstruct imx_port *sport = dev_id;\r\nstruct circ_buf *xmit = &sport->port.state->xmit;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nif (sport->port.x_char) {\r\nwritel(sport->port.x_char, sport->port.membase + URTX0);\r\ngoto out;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&sport->port)) {\r\nimx_stop_tx(&sport->port);\r\ngoto out;\r\n}\r\nimx_transmit_buffer(sport);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&sport->port);\r\nout:\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t imx_rxint(int irq, void *dev_id)\r\n{\r\nstruct imx_port *sport = dev_id;\r\nunsigned int rx, flg, ignored = 0;\r\nstruct tty_port *port = &sport->port.state->port;\r\nunsigned long flags, temp;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nwhile (readl(sport->port.membase + USR2) & USR2_RDR) {\r\nflg = TTY_NORMAL;\r\nsport->port.icount.rx++;\r\nrx = readl(sport->port.membase + URXD0);\r\ntemp = readl(sport->port.membase + USR2);\r\nif (temp & USR2_BRCD) {\r\nwritel(USR2_BRCD, sport->port.membase + USR2);\r\nif (uart_handle_break(&sport->port))\r\ncontinue;\r\n}\r\nif (uart_handle_sysrq_char(&sport->port, (unsigned char)rx))\r\ncontinue;\r\nif (unlikely(rx & URXD_ERR)) {\r\nif (rx & URXD_BRK)\r\nsport->port.icount.brk++;\r\nelse if (rx & URXD_PRERR)\r\nsport->port.icount.parity++;\r\nelse if (rx & URXD_FRMERR)\r\nsport->port.icount.frame++;\r\nif (rx & URXD_OVRRUN)\r\nsport->port.icount.overrun++;\r\nif (rx & sport->port.ignore_status_mask) {\r\nif (++ignored > 100)\r\ngoto out;\r\ncontinue;\r\n}\r\nrx &= sport->port.read_status_mask;\r\nif (rx & URXD_BRK)\r\nflg = TTY_BREAK;\r\nelse if (rx & URXD_PRERR)\r\nflg = TTY_PARITY;\r\nelse if (rx & URXD_FRMERR)\r\nflg = TTY_FRAME;\r\nif (rx & URXD_OVRRUN)\r\nflg = TTY_OVERRUN;\r\n#ifdef SUPPORT_SYSRQ\r\nsport->port.sysrq = 0;\r\n#endif\r\n}\r\ntty_insert_flip_char(port, rx, flg);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\ntty_flip_buffer_push(port);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void imx_dma_rxint(struct imx_port *sport)\r\n{\r\nunsigned long temp;\r\ntemp = readl(sport->port.membase + USR2);\r\nif ((temp & USR2_RDR) && !sport->dma_is_rxing) {\r\nsport->dma_is_rxing = 1;\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp &= ~(UCR1_RRDYEN);\r\nwritel(temp, sport->port.membase + UCR1);\r\nstart_rx_dma(sport);\r\n}\r\n}\r\nstatic irqreturn_t imx_int(int irq, void *dev_id)\r\n{\r\nstruct imx_port *sport = dev_id;\r\nunsigned int sts;\r\nunsigned int sts2;\r\nsts = readl(sport->port.membase + USR1);\r\nif (sts & USR1_RRDY) {\r\nif (sport->dma_is_enabled)\r\nimx_dma_rxint(sport);\r\nelse\r\nimx_rxint(irq, dev_id);\r\n}\r\nif (sts & USR1_TRDY &&\r\nreadl(sport->port.membase + UCR1) & UCR1_TXMPTYEN)\r\nimx_txint(irq, dev_id);\r\nif (sts & USR1_RTSD)\r\nimx_rtsint(irq, dev_id);\r\nif (sts & USR1_AWAKE)\r\nwritel(USR1_AWAKE, sport->port.membase + USR1);\r\nsts2 = readl(sport->port.membase + USR2);\r\nif (sts2 & USR2_ORE) {\r\ndev_err(sport->port.dev, "Rx FIFO overrun\n");\r\nsport->port.icount.overrun++;\r\nwritel(sts2 | USR2_ORE, sport->port.membase + USR2);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int imx_tx_empty(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned int ret;\r\nret = (readl(sport->port.membase + USR2) & USR2_TXDC) ? TIOCSER_TEMT : 0;\r\nif (sport->dma_is_enabled && sport->dma_is_txing)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic unsigned int imx_get_mctrl(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned int tmp = TIOCM_DSR | TIOCM_CAR;\r\nif (readl(sport->port.membase + USR1) & USR1_RTSS)\r\ntmp |= TIOCM_CTS;\r\nif (readl(sport->port.membase + UCR2) & UCR2_CTS)\r\ntmp |= TIOCM_RTS;\r\nif (readl(sport->port.membase + uts_reg(sport)) & UTS_LOOP)\r\ntmp |= TIOCM_LOOP;\r\nreturn tmp;\r\n}\r\nstatic void imx_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long temp;\r\ntemp = readl(sport->port.membase + UCR2) & ~UCR2_CTS;\r\nif (mctrl & TIOCM_RTS)\r\nif (!sport->dma_is_enabled)\r\ntemp |= UCR2_CTS;\r\nwritel(temp, sport->port.membase + UCR2);\r\ntemp = readl(sport->port.membase + uts_reg(sport)) & ~UTS_LOOP;\r\nif (mctrl & TIOCM_LOOP)\r\ntemp |= UTS_LOOP;\r\nwritel(temp, sport->port.membase + uts_reg(sport));\r\n}\r\nstatic void imx_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long flags, temp;\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\ntemp = readl(sport->port.membase + UCR1) & ~UCR1_SNDBRK;\r\nif (break_state != 0)\r\ntemp |= UCR1_SNDBRK;\r\nwritel(temp, sport->port.membase + UCR1);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\n}\r\nstatic int imx_setup_ufcr(struct imx_port *sport, unsigned int mode)\r\n{\r\nunsigned int val;\r\nval = readl(sport->port.membase + UFCR) & (UFCR_RFDIV | UFCR_DCEDTE);\r\nval |= TXTL << UFCR_TXTL_SHF | RXTL;\r\nwritel(val, sport->port.membase + UFCR);\r\nreturn 0;\r\n}\r\nstatic void imx_rx_dma_done(struct imx_port *sport)\r\n{\r\nunsigned long temp;\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp |= UCR1_RRDYEN;\r\nwritel(temp, sport->port.membase + UCR1);\r\nsport->dma_is_rxing = 0;\r\nif (waitqueue_active(&sport->dma_wait))\r\nwake_up(&sport->dma_wait);\r\n}\r\nstatic void dma_rx_callback(void *data)\r\n{\r\nstruct imx_port *sport = data;\r\nstruct dma_chan *chan = sport->dma_chan_rx;\r\nstruct scatterlist *sgl = &sport->rx_sgl;\r\nstruct tty_port *port = &sport->port.state->port;\r\nstruct dma_tx_state state;\r\nenum dma_status status;\r\nunsigned int count;\r\ndma_unmap_sg(sport->port.dev, sgl, 1, DMA_FROM_DEVICE);\r\nstatus = dmaengine_tx_status(chan, (dma_cookie_t)0, &state);\r\ncount = RX_BUF_SIZE - state.residue;\r\ndev_dbg(sport->port.dev, "We get %d bytes.\n", count);\r\nif (count) {\r\ntty_insert_flip_string(port, sport->rx_buf, count);\r\ntty_flip_buffer_push(port);\r\nstart_rx_dma(sport);\r\n} else\r\nimx_rx_dma_done(sport);\r\n}\r\nstatic int start_rx_dma(struct imx_port *sport)\r\n{\r\nstruct scatterlist *sgl = &sport->rx_sgl;\r\nstruct dma_chan *chan = sport->dma_chan_rx;\r\nstruct device *dev = sport->port.dev;\r\nstruct dma_async_tx_descriptor *desc;\r\nint ret;\r\nsg_init_one(sgl, sport->rx_buf, RX_BUF_SIZE);\r\nret = dma_map_sg(dev, sgl, 1, DMA_FROM_DEVICE);\r\nif (ret == 0) {\r\ndev_err(dev, "DMA mapping error for RX.\n");\r\nreturn -EINVAL;\r\n}\r\ndesc = dmaengine_prep_slave_sg(chan, sgl, 1, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT);\r\nif (!desc) {\r\ndev_err(dev, "We cannot prepare for the RX slave dma!\n");\r\nreturn -EINVAL;\r\n}\r\ndesc->callback = dma_rx_callback;\r\ndesc->callback_param = sport;\r\ndev_dbg(dev, "RX: prepare for the DMA.\n");\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(chan);\r\nreturn 0;\r\n}\r\nstatic void imx_uart_dma_exit(struct imx_port *sport)\r\n{\r\nif (sport->dma_chan_rx) {\r\ndma_release_channel(sport->dma_chan_rx);\r\nsport->dma_chan_rx = NULL;\r\nkfree(sport->rx_buf);\r\nsport->rx_buf = NULL;\r\n}\r\nif (sport->dma_chan_tx) {\r\ndma_release_channel(sport->dma_chan_tx);\r\nsport->dma_chan_tx = NULL;\r\n}\r\nsport->dma_is_inited = 0;\r\n}\r\nstatic int imx_uart_dma_init(struct imx_port *sport)\r\n{\r\nstruct dma_slave_config slave_config = {};\r\nstruct device *dev = sport->port.dev;\r\nint ret;\r\nsport->dma_chan_rx = dma_request_slave_channel(dev, "rx");\r\nif (!sport->dma_chan_rx) {\r\ndev_dbg(dev, "cannot get the DMA channel.\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nslave_config.direction = DMA_DEV_TO_MEM;\r\nslave_config.src_addr = sport->port.mapbase + URXD0;\r\nslave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\nslave_config.src_maxburst = RXTL;\r\nret = dmaengine_slave_config(sport->dma_chan_rx, &slave_config);\r\nif (ret) {\r\ndev_err(dev, "error in RX dma configuration.\n");\r\ngoto err;\r\n}\r\nsport->rx_buf = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!sport->rx_buf) {\r\ndev_err(dev, "cannot alloc DMA buffer.\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nsport->dma_chan_tx = dma_request_slave_channel(dev, "tx");\r\nif (!sport->dma_chan_tx) {\r\ndev_err(dev, "cannot get the TX DMA channel!\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nslave_config.direction = DMA_MEM_TO_DEV;\r\nslave_config.dst_addr = sport->port.mapbase + URTX0;\r\nslave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\nslave_config.dst_maxburst = TXTL;\r\nret = dmaengine_slave_config(sport->dma_chan_tx, &slave_config);\r\nif (ret) {\r\ndev_err(dev, "error in TX dma configuration.");\r\ngoto err;\r\n}\r\nsport->dma_is_inited = 1;\r\nreturn 0;\r\nerr:\r\nimx_uart_dma_exit(sport);\r\nreturn ret;\r\n}\r\nstatic void imx_enable_dma(struct imx_port *sport)\r\n{\r\nunsigned long temp;\r\ninit_waitqueue_head(&sport->dma_wait);\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp |= UCR1_RDMAEN | UCR1_TDMAEN | UCR1_ATDMAEN |\r\nUCR1_ICD_REG(3);\r\nwritel(temp, sport->port.membase + UCR1);\r\ntemp = readl(sport->port.membase + UCR4);\r\ntemp |= UCR4_IDDMAEN;\r\nwritel(temp, sport->port.membase + UCR4);\r\nsport->dma_is_enabled = 1;\r\n}\r\nstatic void imx_disable_dma(struct imx_port *sport)\r\n{\r\nunsigned long temp;\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp &= ~(UCR1_RDMAEN | UCR1_TDMAEN | UCR1_ATDMAEN);\r\nwritel(temp, sport->port.membase + UCR1);\r\ntemp = readl(sport->port.membase + UCR2);\r\ntemp &= ~(UCR2_CTSC | UCR2_CTS);\r\nwritel(temp, sport->port.membase + UCR2);\r\ntemp = readl(sport->port.membase + UCR4);\r\ntemp &= ~UCR4_IDDMAEN;\r\nwritel(temp, sport->port.membase + UCR4);\r\nsport->dma_is_enabled = 0;\r\n}\r\nstatic int imx_startup(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nint retval, i;\r\nunsigned long flags, temp;\r\nretval = clk_prepare_enable(sport->clk_per);\r\nif (retval)\r\ngoto error_out1;\r\nretval = clk_prepare_enable(sport->clk_ipg);\r\nif (retval) {\r\nclk_disable_unprepare(sport->clk_per);\r\ngoto error_out1;\r\n}\r\nimx_setup_ufcr(sport, 0);\r\ntemp = readl(sport->port.membase + UCR4);\r\nif (USE_IRDA(sport))\r\ntemp |= UCR4_IRSC;\r\ntemp &= ~(UCR4_CTSTL_MASK << UCR4_CTSTL_SHF);\r\ntemp |= CTSTL << UCR4_CTSTL_SHF;\r\nwritel(temp & ~UCR4_DREN, sport->port.membase + UCR4);\r\ni = 100;\r\ntemp = readl(sport->port.membase + UCR2);\r\ntemp &= ~UCR2_SRST;\r\nwritel(temp, sport->port.membase + UCR2);\r\nwhile (!(readl(sport->port.membase + UCR2) & UCR2_SRST) && (--i > 0))\r\nudelay(1);\r\nif (sport->txirq > 0) {\r\nretval = request_irq(sport->rxirq, imx_rxint, 0,\r\ndev_name(port->dev), sport);\r\nif (retval)\r\ngoto error_out1;\r\nretval = request_irq(sport->txirq, imx_txint, 0,\r\ndev_name(port->dev), sport);\r\nif (retval)\r\ngoto error_out2;\r\nif (!USE_IRDA(sport)) {\r\nretval = request_irq(sport->rtsirq, imx_rtsint, 0,\r\ndev_name(port->dev), sport);\r\nif (retval)\r\ngoto error_out3;\r\n}\r\n} else {\r\nretval = request_irq(sport->port.irq, imx_int, 0,\r\ndev_name(port->dev), sport);\r\nif (retval) {\r\nfree_irq(sport->port.irq, sport);\r\ngoto error_out1;\r\n}\r\n}\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nwritel(USR1_RTSD, sport->port.membase + USR1);\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp |= UCR1_RRDYEN | UCR1_RTSDEN | UCR1_UARTEN;\r\nif (USE_IRDA(sport)) {\r\ntemp |= UCR1_IREN;\r\ntemp &= ~(UCR1_RTSDEN);\r\n}\r\nwritel(temp, sport->port.membase + UCR1);\r\ntemp = readl(sport->port.membase + UCR2);\r\ntemp |= (UCR2_RXEN | UCR2_TXEN);\r\nif (!sport->have_rtscts)\r\ntemp |= UCR2_IRTS;\r\nwritel(temp, sport->port.membase + UCR2);\r\nif (!is_imx1_uart(sport)) {\r\ntemp = readl(sport->port.membase + UCR3);\r\ntemp |= IMX21_UCR3_RXDMUXSEL | UCR3_ADNIMP;\r\nwritel(temp, sport->port.membase + UCR3);\r\n}\r\nif (USE_IRDA(sport)) {\r\ntemp = readl(sport->port.membase + UCR4);\r\nif (sport->irda_inv_rx)\r\ntemp |= UCR4_INVR;\r\nelse\r\ntemp &= ~(UCR4_INVR);\r\nwritel(temp | UCR4_DREN, sport->port.membase + UCR4);\r\ntemp = readl(sport->port.membase + UCR3);\r\nif (sport->irda_inv_tx)\r\ntemp |= UCR3_INVT;\r\nelse\r\ntemp &= ~(UCR3_INVT);\r\nwritel(temp, sport->port.membase + UCR3);\r\n}\r\nimx_enable_ms(&sport->port);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nif (USE_IRDA(sport)) {\r\nstruct imxuart_platform_data *pdata;\r\npdata = dev_get_platdata(sport->port.dev);\r\nsport->irda_inv_rx = pdata->irda_inv_rx;\r\nsport->irda_inv_tx = pdata->irda_inv_tx;\r\nsport->trcv_delay = pdata->transceiver_delay;\r\nif (pdata->irda_enable)\r\npdata->irda_enable(1);\r\n}\r\nreturn 0;\r\nerror_out3:\r\nif (sport->txirq)\r\nfree_irq(sport->txirq, sport);\r\nerror_out2:\r\nif (sport->rxirq)\r\nfree_irq(sport->rxirq, sport);\r\nerror_out1:\r\nreturn retval;\r\n}\r\nstatic void imx_shutdown(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long temp;\r\nunsigned long flags;\r\nif (sport->dma_is_enabled) {\r\nwait_event(sport->dma_wait,\r\n!sport->dma_is_rxing && !sport->dma_is_txing);\r\nimx_stop_rx(port);\r\nimx_disable_dma(sport);\r\nimx_uart_dma_exit(sport);\r\n}\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\ntemp = readl(sport->port.membase + UCR2);\r\ntemp &= ~(UCR2_TXEN);\r\nwritel(temp, sport->port.membase + UCR2);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nif (USE_IRDA(sport)) {\r\nstruct imxuart_platform_data *pdata;\r\npdata = dev_get_platdata(sport->port.dev);\r\nif (pdata->irda_enable)\r\npdata->irda_enable(0);\r\n}\r\ndel_timer_sync(&sport->timer);\r\nif (sport->txirq > 0) {\r\nif (!USE_IRDA(sport))\r\nfree_irq(sport->rtsirq, sport);\r\nfree_irq(sport->txirq, sport);\r\nfree_irq(sport->rxirq, sport);\r\n} else\r\nfree_irq(sport->port.irq, sport);\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\ntemp = readl(sport->port.membase + UCR1);\r\ntemp &= ~(UCR1_TXMPTYEN | UCR1_RRDYEN | UCR1_RTSDEN | UCR1_UARTEN);\r\nif (USE_IRDA(sport))\r\ntemp &= ~(UCR1_IREN);\r\nwritel(temp, sport->port.membase + UCR1);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nclk_disable_unprepare(sport->clk_per);\r\nclk_disable_unprepare(sport->clk_ipg);\r\n}\r\nstatic void imx_flush_buffer(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nif (sport->dma_is_enabled) {\r\nsport->tx_bytes = 0;\r\ndmaengine_terminate_all(sport->dma_chan_tx);\r\n}\r\n}\r\nstatic void\r\nimx_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nunsigned long flags;\r\nunsigned int ucr2, old_ucr1, old_txrxen, baud, quot;\r\nunsigned int old_csize = old ? old->c_cflag & CSIZE : CS8;\r\nunsigned int div, ufcr;\r\nunsigned long num, denom;\r\nuint64_t tdiv64;\r\nif (0) {\r\ntermios->c_cflag &= ~(HUPCL | CRTSCTS | CMSPAR);\r\ntermios->c_cflag |= CLOCAL;\r\n}\r\nwhile ((termios->c_cflag & CSIZE) != CS7 &&\r\n(termios->c_cflag & CSIZE) != CS8) {\r\ntermios->c_cflag &= ~CSIZE;\r\ntermios->c_cflag |= old_csize;\r\nold_csize = CS8;\r\n}\r\nif ((termios->c_cflag & CSIZE) == CS8)\r\nucr2 = UCR2_WS | UCR2_SRST | UCR2_IRTS;\r\nelse\r\nucr2 = UCR2_SRST | UCR2_IRTS;\r\nif (termios->c_cflag & CRTSCTS) {\r\nif (sport->have_rtscts) {\r\nucr2 &= ~UCR2_IRTS;\r\nucr2 |= UCR2_CTSC;\r\nif (is_imx6q_uart(sport) && !uart_console(port)\r\n&& !sport->dma_is_inited)\r\nimx_uart_dma_init(sport);\r\n} else {\r\ntermios->c_cflag &= ~CRTSCTS;\r\n}\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nucr2 |= UCR2_STPB;\r\nif (termios->c_cflag & PARENB) {\r\nucr2 |= UCR2_PREN;\r\nif (termios->c_cflag & PARODD)\r\nucr2 |= UCR2_PROE;\r\n}\r\ndel_timer_sync(&sport->timer);\r\nbaud = uart_get_baud_rate(port, termios, old, 50, port->uartclk / 16);\r\nquot = uart_get_divisor(port, baud);\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nsport->port.read_status_mask = 0;\r\nif (termios->c_iflag & INPCK)\r\nsport->port.read_status_mask |= (URXD_FRMERR | URXD_PRERR);\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nsport->port.read_status_mask |= URXD_BRK;\r\nsport->port.ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nsport->port.ignore_status_mask |= URXD_PRERR;\r\nif (termios->c_iflag & IGNBRK) {\r\nsport->port.ignore_status_mask |= URXD_BRK;\r\nif (termios->c_iflag & IGNPAR)\r\nsport->port.ignore_status_mask |= URXD_OVRRUN;\r\n}\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nold_ucr1 = readl(sport->port.membase + UCR1);\r\nwritel(old_ucr1 & ~(UCR1_TXMPTYEN | UCR1_RRDYEN | UCR1_RTSDEN),\r\nsport->port.membase + UCR1);\r\nwhile (!(readl(sport->port.membase + USR2) & USR2_TXDC))\r\nbarrier();\r\nold_txrxen = readl(sport->port.membase + UCR2);\r\nwritel(old_txrxen & ~(UCR2_TXEN | UCR2_RXEN),\r\nsport->port.membase + UCR2);\r\nold_txrxen &= (UCR2_TXEN | UCR2_RXEN);\r\nif (USE_IRDA(sport)) {\r\ndiv = 1;\r\n} else {\r\ndiv = sport->port.uartclk / (baud * 16);\r\nif (baud == 38400 && quot != div)\r\nbaud = sport->port.uartclk / (quot * 16);\r\ndiv = sport->port.uartclk / (baud * 16);\r\nif (div > 7)\r\ndiv = 7;\r\nif (!div)\r\ndiv = 1;\r\n}\r\nrational_best_approximation(16 * div * baud, sport->port.uartclk,\r\n1 << 16, 1 << 16, &num, &denom);\r\ntdiv64 = sport->port.uartclk;\r\ntdiv64 *= num;\r\ndo_div(tdiv64, denom * 16 * div);\r\ntty_termios_encode_baud_rate(termios,\r\n(speed_t)tdiv64, (speed_t)tdiv64);\r\nnum -= 1;\r\ndenom -= 1;\r\nufcr = readl(sport->port.membase + UFCR);\r\nufcr = (ufcr & (~UFCR_RFDIV)) | UFCR_RFDIV_REG(div);\r\nif (sport->dte_mode)\r\nufcr |= UFCR_DCEDTE;\r\nwritel(ufcr, sport->port.membase + UFCR);\r\nwritel(num, sport->port.membase + UBIR);\r\nwritel(denom, sport->port.membase + UBMR);\r\nif (!is_imx1_uart(sport))\r\nwritel(sport->port.uartclk / div / 1000,\r\nsport->port.membase + IMX21_ONEMS);\r\nwritel(old_ucr1, sport->port.membase + UCR1);\r\nwritel(ucr2 | old_txrxen, sport->port.membase + UCR2);\r\nif (UART_ENABLE_MS(&sport->port, termios->c_cflag))\r\nimx_enable_ms(&sport->port);\r\nif (sport->dma_is_inited && !sport->dma_is_enabled)\r\nimx_enable_dma(sport);\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\n}\r\nstatic const char *imx_type(struct uart_port *port)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nreturn sport->port.type == PORT_IMX ? "IMX" : NULL;\r\n}\r\nstatic void imx_config_port(struct uart_port *port, int flags)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nif (flags & UART_CONFIG_TYPE)\r\nsport->port.type = PORT_IMX;\r\n}\r\nstatic int\r\nimx_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nint ret = 0;\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_IMX)\r\nret = -EINVAL;\r\nif (sport->port.irq != ser->irq)\r\nret = -EINVAL;\r\nif (ser->io_type != UPIO_MEM)\r\nret = -EINVAL;\r\nif (sport->port.uartclk / 16 != ser->baud_base)\r\nret = -EINVAL;\r\nif (sport->port.mapbase != (unsigned long)ser->iomem_base)\r\nret = -EINVAL;\r\nif (sport->port.iobase != ser->port)\r\nret = -EINVAL;\r\nif (ser->hub6 != 0)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int imx_poll_get_char(struct uart_port *port)\r\n{\r\nstruct imx_port_ucrs old_ucr;\r\nunsigned int status;\r\nunsigned char c;\r\nimx_port_ucrs_save(port, &old_ucr);\r\nwritel(UCR1_UARTEN, port->membase + UCR1);\r\nwritel(old_ucr.ucr2 & ~(UCR2_ATEN | UCR2_RTSEN | UCR2_ESCI),\r\nport->membase + UCR2);\r\nwritel(old_ucr.ucr3 & ~(UCR3_DCD | UCR3_RI | UCR3_DTREN),\r\nport->membase + UCR3);\r\ndo {\r\nstatus = readl(port->membase + USR2);\r\n} while (~status & USR2_RDR);\r\nc = readl(port->membase + URXD0);\r\nimx_port_ucrs_restore(port, &old_ucr);\r\nreturn c;\r\n}\r\nstatic void imx_poll_put_char(struct uart_port *port, unsigned char c)\r\n{\r\nstruct imx_port_ucrs old_ucr;\r\nunsigned int status;\r\nimx_port_ucrs_save(port, &old_ucr);\r\nwritel(UCR1_UARTEN, port->membase + UCR1);\r\nwritel(old_ucr.ucr2 & ~(UCR2_ATEN | UCR2_RTSEN | UCR2_ESCI),\r\nport->membase + UCR2);\r\nwritel(old_ucr.ucr3 & ~(UCR3_DCD | UCR3_RI | UCR3_DTREN),\r\nport->membase + UCR3);\r\ndo {\r\nstatus = readl(port->membase + USR1);\r\n} while (~status & USR1_TRDY);\r\nwritel(c, port->membase + URTX0);\r\ndo {\r\nstatus = readl(port->membase + USR2);\r\n} while (~status & USR2_TXDC);\r\nimx_port_ucrs_restore(port, &old_ucr);\r\n}\r\nstatic void imx_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct imx_port *sport = (struct imx_port *)port;\r\nwhile (readl(sport->port.membase + uts_reg(sport)) & UTS_TXFULL)\r\nbarrier();\r\nwritel(ch, sport->port.membase + URTX0);\r\n}\r\nstatic void\r\nimx_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct imx_port *sport = imx_ports[co->index];\r\nstruct imx_port_ucrs old_ucr;\r\nunsigned int ucr1;\r\nunsigned long flags = 0;\r\nint locked = 1;\r\nint retval;\r\nretval = clk_enable(sport->clk_per);\r\nif (retval)\r\nreturn;\r\nretval = clk_enable(sport->clk_ipg);\r\nif (retval) {\r\nclk_disable(sport->clk_per);\r\nreturn;\r\n}\r\nif (sport->port.sysrq)\r\nlocked = 0;\r\nelse if (oops_in_progress)\r\nlocked = spin_trylock_irqsave(&sport->port.lock, flags);\r\nelse\r\nspin_lock_irqsave(&sport->port.lock, flags);\r\nimx_port_ucrs_save(&sport->port, &old_ucr);\r\nucr1 = old_ucr.ucr1;\r\nif (is_imx1_uart(sport))\r\nucr1 |= IMX1_UCR1_UARTCLKEN;\r\nucr1 |= UCR1_UARTEN;\r\nucr1 &= ~(UCR1_TXMPTYEN | UCR1_RRDYEN | UCR1_RTSDEN);\r\nwritel(ucr1, sport->port.membase + UCR1);\r\nwritel(old_ucr.ucr2 | UCR2_TXEN, sport->port.membase + UCR2);\r\nuart_console_write(&sport->port, s, count, imx_console_putchar);\r\nwhile (!(readl(sport->port.membase + USR2) & USR2_TXDC));\r\nimx_port_ucrs_restore(&sport->port, &old_ucr);\r\nif (locked)\r\nspin_unlock_irqrestore(&sport->port.lock, flags);\r\nclk_disable(sport->clk_ipg);\r\nclk_disable(sport->clk_per);\r\n}\r\nstatic void __init\r\nimx_console_get_options(struct imx_port *sport, int *baud,\r\nint *parity, int *bits)\r\n{\r\nif (readl(sport->port.membase + UCR1) & UCR1_UARTEN) {\r\nunsigned int ucr2, ubir, ubmr, uartclk;\r\nunsigned int baud_raw;\r\nunsigned int ucfr_rfdiv;\r\nucr2 = readl(sport->port.membase + UCR2);\r\n*parity = 'n';\r\nif (ucr2 & UCR2_PREN) {\r\nif (ucr2 & UCR2_PROE)\r\n*parity = 'o';\r\nelse\r\n*parity = 'e';\r\n}\r\nif (ucr2 & UCR2_WS)\r\n*bits = 8;\r\nelse\r\n*bits = 7;\r\nubir = readl(sport->port.membase + UBIR) & 0xffff;\r\nubmr = readl(sport->port.membase + UBMR) & 0xffff;\r\nucfr_rfdiv = (readl(sport->port.membase + UFCR) & UFCR_RFDIV) >> 7;\r\nif (ucfr_rfdiv == 6)\r\nucfr_rfdiv = 7;\r\nelse\r\nucfr_rfdiv = 6 - ucfr_rfdiv;\r\nuartclk = clk_get_rate(sport->clk_per);\r\nuartclk /= ucfr_rfdiv;\r\n{\r\nunsigned int mul = ubir + 1;\r\nunsigned int div = 16 * (ubmr + 1);\r\nunsigned int rem = uartclk % div;\r\nbaud_raw = (uartclk / div) * mul;\r\nbaud_raw += (rem * mul + div / 2) / div;\r\n*baud = (baud_raw + 50) / 100 * 100;\r\n}\r\nif (*baud != baud_raw)\r\npr_info("Console IMX rounded baud rate from %d to %d\n",\r\nbaud_raw, *baud);\r\n}\r\n}\r\nstatic int __init\r\nimx_console_setup(struct console *co, char *options)\r\n{\r\nstruct imx_port *sport;\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nint retval;\r\nif (co->index == -1 || co->index >= ARRAY_SIZE(imx_ports))\r\nco->index = 0;\r\nsport = imx_ports[co->index];\r\nif (sport == NULL)\r\nreturn -ENODEV;\r\nretval = clk_prepare_enable(sport->clk_ipg);\r\nif (retval)\r\ngoto error_console;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nelse\r\nimx_console_get_options(sport, &baud, &parity, &bits);\r\nimx_setup_ufcr(sport, 0);\r\nretval = uart_set_options(&sport->port, co, baud, parity, bits, flow);\r\nclk_disable(sport->clk_ipg);\r\nif (retval) {\r\nclk_unprepare(sport->clk_ipg);\r\ngoto error_console;\r\n}\r\nretval = clk_prepare(sport->clk_per);\r\nif (retval)\r\nclk_disable_unprepare(sport->clk_ipg);\r\nerror_console:\r\nreturn retval;\r\n}\r\nstatic int serial_imx_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct imx_port *sport = platform_get_drvdata(dev);\r\nunsigned int val;\r\nval = readl(sport->port.membase + UCR3);\r\nval |= UCR3_AWAKEN;\r\nwritel(val, sport->port.membase + UCR3);\r\nuart_suspend_port(&imx_reg, &sport->port);\r\nreturn 0;\r\n}\r\nstatic int serial_imx_resume(struct platform_device *dev)\r\n{\r\nstruct imx_port *sport = platform_get_drvdata(dev);\r\nunsigned int val;\r\nval = readl(sport->port.membase + UCR3);\r\nval &= ~UCR3_AWAKEN;\r\nwritel(val, sport->port.membase + UCR3);\r\nuart_resume_port(&imx_reg, &sport->port);\r\nreturn 0;\r\n}\r\nstatic int serial_imx_probe_dt(struct imx_port *sport,\r\nstruct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *of_id =\r\nof_match_device(imx_uart_dt_ids, &pdev->dev);\r\nint ret;\r\nif (!np)\r\nreturn 1;\r\nret = of_alias_get_id(np, "serial");\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to get alias id, errno %d\n", ret);\r\nreturn ret;\r\n}\r\nsport->port.line = ret;\r\nif (of_get_property(np, "fsl,uart-has-rtscts", NULL))\r\nsport->have_rtscts = 1;\r\nif (of_get_property(np, "fsl,irda-mode", NULL))\r\nsport->use_irda = 1;\r\nif (of_get_property(np, "fsl,dte-mode", NULL))\r\nsport->dte_mode = 1;\r\nsport->devdata = of_id->data;\r\nreturn 0;\r\n}\r\nstatic inline int serial_imx_probe_dt(struct imx_port *sport,\r\nstruct platform_device *pdev)\r\n{\r\nreturn 1;\r\n}\r\nstatic void serial_imx_probe_pdata(struct imx_port *sport,\r\nstruct platform_device *pdev)\r\n{\r\nstruct imxuart_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nsport->port.line = pdev->id;\r\nsport->devdata = (struct imx_uart_data *) pdev->id_entry->driver_data;\r\nif (!pdata)\r\nreturn;\r\nif (pdata->flags & IMXUART_HAVE_RTSCTS)\r\nsport->have_rtscts = 1;\r\nif (pdata->flags & IMXUART_IRDA)\r\nsport->use_irda = 1;\r\n}\r\nstatic int serial_imx_probe(struct platform_device *pdev)\r\n{\r\nstruct imx_port *sport;\r\nvoid __iomem *base;\r\nint ret = 0;\r\nstruct resource *res;\r\nsport = devm_kzalloc(&pdev->dev, sizeof(*sport), GFP_KERNEL);\r\nif (!sport)\r\nreturn -ENOMEM;\r\nret = serial_imx_probe_dt(sport, pdev);\r\nif (ret > 0)\r\nserial_imx_probe_pdata(sport, pdev);\r\nelse if (ret < 0)\r\nreturn ret;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nsport->port.dev = &pdev->dev;\r\nsport->port.mapbase = res->start;\r\nsport->port.membase = base;\r\nsport->port.type = PORT_IMX,\r\nsport->port.iotype = UPIO_MEM;\r\nsport->port.irq = platform_get_irq(pdev, 0);\r\nsport->rxirq = platform_get_irq(pdev, 0);\r\nsport->txirq = platform_get_irq(pdev, 1);\r\nsport->rtsirq = platform_get_irq(pdev, 2);\r\nsport->port.fifosize = 32;\r\nsport->port.ops = &imx_pops;\r\nsport->port.flags = UPF_BOOT_AUTOCONF;\r\ninit_timer(&sport->timer);\r\nsport->timer.function = imx_timeout;\r\nsport->timer.data = (unsigned long)sport;\r\nsport->clk_ipg = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(sport->clk_ipg)) {\r\nret = PTR_ERR(sport->clk_ipg);\r\ndev_err(&pdev->dev, "failed to get ipg clk: %d\n", ret);\r\nreturn ret;\r\n}\r\nsport->clk_per = devm_clk_get(&pdev->dev, "per");\r\nif (IS_ERR(sport->clk_per)) {\r\nret = PTR_ERR(sport->clk_per);\r\ndev_err(&pdev->dev, "failed to get per clk: %d\n", ret);\r\nreturn ret;\r\n}\r\nsport->port.uartclk = clk_get_rate(sport->clk_per);\r\nimx_ports[sport->port.line] = sport;\r\nplatform_set_drvdata(pdev, sport);\r\nreturn uart_add_one_port(&imx_reg, &sport->port);\r\n}\r\nstatic int serial_imx_remove(struct platform_device *pdev)\r\n{\r\nstruct imx_port *sport = platform_get_drvdata(pdev);\r\nreturn uart_remove_one_port(&imx_reg, &sport->port);\r\n}\r\nstatic int __init imx_serial_init(void)\r\n{\r\nint ret;\r\npr_info("Serial: IMX driver\n");\r\nret = uart_register_driver(&imx_reg);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&serial_imx_driver);\r\nif (ret != 0)\r\nuart_unregister_driver(&imx_reg);\r\nreturn ret;\r\n}\r\nstatic void __exit imx_serial_exit(void)\r\n{\r\nplatform_driver_unregister(&serial_imx_driver);\r\nuart_unregister_driver(&imx_reg);\r\n}
