static inline void set_bios_x(void)\r\n{\r\npcibios_enabled = 1;\r\nset_memory_x(PAGE_OFFSET + BIOS_BEGIN, (BIOS_END - BIOS_BEGIN) >> PAGE_SHIFT);\r\nif (__supported_pte_mask & _PAGE_NX)\r\nprintk(KERN_INFO "PCI : PCI BIOS area is rw and x. Use pci=nobios if you want it NX.\n");\r\n}\r\nstatic unsigned long bios32_service(unsigned long service)\r\n{\r\nunsigned char return_code;\r\nunsigned long address;\r\nunsigned long length;\r\nunsigned long entry;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\n__asm__("lcall *(%%edi); cld"\r\n: "=a" (return_code),\r\n"=b" (address),\r\n"=c" (length),\r\n"=d" (entry)\r\n: "0" (service),\r\n"1" (0),\r\n"D" (&bios32_indirect));\r\nlocal_irq_restore(flags);\r\nswitch (return_code) {\r\ncase 0:\r\nreturn address + entry;\r\ncase 0x80:\r\nprintk(KERN_WARNING "bios32_service(0x%lx): not present\n", service);\r\nreturn 0;\r\ndefault:\r\nprintk(KERN_WARNING "bios32_service(0x%lx): returned 0x%x -- BIOS bug!\n",\r\nservice, return_code);\r\nreturn 0;\r\n}\r\n}\r\nstatic int check_pcibios(void)\r\n{\r\nu32 signature, eax, ebx, ecx;\r\nu8 status, major_ver, minor_ver, hw_mech;\r\nunsigned long flags, pcibios_entry;\r\nif ((pcibios_entry = bios32_service(PCI_SERVICE))) {\r\npci_indirect.address = pcibios_entry + PAGE_OFFSET;\r\nlocal_irq_save(flags);\r\n__asm__(\r\n"lcall *(%%edi); cld\n\t"\r\n"jc 1f\n\t"\r\n"xor %%ah, %%ah\n"\r\n"1:"\r\n: "=d" (signature),\r\n"=a" (eax),\r\n"=b" (ebx),\r\n"=c" (ecx)\r\n: "1" (PCIBIOS_PCI_BIOS_PRESENT),\r\n"D" (&pci_indirect)\r\n: "memory");\r\nlocal_irq_restore(flags);\r\nstatus = (eax >> 8) & 0xff;\r\nhw_mech = eax & 0xff;\r\nmajor_ver = (ebx >> 8) & 0xff;\r\nminor_ver = ebx & 0xff;\r\nif (pcibios_last_bus < 0)\r\npcibios_last_bus = ecx & 0xff;\r\nDBG("PCI: BIOS probe returned s=%02x hw=%02x ver=%02x.%02x l=%02x\n",\r\nstatus, hw_mech, major_ver, minor_ver, pcibios_last_bus);\r\nif (status || signature != PCI_SIGNATURE) {\r\nprintk (KERN_ERR "PCI: BIOS BUG #%x[%08x] found\n",\r\nstatus, signature);\r\nreturn 0;\r\n}\r\nprintk(KERN_INFO "PCI: PCI BIOS revision %x.%02x entry at 0x%lx, last bus=%d\n",\r\nmajor_ver, minor_ver, pcibios_entry, pcibios_last_bus);\r\n#ifdef CONFIG_PCI_DIRECT\r\nif (!(hw_mech & PCIBIOS_HW_TYPE1))\r\npci_probe &= ~PCI_PROBE_CONF1;\r\nif (!(hw_mech & PCIBIOS_HW_TYPE2))\r\npci_probe &= ~PCI_PROBE_CONF2;\r\n#endif\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pci_bios_read(unsigned int seg, unsigned int bus,\r\nunsigned int devfn, int reg, int len, u32 *value)\r\n{\r\nunsigned long result = 0;\r\nunsigned long flags;\r\nunsigned long bx = (bus << 8) | devfn;\r\nWARN_ON(seg);\r\nif (!value || (bus > 255) || (devfn > 255) || (reg > 255))\r\nreturn -EINVAL;\r\nraw_spin_lock_irqsave(&pci_config_lock, flags);\r\nswitch (len) {\r\ncase 1:\r\n__asm__("lcall *(%%esi); cld\n\t"\r\n"jc 1f\n\t"\r\n"xor %%ah, %%ah\n"\r\n"1:"\r\n: "=c" (*value),\r\n"=a" (result)\r\n: "1" (PCIBIOS_READ_CONFIG_BYTE),\r\n"b" (bx),\r\n"D" ((long)reg),\r\n"S" (&pci_indirect));\r\n*value &= 0xff;\r\nbreak;\r\ncase 2:\r\n__asm__("lcall *(%%esi); cld\n\t"\r\n"jc 1f\n\t"\r\n"xor %%ah, %%ah\n"\r\n"1:"\r\n: "=c" (*value),\r\n"=a" (result)\r\n: "1" (PCIBIOS_READ_CONFIG_WORD),\r\n"b" (bx),\r\n"D" ((long)reg),\r\n"S" (&pci_indirect));\r\n*value &= 0xffff;\r\nbreak;\r\ncase 4:\r\n__asm__("lcall *(%%esi); cld\n\t"\r\n"jc 1f\n\t"\r\n"xor %%ah, %%ah\n"\r\n"1:"\r\n: "=c" (*value),\r\n"=a" (result)\r\n: "1" (PCIBIOS_READ_CONFIG_DWORD),\r\n"b" (bx),\r\n"D" ((long)reg),\r\n"S" (&pci_indirect));\r\nbreak;\r\n}\r\nraw_spin_unlock_irqrestore(&pci_config_lock, flags);\r\nreturn (int)((result & 0xff00) >> 8);\r\n}\r\nstatic int pci_bios_write(unsigned int seg, unsigned int bus,\r\nunsigned int devfn, int reg, int len, u32 value)\r\n{\r\nunsigned long result = 0;\r\nunsigned long flags;\r\nunsigned long bx = (bus << 8) | devfn;\r\nWARN_ON(seg);\r\nif ((bus > 255) || (devfn > 255) || (reg > 255))\r\nreturn -EINVAL;\r\nraw_spin_lock_irqsave(&pci_config_lock, flags);\r\nswitch (len) {\r\ncase 1:\r\n__asm__("lcall *(%%esi); cld\n\t"\r\n"jc 1f\n\t"\r\n"xor %%ah, %%ah\n"\r\n"1:"\r\n: "=a" (result)\r\n: "0" (PCIBIOS_WRITE_CONFIG_BYTE),\r\n"c" (value),\r\n"b" (bx),\r\n"D" ((long)reg),\r\n"S" (&pci_indirect));\r\nbreak;\r\ncase 2:\r\n__asm__("lcall *(%%esi); cld\n\t"\r\n"jc 1f\n\t"\r\n"xor %%ah, %%ah\n"\r\n"1:"\r\n: "=a" (result)\r\n: "0" (PCIBIOS_WRITE_CONFIG_WORD),\r\n"c" (value),\r\n"b" (bx),\r\n"D" ((long)reg),\r\n"S" (&pci_indirect));\r\nbreak;\r\ncase 4:\r\n__asm__("lcall *(%%esi); cld\n\t"\r\n"jc 1f\n\t"\r\n"xor %%ah, %%ah\n"\r\n"1:"\r\n: "=a" (result)\r\n: "0" (PCIBIOS_WRITE_CONFIG_DWORD),\r\n"c" (value),\r\n"b" (bx),\r\n"D" ((long)reg),\r\n"S" (&pci_indirect));\r\nbreak;\r\n}\r\nraw_spin_unlock_irqrestore(&pci_config_lock, flags);\r\nreturn (int)((result & 0xff00) >> 8);\r\n}\r\nstatic const struct pci_raw_ops *pci_find_bios(void)\r\n{\r\nunion bios32 *check;\r\nunsigned char sum;\r\nint i, length;\r\nfor (check = (union bios32 *) __va(0xe0000);\r\ncheck <= (union bios32 *) __va(0xffff0);\r\n++check) {\r\nlong sig;\r\nif (probe_kernel_address(&check->fields.signature, sig))\r\ncontinue;\r\nif (check->fields.signature != BIOS32_SIGNATURE)\r\ncontinue;\r\nlength = check->fields.length * 16;\r\nif (!length)\r\ncontinue;\r\nsum = 0;\r\nfor (i = 0; i < length ; ++i)\r\nsum += check->chars[i];\r\nif (sum != 0)\r\ncontinue;\r\nif (check->fields.revision != 0) {\r\nprintk("PCI: unsupported BIOS32 revision %d at 0x%p\n",\r\ncheck->fields.revision, check);\r\ncontinue;\r\n}\r\nDBG("PCI: BIOS32 Service Directory structure at 0x%p\n", check);\r\nif (check->fields.entry >= 0x100000) {\r\nprintk("PCI: BIOS32 entry (0x%p) in high memory, "\r\n"cannot use.\n", check);\r\nreturn NULL;\r\n} else {\r\nunsigned long bios32_entry = check->fields.entry;\r\nDBG("PCI: BIOS32 Service Directory entry at 0x%lx\n",\r\nbios32_entry);\r\nbios32_indirect.address = bios32_entry + PAGE_OFFSET;\r\nset_bios_x();\r\nif (check_pcibios())\r\nreturn &pci_bios_access;\r\n}\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nstruct irq_routing_table * pcibios_get_irq_routing_table(void)\r\n{\r\nstruct irq_routing_options opt;\r\nstruct irq_routing_table *rt = NULL;\r\nint ret, map;\r\nunsigned long page;\r\nif (!pci_bios_present)\r\nreturn NULL;\r\npage = __get_free_page(GFP_KERNEL);\r\nif (!page)\r\nreturn NULL;\r\nopt.table = (struct irq_info *) page;\r\nopt.size = PAGE_SIZE;\r\nopt.segment = __KERNEL_DS;\r\nDBG("PCI: Fetching IRQ routing table... ");\r\n__asm__("push %%es\n\t"\r\n"push %%ds\n\t"\r\n"pop %%es\n\t"\r\n"lcall *(%%esi); cld\n\t"\r\n"pop %%es\n\t"\r\n"jc 1f\n\t"\r\n"xor %%ah, %%ah\n"\r\n"1:"\r\n: "=a" (ret),\r\n"=b" (map),\r\n"=m" (opt)\r\n: "0" (PCIBIOS_GET_ROUTING_OPTIONS),\r\n"1" (0),\r\n"D" ((long) &opt),\r\n"S" (&pci_indirect),\r\n"m" (opt)\r\n: "memory");\r\nDBG("OK ret=%d, size=%d, map=%x\n", ret, opt.size, map);\r\nif (ret & 0xff00)\r\nprintk(KERN_ERR "PCI: Error %02x when fetching IRQ routing table.\n", (ret >> 8) & 0xff);\r\nelse if (opt.size) {\r\nrt = kmalloc(sizeof(struct irq_routing_table) + opt.size, GFP_KERNEL);\r\nif (rt) {\r\nmemset(rt, 0, sizeof(struct irq_routing_table));\r\nrt->size = opt.size + sizeof(struct irq_routing_table);\r\nrt->exclusive_irqs = map;\r\nmemcpy(rt->slots, (void *) page, opt.size);\r\nprintk(KERN_INFO "PCI: Using BIOS Interrupt Routing Table\n");\r\n}\r\n}\r\nfree_page(page);\r\nreturn rt;\r\n}\r\nint pcibios_set_irq_routing(struct pci_dev *dev, int pin, int irq)\r\n{\r\nint ret;\r\n__asm__("lcall *(%%esi); cld\n\t"\r\n"jc 1f\n\t"\r\n"xor %%ah, %%ah\n"\r\n"1:"\r\n: "=a" (ret)\r\n: "0" (PCIBIOS_SET_PCI_HW_INT),\r\n"b" ((dev->bus->number << 8) | dev->devfn),\r\n"c" ((irq << 8) | (pin + 10)),\r\n"S" (&pci_indirect));\r\nreturn !(ret & 0xff00);\r\n}\r\nvoid __init pci_pcbios_init(void)\r\n{\r\nif ((pci_probe & PCI_PROBE_BIOS)\r\n&& ((raw_pci_ops = pci_find_bios()))) {\r\npci_bios_present = 1;\r\n}\r\n}
