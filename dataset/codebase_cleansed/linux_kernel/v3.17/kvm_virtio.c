static struct kvm_vqconfig *kvm_vq_config(const struct kvm_device_desc *desc)\r\n{\r\nreturn (struct kvm_vqconfig *)(desc + 1);\r\n}\r\nstatic u8 *kvm_vq_features(const struct kvm_device_desc *desc)\r\n{\r\nreturn (u8 *)(kvm_vq_config(desc) + desc->num_vq);\r\n}\r\nstatic u8 *kvm_vq_configspace(const struct kvm_device_desc *desc)\r\n{\r\nreturn kvm_vq_features(desc) + desc->feature_len * 2;\r\n}\r\nstatic unsigned desc_size(const struct kvm_device_desc *desc)\r\n{\r\nreturn sizeof(*desc)\r\n+ desc->num_vq * sizeof(struct kvm_vqconfig)\r\n+ desc->feature_len * 2\r\n+ desc->config_len;\r\n}\r\nstatic u32 kvm_get_features(struct virtio_device *vdev)\r\n{\r\nunsigned int i;\r\nu32 features = 0;\r\nstruct kvm_device_desc *desc = to_kvmdev(vdev)->desc;\r\nu8 *in_features = kvm_vq_features(desc);\r\nfor (i = 0; i < min(desc->feature_len * 8, 32); i++)\r\nif (in_features[i / 8] & (1 << (i % 8)))\r\nfeatures |= (1 << i);\r\nreturn features;\r\n}\r\nstatic void kvm_finalize_features(struct virtio_device *vdev)\r\n{\r\nunsigned int i, bits;\r\nstruct kvm_device_desc *desc = to_kvmdev(vdev)->desc;\r\nu8 *out_features = kvm_vq_features(desc) + desc->feature_len;\r\nvring_transport_features(vdev);\r\nmemset(out_features, 0, desc->feature_len);\r\nbits = min_t(unsigned, desc->feature_len, sizeof(vdev->features)) * 8;\r\nfor (i = 0; i < bits; i++) {\r\nif (test_bit(i, vdev->features))\r\nout_features[i / 8] |= (1 << (i % 8));\r\n}\r\n}\r\nstatic void kvm_get(struct virtio_device *vdev, unsigned int offset,\r\nvoid *buf, unsigned len)\r\n{\r\nstruct kvm_device_desc *desc = to_kvmdev(vdev)->desc;\r\nBUG_ON(offset + len > desc->config_len);\r\nmemcpy(buf, kvm_vq_configspace(desc) + offset, len);\r\n}\r\nstatic void kvm_set(struct virtio_device *vdev, unsigned int offset,\r\nconst void *buf, unsigned len)\r\n{\r\nstruct kvm_device_desc *desc = to_kvmdev(vdev)->desc;\r\nBUG_ON(offset + len > desc->config_len);\r\nmemcpy(kvm_vq_configspace(desc) + offset, buf, len);\r\n}\r\nstatic u8 kvm_get_status(struct virtio_device *vdev)\r\n{\r\nreturn to_kvmdev(vdev)->desc->status;\r\n}\r\nstatic void kvm_set_status(struct virtio_device *vdev, u8 status)\r\n{\r\nBUG_ON(!status);\r\nto_kvmdev(vdev)->desc->status = status;\r\nkvm_hypercall1(KVM_S390_VIRTIO_SET_STATUS,\r\n(unsigned long) to_kvmdev(vdev)->desc);\r\n}\r\nstatic void kvm_reset(struct virtio_device *vdev)\r\n{\r\nkvm_hypercall1(KVM_S390_VIRTIO_RESET,\r\n(unsigned long) to_kvmdev(vdev)->desc);\r\n}\r\nstatic bool kvm_notify(struct virtqueue *vq)\r\n{\r\nlong rc;\r\nstruct kvm_vqconfig *config = vq->priv;\r\nrc = kvm_hypercall1(KVM_S390_VIRTIO_NOTIFY, config->address);\r\nif (rc < 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic struct virtqueue *kvm_find_vq(struct virtio_device *vdev,\r\nunsigned index,\r\nvoid (*callback)(struct virtqueue *vq),\r\nconst char *name)\r\n{\r\nstruct kvm_device *kdev = to_kvmdev(vdev);\r\nstruct kvm_vqconfig *config;\r\nstruct virtqueue *vq;\r\nint err;\r\nif (index >= kdev->desc->num_vq)\r\nreturn ERR_PTR(-ENOENT);\r\nif (!name)\r\nreturn NULL;\r\nconfig = kvm_vq_config(kdev->desc)+index;\r\nerr = vmem_add_mapping(config->address,\r\nvring_size(config->num,\r\nKVM_S390_VIRTIO_RING_ALIGN));\r\nif (err)\r\ngoto out;\r\nvq = vring_new_virtqueue(index, config->num, KVM_S390_VIRTIO_RING_ALIGN,\r\nvdev, true, (void *) config->address,\r\nkvm_notify, callback, name);\r\nif (!vq) {\r\nerr = -ENOMEM;\r\ngoto unmap;\r\n}\r\nconfig->token = (u64) vq;\r\nvq->priv = config;\r\nreturn vq;\r\nunmap:\r\nvmem_remove_mapping(config->address,\r\nvring_size(config->num,\r\nKVM_S390_VIRTIO_RING_ALIGN));\r\nout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void kvm_del_vq(struct virtqueue *vq)\r\n{\r\nstruct kvm_vqconfig *config = vq->priv;\r\nvring_del_virtqueue(vq);\r\nvmem_remove_mapping(config->address,\r\nvring_size(config->num,\r\nKVM_S390_VIRTIO_RING_ALIGN));\r\n}\r\nstatic void kvm_del_vqs(struct virtio_device *vdev)\r\n{\r\nstruct virtqueue *vq, *n;\r\nlist_for_each_entry_safe(vq, n, &vdev->vqs, list)\r\nkvm_del_vq(vq);\r\n}\r\nstatic int kvm_find_vqs(struct virtio_device *vdev, unsigned nvqs,\r\nstruct virtqueue *vqs[],\r\nvq_callback_t *callbacks[],\r\nconst char *names[])\r\n{\r\nstruct kvm_device *kdev = to_kvmdev(vdev);\r\nint i;\r\nif (nvqs > kdev->desc->num_vq)\r\nreturn -ENOENT;\r\nfor (i = 0; i < nvqs; ++i) {\r\nvqs[i] = kvm_find_vq(vdev, i, callbacks[i], names[i]);\r\nif (IS_ERR(vqs[i]))\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nkvm_del_vqs(vdev);\r\nreturn PTR_ERR(vqs[i]);\r\n}\r\nstatic const char *kvm_bus_name(struct virtio_device *vdev)\r\n{\r\nreturn "";\r\n}\r\nstatic void add_kvm_device(struct kvm_device_desc *d, unsigned int offset)\r\n{\r\nstruct kvm_device *kdev;\r\nkdev = kzalloc(sizeof(*kdev), GFP_KERNEL);\r\nif (!kdev) {\r\nprintk(KERN_EMERG "Cannot allocate kvm dev %u type %u\n",\r\noffset, d->type);\r\nreturn;\r\n}\r\nkdev->vdev.dev.parent = kvm_root;\r\nkdev->vdev.id.device = d->type;\r\nkdev->vdev.config = &kvm_vq_configspace_ops;\r\nkdev->desc = d;\r\nif (register_virtio_device(&kdev->vdev) != 0) {\r\nprintk(KERN_ERR "Failed to register kvm device %u type %u\n",\r\noffset, d->type);\r\nkfree(kdev);\r\n}\r\n}\r\nstatic void scan_devices(void)\r\n{\r\nunsigned int i;\r\nstruct kvm_device_desc *d;\r\nfor (i = 0; i < PAGE_SIZE; i += desc_size(d)) {\r\nd = kvm_devices + i;\r\nif (d->type == 0)\r\nbreak;\r\nadd_kvm_device(d, i);\r\n}\r\n}\r\nstatic int match_desc(struct device *dev, void *data)\r\n{\r\nstruct virtio_device *vdev = dev_to_virtio(dev);\r\nstruct kvm_device *kdev = to_kvmdev(vdev);\r\nreturn kdev->desc == data;\r\n}\r\nstatic void hotplug_devices(struct work_struct *dummy)\r\n{\r\nunsigned int i;\r\nstruct kvm_device_desc *d;\r\nstruct device *dev;\r\nfor (i = 0; i < PAGE_SIZE; i += desc_size(d)) {\r\nd = kvm_devices + i;\r\nif (d->type == 0)\r\nbreak;\r\ndev = device_find_child(kvm_root, d, match_desc);\r\nif (dev) {\r\nput_device(dev);\r\ncontinue;\r\n}\r\nprintk(KERN_INFO "Adding new virtio device %p\n", d);\r\nadd_kvm_device(d, i);\r\n}\r\n}\r\nstatic void kvm_extint_handler(struct ext_code ext_code,\r\nunsigned int param32, unsigned long param64)\r\n{\r\nstruct virtqueue *vq;\r\nu32 param;\r\nif ((ext_code.subcode & 0xff00) != VIRTIO_SUBCODE_64)\r\nreturn;\r\ninc_irq_stat(IRQEXT_VRT);\r\nvq = (struct virtqueue *)(param64 & ~1UL);\r\nparam = param32 & VIRTIO_PARAM_MASK;\r\nswitch (param) {\r\ncase VIRTIO_PARAM_CONFIG_CHANGED:\r\n{\r\nstruct virtio_driver *drv;\r\ndrv = container_of(vq->vdev->dev.driver,\r\nstruct virtio_driver, driver);\r\nif (drv->config_changed)\r\ndrv->config_changed(vq->vdev);\r\nbreak;\r\n}\r\ncase VIRTIO_PARAM_DEV_ADD:\r\nschedule_work(&hotplug_work);\r\nbreak;\r\ncase VIRTIO_PARAM_VRING_INTERRUPT:\r\ndefault:\r\nvring_interrupt(0, vq);\r\nbreak;\r\n}\r\n}\r\nstatic int __init test_devices_support(unsigned long addr)\r\n{\r\nint ret = -EIO;\r\nasm volatile(\r\n"0: lura 0,%1\n"\r\n"1: xgr %0,%0\n"\r\n"2:\n"\r\nEX_TABLE(0b,2b)\r\nEX_TABLE(1b,2b)\r\n: "+d" (ret)\r\n: "a" (addr)\r\n: "0", "cc");\r\nreturn ret;\r\n}\r\nstatic int __init kvm_devices_init(void)\r\n{\r\nint rc;\r\nunsigned long total_memory_size = sclp_get_rzm() * sclp_get_rnmax();\r\nif (!MACHINE_IS_KVM)\r\nreturn -ENODEV;\r\nif (test_devices_support(total_memory_size) < 0)\r\nreturn -ENODEV;\r\nrc = vmem_add_mapping(total_memory_size, PAGE_SIZE);\r\nif (rc)\r\nreturn rc;\r\nkvm_devices = (void *) total_memory_size;\r\nkvm_root = root_device_register("kvm_s390");\r\nif (IS_ERR(kvm_root)) {\r\nrc = PTR_ERR(kvm_root);\r\nprintk(KERN_ERR "Could not register kvm_s390 root device");\r\nvmem_remove_mapping(total_memory_size, PAGE_SIZE);\r\nreturn rc;\r\n}\r\nINIT_WORK(&hotplug_work, hotplug_devices);\r\nirq_subclass_register(IRQ_SUBCLASS_SERVICE_SIGNAL);\r\nregister_external_irq(EXT_IRQ_CP_SERVICE, kvm_extint_handler);\r\nscan_devices();\r\nreturn 0;\r\n}\r\nstatic __init int early_put_chars(u32 vtermno, const char *buf, int count)\r\n{\r\nchar scratch[17];\r\nunsigned int len = count;\r\nif (len > sizeof(scratch) - 1)\r\nlen = sizeof(scratch) - 1;\r\nscratch[len] = '\0';\r\nmemcpy(scratch, buf, len);\r\nkvm_hypercall1(KVM_S390_VIRTIO_NOTIFY, __pa(scratch));\r\nreturn len;\r\n}\r\nstatic int __init s390_virtio_console_init(void)\r\n{\r\nif (sclp_has_vt220() || sclp_has_linemode())\r\nreturn -ENODEV;\r\nreturn virtio_cons_early_init(early_put_chars);\r\n}
