static struct ib_ucm_context *ib_ucm_ctx_get(struct ib_ucm_file *file, int id)\r\n{\r\nstruct ib_ucm_context *ctx;\r\nmutex_lock(&ctx_id_mutex);\r\nctx = idr_find(&ctx_id_table, id);\r\nif (!ctx)\r\nctx = ERR_PTR(-ENOENT);\r\nelse if (ctx->file != file)\r\nctx = ERR_PTR(-EINVAL);\r\nelse\r\natomic_inc(&ctx->ref);\r\nmutex_unlock(&ctx_id_mutex);\r\nreturn ctx;\r\n}\r\nstatic void ib_ucm_ctx_put(struct ib_ucm_context *ctx)\r\n{\r\nif (atomic_dec_and_test(&ctx->ref))\r\ncomplete(&ctx->comp);\r\n}\r\nstatic inline int ib_ucm_new_cm_id(int event)\r\n{\r\nreturn event == IB_CM_REQ_RECEIVED || event == IB_CM_SIDR_REQ_RECEIVED;\r\n}\r\nstatic void ib_ucm_cleanup_events(struct ib_ucm_context *ctx)\r\n{\r\nstruct ib_ucm_event *uevent;\r\nmutex_lock(&ctx->file->file_mutex);\r\nlist_del(&ctx->file_list);\r\nwhile (!list_empty(&ctx->events)) {\r\nuevent = list_entry(ctx->events.next,\r\nstruct ib_ucm_event, ctx_list);\r\nlist_del(&uevent->file_list);\r\nlist_del(&uevent->ctx_list);\r\nmutex_unlock(&ctx->file->file_mutex);\r\nif (ib_ucm_new_cm_id(uevent->resp.event))\r\nib_destroy_cm_id(uevent->cm_id);\r\nkfree(uevent);\r\nmutex_lock(&ctx->file->file_mutex);\r\n}\r\nmutex_unlock(&ctx->file->file_mutex);\r\n}\r\nstatic struct ib_ucm_context *ib_ucm_ctx_alloc(struct ib_ucm_file *file)\r\n{\r\nstruct ib_ucm_context *ctx;\r\nctx = kzalloc(sizeof *ctx, GFP_KERNEL);\r\nif (!ctx)\r\nreturn NULL;\r\natomic_set(&ctx->ref, 1);\r\ninit_completion(&ctx->comp);\r\nctx->file = file;\r\nINIT_LIST_HEAD(&ctx->events);\r\nmutex_lock(&ctx_id_mutex);\r\nctx->id = idr_alloc(&ctx_id_table, ctx, 0, 0, GFP_KERNEL);\r\nmutex_unlock(&ctx_id_mutex);\r\nif (ctx->id < 0)\r\ngoto error;\r\nlist_add_tail(&ctx->file_list, &file->ctxs);\r\nreturn ctx;\r\nerror:\r\nkfree(ctx);\r\nreturn NULL;\r\n}\r\nstatic void ib_ucm_event_req_get(struct ib_ucm_req_event_resp *ureq,\r\nstruct ib_cm_req_event_param *kreq)\r\n{\r\nureq->remote_ca_guid = kreq->remote_ca_guid;\r\nureq->remote_qkey = kreq->remote_qkey;\r\nureq->remote_qpn = kreq->remote_qpn;\r\nureq->qp_type = kreq->qp_type;\r\nureq->starting_psn = kreq->starting_psn;\r\nureq->responder_resources = kreq->responder_resources;\r\nureq->initiator_depth = kreq->initiator_depth;\r\nureq->local_cm_response_timeout = kreq->local_cm_response_timeout;\r\nureq->flow_control = kreq->flow_control;\r\nureq->remote_cm_response_timeout = kreq->remote_cm_response_timeout;\r\nureq->retry_count = kreq->retry_count;\r\nureq->rnr_retry_count = kreq->rnr_retry_count;\r\nureq->srq = kreq->srq;\r\nureq->port = kreq->port;\r\nib_copy_path_rec_to_user(&ureq->primary_path, kreq->primary_path);\r\nif (kreq->alternate_path)\r\nib_copy_path_rec_to_user(&ureq->alternate_path,\r\nkreq->alternate_path);\r\n}\r\nstatic void ib_ucm_event_rep_get(struct ib_ucm_rep_event_resp *urep,\r\nstruct ib_cm_rep_event_param *krep)\r\n{\r\nurep->remote_ca_guid = krep->remote_ca_guid;\r\nurep->remote_qkey = krep->remote_qkey;\r\nurep->remote_qpn = krep->remote_qpn;\r\nurep->starting_psn = krep->starting_psn;\r\nurep->responder_resources = krep->responder_resources;\r\nurep->initiator_depth = krep->initiator_depth;\r\nurep->target_ack_delay = krep->target_ack_delay;\r\nurep->failover_accepted = krep->failover_accepted;\r\nurep->flow_control = krep->flow_control;\r\nurep->rnr_retry_count = krep->rnr_retry_count;\r\nurep->srq = krep->srq;\r\n}\r\nstatic void ib_ucm_event_sidr_rep_get(struct ib_ucm_sidr_rep_event_resp *urep,\r\nstruct ib_cm_sidr_rep_event_param *krep)\r\n{\r\nurep->status = krep->status;\r\nurep->qkey = krep->qkey;\r\nurep->qpn = krep->qpn;\r\n}\r\nstatic int ib_ucm_event_process(struct ib_cm_event *evt,\r\nstruct ib_ucm_event *uvt)\r\n{\r\nvoid *info = NULL;\r\nswitch (evt->event) {\r\ncase IB_CM_REQ_RECEIVED:\r\nib_ucm_event_req_get(&uvt->resp.u.req_resp,\r\n&evt->param.req_rcvd);\r\nuvt->data_len = IB_CM_REQ_PRIVATE_DATA_SIZE;\r\nuvt->resp.present = IB_UCM_PRES_PRIMARY;\r\nuvt->resp.present |= (evt->param.req_rcvd.alternate_path ?\r\nIB_UCM_PRES_ALTERNATE : 0);\r\nbreak;\r\ncase IB_CM_REP_RECEIVED:\r\nib_ucm_event_rep_get(&uvt->resp.u.rep_resp,\r\n&evt->param.rep_rcvd);\r\nuvt->data_len = IB_CM_REP_PRIVATE_DATA_SIZE;\r\nbreak;\r\ncase IB_CM_RTU_RECEIVED:\r\nuvt->data_len = IB_CM_RTU_PRIVATE_DATA_SIZE;\r\nuvt->resp.u.send_status = evt->param.send_status;\r\nbreak;\r\ncase IB_CM_DREQ_RECEIVED:\r\nuvt->data_len = IB_CM_DREQ_PRIVATE_DATA_SIZE;\r\nuvt->resp.u.send_status = evt->param.send_status;\r\nbreak;\r\ncase IB_CM_DREP_RECEIVED:\r\nuvt->data_len = IB_CM_DREP_PRIVATE_DATA_SIZE;\r\nuvt->resp.u.send_status = evt->param.send_status;\r\nbreak;\r\ncase IB_CM_MRA_RECEIVED:\r\nuvt->resp.u.mra_resp.timeout =\r\nevt->param.mra_rcvd.service_timeout;\r\nuvt->data_len = IB_CM_MRA_PRIVATE_DATA_SIZE;\r\nbreak;\r\ncase IB_CM_REJ_RECEIVED:\r\nuvt->resp.u.rej_resp.reason = evt->param.rej_rcvd.reason;\r\nuvt->data_len = IB_CM_REJ_PRIVATE_DATA_SIZE;\r\nuvt->info_len = evt->param.rej_rcvd.ari_length;\r\ninfo = evt->param.rej_rcvd.ari;\r\nbreak;\r\ncase IB_CM_LAP_RECEIVED:\r\nib_copy_path_rec_to_user(&uvt->resp.u.lap_resp.path,\r\nevt->param.lap_rcvd.alternate_path);\r\nuvt->data_len = IB_CM_LAP_PRIVATE_DATA_SIZE;\r\nuvt->resp.present = IB_UCM_PRES_ALTERNATE;\r\nbreak;\r\ncase IB_CM_APR_RECEIVED:\r\nuvt->resp.u.apr_resp.status = evt->param.apr_rcvd.ap_status;\r\nuvt->data_len = IB_CM_APR_PRIVATE_DATA_SIZE;\r\nuvt->info_len = evt->param.apr_rcvd.info_len;\r\ninfo = evt->param.apr_rcvd.apr_info;\r\nbreak;\r\ncase IB_CM_SIDR_REQ_RECEIVED:\r\nuvt->resp.u.sidr_req_resp.pkey =\r\nevt->param.sidr_req_rcvd.pkey;\r\nuvt->resp.u.sidr_req_resp.port =\r\nevt->param.sidr_req_rcvd.port;\r\nuvt->data_len = IB_CM_SIDR_REQ_PRIVATE_DATA_SIZE;\r\nbreak;\r\ncase IB_CM_SIDR_REP_RECEIVED:\r\nib_ucm_event_sidr_rep_get(&uvt->resp.u.sidr_rep_resp,\r\n&evt->param.sidr_rep_rcvd);\r\nuvt->data_len = IB_CM_SIDR_REP_PRIVATE_DATA_SIZE;\r\nuvt->info_len = evt->param.sidr_rep_rcvd.info_len;\r\ninfo = evt->param.sidr_rep_rcvd.info;\r\nbreak;\r\ndefault:\r\nuvt->resp.u.send_status = evt->param.send_status;\r\nbreak;\r\n}\r\nif (uvt->data_len) {\r\nuvt->data = kmemdup(evt->private_data, uvt->data_len, GFP_KERNEL);\r\nif (!uvt->data)\r\ngoto err1;\r\nuvt->resp.present |= IB_UCM_PRES_DATA;\r\n}\r\nif (uvt->info_len) {\r\nuvt->info = kmemdup(info, uvt->info_len, GFP_KERNEL);\r\nif (!uvt->info)\r\ngoto err2;\r\nuvt->resp.present |= IB_UCM_PRES_INFO;\r\n}\r\nreturn 0;\r\nerr2:\r\nkfree(uvt->data);\r\nerr1:\r\nreturn -ENOMEM;\r\n}\r\nstatic int ib_ucm_event_handler(struct ib_cm_id *cm_id,\r\nstruct ib_cm_event *event)\r\n{\r\nstruct ib_ucm_event *uevent;\r\nstruct ib_ucm_context *ctx;\r\nint result = 0;\r\nctx = cm_id->context;\r\nuevent = kzalloc(sizeof *uevent, GFP_KERNEL);\r\nif (!uevent)\r\ngoto err1;\r\nuevent->ctx = ctx;\r\nuevent->cm_id = cm_id;\r\nuevent->resp.uid = ctx->uid;\r\nuevent->resp.id = ctx->id;\r\nuevent->resp.event = event->event;\r\nresult = ib_ucm_event_process(event, uevent);\r\nif (result)\r\ngoto err2;\r\nmutex_lock(&ctx->file->file_mutex);\r\nlist_add_tail(&uevent->file_list, &ctx->file->events);\r\nlist_add_tail(&uevent->ctx_list, &ctx->events);\r\nwake_up_interruptible(&ctx->file->poll_wait);\r\nmutex_unlock(&ctx->file->file_mutex);\r\nreturn 0;\r\nerr2:\r\nkfree(uevent);\r\nerr1:\r\nreturn ib_ucm_new_cm_id(event->event);\r\n}\r\nstatic ssize_t ib_ucm_event(struct ib_ucm_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_ucm_context *ctx;\r\nstruct ib_ucm_event_get cmd;\r\nstruct ib_ucm_event *uevent;\r\nint result = 0;\r\nif (out_len < sizeof(struct ib_ucm_event_resp))\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nmutex_lock(&file->file_mutex);\r\nwhile (list_empty(&file->events)) {\r\nmutex_unlock(&file->file_mutex);\r\nif (file->filp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nif (wait_event_interruptible(file->poll_wait,\r\n!list_empty(&file->events)))\r\nreturn -ERESTARTSYS;\r\nmutex_lock(&file->file_mutex);\r\n}\r\nuevent = list_entry(file->events.next, struct ib_ucm_event, file_list);\r\nif (ib_ucm_new_cm_id(uevent->resp.event)) {\r\nctx = ib_ucm_ctx_alloc(file);\r\nif (!ctx) {\r\nresult = -ENOMEM;\r\ngoto done;\r\n}\r\nctx->cm_id = uevent->cm_id;\r\nctx->cm_id->context = ctx;\r\nuevent->resp.id = ctx->id;\r\n}\r\nif (copy_to_user((void __user *)(unsigned long)cmd.response,\r\n&uevent->resp, sizeof(uevent->resp))) {\r\nresult = -EFAULT;\r\ngoto done;\r\n}\r\nif (uevent->data) {\r\nif (cmd.data_len < uevent->data_len) {\r\nresult = -ENOMEM;\r\ngoto done;\r\n}\r\nif (copy_to_user((void __user *)(unsigned long)cmd.data,\r\nuevent->data, uevent->data_len)) {\r\nresult = -EFAULT;\r\ngoto done;\r\n}\r\n}\r\nif (uevent->info) {\r\nif (cmd.info_len < uevent->info_len) {\r\nresult = -ENOMEM;\r\ngoto done;\r\n}\r\nif (copy_to_user((void __user *)(unsigned long)cmd.info,\r\nuevent->info, uevent->info_len)) {\r\nresult = -EFAULT;\r\ngoto done;\r\n}\r\n}\r\nlist_del(&uevent->file_list);\r\nlist_del(&uevent->ctx_list);\r\nuevent->ctx->events_reported++;\r\nkfree(uevent->data);\r\nkfree(uevent->info);\r\nkfree(uevent);\r\ndone:\r\nmutex_unlock(&file->file_mutex);\r\nreturn result;\r\n}\r\nstatic ssize_t ib_ucm_create_id(struct ib_ucm_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_ucm_create_id cmd;\r\nstruct ib_ucm_create_id_resp resp;\r\nstruct ib_ucm_context *ctx;\r\nint result;\r\nif (out_len < sizeof(resp))\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nmutex_lock(&file->file_mutex);\r\nctx = ib_ucm_ctx_alloc(file);\r\nmutex_unlock(&file->file_mutex);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->uid = cmd.uid;\r\nctx->cm_id = ib_create_cm_id(file->device->ib_dev,\r\nib_ucm_event_handler, ctx);\r\nif (IS_ERR(ctx->cm_id)) {\r\nresult = PTR_ERR(ctx->cm_id);\r\ngoto err1;\r\n}\r\nresp.id = ctx->id;\r\nif (copy_to_user((void __user *)(unsigned long)cmd.response,\r\n&resp, sizeof(resp))) {\r\nresult = -EFAULT;\r\ngoto err2;\r\n}\r\nreturn 0;\r\nerr2:\r\nib_destroy_cm_id(ctx->cm_id);\r\nerr1:\r\nmutex_lock(&ctx_id_mutex);\r\nidr_remove(&ctx_id_table, ctx->id);\r\nmutex_unlock(&ctx_id_mutex);\r\nkfree(ctx);\r\nreturn result;\r\n}\r\nstatic ssize_t ib_ucm_destroy_id(struct ib_ucm_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_ucm_destroy_id cmd;\r\nstruct ib_ucm_destroy_id_resp resp;\r\nstruct ib_ucm_context *ctx;\r\nint result = 0;\r\nif (out_len < sizeof(resp))\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nmutex_lock(&ctx_id_mutex);\r\nctx = idr_find(&ctx_id_table, cmd.id);\r\nif (!ctx)\r\nctx = ERR_PTR(-ENOENT);\r\nelse if (ctx->file != file)\r\nctx = ERR_PTR(-EINVAL);\r\nelse\r\nidr_remove(&ctx_id_table, ctx->id);\r\nmutex_unlock(&ctx_id_mutex);\r\nif (IS_ERR(ctx))\r\nreturn PTR_ERR(ctx);\r\nib_ucm_ctx_put(ctx);\r\nwait_for_completion(&ctx->comp);\r\nib_destroy_cm_id(ctx->cm_id);\r\nib_ucm_cleanup_events(ctx);\r\nresp.events_reported = ctx->events_reported;\r\nif (copy_to_user((void __user *)(unsigned long)cmd.response,\r\n&resp, sizeof(resp)))\r\nresult = -EFAULT;\r\nkfree(ctx);\r\nreturn result;\r\n}\r\nstatic ssize_t ib_ucm_attr_id(struct ib_ucm_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_ucm_attr_id_resp resp;\r\nstruct ib_ucm_attr_id cmd;\r\nstruct ib_ucm_context *ctx;\r\nint result = 0;\r\nif (out_len < sizeof(resp))\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nctx = ib_ucm_ctx_get(file, cmd.id);\r\nif (IS_ERR(ctx))\r\nreturn PTR_ERR(ctx);\r\nresp.service_id = ctx->cm_id->service_id;\r\nresp.service_mask = ctx->cm_id->service_mask;\r\nresp.local_id = ctx->cm_id->local_id;\r\nresp.remote_id = ctx->cm_id->remote_id;\r\nif (copy_to_user((void __user *)(unsigned long)cmd.response,\r\n&resp, sizeof(resp)))\r\nresult = -EFAULT;\r\nib_ucm_ctx_put(ctx);\r\nreturn result;\r\n}\r\nstatic ssize_t ib_ucm_init_qp_attr(struct ib_ucm_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_uverbs_qp_attr resp;\r\nstruct ib_ucm_init_qp_attr cmd;\r\nstruct ib_ucm_context *ctx;\r\nstruct ib_qp_attr qp_attr;\r\nint result = 0;\r\nif (out_len < sizeof(resp))\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nctx = ib_ucm_ctx_get(file, cmd.id);\r\nif (IS_ERR(ctx))\r\nreturn PTR_ERR(ctx);\r\nresp.qp_attr_mask = 0;\r\nmemset(&qp_attr, 0, sizeof qp_attr);\r\nqp_attr.qp_state = cmd.qp_state;\r\nresult = ib_cm_init_qp_attr(ctx->cm_id, &qp_attr, &resp.qp_attr_mask);\r\nif (result)\r\ngoto out;\r\nib_copy_qp_attr_to_user(&resp, &qp_attr);\r\nif (copy_to_user((void __user *)(unsigned long)cmd.response,\r\n&resp, sizeof(resp)))\r\nresult = -EFAULT;\r\nout:\r\nib_ucm_ctx_put(ctx);\r\nreturn result;\r\n}\r\nstatic int ucm_validate_listen(__be64 service_id, __be64 service_mask)\r\n{\r\nservice_id &= service_mask;\r\nif (((service_id & IB_CMA_SERVICE_ID_MASK) == IB_CMA_SERVICE_ID) ||\r\n((service_id & IB_SDP_SERVICE_ID_MASK) == IB_SDP_SERVICE_ID))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic ssize_t ib_ucm_listen(struct ib_ucm_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_ucm_listen cmd;\r\nstruct ib_ucm_context *ctx;\r\nint result;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nctx = ib_ucm_ctx_get(file, cmd.id);\r\nif (IS_ERR(ctx))\r\nreturn PTR_ERR(ctx);\r\nresult = ucm_validate_listen(cmd.service_id, cmd.service_mask);\r\nif (result)\r\ngoto out;\r\nresult = ib_cm_listen(ctx->cm_id, cmd.service_id, cmd.service_mask,\r\nNULL);\r\nout:\r\nib_ucm_ctx_put(ctx);\r\nreturn result;\r\n}\r\nstatic ssize_t ib_ucm_notify(struct ib_ucm_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_ucm_notify cmd;\r\nstruct ib_ucm_context *ctx;\r\nint result;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nctx = ib_ucm_ctx_get(file, cmd.id);\r\nif (IS_ERR(ctx))\r\nreturn PTR_ERR(ctx);\r\nresult = ib_cm_notify(ctx->cm_id, (enum ib_event_type) cmd.event);\r\nib_ucm_ctx_put(ctx);\r\nreturn result;\r\n}\r\nstatic int ib_ucm_alloc_data(const void **dest, u64 src, u32 len)\r\n{\r\nvoid *data;\r\n*dest = NULL;\r\nif (!len)\r\nreturn 0;\r\ndata = memdup_user((void __user *)(unsigned long)src, len);\r\nif (IS_ERR(data))\r\nreturn PTR_ERR(data);\r\n*dest = data;\r\nreturn 0;\r\n}\r\nstatic int ib_ucm_path_get(struct ib_sa_path_rec **path, u64 src)\r\n{\r\nstruct ib_user_path_rec upath;\r\nstruct ib_sa_path_rec *sa_path;\r\n*path = NULL;\r\nif (!src)\r\nreturn 0;\r\nsa_path = kmalloc(sizeof(*sa_path), GFP_KERNEL);\r\nif (!sa_path)\r\nreturn -ENOMEM;\r\nif (copy_from_user(&upath, (void __user *)(unsigned long)src,\r\nsizeof(upath))) {\r\nkfree(sa_path);\r\nreturn -EFAULT;\r\n}\r\nib_copy_path_rec_from_user(sa_path, &upath);\r\n*path = sa_path;\r\nreturn 0;\r\n}\r\nstatic ssize_t ib_ucm_send_req(struct ib_ucm_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_cm_req_param param;\r\nstruct ib_ucm_context *ctx;\r\nstruct ib_ucm_req cmd;\r\nint result;\r\nparam.private_data = NULL;\r\nparam.primary_path = NULL;\r\nparam.alternate_path = NULL;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nresult = ib_ucm_alloc_data(&param.private_data, cmd.data, cmd.len);\r\nif (result)\r\ngoto done;\r\nresult = ib_ucm_path_get(&param.primary_path, cmd.primary_path);\r\nif (result)\r\ngoto done;\r\nresult = ib_ucm_path_get(&param.alternate_path, cmd.alternate_path);\r\nif (result)\r\ngoto done;\r\nparam.private_data_len = cmd.len;\r\nparam.service_id = cmd.sid;\r\nparam.qp_num = cmd.qpn;\r\nparam.qp_type = cmd.qp_type;\r\nparam.starting_psn = cmd.psn;\r\nparam.peer_to_peer = cmd.peer_to_peer;\r\nparam.responder_resources = cmd.responder_resources;\r\nparam.initiator_depth = cmd.initiator_depth;\r\nparam.remote_cm_response_timeout = cmd.remote_cm_response_timeout;\r\nparam.flow_control = cmd.flow_control;\r\nparam.local_cm_response_timeout = cmd.local_cm_response_timeout;\r\nparam.retry_count = cmd.retry_count;\r\nparam.rnr_retry_count = cmd.rnr_retry_count;\r\nparam.max_cm_retries = cmd.max_cm_retries;\r\nparam.srq = cmd.srq;\r\nctx = ib_ucm_ctx_get(file, cmd.id);\r\nif (!IS_ERR(ctx)) {\r\nresult = ib_send_cm_req(ctx->cm_id, &param);\r\nib_ucm_ctx_put(ctx);\r\n} else\r\nresult = PTR_ERR(ctx);\r\ndone:\r\nkfree(param.private_data);\r\nkfree(param.primary_path);\r\nkfree(param.alternate_path);\r\nreturn result;\r\n}\r\nstatic ssize_t ib_ucm_send_rep(struct ib_ucm_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_cm_rep_param param;\r\nstruct ib_ucm_context *ctx;\r\nstruct ib_ucm_rep cmd;\r\nint result;\r\nparam.private_data = NULL;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nresult = ib_ucm_alloc_data(&param.private_data, cmd.data, cmd.len);\r\nif (result)\r\nreturn result;\r\nparam.qp_num = cmd.qpn;\r\nparam.starting_psn = cmd.psn;\r\nparam.private_data_len = cmd.len;\r\nparam.responder_resources = cmd.responder_resources;\r\nparam.initiator_depth = cmd.initiator_depth;\r\nparam.failover_accepted = cmd.failover_accepted;\r\nparam.flow_control = cmd.flow_control;\r\nparam.rnr_retry_count = cmd.rnr_retry_count;\r\nparam.srq = cmd.srq;\r\nctx = ib_ucm_ctx_get(file, cmd.id);\r\nif (!IS_ERR(ctx)) {\r\nctx->uid = cmd.uid;\r\nresult = ib_send_cm_rep(ctx->cm_id, &param);\r\nib_ucm_ctx_put(ctx);\r\n} else\r\nresult = PTR_ERR(ctx);\r\nkfree(param.private_data);\r\nreturn result;\r\n}\r\nstatic ssize_t ib_ucm_send_private_data(struct ib_ucm_file *file,\r\nconst char __user *inbuf, int in_len,\r\nint (*func)(struct ib_cm_id *cm_id,\r\nconst void *private_data,\r\nu8 private_data_len))\r\n{\r\nstruct ib_ucm_private_data cmd;\r\nstruct ib_ucm_context *ctx;\r\nconst void *private_data = NULL;\r\nint result;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nresult = ib_ucm_alloc_data(&private_data, cmd.data, cmd.len);\r\nif (result)\r\nreturn result;\r\nctx = ib_ucm_ctx_get(file, cmd.id);\r\nif (!IS_ERR(ctx)) {\r\nresult = func(ctx->cm_id, private_data, cmd.len);\r\nib_ucm_ctx_put(ctx);\r\n} else\r\nresult = PTR_ERR(ctx);\r\nkfree(private_data);\r\nreturn result;\r\n}\r\nstatic ssize_t ib_ucm_send_rtu(struct ib_ucm_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nreturn ib_ucm_send_private_data(file, inbuf, in_len, ib_send_cm_rtu);\r\n}\r\nstatic ssize_t ib_ucm_send_dreq(struct ib_ucm_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nreturn ib_ucm_send_private_data(file, inbuf, in_len, ib_send_cm_dreq);\r\n}\r\nstatic ssize_t ib_ucm_send_drep(struct ib_ucm_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nreturn ib_ucm_send_private_data(file, inbuf, in_len, ib_send_cm_drep);\r\n}\r\nstatic ssize_t ib_ucm_send_info(struct ib_ucm_file *file,\r\nconst char __user *inbuf, int in_len,\r\nint (*func)(struct ib_cm_id *cm_id,\r\nint status,\r\nconst void *info,\r\nu8 info_len,\r\nconst void *data,\r\nu8 data_len))\r\n{\r\nstruct ib_ucm_context *ctx;\r\nstruct ib_ucm_info cmd;\r\nconst void *data = NULL;\r\nconst void *info = NULL;\r\nint result;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nresult = ib_ucm_alloc_data(&data, cmd.data, cmd.data_len);\r\nif (result)\r\ngoto done;\r\nresult = ib_ucm_alloc_data(&info, cmd.info, cmd.info_len);\r\nif (result)\r\ngoto done;\r\nctx = ib_ucm_ctx_get(file, cmd.id);\r\nif (!IS_ERR(ctx)) {\r\nresult = func(ctx->cm_id, cmd.status, info, cmd.info_len,\r\ndata, cmd.data_len);\r\nib_ucm_ctx_put(ctx);\r\n} else\r\nresult = PTR_ERR(ctx);\r\ndone:\r\nkfree(data);\r\nkfree(info);\r\nreturn result;\r\n}\r\nstatic ssize_t ib_ucm_send_rej(struct ib_ucm_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nreturn ib_ucm_send_info(file, inbuf, in_len, (void *)ib_send_cm_rej);\r\n}\r\nstatic ssize_t ib_ucm_send_apr(struct ib_ucm_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nreturn ib_ucm_send_info(file, inbuf, in_len, (void *)ib_send_cm_apr);\r\n}\r\nstatic ssize_t ib_ucm_send_mra(struct ib_ucm_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_ucm_context *ctx;\r\nstruct ib_ucm_mra cmd;\r\nconst void *data = NULL;\r\nint result;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nresult = ib_ucm_alloc_data(&data, cmd.data, cmd.len);\r\nif (result)\r\nreturn result;\r\nctx = ib_ucm_ctx_get(file, cmd.id);\r\nif (!IS_ERR(ctx)) {\r\nresult = ib_send_cm_mra(ctx->cm_id, cmd.timeout, data, cmd.len);\r\nib_ucm_ctx_put(ctx);\r\n} else\r\nresult = PTR_ERR(ctx);\r\nkfree(data);\r\nreturn result;\r\n}\r\nstatic ssize_t ib_ucm_send_lap(struct ib_ucm_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_ucm_context *ctx;\r\nstruct ib_sa_path_rec *path = NULL;\r\nstruct ib_ucm_lap cmd;\r\nconst void *data = NULL;\r\nint result;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nresult = ib_ucm_alloc_data(&data, cmd.data, cmd.len);\r\nif (result)\r\ngoto done;\r\nresult = ib_ucm_path_get(&path, cmd.path);\r\nif (result)\r\ngoto done;\r\nctx = ib_ucm_ctx_get(file, cmd.id);\r\nif (!IS_ERR(ctx)) {\r\nresult = ib_send_cm_lap(ctx->cm_id, path, data, cmd.len);\r\nib_ucm_ctx_put(ctx);\r\n} else\r\nresult = PTR_ERR(ctx);\r\ndone:\r\nkfree(data);\r\nkfree(path);\r\nreturn result;\r\n}\r\nstatic ssize_t ib_ucm_send_sidr_req(struct ib_ucm_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_cm_sidr_req_param param;\r\nstruct ib_ucm_context *ctx;\r\nstruct ib_ucm_sidr_req cmd;\r\nint result;\r\nparam.private_data = NULL;\r\nparam.path = NULL;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nresult = ib_ucm_alloc_data(&param.private_data, cmd.data, cmd.len);\r\nif (result)\r\ngoto done;\r\nresult = ib_ucm_path_get(&param.path, cmd.path);\r\nif (result)\r\ngoto done;\r\nparam.private_data_len = cmd.len;\r\nparam.service_id = cmd.sid;\r\nparam.timeout_ms = cmd.timeout;\r\nparam.max_cm_retries = cmd.max_cm_retries;\r\nctx = ib_ucm_ctx_get(file, cmd.id);\r\nif (!IS_ERR(ctx)) {\r\nresult = ib_send_cm_sidr_req(ctx->cm_id, &param);\r\nib_ucm_ctx_put(ctx);\r\n} else\r\nresult = PTR_ERR(ctx);\r\ndone:\r\nkfree(param.private_data);\r\nkfree(param.path);\r\nreturn result;\r\n}\r\nstatic ssize_t ib_ucm_send_sidr_rep(struct ib_ucm_file *file,\r\nconst char __user *inbuf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_cm_sidr_rep_param param;\r\nstruct ib_ucm_sidr_rep cmd;\r\nstruct ib_ucm_context *ctx;\r\nint result;\r\nparam.info = NULL;\r\nif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nresult = ib_ucm_alloc_data(&param.private_data,\r\ncmd.data, cmd.data_len);\r\nif (result)\r\ngoto done;\r\nresult = ib_ucm_alloc_data(&param.info, cmd.info, cmd.info_len);\r\nif (result)\r\ngoto done;\r\nparam.qp_num = cmd.qpn;\r\nparam.qkey = cmd.qkey;\r\nparam.status = cmd.status;\r\nparam.info_length = cmd.info_len;\r\nparam.private_data_len = cmd.data_len;\r\nctx = ib_ucm_ctx_get(file, cmd.id);\r\nif (!IS_ERR(ctx)) {\r\nresult = ib_send_cm_sidr_rep(ctx->cm_id, &param);\r\nib_ucm_ctx_put(ctx);\r\n} else\r\nresult = PTR_ERR(ctx);\r\ndone:\r\nkfree(param.private_data);\r\nkfree(param.info);\r\nreturn result;\r\n}\r\nstatic ssize_t ib_ucm_write(struct file *filp, const char __user *buf,\r\nsize_t len, loff_t *pos)\r\n{\r\nstruct ib_ucm_file *file = filp->private_data;\r\nstruct ib_ucm_cmd_hdr hdr;\r\nssize_t result;\r\nif (len < sizeof(hdr))\r\nreturn -EINVAL;\r\nif (copy_from_user(&hdr, buf, sizeof(hdr)))\r\nreturn -EFAULT;\r\nif (hdr.cmd >= ARRAY_SIZE(ucm_cmd_table))\r\nreturn -EINVAL;\r\nif (hdr.in + sizeof(hdr) > len)\r\nreturn -EINVAL;\r\nresult = ucm_cmd_table[hdr.cmd](file, buf + sizeof(hdr),\r\nhdr.in, hdr.out);\r\nif (!result)\r\nresult = len;\r\nreturn result;\r\n}\r\nstatic unsigned int ib_ucm_poll(struct file *filp,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct ib_ucm_file *file = filp->private_data;\r\nunsigned int mask = 0;\r\npoll_wait(filp, &file->poll_wait, wait);\r\nif (!list_empty(&file->events))\r\nmask = POLLIN | POLLRDNORM;\r\nreturn mask;\r\n}\r\nstatic int ib_ucm_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct ib_ucm_file *file;\r\nfile = kmalloc(sizeof(*file), GFP_KERNEL);\r\nif (!file)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&file->events);\r\nINIT_LIST_HEAD(&file->ctxs);\r\ninit_waitqueue_head(&file->poll_wait);\r\nmutex_init(&file->file_mutex);\r\nfilp->private_data = file;\r\nfile->filp = filp;\r\nfile->device = container_of(inode->i_cdev, struct ib_ucm_device, cdev);\r\nreturn nonseekable_open(inode, filp);\r\n}\r\nstatic int ib_ucm_close(struct inode *inode, struct file *filp)\r\n{\r\nstruct ib_ucm_file *file = filp->private_data;\r\nstruct ib_ucm_context *ctx;\r\nmutex_lock(&file->file_mutex);\r\nwhile (!list_empty(&file->ctxs)) {\r\nctx = list_entry(file->ctxs.next,\r\nstruct ib_ucm_context, file_list);\r\nmutex_unlock(&file->file_mutex);\r\nmutex_lock(&ctx_id_mutex);\r\nidr_remove(&ctx_id_table, ctx->id);\r\nmutex_unlock(&ctx_id_mutex);\r\nib_destroy_cm_id(ctx->cm_id);\r\nib_ucm_cleanup_events(ctx);\r\nkfree(ctx);\r\nmutex_lock(&file->file_mutex);\r\n}\r\nmutex_unlock(&file->file_mutex);\r\nkfree(file);\r\nreturn 0;\r\n}\r\nstatic void ib_ucm_release_dev(struct device *dev)\r\n{\r\nstruct ib_ucm_device *ucm_dev;\r\nucm_dev = container_of(dev, struct ib_ucm_device, dev);\r\ncdev_del(&ucm_dev->cdev);\r\nif (ucm_dev->devnum < IB_UCM_MAX_DEVICES)\r\nclear_bit(ucm_dev->devnum, dev_map);\r\nelse\r\nclear_bit(ucm_dev->devnum - IB_UCM_MAX_DEVICES, dev_map);\r\nkfree(ucm_dev);\r\n}\r\nstatic ssize_t show_ibdev(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ib_ucm_device *ucm_dev;\r\nucm_dev = container_of(dev, struct ib_ucm_device, dev);\r\nreturn sprintf(buf, "%s\n", ucm_dev->ib_dev->name);\r\n}\r\nstatic int find_overflow_devnum(void)\r\n{\r\nint ret;\r\nif (!overflow_maj) {\r\nret = alloc_chrdev_region(&overflow_maj, 0, IB_UCM_MAX_DEVICES,\r\n"infiniband_cm");\r\nif (ret) {\r\nprintk(KERN_ERR "ucm: couldn't register dynamic device number\n");\r\nreturn ret;\r\n}\r\n}\r\nret = find_first_zero_bit(overflow_map, IB_UCM_MAX_DEVICES);\r\nif (ret >= IB_UCM_MAX_DEVICES)\r\nreturn -1;\r\nreturn ret;\r\n}\r\nstatic void ib_ucm_add_one(struct ib_device *device)\r\n{\r\nint devnum;\r\ndev_t base;\r\nstruct ib_ucm_device *ucm_dev;\r\nif (!device->alloc_ucontext ||\r\nrdma_node_get_transport(device->node_type) != RDMA_TRANSPORT_IB)\r\nreturn;\r\nucm_dev = kzalloc(sizeof *ucm_dev, GFP_KERNEL);\r\nif (!ucm_dev)\r\nreturn;\r\nucm_dev->ib_dev = device;\r\ndevnum = find_first_zero_bit(dev_map, IB_UCM_MAX_DEVICES);\r\nif (devnum >= IB_UCM_MAX_DEVICES) {\r\ndevnum = find_overflow_devnum();\r\nif (devnum < 0)\r\ngoto err;\r\nucm_dev->devnum = devnum + IB_UCM_MAX_DEVICES;\r\nbase = devnum + overflow_maj;\r\nset_bit(devnum, overflow_map);\r\n} else {\r\nucm_dev->devnum = devnum;\r\nbase = devnum + IB_UCM_BASE_DEV;\r\nset_bit(devnum, dev_map);\r\n}\r\ncdev_init(&ucm_dev->cdev, &ucm_fops);\r\nucm_dev->cdev.owner = THIS_MODULE;\r\nkobject_set_name(&ucm_dev->cdev.kobj, "ucm%d", ucm_dev->devnum);\r\nif (cdev_add(&ucm_dev->cdev, base, 1))\r\ngoto err;\r\nucm_dev->dev.class = &cm_class;\r\nucm_dev->dev.parent = device->dma_device;\r\nucm_dev->dev.devt = ucm_dev->cdev.dev;\r\nucm_dev->dev.release = ib_ucm_release_dev;\r\ndev_set_name(&ucm_dev->dev, "ucm%d", ucm_dev->devnum);\r\nif (device_register(&ucm_dev->dev))\r\ngoto err_cdev;\r\nif (device_create_file(&ucm_dev->dev, &dev_attr_ibdev))\r\ngoto err_dev;\r\nib_set_client_data(device, &ucm_client, ucm_dev);\r\nreturn;\r\nerr_dev:\r\ndevice_unregister(&ucm_dev->dev);\r\nerr_cdev:\r\ncdev_del(&ucm_dev->cdev);\r\nif (ucm_dev->devnum < IB_UCM_MAX_DEVICES)\r\nclear_bit(devnum, dev_map);\r\nelse\r\nclear_bit(devnum, overflow_map);\r\nerr:\r\nkfree(ucm_dev);\r\nreturn;\r\n}\r\nstatic void ib_ucm_remove_one(struct ib_device *device)\r\n{\r\nstruct ib_ucm_device *ucm_dev = ib_get_client_data(device, &ucm_client);\r\nif (!ucm_dev)\r\nreturn;\r\ndevice_unregister(&ucm_dev->dev);\r\n}\r\nstatic int __init ib_ucm_init(void)\r\n{\r\nint ret;\r\nret = register_chrdev_region(IB_UCM_BASE_DEV, IB_UCM_MAX_DEVICES,\r\n"infiniband_cm");\r\nif (ret) {\r\nprintk(KERN_ERR "ucm: couldn't register device number\n");\r\ngoto error1;\r\n}\r\nret = class_create_file(&cm_class, &class_attr_abi_version.attr);\r\nif (ret) {\r\nprintk(KERN_ERR "ucm: couldn't create abi_version attribute\n");\r\ngoto error2;\r\n}\r\nret = ib_register_client(&ucm_client);\r\nif (ret) {\r\nprintk(KERN_ERR "ucm: couldn't register client\n");\r\ngoto error3;\r\n}\r\nreturn 0;\r\nerror3:\r\nclass_remove_file(&cm_class, &class_attr_abi_version.attr);\r\nerror2:\r\nunregister_chrdev_region(IB_UCM_BASE_DEV, IB_UCM_MAX_DEVICES);\r\nerror1:\r\nreturn ret;\r\n}\r\nstatic void __exit ib_ucm_cleanup(void)\r\n{\r\nib_unregister_client(&ucm_client);\r\nclass_remove_file(&cm_class, &class_attr_abi_version.attr);\r\nunregister_chrdev_region(IB_UCM_BASE_DEV, IB_UCM_MAX_DEVICES);\r\nif (overflow_maj)\r\nunregister_chrdev_region(overflow_maj, IB_UCM_MAX_DEVICES);\r\nidr_destroy(&ctx_id_table);\r\n}
