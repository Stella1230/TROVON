static int dcscb_power_up(unsigned int cpu, unsigned int cluster)\r\n{\r\nunsigned int rst_hold, cpumask = (1 << cpu);\r\nunsigned int all_mask;\r\npr_debug("%s: cpu %u cluster %u\n", __func__, cpu, cluster);\r\nif (cpu >= 4 || cluster >= 2)\r\nreturn -EINVAL;\r\nall_mask = dcscb_allcpus_mask[cluster];\r\nlocal_irq_disable();\r\narch_spin_lock(&dcscb_lock);\r\ndcscb_use_count[cpu][cluster]++;\r\nif (dcscb_use_count[cpu][cluster] == 1) {\r\nrst_hold = readl_relaxed(dcscb_base + RST_HOLD0 + cluster * 4);\r\nif (rst_hold & (1 << 8)) {\r\nrst_hold &= ~(1 << 8);\r\nrst_hold |= all_mask;\r\n}\r\nrst_hold &= ~(cpumask | (cpumask << 4));\r\nwritel_relaxed(rst_hold, dcscb_base + RST_HOLD0 + cluster * 4);\r\n} else if (dcscb_use_count[cpu][cluster] != 2) {\r\nBUG();\r\n}\r\narch_spin_unlock(&dcscb_lock);\r\nlocal_irq_enable();\r\nreturn 0;\r\n}\r\nstatic void dcscb_power_down(void)\r\n{\r\nunsigned int mpidr, cpu, cluster, rst_hold, cpumask, all_mask;\r\nbool last_man = false, skip_wfi = false;\r\nmpidr = read_cpuid_mpidr();\r\ncpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);\r\ncluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);\r\ncpumask = (1 << cpu);\r\npr_debug("%s: cpu %u cluster %u\n", __func__, cpu, cluster);\r\nBUG_ON(cpu >= 4 || cluster >= 2);\r\nall_mask = dcscb_allcpus_mask[cluster];\r\n__mcpm_cpu_going_down(cpu, cluster);\r\narch_spin_lock(&dcscb_lock);\r\nBUG_ON(__mcpm_cluster_state(cluster) != CLUSTER_UP);\r\ndcscb_use_count[cpu][cluster]--;\r\nif (dcscb_use_count[cpu][cluster] == 0) {\r\nrst_hold = readl_relaxed(dcscb_base + RST_HOLD0 + cluster * 4);\r\nrst_hold |= cpumask;\r\nif (((rst_hold | (rst_hold >> 4)) & all_mask) == all_mask) {\r\nrst_hold |= (1 << 8);\r\nlast_man = true;\r\n}\r\nwritel_relaxed(rst_hold, dcscb_base + RST_HOLD0 + cluster * 4);\r\n} else if (dcscb_use_count[cpu][cluster] == 1) {\r\nskip_wfi = true;\r\n} else\r\nBUG();\r\nif (last_man && __mcpm_outbound_enter_critical(cpu, cluster)) {\r\narch_spin_unlock(&dcscb_lock);\r\nv7_exit_coherency_flush(all);\r\ncci_disable_port_by_cpu(mpidr);\r\n__mcpm_outbound_leave_critical(cluster, CLUSTER_DOWN);\r\n} else {\r\narch_spin_unlock(&dcscb_lock);\r\nv7_exit_coherency_flush(louis);\r\n}\r\n__mcpm_cpu_down(cpu, cluster);\r\ndsb();\r\nif (!skip_wfi)\r\nwfi();\r\n}\r\nstatic void __init dcscb_usage_count_init(void)\r\n{\r\nunsigned int mpidr, cpu, cluster;\r\nmpidr = read_cpuid_mpidr();\r\ncpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);\r\ncluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);\r\npr_debug("%s: cpu %u cluster %u\n", __func__, cpu, cluster);\r\nBUG_ON(cpu >= 4 || cluster >= 2);\r\ndcscb_use_count[cpu][cluster] = 1;\r\n}\r\nstatic int __init dcscb_init(void)\r\n{\r\nstruct device_node *node;\r\nunsigned int cfg;\r\nint ret;\r\nif (!cci_probed())\r\nreturn -ENODEV;\r\nnode = of_find_compatible_node(NULL, NULL, "arm,rtsm,dcscb");\r\nif (!node)\r\nreturn -ENODEV;\r\ndcscb_base = of_iomap(node, 0);\r\nif (!dcscb_base)\r\nreturn -EADDRNOTAVAIL;\r\ncfg = readl_relaxed(dcscb_base + DCS_CFG_R);\r\ndcscb_allcpus_mask[0] = (1 << (((cfg >> 16) >> (0 << 2)) & 0xf)) - 1;\r\ndcscb_allcpus_mask[1] = (1 << (((cfg >> 16) >> (1 << 2)) & 0xf)) - 1;\r\ndcscb_usage_count_init();\r\nret = mcpm_platform_register(&dcscb_power_ops);\r\nif (!ret)\r\nret = mcpm_sync_init(dcscb_power_up_setup);\r\nif (ret) {\r\niounmap(dcscb_base);\r\nreturn ret;\r\n}\r\npr_info("VExpress DCSCB support installed\n");\r\nvexpress_flags_set(virt_to_phys(mcpm_entry_point));\r\nreturn 0;\r\n}
