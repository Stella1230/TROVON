static int mxs_spi_setup_transfer(struct spi_device *dev,\r\nconst struct spi_transfer *t)\r\n{\r\nstruct mxs_spi *spi = spi_master_get_devdata(dev->master);\r\nstruct mxs_ssp *ssp = &spi->ssp;\r\nconst unsigned int hz = min(dev->max_speed_hz, t->speed_hz);\r\nif (hz == 0) {\r\ndev_err(&dev->dev, "SPI clock rate of zero not allowed\n");\r\nreturn -EINVAL;\r\n}\r\nif (hz != spi->sck) {\r\nmxs_ssp_set_clk_rate(ssp, hz);\r\nspi->sck = hz;\r\n}\r\nwritel(BM_SSP_CTRL0_LOCK_CS,\r\nssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);\r\nwritel(BF_SSP_CTRL1_SSP_MODE(BV_SSP_CTRL1_SSP_MODE__SPI) |\r\nBF_SSP_CTRL1_WORD_LENGTH(BV_SSP_CTRL1_WORD_LENGTH__EIGHT_BITS) |\r\n((dev->mode & SPI_CPOL) ? BM_SSP_CTRL1_POLARITY : 0) |\r\n((dev->mode & SPI_CPHA) ? BM_SSP_CTRL1_PHASE : 0),\r\nssp->base + HW_SSP_CTRL1(ssp));\r\nwritel(0x0, ssp->base + HW_SSP_CMD0);\r\nwritel(0x0, ssp->base + HW_SSP_CMD1);\r\nreturn 0;\r\n}\r\nstatic u32 mxs_spi_cs_to_reg(unsigned cs)\r\n{\r\nu32 select = 0;\r\nif (cs & 1)\r\nselect |= BM_SSP_CTRL0_WAIT_FOR_CMD;\r\nif (cs & 2)\r\nselect |= BM_SSP_CTRL0_WAIT_FOR_IRQ;\r\nreturn select;\r\n}\r\nstatic int mxs_ssp_wait(struct mxs_spi *spi, int offset, int mask, bool set)\r\n{\r\nconst unsigned long timeout = jiffies + msecs_to_jiffies(SSP_TIMEOUT);\r\nstruct mxs_ssp *ssp = &spi->ssp;\r\nu32 reg;\r\ndo {\r\nreg = readl_relaxed(ssp->base + offset);\r\nif (!set)\r\nreg = ~reg;\r\nreg &= mask;\r\nif (reg == mask)\r\nreturn 0;\r\n} while (time_before(jiffies, timeout));\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void mxs_ssp_dma_irq_callback(void *param)\r\n{\r\nstruct mxs_spi *spi = param;\r\ncomplete(&spi->c);\r\n}\r\nstatic irqreturn_t mxs_ssp_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct mxs_ssp *ssp = dev_id;\r\ndev_err(ssp->dev, "%s[%i] CTRL1=%08x STATUS=%08x\n",\r\n__func__, __LINE__,\r\nreadl(ssp->base + HW_SSP_CTRL1(ssp)),\r\nreadl(ssp->base + HW_SSP_STATUS(ssp)));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mxs_spi_txrx_dma(struct mxs_spi *spi,\r\nunsigned char *buf, int len,\r\nunsigned int flags)\r\n{\r\nstruct mxs_ssp *ssp = &spi->ssp;\r\nstruct dma_async_tx_descriptor *desc = NULL;\r\nconst bool vmalloced_buf = is_vmalloc_addr(buf);\r\nconst int desc_len = vmalloced_buf ? PAGE_SIZE : SG_MAXLEN;\r\nconst int sgs = DIV_ROUND_UP(len, desc_len);\r\nint sg_count;\r\nint min, ret;\r\nu32 ctrl0;\r\nstruct page *vm_page;\r\nvoid *sg_buf;\r\nstruct {\r\nu32 pio[4];\r\nstruct scatterlist sg;\r\n} *dma_xfer;\r\nif (!len)\r\nreturn -EINVAL;\r\ndma_xfer = kzalloc(sizeof(*dma_xfer) * sgs, GFP_KERNEL);\r\nif (!dma_xfer)\r\nreturn -ENOMEM;\r\nreinit_completion(&spi->c);\r\nctrl0 = readl(ssp->base + HW_SSP_CTRL0);\r\nctrl0 &= ~(BM_SSP_CTRL0_XFER_COUNT | BM_SSP_CTRL0_IGNORE_CRC |\r\nBM_SSP_CTRL0_READ);\r\nctrl0 |= BM_SSP_CTRL0_DATA_XFER;\r\nif (!(flags & TXRX_WRITE))\r\nctrl0 |= BM_SSP_CTRL0_READ;\r\nfor (sg_count = 0; sg_count < sgs; sg_count++) {\r\nmin = min(len, desc_len);\r\nif ((sg_count + 1 == sgs) && (flags & TXRX_DEASSERT_CS))\r\nctrl0 |= BM_SSP_CTRL0_IGNORE_CRC;\r\nif (ssp->devid == IMX23_SSP) {\r\nctrl0 &= ~BM_SSP_CTRL0_XFER_COUNT;\r\nctrl0 |= min;\r\n}\r\ndma_xfer[sg_count].pio[0] = ctrl0;\r\ndma_xfer[sg_count].pio[3] = min;\r\nif (vmalloced_buf) {\r\nvm_page = vmalloc_to_page(buf);\r\nif (!vm_page) {\r\nret = -ENOMEM;\r\ngoto err_vmalloc;\r\n}\r\nsg_buf = page_address(vm_page) +\r\n((size_t)buf & ~PAGE_MASK);\r\n} else {\r\nsg_buf = buf;\r\n}\r\nsg_init_one(&dma_xfer[sg_count].sg, sg_buf, min);\r\nret = dma_map_sg(ssp->dev, &dma_xfer[sg_count].sg, 1,\r\n(flags & TXRX_WRITE) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\r\nlen -= min;\r\nbuf += min;\r\ndesc = dmaengine_prep_slave_sg(ssp->dmach,\r\n(struct scatterlist *)dma_xfer[sg_count].pio,\r\n(ssp->devid == IMX23_SSP) ? 1 : 4,\r\nDMA_TRANS_NONE,\r\nsg_count ? DMA_PREP_INTERRUPT : 0);\r\nif (!desc) {\r\ndev_err(ssp->dev,\r\n"Failed to get PIO reg. write descriptor.\n");\r\nret = -EINVAL;\r\ngoto err_mapped;\r\n}\r\ndesc = dmaengine_prep_slave_sg(ssp->dmach,\r\n&dma_xfer[sg_count].sg, 1,\r\n(flags & TXRX_WRITE) ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc) {\r\ndev_err(ssp->dev,\r\n"Failed to get DMA data write descriptor.\n");\r\nret = -EINVAL;\r\ngoto err_mapped;\r\n}\r\n}\r\ndesc->callback = mxs_ssp_dma_irq_callback;\r\ndesc->callback_param = spi;\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(ssp->dmach);\r\nret = wait_for_completion_timeout(&spi->c,\r\nmsecs_to_jiffies(SSP_TIMEOUT));\r\nif (!ret) {\r\ndev_err(ssp->dev, "DMA transfer timeout\n");\r\nret = -ETIMEDOUT;\r\ndmaengine_terminate_all(ssp->dmach);\r\ngoto err_vmalloc;\r\n}\r\nret = 0;\r\nerr_vmalloc:\r\nwhile (--sg_count >= 0) {\r\nerr_mapped:\r\ndma_unmap_sg(ssp->dev, &dma_xfer[sg_count].sg, 1,\r\n(flags & TXRX_WRITE) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\r\n}\r\nkfree(dma_xfer);\r\nreturn ret;\r\n}\r\nstatic int mxs_spi_txrx_pio(struct mxs_spi *spi,\r\nunsigned char *buf, int len,\r\nunsigned int flags)\r\n{\r\nstruct mxs_ssp *ssp = &spi->ssp;\r\nwritel(BM_SSP_CTRL0_IGNORE_CRC,\r\nssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_CLR);\r\nwhile (len--) {\r\nif (len == 0 && (flags & TXRX_DEASSERT_CS))\r\nwritel(BM_SSP_CTRL0_IGNORE_CRC,\r\nssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);\r\nif (ssp->devid == IMX23_SSP) {\r\nwritel(BM_SSP_CTRL0_XFER_COUNT,\r\nssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_CLR);\r\nwritel(1,\r\nssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);\r\n} else {\r\nwritel(1, ssp->base + HW_SSP_XFER_SIZE);\r\n}\r\nif (flags & TXRX_WRITE)\r\nwritel(BM_SSP_CTRL0_READ,\r\nssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_CLR);\r\nelse\r\nwritel(BM_SSP_CTRL0_READ,\r\nssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);\r\nwritel(BM_SSP_CTRL0_RUN,\r\nssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);\r\nif (mxs_ssp_wait(spi, HW_SSP_CTRL0, BM_SSP_CTRL0_RUN, 1))\r\nreturn -ETIMEDOUT;\r\nif (flags & TXRX_WRITE)\r\nwritel(*buf, ssp->base + HW_SSP_DATA(ssp));\r\nwritel(BM_SSP_CTRL0_DATA_XFER,\r\nssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);\r\nif (!(flags & TXRX_WRITE)) {\r\nif (mxs_ssp_wait(spi, HW_SSP_STATUS(ssp),\r\nBM_SSP_STATUS_FIFO_EMPTY, 0))\r\nreturn -ETIMEDOUT;\r\n*buf = (readl(ssp->base + HW_SSP_DATA(ssp)) & 0xff);\r\n}\r\nif (mxs_ssp_wait(spi, HW_SSP_CTRL0, BM_SSP_CTRL0_RUN, 0))\r\nreturn -ETIMEDOUT;\r\nbuf++;\r\n}\r\nif (len <= 0)\r\nreturn 0;\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int mxs_spi_transfer_one(struct spi_master *master,\r\nstruct spi_message *m)\r\n{\r\nstruct mxs_spi *spi = spi_master_get_devdata(master);\r\nstruct mxs_ssp *ssp = &spi->ssp;\r\nstruct spi_transfer *t;\r\nunsigned int flag;\r\nint status = 0;\r\nwritel(BM_SSP_CTRL0_WAIT_FOR_CMD | BM_SSP_CTRL0_WAIT_FOR_IRQ,\r\nssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_CLR);\r\nwritel(mxs_spi_cs_to_reg(m->spi->chip_select),\r\nssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nstatus = mxs_spi_setup_transfer(m->spi, t);\r\nif (status)\r\nbreak;\r\nflag = (&t->transfer_list == m->transfers.prev) ^ t->cs_change ?\r\nTXRX_DEASSERT_CS : 0;\r\nif (t->len < 32) {\r\nwritel(BM_SSP_CTRL1_DMA_ENABLE,\r\nssp->base + HW_SSP_CTRL1(ssp) +\r\nSTMP_OFFSET_REG_CLR);\r\nif (t->tx_buf)\r\nstatus = mxs_spi_txrx_pio(spi,\r\n(void *)t->tx_buf,\r\nt->len, flag | TXRX_WRITE);\r\nif (t->rx_buf)\r\nstatus = mxs_spi_txrx_pio(spi,\r\nt->rx_buf, t->len,\r\nflag);\r\n} else {\r\nwritel(BM_SSP_CTRL1_DMA_ENABLE,\r\nssp->base + HW_SSP_CTRL1(ssp) +\r\nSTMP_OFFSET_REG_SET);\r\nif (t->tx_buf)\r\nstatus = mxs_spi_txrx_dma(spi,\r\n(void *)t->tx_buf, t->len,\r\nflag | TXRX_WRITE);\r\nif (t->rx_buf)\r\nstatus = mxs_spi_txrx_dma(spi,\r\nt->rx_buf, t->len,\r\nflag);\r\n}\r\nif (status) {\r\nstmp_reset_block(ssp->base);\r\nbreak;\r\n}\r\nm->actual_length += t->len;\r\n}\r\nm->status = status;\r\nspi_finalize_current_message(master);\r\nreturn status;\r\n}\r\nstatic int mxs_spi_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(mxs_spi_dt_ids, &pdev->dev);\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct spi_master *master;\r\nstruct mxs_spi *spi;\r\nstruct mxs_ssp *ssp;\r\nstruct resource *iores;\r\nstruct clk *clk;\r\nvoid __iomem *base;\r\nint devid, clk_freq;\r\nint ret = 0, irq_err;\r\nconst int clk_freq_default = 160000000;\r\niores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq_err = platform_get_irq(pdev, 0);\r\nif (irq_err < 0)\r\nreturn irq_err;\r\nbase = devm_ioremap_resource(&pdev->dev, iores);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nclk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\ndevid = (enum mxs_ssp_id) of_id->data;\r\nret = of_property_read_u32(np, "clock-frequency",\r\n&clk_freq);\r\nif (ret)\r\nclk_freq = clk_freq_default;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*spi));\r\nif (!master)\r\nreturn -ENOMEM;\r\nmaster->transfer_one_message = mxs_spi_transfer_one;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8);\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA;\r\nmaster->num_chipselect = 3;\r\nmaster->dev.of_node = np;\r\nmaster->flags = SPI_MASTER_HALF_DUPLEX;\r\nspi = spi_master_get_devdata(master);\r\nssp = &spi->ssp;\r\nssp->dev = &pdev->dev;\r\nssp->clk = clk;\r\nssp->base = base;\r\nssp->devid = devid;\r\ninit_completion(&spi->c);\r\nret = devm_request_irq(&pdev->dev, irq_err, mxs_ssp_irq_handler, 0,\r\nDRIVER_NAME, ssp);\r\nif (ret)\r\ngoto out_master_free;\r\nssp->dmach = dma_request_slave_channel(&pdev->dev, "rx-tx");\r\nif (!ssp->dmach) {\r\ndev_err(ssp->dev, "Failed to request DMA\n");\r\nret = -ENODEV;\r\ngoto out_master_free;\r\n}\r\nret = clk_prepare_enable(ssp->clk);\r\nif (ret)\r\ngoto out_dma_release;\r\nclk_set_rate(ssp->clk, clk_freq);\r\nret = stmp_reset_block(ssp->base);\r\nif (ret)\r\ngoto out_disable_clk;\r\nplatform_set_drvdata(pdev, master);\r\nret = devm_spi_register_master(&pdev->dev, master);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Cannot register SPI master, %d\n", ret);\r\ngoto out_disable_clk;\r\n}\r\nreturn 0;\r\nout_disable_clk:\r\nclk_disable_unprepare(ssp->clk);\r\nout_dma_release:\r\ndma_release_channel(ssp->dmach);\r\nout_master_free:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int mxs_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct mxs_spi *spi;\r\nstruct mxs_ssp *ssp;\r\nmaster = platform_get_drvdata(pdev);\r\nspi = spi_master_get_devdata(master);\r\nssp = &spi->ssp;\r\nclk_disable_unprepare(ssp->clk);\r\ndma_release_channel(ssp->dmach);\r\nreturn 0;\r\n}
