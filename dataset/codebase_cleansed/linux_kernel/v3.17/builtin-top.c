static void perf_top__update_print_entries(struct perf_top *top)\r\n{\r\ntop->print_entries = top->winsize.ws_row - HEADER_LINE_NR;\r\n}\r\nstatic void perf_top__sig_winch(int sig __maybe_unused,\r\nsiginfo_t *info __maybe_unused, void *arg)\r\n{\r\nstruct perf_top *top = arg;\r\nget_term_dimensions(&top->winsize);\r\nperf_top__update_print_entries(top);\r\n}\r\nstatic int perf_top__parse_source(struct perf_top *top, struct hist_entry *he)\r\n{\r\nstruct symbol *sym;\r\nstruct annotation *notes;\r\nstruct map *map;\r\nint err = -1;\r\nif (!he || !he->ms.sym)\r\nreturn -1;\r\nsym = he->ms.sym;\r\nmap = he->ms.map;\r\nif (map->dso->symtab_type == DSO_BINARY_TYPE__KALLSYMS &&\r\n!dso__is_kcore(map->dso)) {\r\npr_err("Can't annotate %s: No vmlinux file was found in the "\r\n"path\n", sym->name);\r\nsleep(1);\r\nreturn -1;\r\n}\r\nnotes = symbol__annotation(sym);\r\nif (notes->src != NULL) {\r\npthread_mutex_lock(&notes->lock);\r\ngoto out_assign;\r\n}\r\npthread_mutex_lock(&notes->lock);\r\nif (symbol__alloc_hist(sym) < 0) {\r\npthread_mutex_unlock(&notes->lock);\r\npr_err("Not enough memory for annotating '%s' symbol!\n",\r\nsym->name);\r\nsleep(1);\r\nreturn err;\r\n}\r\nerr = symbol__annotate(sym, map, 0);\r\nif (err == 0) {\r\nout_assign:\r\ntop->sym_filter_entry = he;\r\n}\r\npthread_mutex_unlock(&notes->lock);\r\nreturn err;\r\n}\r\nstatic void __zero_source_counters(struct hist_entry *he)\r\n{\r\nstruct symbol *sym = he->ms.sym;\r\nsymbol__annotate_zero_histograms(sym);\r\n}\r\nstatic void ui__warn_map_erange(struct map *map, struct symbol *sym, u64 ip)\r\n{\r\nstruct utsname uts;\r\nint err = uname(&uts);\r\nui__warning("Out of bounds address found:\n\n"\r\n"Addr: %" PRIx64 "\n"\r\n"DSO: %s %c\n"\r\n"Map: %" PRIx64 "-%" PRIx64 "\n"\r\n"Symbol: %" PRIx64 "-%" PRIx64 " %c %s\n"\r\n"Arch: %s\n"\r\n"Kernel: %s\n"\r\n"Tools: %s\n\n"\r\n"Not all samples will be on the annotation output.\n\n"\r\n"Please report to linux-kernel@vger.kernel.org\n",\r\nip, map->dso->long_name, dso__symtab_origin(map->dso),\r\nmap->start, map->end, sym->start, sym->end,\r\nsym->binding == STB_GLOBAL ? 'g' :\r\nsym->binding == STB_LOCAL ? 'l' : 'w', sym->name,\r\nerr ? "[unknown]" : uts.machine,\r\nerr ? "[unknown]" : uts.release, perf_version_string);\r\nif (use_browser <= 0)\r\nsleep(5);\r\nmap->erange_warned = true;\r\n}\r\nstatic void perf_top__record_precise_ip(struct perf_top *top,\r\nstruct hist_entry *he,\r\nint counter, u64 ip)\r\n{\r\nstruct annotation *notes;\r\nstruct symbol *sym;\r\nint err = 0;\r\nif (he == NULL || he->ms.sym == NULL ||\r\n((top->sym_filter_entry == NULL ||\r\ntop->sym_filter_entry->ms.sym != he->ms.sym) && use_browser != 1))\r\nreturn;\r\nsym = he->ms.sym;\r\nnotes = symbol__annotation(sym);\r\nif (pthread_mutex_trylock(&notes->lock))\r\nreturn;\r\nip = he->ms.map->map_ip(he->ms.map, ip);\r\nif (ui__has_annotation())\r\nerr = hist_entry__inc_addr_samples(he, counter, ip);\r\npthread_mutex_unlock(&notes->lock);\r\npthread_mutex_unlock(&he->hists->lock);\r\nif (err == -ERANGE && !he->ms.map->erange_warned)\r\nui__warn_map_erange(he->ms.map, sym, ip);\r\nelse if (err == -ENOMEM) {\r\npr_err("Not enough memory for annotating '%s' symbol!\n",\r\nsym->name);\r\nsleep(1);\r\n}\r\npthread_mutex_lock(&he->hists->lock);\r\n}\r\nstatic void perf_top__show_details(struct perf_top *top)\r\n{\r\nstruct hist_entry *he = top->sym_filter_entry;\r\nstruct annotation *notes;\r\nstruct symbol *symbol;\r\nint more;\r\nif (!he)\r\nreturn;\r\nsymbol = he->ms.sym;\r\nnotes = symbol__annotation(symbol);\r\npthread_mutex_lock(&notes->lock);\r\nif (notes->src == NULL)\r\ngoto out_unlock;\r\nprintf("Showing %s for %s\n", perf_evsel__name(top->sym_evsel), symbol->name);\r\nprintf(" Events Pcnt (>=%d%%)\n", top->sym_pcnt_filter);\r\nmore = symbol__annotate_printf(symbol, he->ms.map, top->sym_evsel,\r\n0, top->sym_pcnt_filter, top->print_entries, 4);\r\nif (top->zero)\r\nsymbol__annotate_zero_histogram(symbol, top->sym_evsel->idx);\r\nelse\r\nsymbol__annotate_decay_histogram(symbol, top->sym_evsel->idx);\r\nif (more != 0)\r\nprintf("%d lines not displayed, maybe increase display entries [e]\n", more);\r\nout_unlock:\r\npthread_mutex_unlock(&notes->lock);\r\n}\r\nstatic void perf_top__print_sym_table(struct perf_top *top)\r\n{\r\nchar bf[160];\r\nint printed = 0;\r\nconst int win_width = top->winsize.ws_col - 1;\r\nputs(CONSOLE_CLEAR);\r\nperf_top__header_snprintf(top, bf, sizeof(bf));\r\nprintf("%s\n", bf);\r\nperf_top__reset_sample_counters(top);\r\nprintf("%-*.*s\n", win_width, win_width, graph_dotted_line);\r\nif (top->sym_evsel->hists.stats.nr_lost_warned !=\r\ntop->sym_evsel->hists.stats.nr_events[PERF_RECORD_LOST]) {\r\ntop->sym_evsel->hists.stats.nr_lost_warned =\r\ntop->sym_evsel->hists.stats.nr_events[PERF_RECORD_LOST];\r\ncolor_fprintf(stdout, PERF_COLOR_RED,\r\n"WARNING: LOST %d chunks, Check IO/CPU overload",\r\ntop->sym_evsel->hists.stats.nr_lost_warned);\r\n++printed;\r\n}\r\nif (top->sym_filter_entry) {\r\nperf_top__show_details(top);\r\nreturn;\r\n}\r\nhists__collapse_resort(&top->sym_evsel->hists, NULL);\r\nhists__output_resort(&top->sym_evsel->hists);\r\nhists__decay_entries(&top->sym_evsel->hists,\r\ntop->hide_user_symbols,\r\ntop->hide_kernel_symbols);\r\nhists__output_recalc_col_len(&top->sym_evsel->hists,\r\ntop->print_entries - printed);\r\nputchar('\n');\r\nhists__fprintf(&top->sym_evsel->hists, false,\r\ntop->print_entries - printed, win_width,\r\ntop->min_percent, stdout);\r\n}\r\nstatic void prompt_integer(int *target, const char *msg)\r\n{\r\nchar *buf = malloc(0), *p;\r\nsize_t dummy = 0;\r\nint tmp;\r\nfprintf(stdout, "\n%s: ", msg);\r\nif (getline(&buf, &dummy, stdin) < 0)\r\nreturn;\r\np = strchr(buf, '\n');\r\nif (p)\r\n*p = 0;\r\np = buf;\r\nwhile(*p) {\r\nif (!isdigit(*p))\r\ngoto out_free;\r\np++;\r\n}\r\ntmp = strtoul(buf, NULL, 10);\r\n*target = tmp;\r\nout_free:\r\nfree(buf);\r\n}\r\nstatic void prompt_percent(int *target, const char *msg)\r\n{\r\nint tmp = 0;\r\nprompt_integer(&tmp, msg);\r\nif (tmp >= 0 && tmp <= 100)\r\n*target = tmp;\r\n}\r\nstatic void perf_top__prompt_symbol(struct perf_top *top, const char *msg)\r\n{\r\nchar *buf = malloc(0), *p;\r\nstruct hist_entry *syme = top->sym_filter_entry, *n, *found = NULL;\r\nstruct rb_node *next;\r\nsize_t dummy = 0;\r\nif (syme) {\r\n__zero_source_counters(syme);\r\ntop->sym_filter_entry = NULL;\r\n}\r\nfprintf(stdout, "\n%s: ", msg);\r\nif (getline(&buf, &dummy, stdin) < 0)\r\ngoto out_free;\r\np = strchr(buf, '\n');\r\nif (p)\r\n*p = 0;\r\nnext = rb_first(&top->sym_evsel->hists.entries);\r\nwhile (next) {\r\nn = rb_entry(next, struct hist_entry, rb_node);\r\nif (n->ms.sym && !strcmp(buf, n->ms.sym->name)) {\r\nfound = n;\r\nbreak;\r\n}\r\nnext = rb_next(&n->rb_node);\r\n}\r\nif (!found) {\r\nfprintf(stderr, "Sorry, %s is not active.\n", buf);\r\nsleep(1);\r\n} else\r\nperf_top__parse_source(top, found);\r\nout_free:\r\nfree(buf);\r\n}\r\nstatic void perf_top__print_mapped_keys(struct perf_top *top)\r\n{\r\nchar *name = NULL;\r\nif (top->sym_filter_entry) {\r\nstruct symbol *sym = top->sym_filter_entry->ms.sym;\r\nname = sym->name;\r\n}\r\nfprintf(stdout, "\nMapped keys:\n");\r\nfprintf(stdout, "\t[d] display refresh delay. \t(%d)\n", top->delay_secs);\r\nfprintf(stdout, "\t[e] display entries (lines). \t(%d)\n", top->print_entries);\r\nif (top->evlist->nr_entries > 1)\r\nfprintf(stdout, "\t[E] active event counter. \t(%s)\n", perf_evsel__name(top->sym_evsel));\r\nfprintf(stdout, "\t[f] profile display filter (count). \t(%d)\n", top->count_filter);\r\nfprintf(stdout, "\t[F] annotate display filter (percent). \t(%d%%)\n", top->sym_pcnt_filter);\r\nfprintf(stdout, "\t[s] annotate symbol. \t(%s)\n", name?: "NULL");\r\nfprintf(stdout, "\t[S] stop annotation.\n");\r\nfprintf(stdout,\r\n"\t[K] hide kernel_symbols symbols. \t(%s)\n",\r\ntop->hide_kernel_symbols ? "yes" : "no");\r\nfprintf(stdout,\r\n"\t[U] hide user symbols. \t(%s)\n",\r\ntop->hide_user_symbols ? "yes" : "no");\r\nfprintf(stdout, "\t[z] toggle sample zeroing. \t(%d)\n", top->zero ? 1 : 0);\r\nfprintf(stdout, "\t[qQ] quit.\n");\r\n}\r\nstatic int perf_top__key_mapped(struct perf_top *top, int c)\r\n{\r\nswitch (c) {\r\ncase 'd':\r\ncase 'e':\r\ncase 'f':\r\ncase 'z':\r\ncase 'q':\r\ncase 'Q':\r\ncase 'K':\r\ncase 'U':\r\ncase 'F':\r\ncase 's':\r\ncase 'S':\r\nreturn 1;\r\ncase 'E':\r\nreturn top->evlist->nr_entries > 1 ? 1 : 0;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool perf_top__handle_keypress(struct perf_top *top, int c)\r\n{\r\nbool ret = true;\r\nif (!perf_top__key_mapped(top, c)) {\r\nstruct pollfd stdin_poll = { .fd = 0, .events = POLLIN };\r\nstruct termios tc, save;\r\nperf_top__print_mapped_keys(top);\r\nfprintf(stdout, "\nEnter selection, or unmapped key to continue: ");\r\nfflush(stdout);\r\ntcgetattr(0, &save);\r\ntc = save;\r\ntc.c_lflag &= ~(ICANON | ECHO);\r\ntc.c_cc[VMIN] = 0;\r\ntc.c_cc[VTIME] = 0;\r\ntcsetattr(0, TCSANOW, &tc);\r\npoll(&stdin_poll, 1, -1);\r\nc = getc(stdin);\r\ntcsetattr(0, TCSAFLUSH, &save);\r\nif (!perf_top__key_mapped(top, c))\r\nreturn ret;\r\n}\r\nswitch (c) {\r\ncase 'd':\r\nprompt_integer(&top->delay_secs, "Enter display delay");\r\nif (top->delay_secs < 1)\r\ntop->delay_secs = 1;\r\nbreak;\r\ncase 'e':\r\nprompt_integer(&top->print_entries, "Enter display entries (lines)");\r\nif (top->print_entries == 0) {\r\nstruct sigaction act = {\r\n.sa_sigaction = perf_top__sig_winch,\r\n.sa_flags = SA_SIGINFO,\r\n};\r\nperf_top__sig_winch(SIGWINCH, NULL, top);\r\nsigaction(SIGWINCH, &act, NULL);\r\n} else {\r\nsignal(SIGWINCH, SIG_DFL);\r\n}\r\nbreak;\r\ncase 'E':\r\nif (top->evlist->nr_entries > 1) {\r\nint counter = 0;\r\nfprintf(stderr, "\nAvailable events:");\r\nevlist__for_each(top->evlist, top->sym_evsel)\r\nfprintf(stderr, "\n\t%d %s", top->sym_evsel->idx, perf_evsel__name(top->sym_evsel));\r\nprompt_integer(&counter, "Enter details event counter");\r\nif (counter >= top->evlist->nr_entries) {\r\ntop->sym_evsel = perf_evlist__first(top->evlist);\r\nfprintf(stderr, "Sorry, no such event, using %s.\n", perf_evsel__name(top->sym_evsel));\r\nsleep(1);\r\nbreak;\r\n}\r\nevlist__for_each(top->evlist, top->sym_evsel)\r\nif (top->sym_evsel->idx == counter)\r\nbreak;\r\n} else\r\ntop->sym_evsel = perf_evlist__first(top->evlist);\r\nbreak;\r\ncase 'f':\r\nprompt_integer(&top->count_filter, "Enter display event count filter");\r\nbreak;\r\ncase 'F':\r\nprompt_percent(&top->sym_pcnt_filter,\r\n"Enter details display event filter (percent)");\r\nbreak;\r\ncase 'K':\r\ntop->hide_kernel_symbols = !top->hide_kernel_symbols;\r\nbreak;\r\ncase 'q':\r\ncase 'Q':\r\nprintf("exiting.\n");\r\nif (top->dump_symtab)\r\nperf_session__fprintf_dsos(top->session, stderr);\r\nret = false;\r\nbreak;\r\ncase 's':\r\nperf_top__prompt_symbol(top, "Enter details symbol");\r\nbreak;\r\ncase 'S':\r\nif (!top->sym_filter_entry)\r\nbreak;\r\nelse {\r\nstruct hist_entry *syme = top->sym_filter_entry;\r\ntop->sym_filter_entry = NULL;\r\n__zero_source_counters(syme);\r\n}\r\nbreak;\r\ncase 'U':\r\ntop->hide_user_symbols = !top->hide_user_symbols;\r\nbreak;\r\ncase 'z':\r\ntop->zero = !top->zero;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void perf_top__sort_new_samples(void *arg)\r\n{\r\nstruct perf_top *t = arg;\r\nperf_top__reset_sample_counters(t);\r\nif (t->evlist->selected != NULL)\r\nt->sym_evsel = t->evlist->selected;\r\nhists__collapse_resort(&t->sym_evsel->hists, NULL);\r\nhists__output_resort(&t->sym_evsel->hists);\r\nhists__decay_entries(&t->sym_evsel->hists,\r\nt->hide_user_symbols,\r\nt->hide_kernel_symbols);\r\n}\r\nstatic void *display_thread_tui(void *arg)\r\n{\r\nstruct perf_evsel *pos;\r\nstruct perf_top *top = arg;\r\nconst char *help = "For a higher level overview, try: perf top --sort comm,dso";\r\nstruct hist_browser_timer hbt = {\r\n.timer = perf_top__sort_new_samples,\r\n.arg = top,\r\n.refresh = top->delay_secs,\r\n};\r\nperf_top__sort_new_samples(top);\r\nevlist__for_each(top->evlist, pos)\r\npos->hists.uid_filter_str = top->record_opts.target.uid_str;\r\nperf_evlist__tui_browse_hists(top->evlist, help, &hbt, top->min_percent,\r\n&top->session->header.env);\r\ndone = 1;\r\nreturn NULL;\r\n}\r\nstatic void *display_thread(void *arg)\r\n{\r\nstruct pollfd stdin_poll = { .fd = 0, .events = POLLIN };\r\nstruct termios tc, save;\r\nstruct perf_top *top = arg;\r\nint delay_msecs, c;\r\ntcgetattr(0, &save);\r\ntc = save;\r\ntc.c_lflag &= ~(ICANON | ECHO);\r\ntc.c_cc[VMIN] = 0;\r\ntc.c_cc[VTIME] = 0;\r\npthread__unblock_sigwinch();\r\nrepeat:\r\ndelay_msecs = top->delay_secs * 1000;\r\ntcsetattr(0, TCSANOW, &tc);\r\ngetc(stdin);\r\nwhile (!done) {\r\nperf_top__print_sym_table(top);\r\nswitch (poll(&stdin_poll, 1, delay_msecs)) {\r\ncase 0:\r\ncontinue;\r\ncase -1:\r\nif (errno == EINTR)\r\ncontinue;\r\ndefault:\r\nc = getc(stdin);\r\ntcsetattr(0, TCSAFLUSH, &save);\r\nif (perf_top__handle_keypress(top, c))\r\ngoto repeat;\r\ndone = 1;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int symbol_filter(struct map *map __maybe_unused, struct symbol *sym)\r\n{\r\nconst char *name = sym->name;\r\nif (name[0] == '.')\r\nname++;\r\nif (!strcmp(name, "_text") ||\r\n!strcmp(name, "_etext") ||\r\n!strcmp(name, "_sinittext") ||\r\n!strncmp("init_module", name, 11) ||\r\n!strncmp("cleanup_module", name, 14) ||\r\nstrstr(name, "_text_start") ||\r\nstrstr(name, "_text_end"))\r\nreturn 1;\r\nif (symbol__is_idle(sym))\r\nsym->ignore = true;\r\nreturn 0;\r\n}\r\nstatic int hist_iter__top_callback(struct hist_entry_iter *iter,\r\nstruct addr_location *al, bool single,\r\nvoid *arg)\r\n{\r\nstruct perf_top *top = arg;\r\nstruct hist_entry *he = iter->he;\r\nstruct perf_evsel *evsel = iter->evsel;\r\nif (sort__has_sym && single) {\r\nu64 ip = al->addr;\r\nif (al->map)\r\nip = al->map->unmap_ip(al->map, ip);\r\nperf_top__record_precise_ip(top, he, evsel->idx, ip);\r\n}\r\nreturn 0;\r\n}\r\nstatic void perf_event__process_sample(struct perf_tool *tool,\r\nconst union perf_event *event,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nstruct perf_top *top = container_of(tool, struct perf_top, tool);\r\nstruct addr_location al;\r\nint err;\r\nif (!machine && perf_guest) {\r\nstatic struct intlist *seen;\r\nif (!seen)\r\nseen = intlist__new(NULL);\r\nif (!intlist__has_entry(seen, sample->pid)) {\r\npr_err("Can't find guest [%d]'s kernel information\n",\r\nsample->pid);\r\nintlist__add(seen, sample->pid);\r\n}\r\nreturn;\r\n}\r\nif (!machine) {\r\npr_err("%u unprocessable samples recorded.\r",\r\ntop->session->stats.nr_unprocessable_samples++);\r\nreturn;\r\n}\r\nif (event->header.misc & PERF_RECORD_MISC_EXACT_IP)\r\ntop->exact_samples++;\r\nif (perf_event__preprocess_sample(event, machine, &al, sample) < 0)\r\nreturn;\r\nif (!top->kptr_restrict_warned &&\r\nsymbol_conf.kptr_restrict &&\r\nal.cpumode == PERF_RECORD_MISC_KERNEL) {\r\nui__warning(\r\n"Kernel address maps (/proc/{kallsyms,modules}) are restricted.\n\n"\r\n"Check /proc/sys/kernel/kptr_restrict.\n\n"\r\n"Kernel%s samples will not be resolved.\n",\r\n!RB_EMPTY_ROOT(&al.map->dso->symbols[MAP__FUNCTION]) ?\r\n" modules" : "");\r\nif (use_browser <= 0)\r\nsleep(5);\r\ntop->kptr_restrict_warned = true;\r\n}\r\nif (al.sym == NULL) {\r\nconst char *msg = "Kernel samples will not be resolved.\n";\r\nif (!top->kptr_restrict_warned && !top->vmlinux_warned &&\r\nal.map == machine->vmlinux_maps[MAP__FUNCTION] &&\r\nRB_EMPTY_ROOT(&al.map->dso->symbols[MAP__FUNCTION])) {\r\nif (symbol_conf.vmlinux_name) {\r\nui__warning("The %s file can't be used.\n%s",\r\nsymbol_conf.vmlinux_name, msg);\r\n} else {\r\nui__warning("A vmlinux file was not found.\n%s",\r\nmsg);\r\n}\r\nif (use_browser <= 0)\r\nsleep(5);\r\ntop->vmlinux_warned = true;\r\n}\r\n}\r\nif (al.sym == NULL || !al.sym->ignore) {\r\nstruct hist_entry_iter iter = {\r\n.add_entry_cb = hist_iter__top_callback,\r\n};\r\nif (symbol_conf.cumulate_callchain)\r\niter.ops = &hist_iter_cumulative;\r\nelse\r\niter.ops = &hist_iter_normal;\r\npthread_mutex_lock(&evsel->hists.lock);\r\nerr = hist_entry_iter__add(&iter, &al, evsel, sample,\r\ntop->max_stack, top);\r\nif (err < 0)\r\npr_err("Problem incrementing symbol period, skipping event\n");\r\npthread_mutex_unlock(&evsel->hists.lock);\r\n}\r\nreturn;\r\n}\r\nstatic void perf_top__mmap_read_idx(struct perf_top *top, int idx)\r\n{\r\nstruct perf_sample sample;\r\nstruct perf_evsel *evsel;\r\nstruct perf_session *session = top->session;\r\nunion perf_event *event;\r\nstruct machine *machine;\r\nu8 origin;\r\nint ret;\r\nwhile ((event = perf_evlist__mmap_read(top->evlist, idx)) != NULL) {\r\nret = perf_evlist__parse_sample(top->evlist, event, &sample);\r\nif (ret) {\r\npr_err("Can't parse sample, err = %d\n", ret);\r\ngoto next_event;\r\n}\r\nevsel = perf_evlist__id2evsel(session->evlist, sample.id);\r\nassert(evsel != NULL);\r\norigin = event->header.misc & PERF_RECORD_MISC_CPUMODE_MASK;\r\nif (event->header.type == PERF_RECORD_SAMPLE)\r\n++top->samples;\r\nswitch (origin) {\r\ncase PERF_RECORD_MISC_USER:\r\n++top->us_samples;\r\nif (top->hide_user_symbols)\r\ngoto next_event;\r\nmachine = &session->machines.host;\r\nbreak;\r\ncase PERF_RECORD_MISC_KERNEL:\r\n++top->kernel_samples;\r\nif (top->hide_kernel_symbols)\r\ngoto next_event;\r\nmachine = &session->machines.host;\r\nbreak;\r\ncase PERF_RECORD_MISC_GUEST_KERNEL:\r\n++top->guest_kernel_samples;\r\nmachine = perf_session__find_machine(session,\r\nsample.pid);\r\nbreak;\r\ncase PERF_RECORD_MISC_GUEST_USER:\r\n++top->guest_us_samples;\r\ndefault:\r\ngoto next_event;\r\n}\r\nif (event->header.type == PERF_RECORD_SAMPLE) {\r\nperf_event__process_sample(&top->tool, event, evsel,\r\n&sample, machine);\r\n} else if (event->header.type < PERF_RECORD_MAX) {\r\nhists__inc_nr_events(&evsel->hists, event->header.type);\r\nmachine__process_event(machine, event, &sample);\r\n} else\r\n++session->stats.nr_unknown_events;\r\nnext_event:\r\nperf_evlist__mmap_consume(top->evlist, idx);\r\n}\r\n}\r\nstatic void perf_top__mmap_read(struct perf_top *top)\r\n{\r\nint i;\r\nfor (i = 0; i < top->evlist->nr_mmaps; i++)\r\nperf_top__mmap_read_idx(top, i);\r\n}\r\nstatic int perf_top__start_counters(struct perf_top *top)\r\n{\r\nchar msg[512];\r\nstruct perf_evsel *counter;\r\nstruct perf_evlist *evlist = top->evlist;\r\nstruct record_opts *opts = &top->record_opts;\r\nperf_evlist__config(evlist, opts);\r\nevlist__for_each(evlist, counter) {\r\ntry_again:\r\nif (perf_evsel__open(counter, top->evlist->cpus,\r\ntop->evlist->threads) < 0) {\r\nif (perf_evsel__fallback(counter, errno, msg, sizeof(msg))) {\r\nif (verbose)\r\nui__warning("%s\n", msg);\r\ngoto try_again;\r\n}\r\nperf_evsel__open_strerror(counter, &opts->target,\r\nerrno, msg, sizeof(msg));\r\nui__error("%s\n", msg);\r\ngoto out_err;\r\n}\r\n}\r\nif (perf_evlist__mmap(evlist, opts->mmap_pages, false) < 0) {\r\nui__error("Failed to mmap with %d (%s)\n",\r\nerrno, strerror(errno));\r\ngoto out_err;\r\n}\r\nreturn 0;\r\nout_err:\r\nreturn -1;\r\n}\r\nstatic int perf_top__setup_sample_type(struct perf_top *top __maybe_unused)\r\n{\r\nif (!sort__has_sym) {\r\nif (symbol_conf.use_callchain) {\r\nui__error("Selected -g but \"sym\" not present in --sort/-s.");\r\nreturn -EINVAL;\r\n}\r\n} else if (callchain_param.mode != CHAIN_NONE) {\r\nif (callchain_register_param(&callchain_param) < 0) {\r\nui__error("Can't register callchain params.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __cmd_top(struct perf_top *top)\r\n{\r\nstruct record_opts *opts = &top->record_opts;\r\npthread_t thread;\r\nint ret;\r\ntop->session = perf_session__new(NULL, false, NULL);\r\nif (top->session == NULL)\r\nreturn -ENOMEM;\r\nmachines__set_symbol_filter(&top->session->machines, symbol_filter);\r\nif (!objdump_path) {\r\nret = perf_session_env__lookup_objdump(&top->session->header.env);\r\nif (ret)\r\ngoto out_delete;\r\n}\r\nret = perf_top__setup_sample_type(top);\r\nif (ret)\r\ngoto out_delete;\r\nmachine__synthesize_threads(&top->session->machines.host, &opts->target,\r\ntop->evlist->threads, false);\r\nret = perf_top__start_counters(top);\r\nif (ret)\r\ngoto out_delete;\r\ntop->session->evlist = top->evlist;\r\nperf_session__set_id_hdr_size(top->session);\r\nif (!target__none(&opts->target))\r\nperf_evlist__enable(top->evlist);\r\npoll(top->evlist->pollfd, top->evlist->nr_fds, 100);\r\nperf_top__mmap_read(top);\r\nret = -1;\r\nif (pthread_create(&thread, NULL, (use_browser > 0 ? display_thread_tui :\r\ndisplay_thread), top)) {\r\nui__error("Could not create display thread.\n");\r\ngoto out_delete;\r\n}\r\nif (top->realtime_prio) {\r\nstruct sched_param param;\r\nparam.sched_priority = top->realtime_prio;\r\nif (sched_setscheduler(0, SCHED_FIFO, &param)) {\r\nui__error("Could not set realtime priority.\n");\r\ngoto out_delete;\r\n}\r\n}\r\nwhile (!done) {\r\nu64 hits = top->samples;\r\nperf_top__mmap_read(top);\r\nif (hits == top->samples)\r\nret = poll(top->evlist->pollfd, top->evlist->nr_fds, 100);\r\n}\r\nret = 0;\r\nout_delete:\r\nperf_session__delete(top->session);\r\ntop->session = NULL;\r\nreturn ret;\r\n}\r\nstatic int\r\ncallchain_opt(const struct option *opt, const char *arg, int unset)\r\n{\r\nsymbol_conf.use_callchain = true;\r\nreturn record_callchain_opt(opt, arg, unset);\r\n}\r\nstatic int\r\nparse_callchain_opt(const struct option *opt, const char *arg, int unset)\r\n{\r\nsymbol_conf.use_callchain = true;\r\nreturn record_parse_callchain_opt(opt, arg, unset);\r\n}\r\nstatic int perf_top_config(const char *var, const char *value, void *cb)\r\n{\r\nstruct perf_top *top = cb;\r\nif (!strcmp(var, "top.call-graph"))\r\nreturn record_parse_callchain(value, &top->record_opts);\r\nif (!strcmp(var, "top.children")) {\r\nsymbol_conf.cumulate_callchain = perf_config_bool(var, value);\r\nreturn 0;\r\n}\r\nreturn perf_default_config(var, value, cb);\r\n}\r\nstatic int\r\nparse_percent_limit(const struct option *opt, const char *arg,\r\nint unset __maybe_unused)\r\n{\r\nstruct perf_top *top = opt->value;\r\ntop->min_percent = strtof(arg, NULL);\r\nreturn 0;\r\n}\r\nint cmd_top(int argc, const char **argv, const char *prefix __maybe_unused)\r\n{\r\nint status = -1;\r\nchar errbuf[BUFSIZ];\r\nstruct perf_top top = {\r\n.count_filter = 5,\r\n.delay_secs = 2,\r\n.record_opts = {\r\n.mmap_pages = UINT_MAX,\r\n.user_freq = UINT_MAX,\r\n.user_interval = ULLONG_MAX,\r\n.freq = 4000,\r\n.target = {\r\n.uses_mmap = true,\r\n},\r\n},\r\n.max_stack = PERF_MAX_STACK_DEPTH,\r\n.sym_pcnt_filter = 5,\r\n};\r\nstruct record_opts *opts = &top.record_opts;\r\nstruct target *target = &opts->target;\r\nconst struct option options[] = {\r\nOPT_CALLBACK('e', "event", &top.evlist, "event",\r\n"event selector. use 'perf list' to list available events",\r\nparse_events_option),\r\nOPT_U64('c', "count", &opts->user_interval, "event period to sample"),\r\nOPT_STRING('p', "pid", &target->pid, "pid",\r\n"profile events on existing process id"),\r\nOPT_STRING('t', "tid", &target->tid, "tid",\r\n"profile events on existing thread id"),\r\nOPT_BOOLEAN('a', "all-cpus", &target->system_wide,\r\n"system-wide collection from all CPUs"),\r\nOPT_STRING('C', "cpu", &target->cpu_list, "cpu",\r\n"list of cpus to monitor"),\r\nOPT_STRING('k', "vmlinux", &symbol_conf.vmlinux_name,\r\n"file", "vmlinux pathname"),\r\nOPT_BOOLEAN(0, "ignore-vmlinux", &symbol_conf.ignore_vmlinux,\r\n"don't load vmlinux even if found"),\r\nOPT_BOOLEAN('K', "hide_kernel_symbols", &top.hide_kernel_symbols,\r\n"hide kernel symbols"),\r\nOPT_CALLBACK('m', "mmap-pages", &opts->mmap_pages, "pages",\r\n"number of mmap data pages",\r\nperf_evlist__parse_mmap_pages),\r\nOPT_INTEGER('r', "realtime", &top.realtime_prio,\r\n"collect data with this RT SCHED_FIFO priority"),\r\nOPT_INTEGER('d', "delay", &top.delay_secs,\r\n"number of seconds to delay between refreshes"),\r\nOPT_BOOLEAN('D', "dump-symtab", &top.dump_symtab,\r\n"dump the symbol table used for profiling"),\r\nOPT_INTEGER('f', "count-filter", &top.count_filter,\r\n"only display functions with more events than this"),\r\nOPT_BOOLEAN(0, "group", &opts->group,\r\n"put the counters into a counter group"),\r\nOPT_BOOLEAN('i', "no-inherit", &opts->no_inherit,\r\n"child tasks do not inherit counters"),\r\nOPT_STRING(0, "sym-annotate", &top.sym_filter, "symbol name",\r\n"symbol to annotate"),\r\nOPT_BOOLEAN('z', "zero", &top.zero, "zero history across updates"),\r\nOPT_UINTEGER('F', "freq", &opts->user_freq, "profile at this frequency"),\r\nOPT_INTEGER('E', "entries", &top.print_entries,\r\n"display this many functions"),\r\nOPT_BOOLEAN('U', "hide_user_symbols", &top.hide_user_symbols,\r\n"hide user symbols"),\r\nOPT_BOOLEAN(0, "tui", &top.use_tui, "Use the TUI interface"),\r\nOPT_BOOLEAN(0, "stdio", &top.use_stdio, "Use the stdio interface"),\r\nOPT_INCR('v', "verbose", &verbose,\r\n"be more verbose (show counter open errors, etc)"),\r\nOPT_STRING('s', "sort", &sort_order, "key[,key2...]",\r\n"sort by key(s): pid, comm, dso, symbol, parent, cpu, srcline, ..."\r\n" Please refer the man page for the complete list."),\r\nOPT_STRING(0, "fields", &field_order, "key[,keys...]",\r\n"output field(s): overhead, period, sample plus all of sort keys"),\r\nOPT_BOOLEAN('n', "show-nr-samples", &symbol_conf.show_nr_samples,\r\n"Show a column with the number of samples"),\r\nOPT_CALLBACK_NOOPT('g', NULL, &top.record_opts,\r\nNULL, "enables call-graph recording",\r\n&callchain_opt),\r\nOPT_CALLBACK(0, "call-graph", &top.record_opts,\r\n"mode[,dump_size]", record_callchain_help,\r\n&parse_callchain_opt),\r\nOPT_BOOLEAN(0, "children", &symbol_conf.cumulate_callchain,\r\n"Accumulate callchains of children and show total overhead as well"),\r\nOPT_INTEGER(0, "max-stack", &top.max_stack,\r\n"Set the maximum stack depth when parsing the callchain. "\r\n"Default: " __stringify(PERF_MAX_STACK_DEPTH)),\r\nOPT_CALLBACK(0, "ignore-callees", NULL, "regex",\r\n"ignore callees of these functions in call graphs",\r\nreport_parse_ignore_callees_opt),\r\nOPT_BOOLEAN(0, "show-total-period", &symbol_conf.show_total_period,\r\n"Show a column with the sum of periods"),\r\nOPT_STRING(0, "dsos", &symbol_conf.dso_list_str, "dso[,dso...]",\r\n"only consider symbols in these dsos"),\r\nOPT_STRING(0, "comms", &symbol_conf.comm_list_str, "comm[,comm...]",\r\n"only consider symbols in these comms"),\r\nOPT_STRING(0, "symbols", &symbol_conf.sym_list_str, "symbol[,symbol...]",\r\n"only consider these symbols"),\r\nOPT_BOOLEAN(0, "source", &symbol_conf.annotate_src,\r\n"Interleave source code with assembly code (default)"),\r\nOPT_BOOLEAN(0, "asm-raw", &symbol_conf.annotate_asm_raw,\r\n"Display raw encoding of assembly instructions (default)"),\r\nOPT_STRING(0, "objdump", &objdump_path, "path",\r\n"objdump binary to use for disassembly and annotations"),\r\nOPT_STRING('M', "disassembler-style", &disassembler_style, "disassembler style",\r\n"Specify disassembler style (e.g. -M intel for intel syntax)"),\r\nOPT_STRING('u', "uid", &target->uid_str, "user", "user to profile"),\r\nOPT_CALLBACK(0, "percent-limit", &top, "percent",\r\n"Don't show entries under that percent", parse_percent_limit),\r\nOPT_CALLBACK(0, "percentage", NULL, "relative|absolute",\r\n"How to display percentage of filtered entries", parse_filter_percentage),\r\nOPT_END()\r\n};\r\nconst char * const top_usage[] = {\r\n"perf top [<options>]",\r\nNULL\r\n};\r\ntop.evlist = perf_evlist__new();\r\nif (top.evlist == NULL)\r\nreturn -ENOMEM;\r\nperf_config(perf_top_config, &top);\r\nargc = parse_options(argc, argv, options, top_usage, 0);\r\nif (argc)\r\nusage_with_options(top_usage, options);\r\nsort__mode = SORT_MODE__TOP;\r\nsort__need_collapse = 1;\r\nif (setup_sorting() < 0) {\r\nif (sort_order)\r\nparse_options_usage(top_usage, options, "s", 1);\r\nif (field_order)\r\nparse_options_usage(sort_order ? NULL : top_usage,\r\noptions, "fields", 0);\r\ngoto out_delete_evlist;\r\n}\r\nif (top.use_stdio)\r\nuse_browser = 0;\r\nelse if (top.use_tui)\r\nuse_browser = 1;\r\nsetup_browser(false);\r\nstatus = target__validate(target);\r\nif (status) {\r\ntarget__strerror(target, status, errbuf, BUFSIZ);\r\nui__warning("%s\n", errbuf);\r\n}\r\nstatus = target__parse_uid(target);\r\nif (status) {\r\nint saved_errno = errno;\r\ntarget__strerror(target, status, errbuf, BUFSIZ);\r\nui__error("%s\n", errbuf);\r\nstatus = -saved_errno;\r\ngoto out_delete_evlist;\r\n}\r\nif (target__none(target))\r\ntarget->system_wide = true;\r\nif (perf_evlist__create_maps(top.evlist, target) < 0)\r\nusage_with_options(top_usage, options);\r\nif (!top.evlist->nr_entries &&\r\nperf_evlist__add_default(top.evlist) < 0) {\r\nui__error("Not enough memory for event selector list\n");\r\ngoto out_delete_evlist;\r\n}\r\nsymbol_conf.nr_events = top.evlist->nr_entries;\r\nif (top.delay_secs < 1)\r\ntop.delay_secs = 1;\r\nif (record_opts__config(opts)) {\r\nstatus = -EINVAL;\r\ngoto out_delete_evlist;\r\n}\r\ntop.sym_evsel = perf_evlist__first(top.evlist);\r\nif (!symbol_conf.use_callchain) {\r\nsymbol_conf.cumulate_callchain = false;\r\nperf_hpp__cancel_cumulate();\r\n}\r\nsymbol_conf.priv_size = sizeof(struct annotation);\r\nsymbol_conf.try_vmlinux_path = (symbol_conf.vmlinux_name == NULL);\r\nif (symbol__init() < 0)\r\nreturn -1;\r\nsort__setup_elide(stdout);\r\nget_term_dimensions(&top.winsize);\r\nif (top.print_entries == 0) {\r\nstruct sigaction act = {\r\n.sa_sigaction = perf_top__sig_winch,\r\n.sa_flags = SA_SIGINFO,\r\n};\r\nperf_top__update_print_entries(&top);\r\nsigaction(SIGWINCH, &act, NULL);\r\n}\r\nstatus = __cmd_top(&top);\r\nout_delete_evlist:\r\nperf_evlist__delete(top.evlist);\r\nreturn status;\r\n}
