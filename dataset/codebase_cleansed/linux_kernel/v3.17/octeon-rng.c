static int octeon_rng_init(struct hwrng *rng)\r\n{\r\nunion cvmx_rnm_ctl_status ctl;\r\nstruct octeon_rng *p = container_of(rng, struct octeon_rng, ops);\r\nctl.u64 = 0;\r\nctl.s.ent_en = 1;\r\nctl.s.rng_en = 1;\r\ncvmx_write_csr((u64)p->control_status, ctl.u64);\r\nreturn 0;\r\n}\r\nstatic void octeon_rng_cleanup(struct hwrng *rng)\r\n{\r\nunion cvmx_rnm_ctl_status ctl;\r\nstruct octeon_rng *p = container_of(rng, struct octeon_rng, ops);\r\nctl.u64 = 0;\r\ncvmx_write_csr((u64)p->control_status, ctl.u64);\r\n}\r\nstatic int octeon_rng_data_read(struct hwrng *rng, u32 *data)\r\n{\r\nstruct octeon_rng *p = container_of(rng, struct octeon_rng, ops);\r\n*data = cvmx_read64_uint32((u64)p->result);\r\nreturn sizeof(u32);\r\n}\r\nstatic int octeon_rng_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res_ports;\r\nstruct resource *res_result;\r\nstruct octeon_rng *rng;\r\nint ret;\r\nstruct hwrng ops = {\r\n.name = "octeon",\r\n.init = octeon_rng_init,\r\n.cleanup = octeon_rng_cleanup,\r\n.data_read = octeon_rng_data_read\r\n};\r\nrng = devm_kzalloc(&pdev->dev, sizeof(*rng), GFP_KERNEL);\r\nif (!rng)\r\nreturn -ENOMEM;\r\nres_ports = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res_ports)\r\nreturn -ENOENT;\r\nres_result = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!res_result)\r\nreturn -ENOENT;\r\nrng->control_status = devm_ioremap_nocache(&pdev->dev,\r\nres_ports->start,\r\nsizeof(u64));\r\nif (!rng->control_status)\r\nreturn -ENOENT;\r\nrng->result = devm_ioremap_nocache(&pdev->dev,\r\nres_result->start,\r\nsizeof(u64));\r\nif (!rng->result)\r\nreturn -ENOENT;\r\nrng->ops = ops;\r\nplatform_set_drvdata(pdev, &rng->ops);\r\nret = hwrng_register(&rng->ops);\r\nif (ret)\r\nreturn -ENOENT;\r\ndev_info(&pdev->dev, "Octeon Random Number Generator\n");\r\nreturn 0;\r\n}\r\nstatic int __exit octeon_rng_remove(struct platform_device *pdev)\r\n{\r\nstruct hwrng *rng = platform_get_drvdata(pdev);\r\nhwrng_unregister(rng);\r\nreturn 0;\r\n}
