static void periodic_work_func(struct work_struct *work)\r\n{\r\nPERIODIC_WORK *periodic_work =\r\ncontainer_of(work, struct PERIODIC_WORK_Tag, work.work);\r\n(*periodic_work->workfunc)(periodic_work->workfuncarg);\r\n}\r\nPERIODIC_WORK *visor_periodic_work_create(ulong jiffy_interval,\r\nstruct workqueue_struct *workqueue,\r\nvoid (*workfunc)(void *),\r\nvoid *workfuncarg,\r\nconst char *devnam)\r\n{\r\nPERIODIC_WORK *periodic_work = kzalloc(sizeof(PERIODIC_WORK),\r\nGFP_KERNEL | __GFP_NORETRY);\r\nif (periodic_work == NULL) {\r\nERRDRV("periodic_work allocation failed ");\r\nreturn NULL;\r\n}\r\nrwlock_init(&periodic_work->lock);\r\nperiodic_work->jiffy_interval = jiffy_interval;\r\nperiodic_work->workqueue = workqueue;\r\nperiodic_work->workfunc = workfunc;\r\nperiodic_work->workfuncarg = workfuncarg;\r\nperiodic_work->devnam = devnam;\r\nreturn periodic_work;\r\n}\r\nvoid visor_periodic_work_destroy(PERIODIC_WORK *periodic_work)\r\n{\r\nif (periodic_work == NULL)\r\nreturn;\r\nkfree(periodic_work);\r\n}\r\nBOOL visor_periodic_work_nextperiod(PERIODIC_WORK *periodic_work)\r\n{\r\nBOOL rc = FALSE;\r\nwrite_lock(&periodic_work->lock);\r\nif (periodic_work->want_to_stop) {\r\nperiodic_work->is_scheduled = FALSE;\r\nperiodic_work->want_to_stop = FALSE;\r\nrc = TRUE;\r\ngoto Away;\r\n} else if (queue_delayed_work(periodic_work->workqueue,\r\n&periodic_work->work,\r\nperiodic_work->jiffy_interval) < 0) {\r\nERRDEV(periodic_work->devnam, "queue_delayed_work failed!");\r\nperiodic_work->is_scheduled = FALSE;\r\nrc = FALSE;\r\ngoto Away;\r\n}\r\nrc = TRUE;\r\nAway:\r\nwrite_unlock(&periodic_work->lock);\r\nreturn rc;\r\n}\r\nBOOL visor_periodic_work_start(PERIODIC_WORK *periodic_work)\r\n{\r\nBOOL rc = FALSE;\r\nwrite_lock(&periodic_work->lock);\r\nif (periodic_work->is_scheduled) {\r\nrc = FALSE;\r\ngoto Away;\r\n}\r\nif (periodic_work->want_to_stop) {\r\nERRDEV(periodic_work->devnam,\r\n"dev_start_periodic_work failed!");\r\nrc = FALSE;\r\ngoto Away;\r\n}\r\nINIT_DELAYED_WORK(&periodic_work->work, &periodic_work_func);\r\nif (queue_delayed_work(periodic_work->workqueue,\r\n&periodic_work->work,\r\nperiodic_work->jiffy_interval) < 0) {\r\nERRDEV(periodic_work->devnam,\r\n"%s queue_delayed_work failed!", __func__);\r\nrc = FALSE;\r\ngoto Away;\r\n}\r\nperiodic_work->is_scheduled = TRUE;\r\nrc = TRUE;\r\nAway:\r\nwrite_unlock(&periodic_work->lock);\r\nreturn rc;\r\n}\r\nBOOL visor_periodic_work_stop(PERIODIC_WORK *periodic_work)\r\n{\r\nBOOL stopped_something = FALSE;\r\nwrite_lock(&periodic_work->lock);\r\nstopped_something = periodic_work->is_scheduled &&\r\n(!periodic_work->want_to_stop);\r\nwhile (periodic_work->is_scheduled) {\r\nperiodic_work->want_to_stop = TRUE;\r\nif (cancel_delayed_work(&periodic_work->work)) {\r\nASSERT(periodic_work->is_scheduled);\r\nperiodic_work->is_scheduled = FALSE;\r\n} else {\r\n}\r\nif (periodic_work->is_scheduled) {\r\nwrite_unlock(&periodic_work->lock);\r\nWARNDEV(periodic_work->devnam,\r\n"waiting for delayed work...");\r\nSLEEPJIFFIES(10);\r\nwrite_lock(&periodic_work->lock);\r\n} else\r\nperiodic_work->want_to_stop = FALSE;\r\n}\r\nwrite_unlock(&periodic_work->lock);\r\nreturn stopped_something;\r\n}
