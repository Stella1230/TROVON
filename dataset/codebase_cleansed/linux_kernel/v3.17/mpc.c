static struct mpoa_client *find_mpc_by_itfnum(int itf)\r\n{\r\nstruct mpoa_client *mpc;\r\nmpc = mpcs;\r\nwhile (mpc != NULL) {\r\nif (mpc->dev_num == itf)\r\nreturn mpc;\r\nmpc = mpc->next;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct mpoa_client *find_mpc_by_vcc(struct atm_vcc *vcc)\r\n{\r\nstruct mpoa_client *mpc;\r\nmpc = mpcs;\r\nwhile (mpc != NULL) {\r\nif (mpc->mpoad_vcc == vcc)\r\nreturn mpc;\r\nmpc = mpc->next;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct mpoa_client *find_mpc_by_lec(struct net_device *dev)\r\n{\r\nstruct mpoa_client *mpc;\r\nmpc = mpcs;\r\nwhile (mpc != NULL) {\r\nif (mpc->dev == dev)\r\nreturn mpc;\r\nmpc = mpc->next;\r\n}\r\nreturn NULL;\r\n}\r\nstruct atm_mpoa_qos *atm_mpoa_add_qos(__be32 dst_ip, struct atm_qos *qos)\r\n{\r\nstruct atm_mpoa_qos *entry;\r\nentry = atm_mpoa_search_qos(dst_ip);\r\nif (entry != NULL) {\r\nentry->qos = *qos;\r\nreturn entry;\r\n}\r\nentry = kmalloc(sizeof(struct atm_mpoa_qos), GFP_KERNEL);\r\nif (entry == NULL) {\r\npr_info("mpoa: out of memory\n");\r\nreturn entry;\r\n}\r\nentry->ipaddr = dst_ip;\r\nentry->qos = *qos;\r\nentry->next = qos_head;\r\nqos_head = entry;\r\nreturn entry;\r\n}\r\nstruct atm_mpoa_qos *atm_mpoa_search_qos(__be32 dst_ip)\r\n{\r\nstruct atm_mpoa_qos *qos;\r\nqos = qos_head;\r\nwhile (qos) {\r\nif (qos->ipaddr == dst_ip)\r\nbreak;\r\nqos = qos->next;\r\n}\r\nreturn qos;\r\n}\r\nint atm_mpoa_delete_qos(struct atm_mpoa_qos *entry)\r\n{\r\nstruct atm_mpoa_qos *curr;\r\nif (entry == NULL)\r\nreturn 0;\r\nif (entry == qos_head) {\r\nqos_head = qos_head->next;\r\nkfree(entry);\r\nreturn 1;\r\n}\r\ncurr = qos_head;\r\nwhile (curr != NULL) {\r\nif (curr->next == entry) {\r\ncurr->next = entry->next;\r\nkfree(entry);\r\nreturn 1;\r\n}\r\ncurr = curr->next;\r\n}\r\nreturn 0;\r\n}\r\nvoid atm_mpoa_disp_qos(struct seq_file *m)\r\n{\r\nstruct atm_mpoa_qos *qos;\r\nqos = qos_head;\r\nseq_printf(m, "QoS entries for shortcuts:\n");\r\nseq_printf(m, "IP address\n TX:max_pcr pcr min_pcr max_cdv max_sdu\n RX:max_pcr pcr min_pcr max_cdv max_sdu\n");\r\nwhile (qos != NULL) {\r\nseq_printf(m, "%pI4\n %-7d %-7d %-7d %-7d %-7d\n %-7d %-7d %-7d %-7d %-7d\n",\r\n&qos->ipaddr,\r\nqos->qos.txtp.max_pcr,\r\nqos->qos.txtp.pcr,\r\nqos->qos.txtp.min_pcr,\r\nqos->qos.txtp.max_cdv,\r\nqos->qos.txtp.max_sdu,\r\nqos->qos.rxtp.max_pcr,\r\nqos->qos.rxtp.pcr,\r\nqos->qos.rxtp.min_pcr,\r\nqos->qos.rxtp.max_cdv,\r\nqos->qos.rxtp.max_sdu);\r\nqos = qos->next;\r\n}\r\n}\r\nstatic struct net_device *find_lec_by_itfnum(int itf)\r\n{\r\nstruct net_device *dev;\r\nchar name[IFNAMSIZ];\r\nsprintf(name, "lec%d", itf);\r\ndev = dev_get_by_name(&init_net, name);\r\nreturn dev;\r\n}\r\nstatic struct mpoa_client *alloc_mpc(void)\r\n{\r\nstruct mpoa_client *mpc;\r\nmpc = kzalloc(sizeof(struct mpoa_client), GFP_KERNEL);\r\nif (mpc == NULL)\r\nreturn NULL;\r\nrwlock_init(&mpc->ingress_lock);\r\nrwlock_init(&mpc->egress_lock);\r\nmpc->next = mpcs;\r\natm_mpoa_init_cache(mpc);\r\nmpc->parameters.mpc_p1 = MPC_P1;\r\nmpc->parameters.mpc_p2 = MPC_P2;\r\nmemset(mpc->parameters.mpc_p3, 0, sizeof(mpc->parameters.mpc_p3));\r\nmpc->parameters.mpc_p4 = MPC_P4;\r\nmpc->parameters.mpc_p5 = MPC_P5;\r\nmpc->parameters.mpc_p6 = MPC_P6;\r\nmpcs = mpc;\r\nreturn mpc;\r\n}\r\nstatic void start_mpc(struct mpoa_client *mpc, struct net_device *dev)\r\n{\r\ndprintk("(%s)\n", mpc->dev->name);\r\nif (!dev->netdev_ops)\r\npr_info("(%s) not starting\n", dev->name);\r\nelse {\r\nmpc->old_ops = dev->netdev_ops;\r\nmpc->new_ops = *mpc->old_ops;\r\nmpc->new_ops.ndo_start_xmit = mpc_send_packet;\r\ndev->netdev_ops = &mpc->new_ops;\r\n}\r\n}\r\nstatic void stop_mpc(struct mpoa_client *mpc)\r\n{\r\nstruct net_device *dev = mpc->dev;\r\ndprintk("(%s)", mpc->dev->name);\r\nif (dev->netdev_ops != &mpc->new_ops) {\r\ndprintk_cont(" mpc already stopped, not fatal\n");\r\nreturn;\r\n}\r\ndprintk_cont("\n");\r\ndev->netdev_ops = mpc->old_ops;\r\nmpc->old_ops = NULL;\r\n}\r\nstatic const char *mpoa_device_type_string(char type)\r\n{\r\nswitch (type) {\r\ncase NON_MPOA:\r\nreturn "non-MPOA device";\r\ncase MPS:\r\nreturn "MPS";\r\ncase MPC:\r\nreturn "MPC";\r\ncase MPS_AND_MPC:\r\nreturn "both MPS and MPC";\r\n}\r\nreturn "unspecified (non-MPOA) device";\r\n}\r\nstatic void lane2_assoc_ind(struct net_device *dev, const u8 *mac_addr,\r\nconst u8 *tlvs, u32 sizeoftlvs)\r\n{\r\nuint32_t type;\r\nuint8_t length, mpoa_device_type, number_of_mps_macs;\r\nconst uint8_t *end_of_tlvs;\r\nstruct mpoa_client *mpc;\r\nmpoa_device_type = number_of_mps_macs = 0;\r\ndprintk("(%s) received TLV(s), ", dev->name);\r\ndprintk("total length of all TLVs %d\n", sizeoftlvs);\r\nmpc = find_mpc_by_lec(dev);\r\nif (mpc == NULL) {\r\npr_info("(%s) no mpc\n", dev->name);\r\nreturn;\r\n}\r\nend_of_tlvs = tlvs + sizeoftlvs;\r\nwhile (end_of_tlvs - tlvs >= 5) {\r\ntype = ((tlvs[0] << 24) | (tlvs[1] << 16) |\r\n(tlvs[2] << 8) | tlvs[3]);\r\nlength = tlvs[4];\r\ntlvs += 5;\r\ndprintk(" type 0x%x length %02x\n", type, length);\r\nif (tlvs + length > end_of_tlvs) {\r\npr_info("TLV value extends past its buffer, aborting parse\n");\r\nreturn;\r\n}\r\nif (type == 0) {\r\npr_info("mpoa: (%s) TLV type was 0, returning\n",\r\ndev->name);\r\nreturn;\r\n}\r\nif (type != TLV_MPOA_DEVICE_TYPE) {\r\ntlvs += length;\r\ncontinue;\r\n}\r\nmpoa_device_type = *tlvs++;\r\nnumber_of_mps_macs = *tlvs++;\r\ndprintk("(%s) MPOA device type '%s', ",\r\ndev->name, mpoa_device_type_string(mpoa_device_type));\r\nif (mpoa_device_type == MPS_AND_MPC &&\r\nlength < (42 + number_of_mps_macs*ETH_ALEN)) {\r\npr_info("(%s) short MPOA Device Type TLV\n",\r\ndev->name);\r\ncontinue;\r\n}\r\nif ((mpoa_device_type == MPS || mpoa_device_type == MPC) &&\r\nlength < 22 + number_of_mps_macs*ETH_ALEN) {\r\npr_info("(%s) short MPOA Device Type TLV\n", dev->name);\r\ncontinue;\r\n}\r\nif (mpoa_device_type != MPS &&\r\nmpoa_device_type != MPS_AND_MPC) {\r\ndprintk("ignoring non-MPS device ");\r\nif (mpoa_device_type == MPC)\r\ntlvs += 20;\r\ncontinue;\r\n}\r\nif (number_of_mps_macs == 0 &&\r\nmpoa_device_type == MPS_AND_MPC) {\r\npr_info("(%s) MPS_AND_MPC has zero MACs\n", dev->name);\r\ncontinue;\r\n}\r\ndprintk_cont("this MPS has %d MAC addresses\n",\r\nnumber_of_mps_macs);\r\nsend_set_mps_ctrl_addr(tlvs, mpc);\r\ntlvs = copy_macs(mpc, mac_addr, tlvs,\r\nnumber_of_mps_macs, mpoa_device_type);\r\nif (tlvs == NULL)\r\nreturn;\r\n}\r\nif (end_of_tlvs - tlvs != 0)\r\npr_info("(%s) ignoring %Zd bytes of trailing TLV garbage\n",\r\ndev->name, end_of_tlvs - tlvs);\r\n}\r\nstatic const uint8_t *copy_macs(struct mpoa_client *mpc,\r\nconst uint8_t *router_mac,\r\nconst uint8_t *tlvs, uint8_t mps_macs,\r\nuint8_t device_type)\r\n{\r\nint num_macs;\r\nnum_macs = (mps_macs > 1) ? mps_macs : 1;\r\nif (mpc->number_of_mps_macs != num_macs) {\r\nif (mpc->number_of_mps_macs != 0)\r\nkfree(mpc->mps_macs);\r\nmpc->number_of_mps_macs = 0;\r\nmpc->mps_macs = kmalloc(num_macs * ETH_ALEN, GFP_KERNEL);\r\nif (mpc->mps_macs == NULL) {\r\npr_info("(%s) out of mem\n", mpc->dev->name);\r\nreturn NULL;\r\n}\r\n}\r\nether_addr_copy(mpc->mps_macs, router_mac);\r\ntlvs += 20; if (device_type == MPS_AND_MPC) tlvs += 20;\r\nif (mps_macs > 0)\r\nmemcpy(mpc->mps_macs, tlvs, mps_macs*ETH_ALEN);\r\ntlvs += mps_macs*ETH_ALEN;\r\nmpc->number_of_mps_macs = num_macs;\r\nreturn tlvs;\r\n}\r\nstatic int send_via_shortcut(struct sk_buff *skb, struct mpoa_client *mpc)\r\n{\r\nin_cache_entry *entry;\r\nstruct iphdr *iph;\r\nchar *buff;\r\n__be32 ipaddr = 0;\r\nstatic struct {\r\nstruct llc_snap_hdr hdr;\r\n__be32 tag;\r\n} tagged_llc_snap_hdr = {\r\n{0xaa, 0xaa, 0x03, {0x00, 0x00, 0x00}, {0x88, 0x4c}},\r\n0\r\n};\r\nbuff = skb->data + mpc->dev->hard_header_len;\r\niph = (struct iphdr *)buff;\r\nipaddr = iph->daddr;\r\nddprintk("(%s) ipaddr 0x%x\n",\r\nmpc->dev->name, ipaddr);\r\nentry = mpc->in_ops->get(ipaddr, mpc);\r\nif (entry == NULL) {\r\nentry = mpc->in_ops->add_entry(ipaddr, mpc);\r\nif (entry != NULL)\r\nmpc->in_ops->put(entry);\r\nreturn 1;\r\n}\r\nif (mpc->in_ops->cache_hit(entry, mpc) != OPEN) {\r\nddprintk("(%s) cache_hit: returns != OPEN\n",\r\nmpc->dev->name);\r\nmpc->in_ops->put(entry);\r\nreturn 1;\r\n}\r\nddprintk("(%s) using shortcut\n",\r\nmpc->dev->name);\r\nif (iph->ttl <= 1) {\r\nddprintk("(%s) IP ttl = %u, using LANE\n",\r\nmpc->dev->name, iph->ttl);\r\nmpc->in_ops->put(entry);\r\nreturn 1;\r\n}\r\niph->ttl--;\r\niph->check = 0;\r\niph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);\r\nif (entry->ctrl_info.tag != 0) {\r\nddprintk("(%s) adding tag 0x%x\n",\r\nmpc->dev->name, entry->ctrl_info.tag);\r\ntagged_llc_snap_hdr.tag = entry->ctrl_info.tag;\r\nskb_pull(skb, ETH_HLEN);\r\nskb_push(skb, sizeof(tagged_llc_snap_hdr));\r\nskb_copy_to_linear_data(skb, &tagged_llc_snap_hdr,\r\nsizeof(tagged_llc_snap_hdr));\r\n} else {\r\nskb_pull(skb, ETH_HLEN);\r\nskb_push(skb, sizeof(struct llc_snap_hdr));\r\nskb_copy_to_linear_data(skb, &llc_snap_mpoa_data,\r\nsizeof(struct llc_snap_hdr));\r\n}\r\natomic_add(skb->truesize, &sk_atm(entry->shortcut)->sk_wmem_alloc);\r\nATM_SKB(skb)->atm_options = entry->shortcut->atm_options;\r\nentry->shortcut->send(entry->shortcut, skb);\r\nentry->packets_fwded++;\r\nmpc->in_ops->put(entry);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t mpc_send_packet(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct mpoa_client *mpc;\r\nstruct ethhdr *eth;\r\nint i = 0;\r\nmpc = find_mpc_by_lec(dev);\r\nif (mpc == NULL) {\r\npr_info("(%s) no MPC found\n", dev->name);\r\ngoto non_ip;\r\n}\r\neth = (struct ethhdr *)skb->data;\r\nif (eth->h_proto != htons(ETH_P_IP))\r\ngoto non_ip;\r\nif (skb->len < ETH_HLEN + sizeof(struct iphdr))\r\ngoto non_ip;\r\nskb_set_network_header(skb, ETH_HLEN);\r\nif (skb->len < ETH_HLEN + ip_hdr(skb)->ihl * 4 || ip_hdr(skb)->ihl < 5)\r\ngoto non_ip;\r\nwhile (i < mpc->number_of_mps_macs) {\r\nif (ether_addr_equal(eth->h_dest, mpc->mps_macs + i * ETH_ALEN))\r\nif (send_via_shortcut(skb, mpc) == 0)\r\nreturn NETDEV_TX_OK;\r\ni++;\r\n}\r\nnon_ip:\r\nreturn mpc->old_ops->ndo_start_xmit(skb, dev);\r\n}\r\nstatic int atm_mpoa_vcc_attach(struct atm_vcc *vcc, void __user *arg)\r\n{\r\nint bytes_left;\r\nstruct mpoa_client *mpc;\r\nstruct atmmpc_ioc ioc_data;\r\nin_cache_entry *in_entry;\r\n__be32 ipaddr;\r\nbytes_left = copy_from_user(&ioc_data, arg, sizeof(struct atmmpc_ioc));\r\nif (bytes_left != 0) {\r\npr_info("mpoa:Short read (missed %d bytes) from userland\n",\r\nbytes_left);\r\nreturn -EFAULT;\r\n}\r\nipaddr = ioc_data.ipaddr;\r\nif (ioc_data.dev_num < 0 || ioc_data.dev_num >= MAX_LEC_ITF)\r\nreturn -EINVAL;\r\nmpc = find_mpc_by_itfnum(ioc_data.dev_num);\r\nif (mpc == NULL)\r\nreturn -EINVAL;\r\nif (ioc_data.type == MPC_SOCKET_INGRESS) {\r\nin_entry = mpc->in_ops->get(ipaddr, mpc);\r\nif (in_entry == NULL ||\r\nin_entry->entry_state < INGRESS_RESOLVED) {\r\npr_info("(%s) did not find RESOLVED entry from ingress cache\n",\r\nmpc->dev->name);\r\nif (in_entry != NULL)\r\nmpc->in_ops->put(in_entry);\r\nreturn -EINVAL;\r\n}\r\npr_info("(%s) attaching ingress SVC, entry = %pI4\n",\r\nmpc->dev->name, &in_entry->ctrl_info.in_dst_ip);\r\nin_entry->shortcut = vcc;\r\nmpc->in_ops->put(in_entry);\r\n} else {\r\npr_info("(%s) attaching egress SVC\n", mpc->dev->name);\r\n}\r\nvcc->proto_data = mpc->dev;\r\nvcc->push = mpc_push;\r\nreturn 0;\r\n}\r\nstatic void mpc_vcc_close(struct atm_vcc *vcc, struct net_device *dev)\r\n{\r\nstruct mpoa_client *mpc;\r\nin_cache_entry *in_entry;\r\neg_cache_entry *eg_entry;\r\nmpc = find_mpc_by_lec(dev);\r\nif (mpc == NULL) {\r\npr_info("(%s) close for unknown MPC\n", dev->name);\r\nreturn;\r\n}\r\ndprintk("(%s)\n", dev->name);\r\nin_entry = mpc->in_ops->get_by_vcc(vcc, mpc);\r\nif (in_entry) {\r\ndprintk("(%s) ingress SVC closed ip = %pI4\n",\r\nmpc->dev->name, &in_entry->ctrl_info.in_dst_ip);\r\nin_entry->shortcut = NULL;\r\nmpc->in_ops->put(in_entry);\r\n}\r\neg_entry = mpc->eg_ops->get_by_vcc(vcc, mpc);\r\nif (eg_entry) {\r\ndprintk("(%s) egress SVC closed\n", mpc->dev->name);\r\neg_entry->shortcut = NULL;\r\nmpc->eg_ops->put(eg_entry);\r\n}\r\nif (in_entry == NULL && eg_entry == NULL)\r\ndprintk("(%s) unused vcc closed\n", dev->name);\r\n}\r\nstatic void mpc_push(struct atm_vcc *vcc, struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = (struct net_device *)vcc->proto_data;\r\nstruct sk_buff *new_skb;\r\neg_cache_entry *eg;\r\nstruct mpoa_client *mpc;\r\n__be32 tag;\r\nchar *tmp;\r\nddprintk("(%s)\n", dev->name);\r\nif (skb == NULL) {\r\ndprintk("(%s) null skb, closing VCC\n", dev->name);\r\nmpc_vcc_close(vcc, dev);\r\nreturn;\r\n}\r\nskb->dev = dev;\r\nif (memcmp(skb->data, &llc_snap_mpoa_ctrl,\r\nsizeof(struct llc_snap_hdr)) == 0) {\r\nstruct sock *sk = sk_atm(vcc);\r\ndprintk("(%s) control packet arrived\n", dev->name);\r\nskb_queue_tail(&sk->sk_receive_queue, skb);\r\nsk->sk_data_ready(sk);\r\nreturn;\r\n}\r\natm_return(vcc, skb->truesize);\r\nmpc = find_mpc_by_lec(dev);\r\nif (mpc == NULL) {\r\npr_info("(%s) unknown MPC\n", dev->name);\r\nreturn;\r\n}\r\nif (memcmp(skb->data, &llc_snap_mpoa_data_tagged,\r\nsizeof(struct llc_snap_hdr)) == 0) {\r\nddprintk("(%s) tagged data packet arrived\n", dev->name);\r\n} else if (memcmp(skb->data, &llc_snap_mpoa_data,\r\nsizeof(struct llc_snap_hdr)) == 0) {\r\npr_info("(%s) Unsupported non-tagged data packet arrived. Purging\n",\r\ndev->name);\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n} else {\r\npr_info("(%s) garbage arrived, purging\n", dev->name);\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\ntmp = skb->data + sizeof(struct llc_snap_hdr);\r\ntag = *(__be32 *)tmp;\r\neg = mpc->eg_ops->get_by_tag(tag, mpc);\r\nif (eg == NULL) {\r\npr_info("mpoa: (%s) Didn't find egress cache entry, tag = %u\n",\r\ndev->name, tag);\r\npurge_egress_shortcut(vcc, NULL);\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\nif (eg->shortcut == NULL) {\r\neg->shortcut = vcc;\r\npr_info("(%s) egress SVC in use\n", dev->name);\r\n}\r\nskb_pull(skb, sizeof(struct llc_snap_hdr) + sizeof(tag));\r\nnew_skb = skb_realloc_headroom(skb, eg->ctrl_info.DH_length);\r\ndev_kfree_skb_any(skb);\r\nif (new_skb == NULL) {\r\nmpc->eg_ops->put(eg);\r\nreturn;\r\n}\r\nskb_push(new_skb, eg->ctrl_info.DH_length);\r\nskb_copy_to_linear_data(new_skb, eg->ctrl_info.DLL_header,\r\neg->ctrl_info.DH_length);\r\nnew_skb->protocol = eth_type_trans(new_skb, dev);\r\nskb_reset_network_header(new_skb);\r\neg->latest_ip_addr = ip_hdr(new_skb)->saddr;\r\neg->packets_rcvd++;\r\nmpc->eg_ops->put(eg);\r\nmemset(ATM_SKB(new_skb), 0, sizeof(struct atm_skb_data));\r\nnetif_rx(new_skb);\r\n}\r\nstatic int atm_mpoa_mpoad_attach(struct atm_vcc *vcc, int arg)\r\n{\r\nstruct mpoa_client *mpc;\r\nstruct lec_priv *priv;\r\nint err;\r\nif (mpcs == NULL) {\r\ninit_timer(&mpc_timer);\r\nmpc_timer_refresh();\r\nerr = register_netdevice_notifier(&mpoa_notifier);\r\nif (err < 0) {\r\ndel_timer(&mpc_timer);\r\nreturn err;\r\n}\r\n}\r\nmpc = find_mpc_by_itfnum(arg);\r\nif (mpc == NULL) {\r\ndprintk("allocating new mpc for itf %d\n", arg);\r\nmpc = alloc_mpc();\r\nif (mpc == NULL)\r\nreturn -ENOMEM;\r\nmpc->dev_num = arg;\r\nmpc->dev = find_lec_by_itfnum(arg);\r\n}\r\nif (mpc->mpoad_vcc) {\r\npr_info("mpoad is already present for itf %d\n", arg);\r\nreturn -EADDRINUSE;\r\n}\r\nif (mpc->dev) {\r\npriv = netdev_priv(mpc->dev);\r\nif (priv->lane_version < 2) {\r\ndev_put(mpc->dev);\r\nmpc->dev = NULL;\r\n} else\r\npriv->lane2_ops->associate_indicator = lane2_assoc_ind;\r\n}\r\nmpc->mpoad_vcc = vcc;\r\nvcc->dev = &mpc_dev;\r\nvcc_insert_socket(sk_atm(vcc));\r\nset_bit(ATM_VF_META, &vcc->flags);\r\nset_bit(ATM_VF_READY, &vcc->flags);\r\nif (mpc->dev) {\r\nchar empty[ATM_ESA_LEN];\r\nmemset(empty, 0, ATM_ESA_LEN);\r\nstart_mpc(mpc, mpc->dev);\r\nif (memcmp(mpc->mps_ctrl_addr, empty, ATM_ESA_LEN) != 0)\r\nsend_set_mps_ctrl_addr(mpc->mps_ctrl_addr, mpc);\r\n}\r\n__module_get(THIS_MODULE);\r\nreturn arg;\r\n}\r\nstatic void send_set_mps_ctrl_addr(const char *addr, struct mpoa_client *mpc)\r\n{\r\nstruct k_message mesg;\r\nmemcpy(mpc->mps_ctrl_addr, addr, ATM_ESA_LEN);\r\nmesg.type = SET_MPS_CTRL_ADDR;\r\nmemcpy(mesg.MPS_ctrl, addr, ATM_ESA_LEN);\r\nmsg_to_mpoad(&mesg, mpc);\r\n}\r\nstatic void mpoad_close(struct atm_vcc *vcc)\r\n{\r\nstruct mpoa_client *mpc;\r\nstruct sk_buff *skb;\r\nmpc = find_mpc_by_vcc(vcc);\r\nif (mpc == NULL) {\r\npr_info("did not find MPC\n");\r\nreturn;\r\n}\r\nif (!mpc->mpoad_vcc) {\r\npr_info("close for non-present mpoad\n");\r\nreturn;\r\n}\r\nmpc->mpoad_vcc = NULL;\r\nif (mpc->dev) {\r\nstruct lec_priv *priv = netdev_priv(mpc->dev);\r\npriv->lane2_ops->associate_indicator = NULL;\r\nstop_mpc(mpc);\r\ndev_put(mpc->dev);\r\n}\r\nmpc->in_ops->destroy_cache(mpc);\r\nmpc->eg_ops->destroy_cache(mpc);\r\nwhile ((skb = skb_dequeue(&sk_atm(vcc)->sk_receive_queue))) {\r\natm_return(vcc, skb->truesize);\r\nkfree_skb(skb);\r\n}\r\npr_info("(%s) going down\n",\r\n(mpc->dev) ? mpc->dev->name : "<unknown>");\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic int msg_from_mpoad(struct atm_vcc *vcc, struct sk_buff *skb)\r\n{\r\nstruct mpoa_client *mpc = find_mpc_by_vcc(vcc);\r\nstruct k_message *mesg = (struct k_message *)skb->data;\r\natomic_sub(skb->truesize, &sk_atm(vcc)->sk_wmem_alloc);\r\nif (mpc == NULL) {\r\npr_info("no mpc found\n");\r\nreturn 0;\r\n}\r\ndprintk("(%s)", mpc->dev ? mpc->dev->name : "<unknown>");\r\nswitch (mesg->type) {\r\ncase MPOA_RES_REPLY_RCVD:\r\ndprintk_cont("mpoa_res_reply_rcvd\n");\r\nMPOA_res_reply_rcvd(mesg, mpc);\r\nbreak;\r\ncase MPOA_TRIGGER_RCVD:\r\ndprintk_cont("mpoa_trigger_rcvd\n");\r\nMPOA_trigger_rcvd(mesg, mpc);\r\nbreak;\r\ncase INGRESS_PURGE_RCVD:\r\ndprintk_cont("nhrp_purge_rcvd\n");\r\ningress_purge_rcvd(mesg, mpc);\r\nbreak;\r\ncase EGRESS_PURGE_RCVD:\r\ndprintk_cont("egress_purge_reply_rcvd\n");\r\negress_purge_rcvd(mesg, mpc);\r\nbreak;\r\ncase MPS_DEATH:\r\ndprintk_cont("mps_death\n");\r\nmps_death(mesg, mpc);\r\nbreak;\r\ncase CACHE_IMPOS_RCVD:\r\ndprintk_cont("cache_impos_rcvd\n");\r\nMPOA_cache_impos_rcvd(mesg, mpc);\r\nbreak;\r\ncase SET_MPC_CTRL_ADDR:\r\ndprintk_cont("set_mpc_ctrl_addr\n");\r\nset_mpc_ctrl_addr_rcvd(mesg, mpc);\r\nbreak;\r\ncase SET_MPS_MAC_ADDR:\r\ndprintk_cont("set_mps_mac_addr\n");\r\nset_mps_mac_addr_rcvd(mesg, mpc);\r\nbreak;\r\ncase CLEAN_UP_AND_EXIT:\r\ndprintk_cont("clean_up_and_exit\n");\r\nclean_up(mesg, mpc, DIE);\r\nbreak;\r\ncase RELOAD:\r\ndprintk_cont("reload\n");\r\nclean_up(mesg, mpc, RELOAD);\r\nbreak;\r\ncase SET_MPC_PARAMS:\r\ndprintk_cont("set_mpc_params\n");\r\nmpc->parameters = mesg->content.params;\r\nbreak;\r\ndefault:\r\ndprintk_cont("unknown message %d\n", mesg->type);\r\nbreak;\r\n}\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nint msg_to_mpoad(struct k_message *mesg, struct mpoa_client *mpc)\r\n{\r\nstruct sk_buff *skb;\r\nstruct sock *sk;\r\nif (mpc == NULL || !mpc->mpoad_vcc) {\r\npr_info("mesg %d to a non-existent mpoad\n", mesg->type);\r\nreturn -ENXIO;\r\n}\r\nskb = alloc_skb(sizeof(struct k_message), GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nskb_put(skb, sizeof(struct k_message));\r\nskb_copy_to_linear_data(skb, mesg, sizeof(*mesg));\r\natm_force_charge(mpc->mpoad_vcc, skb->truesize);\r\nsk = sk_atm(mpc->mpoad_vcc);\r\nskb_queue_tail(&sk->sk_receive_queue, skb);\r\nsk->sk_data_ready(sk);\r\nreturn 0;\r\n}\r\nstatic int mpoa_event_listener(struct notifier_block *mpoa_notifier,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct mpoa_client *mpc;\r\nstruct lec_priv *priv;\r\nif (!net_eq(dev_net(dev), &init_net))\r\nreturn NOTIFY_DONE;\r\nif (dev->name == NULL || strncmp(dev->name, "lec", 3))\r\nreturn NOTIFY_DONE;\r\nswitch (event) {\r\ncase NETDEV_REGISTER:\r\npriv = netdev_priv(dev);\r\nif (priv->lane_version < 2)\r\nbreak;\r\npriv->lane2_ops->associate_indicator = lane2_assoc_ind;\r\nmpc = find_mpc_by_itfnum(priv->itfnum);\r\nif (mpc == NULL) {\r\ndprintk("allocating new mpc for %s\n", dev->name);\r\nmpc = alloc_mpc();\r\nif (mpc == NULL) {\r\npr_info("no new mpc");\r\nbreak;\r\n}\r\n}\r\nmpc->dev_num = priv->itfnum;\r\nmpc->dev = dev;\r\ndev_hold(dev);\r\ndprintk("(%s) was initialized\n", dev->name);\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\nmpc = find_mpc_by_lec(dev);\r\nif (mpc == NULL)\r\nbreak;\r\ndprintk("device (%s) was deallocated\n", dev->name);\r\nstop_mpc(mpc);\r\ndev_put(mpc->dev);\r\nmpc->dev = NULL;\r\nbreak;\r\ncase NETDEV_UP:\r\nmpc = find_mpc_by_lec(dev);\r\nif (mpc == NULL)\r\nbreak;\r\nif (mpc->mpoad_vcc != NULL)\r\nstart_mpc(mpc, dev);\r\nbreak;\r\ncase NETDEV_DOWN:\r\nmpc = find_mpc_by_lec(dev);\r\nif (mpc == NULL)\r\nbreak;\r\nif (mpc->mpoad_vcc != NULL)\r\nstop_mpc(mpc);\r\nbreak;\r\ncase NETDEV_REBOOT:\r\ncase NETDEV_CHANGE:\r\ncase NETDEV_CHANGEMTU:\r\ncase NETDEV_CHANGEADDR:\r\ncase NETDEV_GOING_DOWN:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void MPOA_trigger_rcvd(struct k_message *msg, struct mpoa_client *mpc)\r\n{\r\n__be32 dst_ip = msg->content.in_info.in_dst_ip;\r\nin_cache_entry *entry;\r\nentry = mpc->in_ops->get(dst_ip, mpc);\r\nif (entry == NULL) {\r\nentry = mpc->in_ops->add_entry(dst_ip, mpc);\r\nentry->entry_state = INGRESS_RESOLVING;\r\nmsg->type = SND_MPOA_RES_RQST;\r\nmsg->content.in_info = entry->ctrl_info;\r\nmsg_to_mpoad(msg, mpc);\r\ndo_gettimeofday(&(entry->reply_wait));\r\nmpc->in_ops->put(entry);\r\nreturn;\r\n}\r\nif (entry->entry_state == INGRESS_INVALID) {\r\nentry->entry_state = INGRESS_RESOLVING;\r\nmsg->type = SND_MPOA_RES_RQST;\r\nmsg->content.in_info = entry->ctrl_info;\r\nmsg_to_mpoad(msg, mpc);\r\ndo_gettimeofday(&(entry->reply_wait));\r\nmpc->in_ops->put(entry);\r\nreturn;\r\n}\r\npr_info("(%s) entry already in resolving state\n",\r\n(mpc->dev) ? mpc->dev->name : "<unknown>");\r\nmpc->in_ops->put(entry);\r\n}\r\nstatic void check_qos_and_open_shortcut(struct k_message *msg,\r\nstruct mpoa_client *client,\r\nin_cache_entry *entry)\r\n{\r\n__be32 dst_ip = msg->content.in_info.in_dst_ip;\r\nstruct atm_mpoa_qos *qos = atm_mpoa_search_qos(dst_ip);\r\neg_cache_entry *eg_entry = client->eg_ops->get_by_src_ip(dst_ip, client);\r\nif (eg_entry && eg_entry->shortcut) {\r\nif (eg_entry->shortcut->qos.txtp.traffic_class &\r\nmsg->qos.txtp.traffic_class &\r\n(qos ? qos->qos.txtp.traffic_class : ATM_UBR | ATM_CBR)) {\r\nif (eg_entry->shortcut->qos.txtp.traffic_class == ATM_UBR)\r\nentry->shortcut = eg_entry->shortcut;\r\nelse if (eg_entry->shortcut->qos.txtp.max_pcr > 0)\r\nentry->shortcut = eg_entry->shortcut;\r\n}\r\nif (entry->shortcut) {\r\ndprintk("(%s) using egress SVC to reach %pI4\n",\r\nclient->dev->name, &dst_ip);\r\nclient->eg_ops->put(eg_entry);\r\nreturn;\r\n}\r\n}\r\nif (eg_entry != NULL)\r\nclient->eg_ops->put(eg_entry);\r\nmsg->type = OPEN_INGRESS_SVC;\r\nif (qos &&\r\n(qos->qos.txtp.traffic_class == msg->qos.txtp.traffic_class)) {\r\nmsg->qos = qos->qos;\r\npr_info("(%s) trying to get a CBR shortcut\n",\r\nclient->dev->name);\r\n} else\r\nmemset(&msg->qos, 0, sizeof(struct atm_qos));\r\nmsg_to_mpoad(msg, client);\r\n}\r\nstatic void MPOA_res_reply_rcvd(struct k_message *msg, struct mpoa_client *mpc)\r\n{\r\n__be32 dst_ip = msg->content.in_info.in_dst_ip;\r\nin_cache_entry *entry = mpc->in_ops->get(dst_ip, mpc);\r\ndprintk("(%s) ip %pI4\n",\r\nmpc->dev->name, &dst_ip);\r\nddprintk("(%s) entry = %p",\r\nmpc->dev->name, entry);\r\nif (entry == NULL) {\r\npr_info("(%s) ARGH, received res. reply for an entry that doesn't exist.\n",\r\nmpc->dev->name);\r\nreturn;\r\n}\r\nddprintk_cont(" entry_state = %d ", entry->entry_state);\r\nif (entry->entry_state == INGRESS_RESOLVED) {\r\npr_info("(%s) RESOLVED entry!\n", mpc->dev->name);\r\nmpc->in_ops->put(entry);\r\nreturn;\r\n}\r\nentry->ctrl_info = msg->content.in_info;\r\ndo_gettimeofday(&(entry->tv));\r\ndo_gettimeofday(&(entry->reply_wait));\r\nentry->refresh_time = 0;\r\nddprintk_cont("entry->shortcut = %p\n", entry->shortcut);\r\nif (entry->entry_state == INGRESS_RESOLVING &&\r\nentry->shortcut != NULL) {\r\nentry->entry_state = INGRESS_RESOLVED;\r\nmpc->in_ops->put(entry);\r\nreturn;\r\n}\r\nif (entry->shortcut != NULL) {\r\npr_info("(%s) entry->shortcut != NULL, impossible!\n",\r\nmpc->dev->name);\r\nmpc->in_ops->put(entry);\r\nreturn;\r\n}\r\ncheck_qos_and_open_shortcut(msg, mpc, entry);\r\nentry->entry_state = INGRESS_RESOLVED;\r\nmpc->in_ops->put(entry);\r\nreturn;\r\n}\r\nstatic void ingress_purge_rcvd(struct k_message *msg, struct mpoa_client *mpc)\r\n{\r\n__be32 dst_ip = msg->content.in_info.in_dst_ip;\r\n__be32 mask = msg->ip_mask;\r\nin_cache_entry *entry = mpc->in_ops->get_with_mask(dst_ip, mpc, mask);\r\nif (entry == NULL) {\r\npr_info("(%s) purge for a non-existing entry, ip = %pI4\n",\r\nmpc->dev->name, &dst_ip);\r\nreturn;\r\n}\r\ndo {\r\ndprintk("(%s) removing an ingress entry, ip = %pI4\n",\r\nmpc->dev->name, &dst_ip);\r\nwrite_lock_bh(&mpc->ingress_lock);\r\nmpc->in_ops->remove_entry(entry, mpc);\r\nwrite_unlock_bh(&mpc->ingress_lock);\r\nmpc->in_ops->put(entry);\r\nentry = mpc->in_ops->get_with_mask(dst_ip, mpc, mask);\r\n} while (entry != NULL);\r\n}\r\nstatic void egress_purge_rcvd(struct k_message *msg, struct mpoa_client *mpc)\r\n{\r\n__be32 cache_id = msg->content.eg_info.cache_id;\r\neg_cache_entry *entry = mpc->eg_ops->get_by_cache_id(cache_id, mpc);\r\nif (entry == NULL) {\r\ndprintk("(%s) purge for a non-existing entry\n",\r\nmpc->dev->name);\r\nreturn;\r\n}\r\nwrite_lock_irq(&mpc->egress_lock);\r\nmpc->eg_ops->remove_entry(entry, mpc);\r\nwrite_unlock_irq(&mpc->egress_lock);\r\nmpc->eg_ops->put(entry);\r\n}\r\nstatic void purge_egress_shortcut(struct atm_vcc *vcc, eg_cache_entry *entry)\r\n{\r\nstruct sock *sk;\r\nstruct k_message *purge_msg;\r\nstruct sk_buff *skb;\r\ndprintk("entering\n");\r\nif (vcc == NULL) {\r\npr_info("vcc == NULL\n");\r\nreturn;\r\n}\r\nskb = alloc_skb(sizeof(struct k_message), GFP_ATOMIC);\r\nif (skb == NULL) {\r\npr_info("out of memory\n");\r\nreturn;\r\n}\r\nskb_put(skb, sizeof(struct k_message));\r\nmemset(skb->data, 0, sizeof(struct k_message));\r\npurge_msg = (struct k_message *)skb->data;\r\npurge_msg->type = DATA_PLANE_PURGE;\r\nif (entry != NULL)\r\npurge_msg->content.eg_info = entry->ctrl_info;\r\natm_force_charge(vcc, skb->truesize);\r\nsk = sk_atm(vcc);\r\nskb_queue_tail(&sk->sk_receive_queue, skb);\r\nsk->sk_data_ready(sk);\r\ndprintk("exiting\n");\r\n}\r\nstatic void mps_death(struct k_message *msg, struct mpoa_client *mpc)\r\n{\r\neg_cache_entry *entry;\r\ndprintk("(%s)\n", mpc->dev->name);\r\nif (memcmp(msg->MPS_ctrl, mpc->mps_ctrl_addr, ATM_ESA_LEN)) {\r\npr_info("(%s) wrong MPS\n", mpc->dev->name);\r\nreturn;\r\n}\r\nread_lock_irq(&mpc->egress_lock);\r\nentry = mpc->eg_cache;\r\nwhile (entry != NULL) {\r\npurge_egress_shortcut(entry->shortcut, entry);\r\nentry = entry->next;\r\n}\r\nread_unlock_irq(&mpc->egress_lock);\r\nmpc->in_ops->destroy_cache(mpc);\r\nmpc->eg_ops->destroy_cache(mpc);\r\n}\r\nstatic void MPOA_cache_impos_rcvd(struct k_message *msg,\r\nstruct mpoa_client *mpc)\r\n{\r\nuint16_t holding_time;\r\neg_cache_entry *entry = mpc->eg_ops->get_by_cache_id(msg->content.eg_info.cache_id, mpc);\r\nholding_time = msg->content.eg_info.holding_time;\r\ndprintk("(%s) entry = %p, holding_time = %u\n",\r\nmpc->dev->name, entry, holding_time);\r\nif (entry == NULL && holding_time) {\r\nentry = mpc->eg_ops->add_entry(msg, mpc);\r\nmpc->eg_ops->put(entry);\r\nreturn;\r\n}\r\nif (holding_time) {\r\nmpc->eg_ops->update(entry, holding_time);\r\nreturn;\r\n}\r\nwrite_lock_irq(&mpc->egress_lock);\r\nmpc->eg_ops->remove_entry(entry, mpc);\r\nwrite_unlock_irq(&mpc->egress_lock);\r\nmpc->eg_ops->put(entry);\r\n}\r\nstatic void set_mpc_ctrl_addr_rcvd(struct k_message *mesg,\r\nstruct mpoa_client *mpc)\r\n{\r\nstruct lec_priv *priv;\r\nint i, retval ;\r\nuint8_t tlv[4 + 1 + 1 + 1 + ATM_ESA_LEN];\r\ntlv[0] = 00; tlv[1] = 0xa0; tlv[2] = 0x3e; tlv[3] = 0x2a;\r\ntlv[4] = 1 + 1 + ATM_ESA_LEN;\r\ntlv[5] = 0x02;\r\ntlv[6] = 0x00;\r\nmemcpy(&tlv[7], mesg->MPS_ctrl, ATM_ESA_LEN);\r\nmemcpy(mpc->our_ctrl_addr, mesg->MPS_ctrl, ATM_ESA_LEN);\r\ndprintk("(%s) setting MPC ctrl ATM address to",\r\nmpc->dev ? mpc->dev->name : "<unknown>");\r\nfor (i = 7; i < sizeof(tlv); i++)\r\ndprintk_cont(" %02x", tlv[i]);\r\ndprintk_cont("\n");\r\nif (mpc->dev) {\r\npriv = netdev_priv(mpc->dev);\r\nretval = priv->lane2_ops->associate_req(mpc->dev,\r\nmpc->dev->dev_addr,\r\ntlv, sizeof(tlv));\r\nif (retval == 0)\r\npr_info("(%s) MPOA device type TLV association failed\n",\r\nmpc->dev->name);\r\nretval = priv->lane2_ops->resolve(mpc->dev, NULL, 1, NULL, NULL);\r\nif (retval < 0)\r\npr_info("(%s) targetless LE_ARP request failed\n",\r\nmpc->dev->name);\r\n}\r\n}\r\nstatic void set_mps_mac_addr_rcvd(struct k_message *msg,\r\nstruct mpoa_client *client)\r\n{\r\nif (client->number_of_mps_macs)\r\nkfree(client->mps_macs);\r\nclient->number_of_mps_macs = 0;\r\nclient->mps_macs = kmemdup(msg->MPS_ctrl, ETH_ALEN, GFP_KERNEL);\r\nif (client->mps_macs == NULL) {\r\npr_info("out of memory\n");\r\nreturn;\r\n}\r\nclient->number_of_mps_macs = 1;\r\n}\r\nstatic void clean_up(struct k_message *msg, struct mpoa_client *mpc, int action)\r\n{\r\neg_cache_entry *entry;\r\nmsg->type = SND_EGRESS_PURGE;\r\nread_lock_irq(&mpc->egress_lock);\r\nentry = mpc->eg_cache;\r\nwhile (entry != NULL) {\r\nmsg->content.eg_info = entry->ctrl_info;\r\ndprintk("cache_id %u\n", entry->ctrl_info.cache_id);\r\nmsg_to_mpoad(msg, mpc);\r\nentry = entry->next;\r\n}\r\nread_unlock_irq(&mpc->egress_lock);\r\nmsg->type = action;\r\nmsg_to_mpoad(msg, mpc);\r\n}\r\nstatic void mpc_timer_refresh(void)\r\n{\r\nmpc_timer.expires = jiffies + (MPC_P2 * HZ);\r\nmpc_timer.data = mpc_timer.expires;\r\nmpc_timer.function = mpc_cache_check;\r\nadd_timer(&mpc_timer);\r\n}\r\nstatic void mpc_cache_check(unsigned long checking_time)\r\n{\r\nstruct mpoa_client *mpc = mpcs;\r\nstatic unsigned long previous_resolving_check_time;\r\nstatic unsigned long previous_refresh_time;\r\nwhile (mpc != NULL) {\r\nmpc->in_ops->clear_count(mpc);\r\nmpc->eg_ops->clear_expired(mpc);\r\nif (checking_time - previous_resolving_check_time >\r\nmpc->parameters.mpc_p4 * HZ) {\r\nmpc->in_ops->check_resolving(mpc);\r\nprevious_resolving_check_time = checking_time;\r\n}\r\nif (checking_time - previous_refresh_time >\r\nmpc->parameters.mpc_p5 * HZ) {\r\nmpc->in_ops->refresh(mpc);\r\nprevious_refresh_time = checking_time;\r\n}\r\nmpc = mpc->next;\r\n}\r\nmpc_timer_refresh();\r\n}\r\nstatic int atm_mpoa_ioctl(struct socket *sock, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint err = 0;\r\nstruct atm_vcc *vcc = ATM_SD(sock);\r\nif (cmd != ATMMPC_CTRL && cmd != ATMMPC_DATA)\r\nreturn -ENOIOCTLCMD;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nswitch (cmd) {\r\ncase ATMMPC_CTRL:\r\nerr = atm_mpoa_mpoad_attach(vcc, (int)arg);\r\nif (err >= 0)\r\nsock->state = SS_CONNECTED;\r\nbreak;\r\ncase ATMMPC_DATA:\r\nerr = atm_mpoa_vcc_attach(vcc, (void __user *)arg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic __init int atm_mpoa_init(void)\r\n{\r\nregister_atm_ioctl(&atm_ioctl_ops);\r\nif (mpc_proc_init() != 0)\r\npr_info("failed to initialize /proc/mpoa\n");\r\npr_info("mpc.c: initialized\n");\r\nreturn 0;\r\n}\r\nstatic void __exit atm_mpoa_cleanup(void)\r\n{\r\nstruct mpoa_client *mpc, *tmp;\r\nstruct atm_mpoa_qos *qos, *nextqos;\r\nstruct lec_priv *priv;\r\nmpc_proc_clean();\r\ndel_timer_sync(&mpc_timer);\r\nunregister_netdevice_notifier(&mpoa_notifier);\r\nderegister_atm_ioctl(&atm_ioctl_ops);\r\nmpc = mpcs;\r\nmpcs = NULL;\r\nwhile (mpc != NULL) {\r\ntmp = mpc->next;\r\nif (mpc->dev != NULL) {\r\nstop_mpc(mpc);\r\npriv = netdev_priv(mpc->dev);\r\nif (priv->lane2_ops != NULL)\r\npriv->lane2_ops->associate_indicator = NULL;\r\n}\r\nddprintk("about to clear caches\n");\r\nmpc->in_ops->destroy_cache(mpc);\r\nmpc->eg_ops->destroy_cache(mpc);\r\nddprintk("caches cleared\n");\r\nkfree(mpc->mps_macs);\r\nmemset(mpc, 0, sizeof(struct mpoa_client));\r\nddprintk("about to kfree %p\n", mpc);\r\nkfree(mpc);\r\nddprintk("next mpc is at %p\n", tmp);\r\nmpc = tmp;\r\n}\r\nqos = qos_head;\r\nqos_head = NULL;\r\nwhile (qos != NULL) {\r\nnextqos = qos->next;\r\ndprintk("freeing qos entry %p\n", qos);\r\nkfree(qos);\r\nqos = nextqos;\r\n}\r\n}
