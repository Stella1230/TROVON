static int at91ether_start(struct net_device *dev)\r\n{\r\nstruct macb *lp = netdev_priv(dev);\r\ndma_addr_t addr;\r\nu32 ctl;\r\nint i;\r\nlp->rx_ring = dma_alloc_coherent(&lp->pdev->dev,\r\n(MAX_RX_DESCR *\r\nsizeof(struct macb_dma_desc)),\r\n&lp->rx_ring_dma, GFP_KERNEL);\r\nif (!lp->rx_ring)\r\nreturn -ENOMEM;\r\nlp->rx_buffers = dma_alloc_coherent(&lp->pdev->dev,\r\nMAX_RX_DESCR * MAX_RBUFF_SZ,\r\n&lp->rx_buffers_dma, GFP_KERNEL);\r\nif (!lp->rx_buffers) {\r\ndma_free_coherent(&lp->pdev->dev,\r\nMAX_RX_DESCR * sizeof(struct macb_dma_desc),\r\nlp->rx_ring, lp->rx_ring_dma);\r\nlp->rx_ring = NULL;\r\nreturn -ENOMEM;\r\n}\r\naddr = lp->rx_buffers_dma;\r\nfor (i = 0; i < MAX_RX_DESCR; i++) {\r\nlp->rx_ring[i].addr = addr;\r\nlp->rx_ring[i].ctrl = 0;\r\naddr += MAX_RBUFF_SZ;\r\n}\r\nlp->rx_ring[MAX_RX_DESCR - 1].addr |= MACB_BIT(RX_WRAP);\r\nlp->rx_tail = 0;\r\nmacb_writel(lp, RBQP, lp->rx_ring_dma);\r\nctl = macb_readl(lp, NCR);\r\nmacb_writel(lp, NCR, ctl | MACB_BIT(RE) | MACB_BIT(TE));\r\nreturn 0;\r\n}\r\nstatic int at91ether_open(struct net_device *dev)\r\n{\r\nstruct macb *lp = netdev_priv(dev);\r\nu32 ctl;\r\nint ret;\r\nctl = macb_readl(lp, NCR);\r\nmacb_writel(lp, NCR, ctl | MACB_BIT(CLRSTAT));\r\nmacb_set_hwaddr(lp);\r\nret = at91ether_start(dev);\r\nif (ret)\r\nreturn ret;\r\nmacb_writel(lp, IER, MACB_BIT(RCOMP) |\r\nMACB_BIT(RXUBR) |\r\nMACB_BIT(ISR_TUND) |\r\nMACB_BIT(ISR_RLE) |\r\nMACB_BIT(TCOMP) |\r\nMACB_BIT(ISR_ROVR) |\r\nMACB_BIT(HRESP));\r\nphy_start(lp->phy_dev);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int at91ether_close(struct net_device *dev)\r\n{\r\nstruct macb *lp = netdev_priv(dev);\r\nu32 ctl;\r\nctl = macb_readl(lp, NCR);\r\nmacb_writel(lp, NCR, ctl & ~(MACB_BIT(TE) | MACB_BIT(RE)));\r\nmacb_writel(lp, IDR, MACB_BIT(RCOMP) |\r\nMACB_BIT(RXUBR) |\r\nMACB_BIT(ISR_TUND) |\r\nMACB_BIT(ISR_RLE) |\r\nMACB_BIT(TCOMP) |\r\nMACB_BIT(ISR_ROVR) |\r\nMACB_BIT(HRESP));\r\nnetif_stop_queue(dev);\r\ndma_free_coherent(&lp->pdev->dev,\r\nMAX_RX_DESCR * sizeof(struct macb_dma_desc),\r\nlp->rx_ring, lp->rx_ring_dma);\r\nlp->rx_ring = NULL;\r\ndma_free_coherent(&lp->pdev->dev,\r\nMAX_RX_DESCR * MAX_RBUFF_SZ,\r\nlp->rx_buffers, lp->rx_buffers_dma);\r\nlp->rx_buffers = NULL;\r\nreturn 0;\r\n}\r\nstatic int at91ether_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct macb *lp = netdev_priv(dev);\r\nif (macb_readl(lp, TSR) & MACB_BIT(RM9200_BNQ)) {\r\nnetif_stop_queue(dev);\r\nlp->skb = skb;\r\nlp->skb_length = skb->len;\r\nlp->skb_physaddr = dma_map_single(NULL, skb->data, skb->len,\r\nDMA_TO_DEVICE);\r\nmacb_writel(lp, TAR, lp->skb_physaddr);\r\nmacb_writel(lp, TCR, skb->len);\r\n} else {\r\nnetdev_err(dev, "%s called, but device is busy!\n", __func__);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void at91ether_rx(struct net_device *dev)\r\n{\r\nstruct macb *lp = netdev_priv(dev);\r\nunsigned char *p_recv;\r\nstruct sk_buff *skb;\r\nunsigned int pktlen;\r\nwhile (lp->rx_ring[lp->rx_tail].addr & MACB_BIT(RX_USED)) {\r\np_recv = lp->rx_buffers + lp->rx_tail * MAX_RBUFF_SZ;\r\npktlen = MACB_BF(RX_FRMLEN, lp->rx_ring[lp->rx_tail].ctrl);\r\nskb = netdev_alloc_skb(dev, pktlen + 2);\r\nif (skb) {\r\nskb_reserve(skb, 2);\r\nmemcpy(skb_put(skb, pktlen), p_recv, pktlen);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nlp->stats.rx_packets++;\r\nlp->stats.rx_bytes += pktlen;\r\nnetif_rx(skb);\r\n} else {\r\nlp->stats.rx_dropped++;\r\n}\r\nif (lp->rx_ring[lp->rx_tail].ctrl & MACB_BIT(RX_MHASH_MATCH))\r\nlp->stats.multicast++;\r\nlp->rx_ring[lp->rx_tail].addr &= ~MACB_BIT(RX_USED);\r\nif (lp->rx_tail == MAX_RX_DESCR - 1)\r\nlp->rx_tail = 0;\r\nelse\r\nlp->rx_tail++;\r\n}\r\n}\r\nstatic irqreturn_t at91ether_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct macb *lp = netdev_priv(dev);\r\nu32 intstatus, ctl;\r\nintstatus = macb_readl(lp, ISR);\r\nif (intstatus & MACB_BIT(RCOMP))\r\nat91ether_rx(dev);\r\nif (intstatus & MACB_BIT(TCOMP)) {\r\nif (intstatus & (MACB_BIT(ISR_TUND) | MACB_BIT(ISR_RLE)))\r\nlp->stats.tx_errors++;\r\nif (lp->skb) {\r\ndev_kfree_skb_irq(lp->skb);\r\nlp->skb = NULL;\r\ndma_unmap_single(NULL, lp->skb_physaddr, lp->skb_length, DMA_TO_DEVICE);\r\nlp->stats.tx_packets++;\r\nlp->stats.tx_bytes += lp->skb_length;\r\n}\r\nnetif_wake_queue(dev);\r\n}\r\nif (intstatus & MACB_BIT(RXUBR)) {\r\nctl = macb_readl(lp, NCR);\r\nmacb_writel(lp, NCR, ctl & ~MACB_BIT(RE));\r\nmacb_writel(lp, NCR, ctl | MACB_BIT(RE));\r\n}\r\nif (intstatus & MACB_BIT(ISR_ROVR))\r\nnetdev_err(dev, "ROVR error\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void at91ether_poll_controller(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nat91ether_interrupt(dev->irq, dev);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int __init at91ether_probe(struct platform_device *pdev)\r\n{\r\nstruct macb_platform_data *board_data = dev_get_platdata(&pdev->dev);\r\nstruct resource *regs;\r\nstruct net_device *dev;\r\nstruct phy_device *phydev;\r\nstruct macb *lp;\r\nint res;\r\nu32 reg;\r\nconst char *mac;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!regs)\r\nreturn -ENOENT;\r\ndev = alloc_etherdev(sizeof(struct macb));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nlp = netdev_priv(dev);\r\nlp->pdev = pdev;\r\nlp->dev = dev;\r\nspin_lock_init(&lp->lock);\r\ndev->base_addr = regs->start;\r\nlp->regs = devm_ioremap(&pdev->dev, regs->start, resource_size(regs));\r\nif (!lp->regs) {\r\nres = -ENOMEM;\r\ngoto err_free_dev;\r\n}\r\nlp->pclk = devm_clk_get(&pdev->dev, "ether_clk");\r\nif (IS_ERR(lp->pclk)) {\r\nres = PTR_ERR(lp->pclk);\r\ngoto err_free_dev;\r\n}\r\nclk_enable(lp->pclk);\r\nlp->hclk = ERR_PTR(-ENOENT);\r\nlp->tx_clk = ERR_PTR(-ENOENT);\r\ndev->irq = platform_get_irq(pdev, 0);\r\nres = devm_request_irq(&pdev->dev, dev->irq, at91ether_interrupt, 0, dev->name, dev);\r\nif (res)\r\ngoto err_disable_clock;\r\nether_setup(dev);\r\ndev->netdev_ops = &at91ether_netdev_ops;\r\ndev->ethtool_ops = &macb_ethtool_ops;\r\nplatform_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nmac = of_get_mac_address(pdev->dev.of_node);\r\nif (mac)\r\nmemcpy(lp->dev->dev_addr, mac, ETH_ALEN);\r\nelse\r\nmacb_get_hwaddr(lp);\r\nres = of_get_phy_mode(pdev->dev.of_node);\r\nif (res < 0) {\r\nif (board_data && board_data->is_rmii)\r\nlp->phy_interface = PHY_INTERFACE_MODE_RMII;\r\nelse\r\nlp->phy_interface = PHY_INTERFACE_MODE_MII;\r\n} else {\r\nlp->phy_interface = res;\r\n}\r\nmacb_writel(lp, NCR, 0);\r\nreg = MACB_BF(CLK, MACB_CLK_DIV32) | MACB_BIT(BIG);\r\nif (lp->phy_interface == PHY_INTERFACE_MODE_RMII)\r\nreg |= MACB_BIT(RM9200_RMII);\r\nmacb_writel(lp, NCFGR, reg);\r\nres = register_netdev(dev);\r\nif (res)\r\ngoto err_disable_clock;\r\nres = macb_mii_init(lp);\r\nif (res)\r\ngoto err_out_unregister_netdev;\r\nnetif_carrier_off(dev);\r\nphydev = lp->phy_dev;\r\nnetdev_info(dev, "attached PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)\n",\r\nphydev->drv->name, dev_name(&phydev->dev),\r\nphydev->irq);\r\nnetdev_info(dev, "AT91 ethernet at 0x%08lx int=%d (%pM)\n",\r\ndev->base_addr, dev->irq, dev->dev_addr);\r\nreturn 0;\r\nerr_out_unregister_netdev:\r\nunregister_netdev(dev);\r\nerr_disable_clock:\r\nclk_disable(lp->pclk);\r\nerr_free_dev:\r\nfree_netdev(dev);\r\nreturn res;\r\n}\r\nstatic int at91ether_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct macb *lp = netdev_priv(dev);\r\nif (lp->phy_dev)\r\nphy_disconnect(lp->phy_dev);\r\nmdiobus_unregister(lp->mii_bus);\r\nkfree(lp->mii_bus->irq);\r\nmdiobus_free(lp->mii_bus);\r\nunregister_netdev(dev);\r\nclk_disable(lp->pclk);\r\nfree_netdev(dev);\r\nreturn 0;\r\n}\r\nstatic int at91ether_suspend(struct platform_device *pdev, pm_message_t mesg)\r\n{\r\nstruct net_device *net_dev = platform_get_drvdata(pdev);\r\nstruct macb *lp = netdev_priv(net_dev);\r\nif (netif_running(net_dev)) {\r\nnetif_stop_queue(net_dev);\r\nnetif_device_detach(net_dev);\r\nclk_disable(lp->pclk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int at91ether_resume(struct platform_device *pdev)\r\n{\r\nstruct net_device *net_dev = platform_get_drvdata(pdev);\r\nstruct macb *lp = netdev_priv(net_dev);\r\nif (netif_running(net_dev)) {\r\nclk_enable(lp->pclk);\r\nnetif_device_attach(net_dev);\r\nnetif_start_queue(net_dev);\r\n}\r\nreturn 0;\r\n}
