int spk_chartab_get_value(char *keyword)\r\n{\r\nint value = 0;\r\nif (!strcmp(keyword, "ALPHA"))\r\nvalue = ALPHA;\r\nelse if (!strcmp(keyword, "B_CTL"))\r\nvalue = B_CTL;\r\nelse if (!strcmp(keyword, "WDLM"))\r\nvalue = WDLM;\r\nelse if (!strcmp(keyword, "A_PUNC"))\r\nvalue = A_PUNC;\r\nelse if (!strcmp(keyword, "PUNC"))\r\nvalue = PUNC;\r\nelse if (!strcmp(keyword, "NUM"))\r\nvalue = NUM;\r\nelse if (!strcmp(keyword, "A_CAP"))\r\nvalue = A_CAP;\r\nelse if (!strcmp(keyword, "B_CAPSYM"))\r\nvalue = B_CAPSYM;\r\nelse if (!strcmp(keyword, "B_SYM"))\r\nvalue = B_SYM;\r\nreturn value;\r\n}\r\nvoid speakup_register_var(struct var_t *var)\r\n{\r\nstatic char nothing[2] = "\0";\r\nint i;\r\nstruct st_var_header *p_header;\r\nBUG_ON(!var || var->var_id < 0 || var->var_id >= MAXVARS);\r\nif (var_ptrs[0] == NULL) {\r\nfor (i = 0; i < MAXVARS; i++) {\r\np_header = &var_headers[i];\r\nvar_ptrs[p_header->var_id] = p_header;\r\np_header->data = NULL;\r\n}\r\n}\r\np_header = var_ptrs[var->var_id];\r\nif (p_header->data != NULL)\r\nreturn;\r\np_header->data = var;\r\nswitch (p_header->var_type) {\r\ncase VAR_STRING:\r\nspk_set_string_var(nothing, p_header, 0);\r\nbreak;\r\ncase VAR_NUM:\r\ncase VAR_TIME:\r\nspk_set_num_var(0, p_header, E_DEFAULT);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nvoid speakup_unregister_var(enum var_id_t var_id)\r\n{\r\nstruct st_var_header *p_header;\r\nBUG_ON(var_id < 0 || var_id >= MAXVARS);\r\np_header = var_ptrs[var_id];\r\np_header->data = NULL;\r\n}\r\nstruct st_var_header *spk_get_var_header(enum var_id_t var_id)\r\n{\r\nstruct st_var_header *p_header;\r\nif (var_id < 0 || var_id >= MAXVARS)\r\nreturn NULL;\r\np_header = var_ptrs[var_id];\r\nif (p_header->data == NULL)\r\nreturn NULL;\r\nreturn p_header;\r\n}\r\nstruct st_var_header *spk_var_header_by_name(const char *name)\r\n{\r\nint i;\r\nif (!name)\r\nreturn NULL;\r\nfor (i = 0; i < MAXVARS; i++) {\r\nif (strcmp(name, var_ptrs[i]->name) == 0)\r\nreturn var_ptrs[i];\r\n}\r\nreturn NULL;\r\n}\r\nstruct var_t *spk_get_var(enum var_id_t var_id)\r\n{\r\nBUG_ON(var_id < 0 || var_id >= MAXVARS);\r\nBUG_ON(!var_ptrs[var_id]);\r\nreturn var_ptrs[var_id]->data;\r\n}\r\nstruct punc_var_t *spk_get_punc_var(enum var_id_t var_id)\r\n{\r\nstruct punc_var_t *rv = NULL;\r\nstruct punc_var_t *where;\r\nwhere = punc_vars;\r\nwhile ((where->var_id != -1) && (rv == NULL)) {\r\nif (where->var_id == var_id)\r\nrv = where;\r\nelse\r\nwhere++;\r\n}\r\nreturn rv;\r\n}\r\nint spk_set_num_var(int input, struct st_var_header *var, int how)\r\n{\r\nint val;\r\nshort ret = 0;\r\nint *p_val = var->p_val;\r\nint l;\r\nchar buf[32];\r\nchar *cp;\r\nstruct var_t *var_data = var->data;\r\nif (var_data == NULL)\r\nreturn -ENODATA;\r\nif (how == E_NEW_DEFAULT) {\r\nif (input < var_data->u.n.low || input > var_data->u.n.high)\r\nreturn -ERANGE;\r\nvar_data->u.n.default_val = input;\r\nreturn 0;\r\n}\r\nif (how == E_DEFAULT) {\r\nval = var_data->u.n.default_val;\r\nret = -ERESTART;\r\n} else {\r\nif (how == E_SET)\r\nval = input;\r\nelse\r\nval = var_data->u.n.value;\r\nif (how == E_INC)\r\nval += input;\r\nelse if (how == E_DEC)\r\nval -= input;\r\nif (val < var_data->u.n.low || val > var_data->u.n.high)\r\nreturn -ERANGE;\r\n}\r\nvar_data->u.n.value = val;\r\nif (var->var_type == VAR_TIME && p_val != NULL) {\r\n*p_val = msecs_to_jiffies(val);\r\nreturn ret;\r\n}\r\nif (p_val != NULL)\r\n*p_val = val;\r\nif (var->var_id == PUNC_LEVEL) {\r\nspk_punc_mask = spk_punc_masks[val];\r\nreturn ret;\r\n}\r\nif (var_data->u.n.multiplier != 0)\r\nval *= var_data->u.n.multiplier;\r\nval += var_data->u.n.offset;\r\nif (var->var_id < FIRST_SYNTH_VAR || synth == NULL)\r\nreturn ret;\r\nif (synth->synth_adjust != NULL) {\r\nint status = synth->synth_adjust(var);\r\nreturn (status != 0) ? status : ret;\r\n}\r\nif (!var_data->u.n.synth_fmt)\r\nreturn ret;\r\nif (var->var_id == PITCH)\r\ncp = spk_pitch_buff;\r\nelse\r\ncp = buf;\r\nif (!var_data->u.n.out_str)\r\nl = sprintf(cp, var_data->u.n.synth_fmt, (int)val);\r\nelse\r\nl = sprintf(cp,\r\nvar_data->u.n.synth_fmt, var_data->u.n.out_str[val]);\r\nsynth_printf("%s", cp);\r\nreturn ret;\r\n}\r\nint spk_set_string_var(const char *page, struct st_var_header *var, int len)\r\n{\r\nstruct var_t *var_data = var->data;\r\nif (var_data == NULL)\r\nreturn -ENODATA;\r\nif (len > MAXVARLEN)\r\nreturn -E2BIG;\r\nif (!len) {\r\nif (!var_data->u.s.default_val)\r\nreturn 0;\r\nif (!var->p_val)\r\nvar->p_val = var_data->u.s.default_val;\r\nif (var->p_val != var_data->u.s.default_val)\r\nstrcpy((char *)var->p_val, var_data->u.s.default_val);\r\nreturn -ERESTART;\r\n} else if (var->p_val)\r\nstrcpy((char *)var->p_val, page);\r\nelse\r\nreturn -E2BIG;\r\nreturn 0;\r\n}\r\nint spk_set_mask_bits(const char *input, const int which, const int how)\r\n{\r\nu_char *cp;\r\nshort mask = spk_punc_info[which].mask;\r\nif (how&1) {\r\nfor (cp = (u_char *)spk_punc_info[3].value; *cp; cp++)\r\nspk_chartab[*cp] &= ~mask;\r\n}\r\ncp = (u_char *)input;\r\nif (!cp)\r\ncp = spk_punc_info[which].value;\r\nelse {\r\nfor (; *cp; cp++) {\r\nif (*cp < SPACE)\r\nbreak;\r\nif (mask < PUNC) {\r\nif (!(spk_chartab[*cp]&PUNC))\r\nbreak;\r\n} else if (spk_chartab[*cp]&B_NUM)\r\nbreak;\r\n}\r\nif (*cp)\r\nreturn -EINVAL;\r\ncp = (u_char *)input;\r\n}\r\nif (how&2) {\r\nfor (; *cp; cp++)\r\nif (*cp > SPACE)\r\nspk_chartab[*cp] |= mask;\r\n} else {\r\nfor (; *cp; cp++)\r\nif (*cp > SPACE)\r\nspk_chartab[*cp] &= ~mask;\r\n}\r\nreturn 0;\r\n}\r\nchar *spk_strlwr(char *s)\r\n{\r\nchar *p;\r\nif (s == NULL)\r\nreturn NULL;\r\nfor (p = s; *p; p++)\r\n*p = tolower(*p);\r\nreturn s;\r\n}\r\nchar *spk_s2uchar(char *start, char *dest)\r\n{\r\nint val = 0;\r\nval = simple_strtoul(skip_spaces(start), &start, 10);\r\nif (*start == ',')\r\nstart++;\r\n*dest = (u_char)val;\r\nreturn start;\r\n}
