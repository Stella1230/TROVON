static void s6000_pcm_enqueue_dma(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct s6000_runtime_data *prtd = runtime->private_data;\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct s6000_pcm_dma_params *par;\r\nint channel;\r\nunsigned int period_size;\r\nunsigned int dma_offset;\r\ndma_addr_t dma_pos;\r\ndma_addr_t src, dst;\r\npar = snd_soc_dai_get_dma_data(soc_runtime->cpu_dai, substream);\r\nperiod_size = snd_pcm_lib_period_bytes(substream);\r\ndma_offset = prtd->period * period_size;\r\ndma_pos = runtime->dma_addr + dma_offset;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nsrc = dma_pos;\r\ndst = par->sif_out;\r\nchannel = par->dma_out;\r\n} else {\r\nsrc = par->sif_in;\r\ndst = dma_pos;\r\nchannel = par->dma_in;\r\n}\r\nif (!s6dmac_channel_enabled(DMA_MASK_DMAC(channel),\r\nDMA_INDEX_CHNL(channel)))\r\nreturn;\r\nif (s6dmac_fifo_full(DMA_MASK_DMAC(channel), DMA_INDEX_CHNL(channel))) {\r\nprintk(KERN_ERR "s6000-pcm: fifo full\n");\r\nreturn;\r\n}\r\nif (WARN_ON(period_size & 15))\r\nreturn;\r\ns6dmac_put_fifo(DMA_MASK_DMAC(channel), DMA_INDEX_CHNL(channel),\r\nsrc, dst, period_size);\r\nprtd->period++;\r\nif (unlikely(prtd->period >= runtime->periods))\r\nprtd->period = 0;\r\n}\r\nstatic irqreturn_t s6000_pcm_irq(int irq, void *data)\r\n{\r\nstruct snd_pcm *pcm = data;\r\nstruct snd_soc_pcm_runtime *runtime = pcm->private_data;\r\nstruct s6000_runtime_data *prtd;\r\nunsigned int has_xrun;\r\nint i, ret = IRQ_NONE;\r\nfor (i = 0; i < 2; ++i) {\r\nstruct snd_pcm_substream *substream = pcm->streams[i].substream;\r\nstruct s6000_pcm_dma_params *params =\r\nsnd_soc_dai_get_dma_data(runtime->cpu_dai, substream);\r\nu32 channel;\r\nunsigned int pending;\r\nif (substream == SNDRV_PCM_STREAM_PLAYBACK)\r\nchannel = params->dma_out;\r\nelse\r\nchannel = params->dma_in;\r\nhas_xrun = params->check_xrun(runtime->cpu_dai);\r\nif (!channel)\r\ncontinue;\r\nif (unlikely(has_xrun & (1 << i)) &&\r\nsubstream->runtime &&\r\nsnd_pcm_running(substream)) {\r\ndev_dbg(pcm->dev, "xrun\n");\r\nsnd_pcm_stream_lock(substream);\r\nsnd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);\r\nsnd_pcm_stream_unlock(substream);\r\nret = IRQ_HANDLED;\r\n}\r\npending = s6dmac_int_sources(DMA_MASK_DMAC(channel),\r\nDMA_INDEX_CHNL(channel));\r\nif (pending & 1) {\r\nret = IRQ_HANDLED;\r\nif (likely(substream->runtime &&\r\nsnd_pcm_running(substream))) {\r\nsnd_pcm_period_elapsed(substream);\r\ndev_dbg(pcm->dev, "period elapsed %x %x\n",\r\ns6dmac_cur_src(DMA_MASK_DMAC(channel),\r\nDMA_INDEX_CHNL(channel)),\r\ns6dmac_cur_dst(DMA_MASK_DMAC(channel),\r\nDMA_INDEX_CHNL(channel)));\r\nprtd = substream->runtime->private_data;\r\nspin_lock(&prtd->lock);\r\ns6000_pcm_enqueue_dma(substream);\r\nspin_unlock(&prtd->lock);\r\n}\r\n}\r\nif (unlikely(pending & ~7)) {\r\nif (pending & (1 << 3))\r\nprintk(KERN_WARNING\r\n"s6000-pcm: DMA %x Underflow\n",\r\nchannel);\r\nif (pending & (1 << 4))\r\nprintk(KERN_WARNING\r\n"s6000-pcm: DMA %x Overflow\n",\r\nchannel);\r\nif (pending & 0x1e0)\r\nprintk(KERN_WARNING\r\n"s6000-pcm: DMA %x Master Error "\r\n"(mask %x)\n",\r\nchannel, pending >> 5);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int s6000_pcm_start(struct snd_pcm_substream *substream)\r\n{\r\nstruct s6000_runtime_data *prtd = substream->runtime->private_data;\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct s6000_pcm_dma_params *par;\r\nunsigned long flags;\r\nint srcinc;\r\nu32 dma;\r\npar = snd_soc_dai_get_dma_data(soc_runtime->cpu_dai, substream);\r\nspin_lock_irqsave(&prtd->lock, flags);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nsrcinc = 1;\r\ndma = par->dma_out;\r\n} else {\r\nsrcinc = 0;\r\ndma = par->dma_in;\r\n}\r\ns6dmac_enable_chan(DMA_MASK_DMAC(dma), DMA_INDEX_CHNL(dma),\r\n1 ,\r\n0 ,\r\nsrcinc ,\r\nsrcinc^1 ,\r\n0 ,\r\n0 ,\r\n0 ,\r\n4 ,\r\n-1 ,\r\n0 ,\r\n0 ,\r\n1 );\r\ns6000_pcm_enqueue_dma(substream);\r\ns6000_pcm_enqueue_dma(substream);\r\nspin_unlock_irqrestore(&prtd->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int s6000_pcm_stop(struct snd_pcm_substream *substream)\r\n{\r\nstruct s6000_runtime_data *prtd = substream->runtime->private_data;\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct s6000_pcm_dma_params *par;\r\nunsigned long flags;\r\nu32 channel;\r\npar = snd_soc_dai_get_dma_data(soc_runtime->cpu_dai, substream);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nchannel = par->dma_out;\r\nelse\r\nchannel = par->dma_in;\r\ns6dmac_set_terminal_count(DMA_MASK_DMAC(channel),\r\nDMA_INDEX_CHNL(channel), 0);\r\nspin_lock_irqsave(&prtd->lock, flags);\r\ns6dmac_disable_chan(DMA_MASK_DMAC(channel), DMA_INDEX_CHNL(channel));\r\nspin_unlock_irqrestore(&prtd->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int s6000_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct s6000_pcm_dma_params *par;\r\nint ret;\r\npar = snd_soc_dai_get_dma_data(soc_runtime->cpu_dai, substream);\r\nret = par->trigger(substream, cmd, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nret = s6000_pcm_start(substream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nret = s6000_pcm_stop(substream);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\nreturn par->trigger(substream, cmd, 1);\r\n}\r\nstatic int s6000_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct s6000_runtime_data *prtd = substream->runtime->private_data;\r\nprtd->period = 0;\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t s6000_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct s6000_pcm_dma_params *par;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct s6000_runtime_data *prtd = runtime->private_data;\r\nunsigned long flags;\r\nunsigned int offset;\r\ndma_addr_t count;\r\npar = snd_soc_dai_get_dma_data(soc_runtime->cpu_dai, substream);\r\nspin_lock_irqsave(&prtd->lock, flags);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ncount = s6dmac_cur_src(DMA_MASK_DMAC(par->dma_out),\r\nDMA_INDEX_CHNL(par->dma_out));\r\nelse\r\ncount = s6dmac_cur_dst(DMA_MASK_DMAC(par->dma_in),\r\nDMA_INDEX_CHNL(par->dma_in));\r\ncount -= runtime->dma_addr;\r\nspin_unlock_irqrestore(&prtd->lock, flags);\r\noffset = bytes_to_frames(runtime, count);\r\nif (unlikely(offset >= runtime->buffer_size))\r\noffset = 0;\r\nreturn offset;\r\n}\r\nstatic int s6000_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct s6000_pcm_dma_params *par;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct s6000_runtime_data *prtd;\r\nint ret;\r\npar = snd_soc_dai_get_dma_data(soc_runtime->cpu_dai, substream);\r\nsnd_soc_set_runtime_hwparams(substream, &s6000_pcm_hardware);\r\nret = snd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_BYTES, 16);\r\nif (ret < 0)\r\nreturn ret;\r\nret = snd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_BUFFER_BYTES, 16);\r\nif (ret < 0)\r\nreturn ret;\r\nret = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (ret < 0)\r\nreturn ret;\r\nif (par->same_rate) {\r\nint rate;\r\nspin_lock(&par->lock);\r\nrate = par->rate;\r\nspin_unlock(&par->lock);\r\nif (rate != -1) {\r\nret = snd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\nrate, rate);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nprtd = kzalloc(sizeof(struct s6000_runtime_data), GFP_KERNEL);\r\nif (prtd == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_init(&prtd->lock);\r\nruntime->private_data = prtd;\r\nreturn 0;\r\n}\r\nstatic int s6000_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct s6000_runtime_data *prtd = runtime->private_data;\r\nkfree(prtd);\r\nreturn 0;\r\n}\r\nstatic int s6000_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct s6000_pcm_dma_params *par;\r\nint ret;\r\nret = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (ret < 0) {\r\nprintk(KERN_WARNING "s6000-pcm: allocation of memory failed\n");\r\nreturn ret;\r\n}\r\npar = snd_soc_dai_get_dma_data(soc_runtime->cpu_dai, substream);\r\nif (par->same_rate) {\r\nspin_lock(&par->lock);\r\nif (par->rate == -1 ||\r\n!(par->in_use & ~(1 << substream->stream))) {\r\npar->rate = params_rate(hw_params);\r\npar->in_use |= 1 << substream->stream;\r\n} else if (params_rate(hw_params) != par->rate) {\r\nsnd_pcm_lib_free_pages(substream);\r\npar->in_use &= ~(1 << substream->stream);\r\nret = -EBUSY;\r\n}\r\nspin_unlock(&par->lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic int s6000_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *soc_runtime = substream->private_data;\r\nstruct s6000_pcm_dma_params *par =\r\nsnd_soc_dai_get_dma_data(soc_runtime->cpu_dai, substream);\r\nspin_lock(&par->lock);\r\npar->in_use &= ~(1 << substream->stream);\r\nif (!par->in_use)\r\npar->rate = -1;\r\nspin_unlock(&par->lock);\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic void s6000_pcm_free(struct snd_pcm *pcm)\r\n{\r\nstruct snd_soc_pcm_runtime *runtime = pcm->private_data;\r\nstruct s6000_pcm_dma_params *params =\r\nsnd_soc_dai_get_dma_data(runtime->cpu_dai,\r\npcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream);\r\nfree_irq(params->irq, pcm);\r\nsnd_pcm_lib_preallocate_free_for_all(pcm);\r\n}\r\nstatic int s6000_pcm_new(struct snd_soc_pcm_runtime *runtime)\r\n{\r\nstruct snd_card *card = runtime->card->snd_card;\r\nstruct snd_pcm *pcm = runtime->pcm;\r\nstruct s6000_pcm_dma_params *params;\r\nint res;\r\nparams = snd_soc_dai_get_dma_data(runtime->cpu_dai,\r\npcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream);\r\nres = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(32));\r\nif (res)\r\nreturn res;\r\nif (params->dma_in) {\r\ns6dmac_disable_chan(DMA_MASK_DMAC(params->dma_in),\r\nDMA_INDEX_CHNL(params->dma_in));\r\ns6dmac_int_sources(DMA_MASK_DMAC(params->dma_in),\r\nDMA_INDEX_CHNL(params->dma_in));\r\n}\r\nif (params->dma_out) {\r\ns6dmac_disable_chan(DMA_MASK_DMAC(params->dma_out),\r\nDMA_INDEX_CHNL(params->dma_out));\r\ns6dmac_int_sources(DMA_MASK_DMAC(params->dma_out),\r\nDMA_INDEX_CHNL(params->dma_out));\r\n}\r\nres = request_irq(params->irq, s6000_pcm_irq, IRQF_SHARED,\r\n"s6000-audio", pcm);\r\nif (res) {\r\nprintk(KERN_ERR "s6000-pcm couldn't get IRQ\n");\r\nreturn res;\r\n}\r\nres = snd_pcm_lib_preallocate_pages_for_all(pcm,\r\nSNDRV_DMA_TYPE_DEV,\r\ncard->dev,\r\nS6_PCM_PREALLOCATE_SIZE,\r\nS6_PCM_PREALLOCATE_MAX);\r\nif (res)\r\nprintk(KERN_WARNING "s6000-pcm: preallocation failed\n");\r\nspin_lock_init(&params->lock);\r\nparams->in_use = 0;\r\nparams->rate = -1;\r\nreturn 0;\r\n}\r\nstatic int s6000_soc_platform_probe(struct platform_device *pdev)\r\n{\r\nreturn snd_soc_register_platform(&pdev->dev, &s6000_soc_platform);\r\n}\r\nstatic int s6000_soc_platform_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nreturn 0;\r\n}
