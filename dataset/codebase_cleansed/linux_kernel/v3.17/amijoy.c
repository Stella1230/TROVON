static irqreturn_t amijoy_interrupt(int irq, void *dummy)\r\n{\r\nint i, data = 0, button = 0;\r\nfor (i = 0; i < 2; i++)\r\nif (amijoy[i]) {\r\nswitch (i) {\r\ncase 0: data = ~amiga_custom.joy0dat; button = (~ciaa.pra >> 6) & 1; break;\r\ncase 1: data = ~amiga_custom.joy1dat; button = (~ciaa.pra >> 7) & 1; break;\r\n}\r\ninput_report_key(amijoy_dev[i], BTN_TRIGGER, button);\r\ninput_report_abs(amijoy_dev[i], ABS_X, ((data >> 1) & 1) - ((data >> 9) & 1));\r\ndata = ~(data ^ (data << 1));\r\ninput_report_abs(amijoy_dev[i], ABS_Y, ((data >> 1) & 1) - ((data >> 9) & 1));\r\ninput_sync(amijoy_dev[i]);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int amijoy_open(struct input_dev *dev)\r\n{\r\nint err;\r\nerr = mutex_lock_interruptible(&amijoy_mutex);\r\nif (err)\r\nreturn err;\r\nif (!amijoy_used && request_irq(IRQ_AMIGA_VERTB, amijoy_interrupt, 0, "amijoy", amijoy_interrupt)) {\r\nprintk(KERN_ERR "amijoy.c: Can't allocate irq %d\n", IRQ_AMIGA_VERTB);\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\namijoy_used++;\r\nout:\r\nmutex_unlock(&amijoy_mutex);\r\nreturn err;\r\n}\r\nstatic void amijoy_close(struct input_dev *dev)\r\n{\r\nmutex_lock(&amijoy_mutex);\r\nif (!--amijoy_used)\r\nfree_irq(IRQ_AMIGA_VERTB, amijoy_interrupt);\r\nmutex_unlock(&amijoy_mutex);\r\n}\r\nstatic int __init amijoy_init(void)\r\n{\r\nint i, j;\r\nint err;\r\nif (!MACH_IS_AMIGA)\r\nreturn -ENODEV;\r\nfor (i = 0; i < 2; i++) {\r\nif (!amijoy[i])\r\ncontinue;\r\namijoy_dev[i] = input_allocate_device();\r\nif (!amijoy_dev[i]) {\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nif (!request_mem_region(CUSTOM_PHYSADDR + 10 + i * 2, 2, "amijoy [Denise]")) {\r\ninput_free_device(amijoy_dev[i]);\r\nerr = -EBUSY;\r\ngoto fail;\r\n}\r\namijoy_dev[i]->name = "Amiga joystick";\r\namijoy_dev[i]->phys = amijoy_phys[i];\r\namijoy_dev[i]->id.bustype = BUS_AMIGA;\r\namijoy_dev[i]->id.vendor = 0x0001;\r\namijoy_dev[i]->id.product = 0x0003;\r\namijoy_dev[i]->id.version = 0x0100;\r\namijoy_dev[i]->open = amijoy_open;\r\namijoy_dev[i]->close = amijoy_close;\r\namijoy_dev[i]->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\namijoy_dev[i]->absbit[0] = BIT_MASK(ABS_X) | BIT_MASK(ABS_Y);\r\namijoy_dev[i]->keybit[BIT_WORD(BTN_LEFT)] = BIT_MASK(BTN_LEFT) |\r\nBIT_MASK(BTN_MIDDLE) | BIT_MASK(BTN_RIGHT);\r\nfor (j = 0; j < 2; j++) {\r\ninput_set_abs_params(amijoy_dev[i], ABS_X + j,\r\n-1, 1, 0, 0);\r\n}\r\nerr = input_register_device(amijoy_dev[i]);\r\nif (err) {\r\ninput_free_device(amijoy_dev[i]);\r\ngoto fail;\r\n}\r\n}\r\nreturn 0;\r\nfail: while (--i >= 0)\r\nif (amijoy[i]) {\r\ninput_unregister_device(amijoy_dev[i]);\r\nrelease_mem_region(CUSTOM_PHYSADDR + 10 + i * 2, 2);\r\n}\r\nreturn err;\r\n}\r\nstatic void __exit amijoy_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < 2; i++)\r\nif (amijoy[i]) {\r\ninput_unregister_device(amijoy_dev[i]);\r\nrelease_mem_region(CUSTOM_PHYSADDR + 10 + i * 2, 2);\r\n}\r\n}
