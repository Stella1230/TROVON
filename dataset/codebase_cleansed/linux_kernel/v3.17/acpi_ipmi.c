static struct acpi_ipmi_device *\r\nipmi_dev_alloc(int iface, struct device *dev, acpi_handle handle)\r\n{\r\nstruct acpi_ipmi_device *ipmi_device;\r\nint err;\r\nipmi_user_t user;\r\nipmi_device = kzalloc(sizeof(*ipmi_device), GFP_KERNEL);\r\nif (!ipmi_device)\r\nreturn NULL;\r\nkref_init(&ipmi_device->kref);\r\nINIT_LIST_HEAD(&ipmi_device->head);\r\nINIT_LIST_HEAD(&ipmi_device->tx_msg_list);\r\nspin_lock_init(&ipmi_device->tx_msg_lock);\r\nipmi_device->handle = handle;\r\nipmi_device->dev = get_device(dev);\r\nipmi_device->ipmi_ifnum = iface;\r\nerr = ipmi_create_user(iface, &driver_data.ipmi_hndlrs,\r\nipmi_device, &user);\r\nif (err) {\r\nput_device(dev);\r\nkfree(ipmi_device);\r\nreturn NULL;\r\n}\r\nipmi_device->user_interface = user;\r\nreturn ipmi_device;\r\n}\r\nstatic void ipmi_dev_release(struct acpi_ipmi_device *ipmi_device)\r\n{\r\nipmi_destroy_user(ipmi_device->user_interface);\r\nput_device(ipmi_device->dev);\r\nkfree(ipmi_device);\r\n}\r\nstatic void ipmi_dev_release_kref(struct kref *kref)\r\n{\r\nstruct acpi_ipmi_device *ipmi =\r\ncontainer_of(kref, struct acpi_ipmi_device, kref);\r\nipmi_dev_release(ipmi);\r\n}\r\nstatic void __ipmi_dev_kill(struct acpi_ipmi_device *ipmi_device)\r\n{\r\nlist_del(&ipmi_device->head);\r\nif (driver_data.selected_smi == ipmi_device)\r\ndriver_data.selected_smi = NULL;\r\nipmi_device->dead = true;\r\n}\r\nstatic struct acpi_ipmi_device *acpi_ipmi_dev_get(void)\r\n{\r\nstruct acpi_ipmi_device *ipmi_device = NULL;\r\nmutex_lock(&driver_data.ipmi_lock);\r\nif (driver_data.selected_smi) {\r\nipmi_device = driver_data.selected_smi;\r\nkref_get(&ipmi_device->kref);\r\n}\r\nmutex_unlock(&driver_data.ipmi_lock);\r\nreturn ipmi_device;\r\n}\r\nstatic void acpi_ipmi_dev_put(struct acpi_ipmi_device *ipmi_device)\r\n{\r\nkref_put(&ipmi_device->kref, ipmi_dev_release_kref);\r\n}\r\nstatic struct acpi_ipmi_msg *ipmi_msg_alloc(void)\r\n{\r\nstruct acpi_ipmi_device *ipmi;\r\nstruct acpi_ipmi_msg *ipmi_msg;\r\nipmi = acpi_ipmi_dev_get();\r\nif (!ipmi)\r\nreturn NULL;\r\nipmi_msg = kzalloc(sizeof(struct acpi_ipmi_msg), GFP_KERNEL);\r\nif (!ipmi_msg) {\r\nacpi_ipmi_dev_put(ipmi);\r\nreturn NULL;\r\n}\r\nkref_init(&ipmi_msg->kref);\r\ninit_completion(&ipmi_msg->tx_complete);\r\nINIT_LIST_HEAD(&ipmi_msg->head);\r\nipmi_msg->device = ipmi;\r\nipmi_msg->msg_done = ACPI_IPMI_UNKNOWN;\r\nreturn ipmi_msg;\r\n}\r\nstatic void ipmi_msg_release(struct acpi_ipmi_msg *tx_msg)\r\n{\r\nacpi_ipmi_dev_put(tx_msg->device);\r\nkfree(tx_msg);\r\n}\r\nstatic void ipmi_msg_release_kref(struct kref *kref)\r\n{\r\nstruct acpi_ipmi_msg *tx_msg =\r\ncontainer_of(kref, struct acpi_ipmi_msg, kref);\r\nipmi_msg_release(tx_msg);\r\n}\r\nstatic struct acpi_ipmi_msg *acpi_ipmi_msg_get(struct acpi_ipmi_msg *tx_msg)\r\n{\r\nkref_get(&tx_msg->kref);\r\nreturn tx_msg;\r\n}\r\nstatic void acpi_ipmi_msg_put(struct acpi_ipmi_msg *tx_msg)\r\n{\r\nkref_put(&tx_msg->kref, ipmi_msg_release_kref);\r\n}\r\nstatic int acpi_format_ipmi_request(struct acpi_ipmi_msg *tx_msg,\r\nacpi_physical_address address,\r\nacpi_integer *value)\r\n{\r\nstruct kernel_ipmi_msg *msg;\r\nstruct acpi_ipmi_buffer *buffer;\r\nstruct acpi_ipmi_device *device;\r\nunsigned long flags;\r\nmsg = &tx_msg->tx_message;\r\nmsg->netfn = IPMI_OP_RGN_NETFN(address);\r\nmsg->cmd = IPMI_OP_RGN_CMD(address);\r\nmsg->data = tx_msg->data;\r\nbuffer = (struct acpi_ipmi_buffer *)value;\r\nif (buffer->length > ACPI_IPMI_MAX_MSG_LENGTH) {\r\ndev_WARN_ONCE(tx_msg->device->dev, true,\r\n"Unexpected request (msg len %d).\n",\r\nbuffer->length);\r\nreturn -EINVAL;\r\n}\r\nmsg->data_len = buffer->length;\r\nmemcpy(tx_msg->data, buffer->data, msg->data_len);\r\ntx_msg->addr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\r\ntx_msg->addr.channel = IPMI_BMC_CHANNEL;\r\ntx_msg->addr.data[0] = 0;\r\ndevice = tx_msg->device;\r\nspin_lock_irqsave(&device->tx_msg_lock, flags);\r\ndevice->curr_msgid++;\r\ntx_msg->tx_msgid = device->curr_msgid;\r\nspin_unlock_irqrestore(&device->tx_msg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void acpi_format_ipmi_response(struct acpi_ipmi_msg *msg,\r\nacpi_integer *value)\r\n{\r\nstruct acpi_ipmi_buffer *buffer;\r\nbuffer = (struct acpi_ipmi_buffer *)value;\r\nbuffer->status = msg->msg_done;\r\nif (msg->msg_done != ACPI_IPMI_OK)\r\nreturn;\r\nbuffer->length = msg->rx_len;\r\nmemcpy(buffer->data, msg->data, msg->rx_len);\r\n}\r\nstatic void ipmi_flush_tx_msg(struct acpi_ipmi_device *ipmi)\r\n{\r\nstruct acpi_ipmi_msg *tx_msg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ipmi->tx_msg_lock, flags);\r\nwhile (!list_empty(&ipmi->tx_msg_list)) {\r\ntx_msg = list_first_entry(&ipmi->tx_msg_list,\r\nstruct acpi_ipmi_msg,\r\nhead);\r\nlist_del(&tx_msg->head);\r\nspin_unlock_irqrestore(&ipmi->tx_msg_lock, flags);\r\ncomplete(&tx_msg->tx_complete);\r\nacpi_ipmi_msg_put(tx_msg);\r\nspin_lock_irqsave(&ipmi->tx_msg_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&ipmi->tx_msg_lock, flags);\r\n}\r\nstatic void ipmi_cancel_tx_msg(struct acpi_ipmi_device *ipmi,\r\nstruct acpi_ipmi_msg *msg)\r\n{\r\nstruct acpi_ipmi_msg *tx_msg, *temp;\r\nbool msg_found = false;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ipmi->tx_msg_lock, flags);\r\nlist_for_each_entry_safe(tx_msg, temp, &ipmi->tx_msg_list, head) {\r\nif (msg == tx_msg) {\r\nmsg_found = true;\r\nlist_del(&tx_msg->head);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&ipmi->tx_msg_lock, flags);\r\nif (msg_found)\r\nacpi_ipmi_msg_put(tx_msg);\r\n}\r\nstatic void ipmi_msg_handler(struct ipmi_recv_msg *msg, void *user_msg_data)\r\n{\r\nstruct acpi_ipmi_device *ipmi_device = user_msg_data;\r\nbool msg_found = false;\r\nstruct acpi_ipmi_msg *tx_msg, *temp;\r\nstruct device *dev = ipmi_device->dev;\r\nunsigned long flags;\r\nif (msg->user != ipmi_device->user_interface) {\r\ndev_warn(dev,\r\n"Unexpected response is returned. returned user %p, expected user %p\n",\r\nmsg->user, ipmi_device->user_interface);\r\ngoto out_msg;\r\n}\r\nspin_lock_irqsave(&ipmi_device->tx_msg_lock, flags);\r\nlist_for_each_entry_safe(tx_msg, temp, &ipmi_device->tx_msg_list, head) {\r\nif (msg->msgid == tx_msg->tx_msgid) {\r\nmsg_found = true;\r\nlist_del(&tx_msg->head);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&ipmi_device->tx_msg_lock, flags);\r\nif (!msg_found) {\r\ndev_warn(dev,\r\n"Unexpected response (msg id %ld) is returned.\n",\r\nmsg->msgid);\r\ngoto out_msg;\r\n}\r\nif (msg->msg.data_len > ACPI_IPMI_MAX_MSG_LENGTH) {\r\ndev_WARN_ONCE(dev, true,\r\n"Unexpected response (msg len %d).\n",\r\nmsg->msg.data_len);\r\ngoto out_comp;\r\n}\r\nmsg->recv_type = IPMI_RESPONSE_RECV_TYPE;\r\nif (msg->recv_type == IPMI_RESPONSE_RECV_TYPE &&\r\nmsg->msg.data_len == 1) {\r\nif (msg->msg.data[0] == IPMI_TIMEOUT_COMPLETION_CODE) {\r\ndev_WARN_ONCE(dev, true,\r\n"Unexpected response (timeout).\n");\r\ntx_msg->msg_done = ACPI_IPMI_TIMEOUT;\r\n}\r\ngoto out_comp;\r\n}\r\ntx_msg->rx_len = msg->msg.data_len;\r\nmemcpy(tx_msg->data, msg->msg.data, tx_msg->rx_len);\r\ntx_msg->msg_done = ACPI_IPMI_OK;\r\nout_comp:\r\ncomplete(&tx_msg->tx_complete);\r\nacpi_ipmi_msg_put(tx_msg);\r\nout_msg:\r\nipmi_free_recv_msg(msg);\r\n}\r\nstatic void ipmi_register_bmc(int iface, struct device *dev)\r\n{\r\nstruct acpi_ipmi_device *ipmi_device, *temp;\r\nint err;\r\nstruct ipmi_smi_info smi_data;\r\nacpi_handle handle;\r\nerr = ipmi_get_smi_info(iface, &smi_data);\r\nif (err)\r\nreturn;\r\nif (smi_data.addr_src != SI_ACPI)\r\ngoto err_ref;\r\nhandle = smi_data.addr_info.acpi_info.acpi_handle;\r\nif (!handle)\r\ngoto err_ref;\r\nipmi_device = ipmi_dev_alloc(iface, smi_data.dev, handle);\r\nif (!ipmi_device) {\r\ndev_warn(smi_data.dev, "Can't create IPMI user interface\n");\r\ngoto err_ref;\r\n}\r\nmutex_lock(&driver_data.ipmi_lock);\r\nlist_for_each_entry(temp, &driver_data.ipmi_devices, head) {\r\nif (temp->handle == handle)\r\ngoto err_lock;\r\n}\r\nif (!driver_data.selected_smi)\r\ndriver_data.selected_smi = ipmi_device;\r\nlist_add_tail(&ipmi_device->head, &driver_data.ipmi_devices);\r\nmutex_unlock(&driver_data.ipmi_lock);\r\nput_device(smi_data.dev);\r\nreturn;\r\nerr_lock:\r\nmutex_unlock(&driver_data.ipmi_lock);\r\nipmi_dev_release(ipmi_device);\r\nerr_ref:\r\nput_device(smi_data.dev);\r\nreturn;\r\n}\r\nstatic void ipmi_bmc_gone(int iface)\r\n{\r\nstruct acpi_ipmi_device *ipmi_device, *temp;\r\nbool dev_found = false;\r\nmutex_lock(&driver_data.ipmi_lock);\r\nlist_for_each_entry_safe(ipmi_device, temp,\r\n&driver_data.ipmi_devices, head) {\r\nif (ipmi_device->ipmi_ifnum != iface) {\r\ndev_found = true;\r\n__ipmi_dev_kill(ipmi_device);\r\nbreak;\r\n}\r\n}\r\nif (!driver_data.selected_smi)\r\ndriver_data.selected_smi = list_first_entry_or_null(\r\n&driver_data.ipmi_devices,\r\nstruct acpi_ipmi_device, head);\r\nmutex_unlock(&driver_data.ipmi_lock);\r\nif (dev_found) {\r\nipmi_flush_tx_msg(ipmi_device);\r\nacpi_ipmi_dev_put(ipmi_device);\r\n}\r\n}\r\nstatic acpi_status\r\nacpi_ipmi_space_handler(u32 function, acpi_physical_address address,\r\nu32 bits, acpi_integer *value,\r\nvoid *handler_context, void *region_context)\r\n{\r\nstruct acpi_ipmi_msg *tx_msg;\r\nstruct acpi_ipmi_device *ipmi_device;\r\nint err;\r\nacpi_status status;\r\nunsigned long flags;\r\nif ((function & ACPI_IO_MASK) == ACPI_READ)\r\nreturn AE_TYPE;\r\ntx_msg = ipmi_msg_alloc();\r\nif (!tx_msg)\r\nreturn AE_NOT_EXIST;\r\nipmi_device = tx_msg->device;\r\nif (acpi_format_ipmi_request(tx_msg, address, value) != 0) {\r\nipmi_msg_release(tx_msg);\r\nreturn AE_TYPE;\r\n}\r\nacpi_ipmi_msg_get(tx_msg);\r\nmutex_lock(&driver_data.ipmi_lock);\r\nif (ipmi_device->dead) {\r\nmutex_unlock(&driver_data.ipmi_lock);\r\nipmi_msg_release(tx_msg);\r\nreturn AE_NOT_EXIST;\r\n}\r\nspin_lock_irqsave(&ipmi_device->tx_msg_lock, flags);\r\nlist_add_tail(&tx_msg->head, &ipmi_device->tx_msg_list);\r\nspin_unlock_irqrestore(&ipmi_device->tx_msg_lock, flags);\r\nmutex_unlock(&driver_data.ipmi_lock);\r\nerr = ipmi_request_settime(ipmi_device->user_interface,\r\n&tx_msg->addr,\r\ntx_msg->tx_msgid,\r\n&tx_msg->tx_message,\r\nNULL, 0, 0, IPMI_TIMEOUT);\r\nif (err) {\r\nstatus = AE_ERROR;\r\ngoto out_msg;\r\n}\r\nwait_for_completion(&tx_msg->tx_complete);\r\nacpi_format_ipmi_response(tx_msg, value);\r\nstatus = AE_OK;\r\nout_msg:\r\nipmi_cancel_tx_msg(ipmi_device, tx_msg);\r\nacpi_ipmi_msg_put(tx_msg);\r\nreturn status;\r\n}\r\nstatic int __init acpi_ipmi_init(void)\r\n{\r\nint result;\r\nacpi_status status;\r\nif (acpi_disabled)\r\nreturn 0;\r\nstatus = acpi_install_address_space_handler(ACPI_ROOT_OBJECT,\r\nACPI_ADR_SPACE_IPMI,\r\n&acpi_ipmi_space_handler,\r\nNULL, NULL);\r\nif (ACPI_FAILURE(status)) {\r\npr_warn("Can't register IPMI opregion space handle\n");\r\nreturn -EINVAL;\r\n}\r\nresult = ipmi_smi_watcher_register(&driver_data.bmc_events);\r\nif (result)\r\npr_err("Can't register IPMI system interface watcher\n");\r\nreturn result;\r\n}\r\nstatic void __exit acpi_ipmi_exit(void)\r\n{\r\nstruct acpi_ipmi_device *ipmi_device;\r\nif (acpi_disabled)\r\nreturn;\r\nipmi_smi_watcher_unregister(&driver_data.bmc_events);\r\nmutex_lock(&driver_data.ipmi_lock);\r\nwhile (!list_empty(&driver_data.ipmi_devices)) {\r\nipmi_device = list_first_entry(&driver_data.ipmi_devices,\r\nstruct acpi_ipmi_device,\r\nhead);\r\n__ipmi_dev_kill(ipmi_device);\r\nmutex_unlock(&driver_data.ipmi_lock);\r\nipmi_flush_tx_msg(ipmi_device);\r\nacpi_ipmi_dev_put(ipmi_device);\r\nmutex_lock(&driver_data.ipmi_lock);\r\n}\r\nmutex_unlock(&driver_data.ipmi_lock);\r\nacpi_remove_address_space_handler(ACPI_ROOT_OBJECT,\r\nACPI_ADR_SPACE_IPMI,\r\n&acpi_ipmi_space_handler);\r\n}
