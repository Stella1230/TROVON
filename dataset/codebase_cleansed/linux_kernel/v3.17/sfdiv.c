int\r\nsgl_fdiv (sgl_floating_point * srcptr1, sgl_floating_point * srcptr2,\r\nsgl_floating_point * dstptr, unsigned int *status)\r\n{\r\nregister unsigned int opnd1, opnd2, opnd3, result;\r\nregister int dest_exponent, count;\r\nregister boolean inexact = FALSE, guardbit = FALSE, stickybit = FALSE;\r\nboolean is_tiny;\r\nopnd1 = *srcptr1;\r\nopnd2 = *srcptr2;\r\nif (Sgl_sign(opnd1) ^ Sgl_sign(opnd2)) Sgl_setnegativezero(result);\r\nelse Sgl_setzero(result);\r\nif (Sgl_isinfinity_exponent(opnd1)) {\r\nif (Sgl_iszero_mantissa(opnd1)) {\r\nif (Sgl_isnotnan(opnd2)) {\r\nif (Sgl_isinfinity(opnd2)) {\r\nif (Is_invalidtrap_enabled())\r\nreturn(INVALIDEXCEPTION);\r\nSet_invalidflag();\r\nSgl_makequietnan(result);\r\n*dstptr = result;\r\nreturn(NOEXCEPTION);\r\n}\r\nSgl_setinfinity_exponentmantissa(result);\r\n*dstptr = result;\r\nreturn(NOEXCEPTION);\r\n}\r\n}\r\nelse {\r\nif (Sgl_isone_signaling(opnd1)) {\r\nif (Is_invalidtrap_enabled())\r\nreturn(INVALIDEXCEPTION);\r\nSet_invalidflag();\r\nSgl_set_quiet(opnd1);\r\n}\r\nelse if (Sgl_is_signalingnan(opnd2)) {\r\nif (Is_invalidtrap_enabled())\r\nreturn(INVALIDEXCEPTION);\r\nSet_invalidflag();\r\nSgl_set_quiet(opnd2);\r\n*dstptr = opnd2;\r\nreturn(NOEXCEPTION);\r\n}\r\n*dstptr = opnd1;\r\nreturn(NOEXCEPTION);\r\n}\r\n}\r\nif (Sgl_isinfinity_exponent(opnd2)) {\r\nif (Sgl_iszero_mantissa(opnd2)) {\r\nSgl_setzero_exponentmantissa(result);\r\n*dstptr = result;\r\nreturn(NOEXCEPTION);\r\n}\r\nif (Sgl_isone_signaling(opnd2)) {\r\nif (Is_invalidtrap_enabled()) return(INVALIDEXCEPTION);\r\nSet_invalidflag();\r\nSgl_set_quiet(opnd2);\r\n}\r\n*dstptr = opnd2;\r\nreturn(NOEXCEPTION);\r\n}\r\nif (Sgl_iszero_exponentmantissa(opnd2)) {\r\nif (Sgl_iszero_exponentmantissa(opnd1)) {\r\nif (Is_invalidtrap_enabled()) return(INVALIDEXCEPTION);\r\nSet_invalidflag();\r\nSgl_makequietnan(result);\r\n*dstptr = result;\r\nreturn(NOEXCEPTION);\r\n}\r\nif (Is_divisionbyzerotrap_enabled())\r\nreturn(DIVISIONBYZEROEXCEPTION);\r\nSet_divisionbyzeroflag();\r\nSgl_setinfinity_exponentmantissa(result);\r\n*dstptr = result;\r\nreturn(NOEXCEPTION);\r\n}\r\ndest_exponent = Sgl_exponent(opnd1) - Sgl_exponent(opnd2) + SGL_BIAS;\r\nif (Sgl_isnotzero_exponent(opnd1)) {\r\nSgl_clear_signexponent_set_hidden(opnd1);\r\n}\r\nelse {\r\nif (Sgl_iszero_mantissa(opnd1)) {\r\nSgl_setzero_exponentmantissa(result);\r\n*dstptr = result;\r\nreturn(NOEXCEPTION);\r\n}\r\nSgl_clear_signexponent(opnd1);\r\nSgl_leftshiftby1(opnd1);\r\nSgl_normalize(opnd1,dest_exponent);\r\n}\r\nif (Sgl_isnotzero_exponent(opnd2)) {\r\nSgl_clear_signexponent_set_hidden(opnd2);\r\n}\r\nelse {\r\nSgl_clear_signexponent(opnd2);\r\nSgl_leftshiftby1(opnd2);\r\nwhile(Sgl_iszero_hiddenhigh7mantissa(opnd2)) {\r\nSgl_leftshiftby8(opnd2);\r\ndest_exponent += 8;\r\n}\r\nif(Sgl_iszero_hiddenhigh3mantissa(opnd2)) {\r\nSgl_leftshiftby4(opnd2);\r\ndest_exponent += 4;\r\n}\r\nwhile(Sgl_iszero_hidden(opnd2)) {\r\nSgl_leftshiftby1(opnd2);\r\ndest_exponent += 1;\r\n}\r\n}\r\nSgl_subtract(opnd1,opnd2,opnd1);\r\nSgl_setzero(opnd3);\r\nfor (count=1;count<=SGL_P && Sgl_all(opnd1);count++) {\r\nSgl_leftshiftby1(opnd1);\r\nSgl_leftshiftby1(opnd3);\r\nif (Sgl_iszero_sign(opnd1)) {\r\nSgl_setone_lowmantissa(opnd3);\r\nSgl_subtract(opnd1,opnd2,opnd1);\r\n}\r\nelse Sgl_addition(opnd1,opnd2,opnd1);\r\n}\r\nif (count <= SGL_P) {\r\nSgl_leftshiftby1(opnd3);\r\nSgl_setone_lowmantissa(opnd3);\r\nSgl_leftshift(opnd3,SGL_P-count);\r\nif (Sgl_iszero_hidden(opnd3)) {\r\nSgl_leftshiftby1(opnd3);\r\ndest_exponent--;\r\n}\r\n}\r\nelse {\r\nif (Sgl_iszero_hidden(opnd3)) {\r\nSgl_leftshiftby1(opnd1);\r\nSgl_leftshiftby1(opnd3);\r\nif (Sgl_iszero_sign(opnd1)) {\r\nSgl_setone_lowmantissa(opnd3);\r\nSgl_subtract(opnd1,opnd2,opnd1);\r\n}\r\nelse Sgl_addition(opnd1,opnd2,opnd1);\r\ndest_exponent--;\r\n}\r\nif (Sgl_iszero_sign(opnd1)) guardbit = TRUE;\r\nstickybit = Sgl_all(opnd1);\r\n}\r\ninexact = guardbit | stickybit;\r\nif (inexact && (dest_exponent > 0 || Is_underflowtrap_enabled())) {\r\nSgl_clear_signexponent(opnd3);\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nif (Sgl_iszero_sign(result))\r\nSgl_increment_mantissa(opnd3);\r\nbreak;\r\ncase ROUNDMINUS:\r\nif (Sgl_isone_sign(result))\r\nSgl_increment_mantissa(opnd3);\r\nbreak;\r\ncase ROUNDNEAREST:\r\nif (guardbit) {\r\nif (stickybit || Sgl_isone_lowmantissa(opnd3))\r\nSgl_increment_mantissa(opnd3);\r\n}\r\n}\r\nif (Sgl_isone_hidden(opnd3)) dest_exponent++;\r\n}\r\nSgl_set_mantissa(result,opnd3);\r\nif (dest_exponent >= SGL_INFINITY_EXPONENT) {\r\nif (Is_overflowtrap_enabled()) {\r\nSgl_setwrapped_exponent(result,dest_exponent,ovfl);\r\n*dstptr = result;\r\nif (inexact)\r\nif (Is_inexacttrap_enabled())\r\nreturn(OVERFLOWEXCEPTION | INEXACTEXCEPTION);\r\nelse Set_inexactflag();\r\nreturn(OVERFLOWEXCEPTION);\r\n}\r\nSet_overflowflag();\r\nSgl_setoverflow(result);\r\ninexact = TRUE;\r\n}\r\nelse if (dest_exponent <= 0) {\r\nif (Is_underflowtrap_enabled()) {\r\nSgl_setwrapped_exponent(result,dest_exponent,unfl);\r\n*dstptr = result;\r\nif (inexact)\r\nif (Is_inexacttrap_enabled())\r\nreturn(UNDERFLOWEXCEPTION | INEXACTEXCEPTION);\r\nelse Set_inexactflag();\r\nreturn(UNDERFLOWEXCEPTION);\r\n}\r\nis_tiny = TRUE;\r\nif (dest_exponent == 0 && inexact) {\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nif (Sgl_iszero_sign(result)) {\r\nSgl_increment(opnd3);\r\nif (Sgl_isone_hiddenoverflow(opnd3))\r\nis_tiny = FALSE;\r\nSgl_decrement(opnd3);\r\n}\r\nbreak;\r\ncase ROUNDMINUS:\r\nif (Sgl_isone_sign(result)) {\r\nSgl_increment(opnd3);\r\nif (Sgl_isone_hiddenoverflow(opnd3))\r\nis_tiny = FALSE;\r\nSgl_decrement(opnd3);\r\n}\r\nbreak;\r\ncase ROUNDNEAREST:\r\nif (guardbit && (stickybit ||\r\nSgl_isone_lowmantissa(opnd3))) {\r\nSgl_increment(opnd3);\r\nif (Sgl_isone_hiddenoverflow(opnd3))\r\nis_tiny = FALSE;\r\nSgl_decrement(opnd3);\r\n}\r\nbreak;\r\n}\r\n}\r\nstickybit = inexact;\r\nSgl_denormalize(opnd3,dest_exponent,guardbit,stickybit,inexact);\r\nif (inexact) {\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nif (Sgl_iszero_sign(result)) {\r\nSgl_increment(opnd3);\r\n}\r\nbreak;\r\ncase ROUNDMINUS:\r\nif (Sgl_isone_sign(result)) {\r\nSgl_increment(opnd3);\r\n}\r\nbreak;\r\ncase ROUNDNEAREST:\r\nif (guardbit && (stickybit ||\r\nSgl_isone_lowmantissa(opnd3))) {\r\nSgl_increment(opnd3);\r\n}\r\nbreak;\r\n}\r\nif (is_tiny) Set_underflowflag();\r\n}\r\nSgl_set_exponentmantissa(result,opnd3);\r\n}\r\nelse Sgl_set_exponent(result,dest_exponent);\r\n*dstptr = result;\r\nif (inexact) {\r\nif (Is_inexacttrap_enabled()) return(INEXACTEXCEPTION);\r\nelse Set_inexactflag();\r\n}\r\nreturn(NOEXCEPTION);\r\n}
