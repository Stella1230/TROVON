static long zl6100_l2d(s16 l)\r\n{\r\ns16 exponent;\r\ns32 mantissa;\r\nlong val;\r\nexponent = l >> 11;\r\nmantissa = ((s16)((l & 0x7ff) << 5)) >> 5;\r\nval = mantissa;\r\nval = val * 1000L;\r\nif (exponent >= 0)\r\nval <<= exponent;\r\nelse\r\nval >>= -exponent;\r\nreturn val;\r\n}\r\nstatic u16 zl6100_d2l(long val)\r\n{\r\ns16 exponent = 0, mantissa;\r\nbool negative = false;\r\nif (val == 0)\r\nreturn 0;\r\nif (val < 0) {\r\nnegative = true;\r\nval = -val;\r\n}\r\nwhile (val >= MAX_MANTISSA && exponent < 15) {\r\nexponent++;\r\nval >>= 1;\r\n}\r\nwhile (val < MIN_MANTISSA && exponent > -15) {\r\nexponent--;\r\nval <<= 1;\r\n}\r\nmantissa = DIV_ROUND_CLOSEST(val, 1000);\r\nif (mantissa > 0x3ff)\r\nmantissa = 0x3ff;\r\nif (negative)\r\nmantissa = -mantissa;\r\nreturn (mantissa & 0x7ff) | ((exponent << 11) & 0xf800);\r\n}\r\nstatic inline void zl6100_wait(const struct zl6100_data *data)\r\n{\r\nif (data->delay) {\r\ns64 delta = ktime_us_delta(ktime_get(), data->access);\r\nif (delta < data->delay)\r\nudelay(data->delay - delta);\r\n}\r\n}\r\nstatic int zl6100_read_word_data(struct i2c_client *client, int page, int reg)\r\n{\r\nconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\r\nstruct zl6100_data *data = to_zl6100_data(info);\r\nint ret, vreg;\r\nif (page > 0)\r\nreturn -ENXIO;\r\nif (data->id == zl2005) {\r\nswitch (reg) {\r\ncase PMBUS_VOUT_OV_WARN_LIMIT:\r\ncase PMBUS_VOUT_UV_WARN_LIMIT:\r\ncase PMBUS_IOUT_OC_WARN_LIMIT:\r\nreturn -ENXIO;\r\n}\r\n}\r\nswitch (reg) {\r\ncase PMBUS_VIRT_READ_VMON:\r\nvreg = MFR_READ_VMON;\r\nbreak;\r\ncase PMBUS_VIRT_VMON_OV_WARN_LIMIT:\r\ncase PMBUS_VIRT_VMON_OV_FAULT_LIMIT:\r\nvreg = MFR_VMON_OV_FAULT_LIMIT;\r\nbreak;\r\ncase PMBUS_VIRT_VMON_UV_WARN_LIMIT:\r\ncase PMBUS_VIRT_VMON_UV_FAULT_LIMIT:\r\nvreg = MFR_VMON_UV_FAULT_LIMIT;\r\nbreak;\r\ndefault:\r\nif (reg >= PMBUS_VIRT_BASE)\r\nreturn -ENXIO;\r\nvreg = reg;\r\nbreak;\r\n}\r\nzl6100_wait(data);\r\nret = pmbus_read_word_data(client, page, vreg);\r\ndata->access = ktime_get();\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (reg) {\r\ncase PMBUS_VIRT_VMON_OV_WARN_LIMIT:\r\nret = zl6100_d2l(DIV_ROUND_CLOSEST(zl6100_l2d(ret) * 9, 10));\r\nbreak;\r\ncase PMBUS_VIRT_VMON_UV_WARN_LIMIT:\r\nret = zl6100_d2l(DIV_ROUND_CLOSEST(zl6100_l2d(ret) * 11, 10));\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int zl6100_read_byte_data(struct i2c_client *client, int page, int reg)\r\n{\r\nconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\r\nstruct zl6100_data *data = to_zl6100_data(info);\r\nint ret, status;\r\nif (page > 0)\r\nreturn -ENXIO;\r\nzl6100_wait(data);\r\nswitch (reg) {\r\ncase PMBUS_VIRT_STATUS_VMON:\r\nret = pmbus_read_byte_data(client, 0,\r\nPMBUS_STATUS_MFR_SPECIFIC);\r\nif (ret < 0)\r\nbreak;\r\nstatus = 0;\r\nif (ret & VMON_UV_WARNING)\r\nstatus |= PB_VOLTAGE_UV_WARNING;\r\nif (ret & VMON_OV_WARNING)\r\nstatus |= PB_VOLTAGE_OV_WARNING;\r\nif (ret & VMON_UV_FAULT)\r\nstatus |= PB_VOLTAGE_UV_FAULT;\r\nif (ret & VMON_OV_FAULT)\r\nstatus |= PB_VOLTAGE_OV_FAULT;\r\nret = status;\r\nbreak;\r\ndefault:\r\nret = pmbus_read_byte_data(client, page, reg);\r\nbreak;\r\n}\r\ndata->access = ktime_get();\r\nreturn ret;\r\n}\r\nstatic int zl6100_write_word_data(struct i2c_client *client, int page, int reg,\r\nu16 word)\r\n{\r\nconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\r\nstruct zl6100_data *data = to_zl6100_data(info);\r\nint ret, vreg;\r\nif (page > 0)\r\nreturn -ENXIO;\r\nswitch (reg) {\r\ncase PMBUS_VIRT_VMON_OV_WARN_LIMIT:\r\nword = zl6100_d2l(DIV_ROUND_CLOSEST(zl6100_l2d(word) * 10, 9));\r\nvreg = MFR_VMON_OV_FAULT_LIMIT;\r\npmbus_clear_cache(client);\r\nbreak;\r\ncase PMBUS_VIRT_VMON_OV_FAULT_LIMIT:\r\nvreg = MFR_VMON_OV_FAULT_LIMIT;\r\npmbus_clear_cache(client);\r\nbreak;\r\ncase PMBUS_VIRT_VMON_UV_WARN_LIMIT:\r\nword = zl6100_d2l(DIV_ROUND_CLOSEST(zl6100_l2d(word) * 10, 11));\r\nvreg = MFR_VMON_UV_FAULT_LIMIT;\r\npmbus_clear_cache(client);\r\nbreak;\r\ncase PMBUS_VIRT_VMON_UV_FAULT_LIMIT:\r\nvreg = MFR_VMON_UV_FAULT_LIMIT;\r\npmbus_clear_cache(client);\r\nbreak;\r\ndefault:\r\nif (reg >= PMBUS_VIRT_BASE)\r\nreturn -ENXIO;\r\nvreg = reg;\r\n}\r\nzl6100_wait(data);\r\nret = pmbus_write_word_data(client, page, vreg, word);\r\ndata->access = ktime_get();\r\nreturn ret;\r\n}\r\nstatic int zl6100_write_byte(struct i2c_client *client, int page, u8 value)\r\n{\r\nconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\r\nstruct zl6100_data *data = to_zl6100_data(info);\r\nint ret;\r\nif (page > 0)\r\nreturn -ENXIO;\r\nzl6100_wait(data);\r\nret = pmbus_write_byte(client, page, value);\r\ndata->access = ktime_get();\r\nreturn ret;\r\n}\r\nstatic int zl6100_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nstruct zl6100_data *data;\r\nstruct pmbus_driver_info *info;\r\nu8 device_id[I2C_SMBUS_BLOCK_MAX + 1];\r\nconst struct i2c_device_id *mid;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_READ_WORD_DATA\r\n| I2C_FUNC_SMBUS_READ_BLOCK_DATA))\r\nreturn -ENODEV;\r\nret = i2c_smbus_read_block_data(client, ZL6100_DEVICE_ID,\r\ndevice_id);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to read device ID\n");\r\nreturn ret;\r\n}\r\ndevice_id[ret] = '\0';\r\ndev_info(&client->dev, "Device ID %s\n", device_id);\r\nmid = NULL;\r\nfor (mid = zl6100_id; mid->name[0]; mid++) {\r\nif (!strncasecmp(mid->name, device_id, strlen(mid->name)))\r\nbreak;\r\n}\r\nif (!mid->name[0]) {\r\ndev_err(&client->dev, "Unsupported device\n");\r\nreturn -ENODEV;\r\n}\r\nif (id->driver_data != mid->driver_data)\r\ndev_notice(&client->dev,\r\n"Device mismatch: Configured %s, detected %s\n",\r\nid->name, mid->name);\r\ndata = devm_kzalloc(&client->dev, sizeof(struct zl6100_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->id = mid->driver_data;\r\ndata->delay = delay;\r\ndata->access = ktime_get();\r\nzl6100_wait(data);\r\ninfo = &data->info;\r\ninfo->pages = 1;\r\ninfo->func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_STATUS_INPUT\r\n| PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\r\n| PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT\r\n| PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP;\r\nif (data->id == zl2004 || data->id == zl9101 || data->id == zl9117)\r\ninfo->func[0] |= PMBUS_HAVE_VMON | PMBUS_HAVE_STATUS_VMON;\r\nret = i2c_smbus_read_word_data(client, ZL6100_MFR_CONFIG);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret & ZL6100_MFR_XTEMP_ENABLE)\r\ninfo->func[0] |= PMBUS_HAVE_TEMP2;\r\ndata->access = ktime_get();\r\nzl6100_wait(data);\r\ninfo->read_word_data = zl6100_read_word_data;\r\ninfo->read_byte_data = zl6100_read_byte_data;\r\ninfo->write_word_data = zl6100_write_word_data;\r\ninfo->write_byte = zl6100_write_byte;\r\nreturn pmbus_do_probe(client, mid, info);\r\n}
