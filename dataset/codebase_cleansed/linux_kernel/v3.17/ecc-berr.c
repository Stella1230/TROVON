static inline void dec_ecc_be_ack(void)\r\n{\r\n*kn0x_erraddr = 0;\r\niob();\r\n}\r\nstatic int dec_ecc_be_backend(struct pt_regs *regs, int is_fixup, int invoker)\r\n{\r\nstatic const char excstr[] = "exception";\r\nstatic const char intstr[] = "interrupt";\r\nstatic const char cpustr[] = "CPU";\r\nstatic const char dmastr[] = "DMA";\r\nstatic const char readstr[] = "read";\r\nstatic const char mreadstr[] = "memory read";\r\nstatic const char writestr[] = "write";\r\nstatic const char mwritstr[] = "partial memory write";\r\nstatic const char timestr[] = "timeout";\r\nstatic const char overstr[] = "overrun";\r\nstatic const char eccstr[] = "ECC error";\r\nconst char *kind, *agent, *cycle, *event;\r\nconst char *status = "", *xbit = "", *fmt = "";\r\nunsigned long address;\r\nu16 syn = 0, sngl;\r\nint i = 0;\r\nu32 erraddr = *kn0x_erraddr;\r\nu32 chksyn = *kn0x_chksyn;\r\nint action = MIPS_BE_FATAL;\r\nif ((erraddr & (KN0X_EAR_VALID | KN0X_EAR_ECCERR)) == KN0X_EAR_VALID)\r\ndec_ecc_be_ack();\r\nkind = invoker ? intstr : excstr;\r\nif (!(erraddr & KN0X_EAR_VALID)) {\r\nprintk(KERN_ALERT "Unidentified bus error %s\n", kind);\r\nreturn action;\r\n}\r\nagent = (erraddr & KN0X_EAR_CPU) ? cpustr : dmastr;\r\nif (erraddr & KN0X_EAR_ECCERR) {\r\ncycle = (erraddr & KN0X_EAR_WRITE) ? mwritstr : mreadstr;\r\nevent = eccstr;\r\n} else {\r\ncycle = (erraddr & KN0X_EAR_WRITE) ? writestr : readstr;\r\nevent = (erraddr & KN0X_EAR_CPU) ? timestr : overstr;\r\n}\r\naddress = erraddr & KN0X_EAR_ADDRESS;\r\nif ((erraddr & (KN0X_EAR_WRITE | KN0X_EAR_ECCERR)) == KN0X_EAR_ECCERR)\r\naddress = (address & ~0xfffLL) | ((address - 5) & 0xfffLL);\r\naddress <<= 2;\r\nif (erraddr & KN0X_EAR_CPU && is_fixup)\r\naction = MIPS_BE_FIXUP;\r\nif (erraddr & KN0X_EAR_ECCERR) {\r\nstatic const u8 data_sbit[32] = {\r\n0x4f, 0x4a, 0x52, 0x54, 0x57, 0x58, 0x5b, 0x5d,\r\n0x23, 0x25, 0x26, 0x29, 0x2a, 0x2c, 0x31, 0x34,\r\n0x0e, 0x0b, 0x13, 0x15, 0x16, 0x19, 0x1a, 0x1c,\r\n0x62, 0x64, 0x67, 0x68, 0x6b, 0x6d, 0x70, 0x75,\r\n};\r\nstatic const u8 data_mbit[25] = {\r\n0x07, 0x0d, 0x1f,\r\n0x2f, 0x32, 0x37, 0x38, 0x3b, 0x3d, 0x3e,\r\n0x43, 0x45, 0x46, 0x49, 0x4c, 0x51, 0x5e,\r\n0x61, 0x6e, 0x73, 0x76, 0x79, 0x7a, 0x7c, 0x7f,\r\n};\r\nstatic const char sbestr[] = "corrected single";\r\nstatic const char dbestr[] = "uncorrectable double";\r\nstatic const char mbestr[] = "uncorrectable multiple";\r\nif (!(address & 0x4))\r\nsyn = chksyn;\r\nelse\r\nsyn = chksyn >> 16;\r\nif (!(syn & KN0X_ESR_VLDLO)) {\r\ndec_ecc_be_ack();\r\nfmt = KERN_ALERT "%s" "invalid\n";\r\n} else {\r\nsngl = syn & KN0X_ESR_SNGLO;\r\nsyn &= KN0X_ESR_SYNLO;\r\nfor (i = 0; i < 25; i++)\r\nif (syn == data_mbit[i])\r\nbreak;\r\nif (i < 25) {\r\nstatus = mbestr;\r\n} else if (!sngl) {\r\nstatus = dbestr;\r\n} else {\r\nvolatile u32 *ptr =\r\n(void *)CKSEG1ADDR(address);\r\n*ptr = *ptr;\r\niob();\r\nstatus = sbestr;\r\naction = MIPS_BE_DISCARD;\r\n}\r\ndec_ecc_be_ack();\r\nif (syn && syn == (syn & -syn)) {\r\nif (syn == 0x01) {\r\nfmt = KERN_ALERT "%s"\r\n"%#04x -- %s bit error "\r\n"at check bit C%s\n";\r\nxbit = "X";\r\n} else {\r\nfmt = KERN_ALERT "%s"\r\n"%#04x -- %s bit error "\r\n"at check bit C%s%u\n";\r\n}\r\ni = syn >> 2;\r\n} else {\r\nfor (i = 0; i < 32; i++)\r\nif (syn == data_sbit[i])\r\nbreak;\r\nif (i < 32)\r\nfmt = KERN_ALERT "%s"\r\n"%#04x -- %s bit error "\r\n"at data bit D%s%u\n";\r\nelse\r\nfmt = KERN_ALERT "%s"\r\n"%#04x -- %s bit error\n";\r\n}\r\n}\r\n}\r\nif (action != MIPS_BE_FIXUP)\r\nprintk(KERN_ALERT "Bus error %s: %s %s %s at %#010lx\n",\r\nkind, agent, cycle, event, address);\r\nif (action != MIPS_BE_FIXUP && erraddr & KN0X_EAR_ECCERR)\r\nprintk(fmt, " ECC syndrome ", syn, status, xbit, i);\r\nreturn action;\r\n}\r\nint dec_ecc_be_handler(struct pt_regs *regs, int is_fixup)\r\n{\r\nreturn dec_ecc_be_backend(regs, is_fixup, 0);\r\n}\r\nirqreturn_t dec_ecc_be_interrupt(int irq, void *dev_id)\r\n{\r\nstruct pt_regs *regs = get_irq_regs();\r\nint action = dec_ecc_be_backend(regs, 0, 1);\r\nif (action == MIPS_BE_DISCARD)\r\nreturn IRQ_HANDLED;\r\nprintk(KERN_ALERT "Fatal bus interrupt, epc == %08lx, ra == %08lx\n",\r\nregs->cp0_epc, regs->regs[31]);\r\ndie("Unrecoverable bus error", regs);\r\n}\r\nstatic inline void dec_kn02_be_init(void)\r\n{\r\nvolatile u32 *csr = (void *)CKSEG1ADDR(KN02_SLOT_BASE + KN02_CSR);\r\nkn0x_erraddr = (void *)CKSEG1ADDR(KN02_SLOT_BASE + KN02_ERRADDR);\r\nkn0x_chksyn = (void *)CKSEG1ADDR(KN02_SLOT_BASE + KN02_CHKSYN);\r\ncached_kn02_csr = *csr | KN02_CSR_LEDS;\r\ncached_kn02_csr &= ~(KN02_CSR_DIAGCHK | KN02_CSR_DIAGGEN);\r\ncached_kn02_csr |= KN02_CSR_CORRECT;\r\n*csr = cached_kn02_csr;\r\niob();\r\n}\r\nstatic inline void dec_kn03_be_init(void)\r\n{\r\nvolatile u32 *mcr = (void *)CKSEG1ADDR(KN03_SLOT_BASE + IOASIC_MCR);\r\nvolatile u32 *mbcs = (void *)CKSEG1ADDR(KN4K_SLOT_BASE + KN4K_MB_CSR);\r\nkn0x_erraddr = (void *)CKSEG1ADDR(KN03_SLOT_BASE + IOASIC_ERRADDR);\r\nkn0x_chksyn = (void *)CKSEG1ADDR(KN03_SLOT_BASE + IOASIC_CHKSYN);\r\n*mcr = (*mcr & ~(KN03_MCR_DIAGCHK | KN03_MCR_DIAGGEN)) |\r\nKN03_MCR_CORRECT;\r\nif (current_cpu_type() == CPU_R4400SC)\r\n*mbcs |= KN4K_MB_CSR_EE;\r\nfast_iob();\r\n}\r\nvoid __init dec_ecc_be_init(void)\r\n{\r\nif (mips_machtype == MACH_DS5000_200)\r\ndec_kn02_be_init();\r\nelse\r\ndec_kn03_be_init();\r\ndec_ecc_be_ack();\r\n}
