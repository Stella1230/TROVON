static int st1232_ts_read_data(struct st1232_ts_data *ts)\r\n{\r\nstruct st1232_ts_finger *finger = ts->finger;\r\nstruct i2c_client *client = ts->client;\r\nstruct i2c_msg msg[2];\r\nint error;\r\nu8 start_reg;\r\nu8 buf[10];\r\nmsg[0].addr = client->addr;\r\nmsg[0].flags = 0;\r\nmsg[0].len = 1;\r\nmsg[0].buf = &start_reg;\r\nstart_reg = 0x10;\r\nmsg[1].addr = ts->client->addr;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].len = sizeof(buf);\r\nmsg[1].buf = buf;\r\nerror = i2c_transfer(client->adapter, msg, 2);\r\nif (error < 0)\r\nreturn error;\r\nfinger[0].is_valid = buf[2] >> 7;\r\nfinger[1].is_valid = buf[5] >> 7;\r\nif (finger[0].is_valid) {\r\nfinger[0].x = ((buf[2] & 0x0070) << 4) | buf[3];\r\nfinger[0].y = ((buf[2] & 0x0007) << 8) | buf[4];\r\nfinger[0].t = buf[8];\r\n}\r\nif (finger[1].is_valid) {\r\nfinger[1].x = ((buf[5] & 0x0070) << 4) | buf[6];\r\nfinger[1].y = ((buf[5] & 0x0007) << 8) | buf[7];\r\nfinger[1].t = buf[9];\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t st1232_ts_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct st1232_ts_data *ts = dev_id;\r\nstruct st1232_ts_finger *finger = ts->finger;\r\nstruct input_dev *input_dev = ts->input_dev;\r\nint count = 0;\r\nint i, ret;\r\nret = st1232_ts_read_data(ts);\r\nif (ret < 0)\r\ngoto end;\r\nfor (i = 0; i < MAX_FINGERS; i++) {\r\nif (!finger[i].is_valid)\r\ncontinue;\r\ninput_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, finger[i].t);\r\ninput_report_abs(input_dev, ABS_MT_POSITION_X, finger[i].x);\r\ninput_report_abs(input_dev, ABS_MT_POSITION_Y, finger[i].y);\r\ninput_mt_sync(input_dev);\r\ncount++;\r\n}\r\nif (!count) {\r\ninput_mt_sync(input_dev);\r\nif (ts->low_latency_req.dev) {\r\ndev_pm_qos_remove_request(&ts->low_latency_req);\r\nts->low_latency_req.dev = NULL;\r\n}\r\n} else if (!ts->low_latency_req.dev) {\r\ndev_pm_qos_add_ancestor_request(&ts->client->dev,\r\n&ts->low_latency_req,\r\nDEV_PM_QOS_RESUME_LATENCY, 100);\r\n}\r\ninput_sync(input_dev);\r\nend:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void st1232_ts_power(struct st1232_ts_data *ts, bool poweron)\r\n{\r\nif (gpio_is_valid(ts->reset_gpio))\r\ngpio_direction_output(ts->reset_gpio, poweron);\r\n}\r\nstatic int st1232_ts_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct st1232_ts_data *ts;\r\nstruct st1232_pdata *pdata = dev_get_platdata(&client->dev);\r\nstruct input_dev *input_dev;\r\nint error;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\ndev_err(&client->dev, "need I2C_FUNC_I2C\n");\r\nreturn -EIO;\r\n}\r\nif (!client->irq) {\r\ndev_err(&client->dev, "no IRQ?\n");\r\nreturn -EINVAL;\r\n}\r\nts = devm_kzalloc(&client->dev, sizeof(*ts), GFP_KERNEL);\r\nif (!ts)\r\nreturn -ENOMEM;\r\ninput_dev = devm_input_allocate_device(&client->dev);\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\nts->client = client;\r\nts->input_dev = input_dev;\r\nif (pdata)\r\nts->reset_gpio = pdata->reset_gpio;\r\nelse if (client->dev.of_node)\r\nts->reset_gpio = of_get_gpio(client->dev.of_node, 0);\r\nelse\r\nts->reset_gpio = -ENODEV;\r\nif (gpio_is_valid(ts->reset_gpio)) {\r\nerror = devm_gpio_request(&client->dev, ts->reset_gpio, NULL);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"Unable to request GPIO pin %d.\n",\r\nts->reset_gpio);\r\nreturn error;\r\n}\r\n}\r\nst1232_ts_power(ts, true);\r\ninput_dev->name = "st1232-touchscreen";\r\ninput_dev->id.bustype = BUS_I2C;\r\ninput_dev->dev.parent = &client->dev;\r\n__set_bit(EV_SYN, input_dev->evbit);\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(EV_ABS, input_dev->evbit);\r\ninput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, MAX_AREA, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_X, MIN_X, MAX_X, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_Y, MIN_Y, MAX_Y, 0, 0);\r\nerror = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, st1232_ts_irq_handler,\r\nIRQF_ONESHOT,\r\nclient->name, ts);\r\nif (error) {\r\ndev_err(&client->dev, "Failed to register interrupt\n");\r\nreturn error;\r\n}\r\nerror = input_register_device(ts->input_dev);\r\nif (error) {\r\ndev_err(&client->dev, "Unable to register %s input device\n",\r\ninput_dev->name);\r\nreturn error;\r\n}\r\ni2c_set_clientdata(client, ts);\r\ndevice_init_wakeup(&client->dev, 1);\r\nreturn 0;\r\n}\r\nstatic int st1232_ts_remove(struct i2c_client *client)\r\n{\r\nstruct st1232_ts_data *ts = i2c_get_clientdata(client);\r\ndevice_init_wakeup(&client->dev, 0);\r\nst1232_ts_power(ts, false);\r\nreturn 0;\r\n}\r\nstatic int st1232_ts_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct st1232_ts_data *ts = i2c_get_clientdata(client);\r\nif (device_may_wakeup(&client->dev)) {\r\nenable_irq_wake(client->irq);\r\n} else {\r\ndisable_irq(client->irq);\r\nst1232_ts_power(ts, false);\r\n}\r\nreturn 0;\r\n}\r\nstatic int st1232_ts_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct st1232_ts_data *ts = i2c_get_clientdata(client);\r\nif (device_may_wakeup(&client->dev)) {\r\ndisable_irq_wake(client->irq);\r\n} else {\r\nst1232_ts_power(ts, true);\r\nenable_irq(client->irq);\r\n}\r\nreturn 0;\r\n}
