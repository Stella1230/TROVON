static int tda18212_wr_regs(struct tda18212_priv *priv, u8 reg, u8 *val,\r\nint len)\r\n{\r\nint ret;\r\nu8 buf[MAX_XFER_SIZE];\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = priv->cfg->i2c_address,\r\n.flags = 0,\r\n.len = 1 + len,\r\n.buf = buf,\r\n}\r\n};\r\nif (1 + len > sizeof(buf)) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c wr reg=%04x: len=%d is too big!\n",\r\nKBUILD_MODNAME, reg, len);\r\nreturn -EINVAL;\r\n}\r\nbuf[0] = reg;\r\nmemcpy(&buf[1], val, len);\r\nret = i2c_transfer(priv->i2c, msg, 1);\r\nif (ret == 1) {\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->i2c->dev, "%s: i2c wr failed=%d reg=%02x " \\r\n"len=%d\n", KBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int tda18212_rd_regs(struct tda18212_priv *priv, u8 reg, u8 *val,\r\nint len)\r\n{\r\nint ret;\r\nu8 buf[MAX_XFER_SIZE];\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = priv->cfg->i2c_address,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &reg,\r\n}, {\r\n.addr = priv->cfg->i2c_address,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = buf,\r\n}\r\n};\r\nif (len > sizeof(buf)) {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c rd reg=%04x: len=%d is too big!\n",\r\nKBUILD_MODNAME, reg, len);\r\nreturn -EINVAL;\r\n}\r\nret = i2c_transfer(priv->i2c, msg, 2);\r\nif (ret == 2) {\r\nmemcpy(val, buf, len);\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->i2c->dev, "%s: i2c rd failed=%d reg=%02x " \\r\n"len=%d\n", KBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int tda18212_wr_reg(struct tda18212_priv *priv, u8 reg, u8 val)\r\n{\r\nreturn tda18212_wr_regs(priv, reg, &val, 1);\r\n}\r\nstatic int tda18212_rd_reg(struct tda18212_priv *priv, u8 reg, u8 *val)\r\n{\r\nreturn tda18212_rd_regs(priv, reg, val, 1);\r\n}\r\nstatic int tda18212_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct tda18212_priv *priv = fe->tuner_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i;\r\nu32 if_khz;\r\nu8 buf[9];\r\n#define DVBT_6 0\r\n#define DVBT_7 1\r\n#define DVBT_8 2\r\n#define DVBT2_6 3\r\n#define DVBT2_7 4\r\n#define DVBT2_8 5\r\n#define DVBC_6 6\r\n#define DVBC_8 7\r\n#define ATSC_VSB 8\r\n#define ATSC_QAM 9\r\nstatic const u8 bw_params[][3] = {\r\n[DVBT_6] = { 0xb3, 0x20, 0x03 },\r\n[DVBT_7] = { 0xb3, 0x31, 0x01 },\r\n[DVBT_8] = { 0xb3, 0x22, 0x01 },\r\n[DVBT2_6] = { 0xbc, 0x20, 0x03 },\r\n[DVBT2_7] = { 0xbc, 0x72, 0x03 },\r\n[DVBT2_8] = { 0xbc, 0x22, 0x01 },\r\n[DVBC_6] = { 0x92, 0x50, 0x03 },\r\n[DVBC_8] = { 0x92, 0x53, 0x03 },\r\n[ATSC_VSB] = { 0x7d, 0x20, 0x63 },\r\n[ATSC_QAM] = { 0x7d, 0x20, 0x63 },\r\n};\r\ndev_dbg(&priv->i2c->dev,\r\n"%s: delivery_system=%d frequency=%d bandwidth_hz=%d\n",\r\n__func__, c->delivery_system, c->frequency,\r\nc->bandwidth_hz);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nswitch (c->delivery_system) {\r\ncase SYS_ATSC:\r\nif_khz = priv->cfg->if_atsc_vsb;\r\ni = ATSC_VSB;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_B:\r\nif_khz = priv->cfg->if_atsc_qam;\r\ni = ATSC_QAM;\r\nbreak;\r\ncase SYS_DVBT:\r\nswitch (c->bandwidth_hz) {\r\ncase 6000000:\r\nif_khz = priv->cfg->if_dvbt_6;\r\ni = DVBT_6;\r\nbreak;\r\ncase 7000000:\r\nif_khz = priv->cfg->if_dvbt_7;\r\ni = DVBT_7;\r\nbreak;\r\ncase 8000000:\r\nif_khz = priv->cfg->if_dvbt_8;\r\ni = DVBT_8;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nbreak;\r\ncase SYS_DVBT2:\r\nswitch (c->bandwidth_hz) {\r\ncase 6000000:\r\nif_khz = priv->cfg->if_dvbt2_6;\r\ni = DVBT2_6;\r\nbreak;\r\ncase 7000000:\r\nif_khz = priv->cfg->if_dvbt2_7;\r\ni = DVBT2_7;\r\nbreak;\r\ncase 8000000:\r\nif_khz = priv->cfg->if_dvbt2_8;\r\ni = DVBT2_8;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nbreak;\r\ncase SYS_DVBC_ANNEX_A:\r\ncase SYS_DVBC_ANNEX_C:\r\nif_khz = priv->cfg->if_dvbc;\r\ni = DVBC_8;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nret = tda18212_wr_reg(priv, 0x23, bw_params[i][2]);\r\nif (ret)\r\ngoto error;\r\nret = tda18212_wr_reg(priv, 0x06, 0x00);\r\nif (ret)\r\ngoto error;\r\nret = tda18212_wr_reg(priv, 0x0f, bw_params[i][0]);\r\nif (ret)\r\ngoto error;\r\nbuf[0] = 0x02;\r\nbuf[1] = bw_params[i][1];\r\nbuf[2] = 0x03;\r\nbuf[3] = DIV_ROUND_CLOSEST(if_khz, 50);\r\nbuf[4] = ((c->frequency / 1000) >> 16) & 0xff;\r\nbuf[5] = ((c->frequency / 1000) >> 8) & 0xff;\r\nbuf[6] = ((c->frequency / 1000) >> 0) & 0xff;\r\nbuf[7] = 0xc1;\r\nbuf[8] = 0x01;\r\nret = tda18212_wr_regs(priv, 0x12, buf, sizeof(buf));\r\nif (ret)\r\ngoto error;\r\npriv->if_frequency = buf[3] * 50 * 1000;\r\nexit:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn ret;\r\nerror:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\ngoto exit;\r\n}\r\nstatic int tda18212_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct tda18212_priv *priv = fe->tuner_priv;\r\n*frequency = priv->if_frequency;\r\nreturn 0;\r\n}\r\nstatic int tda18212_release(struct dvb_frontend *fe)\r\n{\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *tda18212_attach(struct dvb_frontend *fe,\r\nstruct i2c_adapter *i2c, struct tda18212_config *cfg)\r\n{\r\nstruct tda18212_priv *priv = NULL;\r\nint ret;\r\nu8 val;\r\npriv = kzalloc(sizeof(struct tda18212_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn NULL;\r\npriv->cfg = cfg;\r\npriv->i2c = i2c;\r\nfe->tuner_priv = priv;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = tda18212_rd_reg(priv, 0x00, &val);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nif (!ret)\r\ndev_dbg(&priv->i2c->dev, "%s: chip id=%02x\n", __func__, val);\r\nif (ret || val != 0xc7) {\r\nkfree(priv);\r\nreturn NULL;\r\n}\r\ndev_info(&priv->i2c->dev,\r\n"%s: NXP TDA18212HN successfully identified\n",\r\nKBUILD_MODNAME);\r\nmemcpy(&fe->ops.tuner_ops, &tda18212_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nreturn fe;\r\n}
