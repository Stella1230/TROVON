static int nv3Busy\r\n(\r\nRIVA_HW_INST *chip\r\n)\r\n{\r\nreturn ((NV_RD32(&chip->Rop->FifoFree, 0) < chip->FifoEmptyCount) ||\r\nNV_RD32(&chip->PGRAPH[0x000006B0/4], 0) & 0x01);\r\n}\r\nstatic int nv4Busy\r\n(\r\nRIVA_HW_INST *chip\r\n)\r\n{\r\nreturn ((NV_RD32(&chip->Rop->FifoFree, 0) < chip->FifoEmptyCount) ||\r\nNV_RD32(&chip->PGRAPH[0x00000700/4], 0) & 0x01);\r\n}\r\nstatic int nv10Busy\r\n(\r\nRIVA_HW_INST *chip\r\n)\r\n{\r\nreturn ((NV_RD32(&chip->Rop->FifoFree, 0) < chip->FifoEmptyCount) ||\r\nNV_RD32(&chip->PGRAPH[0x00000700/4], 0) & 0x01);\r\n}\r\nstatic void vgaLockUnlock\r\n(\r\nRIVA_HW_INST *chip,\r\nint Lock\r\n)\r\n{\r\nU008 cr11;\r\nVGA_WR08(chip->PCIO, 0x3D4, 0x11);\r\ncr11 = VGA_RD08(chip->PCIO, 0x3D5);\r\nif(Lock) cr11 |= 0x80;\r\nelse cr11 &= ~0x80;\r\nVGA_WR08(chip->PCIO, 0x3D5, cr11);\r\n}\r\nstatic void nv3LockUnlock\r\n(\r\nRIVA_HW_INST *chip,\r\nint Lock\r\n)\r\n{\r\nVGA_WR08(chip->PVIO, 0x3C4, 0x06);\r\nVGA_WR08(chip->PVIO, 0x3C5, Lock ? 0x99 : 0x57);\r\nvgaLockUnlock(chip, Lock);\r\n}\r\nstatic void nv4LockUnlock\r\n(\r\nRIVA_HW_INST *chip,\r\nint Lock\r\n)\r\n{\r\nVGA_WR08(chip->PCIO, 0x3D4, 0x1F);\r\nVGA_WR08(chip->PCIO, 0x3D5, Lock ? 0x99 : 0x57);\r\nvgaLockUnlock(chip, Lock);\r\n}\r\nstatic int ShowHideCursor\r\n(\r\nRIVA_HW_INST *chip,\r\nint ShowHide\r\n)\r\n{\r\nint cursor;\r\ncursor = chip->CurrentState->cursor1;\r\nchip->CurrentState->cursor1 = (chip->CurrentState->cursor1 & 0xFE) |\r\n(ShowHide & 0x01);\r\nVGA_WR08(chip->PCIO, 0x3D4, 0x31);\r\nVGA_WR08(chip->PCIO, 0x3D5, chip->CurrentState->cursor1);\r\nreturn (cursor & 0x01);\r\n}\r\nstatic int nv3_iterate(nv3_fifo_info *res_info, nv3_sim_state * state, nv3_arb_info *ainfo)\r\n{\r\nint iter = 0;\r\nint tmp;\r\nint vfsize, mfsize, gfsize;\r\nint mburst_size = 32;\r\nint mmisses, gmisses, vmisses;\r\nint misses;\r\nint vlwm, glwm, mlwm;\r\nint last, next, cur;\r\nint max_gfsize ;\r\nlong ns;\r\nvlwm = 0;\r\nglwm = 0;\r\nmlwm = 0;\r\nvfsize = 0;\r\ngfsize = 0;\r\ncur = ainfo->cur;\r\nmmisses = 2;\r\ngmisses = 2;\r\nvmisses = 2;\r\nif (ainfo->gburst_size == 128) max_gfsize = GFIFO_SIZE_128;\r\nelse max_gfsize = GFIFO_SIZE;\r\nmax_gfsize = GFIFO_SIZE;\r\nwhile (1)\r\n{\r\nif (ainfo->vid_en)\r\n{\r\nif (ainfo->wcvocc > ainfo->vocc) ainfo->wcvocc = ainfo->vocc;\r\nif (ainfo->wcvlwm > vlwm) ainfo->wcvlwm = vlwm ;\r\nns = 1000000 * ainfo->vburst_size/(state->memory_width/8)/state->mclk_khz;\r\nvfsize = ns * ainfo->vdrain_rate / 1000000;\r\nvfsize = ainfo->wcvlwm - ainfo->vburst_size + vfsize;\r\n}\r\nif (state->enable_mp)\r\n{\r\nif (ainfo->wcmocc > ainfo->mocc) ainfo->wcmocc = ainfo->mocc;\r\n}\r\nif (ainfo->gr_en)\r\n{\r\nif (ainfo->wcglwm > glwm) ainfo->wcglwm = glwm ;\r\nif (ainfo->wcgocc > ainfo->gocc) ainfo->wcgocc = ainfo->gocc;\r\nns = 1000000 * (ainfo->gburst_size/(state->memory_width/8))/state->mclk_khz;\r\ngfsize = (ns * (long) ainfo->gdrain_rate)/1000000;\r\ngfsize = ainfo->wcglwm - ainfo->gburst_size + gfsize;\r\n}\r\nmfsize = 0;\r\nif (!state->gr_during_vid && ainfo->vid_en)\r\nif (ainfo->vid_en && (ainfo->vocc < 0) && !ainfo->vid_only_once)\r\nnext = VIDEO;\r\nelse if (ainfo->mocc < 0)\r\nnext = MPORT;\r\nelse if (ainfo->gocc< ainfo->by_gfacc)\r\nnext = GRAPHICS;\r\nelse return (0);\r\nelse switch (ainfo->priority)\r\n{\r\ncase VIDEO:\r\nif (ainfo->vid_en && ainfo->vocc<0 && !ainfo->vid_only_once)\r\nnext = VIDEO;\r\nelse if (ainfo->gr_en && ainfo->gocc<0 && !ainfo->gr_only_once)\r\nnext = GRAPHICS;\r\nelse if (ainfo->mocc<0)\r\nnext = MPORT;\r\nelse return (0);\r\nbreak;\r\ncase GRAPHICS:\r\nif (ainfo->gr_en && ainfo->gocc<0 && !ainfo->gr_only_once)\r\nnext = GRAPHICS;\r\nelse if (ainfo->vid_en && ainfo->vocc<0 && !ainfo->vid_only_once)\r\nnext = VIDEO;\r\nelse if (ainfo->mocc<0)\r\nnext = MPORT;\r\nelse return (0);\r\nbreak;\r\ndefault:\r\nif (ainfo->mocc<0)\r\nnext = MPORT;\r\nelse if (ainfo->gr_en && ainfo->gocc<0 && !ainfo->gr_only_once)\r\nnext = GRAPHICS;\r\nelse if (ainfo->vid_en && ainfo->vocc<0 && !ainfo->vid_only_once)\r\nnext = VIDEO;\r\nelse return (0);\r\nbreak;\r\n}\r\nlast = cur;\r\ncur = next;\r\niter++;\r\nswitch (cur)\r\n{\r\ncase VIDEO:\r\nif (last==cur) misses = 0;\r\nelse if (ainfo->first_vacc) misses = vmisses;\r\nelse misses = 1;\r\nainfo->first_vacc = 0;\r\nif (last!=cur)\r\n{\r\nns = 1000000 * (vmisses*state->mem_page_miss + state->mem_latency)/state->mclk_khz;\r\nvlwm = ns * ainfo->vdrain_rate/ 1000000;\r\nvlwm = ainfo->vocc - vlwm;\r\n}\r\nns = 1000000*(misses*state->mem_page_miss + ainfo->vburst_size)/(state->memory_width/8)/state->mclk_khz;\r\nainfo->vocc = ainfo->vocc + ainfo->vburst_size - ns*ainfo->vdrain_rate/1000000;\r\nainfo->gocc = ainfo->gocc - ns*ainfo->gdrain_rate/1000000;\r\nainfo->mocc = ainfo->mocc - ns*ainfo->mdrain_rate/1000000;\r\nbreak;\r\ncase GRAPHICS:\r\nif (last==cur) misses = 0;\r\nelse if (ainfo->first_gacc) misses = gmisses;\r\nelse misses = 1;\r\nainfo->first_gacc = 0;\r\nif (last!=cur)\r\n{\r\nns = 1000000*(gmisses*state->mem_page_miss + state->mem_latency)/state->mclk_khz ;\r\nglwm = ns * ainfo->gdrain_rate/1000000;\r\nglwm = ainfo->gocc - glwm;\r\n}\r\nns = 1000000*(misses*state->mem_page_miss + ainfo->gburst_size/(state->memory_width/8))/state->mclk_khz;\r\nainfo->vocc = ainfo->vocc + 0 - ns*ainfo->vdrain_rate/1000000;\r\nainfo->gocc = ainfo->gocc + ainfo->gburst_size - ns*ainfo->gdrain_rate/1000000;\r\nainfo->mocc = ainfo->mocc + 0 - ns*ainfo->mdrain_rate/1000000;\r\nbreak;\r\ndefault:\r\nif (last==cur) misses = 0;\r\nelse if (ainfo->first_macc) misses = mmisses;\r\nelse misses = 1;\r\nainfo->first_macc = 0;\r\nns = 1000000*(misses*state->mem_page_miss + mburst_size/(state->memory_width/8))/state->mclk_khz;\r\nainfo->vocc = ainfo->vocc + 0 - ns*ainfo->vdrain_rate/1000000;\r\nainfo->gocc = ainfo->gocc + 0 - ns*ainfo->gdrain_rate/1000000;\r\nainfo->mocc = ainfo->mocc + mburst_size - ns*ainfo->mdrain_rate/1000000;\r\nbreak;\r\n}\r\nif (iter>100)\r\n{\r\nainfo->converged = 0;\r\nreturn (1);\r\n}\r\nns = 1000000*ainfo->gburst_size/(state->memory_width/8)/state->mclk_khz;\r\ntmp = ns * ainfo->gdrain_rate/1000000;\r\nif (abs(ainfo->gburst_size) + ((abs(ainfo->wcglwm) + 16 ) & ~0x7) - tmp > max_gfsize)\r\n{\r\nainfo->converged = 0;\r\nreturn (1);\r\n}\r\nns = 1000000*ainfo->vburst_size/(state->memory_width/8)/state->mclk_khz;\r\ntmp = ns * ainfo->vdrain_rate/1000000;\r\nif (abs(ainfo->vburst_size) + (abs(ainfo->wcvlwm + 32) & ~0xf) - tmp> VFIFO_SIZE)\r\n{\r\nainfo->converged = 0;\r\nreturn (1);\r\n}\r\nif (abs(ainfo->gocc) > max_gfsize)\r\n{\r\nainfo->converged = 0;\r\nreturn (1);\r\n}\r\nif (abs(ainfo->vocc) > VFIFO_SIZE)\r\n{\r\nainfo->converged = 0;\r\nreturn (1);\r\n}\r\nif (abs(ainfo->mocc) > MFIFO_SIZE)\r\n{\r\nainfo->converged = 0;\r\nreturn (1);\r\n}\r\nif (abs(vfsize) > VFIFO_SIZE)\r\n{\r\nainfo->converged = 0;\r\nreturn (1);\r\n}\r\nif (abs(gfsize) > max_gfsize)\r\n{\r\nainfo->converged = 0;\r\nreturn (1);\r\n}\r\nif (abs(mfsize) > MFIFO_SIZE)\r\n{\r\nainfo->converged = 0;\r\nreturn (1);\r\n}\r\n}\r\n}\r\nstatic char nv3_arb(nv3_fifo_info * res_info, nv3_sim_state * state, nv3_arb_info *ainfo)\r\n{\r\nlong ens, vns, mns, gns;\r\nint mmisses, gmisses, vmisses, eburst_size, mburst_size;\r\nint refresh_cycle;\r\nrefresh_cycle = 0;\r\nrefresh_cycle = 2*(state->mclk_khz/state->pclk_khz) + 5;\r\nmmisses = 2;\r\nif (state->mem_aligned) gmisses = 2;\r\nelse gmisses = 3;\r\nvmisses = 2;\r\neburst_size = state->memory_width * 1;\r\nmburst_size = 32;\r\ngns = 1000000 * (gmisses*state->mem_page_miss + state->mem_latency)/state->mclk_khz;\r\nainfo->by_gfacc = gns*ainfo->gdrain_rate/1000000;\r\nainfo->wcmocc = 0;\r\nainfo->wcgocc = 0;\r\nainfo->wcvocc = 0;\r\nainfo->wcvlwm = 0;\r\nainfo->wcglwm = 0;\r\nainfo->engine_en = 1;\r\nainfo->converged = 1;\r\nif (ainfo->engine_en)\r\n{\r\nens = 1000000*(state->mem_page_miss + eburst_size/(state->memory_width/8) +refresh_cycle)/state->mclk_khz;\r\nainfo->mocc = state->enable_mp ? 0-ens*ainfo->mdrain_rate/1000000 : 0;\r\nainfo->vocc = ainfo->vid_en ? 0-ens*ainfo->vdrain_rate/1000000 : 0;\r\nainfo->gocc = ainfo->gr_en ? 0-ens*ainfo->gdrain_rate/1000000 : 0;\r\nainfo->cur = ENGINE;\r\nainfo->first_vacc = 1;\r\nainfo->first_gacc = 1;\r\nainfo->first_macc = 1;\r\nnv3_iterate(res_info, state,ainfo);\r\n}\r\nif (state->enable_mp)\r\n{\r\nmns = 1000000 * (mmisses*state->mem_page_miss + mburst_size/(state->memory_width/8) + refresh_cycle)/state->mclk_khz;\r\nainfo->mocc = state->enable_mp ? 0 : mburst_size - mns*ainfo->mdrain_rate/1000000;\r\nainfo->vocc = ainfo->vid_en ? 0 : 0- mns*ainfo->vdrain_rate/1000000;\r\nainfo->gocc = ainfo->gr_en ? 0: 0- mns*ainfo->gdrain_rate/1000000;\r\nainfo->cur = MPORT;\r\nainfo->first_vacc = 1;\r\nainfo->first_gacc = 1;\r\nainfo->first_macc = 0;\r\nnv3_iterate(res_info, state,ainfo);\r\n}\r\nif (ainfo->gr_en)\r\n{\r\nainfo->first_vacc = 1;\r\nainfo->first_gacc = 0;\r\nainfo->first_macc = 1;\r\ngns = 1000000*(gmisses*state->mem_page_miss + ainfo->gburst_size/(state->memory_width/8) + refresh_cycle)/state->mclk_khz;\r\nainfo->gocc = ainfo->gburst_size - gns*ainfo->gdrain_rate/1000000;\r\nainfo->vocc = ainfo->vid_en? 0-gns*ainfo->vdrain_rate/1000000 : 0;\r\nainfo->mocc = state->enable_mp ? 0-gns*ainfo->mdrain_rate/1000000: 0;\r\nainfo->cur = GRAPHICS;\r\nnv3_iterate(res_info, state,ainfo);\r\n}\r\nif (ainfo->vid_en)\r\n{\r\nainfo->first_vacc = 0;\r\nainfo->first_gacc = 1;\r\nainfo->first_macc = 1;\r\nvns = 1000000*(vmisses*state->mem_page_miss + ainfo->vburst_size/(state->memory_width/8) + refresh_cycle)/state->mclk_khz;\r\nainfo->vocc = ainfo->vburst_size - vns*ainfo->vdrain_rate/1000000;\r\nainfo->gocc = ainfo->gr_en? (0-vns*ainfo->gdrain_rate/1000000) : 0;\r\nainfo->mocc = state->enable_mp? 0-vns*ainfo->mdrain_rate/1000000 :0 ;\r\nainfo->cur = VIDEO;\r\nnv3_iterate(res_info, state, ainfo);\r\n}\r\nif (ainfo->converged)\r\n{\r\nres_info->graphics_lwm = (int)abs(ainfo->wcglwm) + 16;\r\nres_info->video_lwm = (int)abs(ainfo->wcvlwm) + 32;\r\nres_info->graphics_burst_size = ainfo->gburst_size;\r\nres_info->video_burst_size = ainfo->vburst_size;\r\nres_info->graphics_hi_priority = (ainfo->priority == GRAPHICS);\r\nres_info->media_hi_priority = (ainfo->priority == MPORT);\r\nif (res_info->video_lwm > 160)\r\n{\r\nres_info->graphics_lwm = 256;\r\nres_info->video_lwm = 128;\r\nres_info->graphics_burst_size = 64;\r\nres_info->video_burst_size = 64;\r\nres_info->graphics_hi_priority = 0;\r\nres_info->media_hi_priority = 0;\r\nainfo->converged = 0;\r\nreturn (0);\r\n}\r\nif (res_info->video_lwm > 128)\r\n{\r\nres_info->video_lwm = 128;\r\n}\r\nreturn (1);\r\n}\r\nelse\r\n{\r\nres_info->graphics_lwm = 256;\r\nres_info->video_lwm = 128;\r\nres_info->graphics_burst_size = 64;\r\nres_info->video_burst_size = 64;\r\nres_info->graphics_hi_priority = 0;\r\nres_info->media_hi_priority = 0;\r\nreturn (0);\r\n}\r\n}\r\nstatic char nv3_get_param(nv3_fifo_info *res_info, nv3_sim_state * state, nv3_arb_info *ainfo)\r\n{\r\nint done, g,v, p;\r\ndone = 0;\r\nfor (p=0; p < 2; p++)\r\n{\r\nfor (g=128 ; g > 32; g= g>> 1)\r\n{\r\nfor (v=128; v >=32; v = v>> 1)\r\n{\r\nainfo->priority = p;\r\nainfo->gburst_size = g;\r\nainfo->vburst_size = v;\r\ndone = nv3_arb(res_info, state,ainfo);\r\nif (done && (g==128))\r\nif ((res_info->graphics_lwm + g) > 256)\r\ndone = 0;\r\nif (done)\r\ngoto Done;\r\n}\r\n}\r\n}\r\nDone:\r\nreturn done;\r\n}\r\nstatic void nv3CalcArbitration\r\n(\r\nnv3_fifo_info * res_info,\r\nnv3_sim_state * state\r\n)\r\n{\r\nnv3_fifo_info save_info;\r\nnv3_arb_info ainfo;\r\nchar res_gr, res_vid;\r\nainfo.gr_en = 1;\r\nainfo.vid_en = state->enable_video;\r\nainfo.vid_only_once = 0;\r\nainfo.gr_only_once = 0;\r\nainfo.gdrain_rate = (int) state->pclk_khz * (state->pix_bpp/8);\r\nainfo.vdrain_rate = (int) state->pclk_khz * 2;\r\nif (state->video_scale != 0)\r\nainfo.vdrain_rate = ainfo.vdrain_rate/state->video_scale;\r\nainfo.mdrain_rate = 33000;\r\nres_info->rtl_values = 0;\r\nif (!state->gr_during_vid && state->enable_video)\r\n{\r\nainfo.gr_only_once = 1;\r\nainfo.gr_en = 1;\r\nainfo.gdrain_rate = 0;\r\nres_vid = nv3_get_param(res_info, state, &ainfo);\r\nres_vid = ainfo.converged;\r\nsave_info.video_lwm = res_info->video_lwm;\r\nsave_info.video_burst_size = res_info->video_burst_size;\r\nainfo.vid_en = 1;\r\nainfo.vid_only_once = 1;\r\nainfo.gr_en = 1;\r\nainfo.gdrain_rate = (int) state->pclk_khz * (state->pix_bpp/8);\r\nainfo.vdrain_rate = 0;\r\nres_gr = nv3_get_param(res_info, state, &ainfo);\r\nres_gr = ainfo.converged;\r\nres_info->video_lwm = save_info.video_lwm;\r\nres_info->video_burst_size = save_info.video_burst_size;\r\nres_info->valid = res_gr & res_vid;\r\n}\r\nelse\r\n{\r\nif (!ainfo.gr_en) ainfo.gdrain_rate = 0;\r\nif (!ainfo.vid_en) ainfo.vdrain_rate = 0;\r\nres_gr = nv3_get_param(res_info, state, &ainfo);\r\nres_info->valid = ainfo.converged;\r\n}\r\n}\r\nstatic void nv3UpdateArbitrationSettings\r\n(\r\nunsigned VClk,\r\nunsigned pixelDepth,\r\nunsigned *burst,\r\nunsigned *lwm,\r\nRIVA_HW_INST *chip\r\n)\r\n{\r\nnv3_fifo_info fifo_data;\r\nnv3_sim_state sim_data;\r\nunsigned int M, N, P, pll, MClk;\r\npll = NV_RD32(&chip->PRAMDAC0[0x00000504/4], 0);\r\nM = (pll >> 0) & 0xFF; N = (pll >> 8) & 0xFF; P = (pll >> 16) & 0x0F;\r\nMClk = (N * chip->CrystalFreqKHz / M) >> P;\r\nsim_data.pix_bpp = (char)pixelDepth;\r\nsim_data.enable_video = 0;\r\nsim_data.enable_mp = 0;\r\nsim_data.video_scale = 1;\r\nsim_data.memory_width = (NV_RD32(&chip->PEXTDEV[0x00000000/4], 0) & 0x10) ?\r\n128 : 64;\r\nsim_data.memory_width = 128;\r\nsim_data.mem_latency = 9;\r\nsim_data.mem_aligned = 1;\r\nsim_data.mem_page_miss = 11;\r\nsim_data.gr_during_vid = 0;\r\nsim_data.pclk_khz = VClk;\r\nsim_data.mclk_khz = MClk;\r\nnv3CalcArbitration(&fifo_data, &sim_data);\r\nif (fifo_data.valid)\r\n{\r\nint b = fifo_data.graphics_burst_size >> 4;\r\n*burst = 0;\r\nwhile (b >>= 1)\r\n(*burst)++;\r\n*lwm = fifo_data.graphics_lwm >> 3;\r\n}\r\nelse\r\n{\r\n*lwm = 0x24;\r\n*burst = 0x2;\r\n}\r\n}\r\nstatic void nv4CalcArbitration\r\n(\r\nnv4_fifo_info *fifo,\r\nnv4_sim_state *arb\r\n)\r\n{\r\nint data, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;\r\nint nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;\r\nint found, mclk_extra, mclk_loop, cbs, m1, p1;\r\nint mclk_freq, pclk_freq, nvclk_freq, mp_enable;\r\nint us_m, us_n, us_p, video_drain_rate, crtc_drain_rate;\r\nint vpm_us, us_video, vlwm, video_fill_us, cpm_us, us_crt,clwm;\r\nint craw, vraw;\r\nfifo->valid = 1;\r\npclk_freq = arb->pclk_khz;\r\nmclk_freq = arb->mclk_khz;\r\nnvclk_freq = arb->nvclk_khz;\r\npagemiss = arb->mem_page_miss;\r\ncas = arb->mem_latency;\r\nwidth = arb->memory_width >> 6;\r\nvideo_enable = arb->enable_video;\r\ncolor_key_enable = arb->gr_during_vid;\r\nbpp = arb->pix_bpp;\r\nalign = arb->mem_aligned;\r\nmp_enable = arb->enable_mp;\r\nclwm = 0;\r\nvlwm = 0;\r\ncbs = 128;\r\npclks = 2;\r\nnvclks = 2;\r\nnvclks += 2;\r\nnvclks += 1;\r\nmclks = 5;\r\nmclks += 3;\r\nmclks += 1;\r\nmclks += cas;\r\nmclks += 1;\r\nmclks += 1;\r\nmclks += 1;\r\nmclks += 1;\r\nmclk_extra = 3;\r\nnvclks += 2;\r\nnvclks += 1;\r\nnvclks += 1;\r\nnvclks += 1;\r\nif (mp_enable)\r\nmclks+=4;\r\nnvclks += 0;\r\npclks += 0;\r\nfound = 0;\r\nvbs = 0;\r\nwhile (found != 1)\r\n{\r\nfifo->valid = 1;\r\nfound = 1;\r\nmclk_loop = mclks+mclk_extra;\r\nus_m = mclk_loop *1000*1000 / mclk_freq;\r\nus_n = nvclks*1000*1000 / nvclk_freq;\r\nus_p = nvclks*1000*1000 / pclk_freq;\r\nif (video_enable)\r\n{\r\nvideo_drain_rate = pclk_freq * 2;\r\ncrtc_drain_rate = pclk_freq * bpp/8;\r\nvpagemiss = 2;\r\nvpagemiss += 1;\r\ncrtpagemiss = 2;\r\nvpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;\r\nif (nvclk_freq * 2 > mclk_freq * width)\r\nvideo_fill_us = cbs*1000*1000 / 16 / nvclk_freq ;\r\nelse\r\nvideo_fill_us = cbs*1000*1000 / (8 * width) / mclk_freq;\r\nus_video = vpm_us + us_m + us_n + us_p + video_fill_us;\r\nvlwm = us_video * video_drain_rate/(1000*1000);\r\nvlwm++;\r\nvbs = 128;\r\nif (vlwm > 128) vbs = 64;\r\nif (vlwm > (256-64)) vbs = 32;\r\nif (nvclk_freq * 2 > mclk_freq * width)\r\nvideo_fill_us = vbs *1000*1000/ 16 / nvclk_freq ;\r\nelse\r\nvideo_fill_us = vbs*1000*1000 / (8 * width) / mclk_freq;\r\ncpm_us = crtpagemiss * pagemiss *1000*1000/ mclk_freq;\r\nus_crt =\r\nus_video\r\n+video_fill_us\r\n+cpm_us\r\n+us_m + us_n +us_p\r\n;\r\nclwm = us_crt * crtc_drain_rate/(1000*1000);\r\nclwm++;\r\n}\r\nelse\r\n{\r\ncrtc_drain_rate = pclk_freq * bpp/8;\r\ncrtpagemiss = 2;\r\ncrtpagemiss += 1;\r\ncpm_us = crtpagemiss * pagemiss *1000*1000/ mclk_freq;\r\nus_crt = cpm_us + us_m + us_n + us_p ;\r\nclwm = us_crt * crtc_drain_rate/(1000*1000);\r\nclwm++;\r\n}\r\nm1 = clwm + cbs - 512;\r\np1 = m1 * pclk_freq / mclk_freq;\r\np1 = p1 * bpp / 8;\r\nif ((p1 < m1) && (m1 > 0))\r\n{\r\nfifo->valid = 0;\r\nfound = 0;\r\nif (mclk_extra ==0) found = 1;\r\nmclk_extra--;\r\n}\r\nelse if (video_enable)\r\n{\r\nif ((clwm > 511) || (vlwm > 255))\r\n{\r\nfifo->valid = 0;\r\nfound = 0;\r\nif (mclk_extra ==0) found = 1;\r\nmclk_extra--;\r\n}\r\n}\r\nelse\r\n{\r\nif (clwm > 519)\r\n{\r\nfifo->valid = 0;\r\nfound = 0;\r\nif (mclk_extra ==0) found = 1;\r\nmclk_extra--;\r\n}\r\n}\r\ncraw = clwm;\r\nvraw = vlwm;\r\nif (clwm < 384) clwm = 384;\r\nif (vlwm < 128) vlwm = 128;\r\ndata = (int)(clwm);\r\nfifo->graphics_lwm = data;\r\nfifo->graphics_burst_size = 128;\r\ndata = (int)((vlwm+15));\r\nfifo->video_lwm = data;\r\nfifo->video_burst_size = vbs;\r\n}\r\n}\r\nstatic void nv4UpdateArbitrationSettings\r\n(\r\nunsigned VClk,\r\nunsigned pixelDepth,\r\nunsigned *burst,\r\nunsigned *lwm,\r\nRIVA_HW_INST *chip\r\n)\r\n{\r\nnv4_fifo_info fifo_data;\r\nnv4_sim_state sim_data;\r\nunsigned int M, N, P, pll, MClk, NVClk, cfg1;\r\npll = NV_RD32(&chip->PRAMDAC0[0x00000504/4], 0);\r\nM = (pll >> 0) & 0xFF; N = (pll >> 8) & 0xFF; P = (pll >> 16) & 0x0F;\r\nMClk = (N * chip->CrystalFreqKHz / M) >> P;\r\npll = NV_RD32(&chip->PRAMDAC0[0x00000500/4], 0);\r\nM = (pll >> 0) & 0xFF; N = (pll >> 8) & 0xFF; P = (pll >> 16) & 0x0F;\r\nNVClk = (N * chip->CrystalFreqKHz / M) >> P;\r\ncfg1 = NV_RD32(&chip->PFB[0x00000204/4], 0);\r\nsim_data.pix_bpp = (char)pixelDepth;\r\nsim_data.enable_video = 0;\r\nsim_data.enable_mp = 0;\r\nsim_data.memory_width = (NV_RD32(&chip->PEXTDEV[0x00000000/4], 0) & 0x10) ?\r\n128 : 64;\r\nsim_data.mem_latency = (char)cfg1 & 0x0F;\r\nsim_data.mem_aligned = 1;\r\nsim_data.mem_page_miss = (char)(((cfg1 >> 4) &0x0F) + ((cfg1 >> 31) & 0x01));\r\nsim_data.gr_during_vid = 0;\r\nsim_data.pclk_khz = VClk;\r\nsim_data.mclk_khz = MClk;\r\nsim_data.nvclk_khz = NVClk;\r\nnv4CalcArbitration(&fifo_data, &sim_data);\r\nif (fifo_data.valid)\r\n{\r\nint b = fifo_data.graphics_burst_size >> 4;\r\n*burst = 0;\r\nwhile (b >>= 1)\r\n(*burst)++;\r\n*lwm = fifo_data.graphics_lwm >> 3;\r\n}\r\n}\r\nstatic void nv10CalcArbitration\r\n(\r\nnv10_fifo_info *fifo,\r\nnv10_sim_state *arb\r\n)\r\n{\r\nint data, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;\r\nint nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;\r\nint nvclk_fill, us_extra;\r\nint found, mclk_extra, mclk_loop, cbs, m1;\r\nint mclk_freq, pclk_freq, nvclk_freq, mp_enable;\r\nint us_m, us_m_min, us_n, us_p, video_drain_rate, crtc_drain_rate;\r\nint vus_m, vus_n, vus_p;\r\nint vpm_us, us_video, vlwm, cpm_us, us_crt,clwm;\r\nint clwm_rnd_down;\r\nint craw, m2us, us_pipe, us_pipe_min, vus_pipe, p1clk, p2;\r\nint pclks_2_top_fifo, min_mclk_extra;\r\nint us_min_mclk_extra;\r\nfifo->valid = 1;\r\npclk_freq = arb->pclk_khz;\r\nmclk_freq = arb->mclk_khz;\r\nnvclk_freq = arb->nvclk_khz;\r\npagemiss = arb->mem_page_miss;\r\ncas = arb->mem_latency;\r\nwidth = arb->memory_width/64;\r\nvideo_enable = arb->enable_video;\r\ncolor_key_enable = arb->gr_during_vid;\r\nbpp = arb->pix_bpp;\r\nalign = arb->mem_aligned;\r\nmp_enable = arb->enable_mp;\r\nclwm = 0;\r\nvlwm = 1024;\r\ncbs = 512;\r\nvbs = 512;\r\npclks = 4;\r\nnvclks = 3;\r\nnvclks += 2;\r\nmclks = 1;\r\nmclks += 1;\r\nmclks += 5;\r\nmclks += 2;\r\nmclks += 2;\r\nmclks += 7;\r\nif (arb->memory_type == 0)\r\nif (arb->memory_width == 64)\r\nmclks += 4;\r\nelse\r\nmclks += 2;\r\nelse\r\nif (arb->memory_width == 64)\r\nmclks += 2;\r\nelse\r\nmclks += 1;\r\nif ((!video_enable) && (arb->memory_width == 128))\r\n{\r\nmclk_extra = (bpp == 32) ? 31 : 42;\r\nmin_mclk_extra = 17;\r\n}\r\nelse\r\n{\r\nmclk_extra = (bpp == 32) ? 8 : 4;\r\nmin_mclk_extra = 18;\r\n}\r\nnvclks += 1;\r\nnvclks += 1;\r\nnvclks += 1;\r\nnvclks += 1;\r\nif(mp_enable)\r\nmclks+=4;\r\nnvclks += 0;\r\npclks += 0;\r\nfound = 0;\r\nwhile(found != 1) {\r\nfifo->valid = 1;\r\nfound = 1;\r\nmclk_loop = mclks+mclk_extra;\r\nus_m = mclk_loop *1000*1000 / mclk_freq;\r\nus_m_min = mclks * 1000*1000 / mclk_freq;\r\nus_min_mclk_extra = min_mclk_extra *1000*1000 / mclk_freq;\r\nus_n = nvclks*1000*1000 / nvclk_freq;\r\nus_p = pclks*1000*1000 / pclk_freq;\r\nus_pipe = us_m + us_n + us_p;\r\nus_pipe_min = us_m_min + us_n + us_p;\r\nus_extra = 0;\r\nvus_m = mclk_loop *1000*1000 / mclk_freq;\r\nvus_n = (4)*1000*1000 / nvclk_freq;\r\nvus_p = 0*1000*1000 / pclk_freq;\r\nvus_pipe = vus_m + vus_n + vus_p;\r\nif(video_enable) {\r\nvideo_drain_rate = pclk_freq * 4;\r\ncrtc_drain_rate = pclk_freq * bpp/8;\r\nvpagemiss = 1;\r\nvpagemiss += 1;\r\ncrtpagemiss = 2;\r\nif(mp_enable)\r\ncrtpagemiss += 1;\r\nvpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;\r\nus_video = vpm_us + vus_m;\r\ncpm_us = crtpagemiss * pagemiss *1000*1000/ mclk_freq;\r\nus_crt =\r\nus_video\r\n+cpm_us\r\n+us_m + us_n +us_p\r\n;\r\nclwm = us_crt * crtc_drain_rate/(1000*1000);\r\nclwm++;\r\n} else {\r\ncrtc_drain_rate = pclk_freq * bpp/8;\r\ncrtpagemiss = 1;\r\ncrtpagemiss += 1;\r\nif(mp_enable)\r\ncrtpagemiss += 1;\r\ncpm_us = crtpagemiss * pagemiss *1000*1000/ mclk_freq;\r\nus_crt = cpm_us + us_m + us_n + us_p ;\r\nclwm = us_crt * crtc_drain_rate/(1000*1000);\r\nclwm++;\r\nif(width == 1){\r\nnvclk_fill = nvclk_freq * 8;\r\nif(crtc_drain_rate * 100 >= nvclk_fill * 102)\r\nclwm = 0xfff;\r\nelse if(crtc_drain_rate * 100 >= nvclk_fill * 98) {\r\nclwm = 1024;\r\ncbs = 512;\r\nus_extra = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;\r\n}\r\n}\r\n}\r\nclwm_rnd_down = ((int)clwm/8)*8;\r\nif (clwm_rnd_down < clwm)\r\nclwm += 8;\r\nm1 = clwm + cbs - 1024;\r\nm2us = us_pipe_min + us_min_mclk_extra;\r\npclks_2_top_fifo = (1024-clwm)/(8*width);\r\np1clk = m2us * pclk_freq/(1000*1000);\r\np2 = p1clk * bpp / 8;\r\nif((p2 < m1) && (m1 > 0)) {\r\nfifo->valid = 0;\r\nfound = 0;\r\nif(min_mclk_extra == 0) {\r\nif(cbs <= 32) {\r\nfound = 1;\r\n} else {\r\ncbs = cbs/2;\r\n}\r\n} else {\r\nmin_mclk_extra--;\r\n}\r\n} else {\r\nif (clwm > 1023){\r\nfifo->valid = 0;\r\nfound = 0;\r\nif(min_mclk_extra == 0)\r\nfound = 1;\r\nelse\r\nmin_mclk_extra--;\r\n}\r\n}\r\ncraw = clwm;\r\nif(clwm < (1024-cbs+8)) clwm = 1024-cbs+8;\r\ndata = (int)(clwm);\r\nfifo->graphics_lwm = data; fifo->graphics_burst_size = cbs;\r\nfifo->video_lwm = 1024; fifo->video_burst_size = 512;\r\n}\r\n}\r\nstatic void nv10UpdateArbitrationSettings\r\n(\r\nunsigned VClk,\r\nunsigned pixelDepth,\r\nunsigned *burst,\r\nunsigned *lwm,\r\nRIVA_HW_INST *chip\r\n)\r\n{\r\nnv10_fifo_info fifo_data;\r\nnv10_sim_state sim_data;\r\nunsigned int M, N, P, pll, MClk, NVClk, cfg1;\r\npll = NV_RD32(&chip->PRAMDAC0[0x00000504/4], 0);\r\nM = (pll >> 0) & 0xFF; N = (pll >> 8) & 0xFF; P = (pll >> 16) & 0x0F;\r\nMClk = (N * chip->CrystalFreqKHz / M) >> P;\r\npll = NV_RD32(&chip->PRAMDAC0[0x00000500/4], 0);\r\nM = (pll >> 0) & 0xFF; N = (pll >> 8) & 0xFF; P = (pll >> 16) & 0x0F;\r\nNVClk = (N * chip->CrystalFreqKHz / M) >> P;\r\ncfg1 = NV_RD32(&chip->PFB[0x00000204/4], 0);\r\nsim_data.pix_bpp = (char)pixelDepth;\r\nsim_data.enable_video = 0;\r\nsim_data.enable_mp = 0;\r\nsim_data.memory_type = (NV_RD32(&chip->PFB[0x00000200/4], 0) & 0x01) ?\r\n1 : 0;\r\nsim_data.memory_width = (NV_RD32(&chip->PEXTDEV[0x00000000/4], 0) & 0x10) ?\r\n128 : 64;\r\nsim_data.mem_latency = (char)cfg1 & 0x0F;\r\nsim_data.mem_aligned = 1;\r\nsim_data.mem_page_miss = (char)(((cfg1 >> 4) &0x0F) + ((cfg1 >> 31) & 0x01));\r\nsim_data.gr_during_vid = 0;\r\nsim_data.pclk_khz = VClk;\r\nsim_data.mclk_khz = MClk;\r\nsim_data.nvclk_khz = NVClk;\r\nnv10CalcArbitration(&fifo_data, &sim_data);\r\nif (fifo_data.valid)\r\n{\r\nint b = fifo_data.graphics_burst_size >> 4;\r\n*burst = 0;\r\nwhile (b >>= 1)\r\n(*burst)++;\r\n*lwm = fifo_data.graphics_lwm >> 3;\r\n}\r\n}\r\nstatic void nForceUpdateArbitrationSettings\r\n(\r\nunsigned VClk,\r\nunsigned pixelDepth,\r\nunsigned *burst,\r\nunsigned *lwm,\r\nRIVA_HW_INST *chip\r\n)\r\n{\r\nnv10_fifo_info fifo_data;\r\nnv10_sim_state sim_data;\r\nunsigned int M, N, P, pll, MClk, NVClk;\r\nunsigned int uMClkPostDiv;\r\nstruct pci_dev *dev;\r\ndev = pci_get_bus_and_slot(0, 3);\r\npci_read_config_dword(dev, 0x6C, &uMClkPostDiv);\r\npci_dev_put(dev);\r\nuMClkPostDiv = (uMClkPostDiv >> 8) & 0xf;\r\nif(!uMClkPostDiv) uMClkPostDiv = 4;\r\nMClk = 400000 / uMClkPostDiv;\r\npll = NV_RD32(&chip->PRAMDAC0[0x00000500/4], 0);\r\nM = (pll >> 0) & 0xFF; N = (pll >> 8) & 0xFF; P = (pll >> 16) & 0x0F;\r\nNVClk = (N * chip->CrystalFreqKHz / M) >> P;\r\nsim_data.pix_bpp = (char)pixelDepth;\r\nsim_data.enable_video = 0;\r\nsim_data.enable_mp = 0;\r\ndev = pci_get_bus_and_slot(0, 1);\r\npci_read_config_dword(dev, 0x7C, &sim_data.memory_type);\r\npci_dev_put(dev);\r\nsim_data.memory_type = (sim_data.memory_type >> 12) & 1;\r\nsim_data.memory_width = 64;\r\nsim_data.mem_latency = 3;\r\nsim_data.mem_aligned = 1;\r\nsim_data.mem_page_miss = 10;\r\nsim_data.gr_during_vid = 0;\r\nsim_data.pclk_khz = VClk;\r\nsim_data.mclk_khz = MClk;\r\nsim_data.nvclk_khz = NVClk;\r\nnv10CalcArbitration(&fifo_data, &sim_data);\r\nif (fifo_data.valid)\r\n{\r\nint b = fifo_data.graphics_burst_size >> 4;\r\n*burst = 0;\r\nwhile (b >>= 1)\r\n(*burst)++;\r\n*lwm = fifo_data.graphics_lwm >> 3;\r\n}\r\n}\r\nstatic int CalcVClock\r\n(\r\nint clockIn,\r\nint *clockOut,\r\nint *mOut,\r\nint *nOut,\r\nint *pOut,\r\nRIVA_HW_INST *chip\r\n)\r\n{\r\nunsigned lowM, highM, highP;\r\nunsigned DeltaNew, DeltaOld;\r\nunsigned VClk, Freq;\r\nunsigned M, N, P;\r\nDeltaOld = 0xFFFFFFFF;\r\nVClk = (unsigned)clockIn;\r\nif (chip->CrystalFreqKHz == 13500)\r\n{\r\nlowM = 7;\r\nhighM = 13 - (chip->Architecture == NV_ARCH_03);\r\n}\r\nelse\r\n{\r\nlowM = 8;\r\nhighM = 14 - (chip->Architecture == NV_ARCH_03);\r\n}\r\nhighP = 4 - (chip->Architecture == NV_ARCH_03);\r\nfor (P = 0; P <= highP; P ++)\r\n{\r\nFreq = VClk << P;\r\nif ((Freq >= 128000) && (Freq <= chip->MaxVClockFreqKHz))\r\n{\r\nfor (M = lowM; M <= highM; M++)\r\n{\r\nN = (VClk << P) * M / chip->CrystalFreqKHz;\r\nif(N <= 255) {\r\nFreq = (chip->CrystalFreqKHz * N / M) >> P;\r\nif (Freq > VClk)\r\nDeltaNew = Freq - VClk;\r\nelse\r\nDeltaNew = VClk - Freq;\r\nif (DeltaNew < DeltaOld)\r\n{\r\n*mOut = M;\r\n*nOut = N;\r\n*pOut = P;\r\n*clockOut = Freq;\r\nDeltaOld = DeltaNew;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nreturn (DeltaOld != 0xFFFFFFFF);\r\n}\r\nint CalcStateExt\r\n(\r\nRIVA_HW_INST *chip,\r\nRIVA_HW_STATE *state,\r\nint bpp,\r\nint width,\r\nint hDisplaySize,\r\nint height,\r\nint dotClock\r\n)\r\n{\r\nint pixelDepth;\r\nint uninitialized_var(VClk),uninitialized_var(m),\r\nuninitialized_var(n), uninitialized_var(p);\r\nstate->bpp = bpp;\r\nstate->width = width;\r\nstate->height = height;\r\npixelDepth = (bpp + 1)/8;\r\nif (!CalcVClock(dotClock, &VClk, &m, &n, &p, chip))\r\nreturn -EINVAL;\r\nswitch (chip->Architecture)\r\n{\r\ncase NV_ARCH_03:\r\nnv3UpdateArbitrationSettings(VClk,\r\npixelDepth * 8,\r\n&(state->arbitration0),\r\n&(state->arbitration1),\r\nchip);\r\nstate->cursor0 = 0x00;\r\nstate->cursor1 = 0x78;\r\nstate->cursor2 = 0x00000000;\r\nstate->pllsel = 0x10010100;\r\nstate->config = ((width + 31)/32)\r\n| (((pixelDepth > 2) ? 3 : pixelDepth) << 8)\r\n| 0x1000;\r\nstate->general = 0x00100100;\r\nstate->repaint1 = hDisplaySize < 1280 ? 0x06 : 0x02;\r\nbreak;\r\ncase NV_ARCH_04:\r\nnv4UpdateArbitrationSettings(VClk,\r\npixelDepth * 8,\r\n&(state->arbitration0),\r\n&(state->arbitration1),\r\nchip);\r\nstate->cursor0 = 0x00;\r\nstate->cursor1 = 0xFC;\r\nstate->cursor2 = 0x00000000;\r\nstate->pllsel = 0x10000700;\r\nstate->config = 0x00001114;\r\nstate->general = bpp == 16 ? 0x00101100 : 0x00100100;\r\nstate->repaint1 = hDisplaySize < 1280 ? 0x04 : 0x00;\r\nbreak;\r\ncase NV_ARCH_10:\r\ncase NV_ARCH_20:\r\ncase NV_ARCH_30:\r\nif((chip->Chipset == NV_CHIP_IGEFORCE2) ||\r\n(chip->Chipset == NV_CHIP_0x01F0))\r\n{\r\nnForceUpdateArbitrationSettings(VClk,\r\npixelDepth * 8,\r\n&(state->arbitration0),\r\n&(state->arbitration1),\r\nchip);\r\n} else {\r\nnv10UpdateArbitrationSettings(VClk,\r\npixelDepth * 8,\r\n&(state->arbitration0),\r\n&(state->arbitration1),\r\nchip);\r\n}\r\nstate->cursor0 = 0x80 | (chip->CursorStart >> 17);\r\nstate->cursor1 = (chip->CursorStart >> 11) << 2;\r\nstate->cursor2 = chip->CursorStart >> 24;\r\nstate->pllsel = 0x10000700;\r\nstate->config = NV_RD32(&chip->PFB[0x00000200/4], 0);\r\nstate->general = bpp == 16 ? 0x00101100 : 0x00100100;\r\nstate->repaint1 = hDisplaySize < 1280 ? 0x04 : 0x00;\r\nbreak;\r\n}\r\nif((bpp != 8) && (chip->Architecture != NV_ARCH_03))\r\nstate->general |= 0x00000030;\r\nstate->vpll = (p << 16) | (n << 8) | m;\r\nstate->repaint0 = (((width/8)*pixelDepth) & 0x700) >> 3;\r\nstate->pixel = pixelDepth > 2 ? 3 : pixelDepth;\r\nstate->offset0 =\r\nstate->offset1 =\r\nstate->offset2 =\r\nstate->offset3 = 0;\r\nstate->pitch0 =\r\nstate->pitch1 =\r\nstate->pitch2 =\r\nstate->pitch3 = pixelDepth * width;\r\nreturn 0;\r\n}\r\nstatic void UpdateFifoState\r\n(\r\nRIVA_HW_INST *chip\r\n)\r\n{\r\nint i;\r\nswitch (chip->Architecture)\r\n{\r\ncase NV_ARCH_04:\r\nLOAD_FIXED_STATE(nv4,FIFO);\r\nchip->Tri03 = NULL;\r\nchip->Tri05 = (RivaTexturedTriangle05 __iomem *)&(chip->FIFO[0x0000E000/4]);\r\nbreak;\r\ncase NV_ARCH_10:\r\ncase NV_ARCH_20:\r\ncase NV_ARCH_30:\r\nLOAD_FIXED_STATE(nv10tri05,PGRAPH);\r\nLOAD_FIXED_STATE(nv10,FIFO);\r\nchip->Tri03 = NULL;\r\nchip->Tri05 = (RivaTexturedTriangle05 __iomem *)&(chip->FIFO[0x0000E000/4]);\r\nbreak;\r\n}\r\n}\r\nstatic void LoadStateExt\r\n(\r\nRIVA_HW_INST *chip,\r\nRIVA_HW_STATE *state\r\n)\r\n{\r\nint i;\r\nLOAD_FIXED_STATE(Riva,PMC);\r\nLOAD_FIXED_STATE(Riva,PTIMER);\r\nswitch (chip->Architecture)\r\n{\r\ncase NV_ARCH_03:\r\nNV_WR32(chip->PFB, 0x00000200, state->config);\r\nLOAD_FIXED_STATE(nv3,PFIFO);\r\nLOAD_FIXED_STATE(nv3,PRAMIN);\r\nLOAD_FIXED_STATE(nv3,PGRAPH);\r\nswitch (state->bpp)\r\n{\r\ncase 15:\r\ncase 16:\r\nLOAD_FIXED_STATE_15BPP(nv3,PRAMIN);\r\nLOAD_FIXED_STATE_15BPP(nv3,PGRAPH);\r\nchip->Tri03 = (RivaTexturedTriangle03 __iomem *)&(chip->FIFO[0x0000E000/4]);\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nLOAD_FIXED_STATE_32BPP(nv3,PRAMIN);\r\nLOAD_FIXED_STATE_32BPP(nv3,PGRAPH);\r\nchip->Tri03 = NULL;\r\nbreak;\r\ncase 8:\r\ndefault:\r\nLOAD_FIXED_STATE_8BPP(nv3,PRAMIN);\r\nLOAD_FIXED_STATE_8BPP(nv3,PGRAPH);\r\nchip->Tri03 = NULL;\r\nbreak;\r\n}\r\nfor (i = 0x00000; i < 0x00800; i++)\r\nNV_WR32(&chip->PRAMIN[0x00000502 + i], 0, (i << 12) | 0x03);\r\nNV_WR32(chip->PGRAPH, 0x00000630, state->offset0);\r\nNV_WR32(chip->PGRAPH, 0x00000634, state->offset1);\r\nNV_WR32(chip->PGRAPH, 0x00000638, state->offset2);\r\nNV_WR32(chip->PGRAPH, 0x0000063C, state->offset3);\r\nNV_WR32(chip->PGRAPH, 0x00000650, state->pitch0);\r\nNV_WR32(chip->PGRAPH, 0x00000654, state->pitch1);\r\nNV_WR32(chip->PGRAPH, 0x00000658, state->pitch2);\r\nNV_WR32(chip->PGRAPH, 0x0000065C, state->pitch3);\r\nbreak;\r\ncase NV_ARCH_04:\r\nNV_WR32(chip->PFB, 0x00000200, state->config);\r\nLOAD_FIXED_STATE(nv4,PFIFO);\r\nLOAD_FIXED_STATE(nv4,PRAMIN);\r\nLOAD_FIXED_STATE(nv4,PGRAPH);\r\nswitch (state->bpp)\r\n{\r\ncase 15:\r\nLOAD_FIXED_STATE_15BPP(nv4,PRAMIN);\r\nLOAD_FIXED_STATE_15BPP(nv4,PGRAPH);\r\nchip->Tri03 = (RivaTexturedTriangle03 __iomem *)&(chip->FIFO[0x0000E000/4]);\r\nbreak;\r\ncase 16:\r\nLOAD_FIXED_STATE_16BPP(nv4,PRAMIN);\r\nLOAD_FIXED_STATE_16BPP(nv4,PGRAPH);\r\nchip->Tri03 = (RivaTexturedTriangle03 __iomem *)&(chip->FIFO[0x0000E000/4]);\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nLOAD_FIXED_STATE_32BPP(nv4,PRAMIN);\r\nLOAD_FIXED_STATE_32BPP(nv4,PGRAPH);\r\nchip->Tri03 = NULL;\r\nbreak;\r\ncase 8:\r\ndefault:\r\nLOAD_FIXED_STATE_8BPP(nv4,PRAMIN);\r\nLOAD_FIXED_STATE_8BPP(nv4,PGRAPH);\r\nchip->Tri03 = NULL;\r\nbreak;\r\n}\r\nNV_WR32(chip->PGRAPH, 0x00000640, state->offset0);\r\nNV_WR32(chip->PGRAPH, 0x00000644, state->offset1);\r\nNV_WR32(chip->PGRAPH, 0x00000648, state->offset2);\r\nNV_WR32(chip->PGRAPH, 0x0000064C, state->offset3);\r\nNV_WR32(chip->PGRAPH, 0x00000670, state->pitch0);\r\nNV_WR32(chip->PGRAPH, 0x00000674, state->pitch1);\r\nNV_WR32(chip->PGRAPH, 0x00000678, state->pitch2);\r\nNV_WR32(chip->PGRAPH, 0x0000067C, state->pitch3);\r\nbreak;\r\ncase NV_ARCH_10:\r\ncase NV_ARCH_20:\r\ncase NV_ARCH_30:\r\nif(chip->twoHeads) {\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x44);\r\nVGA_WR08(chip->PCIO, 0x03D5, state->crtcOwner);\r\nchip->LockUnlock(chip, 0);\r\n}\r\nLOAD_FIXED_STATE(nv10,PFIFO);\r\nLOAD_FIXED_STATE(nv10,PRAMIN);\r\nLOAD_FIXED_STATE(nv10,PGRAPH);\r\nswitch (state->bpp)\r\n{\r\ncase 15:\r\nLOAD_FIXED_STATE_15BPP(nv10,PRAMIN);\r\nLOAD_FIXED_STATE_15BPP(nv10,PGRAPH);\r\nchip->Tri03 = (RivaTexturedTriangle03 __iomem *)&(chip->FIFO[0x0000E000/4]);\r\nbreak;\r\ncase 16:\r\nLOAD_FIXED_STATE_16BPP(nv10,PRAMIN);\r\nLOAD_FIXED_STATE_16BPP(nv10,PGRAPH);\r\nchip->Tri03 = (RivaTexturedTriangle03 __iomem *)&(chip->FIFO[0x0000E000/4]);\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nLOAD_FIXED_STATE_32BPP(nv10,PRAMIN);\r\nLOAD_FIXED_STATE_32BPP(nv10,PGRAPH);\r\nchip->Tri03 = NULL;\r\nbreak;\r\ncase 8:\r\ndefault:\r\nLOAD_FIXED_STATE_8BPP(nv10,PRAMIN);\r\nLOAD_FIXED_STATE_8BPP(nv10,PGRAPH);\r\nchip->Tri03 = NULL;\r\nbreak;\r\n}\r\nif(chip->Architecture == NV_ARCH_10) {\r\nNV_WR32(chip->PGRAPH, 0x00000640, state->offset0);\r\nNV_WR32(chip->PGRAPH, 0x00000644, state->offset1);\r\nNV_WR32(chip->PGRAPH, 0x00000648, state->offset2);\r\nNV_WR32(chip->PGRAPH, 0x0000064C, state->offset3);\r\nNV_WR32(chip->PGRAPH, 0x00000670, state->pitch0);\r\nNV_WR32(chip->PGRAPH, 0x00000674, state->pitch1);\r\nNV_WR32(chip->PGRAPH, 0x00000678, state->pitch2);\r\nNV_WR32(chip->PGRAPH, 0x0000067C, state->pitch3);\r\nNV_WR32(chip->PGRAPH, 0x00000680, state->pitch3);\r\n} else {\r\nNV_WR32(chip->PGRAPH, 0x00000820, state->offset0);\r\nNV_WR32(chip->PGRAPH, 0x00000824, state->offset1);\r\nNV_WR32(chip->PGRAPH, 0x00000828, state->offset2);\r\nNV_WR32(chip->PGRAPH, 0x0000082C, state->offset3);\r\nNV_WR32(chip->PGRAPH, 0x00000850, state->pitch0);\r\nNV_WR32(chip->PGRAPH, 0x00000854, state->pitch1);\r\nNV_WR32(chip->PGRAPH, 0x00000858, state->pitch2);\r\nNV_WR32(chip->PGRAPH, 0x0000085C, state->pitch3);\r\nNV_WR32(chip->PGRAPH, 0x00000860, state->pitch3);\r\nNV_WR32(chip->PGRAPH, 0x00000864, state->pitch3);\r\nNV_WR32(chip->PGRAPH, 0x000009A4, NV_RD32(chip->PFB, 0x00000200));\r\nNV_WR32(chip->PGRAPH, 0x000009A8, NV_RD32(chip->PFB, 0x00000204));\r\n}\r\nif(chip->twoHeads) {\r\nNV_WR32(chip->PCRTC0, 0x00000860, state->head);\r\nNV_WR32(chip->PCRTC0, 0x00002860, state->head2);\r\n}\r\nNV_WR32(chip->PRAMDAC, 0x00000404, NV_RD32(chip->PRAMDAC, 0x00000404) | (1 << 25));\r\nNV_WR32(chip->PMC, 0x00008704, 1);\r\nNV_WR32(chip->PMC, 0x00008140, 0);\r\nNV_WR32(chip->PMC, 0x00008920, 0);\r\nNV_WR32(chip->PMC, 0x00008924, 0);\r\nNV_WR32(chip->PMC, 0x00008908, 0x01ffffff);\r\nNV_WR32(chip->PMC, 0x0000890C, 0x01ffffff);\r\nNV_WR32(chip->PMC, 0x00001588, 0);\r\nNV_WR32(chip->PFB, 0x00000240, 0);\r\nNV_WR32(chip->PFB, 0x00000250, 0);\r\nNV_WR32(chip->PFB, 0x00000260, 0);\r\nNV_WR32(chip->PFB, 0x00000270, 0);\r\nNV_WR32(chip->PFB, 0x00000280, 0);\r\nNV_WR32(chip->PFB, 0x00000290, 0);\r\nNV_WR32(chip->PFB, 0x000002A0, 0);\r\nNV_WR32(chip->PFB, 0x000002B0, 0);\r\nNV_WR32(chip->PGRAPH, 0x00000B00, NV_RD32(chip->PFB, 0x00000240));\r\nNV_WR32(chip->PGRAPH, 0x00000B04, NV_RD32(chip->PFB, 0x00000244));\r\nNV_WR32(chip->PGRAPH, 0x00000B08, NV_RD32(chip->PFB, 0x00000248));\r\nNV_WR32(chip->PGRAPH, 0x00000B0C, NV_RD32(chip->PFB, 0x0000024C));\r\nNV_WR32(chip->PGRAPH, 0x00000B10, NV_RD32(chip->PFB, 0x00000250));\r\nNV_WR32(chip->PGRAPH, 0x00000B14, NV_RD32(chip->PFB, 0x00000254));\r\nNV_WR32(chip->PGRAPH, 0x00000B18, NV_RD32(chip->PFB, 0x00000258));\r\nNV_WR32(chip->PGRAPH, 0x00000B1C, NV_RD32(chip->PFB, 0x0000025C));\r\nNV_WR32(chip->PGRAPH, 0x00000B20, NV_RD32(chip->PFB, 0x00000260));\r\nNV_WR32(chip->PGRAPH, 0x00000B24, NV_RD32(chip->PFB, 0x00000264));\r\nNV_WR32(chip->PGRAPH, 0x00000B28, NV_RD32(chip->PFB, 0x00000268));\r\nNV_WR32(chip->PGRAPH, 0x00000B2C, NV_RD32(chip->PFB, 0x0000026C));\r\nNV_WR32(chip->PGRAPH, 0x00000B30, NV_RD32(chip->PFB, 0x00000270));\r\nNV_WR32(chip->PGRAPH, 0x00000B34, NV_RD32(chip->PFB, 0x00000274));\r\nNV_WR32(chip->PGRAPH, 0x00000B38, NV_RD32(chip->PFB, 0x00000278));\r\nNV_WR32(chip->PGRAPH, 0x00000B3C, NV_RD32(chip->PFB, 0x0000027C));\r\nNV_WR32(chip->PGRAPH, 0x00000B40, NV_RD32(chip->PFB, 0x00000280));\r\nNV_WR32(chip->PGRAPH, 0x00000B44, NV_RD32(chip->PFB, 0x00000284));\r\nNV_WR32(chip->PGRAPH, 0x00000B48, NV_RD32(chip->PFB, 0x00000288));\r\nNV_WR32(chip->PGRAPH, 0x00000B4C, NV_RD32(chip->PFB, 0x0000028C));\r\nNV_WR32(chip->PGRAPH, 0x00000B50, NV_RD32(chip->PFB, 0x00000290));\r\nNV_WR32(chip->PGRAPH, 0x00000B54, NV_RD32(chip->PFB, 0x00000294));\r\nNV_WR32(chip->PGRAPH, 0x00000B58, NV_RD32(chip->PFB, 0x00000298));\r\nNV_WR32(chip->PGRAPH, 0x00000B5C, NV_RD32(chip->PFB, 0x0000029C));\r\nNV_WR32(chip->PGRAPH, 0x00000B60, NV_RD32(chip->PFB, 0x000002A0));\r\nNV_WR32(chip->PGRAPH, 0x00000B64, NV_RD32(chip->PFB, 0x000002A4));\r\nNV_WR32(chip->PGRAPH, 0x00000B68, NV_RD32(chip->PFB, 0x000002A8));\r\nNV_WR32(chip->PGRAPH, 0x00000B6C, NV_RD32(chip->PFB, 0x000002AC));\r\nNV_WR32(chip->PGRAPH, 0x00000B70, NV_RD32(chip->PFB, 0x000002B0));\r\nNV_WR32(chip->PGRAPH, 0x00000B74, NV_RD32(chip->PFB, 0x000002B4));\r\nNV_WR32(chip->PGRAPH, 0x00000B78, NV_RD32(chip->PFB, 0x000002B8));\r\nNV_WR32(chip->PGRAPH, 0x00000B7C, NV_RD32(chip->PFB, 0x000002BC));\r\nNV_WR32(chip->PGRAPH, 0x00000F40, 0x10000000);\r\nNV_WR32(chip->PGRAPH, 0x00000F44, 0x00000000);\r\nNV_WR32(chip->PGRAPH, 0x00000F50, 0x00000040);\r\nNV_WR32(chip->PGRAPH, 0x00000F54, 0x00000008);\r\nNV_WR32(chip->PGRAPH, 0x00000F50, 0x00000200);\r\nfor (i = 0; i < (3*16); i++)\r\nNV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\r\nNV_WR32(chip->PGRAPH, 0x00000F50, 0x00000040);\r\nNV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\r\nNV_WR32(chip->PGRAPH, 0x00000F50, 0x00000800);\r\nfor (i = 0; i < (16*16); i++)\r\nNV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\r\nNV_WR32(chip->PGRAPH, 0x00000F40, 0x30000000);\r\nNV_WR32(chip->PGRAPH, 0x00000F44, 0x00000004);\r\nNV_WR32(chip->PGRAPH, 0x00000F50, 0x00006400);\r\nfor (i = 0; i < (59*4); i++)\r\nNV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\r\nNV_WR32(chip->PGRAPH, 0x00000F50, 0x00006800);\r\nfor (i = 0; i < (47*4); i++)\r\nNV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\r\nNV_WR32(chip->PGRAPH, 0x00000F50, 0x00006C00);\r\nfor (i = 0; i < (3*4); i++)\r\nNV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\r\nNV_WR32(chip->PGRAPH, 0x00000F50, 0x00007000);\r\nfor (i = 0; i < (19*4); i++)\r\nNV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\r\nNV_WR32(chip->PGRAPH, 0x00000F50, 0x00007400);\r\nfor (i = 0; i < (12*4); i++)\r\nNV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\r\nNV_WR32(chip->PGRAPH, 0x00000F50, 0x00007800);\r\nfor (i = 0; i < (12*4); i++)\r\nNV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\r\nNV_WR32(chip->PGRAPH, 0x00000F50, 0x00004400);\r\nfor (i = 0; i < (8*4); i++)\r\nNV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\r\nNV_WR32(chip->PGRAPH, 0x00000F50, 0x00000000);\r\nfor (i = 0; i < 16; i++)\r\nNV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\r\nNV_WR32(chip->PGRAPH, 0x00000F50, 0x00000040);\r\nfor (i = 0; i < 4; i++)\r\nNV_WR32(chip->PGRAPH, 0x00000F54, 0x00000000);\r\nNV_WR32(chip->PCRTC, 0x00000810, state->cursorConfig);\r\nif(chip->flatPanel) {\r\nif((chip->Chipset & 0x0ff0) == 0x0110) {\r\nNV_WR32(chip->PRAMDAC, 0x0528, state->dither);\r\n} else\r\nif((chip->Chipset & 0x0ff0) >= 0x0170) {\r\nNV_WR32(chip->PRAMDAC, 0x083C, state->dither);\r\n}\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x53);\r\nVGA_WR08(chip->PCIO, 0x03D5, 0);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x54);\r\nVGA_WR08(chip->PCIO, 0x03D5, 0);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x21);\r\nVGA_WR08(chip->PCIO, 0x03D5, 0xfa);\r\n}\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x41);\r\nVGA_WR08(chip->PCIO, 0x03D5, state->extra);\r\n}\r\nLOAD_FIXED_STATE(Riva,FIFO);\r\nUpdateFifoState(chip);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x19);\r\nVGA_WR08(chip->PCIO, 0x03D5, state->repaint0);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x1A);\r\nVGA_WR08(chip->PCIO, 0x03D5, state->repaint1);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x25);\r\nVGA_WR08(chip->PCIO, 0x03D5, state->screen);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x28);\r\nVGA_WR08(chip->PCIO, 0x03D5, state->pixel);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x2D);\r\nVGA_WR08(chip->PCIO, 0x03D5, state->horiz);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x1B);\r\nVGA_WR08(chip->PCIO, 0x03D5, state->arbitration0);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x20);\r\nVGA_WR08(chip->PCIO, 0x03D5, state->arbitration1);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x30);\r\nVGA_WR08(chip->PCIO, 0x03D5, state->cursor0);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x31);\r\nVGA_WR08(chip->PCIO, 0x03D5, state->cursor1);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x2F);\r\nVGA_WR08(chip->PCIO, 0x03D5, state->cursor2);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x39);\r\nVGA_WR08(chip->PCIO, 0x03D5, state->interlace);\r\nif(!chip->flatPanel) {\r\nNV_WR32(chip->PRAMDAC0, 0x00000508, state->vpll);\r\nNV_WR32(chip->PRAMDAC0, 0x0000050C, state->pllsel);\r\nif(chip->twoHeads)\r\nNV_WR32(chip->PRAMDAC0, 0x00000520, state->vpll2);\r\n} else {\r\nNV_WR32(chip->PRAMDAC, 0x00000848 , state->scale);\r\n}\r\nNV_WR32(chip->PRAMDAC, 0x00000600 , state->general);\r\nNV_WR32(chip->PCRTC, 0x00000140, 0);\r\nNV_WR32(chip->PCRTC, 0x00000100, chip->VBlankBit);\r\nNV_WR32(chip->PMC, 0x00000140, chip->EnableIRQ & 0x01);\r\nchip->CurrentState = state;\r\nchip->FifoFreeCount = 0;\r\nchip->FifoEmptyCount = NV_RD32(&chip->Rop->FifoFree, 0);\r\n}\r\nstatic void UnloadStateExt\r\n(\r\nRIVA_HW_INST *chip,\r\nRIVA_HW_STATE *state\r\n)\r\n{\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x19);\r\nstate->repaint0 = VGA_RD08(chip->PCIO, 0x03D5);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x1A);\r\nstate->repaint1 = VGA_RD08(chip->PCIO, 0x03D5);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x25);\r\nstate->screen = VGA_RD08(chip->PCIO, 0x03D5);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x28);\r\nstate->pixel = VGA_RD08(chip->PCIO, 0x03D5);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x2D);\r\nstate->horiz = VGA_RD08(chip->PCIO, 0x03D5);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x1B);\r\nstate->arbitration0 = VGA_RD08(chip->PCIO, 0x03D5);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x20);\r\nstate->arbitration1 = VGA_RD08(chip->PCIO, 0x03D5);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x30);\r\nstate->cursor0 = VGA_RD08(chip->PCIO, 0x03D5);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x31);\r\nstate->cursor1 = VGA_RD08(chip->PCIO, 0x03D5);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x2F);\r\nstate->cursor2 = VGA_RD08(chip->PCIO, 0x03D5);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x39);\r\nstate->interlace = VGA_RD08(chip->PCIO, 0x03D5);\r\nstate->vpll = NV_RD32(chip->PRAMDAC0, 0x00000508);\r\nstate->vpll2 = NV_RD32(chip->PRAMDAC0, 0x00000520);\r\nstate->pllsel = NV_RD32(chip->PRAMDAC0, 0x0000050C);\r\nstate->general = NV_RD32(chip->PRAMDAC, 0x00000600);\r\nstate->scale = NV_RD32(chip->PRAMDAC, 0x00000848);\r\nstate->config = NV_RD32(chip->PFB, 0x00000200);\r\nswitch (chip->Architecture)\r\n{\r\ncase NV_ARCH_03:\r\nstate->offset0 = NV_RD32(chip->PGRAPH, 0x00000630);\r\nstate->offset1 = NV_RD32(chip->PGRAPH, 0x00000634);\r\nstate->offset2 = NV_RD32(chip->PGRAPH, 0x00000638);\r\nstate->offset3 = NV_RD32(chip->PGRAPH, 0x0000063C);\r\nstate->pitch0 = NV_RD32(chip->PGRAPH, 0x00000650);\r\nstate->pitch1 = NV_RD32(chip->PGRAPH, 0x00000654);\r\nstate->pitch2 = NV_RD32(chip->PGRAPH, 0x00000658);\r\nstate->pitch3 = NV_RD32(chip->PGRAPH, 0x0000065C);\r\nbreak;\r\ncase NV_ARCH_04:\r\nstate->offset0 = NV_RD32(chip->PGRAPH, 0x00000640);\r\nstate->offset1 = NV_RD32(chip->PGRAPH, 0x00000644);\r\nstate->offset2 = NV_RD32(chip->PGRAPH, 0x00000648);\r\nstate->offset3 = NV_RD32(chip->PGRAPH, 0x0000064C);\r\nstate->pitch0 = NV_RD32(chip->PGRAPH, 0x00000670);\r\nstate->pitch1 = NV_RD32(chip->PGRAPH, 0x00000674);\r\nstate->pitch2 = NV_RD32(chip->PGRAPH, 0x00000678);\r\nstate->pitch3 = NV_RD32(chip->PGRAPH, 0x0000067C);\r\nbreak;\r\ncase NV_ARCH_10:\r\ncase NV_ARCH_20:\r\ncase NV_ARCH_30:\r\nstate->offset0 = NV_RD32(chip->PGRAPH, 0x00000640);\r\nstate->offset1 = NV_RD32(chip->PGRAPH, 0x00000644);\r\nstate->offset2 = NV_RD32(chip->PGRAPH, 0x00000648);\r\nstate->offset3 = NV_RD32(chip->PGRAPH, 0x0000064C);\r\nstate->pitch0 = NV_RD32(chip->PGRAPH, 0x00000670);\r\nstate->pitch1 = NV_RD32(chip->PGRAPH, 0x00000674);\r\nstate->pitch2 = NV_RD32(chip->PGRAPH, 0x00000678);\r\nstate->pitch3 = NV_RD32(chip->PGRAPH, 0x0000067C);\r\nif(chip->twoHeads) {\r\nstate->head = NV_RD32(chip->PCRTC0, 0x00000860);\r\nstate->head2 = NV_RD32(chip->PCRTC0, 0x00002860);\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x44);\r\nstate->crtcOwner = VGA_RD08(chip->PCIO, 0x03D5);\r\n}\r\nVGA_WR08(chip->PCIO, 0x03D4, 0x41);\r\nstate->extra = VGA_RD08(chip->PCIO, 0x03D5);\r\nstate->cursorConfig = NV_RD32(chip->PCRTC, 0x00000810);\r\nif((chip->Chipset & 0x0ff0) == 0x0110) {\r\nstate->dither = NV_RD32(chip->PRAMDAC, 0x0528);\r\n} else\r\nif((chip->Chipset & 0x0ff0) >= 0x0170) {\r\nstate->dither = NV_RD32(chip->PRAMDAC, 0x083C);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void SetStartAddress\r\n(\r\nRIVA_HW_INST *chip,\r\nunsigned start\r\n)\r\n{\r\nNV_WR32(chip->PCRTC, 0x800, start);\r\n}\r\nstatic void SetStartAddress3\r\n(\r\nRIVA_HW_INST *chip,\r\nunsigned start\r\n)\r\n{\r\nint offset = start >> 2;\r\nint pan = (start & 3) << 1;\r\nunsigned char tmp;\r\nchip->LockUnlock(chip, 0);\r\nVGA_WR08(chip->PCIO, 0x3D4, 0x0D); VGA_WR08(chip->PCIO, 0x3D5, offset);\r\noffset >>= 8;\r\nVGA_WR08(chip->PCIO, 0x3D4, 0x0C); VGA_WR08(chip->PCIO, 0x3D5, offset);\r\noffset >>= 8;\r\nVGA_WR08(chip->PCIO, 0x3D4, 0x19); tmp = VGA_RD08(chip->PCIO, 0x3D5);\r\nVGA_WR08(chip->PCIO, 0x3D5, (offset & 0x01F) | (tmp & ~0x1F));\r\nVGA_WR08(chip->PCIO, 0x3D4, 0x2D); tmp = VGA_RD08(chip->PCIO, 0x3D5);\r\nVGA_WR08(chip->PCIO, 0x3D5, (offset & 0x60) | (tmp & ~0x60));\r\noffset = VGA_RD08(chip->PCIO, chip->IO + 0x0A);\r\nVGA_WR08(chip->PCIO, 0x3C0, 0x13);\r\nVGA_WR08(chip->PCIO, 0x3C0, pan);\r\n}\r\nstatic void nv3SetSurfaces2D\r\n(\r\nRIVA_HW_INST *chip,\r\nunsigned surf0,\r\nunsigned surf1\r\n)\r\n{\r\nRivaSurface __iomem *Surface =\r\n(RivaSurface __iomem *)&(chip->FIFO[0x0000E000/4]);\r\nRIVA_FIFO_FREE(*chip,Tri03,5);\r\nNV_WR32(&chip->FIFO[0x00003800], 0, 0x80000003);\r\nNV_WR32(&Surface->Offset, 0, surf0);\r\nNV_WR32(&chip->FIFO[0x00003800], 0, 0x80000004);\r\nNV_WR32(&Surface->Offset, 0, surf1);\r\nNV_WR32(&chip->FIFO[0x00003800], 0, 0x80000013);\r\n}\r\nstatic void nv4SetSurfaces2D\r\n(\r\nRIVA_HW_INST *chip,\r\nunsigned surf0,\r\nunsigned surf1\r\n)\r\n{\r\nRivaSurface __iomem *Surface =\r\n(RivaSurface __iomem *)&(chip->FIFO[0x0000E000/4]);\r\nNV_WR32(&chip->FIFO[0x00003800], 0, 0x80000003);\r\nNV_WR32(&Surface->Offset, 0, surf0);\r\nNV_WR32(&chip->FIFO[0x00003800], 0, 0x80000004);\r\nNV_WR32(&Surface->Offset, 0, surf1);\r\nNV_WR32(&chip->FIFO[0x00003800], 0, 0x80000014);\r\n}\r\nstatic void nv10SetSurfaces2D\r\n(\r\nRIVA_HW_INST *chip,\r\nunsigned surf0,\r\nunsigned surf1\r\n)\r\n{\r\nRivaSurface __iomem *Surface =\r\n(RivaSurface __iomem *)&(chip->FIFO[0x0000E000/4]);\r\nNV_WR32(&chip->FIFO[0x00003800], 0, 0x80000003);\r\nNV_WR32(&Surface->Offset, 0, surf0);\r\nNV_WR32(&chip->FIFO[0x00003800], 0, 0x80000004);\r\nNV_WR32(&Surface->Offset, 0, surf1);\r\nNV_WR32(&chip->FIFO[0x00003800], 0, 0x80000014);\r\n}\r\nstatic void nv3SetSurfaces3D\r\n(\r\nRIVA_HW_INST *chip,\r\nunsigned surf0,\r\nunsigned surf1\r\n)\r\n{\r\nRivaSurface __iomem *Surface =\r\n(RivaSurface __iomem *)&(chip->FIFO[0x0000E000/4]);\r\nRIVA_FIFO_FREE(*chip,Tri03,5);\r\nNV_WR32(&chip->FIFO[0x00003800], 0, 0x80000005);\r\nNV_WR32(&Surface->Offset, 0, surf0);\r\nNV_WR32(&chip->FIFO[0x00003800], 0, 0x80000006);\r\nNV_WR32(&Surface->Offset, 0, surf1);\r\nNV_WR32(&chip->FIFO[0x00003800], 0, 0x80000013);\r\n}\r\nstatic void nv4SetSurfaces3D\r\n(\r\nRIVA_HW_INST *chip,\r\nunsigned surf0,\r\nunsigned surf1\r\n)\r\n{\r\nRivaSurface __iomem *Surface =\r\n(RivaSurface __iomem *)&(chip->FIFO[0x0000E000/4]);\r\nNV_WR32(&chip->FIFO[0x00003800], 0, 0x80000005);\r\nNV_WR32(&Surface->Offset, 0, surf0);\r\nNV_WR32(&chip->FIFO[0x00003800], 0, 0x80000006);\r\nNV_WR32(&Surface->Offset, 0, surf1);\r\nNV_WR32(&chip->FIFO[0x00003800], 0, 0x80000014);\r\n}\r\nstatic void nv10SetSurfaces3D\r\n(\r\nRIVA_HW_INST *chip,\r\nunsigned surf0,\r\nunsigned surf1\r\n)\r\n{\r\nRivaSurface3D __iomem *Surfaces3D =\r\n(RivaSurface3D __iomem *)&(chip->FIFO[0x0000E000/4]);\r\nRIVA_FIFO_FREE(*chip,Tri03,4);\r\nNV_WR32(&chip->FIFO[0x00003800], 0, 0x80000007);\r\nNV_WR32(&Surfaces3D->RenderBufferOffset, 0, surf0);\r\nNV_WR32(&Surfaces3D->ZBufferOffset, 0, surf1);\r\nNV_WR32(&chip->FIFO[0x00003800], 0, 0x80000014);\r\n}\r\nstatic void nv3GetConfig\r\n(\r\nRIVA_HW_INST *chip\r\n)\r\n{\r\nif (NV_RD32(&chip->PFB[0x00000000/4], 0) & 0x00000020)\r\n{\r\nif (((NV_RD32(chip->PMC, 0x00000000) & 0xF0) == 0x20)\r\n&& ((NV_RD32(chip->PMC, 0x00000000) & 0x0F) >= 0x02))\r\n{\r\nchip->RamBandwidthKBytesPerSec = 800000;\r\nswitch (NV_RD32(chip->PFB, 0x00000000) & 0x03)\r\n{\r\ncase 2:\r\nchip->RamAmountKBytes = 1024 * 4;\r\nbreak;\r\ncase 1:\r\nchip->RamAmountKBytes = 1024 * 2;\r\nbreak;\r\ndefault:\r\nchip->RamAmountKBytes = 1024 * 8;\r\nbreak;\r\n}\r\n}\r\nelse\r\n{\r\nchip->RamBandwidthKBytesPerSec = 1000000;\r\nchip->RamAmountKBytes = 1024 * 8;\r\n}\r\n}\r\nelse\r\n{\r\nchip->RamBandwidthKBytesPerSec = 1000000;\r\nswitch (NV_RD32(chip->PFB, 0x00000000) & 0x00000003)\r\n{\r\ncase 0:\r\nchip->RamAmountKBytes = 1024 * 8;\r\nbreak;\r\ncase 2:\r\nchip->RamAmountKBytes = 1024 * 4;\r\nbreak;\r\ndefault:\r\nchip->RamAmountKBytes = 1024 * 2;\r\nbreak;\r\n}\r\n}\r\nchip->CrystalFreqKHz = (NV_RD32(chip->PEXTDEV, 0x00000000) & 0x00000040) ? 14318 : 13500;\r\nchip->CURSOR = &(chip->PRAMIN[0x00008000/4 - 0x0800/4]);\r\nchip->VBlankBit = 0x00000100;\r\nchip->MaxVClockFreqKHz = 256000;\r\nchip->Busy = nv3Busy;\r\nchip->ShowHideCursor = ShowHideCursor;\r\nchip->LoadStateExt = LoadStateExt;\r\nchip->UnloadStateExt = UnloadStateExt;\r\nchip->SetStartAddress = SetStartAddress3;\r\nchip->SetSurfaces2D = nv3SetSurfaces2D;\r\nchip->SetSurfaces3D = nv3SetSurfaces3D;\r\nchip->LockUnlock = nv3LockUnlock;\r\n}\r\nstatic void nv4GetConfig\r\n(\r\nRIVA_HW_INST *chip\r\n)\r\n{\r\nif (NV_RD32(chip->PFB, 0x00000000) & 0x00000100)\r\n{\r\nchip->RamAmountKBytes = ((NV_RD32(chip->PFB, 0x00000000) >> 12) & 0x0F) * 1024 * 2\r\n+ 1024 * 2;\r\n}\r\nelse\r\n{\r\nswitch (NV_RD32(chip->PFB, 0x00000000) & 0x00000003)\r\n{\r\ncase 0:\r\nchip->RamAmountKBytes = 1024 * 32;\r\nbreak;\r\ncase 1:\r\nchip->RamAmountKBytes = 1024 * 4;\r\nbreak;\r\ncase 2:\r\nchip->RamAmountKBytes = 1024 * 8;\r\nbreak;\r\ncase 3:\r\ndefault:\r\nchip->RamAmountKBytes = 1024 * 16;\r\nbreak;\r\n}\r\n}\r\nswitch ((NV_RD32(chip->PFB, 0x00000000) >> 3) & 0x00000003)\r\n{\r\ncase 3:\r\nchip->RamBandwidthKBytesPerSec = 800000;\r\nbreak;\r\ndefault:\r\nchip->RamBandwidthKBytesPerSec = 1000000;\r\nbreak;\r\n}\r\nchip->CrystalFreqKHz = (NV_RD32(chip->PEXTDEV, 0x00000000) & 0x00000040) ? 14318 : 13500;\r\nchip->CURSOR = &(chip->PRAMIN[0x00010000/4 - 0x0800/4]);\r\nchip->VBlankBit = 0x00000001;\r\nchip->MaxVClockFreqKHz = 350000;\r\nchip->Busy = nv4Busy;\r\nchip->ShowHideCursor = ShowHideCursor;\r\nchip->LoadStateExt = LoadStateExt;\r\nchip->UnloadStateExt = UnloadStateExt;\r\nchip->SetStartAddress = SetStartAddress;\r\nchip->SetSurfaces2D = nv4SetSurfaces2D;\r\nchip->SetSurfaces3D = nv4SetSurfaces3D;\r\nchip->LockUnlock = nv4LockUnlock;\r\n}\r\nstatic void nv10GetConfig\r\n(\r\nRIVA_HW_INST *chip,\r\nunsigned int chipset\r\n)\r\n{\r\nstruct pci_dev* dev;\r\nu32 amt;\r\n#ifdef __BIG_ENDIAN\r\nif(!(NV_RD32(chip->PMC, 0x00000004) & 0x01000001))\r\nNV_WR32(chip->PMC, 0x00000004, 0x01000001);\r\n#endif\r\nif(chipset == NV_CHIP_IGEFORCE2) {\r\ndev = pci_get_bus_and_slot(0, 1);\r\npci_read_config_dword(dev, 0x7C, &amt);\r\npci_dev_put(dev);\r\nchip->RamAmountKBytes = (((amt >> 6) & 31) + 1) * 1024;\r\n} else if(chipset == NV_CHIP_0x01F0) {\r\ndev = pci_get_bus_and_slot(0, 1);\r\npci_read_config_dword(dev, 0x84, &amt);\r\npci_dev_put(dev);\r\nchip->RamAmountKBytes = (((amt >> 4) & 127) + 1) * 1024;\r\n} else {\r\nswitch ((NV_RD32(chip->PFB, 0x0000020C) >> 20) & 0x000000FF)\r\n{\r\ncase 0x02:\r\nchip->RamAmountKBytes = 1024 * 2;\r\nbreak;\r\ncase 0x04:\r\nchip->RamAmountKBytes = 1024 * 4;\r\nbreak;\r\ncase 0x08:\r\nchip->RamAmountKBytes = 1024 * 8;\r\nbreak;\r\ncase 0x10:\r\nchip->RamAmountKBytes = 1024 * 16;\r\nbreak;\r\ncase 0x20:\r\nchip->RamAmountKBytes = 1024 * 32;\r\nbreak;\r\ncase 0x40:\r\nchip->RamAmountKBytes = 1024 * 64;\r\nbreak;\r\ncase 0x80:\r\nchip->RamAmountKBytes = 1024 * 128;\r\nbreak;\r\ndefault:\r\nchip->RamAmountKBytes = 1024 * 16;\r\nbreak;\r\n}\r\n}\r\nswitch ((NV_RD32(chip->PFB, 0x00000000) >> 3) & 0x00000003)\r\n{\r\ncase 3:\r\nchip->RamBandwidthKBytesPerSec = 800000;\r\nbreak;\r\ndefault:\r\nchip->RamBandwidthKBytesPerSec = 1000000;\r\nbreak;\r\n}\r\nchip->CrystalFreqKHz = (NV_RD32(chip->PEXTDEV, 0x0000) & (1 << 6)) ?\r\n14318 : 13500;\r\nswitch (chipset & 0x0ff0) {\r\ncase 0x0170:\r\ncase 0x0180:\r\ncase 0x01F0:\r\ncase 0x0250:\r\ncase 0x0280:\r\ncase 0x0300:\r\ncase 0x0310:\r\ncase 0x0320:\r\ncase 0x0330:\r\ncase 0x0340:\r\nif(NV_RD32(chip->PEXTDEV, 0x0000) & (1 << 22))\r\nchip->CrystalFreqKHz = 27000;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nchip->CursorStart = (chip->RamAmountKBytes - 128) * 1024;\r\nchip->CURSOR = NULL;\r\nchip->VBlankBit = 0x00000001;\r\nchip->MaxVClockFreqKHz = 350000;\r\nchip->Busy = nv10Busy;\r\nchip->ShowHideCursor = ShowHideCursor;\r\nchip->LoadStateExt = LoadStateExt;\r\nchip->UnloadStateExt = UnloadStateExt;\r\nchip->SetStartAddress = SetStartAddress;\r\nchip->SetSurfaces2D = nv10SetSurfaces2D;\r\nchip->SetSurfaces3D = nv10SetSurfaces3D;\r\nchip->LockUnlock = nv4LockUnlock;\r\nswitch(chipset & 0x0ff0) {\r\ncase 0x0110:\r\ncase 0x0170:\r\ncase 0x0180:\r\ncase 0x01F0:\r\ncase 0x0250:\r\ncase 0x0280:\r\ncase 0x0300:\r\ncase 0x0310:\r\ncase 0x0320:\r\ncase 0x0330:\r\ncase 0x0340:\r\nchip->twoHeads = TRUE;\r\nbreak;\r\ndefault:\r\nchip->twoHeads = FALSE;\r\nbreak;\r\n}\r\n}\r\nint RivaGetConfig\r\n(\r\nRIVA_HW_INST *chip,\r\nunsigned int chipset\r\n)\r\n{\r\nchip->Version = RIVA_SW_VERSION;\r\nswitch (chip->Architecture)\r\n{\r\ncase NV_ARCH_03:\r\nnv3GetConfig(chip);\r\nbreak;\r\ncase NV_ARCH_04:\r\nnv4GetConfig(chip);\r\nbreak;\r\ncase NV_ARCH_10:\r\ncase NV_ARCH_20:\r\ncase NV_ARCH_30:\r\nnv10GetConfig(chip, chipset);\r\nbreak;\r\ndefault:\r\nreturn (-1);\r\n}\r\nchip->Chipset = chipset;\r\nchip->Rop = (RivaRop __iomem *)&(chip->FIFO[0x00000000/4]);\r\nchip->Clip = (RivaClip __iomem *)&(chip->FIFO[0x00002000/4]);\r\nchip->Patt = (RivaPattern __iomem *)&(chip->FIFO[0x00004000/4]);\r\nchip->Pixmap = (RivaPixmap __iomem *)&(chip->FIFO[0x00006000/4]);\r\nchip->Blt = (RivaScreenBlt __iomem *)&(chip->FIFO[0x00008000/4]);\r\nchip->Bitmap = (RivaBitmap __iomem *)&(chip->FIFO[0x0000A000/4]);\r\nchip->Line = (RivaLine __iomem *)&(chip->FIFO[0x0000C000/4]);\r\nchip->Tri03 = (RivaTexturedTriangle03 __iomem *)&(chip->FIFO[0x0000E000/4]);\r\nreturn (0);\r\n}
