int __init early_init_dt_scan_fw_dump(unsigned long node,\r\nconst char *uname, int depth, void *data)\r\n{\r\nconst __be32 *sections;\r\nint i, num_sections;\r\nint size;\r\nconst int *token;\r\nif (depth != 1 || strcmp(uname, "rtas") != 0)\r\nreturn 0;\r\ntoken = of_get_flat_dt_prop(node, "ibm,configure-kernel-dump", NULL);\r\nif (!token)\r\nreturn 1;\r\nfw_dump.fadump_supported = 1;\r\nfw_dump.ibm_configure_kernel_dump = *token;\r\nfdm_active = of_get_flat_dt_prop(node, "ibm,kernel-dump", NULL);\r\nif (fdm_active)\r\nfw_dump.dump_active = 1;\r\nsections = of_get_flat_dt_prop(node, "ibm,configure-kernel-dump-sizes",\r\n&size);\r\nif (!sections)\r\nreturn 1;\r\nnum_sections = size / (3 * sizeof(u32));\r\nfor (i = 0; i < num_sections; i++, sections += 3) {\r\nu32 type = (u32)of_read_number(sections, 1);\r\nswitch (type) {\r\ncase FADUMP_CPU_STATE_DATA:\r\nfw_dump.cpu_state_data_size =\r\nof_read_ulong(&sections[1], 2);\r\nbreak;\r\ncase FADUMP_HPTE_REGION:\r\nfw_dump.hpte_region_size =\r\nof_read_ulong(&sections[1], 2);\r\nbreak;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nint is_fadump_active(void)\r\n{\r\nreturn fw_dump.dump_active;\r\n}\r\nstatic void fadump_show_config(void)\r\n{\r\npr_debug("Support for firmware-assisted dump (fadump): %s\n",\r\n(fw_dump.fadump_supported ? "present" : "no support"));\r\nif (!fw_dump.fadump_supported)\r\nreturn;\r\npr_debug("Fadump enabled : %s\n",\r\n(fw_dump.fadump_enabled ? "yes" : "no"));\r\npr_debug("Dump Active : %s\n",\r\n(fw_dump.dump_active ? "yes" : "no"));\r\npr_debug("Dump section sizes:\n");\r\npr_debug(" CPU state data size: %lx\n", fw_dump.cpu_state_data_size);\r\npr_debug(" HPTE region size : %lx\n", fw_dump.hpte_region_size);\r\npr_debug("Boot memory size : %lx\n", fw_dump.boot_memory_size);\r\n}\r\nstatic unsigned long init_fadump_mem_struct(struct fadump_mem_struct *fdm,\r\nunsigned long addr)\r\n{\r\nif (!fdm)\r\nreturn 0;\r\nmemset(fdm, 0, sizeof(struct fadump_mem_struct));\r\naddr = addr & PAGE_MASK;\r\nfdm->header.dump_format_version = 0x00000001;\r\nfdm->header.dump_num_sections = 3;\r\nfdm->header.dump_status_flag = 0;\r\nfdm->header.offset_first_dump_section =\r\n(u32)offsetof(struct fadump_mem_struct, cpu_state_data);\r\nfdm->header.dd_block_size = 0;\r\nfdm->header.dd_block_offset = 0;\r\nfdm->header.dd_num_blocks = 0;\r\nfdm->header.dd_offset_disk_path = 0;\r\nfdm->header.max_time_auto = 0;\r\nfdm->cpu_state_data.request_flag = FADUMP_REQUEST_FLAG;\r\nfdm->cpu_state_data.source_data_type = FADUMP_CPU_STATE_DATA;\r\nfdm->cpu_state_data.source_address = 0;\r\nfdm->cpu_state_data.source_len = fw_dump.cpu_state_data_size;\r\nfdm->cpu_state_data.destination_address = addr;\r\naddr += fw_dump.cpu_state_data_size;\r\nfdm->hpte_region.request_flag = FADUMP_REQUEST_FLAG;\r\nfdm->hpte_region.source_data_type = FADUMP_HPTE_REGION;\r\nfdm->hpte_region.source_address = 0;\r\nfdm->hpte_region.source_len = fw_dump.hpte_region_size;\r\nfdm->hpte_region.destination_address = addr;\r\naddr += fw_dump.hpte_region_size;\r\nfdm->rmr_region.request_flag = FADUMP_REQUEST_FLAG;\r\nfdm->rmr_region.source_data_type = FADUMP_REAL_MODE_REGION;\r\nfdm->rmr_region.source_address = RMA_START;\r\nfdm->rmr_region.source_len = fw_dump.boot_memory_size;\r\nfdm->rmr_region.destination_address = addr;\r\naddr += fw_dump.boot_memory_size;\r\nreturn addr;\r\n}\r\nstatic inline unsigned long fadump_calculate_reserve_size(void)\r\n{\r\nunsigned long size;\r\nif (fw_dump.reserve_bootvar)\r\nreturn fw_dump.reserve_bootvar;\r\nsize = memblock_end_of_DRAM() / 20;\r\nsize = size & ~0x0FFFFFFFUL;\r\nif (memory_limit && size > memory_limit)\r\nsize = memory_limit;\r\nreturn (size > MIN_BOOT_MEM ? size : MIN_BOOT_MEM);\r\n}\r\nstatic unsigned long get_fadump_area_size(void)\r\n{\r\nunsigned long size = 0;\r\nsize += fw_dump.cpu_state_data_size;\r\nsize += fw_dump.hpte_region_size;\r\nsize += fw_dump.boot_memory_size;\r\nsize += sizeof(struct fadump_crash_info_header);\r\nsize += sizeof(struct elfhdr);\r\nsize += sizeof(struct elf_phdr);\r\nsize += sizeof(struct elf_phdr) * (memblock_num_regions(memory) + 2);\r\nsize = PAGE_ALIGN(size);\r\nreturn size;\r\n}\r\nint __init fadump_reserve_mem(void)\r\n{\r\nunsigned long base, size, memory_boundary;\r\nif (!fw_dump.fadump_enabled)\r\nreturn 0;\r\nif (!fw_dump.fadump_supported) {\r\nprintk(KERN_INFO "Firmware-assisted dump is not supported on"\r\n" this hardware\n");\r\nfw_dump.fadump_enabled = 0;\r\nreturn 0;\r\n}\r\nif (fdm_active)\r\nfw_dump.boot_memory_size = fdm_active->rmr_region.source_len;\r\nelse\r\nfw_dump.boot_memory_size = fadump_calculate_reserve_size();\r\nif (memory_limit && memory_limit < memblock_end_of_DRAM()) {\r\nsize = get_fadump_area_size();\r\nif ((memory_limit + size) < memblock_end_of_DRAM())\r\nmemory_limit += size;\r\nelse\r\nmemory_limit = memblock_end_of_DRAM();\r\nprintk(KERN_INFO "Adjusted memory_limit for firmware-assisted"\r\n" dump, now %#016llx\n", memory_limit);\r\n}\r\nif (memory_limit)\r\nmemory_boundary = memory_limit;\r\nelse\r\nmemory_boundary = memblock_end_of_DRAM();\r\nif (fw_dump.dump_active) {\r\nprintk(KERN_INFO "Firmware-assisted dump is active.\n");\r\nbase = fw_dump.boot_memory_size;\r\nsize = memory_boundary - base;\r\nmemblock_reserve(base, size);\r\nprintk(KERN_INFO "Reserved %ldMB of memory at %ldMB "\r\n"for saving crash dump\n",\r\n(unsigned long)(size >> 20),\r\n(unsigned long)(base >> 20));\r\nfw_dump.fadumphdr_addr =\r\nfdm_active->rmr_region.destination_address +\r\nfdm_active->rmr_region.source_len;\r\npr_debug("fadumphdr_addr = %p\n",\r\n(void *) fw_dump.fadumphdr_addr);\r\n} else {\r\nsize = get_fadump_area_size();\r\nbase = memory_boundary - size;\r\nmemblock_reserve(base, size);\r\nprintk(KERN_INFO "Reserved %ldMB of memory at %ldMB "\r\n"for firmware-assisted dump\n",\r\n(unsigned long)(size >> 20),\r\n(unsigned long)(base >> 20));\r\n}\r\nfw_dump.reserve_dump_area_start = base;\r\nfw_dump.reserve_dump_area_size = size;\r\nreturn 1;\r\n}\r\nstatic int __init early_fadump_param(char *p)\r\n{\r\nif (!p)\r\nreturn 1;\r\nif (strncmp(p, "on", 2) == 0)\r\nfw_dump.fadump_enabled = 1;\r\nelse if (strncmp(p, "off", 3) == 0)\r\nfw_dump.fadump_enabled = 0;\r\nreturn 0;\r\n}\r\nstatic int __init early_fadump_reserve_mem(char *p)\r\n{\r\nif (p)\r\nfw_dump.reserve_bootvar = memparse(p, &p);\r\nreturn 0;\r\n}\r\nstatic void register_fw_dump(struct fadump_mem_struct *fdm)\r\n{\r\nint rc;\r\nunsigned int wait_time;\r\npr_debug("Registering for firmware-assisted kernel dump...\n");\r\ndo {\r\nrc = rtas_call(fw_dump.ibm_configure_kernel_dump, 3, 1, NULL,\r\nFADUMP_REGISTER, fdm,\r\nsizeof(struct fadump_mem_struct));\r\nwait_time = rtas_busy_delay_time(rc);\r\nif (wait_time)\r\nmdelay(wait_time);\r\n} while (wait_time);\r\nswitch (rc) {\r\ncase -1:\r\nprintk(KERN_ERR "Failed to register firmware-assisted kernel"\r\n" dump. Hardware Error(%d).\n", rc);\r\nbreak;\r\ncase -3:\r\nprintk(KERN_ERR "Failed to register firmware-assisted kernel"\r\n" dump. Parameter Error(%d).\n", rc);\r\nbreak;\r\ncase -9:\r\nprintk(KERN_ERR "firmware-assisted kernel dump is already "\r\n" registered.");\r\nfw_dump.dump_registered = 1;\r\nbreak;\r\ncase 0:\r\nprintk(KERN_INFO "firmware-assisted kernel dump registration"\r\n" is successful\n");\r\nfw_dump.dump_registered = 1;\r\nbreak;\r\n}\r\n}\r\nvoid crash_fadump(struct pt_regs *regs, const char *str)\r\n{\r\nstruct fadump_crash_info_header *fdh = NULL;\r\nif (!fw_dump.dump_registered || !fw_dump.fadumphdr_addr)\r\nreturn;\r\nfdh = __va(fw_dump.fadumphdr_addr);\r\ncrashing_cpu = smp_processor_id();\r\nfdh->crashing_cpu = crashing_cpu;\r\ncrash_save_vmcoreinfo();\r\nif (regs)\r\nfdh->regs = *regs;\r\nelse\r\nppc_save_regs(&fdh->regs);\r\nfdh->cpu_online_mask = *cpu_online_mask;\r\nrtas_os_term((char *)str);\r\n}\r\nstatic inline int fadump_gpr_index(u64 id)\r\n{\r\nint i = -1;\r\nchar str[3];\r\nif ((id & GPR_MASK) == REG_ID("GPR")) {\r\nid &= ~GPR_MASK;\r\nid >>= 24;\r\nstr[2] = '\0';\r\nstr[1] = id & 0xff;\r\nstr[0] = (id >> 8) & 0xff;\r\nsscanf(str, "%d", &i);\r\nif (i > 31)\r\ni = -1;\r\n}\r\nreturn i;\r\n}\r\nstatic inline void fadump_set_regval(struct pt_regs *regs, u64 reg_id,\r\nu64 reg_val)\r\n{\r\nint i;\r\ni = fadump_gpr_index(reg_id);\r\nif (i >= 0)\r\nregs->gpr[i] = (unsigned long)reg_val;\r\nelse if (reg_id == REG_ID("NIA"))\r\nregs->nip = (unsigned long)reg_val;\r\nelse if (reg_id == REG_ID("MSR"))\r\nregs->msr = (unsigned long)reg_val;\r\nelse if (reg_id == REG_ID("CTR"))\r\nregs->ctr = (unsigned long)reg_val;\r\nelse if (reg_id == REG_ID("LR"))\r\nregs->link = (unsigned long)reg_val;\r\nelse if (reg_id == REG_ID("XER"))\r\nregs->xer = (unsigned long)reg_val;\r\nelse if (reg_id == REG_ID("CR"))\r\nregs->ccr = (unsigned long)reg_val;\r\nelse if (reg_id == REG_ID("DAR"))\r\nregs->dar = (unsigned long)reg_val;\r\nelse if (reg_id == REG_ID("DSISR"))\r\nregs->dsisr = (unsigned long)reg_val;\r\n}\r\nstatic struct fadump_reg_entry*\r\nfadump_read_registers(struct fadump_reg_entry *reg_entry, struct pt_regs *regs)\r\n{\r\nmemset(regs, 0, sizeof(struct pt_regs));\r\nwhile (reg_entry->reg_id != REG_ID("CPUEND")) {\r\nfadump_set_regval(regs, reg_entry->reg_id,\r\nreg_entry->reg_value);\r\nreg_entry++;\r\n}\r\nreg_entry++;\r\nreturn reg_entry;\r\n}\r\nstatic u32 *fadump_append_elf_note(u32 *buf, char *name, unsigned type,\r\nvoid *data, size_t data_len)\r\n{\r\nstruct elf_note note;\r\nnote.n_namesz = strlen(name) + 1;\r\nnote.n_descsz = data_len;\r\nnote.n_type = type;\r\nmemcpy(buf, &note, sizeof(note));\r\nbuf += (sizeof(note) + 3)/4;\r\nmemcpy(buf, name, note.n_namesz);\r\nbuf += (note.n_namesz + 3)/4;\r\nmemcpy(buf, data, note.n_descsz);\r\nbuf += (note.n_descsz + 3)/4;\r\nreturn buf;\r\n}\r\nstatic void fadump_final_note(u32 *buf)\r\n{\r\nstruct elf_note note;\r\nnote.n_namesz = 0;\r\nnote.n_descsz = 0;\r\nnote.n_type = 0;\r\nmemcpy(buf, &note, sizeof(note));\r\n}\r\nstatic u32 *fadump_regs_to_elf_notes(u32 *buf, struct pt_regs *regs)\r\n{\r\nstruct elf_prstatus prstatus;\r\nmemset(&prstatus, 0, sizeof(prstatus));\r\nelf_core_copy_kernel_regs(&prstatus.pr_reg, regs);\r\nbuf = fadump_append_elf_note(buf, KEXEC_CORE_NOTE_NAME, NT_PRSTATUS,\r\n&prstatus, sizeof(prstatus));\r\nreturn buf;\r\n}\r\nstatic void fadump_update_elfcore_header(char *bufp)\r\n{\r\nstruct elfhdr *elf;\r\nstruct elf_phdr *phdr;\r\nelf = (struct elfhdr *)bufp;\r\nbufp += sizeof(struct elfhdr);\r\nphdr = (struct elf_phdr *)bufp;\r\nif (phdr->p_type == PT_NOTE) {\r\nphdr->p_paddr = fw_dump.cpu_notes_buf;\r\nphdr->p_offset = phdr->p_paddr;\r\nphdr->p_filesz = fw_dump.cpu_notes_buf_size;\r\nphdr->p_memsz = fw_dump.cpu_notes_buf_size;\r\n}\r\nreturn;\r\n}\r\nstatic void *fadump_cpu_notes_buf_alloc(unsigned long size)\r\n{\r\nvoid *vaddr;\r\nstruct page *page;\r\nunsigned long order, count, i;\r\norder = get_order(size);\r\nvaddr = (void *)__get_free_pages(GFP_KERNEL|__GFP_ZERO, order);\r\nif (!vaddr)\r\nreturn NULL;\r\ncount = 1 << order;\r\npage = virt_to_page(vaddr);\r\nfor (i = 0; i < count; i++)\r\nSetPageReserved(page + i);\r\nreturn vaddr;\r\n}\r\nstatic void fadump_cpu_notes_buf_free(unsigned long vaddr, unsigned long size)\r\n{\r\nstruct page *page;\r\nunsigned long order, count, i;\r\norder = get_order(size);\r\ncount = 1 << order;\r\npage = virt_to_page(vaddr);\r\nfor (i = 0; i < count; i++)\r\nClearPageReserved(page + i);\r\n__free_pages(page, order);\r\n}\r\nstatic int __init fadump_build_cpu_notes(const struct fadump_mem_struct *fdm)\r\n{\r\nstruct fadump_reg_save_area_header *reg_header;\r\nstruct fadump_reg_entry *reg_entry;\r\nstruct fadump_crash_info_header *fdh = NULL;\r\nvoid *vaddr;\r\nunsigned long addr;\r\nu32 num_cpus, *note_buf;\r\nstruct pt_regs regs;\r\nint i, rc = 0, cpu = 0;\r\nif (!fdm->cpu_state_data.bytes_dumped)\r\nreturn -EINVAL;\r\naddr = fdm->cpu_state_data.destination_address;\r\nvaddr = __va(addr);\r\nreg_header = vaddr;\r\nif (reg_header->magic_number != REGSAVE_AREA_MAGIC) {\r\nprintk(KERN_ERR "Unable to read register save area.\n");\r\nreturn -ENOENT;\r\n}\r\npr_debug("--------CPU State Data------------\n");\r\npr_debug("Magic Number: %llx\n", reg_header->magic_number);\r\npr_debug("NumCpuOffset: %x\n", reg_header->num_cpu_offset);\r\nvaddr += reg_header->num_cpu_offset;\r\nnum_cpus = *((u32 *)(vaddr));\r\npr_debug("NumCpus : %u\n", num_cpus);\r\nvaddr += sizeof(u32);\r\nreg_entry = (struct fadump_reg_entry *)vaddr;\r\nfw_dump.cpu_notes_buf_size = num_cpus * sizeof(note_buf_t);\r\nfw_dump.cpu_notes_buf_size = PAGE_ALIGN(fw_dump.cpu_notes_buf_size);\r\nnote_buf = fadump_cpu_notes_buf_alloc(fw_dump.cpu_notes_buf_size);\r\nif (!note_buf) {\r\nprintk(KERN_ERR "Failed to allocate 0x%lx bytes for "\r\n"cpu notes buffer\n", fw_dump.cpu_notes_buf_size);\r\nreturn -ENOMEM;\r\n}\r\nfw_dump.cpu_notes_buf = __pa(note_buf);\r\npr_debug("Allocated buffer for cpu notes of size %ld at %p\n",\r\n(num_cpus * sizeof(note_buf_t)), note_buf);\r\nif (fw_dump.fadumphdr_addr)\r\nfdh = __va(fw_dump.fadumphdr_addr);\r\nfor (i = 0; i < num_cpus; i++) {\r\nif (reg_entry->reg_id != REG_ID("CPUSTRT")) {\r\nprintk(KERN_ERR "Unable to read CPU state data\n");\r\nrc = -ENOENT;\r\ngoto error_out;\r\n}\r\ncpu = reg_entry->reg_value & FADUMP_CPU_ID_MASK;\r\nif (fdh && !cpumask_test_cpu(cpu, &fdh->cpu_online_mask)) {\r\nSKIP_TO_NEXT_CPU(reg_entry);\r\ncontinue;\r\n}\r\npr_debug("Reading register data for cpu %d...\n", cpu);\r\nif (fdh && fdh->crashing_cpu == cpu) {\r\nregs = fdh->regs;\r\nnote_buf = fadump_regs_to_elf_notes(note_buf, &regs);\r\nSKIP_TO_NEXT_CPU(reg_entry);\r\n} else {\r\nreg_entry++;\r\nreg_entry = fadump_read_registers(reg_entry, &regs);\r\nnote_buf = fadump_regs_to_elf_notes(note_buf, &regs);\r\n}\r\n}\r\nfadump_final_note(note_buf);\r\nif (fdh) {\r\npr_debug("Updating elfcore header (%llx) with cpu notes\n",\r\nfdh->elfcorehdr_addr);\r\nfadump_update_elfcore_header((char *)__va(fdh->elfcorehdr_addr));\r\n}\r\nreturn 0;\r\nerror_out:\r\nfadump_cpu_notes_buf_free((unsigned long)__va(fw_dump.cpu_notes_buf),\r\nfw_dump.cpu_notes_buf_size);\r\nfw_dump.cpu_notes_buf = 0;\r\nfw_dump.cpu_notes_buf_size = 0;\r\nreturn rc;\r\n}\r\nstatic int __init process_fadump(const struct fadump_mem_struct *fdm_active)\r\n{\r\nstruct fadump_crash_info_header *fdh;\r\nint rc = 0;\r\nif (!fdm_active || !fw_dump.fadumphdr_addr)\r\nreturn -EINVAL;\r\nif ((fdm_active->header.dump_status_flag == FADUMP_ERROR_FLAG) ||\r\n(fdm_active->cpu_state_data.error_flags != 0) ||\r\n(fdm_active->rmr_region.error_flags != 0)) {\r\nprintk(KERN_ERR "Dump taken by platform is not valid\n");\r\nreturn -EINVAL;\r\n}\r\nif ((fdm_active->rmr_region.bytes_dumped !=\r\nfdm_active->rmr_region.source_len) ||\r\n!fdm_active->cpu_state_data.bytes_dumped) {\r\nprintk(KERN_ERR "Dump taken by platform is incomplete\n");\r\nreturn -EINVAL;\r\n}\r\nfdh = __va(fw_dump.fadumphdr_addr);\r\nif (fdh->magic_number != FADUMP_CRASH_INFO_MAGIC) {\r\nprintk(KERN_ERR "Crash info header is not valid.\n");\r\nreturn -EINVAL;\r\n}\r\nrc = fadump_build_cpu_notes(fdm_active);\r\nif (rc)\r\nreturn rc;\r\nelfcorehdr_addr = fdh->elfcorehdr_addr;\r\nreturn 0;\r\n}\r\nstatic inline void fadump_add_crash_memory(unsigned long long base,\r\nunsigned long long end)\r\n{\r\nif (base == end)\r\nreturn;\r\npr_debug("crash_memory_range[%d] [%#016llx-%#016llx], %#llx bytes\n",\r\ncrash_mem_ranges, base, end - 1, (end - base));\r\ncrash_memory_ranges[crash_mem_ranges].base = base;\r\ncrash_memory_ranges[crash_mem_ranges].size = end - base;\r\ncrash_mem_ranges++;\r\n}\r\nstatic void fadump_exclude_reserved_area(unsigned long long start,\r\nunsigned long long end)\r\n{\r\nunsigned long long ra_start, ra_end;\r\nra_start = fw_dump.reserve_dump_area_start;\r\nra_end = ra_start + fw_dump.reserve_dump_area_size;\r\nif ((ra_start < end) && (ra_end > start)) {\r\nif ((start < ra_start) && (end > ra_end)) {\r\nfadump_add_crash_memory(start, ra_start);\r\nfadump_add_crash_memory(ra_end, end);\r\n} else if (start < ra_start) {\r\nfadump_add_crash_memory(start, ra_start);\r\n} else if (ra_end < end) {\r\nfadump_add_crash_memory(ra_end, end);\r\n}\r\n} else\r\nfadump_add_crash_memory(start, end);\r\n}\r\nstatic int fadump_init_elfcore_header(char *bufp)\r\n{\r\nstruct elfhdr *elf;\r\nelf = (struct elfhdr *) bufp;\r\nbufp += sizeof(struct elfhdr);\r\nmemcpy(elf->e_ident, ELFMAG, SELFMAG);\r\nelf->e_ident[EI_CLASS] = ELF_CLASS;\r\nelf->e_ident[EI_DATA] = ELF_DATA;\r\nelf->e_ident[EI_VERSION] = EV_CURRENT;\r\nelf->e_ident[EI_OSABI] = ELF_OSABI;\r\nmemset(elf->e_ident+EI_PAD, 0, EI_NIDENT-EI_PAD);\r\nelf->e_type = ET_CORE;\r\nelf->e_machine = ELF_ARCH;\r\nelf->e_version = EV_CURRENT;\r\nelf->e_entry = 0;\r\nelf->e_phoff = sizeof(struct elfhdr);\r\nelf->e_shoff = 0;\r\nelf->e_flags = ELF_CORE_EFLAGS;\r\nelf->e_ehsize = sizeof(struct elfhdr);\r\nelf->e_phentsize = sizeof(struct elf_phdr);\r\nelf->e_phnum = 0;\r\nelf->e_shentsize = 0;\r\nelf->e_shnum = 0;\r\nelf->e_shstrndx = 0;\r\nreturn 0;\r\n}\r\nstatic void fadump_setup_crash_memory_ranges(void)\r\n{\r\nstruct memblock_region *reg;\r\nunsigned long long start, end;\r\npr_debug("Setup crash memory ranges.\n");\r\ncrash_mem_ranges = 0;\r\nfadump_add_crash_memory(RMA_START, fw_dump.boot_memory_size);\r\nfor_each_memblock(memory, reg) {\r\nstart = (unsigned long long)reg->base;\r\nend = start + (unsigned long long)reg->size;\r\nif (start == RMA_START && end >= fw_dump.boot_memory_size)\r\nstart = fw_dump.boot_memory_size;\r\nfadump_exclude_reserved_area(start, end);\r\n}\r\n}\r\nstatic inline unsigned long fadump_relocate(unsigned long paddr)\r\n{\r\nif (paddr > RMA_START && paddr < fw_dump.boot_memory_size)\r\nreturn fdm.rmr_region.destination_address + paddr;\r\nelse\r\nreturn paddr;\r\n}\r\nstatic int fadump_create_elfcore_headers(char *bufp)\r\n{\r\nstruct elfhdr *elf;\r\nstruct elf_phdr *phdr;\r\nint i;\r\nfadump_init_elfcore_header(bufp);\r\nelf = (struct elfhdr *)bufp;\r\nbufp += sizeof(struct elfhdr);\r\nphdr = (struct elf_phdr *)bufp;\r\nbufp += sizeof(struct elf_phdr);\r\nphdr->p_type = PT_NOTE;\r\nphdr->p_flags = 0;\r\nphdr->p_vaddr = 0;\r\nphdr->p_align = 0;\r\nphdr->p_offset = 0;\r\nphdr->p_paddr = 0;\r\nphdr->p_filesz = 0;\r\nphdr->p_memsz = 0;\r\n(elf->e_phnum)++;\r\nphdr = (struct elf_phdr *)bufp;\r\nbufp += sizeof(struct elf_phdr);\r\nphdr->p_type = PT_NOTE;\r\nphdr->p_flags = 0;\r\nphdr->p_vaddr = 0;\r\nphdr->p_align = 0;\r\nphdr->p_paddr = fadump_relocate(paddr_vmcoreinfo_note());\r\nphdr->p_offset = phdr->p_paddr;\r\nphdr->p_memsz = vmcoreinfo_max_size;\r\nphdr->p_filesz = vmcoreinfo_max_size;\r\n(elf->e_phnum)++;\r\nfor (i = 0; i < crash_mem_ranges; i++) {\r\nunsigned long long mbase, msize;\r\nmbase = crash_memory_ranges[i].base;\r\nmsize = crash_memory_ranges[i].size;\r\nif (!msize)\r\ncontinue;\r\nphdr = (struct elf_phdr *)bufp;\r\nbufp += sizeof(struct elf_phdr);\r\nphdr->p_type = PT_LOAD;\r\nphdr->p_flags = PF_R|PF_W|PF_X;\r\nphdr->p_offset = mbase;\r\nif (mbase == RMA_START) {\r\nphdr->p_offset = fdm.rmr_region.destination_address;\r\n}\r\nphdr->p_paddr = mbase;\r\nphdr->p_vaddr = (unsigned long)__va(mbase);\r\nphdr->p_filesz = msize;\r\nphdr->p_memsz = msize;\r\nphdr->p_align = 0;\r\n(elf->e_phnum)++;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned long init_fadump_header(unsigned long addr)\r\n{\r\nstruct fadump_crash_info_header *fdh;\r\nif (!addr)\r\nreturn 0;\r\nfw_dump.fadumphdr_addr = addr;\r\nfdh = __va(addr);\r\naddr += sizeof(struct fadump_crash_info_header);\r\nmemset(fdh, 0, sizeof(struct fadump_crash_info_header));\r\nfdh->magic_number = FADUMP_CRASH_INFO_MAGIC;\r\nfdh->elfcorehdr_addr = addr;\r\nfdh->crashing_cpu = CPU_UNKNOWN;\r\nreturn addr;\r\n}\r\nstatic void register_fadump(void)\r\n{\r\nunsigned long addr;\r\nvoid *vaddr;\r\nif (!fw_dump.reserve_dump_area_size)\r\nreturn;\r\nfadump_setup_crash_memory_ranges();\r\naddr = fdm.rmr_region.destination_address + fdm.rmr_region.source_len;\r\naddr = init_fadump_header(addr);\r\nvaddr = __va(addr);\r\npr_debug("Creating ELF core headers at %#016lx\n", addr);\r\nfadump_create_elfcore_headers(vaddr);\r\nregister_fw_dump(&fdm);\r\n}\r\nstatic int fadump_unregister_dump(struct fadump_mem_struct *fdm)\r\n{\r\nint rc = 0;\r\nunsigned int wait_time;\r\npr_debug("Un-register firmware-assisted dump\n");\r\ndo {\r\nrc = rtas_call(fw_dump.ibm_configure_kernel_dump, 3, 1, NULL,\r\nFADUMP_UNREGISTER, fdm,\r\nsizeof(struct fadump_mem_struct));\r\nwait_time = rtas_busy_delay_time(rc);\r\nif (wait_time)\r\nmdelay(wait_time);\r\n} while (wait_time);\r\nif (rc) {\r\nprintk(KERN_ERR "Failed to un-register firmware-assisted dump."\r\n" unexpected error(%d).\n", rc);\r\nreturn rc;\r\n}\r\nfw_dump.dump_registered = 0;\r\nreturn 0;\r\n}\r\nstatic int fadump_invalidate_dump(struct fadump_mem_struct *fdm)\r\n{\r\nint rc = 0;\r\nunsigned int wait_time;\r\npr_debug("Invalidating firmware-assisted dump registration\n");\r\ndo {\r\nrc = rtas_call(fw_dump.ibm_configure_kernel_dump, 3, 1, NULL,\r\nFADUMP_INVALIDATE, fdm,\r\nsizeof(struct fadump_mem_struct));\r\nwait_time = rtas_busy_delay_time(rc);\r\nif (wait_time)\r\nmdelay(wait_time);\r\n} while (wait_time);\r\nif (rc) {\r\nprintk(KERN_ERR "Failed to invalidate firmware-assisted dump "\r\n"rgistration. unexpected error(%d).\n", rc);\r\nreturn rc;\r\n}\r\nfw_dump.dump_active = 0;\r\nfdm_active = NULL;\r\nreturn 0;\r\n}\r\nvoid fadump_cleanup(void)\r\n{\r\nif (fw_dump.dump_active) {\r\ninit_fadump_mem_struct(&fdm,\r\nfdm_active->cpu_state_data.destination_address);\r\nfadump_invalidate_dump(&fdm);\r\n}\r\n}\r\nstatic void fadump_release_memory(unsigned long begin, unsigned long end)\r\n{\r\nunsigned long addr;\r\nunsigned long ra_start, ra_end;\r\nra_start = fw_dump.reserve_dump_area_start;\r\nra_end = ra_start + fw_dump.reserve_dump_area_size;\r\nfor (addr = begin; addr < end; addr += PAGE_SIZE) {\r\nif (addr <= ra_end && ((addr + PAGE_SIZE) > ra_start))\r\ncontinue;\r\nfree_reserved_page(pfn_to_page(addr >> PAGE_SHIFT));\r\n}\r\n}\r\nstatic void fadump_invalidate_release_mem(void)\r\n{\r\nunsigned long reserved_area_start, reserved_area_end;\r\nunsigned long destination_address;\r\nmutex_lock(&fadump_mutex);\r\nif (!fw_dump.dump_active) {\r\nmutex_unlock(&fadump_mutex);\r\nreturn;\r\n}\r\ndestination_address = fdm_active->cpu_state_data.destination_address;\r\nfadump_cleanup();\r\nmutex_unlock(&fadump_mutex);\r\nreserved_area_start = fw_dump.reserve_dump_area_start;\r\nreserved_area_end = reserved_area_start +\r\nfw_dump.reserve_dump_area_size;\r\nfw_dump.reserve_dump_area_start = destination_address;\r\nfw_dump.reserve_dump_area_size = get_fadump_area_size();\r\nfadump_release_memory(reserved_area_start, reserved_area_end);\r\nif (fw_dump.cpu_notes_buf) {\r\nfadump_cpu_notes_buf_free(\r\n(unsigned long)__va(fw_dump.cpu_notes_buf),\r\nfw_dump.cpu_notes_buf_size);\r\nfw_dump.cpu_notes_buf = 0;\r\nfw_dump.cpu_notes_buf_size = 0;\r\n}\r\ninit_fadump_mem_struct(&fdm, fw_dump.reserve_dump_area_start);\r\n}\r\nstatic ssize_t fadump_release_memory_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nif (!fw_dump.dump_active)\r\nreturn -EPERM;\r\nif (buf[0] == '1') {\r\nvmcore_cleanup();\r\nfadump_invalidate_release_mem();\r\n} else\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic ssize_t fadump_enabled_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", fw_dump.fadump_enabled);\r\n}\r\nstatic ssize_t fadump_register_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", fw_dump.dump_registered);\r\n}\r\nstatic ssize_t fadump_register_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret = 0;\r\nif (!fw_dump.fadump_enabled || fdm_active)\r\nreturn -EPERM;\r\nmutex_lock(&fadump_mutex);\r\nswitch (buf[0]) {\r\ncase '0':\r\nif (fw_dump.dump_registered == 0) {\r\nret = -EINVAL;\r\ngoto unlock_out;\r\n}\r\nfadump_unregister_dump(&fdm);\r\nbreak;\r\ncase '1':\r\nif (fw_dump.dump_registered == 1) {\r\nret = -EINVAL;\r\ngoto unlock_out;\r\n}\r\nregister_fadump();\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nunlock_out:\r\nmutex_unlock(&fadump_mutex);\r\nreturn ret < 0 ? ret : count;\r\n}\r\nstatic int fadump_region_show(struct seq_file *m, void *private)\r\n{\r\nconst struct fadump_mem_struct *fdm_ptr;\r\nif (!fw_dump.fadump_enabled)\r\nreturn 0;\r\nmutex_lock(&fadump_mutex);\r\nif (fdm_active)\r\nfdm_ptr = fdm_active;\r\nelse {\r\nmutex_unlock(&fadump_mutex);\r\nfdm_ptr = &fdm;\r\n}\r\nseq_printf(m,\r\n"CPU : [%#016llx-%#016llx] %#llx bytes, "\r\n"Dumped: %#llx\n",\r\nfdm_ptr->cpu_state_data.destination_address,\r\nfdm_ptr->cpu_state_data.destination_address +\r\nfdm_ptr->cpu_state_data.source_len - 1,\r\nfdm_ptr->cpu_state_data.source_len,\r\nfdm_ptr->cpu_state_data.bytes_dumped);\r\nseq_printf(m,\r\n"HPTE: [%#016llx-%#016llx] %#llx bytes, "\r\n"Dumped: %#llx\n",\r\nfdm_ptr->hpte_region.destination_address,\r\nfdm_ptr->hpte_region.destination_address +\r\nfdm_ptr->hpte_region.source_len - 1,\r\nfdm_ptr->hpte_region.source_len,\r\nfdm_ptr->hpte_region.bytes_dumped);\r\nseq_printf(m,\r\n"DUMP: [%#016llx-%#016llx] %#llx bytes, "\r\n"Dumped: %#llx\n",\r\nfdm_ptr->rmr_region.destination_address,\r\nfdm_ptr->rmr_region.destination_address +\r\nfdm_ptr->rmr_region.source_len - 1,\r\nfdm_ptr->rmr_region.source_len,\r\nfdm_ptr->rmr_region.bytes_dumped);\r\nif (!fdm_active ||\r\n(fw_dump.reserve_dump_area_start ==\r\nfdm_ptr->cpu_state_data.destination_address))\r\ngoto out;\r\nseq_printf(m,\r\n" : [%#016llx-%#016llx] %#llx bytes, "\r\n"Dumped: %#llx\n",\r\n(unsigned long long)fw_dump.reserve_dump_area_start,\r\nfdm_ptr->cpu_state_data.destination_address - 1,\r\nfdm_ptr->cpu_state_data.destination_address -\r\nfw_dump.reserve_dump_area_start,\r\nfdm_ptr->cpu_state_data.destination_address -\r\nfw_dump.reserve_dump_area_start);\r\nout:\r\nif (fdm_active)\r\nmutex_unlock(&fadump_mutex);\r\nreturn 0;\r\n}\r\nstatic int fadump_region_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, fadump_region_show, inode->i_private);\r\n}\r\nstatic void fadump_init_files(void)\r\n{\r\nstruct dentry *debugfs_file;\r\nint rc = 0;\r\nrc = sysfs_create_file(kernel_kobj, &fadump_attr.attr);\r\nif (rc)\r\nprintk(KERN_ERR "fadump: unable to create sysfs file"\r\n" fadump_enabled (%d)\n", rc);\r\nrc = sysfs_create_file(kernel_kobj, &fadump_register_attr.attr);\r\nif (rc)\r\nprintk(KERN_ERR "fadump: unable to create sysfs file"\r\n" fadump_registered (%d)\n", rc);\r\ndebugfs_file = debugfs_create_file("fadump_region", 0444,\r\npowerpc_debugfs_root, NULL,\r\n&fadump_region_fops);\r\nif (!debugfs_file)\r\nprintk(KERN_ERR "fadump: unable to create debugfs file"\r\n" fadump_region\n");\r\nif (fw_dump.dump_active) {\r\nrc = sysfs_create_file(kernel_kobj, &fadump_release_attr.attr);\r\nif (rc)\r\nprintk(KERN_ERR "fadump: unable to create sysfs file"\r\n" fadump_release_mem (%d)\n", rc);\r\n}\r\nreturn;\r\n}\r\nint __init setup_fadump(void)\r\n{\r\nif (!fw_dump.fadump_enabled)\r\nreturn 0;\r\nif (!fw_dump.fadump_supported) {\r\nprintk(KERN_ERR "Firmware-assisted dump is not supported on"\r\n" this hardware\n");\r\nreturn 0;\r\n}\r\nfadump_show_config();\r\nif (fw_dump.dump_active) {\r\nif (process_fadump(fdm_active) < 0)\r\nfadump_invalidate_release_mem();\r\n}\r\nelse if (fw_dump.reserve_dump_area_size)\r\ninit_fadump_mem_struct(&fdm, fw_dump.reserve_dump_area_start);\r\nfadump_init_files();\r\nreturn 1;\r\n}
