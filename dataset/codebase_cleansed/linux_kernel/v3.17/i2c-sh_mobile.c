static void iic_wr(struct sh_mobile_i2c_data *pd, int offs, unsigned char data)\r\n{\r\nif (offs == ICIC)\r\ndata |= pd->icic;\r\niowrite8(data, pd->reg + offs);\r\n}\r\nstatic unsigned char iic_rd(struct sh_mobile_i2c_data *pd, int offs)\r\n{\r\nreturn ioread8(pd->reg + offs);\r\n}\r\nstatic void iic_set_clr(struct sh_mobile_i2c_data *pd, int offs,\r\nunsigned char set, unsigned char clr)\r\n{\r\niic_wr(pd, offs, (iic_rd(pd, offs) | set) & ~clr);\r\n}\r\nstatic u32 sh_mobile_i2c_iccl(unsigned long count_khz, u32 tLOW, u32 tf)\r\n{\r\nreturn (((count_khz * (tLOW + tf)) + 5000) / 10000);\r\n}\r\nstatic u32 sh_mobile_i2c_icch(unsigned long count_khz, u32 tHIGH, u32 tf)\r\n{\r\nreturn (((count_khz * (tHIGH + tf)) + 5000) / 10000);\r\n}\r\nstatic int sh_mobile_i2c_init(struct sh_mobile_i2c_data *pd)\r\n{\r\nunsigned long i2c_clk_khz;\r\nu32 tHIGH, tLOW, tf;\r\nuint16_t max_val;\r\nclk_prepare_enable(pd->clk);\r\ni2c_clk_khz = clk_get_rate(pd->clk) / 1000;\r\nclk_disable_unprepare(pd->clk);\r\ni2c_clk_khz /= pd->clks_per_count;\r\nif (pd->bus_speed == STANDARD_MODE) {\r\ntLOW = 47;\r\ntHIGH = 40;\r\ntf = 3;\r\n} else if (pd->bus_speed == FAST_MODE) {\r\ntLOW = 13;\r\ntHIGH = 6;\r\ntf = 3;\r\n} else {\r\ndev_err(pd->dev, "unrecognized bus speed %lu Hz\n",\r\npd->bus_speed);\r\nreturn -EINVAL;\r\n}\r\npd->iccl = sh_mobile_i2c_iccl(i2c_clk_khz, tLOW, tf);\r\npd->icch = sh_mobile_i2c_icch(i2c_clk_khz, tHIGH, tf);\r\nmax_val = pd->flags & IIC_FLAG_HAS_ICIC67 ? 0x1ff : 0xff;\r\nif (pd->iccl > max_val || pd->icch > max_val) {\r\ndev_err(pd->dev, "timing values out of range: L/H=0x%x/0x%x\n",\r\npd->iccl, pd->icch);\r\nreturn -EINVAL;\r\n}\r\nif (pd->iccl & 0x100)\r\npd->icic |= ICIC_ICCLB8;\r\nelse\r\npd->icic &= ~ICIC_ICCLB8;\r\nif (pd->icch & 0x100)\r\npd->icic |= ICIC_ICCHB8;\r\nelse\r\npd->icic &= ~ICIC_ICCHB8;\r\nreturn 0;\r\n}\r\nstatic void activate_ch(struct sh_mobile_i2c_data *pd)\r\n{\r\npm_runtime_get_sync(pd->dev);\r\nclk_prepare_enable(pd->clk);\r\niic_set_clr(pd, ICCR, ICCR_ICE, 0);\r\niic_wr(pd, ICIC, 0);\r\niic_wr(pd, ICCL, pd->iccl & 0xff);\r\niic_wr(pd, ICCH, pd->icch & 0xff);\r\n}\r\nstatic void deactivate_ch(struct sh_mobile_i2c_data *pd)\r\n{\r\niic_wr(pd, ICSR, 0);\r\niic_wr(pd, ICIC, 0);\r\niic_set_clr(pd, ICCR, 0, ICCR_ICE);\r\nclk_disable_unprepare(pd->clk);\r\npm_runtime_put_sync(pd->dev);\r\n}\r\nstatic unsigned char i2c_op(struct sh_mobile_i2c_data *pd,\r\nenum sh_mobile_i2c_op op, unsigned char data)\r\n{\r\nunsigned char ret = 0;\r\nunsigned long flags;\r\ndev_dbg(pd->dev, "op %d, data in 0x%02x\n", op, data);\r\nspin_lock_irqsave(&pd->lock, flags);\r\nswitch (op) {\r\ncase OP_START:\r\niic_wr(pd, ICCR, ICCR_ICE | ICCR_TRS | ICCR_BBSY);\r\nbreak;\r\ncase OP_TX_FIRST:\r\niic_wr(pd, ICIC, ICIC_WAITE | ICIC_ALE | ICIC_TACKE);\r\niic_wr(pd, ICDR, data);\r\nbreak;\r\ncase OP_TX:\r\niic_wr(pd, ICDR, data);\r\nbreak;\r\ncase OP_TX_STOP:\r\niic_wr(pd, ICDR, data);\r\niic_wr(pd, ICCR, pd->send_stop ? ICCR_ICE | ICCR_TRS\r\n: ICCR_ICE | ICCR_TRS | ICCR_BBSY);\r\nbreak;\r\ncase OP_TX_TO_RX:\r\niic_wr(pd, ICCR, ICCR_ICE | ICCR_SCP);\r\nbreak;\r\ncase OP_RX:\r\nret = iic_rd(pd, ICDR);\r\nbreak;\r\ncase OP_RX_STOP:\r\niic_wr(pd, ICIC,\r\nICIC_DTEE | ICIC_WAITE | ICIC_ALE | ICIC_TACKE);\r\niic_wr(pd, ICCR, ICCR_ICE | ICCR_RACK);\r\nbreak;\r\ncase OP_RX_STOP_DATA:\r\niic_wr(pd, ICIC,\r\nICIC_DTEE | ICIC_WAITE | ICIC_ALE | ICIC_TACKE);\r\nret = iic_rd(pd, ICDR);\r\niic_wr(pd, ICCR, ICCR_ICE | ICCR_RACK);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&pd->lock, flags);\r\ndev_dbg(pd->dev, "op %d, data out 0x%02x\n", op, ret);\r\nreturn ret;\r\n}\r\nstatic bool sh_mobile_i2c_is_first_byte(struct sh_mobile_i2c_data *pd)\r\n{\r\nreturn pd->pos == -1;\r\n}\r\nstatic bool sh_mobile_i2c_is_last_byte(struct sh_mobile_i2c_data *pd)\r\n{\r\nreturn pd->pos == pd->msg->len - 1;\r\n}\r\nstatic void sh_mobile_i2c_get_data(struct sh_mobile_i2c_data *pd,\r\nunsigned char *buf)\r\n{\r\nswitch (pd->pos) {\r\ncase -1:\r\n*buf = (pd->msg->addr & 0x7f) << 1;\r\n*buf |= (pd->msg->flags & I2C_M_RD) ? 1 : 0;\r\nbreak;\r\ndefault:\r\n*buf = pd->msg->buf[pd->pos];\r\n}\r\n}\r\nstatic int sh_mobile_i2c_isr_tx(struct sh_mobile_i2c_data *pd)\r\n{\r\nunsigned char data;\r\nif (pd->pos == pd->msg->len)\r\nreturn 1;\r\nsh_mobile_i2c_get_data(pd, &data);\r\nif (sh_mobile_i2c_is_last_byte(pd))\r\ni2c_op(pd, OP_TX_STOP, data);\r\nelse if (sh_mobile_i2c_is_first_byte(pd))\r\ni2c_op(pd, OP_TX_FIRST, data);\r\nelse\r\ni2c_op(pd, OP_TX, data);\r\npd->pos++;\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_i2c_isr_rx(struct sh_mobile_i2c_data *pd)\r\n{\r\nunsigned char data;\r\nint real_pos;\r\ndo {\r\nif (pd->pos <= -1) {\r\nsh_mobile_i2c_get_data(pd, &data);\r\nif (sh_mobile_i2c_is_first_byte(pd))\r\ni2c_op(pd, OP_TX_FIRST, data);\r\nelse\r\ni2c_op(pd, OP_TX, data);\r\nbreak;\r\n}\r\nif (pd->pos == 0) {\r\ni2c_op(pd, OP_TX_TO_RX, 0);\r\nbreak;\r\n}\r\nreal_pos = pd->pos - 2;\r\nif (pd->pos == pd->msg->len) {\r\nif (real_pos < 0) {\r\ni2c_op(pd, OP_RX_STOP, 0);\r\nbreak;\r\n}\r\ndata = i2c_op(pd, OP_RX_STOP_DATA, 0);\r\n} else\r\ndata = i2c_op(pd, OP_RX, 0);\r\nif (real_pos >= 0)\r\npd->msg->buf[real_pos] = data;\r\n} while (0);\r\npd->pos++;\r\nreturn pd->pos == (pd->msg->len + 2);\r\n}\r\nstatic irqreturn_t sh_mobile_i2c_isr(int irq, void *dev_id)\r\n{\r\nstruct platform_device *dev = dev_id;\r\nstruct sh_mobile_i2c_data *pd = platform_get_drvdata(dev);\r\nunsigned char sr;\r\nint wakeup;\r\nsr = iic_rd(pd, ICSR);\r\npd->sr |= sr;\r\ndev_dbg(pd->dev, "i2c_isr 0x%02x 0x%02x %s %d %d!\n", sr, pd->sr,\r\n(pd->msg->flags & I2C_M_RD) ? "read" : "write",\r\npd->pos, pd->msg->len);\r\nif (sr & (ICSR_AL | ICSR_TACK)) {\r\niic_wr(pd, ICSR, sr & ~(ICSR_AL | ICSR_TACK));\r\nwakeup = 0;\r\n} else if (pd->msg->flags & I2C_M_RD)\r\nwakeup = sh_mobile_i2c_isr_rx(pd);\r\nelse\r\nwakeup = sh_mobile_i2c_isr_tx(pd);\r\nif (sr & ICSR_WAIT)\r\niic_wr(pd, ICSR, sr & ~ICSR_WAIT);\r\nif (wakeup) {\r\npd->sr |= SW_DONE;\r\nwake_up(&pd->wait);\r\n}\r\niic_rd(pd, ICSR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int start_ch(struct sh_mobile_i2c_data *pd, struct i2c_msg *usr_msg,\r\nbool do_init)\r\n{\r\nif (usr_msg->len == 0 && (usr_msg->flags & I2C_M_RD)) {\r\ndev_err(pd->dev, "Unsupported zero length i2c read\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (do_init) {\r\niic_set_clr(pd, ICCR, 0, ICCR_ICE);\r\niic_set_clr(pd, ICCR, ICCR_ICE, 0);\r\niic_wr(pd, ICCL, pd->iccl & 0xff);\r\niic_wr(pd, ICCH, pd->icch & 0xff);\r\n}\r\npd->msg = usr_msg;\r\npd->pos = -1;\r\npd->sr = 0;\r\niic_wr(pd, ICIC, ICIC_DTEE | ICIC_WAITE | ICIC_ALE | ICIC_TACKE);\r\nreturn 0;\r\n}\r\nstatic int poll_dte(struct sh_mobile_i2c_data *pd)\r\n{\r\nint i;\r\nfor (i = 1000; i; i--) {\r\nu_int8_t val = iic_rd(pd, ICSR);\r\nif (val & ICSR_DTE)\r\nbreak;\r\nif (val & ICSR_TACK)\r\nreturn -ENXIO;\r\nudelay(10);\r\n}\r\nreturn i ? 0 : -ETIMEDOUT;\r\n}\r\nstatic int poll_busy(struct sh_mobile_i2c_data *pd)\r\n{\r\nint i;\r\nfor (i = 1000; i; i--) {\r\nu_int8_t val = iic_rd(pd, ICSR);\r\ndev_dbg(pd->dev, "val 0x%02x pd->sr 0x%02x\n", val, pd->sr);\r\nif (!(val & ICSR_BUSY)) {\r\nval |= pd->sr;\r\nif (val & ICSR_TACK)\r\nreturn -ENXIO;\r\nif (val & ICSR_AL)\r\nreturn -EAGAIN;\r\nbreak;\r\n}\r\nudelay(10);\r\n}\r\nreturn i ? 0 : -ETIMEDOUT;\r\n}\r\nstatic int sh_mobile_i2c_xfer(struct i2c_adapter *adapter,\r\nstruct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct sh_mobile_i2c_data *pd = i2c_get_adapdata(adapter);\r\nstruct i2c_msg *msg;\r\nint err = 0;\r\nint i, k;\r\nactivate_ch(pd);\r\nfor (i = 0; i < num; i++) {\r\nbool do_start = pd->send_stop || !i;\r\nmsg = &msgs[i];\r\npd->send_stop = i == num - 1 || msg->flags & I2C_M_STOP;\r\nerr = start_ch(pd, msg, do_start);\r\nif (err)\r\nbreak;\r\nif (do_start)\r\ni2c_op(pd, OP_START, 0);\r\nk = wait_event_timeout(pd->wait,\r\npd->sr & (ICSR_TACK | SW_DONE),\r\n5 * HZ);\r\nif (!k) {\r\ndev_err(pd->dev, "Transfer request timed out\n");\r\nerr = -ETIMEDOUT;\r\nbreak;\r\n}\r\nif (pd->send_stop)\r\nerr = poll_busy(pd);\r\nelse\r\nerr = poll_dte(pd);\r\nif (err < 0)\r\nbreak;\r\n}\r\ndeactivate_ch(pd);\r\nif (!err)\r\nerr = num;\r\nreturn err;\r\n}\r\nstatic u32 sh_mobile_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_PROTOCOL_MANGLING;\r\n}\r\nstatic int sh_mobile_i2c_hook_irqs(struct platform_device *dev)\r\n{\r\nstruct resource *res;\r\nresource_size_t n;\r\nint k = 0, ret;\r\nwhile ((res = platform_get_resource(dev, IORESOURCE_IRQ, k))) {\r\nfor (n = res->start; n <= res->end; n++) {\r\nret = devm_request_irq(&dev->dev, n, sh_mobile_i2c_isr,\r\n0, dev_name(&dev->dev), dev);\r\nif (ret) {\r\ndev_err(&dev->dev, "cannot request IRQ %pa\n", &n);\r\nreturn ret;\r\n}\r\n}\r\nk++;\r\n}\r\nreturn k > 0 ? 0 : -ENOENT;\r\n}\r\nstatic int sh_mobile_i2c_probe(struct platform_device *dev)\r\n{\r\nstruct i2c_sh_mobile_platform_data *pdata = dev_get_platdata(&dev->dev);\r\nstruct sh_mobile_i2c_data *pd;\r\nstruct i2c_adapter *adap;\r\nstruct resource *res;\r\nint ret;\r\nu32 bus_speed;\r\npd = devm_kzalloc(&dev->dev, sizeof(struct sh_mobile_i2c_data), GFP_KERNEL);\r\nif (!pd)\r\nreturn -ENOMEM;\r\npd->clk = devm_clk_get(&dev->dev, NULL);\r\nif (IS_ERR(pd->clk)) {\r\ndev_err(&dev->dev, "cannot get clock\n");\r\nreturn PTR_ERR(pd->clk);\r\n}\r\nret = sh_mobile_i2c_hook_irqs(dev);\r\nif (ret)\r\nreturn ret;\r\npd->dev = &dev->dev;\r\nplatform_set_drvdata(dev, pd);\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\npd->reg = devm_ioremap_resource(&dev->dev, res);\r\nif (IS_ERR(pd->reg))\r\nreturn PTR_ERR(pd->reg);\r\nret = of_property_read_u32(dev->dev.of_node, "clock-frequency", &bus_speed);\r\npd->bus_speed = ret ? STANDARD_MODE : bus_speed;\r\npd->clks_per_count = 1;\r\nif (dev->dev.of_node) {\r\nconst struct of_device_id *match;\r\nmatch = of_match_device(sh_mobile_i2c_dt_ids, &dev->dev);\r\nif (match) {\r\nconst struct sh_mobile_dt_config *config;\r\nconfig = match->data;\r\npd->clks_per_count = config->clks_per_count;\r\n}\r\n} else {\r\nif (pdata && pdata->bus_speed)\r\npd->bus_speed = pdata->bus_speed;\r\nif (pdata && pdata->clks_per_count)\r\npd->clks_per_count = pdata->clks_per_count;\r\n}\r\nif (resource_size(res) > 0x17)\r\npd->flags |= IIC_FLAG_HAS_ICIC67;\r\nret = sh_mobile_i2c_init(pd);\r\nif (ret)\r\nreturn ret;\r\npm_suspend_ignore_children(&dev->dev, true);\r\npm_runtime_enable(&dev->dev);\r\nadap = &pd->adap;\r\ni2c_set_adapdata(adap, pd);\r\nadap->owner = THIS_MODULE;\r\nadap->algo = &sh_mobile_i2c_algorithm;\r\nadap->dev.parent = &dev->dev;\r\nadap->retries = 5;\r\nadap->nr = dev->id;\r\nadap->dev.of_node = dev->dev.of_node;\r\nstrlcpy(adap->name, dev->name, sizeof(adap->name));\r\nspin_lock_init(&pd->lock);\r\ninit_waitqueue_head(&pd->wait);\r\nret = i2c_add_numbered_adapter(adap);\r\nif (ret < 0) {\r\ndev_err(&dev->dev, "cannot add numbered adapter\n");\r\nreturn ret;\r\n}\r\ndev_info(&dev->dev,\r\n"I2C adapter %d with bus speed %lu Hz (L/H=0x%x/0x%x)\n",\r\nadap->nr, pd->bus_speed, pd->iccl, pd->icch);\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_i2c_remove(struct platform_device *dev)\r\n{\r\nstruct sh_mobile_i2c_data *pd = platform_get_drvdata(dev);\r\ni2c_del_adapter(&pd->adap);\r\npm_runtime_disable(&dev->dev);\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_i2c_runtime_nop(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init sh_mobile_i2c_adap_init(void)\r\n{\r\nreturn platform_driver_register(&sh_mobile_i2c_driver);\r\n}\r\nstatic void __exit sh_mobile_i2c_adap_exit(void)\r\n{\r\nplatform_driver_unregister(&sh_mobile_i2c_driver);\r\n}
