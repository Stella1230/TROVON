static u32 vm_get_features(struct virtio_device *vdev)\r\n{\r\nstruct virtio_mmio_device *vm_dev = to_virtio_mmio_device(vdev);\r\nwritel(0, vm_dev->base + VIRTIO_MMIO_HOST_FEATURES_SEL);\r\nreturn readl(vm_dev->base + VIRTIO_MMIO_HOST_FEATURES);\r\n}\r\nstatic void vm_finalize_features(struct virtio_device *vdev)\r\n{\r\nstruct virtio_mmio_device *vm_dev = to_virtio_mmio_device(vdev);\r\nint i;\r\nvring_transport_features(vdev);\r\nfor (i = 0; i < ARRAY_SIZE(vdev->features); i++) {\r\nwritel(i, vm_dev->base + VIRTIO_MMIO_GUEST_FEATURES_SEL);\r\nwritel(vdev->features[i],\r\nvm_dev->base + VIRTIO_MMIO_GUEST_FEATURES);\r\n}\r\n}\r\nstatic void vm_get(struct virtio_device *vdev, unsigned offset,\r\nvoid *buf, unsigned len)\r\n{\r\nstruct virtio_mmio_device *vm_dev = to_virtio_mmio_device(vdev);\r\nu8 *ptr = buf;\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nptr[i] = readb(vm_dev->base + VIRTIO_MMIO_CONFIG + offset + i);\r\n}\r\nstatic void vm_set(struct virtio_device *vdev, unsigned offset,\r\nconst void *buf, unsigned len)\r\n{\r\nstruct virtio_mmio_device *vm_dev = to_virtio_mmio_device(vdev);\r\nconst u8 *ptr = buf;\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nwriteb(ptr[i], vm_dev->base + VIRTIO_MMIO_CONFIG + offset + i);\r\n}\r\nstatic u8 vm_get_status(struct virtio_device *vdev)\r\n{\r\nstruct virtio_mmio_device *vm_dev = to_virtio_mmio_device(vdev);\r\nreturn readl(vm_dev->base + VIRTIO_MMIO_STATUS) & 0xff;\r\n}\r\nstatic void vm_set_status(struct virtio_device *vdev, u8 status)\r\n{\r\nstruct virtio_mmio_device *vm_dev = to_virtio_mmio_device(vdev);\r\nBUG_ON(status == 0);\r\nwritel(status, vm_dev->base + VIRTIO_MMIO_STATUS);\r\n}\r\nstatic void vm_reset(struct virtio_device *vdev)\r\n{\r\nstruct virtio_mmio_device *vm_dev = to_virtio_mmio_device(vdev);\r\nwritel(0, vm_dev->base + VIRTIO_MMIO_STATUS);\r\n}\r\nstatic bool vm_notify(struct virtqueue *vq)\r\n{\r\nstruct virtio_mmio_device *vm_dev = to_virtio_mmio_device(vq->vdev);\r\nwritel(vq->index, vm_dev->base + VIRTIO_MMIO_QUEUE_NOTIFY);\r\nreturn true;\r\n}\r\nstatic irqreturn_t vm_interrupt(int irq, void *opaque)\r\n{\r\nstruct virtio_mmio_device *vm_dev = opaque;\r\nstruct virtio_mmio_vq_info *info;\r\nstruct virtio_driver *vdrv = container_of(vm_dev->vdev.dev.driver,\r\nstruct virtio_driver, driver);\r\nunsigned long status;\r\nunsigned long flags;\r\nirqreturn_t ret = IRQ_NONE;\r\nstatus = readl(vm_dev->base + VIRTIO_MMIO_INTERRUPT_STATUS);\r\nwritel(status, vm_dev->base + VIRTIO_MMIO_INTERRUPT_ACK);\r\nif (unlikely(status & VIRTIO_MMIO_INT_CONFIG)\r\n&& vdrv && vdrv->config_changed) {\r\nvdrv->config_changed(&vm_dev->vdev);\r\nret = IRQ_HANDLED;\r\n}\r\nif (likely(status & VIRTIO_MMIO_INT_VRING)) {\r\nspin_lock_irqsave(&vm_dev->lock, flags);\r\nlist_for_each_entry(info, &vm_dev->virtqueues, node)\r\nret |= vring_interrupt(irq, info->vq);\r\nspin_unlock_irqrestore(&vm_dev->lock, flags);\r\n}\r\nreturn ret;\r\n}\r\nstatic void vm_del_vq(struct virtqueue *vq)\r\n{\r\nstruct virtio_mmio_device *vm_dev = to_virtio_mmio_device(vq->vdev);\r\nstruct virtio_mmio_vq_info *info = vq->priv;\r\nunsigned long flags, size;\r\nunsigned int index = vq->index;\r\nspin_lock_irqsave(&vm_dev->lock, flags);\r\nlist_del(&info->node);\r\nspin_unlock_irqrestore(&vm_dev->lock, flags);\r\nvring_del_virtqueue(vq);\r\nwritel(index, vm_dev->base + VIRTIO_MMIO_QUEUE_SEL);\r\nwritel(0, vm_dev->base + VIRTIO_MMIO_QUEUE_PFN);\r\nsize = PAGE_ALIGN(vring_size(info->num, VIRTIO_MMIO_VRING_ALIGN));\r\nfree_pages_exact(info->queue, size);\r\nkfree(info);\r\n}\r\nstatic void vm_del_vqs(struct virtio_device *vdev)\r\n{\r\nstruct virtio_mmio_device *vm_dev = to_virtio_mmio_device(vdev);\r\nstruct virtqueue *vq, *n;\r\nlist_for_each_entry_safe(vq, n, &vdev->vqs, list)\r\nvm_del_vq(vq);\r\nfree_irq(platform_get_irq(vm_dev->pdev, 0), vm_dev);\r\n}\r\nstatic struct virtqueue *vm_setup_vq(struct virtio_device *vdev, unsigned index,\r\nvoid (*callback)(struct virtqueue *vq),\r\nconst char *name)\r\n{\r\nstruct virtio_mmio_device *vm_dev = to_virtio_mmio_device(vdev);\r\nstruct virtio_mmio_vq_info *info;\r\nstruct virtqueue *vq;\r\nunsigned long flags, size;\r\nint err;\r\nif (!name)\r\nreturn NULL;\r\nwritel(index, vm_dev->base + VIRTIO_MMIO_QUEUE_SEL);\r\nif (readl(vm_dev->base + VIRTIO_MMIO_QUEUE_PFN)) {\r\nerr = -ENOENT;\r\ngoto error_available;\r\n}\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info) {\r\nerr = -ENOMEM;\r\ngoto error_kmalloc;\r\n}\r\ninfo->num = readl(vm_dev->base + VIRTIO_MMIO_QUEUE_NUM_MAX);\r\nif (info->num == 0) {\r\nerr = -ENOENT;\r\ngoto error_alloc_pages;\r\n}\r\nwhile (1) {\r\nsize = PAGE_ALIGN(vring_size(info->num,\r\nVIRTIO_MMIO_VRING_ALIGN));\r\nif (size < VIRTIO_MMIO_VRING_ALIGN * 2) {\r\nerr = -ENOMEM;\r\ngoto error_alloc_pages;\r\n}\r\ninfo->queue = alloc_pages_exact(size, GFP_KERNEL | __GFP_ZERO);\r\nif (info->queue)\r\nbreak;\r\ninfo->num /= 2;\r\n}\r\nwritel(info->num, vm_dev->base + VIRTIO_MMIO_QUEUE_NUM);\r\nwritel(VIRTIO_MMIO_VRING_ALIGN,\r\nvm_dev->base + VIRTIO_MMIO_QUEUE_ALIGN);\r\nwritel(virt_to_phys(info->queue) >> PAGE_SHIFT,\r\nvm_dev->base + VIRTIO_MMIO_QUEUE_PFN);\r\nvq = vring_new_virtqueue(index, info->num, VIRTIO_MMIO_VRING_ALIGN, vdev,\r\ntrue, info->queue, vm_notify, callback, name);\r\nif (!vq) {\r\nerr = -ENOMEM;\r\ngoto error_new_virtqueue;\r\n}\r\nvq->priv = info;\r\ninfo->vq = vq;\r\nspin_lock_irqsave(&vm_dev->lock, flags);\r\nlist_add(&info->node, &vm_dev->virtqueues);\r\nspin_unlock_irqrestore(&vm_dev->lock, flags);\r\nreturn vq;\r\nerror_new_virtqueue:\r\nwritel(0, vm_dev->base + VIRTIO_MMIO_QUEUE_PFN);\r\nfree_pages_exact(info->queue, size);\r\nerror_alloc_pages:\r\nkfree(info);\r\nerror_kmalloc:\r\nerror_available:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int vm_find_vqs(struct virtio_device *vdev, unsigned nvqs,\r\nstruct virtqueue *vqs[],\r\nvq_callback_t *callbacks[],\r\nconst char *names[])\r\n{\r\nstruct virtio_mmio_device *vm_dev = to_virtio_mmio_device(vdev);\r\nunsigned int irq = platform_get_irq(vm_dev->pdev, 0);\r\nint i, err;\r\nerr = request_irq(irq, vm_interrupt, IRQF_SHARED,\r\ndev_name(&vdev->dev), vm_dev);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < nvqs; ++i) {\r\nvqs[i] = vm_setup_vq(vdev, i, callbacks[i], names[i]);\r\nif (IS_ERR(vqs[i])) {\r\nvm_del_vqs(vdev);\r\nreturn PTR_ERR(vqs[i]);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic const char *vm_bus_name(struct virtio_device *vdev)\r\n{\r\nstruct virtio_mmio_device *vm_dev = to_virtio_mmio_device(vdev);\r\nreturn vm_dev->pdev->name;\r\n}\r\nstatic int virtio_mmio_probe(struct platform_device *pdev)\r\n{\r\nstruct virtio_mmio_device *vm_dev;\r\nstruct resource *mem;\r\nunsigned long magic;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem)\r\nreturn -EINVAL;\r\nif (!devm_request_mem_region(&pdev->dev, mem->start,\r\nresource_size(mem), pdev->name))\r\nreturn -EBUSY;\r\nvm_dev = devm_kzalloc(&pdev->dev, sizeof(*vm_dev), GFP_KERNEL);\r\nif (!vm_dev)\r\nreturn -ENOMEM;\r\nvm_dev->vdev.dev.parent = &pdev->dev;\r\nvm_dev->vdev.config = &virtio_mmio_config_ops;\r\nvm_dev->pdev = pdev;\r\nINIT_LIST_HEAD(&vm_dev->virtqueues);\r\nspin_lock_init(&vm_dev->lock);\r\nvm_dev->base = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));\r\nif (vm_dev->base == NULL)\r\nreturn -EFAULT;\r\nmagic = readl(vm_dev->base + VIRTIO_MMIO_MAGIC_VALUE);\r\nif (magic != ('v' | 'i' << 8 | 'r' << 16 | 't' << 24)) {\r\ndev_warn(&pdev->dev, "Wrong magic value 0x%08lx!\n", magic);\r\nreturn -ENODEV;\r\n}\r\nvm_dev->version = readl(vm_dev->base + VIRTIO_MMIO_VERSION);\r\nif (vm_dev->version != 1) {\r\ndev_err(&pdev->dev, "Version %ld not supported!\n",\r\nvm_dev->version);\r\nreturn -ENXIO;\r\n}\r\nvm_dev->vdev.id.device = readl(vm_dev->base + VIRTIO_MMIO_DEVICE_ID);\r\nvm_dev->vdev.id.vendor = readl(vm_dev->base + VIRTIO_MMIO_VENDOR_ID);\r\nwritel(PAGE_SIZE, vm_dev->base + VIRTIO_MMIO_GUEST_PAGE_SIZE);\r\nplatform_set_drvdata(pdev, vm_dev);\r\nreturn register_virtio_device(&vm_dev->vdev);\r\n}\r\nstatic int virtio_mmio_remove(struct platform_device *pdev)\r\n{\r\nstruct virtio_mmio_device *vm_dev = platform_get_drvdata(pdev);\r\nunregister_virtio_device(&vm_dev->vdev);\r\nreturn 0;\r\n}\r\nstatic int vm_cmdline_set(const char *device,\r\nconst struct kernel_param *kp)\r\n{\r\nint err;\r\nstruct resource resources[2] = {};\r\nchar *str;\r\nlong long int base, size;\r\nunsigned int irq;\r\nint processed, consumed = 0;\r\nstruct platform_device *pdev;\r\nsize = memparse(device, &str);\r\nprocessed = sscanf(str, "@%lli:%u%n:%d%n",\r\n&base, &irq, &consumed,\r\n&vm_cmdline_id, &consumed);\r\nif (processed < 2 || str[consumed])\r\nreturn -EINVAL;\r\nresources[0].flags = IORESOURCE_MEM;\r\nresources[0].start = base;\r\nresources[0].end = base + size - 1;\r\nresources[1].flags = IORESOURCE_IRQ;\r\nresources[1].start = resources[1].end = irq;\r\nif (!vm_cmdline_parent_registered) {\r\nerr = device_register(&vm_cmdline_parent);\r\nif (err) {\r\npr_err("Failed to register parent device!\n");\r\nreturn err;\r\n}\r\nvm_cmdline_parent_registered = 1;\r\n}\r\npr_info("Registering device virtio-mmio.%d at 0x%llx-0x%llx, IRQ %d.\n",\r\nvm_cmdline_id,\r\n(unsigned long long)resources[0].start,\r\n(unsigned long long)resources[0].end,\r\n(int)resources[1].start);\r\npdev = platform_device_register_resndata(&vm_cmdline_parent,\r\n"virtio-mmio", vm_cmdline_id++,\r\nresources, ARRAY_SIZE(resources), NULL, 0);\r\nif (IS_ERR(pdev))\r\nreturn PTR_ERR(pdev);\r\nreturn 0;\r\n}\r\nstatic int vm_cmdline_get_device(struct device *dev, void *data)\r\n{\r\nchar *buffer = data;\r\nunsigned int len = strlen(buffer);\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nsnprintf(buffer + len, PAGE_SIZE - len, "0x%llx@0x%llx:%llu:%d\n",\r\npdev->resource[0].end - pdev->resource[0].start + 1ULL,\r\n(unsigned long long)pdev->resource[0].start,\r\n(unsigned long long)pdev->resource[1].start,\r\npdev->id);\r\nreturn 0;\r\n}\r\nstatic int vm_cmdline_get(char *buffer, const struct kernel_param *kp)\r\n{\r\nbuffer[0] = '\0';\r\ndevice_for_each_child(&vm_cmdline_parent, buffer,\r\nvm_cmdline_get_device);\r\nreturn strlen(buffer) + 1;\r\n}\r\nstatic int vm_unregister_cmdline_device(struct device *dev,\r\nvoid *data)\r\n{\r\nplatform_device_unregister(to_platform_device(dev));\r\nreturn 0;\r\n}\r\nstatic void vm_unregister_cmdline_devices(void)\r\n{\r\nif (vm_cmdline_parent_registered) {\r\ndevice_for_each_child(&vm_cmdline_parent, NULL,\r\nvm_unregister_cmdline_device);\r\ndevice_unregister(&vm_cmdline_parent);\r\nvm_cmdline_parent_registered = 0;\r\n}\r\n}\r\nstatic void vm_unregister_cmdline_devices(void)\r\n{\r\n}\r\nstatic int __init virtio_mmio_init(void)\r\n{\r\nreturn platform_driver_register(&virtio_mmio_driver);\r\n}\r\nstatic void __exit virtio_mmio_exit(void)\r\n{\r\nplatform_driver_unregister(&virtio_mmio_driver);\r\nvm_unregister_cmdline_devices();\r\n}
