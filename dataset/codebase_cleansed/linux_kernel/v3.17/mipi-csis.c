static struct csis_state *sd_to_csis_state(struct v4l2_subdev *sdev)\r\n{\r\nreturn container_of(sdev, struct csis_state, sd);\r\n}\r\nstatic const struct csis_pix_format *find_csis_format(\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(s5pcsis_formats); i++)\r\nif (mf->code == s5pcsis_formats[i].code)\r\nreturn &s5pcsis_formats[i];\r\nreturn NULL;\r\n}\r\nstatic void s5pcsis_enable_interrupts(struct csis_state *state, bool on)\r\n{\r\nu32 val = s5pcsis_read(state, S5PCSIS_INTMSK);\r\nif (on)\r\nval |= state->interrupt_mask;\r\nelse\r\nval &= ~state->interrupt_mask;\r\ns5pcsis_write(state, S5PCSIS_INTMSK, val);\r\n}\r\nstatic void s5pcsis_reset(struct csis_state *state)\r\n{\r\nu32 val = s5pcsis_read(state, S5PCSIS_CTRL);\r\ns5pcsis_write(state, S5PCSIS_CTRL, val | S5PCSIS_CTRL_RESET);\r\nudelay(10);\r\n}\r\nstatic void s5pcsis_system_enable(struct csis_state *state, int on)\r\n{\r\nu32 val, mask;\r\nval = s5pcsis_read(state, S5PCSIS_CTRL);\r\nif (on)\r\nval |= S5PCSIS_CTRL_ENABLE;\r\nelse\r\nval &= ~S5PCSIS_CTRL_ENABLE;\r\ns5pcsis_write(state, S5PCSIS_CTRL, val);\r\nval = s5pcsis_read(state, S5PCSIS_DPHYCTRL);\r\nval &= ~S5PCSIS_DPHYCTRL_ENABLE;\r\nif (on) {\r\nmask = (1 << (state->num_lanes + 1)) - 1;\r\nval |= (mask & S5PCSIS_DPHYCTRL_ENABLE);\r\n}\r\ns5pcsis_write(state, S5PCSIS_DPHYCTRL, val);\r\n}\r\nstatic void __s5pcsis_set_format(struct csis_state *state)\r\n{\r\nstruct v4l2_mbus_framefmt *mf = &state->format;\r\nu32 val;\r\nv4l2_dbg(1, debug, &state->sd, "fmt: %#x, %d x %d\n",\r\nmf->code, mf->width, mf->height);\r\nval = s5pcsis_read(state, S5PCSIS_CONFIG);\r\nval = (val & ~S5PCSIS_CFG_FMT_MASK) | state->csis_fmt->fmt_reg;\r\ns5pcsis_write(state, S5PCSIS_CONFIG, val);\r\nval = (mf->width << 16) | mf->height;\r\ns5pcsis_write(state, S5PCSIS_RESOL, val);\r\n}\r\nstatic void s5pcsis_set_hsync_settle(struct csis_state *state, int settle)\r\n{\r\nu32 val = s5pcsis_read(state, S5PCSIS_DPHYCTRL);\r\nval = (val & ~S5PCSIS_DPHYCTRL_HSS_MASK) | (settle << 27);\r\ns5pcsis_write(state, S5PCSIS_DPHYCTRL, val);\r\n}\r\nstatic void s5pcsis_set_params(struct csis_state *state)\r\n{\r\nu32 val;\r\nval = s5pcsis_read(state, S5PCSIS_CONFIG);\r\nval = (val & ~S5PCSIS_CFG_NR_LANE_MASK) | (state->num_lanes - 1);\r\ns5pcsis_write(state, S5PCSIS_CONFIG, val);\r\n__s5pcsis_set_format(state);\r\ns5pcsis_set_hsync_settle(state, state->hs_settle);\r\nval = s5pcsis_read(state, S5PCSIS_CTRL);\r\nif (state->csis_fmt->data_alignment == 32)\r\nval |= S5PCSIS_CTRL_ALIGN_32BIT;\r\nelse\r\nval &= ~S5PCSIS_CTRL_ALIGN_32BIT;\r\nval &= ~S5PCSIS_CTRL_WCLK_EXTCLK;\r\nif (state->wclk_ext)\r\nval |= S5PCSIS_CTRL_WCLK_EXTCLK;\r\ns5pcsis_write(state, S5PCSIS_CTRL, val);\r\nval = s5pcsis_read(state, S5PCSIS_CTRL);\r\ns5pcsis_write(state, S5PCSIS_CTRL, val | S5PCSIS_CTRL_UPDATE_SHADOW);\r\n}\r\nstatic void s5pcsis_clk_put(struct csis_state *state)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_CSIS_CLOCKS; i++) {\r\nif (IS_ERR(state->clock[i]))\r\ncontinue;\r\nclk_unprepare(state->clock[i]);\r\nclk_put(state->clock[i]);\r\nstate->clock[i] = ERR_PTR(-EINVAL);\r\n}\r\n}\r\nstatic int s5pcsis_clk_get(struct csis_state *state)\r\n{\r\nstruct device *dev = &state->pdev->dev;\r\nint i, ret;\r\nfor (i = 0; i < NUM_CSIS_CLOCKS; i++)\r\nstate->clock[i] = ERR_PTR(-EINVAL);\r\nfor (i = 0; i < NUM_CSIS_CLOCKS; i++) {\r\nstate->clock[i] = clk_get(dev, csi_clock_name[i]);\r\nif (IS_ERR(state->clock[i])) {\r\nret = PTR_ERR(state->clock[i]);\r\ngoto err;\r\n}\r\nret = clk_prepare(state->clock[i]);\r\nif (ret < 0) {\r\nclk_put(state->clock[i]);\r\nstate->clock[i] = ERR_PTR(-EINVAL);\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\ns5pcsis_clk_put(state);\r\ndev_err(dev, "failed to get clock: %s\n", csi_clock_name[i]);\r\nreturn ret;\r\n}\r\nstatic void dump_regs(struct csis_state *state, const char *label)\r\n{\r\nstruct {\r\nu32 offset;\r\nconst char * const name;\r\n} registers[] = {\r\n{ 0x00, "CTRL" },\r\n{ 0x04, "DPHYCTRL" },\r\n{ 0x08, "CONFIG" },\r\n{ 0x0c, "DPHYSTS" },\r\n{ 0x10, "INTMSK" },\r\n{ 0x2c, "RESOL" },\r\n{ 0x38, "SDW_CONFIG" },\r\n};\r\nu32 i;\r\nv4l2_info(&state->sd, "--- %s ---\n", label);\r\nfor (i = 0; i < ARRAY_SIZE(registers); i++) {\r\nu32 cfg = s5pcsis_read(state, registers[i].offset);\r\nv4l2_info(&state->sd, "%10s: 0x%08x\n", registers[i].name, cfg);\r\n}\r\n}\r\nstatic void s5pcsis_start_stream(struct csis_state *state)\r\n{\r\ns5pcsis_reset(state);\r\ns5pcsis_set_params(state);\r\ns5pcsis_system_enable(state, true);\r\ns5pcsis_enable_interrupts(state, true);\r\n}\r\nstatic void s5pcsis_stop_stream(struct csis_state *state)\r\n{\r\ns5pcsis_enable_interrupts(state, false);\r\ns5pcsis_system_enable(state, false);\r\n}\r\nstatic void s5pcsis_clear_counters(struct csis_state *state)\r\n{\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&state->slock, flags);\r\nfor (i = 0; i < S5PCSIS_NUM_EVENTS; i++)\r\nstate->events[i].counter = 0;\r\nspin_unlock_irqrestore(&state->slock, flags);\r\n}\r\nstatic void s5pcsis_log_counters(struct csis_state *state, bool non_errors)\r\n{\r\nint i = non_errors ? S5PCSIS_NUM_EVENTS : S5PCSIS_NUM_EVENTS - 4;\r\nunsigned long flags;\r\nspin_lock_irqsave(&state->slock, flags);\r\nfor (i--; i >= 0; i--) {\r\nif (state->events[i].counter > 0 || debug)\r\nv4l2_info(&state->sd, "%s events: %d\n",\r\nstate->events[i].name,\r\nstate->events[i].counter);\r\n}\r\nspin_unlock_irqrestore(&state->slock, flags);\r\n}\r\nstatic int s5pcsis_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct csis_state *state = sd_to_csis_state(sd);\r\nstruct device *dev = &state->pdev->dev;\r\nif (on)\r\nreturn pm_runtime_get_sync(dev);\r\nreturn pm_runtime_put_sync(dev);\r\n}\r\nstatic int s5pcsis_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct csis_state *state = sd_to_csis_state(sd);\r\nint ret = 0;\r\nv4l2_dbg(1, debug, sd, "%s: %d, state: 0x%x\n",\r\n__func__, enable, state->flags);\r\nif (enable) {\r\ns5pcsis_clear_counters(state);\r\nret = pm_runtime_get_sync(&state->pdev->dev);\r\nif (ret && ret != 1)\r\nreturn ret;\r\n}\r\nmutex_lock(&state->lock);\r\nif (enable) {\r\nif (state->flags & ST_SUSPENDED) {\r\nret = -EBUSY;\r\ngoto unlock;\r\n}\r\ns5pcsis_start_stream(state);\r\nstate->flags |= ST_STREAMING;\r\n} else {\r\ns5pcsis_stop_stream(state);\r\nstate->flags &= ~ST_STREAMING;\r\nif (debug > 0)\r\ns5pcsis_log_counters(state, true);\r\n}\r\nunlock:\r\nmutex_unlock(&state->lock);\r\nif (!enable)\r\npm_runtime_put(&state->pdev->dev);\r\nreturn ret == 1 ? 0 : ret;\r\n}\r\nstatic int s5pcsis_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->index >= ARRAY_SIZE(s5pcsis_formats))\r\nreturn -EINVAL;\r\ncode->code = s5pcsis_formats[code->index].code;\r\nreturn 0;\r\n}\r\nstatic struct csis_pix_format const *s5pcsis_try_format(\r\nstruct v4l2_mbus_framefmt *mf)\r\n{\r\nstruct csis_pix_format const *csis_fmt;\r\ncsis_fmt = find_csis_format(mf);\r\nif (csis_fmt == NULL)\r\ncsis_fmt = &s5pcsis_formats[0];\r\nmf->code = csis_fmt->code;\r\nv4l_bound_align_image(&mf->width, 1, CSIS_MAX_PIX_WIDTH,\r\ncsis_fmt->pix_width_alignment,\r\n&mf->height, 1, CSIS_MAX_PIX_HEIGHT, 1,\r\n0);\r\nreturn csis_fmt;\r\n}\r\nstatic struct v4l2_mbus_framefmt *__s5pcsis_get_format(\r\nstruct csis_state *state, struct v4l2_subdev_fh *fh,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn fh ? v4l2_subdev_get_try_format(fh, 0) : NULL;\r\nreturn &state->format;\r\n}\r\nstatic int s5pcsis_set_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct csis_state *state = sd_to_csis_state(sd);\r\nstruct csis_pix_format const *csis_fmt;\r\nstruct v4l2_mbus_framefmt *mf;\r\nmf = __s5pcsis_get_format(state, fh, fmt->which);\r\nif (fmt->pad == CSIS_PAD_SOURCE) {\r\nif (mf) {\r\nmutex_lock(&state->lock);\r\nfmt->format = *mf;\r\nmutex_unlock(&state->lock);\r\n}\r\nreturn 0;\r\n}\r\ncsis_fmt = s5pcsis_try_format(&fmt->format);\r\nif (mf) {\r\nmutex_lock(&state->lock);\r\n*mf = fmt->format;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)\r\nstate->csis_fmt = csis_fmt;\r\nmutex_unlock(&state->lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5pcsis_get_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct csis_state *state = sd_to_csis_state(sd);\r\nstruct v4l2_mbus_framefmt *mf;\r\nmf = __s5pcsis_get_format(state, fh, fmt->which);\r\nif (!mf)\r\nreturn -EINVAL;\r\nmutex_lock(&state->lock);\r\nfmt->format = *mf;\r\nmutex_unlock(&state->lock);\r\nreturn 0;\r\n}\r\nstatic int s5pcsis_s_rx_buffer(struct v4l2_subdev *sd, void *buf,\r\nunsigned int *size)\r\n{\r\nstruct csis_state *state = sd_to_csis_state(sd);\r\nunsigned long flags;\r\n*size = min_t(unsigned int, *size, S5PCSIS_PKTDATA_SIZE);\r\nspin_lock_irqsave(&state->slock, flags);\r\nstate->pkt_buf.data = buf;\r\nstate->pkt_buf.len = *size;\r\nspin_unlock_irqrestore(&state->slock, flags);\r\nreturn 0;\r\n}\r\nstatic int s5pcsis_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct csis_state *state = sd_to_csis_state(sd);\r\nmutex_lock(&state->lock);\r\ns5pcsis_log_counters(state, true);\r\nif (debug && (state->flags & ST_POWERED))\r\ndump_regs(state, __func__);\r\nmutex_unlock(&state->lock);\r\nreturn 0;\r\n}\r\nstatic int s5pcsis_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_mbus_framefmt *format = v4l2_subdev_get_try_format(fh, 0);\r\nformat->colorspace = V4L2_COLORSPACE_JPEG;\r\nformat->code = s5pcsis_formats[0].code;\r\nformat->width = S5PCSIS_DEF_PIX_WIDTH;\r\nformat->height = S5PCSIS_DEF_PIX_HEIGHT;\r\nformat->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t s5pcsis_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct csis_state *state = dev_id;\r\nstruct csis_pktbuf *pktbuf = &state->pkt_buf;\r\nunsigned long flags;\r\nu32 status;\r\nstatus = s5pcsis_read(state, S5PCSIS_INTSRC);\r\nspin_lock_irqsave(&state->slock, flags);\r\nif ((status & S5PCSIS_INTSRC_NON_IMAGE_DATA) && pktbuf->data) {\r\nu32 offset;\r\nif (status & S5PCSIS_INTSRC_EVEN)\r\noffset = S5PCSIS_PKTDATA_EVEN;\r\nelse\r\noffset = S5PCSIS_PKTDATA_ODD;\r\nmemcpy(pktbuf->data, state->regs + offset, pktbuf->len);\r\npktbuf->data = NULL;\r\nrmb();\r\n}\r\nif ((status & S5PCSIS_INTSRC_ERRORS) || debug) {\r\nint i;\r\nfor (i = 0; i < S5PCSIS_NUM_EVENTS; i++) {\r\nif (!(status & state->events[i].mask))\r\ncontinue;\r\nstate->events[i].counter++;\r\nv4l2_dbg(2, debug, &state->sd, "%s: %d\n",\r\nstate->events[i].name,\r\nstate->events[i].counter);\r\n}\r\nv4l2_dbg(2, debug, &state->sd, "status: %08x\n", status);\r\n}\r\nspin_unlock_irqrestore(&state->slock, flags);\r\ns5pcsis_write(state, S5PCSIS_INTSRC, status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s5pcsis_parse_dt(struct platform_device *pdev,\r\nstruct csis_state *state)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct v4l2_of_endpoint endpoint;\r\nif (of_property_read_u32(node, "clock-frequency",\r\n&state->clk_frequency))\r\nstate->clk_frequency = DEFAULT_SCLK_CSIS_FREQ;\r\nif (of_property_read_u32(node, "bus-width",\r\n&state->max_num_lanes))\r\nreturn -EINVAL;\r\nnode = of_graph_get_next_endpoint(node, NULL);\r\nif (!node) {\r\ndev_err(&pdev->dev, "No port node at %s\n",\r\npdev->dev.of_node->full_name);\r\nreturn -EINVAL;\r\n}\r\nv4l2_of_parse_endpoint(node, &endpoint);\r\nstate->index = endpoint.base.port - FIMC_INPUT_MIPI_CSI2_0;\r\nif (state->index < 0 || state->index >= CSIS_MAX_ENTITIES)\r\nreturn -ENXIO;\r\nof_property_read_u32(node, "samsung,csis-hs-settle",\r\n&state->hs_settle);\r\nstate->wclk_ext = of_property_read_bool(node,\r\n"samsung,csis-wclk");\r\nstate->num_lanes = endpoint.bus.mipi_csi2.num_data_lanes;\r\nof_node_put(node);\r\nreturn 0;\r\n}\r\nstatic int s5pcsis_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id;\r\nconst struct csis_drvdata *drv_data;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *mem_res;\r\nstruct csis_state *state;\r\nint ret = -ENOMEM;\r\nint i;\r\nstate = devm_kzalloc(dev, sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nmutex_init(&state->lock);\r\nspin_lock_init(&state->slock);\r\nstate->pdev = pdev;\r\nof_id = of_match_node(s5pcsis_of_match, dev->of_node);\r\nif (WARN_ON(of_id == NULL))\r\nreturn -EINVAL;\r\ndrv_data = of_id->data;\r\nstate->interrupt_mask = drv_data->interrupt_mask;\r\nret = s5pcsis_parse_dt(pdev, state);\r\nif (ret < 0)\r\nreturn ret;\r\nif (state->num_lanes == 0 || state->num_lanes > state->max_num_lanes) {\r\ndev_err(dev, "Unsupported number of data lanes: %d (max. %d)\n",\r\nstate->num_lanes, state->max_num_lanes);\r\nreturn -EINVAL;\r\n}\r\nstate->phy = devm_phy_get(dev, "csis");\r\nif (IS_ERR(state->phy))\r\nreturn PTR_ERR(state->phy);\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nstate->regs = devm_ioremap_resource(dev, mem_res);\r\nif (IS_ERR(state->regs))\r\nreturn PTR_ERR(state->regs);\r\nstate->irq = platform_get_irq(pdev, 0);\r\nif (state->irq < 0) {\r\ndev_err(dev, "Failed to get irq\n");\r\nreturn state->irq;\r\n}\r\nfor (i = 0; i < CSIS_NUM_SUPPLIES; i++)\r\nstate->supplies[i].supply = csis_supply_name[i];\r\nret = devm_regulator_bulk_get(dev, CSIS_NUM_SUPPLIES,\r\nstate->supplies);\r\nif (ret)\r\nreturn ret;\r\nret = s5pcsis_clk_get(state);\r\nif (ret < 0)\r\nreturn ret;\r\nif (state->clk_frequency)\r\nret = clk_set_rate(state->clock[CSIS_CLK_MUX],\r\nstate->clk_frequency);\r\nelse\r\ndev_WARN(dev, "No clock frequency specified!\n");\r\nif (ret < 0)\r\ngoto e_clkput;\r\nret = clk_enable(state->clock[CSIS_CLK_MUX]);\r\nif (ret < 0)\r\ngoto e_clkput;\r\nret = devm_request_irq(dev, state->irq, s5pcsis_irq_handler,\r\n0, dev_name(dev), state);\r\nif (ret) {\r\ndev_err(dev, "Interrupt request failed\n");\r\ngoto e_clkdis;\r\n}\r\nv4l2_subdev_init(&state->sd, &s5pcsis_subdev_ops);\r\nstate->sd.owner = THIS_MODULE;\r\nsnprintf(state->sd.name, sizeof(state->sd.name), "%s.%d",\r\nCSIS_SUBDEV_NAME, state->index);\r\nstate->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nstate->csis_fmt = &s5pcsis_formats[0];\r\nstate->format.code = s5pcsis_formats[0].code;\r\nstate->format.width = S5PCSIS_DEF_PIX_WIDTH;\r\nstate->format.height = S5PCSIS_DEF_PIX_HEIGHT;\r\nstate->pads[CSIS_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\r\nstate->pads[CSIS_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\r\nret = media_entity_init(&state->sd.entity,\r\nCSIS_PADS_NUM, state->pads, 0);\r\nif (ret < 0)\r\ngoto e_clkdis;\r\nv4l2_set_subdevdata(&state->sd, pdev);\r\nplatform_set_drvdata(pdev, &state->sd);\r\nmemcpy(state->events, s5pcsis_events, sizeof(state->events));\r\npm_runtime_enable(dev);\r\nif (!pm_runtime_enabled(dev)) {\r\nret = s5pcsis_pm_resume(dev, true);\r\nif (ret < 0)\r\ngoto e_m_ent;\r\n}\r\ndev_info(&pdev->dev, "lanes: %d, hs_settle: %d, wclk: %d, freq: %u\n",\r\nstate->num_lanes, state->hs_settle, state->wclk_ext,\r\nstate->clk_frequency);\r\nreturn 0;\r\ne_m_ent:\r\nmedia_entity_cleanup(&state->sd.entity);\r\ne_clkdis:\r\nclk_disable(state->clock[CSIS_CLK_MUX]);\r\ne_clkput:\r\ns5pcsis_clk_put(state);\r\nreturn ret;\r\n}\r\nstatic int s5pcsis_pm_suspend(struct device *dev, bool runtime)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct v4l2_subdev *sd = platform_get_drvdata(pdev);\r\nstruct csis_state *state = sd_to_csis_state(sd);\r\nint ret = 0;\r\nv4l2_dbg(1, debug, sd, "%s: flags: 0x%x\n",\r\n__func__, state->flags);\r\nmutex_lock(&state->lock);\r\nif (state->flags & ST_POWERED) {\r\ns5pcsis_stop_stream(state);\r\nret = phy_power_off(state->phy);\r\nif (ret)\r\ngoto unlock;\r\nret = regulator_bulk_disable(CSIS_NUM_SUPPLIES,\r\nstate->supplies);\r\nif (ret)\r\ngoto unlock;\r\nclk_disable(state->clock[CSIS_CLK_GATE]);\r\nstate->flags &= ~ST_POWERED;\r\nif (!runtime)\r\nstate->flags |= ST_SUSPENDED;\r\n}\r\nunlock:\r\nmutex_unlock(&state->lock);\r\nreturn ret ? -EAGAIN : 0;\r\n}\r\nstatic int s5pcsis_pm_resume(struct device *dev, bool runtime)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct v4l2_subdev *sd = platform_get_drvdata(pdev);\r\nstruct csis_state *state = sd_to_csis_state(sd);\r\nint ret = 0;\r\nv4l2_dbg(1, debug, sd, "%s: flags: 0x%x\n",\r\n__func__, state->flags);\r\nmutex_lock(&state->lock);\r\nif (!runtime && !(state->flags & ST_SUSPENDED))\r\ngoto unlock;\r\nif (!(state->flags & ST_POWERED)) {\r\nret = regulator_bulk_enable(CSIS_NUM_SUPPLIES,\r\nstate->supplies);\r\nif (ret)\r\ngoto unlock;\r\nret = phy_power_on(state->phy);\r\nif (!ret) {\r\nstate->flags |= ST_POWERED;\r\n} else {\r\nregulator_bulk_disable(CSIS_NUM_SUPPLIES,\r\nstate->supplies);\r\ngoto unlock;\r\n}\r\nclk_enable(state->clock[CSIS_CLK_GATE]);\r\n}\r\nif (state->flags & ST_STREAMING)\r\ns5pcsis_start_stream(state);\r\nstate->flags &= ~ST_SUSPENDED;\r\nunlock:\r\nmutex_unlock(&state->lock);\r\nreturn ret ? -EAGAIN : 0;\r\n}\r\nstatic int s5pcsis_suspend(struct device *dev)\r\n{\r\nreturn s5pcsis_pm_suspend(dev, false);\r\n}\r\nstatic int s5pcsis_resume(struct device *dev)\r\n{\r\nreturn s5pcsis_pm_resume(dev, false);\r\n}\r\nstatic int s5pcsis_runtime_suspend(struct device *dev)\r\n{\r\nreturn s5pcsis_pm_suspend(dev, true);\r\n}\r\nstatic int s5pcsis_runtime_resume(struct device *dev)\r\n{\r\nreturn s5pcsis_pm_resume(dev, true);\r\n}\r\nstatic int s5pcsis_remove(struct platform_device *pdev)\r\n{\r\nstruct v4l2_subdev *sd = platform_get_drvdata(pdev);\r\nstruct csis_state *state = sd_to_csis_state(sd);\r\npm_runtime_disable(&pdev->dev);\r\ns5pcsis_pm_suspend(&pdev->dev, true);\r\nclk_disable(state->clock[CSIS_CLK_MUX]);\r\npm_runtime_set_suspended(&pdev->dev);\r\ns5pcsis_clk_put(state);\r\nmedia_entity_cleanup(&state->sd.entity);\r\nreturn 0;\r\n}
