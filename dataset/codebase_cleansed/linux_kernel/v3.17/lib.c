int iwlagn_hw_valid_rtc_data_addr(u32 addr)\r\n{\r\nreturn (addr >= IWLAGN_RTC_DATA_LOWER_BOUND) &&\r\n(addr < IWLAGN_RTC_DATA_UPPER_BOUND);\r\n}\r\nint iwlagn_send_tx_power(struct iwl_priv *priv)\r\n{\r\nstruct iwlagn_tx_power_dbm_cmd tx_power_cmd;\r\nu8 tx_ant_cfg_cmd;\r\nif (WARN_ONCE(test_bit(STATUS_SCAN_HW, &priv->status),\r\n"TX Power requested while scanning!\n"))\r\nreturn -EAGAIN;\r\ntx_power_cmd.global_lmt = (s8)(2 * priv->tx_power_user_lmt);\r\nif (tx_power_cmd.global_lmt > priv->nvm_data->max_tx_pwr_half_dbm) {\r\ntx_power_cmd.global_lmt =\r\npriv->nvm_data->max_tx_pwr_half_dbm;\r\n}\r\ntx_power_cmd.flags = IWLAGN_TX_POWER_NO_CLOSED;\r\ntx_power_cmd.srv_chan_lmt = IWLAGN_TX_POWER_AUTO;\r\nif (IWL_UCODE_API(priv->fw->ucode_ver) == 1)\r\ntx_ant_cfg_cmd = REPLY_TX_POWER_DBM_CMD_V1;\r\nelse\r\ntx_ant_cfg_cmd = REPLY_TX_POWER_DBM_CMD;\r\nreturn iwl_dvm_send_cmd_pdu(priv, tx_ant_cfg_cmd, 0,\r\nsizeof(tx_power_cmd), &tx_power_cmd);\r\n}\r\nvoid iwlagn_temperature(struct iwl_priv *priv)\r\n{\r\nlockdep_assert_held(&priv->statistics.lock);\r\npriv->temperature = le32_to_cpu(priv->statistics.common.temperature);\r\niwl_tt_handler(priv);\r\n}\r\nint iwlagn_hwrate_to_mac80211_idx(u32 rate_n_flags, enum ieee80211_band band)\r\n{\r\nint idx = 0;\r\nint band_offset = 0;\r\nif (rate_n_flags & RATE_MCS_HT_MSK) {\r\nidx = (rate_n_flags & 0xff);\r\nreturn idx;\r\n} else {\r\nif (band == IEEE80211_BAND_5GHZ)\r\nband_offset = IWL_FIRST_OFDM_RATE;\r\nfor (idx = band_offset; idx < IWL_RATE_COUNT_LEGACY; idx++)\r\nif (iwl_rates[idx].plcp == (rate_n_flags & 0xFF))\r\nreturn idx - band_offset;\r\n}\r\nreturn -1;\r\n}\r\nint iwlagn_manage_ibss_station(struct iwl_priv *priv,\r\nstruct ieee80211_vif *vif, bool add)\r\n{\r\nstruct iwl_vif_priv *vif_priv = (void *)vif->drv_priv;\r\nif (add)\r\nreturn iwlagn_add_bssid_station(priv, vif_priv->ctx,\r\nvif->bss_conf.bssid,\r\n&vif_priv->ibss_bssid_sta_id);\r\nreturn iwl_remove_station(priv, vif_priv->ibss_bssid_sta_id,\r\nvif->bss_conf.bssid);\r\n}\r\nint iwlagn_txfifo_flush(struct iwl_priv *priv, u32 scd_q_msk)\r\n{\r\nstruct iwl_txfifo_flush_cmd flush_cmd;\r\nstruct iwl_host_cmd cmd = {\r\n.id = REPLY_TXFIFO_FLUSH,\r\n.len = { sizeof(struct iwl_txfifo_flush_cmd), },\r\n.data = { &flush_cmd, },\r\n};\r\nmemset(&flush_cmd, 0, sizeof(flush_cmd));\r\nflush_cmd.queue_control = IWL_SCD_VO_MSK | IWL_SCD_VI_MSK |\r\nIWL_SCD_BE_MSK | IWL_SCD_BK_MSK |\r\nIWL_SCD_MGMT_MSK;\r\nif ((priv->valid_contexts != BIT(IWL_RXON_CTX_BSS)))\r\nflush_cmd.queue_control |= IWL_PAN_SCD_VO_MSK |\r\nIWL_PAN_SCD_VI_MSK |\r\nIWL_PAN_SCD_BE_MSK |\r\nIWL_PAN_SCD_BK_MSK |\r\nIWL_PAN_SCD_MGMT_MSK |\r\nIWL_PAN_SCD_MULTICAST_MSK;\r\nif (priv->nvm_data->sku_cap_11n_enable)\r\nflush_cmd.queue_control |= IWL_AGG_TX_QUEUE_MSK;\r\nif (scd_q_msk)\r\nflush_cmd.queue_control = cpu_to_le32(scd_q_msk);\r\nIWL_DEBUG_INFO(priv, "queue control: 0x%x\n",\r\nflush_cmd.queue_control);\r\nflush_cmd.flush_control = cpu_to_le16(IWL_DROP_ALL);\r\nreturn iwl_dvm_send_cmd(priv, &cmd);\r\n}\r\nvoid iwlagn_dev_txfifo_flush(struct iwl_priv *priv)\r\n{\r\nmutex_lock(&priv->mutex);\r\nieee80211_stop_queues(priv->hw);\r\nif (iwlagn_txfifo_flush(priv, 0)) {\r\nIWL_ERR(priv, "flush request fail\n");\r\ngoto done;\r\n}\r\nIWL_DEBUG_INFO(priv, "wait transmit/flush all frames\n");\r\niwl_trans_wait_tx_queue_empty(priv->trans, 0xffffffff);\r\ndone:\r\nieee80211_wake_queues(priv->hw);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nvoid iwlagn_send_advance_bt_config(struct iwl_priv *priv)\r\n{\r\nstruct iwl_basic_bt_cmd basic = {\r\n.max_kill = IWLAGN_BT_MAX_KILL_DEFAULT,\r\n.bt3_timer_t7_value = IWLAGN_BT3_T7_DEFAULT,\r\n.bt3_prio_sample_time = IWLAGN_BT3_PRIO_SAMPLE_DEFAULT,\r\n.bt3_timer_t2_value = IWLAGN_BT3_T2_DEFAULT,\r\n};\r\nstruct iwl_bt_cmd_v1 bt_cmd_v1;\r\nstruct iwl_bt_cmd_v2 bt_cmd_v2;\r\nint ret;\r\nBUILD_BUG_ON(sizeof(iwlagn_def_3w_lookup) !=\r\nsizeof(basic.bt3_lookup_table));\r\nif (priv->lib->bt_params) {\r\nif (priv->lib->bt_params->bt_session_2) {\r\nbt_cmd_v2.prio_boost = cpu_to_le32(\r\npriv->lib->bt_params->bt_prio_boost);\r\nbt_cmd_v2.tx_prio_boost = 0;\r\nbt_cmd_v2.rx_prio_boost = 0;\r\n} else {\r\nWARN_ON(priv->lib->bt_params->bt_prio_boost & ~0xFF);\r\nbt_cmd_v1.prio_boost =\r\npriv->lib->bt_params->bt_prio_boost;\r\nbt_cmd_v1.tx_prio_boost = 0;\r\nbt_cmd_v1.rx_prio_boost = 0;\r\n}\r\n} else {\r\nIWL_ERR(priv, "failed to construct BT Coex Config\n");\r\nreturn;\r\n}\r\nbasic.kill_ack_mask = priv->kill_ack_mask;\r\nbasic.kill_cts_mask = priv->kill_cts_mask;\r\nif (priv->reduced_txpower)\r\nbasic.reduce_txpower = IWLAGN_BT_REDUCED_TX_PWR;\r\nbasic.valid = priv->bt_valid;\r\nif (!iwlwifi_mod_params.bt_coex_active ||\r\npriv->iw_mode == NL80211_IFTYPE_ADHOC) {\r\nbasic.flags = IWLAGN_BT_FLAG_COEX_MODE_DISABLED;\r\n} else {\r\nbasic.flags = IWLAGN_BT_FLAG_COEX_MODE_3W <<\r\nIWLAGN_BT_FLAG_COEX_MODE_SHIFT;\r\nif (!priv->bt_enable_pspoll)\r\nbasic.flags |= IWLAGN_BT_FLAG_SYNC_2_BT_DISABLE;\r\nelse\r\nbasic.flags &= ~IWLAGN_BT_FLAG_SYNC_2_BT_DISABLE;\r\nif (priv->bt_ch_announce)\r\nbasic.flags |= IWLAGN_BT_FLAG_CHANNEL_INHIBITION;\r\nIWL_DEBUG_COEX(priv, "BT coex flag: 0X%x\n", basic.flags);\r\n}\r\npriv->bt_enable_flag = basic.flags;\r\nif (priv->bt_full_concurrent)\r\nmemcpy(basic.bt3_lookup_table, iwlagn_concurrent_lookup,\r\nsizeof(iwlagn_concurrent_lookup));\r\nelse\r\nmemcpy(basic.bt3_lookup_table, iwlagn_def_3w_lookup,\r\nsizeof(iwlagn_def_3w_lookup));\r\nIWL_DEBUG_COEX(priv, "BT coex %s in %s mode\n",\r\nbasic.flags ? "active" : "disabled",\r\npriv->bt_full_concurrent ?\r\n"full concurrency" : "3-wire");\r\nif (priv->lib->bt_params->bt_session_2) {\r\nmemcpy(&bt_cmd_v2.basic, &basic,\r\nsizeof(basic));\r\nret = iwl_dvm_send_cmd_pdu(priv, REPLY_BT_CONFIG,\r\n0, sizeof(bt_cmd_v2), &bt_cmd_v2);\r\n} else {\r\nmemcpy(&bt_cmd_v1.basic, &basic,\r\nsizeof(basic));\r\nret = iwl_dvm_send_cmd_pdu(priv, REPLY_BT_CONFIG,\r\n0, sizeof(bt_cmd_v1), &bt_cmd_v1);\r\n}\r\nif (ret)\r\nIWL_ERR(priv, "failed to send BT Coex Config\n");\r\n}\r\nvoid iwlagn_bt_adjust_rssi_monitor(struct iwl_priv *priv, bool rssi_ena)\r\n{\r\nstruct iwl_rxon_context *ctx, *found_ctx = NULL;\r\nbool found_ap = false;\r\nlockdep_assert_held(&priv->mutex);\r\nif (rssi_ena) {\r\nfor_each_context(priv, ctx) {\r\nif (ctx->vif && ctx->vif->type == NL80211_IFTYPE_AP &&\r\niwl_is_associated_ctx(ctx)) {\r\nfound_ap = true;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!rssi_ena || found_ap) {\r\nif (priv->cur_rssi_ctx) {\r\nctx = priv->cur_rssi_ctx;\r\nieee80211_disable_rssi_reports(ctx->vif);\r\npriv->cur_rssi_ctx = NULL;\r\n}\r\nreturn;\r\n}\r\nfor_each_context(priv, ctx) {\r\nif (ctx->vif && ctx->vif->type == NL80211_IFTYPE_STATION &&\r\niwl_is_associated_ctx(ctx)) {\r\nfound_ctx = ctx;\r\nbreak;\r\n}\r\n}\r\nif (found_ctx == priv->cur_rssi_ctx)\r\nreturn;\r\nif (priv->cur_rssi_ctx) {\r\nctx = priv->cur_rssi_ctx;\r\nif (ctx->vif)\r\nieee80211_disable_rssi_reports(ctx->vif);\r\n}\r\npriv->cur_rssi_ctx = found_ctx;\r\nif (!found_ctx)\r\nreturn;\r\nieee80211_enable_rssi_reports(found_ctx->vif,\r\nIWLAGN_BT_PSP_MIN_RSSI_THRESHOLD,\r\nIWLAGN_BT_PSP_MAX_RSSI_THRESHOLD);\r\n}\r\nstatic bool iwlagn_bt_traffic_is_sco(struct iwl_bt_uart_msg *uart_msg)\r\n{\r\nreturn BT_UART_MSG_FRAME3SCOESCO_MSK & uart_msg->frame3 >>\r\nBT_UART_MSG_FRAME3SCOESCO_POS;\r\n}\r\nstatic void iwlagn_bt_traffic_change_work(struct work_struct *work)\r\n{\r\nstruct iwl_priv *priv =\r\ncontainer_of(work, struct iwl_priv, bt_traffic_change_work);\r\nstruct iwl_rxon_context *ctx;\r\nint smps_request = -1;\r\nif (priv->bt_enable_flag == IWLAGN_BT_FLAG_COEX_MODE_DISABLED) {\r\nreturn;\r\n}\r\nIWL_DEBUG_COEX(priv, "BT traffic load changes: %d\n",\r\npriv->bt_traffic_load);\r\nswitch (priv->bt_traffic_load) {\r\ncase IWL_BT_COEX_TRAFFIC_LOAD_NONE:\r\nif (priv->bt_status)\r\nsmps_request = IEEE80211_SMPS_DYNAMIC;\r\nelse\r\nsmps_request = IEEE80211_SMPS_AUTOMATIC;\r\nbreak;\r\ncase IWL_BT_COEX_TRAFFIC_LOAD_LOW:\r\nsmps_request = IEEE80211_SMPS_DYNAMIC;\r\nbreak;\r\ncase IWL_BT_COEX_TRAFFIC_LOAD_HIGH:\r\ncase IWL_BT_COEX_TRAFFIC_LOAD_CONTINUOUS:\r\nsmps_request = IEEE80211_SMPS_STATIC;\r\nbreak;\r\ndefault:\r\nIWL_ERR(priv, "Invalid BT traffic load: %d\n",\r\npriv->bt_traffic_load);\r\nbreak;\r\n}\r\nmutex_lock(&priv->mutex);\r\nif (test_bit(STATUS_SCAN_HW, &priv->status))\r\ngoto out;\r\niwl_update_chain_flags(priv);\r\nif (smps_request != -1) {\r\npriv->current_ht_config.smps = smps_request;\r\nfor_each_context(priv, ctx) {\r\nif (ctx->vif && ctx->vif->type == NL80211_IFTYPE_STATION)\r\nieee80211_request_smps(ctx->vif, smps_request);\r\n}\r\n}\r\niwlagn_bt_coex_rssi_monitor(priv);\r\nout:\r\nmutex_unlock(&priv->mutex);\r\n}\r\nvoid iwlagn_bt_coex_rssi_monitor(struct iwl_priv *priv)\r\n{\r\nif (priv->bt_is_sco &&\r\npriv->bt_traffic_load == IWL_BT_COEX_TRAFFIC_LOAD_CONTINUOUS)\r\niwlagn_bt_adjust_rssi_monitor(priv, true);\r\nelse\r\niwlagn_bt_adjust_rssi_monitor(priv, false);\r\n}\r\nstatic void iwlagn_print_uartmsg(struct iwl_priv *priv,\r\nstruct iwl_bt_uart_msg *uart_msg)\r\n{\r\nIWL_DEBUG_COEX(priv, "Message Type = 0x%X, SSN = 0x%X, "\r\n"Update Req = 0x%X\n",\r\n(BT_UART_MSG_FRAME1MSGTYPE_MSK & uart_msg->frame1) >>\r\nBT_UART_MSG_FRAME1MSGTYPE_POS,\r\n(BT_UART_MSG_FRAME1SSN_MSK & uart_msg->frame1) >>\r\nBT_UART_MSG_FRAME1SSN_POS,\r\n(BT_UART_MSG_FRAME1UPDATEREQ_MSK & uart_msg->frame1) >>\r\nBT_UART_MSG_FRAME1UPDATEREQ_POS);\r\nIWL_DEBUG_COEX(priv, "Open connections = 0x%X, Traffic load = 0x%X, "\r\n"Chl_SeqN = 0x%X, In band = 0x%X\n",\r\n(BT_UART_MSG_FRAME2OPENCONNECTIONS_MSK & uart_msg->frame2) >>\r\nBT_UART_MSG_FRAME2OPENCONNECTIONS_POS,\r\n(BT_UART_MSG_FRAME2TRAFFICLOAD_MSK & uart_msg->frame2) >>\r\nBT_UART_MSG_FRAME2TRAFFICLOAD_POS,\r\n(BT_UART_MSG_FRAME2CHLSEQN_MSK & uart_msg->frame2) >>\r\nBT_UART_MSG_FRAME2CHLSEQN_POS,\r\n(BT_UART_MSG_FRAME2INBAND_MSK & uart_msg->frame2) >>\r\nBT_UART_MSG_FRAME2INBAND_POS);\r\nIWL_DEBUG_COEX(priv, "SCO/eSCO = 0x%X, Sniff = 0x%X, A2DP = 0x%X, "\r\n"ACL = 0x%X, Master = 0x%X, OBEX = 0x%X\n",\r\n(BT_UART_MSG_FRAME3SCOESCO_MSK & uart_msg->frame3) >>\r\nBT_UART_MSG_FRAME3SCOESCO_POS,\r\n(BT_UART_MSG_FRAME3SNIFF_MSK & uart_msg->frame3) >>\r\nBT_UART_MSG_FRAME3SNIFF_POS,\r\n(BT_UART_MSG_FRAME3A2DP_MSK & uart_msg->frame3) >>\r\nBT_UART_MSG_FRAME3A2DP_POS,\r\n(BT_UART_MSG_FRAME3ACL_MSK & uart_msg->frame3) >>\r\nBT_UART_MSG_FRAME3ACL_POS,\r\n(BT_UART_MSG_FRAME3MASTER_MSK & uart_msg->frame3) >>\r\nBT_UART_MSG_FRAME3MASTER_POS,\r\n(BT_UART_MSG_FRAME3OBEX_MSK & uart_msg->frame3) >>\r\nBT_UART_MSG_FRAME3OBEX_POS);\r\nIWL_DEBUG_COEX(priv, "Idle duration = 0x%X\n",\r\n(BT_UART_MSG_FRAME4IDLEDURATION_MSK & uart_msg->frame4) >>\r\nBT_UART_MSG_FRAME4IDLEDURATION_POS);\r\nIWL_DEBUG_COEX(priv, "Tx Activity = 0x%X, Rx Activity = 0x%X, "\r\n"eSCO Retransmissions = 0x%X\n",\r\n(BT_UART_MSG_FRAME5TXACTIVITY_MSK & uart_msg->frame5) >>\r\nBT_UART_MSG_FRAME5TXACTIVITY_POS,\r\n(BT_UART_MSG_FRAME5RXACTIVITY_MSK & uart_msg->frame5) >>\r\nBT_UART_MSG_FRAME5RXACTIVITY_POS,\r\n(BT_UART_MSG_FRAME5ESCORETRANSMIT_MSK & uart_msg->frame5) >>\r\nBT_UART_MSG_FRAME5ESCORETRANSMIT_POS);\r\nIWL_DEBUG_COEX(priv, "Sniff Interval = 0x%X, Discoverable = 0x%X\n",\r\n(BT_UART_MSG_FRAME6SNIFFINTERVAL_MSK & uart_msg->frame6) >>\r\nBT_UART_MSG_FRAME6SNIFFINTERVAL_POS,\r\n(BT_UART_MSG_FRAME6DISCOVERABLE_MSK & uart_msg->frame6) >>\r\nBT_UART_MSG_FRAME6DISCOVERABLE_POS);\r\nIWL_DEBUG_COEX(priv, "Sniff Activity = 0x%X, Page = "\r\n"0x%X, Inquiry = 0x%X, Connectable = 0x%X\n",\r\n(BT_UART_MSG_FRAME7SNIFFACTIVITY_MSK & uart_msg->frame7) >>\r\nBT_UART_MSG_FRAME7SNIFFACTIVITY_POS,\r\n(BT_UART_MSG_FRAME7PAGE_MSK & uart_msg->frame7) >>\r\nBT_UART_MSG_FRAME7PAGE_POS,\r\n(BT_UART_MSG_FRAME7INQUIRY_MSK & uart_msg->frame7) >>\r\nBT_UART_MSG_FRAME7INQUIRY_POS,\r\n(BT_UART_MSG_FRAME7CONNECTABLE_MSK & uart_msg->frame7) >>\r\nBT_UART_MSG_FRAME7CONNECTABLE_POS);\r\n}\r\nstatic bool iwlagn_set_kill_msk(struct iwl_priv *priv,\r\nstruct iwl_bt_uart_msg *uart_msg)\r\n{\r\nbool need_update = false;\r\nu8 kill_msk = IWL_BT_KILL_REDUCE;\r\nstatic const __le32 bt_kill_ack_msg[3] = {\r\nIWLAGN_BT_KILL_ACK_MASK_DEFAULT,\r\nIWLAGN_BT_KILL_ACK_CTS_MASK_SCO,\r\nIWLAGN_BT_KILL_ACK_CTS_MASK_REDUCE};\r\nstatic const __le32 bt_kill_cts_msg[3] = {\r\nIWLAGN_BT_KILL_CTS_MASK_DEFAULT,\r\nIWLAGN_BT_KILL_ACK_CTS_MASK_SCO,\r\nIWLAGN_BT_KILL_ACK_CTS_MASK_REDUCE};\r\nif (!priv->reduced_txpower)\r\nkill_msk = (BT_UART_MSG_FRAME3SCOESCO_MSK & uart_msg->frame3)\r\n? IWL_BT_KILL_OVERRIDE : IWL_BT_KILL_DEFAULT;\r\nif (priv->kill_ack_mask != bt_kill_ack_msg[kill_msk] ||\r\npriv->kill_cts_mask != bt_kill_cts_msg[kill_msk]) {\r\npriv->bt_valid |= IWLAGN_BT_VALID_KILL_ACK_MASK;\r\npriv->kill_ack_mask = bt_kill_ack_msg[kill_msk];\r\npriv->bt_valid |= IWLAGN_BT_VALID_KILL_CTS_MASK;\r\npriv->kill_cts_mask = bt_kill_cts_msg[kill_msk];\r\nneed_update = true;\r\n}\r\nreturn need_update;\r\n}\r\nstatic bool iwlagn_fill_txpower_mode(struct iwl_priv *priv,\r\nstruct iwl_bt_uart_msg *uart_msg)\r\n{\r\nbool need_update = false;\r\nstruct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];\r\nint ave_rssi;\r\nif (!ctx->vif || (ctx->vif->type != NL80211_IFTYPE_STATION)) {\r\nIWL_DEBUG_INFO(priv, "BSS ctx not active or not in sta mode\n");\r\nreturn false;\r\n}\r\nave_rssi = ieee80211_ave_rssi(ctx->vif);\r\nif (!ave_rssi) {\r\nIWL_DEBUG_COEX(priv, "no rssi data available\n");\r\nreturn need_update;\r\n}\r\nif (!priv->reduced_txpower &&\r\n!iwl_is_associated(priv, IWL_RXON_CTX_PAN) &&\r\n(ave_rssi > BT_ENABLE_REDUCED_TXPOWER_THRESHOLD) &&\r\n(uart_msg->frame3 & (BT_UART_MSG_FRAME3ACL_MSK |\r\nBT_UART_MSG_FRAME3OBEX_MSK)) &&\r\n!(uart_msg->frame3 & (BT_UART_MSG_FRAME3SCOESCO_MSK |\r\nBT_UART_MSG_FRAME3SNIFF_MSK | BT_UART_MSG_FRAME3A2DP_MSK))) {\r\npriv->reduced_txpower = true;\r\npriv->bt_valid |= IWLAGN_BT_VALID_REDUCED_TX_PWR;\r\nneed_update = true;\r\n} else if (priv->reduced_txpower &&\r\n(iwl_is_associated(priv, IWL_RXON_CTX_PAN) ||\r\n(ave_rssi < BT_DISABLE_REDUCED_TXPOWER_THRESHOLD) ||\r\n(uart_msg->frame3 & (BT_UART_MSG_FRAME3SCOESCO_MSK |\r\nBT_UART_MSG_FRAME3SNIFF_MSK | BT_UART_MSG_FRAME3A2DP_MSK)) ||\r\n!(uart_msg->frame3 & (BT_UART_MSG_FRAME3ACL_MSK |\r\nBT_UART_MSG_FRAME3OBEX_MSK)))) {\r\npriv->reduced_txpower = false;\r\npriv->bt_valid |= IWLAGN_BT_VALID_REDUCED_TX_PWR;\r\nneed_update = true;\r\n}\r\nreturn need_update;\r\n}\r\nint iwlagn_bt_coex_profile_notif(struct iwl_priv *priv,\r\nstruct iwl_rx_cmd_buffer *rxb,\r\nstruct iwl_device_cmd *cmd)\r\n{\r\nstruct iwl_rx_packet *pkt = rxb_addr(rxb);\r\nstruct iwl_bt_coex_profile_notif *coex = (void *)pkt->data;\r\nstruct iwl_bt_uart_msg *uart_msg = &coex->last_bt_uart_msg;\r\nif (priv->bt_enable_flag == IWLAGN_BT_FLAG_COEX_MODE_DISABLED) {\r\nreturn 0;\r\n}\r\nIWL_DEBUG_COEX(priv, "BT Coex notification:\n");\r\nIWL_DEBUG_COEX(priv, " status: %d\n", coex->bt_status);\r\nIWL_DEBUG_COEX(priv, " traffic load: %d\n", coex->bt_traffic_load);\r\nIWL_DEBUG_COEX(priv, " CI compliance: %d\n",\r\ncoex->bt_ci_compliance);\r\niwlagn_print_uartmsg(priv, uart_msg);\r\npriv->last_bt_traffic_load = priv->bt_traffic_load;\r\npriv->bt_is_sco = iwlagn_bt_traffic_is_sco(uart_msg);\r\nif (priv->iw_mode != NL80211_IFTYPE_ADHOC) {\r\nif (priv->bt_status != coex->bt_status ||\r\npriv->last_bt_traffic_load != coex->bt_traffic_load) {\r\nif (coex->bt_status) {\r\nif (!priv->bt_ch_announce)\r\npriv->bt_traffic_load =\r\nIWL_BT_COEX_TRAFFIC_LOAD_HIGH;\r\nelse\r\npriv->bt_traffic_load =\r\ncoex->bt_traffic_load;\r\n} else {\r\npriv->bt_traffic_load =\r\nIWL_BT_COEX_TRAFFIC_LOAD_NONE;\r\n}\r\npriv->bt_status = coex->bt_status;\r\nqueue_work(priv->workqueue,\r\n&priv->bt_traffic_change_work);\r\n}\r\n}\r\nif (iwlagn_fill_txpower_mode(priv, uart_msg) ||\r\niwlagn_set_kill_msk(priv, uart_msg))\r\nqueue_work(priv->workqueue, &priv->bt_runtime_config);\r\npriv->bt_ci_compliance = coex->bt_ci_compliance;\r\nreturn 0;\r\n}\r\nvoid iwlagn_bt_rx_handler_setup(struct iwl_priv *priv)\r\n{\r\npriv->rx_handlers[REPLY_BT_COEX_PROFILE_NOTIF] =\r\niwlagn_bt_coex_profile_notif;\r\n}\r\nvoid iwlagn_bt_setup_deferred_work(struct iwl_priv *priv)\r\n{\r\nINIT_WORK(&priv->bt_traffic_change_work,\r\niwlagn_bt_traffic_change_work);\r\n}\r\nvoid iwlagn_bt_cancel_deferred_work(struct iwl_priv *priv)\r\n{\r\ncancel_work_sync(&priv->bt_traffic_change_work);\r\n}\r\nstatic bool is_single_rx_stream(struct iwl_priv *priv)\r\n{\r\nreturn priv->current_ht_config.smps == IEEE80211_SMPS_STATIC ||\r\npriv->current_ht_config.single_chain_sufficient;\r\n}\r\nstatic int iwl_get_active_rx_chain_count(struct iwl_priv *priv)\r\n{\r\nif (priv->lib->bt_params &&\r\npriv->lib->bt_params->advanced_bt_coexist &&\r\n(priv->bt_full_concurrent ||\r\npriv->bt_traffic_load >= IWL_BT_COEX_TRAFFIC_LOAD_HIGH)) {\r\nreturn IWL_NUM_RX_CHAINS_SINGLE;\r\n}\r\nif (is_single_rx_stream(priv))\r\nreturn IWL_NUM_RX_CHAINS_SINGLE;\r\nelse\r\nreturn IWL_NUM_RX_CHAINS_MULTIPLE;\r\n}\r\nstatic int iwl_get_idle_rx_chain_count(struct iwl_priv *priv, int active_cnt)\r\n{\r\nswitch (priv->current_ht_config.smps) {\r\ncase IEEE80211_SMPS_STATIC:\r\ncase IEEE80211_SMPS_DYNAMIC:\r\nreturn IWL_NUM_IDLE_CHAINS_SINGLE;\r\ncase IEEE80211_SMPS_AUTOMATIC:\r\ncase IEEE80211_SMPS_OFF:\r\nreturn active_cnt;\r\ndefault:\r\nWARN(1, "invalid SMPS mode %d",\r\npriv->current_ht_config.smps);\r\nreturn active_cnt;\r\n}\r\n}\r\nstatic u8 iwl_count_chain_bitmap(u32 chain_bitmap)\r\n{\r\nu8 res;\r\nres = (chain_bitmap & BIT(0)) >> 0;\r\nres += (chain_bitmap & BIT(1)) >> 1;\r\nres += (chain_bitmap & BIT(2)) >> 2;\r\nres += (chain_bitmap & BIT(3)) >> 3;\r\nreturn res;\r\n}\r\nvoid iwlagn_set_rxon_chain(struct iwl_priv *priv, struct iwl_rxon_context *ctx)\r\n{\r\nbool is_single = is_single_rx_stream(priv);\r\nbool is_cam = !test_bit(STATUS_POWER_PMI, &priv->status);\r\nu8 idle_rx_cnt, active_rx_cnt, valid_rx_cnt;\r\nu32 active_chains;\r\nu16 rx_chain;\r\nif (priv->chain_noise_data.active_chains)\r\nactive_chains = priv->chain_noise_data.active_chains;\r\nelse\r\nactive_chains = priv->nvm_data->valid_rx_ant;\r\nif (priv->lib->bt_params &&\r\npriv->lib->bt_params->advanced_bt_coexist &&\r\n(priv->bt_full_concurrent ||\r\npriv->bt_traffic_load >= IWL_BT_COEX_TRAFFIC_LOAD_HIGH)) {\r\nactive_chains = first_antenna(active_chains);\r\n}\r\nrx_chain = active_chains << RXON_RX_CHAIN_VALID_POS;\r\nactive_rx_cnt = iwl_get_active_rx_chain_count(priv);\r\nidle_rx_cnt = iwl_get_idle_rx_chain_count(priv, active_rx_cnt);\r\nvalid_rx_cnt = iwl_count_chain_bitmap(active_chains);\r\nif (valid_rx_cnt < active_rx_cnt)\r\nactive_rx_cnt = valid_rx_cnt;\r\nif (valid_rx_cnt < idle_rx_cnt)\r\nidle_rx_cnt = valid_rx_cnt;\r\nrx_chain |= active_rx_cnt << RXON_RX_CHAIN_MIMO_CNT_POS;\r\nrx_chain |= idle_rx_cnt << RXON_RX_CHAIN_CNT_POS;\r\nctx->staging.rx_chain = cpu_to_le16(rx_chain);\r\nif (!is_single && (active_rx_cnt >= IWL_NUM_RX_CHAINS_SINGLE) && is_cam)\r\nctx->staging.rx_chain |= RXON_RX_CHAIN_MIMO_FORCE_MSK;\r\nelse\r\nctx->staging.rx_chain &= ~RXON_RX_CHAIN_MIMO_FORCE_MSK;\r\nIWL_DEBUG_ASSOC(priv, "rx_chain=0x%X active=%d idle=%d\n",\r\nctx->staging.rx_chain,\r\nactive_rx_cnt, idle_rx_cnt);\r\nWARN_ON(active_rx_cnt == 0 || idle_rx_cnt == 0 ||\r\nactive_rx_cnt < idle_rx_cnt);\r\n}\r\nu8 iwl_toggle_tx_ant(struct iwl_priv *priv, u8 ant, u8 valid)\r\n{\r\nint i;\r\nu8 ind = ant;\r\nif (priv->band == IEEE80211_BAND_2GHZ &&\r\npriv->bt_traffic_load >= IWL_BT_COEX_TRAFFIC_LOAD_HIGH)\r\nreturn 0;\r\nfor (i = 0; i < RATE_ANT_NUM - 1; i++) {\r\nind = (ind + 1) < RATE_ANT_NUM ? ind + 1 : 0;\r\nif (valid & BIT(ind))\r\nreturn ind;\r\n}\r\nreturn ant;\r\n}\r\nstatic void iwlagn_convert_p1k(u16 *p1k, __le16 *out)\r\n{\r\nint i;\r\nfor (i = 0; i < IWLAGN_P1K_SIZE; i++)\r\nout[i] = cpu_to_le16(p1k[i]);\r\n}\r\nstatic void iwlagn_wowlan_program_keys(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta,\r\nstruct ieee80211_key_conf *key,\r\nvoid *_data)\r\n{\r\nstruct iwl_priv *priv = IWL_MAC80211_GET_DVM(hw);\r\nstruct wowlan_key_data *data = _data;\r\nstruct iwl_rxon_context *ctx = data->ctx;\r\nstruct aes_sc *aes_sc, *aes_tx_sc = NULL;\r\nstruct tkip_sc *tkip_sc, *tkip_tx_sc = NULL;\r\nstruct iwlagn_p1k_cache *rx_p1ks;\r\nu8 *rx_mic_key;\r\nstruct ieee80211_key_seq seq;\r\nu32 cur_rx_iv32 = 0;\r\nu16 p1k[IWLAGN_P1K_SIZE];\r\nint ret, i;\r\nmutex_lock(&priv->mutex);\r\nif ((key->cipher == WLAN_CIPHER_SUITE_WEP40 ||\r\nkey->cipher == WLAN_CIPHER_SUITE_WEP104) &&\r\n!sta && !ctx->key_mapping_keys)\r\nret = iwl_set_default_wep_key(priv, ctx, key);\r\nelse\r\nret = iwl_set_dynamic_key(priv, ctx, key, sta);\r\nif (ret) {\r\nIWL_ERR(priv, "Error setting key during suspend!\n");\r\ndata->error = true;\r\n}\r\nswitch (key->cipher) {\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nif (sta) {\r\ntkip_sc = data->rsc_tsc->all_tsc_rsc.tkip.unicast_rsc;\r\ntkip_tx_sc = &data->rsc_tsc->all_tsc_rsc.tkip.tsc;\r\nrx_p1ks = data->tkip->rx_uni;\r\nieee80211_get_key_tx_seq(key, &seq);\r\ntkip_tx_sc->iv16 = cpu_to_le16(seq.tkip.iv16);\r\ntkip_tx_sc->iv32 = cpu_to_le32(seq.tkip.iv32);\r\nieee80211_get_tkip_p1k_iv(key, seq.tkip.iv32, p1k);\r\niwlagn_convert_p1k(p1k, data->tkip->tx.p1k);\r\nmemcpy(data->tkip->mic_keys.tx,\r\n&key->key[NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY],\r\nIWLAGN_MIC_KEY_SIZE);\r\nrx_mic_key = data->tkip->mic_keys.rx_unicast;\r\n} else {\r\ntkip_sc =\r\ndata->rsc_tsc->all_tsc_rsc.tkip.multicast_rsc;\r\nrx_p1ks = data->tkip->rx_multi;\r\nrx_mic_key = data->tkip->mic_keys.rx_mcast;\r\n}\r\nfor (i = 0; i < IWLAGN_NUM_RSC; i++) {\r\nieee80211_get_key_rx_seq(key, i, &seq);\r\ntkip_sc[i].iv16 = cpu_to_le16(seq.tkip.iv16);\r\ntkip_sc[i].iv32 = cpu_to_le32(seq.tkip.iv32);\r\nif (seq.tkip.iv32 > cur_rx_iv32)\r\ncur_rx_iv32 = seq.tkip.iv32;\r\n}\r\nieee80211_get_tkip_rx_p1k(key, data->bssid, cur_rx_iv32, p1k);\r\niwlagn_convert_p1k(p1k, rx_p1ks[0].p1k);\r\nieee80211_get_tkip_rx_p1k(key, data->bssid,\r\ncur_rx_iv32 + 1, p1k);\r\niwlagn_convert_p1k(p1k, rx_p1ks[1].p1k);\r\nmemcpy(rx_mic_key,\r\n&key->key[NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY],\r\nIWLAGN_MIC_KEY_SIZE);\r\ndata->use_tkip = true;\r\ndata->use_rsc_tsc = true;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nif (sta) {\r\nu8 *pn = seq.ccmp.pn;\r\naes_sc = data->rsc_tsc->all_tsc_rsc.aes.unicast_rsc;\r\naes_tx_sc = &data->rsc_tsc->all_tsc_rsc.aes.tsc;\r\nieee80211_get_key_tx_seq(key, &seq);\r\naes_tx_sc->pn = cpu_to_le64(\r\n(u64)pn[5] |\r\n((u64)pn[4] << 8) |\r\n((u64)pn[3] << 16) |\r\n((u64)pn[2] << 24) |\r\n((u64)pn[1] << 32) |\r\n((u64)pn[0] << 40));\r\n} else\r\naes_sc = data->rsc_tsc->all_tsc_rsc.aes.multicast_rsc;\r\nfor (i = 0; i < IWLAGN_NUM_RSC; i++) {\r\nu8 *pn = seq.ccmp.pn;\r\nieee80211_get_key_rx_seq(key, i, &seq);\r\naes_sc->pn = cpu_to_le64(\r\n(u64)pn[5] |\r\n((u64)pn[4] << 8) |\r\n((u64)pn[3] << 16) |\r\n((u64)pn[2] << 24) |\r\n((u64)pn[1] << 32) |\r\n((u64)pn[0] << 40));\r\n}\r\ndata->use_rsc_tsc = true;\r\nbreak;\r\n}\r\nmutex_unlock(&priv->mutex);\r\n}\r\nint iwlagn_send_patterns(struct iwl_priv *priv,\r\nstruct cfg80211_wowlan *wowlan)\r\n{\r\nstruct iwlagn_wowlan_patterns_cmd *pattern_cmd;\r\nstruct iwl_host_cmd cmd = {\r\n.id = REPLY_WOWLAN_PATTERNS,\r\n.dataflags[0] = IWL_HCMD_DFL_NOCOPY,\r\n};\r\nint i, err;\r\nif (!wowlan->n_patterns)\r\nreturn 0;\r\ncmd.len[0] = sizeof(*pattern_cmd) +\r\nwowlan->n_patterns * sizeof(struct iwlagn_wowlan_pattern);\r\npattern_cmd = kmalloc(cmd.len[0], GFP_KERNEL);\r\nif (!pattern_cmd)\r\nreturn -ENOMEM;\r\npattern_cmd->n_patterns = cpu_to_le32(wowlan->n_patterns);\r\nfor (i = 0; i < wowlan->n_patterns; i++) {\r\nint mask_len = DIV_ROUND_UP(wowlan->patterns[i].pattern_len, 8);\r\nmemcpy(&pattern_cmd->patterns[i].mask,\r\nwowlan->patterns[i].mask, mask_len);\r\nmemcpy(&pattern_cmd->patterns[i].pattern,\r\nwowlan->patterns[i].pattern,\r\nwowlan->patterns[i].pattern_len);\r\npattern_cmd->patterns[i].mask_size = mask_len;\r\npattern_cmd->patterns[i].pattern_size =\r\nwowlan->patterns[i].pattern_len;\r\n}\r\ncmd.data[0] = pattern_cmd;\r\nerr = iwl_dvm_send_cmd(priv, &cmd);\r\nkfree(pattern_cmd);\r\nreturn err;\r\n}\r\nint iwlagn_suspend(struct iwl_priv *priv, struct cfg80211_wowlan *wowlan)\r\n{\r\nstruct iwlagn_wowlan_wakeup_filter_cmd wakeup_filter_cmd;\r\nstruct iwl_rxon_cmd rxon;\r\nstruct iwl_rxon_context *ctx = &priv->contexts[IWL_RXON_CTX_BSS];\r\nstruct iwlagn_wowlan_kek_kck_material_cmd kek_kck_cmd;\r\nstruct iwlagn_wowlan_tkip_params_cmd tkip_cmd = {};\r\nstruct iwlagn_d3_config_cmd d3_cfg_cmd = {\r\n.min_sleep_time = cpu_to_le32(10 * 1000 * 1000),\r\n};\r\nstruct wowlan_key_data key_data = {\r\n.ctx = ctx,\r\n.bssid = ctx->active.bssid_addr,\r\n.use_rsc_tsc = false,\r\n.tkip = &tkip_cmd,\r\n.use_tkip = false,\r\n};\r\nint ret, i;\r\nu16 seq;\r\nkey_data.rsc_tsc = kzalloc(sizeof(*key_data.rsc_tsc), GFP_KERNEL);\r\nif (!key_data.rsc_tsc)\r\nreturn -ENOMEM;\r\nmemset(&wakeup_filter_cmd, 0, sizeof(wakeup_filter_cmd));\r\nseq = le16_to_cpu(priv->last_seq_ctl) & IEEE80211_SCTL_SEQ;\r\nwakeup_filter_cmd.non_qos_seq = cpu_to_le16(seq);\r\nfor (i = 0; i < IWL_MAX_TID_COUNT; i++) {\r\nseq = priv->tid_data[IWL_AP_ID][i].seq_number;\r\nseq -= 0x10;\r\nwakeup_filter_cmd.qos_seq[i] = cpu_to_le16(seq);\r\n}\r\nif (wowlan->disconnect)\r\nwakeup_filter_cmd.enabled |=\r\ncpu_to_le32(IWLAGN_WOWLAN_WAKEUP_BEACON_MISS |\r\nIWLAGN_WOWLAN_WAKEUP_LINK_CHANGE);\r\nif (wowlan->magic_pkt)\r\nwakeup_filter_cmd.enabled |=\r\ncpu_to_le32(IWLAGN_WOWLAN_WAKEUP_MAGIC_PACKET);\r\nif (wowlan->gtk_rekey_failure)\r\nwakeup_filter_cmd.enabled |=\r\ncpu_to_le32(IWLAGN_WOWLAN_WAKEUP_GTK_REKEY_FAIL);\r\nif (wowlan->eap_identity_req)\r\nwakeup_filter_cmd.enabled |=\r\ncpu_to_le32(IWLAGN_WOWLAN_WAKEUP_EAP_IDENT_REQ);\r\nif (wowlan->four_way_handshake)\r\nwakeup_filter_cmd.enabled |=\r\ncpu_to_le32(IWLAGN_WOWLAN_WAKEUP_4WAY_HANDSHAKE);\r\nif (wowlan->n_patterns)\r\nwakeup_filter_cmd.enabled |=\r\ncpu_to_le32(IWLAGN_WOWLAN_WAKEUP_PATTERN_MATCH);\r\nif (wowlan->rfkill_release)\r\nd3_cfg_cmd.wakeup_flags |=\r\ncpu_to_le32(IWLAGN_D3_WAKEUP_RFKILL);\r\niwl_scan_cancel_timeout(priv, 200);\r\nmemcpy(&rxon, &ctx->active, sizeof(rxon));\r\npriv->ucode_loaded = false;\r\niwl_trans_stop_device(priv->trans);\r\npriv->wowlan = true;\r\nret = iwl_load_ucode_wait_alive(priv, IWL_UCODE_WOWLAN);\r\nif (ret)\r\ngoto out;\r\nret = iwl_alive_start(priv);\r\nif (ret)\r\ngoto out;\r\nmemcpy(&ctx->staging, &rxon, sizeof(rxon));\r\nret = iwlagn_commit_rxon(priv, ctx);\r\nif (ret)\r\ngoto out;\r\nret = iwl_power_update_mode(priv, true);\r\nif (ret)\r\ngoto out;\r\nif (!iwlwifi_mod_params.sw_crypto) {\r\npriv->ucode_key_table = 0;\r\nctx->key_mapping_keys = 0;\r\nmutex_unlock(&priv->mutex);\r\nieee80211_iter_keys(priv->hw, ctx->vif,\r\niwlagn_wowlan_program_keys,\r\n&key_data);\r\nmutex_lock(&priv->mutex);\r\nif (key_data.error) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (key_data.use_rsc_tsc) {\r\nstruct iwl_host_cmd rsc_tsc_cmd = {\r\n.id = REPLY_WOWLAN_TSC_RSC_PARAMS,\r\n.data[0] = key_data.rsc_tsc,\r\n.dataflags[0] = IWL_HCMD_DFL_NOCOPY,\r\n.len[0] = sizeof(*key_data.rsc_tsc),\r\n};\r\nret = iwl_dvm_send_cmd(priv, &rsc_tsc_cmd);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (key_data.use_tkip) {\r\nret = iwl_dvm_send_cmd_pdu(priv,\r\nREPLY_WOWLAN_TKIP_PARAMS,\r\n0, sizeof(tkip_cmd),\r\n&tkip_cmd);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (priv->have_rekey_data) {\r\nmemset(&kek_kck_cmd, 0, sizeof(kek_kck_cmd));\r\nmemcpy(kek_kck_cmd.kck, priv->kck, NL80211_KCK_LEN);\r\nkek_kck_cmd.kck_len = cpu_to_le16(NL80211_KCK_LEN);\r\nmemcpy(kek_kck_cmd.kek, priv->kek, NL80211_KEK_LEN);\r\nkek_kck_cmd.kek_len = cpu_to_le16(NL80211_KEK_LEN);\r\nkek_kck_cmd.replay_ctr = priv->replay_ctr;\r\nret = iwl_dvm_send_cmd_pdu(priv,\r\nREPLY_WOWLAN_KEK_KCK_MATERIAL,\r\n0, sizeof(kek_kck_cmd),\r\n&kek_kck_cmd);\r\nif (ret)\r\ngoto out;\r\n}\r\n}\r\nret = iwl_dvm_send_cmd_pdu(priv, REPLY_D3_CONFIG, 0,\r\nsizeof(d3_cfg_cmd), &d3_cfg_cmd);\r\nif (ret)\r\ngoto out;\r\nret = iwl_dvm_send_cmd_pdu(priv, REPLY_WOWLAN_WAKEUP_FILTER,\r\n0, sizeof(wakeup_filter_cmd),\r\n&wakeup_filter_cmd);\r\nif (ret)\r\ngoto out;\r\nret = iwlagn_send_patterns(priv, wowlan);\r\nout:\r\nkfree(key_data.rsc_tsc);\r\nreturn ret;\r\n}\r\nint iwl_dvm_send_cmd(struct iwl_priv *priv, struct iwl_host_cmd *cmd)\r\n{\r\nif (iwl_is_rfkill(priv) || iwl_is_ctkill(priv)) {\r\nIWL_WARN(priv, "Not sending command - %s KILL\n",\r\niwl_is_rfkill(priv) ? "RF" : "CT");\r\nreturn -EIO;\r\n}\r\nif (test_bit(STATUS_FW_ERROR, &priv->status)) {\r\nIWL_ERR(priv, "Command %s failed: FW Error\n",\r\niwl_dvm_get_cmd_string(cmd->id));\r\nreturn -EIO;\r\n}\r\nif (!priv->ucode_loaded) {\r\nIWL_ERR(priv, "Fw not loaded - dropping CMD: %x\n", cmd->id);\r\nreturn -EIO;\r\n}\r\nif (!(cmd->flags & CMD_ASYNC))\r\nlockdep_assert_held(&priv->mutex);\r\nreturn iwl_trans_send_cmd(priv->trans, cmd);\r\n}\r\nint iwl_dvm_send_cmd_pdu(struct iwl_priv *priv, u8 id,\r\nu32 flags, u16 len, const void *data)\r\n{\r\nstruct iwl_host_cmd cmd = {\r\n.id = id,\r\n.len = { len, },\r\n.data = { data, },\r\n.flags = flags,\r\n};\r\nreturn iwl_dvm_send_cmd(priv, &cmd);\r\n}
