static struct usb_request *\r\nprinter_req_alloc(struct usb_ep *ep, unsigned len, gfp_t gfp_flags)\r\n{\r\nstruct usb_request *req;\r\nreq = usb_ep_alloc_request(ep, gfp_flags);\r\nif (req != NULL) {\r\nreq->length = len;\r\nreq->buf = kmalloc(len, gfp_flags);\r\nif (req->buf == NULL) {\r\nusb_ep_free_request(ep, req);\r\nreturn NULL;\r\n}\r\n}\r\nreturn req;\r\n}\r\nstatic void\r\nprinter_req_free(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nif (ep != NULL && req != NULL) {\r\nkfree(req->buf);\r\nusb_ep_free_request(ep, req);\r\n}\r\n}\r\nstatic void rx_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct printer_dev *dev = ep->driver_data;\r\nint status = req->status;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nlist_del_init(&req->list);\r\nswitch (status) {\r\ncase 0:\r\nif (req->actual > 0) {\r\nlist_add_tail(&req->list, &dev->rx_buffers);\r\nDBG(dev, "G_Printer : rx length %d\n", req->actual);\r\n} else {\r\nlist_add(&req->list, &dev->rx_reqs);\r\n}\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nVDBG(dev, "rx shutdown, code %d\n", status);\r\nlist_add(&req->list, &dev->rx_reqs);\r\nbreak;\r\ncase -ECONNABORTED:\r\nDBG(dev, "rx %s reset\n", ep->name);\r\nlist_add(&req->list, &dev->rx_reqs);\r\nbreak;\r\ncase -EOVERFLOW:\r\ndefault:\r\nDBG(dev, "rx status %d\n", status);\r\nlist_add(&req->list, &dev->rx_reqs);\r\nbreak;\r\n}\r\nwake_up_interruptible(&dev->rx_wait);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\n}\r\nstatic void tx_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct printer_dev *dev = ep->driver_data;\r\nswitch (req->status) {\r\ndefault:\r\nVDBG(dev, "tx err %d\n", req->status);\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nbreak;\r\ncase 0:\r\nbreak;\r\n}\r\nspin_lock(&dev->lock);\r\nlist_del_init(&req->list);\r\nlist_add(&req->list, &dev->tx_reqs);\r\nwake_up_interruptible(&dev->tx_wait);\r\nif (likely(list_empty(&dev->tx_reqs_active)))\r\nwake_up_interruptible(&dev->tx_flush_wait);\r\nspin_unlock(&dev->lock);\r\n}\r\nstatic int\r\nprinter_open(struct inode *inode, struct file *fd)\r\n{\r\nstruct printer_dev *dev;\r\nunsigned long flags;\r\nint ret = -EBUSY;\r\nmutex_lock(&printer_mutex);\r\ndev = container_of(inode->i_cdev, struct printer_dev, printer_cdev);\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (!dev->printer_cdev_open) {\r\ndev->printer_cdev_open = 1;\r\nfd->private_data = dev;\r\nret = 0;\r\ndev->printer_status |= PRINTER_SELECTED;\r\n}\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nDBG(dev, "printer_open returned %x\n", ret);\r\nmutex_unlock(&printer_mutex);\r\nreturn ret;\r\n}\r\nstatic int\r\nprinter_close(struct inode *inode, struct file *fd)\r\n{\r\nstruct printer_dev *dev = fd->private_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->lock, flags);\r\ndev->printer_cdev_open = 0;\r\nfd->private_data = NULL;\r\ndev->printer_status &= ~PRINTER_SELECTED;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nDBG(dev, "printer_close\n");\r\nreturn 0;\r\n}\r\nstatic void\r\nsetup_rx_reqs(struct printer_dev *dev)\r\n{\r\nstruct usb_request *req;\r\nwhile (likely(!list_empty(&dev->rx_reqs))) {\r\nint error;\r\nreq = container_of(dev->rx_reqs.next,\r\nstruct usb_request, list);\r\nlist_del_init(&req->list);\r\nreq->length = USB_BUFSIZE;\r\nreq->complete = rx_complete;\r\nspin_unlock(&dev->lock);\r\nerror = usb_ep_queue(dev->out_ep, req, GFP_ATOMIC);\r\nspin_lock(&dev->lock);\r\nif (error) {\r\nDBG(dev, "rx submit --> %d\n", error);\r\nlist_add(&req->list, &dev->rx_reqs);\r\nbreak;\r\n}\r\nelse if (list_empty(&req->list)) {\r\nlist_add(&req->list, &dev->rx_reqs_active);\r\n}\r\n}\r\n}\r\nstatic ssize_t\r\nprinter_read(struct file *fd, char __user *buf, size_t len, loff_t *ptr)\r\n{\r\nstruct printer_dev *dev = fd->private_data;\r\nunsigned long flags;\r\nsize_t size;\r\nsize_t bytes_copied;\r\nstruct usb_request *req;\r\nstruct usb_request *current_rx_req;\r\nsize_t current_rx_bytes;\r\nu8 *current_rx_buf;\r\nif (len == 0)\r\nreturn -EINVAL;\r\nDBG(dev, "printer_read trying to read %d bytes\n", (int)len);\r\nmutex_lock(&dev->lock_printer_io);\r\nspin_lock_irqsave(&dev->lock, flags);\r\ndev->reset_printer = 0;\r\nsetup_rx_reqs(dev);\r\nbytes_copied = 0;\r\ncurrent_rx_req = dev->current_rx_req;\r\ncurrent_rx_bytes = dev->current_rx_bytes;\r\ncurrent_rx_buf = dev->current_rx_buf;\r\ndev->current_rx_req = NULL;\r\ndev->current_rx_bytes = 0;\r\ndev->current_rx_buf = NULL;\r\nif ((current_rx_bytes == 0) &&\r\n(likely(list_empty(&dev->rx_buffers)))) {\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (fd->f_flags & (O_NONBLOCK|O_NDELAY)) {\r\nmutex_unlock(&dev->lock_printer_io);\r\nreturn -EAGAIN;\r\n}\r\nwait_event_interruptible(dev->rx_wait,\r\n(likely(!list_empty(&dev->rx_buffers))));\r\nspin_lock_irqsave(&dev->lock, flags);\r\n}\r\nwhile ((current_rx_bytes || likely(!list_empty(&dev->rx_buffers)))\r\n&& len) {\r\nif (current_rx_bytes == 0) {\r\nreq = container_of(dev->rx_buffers.next,\r\nstruct usb_request, list);\r\nlist_del_init(&req->list);\r\nif (req->actual && req->buf) {\r\ncurrent_rx_req = req;\r\ncurrent_rx_bytes = req->actual;\r\ncurrent_rx_buf = req->buf;\r\n} else {\r\nlist_add(&req->list, &dev->rx_reqs);\r\ncontinue;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (len > current_rx_bytes)\r\nsize = current_rx_bytes;\r\nelse\r\nsize = len;\r\nsize -= copy_to_user(buf, current_rx_buf, size);\r\nbytes_copied += size;\r\nlen -= size;\r\nbuf += size;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (dev->reset_printer) {\r\nlist_add(&current_rx_req->list, &dev->rx_reqs);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nmutex_unlock(&dev->lock_printer_io);\r\nreturn -EAGAIN;\r\n}\r\nif (size < current_rx_bytes) {\r\ncurrent_rx_bytes -= size;\r\ncurrent_rx_buf += size;\r\n} else {\r\nlist_add(&current_rx_req->list, &dev->rx_reqs);\r\ncurrent_rx_bytes = 0;\r\ncurrent_rx_buf = NULL;\r\ncurrent_rx_req = NULL;\r\n}\r\n}\r\ndev->current_rx_req = current_rx_req;\r\ndev->current_rx_bytes = current_rx_bytes;\r\ndev->current_rx_buf = current_rx_buf;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nmutex_unlock(&dev->lock_printer_io);\r\nDBG(dev, "printer_read returned %d bytes\n", (int)bytes_copied);\r\nif (bytes_copied)\r\nreturn bytes_copied;\r\nelse\r\nreturn -EAGAIN;\r\n}\r\nstatic ssize_t\r\nprinter_write(struct file *fd, const char __user *buf, size_t len, loff_t *ptr)\r\n{\r\nstruct printer_dev *dev = fd->private_data;\r\nunsigned long flags;\r\nsize_t size;\r\nsize_t bytes_copied = 0;\r\nstruct usb_request *req;\r\nDBG(dev, "printer_write trying to send %d bytes\n", (int)len);\r\nif (len == 0)\r\nreturn -EINVAL;\r\nmutex_lock(&dev->lock_printer_io);\r\nspin_lock_irqsave(&dev->lock, flags);\r\ndev->reset_printer = 0;\r\nif (likely(list_empty(&dev->tx_reqs))) {\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (fd->f_flags & (O_NONBLOCK|O_NDELAY)) {\r\nmutex_unlock(&dev->lock_printer_io);\r\nreturn -EAGAIN;\r\n}\r\nwait_event_interruptible(dev->tx_wait,\r\n(likely(!list_empty(&dev->tx_reqs))));\r\nspin_lock_irqsave(&dev->lock, flags);\r\n}\r\nwhile (likely(!list_empty(&dev->tx_reqs)) && len) {\r\nif (len > USB_BUFSIZE)\r\nsize = USB_BUFSIZE;\r\nelse\r\nsize = len;\r\nreq = container_of(dev->tx_reqs.next, struct usb_request,\r\nlist);\r\nlist_del_init(&req->list);\r\nreq->complete = tx_complete;\r\nreq->length = size;\r\nif (len > size)\r\nreq->zero = 0;\r\nelse\r\nreq->zero = ((len % dev->in_ep->maxpacket) == 0);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (copy_from_user(req->buf, buf, size)) {\r\nlist_add(&req->list, &dev->tx_reqs);\r\nmutex_unlock(&dev->lock_printer_io);\r\nreturn bytes_copied;\r\n}\r\nbytes_copied += size;\r\nlen -= size;\r\nbuf += size;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (dev->reset_printer) {\r\nlist_add(&req->list, &dev->tx_reqs);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nmutex_unlock(&dev->lock_printer_io);\r\nreturn -EAGAIN;\r\n}\r\nif (usb_ep_queue(dev->in_ep, req, GFP_ATOMIC)) {\r\nlist_add(&req->list, &dev->tx_reqs);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nmutex_unlock(&dev->lock_printer_io);\r\nreturn -EAGAIN;\r\n}\r\nlist_add(&req->list, &dev->tx_reqs_active);\r\n}\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nmutex_unlock(&dev->lock_printer_io);\r\nDBG(dev, "printer_write sent %d bytes\n", (int)bytes_copied);\r\nif (bytes_copied) {\r\nreturn bytes_copied;\r\n} else {\r\nreturn -EAGAIN;\r\n}\r\n}\r\nstatic int\r\nprinter_fsync(struct file *fd, loff_t start, loff_t end, int datasync)\r\n{\r\nstruct printer_dev *dev = fd->private_data;\r\nstruct inode *inode = file_inode(fd);\r\nunsigned long flags;\r\nint tx_list_empty;\r\nmutex_lock(&inode->i_mutex);\r\nspin_lock_irqsave(&dev->lock, flags);\r\ntx_list_empty = (likely(list_empty(&dev->tx_reqs)));\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (!tx_list_empty) {\r\nwait_event_interruptible(dev->tx_flush_wait,\r\n(likely(list_empty(&dev->tx_reqs_active))));\r\n}\r\nmutex_unlock(&inode->i_mutex);\r\nreturn 0;\r\n}\r\nstatic unsigned int\r\nprinter_poll(struct file *fd, poll_table *wait)\r\n{\r\nstruct printer_dev *dev = fd->private_data;\r\nunsigned long flags;\r\nint status = 0;\r\nmutex_lock(&dev->lock_printer_io);\r\nspin_lock_irqsave(&dev->lock, flags);\r\nsetup_rx_reqs(dev);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nmutex_unlock(&dev->lock_printer_io);\r\npoll_wait(fd, &dev->rx_wait, wait);\r\npoll_wait(fd, &dev->tx_wait, wait);\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (likely(!list_empty(&dev->tx_reqs)))\r\nstatus |= POLLOUT | POLLWRNORM;\r\nif (likely(dev->current_rx_bytes) ||\r\nlikely(!list_empty(&dev->rx_buffers)))\r\nstatus |= POLLIN | POLLRDNORM;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn status;\r\n}\r\nstatic long\r\nprinter_ioctl(struct file *fd, unsigned int code, unsigned long arg)\r\n{\r\nstruct printer_dev *dev = fd->private_data;\r\nunsigned long flags;\r\nint status = 0;\r\nDBG(dev, "printer_ioctl: cmd=0x%4.4x, arg=%lu\n", code, arg);\r\nspin_lock_irqsave(&dev->lock, flags);\r\nswitch (code) {\r\ncase GADGET_GET_PRINTER_STATUS:\r\nstatus = (int)dev->printer_status;\r\nbreak;\r\ncase GADGET_SET_PRINTER_STATUS:\r\ndev->printer_status = (u8)arg;\r\nbreak;\r\ndefault:\r\nDBG(dev, "printer_ioctl: ERROR cmd=0x%4.4xis not supported\n",\r\ncode);\r\nstatus = -ENOTTY;\r\n}\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn status;\r\n}\r\nstatic int\r\nset_printer_interface(struct printer_dev *dev)\r\n{\r\nint result = 0;\r\ndev->in_ep->desc = ep_desc(dev->gadget, &hs_ep_in_desc, &fs_ep_in_desc);\r\ndev->in_ep->driver_data = dev;\r\ndev->out_ep->desc = ep_desc(dev->gadget, &hs_ep_out_desc,\r\n&fs_ep_out_desc);\r\ndev->out_ep->driver_data = dev;\r\nresult = usb_ep_enable(dev->in_ep);\r\nif (result != 0) {\r\nDBG(dev, "enable %s --> %d\n", dev->in_ep->name, result);\r\ngoto done;\r\n}\r\nresult = usb_ep_enable(dev->out_ep);\r\nif (result != 0) {\r\nDBG(dev, "enable %s --> %d\n", dev->in_ep->name, result);\r\ngoto done;\r\n}\r\ndone:\r\nif (result != 0) {\r\n(void) usb_ep_disable(dev->in_ep);\r\n(void) usb_ep_disable(dev->out_ep);\r\ndev->in_ep->desc = NULL;\r\ndev->out_ep->desc = NULL;\r\n}\r\nreturn result;\r\n}\r\nstatic void printer_reset_interface(struct printer_dev *dev)\r\n{\r\nif (dev->interface < 0)\r\nreturn;\r\nDBG(dev, "%s\n", __func__);\r\nif (dev->in_ep->desc)\r\nusb_ep_disable(dev->in_ep);\r\nif (dev->out_ep->desc)\r\nusb_ep_disable(dev->out_ep);\r\ndev->in_ep->desc = NULL;\r\ndev->out_ep->desc = NULL;\r\ndev->interface = -1;\r\n}\r\nstatic int set_interface(struct printer_dev *dev, unsigned number)\r\n{\r\nint result = 0;\r\nprinter_reset_interface(dev);\r\nresult = set_printer_interface(dev);\r\nif (result)\r\nprinter_reset_interface(dev);\r\nelse\r\ndev->interface = number;\r\nif (!result)\r\nINFO(dev, "Using interface %x\n", number);\r\nreturn result;\r\n}\r\nstatic void printer_soft_reset(struct printer_dev *dev)\r\n{\r\nstruct usb_request *req;\r\nINFO(dev, "Received Printer Reset Request\n");\r\nif (usb_ep_disable(dev->in_ep))\r\nDBG(dev, "Failed to disable USB in_ep\n");\r\nif (usb_ep_disable(dev->out_ep))\r\nDBG(dev, "Failed to disable USB out_ep\n");\r\nif (dev->current_rx_req != NULL) {\r\nlist_add(&dev->current_rx_req->list, &dev->rx_reqs);\r\ndev->current_rx_req = NULL;\r\n}\r\ndev->current_rx_bytes = 0;\r\ndev->current_rx_buf = NULL;\r\ndev->reset_printer = 1;\r\nwhile (likely(!(list_empty(&dev->rx_buffers)))) {\r\nreq = container_of(dev->rx_buffers.next, struct usb_request,\r\nlist);\r\nlist_del_init(&req->list);\r\nlist_add(&req->list, &dev->rx_reqs);\r\n}\r\nwhile (likely(!(list_empty(&dev->rx_reqs_active)))) {\r\nreq = container_of(dev->rx_buffers.next, struct usb_request,\r\nlist);\r\nlist_del_init(&req->list);\r\nlist_add(&req->list, &dev->rx_reqs);\r\n}\r\nwhile (likely(!(list_empty(&dev->tx_reqs_active)))) {\r\nreq = container_of(dev->tx_reqs_active.next,\r\nstruct usb_request, list);\r\nlist_del_init(&req->list);\r\nlist_add(&req->list, &dev->tx_reqs);\r\n}\r\nif (usb_ep_enable(dev->in_ep))\r\nDBG(dev, "Failed to enable USB in_ep\n");\r\nif (usb_ep_enable(dev->out_ep))\r\nDBG(dev, "Failed to enable USB out_ep\n");\r\nwake_up_interruptible(&dev->rx_wait);\r\nwake_up_interruptible(&dev->tx_wait);\r\nwake_up_interruptible(&dev->tx_flush_wait);\r\n}\r\nstatic int printer_func_setup(struct usb_function *f,\r\nconst struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct printer_dev *dev = container_of(f, struct printer_dev, function);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct usb_request *req = cdev->req;\r\nint value = -EOPNOTSUPP;\r\nu16 wIndex = le16_to_cpu(ctrl->wIndex);\r\nu16 wValue = le16_to_cpu(ctrl->wValue);\r\nu16 wLength = le16_to_cpu(ctrl->wLength);\r\nDBG(dev, "ctrl req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest, wValue, wIndex, wLength);\r\nswitch (ctrl->bRequestType&USB_TYPE_MASK) {\r\ncase USB_TYPE_CLASS:\r\nswitch (ctrl->bRequest) {\r\ncase 0:\r\nif ((wIndex>>8) != dev->interface)\r\nbreak;\r\nvalue = (pnp_string[0]<<8)|pnp_string[1];\r\nmemcpy(req->buf, pnp_string, value);\r\nDBG(dev, "1284 PNP String: %x %s\n", value,\r\n&pnp_string[2]);\r\nbreak;\r\ncase 1:\r\nif (wIndex != dev->interface)\r\nbreak;\r\n*(u8 *)req->buf = dev->printer_status;\r\nvalue = min(wLength, (u16) 1);\r\nbreak;\r\ncase 2:\r\nif (wIndex != dev->interface)\r\nbreak;\r\nprinter_soft_reset(dev);\r\nvalue = 0;\r\nbreak;\r\ndefault:\r\ngoto unknown;\r\n}\r\nbreak;\r\ndefault:\r\nunknown:\r\nVDBG(dev,\r\n"unknown ctrl req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nwValue, wIndex, wLength);\r\nbreak;\r\n}\r\nreturn value;\r\n}\r\nstatic int __init printer_func_bind(struct usb_configuration *c,\r\nstruct usb_function *f)\r\n{\r\nstruct printer_dev *dev = container_of(f, struct printer_dev, function);\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct usb_ep *in_ep;\r\nstruct usb_ep *out_ep = NULL;\r\nint id;\r\nint ret;\r\nid = usb_interface_id(c, f);\r\nif (id < 0)\r\nreturn id;\r\nintf_desc.bInterfaceNumber = id;\r\nin_ep = usb_ep_autoconfig(cdev->gadget, &fs_ep_in_desc);\r\nif (!in_ep) {\r\nautoconf_fail:\r\ndev_err(&cdev->gadget->dev, "can't autoconfigure on %s\n",\r\ncdev->gadget->name);\r\nreturn -ENODEV;\r\n}\r\nin_ep->driver_data = in_ep;\r\nout_ep = usb_ep_autoconfig(cdev->gadget, &fs_ep_out_desc);\r\nif (!out_ep)\r\ngoto autoconf_fail;\r\nout_ep->driver_data = out_ep;\r\nhs_ep_in_desc.bEndpointAddress = fs_ep_in_desc.bEndpointAddress;\r\nhs_ep_out_desc.bEndpointAddress = fs_ep_out_desc.bEndpointAddress;\r\nret = usb_assign_descriptors(f, fs_printer_function,\r\nhs_printer_function, NULL);\r\nif (ret)\r\nreturn ret;\r\ndev->in_ep = in_ep;\r\ndev->out_ep = out_ep;\r\nreturn 0;\r\n}\r\nstatic void printer_func_unbind(struct usb_configuration *c,\r\nstruct usb_function *f)\r\n{\r\nusb_free_all_descriptors(f);\r\n}\r\nstatic int printer_func_set_alt(struct usb_function *f,\r\nunsigned intf, unsigned alt)\r\n{\r\nstruct printer_dev *dev = container_of(f, struct printer_dev, function);\r\nint ret = -ENOTSUPP;\r\nif (!alt)\r\nret = set_interface(dev, intf);\r\nreturn ret;\r\n}\r\nstatic void printer_func_disable(struct usb_function *f)\r\n{\r\nstruct printer_dev *dev = container_of(f, struct printer_dev, function);\r\nunsigned long flags;\r\nDBG(dev, "%s\n", __func__);\r\nspin_lock_irqsave(&dev->lock, flags);\r\nprinter_reset_interface(dev);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\n}\r\nstatic void printer_cfg_unbind(struct usb_configuration *c)\r\n{\r\nstruct printer_dev *dev;\r\nstruct usb_request *req;\r\ndev = &usb_printer_gadget;\r\nDBG(dev, "%s\n", __func__);\r\ndevice_destroy(usb_gadget_class, g_printer_devno);\r\ncdev_del(&dev->printer_cdev);\r\nWARN_ON(!list_empty(&dev->tx_reqs_active));\r\nWARN_ON(!list_empty(&dev->rx_reqs_active));\r\nwhile (!list_empty(&dev->tx_reqs)) {\r\nreq = container_of(dev->tx_reqs.next, struct usb_request,\r\nlist);\r\nlist_del(&req->list);\r\nprinter_req_free(dev->in_ep, req);\r\n}\r\nif (dev->current_rx_req != NULL)\r\nprinter_req_free(dev->out_ep, dev->current_rx_req);\r\nwhile (!list_empty(&dev->rx_reqs)) {\r\nreq = container_of(dev->rx_reqs.next,\r\nstruct usb_request, list);\r\nlist_del(&req->list);\r\nprinter_req_free(dev->out_ep, req);\r\n}\r\nwhile (!list_empty(&dev->rx_buffers)) {\r\nreq = container_of(dev->rx_buffers.next,\r\nstruct usb_request, list);\r\nlist_del(&req->list);\r\nprinter_req_free(dev->out_ep, req);\r\n}\r\n}\r\nstatic int __init printer_bind_config(struct usb_configuration *c)\r\n{\r\nstruct usb_gadget *gadget = c->cdev->gadget;\r\nstruct printer_dev *dev;\r\nint status = -ENOMEM;\r\nsize_t len;\r\nu32 i;\r\nstruct usb_request *req;\r\nusb_ep_autoconfig_reset(gadget);\r\ndev = &usb_printer_gadget;\r\ndev->function.name = shortname;\r\ndev->function.bind = printer_func_bind;\r\ndev->function.setup = printer_func_setup;\r\ndev->function.unbind = printer_func_unbind;\r\ndev->function.set_alt = printer_func_set_alt;\r\ndev->function.disable = printer_func_disable;\r\nstatus = usb_add_function(c, &dev->function);\r\nif (status)\r\nreturn status;\r\ndev->pdev = device_create(usb_gadget_class, NULL, g_printer_devno,\r\nNULL, "g_printer");\r\nif (IS_ERR(dev->pdev)) {\r\nERROR(dev, "Failed to create device: g_printer\n");\r\nstatus = PTR_ERR(dev->pdev);\r\ngoto fail;\r\n}\r\ncdev_init(&dev->printer_cdev, &printer_io_operations);\r\ndev->printer_cdev.owner = THIS_MODULE;\r\nstatus = cdev_add(&dev->printer_cdev, g_printer_devno, 1);\r\nif (status) {\r\nERROR(dev, "Failed to open char device\n");\r\ngoto fail;\r\n}\r\nif (iPNPstring)\r\nstrlcpy(&pnp_string[2], iPNPstring, (sizeof pnp_string)-2);\r\nlen = strlen(pnp_string);\r\npnp_string[0] = (len >> 8) & 0xFF;\r\npnp_string[1] = len & 0xFF;\r\nusb_gadget_set_selfpowered(gadget);\r\nif (gadget_is_otg(gadget)) {\r\notg_descriptor.bmAttributes |= USB_OTG_HNP;\r\nprinter_cfg_driver.descriptors = otg_desc;\r\nprinter_cfg_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;\r\n}\r\nspin_lock_init(&dev->lock);\r\nmutex_init(&dev->lock_printer_io);\r\nINIT_LIST_HEAD(&dev->tx_reqs);\r\nINIT_LIST_HEAD(&dev->tx_reqs_active);\r\nINIT_LIST_HEAD(&dev->rx_reqs);\r\nINIT_LIST_HEAD(&dev->rx_reqs_active);\r\nINIT_LIST_HEAD(&dev->rx_buffers);\r\ninit_waitqueue_head(&dev->rx_wait);\r\ninit_waitqueue_head(&dev->tx_wait);\r\ninit_waitqueue_head(&dev->tx_flush_wait);\r\ndev->interface = -1;\r\ndev->printer_cdev_open = 0;\r\ndev->printer_status = PRINTER_NOT_ERROR;\r\ndev->current_rx_req = NULL;\r\ndev->current_rx_bytes = 0;\r\ndev->current_rx_buf = NULL;\r\nfor (i = 0; i < QLEN; i++) {\r\nreq = printer_req_alloc(dev->in_ep, USB_BUFSIZE, GFP_KERNEL);\r\nif (!req) {\r\nwhile (!list_empty(&dev->tx_reqs)) {\r\nreq = container_of(dev->tx_reqs.next,\r\nstruct usb_request, list);\r\nlist_del(&req->list);\r\nprinter_req_free(dev->in_ep, req);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nlist_add(&req->list, &dev->tx_reqs);\r\n}\r\nfor (i = 0; i < QLEN; i++) {\r\nreq = printer_req_alloc(dev->out_ep, USB_BUFSIZE, GFP_KERNEL);\r\nif (!req) {\r\nwhile (!list_empty(&dev->rx_reqs)) {\r\nreq = container_of(dev->rx_reqs.next,\r\nstruct usb_request, list);\r\nlist_del(&req->list);\r\nprinter_req_free(dev->out_ep, req);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nlist_add(&req->list, &dev->rx_reqs);\r\n}\r\ndev->gadget = gadget;\r\nINFO(dev, "%s, version: " DRIVER_VERSION "\n", driver_desc);\r\nreturn 0;\r\nfail:\r\nprinter_cfg_unbind(c);\r\nreturn status;\r\n}\r\nstatic int printer_unbind(struct usb_composite_dev *cdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init printer_bind(struct usb_composite_dev *cdev)\r\n{\r\nint ret;\r\nret = usb_string_ids_tab(cdev, strings);\r\nif (ret < 0)\r\nreturn ret;\r\ndevice_desc.iManufacturer = strings[USB_GADGET_MANUFACTURER_IDX].id;\r\ndevice_desc.iProduct = strings[USB_GADGET_PRODUCT_IDX].id;\r\ndevice_desc.iSerialNumber = strings[USB_GADGET_SERIAL_IDX].id;\r\nret = usb_add_config(cdev, &printer_cfg_driver, printer_bind_config);\r\nif (ret)\r\nreturn ret;\r\nusb_composite_overwrite_options(cdev, &coverwrite);\r\nreturn ret;\r\n}\r\nstatic int __init\r\ninit(void)\r\n{\r\nint status;\r\nusb_gadget_class = class_create(THIS_MODULE, "usb_printer_gadget");\r\nif (IS_ERR(usb_gadget_class)) {\r\nstatus = PTR_ERR(usb_gadget_class);\r\npr_err("unable to create usb_gadget class %d\n", status);\r\nreturn status;\r\n}\r\nstatus = alloc_chrdev_region(&g_printer_devno, 0, 1,\r\n"USB printer gadget");\r\nif (status) {\r\npr_err("alloc_chrdev_region %d\n", status);\r\nclass_destroy(usb_gadget_class);\r\nreturn status;\r\n}\r\nstatus = usb_composite_probe(&printer_driver);\r\nif (status) {\r\nclass_destroy(usb_gadget_class);\r\nunregister_chrdev_region(g_printer_devno, 1);\r\npr_err("usb_gadget_probe_driver %x\n", status);\r\n}\r\nreturn status;\r\n}\r\nstatic void __exit\r\ncleanup(void)\r\n{\r\nmutex_lock(&usb_printer_gadget.lock_printer_io);\r\nusb_composite_unregister(&printer_driver);\r\nunregister_chrdev_region(g_printer_devno, 1);\r\nclass_destroy(usb_gadget_class);\r\nmutex_unlock(&usb_printer_gadget.lock_printer_io);\r\n}
