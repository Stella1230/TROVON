static int tcm825x_read_reg(struct i2c_client *client, int reg)\r\n{\r\nint err;\r\nstruct i2c_msg msg[2];\r\nu8 reg_buf, data_buf = 0;\r\nif (!client->adapter)\r\nreturn -ENODEV;\r\nmsg[0].addr = client->addr;\r\nmsg[0].flags = 0;\r\nmsg[0].len = 1;\r\nmsg[0].buf = &reg_buf;\r\nmsg[1].addr = client->addr;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].len = 1;\r\nmsg[1].buf = &data_buf;\r\nreg_buf = reg;\r\nerr = i2c_transfer(client->adapter, msg, 2);\r\nif (err < 0)\r\nreturn err;\r\nreturn data_buf;\r\n}\r\nstatic int tcm825x_write_reg(struct i2c_client *client, u8 reg, u8 val)\r\n{\r\nint err;\r\nstruct i2c_msg msg[1];\r\nunsigned char data[2];\r\nif (!client->adapter)\r\nreturn -ENODEV;\r\nmsg->addr = client->addr;\r\nmsg->flags = 0;\r\nmsg->len = 2;\r\nmsg->buf = data;\r\ndata[0] = reg;\r\ndata[1] = val;\r\nerr = i2c_transfer(client->adapter, msg, 1);\r\nif (err >= 0)\r\nreturn 0;\r\nreturn err;\r\n}\r\nstatic int __tcm825x_write_reg_mask(struct i2c_client *client,\r\nu8 reg, u8 val, u8 mask)\r\n{\r\nint rc;\r\nrc = tcm825x_read_reg(client, reg);\r\nif (rc < 0)\r\nreturn rc;\r\nrc &= (~mask);\r\nval &= mask;\r\nval |= rc;\r\nrc = tcm825x_write_reg(client, reg, val);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int tcm825x_write_default_regs(struct i2c_client *client,\r\nconst struct tcm825x_reg *reglist)\r\n{\r\nint err;\r\nconst struct tcm825x_reg *next = reglist;\r\nwhile (!((next->reg == TCM825X_REG_TERM)\r\n&& (next->val == TCM825X_VAL_TERM))) {\r\nerr = tcm825x_write_reg(client, next->reg, next->val);\r\nif (err) {\r\ndev_err(&client->dev, "register writing failed\n");\r\nreturn err;\r\n}\r\nnext++;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct vcontrol *find_vctrl(int id)\r\n{\r\nint i;\r\nif (id < V4L2_CID_BASE)\r\nreturn NULL;\r\nfor (i = 0; i < ARRAY_SIZE(video_control); i++)\r\nif (video_control[i].qc.id == id)\r\nreturn &video_control[i];\r\nreturn NULL;\r\n}\r\nstatic enum image_size tcm825x_find_size(struct v4l2_int_device *s,\r\nunsigned int width,\r\nunsigned int height)\r\n{\r\nenum image_size isize;\r\nunsigned long pixels = width * height;\r\nstruct tcm825x_sensor *sensor = s->priv;\r\nfor (isize = subQCIF; isize < VGA; isize++) {\r\nif (tcm825x_sizes[isize + 1].height\r\n* tcm825x_sizes[isize + 1].width > pixels) {\r\ndev_dbg(&sensor->i2c_client->dev, "size %d\n", isize);\r\nreturn isize;\r\n}\r\n}\r\ndev_dbg(&sensor->i2c_client->dev, "format default VGA\n");\r\nreturn VGA;\r\n}\r\nstatic int tcm825x_configure(struct v4l2_int_device *s)\r\n{\r\nstruct tcm825x_sensor *sensor = s->priv;\r\nstruct v4l2_pix_format *pix = &sensor->pix;\r\nenum image_size isize = tcm825x_find_size(s, pix->width, pix->height);\r\nstruct v4l2_fract *fper = &sensor->timeperframe;\r\nenum pixel_format pfmt;\r\nint err;\r\nu32 tgt_fps;\r\nu8 val;\r\nerr = tcm825x_write_default_regs(\r\nsensor->i2c_client, sensor->platform_data->default_regs());\r\nif (err)\r\nreturn err;\r\nval = tcm825x_siz_reg[isize]->val;\r\ndev_dbg(&sensor->i2c_client->dev,\r\n"configuring image size %d\n", isize);\r\nerr = tcm825x_write_reg_mask(sensor->i2c_client,\r\ntcm825x_siz_reg[isize]->reg, val);\r\nif (err)\r\nreturn err;\r\nswitch (pix->pixelformat) {\r\ndefault:\r\ncase V4L2_PIX_FMT_RGB565:\r\npfmt = RGB565;\r\nbreak;\r\ncase V4L2_PIX_FMT_UYVY:\r\npfmt = YUV422;\r\nbreak;\r\n}\r\ndev_dbg(&sensor->i2c_client->dev,\r\n"configuring pixel format %d\n", pfmt);\r\nval = tcm825x_fmt_reg[pfmt]->val;\r\nerr = tcm825x_write_reg_mask(sensor->i2c_client,\r\ntcm825x_fmt_reg[pfmt]->reg, val);\r\nif (err)\r\nreturn err;\r\ntgt_fps = fper->denominator / fper->numerator;\r\nif (tgt_fps <= HIGH_FPS_MODE_LOWER_LIMIT) {\r\nval = tcm825x_read_reg(sensor->i2c_client, 0x02);\r\nval |= 0x80;\r\ntcm825x_write_reg(sensor->i2c_client, 0x02, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ioctl_queryctrl(struct v4l2_int_device *s,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nstruct vcontrol *control;\r\ncontrol = find_vctrl(qc->id);\r\nif (control == NULL)\r\nreturn -EINVAL;\r\n*qc = control->qc;\r\nreturn 0;\r\n}\r\nstatic int ioctl_g_ctrl(struct v4l2_int_device *s,\r\nstruct v4l2_control *vc)\r\n{\r\nstruct tcm825x_sensor *sensor = s->priv;\r\nstruct i2c_client *client = sensor->i2c_client;\r\nint val, r;\r\nstruct vcontrol *lvc;\r\nif (vc->id == V4L2_CID_EXPOSURE) {\r\nint val_lower, val_upper;\r\nval_upper = tcm825x_read_reg(client,\r\nTCM825X_ADDR(TCM825X_ESRSPD_U));\r\nif (val_upper < 0)\r\nreturn val_upper;\r\nval_lower = tcm825x_read_reg(client,\r\nTCM825X_ADDR(TCM825X_ESRSPD_L));\r\nif (val_lower < 0)\r\nreturn val_lower;\r\nvc->value = ((val_upper & 0x1f) << 8) | (val_lower);\r\nreturn 0;\r\n}\r\nlvc = find_vctrl(vc->id);\r\nif (lvc == NULL)\r\nreturn -EINVAL;\r\nr = tcm825x_read_reg(client, TCM825X_ADDR(lvc->reg));\r\nif (r < 0)\r\nreturn r;\r\nval = r & TCM825X_MASK(lvc->reg);\r\nval >>= lvc->start_bit;\r\nif (val < 0)\r\nreturn val;\r\nif (vc->id == V4L2_CID_HFLIP || vc->id == V4L2_CID_VFLIP)\r\nval ^= sensor->platform_data->is_upside_down();\r\nvc->value = val;\r\nreturn 0;\r\n}\r\nstatic int ioctl_s_ctrl(struct v4l2_int_device *s,\r\nstruct v4l2_control *vc)\r\n{\r\nstruct tcm825x_sensor *sensor = s->priv;\r\nstruct i2c_client *client = sensor->i2c_client;\r\nstruct vcontrol *lvc;\r\nint val = vc->value;\r\nif (vc->id == V4L2_CID_EXPOSURE) {\r\nint val_lower, val_upper;\r\nval_lower = val & TCM825X_MASK(TCM825X_ESRSPD_L);\r\nval_upper = (val >> 8) & TCM825X_MASK(TCM825X_ESRSPD_U);\r\nif (tcm825x_write_reg_mask(client,\r\nTCM825X_ESRSPD_U, val_upper))\r\nreturn -EIO;\r\nif (tcm825x_write_reg_mask(client,\r\nTCM825X_ESRSPD_L, val_lower))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nlvc = find_vctrl(vc->id);\r\nif (lvc == NULL)\r\nreturn -EINVAL;\r\nif (vc->id == V4L2_CID_HFLIP || vc->id == V4L2_CID_VFLIP)\r\nval ^= sensor->platform_data->is_upside_down();\r\nval = val << lvc->start_bit;\r\nif (tcm825x_write_reg_mask(client, lvc->reg, val))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int ioctl_enum_fmt_cap(struct v4l2_int_device *s,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nint index = fmt->index;\r\nswitch (fmt->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nif (index >= TCM825X_NUM_CAPTURE_FORMATS)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfmt->flags = tcm825x_formats[index].flags;\r\nstrlcpy(fmt->description, tcm825x_formats[index].description,\r\nsizeof(fmt->description));\r\nfmt->pixelformat = tcm825x_formats[index].pixelformat;\r\nreturn 0;\r\n}\r\nstatic int ioctl_try_fmt_cap(struct v4l2_int_device *s,\r\nstruct v4l2_format *f)\r\n{\r\nstruct tcm825x_sensor *sensor = s->priv;\r\nenum image_size isize;\r\nint ifmt;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nisize = tcm825x_find_size(s, pix->width, pix->height);\r\ndev_dbg(&sensor->i2c_client->dev, "isize = %d num_capture = %lu\n",\r\nisize, (unsigned long)TCM825X_NUM_CAPTURE_FORMATS);\r\npix->width = tcm825x_sizes[isize].width;\r\npix->height = tcm825x_sizes[isize].height;\r\nfor (ifmt = 0; ifmt < TCM825X_NUM_CAPTURE_FORMATS; ifmt++)\r\nif (pix->pixelformat == tcm825x_formats[ifmt].pixelformat)\r\nbreak;\r\nif (ifmt == TCM825X_NUM_CAPTURE_FORMATS)\r\nifmt = 0;\r\npix->pixelformat = tcm825x_formats[ifmt].pixelformat;\r\npix->field = V4L2_FIELD_NONE;\r\npix->bytesperline = pix->width * TCM825X_BYTES_PER_PIXEL;\r\npix->sizeimage = pix->bytesperline * pix->height;\r\npix->priv = 0;\r\ndev_dbg(&sensor->i2c_client->dev, "format = 0x%08x\n",\r\npix->pixelformat);\r\nswitch (pix->pixelformat) {\r\ncase V4L2_PIX_FMT_UYVY:\r\ndefault:\r\npix->colorspace = V4L2_COLORSPACE_JPEG;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565:\r\npix->colorspace = V4L2_COLORSPACE_SRGB;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ioctl_s_fmt_cap(struct v4l2_int_device *s,\r\nstruct v4l2_format *f)\r\n{\r\nstruct tcm825x_sensor *sensor = s->priv;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nint rval;\r\nrval = ioctl_try_fmt_cap(s, f);\r\nif (rval)\r\nreturn rval;\r\nrval = tcm825x_configure(s);\r\nsensor->pix = *pix;\r\nreturn rval;\r\n}\r\nstatic int ioctl_g_fmt_cap(struct v4l2_int_device *s,\r\nstruct v4l2_format *f)\r\n{\r\nstruct tcm825x_sensor *sensor = s->priv;\r\nf->fmt.pix = sensor->pix;\r\nreturn 0;\r\n}\r\nstatic int ioctl_g_parm(struct v4l2_int_device *s,\r\nstruct v4l2_streamparm *a)\r\n{\r\nstruct tcm825x_sensor *sensor = s->priv;\r\nstruct v4l2_captureparm *cparm = &a->parm.capture;\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nmemset(a, 0, sizeof(*a));\r\na->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ncparm->capability = V4L2_CAP_TIMEPERFRAME;\r\ncparm->timeperframe = sensor->timeperframe;\r\nreturn 0;\r\n}\r\nstatic int ioctl_s_parm(struct v4l2_int_device *s,\r\nstruct v4l2_streamparm *a)\r\n{\r\nstruct tcm825x_sensor *sensor = s->priv;\r\nstruct v4l2_fract *timeperframe = &a->parm.capture.timeperframe;\r\nu32 tgt_fps;\r\nint rval;\r\nif (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif ((timeperframe->numerator == 0)\r\n|| (timeperframe->denominator == 0)) {\r\ntimeperframe->denominator = DEFAULT_FPS;\r\ntimeperframe->numerator = 1;\r\n}\r\ntgt_fps = timeperframe->denominator / timeperframe->numerator;\r\nif (tgt_fps > MAX_FPS) {\r\ntimeperframe->denominator = MAX_FPS;\r\ntimeperframe->numerator = 1;\r\n} else if (tgt_fps < MIN_FPS) {\r\ntimeperframe->denominator = MIN_FPS;\r\ntimeperframe->numerator = 1;\r\n}\r\nsensor->timeperframe = *timeperframe;\r\nrval = tcm825x_configure(s);\r\nreturn rval;\r\n}\r\nstatic int ioctl_s_power(struct v4l2_int_device *s, int on)\r\n{\r\nstruct tcm825x_sensor *sensor = s->priv;\r\nreturn sensor->platform_data->power_set(on);\r\n}\r\nstatic int ioctl_g_ifparm(struct v4l2_int_device *s, struct v4l2_ifparm *p)\r\n{\r\nstruct tcm825x_sensor *sensor = s->priv;\r\nstruct v4l2_fract *timeperframe = &sensor->timeperframe;\r\nu32 tgt_xclk;\r\nu32 tgt_fps;\r\nint rval;\r\nrval = sensor->platform_data->ifparm(p);\r\nif (rval)\r\nreturn rval;\r\ntgt_fps = timeperframe->denominator / timeperframe->numerator;\r\ntgt_xclk = (tgt_fps <= HIGH_FPS_MODE_LOWER_LIMIT) ?\r\n(2457 * tgt_fps) / MAX_HALF_FPS :\r\n(2457 * tgt_fps) / MAX_FPS;\r\ntgt_xclk *= 10000;\r\ntgt_xclk = min(tgt_xclk, (u32)TCM825X_XCLK_MAX);\r\ntgt_xclk = max(tgt_xclk, (u32)TCM825X_XCLK_MIN);\r\np->u.bt656.clock_curr = tgt_xclk;\r\nreturn 0;\r\n}\r\nstatic int ioctl_g_needs_reset(struct v4l2_int_device *s, void *buf)\r\n{\r\nstruct tcm825x_sensor *sensor = s->priv;\r\nreturn sensor->platform_data->needs_reset(s, buf, &sensor->pix);\r\n}\r\nstatic int ioctl_reset(struct v4l2_int_device *s)\r\n{\r\nreturn -EBUSY;\r\n}\r\nstatic int ioctl_init(struct v4l2_int_device *s)\r\n{\r\nreturn tcm825x_configure(s);\r\n}\r\nstatic int ioctl_dev_exit(struct v4l2_int_device *s)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ioctl_dev_init(struct v4l2_int_device *s)\r\n{\r\nstruct tcm825x_sensor *sensor = s->priv;\r\nint r;\r\nr = tcm825x_read_reg(sensor->i2c_client, 0x01);\r\nif (r < 0)\r\nreturn r;\r\nif (r == 0) {\r\ndev_err(&sensor->i2c_client->dev, "device not detected\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tcm825x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct tcm825x_sensor *sensor = &tcm825x;\r\nif (i2c_get_clientdata(client))\r\nreturn -EBUSY;\r\nsensor->platform_data = client->dev.platform_data;\r\nif (sensor->platform_data == NULL\r\n|| !sensor->platform_data->is_okay())\r\nreturn -ENODEV;\r\nsensor->v4l2_int_device = &tcm825x_int_device;\r\nsensor->i2c_client = client;\r\ni2c_set_clientdata(client, sensor);\r\nsensor->pix.width = tcm825x_sizes[QVGA].width;\r\nsensor->pix.height = tcm825x_sizes[QVGA].height;\r\nsensor->pix.pixelformat = V4L2_PIX_FMT_RGB565;\r\nreturn v4l2_int_device_register(sensor->v4l2_int_device);\r\n}\r\nstatic int tcm825x_remove(struct i2c_client *client)\r\n{\r\nstruct tcm825x_sensor *sensor = i2c_get_clientdata(client);\r\nif (!client->adapter)\r\nreturn -ENODEV;\r\nv4l2_int_device_unregister(sensor->v4l2_int_device);\r\nreturn 0;\r\n}\r\nstatic int __init tcm825x_init(void)\r\n{\r\nint rval;\r\nrval = i2c_add_driver(&tcm825x_i2c_driver);\r\nif (rval)\r\npr_info("%s: failed registering " TCM825X_NAME "\n",\r\n__func__);\r\nreturn rval;\r\n}\r\nstatic void __exit tcm825x_exit(void)\r\n{\r\ni2c_del_driver(&tcm825x_i2c_driver);\r\n}
