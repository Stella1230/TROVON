int skein_ctx_prepare(struct skein_ctx *ctx, enum skein_size size)\r\n{\r\nskein_assert_ret(ctx && size, SKEIN_FAIL);\r\nmemset(ctx , 0, sizeof(struct skein_ctx));\r\nctx->skein_size = size;\r\nreturn SKEIN_SUCCESS;\r\n}\r\nint skein_init(struct skein_ctx *ctx, size_t hash_bit_len)\r\n{\r\nint ret = SKEIN_FAIL;\r\nsize_t x_len = 0;\r\nu64 *x = NULL;\r\nu64 tree_info = SKEIN_CFG_TREE_INFO_SEQUENTIAL;\r\nskein_assert_ret(ctx, SKEIN_FAIL);\r\nx = ctx->m.s256.x;\r\nx_len = ctx->skein_size/8;\r\nswitch (ctx->skein_size) {\r\ncase SKEIN_256:\r\nret = skein_256_init_ext(&ctx->m.s256, hash_bit_len,\r\ntree_info, NULL, 0);\r\nbreak;\r\ncase SKEIN_512:\r\nret = skein_512_init_ext(&ctx->m.s512, hash_bit_len,\r\ntree_info, NULL, 0);\r\nbreak;\r\ncase SKEIN_1024:\r\nret = skein_1024_init_ext(&ctx->m.s1024, hash_bit_len,\r\ntree_info, NULL, 0);\r\nbreak;\r\n}\r\nif (ret == SKEIN_SUCCESS) {\r\nmemcpy(ctx->x_save, x, x_len);\r\n}\r\nreturn ret;\r\n}\r\nint skein_mac_init(struct skein_ctx *ctx, const u8 *key, size_t key_len,\r\nsize_t hash_bit_len)\r\n{\r\nint ret = SKEIN_FAIL;\r\nu64 *x = NULL;\r\nsize_t x_len = 0;\r\nu64 tree_info = SKEIN_CFG_TREE_INFO_SEQUENTIAL;\r\nskein_assert_ret(ctx, SKEIN_FAIL);\r\nx = ctx->m.s256.x;\r\nx_len = ctx->skein_size/8;\r\nskein_assert_ret(hash_bit_len, SKEIN_BAD_HASHLEN);\r\nswitch (ctx->skein_size) {\r\ncase SKEIN_256:\r\nret = skein_256_init_ext(&ctx->m.s256, hash_bit_len,\r\ntree_info,\r\n(const u8 *)key, key_len);\r\nbreak;\r\ncase SKEIN_512:\r\nret = skein_512_init_ext(&ctx->m.s512, hash_bit_len,\r\ntree_info,\r\n(const u8 *)key, key_len);\r\nbreak;\r\ncase SKEIN_1024:\r\nret = skein_1024_init_ext(&ctx->m.s1024, hash_bit_len,\r\ntree_info,\r\n(const u8 *)key, key_len);\r\nbreak;\r\n}\r\nif (ret == SKEIN_SUCCESS) {\r\nmemcpy(ctx->x_save, x, x_len);\r\n}\r\nreturn ret;\r\n}\r\nvoid skein_reset(struct skein_ctx *ctx)\r\n{\r\nsize_t x_len = 0;\r\nu64 *x = NULL;\r\nx = ctx->m.s256.x;\r\nx_len = ctx->skein_size/8;\r\nmemcpy(x, ctx->x_save, x_len);\r\nskein_start_new_type(&ctx->m, MSG);\r\n}\r\nint skein_update(struct skein_ctx *ctx, const u8 *msg,\r\nsize_t msg_byte_cnt)\r\n{\r\nint ret = SKEIN_FAIL;\r\nskein_assert_ret(ctx, SKEIN_FAIL);\r\nswitch (ctx->skein_size) {\r\ncase SKEIN_256:\r\nret = skein_256_update(&ctx->m.s256, (const u8 *)msg,\r\nmsg_byte_cnt);\r\nbreak;\r\ncase SKEIN_512:\r\nret = skein_512_update(&ctx->m.s512, (const u8 *)msg,\r\nmsg_byte_cnt);\r\nbreak;\r\ncase SKEIN_1024:\r\nret = skein_1024_update(&ctx->m.s1024, (const u8 *)msg,\r\nmsg_byte_cnt);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint skein_update_bits(struct skein_ctx *ctx, const u8 *msg,\r\nsize_t msg_bit_cnt)\r\n{\r\nsize_t length;\r\nu8 mask;\r\nu8 *up;\r\nskein_assert_ret((ctx->m.h.T[1] & SKEIN_T1_FLAG_BIT_PAD) == 0 ||\r\nmsg_bit_cnt == 0, SKEIN_FAIL);\r\nif ((msg_bit_cnt & 0x7) == 0)\r\nreturn skein_update(ctx, msg, msg_bit_cnt >> 3);\r\nskein_update(ctx, msg, (msg_bit_cnt >> 3) + 1);\r\nup = (u8 *)ctx->m.s256.x + ctx->skein_size / 8;\r\nskein_set_bit_pad_flag(ctx->m.h);\r\nlength = ctx->m.h.b_cnt;\r\nskein_assert(length != 0);\r\nmask = (u8) (1u << (7 - (msg_bit_cnt & 7)));\r\nup[length-1] = (u8)((up[length-1] & (0-mask))|mask);\r\nreturn SKEIN_SUCCESS;\r\n}\r\nint skein_final(struct skein_ctx *ctx, u8 *hash)\r\n{\r\nint ret = SKEIN_FAIL;\r\nskein_assert_ret(ctx, SKEIN_FAIL);\r\nswitch (ctx->skein_size) {\r\ncase SKEIN_256:\r\nret = skein_256_final(&ctx->m.s256, (u8 *)hash);\r\nbreak;\r\ncase SKEIN_512:\r\nret = skein_512_final(&ctx->m.s512, (u8 *)hash);\r\nbreak;\r\ncase SKEIN_1024:\r\nret = skein_1024_final(&ctx->m.s1024, (u8 *)hash);\r\nbreak;\r\n}\r\nreturn ret;\r\n}
