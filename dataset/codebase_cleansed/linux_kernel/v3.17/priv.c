static int handle_set_clock(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_vcpu *cpup;\r\ns64 hostclk, val;\r\nint i, rc;\r\nu64 op2;\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\nop2 = kvm_s390_get_base_disp_s(vcpu);\r\nif (op2 & 7)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nrc = read_guest(vcpu, op2, &val, sizeof(val));\r\nif (rc)\r\nreturn kvm_s390_inject_prog_cond(vcpu, rc);\r\nif (store_tod_clock(&hostclk)) {\r\nkvm_s390_set_psw_cc(vcpu, 3);\r\nreturn 0;\r\n}\r\nval = (val - hostclk) & ~0x3fUL;\r\nmutex_lock(&vcpu->kvm->lock);\r\nkvm_for_each_vcpu(i, cpup, vcpu->kvm)\r\ncpup->arch.sie_block->epoch = val;\r\nmutex_unlock(&vcpu->kvm->lock);\r\nkvm_s390_set_psw_cc(vcpu, 0);\r\nreturn 0;\r\n}\r\nstatic int handle_set_prefix(struct kvm_vcpu *vcpu)\r\n{\r\nu64 operand2;\r\nu32 address;\r\nint rc;\r\nvcpu->stat.instruction_spx++;\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\noperand2 = kvm_s390_get_base_disp_s(vcpu);\r\nif (operand2 & 3)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nrc = read_guest(vcpu, operand2, &address, sizeof(address));\r\nif (rc)\r\nreturn kvm_s390_inject_prog_cond(vcpu, rc);\r\naddress &= 0x7fffe000u;\r\nif (kvm_is_error_gpa(vcpu->kvm, address))\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_ADDRESSING);\r\nkvm_s390_set_prefix(vcpu, address);\r\nVCPU_EVENT(vcpu, 5, "setting prefix to %x", address);\r\ntrace_kvm_s390_handle_prefix(vcpu, 1, address);\r\nreturn 0;\r\n}\r\nstatic int handle_store_prefix(struct kvm_vcpu *vcpu)\r\n{\r\nu64 operand2;\r\nu32 address;\r\nint rc;\r\nvcpu->stat.instruction_stpx++;\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\noperand2 = kvm_s390_get_base_disp_s(vcpu);\r\nif (operand2 & 3)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\naddress = kvm_s390_get_prefix(vcpu);\r\nrc = write_guest(vcpu, operand2, &address, sizeof(address));\r\nif (rc)\r\nreturn kvm_s390_inject_prog_cond(vcpu, rc);\r\nVCPU_EVENT(vcpu, 5, "storing prefix to %x", address);\r\ntrace_kvm_s390_handle_prefix(vcpu, 0, address);\r\nreturn 0;\r\n}\r\nstatic int handle_store_cpu_address(struct kvm_vcpu *vcpu)\r\n{\r\nu16 vcpu_id = vcpu->vcpu_id;\r\nu64 ga;\r\nint rc;\r\nvcpu->stat.instruction_stap++;\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\nga = kvm_s390_get_base_disp_s(vcpu);\r\nif (ga & 1)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nrc = write_guest(vcpu, ga, &vcpu_id, sizeof(vcpu_id));\r\nif (rc)\r\nreturn kvm_s390_inject_prog_cond(vcpu, rc);\r\nVCPU_EVENT(vcpu, 5, "storing cpu address to %llx", ga);\r\ntrace_kvm_s390_handle_stap(vcpu, ga);\r\nreturn 0;\r\n}\r\nstatic void __skey_check_enable(struct kvm_vcpu *vcpu)\r\n{\r\nif (!(vcpu->arch.sie_block->ictl & (ICTL_ISKE | ICTL_SSKE | ICTL_RRBE)))\r\nreturn;\r\ns390_enable_skey();\r\ntrace_kvm_s390_skey_related_inst(vcpu);\r\nvcpu->arch.sie_block->ictl &= ~(ICTL_ISKE | ICTL_SSKE | ICTL_RRBE);\r\n}\r\nstatic int handle_skey(struct kvm_vcpu *vcpu)\r\n{\r\n__skey_check_enable(vcpu);\r\nvcpu->stat.instruction_storage_key++;\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\nvcpu->arch.sie_block->gpsw.addr =\r\n__rewind_psw(vcpu->arch.sie_block->gpsw, 4);\r\nVCPU_EVENT(vcpu, 4, "%s", "retrying storage key operation");\r\nreturn 0;\r\n}\r\nstatic int handle_ipte_interlock(struct kvm_vcpu *vcpu)\r\n{\r\npsw_t *psw = &vcpu->arch.sie_block->gpsw;\r\nvcpu->stat.instruction_ipte_interlock++;\r\nif (psw_bits(*psw).p)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\nwait_event(vcpu->kvm->arch.ipte_wq, !ipte_lock_held(vcpu));\r\npsw->addr = __rewind_psw(*psw, 4);\r\nVCPU_EVENT(vcpu, 4, "%s", "retrying ipte interlock operation");\r\nreturn 0;\r\n}\r\nstatic int handle_test_block(struct kvm_vcpu *vcpu)\r\n{\r\ngpa_t addr;\r\nint reg2;\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\nkvm_s390_get_regs_rre(vcpu, NULL, &reg2);\r\naddr = vcpu->run->s.regs.gprs[reg2] & PAGE_MASK;\r\naddr = kvm_s390_logical_to_effective(vcpu, addr);\r\nif (kvm_s390_check_low_addr_protection(vcpu, addr))\r\nreturn kvm_s390_inject_prog_irq(vcpu, &vcpu->arch.pgm);\r\naddr = kvm_s390_real_to_abs(vcpu, addr);\r\nif (kvm_is_error_gpa(vcpu->kvm, addr))\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_ADDRESSING);\r\nif (kvm_clear_guest(vcpu->kvm, addr, PAGE_SIZE))\r\nreturn -EFAULT;\r\nkvm_s390_set_psw_cc(vcpu, 0);\r\nvcpu->run->s.regs.gprs[0] = 0;\r\nreturn 0;\r\n}\r\nstatic int handle_tpi(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_s390_interrupt_info *inti;\r\nunsigned long len;\r\nu32 tpi_data[3];\r\nint cc, rc;\r\nu64 addr;\r\nrc = 0;\r\naddr = kvm_s390_get_base_disp_s(vcpu);\r\nif (addr & 3)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\ncc = 0;\r\ninti = kvm_s390_get_io_int(vcpu->kvm, vcpu->arch.sie_block->gcr[6], 0);\r\nif (!inti)\r\ngoto no_interrupt;\r\ncc = 1;\r\ntpi_data[0] = inti->io.subchannel_id << 16 | inti->io.subchannel_nr;\r\ntpi_data[1] = inti->io.io_int_parm;\r\ntpi_data[2] = inti->io.io_int_word;\r\nif (addr) {\r\nlen = sizeof(tpi_data) - 4;\r\nrc = write_guest(vcpu, addr, &tpi_data, len);\r\nif (rc)\r\nreturn kvm_s390_inject_prog_cond(vcpu, rc);\r\n} else {\r\nlen = sizeof(tpi_data);\r\nif (write_guest_lc(vcpu, __LC_SUBCHANNEL_ID, &tpi_data, len))\r\nrc = -EFAULT;\r\n}\r\nif (!rc)\r\nkfree(inti);\r\nelse\r\nkvm_s390_reinject_io_int(vcpu->kvm, inti);\r\nno_interrupt:\r\nif (!rc)\r\nkvm_s390_set_psw_cc(vcpu, cc);\r\nreturn rc ? -EFAULT : 0;\r\n}\r\nstatic int handle_tsch(struct kvm_vcpu *vcpu)\r\n{\r\nstruct kvm_s390_interrupt_info *inti;\r\ninti = kvm_s390_get_io_int(vcpu->kvm, 0,\r\nvcpu->run->s.regs.gprs[1]);\r\nvcpu->run->exit_reason = KVM_EXIT_S390_TSCH;\r\nvcpu->run->s390_tsch.dequeued = !!inti;\r\nif (inti) {\r\nvcpu->run->s390_tsch.subchannel_id = inti->io.subchannel_id;\r\nvcpu->run->s390_tsch.subchannel_nr = inti->io.subchannel_nr;\r\nvcpu->run->s390_tsch.io_int_parm = inti->io.io_int_parm;\r\nvcpu->run->s390_tsch.io_int_word = inti->io.io_int_word;\r\n}\r\nvcpu->run->s390_tsch.ipb = vcpu->arch.sie_block->ipb;\r\nkfree(inti);\r\nreturn -EREMOTE;\r\n}\r\nstatic int handle_io_inst(struct kvm_vcpu *vcpu)\r\n{\r\nVCPU_EVENT(vcpu, 4, "%s", "I/O instruction");\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\nif (vcpu->kvm->arch.css_support) {\r\nif (vcpu->arch.sie_block->ipa == 0xb236)\r\nreturn handle_tpi(vcpu);\r\nif (vcpu->arch.sie_block->ipa == 0xb235)\r\nreturn handle_tsch(vcpu);\r\nreturn -EOPNOTSUPP;\r\n} else {\r\nkvm_s390_set_psw_cc(vcpu, 3);\r\nreturn 0;\r\n}\r\n}\r\nstatic int handle_stfl(struct kvm_vcpu *vcpu)\r\n{\r\nint rc;\r\nvcpu->stat.instruction_stfl++;\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\nrc = write_guest_lc(vcpu, offsetof(struct _lowcore, stfl_fac_list),\r\nvfacilities, 4);\r\nif (rc)\r\nreturn rc;\r\nVCPU_EVENT(vcpu, 5, "store facility list value %x",\r\n*(unsigned int *) vfacilities);\r\ntrace_kvm_s390_handle_stfl(vcpu, *(unsigned int *) vfacilities);\r\nreturn 0;\r\n}\r\nstatic void handle_new_psw(struct kvm_vcpu *vcpu)\r\n{\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_MCHECK)\r\nkvm_s390_deliver_pending_machine_checks(vcpu);\r\n}\r\nint is_valid_psw(psw_t *psw)\r\n{\r\nif (psw->mask & PSW_MASK_UNASSIGNED)\r\nreturn 0;\r\nif ((psw->mask & PSW_MASK_ADDR_MODE) == PSW_MASK_BA) {\r\nif (psw->addr & ~PSW_ADDR_31)\r\nreturn 0;\r\n}\r\nif (!(psw->mask & PSW_MASK_ADDR_MODE) && (psw->addr & ~PSW_ADDR_24))\r\nreturn 0;\r\nif ((psw->mask & PSW_MASK_ADDR_MODE) == PSW_MASK_EA)\r\nreturn 0;\r\nif (psw->addr & 1)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint kvm_s390_handle_lpsw(struct kvm_vcpu *vcpu)\r\n{\r\npsw_t *gpsw = &vcpu->arch.sie_block->gpsw;\r\npsw_compat_t new_psw;\r\nu64 addr;\r\nint rc;\r\nif (gpsw->mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\naddr = kvm_s390_get_base_disp_s(vcpu);\r\nif (addr & 7)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nrc = read_guest(vcpu, addr, &new_psw, sizeof(new_psw));\r\nif (rc)\r\nreturn kvm_s390_inject_prog_cond(vcpu, rc);\r\nif (!(new_psw.mask & PSW32_MASK_BASE))\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\ngpsw->mask = (new_psw.mask & ~PSW32_MASK_BASE) << 32;\r\ngpsw->mask |= new_psw.addr & PSW32_ADDR_AMODE;\r\ngpsw->addr = new_psw.addr & ~PSW32_ADDR_AMODE;\r\nif (!is_valid_psw(gpsw))\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nhandle_new_psw(vcpu);\r\nreturn 0;\r\n}\r\nstatic int handle_lpswe(struct kvm_vcpu *vcpu)\r\n{\r\npsw_t new_psw;\r\nu64 addr;\r\nint rc;\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\naddr = kvm_s390_get_base_disp_s(vcpu);\r\nif (addr & 7)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nrc = read_guest(vcpu, addr, &new_psw, sizeof(new_psw));\r\nif (rc)\r\nreturn kvm_s390_inject_prog_cond(vcpu, rc);\r\nvcpu->arch.sie_block->gpsw = new_psw;\r\nif (!is_valid_psw(&vcpu->arch.sie_block->gpsw))\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nhandle_new_psw(vcpu);\r\nreturn 0;\r\n}\r\nstatic int handle_stidp(struct kvm_vcpu *vcpu)\r\n{\r\nu64 stidp_data = vcpu->arch.stidp_data;\r\nu64 operand2;\r\nint rc;\r\nvcpu->stat.instruction_stidp++;\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\noperand2 = kvm_s390_get_base_disp_s(vcpu);\r\nif (operand2 & 7)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nrc = write_guest(vcpu, operand2, &stidp_data, sizeof(stidp_data));\r\nif (rc)\r\nreturn kvm_s390_inject_prog_cond(vcpu, rc);\r\nVCPU_EVENT(vcpu, 5, "%s", "store cpu id");\r\nreturn 0;\r\n}\r\nstatic void handle_stsi_3_2_2(struct kvm_vcpu *vcpu, struct sysinfo_3_2_2 *mem)\r\n{\r\nint cpus = 0;\r\nint n;\r\ncpus = atomic_read(&vcpu->kvm->online_vcpus);\r\nif (stsi(mem, 3, 2, 2))\r\nmem->count = 0;\r\nif (mem->count < 8)\r\nmem->count++;\r\nfor (n = mem->count - 1; n > 0 ; n--)\r\nmemcpy(&mem->vm[n], &mem->vm[n - 1], sizeof(mem->vm[0]));\r\nmem->vm[0].cpus_total = cpus;\r\nmem->vm[0].cpus_configured = cpus;\r\nmem->vm[0].cpus_standby = 0;\r\nmem->vm[0].cpus_reserved = 0;\r\nmem->vm[0].caf = 1000;\r\nmemcpy(mem->vm[0].name, "KVMguest", 8);\r\nASCEBC(mem->vm[0].name, 8);\r\nmemcpy(mem->vm[0].cpi, "KVM/Linux ", 16);\r\nASCEBC(mem->vm[0].cpi, 16);\r\n}\r\nstatic int handle_stsi(struct kvm_vcpu *vcpu)\r\n{\r\nint fc = (vcpu->run->s.regs.gprs[0] & 0xf0000000) >> 28;\r\nint sel1 = vcpu->run->s.regs.gprs[0] & 0xff;\r\nint sel2 = vcpu->run->s.regs.gprs[1] & 0xffff;\r\nunsigned long mem = 0;\r\nu64 operand2;\r\nint rc = 0;\r\nvcpu->stat.instruction_stsi++;\r\nVCPU_EVENT(vcpu, 4, "stsi: fc: %x sel1: %x sel2: %x", fc, sel1, sel2);\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\nif (fc > 3) {\r\nkvm_s390_set_psw_cc(vcpu, 3);\r\nreturn 0;\r\n}\r\nif (vcpu->run->s.regs.gprs[0] & 0x0fffff00\r\n|| vcpu->run->s.regs.gprs[1] & 0xffff0000)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nif (fc == 0) {\r\nvcpu->run->s.regs.gprs[0] = 3 << 28;\r\nkvm_s390_set_psw_cc(vcpu, 0);\r\nreturn 0;\r\n}\r\noperand2 = kvm_s390_get_base_disp_s(vcpu);\r\nif (operand2 & 0xfff)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nswitch (fc) {\r\ncase 1:\r\ncase 2:\r\nmem = get_zeroed_page(GFP_KERNEL);\r\nif (!mem)\r\ngoto out_no_data;\r\nif (stsi((void *) mem, fc, sel1, sel2))\r\ngoto out_no_data;\r\nbreak;\r\ncase 3:\r\nif (sel1 != 2 || sel2 != 2)\r\ngoto out_no_data;\r\nmem = get_zeroed_page(GFP_KERNEL);\r\nif (!mem)\r\ngoto out_no_data;\r\nhandle_stsi_3_2_2(vcpu, (void *) mem);\r\nbreak;\r\n}\r\nrc = write_guest(vcpu, operand2, (void *)mem, PAGE_SIZE);\r\nif (rc) {\r\nrc = kvm_s390_inject_prog_cond(vcpu, rc);\r\ngoto out;\r\n}\r\ntrace_kvm_s390_handle_stsi(vcpu, fc, sel1, sel2, operand2);\r\nfree_page(mem);\r\nkvm_s390_set_psw_cc(vcpu, 0);\r\nvcpu->run->s.regs.gprs[0] = 0;\r\nreturn 0;\r\nout_no_data:\r\nkvm_s390_set_psw_cc(vcpu, 3);\r\nout:\r\nfree_page(mem);\r\nreturn rc;\r\n}\r\nint kvm_s390_handle_b2(struct kvm_vcpu *vcpu)\r\n{\r\nintercept_handler_t handler;\r\nhandler = b2_handlers[vcpu->arch.sie_block->ipa & 0x00ff];\r\nif (handler)\r\nreturn handler(vcpu);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int handle_epsw(struct kvm_vcpu *vcpu)\r\n{\r\nint reg1, reg2;\r\nkvm_s390_get_regs_rre(vcpu, &reg1, &reg2);\r\nvcpu->run->s.regs.gprs[reg1] &= 0xffffffff00000000UL;\r\nvcpu->run->s.regs.gprs[reg1] |= vcpu->arch.sie_block->gpsw.mask >> 32;\r\nif (reg2) {\r\nvcpu->run->s.regs.gprs[reg2] &= 0xffffffff00000000UL;\r\nvcpu->run->s.regs.gprs[reg2] |=\r\nvcpu->arch.sie_block->gpsw.mask & 0x00000000ffffffffUL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int handle_pfmf(struct kvm_vcpu *vcpu)\r\n{\r\nint reg1, reg2;\r\nunsigned long start, end;\r\nvcpu->stat.instruction_pfmf++;\r\nkvm_s390_get_regs_rre(vcpu, &reg1, &reg2);\r\nif (!MACHINE_HAS_PFMF)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_OPERATION);\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\nif (vcpu->run->s.regs.gprs[reg1] & PFMF_RESERVED)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nif (vcpu->run->s.regs.gprs[reg1] & PFMF_NQ && !test_facility(14))\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nif (vcpu->run->s.regs.gprs[reg1] & (PFMF_MR | PFMF_MC))\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nstart = vcpu->run->s.regs.gprs[reg2] & PAGE_MASK;\r\nif (vcpu->run->s.regs.gprs[reg1] & PFMF_CF) {\r\nif (kvm_s390_check_low_addr_protection(vcpu, start))\r\nreturn kvm_s390_inject_prog_irq(vcpu, &vcpu->arch.pgm);\r\n}\r\nswitch (vcpu->run->s.regs.gprs[reg1] & PFMF_FSC) {\r\ncase 0x00000000:\r\nend = (start + (1UL << 12)) & ~((1UL << 12) - 1);\r\nbreak;\r\ncase 0x00001000:\r\nend = (start + (1UL << 20)) & ~((1UL << 20) - 1);\r\nbreak;\r\ndefault:\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\n}\r\nwhile (start < end) {\r\nunsigned long useraddr, abs_addr;\r\nif ((vcpu->run->s.regs.gprs[reg1] & PFMF_FSC) == 0)\r\nabs_addr = kvm_s390_real_to_abs(vcpu, start);\r\nelse\r\nabs_addr = start;\r\nuseraddr = gfn_to_hva(vcpu->kvm, gpa_to_gfn(abs_addr));\r\nif (kvm_is_error_hva(useraddr))\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_ADDRESSING);\r\nif (vcpu->run->s.regs.gprs[reg1] & PFMF_CF) {\r\nif (clear_user((void __user *)useraddr, PAGE_SIZE))\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_ADDRESSING);\r\n}\r\nif (vcpu->run->s.regs.gprs[reg1] & PFMF_SK) {\r\n__skey_check_enable(vcpu);\r\nif (set_guest_storage_key(current->mm, useraddr,\r\nvcpu->run->s.regs.gprs[reg1] & PFMF_KEY,\r\nvcpu->run->s.regs.gprs[reg1] & PFMF_NQ))\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_ADDRESSING);\r\n}\r\nstart += PAGE_SIZE;\r\n}\r\nif (vcpu->run->s.regs.gprs[reg1] & PFMF_FSC)\r\nvcpu->run->s.regs.gprs[reg2] = end;\r\nreturn 0;\r\n}\r\nstatic int handle_essa(struct kvm_vcpu *vcpu)\r\n{\r\nint entries = (vcpu->arch.sie_block->cbrlo & ~PAGE_MASK) >> 3;\r\nunsigned long *cbrlo, cbrle;\r\nstruct gmap *gmap;\r\nint i;\r\nVCPU_EVENT(vcpu, 5, "cmma release %d pages", entries);\r\ngmap = vcpu->arch.gmap;\r\nvcpu->stat.instruction_essa++;\r\nif (!kvm_s390_cmma_enabled(vcpu->kvm))\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_OPERATION);\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\nif (((vcpu->arch.sie_block->ipb & 0xf0000000) >> 28) > 6)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nvcpu->arch.sie_block->gpsw.addr =\r\n__rewind_psw(vcpu->arch.sie_block->gpsw, 4);\r\nvcpu->arch.sie_block->cbrlo &= PAGE_MASK;\r\ncbrlo = phys_to_virt(vcpu->arch.sie_block->cbrlo);\r\ndown_read(&gmap->mm->mmap_sem);\r\nfor (i = 0; i < entries; ++i) {\r\ncbrle = cbrlo[i];\r\nif (unlikely(cbrle & ~PAGE_MASK || cbrle < 2 * PAGE_SIZE))\r\nbreak;\r\n__gmap_zap(cbrle, gmap);\r\n}\r\nup_read(&gmap->mm->mmap_sem);\r\nif (i < entries)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nreturn 0;\r\n}\r\nint kvm_s390_handle_b9(struct kvm_vcpu *vcpu)\r\n{\r\nintercept_handler_t handler;\r\nhandler = b9_handlers[vcpu->arch.sie_block->ipa & 0x00ff];\r\nif (handler)\r\nreturn handler(vcpu);\r\nreturn -EOPNOTSUPP;\r\n}\r\nint kvm_s390_handle_lctl(struct kvm_vcpu *vcpu)\r\n{\r\nint reg1 = (vcpu->arch.sie_block->ipa & 0x00f0) >> 4;\r\nint reg3 = vcpu->arch.sie_block->ipa & 0x000f;\r\nu32 val = 0;\r\nint reg, rc;\r\nu64 ga;\r\nvcpu->stat.instruction_lctl++;\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\nga = kvm_s390_get_base_disp_rs(vcpu);\r\nif (ga & 3)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nVCPU_EVENT(vcpu, 5, "lctl r1:%x, r3:%x, addr:%llx", reg1, reg3, ga);\r\ntrace_kvm_s390_handle_lctl(vcpu, 0, reg1, reg3, ga);\r\nreg = reg1;\r\ndo {\r\nrc = read_guest(vcpu, ga, &val, sizeof(val));\r\nif (rc)\r\nreturn kvm_s390_inject_prog_cond(vcpu, rc);\r\nvcpu->arch.sie_block->gcr[reg] &= 0xffffffff00000000ul;\r\nvcpu->arch.sie_block->gcr[reg] |= val;\r\nga += 4;\r\nif (reg == reg3)\r\nbreak;\r\nreg = (reg + 1) % 16;\r\n} while (1);\r\nreturn 0;\r\n}\r\nint kvm_s390_handle_stctl(struct kvm_vcpu *vcpu)\r\n{\r\nint reg1 = (vcpu->arch.sie_block->ipa & 0x00f0) >> 4;\r\nint reg3 = vcpu->arch.sie_block->ipa & 0x000f;\r\nu64 ga;\r\nu32 val;\r\nint reg, rc;\r\nvcpu->stat.instruction_stctl++;\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\nga = kvm_s390_get_base_disp_rs(vcpu);\r\nif (ga & 3)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nVCPU_EVENT(vcpu, 5, "stctl r1:%x, r3:%x, addr:%llx", reg1, reg3, ga);\r\ntrace_kvm_s390_handle_stctl(vcpu, 0, reg1, reg3, ga);\r\nreg = reg1;\r\ndo {\r\nval = vcpu->arch.sie_block->gcr[reg] & 0x00000000fffffffful;\r\nrc = write_guest(vcpu, ga, &val, sizeof(val));\r\nif (rc)\r\nreturn kvm_s390_inject_prog_cond(vcpu, rc);\r\nga += 4;\r\nif (reg == reg3)\r\nbreak;\r\nreg = (reg + 1) % 16;\r\n} while (1);\r\nreturn 0;\r\n}\r\nstatic int handle_lctlg(struct kvm_vcpu *vcpu)\r\n{\r\nint reg1 = (vcpu->arch.sie_block->ipa & 0x00f0) >> 4;\r\nint reg3 = vcpu->arch.sie_block->ipa & 0x000f;\r\nu64 ga, val;\r\nint reg, rc;\r\nvcpu->stat.instruction_lctlg++;\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\nga = kvm_s390_get_base_disp_rsy(vcpu);\r\nif (ga & 7)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nreg = reg1;\r\nVCPU_EVENT(vcpu, 5, "lctlg r1:%x, r3:%x, addr:%llx", reg1, reg3, ga);\r\ntrace_kvm_s390_handle_lctl(vcpu, 1, reg1, reg3, ga);\r\ndo {\r\nrc = read_guest(vcpu, ga, &val, sizeof(val));\r\nif (rc)\r\nreturn kvm_s390_inject_prog_cond(vcpu, rc);\r\nvcpu->arch.sie_block->gcr[reg] = val;\r\nga += 8;\r\nif (reg == reg3)\r\nbreak;\r\nreg = (reg + 1) % 16;\r\n} while (1);\r\nreturn 0;\r\n}\r\nstatic int handle_stctg(struct kvm_vcpu *vcpu)\r\n{\r\nint reg1 = (vcpu->arch.sie_block->ipa & 0x00f0) >> 4;\r\nint reg3 = vcpu->arch.sie_block->ipa & 0x000f;\r\nu64 ga, val;\r\nint reg, rc;\r\nvcpu->stat.instruction_stctg++;\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\nga = kvm_s390_get_base_disp_rsy(vcpu);\r\nif (ga & 7)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);\r\nreg = reg1;\r\nVCPU_EVENT(vcpu, 5, "stctg r1:%x, r3:%x, addr:%llx", reg1, reg3, ga);\r\ntrace_kvm_s390_handle_stctl(vcpu, 1, reg1, reg3, ga);\r\ndo {\r\nval = vcpu->arch.sie_block->gcr[reg];\r\nrc = write_guest(vcpu, ga, &val, sizeof(val));\r\nif (rc)\r\nreturn kvm_s390_inject_prog_cond(vcpu, rc);\r\nga += 8;\r\nif (reg == reg3)\r\nbreak;\r\nreg = (reg + 1) % 16;\r\n} while (1);\r\nreturn 0;\r\n}\r\nint kvm_s390_handle_eb(struct kvm_vcpu *vcpu)\r\n{\r\nintercept_handler_t handler;\r\nhandler = eb_handlers[vcpu->arch.sie_block->ipb & 0xff];\r\nif (handler)\r\nreturn handler(vcpu);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int handle_tprot(struct kvm_vcpu *vcpu)\r\n{\r\nu64 address1, address2;\r\nunsigned long hva, gpa;\r\nint ret = 0, cc = 0;\r\nbool writable;\r\nvcpu->stat.instruction_tprot++;\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\nkvm_s390_get_base_disp_sse(vcpu, &address1, &address2);\r\nif (address2 & 0xf0)\r\nreturn -EOPNOTSUPP;\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_DAT)\r\nipte_lock(vcpu);\r\nret = guest_translate_address(vcpu, address1, &gpa, 1);\r\nif (ret == PGM_PROTECTION) {\r\ncc = 1;\r\nret = guest_translate_address(vcpu, address1, &gpa, 0);\r\n}\r\nif (ret) {\r\nif (ret == PGM_ADDRESSING || ret == PGM_TRANSLATION_SPEC) {\r\nret = kvm_s390_inject_program_int(vcpu, ret);\r\n} else if (ret > 0) {\r\nkvm_s390_set_psw_cc(vcpu, 3);\r\nret = 0;\r\n}\r\ngoto out_unlock;\r\n}\r\nhva = gfn_to_hva_prot(vcpu->kvm, gpa_to_gfn(gpa), &writable);\r\nif (kvm_is_error_hva(hva)) {\r\nret = kvm_s390_inject_program_int(vcpu, PGM_ADDRESSING);\r\n} else {\r\nif (!writable)\r\ncc = 1;\r\nkvm_s390_set_psw_cc(vcpu, cc);\r\n}\r\nout_unlock:\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_DAT)\r\nipte_unlock(vcpu);\r\nreturn ret;\r\n}\r\nint kvm_s390_handle_e5(struct kvm_vcpu *vcpu)\r\n{\r\nif ((vcpu->arch.sie_block->ipa & 0x00ff) == 0x01)\r\nreturn handle_tprot(vcpu);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int handle_sckpf(struct kvm_vcpu *vcpu)\r\n{\r\nu32 value;\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\nif (vcpu->run->s.regs.gprs[0] & 0x00000000ffff0000)\r\nreturn kvm_s390_inject_program_int(vcpu,\r\nPGM_SPECIFICATION);\r\nvalue = vcpu->run->s.regs.gprs[0] & 0x000000000000ffff;\r\nvcpu->arch.sie_block->todpr = value;\r\nreturn 0;\r\n}\r\nint kvm_s390_handle_01(struct kvm_vcpu *vcpu)\r\n{\r\nintercept_handler_t handler;\r\nhandler = x01_handlers[vcpu->arch.sie_block->ipa & 0x00ff];\r\nif (handler)\r\nreturn handler(vcpu);\r\nreturn -EOPNOTSUPP;\r\n}
