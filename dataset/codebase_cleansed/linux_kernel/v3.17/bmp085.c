static irqreturn_t bmp085_eoc_isr(int irq, void *devid)\r\n{\r\nstruct bmp085_data *data = devid;\r\ncomplete(&data->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic s32 bmp085_read_calibration_data(struct bmp085_data *data)\r\n{\r\nu16 tmp[BMP085_CALIBRATION_DATA_LENGTH];\r\nstruct bmp085_calibration_data *cali = &(data->calibration);\r\ns32 status = regmap_bulk_read(data->regmap,\r\nBMP085_CALIBRATION_DATA_START, (u8 *)tmp,\r\n(BMP085_CALIBRATION_DATA_LENGTH << 1));\r\nif (status < 0)\r\nreturn status;\r\ncali->AC1 = be16_to_cpu(tmp[0]);\r\ncali->AC2 = be16_to_cpu(tmp[1]);\r\ncali->AC3 = be16_to_cpu(tmp[2]);\r\ncali->AC4 = be16_to_cpu(tmp[3]);\r\ncali->AC5 = be16_to_cpu(tmp[4]);\r\ncali->AC6 = be16_to_cpu(tmp[5]);\r\ncali->B1 = be16_to_cpu(tmp[6]);\r\ncali->B2 = be16_to_cpu(tmp[7]);\r\ncali->MB = be16_to_cpu(tmp[8]);\r\ncali->MC = be16_to_cpu(tmp[9]);\r\ncali->MD = be16_to_cpu(tmp[10]);\r\nreturn 0;\r\n}\r\nstatic s32 bmp085_update_raw_temperature(struct bmp085_data *data)\r\n{\r\nu16 tmp;\r\ns32 status;\r\nmutex_lock(&data->lock);\r\ninit_completion(&data->done);\r\nstatus = regmap_write(data->regmap, BMP085_CTRL_REG,\r\nBMP085_TEMP_MEASUREMENT);\r\nif (status < 0) {\r\ndev_err(data->dev,\r\n"Error while requesting temperature measurement.\n");\r\ngoto exit;\r\n}\r\nwait_for_completion_timeout(&data->done, 1 + msecs_to_jiffies(\r\nBMP085_TEMP_CONVERSION_TIME));\r\nstatus = regmap_bulk_read(data->regmap, BMP085_CONVERSION_REGISTER_MSB,\r\n&tmp, sizeof(tmp));\r\nif (status < 0) {\r\ndev_err(data->dev,\r\n"Error while reading temperature measurement result\n");\r\ngoto exit;\r\n}\r\ndata->raw_temperature = be16_to_cpu(tmp);\r\ndata->last_temp_measurement = jiffies;\r\nstatus = 0;\r\nexit:\r\nmutex_unlock(&data->lock);\r\nreturn status;\r\n}\r\nstatic s32 bmp085_update_raw_pressure(struct bmp085_data *data)\r\n{\r\nu32 tmp = 0;\r\ns32 status;\r\nmutex_lock(&data->lock);\r\ninit_completion(&data->done);\r\nstatus = regmap_write(data->regmap, BMP085_CTRL_REG,\r\nBMP085_PRESSURE_MEASUREMENT +\r\n(data->oversampling_setting << 6));\r\nif (status < 0) {\r\ndev_err(data->dev,\r\n"Error while requesting pressure measurement.\n");\r\ngoto exit;\r\n}\r\nwait_for_completion_timeout(&data->done, 1 + msecs_to_jiffies(\r\n2+(3 << data->oversampling_setting)));\r\nstatus = regmap_bulk_read(data->regmap, BMP085_CONVERSION_REGISTER_MSB,\r\n((u8 *)&tmp)+1, 3);\r\nif (status < 0) {\r\ndev_err(data->dev,\r\n"Error while reading pressure measurement results\n");\r\ngoto exit;\r\n}\r\ndata->raw_pressure = be32_to_cpu((tmp));\r\ndata->raw_pressure >>= (8-data->oversampling_setting);\r\nstatus = 0;\r\nexit:\r\nmutex_unlock(&data->lock);\r\nreturn status;\r\n}\r\nstatic s32 bmp085_get_temperature(struct bmp085_data *data, int *temperature)\r\n{\r\nstruct bmp085_calibration_data *cali = &data->calibration;\r\nlong x1, x2;\r\nint status;\r\nstatus = bmp085_update_raw_temperature(data);\r\nif (status < 0)\r\ngoto exit;\r\nx1 = ((data->raw_temperature - cali->AC6) * cali->AC5) >> 15;\r\nx2 = (cali->MC << 11) / (x1 + cali->MD);\r\ndata->b6 = x1 + x2 - 4000;\r\nif (temperature != NULL)\r\n*temperature = (x1+x2+8) >> 4;\r\nexit:\r\nreturn status;\r\n}\r\nstatic s32 bmp085_get_pressure(struct bmp085_data *data, int *pressure)\r\n{\r\nstruct bmp085_calibration_data *cali = &data->calibration;\r\ns32 x1, x2, x3, b3;\r\nu32 b4, b7;\r\ns32 p;\r\nint status;\r\nif ((data->last_temp_measurement == 0) ||\r\ntime_is_before_jiffies(data->last_temp_measurement + 1*HZ)) {\r\nstatus = bmp085_get_temperature(data, NULL);\r\nif (status < 0)\r\nreturn status;\r\n}\r\nstatus = bmp085_update_raw_pressure(data);\r\nif (status < 0)\r\nreturn status;\r\nx1 = (data->b6 * data->b6) >> 12;\r\nx1 *= cali->B2;\r\nx1 >>= 11;\r\nx2 = cali->AC2 * data->b6;\r\nx2 >>= 11;\r\nx3 = x1 + x2;\r\nb3 = (((((s32)cali->AC1) * 4 + x3) << data->oversampling_setting) + 2);\r\nb3 >>= 2;\r\nx1 = (cali->AC3 * data->b6) >> 13;\r\nx2 = (cali->B1 * ((data->b6 * data->b6) >> 12)) >> 16;\r\nx3 = (x1 + x2 + 2) >> 2;\r\nb4 = (cali->AC4 * (u32)(x3 + 32768)) >> 15;\r\nb7 = ((u32)data->raw_pressure - b3) *\r\n(50000 >> data->oversampling_setting);\r\np = ((b7 < 0x80000000) ? ((b7 << 1) / b4) : ((b7 / b4) * 2));\r\nx1 = p >> 8;\r\nx1 *= x1;\r\nx1 = (x1 * 3038) >> 16;\r\nx2 = (-7357 * p) >> 16;\r\np += (x1 + x2 + 3791) >> 4;\r\n*pressure = p;\r\nreturn 0;\r\n}\r\nstatic void bmp085_set_oversampling(struct bmp085_data *data,\r\nunsigned char oversampling)\r\n{\r\nif (oversampling > 3)\r\noversampling = 3;\r\ndata->oversampling_setting = oversampling;\r\n}\r\nstatic unsigned char bmp085_get_oversampling(struct bmp085_data *data)\r\n{\r\nreturn data->oversampling_setting;\r\n}\r\nstatic ssize_t set_oversampling(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct bmp085_data *data = dev_get_drvdata(dev);\r\nunsigned long oversampling;\r\nint err = kstrtoul(buf, 10, &oversampling);\r\nif (err == 0) {\r\nmutex_lock(&data->lock);\r\nbmp085_set_oversampling(data, oversampling);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nreturn err;\r\n}\r\nstatic ssize_t show_oversampling(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bmp085_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", bmp085_get_oversampling(data));\r\n}\r\nstatic ssize_t show_temperature(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint temperature;\r\nint status;\r\nstruct bmp085_data *data = dev_get_drvdata(dev);\r\nstatus = bmp085_get_temperature(data, &temperature);\r\nif (status < 0)\r\nreturn status;\r\nelse\r\nreturn sprintf(buf, "%d\n", temperature);\r\n}\r\nstatic ssize_t show_pressure(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint pressure;\r\nint status;\r\nstruct bmp085_data *data = dev_get_drvdata(dev);\r\nstatus = bmp085_get_pressure(data, &pressure);\r\nif (status < 0)\r\nreturn status;\r\nelse\r\nreturn sprintf(buf, "%d\n", pressure);\r\n}\r\nint bmp085_detect(struct device *dev)\r\n{\r\nstruct bmp085_data *data = dev_get_drvdata(dev);\r\nunsigned int id;\r\nint ret;\r\nret = regmap_read(data->regmap, BMP085_CHIP_ID_REG, &id);\r\nif (ret < 0)\r\nreturn ret;\r\nif (id != data->chip_id)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void bmp085_get_of_properties(struct bmp085_data *data)\r\n{\r\n#ifdef CONFIG_OF\r\nstruct device_node *np = data->dev->of_node;\r\nu32 prop;\r\nif (!np)\r\nreturn;\r\nif (!of_property_read_u32(np, "chip-id", &prop))\r\ndata->chip_id = prop & 0xff;\r\nif (!of_property_read_u32(np, "temp-measurement-period", &prop))\r\ndata->temp_measurement_period = (prop/100)*HZ;\r\nif (!of_property_read_u32(np, "default-oversampling", &prop))\r\ndata->oversampling_setting = prop & 0xff;\r\n#endif\r\n}\r\nstatic int bmp085_init_client(struct bmp085_data *data)\r\n{\r\nint status = bmp085_read_calibration_data(data);\r\nif (status < 0)\r\nreturn status;\r\ndata->chip_id = BMP085_CHIP_ID;\r\ndata->last_temp_measurement = 0;\r\ndata->temp_measurement_period = 1*HZ;\r\ndata->oversampling_setting = 3;\r\nbmp085_get_of_properties(data);\r\nmutex_init(&data->lock);\r\nreturn 0;\r\n}\r\nint bmp085_probe(struct device *dev, struct regmap *regmap, int irq)\r\n{\r\nstruct bmp085_data *data;\r\nint err = 0;\r\ndata = kzalloc(sizeof(struct bmp085_data), GFP_KERNEL);\r\nif (!data) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ndev_set_drvdata(dev, data);\r\ndata->dev = dev;\r\ndata->regmap = regmap;\r\ndata->irq = irq;\r\nif (data->irq > 0) {\r\nerr = devm_request_irq(dev, data->irq, bmp085_eoc_isr,\r\nIRQF_TRIGGER_RISING, "bmp085",\r\ndata);\r\nif (err < 0)\r\ngoto exit_free;\r\n}\r\nerr = bmp085_init_client(data);\r\nif (err < 0)\r\ngoto exit_free;\r\nerr = bmp085_detect(dev);\r\nif (err < 0) {\r\ndev_err(dev, "%s: chip_id failed!\n", BMP085_NAME);\r\ngoto exit_free;\r\n}\r\nerr = sysfs_create_group(&dev->kobj, &bmp085_attr_group);\r\nif (err)\r\ngoto exit_free;\r\ndev_info(dev, "Successfully initialized %s!\n", BMP085_NAME);\r\nreturn 0;\r\nexit_free:\r\nkfree(data);\r\nexit:\r\nreturn err;\r\n}\r\nint bmp085_remove(struct device *dev)\r\n{\r\nstruct bmp085_data *data = dev_get_drvdata(dev);\r\nsysfs_remove_group(&data->dev->kobj, &bmp085_attr_group);\r\nkfree(data);\r\nreturn 0;\r\n}
