static unsigned time_diff(struct timeval *now, struct timeval *then)\r\n{\r\nreturn (now->tv_usec >= then->tv_usec) ?\r\nnow->tv_usec - then->tv_usec :\r\n1000000 - (then->tv_usec - now->tv_usec);\r\n}\r\nu32 via_get_vblank_counter(struct drm_device *dev, int crtc)\r\n{\r\ndrm_via_private_t *dev_priv = dev->dev_private;\r\nif (crtc != 0)\r\nreturn 0;\r\nreturn atomic_read(&dev_priv->vbl_received);\r\n}\r\nirqreturn_t via_driver_irq_handler(int irq, void *arg)\r\n{\r\nstruct drm_device *dev = (struct drm_device *) arg;\r\ndrm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;\r\nu32 status;\r\nint handled = 0;\r\nstruct timeval cur_vblank;\r\ndrm_via_irq_t *cur_irq = dev_priv->via_irqs;\r\nint i;\r\nstatus = VIA_READ(VIA_REG_INTERRUPT);\r\nif (status & VIA_IRQ_VBLANK_PENDING) {\r\natomic_inc(&dev_priv->vbl_received);\r\nif (!(atomic_read(&dev_priv->vbl_received) & 0x0F)) {\r\ndo_gettimeofday(&cur_vblank);\r\nif (dev_priv->last_vblank_valid) {\r\ndev_priv->usec_per_vblank =\r\ntime_diff(&cur_vblank,\r\n&dev_priv->last_vblank) >> 4;\r\n}\r\ndev_priv->last_vblank = cur_vblank;\r\ndev_priv->last_vblank_valid = 1;\r\n}\r\nif (!(atomic_read(&dev_priv->vbl_received) & 0xFF)) {\r\nDRM_DEBUG("US per vblank is: %u\n",\r\ndev_priv->usec_per_vblank);\r\n}\r\ndrm_handle_vblank(dev, 0);\r\nhandled = 1;\r\n}\r\nfor (i = 0; i < dev_priv->num_irqs; ++i) {\r\nif (status & cur_irq->pending_mask) {\r\natomic_inc(&cur_irq->irq_received);\r\nwake_up(&cur_irq->irq_queue);\r\nhandled = 1;\r\nif (dev_priv->irq_map[drm_via_irq_dma0_td] == i)\r\nvia_dmablit_handler(dev, 0, 1);\r\nelse if (dev_priv->irq_map[drm_via_irq_dma1_td] == i)\r\nvia_dmablit_handler(dev, 1, 1);\r\n}\r\ncur_irq++;\r\n}\r\nVIA_WRITE(VIA_REG_INTERRUPT, status);\r\nif (handled)\r\nreturn IRQ_HANDLED;\r\nelse\r\nreturn IRQ_NONE;\r\n}\r\nstatic __inline__ void viadrv_acknowledge_irqs(drm_via_private_t *dev_priv)\r\n{\r\nu32 status;\r\nif (dev_priv) {\r\nstatus = VIA_READ(VIA_REG_INTERRUPT);\r\nVIA_WRITE(VIA_REG_INTERRUPT, status |\r\ndev_priv->irq_pending_mask);\r\n}\r\n}\r\nint via_enable_vblank(struct drm_device *dev, int crtc)\r\n{\r\ndrm_via_private_t *dev_priv = dev->dev_private;\r\nu32 status;\r\nif (crtc != 0) {\r\nDRM_ERROR("%s: bad crtc %d\n", __func__, crtc);\r\nreturn -EINVAL;\r\n}\r\nstatus = VIA_READ(VIA_REG_INTERRUPT);\r\nVIA_WRITE(VIA_REG_INTERRUPT, status | VIA_IRQ_VBLANK_ENABLE);\r\nVIA_WRITE8(0x83d4, 0x11);\r\nVIA_WRITE8(0x83d5, VIA_READ8(0x83d5) | 0x30);\r\nreturn 0;\r\n}\r\nvoid via_disable_vblank(struct drm_device *dev, int crtc)\r\n{\r\ndrm_via_private_t *dev_priv = dev->dev_private;\r\nu32 status;\r\nstatus = VIA_READ(VIA_REG_INTERRUPT);\r\nVIA_WRITE(VIA_REG_INTERRUPT, status & ~VIA_IRQ_VBLANK_ENABLE);\r\nVIA_WRITE8(0x83d4, 0x11);\r\nVIA_WRITE8(0x83d5, VIA_READ8(0x83d5) & ~0x30);\r\nif (crtc != 0)\r\nDRM_ERROR("%s: bad crtc %d\n", __func__, crtc);\r\n}\r\nstatic int\r\nvia_driver_irq_wait(struct drm_device *dev, unsigned int irq, int force_sequence,\r\nunsigned int *sequence)\r\n{\r\ndrm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;\r\nunsigned int cur_irq_sequence;\r\ndrm_via_irq_t *cur_irq;\r\nint ret = 0;\r\nmaskarray_t *masks;\r\nint real_irq;\r\nDRM_DEBUG("\n");\r\nif (!dev_priv) {\r\nDRM_ERROR("called with no initialization\n");\r\nreturn -EINVAL;\r\n}\r\nif (irq >= drm_via_irq_num) {\r\nDRM_ERROR("Trying to wait on unknown irq %d\n", irq);\r\nreturn -EINVAL;\r\n}\r\nreal_irq = dev_priv->irq_map[irq];\r\nif (real_irq < 0) {\r\nDRM_ERROR("Video IRQ %d not available on this hardware.\n",\r\nirq);\r\nreturn -EINVAL;\r\n}\r\nmasks = dev_priv->irq_masks;\r\ncur_irq = dev_priv->via_irqs + real_irq;\r\nif (masks[real_irq][2] && !force_sequence) {\r\nDRM_WAIT_ON(ret, cur_irq->irq_queue, 3 * HZ,\r\n((VIA_READ(masks[irq][2]) & masks[irq][3]) ==\r\nmasks[irq][4]));\r\ncur_irq_sequence = atomic_read(&cur_irq->irq_received);\r\n} else {\r\nDRM_WAIT_ON(ret, cur_irq->irq_queue, 3 * HZ,\r\n(((cur_irq_sequence =\r\natomic_read(&cur_irq->irq_received)) -\r\n*sequence) <= (1 << 23)));\r\n}\r\n*sequence = cur_irq_sequence;\r\nreturn ret;\r\n}\r\nvoid via_driver_irq_preinstall(struct drm_device *dev)\r\n{\r\ndrm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;\r\nu32 status;\r\ndrm_via_irq_t *cur_irq;\r\nint i;\r\nDRM_DEBUG("dev_priv: %p\n", dev_priv);\r\nif (dev_priv) {\r\ncur_irq = dev_priv->via_irqs;\r\ndev_priv->irq_enable_mask = VIA_IRQ_VBLANK_ENABLE;\r\ndev_priv->irq_pending_mask = VIA_IRQ_VBLANK_PENDING;\r\nif (dev_priv->chipset == VIA_PRO_GROUP_A ||\r\ndev_priv->chipset == VIA_DX9_0) {\r\ndev_priv->irq_masks = via_pro_group_a_irqs;\r\ndev_priv->num_irqs = via_num_pro_group_a;\r\ndev_priv->irq_map = via_irqmap_pro_group_a;\r\n} else {\r\ndev_priv->irq_masks = via_unichrome_irqs;\r\ndev_priv->num_irqs = via_num_unichrome;\r\ndev_priv->irq_map = via_irqmap_unichrome;\r\n}\r\nfor (i = 0; i < dev_priv->num_irqs; ++i) {\r\natomic_set(&cur_irq->irq_received, 0);\r\ncur_irq->enable_mask = dev_priv->irq_masks[i][0];\r\ncur_irq->pending_mask = dev_priv->irq_masks[i][1];\r\ninit_waitqueue_head(&cur_irq->irq_queue);\r\ndev_priv->irq_enable_mask |= cur_irq->enable_mask;\r\ndev_priv->irq_pending_mask |= cur_irq->pending_mask;\r\ncur_irq++;\r\nDRM_DEBUG("Initializing IRQ %d\n", i);\r\n}\r\ndev_priv->last_vblank_valid = 0;\r\nstatus = VIA_READ(VIA_REG_INTERRUPT);\r\nVIA_WRITE(VIA_REG_INTERRUPT, status &\r\n~(dev_priv->irq_enable_mask));\r\nviadrv_acknowledge_irqs(dev_priv);\r\n}\r\n}\r\nint via_driver_irq_postinstall(struct drm_device *dev)\r\n{\r\ndrm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;\r\nu32 status;\r\nDRM_DEBUG("via_driver_irq_postinstall\n");\r\nif (!dev_priv)\r\nreturn -EINVAL;\r\nstatus = VIA_READ(VIA_REG_INTERRUPT);\r\nVIA_WRITE(VIA_REG_INTERRUPT, status | VIA_IRQ_GLOBAL\r\n| dev_priv->irq_enable_mask);\r\nVIA_WRITE8(0x83d4, 0x11);\r\nVIA_WRITE8(0x83d5, VIA_READ8(0x83d5) | 0x30);\r\nreturn 0;\r\n}\r\nvoid via_driver_irq_uninstall(struct drm_device *dev)\r\n{\r\ndrm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;\r\nu32 status;\r\nDRM_DEBUG("\n");\r\nif (dev_priv) {\r\nVIA_WRITE8(0x83d4, 0x11);\r\nVIA_WRITE8(0x83d5, VIA_READ8(0x83d5) & ~0x30);\r\nstatus = VIA_READ(VIA_REG_INTERRUPT);\r\nVIA_WRITE(VIA_REG_INTERRUPT, status &\r\n~(VIA_IRQ_VBLANK_ENABLE | dev_priv->irq_enable_mask));\r\n}\r\n}\r\nint via_wait_irq(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_via_irqwait_t *irqwait = data;\r\nstruct timeval now;\r\nint ret = 0;\r\ndrm_via_private_t *dev_priv = (drm_via_private_t *) dev->dev_private;\r\ndrm_via_irq_t *cur_irq = dev_priv->via_irqs;\r\nint force_sequence;\r\nif (irqwait->request.irq >= dev_priv->num_irqs) {\r\nDRM_ERROR("Trying to wait on unknown irq %d\n",\r\nirqwait->request.irq);\r\nreturn -EINVAL;\r\n}\r\ncur_irq += irqwait->request.irq;\r\nswitch (irqwait->request.type & ~VIA_IRQ_FLAGS_MASK) {\r\ncase VIA_IRQ_RELATIVE:\r\nirqwait->request.sequence +=\r\natomic_read(&cur_irq->irq_received);\r\nirqwait->request.type &= ~_DRM_VBLANK_RELATIVE;\r\ncase VIA_IRQ_ABSOLUTE:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (irqwait->request.type & VIA_IRQ_SIGNAL) {\r\nDRM_ERROR("Signals on Via IRQs not implemented yet.\n");\r\nreturn -EINVAL;\r\n}\r\nforce_sequence = (irqwait->request.type & VIA_IRQ_FORCE_SEQUENCE);\r\nret = via_driver_irq_wait(dev, irqwait->request.irq, force_sequence,\r\n&irqwait->request.sequence);\r\ndo_gettimeofday(&now);\r\nirqwait->reply.tval_sec = now.tv_sec;\r\nirqwait->reply.tval_usec = now.tv_usec;\r\nreturn ret;\r\n}
