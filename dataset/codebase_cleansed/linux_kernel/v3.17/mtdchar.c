static loff_t mtdchar_lseek(struct file *file, loff_t offset, int orig)\r\n{\r\nstruct mtd_file_info *mfi = file->private_data;\r\nreturn fixed_size_llseek(file, offset, orig, mfi->mtd->size);\r\n}\r\nstatic int mtdchar_open(struct inode *inode, struct file *file)\r\n{\r\nint minor = iminor(inode);\r\nint devnum = minor >> 1;\r\nint ret = 0;\r\nstruct mtd_info *mtd;\r\nstruct mtd_file_info *mfi;\r\nstruct inode *mtd_ino;\r\npr_debug("MTD_open\n");\r\nif ((file->f_mode & FMODE_WRITE) && (minor & 1))\r\nreturn -EACCES;\r\nret = simple_pin_fs(&mtd_inodefs_type, &mnt, &count);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&mtd_mutex);\r\nmtd = get_mtd_device(NULL, devnum);\r\nif (IS_ERR(mtd)) {\r\nret = PTR_ERR(mtd);\r\ngoto out;\r\n}\r\nif (mtd->type == MTD_ABSENT) {\r\nret = -ENODEV;\r\ngoto out1;\r\n}\r\nmtd_ino = iget_locked(mnt->mnt_sb, devnum);\r\nif (!mtd_ino) {\r\nret = -ENOMEM;\r\ngoto out1;\r\n}\r\nif (mtd_ino->i_state & I_NEW) {\r\nmtd_ino->i_private = mtd;\r\nmtd_ino->i_mode = S_IFCHR;\r\nmtd_ino->i_data.backing_dev_info = mtd->backing_dev_info;\r\nunlock_new_inode(mtd_ino);\r\n}\r\nfile->f_mapping = mtd_ino->i_mapping;\r\nif ((file->f_mode & FMODE_WRITE) && !(mtd->flags & MTD_WRITEABLE)) {\r\nret = -EACCES;\r\ngoto out2;\r\n}\r\nmfi = kzalloc(sizeof(*mfi), GFP_KERNEL);\r\nif (!mfi) {\r\nret = -ENOMEM;\r\ngoto out2;\r\n}\r\nmfi->ino = mtd_ino;\r\nmfi->mtd = mtd;\r\nfile->private_data = mfi;\r\nmutex_unlock(&mtd_mutex);\r\nreturn 0;\r\nout2:\r\niput(mtd_ino);\r\nout1:\r\nput_mtd_device(mtd);\r\nout:\r\nmutex_unlock(&mtd_mutex);\r\nsimple_release_fs(&mnt, &count);\r\nreturn ret;\r\n}\r\nstatic int mtdchar_close(struct inode *inode, struct file *file)\r\n{\r\nstruct mtd_file_info *mfi = file->private_data;\r\nstruct mtd_info *mtd = mfi->mtd;\r\npr_debug("MTD_close\n");\r\nif ((file->f_mode & FMODE_WRITE))\r\nmtd_sync(mtd);\r\niput(mfi->ino);\r\nput_mtd_device(mtd);\r\nfile->private_data = NULL;\r\nkfree(mfi);\r\nsimple_release_fs(&mnt, &count);\r\nreturn 0;\r\n}\r\nstatic ssize_t mtdchar_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct mtd_file_info *mfi = file->private_data;\r\nstruct mtd_info *mtd = mfi->mtd;\r\nsize_t retlen;\r\nsize_t total_retlen=0;\r\nint ret=0;\r\nint len;\r\nsize_t size = count;\r\nchar *kbuf;\r\npr_debug("MTD_read\n");\r\nif (*ppos + count > mtd->size)\r\ncount = mtd->size - *ppos;\r\nif (!count)\r\nreturn 0;\r\nkbuf = mtd_kmalloc_up_to(mtd, &size);\r\nif (!kbuf)\r\nreturn -ENOMEM;\r\nwhile (count) {\r\nlen = min_t(size_t, count, size);\r\nswitch (mfi->mode) {\r\ncase MTD_FILE_MODE_OTP_FACTORY:\r\nret = mtd_read_fact_prot_reg(mtd, *ppos, len,\r\n&retlen, kbuf);\r\nbreak;\r\ncase MTD_FILE_MODE_OTP_USER:\r\nret = mtd_read_user_prot_reg(mtd, *ppos, len,\r\n&retlen, kbuf);\r\nbreak;\r\ncase MTD_FILE_MODE_RAW:\r\n{\r\nstruct mtd_oob_ops ops;\r\nops.mode = MTD_OPS_RAW;\r\nops.datbuf = kbuf;\r\nops.oobbuf = NULL;\r\nops.len = len;\r\nret = mtd_read_oob(mtd, *ppos, &ops);\r\nretlen = ops.retlen;\r\nbreak;\r\n}\r\ndefault:\r\nret = mtd_read(mtd, *ppos, len, &retlen, kbuf);\r\n}\r\nif (!ret || mtd_is_bitflip_or_eccerr(ret)) {\r\n*ppos += retlen;\r\nif (copy_to_user(buf, kbuf, retlen)) {\r\nkfree(kbuf);\r\nreturn -EFAULT;\r\n}\r\nelse\r\ntotal_retlen += retlen;\r\ncount -= retlen;\r\nbuf += retlen;\r\nif (retlen == 0)\r\ncount = 0;\r\n}\r\nelse {\r\nkfree(kbuf);\r\nreturn ret;\r\n}\r\n}\r\nkfree(kbuf);\r\nreturn total_retlen;\r\n}\r\nstatic ssize_t mtdchar_write(struct file *file, const char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct mtd_file_info *mfi = file->private_data;\r\nstruct mtd_info *mtd = mfi->mtd;\r\nsize_t size = count;\r\nchar *kbuf;\r\nsize_t retlen;\r\nsize_t total_retlen=0;\r\nint ret=0;\r\nint len;\r\npr_debug("MTD_write\n");\r\nif (*ppos == mtd->size)\r\nreturn -ENOSPC;\r\nif (*ppos + count > mtd->size)\r\ncount = mtd->size - *ppos;\r\nif (!count)\r\nreturn 0;\r\nkbuf = mtd_kmalloc_up_to(mtd, &size);\r\nif (!kbuf)\r\nreturn -ENOMEM;\r\nwhile (count) {\r\nlen = min_t(size_t, count, size);\r\nif (copy_from_user(kbuf, buf, len)) {\r\nkfree(kbuf);\r\nreturn -EFAULT;\r\n}\r\nswitch (mfi->mode) {\r\ncase MTD_FILE_MODE_OTP_FACTORY:\r\nret = -EROFS;\r\nbreak;\r\ncase MTD_FILE_MODE_OTP_USER:\r\nret = mtd_write_user_prot_reg(mtd, *ppos, len,\r\n&retlen, kbuf);\r\nbreak;\r\ncase MTD_FILE_MODE_RAW:\r\n{\r\nstruct mtd_oob_ops ops;\r\nops.mode = MTD_OPS_RAW;\r\nops.datbuf = kbuf;\r\nops.oobbuf = NULL;\r\nops.ooboffs = 0;\r\nops.len = len;\r\nret = mtd_write_oob(mtd, *ppos, &ops);\r\nretlen = ops.retlen;\r\nbreak;\r\n}\r\ndefault:\r\nret = mtd_write(mtd, *ppos, len, &retlen, kbuf);\r\n}\r\nif ((ret == -ENOSPC) && (total_retlen))\r\nbreak;\r\nif (!ret) {\r\n*ppos += retlen;\r\ntotal_retlen += retlen;\r\ncount -= retlen;\r\nbuf += retlen;\r\n}\r\nelse {\r\nkfree(kbuf);\r\nreturn ret;\r\n}\r\n}\r\nkfree(kbuf);\r\nreturn total_retlen;\r\n}\r\nstatic void mtdchar_erase_callback (struct erase_info *instr)\r\n{\r\nwake_up((wait_queue_head_t *)instr->priv);\r\n}\r\nstatic int otp_select_filemode(struct mtd_file_info *mfi, int mode)\r\n{\r\nstruct mtd_info *mtd = mfi->mtd;\r\nsize_t retlen;\r\nswitch (mode) {\r\ncase MTD_OTP_FACTORY:\r\nif (mtd_read_fact_prot_reg(mtd, -1, 0, &retlen, NULL) ==\r\n-EOPNOTSUPP)\r\nreturn -EOPNOTSUPP;\r\nmfi->mode = MTD_FILE_MODE_OTP_FACTORY;\r\nbreak;\r\ncase MTD_OTP_USER:\r\nif (mtd_read_user_prot_reg(mtd, -1, 0, &retlen, NULL) ==\r\n-EOPNOTSUPP)\r\nreturn -EOPNOTSUPP;\r\nmfi->mode = MTD_FILE_MODE_OTP_USER;\r\nbreak;\r\ncase MTD_OTP_OFF:\r\nmfi->mode = MTD_FILE_MODE_NORMAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mtdchar_writeoob(struct file *file, struct mtd_info *mtd,\r\nuint64_t start, uint32_t length, void __user *ptr,\r\nuint32_t __user *retp)\r\n{\r\nstruct mtd_file_info *mfi = file->private_data;\r\nstruct mtd_oob_ops ops;\r\nuint32_t retlen;\r\nint ret = 0;\r\nif (!(file->f_mode & FMODE_WRITE))\r\nreturn -EPERM;\r\nif (length > 4096)\r\nreturn -EINVAL;\r\nif (!mtd->_write_oob)\r\nret = -EOPNOTSUPP;\r\nelse\r\nret = access_ok(VERIFY_READ, ptr, length) ? 0 : -EFAULT;\r\nif (ret)\r\nreturn ret;\r\nops.ooblen = length;\r\nops.ooboffs = start & (mtd->writesize - 1);\r\nops.datbuf = NULL;\r\nops.mode = (mfi->mode == MTD_FILE_MODE_RAW) ? MTD_OPS_RAW :\r\nMTD_OPS_PLACE_OOB;\r\nif (ops.ooboffs && ops.ooblen > (mtd->oobsize - ops.ooboffs))\r\nreturn -EINVAL;\r\nops.oobbuf = memdup_user(ptr, length);\r\nif (IS_ERR(ops.oobbuf))\r\nreturn PTR_ERR(ops.oobbuf);\r\nstart &= ~((uint64_t)mtd->writesize - 1);\r\nret = mtd_write_oob(mtd, start, &ops);\r\nif (ops.oobretlen > 0xFFFFFFFFU)\r\nret = -EOVERFLOW;\r\nretlen = ops.oobretlen;\r\nif (copy_to_user(retp, &retlen, sizeof(length)))\r\nret = -EFAULT;\r\nkfree(ops.oobbuf);\r\nreturn ret;\r\n}\r\nstatic int mtdchar_readoob(struct file *file, struct mtd_info *mtd,\r\nuint64_t start, uint32_t length, void __user *ptr,\r\nuint32_t __user *retp)\r\n{\r\nstruct mtd_file_info *mfi = file->private_data;\r\nstruct mtd_oob_ops ops;\r\nint ret = 0;\r\nif (length > 4096)\r\nreturn -EINVAL;\r\nif (!access_ok(VERIFY_WRITE, ptr, length))\r\nreturn -EFAULT;\r\nops.ooblen = length;\r\nops.ooboffs = start & (mtd->writesize - 1);\r\nops.datbuf = NULL;\r\nops.mode = (mfi->mode == MTD_FILE_MODE_RAW) ? MTD_OPS_RAW :\r\nMTD_OPS_PLACE_OOB;\r\nif (ops.ooboffs && ops.ooblen > (mtd->oobsize - ops.ooboffs))\r\nreturn -EINVAL;\r\nops.oobbuf = kmalloc(length, GFP_KERNEL);\r\nif (!ops.oobbuf)\r\nreturn -ENOMEM;\r\nstart &= ~((uint64_t)mtd->writesize - 1);\r\nret = mtd_read_oob(mtd, start, &ops);\r\nif (put_user(ops.oobretlen, retp))\r\nret = -EFAULT;\r\nelse if (ops.oobretlen && copy_to_user(ptr, ops.oobbuf,\r\nops.oobretlen))\r\nret = -EFAULT;\r\nkfree(ops.oobbuf);\r\nif (mtd_is_bitflip_or_eccerr(ret))\r\nreturn 0;\r\nreturn ret;\r\n}\r\nstatic int shrink_ecclayout(const struct nand_ecclayout *from,\r\nstruct nand_ecclayout_user *to)\r\n{\r\nint i;\r\nif (!from || !to)\r\nreturn -EINVAL;\r\nmemset(to, 0, sizeof(*to));\r\nto->eccbytes = min((int)from->eccbytes, MTD_MAX_ECCPOS_ENTRIES);\r\nfor (i = 0; i < to->eccbytes; i++)\r\nto->eccpos[i] = from->eccpos[i];\r\nfor (i = 0; i < MTD_MAX_OOBFREE_ENTRIES; i++) {\r\nif (from->oobfree[i].length == 0 &&\r\nfrom->oobfree[i].offset == 0)\r\nbreak;\r\nto->oobavail += from->oobfree[i].length;\r\nto->oobfree[i] = from->oobfree[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic int mtdchar_blkpg_ioctl(struct mtd_info *mtd,\r\nstruct blkpg_ioctl_arg __user *arg)\r\n{\r\nstruct blkpg_ioctl_arg a;\r\nstruct blkpg_partition p;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&a, arg, sizeof(struct blkpg_ioctl_arg)))\r\nreturn -EFAULT;\r\nif (copy_from_user(&p, a.data, sizeof(struct blkpg_partition)))\r\nreturn -EFAULT;\r\nswitch (a.op) {\r\ncase BLKPG_ADD_PARTITION:\r\nif (mtd_is_partition(mtd))\r\nreturn -EINVAL;\r\nreturn mtd_add_partition(mtd, p.devname, p.start, p.length);\r\ncase BLKPG_DEL_PARTITION:\r\nif (p.pno < 0)\r\nreturn -EINVAL;\r\nreturn mtd_del_partition(mtd, p.pno);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int mtdchar_write_ioctl(struct mtd_info *mtd,\r\nstruct mtd_write_req __user *argp)\r\n{\r\nstruct mtd_write_req req;\r\nstruct mtd_oob_ops ops;\r\nconst void __user *usr_data, *usr_oob;\r\nint ret;\r\nif (copy_from_user(&req, argp, sizeof(req)))\r\nreturn -EFAULT;\r\nusr_data = (const void __user *)(uintptr_t)req.usr_data;\r\nusr_oob = (const void __user *)(uintptr_t)req.usr_oob;\r\nif (!access_ok(VERIFY_READ, usr_data, req.len) ||\r\n!access_ok(VERIFY_READ, usr_oob, req.ooblen))\r\nreturn -EFAULT;\r\nif (!mtd->_write_oob)\r\nreturn -EOPNOTSUPP;\r\nops.mode = req.mode;\r\nops.len = (size_t)req.len;\r\nops.ooblen = (size_t)req.ooblen;\r\nops.ooboffs = 0;\r\nif (usr_data) {\r\nops.datbuf = memdup_user(usr_data, ops.len);\r\nif (IS_ERR(ops.datbuf))\r\nreturn PTR_ERR(ops.datbuf);\r\n} else {\r\nops.datbuf = NULL;\r\n}\r\nif (usr_oob) {\r\nops.oobbuf = memdup_user(usr_oob, ops.ooblen);\r\nif (IS_ERR(ops.oobbuf)) {\r\nkfree(ops.datbuf);\r\nreturn PTR_ERR(ops.oobbuf);\r\n}\r\n} else {\r\nops.oobbuf = NULL;\r\n}\r\nret = mtd_write_oob(mtd, (loff_t)req.start, &ops);\r\nkfree(ops.datbuf);\r\nkfree(ops.oobbuf);\r\nreturn ret;\r\n}\r\nstatic int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)\r\n{\r\nstruct mtd_file_info *mfi = file->private_data;\r\nstruct mtd_info *mtd = mfi->mtd;\r\nvoid __user *argp = (void __user *)arg;\r\nint ret = 0;\r\nu_long size;\r\nstruct mtd_info_user info;\r\npr_debug("MTD_ioctl\n");\r\nsize = (cmd & IOCSIZE_MASK) >> IOCSIZE_SHIFT;\r\nif (cmd & IOC_IN) {\r\nif (!access_ok(VERIFY_READ, argp, size))\r\nreturn -EFAULT;\r\n}\r\nif (cmd & IOC_OUT) {\r\nif (!access_ok(VERIFY_WRITE, argp, size))\r\nreturn -EFAULT;\r\n}\r\nswitch (cmd) {\r\ncase MEMGETREGIONCOUNT:\r\nif (copy_to_user(argp, &(mtd->numeraseregions), sizeof(int)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase MEMGETREGIONINFO:\r\n{\r\nuint32_t ur_idx;\r\nstruct mtd_erase_region_info *kr;\r\nstruct region_info_user __user *ur = argp;\r\nif (get_user(ur_idx, &(ur->regionindex)))\r\nreturn -EFAULT;\r\nif (ur_idx >= mtd->numeraseregions)\r\nreturn -EINVAL;\r\nkr = &(mtd->eraseregions[ur_idx]);\r\nif (put_user(kr->offset, &(ur->offset))\r\n|| put_user(kr->erasesize, &(ur->erasesize))\r\n|| put_user(kr->numblocks, &(ur->numblocks)))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase MEMGETINFO:\r\nmemset(&info, 0, sizeof(info));\r\ninfo.type = mtd->type;\r\ninfo.flags = mtd->flags;\r\ninfo.size = mtd->size;\r\ninfo.erasesize = mtd->erasesize;\r\ninfo.writesize = mtd->writesize;\r\ninfo.oobsize = mtd->oobsize;\r\ninfo.padding = 0;\r\nif (copy_to_user(argp, &info, sizeof(struct mtd_info_user)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase MEMERASE:\r\ncase MEMERASE64:\r\n{\r\nstruct erase_info *erase;\r\nif(!(file->f_mode & FMODE_WRITE))\r\nreturn -EPERM;\r\nerase=kzalloc(sizeof(struct erase_info),GFP_KERNEL);\r\nif (!erase)\r\nret = -ENOMEM;\r\nelse {\r\nwait_queue_head_t waitq;\r\nDECLARE_WAITQUEUE(wait, current);\r\ninit_waitqueue_head(&waitq);\r\nif (cmd == MEMERASE64) {\r\nstruct erase_info_user64 einfo64;\r\nif (copy_from_user(&einfo64, argp,\r\nsizeof(struct erase_info_user64))) {\r\nkfree(erase);\r\nreturn -EFAULT;\r\n}\r\nerase->addr = einfo64.start;\r\nerase->len = einfo64.length;\r\n} else {\r\nstruct erase_info_user einfo32;\r\nif (copy_from_user(&einfo32, argp,\r\nsizeof(struct erase_info_user))) {\r\nkfree(erase);\r\nreturn -EFAULT;\r\n}\r\nerase->addr = einfo32.start;\r\nerase->len = einfo32.length;\r\n}\r\nerase->mtd = mtd;\r\nerase->callback = mtdchar_erase_callback;\r\nerase->priv = (unsigned long)&waitq;\r\nret = mtd_erase(mtd, erase);\r\nif (!ret) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&waitq, &wait);\r\nif (erase->state != MTD_ERASE_DONE &&\r\nerase->state != MTD_ERASE_FAILED)\r\nschedule();\r\nremove_wait_queue(&waitq, &wait);\r\nset_current_state(TASK_RUNNING);\r\nret = (erase->state == MTD_ERASE_FAILED)?-EIO:0;\r\n}\r\nkfree(erase);\r\n}\r\nbreak;\r\n}\r\ncase MEMWRITEOOB:\r\n{\r\nstruct mtd_oob_buf buf;\r\nstruct mtd_oob_buf __user *buf_user = argp;\r\nif (copy_from_user(&buf, argp, sizeof(buf)))\r\nret = -EFAULT;\r\nelse\r\nret = mtdchar_writeoob(file, mtd, buf.start, buf.length,\r\nbuf.ptr, &buf_user->length);\r\nbreak;\r\n}\r\ncase MEMREADOOB:\r\n{\r\nstruct mtd_oob_buf buf;\r\nstruct mtd_oob_buf __user *buf_user = argp;\r\nif (copy_from_user(&buf, argp, sizeof(buf)))\r\nret = -EFAULT;\r\nelse\r\nret = mtdchar_readoob(file, mtd, buf.start, buf.length,\r\nbuf.ptr, &buf_user->start);\r\nbreak;\r\n}\r\ncase MEMWRITEOOB64:\r\n{\r\nstruct mtd_oob_buf64 buf;\r\nstruct mtd_oob_buf64 __user *buf_user = argp;\r\nif (copy_from_user(&buf, argp, sizeof(buf)))\r\nret = -EFAULT;\r\nelse\r\nret = mtdchar_writeoob(file, mtd, buf.start, buf.length,\r\n(void __user *)(uintptr_t)buf.usr_ptr,\r\n&buf_user->length);\r\nbreak;\r\n}\r\ncase MEMREADOOB64:\r\n{\r\nstruct mtd_oob_buf64 buf;\r\nstruct mtd_oob_buf64 __user *buf_user = argp;\r\nif (copy_from_user(&buf, argp, sizeof(buf)))\r\nret = -EFAULT;\r\nelse\r\nret = mtdchar_readoob(file, mtd, buf.start, buf.length,\r\n(void __user *)(uintptr_t)buf.usr_ptr,\r\n&buf_user->length);\r\nbreak;\r\n}\r\ncase MEMWRITE:\r\n{\r\nret = mtdchar_write_ioctl(mtd,\r\n(struct mtd_write_req __user *)arg);\r\nbreak;\r\n}\r\ncase MEMLOCK:\r\n{\r\nstruct erase_info_user einfo;\r\nif (copy_from_user(&einfo, argp, sizeof(einfo)))\r\nreturn -EFAULT;\r\nret = mtd_lock(mtd, einfo.start, einfo.length);\r\nbreak;\r\n}\r\ncase MEMUNLOCK:\r\n{\r\nstruct erase_info_user einfo;\r\nif (copy_from_user(&einfo, argp, sizeof(einfo)))\r\nreturn -EFAULT;\r\nret = mtd_unlock(mtd, einfo.start, einfo.length);\r\nbreak;\r\n}\r\ncase MEMISLOCKED:\r\n{\r\nstruct erase_info_user einfo;\r\nif (copy_from_user(&einfo, argp, sizeof(einfo)))\r\nreturn -EFAULT;\r\nret = mtd_is_locked(mtd, einfo.start, einfo.length);\r\nbreak;\r\n}\r\ncase MEMGETOOBSEL:\r\n{\r\nstruct nand_oobinfo oi;\r\nif (!mtd->ecclayout)\r\nreturn -EOPNOTSUPP;\r\nif (mtd->ecclayout->eccbytes > ARRAY_SIZE(oi.eccpos))\r\nreturn -EINVAL;\r\noi.useecc = MTD_NANDECC_AUTOPLACE;\r\nmemcpy(&oi.eccpos, mtd->ecclayout->eccpos, sizeof(oi.eccpos));\r\nmemcpy(&oi.oobfree, mtd->ecclayout->oobfree,\r\nsizeof(oi.oobfree));\r\noi.eccbytes = mtd->ecclayout->eccbytes;\r\nif (copy_to_user(argp, &oi, sizeof(struct nand_oobinfo)))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase MEMGETBADBLOCK:\r\n{\r\nloff_t offs;\r\nif (copy_from_user(&offs, argp, sizeof(loff_t)))\r\nreturn -EFAULT;\r\nreturn mtd_block_isbad(mtd, offs);\r\nbreak;\r\n}\r\ncase MEMSETBADBLOCK:\r\n{\r\nloff_t offs;\r\nif (copy_from_user(&offs, argp, sizeof(loff_t)))\r\nreturn -EFAULT;\r\nreturn mtd_block_markbad(mtd, offs);\r\nbreak;\r\n}\r\ncase OTPSELECT:\r\n{\r\nint mode;\r\nif (copy_from_user(&mode, argp, sizeof(int)))\r\nreturn -EFAULT;\r\nmfi->mode = MTD_FILE_MODE_NORMAL;\r\nret = otp_select_filemode(mfi, mode);\r\nfile->f_pos = 0;\r\nbreak;\r\n}\r\ncase OTPGETREGIONCOUNT:\r\ncase OTPGETREGIONINFO:\r\n{\r\nstruct otp_info *buf = kmalloc(4096, GFP_KERNEL);\r\nsize_t retlen;\r\nif (!buf)\r\nreturn -ENOMEM;\r\nswitch (mfi->mode) {\r\ncase MTD_FILE_MODE_OTP_FACTORY:\r\nret = mtd_get_fact_prot_info(mtd, 4096, &retlen, buf);\r\nbreak;\r\ncase MTD_FILE_MODE_OTP_USER:\r\nret = mtd_get_user_prot_info(mtd, 4096, &retlen, buf);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (!ret) {\r\nif (cmd == OTPGETREGIONCOUNT) {\r\nint nbr = retlen / sizeof(struct otp_info);\r\nret = copy_to_user(argp, &nbr, sizeof(int));\r\n} else\r\nret = copy_to_user(argp, buf, retlen);\r\nif (ret)\r\nret = -EFAULT;\r\n}\r\nkfree(buf);\r\nbreak;\r\n}\r\ncase OTPLOCK:\r\n{\r\nstruct otp_info oinfo;\r\nif (mfi->mode != MTD_FILE_MODE_OTP_USER)\r\nreturn -EINVAL;\r\nif (copy_from_user(&oinfo, argp, sizeof(oinfo)))\r\nreturn -EFAULT;\r\nret = mtd_lock_user_prot_reg(mtd, oinfo.start, oinfo.length);\r\nbreak;\r\n}\r\ncase ECCGETLAYOUT:\r\n{\r\nstruct nand_ecclayout_user *usrlay;\r\nif (!mtd->ecclayout)\r\nreturn -EOPNOTSUPP;\r\nusrlay = kmalloc(sizeof(*usrlay), GFP_KERNEL);\r\nif (!usrlay)\r\nreturn -ENOMEM;\r\nshrink_ecclayout(mtd->ecclayout, usrlay);\r\nif (copy_to_user(argp, usrlay, sizeof(*usrlay)))\r\nret = -EFAULT;\r\nkfree(usrlay);\r\nbreak;\r\n}\r\ncase ECCGETSTATS:\r\n{\r\nif (copy_to_user(argp, &mtd->ecc_stats,\r\nsizeof(struct mtd_ecc_stats)))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase MTDFILEMODE:\r\n{\r\nmfi->mode = 0;\r\nswitch(arg) {\r\ncase MTD_FILE_MODE_OTP_FACTORY:\r\ncase MTD_FILE_MODE_OTP_USER:\r\nret = otp_select_filemode(mfi, arg);\r\nbreak;\r\ncase MTD_FILE_MODE_RAW:\r\nif (!mtd_has_oob(mtd))\r\nreturn -EOPNOTSUPP;\r\nmfi->mode = arg;\r\ncase MTD_FILE_MODE_NORMAL:\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nfile->f_pos = 0;\r\nbreak;\r\n}\r\ncase BLKPG:\r\n{\r\nret = mtdchar_blkpg_ioctl(mtd,\r\n(struct blkpg_ioctl_arg __user *)arg);\r\nbreak;\r\n}\r\ncase BLKRRPART:\r\n{\r\nret = 0;\r\nbreak;\r\n}\r\ndefault:\r\nret = -ENOTTY;\r\n}\r\nreturn ret;\r\n}\r\nstatic long mtdchar_unlocked_ioctl(struct file *file, u_int cmd, u_long arg)\r\n{\r\nint ret;\r\nmutex_lock(&mtd_mutex);\r\nret = mtdchar_ioctl(file, cmd, arg);\r\nmutex_unlock(&mtd_mutex);\r\nreturn ret;\r\n}\r\nstatic long mtdchar_compat_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct mtd_file_info *mfi = file->private_data;\r\nstruct mtd_info *mtd = mfi->mtd;\r\nvoid __user *argp = compat_ptr(arg);\r\nint ret = 0;\r\nmutex_lock(&mtd_mutex);\r\nswitch (cmd) {\r\ncase MEMWRITEOOB32:\r\n{\r\nstruct mtd_oob_buf32 buf;\r\nstruct mtd_oob_buf32 __user *buf_user = argp;\r\nif (copy_from_user(&buf, argp, sizeof(buf)))\r\nret = -EFAULT;\r\nelse\r\nret = mtdchar_writeoob(file, mtd, buf.start,\r\nbuf.length, compat_ptr(buf.ptr),\r\n&buf_user->length);\r\nbreak;\r\n}\r\ncase MEMREADOOB32:\r\n{\r\nstruct mtd_oob_buf32 buf;\r\nstruct mtd_oob_buf32 __user *buf_user = argp;\r\nif (copy_from_user(&buf, argp, sizeof(buf)))\r\nret = -EFAULT;\r\nelse\r\nret = mtdchar_readoob(file, mtd, buf.start,\r\nbuf.length, compat_ptr(buf.ptr),\r\n&buf_user->start);\r\nbreak;\r\n}\r\ndefault:\r\nret = mtdchar_ioctl(file, cmd, (unsigned long)argp);\r\n}\r\nmutex_unlock(&mtd_mutex);\r\nreturn ret;\r\n}\r\nstatic unsigned long mtdchar_get_unmapped_area(struct file *file,\r\nunsigned long addr,\r\nunsigned long len,\r\nunsigned long pgoff,\r\nunsigned long flags)\r\n{\r\nstruct mtd_file_info *mfi = file->private_data;\r\nstruct mtd_info *mtd = mfi->mtd;\r\nunsigned long offset;\r\nint ret;\r\nif (addr != 0)\r\nreturn (unsigned long) -EINVAL;\r\nif (len > mtd->size || pgoff >= (mtd->size >> PAGE_SHIFT))\r\nreturn (unsigned long) -EINVAL;\r\noffset = pgoff << PAGE_SHIFT;\r\nif (offset > mtd->size - len)\r\nreturn (unsigned long) -EINVAL;\r\nret = mtd_get_unmapped_area(mtd, len, offset, flags);\r\nreturn ret == -EOPNOTSUPP ? -ENODEV : ret;\r\n}\r\nstatic int mtdchar_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\n#ifdef CONFIG_MMU\r\nstruct mtd_file_info *mfi = file->private_data;\r\nstruct mtd_info *mtd = mfi->mtd;\r\nstruct map_info *map = mtd->priv;\r\nif (0 ) {\r\n#ifdef pgprot_noncached\r\nif (file->f_flags & O_DSYNC || map->phys >= __pa(high_memory))\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\n#endif\r\nreturn vm_iomap_memory(vma, map->phys, map->size);\r\n}\r\nreturn -ENODEV;\r\n#else\r\nreturn vma->vm_flags & VM_SHARED ? 0 : -EACCES;\r\n#endif\r\n}\r\nstatic struct dentry *mtd_inodefs_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name, void *data)\r\n{\r\nreturn mount_pseudo(fs_type, "mtd_inode:", &mtd_ops, NULL, MTD_INODE_FS_MAGIC);\r\n}\r\nint __init init_mtdchar(void)\r\n{\r\nint ret;\r\nret = __register_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS,\r\n"mtd", &mtd_fops);\r\nif (ret < 0) {\r\npr_err("Can't allocate major number %d for MTD\n",\r\nMTD_CHAR_MAJOR);\r\nreturn ret;\r\n}\r\nret = register_filesystem(&mtd_inodefs_type);\r\nif (ret) {\r\npr_err("Can't register mtd_inodefs filesystem, error %d\n",\r\nret);\r\ngoto err_unregister_chdev;\r\n}\r\nreturn ret;\r\nerr_unregister_chdev:\r\n__unregister_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS, "mtd");\r\nreturn ret;\r\n}\r\nvoid __exit cleanup_mtdchar(void)\r\n{\r\nunregister_filesystem(&mtd_inodefs_type);\r\n__unregister_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS, "mtd");\r\n}
