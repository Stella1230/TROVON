static int __init evm_set_fixmode(char *str)\r\n{\r\nif (strncmp(str, "fix", 3) == 0)\r\nevm_fixmode = 1;\r\nreturn 0;\r\n}\r\nstatic void __init evm_init_config(void)\r\n{\r\n#ifdef CONFIG_EVM_ATTR_FSUUID\r\nevm_hmac_attrs |= EVM_ATTR_FSUUID;\r\n#endif\r\npr_info("HMAC attrs: 0x%x\n", evm_hmac_attrs);\r\n}\r\nstatic int evm_find_protected_xattrs(struct dentry *dentry)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nchar **xattr;\r\nint error;\r\nint count = 0;\r\nif (!inode->i_op->getxattr)\r\nreturn -EOPNOTSUPP;\r\nfor (xattr = evm_config_xattrnames; *xattr != NULL; xattr++) {\r\nerror = inode->i_op->getxattr(dentry, *xattr, NULL, 0);\r\nif (error < 0) {\r\nif (error == -ENODATA)\r\ncontinue;\r\nreturn error;\r\n}\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic enum integrity_status evm_verify_hmac(struct dentry *dentry,\r\nconst char *xattr_name,\r\nchar *xattr_value,\r\nsize_t xattr_value_len,\r\nstruct integrity_iint_cache *iint)\r\n{\r\nstruct evm_ima_xattr_data *xattr_data = NULL;\r\nstruct evm_ima_xattr_data calc;\r\nenum integrity_status evm_status = INTEGRITY_PASS;\r\nint rc, xattr_len;\r\nif (iint && iint->evm_status == INTEGRITY_PASS)\r\nreturn iint->evm_status;\r\nrc = vfs_getxattr_alloc(dentry, XATTR_NAME_EVM, (char **)&xattr_data, 0,\r\nGFP_NOFS);\r\nif (rc <= 0) {\r\nif (rc == 0)\r\nevm_status = INTEGRITY_FAIL;\r\nelse if (rc == -ENODATA) {\r\nrc = evm_find_protected_xattrs(dentry);\r\nif (rc > 0)\r\nevm_status = INTEGRITY_NOLABEL;\r\nelse if (rc == 0)\r\nevm_status = INTEGRITY_NOXATTRS;\r\n}\r\ngoto out;\r\n}\r\nxattr_len = rc;\r\nswitch (xattr_data->type) {\r\ncase EVM_XATTR_HMAC:\r\nrc = evm_calc_hmac(dentry, xattr_name, xattr_value,\r\nxattr_value_len, calc.digest);\r\nif (rc)\r\nbreak;\r\nrc = memcmp(xattr_data->digest, calc.digest,\r\nsizeof(calc.digest));\r\nif (rc)\r\nrc = -EINVAL;\r\nbreak;\r\ncase EVM_IMA_XATTR_DIGSIG:\r\nrc = evm_calc_hash(dentry, xattr_name, xattr_value,\r\nxattr_value_len, calc.digest);\r\nif (rc)\r\nbreak;\r\nrc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,\r\n(const char *)xattr_data, xattr_len,\r\ncalc.digest, sizeof(calc.digest));\r\nif (!rc) {\r\nevm_update_evmxattr(dentry, xattr_name, xattr_value,\r\nxattr_value_len);\r\n}\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nif (rc)\r\nevm_status = (rc == -ENODATA) ?\r\nINTEGRITY_NOXATTRS : INTEGRITY_FAIL;\r\nout:\r\nif (iint)\r\niint->evm_status = evm_status;\r\nkfree(xattr_data);\r\nreturn evm_status;\r\n}\r\nstatic int evm_protected_xattr(const char *req_xattr_name)\r\n{\r\nchar **xattrname;\r\nint namelen;\r\nint found = 0;\r\nnamelen = strlen(req_xattr_name);\r\nfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\r\nif ((strlen(*xattrname) == namelen)\r\n&& (strncmp(req_xattr_name, *xattrname, namelen) == 0)) {\r\nfound = 1;\r\nbreak;\r\n}\r\nif (strncmp(req_xattr_name,\r\n*xattrname + XATTR_SECURITY_PREFIX_LEN,\r\nstrlen(req_xattr_name)) == 0) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nreturn found;\r\n}\r\nenum integrity_status evm_verifyxattr(struct dentry *dentry,\r\nconst char *xattr_name,\r\nvoid *xattr_value, size_t xattr_value_len,\r\nstruct integrity_iint_cache *iint)\r\n{\r\nif (!evm_initialized || !evm_protected_xattr(xattr_name))\r\nreturn INTEGRITY_UNKNOWN;\r\nif (!iint) {\r\niint = integrity_iint_find(dentry->d_inode);\r\nif (!iint)\r\nreturn INTEGRITY_UNKNOWN;\r\n}\r\nreturn evm_verify_hmac(dentry, xattr_name, xattr_value,\r\nxattr_value_len, iint);\r\n}\r\nstatic enum integrity_status evm_verify_current_integrity(struct dentry *dentry)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nif (!evm_initialized || !S_ISREG(inode->i_mode) || evm_fixmode)\r\nreturn 0;\r\nreturn evm_verify_hmac(dentry, NULL, NULL, 0, NULL);\r\n}\r\nstatic int evm_protect_xattr(struct dentry *dentry, const char *xattr_name,\r\nconst void *xattr_value, size_t xattr_value_len)\r\n{\r\nenum integrity_status evm_status;\r\nif (strcmp(xattr_name, XATTR_NAME_EVM) == 0) {\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\n} else if (!evm_protected_xattr(xattr_name)) {\r\nif (!posix_xattr_acl(xattr_name))\r\nreturn 0;\r\nevm_status = evm_verify_current_integrity(dentry);\r\nif ((evm_status == INTEGRITY_PASS) ||\r\n(evm_status == INTEGRITY_NOXATTRS))\r\nreturn 0;\r\ngoto out;\r\n}\r\nevm_status = evm_verify_current_integrity(dentry);\r\nout:\r\nif (evm_status != INTEGRITY_PASS)\r\nintegrity_audit_msg(AUDIT_INTEGRITY_METADATA, dentry->d_inode,\r\ndentry->d_name.name, "appraise_metadata",\r\nintegrity_status_msg[evm_status],\r\n-EPERM, 0);\r\nreturn evm_status == INTEGRITY_PASS ? 0 : -EPERM;\r\n}\r\nint evm_inode_setxattr(struct dentry *dentry, const char *xattr_name,\r\nconst void *xattr_value, size_t xattr_value_len)\r\n{\r\nconst struct evm_ima_xattr_data *xattr_data = xattr_value;\r\nif ((strcmp(xattr_name, XATTR_NAME_EVM) == 0)\r\n&& (xattr_data->type == EVM_XATTR_HMAC))\r\nreturn -EPERM;\r\nreturn evm_protect_xattr(dentry, xattr_name, xattr_value,\r\nxattr_value_len);\r\n}\r\nint evm_inode_removexattr(struct dentry *dentry, const char *xattr_name)\r\n{\r\nreturn evm_protect_xattr(dentry, xattr_name, NULL, 0);\r\n}\r\nvoid evm_inode_post_setxattr(struct dentry *dentry, const char *xattr_name,\r\nconst void *xattr_value, size_t xattr_value_len)\r\n{\r\nif (!evm_initialized || (!evm_protected_xattr(xattr_name)\r\n&& !posix_xattr_acl(xattr_name)))\r\nreturn;\r\nevm_update_evmxattr(dentry, xattr_name, xattr_value, xattr_value_len);\r\nreturn;\r\n}\r\nvoid evm_inode_post_removexattr(struct dentry *dentry, const char *xattr_name)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nif (!evm_initialized || !evm_protected_xattr(xattr_name))\r\nreturn;\r\nmutex_lock(&inode->i_mutex);\r\nevm_update_evmxattr(dentry, xattr_name, NULL, 0);\r\nmutex_unlock(&inode->i_mutex);\r\nreturn;\r\n}\r\nint evm_inode_setattr(struct dentry *dentry, struct iattr *attr)\r\n{\r\nunsigned int ia_valid = attr->ia_valid;\r\nenum integrity_status evm_status;\r\nif (!(ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID)))\r\nreturn 0;\r\nevm_status = evm_verify_current_integrity(dentry);\r\nif ((evm_status == INTEGRITY_PASS) ||\r\n(evm_status == INTEGRITY_NOXATTRS))\r\nreturn 0;\r\nintegrity_audit_msg(AUDIT_INTEGRITY_METADATA, dentry->d_inode,\r\ndentry->d_name.name, "appraise_metadata",\r\nintegrity_status_msg[evm_status], -EPERM, 0);\r\nreturn -EPERM;\r\n}\r\nvoid evm_inode_post_setattr(struct dentry *dentry, int ia_valid)\r\n{\r\nif (!evm_initialized)\r\nreturn;\r\nif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID))\r\nevm_update_evmxattr(dentry, NULL, NULL, 0);\r\nreturn;\r\n}\r\nint evm_inode_init_security(struct inode *inode,\r\nconst struct xattr *lsm_xattr,\r\nstruct xattr *evm_xattr)\r\n{\r\nstruct evm_ima_xattr_data *xattr_data;\r\nint rc;\r\nif (!evm_initialized || !evm_protected_xattr(lsm_xattr->name))\r\nreturn 0;\r\nxattr_data = kzalloc(sizeof(*xattr_data), GFP_NOFS);\r\nif (!xattr_data)\r\nreturn -ENOMEM;\r\nxattr_data->type = EVM_XATTR_HMAC;\r\nrc = evm_init_hmac(inode, lsm_xattr, xattr_data->digest);\r\nif (rc < 0)\r\ngoto out;\r\nevm_xattr->value = xattr_data;\r\nevm_xattr->value_len = sizeof(*xattr_data);\r\nevm_xattr->name = XATTR_EVM_SUFFIX;\r\nreturn 0;\r\nout:\r\nkfree(xattr_data);\r\nreturn rc;\r\n}\r\nstatic int __init init_evm(void)\r\n{\r\nint error;\r\nevm_init_config();\r\nerror = evm_init_secfs();\r\nif (error < 0) {\r\npr_info("Error registering secfs\n");\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nreturn error;\r\n}\r\nstatic int __init evm_display_config(void)\r\n{\r\nchar **xattrname;\r\nfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++)\r\npr_info("%s\n", *xattrname);\r\nreturn 0;\r\n}
