static void read_int_callback(struct urb *urb)\r\n{\r\nint status = urb->status;\r\nstruct bcm_interface_adapter *psIntfAdapter =\r\n(struct bcm_interface_adapter *)urb->context;\r\nstruct bcm_mini_adapter *Adapter = psIntfAdapter->psAdapter;\r\nif (netif_msg_intr(Adapter))\r\npr_info(PFX "%s: interrupt status %d\n",\r\nAdapter->dev->name, status);\r\nif (Adapter->device_removed) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, INTF_INIT,\r\nDBG_LVL_ALL, "Device has Got Removed.");\r\nreturn;\r\n}\r\nif ((Adapter->bPreparingForLowPowerMode && Adapter->bDoSuspend) ||\r\npsIntfAdapter->bSuspended ||\r\npsIntfAdapter->bPreparingForBusSuspend) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, INTF_INIT,\r\nDBG_LVL_ALL,\r\n"Interrupt call back is called while suspending the device");\r\nreturn;\r\n}\r\nswitch (status) {\r\ncase STATUS_SUCCESS:\r\nif (urb->actual_length) {\r\nif (psIntfAdapter->ulInterruptData[1] & 0xFF) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS,\r\nINTF_INIT, DBG_LVL_ALL,\r\n"Got USIM interrupt");\r\n}\r\nif (psIntfAdapter->ulInterruptData[1] & 0xFF00) {\r\natomic_set(&Adapter->CurrNumFreeTxDesc,\r\n(psIntfAdapter->ulInterruptData[1] &\r\n0xFF00) >> 8);\r\natomic_set(&Adapter->uiMBupdate, TRUE);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS,\r\nINTF_INIT, DBG_LVL_ALL,\r\n"TX mailbox contains %d",\r\natomic_read(&Adapter->CurrNumFreeTxDesc));\r\n}\r\nif (psIntfAdapter->ulInterruptData[1] >> 16) {\r\nAdapter->CurrNumRecvDescs =\r\n(psIntfAdapter->ulInterruptData[1] >> 16);\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS,\r\nINTF_INIT, DBG_LVL_ALL,\r\n"RX mailbox contains %d",\r\nAdapter->CurrNumRecvDescs);\r\nInterfaceRx(psIntfAdapter);\r\n}\r\nif (Adapter->fw_download_done &&\r\n!Adapter->downloadDDR &&\r\natomic_read(&Adapter->CurrNumFreeTxDesc)) {\r\npsIntfAdapter->psAdapter->downloadDDR += 1;\r\nwake_up(&Adapter->tx_packet_wait_queue);\r\n}\r\nif (!Adapter->waiting_to_fw_download_done) {\r\nAdapter->waiting_to_fw_download_done = TRUE;\r\nwake_up(&Adapter->ioctl_fw_dnld_wait_queue);\r\n}\r\nif (!atomic_read(&Adapter->TxPktAvail)) {\r\natomic_set(&Adapter->TxPktAvail, 1);\r\nwake_up(&Adapter->tx_packet_wait_queue);\r\n}\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, INTF_INIT,\r\nDBG_LVL_ALL, "Firing interrupt in URB");\r\n}\r\nbreak;\r\ncase -ENOENT:\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, INTF_INIT,\r\nDBG_LVL_ALL, "URB has got disconnected....");\r\nreturn;\r\ncase -EINPROGRESS:\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, INTF_INIT,\r\nDBG_LVL_ALL,\r\n"Impossibe condition has occurred... something very bad is going on");\r\nbreak;\r\ncase -EPIPE:\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, INTF_INIT,\r\nDBG_LVL_ALL,\r\n"Interrupt IN endPoint has got halted/stalled...need to clear this");\r\nAdapter->bEndPointHalted = TRUE;\r\nwake_up(&Adapter->tx_packet_wait_queue);\r\nurb->status = STATUS_SUCCESS;\r\nreturn;\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\ncase -ENODEV:\r\ncase -EINVAL:\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, INTF_INIT,\r\nDBG_LVL_ALL, "interrupt urb error %d", status);\r\nurb->status = STATUS_SUCCESS;\r\nbreak;\r\ndefault:\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_TX, NEXT_SEND, DBG_LVL_ALL,\r\n"GOT DEFAULT INTERRUPT URB STATUS :%d..Please Analyze it...",\r\nstatus);\r\nbreak;\r\n}\r\nStartInterruptUrb(psIntfAdapter);\r\n}\r\nint CreateInterruptUrb(struct bcm_interface_adapter *psIntfAdapter)\r\n{\r\npsIntfAdapter->psInterruptUrb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!psIntfAdapter->psInterruptUrb) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_OTHERS,\r\nINTF_INIT, DBG_LVL_ALL,\r\n"Cannot allocate interrupt urb");\r\nreturn -ENOMEM;\r\n}\r\npsIntfAdapter->psInterruptUrb->transfer_buffer =\r\npsIntfAdapter->ulInterruptData;\r\npsIntfAdapter->psInterruptUrb->transfer_buffer_length =\r\nsizeof(psIntfAdapter->ulInterruptData);\r\npsIntfAdapter->sIntrIn.int_in_pipe = usb_rcvintpipe(psIntfAdapter->udev,\r\npsIntfAdapter->sIntrIn.int_in_endpointAddr);\r\nusb_fill_int_urb(psIntfAdapter->psInterruptUrb, psIntfAdapter->udev,\r\npsIntfAdapter->sIntrIn.int_in_pipe,\r\npsIntfAdapter->psInterruptUrb->transfer_buffer,\r\npsIntfAdapter->psInterruptUrb->transfer_buffer_length,\r\nread_int_callback, psIntfAdapter,\r\npsIntfAdapter->sIntrIn.int_in_interval);\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter, DBG_TYPE_OTHERS, INTF_INIT,\r\nDBG_LVL_ALL, "Interrupt Interval: %d\n",\r\npsIntfAdapter->sIntrIn.int_in_interval);\r\nreturn 0;\r\n}\r\nINT StartInterruptUrb(struct bcm_interface_adapter *psIntfAdapter)\r\n{\r\nINT status = 0;\r\nif (!(psIntfAdapter->psAdapter->device_removed ||\r\npsIntfAdapter->psAdapter->bEndPointHalted ||\r\npsIntfAdapter->bSuspended ||\r\npsIntfAdapter->bPreparingForBusSuspend ||\r\npsIntfAdapter->psAdapter->StopAllXaction)) {\r\nstatus =\r\nusb_submit_urb(psIntfAdapter->psInterruptUrb, GFP_ATOMIC);\r\nif (status) {\r\nBCM_DEBUG_PRINT(psIntfAdapter->psAdapter,\r\nDBG_TYPE_OTHERS, INTF_INIT, DBG_LVL_ALL,\r\n"Cannot send inturb %d\n", status);\r\nif (status == -EPIPE) {\r\npsIntfAdapter->psAdapter->bEndPointHalted =\r\nTRUE;\r\nwake_up(&psIntfAdapter->psAdapter->tx_packet_wait_queue);\r\n}\r\n}\r\n}\r\nreturn status;\r\n}
