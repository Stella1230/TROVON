static void ttm_eu_backoff_reservation_locked(struct list_head *list)\r\n{\r\nstruct ttm_validate_buffer *entry;\r\nlist_for_each_entry(entry, list, head) {\r\nstruct ttm_buffer_object *bo = entry->bo;\r\nif (!entry->reserved)\r\ncontinue;\r\nentry->reserved = false;\r\nif (entry->removed) {\r\nttm_bo_add_to_lru(bo);\r\nentry->removed = false;\r\n}\r\n__ttm_bo_unreserve(bo);\r\n}\r\n}\r\nstatic void ttm_eu_del_from_lru_locked(struct list_head *list)\r\n{\r\nstruct ttm_validate_buffer *entry;\r\nlist_for_each_entry(entry, list, head) {\r\nstruct ttm_buffer_object *bo = entry->bo;\r\nif (!entry->reserved)\r\ncontinue;\r\nif (!entry->removed) {\r\nentry->put_count = ttm_bo_del_from_lru(bo);\r\nentry->removed = true;\r\n}\r\n}\r\n}\r\nstatic void ttm_eu_list_ref_sub(struct list_head *list)\r\n{\r\nstruct ttm_validate_buffer *entry;\r\nlist_for_each_entry(entry, list, head) {\r\nstruct ttm_buffer_object *bo = entry->bo;\r\nif (entry->put_count) {\r\nttm_bo_list_ref_sub(bo, entry->put_count, true);\r\nentry->put_count = 0;\r\n}\r\n}\r\n}\r\nvoid ttm_eu_backoff_reservation(struct ww_acquire_ctx *ticket,\r\nstruct list_head *list)\r\n{\r\nstruct ttm_validate_buffer *entry;\r\nstruct ttm_bo_global *glob;\r\nif (list_empty(list))\r\nreturn;\r\nentry = list_first_entry(list, struct ttm_validate_buffer, head);\r\nglob = entry->bo->glob;\r\nspin_lock(&glob->lru_lock);\r\nttm_eu_backoff_reservation_locked(list);\r\nif (ticket)\r\nww_acquire_fini(ticket);\r\nspin_unlock(&glob->lru_lock);\r\n}\r\nint ttm_eu_reserve_buffers(struct ww_acquire_ctx *ticket,\r\nstruct list_head *list)\r\n{\r\nstruct ttm_bo_global *glob;\r\nstruct ttm_validate_buffer *entry;\r\nint ret;\r\nif (list_empty(list))\r\nreturn 0;\r\nlist_for_each_entry(entry, list, head) {\r\nentry->reserved = false;\r\nentry->put_count = 0;\r\nentry->removed = false;\r\n}\r\nentry = list_first_entry(list, struct ttm_validate_buffer, head);\r\nglob = entry->bo->glob;\r\nif (ticket)\r\nww_acquire_init(ticket, &reservation_ww_class);\r\nretry:\r\nlist_for_each_entry(entry, list, head) {\r\nstruct ttm_buffer_object *bo = entry->bo;\r\nif (entry->reserved)\r\ncontinue;\r\nret = __ttm_bo_reserve(bo, true, (ticket == NULL), true,\r\nticket);\r\nif (ret == -EDEADLK) {\r\nBUG_ON(ticket == NULL);\r\nspin_lock(&glob->lru_lock);\r\nttm_eu_backoff_reservation_locked(list);\r\nspin_unlock(&glob->lru_lock);\r\nttm_eu_list_ref_sub(list);\r\nret = ww_mutex_lock_slow_interruptible(&bo->resv->lock,\r\nticket);\r\nif (unlikely(ret != 0)) {\r\nif (ret == -EINTR)\r\nret = -ERESTARTSYS;\r\ngoto err_fini;\r\n}\r\nentry->reserved = true;\r\nif (unlikely(atomic_read(&bo->cpu_writers) > 0)) {\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\ngoto retry;\r\n} else if (ret)\r\ngoto err;\r\nentry->reserved = true;\r\nif (unlikely(atomic_read(&bo->cpu_writers) > 0)) {\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\n}\r\nif (ticket)\r\nww_acquire_done(ticket);\r\nspin_lock(&glob->lru_lock);\r\nttm_eu_del_from_lru_locked(list);\r\nspin_unlock(&glob->lru_lock);\r\nttm_eu_list_ref_sub(list);\r\nreturn 0;\r\nerr:\r\nspin_lock(&glob->lru_lock);\r\nttm_eu_backoff_reservation_locked(list);\r\nspin_unlock(&glob->lru_lock);\r\nttm_eu_list_ref_sub(list);\r\nerr_fini:\r\nif (ticket) {\r\nww_acquire_done(ticket);\r\nww_acquire_fini(ticket);\r\n}\r\nreturn ret;\r\n}\r\nvoid ttm_eu_fence_buffer_objects(struct ww_acquire_ctx *ticket,\r\nstruct list_head *list, void *sync_obj)\r\n{\r\nstruct ttm_validate_buffer *entry;\r\nstruct ttm_buffer_object *bo;\r\nstruct ttm_bo_global *glob;\r\nstruct ttm_bo_device *bdev;\r\nstruct ttm_bo_driver *driver;\r\nif (list_empty(list))\r\nreturn;\r\nbo = list_first_entry(list, struct ttm_validate_buffer, head)->bo;\r\nbdev = bo->bdev;\r\ndriver = bdev->driver;\r\nglob = bo->glob;\r\nspin_lock(&glob->lru_lock);\r\nspin_lock(&bdev->fence_lock);\r\nlist_for_each_entry(entry, list, head) {\r\nbo = entry->bo;\r\nentry->old_sync_obj = bo->sync_obj;\r\nbo->sync_obj = driver->sync_obj_ref(sync_obj);\r\nttm_bo_add_to_lru(bo);\r\n__ttm_bo_unreserve(bo);\r\nentry->reserved = false;\r\n}\r\nspin_unlock(&bdev->fence_lock);\r\nspin_unlock(&glob->lru_lock);\r\nif (ticket)\r\nww_acquire_fini(ticket);\r\nlist_for_each_entry(entry, list, head) {\r\nif (entry->old_sync_obj)\r\ndriver->sync_obj_unref(&entry->old_sync_obj);\r\n}\r\n}
