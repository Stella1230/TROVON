static inline int is_vybrid_qspi(struct fsl_qspi *q)\r\n{\r\nreturn q->devtype_data->devtype == FSL_QUADSPI_VYBRID;\r\n}\r\nstatic inline int is_imx6sx_qspi(struct fsl_qspi *q)\r\n{\r\nreturn q->devtype_data->devtype == FSL_QUADSPI_IMX6SX;\r\n}\r\nstatic inline u32 fsl_qspi_endian_xchg(struct fsl_qspi *q, u32 a)\r\n{\r\nreturn is_vybrid_qspi(q) ? __swab32(a) : a;\r\n}\r\nstatic inline void fsl_qspi_unlock_lut(struct fsl_qspi *q)\r\n{\r\nwritel(QUADSPI_LUTKEY_VALUE, q->iobase + QUADSPI_LUTKEY);\r\nwritel(QUADSPI_LCKER_UNLOCK, q->iobase + QUADSPI_LCKCR);\r\n}\r\nstatic inline void fsl_qspi_lock_lut(struct fsl_qspi *q)\r\n{\r\nwritel(QUADSPI_LUTKEY_VALUE, q->iobase + QUADSPI_LUTKEY);\r\nwritel(QUADSPI_LCKER_LOCK, q->iobase + QUADSPI_LCKCR);\r\n}\r\nstatic irqreturn_t fsl_qspi_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct fsl_qspi *q = dev_id;\r\nu32 reg;\r\nreg = readl(q->iobase + QUADSPI_FR);\r\nwritel(reg, q->iobase + QUADSPI_FR);\r\nif (reg & QUADSPI_FR_TFF_MASK)\r\ncomplete(&q->c);\r\ndev_dbg(q->dev, "QUADSPI_FR : 0x%.8x:0x%.8x\n", q->chip_base_addr, reg);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void fsl_qspi_init_lut(struct fsl_qspi *q)\r\n{\r\nvoid __iomem *base = q->iobase;\r\nint rxfifo = q->devtype_data->rxfifo;\r\nu32 lut_base;\r\nu8 cmd, addrlen, dummy;\r\nint i;\r\nfsl_qspi_unlock_lut(q);\r\nfor (i = 0; i < QUADSPI_LUT_NUM; i++)\r\nwritel(0, base + QUADSPI_LUT_BASE + i * 4);\r\nlut_base = SEQID_QUAD_READ * 4;\r\nif (q->nor_size <= SZ_16M) {\r\ncmd = SPINOR_OP_READ_1_1_4;\r\naddrlen = ADDR24BIT;\r\ndummy = 8;\r\n} else {\r\ncmd = SPINOR_OP_READ_1_1_4;\r\naddrlen = ADDR32BIT;\r\ndummy = 8;\r\n}\r\nwritel(LUT0(CMD, PAD1, cmd) | LUT1(ADDR, PAD1, addrlen),\r\nbase + QUADSPI_LUT(lut_base));\r\nwritel(LUT0(DUMMY, PAD1, dummy) | LUT1(READ, PAD4, rxfifo),\r\nbase + QUADSPI_LUT(lut_base + 1));\r\nlut_base = SEQID_WREN * 4;\r\nwritel(LUT0(CMD, PAD1, SPINOR_OP_WREN), base + QUADSPI_LUT(lut_base));\r\nlut_base = SEQID_PP * 4;\r\nif (q->nor_size <= SZ_16M) {\r\ncmd = SPINOR_OP_PP;\r\naddrlen = ADDR24BIT;\r\n} else {\r\ncmd = SPINOR_OP_PP;\r\naddrlen = ADDR32BIT;\r\n}\r\nwritel(LUT0(CMD, PAD1, cmd) | LUT1(ADDR, PAD1, addrlen),\r\nbase + QUADSPI_LUT(lut_base));\r\nwritel(LUT0(WRITE, PAD1, 0), base + QUADSPI_LUT(lut_base + 1));\r\nlut_base = SEQID_RDSR * 4;\r\nwritel(LUT0(CMD, PAD1, SPINOR_OP_RDSR) | LUT1(READ, PAD1, 0x1),\r\nbase + QUADSPI_LUT(lut_base));\r\nlut_base = SEQID_SE * 4;\r\nif (q->nor_size <= SZ_16M) {\r\ncmd = SPINOR_OP_SE;\r\naddrlen = ADDR24BIT;\r\n} else {\r\ncmd = SPINOR_OP_SE;\r\naddrlen = ADDR32BIT;\r\n}\r\nwritel(LUT0(CMD, PAD1, cmd) | LUT1(ADDR, PAD1, addrlen),\r\nbase + QUADSPI_LUT(lut_base));\r\nlut_base = SEQID_CHIP_ERASE * 4;\r\nwritel(LUT0(CMD, PAD1, SPINOR_OP_CHIP_ERASE),\r\nbase + QUADSPI_LUT(lut_base));\r\nlut_base = SEQID_RDID * 4;\r\nwritel(LUT0(CMD, PAD1, SPINOR_OP_RDID) | LUT1(READ, PAD1, 0x8),\r\nbase + QUADSPI_LUT(lut_base));\r\nlut_base = SEQID_WRSR * 4;\r\nwritel(LUT0(CMD, PAD1, SPINOR_OP_WRSR) | LUT1(WRITE, PAD1, 0x2),\r\nbase + QUADSPI_LUT(lut_base));\r\nlut_base = SEQID_RDCR * 4;\r\nwritel(LUT0(CMD, PAD1, SPINOR_OP_RDCR) | LUT1(READ, PAD1, 0x1),\r\nbase + QUADSPI_LUT(lut_base));\r\nlut_base = SEQID_WRDI * 4;\r\nwritel(LUT0(CMD, PAD1, SPINOR_OP_WRDI), base + QUADSPI_LUT(lut_base));\r\nlut_base = SEQID_EN4B * 4;\r\nwritel(LUT0(CMD, PAD1, SPINOR_OP_EN4B), base + QUADSPI_LUT(lut_base));\r\nlut_base = SEQID_BRWR * 4;\r\nwritel(LUT0(CMD, PAD1, SPINOR_OP_BRWR), base + QUADSPI_LUT(lut_base));\r\nfsl_qspi_lock_lut(q);\r\n}\r\nstatic int fsl_qspi_get_seqid(struct fsl_qspi *q, u8 cmd)\r\n{\r\nswitch (cmd) {\r\ncase SPINOR_OP_READ_1_1_4:\r\nreturn SEQID_QUAD_READ;\r\ncase SPINOR_OP_WREN:\r\nreturn SEQID_WREN;\r\ncase SPINOR_OP_WRDI:\r\nreturn SEQID_WRDI;\r\ncase SPINOR_OP_RDSR:\r\nreturn SEQID_RDSR;\r\ncase SPINOR_OP_SE:\r\nreturn SEQID_SE;\r\ncase SPINOR_OP_CHIP_ERASE:\r\nreturn SEQID_CHIP_ERASE;\r\ncase SPINOR_OP_PP:\r\nreturn SEQID_PP;\r\ncase SPINOR_OP_RDID:\r\nreturn SEQID_RDID;\r\ncase SPINOR_OP_WRSR:\r\nreturn SEQID_WRSR;\r\ncase SPINOR_OP_RDCR:\r\nreturn SEQID_RDCR;\r\ncase SPINOR_OP_EN4B:\r\nreturn SEQID_EN4B;\r\ncase SPINOR_OP_BRWR:\r\nreturn SEQID_BRWR;\r\ndefault:\r\ndev_err(q->dev, "Unsupported cmd 0x%.2x\n", cmd);\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nfsl_qspi_runcmd(struct fsl_qspi *q, u8 cmd, unsigned int addr, int len)\r\n{\r\nvoid __iomem *base = q->iobase;\r\nint seqid;\r\nu32 reg, reg2;\r\nint err;\r\ninit_completion(&q->c);\r\ndev_dbg(q->dev, "to 0x%.8x:0x%.8x, len:%d, cmd:%.2x\n",\r\nq->chip_base_addr, addr, len, cmd);\r\nreg = readl(base + QUADSPI_MCR);\r\nwritel(q->memmap_phy + q->chip_base_addr + addr, base + QUADSPI_SFAR);\r\nwritel(QUADSPI_RBCT_WMRK_MASK | QUADSPI_RBCT_RXBRD_USEIPS,\r\nbase + QUADSPI_RBCT);\r\nwritel(reg | QUADSPI_MCR_CLR_RXF_MASK, base + QUADSPI_MCR);\r\ndo {\r\nreg2 = readl(base + QUADSPI_SR);\r\nif (reg2 & (QUADSPI_SR_IP_ACC_MASK | QUADSPI_SR_AHB_ACC_MASK)) {\r\nudelay(1);\r\ndev_dbg(q->dev, "The controller is busy, 0x%x\n", reg2);\r\ncontinue;\r\n}\r\nbreak;\r\n} while (1);\r\nseqid = fsl_qspi_get_seqid(q, cmd);\r\nwritel((seqid << QUADSPI_IPCR_SEQID_SHIFT) | len, base + QUADSPI_IPCR);\r\nerr = wait_for_completion_timeout(&q->c, msecs_to_jiffies(1000));\r\nif (!err) {\r\ndev_err(q->dev,\r\n"cmd 0x%.2x timeout, addr@%.8x, FR:0x%.8x, SR:0x%.8x\n",\r\ncmd, addr, readl(base + QUADSPI_FR),\r\nreadl(base + QUADSPI_SR));\r\nerr = -ETIMEDOUT;\r\n} else {\r\nerr = 0;\r\n}\r\nwritel(reg, base + QUADSPI_MCR);\r\nreturn err;\r\n}\r\nstatic void fsl_qspi_read_data(struct fsl_qspi *q, int len, u8 *rxbuf)\r\n{\r\nu32 tmp;\r\nint i = 0;\r\nwhile (len > 0) {\r\ntmp = readl(q->iobase + QUADSPI_RBDR + i * 4);\r\ntmp = fsl_qspi_endian_xchg(q, tmp);\r\ndev_dbg(q->dev, "chip addr:0x%.8x, rcv:0x%.8x\n",\r\nq->chip_base_addr, tmp);\r\nif (len >= 4) {\r\n*((u32 *)rxbuf) = tmp;\r\nrxbuf += 4;\r\n} else {\r\nmemcpy(rxbuf, &tmp, len);\r\nbreak;\r\n}\r\nlen -= 4;\r\ni++;\r\n}\r\n}\r\nstatic inline void fsl_qspi_invalid(struct fsl_qspi *q)\r\n{\r\nu32 reg;\r\nreg = readl(q->iobase + QUADSPI_MCR);\r\nreg |= QUADSPI_MCR_SWRSTHD_MASK | QUADSPI_MCR_SWRSTSD_MASK;\r\nwritel(reg, q->iobase + QUADSPI_MCR);\r\nudelay(1);\r\nreg &= ~(QUADSPI_MCR_SWRSTHD_MASK | QUADSPI_MCR_SWRSTSD_MASK);\r\nwritel(reg, q->iobase + QUADSPI_MCR);\r\n}\r\nstatic int fsl_qspi_nor_write(struct fsl_qspi *q, struct spi_nor *nor,\r\nu8 opcode, unsigned int to, u32 *txbuf,\r\nunsigned count, size_t *retlen)\r\n{\r\nint ret, i, j;\r\nu32 tmp;\r\ndev_dbg(q->dev, "to 0x%.8x:0x%.8x, len : %d\n",\r\nq->chip_base_addr, to, count);\r\ntmp = readl(q->iobase + QUADSPI_MCR);\r\nwritel(tmp | QUADSPI_MCR_CLR_RXF_MASK, q->iobase + QUADSPI_MCR);\r\nfor (j = 0, i = ((count + 3) / 4); j < i; j++) {\r\ntmp = fsl_qspi_endian_xchg(q, *txbuf);\r\nwritel(tmp, q->iobase + QUADSPI_TBDR);\r\ntxbuf++;\r\n}\r\nret = fsl_qspi_runcmd(q, opcode, to, count);\r\nif (ret == 0 && retlen)\r\n*retlen += count;\r\nreturn ret;\r\n}\r\nstatic void fsl_qspi_set_map_addr(struct fsl_qspi *q)\r\n{\r\nint nor_size = q->nor_size;\r\nvoid __iomem *base = q->iobase;\r\nwritel(nor_size + q->memmap_phy, base + QUADSPI_SFA1AD);\r\nwritel(nor_size * 2 + q->memmap_phy, base + QUADSPI_SFA2AD);\r\nwritel(nor_size * 3 + q->memmap_phy, base + QUADSPI_SFB1AD);\r\nwritel(nor_size * 4 + q->memmap_phy, base + QUADSPI_SFB2AD);\r\n}\r\nstatic void fsl_qspi_init_abh_read(struct fsl_qspi *q)\r\n{\r\nvoid __iomem *base = q->iobase;\r\nint seqid;\r\nwritel(QUADSPI_BUFXCR_INVALID_MSTRID, base + QUADSPI_BUF0CR);\r\nwritel(QUADSPI_BUFXCR_INVALID_MSTRID, base + QUADSPI_BUF1CR);\r\nwritel(QUADSPI_BUFXCR_INVALID_MSTRID, base + QUADSPI_BUF2CR);\r\nwritel(QUADSPI_BUF3CR_ALLMST, base + QUADSPI_BUF3CR);\r\nwritel(0, base + QUADSPI_BUF0IND);\r\nwritel(0, base + QUADSPI_BUF1IND);\r\nwritel(0, base + QUADSPI_BUF2IND);\r\nseqid = fsl_qspi_get_seqid(q, q->nor[0].read_opcode);\r\nwritel(seqid << QUADSPI_BFGENCR_SEQID_SHIFT,\r\nq->iobase + QUADSPI_BFGENCR);\r\n}\r\nstatic int fsl_qspi_nor_setup(struct fsl_qspi *q)\r\n{\r\nvoid __iomem *base = q->iobase;\r\nu32 reg;\r\nint ret;\r\nret = clk_set_rate(q->clk, 66000000);\r\nif (ret)\r\nreturn ret;\r\nfsl_qspi_init_lut(q);\r\nwritel(QUADSPI_MCR_MDIS_MASK | QUADSPI_MCR_RESERVED_MASK,\r\nbase + QUADSPI_MCR);\r\nreg = readl(base + QUADSPI_SMPR);\r\nwritel(reg & ~(QUADSPI_SMPR_FSDLY_MASK\r\n| QUADSPI_SMPR_FSPHS_MASK\r\n| QUADSPI_SMPR_HSENA_MASK\r\n| QUADSPI_SMPR_DDRSMP_MASK), base + QUADSPI_SMPR);\r\nwritel(QUADSPI_MCR_RESERVED_MASK | QUADSPI_MCR_END_CFG_MASK,\r\nbase + QUADSPI_MCR);\r\nwritel(QUADSPI_RSER_TFIE, q->iobase + QUADSPI_RSER);\r\nreturn 0;\r\n}\r\nstatic int fsl_qspi_nor_setup_last(struct fsl_qspi *q)\r\n{\r\nunsigned long rate = q->clk_rate;\r\nint ret;\r\nif (is_imx6sx_qspi(q))\r\nrate *= 4;\r\nret = clk_set_rate(q->clk, rate);\r\nif (ret)\r\nreturn ret;\r\nfsl_qspi_init_lut(q);\r\nfsl_qspi_init_abh_read(q);\r\nreturn 0;\r\n}\r\nstatic void fsl_qspi_set_base_addr(struct fsl_qspi *q, struct spi_nor *nor)\r\n{\r\nq->chip_base_addr = q->nor_size * (nor - q->nor);\r\n}\r\nstatic int fsl_qspi_read_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)\r\n{\r\nint ret;\r\nstruct fsl_qspi *q = nor->priv;\r\nret = fsl_qspi_runcmd(q, opcode, 0, len);\r\nif (ret)\r\nreturn ret;\r\nfsl_qspi_read_data(q, len, buf);\r\nreturn 0;\r\n}\r\nstatic int fsl_qspi_write_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len,\r\nint write_enable)\r\n{\r\nstruct fsl_qspi *q = nor->priv;\r\nint ret;\r\nif (!buf) {\r\nret = fsl_qspi_runcmd(q, opcode, 0, 1);\r\nif (ret)\r\nreturn ret;\r\nif (opcode == SPINOR_OP_CHIP_ERASE)\r\nfsl_qspi_invalid(q);\r\n} else if (len > 0) {\r\nret = fsl_qspi_nor_write(q, nor, opcode, 0,\r\n(u32 *)buf, len, NULL);\r\n} else {\r\ndev_err(q->dev, "invalid cmd %d\n", opcode);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void fsl_qspi_write(struct spi_nor *nor, loff_t to,\r\nsize_t len, size_t *retlen, const u_char *buf)\r\n{\r\nstruct fsl_qspi *q = nor->priv;\r\nfsl_qspi_nor_write(q, nor, nor->program_opcode, to,\r\n(u32 *)buf, len, retlen);\r\nfsl_qspi_invalid(q);\r\n}\r\nstatic int fsl_qspi_read(struct spi_nor *nor, loff_t from,\r\nsize_t len, size_t *retlen, u_char *buf)\r\n{\r\nstruct fsl_qspi *q = nor->priv;\r\nu8 cmd = nor->read_opcode;\r\nint ret;\r\ndev_dbg(q->dev, "cmd [%x],read from (0x%p, 0x%.8x, 0x%.8x),len:%d\n",\r\ncmd, q->ahb_base, q->chip_base_addr, (unsigned int)from, len);\r\nret = nor->wait_till_ready(nor);\r\nif (ret)\r\nreturn ret;\r\nmemcpy(buf, q->ahb_base + q->chip_base_addr + from, len);\r\n*retlen += len;\r\nreturn 0;\r\n}\r\nstatic int fsl_qspi_erase(struct spi_nor *nor, loff_t offs)\r\n{\r\nstruct fsl_qspi *q = nor->priv;\r\nint ret;\r\ndev_dbg(nor->dev, "%dKiB at 0x%08x:0x%08x\n",\r\nnor->mtd->erasesize / 1024, q->chip_base_addr, (u32)offs);\r\nret = nor->wait_till_ready(nor);\r\nif (ret)\r\nreturn ret;\r\nret = nor->write_reg(nor, SPINOR_OP_WREN, NULL, 0, 0);\r\nif (ret)\r\nreturn ret;\r\nret = fsl_qspi_runcmd(q, nor->erase_opcode, offs, 0);\r\nif (ret)\r\nreturn ret;\r\nfsl_qspi_invalid(q);\r\nreturn 0;\r\n}\r\nstatic int fsl_qspi_prep(struct spi_nor *nor, enum spi_nor_ops ops)\r\n{\r\nstruct fsl_qspi *q = nor->priv;\r\nint ret;\r\nret = clk_enable(q->clk_en);\r\nif (ret)\r\nreturn ret;\r\nret = clk_enable(q->clk);\r\nif (ret) {\r\nclk_disable(q->clk_en);\r\nreturn ret;\r\n}\r\nfsl_qspi_set_base_addr(q, nor);\r\nreturn 0;\r\n}\r\nstatic void fsl_qspi_unprep(struct spi_nor *nor, enum spi_nor_ops ops)\r\n{\r\nstruct fsl_qspi *q = nor->priv;\r\nclk_disable(q->clk);\r\nclk_disable(q->clk_en);\r\n}\r\nstatic int fsl_qspi_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct mtd_part_parser_data ppdata;\r\nstruct device *dev = &pdev->dev;\r\nstruct fsl_qspi *q;\r\nstruct resource *res;\r\nstruct spi_nor *nor;\r\nstruct mtd_info *mtd;\r\nint ret, i = 0;\r\nbool has_second_chip = false;\r\nconst struct of_device_id *of_id =\r\nof_match_device(fsl_qspi_dt_ids, &pdev->dev);\r\nq = devm_kzalloc(dev, sizeof(*q), GFP_KERNEL);\r\nif (!q)\r\nreturn -ENOMEM;\r\nq->nor_num = of_get_child_count(dev->of_node);\r\nif (!q->nor_num || q->nor_num > FSL_QSPI_MAX_CHIP)\r\nreturn -ENODEV;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "QuadSPI");\r\nq->iobase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(q->iobase)) {\r\nret = PTR_ERR(q->iobase);\r\ngoto map_failed;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"QuadSPI-memory");\r\nq->ahb_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(q->ahb_base)) {\r\nret = PTR_ERR(q->ahb_base);\r\ngoto map_failed;\r\n}\r\nq->memmap_phy = res->start;\r\nq->clk_en = devm_clk_get(dev, "qspi_en");\r\nif (IS_ERR(q->clk_en)) {\r\nret = PTR_ERR(q->clk_en);\r\ngoto map_failed;\r\n}\r\nq->clk = devm_clk_get(dev, "qspi");\r\nif (IS_ERR(q->clk)) {\r\nret = PTR_ERR(q->clk);\r\ngoto map_failed;\r\n}\r\nret = clk_prepare_enable(q->clk_en);\r\nif (ret) {\r\ndev_err(dev, "can not enable the qspi_en clock\n");\r\ngoto map_failed;\r\n}\r\nret = clk_prepare_enable(q->clk);\r\nif (ret) {\r\nclk_disable_unprepare(q->clk_en);\r\ndev_err(dev, "can not enable the qspi clock\n");\r\ngoto map_failed;\r\n}\r\nret = platform_get_irq(pdev, 0);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to get the irq\n");\r\ngoto irq_failed;\r\n}\r\nret = devm_request_irq(dev, ret,\r\nfsl_qspi_irq_handler, 0, pdev->name, q);\r\nif (ret) {\r\ndev_err(dev, "failed to request irq.\n");\r\ngoto irq_failed;\r\n}\r\nq->dev = dev;\r\nq->devtype_data = (struct fsl_qspi_devtype_data *)of_id->data;\r\nplatform_set_drvdata(pdev, q);\r\nret = fsl_qspi_nor_setup(q);\r\nif (ret)\r\ngoto irq_failed;\r\nif (of_get_property(np, "fsl,qspi-has-second-chip", NULL))\r\nhas_second_chip = true;\r\nfor_each_available_child_of_node(dev->of_node, np) {\r\nconst struct spi_device_id *id;\r\nchar modalias[40];\r\nif (!has_second_chip)\r\ni *= 2;\r\nnor = &q->nor[i];\r\nmtd = &q->mtd[i];\r\nnor->mtd = mtd;\r\nnor->dev = dev;\r\nnor->priv = q;\r\nmtd->priv = nor;\r\nnor->read_reg = fsl_qspi_read_reg;\r\nnor->write_reg = fsl_qspi_write_reg;\r\nnor->read = fsl_qspi_read;\r\nnor->write = fsl_qspi_write;\r\nnor->erase = fsl_qspi_erase;\r\nnor->prepare = fsl_qspi_prep;\r\nnor->unprepare = fsl_qspi_unprep;\r\nif (of_modalias_node(np, modalias, sizeof(modalias)) < 0)\r\ngoto map_failed;\r\nid = spi_nor_match_id(modalias);\r\nif (!id)\r\ngoto map_failed;\r\nret = of_property_read_u32(np, "spi-max-frequency",\r\n&q->clk_rate);\r\nif (ret < 0)\r\ngoto map_failed;\r\nfsl_qspi_set_base_addr(q, nor);\r\nret = spi_nor_scan(nor, id, SPI_NOR_QUAD);\r\nif (ret)\r\ngoto map_failed;\r\nppdata.of_node = np;\r\nret = mtd_device_parse_register(mtd, NULL, &ppdata, NULL, 0);\r\nif (ret)\r\ngoto map_failed;\r\nif (q->nor_size == 0) {\r\nq->nor_size = mtd->size;\r\nfsl_qspi_set_map_addr(q);\r\n}\r\nif (nor->page_size > q->devtype_data->txfifo)\r\nnor->page_size = q->devtype_data->txfifo;\r\ni++;\r\n}\r\nret = fsl_qspi_nor_setup_last(q);\r\nif (ret)\r\ngoto last_init_failed;\r\nclk_disable(q->clk);\r\nclk_disable(q->clk_en);\r\ndev_info(dev, "QuadSPI SPI NOR flash driver\n");\r\nreturn 0;\r\nlast_init_failed:\r\nfor (i = 0; i < q->nor_num; i++)\r\nmtd_device_unregister(&q->mtd[i]);\r\nirq_failed:\r\nclk_disable_unprepare(q->clk);\r\nclk_disable_unprepare(q->clk_en);\r\nmap_failed:\r\ndev_err(dev, "Freescale QuadSPI probe failed\n");\r\nreturn ret;\r\n}\r\nstatic int fsl_qspi_remove(struct platform_device *pdev)\r\n{\r\nstruct fsl_qspi *q = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < q->nor_num; i++)\r\nmtd_device_unregister(&q->mtd[i]);\r\nwritel(QUADSPI_MCR_MDIS_MASK, q->iobase + QUADSPI_MCR);\r\nwritel(0x0, q->iobase + QUADSPI_RSER);\r\nclk_unprepare(q->clk);\r\nclk_unprepare(q->clk_en);\r\nreturn 0;\r\n}
