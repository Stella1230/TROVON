void sctp_inq_init(struct sctp_inq *queue)\r\n{\r\nINIT_LIST_HEAD(&queue->in_chunk_list);\r\nqueue->in_progress = NULL;\r\nINIT_WORK(&queue->immediate, NULL);\r\n}\r\nvoid sctp_inq_free(struct sctp_inq *queue)\r\n{\r\nstruct sctp_chunk *chunk, *tmp;\r\nlist_for_each_entry_safe(chunk, tmp, &queue->in_chunk_list, list) {\r\nlist_del_init(&chunk->list);\r\nsctp_chunk_free(chunk);\r\n}\r\nif (queue->in_progress) {\r\nsctp_chunk_free(queue->in_progress);\r\nqueue->in_progress = NULL;\r\n}\r\n}\r\nvoid sctp_inq_push(struct sctp_inq *q, struct sctp_chunk *chunk)\r\n{\r\nif (chunk->rcvr->dead) {\r\nsctp_chunk_free(chunk);\r\nreturn;\r\n}\r\nlist_add_tail(&chunk->list, &q->in_chunk_list);\r\nif (chunk->asoc)\r\nchunk->asoc->stats.ipackets++;\r\nq->immediate.func(&q->immediate);\r\n}\r\nstruct sctp_chunkhdr *sctp_inq_peek(struct sctp_inq *queue)\r\n{\r\nstruct sctp_chunk *chunk;\r\nsctp_chunkhdr_t *ch = NULL;\r\nchunk = queue->in_progress;\r\nif (chunk->singleton ||\r\nchunk->end_of_packet ||\r\nchunk->pdiscard)\r\nreturn NULL;\r\nch = (sctp_chunkhdr_t *)chunk->chunk_end;\r\nreturn ch;\r\n}\r\nstruct sctp_chunk *sctp_inq_pop(struct sctp_inq *queue)\r\n{\r\nstruct sctp_chunk *chunk;\r\nsctp_chunkhdr_t *ch = NULL;\r\nif ((chunk = queue->in_progress)) {\r\nif (chunk->singleton ||\r\nchunk->end_of_packet ||\r\nchunk->pdiscard) {\r\nsctp_chunk_free(chunk);\r\nchunk = queue->in_progress = NULL;\r\n} else {\r\nch = (sctp_chunkhdr_t *) chunk->chunk_end;\r\nskb_pull(chunk->skb,\r\nchunk->chunk_end - chunk->skb->data);\r\nif (skb_headlen(chunk->skb) < sizeof(sctp_chunkhdr_t)) {\r\nsctp_chunk_free(chunk);\r\nchunk = queue->in_progress = NULL;\r\n}\r\n}\r\n}\r\nif (!chunk) {\r\nstruct list_head *entry;\r\nif (list_empty(&queue->in_chunk_list))\r\nreturn NULL;\r\nentry = queue->in_chunk_list.next;\r\nchunk = queue->in_progress =\r\nlist_entry(entry, struct sctp_chunk, list);\r\nlist_del_init(entry);\r\nchunk->singleton = 1;\r\nch = (sctp_chunkhdr_t *) chunk->skb->data;\r\nchunk->data_accepted = 0;\r\n}\r\nchunk->chunk_hdr = ch;\r\nchunk->chunk_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));\r\nif (unlikely(skb_is_nonlinear(chunk->skb))) {\r\nif (chunk->chunk_end > skb_tail_pointer(chunk->skb))\r\nchunk->chunk_end = skb_tail_pointer(chunk->skb);\r\n}\r\nskb_pull(chunk->skb, sizeof(sctp_chunkhdr_t));\r\nchunk->subh.v = NULL;\r\nif (chunk->chunk_end < skb_tail_pointer(chunk->skb)) {\r\nchunk->singleton = 0;\r\n} else if (chunk->chunk_end > skb_tail_pointer(chunk->skb)) {\r\nsctp_chunk_free(chunk);\r\nchunk = queue->in_progress = NULL;\r\nreturn NULL;\r\n} else {\r\nchunk->end_of_packet = 1;\r\n}\r\npr_debug("+++sctp_inq_pop+++ chunk:%p[%s], length:%d, skb->len:%d\n",\r\nchunk, sctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)),\r\nntohs(chunk->chunk_hdr->length), chunk->skb->len);\r\nreturn chunk;\r\n}\r\nvoid sctp_inq_set_th_handler(struct sctp_inq *q, work_func_t callback)\r\n{\r\nINIT_WORK(&q->immediate, callback);\r\n}
