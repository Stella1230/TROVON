static irqreturn_t mpr_touchkey_interrupt(int irq, void *dev_id)\r\n{\r\nstruct mpr121_touchkey *mpr121 = dev_id;\r\nstruct i2c_client *client = mpr121->client;\r\nstruct input_dev *input = mpr121->input_dev;\r\nunsigned int key_num, key_val, pressed;\r\nint reg;\r\nreg = i2c_smbus_read_byte_data(client, ELE_TOUCH_STATUS_1_ADDR);\r\nif (reg < 0) {\r\ndev_err(&client->dev, "i2c read error [%d]\n", reg);\r\ngoto out;\r\n}\r\nreg <<= 8;\r\nreg |= i2c_smbus_read_byte_data(client, ELE_TOUCH_STATUS_0_ADDR);\r\nif (reg < 0) {\r\ndev_err(&client->dev, "i2c read error [%d]\n", reg);\r\ngoto out;\r\n}\r\nreg &= TOUCH_STATUS_MASK;\r\nkey_num = ffs(reg ^ mpr121->statusbits) - 1;\r\npressed = reg & (1 << key_num);\r\nmpr121->statusbits = reg;\r\nkey_val = mpr121->keycodes[key_num];\r\ninput_event(input, EV_MSC, MSC_SCAN, key_num);\r\ninput_report_key(input, key_val, pressed);\r\ninput_sync(input);\r\ndev_dbg(&client->dev, "key %d %d %s\n", key_num, key_val,\r\npressed ? "pressed" : "released");\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mpr121_phys_init(const struct mpr121_platform_data *pdata,\r\nstruct mpr121_touchkey *mpr121,\r\nstruct i2c_client *client)\r\n{\r\nconst struct mpr121_init_register *reg;\r\nunsigned char usl, lsl, tl, eleconf;\r\nint i, t, vdd, ret;\r\nfor (i = 0; i <= MPR121_MAX_KEY_COUNT; i++) {\r\nt = ELE0_TOUCH_THRESHOLD_ADDR + (i * 2);\r\nret = i2c_smbus_write_byte_data(client, t, TOUCH_THRESHOLD);\r\nif (ret < 0)\r\ngoto err_i2c_write;\r\nret = i2c_smbus_write_byte_data(client, t + 1,\r\nRELEASE_THRESHOLD);\r\nif (ret < 0)\r\ngoto err_i2c_write;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(init_reg_table); i++) {\r\nreg = &init_reg_table[i];\r\nret = i2c_smbus_write_byte_data(client, reg->addr, reg->val);\r\nif (ret < 0)\r\ngoto err_i2c_write;\r\n}\r\nvdd = pdata->vdd_uv / 1000;\r\nusl = ((vdd - 700) * 256) / vdd;\r\nlsl = (usl * 65) / 100;\r\ntl = (usl * 90) / 100;\r\nret = i2c_smbus_write_byte_data(client, AUTO_CONFIG_USL_ADDR, usl);\r\nret |= i2c_smbus_write_byte_data(client, AUTO_CONFIG_LSL_ADDR, lsl);\r\nret |= i2c_smbus_write_byte_data(client, AUTO_CONFIG_TL_ADDR, tl);\r\neleconf = mpr121->keycount | ELECTRODE_CONF_QUICK_CHARGE;\r\nret |= i2c_smbus_write_byte_data(client, ELECTRODE_CONF_ADDR,\r\neleconf);\r\nif (ret != 0)\r\ngoto err_i2c_write;\r\ndev_dbg(&client->dev, "set up with %x keys.\n", mpr121->keycount);\r\nreturn 0;\r\nerr_i2c_write:\r\ndev_err(&client->dev, "i2c write error: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int mpr_touchkey_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct mpr121_platform_data *pdata =\r\ndev_get_platdata(&client->dev);\r\nstruct mpr121_touchkey *mpr121;\r\nstruct input_dev *input_dev;\r\nint error;\r\nint i;\r\nif (!pdata) {\r\ndev_err(&client->dev, "no platform data defined\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pdata->keymap || !pdata->keymap_size) {\r\ndev_err(&client->dev, "missing keymap data\n");\r\nreturn -EINVAL;\r\n}\r\nif (pdata->keymap_size > MPR121_MAX_KEY_COUNT) {\r\ndev_err(&client->dev, "too many keys defined\n");\r\nreturn -EINVAL;\r\n}\r\nif (!client->irq) {\r\ndev_err(&client->dev, "irq number should not be zero\n");\r\nreturn -EINVAL;\r\n}\r\nmpr121 = kzalloc(sizeof(struct mpr121_touchkey), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!mpr121 || !input_dev) {\r\ndev_err(&client->dev, "Failed to allocate memory\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nmpr121->client = client;\r\nmpr121->input_dev = input_dev;\r\nmpr121->keycount = pdata->keymap_size;\r\ninput_dev->name = "Freescale MPR121 Touchkey";\r\ninput_dev->id.bustype = BUS_I2C;\r\ninput_dev->dev.parent = &client->dev;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);\r\ninput_dev->keycode = mpr121->keycodes;\r\ninput_dev->keycodesize = sizeof(mpr121->keycodes[0]);\r\ninput_dev->keycodemax = mpr121->keycount;\r\nfor (i = 0; i < pdata->keymap_size; i++) {\r\ninput_set_capability(input_dev, EV_KEY, pdata->keymap[i]);\r\nmpr121->keycodes[i] = pdata->keymap[i];\r\n}\r\nerror = mpr121_phys_init(pdata, mpr121, client);\r\nif (error) {\r\ndev_err(&client->dev, "Failed to init register\n");\r\ngoto err_free_mem;\r\n}\r\nerror = request_threaded_irq(client->irq, NULL,\r\nmpr_touchkey_interrupt,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\nclient->dev.driver->name, mpr121);\r\nif (error) {\r\ndev_err(&client->dev, "Failed to register interrupt\n");\r\ngoto err_free_mem;\r\n}\r\nerror = input_register_device(input_dev);\r\nif (error)\r\ngoto err_free_irq;\r\ni2c_set_clientdata(client, mpr121);\r\ndevice_init_wakeup(&client->dev, pdata->wakeup);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(client->irq, mpr121);\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(mpr121);\r\nreturn error;\r\n}\r\nstatic int mpr_touchkey_remove(struct i2c_client *client)\r\n{\r\nstruct mpr121_touchkey *mpr121 = i2c_get_clientdata(client);\r\nfree_irq(client->irq, mpr121);\r\ninput_unregister_device(mpr121->input_dev);\r\nkfree(mpr121);\r\nreturn 0;\r\n}\r\nstatic int mpr_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nif (device_may_wakeup(&client->dev))\r\nenable_irq_wake(client->irq);\r\ni2c_smbus_write_byte_data(client, ELECTRODE_CONF_ADDR, 0x00);\r\nreturn 0;\r\n}\r\nstatic int mpr_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct mpr121_touchkey *mpr121 = i2c_get_clientdata(client);\r\nif (device_may_wakeup(&client->dev))\r\ndisable_irq_wake(client->irq);\r\ni2c_smbus_write_byte_data(client, ELECTRODE_CONF_ADDR,\r\nmpr121->keycount);\r\nreturn 0;\r\n}
