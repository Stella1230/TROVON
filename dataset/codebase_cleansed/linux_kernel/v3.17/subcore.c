static void wait_for_sync_step(int step)\r\n{\r\nint i, cpu = smp_processor_id();\r\nfor (i = cpu + 1; i < cpu + threads_per_core; i++)\r\nwhile(per_cpu(split_state, i).step < step)\r\nbarrier();\r\nmb();\r\n}\r\nstatic void unsplit_core(void)\r\n{\r\nu64 hid0, mask;\r\nint i, cpu;\r\nmask = HID0_POWER8_2LPARMODE | HID0_POWER8_4LPARMODE;\r\ncpu = smp_processor_id();\r\nif (cpu_thread_in_core(cpu) != 0) {\r\nwhile (mfspr(SPRN_HID0) & mask)\r\npower7_nap(0);\r\nper_cpu(split_state, cpu).step = SYNC_STEP_UNSPLIT;\r\nreturn;\r\n}\r\nhid0 = mfspr(SPRN_HID0);\r\nhid0 &= ~HID0_POWER8_DYNLPARDIS;\r\nmtspr(SPRN_HID0, hid0);\r\nwhile (mfspr(SPRN_HID0) & mask)\r\ncpu_relax();\r\nfor (i = cpu + 1; i < cpu + threads_per_core; i++)\r\nsmp_send_reschedule(i);\r\nwait_for_sync_step(SYNC_STEP_UNSPLIT);\r\n}\r\nstatic void split_core(int new_mode)\r\n{\r\nstruct { u64 value; u64 mask; } split_parms[2] = {\r\n{ HID0_POWER8_1TO2LPAR, HID0_POWER8_2LPARMODE },\r\n{ HID0_POWER8_1TO4LPAR, HID0_POWER8_4LPARMODE }\r\n};\r\nint i, cpu;\r\nu64 hid0;\r\ni = (new_mode >> 1) - 1;\r\nBUG_ON(i < 0 || i > 1);\r\ncpu = smp_processor_id();\r\nif (cpu_thread_in_core(cpu) != 0) {\r\nsplit_core_secondary_loop(&per_cpu(split_state, cpu).step);\r\nreturn;\r\n}\r\nwait_for_sync_step(SYNC_STEP_REAL_MODE);\r\nhid0 = mfspr(SPRN_HID0);\r\nhid0 |= HID0_POWER8_DYNLPARDIS | split_parms[i].value;\r\nmtspr(SPRN_HID0, hid0);\r\nwhile (!(mfspr(SPRN_HID0) & split_parms[i].mask))\r\ncpu_relax();\r\n}\r\nstatic void cpu_do_split(int new_mode)\r\n{\r\nif (subcores_per_core != 1)\r\nunsplit_core();\r\nif (new_mode != 1)\r\nsplit_core(new_mode);\r\nmb();\r\nper_cpu(split_state, smp_processor_id()).step = SYNC_STEP_FINISHED;\r\n}\r\nbool cpu_core_split_required(void)\r\n{\r\nsmp_rmb();\r\nif (!new_split_mode)\r\nreturn false;\r\ncpu_do_split(new_split_mode);\r\nreturn true;\r\n}\r\nstatic int cpu_update_split_mode(void *data)\r\n{\r\nint cpu, new_mode = *(int *)data;\r\nif (this_cpu_ptr(&split_state)->master) {\r\nnew_split_mode = new_mode;\r\nsmp_wmb();\r\ncpumask_andnot(cpu_offline_mask, cpu_present_mask,\r\ncpu_online_mask);\r\nfor_each_cpu(cpu, cpu_offline_mask)\r\nsmp_send_reschedule(cpu);\r\n}\r\ncpu_do_split(new_mode);\r\nif (this_cpu_ptr(&split_state)->master) {\r\nfor_each_present_cpu(cpu) {\r\nif (cpu >= setup_max_cpus)\r\nbreak;\r\nwhile(per_cpu(split_state, cpu).step < SYNC_STEP_FINISHED)\r\nbarrier();\r\n}\r\nnew_split_mode = 0;\r\nsubcores_per_core = new_mode;\r\nthreads_per_subcore = threads_per_core / subcores_per_core;\r\nmb();\r\n}\r\nreturn 0;\r\n}\r\nstatic int set_subcores_per_core(int new_mode)\r\n{\r\nstruct split_state *state;\r\nint cpu;\r\nif (kvm_hv_mode_active()) {\r\npr_err("Unable to change split core mode while KVM active.\n");\r\nreturn -EBUSY;\r\n}\r\nBUG_ON(new_mode < 1 || new_mode > 4 || new_mode == 3);\r\nfor_each_present_cpu(cpu) {\r\nstate = &per_cpu(split_state, cpu);\r\nstate->step = SYNC_STEP_INITIAL;\r\nstate->master = 0;\r\n}\r\nget_online_cpus();\r\nthis_cpu_ptr(&split_state)->master = 1;\r\nmb();\r\nstop_machine(cpu_update_split_mode, &new_mode, cpu_online_mask);\r\nput_online_cpus();\r\nreturn 0;\r\n}\r\nstatic ssize_t __used store_subcores_per_core(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nunsigned long val;\r\nint rc;\r\nrc = sscanf(buf, "%lx", &val);\r\nif (rc != 1)\r\nreturn -EINVAL;\r\nswitch (val) {\r\ncase 1:\r\ncase 2:\r\ncase 4:\r\nif (subcores_per_core == val)\r\ngoto out;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nrc = set_subcores_per_core(val);\r\nif (rc)\r\nreturn rc;\r\nout:\r\nreturn count;\r\n}\r\nstatic ssize_t show_subcores_per_core(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%x\n", subcores_per_core);\r\n}\r\nstatic int subcore_init(void)\r\n{\r\nif (!cpu_has_feature(CPU_FTR_ARCH_207S))\r\nreturn 0;\r\nif (setup_max_cpus % threads_per_core)\r\nreturn 0;\r\nBUG_ON(!alloc_cpumask_var(&cpu_offline_mask, GFP_KERNEL));\r\nset_subcores_per_core(1);\r\nreturn device_create_file(cpu_subsys.dev_root,\r\n&dev_attr_subcores_per_core);\r\n}
