s32 shiftx(s32 x, int demod, s32 shift)\r\n{\r\nif (demod == 1)\r\nreturn x - shift;\r\nreturn x;\r\n}\r\nint stv0900_check_signal_presence(struct stv0900_internal *intp,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\ns32 carr_offset,\r\nagc2_integr,\r\nmax_carrier;\r\nint no_signal = FALSE;\r\ncarr_offset = (stv0900_read_reg(intp, CFR2) << 8)\r\n| stv0900_read_reg(intp, CFR1);\r\ncarr_offset = ge2comp(carr_offset, 16);\r\nagc2_integr = (stv0900_read_reg(intp, AGC2I1) << 8)\r\n| stv0900_read_reg(intp, AGC2I0);\r\nmax_carrier = intp->srch_range[demod] / 1000;\r\nmax_carrier += (max_carrier / 10);\r\nmax_carrier = 65536 * (max_carrier / 2);\r\nmax_carrier /= intp->mclk / 1000;\r\nif (max_carrier > 0x4000)\r\nmax_carrier = 0x4000;\r\nif ((agc2_integr > 0x2000)\r\n|| (carr_offset > (2 * max_carrier))\r\n|| (carr_offset < (-2 * max_carrier)))\r\nno_signal = TRUE;\r\nreturn no_signal;\r\n}\r\nstatic void stv0900_get_sw_loop_params(struct stv0900_internal *intp,\r\ns32 *frequency_inc, s32 *sw_timeout,\r\ns32 *steps,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\ns32 timeout, freq_inc, max_steps, srate, max_carrier;\r\nenum fe_stv0900_search_standard standard;\r\nsrate = intp->symbol_rate[demod];\r\nmax_carrier = intp->srch_range[demod] / 1000;\r\nmax_carrier += max_carrier / 10;\r\nstandard = intp->srch_standard[demod];\r\nmax_carrier = 65536 * (max_carrier / 2);\r\nmax_carrier /= intp->mclk / 1000;\r\nif (max_carrier > 0x4000)\r\nmax_carrier = 0x4000;\r\nfreq_inc = srate;\r\nfreq_inc /= intp->mclk >> 10;\r\nfreq_inc = freq_inc << 6;\r\nswitch (standard) {\r\ncase STV0900_SEARCH_DVBS1:\r\ncase STV0900_SEARCH_DSS:\r\nfreq_inc *= 3;\r\ntimeout = 20;\r\nbreak;\r\ncase STV0900_SEARCH_DVBS2:\r\nfreq_inc *= 4;\r\ntimeout = 25;\r\nbreak;\r\ncase STV0900_AUTO_SEARCH:\r\ndefault:\r\nfreq_inc *= 3;\r\ntimeout = 25;\r\nbreak;\r\n}\r\nfreq_inc /= 100;\r\nif ((freq_inc > max_carrier) || (freq_inc < 0))\r\nfreq_inc = max_carrier / 2;\r\ntimeout *= 27500;\r\nif (srate > 0)\r\ntimeout /= srate / 1000;\r\nif ((timeout > 100) || (timeout < 0))\r\ntimeout = 100;\r\nmax_steps = (max_carrier / freq_inc) + 1;\r\nif ((max_steps > 100) || (max_steps < 0)) {\r\nmax_steps = 100;\r\nfreq_inc = max_carrier / max_steps;\r\n}\r\n*frequency_inc = freq_inc;\r\n*sw_timeout = timeout;\r\n*steps = max_steps;\r\n}\r\nstatic int stv0900_search_carr_sw_loop(struct stv0900_internal *intp,\r\ns32 FreqIncr, s32 Timeout, int zigzag,\r\ns32 MaxStep, enum fe_stv0900_demod_num demod)\r\n{\r\nint no_signal,\r\nlock = FALSE;\r\ns32 stepCpt,\r\nfreqOffset,\r\nmax_carrier;\r\nmax_carrier = intp->srch_range[demod] / 1000;\r\nmax_carrier += (max_carrier / 10);\r\nmax_carrier = 65536 * (max_carrier / 2);\r\nmax_carrier /= intp->mclk / 1000;\r\nif (max_carrier > 0x4000)\r\nmax_carrier = 0x4000;\r\nif (zigzag == TRUE)\r\nfreqOffset = 0;\r\nelse\r\nfreqOffset = -max_carrier + FreqIncr;\r\nstepCpt = 0;\r\ndo {\r\nstv0900_write_reg(intp, DMDISTATE, 0x1c);\r\nstv0900_write_reg(intp, CFRINIT1, (freqOffset / 256) & 0xff);\r\nstv0900_write_reg(intp, CFRINIT0, freqOffset & 0xff);\r\nstv0900_write_reg(intp, DMDISTATE, 0x18);\r\nstv0900_write_bits(intp, ALGOSWRST, 1);\r\nif (intp->chip_id == 0x12) {\r\nstv0900_write_bits(intp, RST_HWARE, 1);\r\nstv0900_write_bits(intp, RST_HWARE, 0);\r\n}\r\nif (zigzag == TRUE) {\r\nif (freqOffset >= 0)\r\nfreqOffset = -freqOffset - 2 * FreqIncr;\r\nelse\r\nfreqOffset = -freqOffset;\r\n} else\r\nfreqOffset += + 2 * FreqIncr;\r\nstepCpt++;\r\nlock = stv0900_get_demod_lock(intp, demod, Timeout);\r\nno_signal = stv0900_check_signal_presence(intp, demod);\r\n} while ((lock == FALSE)\r\n&& (no_signal == FALSE)\r\n&& ((freqOffset - FreqIncr) < max_carrier)\r\n&& ((freqOffset + FreqIncr) > -max_carrier)\r\n&& (stepCpt < MaxStep));\r\nstv0900_write_bits(intp, ALGOSWRST, 0);\r\nreturn lock;\r\n}\r\nstatic int stv0900_sw_algo(struct stv0900_internal *intp,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\nint lock = FALSE,\r\nno_signal,\r\nzigzag;\r\ns32 s2fw,\r\nfqc_inc,\r\nsft_stp_tout,\r\ntrial_cntr,\r\nmax_steps;\r\nstv0900_get_sw_loop_params(intp, &fqc_inc, &sft_stp_tout,\r\n&max_steps, demod);\r\nswitch (intp->srch_standard[demod]) {\r\ncase STV0900_SEARCH_DVBS1:\r\ncase STV0900_SEARCH_DSS:\r\nif (intp->chip_id >= 0x20)\r\nstv0900_write_reg(intp, CARFREQ, 0x3b);\r\nelse\r\nstv0900_write_reg(intp, CARFREQ, 0xef);\r\nstv0900_write_reg(intp, DMDCFGMD, 0x49);\r\nzigzag = FALSE;\r\nbreak;\r\ncase STV0900_SEARCH_DVBS2:\r\nif (intp->chip_id >= 0x20)\r\nstv0900_write_reg(intp, CORRELABS, 0x79);\r\nelse\r\nstv0900_write_reg(intp, CORRELABS, 0x68);\r\nstv0900_write_reg(intp, DMDCFGMD, 0x89);\r\nzigzag = TRUE;\r\nbreak;\r\ncase STV0900_AUTO_SEARCH:\r\ndefault:\r\nif (intp->chip_id >= 0x20) {\r\nstv0900_write_reg(intp, CARFREQ, 0x3b);\r\nstv0900_write_reg(intp, CORRELABS, 0x79);\r\n} else {\r\nstv0900_write_reg(intp, CARFREQ, 0xef);\r\nstv0900_write_reg(intp, CORRELABS, 0x68);\r\n}\r\nstv0900_write_reg(intp, DMDCFGMD, 0xc9);\r\nzigzag = FALSE;\r\nbreak;\r\n}\r\ntrial_cntr = 0;\r\ndo {\r\nlock = stv0900_search_carr_sw_loop(intp,\r\nfqc_inc,\r\nsft_stp_tout,\r\nzigzag,\r\nmax_steps,\r\ndemod);\r\nno_signal = stv0900_check_signal_presence(intp, demod);\r\ntrial_cntr++;\r\nif ((lock == TRUE)\r\n|| (no_signal == TRUE)\r\n|| (trial_cntr == 2)) {\r\nif (intp->chip_id >= 0x20) {\r\nstv0900_write_reg(intp, CARFREQ, 0x49);\r\nstv0900_write_reg(intp, CORRELABS, 0x9e);\r\n} else {\r\nstv0900_write_reg(intp, CARFREQ, 0xed);\r\nstv0900_write_reg(intp, CORRELABS, 0x88);\r\n}\r\nif ((stv0900_get_bits(intp, HEADER_MODE) ==\r\nSTV0900_DVBS2_FOUND) &&\r\n(lock == TRUE)) {\r\nmsleep(sft_stp_tout);\r\ns2fw = stv0900_get_bits(intp, FLYWHEEL_CPT);\r\nif (s2fw < 0xd) {\r\nmsleep(sft_stp_tout);\r\ns2fw = stv0900_get_bits(intp,\r\nFLYWHEEL_CPT);\r\n}\r\nif (s2fw < 0xd) {\r\nlock = FALSE;\r\nif (trial_cntr < 2) {\r\nif (intp->chip_id >= 0x20)\r\nstv0900_write_reg(intp,\r\nCORRELABS,\r\n0x79);\r\nelse\r\nstv0900_write_reg(intp,\r\nCORRELABS,\r\n0x68);\r\nstv0900_write_reg(intp,\r\nDMDCFGMD,\r\n0x89);\r\n}\r\n}\r\n}\r\n}\r\n} while ((lock == FALSE)\r\n&& (trial_cntr < 2)\r\n&& (no_signal == FALSE));\r\nreturn lock;\r\n}\r\nstatic u32 stv0900_get_symbol_rate(struct stv0900_internal *intp,\r\nu32 mclk,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\ns32 rem1, rem2, intval1, intval2, srate;\r\nsrate = (stv0900_get_bits(intp, SYMB_FREQ3) << 24) +\r\n(stv0900_get_bits(intp, SYMB_FREQ2) << 16) +\r\n(stv0900_get_bits(intp, SYMB_FREQ1) << 8) +\r\n(stv0900_get_bits(intp, SYMB_FREQ0));\r\ndprintk("lock: srate=%d r0=0x%x r1=0x%x r2=0x%x r3=0x%x \n",\r\nsrate, stv0900_get_bits(intp, SYMB_FREQ0),\r\nstv0900_get_bits(intp, SYMB_FREQ1),\r\nstv0900_get_bits(intp, SYMB_FREQ2),\r\nstv0900_get_bits(intp, SYMB_FREQ3));\r\nintval1 = (mclk) >> 16;\r\nintval2 = (srate) >> 16;\r\nrem1 = (mclk) % 0x10000;\r\nrem2 = (srate) % 0x10000;\r\nsrate = (intval1 * intval2) +\r\n((intval1 * rem2) >> 16) +\r\n((intval2 * rem1) >> 16);\r\nreturn srate;\r\n}\r\nstatic void stv0900_set_symbol_rate(struct stv0900_internal *intp,\r\nu32 mclk, u32 srate,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\nu32 symb;\r\ndprintk("%s: Mclk %d, SR %d, Dmd %d\n", __func__, mclk,\r\nsrate, demod);\r\nif (srate > 60000000) {\r\nsymb = srate << 4;\r\nsymb /= (mclk >> 12);\r\n} else if (srate > 6000000) {\r\nsymb = srate << 6;\r\nsymb /= (mclk >> 10);\r\n} else {\r\nsymb = srate << 9;\r\nsymb /= (mclk >> 7);\r\n}\r\nstv0900_write_reg(intp, SFRINIT1, (symb >> 8) & 0x7f);\r\nstv0900_write_reg(intp, SFRINIT1 + 1, (symb & 0xff));\r\n}\r\nstatic void stv0900_set_max_symbol_rate(struct stv0900_internal *intp,\r\nu32 mclk, u32 srate,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\nu32 symb;\r\nsrate = 105 * (srate / 100);\r\nif (srate > 60000000) {\r\nsymb = srate << 4;\r\nsymb /= (mclk >> 12);\r\n} else if (srate > 6000000) {\r\nsymb = srate << 6;\r\nsymb /= (mclk >> 10);\r\n} else {\r\nsymb = srate << 9;\r\nsymb /= (mclk >> 7);\r\n}\r\nif (symb < 0x7fff) {\r\nstv0900_write_reg(intp, SFRUP1, (symb >> 8) & 0x7f);\r\nstv0900_write_reg(intp, SFRUP1 + 1, (symb & 0xff));\r\n} else {\r\nstv0900_write_reg(intp, SFRUP1, 0x7f);\r\nstv0900_write_reg(intp, SFRUP1 + 1, 0xff);\r\n}\r\n}\r\nstatic void stv0900_set_min_symbol_rate(struct stv0900_internal *intp,\r\nu32 mclk, u32 srate,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\nu32 symb;\r\nsrate = 95 * (srate / 100);\r\nif (srate > 60000000) {\r\nsymb = srate << 4;\r\nsymb /= (mclk >> 12);\r\n} else if (srate > 6000000) {\r\nsymb = srate << 6;\r\nsymb /= (mclk >> 10);\r\n} else {\r\nsymb = srate << 9;\r\nsymb /= (mclk >> 7);\r\n}\r\nstv0900_write_reg(intp, SFRLOW1, (symb >> 8) & 0xff);\r\nstv0900_write_reg(intp, SFRLOW1 + 1, (symb & 0xff));\r\n}\r\nstatic s32 stv0900_get_timing_offst(struct stv0900_internal *intp,\r\nu32 srate,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\ns32 timingoffset;\r\ntimingoffset = (stv0900_read_reg(intp, TMGREG2) << 16) +\r\n(stv0900_read_reg(intp, TMGREG2 + 1) << 8) +\r\n(stv0900_read_reg(intp, TMGREG2 + 2));\r\ntimingoffset = ge2comp(timingoffset, 24);\r\nif (timingoffset == 0)\r\ntimingoffset = 1;\r\ntimingoffset = ((s32)srate * 10) / ((s32)0x1000000 / timingoffset);\r\ntimingoffset /= 320;\r\nreturn timingoffset;\r\n}\r\nstatic void stv0900_set_dvbs2_rolloff(struct stv0900_internal *intp,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\ns32 rolloff;\r\nif (intp->chip_id == 0x10) {\r\nstv0900_write_bits(intp, MANUALSX_ROLLOFF, 1);\r\nrolloff = stv0900_read_reg(intp, MATSTR1) & 0x03;\r\nstv0900_write_bits(intp, ROLLOFF_CONTROL, rolloff);\r\n} else if (intp->chip_id <= 0x20)\r\nstv0900_write_bits(intp, MANUALSX_ROLLOFF, 0);\r\nelse\r\nstv0900_write_bits(intp, MANUALS2_ROLLOFF, 0);\r\n}\r\nstatic u32 stv0900_carrier_width(u32 srate, enum fe_stv0900_rolloff ro)\r\n{\r\nu32 rolloff;\r\nswitch (ro) {\r\ncase STV0900_20:\r\nrolloff = 20;\r\nbreak;\r\ncase STV0900_25:\r\nrolloff = 25;\r\nbreak;\r\ncase STV0900_35:\r\ndefault:\r\nrolloff = 35;\r\nbreak;\r\n}\r\nreturn srate + (srate * rolloff) / 100;\r\n}\r\nstatic int stv0900_check_timing_lock(struct stv0900_internal *intp,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\nint timingLock = FALSE;\r\ns32 i,\r\ntimingcpt = 0;\r\nu8 car_freq,\r\ntmg_th_high,\r\ntmg_th_low;\r\ncar_freq = stv0900_read_reg(intp, CARFREQ);\r\ntmg_th_high = stv0900_read_reg(intp, TMGTHRISE);\r\ntmg_th_low = stv0900_read_reg(intp, TMGTHFALL);\r\nstv0900_write_reg(intp, TMGTHRISE, 0x20);\r\nstv0900_write_reg(intp, TMGTHFALL, 0x0);\r\nstv0900_write_bits(intp, CFR_AUTOSCAN, 0);\r\nstv0900_write_reg(intp, RTC, 0x80);\r\nstv0900_write_reg(intp, RTCS2, 0x40);\r\nstv0900_write_reg(intp, CARFREQ, 0x0);\r\nstv0900_write_reg(intp, CFRINIT1, 0x0);\r\nstv0900_write_reg(intp, CFRINIT0, 0x0);\r\nstv0900_write_reg(intp, AGC2REF, 0x65);\r\nstv0900_write_reg(intp, DMDISTATE, 0x18);\r\nmsleep(7);\r\nfor (i = 0; i < 10; i++) {\r\nif (stv0900_get_bits(intp, TMGLOCK_QUALITY) >= 2)\r\ntimingcpt++;\r\nmsleep(1);\r\n}\r\nif (timingcpt >= 3)\r\ntimingLock = TRUE;\r\nstv0900_write_reg(intp, AGC2REF, 0x38);\r\nstv0900_write_reg(intp, RTC, 0x88);\r\nstv0900_write_reg(intp, RTCS2, 0x68);\r\nstv0900_write_reg(intp, CARFREQ, car_freq);\r\nstv0900_write_reg(intp, TMGTHRISE, tmg_th_high);\r\nstv0900_write_reg(intp, TMGTHFALL, tmg_th_low);\r\nreturn timingLock;\r\n}\r\nstatic int stv0900_get_demod_cold_lock(struct dvb_frontend *fe,\r\ns32 demod_timeout)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nstruct stv0900_internal *intp = state->internal;\r\nenum fe_stv0900_demod_num demod = state->demod;\r\nint lock = FALSE,\r\nd = demod;\r\ns32 srate,\r\nsearch_range,\r\nlocktimeout,\r\ncurrier_step,\r\nnb_steps,\r\ncurrent_step,\r\ndirection,\r\ntuner_freq,\r\ntimeout,\r\nfreq;\r\nsrate = intp->symbol_rate[d];\r\nsearch_range = intp->srch_range[d];\r\nif (srate >= 10000000)\r\nlocktimeout = demod_timeout / 3;\r\nelse\r\nlocktimeout = demod_timeout / 2;\r\nlock = stv0900_get_demod_lock(intp, d, locktimeout);\r\nif (lock != FALSE)\r\nreturn lock;\r\nif (srate >= 10000000) {\r\nif (stv0900_check_timing_lock(intp, d) == TRUE) {\r\nstv0900_write_reg(intp, DMDISTATE, 0x1f);\r\nstv0900_write_reg(intp, DMDISTATE, 0x15);\r\nlock = stv0900_get_demod_lock(intp, d, demod_timeout);\r\n} else\r\nlock = FALSE;\r\nreturn lock;\r\n}\r\nif (intp->chip_id <= 0x20) {\r\nif (srate <= 1000000)\r\ncurrier_step = 500;\r\nelse if (srate <= 4000000)\r\ncurrier_step = 1000;\r\nelse if (srate <= 7000000)\r\ncurrier_step = 2000;\r\nelse if (srate <= 10000000)\r\ncurrier_step = 3000;\r\nelse\r\ncurrier_step = 5000;\r\nif (srate >= 2000000) {\r\ntimeout = (demod_timeout / 3);\r\nif (timeout > 1000)\r\ntimeout = 1000;\r\n} else\r\ntimeout = (demod_timeout / 2);\r\n} else {\r\ncurrier_step = srate / 4000;\r\ntimeout = (demod_timeout * 3) / 4;\r\n}\r\nnb_steps = ((search_range / 1000) / currier_step);\r\nif ((nb_steps % 2) != 0)\r\nnb_steps += 1;\r\nif (nb_steps <= 0)\r\nnb_steps = 2;\r\nelse if (nb_steps > 12)\r\nnb_steps = 12;\r\ncurrent_step = 1;\r\ndirection = 1;\r\nif (intp->chip_id <= 0x20) {\r\ntuner_freq = intp->freq[d];\r\nintp->bw[d] = stv0900_carrier_width(intp->symbol_rate[d],\r\nintp->rolloff) + intp->symbol_rate[d];\r\n} else\r\ntuner_freq = 0;\r\nwhile ((current_step <= nb_steps) && (lock == FALSE)) {\r\nif (direction > 0)\r\ntuner_freq += (current_step * currier_step);\r\nelse\r\ntuner_freq -= (current_step * currier_step);\r\nif (intp->chip_id <= 0x20) {\r\nif (intp->tuner_type[d] == 3)\r\nstv0900_set_tuner_auto(intp, tuner_freq,\r\nintp->bw[d], demod);\r\nelse\r\nstv0900_set_tuner(fe, tuner_freq, intp->bw[d]);\r\nstv0900_write_reg(intp, DMDISTATE, 0x1c);\r\nstv0900_write_reg(intp, CFRINIT1, 0);\r\nstv0900_write_reg(intp, CFRINIT0, 0);\r\nstv0900_write_reg(intp, DMDISTATE, 0x1f);\r\nstv0900_write_reg(intp, DMDISTATE, 0x15);\r\n} else {\r\nstv0900_write_reg(intp, DMDISTATE, 0x1c);\r\nfreq = (tuner_freq * 65536) / (intp->mclk / 1000);\r\nstv0900_write_bits(intp, CFR_INIT1, MSB(freq));\r\nstv0900_write_bits(intp, CFR_INIT0, LSB(freq));\r\nstv0900_write_reg(intp, DMDISTATE, 0x1f);\r\nstv0900_write_reg(intp, DMDISTATE, 0x05);\r\n}\r\nlock = stv0900_get_demod_lock(intp, d, timeout);\r\ndirection *= -1;\r\ncurrent_step++;\r\n}\r\nreturn lock;\r\n}\r\nstatic void stv0900_get_lock_timeout(s32 *demod_timeout, s32 *fec_timeout,\r\ns32 srate,\r\nenum fe_stv0900_search_algo algo)\r\n{\r\nswitch (algo) {\r\ncase STV0900_BLIND_SEARCH:\r\nif (srate <= 1500000) {\r\n(*demod_timeout) = 1500;\r\n(*fec_timeout) = 400;\r\n} else if (srate <= 5000000) {\r\n(*demod_timeout) = 1000;\r\n(*fec_timeout) = 300;\r\n} else {\r\n(*demod_timeout) = 700;\r\n(*fec_timeout) = 100;\r\n}\r\nbreak;\r\ncase STV0900_COLD_START:\r\ncase STV0900_WARM_START:\r\ndefault:\r\nif (srate <= 1000000) {\r\n(*demod_timeout) = 3000;\r\n(*fec_timeout) = 1700;\r\n} else if (srate <= 2000000) {\r\n(*demod_timeout) = 2500;\r\n(*fec_timeout) = 1100;\r\n} else if (srate <= 5000000) {\r\n(*demod_timeout) = 1000;\r\n(*fec_timeout) = 550;\r\n} else if (srate <= 10000000) {\r\n(*demod_timeout) = 700;\r\n(*fec_timeout) = 250;\r\n} else if (srate <= 20000000) {\r\n(*demod_timeout) = 400;\r\n(*fec_timeout) = 130;\r\n} else {\r\n(*demod_timeout) = 300;\r\n(*fec_timeout) = 100;\r\n}\r\nbreak;\r\n}\r\nif (algo == STV0900_WARM_START)\r\n(*demod_timeout) /= 2;\r\n}\r\nstatic void stv0900_set_viterbi_tracq(struct stv0900_internal *intp,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\ns32 vth_reg = VTH12;\r\ndprintk("%s\n", __func__);\r\nstv0900_write_reg(intp, vth_reg++, 0xd0);\r\nstv0900_write_reg(intp, vth_reg++, 0x7d);\r\nstv0900_write_reg(intp, vth_reg++, 0x53);\r\nstv0900_write_reg(intp, vth_reg++, 0x2f);\r\nstv0900_write_reg(intp, vth_reg++, 0x24);\r\nstv0900_write_reg(intp, vth_reg++, 0x1f);\r\n}\r\nstatic void stv0900_set_viterbi_standard(struct stv0900_internal *intp,\r\nenum fe_stv0900_search_standard standard,\r\nenum fe_stv0900_fec fec,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\ndprintk("%s: ViterbiStandard = ", __func__);\r\nswitch (standard) {\r\ncase STV0900_AUTO_SEARCH:\r\ndprintk("Auto\n");\r\nstv0900_write_reg(intp, FECM, 0x10);\r\nstv0900_write_reg(intp, PRVIT, 0x3f);\r\nbreak;\r\ncase STV0900_SEARCH_DVBS1:\r\ndprintk("DVBS1\n");\r\nstv0900_write_reg(intp, FECM, 0x00);\r\nswitch (fec) {\r\ncase STV0900_FEC_UNKNOWN:\r\ndefault:\r\nstv0900_write_reg(intp, PRVIT, 0x2f);\r\nbreak;\r\ncase STV0900_FEC_1_2:\r\nstv0900_write_reg(intp, PRVIT, 0x01);\r\nbreak;\r\ncase STV0900_FEC_2_3:\r\nstv0900_write_reg(intp, PRVIT, 0x02);\r\nbreak;\r\ncase STV0900_FEC_3_4:\r\nstv0900_write_reg(intp, PRVIT, 0x04);\r\nbreak;\r\ncase STV0900_FEC_5_6:\r\nstv0900_write_reg(intp, PRVIT, 0x08);\r\nbreak;\r\ncase STV0900_FEC_7_8:\r\nstv0900_write_reg(intp, PRVIT, 0x20);\r\nbreak;\r\n}\r\nbreak;\r\ncase STV0900_SEARCH_DSS:\r\ndprintk("DSS\n");\r\nstv0900_write_reg(intp, FECM, 0x80);\r\nswitch (fec) {\r\ncase STV0900_FEC_UNKNOWN:\r\ndefault:\r\nstv0900_write_reg(intp, PRVIT, 0x13);\r\nbreak;\r\ncase STV0900_FEC_1_2:\r\nstv0900_write_reg(intp, PRVIT, 0x01);\r\nbreak;\r\ncase STV0900_FEC_2_3:\r\nstv0900_write_reg(intp, PRVIT, 0x02);\r\nbreak;\r\ncase STV0900_FEC_6_7:\r\nstv0900_write_reg(intp, PRVIT, 0x10);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic enum fe_stv0900_fec stv0900_get_vit_fec(struct stv0900_internal *intp,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\nenum fe_stv0900_fec prate;\r\ns32 rate_fld = stv0900_get_bits(intp, VIT_CURPUN);\r\nswitch (rate_fld) {\r\ncase 13:\r\nprate = STV0900_FEC_1_2;\r\nbreak;\r\ncase 18:\r\nprate = STV0900_FEC_2_3;\r\nbreak;\r\ncase 21:\r\nprate = STV0900_FEC_3_4;\r\nbreak;\r\ncase 24:\r\nprate = STV0900_FEC_5_6;\r\nbreak;\r\ncase 25:\r\nprate = STV0900_FEC_6_7;\r\nbreak;\r\ncase 26:\r\nprate = STV0900_FEC_7_8;\r\nbreak;\r\ndefault:\r\nprate = STV0900_FEC_UNKNOWN;\r\nbreak;\r\n}\r\nreturn prate;\r\n}\r\nstatic void stv0900_set_dvbs1_track_car_loop(struct stv0900_internal *intp,\r\nenum fe_stv0900_demod_num demod,\r\nu32 srate)\r\n{\r\nif (intp->chip_id >= 0x30) {\r\nif (srate >= 15000000) {\r\nstv0900_write_reg(intp, ACLC, 0x2b);\r\nstv0900_write_reg(intp, BCLC, 0x1a);\r\n} else if ((srate >= 7000000) && (15000000 > srate)) {\r\nstv0900_write_reg(intp, ACLC, 0x0c);\r\nstv0900_write_reg(intp, BCLC, 0x1b);\r\n} else if (srate < 7000000) {\r\nstv0900_write_reg(intp, ACLC, 0x2c);\r\nstv0900_write_reg(intp, BCLC, 0x1c);\r\n}\r\n} else {\r\nstv0900_write_reg(intp, ACLC, 0x1a);\r\nstv0900_write_reg(intp, BCLC, 0x09);\r\n}\r\n}\r\nstatic void stv0900_track_optimization(struct dvb_frontend *fe)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nstruct stv0900_internal *intp = state->internal;\r\nenum fe_stv0900_demod_num demod = state->demod;\r\ns32 srate,\r\npilots,\r\naclc,\r\nfreq1,\r\nfreq0,\r\ni = 0,\r\ntimed,\r\ntimef,\r\nblind_tun_sw = 0,\r\nmodulation;\r\nenum fe_stv0900_modcode foundModcod;\r\ndprintk("%s\n", __func__);\r\nsrate = stv0900_get_symbol_rate(intp, intp->mclk, demod);\r\nsrate += stv0900_get_timing_offst(intp, srate, demod);\r\nswitch (intp->result[demod].standard) {\r\ncase STV0900_DVBS1_STANDARD:\r\ncase STV0900_DSS_STANDARD:\r\ndprintk("%s: found DVB-S or DSS\n", __func__);\r\nif (intp->srch_standard[demod] == STV0900_AUTO_SEARCH) {\r\nstv0900_write_bits(intp, DVBS1_ENABLE, 1);\r\nstv0900_write_bits(intp, DVBS2_ENABLE, 0);\r\n}\r\nstv0900_write_bits(intp, ROLLOFF_CONTROL, intp->rolloff);\r\nstv0900_write_bits(intp, MANUALSX_ROLLOFF, 1);\r\nif (intp->chip_id < 0x30) {\r\nstv0900_write_reg(intp, ERRCTRL1, 0x75);\r\nbreak;\r\n}\r\nif (stv0900_get_vit_fec(intp, demod) == STV0900_FEC_1_2) {\r\nstv0900_write_reg(intp, GAUSSR0, 0x98);\r\nstv0900_write_reg(intp, CCIR0, 0x18);\r\n} else {\r\nstv0900_write_reg(intp, GAUSSR0, 0x18);\r\nstv0900_write_reg(intp, CCIR0, 0x18);\r\n}\r\nstv0900_write_reg(intp, ERRCTRL1, 0x75);\r\nbreak;\r\ncase STV0900_DVBS2_STANDARD:\r\ndprintk("%s: found DVB-S2\n", __func__);\r\nstv0900_write_bits(intp, DVBS1_ENABLE, 0);\r\nstv0900_write_bits(intp, DVBS2_ENABLE, 1);\r\nstv0900_write_reg(intp, ACLC, 0);\r\nstv0900_write_reg(intp, BCLC, 0);\r\nif (intp->result[demod].frame_len == STV0900_LONG_FRAME) {\r\nfoundModcod = stv0900_get_bits(intp, DEMOD_MODCOD);\r\npilots = stv0900_get_bits(intp, DEMOD_TYPE) & 0x01;\r\naclc = stv0900_get_optim_carr_loop(srate,\r\nfoundModcod,\r\npilots,\r\nintp->chip_id);\r\nif (foundModcod <= STV0900_QPSK_910)\r\nstv0900_write_reg(intp, ACLC2S2Q, aclc);\r\nelse if (foundModcod <= STV0900_8PSK_910) {\r\nstv0900_write_reg(intp, ACLC2S2Q, 0x2a);\r\nstv0900_write_reg(intp, ACLC2S28, aclc);\r\n}\r\nif ((intp->demod_mode == STV0900_SINGLE) &&\r\n(foundModcod > STV0900_8PSK_910)) {\r\nif (foundModcod <= STV0900_16APSK_910) {\r\nstv0900_write_reg(intp, ACLC2S2Q, 0x2a);\r\nstv0900_write_reg(intp, ACLC2S216A,\r\naclc);\r\n} else if (foundModcod <= STV0900_32APSK_910) {\r\nstv0900_write_reg(intp, ACLC2S2Q, 0x2a);\r\nstv0900_write_reg(intp, ACLC2S232A,\r\naclc);\r\n}\r\n}\r\n} else {\r\nmodulation = intp->result[demod].modulation;\r\naclc = stv0900_get_optim_short_carr_loop(srate,\r\nmodulation, intp->chip_id);\r\nif (modulation == STV0900_QPSK)\r\nstv0900_write_reg(intp, ACLC2S2Q, aclc);\r\nelse if (modulation == STV0900_8PSK) {\r\nstv0900_write_reg(intp, ACLC2S2Q, 0x2a);\r\nstv0900_write_reg(intp, ACLC2S28, aclc);\r\n} else if (modulation == STV0900_16APSK) {\r\nstv0900_write_reg(intp, ACLC2S2Q, 0x2a);\r\nstv0900_write_reg(intp, ACLC2S216A, aclc);\r\n} else if (modulation == STV0900_32APSK) {\r\nstv0900_write_reg(intp, ACLC2S2Q, 0x2a);\r\nstv0900_write_reg(intp, ACLC2S232A, aclc);\r\n}\r\n}\r\nif (intp->chip_id <= 0x11) {\r\nif (intp->demod_mode != STV0900_SINGLE)\r\nstv0900_activate_s2_modcod(intp, demod);\r\n}\r\nstv0900_write_reg(intp, ERRCTRL1, 0x67);\r\nbreak;\r\ncase STV0900_UNKNOWN_STANDARD:\r\ndefault:\r\ndprintk("%s: found unknown standard\n", __func__);\r\nstv0900_write_bits(intp, DVBS1_ENABLE, 1);\r\nstv0900_write_bits(intp, DVBS2_ENABLE, 1);\r\nbreak;\r\n}\r\nfreq1 = stv0900_read_reg(intp, CFR2);\r\nfreq0 = stv0900_read_reg(intp, CFR1);\r\nif (intp->srch_algo[demod] == STV0900_BLIND_SEARCH) {\r\nstv0900_write_reg(intp, SFRSTEP, 0x00);\r\nstv0900_write_bits(intp, SCAN_ENABLE, 0);\r\nstv0900_write_bits(intp, CFR_AUTOSCAN, 0);\r\nstv0900_write_reg(intp, TMGCFG2, 0xc1);\r\nstv0900_set_symbol_rate(intp, intp->mclk, srate, demod);\r\nblind_tun_sw = 1;\r\nif (intp->result[demod].standard != STV0900_DVBS2_STANDARD)\r\nstv0900_set_dvbs1_track_car_loop(intp, demod, srate);\r\n}\r\nif (intp->chip_id >= 0x20) {\r\nif ((intp->srch_standard[demod] == STV0900_SEARCH_DVBS1) ||\r\n(intp->srch_standard[demod] ==\r\nSTV0900_SEARCH_DSS) ||\r\n(intp->srch_standard[demod] ==\r\nSTV0900_AUTO_SEARCH)) {\r\nstv0900_write_reg(intp, VAVSRVIT, 0x0a);\r\nstv0900_write_reg(intp, VITSCALE, 0x0);\r\n}\r\n}\r\nif (intp->chip_id < 0x20)\r\nstv0900_write_reg(intp, CARHDR, 0x08);\r\nif (intp->chip_id == 0x10)\r\nstv0900_write_reg(intp, CORRELEXP, 0x0a);\r\nstv0900_write_reg(intp, AGC2REF, 0x38);\r\nif ((intp->chip_id >= 0x20) ||\r\n(blind_tun_sw == 1) ||\r\n(intp->symbol_rate[demod] < 10000000)) {\r\nstv0900_write_reg(intp, CFRINIT1, freq1);\r\nstv0900_write_reg(intp, CFRINIT0, freq0);\r\nintp->bw[demod] = stv0900_carrier_width(srate,\r\nintp->rolloff) + 10000000;\r\nif ((intp->chip_id >= 0x20) || (blind_tun_sw == 1)) {\r\nif (intp->srch_algo[demod] != STV0900_WARM_START) {\r\nif (intp->tuner_type[demod] == 3)\r\nstv0900_set_tuner_auto(intp,\r\nintp->freq[demod],\r\nintp->bw[demod],\r\ndemod);\r\nelse\r\nstv0900_set_bandwidth(fe,\r\nintp->bw[demod]);\r\n}\r\n}\r\nif ((intp->srch_algo[demod] == STV0900_BLIND_SEARCH) ||\r\n(intp->symbol_rate[demod] < 10000000))\r\nmsleep(50);\r\nelse\r\nmsleep(5);\r\nstv0900_get_lock_timeout(&timed, &timef, srate,\r\nSTV0900_WARM_START);\r\nif (stv0900_get_demod_lock(intp, demod, timed / 2) == FALSE) {\r\nstv0900_write_reg(intp, DMDISTATE, 0x1f);\r\nstv0900_write_reg(intp, CFRINIT1, freq1);\r\nstv0900_write_reg(intp, CFRINIT0, freq0);\r\nstv0900_write_reg(intp, DMDISTATE, 0x18);\r\ni = 0;\r\nwhile ((stv0900_get_demod_lock(intp,\r\ndemod,\r\ntimed / 2) == FALSE) &&\r\n(i <= 2)) {\r\nstv0900_write_reg(intp, DMDISTATE, 0x1f);\r\nstv0900_write_reg(intp, CFRINIT1, freq1);\r\nstv0900_write_reg(intp, CFRINIT0, freq0);\r\nstv0900_write_reg(intp, DMDISTATE, 0x18);\r\ni++;\r\n}\r\n}\r\n}\r\nif (intp->chip_id >= 0x20)\r\nstv0900_write_reg(intp, CARFREQ, 0x49);\r\nif ((intp->result[demod].standard == STV0900_DVBS1_STANDARD) ||\r\n(intp->result[demod].standard == STV0900_DSS_STANDARD))\r\nstv0900_set_viterbi_tracq(intp, demod);\r\n}\r\nstatic int stv0900_get_fec_lock(struct stv0900_internal *intp,\r\nenum fe_stv0900_demod_num demod, s32 time_out)\r\n{\r\ns32 timer = 0, lock = 0;\r\nenum fe_stv0900_search_state dmd_state;\r\ndprintk("%s\n", __func__);\r\ndmd_state = stv0900_get_bits(intp, HEADER_MODE);\r\nwhile ((timer < time_out) && (lock == 0)) {\r\nswitch (dmd_state) {\r\ncase STV0900_SEARCH:\r\ncase STV0900_PLH_DETECTED:\r\ndefault:\r\nlock = 0;\r\nbreak;\r\ncase STV0900_DVBS2_FOUND:\r\nlock = stv0900_get_bits(intp, PKTDELIN_LOCK);\r\nbreak;\r\ncase STV0900_DVBS_FOUND:\r\nlock = stv0900_get_bits(intp, LOCKEDVIT);\r\nbreak;\r\n}\r\nif (lock == 0) {\r\nmsleep(10);\r\ntimer += 10;\r\n}\r\n}\r\nif (lock)\r\ndprintk("%s: DEMOD FEC LOCK OK\n", __func__);\r\nelse\r\ndprintk("%s: DEMOD FEC LOCK FAIL\n", __func__);\r\nreturn lock;\r\n}\r\nstatic int stv0900_wait_for_lock(struct stv0900_internal *intp,\r\nenum fe_stv0900_demod_num demod,\r\ns32 dmd_timeout, s32 fec_timeout)\r\n{\r\ns32 timer = 0, lock = 0;\r\ndprintk("%s\n", __func__);\r\nlock = stv0900_get_demod_lock(intp, demod, dmd_timeout);\r\nif (lock)\r\nlock = stv0900_get_fec_lock(intp, demod, fec_timeout);\r\nif (lock) {\r\nlock = 0;\r\ndprintk("%s: Timer = %d, time_out = %d\n",\r\n__func__, timer, fec_timeout);\r\nwhile ((timer < fec_timeout) && (lock == 0)) {\r\nlock = stv0900_get_bits(intp, TSFIFO_LINEOK);\r\nmsleep(1);\r\ntimer++;\r\n}\r\n}\r\nif (lock)\r\ndprintk("%s: DEMOD LOCK OK\n", __func__);\r\nelse\r\ndprintk("%s: DEMOD LOCK FAIL\n", __func__);\r\nif (lock)\r\nreturn TRUE;\r\nelse\r\nreturn FALSE;\r\n}\r\nenum fe_stv0900_tracking_standard stv0900_get_standard(struct dvb_frontend *fe,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nstruct stv0900_internal *intp = state->internal;\r\nenum fe_stv0900_tracking_standard fnd_standard;\r\nint hdr_mode = stv0900_get_bits(intp, HEADER_MODE);\r\nswitch (hdr_mode) {\r\ncase 2:\r\nfnd_standard = STV0900_DVBS2_STANDARD;\r\nbreak;\r\ncase 3:\r\nif (stv0900_get_bits(intp, DSS_DVB) == 1)\r\nfnd_standard = STV0900_DSS_STANDARD;\r\nelse\r\nfnd_standard = STV0900_DVBS1_STANDARD;\r\nbreak;\r\ndefault:\r\nfnd_standard = STV0900_UNKNOWN_STANDARD;\r\n}\r\ndprintk("%s: standard %d\n", __func__, fnd_standard);\r\nreturn fnd_standard;\r\n}\r\nstatic s32 stv0900_get_carr_freq(struct stv0900_internal *intp, u32 mclk,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\ns32 derot,\r\nrem1,\r\nrem2,\r\nintval1,\r\nintval2;\r\nderot = (stv0900_get_bits(intp, CAR_FREQ2) << 16) +\r\n(stv0900_get_bits(intp, CAR_FREQ1) << 8) +\r\n(stv0900_get_bits(intp, CAR_FREQ0));\r\nderot = ge2comp(derot, 24);\r\nintval1 = mclk >> 12;\r\nintval2 = derot >> 12;\r\nrem1 = mclk % 0x1000;\r\nrem2 = derot % 0x1000;\r\nderot = (intval1 * intval2) +\r\n((intval1 * rem2) >> 12) +\r\n((intval2 * rem1) >> 12);\r\nreturn derot;\r\n}\r\nstatic u32 stv0900_get_tuner_freq(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_frontend_ops *frontend_ops = NULL;\r\nstruct dvb_tuner_ops *tuner_ops = NULL;\r\nu32 freq = 0;\r\nfrontend_ops = &fe->ops;\r\ntuner_ops = &frontend_ops->tuner_ops;\r\nif (tuner_ops->get_frequency) {\r\nif ((tuner_ops->get_frequency(fe, &freq)) < 0)\r\ndprintk("%s: Invalid parameter\n", __func__);\r\nelse\r\ndprintk("%s: Frequency=%d\n", __func__, freq);\r\n}\r\nreturn freq;\r\n}\r\nstatic enum\r\nfe_stv0900_signal_type stv0900_get_signal_params(struct dvb_frontend *fe)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nstruct stv0900_internal *intp = state->internal;\r\nenum fe_stv0900_demod_num demod = state->demod;\r\nenum fe_stv0900_signal_type range = STV0900_OUTOFRANGE;\r\nstruct stv0900_signal_info *result = &intp->result[demod];\r\ns32 offsetFreq,\r\nsrate_offset;\r\nint i = 0,\r\nd = demod;\r\nu8 timing;\r\nmsleep(5);\r\nif (intp->srch_algo[d] == STV0900_BLIND_SEARCH) {\r\ntiming = stv0900_read_reg(intp, TMGREG2);\r\ni = 0;\r\nstv0900_write_reg(intp, SFRSTEP, 0x5c);\r\nwhile ((i <= 50) && (timing != 0) && (timing != 0xff)) {\r\ntiming = stv0900_read_reg(intp, TMGREG2);\r\nmsleep(5);\r\ni += 5;\r\n}\r\n}\r\nresult->standard = stv0900_get_standard(fe, d);\r\nif (intp->tuner_type[demod] == 3)\r\nresult->frequency = stv0900_get_freq_auto(intp, d);\r\nelse\r\nresult->frequency = stv0900_get_tuner_freq(fe);\r\noffsetFreq = stv0900_get_carr_freq(intp, intp->mclk, d) / 1000;\r\nresult->frequency += offsetFreq;\r\nresult->symbol_rate = stv0900_get_symbol_rate(intp, intp->mclk, d);\r\nsrate_offset = stv0900_get_timing_offst(intp, result->symbol_rate, d);\r\nresult->symbol_rate += srate_offset;\r\nresult->fec = stv0900_get_vit_fec(intp, d);\r\nresult->modcode = stv0900_get_bits(intp, DEMOD_MODCOD);\r\nresult->pilot = stv0900_get_bits(intp, DEMOD_TYPE) & 0x01;\r\nresult->frame_len = ((u32)stv0900_get_bits(intp, DEMOD_TYPE)) >> 1;\r\nresult->rolloff = stv0900_get_bits(intp, ROLLOFF_STATUS);\r\ndprintk("%s: modcode=0x%x \n", __func__, result->modcode);\r\nswitch (result->standard) {\r\ncase STV0900_DVBS2_STANDARD:\r\nresult->spectrum = stv0900_get_bits(intp, SPECINV_DEMOD);\r\nif (result->modcode <= STV0900_QPSK_910)\r\nresult->modulation = STV0900_QPSK;\r\nelse if (result->modcode <= STV0900_8PSK_910)\r\nresult->modulation = STV0900_8PSK;\r\nelse if (result->modcode <= STV0900_16APSK_910)\r\nresult->modulation = STV0900_16APSK;\r\nelse if (result->modcode <= STV0900_32APSK_910)\r\nresult->modulation = STV0900_32APSK;\r\nelse\r\nresult->modulation = STV0900_UNKNOWN;\r\nbreak;\r\ncase STV0900_DVBS1_STANDARD:\r\ncase STV0900_DSS_STANDARD:\r\nresult->spectrum = stv0900_get_bits(intp, IQINV);\r\nresult->modulation = STV0900_QPSK;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif ((intp->srch_algo[d] == STV0900_BLIND_SEARCH) ||\r\n(intp->symbol_rate[d] < 10000000)) {\r\noffsetFreq = result->frequency - intp->freq[d];\r\nif (intp->tuner_type[demod] == 3)\r\nintp->freq[d] = stv0900_get_freq_auto(intp, d);\r\nelse\r\nintp->freq[d] = stv0900_get_tuner_freq(fe);\r\nif (ABS(offsetFreq) <= ((intp->srch_range[d] / 2000) + 500))\r\nrange = STV0900_RANGEOK;\r\nelse if (ABS(offsetFreq) <=\r\n(stv0900_carrier_width(result->symbol_rate,\r\nresult->rolloff) / 2000))\r\nrange = STV0900_RANGEOK;\r\n} else if (ABS(offsetFreq) <= ((intp->srch_range[d] / 2000) + 500))\r\nrange = STV0900_RANGEOK;\r\ndprintk("%s: range %d\n", __func__, range);\r\nreturn range;\r\n}\r\nstatic enum\r\nfe_stv0900_signal_type stv0900_dvbs1_acq_workaround(struct dvb_frontend *fe)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nstruct stv0900_internal *intp = state->internal;\r\nenum fe_stv0900_demod_num demod = state->demod;\r\nenum fe_stv0900_signal_type signal_type = STV0900_NODATA;\r\ns32 srate,\r\ndemod_timeout,\r\nfec_timeout,\r\nfreq1,\r\nfreq0;\r\nintp->result[demod].locked = FALSE;\r\nif (stv0900_get_bits(intp, HEADER_MODE) == STV0900_DVBS_FOUND) {\r\nsrate = stv0900_get_symbol_rate(intp, intp->mclk, demod);\r\nsrate += stv0900_get_timing_offst(intp, srate, demod);\r\nif (intp->srch_algo[demod] == STV0900_BLIND_SEARCH)\r\nstv0900_set_symbol_rate(intp, intp->mclk, srate, demod);\r\nstv0900_get_lock_timeout(&demod_timeout, &fec_timeout,\r\nsrate, STV0900_WARM_START);\r\nfreq1 = stv0900_read_reg(intp, CFR2);\r\nfreq0 = stv0900_read_reg(intp, CFR1);\r\nstv0900_write_bits(intp, CFR_AUTOSCAN, 0);\r\nstv0900_write_bits(intp, SPECINV_CONTROL,\r\nSTV0900_IQ_FORCE_SWAPPED);\r\nstv0900_write_reg(intp, DMDISTATE, 0x1c);\r\nstv0900_write_reg(intp, CFRINIT1, freq1);\r\nstv0900_write_reg(intp, CFRINIT0, freq0);\r\nstv0900_write_reg(intp, DMDISTATE, 0x18);\r\nif (stv0900_wait_for_lock(intp, demod,\r\ndemod_timeout, fec_timeout) == TRUE) {\r\nintp->result[demod].locked = TRUE;\r\nsignal_type = stv0900_get_signal_params(fe);\r\nstv0900_track_optimization(fe);\r\n} else {\r\nstv0900_write_bits(intp, SPECINV_CONTROL,\r\nSTV0900_IQ_FORCE_NORMAL);\r\nstv0900_write_reg(intp, DMDISTATE, 0x1c);\r\nstv0900_write_reg(intp, CFRINIT1, freq1);\r\nstv0900_write_reg(intp, CFRINIT0, freq0);\r\nstv0900_write_reg(intp, DMDISTATE, 0x18);\r\nif (stv0900_wait_for_lock(intp, demod,\r\ndemod_timeout, fec_timeout) == TRUE) {\r\nintp->result[demod].locked = TRUE;\r\nsignal_type = stv0900_get_signal_params(fe);\r\nstv0900_track_optimization(fe);\r\n}\r\n}\r\n} else\r\nintp->result[demod].locked = FALSE;\r\nreturn signal_type;\r\n}\r\nstatic u16 stv0900_blind_check_agc2_min_level(struct stv0900_internal *intp,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\nu32 minagc2level = 0xffff,\r\nagc2level,\r\ninit_freq, freq_step;\r\ns32 i, j, nb_steps, direction;\r\ndprintk("%s\n", __func__);\r\nstv0900_write_reg(intp, AGC2REF, 0x38);\r\nstv0900_write_bits(intp, SCAN_ENABLE, 0);\r\nstv0900_write_bits(intp, CFR_AUTOSCAN, 0);\r\nstv0900_write_bits(intp, AUTO_GUP, 1);\r\nstv0900_write_bits(intp, AUTO_GLOW, 1);\r\nstv0900_write_reg(intp, DMDT0M, 0x0);\r\nstv0900_set_symbol_rate(intp, intp->mclk, 1000000, demod);\r\nnb_steps = -1 + (intp->srch_range[demod] / 1000000);\r\nnb_steps /= 2;\r\nnb_steps = (2 * nb_steps) + 1;\r\nif (nb_steps < 0)\r\nnb_steps = 1;\r\ndirection = 1;\r\nfreq_step = (1000000 << 8) / (intp->mclk >> 8);\r\ninit_freq = 0;\r\nfor (i = 0; i < nb_steps; i++) {\r\nif (direction > 0)\r\ninit_freq = init_freq + (freq_step * i);\r\nelse\r\ninit_freq = init_freq - (freq_step * i);\r\ndirection *= -1;\r\nstv0900_write_reg(intp, DMDISTATE, 0x5C);\r\nstv0900_write_reg(intp, CFRINIT1, (init_freq >> 8) & 0xff);\r\nstv0900_write_reg(intp, CFRINIT0, init_freq & 0xff);\r\nstv0900_write_reg(intp, DMDISTATE, 0x58);\r\nmsleep(10);\r\nagc2level = 0;\r\nfor (j = 0; j < 10; j++)\r\nagc2level += (stv0900_read_reg(intp, AGC2I1) << 8)\r\n| stv0900_read_reg(intp, AGC2I0);\r\nagc2level /= 10;\r\nif (agc2level < minagc2level)\r\nminagc2level = agc2level;\r\n}\r\nreturn (u16)minagc2level;\r\n}\r\nstatic u32 stv0900_search_srate_coarse(struct dvb_frontend *fe)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nstruct stv0900_internal *intp = state->internal;\r\nenum fe_stv0900_demod_num demod = state->demod;\r\nint timing_lck = FALSE;\r\ns32 i, timingcpt = 0,\r\ndirection = 1,\r\nnb_steps,\r\ncurrent_step = 0,\r\ntuner_freq;\r\nu32 agc2_th,\r\ncoarse_srate = 0,\r\nagc2_integr = 0,\r\ncurrier_step = 1200;\r\nif (intp->chip_id >= 0x30)\r\nagc2_th = 0x2e00;\r\nelse\r\nagc2_th = 0x1f00;\r\nstv0900_write_bits(intp, DEMOD_MODE, 0x1f);\r\nstv0900_write_reg(intp, TMGCFG, 0x12);\r\nstv0900_write_reg(intp, TMGTHRISE, 0xf0);\r\nstv0900_write_reg(intp, TMGTHFALL, 0xe0);\r\nstv0900_write_bits(intp, SCAN_ENABLE, 1);\r\nstv0900_write_bits(intp, CFR_AUTOSCAN, 1);\r\nstv0900_write_reg(intp, SFRUP1, 0x83);\r\nstv0900_write_reg(intp, SFRUP0, 0xc0);\r\nstv0900_write_reg(intp, SFRLOW1, 0x82);\r\nstv0900_write_reg(intp, SFRLOW0, 0xa0);\r\nstv0900_write_reg(intp, DMDT0M, 0x0);\r\nstv0900_write_reg(intp, AGC2REF, 0x50);\r\nif (intp->chip_id >= 0x30) {\r\nstv0900_write_reg(intp, CARFREQ, 0x99);\r\nstv0900_write_reg(intp, SFRSTEP, 0x98);\r\n} else if (intp->chip_id >= 0x20) {\r\nstv0900_write_reg(intp, CARFREQ, 0x6a);\r\nstv0900_write_reg(intp, SFRSTEP, 0x95);\r\n} else {\r\nstv0900_write_reg(intp, CARFREQ, 0xed);\r\nstv0900_write_reg(intp, SFRSTEP, 0x73);\r\n}\r\nif (intp->symbol_rate[demod] <= 2000000)\r\ncurrier_step = 1000;\r\nelse if (intp->symbol_rate[demod] <= 5000000)\r\ncurrier_step = 2000;\r\nelse if (intp->symbol_rate[demod] <= 12000000)\r\ncurrier_step = 3000;\r\nelse\r\ncurrier_step = 5000;\r\nnb_steps = -1 + ((intp->srch_range[demod] / 1000) / currier_step);\r\nnb_steps /= 2;\r\nnb_steps = (2 * nb_steps) + 1;\r\nif (nb_steps < 0)\r\nnb_steps = 1;\r\nelse if (nb_steps > 10) {\r\nnb_steps = 11;\r\ncurrier_step = (intp->srch_range[demod] / 1000) / 10;\r\n}\r\ncurrent_step = 0;\r\ndirection = 1;\r\ntuner_freq = intp->freq[demod];\r\nwhile ((timing_lck == FALSE) && (current_step < nb_steps)) {\r\nstv0900_write_reg(intp, DMDISTATE, 0x5f);\r\nstv0900_write_bits(intp, DEMOD_MODE, 0);\r\nmsleep(50);\r\nfor (i = 0; i < 10; i++) {\r\nif (stv0900_get_bits(intp, TMGLOCK_QUALITY) >= 2)\r\ntimingcpt++;\r\nagc2_integr += (stv0900_read_reg(intp, AGC2I1) << 8) |\r\nstv0900_read_reg(intp, AGC2I0);\r\n}\r\nagc2_integr /= 10;\r\ncoarse_srate = stv0900_get_symbol_rate(intp, intp->mclk, demod);\r\ncurrent_step++;\r\ndirection *= -1;\r\ndprintk("lock: I2C_DEMOD_MODE_FIELD =0. Search started."\r\n" tuner freq=%d agc2=0x%x srate_coarse=%d tmg_cpt=%d\n",\r\ntuner_freq, agc2_integr, coarse_srate, timingcpt);\r\nif ((timingcpt >= 5) &&\r\n(agc2_integr < agc2_th) &&\r\n(coarse_srate < 55000000) &&\r\n(coarse_srate > 850000))\r\ntiming_lck = TRUE;\r\nelse if (current_step < nb_steps) {\r\nif (direction > 0)\r\ntuner_freq += (current_step * currier_step);\r\nelse\r\ntuner_freq -= (current_step * currier_step);\r\nif (intp->tuner_type[demod] == 3)\r\nstv0900_set_tuner_auto(intp, tuner_freq,\r\nintp->bw[demod], demod);\r\nelse\r\nstv0900_set_tuner(fe, tuner_freq,\r\nintp->bw[demod]);\r\n}\r\n}\r\nif (timing_lck == FALSE)\r\ncoarse_srate = 0;\r\nelse\r\ncoarse_srate = stv0900_get_symbol_rate(intp, intp->mclk, demod);\r\nreturn coarse_srate;\r\n}\r\nstatic u32 stv0900_search_srate_fine(struct dvb_frontend *fe)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nstruct stv0900_internal *intp = state->internal;\r\nenum fe_stv0900_demod_num demod = state->demod;\r\nu32 coarse_srate,\r\ncoarse_freq,\r\nsymb,\r\nsymbmax,\r\nsymbmin,\r\nsymbcomp;\r\ncoarse_srate = stv0900_get_symbol_rate(intp, intp->mclk, demod);\r\nif (coarse_srate > 3000000) {\r\nsymbmax = 13 * (coarse_srate / 10);\r\nsymbmax = (symbmax / 1000) * 65536;\r\nsymbmax /= (intp->mclk / 1000);\r\nsymbmin = 10 * (coarse_srate / 13);\r\nsymbmin = (symbmin / 1000)*65536;\r\nsymbmin /= (intp->mclk / 1000);\r\nsymb = (coarse_srate / 1000) * 65536;\r\nsymb /= (intp->mclk / 1000);\r\n} else {\r\nsymbmax = 13 * (coarse_srate / 10);\r\nsymbmax = (symbmax / 100) * 65536;\r\nsymbmax /= (intp->mclk / 100);\r\nsymbmin = 10 * (coarse_srate / 14);\r\nsymbmin = (symbmin / 100) * 65536;\r\nsymbmin /= (intp->mclk / 100);\r\nsymb = (coarse_srate / 100) * 65536;\r\nsymb /= (intp->mclk / 100);\r\n}\r\nsymbcomp = 13 * (coarse_srate / 10);\r\ncoarse_freq = (stv0900_read_reg(intp, CFR2) << 8)\r\n| stv0900_read_reg(intp, CFR1);\r\nif (symbcomp < intp->symbol_rate[demod])\r\ncoarse_srate = 0;\r\nelse {\r\nstv0900_write_reg(intp, DMDISTATE, 0x1f);\r\nstv0900_write_reg(intp, TMGCFG2, 0xc1);\r\nstv0900_write_reg(intp, TMGTHRISE, 0x20);\r\nstv0900_write_reg(intp, TMGTHFALL, 0x00);\r\nstv0900_write_reg(intp, TMGCFG, 0xd2);\r\nstv0900_write_bits(intp, CFR_AUTOSCAN, 0);\r\nstv0900_write_reg(intp, AGC2REF, 0x38);\r\nif (intp->chip_id >= 0x30)\r\nstv0900_write_reg(intp, CARFREQ, 0x79);\r\nelse if (intp->chip_id >= 0x20)\r\nstv0900_write_reg(intp, CARFREQ, 0x49);\r\nelse\r\nstv0900_write_reg(intp, CARFREQ, 0xed);\r\nstv0900_write_reg(intp, SFRUP1, (symbmax >> 8) & 0x7f);\r\nstv0900_write_reg(intp, SFRUP0, (symbmax & 0xff));\r\nstv0900_write_reg(intp, SFRLOW1, (symbmin >> 8) & 0x7f);\r\nstv0900_write_reg(intp, SFRLOW0, (symbmin & 0xff));\r\nstv0900_write_reg(intp, SFRINIT1, (symb >> 8) & 0xff);\r\nstv0900_write_reg(intp, SFRINIT0, (symb & 0xff));\r\nstv0900_write_reg(intp, DMDT0M, 0x20);\r\nstv0900_write_reg(intp, CFRINIT1, (coarse_freq >> 8) & 0xff);\r\nstv0900_write_reg(intp, CFRINIT0, coarse_freq & 0xff);\r\nstv0900_write_reg(intp, DMDISTATE, 0x15);\r\n}\r\nreturn coarse_srate;\r\n}\r\nstatic int stv0900_blind_search_algo(struct dvb_frontend *fe)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nstruct stv0900_internal *intp = state->internal;\r\nenum fe_stv0900_demod_num demod = state->demod;\r\nu8 k_ref_tmg,\r\nk_ref_tmg_max,\r\nk_ref_tmg_min;\r\nu32 coarse_srate,\r\nagc2_th;\r\nint lock = FALSE,\r\ncoarse_fail = FALSE;\r\ns32 demod_timeout = 500,\r\nfec_timeout = 50,\r\nfail_cpt,\r\ni,\r\nagc2_overflow;\r\nu16 agc2_int;\r\nu8 dstatus2;\r\ndprintk("%s\n", __func__);\r\nif (intp->chip_id < 0x20) {\r\nk_ref_tmg_max = 233;\r\nk_ref_tmg_min = 143;\r\n} else {\r\nk_ref_tmg_max = 110;\r\nk_ref_tmg_min = 10;\r\n}\r\nif (intp->chip_id <= 0x20)\r\nagc2_th = STV0900_BLIND_SEARCH_AGC2_TH;\r\nelse\r\nagc2_th = STV0900_BLIND_SEARCH_AGC2_TH_CUT30;\r\nagc2_int = stv0900_blind_check_agc2_min_level(intp, demod);\r\ndprintk("%s agc2_int=%d agc2_th=%d \n", __func__, agc2_int, agc2_th);\r\nif (agc2_int > agc2_th)\r\nreturn FALSE;\r\nif (intp->chip_id == 0x10)\r\nstv0900_write_reg(intp, CORRELEXP, 0xaa);\r\nif (intp->chip_id < 0x20)\r\nstv0900_write_reg(intp, CARHDR, 0x55);\r\nelse\r\nstv0900_write_reg(intp, CARHDR, 0x20);\r\nif (intp->chip_id <= 0x20)\r\nstv0900_write_reg(intp, CARCFG, 0xc4);\r\nelse\r\nstv0900_write_reg(intp, CARCFG, 0x6);\r\nstv0900_write_reg(intp, RTCS2, 0x44);\r\nif (intp->chip_id >= 0x20) {\r\nstv0900_write_reg(intp, EQUALCFG, 0x41);\r\nstv0900_write_reg(intp, FFECFG, 0x41);\r\nstv0900_write_reg(intp, VITSCALE, 0x82);\r\nstv0900_write_reg(intp, VAVSRVIT, 0x0);\r\n}\r\nk_ref_tmg = k_ref_tmg_max;\r\ndo {\r\nstv0900_write_reg(intp, KREFTMG, k_ref_tmg);\r\nif (stv0900_search_srate_coarse(fe) != 0) {\r\ncoarse_srate = stv0900_search_srate_fine(fe);\r\nif (coarse_srate != 0) {\r\nstv0900_get_lock_timeout(&demod_timeout,\r\n&fec_timeout,\r\ncoarse_srate,\r\nSTV0900_BLIND_SEARCH);\r\nlock = stv0900_get_demod_lock(intp,\r\ndemod,\r\ndemod_timeout);\r\n} else\r\nlock = FALSE;\r\n} else {\r\nfail_cpt = 0;\r\nagc2_overflow = 0;\r\nfor (i = 0; i < 10; i++) {\r\nagc2_int = (stv0900_read_reg(intp, AGC2I1) << 8)\r\n| stv0900_read_reg(intp, AGC2I0);\r\nif (agc2_int >= 0xff00)\r\nagc2_overflow++;\r\ndstatus2 = stv0900_read_reg(intp, DSTATUS2);\r\nif (((dstatus2 & 0x1) == 0x1) &&\r\n((dstatus2 >> 7) == 1))\r\nfail_cpt++;\r\n}\r\nif ((fail_cpt > 7) || (agc2_overflow > 7))\r\ncoarse_fail = TRUE;\r\nlock = FALSE;\r\n}\r\nk_ref_tmg -= 30;\r\n} while ((k_ref_tmg >= k_ref_tmg_min) &&\r\n(lock == FALSE) &&\r\n(coarse_fail == FALSE));\r\nreturn lock;\r\n}\r\nstatic void stv0900_set_viterbi_acq(struct stv0900_internal *intp,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\ns32 vth_reg = VTH12;\r\ndprintk("%s\n", __func__);\r\nstv0900_write_reg(intp, vth_reg++, 0x96);\r\nstv0900_write_reg(intp, vth_reg++, 0x64);\r\nstv0900_write_reg(intp, vth_reg++, 0x36);\r\nstv0900_write_reg(intp, vth_reg++, 0x23);\r\nstv0900_write_reg(intp, vth_reg++, 0x1e);\r\nstv0900_write_reg(intp, vth_reg++, 0x19);\r\n}\r\nstatic void stv0900_set_search_standard(struct stv0900_internal *intp,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\ndprintk("%s\n", __func__);\r\nswitch (intp->srch_standard[demod]) {\r\ncase STV0900_SEARCH_DVBS1:\r\ndprintk("Search Standard = DVBS1\n");\r\nbreak;\r\ncase STV0900_SEARCH_DSS:\r\ndprintk("Search Standard = DSS\n");\r\ncase STV0900_SEARCH_DVBS2:\r\nbreak;\r\ndprintk("Search Standard = DVBS2\n");\r\ncase STV0900_AUTO_SEARCH:\r\ndefault:\r\ndprintk("Search Standard = AUTO\n");\r\nbreak;\r\n}\r\nswitch (intp->srch_standard[demod]) {\r\ncase STV0900_SEARCH_DVBS1:\r\ncase STV0900_SEARCH_DSS:\r\nstv0900_write_bits(intp, DVBS1_ENABLE, 1);\r\nstv0900_write_bits(intp, DVBS2_ENABLE, 0);\r\nstv0900_write_bits(intp, STOP_CLKVIT, 0);\r\nstv0900_set_dvbs1_track_car_loop(intp,\r\ndemod,\r\nintp->symbol_rate[demod]);\r\nstv0900_write_reg(intp, CAR2CFG, 0x22);\r\nstv0900_set_viterbi_acq(intp, demod);\r\nstv0900_set_viterbi_standard(intp,\r\nintp->srch_standard[demod],\r\nintp->fec[demod], demod);\r\nbreak;\r\ncase STV0900_SEARCH_DVBS2:\r\nstv0900_write_bits(intp, DVBS1_ENABLE, 0);\r\nstv0900_write_bits(intp, DVBS2_ENABLE, 1);\r\nstv0900_write_bits(intp, STOP_CLKVIT, 1);\r\nstv0900_write_reg(intp, ACLC, 0x1a);\r\nstv0900_write_reg(intp, BCLC, 0x09);\r\nif (intp->chip_id <= 0x20)\r\nstv0900_write_reg(intp, CAR2CFG, 0x26);\r\nelse\r\nstv0900_write_reg(intp, CAR2CFG, 0x66);\r\nif (intp->demod_mode != STV0900_SINGLE) {\r\nif (intp->chip_id <= 0x11)\r\nstv0900_stop_all_s2_modcod(intp, demod);\r\nelse\r\nstv0900_activate_s2_modcod(intp, demod);\r\n} else\r\nstv0900_activate_s2_modcod_single(intp, demod);\r\nstv0900_set_viterbi_tracq(intp, demod);\r\nbreak;\r\ncase STV0900_AUTO_SEARCH:\r\ndefault:\r\nstv0900_write_bits(intp, DVBS1_ENABLE, 1);\r\nstv0900_write_bits(intp, DVBS2_ENABLE, 1);\r\nstv0900_write_bits(intp, STOP_CLKVIT, 0);\r\nstv0900_write_reg(intp, ACLC, 0x1a);\r\nstv0900_write_reg(intp, BCLC, 0x09);\r\nstv0900_set_dvbs1_track_car_loop(intp,\r\ndemod,\r\nintp->symbol_rate[demod]);\r\nif (intp->chip_id <= 0x20)\r\nstv0900_write_reg(intp, CAR2CFG, 0x26);\r\nelse\r\nstv0900_write_reg(intp, CAR2CFG, 0x66);\r\nif (intp->demod_mode != STV0900_SINGLE) {\r\nif (intp->chip_id <= 0x11)\r\nstv0900_stop_all_s2_modcod(intp, demod);\r\nelse\r\nstv0900_activate_s2_modcod(intp, demod);\r\n} else\r\nstv0900_activate_s2_modcod_single(intp, demod);\r\nstv0900_set_viterbi_tracq(intp, demod);\r\nstv0900_set_viterbi_standard(intp,\r\nintp->srch_standard[demod],\r\nintp->fec[demod], demod);\r\nbreak;\r\n}\r\n}\r\nenum fe_stv0900_signal_type stv0900_algo(struct dvb_frontend *fe)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nstruct stv0900_internal *intp = state->internal;\r\nenum fe_stv0900_demod_num demod = state->demod;\r\ns32 demod_timeout = 500, fec_timeout = 50;\r\ns32 aq_power, agc1_power, i;\r\nint lock = FALSE, low_sr = FALSE;\r\nenum fe_stv0900_signal_type signal_type = STV0900_NOCARRIER;\r\nenum fe_stv0900_search_algo algo;\r\nint no_signal = FALSE;\r\ndprintk("%s\n", __func__);\r\nalgo = intp->srch_algo[demod];\r\nstv0900_write_bits(intp, RST_HWARE, 1);\r\nstv0900_write_reg(intp, DMDISTATE, 0x5c);\r\nif (intp->chip_id >= 0x20) {\r\nif (intp->symbol_rate[demod] > 5000000)\r\nstv0900_write_reg(intp, CORRELABS, 0x9e);\r\nelse\r\nstv0900_write_reg(intp, CORRELABS, 0x82);\r\n} else\r\nstv0900_write_reg(intp, CORRELABS, 0x88);\r\nstv0900_get_lock_timeout(&demod_timeout, &fec_timeout,\r\nintp->symbol_rate[demod],\r\nintp->srch_algo[demod]);\r\nif (intp->srch_algo[demod] == STV0900_BLIND_SEARCH) {\r\nintp->bw[demod] = 2 * 36000000;\r\nstv0900_write_reg(intp, TMGCFG2, 0xc0);\r\nstv0900_write_reg(intp, CORRELMANT, 0x70);\r\nstv0900_set_symbol_rate(intp, intp->mclk, 1000000, demod);\r\n} else {\r\nstv0900_write_reg(intp, DMDT0M, 0x20);\r\nstv0900_write_reg(intp, TMGCFG, 0xd2);\r\nif (intp->symbol_rate[demod] < 2000000)\r\nstv0900_write_reg(intp, CORRELMANT, 0x63);\r\nelse\r\nstv0900_write_reg(intp, CORRELMANT, 0x70);\r\nstv0900_write_reg(intp, AGC2REF, 0x38);\r\nintp->bw[demod] =\r\nstv0900_carrier_width(intp->symbol_rate[demod],\r\nintp->rolloff);\r\nif (intp->chip_id >= 0x20) {\r\nstv0900_write_reg(intp, KREFTMG, 0x5a);\r\nif (intp->srch_algo[demod] == STV0900_COLD_START) {\r\nintp->bw[demod] += 10000000;\r\nintp->bw[demod] *= 15;\r\nintp->bw[demod] /= 10;\r\n} else if (intp->srch_algo[demod] == STV0900_WARM_START)\r\nintp->bw[demod] += 10000000;\r\n} else {\r\nstv0900_write_reg(intp, KREFTMG, 0xc1);\r\nintp->bw[demod] += 10000000;\r\nintp->bw[demod] *= 15;\r\nintp->bw[demod] /= 10;\r\n}\r\nstv0900_write_reg(intp, TMGCFG2, 0xc1);\r\nstv0900_set_symbol_rate(intp, intp->mclk,\r\nintp->symbol_rate[demod], demod);\r\nstv0900_set_max_symbol_rate(intp, intp->mclk,\r\nintp->symbol_rate[demod], demod);\r\nstv0900_set_min_symbol_rate(intp, intp->mclk,\r\nintp->symbol_rate[demod], demod);\r\nif (intp->symbol_rate[demod] >= 10000000)\r\nlow_sr = FALSE;\r\nelse\r\nlow_sr = TRUE;\r\n}\r\nif (intp->tuner_type[demod] == 3)\r\nstv0900_set_tuner_auto(intp, intp->freq[demod],\r\nintp->bw[demod], demod);\r\nelse\r\nstv0900_set_tuner(fe, intp->freq[demod], intp->bw[demod]);\r\nagc1_power = MAKEWORD(stv0900_get_bits(intp, AGCIQ_VALUE1),\r\nstv0900_get_bits(intp, AGCIQ_VALUE0));\r\naq_power = 0;\r\nif (agc1_power == 0) {\r\nfor (i = 0; i < 5; i++)\r\naq_power += (stv0900_get_bits(intp, POWER_I) +\r\nstv0900_get_bits(intp, POWER_Q)) / 2;\r\naq_power /= 5;\r\n}\r\nif ((agc1_power == 0) && (aq_power < IQPOWER_THRESHOLD)) {\r\nintp->result[demod].locked = FALSE;\r\nsignal_type = STV0900_NOAGC1;\r\ndprintk("%s: NO AGC1, POWERI, POWERQ\n", __func__);\r\n} else {\r\nstv0900_write_bits(intp, SPECINV_CONTROL,\r\nintp->srch_iq_inv[demod]);\r\nif (intp->chip_id <= 0x20)\r\nstv0900_write_bits(intp, MANUALSX_ROLLOFF, 1);\r\nelse\r\nstv0900_write_bits(intp, MANUALS2_ROLLOFF, 1);\r\nstv0900_set_search_standard(intp, demod);\r\nif (intp->srch_algo[demod] != STV0900_BLIND_SEARCH)\r\nstv0900_start_search(intp, demod);\r\n}\r\nif (signal_type == STV0900_NOAGC1)\r\nreturn signal_type;\r\nif (intp->chip_id == 0x12) {\r\nstv0900_write_bits(intp, RST_HWARE, 0);\r\nmsleep(3);\r\nstv0900_write_bits(intp, RST_HWARE, 1);\r\nstv0900_write_bits(intp, RST_HWARE, 0);\r\n}\r\nif (algo == STV0900_BLIND_SEARCH)\r\nlock = stv0900_blind_search_algo(fe);\r\nelse if (algo == STV0900_COLD_START)\r\nlock = stv0900_get_demod_cold_lock(fe, demod_timeout);\r\nelse if (algo == STV0900_WARM_START)\r\nlock = stv0900_get_demod_lock(intp, demod, demod_timeout);\r\nif ((lock == FALSE) && (algo == STV0900_COLD_START)) {\r\nif (low_sr == FALSE) {\r\nif (stv0900_check_timing_lock(intp, demod) == TRUE)\r\nlock = stv0900_sw_algo(intp, demod);\r\n}\r\n}\r\nif (lock == TRUE)\r\nsignal_type = stv0900_get_signal_params(fe);\r\nif ((lock == TRUE) && (signal_type == STV0900_RANGEOK)) {\r\nstv0900_track_optimization(fe);\r\nif (intp->chip_id <= 0x11) {\r\nif ((stv0900_get_standard(fe, 0) ==\r\nSTV0900_DVBS1_STANDARD) &&\r\n(stv0900_get_standard(fe, 1) ==\r\nSTV0900_DVBS1_STANDARD)) {\r\nmsleep(20);\r\nstv0900_write_bits(intp, RST_HWARE, 0);\r\n} else {\r\nstv0900_write_bits(intp, RST_HWARE, 0);\r\nmsleep(3);\r\nstv0900_write_bits(intp, RST_HWARE, 1);\r\nstv0900_write_bits(intp, RST_HWARE, 0);\r\n}\r\n} else if (intp->chip_id >= 0x20) {\r\nstv0900_write_bits(intp, RST_HWARE, 0);\r\nmsleep(3);\r\nstv0900_write_bits(intp, RST_HWARE, 1);\r\nstv0900_write_bits(intp, RST_HWARE, 0);\r\n}\r\nif (stv0900_wait_for_lock(intp, demod,\r\nfec_timeout, fec_timeout) == TRUE) {\r\nlock = TRUE;\r\nintp->result[demod].locked = TRUE;\r\nif (intp->result[demod].standard ==\r\nSTV0900_DVBS2_STANDARD) {\r\nstv0900_set_dvbs2_rolloff(intp, demod);\r\nstv0900_write_bits(intp, RESET_UPKO_COUNT, 1);\r\nstv0900_write_bits(intp, RESET_UPKO_COUNT, 0);\r\nstv0900_write_reg(intp, ERRCTRL1, 0x67);\r\n} else {\r\nstv0900_write_reg(intp, ERRCTRL1, 0x75);\r\n}\r\nstv0900_write_reg(intp, FBERCPT4, 0);\r\nstv0900_write_reg(intp, ERRCTRL2, 0xc1);\r\n} else {\r\nlock = FALSE;\r\nsignal_type = STV0900_NODATA;\r\nno_signal = stv0900_check_signal_presence(intp, demod);\r\nintp->result[demod].locked = FALSE;\r\n}\r\n}\r\nif ((signal_type != STV0900_NODATA) || (no_signal != FALSE))\r\nreturn signal_type;\r\nif (intp->chip_id > 0x11) {\r\nintp->result[demod].locked = FALSE;\r\nreturn signal_type;\r\n}\r\nif ((stv0900_get_bits(intp, HEADER_MODE) == STV0900_DVBS_FOUND) &&\r\n(intp->srch_iq_inv[demod] <= STV0900_IQ_AUTO_NORMAL_FIRST))\r\nsignal_type = stv0900_dvbs1_acq_workaround(fe);\r\nreturn signal_type;\r\n}
