static int lz4_uncompress(const char *source, char *dest, int osize)\r\n{\r\nconst BYTE *ip = (const BYTE *) source;\r\nconst BYTE *ref;\r\nBYTE *op = (BYTE *) dest;\r\nBYTE * const oend = op + osize;\r\nBYTE *cpy;\r\nunsigned token;\r\nsize_t length;\r\nsize_t dec32table[] = {0, 3, 2, 3, 0, 0, 0, 0};\r\n#if LZ4_ARCH64\r\nsize_t dec64table[] = {0, 0, 0, -1, 0, 1, 2, 3};\r\n#endif\r\nwhile (1) {\r\ntoken = *ip++;\r\nlength = (token >> ML_BITS);\r\nif (length == RUN_MASK) {\r\nsize_t len;\r\nlen = *ip++;\r\nfor (; len == 255; length += 255)\r\nlen = *ip++;\r\nif (unlikely(length > (size_t)(length + len)))\r\ngoto _output_error;\r\nlength += len;\r\n}\r\ncpy = op + length;\r\nif (unlikely(cpy > oend - COPYLENGTH)) {\r\nif (cpy != oend)\r\ngoto _output_error;\r\nmemcpy(op, ip, length);\r\nip += length;\r\nbreak;\r\n}\r\nLZ4_WILDCOPY(ip, op, cpy);\r\nip -= (op - cpy);\r\nop = cpy;\r\nLZ4_READ_LITTLEENDIAN_16(ref, cpy, ip);\r\nip += 2;\r\nif (unlikely(ref < (BYTE *const) dest))\r\ngoto _output_error;\r\nlength = token & ML_MASK;\r\nif (length == ML_MASK) {\r\nfor (; *ip == 255; length += 255)\r\nip++;\r\nif (unlikely(length > (size_t)(length + *ip)))\r\ngoto _output_error;\r\nlength += *ip++;\r\n}\r\nif (unlikely((op - ref) < STEPSIZE)) {\r\n#if LZ4_ARCH64\r\nsize_t dec64 = dec64table[op - ref];\r\n#else\r\nconst int dec64 = 0;\r\n#endif\r\nop[0] = ref[0];\r\nop[1] = ref[1];\r\nop[2] = ref[2];\r\nop[3] = ref[3];\r\nop += 4;\r\nref += 4;\r\nref -= dec32table[op-ref];\r\nPUT4(ref, op);\r\nop += STEPSIZE - 4;\r\nref -= dec64;\r\n} else {\r\nLZ4_COPYSTEP(ref, op);\r\n}\r\ncpy = op + length - (STEPSIZE - 4);\r\nif (cpy > (oend - COPYLENGTH)) {\r\nif (cpy > oend)\r\ngoto _output_error;\r\nLZ4_SECURECOPY(ref, op, (oend - COPYLENGTH));\r\nwhile (op < cpy)\r\n*op++ = *ref++;\r\nop = cpy;\r\nif (op == oend)\r\ngoto _output_error;\r\ncontinue;\r\n}\r\nLZ4_SECURECOPY(ref, op, cpy);\r\nop = cpy;\r\n}\r\nreturn (int) (((char *)ip) - source);\r\n_output_error:\r\nreturn -1;\r\n}\r\nstatic int lz4_uncompress_unknownoutputsize(const char *source, char *dest,\r\nint isize, size_t maxoutputsize)\r\n{\r\nconst BYTE *ip = (const BYTE *) source;\r\nconst BYTE *const iend = ip + isize;\r\nconst BYTE *ref;\r\nBYTE *op = (BYTE *) dest;\r\nBYTE * const oend = op + maxoutputsize;\r\nBYTE *cpy;\r\nsize_t dec32table[] = {0, 3, 2, 3, 0, 0, 0, 0};\r\n#if LZ4_ARCH64\r\nsize_t dec64table[] = {0, 0, 0, -1, 0, 1, 2, 3};\r\n#endif\r\nwhile (ip < iend) {\r\nunsigned token;\r\nsize_t length;\r\ntoken = *ip++;\r\nlength = (token >> ML_BITS);\r\nif (length == RUN_MASK) {\r\nint s = 255;\r\nwhile ((ip < iend) && (s == 255)) {\r\ns = *ip++;\r\nif (unlikely(length > (size_t)(length + s)))\r\ngoto _output_error;\r\nlength += s;\r\n}\r\n}\r\ncpy = op + length;\r\nif ((cpy > oend - COPYLENGTH) ||\r\n(ip + length > iend - COPYLENGTH)) {\r\nif (cpy > oend)\r\ngoto _output_error;\r\nif (ip + length != iend)\r\ngoto _output_error;\r\nmemcpy(op, ip, length);\r\nop += length;\r\nbreak;\r\n}\r\nLZ4_WILDCOPY(ip, op, cpy);\r\nip -= (op - cpy);\r\nop = cpy;\r\nLZ4_READ_LITTLEENDIAN_16(ref, cpy, ip);\r\nip += 2;\r\nif (ref < (BYTE * const) dest)\r\ngoto _output_error;\r\nlength = (token & ML_MASK);\r\nif (length == ML_MASK) {\r\nwhile (ip < iend) {\r\nint s = *ip++;\r\nif (unlikely(length > (size_t)(length + s)))\r\ngoto _output_error;\r\nlength += s;\r\nif (s == 255)\r\ncontinue;\r\nbreak;\r\n}\r\n}\r\nif (unlikely((op - ref) < STEPSIZE)) {\r\n#if LZ4_ARCH64\r\nsize_t dec64 = dec64table[op - ref];\r\n#else\r\nconst int dec64 = 0;\r\n#endif\r\nop[0] = ref[0];\r\nop[1] = ref[1];\r\nop[2] = ref[2];\r\nop[3] = ref[3];\r\nop += 4;\r\nref += 4;\r\nref -= dec32table[op - ref];\r\nPUT4(ref, op);\r\nop += STEPSIZE - 4;\r\nref -= dec64;\r\n} else {\r\nLZ4_COPYSTEP(ref, op);\r\n}\r\ncpy = op + length - (STEPSIZE-4);\r\nif (cpy > oend - COPYLENGTH) {\r\nif (cpy > oend)\r\ngoto _output_error;\r\nLZ4_SECURECOPY(ref, op, (oend - COPYLENGTH));\r\nwhile (op < cpy)\r\n*op++ = *ref++;\r\nop = cpy;\r\nif (op == oend)\r\ngoto _output_error;\r\ncontinue;\r\n}\r\nLZ4_SECURECOPY(ref, op, cpy);\r\nop = cpy;\r\n}\r\nreturn (int) (((char *) op) - dest);\r\n_output_error:\r\nreturn -1;\r\n}\r\nint lz4_decompress(const unsigned char *src, size_t *src_len,\r\nunsigned char *dest, size_t actual_dest_len)\r\n{\r\nint ret = -1;\r\nint input_len = 0;\r\ninput_len = lz4_uncompress(src, dest, actual_dest_len);\r\nif (input_len < 0)\r\ngoto exit_0;\r\n*src_len = input_len;\r\nreturn 0;\r\nexit_0:\r\nreturn ret;\r\n}\r\nint lz4_decompress_unknownoutputsize(const unsigned char *src, size_t src_len,\r\nunsigned char *dest, size_t *dest_len)\r\n{\r\nint ret = -1;\r\nint out_len = 0;\r\nout_len = lz4_uncompress_unknownoutputsize(src, dest, src_len,\r\n*dest_len);\r\nif (out_len < 0)\r\ngoto exit_0;\r\n*dest_len = out_len;\r\nreturn 0;\r\nexit_0:\r\nreturn ret;\r\n}
