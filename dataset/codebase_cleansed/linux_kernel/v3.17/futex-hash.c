static void *workerfn(void *arg)\r\n{\r\nint ret;\r\nunsigned int i;\r\nstruct worker *w = (struct worker *) arg;\r\npthread_mutex_lock(&thread_lock);\r\nthreads_starting--;\r\nif (!threads_starting)\r\npthread_cond_signal(&thread_parent);\r\npthread_cond_wait(&thread_worker, &thread_lock);\r\npthread_mutex_unlock(&thread_lock);\r\ndo {\r\nfor (i = 0; i < nfutexes; i++, w->ops++) {\r\nret = futex_wait(&w->futex[i], 1234, NULL,\r\nfshared ? 0 : FUTEX_PRIVATE_FLAG);\r\nif (!silent &&\r\n(!ret || errno != EAGAIN || errno != EWOULDBLOCK))\r\nwarn("Non-expected futex return call");\r\n}\r\n} while (!done);\r\nreturn NULL;\r\n}\r\nstatic void toggle_done(int sig __maybe_unused,\r\nsiginfo_t *info __maybe_unused,\r\nvoid *uc __maybe_unused)\r\n{\r\ndone = true;\r\ngettimeofday(&end, NULL);\r\ntimersub(&end, &start, &runtime);\r\n}\r\nstatic void print_summary(void)\r\n{\r\nunsigned long avg = avg_stats(&throughput_stats);\r\ndouble stddev = stddev_stats(&throughput_stats);\r\nprintf("%sAveraged %ld operations/sec (+- %.2f%%), total secs = %d\n",\r\n!silent ? "\n" : "", avg, rel_stddev_stats(stddev, avg),\r\n(int) runtime.tv_sec);\r\n}\r\nint bench_futex_hash(int argc, const char **argv,\r\nconst char *prefix __maybe_unused)\r\n{\r\nint ret = 0;\r\ncpu_set_t cpu;\r\nstruct sigaction act;\r\nunsigned int i, ncpus;\r\npthread_attr_t thread_attr;\r\nstruct worker *worker = NULL;\r\nargc = parse_options(argc, argv, options, bench_futex_hash_usage, 0);\r\nif (argc) {\r\nusage_with_options(bench_futex_hash_usage, options);\r\nexit(EXIT_FAILURE);\r\n}\r\nncpus = sysconf(_SC_NPROCESSORS_ONLN);\r\nsigfillset(&act.sa_mask);\r\nact.sa_sigaction = toggle_done;\r\nsigaction(SIGINT, &act, NULL);\r\nif (!nthreads)\r\nnthreads = ncpus;\r\nworker = calloc(nthreads, sizeof(*worker));\r\nif (!worker)\r\ngoto errmem;\r\nprintf("Run summary [PID %d]: %d threads, each operating on %d [%s] futexes for %d secs.\n\n",\r\ngetpid(), nthreads, nfutexes, fshared ? "shared":"private", nsecs);\r\ninit_stats(&throughput_stats);\r\npthread_mutex_init(&thread_lock, NULL);\r\npthread_cond_init(&thread_parent, NULL);\r\npthread_cond_init(&thread_worker, NULL);\r\nthreads_starting = nthreads;\r\npthread_attr_init(&thread_attr);\r\ngettimeofday(&start, NULL);\r\nfor (i = 0; i < nthreads; i++) {\r\nworker[i].tid = i;\r\nworker[i].futex = calloc(nfutexes, sizeof(*worker[i].futex));\r\nif (!worker[i].futex)\r\ngoto errmem;\r\nCPU_ZERO(&cpu);\r\nCPU_SET(i % ncpus, &cpu);\r\nret = pthread_attr_setaffinity_np(&thread_attr, sizeof(cpu_set_t), &cpu);\r\nif (ret)\r\nerr(EXIT_FAILURE, "pthread_attr_setaffinity_np");\r\nret = pthread_create(&worker[i].thread, &thread_attr, workerfn,\r\n(void *)(struct worker *) &worker[i]);\r\nif (ret)\r\nerr(EXIT_FAILURE, "pthread_create");\r\n}\r\npthread_attr_destroy(&thread_attr);\r\npthread_mutex_lock(&thread_lock);\r\nwhile (threads_starting)\r\npthread_cond_wait(&thread_parent, &thread_lock);\r\npthread_cond_broadcast(&thread_worker);\r\npthread_mutex_unlock(&thread_lock);\r\nsleep(nsecs);\r\ntoggle_done(0, NULL, NULL);\r\nfor (i = 0; i < nthreads; i++) {\r\nret = pthread_join(worker[i].thread, NULL);\r\nif (ret)\r\nerr(EXIT_FAILURE, "pthread_join");\r\n}\r\npthread_cond_destroy(&thread_parent);\r\npthread_cond_destroy(&thread_worker);\r\npthread_mutex_destroy(&thread_lock);\r\nfor (i = 0; i < nthreads; i++) {\r\nunsigned long t = worker[i].ops/runtime.tv_sec;\r\nupdate_stats(&throughput_stats, t);\r\nif (!silent) {\r\nif (nfutexes == 1)\r\nprintf("[thread %2d] futex: %p [ %ld ops/sec ]\n",\r\nworker[i].tid, &worker[i].futex[0], t);\r\nelse\r\nprintf("[thread %2d] futexes: %p ... %p [ %ld ops/sec ]\n",\r\nworker[i].tid, &worker[i].futex[0],\r\n&worker[i].futex[nfutexes-1], t);\r\n}\r\nfree(worker[i].futex);\r\n}\r\nprint_summary();\r\nfree(worker);\r\nreturn ret;\r\nerrmem:\r\nerr(EXIT_FAILURE, "calloc");\r\n}
