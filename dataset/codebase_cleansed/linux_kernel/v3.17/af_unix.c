static struct hlist_head *unix_sockets_unbound(void *addr)\r\n{\r\nunsigned long hash = (unsigned long)addr;\r\nhash ^= hash >> 16;\r\nhash ^= hash >> 8;\r\nhash %= UNIX_HASH_SIZE;\r\nreturn &unix_socket_table[UNIX_HASH_SIZE + hash];\r\n}\r\nstatic void unix_get_secdata(struct scm_cookie *scm, struct sk_buff *skb)\r\n{\r\nmemcpy(UNIXSID(skb), &scm->secid, sizeof(u32));\r\n}\r\nstatic inline void unix_set_secdata(struct scm_cookie *scm, struct sk_buff *skb)\r\n{\r\nscm->secid = *UNIXSID(skb);\r\n}\r\nstatic inline void unix_get_secdata(struct scm_cookie *scm, struct sk_buff *skb)\r\n{ }\r\nstatic inline void unix_set_secdata(struct scm_cookie *scm, struct sk_buff *skb)\r\n{ }\r\nstatic inline unsigned int unix_hash_fold(__wsum n)\r\n{\r\nunsigned int hash = (__force unsigned int)csum_fold(n);\r\nhash ^= hash>>8;\r\nreturn hash&(UNIX_HASH_SIZE-1);\r\n}\r\nstatic inline int unix_our_peer(struct sock *sk, struct sock *osk)\r\n{\r\nreturn unix_peer(osk) == sk;\r\n}\r\nstatic inline int unix_may_send(struct sock *sk, struct sock *osk)\r\n{\r\nreturn unix_peer(osk) == NULL || unix_our_peer(sk, osk);\r\n}\r\nstatic inline int unix_recvq_full(struct sock const *sk)\r\n{\r\nreturn skb_queue_len(&sk->sk_receive_queue) > sk->sk_max_ack_backlog;\r\n}\r\nstruct sock *unix_peer_get(struct sock *s)\r\n{\r\nstruct sock *peer;\r\nunix_state_lock(s);\r\npeer = unix_peer(s);\r\nif (peer)\r\nsock_hold(peer);\r\nunix_state_unlock(s);\r\nreturn peer;\r\n}\r\nstatic inline void unix_release_addr(struct unix_address *addr)\r\n{\r\nif (atomic_dec_and_test(&addr->refcnt))\r\nkfree(addr);\r\n}\r\nstatic int unix_mkname(struct sockaddr_un *sunaddr, int len, unsigned int *hashp)\r\n{\r\nif (len <= sizeof(short) || len > sizeof(*sunaddr))\r\nreturn -EINVAL;\r\nif (!sunaddr || sunaddr->sun_family != AF_UNIX)\r\nreturn -EINVAL;\r\nif (sunaddr->sun_path[0]) {\r\n((char *)sunaddr)[len] = 0;\r\nlen = strlen(sunaddr->sun_path)+1+sizeof(short);\r\nreturn len;\r\n}\r\n*hashp = unix_hash_fold(csum_partial(sunaddr, len, 0));\r\nreturn len;\r\n}\r\nstatic void __unix_remove_socket(struct sock *sk)\r\n{\r\nsk_del_node_init(sk);\r\n}\r\nstatic void __unix_insert_socket(struct hlist_head *list, struct sock *sk)\r\n{\r\nWARN_ON(!sk_unhashed(sk));\r\nsk_add_node(sk, list);\r\n}\r\nstatic inline void unix_remove_socket(struct sock *sk)\r\n{\r\nspin_lock(&unix_table_lock);\r\n__unix_remove_socket(sk);\r\nspin_unlock(&unix_table_lock);\r\n}\r\nstatic inline void unix_insert_socket(struct hlist_head *list, struct sock *sk)\r\n{\r\nspin_lock(&unix_table_lock);\r\n__unix_insert_socket(list, sk);\r\nspin_unlock(&unix_table_lock);\r\n}\r\nstatic struct sock *__unix_find_socket_byname(struct net *net,\r\nstruct sockaddr_un *sunname,\r\nint len, int type, unsigned int hash)\r\n{\r\nstruct sock *s;\r\nsk_for_each(s, &unix_socket_table[hash ^ type]) {\r\nstruct unix_sock *u = unix_sk(s);\r\nif (!net_eq(sock_net(s), net))\r\ncontinue;\r\nif (u->addr->len == len &&\r\n!memcmp(u->addr->name, sunname, len))\r\ngoto found;\r\n}\r\ns = NULL;\r\nfound:\r\nreturn s;\r\n}\r\nstatic inline struct sock *unix_find_socket_byname(struct net *net,\r\nstruct sockaddr_un *sunname,\r\nint len, int type,\r\nunsigned int hash)\r\n{\r\nstruct sock *s;\r\nspin_lock(&unix_table_lock);\r\ns = __unix_find_socket_byname(net, sunname, len, type, hash);\r\nif (s)\r\nsock_hold(s);\r\nspin_unlock(&unix_table_lock);\r\nreturn s;\r\n}\r\nstatic struct sock *unix_find_socket_byinode(struct inode *i)\r\n{\r\nstruct sock *s;\r\nspin_lock(&unix_table_lock);\r\nsk_for_each(s,\r\n&unix_socket_table[i->i_ino & (UNIX_HASH_SIZE - 1)]) {\r\nstruct dentry *dentry = unix_sk(s)->path.dentry;\r\nif (dentry && dentry->d_inode == i) {\r\nsock_hold(s);\r\ngoto found;\r\n}\r\n}\r\ns = NULL;\r\nfound:\r\nspin_unlock(&unix_table_lock);\r\nreturn s;\r\n}\r\nstatic inline int unix_writable(struct sock *sk)\r\n{\r\nreturn (atomic_read(&sk->sk_wmem_alloc) << 2) <= sk->sk_sndbuf;\r\n}\r\nstatic void unix_write_space(struct sock *sk)\r\n{\r\nstruct socket_wq *wq;\r\nrcu_read_lock();\r\nif (unix_writable(sk)) {\r\nwq = rcu_dereference(sk->sk_wq);\r\nif (wq_has_sleeper(wq))\r\nwake_up_interruptible_sync_poll(&wq->wait,\r\nPOLLOUT | POLLWRNORM | POLLWRBAND);\r\nsk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void unix_dgram_disconnected(struct sock *sk, struct sock *other)\r\n{\r\nif (!skb_queue_empty(&sk->sk_receive_queue)) {\r\nskb_queue_purge(&sk->sk_receive_queue);\r\nwake_up_interruptible_all(&unix_sk(sk)->peer_wait);\r\nif (!sock_flag(other, SOCK_DEAD) && unix_peer(other) == sk) {\r\nother->sk_err = ECONNRESET;\r\nother->sk_error_report(other);\r\n}\r\n}\r\n}\r\nstatic void unix_sock_destructor(struct sock *sk)\r\n{\r\nstruct unix_sock *u = unix_sk(sk);\r\nskb_queue_purge(&sk->sk_receive_queue);\r\nWARN_ON(atomic_read(&sk->sk_wmem_alloc));\r\nWARN_ON(!sk_unhashed(sk));\r\nWARN_ON(sk->sk_socket);\r\nif (!sock_flag(sk, SOCK_DEAD)) {\r\npr_info("Attempt to release alive unix socket: %p\n", sk);\r\nreturn;\r\n}\r\nif (u->addr)\r\nunix_release_addr(u->addr);\r\natomic_long_dec(&unix_nr_socks);\r\nlocal_bh_disable();\r\nsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\r\nlocal_bh_enable();\r\n#ifdef UNIX_REFCNT_DEBUG\r\npr_debug("UNIX %p is destroyed, %ld are still alive.\n", sk,\r\natomic_long_read(&unix_nr_socks));\r\n#endif\r\n}\r\nstatic void unix_release_sock(struct sock *sk, int embrion)\r\n{\r\nstruct unix_sock *u = unix_sk(sk);\r\nstruct path path;\r\nstruct sock *skpair;\r\nstruct sk_buff *skb;\r\nint state;\r\nunix_remove_socket(sk);\r\nunix_state_lock(sk);\r\nsock_orphan(sk);\r\nsk->sk_shutdown = SHUTDOWN_MASK;\r\npath = u->path;\r\nu->path.dentry = NULL;\r\nu->path.mnt = NULL;\r\nstate = sk->sk_state;\r\nsk->sk_state = TCP_CLOSE;\r\nunix_state_unlock(sk);\r\nwake_up_interruptible_all(&u->peer_wait);\r\nskpair = unix_peer(sk);\r\nif (skpair != NULL) {\r\nif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) {\r\nunix_state_lock(skpair);\r\nskpair->sk_shutdown = SHUTDOWN_MASK;\r\nif (!skb_queue_empty(&sk->sk_receive_queue) || embrion)\r\nskpair->sk_err = ECONNRESET;\r\nunix_state_unlock(skpair);\r\nskpair->sk_state_change(skpair);\r\nsk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);\r\n}\r\nsock_put(skpair);\r\nunix_peer(sk) = NULL;\r\n}\r\nwhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\r\nif (state == TCP_LISTEN)\r\nunix_release_sock(skb->sk, 1);\r\nkfree_skb(skb);\r\n}\r\nif (path.dentry)\r\npath_put(&path);\r\nsock_put(sk);\r\nif (unix_tot_inflight)\r\nunix_gc();\r\n}\r\nstatic void init_peercred(struct sock *sk)\r\n{\r\nput_pid(sk->sk_peer_pid);\r\nif (sk->sk_peer_cred)\r\nput_cred(sk->sk_peer_cred);\r\nsk->sk_peer_pid = get_pid(task_tgid(current));\r\nsk->sk_peer_cred = get_current_cred();\r\n}\r\nstatic void copy_peercred(struct sock *sk, struct sock *peersk)\r\n{\r\nput_pid(sk->sk_peer_pid);\r\nif (sk->sk_peer_cred)\r\nput_cred(sk->sk_peer_cred);\r\nsk->sk_peer_pid = get_pid(peersk->sk_peer_pid);\r\nsk->sk_peer_cred = get_cred(peersk->sk_peer_cred);\r\n}\r\nstatic int unix_listen(struct socket *sock, int backlog)\r\n{\r\nint err;\r\nstruct sock *sk = sock->sk;\r\nstruct unix_sock *u = unix_sk(sk);\r\nstruct pid *old_pid = NULL;\r\nerr = -EOPNOTSUPP;\r\nif (sock->type != SOCK_STREAM && sock->type != SOCK_SEQPACKET)\r\ngoto out;\r\nerr = -EINVAL;\r\nif (!u->addr)\r\ngoto out;\r\nunix_state_lock(sk);\r\nif (sk->sk_state != TCP_CLOSE && sk->sk_state != TCP_LISTEN)\r\ngoto out_unlock;\r\nif (backlog > sk->sk_max_ack_backlog)\r\nwake_up_interruptible_all(&u->peer_wait);\r\nsk->sk_max_ack_backlog = backlog;\r\nsk->sk_state = TCP_LISTEN;\r\ninit_peercred(sk);\r\nerr = 0;\r\nout_unlock:\r\nunix_state_unlock(sk);\r\nput_pid(old_pid);\r\nout:\r\nreturn err;\r\n}\r\nstatic int unix_set_peek_off(struct sock *sk, int val)\r\n{\r\nstruct unix_sock *u = unix_sk(sk);\r\nif (mutex_lock_interruptible(&u->readlock))\r\nreturn -EINTR;\r\nsk->sk_peek_off = val;\r\nmutex_unlock(&u->readlock);\r\nreturn 0;\r\n}\r\nstatic struct sock *unix_create1(struct net *net, struct socket *sock)\r\n{\r\nstruct sock *sk = NULL;\r\nstruct unix_sock *u;\r\natomic_long_inc(&unix_nr_socks);\r\nif (atomic_long_read(&unix_nr_socks) > 2 * get_max_files())\r\ngoto out;\r\nsk = sk_alloc(net, PF_UNIX, GFP_KERNEL, &unix_proto);\r\nif (!sk)\r\ngoto out;\r\nsock_init_data(sock, sk);\r\nlockdep_set_class(&sk->sk_receive_queue.lock,\r\n&af_unix_sk_receive_queue_lock_key);\r\nsk->sk_write_space = unix_write_space;\r\nsk->sk_max_ack_backlog = net->unx.sysctl_max_dgram_qlen;\r\nsk->sk_destruct = unix_sock_destructor;\r\nu = unix_sk(sk);\r\nu->path.dentry = NULL;\r\nu->path.mnt = NULL;\r\nspin_lock_init(&u->lock);\r\natomic_long_set(&u->inflight, 0);\r\nINIT_LIST_HEAD(&u->link);\r\nmutex_init(&u->readlock);\r\ninit_waitqueue_head(&u->peer_wait);\r\nunix_insert_socket(unix_sockets_unbound(sk), sk);\r\nout:\r\nif (sk == NULL)\r\natomic_long_dec(&unix_nr_socks);\r\nelse {\r\nlocal_bh_disable();\r\nsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\r\nlocal_bh_enable();\r\n}\r\nreturn sk;\r\n}\r\nstatic int unix_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nif (protocol && protocol != PF_UNIX)\r\nreturn -EPROTONOSUPPORT;\r\nsock->state = SS_UNCONNECTED;\r\nswitch (sock->type) {\r\ncase SOCK_STREAM:\r\nsock->ops = &unix_stream_ops;\r\nbreak;\r\ncase SOCK_RAW:\r\nsock->type = SOCK_DGRAM;\r\ncase SOCK_DGRAM:\r\nsock->ops = &unix_dgram_ops;\r\nbreak;\r\ncase SOCK_SEQPACKET:\r\nsock->ops = &unix_seqpacket_ops;\r\nbreak;\r\ndefault:\r\nreturn -ESOCKTNOSUPPORT;\r\n}\r\nreturn unix_create1(net, sock) ? 0 : -ENOMEM;\r\n}\r\nstatic int unix_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nif (!sk)\r\nreturn 0;\r\nunix_release_sock(sk, 0);\r\nsock->sk = NULL;\r\nreturn 0;\r\n}\r\nstatic int unix_autobind(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct net *net = sock_net(sk);\r\nstruct unix_sock *u = unix_sk(sk);\r\nstatic u32 ordernum = 1;\r\nstruct unix_address *addr;\r\nint err;\r\nunsigned int retries = 0;\r\nerr = mutex_lock_interruptible(&u->readlock);\r\nif (err)\r\nreturn err;\r\nerr = 0;\r\nif (u->addr)\r\ngoto out;\r\nerr = -ENOMEM;\r\naddr = kzalloc(sizeof(*addr) + sizeof(short) + 16, GFP_KERNEL);\r\nif (!addr)\r\ngoto out;\r\naddr->name->sun_family = AF_UNIX;\r\natomic_set(&addr->refcnt, 1);\r\nretry:\r\naddr->len = sprintf(addr->name->sun_path+1, "%05x", ordernum) + 1 + sizeof(short);\r\naddr->hash = unix_hash_fold(csum_partial(addr->name, addr->len, 0));\r\nspin_lock(&unix_table_lock);\r\nordernum = (ordernum+1)&0xFFFFF;\r\nif (__unix_find_socket_byname(net, addr->name, addr->len, sock->type,\r\naddr->hash)) {\r\nspin_unlock(&unix_table_lock);\r\ncond_resched();\r\nif (retries++ == 0xFFFFF) {\r\nerr = -ENOSPC;\r\nkfree(addr);\r\ngoto out;\r\n}\r\ngoto retry;\r\n}\r\naddr->hash ^= sk->sk_type;\r\n__unix_remove_socket(sk);\r\nu->addr = addr;\r\n__unix_insert_socket(&unix_socket_table[addr->hash], sk);\r\nspin_unlock(&unix_table_lock);\r\nerr = 0;\r\nout: mutex_unlock(&u->readlock);\r\nreturn err;\r\n}\r\nstatic struct sock *unix_find_other(struct net *net,\r\nstruct sockaddr_un *sunname, int len,\r\nint type, unsigned int hash, int *error)\r\n{\r\nstruct sock *u;\r\nstruct path path;\r\nint err = 0;\r\nif (sunname->sun_path[0]) {\r\nstruct inode *inode;\r\nerr = kern_path(sunname->sun_path, LOOKUP_FOLLOW, &path);\r\nif (err)\r\ngoto fail;\r\ninode = path.dentry->d_inode;\r\nerr = inode_permission(inode, MAY_WRITE);\r\nif (err)\r\ngoto put_fail;\r\nerr = -ECONNREFUSED;\r\nif (!S_ISSOCK(inode->i_mode))\r\ngoto put_fail;\r\nu = unix_find_socket_byinode(inode);\r\nif (!u)\r\ngoto put_fail;\r\nif (u->sk_type == type)\r\ntouch_atime(&path);\r\npath_put(&path);\r\nerr = -EPROTOTYPE;\r\nif (u->sk_type != type) {\r\nsock_put(u);\r\ngoto fail;\r\n}\r\n} else {\r\nerr = -ECONNREFUSED;\r\nu = unix_find_socket_byname(net, sunname, len, type, hash);\r\nif (u) {\r\nstruct dentry *dentry;\r\ndentry = unix_sk(u)->path.dentry;\r\nif (dentry)\r\ntouch_atime(&unix_sk(u)->path);\r\n} else\r\ngoto fail;\r\n}\r\nreturn u;\r\nput_fail:\r\npath_put(&path);\r\nfail:\r\n*error = err;\r\nreturn NULL;\r\n}\r\nstatic int unix_mknod(const char *sun_path, umode_t mode, struct path *res)\r\n{\r\nstruct dentry *dentry;\r\nstruct path path;\r\nint err = 0;\r\ndentry = kern_path_create(AT_FDCWD, sun_path, &path, 0);\r\nerr = PTR_ERR(dentry);\r\nif (IS_ERR(dentry))\r\nreturn err;\r\nerr = security_path_mknod(&path, dentry, mode, 0);\r\nif (!err) {\r\nerr = vfs_mknod(path.dentry->d_inode, dentry, mode, 0);\r\nif (!err) {\r\nres->mnt = mntget(path.mnt);\r\nres->dentry = dget(dentry);\r\n}\r\n}\r\ndone_path_create(&path, dentry);\r\nreturn err;\r\n}\r\nstatic int unix_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct net *net = sock_net(sk);\r\nstruct unix_sock *u = unix_sk(sk);\r\nstruct sockaddr_un *sunaddr = (struct sockaddr_un *)uaddr;\r\nchar *sun_path = sunaddr->sun_path;\r\nint err;\r\nunsigned int hash;\r\nstruct unix_address *addr;\r\nstruct hlist_head *list;\r\nerr = -EINVAL;\r\nif (sunaddr->sun_family != AF_UNIX)\r\ngoto out;\r\nif (addr_len == sizeof(short)) {\r\nerr = unix_autobind(sock);\r\ngoto out;\r\n}\r\nerr = unix_mkname(sunaddr, addr_len, &hash);\r\nif (err < 0)\r\ngoto out;\r\naddr_len = err;\r\nerr = mutex_lock_interruptible(&u->readlock);\r\nif (err)\r\ngoto out;\r\nerr = -EINVAL;\r\nif (u->addr)\r\ngoto out_up;\r\nerr = -ENOMEM;\r\naddr = kmalloc(sizeof(*addr)+addr_len, GFP_KERNEL);\r\nif (!addr)\r\ngoto out_up;\r\nmemcpy(addr->name, sunaddr, addr_len);\r\naddr->len = addr_len;\r\naddr->hash = hash ^ sk->sk_type;\r\natomic_set(&addr->refcnt, 1);\r\nif (sun_path[0]) {\r\nstruct path path;\r\numode_t mode = S_IFSOCK |\r\n(SOCK_INODE(sock)->i_mode & ~current_umask());\r\nerr = unix_mknod(sun_path, mode, &path);\r\nif (err) {\r\nif (err == -EEXIST)\r\nerr = -EADDRINUSE;\r\nunix_release_addr(addr);\r\ngoto out_up;\r\n}\r\naddr->hash = UNIX_HASH_SIZE;\r\nhash = path.dentry->d_inode->i_ino & (UNIX_HASH_SIZE-1);\r\nspin_lock(&unix_table_lock);\r\nu->path = path;\r\nlist = &unix_socket_table[hash];\r\n} else {\r\nspin_lock(&unix_table_lock);\r\nerr = -EADDRINUSE;\r\nif (__unix_find_socket_byname(net, sunaddr, addr_len,\r\nsk->sk_type, hash)) {\r\nunix_release_addr(addr);\r\ngoto out_unlock;\r\n}\r\nlist = &unix_socket_table[addr->hash];\r\n}\r\nerr = 0;\r\n__unix_remove_socket(sk);\r\nu->addr = addr;\r\n__unix_insert_socket(list, sk);\r\nout_unlock:\r\nspin_unlock(&unix_table_lock);\r\nout_up:\r\nmutex_unlock(&u->readlock);\r\nout:\r\nreturn err;\r\n}\r\nstatic void unix_state_double_lock(struct sock *sk1, struct sock *sk2)\r\n{\r\nif (unlikely(sk1 == sk2) || !sk2) {\r\nunix_state_lock(sk1);\r\nreturn;\r\n}\r\nif (sk1 < sk2) {\r\nunix_state_lock(sk1);\r\nunix_state_lock_nested(sk2);\r\n} else {\r\nunix_state_lock(sk2);\r\nunix_state_lock_nested(sk1);\r\n}\r\n}\r\nstatic void unix_state_double_unlock(struct sock *sk1, struct sock *sk2)\r\n{\r\nif (unlikely(sk1 == sk2) || !sk2) {\r\nunix_state_unlock(sk1);\r\nreturn;\r\n}\r\nunix_state_unlock(sk1);\r\nunix_state_unlock(sk2);\r\n}\r\nstatic int unix_dgram_connect(struct socket *sock, struct sockaddr *addr,\r\nint alen, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct net *net = sock_net(sk);\r\nstruct sockaddr_un *sunaddr = (struct sockaddr_un *)addr;\r\nstruct sock *other;\r\nunsigned int hash;\r\nint err;\r\nif (addr->sa_family != AF_UNSPEC) {\r\nerr = unix_mkname(sunaddr, alen, &hash);\r\nif (err < 0)\r\ngoto out;\r\nalen = err;\r\nif (test_bit(SOCK_PASSCRED, &sock->flags) &&\r\n!unix_sk(sk)->addr && (err = unix_autobind(sock)) != 0)\r\ngoto out;\r\nrestart:\r\nother = unix_find_other(net, sunaddr, alen, sock->type, hash, &err);\r\nif (!other)\r\ngoto out;\r\nunix_state_double_lock(sk, other);\r\nif (sock_flag(other, SOCK_DEAD)) {\r\nunix_state_double_unlock(sk, other);\r\nsock_put(other);\r\ngoto restart;\r\n}\r\nerr = -EPERM;\r\nif (!unix_may_send(sk, other))\r\ngoto out_unlock;\r\nerr = security_unix_may_send(sk->sk_socket, other->sk_socket);\r\nif (err)\r\ngoto out_unlock;\r\n} else {\r\nother = NULL;\r\nunix_state_double_lock(sk, other);\r\n}\r\nif (unix_peer(sk)) {\r\nstruct sock *old_peer = unix_peer(sk);\r\nunix_peer(sk) = other;\r\nunix_state_double_unlock(sk, other);\r\nif (other != old_peer)\r\nunix_dgram_disconnected(sk, old_peer);\r\nsock_put(old_peer);\r\n} else {\r\nunix_peer(sk) = other;\r\nunix_state_double_unlock(sk, other);\r\n}\r\nreturn 0;\r\nout_unlock:\r\nunix_state_double_unlock(sk, other);\r\nsock_put(other);\r\nout:\r\nreturn err;\r\n}\r\nstatic long unix_wait_for_peer(struct sock *other, long timeo)\r\n{\r\nstruct unix_sock *u = unix_sk(other);\r\nint sched;\r\nDEFINE_WAIT(wait);\r\nprepare_to_wait_exclusive(&u->peer_wait, &wait, TASK_INTERRUPTIBLE);\r\nsched = !sock_flag(other, SOCK_DEAD) &&\r\n!(other->sk_shutdown & RCV_SHUTDOWN) &&\r\nunix_recvq_full(other);\r\nunix_state_unlock(other);\r\nif (sched)\r\ntimeo = schedule_timeout(timeo);\r\nfinish_wait(&u->peer_wait, &wait);\r\nreturn timeo;\r\n}\r\nstatic int unix_stream_connect(struct socket *sock, struct sockaddr *uaddr,\r\nint addr_len, int flags)\r\n{\r\nstruct sockaddr_un *sunaddr = (struct sockaddr_un *)uaddr;\r\nstruct sock *sk = sock->sk;\r\nstruct net *net = sock_net(sk);\r\nstruct unix_sock *u = unix_sk(sk), *newu, *otheru;\r\nstruct sock *newsk = NULL;\r\nstruct sock *other = NULL;\r\nstruct sk_buff *skb = NULL;\r\nunsigned int hash;\r\nint st;\r\nint err;\r\nlong timeo;\r\nerr = unix_mkname(sunaddr, addr_len, &hash);\r\nif (err < 0)\r\ngoto out;\r\naddr_len = err;\r\nif (test_bit(SOCK_PASSCRED, &sock->flags) && !u->addr &&\r\n(err = unix_autobind(sock)) != 0)\r\ngoto out;\r\ntimeo = sock_sndtimeo(sk, flags & O_NONBLOCK);\r\nerr = -ENOMEM;\r\nnewsk = unix_create1(sock_net(sk), NULL);\r\nif (newsk == NULL)\r\ngoto out;\r\nskb = sock_wmalloc(newsk, 1, 0, GFP_KERNEL);\r\nif (skb == NULL)\r\ngoto out;\r\nrestart:\r\nother = unix_find_other(net, sunaddr, addr_len, sk->sk_type, hash, &err);\r\nif (!other)\r\ngoto out;\r\nunix_state_lock(other);\r\nif (sock_flag(other, SOCK_DEAD)) {\r\nunix_state_unlock(other);\r\nsock_put(other);\r\ngoto restart;\r\n}\r\nerr = -ECONNREFUSED;\r\nif (other->sk_state != TCP_LISTEN)\r\ngoto out_unlock;\r\nif (other->sk_shutdown & RCV_SHUTDOWN)\r\ngoto out_unlock;\r\nif (unix_recvq_full(other)) {\r\nerr = -EAGAIN;\r\nif (!timeo)\r\ngoto out_unlock;\r\ntimeo = unix_wait_for_peer(other, timeo);\r\nerr = sock_intr_errno(timeo);\r\nif (signal_pending(current))\r\ngoto out;\r\nsock_put(other);\r\ngoto restart;\r\n}\r\nst = sk->sk_state;\r\nswitch (st) {\r\ncase TCP_CLOSE:\r\nbreak;\r\ncase TCP_ESTABLISHED:\r\nerr = -EISCONN;\r\ngoto out_unlock;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nunix_state_lock_nested(sk);\r\nif (sk->sk_state != st) {\r\nunix_state_unlock(sk);\r\nunix_state_unlock(other);\r\nsock_put(other);\r\ngoto restart;\r\n}\r\nerr = security_unix_stream_connect(sk, other, newsk);\r\nif (err) {\r\nunix_state_unlock(sk);\r\ngoto out_unlock;\r\n}\r\nsock_hold(sk);\r\nunix_peer(newsk) = sk;\r\nnewsk->sk_state = TCP_ESTABLISHED;\r\nnewsk->sk_type = sk->sk_type;\r\ninit_peercred(newsk);\r\nnewu = unix_sk(newsk);\r\nRCU_INIT_POINTER(newsk->sk_wq, &newu->peer_wq);\r\notheru = unix_sk(other);\r\nif (otheru->addr) {\r\natomic_inc(&otheru->addr->refcnt);\r\nnewu->addr = otheru->addr;\r\n}\r\nif (otheru->path.dentry) {\r\npath_get(&otheru->path);\r\nnewu->path = otheru->path;\r\n}\r\ncopy_peercred(sk, other);\r\nsock->state = SS_CONNECTED;\r\nsk->sk_state = TCP_ESTABLISHED;\r\nsock_hold(newsk);\r\nsmp_mb__after_atomic();\r\nunix_peer(sk) = newsk;\r\nunix_state_unlock(sk);\r\nspin_lock(&other->sk_receive_queue.lock);\r\n__skb_queue_tail(&other->sk_receive_queue, skb);\r\nspin_unlock(&other->sk_receive_queue.lock);\r\nunix_state_unlock(other);\r\nother->sk_data_ready(other);\r\nsock_put(other);\r\nreturn 0;\r\nout_unlock:\r\nif (other)\r\nunix_state_unlock(other);\r\nout:\r\nkfree_skb(skb);\r\nif (newsk)\r\nunix_release_sock(newsk, 0);\r\nif (other)\r\nsock_put(other);\r\nreturn err;\r\n}\r\nstatic int unix_socketpair(struct socket *socka, struct socket *sockb)\r\n{\r\nstruct sock *ska = socka->sk, *skb = sockb->sk;\r\nsock_hold(ska);\r\nsock_hold(skb);\r\nunix_peer(ska) = skb;\r\nunix_peer(skb) = ska;\r\ninit_peercred(ska);\r\ninit_peercred(skb);\r\nif (ska->sk_type != SOCK_DGRAM) {\r\nska->sk_state = TCP_ESTABLISHED;\r\nskb->sk_state = TCP_ESTABLISHED;\r\nsocka->state = SS_CONNECTED;\r\nsockb->state = SS_CONNECTED;\r\n}\r\nreturn 0;\r\n}\r\nstatic void unix_sock_inherit_flags(const struct socket *old,\r\nstruct socket *new)\r\n{\r\nif (test_bit(SOCK_PASSCRED, &old->flags))\r\nset_bit(SOCK_PASSCRED, &new->flags);\r\nif (test_bit(SOCK_PASSSEC, &old->flags))\r\nset_bit(SOCK_PASSSEC, &new->flags);\r\n}\r\nstatic int unix_accept(struct socket *sock, struct socket *newsock, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sock *tsk;\r\nstruct sk_buff *skb;\r\nint err;\r\nerr = -EOPNOTSUPP;\r\nif (sock->type != SOCK_STREAM && sock->type != SOCK_SEQPACKET)\r\ngoto out;\r\nerr = -EINVAL;\r\nif (sk->sk_state != TCP_LISTEN)\r\ngoto out;\r\nskb = skb_recv_datagram(sk, 0, flags&O_NONBLOCK, &err);\r\nif (!skb) {\r\nif (err == 0)\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\ntsk = skb->sk;\r\nskb_free_datagram(sk, skb);\r\nwake_up_interruptible(&unix_sk(sk)->peer_wait);\r\nunix_state_lock(tsk);\r\nnewsock->state = SS_CONNECTED;\r\nunix_sock_inherit_flags(sock, newsock);\r\nsock_graft(tsk, newsock);\r\nunix_state_unlock(tsk);\r\nreturn 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int unix_getname(struct socket *sock, struct sockaddr *uaddr, int *uaddr_len, int peer)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct unix_sock *u;\r\nDECLARE_SOCKADDR(struct sockaddr_un *, sunaddr, uaddr);\r\nint err = 0;\r\nif (peer) {\r\nsk = unix_peer_get(sk);\r\nerr = -ENOTCONN;\r\nif (!sk)\r\ngoto out;\r\nerr = 0;\r\n} else {\r\nsock_hold(sk);\r\n}\r\nu = unix_sk(sk);\r\nunix_state_lock(sk);\r\nif (!u->addr) {\r\nsunaddr->sun_family = AF_UNIX;\r\nsunaddr->sun_path[0] = 0;\r\n*uaddr_len = sizeof(short);\r\n} else {\r\nstruct unix_address *addr = u->addr;\r\n*uaddr_len = addr->len;\r\nmemcpy(sunaddr, addr->name, *uaddr_len);\r\n}\r\nunix_state_unlock(sk);\r\nsock_put(sk);\r\nout:\r\nreturn err;\r\n}\r\nstatic void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)\r\n{\r\nint i;\r\nscm->fp = UNIXCB(skb).fp;\r\nUNIXCB(skb).fp = NULL;\r\nfor (i = scm->fp->count-1; i >= 0; i--)\r\nunix_notinflight(scm->fp->fp[i]);\r\n}\r\nstatic void unix_destruct_scm(struct sk_buff *skb)\r\n{\r\nstruct scm_cookie scm;\r\nmemset(&scm, 0, sizeof(scm));\r\nscm.pid = UNIXCB(skb).pid;\r\nif (UNIXCB(skb).fp)\r\nunix_detach_fds(&scm, skb);\r\nscm_destroy(&scm);\r\nsock_wfree(skb);\r\n}\r\nstatic int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)\r\n{\r\nint i;\r\nunsigned char max_level = 0;\r\nint unix_sock_count = 0;\r\nfor (i = scm->fp->count - 1; i >= 0; i--) {\r\nstruct sock *sk = unix_get_socket(scm->fp->fp[i]);\r\nif (sk) {\r\nunix_sock_count++;\r\nmax_level = max(max_level,\r\nunix_sk(sk)->recursion_level);\r\n}\r\n}\r\nif (unlikely(max_level > MAX_RECURSION_LEVEL))\r\nreturn -ETOOMANYREFS;\r\nUNIXCB(skb).fp = scm_fp_dup(scm->fp);\r\nif (!UNIXCB(skb).fp)\r\nreturn -ENOMEM;\r\nif (unix_sock_count) {\r\nfor (i = scm->fp->count - 1; i >= 0; i--)\r\nunix_inflight(scm->fp->fp[i]);\r\n}\r\nreturn max_level;\r\n}\r\nstatic int unix_scm_to_skb(struct scm_cookie *scm, struct sk_buff *skb, bool send_fds)\r\n{\r\nint err = 0;\r\nUNIXCB(skb).pid = get_pid(scm->pid);\r\nUNIXCB(skb).uid = scm->creds.uid;\r\nUNIXCB(skb).gid = scm->creds.gid;\r\nUNIXCB(skb).fp = NULL;\r\nif (scm->fp && send_fds)\r\nerr = unix_attach_fds(scm, skb);\r\nskb->destructor = unix_destruct_scm;\r\nreturn err;\r\n}\r\nstatic void maybe_add_creds(struct sk_buff *skb, const struct socket *sock,\r\nconst struct sock *other)\r\n{\r\nif (UNIXCB(skb).pid)\r\nreturn;\r\nif (test_bit(SOCK_PASSCRED, &sock->flags) ||\r\n!other->sk_socket ||\r\ntest_bit(SOCK_PASSCRED, &other->sk_socket->flags)) {\r\nUNIXCB(skb).pid = get_pid(task_tgid(current));\r\ncurrent_uid_gid(&UNIXCB(skb).uid, &UNIXCB(skb).gid);\r\n}\r\n}\r\nstatic int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\r\nstruct sock *sk = sock->sk;\r\nstruct net *net = sock_net(sk);\r\nstruct unix_sock *u = unix_sk(sk);\r\nDECLARE_SOCKADDR(struct sockaddr_un *, sunaddr, msg->msg_name);\r\nstruct sock *other = NULL;\r\nint namelen = 0;\r\nint err;\r\nunsigned int hash;\r\nstruct sk_buff *skb;\r\nlong timeo;\r\nstruct scm_cookie tmp_scm;\r\nint max_level;\r\nint data_len = 0;\r\nif (NULL == siocb->scm)\r\nsiocb->scm = &tmp_scm;\r\nwait_for_unix_gc();\r\nerr = scm_send(sock, msg, siocb->scm, false);\r\nif (err < 0)\r\nreturn err;\r\nerr = -EOPNOTSUPP;\r\nif (msg->msg_flags&MSG_OOB)\r\ngoto out;\r\nif (msg->msg_namelen) {\r\nerr = unix_mkname(sunaddr, msg->msg_namelen, &hash);\r\nif (err < 0)\r\ngoto out;\r\nnamelen = err;\r\n} else {\r\nsunaddr = NULL;\r\nerr = -ENOTCONN;\r\nother = unix_peer_get(sk);\r\nif (!other)\r\ngoto out;\r\n}\r\nif (test_bit(SOCK_PASSCRED, &sock->flags) && !u->addr\r\n&& (err = unix_autobind(sock)) != 0)\r\ngoto out;\r\nerr = -EMSGSIZE;\r\nif (len > sk->sk_sndbuf - 32)\r\ngoto out;\r\nif (len > SKB_MAX_ALLOC) {\r\ndata_len = min_t(size_t,\r\nlen - SKB_MAX_ALLOC,\r\nMAX_SKB_FRAGS * PAGE_SIZE);\r\ndata_len = PAGE_ALIGN(data_len);\r\nBUILD_BUG_ON(SKB_MAX_ALLOC < PAGE_SIZE);\r\n}\r\nskb = sock_alloc_send_pskb(sk, len - data_len, data_len,\r\nmsg->msg_flags & MSG_DONTWAIT, &err,\r\nPAGE_ALLOC_COSTLY_ORDER);\r\nif (skb == NULL)\r\ngoto out;\r\nerr = unix_scm_to_skb(siocb->scm, skb, true);\r\nif (err < 0)\r\ngoto out_free;\r\nmax_level = err + 1;\r\nunix_get_secdata(siocb->scm, skb);\r\nskb_put(skb, len - data_len);\r\nskb->data_len = data_len;\r\nskb->len = len;\r\nerr = skb_copy_datagram_from_iovec(skb, 0, msg->msg_iov, 0, len);\r\nif (err)\r\ngoto out_free;\r\ntimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\r\nrestart:\r\nif (!other) {\r\nerr = -ECONNRESET;\r\nif (sunaddr == NULL)\r\ngoto out_free;\r\nother = unix_find_other(net, sunaddr, namelen, sk->sk_type,\r\nhash, &err);\r\nif (other == NULL)\r\ngoto out_free;\r\n}\r\nif (sk_filter(other, skb) < 0) {\r\nerr = len;\r\ngoto out_free;\r\n}\r\nunix_state_lock(other);\r\nerr = -EPERM;\r\nif (!unix_may_send(sk, other))\r\ngoto out_unlock;\r\nif (sock_flag(other, SOCK_DEAD)) {\r\nunix_state_unlock(other);\r\nsock_put(other);\r\nerr = 0;\r\nunix_state_lock(sk);\r\nif (unix_peer(sk) == other) {\r\nunix_peer(sk) = NULL;\r\nunix_state_unlock(sk);\r\nunix_dgram_disconnected(sk, other);\r\nsock_put(other);\r\nerr = -ECONNREFUSED;\r\n} else {\r\nunix_state_unlock(sk);\r\n}\r\nother = NULL;\r\nif (err)\r\ngoto out_free;\r\ngoto restart;\r\n}\r\nerr = -EPIPE;\r\nif (other->sk_shutdown & RCV_SHUTDOWN)\r\ngoto out_unlock;\r\nif (sk->sk_type != SOCK_SEQPACKET) {\r\nerr = security_unix_may_send(sk->sk_socket, other->sk_socket);\r\nif (err)\r\ngoto out_unlock;\r\n}\r\nif (unix_peer(other) != sk && unix_recvq_full(other)) {\r\nif (!timeo) {\r\nerr = -EAGAIN;\r\ngoto out_unlock;\r\n}\r\ntimeo = unix_wait_for_peer(other, timeo);\r\nerr = sock_intr_errno(timeo);\r\nif (signal_pending(current))\r\ngoto out_free;\r\ngoto restart;\r\n}\r\nif (sock_flag(other, SOCK_RCVTSTAMP))\r\n__net_timestamp(skb);\r\nmaybe_add_creds(skb, sock, other);\r\nskb_queue_tail(&other->sk_receive_queue, skb);\r\nif (max_level > unix_sk(other)->recursion_level)\r\nunix_sk(other)->recursion_level = max_level;\r\nunix_state_unlock(other);\r\nother->sk_data_ready(other);\r\nsock_put(other);\r\nscm_destroy(siocb->scm);\r\nreturn len;\r\nout_unlock:\r\nunix_state_unlock(other);\r\nout_free:\r\nkfree_skb(skb);\r\nout:\r\nif (other)\r\nsock_put(other);\r\nscm_destroy(siocb->scm);\r\nreturn err;\r\n}\r\nstatic int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\r\nstruct sock *sk = sock->sk;\r\nstruct sock *other = NULL;\r\nint err, size;\r\nstruct sk_buff *skb;\r\nint sent = 0;\r\nstruct scm_cookie tmp_scm;\r\nbool fds_sent = false;\r\nint max_level;\r\nint data_len;\r\nif (NULL == siocb->scm)\r\nsiocb->scm = &tmp_scm;\r\nwait_for_unix_gc();\r\nerr = scm_send(sock, msg, siocb->scm, false);\r\nif (err < 0)\r\nreturn err;\r\nerr = -EOPNOTSUPP;\r\nif (msg->msg_flags&MSG_OOB)\r\ngoto out_err;\r\nif (msg->msg_namelen) {\r\nerr = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;\r\ngoto out_err;\r\n} else {\r\nerr = -ENOTCONN;\r\nother = unix_peer(sk);\r\nif (!other)\r\ngoto out_err;\r\n}\r\nif (sk->sk_shutdown & SEND_SHUTDOWN)\r\ngoto pipe_err;\r\nwhile (sent < len) {\r\nsize = len - sent;\r\nsize = min_t(int, size, (sk->sk_sndbuf >> 1) - 64);\r\nsize = min_t(int, size, SKB_MAX_HEAD(0) + UNIX_SKB_FRAGS_SZ);\r\ndata_len = max_t(int, 0, size - SKB_MAX_HEAD(0));\r\ndata_len = min_t(size_t, size, PAGE_ALIGN(data_len));\r\nskb = sock_alloc_send_pskb(sk, size - data_len, data_len,\r\nmsg->msg_flags & MSG_DONTWAIT, &err,\r\nget_order(UNIX_SKB_FRAGS_SZ));\r\nif (!skb)\r\ngoto out_err;\r\nerr = unix_scm_to_skb(siocb->scm, skb, !fds_sent);\r\nif (err < 0) {\r\nkfree_skb(skb);\r\ngoto out_err;\r\n}\r\nmax_level = err + 1;\r\nfds_sent = true;\r\nskb_put(skb, size - data_len);\r\nskb->data_len = data_len;\r\nskb->len = size;\r\nerr = skb_copy_datagram_from_iovec(skb, 0, msg->msg_iov,\r\nsent, size);\r\nif (err) {\r\nkfree_skb(skb);\r\ngoto out_err;\r\n}\r\nunix_state_lock(other);\r\nif (sock_flag(other, SOCK_DEAD) ||\r\n(other->sk_shutdown & RCV_SHUTDOWN))\r\ngoto pipe_err_free;\r\nmaybe_add_creds(skb, sock, other);\r\nskb_queue_tail(&other->sk_receive_queue, skb);\r\nif (max_level > unix_sk(other)->recursion_level)\r\nunix_sk(other)->recursion_level = max_level;\r\nunix_state_unlock(other);\r\nother->sk_data_ready(other);\r\nsent += size;\r\n}\r\nscm_destroy(siocb->scm);\r\nsiocb->scm = NULL;\r\nreturn sent;\r\npipe_err_free:\r\nunix_state_unlock(other);\r\nkfree_skb(skb);\r\npipe_err:\r\nif (sent == 0 && !(msg->msg_flags&MSG_NOSIGNAL))\r\nsend_sig(SIGPIPE, current, 0);\r\nerr = -EPIPE;\r\nout_err:\r\nscm_destroy(siocb->scm);\r\nsiocb->scm = NULL;\r\nreturn sent ? : err;\r\n}\r\nstatic int unix_seqpacket_sendmsg(struct kiocb *kiocb, struct socket *sock,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nint err;\r\nstruct sock *sk = sock->sk;\r\nerr = sock_error(sk);\r\nif (err)\r\nreturn err;\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\nreturn -ENOTCONN;\r\nif (msg->msg_namelen)\r\nmsg->msg_namelen = 0;\r\nreturn unix_dgram_sendmsg(kiocb, sock, msg, len);\r\n}\r\nstatic int unix_seqpacket_recvmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t size,\r\nint flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\nreturn -ENOTCONN;\r\nreturn unix_dgram_recvmsg(iocb, sock, msg, size, flags);\r\n}\r\nstatic void unix_copy_addr(struct msghdr *msg, struct sock *sk)\r\n{\r\nstruct unix_sock *u = unix_sk(sk);\r\nif (u->addr) {\r\nmsg->msg_namelen = u->addr->len;\r\nmemcpy(msg->msg_name, u->addr->name, u->addr->len);\r\n}\r\n}\r\nstatic int unix_dgram_recvmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t size,\r\nint flags)\r\n{\r\nstruct sock_iocb *siocb = kiocb_to_siocb(iocb);\r\nstruct scm_cookie tmp_scm;\r\nstruct sock *sk = sock->sk;\r\nstruct unix_sock *u = unix_sk(sk);\r\nint noblock = flags & MSG_DONTWAIT;\r\nstruct sk_buff *skb;\r\nint err;\r\nint peeked, skip;\r\nerr = -EOPNOTSUPP;\r\nif (flags&MSG_OOB)\r\ngoto out;\r\nerr = mutex_lock_interruptible(&u->readlock);\r\nif (unlikely(err)) {\r\nerr = noblock ? -EAGAIN : -ERESTARTSYS;\r\ngoto out;\r\n}\r\nskip = sk_peek_offset(sk, flags);\r\nskb = __skb_recv_datagram(sk, flags, &peeked, &skip, &err);\r\nif (!skb) {\r\nunix_state_lock(sk);\r\nif (sk->sk_type == SOCK_SEQPACKET && err == -EAGAIN &&\r\n(sk->sk_shutdown & RCV_SHUTDOWN))\r\nerr = 0;\r\nunix_state_unlock(sk);\r\ngoto out_unlock;\r\n}\r\nwake_up_interruptible_sync_poll(&u->peer_wait,\r\nPOLLOUT | POLLWRNORM | POLLWRBAND);\r\nif (msg->msg_name)\r\nunix_copy_addr(msg, skb->sk);\r\nif (size > skb->len - skip)\r\nsize = skb->len - skip;\r\nelse if (size < skb->len - skip)\r\nmsg->msg_flags |= MSG_TRUNC;\r\nerr = skb_copy_datagram_iovec(skb, skip, msg->msg_iov, size);\r\nif (err)\r\ngoto out_free;\r\nif (sock_flag(sk, SOCK_RCVTSTAMP))\r\n__sock_recv_timestamp(msg, sk, skb);\r\nif (!siocb->scm) {\r\nsiocb->scm = &tmp_scm;\r\nmemset(&tmp_scm, 0, sizeof(tmp_scm));\r\n}\r\nscm_set_cred(siocb->scm, UNIXCB(skb).pid, UNIXCB(skb).uid, UNIXCB(skb).gid);\r\nunix_set_secdata(siocb->scm, skb);\r\nif (!(flags & MSG_PEEK)) {\r\nif (UNIXCB(skb).fp)\r\nunix_detach_fds(siocb->scm, skb);\r\nsk_peek_offset_bwd(sk, skb->len);\r\n} else {\r\nsk_peek_offset_fwd(sk, size);\r\nif (UNIXCB(skb).fp)\r\nsiocb->scm->fp = scm_fp_dup(UNIXCB(skb).fp);\r\n}\r\nerr = (flags & MSG_TRUNC) ? skb->len - skip : size;\r\nscm_recv(sock, msg, siocb->scm, flags);\r\nout_free:\r\nskb_free_datagram(sk, skb);\r\nout_unlock:\r\nmutex_unlock(&u->readlock);\r\nout:\r\nreturn err;\r\n}\r\nstatic long unix_stream_data_wait(struct sock *sk, long timeo,\r\nstruct sk_buff *last)\r\n{\r\nDEFINE_WAIT(wait);\r\nunix_state_lock(sk);\r\nfor (;;) {\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\nif (skb_peek_tail(&sk->sk_receive_queue) != last ||\r\nsk->sk_err ||\r\n(sk->sk_shutdown & RCV_SHUTDOWN) ||\r\nsignal_pending(current) ||\r\n!timeo)\r\nbreak;\r\nset_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);\r\nunix_state_unlock(sk);\r\ntimeo = freezable_schedule_timeout(timeo);\r\nunix_state_lock(sk);\r\nclear_bit(SOCK_ASYNC_WAITDATA, &sk->sk_socket->flags);\r\n}\r\nfinish_wait(sk_sleep(sk), &wait);\r\nunix_state_unlock(sk);\r\nreturn timeo;\r\n}\r\nstatic unsigned int unix_skb_len(const struct sk_buff *skb)\r\n{\r\nreturn skb->len - UNIXCB(skb).consumed;\r\n}\r\nstatic int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t size,\r\nint flags)\r\n{\r\nstruct sock_iocb *siocb = kiocb_to_siocb(iocb);\r\nstruct scm_cookie tmp_scm;\r\nstruct sock *sk = sock->sk;\r\nstruct unix_sock *u = unix_sk(sk);\r\nDECLARE_SOCKADDR(struct sockaddr_un *, sunaddr, msg->msg_name);\r\nint copied = 0;\r\nint noblock = flags & MSG_DONTWAIT;\r\nint check_creds = 0;\r\nint target;\r\nint err = 0;\r\nlong timeo;\r\nint skip;\r\nerr = -EINVAL;\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\ngoto out;\r\nerr = -EOPNOTSUPP;\r\nif (flags&MSG_OOB)\r\ngoto out;\r\ntarget = sock_rcvlowat(sk, flags&MSG_WAITALL, size);\r\ntimeo = sock_rcvtimeo(sk, noblock);\r\nif (!siocb->scm) {\r\nsiocb->scm = &tmp_scm;\r\nmemset(&tmp_scm, 0, sizeof(tmp_scm));\r\n}\r\nerr = mutex_lock_interruptible(&u->readlock);\r\nif (unlikely(err)) {\r\nerr = noblock ? -EAGAIN : -ERESTARTSYS;\r\ngoto out;\r\n}\r\ndo {\r\nint chunk;\r\nstruct sk_buff *skb, *last;\r\nunix_state_lock(sk);\r\nlast = skb = skb_peek(&sk->sk_receive_queue);\r\nagain:\r\nif (skb == NULL) {\r\nunix_sk(sk)->recursion_level = 0;\r\nif (copied >= target)\r\ngoto unlock;\r\nerr = sock_error(sk);\r\nif (err)\r\ngoto unlock;\r\nif (sk->sk_shutdown & RCV_SHUTDOWN)\r\ngoto unlock;\r\nunix_state_unlock(sk);\r\nerr = -EAGAIN;\r\nif (!timeo)\r\nbreak;\r\nmutex_unlock(&u->readlock);\r\ntimeo = unix_stream_data_wait(sk, timeo, last);\r\nif (signal_pending(current)\r\n|| mutex_lock_interruptible(&u->readlock)) {\r\nerr = sock_intr_errno(timeo);\r\ngoto out;\r\n}\r\ncontinue;\r\nunlock:\r\nunix_state_unlock(sk);\r\nbreak;\r\n}\r\nskip = sk_peek_offset(sk, flags);\r\nwhile (skip >= unix_skb_len(skb)) {\r\nskip -= unix_skb_len(skb);\r\nlast = skb;\r\nskb = skb_peek_next(skb, &sk->sk_receive_queue);\r\nif (!skb)\r\ngoto again;\r\n}\r\nunix_state_unlock(sk);\r\nif (check_creds) {\r\nif ((UNIXCB(skb).pid != siocb->scm->pid) ||\r\n!uid_eq(UNIXCB(skb).uid, siocb->scm->creds.uid) ||\r\n!gid_eq(UNIXCB(skb).gid, siocb->scm->creds.gid))\r\nbreak;\r\n} else if (test_bit(SOCK_PASSCRED, &sock->flags)) {\r\nscm_set_cred(siocb->scm, UNIXCB(skb).pid, UNIXCB(skb).uid, UNIXCB(skb).gid);\r\ncheck_creds = 1;\r\n}\r\nif (sunaddr) {\r\nunix_copy_addr(msg, skb->sk);\r\nsunaddr = NULL;\r\n}\r\nchunk = min_t(unsigned int, unix_skb_len(skb) - skip, size);\r\nif (skb_copy_datagram_iovec(skb, UNIXCB(skb).consumed + skip,\r\nmsg->msg_iov, chunk)) {\r\nif (copied == 0)\r\ncopied = -EFAULT;\r\nbreak;\r\n}\r\ncopied += chunk;\r\nsize -= chunk;\r\nif (!(flags & MSG_PEEK)) {\r\nUNIXCB(skb).consumed += chunk;\r\nsk_peek_offset_bwd(sk, chunk);\r\nif (UNIXCB(skb).fp)\r\nunix_detach_fds(siocb->scm, skb);\r\nif (unix_skb_len(skb))\r\nbreak;\r\nskb_unlink(skb, &sk->sk_receive_queue);\r\nconsume_skb(skb);\r\nif (siocb->scm->fp)\r\nbreak;\r\n} else {\r\nif (UNIXCB(skb).fp)\r\nsiocb->scm->fp = scm_fp_dup(UNIXCB(skb).fp);\r\nsk_peek_offset_fwd(sk, chunk);\r\nbreak;\r\n}\r\n} while (size);\r\nmutex_unlock(&u->readlock);\r\nscm_recv(sock, msg, siocb->scm, flags);\r\nout:\r\nreturn copied ? : err;\r\n}\r\nstatic int unix_shutdown(struct socket *sock, int mode)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sock *other;\r\nif (mode < SHUT_RD || mode > SHUT_RDWR)\r\nreturn -EINVAL;\r\n++mode;\r\nunix_state_lock(sk);\r\nsk->sk_shutdown |= mode;\r\nother = unix_peer(sk);\r\nif (other)\r\nsock_hold(other);\r\nunix_state_unlock(sk);\r\nsk->sk_state_change(sk);\r\nif (other &&\r\n(sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET)) {\r\nint peer_mode = 0;\r\nif (mode&RCV_SHUTDOWN)\r\npeer_mode |= SEND_SHUTDOWN;\r\nif (mode&SEND_SHUTDOWN)\r\npeer_mode |= RCV_SHUTDOWN;\r\nunix_state_lock(other);\r\nother->sk_shutdown |= peer_mode;\r\nunix_state_unlock(other);\r\nother->sk_state_change(other);\r\nif (peer_mode == SHUTDOWN_MASK)\r\nsk_wake_async(other, SOCK_WAKE_WAITD, POLL_HUP);\r\nelse if (peer_mode & RCV_SHUTDOWN)\r\nsk_wake_async(other, SOCK_WAKE_WAITD, POLL_IN);\r\n}\r\nif (other)\r\nsock_put(other);\r\nreturn 0;\r\n}\r\nlong unix_inq_len(struct sock *sk)\r\n{\r\nstruct sk_buff *skb;\r\nlong amount = 0;\r\nif (sk->sk_state == TCP_LISTEN)\r\nreturn -EINVAL;\r\nspin_lock(&sk->sk_receive_queue.lock);\r\nif (sk->sk_type == SOCK_STREAM ||\r\nsk->sk_type == SOCK_SEQPACKET) {\r\nskb_queue_walk(&sk->sk_receive_queue, skb)\r\namount += unix_skb_len(skb);\r\n} else {\r\nskb = skb_peek(&sk->sk_receive_queue);\r\nif (skb)\r\namount = skb->len;\r\n}\r\nspin_unlock(&sk->sk_receive_queue.lock);\r\nreturn amount;\r\n}\r\nlong unix_outq_len(struct sock *sk)\r\n{\r\nreturn sk_wmem_alloc_get(sk);\r\n}\r\nstatic int unix_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct sock *sk = sock->sk;\r\nlong amount = 0;\r\nint err;\r\nswitch (cmd) {\r\ncase SIOCOUTQ:\r\namount = unix_outq_len(sk);\r\nerr = put_user(amount, (int __user *)arg);\r\nbreak;\r\ncase SIOCINQ:\r\namount = unix_inq_len(sk);\r\nif (amount < 0)\r\nerr = amount;\r\nelse\r\nerr = put_user(amount, (int __user *)arg);\r\nbreak;\r\ndefault:\r\nerr = -ENOIOCTLCMD;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic unsigned int unix_poll(struct file *file, struct socket *sock, poll_table *wait)\r\n{\r\nstruct sock *sk = sock->sk;\r\nunsigned int mask;\r\nsock_poll_wait(file, sk_sleep(sk), wait);\r\nmask = 0;\r\nif (sk->sk_err)\r\nmask |= POLLERR;\r\nif (sk->sk_shutdown == SHUTDOWN_MASK)\r\nmask |= POLLHUP;\r\nif (sk->sk_shutdown & RCV_SHUTDOWN)\r\nmask |= POLLRDHUP | POLLIN | POLLRDNORM;\r\nif (!skb_queue_empty(&sk->sk_receive_queue))\r\nmask |= POLLIN | POLLRDNORM;\r\nif ((sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) &&\r\nsk->sk_state == TCP_CLOSE)\r\nmask |= POLLHUP;\r\nif (unix_writable(sk))\r\nmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\r\nreturn mask;\r\n}\r\nstatic unsigned int unix_dgram_poll(struct file *file, struct socket *sock,\r\npoll_table *wait)\r\n{\r\nstruct sock *sk = sock->sk, *other;\r\nunsigned int mask, writable;\r\nsock_poll_wait(file, sk_sleep(sk), wait);\r\nmask = 0;\r\nif (sk->sk_err || !skb_queue_empty(&sk->sk_error_queue))\r\nmask |= POLLERR |\r\n(sock_flag(sk, SOCK_SELECT_ERR_QUEUE) ? POLLPRI : 0);\r\nif (sk->sk_shutdown & RCV_SHUTDOWN)\r\nmask |= POLLRDHUP | POLLIN | POLLRDNORM;\r\nif (sk->sk_shutdown == SHUTDOWN_MASK)\r\nmask |= POLLHUP;\r\nif (!skb_queue_empty(&sk->sk_receive_queue))\r\nmask |= POLLIN | POLLRDNORM;\r\nif (sk->sk_type == SOCK_SEQPACKET) {\r\nif (sk->sk_state == TCP_CLOSE)\r\nmask |= POLLHUP;\r\nif (sk->sk_state == TCP_SYN_SENT)\r\nreturn mask;\r\n}\r\nif (!(poll_requested_events(wait) & (POLLWRBAND|POLLWRNORM|POLLOUT)))\r\nreturn mask;\r\nwritable = unix_writable(sk);\r\nother = unix_peer_get(sk);\r\nif (other) {\r\nif (unix_peer(other) != sk) {\r\nsock_poll_wait(file, &unix_sk(other)->peer_wait, wait);\r\nif (unix_recvq_full(other))\r\nwritable = 0;\r\n}\r\nsock_put(other);\r\n}\r\nif (writable)\r\nmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\r\nelse\r\nset_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);\r\nreturn mask;\r\n}\r\nstatic struct sock *unix_from_bucket(struct seq_file *seq, loff_t *pos)\r\n{\r\nunsigned long offset = get_offset(*pos);\r\nunsigned long bucket = get_bucket(*pos);\r\nstruct sock *sk;\r\nunsigned long count = 0;\r\nfor (sk = sk_head(&unix_socket_table[bucket]); sk; sk = sk_next(sk)) {\r\nif (sock_net(sk) != seq_file_net(seq))\r\ncontinue;\r\nif (++count == offset)\r\nbreak;\r\n}\r\nreturn sk;\r\n}\r\nstatic struct sock *unix_next_socket(struct seq_file *seq,\r\nstruct sock *sk,\r\nloff_t *pos)\r\n{\r\nunsigned long bucket;\r\nwhile (sk > (struct sock *)SEQ_START_TOKEN) {\r\nsk = sk_next(sk);\r\nif (!sk)\r\ngoto next_bucket;\r\nif (sock_net(sk) == seq_file_net(seq))\r\nreturn sk;\r\n}\r\ndo {\r\nsk = unix_from_bucket(seq, pos);\r\nif (sk)\r\nreturn sk;\r\nnext_bucket:\r\nbucket = get_bucket(*pos) + 1;\r\n*pos = set_bucket_offset(bucket, 1);\r\n} while (bucket < ARRAY_SIZE(unix_socket_table));\r\nreturn NULL;\r\n}\r\nstatic void *unix_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(unix_table_lock)\r\n{\r\nspin_lock(&unix_table_lock);\r\nif (!*pos)\r\nreturn SEQ_START_TOKEN;\r\nif (get_bucket(*pos) >= ARRAY_SIZE(unix_socket_table))\r\nreturn NULL;\r\nreturn unix_next_socket(seq, NULL, pos);\r\n}\r\nstatic void *unix_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\n++*pos;\r\nreturn unix_next_socket(seq, v, pos);\r\n}\r\nstatic void unix_seq_stop(struct seq_file *seq, void *v)\r\n__releases(unix_table_lock)\r\n{\r\nspin_unlock(&unix_table_lock);\r\n}\r\nstatic int unix_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq, "Num RefCount Protocol Flags Type St "\r\n"Inode Path\n");\r\nelse {\r\nstruct sock *s = v;\r\nstruct unix_sock *u = unix_sk(s);\r\nunix_state_lock(s);\r\nseq_printf(seq, "%pK: %08X %08X %08X %04X %02X %5lu",\r\ns,\r\natomic_read(&s->sk_refcnt),\r\n0,\r\ns->sk_state == TCP_LISTEN ? __SO_ACCEPTCON : 0,\r\ns->sk_type,\r\ns->sk_socket ?\r\n(s->sk_state == TCP_ESTABLISHED ? SS_CONNECTED : SS_UNCONNECTED) :\r\n(s->sk_state == TCP_ESTABLISHED ? SS_CONNECTING : SS_DISCONNECTING),\r\nsock_i_ino(s));\r\nif (u->addr) {\r\nint i, len;\r\nseq_putc(seq, ' ');\r\ni = 0;\r\nlen = u->addr->len - sizeof(short);\r\nif (!UNIX_ABSTRACT(s))\r\nlen--;\r\nelse {\r\nseq_putc(seq, '@');\r\ni++;\r\n}\r\nfor ( ; i < len; i++)\r\nseq_putc(seq, u->addr->name->sun_path[i]);\r\n}\r\nunix_state_unlock(s);\r\nseq_putc(seq, '\n');\r\n}\r\nreturn 0;\r\n}\r\nstatic int unix_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &unix_seq_ops,\r\nsizeof(struct seq_net_private));\r\n}\r\nstatic int __net_init unix_net_init(struct net *net)\r\n{\r\nint error = -ENOMEM;\r\nnet->unx.sysctl_max_dgram_qlen = 10;\r\nif (unix_sysctl_register(net))\r\ngoto out;\r\n#ifdef CONFIG_PROC_FS\r\nif (!proc_create("unix", 0, net->proc_net, &unix_seq_fops)) {\r\nunix_sysctl_unregister(net);\r\ngoto out;\r\n}\r\n#endif\r\nerror = 0;\r\nout:\r\nreturn error;\r\n}\r\nstatic void __net_exit unix_net_exit(struct net *net)\r\n{\r\nunix_sysctl_unregister(net);\r\nremove_proc_entry("unix", net->proc_net);\r\n}\r\nstatic int __init af_unix_init(void)\r\n{\r\nint rc = -1;\r\nBUILD_BUG_ON(sizeof(struct unix_skb_parms) > FIELD_SIZEOF(struct sk_buff, cb));\r\nrc = proto_register(&unix_proto, 1);\r\nif (rc != 0) {\r\npr_crit("%s: Cannot create unix_sock SLAB cache!\n", __func__);\r\ngoto out;\r\n}\r\nsock_register(&unix_family_ops);\r\nregister_pernet_subsys(&unix_net_ops);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void __exit af_unix_exit(void)\r\n{\r\nsock_unregister(PF_UNIX);\r\nproto_unregister(&unix_proto);\r\nunregister_pernet_subsys(&unix_net_ops);\r\n}
