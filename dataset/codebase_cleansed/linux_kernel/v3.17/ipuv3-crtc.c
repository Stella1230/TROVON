static void ipu_fb_enable(struct ipu_crtc *ipu_crtc)\r\n{\r\nstruct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);\r\nif (ipu_crtc->enabled)\r\nreturn;\r\nipu_dc_enable(ipu);\r\nipu_plane_enable(ipu_crtc->plane[0]);\r\nipu_dc_enable_channel(ipu_crtc->dc);\r\nipu_di_enable(ipu_crtc->di);\r\nipu_crtc->enabled = 1;\r\n}\r\nstatic void ipu_fb_disable(struct ipu_crtc *ipu_crtc)\r\n{\r\nstruct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);\r\nif (!ipu_crtc->enabled)\r\nreturn;\r\nipu_dc_disable_channel(ipu_crtc->dc);\r\nipu_di_disable(ipu_crtc->di);\r\nipu_plane_disable(ipu_crtc->plane[0]);\r\nipu_dc_disable(ipu);\r\nipu_crtc->enabled = 0;\r\n}\r\nstatic void ipu_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\r\ndev_dbg(ipu_crtc->dev, "%s mode: %d\n", __func__, mode);\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\nipu_fb_enable(ipu_crtc);\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ncase DRM_MODE_DPMS_OFF:\r\nipu_fb_disable(ipu_crtc);\r\nbreak;\r\n}\r\n}\r\nstatic int ipu_page_flip(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nstruct drm_pending_vblank_event *event,\r\nuint32_t page_flip_flags)\r\n{\r\nstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\r\nint ret;\r\nif (ipu_crtc->newfb)\r\nreturn -EBUSY;\r\nret = imx_drm_crtc_vblank_get(ipu_crtc->imx_crtc);\r\nif (ret) {\r\ndev_dbg(ipu_crtc->dev, "failed to acquire vblank counter\n");\r\nlist_del(&event->base.link);\r\nreturn ret;\r\n}\r\nipu_crtc->newfb = fb;\r\nipu_crtc->page_flip_event = event;\r\ncrtc->primary->fb = fb;\r\nreturn 0;\r\n}\r\nstatic int ipu_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *orig_mode,\r\nstruct drm_display_mode *mode,\r\nint x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\r\nint ret;\r\nstruct ipu_di_signal_cfg sig_cfg = {};\r\nu32 out_pixel_fmt;\r\ndev_dbg(ipu_crtc->dev, "%s: mode->hdisplay: %d\n", __func__,\r\nmode->hdisplay);\r\ndev_dbg(ipu_crtc->dev, "%s: mode->vdisplay: %d\n", __func__,\r\nmode->vdisplay);\r\nout_pixel_fmt = ipu_crtc->interface_pix_fmt;\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE)\r\nsig_cfg.interlaced = 1;\r\nif (mode->flags & DRM_MODE_FLAG_PHSYNC)\r\nsig_cfg.Hsync_pol = 1;\r\nif (mode->flags & DRM_MODE_FLAG_PVSYNC)\r\nsig_cfg.Vsync_pol = 1;\r\nsig_cfg.enable_pol = 1;\r\nsig_cfg.clk_pol = 0;\r\nsig_cfg.width = mode->hdisplay;\r\nsig_cfg.height = mode->vdisplay;\r\nsig_cfg.pixel_fmt = out_pixel_fmt;\r\nsig_cfg.h_start_width = mode->htotal - mode->hsync_end;\r\nsig_cfg.h_sync_width = mode->hsync_end - mode->hsync_start;\r\nsig_cfg.h_end_width = mode->hsync_start - mode->hdisplay;\r\nsig_cfg.v_start_width = mode->vtotal - mode->vsync_end;\r\nsig_cfg.v_sync_width = mode->vsync_end - mode->vsync_start;\r\nsig_cfg.v_end_width = mode->vsync_start - mode->vdisplay;\r\nsig_cfg.pixelclock = mode->clock * 1000;\r\nsig_cfg.clkflags = ipu_crtc->di_clkflags;\r\nsig_cfg.v_to_h_sync = 0;\r\nsig_cfg.hsync_pin = ipu_crtc->di_hsync_pin;\r\nsig_cfg.vsync_pin = ipu_crtc->di_vsync_pin;\r\nret = ipu_dc_init_sync(ipu_crtc->dc, ipu_crtc->di, sig_cfg.interlaced,\r\nout_pixel_fmt, mode->hdisplay);\r\nif (ret) {\r\ndev_err(ipu_crtc->dev,\r\n"initializing display controller failed with %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = ipu_di_init_sync_panel(ipu_crtc->di, &sig_cfg);\r\nif (ret) {\r\ndev_err(ipu_crtc->dev,\r\n"initializing panel failed with %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn ipu_plane_mode_set(ipu_crtc->plane[0], crtc, mode, crtc->primary->fb,\r\n0, 0, mode->hdisplay, mode->vdisplay,\r\nx, y, mode->hdisplay, mode->vdisplay);\r\n}\r\nstatic void ipu_crtc_handle_pageflip(struct ipu_crtc *ipu_crtc)\r\n{\r\nunsigned long flags;\r\nstruct drm_device *drm = ipu_crtc->base.dev;\r\nspin_lock_irqsave(&drm->event_lock, flags);\r\nif (ipu_crtc->page_flip_event)\r\ndrm_send_vblank_event(drm, -1, ipu_crtc->page_flip_event);\r\nipu_crtc->page_flip_event = NULL;\r\nimx_drm_crtc_vblank_put(ipu_crtc->imx_crtc);\r\nspin_unlock_irqrestore(&drm->event_lock, flags);\r\n}\r\nstatic irqreturn_t ipu_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct ipu_crtc *ipu_crtc = dev_id;\r\nimx_drm_handle_vblank(ipu_crtc->imx_crtc);\r\nif (ipu_crtc->newfb) {\r\nipu_crtc->newfb = NULL;\r\nipu_plane_set_base(ipu_crtc->plane[0], ipu_crtc->base.primary->fb,\r\nipu_crtc->plane[0]->x, ipu_crtc->plane[0]->y);\r\nipu_crtc_handle_pageflip(ipu_crtc);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic bool ipu_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void ipu_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\nstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\r\nipu_fb_disable(ipu_crtc);\r\n}\r\nstatic void ipu_crtc_commit(struct drm_crtc *crtc)\r\n{\r\nstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\r\nipu_fb_enable(ipu_crtc);\r\n}\r\nstatic int ipu_enable_vblank(struct drm_crtc *crtc)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ipu_disable_vblank(struct drm_crtc *crtc)\r\n{\r\nstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\r\nipu_crtc->page_flip_event = NULL;\r\nipu_crtc->newfb = NULL;\r\n}\r\nstatic int ipu_set_interface_pix_fmt(struct drm_crtc *crtc, u32 encoder_type,\r\nu32 pixfmt, int hsync_pin, int vsync_pin)\r\n{\r\nstruct ipu_crtc *ipu_crtc = to_ipu_crtc(crtc);\r\nipu_crtc->interface_pix_fmt = pixfmt;\r\nipu_crtc->di_hsync_pin = hsync_pin;\r\nipu_crtc->di_vsync_pin = vsync_pin;\r\nswitch (encoder_type) {\r\ncase DRM_MODE_ENCODER_DAC:\r\ncase DRM_MODE_ENCODER_TVDAC:\r\ncase DRM_MODE_ENCODER_LVDS:\r\nipu_crtc->di_clkflags = IPU_DI_CLKMODE_SYNC |\r\nIPU_DI_CLKMODE_EXT;\r\nbreak;\r\ncase DRM_MODE_ENCODER_TMDS:\r\ncase DRM_MODE_ENCODER_NONE:\r\nipu_crtc->di_clkflags = 0;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ipu_put_resources(struct ipu_crtc *ipu_crtc)\r\n{\r\nif (!IS_ERR_OR_NULL(ipu_crtc->dc))\r\nipu_dc_put(ipu_crtc->dc);\r\nif (!IS_ERR_OR_NULL(ipu_crtc->di))\r\nipu_di_put(ipu_crtc->di);\r\n}\r\nstatic int ipu_get_resources(struct ipu_crtc *ipu_crtc,\r\nstruct ipu_client_platformdata *pdata)\r\n{\r\nstruct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);\r\nint ret;\r\nipu_crtc->dc = ipu_dc_get(ipu, pdata->dc);\r\nif (IS_ERR(ipu_crtc->dc)) {\r\nret = PTR_ERR(ipu_crtc->dc);\r\ngoto err_out;\r\n}\r\nipu_crtc->di = ipu_di_get(ipu, pdata->di);\r\nif (IS_ERR(ipu_crtc->di)) {\r\nret = PTR_ERR(ipu_crtc->di);\r\ngoto err_out;\r\n}\r\nreturn 0;\r\nerr_out:\r\nipu_put_resources(ipu_crtc);\r\nreturn ret;\r\n}\r\nstatic int ipu_crtc_init(struct ipu_crtc *ipu_crtc,\r\nstruct ipu_client_platformdata *pdata, struct drm_device *drm)\r\n{\r\nstruct ipu_soc *ipu = dev_get_drvdata(ipu_crtc->dev->parent);\r\nint dp = -EINVAL;\r\nint ret;\r\nint id;\r\nret = ipu_get_resources(ipu_crtc, pdata);\r\nif (ret) {\r\ndev_err(ipu_crtc->dev, "getting resources failed with %d.\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = imx_drm_add_crtc(drm, &ipu_crtc->base, &ipu_crtc->imx_crtc,\r\n&ipu_crtc_helper_funcs, ipu_crtc->dev->of_node);\r\nif (ret) {\r\ndev_err(ipu_crtc->dev, "adding crtc failed with %d.\n", ret);\r\ngoto err_put_resources;\r\n}\r\nif (pdata->dp >= 0)\r\ndp = IPU_DP_FLOW_SYNC_BG;\r\nid = imx_drm_crtc_id(ipu_crtc->imx_crtc);\r\nipu_crtc->plane[0] = ipu_plane_init(ipu_crtc->base.dev, ipu,\r\npdata->dma[0], dp, BIT(id), true);\r\nret = ipu_plane_get_resources(ipu_crtc->plane[0]);\r\nif (ret) {\r\ndev_err(ipu_crtc->dev, "getting plane 0 resources failed with %d.\n",\r\nret);\r\ngoto err_remove_crtc;\r\n}\r\nif (pdata->dp >= 0 && pdata->dma[1] > 0) {\r\nipu_crtc->plane[1] = ipu_plane_init(ipu_crtc->base.dev, ipu,\r\npdata->dma[1],\r\nIPU_DP_FLOW_SYNC_FG,\r\nBIT(id), false);\r\nif (IS_ERR(ipu_crtc->plane[1]))\r\nipu_crtc->plane[1] = NULL;\r\n}\r\nipu_crtc->irq = ipu_plane_irq(ipu_crtc->plane[0]);\r\nret = devm_request_irq(ipu_crtc->dev, ipu_crtc->irq, ipu_irq_handler, 0,\r\n"imx_drm", ipu_crtc);\r\nif (ret < 0) {\r\ndev_err(ipu_crtc->dev, "irq request failed with %d.\n", ret);\r\ngoto err_put_plane_res;\r\n}\r\nreturn 0;\r\nerr_put_plane_res:\r\nipu_plane_put_resources(ipu_crtc->plane[0]);\r\nerr_remove_crtc:\r\nimx_drm_remove_crtc(ipu_crtc->imx_crtc);\r\nerr_put_resources:\r\nipu_put_resources(ipu_crtc);\r\nreturn ret;\r\n}\r\nstatic struct device_node *ipu_drm_get_port_by_id(struct device_node *parent,\r\nint port_id)\r\n{\r\nstruct device_node *port;\r\nint id, ret;\r\nport = of_get_child_by_name(parent, "port");\r\nwhile (port) {\r\nret = of_property_read_u32(port, "reg", &id);\r\nif (!ret && id == port_id)\r\nreturn port;\r\ndo {\r\nport = of_get_next_child(parent, port);\r\nif (!port)\r\nreturn NULL;\r\n} while (of_node_cmp(port->name, "port"));\r\n}\r\nreturn NULL;\r\n}\r\nstatic int ipu_drm_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct ipu_client_platformdata *pdata = dev->platform_data;\r\nstruct drm_device *drm = data;\r\nstruct ipu_crtc *ipu_crtc;\r\nint ret;\r\nipu_crtc = devm_kzalloc(dev, sizeof(*ipu_crtc), GFP_KERNEL);\r\nif (!ipu_crtc)\r\nreturn -ENOMEM;\r\nipu_crtc->dev = dev;\r\nret = ipu_crtc_init(ipu_crtc, pdata, drm);\r\nif (ret)\r\nreturn ret;\r\ndev_set_drvdata(dev, ipu_crtc);\r\nreturn 0;\r\n}\r\nstatic void ipu_drm_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct ipu_crtc *ipu_crtc = dev_get_drvdata(dev);\r\nimx_drm_remove_crtc(ipu_crtc->imx_crtc);\r\nipu_plane_put_resources(ipu_crtc->plane[0]);\r\nipu_put_resources(ipu_crtc);\r\n}\r\nstatic int ipu_drm_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ipu_client_platformdata *pdata = dev->platform_data;\r\nint ret;\r\nif (!dev->platform_data)\r\nreturn -EINVAL;\r\nif (!dev->of_node) {\r\ndev->of_node = ipu_drm_get_port_by_id(dev->parent->of_node,\r\npdata->di + 2);\r\nif (!dev->of_node) {\r\ndev_err(dev, "missing port@%d node in %s\n",\r\npdata->di + 2, dev->parent->of_node->full_name);\r\nreturn -ENODEV;\r\n}\r\n}\r\nret = dma_set_coherent_mask(dev, DMA_BIT_MASK(32));\r\nif (ret)\r\nreturn ret;\r\nreturn component_add(dev, &ipu_crtc_ops);\r\n}\r\nstatic int ipu_drm_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &ipu_crtc_ops);\r\nreturn 0;\r\n}
