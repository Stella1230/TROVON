static void poly_step_func(u64 *ahi, u64 *alo,\r\nconst u64 *kh, const u64 *kl,\r\nconst u64 *mh, const u64 *ml)\r\n{\r\n#define a0 (*(((u32 *)alo)+INDEX_LOW))\r\n#define a1 (*(((u32 *)alo)+INDEX_HIGH))\r\n#define a2 (*(((u32 *)ahi)+INDEX_LOW))\r\n#define a3 (*(((u32 *)ahi)+INDEX_HIGH))\r\n#define k0 (*(((u32 *)kl)+INDEX_LOW))\r\n#define k1 (*(((u32 *)kl)+INDEX_HIGH))\r\n#define k2 (*(((u32 *)kh)+INDEX_LOW))\r\n#define k3 (*(((u32 *)kh)+INDEX_HIGH))\r\nu64 p, q, t;\r\nu32 t2;\r\np = MUL32(a3, k3);\r\np += p;\r\np += *(u64 *)mh;\r\np += MUL32(a0, k2);\r\np += MUL32(a1, k1);\r\np += MUL32(a2, k0);\r\nt = (u32)(p);\r\np >>= 32;\r\np += MUL32(a0, k3);\r\np += MUL32(a1, k2);\r\np += MUL32(a2, k1);\r\np += MUL32(a3, k0);\r\nt |= ((u64)((u32)p & 0x7fffffff)) << 32;\r\np >>= 31;\r\np += (u64)(((u32 *)ml)[INDEX_LOW]);\r\np += MUL32(a0, k0);\r\nq = MUL32(a1, k3);\r\nq += MUL32(a2, k2);\r\nq += MUL32(a3, k1);\r\nq += q;\r\np += q;\r\nt2 = (u32)(p);\r\np >>= 32;\r\np += (u64)(((u32 *)ml)[INDEX_HIGH]);\r\np += MUL32(a0, k1);\r\np += MUL32(a1, k0);\r\nq = MUL32(a2, k3);\r\nq += MUL32(a3, k2);\r\nq += q;\r\np += q;\r\n*(u64 *)(alo) = (p << 32) | t2;\r\np >>= 32;\r\n*(u64 *)(ahi) = p + t;\r\n#undef a0\r\n#undef a1\r\n#undef a2\r\n#undef a3\r\n#undef k0\r\n#undef k1\r\n#undef k2\r\n#undef k3\r\n}\r\nstatic void vhash_abort(struct vmac_ctx *ctx)\r\n{\r\nctx->polytmp[0] = ctx->polykey[0] ;\r\nctx->polytmp[1] = ctx->polykey[1] ;\r\nctx->first_block_processed = 0;\r\n}\r\nstatic u64 l3hash(u64 p1, u64 p2, u64 k1, u64 k2, u64 len)\r\n{\r\nu64 rh, rl, t, z = 0;\r\nt = p1 >> 63;\r\np1 &= m63;\r\nADD128(p1, p2, len, t);\r\nt = (p1 > m63) + ((p1 == m63) && (p2 == m64));\r\nADD128(p1, p2, z, t);\r\np1 &= m63;\r\nt = p1 + (p2 >> 32);\r\nt += (t >> 32);\r\nt += (u32)t > 0xfffffffeu;\r\np1 += (t >> 32);\r\np2 += (p1 << 32);\r\np1 += k1;\r\np1 += (0 - (p1 < k1)) & 257;\r\np2 += k2;\r\np2 += (0 - (p2 < k2)) & 257;\r\nMUL64(rh, rl, p1, p2);\r\nt = rh >> 56;\r\nADD128(t, rl, z, rh);\r\nrh <<= 8;\r\nADD128(t, rl, z, rh);\r\nt += t << 8;\r\nrl += t;\r\nrl += (0 - (rl < t)) & 257;\r\nrl += (0 - (rl > p64-1)) & 257;\r\nreturn rl;\r\n}\r\nstatic void vhash_update(const unsigned char *m,\r\nunsigned int mbytes,\r\nstruct vmac_ctx *ctx)\r\n{\r\nu64 rh, rl, *mptr;\r\nconst u64 *kptr = (u64 *)ctx->nhkey;\r\nint i;\r\nu64 ch, cl;\r\nu64 pkh = ctx->polykey[0];\r\nu64 pkl = ctx->polykey[1];\r\nif (!mbytes)\r\nreturn;\r\nBUG_ON(mbytes % VMAC_NHBYTES);\r\nmptr = (u64 *)m;\r\ni = mbytes / VMAC_NHBYTES;\r\nch = ctx->polytmp[0];\r\ncl = ctx->polytmp[1];\r\nif (!ctx->first_block_processed) {\r\nctx->first_block_processed = 1;\r\nnh_vmac_nhbytes(mptr, kptr, VMAC_NHBYTES/8, rh, rl);\r\nrh &= m62;\r\nADD128(ch, cl, rh, rl);\r\nmptr += (VMAC_NHBYTES/sizeof(u64));\r\ni--;\r\n}\r\nwhile (i--) {\r\nnh_vmac_nhbytes(mptr, kptr, VMAC_NHBYTES/8, rh, rl);\r\nrh &= m62;\r\npoly_step(ch, cl, pkh, pkl, rh, rl);\r\nmptr += (VMAC_NHBYTES/sizeof(u64));\r\n}\r\nctx->polytmp[0] = ch;\r\nctx->polytmp[1] = cl;\r\n}\r\nstatic u64 vhash(unsigned char m[], unsigned int mbytes,\r\nu64 *tagl, struct vmac_ctx *ctx)\r\n{\r\nu64 rh, rl, *mptr;\r\nconst u64 *kptr = (u64 *)ctx->nhkey;\r\nint i, remaining;\r\nu64 ch, cl;\r\nu64 pkh = ctx->polykey[0];\r\nu64 pkl = ctx->polykey[1];\r\nmptr = (u64 *)m;\r\ni = mbytes / VMAC_NHBYTES;\r\nremaining = mbytes % VMAC_NHBYTES;\r\nif (ctx->first_block_processed) {\r\nch = ctx->polytmp[0];\r\ncl = ctx->polytmp[1];\r\n} else if (i) {\r\nnh_vmac_nhbytes(mptr, kptr, VMAC_NHBYTES/8, ch, cl);\r\nch &= m62;\r\nADD128(ch, cl, pkh, pkl);\r\nmptr += (VMAC_NHBYTES/sizeof(u64));\r\ni--;\r\n} else if (remaining) {\r\nnh_16(mptr, kptr, 2*((remaining+15)/16), ch, cl);\r\nch &= m62;\r\nADD128(ch, cl, pkh, pkl);\r\nmptr += (VMAC_NHBYTES/sizeof(u64));\r\ngoto do_l3;\r\n} else {\r\nch = pkh; cl = pkl;\r\ngoto do_l3;\r\n}\r\nwhile (i--) {\r\nnh_vmac_nhbytes(mptr, kptr, VMAC_NHBYTES/8, rh, rl);\r\nrh &= m62;\r\npoly_step(ch, cl, pkh, pkl, rh, rl);\r\nmptr += (VMAC_NHBYTES/sizeof(u64));\r\n}\r\nif (remaining) {\r\nnh_16(mptr, kptr, 2*((remaining+15)/16), rh, rl);\r\nrh &= m62;\r\npoly_step(ch, cl, pkh, pkl, rh, rl);\r\n}\r\ndo_l3:\r\nvhash_abort(ctx);\r\nremaining *= 8;\r\nreturn l3hash(ch, cl, ctx->l3key[0], ctx->l3key[1], remaining);\r\n}\r\nstatic u64 vmac(unsigned char m[], unsigned int mbytes,\r\nconst unsigned char n[16], u64 *tagl,\r\nstruct vmac_ctx_t *ctx)\r\n{\r\nu64 *in_n, *out_p;\r\nu64 p, h;\r\nint i;\r\nin_n = ctx->__vmac_ctx.cached_nonce;\r\nout_p = ctx->__vmac_ctx.cached_aes;\r\ni = n[15] & 1;\r\nif ((*(u64 *)(n+8) != in_n[1]) || (*(u64 *)(n) != in_n[0])) {\r\nin_n[0] = *(u64 *)(n);\r\nin_n[1] = *(u64 *)(n+8);\r\n((unsigned char *)in_n)[15] &= 0xFE;\r\ncrypto_cipher_encrypt_one(ctx->child,\r\n(unsigned char *)out_p, (unsigned char *)in_n);\r\n((unsigned char *)in_n)[15] |= (unsigned char)(1-i);\r\n}\r\np = be64_to_cpup(out_p + i);\r\nh = vhash(m, mbytes, (u64 *)0, &ctx->__vmac_ctx);\r\nreturn le64_to_cpu(p + h);\r\n}\r\nstatic int vmac_set_key(unsigned char user_key[], struct vmac_ctx_t *ctx)\r\n{\r\nu64 in[2] = {0}, out[2];\r\nunsigned i;\r\nint err = 0;\r\nerr = crypto_cipher_setkey(ctx->child, user_key, VMAC_KEY_LEN);\r\nif (err)\r\nreturn err;\r\n((unsigned char *)in)[0] = 0x80;\r\nfor (i = 0; i < sizeof(ctx->__vmac_ctx.nhkey)/8; i += 2) {\r\ncrypto_cipher_encrypt_one(ctx->child,\r\n(unsigned char *)out, (unsigned char *)in);\r\nctx->__vmac_ctx.nhkey[i] = be64_to_cpup(out);\r\nctx->__vmac_ctx.nhkey[i+1] = be64_to_cpup(out+1);\r\n((unsigned char *)in)[15] += 1;\r\n}\r\n((unsigned char *)in)[0] = 0xC0;\r\nin[1] = 0;\r\nfor (i = 0; i < sizeof(ctx->__vmac_ctx.polykey)/8; i += 2) {\r\ncrypto_cipher_encrypt_one(ctx->child,\r\n(unsigned char *)out, (unsigned char *)in);\r\nctx->__vmac_ctx.polytmp[i] =\r\nctx->__vmac_ctx.polykey[i] =\r\nbe64_to_cpup(out) & mpoly;\r\nctx->__vmac_ctx.polytmp[i+1] =\r\nctx->__vmac_ctx.polykey[i+1] =\r\nbe64_to_cpup(out+1) & mpoly;\r\n((unsigned char *)in)[15] += 1;\r\n}\r\n((unsigned char *)in)[0] = 0xE0;\r\nin[1] = 0;\r\nfor (i = 0; i < sizeof(ctx->__vmac_ctx.l3key)/8; i += 2) {\r\ndo {\r\ncrypto_cipher_encrypt_one(ctx->child,\r\n(unsigned char *)out, (unsigned char *)in);\r\nctx->__vmac_ctx.l3key[i] = be64_to_cpup(out);\r\nctx->__vmac_ctx.l3key[i+1] = be64_to_cpup(out+1);\r\n((unsigned char *)in)[15] += 1;\r\n} while (ctx->__vmac_ctx.l3key[i] >= p64\r\n|| ctx->__vmac_ctx.l3key[i+1] >= p64);\r\n}\r\nctx->__vmac_ctx.cached_nonce[0] = (u64)-1;\r\nctx->__vmac_ctx.cached_nonce[1] = (u64)0;\r\nctx->__vmac_ctx.first_block_processed = 0;\r\nreturn err;\r\n}\r\nstatic int vmac_setkey(struct crypto_shash *parent,\r\nconst u8 *key, unsigned int keylen)\r\n{\r\nstruct vmac_ctx_t *ctx = crypto_shash_ctx(parent);\r\nif (keylen != VMAC_KEY_LEN) {\r\ncrypto_shash_set_flags(parent, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nreturn vmac_set_key((u8 *)key, ctx);\r\n}\r\nstatic int vmac_init(struct shash_desc *pdesc)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vmac_update(struct shash_desc *pdesc, const u8 *p,\r\nunsigned int len)\r\n{\r\nstruct crypto_shash *parent = pdesc->tfm;\r\nstruct vmac_ctx_t *ctx = crypto_shash_ctx(parent);\r\nint expand;\r\nint min;\r\nexpand = VMAC_NHBYTES - ctx->partial_size > 0 ?\r\nVMAC_NHBYTES - ctx->partial_size : 0;\r\nmin = len < expand ? len : expand;\r\nmemcpy(ctx->partial + ctx->partial_size, p, min);\r\nctx->partial_size += min;\r\nif (len < expand)\r\nreturn 0;\r\nvhash_update(ctx->partial, VMAC_NHBYTES, &ctx->__vmac_ctx);\r\nctx->partial_size = 0;\r\nlen -= expand;\r\np += expand;\r\nif (len % VMAC_NHBYTES) {\r\nmemcpy(ctx->partial, p + len - (len % VMAC_NHBYTES),\r\nlen % VMAC_NHBYTES);\r\nctx->partial_size = len % VMAC_NHBYTES;\r\n}\r\nvhash_update(p, len - len % VMAC_NHBYTES, &ctx->__vmac_ctx);\r\nreturn 0;\r\n}\r\nstatic int vmac_final(struct shash_desc *pdesc, u8 *out)\r\n{\r\nstruct crypto_shash *parent = pdesc->tfm;\r\nstruct vmac_ctx_t *ctx = crypto_shash_ctx(parent);\r\nvmac_t mac;\r\nu8 nonce[16] = {};\r\nif (ctx->partial_size) {\r\nmemset(ctx->partial + ctx->partial_size, 0,\r\nVMAC_NHBYTES - ctx->partial_size);\r\n}\r\nmac = vmac(ctx->partial, ctx->partial_size, nonce, NULL, ctx);\r\nmemcpy(out, &mac, sizeof(vmac_t));\r\nmemset(&mac, 0, sizeof(vmac_t));\r\nmemset(&ctx->__vmac_ctx, 0, sizeof(struct vmac_ctx));\r\nctx->partial_size = 0;\r\nreturn 0;\r\n}\r\nstatic int vmac_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_cipher *cipher;\r\nstruct crypto_instance *inst = (void *)tfm->__crt_alg;\r\nstruct crypto_spawn *spawn = crypto_instance_ctx(inst);\r\nstruct vmac_ctx_t *ctx = crypto_tfm_ctx(tfm);\r\ncipher = crypto_spawn_cipher(spawn);\r\nif (IS_ERR(cipher))\r\nreturn PTR_ERR(cipher);\r\nctx->child = cipher;\r\nreturn 0;\r\n}\r\nstatic void vmac_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct vmac_ctx_t *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_cipher(ctx->child);\r\n}\r\nstatic int vmac_create(struct crypto_template *tmpl, struct rtattr **tb)\r\n{\r\nstruct shash_instance *inst;\r\nstruct crypto_alg *alg;\r\nint err;\r\nerr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH);\r\nif (err)\r\nreturn err;\r\nalg = crypto_get_attr_alg(tb, CRYPTO_ALG_TYPE_CIPHER,\r\nCRYPTO_ALG_TYPE_MASK);\r\nif (IS_ERR(alg))\r\nreturn PTR_ERR(alg);\r\ninst = shash_alloc_instance("vmac", alg);\r\nerr = PTR_ERR(inst);\r\nif (IS_ERR(inst))\r\ngoto out_put_alg;\r\nerr = crypto_init_spawn(shash_instance_ctx(inst), alg,\r\nshash_crypto_instance(inst),\r\nCRYPTO_ALG_TYPE_MASK);\r\nif (err)\r\ngoto out_free_inst;\r\ninst->alg.base.cra_priority = alg->cra_priority;\r\ninst->alg.base.cra_blocksize = alg->cra_blocksize;\r\ninst->alg.base.cra_alignmask = alg->cra_alignmask;\r\ninst->alg.digestsize = sizeof(vmac_t);\r\ninst->alg.base.cra_ctxsize = sizeof(struct vmac_ctx_t);\r\ninst->alg.base.cra_init = vmac_init_tfm;\r\ninst->alg.base.cra_exit = vmac_exit_tfm;\r\ninst->alg.init = vmac_init;\r\ninst->alg.update = vmac_update;\r\ninst->alg.final = vmac_final;\r\ninst->alg.setkey = vmac_setkey;\r\nerr = shash_register_instance(tmpl, inst);\r\nif (err) {\r\nout_free_inst:\r\nshash_free_instance(shash_crypto_instance(inst));\r\n}\r\nout_put_alg:\r\ncrypto_mod_put(alg);\r\nreturn err;\r\n}\r\nstatic int __init vmac_module_init(void)\r\n{\r\nreturn crypto_register_template(&vmac_tmpl);\r\n}\r\nstatic void __exit vmac_module_exit(void)\r\n{\r\ncrypto_unregister_template(&vmac_tmpl);\r\n}
