static void\r\nast_enable_vga(struct drm_device *dev)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nast_io_write8(ast, 0x43, 0x01);\r\nast_io_write8(ast, 0x42, 0x01);\r\n}\r\nstatic void\r\nast_set_def_ext_reg(struct drm_device *dev)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nu8 i, index, reg;\r\nconst u8 *ext_reg_info;\r\nfor (i = 0x81; i <= 0x8f; i++)\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, i, 0x00);\r\nif (ast->chip == AST2300 || ast->chip == AST2400) {\r\nif (dev->pdev->revision >= 0x20)\r\next_reg_info = extreginfo_ast2300;\r\nelse\r\next_reg_info = extreginfo_ast2300a0;\r\n} else\r\next_reg_info = extreginfo;\r\nindex = 0xa0;\r\nwhile (*ext_reg_info != 0xff) {\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, index, 0x00, *ext_reg_info);\r\nindex++;\r\next_reg_info++;\r\n}\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x8c, 0x00, 0x01);\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb7, 0x00, 0x00);\r\nreg = 0x04;\r\nif (ast->chip == AST2300 || ast->chip == AST2400)\r\nreg |= 0x20;\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb6, 0xff, reg);\r\n}\r\nu32 ast_mindwm(struct ast_private *ast, u32 r)\r\n{\r\nuint32_t data;\r\nast_write32(ast, 0xf004, r & 0xffff0000);\r\nast_write32(ast, 0xf000, 0x1);\r\ndo {\r\ndata = ast_read32(ast, 0xf004) & 0xffff0000;\r\n} while (data != (r & 0xffff0000));\r\nreturn ast_read32(ast, 0x10000 + (r & 0x0000ffff));\r\n}\r\nvoid ast_moutdwm(struct ast_private *ast, u32 r, u32 v)\r\n{\r\nuint32_t data;\r\nast_write32(ast, 0xf004, r & 0xffff0000);\r\nast_write32(ast, 0xf000, 0x1);\r\ndo {\r\ndata = ast_read32(ast, 0xf004) & 0xffff0000;\r\n} while (data != (r & 0xffff0000));\r\nast_write32(ast, 0x10000 + (r & 0x0000ffff), v);\r\n}\r\nstatic u32 mmctestburst2_ast2150(struct ast_private *ast, u32 datagen)\r\n{\r\nu32 data, timeout;\r\nast_moutdwm(ast, 0x1e6e0070, 0x00000000);\r\nast_moutdwm(ast, 0x1e6e0070, 0x00000001 | (datagen << 3));\r\ntimeout = 0;\r\ndo {\r\ndata = ast_mindwm(ast, 0x1e6e0070) & 0x40;\r\nif (++timeout > TIMEOUT_AST2150) {\r\nast_moutdwm(ast, 0x1e6e0070, 0x00000000);\r\nreturn 0xffffffff;\r\n}\r\n} while (!data);\r\nast_moutdwm(ast, 0x1e6e0070, 0x00000000);\r\nast_moutdwm(ast, 0x1e6e0070, 0x00000003 | (datagen << 3));\r\ntimeout = 0;\r\ndo {\r\ndata = ast_mindwm(ast, 0x1e6e0070) & 0x40;\r\nif (++timeout > TIMEOUT_AST2150) {\r\nast_moutdwm(ast, 0x1e6e0070, 0x00000000);\r\nreturn 0xffffffff;\r\n}\r\n} while (!data);\r\ndata = (ast_mindwm(ast, 0x1e6e0070) & 0x80) >> 7;\r\nast_moutdwm(ast, 0x1e6e0070, 0x00000000);\r\nreturn data;\r\n}\r\nstatic int cbrtest_ast2150(struct ast_private *ast)\r\n{\r\nint i;\r\nfor (i = 0; i < 8; i++)\r\nif (mmctestburst2_ast2150(ast, i))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int cbrscan_ast2150(struct ast_private *ast, int busw)\r\n{\r\nu32 patcnt, loop;\r\nfor (patcnt = 0; patcnt < CBR_PATNUM_AST2150; patcnt++) {\r\nast_moutdwm(ast, 0x1e6e007c, pattern_AST2150[patcnt]);\r\nfor (loop = 0; loop < CBR_PASSNUM_AST2150; loop++) {\r\nif (cbrtest_ast2150(ast))\r\nbreak;\r\n}\r\nif (loop == CBR_PASSNUM_AST2150)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void cbrdlli_ast2150(struct ast_private *ast, int busw)\r\n{\r\nu32 dll_min[4], dll_max[4], dlli, data, passcnt;\r\ncbr_start:\r\ndll_min[0] = dll_min[1] = dll_min[2] = dll_min[3] = 0xff;\r\ndll_max[0] = dll_max[1] = dll_max[2] = dll_max[3] = 0x0;\r\npasscnt = 0;\r\nfor (dlli = 0; dlli < 100; dlli++) {\r\nast_moutdwm(ast, 0x1e6e0068, dlli | (dlli << 8) | (dlli << 16) | (dlli << 24));\r\ndata = cbrscan_ast2150(ast, busw);\r\nif (data != 0) {\r\nif (data & 0x1) {\r\nif (dll_min[0] > dlli)\r\ndll_min[0] = dlli;\r\nif (dll_max[0] < dlli)\r\ndll_max[0] = dlli;\r\n}\r\npasscnt++;\r\n} else if (passcnt >= CBR_THRESHOLD_AST2150)\r\ngoto cbr_start;\r\n}\r\nif (dll_max[0] == 0 || (dll_max[0]-dll_min[0]) < CBR_THRESHOLD_AST2150)\r\ngoto cbr_start;\r\ndlli = dll_min[0] + (((dll_max[0] - dll_min[0]) * 7) >> 4);\r\nast_moutdwm(ast, 0x1e6e0068, dlli | (dlli << 8) | (dlli << 16) | (dlli << 24));\r\n}\r\nstatic void ast_init_dram_reg(struct drm_device *dev)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nu8 j;\r\nu32 data, temp, i;\r\nconst struct ast_dramstruct *dram_reg_info;\r\nj = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd0, 0xff);\r\nif ((j & 0x80) == 0) {\r\nif (ast->chip == AST2000) {\r\ndram_reg_info = ast2000_dram_table_data;\r\nast_write32(ast, 0xf004, 0x1e6e0000);\r\nast_write32(ast, 0xf000, 0x1);\r\nast_write32(ast, 0x10100, 0xa8);\r\ndo {\r\n;\r\n} while (ast_read32(ast, 0x10100) != 0xa8);\r\n} else {\r\nif (ast->chip == AST2100 || ast->chip == 2200)\r\ndram_reg_info = ast2100_dram_table_data;\r\nelse\r\ndram_reg_info = ast1100_dram_table_data;\r\nast_write32(ast, 0xf004, 0x1e6e0000);\r\nast_write32(ast, 0xf000, 0x1);\r\nast_write32(ast, 0x12000, 0x1688A8A8);\r\ndo {\r\n;\r\n} while (ast_read32(ast, 0x12000) != 0x01);\r\nast_write32(ast, 0x10000, 0xfc600309);\r\ndo {\r\n;\r\n} while (ast_read32(ast, 0x10000) != 0x01);\r\n}\r\nwhile (dram_reg_info->index != 0xffff) {\r\nif (dram_reg_info->index == 0xff00) {\r\nfor (i = 0; i < 15; i++)\r\nudelay(dram_reg_info->data);\r\n} else if (dram_reg_info->index == 0x4 && ast->chip != AST2000) {\r\ndata = dram_reg_info->data;\r\nif (ast->dram_type == AST_DRAM_1Gx16)\r\ndata = 0x00000d89;\r\nelse if (ast->dram_type == AST_DRAM_1Gx32)\r\ndata = 0x00000c8d;\r\ntemp = ast_read32(ast, 0x12070);\r\ntemp &= 0xc;\r\ntemp <<= 2;\r\nast_write32(ast, 0x10000 + dram_reg_info->index, data | temp);\r\n} else\r\nast_write32(ast, 0x10000 + dram_reg_info->index, dram_reg_info->data);\r\ndram_reg_info++;\r\n}\r\ndata = ast_read32(ast, 0x10120);\r\nif (data == 0x5061) {\r\ndata = ast_read32(ast, 0x10004);\r\nif (data & 0x40)\r\ncbrdlli_ast2150(ast, 16);\r\nelse\r\ncbrdlli_ast2150(ast, 32);\r\n}\r\nswitch (ast->chip) {\r\ncase AST2000:\r\ntemp = ast_read32(ast, 0x10140);\r\nast_write32(ast, 0x10140, temp | 0x40);\r\nbreak;\r\ncase AST1100:\r\ncase AST2100:\r\ncase AST2200:\r\ncase AST2150:\r\ntemp = ast_read32(ast, 0x1200c);\r\nast_write32(ast, 0x1200c, temp & 0xfffffffd);\r\ntemp = ast_read32(ast, 0x12040);\r\nast_write32(ast, 0x12040, temp | 0x40);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ndo {\r\nj = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd0, 0xff);\r\n} while ((j & 0x40) == 0);\r\n}\r\nvoid ast_post_gpu(struct drm_device *dev)\r\n{\r\nu32 reg;\r\nstruct ast_private *ast = dev->dev_private;\r\npci_read_config_dword(ast->dev->pdev, 0x04, &reg);\r\nreg |= 0x3;\r\npci_write_config_dword(ast->dev->pdev, 0x04, reg);\r\nast_enable_vga(dev);\r\nast_open_key(ast);\r\nast_set_def_ext_reg(dev);\r\nif (ast->chip == AST2300 || ast->chip == AST2400)\r\nast_init_dram_2300(dev);\r\nelse\r\nast_init_dram_reg(dev);\r\nast_init_3rdtx(dev);\r\n}\r\nstatic int mmc_test_burst(struct ast_private *ast, u32 datagen)\r\n{\r\nu32 data, timeout;\r\nast_moutdwm(ast, 0x1e6e0070, 0x00000000);\r\nast_moutdwm(ast, 0x1e6e0070, 0x000000c1 | (datagen << 3));\r\ntimeout = 0;\r\ndo {\r\ndata = ast_mindwm(ast, 0x1e6e0070) & 0x3000;\r\nif (data & 0x2000) {\r\nreturn 0;\r\n}\r\nif (++timeout > TIMEOUT) {\r\nast_moutdwm(ast, 0x1e6e0070, 0x00000000);\r\nreturn 0;\r\n}\r\n} while (!data);\r\nast_moutdwm(ast, 0x1e6e0070, 0x00000000);\r\nreturn 1;\r\n}\r\nstatic int mmc_test_burst2(struct ast_private *ast, u32 datagen)\r\n{\r\nu32 data, timeout;\r\nast_moutdwm(ast, 0x1e6e0070, 0x00000000);\r\nast_moutdwm(ast, 0x1e6e0070, 0x00000041 | (datagen << 3));\r\ntimeout = 0;\r\ndo {\r\ndata = ast_mindwm(ast, 0x1e6e0070) & 0x1000;\r\nif (++timeout > TIMEOUT) {\r\nast_moutdwm(ast, 0x1e6e0070, 0x0);\r\nreturn -1;\r\n}\r\n} while (!data);\r\ndata = ast_mindwm(ast, 0x1e6e0078);\r\ndata = (data | (data >> 16)) & 0xffff;\r\nast_moutdwm(ast, 0x1e6e0070, 0x0);\r\nreturn data;\r\n}\r\nstatic int mmc_test_single(struct ast_private *ast, u32 datagen)\r\n{\r\nu32 data, timeout;\r\nast_moutdwm(ast, 0x1e6e0070, 0x00000000);\r\nast_moutdwm(ast, 0x1e6e0070, 0x000000c5 | (datagen << 3));\r\ntimeout = 0;\r\ndo {\r\ndata = ast_mindwm(ast, 0x1e6e0070) & 0x3000;\r\nif (data & 0x2000)\r\nreturn 0;\r\nif (++timeout > TIMEOUT) {\r\nast_moutdwm(ast, 0x1e6e0070, 0x0);\r\nreturn 0;\r\n}\r\n} while (!data);\r\nast_moutdwm(ast, 0x1e6e0070, 0x0);\r\nreturn 1;\r\n}\r\nstatic int mmc_test_single2(struct ast_private *ast, u32 datagen)\r\n{\r\nu32 data, timeout;\r\nast_moutdwm(ast, 0x1e6e0070, 0x00000000);\r\nast_moutdwm(ast, 0x1e6e0070, 0x00000005 | (datagen << 3));\r\ntimeout = 0;\r\ndo {\r\ndata = ast_mindwm(ast, 0x1e6e0070) & 0x1000;\r\nif (++timeout > TIMEOUT) {\r\nast_moutdwm(ast, 0x1e6e0070, 0x0);\r\nreturn -1;\r\n}\r\n} while (!data);\r\ndata = ast_mindwm(ast, 0x1e6e0078);\r\ndata = (data | (data >> 16)) & 0xffff;\r\nast_moutdwm(ast, 0x1e6e0070, 0x0);\r\nreturn data;\r\n}\r\nstatic int cbr_test(struct ast_private *ast)\r\n{\r\nu32 data;\r\nint i;\r\ndata = mmc_test_single2(ast, 0);\r\nif ((data & 0xff) && (data & 0xff00))\r\nreturn 0;\r\nfor (i = 0; i < 8; i++) {\r\ndata = mmc_test_burst2(ast, i);\r\nif ((data & 0xff) && (data & 0xff00))\r\nreturn 0;\r\n}\r\nif (!data)\r\nreturn 3;\r\nelse if (data & 0xff)\r\nreturn 2;\r\nreturn 1;\r\n}\r\nstatic int cbr_scan(struct ast_private *ast)\r\n{\r\nu32 data, data2, patcnt, loop;\r\ndata2 = 3;\r\nfor (patcnt = 0; patcnt < CBR_PATNUM; patcnt++) {\r\nast_moutdwm(ast, 0x1e6e007c, pattern[patcnt]);\r\nfor (loop = 0; loop < CBR_PASSNUM2; loop++) {\r\nif ((data = cbr_test(ast)) != 0) {\r\ndata2 &= data;\r\nif (!data2)\r\nreturn 0;\r\nbreak;\r\n}\r\n}\r\nif (loop == CBR_PASSNUM2)\r\nreturn 0;\r\n}\r\nreturn data2;\r\n}\r\nstatic u32 cbr_test2(struct ast_private *ast)\r\n{\r\nu32 data;\r\ndata = mmc_test_burst2(ast, 0);\r\nif (data == 0xffff)\r\nreturn 0;\r\ndata |= mmc_test_single2(ast, 0);\r\nif (data == 0xffff)\r\nreturn 0;\r\nreturn ~data & 0xffff;\r\n}\r\nstatic u32 cbr_scan2(struct ast_private *ast)\r\n{\r\nu32 data, data2, patcnt, loop;\r\ndata2 = 0xffff;\r\nfor (patcnt = 0; patcnt < CBR_PATNUM; patcnt++) {\r\nast_moutdwm(ast, 0x1e6e007c, pattern[patcnt]);\r\nfor (loop = 0; loop < CBR_PASSNUM2; loop++) {\r\nif ((data = cbr_test2(ast)) != 0) {\r\ndata2 &= data;\r\nif (!data2)\r\nreturn 0;\r\nbreak;\r\n}\r\n}\r\nif (loop == CBR_PASSNUM2)\r\nreturn 0;\r\n}\r\nreturn data2;\r\n}\r\nstatic u32 cbr_test3(struct ast_private *ast)\r\n{\r\nif (!mmc_test_burst(ast, 0))\r\nreturn 0;\r\nif (!mmc_test_single(ast, 0))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic u32 cbr_scan3(struct ast_private *ast)\r\n{\r\nu32 patcnt, loop;\r\nfor (patcnt = 0; patcnt < CBR_PATNUM; patcnt++) {\r\nast_moutdwm(ast, 0x1e6e007c, pattern[patcnt]);\r\nfor (loop = 0; loop < 2; loop++) {\r\nif (cbr_test3(ast))\r\nbreak;\r\n}\r\nif (loop == 2)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic bool finetuneDQI_L(struct ast_private *ast, struct ast2300_dram_param *param)\r\n{\r\nu32 gold_sadj[2], dllmin[16], dllmax[16], dlli, data, cnt, mask, passcnt, retry = 0;\r\nbool status = false;\r\nFINETUNE_START:\r\nfor (cnt = 0; cnt < 16; cnt++) {\r\ndllmin[cnt] = 0xff;\r\ndllmax[cnt] = 0x0;\r\n}\r\npasscnt = 0;\r\nfor (dlli = 0; dlli < 76; dlli++) {\r\nast_moutdwm(ast, 0x1E6E0068, 0x00001400 | (dlli << 16) | (dlli << 24));\r\nast_moutdwm(ast, 0x1E6E0074, CBR_SIZE1);\r\ndata = cbr_scan2(ast);\r\nif (data != 0) {\r\nmask = 0x00010001;\r\nfor (cnt = 0; cnt < 16; cnt++) {\r\nif (data & mask) {\r\nif (dllmin[cnt] > dlli) {\r\ndllmin[cnt] = dlli;\r\n}\r\nif (dllmax[cnt] < dlli) {\r\ndllmax[cnt] = dlli;\r\n}\r\n}\r\nmask <<= 1;\r\n}\r\npasscnt++;\r\n} else if (passcnt >= CBR_THRESHOLD2) {\r\nbreak;\r\n}\r\n}\r\ngold_sadj[0] = 0x0;\r\npasscnt = 0;\r\nfor (cnt = 0; cnt < 16; cnt++) {\r\nif ((dllmax[cnt] > dllmin[cnt]) && ((dllmax[cnt] - dllmin[cnt]) >= CBR_THRESHOLD2)) {\r\ngold_sadj[0] += dllmin[cnt];\r\npasscnt++;\r\n}\r\n}\r\nif (retry++ > 10)\r\ngoto FINETUNE_DONE;\r\nif (passcnt != 16) {\r\ngoto FINETUNE_START;\r\n}\r\nstatus = true;\r\nFINETUNE_DONE:\r\ngold_sadj[0] = gold_sadj[0] >> 4;\r\ngold_sadj[1] = gold_sadj[0];\r\ndata = 0;\r\nfor (cnt = 0; cnt < 8; cnt++) {\r\ndata >>= 3;\r\nif ((dllmax[cnt] > dllmin[cnt]) && ((dllmax[cnt] - dllmin[cnt]) >= CBR_THRESHOLD2)) {\r\ndlli = dllmin[cnt];\r\nif (gold_sadj[0] >= dlli) {\r\ndlli = ((gold_sadj[0] - dlli) * 19) >> 5;\r\nif (dlli > 3) {\r\ndlli = 3;\r\n}\r\n} else {\r\ndlli = ((dlli - gold_sadj[0]) * 19) >> 5;\r\nif (dlli > 4) {\r\ndlli = 4;\r\n}\r\ndlli = (8 - dlli) & 0x7;\r\n}\r\ndata |= dlli << 21;\r\n}\r\n}\r\nast_moutdwm(ast, 0x1E6E0080, data);\r\ndata = 0;\r\nfor (cnt = 8; cnt < 16; cnt++) {\r\ndata >>= 3;\r\nif ((dllmax[cnt] > dllmin[cnt]) && ((dllmax[cnt] - dllmin[cnt]) >= CBR_THRESHOLD2)) {\r\ndlli = dllmin[cnt];\r\nif (gold_sadj[1] >= dlli) {\r\ndlli = ((gold_sadj[1] - dlli) * 19) >> 5;\r\nif (dlli > 3) {\r\ndlli = 3;\r\n} else {\r\ndlli = (dlli - 1) & 0x7;\r\n}\r\n} else {\r\ndlli = ((dlli - gold_sadj[1]) * 19) >> 5;\r\ndlli += 1;\r\nif (dlli > 4) {\r\ndlli = 4;\r\n}\r\ndlli = (8 - dlli) & 0x7;\r\n}\r\ndata |= dlli << 21;\r\n}\r\n}\r\nast_moutdwm(ast, 0x1E6E0084, data);\r\nreturn status;\r\n}\r\nstatic void finetuneDQSI(struct ast_private *ast)\r\n{\r\nu32 dlli, dqsip, dqidly;\r\nu32 reg_mcr18, reg_mcr0c, passcnt[2], diff;\r\nu32 g_dqidly, g_dqsip, g_margin, g_side;\r\nu16 pass[32][2][2];\r\nchar tag[2][76];\r\nreg_mcr0c = ast_mindwm(ast, 0x1E6E000C);\r\nreg_mcr18 = ast_mindwm(ast, 0x1E6E0018);\r\nreg_mcr18 &= 0x0000ffff;\r\nast_moutdwm(ast, 0x1E6E0018, reg_mcr18);\r\nfor (dlli = 0; dlli < 76; dlli++) {\r\ntag[0][dlli] = 0x0;\r\ntag[1][dlli] = 0x0;\r\n}\r\nfor (dqidly = 0; dqidly < 32; dqidly++) {\r\npass[dqidly][0][0] = 0xff;\r\npass[dqidly][0][1] = 0x0;\r\npass[dqidly][1][0] = 0xff;\r\npass[dqidly][1][1] = 0x0;\r\n}\r\nfor (dqidly = 0; dqidly < 32; dqidly++) {\r\npasscnt[0] = passcnt[1] = 0;\r\nfor (dqsip = 0; dqsip < 2; dqsip++) {\r\nast_moutdwm(ast, 0x1E6E000C, 0);\r\nast_moutdwm(ast, 0x1E6E0018, reg_mcr18 | (dqidly << 16) | (dqsip << 23));\r\nast_moutdwm(ast, 0x1E6E000C, reg_mcr0c);\r\nfor (dlli = 0; dlli < 76; dlli++) {\r\nast_moutdwm(ast, 0x1E6E0068, 0x00001300 | (dlli << 16) | (dlli << 24));\r\nast_moutdwm(ast, 0x1E6E0070, 0);\r\nast_moutdwm(ast, 0x1E6E0074, CBR_SIZE0);\r\nif (cbr_scan3(ast)) {\r\nif (dlli == 0)\r\nbreak;\r\npasscnt[dqsip]++;\r\ntag[dqsip][dlli] = 'P';\r\nif (dlli < pass[dqidly][dqsip][0])\r\npass[dqidly][dqsip][0] = (u16) dlli;\r\nif (dlli > pass[dqidly][dqsip][1])\r\npass[dqidly][dqsip][1] = (u16) dlli;\r\n} else if (passcnt[dqsip] >= 5)\r\nbreak;\r\nelse {\r\npass[dqidly][dqsip][0] = 0xff;\r\npass[dqidly][dqsip][1] = 0x0;\r\n}\r\n}\r\n}\r\nif (passcnt[0] == 0 && passcnt[1] == 0)\r\ndqidly++;\r\n}\r\ng_dqidly = g_dqsip = g_margin = g_side = 0;\r\nfor (dqidly = 0; dqidly < 32; dqidly++) {\r\nfor (dqsip = 0; dqsip < 2; dqsip++) {\r\nif (pass[dqidly][dqsip][0] > pass[dqidly][dqsip][1])\r\ncontinue;\r\ndiff = pass[dqidly][dqsip][1] - pass[dqidly][dqsip][0];\r\nif ((diff+2) < g_margin)\r\ncontinue;\r\npasscnt[0] = passcnt[1] = 0;\r\nfor (dlli = pass[dqidly][dqsip][0]; dlli > 0 && tag[dqsip][dlli] != 0; dlli--, passcnt[0]++);\r\nfor (dlli = pass[dqidly][dqsip][1]; dlli < 76 && tag[dqsip][dlli] != 0; dlli++, passcnt[1]++);\r\nif (passcnt[0] > passcnt[1])\r\npasscnt[0] = passcnt[1];\r\npasscnt[1] = 0;\r\nif (passcnt[0] > g_side)\r\npasscnt[1] = passcnt[0] - g_side;\r\nif (diff > (g_margin+1) && (passcnt[1] > 0 || passcnt[0] > 8)) {\r\ng_margin = diff;\r\ng_dqidly = dqidly;\r\ng_dqsip = dqsip;\r\ng_side = passcnt[0];\r\n} else if (passcnt[1] > 1 && g_side < 8) {\r\nif (diff > g_margin)\r\ng_margin = diff;\r\ng_dqidly = dqidly;\r\ng_dqsip = dqsip;\r\ng_side = passcnt[0];\r\n}\r\n}\r\n}\r\nreg_mcr18 = reg_mcr18 | (g_dqidly << 16) | (g_dqsip << 23);\r\nast_moutdwm(ast, 0x1E6E0018, reg_mcr18);\r\n}\r\nstatic bool cbr_dll2(struct ast_private *ast, struct ast2300_dram_param *param)\r\n{\r\nu32 dllmin[2], dllmax[2], dlli, data, passcnt, retry = 0;\r\nbool status = false;\r\nfinetuneDQSI(ast);\r\nif (finetuneDQI_L(ast, param) == false)\r\nreturn status;\r\nCBR_START2:\r\ndllmin[0] = dllmin[1] = 0xff;\r\ndllmax[0] = dllmax[1] = 0x0;\r\npasscnt = 0;\r\nfor (dlli = 0; dlli < 76; dlli++) {\r\nast_moutdwm(ast, 0x1E6E0068, 0x00001300 | (dlli << 16) | (dlli << 24));\r\nast_moutdwm(ast, 0x1E6E0074, CBR_SIZE2);\r\ndata = cbr_scan(ast);\r\nif (data != 0) {\r\nif (data & 0x1) {\r\nif (dllmin[0] > dlli) {\r\ndllmin[0] = dlli;\r\n}\r\nif (dllmax[0] < dlli) {\r\ndllmax[0] = dlli;\r\n}\r\n}\r\nif (data & 0x2) {\r\nif (dllmin[1] > dlli) {\r\ndllmin[1] = dlli;\r\n}\r\nif (dllmax[1] < dlli) {\r\ndllmax[1] = dlli;\r\n}\r\n}\r\npasscnt++;\r\n} else if (passcnt >= CBR_THRESHOLD) {\r\nbreak;\r\n}\r\n}\r\nif (retry++ > 10)\r\ngoto CBR_DONE2;\r\nif (dllmax[0] == 0 || (dllmax[0]-dllmin[0]) < CBR_THRESHOLD) {\r\ngoto CBR_START2;\r\n}\r\nif (dllmax[1] == 0 || (dllmax[1]-dllmin[1]) < CBR_THRESHOLD) {\r\ngoto CBR_START2;\r\n}\r\nstatus = true;\r\nCBR_DONE2:\r\ndlli = (dllmin[1] + dllmax[1]) >> 1;\r\ndlli <<= 8;\r\ndlli += (dllmin[0] + dllmax[0]) >> 1;\r\nast_moutdwm(ast, 0x1E6E0068, ast_mindwm(ast, 0x1E720058) | (dlli << 16));\r\nreturn status;\r\n}\r\nstatic void get_ddr3_info(struct ast_private *ast, struct ast2300_dram_param *param)\r\n{\r\nu32 trap, trap_AC2, trap_MRS;\r\nast_moutdwm(ast, 0x1E6E2000, 0x1688A8A8);\r\ntrap = (ast_mindwm(ast, 0x1E6E2070) >> 25) & 0x3;\r\ntrap_AC2 = 0x00020000 + (trap << 16);\r\ntrap_AC2 |= 0x00300000 + ((trap & 0x2) << 19);\r\ntrap_MRS = 0x00000010 + (trap << 4);\r\ntrap_MRS |= ((trap & 0x2) << 18);\r\nparam->reg_MADJ = 0x00034C4C;\r\nparam->reg_SADJ = 0x00001800;\r\nparam->reg_DRV = 0x000000F0;\r\nparam->reg_PERIOD = param->dram_freq;\r\nparam->rodt = 0;\r\nswitch (param->dram_freq) {\r\ncase 336:\r\nast_moutdwm(ast, 0x1E6E2020, 0x0190);\r\nparam->wodt = 0;\r\nparam->reg_AC1 = 0x22202725;\r\nparam->reg_AC2 = 0xAA007613 | trap_AC2;\r\nparam->reg_DQSIC = 0x000000BA;\r\nparam->reg_MRS = 0x04001400 | trap_MRS;\r\nparam->reg_EMRS = 0x00000000;\r\nparam->reg_IOZ = 0x00000023;\r\nparam->reg_DQIDLY = 0x00000074;\r\nparam->reg_FREQ = 0x00004DC0;\r\nparam->madj_max = 96;\r\nparam->dll2_finetune_step = 3;\r\nswitch (param->dram_chipid) {\r\ndefault:\r\ncase AST_DRAM_512Mx16:\r\ncase AST_DRAM_1Gx16:\r\nparam->reg_AC2 = 0xAA007613 | trap_AC2;\r\nbreak;\r\ncase AST_DRAM_2Gx16:\r\nparam->reg_AC2 = 0xAA00761C | trap_AC2;\r\nbreak;\r\ncase AST_DRAM_4Gx16:\r\nparam->reg_AC2 = 0xAA007636 | trap_AC2;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\ncase 396:\r\nast_moutdwm(ast, 0x1E6E2020, 0x03F1);\r\nparam->wodt = 1;\r\nparam->reg_AC1 = 0x33302825;\r\nparam->reg_AC2 = 0xCC009617 | trap_AC2;\r\nparam->reg_DQSIC = 0x000000E2;\r\nparam->reg_MRS = 0x04001600 | trap_MRS;\r\nparam->reg_EMRS = 0x00000000;\r\nparam->reg_IOZ = 0x00000034;\r\nparam->reg_DRV = 0x000000FA;\r\nparam->reg_DQIDLY = 0x00000089;\r\nparam->reg_FREQ = 0x00005040;\r\nparam->madj_max = 96;\r\nparam->dll2_finetune_step = 4;\r\nswitch (param->dram_chipid) {\r\ndefault:\r\ncase AST_DRAM_512Mx16:\r\ncase AST_DRAM_1Gx16:\r\nparam->reg_AC2 = 0xCC009617 | trap_AC2;\r\nbreak;\r\ncase AST_DRAM_2Gx16:\r\nparam->reg_AC2 = 0xCC009622 | trap_AC2;\r\nbreak;\r\ncase AST_DRAM_4Gx16:\r\nparam->reg_AC2 = 0xCC00963F | trap_AC2;\r\nbreak;\r\n}\r\nbreak;\r\ncase 408:\r\nast_moutdwm(ast, 0x1E6E2020, 0x01F0);\r\nparam->wodt = 1;\r\nparam->reg_AC1 = 0x33302825;\r\nparam->reg_AC2 = 0xCC009617 | trap_AC2;\r\nparam->reg_DQSIC = 0x000000E2;\r\nparam->reg_MRS = 0x04001600 | trap_MRS;\r\nparam->reg_EMRS = 0x00000000;\r\nparam->reg_IOZ = 0x00000023;\r\nparam->reg_DRV = 0x000000FA;\r\nparam->reg_DQIDLY = 0x00000089;\r\nparam->reg_FREQ = 0x000050C0;\r\nparam->madj_max = 96;\r\nparam->dll2_finetune_step = 4;\r\nswitch (param->dram_chipid) {\r\ndefault:\r\ncase AST_DRAM_512Mx16:\r\ncase AST_DRAM_1Gx16:\r\nparam->reg_AC2 = 0xCC009617 | trap_AC2;\r\nbreak;\r\ncase AST_DRAM_2Gx16:\r\nparam->reg_AC2 = 0xCC009622 | trap_AC2;\r\nbreak;\r\ncase AST_DRAM_4Gx16:\r\nparam->reg_AC2 = 0xCC00963F | trap_AC2;\r\nbreak;\r\n}\r\nbreak;\r\ncase 456:\r\nast_moutdwm(ast, 0x1E6E2020, 0x0230);\r\nparam->wodt = 0;\r\nparam->reg_AC1 = 0x33302926;\r\nparam->reg_AC2 = 0xCD44961A;\r\nparam->reg_DQSIC = 0x000000FC;\r\nparam->reg_MRS = 0x00081830;\r\nparam->reg_EMRS = 0x00000000;\r\nparam->reg_IOZ = 0x00000045;\r\nparam->reg_DQIDLY = 0x00000097;\r\nparam->reg_FREQ = 0x000052C0;\r\nparam->madj_max = 88;\r\nparam->dll2_finetune_step = 4;\r\nbreak;\r\ncase 504:\r\nast_moutdwm(ast, 0x1E6E2020, 0x0270);\r\nparam->wodt = 1;\r\nparam->reg_AC1 = 0x33302926;\r\nparam->reg_AC2 = 0xDE44A61D;\r\nparam->reg_DQSIC = 0x00000117;\r\nparam->reg_MRS = 0x00081A30;\r\nparam->reg_EMRS = 0x00000000;\r\nparam->reg_IOZ = 0x070000BB;\r\nparam->reg_DQIDLY = 0x000000A0;\r\nparam->reg_FREQ = 0x000054C0;\r\nparam->madj_max = 79;\r\nparam->dll2_finetune_step = 4;\r\nbreak;\r\ncase 528:\r\nast_moutdwm(ast, 0x1E6E2020, 0x0290);\r\nparam->wodt = 1;\r\nparam->rodt = 1;\r\nparam->reg_AC1 = 0x33302926;\r\nparam->reg_AC2 = 0xEF44B61E;\r\nparam->reg_DQSIC = 0x00000125;\r\nparam->reg_MRS = 0x00081A30;\r\nparam->reg_EMRS = 0x00000040;\r\nparam->reg_DRV = 0x000000F5;\r\nparam->reg_IOZ = 0x00000023;\r\nparam->reg_DQIDLY = 0x00000088;\r\nparam->reg_FREQ = 0x000055C0;\r\nparam->madj_max = 76;\r\nparam->dll2_finetune_step = 3;\r\nbreak;\r\ncase 576:\r\nast_moutdwm(ast, 0x1E6E2020, 0x0140);\r\nparam->reg_MADJ = 0x00136868;\r\nparam->reg_SADJ = 0x00004534;\r\nparam->wodt = 1;\r\nparam->rodt = 1;\r\nparam->reg_AC1 = 0x33302A37;\r\nparam->reg_AC2 = 0xEF56B61E;\r\nparam->reg_DQSIC = 0x0000013F;\r\nparam->reg_MRS = 0x00101A50;\r\nparam->reg_EMRS = 0x00000040;\r\nparam->reg_DRV = 0x000000FA;\r\nparam->reg_IOZ = 0x00000023;\r\nparam->reg_DQIDLY = 0x00000078;\r\nparam->reg_FREQ = 0x000057C0;\r\nparam->madj_max = 136;\r\nparam->dll2_finetune_step = 3;\r\nbreak;\r\ncase 600:\r\nast_moutdwm(ast, 0x1E6E2020, 0x02E1);\r\nparam->reg_MADJ = 0x00136868;\r\nparam->reg_SADJ = 0x00004534;\r\nparam->wodt = 1;\r\nparam->rodt = 1;\r\nparam->reg_AC1 = 0x32302A37;\r\nparam->reg_AC2 = 0xDF56B61F;\r\nparam->reg_DQSIC = 0x0000014D;\r\nparam->reg_MRS = 0x00101A50;\r\nparam->reg_EMRS = 0x00000004;\r\nparam->reg_DRV = 0x000000F5;\r\nparam->reg_IOZ = 0x00000023;\r\nparam->reg_DQIDLY = 0x00000078;\r\nparam->reg_FREQ = 0x000058C0;\r\nparam->madj_max = 132;\r\nparam->dll2_finetune_step = 3;\r\nbreak;\r\ncase 624:\r\nast_moutdwm(ast, 0x1E6E2020, 0x0160);\r\nparam->reg_MADJ = 0x00136868;\r\nparam->reg_SADJ = 0x00004534;\r\nparam->wodt = 1;\r\nparam->rodt = 1;\r\nparam->reg_AC1 = 0x32302A37;\r\nparam->reg_AC2 = 0xEF56B621;\r\nparam->reg_DQSIC = 0x0000015A;\r\nparam->reg_MRS = 0x02101A50;\r\nparam->reg_EMRS = 0x00000004;\r\nparam->reg_DRV = 0x000000F5;\r\nparam->reg_IOZ = 0x00000034;\r\nparam->reg_DQIDLY = 0x00000078;\r\nparam->reg_FREQ = 0x000059C0;\r\nparam->madj_max = 128;\r\nparam->dll2_finetune_step = 3;\r\nbreak;\r\n}\r\nswitch (param->dram_chipid) {\r\ncase AST_DRAM_512Mx16:\r\nparam->dram_config = 0x130;\r\nbreak;\r\ndefault:\r\ncase AST_DRAM_1Gx16:\r\nparam->dram_config = 0x131;\r\nbreak;\r\ncase AST_DRAM_2Gx16:\r\nparam->dram_config = 0x132;\r\nbreak;\r\ncase AST_DRAM_4Gx16:\r\nparam->dram_config = 0x133;\r\nbreak;\r\n}\r\nswitch (param->vram_size) {\r\ndefault:\r\ncase AST_VIDMEM_SIZE_8M:\r\nparam->dram_config |= 0x00;\r\nbreak;\r\ncase AST_VIDMEM_SIZE_16M:\r\nparam->dram_config |= 0x04;\r\nbreak;\r\ncase AST_VIDMEM_SIZE_32M:\r\nparam->dram_config |= 0x08;\r\nbreak;\r\ncase AST_VIDMEM_SIZE_64M:\r\nparam->dram_config |= 0x0c;\r\nbreak;\r\n}\r\n}\r\nstatic void ddr3_init(struct ast_private *ast, struct ast2300_dram_param *param)\r\n{\r\nu32 data, data2, retry = 0;\r\nddr3_init_start:\r\nast_moutdwm(ast, 0x1E6E0000, 0xFC600309);\r\nast_moutdwm(ast, 0x1E6E0018, 0x00000100);\r\nast_moutdwm(ast, 0x1E6E0024, 0x00000000);\r\nast_moutdwm(ast, 0x1E6E0034, 0x00000000);\r\nudelay(10);\r\nast_moutdwm(ast, 0x1E6E0064, param->reg_MADJ);\r\nast_moutdwm(ast, 0x1E6E0068, param->reg_SADJ);\r\nudelay(10);\r\nast_moutdwm(ast, 0x1E6E0064, param->reg_MADJ | 0xC0000);\r\nudelay(10);\r\nast_moutdwm(ast, 0x1E6E0004, param->dram_config);\r\nast_moutdwm(ast, 0x1E6E0008, 0x90040f);\r\nast_moutdwm(ast, 0x1E6E0010, param->reg_AC1);\r\nast_moutdwm(ast, 0x1E6E0014, param->reg_AC2);\r\nast_moutdwm(ast, 0x1E6E0020, param->reg_DQSIC);\r\nast_moutdwm(ast, 0x1E6E0080, 0x00000000);\r\nast_moutdwm(ast, 0x1E6E0084, 0x00000000);\r\nast_moutdwm(ast, 0x1E6E0088, param->reg_DQIDLY);\r\nast_moutdwm(ast, 0x1E6E0018, 0x4000A170);\r\nast_moutdwm(ast, 0x1E6E0018, 0x00002370);\r\nast_moutdwm(ast, 0x1E6E0038, 0x00000000);\r\nast_moutdwm(ast, 0x1E6E0040, 0xFF444444);\r\nast_moutdwm(ast, 0x1E6E0044, 0x22222222);\r\nast_moutdwm(ast, 0x1E6E0048, 0x22222222);\r\nast_moutdwm(ast, 0x1E6E004C, 0x00000002);\r\nast_moutdwm(ast, 0x1E6E0050, 0x80000000);\r\nast_moutdwm(ast, 0x1E6E0050, 0x00000000);\r\nast_moutdwm(ast, 0x1E6E0054, 0);\r\nast_moutdwm(ast, 0x1E6E0060, param->reg_DRV);\r\nast_moutdwm(ast, 0x1E6E006C, param->reg_IOZ);\r\nast_moutdwm(ast, 0x1E6E0070, 0x00000000);\r\nast_moutdwm(ast, 0x1E6E0074, 0x00000000);\r\nast_moutdwm(ast, 0x1E6E0078, 0x00000000);\r\nast_moutdwm(ast, 0x1E6E007C, 0x00000000);\r\ndo {\r\ndata = ast_mindwm(ast, 0x1E6E001C);\r\n} while (!(data & 0x08000000));\r\ndata = ast_mindwm(ast, 0x1E6E001C);\r\ndata = (data >> 8) & 0xff;\r\nwhile ((data & 0x08) || ((data & 0x7) < 2) || (data < 4)) {\r\ndata2 = (ast_mindwm(ast, 0x1E6E0064) & 0xfff3ffff) + 4;\r\nif ((data2 & 0xff) > param->madj_max) {\r\nbreak;\r\n}\r\nast_moutdwm(ast, 0x1E6E0064, data2);\r\nif (data2 & 0x00100000) {\r\ndata2 = ((data2 & 0xff) >> 3) + 3;\r\n} else {\r\ndata2 = ((data2 & 0xff) >> 2) + 5;\r\n}\r\ndata = ast_mindwm(ast, 0x1E6E0068) & 0xffff00ff;\r\ndata2 += data & 0xff;\r\ndata = data | (data2 << 8);\r\nast_moutdwm(ast, 0x1E6E0068, data);\r\nudelay(10);\r\nast_moutdwm(ast, 0x1E6E0064, ast_mindwm(ast, 0x1E6E0064) | 0xC0000);\r\nudelay(10);\r\ndata = ast_mindwm(ast, 0x1E6E0018) & 0xfffff1ff;\r\nast_moutdwm(ast, 0x1E6E0018, data);\r\ndata = data | 0x200;\r\nast_moutdwm(ast, 0x1E6E0018, data);\r\ndo {\r\ndata = ast_mindwm(ast, 0x1E6E001C);\r\n} while (!(data & 0x08000000));\r\ndata = ast_mindwm(ast, 0x1E6E001C);\r\ndata = (data >> 8) & 0xff;\r\n}\r\nast_moutdwm(ast, 0x1E720058, ast_mindwm(ast, 0x1E6E0068) & 0xffff);\r\ndata = ast_mindwm(ast, 0x1E6E0018) | 0xC00;\r\nast_moutdwm(ast, 0x1E6E0018, data);\r\nast_moutdwm(ast, 0x1E6E0034, 0x00000001);\r\nast_moutdwm(ast, 0x1E6E000C, 0x00000040);\r\nudelay(50);\r\nast_moutdwm(ast, 0x1E6E002C, param->reg_MRS | 0x100);\r\nast_moutdwm(ast, 0x1E6E0030, param->reg_EMRS);\r\nast_moutdwm(ast, 0x1E6E0028, 0x00000005);\r\nast_moutdwm(ast, 0x1E6E0028, 0x00000007);\r\nast_moutdwm(ast, 0x1E6E0028, 0x00000003);\r\nast_moutdwm(ast, 0x1E6E0028, 0x00000001);\r\nast_moutdwm(ast, 0x1E6E002C, param->reg_MRS);\r\nast_moutdwm(ast, 0x1E6E000C, 0x00005C08);\r\nast_moutdwm(ast, 0x1E6E0028, 0x00000001);\r\nast_moutdwm(ast, 0x1E6E000C, 0x00005C01);\r\ndata = 0;\r\nif (param->wodt) {\r\ndata = 0x300;\r\n}\r\nif (param->rodt) {\r\ndata = data | 0x3000 | ((param->reg_AC2 & 0x60000) >> 3);\r\n}\r\nast_moutdwm(ast, 0x1E6E0034, data | 0x3);\r\nif ((cbr_dll2(ast, param) == false) && (retry++ < 10))\r\ngoto ddr3_init_start;\r\nast_moutdwm(ast, 0x1E6E0120, param->reg_FREQ);\r\n#ifdef ECC\r\nast_moutdwm(ast, 0x1E6E007C, 0x00000000);\r\nast_moutdwm(ast, 0x1E6E0070, 0x221);\r\ndo {\r\ndata = ast_mindwm(ast, 0x1E6E0070);\r\n} while (!(data & 0x00001000));\r\nast_moutdwm(ast, 0x1E6E0070, 0x00000000);\r\nast_moutdwm(ast, 0x1E6E0050, 0x80000000);\r\nast_moutdwm(ast, 0x1E6E0050, 0x00000000);\r\n#endif\r\n}\r\nstatic void get_ddr2_info(struct ast_private *ast, struct ast2300_dram_param *param)\r\n{\r\nu32 trap, trap_AC2, trap_MRS;\r\nast_moutdwm(ast, 0x1E6E2000, 0x1688A8A8);\r\ntrap = (ast_mindwm(ast, 0x1E6E2070) >> 25) & 0x3;\r\ntrap_AC2 = (trap << 20) | (trap << 16);\r\ntrap_AC2 += 0x00110000;\r\ntrap_MRS = 0x00000040 | (trap << 4);\r\nparam->reg_MADJ = 0x00034C4C;\r\nparam->reg_SADJ = 0x00001800;\r\nparam->reg_DRV = 0x000000F0;\r\nparam->reg_PERIOD = param->dram_freq;\r\nparam->rodt = 0;\r\nswitch (param->dram_freq) {\r\ncase 264:\r\nast_moutdwm(ast, 0x1E6E2020, 0x0130);\r\nparam->wodt = 0;\r\nparam->reg_AC1 = 0x11101513;\r\nparam->reg_AC2 = 0x78117011;\r\nparam->reg_DQSIC = 0x00000092;\r\nparam->reg_MRS = 0x00000842;\r\nparam->reg_EMRS = 0x00000000;\r\nparam->reg_DRV = 0x000000F0;\r\nparam->reg_IOZ = 0x00000034;\r\nparam->reg_DQIDLY = 0x0000005A;\r\nparam->reg_FREQ = 0x00004AC0;\r\nparam->madj_max = 138;\r\nparam->dll2_finetune_step = 3;\r\nbreak;\r\ncase 336:\r\nast_moutdwm(ast, 0x1E6E2020, 0x0190);\r\nparam->wodt = 1;\r\nparam->reg_AC1 = 0x22202613;\r\nparam->reg_AC2 = 0xAA009016 | trap_AC2;\r\nparam->reg_DQSIC = 0x000000BA;\r\nparam->reg_MRS = 0x00000A02 | trap_MRS;\r\nparam->reg_EMRS = 0x00000040;\r\nparam->reg_DRV = 0x000000FA;\r\nparam->reg_IOZ = 0x00000034;\r\nparam->reg_DQIDLY = 0x00000074;\r\nparam->reg_FREQ = 0x00004DC0;\r\nparam->madj_max = 96;\r\nparam->dll2_finetune_step = 3;\r\nswitch (param->dram_chipid) {\r\ndefault:\r\ncase AST_DRAM_512Mx16:\r\nparam->reg_AC2 = 0xAA009012 | trap_AC2;\r\nbreak;\r\ncase AST_DRAM_1Gx16:\r\nparam->reg_AC2 = 0xAA009016 | trap_AC2;\r\nbreak;\r\ncase AST_DRAM_2Gx16:\r\nparam->reg_AC2 = 0xAA009023 | trap_AC2;\r\nbreak;\r\ncase AST_DRAM_4Gx16:\r\nparam->reg_AC2 = 0xAA00903B | trap_AC2;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\ncase 396:\r\nast_moutdwm(ast, 0x1E6E2020, 0x03F1);\r\nparam->wodt = 1;\r\nparam->rodt = 0;\r\nparam->reg_AC1 = 0x33302714;\r\nparam->reg_AC2 = 0xCC00B01B | trap_AC2;\r\nparam->reg_DQSIC = 0x000000E2;\r\nparam->reg_MRS = 0x00000C02 | trap_MRS;\r\nparam->reg_EMRS = 0x00000040;\r\nparam->reg_DRV = 0x000000FA;\r\nparam->reg_IOZ = 0x00000034;\r\nparam->reg_DQIDLY = 0x00000089;\r\nparam->reg_FREQ = 0x00005040;\r\nparam->madj_max = 96;\r\nparam->dll2_finetune_step = 4;\r\nswitch (param->dram_chipid) {\r\ncase AST_DRAM_512Mx16:\r\nparam->reg_AC2 = 0xCC00B016 | trap_AC2;\r\nbreak;\r\ndefault:\r\ncase AST_DRAM_1Gx16:\r\nparam->reg_AC2 = 0xCC00B01B | trap_AC2;\r\nbreak;\r\ncase AST_DRAM_2Gx16:\r\nparam->reg_AC2 = 0xCC00B02B | trap_AC2;\r\nbreak;\r\ncase AST_DRAM_4Gx16:\r\nparam->reg_AC2 = 0xCC00B03F | trap_AC2;\r\nbreak;\r\n}\r\nbreak;\r\ncase 408:\r\nast_moutdwm(ast, 0x1E6E2020, 0x01F0);\r\nparam->wodt = 1;\r\nparam->rodt = 0;\r\nparam->reg_AC1 = 0x33302714;\r\nparam->reg_AC2 = 0xCC00B01B | trap_AC2;\r\nparam->reg_DQSIC = 0x000000E2;\r\nparam->reg_MRS = 0x00000C02 | trap_MRS;\r\nparam->reg_EMRS = 0x00000040;\r\nparam->reg_DRV = 0x000000FA;\r\nparam->reg_IOZ = 0x00000034;\r\nparam->reg_DQIDLY = 0x00000089;\r\nparam->reg_FREQ = 0x000050C0;\r\nparam->madj_max = 96;\r\nparam->dll2_finetune_step = 4;\r\nswitch (param->dram_chipid) {\r\ncase AST_DRAM_512Mx16:\r\nparam->reg_AC2 = 0xCC00B016 | trap_AC2;\r\nbreak;\r\ndefault:\r\ncase AST_DRAM_1Gx16:\r\nparam->reg_AC2 = 0xCC00B01B | trap_AC2;\r\nbreak;\r\ncase AST_DRAM_2Gx16:\r\nparam->reg_AC2 = 0xCC00B02B | trap_AC2;\r\nbreak;\r\ncase AST_DRAM_4Gx16:\r\nparam->reg_AC2 = 0xCC00B03F | trap_AC2;\r\nbreak;\r\n}\r\nbreak;\r\ncase 456:\r\nast_moutdwm(ast, 0x1E6E2020, 0x0230);\r\nparam->wodt = 0;\r\nparam->reg_AC1 = 0x33302815;\r\nparam->reg_AC2 = 0xCD44B01E;\r\nparam->reg_DQSIC = 0x000000FC;\r\nparam->reg_MRS = 0x00000E72;\r\nparam->reg_EMRS = 0x00000000;\r\nparam->reg_DRV = 0x00000000;\r\nparam->reg_IOZ = 0x00000034;\r\nparam->reg_DQIDLY = 0x00000097;\r\nparam->reg_FREQ = 0x000052C0;\r\nparam->madj_max = 88;\r\nparam->dll2_finetune_step = 3;\r\nbreak;\r\ncase 504:\r\nast_moutdwm(ast, 0x1E6E2020, 0x0261);\r\nparam->wodt = 1;\r\nparam->rodt = 1;\r\nparam->reg_AC1 = 0x33302815;\r\nparam->reg_AC2 = 0xDE44C022;\r\nparam->reg_DQSIC = 0x00000117;\r\nparam->reg_MRS = 0x00000E72;\r\nparam->reg_EMRS = 0x00000040;\r\nparam->reg_DRV = 0x0000000A;\r\nparam->reg_IOZ = 0x00000045;\r\nparam->reg_DQIDLY = 0x000000A0;\r\nparam->reg_FREQ = 0x000054C0;\r\nparam->madj_max = 79;\r\nparam->dll2_finetune_step = 3;\r\nbreak;\r\ncase 528:\r\nast_moutdwm(ast, 0x1E6E2020, 0x0120);\r\nparam->wodt = 1;\r\nparam->rodt = 1;\r\nparam->reg_AC1 = 0x33302815;\r\nparam->reg_AC2 = 0xEF44D024;\r\nparam->reg_DQSIC = 0x00000125;\r\nparam->reg_MRS = 0x00000E72;\r\nparam->reg_EMRS = 0x00000004;\r\nparam->reg_DRV = 0x000000F9;\r\nparam->reg_IOZ = 0x00000045;\r\nparam->reg_DQIDLY = 0x000000A7;\r\nparam->reg_FREQ = 0x000055C0;\r\nparam->madj_max = 76;\r\nparam->dll2_finetune_step = 3;\r\nbreak;\r\ncase 552:\r\nast_moutdwm(ast, 0x1E6E2020, 0x02A1);\r\nparam->wodt = 1;\r\nparam->rodt = 1;\r\nparam->reg_AC1 = 0x43402915;\r\nparam->reg_AC2 = 0xFF44E025;\r\nparam->reg_DQSIC = 0x00000132;\r\nparam->reg_MRS = 0x00000E72;\r\nparam->reg_EMRS = 0x00000040;\r\nparam->reg_DRV = 0x0000000A;\r\nparam->reg_IOZ = 0x00000045;\r\nparam->reg_DQIDLY = 0x000000AD;\r\nparam->reg_FREQ = 0x000056C0;\r\nparam->madj_max = 76;\r\nparam->dll2_finetune_step = 3;\r\nbreak;\r\ncase 576:\r\nast_moutdwm(ast, 0x1E6E2020, 0x0140);\r\nparam->wodt = 1;\r\nparam->rodt = 1;\r\nparam->reg_AC1 = 0x43402915;\r\nparam->reg_AC2 = 0xFF44E027;\r\nparam->reg_DQSIC = 0x0000013F;\r\nparam->reg_MRS = 0x00000E72;\r\nparam->reg_EMRS = 0x00000004;\r\nparam->reg_DRV = 0x000000F5;\r\nparam->reg_IOZ = 0x00000045;\r\nparam->reg_DQIDLY = 0x000000B3;\r\nparam->reg_FREQ = 0x000057C0;\r\nparam->madj_max = 76;\r\nparam->dll2_finetune_step = 3;\r\nbreak;\r\n}\r\nswitch (param->dram_chipid) {\r\ncase AST_DRAM_512Mx16:\r\nparam->dram_config = 0x100;\r\nbreak;\r\ndefault:\r\ncase AST_DRAM_1Gx16:\r\nparam->dram_config = 0x121;\r\nbreak;\r\ncase AST_DRAM_2Gx16:\r\nparam->dram_config = 0x122;\r\nbreak;\r\ncase AST_DRAM_4Gx16:\r\nparam->dram_config = 0x123;\r\nbreak;\r\n}\r\nswitch (param->vram_size) {\r\ndefault:\r\ncase AST_VIDMEM_SIZE_8M:\r\nparam->dram_config |= 0x00;\r\nbreak;\r\ncase AST_VIDMEM_SIZE_16M:\r\nparam->dram_config |= 0x04;\r\nbreak;\r\ncase AST_VIDMEM_SIZE_32M:\r\nparam->dram_config |= 0x08;\r\nbreak;\r\ncase AST_VIDMEM_SIZE_64M:\r\nparam->dram_config |= 0x0c;\r\nbreak;\r\n}\r\n}\r\nstatic void ddr2_init(struct ast_private *ast, struct ast2300_dram_param *param)\r\n{\r\nu32 data, data2, retry = 0;\r\nddr2_init_start:\r\nast_moutdwm(ast, 0x1E6E0000, 0xFC600309);\r\nast_moutdwm(ast, 0x1E6E0018, 0x00000100);\r\nast_moutdwm(ast, 0x1E6E0024, 0x00000000);\r\nast_moutdwm(ast, 0x1E6E0064, param->reg_MADJ);\r\nast_moutdwm(ast, 0x1E6E0068, param->reg_SADJ);\r\nudelay(10);\r\nast_moutdwm(ast, 0x1E6E0064, param->reg_MADJ | 0xC0000);\r\nudelay(10);\r\nast_moutdwm(ast, 0x1E6E0004, param->dram_config);\r\nast_moutdwm(ast, 0x1E6E0008, 0x90040f);\r\nast_moutdwm(ast, 0x1E6E0010, param->reg_AC1);\r\nast_moutdwm(ast, 0x1E6E0014, param->reg_AC2);\r\nast_moutdwm(ast, 0x1E6E0020, param->reg_DQSIC);\r\nast_moutdwm(ast, 0x1E6E0080, 0x00000000);\r\nast_moutdwm(ast, 0x1E6E0084, 0x00000000);\r\nast_moutdwm(ast, 0x1E6E0088, param->reg_DQIDLY);\r\nast_moutdwm(ast, 0x1E6E0018, 0x4000A130);\r\nast_moutdwm(ast, 0x1E6E0018, 0x00002330);\r\nast_moutdwm(ast, 0x1E6E0038, 0x00000000);\r\nast_moutdwm(ast, 0x1E6E0040, 0xFF808000);\r\nast_moutdwm(ast, 0x1E6E0044, 0x88848466);\r\nast_moutdwm(ast, 0x1E6E0048, 0x44440008);\r\nast_moutdwm(ast, 0x1E6E004C, 0x00000000);\r\nast_moutdwm(ast, 0x1E6E0050, 0x80000000);\r\nast_moutdwm(ast, 0x1E6E0050, 0x00000000);\r\nast_moutdwm(ast, 0x1E6E0054, 0);\r\nast_moutdwm(ast, 0x1E6E0060, param->reg_DRV);\r\nast_moutdwm(ast, 0x1E6E006C, param->reg_IOZ);\r\nast_moutdwm(ast, 0x1E6E0070, 0x00000000);\r\nast_moutdwm(ast, 0x1E6E0074, 0x00000000);\r\nast_moutdwm(ast, 0x1E6E0078, 0x00000000);\r\nast_moutdwm(ast, 0x1E6E007C, 0x00000000);\r\ndo {\r\ndata = ast_mindwm(ast, 0x1E6E001C);\r\n} while (!(data & 0x08000000));\r\ndata = ast_mindwm(ast, 0x1E6E001C);\r\ndata = (data >> 8) & 0xff;\r\nwhile ((data & 0x08) || ((data & 0x7) < 2) || (data < 4)) {\r\ndata2 = (ast_mindwm(ast, 0x1E6E0064) & 0xfff3ffff) + 4;\r\nif ((data2 & 0xff) > param->madj_max) {\r\nbreak;\r\n}\r\nast_moutdwm(ast, 0x1E6E0064, data2);\r\nif (data2 & 0x00100000) {\r\ndata2 = ((data2 & 0xff) >> 3) + 3;\r\n} else {\r\ndata2 = ((data2 & 0xff) >> 2) + 5;\r\n}\r\ndata = ast_mindwm(ast, 0x1E6E0068) & 0xffff00ff;\r\ndata2 += data & 0xff;\r\ndata = data | (data2 << 8);\r\nast_moutdwm(ast, 0x1E6E0068, data);\r\nudelay(10);\r\nast_moutdwm(ast, 0x1E6E0064, ast_mindwm(ast, 0x1E6E0064) | 0xC0000);\r\nudelay(10);\r\ndata = ast_mindwm(ast, 0x1E6E0018) & 0xfffff1ff;\r\nast_moutdwm(ast, 0x1E6E0018, data);\r\ndata = data | 0x200;\r\nast_moutdwm(ast, 0x1E6E0018, data);\r\ndo {\r\ndata = ast_mindwm(ast, 0x1E6E001C);\r\n} while (!(data & 0x08000000));\r\ndata = ast_mindwm(ast, 0x1E6E001C);\r\ndata = (data >> 8) & 0xff;\r\n}\r\nast_moutdwm(ast, 0x1E720058, ast_mindwm(ast, 0x1E6E0008) & 0xffff);\r\ndata = ast_mindwm(ast, 0x1E6E0018) | 0xC00;\r\nast_moutdwm(ast, 0x1E6E0018, data);\r\nast_moutdwm(ast, 0x1E6E0034, 0x00000001);\r\nast_moutdwm(ast, 0x1E6E000C, 0x00000000);\r\nudelay(50);\r\nast_moutdwm(ast, 0x1E6E002C, param->reg_MRS | 0x100);\r\nast_moutdwm(ast, 0x1E6E0030, param->reg_EMRS);\r\nast_moutdwm(ast, 0x1E6E0028, 0x00000005);\r\nast_moutdwm(ast, 0x1E6E0028, 0x00000007);\r\nast_moutdwm(ast, 0x1E6E0028, 0x00000003);\r\nast_moutdwm(ast, 0x1E6E0028, 0x00000001);\r\nast_moutdwm(ast, 0x1E6E000C, 0x00005C08);\r\nast_moutdwm(ast, 0x1E6E002C, param->reg_MRS);\r\nast_moutdwm(ast, 0x1E6E0028, 0x00000001);\r\nast_moutdwm(ast, 0x1E6E0030, param->reg_EMRS | 0x380);\r\nast_moutdwm(ast, 0x1E6E0028, 0x00000003);\r\nast_moutdwm(ast, 0x1E6E0030, param->reg_EMRS);\r\nast_moutdwm(ast, 0x1E6E0028, 0x00000003);\r\nast_moutdwm(ast, 0x1E6E000C, 0x7FFF5C01);\r\ndata = 0;\r\nif (param->wodt) {\r\ndata = 0x500;\r\n}\r\nif (param->rodt) {\r\ndata = data | 0x3000 | ((param->reg_AC2 & 0x60000) >> 3);\r\n}\r\nast_moutdwm(ast, 0x1E6E0034, data | 0x3);\r\nast_moutdwm(ast, 0x1E6E0120, param->reg_FREQ);\r\nif ((cbr_dll2(ast, param) == false) && (retry++ < 10))\r\ngoto ddr2_init_start;\r\n#ifdef ECC\r\nast_moutdwm(ast, 0x1E6E007C, 0x00000000);\r\nast_moutdwm(ast, 0x1E6E0070, 0x221);\r\ndo {\r\ndata = ast_mindwm(ast, 0x1E6E0070);\r\n} while (!(data & 0x00001000));\r\nast_moutdwm(ast, 0x1E6E0070, 0x00000000);\r\nast_moutdwm(ast, 0x1E6E0050, 0x80000000);\r\nast_moutdwm(ast, 0x1E6E0050, 0x00000000);\r\n#endif\r\n}\r\nstatic void ast_init_dram_2300(struct drm_device *dev)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nstruct ast2300_dram_param param;\r\nu32 temp;\r\nu8 reg;\r\nreg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd0, 0xff);\r\nif ((reg & 0x80) == 0) {\r\nast_write32(ast, 0xf004, 0x1e6e0000);\r\nast_write32(ast, 0xf000, 0x1);\r\nast_write32(ast, 0x12000, 0x1688a8a8);\r\ndo {\r\n;\r\n} while (ast_read32(ast, 0x12000) != 0x1);\r\nast_write32(ast, 0x10000, 0xfc600309);\r\ndo {\r\n;\r\n} while (ast_read32(ast, 0x10000) != 0x1);\r\ntemp = ast_read32(ast, 0x12008);\r\ntemp |= 0x73;\r\nast_write32(ast, 0x12008, temp);\r\nparam.dram_type = AST_DDR3;\r\nif (temp & 0x01000000)\r\nparam.dram_type = AST_DDR2;\r\nparam.dram_chipid = ast->dram_type;\r\nparam.dram_freq = ast->mclk;\r\nparam.vram_size = ast->vram_size;\r\nif (param.dram_type == AST_DDR3) {\r\nget_ddr3_info(ast, &param);\r\nddr3_init(ast, &param);\r\n} else {\r\nget_ddr2_info(ast, &param);\r\nddr2_init(ast, &param);\r\n}\r\ntemp = ast_mindwm(ast, 0x1e6e2040);\r\nast_moutdwm(ast, 0x1e6e2040, temp | 0x40);\r\n}\r\ndo {\r\nreg = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd0, 0xff);\r\n} while ((reg & 0x40) == 0);\r\n}
