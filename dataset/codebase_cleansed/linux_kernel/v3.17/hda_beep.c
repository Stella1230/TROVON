static void snd_hda_generate_beep(struct work_struct *work)\r\n{\r\nstruct hda_beep *beep =\r\ncontainer_of(work, struct hda_beep, beep_work);\r\nstruct hda_codec *codec = beep->codec;\r\nint tone;\r\nif (!beep->enabled)\r\nreturn;\r\ntone = beep->tone;\r\nif (tone && !beep->playing) {\r\nsnd_hda_power_up(codec);\r\nbeep->playing = 1;\r\n}\r\nsnd_hda_codec_write(codec, beep->nid, 0,\r\nAC_VERB_SET_BEEP_CONTROL, tone);\r\nif (!tone && beep->playing) {\r\nbeep->playing = 0;\r\nsnd_hda_power_down(codec);\r\n}\r\n}\r\nstatic int beep_linear_tone(struct hda_beep *beep, int hz)\r\n{\r\nif (hz <= 0)\r\nreturn 0;\r\nhz *= 1000;\r\nhz = hz - DIGBEEP_HZ_MIN\r\n+ DIGBEEP_HZ_STEP / 2;\r\nif (hz < 0)\r\nhz = 0;\r\nelse if (hz >= (DIGBEEP_HZ_MAX - DIGBEEP_HZ_MIN))\r\nhz = 1;\r\nelse {\r\nhz /= DIGBEEP_HZ_STEP;\r\nhz = 255 - hz;\r\n}\r\nreturn hz;\r\n}\r\nstatic int beep_standard_tone(struct hda_beep *beep, int hz)\r\n{\r\nif (hz <= 0)\r\nreturn 0;\r\nhz = 12000 / hz;\r\nif (hz > 0xff)\r\nreturn 0xff;\r\nif (hz <= 0)\r\nreturn 1;\r\nreturn hz;\r\n}\r\nstatic int snd_hda_beep_event(struct input_dev *dev, unsigned int type,\r\nunsigned int code, int hz)\r\n{\r\nstruct hda_beep *beep = input_get_drvdata(dev);\r\nswitch (code) {\r\ncase SND_BELL:\r\nif (hz)\r\nhz = 1000;\r\ncase SND_TONE:\r\nif (beep->linear_tone)\r\nbeep->tone = beep_linear_tone(beep, hz);\r\nelse\r\nbeep->tone = beep_standard_tone(beep, hz);\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nschedule_work(&beep->beep_work);\r\nreturn 0;\r\n}\r\nstatic void turn_off_beep(struct hda_beep *beep)\r\n{\r\ncancel_work_sync(&beep->beep_work);\r\nif (beep->playing) {\r\nsnd_hda_codec_write(beep->codec, beep->nid, 0,\r\nAC_VERB_SET_BEEP_CONTROL, 0);\r\nbeep->playing = 0;\r\nsnd_hda_power_down(beep->codec);\r\n}\r\n}\r\nstatic void snd_hda_do_detach(struct hda_beep *beep)\r\n{\r\nif (beep->registered)\r\ninput_unregister_device(beep->dev);\r\nelse\r\ninput_free_device(beep->dev);\r\nbeep->dev = NULL;\r\nturn_off_beep(beep);\r\n}\r\nstatic int snd_hda_do_attach(struct hda_beep *beep)\r\n{\r\nstruct input_dev *input_dev;\r\nstruct hda_codec *codec = beep->codec;\r\ninput_dev = input_allocate_device();\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\ninput_dev->name = "HDA Digital PCBeep";\r\ninput_dev->phys = beep->phys;\r\ninput_dev->id.bustype = BUS_PCI;\r\ninput_dev->id.vendor = codec->vendor_id >> 16;\r\ninput_dev->id.product = codec->vendor_id & 0xffff;\r\ninput_dev->id.version = 0x01;\r\ninput_dev->evbit[0] = BIT_MASK(EV_SND);\r\ninput_dev->sndbit[0] = BIT_MASK(SND_BELL) | BIT_MASK(SND_TONE);\r\ninput_dev->event = snd_hda_beep_event;\r\ninput_dev->dev.parent = &codec->dev;\r\ninput_set_drvdata(input_dev, beep);\r\nbeep->dev = input_dev;\r\nreturn 0;\r\n}\r\nint snd_hda_enable_beep_device(struct hda_codec *codec, int enable)\r\n{\r\nstruct hda_beep *beep = codec->beep;\r\nif (!beep)\r\nreturn 0;\r\nenable = !!enable;\r\nif (beep->enabled != enable) {\r\nbeep->enabled = enable;\r\nif (!enable)\r\nturn_off_beep(beep);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint snd_hda_attach_beep_device(struct hda_codec *codec, int nid)\r\n{\r\nstruct hda_beep *beep;\r\nint err;\r\nif (!snd_hda_get_bool_hint(codec, "beep"))\r\nreturn 0;\r\nif (codec->beep_mode == HDA_BEEP_MODE_OFF)\r\nreturn 0;\r\nbeep = kzalloc(sizeof(*beep), GFP_KERNEL);\r\nif (beep == NULL)\r\nreturn -ENOMEM;\r\nsnprintf(beep->phys, sizeof(beep->phys),\r\n"card%d/codec#%d/beep0", codec->bus->card->number, codec->addr);\r\nsnd_hda_codec_write_cache(codec, nid, 0,\r\nAC_VERB_SET_DIGI_CONVERT_2, 0x01);\r\nbeep->nid = nid;\r\nbeep->codec = codec;\r\ncodec->beep = beep;\r\nINIT_WORK(&beep->beep_work, &snd_hda_generate_beep);\r\nmutex_init(&beep->mutex);\r\nerr = snd_hda_do_attach(beep);\r\nif (err < 0) {\r\nkfree(beep);\r\ncodec->beep = NULL;\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nvoid snd_hda_detach_beep_device(struct hda_codec *codec)\r\n{\r\nstruct hda_beep *beep = codec->beep;\r\nif (beep) {\r\nif (beep->dev)\r\nsnd_hda_do_detach(beep);\r\ncodec->beep = NULL;\r\nkfree(beep);\r\n}\r\n}\r\nint snd_hda_register_beep_device(struct hda_codec *codec)\r\n{\r\nstruct hda_beep *beep = codec->beep;\r\nint err;\r\nif (!beep || !beep->dev)\r\nreturn 0;\r\nerr = input_register_device(beep->dev);\r\nif (err < 0) {\r\ncodec_err(codec, "hda_beep: unable to register input device\n");\r\ninput_free_device(beep->dev);\r\ncodec->beep = NULL;\r\nkfree(beep);\r\nreturn err;\r\n}\r\nbeep->registered = true;\r\nreturn 0;\r\n}\r\nstatic bool ctl_has_mute(struct snd_kcontrol *kcontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nreturn query_amp_caps(codec, get_amp_nid(kcontrol),\r\nget_amp_direction(kcontrol)) & AC_AMPCAP_MUTE;\r\n}\r\nint snd_hda_mixer_amp_switch_get_beep(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_beep *beep = codec->beep;\r\nif (beep && (!beep->enabled || !ctl_has_mute(kcontrol))) {\r\nucontrol->value.integer.value[0] =\r\nucontrol->value.integer.value[1] = beep->enabled;\r\nreturn 0;\r\n}\r\nreturn snd_hda_mixer_amp_switch_get(kcontrol, ucontrol);\r\n}\r\nint snd_hda_mixer_amp_switch_put_beep(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_beep *beep = codec->beep;\r\nif (beep) {\r\nu8 chs = get_amp_channels(kcontrol);\r\nint enable = 0;\r\nlong *valp = ucontrol->value.integer.value;\r\nif (chs & 1) {\r\nenable |= *valp;\r\nvalp++;\r\n}\r\nif (chs & 2)\r\nenable |= *valp;\r\nsnd_hda_enable_beep_device(codec, enable);\r\n}\r\nif (!ctl_has_mute(kcontrol))\r\nreturn 0;\r\nreturn snd_hda_mixer_amp_switch_put(kcontrol, ucontrol);\r\n}
