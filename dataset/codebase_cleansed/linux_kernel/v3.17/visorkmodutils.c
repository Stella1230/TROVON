void *kmalloc_kernel(size_t siz)\r\n{\r\nreturn kmalloc(siz, GFP_KERNEL | __GFP_NORETRY);\r\n}\r\nstruct seq_file *visor_seq_file_new_buffer(void *buf, size_t buf_size)\r\n{\r\nstruct seq_file *rc = NULL;\r\nstruct seq_file *m = kmalloc_kernel(sizeof(struct seq_file));\r\nif (m == NULL) {\r\nrc = NULL;\r\ngoto Away;\r\n}\r\nmemset(m, 0, sizeof(struct seq_file));\r\nm->buf = buf;\r\nm->size = buf_size;\r\nrc = m;\r\nAway:\r\nif (rc == NULL) {\r\nvisor_seq_file_done_buffer(m);\r\nm = NULL;\r\n}\r\nreturn rc;\r\n}\r\nvoid visor_seq_file_done_buffer(struct seq_file *m)\r\n{\r\nif (!m)\r\nreturn;\r\nkfree(m);\r\n}\r\nstatic __init uint32_t\r\nvisorutil_spar_detect(void)\r\n{\r\nunsigned int eax, ebx, ecx, edx;\r\nif (cpu_has_hypervisor) {\r\ncpuid(UNISYS_SPAR_LEAF_ID, &eax, &ebx, &ecx, &edx);\r\nreturn (ebx == UNISYS_SPAR_ID_EBX) &&\r\n(ecx == UNISYS_SPAR_ID_ECX) &&\r\n(edx == UNISYS_SPAR_ID_EDX);\r\n} else\r\nreturn 0;\r\n}\r\nstatic __init int\r\nvisorutil_mod_init(void)\r\n{\r\nif (visorutil_spar_detect()) {\r\nunisys_spar_platform = TRUE;\r\nreturn 0;\r\n} else\r\nreturn -ENODEV;\r\n}\r\nstatic __exit void\r\nvisorutil_mod_exit(void)\r\n{\r\n}
