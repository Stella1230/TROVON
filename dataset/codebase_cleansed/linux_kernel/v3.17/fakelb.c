static int\r\nfakelb_hw_ed(struct ieee802154_dev *dev, u8 *level)\r\n{\r\nmight_sleep();\r\nBUG_ON(!level);\r\n*level = 0xbe;\r\nreturn 0;\r\n}\r\nstatic int\r\nfakelb_hw_channel(struct ieee802154_dev *dev, int page, int channel)\r\n{\r\npr_debug("set channel to %d\n", channel);\r\nmight_sleep();\r\ndev->phy->current_page = page;\r\ndev->phy->current_channel = channel;\r\nreturn 0;\r\n}\r\nstatic void\r\nfakelb_hw_deliver(struct fakelb_dev_priv *priv, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *newskb;\r\nspin_lock(&priv->lock);\r\nif (priv->working) {\r\nnewskb = pskb_copy(skb, GFP_ATOMIC);\r\nieee802154_rx_irqsafe(priv->dev, newskb, 0xcc);\r\n}\r\nspin_unlock(&priv->lock);\r\n}\r\nstatic int\r\nfakelb_hw_xmit(struct ieee802154_dev *dev, struct sk_buff *skb)\r\n{\r\nstruct fakelb_dev_priv *priv = dev->priv;\r\nstruct fakelb_priv *fake = priv->fake;\r\nmight_sleep();\r\nread_lock_bh(&fake->lock);\r\nif (priv->list.next == priv->list.prev) {\r\nfakelb_hw_deliver(priv, skb);\r\n} else {\r\nstruct fakelb_dev_priv *dp;\r\nlist_for_each_entry(dp, &priv->fake->list, list) {\r\nif (dp != priv &&\r\n(dp->dev->phy->current_channel ==\r\npriv->dev->phy->current_channel))\r\nfakelb_hw_deliver(dp, skb);\r\n}\r\n}\r\nread_unlock_bh(&fake->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nfakelb_hw_start(struct ieee802154_dev *dev) {\r\nstruct fakelb_dev_priv *priv = dev->priv;\r\nint ret = 0;\r\nspin_lock(&priv->lock);\r\nif (priv->working)\r\nret = -EBUSY;\r\nelse\r\npriv->working = 1;\r\nspin_unlock(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic void\r\nfakelb_hw_stop(struct ieee802154_dev *dev) {\r\nstruct fakelb_dev_priv *priv = dev->priv;\r\nspin_lock(&priv->lock);\r\npriv->working = 0;\r\nspin_unlock(&priv->lock);\r\n}\r\nstatic int fakelb_add_one(struct device *dev, struct fakelb_priv *fake)\r\n{\r\nstruct fakelb_dev_priv *priv;\r\nint err;\r\nstruct ieee802154_dev *ieee;\r\nieee = ieee802154_alloc_device(sizeof(*priv), &fakelb_ops);\r\nif (!ieee)\r\nreturn -ENOMEM;\r\npriv = ieee->priv;\r\npriv->dev = ieee;\r\nieee->phy->channels_supported[0] |= 1;\r\nieee->phy->channels_supported[0] |= 0x7fe;\r\nieee->phy->channels_supported[0] |= 0x7FFF800;\r\nieee->phy->channels_supported[1] |= 1;\r\nieee->phy->channels_supported[1] |= 0x7fe;\r\nieee->phy->channels_supported[2] |= 1;\r\nieee->phy->channels_supported[2] |= 0x7fe;\r\nieee->phy->channels_supported[3] |= 0x3fff;\r\nieee->phy->channels_supported[4] |= 1;\r\nieee->phy->channels_supported[4] |= 0x1e;\r\nieee->phy->channels_supported[4] |= 0xffe0;\r\nieee->phy->channels_supported[5] |= 0xf;\r\nieee->phy->channels_supported[5] |= 0xf0;\r\nieee->phy->channels_supported[6] |= 0x3ff;\r\nieee->phy->channels_supported[6] |= 0x3ffc00;\r\nINIT_LIST_HEAD(&priv->list);\r\npriv->fake = fake;\r\nspin_lock_init(&priv->lock);\r\nieee->parent = dev;\r\nerr = ieee802154_register_device(ieee);\r\nif (err)\r\ngoto err_reg;\r\nwrite_lock_bh(&fake->lock);\r\nlist_add_tail(&priv->list, &fake->list);\r\nwrite_unlock_bh(&fake->lock);\r\nreturn 0;\r\nerr_reg:\r\nieee802154_free_device(priv->dev);\r\nreturn err;\r\n}\r\nstatic void fakelb_del(struct fakelb_dev_priv *priv)\r\n{\r\nwrite_lock_bh(&priv->fake->lock);\r\nlist_del(&priv->list);\r\nwrite_unlock_bh(&priv->fake->lock);\r\nieee802154_unregister_device(priv->dev);\r\nieee802154_free_device(priv->dev);\r\n}\r\nstatic int fakelb_probe(struct platform_device *pdev)\r\n{\r\nstruct fakelb_priv *priv;\r\nstruct fakelb_dev_priv *dp;\r\nint err = -ENOMEM;\r\nint i;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(struct fakelb_priv),\r\nGFP_KERNEL);\r\nif (!priv)\r\ngoto err_alloc;\r\nINIT_LIST_HEAD(&priv->list);\r\nrwlock_init(&priv->lock);\r\nfor (i = 0; i < numlbs; i++) {\r\nerr = fakelb_add_one(&pdev->dev, priv);\r\nif (err < 0)\r\ngoto err_slave;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\ndev_info(&pdev->dev, "added ieee802154 hardware\n");\r\nreturn 0;\r\nerr_slave:\r\nlist_for_each_entry(dp, &priv->list, list)\r\nfakelb_del(dp);\r\nerr_alloc:\r\nreturn err;\r\n}\r\nstatic int fakelb_remove(struct platform_device *pdev)\r\n{\r\nstruct fakelb_priv *priv = platform_get_drvdata(pdev);\r\nstruct fakelb_dev_priv *dp, *temp;\r\nlist_for_each_entry_safe(dp, temp, &priv->list, list)\r\nfakelb_del(dp);\r\nreturn 0;\r\n}\r\nstatic __init int fakelb_init_module(void)\r\n{\r\nieee802154fake_dev = platform_device_register_simple(\r\n"ieee802154fakelb", -1, NULL, 0);\r\nreturn platform_driver_register(&ieee802154fake_driver);\r\n}\r\nstatic __exit void fake_remove_module(void)\r\n{\r\nplatform_driver_unregister(&ieee802154fake_driver);\r\nplatform_device_unregister(ieee802154fake_dev);\r\n}
