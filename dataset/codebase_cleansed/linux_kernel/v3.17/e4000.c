static int e4000_init(struct dvb_frontend *fe)\r\n{\r\nstruct e4000 *s = fe->tuner_priv;\r\nint ret;\r\ndev_dbg(&s->client->dev, "%s:\n", __func__);\r\nret = regmap_write(s->regmap, 0x02, 0x40);\r\nret = regmap_write(s->regmap, 0x00, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(s->regmap, 0x06, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(s->regmap, 0x7a, 0x96);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_write(s->regmap, 0x7e, "\x01\xfe", 2);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(s->regmap, 0x82, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(s->regmap, 0x24, 0x05);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_write(s->regmap, 0x87, "\x20\x01", 2);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_write(s->regmap, 0x9f, "\x7f\x07", 2);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(s->regmap, 0x2d, 0x1f);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_write(s->regmap, 0x70, "\x01\x01", 2);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(s->regmap, 0x1a, 0x17);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(s->regmap, 0x1f, 0x1a);\r\nif (ret)\r\ngoto err;\r\ns->active = true;\r\nerr:\r\nif (ret)\r\ndev_dbg(&s->client->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int e4000_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct e4000 *s = fe->tuner_priv;\r\nint ret;\r\ndev_dbg(&s->client->dev, "%s:\n", __func__);\r\ns->active = false;\r\nret = regmap_write(s->regmap, 0x00, 0x00);\r\nif (ret)\r\ngoto err;\r\nerr:\r\nif (ret)\r\ndev_dbg(&s->client->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int e4000_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct e4000 *s = fe->tuner_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i, sigma_delta;\r\nunsigned int pll_n, pll_f;\r\nu64 f_vco;\r\nu8 buf[5], i_data[4], q_data[4];\r\ndev_dbg(&s->client->dev,\r\n"%s: delivery_system=%d frequency=%u bandwidth_hz=%u\n",\r\n__func__, c->delivery_system, c->frequency,\r\nc->bandwidth_hz);\r\nret = regmap_write(s->regmap, 0x1a, 0x00);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(e4000_pll_lut); i++) {\r\nif (c->frequency <= e4000_pll_lut[i].freq)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(e4000_pll_lut)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nf_vco = 1ull * c->frequency * e4000_pll_lut[i].mul;\r\npll_n = div_u64_rem(f_vco, s->clock, &pll_f);\r\nsigma_delta = div_u64(0x10000ULL * pll_f, s->clock);\r\nbuf[0] = pll_n;\r\nbuf[1] = (sigma_delta >> 0) & 0xff;\r\nbuf[2] = (sigma_delta >> 8) & 0xff;\r\nbuf[3] = 0x00;\r\nbuf[4] = e4000_pll_lut[i].div;\r\ndev_dbg(&s->client->dev,\r\n"%s: f_vco=%llu pll div=%d sigma_delta=%04x\n",\r\n__func__, f_vco, buf[0], sigma_delta);\r\nret = regmap_bulk_write(s->regmap, 0x09, buf, 5);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(e400_lna_filter_lut); i++) {\r\nif (c->frequency <= e400_lna_filter_lut[i].freq)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(e400_lna_filter_lut)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = regmap_write(s->regmap, 0x10, e400_lna_filter_lut[i].val);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(e4000_if_filter_lut); i++) {\r\nif (c->bandwidth_hz <= e4000_if_filter_lut[i].freq)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(e4000_if_filter_lut)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nbuf[0] = e4000_if_filter_lut[i].reg11_val;\r\nbuf[1] = e4000_if_filter_lut[i].reg12_val;\r\nret = regmap_bulk_write(s->regmap, 0x11, buf, 2);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(e4000_band_lut); i++) {\r\nif (c->frequency <= e4000_band_lut[i].freq)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(e4000_band_lut)) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = regmap_write(s->regmap, 0x07, e4000_band_lut[i].reg07_val);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(s->regmap, 0x78, e4000_band_lut[i].reg78_val);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < 4; i++) {\r\nif (i == 0)\r\nret = regmap_bulk_write(s->regmap, 0x15, "\x00\x7e\x24", 3);\r\nelse if (i == 1)\r\nret = regmap_bulk_write(s->regmap, 0x15, "\x00\x7f", 2);\r\nelse if (i == 2)\r\nret = regmap_bulk_write(s->regmap, 0x15, "\x01", 1);\r\nelse\r\nret = regmap_bulk_write(s->regmap, 0x16, "\x7e", 1);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(s->regmap, 0x29, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_read(s->regmap, 0x2a, buf, 3);\r\nif (ret)\r\ngoto err;\r\ni_data[i] = (((buf[2] >> 0) & 0x3) << 6) | (buf[0] & 0x3f);\r\nq_data[i] = (((buf[2] >> 4) & 0x3) << 6) | (buf[1] & 0x3f);\r\n}\r\nswap(q_data[2], q_data[3]);\r\nswap(i_data[2], i_data[3]);\r\nret = regmap_bulk_write(s->regmap, 0x50, q_data, 4);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_write(s->regmap, 0x60, i_data, 4);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(s->regmap, 0x1a, 0x17);\r\nif (ret)\r\ngoto err;\r\nerr:\r\nif (ret)\r\ndev_dbg(&s->client->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int e4000_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct e4000 *s = fe->tuner_priv;\r\ndev_dbg(&s->client->dev, "%s:\n", __func__);\r\n*frequency = 0;\r\nreturn 0;\r\n}\r\nstatic int e4000_set_lna_gain(struct dvb_frontend *fe)\r\n{\r\nstruct e4000 *s = fe->tuner_priv;\r\nint ret;\r\nu8 u8tmp;\r\ndev_dbg(&s->client->dev, "%s: lna auto=%d->%d val=%d->%d\n",\r\n__func__, s->lna_gain_auto->cur.val,\r\ns->lna_gain_auto->val, s->lna_gain->cur.val,\r\ns->lna_gain->val);\r\nif (s->lna_gain_auto->val && s->if_gain_auto->cur.val)\r\nu8tmp = 0x17;\r\nelse if (s->lna_gain_auto->val)\r\nu8tmp = 0x19;\r\nelse if (s->if_gain_auto->cur.val)\r\nu8tmp = 0x16;\r\nelse\r\nu8tmp = 0x10;\r\nret = regmap_write(s->regmap, 0x1a, u8tmp);\r\nif (ret)\r\ngoto err;\r\nif (s->lna_gain_auto->val == false) {\r\nret = regmap_write(s->regmap, 0x14, s->lna_gain->val);\r\nif (ret)\r\ngoto err;\r\n}\r\nerr:\r\nif (ret)\r\ndev_dbg(&s->client->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int e4000_set_mixer_gain(struct dvb_frontend *fe)\r\n{\r\nstruct e4000 *s = fe->tuner_priv;\r\nint ret;\r\nu8 u8tmp;\r\ndev_dbg(&s->client->dev, "%s: mixer auto=%d->%d val=%d->%d\n",\r\n__func__, s->mixer_gain_auto->cur.val,\r\ns->mixer_gain_auto->val, s->mixer_gain->cur.val,\r\ns->mixer_gain->val);\r\nif (s->mixer_gain_auto->val)\r\nu8tmp = 0x15;\r\nelse\r\nu8tmp = 0x14;\r\nret = regmap_write(s->regmap, 0x20, u8tmp);\r\nif (ret)\r\ngoto err;\r\nif (s->mixer_gain_auto->val == false) {\r\nret = regmap_write(s->regmap, 0x15, s->mixer_gain->val);\r\nif (ret)\r\ngoto err;\r\n}\r\nerr:\r\nif (ret)\r\ndev_dbg(&s->client->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int e4000_set_if_gain(struct dvb_frontend *fe)\r\n{\r\nstruct e4000 *s = fe->tuner_priv;\r\nint ret;\r\nu8 buf[2];\r\nu8 u8tmp;\r\ndev_dbg(&s->client->dev, "%s: if auto=%d->%d val=%d->%d\n",\r\n__func__, s->if_gain_auto->cur.val,\r\ns->if_gain_auto->val, s->if_gain->cur.val,\r\ns->if_gain->val);\r\nif (s->if_gain_auto->val && s->lna_gain_auto->cur.val)\r\nu8tmp = 0x17;\r\nelse if (s->lna_gain_auto->cur.val)\r\nu8tmp = 0x19;\r\nelse if (s->if_gain_auto->val)\r\nu8tmp = 0x16;\r\nelse\r\nu8tmp = 0x10;\r\nret = regmap_write(s->regmap, 0x1a, u8tmp);\r\nif (ret)\r\ngoto err;\r\nif (s->if_gain_auto->val == false) {\r\nbuf[0] = e4000_if_gain_lut[s->if_gain->val].reg16_val;\r\nbuf[1] = e4000_if_gain_lut[s->if_gain->val].reg17_val;\r\nret = regmap_bulk_write(s->regmap, 0x16, buf, 2);\r\nif (ret)\r\ngoto err;\r\n}\r\nerr:\r\nif (ret)\r\ndev_dbg(&s->client->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int e4000_pll_lock(struct dvb_frontend *fe)\r\n{\r\nstruct e4000 *s = fe->tuner_priv;\r\nint ret;\r\nunsigned int utmp;\r\nret = regmap_read(s->regmap, 0x07, &utmp);\r\nif (ret)\r\ngoto err;\r\ns->pll_lock->val = (utmp & 0x01);\r\nerr:\r\nif (ret)\r\ndev_dbg(&s->client->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int e4000_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct e4000 *s = container_of(ctrl->handler, struct e4000, hdl);\r\nint ret;\r\nif (s->active == false)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_RF_TUNER_PLL_LOCK:\r\nret = e4000_pll_lock(s->fe);\r\nbreak;\r\ndefault:\r\ndev_dbg(&s->client->dev, "%s: unknown ctrl: id=%d name=%s\n",\r\n__func__, ctrl->id, ctrl->name);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int e4000_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct e4000 *s = container_of(ctrl->handler, struct e4000, hdl);\r\nstruct dvb_frontend *fe = s->fe;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\nif (s->active == false)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_RF_TUNER_BANDWIDTH_AUTO:\r\ncase V4L2_CID_RF_TUNER_BANDWIDTH:\r\nc->bandwidth_hz = s->bandwidth->val;\r\nret = e4000_set_params(s->fe);\r\nbreak;\r\ncase V4L2_CID_RF_TUNER_LNA_GAIN_AUTO:\r\ncase V4L2_CID_RF_TUNER_LNA_GAIN:\r\nret = e4000_set_lna_gain(s->fe);\r\nbreak;\r\ncase V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO:\r\ncase V4L2_CID_RF_TUNER_MIXER_GAIN:\r\nret = e4000_set_mixer_gain(s->fe);\r\nbreak;\r\ncase V4L2_CID_RF_TUNER_IF_GAIN_AUTO:\r\ncase V4L2_CID_RF_TUNER_IF_GAIN:\r\nret = e4000_set_if_gain(s->fe);\r\nbreak;\r\ndefault:\r\ndev_dbg(&s->client->dev, "%s: unknown ctrl: id=%d name=%s\n",\r\n__func__, ctrl->id, ctrl->name);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int e4000_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct e4000_config *cfg = client->dev.platform_data;\r\nstruct dvb_frontend *fe = cfg->fe;\r\nstruct e4000 *s;\r\nint ret;\r\nunsigned int utmp;\r\nstatic const struct regmap_config regmap_config = {\r\n.reg_bits = 8,\r\n.val_bits = 8,\r\n.max_register = 0xff,\r\n};\r\ns = kzalloc(sizeof(struct e4000), GFP_KERNEL);\r\nif (!s) {\r\nret = -ENOMEM;\r\ndev_err(&client->dev, "%s: kzalloc() failed\n", KBUILD_MODNAME);\r\ngoto err;\r\n}\r\ns->clock = cfg->clock;\r\ns->client = client;\r\ns->fe = cfg->fe;\r\ns->regmap = devm_regmap_init_i2c(client, &regmap_config);\r\nif (IS_ERR(s->regmap)) {\r\nret = PTR_ERR(s->regmap);\r\ngoto err;\r\n}\r\nret = regmap_read(s->regmap, 0x02, &utmp);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&s->client->dev, "%s: chip id=%02x\n", __func__, utmp);\r\nif (utmp != 0x40) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nret = regmap_write(s->regmap, 0x00, 0x00);\r\nif (ret)\r\ngoto err;\r\n#if IS_ENABLED(CONFIG_VIDEO_V4L2)\r\nv4l2_ctrl_handler_init(&s->hdl, 9);\r\ns->bandwidth_auto = v4l2_ctrl_new_std(&s->hdl, &e4000_ctrl_ops,\r\nV4L2_CID_RF_TUNER_BANDWIDTH_AUTO, 0, 1, 1, 1);\r\ns->bandwidth = v4l2_ctrl_new_std(&s->hdl, &e4000_ctrl_ops,\r\nV4L2_CID_RF_TUNER_BANDWIDTH, 4300000, 11000000, 100000, 4300000);\r\nv4l2_ctrl_auto_cluster(2, &s->bandwidth_auto, 0, false);\r\ns->lna_gain_auto = v4l2_ctrl_new_std(&s->hdl, &e4000_ctrl_ops,\r\nV4L2_CID_RF_TUNER_LNA_GAIN_AUTO, 0, 1, 1, 1);\r\ns->lna_gain = v4l2_ctrl_new_std(&s->hdl, &e4000_ctrl_ops,\r\nV4L2_CID_RF_TUNER_LNA_GAIN, 0, 15, 1, 10);\r\nv4l2_ctrl_auto_cluster(2, &s->lna_gain_auto, 0, false);\r\ns->mixer_gain_auto = v4l2_ctrl_new_std(&s->hdl, &e4000_ctrl_ops,\r\nV4L2_CID_RF_TUNER_MIXER_GAIN_AUTO, 0, 1, 1, 1);\r\ns->mixer_gain = v4l2_ctrl_new_std(&s->hdl, &e4000_ctrl_ops,\r\nV4L2_CID_RF_TUNER_MIXER_GAIN, 0, 1, 1, 1);\r\nv4l2_ctrl_auto_cluster(2, &s->mixer_gain_auto, 0, false);\r\ns->if_gain_auto = v4l2_ctrl_new_std(&s->hdl, &e4000_ctrl_ops,\r\nV4L2_CID_RF_TUNER_IF_GAIN_AUTO, 0, 1, 1, 1);\r\ns->if_gain = v4l2_ctrl_new_std(&s->hdl, &e4000_ctrl_ops,\r\nV4L2_CID_RF_TUNER_IF_GAIN, 0, 54, 1, 0);\r\nv4l2_ctrl_auto_cluster(2, &s->if_gain_auto, 0, false);\r\ns->pll_lock = v4l2_ctrl_new_std(&s->hdl, &e4000_ctrl_ops,\r\nV4L2_CID_RF_TUNER_PLL_LOCK, 0, 1, 1, 0);\r\nif (s->hdl.error) {\r\nret = s->hdl.error;\r\ndev_err(&s->client->dev, "Could not initialize controls\n");\r\nv4l2_ctrl_handler_free(&s->hdl);\r\ngoto err;\r\n}\r\ns->sd.ctrl_handler = &s->hdl;\r\n#endif\r\ndev_info(&s->client->dev,\r\n"%s: Elonics E4000 successfully identified\n",\r\nKBUILD_MODNAME);\r\nfe->tuner_priv = s;\r\nmemcpy(&fe->ops.tuner_ops, &e4000_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nv4l2_set_subdevdata(&s->sd, client);\r\ni2c_set_clientdata(client, &s->sd);\r\nreturn 0;\r\nerr:\r\nif (ret) {\r\ndev_dbg(&client->dev, "%s: failed=%d\n", __func__, ret);\r\nkfree(s);\r\n}\r\nreturn ret;\r\n}\r\nstatic int e4000_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct e4000 *s = container_of(sd, struct e4000, sd);\r\nstruct dvb_frontend *fe = s->fe;\r\ndev_dbg(&client->dev, "%s:\n", __func__);\r\n#if IS_ENABLED(CONFIG_VIDEO_V4L2)\r\nv4l2_ctrl_handler_free(&s->hdl);\r\n#endif\r\nmemset(&fe->ops.tuner_ops, 0, sizeof(struct dvb_tuner_ops));\r\nfe->tuner_priv = NULL;\r\nkfree(s);\r\nreturn 0;\r\n}
