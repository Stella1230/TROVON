static inline int should_deliver(const struct net_bridge_port *p,\r\nconst struct sk_buff *skb)\r\n{\r\nreturn ((p->flags & BR_HAIRPIN_MODE) || skb->dev != p->dev) &&\r\nbr_allowed_egress(p->br, nbp_get_vlan_info(p), skb) &&\r\np->state == BR_STATE_FORWARDING;\r\n}\r\nint br_dev_queue_push_xmit(struct sk_buff *skb)\r\n{\r\nif (nf_bridge_maybe_copy_header(skb) ||\r\n!is_skb_forwardable(skb->dev, skb)) {\r\nkfree_skb(skb);\r\n} else {\r\nskb_push(skb, ETH_HLEN);\r\nbr_drop_fake_rtable(skb);\r\ndev_queue_xmit(skb);\r\n}\r\nreturn 0;\r\n}\r\nint br_forward_finish(struct sk_buff *skb)\r\n{\r\nreturn NF_HOOK(NFPROTO_BRIDGE, NF_BR_POST_ROUTING, skb, NULL, skb->dev,\r\nbr_dev_queue_push_xmit);\r\n}\r\nstatic void __br_deliver(const struct net_bridge_port *to, struct sk_buff *skb)\r\n{\r\nskb = br_handle_vlan(to->br, nbp_get_vlan_info(to), skb);\r\nif (!skb)\r\nreturn;\r\nskb->dev = to->dev;\r\nif (unlikely(netpoll_tx_running(to->br->dev))) {\r\nif (!is_skb_forwardable(skb->dev, skb))\r\nkfree_skb(skb);\r\nelse {\r\nskb_push(skb, ETH_HLEN);\r\nbr_netpoll_send_skb(to, skb);\r\n}\r\nreturn;\r\n}\r\nNF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, skb, NULL, skb->dev,\r\nbr_forward_finish);\r\n}\r\nstatic void __br_forward(const struct net_bridge_port *to, struct sk_buff *skb)\r\n{\r\nstruct net_device *indev;\r\nif (skb_warn_if_lro(skb)) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nskb = br_handle_vlan(to->br, nbp_get_vlan_info(to), skb);\r\nif (!skb)\r\nreturn;\r\nindev = skb->dev;\r\nskb->dev = to->dev;\r\nskb_forward_csum(skb);\r\nNF_HOOK(NFPROTO_BRIDGE, NF_BR_FORWARD, skb, indev, skb->dev,\r\nbr_forward_finish);\r\n}\r\nvoid br_deliver(const struct net_bridge_port *to, struct sk_buff *skb)\r\n{\r\nif (to && should_deliver(to, skb)) {\r\n__br_deliver(to, skb);\r\nreturn;\r\n}\r\nkfree_skb(skb);\r\n}\r\nvoid br_forward(const struct net_bridge_port *to, struct sk_buff *skb, struct sk_buff *skb0)\r\n{\r\nif (should_deliver(to, skb)) {\r\nif (skb0)\r\ndeliver_clone(to, skb, __br_forward);\r\nelse\r\n__br_forward(to, skb);\r\nreturn;\r\n}\r\nif (!skb0)\r\nkfree_skb(skb);\r\n}\r\nstatic int deliver_clone(const struct net_bridge_port *prev,\r\nstruct sk_buff *skb,\r\nvoid (*__packet_hook)(const struct net_bridge_port *p,\r\nstruct sk_buff *skb))\r\n{\r\nstruct net_device *dev = BR_INPUT_SKB_CB(skb)->brdev;\r\nskb = skb_clone(skb, GFP_ATOMIC);\r\nif (!skb) {\r\ndev->stats.tx_dropped++;\r\nreturn -ENOMEM;\r\n}\r\n__packet_hook(prev, skb);\r\nreturn 0;\r\n}\r\nstatic struct net_bridge_port *maybe_deliver(\r\nstruct net_bridge_port *prev, struct net_bridge_port *p,\r\nstruct sk_buff *skb,\r\nvoid (*__packet_hook)(const struct net_bridge_port *p,\r\nstruct sk_buff *skb))\r\n{\r\nint err;\r\nif (!should_deliver(p, skb))\r\nreturn prev;\r\nif (!prev)\r\ngoto out;\r\nerr = deliver_clone(prev, skb, __packet_hook);\r\nif (err)\r\nreturn ERR_PTR(err);\r\nout:\r\nreturn p;\r\n}\r\nstatic void br_flood(struct net_bridge *br, struct sk_buff *skb,\r\nstruct sk_buff *skb0,\r\nvoid (*__packet_hook)(const struct net_bridge_port *p,\r\nstruct sk_buff *skb),\r\nbool unicast)\r\n{\r\nstruct net_bridge_port *p;\r\nstruct net_bridge_port *prev;\r\nprev = NULL;\r\nlist_for_each_entry_rcu(p, &br->port_list, list) {\r\nif (unicast && !(p->flags & BR_FLOOD))\r\ncontinue;\r\nprev = maybe_deliver(prev, p, skb, __packet_hook);\r\nif (IS_ERR(prev))\r\ngoto out;\r\n}\r\nif (!prev)\r\ngoto out;\r\nif (skb0)\r\ndeliver_clone(prev, skb, __packet_hook);\r\nelse\r\n__packet_hook(prev, skb);\r\nreturn;\r\nout:\r\nif (!skb0)\r\nkfree_skb(skb);\r\n}\r\nvoid br_flood_deliver(struct net_bridge *br, struct sk_buff *skb, bool unicast)\r\n{\r\nbr_flood(br, skb, NULL, __br_deliver, unicast);\r\n}\r\nvoid br_flood_forward(struct net_bridge *br, struct sk_buff *skb,\r\nstruct sk_buff *skb2, bool unicast)\r\n{\r\nbr_flood(br, skb, skb2, __br_forward, unicast);\r\n}\r\nstatic void br_multicast_flood(struct net_bridge_mdb_entry *mdst,\r\nstruct sk_buff *skb, struct sk_buff *skb0,\r\nvoid (*__packet_hook)(\r\nconst struct net_bridge_port *p,\r\nstruct sk_buff *skb))\r\n{\r\nstruct net_device *dev = BR_INPUT_SKB_CB(skb)->brdev;\r\nstruct net_bridge *br = netdev_priv(dev);\r\nstruct net_bridge_port *prev = NULL;\r\nstruct net_bridge_port_group *p;\r\nstruct hlist_node *rp;\r\nrp = rcu_dereference(hlist_first_rcu(&br->router_list));\r\np = mdst ? rcu_dereference(mdst->ports) : NULL;\r\nwhile (p || rp) {\r\nstruct net_bridge_port *port, *lport, *rport;\r\nlport = p ? p->port : NULL;\r\nrport = rp ? hlist_entry(rp, struct net_bridge_port, rlist) :\r\nNULL;\r\nport = (unsigned long)lport > (unsigned long)rport ?\r\nlport : rport;\r\nprev = maybe_deliver(prev, port, skb, __packet_hook);\r\nif (IS_ERR(prev))\r\ngoto out;\r\nif ((unsigned long)lport >= (unsigned long)port)\r\np = rcu_dereference(p->next);\r\nif ((unsigned long)rport >= (unsigned long)port)\r\nrp = rcu_dereference(hlist_next_rcu(rp));\r\n}\r\nif (!prev)\r\ngoto out;\r\nif (skb0)\r\ndeliver_clone(prev, skb, __packet_hook);\r\nelse\r\n__packet_hook(prev, skb);\r\nreturn;\r\nout:\r\nif (!skb0)\r\nkfree_skb(skb);\r\n}\r\nvoid br_multicast_deliver(struct net_bridge_mdb_entry *mdst,\r\nstruct sk_buff *skb)\r\n{\r\nbr_multicast_flood(mdst, skb, NULL, __br_deliver);\r\n}\r\nvoid br_multicast_forward(struct net_bridge_mdb_entry *mdst,\r\nstruct sk_buff *skb, struct sk_buff *skb2)\r\n{\r\nbr_multicast_flood(mdst, skb, skb2, __br_forward);\r\n}
