static inline struct f_gether *func_to_geth(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_gether, port.func);\r\n}\r\nstatic int geth_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\r\n{\r\nstruct f_gether *geth = func_to_geth(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct net_device *net;\r\nif (geth->port.in_ep->driver_data) {\r\nDBG(cdev, "reset cdc subset\n");\r\ngether_disconnect(&geth->port);\r\n}\r\nDBG(cdev, "init + activate cdc subset\n");\r\nif (config_ep_by_speed(cdev->gadget, f, geth->port.in_ep) ||\r\nconfig_ep_by_speed(cdev->gadget, f, geth->port.out_ep)) {\r\ngeth->port.in_ep->desc = NULL;\r\ngeth->port.out_ep->desc = NULL;\r\nreturn -EINVAL;\r\n}\r\nnet = gether_connect(&geth->port);\r\nreturn PTR_ERR_OR_ZERO(net);\r\n}\r\nstatic void geth_disable(struct usb_function *f)\r\n{\r\nstruct f_gether *geth = func_to_geth(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nDBG(cdev, "net deactivated\n");\r\ngether_disconnect(&geth->port);\r\n}\r\nstatic int\r\ngeth_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct f_gether *geth = func_to_geth(f);\r\nstruct usb_string *us;\r\nint status;\r\nstruct usb_ep *ep;\r\nstruct f_gether_opts *gether_opts;\r\ngether_opts = container_of(f->fi, struct f_gether_opts, func_inst);\r\nif (!gether_opts->bound) {\r\nmutex_lock(&gether_opts->lock);\r\ngether_set_gadget(gether_opts->net, cdev->gadget);\r\nstatus = gether_register_netdev(gether_opts->net);\r\nmutex_unlock(&gether_opts->lock);\r\nif (status)\r\nreturn status;\r\ngether_opts->bound = true;\r\n}\r\nus = usb_gstrings_attach(cdev, geth_strings,\r\nARRAY_SIZE(geth_string_defs));\r\nif (IS_ERR(us))\r\nreturn PTR_ERR(us);\r\nsubset_data_intf.iInterface = us[0].id;\r\nether_desc.iMACAddress = us[1].id;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nsubset_data_intf.bInterfaceNumber = status;\r\nstatus = -ENODEV;\r\nep = usb_ep_autoconfig(cdev->gadget, &fs_subset_in_desc);\r\nif (!ep)\r\ngoto fail;\r\ngeth->port.in_ep = ep;\r\nep->driver_data = cdev;\r\nep = usb_ep_autoconfig(cdev->gadget, &fs_subset_out_desc);\r\nif (!ep)\r\ngoto fail;\r\ngeth->port.out_ep = ep;\r\nep->driver_data = cdev;\r\nhs_subset_in_desc.bEndpointAddress = fs_subset_in_desc.bEndpointAddress;\r\nhs_subset_out_desc.bEndpointAddress =\r\nfs_subset_out_desc.bEndpointAddress;\r\nss_subset_in_desc.bEndpointAddress = fs_subset_in_desc.bEndpointAddress;\r\nss_subset_out_desc.bEndpointAddress =\r\nfs_subset_out_desc.bEndpointAddress;\r\nstatus = usb_assign_descriptors(f, fs_eth_function, hs_eth_function,\r\nss_eth_function);\r\nif (status)\r\ngoto fail;\r\nDBG(cdev, "CDC Subset: %s speed IN/%s OUT/%s\n",\r\ngadget_is_superspeed(c->cdev->gadget) ? "super" :\r\ngadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",\r\ngeth->port.in_ep->name, geth->port.out_ep->name);\r\nreturn 0;\r\nfail:\r\nusb_free_all_descriptors(f);\r\nif (geth->port.out_ep)\r\ngeth->port.out_ep->driver_data = NULL;\r\nif (geth->port.in_ep)\r\ngeth->port.in_ep->driver_data = NULL;\r\nERROR(cdev, "%s: can't bind, err %d\n", f->name, status);\r\nreturn status;\r\n}\r\nstatic inline struct f_gether_opts *to_f_gether_opts(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct f_gether_opts,\r\nfunc_inst.group);\r\n}\r\nstatic void geth_free_inst(struct usb_function_instance *f)\r\n{\r\nstruct f_gether_opts *opts;\r\nopts = container_of(f, struct f_gether_opts, func_inst);\r\nif (opts->bound)\r\ngether_cleanup(netdev_priv(opts->net));\r\nelse\r\nfree_netdev(opts->net);\r\nkfree(opts);\r\n}\r\nstatic struct usb_function_instance *geth_alloc_inst(void)\r\n{\r\nstruct f_gether_opts *opts;\r\nopts = kzalloc(sizeof(*opts), GFP_KERNEL);\r\nif (!opts)\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_init(&opts->lock);\r\nopts->func_inst.free_func_inst = geth_free_inst;\r\nopts->net = gether_setup_default();\r\nif (IS_ERR(opts->net)) {\r\nstruct net_device *net = opts->net;\r\nkfree(opts);\r\nreturn ERR_CAST(net);\r\n}\r\nconfig_group_init_type_name(&opts->func_inst.group, "",\r\n&gether_func_type);\r\nreturn &opts->func_inst;\r\n}\r\nstatic void geth_free(struct usb_function *f)\r\n{\r\nstruct f_gether *eth;\r\neth = func_to_geth(f);\r\nkfree(eth);\r\n}\r\nstatic void geth_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\ngeth_string_defs[0].id = 0;\r\nusb_free_all_descriptors(f);\r\n}\r\nstatic struct usb_function *geth_alloc(struct usb_function_instance *fi)\r\n{\r\nstruct f_gether *geth;\r\nstruct f_gether_opts *opts;\r\nint status;\r\ngeth = kzalloc(sizeof(*geth), GFP_KERNEL);\r\nif (!geth)\r\nreturn ERR_PTR(-ENOMEM);\r\nopts = container_of(fi, struct f_gether_opts, func_inst);\r\nmutex_lock(&opts->lock);\r\nopts->refcnt++;\r\nstatus = gether_get_host_addr_cdc(opts->net, geth->ethaddr,\r\nsizeof(geth->ethaddr));\r\nif (status < 12) {\r\nkfree(geth);\r\nmutex_unlock(&opts->lock);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ngeth_string_defs[1].s = geth->ethaddr;\r\ngeth->port.ioport = netdev_priv(opts->net);\r\nmutex_unlock(&opts->lock);\r\ngeth->port.cdc_filter = DEFAULT_FILTER;\r\ngeth->port.func.name = "cdc_subset";\r\ngeth->port.func.bind = geth_bind;\r\ngeth->port.func.unbind = geth_unbind;\r\ngeth->port.func.set_alt = geth_set_alt;\r\ngeth->port.func.disable = geth_disable;\r\ngeth->port.func.free_func = geth_free;\r\nreturn &geth->port.func;\r\n}
