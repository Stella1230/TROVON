static int pcic_read_config_dword(unsigned int busno, unsigned int devfn,\r\nint where, u32 *value)\r\n{\r\nstruct linux_pcic *pcic;\r\nunsigned long flags;\r\npcic = &pcic0;\r\nlocal_irq_save(flags);\r\n#if 0\r\npcic_speculative = 1;\r\npcic_trapped = 0;\r\n#endif\r\nwritel(CONFIG_CMD(busno, devfn, where), pcic->pcic_config_space_addr);\r\n#if 0\r\nnop();\r\nif (pcic_trapped) {\r\nlocal_irq_restore(flags);\r\n*value = ~0;\r\nreturn 0;\r\n}\r\n#endif\r\npcic_speculative = 2;\r\npcic_trapped = 0;\r\n*value = readl(pcic->pcic_config_space_data + (where&4));\r\nnop();\r\nif (pcic_trapped) {\r\npcic_speculative = 0;\r\nlocal_irq_restore(flags);\r\n*value = ~0;\r\nreturn 0;\r\n}\r\npcic_speculative = 0;\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int pcic_read_config(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nunsigned int v;\r\nif (bus->number != 0) return -EINVAL;\r\nswitch (size) {\r\ncase 1:\r\npcic_read_config_dword(bus->number, devfn, where&~3, &v);\r\n*val = 0xff & (v >> (8*(where & 3)));\r\nreturn 0;\r\ncase 2:\r\nif (where&1) return -EINVAL;\r\npcic_read_config_dword(bus->number, devfn, where&~3, &v);\r\n*val = 0xffff & (v >> (8*(where & 3)));\r\nreturn 0;\r\ncase 4:\r\nif (where&3) return -EINVAL;\r\npcic_read_config_dword(bus->number, devfn, where&~3, val);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int pcic_write_config_dword(unsigned int busno, unsigned int devfn,\r\nint where, u32 value)\r\n{\r\nstruct linux_pcic *pcic;\r\nunsigned long flags;\r\npcic = &pcic0;\r\nlocal_irq_save(flags);\r\nwritel(CONFIG_CMD(busno, devfn, where), pcic->pcic_config_space_addr);\r\nwritel(value, pcic->pcic_config_space_data + (where&4));\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int pcic_write_config(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nunsigned int v;\r\nif (bus->number != 0) return -EINVAL;\r\nswitch (size) {\r\ncase 1:\r\npcic_read_config_dword(bus->number, devfn, where&~3, &v);\r\nv = (v & ~(0xff << (8*(where&3)))) |\r\n((0xff&val) << (8*(where&3)));\r\nreturn pcic_write_config_dword(bus->number, devfn, where&~3, v);\r\ncase 2:\r\nif (where&1) return -EINVAL;\r\npcic_read_config_dword(bus->number, devfn, where&~3, &v);\r\nv = (v & ~(0xffff << (8*(where&3)))) |\r\n((0xffff&val) << (8*(where&3)));\r\nreturn pcic_write_config_dword(bus->number, devfn, where&~3, v);\r\ncase 4:\r\nif (where&3) return -EINVAL;\r\nreturn pcic_write_config_dword(bus->number, devfn, where, val);\r\n}\r\nreturn -EINVAL;\r\n}\r\nint __init pcic_probe(void)\r\n{\r\nstruct linux_pcic *pcic;\r\nstruct linux_prom_registers regs[PROMREG_MAX];\r\nstruct linux_pbm_info* pbm;\r\nchar namebuf[64];\r\nphandle node;\r\nint err;\r\nif (pcic0_up) {\r\nprom_printf("PCIC: called twice!\n");\r\nprom_halt();\r\n}\r\npcic = &pcic0;\r\nnode = prom_getchild (prom_root_node);\r\nnode = prom_searchsiblings (node, "pci");\r\nif (node == 0)\r\nreturn -ENODEV;\r\nerr = prom_getproperty(node, "reg", (char*)regs, sizeof(regs));\r\nif (err == 0 || err == -1) {\r\nprom_printf("PCIC: Error, cannot get PCIC registers "\r\n"from PROM.\n");\r\nprom_halt();\r\n}\r\npcic0_up = 1;\r\npcic->pcic_res_regs.name = "pcic_registers";\r\npcic->pcic_regs = ioremap(regs[0].phys_addr, regs[0].reg_size);\r\nif (!pcic->pcic_regs) {\r\nprom_printf("PCIC: Error, cannot map PCIC registers.\n");\r\nprom_halt();\r\n}\r\npcic->pcic_res_io.name = "pcic_io";\r\nif ((pcic->pcic_io = (unsigned long)\r\nioremap(regs[1].phys_addr, 0x10000)) == 0) {\r\nprom_printf("PCIC: Error, cannot map PCIC IO Base.\n");\r\nprom_halt();\r\n}\r\npcic->pcic_res_cfg_addr.name = "pcic_cfg_addr";\r\nif ((pcic->pcic_config_space_addr =\r\nioremap(regs[2].phys_addr, regs[2].reg_size * 2)) == NULL) {\r\nprom_printf("PCIC: Error, cannot map "\r\n"PCI Configuration Space Address.\n");\r\nprom_halt();\r\n}\r\npcic->pcic_res_cfg_data.name = "pcic_cfg_data";\r\nif ((pcic->pcic_config_space_data =\r\nioremap(regs[3].phys_addr, regs[3].reg_size * 2)) == NULL) {\r\nprom_printf("PCIC: Error, cannot map "\r\n"PCI Configuration Space Data.\n");\r\nprom_halt();\r\n}\r\npbm = &pcic->pbm;\r\npbm->prom_node = node;\r\nprom_getstring(node, "name", namebuf, 63); namebuf[63] = 0;\r\nstrcpy(pbm->prom_name, namebuf);\r\n{\r\nextern int pcic_nmi_trap_patch[4];\r\nt_nmi[0] = pcic_nmi_trap_patch[0];\r\nt_nmi[1] = pcic_nmi_trap_patch[1];\r\nt_nmi[2] = pcic_nmi_trap_patch[2];\r\nt_nmi[3] = pcic_nmi_trap_patch[3];\r\nswift_flush_dcache();\r\npcic_regs = pcic->pcic_regs;\r\n}\r\nprom_getstring(prom_root_node, "name", namebuf, 63); namebuf[63] = 0;\r\n{\r\nstruct pcic_sn2list *p;\r\nfor (p = pcic_known_sysnames; p->sysname != NULL; p++) {\r\nif (strcmp(namebuf, p->sysname) == 0)\r\nbreak;\r\n}\r\npcic->pcic_imap = p->intmap;\r\npcic->pcic_imdim = p->mapdim;\r\n}\r\nif (pcic->pcic_imap == NULL) {\r\nprintk("PCIC: System %s is unknown, cannot route interrupts\n",\r\nnamebuf);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init pcic_pbm_scan_bus(struct linux_pcic *pcic)\r\n{\r\nstruct linux_pbm_info *pbm = &pcic->pbm;\r\npbm->pci_bus = pci_scan_bus(pbm->pci_first_busno, &pcic_ops, pbm);\r\n#if 0\r\npci_fill_in_pbm_cookies(pbm->pci_bus, pbm, pbm->prom_node);\r\npci_record_assignments(pbm, pbm->pci_bus);\r\npci_assign_unassigned(pbm, pbm->pci_bus);\r\npci_fixup_irq(pbm, pbm->pci_bus);\r\n#endif\r\n}\r\nstatic int __init pcic_init(void)\r\n{\r\nstruct linux_pcic *pcic;\r\nif(!pcic0_up)\r\nreturn 0;\r\npcic = &pcic0;\r\nwriteb(PCI_DVMA_CONTROL_IOTLB_DISABLE,\r\npcic->pcic_regs+PCI_DVMA_CONTROL);\r\nwritel(0xF0000000UL, pcic->pcic_regs+PCI_SIZE_0);\r\nwritel(0+PCI_BASE_ADDRESS_SPACE_MEMORY,\r\npcic->pcic_regs+PCI_BASE_ADDRESS_0);\r\npcic_pbm_scan_bus(pcic);\r\nreturn 0;\r\n}\r\nint pcic_present(void)\r\n{\r\nreturn pcic0_up;\r\n}\r\nstatic int pdev_to_pnode(struct linux_pbm_info *pbm, struct pci_dev *pdev)\r\n{\r\nstruct linux_prom_pci_registers regs[PROMREG_MAX];\r\nint err;\r\nphandle node = prom_getchild(pbm->prom_node);\r\nwhile(node) {\r\nerr = prom_getproperty(node, "reg",\r\n(char *)&regs[0], sizeof(regs));\r\nif(err != 0 && err != -1) {\r\nunsigned long devfn = (regs[0].which_io >> 8) & 0xff;\r\nif(devfn == pdev->devfn)\r\nreturn node;\r\n}\r\nnode = prom_getsibling(node);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline struct pcidev_cookie *pci_devcookie_alloc(void)\r\n{\r\nreturn kmalloc(sizeof(struct pcidev_cookie), GFP_ATOMIC);\r\n}\r\nstatic void pcic_map_pci_device(struct linux_pcic *pcic,\r\nstruct pci_dev *dev, int node)\r\n{\r\nchar namebuf[64];\r\nunsigned long address;\r\nunsigned long flags;\r\nint j;\r\nif (node == 0 || node == -1) {\r\nstrcpy(namebuf, "???");\r\n} else {\r\nprom_getstring(node, "name", namebuf, 63); namebuf[63] = 0;\r\n}\r\nfor (j = 0; j < 6; j++) {\r\naddress = dev->resource[j].start;\r\nif (address == 0) break;\r\nflags = dev->resource[j].flags;\r\nif ((flags & IORESOURCE_IO) != 0) {\r\nif (address < 0x10000) {\r\ndev->resource[j].start =\r\npcic->pcic_io + address;\r\ndev->resource[j].end = 1;\r\ndev->resource[j].flags =\r\n(flags & ~IORESOURCE_IO) | IORESOURCE_MEM;\r\n} else {\r\nprintk("PCIC: Skipping I/O space at 0x%lx, "\r\n"this will Oops if a driver attaches "\r\n"device '%s' at %02x:%02x)\n", address,\r\nnamebuf, dev->bus->number, dev->devfn);\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\npcic_fill_irq(struct linux_pcic *pcic, struct pci_dev *dev, int node)\r\n{\r\nstruct pcic_ca2irq *p;\r\nunsigned int real_irq;\r\nint i, ivec;\r\nchar namebuf[64];\r\nif (node == 0 || node == -1) {\r\nstrcpy(namebuf, "???");\r\n} else {\r\nprom_getstring(node, "name", namebuf, sizeof(namebuf));\r\n}\r\nif ((p = pcic->pcic_imap) == NULL) {\r\ndev->irq = 0;\r\nreturn;\r\n}\r\nfor (i = 0; i < pcic->pcic_imdim; i++) {\r\nif (p->busno == dev->bus->number && p->devfn == dev->devfn)\r\nbreak;\r\np++;\r\n}\r\nif (i >= pcic->pcic_imdim) {\r\nprintk("PCIC: device %s devfn %02x:%02x not found in %d\n",\r\nnamebuf, dev->bus->number, dev->devfn, pcic->pcic_imdim);\r\ndev->irq = 0;\r\nreturn;\r\n}\r\ni = p->pin;\r\nif (i >= 0 && i < 4) {\r\nivec = readw(pcic->pcic_regs+PCI_INT_SELECT_LO);\r\nreal_irq = ivec >> (i << 2) & 0xF;\r\n} else if (i >= 4 && i < 8) {\r\nivec = readw(pcic->pcic_regs+PCI_INT_SELECT_HI);\r\nreal_irq = ivec >> ((i-4) << 2) & 0xF;\r\n} else {\r\nprintk("PCIC: BAD PIN %d\n", i); for (;;) {}\r\n}\r\nif (real_irq == 0 || p->force) {\r\nif (p->irq == 0 || p->irq >= 15) {\r\nprintk("PCIC: BAD IRQ %d\n", p->irq); for (;;) {}\r\n}\r\nprintk("PCIC: setting irq %d at pin %d for device %02x:%02x\n",\r\np->irq, p->pin, dev->bus->number, dev->devfn);\r\nreal_irq = p->irq;\r\ni = p->pin;\r\nif (i >= 4) {\r\nivec = readw(pcic->pcic_regs+PCI_INT_SELECT_HI);\r\nivec &= ~(0xF << ((i - 4) << 2));\r\nivec |= p->irq << ((i - 4) << 2);\r\nwritew(ivec, pcic->pcic_regs+PCI_INT_SELECT_HI);\r\n} else {\r\nivec = readw(pcic->pcic_regs+PCI_INT_SELECT_LO);\r\nivec &= ~(0xF << (i << 2));\r\nivec |= p->irq << (i << 2);\r\nwritew(ivec, pcic->pcic_regs+PCI_INT_SELECT_LO);\r\n}\r\n}\r\ndev->irq = pcic_build_device_irq(NULL, real_irq);\r\n}\r\nvoid pcibios_fixup_bus(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\nint i, has_io, has_mem;\r\nunsigned int cmd;\r\nstruct linux_pcic *pcic;\r\nint node;\r\nstruct pcidev_cookie *pcp;\r\nif (!pcic0_up) {\r\nprintk("pcibios_fixup_bus: no PCIC\n");\r\nreturn;\r\n}\r\npcic = &pcic0;\r\nif (bus->number != 0) {\r\nprintk("pcibios_fixup_bus: nonzero bus 0x%x\n", bus->number);\r\nreturn;\r\n}\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nhas_io = has_mem = 0;\r\nfor(i=0; i<6; i++) {\r\nunsigned long f = dev->resource[i].flags;\r\nif (f & IORESOURCE_IO) {\r\nhas_io = 1;\r\n} else if (f & IORESOURCE_MEM)\r\nhas_mem = 1;\r\n}\r\npcic_read_config(dev->bus, dev->devfn, PCI_COMMAND, 2, &cmd);\r\nif (has_io && !(cmd & PCI_COMMAND_IO)) {\r\nprintk("PCIC: Enabling I/O for device %02x:%02x\n",\r\ndev->bus->number, dev->devfn);\r\ncmd |= PCI_COMMAND_IO;\r\npcic_write_config(dev->bus, dev->devfn,\r\nPCI_COMMAND, 2, cmd);\r\n}\r\nif (has_mem && !(cmd & PCI_COMMAND_MEMORY)) {\r\nprintk("PCIC: Enabling memory for device %02x:%02x\n",\r\ndev->bus->number, dev->devfn);\r\ncmd |= PCI_COMMAND_MEMORY;\r\npcic_write_config(dev->bus, dev->devfn,\r\nPCI_COMMAND, 2, cmd);\r\n}\r\nnode = pdev_to_pnode(&pcic->pbm, dev);\r\nif(node == 0)\r\nnode = -1;\r\npcp = pci_devcookie_alloc();\r\npcp->pbm = &pcic->pbm;\r\npcp->prom_node = of_find_node_by_phandle(node);\r\ndev->sysdata = pcp;\r\nif ((dev->class>>16) != PCI_BASE_CLASS_BRIDGE)\r\npcic_map_pci_device(pcic, dev, node);\r\npcic_fill_irq(pcic, dev, node);\r\n}\r\n}\r\nstatic void pcic_clear_clock_irq(void)\r\n{\r\npcic_timer_dummy = readl(pcic0.pcic_regs+PCI_SYS_LIMIT);\r\n}\r\nstatic unsigned int pcic_cycles_offset(void)\r\n{\r\nu32 value, count;\r\nvalue = readl(pcic0.pcic_regs + PCI_SYS_COUNTER);\r\ncount = value & ~PCI_SYS_COUNTER_OVERFLOW;\r\nif (value & PCI_SYS_COUNTER_OVERFLOW)\r\ncount += TICK_TIMER_LIMIT;\r\ncount = ((count / HZ) * USECS_PER_JIFFY) / (TICK_TIMER_LIMIT / HZ);\r\nreturn count * 2;\r\n}\r\nvoid __init pci_time_init(void)\r\n{\r\nstruct linux_pcic *pcic = &pcic0;\r\nunsigned long v;\r\nint timer_irq, irq;\r\nint err;\r\n#ifndef CONFIG_SMP\r\nsparc_config.clock_rate = SBUS_CLOCK_RATE / HZ;\r\nsparc_config.features |= FEAT_L10_CLOCKEVENT;\r\n#endif\r\nsparc_config.features |= FEAT_L10_CLOCKSOURCE;\r\nsparc_config.get_cycles_offset = pcic_cycles_offset;\r\nwritel (TICK_TIMER_LIMIT, pcic->pcic_regs+PCI_SYS_LIMIT);\r\nv = readb(pcic->pcic_regs+PCI_COUNTER_IRQ);\r\ntimer_irq = PCI_COUNTER_IRQ_SYS(v);\r\nwritel (PCI_COUNTER_IRQ_SET(timer_irq, 0),\r\npcic->pcic_regs+PCI_COUNTER_IRQ);\r\nirq = pcic_build_device_irq(NULL, timer_irq);\r\nerr = request_irq(irq, timer_interrupt,\r\nIRQF_TIMER, "timer", NULL);\r\nif (err) {\r\nprom_printf("time_init: unable to attach IRQ%d\n", timer_irq);\r\nprom_halt();\r\n}\r\nlocal_irq_enable();\r\n}\r\nresource_size_t pcibios_align_resource(void *data, const struct resource *res,\r\nresource_size_t size, resource_size_t align)\r\n{\r\nreturn res->start;\r\n}\r\nint pcibios_enable_device(struct pci_dev *pdev, int mask)\r\n{\r\nreturn 0;\r\n}\r\nvoid pcic_nmi(unsigned int pend, struct pt_regs *regs)\r\n{\r\npend = swab32(pend);\r\nif (!pcic_speculative || (pend & PCI_SYS_INT_PENDING_PIO) == 0) {\r\nprintk("Aiee, NMI pend 0x%x pc 0x%x spec %d, hanging\n",\r\npend, (int)regs->pc, pcic_speculative);\r\nfor (;;) { }\r\n}\r\npcic_speculative = 0;\r\npcic_trapped = 1;\r\nregs->pc = regs->npc;\r\nregs->npc += 4;\r\n}\r\nstatic inline unsigned long get_irqmask(int irq_nr)\r\n{\r\nreturn 1 << irq_nr;\r\n}\r\nstatic void pcic_mask_irq(struct irq_data *data)\r\n{\r\nunsigned long mask, flags;\r\nmask = (unsigned long)data->chip_data;\r\nlocal_irq_save(flags);\r\nwritel(mask, pcic0.pcic_regs+PCI_SYS_INT_TARGET_MASK_SET);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void pcic_unmask_irq(struct irq_data *data)\r\n{\r\nunsigned long mask, flags;\r\nmask = (unsigned long)data->chip_data;\r\nlocal_irq_save(flags);\r\nwritel(mask, pcic0.pcic_regs+PCI_SYS_INT_TARGET_MASK_CLEAR);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic unsigned int pcic_startup_irq(struct irq_data *data)\r\n{\r\nirq_link(data->irq);\r\npcic_unmask_irq(data);\r\nreturn 0;\r\n}\r\nunsigned int pcic_build_device_irq(struct platform_device *op,\r\nunsigned int real_irq)\r\n{\r\nunsigned int irq;\r\nunsigned long mask;\r\nirq = 0;\r\nmask = get_irqmask(real_irq);\r\nif (mask == 0)\r\ngoto out;\r\nirq = irq_alloc(real_irq, real_irq);\r\nif (irq == 0)\r\ngoto out;\r\nirq_set_chip_and_handler_name(irq, &pcic_irq,\r\nhandle_level_irq, "PCIC");\r\nirq_set_chip_data(irq, (void *)mask);\r\nout:\r\nreturn irq;\r\n}\r\nstatic void pcic_load_profile_irq(int cpu, unsigned int limit)\r\n{\r\nprintk("PCIC: unimplemented code: FILE=%s LINE=%d", __FILE__, __LINE__);\r\n}\r\nvoid __init sun4m_pci_init_IRQ(void)\r\n{\r\nsparc_config.build_device_irq = pcic_build_device_irq;\r\nsparc_config.clear_clock_irq = pcic_clear_clock_irq;\r\nsparc_config.load_profile_irq = pcic_load_profile_irq;\r\n}
