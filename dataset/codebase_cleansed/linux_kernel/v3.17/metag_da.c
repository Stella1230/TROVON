static int chancall(int in_bios_function, int in_channel,\r\nint in_arg2, void *in_arg3,\r\nvoid *in_arg4)\r\n{\r\nregister int bios_function asm("D1Ar1") = in_bios_function;\r\nregister int channel asm("D0Ar2") = in_channel;\r\nregister int arg2 asm("D1Ar3") = in_arg2;\r\nregister void *arg3 asm("D0Ar4") = in_arg3;\r\nregister void *arg4 asm("D1Ar5") = in_arg4;\r\nregister int bios_call asm("D0Ar6") = 3;\r\nregister int result asm("D0Re0");\r\nasm volatile (\r\n"MSETL [A0StP++], %6,%4,%2\n\t"\r\n"ADD A0StP, A0StP, #8\n\t"\r\n"SWITCH #0x0C30208\n\t"\r\n"GETD %0, [A0StP+#-8]\n\t"\r\n"SUB A0StP, A0StP, #(4*6)+8\n\t"\r\n: "=d" (result)\r\n: "d" (bios_function),\r\n"d" (channel),\r\n"d" (arg2),\r\n"d" (arg3),\r\n"d" (arg4),\r\n"d" (bios_call)\r\n: "memory");\r\nreturn result;\r\n}\r\nstatic int fetch_data(unsigned int channel)\r\n{\r\nstruct dashtty_port *dport = &dashtty_ports[channel];\r\nint received = 0;\r\nspin_lock_bh(&dport->rx_lock);\r\nif (!dport->rx_buf)\r\ngoto unlock;\r\nif (chancall(RDBUF, channel, RX_BUF_SIZE,\r\n(void *)dport->rx_buf, &received) == CONAOK) {\r\nif (received) {\r\nint space;\r\nunsigned char *cbuf;\r\nspace = tty_prepare_flip_string(&dport->port, &cbuf,\r\nreceived);\r\nif (space <= 0)\r\ngoto unlock;\r\nmemcpy(cbuf, dport->rx_buf, space);\r\ntty_flip_buffer_push(&dport->port);\r\n}\r\n}\r\nunlock:\r\nspin_unlock_bh(&dport->rx_lock);\r\nreturn received;\r\n}\r\nstatic int find_channel_to_poll(void)\r\n{\r\nstatic int last_polled_channel;\r\nint last = last_polled_channel;\r\nint chan;\r\nstruct dashtty_port *dport;\r\nfor (chan = last + 1; ; ++chan) {\r\nif (chan >= NUM_TTY_CHANNELS)\r\nchan = 0;\r\ndport = &dashtty_ports[chan];\r\nif (dport->rx_buf) {\r\nlast_polled_channel = chan;\r\nreturn chan;\r\n}\r\nif (chan == last)\r\nbreak;\r\n}\r\nreturn -1;\r\n}\r\nstatic int put_channel_data(unsigned int chan)\r\n{\r\nstruct dashtty_port *dport;\r\nstruct tty_struct *tty;\r\nint number_written;\r\nunsigned int count = 0;\r\ndport = &dashtty_ports[chan];\r\nmutex_lock(&dport->xmit_lock);\r\nif (dport->xmit_cnt) {\r\ncount = min((unsigned int)(SERIAL_XMIT_SIZE - dport->xmit_tail),\r\ndport->xmit_cnt);\r\nchancall(WRBUF, chan, count,\r\ndport->port.xmit_buf + dport->xmit_tail,\r\n&number_written);\r\ndport->xmit_cnt -= number_written;\r\nif (!dport->xmit_cnt) {\r\ndport->xmit_head = 0;\r\ndport->xmit_tail = 0;\r\ncomplete(&dport->xmit_empty);\r\n} else {\r\ndport->xmit_tail += number_written;\r\nif (dport->xmit_tail >= SERIAL_XMIT_SIZE)\r\ndport->xmit_tail -= SERIAL_XMIT_SIZE;\r\n}\r\natomic_sub(number_written, &dashtty_xmit_cnt);\r\n}\r\nmutex_unlock(&dport->xmit_lock);\r\nif (count && number_written) {\r\ntty = tty_port_tty_get(&dport->port);\r\nif (tty) {\r\ntty_wakeup(tty);\r\ntty_kref_put(tty);\r\n}\r\n}\r\nreturn count && !number_written;\r\n}\r\nstatic int put_data(void *arg)\r\n{\r\nunsigned int chan, stall;\r\n__set_current_state(TASK_RUNNING);\r\nwhile (!kthread_should_stop()) {\r\nstall = 0;\r\nfor (chan = 0; chan < NUM_TTY_CHANNELS; ++chan)\r\nstall += put_channel_data(chan);\r\nif (stall)\r\nmsleep(25);\r\nwait_event_interruptible(dashtty_waitqueue,\r\natomic_read(&dashtty_xmit_cnt));\r\n}\r\nreturn 0;\r\n}\r\nstatic void dashtty_timer(unsigned long ignored)\r\n{\r\nint channel;\r\nif (!atomic_read(&num_channels_need_poll))\r\nreturn;\r\nchannel = find_channel_to_poll();\r\nif (channel >= 0)\r\nfetch_data(channel);\r\nmod_timer_pinned(&poll_timer, jiffies + DA_TTY_POLL);\r\n}\r\nstatic void add_poll_timer(struct timer_list *poll_timer)\r\n{\r\nsetup_timer(poll_timer, dashtty_timer, 0);\r\npoll_timer->expires = jiffies + DA_TTY_POLL;\r\nadd_timer_on(poll_timer, 0);\r\n}\r\nstatic int dashtty_port_activate(struct tty_port *port, struct tty_struct *tty)\r\n{\r\nstruct dashtty_port *dport = container_of(port, struct dashtty_port,\r\nport);\r\nvoid *rx_buf;\r\nif (tty_port_alloc_xmit_buf(port) < 0)\r\ngoto err;\r\nrx_buf = kzalloc(RX_BUF_SIZE, GFP_KERNEL);\r\nif (!rx_buf)\r\ngoto err_free_xmit;\r\nspin_lock_bh(&dport->rx_lock);\r\ndport->rx_buf = rx_buf;\r\nspin_unlock_bh(&dport->rx_lock);\r\nif (dport != &dashtty_ports[CONSOLE_CHANNEL])\r\nif (atomic_inc_return(&num_channels_need_poll) == 1)\r\nadd_poll_timer(&poll_timer);\r\nreturn 0;\r\nerr_free_xmit:\r\ntty_port_free_xmit_buf(port);\r\nerr:\r\nreturn -ENOMEM;\r\n}\r\nstatic void dashtty_port_shutdown(struct tty_port *port)\r\n{\r\nstruct dashtty_port *dport = container_of(port, struct dashtty_port,\r\nport);\r\nvoid *rx_buf;\r\nunsigned int count;\r\nif (dport != &dashtty_ports[CONSOLE_CHANNEL])\r\nif (atomic_dec_and_test(&num_channels_need_poll))\r\ndel_timer_sync(&poll_timer);\r\nmutex_lock(&dport->xmit_lock);\r\ncount = dport->xmit_cnt;\r\nmutex_unlock(&dport->xmit_lock);\r\nif (count) {\r\ndel_timer(&put_timer);\r\nwake_up_interruptible(&dashtty_waitqueue);\r\nwait_for_completion(&dport->xmit_empty);\r\n}\r\nspin_lock_bh(&dport->rx_lock);\r\nrx_buf = dport->rx_buf;\r\ndport->rx_buf = NULL;\r\nspin_unlock_bh(&dport->rx_lock);\r\nkfree(rx_buf);\r\ntty_port_free_xmit_buf(port);\r\n}\r\nstatic int dashtty_install(struct tty_driver *driver, struct tty_struct *tty)\r\n{\r\nreturn tty_port_install(&dashtty_ports[tty->index].port, driver, tty);\r\n}\r\nstatic int dashtty_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nreturn tty_port_open(tty->port, tty, filp);\r\n}\r\nstatic void dashtty_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nreturn tty_port_close(tty->port, tty, filp);\r\n}\r\nstatic void dashtty_hangup(struct tty_struct *tty)\r\n{\r\nint channel;\r\nstruct dashtty_port *dport;\r\nchannel = tty->index;\r\ndport = &dashtty_ports[channel];\r\nmutex_lock(&dport->xmit_lock);\r\nif (dport->xmit_cnt) {\r\natomic_sub(dport->xmit_cnt, &dashtty_xmit_cnt);\r\ndport->xmit_cnt = 0;\r\ndport->xmit_head = 0;\r\ndport->xmit_tail = 0;\r\ncomplete(&dport->xmit_empty);\r\n}\r\nmutex_unlock(&dport->xmit_lock);\r\ntty_port_hangup(tty->port);\r\n}\r\nstatic void dashtty_put_timer(unsigned long ignored)\r\n{\r\nif (atomic_read(&dashtty_xmit_cnt))\r\nwake_up_interruptible(&dashtty_waitqueue);\r\n}\r\nstatic int dashtty_write(struct tty_struct *tty, const unsigned char *buf,\r\nint total)\r\n{\r\nint channel, count, block;\r\nstruct dashtty_port *dport;\r\nchannel = tty->index;\r\ndport = &dashtty_ports[channel];\r\nmutex_lock(&dport->xmit_lock);\r\ntotal = min(total, (int)(SERIAL_XMIT_SIZE - dport->xmit_cnt));\r\natomic_add(total, &dashtty_xmit_cnt);\r\ndport->xmit_cnt += total;\r\nfor (count = total; count; count -= block) {\r\nblock = min(count, (int)(SERIAL_XMIT_SIZE - dport->xmit_head));\r\nmemcpy(dport->port.xmit_buf + dport->xmit_head, buf, block);\r\ndport->xmit_head += block;\r\nif (dport->xmit_head >= SERIAL_XMIT_SIZE)\r\ndport->xmit_head -= SERIAL_XMIT_SIZE;\r\nbuf += block;\r\n}\r\ncount = dport->xmit_cnt;\r\nif (count)\r\nreinit_completion(&dport->xmit_empty);\r\nmutex_unlock(&dport->xmit_lock);\r\nif (total) {\r\nif (count == SERIAL_XMIT_SIZE) {\r\ndel_timer(&put_timer);\r\nwake_up_interruptible(&dashtty_waitqueue);\r\n} else {\r\nmod_timer(&put_timer, jiffies + DA_TTY_PUT_DELAY);\r\n}\r\n}\r\nreturn total;\r\n}\r\nstatic int dashtty_write_room(struct tty_struct *tty)\r\n{\r\nstruct dashtty_port *dport;\r\nint channel;\r\nint room;\r\nchannel = tty->index;\r\ndport = &dashtty_ports[channel];\r\nmutex_lock(&dport->xmit_lock);\r\nroom = SERIAL_XMIT_SIZE - dport->xmit_cnt;\r\nmutex_unlock(&dport->xmit_lock);\r\nreturn room;\r\n}\r\nstatic int dashtty_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct dashtty_port *dport;\r\nint channel;\r\nint chars;\r\nchannel = tty->index;\r\ndport = &dashtty_ports[channel];\r\nmutex_lock(&dport->xmit_lock);\r\nchars = dport->xmit_cnt;\r\nmutex_unlock(&dport->xmit_lock);\r\nreturn chars;\r\n}\r\nstatic int __init dashtty_init(void)\r\n{\r\nint ret;\r\nint nport;\r\nstruct dashtty_port *dport;\r\nif (!metag_da_enabled())\r\nreturn -ENODEV;\r\nchannel_driver = tty_alloc_driver(NUM_TTY_CHANNELS,\r\nTTY_DRIVER_REAL_RAW);\r\nif (IS_ERR(channel_driver))\r\nreturn PTR_ERR(channel_driver);\r\nchannel_driver->driver_name = "metag_da";\r\nchannel_driver->name = "ttyDA";\r\nchannel_driver->major = DA_TTY_MAJOR;\r\nchannel_driver->minor_start = 0;\r\nchannel_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\nchannel_driver->subtype = SERIAL_TYPE_NORMAL;\r\nchannel_driver->init_termios = tty_std_termios;\r\nchannel_driver->init_termios.c_cflag |= CLOCAL;\r\ntty_set_operations(channel_driver, &dashtty_ops);\r\nfor (nport = 0; nport < NUM_TTY_CHANNELS; nport++) {\r\ndport = &dashtty_ports[nport];\r\ntty_port_init(&dport->port);\r\ndport->port.ops = &dashtty_port_ops;\r\nspin_lock_init(&dport->rx_lock);\r\nmutex_init(&dport->xmit_lock);\r\ninit_completion(&dport->xmit_empty);\r\ncomplete(&dport->xmit_empty);\r\n}\r\nsetup_timer(&put_timer, dashtty_put_timer, 0);\r\ninit_waitqueue_head(&dashtty_waitqueue);\r\ndashtty_thread = kthread_create(put_data, NULL, "ttyDA");\r\nif (IS_ERR(dashtty_thread)) {\r\npr_err("Couldn't create dashtty thread\n");\r\nret = PTR_ERR(dashtty_thread);\r\ngoto err_destroy_ports;\r\n}\r\nkthread_bind(dashtty_thread, 0);\r\nwake_up_process(dashtty_thread);\r\nret = tty_register_driver(channel_driver);\r\nif (ret < 0) {\r\npr_err("Couldn't install dashtty driver: err %d\n",\r\nret);\r\ngoto err_stop_kthread;\r\n}\r\nreturn 0;\r\nerr_stop_kthread:\r\nkthread_stop(dashtty_thread);\r\nerr_destroy_ports:\r\nfor (nport = 0; nport < NUM_TTY_CHANNELS; nport++) {\r\ndport = &dashtty_ports[nport];\r\ntty_port_destroy(&dport->port);\r\n}\r\nput_tty_driver(channel_driver);\r\nreturn ret;\r\n}\r\nstatic void dashtty_exit(void)\r\n{\r\nint nport;\r\nstruct dashtty_port *dport;\r\ndel_timer_sync(&put_timer);\r\nkthread_stop(dashtty_thread);\r\ndel_timer_sync(&poll_timer);\r\ntty_unregister_driver(channel_driver);\r\nfor (nport = 0; nport < NUM_TTY_CHANNELS; nport++) {\r\ndport = &dashtty_ports[nport];\r\ntty_port_destroy(&dport->port);\r\n}\r\nput_tty_driver(channel_driver);\r\n}\r\nstatic void dash_console_write(struct console *co, const char *s,\r\nunsigned int count)\r\n{\r\nint actually_written;\r\nchancall(WRBUF, CONSOLE_CHANNEL, count, (void *)s, &actually_written);\r\n}\r\nstatic struct tty_driver *dash_console_device(struct console *c, int *index)\r\n{\r\n*index = c->index;\r\nreturn channel_driver;\r\n}
