uint32_t\r\nqla8044_rd_reg(struct qla_hw_data *ha, ulong addr)\r\n{\r\nreturn readl((void __iomem *) (ha->nx_pcibase + addr));\r\n}\r\nvoid\r\nqla8044_wr_reg(struct qla_hw_data *ha, ulong addr, uint32_t val)\r\n{\r\nwritel(val, (void __iomem *)((ha)->nx_pcibase + addr));\r\n}\r\nint\r\nqla8044_rd_direct(struct scsi_qla_host *vha,\r\nconst uint32_t crb_reg)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (crb_reg < CRB_REG_INDEX_MAX)\r\nreturn qla8044_rd_reg(ha, qla8044_reg_tbl[crb_reg]);\r\nelse\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nvoid\r\nqla8044_wr_direct(struct scsi_qla_host *vha,\r\nconst uint32_t crb_reg,\r\nconst uint32_t value)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (crb_reg < CRB_REG_INDEX_MAX)\r\nqla8044_wr_reg(ha, qla8044_reg_tbl[crb_reg], value);\r\n}\r\nstatic int\r\nqla8044_set_win_base(scsi_qla_host_t *vha, uint32_t addr)\r\n{\r\nuint32_t val;\r\nint ret_val = QLA_SUCCESS;\r\nstruct qla_hw_data *ha = vha->hw;\r\nqla8044_wr_reg(ha, QLA8044_CRB_WIN_FUNC(ha->portnum), addr);\r\nval = qla8044_rd_reg(ha, QLA8044_CRB_WIN_FUNC(ha->portnum));\r\nif (val != addr) {\r\nql_log(ql_log_warn, vha, 0xb087,\r\n"%s: Failed to set register window : "\r\n"addr written 0x%x, read 0x%x!\n",\r\n__func__, addr, val);\r\nret_val = QLA_FUNCTION_FAILED;\r\n}\r\nreturn ret_val;\r\n}\r\nstatic int\r\nqla8044_rd_reg_indirect(scsi_qla_host_t *vha, uint32_t addr, uint32_t *data)\r\n{\r\nint ret_val = QLA_SUCCESS;\r\nstruct qla_hw_data *ha = vha->hw;\r\nret_val = qla8044_set_win_base(vha, addr);\r\nif (!ret_val)\r\n*data = qla8044_rd_reg(ha, QLA8044_WILDCARD);\r\nelse\r\nql_log(ql_log_warn, vha, 0xb088,\r\n"%s: failed read of addr 0x%x!\n", __func__, addr);\r\nreturn ret_val;\r\n}\r\nstatic int\r\nqla8044_wr_reg_indirect(scsi_qla_host_t *vha, uint32_t addr, uint32_t data)\r\n{\r\nint ret_val = QLA_SUCCESS;\r\nstruct qla_hw_data *ha = vha->hw;\r\nret_val = qla8044_set_win_base(vha, addr);\r\nif (!ret_val)\r\nqla8044_wr_reg(ha, QLA8044_WILDCARD, data);\r\nelse\r\nql_log(ql_log_warn, vha, 0xb089,\r\n"%s: failed wrt to addr 0x%x, data 0x%x\n",\r\n__func__, addr, data);\r\nreturn ret_val;\r\n}\r\nstatic void\r\nqla8044_read_write_crb_reg(struct scsi_qla_host *vha,\r\nuint32_t raddr, uint32_t waddr)\r\n{\r\nuint32_t value;\r\nqla8044_rd_reg_indirect(vha, raddr, &value);\r\nqla8044_wr_reg_indirect(vha, waddr, value);\r\n}\r\nstatic int\r\nqla8044_poll_wait_for_ready(struct scsi_qla_host *vha, uint32_t addr1,\r\nuint32_t mask)\r\n{\r\nunsigned long timeout;\r\nuint32_t temp;\r\ntimeout = jiffies + msecs_to_jiffies(TIMEOUT_100_MS);\r\ndo {\r\nqla8044_rd_reg_indirect(vha, addr1, &temp);\r\nif ((temp & mask) != 0)\r\nbreak;\r\nif (time_after_eq(jiffies, timeout)) {\r\nql_log(ql_log_warn, vha, 0xb151,\r\n"Error in processing rdmdio entry\n");\r\nreturn -1;\r\n}\r\n} while (1);\r\nreturn 0;\r\n}\r\nstatic uint32_t\r\nqla8044_ipmdio_rd_reg(struct scsi_qla_host *vha,\r\nuint32_t addr1, uint32_t addr3, uint32_t mask, uint32_t addr)\r\n{\r\nuint32_t temp;\r\nint ret = 0;\r\nret = qla8044_poll_wait_for_ready(vha, addr1, mask);\r\nif (ret == -1)\r\nreturn -1;\r\ntemp = (0x40000000 | addr);\r\nqla8044_wr_reg_indirect(vha, addr1, temp);\r\nret = qla8044_poll_wait_for_ready(vha, addr1, mask);\r\nif (ret == -1)\r\nreturn 0;\r\nqla8044_rd_reg_indirect(vha, addr3, &ret);\r\nreturn ret;\r\n}\r\nstatic int\r\nqla8044_poll_wait_ipmdio_bus_idle(struct scsi_qla_host *vha,\r\nuint32_t addr1, uint32_t addr2, uint32_t addr3, uint32_t mask)\r\n{\r\nunsigned long timeout;\r\nuint32_t temp;\r\ntimeout = jiffies + msecs_to_jiffies(TIMEOUT_100_MS);\r\ndo {\r\ntemp = qla8044_ipmdio_rd_reg(vha, addr1, addr3, mask, addr2);\r\nif ((temp & 0x1) != 1)\r\nbreak;\r\nif (time_after_eq(jiffies, timeout)) {\r\nql_log(ql_log_warn, vha, 0xb152,\r\n"Error in processing mdiobus idle\n");\r\nreturn -1;\r\n}\r\n} while (1);\r\nreturn 0;\r\n}\r\nstatic int\r\nqla8044_ipmdio_wr_reg(struct scsi_qla_host *vha, uint32_t addr1,\r\nuint32_t addr3, uint32_t mask, uint32_t addr, uint32_t value)\r\n{\r\nint ret = 0;\r\nret = qla8044_poll_wait_for_ready(vha, addr1, mask);\r\nif (ret == -1)\r\nreturn -1;\r\nqla8044_wr_reg_indirect(vha, addr3, value);\r\nqla8044_wr_reg_indirect(vha, addr1, addr);\r\nret = qla8044_poll_wait_for_ready(vha, addr1, mask);\r\nif (ret == -1)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void\r\nqla8044_rmw_crb_reg(struct scsi_qla_host *vha,\r\nuint32_t raddr, uint32_t waddr, struct qla8044_rmw *p_rmw_hdr)\r\n{\r\nuint32_t value;\r\nif (p_rmw_hdr->index_a)\r\nvalue = vha->reset_tmplt.array[p_rmw_hdr->index_a];\r\nelse\r\nqla8044_rd_reg_indirect(vha, raddr, &value);\r\nvalue &= p_rmw_hdr->test_mask;\r\nvalue <<= p_rmw_hdr->shl;\r\nvalue >>= p_rmw_hdr->shr;\r\nvalue |= p_rmw_hdr->or_value;\r\nvalue ^= p_rmw_hdr->xor_value;\r\nqla8044_wr_reg_indirect(vha, waddr, value);\r\nreturn;\r\n}\r\ninline void\r\nqla8044_set_qsnt_ready(struct scsi_qla_host *vha)\r\n{\r\nuint32_t qsnt_state;\r\nstruct qla_hw_data *ha = vha->hw;\r\nqsnt_state = qla8044_rd_direct(vha, QLA8044_CRB_DRV_STATE_INDEX);\r\nqsnt_state |= (1 << ha->portnum);\r\nqla8044_wr_direct(vha, QLA8044_CRB_DRV_STATE_INDEX, qsnt_state);\r\nql_log(ql_log_info, vha, 0xb08e, "%s(%ld): qsnt_state: 0x%08x\n",\r\n__func__, vha->host_no, qsnt_state);\r\n}\r\nvoid\r\nqla8044_clear_qsnt_ready(struct scsi_qla_host *vha)\r\n{\r\nuint32_t qsnt_state;\r\nstruct qla_hw_data *ha = vha->hw;\r\nqsnt_state = qla8044_rd_direct(vha, QLA8044_CRB_DRV_STATE_INDEX);\r\nqsnt_state &= ~(1 << ha->portnum);\r\nqla8044_wr_direct(vha, QLA8044_CRB_DRV_STATE_INDEX, qsnt_state);\r\nql_log(ql_log_info, vha, 0xb08f, "%s(%ld): qsnt_state: 0x%08x\n",\r\n__func__, vha->host_no, qsnt_state);\r\n}\r\nstatic int\r\nqla8044_lock_recovery(struct scsi_qla_host *vha)\r\n{\r\nuint32_t lock = 0, lockid;\r\nstruct qla_hw_data *ha = vha->hw;\r\nlockid = qla8044_rd_reg(ha, QLA8044_DRV_LOCKRECOVERY);\r\nif ((lockid & IDC_LOCK_RECOVERY_STATE_MASK) != 0)\r\nreturn QLA_FUNCTION_FAILED;\r\nqla8044_wr_reg(ha, QLA8044_DRV_LOCKRECOVERY,\r\n(ha->portnum <<\r\nIDC_LOCK_RECOVERY_STATE_SHIFT_BITS) | INTENT_TO_RECOVER);\r\nmsleep(200);\r\nlockid = qla8044_rd_reg(ha, QLA8044_DRV_LOCKRECOVERY);\r\nif ((lockid & IDC_LOCK_RECOVERY_OWNER_MASK) != (ha->portnum <<\r\nIDC_LOCK_RECOVERY_STATE_SHIFT_BITS))\r\nreturn QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_p3p, vha, 0xb08B, "%s:%d: IDC Lock recovery initiated\n"\r\n, __func__, ha->portnum);\r\nqla8044_wr_reg(ha, QLA8044_DRV_LOCKRECOVERY,\r\n(ha->portnum << IDC_LOCK_RECOVERY_STATE_SHIFT_BITS) |\r\nPROCEED_TO_RECOVER);\r\nqla8044_wr_reg(ha, QLA8044_DRV_LOCK_ID, 0xFF);\r\nqla8044_rd_reg(ha, QLA8044_DRV_UNLOCK);\r\nqla8044_wr_reg(ha, QLA8044_DRV_LOCKRECOVERY, 0);\r\nlock = qla8044_rd_reg(ha, QLA8044_DRV_LOCK);\r\nif (lock) {\r\nlockid = qla8044_rd_reg(ha, QLA8044_DRV_LOCK_ID);\r\nlockid = ((lockid + (1 << 8)) & ~0xFF) | ha->portnum;\r\nqla8044_wr_reg(ha, QLA8044_DRV_LOCK_ID, lockid);\r\nreturn QLA_SUCCESS;\r\n} else\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nint\r\nqla8044_idc_lock(struct qla_hw_data *ha)\r\n{\r\nuint32_t ret_val = QLA_SUCCESS, timeout = 0, status = 0;\r\nuint32_t lock_id, lock_cnt, func_num, tmo_owner = 0, first_owner = 0;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nwhile (status == 0) {\r\nstatus = qla8044_rd_reg(ha, QLA8044_DRV_LOCK);\r\nif (status) {\r\nlock_id = qla8044_rd_reg(ha, QLA8044_DRV_LOCK_ID);\r\nlock_id = ((lock_id + (1 << 8)) & ~0xFF) | ha->portnum;\r\nqla8044_wr_reg(ha, QLA8044_DRV_LOCK_ID, lock_id);\r\nbreak;\r\n}\r\nif (timeout == 0)\r\nfirst_owner = qla8044_rd_reg(ha, QLA8044_DRV_LOCK_ID);\r\nif (++timeout >=\r\n(QLA8044_DRV_LOCK_TIMEOUT / QLA8044_DRV_LOCK_MSLEEP)) {\r\ntmo_owner = qla8044_rd_reg(ha, QLA8044_DRV_LOCK_ID);\r\nfunc_num = tmo_owner & 0xFF;\r\nlock_cnt = tmo_owner >> 8;\r\nql_log(ql_log_warn, vha, 0xb114,\r\n"%s: Lock by func %d failed after 2s, lock held "\r\n"by func %d, lock count %d, first_owner %d\n",\r\n__func__, ha->portnum, func_num, lock_cnt,\r\n(first_owner & 0xFF));\r\nif (first_owner != tmo_owner) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb115,\r\n"%s: %d: IDC lock failed\n",\r\n__func__, ha->portnum);\r\ntimeout = 0;\r\n} else {\r\nif (qla8044_lock_recovery(vha) == QLA_SUCCESS) {\r\nret_val = QLA_SUCCESS;\r\nql_dbg(ql_dbg_p3p, vha, 0xb116,\r\n"%s:IDC lock Recovery by %d"\r\n"successful...\n", __func__,\r\nha->portnum);\r\n}\r\nql_dbg(ql_dbg_p3p, vha, 0xb08a,\r\n"%s: IDC lock Recovery by %d "\r\n"failed, Retrying timout\n", __func__,\r\nha->portnum);\r\ntimeout = 0;\r\n}\r\n}\r\nmsleep(QLA8044_DRV_LOCK_MSLEEP);\r\n}\r\nreturn ret_val;\r\n}\r\nvoid\r\nqla8044_idc_unlock(struct qla_hw_data *ha)\r\n{\r\nint id;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nid = qla8044_rd_reg(ha, QLA8044_DRV_LOCK_ID);\r\nif ((id & 0xFF) != ha->portnum) {\r\nql_log(ql_log_warn, vha, 0xb118,\r\n"%s: IDC Unlock by %d failed, lock owner is %d!\n",\r\n__func__, ha->portnum, (id & 0xFF));\r\nreturn;\r\n}\r\nqla8044_wr_reg(ha, QLA8044_DRV_LOCK_ID, (id | 0xFF));\r\nqla8044_rd_reg(ha, QLA8044_DRV_UNLOCK);\r\n}\r\nstatic int\r\nqla8044_flash_lock(scsi_qla_host_t *vha)\r\n{\r\nint lock_owner;\r\nint timeout = 0;\r\nuint32_t lock_status = 0;\r\nint ret_val = QLA_SUCCESS;\r\nstruct qla_hw_data *ha = vha->hw;\r\nwhile (lock_status == 0) {\r\nlock_status = qla8044_rd_reg(ha, QLA8044_FLASH_LOCK);\r\nif (lock_status)\r\nbreak;\r\nif (++timeout >= QLA8044_FLASH_LOCK_TIMEOUT / 20) {\r\nlock_owner = qla8044_rd_reg(ha,\r\nQLA8044_FLASH_LOCK_ID);\r\nql_log(ql_log_warn, vha, 0xb113,\r\n"%s: Simultaneous flash access by following ports, active port = %d: accessing port = %d",\r\n__func__, ha->portnum, lock_owner);\r\nret_val = QLA_FUNCTION_FAILED;\r\nbreak;\r\n}\r\nmsleep(20);\r\n}\r\nqla8044_wr_reg(ha, QLA8044_FLASH_LOCK_ID, ha->portnum);\r\nreturn ret_val;\r\n}\r\nstatic void\r\nqla8044_flash_unlock(scsi_qla_host_t *vha)\r\n{\r\nint ret_val;\r\nstruct qla_hw_data *ha = vha->hw;\r\nqla8044_wr_reg(ha, QLA8044_FLASH_LOCK_ID, 0xFF);\r\nret_val = qla8044_rd_reg(ha, QLA8044_FLASH_UNLOCK);\r\n}\r\nstatic\r\nvoid qla8044_flash_lock_recovery(struct scsi_qla_host *vha)\r\n{\r\nif (qla8044_flash_lock(vha)) {\r\nql_log(ql_log_warn, vha, 0xb120, "Resetting flash_lock\n");\r\n}\r\nqla8044_flash_unlock(vha);\r\n}\r\nstatic int\r\nqla8044_read_flash_data(scsi_qla_host_t *vha, uint8_t *p_data,\r\nuint32_t flash_addr, int u32_word_count)\r\n{\r\nint i, ret_val = QLA_SUCCESS;\r\nuint32_t u32_word;\r\nif (qla8044_flash_lock(vha) != QLA_SUCCESS) {\r\nret_val = QLA_FUNCTION_FAILED;\r\ngoto exit_lock_error;\r\n}\r\nif (flash_addr & 0x03) {\r\nql_log(ql_log_warn, vha, 0xb117,\r\n"%s: Illegal addr = 0x%x\n", __func__, flash_addr);\r\nret_val = QLA_FUNCTION_FAILED;\r\ngoto exit_flash_read;\r\n}\r\nfor (i = 0; i < u32_word_count; i++) {\r\nif (qla8044_wr_reg_indirect(vha, QLA8044_FLASH_DIRECT_WINDOW,\r\n(flash_addr & 0xFFFF0000))) {\r\nql_log(ql_log_warn, vha, 0xb119,\r\n"%s: failed to write addr 0x%x to "\r\n"FLASH_DIRECT_WINDOW\n! ",\r\n__func__, flash_addr);\r\nret_val = QLA_FUNCTION_FAILED;\r\ngoto exit_flash_read;\r\n}\r\nret_val = qla8044_rd_reg_indirect(vha,\r\nQLA8044_FLASH_DIRECT_DATA(flash_addr),\r\n&u32_word);\r\nif (ret_val != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0xb08c,\r\n"%s: failed to read addr 0x%x!\n",\r\n__func__, flash_addr);\r\ngoto exit_flash_read;\r\n}\r\n*(uint32_t *)p_data = u32_word;\r\np_data = p_data + 4;\r\nflash_addr = flash_addr + 4;\r\n}\r\nexit_flash_read:\r\nqla8044_flash_unlock(vha);\r\nexit_lock_error:\r\nreturn ret_val;\r\n}\r\nuint8_t *\r\nqla8044_read_optrom_data(struct scsi_qla_host *vha, uint8_t *buf,\r\nuint32_t offset, uint32_t length)\r\n{\r\nscsi_block_requests(vha->host);\r\nif (qla8044_read_flash_data(vha, (uint8_t *)buf, offset, length / 4)\r\n!= QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0xb08d,\r\n"%s: Failed to read from flash\n",\r\n__func__);\r\n}\r\nscsi_unblock_requests(vha->host);\r\nreturn buf;\r\n}\r\ninline int\r\nqla8044_need_reset(struct scsi_qla_host *vha)\r\n{\r\nuint32_t drv_state, drv_active;\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\ndrv_active = qla8044_rd_direct(vha, QLA8044_CRB_DRV_ACTIVE_INDEX);\r\ndrv_state = qla8044_rd_direct(vha, QLA8044_CRB_DRV_STATE_INDEX);\r\nrval = drv_state & (1 << ha->portnum);\r\nif (ha->flags.eeh_busy && drv_active)\r\nrval = 1;\r\nreturn rval;\r\n}\r\nstatic void\r\nqla8044_write_list(struct scsi_qla_host *vha,\r\nstruct qla8044_reset_entry_hdr *p_hdr)\r\n{\r\nstruct qla8044_entry *p_entry;\r\nuint32_t i;\r\np_entry = (struct qla8044_entry *)((char *)p_hdr +\r\nsizeof(struct qla8044_reset_entry_hdr));\r\nfor (i = 0; i < p_hdr->count; i++, p_entry++) {\r\nqla8044_wr_reg_indirect(vha, p_entry->arg1, p_entry->arg2);\r\nif (p_hdr->delay)\r\nudelay((uint32_t)(p_hdr->delay));\r\n}\r\n}\r\nstatic void\r\nqla8044_read_write_list(struct scsi_qla_host *vha,\r\nstruct qla8044_reset_entry_hdr *p_hdr)\r\n{\r\nstruct qla8044_entry *p_entry;\r\nuint32_t i;\r\np_entry = (struct qla8044_entry *)((char *)p_hdr +\r\nsizeof(struct qla8044_reset_entry_hdr));\r\nfor (i = 0; i < p_hdr->count; i++, p_entry++) {\r\nqla8044_read_write_crb_reg(vha, p_entry->arg1,\r\np_entry->arg2);\r\nif (p_hdr->delay)\r\nudelay((uint32_t)(p_hdr->delay));\r\n}\r\n}\r\nstatic int\r\nqla8044_poll_reg(struct scsi_qla_host *vha, uint32_t addr,\r\nint duration, uint32_t test_mask, uint32_t test_result)\r\n{\r\nuint32_t value;\r\nint timeout_error;\r\nuint8_t retries;\r\nint ret_val = QLA_SUCCESS;\r\nret_val = qla8044_rd_reg_indirect(vha, addr, &value);\r\nif (ret_val == QLA_FUNCTION_FAILED) {\r\ntimeout_error = 1;\r\ngoto exit_poll_reg;\r\n}\r\nretries = duration/10;\r\ndo {\r\nif ((value & test_mask) != test_result) {\r\ntimeout_error = 1;\r\nmsleep(duration/10);\r\nret_val = qla8044_rd_reg_indirect(vha, addr, &value);\r\nif (ret_val == QLA_FUNCTION_FAILED) {\r\ntimeout_error = 1;\r\ngoto exit_poll_reg;\r\n}\r\n} else {\r\ntimeout_error = 0;\r\nbreak;\r\n}\r\n} while (retries--);\r\nexit_poll_reg:\r\nif (timeout_error) {\r\nvha->reset_tmplt.seq_error++;\r\nql_log(ql_log_fatal, vha, 0xb090,\r\n"%s: Poll Failed: 0x%08x 0x%08x 0x%08x\n",\r\n__func__, value, test_mask, test_result);\r\n}\r\nreturn timeout_error;\r\n}\r\nstatic void\r\nqla8044_poll_list(struct scsi_qla_host *vha,\r\nstruct qla8044_reset_entry_hdr *p_hdr)\r\n{\r\nlong delay;\r\nstruct qla8044_entry *p_entry;\r\nstruct qla8044_poll *p_poll;\r\nuint32_t i;\r\nuint32_t value;\r\np_poll = (struct qla8044_poll *)\r\n((char *)p_hdr + sizeof(struct qla8044_reset_entry_hdr));\r\np_entry = (struct qla8044_entry *)((char *)p_poll +\r\nsizeof(struct qla8044_poll));\r\ndelay = (long)p_hdr->delay;\r\nif (!delay) {\r\nfor (i = 0; i < p_hdr->count; i++, p_entry++)\r\nqla8044_poll_reg(vha, p_entry->arg1,\r\ndelay, p_poll->test_mask, p_poll->test_value);\r\n} else {\r\nfor (i = 0; i < p_hdr->count; i++, p_entry++) {\r\nif (delay) {\r\nif (qla8044_poll_reg(vha,\r\np_entry->arg1, delay,\r\np_poll->test_mask,\r\np_poll->test_value)) {\r\nqla8044_rd_reg_indirect(vha,\r\np_entry->arg1, &value);\r\nqla8044_rd_reg_indirect(vha,\r\np_entry->arg2, &value);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\nqla8044_poll_write_list(struct scsi_qla_host *vha,\r\nstruct qla8044_reset_entry_hdr *p_hdr)\r\n{\r\nlong delay;\r\nstruct qla8044_quad_entry *p_entry;\r\nstruct qla8044_poll *p_poll;\r\nuint32_t i;\r\np_poll = (struct qla8044_poll *)((char *)p_hdr +\r\nsizeof(struct qla8044_reset_entry_hdr));\r\np_entry = (struct qla8044_quad_entry *)((char *)p_poll +\r\nsizeof(struct qla8044_poll));\r\ndelay = (long)p_hdr->delay;\r\nfor (i = 0; i < p_hdr->count; i++, p_entry++) {\r\nqla8044_wr_reg_indirect(vha,\r\np_entry->dr_addr, p_entry->dr_value);\r\nqla8044_wr_reg_indirect(vha,\r\np_entry->ar_addr, p_entry->ar_value);\r\nif (delay) {\r\nif (qla8044_poll_reg(vha,\r\np_entry->ar_addr, delay,\r\np_poll->test_mask,\r\np_poll->test_value)) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb091,\r\n"%s: Timeout Error: poll list, ",\r\n__func__);\r\nql_dbg(ql_dbg_p3p, vha, 0xb092,\r\n"item_num %d, entry_num %d\n", i,\r\nvha->reset_tmplt.seq_index);\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\nqla8044_read_modify_write(struct scsi_qla_host *vha,\r\nstruct qla8044_reset_entry_hdr *p_hdr)\r\n{\r\nstruct qla8044_entry *p_entry;\r\nstruct qla8044_rmw *p_rmw_hdr;\r\nuint32_t i;\r\np_rmw_hdr = (struct qla8044_rmw *)((char *)p_hdr +\r\nsizeof(struct qla8044_reset_entry_hdr));\r\np_entry = (struct qla8044_entry *)((char *)p_rmw_hdr +\r\nsizeof(struct qla8044_rmw));\r\nfor (i = 0; i < p_hdr->count; i++, p_entry++) {\r\nqla8044_rmw_crb_reg(vha, p_entry->arg1,\r\np_entry->arg2, p_rmw_hdr);\r\nif (p_hdr->delay)\r\nudelay((uint32_t)(p_hdr->delay));\r\n}\r\n}\r\nstatic\r\nvoid qla8044_pause(struct scsi_qla_host *vha,\r\nstruct qla8044_reset_entry_hdr *p_hdr)\r\n{\r\nif (p_hdr->delay)\r\nmdelay((uint32_t)((long)p_hdr->delay));\r\n}\r\nstatic void\r\nqla8044_template_end(struct scsi_qla_host *vha,\r\nstruct qla8044_reset_entry_hdr *p_hdr)\r\n{\r\nvha->reset_tmplt.template_end = 1;\r\nif (vha->reset_tmplt.seq_error == 0) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb093,\r\n"%s: Reset sequence completed SUCCESSFULLY.\n", __func__);\r\n} else {\r\nql_log(ql_log_fatal, vha, 0xb094,\r\n"%s: Reset sequence completed with some timeout "\r\n"errors.\n", __func__);\r\n}\r\n}\r\nstatic void\r\nqla8044_poll_read_list(struct scsi_qla_host *vha,\r\nstruct qla8044_reset_entry_hdr *p_hdr)\r\n{\r\nlong delay;\r\nint index;\r\nstruct qla8044_quad_entry *p_entry;\r\nstruct qla8044_poll *p_poll;\r\nuint32_t i;\r\nuint32_t value;\r\np_poll = (struct qla8044_poll *)\r\n((char *)p_hdr + sizeof(struct qla8044_reset_entry_hdr));\r\np_entry = (struct qla8044_quad_entry *)\r\n((char *)p_poll + sizeof(struct qla8044_poll));\r\ndelay = (long)p_hdr->delay;\r\nfor (i = 0; i < p_hdr->count; i++, p_entry++) {\r\nqla8044_wr_reg_indirect(vha, p_entry->ar_addr,\r\np_entry->ar_value);\r\nif (delay) {\r\nif (qla8044_poll_reg(vha, p_entry->ar_addr, delay,\r\np_poll->test_mask, p_poll->test_value)) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb095,\r\n"%s: Timeout Error: poll "\r\n"list, ", __func__);\r\nql_dbg(ql_dbg_p3p, vha, 0xb096,\r\n"Item_num %d, "\r\n"entry_num %d\n", i,\r\nvha->reset_tmplt.seq_index);\r\n} else {\r\nindex = vha->reset_tmplt.array_index;\r\nqla8044_rd_reg_indirect(vha,\r\np_entry->dr_addr, &value);\r\nvha->reset_tmplt.array[index++] = value;\r\nif (index == QLA8044_MAX_RESET_SEQ_ENTRIES)\r\nvha->reset_tmplt.array_index = 1;\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\nqla8044_process_reset_template(struct scsi_qla_host *vha,\r\nchar *p_buff)\r\n{\r\nint index, entries;\r\nstruct qla8044_reset_entry_hdr *p_hdr;\r\nchar *p_entry = p_buff;\r\nvha->reset_tmplt.seq_end = 0;\r\nvha->reset_tmplt.template_end = 0;\r\nentries = vha->reset_tmplt.hdr->entries;\r\nindex = vha->reset_tmplt.seq_index;\r\nfor (; (!vha->reset_tmplt.seq_end) && (index < entries); index++) {\r\np_hdr = (struct qla8044_reset_entry_hdr *)p_entry;\r\nswitch (p_hdr->cmd) {\r\ncase OPCODE_NOP:\r\nbreak;\r\ncase OPCODE_WRITE_LIST:\r\nqla8044_write_list(vha, p_hdr);\r\nbreak;\r\ncase OPCODE_READ_WRITE_LIST:\r\nqla8044_read_write_list(vha, p_hdr);\r\nbreak;\r\ncase OPCODE_POLL_LIST:\r\nqla8044_poll_list(vha, p_hdr);\r\nbreak;\r\ncase OPCODE_POLL_WRITE_LIST:\r\nqla8044_poll_write_list(vha, p_hdr);\r\nbreak;\r\ncase OPCODE_READ_MODIFY_WRITE:\r\nqla8044_read_modify_write(vha, p_hdr);\r\nbreak;\r\ncase OPCODE_SEQ_PAUSE:\r\nqla8044_pause(vha, p_hdr);\r\nbreak;\r\ncase OPCODE_SEQ_END:\r\nvha->reset_tmplt.seq_end = 1;\r\nbreak;\r\ncase OPCODE_TMPL_END:\r\nqla8044_template_end(vha, p_hdr);\r\nbreak;\r\ncase OPCODE_POLL_READ_LIST:\r\nqla8044_poll_read_list(vha, p_hdr);\r\nbreak;\r\ndefault:\r\nql_log(ql_log_fatal, vha, 0xb097,\r\n"%s: Unknown command ==> 0x%04x on "\r\n"entry = %d\n", __func__, p_hdr->cmd, index);\r\nbreak;\r\n}\r\np_entry += p_hdr->size;\r\n}\r\nvha->reset_tmplt.seq_index = index;\r\n}\r\nstatic void\r\nqla8044_process_init_seq(struct scsi_qla_host *vha)\r\n{\r\nqla8044_process_reset_template(vha,\r\nvha->reset_tmplt.init_offset);\r\nif (vha->reset_tmplt.seq_end != 1)\r\nql_log(ql_log_fatal, vha, 0xb098,\r\n"%s: Abrupt INIT Sub-Sequence end.\n",\r\n__func__);\r\n}\r\nstatic void\r\nqla8044_process_stop_seq(struct scsi_qla_host *vha)\r\n{\r\nvha->reset_tmplt.seq_index = 0;\r\nqla8044_process_reset_template(vha, vha->reset_tmplt.stop_offset);\r\nif (vha->reset_tmplt.seq_end != 1)\r\nql_log(ql_log_fatal, vha, 0xb099,\r\n"%s: Abrupt STOP Sub-Sequence end.\n", __func__);\r\n}\r\nstatic void\r\nqla8044_process_start_seq(struct scsi_qla_host *vha)\r\n{\r\nqla8044_process_reset_template(vha, vha->reset_tmplt.start_offset);\r\nif (vha->reset_tmplt.template_end != 1)\r\nql_log(ql_log_fatal, vha, 0xb09a,\r\n"%s: Abrupt START Sub-Sequence end.\n",\r\n__func__);\r\n}\r\nstatic int\r\nqla8044_lockless_flash_read_u32(struct scsi_qla_host *vha,\r\nuint32_t flash_addr, uint8_t *p_data, int u32_word_count)\r\n{\r\nuint32_t i;\r\nuint32_t u32_word;\r\nuint32_t flash_offset;\r\nuint32_t addr = flash_addr;\r\nint ret_val = QLA_SUCCESS;\r\nflash_offset = addr & (QLA8044_FLASH_SECTOR_SIZE - 1);\r\nif (addr & 0x3) {\r\nql_log(ql_log_fatal, vha, 0xb09b, "%s: Illegal addr = 0x%x\n",\r\n__func__, addr);\r\nret_val = QLA_FUNCTION_FAILED;\r\ngoto exit_lockless_read;\r\n}\r\nret_val = qla8044_wr_reg_indirect(vha,\r\nQLA8044_FLASH_DIRECT_WINDOW, (addr));\r\nif (ret_val != QLA_SUCCESS) {\r\nql_log(ql_log_fatal, vha, 0xb09c,\r\n"%s: failed to write addr 0x%x to FLASH_DIRECT_WINDOW!\n",\r\n__func__, addr);\r\ngoto exit_lockless_read;\r\n}\r\nif ((flash_offset + (u32_word_count * sizeof(uint32_t))) >\r\n(QLA8044_FLASH_SECTOR_SIZE - 1)) {\r\nfor (i = 0; i < u32_word_count; i++) {\r\nret_val = qla8044_rd_reg_indirect(vha,\r\nQLA8044_FLASH_DIRECT_DATA(addr), &u32_word);\r\nif (ret_val != QLA_SUCCESS) {\r\nql_log(ql_log_fatal, vha, 0xb09d,\r\n"%s: failed to read addr 0x%x!\n",\r\n__func__, addr);\r\ngoto exit_lockless_read;\r\n}\r\n*(uint32_t *)p_data = u32_word;\r\np_data = p_data + 4;\r\naddr = addr + 4;\r\nflash_offset = flash_offset + 4;\r\nif (flash_offset > (QLA8044_FLASH_SECTOR_SIZE - 1)) {\r\nret_val = qla8044_wr_reg_indirect(vha,\r\nQLA8044_FLASH_DIRECT_WINDOW, (addr));\r\nif (ret_val != QLA_SUCCESS) {\r\nql_log(ql_log_fatal, vha, 0xb09f,\r\n"%s: failed to write addr "\r\n"0x%x to FLASH_DIRECT_WINDOW!\n",\r\n__func__, addr);\r\ngoto exit_lockless_read;\r\n}\r\nflash_offset = 0;\r\n}\r\n}\r\n} else {\r\nfor (i = 0; i < u32_word_count; i++) {\r\nret_val = qla8044_rd_reg_indirect(vha,\r\nQLA8044_FLASH_DIRECT_DATA(addr), &u32_word);\r\nif (ret_val != QLA_SUCCESS) {\r\nql_log(ql_log_fatal, vha, 0xb0a0,\r\n"%s: failed to read addr 0x%x!\n",\r\n__func__, addr);\r\ngoto exit_lockless_read;\r\n}\r\n*(uint32_t *)p_data = u32_word;\r\np_data = p_data + 4;\r\naddr = addr + 4;\r\n}\r\n}\r\nexit_lockless_read:\r\nreturn ret_val;\r\n}\r\nstatic int\r\nqla8044_ms_mem_write_128b(struct scsi_qla_host *vha,\r\nuint64_t addr, uint32_t *data, uint32_t count)\r\n{\r\nint i, j, ret_val = QLA_SUCCESS;\r\nuint32_t agt_ctrl;\r\nunsigned long flags;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (addr & 0xF) {\r\nret_val = QLA_FUNCTION_FAILED;\r\ngoto exit_ms_mem_write;\r\n}\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\nret_val = qla8044_wr_reg_indirect(vha, MD_MIU_TEST_AGT_ADDR_HI, 0);\r\nif (ret_val == QLA_FUNCTION_FAILED) {\r\nql_log(ql_log_fatal, vha, 0xb0a1,\r\n"%s: write to AGT_ADDR_HI failed!\n", __func__);\r\ngoto exit_ms_mem_write_unlock;\r\n}\r\nfor (i = 0; i < count; i++, addr += 16) {\r\nif (!((QLA8044_ADDR_IN_RANGE(addr, QLA8044_ADDR_QDR_NET,\r\nQLA8044_ADDR_QDR_NET_MAX)) ||\r\n(QLA8044_ADDR_IN_RANGE(addr, QLA8044_ADDR_DDR_NET,\r\nQLA8044_ADDR_DDR_NET_MAX)))) {\r\nret_val = QLA_FUNCTION_FAILED;\r\ngoto exit_ms_mem_write_unlock;\r\n}\r\nret_val = qla8044_wr_reg_indirect(vha,\r\nMD_MIU_TEST_AGT_ADDR_LO, addr);\r\nret_val += qla8044_wr_reg_indirect(vha,\r\nMD_MIU_TEST_AGT_WRDATA_LO, *data++);\r\nret_val += qla8044_wr_reg_indirect(vha,\r\nMD_MIU_TEST_AGT_WRDATA_HI, *data++);\r\nret_val += qla8044_wr_reg_indirect(vha,\r\nMD_MIU_TEST_AGT_WRDATA_ULO, *data++);\r\nret_val += qla8044_wr_reg_indirect(vha,\r\nMD_MIU_TEST_AGT_WRDATA_UHI, *data++);\r\nif (ret_val == QLA_FUNCTION_FAILED) {\r\nql_log(ql_log_fatal, vha, 0xb0a2,\r\n"%s: write to AGT_WRDATA failed!\n",\r\n__func__);\r\ngoto exit_ms_mem_write_unlock;\r\n}\r\nret_val = qla8044_wr_reg_indirect(vha, MD_MIU_TEST_AGT_CTRL,\r\nMIU_TA_CTL_WRITE_ENABLE);\r\nret_val += qla8044_wr_reg_indirect(vha, MD_MIU_TEST_AGT_CTRL,\r\nMIU_TA_CTL_WRITE_START);\r\nif (ret_val == QLA_FUNCTION_FAILED) {\r\nql_log(ql_log_fatal, vha, 0xb0a3,\r\n"%s: write to AGT_CTRL failed!\n", __func__);\r\ngoto exit_ms_mem_write_unlock;\r\n}\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\nret_val = qla8044_rd_reg_indirect(vha,\r\nMD_MIU_TEST_AGT_CTRL, &agt_ctrl);\r\nif (ret_val == QLA_FUNCTION_FAILED) {\r\nql_log(ql_log_fatal, vha, 0xb0a4,\r\n"%s: failed to read "\r\n"MD_MIU_TEST_AGT_CTRL!\n", __func__);\r\ngoto exit_ms_mem_write_unlock;\r\n}\r\nif ((agt_ctrl & MIU_TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nql_log(ql_log_fatal, vha, 0xb0a5,\r\n"%s: MS memory write failed!\n",\r\n__func__);\r\nret_val = QLA_FUNCTION_FAILED;\r\ngoto exit_ms_mem_write_unlock;\r\n}\r\n}\r\nexit_ms_mem_write_unlock:\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nexit_ms_mem_write:\r\nreturn ret_val;\r\n}\r\nstatic int\r\nqla8044_copy_bootloader(struct scsi_qla_host *vha)\r\n{\r\nuint8_t *p_cache;\r\nuint32_t src, count, size;\r\nuint64_t dest;\r\nint ret_val = QLA_SUCCESS;\r\nstruct qla_hw_data *ha = vha->hw;\r\nsrc = QLA8044_BOOTLOADER_FLASH_ADDR;\r\ndest = qla8044_rd_reg(ha, QLA8044_BOOTLOADER_ADDR);\r\nsize = qla8044_rd_reg(ha, QLA8044_BOOTLOADER_SIZE);\r\nif (size & 0xF)\r\nsize = (size + 16) & ~0xF;\r\ncount = size/16;\r\np_cache = vmalloc(size);\r\nif (p_cache == NULL) {\r\nql_log(ql_log_fatal, vha, 0xb0a6,\r\n"%s: Failed to allocate memory for "\r\n"boot loader cache\n", __func__);\r\nret_val = QLA_FUNCTION_FAILED;\r\ngoto exit_copy_bootloader;\r\n}\r\nret_val = qla8044_lockless_flash_read_u32(vha, src,\r\np_cache, size/sizeof(uint32_t));\r\nif (ret_val == QLA_FUNCTION_FAILED) {\r\nql_log(ql_log_fatal, vha, 0xb0a7,\r\n"%s: Error reading F/W from flash!!!\n", __func__);\r\ngoto exit_copy_error;\r\n}\r\nql_dbg(ql_dbg_p3p, vha, 0xb0a8, "%s: Read F/W from flash!\n",\r\n__func__);\r\nret_val = qla8044_ms_mem_write_128b(vha, dest,\r\n(uint32_t *)p_cache, count);\r\nif (ret_val == QLA_FUNCTION_FAILED) {\r\nql_log(ql_log_fatal, vha, 0xb0a9,\r\n"%s: Error writing F/W to MS !!!\n", __func__);\r\ngoto exit_copy_error;\r\n}\r\nql_dbg(ql_dbg_p3p, vha, 0xb0aa,\r\n"%s: Wrote F/W (size %d) to MS !!!\n",\r\n__func__, size);\r\nexit_copy_error:\r\nvfree(p_cache);\r\nexit_copy_bootloader:\r\nreturn ret_val;\r\n}\r\nstatic int\r\nqla8044_restart(struct scsi_qla_host *vha)\r\n{\r\nint ret_val = QLA_SUCCESS;\r\nstruct qla_hw_data *ha = vha->hw;\r\nqla8044_process_stop_seq(vha);\r\nif (ql2xmdenable)\r\nqla8044_get_minidump(vha);\r\nelse\r\nql_log(ql_log_fatal, vha, 0xb14c,\r\n"Minidump disabled.\n");\r\nqla8044_process_init_seq(vha);\r\nif (qla8044_copy_bootloader(vha)) {\r\nql_log(ql_log_fatal, vha, 0xb0ab,\r\n"%s: Copy bootloader, firmware restart failed!\n",\r\n__func__);\r\nret_val = QLA_FUNCTION_FAILED;\r\ngoto exit_restart;\r\n}\r\nqla8044_wr_reg(ha, QLA8044_FW_IMAGE_VALID, QLA8044_BOOT_FROM_FLASH);\r\nqla8044_process_start_seq(vha);\r\nexit_restart:\r\nreturn ret_val;\r\n}\r\nstatic int\r\nqla8044_check_cmd_peg_status(struct scsi_qla_host *vha)\r\n{\r\nuint32_t val, ret_val = QLA_FUNCTION_FAILED;\r\nint retries = CRB_CMDPEG_CHECK_RETRY_COUNT;\r\nstruct qla_hw_data *ha = vha->hw;\r\ndo {\r\nval = qla8044_rd_reg(ha, QLA8044_CMDPEG_STATE);\r\nif (val == PHAN_INITIALIZE_COMPLETE) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb0ac,\r\n"%s: Command Peg initialization "\r\n"complete! state=0x%x\n", __func__, val);\r\nret_val = QLA_SUCCESS;\r\nbreak;\r\n}\r\nmsleep(CRB_CMDPEG_CHECK_DELAY);\r\n} while (--retries);\r\nreturn ret_val;\r\n}\r\nstatic int\r\nqla8044_start_firmware(struct scsi_qla_host *vha)\r\n{\r\nint ret_val = QLA_SUCCESS;\r\nif (qla8044_restart(vha)) {\r\nql_log(ql_log_fatal, vha, 0xb0ad,\r\n"%s: Restart Error!!!, Need Reset!!!\n",\r\n__func__);\r\nret_val = QLA_FUNCTION_FAILED;\r\ngoto exit_start_fw;\r\n} else\r\nql_dbg(ql_dbg_p3p, vha, 0xb0af,\r\n"%s: Restart done!\n", __func__);\r\nret_val = qla8044_check_cmd_peg_status(vha);\r\nif (ret_val) {\r\nql_log(ql_log_fatal, vha, 0xb0b0,\r\n"%s: Peg not initialized!\n", __func__);\r\nret_val = QLA_FUNCTION_FAILED;\r\n}\r\nexit_start_fw:\r\nreturn ret_val;\r\n}\r\nvoid\r\nqla8044_clear_drv_active(struct qla_hw_data *ha)\r\n{\r\nuint32_t drv_active;\r\nstruct scsi_qla_host *vha = pci_get_drvdata(ha->pdev);\r\ndrv_active = qla8044_rd_direct(vha, QLA8044_CRB_DRV_ACTIVE_INDEX);\r\ndrv_active &= ~(1 << (ha->portnum));\r\nql_log(ql_log_info, vha, 0xb0b1,\r\n"%s(%ld): drv_active: 0x%08x\n",\r\n__func__, vha->host_no, drv_active);\r\nqla8044_wr_direct(vha, QLA8044_CRB_DRV_ACTIVE_INDEX, drv_active);\r\n}\r\nstatic int\r\nqla8044_device_bootstrap(struct scsi_qla_host *vha)\r\n{\r\nint rval = QLA_FUNCTION_FAILED;\r\nint i;\r\nuint32_t old_count = 0, count = 0;\r\nint need_reset = 0;\r\nuint32_t idc_ctrl;\r\nstruct qla_hw_data *ha = vha->hw;\r\nneed_reset = qla8044_need_reset(vha);\r\nif (!need_reset) {\r\nold_count = qla8044_rd_direct(vha,\r\nQLA8044_PEG_ALIVE_COUNTER_INDEX);\r\nfor (i = 0; i < 10; i++) {\r\nmsleep(200);\r\ncount = qla8044_rd_direct(vha,\r\nQLA8044_PEG_ALIVE_COUNTER_INDEX);\r\nif (count != old_count) {\r\nrval = QLA_SUCCESS;\r\ngoto dev_ready;\r\n}\r\n}\r\nqla8044_flash_lock_recovery(vha);\r\n} else {\r\nif (ha->flags.isp82xx_fw_hung)\r\nqla8044_flash_lock_recovery(vha);\r\n}\r\nql_log(ql_log_info, vha, 0xb0b2,\r\n"%s: HW State: INITIALIZING\n", __func__);\r\nqla8044_wr_direct(vha, QLA8044_CRB_DEV_STATE_INDEX,\r\nQLA8XXX_DEV_INITIALIZING);\r\nqla8044_idc_unlock(ha);\r\nrval = qla8044_start_firmware(vha);\r\nqla8044_idc_lock(ha);\r\nif (rval != QLA_SUCCESS) {\r\nql_log(ql_log_info, vha, 0xb0b3,\r\n"%s: HW State: FAILED\n", __func__);\r\nqla8044_clear_drv_active(ha);\r\nqla8044_wr_direct(vha, QLA8044_CRB_DEV_STATE_INDEX,\r\nQLA8XXX_DEV_FAILED);\r\nreturn rval;\r\n}\r\nidc_ctrl = qla8044_rd_reg(ha, QLA8044_IDC_DRV_CTRL);\r\nif (idc_ctrl & GRACEFUL_RESET_BIT1) {\r\nqla8044_wr_reg(ha, QLA8044_IDC_DRV_CTRL,\r\n(idc_ctrl & ~GRACEFUL_RESET_BIT1));\r\nha->fw_dumped = 0;\r\n}\r\ndev_ready:\r\nql_log(ql_log_info, vha, 0xb0b4,\r\n"%s: HW State: READY\n", __func__);\r\nqla8044_wr_direct(vha, QLA8044_CRB_DEV_STATE_INDEX, QLA8XXX_DEV_READY);\r\nreturn rval;\r\n}\r\nstatic void\r\nqla8044_dump_reset_seq_hdr(struct scsi_qla_host *vha)\r\n{\r\nu8 *phdr;\r\nif (!vha->reset_tmplt.buff) {\r\nql_log(ql_log_fatal, vha, 0xb0b5,\r\n"%s: Error Invalid reset_seq_template\n", __func__);\r\nreturn;\r\n}\r\nphdr = vha->reset_tmplt.buff;\r\nql_dbg(ql_dbg_p3p, vha, 0xb0b6,\r\n"Reset Template :\n\t0x%X 0x%X 0x%X 0x%X"\r\n"0x%X 0x%X 0x%X 0x%X 0x%X 0x%X\n"\r\n"\t0x%X 0x%X 0x%X 0x%X 0x%X 0x%X\n\n",\r\n*phdr, *(phdr+1), *(phdr+2), *(phdr+3), *(phdr+4),\r\n*(phdr+5), *(phdr+6), *(phdr+7), *(phdr + 8),\r\n*(phdr+9), *(phdr+10), *(phdr+11), *(phdr+12),\r\n*(phdr+13), *(phdr+14), *(phdr+15));\r\n}\r\nstatic int\r\nqla8044_reset_seq_checksum_test(struct scsi_qla_host *vha)\r\n{\r\nuint32_t sum = 0;\r\nuint16_t *buff = (uint16_t *)vha->reset_tmplt.buff;\r\nint u16_count = vha->reset_tmplt.hdr->size / sizeof(uint16_t);\r\nwhile (u16_count-- > 0)\r\nsum += *buff++;\r\nwhile (sum >> 16)\r\nsum = (sum & 0xFFFF) + (sum >> 16);\r\nif (~sum) {\r\nreturn QLA_SUCCESS;\r\n} else {\r\nql_log(ql_log_fatal, vha, 0xb0b7,\r\n"%s: Reset seq checksum failed\n", __func__);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\n}\r\nvoid\r\nqla8044_read_reset_template(struct scsi_qla_host *vha)\r\n{\r\nuint8_t *p_buff;\r\nuint32_t addr, tmplt_hdr_def_size, tmplt_hdr_size;\r\nvha->reset_tmplt.seq_error = 0;\r\nvha->reset_tmplt.buff = vmalloc(QLA8044_RESTART_TEMPLATE_SIZE);\r\nif (vha->reset_tmplt.buff == NULL) {\r\nql_log(ql_log_fatal, vha, 0xb0b8,\r\n"%s: Failed to allocate reset template resources\n",\r\n__func__);\r\ngoto exit_read_reset_template;\r\n}\r\np_buff = vha->reset_tmplt.buff;\r\naddr = QLA8044_RESET_TEMPLATE_ADDR;\r\ntmplt_hdr_def_size =\r\nsizeof(struct qla8044_reset_template_hdr) / sizeof(uint32_t);\r\nql_dbg(ql_dbg_p3p, vha, 0xb0b9,\r\n"%s: Read template hdr size %d from Flash\n",\r\n__func__, tmplt_hdr_def_size);\r\nif (qla8044_read_flash_data(vha, p_buff, addr, tmplt_hdr_def_size)) {\r\nql_log(ql_log_fatal, vha, 0xb0ba,\r\n"%s: Failed to read reset template\n", __func__);\r\ngoto exit_read_template_error;\r\n}\r\nvha->reset_tmplt.hdr =\r\n(struct qla8044_reset_template_hdr *) vha->reset_tmplt.buff;\r\ntmplt_hdr_size = vha->reset_tmplt.hdr->hdr_size/sizeof(uint32_t);\r\nif ((tmplt_hdr_size != tmplt_hdr_def_size) ||\r\n(vha->reset_tmplt.hdr->signature != RESET_TMPLT_HDR_SIGNATURE)) {\r\nql_log(ql_log_fatal, vha, 0xb0bb,\r\n"%s: Template Header size invalid %d "\r\n"tmplt_hdr_def_size %d!!!\n", __func__,\r\ntmplt_hdr_size, tmplt_hdr_def_size);\r\ngoto exit_read_template_error;\r\n}\r\naddr = QLA8044_RESET_TEMPLATE_ADDR + vha->reset_tmplt.hdr->hdr_size;\r\np_buff = vha->reset_tmplt.buff + vha->reset_tmplt.hdr->hdr_size;\r\ntmplt_hdr_def_size = (vha->reset_tmplt.hdr->size -\r\nvha->reset_tmplt.hdr->hdr_size)/sizeof(uint32_t);\r\nql_dbg(ql_dbg_p3p, vha, 0xb0bc,\r\n"%s: Read rest of the template size %d\n",\r\n__func__, vha->reset_tmplt.hdr->size);\r\nif (qla8044_read_flash_data(vha, p_buff, addr, tmplt_hdr_def_size)) {\r\nql_log(ql_log_fatal, vha, 0xb0bd,\r\n"%s: Failed to read reset tempelate\n", __func__);\r\ngoto exit_read_template_error;\r\n}\r\nif (qla8044_reset_seq_checksum_test(vha)) {\r\nql_log(ql_log_fatal, vha, 0xb0be,\r\n"%s: Reset Seq checksum failed!\n", __func__);\r\ngoto exit_read_template_error;\r\n}\r\nql_dbg(ql_dbg_p3p, vha, 0xb0bf,\r\n"%s: Reset Seq checksum passed! Get stop, "\r\n"start and init seq offsets\n", __func__);\r\nvha->reset_tmplt.init_offset = vha->reset_tmplt.buff +\r\nvha->reset_tmplt.hdr->init_seq_offset;\r\nvha->reset_tmplt.start_offset = vha->reset_tmplt.buff +\r\nvha->reset_tmplt.hdr->start_seq_offset;\r\nvha->reset_tmplt.stop_offset = vha->reset_tmplt.buff +\r\nvha->reset_tmplt.hdr->hdr_size;\r\nqla8044_dump_reset_seq_hdr(vha);\r\ngoto exit_read_reset_template;\r\nexit_read_template_error:\r\nvfree(vha->reset_tmplt.buff);\r\nexit_read_reset_template:\r\nreturn;\r\n}\r\nvoid\r\nqla8044_set_idc_dontreset(struct scsi_qla_host *vha)\r\n{\r\nuint32_t idc_ctrl;\r\nstruct qla_hw_data *ha = vha->hw;\r\nidc_ctrl = qla8044_rd_reg(ha, QLA8044_IDC_DRV_CTRL);\r\nidc_ctrl |= DONTRESET_BIT0;\r\nql_dbg(ql_dbg_p3p, vha, 0xb0c0,\r\n"%s: idc_ctrl = %d\n", __func__, idc_ctrl);\r\nqla8044_wr_reg(ha, QLA8044_IDC_DRV_CTRL, idc_ctrl);\r\n}\r\ninline void\r\nqla8044_set_rst_ready(struct scsi_qla_host *vha)\r\n{\r\nuint32_t drv_state;\r\nstruct qla_hw_data *ha = vha->hw;\r\ndrv_state = qla8044_rd_direct(vha, QLA8044_CRB_DRV_STATE_INDEX);\r\ndrv_state |= (1 << ha->portnum);\r\nql_log(ql_log_info, vha, 0xb0c1,\r\n"%s(%ld): drv_state: 0x%08x\n",\r\n__func__, vha->host_no, drv_state);\r\nqla8044_wr_direct(vha, QLA8044_CRB_DRV_STATE_INDEX, drv_state);\r\n}\r\nstatic void\r\nqla8044_need_reset_handler(struct scsi_qla_host *vha)\r\n{\r\nuint32_t dev_state = 0, drv_state, drv_active;\r\nunsigned long reset_timeout;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_log(ql_log_fatal, vha, 0xb0c2,\r\n"%s: Performing ISP error recovery\n", __func__);\r\nif (vha->flags.online) {\r\nqla8044_idc_unlock(ha);\r\nqla2x00_abort_isp_cleanup(vha);\r\nha->isp_ops->get_flash_version(vha, vha->req->ring);\r\nha->isp_ops->nvram_config(vha);\r\nqla8044_idc_lock(ha);\r\n}\r\ndev_state = qla8044_rd_direct(vha,\r\nQLA8044_CRB_DEV_STATE_INDEX);\r\ndrv_state = qla8044_rd_direct(vha,\r\nQLA8044_CRB_DRV_STATE_INDEX);\r\ndrv_active = qla8044_rd_direct(vha,\r\nQLA8044_CRB_DRV_ACTIVE_INDEX);\r\nql_log(ql_log_info, vha, 0xb0c5,\r\n"%s(%ld): drv_state = 0x%x, drv_active = 0x%x dev_state = 0x%x\n",\r\n__func__, vha->host_no, drv_state, drv_active, dev_state);\r\nqla8044_set_rst_ready(vha);\r\nreset_timeout = jiffies + (ha->fcoe_reset_timeout * HZ);\r\ndo {\r\nif (time_after_eq(jiffies, reset_timeout)) {\r\nql_log(ql_log_info, vha, 0xb0c4,\r\n"%s: Function %d: Reset Ack Timeout!, drv_state: 0x%08x, drv_active: 0x%08x\n",\r\n__func__, ha->portnum, drv_state, drv_active);\r\nbreak;\r\n}\r\nqla8044_idc_unlock(ha);\r\nmsleep(1000);\r\nqla8044_idc_lock(ha);\r\ndev_state = qla8044_rd_direct(vha,\r\nQLA8044_CRB_DEV_STATE_INDEX);\r\ndrv_state = qla8044_rd_direct(vha,\r\nQLA8044_CRB_DRV_STATE_INDEX);\r\ndrv_active = qla8044_rd_direct(vha,\r\nQLA8044_CRB_DRV_ACTIVE_INDEX);\r\n} while (((drv_state & drv_active) != drv_active) &&\r\n(dev_state == QLA8XXX_DEV_NEED_RESET));\r\nif (drv_state != drv_active) {\r\nql_log(ql_log_info, vha, 0xb0c7,\r\n"%s(%ld): Function %d turning off drv_active of non-acking function 0x%x\n",\r\n__func__, vha->host_no, ha->portnum,\r\n(drv_active ^ drv_state));\r\ndrv_active = drv_active & drv_state;\r\nqla8044_wr_direct(vha, QLA8044_CRB_DRV_ACTIVE_INDEX,\r\ndrv_active);\r\n} else {\r\nif ((ha->flags.nic_core_reset_owner) &&\r\n(dev_state == QLA8XXX_DEV_NEED_RESET)) {\r\nha->flags.nic_core_reset_owner = 0;\r\nqla8044_device_bootstrap(vha);\r\nreturn;\r\n}\r\n}\r\nif (!(drv_active & (1 << ha->portnum))) {\r\nha->flags.nic_core_reset_owner = 0;\r\nreturn;\r\n}\r\nif (ha->flags.nic_core_reset_owner ||\r\n((drv_state & drv_active) == QLA8044_FUN7_ACTIVE_INDEX)) {\r\nha->flags.nic_core_reset_owner = 0;\r\nqla8044_device_bootstrap(vha);\r\n}\r\n}\r\nstatic void\r\nqla8044_set_drv_active(struct scsi_qla_host *vha)\r\n{\r\nuint32_t drv_active;\r\nstruct qla_hw_data *ha = vha->hw;\r\ndrv_active = qla8044_rd_direct(vha, QLA8044_CRB_DRV_ACTIVE_INDEX);\r\ndrv_active |= (1 << ha->portnum);\r\nql_log(ql_log_info, vha, 0xb0c8,\r\n"%s(%ld): drv_active: 0x%08x\n",\r\n__func__, vha->host_no, drv_active);\r\nqla8044_wr_direct(vha, QLA8044_CRB_DRV_ACTIVE_INDEX, drv_active);\r\n}\r\nstatic int\r\nqla8044_check_drv_active(struct scsi_qla_host *vha)\r\n{\r\nuint32_t drv_active;\r\nstruct qla_hw_data *ha = vha->hw;\r\ndrv_active = qla8044_rd_direct(vha, QLA8044_CRB_DRV_ACTIVE_INDEX);\r\nif (drv_active & (1 << ha->portnum))\r\nreturn QLA_SUCCESS;\r\nelse\r\nreturn QLA_TEST_FAILED;\r\n}\r\nstatic void\r\nqla8044_clear_idc_dontreset(struct scsi_qla_host *vha)\r\n{\r\nuint32_t idc_ctrl;\r\nstruct qla_hw_data *ha = vha->hw;\r\nidc_ctrl = qla8044_rd_reg(ha, QLA8044_IDC_DRV_CTRL);\r\nidc_ctrl &= ~DONTRESET_BIT0;\r\nql_log(ql_log_info, vha, 0xb0c9,\r\n"%s: idc_ctrl = %d\n", __func__,\r\nidc_ctrl);\r\nqla8044_wr_reg(ha, QLA8044_IDC_DRV_CTRL, idc_ctrl);\r\n}\r\nstatic int\r\nqla8044_set_idc_ver(struct scsi_qla_host *vha)\r\n{\r\nint idc_ver;\r\nuint32_t drv_active;\r\nint rval = QLA_SUCCESS;\r\nstruct qla_hw_data *ha = vha->hw;\r\ndrv_active = qla8044_rd_direct(vha, QLA8044_CRB_DRV_ACTIVE_INDEX);\r\nif (drv_active == (1 << ha->portnum)) {\r\nidc_ver = qla8044_rd_direct(vha,\r\nQLA8044_CRB_DRV_IDC_VERSION_INDEX);\r\nidc_ver &= (~0xFF);\r\nidc_ver |= QLA8044_IDC_VER_MAJ_VALUE;\r\nqla8044_wr_direct(vha, QLA8044_CRB_DRV_IDC_VERSION_INDEX,\r\nidc_ver);\r\nql_log(ql_log_info, vha, 0xb0ca,\r\n"%s: IDC version updated to %d\n",\r\n__func__, idc_ver);\r\n} else {\r\nidc_ver = qla8044_rd_direct(vha,\r\nQLA8044_CRB_DRV_IDC_VERSION_INDEX);\r\nidc_ver &= 0xFF;\r\nif (QLA8044_IDC_VER_MAJ_VALUE != idc_ver) {\r\nql_log(ql_log_info, vha, 0xb0cb,\r\n"%s: qla4xxx driver IDC version %d "\r\n"is not compatible with IDC version %d "\r\n"of other drivers!\n",\r\n__func__, QLA8044_IDC_VER_MAJ_VALUE,\r\nidc_ver);\r\nrval = QLA_FUNCTION_FAILED;\r\ngoto exit_set_idc_ver;\r\n}\r\n}\r\nidc_ver = qla8044_rd_reg(ha, QLA8044_CRB_IDC_VER_MINOR);\r\nidc_ver &= ~(0x03 << (ha->portnum * 2));\r\nidc_ver |= (QLA8044_IDC_VER_MIN_VALUE << (ha->portnum * 2));\r\nqla8044_wr_reg(ha, QLA8044_CRB_IDC_VER_MINOR, idc_ver);\r\nexit_set_idc_ver:\r\nreturn rval;\r\n}\r\nstatic int\r\nqla8044_update_idc_reg(struct scsi_qla_host *vha)\r\n{\r\nuint32_t drv_active;\r\nint rval = QLA_SUCCESS;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (vha->flags.init_done)\r\ngoto exit_update_idc_reg;\r\nqla8044_idc_lock(ha);\r\nqla8044_set_drv_active(vha);\r\ndrv_active = qla8044_rd_direct(vha,\r\nQLA8044_CRB_DRV_ACTIVE_INDEX);\r\nif ((drv_active == (1 << ha->portnum)) && !ql2xdontresethba)\r\nqla8044_clear_idc_dontreset(vha);\r\nrval = qla8044_set_idc_ver(vha);\r\nif (rval == QLA_FUNCTION_FAILED)\r\nqla8044_clear_drv_active(ha);\r\nqla8044_idc_unlock(ha);\r\nexit_update_idc_reg:\r\nreturn rval;\r\n}\r\nstatic void\r\nqla8044_need_qsnt_handler(struct scsi_qla_host *vha)\r\n{\r\nunsigned long qsnt_timeout;\r\nuint32_t drv_state, drv_active, dev_state;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (vha->flags.online)\r\nqla2x00_quiesce_io(vha);\r\nelse\r\nreturn;\r\nqla8044_set_qsnt_ready(vha);\r\nqsnt_timeout = jiffies + (QSNT_ACK_TOV * HZ);\r\ndrv_state = qla8044_rd_direct(vha, QLA8044_CRB_DRV_STATE_INDEX);\r\ndrv_active = qla8044_rd_direct(vha, QLA8044_CRB_DRV_ACTIVE_INDEX);\r\ndrv_active = drv_active << 1;\r\nwhile (drv_state != drv_active) {\r\nif (time_after_eq(jiffies, qsnt_timeout)) {\r\nclear_bit(ISP_QUIESCE_NEEDED, &vha->dpc_flags);\r\nqla8044_wr_direct(vha, QLA8044_CRB_DEV_STATE_INDEX,\r\nQLA8XXX_DEV_READY);\r\nqla8044_clear_qsnt_ready(vha);\r\nql_log(ql_log_info, vha, 0xb0cc,\r\n"Timeout waiting for quiescent ack!!!\n");\r\nreturn;\r\n}\r\nqla8044_idc_unlock(ha);\r\nmsleep(1000);\r\nqla8044_idc_lock(ha);\r\ndrv_state = qla8044_rd_direct(vha,\r\nQLA8044_CRB_DRV_STATE_INDEX);\r\ndrv_active = qla8044_rd_direct(vha,\r\nQLA8044_CRB_DRV_ACTIVE_INDEX);\r\ndrv_active = drv_active << 1;\r\n}\r\ndev_state = qla8044_rd_direct(vha, QLA8044_CRB_DEV_STATE_INDEX);\r\nif (dev_state == QLA8XXX_DEV_NEED_QUIESCENT) {\r\nqla8044_wr_direct(vha, QLA8044_CRB_DEV_STATE_INDEX,\r\nQLA8XXX_DEV_QUIESCENT);\r\nql_log(ql_log_info, vha, 0xb0cd,\r\n"%s: HW State: QUIESCENT\n", __func__);\r\n}\r\n}\r\nint\r\nqla8044_device_state_handler(struct scsi_qla_host *vha)\r\n{\r\nuint32_t dev_state;\r\nint rval = QLA_SUCCESS;\r\nunsigned long dev_init_timeout;\r\nstruct qla_hw_data *ha = vha->hw;\r\nrval = qla8044_update_idc_reg(vha);\r\nif (rval == QLA_FUNCTION_FAILED)\r\ngoto exit_error;\r\ndev_state = qla8044_rd_direct(vha, QLA8044_CRB_DEV_STATE_INDEX);\r\nql_dbg(ql_dbg_p3p, vha, 0xb0ce,\r\n"Device state is 0x%x = %s\n",\r\ndev_state, dev_state < MAX_STATES ?\r\nqdev_state(dev_state) : "Unknown");\r\ndev_init_timeout = jiffies + (ha->fcoe_dev_init_timeout * HZ);\r\nqla8044_idc_lock(ha);\r\nwhile (1) {\r\nif (time_after_eq(jiffies, dev_init_timeout)) {\r\nif (qla8044_check_drv_active(vha) == QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0xb0cf,\r\n"%s: Device Init Failed 0x%x = %s\n",\r\nQLA2XXX_DRIVER_NAME, dev_state,\r\ndev_state < MAX_STATES ?\r\nqdev_state(dev_state) : "Unknown");\r\nqla8044_wr_direct(vha,\r\nQLA8044_CRB_DEV_STATE_INDEX,\r\nQLA8XXX_DEV_FAILED);\r\n}\r\n}\r\ndev_state = qla8044_rd_direct(vha, QLA8044_CRB_DEV_STATE_INDEX);\r\nql_log(ql_log_info, vha, 0xb0d0,\r\n"Device state is 0x%x = %s\n",\r\ndev_state, dev_state < MAX_STATES ?\r\nqdev_state(dev_state) : "Unknown");\r\nswitch (dev_state) {\r\ncase QLA8XXX_DEV_READY:\r\nha->flags.nic_core_reset_owner = 0;\r\ngoto exit;\r\ncase QLA8XXX_DEV_COLD:\r\nrval = qla8044_device_bootstrap(vha);\r\nbreak;\r\ncase QLA8XXX_DEV_INITIALIZING:\r\nqla8044_idc_unlock(ha);\r\nmsleep(1000);\r\nqla8044_idc_lock(ha);\r\nbreak;\r\ncase QLA8XXX_DEV_NEED_RESET:\r\nqla8044_need_reset_handler(vha);\r\nbreak;\r\ncase QLA8XXX_DEV_NEED_QUIESCENT:\r\nqla8044_need_qsnt_handler(vha);\r\ndev_init_timeout = jiffies +\r\n(ha->fcoe_reset_timeout * HZ);\r\nbreak;\r\ncase QLA8XXX_DEV_QUIESCENT:\r\nql_log(ql_log_info, vha, 0xb0d1,\r\n"HW State: QUIESCENT\n");\r\nqla8044_idc_unlock(ha);\r\nmsleep(1000);\r\nqla8044_idc_lock(ha);\r\ndev_init_timeout = jiffies +\r\n(ha->fcoe_reset_timeout * HZ);\r\nbreak;\r\ncase QLA8XXX_DEV_FAILED:\r\nha->flags.nic_core_reset_owner = 0;\r\nqla8044_idc_unlock(ha);\r\nqla8xxx_dev_failed_handler(vha);\r\nrval = QLA_FUNCTION_FAILED;\r\nqla8044_idc_lock(ha);\r\ngoto exit;\r\ndefault:\r\nqla8044_idc_unlock(ha);\r\nqla8xxx_dev_failed_handler(vha);\r\nrval = QLA_FUNCTION_FAILED;\r\nqla8044_idc_lock(ha);\r\ngoto exit;\r\n}\r\n}\r\nexit:\r\nqla8044_idc_unlock(ha);\r\nexit_error:\r\nreturn rval;\r\n}\r\nstatic int\r\nqla8044_check_temp(struct scsi_qla_host *vha)\r\n{\r\nuint32_t temp, temp_state, temp_val;\r\nint status = QLA_SUCCESS;\r\ntemp = qla8044_rd_direct(vha, QLA8044_CRB_TEMP_STATE_INDEX);\r\ntemp_state = qla82xx_get_temp_state(temp);\r\ntemp_val = qla82xx_get_temp_val(temp);\r\nif (temp_state == QLA82XX_TEMP_PANIC) {\r\nql_log(ql_log_warn, vha, 0xb0d2,\r\n"Device temperature %d degrees C"\r\n" exceeds maximum allowed. Hardware has been shut"\r\n" down\n", temp_val);\r\nstatus = QLA_FUNCTION_FAILED;\r\nreturn status;\r\n} else if (temp_state == QLA82XX_TEMP_WARN) {\r\nql_log(ql_log_warn, vha, 0xb0d3,\r\n"Device temperature %d"\r\n" degrees C exceeds operating range."\r\n" Immediate action needed.\n", temp_val);\r\n}\r\nreturn 0;\r\n}\r\nint qla8044_read_temperature(scsi_qla_host_t *vha)\r\n{\r\nuint32_t temp;\r\ntemp = qla8044_rd_direct(vha, QLA8044_CRB_TEMP_STATE_INDEX);\r\nreturn qla82xx_get_temp_val(temp);\r\n}\r\nint\r\nqla8044_check_fw_alive(struct scsi_qla_host *vha)\r\n{\r\nuint32_t fw_heartbeat_counter;\r\nuint32_t halt_status1, halt_status2;\r\nint status = QLA_SUCCESS;\r\nfw_heartbeat_counter = qla8044_rd_direct(vha,\r\nQLA8044_PEG_ALIVE_COUNTER_INDEX);\r\nif (fw_heartbeat_counter == 0xffffffff) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb0d4,\r\n"scsi%ld: %s: Device in frozen "\r\n"state, QLA82XX_PEG_ALIVE_COUNTER is 0xffffffff\n",\r\nvha->host_no, __func__);\r\nreturn status;\r\n}\r\nif (vha->fw_heartbeat_counter == fw_heartbeat_counter) {\r\nvha->seconds_since_last_heartbeat++;\r\nif (vha->seconds_since_last_heartbeat == 2) {\r\nvha->seconds_since_last_heartbeat = 0;\r\nhalt_status1 = qla8044_rd_direct(vha,\r\nQLA8044_PEG_HALT_STATUS1_INDEX);\r\nhalt_status2 = qla8044_rd_direct(vha,\r\nQLA8044_PEG_HALT_STATUS2_INDEX);\r\nql_log(ql_log_info, vha, 0xb0d5,\r\n"scsi(%ld): %s, ISP8044 "\r\n"Dumping hw/fw registers:\n"\r\n" PEG_HALT_STATUS1: 0x%x, "\r\n"PEG_HALT_STATUS2: 0x%x,\n",\r\nvha->host_no, __func__, halt_status1,\r\nhalt_status2);\r\nstatus = QLA_FUNCTION_FAILED;\r\n}\r\n} else\r\nvha->seconds_since_last_heartbeat = 0;\r\nvha->fw_heartbeat_counter = fw_heartbeat_counter;\r\nreturn status;\r\n}\r\nvoid\r\nqla8044_watchdog(struct scsi_qla_host *vha)\r\n{\r\nuint32_t dev_state, halt_status;\r\nint halt_status_unrecoverable = 0;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!(test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags) ||\r\ntest_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags))) {\r\ndev_state = qla8044_rd_direct(vha, QLA8044_CRB_DEV_STATE_INDEX);\r\nif (qla8044_check_fw_alive(vha)) {\r\nha->flags.isp82xx_fw_hung = 1;\r\nql_log(ql_log_warn, vha, 0xb10a,\r\n"Firmware hung.\n");\r\nqla82xx_clear_pending_mbx(vha);\r\n}\r\nif (qla8044_check_temp(vha)) {\r\nset_bit(ISP_UNRECOVERABLE, &vha->dpc_flags);\r\nha->flags.isp82xx_fw_hung = 1;\r\nqla2xxx_wake_dpc(vha);\r\n} else if (dev_state == QLA8XXX_DEV_NEED_RESET &&\r\n!test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags)) {\r\nql_log(ql_log_info, vha, 0xb0d6,\r\n"%s: HW State: NEED RESET!\n",\r\n__func__);\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\n} else if (dev_state == QLA8XXX_DEV_NEED_QUIESCENT &&\r\n!test_bit(ISP_QUIESCE_NEEDED, &vha->dpc_flags)) {\r\nql_log(ql_log_info, vha, 0xb0d7,\r\n"%s: HW State: NEED QUIES detected!\n",\r\n__func__);\r\nset_bit(ISP_QUIESCE_NEEDED, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\n} else {\r\nif (ha->flags.isp82xx_fw_hung) {\r\nhalt_status = qla8044_rd_direct(vha,\r\nQLA8044_PEG_HALT_STATUS1_INDEX);\r\nif (halt_status &\r\nQLA8044_HALT_STATUS_FW_RESET) {\r\nql_log(ql_log_fatal, vha,\r\n0xb0d8, "%s: Firmware "\r\n"error detected device "\r\n"is being reset\n",\r\n__func__);\r\n} else if (halt_status &\r\nQLA8044_HALT_STATUS_UNRECOVERABLE) {\r\nhalt_status_unrecoverable = 1;\r\n}\r\nif (halt_status_unrecoverable) {\r\nset_bit(ISP_UNRECOVERABLE,\r\n&vha->dpc_flags);\r\n} else {\r\nif (dev_state ==\r\nQLA8XXX_DEV_QUIESCENT) {\r\nset_bit(FCOE_CTX_RESET_NEEDED,\r\n&vha->dpc_flags);\r\nql_log(ql_log_info, vha, 0xb0d9,\r\n"%s: FW CONTEXT Reset "\r\n"needed!\n", __func__);\r\n} else {\r\nql_log(ql_log_info, vha,\r\n0xb0da, "%s: "\r\n"detect abort needed\n",\r\n__func__);\r\nset_bit(ISP_ABORT_NEEDED,\r\n&vha->dpc_flags);\r\n}\r\n}\r\nqla2xxx_wake_dpc(vha);\r\n}\r\n}\r\n}\r\n}\r\nstatic int\r\nqla8044_minidump_process_control(struct scsi_qla_host *vha,\r\nstruct qla8044_minidump_entry_hdr *entry_hdr)\r\n{\r\nstruct qla8044_minidump_entry_crb *crb_entry;\r\nuint32_t read_value, opcode, poll_time, addr, index;\r\nuint32_t crb_addr, rval = QLA_SUCCESS;\r\nunsigned long wtime;\r\nstruct qla8044_minidump_template_hdr *tmplt_hdr;\r\nint i;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_dbg(ql_dbg_p3p, vha, 0xb0dd, "Entering fn: %s\n", __func__);\r\ntmplt_hdr = (struct qla8044_minidump_template_hdr *)\r\nha->md_tmplt_hdr;\r\ncrb_entry = (struct qla8044_minidump_entry_crb *)entry_hdr;\r\ncrb_addr = crb_entry->addr;\r\nfor (i = 0; i < crb_entry->op_count; i++) {\r\nopcode = crb_entry->crb_ctrl.opcode;\r\nif (opcode & QLA82XX_DBG_OPCODE_WR) {\r\nqla8044_wr_reg_indirect(vha, crb_addr,\r\ncrb_entry->value_1);\r\nopcode &= ~QLA82XX_DBG_OPCODE_WR;\r\n}\r\nif (opcode & QLA82XX_DBG_OPCODE_RW) {\r\nqla8044_rd_reg_indirect(vha, crb_addr, &read_value);\r\nqla8044_wr_reg_indirect(vha, crb_addr, read_value);\r\nopcode &= ~QLA82XX_DBG_OPCODE_RW;\r\n}\r\nif (opcode & QLA82XX_DBG_OPCODE_AND) {\r\nqla8044_rd_reg_indirect(vha, crb_addr, &read_value);\r\nread_value &= crb_entry->value_2;\r\nopcode &= ~QLA82XX_DBG_OPCODE_AND;\r\nif (opcode & QLA82XX_DBG_OPCODE_OR) {\r\nread_value |= crb_entry->value_3;\r\nopcode &= ~QLA82XX_DBG_OPCODE_OR;\r\n}\r\nqla8044_wr_reg_indirect(vha, crb_addr, read_value);\r\n}\r\nif (opcode & QLA82XX_DBG_OPCODE_OR) {\r\nqla8044_rd_reg_indirect(vha, crb_addr, &read_value);\r\nread_value |= crb_entry->value_3;\r\nqla8044_wr_reg_indirect(vha, crb_addr, read_value);\r\nopcode &= ~QLA82XX_DBG_OPCODE_OR;\r\n}\r\nif (opcode & QLA82XX_DBG_OPCODE_POLL) {\r\npoll_time = crb_entry->crb_strd.poll_timeout;\r\nwtime = jiffies + poll_time;\r\nqla8044_rd_reg_indirect(vha, crb_addr, &read_value);\r\ndo {\r\nif ((read_value & crb_entry->value_2) ==\r\ncrb_entry->value_1) {\r\nbreak;\r\n} else if (time_after_eq(jiffies, wtime)) {\r\nrval = QLA_FUNCTION_FAILED;\r\nbreak;\r\n} else {\r\nqla8044_rd_reg_indirect(vha,\r\ncrb_addr, &read_value);\r\n}\r\n} while (1);\r\nopcode &= ~QLA82XX_DBG_OPCODE_POLL;\r\n}\r\nif (opcode & QLA82XX_DBG_OPCODE_RDSTATE) {\r\nif (crb_entry->crb_strd.state_index_a) {\r\nindex = crb_entry->crb_strd.state_index_a;\r\naddr = tmplt_hdr->saved_state_array[index];\r\n} else {\r\naddr = crb_addr;\r\n}\r\nqla8044_rd_reg_indirect(vha, addr, &read_value);\r\nindex = crb_entry->crb_ctrl.state_index_v;\r\ntmplt_hdr->saved_state_array[index] = read_value;\r\nopcode &= ~QLA82XX_DBG_OPCODE_RDSTATE;\r\n}\r\nif (opcode & QLA82XX_DBG_OPCODE_WRSTATE) {\r\nif (crb_entry->crb_strd.state_index_a) {\r\nindex = crb_entry->crb_strd.state_index_a;\r\naddr = tmplt_hdr->saved_state_array[index];\r\n} else {\r\naddr = crb_addr;\r\n}\r\nif (crb_entry->crb_ctrl.state_index_v) {\r\nindex = crb_entry->crb_ctrl.state_index_v;\r\nread_value =\r\ntmplt_hdr->saved_state_array[index];\r\n} else {\r\nread_value = crb_entry->value_1;\r\n}\r\nqla8044_wr_reg_indirect(vha, addr, read_value);\r\nopcode &= ~QLA82XX_DBG_OPCODE_WRSTATE;\r\n}\r\nif (opcode & QLA82XX_DBG_OPCODE_MDSTATE) {\r\nindex = crb_entry->crb_ctrl.state_index_v;\r\nread_value = tmplt_hdr->saved_state_array[index];\r\nread_value <<= crb_entry->crb_ctrl.shl;\r\nread_value >>= crb_entry->crb_ctrl.shr;\r\nif (crb_entry->value_2)\r\nread_value &= crb_entry->value_2;\r\nread_value |= crb_entry->value_3;\r\nread_value += crb_entry->value_1;\r\ntmplt_hdr->saved_state_array[index] = read_value;\r\nopcode &= ~QLA82XX_DBG_OPCODE_MDSTATE;\r\n}\r\ncrb_addr += crb_entry->crb_strd.addr_stride;\r\n}\r\nreturn rval;\r\n}\r\nstatic void\r\nqla8044_minidump_process_rdcrb(struct scsi_qla_host *vha,\r\nstruct qla8044_minidump_entry_hdr *entry_hdr, uint32_t **d_ptr)\r\n{\r\nuint32_t r_addr, r_stride, loop_cnt, i, r_value;\r\nstruct qla8044_minidump_entry_crb *crb_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\nql_dbg(ql_dbg_p3p, vha, 0xb0de, "Entering fn: %s\n", __func__);\r\ncrb_hdr = (struct qla8044_minidump_entry_crb *)entry_hdr;\r\nr_addr = crb_hdr->addr;\r\nr_stride = crb_hdr->crb_strd.addr_stride;\r\nloop_cnt = crb_hdr->op_count;\r\nfor (i = 0; i < loop_cnt; i++) {\r\nqla8044_rd_reg_indirect(vha, r_addr, &r_value);\r\n*data_ptr++ = r_addr;\r\n*data_ptr++ = r_value;\r\nr_addr += r_stride;\r\n}\r\n*d_ptr = data_ptr;\r\n}\r\nstatic int\r\nqla8044_minidump_process_rdmem(struct scsi_qla_host *vha,\r\nstruct qla8044_minidump_entry_hdr *entry_hdr, uint32_t **d_ptr)\r\n{\r\nuint32_t r_addr, r_value, r_data;\r\nuint32_t i, j, loop_cnt;\r\nstruct qla8044_minidump_entry_rdmem *m_hdr;\r\nunsigned long flags;\r\nuint32_t *data_ptr = *d_ptr;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_dbg(ql_dbg_p3p, vha, 0xb0df, "Entering fn: %s\n", __func__);\r\nm_hdr = (struct qla8044_minidump_entry_rdmem *)entry_hdr;\r\nr_addr = m_hdr->read_addr;\r\nloop_cnt = m_hdr->read_data_size/16;\r\nql_dbg(ql_dbg_p3p, vha, 0xb0f0,\r\n"[%s]: Read addr: 0x%x, read_data_size: 0x%x\n",\r\n__func__, r_addr, m_hdr->read_data_size);\r\nif (r_addr & 0xf) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb0f1,\r\n"[%s]: Read addr 0x%x not 16 bytes aligned\n",\r\n__func__, r_addr);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nif (m_hdr->read_data_size % 16) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb0f2,\r\n"[%s]: Read data[0x%x] not multiple of 16 bytes\n",\r\n__func__, m_hdr->read_data_size);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nql_dbg(ql_dbg_p3p, vha, 0xb0f3,\r\n"[%s]: rdmem_addr: 0x%x, read_data_size: 0x%x, loop_cnt: 0x%x\n",\r\n__func__, r_addr, m_hdr->read_data_size, loop_cnt);\r\nwrite_lock_irqsave(&ha->hw_lock, flags);\r\nfor (i = 0; i < loop_cnt; i++) {\r\nqla8044_wr_reg_indirect(vha, MD_MIU_TEST_AGT_ADDR_LO, r_addr);\r\nr_value = 0;\r\nqla8044_wr_reg_indirect(vha, MD_MIU_TEST_AGT_ADDR_HI, r_value);\r\nr_value = MIU_TA_CTL_ENABLE;\r\nqla8044_wr_reg_indirect(vha, MD_MIU_TEST_AGT_CTRL, r_value);\r\nr_value = MIU_TA_CTL_START_ENABLE;\r\nqla8044_wr_reg_indirect(vha, MD_MIU_TEST_AGT_CTRL, r_value);\r\nfor (j = 0; j < MAX_CTL_CHECK; j++) {\r\nqla8044_rd_reg_indirect(vha, MD_MIU_TEST_AGT_CTRL,\r\n&r_value);\r\nif ((r_value & MIU_TA_CTL_BUSY) == 0)\r\nbreak;\r\n}\r\nif (j >= MAX_CTL_CHECK) {\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nreturn QLA_SUCCESS;\r\n}\r\nfor (j = 0; j < 4; j++) {\r\nqla8044_rd_reg_indirect(vha, MD_MIU_TEST_AGT_RDDATA[j],\r\n&r_data);\r\n*data_ptr++ = r_data;\r\n}\r\nr_addr += 16;\r\n}\r\nwrite_unlock_irqrestore(&ha->hw_lock, flags);\r\nql_dbg(ql_dbg_p3p, vha, 0xb0f4,\r\n"Leaving fn: %s datacount: 0x%x\n",\r\n__func__, (loop_cnt * 16));\r\n*d_ptr = data_ptr;\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic uint32_t\r\nqla8044_minidump_process_rdrom(struct scsi_qla_host *vha,\r\nstruct qla8044_minidump_entry_hdr *entry_hdr, uint32_t **d_ptr)\r\n{\r\nuint32_t fl_addr, u32_count, rval;\r\nstruct qla8044_minidump_entry_rdrom *rom_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\nrom_hdr = (struct qla8044_minidump_entry_rdrom *)entry_hdr;\r\nfl_addr = rom_hdr->read_addr;\r\nu32_count = (rom_hdr->read_data_size)/sizeof(uint32_t);\r\nql_dbg(ql_dbg_p3p, vha, 0xb0f5, "[%s]: fl_addr: 0x%x, count: 0x%x\n",\r\n__func__, fl_addr, u32_count);\r\nrval = qla8044_lockless_flash_read_u32(vha, fl_addr,\r\n(u8 *)(data_ptr), u32_count);\r\nif (rval != QLA_SUCCESS) {\r\nql_log(ql_log_fatal, vha, 0xb0f6,\r\n"%s: Flash Read Error,Count=%d\n", __func__, u32_count);\r\nreturn QLA_FUNCTION_FAILED;\r\n} else {\r\ndata_ptr += u32_count;\r\n*d_ptr = data_ptr;\r\nreturn QLA_SUCCESS;\r\n}\r\n}\r\nstatic void\r\nqla8044_mark_entry_skipped(struct scsi_qla_host *vha,\r\nstruct qla8044_minidump_entry_hdr *entry_hdr, int index)\r\n{\r\nentry_hdr->d_ctrl.driver_flags |= QLA82XX_DBG_SKIPPED_FLAG;\r\nql_log(ql_log_info, vha, 0xb0f7,\r\n"scsi(%ld): Skipping entry[%d]: ETYPE[0x%x]-ELEVEL[0x%x]\n",\r\nvha->host_no, index, entry_hdr->entry_type,\r\nentry_hdr->d_ctrl.entry_capture_mask);\r\n}\r\nstatic int\r\nqla8044_minidump_process_l2tag(struct scsi_qla_host *vha,\r\nstruct qla8044_minidump_entry_hdr *entry_hdr,\r\nuint32_t **d_ptr)\r\n{\r\nuint32_t addr, r_addr, c_addr, t_r_addr;\r\nuint32_t i, k, loop_count, t_value, r_cnt, r_value;\r\nunsigned long p_wait, w_time, p_mask;\r\nuint32_t c_value_w, c_value_r;\r\nstruct qla8044_minidump_entry_cache *cache_hdr;\r\nint rval = QLA_FUNCTION_FAILED;\r\nuint32_t *data_ptr = *d_ptr;\r\nql_dbg(ql_dbg_p3p, vha, 0xb0f8, "Entering fn: %s\n", __func__);\r\ncache_hdr = (struct qla8044_minidump_entry_cache *)entry_hdr;\r\nloop_count = cache_hdr->op_count;\r\nr_addr = cache_hdr->read_addr;\r\nc_addr = cache_hdr->control_addr;\r\nc_value_w = cache_hdr->cache_ctrl.write_value;\r\nt_r_addr = cache_hdr->tag_reg_addr;\r\nt_value = cache_hdr->addr_ctrl.init_tag_value;\r\nr_cnt = cache_hdr->read_ctrl.read_addr_cnt;\r\np_wait = cache_hdr->cache_ctrl.poll_wait;\r\np_mask = cache_hdr->cache_ctrl.poll_mask;\r\nfor (i = 0; i < loop_count; i++) {\r\nqla8044_wr_reg_indirect(vha, t_r_addr, t_value);\r\nif (c_value_w)\r\nqla8044_wr_reg_indirect(vha, c_addr, c_value_w);\r\nif (p_mask) {\r\nw_time = jiffies + p_wait;\r\ndo {\r\nqla8044_rd_reg_indirect(vha, c_addr,\r\n&c_value_r);\r\nif ((c_value_r & p_mask) == 0) {\r\nbreak;\r\n} else if (time_after_eq(jiffies, w_time)) {\r\nreturn rval;\r\n}\r\n} while (1);\r\n}\r\naddr = r_addr;\r\nfor (k = 0; k < r_cnt; k++) {\r\nqla8044_rd_reg_indirect(vha, addr, &r_value);\r\n*data_ptr++ = r_value;\r\naddr += cache_hdr->read_ctrl.read_addr_stride;\r\n}\r\nt_value += cache_hdr->addr_ctrl.tag_value_stride;\r\n}\r\n*d_ptr = data_ptr;\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic void\r\nqla8044_minidump_process_l1cache(struct scsi_qla_host *vha,\r\nstruct qla8044_minidump_entry_hdr *entry_hdr, uint32_t **d_ptr)\r\n{\r\nuint32_t addr, r_addr, c_addr, t_r_addr;\r\nuint32_t i, k, loop_count, t_value, r_cnt, r_value;\r\nuint32_t c_value_w;\r\nstruct qla8044_minidump_entry_cache *cache_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\ncache_hdr = (struct qla8044_minidump_entry_cache *)entry_hdr;\r\nloop_count = cache_hdr->op_count;\r\nr_addr = cache_hdr->read_addr;\r\nc_addr = cache_hdr->control_addr;\r\nc_value_w = cache_hdr->cache_ctrl.write_value;\r\nt_r_addr = cache_hdr->tag_reg_addr;\r\nt_value = cache_hdr->addr_ctrl.init_tag_value;\r\nr_cnt = cache_hdr->read_ctrl.read_addr_cnt;\r\nfor (i = 0; i < loop_count; i++) {\r\nqla8044_wr_reg_indirect(vha, t_r_addr, t_value);\r\nqla8044_wr_reg_indirect(vha, c_addr, c_value_w);\r\naddr = r_addr;\r\nfor (k = 0; k < r_cnt; k++) {\r\nqla8044_rd_reg_indirect(vha, addr, &r_value);\r\n*data_ptr++ = r_value;\r\naddr += cache_hdr->read_ctrl.read_addr_stride;\r\n}\r\nt_value += cache_hdr->addr_ctrl.tag_value_stride;\r\n}\r\n*d_ptr = data_ptr;\r\n}\r\nstatic void\r\nqla8044_minidump_process_rdocm(struct scsi_qla_host *vha,\r\nstruct qla8044_minidump_entry_hdr *entry_hdr, uint32_t **d_ptr)\r\n{\r\nuint32_t r_addr, r_stride, loop_cnt, i, r_value;\r\nstruct qla8044_minidump_entry_rdocm *ocm_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_dbg(ql_dbg_p3p, vha, 0xb0f9, "Entering fn: %s\n", __func__);\r\nocm_hdr = (struct qla8044_minidump_entry_rdocm *)entry_hdr;\r\nr_addr = ocm_hdr->read_addr;\r\nr_stride = ocm_hdr->read_addr_stride;\r\nloop_cnt = ocm_hdr->op_count;\r\nql_dbg(ql_dbg_p3p, vha, 0xb0fa,\r\n"[%s]: r_addr: 0x%x, r_stride: 0x%x, loop_cnt: 0x%x\n",\r\n__func__, r_addr, r_stride, loop_cnt);\r\nfor (i = 0; i < loop_cnt; i++) {\r\nr_value = readl((void __iomem *)(r_addr + ha->nx_pcibase));\r\n*data_ptr++ = r_value;\r\nr_addr += r_stride;\r\n}\r\nql_dbg(ql_dbg_p3p, vha, 0xb0fb, "Leaving fn: %s datacount: 0x%lx\n",\r\n__func__, (long unsigned int) (loop_cnt * sizeof(uint32_t)));\r\n*d_ptr = data_ptr;\r\n}\r\nstatic void\r\nqla8044_minidump_process_rdmux(struct scsi_qla_host *vha,\r\nstruct qla8044_minidump_entry_hdr *entry_hdr,\r\nuint32_t **d_ptr)\r\n{\r\nuint32_t r_addr, s_stride, s_addr, s_value, loop_cnt, i, r_value;\r\nstruct qla8044_minidump_entry_mux *mux_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\nql_dbg(ql_dbg_p3p, vha, 0xb0fc, "Entering fn: %s\n", __func__);\r\nmux_hdr = (struct qla8044_minidump_entry_mux *)entry_hdr;\r\nr_addr = mux_hdr->read_addr;\r\ns_addr = mux_hdr->select_addr;\r\ns_stride = mux_hdr->select_value_stride;\r\ns_value = mux_hdr->select_value;\r\nloop_cnt = mux_hdr->op_count;\r\nfor (i = 0; i < loop_cnt; i++) {\r\nqla8044_wr_reg_indirect(vha, s_addr, s_value);\r\nqla8044_rd_reg_indirect(vha, r_addr, &r_value);\r\n*data_ptr++ = s_value;\r\n*data_ptr++ = r_value;\r\ns_value += s_stride;\r\n}\r\n*d_ptr = data_ptr;\r\n}\r\nstatic void\r\nqla8044_minidump_process_queue(struct scsi_qla_host *vha,\r\nstruct qla8044_minidump_entry_hdr *entry_hdr,\r\nuint32_t **d_ptr)\r\n{\r\nuint32_t s_addr, r_addr;\r\nuint32_t r_stride, r_value, r_cnt, qid = 0;\r\nuint32_t i, k, loop_cnt;\r\nstruct qla8044_minidump_entry_queue *q_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\nql_dbg(ql_dbg_p3p, vha, 0xb0fd, "Entering fn: %s\n", __func__);\r\nq_hdr = (struct qla8044_minidump_entry_queue *)entry_hdr;\r\ns_addr = q_hdr->select_addr;\r\nr_cnt = q_hdr->rd_strd.read_addr_cnt;\r\nr_stride = q_hdr->rd_strd.read_addr_stride;\r\nloop_cnt = q_hdr->op_count;\r\nfor (i = 0; i < loop_cnt; i++) {\r\nqla8044_wr_reg_indirect(vha, s_addr, qid);\r\nr_addr = q_hdr->read_addr;\r\nfor (k = 0; k < r_cnt; k++) {\r\nqla8044_rd_reg_indirect(vha, r_addr, &r_value);\r\n*data_ptr++ = r_value;\r\nr_addr += r_stride;\r\n}\r\nqid += q_hdr->q_strd.queue_id_stride;\r\n}\r\n*d_ptr = data_ptr;\r\n}\r\nstatic uint32_t\r\nqla8044_minidump_process_pollrd(struct scsi_qla_host *vha,\r\nstruct qla8044_minidump_entry_hdr *entry_hdr,\r\nuint32_t **d_ptr)\r\n{\r\nuint32_t r_addr, s_addr, s_value, r_value, poll_wait, poll_mask;\r\nuint16_t s_stride, i;\r\nstruct qla8044_minidump_entry_pollrd *pollrd_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\npollrd_hdr = (struct qla8044_minidump_entry_pollrd *) entry_hdr;\r\ns_addr = pollrd_hdr->select_addr;\r\nr_addr = pollrd_hdr->read_addr;\r\ns_value = pollrd_hdr->select_value;\r\ns_stride = pollrd_hdr->select_value_stride;\r\npoll_wait = pollrd_hdr->poll_wait;\r\npoll_mask = pollrd_hdr->poll_mask;\r\nfor (i = 0; i < pollrd_hdr->op_count; i++) {\r\nqla8044_wr_reg_indirect(vha, s_addr, s_value);\r\npoll_wait = pollrd_hdr->poll_wait;\r\nwhile (1) {\r\nqla8044_rd_reg_indirect(vha, s_addr, &r_value);\r\nif ((r_value & poll_mask) != 0) {\r\nbreak;\r\n} else {\r\nusleep_range(1000, 1100);\r\nif (--poll_wait == 0) {\r\nql_log(ql_log_fatal, vha, 0xb0fe,\r\n"%s: TIMEOUT\n", __func__);\r\ngoto error;\r\n}\r\n}\r\n}\r\nqla8044_rd_reg_indirect(vha, r_addr, &r_value);\r\n*data_ptr++ = s_value;\r\n*data_ptr++ = r_value;\r\ns_value += s_stride;\r\n}\r\n*d_ptr = data_ptr;\r\nreturn QLA_SUCCESS;\r\nerror:\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nstatic void\r\nqla8044_minidump_process_rdmux2(struct scsi_qla_host *vha,\r\nstruct qla8044_minidump_entry_hdr *entry_hdr, uint32_t **d_ptr)\r\n{\r\nuint32_t sel_val1, sel_val2, t_sel_val, data, i;\r\nuint32_t sel_addr1, sel_addr2, sel_val_mask, read_addr;\r\nstruct qla8044_minidump_entry_rdmux2 *rdmux2_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\nrdmux2_hdr = (struct qla8044_minidump_entry_rdmux2 *) entry_hdr;\r\nsel_val1 = rdmux2_hdr->select_value_1;\r\nsel_val2 = rdmux2_hdr->select_value_2;\r\nsel_addr1 = rdmux2_hdr->select_addr_1;\r\nsel_addr2 = rdmux2_hdr->select_addr_2;\r\nsel_val_mask = rdmux2_hdr->select_value_mask;\r\nread_addr = rdmux2_hdr->read_addr;\r\nfor (i = 0; i < rdmux2_hdr->op_count; i++) {\r\nqla8044_wr_reg_indirect(vha, sel_addr1, sel_val1);\r\nt_sel_val = sel_val1 & sel_val_mask;\r\n*data_ptr++ = t_sel_val;\r\nqla8044_wr_reg_indirect(vha, sel_addr2, t_sel_val);\r\nqla8044_rd_reg_indirect(vha, read_addr, &data);\r\n*data_ptr++ = data;\r\nqla8044_wr_reg_indirect(vha, sel_addr1, sel_val2);\r\nt_sel_val = sel_val2 & sel_val_mask;\r\n*data_ptr++ = t_sel_val;\r\nqla8044_wr_reg_indirect(vha, sel_addr2, t_sel_val);\r\nqla8044_rd_reg_indirect(vha, read_addr, &data);\r\n*data_ptr++ = data;\r\nsel_val1 += rdmux2_hdr->select_value_stride;\r\nsel_val2 += rdmux2_hdr->select_value_stride;\r\n}\r\n*d_ptr = data_ptr;\r\n}\r\nstatic uint32_t\r\nqla8044_minidump_process_pollrdmwr(struct scsi_qla_host *vha,\r\nstruct qla8044_minidump_entry_hdr *entry_hdr,\r\nuint32_t **d_ptr)\r\n{\r\nuint32_t poll_wait, poll_mask, r_value, data;\r\nuint32_t addr_1, addr_2, value_1, value_2;\r\nstruct qla8044_minidump_entry_pollrdmwr *poll_hdr;\r\nuint32_t *data_ptr = *d_ptr;\r\npoll_hdr = (struct qla8044_minidump_entry_pollrdmwr *) entry_hdr;\r\naddr_1 = poll_hdr->addr_1;\r\naddr_2 = poll_hdr->addr_2;\r\nvalue_1 = poll_hdr->value_1;\r\nvalue_2 = poll_hdr->value_2;\r\npoll_mask = poll_hdr->poll_mask;\r\nqla8044_wr_reg_indirect(vha, addr_1, value_1);\r\npoll_wait = poll_hdr->poll_wait;\r\nwhile (1) {\r\nqla8044_rd_reg_indirect(vha, addr_1, &r_value);\r\nif ((r_value & poll_mask) != 0) {\r\nbreak;\r\n} else {\r\nusleep_range(1000, 1100);\r\nif (--poll_wait == 0) {\r\nql_log(ql_log_fatal, vha, 0xb0ff,\r\n"%s: TIMEOUT\n", __func__);\r\ngoto error;\r\n}\r\n}\r\n}\r\nqla8044_rd_reg_indirect(vha, addr_2, &data);\r\ndata &= poll_hdr->modify_mask;\r\nqla8044_wr_reg_indirect(vha, addr_2, data);\r\nqla8044_wr_reg_indirect(vha, addr_1, value_2);\r\npoll_wait = poll_hdr->poll_wait;\r\nwhile (1) {\r\nqla8044_rd_reg_indirect(vha, addr_1, &r_value);\r\nif ((r_value & poll_mask) != 0) {\r\nbreak;\r\n} else {\r\nusleep_range(1000, 1100);\r\nif (--poll_wait == 0) {\r\nql_log(ql_log_fatal, vha, 0xb100,\r\n"%s: TIMEOUT2\n", __func__);\r\ngoto error;\r\n}\r\n}\r\n}\r\n*data_ptr++ = addr_2;\r\n*data_ptr++ = data;\r\n*d_ptr = data_ptr;\r\nreturn QLA_SUCCESS;\r\nerror:\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nstatic int\r\nqla8044_check_dma_engine_state(struct scsi_qla_host *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nint rval = QLA_SUCCESS;\r\nuint32_t dma_eng_num = 0, cmd_sts_and_cntrl = 0;\r\nuint64_t dma_base_addr = 0;\r\nstruct qla8044_minidump_template_hdr *tmplt_hdr = NULL;\r\ntmplt_hdr = ha->md_tmplt_hdr;\r\ndma_eng_num =\r\ntmplt_hdr->saved_state_array[ISP8044_PEX_DMA_ENGINE_INDEX];\r\ndma_base_addr = ISP8044_PEX_DMA_BASE_ADDRESS +\r\n(dma_eng_num * ISP8044_PEX_DMA_NUM_OFFSET);\r\nrval = qla8044_rd_reg_indirect(vha,\r\n(dma_base_addr + ISP8044_PEX_DMA_CMD_STS_AND_CNTRL),\r\n&cmd_sts_and_cntrl);\r\nif (rval)\r\nreturn QLA_FUNCTION_FAILED;\r\nif (cmd_sts_and_cntrl & BIT_31)\r\nreturn QLA_SUCCESS;\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nstatic int\r\nqla8044_start_pex_dma(struct scsi_qla_host *vha,\r\nstruct qla8044_minidump_entry_rdmem_pex_dma *m_hdr)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nint rval = QLA_SUCCESS, wait = 0;\r\nuint32_t dma_eng_num = 0, cmd_sts_and_cntrl = 0;\r\nuint64_t dma_base_addr = 0;\r\nstruct qla8044_minidump_template_hdr *tmplt_hdr = NULL;\r\ntmplt_hdr = ha->md_tmplt_hdr;\r\ndma_eng_num =\r\ntmplt_hdr->saved_state_array[ISP8044_PEX_DMA_ENGINE_INDEX];\r\ndma_base_addr = ISP8044_PEX_DMA_BASE_ADDRESS +\r\n(dma_eng_num * ISP8044_PEX_DMA_NUM_OFFSET);\r\nrval = qla8044_wr_reg_indirect(vha,\r\ndma_base_addr + ISP8044_PEX_DMA_CMD_ADDR_LOW,\r\nm_hdr->desc_card_addr);\r\nif (rval)\r\ngoto error_exit;\r\nrval = qla8044_wr_reg_indirect(vha,\r\ndma_base_addr + ISP8044_PEX_DMA_CMD_ADDR_HIGH, 0);\r\nif (rval)\r\ngoto error_exit;\r\nrval = qla8044_wr_reg_indirect(vha,\r\ndma_base_addr + ISP8044_PEX_DMA_CMD_STS_AND_CNTRL,\r\nm_hdr->start_dma_cmd);\r\nif (rval)\r\ngoto error_exit;\r\nfor (wait = 0; wait < ISP8044_PEX_DMA_MAX_WAIT; wait++) {\r\nrval = qla8044_rd_reg_indirect(vha,\r\n(dma_base_addr + ISP8044_PEX_DMA_CMD_STS_AND_CNTRL),\r\n&cmd_sts_and_cntrl);\r\nif (rval)\r\ngoto error_exit;\r\nif ((cmd_sts_and_cntrl & BIT_1) == 0)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (wait >= ISP8044_PEX_DMA_MAX_WAIT) {\r\nrval = QLA_FUNCTION_FAILED;\r\ngoto error_exit;\r\n}\r\nerror_exit:\r\nreturn rval;\r\n}\r\nstatic int\r\nqla8044_minidump_pex_dma_read(struct scsi_qla_host *vha,\r\nstruct qla8044_minidump_entry_hdr *entry_hdr, uint32_t **d_ptr)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nint rval = QLA_SUCCESS;\r\nstruct qla8044_minidump_entry_rdmem_pex_dma *m_hdr = NULL;\r\nuint32_t chunk_size, read_size;\r\nuint8_t *data_ptr = (uint8_t *)*d_ptr;\r\nvoid *rdmem_buffer = NULL;\r\ndma_addr_t rdmem_dma;\r\nstruct qla8044_pex_dma_descriptor dma_desc;\r\nrval = qla8044_check_dma_engine_state(vha);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb147,\r\n"DMA engine not available. Fallback to rdmem-read.\n");\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nm_hdr = (void *)entry_hdr;\r\nrdmem_buffer = dma_alloc_coherent(&ha->pdev->dev,\r\nISP8044_PEX_DMA_READ_SIZE, &rdmem_dma, GFP_KERNEL);\r\nif (!rdmem_buffer) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb148,\r\n"Unable to allocate rdmem dma buffer\n");\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\ndma_desc.cmd.dma_desc_cmd = (m_hdr->dma_desc_cmd & 0xff0f);\r\ndma_desc.cmd.dma_desc_cmd |=\r\n((PCI_FUNC(ha->pdev->devfn) & 0xf) << 0x4);\r\ndma_desc.dma_bus_addr = rdmem_dma;\r\ndma_desc.cmd.read_data_size = chunk_size = ISP8044_PEX_DMA_READ_SIZE;\r\nread_size = 0;\r\nwhile (read_size < m_hdr->read_data_size) {\r\nif (m_hdr->read_data_size - read_size <\r\nISP8044_PEX_DMA_READ_SIZE) {\r\nchunk_size = (m_hdr->read_data_size - read_size);\r\ndma_desc.cmd.read_data_size = chunk_size;\r\n}\r\ndma_desc.src_addr = m_hdr->read_addr + read_size;\r\nrval = qla8044_ms_mem_write_128b(vha,\r\nm_hdr->desc_card_addr, (void *)&dma_desc,\r\n(sizeof(struct qla8044_pex_dma_descriptor)/16));\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0xb14a,\r\n"%s: Error writing rdmem-dma-init to MS !!!\n",\r\n__func__);\r\ngoto error_exit;\r\n}\r\nql_dbg(ql_dbg_p3p, vha, 0xb14b,\r\n"%s: Dma-descriptor: Instruct for rdmem dma "\r\n"(chunk_size 0x%x).\n", __func__, chunk_size);\r\nrval = qla8044_start_pex_dma(vha, m_hdr);\r\nif (rval)\r\ngoto error_exit;\r\nmemcpy(data_ptr, rdmem_buffer, chunk_size);\r\ndata_ptr += chunk_size;\r\nread_size += chunk_size;\r\n}\r\n*d_ptr = (void *)data_ptr;\r\nerror_exit:\r\nif (rdmem_buffer)\r\ndma_free_coherent(&ha->pdev->dev, ISP8044_PEX_DMA_READ_SIZE,\r\nrdmem_buffer, rdmem_dma);\r\nreturn rval;\r\n}\r\nstatic uint32_t\r\nqla8044_minidump_process_rddfe(struct scsi_qla_host *vha,\r\nstruct qla8044_minidump_entry_hdr *entry_hdr, uint32_t **d_ptr)\r\n{\r\nint loop_cnt;\r\nuint32_t addr1, addr2, value, data, temp, wrVal;\r\nuint8_t stride, stride2;\r\nuint16_t count;\r\nuint32_t poll, mask, data_size, modify_mask;\r\nuint32_t wait_count = 0;\r\nuint32_t *data_ptr = *d_ptr;\r\nstruct qla8044_minidump_entry_rddfe *rddfe;\r\nrddfe = (struct qla8044_minidump_entry_rddfe *) entry_hdr;\r\naddr1 = rddfe->addr_1;\r\nvalue = rddfe->value;\r\nstride = rddfe->stride;\r\nstride2 = rddfe->stride2;\r\ncount = rddfe->count;\r\npoll = rddfe->poll;\r\nmask = rddfe->mask;\r\nmodify_mask = rddfe->modify_mask;\r\ndata_size = rddfe->data_size;\r\naddr2 = addr1 + stride;\r\nfor (loop_cnt = 0x0; loop_cnt < count; loop_cnt++) {\r\nqla8044_wr_reg_indirect(vha, addr1, (0x40000000 | value));\r\nwait_count = 0;\r\nwhile (wait_count < poll) {\r\nqla8044_rd_reg_indirect(vha, addr1, &temp);\r\nif ((temp & mask) != 0)\r\nbreak;\r\nwait_count++;\r\n}\r\nif (wait_count == poll) {\r\nql_log(ql_log_warn, vha, 0xb153,\r\n"%s: TIMEOUT\n", __func__);\r\ngoto error;\r\n} else {\r\nqla8044_rd_reg_indirect(vha, addr2, &temp);\r\ntemp = temp & modify_mask;\r\ntemp = (temp | ((loop_cnt << 16) | loop_cnt));\r\nwrVal = ((temp << 16) | temp);\r\nqla8044_wr_reg_indirect(vha, addr2, wrVal);\r\nqla8044_wr_reg_indirect(vha, addr1, value);\r\nwait_count = 0;\r\nwhile (wait_count < poll) {\r\nqla8044_rd_reg_indirect(vha, addr1, &temp);\r\nif ((temp & mask) != 0)\r\nbreak;\r\nwait_count++;\r\n}\r\nif (wait_count == poll) {\r\nql_log(ql_log_warn, vha, 0xb154,\r\n"%s: TIMEOUT\n", __func__);\r\ngoto error;\r\n}\r\nqla8044_wr_reg_indirect(vha, addr1,\r\n((0x40000000 | value) + stride2));\r\nwait_count = 0;\r\nwhile (wait_count < poll) {\r\nqla8044_rd_reg_indirect(vha, addr1, &temp);\r\nif ((temp & mask) != 0)\r\nbreak;\r\nwait_count++;\r\n}\r\nif (wait_count == poll) {\r\nql_log(ql_log_warn, vha, 0xb155,\r\n"%s: TIMEOUT\n", __func__);\r\ngoto error;\r\n}\r\nqla8044_rd_reg_indirect(vha, addr2, &data);\r\n*data_ptr++ = wrVal;\r\n*data_ptr++ = data;\r\n}\r\n}\r\n*d_ptr = data_ptr;\r\nreturn QLA_SUCCESS;\r\nerror:\r\nreturn -1;\r\n}\r\nstatic uint32_t\r\nqla8044_minidump_process_rdmdio(struct scsi_qla_host *vha,\r\nstruct qla8044_minidump_entry_hdr *entry_hdr, uint32_t **d_ptr)\r\n{\r\nint ret = 0;\r\nuint32_t addr1, addr2, value1, value2, data, selVal;\r\nuint8_t stride1, stride2;\r\nuint32_t addr3, addr4, addr5, addr6, addr7;\r\nuint16_t count, loop_cnt;\r\nuint32_t poll, mask;\r\nuint32_t *data_ptr = *d_ptr;\r\nstruct qla8044_minidump_entry_rdmdio *rdmdio;\r\nrdmdio = (struct qla8044_minidump_entry_rdmdio *) entry_hdr;\r\naddr1 = rdmdio->addr_1;\r\naddr2 = rdmdio->addr_2;\r\nvalue1 = rdmdio->value_1;\r\nstride1 = rdmdio->stride_1;\r\nstride2 = rdmdio->stride_2;\r\ncount = rdmdio->count;\r\npoll = rdmdio->poll;\r\nmask = rdmdio->mask;\r\nvalue2 = rdmdio->value_2;\r\naddr3 = addr1 + stride1;\r\nfor (loop_cnt = 0; loop_cnt < count; loop_cnt++) {\r\nret = qla8044_poll_wait_ipmdio_bus_idle(vha, addr1, addr2,\r\naddr3, mask);\r\nif (ret == -1)\r\ngoto error;\r\naddr4 = addr2 - stride1;\r\nret = qla8044_ipmdio_wr_reg(vha, addr1, addr3, mask, addr4,\r\nvalue2);\r\nif (ret == -1)\r\ngoto error;\r\naddr5 = addr2 - (2 * stride1);\r\nret = qla8044_ipmdio_wr_reg(vha, addr1, addr3, mask, addr5,\r\nvalue1);\r\nif (ret == -1)\r\ngoto error;\r\naddr6 = addr2 - (3 * stride1);\r\nret = qla8044_ipmdio_wr_reg(vha, addr1, addr3, mask,\r\naddr6, 0x2);\r\nif (ret == -1)\r\ngoto error;\r\nret = qla8044_poll_wait_ipmdio_bus_idle(vha, addr1, addr2,\r\naddr3, mask);\r\nif (ret == -1)\r\ngoto error;\r\naddr7 = addr2 - (4 * stride1);\r\ndata = qla8044_ipmdio_rd_reg(vha, addr1, addr3,\r\nmask, addr7);\r\nif (data == -1)\r\ngoto error;\r\nselVal = (value2 << 18) | (value1 << 2) | 2;\r\nstride2 = rdmdio->stride_2;\r\n*data_ptr++ = selVal;\r\n*data_ptr++ = data;\r\nvalue1 = value1 + stride2;\r\n*d_ptr = data_ptr;\r\n}\r\nreturn 0;\r\nerror:\r\nreturn -1;\r\n}\r\nstatic uint32_t qla8044_minidump_process_pollwr(struct scsi_qla_host *vha,\r\nstruct qla8044_minidump_entry_hdr *entry_hdr, uint32_t **d_ptr)\r\n{\r\nuint32_t addr1, addr2, value1, value2, poll, mask, r_value;\r\nuint32_t wait_count = 0;\r\nstruct qla8044_minidump_entry_pollwr *pollwr_hdr;\r\npollwr_hdr = (struct qla8044_minidump_entry_pollwr *)entry_hdr;\r\naddr1 = pollwr_hdr->addr_1;\r\naddr2 = pollwr_hdr->addr_2;\r\nvalue1 = pollwr_hdr->value_1;\r\nvalue2 = pollwr_hdr->value_2;\r\npoll = pollwr_hdr->poll;\r\nmask = pollwr_hdr->mask;\r\nwhile (wait_count < poll) {\r\nqla8044_rd_reg_indirect(vha, addr1, &r_value);\r\nif ((r_value & poll) != 0)\r\nbreak;\r\nwait_count++;\r\n}\r\nif (wait_count == poll) {\r\nql_log(ql_log_warn, vha, 0xb156, "%s: TIMEOUT\n", __func__);\r\ngoto error;\r\n}\r\nqla8044_wr_reg_indirect(vha, addr2, value2);\r\nqla8044_wr_reg_indirect(vha, addr1, value1);\r\nwait_count = 0;\r\nwhile (wait_count < poll) {\r\nqla8044_rd_reg_indirect(vha, addr1, &r_value);\r\nif ((r_value & poll) != 0)\r\nbreak;\r\nwait_count++;\r\n}\r\nreturn QLA_SUCCESS;\r\nerror:\r\nreturn -1;\r\n}\r\nint\r\nqla8044_collect_md_data(struct scsi_qla_host *vha)\r\n{\r\nint num_entry_hdr = 0;\r\nstruct qla8044_minidump_entry_hdr *entry_hdr;\r\nstruct qla8044_minidump_template_hdr *tmplt_hdr;\r\nuint32_t *data_ptr;\r\nuint32_t data_collected = 0, f_capture_mask;\r\nint i, rval = QLA_FUNCTION_FAILED;\r\nuint64_t now;\r\nuint32_t timestamp, idc_control;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!ha->md_dump) {\r\nql_log(ql_log_info, vha, 0xb101,\r\n"%s(%ld) No buffer to dump\n",\r\n__func__, vha->host_no);\r\nreturn rval;\r\n}\r\nif (ha->fw_dumped) {\r\nql_log(ql_log_warn, vha, 0xb10d,\r\n"Firmware has been previously dumped (%p) "\r\n"-- ignoring request.\n", ha->fw_dump);\r\ngoto md_failed;\r\n}\r\nha->fw_dumped = 0;\r\nif (!ha->md_tmplt_hdr || !ha->md_dump) {\r\nql_log(ql_log_warn, vha, 0xb10e,\r\n"Memory not allocated for minidump capture\n");\r\ngoto md_failed;\r\n}\r\nqla8044_idc_lock(ha);\r\nidc_control = qla8044_rd_reg(ha, QLA8044_IDC_DRV_CTRL);\r\nif (idc_control & GRACEFUL_RESET_BIT1) {\r\nql_log(ql_log_warn, vha, 0xb112,\r\n"Forced reset from application, "\r\n"ignore minidump capture\n");\r\nqla8044_wr_reg(ha, QLA8044_IDC_DRV_CTRL,\r\n(idc_control & ~GRACEFUL_RESET_BIT1));\r\nqla8044_idc_unlock(ha);\r\ngoto md_failed;\r\n}\r\nqla8044_idc_unlock(ha);\r\nif (qla82xx_validate_template_chksum(vha)) {\r\nql_log(ql_log_info, vha, 0xb109,\r\n"Template checksum validation error\n");\r\ngoto md_failed;\r\n}\r\ntmplt_hdr = (struct qla8044_minidump_template_hdr *)\r\nha->md_tmplt_hdr;\r\ndata_ptr = (uint32_t *)((uint8_t *)ha->md_dump);\r\nnum_entry_hdr = tmplt_hdr->num_of_entries;\r\nql_dbg(ql_dbg_p3p, vha, 0xb11a,\r\n"Capture Mask obtained: 0x%x\n", tmplt_hdr->capture_debug_level);\r\nf_capture_mask = tmplt_hdr->capture_debug_level & 0xFF;\r\nif ((f_capture_mask & 0x3) != 0x3) {\r\nql_log(ql_log_warn, vha, 0xb10f,\r\n"Minimum required capture mask[0x%x] level not set\n",\r\nf_capture_mask);\r\n}\r\ntmplt_hdr->driver_capture_mask = ql2xmdcapmask;\r\nql_log(ql_log_info, vha, 0xb102,\r\n"[%s]: starting data ptr: %p\n",\r\n__func__, data_ptr);\r\nql_log(ql_log_info, vha, 0xb10b,\r\n"[%s]: no of entry headers in Template: 0x%x\n",\r\n__func__, num_entry_hdr);\r\nql_log(ql_log_info, vha, 0xb10c,\r\n"[%s]: Total_data_size 0x%x, %d obtained\n",\r\n__func__, ha->md_dump_size, ha->md_dump_size);\r\nnow = get_jiffies_64();\r\ntimestamp = (u32)(jiffies_to_msecs(now) / 1000);\r\ntmplt_hdr->driver_timestamp = timestamp;\r\nentry_hdr = (struct qla8044_minidump_entry_hdr *)\r\n(((uint8_t *)ha->md_tmplt_hdr) + tmplt_hdr->first_entry_offset);\r\ntmplt_hdr->saved_state_array[QLA8044_SS_OCM_WNDREG_INDEX] =\r\ntmplt_hdr->ocm_window_reg[ha->portnum];\r\nfor (i = 0; i < num_entry_hdr; i++) {\r\nif (data_collected > ha->md_dump_size) {\r\nql_log(ql_log_info, vha, 0xb103,\r\n"Data collected: [0x%x], "\r\n"Total Dump size: [0x%x]\n",\r\ndata_collected, ha->md_dump_size);\r\nreturn rval;\r\n}\r\nif (!(entry_hdr->d_ctrl.entry_capture_mask &\r\nql2xmdcapmask)) {\r\nentry_hdr->d_ctrl.driver_flags |=\r\nQLA82XX_DBG_SKIPPED_FLAG;\r\ngoto skip_nxt_entry;\r\n}\r\nql_dbg(ql_dbg_p3p, vha, 0xb104,\r\n"Data collected: [0x%x], Dump size left:[0x%x]\n",\r\ndata_collected,\r\n(ha->md_dump_size - data_collected));\r\nswitch (entry_hdr->entry_type) {\r\ncase QLA82XX_RDEND:\r\nqla8044_mark_entry_skipped(vha, entry_hdr, i);\r\nbreak;\r\ncase QLA82XX_CNTRL:\r\nrval = qla8044_minidump_process_control(vha,\r\nentry_hdr);\r\nif (rval != QLA_SUCCESS) {\r\nqla8044_mark_entry_skipped(vha, entry_hdr, i);\r\ngoto md_failed;\r\n}\r\nbreak;\r\ncase QLA82XX_RDCRB:\r\nqla8044_minidump_process_rdcrb(vha,\r\nentry_hdr, &data_ptr);\r\nbreak;\r\ncase QLA82XX_RDMEM:\r\nrval = qla8044_minidump_pex_dma_read(vha,\r\nentry_hdr, &data_ptr);\r\nif (rval != QLA_SUCCESS) {\r\nrval = qla8044_minidump_process_rdmem(vha,\r\nentry_hdr, &data_ptr);\r\nif (rval != QLA_SUCCESS) {\r\nqla8044_mark_entry_skipped(vha,\r\nentry_hdr, i);\r\ngoto md_failed;\r\n}\r\n}\r\nbreak;\r\ncase QLA82XX_BOARD:\r\ncase QLA82XX_RDROM:\r\nrval = qla8044_minidump_process_rdrom(vha,\r\nentry_hdr, &data_ptr);\r\nif (rval != QLA_SUCCESS) {\r\nqla8044_mark_entry_skipped(vha,\r\nentry_hdr, i);\r\n}\r\nbreak;\r\ncase QLA82XX_L2DTG:\r\ncase QLA82XX_L2ITG:\r\ncase QLA82XX_L2DAT:\r\ncase QLA82XX_L2INS:\r\nrval = qla8044_minidump_process_l2tag(vha,\r\nentry_hdr, &data_ptr);\r\nif (rval != QLA_SUCCESS) {\r\nqla8044_mark_entry_skipped(vha, entry_hdr, i);\r\ngoto md_failed;\r\n}\r\nbreak;\r\ncase QLA8044_L1DTG:\r\ncase QLA8044_L1ITG:\r\ncase QLA82XX_L1DAT:\r\ncase QLA82XX_L1INS:\r\nqla8044_minidump_process_l1cache(vha,\r\nentry_hdr, &data_ptr);\r\nbreak;\r\ncase QLA82XX_RDOCM:\r\nqla8044_minidump_process_rdocm(vha,\r\nentry_hdr, &data_ptr);\r\nbreak;\r\ncase QLA82XX_RDMUX:\r\nqla8044_minidump_process_rdmux(vha,\r\nentry_hdr, &data_ptr);\r\nbreak;\r\ncase QLA82XX_QUEUE:\r\nqla8044_minidump_process_queue(vha,\r\nentry_hdr, &data_ptr);\r\nbreak;\r\ncase QLA8044_POLLRD:\r\nrval = qla8044_minidump_process_pollrd(vha,\r\nentry_hdr, &data_ptr);\r\nif (rval != QLA_SUCCESS)\r\nqla8044_mark_entry_skipped(vha, entry_hdr, i);\r\nbreak;\r\ncase QLA8044_RDMUX2:\r\nqla8044_minidump_process_rdmux2(vha,\r\nentry_hdr, &data_ptr);\r\nbreak;\r\ncase QLA8044_POLLRDMWR:\r\nrval = qla8044_minidump_process_pollrdmwr(vha,\r\nentry_hdr, &data_ptr);\r\nif (rval != QLA_SUCCESS)\r\nqla8044_mark_entry_skipped(vha, entry_hdr, i);\r\nbreak;\r\ncase QLA8044_RDDFE:\r\nrval = qla8044_minidump_process_rddfe(vha, entry_hdr,\r\n&data_ptr);\r\nif (rval != QLA_SUCCESS)\r\nqla8044_mark_entry_skipped(vha, entry_hdr, i);\r\nbreak;\r\ncase QLA8044_RDMDIO:\r\nrval = qla8044_minidump_process_rdmdio(vha, entry_hdr,\r\n&data_ptr);\r\nif (rval != QLA_SUCCESS)\r\nqla8044_mark_entry_skipped(vha, entry_hdr, i);\r\nbreak;\r\ncase QLA8044_POLLWR:\r\nrval = qla8044_minidump_process_pollwr(vha, entry_hdr,\r\n&data_ptr);\r\nif (rval != QLA_SUCCESS)\r\nqla8044_mark_entry_skipped(vha, entry_hdr, i);\r\nbreak;\r\ncase QLA82XX_RDNOP:\r\ndefault:\r\nqla8044_mark_entry_skipped(vha, entry_hdr, i);\r\nbreak;\r\n}\r\ndata_collected = (uint8_t *)data_ptr -\r\n(uint8_t *)((uint8_t *)ha->md_dump);\r\nskip_nxt_entry:\r\nentry_hdr = (struct qla8044_minidump_entry_hdr *)\r\n(((uint8_t *)entry_hdr) + entry_hdr->entry_size);\r\n}\r\nif (data_collected != ha->md_dump_size) {\r\nql_log(ql_log_info, vha, 0xb105,\r\n"Dump data mismatch: Data collected: "\r\n"[0x%x], total_data_size:[0x%x]\n",\r\ndata_collected, ha->md_dump_size);\r\nrval = QLA_FUNCTION_FAILED;\r\ngoto md_failed;\r\n}\r\nql_log(ql_log_info, vha, 0xb110,\r\n"Firmware dump saved to temp buffer (%ld/%p %ld/%p).\n",\r\nvha->host_no, ha->md_tmplt_hdr, vha->host_no, ha->md_dump);\r\nha->fw_dumped = 1;\r\nqla2x00_post_uevent_work(vha, QLA_UEVENT_CODE_FW_DUMP);\r\nql_log(ql_log_info, vha, 0xb106,\r\n"Leaving fn: %s Last entry: 0x%x\n",\r\n__func__, i);\r\nmd_failed:\r\nreturn rval;\r\n}\r\nvoid\r\nqla8044_get_minidump(struct scsi_qla_host *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!qla8044_collect_md_data(vha)) {\r\nha->fw_dumped = 1;\r\nha->prev_minidump_failed = 0;\r\n} else {\r\nql_log(ql_log_fatal, vha, 0xb0db,\r\n"%s: Unable to collect minidump\n",\r\n__func__);\r\nha->prev_minidump_failed = 1;\r\n}\r\n}\r\nstatic int\r\nqla8044_poll_flash_status_reg(struct scsi_qla_host *vha)\r\n{\r\nuint32_t flash_status;\r\nint retries = QLA8044_FLASH_READ_RETRY_COUNT;\r\nint ret_val = QLA_SUCCESS;\r\nwhile (retries--) {\r\nret_val = qla8044_rd_reg_indirect(vha, QLA8044_FLASH_STATUS,\r\n&flash_status);\r\nif (ret_val) {\r\nql_log(ql_log_warn, vha, 0xb13c,\r\n"%s: Failed to read FLASH_STATUS reg.\n",\r\n__func__);\r\nbreak;\r\n}\r\nif ((flash_status & QLA8044_FLASH_STATUS_READY) ==\r\nQLA8044_FLASH_STATUS_READY)\r\nbreak;\r\nmsleep(QLA8044_FLASH_STATUS_REG_POLL_DELAY);\r\n}\r\nif (!retries)\r\nret_val = QLA_FUNCTION_FAILED;\r\nreturn ret_val;\r\n}\r\nstatic int\r\nqla8044_write_flash_status_reg(struct scsi_qla_host *vha,\r\nuint32_t data)\r\n{\r\nint ret_val = QLA_SUCCESS;\r\nuint32_t cmd;\r\ncmd = vha->hw->fdt_wrt_sts_reg_cmd;\r\nret_val = qla8044_wr_reg_indirect(vha, QLA8044_FLASH_ADDR,\r\nQLA8044_FLASH_STATUS_WRITE_DEF_SIG | cmd);\r\nif (ret_val) {\r\nql_log(ql_log_warn, vha, 0xb125,\r\n"%s: Failed to write to FLASH_ADDR.\n", __func__);\r\ngoto exit_func;\r\n}\r\nret_val = qla8044_wr_reg_indirect(vha, QLA8044_FLASH_WRDATA, data);\r\nif (ret_val) {\r\nql_log(ql_log_warn, vha, 0xb126,\r\n"%s: Failed to write to FLASH_WRDATA.\n", __func__);\r\ngoto exit_func;\r\n}\r\nret_val = qla8044_wr_reg_indirect(vha, QLA8044_FLASH_CONTROL,\r\nQLA8044_FLASH_SECOND_ERASE_MS_VAL);\r\nif (ret_val) {\r\nql_log(ql_log_warn, vha, 0xb127,\r\n"%s: Failed to write to FLASH_CONTROL.\n", __func__);\r\ngoto exit_func;\r\n}\r\nret_val = qla8044_poll_flash_status_reg(vha);\r\nif (ret_val)\r\nql_log(ql_log_warn, vha, 0xb128,\r\n"%s: Error polling flash status reg.\n", __func__);\r\nexit_func:\r\nreturn ret_val;\r\n}\r\nstatic int\r\nqla8044_unprotect_flash(scsi_qla_host_t *vha)\r\n{\r\nint ret_val;\r\nstruct qla_hw_data *ha = vha->hw;\r\nret_val = qla8044_write_flash_status_reg(vha, ha->fdt_wrt_enable);\r\nif (ret_val)\r\nql_log(ql_log_warn, vha, 0xb139,\r\n"%s: Write flash status failed.\n", __func__);\r\nreturn ret_val;\r\n}\r\nstatic int\r\nqla8044_protect_flash(scsi_qla_host_t *vha)\r\n{\r\nint ret_val;\r\nstruct qla_hw_data *ha = vha->hw;\r\nret_val = qla8044_write_flash_status_reg(vha, ha->fdt_wrt_disable);\r\nif (ret_val)\r\nql_log(ql_log_warn, vha, 0xb13b,\r\n"%s: Write flash status failed.\n", __func__);\r\nreturn ret_val;\r\n}\r\nstatic int\r\nqla8044_erase_flash_sector(struct scsi_qla_host *vha,\r\nuint32_t sector_start_addr)\r\n{\r\nuint32_t reversed_addr;\r\nint ret_val = QLA_SUCCESS;\r\nret_val = qla8044_poll_flash_status_reg(vha);\r\nif (ret_val) {\r\nql_log(ql_log_warn, vha, 0xb12e,\r\n"%s: Poll flash status after erase failed..\n", __func__);\r\n}\r\nreversed_addr = (((sector_start_addr & 0xFF) << 16) |\r\n(sector_start_addr & 0xFF00) |\r\n((sector_start_addr & 0xFF0000) >> 16));\r\nret_val = qla8044_wr_reg_indirect(vha,\r\nQLA8044_FLASH_WRDATA, reversed_addr);\r\nif (ret_val) {\r\nql_log(ql_log_warn, vha, 0xb12f,\r\n"%s: Failed to write to FLASH_WRDATA.\n", __func__);\r\n}\r\nret_val = qla8044_wr_reg_indirect(vha, QLA8044_FLASH_ADDR,\r\nQLA8044_FLASH_ERASE_SIG | vha->hw->fdt_erase_cmd);\r\nif (ret_val) {\r\nql_log(ql_log_warn, vha, 0xb130,\r\n"%s: Failed to write to FLASH_ADDR.\n", __func__);\r\n}\r\nret_val = qla8044_wr_reg_indirect(vha, QLA8044_FLASH_CONTROL,\r\nQLA8044_FLASH_LAST_ERASE_MS_VAL);\r\nif (ret_val) {\r\nql_log(ql_log_warn, vha, 0xb131,\r\n"%s: Failed write to FLASH_CONTROL.\n", __func__);\r\n}\r\nret_val = qla8044_poll_flash_status_reg(vha);\r\nif (ret_val) {\r\nql_log(ql_log_warn, vha, 0xb132,\r\n"%s: Poll flash status failed.\n", __func__);\r\n}\r\nreturn ret_val;\r\n}\r\nstatic int\r\nqla8044_flash_write_u32(struct scsi_qla_host *vha, uint32_t addr,\r\nuint32_t *p_data)\r\n{\r\nint ret_val = QLA_SUCCESS;\r\nret_val = qla8044_wr_reg_indirect(vha, QLA8044_FLASH_ADDR,\r\n0x00800000 | (addr >> 2));\r\nif (ret_val) {\r\nql_log(ql_log_warn, vha, 0xb134,\r\n"%s: Failed write to FLASH_ADDR.\n", __func__);\r\ngoto exit_func;\r\n}\r\nret_val = qla8044_wr_reg_indirect(vha, QLA8044_FLASH_WRDATA, *p_data);\r\nif (ret_val) {\r\nql_log(ql_log_warn, vha, 0xb135,\r\n"%s: Failed write to FLASH_WRDATA.\n", __func__);\r\ngoto exit_func;\r\n}\r\nret_val = qla8044_wr_reg_indirect(vha, QLA8044_FLASH_CONTROL, 0x3D);\r\nif (ret_val) {\r\nql_log(ql_log_warn, vha, 0xb136,\r\n"%s: Failed write to FLASH_CONTROL.\n", __func__);\r\ngoto exit_func;\r\n}\r\nret_val = qla8044_poll_flash_status_reg(vha);\r\nif (ret_val) {\r\nql_log(ql_log_warn, vha, 0xb137,\r\n"%s: Poll flash status failed.\n", __func__);\r\n}\r\nexit_func:\r\nreturn ret_val;\r\n}\r\nstatic int\r\nqla8044_write_flash_buffer_mode(scsi_qla_host_t *vha, uint32_t *dwptr,\r\nuint32_t faddr, uint32_t dwords)\r\n{\r\nint ret = QLA_FUNCTION_FAILED;\r\nuint32_t spi_val;\r\nif (dwords < QLA8044_MIN_OPTROM_BURST_DWORDS ||\r\ndwords > QLA8044_MAX_OPTROM_BURST_DWORDS) {\r\nql_dbg(ql_dbg_user, vha, 0xb123,\r\n"Got unsupported dwords = 0x%x.\n",\r\ndwords);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nqla8044_rd_reg_indirect(vha, QLA8044_FLASH_SPI_CONTROL, &spi_val);\r\nqla8044_wr_reg_indirect(vha, QLA8044_FLASH_SPI_CONTROL,\r\nspi_val | QLA8044_FLASH_SPI_CTL);\r\nqla8044_wr_reg_indirect(vha, QLA8044_FLASH_ADDR,\r\nQLA8044_FLASH_FIRST_TEMP_VAL);\r\nret = qla8044_wr_reg_indirect(vha, QLA8044_FLASH_WRDATA,\r\n*dwptr++);\r\nqla8044_wr_reg_indirect(vha, QLA8044_FLASH_CONTROL,\r\nQLA8044_FLASH_FIRST_MS_PATTERN);\r\nret = qla8044_poll_flash_status_reg(vha);\r\nif (ret) {\r\nql_log(ql_log_warn, vha, 0xb124,\r\n"%s: Failed.\n", __func__);\r\ngoto exit_func;\r\n}\r\ndwords--;\r\nqla8044_wr_reg_indirect(vha, QLA8044_FLASH_ADDR,\r\nQLA8044_FLASH_SECOND_TEMP_VAL);\r\nwhile (dwords != 1) {\r\nqla8044_wr_reg_indirect(vha, QLA8044_FLASH_WRDATA, *dwptr++);\r\nqla8044_wr_reg_indirect(vha, QLA8044_FLASH_CONTROL,\r\nQLA8044_FLASH_SECOND_MS_PATTERN);\r\nret = qla8044_poll_flash_status_reg(vha);\r\nif (ret) {\r\nql_log(ql_log_warn, vha, 0xb129,\r\n"%s: Failed.\n", __func__);\r\ngoto exit_func;\r\n}\r\ndwords--;\r\n}\r\nqla8044_wr_reg_indirect(vha, QLA8044_FLASH_ADDR,\r\nQLA8044_FLASH_FIRST_TEMP_VAL | (faddr >> 2));\r\nqla8044_wr_reg_indirect(vha, QLA8044_FLASH_WRDATA, *dwptr++);\r\nqla8044_wr_reg_indirect(vha, QLA8044_FLASH_CONTROL,\r\nQLA8044_FLASH_LAST_MS_PATTERN);\r\nret = qla8044_poll_flash_status_reg(vha);\r\nif (ret) {\r\nql_log(ql_log_warn, vha, 0xb12a,\r\n"%s: Failed.\n", __func__);\r\ngoto exit_func;\r\n}\r\nqla8044_rd_reg_indirect(vha, QLA8044_FLASH_SPI_STATUS, &spi_val);\r\nif ((spi_val & QLA8044_FLASH_SPI_CTL) == QLA8044_FLASH_SPI_CTL) {\r\nql_log(ql_log_warn, vha, 0xb12b,\r\n"%s: Failed.\n", __func__);\r\nspi_val = 0;\r\nqla8044_rd_reg_indirect(vha, QLA8044_FLASH_SPI_CONTROL,\r\n&spi_val);\r\nqla8044_wr_reg_indirect(vha, QLA8044_FLASH_SPI_CONTROL,\r\nspi_val | QLA8044_FLASH_SPI_CTL);\r\n}\r\nexit_func:\r\nreturn ret;\r\n}\r\nstatic int\r\nqla8044_write_flash_dword_mode(scsi_qla_host_t *vha, uint32_t *dwptr,\r\nuint32_t faddr, uint32_t dwords)\r\n{\r\nint ret = QLA_FUNCTION_FAILED;\r\nuint32_t liter;\r\nfor (liter = 0; liter < dwords; liter++, faddr += 4, dwptr++) {\r\nret = qla8044_flash_write_u32(vha, faddr, dwptr);\r\nif (ret) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb141,\r\n"%s: flash address=%x data=%x.\n", __func__,\r\nfaddr, *dwptr);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint\r\nqla8044_write_optrom_data(struct scsi_qla_host *vha, uint8_t *buf,\r\nuint32_t offset, uint32_t length)\r\n{\r\nint rval = QLA_FUNCTION_FAILED, i, burst_iter_count;\r\nint dword_count, erase_sec_count;\r\nuint32_t erase_offset;\r\nuint8_t *p_cache, *p_src;\r\nerase_offset = offset;\r\np_cache = kcalloc(length, sizeof(uint8_t), GFP_KERNEL);\r\nif (!p_cache)\r\nreturn QLA_FUNCTION_FAILED;\r\nmemcpy(p_cache, buf, length);\r\np_src = p_cache;\r\ndword_count = length / sizeof(uint32_t);\r\nburst_iter_count = dword_count / QLA8044_MAX_OPTROM_BURST_DWORDS;\r\nerase_sec_count = length / QLA8044_SECTOR_SIZE;\r\nscsi_block_requests(vha->host);\r\nqla8044_flash_lock(vha);\r\nqla8044_unprotect_flash(vha);\r\nfor (i = 0; i < erase_sec_count; i++) {\r\nrval = qla8044_erase_flash_sector(vha, erase_offset);\r\nql_dbg(ql_dbg_user, vha, 0xb138,\r\n"Done erase of sector=0x%x.\n",\r\nerase_offset);\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0xb121,\r\n"Failed to erase the sector having address: "\r\n"0x%x.\n", erase_offset);\r\ngoto out;\r\n}\r\nerase_offset += QLA8044_SECTOR_SIZE;\r\n}\r\nql_dbg(ql_dbg_user, vha, 0xb13f,\r\n"Got write for addr = 0x%x length=0x%x.\n",\r\noffset, length);\r\nfor (i = 0; i < burst_iter_count; i++) {\r\nrval = qla8044_write_flash_buffer_mode(vha, (uint32_t *)p_src,\r\noffset, QLA8044_MAX_OPTROM_BURST_DWORDS);\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0xb122,\r\n"Failed to write flash in buffer mode, "\r\n"Reverting to slow-write.\n");\r\nrval = qla8044_write_flash_dword_mode(vha,\r\n(uint32_t *)p_src, offset,\r\nQLA8044_MAX_OPTROM_BURST_DWORDS);\r\n}\r\np_src += sizeof(uint32_t) * QLA8044_MAX_OPTROM_BURST_DWORDS;\r\noffset += sizeof(uint32_t) * QLA8044_MAX_OPTROM_BURST_DWORDS;\r\n}\r\nql_dbg(ql_dbg_user, vha, 0xb133,\r\n"Done writing.\n");\r\nout:\r\nqla8044_protect_flash(vha);\r\nqla8044_flash_unlock(vha);\r\nscsi_unblock_requests(vha->host);\r\nkfree(p_cache);\r\nreturn rval;\r\n}\r\nirqreturn_t\r\nqla8044_intr_handler(int irq, void *dev_id)\r\n{\r\nscsi_qla_host_t *vha;\r\nstruct qla_hw_data *ha;\r\nstruct rsp_que *rsp;\r\nstruct device_reg_82xx __iomem *reg;\r\nint status = 0;\r\nunsigned long flags;\r\nunsigned long iter;\r\nuint32_t stat;\r\nuint16_t mb[4];\r\nuint32_t leg_int_ptr = 0, pf_bit;\r\nrsp = (struct rsp_que *) dev_id;\r\nif (!rsp) {\r\nql_log(ql_log_info, NULL, 0xb143,\r\n"%s(): NULL response queue pointer\n", __func__);\r\nreturn IRQ_NONE;\r\n}\r\nha = rsp->hw;\r\nvha = pci_get_drvdata(ha->pdev);\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\nreturn IRQ_HANDLED;\r\nleg_int_ptr = qla8044_rd_reg(ha, LEG_INTR_PTR_OFFSET);\r\nif (!(leg_int_ptr & (LEG_INT_PTR_B31))) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb144,\r\n"%s: Legacy Interrupt Bit 31 not set, "\r\n"spurious interrupt!\n", __func__);\r\nreturn IRQ_NONE;\r\n}\r\npf_bit = ha->portnum << 16;\r\nif ((leg_int_ptr & (PF_BITS_MASK)) != pf_bit) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb145,\r\n"%s: Incorrect function ID 0x%x in "\r\n"legacy interrupt register, "\r\n"ha->pf_bit = 0x%x\n", __func__,\r\n(leg_int_ptr & (PF_BITS_MASK)), pf_bit);\r\nreturn IRQ_NONE;\r\n}\r\nqla8044_wr_reg(ha, LEG_INTR_TRIG_OFFSET, 0);\r\ndo {\r\nleg_int_ptr = qla8044_rd_reg(ha, LEG_INTR_PTR_OFFSET);\r\nif ((leg_int_ptr & (PF_BITS_MASK)) != pf_bit)\r\nbreak;\r\n} while (leg_int_ptr & (LEG_INT_PTR_B30));\r\nreg = &ha->iobase->isp82;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nfor (iter = 1; iter--; ) {\r\nif (RD_REG_DWORD(&reg->host_int)) {\r\nstat = RD_REG_DWORD(&reg->host_status);\r\nif ((stat & HSRX_RISC_INT) == 0)\r\nbreak;\r\nswitch (stat & 0xff) {\r\ncase 0x1:\r\ncase 0x2:\r\ncase 0x10:\r\ncase 0x11:\r\nqla82xx_mbx_completion(vha, MSW(stat));\r\nstatus |= MBX_INTERRUPT;\r\nbreak;\r\ncase 0x12:\r\nmb[0] = MSW(stat);\r\nmb[1] = RD_REG_WORD(&reg->mailbox_out[1]);\r\nmb[2] = RD_REG_WORD(&reg->mailbox_out[2]);\r\nmb[3] = RD_REG_WORD(&reg->mailbox_out[3]);\r\nqla2x00_async_event(vha, rsp, mb);\r\nbreak;\r\ncase 0x13:\r\nqla24xx_process_response_queue(vha, rsp);\r\nbreak;\r\ndefault:\r\nql_dbg(ql_dbg_p3p, vha, 0xb146,\r\n"Unrecognized interrupt type "\r\n"(%d).\n", stat & 0xff);\r\nbreak;\r\n}\r\n}\r\nWRT_REG_DWORD(&reg->host_int, 0);\r\n}\r\nqla2x00_handle_mbx_completion(ha, status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\nqla8044_idc_dontreset(struct qla_hw_data *ha)\r\n{\r\nuint32_t idc_ctrl;\r\nidc_ctrl = qla8044_rd_reg(ha, QLA8044_IDC_DRV_CTRL);\r\nreturn idc_ctrl & DONTRESET_BIT0;\r\n}\r\nstatic void\r\nqla8044_clear_rst_ready(scsi_qla_host_t *vha)\r\n{\r\nuint32_t drv_state;\r\ndrv_state = qla8044_rd_direct(vha, QLA8044_CRB_DRV_STATE_INDEX);\r\ndrv_state &= ~(1 << vha->hw->portnum);\r\nql_dbg(ql_dbg_p3p, vha, 0xb13d,\r\n"drv_state: 0x%08x\n", drv_state);\r\nqla8044_wr_direct(vha, QLA8044_CRB_DRV_STATE_INDEX, drv_state);\r\n}\r\nint\r\nqla8044_abort_isp(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nuint32_t dev_state;\r\nstruct qla_hw_data *ha = vha->hw;\r\nqla8044_idc_lock(ha);\r\ndev_state = qla8044_rd_direct(vha, QLA8044_CRB_DEV_STATE_INDEX);\r\nif (ql2xdontresethba)\r\nqla8044_set_idc_dontreset(vha);\r\nif (dev_state == QLA8XXX_DEV_READY) {\r\nif (qla8044_idc_dontreset(ha) == DONTRESET_BIT0) {\r\nql_dbg(ql_dbg_p3p, vha, 0xb13e,\r\n"Reset recovery disabled\n");\r\nrval = QLA_FUNCTION_FAILED;\r\ngoto exit_isp_reset;\r\n}\r\nql_dbg(ql_dbg_p3p, vha, 0xb140,\r\n"HW State: NEED RESET\n");\r\nqla8044_wr_direct(vha, QLA8044_CRB_DEV_STATE_INDEX,\r\nQLA8XXX_DEV_NEED_RESET);\r\n}\r\nqla83xx_reset_ownership(vha);\r\nqla8044_idc_unlock(ha);\r\nrval = qla8044_device_state_handler(vha);\r\nqla8044_idc_lock(ha);\r\nqla8044_clear_rst_ready(vha);\r\nexit_isp_reset:\r\nqla8044_idc_unlock(ha);\r\nif (rval == QLA_SUCCESS) {\r\nha->flags.isp82xx_fw_hung = 0;\r\nha->flags.nic_core_reset_hdlr_active = 0;\r\nrval = qla82xx_restart_isp(vha);\r\n}\r\nreturn rval;\r\n}\r\nvoid\r\nqla8044_fw_dump(scsi_qla_host_t *vha, int hardware_locked)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!ha->allow_cna_fw_dump)\r\nreturn;\r\nscsi_block_requests(vha->host);\r\nha->flags.isp82xx_no_md_cap = 1;\r\nqla8044_idc_lock(ha);\r\nqla82xx_set_reset_owner(vha);\r\nqla8044_idc_unlock(ha);\r\nqla2x00_wait_for_chip_reset(vha);\r\nscsi_unblock_requests(vha->host);\r\n}
