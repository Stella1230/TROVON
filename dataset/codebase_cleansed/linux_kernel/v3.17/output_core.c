int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\r\n{\r\nu16 offset = sizeof(struct ipv6hdr);\r\nstruct ipv6_opt_hdr *exthdr =\r\n(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);\r\nunsigned int packet_len = skb_tail_pointer(skb) -\r\nskb_network_header(skb);\r\nint found_rhdr = 0;\r\n*nexthdr = &ipv6_hdr(skb)->nexthdr;\r\nwhile (offset + 1 <= packet_len) {\r\nswitch (**nexthdr) {\r\ncase NEXTHDR_HOP:\r\nbreak;\r\ncase NEXTHDR_ROUTING:\r\nfound_rhdr = 1;\r\nbreak;\r\ncase NEXTHDR_DEST:\r\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\r\nif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\r\nbreak;\r\n#endif\r\nif (found_rhdr)\r\nreturn offset;\r\nbreak;\r\ndefault :\r\nreturn offset;\r\n}\r\noffset += ipv6_optlen(exthdr);\r\n*nexthdr = &exthdr->nexthdr;\r\nexthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\r\noffset);\r\n}\r\nreturn offset;\r\n}\r\nint ip6_dst_hoplimit(struct dst_entry *dst)\r\n{\r\nint hoplimit = dst_metric_raw(dst, RTAX_HOPLIMIT);\r\nif (hoplimit == 0) {\r\nstruct net_device *dev = dst->dev;\r\nstruct inet6_dev *idev;\r\nrcu_read_lock();\r\nidev = __in6_dev_get(dev);\r\nif (idev)\r\nhoplimit = idev->cnf.hop_limit;\r\nelse\r\nhoplimit = dev_net(dev)->ipv6.devconf_all->hop_limit;\r\nrcu_read_unlock();\r\n}\r\nreturn hoplimit;\r\n}\r\nint __ip6_local_out(struct sk_buff *skb)\r\n{\r\nint len;\r\nlen = skb->len - sizeof(struct ipv6hdr);\r\nif (len > IPV6_MAXPLEN)\r\nlen = 0;\r\nipv6_hdr(skb)->payload_len = htons(len);\r\nIP6CB(skb)->nhoff = offsetof(struct ipv6hdr, nexthdr);\r\nreturn nf_hook(NFPROTO_IPV6, NF_INET_LOCAL_OUT, skb, NULL,\r\nskb_dst(skb)->dev, dst_output);\r\n}\r\nint ip6_local_out(struct sk_buff *skb)\r\n{\r\nint err;\r\nerr = __ip6_local_out(skb);\r\nif (likely(err == 1))\r\nerr = dst_output(skb);\r\nreturn err;\r\n}
