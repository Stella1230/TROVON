static int br_pass_frame_up(struct sk_buff *skb)\r\n{\r\nstruct net_device *indev, *brdev = BR_INPUT_SKB_CB(skb)->brdev;\r\nstruct net_bridge *br = netdev_priv(brdev);\r\nstruct pcpu_sw_netstats *brstats = this_cpu_ptr(br->stats);\r\nstruct net_port_vlans *pv;\r\nu64_stats_update_begin(&brstats->syncp);\r\nbrstats->rx_packets++;\r\nbrstats->rx_bytes += skb->len;\r\nu64_stats_update_end(&brstats->syncp);\r\npv = br_get_vlan_info(br);\r\nif (!(brdev->flags & IFF_PROMISC) &&\r\n!br_allowed_egress(br, pv, skb)) {\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nindev = skb->dev;\r\nskb->dev = brdev;\r\nskb = br_handle_vlan(br, pv, skb);\r\nif (!skb)\r\nreturn NET_RX_DROP;\r\nreturn NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, skb, indev, NULL,\r\nnetif_receive_skb);\r\n}\r\nint br_handle_frame_finish(struct sk_buff *skb)\r\n{\r\nconst unsigned char *dest = eth_hdr(skb)->h_dest;\r\nstruct net_bridge_port *p = br_port_get_rcu(skb->dev);\r\nstruct net_bridge *br;\r\nstruct net_bridge_fdb_entry *dst;\r\nstruct net_bridge_mdb_entry *mdst;\r\nstruct sk_buff *skb2;\r\nbool unicast = true;\r\nu16 vid = 0;\r\nif (!p || p->state == BR_STATE_DISABLED)\r\ngoto drop;\r\nif (!br_allowed_ingress(p->br, nbp_get_vlan_info(p), skb, &vid))\r\ngoto out;\r\nbr = p->br;\r\nif (p->flags & BR_LEARNING)\r\nbr_fdb_update(br, p, eth_hdr(skb)->h_source, vid, false);\r\nif (!is_broadcast_ether_addr(dest) && is_multicast_ether_addr(dest) &&\r\nbr_multicast_rcv(br, p, skb, vid))\r\ngoto drop;\r\nif (p->state == BR_STATE_LEARNING)\r\ngoto drop;\r\nBR_INPUT_SKB_CB(skb)->brdev = br->dev;\r\nskb2 = NULL;\r\nif (br->dev->flags & IFF_PROMISC)\r\nskb2 = skb;\r\ndst = NULL;\r\nif (is_broadcast_ether_addr(dest)) {\r\nskb2 = skb;\r\nunicast = false;\r\n} else if (is_multicast_ether_addr(dest)) {\r\nmdst = br_mdb_get(br, skb, vid);\r\nif ((mdst || BR_INPUT_SKB_CB_MROUTERS_ONLY(skb)) &&\r\nbr_multicast_querier_exists(br, eth_hdr(skb))) {\r\nif ((mdst && mdst->mglist) ||\r\nbr_multicast_is_router(br))\r\nskb2 = skb;\r\nbr_multicast_forward(mdst, skb, skb2);\r\nskb = NULL;\r\nif (!skb2)\r\ngoto out;\r\n} else\r\nskb2 = skb;\r\nunicast = false;\r\nbr->dev->stats.multicast++;\r\n} else if ((dst = __br_fdb_get(br, dest, vid)) &&\r\ndst->is_local) {\r\nskb2 = skb;\r\nskb = NULL;\r\n}\r\nif (skb) {\r\nif (dst) {\r\ndst->used = jiffies;\r\nbr_forward(dst->dst, skb, skb2);\r\n} else\r\nbr_flood_forward(br, skb, skb2, unicast);\r\n}\r\nif (skb2)\r\nreturn br_pass_frame_up(skb2);\r\nout:\r\nreturn 0;\r\ndrop:\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nstatic int br_handle_local_finish(struct sk_buff *skb)\r\n{\r\nstruct net_bridge_port *p = br_port_get_rcu(skb->dev);\r\nu16 vid = 0;\r\nif (p->flags & BR_LEARNING && br_should_learn(p, skb, &vid))\r\nbr_fdb_update(p->br, p, eth_hdr(skb)->h_source, vid, false);\r\nreturn 0;\r\n}\r\nrx_handler_result_t br_handle_frame(struct sk_buff **pskb)\r\n{\r\nstruct net_bridge_port *p;\r\nstruct sk_buff *skb = *pskb;\r\nconst unsigned char *dest = eth_hdr(skb)->h_dest;\r\nbr_should_route_hook_t *rhook;\r\nif (unlikely(skb->pkt_type == PACKET_LOOPBACK))\r\nreturn RX_HANDLER_PASS;\r\nif (!is_valid_ether_addr(eth_hdr(skb)->h_source))\r\ngoto drop;\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (!skb)\r\nreturn RX_HANDLER_CONSUMED;\r\np = br_port_get_rcu(skb->dev);\r\nif (unlikely(is_link_local_ether_addr(dest))) {\r\nu16 fwd_mask = p->br->group_fwd_mask_required;\r\nswitch (dest[5]) {\r\ncase 0x00:\r\nif (p->br->stp_enabled == BR_NO_STP ||\r\nfwd_mask & (1u << dest[5]))\r\ngoto forward;\r\nbreak;\r\ncase 0x01:\r\ngoto drop;\r\ndefault:\r\nfwd_mask |= p->br->group_fwd_mask;\r\nif (fwd_mask & (1u << dest[5]))\r\ngoto forward;\r\n}\r\nif (NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, skb, skb->dev,\r\nNULL, br_handle_local_finish)) {\r\nreturn RX_HANDLER_CONSUMED;\r\n} else {\r\n*pskb = skb;\r\nreturn RX_HANDLER_PASS;\r\n}\r\n}\r\nforward:\r\nswitch (p->state) {\r\ncase BR_STATE_FORWARDING:\r\nrhook = rcu_dereference(br_should_route_hook);\r\nif (rhook) {\r\nif ((*rhook)(skb)) {\r\n*pskb = skb;\r\nreturn RX_HANDLER_PASS;\r\n}\r\ndest = eth_hdr(skb)->h_dest;\r\n}\r\ncase BR_STATE_LEARNING:\r\nif (ether_addr_equal(p->br->dev->dev_addr, dest))\r\nskb->pkt_type = PACKET_HOST;\r\nNF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING, skb, skb->dev, NULL,\r\nbr_handle_frame_finish);\r\nbreak;\r\ndefault:\r\ndrop:\r\nkfree_skb(skb);\r\n}\r\nreturn RX_HANDLER_CONSUMED;\r\n}
