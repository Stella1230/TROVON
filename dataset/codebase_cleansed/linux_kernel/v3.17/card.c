static const struct pnp_card_device_id *match_card(struct pnp_card_driver *drv,\r\nstruct pnp_card *card)\r\n{\r\nconst struct pnp_card_device_id *drv_id = drv->id_table;\r\nwhile (*drv_id->id) {\r\nif (compare_pnp_id(card->id, drv_id->id)) {\r\nint i = 0;\r\nfor (;;) {\r\nint found;\r\nstruct pnp_dev *dev;\r\nif (i == PNP_MAX_DEVICES ||\r\n!*drv_id->devs[i].id)\r\nreturn drv_id;\r\nfound = 0;\r\ncard_for_each_dev(card, dev) {\r\nif (compare_pnp_id(dev->id,\r\ndrv_id->devs[i].id)) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found)\r\nbreak;\r\ni++;\r\n}\r\n}\r\ndrv_id++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void card_remove(struct pnp_dev *dev)\r\n{\r\ndev->card_link = NULL;\r\n}\r\nstatic void card_remove_first(struct pnp_dev *dev)\r\n{\r\nstruct pnp_card_driver *drv = to_pnp_card_driver(dev->driver);\r\nif (!dev->card || !drv)\r\nreturn;\r\nif (drv->remove)\r\ndrv->remove(dev->card_link);\r\ndrv->link.remove = &card_remove;\r\nkfree(dev->card_link);\r\ncard_remove(dev);\r\n}\r\nstatic int card_probe(struct pnp_card *card, struct pnp_card_driver *drv)\r\n{\r\nconst struct pnp_card_device_id *id;\r\nstruct pnp_card_link *clink;\r\nstruct pnp_dev *dev;\r\nif (!drv->probe)\r\nreturn 0;\r\nid = match_card(drv, card);\r\nif (!id)\r\nreturn 0;\r\nclink = pnp_alloc(sizeof(*clink));\r\nif (!clink)\r\nreturn 0;\r\nclink->card = card;\r\nclink->driver = drv;\r\nclink->pm_state = PMSG_ON;\r\nif (drv->probe(clink, id) >= 0)\r\nreturn 1;\r\ncard_for_each_dev(card, dev) {\r\nif (dev->card_link == clink)\r\npnp_release_card_device(dev);\r\n}\r\nkfree(clink);\r\nreturn 0;\r\n}\r\nstatic struct pnp_id *pnp_add_card_id(struct pnp_card *card, char *id)\r\n{\r\nstruct pnp_id *dev_id, *ptr;\r\ndev_id = kzalloc(sizeof(struct pnp_id), GFP_KERNEL);\r\nif (!dev_id)\r\nreturn NULL;\r\ndev_id->id[0] = id[0];\r\ndev_id->id[1] = id[1];\r\ndev_id->id[2] = id[2];\r\ndev_id->id[3] = tolower(id[3]);\r\ndev_id->id[4] = tolower(id[4]);\r\ndev_id->id[5] = tolower(id[5]);\r\ndev_id->id[6] = tolower(id[6]);\r\ndev_id->id[7] = '\0';\r\ndev_id->next = NULL;\r\nptr = card->id;\r\nwhile (ptr && ptr->next)\r\nptr = ptr->next;\r\nif (ptr)\r\nptr->next = dev_id;\r\nelse\r\ncard->id = dev_id;\r\nreturn dev_id;\r\n}\r\nstatic void pnp_free_card_ids(struct pnp_card *card)\r\n{\r\nstruct pnp_id *id;\r\nstruct pnp_id *next;\r\nid = card->id;\r\nwhile (id) {\r\nnext = id->next;\r\nkfree(id);\r\nid = next;\r\n}\r\n}\r\nstatic void pnp_release_card(struct device *dmdev)\r\n{\r\nstruct pnp_card *card = to_pnp_card(dmdev);\r\npnp_free_card_ids(card);\r\nkfree(card);\r\n}\r\nstruct pnp_card *pnp_alloc_card(struct pnp_protocol *protocol, int id, char *pnpid)\r\n{\r\nstruct pnp_card *card;\r\nstruct pnp_id *dev_id;\r\ncard = kzalloc(sizeof(struct pnp_card), GFP_KERNEL);\r\nif (!card)\r\nreturn NULL;\r\ncard->protocol = protocol;\r\ncard->number = id;\r\ncard->dev.parent = &card->protocol->dev;\r\ndev_set_name(&card->dev, "%02x:%02x", card->protocol->number, card->number);\r\ncard->dev.coherent_dma_mask = DMA_BIT_MASK(24);\r\ncard->dev.dma_mask = &card->dev.coherent_dma_mask;\r\ndev_id = pnp_add_card_id(card, pnpid);\r\nif (!dev_id) {\r\nkfree(card);\r\nreturn NULL;\r\n}\r\nreturn card;\r\n}\r\nstatic ssize_t pnp_show_card_name(struct device *dmdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nchar *str = buf;\r\nstruct pnp_card *card = to_pnp_card(dmdev);\r\nstr += sprintf(str, "%s\n", card->name);\r\nreturn (str - buf);\r\n}\r\nstatic ssize_t pnp_show_card_ids(struct device *dmdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nchar *str = buf;\r\nstruct pnp_card *card = to_pnp_card(dmdev);\r\nstruct pnp_id *pos = card->id;\r\nwhile (pos) {\r\nstr += sprintf(str, "%s\n", pos->id);\r\npos = pos->next;\r\n}\r\nreturn (str - buf);\r\n}\r\nstatic int pnp_interface_attach_card(struct pnp_card *card)\r\n{\r\nint rc = device_create_file(&card->dev, &dev_attr_name);\r\nif (rc)\r\nreturn rc;\r\nrc = device_create_file(&card->dev, &dev_attr_card_id);\r\nif (rc)\r\ngoto err_name;\r\nreturn 0;\r\nerr_name:\r\ndevice_remove_file(&card->dev, &dev_attr_name);\r\nreturn rc;\r\n}\r\nint pnp_add_card(struct pnp_card *card)\r\n{\r\nint error;\r\nstruct list_head *pos, *temp;\r\ncard->dev.bus = NULL;\r\ncard->dev.release = &pnp_release_card;\r\nerror = device_register(&card->dev);\r\nif (error) {\r\ndev_err(&card->dev, "could not register (err=%d)\n", error);\r\nput_device(&card->dev);\r\nreturn error;\r\n}\r\npnp_interface_attach_card(card);\r\nspin_lock(&pnp_lock);\r\nlist_add_tail(&card->global_list, &pnp_cards);\r\nlist_add_tail(&card->protocol_list, &card->protocol->cards);\r\nspin_unlock(&pnp_lock);\r\nlist_for_each(pos, &card->devices) {\r\nstruct pnp_dev *dev = card_to_pnp_dev(pos);\r\n__pnp_add_device(dev);\r\n}\r\nlist_for_each_safe(pos, temp, &pnp_card_drivers) {\r\nstruct pnp_card_driver *drv =\r\nlist_entry(pos, struct pnp_card_driver,\r\nglobal_list);\r\ncard_probe(card, drv);\r\n}\r\nreturn 0;\r\n}\r\nvoid pnp_remove_card(struct pnp_card *card)\r\n{\r\nstruct list_head *pos, *temp;\r\ndevice_unregister(&card->dev);\r\nspin_lock(&pnp_lock);\r\nlist_del(&card->global_list);\r\nlist_del(&card->protocol_list);\r\nspin_unlock(&pnp_lock);\r\nlist_for_each_safe(pos, temp, &card->devices) {\r\nstruct pnp_dev *dev = card_to_pnp_dev(pos);\r\npnp_remove_card_device(dev);\r\n}\r\n}\r\nint pnp_add_card_device(struct pnp_card *card, struct pnp_dev *dev)\r\n{\r\ndev->dev.parent = &card->dev;\r\ndev->card_link = NULL;\r\ndev_set_name(&dev->dev, "%02x:%02x.%02x",\r\ndev->protocol->number, card->number, dev->number);\r\nspin_lock(&pnp_lock);\r\ndev->card = card;\r\nlist_add_tail(&dev->card_list, &card->devices);\r\nspin_unlock(&pnp_lock);\r\nreturn 0;\r\n}\r\nvoid pnp_remove_card_device(struct pnp_dev *dev)\r\n{\r\nspin_lock(&pnp_lock);\r\ndev->card = NULL;\r\nlist_del(&dev->card_list);\r\nspin_unlock(&pnp_lock);\r\n__pnp_remove_device(dev);\r\n}\r\nstruct pnp_dev *pnp_request_card_device(struct pnp_card_link *clink,\r\nconst char *id, struct pnp_dev *from)\r\n{\r\nstruct list_head *pos;\r\nstruct pnp_dev *dev;\r\nstruct pnp_card_driver *drv;\r\nstruct pnp_card *card;\r\nif (!clink || !id)\r\nreturn NULL;\r\ncard = clink->card;\r\ndrv = clink->driver;\r\nif (!from) {\r\npos = card->devices.next;\r\n} else {\r\nif (from->card != card)\r\nreturn NULL;\r\npos = from->card_list.next;\r\n}\r\nwhile (pos != &card->devices) {\r\ndev = card_to_pnp_dev(pos);\r\nif ((!dev->card_link) && compare_pnp_id(dev->id, id))\r\ngoto found;\r\npos = pos->next;\r\n}\r\nreturn NULL;\r\nfound:\r\ndev->card_link = clink;\r\ndev->dev.driver = &drv->link.driver;\r\nif (pnp_bus_type.probe(&dev->dev))\r\ngoto err_out;\r\nif (device_bind_driver(&dev->dev))\r\ngoto err_out;\r\nreturn dev;\r\nerr_out:\r\ndev->dev.driver = NULL;\r\ndev->card_link = NULL;\r\nreturn NULL;\r\n}\r\nvoid pnp_release_card_device(struct pnp_dev *dev)\r\n{\r\nstruct pnp_card_driver *drv = dev->card_link->driver;\r\ndrv->link.remove = &card_remove;\r\ndevice_release_driver(&dev->dev);\r\ndrv->link.remove = &card_remove_first;\r\n}\r\nstatic int card_suspend(struct pnp_dev *dev, pm_message_t state)\r\n{\r\nstruct pnp_card_link *link = dev->card_link;\r\nif (link->pm_state.event == state.event)\r\nreturn 0;\r\nlink->pm_state = state;\r\nreturn link->driver->suspend(link, state);\r\n}\r\nstatic int card_resume(struct pnp_dev *dev)\r\n{\r\nstruct pnp_card_link *link = dev->card_link;\r\nif (link->pm_state.event == PM_EVENT_ON)\r\nreturn 0;\r\nlink->pm_state = PMSG_ON;\r\nlink->driver->resume(link);\r\nreturn 0;\r\n}\r\nint pnp_register_card_driver(struct pnp_card_driver *drv)\r\n{\r\nint error;\r\nstruct list_head *pos, *temp;\r\ndrv->link.name = drv->name;\r\ndrv->link.id_table = NULL;\r\ndrv->link.flags = drv->flags;\r\ndrv->link.probe = NULL;\r\ndrv->link.remove = &card_remove_first;\r\ndrv->link.suspend = drv->suspend ? card_suspend : NULL;\r\ndrv->link.resume = drv->resume ? card_resume : NULL;\r\nerror = pnp_register_driver(&drv->link);\r\nif (error < 0)\r\nreturn error;\r\nspin_lock(&pnp_lock);\r\nlist_add_tail(&drv->global_list, &pnp_card_drivers);\r\nspin_unlock(&pnp_lock);\r\nlist_for_each_safe(pos, temp, &pnp_cards) {\r\nstruct pnp_card *card =\r\nlist_entry(pos, struct pnp_card, global_list);\r\ncard_probe(card, drv);\r\n}\r\nreturn 0;\r\n}\r\nvoid pnp_unregister_card_driver(struct pnp_card_driver *drv)\r\n{\r\nspin_lock(&pnp_lock);\r\nlist_del(&drv->global_list);\r\nspin_unlock(&pnp_lock);\r\npnp_unregister_driver(&drv->link);\r\n}
