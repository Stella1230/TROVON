static const char *mei_cl_conn_status_str(enum mei_cl_connect_status status)\r\n{\r\n#define MEI_CL_CS(status) case MEI_CL_CONN_##status: return #status\r\nswitch (status) {\r\nMEI_CL_CS(SUCCESS);\r\nMEI_CL_CS(NOT_FOUND);\r\nMEI_CL_CS(ALREADY_STARTED);\r\nMEI_CL_CS(OUT_OF_RESOURCES);\r\nMEI_CL_CS(MESSAGE_SMALL);\r\ndefault: return "unknown";\r\n}\r\n#undef MEI_CL_CCS\r\n}\r\nstatic int mei_cl_conn_status_to_errno(enum mei_cl_connect_status status)\r\n{\r\nswitch (status) {\r\ncase MEI_CL_CONN_SUCCESS: return 0;\r\ncase MEI_CL_CONN_NOT_FOUND: return -ENOTTY;\r\ncase MEI_CL_CONN_ALREADY_STARTED: return -EBUSY;\r\ncase MEI_CL_CONN_OUT_OF_RESOURCES: return -EBUSY;\r\ncase MEI_CL_CONN_MESSAGE_SMALL: return -EINVAL;\r\ndefault: return -EINVAL;\r\n}\r\n}\r\nvoid mei_hbm_idle(struct mei_device *dev)\r\n{\r\ndev->init_clients_timer = 0;\r\ndev->hbm_state = MEI_HBM_IDLE;\r\n}\r\nvoid mei_hbm_reset(struct mei_device *dev)\r\n{\r\ndev->me_clients_num = 0;\r\ndev->me_client_presentation_num = 0;\r\ndev->me_client_index = 0;\r\nkfree(dev->me_clients);\r\ndev->me_clients = NULL;\r\nmei_hbm_idle(dev);\r\n}\r\nstatic int mei_hbm_me_cl_allocate(struct mei_device *dev)\r\n{\r\nstruct mei_me_client *clients;\r\nint b;\r\nmei_hbm_reset(dev);\r\nfor_each_set_bit(b, dev->me_clients_map, MEI_CLIENTS_MAX)\r\ndev->me_clients_num++;\r\nif (dev->me_clients_num == 0)\r\nreturn 0;\r\ndev_dbg(&dev->pdev->dev, "memory allocation for ME clients size=%ld.\n",\r\ndev->me_clients_num * sizeof(struct mei_me_client));\r\nclients = kcalloc(dev->me_clients_num,\r\nsizeof(struct mei_me_client), GFP_KERNEL);\r\nif (!clients) {\r\ndev_err(&dev->pdev->dev, "memory allocation for ME clients failed.\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->me_clients = clients;\r\nreturn 0;\r\n}\r\nstatic inline\r\nvoid mei_hbm_cl_hdr(struct mei_cl *cl, u8 hbm_cmd, void *buf, size_t len)\r\n{\r\nstruct mei_hbm_cl_cmd *cmd = buf;\r\nmemset(cmd, 0, len);\r\ncmd->hbm_cmd = hbm_cmd;\r\ncmd->host_addr = cl->host_client_id;\r\ncmd->me_addr = cl->me_client_id;\r\n}\r\nstatic inline\r\nbool mei_hbm_cl_addr_equal(struct mei_cl *cl, void *buf)\r\n{\r\nstruct mei_hbm_cl_cmd *cmd = buf;\r\nreturn cl->host_client_id == cmd->host_addr &&\r\ncl->me_client_id == cmd->me_addr;\r\n}\r\nint mei_hbm_start_wait(struct mei_device *dev)\r\n{\r\nint ret;\r\nif (dev->hbm_state > MEI_HBM_START)\r\nreturn 0;\r\nmutex_unlock(&dev->device_lock);\r\nret = wait_event_interruptible_timeout(dev->wait_recvd_msg,\r\ndev->hbm_state == MEI_HBM_IDLE ||\r\ndev->hbm_state >= MEI_HBM_STARTED,\r\nmei_secs_to_jiffies(MEI_HBM_TIMEOUT));\r\nmutex_lock(&dev->device_lock);\r\nif (ret <= 0 && (dev->hbm_state <= MEI_HBM_START)) {\r\ndev->hbm_state = MEI_HBM_IDLE;\r\ndev_err(&dev->pdev->dev, "waiting for mei start failed\n");\r\nreturn -ETIME;\r\n}\r\nreturn 0;\r\n}\r\nint mei_hbm_start_req(struct mei_device *dev)\r\n{\r\nstruct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;\r\nstruct hbm_host_version_request *start_req;\r\nconst size_t len = sizeof(struct hbm_host_version_request);\r\nint ret;\r\nmei_hbm_hdr(mei_hdr, len);\r\nstart_req = (struct hbm_host_version_request *)dev->wr_msg.data;\r\nmemset(start_req, 0, len);\r\nstart_req->hbm_cmd = HOST_START_REQ_CMD;\r\nstart_req->host_version.major_version = HBM_MAJOR_VERSION;\r\nstart_req->host_version.minor_version = HBM_MINOR_VERSION;\r\ndev->hbm_state = MEI_HBM_IDLE;\r\nret = mei_write_message(dev, mei_hdr, dev->wr_msg.data);\r\nif (ret) {\r\ndev_err(&dev->pdev->dev, "version message write failed: ret = %d\n",\r\nret);\r\nreturn ret;\r\n}\r\ndev->hbm_state = MEI_HBM_START;\r\ndev->init_clients_timer = MEI_CLIENTS_INIT_TIMEOUT;\r\nreturn 0;\r\n}\r\nstatic int mei_hbm_enum_clients_req(struct mei_device *dev)\r\n{\r\nstruct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;\r\nstruct hbm_host_enum_request *enum_req;\r\nconst size_t len = sizeof(struct hbm_host_enum_request);\r\nint ret;\r\nmei_hbm_hdr(mei_hdr, len);\r\nenum_req = (struct hbm_host_enum_request *)dev->wr_msg.data;\r\nmemset(enum_req, 0, len);\r\nenum_req->hbm_cmd = HOST_ENUM_REQ_CMD;\r\nret = mei_write_message(dev, mei_hdr, dev->wr_msg.data);\r\nif (ret) {\r\ndev_err(&dev->pdev->dev, "enumeration request write failed: ret = %d.\n",\r\nret);\r\nreturn ret;\r\n}\r\ndev->hbm_state = MEI_HBM_ENUM_CLIENTS;\r\ndev->init_clients_timer = MEI_CLIENTS_INIT_TIMEOUT;\r\nreturn 0;\r\n}\r\nstatic int mei_hbm_prop_req(struct mei_device *dev)\r\n{\r\nstruct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;\r\nstruct hbm_props_request *prop_req;\r\nconst size_t len = sizeof(struct hbm_props_request);\r\nunsigned long next_client_index;\r\nunsigned long client_num;\r\nint ret;\r\nclient_num = dev->me_client_presentation_num;\r\nnext_client_index = find_next_bit(dev->me_clients_map, MEI_CLIENTS_MAX,\r\ndev->me_client_index);\r\nif (next_client_index == MEI_CLIENTS_MAX) {\r\ndev->hbm_state = MEI_HBM_STARTED;\r\nschedule_work(&dev->init_work);\r\nreturn 0;\r\n}\r\ndev->me_clients[client_num].client_id = next_client_index;\r\ndev->me_clients[client_num].mei_flow_ctrl_creds = 0;\r\nmei_hbm_hdr(mei_hdr, len);\r\nprop_req = (struct hbm_props_request *)dev->wr_msg.data;\r\nmemset(prop_req, 0, sizeof(struct hbm_props_request));\r\nprop_req->hbm_cmd = HOST_CLIENT_PROPERTIES_REQ_CMD;\r\nprop_req->address = next_client_index;\r\nret = mei_write_message(dev, mei_hdr, dev->wr_msg.data);\r\nif (ret) {\r\ndev_err(&dev->pdev->dev, "properties request write failed: ret = %d\n",\r\nret);\r\nreturn ret;\r\n}\r\ndev->init_clients_timer = MEI_CLIENTS_INIT_TIMEOUT;\r\ndev->me_client_index = next_client_index;\r\nreturn 0;\r\n}\r\nint mei_hbm_pg(struct mei_device *dev, u8 pg_cmd)\r\n{\r\nstruct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;\r\nstruct hbm_power_gate *req;\r\nconst size_t len = sizeof(struct hbm_power_gate);\r\nint ret;\r\nmei_hbm_hdr(mei_hdr, len);\r\nreq = (struct hbm_power_gate *)dev->wr_msg.data;\r\nmemset(req, 0, len);\r\nreq->hbm_cmd = pg_cmd;\r\nret = mei_write_message(dev, mei_hdr, dev->wr_msg.data);\r\nif (ret)\r\ndev_err(&dev->pdev->dev, "power gate command write failed.\n");\r\nreturn ret;\r\n}\r\nstatic int mei_hbm_stop_req(struct mei_device *dev)\r\n{\r\nstruct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;\r\nstruct hbm_host_stop_request *req =\r\n(struct hbm_host_stop_request *)dev->wr_msg.data;\r\nconst size_t len = sizeof(struct hbm_host_stop_request);\r\nmei_hbm_hdr(mei_hdr, len);\r\nmemset(req, 0, len);\r\nreq->hbm_cmd = HOST_STOP_REQ_CMD;\r\nreq->reason = DRIVER_STOP_REQUEST;\r\nreturn mei_write_message(dev, mei_hdr, dev->wr_msg.data);\r\n}\r\nint mei_hbm_cl_flow_control_req(struct mei_device *dev, struct mei_cl *cl)\r\n{\r\nstruct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;\r\nconst size_t len = sizeof(struct hbm_flow_control);\r\nmei_hbm_hdr(mei_hdr, len);\r\nmei_hbm_cl_hdr(cl, MEI_FLOW_CONTROL_CMD, dev->wr_msg.data, len);\r\ncl_dbg(dev, cl, "sending flow control\n");\r\nreturn mei_write_message(dev, mei_hdr, dev->wr_msg.data);\r\n}\r\nstatic int mei_hbm_add_single_flow_creds(struct mei_device *dev,\r\nstruct hbm_flow_control *flow)\r\n{\r\nstruct mei_me_client *me_cl;\r\nint id;\r\nid = mei_me_cl_by_id(dev, flow->me_addr);\r\nif (id < 0) {\r\ndev_err(&dev->pdev->dev, "no such me client %d\n",\r\nflow->me_addr);\r\nreturn id;\r\n}\r\nme_cl = &dev->me_clients[id];\r\nif (me_cl->props.single_recv_buf) {\r\nme_cl->mei_flow_ctrl_creds++;\r\ndev_dbg(&dev->pdev->dev, "recv flow ctrl msg ME %d (single).\n",\r\nflow->me_addr);\r\ndev_dbg(&dev->pdev->dev, "flow control credentials =%d.\n",\r\nme_cl->mei_flow_ctrl_creds);\r\n} else {\r\nBUG();\r\n}\r\nreturn 0;\r\n}\r\nstatic void mei_hbm_cl_flow_control_res(struct mei_device *dev,\r\nstruct hbm_flow_control *flow_control)\r\n{\r\nstruct mei_cl *cl;\r\nif (!flow_control->host_addr) {\r\nmei_hbm_add_single_flow_creds(dev, flow_control);\r\nreturn;\r\n}\r\nlist_for_each_entry(cl, &dev->file_list, link) {\r\nif (mei_hbm_cl_addr_equal(cl, flow_control)) {\r\ncl->mei_flow_ctrl_creds++;\r\ndev_dbg(&dev->pdev->dev, "flow ctrl msg for host %d ME %d.\n",\r\nflow_control->host_addr, flow_control->me_addr);\r\ndev_dbg(&dev->pdev->dev, "flow control credentials = %d.\n",\r\ncl->mei_flow_ctrl_creds);\r\nbreak;\r\n}\r\n}\r\n}\r\nint mei_hbm_cl_disconnect_req(struct mei_device *dev, struct mei_cl *cl)\r\n{\r\nstruct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;\r\nconst size_t len = sizeof(struct hbm_client_connect_request);\r\nmei_hbm_hdr(mei_hdr, len);\r\nmei_hbm_cl_hdr(cl, CLIENT_DISCONNECT_REQ_CMD, dev->wr_msg.data, len);\r\nreturn mei_write_message(dev, mei_hdr, dev->wr_msg.data);\r\n}\r\nint mei_hbm_cl_disconnect_rsp(struct mei_device *dev, struct mei_cl *cl)\r\n{\r\nstruct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;\r\nconst size_t len = sizeof(struct hbm_client_connect_response);\r\nmei_hbm_hdr(mei_hdr, len);\r\nmei_hbm_cl_hdr(cl, CLIENT_DISCONNECT_RES_CMD, dev->wr_msg.data, len);\r\nreturn mei_write_message(dev, mei_hdr, dev->wr_msg.data);\r\n}\r\nstatic void mei_hbm_cl_disconnect_res(struct mei_device *dev,\r\nstruct hbm_client_connect_response *rs)\r\n{\r\nstruct mei_cl *cl;\r\nstruct mei_cl_cb *cb, *next;\r\ndev_dbg(&dev->pdev->dev, "hbm: disconnect response cl:host=%02d me=%02d status=%d\n",\r\nrs->me_addr, rs->host_addr, rs->status);\r\nlist_for_each_entry_safe(cb, next, &dev->ctrl_rd_list.list, list) {\r\ncl = cb->cl;\r\nif (WARN_ON(!cl)) {\r\nlist_del(&cb->list);\r\nreturn;\r\n}\r\nif (mei_hbm_cl_addr_equal(cl, rs)) {\r\nlist_del(&cb->list);\r\nif (rs->status == MEI_CL_DISCONN_SUCCESS)\r\ncl->state = MEI_FILE_DISCONNECTED;\r\ncl->status = 0;\r\ncl->timer_count = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nint mei_hbm_cl_connect_req(struct mei_device *dev, struct mei_cl *cl)\r\n{\r\nstruct mei_msg_hdr *mei_hdr = &dev->wr_msg.hdr;\r\nconst size_t len = sizeof(struct hbm_client_connect_request);\r\nmei_hbm_hdr(mei_hdr, len);\r\nmei_hbm_cl_hdr(cl, CLIENT_CONNECT_REQ_CMD, dev->wr_msg.data, len);\r\nreturn mei_write_message(dev, mei_hdr, dev->wr_msg.data);\r\n}\r\nstatic void mei_hbm_cl_connect_res(struct mei_device *dev,\r\nstruct hbm_client_connect_response *rs)\r\n{\r\nstruct mei_cl *cl;\r\nstruct mei_cl_cb *cb, *next;\r\ndev_dbg(&dev->pdev->dev, "hbm: connect response cl:host=%02d me=%02d status=%s\n",\r\nrs->me_addr, rs->host_addr,\r\nmei_cl_conn_status_str(rs->status));\r\ncl = NULL;\r\nlist_for_each_entry_safe(cb, next, &dev->ctrl_rd_list.list, list) {\r\ncl = cb->cl;\r\nif (WARN_ON(!cl)) {\r\nlist_del_init(&cb->list);\r\ncontinue;\r\n}\r\nif (cb->fop_type != MEI_FOP_CONNECT)\r\ncontinue;\r\nif (mei_hbm_cl_addr_equal(cl, rs)) {\r\nlist_del(&cb->list);\r\nbreak;\r\n}\r\n}\r\nif (!cl)\r\nreturn;\r\ncl->timer_count = 0;\r\nif (rs->status == MEI_CL_CONN_SUCCESS)\r\ncl->state = MEI_FILE_CONNECTED;\r\nelse\r\ncl->state = MEI_FILE_DISCONNECTED;\r\ncl->status = mei_cl_conn_status_to_errno(rs->status);\r\n}\r\nstatic int mei_hbm_fw_disconnect_req(struct mei_device *dev,\r\nstruct hbm_client_connect_request *disconnect_req)\r\n{\r\nstruct mei_cl *cl;\r\nstruct mei_cl_cb *cb;\r\nlist_for_each_entry(cl, &dev->file_list, link) {\r\nif (mei_hbm_cl_addr_equal(cl, disconnect_req)) {\r\ndev_dbg(&dev->pdev->dev, "disconnect request host client %d ME client %d.\n",\r\ndisconnect_req->host_addr,\r\ndisconnect_req->me_addr);\r\ncl->state = MEI_FILE_DISCONNECTED;\r\ncl->timer_count = 0;\r\ncb = mei_io_cb_init(cl, NULL);\r\nif (!cb)\r\nreturn -ENOMEM;\r\ncb->fop_type = MEI_FOP_DISCONNECT_RSP;\r\ncl_dbg(dev, cl, "add disconnect response as first\n");\r\nlist_add(&cb->list, &dev->ctrl_wr_list.list);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nbool mei_hbm_version_is_supported(struct mei_device *dev)\r\n{\r\nreturn (dev->version.major_version < HBM_MAJOR_VERSION) ||\r\n(dev->version.major_version == HBM_MAJOR_VERSION &&\r\ndev->version.minor_version <= HBM_MINOR_VERSION);\r\n}\r\nint mei_hbm_dispatch(struct mei_device *dev, struct mei_msg_hdr *hdr)\r\n{\r\nstruct mei_bus_message *mei_msg;\r\nstruct mei_me_client *me_client;\r\nstruct hbm_host_version_response *version_res;\r\nstruct hbm_client_connect_response *connect_res;\r\nstruct hbm_client_connect_response *disconnect_res;\r\nstruct hbm_client_connect_request *disconnect_req;\r\nstruct hbm_flow_control *flow_control;\r\nstruct hbm_props_response *props_res;\r\nstruct hbm_host_enum_response *enum_res;\r\nBUG_ON(hdr->length >= sizeof(dev->rd_msg_buf));\r\nmei_read_slots(dev, dev->rd_msg_buf, hdr->length);\r\nmei_msg = (struct mei_bus_message *)dev->rd_msg_buf;\r\nif (dev->hbm_state == MEI_HBM_IDLE) {\r\ndev_dbg(&dev->pdev->dev, "hbm: state is idle ignore spurious messages\n");\r\nreturn 0;\r\n}\r\nswitch (mei_msg->hbm_cmd) {\r\ncase HOST_START_RES_CMD:\r\ndev_dbg(&dev->pdev->dev, "hbm: start: response message received.\n");\r\ndev->init_clients_timer = 0;\r\nversion_res = (struct hbm_host_version_response *)mei_msg;\r\ndev_dbg(&dev->pdev->dev, "HBM VERSION: DRIVER=%02d:%02d DEVICE=%02d:%02d\n",\r\nHBM_MAJOR_VERSION, HBM_MINOR_VERSION,\r\nversion_res->me_max_version.major_version,\r\nversion_res->me_max_version.minor_version);\r\nif (version_res->host_version_supported) {\r\ndev->version.major_version = HBM_MAJOR_VERSION;\r\ndev->version.minor_version = HBM_MINOR_VERSION;\r\n} else {\r\ndev->version.major_version =\r\nversion_res->me_max_version.major_version;\r\ndev->version.minor_version =\r\nversion_res->me_max_version.minor_version;\r\n}\r\nif (!mei_hbm_version_is_supported(dev)) {\r\ndev_warn(&dev->pdev->dev, "hbm: start: version mismatch - stopping the driver.\n");\r\ndev->hbm_state = MEI_HBM_STOPPED;\r\nif (mei_hbm_stop_req(dev)) {\r\ndev_err(&dev->pdev->dev, "hbm: start: failed to send stop request\n");\r\nreturn -EIO;\r\n}\r\nbreak;\r\n}\r\nif (dev->dev_state != MEI_DEV_INIT_CLIENTS ||\r\ndev->hbm_state != MEI_HBM_START) {\r\ndev_err(&dev->pdev->dev, "hbm: start: state mismatch, [%d, %d]\n",\r\ndev->dev_state, dev->hbm_state);\r\nreturn -EPROTO;\r\n}\r\ndev->hbm_state = MEI_HBM_STARTED;\r\nif (mei_hbm_enum_clients_req(dev)) {\r\ndev_err(&dev->pdev->dev, "hbm: start: failed to send enumeration request\n");\r\nreturn -EIO;\r\n}\r\nwake_up_interruptible(&dev->wait_recvd_msg);\r\nbreak;\r\ncase CLIENT_CONNECT_RES_CMD:\r\ndev_dbg(&dev->pdev->dev, "hbm: client connect response: message received.\n");\r\nconnect_res = (struct hbm_client_connect_response *) mei_msg;\r\nmei_hbm_cl_connect_res(dev, connect_res);\r\nwake_up(&dev->wait_recvd_msg);\r\nbreak;\r\ncase CLIENT_DISCONNECT_RES_CMD:\r\ndev_dbg(&dev->pdev->dev, "hbm: client disconnect response: message received.\n");\r\ndisconnect_res = (struct hbm_client_connect_response *) mei_msg;\r\nmei_hbm_cl_disconnect_res(dev, disconnect_res);\r\nwake_up(&dev->wait_recvd_msg);\r\nbreak;\r\ncase MEI_FLOW_CONTROL_CMD:\r\ndev_dbg(&dev->pdev->dev, "hbm: client flow control response: message received.\n");\r\nflow_control = (struct hbm_flow_control *) mei_msg;\r\nmei_hbm_cl_flow_control_res(dev, flow_control);\r\nbreak;\r\ncase MEI_PG_ISOLATION_ENTRY_RES_CMD:\r\ndev_dbg(&dev->pdev->dev, "power gate isolation entry response received\n");\r\ndev->pg_event = MEI_PG_EVENT_RECEIVED;\r\nif (waitqueue_active(&dev->wait_pg))\r\nwake_up(&dev->wait_pg);\r\nbreak;\r\ncase MEI_PG_ISOLATION_EXIT_REQ_CMD:\r\ndev_dbg(&dev->pdev->dev, "power gate isolation exit request received\n");\r\ndev->pg_event = MEI_PG_EVENT_RECEIVED;\r\nif (waitqueue_active(&dev->wait_pg))\r\nwake_up(&dev->wait_pg);\r\nelse\r\npm_request_resume(&dev->pdev->dev);\r\nbreak;\r\ncase HOST_CLIENT_PROPERTIES_RES_CMD:\r\ndev_dbg(&dev->pdev->dev, "hbm: properties response: message received.\n");\r\ndev->init_clients_timer = 0;\r\nif (dev->me_clients == NULL) {\r\ndev_err(&dev->pdev->dev, "hbm: properties response: mei_clients not allocated\n");\r\nreturn -EPROTO;\r\n}\r\nprops_res = (struct hbm_props_response *)mei_msg;\r\nme_client = &dev->me_clients[dev->me_client_presentation_num];\r\nif (props_res->status) {\r\ndev_err(&dev->pdev->dev, "hbm: properties response: wrong status = %d\n",\r\nprops_res->status);\r\nreturn -EPROTO;\r\n}\r\nif (me_client->client_id != props_res->address) {\r\ndev_err(&dev->pdev->dev, "hbm: properties response: address mismatch %d ?= %d\n",\r\nme_client->client_id, props_res->address);\r\nreturn -EPROTO;\r\n}\r\nif (dev->dev_state != MEI_DEV_INIT_CLIENTS ||\r\ndev->hbm_state != MEI_HBM_CLIENT_PROPERTIES) {\r\ndev_err(&dev->pdev->dev, "hbm: properties response: state mismatch, [%d, %d]\n",\r\ndev->dev_state, dev->hbm_state);\r\nreturn -EPROTO;\r\n}\r\nme_client->props = props_res->client_properties;\r\ndev->me_client_index++;\r\ndev->me_client_presentation_num++;\r\nif (mei_hbm_prop_req(dev))\r\nreturn -EIO;\r\nbreak;\r\ncase HOST_ENUM_RES_CMD:\r\ndev_dbg(&dev->pdev->dev, "hbm: enumeration response: message received\n");\r\ndev->init_clients_timer = 0;\r\nenum_res = (struct hbm_host_enum_response *) mei_msg;\r\nBUILD_BUG_ON(sizeof(dev->me_clients_map)\r\n< sizeof(enum_res->valid_addresses));\r\nmemcpy(dev->me_clients_map, enum_res->valid_addresses,\r\nsizeof(enum_res->valid_addresses));\r\nif (dev->dev_state != MEI_DEV_INIT_CLIENTS ||\r\ndev->hbm_state != MEI_HBM_ENUM_CLIENTS) {\r\ndev_err(&dev->pdev->dev, "hbm: enumeration response: state mismatch, [%d, %d]\n",\r\ndev->dev_state, dev->hbm_state);\r\nreturn -EPROTO;\r\n}\r\nif (mei_hbm_me_cl_allocate(dev)) {\r\ndev_err(&dev->pdev->dev, "hbm: enumeration response: cannot allocate clients array\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->hbm_state = MEI_HBM_CLIENT_PROPERTIES;\r\nif (mei_hbm_prop_req(dev))\r\nreturn -EIO;\r\nbreak;\r\ncase HOST_STOP_RES_CMD:\r\ndev_dbg(&dev->pdev->dev, "hbm: stop response: message received\n");\r\ndev->init_clients_timer = 0;\r\nif (dev->hbm_state != MEI_HBM_STOPPED) {\r\ndev_err(&dev->pdev->dev, "hbm: stop response: state mismatch, [%d, %d]\n",\r\ndev->dev_state, dev->hbm_state);\r\nreturn -EPROTO;\r\n}\r\ndev->dev_state = MEI_DEV_POWER_DOWN;\r\ndev_info(&dev->pdev->dev, "hbm: stop response: resetting.\n");\r\nreturn -EPROTO;\r\nbreak;\r\ncase CLIENT_DISCONNECT_REQ_CMD:\r\ndev_dbg(&dev->pdev->dev, "hbm: disconnect request: message received\n");\r\ndisconnect_req = (struct hbm_client_connect_request *)mei_msg;\r\nmei_hbm_fw_disconnect_req(dev, disconnect_req);\r\nbreak;\r\ncase ME_STOP_REQ_CMD:\r\ndev_dbg(&dev->pdev->dev, "hbm: stop request: message received\n");\r\ndev->hbm_state = MEI_HBM_STOPPED;\r\nif (mei_hbm_stop_req(dev)) {\r\ndev_err(&dev->pdev->dev, "hbm: start: failed to send stop request\n");\r\nreturn -EIO;\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nreturn 0;\r\n}
