static inline unsigned char str2hexnum(unsigned char c)\r\n{\r\nif (c >= '0' && c <= '9')\r\nreturn c - '0';\r\nif (c >= 'a' && c <= 'f')\r\nreturn c - 'a' + 10;\r\nreturn 0;\r\n}\r\nint str2eaddr(unsigned char *ea, unsigned char *str)\r\n{\r\nint index = 0;\r\nunsigned char num = 0;\r\nwhile (*str != '\0') {\r\nif ((*str == '.') || (*str == ':')) {\r\nea[index++] = num;\r\nnum = 0;\r\nstr++;\r\n} else {\r\nnum = num << 4;\r\nnum |= str2hexnum(*str++);\r\n}\r\n}\r\nif (index == 5) {\r\nea[index++] = num;\r\nreturn 0;\r\n} else\r\nreturn -1;\r\n}\r\nstatic inline unsigned long str2hex(unsigned char *str)\r\n{\r\nint value = 0;\r\nwhile (*str) {\r\nvalue = value << 4;\r\nvalue |= str2hexnum(*str++);\r\n}\r\nreturn value;\r\n}\r\nconst char *get_system_type(void)\r\n{\r\n#if defined(CONFIG_PMC_MSP4200_EVAL)\r\nreturn "PMC-Sierra MSP4200 Eval Board";\r\n#elif defined(CONFIG_PMC_MSP4200_GW)\r\nreturn "PMC-Sierra MSP4200 VoIP Gateway";\r\n#elif defined(CONFIG_PMC_MSP7120_EVAL)\r\nreturn "PMC-Sierra MSP7120 Eval Board";\r\n#elif defined(CONFIG_PMC_MSP7120_GW)\r\nreturn "PMC-Sierra MSP7120 Residential Gateway";\r\n#elif defined(CONFIG_PMC_MSP7120_FPGA)\r\nreturn "PMC-Sierra MSP7120 FPGA";\r\n#else\r\n#error "What is the type of *your* MSP?"\r\n#endif\r\n}\r\nint get_ethernet_addr(char *ethaddr_name, char *ethernet_addr)\r\n{\r\nchar *ethaddr_str;\r\nethaddr_str = prom_getenv(ethaddr_name);\r\nif (!ethaddr_str) {\r\nprintk(KERN_WARNING "%s not set in boot prom\n", ethaddr_name);\r\nreturn -1;\r\n}\r\nif (str2eaddr(ethernet_addr, ethaddr_str) == -1) {\r\nprintk(KERN_WARNING "%s badly formatted-<%s>\n",\r\nethaddr_name, ethaddr_str);\r\nreturn -1;\r\n}\r\nif (init_debug > 1) {\r\nint i;\r\nprintk(KERN_DEBUG "get_ethernet_addr: for %s ", ethaddr_name);\r\nfor (i = 0; i < 5; i++)\r\nprintk(KERN_DEBUG "%02x:",\r\n(unsigned char)*(ethernet_addr+i));\r\nprintk(KERN_DEBUG "%02x\n", *(ethernet_addr+i));\r\n}\r\nreturn 0;\r\n}\r\nstatic char *get_features(void)\r\n{\r\nchar *feature = prom_getenv(FEATURES);\r\nif (feature == NULL) {\r\nfeature = msp_default_features;\r\n}\r\nreturn feature;\r\n}\r\nstatic char test_feature(char c)\r\n{\r\nchar *feature = get_features();\r\nwhile (*feature) {\r\nif (*feature++ == c)\r\nreturn *feature;\r\nfeature++;\r\n}\r\nreturn FEATURE_NOEXIST;\r\n}\r\nunsigned long get_deviceid(void)\r\n{\r\nchar *deviceid = prom_getenv(DEVICEID);\r\nif (deviceid == NULL)\r\nreturn *DEV_ID_REG;\r\nelse\r\nreturn str2hex(deviceid);\r\n}\r\nchar identify_pci(void)\r\n{\r\nreturn test_feature(PCI_KEY);\r\n}\r\nchar identify_pcimux(void)\r\n{\r\nreturn test_feature(PCIMUX_KEY);\r\n}\r\nchar identify_sec(void)\r\n{\r\nreturn test_feature(SEC_KEY);\r\n}\r\nchar identify_spad(void)\r\n{\r\nreturn test_feature(SPAD_KEY);\r\n}\r\nchar identify_tdm(void)\r\n{\r\nreturn test_feature(TDM_KEY);\r\n}\r\nchar identify_zsp(void)\r\n{\r\nreturn test_feature(ZSP_KEY);\r\n}\r\nstatic char identify_enetfeature(char key, unsigned long interface_num)\r\n{\r\nchar *feature = get_features();\r\nwhile (*feature) {\r\nif (*feature++ == key && interface_num-- == 0)\r\nreturn *feature;\r\nfeature++;\r\n}\r\nreturn FEATURE_NOEXIST;\r\n}\r\nchar identify_enet(unsigned long interface_num)\r\n{\r\nreturn identify_enetfeature(ENET_KEY, interface_num);\r\n}\r\nchar identify_enetTxD(unsigned long interface_num)\r\n{\r\nreturn identify_enetfeature(ENETTXD_KEY, interface_num);\r\n}\r\nunsigned long identify_family(void)\r\n{\r\nunsigned long deviceid;\r\ndeviceid = get_deviceid();\r\nreturn deviceid & CPU_DEVID_FAMILY;\r\n}\r\nunsigned long identify_revision(void)\r\n{\r\nunsigned long deviceid;\r\ndeviceid = get_deviceid();\r\nreturn deviceid & CPU_DEVID_REVISION;\r\n}\r\nchar *prom_getenv(char *env_name)\r\n{\r\nchar **var = prom_envp;\r\nint i = strlen(env_name);\r\nwhile (*var) {\r\nif (strncmp(env_name, *var, i) == 0) {\r\nreturn (*var + strlen(env_name) + 1);\r\n}\r\nvar++;\r\n}\r\nreturn NULL;\r\n}\r\nvoid __init prom_init_cmdline(void)\r\n{\r\nchar *cp;\r\nint actr;\r\nactr = 1;\r\ncp = &(arcs_cmdline[0]);\r\nwhile (actr < prom_argc) {\r\nstrcpy(cp, prom_argv[actr]);\r\ncp += strlen(prom_argv[actr]);\r\n*cp++ = ' ';\r\nactr++;\r\n}\r\nif (cp != &(arcs_cmdline[0]))\r\n--cp;\r\n*cp = '\0';\r\n}\r\nstatic int __init prom_memtype_classify(unsigned int type)\r\n{\r\nswitch (type) {\r\ncase yamon_free:\r\nreturn BOOT_MEM_RAM;\r\ncase yamon_prom:\r\nreturn BOOT_MEM_ROM_DATA;\r\ndefault:\r\nreturn BOOT_MEM_RESERVED;\r\n}\r\n}\r\nvoid __init prom_meminit(void)\r\n{\r\nstruct prom_pmemblock *p;\r\np = prom_getmdesc();\r\nwhile (p->size) {\r\nlong type;\r\nunsigned long base, size;\r\ntype = prom_memtype_classify(p->type);\r\nbase = p->base;\r\nsize = p->size;\r\nadd_memory_region(base, size, type);\r\np++;\r\n}\r\n}\r\nvoid __init prom_free_prom_memory(void)\r\n{\r\nint argc;\r\nchar **argv;\r\nchar **envp;\r\nchar *ptr;\r\nint len = 0;\r\nint i;\r\nunsigned long addr;\r\nfor (argc = 0; argc < prom_argc; argc++) {\r\nlen += sizeof(char *);\r\nlen += strlen(prom_argv[argc]) + 1;\r\n}\r\nlen += sizeof(char *);\r\nargv = kmalloc(len, GFP_KERNEL);\r\nptr = (char *) &argv[prom_argc + 1];\r\nfor (argc = 0; argc < prom_argc; argc++) {\r\nargv[argc] = ptr;\r\nstrcpy(ptr, prom_argv[argc]);\r\nptr += strlen(prom_argv[argc]) + 1;\r\n}\r\nargv[prom_argc] = NULL;\r\nprom_argv = argv;\r\nlen = 0;\r\ni = 0;\r\nfor (envp = prom_envp; *envp != NULL; envp++) {\r\ni++;\r\nlen += sizeof(char *);\r\nlen += strlen(*envp) + 1;\r\n}\r\nlen += sizeof(char *);\r\nenvp = kmalloc(len, GFP_KERNEL);\r\nptr = (char *) &envp[i+1];\r\nfor (argc = 0; argc < i; argc++) {\r\nenvp[argc] = ptr;\r\nstrcpy(ptr, prom_envp[argc]);\r\nptr += strlen(prom_envp[argc]) + 1;\r\n}\r\nenvp[i] = NULL;\r\nprom_envp = envp;\r\nfor (i = 0; i < boot_mem_map.nr_map; i++) {\r\nif (boot_mem_map.map[i].type != BOOT_MEM_ROM_DATA)\r\ncontinue;\r\naddr = boot_mem_map.map[i].addr;\r\nfree_init_pages("prom memory",\r\naddr, addr + boot_mem_map.map[i].size);\r\n}\r\n}\r\nstruct prom_pmemblock *__init prom_getmdesc(void)\r\n{\r\nstatic char memsz_env[] __initdata = "memsize";\r\nstatic char heaptop_env[] __initdata = "heaptop";\r\nchar *str;\r\nunsigned int memsize;\r\nunsigned int heaptop;\r\nint i;\r\nstr = prom_getenv(memsz_env);\r\nif (!str) {\r\nppfinit("memsize not set in boot prom, "\r\n"set to default (32Mb)\n");\r\nmemsize = 0x02000000;\r\n} else {\r\nmemsize = simple_strtol(str, NULL, 0);\r\nif (memsize == 0) {\r\nmemsize = 0x02000000;\r\n}\r\nmemsize = CPHYSADDR(memsize);\r\n}\r\nstr = prom_getenv(heaptop_env);\r\nif (!str) {\r\nheaptop = CPHYSADDR((u32)&_text);\r\nppfinit("heaptop not set in boot prom, "\r\n"set to default 0x%08x\n", heaptop);\r\n} else {\r\nheaptop = simple_strtol(str, NULL, 16);\r\nif (heaptop == 0) {\r\nheaptop = simple_strtol(str, NULL, 0);\r\nif (heaptop == 0) {\r\nheaptop = CPHYSADDR((u32)&_text);\r\n}\r\n}\r\nheaptop = CPHYSADDR((u32)heaptop);\r\n}\r\ni = 0;\r\nmdesc[i].type = BOOT_MEM_RESERVED;\r\nmdesc[i].base = 0x00000000;\r\nmdesc[i].size = PAGE_ALIGN(0x300 + 0x80);\r\nif (heaptop > mdesc[i].base + mdesc[i].size) {\r\ni++;\r\nmdesc[i].type = BOOT_MEM_ROM_DATA;\r\nmdesc[i].base = mdesc[i-1].base + mdesc[i-1].size;\r\nmdesc[i].size = heaptop - mdesc[i].base;\r\n}\r\nif (heaptop != CPHYSADDR((u32)_text)) {\r\ni++;\r\nmdesc[i].type = BOOT_MEM_RAM;\r\nmdesc[i].base = heaptop;\r\nmdesc[i].size = CPHYSADDR((u32)_text) - mdesc[i].base;\r\n}\r\ni++;\r\nmdesc[i].type = BOOT_MEM_RESERVED;\r\nmdesc[i].base = CPHYSADDR((u32)_text);\r\nmdesc[i].size = CPHYSADDR(PAGE_ALIGN((u32)_end)) - mdesc[i].base;\r\ni++;\r\nmdesc[i].type = yamon_free;\r\nmdesc[i].base = mdesc[i-1].base + mdesc[i-1].size;\r\nmdesc[i].size = memsize - mdesc[i].base;\r\nreturn &mdesc[0];\r\n}
