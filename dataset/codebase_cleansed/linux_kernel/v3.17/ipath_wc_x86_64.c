int ipath_enable_wc(struct ipath_devdata *dd)\r\n{\r\nint ret = 0;\r\nu64 pioaddr, piolen;\r\nunsigned bits;\r\nconst unsigned long addr = pci_resource_start(dd->pcidev, 0);\r\nconst size_t len = pci_resource_len(dd->pcidev, 0);\r\nif (dd->ipath_piobcnt2k && dd->ipath_piobcnt4k) {\r\nunsigned long pio2kbase, pio4kbase;\r\npio2kbase = dd->ipath_piobufbase & 0xffffffffUL;\r\npio4kbase = (dd->ipath_piobufbase >> 32) & 0xffffffffUL;\r\nif (pio2kbase < pio4kbase) {\r\npioaddr = addr + pio2kbase;\r\npiolen = pio4kbase - pio2kbase +\r\ndd->ipath_piobcnt4k * dd->ipath_4kalign;\r\n} else {\r\npioaddr = addr + pio4kbase;\r\npiolen = pio2kbase - pio4kbase +\r\ndd->ipath_piobcnt2k * dd->ipath_palign;\r\n}\r\n} else {\r\npioaddr = addr + dd->ipath_piobufbase;\r\npiolen = dd->ipath_piobcnt2k * dd->ipath_palign +\r\ndd->ipath_piobcnt4k * dd->ipath_4kalign;\r\n}\r\nfor (bits = 0; !(piolen & (1ULL << bits)); bits++)\r\n;\r\nif (piolen != (1ULL << bits)) {\r\npiolen >>= bits;\r\nwhile (piolen >>= 1)\r\nbits++;\r\npiolen = 1ULL << (bits + 1);\r\n}\r\nif (pioaddr & (piolen - 1)) {\r\nu64 atmp;\r\nipath_dbg("pioaddr %llx not on right boundary for size "\r\n"%llx, fixing\n",\r\n(unsigned long long) pioaddr,\r\n(unsigned long long) piolen);\r\natmp = pioaddr & ~(piolen - 1);\r\nif (atmp < addr || (atmp + piolen) > (addr + len)) {\r\nipath_dev_err(dd, "No way to align address/size "\r\n"(%llx/%llx), no WC mtrr\n",\r\n(unsigned long long) atmp,\r\n(unsigned long long) piolen << 1);\r\nret = -ENODEV;\r\n} else {\r\nipath_dbg("changing WC base from %llx to %llx, "\r\n"len from %llx to %llx\n",\r\n(unsigned long long) pioaddr,\r\n(unsigned long long) atmp,\r\n(unsigned long long) piolen,\r\n(unsigned long long) piolen << 1);\r\npioaddr = atmp;\r\npiolen <<= 1;\r\n}\r\n}\r\nif (!ret) {\r\nint cookie;\r\nipath_cdbg(VERBOSE, "Setting mtrr for chip to WC "\r\n"(addr %llx, len=0x%llx)\n",\r\n(unsigned long long) pioaddr,\r\n(unsigned long long) piolen);\r\ncookie = mtrr_add(pioaddr, piolen, MTRR_TYPE_WRCOMB, 0);\r\nif (cookie < 0) {\r\n{\r\ndev_info(&dd->pcidev->dev,\r\n"mtrr_add() WC for PIO bufs "\r\n"failed (%d)\n",\r\ncookie);\r\nret = -EINVAL;\r\n}\r\n} else {\r\nipath_cdbg(VERBOSE, "Set mtrr for chip to WC, "\r\n"cookie is %d\n", cookie);\r\ndd->ipath_wc_cookie = cookie;\r\ndd->ipath_wc_base = (unsigned long) pioaddr;\r\ndd->ipath_wc_len = (unsigned long) piolen;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid ipath_disable_wc(struct ipath_devdata *dd)\r\n{\r\nif (dd->ipath_wc_cookie) {\r\nint r;\r\nipath_cdbg(VERBOSE, "undoing WCCOMB on pio buffers\n");\r\nr = mtrr_del(dd->ipath_wc_cookie, dd->ipath_wc_base,\r\ndd->ipath_wc_len);\r\nif (r < 0)\r\ndev_info(&dd->pcidev->dev,\r\n"mtrr_del(%lx, %lx, %lx) failed: %d\n",\r\ndd->ipath_wc_cookie, dd->ipath_wc_base,\r\ndd->ipath_wc_len, r);\r\ndd->ipath_wc_cookie = 0;\r\n}\r\n}\r\nint ipath_unordered_wc(void)\r\n{\r\nreturn boot_cpu_data.x86_vendor != X86_VENDOR_AMD;\r\n}
