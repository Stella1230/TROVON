static void uhid_queue(struct uhid_device *uhid, struct uhid_event *ev)\r\n{\r\n__u8 newhead;\r\nnewhead = (uhid->head + 1) % UHID_BUFSIZE;\r\nif (newhead != uhid->tail) {\r\nuhid->outq[uhid->head] = ev;\r\nuhid->head = newhead;\r\nwake_up_interruptible(&uhid->waitq);\r\n} else {\r\nhid_warn(uhid->hid, "Output queue is full\n");\r\nkfree(ev);\r\n}\r\n}\r\nstatic int uhid_queue_event(struct uhid_device *uhid, __u32 event)\r\n{\r\nunsigned long flags;\r\nstruct uhid_event *ev;\r\nev = kzalloc(sizeof(*ev), GFP_KERNEL);\r\nif (!ev)\r\nreturn -ENOMEM;\r\nev->type = event;\r\nspin_lock_irqsave(&uhid->qlock, flags);\r\nuhid_queue(uhid, ev);\r\nspin_unlock_irqrestore(&uhid->qlock, flags);\r\nreturn 0;\r\n}\r\nstatic int uhid_hid_start(struct hid_device *hid)\r\n{\r\nstruct uhid_device *uhid = hid->driver_data;\r\nreturn uhid_queue_event(uhid, UHID_START);\r\n}\r\nstatic void uhid_hid_stop(struct hid_device *hid)\r\n{\r\nstruct uhid_device *uhid = hid->driver_data;\r\nhid->claimed = 0;\r\nuhid_queue_event(uhid, UHID_STOP);\r\n}\r\nstatic int uhid_hid_open(struct hid_device *hid)\r\n{\r\nstruct uhid_device *uhid = hid->driver_data;\r\nreturn uhid_queue_event(uhid, UHID_OPEN);\r\n}\r\nstatic void uhid_hid_close(struct hid_device *hid)\r\n{\r\nstruct uhid_device *uhid = hid->driver_data;\r\nuhid_queue_event(uhid, UHID_CLOSE);\r\n}\r\nstatic int uhid_hid_parse(struct hid_device *hid)\r\n{\r\nstruct uhid_device *uhid = hid->driver_data;\r\nreturn hid_parse_report(hid, uhid->rd_data, uhid->rd_size);\r\n}\r\nstatic int uhid_hid_get_raw(struct hid_device *hid, unsigned char rnum,\r\n__u8 *buf, size_t count, unsigned char rtype)\r\n{\r\nstruct uhid_device *uhid = hid->driver_data;\r\n__u8 report_type;\r\nstruct uhid_event *ev;\r\nunsigned long flags;\r\nint ret;\r\nsize_t uninitialized_var(len);\r\nstruct uhid_feature_answer_req *req;\r\nif (!uhid->running)\r\nreturn -EIO;\r\nswitch (rtype) {\r\ncase HID_FEATURE_REPORT:\r\nreport_type = UHID_FEATURE_REPORT;\r\nbreak;\r\ncase HID_OUTPUT_REPORT:\r\nreport_type = UHID_OUTPUT_REPORT;\r\nbreak;\r\ncase HID_INPUT_REPORT:\r\nreport_type = UHID_INPUT_REPORT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = mutex_lock_interruptible(&uhid->report_lock);\r\nif (ret)\r\nreturn ret;\r\nev = kzalloc(sizeof(*ev), GFP_KERNEL);\r\nif (!ev) {\r\nret = -ENOMEM;\r\ngoto unlock;\r\n}\r\nspin_lock_irqsave(&uhid->qlock, flags);\r\nev->type = UHID_FEATURE;\r\nev->u.feature.id = atomic_inc_return(&uhid->report_id);\r\nev->u.feature.rnum = rnum;\r\nev->u.feature.rtype = report_type;\r\natomic_set(&uhid->report_done, 0);\r\nuhid_queue(uhid, ev);\r\nspin_unlock_irqrestore(&uhid->qlock, flags);\r\nret = wait_event_interruptible_timeout(uhid->report_wait,\r\natomic_read(&uhid->report_done), 5 * HZ);\r\nsmp_rmb();\r\nif (!ret || !uhid->running) {\r\nret = -EIO;\r\n} else if (ret < 0) {\r\nret = -ERESTARTSYS;\r\n} else {\r\nspin_lock_irqsave(&uhid->qlock, flags);\r\nreq = &uhid->report_buf.u.feature_answer;\r\nif (req->err) {\r\nret = -EIO;\r\n} else {\r\nret = 0;\r\nlen = min(count,\r\nmin_t(size_t, req->size, UHID_DATA_MAX));\r\nmemcpy(buf, req->data, len);\r\n}\r\nspin_unlock_irqrestore(&uhid->qlock, flags);\r\n}\r\natomic_set(&uhid->report_done, 1);\r\nunlock:\r\nmutex_unlock(&uhid->report_lock);\r\nreturn ret ? ret : len;\r\n}\r\nstatic int uhid_hid_output_raw(struct hid_device *hid, __u8 *buf, size_t count,\r\nunsigned char report_type)\r\n{\r\nstruct uhid_device *uhid = hid->driver_data;\r\n__u8 rtype;\r\nunsigned long flags;\r\nstruct uhid_event *ev;\r\nswitch (report_type) {\r\ncase HID_FEATURE_REPORT:\r\nrtype = UHID_FEATURE_REPORT;\r\nbreak;\r\ncase HID_OUTPUT_REPORT:\r\nrtype = UHID_OUTPUT_REPORT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (count < 1 || count > UHID_DATA_MAX)\r\nreturn -EINVAL;\r\nev = kzalloc(sizeof(*ev), GFP_KERNEL);\r\nif (!ev)\r\nreturn -ENOMEM;\r\nev->type = UHID_OUTPUT;\r\nev->u.output.size = count;\r\nev->u.output.rtype = rtype;\r\nmemcpy(ev->u.output.data, buf, count);\r\nspin_lock_irqsave(&uhid->qlock, flags);\r\nuhid_queue(uhid, ev);\r\nspin_unlock_irqrestore(&uhid->qlock, flags);\r\nreturn count;\r\n}\r\nstatic int uhid_hid_output_report(struct hid_device *hid, __u8 *buf,\r\nsize_t count)\r\n{\r\nreturn uhid_hid_output_raw(hid, buf, count, HID_OUTPUT_REPORT);\r\n}\r\nstatic int uhid_raw_request(struct hid_device *hid, unsigned char reportnum,\r\n__u8 *buf, size_t len, unsigned char rtype,\r\nint reqtype)\r\n{\r\nswitch (reqtype) {\r\ncase HID_REQ_GET_REPORT:\r\nreturn uhid_hid_get_raw(hid, reportnum, buf, len, rtype);\r\ncase HID_REQ_SET_REPORT:\r\nreturn -ENOSYS;\r\ndefault:\r\nreturn -EIO;\r\n}\r\n}\r\nstatic int uhid_event_from_user(const char __user *buffer, size_t len,\r\nstruct uhid_event *event)\r\n{\r\nif (is_compat_task()) {\r\nu32 type;\r\nif (get_user(type, buffer))\r\nreturn -EFAULT;\r\nif (type == UHID_CREATE) {\r\nstruct uhid_create_req_compat *compat;\r\ncompat = kzalloc(sizeof(*compat), GFP_KERNEL);\r\nif (!compat)\r\nreturn -ENOMEM;\r\nbuffer += sizeof(type);\r\nlen -= sizeof(type);\r\nif (copy_from_user(compat, buffer,\r\nmin(len, sizeof(*compat)))) {\r\nkfree(compat);\r\nreturn -EFAULT;\r\n}\r\nevent->type = type;\r\nmemcpy(event->u.create.name, compat->name,\r\nsizeof(compat->name));\r\nmemcpy(event->u.create.phys, compat->phys,\r\nsizeof(compat->phys));\r\nmemcpy(event->u.create.uniq, compat->uniq,\r\nsizeof(compat->uniq));\r\nevent->u.create.rd_data = compat_ptr(compat->rd_data);\r\nevent->u.create.rd_size = compat->rd_size;\r\nevent->u.create.bus = compat->bus;\r\nevent->u.create.vendor = compat->vendor;\r\nevent->u.create.product = compat->product;\r\nevent->u.create.version = compat->version;\r\nevent->u.create.country = compat->country;\r\nkfree(compat);\r\nreturn 0;\r\n}\r\n}\r\nif (copy_from_user(event, buffer, min(len, sizeof(*event))))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int uhid_event_from_user(const char __user *buffer, size_t len,\r\nstruct uhid_event *event)\r\n{\r\nif (copy_from_user(event, buffer, min(len, sizeof(*event))))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int uhid_dev_create(struct uhid_device *uhid,\r\nconst struct uhid_event *ev)\r\n{\r\nstruct hid_device *hid;\r\nint ret;\r\nif (uhid->running)\r\nreturn -EALREADY;\r\nuhid->rd_size = ev->u.create.rd_size;\r\nif (uhid->rd_size <= 0 || uhid->rd_size > HID_MAX_DESCRIPTOR_SIZE)\r\nreturn -EINVAL;\r\nuhid->rd_data = kmalloc(uhid->rd_size, GFP_KERNEL);\r\nif (!uhid->rd_data)\r\nreturn -ENOMEM;\r\nif (copy_from_user(uhid->rd_data, ev->u.create.rd_data,\r\nuhid->rd_size)) {\r\nret = -EFAULT;\r\ngoto err_free;\r\n}\r\nhid = hid_allocate_device();\r\nif (IS_ERR(hid)) {\r\nret = PTR_ERR(hid);\r\ngoto err_free;\r\n}\r\nstrncpy(hid->name, ev->u.create.name, 127);\r\nhid->name[127] = 0;\r\nstrncpy(hid->phys, ev->u.create.phys, 63);\r\nhid->phys[63] = 0;\r\nstrncpy(hid->uniq, ev->u.create.uniq, 63);\r\nhid->uniq[63] = 0;\r\nhid->ll_driver = &uhid_hid_driver;\r\nhid->bus = ev->u.create.bus;\r\nhid->vendor = ev->u.create.vendor;\r\nhid->product = ev->u.create.product;\r\nhid->version = ev->u.create.version;\r\nhid->country = ev->u.create.country;\r\nhid->driver_data = uhid;\r\nhid->dev.parent = uhid_misc.this_device;\r\nuhid->hid = hid;\r\nuhid->running = true;\r\nret = hid_add_device(hid);\r\nif (ret) {\r\nhid_err(hid, "Cannot register HID device\n");\r\ngoto err_hid;\r\n}\r\nreturn 0;\r\nerr_hid:\r\nhid_destroy_device(hid);\r\nuhid->hid = NULL;\r\nuhid->running = false;\r\nerr_free:\r\nkfree(uhid->rd_data);\r\nreturn ret;\r\n}\r\nstatic int uhid_dev_create2(struct uhid_device *uhid,\r\nconst struct uhid_event *ev)\r\n{\r\nstruct hid_device *hid;\r\nint ret;\r\nif (uhid->running)\r\nreturn -EALREADY;\r\nuhid->rd_size = ev->u.create2.rd_size;\r\nif (uhid->rd_size <= 0 || uhid->rd_size > HID_MAX_DESCRIPTOR_SIZE)\r\nreturn -EINVAL;\r\nuhid->rd_data = kmemdup(ev->u.create2.rd_data, uhid->rd_size,\r\nGFP_KERNEL);\r\nif (!uhid->rd_data)\r\nreturn -ENOMEM;\r\nhid = hid_allocate_device();\r\nif (IS_ERR(hid)) {\r\nret = PTR_ERR(hid);\r\ngoto err_free;\r\n}\r\nstrncpy(hid->name, ev->u.create2.name, 127);\r\nhid->name[127] = 0;\r\nstrncpy(hid->phys, ev->u.create2.phys, 63);\r\nhid->phys[63] = 0;\r\nstrncpy(hid->uniq, ev->u.create2.uniq, 63);\r\nhid->uniq[63] = 0;\r\nhid->ll_driver = &uhid_hid_driver;\r\nhid->bus = ev->u.create2.bus;\r\nhid->vendor = ev->u.create2.vendor;\r\nhid->product = ev->u.create2.product;\r\nhid->version = ev->u.create2.version;\r\nhid->country = ev->u.create2.country;\r\nhid->driver_data = uhid;\r\nhid->dev.parent = uhid_misc.this_device;\r\nuhid->hid = hid;\r\nuhid->running = true;\r\nret = hid_add_device(hid);\r\nif (ret) {\r\nhid_err(hid, "Cannot register HID device\n");\r\ngoto err_hid;\r\n}\r\nreturn 0;\r\nerr_hid:\r\nhid_destroy_device(hid);\r\nuhid->hid = NULL;\r\nuhid->running = false;\r\nerr_free:\r\nkfree(uhid->rd_data);\r\nreturn ret;\r\n}\r\nstatic int uhid_dev_destroy(struct uhid_device *uhid)\r\n{\r\nif (!uhid->running)\r\nreturn -EINVAL;\r\nuhid->running = false;\r\nsmp_wmb();\r\natomic_set(&uhid->report_done, 1);\r\nwake_up_interruptible(&uhid->report_wait);\r\nhid_destroy_device(uhid->hid);\r\nkfree(uhid->rd_data);\r\nreturn 0;\r\n}\r\nstatic int uhid_dev_input(struct uhid_device *uhid, struct uhid_event *ev)\r\n{\r\nif (!uhid->running)\r\nreturn -EINVAL;\r\nhid_input_report(uhid->hid, HID_INPUT_REPORT, ev->u.input.data,\r\nmin_t(size_t, ev->u.input.size, UHID_DATA_MAX), 0);\r\nreturn 0;\r\n}\r\nstatic int uhid_dev_input2(struct uhid_device *uhid, struct uhid_event *ev)\r\n{\r\nif (!uhid->running)\r\nreturn -EINVAL;\r\nhid_input_report(uhid->hid, HID_INPUT_REPORT, ev->u.input2.data,\r\nmin_t(size_t, ev->u.input2.size, UHID_DATA_MAX), 0);\r\nreturn 0;\r\n}\r\nstatic int uhid_dev_feature_answer(struct uhid_device *uhid,\r\nstruct uhid_event *ev)\r\n{\r\nunsigned long flags;\r\nif (!uhid->running)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&uhid->qlock, flags);\r\nif (atomic_read(&uhid->report_id) != ev->u.feature_answer.id)\r\ngoto unlock;\r\nif (atomic_read(&uhid->report_done))\r\ngoto unlock;\r\nmemcpy(&uhid->report_buf, ev, sizeof(*ev));\r\natomic_set(&uhid->report_done, 1);\r\nwake_up_interruptible(&uhid->report_wait);\r\nunlock:\r\nspin_unlock_irqrestore(&uhid->qlock, flags);\r\nreturn 0;\r\n}\r\nstatic int uhid_char_open(struct inode *inode, struct file *file)\r\n{\r\nstruct uhid_device *uhid;\r\nuhid = kzalloc(sizeof(*uhid), GFP_KERNEL);\r\nif (!uhid)\r\nreturn -ENOMEM;\r\nmutex_init(&uhid->devlock);\r\nmutex_init(&uhid->report_lock);\r\nspin_lock_init(&uhid->qlock);\r\ninit_waitqueue_head(&uhid->waitq);\r\ninit_waitqueue_head(&uhid->report_wait);\r\nuhid->running = false;\r\natomic_set(&uhid->report_done, 1);\r\nfile->private_data = uhid;\r\nnonseekable_open(inode, file);\r\nreturn 0;\r\n}\r\nstatic int uhid_char_release(struct inode *inode, struct file *file)\r\n{\r\nstruct uhid_device *uhid = file->private_data;\r\nunsigned int i;\r\nuhid_dev_destroy(uhid);\r\nfor (i = 0; i < UHID_BUFSIZE; ++i)\r\nkfree(uhid->outq[i]);\r\nkfree(uhid);\r\nreturn 0;\r\n}\r\nstatic ssize_t uhid_char_read(struct file *file, char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct uhid_device *uhid = file->private_data;\r\nint ret;\r\nunsigned long flags;\r\nsize_t len;\r\nif (count < sizeof(__u32))\r\nreturn -EINVAL;\r\ntry_again:\r\nif (file->f_flags & O_NONBLOCK) {\r\nif (uhid->head == uhid->tail)\r\nreturn -EAGAIN;\r\n} else {\r\nret = wait_event_interruptible(uhid->waitq,\r\nuhid->head != uhid->tail);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = mutex_lock_interruptible(&uhid->devlock);\r\nif (ret)\r\nreturn ret;\r\nif (uhid->head == uhid->tail) {\r\nmutex_unlock(&uhid->devlock);\r\ngoto try_again;\r\n} else {\r\nlen = min(count, sizeof(**uhid->outq));\r\nif (copy_to_user(buffer, uhid->outq[uhid->tail], len)) {\r\nret = -EFAULT;\r\n} else {\r\nkfree(uhid->outq[uhid->tail]);\r\nuhid->outq[uhid->tail] = NULL;\r\nspin_lock_irqsave(&uhid->qlock, flags);\r\nuhid->tail = (uhid->tail + 1) % UHID_BUFSIZE;\r\nspin_unlock_irqrestore(&uhid->qlock, flags);\r\n}\r\n}\r\nmutex_unlock(&uhid->devlock);\r\nreturn ret ? ret : len;\r\n}\r\nstatic ssize_t uhid_char_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct uhid_device *uhid = file->private_data;\r\nint ret;\r\nsize_t len;\r\nif (count < sizeof(__u32))\r\nreturn -EINVAL;\r\nret = mutex_lock_interruptible(&uhid->devlock);\r\nif (ret)\r\nreturn ret;\r\nmemset(&uhid->input_buf, 0, sizeof(uhid->input_buf));\r\nlen = min(count, sizeof(uhid->input_buf));\r\nret = uhid_event_from_user(buffer, len, &uhid->input_buf);\r\nif (ret)\r\ngoto unlock;\r\nswitch (uhid->input_buf.type) {\r\ncase UHID_CREATE:\r\nret = uhid_dev_create(uhid, &uhid->input_buf);\r\nbreak;\r\ncase UHID_CREATE2:\r\nret = uhid_dev_create2(uhid, &uhid->input_buf);\r\nbreak;\r\ncase UHID_DESTROY:\r\nret = uhid_dev_destroy(uhid);\r\nbreak;\r\ncase UHID_INPUT:\r\nret = uhid_dev_input(uhid, &uhid->input_buf);\r\nbreak;\r\ncase UHID_INPUT2:\r\nret = uhid_dev_input2(uhid, &uhid->input_buf);\r\nbreak;\r\ncase UHID_FEATURE_ANSWER:\r\nret = uhid_dev_feature_answer(uhid, &uhid->input_buf);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\n}\r\nunlock:\r\nmutex_unlock(&uhid->devlock);\r\nreturn ret ? ret : count;\r\n}\r\nstatic unsigned int uhid_char_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct uhid_device *uhid = file->private_data;\r\npoll_wait(file, &uhid->waitq, wait);\r\nif (uhid->head != uhid->tail)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int __init uhid_init(void)\r\n{\r\nreturn misc_register(&uhid_misc);\r\n}\r\nstatic void __exit uhid_exit(void)\r\n{\r\nmisc_deregister(&uhid_misc);\r\n}
