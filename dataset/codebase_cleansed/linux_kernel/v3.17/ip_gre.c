static int ipgre_err(struct sk_buff *skb, u32 info,\r\nconst struct tnl_ptk_info *tpi)\r\n{\r\nstruct net *net = dev_net(skb->dev);\r\nstruct ip_tunnel_net *itn;\r\nconst struct iphdr *iph;\r\nconst int type = icmp_hdr(skb)->type;\r\nconst int code = icmp_hdr(skb)->code;\r\nstruct ip_tunnel *t;\r\nswitch (type) {\r\ndefault:\r\ncase ICMP_PARAMETERPROB:\r\nreturn PACKET_RCVD;\r\ncase ICMP_DEST_UNREACH:\r\nswitch (code) {\r\ncase ICMP_SR_FAILED:\r\ncase ICMP_PORT_UNREACH:\r\nreturn PACKET_RCVD;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase ICMP_TIME_EXCEEDED:\r\nif (code != ICMP_EXC_TTL)\r\nreturn PACKET_RCVD;\r\nbreak;\r\ncase ICMP_REDIRECT:\r\nbreak;\r\n}\r\nif (tpi->proto == htons(ETH_P_TEB))\r\nitn = net_generic(net, gre_tap_net_id);\r\nelse\r\nitn = net_generic(net, ipgre_net_id);\r\niph = (const struct iphdr *)(icmp_hdr(skb) + 1);\r\nt = ip_tunnel_lookup(itn, skb->dev->ifindex, tpi->flags,\r\niph->daddr, iph->saddr, tpi->key);\r\nif (t == NULL)\r\nreturn PACKET_REJECT;\r\nif (t->parms.iph.daddr == 0 ||\r\nipv4_is_multicast(t->parms.iph.daddr))\r\nreturn PACKET_RCVD;\r\nif (t->parms.iph.ttl == 0 && type == ICMP_TIME_EXCEEDED)\r\nreturn PACKET_RCVD;\r\nif (time_before(jiffies, t->err_time + IPTUNNEL_ERR_TIMEO))\r\nt->err_count++;\r\nelse\r\nt->err_count = 1;\r\nt->err_time = jiffies;\r\nreturn PACKET_RCVD;\r\n}\r\nstatic int ipgre_rcv(struct sk_buff *skb, const struct tnl_ptk_info *tpi)\r\n{\r\nstruct net *net = dev_net(skb->dev);\r\nstruct ip_tunnel_net *itn;\r\nconst struct iphdr *iph;\r\nstruct ip_tunnel *tunnel;\r\nif (tpi->proto == htons(ETH_P_TEB))\r\nitn = net_generic(net, gre_tap_net_id);\r\nelse\r\nitn = net_generic(net, ipgre_net_id);\r\niph = ip_hdr(skb);\r\ntunnel = ip_tunnel_lookup(itn, skb->dev->ifindex, tpi->flags,\r\niph->saddr, iph->daddr, tpi->key);\r\nif (tunnel) {\r\nskb_pop_mac_header(skb);\r\nip_tunnel_rcv(tunnel, skb, tpi, log_ecn_error);\r\nreturn PACKET_RCVD;\r\n}\r\nreturn PACKET_REJECT;\r\n}\r\nstatic void __gre_xmit(struct sk_buff *skb, struct net_device *dev,\r\nconst struct iphdr *tnl_params,\r\n__be16 proto)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nstruct tnl_ptk_info tpi;\r\ntpi.flags = tunnel->parms.o_flags;\r\ntpi.proto = proto;\r\ntpi.key = tunnel->parms.o_key;\r\nif (tunnel->parms.o_flags & TUNNEL_SEQ)\r\ntunnel->o_seqno++;\r\ntpi.seq = htonl(tunnel->o_seqno);\r\ngre_build_header(skb, &tpi, tunnel->hlen);\r\nip_tunnel_xmit(skb, dev, tnl_params, tnl_params->protocol);\r\n}\r\nstatic netdev_tx_t ipgre_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nconst struct iphdr *tnl_params;\r\nskb = gre_handle_offloads(skb, !!(tunnel->parms.o_flags&TUNNEL_CSUM));\r\nif (IS_ERR(skb))\r\ngoto out;\r\nif (dev->header_ops) {\r\nif (skb_cow_head(skb, dev->needed_headroom -\r\n(tunnel->hlen + sizeof(struct iphdr))))\r\ngoto free_skb;\r\ntnl_params = (const struct iphdr *)skb->data;\r\nskb_pull(skb, tunnel->hlen + sizeof(struct iphdr));\r\n} else {\r\nif (skb_cow_head(skb, dev->needed_headroom))\r\ngoto free_skb;\r\ntnl_params = &tunnel->parms.iph;\r\n}\r\n__gre_xmit(skb, dev, tnl_params, skb->protocol);\r\nreturn NETDEV_TX_OK;\r\nfree_skb:\r\nkfree_skb(skb);\r\nout:\r\ndev->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic netdev_tx_t gre_tap_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nskb = gre_handle_offloads(skb, !!(tunnel->parms.o_flags&TUNNEL_CSUM));\r\nif (IS_ERR(skb))\r\ngoto out;\r\nif (skb_cow_head(skb, dev->needed_headroom))\r\ngoto free_skb;\r\n__gre_xmit(skb, dev, &tunnel->parms.iph, htons(ETH_P_TEB));\r\nreturn NETDEV_TX_OK;\r\nfree_skb:\r\nkfree_skb(skb);\r\nout:\r\ndev->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ipgre_tunnel_ioctl(struct net_device *dev,\r\nstruct ifreq *ifr, int cmd)\r\n{\r\nint err = 0;\r\nstruct ip_tunnel_parm p;\r\nif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\r\nreturn -EFAULT;\r\nif (cmd == SIOCADDTUNNEL || cmd == SIOCCHGTUNNEL) {\r\nif (p.iph.version != 4 || p.iph.protocol != IPPROTO_GRE ||\r\np.iph.ihl != 5 || (p.iph.frag_off&htons(~IP_DF)) ||\r\n((p.i_flags|p.o_flags)&(GRE_VERSION|GRE_ROUTING)))\r\nreturn -EINVAL;\r\n}\r\np.i_flags = gre_flags_to_tnl_flags(p.i_flags);\r\np.o_flags = gre_flags_to_tnl_flags(p.o_flags);\r\nerr = ip_tunnel_ioctl(dev, &p, cmd);\r\nif (err)\r\nreturn err;\r\np.i_flags = tnl_flags_to_gre_flags(p.i_flags);\r\np.o_flags = tnl_flags_to_gre_flags(p.o_flags);\r\nif (copy_to_user(ifr->ifr_ifru.ifru_data, &p, sizeof(p)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ipgre_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type,\r\nconst void *daddr, const void *saddr, unsigned int len)\r\n{\r\nstruct ip_tunnel *t = netdev_priv(dev);\r\nstruct iphdr *iph;\r\nstruct gre_base_hdr *greh;\r\niph = (struct iphdr *)skb_push(skb, t->hlen + sizeof(*iph));\r\ngreh = (struct gre_base_hdr *)(iph+1);\r\ngreh->flags = tnl_flags_to_gre_flags(t->parms.o_flags);\r\ngreh->protocol = htons(type);\r\nmemcpy(iph, &t->parms.iph, sizeof(struct iphdr));\r\nif (saddr)\r\nmemcpy(&iph->saddr, saddr, 4);\r\nif (daddr)\r\nmemcpy(&iph->daddr, daddr, 4);\r\nif (iph->daddr)\r\nreturn t->hlen + sizeof(*iph);\r\nreturn -(t->hlen + sizeof(*iph));\r\n}\r\nstatic int ipgre_header_parse(const struct sk_buff *skb, unsigned char *haddr)\r\n{\r\nconst struct iphdr *iph = (const struct iphdr *) skb_mac_header(skb);\r\nmemcpy(haddr, &iph->saddr, 4);\r\nreturn 4;\r\n}\r\nstatic int ipgre_open(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *t = netdev_priv(dev);\r\nif (ipv4_is_multicast(t->parms.iph.daddr)) {\r\nstruct flowi4 fl4;\r\nstruct rtable *rt;\r\nrt = ip_route_output_gre(t->net, &fl4,\r\nt->parms.iph.daddr,\r\nt->parms.iph.saddr,\r\nt->parms.o_key,\r\nRT_TOS(t->parms.iph.tos),\r\nt->parms.link);\r\nif (IS_ERR(rt))\r\nreturn -EADDRNOTAVAIL;\r\ndev = rt->dst.dev;\r\nip_rt_put(rt);\r\nif (__in_dev_get_rtnl(dev) == NULL)\r\nreturn -EADDRNOTAVAIL;\r\nt->mlink = dev->ifindex;\r\nip_mc_inc_group(__in_dev_get_rtnl(dev), t->parms.iph.daddr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipgre_close(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *t = netdev_priv(dev);\r\nif (ipv4_is_multicast(t->parms.iph.daddr) && t->mlink) {\r\nstruct in_device *in_dev;\r\nin_dev = inetdev_by_index(t->net, t->mlink);\r\nif (in_dev)\r\nip_mc_dec_group(in_dev, t->parms.iph.daddr);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ipgre_tunnel_setup(struct net_device *dev)\r\n{\r\ndev->netdev_ops = &ipgre_netdev_ops;\r\ndev->type = ARPHRD_IPGRE;\r\nip_tunnel_setup(dev, ipgre_net_id);\r\n}\r\nstatic void __gre_tunnel_init(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel;\r\ntunnel = netdev_priv(dev);\r\ntunnel->hlen = ip_gre_calc_hlen(tunnel->parms.o_flags);\r\ntunnel->parms.iph.protocol = IPPROTO_GRE;\r\ndev->needed_headroom = LL_MAX_HEADER + sizeof(struct iphdr) + 4;\r\ndev->mtu = ETH_DATA_LEN - sizeof(struct iphdr) - 4;\r\ndev->features |= GRE_FEATURES;\r\ndev->hw_features |= GRE_FEATURES;\r\nif (!(tunnel->parms.o_flags & TUNNEL_SEQ)) {\r\ndev->features |= NETIF_F_GSO_SOFTWARE;\r\ndev->hw_features |= NETIF_F_GSO_SOFTWARE;\r\ndev->features |= NETIF_F_LLTX;\r\n}\r\n}\r\nstatic int ipgre_tunnel_init(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nstruct iphdr *iph = &tunnel->parms.iph;\r\n__gre_tunnel_init(dev);\r\nmemcpy(dev->dev_addr, &iph->saddr, 4);\r\nmemcpy(dev->broadcast, &iph->daddr, 4);\r\ndev->flags = IFF_NOARP;\r\ndev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\r\ndev->addr_len = 4;\r\nif (iph->daddr) {\r\n#ifdef CONFIG_NET_IPGRE_BROADCAST\r\nif (ipv4_is_multicast(iph->daddr)) {\r\nif (!iph->saddr)\r\nreturn -EINVAL;\r\ndev->flags = IFF_BROADCAST;\r\ndev->header_ops = &ipgre_header_ops;\r\n}\r\n#endif\r\n} else\r\ndev->header_ops = &ipgre_header_ops;\r\nreturn ip_tunnel_init(dev);\r\n}\r\nstatic int __net_init ipgre_init_net(struct net *net)\r\n{\r\nreturn ip_tunnel_init_net(net, ipgre_net_id, &ipgre_link_ops, NULL);\r\n}\r\nstatic void __net_exit ipgre_exit_net(struct net *net)\r\n{\r\nstruct ip_tunnel_net *itn = net_generic(net, ipgre_net_id);\r\nip_tunnel_delete_net(itn, &ipgre_link_ops);\r\n}\r\nstatic int ipgre_tunnel_validate(struct nlattr *tb[], struct nlattr *data[])\r\n{\r\n__be16 flags;\r\nif (!data)\r\nreturn 0;\r\nflags = 0;\r\nif (data[IFLA_GRE_IFLAGS])\r\nflags |= nla_get_be16(data[IFLA_GRE_IFLAGS]);\r\nif (data[IFLA_GRE_OFLAGS])\r\nflags |= nla_get_be16(data[IFLA_GRE_OFLAGS]);\r\nif (flags & (GRE_VERSION|GRE_ROUTING))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ipgre_tap_validate(struct nlattr *tb[], struct nlattr *data[])\r\n{\r\n__be32 daddr;\r\nif (tb[IFLA_ADDRESS]) {\r\nif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\r\nreturn -EINVAL;\r\nif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nif (!data)\r\ngoto out;\r\nif (data[IFLA_GRE_REMOTE]) {\r\nmemcpy(&daddr, nla_data(data[IFLA_GRE_REMOTE]), 4);\r\nif (!daddr)\r\nreturn -EINVAL;\r\n}\r\nout:\r\nreturn ipgre_tunnel_validate(tb, data);\r\n}\r\nstatic void ipgre_netlink_parms(struct nlattr *data[], struct nlattr *tb[],\r\nstruct ip_tunnel_parm *parms)\r\n{\r\nmemset(parms, 0, sizeof(*parms));\r\nparms->iph.protocol = IPPROTO_GRE;\r\nif (!data)\r\nreturn;\r\nif (data[IFLA_GRE_LINK])\r\nparms->link = nla_get_u32(data[IFLA_GRE_LINK]);\r\nif (data[IFLA_GRE_IFLAGS])\r\nparms->i_flags = gre_flags_to_tnl_flags(nla_get_be16(data[IFLA_GRE_IFLAGS]));\r\nif (data[IFLA_GRE_OFLAGS])\r\nparms->o_flags = gre_flags_to_tnl_flags(nla_get_be16(data[IFLA_GRE_OFLAGS]));\r\nif (data[IFLA_GRE_IKEY])\r\nparms->i_key = nla_get_be32(data[IFLA_GRE_IKEY]);\r\nif (data[IFLA_GRE_OKEY])\r\nparms->o_key = nla_get_be32(data[IFLA_GRE_OKEY]);\r\nif (data[IFLA_GRE_LOCAL])\r\nparms->iph.saddr = nla_get_be32(data[IFLA_GRE_LOCAL]);\r\nif (data[IFLA_GRE_REMOTE])\r\nparms->iph.daddr = nla_get_be32(data[IFLA_GRE_REMOTE]);\r\nif (data[IFLA_GRE_TTL])\r\nparms->iph.ttl = nla_get_u8(data[IFLA_GRE_TTL]);\r\nif (data[IFLA_GRE_TOS])\r\nparms->iph.tos = nla_get_u8(data[IFLA_GRE_TOS]);\r\nif (!data[IFLA_GRE_PMTUDISC] || nla_get_u8(data[IFLA_GRE_PMTUDISC]))\r\nparms->iph.frag_off = htons(IP_DF);\r\n}\r\nstatic int gre_tap_init(struct net_device *dev)\r\n{\r\n__gre_tunnel_init(dev);\r\nreturn ip_tunnel_init(dev);\r\n}\r\nstatic void ipgre_tap_setup(struct net_device *dev)\r\n{\r\nether_setup(dev);\r\ndev->netdev_ops = &gre_tap_netdev_ops;\r\ndev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\r\nip_tunnel_setup(dev, gre_tap_net_id);\r\n}\r\nstatic int ipgre_newlink(struct net *src_net, struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nstruct ip_tunnel_parm p;\r\nipgre_netlink_parms(data, tb, &p);\r\nreturn ip_tunnel_newlink(dev, tb, &p);\r\n}\r\nstatic int ipgre_changelink(struct net_device *dev, struct nlattr *tb[],\r\nstruct nlattr *data[])\r\n{\r\nstruct ip_tunnel_parm p;\r\nipgre_netlink_parms(data, tb, &p);\r\nreturn ip_tunnel_changelink(dev, tb, &p);\r\n}\r\nstatic size_t ipgre_get_size(const struct net_device *dev)\r\n{\r\nreturn\r\nnla_total_size(4) +\r\nnla_total_size(2) +\r\nnla_total_size(2) +\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\nnla_total_size(1) +\r\nnla_total_size(1) +\r\nnla_total_size(1) +\r\n0;\r\n}\r\nstatic int ipgre_fill_info(struct sk_buff *skb, const struct net_device *dev)\r\n{\r\nstruct ip_tunnel *t = netdev_priv(dev);\r\nstruct ip_tunnel_parm *p = &t->parms;\r\nif (nla_put_u32(skb, IFLA_GRE_LINK, p->link) ||\r\nnla_put_be16(skb, IFLA_GRE_IFLAGS, tnl_flags_to_gre_flags(p->i_flags)) ||\r\nnla_put_be16(skb, IFLA_GRE_OFLAGS, tnl_flags_to_gre_flags(p->o_flags)) ||\r\nnla_put_be32(skb, IFLA_GRE_IKEY, p->i_key) ||\r\nnla_put_be32(skb, IFLA_GRE_OKEY, p->o_key) ||\r\nnla_put_be32(skb, IFLA_GRE_LOCAL, p->iph.saddr) ||\r\nnla_put_be32(skb, IFLA_GRE_REMOTE, p->iph.daddr) ||\r\nnla_put_u8(skb, IFLA_GRE_TTL, p->iph.ttl) ||\r\nnla_put_u8(skb, IFLA_GRE_TOS, p->iph.tos) ||\r\nnla_put_u8(skb, IFLA_GRE_PMTUDISC,\r\n!!(p->iph.frag_off & htons(IP_DF))))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int __net_init ipgre_tap_init_net(struct net *net)\r\n{\r\nreturn ip_tunnel_init_net(net, gre_tap_net_id, &ipgre_tap_ops, NULL);\r\n}\r\nstatic void __net_exit ipgre_tap_exit_net(struct net *net)\r\n{\r\nstruct ip_tunnel_net *itn = net_generic(net, gre_tap_net_id);\r\nip_tunnel_delete_net(itn, &ipgre_tap_ops);\r\n}\r\nstatic int __init ipgre_init(void)\r\n{\r\nint err;\r\npr_info("GRE over IPv4 tunneling driver\n");\r\nerr = register_pernet_device(&ipgre_net_ops);\r\nif (err < 0)\r\nreturn err;\r\nerr = register_pernet_device(&ipgre_tap_net_ops);\r\nif (err < 0)\r\ngoto pnet_tap_faied;\r\nerr = gre_cisco_register(&ipgre_protocol);\r\nif (err < 0) {\r\npr_info("%s: can't add protocol\n", __func__);\r\ngoto add_proto_failed;\r\n}\r\nerr = rtnl_link_register(&ipgre_link_ops);\r\nif (err < 0)\r\ngoto rtnl_link_failed;\r\nerr = rtnl_link_register(&ipgre_tap_ops);\r\nif (err < 0)\r\ngoto tap_ops_failed;\r\nreturn 0;\r\ntap_ops_failed:\r\nrtnl_link_unregister(&ipgre_link_ops);\r\nrtnl_link_failed:\r\ngre_cisco_unregister(&ipgre_protocol);\r\nadd_proto_failed:\r\nunregister_pernet_device(&ipgre_tap_net_ops);\r\npnet_tap_faied:\r\nunregister_pernet_device(&ipgre_net_ops);\r\nreturn err;\r\n}\r\nstatic void __exit ipgre_fini(void)\r\n{\r\nrtnl_link_unregister(&ipgre_tap_ops);\r\nrtnl_link_unregister(&ipgre_link_ops);\r\ngre_cisco_unregister(&ipgre_protocol);\r\nunregister_pernet_device(&ipgre_tap_net_ops);\r\nunregister_pernet_device(&ipgre_net_ops);\r\n}
