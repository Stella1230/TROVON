static void imx_hdmi_set_ipu_di_mux(struct imx_hdmi *hdmi, int ipu_di)\r\n{\r\nregmap_update_bits(hdmi->regmap, IOMUXC_GPR3,\r\nIMX6Q_GPR3_HDMI_MUX_CTL_MASK,\r\nipu_di << IMX6Q_GPR3_HDMI_MUX_CTL_SHIFT);\r\n}\r\nstatic inline void hdmi_writeb(struct imx_hdmi *hdmi, u8 val, int offset)\r\n{\r\nwriteb(val, hdmi->regs + offset);\r\n}\r\nstatic inline u8 hdmi_readb(struct imx_hdmi *hdmi, int offset)\r\n{\r\nreturn readb(hdmi->regs + offset);\r\n}\r\nstatic void hdmi_modb(struct imx_hdmi *hdmi, u8 data, u8 mask, unsigned reg)\r\n{\r\nu8 val = hdmi_readb(hdmi, reg) & ~mask;\r\nval |= data & mask;\r\nhdmi_writeb(hdmi, val, reg);\r\n}\r\nstatic void hdmi_mask_writeb(struct imx_hdmi *hdmi, u8 data, unsigned int reg,\r\nu8 shift, u8 mask)\r\n{\r\nhdmi_modb(hdmi, data << shift, mask, reg);\r\n}\r\nstatic void hdmi_set_clock_regenerator_n(struct imx_hdmi *hdmi,\r\nunsigned int value)\r\n{\r\nhdmi_writeb(hdmi, value & 0xff, HDMI_AUD_N1);\r\nhdmi_writeb(hdmi, (value >> 8) & 0xff, HDMI_AUD_N2);\r\nhdmi_writeb(hdmi, (value >> 16) & 0x0f, HDMI_AUD_N3);\r\nhdmi_modb(hdmi, 0, HDMI_AUD_CTS3_N_SHIFT_MASK, HDMI_AUD_CTS3);\r\n}\r\nstatic void hdmi_regenerate_cts(struct imx_hdmi *hdmi, unsigned int cts)\r\n{\r\nhdmi_modb(hdmi, 0, HDMI_AUD_CTS3_CTS_MANUAL, HDMI_AUD_CTS3);\r\nhdmi_writeb(hdmi, cts & 0xff, HDMI_AUD_CTS1);\r\nhdmi_writeb(hdmi, (cts >> 8) & 0xff, HDMI_AUD_CTS2);\r\nhdmi_writeb(hdmi, ((cts >> 16) & HDMI_AUD_CTS3_AUDCTS19_16_MASK) |\r\nHDMI_AUD_CTS3_CTS_MANUAL, HDMI_AUD_CTS3);\r\n}\r\nstatic unsigned int hdmi_compute_n(unsigned int freq, unsigned long pixel_clk,\r\nunsigned int ratio)\r\n{\r\nunsigned int n = (128 * freq) / 1000;\r\nswitch (freq) {\r\ncase 32000:\r\nif (pixel_clk == 25170000)\r\nn = (ratio == 150) ? 9152 : 4576;\r\nelse if (pixel_clk == 27020000)\r\nn = (ratio == 150) ? 8192 : 4096;\r\nelse if (pixel_clk == 74170000 || pixel_clk == 148350000)\r\nn = 11648;\r\nelse\r\nn = 4096;\r\nbreak;\r\ncase 44100:\r\nif (pixel_clk == 25170000)\r\nn = 7007;\r\nelse if (pixel_clk == 74170000)\r\nn = 17836;\r\nelse if (pixel_clk == 148350000)\r\nn = (ratio == 150) ? 17836 : 8918;\r\nelse\r\nn = 6272;\r\nbreak;\r\ncase 48000:\r\nif (pixel_clk == 25170000)\r\nn = (ratio == 150) ? 9152 : 6864;\r\nelse if (pixel_clk == 27020000)\r\nn = (ratio == 150) ? 8192 : 6144;\r\nelse if (pixel_clk == 74170000)\r\nn = 11648;\r\nelse if (pixel_clk == 148350000)\r\nn = (ratio == 150) ? 11648 : 5824;\r\nelse\r\nn = 6144;\r\nbreak;\r\ncase 88200:\r\nn = hdmi_compute_n(44100, pixel_clk, ratio) * 2;\r\nbreak;\r\ncase 96000:\r\nn = hdmi_compute_n(48000, pixel_clk, ratio) * 2;\r\nbreak;\r\ncase 176400:\r\nn = hdmi_compute_n(44100, pixel_clk, ratio) * 4;\r\nbreak;\r\ncase 192000:\r\nn = hdmi_compute_n(48000, pixel_clk, ratio) * 4;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn n;\r\n}\r\nstatic unsigned int hdmi_compute_cts(unsigned int freq, unsigned long pixel_clk,\r\nunsigned int ratio)\r\n{\r\nunsigned int cts = 0;\r\npr_debug("%s: freq: %d pixel_clk: %ld ratio: %d\n", __func__, freq,\r\npixel_clk, ratio);\r\nswitch (freq) {\r\ncase 32000:\r\nif (pixel_clk == 297000000) {\r\ncts = 222750;\r\nbreak;\r\n}\r\ncase 48000:\r\ncase 96000:\r\ncase 192000:\r\nswitch (pixel_clk) {\r\ncase 25200000:\r\ncase 27000000:\r\ncase 54000000:\r\ncase 74250000:\r\ncase 148500000:\r\ncts = pixel_clk / 1000;\r\nbreak;\r\ncase 297000000:\r\ncts = 247500;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase 44100:\r\ncase 88200:\r\ncase 176400:\r\nswitch (pixel_clk) {\r\ncase 25200000:\r\ncts = 28000;\r\nbreak;\r\ncase 27000000:\r\ncts = 30000;\r\nbreak;\r\ncase 54000000:\r\ncts = 60000;\r\nbreak;\r\ncase 74250000:\r\ncts = 82500;\r\nbreak;\r\ncase 148500000:\r\ncts = 165000;\r\nbreak;\r\ncase 297000000:\r\ncts = 247500;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ratio == 100)\r\nreturn cts;\r\nelse\r\nreturn (cts * ratio) / 100;\r\n}\r\nstatic void hdmi_set_clk_regenerator(struct imx_hdmi *hdmi,\r\nunsigned long pixel_clk)\r\n{\r\nunsigned int clk_n, clk_cts;\r\nclk_n = hdmi_compute_n(hdmi->sample_rate, pixel_clk,\r\nhdmi->ratio);\r\nclk_cts = hdmi_compute_cts(hdmi->sample_rate, pixel_clk,\r\nhdmi->ratio);\r\nif (!clk_cts) {\r\ndev_dbg(hdmi->dev, "%s: pixel clock not supported: %lu\n",\r\n__func__, pixel_clk);\r\nreturn;\r\n}\r\ndev_dbg(hdmi->dev, "%s: samplerate=%d ratio=%d pixelclk=%lu N=%d cts=%d\n",\r\n__func__, hdmi->sample_rate, hdmi->ratio,\r\npixel_clk, clk_n, clk_cts);\r\nhdmi_set_clock_regenerator_n(hdmi, clk_n);\r\nhdmi_regenerate_cts(hdmi, clk_cts);\r\n}\r\nstatic void hdmi_init_clk_regenerator(struct imx_hdmi *hdmi)\r\n{\r\nhdmi_set_clk_regenerator(hdmi, 74250000);\r\n}\r\nstatic void hdmi_clk_regenerator_update_pixel_clock(struct imx_hdmi *hdmi)\r\n{\r\nhdmi_set_clk_regenerator(hdmi, hdmi->hdmi_data.video_mode.mpixelclock);\r\n}\r\nstatic void hdmi_video_sample(struct imx_hdmi *hdmi)\r\n{\r\nint color_format = 0;\r\nu8 val;\r\nif (hdmi->hdmi_data.enc_in_format == RGB) {\r\nif (hdmi->hdmi_data.enc_color_depth == 8)\r\ncolor_format = 0x01;\r\nelse if (hdmi->hdmi_data.enc_color_depth == 10)\r\ncolor_format = 0x03;\r\nelse if (hdmi->hdmi_data.enc_color_depth == 12)\r\ncolor_format = 0x05;\r\nelse if (hdmi->hdmi_data.enc_color_depth == 16)\r\ncolor_format = 0x07;\r\nelse\r\nreturn;\r\n} else if (hdmi->hdmi_data.enc_in_format == YCBCR444) {\r\nif (hdmi->hdmi_data.enc_color_depth == 8)\r\ncolor_format = 0x09;\r\nelse if (hdmi->hdmi_data.enc_color_depth == 10)\r\ncolor_format = 0x0B;\r\nelse if (hdmi->hdmi_data.enc_color_depth == 12)\r\ncolor_format = 0x0D;\r\nelse if (hdmi->hdmi_data.enc_color_depth == 16)\r\ncolor_format = 0x0F;\r\nelse\r\nreturn;\r\n} else if (hdmi->hdmi_data.enc_in_format == YCBCR422_8BITS) {\r\nif (hdmi->hdmi_data.enc_color_depth == 8)\r\ncolor_format = 0x16;\r\nelse if (hdmi->hdmi_data.enc_color_depth == 10)\r\ncolor_format = 0x14;\r\nelse if (hdmi->hdmi_data.enc_color_depth == 12)\r\ncolor_format = 0x12;\r\nelse\r\nreturn;\r\n}\r\nval = HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_DISABLE |\r\n((color_format << HDMI_TX_INVID0_VIDEO_MAPPING_OFFSET) &\r\nHDMI_TX_INVID0_VIDEO_MAPPING_MASK);\r\nhdmi_writeb(hdmi, val, HDMI_TX_INVID0);\r\nval = HDMI_TX_INSTUFFING_BDBDATA_STUFFING_ENABLE |\r\nHDMI_TX_INSTUFFING_RCRDATA_STUFFING_ENABLE |\r\nHDMI_TX_INSTUFFING_GYDATA_STUFFING_ENABLE;\r\nhdmi_writeb(hdmi, val, HDMI_TX_INSTUFFING);\r\nhdmi_writeb(hdmi, 0x0, HDMI_TX_GYDATA0);\r\nhdmi_writeb(hdmi, 0x0, HDMI_TX_GYDATA1);\r\nhdmi_writeb(hdmi, 0x0, HDMI_TX_RCRDATA0);\r\nhdmi_writeb(hdmi, 0x0, HDMI_TX_RCRDATA1);\r\nhdmi_writeb(hdmi, 0x0, HDMI_TX_BCBDATA0);\r\nhdmi_writeb(hdmi, 0x0, HDMI_TX_BCBDATA1);\r\n}\r\nstatic int is_color_space_conversion(struct imx_hdmi *hdmi)\r\n{\r\nreturn hdmi->hdmi_data.enc_in_format != hdmi->hdmi_data.enc_out_format;\r\n}\r\nstatic int is_color_space_decimation(struct imx_hdmi *hdmi)\r\n{\r\nif (hdmi->hdmi_data.enc_out_format != YCBCR422_8BITS)\r\nreturn 0;\r\nif (hdmi->hdmi_data.enc_in_format == RGB ||\r\nhdmi->hdmi_data.enc_in_format == YCBCR444)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int is_color_space_interpolation(struct imx_hdmi *hdmi)\r\n{\r\nif (hdmi->hdmi_data.enc_in_format != YCBCR422_8BITS)\r\nreturn 0;\r\nif (hdmi->hdmi_data.enc_out_format == RGB ||\r\nhdmi->hdmi_data.enc_out_format == YCBCR444)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void imx_hdmi_update_csc_coeffs(struct imx_hdmi *hdmi)\r\n{\r\nconst u16 (*csc_coeff)[3][4] = &csc_coeff_default;\r\nunsigned i;\r\nu32 csc_scale = 1;\r\nif (is_color_space_conversion(hdmi)) {\r\nif (hdmi->hdmi_data.enc_out_format == RGB) {\r\nif (hdmi->hdmi_data.colorimetry ==\r\nHDMI_COLORIMETRY_ITU_601)\r\ncsc_coeff = &csc_coeff_rgb_out_eitu601;\r\nelse\r\ncsc_coeff = &csc_coeff_rgb_out_eitu709;\r\n} else if (hdmi->hdmi_data.enc_in_format == RGB) {\r\nif (hdmi->hdmi_data.colorimetry ==\r\nHDMI_COLORIMETRY_ITU_601)\r\ncsc_coeff = &csc_coeff_rgb_in_eitu601;\r\nelse\r\ncsc_coeff = &csc_coeff_rgb_in_eitu709;\r\ncsc_scale = 0;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(csc_coeff_default[0]); i++) {\r\nu16 coeff_a = (*csc_coeff)[0][i];\r\nu16 coeff_b = (*csc_coeff)[1][i];\r\nu16 coeff_c = (*csc_coeff)[2][i];\r\nhdmi_writeb(hdmi, coeff_a & 0xff,\r\nHDMI_CSC_COEF_A1_LSB + i * 2);\r\nhdmi_writeb(hdmi, coeff_a >> 8, HDMI_CSC_COEF_A1_MSB + i * 2);\r\nhdmi_writeb(hdmi, coeff_b & 0xff, HDMI_CSC_COEF_B1_LSB + i * 2);\r\nhdmi_writeb(hdmi, coeff_b >> 8, HDMI_CSC_COEF_B1_MSB + i * 2);\r\nhdmi_writeb(hdmi, coeff_c & 0xff,\r\nHDMI_CSC_COEF_C1_LSB + i * 2);\r\nhdmi_writeb(hdmi, coeff_c >> 8, HDMI_CSC_COEF_C1_MSB + i * 2);\r\n}\r\nhdmi_modb(hdmi, csc_scale, HDMI_CSC_SCALE_CSCSCALE_MASK,\r\nHDMI_CSC_SCALE);\r\n}\r\nstatic void hdmi_video_csc(struct imx_hdmi *hdmi)\r\n{\r\nint color_depth = 0;\r\nint interpolation = HDMI_CSC_CFG_INTMODE_DISABLE;\r\nint decimation = 0;\r\nif (is_color_space_interpolation(hdmi))\r\ninterpolation = HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA1;\r\nelse if (is_color_space_decimation(hdmi))\r\ndecimation = HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA3;\r\nif (hdmi->hdmi_data.enc_color_depth == 8)\r\ncolor_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_24BPP;\r\nelse if (hdmi->hdmi_data.enc_color_depth == 10)\r\ncolor_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_30BPP;\r\nelse if (hdmi->hdmi_data.enc_color_depth == 12)\r\ncolor_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_36BPP;\r\nelse if (hdmi->hdmi_data.enc_color_depth == 16)\r\ncolor_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_48BPP;\r\nelse\r\nreturn;\r\nhdmi_writeb(hdmi, interpolation | decimation, HDMI_CSC_CFG);\r\nhdmi_modb(hdmi, color_depth, HDMI_CSC_SCALE_CSC_COLORDE_PTH_MASK,\r\nHDMI_CSC_SCALE);\r\nimx_hdmi_update_csc_coeffs(hdmi);\r\n}\r\nstatic void hdmi_video_packetize(struct imx_hdmi *hdmi)\r\n{\r\nunsigned int color_depth = 0;\r\nunsigned int remap_size = HDMI_VP_REMAP_YCC422_16bit;\r\nunsigned int output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_PP;\r\nstruct hdmi_data_info *hdmi_data = &hdmi->hdmi_data;\r\nu8 val, vp_conf;\r\nif (hdmi_data->enc_out_format == RGB\r\n|| hdmi_data->enc_out_format == YCBCR444) {\r\nif (!hdmi_data->enc_color_depth)\r\noutput_select = HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS;\r\nelse if (hdmi_data->enc_color_depth == 8) {\r\ncolor_depth = 4;\r\noutput_select = HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS;\r\n} else if (hdmi_data->enc_color_depth == 10)\r\ncolor_depth = 5;\r\nelse if (hdmi_data->enc_color_depth == 12)\r\ncolor_depth = 6;\r\nelse if (hdmi_data->enc_color_depth == 16)\r\ncolor_depth = 7;\r\nelse\r\nreturn;\r\n} else if (hdmi_data->enc_out_format == YCBCR422_8BITS) {\r\nif (!hdmi_data->enc_color_depth ||\r\nhdmi_data->enc_color_depth == 8)\r\nremap_size = HDMI_VP_REMAP_YCC422_16bit;\r\nelse if (hdmi_data->enc_color_depth == 10)\r\nremap_size = HDMI_VP_REMAP_YCC422_20bit;\r\nelse if (hdmi_data->enc_color_depth == 12)\r\nremap_size = HDMI_VP_REMAP_YCC422_24bit;\r\nelse\r\nreturn;\r\noutput_select = HDMI_VP_CONF_OUTPUT_SELECTOR_YCC422;\r\n} else\r\nreturn;\r\nval = ((color_depth << HDMI_VP_PR_CD_COLOR_DEPTH_OFFSET) &\r\nHDMI_VP_PR_CD_COLOR_DEPTH_MASK) |\r\n((hdmi_data->pix_repet_factor <<\r\nHDMI_VP_PR_CD_DESIRED_PR_FACTOR_OFFSET) &\r\nHDMI_VP_PR_CD_DESIRED_PR_FACTOR_MASK);\r\nhdmi_writeb(hdmi, val, HDMI_VP_PR_CD);\r\nhdmi_modb(hdmi, HDMI_VP_STUFF_PR_STUFFING_STUFFING_MODE,\r\nHDMI_VP_STUFF_PR_STUFFING_MASK, HDMI_VP_STUFF);\r\nif (hdmi_data->pix_repet_factor > 1) {\r\nvp_conf = HDMI_VP_CONF_PR_EN_ENABLE |\r\nHDMI_VP_CONF_BYPASS_SELECT_PIX_REPEATER;\r\n} else {\r\nvp_conf = HDMI_VP_CONF_PR_EN_DISABLE |\r\nHDMI_VP_CONF_BYPASS_SELECT_VID_PACKETIZER;\r\n}\r\nhdmi_modb(hdmi, vp_conf,\r\nHDMI_VP_CONF_PR_EN_MASK |\r\nHDMI_VP_CONF_BYPASS_SELECT_MASK, HDMI_VP_CONF);\r\nhdmi_modb(hdmi, 1 << HDMI_VP_STUFF_IDEFAULT_PHASE_OFFSET,\r\nHDMI_VP_STUFF_IDEFAULT_PHASE_MASK, HDMI_VP_STUFF);\r\nhdmi_writeb(hdmi, remap_size, HDMI_VP_REMAP);\r\nif (output_select == HDMI_VP_CONF_OUTPUT_SELECTOR_PP) {\r\nvp_conf = HDMI_VP_CONF_BYPASS_EN_DISABLE |\r\nHDMI_VP_CONF_PP_EN_ENABLE |\r\nHDMI_VP_CONF_YCC422_EN_DISABLE;\r\n} else if (output_select == HDMI_VP_CONF_OUTPUT_SELECTOR_YCC422) {\r\nvp_conf = HDMI_VP_CONF_BYPASS_EN_DISABLE |\r\nHDMI_VP_CONF_PP_EN_DISABLE |\r\nHDMI_VP_CONF_YCC422_EN_ENABLE;\r\n} else if (output_select == HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS) {\r\nvp_conf = HDMI_VP_CONF_BYPASS_EN_ENABLE |\r\nHDMI_VP_CONF_PP_EN_DISABLE |\r\nHDMI_VP_CONF_YCC422_EN_DISABLE;\r\n} else {\r\nreturn;\r\n}\r\nhdmi_modb(hdmi, vp_conf,\r\nHDMI_VP_CONF_BYPASS_EN_MASK | HDMI_VP_CONF_PP_EN_ENMASK |\r\nHDMI_VP_CONF_YCC422_EN_MASK, HDMI_VP_CONF);\r\nhdmi_modb(hdmi, HDMI_VP_STUFF_PP_STUFFING_STUFFING_MODE |\r\nHDMI_VP_STUFF_YCC422_STUFFING_STUFFING_MODE,\r\nHDMI_VP_STUFF_PP_STUFFING_MASK |\r\nHDMI_VP_STUFF_YCC422_STUFFING_MASK, HDMI_VP_STUFF);\r\nhdmi_modb(hdmi, output_select, HDMI_VP_CONF_OUTPUT_SELECTOR_MASK,\r\nHDMI_VP_CONF);\r\n}\r\nstatic inline void hdmi_phy_test_clear(struct imx_hdmi *hdmi,\r\nunsigned char bit)\r\n{\r\nhdmi_modb(hdmi, bit << HDMI_PHY_TST0_TSTCLR_OFFSET,\r\nHDMI_PHY_TST0_TSTCLR_MASK, HDMI_PHY_TST0);\r\n}\r\nstatic inline void hdmi_phy_test_enable(struct imx_hdmi *hdmi,\r\nunsigned char bit)\r\n{\r\nhdmi_modb(hdmi, bit << HDMI_PHY_TST0_TSTEN_OFFSET,\r\nHDMI_PHY_TST0_TSTEN_MASK, HDMI_PHY_TST0);\r\n}\r\nstatic inline void hdmi_phy_test_clock(struct imx_hdmi *hdmi,\r\nunsigned char bit)\r\n{\r\nhdmi_modb(hdmi, bit << HDMI_PHY_TST0_TSTCLK_OFFSET,\r\nHDMI_PHY_TST0_TSTCLK_MASK, HDMI_PHY_TST0);\r\n}\r\nstatic inline void hdmi_phy_test_din(struct imx_hdmi *hdmi,\r\nunsigned char bit)\r\n{\r\nhdmi_writeb(hdmi, bit, HDMI_PHY_TST1);\r\n}\r\nstatic inline void hdmi_phy_test_dout(struct imx_hdmi *hdmi,\r\nunsigned char bit)\r\n{\r\nhdmi_writeb(hdmi, bit, HDMI_PHY_TST2);\r\n}\r\nstatic bool hdmi_phy_wait_i2c_done(struct imx_hdmi *hdmi, int msec)\r\n{\r\nwhile ((hdmi_readb(hdmi, HDMI_IH_I2CMPHY_STAT0) & 0x3) == 0) {\r\nif (msec-- == 0)\r\nreturn false;\r\nudelay(1000);\r\n}\r\nreturn true;\r\n}\r\nstatic void __hdmi_phy_i2c_write(struct imx_hdmi *hdmi, unsigned short data,\r\nunsigned char addr)\r\n{\r\nhdmi_writeb(hdmi, 0xFF, HDMI_IH_I2CMPHY_STAT0);\r\nhdmi_writeb(hdmi, addr, HDMI_PHY_I2CM_ADDRESS_ADDR);\r\nhdmi_writeb(hdmi, (unsigned char)(data >> 8),\r\nHDMI_PHY_I2CM_DATAO_1_ADDR);\r\nhdmi_writeb(hdmi, (unsigned char)(data >> 0),\r\nHDMI_PHY_I2CM_DATAO_0_ADDR);\r\nhdmi_writeb(hdmi, HDMI_PHY_I2CM_OPERATION_ADDR_WRITE,\r\nHDMI_PHY_I2CM_OPERATION_ADDR);\r\nhdmi_phy_wait_i2c_done(hdmi, 1000);\r\n}\r\nstatic int hdmi_phy_i2c_write(struct imx_hdmi *hdmi, unsigned short data,\r\nunsigned char addr)\r\n{\r\n__hdmi_phy_i2c_write(hdmi, data, addr);\r\nreturn 0;\r\n}\r\nstatic void imx_hdmi_phy_enable_power(struct imx_hdmi *hdmi, u8 enable)\r\n{\r\nhdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,\r\nHDMI_PHY_CONF0_PDZ_OFFSET,\r\nHDMI_PHY_CONF0_PDZ_MASK);\r\n}\r\nstatic void imx_hdmi_phy_enable_tmds(struct imx_hdmi *hdmi, u8 enable)\r\n{\r\nhdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,\r\nHDMI_PHY_CONF0_ENTMDS_OFFSET,\r\nHDMI_PHY_CONF0_ENTMDS_MASK);\r\n}\r\nstatic void imx_hdmi_phy_gen2_pddq(struct imx_hdmi *hdmi, u8 enable)\r\n{\r\nhdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,\r\nHDMI_PHY_CONF0_GEN2_PDDQ_OFFSET,\r\nHDMI_PHY_CONF0_GEN2_PDDQ_MASK);\r\n}\r\nstatic void imx_hdmi_phy_gen2_txpwron(struct imx_hdmi *hdmi, u8 enable)\r\n{\r\nhdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,\r\nHDMI_PHY_CONF0_GEN2_TXPWRON_OFFSET,\r\nHDMI_PHY_CONF0_GEN2_TXPWRON_MASK);\r\n}\r\nstatic void imx_hdmi_phy_sel_data_en_pol(struct imx_hdmi *hdmi, u8 enable)\r\n{\r\nhdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,\r\nHDMI_PHY_CONF0_SELDATAENPOL_OFFSET,\r\nHDMI_PHY_CONF0_SELDATAENPOL_MASK);\r\n}\r\nstatic void imx_hdmi_phy_sel_interface_control(struct imx_hdmi *hdmi, u8 enable)\r\n{\r\nhdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,\r\nHDMI_PHY_CONF0_SELDIPIF_OFFSET,\r\nHDMI_PHY_CONF0_SELDIPIF_MASK);\r\n}\r\nstatic int hdmi_phy_configure(struct imx_hdmi *hdmi, unsigned char prep,\r\nunsigned char res, int cscon)\r\n{\r\nunsigned res_idx, i;\r\nu8 val, msec;\r\nif (prep)\r\nreturn -EINVAL;\r\nswitch (res) {\r\ncase 0:\r\ncase 8:\r\nres_idx = RES_8;\r\nbreak;\r\ncase 10:\r\nres_idx = RES_10;\r\nbreak;\r\ncase 12:\r\nres_idx = RES_12;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (cscon)\r\nval = HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_IN_PATH;\r\nelse\r\nval = HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_BYPASS;\r\nhdmi_writeb(hdmi, val, HDMI_MC_FLOWCTRL);\r\nimx_hdmi_phy_gen2_txpwron(hdmi, 0);\r\nimx_hdmi_phy_gen2_pddq(hdmi, 1);\r\nhdmi_writeb(hdmi, HDMI_MC_PHYRSTZ_DEASSERT, HDMI_MC_PHYRSTZ);\r\nhdmi_writeb(hdmi, HDMI_MC_PHYRSTZ_ASSERT, HDMI_MC_PHYRSTZ);\r\nhdmi_writeb(hdmi, HDMI_MC_HEACPHY_RST_ASSERT, HDMI_MC_HEACPHY_RST);\r\nhdmi_phy_test_clear(hdmi, 1);\r\nhdmi_writeb(hdmi, HDMI_PHY_I2CM_SLAVE_ADDR_PHY_GEN2,\r\nHDMI_PHY_I2CM_SLAVE_ADDR);\r\nhdmi_phy_test_clear(hdmi, 0);\r\nfor (i = 0; i < ARRAY_SIZE(mpll_config) - 1; i++)\r\nif (hdmi->hdmi_data.video_mode.mpixelclock <=\r\nmpll_config[i].mpixelclock)\r\nbreak;\r\nhdmi_phy_i2c_write(hdmi, mpll_config[i].res[res_idx].cpce, 0x06);\r\nhdmi_phy_i2c_write(hdmi, mpll_config[i].res[res_idx].gmp, 0x15);\r\nfor (i = 0; i < ARRAY_SIZE(curr_ctrl); i++)\r\nif (hdmi->hdmi_data.video_mode.mpixelclock <=\r\ncurr_ctrl[i].mpixelclock)\r\nbreak;\r\nif (i >= ARRAY_SIZE(curr_ctrl)) {\r\ndev_err(hdmi->dev,\r\n"Pixel clock %d - unsupported by HDMI\n",\r\nhdmi->hdmi_data.video_mode.mpixelclock);\r\nreturn -EINVAL;\r\n}\r\nhdmi_phy_i2c_write(hdmi, curr_ctrl[i].curr[res_idx], 0x10);\r\nhdmi_phy_i2c_write(hdmi, 0x0000, 0x13);\r\nhdmi_phy_i2c_write(hdmi, 0x0006, 0x17);\r\nhdmi_phy_i2c_write(hdmi, 0x0005, 0x19);\r\nhdmi_phy_i2c_write(hdmi, 0x800d, 0x09);\r\nhdmi_phy_i2c_write(hdmi, 0x01ad, 0x0E);\r\nhdmi_phy_i2c_write(hdmi, 0x8000, 0x05);\r\nimx_hdmi_phy_enable_power(hdmi, 1);\r\nimx_hdmi_phy_enable_tmds(hdmi, 0);\r\nimx_hdmi_phy_enable_tmds(hdmi, 1);\r\nimx_hdmi_phy_gen2_txpwron(hdmi, 1);\r\nimx_hdmi_phy_gen2_pddq(hdmi, 0);\r\nmsec = 5;\r\ndo {\r\nval = hdmi_readb(hdmi, HDMI_PHY_STAT0) & HDMI_PHY_TX_PHY_LOCK;\r\nif (!val)\r\nbreak;\r\nif (msec == 0) {\r\ndev_err(hdmi->dev, "PHY PLL not locked\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nudelay(1000);\r\nmsec--;\r\n} while (1);\r\nreturn 0;\r\n}\r\nstatic int imx_hdmi_phy_init(struct imx_hdmi *hdmi)\r\n{\r\nint i, ret;\r\nbool cscon = false;\r\ncscon = (is_color_space_conversion(hdmi) &&\r\n!hdmi->hdmi_data.video_mode.mdvi);\r\nfor (i = 0; i < 2; i++) {\r\nimx_hdmi_phy_sel_data_en_pol(hdmi, 1);\r\nimx_hdmi_phy_sel_interface_control(hdmi, 0);\r\nimx_hdmi_phy_enable_tmds(hdmi, 0);\r\nimx_hdmi_phy_enable_power(hdmi, 0);\r\nret = hdmi_phy_configure(hdmi, 0, 8, cscon);\r\nif (ret)\r\nreturn ret;\r\n}\r\nhdmi->phy_enabled = true;\r\nreturn 0;\r\n}\r\nstatic void hdmi_tx_hdcp_config(struct imx_hdmi *hdmi)\r\n{\r\nu8 de;\r\nif (hdmi->hdmi_data.video_mode.mdataenablepolarity)\r\nde = HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_HIGH;\r\nelse\r\nde = HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_LOW;\r\nhdmi_modb(hdmi, HDMI_A_HDCPCFG0_RXDETECT_DISABLE,\r\nHDMI_A_HDCPCFG0_RXDETECT_MASK, HDMI_A_HDCPCFG0);\r\nhdmi_modb(hdmi, de, HDMI_A_VIDPOLCFG_DATAENPOL_MASK, HDMI_A_VIDPOLCFG);\r\nhdmi_modb(hdmi, HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_DISABLE,\r\nHDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_MASK, HDMI_A_HDCPCFG1);\r\n}\r\nstatic void hdmi_config_AVI(struct imx_hdmi *hdmi)\r\n{\r\nu8 val, pix_fmt, under_scan;\r\nu8 act_ratio, coded_ratio, colorimetry, ext_colorimetry;\r\nbool aspect_16_9;\r\naspect_16_9 = false;\r\nif (hdmi->hdmi_data.enc_out_format == YCBCR444)\r\npix_fmt = HDMI_FC_AVICONF0_PIX_FMT_YCBCR444;\r\nelse if (hdmi->hdmi_data.enc_out_format == YCBCR422_8BITS)\r\npix_fmt = HDMI_FC_AVICONF0_PIX_FMT_YCBCR422;\r\nelse\r\npix_fmt = HDMI_FC_AVICONF0_PIX_FMT_RGB;\r\nunder_scan = HDMI_FC_AVICONF0_SCAN_INFO_NODATA;\r\nval = pix_fmt | under_scan |\r\nHDMI_FC_AVICONF0_ACTIVE_FMT_INFO_PRESENT |\r\nHDMI_FC_AVICONF0_BAR_DATA_NO_DATA;\r\nhdmi_writeb(hdmi, val, HDMI_FC_AVICONF0);\r\nif (aspect_16_9) {\r\nact_ratio = HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_16_9;\r\ncoded_ratio = HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_16_9;\r\n} else {\r\nact_ratio = HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_4_3;\r\ncoded_ratio = HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_4_3;\r\n}\r\nif (hdmi->hdmi_data.enc_out_format == XVYCC444) {\r\ncolorimetry = HDMI_FC_AVICONF1_COLORIMETRY_EXTENDED_INFO;\r\nif (hdmi->hdmi_data.colorimetry == HDMI_COLORIMETRY_ITU_601)\r\next_colorimetry =\r\nHDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC601;\r\nelse\r\next_colorimetry =\r\nHDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC709;\r\n} else if (hdmi->hdmi_data.enc_out_format != RGB) {\r\nif (hdmi->hdmi_data.colorimetry == HDMI_COLORIMETRY_ITU_601)\r\ncolorimetry = HDMI_FC_AVICONF1_COLORIMETRY_SMPTE;\r\nelse\r\ncolorimetry = HDMI_FC_AVICONF1_COLORIMETRY_ITUR;\r\next_colorimetry = HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC601;\r\n} else {\r\ncolorimetry = HDMI_FC_AVICONF1_COLORIMETRY_NO_DATA;\r\next_colorimetry = HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC601;\r\n}\r\nval = colorimetry | coded_ratio | act_ratio;\r\nhdmi_writeb(hdmi, val, HDMI_FC_AVICONF1);\r\nval = HDMI_FC_AVICONF2_IT_CONTENT_NO_DATA | ext_colorimetry |\r\nHDMI_FC_AVICONF2_RGB_QUANT_DEFAULT |\r\nHDMI_FC_AVICONF2_SCALING_NONE;\r\nhdmi_writeb(hdmi, val, HDMI_FC_AVICONF2);\r\nhdmi_writeb(hdmi, hdmi->vic, HDMI_FC_AVIVID);\r\nval = (((hdmi->hdmi_data.video_mode.mpixelrepetitioninput + 1) <<\r\nHDMI_FC_PRCONF_INCOMING_PR_FACTOR_OFFSET) &\r\nHDMI_FC_PRCONF_INCOMING_PR_FACTOR_MASK) |\r\n((hdmi->hdmi_data.video_mode.mpixelrepetitionoutput <<\r\nHDMI_FC_PRCONF_OUTPUT_PR_FACTOR_OFFSET) &\r\nHDMI_FC_PRCONF_OUTPUT_PR_FACTOR_MASK);\r\nhdmi_writeb(hdmi, val, HDMI_FC_PRCONF);\r\nval = HDMI_FC_AVICONF3_IT_CONTENT_TYPE_GRAPHICS |\r\nHDMI_FC_AVICONF3_QUANT_RANGE_LIMITED;\r\nhdmi_writeb(hdmi, val, HDMI_FC_AVICONF3);\r\nhdmi_writeb(hdmi, 0, HDMI_FC_AVIETB0);\r\nhdmi_writeb(hdmi, 0, HDMI_FC_AVIETB1);\r\nhdmi_writeb(hdmi, 0, HDMI_FC_AVISBB0);\r\nhdmi_writeb(hdmi, 0, HDMI_FC_AVISBB1);\r\nhdmi_writeb(hdmi, 0, HDMI_FC_AVIELB0);\r\nhdmi_writeb(hdmi, 0, HDMI_FC_AVIELB1);\r\nhdmi_writeb(hdmi, 0, HDMI_FC_AVISRB0);\r\nhdmi_writeb(hdmi, 0, HDMI_FC_AVISRB1);\r\n}\r\nstatic void hdmi_av_composer(struct imx_hdmi *hdmi,\r\nconst struct drm_display_mode *mode)\r\n{\r\nu8 inv_val;\r\nstruct hdmi_vmode *vmode = &hdmi->hdmi_data.video_mode;\r\nint hblank, vblank, h_de_hs, v_de_vs, hsync_len, vsync_len;\r\nvmode->mhsyncpolarity = !!(mode->flags & DRM_MODE_FLAG_PHSYNC);\r\nvmode->mvsyncpolarity = !!(mode->flags & DRM_MODE_FLAG_PVSYNC);\r\nvmode->minterlaced = !!(mode->flags & DRM_MODE_FLAG_INTERLACE);\r\nvmode->mpixelclock = mode->clock * 1000;\r\ndev_dbg(hdmi->dev, "final pixclk = %d\n", vmode->mpixelclock);\r\ninv_val = (hdmi->hdmi_data.hdcp_enable ?\r\nHDMI_FC_INVIDCONF_HDCP_KEEPOUT_ACTIVE :\r\nHDMI_FC_INVIDCONF_HDCP_KEEPOUT_INACTIVE);\r\ninv_val |= (vmode->mvsyncpolarity ?\r\nHDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_HIGH :\r\nHDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_LOW);\r\ninv_val |= (vmode->mhsyncpolarity ?\r\nHDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_HIGH :\r\nHDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_LOW);\r\ninv_val |= (vmode->mdataenablepolarity ?\r\nHDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_HIGH :\r\nHDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_LOW);\r\nif (hdmi->vic == 39)\r\ninv_val |= HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH;\r\nelse\r\ninv_val |= (vmode->minterlaced ?\r\nHDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH :\r\nHDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_LOW);\r\ninv_val |= (vmode->minterlaced ?\r\nHDMI_FC_INVIDCONF_IN_I_P_INTERLACED :\r\nHDMI_FC_INVIDCONF_IN_I_P_PROGRESSIVE);\r\ninv_val |= (vmode->mdvi ?\r\nHDMI_FC_INVIDCONF_DVI_MODEZ_DVI_MODE :\r\nHDMI_FC_INVIDCONF_DVI_MODEZ_HDMI_MODE);\r\nhdmi_writeb(hdmi, inv_val, HDMI_FC_INVIDCONF);\r\nhdmi_writeb(hdmi, mode->hdisplay >> 8, HDMI_FC_INHACTV1);\r\nhdmi_writeb(hdmi, mode->hdisplay, HDMI_FC_INHACTV0);\r\nhdmi_writeb(hdmi, mode->vdisplay >> 8, HDMI_FC_INVACTV1);\r\nhdmi_writeb(hdmi, mode->vdisplay, HDMI_FC_INVACTV0);\r\nhblank = mode->htotal - mode->hdisplay;\r\nhdmi_writeb(hdmi, hblank >> 8, HDMI_FC_INHBLANK1);\r\nhdmi_writeb(hdmi, hblank, HDMI_FC_INHBLANK0);\r\nvblank = mode->vtotal - mode->vdisplay;\r\nhdmi_writeb(hdmi, vblank, HDMI_FC_INVBLANK);\r\nh_de_hs = mode->hsync_start - mode->hdisplay;\r\nhdmi_writeb(hdmi, h_de_hs >> 8, HDMI_FC_HSYNCINDELAY1);\r\nhdmi_writeb(hdmi, h_de_hs, HDMI_FC_HSYNCINDELAY0);\r\nv_de_vs = mode->vsync_start - mode->vdisplay;\r\nhdmi_writeb(hdmi, v_de_vs, HDMI_FC_VSYNCINDELAY);\r\nhsync_len = mode->hsync_end - mode->hsync_start;\r\nhdmi_writeb(hdmi, hsync_len >> 8, HDMI_FC_HSYNCINWIDTH1);\r\nhdmi_writeb(hdmi, hsync_len, HDMI_FC_HSYNCINWIDTH0);\r\nvsync_len = mode->vsync_end - mode->vsync_start;\r\nhdmi_writeb(hdmi, vsync_len, HDMI_FC_VSYNCINWIDTH);\r\n}\r\nstatic void imx_hdmi_phy_disable(struct imx_hdmi *hdmi)\r\n{\r\nif (!hdmi->phy_enabled)\r\nreturn;\r\nimx_hdmi_phy_enable_tmds(hdmi, 0);\r\nimx_hdmi_phy_enable_power(hdmi, 0);\r\nhdmi->phy_enabled = false;\r\n}\r\nstatic void imx_hdmi_enable_video_path(struct imx_hdmi *hdmi)\r\n{\r\nu8 clkdis;\r\nhdmi_writeb(hdmi, 12, HDMI_FC_CTRLDUR);\r\nhdmi_writeb(hdmi, 32, HDMI_FC_EXCTRLDUR);\r\nhdmi_writeb(hdmi, 1, HDMI_FC_EXCTRLSPAC);\r\nhdmi_writeb(hdmi, 0x0B, HDMI_FC_CH0PREAM);\r\nhdmi_writeb(hdmi, 0x16, HDMI_FC_CH1PREAM);\r\nhdmi_writeb(hdmi, 0x21, HDMI_FC_CH2PREAM);\r\nclkdis = 0x7F;\r\nclkdis &= ~HDMI_MC_CLKDIS_PIXELCLK_DISABLE;\r\nhdmi_writeb(hdmi, clkdis, HDMI_MC_CLKDIS);\r\nclkdis &= ~HDMI_MC_CLKDIS_TMDSCLK_DISABLE;\r\nhdmi_writeb(hdmi, clkdis, HDMI_MC_CLKDIS);\r\nif (is_color_space_conversion(hdmi)) {\r\nclkdis &= ~HDMI_MC_CLKDIS_CSCCLK_DISABLE;\r\nhdmi_writeb(hdmi, clkdis, HDMI_MC_CLKDIS);\r\n}\r\n}\r\nstatic void hdmi_enable_audio_clk(struct imx_hdmi *hdmi)\r\n{\r\nhdmi_modb(hdmi, 0, HDMI_MC_CLKDIS_AUDCLK_DISABLE, HDMI_MC_CLKDIS);\r\n}\r\nstatic void imx_hdmi_clear_overflow(struct imx_hdmi *hdmi)\r\n{\r\nint count;\r\nu8 val;\r\nhdmi_writeb(hdmi, (u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ, HDMI_MC_SWRSTZ);\r\nval = hdmi_readb(hdmi, HDMI_FC_INVIDCONF);\r\nif (hdmi->dev_type == IMX6DL_HDMI) {\r\nhdmi_writeb(hdmi, val, HDMI_FC_INVIDCONF);\r\nreturn;\r\n}\r\nfor (count = 0; count < 4; count++)\r\nhdmi_writeb(hdmi, val, HDMI_FC_INVIDCONF);\r\n}\r\nstatic void hdmi_enable_overflow_interrupts(struct imx_hdmi *hdmi)\r\n{\r\nhdmi_writeb(hdmi, 0, HDMI_FC_MASK2);\r\nhdmi_writeb(hdmi, 0, HDMI_IH_MUTE_FC_STAT2);\r\n}\r\nstatic void hdmi_disable_overflow_interrupts(struct imx_hdmi *hdmi)\r\n{\r\nhdmi_writeb(hdmi, HDMI_IH_MUTE_FC_STAT2_OVERFLOW_MASK,\r\nHDMI_IH_MUTE_FC_STAT2);\r\n}\r\nstatic int imx_hdmi_setup(struct imx_hdmi *hdmi, struct drm_display_mode *mode)\r\n{\r\nint ret;\r\nhdmi_disable_overflow_interrupts(hdmi);\r\nhdmi->vic = drm_match_cea_mode(mode);\r\nif (!hdmi->vic) {\r\ndev_dbg(hdmi->dev, "Non-CEA mode used in HDMI\n");\r\nhdmi->hdmi_data.video_mode.mdvi = true;\r\n} else {\r\ndev_dbg(hdmi->dev, "CEA mode used vic=%d\n", hdmi->vic);\r\nhdmi->hdmi_data.video_mode.mdvi = false;\r\n}\r\nif ((hdmi->vic == 6) || (hdmi->vic == 7) ||\r\n(hdmi->vic == 21) || (hdmi->vic == 22) ||\r\n(hdmi->vic == 2) || (hdmi->vic == 3) ||\r\n(hdmi->vic == 17) || (hdmi->vic == 18))\r\nhdmi->hdmi_data.colorimetry = HDMI_COLORIMETRY_ITU_601;\r\nelse\r\nhdmi->hdmi_data.colorimetry = HDMI_COLORIMETRY_ITU_709;\r\nif ((hdmi->vic == 10) || (hdmi->vic == 11) ||\r\n(hdmi->vic == 12) || (hdmi->vic == 13) ||\r\n(hdmi->vic == 14) || (hdmi->vic == 15) ||\r\n(hdmi->vic == 25) || (hdmi->vic == 26) ||\r\n(hdmi->vic == 27) || (hdmi->vic == 28) ||\r\n(hdmi->vic == 29) || (hdmi->vic == 30) ||\r\n(hdmi->vic == 35) || (hdmi->vic == 36) ||\r\n(hdmi->vic == 37) || (hdmi->vic == 38))\r\nhdmi->hdmi_data.video_mode.mpixelrepetitionoutput = 1;\r\nelse\r\nhdmi->hdmi_data.video_mode.mpixelrepetitionoutput = 0;\r\nhdmi->hdmi_data.video_mode.mpixelrepetitioninput = 0;\r\nhdmi->hdmi_data.enc_in_format = RGB;\r\nhdmi->hdmi_data.enc_out_format = RGB;\r\nhdmi->hdmi_data.enc_color_depth = 8;\r\nhdmi->hdmi_data.pix_repet_factor = 0;\r\nhdmi->hdmi_data.hdcp_enable = 0;\r\nhdmi->hdmi_data.video_mode.mdataenablepolarity = true;\r\nhdmi_av_composer(hdmi, mode);\r\nret = imx_hdmi_phy_init(hdmi);\r\nif (ret)\r\nreturn ret;\r\nimx_hdmi_enable_video_path(hdmi);\r\nif (hdmi->hdmi_data.video_mode.mdvi)\r\ndev_dbg(hdmi->dev, "%s DVI mode\n", __func__);\r\nelse {\r\ndev_dbg(hdmi->dev, "%s CEA mode\n", __func__);\r\nhdmi_clk_regenerator_update_pixel_clock(hdmi);\r\nhdmi_enable_audio_clk(hdmi);\r\nhdmi_config_AVI(hdmi);\r\n}\r\nhdmi_video_packetize(hdmi);\r\nhdmi_video_csc(hdmi);\r\nhdmi_video_sample(hdmi);\r\nhdmi_tx_hdcp_config(hdmi);\r\nimx_hdmi_clear_overflow(hdmi);\r\nif (hdmi->cable_plugin && !hdmi->hdmi_data.video_mode.mdvi)\r\nhdmi_enable_overflow_interrupts(hdmi);\r\nreturn 0;\r\n}\r\nstatic int imx_hdmi_fb_registered(struct imx_hdmi *hdmi)\r\n{\r\nhdmi_writeb(hdmi, HDMI_PHY_I2CM_INT_ADDR_DONE_POL,\r\nHDMI_PHY_I2CM_INT_ADDR);\r\nhdmi_writeb(hdmi, HDMI_PHY_I2CM_CTLINT_ADDR_NAC_POL |\r\nHDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_POL,\r\nHDMI_PHY_I2CM_CTLINT_ADDR);\r\nhdmi_writeb(hdmi, (u8)~HDMI_PHY_HPD, HDMI_PHY_MASK0);\r\nhdmi_writeb(hdmi, HDMI_IH_PHY_STAT0_HPD, HDMI_IH_PHY_STAT0);\r\nreturn 0;\r\n}\r\nstatic void initialize_hdmi_ih_mutes(struct imx_hdmi *hdmi)\r\n{\r\nu8 ih_mute;\r\nih_mute = hdmi_readb(hdmi, HDMI_IH_MUTE) |\r\nHDMI_IH_MUTE_MUTE_WAKEUP_INTERRUPT |\r\nHDMI_IH_MUTE_MUTE_ALL_INTERRUPT;\r\nhdmi_writeb(hdmi, ih_mute, HDMI_IH_MUTE);\r\nhdmi_writeb(hdmi, 0xff, HDMI_VP_MASK);\r\nhdmi_writeb(hdmi, 0xff, HDMI_FC_MASK0);\r\nhdmi_writeb(hdmi, 0xff, HDMI_FC_MASK1);\r\nhdmi_writeb(hdmi, 0xff, HDMI_FC_MASK2);\r\nhdmi_writeb(hdmi, 0xff, HDMI_PHY_MASK0);\r\nhdmi_writeb(hdmi, 0xff, HDMI_PHY_I2CM_INT_ADDR);\r\nhdmi_writeb(hdmi, 0xff, HDMI_PHY_I2CM_CTLINT_ADDR);\r\nhdmi_writeb(hdmi, 0xff, HDMI_AUD_INT);\r\nhdmi_writeb(hdmi, 0xff, HDMI_AUD_SPDIFINT);\r\nhdmi_writeb(hdmi, 0xff, HDMI_AUD_HBR_MASK);\r\nhdmi_writeb(hdmi, 0xff, HDMI_GP_MASK);\r\nhdmi_writeb(hdmi, 0xff, HDMI_A_APIINTMSK);\r\nhdmi_writeb(hdmi, 0xff, HDMI_CEC_MASK);\r\nhdmi_writeb(hdmi, 0xff, HDMI_I2CM_INT);\r\nhdmi_writeb(hdmi, 0xff, HDMI_I2CM_CTLINT);\r\nhdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_FC_STAT0);\r\nhdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_FC_STAT1);\r\nhdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_FC_STAT2);\r\nhdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_AS_STAT0);\r\nhdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_PHY_STAT0);\r\nhdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_I2CM_STAT0);\r\nhdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_CEC_STAT0);\r\nhdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_VP_STAT0);\r\nhdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_I2CMPHY_STAT0);\r\nhdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_AHBDMAAUD_STAT0);\r\nih_mute &= ~(HDMI_IH_MUTE_MUTE_WAKEUP_INTERRUPT |\r\nHDMI_IH_MUTE_MUTE_ALL_INTERRUPT);\r\nhdmi_writeb(hdmi, ih_mute, HDMI_IH_MUTE);\r\n}\r\nstatic void imx_hdmi_poweron(struct imx_hdmi *hdmi)\r\n{\r\nimx_hdmi_setup(hdmi, &hdmi->previous_mode);\r\n}\r\nstatic void imx_hdmi_poweroff(struct imx_hdmi *hdmi)\r\n{\r\nimx_hdmi_phy_disable(hdmi);\r\n}\r\nstatic enum drm_connector_status imx_hdmi_connector_detect(struct drm_connector\r\n*connector, bool force)\r\n{\r\nstruct imx_hdmi *hdmi = container_of(connector, struct imx_hdmi,\r\nconnector);\r\nreturn hdmi_readb(hdmi, HDMI_PHY_STAT0) & HDMI_PHY_HPD ?\r\nconnector_status_connected : connector_status_disconnected;\r\n}\r\nstatic int imx_hdmi_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct imx_hdmi *hdmi = container_of(connector, struct imx_hdmi,\r\nconnector);\r\nstruct edid *edid;\r\nint ret;\r\nif (!hdmi->ddc)\r\nreturn 0;\r\nedid = drm_get_edid(connector, hdmi->ddc);\r\nif (edid) {\r\ndev_dbg(hdmi->dev, "got edid: width[%d] x height[%d]\n",\r\nedid->width_cm, edid->height_cm);\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\nret = drm_add_edid_modes(connector, edid);\r\nkfree(edid);\r\n} else {\r\ndev_dbg(hdmi->dev, "failed to get edid\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic struct drm_encoder *imx_hdmi_connector_best_encoder(struct drm_connector\r\n*connector)\r\n{\r\nstruct imx_hdmi *hdmi = container_of(connector, struct imx_hdmi,\r\nconnector);\r\nreturn &hdmi->encoder;\r\n}\r\nstatic void imx_hdmi_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct imx_hdmi *hdmi = container_of(encoder, struct imx_hdmi, encoder);\r\nimx_hdmi_setup(hdmi, mode);\r\nmemcpy(&hdmi->previous_mode, mode, sizeof(hdmi->previous_mode));\r\n}\r\nstatic bool imx_hdmi_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void imx_hdmi_encoder_disable(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void imx_hdmi_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct imx_hdmi *hdmi = container_of(encoder, struct imx_hdmi, encoder);\r\nif (mode)\r\nimx_hdmi_poweroff(hdmi);\r\nelse\r\nimx_hdmi_poweron(hdmi);\r\n}\r\nstatic void imx_hdmi_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\nstruct imx_hdmi *hdmi = container_of(encoder, struct imx_hdmi, encoder);\r\nimx_hdmi_poweroff(hdmi);\r\nimx_drm_panel_format(encoder, V4L2_PIX_FMT_RGB24);\r\n}\r\nstatic void imx_hdmi_encoder_commit(struct drm_encoder *encoder)\r\n{\r\nstruct imx_hdmi *hdmi = container_of(encoder, struct imx_hdmi, encoder);\r\nint mux = imx_drm_encoder_get_mux_id(hdmi->dev->of_node, encoder);\r\nimx_hdmi_set_ipu_di_mux(hdmi, mux);\r\nimx_hdmi_poweron(hdmi);\r\n}\r\nstatic irqreturn_t imx_hdmi_hardirq(int irq, void *dev_id)\r\n{\r\nstruct imx_hdmi *hdmi = dev_id;\r\nu8 intr_stat;\r\nintr_stat = hdmi_readb(hdmi, HDMI_IH_PHY_STAT0);\r\nif (intr_stat)\r\nhdmi_writeb(hdmi, ~0, HDMI_IH_MUTE_PHY_STAT0);\r\nreturn intr_stat ? IRQ_WAKE_THREAD : IRQ_NONE;\r\n}\r\nstatic irqreturn_t imx_hdmi_irq(int irq, void *dev_id)\r\n{\r\nstruct imx_hdmi *hdmi = dev_id;\r\nu8 intr_stat;\r\nu8 phy_int_pol;\r\nintr_stat = hdmi_readb(hdmi, HDMI_IH_PHY_STAT0);\r\nphy_int_pol = hdmi_readb(hdmi, HDMI_PHY_POL0);\r\nif (intr_stat & HDMI_IH_PHY_STAT0_HPD) {\r\nif (phy_int_pol & HDMI_PHY_HPD) {\r\ndev_dbg(hdmi->dev, "EVENT=plugin\n");\r\nhdmi_modb(hdmi, 0, HDMI_PHY_HPD, HDMI_PHY_POL0);\r\nimx_hdmi_poweron(hdmi);\r\n} else {\r\ndev_dbg(hdmi->dev, "EVENT=plugout\n");\r\nhdmi_modb(hdmi, HDMI_PHY_HPD, HDMI_PHY_HPD,\r\nHDMI_PHY_POL0);\r\nimx_hdmi_poweroff(hdmi);\r\n}\r\ndrm_helper_hpd_irq_event(hdmi->connector.dev);\r\n}\r\nhdmi_writeb(hdmi, intr_stat, HDMI_IH_PHY_STAT0);\r\nhdmi_writeb(hdmi, ~HDMI_IH_PHY_STAT0_HPD, HDMI_IH_MUTE_PHY_STAT0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int imx_hdmi_register(struct drm_device *drm, struct imx_hdmi *hdmi)\r\n{\r\nint ret;\r\nret = imx_drm_encoder_parse_of(drm, &hdmi->encoder,\r\nhdmi->dev->of_node);\r\nif (ret)\r\nreturn ret;\r\nhdmi->connector.polled = DRM_CONNECTOR_POLL_HPD;\r\ndrm_encoder_helper_add(&hdmi->encoder, &imx_hdmi_encoder_helper_funcs);\r\ndrm_encoder_init(drm, &hdmi->encoder, &imx_hdmi_encoder_funcs,\r\nDRM_MODE_ENCODER_TMDS);\r\ndrm_connector_helper_add(&hdmi->connector,\r\n&imx_hdmi_connector_helper_funcs);\r\ndrm_connector_init(drm, &hdmi->connector, &imx_hdmi_connector_funcs,\r\nDRM_MODE_CONNECTOR_HDMIA);\r\nhdmi->connector.encoder = &hdmi->encoder;\r\ndrm_mode_connector_attach_encoder(&hdmi->connector, &hdmi->encoder);\r\nreturn 0;\r\n}\r\nstatic int imx_hdmi_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nconst struct of_device_id *of_id =\r\nof_match_device(imx_hdmi_dt_ids, dev);\r\nstruct drm_device *drm = data;\r\nstruct device_node *np = dev->of_node;\r\nstruct device_node *ddc_node;\r\nstruct imx_hdmi *hdmi;\r\nstruct resource *iores;\r\nint ret, irq;\r\nhdmi = devm_kzalloc(dev, sizeof(*hdmi), GFP_KERNEL);\r\nif (!hdmi)\r\nreturn -ENOMEM;\r\nhdmi->dev = dev;\r\nhdmi->sample_rate = 48000;\r\nhdmi->ratio = 100;\r\nif (of_id) {\r\nconst struct platform_device_id *device_id = of_id->data;\r\nhdmi->dev_type = device_id->driver_data;\r\n}\r\nddc_node = of_parse_phandle(np, "ddc-i2c-bus", 0);\r\nif (ddc_node) {\r\nhdmi->ddc = of_find_i2c_adapter_by_node(ddc_node);\r\nif (!hdmi->ddc)\r\ndev_dbg(hdmi->dev, "failed to read ddc node\n");\r\nof_node_put(ddc_node);\r\n} else {\r\ndev_dbg(hdmi->dev, "no ddc property found\n");\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nret = devm_request_threaded_irq(dev, irq, imx_hdmi_hardirq,\r\nimx_hdmi_irq, IRQF_SHARED,\r\ndev_name(dev), hdmi);\r\nif (ret)\r\nreturn ret;\r\niores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhdmi->regs = devm_ioremap_resource(dev, iores);\r\nif (IS_ERR(hdmi->regs))\r\nreturn PTR_ERR(hdmi->regs);\r\nhdmi->regmap = syscon_regmap_lookup_by_phandle(np, "gpr");\r\nif (IS_ERR(hdmi->regmap))\r\nreturn PTR_ERR(hdmi->regmap);\r\nhdmi->isfr_clk = devm_clk_get(hdmi->dev, "isfr");\r\nif (IS_ERR(hdmi->isfr_clk)) {\r\nret = PTR_ERR(hdmi->isfr_clk);\r\ndev_err(hdmi->dev,\r\n"Unable to get HDMI isfr clk: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(hdmi->isfr_clk);\r\nif (ret) {\r\ndev_err(hdmi->dev,\r\n"Cannot enable HDMI isfr clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nhdmi->iahb_clk = devm_clk_get(hdmi->dev, "iahb");\r\nif (IS_ERR(hdmi->iahb_clk)) {\r\nret = PTR_ERR(hdmi->iahb_clk);\r\ndev_err(hdmi->dev,\r\n"Unable to get HDMI iahb clk: %d\n", ret);\r\ngoto err_isfr;\r\n}\r\nret = clk_prepare_enable(hdmi->iahb_clk);\r\nif (ret) {\r\ndev_err(hdmi->dev,\r\n"Cannot enable HDMI iahb clock: %d\n", ret);\r\ngoto err_isfr;\r\n}\r\ndev_info(dev,\r\n"Detected HDMI controller 0x%x:0x%x:0x%x:0x%x\n",\r\nhdmi_readb(hdmi, HDMI_DESIGN_ID),\r\nhdmi_readb(hdmi, HDMI_REVISION_ID),\r\nhdmi_readb(hdmi, HDMI_PRODUCT_ID0),\r\nhdmi_readb(hdmi, HDMI_PRODUCT_ID1));\r\ninitialize_hdmi_ih_mutes(hdmi);\r\nhdmi_init_clk_regenerator(hdmi);\r\nhdmi_writeb(hdmi, HDMI_PHY_HPD, HDMI_PHY_POL0);\r\nhdmi_writeb(hdmi, HDMI_IH_PHY_STAT0_HPD, HDMI_IH_PHY_STAT0);\r\nret = imx_hdmi_fb_registered(hdmi);\r\nif (ret)\r\ngoto err_iahb;\r\nret = imx_hdmi_register(drm, hdmi);\r\nif (ret)\r\ngoto err_iahb;\r\nhdmi_writeb(hdmi, ~HDMI_IH_PHY_STAT0_HPD, HDMI_IH_MUTE_PHY_STAT0);\r\ndev_set_drvdata(dev, hdmi);\r\nreturn 0;\r\nerr_iahb:\r\nclk_disable_unprepare(hdmi->iahb_clk);\r\nerr_isfr:\r\nclk_disable_unprepare(hdmi->isfr_clk);\r\nreturn ret;\r\n}\r\nstatic void imx_hdmi_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct imx_hdmi *hdmi = dev_get_drvdata(dev);\r\nhdmi_writeb(hdmi, ~0, HDMI_IH_MUTE_PHY_STAT0);\r\nhdmi->connector.funcs->destroy(&hdmi->connector);\r\nhdmi->encoder.funcs->destroy(&hdmi->encoder);\r\nclk_disable_unprepare(hdmi->iahb_clk);\r\nclk_disable_unprepare(hdmi->isfr_clk);\r\ni2c_put_adapter(hdmi->ddc);\r\n}\r\nstatic int imx_hdmi_platform_probe(struct platform_device *pdev)\r\n{\r\nreturn component_add(&pdev->dev, &hdmi_ops);\r\n}\r\nstatic int imx_hdmi_platform_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &hdmi_ops);\r\nreturn 0;\r\n}
