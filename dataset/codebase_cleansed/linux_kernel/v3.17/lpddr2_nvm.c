static inline map_word build_map_word(u_long myword)\r\n{\r\nmap_word val = { {0} };\r\nval.x[0] = myword;\r\nreturn val;\r\n}\r\nstatic inline u_int build_mr_cfgmask(u_int bus_width)\r\n{\r\nu_int val = MR_CFGMASK;\r\nif (bus_width == 0x0004)\r\nval = val << 16;\r\nreturn val;\r\n}\r\nstatic inline u_int build_sr_ok_datamask(u_int bus_width)\r\n{\r\nu_int val = SR_OK_DATAMASK;\r\nif (bus_width == 0x0004)\r\nval = (val << 16)+val;\r\nreturn val;\r\n}\r\nstatic inline u_long ow_reg_add(struct map_info *map, u_long offset)\r\n{\r\nu_long val = 0;\r\nstruct pcm_int_data *pcm_data = map->fldrv_priv;\r\nval = map->pfow_base + offset*pcm_data->bus_width;\r\nreturn val;\r\n}\r\nstatic inline void ow_enable(struct map_info *map)\r\n{\r\nstruct pcm_int_data *pcm_data = map->fldrv_priv;\r\nwritel_relaxed(build_mr_cfgmask(pcm_data->bus_width) | 0x18,\r\npcm_data->ctl_regs + LPDDR2_MODE_REG_CFG);\r\nwritel_relaxed(0x01, pcm_data->ctl_regs + LPDDR2_MODE_REG_DATA);\r\n}\r\nstatic inline void ow_disable(struct map_info *map)\r\n{\r\nstruct pcm_int_data *pcm_data = map->fldrv_priv;\r\nwritel_relaxed(build_mr_cfgmask(pcm_data->bus_width) | 0x18,\r\npcm_data->ctl_regs + LPDDR2_MODE_REG_CFG);\r\nwritel_relaxed(0x02, pcm_data->ctl_regs + LPDDR2_MODE_REG_DATA);\r\n}\r\nstatic int lpddr2_nvm_do_op(struct map_info *map, u_long cmd_code,\r\nu_long cmd_data, u_long cmd_add, u_long cmd_mpr, u_char *buf)\r\n{\r\nmap_word add_l = { {0} }, add_h = { {0} }, mpr_l = { {0} },\r\nmpr_h = { {0} }, data_l = { {0} }, cmd = { {0} },\r\nexec_cmd = { {0} }, sr;\r\nmap_word data_h = { {0} };\r\nu_long i, status_reg, prg_buff_ofs;\r\nstruct pcm_int_data *pcm_data = map->fldrv_priv;\r\nu_int sr_ok_datamask = build_sr_ok_datamask(pcm_data->bus_width);\r\nadd_l.x[0] = cmd_add & 0x0000FFFF;\r\nadd_h.x[0] = (cmd_add >> 16) & 0x0000FFFF;\r\nmpr_l.x[0] = cmd_mpr & 0x0000FFFF;\r\nmpr_h.x[0] = (cmd_mpr >> 16) & 0x0000FFFF;\r\ncmd.x[0] = cmd_code & 0x0000FFFF;\r\nexec_cmd.x[0] = 0x0001;\r\ndata_l.x[0] = cmd_data & 0x0000FFFF;\r\ndata_h.x[0] = (cmd_data >> 16) & 0x0000FFFF;\r\nmap_write(map, cmd, ow_reg_add(map, CMD_CODE_OFS));\r\nmap_write(map, data_l, ow_reg_add(map, CMD_DATA_OFS));\r\nmap_write(map, add_l, ow_reg_add(map, CMD_ADD_L_OFS));\r\nmap_write(map, add_h, ow_reg_add(map, CMD_ADD_H_OFS));\r\nmap_write(map, mpr_l, ow_reg_add(map, MPR_L_OFS));\r\nmap_write(map, mpr_h, ow_reg_add(map, MPR_H_OFS));\r\nif (pcm_data->bus_width == 0x0004) {\r\nmap_write(map, cmd, ow_reg_add(map, CMD_CODE_OFS) + 2);\r\nmap_write(map, data_h, ow_reg_add(map, CMD_DATA_OFS) + 2);\r\nmap_write(map, add_l, ow_reg_add(map, CMD_ADD_L_OFS) + 2);\r\nmap_write(map, add_h, ow_reg_add(map, CMD_ADD_H_OFS) + 2);\r\nmap_write(map, mpr_l, ow_reg_add(map, MPR_L_OFS) + 2);\r\nmap_write(map, mpr_h, ow_reg_add(map, MPR_H_OFS) + 2);\r\n}\r\nif ((cmd_code == LPDDR2_NVM_BUF_PROGRAM) ||\r\n(cmd_code == LPDDR2_NVM_BUF_OVERWRITE)) {\r\nprg_buff_ofs = (map_read(map,\r\now_reg_add(map, PRG_BUFFER_OFS))).x[0];\r\nfor (i = 0; i < cmd_mpr; i++) {\r\nmap_write(map, build_map_word(buf[i]), map->pfow_base +\r\nprg_buff_ofs + i);\r\n}\r\n}\r\nmap_write(map, exec_cmd, ow_reg_add(map, CMD_EXEC_OFS));\r\nif (pcm_data->bus_width == 0x0004)\r\nmap_write(map, exec_cmd, ow_reg_add(map, CMD_EXEC_OFS) + 2);\r\ndo {\r\nsr = map_read(map, ow_reg_add(map, STATUS_REG_OFS));\r\nstatus_reg = sr.x[0];\r\nif (pcm_data->bus_width == 0x0004) {\r\nsr = map_read(map, ow_reg_add(map,\r\nSTATUS_REG_OFS) + 2);\r\nstatus_reg += sr.x[0] << 16;\r\n}\r\n} while ((status_reg & sr_ok_datamask) != sr_ok_datamask);\r\nreturn (((status_reg & sr_ok_datamask) == sr_ok_datamask) ? 0 : -EIO);\r\n}\r\nstatic int lpddr2_nvm_do_block_op(struct mtd_info *mtd, loff_t start_add,\r\nuint64_t len, u_char block_op)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nu_long add, end_add;\r\nint ret = 0;\r\nmutex_lock(&lpdd2_nvm_mutex);\r\now_enable(map);\r\nadd = start_add;\r\nend_add = add + len;\r\ndo {\r\nret = lpddr2_nvm_do_op(map, block_op, 0x00, add, add, NULL);\r\nif (ret)\r\ngoto out;\r\nadd += mtd->erasesize;\r\n} while (add < end_add);\r\nout:\r\now_disable(map);\r\nmutex_unlock(&lpdd2_nvm_mutex);\r\nreturn ret;\r\n}\r\nstatic int lpddr2_nvm_pfow_present(struct map_info *map)\r\n{\r\nmap_word pfow_val[4];\r\nunsigned int found = 1;\r\nmutex_lock(&lpdd2_nvm_mutex);\r\now_enable(map);\r\npfow_val[0] = map_read(map, ow_reg_add(map, PFOW_QUERY_STRING_P));\r\npfow_val[1] = map_read(map, ow_reg_add(map, PFOW_QUERY_STRING_F));\r\npfow_val[2] = map_read(map, ow_reg_add(map, PFOW_QUERY_STRING_O));\r\npfow_val[3] = map_read(map, ow_reg_add(map, PFOW_QUERY_STRING_W));\r\nif (!map_word_equal(map, build_map_word('P'), pfow_val[0]))\r\nfound = 0;\r\nif (!map_word_equal(map, build_map_word('F'), pfow_val[1]))\r\nfound = 0;\r\nif (!map_word_equal(map, build_map_word('O'), pfow_val[2]))\r\nfound = 0;\r\nif (!map_word_equal(map, build_map_word('W'), pfow_val[3]))\r\nfound = 0;\r\now_disable(map);\r\nmutex_unlock(&lpdd2_nvm_mutex);\r\nreturn found;\r\n}\r\nstatic int lpddr2_nvm_read(struct mtd_info *mtd, loff_t start_add,\r\nsize_t len, size_t *retlen, u_char *buf)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nmutex_lock(&lpdd2_nvm_mutex);\r\n*retlen = len;\r\nmap_copy_from(map, buf, start_add, *retlen);\r\nmutex_unlock(&lpdd2_nvm_mutex);\r\nreturn 0;\r\n}\r\nstatic int lpddr2_nvm_write(struct mtd_info *mtd, loff_t start_add,\r\nsize_t len, size_t *retlen, const u_char *buf)\r\n{\r\nstruct map_info *map = mtd->priv;\r\nstruct pcm_int_data *pcm_data = map->fldrv_priv;\r\nu_long add, current_len, tot_len, target_len, my_data;\r\nu_char *write_buf = (u_char *)buf;\r\nint ret = 0;\r\nmutex_lock(&lpdd2_nvm_mutex);\r\now_enable(map);\r\nadd = start_add;\r\ntarget_len = len;\r\ntot_len = 0;\r\nwhile (tot_len < target_len) {\r\nif (!(IS_ALIGNED(add, mtd->writesize))) {\r\nmy_data = write_buf[tot_len];\r\nmy_data += (write_buf[tot_len+1]) << 8;\r\nif (pcm_data->bus_width == 0x0004) {\r\nmy_data += (write_buf[tot_len+2]) << 16;\r\nmy_data += (write_buf[tot_len+3]) << 24;\r\n}\r\nret = lpddr2_nvm_do_op(map, LPDDR2_NVM_SW_OVERWRITE,\r\nmy_data, add, 0x00, NULL);\r\nif (ret)\r\ngoto out;\r\nadd += pcm_data->bus_width;\r\ntot_len += pcm_data->bus_width;\r\n} else {\r\ncurrent_len = min(target_len - tot_len,\r\n(u_long) mtd->writesize);\r\nret = lpddr2_nvm_do_op(map, LPDDR2_NVM_BUF_OVERWRITE,\r\n0x00, add, current_len, write_buf + tot_len);\r\nif (ret)\r\ngoto out;\r\nadd += current_len;\r\ntot_len += current_len;\r\n}\r\n}\r\nout:\r\n*retlen = tot_len;\r\now_disable(map);\r\nmutex_unlock(&lpdd2_nvm_mutex);\r\nreturn ret;\r\n}\r\nstatic int lpddr2_nvm_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nint ret = lpddr2_nvm_do_block_op(mtd, instr->addr, instr->len,\r\nLPDDR2_NVM_ERASE);\r\nif (!ret) {\r\ninstr->state = MTD_ERASE_DONE;\r\nmtd_erase_callback(instr);\r\n}\r\nreturn ret;\r\n}\r\nstatic int lpddr2_nvm_unlock(struct mtd_info *mtd, loff_t start_add,\r\nuint64_t len)\r\n{\r\nreturn lpddr2_nvm_do_block_op(mtd, start_add, len, LPDDR2_NVM_UNLOCK);\r\n}\r\nstatic int lpddr2_nvm_lock(struct mtd_info *mtd, loff_t start_add,\r\nuint64_t len)\r\n{\r\nreturn lpddr2_nvm_do_block_op(mtd, start_add, len, LPDDR2_NVM_LOCK);\r\n}\r\nstatic int lpddr2_nvm_probe(struct platform_device *pdev)\r\n{\r\nstruct map_info *map;\r\nstruct mtd_info *mtd;\r\nstruct resource *add_range;\r\nstruct resource *control_regs;\r\nstruct pcm_int_data *pcm_data;\r\npcm_data = devm_kzalloc(&pdev->dev, sizeof(*pcm_data), GFP_KERNEL);\r\nif (!pcm_data)\r\nreturn -ENOMEM;\r\npcm_data->bus_width = BUS_WIDTH;\r\nmap = devm_kzalloc(&pdev->dev, sizeof(*map), GFP_KERNEL);\r\nif (!map)\r\nreturn -ENOMEM;\r\nmtd = devm_kzalloc(&pdev->dev, sizeof(*mtd), GFP_KERNEL);\r\nif (!mtd)\r\nreturn -ENOMEM;\r\nadd_range = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\n*map = (struct map_info) {\r\n.virt = devm_ioremap_resource(&pdev->dev, add_range),\r\n.name = pdev->dev.init_name,\r\n.phys = add_range->start,\r\n.size = resource_size(add_range),\r\n.bankwidth = pcm_data->bus_width / 2,\r\n.pfow_base = OW_BASE_ADDRESS,\r\n.fldrv_priv = pcm_data,\r\n};\r\nif (IS_ERR(map->virt))\r\nreturn PTR_ERR(map->virt);\r\nsimple_map_init(map);\r\ncontrol_regs = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\npcm_data->ctl_regs = devm_ioremap_resource(&pdev->dev, control_regs);\r\nif (IS_ERR(pcm_data->ctl_regs))\r\nreturn PTR_ERR(pcm_data->ctl_regs);\r\n*mtd = (struct mtd_info) {\r\n.name = pdev->dev.init_name,\r\n.type = MTD_RAM,\r\n.priv = map,\r\n.size = resource_size(add_range),\r\n.erasesize = ERASE_BLOCKSIZE * pcm_data->bus_width,\r\n.writesize = 1,\r\n.writebufsize = WRITE_BUFFSIZE * pcm_data->bus_width,\r\n.flags = (MTD_CAP_NVRAM | MTD_POWERUP_LOCK),\r\n._read = lpddr2_nvm_read,\r\n._write = lpddr2_nvm_write,\r\n._erase = lpddr2_nvm_erase,\r\n._unlock = lpddr2_nvm_unlock,\r\n._lock = lpddr2_nvm_lock,\r\n};\r\nif (!lpddr2_nvm_pfow_present(map)) {\r\npr_err("device not recognized\n");\r\nreturn -EINVAL;\r\n}\r\nreturn mtd_device_parse_register(mtd, NULL, NULL, NULL, 0);\r\n}\r\nstatic int lpddr2_nvm_remove(struct platform_device *pdev)\r\n{\r\nreturn mtd_device_unregister(dev_get_drvdata(&pdev->dev));\r\n}
