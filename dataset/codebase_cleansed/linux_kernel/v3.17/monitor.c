static netdev_tx_t mac802154_monitor_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct mac802154_sub_if_data *priv;\r\nu8 chan, page;\r\npriv = netdev_priv(dev);\r\nchan = priv->hw->phy->current_channel;\r\npage = priv->hw->phy->current_page;\r\nif (chan == MAC802154_CHAN_NONE)\r\nreturn NETDEV_TX_OK;\r\nif (WARN_ON(page >= WPAN_NUM_PAGES) ||\r\nWARN_ON(chan >= WPAN_NUM_CHANNELS))\r\nreturn NETDEV_TX_OK;\r\nskb->skb_iif = dev->ifindex;\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\nreturn mac802154_tx(priv->hw, skb, page, chan);\r\n}\r\nvoid mac802154_monitors_rx(struct mac802154_priv *priv, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *skb2;\r\nstruct mac802154_sub_if_data *sdata;\r\nu16 crc = crc_ccitt(0, skb->data, skb->len);\r\nu8 *data;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(sdata, &priv->slaves, list) {\r\nif (sdata->type != IEEE802154_DEV_MONITOR ||\r\n!netif_running(sdata->dev))\r\ncontinue;\r\nskb2 = skb_clone(skb, GFP_ATOMIC);\r\nskb2->dev = sdata->dev;\r\nskb2->pkt_type = PACKET_HOST;\r\ndata = skb_put(skb2, 2);\r\ndata[0] = crc & 0xff;\r\ndata[1] = crc >> 8;\r\nnetif_rx_ni(skb2);\r\n}\r\nrcu_read_unlock();\r\n}\r\nvoid mac802154_monitor_setup(struct net_device *dev)\r\n{\r\nstruct mac802154_sub_if_data *priv;\r\ndev->addr_len = 0;\r\ndev->hard_header_len = 0;\r\ndev->needed_tailroom = 2;\r\ndev->mtu = IEEE802154_MTU;\r\ndev->tx_queue_len = 10;\r\ndev->type = ARPHRD_IEEE802154_MONITOR;\r\ndev->flags = IFF_NOARP | IFF_BROADCAST;\r\ndev->watchdog_timeo = 0;\r\ndev->destructor = free_netdev;\r\ndev->netdev_ops = &mac802154_monitor_ops;\r\ndev->ml_priv = &mac802154_mlme_reduced;\r\npriv = netdev_priv(dev);\r\npriv->type = IEEE802154_DEV_MONITOR;\r\npriv->chan = MAC802154_CHAN_NONE;\r\npriv->page = 0;\r\n}
