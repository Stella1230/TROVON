int\r\naffs_insert_hash(struct inode *dir, struct buffer_head *bh)\r\n{\r\nstruct super_block *sb = dir->i_sb;\r\nstruct buffer_head *dir_bh;\r\nu32 ino, hash_ino;\r\nint offset;\r\nino = bh->b_blocknr;\r\noffset = affs_hash_name(sb, AFFS_TAIL(sb, bh)->name + 1, AFFS_TAIL(sb, bh)->name[0]);\r\npr_debug("%s(dir=%u, ino=%d)\n", __func__, (u32)dir->i_ino, ino);\r\ndir_bh = affs_bread(sb, dir->i_ino);\r\nif (!dir_bh)\r\nreturn -EIO;\r\nhash_ino = be32_to_cpu(AFFS_HEAD(dir_bh)->table[offset]);\r\nwhile (hash_ino) {\r\naffs_brelse(dir_bh);\r\ndir_bh = affs_bread(sb, hash_ino);\r\nif (!dir_bh)\r\nreturn -EIO;\r\nhash_ino = be32_to_cpu(AFFS_TAIL(sb, dir_bh)->hash_chain);\r\n}\r\nAFFS_TAIL(sb, bh)->parent = cpu_to_be32(dir->i_ino);\r\nAFFS_TAIL(sb, bh)->hash_chain = 0;\r\naffs_fix_checksum(sb, bh);\r\nif (dir->i_ino == dir_bh->b_blocknr)\r\nAFFS_HEAD(dir_bh)->table[offset] = cpu_to_be32(ino);\r\nelse\r\nAFFS_TAIL(sb, dir_bh)->hash_chain = cpu_to_be32(ino);\r\naffs_adjust_checksum(dir_bh, ino);\r\nmark_buffer_dirty_inode(dir_bh, dir);\r\naffs_brelse(dir_bh);\r\ndir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\r\ndir->i_version++;\r\nmark_inode_dirty(dir);\r\nreturn 0;\r\n}\r\nint\r\naffs_remove_hash(struct inode *dir, struct buffer_head *rem_bh)\r\n{\r\nstruct super_block *sb;\r\nstruct buffer_head *bh;\r\nu32 rem_ino, hash_ino;\r\n__be32 ino;\r\nint offset, retval;\r\nsb = dir->i_sb;\r\nrem_ino = rem_bh->b_blocknr;\r\noffset = affs_hash_name(sb, AFFS_TAIL(sb, rem_bh)->name+1, AFFS_TAIL(sb, rem_bh)->name[0]);\r\npr_debug("%s(dir=%d, ino=%d, hashval=%d)\n",\r\n__func__, (u32)dir->i_ino, rem_ino, offset);\r\nbh = affs_bread(sb, dir->i_ino);\r\nif (!bh)\r\nreturn -EIO;\r\nretval = -ENOENT;\r\nhash_ino = be32_to_cpu(AFFS_HEAD(bh)->table[offset]);\r\nwhile (hash_ino) {\r\nif (hash_ino == rem_ino) {\r\nino = AFFS_TAIL(sb, rem_bh)->hash_chain;\r\nif (dir->i_ino == bh->b_blocknr)\r\nAFFS_HEAD(bh)->table[offset] = ino;\r\nelse\r\nAFFS_TAIL(sb, bh)->hash_chain = ino;\r\naffs_adjust_checksum(bh, be32_to_cpu(ino) - hash_ino);\r\nmark_buffer_dirty_inode(bh, dir);\r\nAFFS_TAIL(sb, rem_bh)->parent = 0;\r\nretval = 0;\r\nbreak;\r\n}\r\naffs_brelse(bh);\r\nbh = affs_bread(sb, hash_ino);\r\nif (!bh)\r\nreturn -EIO;\r\nhash_ino = be32_to_cpu(AFFS_TAIL(sb, bh)->hash_chain);\r\n}\r\naffs_brelse(bh);\r\ndir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\r\ndir->i_version++;\r\nmark_inode_dirty(dir);\r\nreturn retval;\r\n}\r\nstatic void\r\naffs_fix_dcache(struct inode *inode, u32 entry_ino)\r\n{\r\nstruct dentry *dentry;\r\nspin_lock(&inode->i_lock);\r\nhlist_for_each_entry(dentry, &inode->i_dentry, d_alias) {\r\nif (entry_ino == (u32)(long)dentry->d_fsdata) {\r\ndentry->d_fsdata = (void *)inode->i_ino;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&inode->i_lock);\r\n}\r\nstatic int\r\naffs_remove_link(struct dentry *dentry)\r\n{\r\nstruct inode *dir, *inode = dentry->d_inode;\r\nstruct super_block *sb = inode->i_sb;\r\nstruct buffer_head *bh = NULL, *link_bh = NULL;\r\nu32 link_ino, ino;\r\nint retval;\r\npr_debug("%s(key=%ld)\n", __func__, inode->i_ino);\r\nretval = -EIO;\r\nbh = affs_bread(sb, inode->i_ino);\r\nif (!bh)\r\ngoto done;\r\nlink_ino = (u32)(long)dentry->d_fsdata;\r\nif (inode->i_ino == link_ino) {\r\nlink_ino = be32_to_cpu(AFFS_TAIL(sb, bh)->link_chain);\r\nlink_bh = affs_bread(sb, link_ino);\r\nif (!link_bh)\r\ngoto done;\r\ndir = affs_iget(sb, be32_to_cpu(AFFS_TAIL(sb, link_bh)->parent));\r\nif (IS_ERR(dir)) {\r\nretval = PTR_ERR(dir);\r\ngoto done;\r\n}\r\naffs_lock_dir(dir);\r\naffs_fix_dcache(inode, link_ino);\r\nretval = affs_remove_hash(dir, link_bh);\r\nif (retval) {\r\naffs_unlock_dir(dir);\r\ngoto done;\r\n}\r\nmark_buffer_dirty_inode(link_bh, inode);\r\nmemcpy(AFFS_TAIL(sb, bh)->name, AFFS_TAIL(sb, link_bh)->name, 32);\r\nretval = affs_insert_hash(dir, bh);\r\nif (retval) {\r\naffs_unlock_dir(dir);\r\ngoto done;\r\n}\r\nmark_buffer_dirty_inode(bh, inode);\r\naffs_unlock_dir(dir);\r\niput(dir);\r\n} else {\r\nlink_bh = affs_bread(sb, link_ino);\r\nif (!link_bh)\r\ngoto done;\r\n}\r\nwhile ((ino = be32_to_cpu(AFFS_TAIL(sb, bh)->link_chain)) != 0) {\r\nif (ino == link_ino) {\r\n__be32 ino2 = AFFS_TAIL(sb, link_bh)->link_chain;\r\nAFFS_TAIL(sb, bh)->link_chain = ino2;\r\naffs_adjust_checksum(bh, be32_to_cpu(ino2) - link_ino);\r\nmark_buffer_dirty_inode(bh, inode);\r\nretval = 0;\r\nswitch (be32_to_cpu(AFFS_TAIL(sb, bh)->stype)) {\r\ncase ST_LINKDIR:\r\ncase ST_LINKFILE:\r\nbreak;\r\ndefault:\r\nif (!AFFS_TAIL(sb, bh)->link_chain)\r\nset_nlink(inode, 1);\r\n}\r\naffs_free_block(sb, link_ino);\r\ngoto done;\r\n}\r\naffs_brelse(bh);\r\nbh = affs_bread(sb, ino);\r\nif (!bh)\r\ngoto done;\r\n}\r\nretval = -ENOENT;\r\ndone:\r\naffs_brelse(link_bh);\r\naffs_brelse(bh);\r\nreturn retval;\r\n}\r\nstatic int\r\naffs_empty_dir(struct inode *inode)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct buffer_head *bh;\r\nint retval, size;\r\nretval = -EIO;\r\nbh = affs_bread(sb, inode->i_ino);\r\nif (!bh)\r\ngoto done;\r\nretval = -ENOTEMPTY;\r\nfor (size = AFFS_SB(sb)->s_hashsize - 1; size >= 0; size--)\r\nif (AFFS_HEAD(bh)->table[size])\r\ngoto not_empty;\r\nretval = 0;\r\nnot_empty:\r\naffs_brelse(bh);\r\ndone:\r\nreturn retval;\r\n}\r\nint\r\naffs_remove_header(struct dentry *dentry)\r\n{\r\nstruct super_block *sb;\r\nstruct inode *inode, *dir;\r\nstruct buffer_head *bh = NULL;\r\nint retval;\r\ndir = dentry->d_parent->d_inode;\r\nsb = dir->i_sb;\r\nretval = -ENOENT;\r\ninode = dentry->d_inode;\r\nif (!inode)\r\ngoto done;\r\npr_debug("%s(key=%ld)\n", __func__, inode->i_ino);\r\nretval = -EIO;\r\nbh = affs_bread(sb, (u32)(long)dentry->d_fsdata);\r\nif (!bh)\r\ngoto done;\r\naffs_lock_link(inode);\r\naffs_lock_dir(dir);\r\nswitch (be32_to_cpu(AFFS_TAIL(sb, bh)->stype)) {\r\ncase ST_USERDIR:\r\naffs_lock_dir(inode);\r\nretval = affs_empty_dir(inode);\r\naffs_unlock_dir(inode);\r\nif (retval)\r\ngoto done_unlock;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nretval = affs_remove_hash(dir, bh);\r\nif (retval)\r\ngoto done_unlock;\r\nmark_buffer_dirty_inode(bh, inode);\r\naffs_unlock_dir(dir);\r\nif (inode->i_nlink > 1)\r\nretval = affs_remove_link(dentry);\r\nelse\r\nclear_nlink(inode);\r\naffs_unlock_link(inode);\r\ninode->i_ctime = CURRENT_TIME_SEC;\r\nmark_inode_dirty(inode);\r\ndone:\r\naffs_brelse(bh);\r\nreturn retval;\r\ndone_unlock:\r\naffs_unlock_dir(dir);\r\naffs_unlock_link(inode);\r\ngoto done;\r\n}\r\nu32\r\naffs_checksum_block(struct super_block *sb, struct buffer_head *bh)\r\n{\r\n__be32 *ptr = (__be32 *)bh->b_data;\r\nu32 sum;\r\nint bsize;\r\nsum = 0;\r\nfor (bsize = sb->s_blocksize / sizeof(__be32); bsize > 0; bsize--)\r\nsum += be32_to_cpu(*ptr++);\r\nreturn sum;\r\n}\r\nvoid\r\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\r\n{\r\nint cnt = sb->s_blocksize / sizeof(__be32);\r\n__be32 *ptr = (__be32 *)bh->b_data;\r\nu32 checksum;\r\n__be32 *checksumptr;\r\nchecksumptr = ptr + 5;\r\n*checksumptr = 0;\r\nfor (checksum = 0; cnt > 0; ptr++, cnt--)\r\nchecksum += be32_to_cpu(*ptr);\r\n*checksumptr = cpu_to_be32(-checksum);\r\n}\r\nvoid\r\nsecs_to_datestamp(time_t secs, struct affs_date *ds)\r\n{\r\nu32 days;\r\nu32 minute;\r\nsecs -= sys_tz.tz_minuteswest * 60 + ((8 * 365 + 2) * 24 * 60 * 60);\r\nif (secs < 0)\r\nsecs = 0;\r\ndays = secs / 86400;\r\nsecs -= days * 86400;\r\nminute = secs / 60;\r\nsecs -= minute * 60;\r\nds->days = cpu_to_be32(days);\r\nds->mins = cpu_to_be32(minute);\r\nds->ticks = cpu_to_be32(secs * 50);\r\n}\r\numode_t\r\nprot_to_mode(u32 prot)\r\n{\r\numode_t mode = 0;\r\nif (!(prot & FIBF_NOWRITE))\r\nmode |= S_IWUSR;\r\nif (!(prot & FIBF_NOREAD))\r\nmode |= S_IRUSR;\r\nif (!(prot & FIBF_NOEXECUTE))\r\nmode |= S_IXUSR;\r\nif (prot & FIBF_GRP_WRITE)\r\nmode |= S_IWGRP;\r\nif (prot & FIBF_GRP_READ)\r\nmode |= S_IRGRP;\r\nif (prot & FIBF_GRP_EXECUTE)\r\nmode |= S_IXGRP;\r\nif (prot & FIBF_OTR_WRITE)\r\nmode |= S_IWOTH;\r\nif (prot & FIBF_OTR_READ)\r\nmode |= S_IROTH;\r\nif (prot & FIBF_OTR_EXECUTE)\r\nmode |= S_IXOTH;\r\nreturn mode;\r\n}\r\nvoid\r\nmode_to_prot(struct inode *inode)\r\n{\r\nu32 prot = AFFS_I(inode)->i_protect;\r\numode_t mode = inode->i_mode;\r\nif (!(mode & S_IXUSR))\r\nprot |= FIBF_NOEXECUTE;\r\nif (!(mode & S_IRUSR))\r\nprot |= FIBF_NOREAD;\r\nif (!(mode & S_IWUSR))\r\nprot |= FIBF_NOWRITE;\r\nif (mode & S_IXGRP)\r\nprot |= FIBF_GRP_EXECUTE;\r\nif (mode & S_IRGRP)\r\nprot |= FIBF_GRP_READ;\r\nif (mode & S_IWGRP)\r\nprot |= FIBF_GRP_WRITE;\r\nif (mode & S_IXOTH)\r\nprot |= FIBF_OTR_EXECUTE;\r\nif (mode & S_IROTH)\r\nprot |= FIBF_OTR_READ;\r\nif (mode & S_IWOTH)\r\nprot |= FIBF_OTR_WRITE;\r\nAFFS_I(inode)->i_protect = prot;\r\n}\r\nvoid\r\naffs_error(struct super_block *sb, const char *function, const char *fmt, ...)\r\n{\r\nva_list args;\r\nva_start(args,fmt);\r\nvsnprintf(ErrorBuffer,sizeof(ErrorBuffer),fmt,args);\r\nva_end(args);\r\npr_crit("error (device %s): %s(): %s\n", sb->s_id,\r\nfunction,ErrorBuffer);\r\nif (!(sb->s_flags & MS_RDONLY))\r\npr_warn("Remounting filesystem read-only\n");\r\nsb->s_flags |= MS_RDONLY;\r\n}\r\nvoid\r\naffs_warning(struct super_block *sb, const char *function, const char *fmt, ...)\r\n{\r\nva_list args;\r\nva_start(args,fmt);\r\nvsnprintf(ErrorBuffer,sizeof(ErrorBuffer),fmt,args);\r\nva_end(args);\r\npr_warn("(device %s): %s(): %s\n", sb->s_id,\r\nfunction,ErrorBuffer);\r\n}\r\nbool\r\naffs_nofilenametruncate(const struct dentry *dentry)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nreturn AFFS_SB(inode->i_sb)->s_flags & SF_NO_TRUNCATE;\r\n}\r\nint\r\naffs_check_name(const unsigned char *name, int len, bool notruncate)\r\n{\r\nint i;\r\nif (len > 30) {\r\nif (notruncate)\r\nreturn -ENAMETOOLONG;\r\nelse\r\nlen = 30;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nif (name[i] < ' ' || name[i] == ':'\r\n|| (name[i] > 0x7e && name[i] < 0xa0))\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint\r\naffs_copy_name(unsigned char *bstr, struct dentry *dentry)\r\n{\r\nint len = min(dentry->d_name.len, 30u);\r\n*bstr++ = len;\r\nmemcpy(bstr, dentry->d_name.name, len);\r\nreturn len;\r\n}
