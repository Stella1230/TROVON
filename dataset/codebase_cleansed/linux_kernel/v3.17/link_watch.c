static unsigned char default_operstate(const struct net_device *dev)\r\n{\r\nif (!netif_carrier_ok(dev))\r\nreturn (dev->ifindex != dev->iflink ?\r\nIF_OPER_LOWERLAYERDOWN : IF_OPER_DOWN);\r\nif (netif_dormant(dev))\r\nreturn IF_OPER_DORMANT;\r\nreturn IF_OPER_UP;\r\n}\r\nstatic void rfc2863_policy(struct net_device *dev)\r\n{\r\nunsigned char operstate = default_operstate(dev);\r\nif (operstate == dev->operstate)\r\nreturn;\r\nwrite_lock_bh(&dev_base_lock);\r\nswitch(dev->link_mode) {\r\ncase IF_LINK_MODE_DORMANT:\r\nif (operstate == IF_OPER_UP)\r\noperstate = IF_OPER_DORMANT;\r\nbreak;\r\ncase IF_LINK_MODE_DEFAULT:\r\ndefault:\r\nbreak;\r\n}\r\ndev->operstate = operstate;\r\nwrite_unlock_bh(&dev_base_lock);\r\n}\r\nvoid linkwatch_init_dev(struct net_device *dev)\r\n{\r\nif (!netif_carrier_ok(dev) || netif_dormant(dev))\r\nrfc2863_policy(dev);\r\n}\r\nstatic bool linkwatch_urgent_event(struct net_device *dev)\r\n{\r\nif (!netif_running(dev))\r\nreturn false;\r\nif (dev->ifindex != dev->iflink)\r\nreturn true;\r\nif (dev->priv_flags & IFF_TEAM_PORT)\r\nreturn true;\r\nreturn netif_carrier_ok(dev) && qdisc_tx_changing(dev);\r\n}\r\nstatic void linkwatch_add_event(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&lweventlist_lock, flags);\r\nif (list_empty(&dev->link_watch_list)) {\r\nlist_add_tail(&dev->link_watch_list, &lweventlist);\r\ndev_hold(dev);\r\n}\r\nspin_unlock_irqrestore(&lweventlist_lock, flags);\r\n}\r\nstatic void linkwatch_schedule_work(int urgent)\r\n{\r\nunsigned long delay = linkwatch_nextevent - jiffies;\r\nif (test_bit(LW_URGENT, &linkwatch_flags))\r\nreturn;\r\nif (urgent) {\r\nif (test_and_set_bit(LW_URGENT, &linkwatch_flags))\r\nreturn;\r\ndelay = 0;\r\n}\r\nif (delay > HZ)\r\ndelay = 0;\r\nif (test_bit(LW_URGENT, &linkwatch_flags))\r\nmod_delayed_work(system_wq, &linkwatch_work, 0);\r\nelse\r\nschedule_delayed_work(&linkwatch_work, delay);\r\n}\r\nstatic void linkwatch_do_dev(struct net_device *dev)\r\n{\r\nsmp_mb__before_atomic();\r\nclear_bit(__LINK_STATE_LINKWATCH_PENDING, &dev->state);\r\nrfc2863_policy(dev);\r\nif (dev->flags & IFF_UP) {\r\nif (netif_carrier_ok(dev))\r\ndev_activate(dev);\r\nelse\r\ndev_deactivate(dev);\r\nnetdev_state_change(dev);\r\n}\r\ndev_put(dev);\r\n}\r\nstatic void __linkwatch_run_queue(int urgent_only)\r\n{\r\nstruct net_device *dev;\r\nLIST_HEAD(wrk);\r\nif (!urgent_only)\r\nlinkwatch_nextevent = jiffies + HZ;\r\nelse if (time_after(linkwatch_nextevent, jiffies + HZ))\r\nlinkwatch_nextevent = jiffies;\r\nclear_bit(LW_URGENT, &linkwatch_flags);\r\nspin_lock_irq(&lweventlist_lock);\r\nlist_splice_init(&lweventlist, &wrk);\r\nwhile (!list_empty(&wrk)) {\r\ndev = list_first_entry(&wrk, struct net_device, link_watch_list);\r\nlist_del_init(&dev->link_watch_list);\r\nif (urgent_only && !linkwatch_urgent_event(dev)) {\r\nlist_add_tail(&dev->link_watch_list, &lweventlist);\r\ncontinue;\r\n}\r\nspin_unlock_irq(&lweventlist_lock);\r\nlinkwatch_do_dev(dev);\r\nspin_lock_irq(&lweventlist_lock);\r\n}\r\nif (!list_empty(&lweventlist))\r\nlinkwatch_schedule_work(0);\r\nspin_unlock_irq(&lweventlist_lock);\r\n}\r\nvoid linkwatch_forget_dev(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nint clean = 0;\r\nspin_lock_irqsave(&lweventlist_lock, flags);\r\nif (!list_empty(&dev->link_watch_list)) {\r\nlist_del_init(&dev->link_watch_list);\r\nclean = 1;\r\n}\r\nspin_unlock_irqrestore(&lweventlist_lock, flags);\r\nif (clean)\r\nlinkwatch_do_dev(dev);\r\n}\r\nvoid linkwatch_run_queue(void)\r\n{\r\n__linkwatch_run_queue(0);\r\n}\r\nstatic void linkwatch_event(struct work_struct *dummy)\r\n{\r\nrtnl_lock();\r\n__linkwatch_run_queue(time_after(linkwatch_nextevent, jiffies));\r\nrtnl_unlock();\r\n}\r\nvoid linkwatch_fire_event(struct net_device *dev)\r\n{\r\nbool urgent = linkwatch_urgent_event(dev);\r\nif (!test_and_set_bit(__LINK_STATE_LINKWATCH_PENDING, &dev->state)) {\r\nlinkwatch_add_event(dev);\r\n} else if (!urgent)\r\nreturn;\r\nlinkwatch_schedule_work(urgent);\r\n}
