static void bcsp_crc_update(u16 *crc, u8 d)\r\n{\r\nu16 reg = *crc;\r\nreg = (reg >> 4) ^ crc_table[(reg ^ d) & 0x000f];\r\nreg = (reg >> 4) ^ crc_table[(reg ^ (d >> 4)) & 0x000f];\r\n*crc = reg;\r\n}\r\nstatic void bcsp_slip_msgdelim(struct sk_buff *skb)\r\n{\r\nconst char pkt_delim = 0xc0;\r\nmemcpy(skb_put(skb, 1), &pkt_delim, 1);\r\n}\r\nstatic void bcsp_slip_one_byte(struct sk_buff *skb, u8 c)\r\n{\r\nconst char esc_c0[2] = { 0xdb, 0xdc };\r\nconst char esc_db[2] = { 0xdb, 0xdd };\r\nswitch (c) {\r\ncase 0xc0:\r\nmemcpy(skb_put(skb, 2), &esc_c0, 2);\r\nbreak;\r\ncase 0xdb:\r\nmemcpy(skb_put(skb, 2), &esc_db, 2);\r\nbreak;\r\ndefault:\r\nmemcpy(skb_put(skb, 1), &c, 1);\r\n}\r\n}\r\nstatic int bcsp_enqueue(struct hci_uart *hu, struct sk_buff *skb)\r\n{\r\nstruct bcsp_struct *bcsp = hu->priv;\r\nif (skb->len > 0xFFF) {\r\nBT_ERR("Packet too long");\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nswitch (bt_cb(skb)->pkt_type) {\r\ncase HCI_ACLDATA_PKT:\r\ncase HCI_COMMAND_PKT:\r\nskb_queue_tail(&bcsp->rel, skb);\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\nskb_queue_tail(&bcsp->unrel, skb);\r\nbreak;\r\ndefault:\r\nBT_ERR("Unknown packet type");\r\nkfree_skb(skb);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *bcsp_prepare_pkt(struct bcsp_struct *bcsp, u8 *data,\r\nint len, int pkt_type)\r\n{\r\nstruct sk_buff *nskb;\r\nu8 hdr[4], chan;\r\nu16 BCSP_CRC_INIT(bcsp_txmsg_crc);\r\nint rel, i;\r\nswitch (pkt_type) {\r\ncase HCI_ACLDATA_PKT:\r\nchan = 6;\r\nrel = 1;\r\nbreak;\r\ncase HCI_COMMAND_PKT:\r\nchan = 5;\r\nrel = 1;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\nchan = 7;\r\nrel = 0;\r\nbreak;\r\ncase BCSP_LE_PKT:\r\nchan = 1;\r\nrel = 0;\r\nbreak;\r\ncase BCSP_ACK_PKT:\r\nchan = 0;\r\nrel = 0;\r\nbreak;\r\ndefault:\r\nBT_ERR("Unknown packet type");\r\nreturn NULL;\r\n}\r\nif (hciextn && chan == 5) {\r\n__le16 opcode = ((struct hci_command_hdr *)data)->opcode;\r\nif (hci_opcode_ogf(__le16_to_cpu(opcode)) == 0x3f) {\r\nu8 desc = *(data + HCI_COMMAND_HDR_SIZE);\r\nif ((desc & 0xf0) == 0xc0) {\r\ndata += HCI_COMMAND_HDR_SIZE + 1;\r\nlen -= HCI_COMMAND_HDR_SIZE + 1;\r\nchan = desc & 0x0f;\r\n}\r\n}\r\n}\r\nnskb = alloc_skb((len + 6) * 2 + 2, GFP_ATOMIC);\r\nif (!nskb)\r\nreturn NULL;\r\nbt_cb(nskb)->pkt_type = pkt_type;\r\nbcsp_slip_msgdelim(nskb);\r\nhdr[0] = bcsp->rxseq_txack << 3;\r\nbcsp->txack_req = 0;\r\nBT_DBG("We request packet no %u to card", bcsp->rxseq_txack);\r\nif (rel) {\r\nhdr[0] |= 0x80 + bcsp->msgq_txseq;\r\nBT_DBG("Sending packet with seqno %u", bcsp->msgq_txseq);\r\nbcsp->msgq_txseq = (bcsp->msgq_txseq + 1) & 0x07;\r\n}\r\nif (bcsp->use_crc)\r\nhdr[0] |= 0x40;\r\nhdr[1] = ((len << 4) & 0xff) | chan;\r\nhdr[2] = len >> 4;\r\nhdr[3] = ~(hdr[0] + hdr[1] + hdr[2]);\r\nfor (i = 0; i < 4; i++) {\r\nbcsp_slip_one_byte(nskb, hdr[i]);\r\nif (bcsp->use_crc)\r\nbcsp_crc_update(&bcsp_txmsg_crc, hdr[i]);\r\n}\r\nfor (i = 0; i < len; i++) {\r\nbcsp_slip_one_byte(nskb, data[i]);\r\nif (bcsp->use_crc)\r\nbcsp_crc_update(&bcsp_txmsg_crc, data[i]);\r\n}\r\nif (bcsp->use_crc) {\r\nbcsp_txmsg_crc = bitrev16(bcsp_txmsg_crc);\r\nbcsp_slip_one_byte(nskb, (u8) ((bcsp_txmsg_crc >> 8) & 0x00ff));\r\nbcsp_slip_one_byte(nskb, (u8) (bcsp_txmsg_crc & 0x00ff));\r\n}\r\nbcsp_slip_msgdelim(nskb);\r\nreturn nskb;\r\n}\r\nstatic struct sk_buff *bcsp_dequeue(struct hci_uart *hu)\r\n{\r\nstruct bcsp_struct *bcsp = hu->priv;\r\nunsigned long flags;\r\nstruct sk_buff *skb;\r\nskb = skb_dequeue(&bcsp->unrel);\r\nif (skb != NULL) {\r\nstruct sk_buff *nskb = bcsp_prepare_pkt(bcsp, skb->data, skb->len, bt_cb(skb)->pkt_type);\r\nif (nskb) {\r\nkfree_skb(skb);\r\nreturn nskb;\r\n} else {\r\nskb_queue_head(&bcsp->unrel, skb);\r\nBT_ERR("Could not dequeue pkt because alloc_skb failed");\r\n}\r\n}\r\nspin_lock_irqsave_nested(&bcsp->unack.lock, flags, SINGLE_DEPTH_NESTING);\r\nif (bcsp->unack.qlen < BCSP_TXWINSIZE) {\r\nskb = skb_dequeue(&bcsp->rel);\r\nif (skb != NULL) {\r\nstruct sk_buff *nskb = bcsp_prepare_pkt(bcsp, skb->data, skb->len,\r\nbt_cb(skb)->pkt_type);\r\nif (nskb) {\r\n__skb_queue_tail(&bcsp->unack, skb);\r\nmod_timer(&bcsp->tbcsp, jiffies + HZ / 4);\r\nspin_unlock_irqrestore(&bcsp->unack.lock, flags);\r\nreturn nskb;\r\n} else {\r\nskb_queue_head(&bcsp->rel, skb);\r\nBT_ERR("Could not dequeue pkt because alloc_skb failed");\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&bcsp->unack.lock, flags);\r\nif (bcsp->txack_req) {\r\nstruct sk_buff *nskb = bcsp_prepare_pkt(bcsp, NULL, 0, BCSP_ACK_PKT);\r\nreturn nskb;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int bcsp_flush(struct hci_uart *hu)\r\n{\r\nBT_DBG("hu %p", hu);\r\nreturn 0;\r\n}\r\nstatic void bcsp_pkt_cull(struct bcsp_struct *bcsp)\r\n{\r\nstruct sk_buff *skb, *tmp;\r\nunsigned long flags;\r\nint i, pkts_to_be_removed;\r\nu8 seqno;\r\nspin_lock_irqsave(&bcsp->unack.lock, flags);\r\npkts_to_be_removed = skb_queue_len(&bcsp->unack);\r\nseqno = bcsp->msgq_txseq;\r\nwhile (pkts_to_be_removed) {\r\nif (bcsp->rxack == seqno)\r\nbreak;\r\npkts_to_be_removed--;\r\nseqno = (seqno - 1) & 0x07;\r\n}\r\nif (bcsp->rxack != seqno)\r\nBT_ERR("Peer acked invalid packet");\r\nBT_DBG("Removing %u pkts out of %u, up to seqno %u",\r\npkts_to_be_removed, skb_queue_len(&bcsp->unack),\r\n(seqno - 1) & 0x07);\r\ni = 0;\r\nskb_queue_walk_safe(&bcsp->unack, skb, tmp) {\r\nif (i >= pkts_to_be_removed)\r\nbreak;\r\ni++;\r\n__skb_unlink(skb, &bcsp->unack);\r\nkfree_skb(skb);\r\n}\r\nif (skb_queue_empty(&bcsp->unack))\r\ndel_timer(&bcsp->tbcsp);\r\nspin_unlock_irqrestore(&bcsp->unack.lock, flags);\r\nif (i != pkts_to_be_removed)\r\nBT_ERR("Removed only %u out of %u pkts", i, pkts_to_be_removed);\r\n}\r\nstatic void bcsp_handle_le_pkt(struct hci_uart *hu)\r\n{\r\nstruct bcsp_struct *bcsp = hu->priv;\r\nu8 conf_pkt[4] = { 0xad, 0xef, 0xac, 0xed };\r\nu8 conf_rsp_pkt[4] = { 0xde, 0xad, 0xd0, 0xd0 };\r\nu8 sync_pkt[4] = { 0xda, 0xdc, 0xed, 0xed };\r\nif (bcsp->rx_skb->data[1] >> 4 == 4 && bcsp->rx_skb->data[2] == 0 &&\r\n!memcmp(&bcsp->rx_skb->data[4], conf_pkt, 4)) {\r\nstruct sk_buff *nskb = alloc_skb(4, GFP_ATOMIC);\r\nBT_DBG("Found a LE conf pkt");\r\nif (!nskb)\r\nreturn;\r\nmemcpy(skb_put(nskb, 4), conf_rsp_pkt, 4);\r\nbt_cb(nskb)->pkt_type = BCSP_LE_PKT;\r\nskb_queue_head(&bcsp->unrel, nskb);\r\nhci_uart_tx_wakeup(hu);\r\n}\r\nelse if (bcsp->rx_skb->data[1] >> 4 == 4 && bcsp->rx_skb->data[2] == 0 &&\r\n!memcmp(&bcsp->rx_skb->data[4], sync_pkt, 4)) {\r\nBT_ERR("Found a LE sync pkt, card has reset");\r\n}\r\n}\r\nstatic inline void bcsp_unslip_one_byte(struct bcsp_struct *bcsp, unsigned char byte)\r\n{\r\nconst u8 c0 = 0xc0, db = 0xdb;\r\nswitch (bcsp->rx_esc_state) {\r\ncase BCSP_ESCSTATE_NOESC:\r\nswitch (byte) {\r\ncase 0xdb:\r\nbcsp->rx_esc_state = BCSP_ESCSTATE_ESC;\r\nbreak;\r\ndefault:\r\nmemcpy(skb_put(bcsp->rx_skb, 1), &byte, 1);\r\nif ((bcsp->rx_skb-> data[0] & 0x40) != 0 &&\r\nbcsp->rx_state != BCSP_W4_CRC)\r\nbcsp_crc_update(&bcsp->message_crc, byte);\r\nbcsp->rx_count--;\r\n}\r\nbreak;\r\ncase BCSP_ESCSTATE_ESC:\r\nswitch (byte) {\r\ncase 0xdc:\r\nmemcpy(skb_put(bcsp->rx_skb, 1), &c0, 1);\r\nif ((bcsp->rx_skb-> data[0] & 0x40) != 0 &&\r\nbcsp->rx_state != BCSP_W4_CRC)\r\nbcsp_crc_update(&bcsp-> message_crc, 0xc0);\r\nbcsp->rx_esc_state = BCSP_ESCSTATE_NOESC;\r\nbcsp->rx_count--;\r\nbreak;\r\ncase 0xdd:\r\nmemcpy(skb_put(bcsp->rx_skb, 1), &db, 1);\r\nif ((bcsp->rx_skb-> data[0] & 0x40) != 0 &&\r\nbcsp->rx_state != BCSP_W4_CRC)\r\nbcsp_crc_update(&bcsp-> message_crc, 0xdb);\r\nbcsp->rx_esc_state = BCSP_ESCSTATE_NOESC;\r\nbcsp->rx_count--;\r\nbreak;\r\ndefault:\r\nBT_ERR ("Invalid byte %02x after esc byte", byte);\r\nkfree_skb(bcsp->rx_skb);\r\nbcsp->rx_skb = NULL;\r\nbcsp->rx_state = BCSP_W4_PKT_DELIMITER;\r\nbcsp->rx_count = 0;\r\n}\r\n}\r\n}\r\nstatic void bcsp_complete_rx_pkt(struct hci_uart *hu)\r\n{\r\nstruct bcsp_struct *bcsp = hu->priv;\r\nint pass_up;\r\nif (bcsp->rx_skb->data[0] & 0x80) {\r\nBT_DBG("Received seqno %u from card", bcsp->rxseq_txack);\r\nbcsp->rxseq_txack++;\r\nbcsp->rxseq_txack %= 0x8;\r\nbcsp->txack_req = 1;\r\nhci_uart_tx_wakeup(hu);\r\n}\r\nbcsp->rxack = (bcsp->rx_skb->data[0] >> 3) & 0x07;\r\nBT_DBG("Request for pkt %u from card", bcsp->rxack);\r\nbcsp_pkt_cull(bcsp);\r\nif ((bcsp->rx_skb->data[1] & 0x0f) == 6 &&\r\nbcsp->rx_skb->data[0] & 0x80) {\r\nbt_cb(bcsp->rx_skb)->pkt_type = HCI_ACLDATA_PKT;\r\npass_up = 1;\r\n} else if ((bcsp->rx_skb->data[1] & 0x0f) == 5 &&\r\nbcsp->rx_skb->data[0] & 0x80) {\r\nbt_cb(bcsp->rx_skb)->pkt_type = HCI_EVENT_PKT;\r\npass_up = 1;\r\n} else if ((bcsp->rx_skb->data[1] & 0x0f) == 7) {\r\nbt_cb(bcsp->rx_skb)->pkt_type = HCI_SCODATA_PKT;\r\npass_up = 1;\r\n} else if ((bcsp->rx_skb->data[1] & 0x0f) == 1 &&\r\n!(bcsp->rx_skb->data[0] & 0x80)) {\r\nbcsp_handle_le_pkt(hu);\r\npass_up = 0;\r\n} else\r\npass_up = 0;\r\nif (!pass_up) {\r\nstruct hci_event_hdr hdr;\r\nu8 desc = (bcsp->rx_skb->data[1] & 0x0f);\r\nif (desc != 0 && desc != 1) {\r\nif (hciextn) {\r\ndesc |= 0xc0;\r\nskb_pull(bcsp->rx_skb, 4);\r\nmemcpy(skb_push(bcsp->rx_skb, 1), &desc, 1);\r\nhdr.evt = 0xff;\r\nhdr.plen = bcsp->rx_skb->len;\r\nmemcpy(skb_push(bcsp->rx_skb, HCI_EVENT_HDR_SIZE), &hdr, HCI_EVENT_HDR_SIZE);\r\nbt_cb(bcsp->rx_skb)->pkt_type = HCI_EVENT_PKT;\r\nhci_recv_frame(hu->hdev, bcsp->rx_skb);\r\n} else {\r\nBT_ERR ("Packet for unknown channel (%u %s)",\r\nbcsp->rx_skb->data[1] & 0x0f,\r\nbcsp->rx_skb->data[0] & 0x80 ?\r\n"reliable" : "unreliable");\r\nkfree_skb(bcsp->rx_skb);\r\n}\r\n} else\r\nkfree_skb(bcsp->rx_skb);\r\n} else {\r\nskb_pull(bcsp->rx_skb, 4);\r\nhci_recv_frame(hu->hdev, bcsp->rx_skb);\r\n}\r\nbcsp->rx_state = BCSP_W4_PKT_DELIMITER;\r\nbcsp->rx_skb = NULL;\r\n}\r\nstatic u16 bscp_get_crc(struct bcsp_struct *bcsp)\r\n{\r\nreturn get_unaligned_be16(&bcsp->rx_skb->data[bcsp->rx_skb->len - 2]);\r\n}\r\nstatic int bcsp_recv(struct hci_uart *hu, void *data, int count)\r\n{\r\nstruct bcsp_struct *bcsp = hu->priv;\r\nunsigned char *ptr;\r\nBT_DBG("hu %p count %d rx_state %d rx_count %ld",\r\nhu, count, bcsp->rx_state, bcsp->rx_count);\r\nptr = data;\r\nwhile (count) {\r\nif (bcsp->rx_count) {\r\nif (*ptr == 0xc0) {\r\nBT_ERR("Short BCSP packet");\r\nkfree_skb(bcsp->rx_skb);\r\nbcsp->rx_state = BCSP_W4_PKT_START;\r\nbcsp->rx_count = 0;\r\n} else\r\nbcsp_unslip_one_byte(bcsp, *ptr);\r\nptr++; count--;\r\ncontinue;\r\n}\r\nswitch (bcsp->rx_state) {\r\ncase BCSP_W4_BCSP_HDR:\r\nif ((0xff & (u8) ~ (bcsp->rx_skb->data[0] + bcsp->rx_skb->data[1] +\r\nbcsp->rx_skb->data[2])) != bcsp->rx_skb->data[3]) {\r\nBT_ERR("Error in BCSP hdr checksum");\r\nkfree_skb(bcsp->rx_skb);\r\nbcsp->rx_state = BCSP_W4_PKT_DELIMITER;\r\nbcsp->rx_count = 0;\r\ncontinue;\r\n}\r\nif (bcsp->rx_skb->data[0] & 0x80\r\n&& (bcsp->rx_skb->data[0] & 0x07) != bcsp->rxseq_txack) {\r\nBT_ERR ("Out-of-order packet arrived, got %u expected %u",\r\nbcsp->rx_skb->data[0] & 0x07, bcsp->rxseq_txack);\r\nkfree_skb(bcsp->rx_skb);\r\nbcsp->rx_state = BCSP_W4_PKT_DELIMITER;\r\nbcsp->rx_count = 0;\r\ncontinue;\r\n}\r\nbcsp->rx_state = BCSP_W4_DATA;\r\nbcsp->rx_count = (bcsp->rx_skb->data[1] >> 4) +\r\n(bcsp->rx_skb->data[2] << 4);\r\ncontinue;\r\ncase BCSP_W4_DATA:\r\nif (bcsp->rx_skb->data[0] & 0x40) {\r\nbcsp->rx_state = BCSP_W4_CRC;\r\nbcsp->rx_count = 2;\r\n} else\r\nbcsp_complete_rx_pkt(hu);\r\ncontinue;\r\ncase BCSP_W4_CRC:\r\nif (bitrev16(bcsp->message_crc) != bscp_get_crc(bcsp)) {\r\nBT_ERR ("Checksum failed: computed %04x received %04x",\r\nbitrev16(bcsp->message_crc),\r\nbscp_get_crc(bcsp));\r\nkfree_skb(bcsp->rx_skb);\r\nbcsp->rx_state = BCSP_W4_PKT_DELIMITER;\r\nbcsp->rx_count = 0;\r\ncontinue;\r\n}\r\nskb_trim(bcsp->rx_skb, bcsp->rx_skb->len - 2);\r\nbcsp_complete_rx_pkt(hu);\r\ncontinue;\r\ncase BCSP_W4_PKT_DELIMITER:\r\nswitch (*ptr) {\r\ncase 0xc0:\r\nbcsp->rx_state = BCSP_W4_PKT_START;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nptr++; count--;\r\nbreak;\r\ncase BCSP_W4_PKT_START:\r\nswitch (*ptr) {\r\ncase 0xc0:\r\nptr++; count--;\r\nbreak;\r\ndefault:\r\nbcsp->rx_state = BCSP_W4_BCSP_HDR;\r\nbcsp->rx_count = 4;\r\nbcsp->rx_esc_state = BCSP_ESCSTATE_NOESC;\r\nBCSP_CRC_INIT(bcsp->message_crc);\r\nbcsp->rx_skb = bt_skb_alloc(0x1005, GFP_ATOMIC);\r\nif (!bcsp->rx_skb) {\r\nBT_ERR("Can't allocate mem for new packet");\r\nbcsp->rx_state = BCSP_W4_PKT_DELIMITER;\r\nbcsp->rx_count = 0;\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic void bcsp_timed_event(unsigned long arg)\r\n{\r\nstruct hci_uart *hu = (struct hci_uart *) arg;\r\nstruct bcsp_struct *bcsp = hu->priv;\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nBT_DBG("hu %p retransmitting %u pkts", hu, bcsp->unack.qlen);\r\nspin_lock_irqsave_nested(&bcsp->unack.lock, flags, SINGLE_DEPTH_NESTING);\r\nwhile ((skb = __skb_dequeue_tail(&bcsp->unack)) != NULL) {\r\nbcsp->msgq_txseq = (bcsp->msgq_txseq - 1) & 0x07;\r\nskb_queue_head(&bcsp->rel, skb);\r\n}\r\nspin_unlock_irqrestore(&bcsp->unack.lock, flags);\r\nhci_uart_tx_wakeup(hu);\r\n}\r\nstatic int bcsp_open(struct hci_uart *hu)\r\n{\r\nstruct bcsp_struct *bcsp;\r\nBT_DBG("hu %p", hu);\r\nbcsp = kzalloc(sizeof(*bcsp), GFP_KERNEL);\r\nif (!bcsp)\r\nreturn -ENOMEM;\r\nhu->priv = bcsp;\r\nskb_queue_head_init(&bcsp->unack);\r\nskb_queue_head_init(&bcsp->rel);\r\nskb_queue_head_init(&bcsp->unrel);\r\ninit_timer(&bcsp->tbcsp);\r\nbcsp->tbcsp.function = bcsp_timed_event;\r\nbcsp->tbcsp.data = (u_long) hu;\r\nbcsp->rx_state = BCSP_W4_PKT_DELIMITER;\r\nif (txcrc)\r\nbcsp->use_crc = 1;\r\nreturn 0;\r\n}\r\nstatic int bcsp_close(struct hci_uart *hu)\r\n{\r\nstruct bcsp_struct *bcsp = hu->priv;\r\ndel_timer_sync(&bcsp->tbcsp);\r\nhu->priv = NULL;\r\nBT_DBG("hu %p", hu);\r\nskb_queue_purge(&bcsp->unack);\r\nskb_queue_purge(&bcsp->rel);\r\nskb_queue_purge(&bcsp->unrel);\r\nkfree(bcsp);\r\nreturn 0;\r\n}\r\nint __init bcsp_init(void)\r\n{\r\nint err = hci_uart_register_proto(&bcsp);\r\nif (!err)\r\nBT_INFO("HCI BCSP protocol initialized");\r\nelse\r\nBT_ERR("HCI BCSP protocol registration failed");\r\nreturn err;\r\n}\r\nint __exit bcsp_deinit(void)\r\n{\r\nreturn hci_uart_unregister_proto(&bcsp);\r\n}
