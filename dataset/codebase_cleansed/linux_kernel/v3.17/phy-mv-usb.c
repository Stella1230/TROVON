static int mv_otg_set_vbus(struct usb_otg *otg, bool on)\r\n{\r\nstruct mv_otg *mvotg = container_of(otg->phy, struct mv_otg, phy);\r\nif (mvotg->pdata->set_vbus == NULL)\r\nreturn -ENODEV;\r\nreturn mvotg->pdata->set_vbus(on);\r\n}\r\nstatic int mv_otg_set_host(struct usb_otg *otg,\r\nstruct usb_bus *host)\r\n{\r\notg->host = host;\r\nreturn 0;\r\n}\r\nstatic int mv_otg_set_peripheral(struct usb_otg *otg,\r\nstruct usb_gadget *gadget)\r\n{\r\notg->gadget = gadget;\r\nreturn 0;\r\n}\r\nstatic void mv_otg_run_state_machine(struct mv_otg *mvotg,\r\nunsigned long delay)\r\n{\r\ndev_dbg(&mvotg->pdev->dev, "transceiver is updated\n");\r\nif (!mvotg->qwork)\r\nreturn;\r\nqueue_delayed_work(mvotg->qwork, &mvotg->work, delay);\r\n}\r\nstatic void mv_otg_timer_await_bcon(unsigned long data)\r\n{\r\nstruct mv_otg *mvotg = (struct mv_otg *) data;\r\nmvotg->otg_ctrl.a_wait_bcon_timeout = 1;\r\ndev_info(&mvotg->pdev->dev, "B Device No Response!\n");\r\nif (spin_trylock(&mvotg->wq_lock)) {\r\nmv_otg_run_state_machine(mvotg, 0);\r\nspin_unlock(&mvotg->wq_lock);\r\n}\r\n}\r\nstatic int mv_otg_cancel_timer(struct mv_otg *mvotg, unsigned int id)\r\n{\r\nstruct timer_list *timer;\r\nif (id >= OTG_TIMER_NUM)\r\nreturn -EINVAL;\r\ntimer = &mvotg->otg_ctrl.timer[id];\r\nif (timer_pending(timer))\r\ndel_timer(timer);\r\nreturn 0;\r\n}\r\nstatic int mv_otg_set_timer(struct mv_otg *mvotg, unsigned int id,\r\nunsigned long interval,\r\nvoid (*callback) (unsigned long))\r\n{\r\nstruct timer_list *timer;\r\nif (id >= OTG_TIMER_NUM)\r\nreturn -EINVAL;\r\ntimer = &mvotg->otg_ctrl.timer[id];\r\nif (timer_pending(timer)) {\r\ndev_err(&mvotg->pdev->dev, "Timer%d is already running\n", id);\r\nreturn -EBUSY;\r\n}\r\ninit_timer(timer);\r\ntimer->data = (unsigned long) mvotg;\r\ntimer->function = callback;\r\ntimer->expires = jiffies + interval;\r\nadd_timer(timer);\r\nreturn 0;\r\n}\r\nstatic int mv_otg_reset(struct mv_otg *mvotg)\r\n{\r\nunsigned int loops;\r\nu32 tmp;\r\ntmp = readl(&mvotg->op_regs->usbcmd);\r\ntmp &= ~USBCMD_RUN_STOP;\r\nwritel(tmp, &mvotg->op_regs->usbcmd);\r\nwritel(USBCMD_CTRL_RESET, &mvotg->op_regs->usbcmd);\r\nloops = 500;\r\nwhile (readl(&mvotg->op_regs->usbcmd) & USBCMD_CTRL_RESET) {\r\nif (loops == 0) {\r\ndev_err(&mvotg->pdev->dev,\r\n"Wait for RESET completed TIMEOUT\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nloops--;\r\nudelay(20);\r\n}\r\nwritel(0x0, &mvotg->op_regs->usbintr);\r\ntmp = readl(&mvotg->op_regs->usbsts);\r\nwritel(tmp, &mvotg->op_regs->usbsts);\r\nreturn 0;\r\n}\r\nstatic void mv_otg_init_irq(struct mv_otg *mvotg)\r\n{\r\nu32 otgsc;\r\nmvotg->irq_en = OTGSC_INTR_A_SESSION_VALID\r\n| OTGSC_INTR_A_VBUS_VALID;\r\nmvotg->irq_status = OTGSC_INTSTS_A_SESSION_VALID\r\n| OTGSC_INTSTS_A_VBUS_VALID;\r\nif (mvotg->pdata->vbus == NULL) {\r\nmvotg->irq_en |= OTGSC_INTR_B_SESSION_VALID\r\n| OTGSC_INTR_B_SESSION_END;\r\nmvotg->irq_status |= OTGSC_INTSTS_B_SESSION_VALID\r\n| OTGSC_INTSTS_B_SESSION_END;\r\n}\r\nif (mvotg->pdata->id == NULL) {\r\nmvotg->irq_en |= OTGSC_INTR_USB_ID;\r\nmvotg->irq_status |= OTGSC_INTSTS_USB_ID;\r\n}\r\notgsc = readl(&mvotg->op_regs->otgsc);\r\notgsc |= mvotg->irq_en;\r\nwritel(otgsc, &mvotg->op_regs->otgsc);\r\n}\r\nstatic void mv_otg_start_host(struct mv_otg *mvotg, int on)\r\n{\r\n#ifdef CONFIG_USB\r\nstruct usb_otg *otg = mvotg->phy.otg;\r\nstruct usb_hcd *hcd;\r\nif (!otg->host)\r\nreturn;\r\ndev_info(&mvotg->pdev->dev, "%s host\n", on ? "start" : "stop");\r\nhcd = bus_to_hcd(otg->host);\r\nif (on) {\r\nusb_add_hcd(hcd, hcd->irq, IRQF_SHARED);\r\ndevice_wakeup_enable(hcd->self.controller);\r\n} else {\r\nusb_remove_hcd(hcd);\r\n}\r\n#endif\r\n}\r\nstatic void mv_otg_start_periphrals(struct mv_otg *mvotg, int on)\r\n{\r\nstruct usb_otg *otg = mvotg->phy.otg;\r\nif (!otg->gadget)\r\nreturn;\r\ndev_info(mvotg->phy.dev, "gadget %s\n", on ? "on" : "off");\r\nif (on)\r\nusb_gadget_vbus_connect(otg->gadget);\r\nelse\r\nusb_gadget_vbus_disconnect(otg->gadget);\r\n}\r\nstatic void otg_clock_enable(struct mv_otg *mvotg)\r\n{\r\nclk_prepare_enable(mvotg->clk);\r\n}\r\nstatic void otg_clock_disable(struct mv_otg *mvotg)\r\n{\r\nclk_disable_unprepare(mvotg->clk);\r\n}\r\nstatic int mv_otg_enable_internal(struct mv_otg *mvotg)\r\n{\r\nint retval = 0;\r\nif (mvotg->active)\r\nreturn 0;\r\ndev_dbg(&mvotg->pdev->dev, "otg enabled\n");\r\notg_clock_enable(mvotg);\r\nif (mvotg->pdata->phy_init) {\r\nretval = mvotg->pdata->phy_init(mvotg->phy_regs);\r\nif (retval) {\r\ndev_err(&mvotg->pdev->dev,\r\n"init phy error %d\n", retval);\r\notg_clock_disable(mvotg);\r\nreturn retval;\r\n}\r\n}\r\nmvotg->active = 1;\r\nreturn 0;\r\n}\r\nstatic int mv_otg_enable(struct mv_otg *mvotg)\r\n{\r\nif (mvotg->clock_gating)\r\nreturn mv_otg_enable_internal(mvotg);\r\nreturn 0;\r\n}\r\nstatic void mv_otg_disable_internal(struct mv_otg *mvotg)\r\n{\r\nif (mvotg->active) {\r\ndev_dbg(&mvotg->pdev->dev, "otg disabled\n");\r\nif (mvotg->pdata->phy_deinit)\r\nmvotg->pdata->phy_deinit(mvotg->phy_regs);\r\notg_clock_disable(mvotg);\r\nmvotg->active = 0;\r\n}\r\n}\r\nstatic void mv_otg_disable(struct mv_otg *mvotg)\r\n{\r\nif (mvotg->clock_gating)\r\nmv_otg_disable_internal(mvotg);\r\n}\r\nstatic void mv_otg_update_inputs(struct mv_otg *mvotg)\r\n{\r\nstruct mv_otg_ctrl *otg_ctrl = &mvotg->otg_ctrl;\r\nu32 otgsc;\r\notgsc = readl(&mvotg->op_regs->otgsc);\r\nif (mvotg->pdata->vbus) {\r\nif (mvotg->pdata->vbus->poll() == VBUS_HIGH) {\r\notg_ctrl->b_sess_vld = 1;\r\notg_ctrl->b_sess_end = 0;\r\n} else {\r\notg_ctrl->b_sess_vld = 0;\r\notg_ctrl->b_sess_end = 1;\r\n}\r\n} else {\r\notg_ctrl->b_sess_vld = !!(otgsc & OTGSC_STS_B_SESSION_VALID);\r\notg_ctrl->b_sess_end = !!(otgsc & OTGSC_STS_B_SESSION_END);\r\n}\r\nif (mvotg->pdata->id)\r\notg_ctrl->id = !!mvotg->pdata->id->poll();\r\nelse\r\notg_ctrl->id = !!(otgsc & OTGSC_STS_USB_ID);\r\nif (mvotg->pdata->otg_force_a_bus_req && !otg_ctrl->id)\r\notg_ctrl->a_bus_req = 1;\r\notg_ctrl->a_sess_vld = !!(otgsc & OTGSC_STS_A_SESSION_VALID);\r\notg_ctrl->a_vbus_vld = !!(otgsc & OTGSC_STS_A_VBUS_VALID);\r\ndev_dbg(&mvotg->pdev->dev, "%s: ", __func__);\r\ndev_dbg(&mvotg->pdev->dev, "id %d\n", otg_ctrl->id);\r\ndev_dbg(&mvotg->pdev->dev, "b_sess_vld %d\n", otg_ctrl->b_sess_vld);\r\ndev_dbg(&mvotg->pdev->dev, "b_sess_end %d\n", otg_ctrl->b_sess_end);\r\ndev_dbg(&mvotg->pdev->dev, "a_vbus_vld %d\n", otg_ctrl->a_vbus_vld);\r\ndev_dbg(&mvotg->pdev->dev, "a_sess_vld %d\n", otg_ctrl->a_sess_vld);\r\n}\r\nstatic void mv_otg_update_state(struct mv_otg *mvotg)\r\n{\r\nstruct mv_otg_ctrl *otg_ctrl = &mvotg->otg_ctrl;\r\nstruct usb_phy *phy = &mvotg->phy;\r\nint old_state = phy->state;\r\nswitch (old_state) {\r\ncase OTG_STATE_UNDEFINED:\r\nphy->state = OTG_STATE_B_IDLE;\r\ncase OTG_STATE_B_IDLE:\r\nif (otg_ctrl->id == 0)\r\nphy->state = OTG_STATE_A_IDLE;\r\nelse if (otg_ctrl->b_sess_vld)\r\nphy->state = OTG_STATE_B_PERIPHERAL;\r\nbreak;\r\ncase OTG_STATE_B_PERIPHERAL:\r\nif (!otg_ctrl->b_sess_vld || otg_ctrl->id == 0)\r\nphy->state = OTG_STATE_B_IDLE;\r\nbreak;\r\ncase OTG_STATE_A_IDLE:\r\nif (otg_ctrl->id)\r\nphy->state = OTG_STATE_B_IDLE;\r\nelse if (!(otg_ctrl->a_bus_drop) &&\r\n(otg_ctrl->a_bus_req || otg_ctrl->a_srp_det))\r\nphy->state = OTG_STATE_A_WAIT_VRISE;\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VRISE:\r\nif (otg_ctrl->a_vbus_vld)\r\nphy->state = OTG_STATE_A_WAIT_BCON;\r\nbreak;\r\ncase OTG_STATE_A_WAIT_BCON:\r\nif (otg_ctrl->id || otg_ctrl->a_bus_drop\r\n|| otg_ctrl->a_wait_bcon_timeout) {\r\nmv_otg_cancel_timer(mvotg, A_WAIT_BCON_TIMER);\r\nmvotg->otg_ctrl.a_wait_bcon_timeout = 0;\r\nphy->state = OTG_STATE_A_WAIT_VFALL;\r\notg_ctrl->a_bus_req = 0;\r\n} else if (!otg_ctrl->a_vbus_vld) {\r\nmv_otg_cancel_timer(mvotg, A_WAIT_BCON_TIMER);\r\nmvotg->otg_ctrl.a_wait_bcon_timeout = 0;\r\nphy->state = OTG_STATE_A_VBUS_ERR;\r\n} else if (otg_ctrl->b_conn) {\r\nmv_otg_cancel_timer(mvotg, A_WAIT_BCON_TIMER);\r\nmvotg->otg_ctrl.a_wait_bcon_timeout = 0;\r\nphy->state = OTG_STATE_A_HOST;\r\n}\r\nbreak;\r\ncase OTG_STATE_A_HOST:\r\nif (otg_ctrl->id || !otg_ctrl->b_conn\r\n|| otg_ctrl->a_bus_drop)\r\nphy->state = OTG_STATE_A_WAIT_BCON;\r\nelse if (!otg_ctrl->a_vbus_vld)\r\nphy->state = OTG_STATE_A_VBUS_ERR;\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VFALL:\r\nif (otg_ctrl->id\r\n|| (!otg_ctrl->b_conn && otg_ctrl->a_sess_vld)\r\n|| otg_ctrl->a_bus_req)\r\nphy->state = OTG_STATE_A_IDLE;\r\nbreak;\r\ncase OTG_STATE_A_VBUS_ERR:\r\nif (otg_ctrl->id || otg_ctrl->a_clr_err\r\n|| otg_ctrl->a_bus_drop) {\r\notg_ctrl->a_clr_err = 0;\r\nphy->state = OTG_STATE_A_WAIT_VFALL;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void mv_otg_work(struct work_struct *work)\r\n{\r\nstruct mv_otg *mvotg;\r\nstruct usb_phy *phy;\r\nstruct usb_otg *otg;\r\nint old_state;\r\nmvotg = container_of(to_delayed_work(work), struct mv_otg, work);\r\nrun:\r\nphy = &mvotg->phy;\r\notg = phy->otg;\r\nold_state = phy->state;\r\nif (!mvotg->active)\r\nreturn;\r\nmv_otg_update_inputs(mvotg);\r\nmv_otg_update_state(mvotg);\r\nif (old_state != phy->state) {\r\ndev_info(&mvotg->pdev->dev, "change from state %s to %s\n",\r\nstate_string[old_state],\r\nstate_string[phy->state]);\r\nswitch (phy->state) {\r\ncase OTG_STATE_B_IDLE:\r\notg->default_a = 0;\r\nif (old_state == OTG_STATE_B_PERIPHERAL)\r\nmv_otg_start_periphrals(mvotg, 0);\r\nmv_otg_reset(mvotg);\r\nmv_otg_disable(mvotg);\r\nbreak;\r\ncase OTG_STATE_B_PERIPHERAL:\r\nmv_otg_enable(mvotg);\r\nmv_otg_start_periphrals(mvotg, 1);\r\nbreak;\r\ncase OTG_STATE_A_IDLE:\r\notg->default_a = 1;\r\nmv_otg_enable(mvotg);\r\nif (old_state == OTG_STATE_A_WAIT_VFALL)\r\nmv_otg_start_host(mvotg, 0);\r\nmv_otg_reset(mvotg);\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VRISE:\r\nmv_otg_set_vbus(otg, 1);\r\nbreak;\r\ncase OTG_STATE_A_WAIT_BCON:\r\nif (old_state != OTG_STATE_A_HOST)\r\nmv_otg_start_host(mvotg, 1);\r\nmv_otg_set_timer(mvotg, A_WAIT_BCON_TIMER,\r\nT_A_WAIT_BCON,\r\nmv_otg_timer_await_bcon);\r\nmvotg->otg_ctrl.b_conn = 1;\r\nbreak;\r\ncase OTG_STATE_A_HOST:\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VFALL:\r\nmvotg->otg_ctrl.b_conn = 0;\r\nmv_otg_set_vbus(otg, 0);\r\nbreak;\r\ncase OTG_STATE_A_VBUS_ERR:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ngoto run;\r\n}\r\n}\r\nstatic irqreturn_t mv_otg_irq(int irq, void *dev)\r\n{\r\nstruct mv_otg *mvotg = dev;\r\nu32 otgsc;\r\notgsc = readl(&mvotg->op_regs->otgsc);\r\nwritel(otgsc, &mvotg->op_regs->otgsc);\r\nif (mvotg->pdata->vbus)\r\nif ((otgsc & OTGSC_STS_USB_ID) &&\r\n!(otgsc & OTGSC_INTSTS_USB_ID))\r\nreturn IRQ_NONE;\r\nif ((otgsc & mvotg->irq_status) == 0)\r\nreturn IRQ_NONE;\r\nmv_otg_run_state_machine(mvotg, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t mv_otg_inputs_irq(int irq, void *dev)\r\n{\r\nstruct mv_otg *mvotg = dev;\r\nif (!mvotg->active) {\r\nmv_otg_enable(mvotg);\r\nmv_otg_init_irq(mvotg);\r\n}\r\nmv_otg_run_state_machine(mvotg, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic ssize_t\r\nget_a_bus_req(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct mv_otg *mvotg = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n",\r\nmvotg->otg_ctrl.a_bus_req);\r\n}\r\nstatic ssize_t\r\nset_a_bus_req(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct mv_otg *mvotg = dev_get_drvdata(dev);\r\nif (count > 2)\r\nreturn -1;\r\nif (mvotg->phy.state != OTG_STATE_B_IDLE\r\n&& mvotg->phy.state != OTG_STATE_A_IDLE)\r\nreturn -1;\r\nmv_otg_enable(mvotg);\r\nmv_otg_init_irq(mvotg);\r\nif (buf[0] == '1') {\r\nmvotg->otg_ctrl.a_bus_req = 1;\r\nmvotg->otg_ctrl.a_bus_drop = 0;\r\ndev_dbg(&mvotg->pdev->dev,\r\n"User request: a_bus_req = 1\n");\r\nif (spin_trylock(&mvotg->wq_lock)) {\r\nmv_otg_run_state_machine(mvotg, 0);\r\nspin_unlock(&mvotg->wq_lock);\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nset_a_clr_err(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct mv_otg *mvotg = dev_get_drvdata(dev);\r\nif (!mvotg->phy.otg->default_a)\r\nreturn -1;\r\nif (count > 2)\r\nreturn -1;\r\nif (buf[0] == '1') {\r\nmvotg->otg_ctrl.a_clr_err = 1;\r\ndev_dbg(&mvotg->pdev->dev,\r\n"User request: a_clr_err = 1\n");\r\n}\r\nif (spin_trylock(&mvotg->wq_lock)) {\r\nmv_otg_run_state_machine(mvotg, 0);\r\nspin_unlock(&mvotg->wq_lock);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nget_a_bus_drop(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct mv_otg *mvotg = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n",\r\nmvotg->otg_ctrl.a_bus_drop);\r\n}\r\nstatic ssize_t\r\nset_a_bus_drop(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct mv_otg *mvotg = dev_get_drvdata(dev);\r\nif (!mvotg->phy.otg->default_a)\r\nreturn -1;\r\nif (count > 2)\r\nreturn -1;\r\nif (buf[0] == '0') {\r\nmvotg->otg_ctrl.a_bus_drop = 0;\r\ndev_dbg(&mvotg->pdev->dev,\r\n"User request: a_bus_drop = 0\n");\r\n} else if (buf[0] == '1') {\r\nmvotg->otg_ctrl.a_bus_drop = 1;\r\nmvotg->otg_ctrl.a_bus_req = 0;\r\ndev_dbg(&mvotg->pdev->dev,\r\n"User request: a_bus_drop = 1\n");\r\ndev_dbg(&mvotg->pdev->dev,\r\n"User request: and a_bus_req = 0\n");\r\n}\r\nif (spin_trylock(&mvotg->wq_lock)) {\r\nmv_otg_run_state_machine(mvotg, 0);\r\nspin_unlock(&mvotg->wq_lock);\r\n}\r\nreturn count;\r\n}\r\nstatic int mv_otg_remove(struct platform_device *pdev)\r\n{\r\nstruct mv_otg *mvotg = platform_get_drvdata(pdev);\r\nsysfs_remove_group(&mvotg->pdev->dev.kobj, &inputs_attr_group);\r\nif (mvotg->qwork) {\r\nflush_workqueue(mvotg->qwork);\r\ndestroy_workqueue(mvotg->qwork);\r\n}\r\nmv_otg_disable(mvotg);\r\nusb_remove_phy(&mvotg->phy);\r\nreturn 0;\r\n}\r\nstatic int mv_otg_probe(struct platform_device *pdev)\r\n{\r\nstruct mv_usb_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct mv_otg *mvotg;\r\nstruct usb_otg *otg;\r\nstruct resource *r;\r\nint retval = 0, i;\r\nif (pdata == NULL) {\r\ndev_err(&pdev->dev, "failed to get platform data\n");\r\nreturn -ENODEV;\r\n}\r\nmvotg = devm_kzalloc(&pdev->dev, sizeof(*mvotg), GFP_KERNEL);\r\nif (!mvotg) {\r\ndev_err(&pdev->dev, "failed to allocate memory!\n");\r\nreturn -ENOMEM;\r\n}\r\notg = devm_kzalloc(&pdev->dev, sizeof(*otg), GFP_KERNEL);\r\nif (!otg)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, mvotg);\r\nmvotg->pdev = pdev;\r\nmvotg->pdata = pdata;\r\nmvotg->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(mvotg->clk))\r\nreturn PTR_ERR(mvotg->clk);\r\nmvotg->qwork = create_singlethread_workqueue("mv_otg_queue");\r\nif (!mvotg->qwork) {\r\ndev_dbg(&pdev->dev, "cannot create workqueue for OTG\n");\r\nreturn -ENOMEM;\r\n}\r\nINIT_DELAYED_WORK(&mvotg->work, mv_otg_work);\r\nmvotg->pdev = pdev;\r\nmvotg->phy.dev = &pdev->dev;\r\nmvotg->phy.otg = otg;\r\nmvotg->phy.label = driver_name;\r\nmvotg->phy.state = OTG_STATE_UNDEFINED;\r\notg->phy = &mvotg->phy;\r\notg->set_host = mv_otg_set_host;\r\notg->set_peripheral = mv_otg_set_peripheral;\r\notg->set_vbus = mv_otg_set_vbus;\r\nfor (i = 0; i < OTG_TIMER_NUM; i++)\r\ninit_timer(&mvotg->otg_ctrl.timer[i]);\r\nr = platform_get_resource_byname(mvotg->pdev,\r\nIORESOURCE_MEM, "phyregs");\r\nif (r == NULL) {\r\ndev_err(&pdev->dev, "no phy I/O memory resource defined\n");\r\nretval = -ENODEV;\r\ngoto err_destroy_workqueue;\r\n}\r\nmvotg->phy_regs = devm_ioremap(&pdev->dev, r->start, resource_size(r));\r\nif (mvotg->phy_regs == NULL) {\r\ndev_err(&pdev->dev, "failed to map phy I/O memory\n");\r\nretval = -EFAULT;\r\ngoto err_destroy_workqueue;\r\n}\r\nr = platform_get_resource_byname(mvotg->pdev,\r\nIORESOURCE_MEM, "capregs");\r\nif (r == NULL) {\r\ndev_err(&pdev->dev, "no I/O memory resource defined\n");\r\nretval = -ENODEV;\r\ngoto err_destroy_workqueue;\r\n}\r\nmvotg->cap_regs = devm_ioremap(&pdev->dev, r->start, resource_size(r));\r\nif (mvotg->cap_regs == NULL) {\r\ndev_err(&pdev->dev, "failed to map I/O memory\n");\r\nretval = -EFAULT;\r\ngoto err_destroy_workqueue;\r\n}\r\nretval = mv_otg_enable_internal(mvotg);\r\nif (retval) {\r\ndev_err(&pdev->dev, "mv otg enable error %d\n", retval);\r\ngoto err_destroy_workqueue;\r\n}\r\nmvotg->op_regs =\r\n(struct mv_otg_regs __iomem *) ((unsigned long) mvotg->cap_regs\r\n+ (readl(mvotg->cap_regs) & CAPLENGTH_MASK));\r\nif (pdata->id) {\r\nretval = devm_request_threaded_irq(&pdev->dev, pdata->id->irq,\r\nNULL, mv_otg_inputs_irq,\r\nIRQF_ONESHOT, "id", mvotg);\r\nif (retval) {\r\ndev_info(&pdev->dev,\r\n"Failed to request irq for ID\n");\r\npdata->id = NULL;\r\n}\r\n}\r\nif (pdata->vbus) {\r\nmvotg->clock_gating = 1;\r\nretval = devm_request_threaded_irq(&pdev->dev, pdata->vbus->irq,\r\nNULL, mv_otg_inputs_irq,\r\nIRQF_ONESHOT, "vbus", mvotg);\r\nif (retval) {\r\ndev_info(&pdev->dev,\r\n"Failed to request irq for VBUS, "\r\n"disable clock gating\n");\r\nmvotg->clock_gating = 0;\r\npdata->vbus = NULL;\r\n}\r\n}\r\nif (pdata->disable_otg_clock_gating)\r\nmvotg->clock_gating = 0;\r\nmv_otg_reset(mvotg);\r\nmv_otg_init_irq(mvotg);\r\nr = platform_get_resource(mvotg->pdev, IORESOURCE_IRQ, 0);\r\nif (r == NULL) {\r\ndev_err(&pdev->dev, "no IRQ resource defined\n");\r\nretval = -ENODEV;\r\ngoto err_disable_clk;\r\n}\r\nmvotg->irq = r->start;\r\nif (devm_request_irq(&pdev->dev, mvotg->irq, mv_otg_irq, IRQF_SHARED,\r\ndriver_name, mvotg)) {\r\ndev_err(&pdev->dev, "Request irq %d for OTG failed\n",\r\nmvotg->irq);\r\nmvotg->irq = 0;\r\nretval = -ENODEV;\r\ngoto err_disable_clk;\r\n}\r\nretval = usb_add_phy(&mvotg->phy, USB_PHY_TYPE_USB2);\r\nif (retval < 0) {\r\ndev_err(&pdev->dev, "can't register transceiver, %d\n",\r\nretval);\r\ngoto err_disable_clk;\r\n}\r\nretval = sysfs_create_group(&pdev->dev.kobj, &inputs_attr_group);\r\nif (retval < 0) {\r\ndev_dbg(&pdev->dev,\r\n"Can't register sysfs attr group: %d\n", retval);\r\ngoto err_remove_phy;\r\n}\r\nspin_lock_init(&mvotg->wq_lock);\r\nif (spin_trylock(&mvotg->wq_lock)) {\r\nmv_otg_run_state_machine(mvotg, 2 * HZ);\r\nspin_unlock(&mvotg->wq_lock);\r\n}\r\ndev_info(&pdev->dev,\r\n"successful probe OTG device %s clock gating.\n",\r\nmvotg->clock_gating ? "with" : "without");\r\nreturn 0;\r\nerr_remove_phy:\r\nusb_remove_phy(&mvotg->phy);\r\nerr_disable_clk:\r\nmv_otg_disable_internal(mvotg);\r\nerr_destroy_workqueue:\r\nflush_workqueue(mvotg->qwork);\r\ndestroy_workqueue(mvotg->qwork);\r\nreturn retval;\r\n}\r\nstatic int mv_otg_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct mv_otg *mvotg = platform_get_drvdata(pdev);\r\nif (mvotg->phy.state != OTG_STATE_B_IDLE) {\r\ndev_info(&pdev->dev,\r\n"OTG state is not B_IDLE, it is %d!\n",\r\nmvotg->phy.state);\r\nreturn -EAGAIN;\r\n}\r\nif (!mvotg->clock_gating)\r\nmv_otg_disable_internal(mvotg);\r\nreturn 0;\r\n}\r\nstatic int mv_otg_resume(struct platform_device *pdev)\r\n{\r\nstruct mv_otg *mvotg = platform_get_drvdata(pdev);\r\nu32 otgsc;\r\nif (!mvotg->clock_gating) {\r\nmv_otg_enable_internal(mvotg);\r\notgsc = readl(&mvotg->op_regs->otgsc);\r\notgsc |= mvotg->irq_en;\r\nwritel(otgsc, &mvotg->op_regs->otgsc);\r\nif (spin_trylock(&mvotg->wq_lock)) {\r\nmv_otg_run_state_machine(mvotg, 0);\r\nspin_unlock(&mvotg->wq_lock);\r\n}\r\n}\r\nreturn 0;\r\n}
