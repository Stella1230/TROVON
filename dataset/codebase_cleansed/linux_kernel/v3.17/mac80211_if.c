static void brcms_set_basic_rate(struct brcm_rateset *rs, u16 rate, bool is_br)\r\n{\r\nu32 i;\r\nfor (i = 0; i < rs->count; i++) {\r\nif (rate != (rs->rates[i] & 0x7f))\r\ncontinue;\r\nif (is_br)\r\nrs->rates[i] |= BRCMS_RATE_FLAG;\r\nelse\r\nrs->rates[i] &= BRCMS_RATE_MASK;\r\nreturn;\r\n}\r\n}\r\nstatic void brcms_free(struct brcms_info *wl)\r\n{\r\nstruct brcms_timer *t, *next;\r\nif (wl->fw.fw_cnt)\r\nbrcms_ucode_data_free(&wl->ucode);\r\nif (wl->irq)\r\nfree_irq(wl->irq, wl);\r\ntasklet_kill(&wl->tasklet);\r\nif (wl->pub) {\r\nbrcms_debugfs_detach(wl->pub);\r\nbrcms_c_module_unregister(wl->pub, "linux", wl);\r\n}\r\nif (wl->wlc) {\r\nbrcms_c_detach(wl->wlc);\r\nwl->wlc = NULL;\r\nwl->pub = NULL;\r\n}\r\nwhile (atomic_read(&wl->callbacks) > 0)\r\nschedule();\r\nfor (t = wl->timers; t; t = next) {\r\nnext = t->next;\r\n#ifdef DEBUG\r\nkfree(t->name);\r\n#endif\r\nkfree(t);\r\n}\r\n}\r\nstatic void brcms_remove(struct bcma_device *pdev)\r\n{\r\nstruct ieee80211_hw *hw = bcma_get_drvdata(pdev);\r\nstruct brcms_info *wl = hw->priv;\r\nif (wl->wlc) {\r\nbrcms_led_unregister(wl);\r\nwiphy_rfkill_set_hw_state(wl->pub->ieee_hw->wiphy, false);\r\nwiphy_rfkill_stop_polling(wl->pub->ieee_hw->wiphy);\r\nieee80211_unregister_hw(hw);\r\n}\r\nbrcms_free(wl);\r\nbcma_set_drvdata(pdev, NULL);\r\nieee80211_free_hw(hw);\r\n}\r\nstatic void brcms_release_fw(struct brcms_info *wl)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_FW_IMAGES; i++) {\r\nrelease_firmware(wl->fw.fw_bin[i]);\r\nrelease_firmware(wl->fw.fw_hdr[i]);\r\n}\r\n}\r\nstatic int brcms_request_fw(struct brcms_info *wl, struct bcma_device *pdev)\r\n{\r\nint status;\r\nstruct device *device = &pdev->dev;\r\nchar fw_name[100];\r\nint i;\r\nmemset(&wl->fw, 0, sizeof(struct brcms_firmware));\r\nfor (i = 0; i < MAX_FW_IMAGES; i++) {\r\nif (brcms_firmwares[i] == NULL)\r\nbreak;\r\nsprintf(fw_name, "%s-%d.fw", brcms_firmwares[i],\r\nUCODE_LOADER_API_VER);\r\nstatus = request_firmware(&wl->fw.fw_bin[i], fw_name, device);\r\nif (status) {\r\nwiphy_err(wl->wiphy, "%s: fail to load firmware %s\n",\r\nKBUILD_MODNAME, fw_name);\r\nreturn status;\r\n}\r\nsprintf(fw_name, "%s_hdr-%d.fw", brcms_firmwares[i],\r\nUCODE_LOADER_API_VER);\r\nstatus = request_firmware(&wl->fw.fw_hdr[i], fw_name, device);\r\nif (status) {\r\nwiphy_err(wl->wiphy, "%s: fail to load firmware %s\n",\r\nKBUILD_MODNAME, fw_name);\r\nreturn status;\r\n}\r\nwl->fw.hdr_num_entries[i] =\r\nwl->fw.fw_hdr[i]->size / (sizeof(struct firmware_hdr));\r\n}\r\nwl->fw.fw_cnt = i;\r\nstatus = brcms_ucode_data_init(wl, &wl->ucode);\r\nbrcms_release_fw(wl);\r\nreturn status;\r\n}\r\nstatic void brcms_ops_tx(struct ieee80211_hw *hw,\r\nstruct ieee80211_tx_control *control,\r\nstruct sk_buff *skb)\r\n{\r\nstruct brcms_info *wl = hw->priv;\r\nstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\r\nspin_lock_bh(&wl->lock);\r\nif (!wl->pub->up) {\r\nbrcms_err(wl->wlc->hw->d11core, "ops->tx called while down\n");\r\nkfree_skb(skb);\r\ngoto done;\r\n}\r\nif (brcms_c_sendpkt_mac80211(wl->wlc, skb, hw))\r\ntx_info->rate_driver_data[0] = control->sta;\r\ndone:\r\nspin_unlock_bh(&wl->lock);\r\n}\r\nstatic int brcms_ops_start(struct ieee80211_hw *hw)\r\n{\r\nstruct brcms_info *wl = hw->priv;\r\nbool blocked;\r\nint err;\r\nif (!wl->ucode.bcm43xx_bomminor) {\r\nerr = brcms_request_fw(wl, wl->wlc->hw->d11core);\r\nif (err)\r\nreturn -ENOENT;\r\n}\r\nieee80211_wake_queues(hw);\r\nspin_lock_bh(&wl->lock);\r\nblocked = brcms_rfkill_set_hw_state(wl);\r\nspin_unlock_bh(&wl->lock);\r\nif (!blocked)\r\nwiphy_rfkill_stop_polling(wl->pub->ieee_hw->wiphy);\r\nspin_lock_bh(&wl->lock);\r\nwl->mute_tx = true;\r\nif (!wl->pub->up)\r\nif (!blocked)\r\nerr = brcms_up(wl);\r\nelse\r\nerr = -ERFKILL;\r\nelse\r\nerr = -ENODEV;\r\nspin_unlock_bh(&wl->lock);\r\nif (err != 0)\r\nbrcms_err(wl->wlc->hw->d11core, "%s: brcms_up() returned %d\n",\r\n__func__, err);\r\nbcma_core_pci_power_save(wl->wlc->hw->d11core->bus, true);\r\nreturn err;\r\n}\r\nstatic void brcms_ops_stop(struct ieee80211_hw *hw)\r\n{\r\nstruct brcms_info *wl = hw->priv;\r\nint status;\r\nieee80211_stop_queues(hw);\r\nif (wl->wlc == NULL)\r\nreturn;\r\nspin_lock_bh(&wl->lock);\r\nstatus = brcms_c_chipmatch(wl->wlc->hw->d11core);\r\nspin_unlock_bh(&wl->lock);\r\nif (!status) {\r\nbrcms_err(wl->wlc->hw->d11core,\r\n"wl: brcms_ops_stop: chipmatch failed\n");\r\nreturn;\r\n}\r\nbcma_core_pci_power_save(wl->wlc->hw->d11core->bus, false);\r\nspin_lock_bh(&wl->lock);\r\nbrcms_down(wl);\r\nspin_unlock_bh(&wl->lock);\r\n}\r\nstatic int\r\nbrcms_ops_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\r\n{\r\nstruct brcms_info *wl = hw->priv;\r\nif (vif->type != NL80211_IFTYPE_STATION &&\r\nvif->type != NL80211_IFTYPE_AP &&\r\nvif->type != NL80211_IFTYPE_ADHOC) {\r\nbrcms_err(wl->wlc->hw->d11core,\r\n"%s: Attempt to add type %d, only STA, AP and AdHoc for now\n",\r\n__func__, vif->type);\r\nreturn -EOPNOTSUPP;\r\n}\r\nspin_lock_bh(&wl->lock);\r\nwl->mute_tx = false;\r\nbrcms_c_mute(wl->wlc, false);\r\nif (vif->type == NL80211_IFTYPE_STATION)\r\nbrcms_c_start_station(wl->wlc, vif->addr);\r\nelse if (vif->type == NL80211_IFTYPE_AP)\r\nbrcms_c_start_ap(wl->wlc, vif->addr, vif->bss_conf.bssid,\r\nvif->bss_conf.ssid, vif->bss_conf.ssid_len);\r\nelse if (vif->type == NL80211_IFTYPE_ADHOC)\r\nbrcms_c_start_adhoc(wl->wlc, vif->addr);\r\nspin_unlock_bh(&wl->lock);\r\nreturn 0;\r\n}\r\nstatic void\r\nbrcms_ops_remove_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\r\n{\r\n}\r\nstatic int brcms_ops_config(struct ieee80211_hw *hw, u32 changed)\r\n{\r\nstruct ieee80211_conf *conf = &hw->conf;\r\nstruct brcms_info *wl = hw->priv;\r\nstruct bcma_device *core = wl->wlc->hw->d11core;\r\nint err = 0;\r\nint new_int;\r\nspin_lock_bh(&wl->lock);\r\nif (changed & IEEE80211_CONF_CHANGE_LISTEN_INTERVAL) {\r\nbrcms_c_set_beacon_listen_interval(wl->wlc,\r\nconf->listen_interval);\r\n}\r\nif (changed & IEEE80211_CONF_CHANGE_MONITOR)\r\nbrcms_dbg_info(core, "%s: change monitor mode: %s\n",\r\n__func__, conf->flags & IEEE80211_CONF_MONITOR ?\r\n"true" : "false");\r\nif (changed & IEEE80211_CONF_CHANGE_PS)\r\nbrcms_err(core, "%s: change power-save mode: %s (implement)\n",\r\n__func__, conf->flags & IEEE80211_CONF_PS ?\r\n"true" : "false");\r\nif (changed & IEEE80211_CONF_CHANGE_POWER) {\r\nerr = brcms_c_set_tx_power(wl->wlc, conf->power_level);\r\nif (err < 0) {\r\nbrcms_err(core, "%s: Error setting power_level\n",\r\n__func__);\r\ngoto config_out;\r\n}\r\nnew_int = brcms_c_get_tx_power(wl->wlc);\r\nif (new_int != conf->power_level)\r\nbrcms_err(core,\r\n"%s: Power level req != actual, %d %d\n",\r\n__func__, conf->power_level,\r\nnew_int);\r\n}\r\nif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\r\nif (conf->chandef.width == NL80211_CHAN_WIDTH_20 ||\r\nconf->chandef.width == NL80211_CHAN_WIDTH_20_NOHT)\r\nerr = brcms_c_set_channel(wl->wlc,\r\nconf->chandef.chan->hw_value);\r\nelse\r\nerr = -ENOTSUPP;\r\n}\r\nif (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS)\r\nerr = brcms_c_set_rate_limit(wl->wlc,\r\nconf->short_frame_max_tx_count,\r\nconf->long_frame_max_tx_count);\r\nconfig_out:\r\nspin_unlock_bh(&wl->lock);\r\nreturn err;\r\n}\r\nstatic void\r\nbrcms_ops_bss_info_changed(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_bss_conf *info, u32 changed)\r\n{\r\nstruct brcms_info *wl = hw->priv;\r\nstruct bcma_device *core = wl->wlc->hw->d11core;\r\nif (changed & BSS_CHANGED_ASSOC) {\r\nbrcms_err(core, "%s: %s: %sassociated\n", KBUILD_MODNAME,\r\n__func__, info->assoc ? "" : "dis");\r\nspin_lock_bh(&wl->lock);\r\nbrcms_c_associate_upd(wl->wlc, info->assoc);\r\nspin_unlock_bh(&wl->lock);\r\n}\r\nif (changed & BSS_CHANGED_ERP_SLOT) {\r\ns8 val;\r\nif (info->use_short_slot)\r\nval = 1;\r\nelse\r\nval = 0;\r\nspin_lock_bh(&wl->lock);\r\nbrcms_c_set_shortslot_override(wl->wlc, val);\r\nspin_unlock_bh(&wl->lock);\r\n}\r\nif (changed & BSS_CHANGED_HT) {\r\nu16 mode = info->ht_operation_mode;\r\nspin_lock_bh(&wl->lock);\r\nbrcms_c_protection_upd(wl->wlc, BRCMS_PROT_N_CFG,\r\nmode & IEEE80211_HT_OP_MODE_PROTECTION);\r\nbrcms_c_protection_upd(wl->wlc, BRCMS_PROT_N_NONGF,\r\nmode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\r\nbrcms_c_protection_upd(wl->wlc, BRCMS_PROT_N_OBSS,\r\nmode & IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT);\r\nspin_unlock_bh(&wl->lock);\r\n}\r\nif (changed & BSS_CHANGED_BASIC_RATES) {\r\nstruct ieee80211_supported_band *bi;\r\nu32 br_mask, i;\r\nu16 rate;\r\nstruct brcm_rateset rs;\r\nint error;\r\nspin_lock_bh(&wl->lock);\r\nbrcms_c_get_current_rateset(wl->wlc, &rs);\r\nspin_unlock_bh(&wl->lock);\r\nbr_mask = info->basic_rates;\r\nbi = hw->wiphy->bands[brcms_c_get_curband(wl->wlc)];\r\nfor (i = 0; i < bi->n_bitrates; i++) {\r\nrate = (bi->bitrates[i].bitrate << 1) / 10;\r\nbrcms_set_basic_rate(&rs, rate, br_mask & 1);\r\nbr_mask >>= 1;\r\n}\r\nspin_lock_bh(&wl->lock);\r\nerror = brcms_c_set_rateset(wl->wlc, &rs);\r\nspin_unlock_bh(&wl->lock);\r\nif (error)\r\nbrcms_err(core, "changing basic rates failed: %d\n",\r\nerror);\r\n}\r\nif (changed & BSS_CHANGED_BEACON_INT) {\r\nspin_lock_bh(&wl->lock);\r\nbrcms_c_set_beacon_period(wl->wlc, info->beacon_int);\r\nspin_unlock_bh(&wl->lock);\r\n}\r\nif (changed & BSS_CHANGED_BSSID) {\r\nspin_lock_bh(&wl->lock);\r\nbrcms_c_set_addrmatch(wl->wlc, RCM_BSSID_OFFSET, info->bssid);\r\nspin_unlock_bh(&wl->lock);\r\n}\r\nif (changed & BSS_CHANGED_SSID) {\r\nspin_lock_bh(&wl->lock);\r\nbrcms_c_set_ssid(wl->wlc, info->ssid, info->ssid_len);\r\nspin_unlock_bh(&wl->lock);\r\n}\r\nif (changed & BSS_CHANGED_BEACON) {\r\nstruct sk_buff *beacon;\r\nu16 tim_offset = 0;\r\nspin_lock_bh(&wl->lock);\r\nbeacon = ieee80211_beacon_get_tim(hw, vif, &tim_offset, NULL);\r\nbrcms_c_set_new_beacon(wl->wlc, beacon, tim_offset,\r\ninfo->dtim_period);\r\nspin_unlock_bh(&wl->lock);\r\n}\r\nif (changed & BSS_CHANGED_AP_PROBE_RESP) {\r\nstruct sk_buff *probe_resp;\r\nspin_lock_bh(&wl->lock);\r\nprobe_resp = ieee80211_proberesp_get(hw, vif);\r\nbrcms_c_set_new_probe_resp(wl->wlc, probe_resp);\r\nspin_unlock_bh(&wl->lock);\r\n}\r\nif (changed & BSS_CHANGED_BEACON_ENABLED) {\r\nbrcms_err(core, "%s: Beacon enabled: %s\n", __func__,\r\ninfo->enable_beacon ? "true" : "false");\r\nif (info->enable_beacon &&\r\nhw->wiphy->flags & WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD) {\r\nbrcms_c_enable_probe_resp(wl->wlc, true);\r\n} else {\r\nbrcms_c_enable_probe_resp(wl->wlc, false);\r\n}\r\n}\r\nif (changed & BSS_CHANGED_CQM) {\r\nbrcms_err(core, "%s: cqm change: threshold %d, hys %d "\r\n" (implement)\n", __func__, info->cqm_rssi_thold,\r\ninfo->cqm_rssi_hyst);\r\n}\r\nif (changed & BSS_CHANGED_IBSS) {\r\nbrcms_err(core, "%s: IBSS joined: %s (implement)\n",\r\n__func__, info->ibss_joined ? "true" : "false");\r\n}\r\nif (changed & BSS_CHANGED_ARP_FILTER) {\r\nbrcms_err(core, "%s: arp filtering: %d addresses"\r\n" (implement)\n", __func__, info->arp_addr_cnt);\r\n}\r\nif (changed & BSS_CHANGED_QOS) {\r\nbrcms_err(core, "%s: qos enabled: %s (implement)\n",\r\n__func__, info->qos ? "true" : "false");\r\n}\r\nreturn;\r\n}\r\nstatic void\r\nbrcms_ops_configure_filter(struct ieee80211_hw *hw,\r\nunsigned int changed_flags,\r\nunsigned int *total_flags, u64 multicast)\r\n{\r\nstruct brcms_info *wl = hw->priv;\r\nstruct bcma_device *core = wl->wlc->hw->d11core;\r\nchanged_flags &= MAC_FILTERS;\r\n*total_flags &= MAC_FILTERS;\r\nif (changed_flags & FIF_PROMISC_IN_BSS)\r\nbrcms_dbg_info(core, "FIF_PROMISC_IN_BSS\n");\r\nif (changed_flags & FIF_ALLMULTI)\r\nbrcms_dbg_info(core, "FIF_ALLMULTI\n");\r\nif (changed_flags & FIF_FCSFAIL)\r\nbrcms_dbg_info(core, "FIF_FCSFAIL\n");\r\nif (changed_flags & FIF_CONTROL)\r\nbrcms_dbg_info(core, "FIF_CONTROL\n");\r\nif (changed_flags & FIF_OTHER_BSS)\r\nbrcms_dbg_info(core, "FIF_OTHER_BSS\n");\r\nif (changed_flags & FIF_PSPOLL)\r\nbrcms_dbg_info(core, "FIF_PSPOLL\n");\r\nif (changed_flags & FIF_BCN_PRBRESP_PROMISC)\r\nbrcms_dbg_info(core, "FIF_BCN_PRBRESP_PROMISC\n");\r\nspin_lock_bh(&wl->lock);\r\nbrcms_c_mac_promisc(wl->wlc, *total_flags);\r\nspin_unlock_bh(&wl->lock);\r\nreturn;\r\n}\r\nstatic void brcms_ops_sw_scan_start(struct ieee80211_hw *hw)\r\n{\r\nstruct brcms_info *wl = hw->priv;\r\nspin_lock_bh(&wl->lock);\r\nbrcms_c_scan_start(wl->wlc);\r\nspin_unlock_bh(&wl->lock);\r\nreturn;\r\n}\r\nstatic void brcms_ops_sw_scan_complete(struct ieee80211_hw *hw)\r\n{\r\nstruct brcms_info *wl = hw->priv;\r\nspin_lock_bh(&wl->lock);\r\nbrcms_c_scan_stop(wl->wlc);\r\nspin_unlock_bh(&wl->lock);\r\nreturn;\r\n}\r\nstatic int\r\nbrcms_ops_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif, u16 queue,\r\nconst struct ieee80211_tx_queue_params *params)\r\n{\r\nstruct brcms_info *wl = hw->priv;\r\nspin_lock_bh(&wl->lock);\r\nbrcms_c_wme_setparams(wl->wlc, queue, params, true);\r\nspin_unlock_bh(&wl->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nbrcms_ops_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct brcms_info *wl = hw->priv;\r\nstruct scb *scb = &wl->wlc->pri_scb;\r\nbrcms_c_init_scb(scb);\r\nwl->pub->global_ampdu = &(scb->scb_ampdu);\r\nwl->pub->global_ampdu->scb = scb;\r\nwl->pub->global_ampdu->max_pdu = 16;\r\nreturn 0;\r\n}\r\nstatic int\r\nbrcms_ops_ampdu_action(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nenum ieee80211_ampdu_mlme_action action,\r\nstruct ieee80211_sta *sta, u16 tid, u16 *ssn,\r\nu8 buf_size)\r\n{\r\nstruct brcms_info *wl = hw->priv;\r\nstruct scb *scb = &wl->wlc->pri_scb;\r\nint status;\r\nif (WARN_ON(scb->magic != SCB_MAGIC))\r\nreturn -EIDRM;\r\nswitch (action) {\r\ncase IEEE80211_AMPDU_RX_START:\r\nbreak;\r\ncase IEEE80211_AMPDU_RX_STOP:\r\nbreak;\r\ncase IEEE80211_AMPDU_TX_START:\r\nspin_lock_bh(&wl->lock);\r\nstatus = brcms_c_aggregatable(wl->wlc, tid);\r\nspin_unlock_bh(&wl->lock);\r\nif (!status) {\r\nbrcms_err(wl->wlc->hw->d11core,\r\n"START: tid %d is not agg\'able\n", tid);\r\nreturn -EINVAL;\r\n}\r\nieee80211_start_tx_ba_cb_irqsafe(vif, sta->addr, tid);\r\nbreak;\r\ncase IEEE80211_AMPDU_TX_STOP_CONT:\r\ncase IEEE80211_AMPDU_TX_STOP_FLUSH:\r\ncase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\r\nspin_lock_bh(&wl->lock);\r\nbrcms_c_ampdu_flush(wl->wlc, sta, tid);\r\nspin_unlock_bh(&wl->lock);\r\nieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\r\nbreak;\r\ncase IEEE80211_AMPDU_TX_OPERATIONAL:\r\nspin_lock_bh(&wl->lock);\r\nbrcms_c_ampdu_tx_operational(wl->wlc, tid, buf_size,\r\n(1 << (IEEE80211_HT_MAX_AMPDU_FACTOR +\r\nsta->ht_cap.ampdu_factor)) - 1);\r\nspin_unlock_bh(&wl->lock);\r\nbreak;\r\ndefault:\r\nbrcms_err(wl->wlc->hw->d11core,\r\n"%s: Invalid command, ignoring\n", __func__);\r\n}\r\nreturn 0;\r\n}\r\nstatic void brcms_ops_rfkill_poll(struct ieee80211_hw *hw)\r\n{\r\nstruct brcms_info *wl = hw->priv;\r\nbool blocked;\r\nspin_lock_bh(&wl->lock);\r\nblocked = brcms_c_check_radio_disabled(wl->wlc);\r\nspin_unlock_bh(&wl->lock);\r\nwiphy_rfkill_set_hw_state(wl->pub->ieee_hw->wiphy, blocked);\r\n}\r\nstatic bool brcms_tx_flush_completed(struct brcms_info *wl)\r\n{\r\nbool result;\r\nspin_lock_bh(&wl->lock);\r\nresult = brcms_c_tx_flush_completed(wl->wlc);\r\nspin_unlock_bh(&wl->lock);\r\nreturn result;\r\n}\r\nstatic void brcms_ops_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\r\nu32 queues, bool drop)\r\n{\r\nstruct brcms_info *wl = hw->priv;\r\nint ret;\r\nno_printk("%s: drop = %s\n", __func__, drop ? "true" : "false");\r\nret = wait_event_timeout(wl->tx_flush_wq,\r\nbrcms_tx_flush_completed(wl),\r\nmsecs_to_jiffies(BRCMS_FLUSH_TIMEOUT));\r\nbrcms_dbg_mac80211(wl->wlc->hw->d11core,\r\n"ret=%d\n", jiffies_to_msecs(ret));\r\n}\r\nstatic u64 brcms_ops_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\r\n{\r\nstruct brcms_info *wl = hw->priv;\r\nu64 tsf;\r\nspin_lock_bh(&wl->lock);\r\ntsf = brcms_c_tsf_get(wl->wlc);\r\nspin_unlock_bh(&wl->lock);\r\nreturn tsf;\r\n}\r\nstatic void brcms_ops_set_tsf(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, u64 tsf)\r\n{\r\nstruct brcms_info *wl = hw->priv;\r\nspin_lock_bh(&wl->lock);\r\nbrcms_c_tsf_set(wl->wlc, tsf);\r\nspin_unlock_bh(&wl->lock);\r\n}\r\nvoid brcms_dpc(unsigned long data)\r\n{\r\nstruct brcms_info *wl;\r\nwl = (struct brcms_info *) data;\r\nspin_lock_bh(&wl->lock);\r\nif (wl->pub->up) {\r\nif (wl->resched) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&wl->isr_lock, flags);\r\nbrcms_c_intrsupd(wl->wlc);\r\nspin_unlock_irqrestore(&wl->isr_lock, flags);\r\n}\r\nwl->resched = brcms_c_dpc(wl->wlc, true);\r\n}\r\nif (!wl->pub->up)\r\ngoto done;\r\nif (wl->resched)\r\ntasklet_schedule(&wl->tasklet);\r\nelse\r\nbrcms_intrson(wl);\r\ndone:\r\nspin_unlock_bh(&wl->lock);\r\nwake_up(&wl->tx_flush_wq);\r\n}\r\nstatic irqreturn_t brcms_isr(int irq, void *dev_id)\r\n{\r\nstruct brcms_info *wl;\r\nirqreturn_t ret = IRQ_NONE;\r\nwl = (struct brcms_info *) dev_id;\r\nspin_lock(&wl->isr_lock);\r\nif (brcms_c_isr(wl->wlc)) {\r\ntasklet_schedule(&wl->tasklet);\r\nret = IRQ_HANDLED;\r\n}\r\nspin_unlock(&wl->isr_lock);\r\nreturn ret;\r\n}\r\nstatic int ieee_hw_rate_init(struct ieee80211_hw *hw)\r\n{\r\nstruct brcms_info *wl = hw->priv;\r\nstruct brcms_c_info *wlc = wl->wlc;\r\nstruct ieee80211_supported_band *band;\r\nint has_5g = 0;\r\nu16 phy_type;\r\nhw->wiphy->bands[IEEE80211_BAND_2GHZ] = NULL;\r\nhw->wiphy->bands[IEEE80211_BAND_5GHZ] = NULL;\r\nphy_type = brcms_c_get_phy_type(wl->wlc, 0);\r\nif (phy_type == PHY_TYPE_N || phy_type == PHY_TYPE_LCN) {\r\nband = &wlc->bandstate[BAND_2G_INDEX]->band;\r\n*band = brcms_band_2GHz_nphy_template;\r\nif (phy_type == PHY_TYPE_LCN) {\r\nband->ht_cap.mcs.rx_mask[1] = 0;\r\nband->ht_cap.mcs.rx_highest = cpu_to_le16(72);\r\n}\r\nhw->wiphy->bands[IEEE80211_BAND_2GHZ] = band;\r\n} else {\r\nreturn -EPERM;\r\n}\r\nif (wl->pub->_nbands > 1) {\r\nhas_5g++;\r\nif (phy_type == PHY_TYPE_N || phy_type == PHY_TYPE_LCN) {\r\nband = &wlc->bandstate[BAND_5G_INDEX]->band;\r\n*band = brcms_band_5GHz_nphy_template;\r\nhw->wiphy->bands[IEEE80211_BAND_5GHZ] = band;\r\n} else {\r\nreturn -EPERM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ieee_hw_init(struct ieee80211_hw *hw)\r\n{\r\nhw->flags = IEEE80211_HW_SIGNAL_DBM\r\n| IEEE80211_HW_REPORTS_TX_ACK_STATUS\r\n| IEEE80211_HW_AMPDU_AGGREGATION;\r\nhw->extra_tx_headroom = brcms_c_get_header_len();\r\nhw->queues = N_TX_QUEUES;\r\nhw->max_rates = 2;\r\nhw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\r\nBIT(NL80211_IFTYPE_AP) |\r\nBIT(NL80211_IFTYPE_ADHOC);\r\nhw->rate_control_algorithm = "minstrel_ht";\r\nhw->sta_data_size = 0;\r\nreturn ieee_hw_rate_init(hw);\r\n}\r\nstatic struct brcms_info *brcms_attach(struct bcma_device *pdev)\r\n{\r\nstruct brcms_info *wl = NULL;\r\nint unit, err;\r\nstruct ieee80211_hw *hw;\r\nu8 perm[ETH_ALEN];\r\nunit = n_adapters_found;\r\nerr = 0;\r\nif (unit < 0)\r\nreturn NULL;\r\nhw = bcma_get_drvdata(pdev);\r\nif (hw != NULL)\r\nwl = hw->priv;\r\nif (WARN_ON(hw == NULL) || WARN_ON(wl == NULL))\r\nreturn NULL;\r\nwl->wiphy = hw->wiphy;\r\natomic_set(&wl->callbacks, 0);\r\ninit_waitqueue_head(&wl->tx_flush_wq);\r\ntasklet_init(&wl->tasklet, brcms_dpc, (unsigned long) wl);\r\nspin_lock_init(&wl->lock);\r\nspin_lock_init(&wl->isr_lock);\r\nwl->wlc = brcms_c_attach((void *)wl, pdev, unit, false, &err);\r\nif (!wl->wlc) {\r\nwiphy_err(wl->wiphy, "%s: attach() failed with code %d\n",\r\nKBUILD_MODNAME, err);\r\ngoto fail;\r\n}\r\nwl->pub = brcms_c_pub(wl->wlc);\r\nwl->pub->ieee_hw = hw;\r\nif (request_irq(pdev->irq, brcms_isr,\r\nIRQF_SHARED, KBUILD_MODNAME, wl)) {\r\nwiphy_err(wl->wiphy, "wl%d: request_irq() failed\n", unit);\r\ngoto fail;\r\n}\r\nwl->irq = pdev->irq;\r\nbrcms_c_module_register(wl->pub, "linux", wl, NULL);\r\nif (ieee_hw_init(hw)) {\r\nwiphy_err(wl->wiphy, "wl%d: %s: ieee_hw_init failed!\n", unit,\r\n__func__);\r\ngoto fail;\r\n}\r\nbrcms_c_regd_init(wl->wlc);\r\nmemcpy(perm, &wl->pub->cur_etheraddr, ETH_ALEN);\r\nif (WARN_ON(!is_valid_ether_addr(perm)))\r\ngoto fail;\r\nSET_IEEE80211_PERM_ADDR(hw, perm);\r\nerr = ieee80211_register_hw(hw);\r\nif (err)\r\nwiphy_err(wl->wiphy, "%s: ieee80211_register_hw failed, status"\r\n"%d\n", __func__, err);\r\nif (wl->pub->srom_ccode[0] &&\r\nregulatory_hint(wl->wiphy, wl->pub->srom_ccode))\r\nwiphy_err(wl->wiphy, "%s: regulatory hint failed\n", __func__);\r\nbrcms_debugfs_attach(wl->pub);\r\nbrcms_debugfs_create_files(wl->pub);\r\nn_adapters_found++;\r\nreturn wl;\r\nfail:\r\nbrcms_free(wl);\r\nreturn NULL;\r\n}\r\nstatic int brcms_bcma_probe(struct bcma_device *pdev)\r\n{\r\nstruct brcms_info *wl;\r\nstruct ieee80211_hw *hw;\r\ndev_info(&pdev->dev, "mfg %x core %x rev %d class %d irq %d\n",\r\npdev->id.manuf, pdev->id.id, pdev->id.rev, pdev->id.class,\r\npdev->irq);\r\nif ((pdev->id.manuf != BCMA_MANUF_BCM) ||\r\n(pdev->id.id != BCMA_CORE_80211))\r\nreturn -ENODEV;\r\nhw = ieee80211_alloc_hw(sizeof(struct brcms_info), &brcms_ops);\r\nif (!hw) {\r\npr_err("%s: ieee80211_alloc_hw failed\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nSET_IEEE80211_DEV(hw, &pdev->dev);\r\nbcma_set_drvdata(pdev, hw);\r\nmemset(hw->priv, 0, sizeof(*wl));\r\nwl = brcms_attach(pdev);\r\nif (!wl) {\r\npr_err("%s: brcms_attach failed!\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nbrcms_led_register(wl);\r\nreturn 0;\r\n}\r\nstatic int brcms_suspend(struct bcma_device *pdev)\r\n{\r\nstruct brcms_info *wl;\r\nstruct ieee80211_hw *hw;\r\nhw = bcma_get_drvdata(pdev);\r\nwl = hw->priv;\r\nif (!wl) {\r\npr_err("%s: %s: no driver private struct!\n", KBUILD_MODNAME,\r\n__func__);\r\nreturn -ENODEV;\r\n}\r\nspin_lock_bh(&wl->lock);\r\nwl->pub->hw_up = false;\r\nspin_unlock_bh(&wl->lock);\r\nbrcms_dbg_info(wl->wlc->hw->d11core, "brcms_suspend ok\n");\r\nreturn 0;\r\n}\r\nstatic int brcms_resume(struct bcma_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void brcms_driver_init(struct work_struct *work)\r\n{\r\nint error;\r\nerror = bcma_driver_register(&brcms_bcma_driver);\r\nif (error)\r\npr_err("%s: register returned %d\n", __func__, error);\r\n}\r\nstatic int __init brcms_module_init(void)\r\n{\r\nbrcms_debugfs_init();\r\nif (!schedule_work(&brcms_driver_work))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic void __exit brcms_module_exit(void)\r\n{\r\ncancel_work_sync(&brcms_driver_work);\r\nbcma_driver_unregister(&brcms_bcma_driver);\r\nbrcms_debugfs_exit();\r\n}\r\nvoid brcms_txflowcontrol(struct brcms_info *wl, struct brcms_if *wlif,\r\nbool state, int prio)\r\n{\r\nbrcms_err(wl->wlc->hw->d11core, "Shouldn't be here %s\n", __func__);\r\n}\r\nvoid brcms_init(struct brcms_info *wl)\r\n{\r\nbrcms_dbg_info(wl->wlc->hw->d11core, "Initializing wl%d\n",\r\nwl->pub->unit);\r\nbrcms_reset(wl);\r\nbrcms_c_init(wl->wlc, wl->mute_tx);\r\n}\r\nuint brcms_reset(struct brcms_info *wl)\r\n{\r\nbrcms_dbg_info(wl->wlc->hw->d11core, "Resetting wl%d\n", wl->pub->unit);\r\nbrcms_c_reset(wl->wlc);\r\nwl->resched = false;\r\nwl->pub->up = false;\r\nreturn 0;\r\n}\r\nvoid brcms_fatal_error(struct brcms_info *wl)\r\n{\r\nbrcms_err(wl->wlc->hw->d11core, "wl%d: fatal error, reinitializing\n",\r\nwl->wlc->pub->unit);\r\nbrcms_reset(wl);\r\nieee80211_restart_hw(wl->pub->ieee_hw);\r\n}\r\nvoid brcms_intrson(struct brcms_info *wl)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&wl->isr_lock, flags);\r\nbrcms_c_intrson(wl->wlc);\r\nspin_unlock_irqrestore(&wl->isr_lock, flags);\r\n}\r\nu32 brcms_intrsoff(struct brcms_info *wl)\r\n{\r\nunsigned long flags;\r\nu32 status;\r\nspin_lock_irqsave(&wl->isr_lock, flags);\r\nstatus = brcms_c_intrsoff(wl->wlc);\r\nspin_unlock_irqrestore(&wl->isr_lock, flags);\r\nreturn status;\r\n}\r\nvoid brcms_intrsrestore(struct brcms_info *wl, u32 macintmask)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&wl->isr_lock, flags);\r\nbrcms_c_intrsrestore(wl->wlc, macintmask);\r\nspin_unlock_irqrestore(&wl->isr_lock, flags);\r\n}\r\nint brcms_up(struct brcms_info *wl)\r\n{\r\nint error = 0;\r\nif (wl->pub->up)\r\nreturn 0;\r\nerror = brcms_c_up(wl->wlc);\r\nreturn error;\r\n}\r\nvoid brcms_down(struct brcms_info *wl)\r\n{\r\nuint callbacks, ret_val = 0;\r\nret_val = brcms_c_down(wl->wlc);\r\ncallbacks = atomic_read(&wl->callbacks) - ret_val;\r\nspin_unlock_bh(&wl->lock);\r\nSPINWAIT((atomic_read(&wl->callbacks) > callbacks), 100 * 1000);\r\nspin_lock_bh(&wl->lock);\r\n}\r\nstatic void _brcms_timer(struct work_struct *work)\r\n{\r\nstruct brcms_timer *t = container_of(work, struct brcms_timer,\r\ndly_wrk.work);\r\nspin_lock_bh(&t->wl->lock);\r\nif (t->set) {\r\nif (t->periodic) {\r\natomic_inc(&t->wl->callbacks);\r\nieee80211_queue_delayed_work(t->wl->pub->ieee_hw,\r\n&t->dly_wrk,\r\nmsecs_to_jiffies(t->ms));\r\n} else {\r\nt->set = false;\r\n}\r\nt->fn(t->arg);\r\n}\r\natomic_dec(&t->wl->callbacks);\r\nspin_unlock_bh(&t->wl->lock);\r\n}\r\nstruct brcms_timer *brcms_init_timer(struct brcms_info *wl,\r\nvoid (*fn) (void *arg),\r\nvoid *arg, const char *name)\r\n{\r\nstruct brcms_timer *t;\r\nt = kzalloc(sizeof(struct brcms_timer), GFP_ATOMIC);\r\nif (!t)\r\nreturn NULL;\r\nINIT_DELAYED_WORK(&t->dly_wrk, _brcms_timer);\r\nt->wl = wl;\r\nt->fn = fn;\r\nt->arg = arg;\r\nt->next = wl->timers;\r\nwl->timers = t;\r\n#ifdef DEBUG\r\nt->name = kmalloc(strlen(name) + 1, GFP_ATOMIC);\r\nif (t->name)\r\nstrcpy(t->name, name);\r\n#endif\r\nreturn t;\r\n}\r\nvoid brcms_add_timer(struct brcms_timer *t, uint ms, int periodic)\r\n{\r\nstruct ieee80211_hw *hw = t->wl->pub->ieee_hw;\r\n#ifdef DEBUG\r\nif (t->set)\r\nbrcms_dbg_info(t->wl->wlc->hw->d11core,\r\n"%s: Already set. Name: %s, per %d\n",\r\n__func__, t->name, periodic);\r\n#endif\r\nt->ms = ms;\r\nt->periodic = (bool) periodic;\r\nif (!t->set) {\r\nt->set = true;\r\natomic_inc(&t->wl->callbacks);\r\n}\r\nieee80211_queue_delayed_work(hw, &t->dly_wrk, msecs_to_jiffies(ms));\r\n}\r\nbool brcms_del_timer(struct brcms_timer *t)\r\n{\r\nif (t->set) {\r\nt->set = false;\r\nif (!cancel_delayed_work(&t->dly_wrk))\r\nreturn false;\r\natomic_dec(&t->wl->callbacks);\r\n}\r\nreturn true;\r\n}\r\nvoid brcms_free_timer(struct brcms_timer *t)\r\n{\r\nstruct brcms_info *wl = t->wl;\r\nstruct brcms_timer *tmp;\r\nbrcms_del_timer(t);\r\nif (wl->timers == t) {\r\nwl->timers = wl->timers->next;\r\n#ifdef DEBUG\r\nkfree(t->name);\r\n#endif\r\nkfree(t);\r\nreturn;\r\n}\r\ntmp = wl->timers;\r\nwhile (tmp) {\r\nif (tmp->next == t) {\r\ntmp->next = t->next;\r\n#ifdef DEBUG\r\nkfree(t->name);\r\n#endif\r\nkfree(t);\r\nreturn;\r\n}\r\ntmp = tmp->next;\r\n}\r\n}\r\nint brcms_ucode_init_buf(struct brcms_info *wl, void **pbuf, u32 idx)\r\n{\r\nint i, entry;\r\nconst u8 *pdata;\r\nstruct firmware_hdr *hdr;\r\nfor (i = 0; i < wl->fw.fw_cnt; i++) {\r\nhdr = (struct firmware_hdr *)wl->fw.fw_hdr[i]->data;\r\nfor (entry = 0; entry < wl->fw.hdr_num_entries[i];\r\nentry++, hdr++) {\r\nu32 len = le32_to_cpu(hdr->len);\r\nif (le32_to_cpu(hdr->idx) == idx) {\r\npdata = wl->fw.fw_bin[i]->data +\r\nle32_to_cpu(hdr->offset);\r\n*pbuf = kmemdup(pdata, len, GFP_ATOMIC);\r\nif (*pbuf == NULL)\r\ngoto fail;\r\nreturn 0;\r\n}\r\n}\r\n}\r\nbrcms_err(wl->wlc->hw->d11core,\r\n"ERROR: ucode buf tag:%d can not be found!\n", idx);\r\n*pbuf = NULL;\r\nfail:\r\nreturn -ENODATA;\r\n}\r\nint brcms_ucode_init_uint(struct brcms_info *wl, size_t *n_bytes, u32 idx)\r\n{\r\nint i, entry;\r\nconst u8 *pdata;\r\nstruct firmware_hdr *hdr;\r\nfor (i = 0; i < wl->fw.fw_cnt; i++) {\r\nhdr = (struct firmware_hdr *)wl->fw.fw_hdr[i]->data;\r\nfor (entry = 0; entry < wl->fw.hdr_num_entries[i];\r\nentry++, hdr++) {\r\nif (le32_to_cpu(hdr->idx) == idx) {\r\npdata = wl->fw.fw_bin[i]->data +\r\nle32_to_cpu(hdr->offset);\r\nif (le32_to_cpu(hdr->len) != 4) {\r\nbrcms_err(wl->wlc->hw->d11core,\r\n"ERROR: fw hdr len\n");\r\nreturn -ENOMSG;\r\n}\r\n*n_bytes = le32_to_cpu(*((__le32 *) pdata));\r\nreturn 0;\r\n}\r\n}\r\n}\r\nbrcms_err(wl->wlc->hw->d11core,\r\n"ERROR: ucode tag:%d can not be found!\n", idx);\r\nreturn -ENOMSG;\r\n}\r\nvoid brcms_ucode_free_buf(void *p)\r\n{\r\nkfree(p);\r\n}\r\nint brcms_check_firmwares(struct brcms_info *wl)\r\n{\r\nint i;\r\nint entry;\r\nint rc = 0;\r\nconst struct firmware *fw;\r\nconst struct firmware *fw_hdr;\r\nstruct firmware_hdr *ucode_hdr;\r\nfor (i = 0; i < MAX_FW_IMAGES && rc == 0; i++) {\r\nfw = wl->fw.fw_bin[i];\r\nfw_hdr = wl->fw.fw_hdr[i];\r\nif (fw == NULL && fw_hdr == NULL) {\r\nbreak;\r\n} else if (fw == NULL || fw_hdr == NULL) {\r\nwiphy_err(wl->wiphy, "%s: invalid bin/hdr fw\n",\r\n__func__);\r\nrc = -EBADF;\r\n} else if (fw_hdr->size % sizeof(struct firmware_hdr)) {\r\nwiphy_err(wl->wiphy, "%s: non integral fw hdr file "\r\n"size %zu/%zu\n", __func__, fw_hdr->size,\r\nsizeof(struct firmware_hdr));\r\nrc = -EBADF;\r\n} else if (fw->size < MIN_FW_SIZE || fw->size > MAX_FW_SIZE) {\r\nwiphy_err(wl->wiphy, "%s: out of bounds fw file size %zu\n",\r\n__func__, fw->size);\r\nrc = -EBADF;\r\n} else {\r\nucode_hdr = (struct firmware_hdr *)fw_hdr->data;\r\nfor (entry = 0; entry < wl->fw.hdr_num_entries[i] &&\r\n!rc; entry++, ucode_hdr++) {\r\nif (le32_to_cpu(ucode_hdr->offset) +\r\nle32_to_cpu(ucode_hdr->len) >\r\nfw->size) {\r\nwiphy_err(wl->wiphy,\r\n"%s: conflicting bin/hdr\n",\r\n__func__);\r\nrc = -EBADF;\r\n}\r\n}\r\n}\r\n}\r\nif (rc == 0 && wl->fw.fw_cnt != i) {\r\nwiphy_err(wl->wiphy, "%s: invalid fw_cnt=%d\n", __func__,\r\nwl->fw.fw_cnt);\r\nrc = -EBADF;\r\n}\r\nreturn rc;\r\n}\r\nbool brcms_rfkill_set_hw_state(struct brcms_info *wl)\r\n{\r\nbool blocked = brcms_c_check_radio_disabled(wl->wlc);\r\nspin_unlock_bh(&wl->lock);\r\nwiphy_rfkill_set_hw_state(wl->pub->ieee_hw->wiphy, blocked);\r\nif (blocked)\r\nwiphy_rfkill_start_polling(wl->pub->ieee_hw->wiphy);\r\nspin_lock_bh(&wl->lock);\r\nreturn blocked;\r\n}
