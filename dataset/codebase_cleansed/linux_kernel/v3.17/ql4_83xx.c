uint32_t qla4_83xx_rd_reg(struct scsi_qla_host *ha, ulong addr)\r\n{\r\nreturn readl((void __iomem *)(ha->nx_pcibase + addr));\r\n}\r\nvoid qla4_83xx_wr_reg(struct scsi_qla_host *ha, ulong addr, uint32_t val)\r\n{\r\nwritel(val, (void __iomem *)(ha->nx_pcibase + addr));\r\n}\r\nstatic int qla4_83xx_set_win_base(struct scsi_qla_host *ha, uint32_t addr)\r\n{\r\nuint32_t val;\r\nint ret_val = QLA_SUCCESS;\r\nqla4_83xx_wr_reg(ha, QLA83XX_CRB_WIN_FUNC(ha->func_num), addr);\r\nval = qla4_83xx_rd_reg(ha, QLA83XX_CRB_WIN_FUNC(ha->func_num));\r\nif (val != addr) {\r\nql4_printk(KERN_ERR, ha, "%s: Failed to set register window : addr written 0x%x, read 0x%x!\n",\r\n__func__, addr, val);\r\nret_val = QLA_ERROR;\r\n}\r\nreturn ret_val;\r\n}\r\nint qla4_83xx_rd_reg_indirect(struct scsi_qla_host *ha, uint32_t addr,\r\nuint32_t *data)\r\n{\r\nint ret_val;\r\nret_val = qla4_83xx_set_win_base(ha, addr);\r\nif (ret_val == QLA_SUCCESS)\r\n*data = qla4_83xx_rd_reg(ha, QLA83XX_WILDCARD);\r\nelse\r\nql4_printk(KERN_ERR, ha, "%s: failed read of addr 0x%x!\n",\r\n__func__, addr);\r\nreturn ret_val;\r\n}\r\nint qla4_83xx_wr_reg_indirect(struct scsi_qla_host *ha, uint32_t addr,\r\nuint32_t data)\r\n{\r\nint ret_val;\r\nret_val = qla4_83xx_set_win_base(ha, addr);\r\nif (ret_val == QLA_SUCCESS)\r\nqla4_83xx_wr_reg(ha, QLA83XX_WILDCARD, data);\r\nelse\r\nql4_printk(KERN_ERR, ha, "%s: failed wrt to addr 0x%x, data 0x%x\n",\r\n__func__, addr, data);\r\nreturn ret_val;\r\n}\r\nstatic int qla4_83xx_flash_lock(struct scsi_qla_host *ha)\r\n{\r\nint lock_owner;\r\nint timeout = 0;\r\nuint32_t lock_status = 0;\r\nint ret_val = QLA_SUCCESS;\r\nwhile (lock_status == 0) {\r\nlock_status = qla4_83xx_rd_reg(ha, QLA83XX_FLASH_LOCK);\r\nif (lock_status)\r\nbreak;\r\nif (++timeout >= QLA83XX_FLASH_LOCK_TIMEOUT / 20) {\r\nlock_owner = qla4_83xx_rd_reg(ha,\r\nQLA83XX_FLASH_LOCK_ID);\r\nql4_printk(KERN_ERR, ha, "%s: flash lock by func %d failed, held by func %d\n",\r\n__func__, ha->func_num, lock_owner);\r\nret_val = QLA_ERROR;\r\nbreak;\r\n}\r\nmsleep(20);\r\n}\r\nqla4_83xx_wr_reg(ha, QLA83XX_FLASH_LOCK_ID, ha->func_num);\r\nreturn ret_val;\r\n}\r\nstatic void qla4_83xx_flash_unlock(struct scsi_qla_host *ha)\r\n{\r\nqla4_83xx_wr_reg(ha, QLA83XX_FLASH_LOCK_ID, 0xFF);\r\nqla4_83xx_rd_reg(ha, QLA83XX_FLASH_UNLOCK);\r\n}\r\nint qla4_83xx_flash_read_u32(struct scsi_qla_host *ha, uint32_t flash_addr,\r\nuint8_t *p_data, int u32_word_count)\r\n{\r\nint i;\r\nuint32_t u32_word;\r\nuint32_t addr = flash_addr;\r\nint ret_val = QLA_SUCCESS;\r\nret_val = qla4_83xx_flash_lock(ha);\r\nif (ret_val == QLA_ERROR)\r\ngoto exit_lock_error;\r\nif (addr & 0x03) {\r\nql4_printk(KERN_ERR, ha, "%s: Illegal addr = 0x%x\n",\r\n__func__, addr);\r\nret_val = QLA_ERROR;\r\ngoto exit_flash_read;\r\n}\r\nfor (i = 0; i < u32_word_count; i++) {\r\nret_val = qla4_83xx_wr_reg_indirect(ha,\r\nQLA83XX_FLASH_DIRECT_WINDOW,\r\n(addr & 0xFFFF0000));\r\nif (ret_val == QLA_ERROR) {\r\nql4_printk(KERN_ERR, ha, "%s: failed to write addr 0x%x to FLASH_DIRECT_WINDOW\n!",\r\n__func__, addr);\r\ngoto exit_flash_read;\r\n}\r\nret_val = qla4_83xx_rd_reg_indirect(ha,\r\nQLA83XX_FLASH_DIRECT_DATA(addr),\r\n&u32_word);\r\nif (ret_val == QLA_ERROR) {\r\nql4_printk(KERN_ERR, ha, "%s: failed to read addr 0x%x!\n",\r\n__func__, addr);\r\ngoto exit_flash_read;\r\n}\r\n*(__le32 *)p_data = le32_to_cpu(u32_word);\r\np_data = p_data + 4;\r\naddr = addr + 4;\r\n}\r\nexit_flash_read:\r\nqla4_83xx_flash_unlock(ha);\r\nexit_lock_error:\r\nreturn ret_val;\r\n}\r\nint qla4_83xx_lockless_flash_read_u32(struct scsi_qla_host *ha,\r\nuint32_t flash_addr, uint8_t *p_data,\r\nint u32_word_count)\r\n{\r\nuint32_t i;\r\nuint32_t u32_word;\r\nuint32_t flash_offset;\r\nuint32_t addr = flash_addr;\r\nint ret_val = QLA_SUCCESS;\r\nflash_offset = addr & (QLA83XX_FLASH_SECTOR_SIZE - 1);\r\nif (addr & 0x3) {\r\nql4_printk(KERN_ERR, ha, "%s: Illegal addr = 0x%x\n",\r\n__func__, addr);\r\nret_val = QLA_ERROR;\r\ngoto exit_lockless_read;\r\n}\r\nret_val = qla4_83xx_wr_reg_indirect(ha, QLA83XX_FLASH_DIRECT_WINDOW,\r\naddr);\r\nif (ret_val == QLA_ERROR) {\r\nql4_printk(KERN_ERR, ha, "%s: failed to write addr 0x%x to FLASH_DIRECT_WINDOW!\n",\r\n__func__, addr);\r\ngoto exit_lockless_read;\r\n}\r\nif ((flash_offset + (u32_word_count * sizeof(uint32_t))) >\r\n(QLA83XX_FLASH_SECTOR_SIZE - 1)) {\r\nfor (i = 0; i < u32_word_count; i++) {\r\nret_val = qla4_83xx_rd_reg_indirect(ha,\r\nQLA83XX_FLASH_DIRECT_DATA(addr),\r\n&u32_word);\r\nif (ret_val == QLA_ERROR) {\r\nql4_printk(KERN_ERR, ha, "%s: failed to read addr 0x%x!\n",\r\n__func__, addr);\r\ngoto exit_lockless_read;\r\n}\r\n*(__le32 *)p_data = le32_to_cpu(u32_word);\r\np_data = p_data + 4;\r\naddr = addr + 4;\r\nflash_offset = flash_offset + 4;\r\nif (flash_offset > (QLA83XX_FLASH_SECTOR_SIZE - 1)) {\r\nret_val = qla4_83xx_wr_reg_indirect(ha,\r\nQLA83XX_FLASH_DIRECT_WINDOW,\r\naddr);\r\nif (ret_val == QLA_ERROR) {\r\nql4_printk(KERN_ERR, ha, "%s: failed to write addr 0x%x to FLASH_DIRECT_WINDOW!\n",\r\n__func__, addr);\r\ngoto exit_lockless_read;\r\n}\r\nflash_offset = 0;\r\n}\r\n}\r\n} else {\r\nfor (i = 0; i < u32_word_count; i++) {\r\nret_val = qla4_83xx_rd_reg_indirect(ha,\r\nQLA83XX_FLASH_DIRECT_DATA(addr),\r\n&u32_word);\r\nif (ret_val == QLA_ERROR) {\r\nql4_printk(KERN_ERR, ha, "%s: failed to read addr 0x%x!\n",\r\n__func__, addr);\r\ngoto exit_lockless_read;\r\n}\r\n*(__le32 *)p_data = le32_to_cpu(u32_word);\r\np_data = p_data + 4;\r\naddr = addr + 4;\r\n}\r\n}\r\nexit_lockless_read:\r\nreturn ret_val;\r\n}\r\nvoid qla4_83xx_rom_lock_recovery(struct scsi_qla_host *ha)\r\n{\r\nif (qla4_83xx_flash_lock(ha))\r\nql4_printk(KERN_INFO, ha, "%s: Resetting rom lock\n", __func__);\r\nqla4_83xx_flash_unlock(ha);\r\n}\r\nstatic int qla4_83xx_lock_recovery(struct scsi_qla_host *ha)\r\n{\r\nuint32_t lock = 0, lockid;\r\nint ret_val = QLA_ERROR;\r\nlockid = ha->isp_ops->rd_reg_direct(ha, QLA83XX_DRV_LOCKRECOVERY);\r\nif ((lockid & 0x3) != 0)\r\ngoto exit_lock_recovery;\r\nha->isp_ops->wr_reg_direct(ha, QLA83XX_DRV_LOCKRECOVERY,\r\n(ha->func_num << 2) | INTENT_TO_RECOVER);\r\nmsleep(200);\r\nlockid = ha->isp_ops->rd_reg_direct(ha, QLA83XX_DRV_LOCKRECOVERY);\r\nif ((lockid & 0x3C) != (ha->func_num << 2))\r\ngoto exit_lock_recovery;\r\nql4_printk(KERN_INFO, ha, "%s: IDC Lock recovery initiated for func %d\n",\r\n__func__, ha->func_num);\r\nha->isp_ops->wr_reg_direct(ha, QLA83XX_DRV_LOCKRECOVERY,\r\n(ha->func_num << 2) | PROCEED_TO_RECOVER);\r\nha->isp_ops->wr_reg_direct(ha, QLA83XX_DRV_LOCK_ID, 0xFF);\r\nha->isp_ops->rd_reg_direct(ha, QLA83XX_DRV_UNLOCK);\r\nha->isp_ops->wr_reg_direct(ha, QLA83XX_DRV_LOCKRECOVERY, 0);\r\nlock = ha->isp_ops->rd_reg_direct(ha, QLA83XX_DRV_LOCK);\r\nif (lock) {\r\nlockid = ha->isp_ops->rd_reg_direct(ha, QLA83XX_DRV_LOCK_ID);\r\nlockid = ((lockid + (1 << 8)) & ~0xFF) | ha->func_num;\r\nha->isp_ops->wr_reg_direct(ha, QLA83XX_DRV_LOCK_ID, lockid);\r\nret_val = QLA_SUCCESS;\r\n}\r\nexit_lock_recovery:\r\nreturn ret_val;\r\n}\r\nint qla4_83xx_drv_lock(struct scsi_qla_host *ha)\r\n{\r\nint timeout = 0;\r\nuint32_t status = 0;\r\nint ret_val = QLA_SUCCESS;\r\nuint32_t first_owner = 0;\r\nuint32_t tmo_owner = 0;\r\nuint32_t lock_id;\r\nuint32_t func_num;\r\nuint32_t lock_cnt;\r\nwhile (status == 0) {\r\nstatus = qla4_83xx_rd_reg(ha, QLA83XX_DRV_LOCK);\r\nif (status) {\r\nlock_id = qla4_83xx_rd_reg(ha, QLA83XX_DRV_LOCK_ID);\r\nlock_id = ((lock_id + (1 << 8)) & ~0xFF) | ha->func_num;\r\nqla4_83xx_wr_reg(ha, QLA83XX_DRV_LOCK_ID, lock_id);\r\nbreak;\r\n}\r\nif (timeout == 0)\r\nfirst_owner = ha->isp_ops->rd_reg_direct(ha,\r\nQLA83XX_DRV_LOCK_ID);\r\nif (++timeout >=\r\n(QLA83XX_DRV_LOCK_TIMEOUT / QLA83XX_DRV_LOCK_MSLEEP)) {\r\ntmo_owner = qla4_83xx_rd_reg(ha, QLA83XX_DRV_LOCK_ID);\r\nfunc_num = tmo_owner & 0xFF;\r\nlock_cnt = tmo_owner >> 8;\r\nql4_printk(KERN_INFO, ha, "%s: Lock by func %d failed after 2s, lock held by func %d, lock count %d, first_owner %d\n",\r\n__func__, ha->func_num, func_num, lock_cnt,\r\n(first_owner & 0xFF));\r\nif (first_owner != tmo_owner) {\r\nql4_printk(KERN_INFO, ha, "%s: IDC lock failed for func %d\n",\r\n__func__, ha->func_num);\r\ntimeout = 0;\r\n} else {\r\nret_val = qla4_83xx_lock_recovery(ha);\r\nif (ret_val == QLA_SUCCESS) {\r\nql4_printk(KERN_INFO, ha, "%s: IDC lock Recovery by %d successful\n",\r\n__func__, ha->func_num);\r\nbreak;\r\n}\r\nql4_printk(KERN_INFO, ha, "%s: IDC lock Recovery by %d failed, Retrying timeout\n",\r\n__func__, ha->func_num);\r\ntimeout = 0;\r\n}\r\n}\r\nmsleep(QLA83XX_DRV_LOCK_MSLEEP);\r\n}\r\nreturn ret_val;\r\n}\r\nvoid qla4_83xx_drv_unlock(struct scsi_qla_host *ha)\r\n{\r\nint id;\r\nid = qla4_83xx_rd_reg(ha, QLA83XX_DRV_LOCK_ID);\r\nif ((id & 0xFF) != ha->func_num) {\r\nql4_printk(KERN_ERR, ha, "%s: IDC Unlock by %d failed, lock owner is %d\n",\r\n__func__, ha->func_num, (id & 0xFF));\r\nreturn;\r\n}\r\nqla4_83xx_wr_reg(ha, QLA83XX_DRV_LOCK_ID, (id | 0xFF));\r\nqla4_83xx_rd_reg(ha, QLA83XX_DRV_UNLOCK);\r\n}\r\nvoid qla4_83xx_set_idc_dontreset(struct scsi_qla_host *ha)\r\n{\r\nuint32_t idc_ctrl;\r\nidc_ctrl = qla4_83xx_rd_reg(ha, QLA83XX_IDC_DRV_CTRL);\r\nidc_ctrl |= DONTRESET_BIT0;\r\nqla4_83xx_wr_reg(ha, QLA83XX_IDC_DRV_CTRL, idc_ctrl);\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: idc_ctrl = %d\n", __func__,\r\nidc_ctrl));\r\n}\r\nvoid qla4_83xx_clear_idc_dontreset(struct scsi_qla_host *ha)\r\n{\r\nuint32_t idc_ctrl;\r\nidc_ctrl = qla4_83xx_rd_reg(ha, QLA83XX_IDC_DRV_CTRL);\r\nidc_ctrl &= ~DONTRESET_BIT0;\r\nqla4_83xx_wr_reg(ha, QLA83XX_IDC_DRV_CTRL, idc_ctrl);\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: idc_ctrl = %d\n", __func__,\r\nidc_ctrl));\r\n}\r\nint qla4_83xx_idc_dontreset(struct scsi_qla_host *ha)\r\n{\r\nuint32_t idc_ctrl;\r\nidc_ctrl = qla4_83xx_rd_reg(ha, QLA83XX_IDC_DRV_CTRL);\r\nreturn idc_ctrl & DONTRESET_BIT0;\r\n}\r\nint qla4_83xx_can_perform_reset(struct scsi_qla_host *ha)\r\n{\r\nuint32_t drv_active;\r\nuint32_t dev_part, dev_part1, dev_part2;\r\nint i;\r\nstruct device_info device_map[16];\r\nint func_nibble;\r\nint nibble;\r\nint nic_present = 0;\r\nint iscsi_present = 0;\r\nint iscsi_func_low = 0;\r\ndev_part1 = qla4_83xx_rd_reg(ha,\r\nha->reg_tbl[QLA8XXX_CRB_DEV_PART_INFO]);\r\ndev_part2 = qla4_83xx_rd_reg(ha, QLA83XX_CRB_DEV_PART_INFO2);\r\ndrv_active = qla4_83xx_rd_reg(ha, ha->reg_tbl[QLA8XXX_CRB_DRV_ACTIVE]);\r\ndev_part = dev_part1;\r\nfor (i = nibble = 0; i <= 15; i++, nibble++) {\r\nfunc_nibble = dev_part & (0xF << (nibble * 4));\r\nfunc_nibble >>= (nibble * 4);\r\ndevice_map[i].func_num = i;\r\ndevice_map[i].device_type = func_nibble & 0x3;\r\ndevice_map[i].port_num = func_nibble & 0xC;\r\nif (device_map[i].device_type == NIC_CLASS) {\r\nif (drv_active & (1 << device_map[i].func_num)) {\r\nnic_present++;\r\nbreak;\r\n}\r\n} else if (device_map[i].device_type == ISCSI_CLASS) {\r\nif (drv_active & (1 << device_map[i].func_num)) {\r\nif (!iscsi_present ||\r\n(iscsi_present &&\r\n(iscsi_func_low > device_map[i].func_num)))\r\niscsi_func_low = device_map[i].func_num;\r\niscsi_present++;\r\n}\r\n}\r\nif (nibble == 7) {\r\nnibble = 0;\r\ndev_part = dev_part2;\r\n}\r\n}\r\nif (!nic_present && (ha->func_num == iscsi_func_low)) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: can reset - NIC not present and lower iSCSI function is %d\n",\r\n__func__, ha->func_num));\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid qla4_83xx_need_reset_handler(struct scsi_qla_host *ha)\r\n{\r\nuint32_t dev_state, drv_state, drv_active;\r\nunsigned long reset_timeout, dev_init_timeout;\r\nql4_printk(KERN_INFO, ha, "%s: Performing ISP error recovery\n",\r\n__func__);\r\nif (!test_bit(AF_8XXX_RST_OWNER, &ha->flags)) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: reset acknowledged\n",\r\n__func__));\r\nqla4_8xxx_set_rst_ready(ha);\r\ndev_init_timeout = jiffies + (ha->nx_dev_init_timeout * HZ);\r\ndo {\r\nif (time_after_eq(jiffies, dev_init_timeout)) {\r\nql4_printk(KERN_INFO, ha, "%s: Non Reset owner dev init timeout\n",\r\n__func__);\r\nbreak;\r\n}\r\nha->isp_ops->idc_unlock(ha);\r\nmsleep(1000);\r\nha->isp_ops->idc_lock(ha);\r\ndev_state = qla4_8xxx_rd_direct(ha,\r\nQLA8XXX_CRB_DEV_STATE);\r\n} while (dev_state == QLA8XXX_DEV_NEED_RESET);\r\n} else {\r\nqla4_8xxx_set_rst_ready(ha);\r\nreset_timeout = jiffies + (ha->nx_reset_timeout * HZ);\r\ndrv_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_STATE);\r\ndrv_active = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_ACTIVE);\r\nql4_printk(KERN_INFO, ha, "%s: drv_state = 0x%x, drv_active = 0x%x\n",\r\n__func__, drv_state, drv_active);\r\nwhile (drv_state != drv_active) {\r\nif (time_after_eq(jiffies, reset_timeout)) {\r\nql4_printk(KERN_INFO, ha, "%s: %s: RESET TIMEOUT! drv_state: 0x%08x, drv_active: 0x%08x\n",\r\n__func__, DRIVER_NAME, drv_state,\r\ndrv_active);\r\nbreak;\r\n}\r\nha->isp_ops->idc_unlock(ha);\r\nmsleep(1000);\r\nha->isp_ops->idc_lock(ha);\r\ndrv_state = qla4_8xxx_rd_direct(ha,\r\nQLA8XXX_CRB_DRV_STATE);\r\ndrv_active = qla4_8xxx_rd_direct(ha,\r\nQLA8XXX_CRB_DRV_ACTIVE);\r\n}\r\nif (drv_state != drv_active) {\r\nql4_printk(KERN_INFO, ha, "%s: Reset_owner turning off drv_active of non-acking function 0x%x\n",\r\n__func__, (drv_active ^ drv_state));\r\ndrv_active = drv_active & drv_state;\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DRV_ACTIVE,\r\ndrv_active);\r\n}\r\nclear_bit(AF_8XXX_RST_OWNER, &ha->flags);\r\nqla4_8xxx_device_bootstrap(ha);\r\n}\r\n}\r\nvoid qla4_83xx_get_idc_param(struct scsi_qla_host *ha)\r\n{\r\nuint32_t idc_params, ret_val;\r\nret_val = qla4_83xx_flash_read_u32(ha, QLA83XX_IDC_PARAM_ADDR,\r\n(uint8_t *)&idc_params, 1);\r\nif (ret_val == QLA_SUCCESS) {\r\nha->nx_dev_init_timeout = idc_params & 0xFFFF;\r\nha->nx_reset_timeout = (idc_params >> 16) & 0xFFFF;\r\n} else {\r\nha->nx_dev_init_timeout = ROM_DEV_INIT_TIMEOUT;\r\nha->nx_reset_timeout = ROM_DRV_RESET_ACK_TIMEOUT;\r\n}\r\nDEBUG2(ql4_printk(KERN_DEBUG, ha,\r\n"%s: ha->nx_dev_init_timeout = %d, ha->nx_reset_timeout = %d\n",\r\n__func__, ha->nx_dev_init_timeout,\r\nha->nx_reset_timeout));\r\n}\r\nstatic void qla4_83xx_dump_reset_seq_hdr(struct scsi_qla_host *ha)\r\n{\r\nuint8_t *phdr;\r\nif (!ha->reset_tmplt.buff) {\r\nql4_printk(KERN_ERR, ha, "%s: Error: Invalid reset_seq_template\n",\r\n__func__);\r\nreturn;\r\n}\r\nphdr = ha->reset_tmplt.buff;\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Reset Template: 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X\n",\r\n*phdr, *(phdr+1), *(phdr+2), *(phdr+3), *(phdr+4),\r\n*(phdr+5), *(phdr+6), *(phdr+7), *(phdr + 8),\r\n*(phdr+9), *(phdr+10), *(phdr+11), *(phdr+12),\r\n*(phdr+13), *(phdr+14), *(phdr+15)));\r\n}\r\nstatic int qla4_83xx_copy_bootloader(struct scsi_qla_host *ha)\r\n{\r\nuint8_t *p_cache;\r\nuint32_t src, count, size;\r\nuint64_t dest;\r\nint ret_val = QLA_SUCCESS;\r\nsrc = QLA83XX_BOOTLOADER_FLASH_ADDR;\r\ndest = qla4_83xx_rd_reg(ha, QLA83XX_BOOTLOADER_ADDR);\r\nsize = qla4_83xx_rd_reg(ha, QLA83XX_BOOTLOADER_SIZE);\r\nif (size & 0xF)\r\nsize = (size + 16) & ~0xF;\r\ncount = size/16;\r\np_cache = vmalloc(size);\r\nif (p_cache == NULL) {\r\nql4_printk(KERN_ERR, ha, "%s: Failed to allocate memory for boot loader cache\n",\r\n__func__);\r\nret_val = QLA_ERROR;\r\ngoto exit_copy_bootloader;\r\n}\r\nret_val = qla4_83xx_lockless_flash_read_u32(ha, src, p_cache,\r\nsize / sizeof(uint32_t));\r\nif (ret_val == QLA_ERROR) {\r\nql4_printk(KERN_ERR, ha, "%s: Error reading firmware from flash\n",\r\n__func__);\r\ngoto exit_copy_error;\r\n}\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: Read firmware from flash\n",\r\n__func__));\r\nret_val = qla4_8xxx_ms_mem_write_128b(ha, dest, (uint32_t *)p_cache,\r\ncount);\r\nif (ret_val == QLA_ERROR) {\r\nql4_printk(KERN_ERR, ha, "%s: Error writing firmware to MS\n",\r\n__func__);\r\ngoto exit_copy_error;\r\n}\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: Wrote firmware size %d to MS\n",\r\n__func__, size));\r\nexit_copy_error:\r\nvfree(p_cache);\r\nexit_copy_bootloader:\r\nreturn ret_val;\r\n}\r\nstatic int qla4_83xx_check_cmd_peg_status(struct scsi_qla_host *ha)\r\n{\r\nuint32_t val, ret_val = QLA_ERROR;\r\nint retries = CRB_CMDPEG_CHECK_RETRY_COUNT;\r\ndo {\r\nval = qla4_83xx_rd_reg(ha, QLA83XX_CMDPEG_STATE);\r\nif (val == PHAN_INITIALIZE_COMPLETE) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: Command Peg initialization complete. State=0x%x\n",\r\n__func__, val));\r\nret_val = QLA_SUCCESS;\r\nbreak;\r\n}\r\nmsleep(CRB_CMDPEG_CHECK_DELAY);\r\n} while (--retries);\r\nreturn ret_val;\r\n}\r\nstatic int qla4_83xx_poll_reg(struct scsi_qla_host *ha, uint32_t addr,\r\nint duration, uint32_t test_mask,\r\nuint32_t test_result)\r\n{\r\nuint32_t value;\r\nuint8_t retries;\r\nint ret_val = QLA_SUCCESS;\r\nret_val = qla4_83xx_rd_reg_indirect(ha, addr, &value);\r\nif (ret_val == QLA_ERROR)\r\ngoto exit_poll_reg;\r\nretries = duration / 10;\r\ndo {\r\nif ((value & test_mask) != test_result) {\r\nmsleep(duration / 10);\r\nret_val = qla4_83xx_rd_reg_indirect(ha, addr, &value);\r\nif (ret_val == QLA_ERROR)\r\ngoto exit_poll_reg;\r\nret_val = QLA_ERROR;\r\n} else {\r\nret_val = QLA_SUCCESS;\r\nbreak;\r\n}\r\n} while (retries--);\r\nexit_poll_reg:\r\nif (ret_val == QLA_ERROR) {\r\nha->reset_tmplt.seq_error++;\r\nql4_printk(KERN_ERR, ha, "%s: Poll Failed: 0x%08x 0x%08x 0x%08x\n",\r\n__func__, value, test_mask, test_result);\r\n}\r\nreturn ret_val;\r\n}\r\nstatic int qla4_83xx_reset_seq_checksum_test(struct scsi_qla_host *ha)\r\n{\r\nuint32_t sum = 0;\r\nuint16_t *buff = (uint16_t *)ha->reset_tmplt.buff;\r\nint u16_count = ha->reset_tmplt.hdr->size / sizeof(uint16_t);\r\nint ret_val;\r\nwhile (u16_count-- > 0)\r\nsum += *buff++;\r\nwhile (sum >> 16)\r\nsum = (sum & 0xFFFF) + (sum >> 16);\r\nif (~sum) {\r\nret_val = QLA_SUCCESS;\r\n} else {\r\nql4_printk(KERN_ERR, ha, "%s: Reset seq checksum failed\n",\r\n__func__);\r\nret_val = QLA_ERROR;\r\n}\r\nreturn ret_val;\r\n}\r\nvoid qla4_83xx_read_reset_template(struct scsi_qla_host *ha)\r\n{\r\nuint8_t *p_buff;\r\nuint32_t addr, tmplt_hdr_def_size, tmplt_hdr_size;\r\nuint32_t ret_val;\r\nha->reset_tmplt.seq_error = 0;\r\nha->reset_tmplt.buff = vmalloc(QLA83XX_RESTART_TEMPLATE_SIZE);\r\nif (ha->reset_tmplt.buff == NULL) {\r\nql4_printk(KERN_ERR, ha, "%s: Failed to allocate reset template resources\n",\r\n__func__);\r\ngoto exit_read_reset_template;\r\n}\r\np_buff = ha->reset_tmplt.buff;\r\naddr = QLA83XX_RESET_TEMPLATE_ADDR;\r\ntmplt_hdr_def_size = sizeof(struct qla4_83xx_reset_template_hdr) /\r\nsizeof(uint32_t);\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: Read template hdr size %d from Flash\n",\r\n__func__, tmplt_hdr_def_size));\r\nret_val = qla4_83xx_flash_read_u32(ha, addr, p_buff,\r\ntmplt_hdr_def_size);\r\nif (ret_val != QLA_SUCCESS) {\r\nql4_printk(KERN_ERR, ha, "%s: Failed to read reset template\n",\r\n__func__);\r\ngoto exit_read_template_error;\r\n}\r\nha->reset_tmplt.hdr =\r\n(struct qla4_83xx_reset_template_hdr *)ha->reset_tmplt.buff;\r\ntmplt_hdr_size = ha->reset_tmplt.hdr->hdr_size/sizeof(uint32_t);\r\nif ((tmplt_hdr_size != tmplt_hdr_def_size) ||\r\n(ha->reset_tmplt.hdr->signature != RESET_TMPLT_HDR_SIGNATURE)) {\r\nql4_printk(KERN_ERR, ha, "%s: Template Header size %d is invalid, tmplt_hdr_def_size %d\n",\r\n__func__, tmplt_hdr_size, tmplt_hdr_def_size);\r\ngoto exit_read_template_error;\r\n}\r\naddr = QLA83XX_RESET_TEMPLATE_ADDR + ha->reset_tmplt.hdr->hdr_size;\r\np_buff = ha->reset_tmplt.buff + ha->reset_tmplt.hdr->hdr_size;\r\ntmplt_hdr_def_size = (ha->reset_tmplt.hdr->size -\r\nha->reset_tmplt.hdr->hdr_size) / sizeof(uint32_t);\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: Read rest of the template size %d\n",\r\n__func__, ha->reset_tmplt.hdr->size));\r\nret_val = qla4_83xx_flash_read_u32(ha, addr, p_buff,\r\ntmplt_hdr_def_size);\r\nif (ret_val != QLA_SUCCESS) {\r\nql4_printk(KERN_ERR, ha, "%s: Failed to read reset tempelate\n",\r\n__func__);\r\ngoto exit_read_template_error;\r\n}\r\nif (qla4_83xx_reset_seq_checksum_test(ha)) {\r\nql4_printk(KERN_ERR, ha, "%s: Reset Seq checksum failed!\n",\r\n__func__);\r\ngoto exit_read_template_error;\r\n}\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: Reset Seq checksum passed, Get stop, start and init seq offsets\n",\r\n__func__));\r\nha->reset_tmplt.init_offset = ha->reset_tmplt.buff +\r\nha->reset_tmplt.hdr->init_seq_offset;\r\nha->reset_tmplt.start_offset = ha->reset_tmplt.buff +\r\nha->reset_tmplt.hdr->start_seq_offset;\r\nha->reset_tmplt.stop_offset = ha->reset_tmplt.buff +\r\nha->reset_tmplt.hdr->hdr_size;\r\nqla4_83xx_dump_reset_seq_hdr(ha);\r\ngoto exit_read_reset_template;\r\nexit_read_template_error:\r\nvfree(ha->reset_tmplt.buff);\r\nexit_read_reset_template:\r\nreturn;\r\n}\r\nstatic void qla4_83xx_read_write_crb_reg(struct scsi_qla_host *ha,\r\nuint32_t raddr, uint32_t waddr)\r\n{\r\nuint32_t value;\r\nqla4_83xx_rd_reg_indirect(ha, raddr, &value);\r\nqla4_83xx_wr_reg_indirect(ha, waddr, value);\r\n}\r\nstatic void qla4_83xx_rmw_crb_reg(struct scsi_qla_host *ha, uint32_t raddr,\r\nuint32_t waddr,\r\nstruct qla4_83xx_rmw *p_rmw_hdr)\r\n{\r\nuint32_t value;\r\nif (p_rmw_hdr->index_a)\r\nvalue = ha->reset_tmplt.array[p_rmw_hdr->index_a];\r\nelse\r\nqla4_83xx_rd_reg_indirect(ha, raddr, &value);\r\nvalue &= p_rmw_hdr->test_mask;\r\nvalue <<= p_rmw_hdr->shl;\r\nvalue >>= p_rmw_hdr->shr;\r\nvalue |= p_rmw_hdr->or_value;\r\nvalue ^= p_rmw_hdr->xor_value;\r\nqla4_83xx_wr_reg_indirect(ha, waddr, value);\r\nreturn;\r\n}\r\nstatic void qla4_83xx_write_list(struct scsi_qla_host *ha,\r\nstruct qla4_83xx_reset_entry_hdr *p_hdr)\r\n{\r\nstruct qla4_83xx_entry *p_entry;\r\nuint32_t i;\r\np_entry = (struct qla4_83xx_entry *)\r\n((char *)p_hdr + sizeof(struct qla4_83xx_reset_entry_hdr));\r\nfor (i = 0; i < p_hdr->count; i++, p_entry++) {\r\nqla4_83xx_wr_reg_indirect(ha, p_entry->arg1, p_entry->arg2);\r\nif (p_hdr->delay)\r\nudelay((uint32_t)(p_hdr->delay));\r\n}\r\n}\r\nstatic void qla4_83xx_read_write_list(struct scsi_qla_host *ha,\r\nstruct qla4_83xx_reset_entry_hdr *p_hdr)\r\n{\r\nstruct qla4_83xx_entry *p_entry;\r\nuint32_t i;\r\np_entry = (struct qla4_83xx_entry *)\r\n((char *)p_hdr + sizeof(struct qla4_83xx_reset_entry_hdr));\r\nfor (i = 0; i < p_hdr->count; i++, p_entry++) {\r\nqla4_83xx_read_write_crb_reg(ha, p_entry->arg1, p_entry->arg2);\r\nif (p_hdr->delay)\r\nudelay((uint32_t)(p_hdr->delay));\r\n}\r\n}\r\nstatic void qla4_83xx_poll_list(struct scsi_qla_host *ha,\r\nstruct qla4_83xx_reset_entry_hdr *p_hdr)\r\n{\r\nlong delay;\r\nstruct qla4_83xx_entry *p_entry;\r\nstruct qla4_83xx_poll *p_poll;\r\nuint32_t i;\r\nuint32_t value;\r\np_poll = (struct qla4_83xx_poll *)\r\n((char *)p_hdr + sizeof(struct qla4_83xx_reset_entry_hdr));\r\np_entry = (struct qla4_83xx_entry *)((char *)p_poll +\r\nsizeof(struct qla4_83xx_poll));\r\ndelay = (long)p_hdr->delay;\r\nif (!delay) {\r\nfor (i = 0; i < p_hdr->count; i++, p_entry++) {\r\nqla4_83xx_poll_reg(ha, p_entry->arg1, delay,\r\np_poll->test_mask,\r\np_poll->test_value);\r\n}\r\n} else {\r\nfor (i = 0; i < p_hdr->count; i++, p_entry++) {\r\nif (qla4_83xx_poll_reg(ha, p_entry->arg1, delay,\r\np_poll->test_mask,\r\np_poll->test_value)) {\r\nqla4_83xx_rd_reg_indirect(ha, p_entry->arg1,\r\n&value);\r\nqla4_83xx_rd_reg_indirect(ha, p_entry->arg2,\r\n&value);\r\n}\r\n}\r\n}\r\n}\r\nstatic void qla4_83xx_poll_write_list(struct scsi_qla_host *ha,\r\nstruct qla4_83xx_reset_entry_hdr *p_hdr)\r\n{\r\nlong delay;\r\nstruct qla4_83xx_quad_entry *p_entry;\r\nstruct qla4_83xx_poll *p_poll;\r\nuint32_t i;\r\np_poll = (struct qla4_83xx_poll *)\r\n((char *)p_hdr + sizeof(struct qla4_83xx_reset_entry_hdr));\r\np_entry = (struct qla4_83xx_quad_entry *)\r\n((char *)p_poll + sizeof(struct qla4_83xx_poll));\r\ndelay = (long)p_hdr->delay;\r\nfor (i = 0; i < p_hdr->count; i++, p_entry++) {\r\nqla4_83xx_wr_reg_indirect(ha, p_entry->dr_addr,\r\np_entry->dr_value);\r\nqla4_83xx_wr_reg_indirect(ha, p_entry->ar_addr,\r\np_entry->ar_value);\r\nif (delay) {\r\nif (qla4_83xx_poll_reg(ha, p_entry->ar_addr, delay,\r\np_poll->test_mask,\r\np_poll->test_value)) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: Timeout Error: poll list, item_num %d, entry_num %d\n",\r\n__func__, i,\r\nha->reset_tmplt.seq_index));\r\n}\r\n}\r\n}\r\n}\r\nstatic void qla4_83xx_read_modify_write(struct scsi_qla_host *ha,\r\nstruct qla4_83xx_reset_entry_hdr *p_hdr)\r\n{\r\nstruct qla4_83xx_entry *p_entry;\r\nstruct qla4_83xx_rmw *p_rmw_hdr;\r\nuint32_t i;\r\np_rmw_hdr = (struct qla4_83xx_rmw *)\r\n((char *)p_hdr + sizeof(struct qla4_83xx_reset_entry_hdr));\r\np_entry = (struct qla4_83xx_entry *)\r\n((char *)p_rmw_hdr + sizeof(struct qla4_83xx_rmw));\r\nfor (i = 0; i < p_hdr->count; i++, p_entry++) {\r\nqla4_83xx_rmw_crb_reg(ha, p_entry->arg1, p_entry->arg2,\r\np_rmw_hdr);\r\nif (p_hdr->delay)\r\nudelay((uint32_t)(p_hdr->delay));\r\n}\r\n}\r\nstatic void qla4_83xx_pause(struct scsi_qla_host *ha,\r\nstruct qla4_83xx_reset_entry_hdr *p_hdr)\r\n{\r\nif (p_hdr->delay)\r\nmdelay((uint32_t)((long)p_hdr->delay));\r\n}\r\nstatic void qla4_83xx_poll_read_list(struct scsi_qla_host *ha,\r\nstruct qla4_83xx_reset_entry_hdr *p_hdr)\r\n{\r\nlong delay;\r\nint index;\r\nstruct qla4_83xx_quad_entry *p_entry;\r\nstruct qla4_83xx_poll *p_poll;\r\nuint32_t i;\r\nuint32_t value;\r\np_poll = (struct qla4_83xx_poll *)\r\n((char *)p_hdr + sizeof(struct qla4_83xx_reset_entry_hdr));\r\np_entry = (struct qla4_83xx_quad_entry *)\r\n((char *)p_poll + sizeof(struct qla4_83xx_poll));\r\ndelay = (long)p_hdr->delay;\r\nfor (i = 0; i < p_hdr->count; i++, p_entry++) {\r\nqla4_83xx_wr_reg_indirect(ha, p_entry->ar_addr,\r\np_entry->ar_value);\r\nif (delay) {\r\nif (qla4_83xx_poll_reg(ha, p_entry->ar_addr, delay,\r\np_poll->test_mask,\r\np_poll->test_value)) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: Timeout Error: poll list, Item_num %d, entry_num %d\n",\r\n__func__, i,\r\nha->reset_tmplt.seq_index));\r\n} else {\r\nindex = ha->reset_tmplt.array_index;\r\nqla4_83xx_rd_reg_indirect(ha, p_entry->dr_addr,\r\n&value);\r\nha->reset_tmplt.array[index++] = value;\r\nif (index == QLA83XX_MAX_RESET_SEQ_ENTRIES)\r\nha->reset_tmplt.array_index = 1;\r\n}\r\n}\r\n}\r\n}\r\nstatic void qla4_83xx_seq_end(struct scsi_qla_host *ha,\r\nstruct qla4_83xx_reset_entry_hdr *p_hdr)\r\n{\r\nha->reset_tmplt.seq_end = 1;\r\n}\r\nstatic void qla4_83xx_template_end(struct scsi_qla_host *ha,\r\nstruct qla4_83xx_reset_entry_hdr *p_hdr)\r\n{\r\nha->reset_tmplt.template_end = 1;\r\nif (ha->reset_tmplt.seq_error == 0) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: Reset sequence completed SUCCESSFULLY.\n",\r\n__func__));\r\n} else {\r\nql4_printk(KERN_ERR, ha, "%s: Reset sequence completed with some timeout errors.\n",\r\n__func__);\r\n}\r\n}\r\nstatic void qla4_83xx_process_reset_template(struct scsi_qla_host *ha,\r\nchar *p_buff)\r\n{\r\nint index, entries;\r\nstruct qla4_83xx_reset_entry_hdr *p_hdr;\r\nchar *p_entry = p_buff;\r\nha->reset_tmplt.seq_end = 0;\r\nha->reset_tmplt.template_end = 0;\r\nentries = ha->reset_tmplt.hdr->entries;\r\nindex = ha->reset_tmplt.seq_index;\r\nfor (; (!ha->reset_tmplt.seq_end) && (index < entries); index++) {\r\np_hdr = (struct qla4_83xx_reset_entry_hdr *)p_entry;\r\nswitch (p_hdr->cmd) {\r\ncase OPCODE_NOP:\r\nbreak;\r\ncase OPCODE_WRITE_LIST:\r\nqla4_83xx_write_list(ha, p_hdr);\r\nbreak;\r\ncase OPCODE_READ_WRITE_LIST:\r\nqla4_83xx_read_write_list(ha, p_hdr);\r\nbreak;\r\ncase OPCODE_POLL_LIST:\r\nqla4_83xx_poll_list(ha, p_hdr);\r\nbreak;\r\ncase OPCODE_POLL_WRITE_LIST:\r\nqla4_83xx_poll_write_list(ha, p_hdr);\r\nbreak;\r\ncase OPCODE_READ_MODIFY_WRITE:\r\nqla4_83xx_read_modify_write(ha, p_hdr);\r\nbreak;\r\ncase OPCODE_SEQ_PAUSE:\r\nqla4_83xx_pause(ha, p_hdr);\r\nbreak;\r\ncase OPCODE_SEQ_END:\r\nqla4_83xx_seq_end(ha, p_hdr);\r\nbreak;\r\ncase OPCODE_TMPL_END:\r\nqla4_83xx_template_end(ha, p_hdr);\r\nbreak;\r\ncase OPCODE_POLL_READ_LIST:\r\nqla4_83xx_poll_read_list(ha, p_hdr);\r\nbreak;\r\ndefault:\r\nql4_printk(KERN_ERR, ha, "%s: Unknown command ==> 0x%04x on entry = %d\n",\r\n__func__, p_hdr->cmd, index);\r\nbreak;\r\n}\r\np_entry += p_hdr->size;\r\n}\r\nha->reset_tmplt.seq_index = index;\r\n}\r\nstatic void qla4_83xx_process_stop_seq(struct scsi_qla_host *ha)\r\n{\r\nha->reset_tmplt.seq_index = 0;\r\nqla4_83xx_process_reset_template(ha, ha->reset_tmplt.stop_offset);\r\nif (ha->reset_tmplt.seq_end != 1)\r\nql4_printk(KERN_ERR, ha, "%s: Abrupt STOP Sub-Sequence end.\n",\r\n__func__);\r\n}\r\nstatic void qla4_83xx_process_start_seq(struct scsi_qla_host *ha)\r\n{\r\nqla4_83xx_process_reset_template(ha, ha->reset_tmplt.start_offset);\r\nif (ha->reset_tmplt.template_end != 1)\r\nql4_printk(KERN_ERR, ha, "%s: Abrupt START Sub-Sequence end.\n",\r\n__func__);\r\n}\r\nstatic void qla4_83xx_process_init_seq(struct scsi_qla_host *ha)\r\n{\r\nqla4_83xx_process_reset_template(ha, ha->reset_tmplt.init_offset);\r\nif (ha->reset_tmplt.seq_end != 1)\r\nql4_printk(KERN_ERR, ha, "%s: Abrupt INIT Sub-Sequence end.\n",\r\n__func__);\r\n}\r\nstatic int qla4_83xx_restart(struct scsi_qla_host *ha)\r\n{\r\nint ret_val = QLA_SUCCESS;\r\nuint32_t idc_ctrl;\r\nqla4_83xx_process_stop_seq(ha);\r\nidc_ctrl = qla4_83xx_rd_reg(ha, QLA83XX_IDC_DRV_CTRL);\r\nif (idc_ctrl & GRACEFUL_RESET_BIT1) {\r\nqla4_83xx_wr_reg(ha, QLA83XX_IDC_DRV_CTRL,\r\n(idc_ctrl & ~GRACEFUL_RESET_BIT1));\r\nql4_printk(KERN_INFO, ha, "%s: Graceful RESET: Not collecting minidump\n",\r\n__func__);\r\n} else {\r\nqla4_8xxx_get_minidump(ha);\r\n}\r\nqla4_83xx_process_init_seq(ha);\r\nif (qla4_83xx_copy_bootloader(ha)) {\r\nql4_printk(KERN_ERR, ha, "%s: Copy bootloader, firmware restart failed!\n",\r\n__func__);\r\nret_val = QLA_ERROR;\r\ngoto exit_restart;\r\n}\r\nqla4_83xx_wr_reg(ha, QLA83XX_FW_IMAGE_VALID, QLA83XX_BOOT_FROM_FLASH);\r\nqla4_83xx_process_start_seq(ha);\r\nexit_restart:\r\nreturn ret_val;\r\n}\r\nint qla4_83xx_start_firmware(struct scsi_qla_host *ha)\r\n{\r\nint ret_val = QLA_SUCCESS;\r\nret_val = qla4_83xx_restart(ha);\r\nif (ret_val == QLA_ERROR) {\r\nql4_printk(KERN_ERR, ha, "%s: Restart error\n", __func__);\r\ngoto exit_start_fw;\r\n} else {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: Restart done\n",\r\n__func__));\r\n}\r\nret_val = qla4_83xx_check_cmd_peg_status(ha);\r\nif (ret_val == QLA_ERROR)\r\nql4_printk(KERN_ERR, ha, "%s: Peg not initialized\n",\r\n__func__);\r\nexit_start_fw:\r\nreturn ret_val;\r\n}\r\nstatic void qla4_83xx_disable_iocb_intrs(struct scsi_qla_host *ha)\r\n{\r\nif (test_and_clear_bit(AF_83XX_IOCB_INTR_ON, &ha->flags))\r\nqla4_8xxx_intr_disable(ha);\r\n}\r\nstatic void qla4_83xx_disable_mbox_intrs(struct scsi_qla_host *ha)\r\n{\r\nuint32_t mb_int, ret;\r\nif (test_and_clear_bit(AF_83XX_MBOX_INTR_ON, &ha->flags)) {\r\nret = readl(&ha->qla4_83xx_reg->mbox_int);\r\nmb_int = ret & ~INT_ENABLE_FW_MB;\r\nwritel(mb_int, &ha->qla4_83xx_reg->mbox_int);\r\nwritel(1, &ha->qla4_83xx_reg->leg_int_mask);\r\n}\r\n}\r\nvoid qla4_83xx_disable_intrs(struct scsi_qla_host *ha)\r\n{\r\nqla4_83xx_disable_mbox_intrs(ha);\r\nqla4_83xx_disable_iocb_intrs(ha);\r\n}\r\nstatic void qla4_83xx_enable_iocb_intrs(struct scsi_qla_host *ha)\r\n{\r\nif (!test_bit(AF_83XX_IOCB_INTR_ON, &ha->flags)) {\r\nqla4_8xxx_intr_enable(ha);\r\nset_bit(AF_83XX_IOCB_INTR_ON, &ha->flags);\r\n}\r\n}\r\nvoid qla4_83xx_enable_mbox_intrs(struct scsi_qla_host *ha)\r\n{\r\nuint32_t mb_int;\r\nif (!test_bit(AF_83XX_MBOX_INTR_ON, &ha->flags)) {\r\nmb_int = INT_ENABLE_FW_MB;\r\nwritel(mb_int, &ha->qla4_83xx_reg->mbox_int);\r\nwritel(0, &ha->qla4_83xx_reg->leg_int_mask);\r\nset_bit(AF_83XX_MBOX_INTR_ON, &ha->flags);\r\n}\r\n}\r\nvoid qla4_83xx_enable_intrs(struct scsi_qla_host *ha)\r\n{\r\nqla4_83xx_enable_mbox_intrs(ha);\r\nqla4_83xx_enable_iocb_intrs(ha);\r\n}\r\nvoid qla4_83xx_queue_mbox_cmd(struct scsi_qla_host *ha, uint32_t *mbx_cmd,\r\nint incount)\r\n{\r\nint i;\r\nfor (i = 1; i < incount; i++)\r\nwritel(mbx_cmd[i], &ha->qla4_83xx_reg->mailbox_in[i]);\r\nwritel(mbx_cmd[0], &ha->qla4_83xx_reg->mailbox_in[0]);\r\nwritel(HINT_MBX_INT_PENDING, &ha->qla4_83xx_reg->host_intr);\r\n}\r\nvoid qla4_83xx_process_mbox_intr(struct scsi_qla_host *ha, int outcount)\r\n{\r\nint intr_status;\r\nintr_status = readl(&ha->qla4_83xx_reg->risc_intr);\r\nif (intr_status) {\r\nha->mbox_status_count = outcount;\r\nha->isp_ops->interrupt_service_routine(ha, intr_status);\r\n}\r\n}\r\nint qla4_83xx_isp_reset(struct scsi_qla_host *ha)\r\n{\r\nint rval;\r\nuint32_t dev_state;\r\nha->isp_ops->idc_lock(ha);\r\ndev_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DEV_STATE);\r\nif (ql4xdontresethba)\r\nqla4_83xx_set_idc_dontreset(ha);\r\nif (dev_state == QLA8XXX_DEV_READY) {\r\nif (qla4_83xx_idc_dontreset(ha) == DONTRESET_BIT0) {\r\nql4_printk(KERN_ERR, ha, "%s: Reset recovery disabled\n",\r\n__func__);\r\nrval = QLA_ERROR;\r\ngoto exit_isp_reset;\r\n}\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: HW State: NEED RESET\n",\r\n__func__));\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\r\nQLA8XXX_DEV_NEED_RESET);\r\n} else {\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"%s: HW state already set to NEED_RESET\n",\r\n__func__));\r\n}\r\nif (qla4_83xx_can_perform_reset(ha))\r\nset_bit(AF_8XXX_RST_OWNER, &ha->flags);\r\nha->isp_ops->idc_unlock(ha);\r\nrval = qla4_8xxx_device_state_handler(ha);\r\nha->isp_ops->idc_lock(ha);\r\nqla4_8xxx_clear_rst_ready(ha);\r\nexit_isp_reset:\r\nha->isp_ops->idc_unlock(ha);\r\nif (rval == QLA_SUCCESS)\r\nclear_bit(AF_FW_RECOVERY, &ha->flags);\r\nreturn rval;\r\n}\r\nstatic void qla4_83xx_dump_pause_control_regs(struct scsi_qla_host *ha)\r\n{\r\nu32 val = 0, val1 = 0;\r\nint i, status = QLA_SUCCESS;\r\nstatus = qla4_83xx_rd_reg_indirect(ha, QLA83XX_SRE_SHIM_CONTROL, &val);\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "SRE-Shim Ctrl:0x%x\n", val));\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Port 0 Rx Buffer Pause Threshold Registers[TC7..TC0]:"));\r\nfor (i = 0; i < 8; i++) {\r\nstatus = qla4_83xx_rd_reg_indirect(ha,\r\nQLA83XX_PORT0_RXB_PAUSE_THRS + (i * 0x4), &val);\r\nDEBUG2(pr_info("0x%x ", val));\r\n}\r\nDEBUG2(pr_info("\n"));\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Port 1 Rx Buffer Pause Threshold Registers[TC7..TC0]:"));\r\nfor (i = 0; i < 8; i++) {\r\nstatus = qla4_83xx_rd_reg_indirect(ha,\r\nQLA83XX_PORT1_RXB_PAUSE_THRS + (i * 0x4), &val);\r\nDEBUG2(pr_info("0x%x ", val));\r\n}\r\nDEBUG2(pr_info("\n"));\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Port 0 RxB Traffic Class Max Cell Registers[3..0]:"));\r\nfor (i = 0; i < 4; i++) {\r\nstatus = qla4_83xx_rd_reg_indirect(ha,\r\nQLA83XX_PORT0_RXB_TC_MAX_CELL + (i * 0x4), &val);\r\nDEBUG2(pr_info("0x%x ", val));\r\n}\r\nDEBUG2(pr_info("\n"));\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Port 1 RxB Traffic Class Max Cell Registers[3..0]:"));\r\nfor (i = 0; i < 4; i++) {\r\nstatus = qla4_83xx_rd_reg_indirect(ha,\r\nQLA83XX_PORT1_RXB_TC_MAX_CELL + (i * 0x4), &val);\r\nDEBUG2(pr_info("0x%x ", val));\r\n}\r\nDEBUG2(pr_info("\n"));\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Port 0 RxB Rx Traffic Class Stats [TC7..TC0]"));\r\nfor (i = 7; i >= 0; i--) {\r\nstatus = qla4_83xx_rd_reg_indirect(ha,\r\nQLA83XX_PORT0_RXB_TC_STATS,\r\n&val);\r\nval &= ~(0x7 << 29);\r\nqla4_83xx_wr_reg_indirect(ha, QLA83XX_PORT0_RXB_TC_STATS,\r\n(val | (i << 29)));\r\nstatus = qla4_83xx_rd_reg_indirect(ha,\r\nQLA83XX_PORT0_RXB_TC_STATS,\r\n&val);\r\nDEBUG2(pr_info("0x%x ", val));\r\n}\r\nDEBUG2(pr_info("\n"));\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Port 1 RxB Rx Traffic Class Stats [TC7..TC0]"));\r\nfor (i = 7; i >= 0; i--) {\r\nstatus = qla4_83xx_rd_reg_indirect(ha,\r\nQLA83XX_PORT1_RXB_TC_STATS,\r\n&val);\r\nval &= ~(0x7 << 29);\r\nqla4_83xx_wr_reg_indirect(ha, QLA83XX_PORT1_RXB_TC_STATS,\r\n(val | (i << 29)));\r\nstatus = qla4_83xx_rd_reg_indirect(ha,\r\nQLA83XX_PORT1_RXB_TC_STATS,\r\n&val);\r\nDEBUG2(pr_info("0x%x ", val));\r\n}\r\nDEBUG2(pr_info("\n"));\r\nstatus = qla4_83xx_rd_reg_indirect(ha, QLA83XX_PORT2_IFB_PAUSE_THRS,\r\n&val);\r\nstatus = qla4_83xx_rd_reg_indirect(ha, QLA83XX_PORT3_IFB_PAUSE_THRS,\r\n&val1);\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"IFB-Pause Thresholds: Port 2:0x%x, Port 3:0x%x\n",\r\nval, val1));\r\n}\r\nstatic void __qla4_83xx_disable_pause(struct scsi_qla_host *ha)\r\n{\r\nint i;\r\nqla4_83xx_wr_reg_indirect(ha, QLA83XX_SRE_SHIM_CONTROL,\r\nQLA83XX_SET_PAUSE_VAL);\r\nfor (i = 0; i < 8; i++) {\r\nqla4_83xx_wr_reg_indirect(ha,\r\nQLA83XX_PORT0_RXB_PAUSE_THRS + (i * 0x4),\r\nQLA83XX_SET_PAUSE_VAL);\r\nqla4_83xx_wr_reg_indirect(ha,\r\nQLA83XX_PORT1_RXB_PAUSE_THRS + (i * 0x4),\r\nQLA83XX_SET_PAUSE_VAL);\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nqla4_83xx_wr_reg_indirect(ha,\r\nQLA83XX_PORT0_RXB_TC_MAX_CELL + (i * 0x4),\r\nQLA83XX_SET_TC_MAX_CELL_VAL);\r\nqla4_83xx_wr_reg_indirect(ha,\r\nQLA83XX_PORT1_RXB_TC_MAX_CELL + (i * 0x4),\r\nQLA83XX_SET_TC_MAX_CELL_VAL);\r\n}\r\nqla4_83xx_wr_reg_indirect(ha, QLA83XX_PORT2_IFB_PAUSE_THRS,\r\nQLA83XX_SET_PAUSE_VAL);\r\nqla4_83xx_wr_reg_indirect(ha, QLA83XX_PORT3_IFB_PAUSE_THRS,\r\nQLA83XX_SET_PAUSE_VAL);\r\nql4_printk(KERN_INFO, ha, "Disabled pause frames successfully.\n");\r\n}\r\nstatic void qla4_83xx_eport_init(struct scsi_qla_host *ha)\r\n{\r\nqla4_83xx_wr_reg_indirect(ha, QLA83XX_RESET_REG, 0x0);\r\nqla4_83xx_wr_reg_indirect(ha, QLA83XX_RESET_PORT0, 0x0);\r\nqla4_83xx_wr_reg_indirect(ha, QLA83XX_RESET_PORT1, 0x0);\r\nqla4_83xx_wr_reg_indirect(ha, QLA83XX_RESET_PORT2, 0x0);\r\nqla4_83xx_wr_reg_indirect(ha, QLA83XX_RESET_PORT3, 0x0);\r\nqla4_83xx_wr_reg_indirect(ha, QLA83XX_RESET_SRE_SHIM, 0x0);\r\nqla4_83xx_wr_reg_indirect(ha, QLA83XX_RESET_EPG_SHIM, 0x0);\r\nqla4_83xx_wr_reg_indirect(ha, QLA83XX_RESET_ETHER_PCS, 0x0);\r\nqla4_83xx_wr_reg_indirect(ha, QLA83XX_RESET_CONTROL, 0xFF);\r\nql4_printk(KERN_INFO, ha, "EPORT is out of reset.\n");\r\n}\r\nvoid qla4_83xx_disable_pause(struct scsi_qla_host *ha)\r\n{\r\nha->isp_ops->idc_lock(ha);\r\nqla4_83xx_eport_init(ha);\r\nqla4_83xx_dump_pause_control_regs(ha);\r\n__qla4_83xx_disable_pause(ha);\r\nha->isp_ops->idc_unlock(ha);\r\n}\r\nint qla4_83xx_is_detached(struct scsi_qla_host *ha)\r\n{\r\nuint32_t drv_active;\r\ndrv_active = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_ACTIVE);\r\nif (test_bit(AF_INIT_DONE, &ha->flags) &&\r\n!(drv_active & (1 << ha->func_num))) {\r\nDEBUG2(ql4_printk(KERN_INFO, ha, "%s: drv_active = 0x%X\n",\r\n__func__, drv_active));\r\nreturn QLA_SUCCESS;\r\n}\r\nreturn QLA_ERROR;\r\n}
