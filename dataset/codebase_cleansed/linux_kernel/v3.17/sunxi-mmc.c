static int sunxi_mmc_reset_host(struct sunxi_mmc_host *host)\r\n{\r\nunsigned long expire = jiffies + msecs_to_jiffies(250);\r\nu32 rval;\r\nmmc_writel(host, REG_CMDR, SDXC_HARDWARE_RESET);\r\ndo {\r\nrval = mmc_readl(host, REG_GCTRL);\r\n} while (time_before(jiffies, expire) && (rval & SDXC_HARDWARE_RESET));\r\nif (rval & SDXC_HARDWARE_RESET) {\r\ndev_err(mmc_dev(host->mmc), "fatal err reset timeout\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sunxi_mmc_init_host(struct mmc_host *mmc)\r\n{\r\nu32 rval;\r\nstruct sunxi_mmc_host *host = mmc_priv(mmc);\r\nif (sunxi_mmc_reset_host(host))\r\nreturn -EIO;\r\nmmc_writel(host, REG_FTRGL, 0x20070008);\r\nmmc_writel(host, REG_TMOUT, 0xffffffff);\r\nmmc_writel(host, REG_IMASK, host->sdio_imask);\r\nmmc_writel(host, REG_RINTR, 0xffffffff);\r\nmmc_writel(host, REG_DBGC, 0xdeb);\r\nmmc_writel(host, REG_FUNS, SDXC_CEATA_ON);\r\nmmc_writel(host, REG_DLBA, host->sg_dma);\r\nrval = mmc_readl(host, REG_GCTRL);\r\nrval |= SDXC_INTERRUPT_ENABLE_BIT;\r\nrval &= ~SDXC_ACCESS_DONE_DIRECT;\r\nmmc_writel(host, REG_GCTRL, rval);\r\nreturn 0;\r\n}\r\nstatic void sunxi_mmc_init_idma_des(struct sunxi_mmc_host *host,\r\nstruct mmc_data *data)\r\n{\r\nstruct sunxi_idma_des *pdes = (struct sunxi_idma_des *)host->sg_cpu;\r\nstruct sunxi_idma_des *pdes_pa = (struct sunxi_idma_des *)host->sg_dma;\r\nint i, max_len = (1 << host->idma_des_size_bits);\r\nfor (i = 0; i < data->sg_len; i++) {\r\npdes[i].config = SDXC_IDMAC_DES0_CH | SDXC_IDMAC_DES0_OWN |\r\nSDXC_IDMAC_DES0_DIC;\r\nif (data->sg[i].length == max_len)\r\npdes[i].buf_size = 0;\r\nelse\r\npdes[i].buf_size = data->sg[i].length;\r\npdes[i].buf_addr_ptr1 = sg_dma_address(&data->sg[i]);\r\npdes[i].buf_addr_ptr2 = (u32)&pdes_pa[i + 1];\r\n}\r\npdes[0].config |= SDXC_IDMAC_DES0_FD;\r\npdes[i - 1].config = SDXC_IDMAC_DES0_OWN | SDXC_IDMAC_DES0_LD;\r\nwmb();\r\n}\r\nstatic enum dma_data_direction sunxi_mmc_get_dma_dir(struct mmc_data *data)\r\n{\r\nif (data->flags & MMC_DATA_WRITE)\r\nreturn DMA_TO_DEVICE;\r\nelse\r\nreturn DMA_FROM_DEVICE;\r\n}\r\nstatic int sunxi_mmc_map_dma(struct sunxi_mmc_host *host,\r\nstruct mmc_data *data)\r\n{\r\nu32 i, dma_len;\r\nstruct scatterlist *sg;\r\ndma_len = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,\r\nsunxi_mmc_get_dma_dir(data));\r\nif (dma_len == 0) {\r\ndev_err(mmc_dev(host->mmc), "dma_map_sg failed\n");\r\nreturn -ENOMEM;\r\n}\r\nfor_each_sg(data->sg, sg, data->sg_len, i) {\r\nif (sg->offset & 3 || sg->length & 3) {\r\ndev_err(mmc_dev(host->mmc),\r\n"unaligned scatterlist: os %x length %d\n",\r\nsg->offset, sg->length);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void sunxi_mmc_start_dma(struct sunxi_mmc_host *host,\r\nstruct mmc_data *data)\r\n{\r\nu32 rval;\r\nsunxi_mmc_init_idma_des(host, data);\r\nrval = mmc_readl(host, REG_GCTRL);\r\nrval |= SDXC_DMA_ENABLE_BIT;\r\nmmc_writel(host, REG_GCTRL, rval);\r\nrval |= SDXC_DMA_RESET;\r\nmmc_writel(host, REG_GCTRL, rval);\r\nmmc_writel(host, REG_DMAC, SDXC_IDMAC_SOFT_RESET);\r\nif (!(data->flags & MMC_DATA_WRITE))\r\nmmc_writel(host, REG_IDIE, SDXC_IDMAC_RECEIVE_INTERRUPT);\r\nmmc_writel(host, REG_DMAC,\r\nSDXC_IDMAC_FIX_BURST | SDXC_IDMAC_IDMA_ON);\r\n}\r\nstatic void sunxi_mmc_send_manual_stop(struct sunxi_mmc_host *host,\r\nstruct mmc_request *req)\r\n{\r\nu32 arg, cmd_val, ri;\r\nunsigned long expire = jiffies + msecs_to_jiffies(1000);\r\ncmd_val = SDXC_START | SDXC_RESP_EXPIRE |\r\nSDXC_STOP_ABORT_CMD | SDXC_CHECK_RESPONSE_CRC;\r\nif (req->cmd->opcode == SD_IO_RW_EXTENDED) {\r\ncmd_val |= SD_IO_RW_DIRECT;\r\narg = (1 << 31) | (0 << 28) | (SDIO_CCCR_ABORT << 9) |\r\n((req->cmd->arg >> 28) & 0x7);\r\n} else {\r\ncmd_val |= MMC_STOP_TRANSMISSION;\r\narg = 0;\r\n}\r\nmmc_writel(host, REG_CARG, arg);\r\nmmc_writel(host, REG_CMDR, cmd_val);\r\ndo {\r\nri = mmc_readl(host, REG_RINTR);\r\n} while (!(ri & (SDXC_COMMAND_DONE | SDXC_INTERRUPT_ERROR_BIT)) &&\r\ntime_before(jiffies, expire));\r\nif (!(ri & SDXC_COMMAND_DONE) || (ri & SDXC_INTERRUPT_ERROR_BIT)) {\r\ndev_err(mmc_dev(host->mmc), "send stop command failed\n");\r\nif (req->stop)\r\nreq->stop->resp[0] = -ETIMEDOUT;\r\n} else {\r\nif (req->stop)\r\nreq->stop->resp[0] = mmc_readl(host, REG_RESP0);\r\n}\r\nmmc_writel(host, REG_RINTR, 0xffff);\r\n}\r\nstatic void sunxi_mmc_dump_errinfo(struct sunxi_mmc_host *host)\r\n{\r\nstruct mmc_command *cmd = host->mrq->cmd;\r\nstruct mmc_data *data = host->mrq->data;\r\nif ((host->int_sum & SDXC_INTERRUPT_ERROR_BIT) ==\r\nSDXC_RESP_TIMEOUT && (cmd->opcode == SD_IO_SEND_OP_COND ||\r\ncmd->opcode == SD_IO_RW_DIRECT))\r\nreturn;\r\ndev_err(mmc_dev(host->mmc),\r\n"smc %d err, cmd %d,%s%s%s%s%s%s%s%s%s%s !!\n",\r\nhost->mmc->index, cmd->opcode,\r\ndata ? (data->flags & MMC_DATA_WRITE ? " WR" : " RD") : "",\r\nhost->int_sum & SDXC_RESP_ERROR ? " RE" : "",\r\nhost->int_sum & SDXC_RESP_CRC_ERROR ? " RCE" : "",\r\nhost->int_sum & SDXC_DATA_CRC_ERROR ? " DCE" : "",\r\nhost->int_sum & SDXC_RESP_TIMEOUT ? " RTO" : "",\r\nhost->int_sum & SDXC_DATA_TIMEOUT ? " DTO" : "",\r\nhost->int_sum & SDXC_FIFO_RUN_ERROR ? " FE" : "",\r\nhost->int_sum & SDXC_HARD_WARE_LOCKED ? " HL" : "",\r\nhost->int_sum & SDXC_START_BIT_ERROR ? " SBE" : "",\r\nhost->int_sum & SDXC_END_BIT_ERROR ? " EBE" : ""\r\n);\r\n}\r\nstatic irqreturn_t sunxi_mmc_finalize_request(struct sunxi_mmc_host *host)\r\n{\r\nstruct mmc_request *mrq = host->mrq;\r\nstruct mmc_data *data = mrq->data;\r\nu32 rval;\r\nmmc_writel(host, REG_IMASK, host->sdio_imask);\r\nmmc_writel(host, REG_IDIE, 0);\r\nif (host->int_sum & SDXC_INTERRUPT_ERROR_BIT) {\r\nsunxi_mmc_dump_errinfo(host);\r\nmrq->cmd->error = -ETIMEDOUT;\r\nif (data) {\r\ndata->error = -ETIMEDOUT;\r\nhost->manual_stop_mrq = mrq;\r\n}\r\nif (mrq->stop)\r\nmrq->stop->error = -ETIMEDOUT;\r\n} else {\r\nif (mrq->cmd->flags & MMC_RSP_136) {\r\nmrq->cmd->resp[0] = mmc_readl(host, REG_RESP3);\r\nmrq->cmd->resp[1] = mmc_readl(host, REG_RESP2);\r\nmrq->cmd->resp[2] = mmc_readl(host, REG_RESP1);\r\nmrq->cmd->resp[3] = mmc_readl(host, REG_RESP0);\r\n} else {\r\nmrq->cmd->resp[0] = mmc_readl(host, REG_RESP0);\r\n}\r\nif (data)\r\ndata->bytes_xfered = data->blocks * data->blksz;\r\n}\r\nif (data) {\r\nmmc_writel(host, REG_IDST, 0x337);\r\nmmc_writel(host, REG_DMAC, 0);\r\nrval = mmc_readl(host, REG_GCTRL);\r\nrval |= SDXC_DMA_RESET;\r\nmmc_writel(host, REG_GCTRL, rval);\r\nrval &= ~SDXC_DMA_ENABLE_BIT;\r\nmmc_writel(host, REG_GCTRL, rval);\r\nrval |= SDXC_FIFO_RESET;\r\nmmc_writel(host, REG_GCTRL, rval);\r\ndma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,\r\nsunxi_mmc_get_dma_dir(data));\r\n}\r\nmmc_writel(host, REG_RINTR, 0xffff);\r\nhost->mrq = NULL;\r\nhost->int_sum = 0;\r\nhost->wait_dma = false;\r\nreturn host->manual_stop_mrq ? IRQ_WAKE_THREAD : IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t sunxi_mmc_irq(int irq, void *dev_id)\r\n{\r\nstruct sunxi_mmc_host *host = dev_id;\r\nstruct mmc_request *mrq;\r\nu32 msk_int, idma_int;\r\nbool finalize = false;\r\nbool sdio_int = false;\r\nirqreturn_t ret = IRQ_HANDLED;\r\nspin_lock(&host->lock);\r\nidma_int = mmc_readl(host, REG_IDST);\r\nmsk_int = mmc_readl(host, REG_MISTA);\r\ndev_dbg(mmc_dev(host->mmc), "irq: rq %p mi %08x idi %08x\n",\r\nhost->mrq, msk_int, idma_int);\r\nmrq = host->mrq;\r\nif (mrq) {\r\nif (idma_int & SDXC_IDMAC_RECEIVE_INTERRUPT)\r\nhost->wait_dma = false;\r\nhost->int_sum |= msk_int;\r\nif ((host->int_sum & SDXC_RESP_TIMEOUT) &&\r\n!(host->int_sum & SDXC_COMMAND_DONE))\r\nmmc_writel(host, REG_IMASK,\r\nhost->sdio_imask | SDXC_COMMAND_DONE);\r\nelse if (host->int_sum & SDXC_INTERRUPT_ERROR_BIT)\r\nfinalize = true;\r\nelse if ((host->int_sum & SDXC_INTERRUPT_DONE_BIT) &&\r\n!host->wait_dma)\r\nfinalize = true;\r\n}\r\nif (msk_int & SDXC_SDIO_INTERRUPT)\r\nsdio_int = true;\r\nmmc_writel(host, REG_RINTR, msk_int);\r\nmmc_writel(host, REG_IDST, idma_int);\r\nif (finalize)\r\nret = sunxi_mmc_finalize_request(host);\r\nspin_unlock(&host->lock);\r\nif (finalize && ret == IRQ_HANDLED)\r\nmmc_request_done(host->mmc, mrq);\r\nif (sdio_int)\r\nmmc_signal_sdio_irq(host->mmc);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t sunxi_mmc_handle_manual_stop(int irq, void *dev_id)\r\n{\r\nstruct sunxi_mmc_host *host = dev_id;\r\nstruct mmc_request *mrq;\r\nunsigned long iflags;\r\nspin_lock_irqsave(&host->lock, iflags);\r\nmrq = host->manual_stop_mrq;\r\nspin_unlock_irqrestore(&host->lock, iflags);\r\nif (!mrq) {\r\ndev_err(mmc_dev(host->mmc), "no request for manual stop\n");\r\nreturn IRQ_HANDLED;\r\n}\r\ndev_err(mmc_dev(host->mmc), "data error, sending stop command\n");\r\nsunxi_mmc_send_manual_stop(host, mrq);\r\nspin_lock_irqsave(&host->lock, iflags);\r\nhost->manual_stop_mrq = NULL;\r\nspin_unlock_irqrestore(&host->lock, iflags);\r\nmmc_request_done(host->mmc, mrq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sunxi_mmc_oclk_onoff(struct sunxi_mmc_host *host, u32 oclk_en)\r\n{\r\nunsigned long expire = jiffies + msecs_to_jiffies(250);\r\nu32 rval;\r\nrval = mmc_readl(host, REG_CLKCR);\r\nrval &= ~(SDXC_CARD_CLOCK_ON | SDXC_LOW_POWER_ON);\r\nif (oclk_en)\r\nrval |= SDXC_CARD_CLOCK_ON;\r\nmmc_writel(host, REG_CLKCR, rval);\r\nrval = SDXC_START | SDXC_UPCLK_ONLY | SDXC_WAIT_PRE_OVER;\r\nmmc_writel(host, REG_CMDR, rval);\r\ndo {\r\nrval = mmc_readl(host, REG_CMDR);\r\n} while (time_before(jiffies, expire) && (rval & SDXC_START));\r\nmmc_writel(host, REG_RINTR,\r\nmmc_readl(host, REG_RINTR) & ~SDXC_SDIO_INTERRUPT);\r\nif (rval & SDXC_START) {\r\ndev_err(mmc_dev(host->mmc), "fatal err update clk timeout\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sunxi_mmc_clk_set_rate(struct sunxi_mmc_host *host,\r\nstruct mmc_ios *ios)\r\n{\r\nu32 rate, oclk_dly, rval, sclk_dly, src_clk;\r\nint ret;\r\nrate = clk_round_rate(host->clk_mmc, ios->clock);\r\ndev_dbg(mmc_dev(host->mmc), "setting clk to %d, rounded %d\n",\r\nios->clock, rate);\r\nret = clk_set_rate(host->clk_mmc, rate);\r\nif (ret) {\r\ndev_err(mmc_dev(host->mmc), "error setting clk to %d: %d\n",\r\nrate, ret);\r\nreturn ret;\r\n}\r\nret = sunxi_mmc_oclk_onoff(host, 0);\r\nif (ret)\r\nreturn ret;\r\nrval = mmc_readl(host, REG_CLKCR);\r\nrval &= ~0xff;\r\nmmc_writel(host, REG_CLKCR, rval);\r\nif (rate <= 400000) {\r\noclk_dly = 0;\r\nsclk_dly = 7;\r\n} else if (rate <= 25000000) {\r\noclk_dly = 0;\r\nsclk_dly = 5;\r\n} else if (rate <= 50000000) {\r\nif (ios->timing == MMC_TIMING_UHS_DDR50) {\r\noclk_dly = 2;\r\nsclk_dly = 4;\r\n} else {\r\noclk_dly = 3;\r\nsclk_dly = 5;\r\n}\r\n} else {\r\noclk_dly = 2;\r\nsclk_dly = 4;\r\n}\r\nsrc_clk = clk_get_rate(clk_get_parent(host->clk_mmc));\r\nif (src_clk >= 300000000 && src_clk <= 400000000) {\r\nif (oclk_dly)\r\noclk_dly--;\r\nif (sclk_dly)\r\nsclk_dly--;\r\n}\r\nclk_sunxi_mmc_phase_control(host->clk_mmc, sclk_dly, oclk_dly);\r\nreturn sunxi_mmc_oclk_onoff(host, 1);\r\n}\r\nstatic void sunxi_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct sunxi_mmc_host *host = mmc_priv(mmc);\r\nu32 rval;\r\nswitch (ios->power_mode) {\r\ncase MMC_POWER_ON:\r\nbreak;\r\ncase MMC_POWER_UP:\r\nmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, ios->vdd);\r\nhost->ferror = sunxi_mmc_init_host(mmc);\r\nif (host->ferror)\r\nreturn;\r\ndev_dbg(mmc_dev(mmc), "power on!\n");\r\nbreak;\r\ncase MMC_POWER_OFF:\r\ndev_dbg(mmc_dev(mmc), "power off!\n");\r\nsunxi_mmc_reset_host(host);\r\nmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);\r\nbreak;\r\n}\r\nswitch (ios->bus_width) {\r\ncase MMC_BUS_WIDTH_1:\r\nmmc_writel(host, REG_WIDTH, SDXC_WIDTH1);\r\nbreak;\r\ncase MMC_BUS_WIDTH_4:\r\nmmc_writel(host, REG_WIDTH, SDXC_WIDTH4);\r\nbreak;\r\ncase MMC_BUS_WIDTH_8:\r\nmmc_writel(host, REG_WIDTH, SDXC_WIDTH8);\r\nbreak;\r\n}\r\nrval = mmc_readl(host, REG_GCTRL);\r\nif (ios->timing == MMC_TIMING_UHS_DDR50)\r\nrval |= SDXC_DDR_MODE;\r\nelse\r\nrval &= ~SDXC_DDR_MODE;\r\nmmc_writel(host, REG_GCTRL, rval);\r\nif (ios->clock && ios->power_mode) {\r\nhost->ferror = sunxi_mmc_clk_set_rate(host, ios);\r\n}\r\n}\r\nstatic void sunxi_mmc_enable_sdio_irq(struct mmc_host *mmc, int enable)\r\n{\r\nstruct sunxi_mmc_host *host = mmc_priv(mmc);\r\nunsigned long flags;\r\nu32 imask;\r\nspin_lock_irqsave(&host->lock, flags);\r\nimask = mmc_readl(host, REG_IMASK);\r\nif (enable) {\r\nhost->sdio_imask = SDXC_SDIO_INTERRUPT;\r\nimask |= SDXC_SDIO_INTERRUPT;\r\n} else {\r\nhost->sdio_imask = 0;\r\nimask &= ~SDXC_SDIO_INTERRUPT;\r\n}\r\nmmc_writel(host, REG_IMASK, imask);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic void sunxi_mmc_hw_reset(struct mmc_host *mmc)\r\n{\r\nstruct sunxi_mmc_host *host = mmc_priv(mmc);\r\nmmc_writel(host, REG_HWRST, 0);\r\nudelay(10);\r\nmmc_writel(host, REG_HWRST, 1);\r\nudelay(300);\r\n}\r\nstatic void sunxi_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)\r\n{\r\nstruct sunxi_mmc_host *host = mmc_priv(mmc);\r\nstruct mmc_command *cmd = mrq->cmd;\r\nstruct mmc_data *data = mrq->data;\r\nunsigned long iflags;\r\nu32 imask = SDXC_INTERRUPT_ERROR_BIT;\r\nu32 cmd_val = SDXC_START | (cmd->opcode & 0x3f);\r\nint ret;\r\nif (host->ferror) {\r\nmrq->cmd->error = host->ferror;\r\nmmc_request_done(mmc, mrq);\r\nreturn;\r\n}\r\nif (data) {\r\nret = sunxi_mmc_map_dma(host, data);\r\nif (ret < 0) {\r\ndev_err(mmc_dev(mmc), "map DMA failed\n");\r\ncmd->error = ret;\r\ndata->error = ret;\r\nmmc_request_done(mmc, mrq);\r\nreturn;\r\n}\r\n}\r\nif (cmd->opcode == MMC_GO_IDLE_STATE) {\r\ncmd_val |= SDXC_SEND_INIT_SEQUENCE;\r\nimask |= SDXC_COMMAND_DONE;\r\n}\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\ncmd_val |= SDXC_RESP_EXPIRE;\r\nif (cmd->flags & MMC_RSP_136)\r\ncmd_val |= SDXC_LONG_RESPONSE;\r\nif (cmd->flags & MMC_RSP_CRC)\r\ncmd_val |= SDXC_CHECK_RESPONSE_CRC;\r\nif ((cmd->flags & MMC_CMD_MASK) == MMC_CMD_ADTC) {\r\ncmd_val |= SDXC_DATA_EXPIRE | SDXC_WAIT_PRE_OVER;\r\nif (cmd->data->flags & MMC_DATA_STREAM) {\r\nimask |= SDXC_AUTO_COMMAND_DONE;\r\ncmd_val |= SDXC_SEQUENCE_MODE |\r\nSDXC_SEND_AUTO_STOP;\r\n}\r\nif (cmd->data->stop) {\r\nimask |= SDXC_AUTO_COMMAND_DONE;\r\ncmd_val |= SDXC_SEND_AUTO_STOP;\r\n} else {\r\nimask |= SDXC_DATA_OVER;\r\n}\r\nif (cmd->data->flags & MMC_DATA_WRITE)\r\ncmd_val |= SDXC_WRITE;\r\nelse\r\nhost->wait_dma = true;\r\n} else {\r\nimask |= SDXC_COMMAND_DONE;\r\n}\r\n} else {\r\nimask |= SDXC_COMMAND_DONE;\r\n}\r\ndev_dbg(mmc_dev(mmc), "cmd %d(%08x) arg %x ie 0x%08x len %d\n",\r\ncmd_val & 0x3f, cmd_val, cmd->arg, imask,\r\nmrq->data ? mrq->data->blksz * mrq->data->blocks : 0);\r\nspin_lock_irqsave(&host->lock, iflags);\r\nif (host->mrq || host->manual_stop_mrq) {\r\nspin_unlock_irqrestore(&host->lock, iflags);\r\nif (data)\r\ndma_unmap_sg(mmc_dev(mmc), data->sg, data->sg_len,\r\nsunxi_mmc_get_dma_dir(data));\r\ndev_err(mmc_dev(mmc), "request already pending\n");\r\nmrq->cmd->error = -EBUSY;\r\nmmc_request_done(mmc, mrq);\r\nreturn;\r\n}\r\nif (data) {\r\nmmc_writel(host, REG_BLKSZ, data->blksz);\r\nmmc_writel(host, REG_BCNTR, data->blksz * data->blocks);\r\nsunxi_mmc_start_dma(host, data);\r\n}\r\nhost->mrq = mrq;\r\nmmc_writel(host, REG_IMASK, host->sdio_imask | imask);\r\nmmc_writel(host, REG_CARG, cmd->arg);\r\nmmc_writel(host, REG_CMDR, cmd_val);\r\nspin_unlock_irqrestore(&host->lock, iflags);\r\n}\r\nstatic int sunxi_mmc_resource_request(struct sunxi_mmc_host *host,\r\nstruct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nint ret;\r\nif (of_device_is_compatible(np, "allwinner,sun4i-a10-mmc"))\r\nhost->idma_des_size_bits = 13;\r\nelse\r\nhost->idma_des_size_bits = 16;\r\nret = mmc_regulator_get_supply(host->mmc);\r\nif (ret) {\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(&pdev->dev, "Could not get vmmc supply\n");\r\nreturn ret;\r\n}\r\nhost->reg_base = devm_ioremap_resource(&pdev->dev,\r\nplatform_get_resource(pdev, IORESOURCE_MEM, 0));\r\nif (IS_ERR(host->reg_base))\r\nreturn PTR_ERR(host->reg_base);\r\nhost->clk_ahb = devm_clk_get(&pdev->dev, "ahb");\r\nif (IS_ERR(host->clk_ahb)) {\r\ndev_err(&pdev->dev, "Could not get ahb clock\n");\r\nreturn PTR_ERR(host->clk_ahb);\r\n}\r\nhost->clk_mmc = devm_clk_get(&pdev->dev, "mmc");\r\nif (IS_ERR(host->clk_mmc)) {\r\ndev_err(&pdev->dev, "Could not get mmc clock\n");\r\nreturn PTR_ERR(host->clk_mmc);\r\n}\r\nhost->reset = devm_reset_control_get(&pdev->dev, "ahb");\r\nret = clk_prepare_enable(host->clk_ahb);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Enable ahb clk err %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(host->clk_mmc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Enable mmc clk err %d\n", ret);\r\ngoto error_disable_clk_ahb;\r\n}\r\nif (!IS_ERR(host->reset)) {\r\nret = reset_control_deassert(host->reset);\r\nif (ret) {\r\ndev_err(&pdev->dev, "reset err %d\n", ret);\r\ngoto error_disable_clk_mmc;\r\n}\r\n}\r\nret = sunxi_mmc_reset_host(host);\r\nif (ret)\r\ngoto error_assert_reset;\r\nhost->irq = platform_get_irq(pdev, 0);\r\nreturn devm_request_threaded_irq(&pdev->dev, host->irq, sunxi_mmc_irq,\r\nsunxi_mmc_handle_manual_stop, 0, "sunxi-mmc", host);\r\nerror_assert_reset:\r\nif (!IS_ERR(host->reset))\r\nreset_control_assert(host->reset);\r\nerror_disable_clk_mmc:\r\nclk_disable_unprepare(host->clk_mmc);\r\nerror_disable_clk_ahb:\r\nclk_disable_unprepare(host->clk_ahb);\r\nreturn ret;\r\n}\r\nstatic int sunxi_mmc_probe(struct platform_device *pdev)\r\n{\r\nstruct sunxi_mmc_host *host;\r\nstruct mmc_host *mmc;\r\nint ret;\r\nmmc = mmc_alloc_host(sizeof(struct sunxi_mmc_host), &pdev->dev);\r\nif (!mmc) {\r\ndev_err(&pdev->dev, "mmc alloc host failed\n");\r\nreturn -ENOMEM;\r\n}\r\nhost = mmc_priv(mmc);\r\nhost->mmc = mmc;\r\nspin_lock_init(&host->lock);\r\nret = sunxi_mmc_resource_request(host, pdev);\r\nif (ret)\r\ngoto error_free_host;\r\nhost->sg_cpu = dma_alloc_coherent(&pdev->dev, PAGE_SIZE,\r\n&host->sg_dma, GFP_KERNEL);\r\nif (!host->sg_cpu) {\r\ndev_err(&pdev->dev, "Failed to allocate DMA descriptor mem\n");\r\nret = -ENOMEM;\r\ngoto error_free_host;\r\n}\r\nmmc->ops = &sunxi_mmc_ops;\r\nmmc->max_blk_count = 8192;\r\nmmc->max_blk_size = 4096;\r\nmmc->max_segs = PAGE_SIZE / sizeof(struct sunxi_idma_des);\r\nmmc->max_seg_size = (1 << host->idma_des_size_bits);\r\nmmc->max_req_size = mmc->max_seg_size * mmc->max_segs;\r\nmmc->f_min = 400000;\r\nmmc->f_max = 50000000;\r\nmmc->caps |= MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED;\r\nret = mmc_of_parse(mmc);\r\nif (ret)\r\ngoto error_free_dma;\r\nret = mmc_add_host(mmc);\r\nif (ret)\r\ngoto error_free_dma;\r\ndev_info(&pdev->dev, "base:0x%p irq:%u\n", host->reg_base, host->irq);\r\nplatform_set_drvdata(pdev, mmc);\r\nreturn 0;\r\nerror_free_dma:\r\ndma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);\r\nerror_free_host:\r\nmmc_free_host(mmc);\r\nreturn ret;\r\n}\r\nstatic int sunxi_mmc_remove(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nstruct sunxi_mmc_host *host = mmc_priv(mmc);\r\nmmc_remove_host(mmc);\r\ndisable_irq(host->irq);\r\nsunxi_mmc_reset_host(host);\r\nif (!IS_ERR(host->reset))\r\nreset_control_assert(host->reset);\r\nclk_disable_unprepare(host->clk_mmc);\r\nclk_disable_unprepare(host->clk_ahb);\r\ndma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);\r\nmmc_free_host(mmc);\r\nreturn 0;\r\n}
