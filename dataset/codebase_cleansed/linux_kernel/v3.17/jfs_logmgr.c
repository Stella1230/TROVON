static void write_special_inodes(struct jfs_log *log,\r\nint (*writer)(struct address_space *))\r\n{\r\nstruct jfs_sb_info *sbi;\r\nlist_for_each_entry(sbi, &log->sb_list, log_list) {\r\nwriter(sbi->ipbmap->i_mapping);\r\nwriter(sbi->ipimap->i_mapping);\r\nwriter(sbi->direct_inode->i_mapping);\r\n}\r\n}\r\nint lmLog(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\r\nstruct tlock * tlck)\r\n{\r\nint lsn;\r\nint diffp, difft;\r\nstruct metapage *mp = NULL;\r\nunsigned long flags;\r\njfs_info("lmLog: log:0x%p tblk:0x%p, lrd:0x%p tlck:0x%p",\r\nlog, tblk, lrd, tlck);\r\nLOG_LOCK(log);\r\nif (tblk == NULL)\r\ngoto writeRecord;\r\nif (tlck == NULL ||\r\ntlck->type & tlckBTROOT || (mp = tlck->mp) == NULL)\r\ngoto writeRecord;\r\nlsn = log->lsn;\r\nLOGSYNC_LOCK(log, flags);\r\nif (mp->lsn == 0) {\r\nmp->log = log;\r\nmp->lsn = lsn;\r\nlog->count++;\r\nlist_add_tail(&mp->synclist, &log->synclist);\r\n}\r\nif (tblk->lsn == 0) {\r\ntblk->lsn = mp->lsn;\r\nlog->count++;\r\nlist_add(&tblk->synclist, &mp->synclist);\r\n}\r\nelse {\r\nlogdiff(diffp, mp->lsn, log);\r\nlogdiff(difft, tblk->lsn, log);\r\nif (diffp < difft) {\r\ntblk->lsn = mp->lsn;\r\nlist_move(&tblk->synclist, &mp->synclist);\r\n}\r\n}\r\nLOGSYNC_UNLOCK(log, flags);\r\nwriteRecord:\r\nlsn = lmWriteRecord(log, tblk, lrd, tlck);\r\nlogdiff(diffp, lsn, log);\r\nif (diffp >= log->nextsync)\r\nlsn = lmLogSync(log, 0);\r\nlog->lsn = lsn;\r\nLOG_UNLOCK(log);\r\nreturn lsn;\r\n}\r\nstatic int\r\nlmWriteRecord(struct jfs_log * log, struct tblock * tblk, struct lrd * lrd,\r\nstruct tlock * tlck)\r\n{\r\nint lsn = 0;\r\nstruct lbuf *bp;\r\nstruct logpage *lp;\r\ncaddr_t dst;\r\nint dstoffset;\r\nint freespace;\r\ncaddr_t p;\r\ncaddr_t src;\r\nint srclen;\r\nint nbytes;\r\nint i;\r\nint len;\r\nstruct linelock *linelock;\r\nstruct lv *lv;\r\nstruct lvd *lvd;\r\nint l2linesize;\r\nlen = 0;\r\nbp = (struct lbuf *) log->bp;\r\nlp = (struct logpage *) bp->l_ldata;\r\ndstoffset = log->eor;\r\nif (tlck == NULL)\r\ngoto moveLrd;\r\nif (tlck->flag & tlckPAGELOCK) {\r\np = (caddr_t) (tlck->mp->data);\r\nlinelock = (struct linelock *) & tlck->lock;\r\n}\r\nelse if (tlck->flag & tlckINODELOCK) {\r\nif (tlck->type & tlckDTREE)\r\np = (caddr_t) &JFS_IP(tlck->ip)->i_dtroot;\r\nelse\r\np = (caddr_t) &JFS_IP(tlck->ip)->i_xtroot;\r\nlinelock = (struct linelock *) & tlck->lock;\r\n}\r\n#ifdef _JFS_WIP\r\nelse if (tlck->flag & tlckINLINELOCK) {\r\ninlinelock = (struct inlinelock *) & tlck;\r\np = (caddr_t) & inlinelock->pxd;\r\nlinelock = (struct linelock *) & tlck;\r\n}\r\n#endif\r\nelse {\r\njfs_err("lmWriteRecord: UFO tlck:0x%p", tlck);\r\nreturn 0;\r\n}\r\nl2linesize = linelock->l2linesize;\r\nmoveData:\r\nASSERT(linelock->index <= linelock->maxcnt);\r\nlv = linelock->lv;\r\nfor (i = 0; i < linelock->index; i++, lv++) {\r\nif (lv->length == 0)\r\ncontinue;\r\nif (dstoffset >= LOGPSIZE - LOGPTLRSIZE) {\r\nlmNextPage(log);\r\nbp = log->bp;\r\nlp = (struct logpage *) bp->l_ldata;\r\ndstoffset = LOGPHDRSIZE;\r\n}\r\nsrc = (u8 *) p + (lv->offset << l2linesize);\r\nsrclen = lv->length << l2linesize;\r\nlen += srclen;\r\nwhile (srclen > 0) {\r\nfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\r\nnbytes = min(freespace, srclen);\r\ndst = (caddr_t) lp + dstoffset;\r\nmemcpy(dst, src, nbytes);\r\ndstoffset += nbytes;\r\nif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\r\nbreak;\r\nlmNextPage(log);\r\nbp = (struct lbuf *) log->bp;\r\nlp = (struct logpage *) bp->l_ldata;\r\ndstoffset = LOGPHDRSIZE;\r\nsrclen -= nbytes;\r\nsrc += nbytes;\r\n}\r\nlen += 4;\r\nlvd = (struct lvd *) ((caddr_t) lp + dstoffset);\r\nlvd->offset = cpu_to_le16(lv->offset);\r\nlvd->length = cpu_to_le16(lv->length);\r\ndstoffset += 4;\r\njfs_info("lmWriteRecord: lv offset:%d length:%d",\r\nlv->offset, lv->length);\r\n}\r\nif ((i = linelock->next)) {\r\nlinelock = (struct linelock *) lid_to_tlock(i);\r\ngoto moveData;\r\n}\r\nmoveLrd:\r\nlrd->length = cpu_to_le16(len);\r\nsrc = (caddr_t) lrd;\r\nsrclen = LOGRDSIZE;\r\nwhile (srclen > 0) {\r\nfreespace = (LOGPSIZE - LOGPTLRSIZE) - dstoffset;\r\nnbytes = min(freespace, srclen);\r\ndst = (caddr_t) lp + dstoffset;\r\nmemcpy(dst, src, nbytes);\r\ndstoffset += nbytes;\r\nsrclen -= nbytes;\r\nif (srclen)\r\ngoto pageFull;\r\nlog->eor = dstoffset;\r\nbp->l_eor = dstoffset;\r\nlsn = (log->page << L2LOGPSIZE) + dstoffset;\r\nif (lrd->type & cpu_to_le16(LOG_COMMIT)) {\r\ntblk->clsn = lsn;\r\njfs_info("wr: tclsn:0x%x, beor:0x%x", tblk->clsn,\r\nbp->l_eor);\r\nINCREMENT(lmStat.commit);\r\nLOGGC_LOCK(log);\r\ntblk->flag = tblkGC_QUEUE;\r\ntblk->bp = log->bp;\r\ntblk->pn = log->page;\r\ntblk->eor = log->eor;\r\nlist_add_tail(&tblk->cqueue, &log->cqueue);\r\nLOGGC_UNLOCK(log);\r\n}\r\njfs_info("lmWriteRecord: lrd:0x%04x bp:0x%p pn:%d eor:0x%x",\r\nle16_to_cpu(lrd->type), log->bp, log->page, dstoffset);\r\nif (dstoffset < LOGPSIZE - LOGPTLRSIZE)\r\nreturn lsn;\r\npageFull:\r\nlmNextPage(log);\r\nbp = (struct lbuf *) log->bp;\r\nlp = (struct logpage *) bp->l_ldata;\r\ndstoffset = LOGPHDRSIZE;\r\nsrc += nbytes;\r\n}\r\nreturn lsn;\r\n}\r\nstatic int lmNextPage(struct jfs_log * log)\r\n{\r\nstruct logpage *lp;\r\nint lspn;\r\nint pn;\r\nstruct lbuf *bp;\r\nstruct lbuf *nextbp;\r\nstruct tblock *tblk;\r\npn = log->page;\r\nbp = log->bp;\r\nlp = (struct logpage *) bp->l_ldata;\r\nlspn = le32_to_cpu(lp->h.page);\r\nLOGGC_LOCK(log);\r\nif (list_empty(&log->cqueue))\r\ntblk = NULL;\r\nelse\r\ntblk = list_entry(log->cqueue.prev, struct tblock, cqueue);\r\nif (tblk && tblk->pn == pn) {\r\ntblk->flag |= tblkGC_EOP;\r\nif (log->cflag & logGC_PAGEOUT) {\r\nif (bp->l_wqnext == NULL)\r\nlbmWrite(log, bp, 0, 0);\r\n} else {\r\nlog->cflag |= logGC_PAGEOUT;\r\nlmGCwrite(log, 0);\r\n}\r\n}\r\nelse {\r\nbp->l_ceor = bp->l_eor;\r\nlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\r\nlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmFREE, 0);\r\n}\r\nLOGGC_UNLOCK(log);\r\nlog->page = (pn == log->size - 1) ? 2 : pn + 1;\r\nlog->eor = LOGPHDRSIZE;\r\nnextbp = lbmAllocate(log, log->page);\r\nnextbp->l_eor = log->eor;\r\nlog->bp = nextbp;\r\nlp = (struct logpage *) nextbp->l_ldata;\r\nlp->h.page = lp->t.page = cpu_to_le32(lspn + 1);\r\nlp->h.eor = lp->t.eor = cpu_to_le16(LOGPHDRSIZE);\r\nreturn 0;\r\n}\r\nint lmGroupCommit(struct jfs_log * log, struct tblock * tblk)\r\n{\r\nint rc = 0;\r\nLOGGC_LOCK(log);\r\nif (tblk->flag & tblkGC_COMMITTED) {\r\nif (tblk->flag & tblkGC_ERROR)\r\nrc = -EIO;\r\nLOGGC_UNLOCK(log);\r\nreturn rc;\r\n}\r\njfs_info("lmGroup Commit: tblk = 0x%p, gcrtc = %d", tblk, log->gcrtc);\r\nif (tblk->xflag & COMMIT_LAZY)\r\ntblk->flag |= tblkGC_LAZY;\r\nif ((!(log->cflag & logGC_PAGEOUT)) && (!list_empty(&log->cqueue)) &&\r\n(!(tblk->xflag & COMMIT_LAZY) || test_bit(log_FLUSH, &log->flag)\r\n|| jfs_tlocks_low)) {\r\nlog->cflag |= logGC_PAGEOUT;\r\nlmGCwrite(log, 0);\r\n}\r\nif (tblk->xflag & COMMIT_LAZY) {\r\nLOGGC_UNLOCK(log);\r\nreturn 0;\r\n}\r\nif (tblk->flag & tblkGC_COMMITTED) {\r\nif (tblk->flag & tblkGC_ERROR)\r\nrc = -EIO;\r\nLOGGC_UNLOCK(log);\r\nreturn rc;\r\n}\r\nlog->gcrtc++;\r\ntblk->flag |= tblkGC_READY;\r\n__SLEEP_COND(tblk->gcwait, (tblk->flag & tblkGC_COMMITTED),\r\nLOGGC_LOCK(log), LOGGC_UNLOCK(log));\r\nif (tblk->flag & tblkGC_ERROR)\r\nrc = -EIO;\r\nLOGGC_UNLOCK(log);\r\nreturn rc;\r\n}\r\nstatic void lmGCwrite(struct jfs_log * log, int cant_write)\r\n{\r\nstruct lbuf *bp;\r\nstruct logpage *lp;\r\nint gcpn;\r\nstruct tblock *tblk;\r\nstruct tblock *xtblk = NULL;\r\ngcpn = list_entry(log->cqueue.next, struct tblock, cqueue)->pn;\r\nlist_for_each_entry(tblk, &log->cqueue, cqueue) {\r\nif (tblk->pn != gcpn)\r\nbreak;\r\nxtblk = tblk;\r\ntblk->flag |= tblkGC_COMMIT;\r\n}\r\ntblk = xtblk;\r\nbp = (struct lbuf *) tblk->bp;\r\nlp = (struct logpage *) bp->l_ldata;\r\nif (tblk->flag & tblkGC_EOP) {\r\ntblk->flag &= ~tblkGC_EOP;\r\ntblk->flag |= tblkGC_FREE;\r\nbp->l_ceor = bp->l_eor;\r\nlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\r\nlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmGC,\r\ncant_write);\r\nINCREMENT(lmStat.full_page);\r\n}\r\nelse {\r\nbp->l_ceor = tblk->eor;\r\nlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_ceor);\r\nlbmWrite(log, bp, lbmWRITE | lbmGC, cant_write);\r\nINCREMENT(lmStat.partial_page);\r\n}\r\n}\r\nstatic void lmPostGC(struct lbuf * bp)\r\n{\r\nunsigned long flags;\r\nstruct jfs_log *log = bp->l_log;\r\nstruct logpage *lp;\r\nstruct tblock *tblk, *temp;\r\nspin_lock_irqsave(&log->gclock, flags);\r\nlist_for_each_entry_safe(tblk, temp, &log->cqueue, cqueue) {\r\nif (!(tblk->flag & tblkGC_COMMIT))\r\nbreak;\r\nif (bp->l_flag & lbmERROR)\r\ntblk->flag |= tblkGC_ERROR;\r\nlist_del(&tblk->cqueue);\r\ntblk->flag &= ~tblkGC_QUEUE;\r\nif (tblk == log->flush_tblk) {\r\nclear_bit(log_FLUSH, &log->flag);\r\nlog->flush_tblk = NULL;\r\n}\r\njfs_info("lmPostGC: tblk = 0x%p, flag = 0x%x", tblk,\r\ntblk->flag);\r\nif (!(tblk->xflag & COMMIT_FORCE))\r\ntxLazyUnlock(tblk);\r\nelse {\r\ntblk->flag |= tblkGC_COMMITTED;\r\nif (tblk->flag & tblkGC_READY)\r\nlog->gcrtc--;\r\nLOGGC_WAKEUP(tblk);\r\n}\r\nif (tblk->flag & tblkGC_FREE)\r\nlbmFree(bp);\r\nelse if (tblk->flag & tblkGC_EOP) {\r\nlp = (struct logpage *) bp->l_ldata;\r\nbp->l_ceor = bp->l_eor;\r\nlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\r\njfs_info("lmPostGC: calling lbmWrite");\r\nlbmWrite(log, bp, lbmWRITE | lbmRELEASE | lbmFREE,\r\n1);\r\n}\r\n}\r\nif ((!list_empty(&log->cqueue)) &&\r\n((log->gcrtc > 0) || (tblk->bp->l_wqnext != NULL) ||\r\ntest_bit(log_FLUSH, &log->flag) || jfs_tlocks_low))\r\nlmGCwrite(log, 1);\r\nelse\r\nlog->cflag &= ~logGC_PAGEOUT;\r\nspin_unlock_irqrestore(&log->gclock, flags);\r\nreturn;\r\n}\r\nstatic int lmLogSync(struct jfs_log * log, int hard_sync)\r\n{\r\nint logsize;\r\nint written;\r\nint free;\r\nint delta;\r\nint more;\r\nstruct lrd lrd;\r\nint lsn;\r\nstruct logsyncblk *lp;\r\nunsigned long flags;\r\nif (hard_sync)\r\nwrite_special_inodes(log, filemap_fdatawrite);\r\nelse\r\nwrite_special_inodes(log, filemap_flush);\r\nif (log->sync == log->syncpt) {\r\nLOGSYNC_LOCK(log, flags);\r\nif (list_empty(&log->synclist))\r\nlog->sync = log->lsn;\r\nelse {\r\nlp = list_entry(log->synclist.next,\r\nstruct logsyncblk, synclist);\r\nlog->sync = lp->lsn;\r\n}\r\nLOGSYNC_UNLOCK(log, flags);\r\n}\r\nif (log->sync != log->syncpt) {\r\nlrd.logtid = 0;\r\nlrd.backchain = 0;\r\nlrd.type = cpu_to_le16(LOG_SYNCPT);\r\nlrd.length = 0;\r\nlrd.log.syncpt.sync = cpu_to_le32(log->sync);\r\nlsn = lmWriteRecord(log, NULL, &lrd, NULL);\r\nlog->syncpt = log->sync;\r\n} else\r\nlsn = log->lsn;\r\nlogsize = log->logsize;\r\nlogdiff(written, lsn, log);\r\nfree = logsize - written;\r\ndelta = LOGSYNC_DELTA(logsize);\r\nmore = min(free / 2, delta);\r\nif (more < 2 * LOGPSIZE) {\r\njfs_warn("\n ... Log Wrap ... Log Wrap ... Log Wrap ...\n");\r\nlog->syncpt = log->sync = lsn;\r\nlog->nextsync = delta;\r\n} else\r\nlog->nextsync = written + more;\r\nif (!test_bit(log_SYNCBARRIER, &log->flag) &&\r\n(written > LOGSYNC_BARRIER(logsize)) && log->active) {\r\nset_bit(log_SYNCBARRIER, &log->flag);\r\njfs_info("log barrier on: lsn=0x%x syncpt=0x%x", lsn,\r\nlog->syncpt);\r\njfs_flush_journal(log, 0);\r\n}\r\nreturn lsn;\r\n}\r\nvoid jfs_syncpt(struct jfs_log *log, int hard_sync)\r\n{ LOG_LOCK(log);\r\nif (!test_bit(log_QUIESCE, &log->flag))\r\nlmLogSync(log, hard_sync);\r\nLOG_UNLOCK(log);\r\n}\r\nint lmLogOpen(struct super_block *sb)\r\n{\r\nint rc;\r\nstruct block_device *bdev;\r\nstruct jfs_log *log;\r\nstruct jfs_sb_info *sbi = JFS_SBI(sb);\r\nif (sbi->flag & JFS_NOINTEGRITY)\r\nreturn open_dummy_log(sb);\r\nif (sbi->mntflag & JFS_INLINELOG)\r\nreturn open_inline_log(sb);\r\nmutex_lock(&jfs_log_mutex);\r\nlist_for_each_entry(log, &jfs_external_logs, journal_list) {\r\nif (log->bdev->bd_dev == sbi->logdev) {\r\nif (memcmp(log->uuid, sbi->loguuid,\r\nsizeof(log->uuid))) {\r\njfs_warn("wrong uuid on JFS journal\n");\r\nmutex_unlock(&jfs_log_mutex);\r\nreturn -EINVAL;\r\n}\r\nif ((rc = lmLogFileSystem(log, sbi, 1))) {\r\nmutex_unlock(&jfs_log_mutex);\r\nreturn rc;\r\n}\r\ngoto journal_found;\r\n}\r\n}\r\nif (!(log = kzalloc(sizeof(struct jfs_log), GFP_KERNEL))) {\r\nmutex_unlock(&jfs_log_mutex);\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&log->sb_list);\r\ninit_waitqueue_head(&log->syncwait);\r\nbdev = blkdev_get_by_dev(sbi->logdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL,\r\nlog);\r\nif (IS_ERR(bdev)) {\r\nrc = PTR_ERR(bdev);\r\ngoto free;\r\n}\r\nlog->bdev = bdev;\r\nmemcpy(log->uuid, sbi->loguuid, sizeof(log->uuid));\r\nif ((rc = lmLogInit(log)))\r\ngoto close;\r\nlist_add(&log->journal_list, &jfs_external_logs);\r\nif ((rc = lmLogFileSystem(log, sbi, 1)))\r\ngoto shutdown;\r\njournal_found:\r\nLOG_LOCK(log);\r\nlist_add(&sbi->log_list, &log->sb_list);\r\nsbi->log = log;\r\nLOG_UNLOCK(log);\r\nmutex_unlock(&jfs_log_mutex);\r\nreturn 0;\r\nshutdown:\r\nlist_del(&log->journal_list);\r\nlbmLogShutdown(log);\r\nclose:\r\nblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\r\nfree:\r\nmutex_unlock(&jfs_log_mutex);\r\nkfree(log);\r\njfs_warn("lmLogOpen: exit(%d)", rc);\r\nreturn rc;\r\n}\r\nstatic int open_inline_log(struct super_block *sb)\r\n{\r\nstruct jfs_log *log;\r\nint rc;\r\nif (!(log = kzalloc(sizeof(struct jfs_log), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&log->sb_list);\r\ninit_waitqueue_head(&log->syncwait);\r\nset_bit(log_INLINELOG, &log->flag);\r\nlog->bdev = sb->s_bdev;\r\nlog->base = addressPXD(&JFS_SBI(sb)->logpxd);\r\nlog->size = lengthPXD(&JFS_SBI(sb)->logpxd) >>\r\n(L2LOGPSIZE - sb->s_blocksize_bits);\r\nlog->l2bsize = sb->s_blocksize_bits;\r\nASSERT(L2LOGPSIZE >= sb->s_blocksize_bits);\r\nif ((rc = lmLogInit(log))) {\r\nkfree(log);\r\njfs_warn("lmLogOpen: exit(%d)", rc);\r\nreturn rc;\r\n}\r\nlist_add(&JFS_SBI(sb)->log_list, &log->sb_list);\r\nJFS_SBI(sb)->log = log;\r\nreturn rc;\r\n}\r\nstatic int open_dummy_log(struct super_block *sb)\r\n{\r\nint rc;\r\nmutex_lock(&jfs_log_mutex);\r\nif (!dummy_log) {\r\ndummy_log = kzalloc(sizeof(struct jfs_log), GFP_KERNEL);\r\nif (!dummy_log) {\r\nmutex_unlock(&jfs_log_mutex);\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&dummy_log->sb_list);\r\ninit_waitqueue_head(&dummy_log->syncwait);\r\ndummy_log->no_integrity = 1;\r\ndummy_log->base = 0;\r\ndummy_log->size = 1024;\r\nrc = lmLogInit(dummy_log);\r\nif (rc) {\r\nkfree(dummy_log);\r\ndummy_log = NULL;\r\nmutex_unlock(&jfs_log_mutex);\r\nreturn rc;\r\n}\r\n}\r\nLOG_LOCK(dummy_log);\r\nlist_add(&JFS_SBI(sb)->log_list, &dummy_log->sb_list);\r\nJFS_SBI(sb)->log = dummy_log;\r\nLOG_UNLOCK(dummy_log);\r\nmutex_unlock(&jfs_log_mutex);\r\nreturn 0;\r\n}\r\nint lmLogInit(struct jfs_log * log)\r\n{\r\nint rc = 0;\r\nstruct lrd lrd;\r\nstruct logsuper *logsuper;\r\nstruct lbuf *bpsuper;\r\nstruct lbuf *bp;\r\nstruct logpage *lp;\r\nint lsn = 0;\r\njfs_info("lmLogInit: log:0x%p", log);\r\nLOGGC_LOCK_INIT(log);\r\nLOG_LOCK_INIT(log);\r\nLOGSYNC_LOCK_INIT(log);\r\nINIT_LIST_HEAD(&log->synclist);\r\nINIT_LIST_HEAD(&log->cqueue);\r\nlog->flush_tblk = NULL;\r\nlog->count = 0;\r\nif ((rc = lbmLogInit(log)))\r\nreturn rc;\r\nif (!test_bit(log_INLINELOG, &log->flag))\r\nlog->l2bsize = L2LOGPSIZE;\r\nif (log->no_integrity) {\r\nbp = lbmAllocate(log , 0);\r\nlog->bp = bp;\r\nbp->l_pn = bp->l_eor = 0;\r\n} else {\r\nif ((rc = lbmRead(log, 1, &bpsuper)))\r\ngoto errout10;\r\nlogsuper = (struct logsuper *) bpsuper->l_ldata;\r\nif (logsuper->magic != cpu_to_le32(LOGMAGIC)) {\r\njfs_warn("*** Log Format Error ! ***");\r\nrc = -EINVAL;\r\ngoto errout20;\r\n}\r\nif (logsuper->state != cpu_to_le32(LOGREDONE)) {\r\njfs_warn("*** Log Is Dirty ! ***");\r\nrc = -EINVAL;\r\ngoto errout20;\r\n}\r\nif (test_bit(log_INLINELOG,&log->flag)) {\r\nif (log->size != le32_to_cpu(logsuper->size)) {\r\nrc = -EINVAL;\r\ngoto errout20;\r\n}\r\njfs_info("lmLogInit: inline log:0x%p base:0x%Lx "\r\n"size:0x%x", log,\r\n(unsigned long long) log->base, log->size);\r\n} else {\r\nif (memcmp(logsuper->uuid, log->uuid, 16)) {\r\njfs_warn("wrong uuid on JFS log device");\r\ngoto errout20;\r\n}\r\nlog->size = le32_to_cpu(logsuper->size);\r\nlog->l2bsize = le32_to_cpu(logsuper->l2bsize);\r\njfs_info("lmLogInit: external log:0x%p base:0x%Lx "\r\n"size:0x%x", log,\r\n(unsigned long long) log->base, log->size);\r\n}\r\nlog->page = le32_to_cpu(logsuper->end) / LOGPSIZE;\r\nlog->eor = le32_to_cpu(logsuper->end) - (LOGPSIZE * log->page);\r\nif ((rc = lbmRead(log, log->page, &bp)))\r\ngoto errout20;\r\nlp = (struct logpage *) bp->l_ldata;\r\njfs_info("lmLogInit: lsn:0x%x page:%d eor:%d:%d",\r\nle32_to_cpu(logsuper->end), log->page, log->eor,\r\nle16_to_cpu(lp->h.eor));\r\nlog->bp = bp;\r\nbp->l_pn = log->page;\r\nbp->l_eor = log->eor;\r\nif (log->eor >= LOGPSIZE - LOGPTLRSIZE)\r\nlmNextPage(log);\r\nlrd.logtid = 0;\r\nlrd.backchain = 0;\r\nlrd.type = cpu_to_le16(LOG_SYNCPT);\r\nlrd.length = 0;\r\nlrd.log.syncpt.sync = 0;\r\nlsn = lmWriteRecord(log, NULL, &lrd, NULL);\r\nbp = log->bp;\r\nbp->l_ceor = bp->l_eor;\r\nlp = (struct logpage *) bp->l_ldata;\r\nlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\r\nlbmWrite(log, bp, lbmWRITE | lbmSYNC, 0);\r\nif ((rc = lbmIOWait(bp, 0)))\r\ngoto errout30;\r\nlogsuper->state = cpu_to_le32(LOGMOUNT);\r\nlog->serial = le32_to_cpu(logsuper->serial) + 1;\r\nlogsuper->serial = cpu_to_le32(log->serial);\r\nlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\r\nif ((rc = lbmIOWait(bpsuper, lbmFREE)))\r\ngoto errout30;\r\n}\r\nlog->logsize = (log->size - 2) << L2LOGPSIZE;\r\nlog->lsn = lsn;\r\nlog->syncpt = lsn;\r\nlog->sync = log->syncpt;\r\nlog->nextsync = LOGSYNC_DELTA(log->logsize);\r\njfs_info("lmLogInit: lsn:0x%x syncpt:0x%x sync:0x%x",\r\nlog->lsn, log->syncpt, log->sync);\r\nlog->clsn = lsn;\r\nreturn 0;\r\nerrout30:\r\nlog->wqueue = NULL;\r\nbp->l_wqnext = NULL;\r\nlbmFree(bp);\r\nerrout20:\r\nlbmFree(bpsuper);\r\nerrout10:\r\nlbmLogShutdown(log);\r\njfs_warn("lmLogInit: exit(%d)", rc);\r\nreturn rc;\r\n}\r\nint lmLogClose(struct super_block *sb)\r\n{\r\nstruct jfs_sb_info *sbi = JFS_SBI(sb);\r\nstruct jfs_log *log = sbi->log;\r\nstruct block_device *bdev;\r\nint rc = 0;\r\njfs_info("lmLogClose: log:0x%p", log);\r\nmutex_lock(&jfs_log_mutex);\r\nLOG_LOCK(log);\r\nlist_del(&sbi->log_list);\r\nLOG_UNLOCK(log);\r\nsbi->log = NULL;\r\nsync_blockdev(sb->s_bdev);\r\nif (test_bit(log_INLINELOG, &log->flag)) {\r\nrc = lmLogShutdown(log);\r\nkfree(log);\r\ngoto out;\r\n}\r\nif (!log->no_integrity)\r\nlmLogFileSystem(log, sbi, 0);\r\nif (!list_empty(&log->sb_list))\r\ngoto out;\r\nif (log->no_integrity)\r\ngoto out;\r\nlist_del(&log->journal_list);\r\nbdev = log->bdev;\r\nrc = lmLogShutdown(log);\r\nblkdev_put(bdev, FMODE_READ|FMODE_WRITE|FMODE_EXCL);\r\nkfree(log);\r\nout:\r\nmutex_unlock(&jfs_log_mutex);\r\njfs_info("lmLogClose: exit(%d)", rc);\r\nreturn rc;\r\n}\r\nvoid jfs_flush_journal(struct jfs_log *log, int wait)\r\n{\r\nint i;\r\nstruct tblock *target = NULL;\r\nif (!log)\r\nreturn;\r\njfs_info("jfs_flush_journal: log:0x%p wait=%d", log, wait);\r\nLOGGC_LOCK(log);\r\nif (!list_empty(&log->cqueue)) {\r\ntarget = list_entry(log->cqueue.prev, struct tblock, cqueue);\r\nif (test_bit(log_FLUSH, &log->flag)) {\r\nif (log->flush_tblk)\r\nlog->flush_tblk = target;\r\n} else {\r\nlog->flush_tblk = target;\r\nset_bit(log_FLUSH, &log->flag);\r\nif (!(log->cflag & logGC_PAGEOUT)) {\r\nlog->cflag |= logGC_PAGEOUT;\r\nlmGCwrite(log, 0);\r\n}\r\n}\r\n}\r\nif ((wait > 1) || test_bit(log_SYNCBARRIER, &log->flag)) {\r\nset_bit(log_FLUSH, &log->flag);\r\nlog->flush_tblk = NULL;\r\n}\r\nif (wait && target && !(target->flag & tblkGC_COMMITTED)) {\r\nDECLARE_WAITQUEUE(__wait, current);\r\nadd_wait_queue(&target->gcwait, &__wait);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nLOGGC_UNLOCK(log);\r\nschedule();\r\n__set_current_state(TASK_RUNNING);\r\nLOGGC_LOCK(log);\r\nremove_wait_queue(&target->gcwait, &__wait);\r\n}\r\nLOGGC_UNLOCK(log);\r\nif (wait < 2)\r\nreturn;\r\nwrite_special_inodes(log, filemap_fdatawrite);\r\nif ((!list_empty(&log->cqueue)) || !list_empty(&log->synclist)) {\r\nfor (i = 0; i < 200; i++) {\r\nmsleep(250);\r\nwrite_special_inodes(log, filemap_fdatawrite);\r\nif (list_empty(&log->cqueue) &&\r\nlist_empty(&log->synclist))\r\nbreak;\r\n}\r\n}\r\nassert(list_empty(&log->cqueue));\r\n#ifdef CONFIG_JFS_DEBUG\r\nif (!list_empty(&log->synclist)) {\r\nstruct logsyncblk *lp;\r\nprintk(KERN_ERR "jfs_flush_journal: synclist not empty\n");\r\nlist_for_each_entry(lp, &log->synclist, synclist) {\r\nif (lp->xflag & COMMIT_PAGE) {\r\nstruct metapage *mp = (struct metapage *)lp;\r\nprint_hex_dump(KERN_ERR, "metapage: ",\r\nDUMP_PREFIX_ADDRESS, 16, 4,\r\nmp, sizeof(struct metapage), 0);\r\nprint_hex_dump(KERN_ERR, "page: ",\r\nDUMP_PREFIX_ADDRESS, 16,\r\nsizeof(long), mp->page,\r\nsizeof(struct page), 0);\r\n} else\r\nprint_hex_dump(KERN_ERR, "tblock:",\r\nDUMP_PREFIX_ADDRESS, 16, 4,\r\nlp, sizeof(struct tblock), 0);\r\n}\r\n}\r\n#else\r\nWARN_ON(!list_empty(&log->synclist));\r\n#endif\r\nclear_bit(log_FLUSH, &log->flag);\r\n}\r\nint lmLogShutdown(struct jfs_log * log)\r\n{\r\nint rc;\r\nstruct lrd lrd;\r\nint lsn;\r\nstruct logsuper *logsuper;\r\nstruct lbuf *bpsuper;\r\nstruct lbuf *bp;\r\nstruct logpage *lp;\r\njfs_info("lmLogShutdown: log:0x%p", log);\r\njfs_flush_journal(log, 2);\r\nlrd.logtid = 0;\r\nlrd.backchain = 0;\r\nlrd.type = cpu_to_le16(LOG_SYNCPT);\r\nlrd.length = 0;\r\nlrd.log.syncpt.sync = 0;\r\nlsn = lmWriteRecord(log, NULL, &lrd, NULL);\r\nbp = log->bp;\r\nlp = (struct logpage *) bp->l_ldata;\r\nlp->h.eor = lp->t.eor = cpu_to_le16(bp->l_eor);\r\nlbmWrite(log, log->bp, lbmWRITE | lbmRELEASE | lbmSYNC, 0);\r\nlbmIOWait(log->bp, lbmFREE);\r\nlog->bp = NULL;\r\nif ((rc = lbmRead(log, 1, &bpsuper)))\r\ngoto out;\r\nlogsuper = (struct logsuper *) bpsuper->l_ldata;\r\nlogsuper->state = cpu_to_le32(LOGREDONE);\r\nlogsuper->end = cpu_to_le32(lsn);\r\nlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\r\nrc = lbmIOWait(bpsuper, lbmFREE);\r\njfs_info("lmLogShutdown: lsn:0x%x page:%d eor:%d",\r\nlsn, log->page, log->eor);\r\nout:\r\nlbmLogShutdown(log);\r\nif (rc) {\r\njfs_warn("lmLogShutdown: exit(%d)", rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic int lmLogFileSystem(struct jfs_log * log, struct jfs_sb_info *sbi,\r\nint activate)\r\n{\r\nint rc = 0;\r\nint i;\r\nstruct logsuper *logsuper;\r\nstruct lbuf *bpsuper;\r\nchar *uuid = sbi->uuid;\r\nif ((rc = lbmRead(log, 1, &bpsuper)))\r\nreturn rc;\r\nlogsuper = (struct logsuper *) bpsuper->l_ldata;\r\nif (activate) {\r\nfor (i = 0; i < MAX_ACTIVE; i++)\r\nif (!memcmp(logsuper->active[i].uuid, NULL_UUID, 16)) {\r\nmemcpy(logsuper->active[i].uuid, uuid, 16);\r\nsbi->aggregate = i;\r\nbreak;\r\n}\r\nif (i == MAX_ACTIVE) {\r\njfs_warn("Too many file systems sharing journal!");\r\nlbmFree(bpsuper);\r\nreturn -EMFILE;\r\n}\r\n} else {\r\nfor (i = 0; i < MAX_ACTIVE; i++)\r\nif (!memcmp(logsuper->active[i].uuid, uuid, 16)) {\r\nmemcpy(logsuper->active[i].uuid, NULL_UUID, 16);\r\nbreak;\r\n}\r\nif (i == MAX_ACTIVE) {\r\njfs_warn("Somebody stomped on the journal!");\r\nlbmFree(bpsuper);\r\nreturn -EIO;\r\n}\r\n}\r\nlbmDirectWrite(log, bpsuper, lbmWRITE | lbmRELEASE | lbmSYNC);\r\nrc = lbmIOWait(bpsuper, lbmFREE);\r\nreturn rc;\r\n}\r\nstatic int lbmLogInit(struct jfs_log * log)\r\n{\r\nint i;\r\nstruct lbuf *lbuf;\r\njfs_info("lbmLogInit: log:0x%p", log);\r\nlog->bp = NULL;\r\nlog->wqueue = NULL;\r\ninit_waitqueue_head(&log->free_wait);\r\nlog->lbuf_free = NULL;\r\nfor (i = 0; i < LOGPAGES;) {\r\nchar *buffer;\r\nuint offset;\r\nstruct page *page;\r\nbuffer = (char *) get_zeroed_page(GFP_KERNEL);\r\nif (buffer == NULL)\r\ngoto error;\r\npage = virt_to_page(buffer);\r\nfor (offset = 0; offset < PAGE_SIZE; offset += LOGPSIZE) {\r\nlbuf = kmalloc(sizeof(struct lbuf), GFP_KERNEL);\r\nif (lbuf == NULL) {\r\nif (offset == 0)\r\nfree_page((unsigned long) buffer);\r\ngoto error;\r\n}\r\nif (offset)\r\nget_page(page);\r\nlbuf->l_offset = offset;\r\nlbuf->l_ldata = buffer + offset;\r\nlbuf->l_page = page;\r\nlbuf->l_log = log;\r\ninit_waitqueue_head(&lbuf->l_ioevent);\r\nlbuf->l_freelist = log->lbuf_free;\r\nlog->lbuf_free = lbuf;\r\ni++;\r\n}\r\n}\r\nreturn (0);\r\nerror:\r\nlbmLogShutdown(log);\r\nreturn -ENOMEM;\r\n}\r\nstatic void lbmLogShutdown(struct jfs_log * log)\r\n{\r\nstruct lbuf *lbuf;\r\njfs_info("lbmLogShutdown: log:0x%p", log);\r\nlbuf = log->lbuf_free;\r\nwhile (lbuf) {\r\nstruct lbuf *next = lbuf->l_freelist;\r\n__free_page(lbuf->l_page);\r\nkfree(lbuf);\r\nlbuf = next;\r\n}\r\n}\r\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int pn)\r\n{\r\nstruct lbuf *bp;\r\nunsigned long flags;\r\nLCACHE_LOCK(flags);\r\nLCACHE_SLEEP_COND(log->free_wait, (bp = log->lbuf_free), flags);\r\nlog->lbuf_free = bp->l_freelist;\r\nLCACHE_UNLOCK(flags);\r\nbp->l_flag = 0;\r\nbp->l_wqnext = NULL;\r\nbp->l_freelist = NULL;\r\nbp->l_pn = pn;\r\nbp->l_blkno = log->base + (pn << (L2LOGPSIZE - log->l2bsize));\r\nbp->l_ceor = 0;\r\nreturn bp;\r\n}\r\nstatic void lbmFree(struct lbuf * bp)\r\n{\r\nunsigned long flags;\r\nLCACHE_LOCK(flags);\r\nlbmfree(bp);\r\nLCACHE_UNLOCK(flags);\r\n}\r\nstatic void lbmfree(struct lbuf * bp)\r\n{\r\nstruct jfs_log *log = bp->l_log;\r\nassert(bp->l_wqnext == NULL);\r\nbp->l_freelist = log->lbuf_free;\r\nlog->lbuf_free = bp;\r\nwake_up(&log->free_wait);\r\nreturn;\r\n}\r\nstatic inline void lbmRedrive(struct lbuf *bp)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&log_redrive_lock, flags);\r\nbp->l_redrive_next = log_redrive_list;\r\nlog_redrive_list = bp;\r\nspin_unlock_irqrestore(&log_redrive_lock, flags);\r\nwake_up_process(jfsIOthread);\r\n}\r\nstatic int lbmRead(struct jfs_log * log, int pn, struct lbuf ** bpp)\r\n{\r\nstruct bio *bio;\r\nstruct lbuf *bp;\r\n*bpp = bp = lbmAllocate(log, pn);\r\njfs_info("lbmRead: bp:0x%p pn:0x%x", bp, pn);\r\nbp->l_flag |= lbmREAD;\r\nbio = bio_alloc(GFP_NOFS, 1);\r\nbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\r\nbio->bi_bdev = log->bdev;\r\nbio->bi_io_vec[0].bv_page = bp->l_page;\r\nbio->bi_io_vec[0].bv_len = LOGPSIZE;\r\nbio->bi_io_vec[0].bv_offset = bp->l_offset;\r\nbio->bi_vcnt = 1;\r\nbio->bi_iter.bi_size = LOGPSIZE;\r\nbio->bi_end_io = lbmIODone;\r\nbio->bi_private = bp;\r\nif (log->no_integrity) {\r\nbio->bi_iter.bi_size = 0;\r\nlbmIODone(bio, 0);\r\n} else {\r\nsubmit_bio(READ_SYNC, bio);\r\n}\r\nwait_event(bp->l_ioevent, (bp->l_flag != lbmREAD));\r\nreturn 0;\r\n}\r\nstatic void lbmWrite(struct jfs_log * log, struct lbuf * bp, int flag,\r\nint cant_block)\r\n{\r\nstruct lbuf *tail;\r\nunsigned long flags;\r\njfs_info("lbmWrite: bp:0x%p flag:0x%x pn:0x%x", bp, flag, bp->l_pn);\r\nbp->l_blkno =\r\nlog->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\r\nLCACHE_LOCK(flags);\r\nbp->l_flag = flag;\r\ntail = log->wqueue;\r\nif (bp->l_wqnext == NULL) {\r\nif (tail == NULL) {\r\nlog->wqueue = bp;\r\nbp->l_wqnext = bp;\r\n} else {\r\nlog->wqueue = bp;\r\nbp->l_wqnext = tail->l_wqnext;\r\ntail->l_wqnext = bp;\r\n}\r\ntail = bp;\r\n}\r\nif ((bp != tail->l_wqnext) || !(flag & lbmWRITE)) {\r\nLCACHE_UNLOCK(flags);\r\nreturn;\r\n}\r\nLCACHE_UNLOCK(flags);\r\nif (cant_block)\r\nlbmRedrive(bp);\r\nelse if (flag & lbmSYNC)\r\nlbmStartIO(bp);\r\nelse {\r\nLOGGC_UNLOCK(log);\r\nlbmStartIO(bp);\r\nLOGGC_LOCK(log);\r\n}\r\n}\r\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag)\r\n{\r\njfs_info("lbmDirectWrite: bp:0x%p flag:0x%x pn:0x%x",\r\nbp, flag, bp->l_pn);\r\nbp->l_flag = flag | lbmDIRECT;\r\nbp->l_blkno =\r\nlog->base + (bp->l_pn << (L2LOGPSIZE - log->l2bsize));\r\nlbmStartIO(bp);\r\n}\r\nstatic void lbmStartIO(struct lbuf * bp)\r\n{\r\nstruct bio *bio;\r\nstruct jfs_log *log = bp->l_log;\r\njfs_info("lbmStartIO\n");\r\nbio = bio_alloc(GFP_NOFS, 1);\r\nbio->bi_iter.bi_sector = bp->l_blkno << (log->l2bsize - 9);\r\nbio->bi_bdev = log->bdev;\r\nbio->bi_io_vec[0].bv_page = bp->l_page;\r\nbio->bi_io_vec[0].bv_len = LOGPSIZE;\r\nbio->bi_io_vec[0].bv_offset = bp->l_offset;\r\nbio->bi_vcnt = 1;\r\nbio->bi_iter.bi_size = LOGPSIZE;\r\nbio->bi_end_io = lbmIODone;\r\nbio->bi_private = bp;\r\nif (log->no_integrity) {\r\nbio->bi_iter.bi_size = 0;\r\nlbmIODone(bio, 0);\r\n} else {\r\nsubmit_bio(WRITE_SYNC, bio);\r\nINCREMENT(lmStat.submitted);\r\n}\r\n}\r\nstatic int lbmIOWait(struct lbuf * bp, int flag)\r\n{\r\nunsigned long flags;\r\nint rc = 0;\r\njfs_info("lbmIOWait1: bp:0x%p flag:0x%x:0x%x", bp, bp->l_flag, flag);\r\nLCACHE_LOCK(flags);\r\nLCACHE_SLEEP_COND(bp->l_ioevent, (bp->l_flag & lbmDONE), flags);\r\nrc = (bp->l_flag & lbmERROR) ? -EIO : 0;\r\nif (flag & lbmFREE)\r\nlbmfree(bp);\r\nLCACHE_UNLOCK(flags);\r\njfs_info("lbmIOWait2: bp:0x%p flag:0x%x:0x%x", bp, bp->l_flag, flag);\r\nreturn rc;\r\n}\r\nstatic void lbmIODone(struct bio *bio, int error)\r\n{\r\nstruct lbuf *bp = bio->bi_private;\r\nstruct lbuf *nextbp, *tail;\r\nstruct jfs_log *log;\r\nunsigned long flags;\r\njfs_info("lbmIODone: bp:0x%p flag:0x%x", bp, bp->l_flag);\r\nLCACHE_LOCK(flags);\r\nbp->l_flag |= lbmDONE;\r\nif (!test_bit(BIO_UPTODATE, &bio->bi_flags)) {\r\nbp->l_flag |= lbmERROR;\r\njfs_err("lbmIODone: I/O error in JFS log");\r\n}\r\nbio_put(bio);\r\nif (bp->l_flag & lbmREAD) {\r\nbp->l_flag &= ~lbmREAD;\r\nLCACHE_UNLOCK(flags);\r\nLCACHE_WAKEUP(&bp->l_ioevent);\r\nreturn;\r\n}\r\nbp->l_flag &= ~lbmWRITE;\r\nINCREMENT(lmStat.pagedone);\r\nlog = bp->l_log;\r\nlog->clsn = (bp->l_pn << L2LOGPSIZE) + bp->l_ceor;\r\nif (bp->l_flag & lbmDIRECT) {\r\nLCACHE_WAKEUP(&bp->l_ioevent);\r\nLCACHE_UNLOCK(flags);\r\nreturn;\r\n}\r\ntail = log->wqueue;\r\nif (bp == tail) {\r\nif (bp->l_flag & lbmRELEASE) {\r\nlog->wqueue = NULL;\r\nbp->l_wqnext = NULL;\r\n}\r\n}\r\nelse {\r\nif (bp->l_flag & lbmRELEASE) {\r\nnextbp = tail->l_wqnext = bp->l_wqnext;\r\nbp->l_wqnext = NULL;\r\nif (nextbp->l_flag & lbmWRITE) {\r\nlbmRedrive(nextbp);\r\n}\r\n}\r\n}\r\nif (bp->l_flag & lbmSYNC) {\r\nLCACHE_UNLOCK(flags);\r\nLCACHE_WAKEUP(&bp->l_ioevent);\r\n}\r\nelse if (bp->l_flag & lbmGC) {\r\nLCACHE_UNLOCK(flags);\r\nlmPostGC(bp);\r\n}\r\nelse {\r\nassert(bp->l_flag & lbmRELEASE);\r\nassert(bp->l_flag & lbmFREE);\r\nlbmfree(bp);\r\nLCACHE_UNLOCK(flags);\r\n}\r\n}\r\nint jfsIOWait(void *arg)\r\n{\r\nstruct lbuf *bp;\r\ndo {\r\nspin_lock_irq(&log_redrive_lock);\r\nwhile ((bp = log_redrive_list)) {\r\nlog_redrive_list = bp->l_redrive_next;\r\nbp->l_redrive_next = NULL;\r\nspin_unlock_irq(&log_redrive_lock);\r\nlbmStartIO(bp);\r\nspin_lock_irq(&log_redrive_lock);\r\n}\r\nif (freezing(current)) {\r\nspin_unlock_irq(&log_redrive_lock);\r\ntry_to_freeze();\r\n} else {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nspin_unlock_irq(&log_redrive_lock);\r\nschedule();\r\n__set_current_state(TASK_RUNNING);\r\n}\r\n} while (!kthread_should_stop());\r\njfs_info("jfsIOWait being killed!");\r\nreturn 0;\r\n}\r\nint lmLogFormat(struct jfs_log *log, s64 logAddress, int logSize)\r\n{\r\nint rc = -EIO;\r\nstruct jfs_sb_info *sbi;\r\nstruct logsuper *logsuper;\r\nstruct logpage *lp;\r\nint lspn;\r\nstruct lrd *lrd_ptr;\r\nint npages = 0;\r\nstruct lbuf *bp;\r\njfs_info("lmLogFormat: logAddress:%Ld logSize:%d",\r\n(long long)logAddress, logSize);\r\nsbi = list_entry(log->sb_list.next, struct jfs_sb_info, log_list);\r\nbp = lbmAllocate(log, 1);\r\nnpages = logSize >> sbi->l2nbperpage;\r\nlogsuper = (struct logsuper *) bp->l_ldata;\r\nlogsuper->magic = cpu_to_le32(LOGMAGIC);\r\nlogsuper->version = cpu_to_le32(LOGVERSION);\r\nlogsuper->state = cpu_to_le32(LOGREDONE);\r\nlogsuper->flag = cpu_to_le32(sbi->mntflag);\r\nlogsuper->size = cpu_to_le32(npages);\r\nlogsuper->bsize = cpu_to_le32(sbi->bsize);\r\nlogsuper->l2bsize = cpu_to_le32(sbi->l2bsize);\r\nlogsuper->end = cpu_to_le32(2 * LOGPSIZE + LOGPHDRSIZE + LOGRDSIZE);\r\nbp->l_flag = lbmWRITE | lbmSYNC | lbmDIRECT;\r\nbp->l_blkno = logAddress + sbi->nbperpage;\r\nlbmStartIO(bp);\r\nif ((rc = lbmIOWait(bp, 0)))\r\ngoto exit;\r\nlp = (struct logpage *) bp->l_ldata;\r\nlp->h.page = lp->t.page = cpu_to_le32(npages - 3);\r\nlp->h.eor = lp->t.eor = cpu_to_le16(LOGPHDRSIZE + LOGRDSIZE);\r\nlrd_ptr = (struct lrd *) &lp->data;\r\nlrd_ptr->logtid = 0;\r\nlrd_ptr->backchain = 0;\r\nlrd_ptr->type = cpu_to_le16(LOG_SYNCPT);\r\nlrd_ptr->length = 0;\r\nlrd_ptr->log.syncpt.sync = 0;\r\nbp->l_blkno += sbi->nbperpage;\r\nbp->l_flag = lbmWRITE | lbmSYNC | lbmDIRECT;\r\nlbmStartIO(bp);\r\nif ((rc = lbmIOWait(bp, 0)))\r\ngoto exit;\r\nfor (lspn = 0; lspn < npages - 3; lspn++) {\r\nlp->h.page = lp->t.page = cpu_to_le32(lspn);\r\nlp->h.eor = lp->t.eor = cpu_to_le16(LOGPHDRSIZE);\r\nbp->l_blkno += sbi->nbperpage;\r\nbp->l_flag = lbmWRITE | lbmSYNC | lbmDIRECT;\r\nlbmStartIO(bp);\r\nif ((rc = lbmIOWait(bp, 0)))\r\ngoto exit;\r\n}\r\nrc = 0;\r\nexit:\r\nlbmFree(bp);\r\nreturn rc;\r\n}\r\nstatic int jfs_lmstats_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m,\r\n"JFS Logmgr stats\n"\r\n"================\n"\r\n"commits = %d\n"\r\n"writes submitted = %d\n"\r\n"writes completed = %d\n"\r\n"full pages submitted = %d\n"\r\n"partial pages submitted = %d\n",\r\nlmStat.commit,\r\nlmStat.submitted,\r\nlmStat.pagedone,\r\nlmStat.full_page,\r\nlmStat.partial_page);\r\nreturn 0;\r\n}\r\nstatic int jfs_lmstats_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, jfs_lmstats_proc_show, NULL);\r\n}
