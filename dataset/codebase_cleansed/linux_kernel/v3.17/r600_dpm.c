void r600_dpm_print_class_info(u32 class, u32 class2)\r\n{\r\nprintk("\tui class: ");\r\nswitch (class & ATOM_PPLIB_CLASSIFICATION_UI_MASK) {\r\ncase ATOM_PPLIB_CLASSIFICATION_UI_NONE:\r\ndefault:\r\nprintk("none\n");\r\nbreak;\r\ncase ATOM_PPLIB_CLASSIFICATION_UI_BATTERY:\r\nprintk("battery\n");\r\nbreak;\r\ncase ATOM_PPLIB_CLASSIFICATION_UI_BALANCED:\r\nprintk("balanced\n");\r\nbreak;\r\ncase ATOM_PPLIB_CLASSIFICATION_UI_PERFORMANCE:\r\nprintk("performance\n");\r\nbreak;\r\n}\r\nprintk("\tinternal class: ");\r\nif (((class & ~ATOM_PPLIB_CLASSIFICATION_UI_MASK) == 0) &&\r\n(class2 == 0))\r\nprintk("none");\r\nelse {\r\nif (class & ATOM_PPLIB_CLASSIFICATION_BOOT)\r\nprintk("boot ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_THERMAL)\r\nprintk("thermal ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_LIMITEDPOWERSOURCE)\r\nprintk("limited_pwr ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_REST)\r\nprintk("rest ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_FORCED)\r\nprintk("forced ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_3DPERFORMANCE)\r\nprintk("3d_perf ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_OVERDRIVETEMPLATE)\r\nprintk("ovrdrv ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\r\nprintk("uvd ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_3DLOW)\r\nprintk("3d_low ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_ACPI)\r\nprintk("acpi ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_HD2STATE)\r\nprintk("uvd_hd2 ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_HDSTATE)\r\nprintk("uvd_hd ");\r\nif (class & ATOM_PPLIB_CLASSIFICATION_SDSTATE)\r\nprintk("uvd_sd ");\r\nif (class2 & ATOM_PPLIB_CLASSIFICATION2_LIMITEDPOWERSOURCE_2)\r\nprintk("limited_pwr2 ");\r\nif (class2 & ATOM_PPLIB_CLASSIFICATION2_ULV)\r\nprintk("ulv ");\r\nif (class2 & ATOM_PPLIB_CLASSIFICATION2_MVC)\r\nprintk("uvd_mvc ");\r\n}\r\nprintk("\n");\r\n}\r\nvoid r600_dpm_print_cap_info(u32 caps)\r\n{\r\nprintk("\tcaps: ");\r\nif (caps & ATOM_PPLIB_SINGLE_DISPLAY_ONLY)\r\nprintk("single_disp ");\r\nif (caps & ATOM_PPLIB_SUPPORTS_VIDEO_PLAYBACK)\r\nprintk("video ");\r\nif (caps & ATOM_PPLIB_DISALLOW_ON_DC)\r\nprintk("no_dc ");\r\nprintk("\n");\r\n}\r\nvoid r600_dpm_print_ps_status(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nprintk("\tstatus: ");\r\nif (rps == rdev->pm.dpm.current_ps)\r\nprintk("c ");\r\nif (rps == rdev->pm.dpm.requested_ps)\r\nprintk("r ");\r\nif (rps == rdev->pm.dpm.boot_ps)\r\nprintk("b ");\r\nprintk("\n");\r\n}\r\nu32 r600_dpm_get_vblank_time(struct radeon_device *rdev)\r\n{\r\nstruct drm_device *dev = rdev->ddev;\r\nstruct drm_crtc *crtc;\r\nstruct radeon_crtc *radeon_crtc;\r\nu32 line_time_us, vblank_lines;\r\nu32 vblank_time_us = 0xffffffff;\r\nif (rdev->num_crtc && rdev->mode_info.mode_config_initialized) {\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nradeon_crtc = to_radeon_crtc(crtc);\r\nif (crtc->enabled && radeon_crtc->enabled && radeon_crtc->hw_mode.clock) {\r\nline_time_us = (radeon_crtc->hw_mode.crtc_htotal * 1000) /\r\nradeon_crtc->hw_mode.clock;\r\nvblank_lines = radeon_crtc->hw_mode.crtc_vblank_end -\r\nradeon_crtc->hw_mode.crtc_vdisplay +\r\n(radeon_crtc->v_border * 2);\r\nvblank_time_us = vblank_lines * line_time_us;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn vblank_time_us;\r\n}\r\nu32 r600_dpm_get_vrefresh(struct radeon_device *rdev)\r\n{\r\nstruct drm_device *dev = rdev->ddev;\r\nstruct drm_crtc *crtc;\r\nstruct radeon_crtc *radeon_crtc;\r\nu32 vrefresh = 0;\r\nif (rdev->num_crtc && rdev->mode_info.mode_config_initialized) {\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nradeon_crtc = to_radeon_crtc(crtc);\r\nif (crtc->enabled && radeon_crtc->enabled && radeon_crtc->hw_mode.clock) {\r\nvrefresh = radeon_crtc->hw_mode.vrefresh;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn vrefresh;\r\n}\r\nvoid r600_calculate_u_and_p(u32 i, u32 r_c, u32 p_b,\r\nu32 *p, u32 *u)\r\n{\r\nu32 b_c = 0;\r\nu32 i_c;\r\nu32 tmp;\r\ni_c = (i * r_c) / 100;\r\ntmp = i_c >> p_b;\r\nwhile (tmp) {\r\nb_c++;\r\ntmp >>= 1;\r\n}\r\n*u = (b_c + 1) / 2;\r\n*p = i_c / (1 << (2 * (*u)));\r\n}\r\nint r600_calculate_at(u32 t, u32 h, u32 fh, u32 fl, u32 *tl, u32 *th)\r\n{\r\nu32 k, a, ah, al;\r\nu32 t1;\r\nif ((fl == 0) || (fh == 0) || (fl > fh))\r\nreturn -EINVAL;\r\nk = (100 * fh) / fl;\r\nt1 = (t * (k - 100));\r\na = (1000 * (100 * h + t1)) / (10000 + (t1 / 100));\r\na = (a + 5) / 10;\r\nah = ((a * t) + 5000) / 10000;\r\nal = a - ah;\r\n*th = t - ah;\r\n*tl = t + al;\r\nreturn 0;\r\n}\r\nvoid r600_gfx_clockgating_enable(struct radeon_device *rdev, bool enable)\r\n{\r\nint i;\r\nif (enable) {\r\nWREG32_P(SCLK_PWRMGT_CNTL, DYN_GFX_CLK_OFF_EN, ~DYN_GFX_CLK_OFF_EN);\r\n} else {\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~DYN_GFX_CLK_OFF_EN);\r\nWREG32(CG_RLC_REQ_AND_RSP, 0x2);\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (((RREG32(CG_RLC_REQ_AND_RSP) & CG_RLC_RSP_TYPE_MASK) >> CG_RLC_RSP_TYPE_SHIFT) == 1)\r\nbreak;\r\nudelay(1);\r\n}\r\nWREG32(CG_RLC_REQ_AND_RSP, 0x0);\r\nWREG32(GRBM_PWR_CNTL, 0x1);\r\nRREG32(GRBM_PWR_CNTL);\r\n}\r\n}\r\nvoid r600_dynamicpm_enable(struct radeon_device *rdev, bool enable)\r\n{\r\nif (enable)\r\nWREG32_P(GENERAL_PWRMGT, GLOBAL_PWRMGT_EN, ~GLOBAL_PWRMGT_EN);\r\nelse\r\nWREG32_P(GENERAL_PWRMGT, 0, ~GLOBAL_PWRMGT_EN);\r\n}\r\nvoid r600_enable_thermal_protection(struct radeon_device *rdev, bool enable)\r\n{\r\nif (enable)\r\nWREG32_P(GENERAL_PWRMGT, 0, ~THERMAL_PROTECTION_DIS);\r\nelse\r\nWREG32_P(GENERAL_PWRMGT, THERMAL_PROTECTION_DIS, ~THERMAL_PROTECTION_DIS);\r\n}\r\nvoid r600_enable_acpi_pm(struct radeon_device *rdev)\r\n{\r\nWREG32_P(GENERAL_PWRMGT, STATIC_PM_EN, ~STATIC_PM_EN);\r\n}\r\nvoid r600_enable_dynamic_pcie_gen2(struct radeon_device *rdev, bool enable)\r\n{\r\nif (enable)\r\nWREG32_P(GENERAL_PWRMGT, ENABLE_GEN2PCIE, ~ENABLE_GEN2PCIE);\r\nelse\r\nWREG32_P(GENERAL_PWRMGT, 0, ~ENABLE_GEN2PCIE);\r\n}\r\nbool r600_dynamicpm_enabled(struct radeon_device *rdev)\r\n{\r\nif (RREG32(GENERAL_PWRMGT) & GLOBAL_PWRMGT_EN)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nvoid r600_enable_sclk_control(struct radeon_device *rdev, bool enable)\r\n{\r\nif (enable)\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~SCLK_PWRMGT_OFF);\r\nelse\r\nWREG32_P(SCLK_PWRMGT_CNTL, SCLK_PWRMGT_OFF, ~SCLK_PWRMGT_OFF);\r\n}\r\nvoid r600_enable_mclk_control(struct radeon_device *rdev, bool enable)\r\n{\r\nif (enable)\r\nWREG32_P(MCLK_PWRMGT_CNTL, 0, ~MPLL_PWRMGT_OFF);\r\nelse\r\nWREG32_P(MCLK_PWRMGT_CNTL, MPLL_PWRMGT_OFF, ~MPLL_PWRMGT_OFF);\r\n}\r\nvoid r600_enable_spll_bypass(struct radeon_device *rdev, bool enable)\r\n{\r\nif (enable)\r\nWREG32_P(CG_SPLL_FUNC_CNTL, SPLL_BYPASS_EN, ~SPLL_BYPASS_EN);\r\nelse\r\nWREG32_P(CG_SPLL_FUNC_CNTL, 0, ~SPLL_BYPASS_EN);\r\n}\r\nvoid r600_wait_for_spll_change(struct radeon_device *rdev)\r\n{\r\nint i;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (RREG32(CG_SPLL_FUNC_CNTL) & SPLL_CHG_STATUS)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\nvoid r600_set_bsp(struct radeon_device *rdev, u32 u, u32 p)\r\n{\r\nWREG32(CG_BSP, BSP(p) | BSU(u));\r\n}\r\nvoid r600_set_at(struct radeon_device *rdev,\r\nu32 l_to_m, u32 m_to_h,\r\nu32 h_to_m, u32 m_to_l)\r\n{\r\nWREG32(CG_RT, FLS(l_to_m) | FMS(m_to_h));\r\nWREG32(CG_LT, FHS(h_to_m) | FMS(m_to_l));\r\n}\r\nvoid r600_set_tc(struct radeon_device *rdev,\r\nu32 index, u32 u_t, u32 d_t)\r\n{\r\nWREG32(CG_FFCT_0 + (index * 4), UTC_0(u_t) | DTC_0(d_t));\r\n}\r\nvoid r600_select_td(struct radeon_device *rdev,\r\nenum r600_td td)\r\n{\r\nif (td == R600_TD_AUTO)\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~FIR_FORCE_TREND_SEL);\r\nelse\r\nWREG32_P(SCLK_PWRMGT_CNTL, FIR_FORCE_TREND_SEL, ~FIR_FORCE_TREND_SEL);\r\nif (td == R600_TD_UP)\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~FIR_TREND_MODE);\r\nif (td == R600_TD_DOWN)\r\nWREG32_P(SCLK_PWRMGT_CNTL, FIR_TREND_MODE, ~FIR_TREND_MODE);\r\n}\r\nvoid r600_set_vrc(struct radeon_device *rdev, u32 vrv)\r\n{\r\nWREG32(CG_FTV, vrv);\r\n}\r\nvoid r600_set_tpu(struct radeon_device *rdev, u32 u)\r\n{\r\nWREG32_P(CG_TPC, TPU(u), ~TPU_MASK);\r\n}\r\nvoid r600_set_tpc(struct radeon_device *rdev, u32 c)\r\n{\r\nWREG32_P(CG_TPC, TPCC(c), ~TPCC_MASK);\r\n}\r\nvoid r600_set_sstu(struct radeon_device *rdev, u32 u)\r\n{\r\nWREG32_P(CG_SSP, CG_SSTU(u), ~CG_SSTU_MASK);\r\n}\r\nvoid r600_set_sst(struct radeon_device *rdev, u32 t)\r\n{\r\nWREG32_P(CG_SSP, CG_SST(t), ~CG_SST_MASK);\r\n}\r\nvoid r600_set_git(struct radeon_device *rdev, u32 t)\r\n{\r\nWREG32_P(CG_GIT, CG_GICST(t), ~CG_GICST_MASK);\r\n}\r\nvoid r600_set_fctu(struct radeon_device *rdev, u32 u)\r\n{\r\nWREG32_P(CG_FC_T, FC_TU(u), ~FC_TU_MASK);\r\n}\r\nvoid r600_set_fct(struct radeon_device *rdev, u32 t)\r\n{\r\nWREG32_P(CG_FC_T, FC_T(t), ~FC_T_MASK);\r\n}\r\nvoid r600_set_ctxcgtt3d_rphc(struct radeon_device *rdev, u32 p)\r\n{\r\nWREG32_P(CG_CTX_CGTT3D_R, PHC(p), ~PHC_MASK);\r\n}\r\nvoid r600_set_ctxcgtt3d_rsdc(struct radeon_device *rdev, u32 s)\r\n{\r\nWREG32_P(CG_CTX_CGTT3D_R, SDC(s), ~SDC_MASK);\r\n}\r\nvoid r600_set_vddc3d_oorsu(struct radeon_device *rdev, u32 u)\r\n{\r\nWREG32_P(CG_VDDC3D_OOR, SU(u), ~SU_MASK);\r\n}\r\nvoid r600_set_vddc3d_oorphc(struct radeon_device *rdev, u32 p)\r\n{\r\nWREG32_P(CG_VDDC3D_OOR, PHC(p), ~PHC_MASK);\r\n}\r\nvoid r600_set_vddc3d_oorsdc(struct radeon_device *rdev, u32 s)\r\n{\r\nWREG32_P(CG_VDDC3D_OOR, SDC(s), ~SDC_MASK);\r\n}\r\nvoid r600_set_mpll_lock_time(struct radeon_device *rdev, u32 lock_time)\r\n{\r\nWREG32_P(MPLL_TIME, MPLL_LOCK_TIME(lock_time), ~MPLL_LOCK_TIME_MASK);\r\n}\r\nvoid r600_set_mpll_reset_time(struct radeon_device *rdev, u32 reset_time)\r\n{\r\nWREG32_P(MPLL_TIME, MPLL_RESET_TIME(reset_time), ~MPLL_RESET_TIME_MASK);\r\n}\r\nvoid r600_engine_clock_entry_enable(struct radeon_device *rdev,\r\nu32 index, bool enable)\r\n{\r\nif (enable)\r\nWREG32_P(SCLK_FREQ_SETTING_STEP_0_PART2 + (index * 4 * 2),\r\nSTEP_0_SPLL_ENTRY_VALID, ~STEP_0_SPLL_ENTRY_VALID);\r\nelse\r\nWREG32_P(SCLK_FREQ_SETTING_STEP_0_PART2 + (index * 4 * 2),\r\n0, ~STEP_0_SPLL_ENTRY_VALID);\r\n}\r\nvoid r600_engine_clock_entry_enable_pulse_skipping(struct radeon_device *rdev,\r\nu32 index, bool enable)\r\n{\r\nif (enable)\r\nWREG32_P(SCLK_FREQ_SETTING_STEP_0_PART2 + (index * 4 * 2),\r\nSTEP_0_SPLL_STEP_ENABLE, ~STEP_0_SPLL_STEP_ENABLE);\r\nelse\r\nWREG32_P(SCLK_FREQ_SETTING_STEP_0_PART2 + (index * 4 * 2),\r\n0, ~STEP_0_SPLL_STEP_ENABLE);\r\n}\r\nvoid r600_engine_clock_entry_enable_post_divider(struct radeon_device *rdev,\r\nu32 index, bool enable)\r\n{\r\nif (enable)\r\nWREG32_P(SCLK_FREQ_SETTING_STEP_0_PART2 + (index * 4 * 2),\r\nSTEP_0_POST_DIV_EN, ~STEP_0_POST_DIV_EN);\r\nelse\r\nWREG32_P(SCLK_FREQ_SETTING_STEP_0_PART2 + (index * 4 * 2),\r\n0, ~STEP_0_POST_DIV_EN);\r\n}\r\nvoid r600_engine_clock_entry_set_post_divider(struct radeon_device *rdev,\r\nu32 index, u32 divider)\r\n{\r\nWREG32_P(SCLK_FREQ_SETTING_STEP_0_PART1 + (index * 4 * 2),\r\nSTEP_0_SPLL_POST_DIV(divider), ~STEP_0_SPLL_POST_DIV_MASK);\r\n}\r\nvoid r600_engine_clock_entry_set_reference_divider(struct radeon_device *rdev,\r\nu32 index, u32 divider)\r\n{\r\nWREG32_P(SCLK_FREQ_SETTING_STEP_0_PART1 + (index * 4 * 2),\r\nSTEP_0_SPLL_REF_DIV(divider), ~STEP_0_SPLL_REF_DIV_MASK);\r\n}\r\nvoid r600_engine_clock_entry_set_feedback_divider(struct radeon_device *rdev,\r\nu32 index, u32 divider)\r\n{\r\nWREG32_P(SCLK_FREQ_SETTING_STEP_0_PART1 + (index * 4 * 2),\r\nSTEP_0_SPLL_FB_DIV(divider), ~STEP_0_SPLL_FB_DIV_MASK);\r\n}\r\nvoid r600_engine_clock_entry_set_step_time(struct radeon_device *rdev,\r\nu32 index, u32 step_time)\r\n{\r\nWREG32_P(SCLK_FREQ_SETTING_STEP_0_PART1 + (index * 4 * 2),\r\nSTEP_0_SPLL_STEP_TIME(step_time), ~STEP_0_SPLL_STEP_TIME_MASK);\r\n}\r\nvoid r600_vid_rt_set_ssu(struct radeon_device *rdev, u32 u)\r\n{\r\nWREG32_P(VID_RT, SSTU(u), ~SSTU_MASK);\r\n}\r\nvoid r600_vid_rt_set_vru(struct radeon_device *rdev, u32 u)\r\n{\r\nWREG32_P(VID_RT, VID_CRTU(u), ~VID_CRTU_MASK);\r\n}\r\nvoid r600_vid_rt_set_vrt(struct radeon_device *rdev, u32 rt)\r\n{\r\nWREG32_P(VID_RT, VID_CRT(rt), ~VID_CRT_MASK);\r\n}\r\nvoid r600_voltage_control_enable_pins(struct radeon_device *rdev,\r\nu64 mask)\r\n{\r\nWREG32(LOWER_GPIO_ENABLE, mask & 0xffffffff);\r\nWREG32(UPPER_GPIO_ENABLE, upper_32_bits(mask));\r\n}\r\nvoid r600_voltage_control_program_voltages(struct radeon_device *rdev,\r\nenum r600_power_level index, u64 pins)\r\n{\r\nu32 tmp, mask;\r\nu32 ix = 3 - (3 & index);\r\nWREG32(CTXSW_VID_LOWER_GPIO_CNTL + (ix * 4), pins & 0xffffffff);\r\nmask = 7 << (3 * ix);\r\ntmp = RREG32(VID_UPPER_GPIO_CNTL);\r\ntmp = (tmp & ~mask) | ((pins >> (32 - (3 * ix))) & mask);\r\nWREG32(VID_UPPER_GPIO_CNTL, tmp);\r\n}\r\nvoid r600_voltage_control_deactivate_static_control(struct radeon_device *rdev,\r\nu64 mask)\r\n{\r\nu32 gpio;\r\ngpio = RREG32(GPIOPAD_MASK);\r\ngpio &= ~mask;\r\nWREG32(GPIOPAD_MASK, gpio);\r\ngpio = RREG32(GPIOPAD_EN);\r\ngpio &= ~mask;\r\nWREG32(GPIOPAD_EN, gpio);\r\ngpio = RREG32(GPIOPAD_A);\r\ngpio &= ~mask;\r\nWREG32(GPIOPAD_A, gpio);\r\n}\r\nvoid r600_power_level_enable(struct radeon_device *rdev,\r\nenum r600_power_level index, bool enable)\r\n{\r\nu32 ix = 3 - (3 & index);\r\nif (enable)\r\nWREG32_P(CTXSW_PROFILE_INDEX + (ix * 4), CTXSW_FREQ_STATE_ENABLE,\r\n~CTXSW_FREQ_STATE_ENABLE);\r\nelse\r\nWREG32_P(CTXSW_PROFILE_INDEX + (ix * 4), 0,\r\n~CTXSW_FREQ_STATE_ENABLE);\r\n}\r\nvoid r600_power_level_set_voltage_index(struct radeon_device *rdev,\r\nenum r600_power_level index, u32 voltage_index)\r\n{\r\nu32 ix = 3 - (3 & index);\r\nWREG32_P(CTXSW_PROFILE_INDEX + (ix * 4),\r\nCTXSW_FREQ_VIDS_CFG_INDEX(voltage_index), ~CTXSW_FREQ_VIDS_CFG_INDEX_MASK);\r\n}\r\nvoid r600_power_level_set_mem_clock_index(struct radeon_device *rdev,\r\nenum r600_power_level index, u32 mem_clock_index)\r\n{\r\nu32 ix = 3 - (3 & index);\r\nWREG32_P(CTXSW_PROFILE_INDEX + (ix * 4),\r\nCTXSW_FREQ_MCLK_CFG_INDEX(mem_clock_index), ~CTXSW_FREQ_MCLK_CFG_INDEX_MASK);\r\n}\r\nvoid r600_power_level_set_eng_clock_index(struct radeon_device *rdev,\r\nenum r600_power_level index, u32 eng_clock_index)\r\n{\r\nu32 ix = 3 - (3 & index);\r\nWREG32_P(CTXSW_PROFILE_INDEX + (ix * 4),\r\nCTXSW_FREQ_SCLK_CFG_INDEX(eng_clock_index), ~CTXSW_FREQ_SCLK_CFG_INDEX_MASK);\r\n}\r\nvoid r600_power_level_set_watermark_id(struct radeon_device *rdev,\r\nenum r600_power_level index,\r\nenum r600_display_watermark watermark_id)\r\n{\r\nu32 ix = 3 - (3 & index);\r\nu32 tmp = 0;\r\nif (watermark_id == R600_DISPLAY_WATERMARK_HIGH)\r\ntmp = CTXSW_FREQ_DISPLAY_WATERMARK;\r\nWREG32_P(CTXSW_PROFILE_INDEX + (ix * 4), tmp, ~CTXSW_FREQ_DISPLAY_WATERMARK);\r\n}\r\nvoid r600_power_level_set_pcie_gen2(struct radeon_device *rdev,\r\nenum r600_power_level index, bool compatible)\r\n{\r\nu32 ix = 3 - (3 & index);\r\nu32 tmp = 0;\r\nif (compatible)\r\ntmp = CTXSW_FREQ_GEN2PCIE_VOLT;\r\nWREG32_P(CTXSW_PROFILE_INDEX + (ix * 4), tmp, ~CTXSW_FREQ_GEN2PCIE_VOLT);\r\n}\r\nenum r600_power_level r600_power_level_get_current_index(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\ntmp = RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_PROFILE_INDEX_MASK;\r\ntmp >>= CURRENT_PROFILE_INDEX_SHIFT;\r\nreturn tmp;\r\n}\r\nenum r600_power_level r600_power_level_get_target_index(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\ntmp = RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & TARGET_PROFILE_INDEX_MASK;\r\ntmp >>= TARGET_PROFILE_INDEX_SHIFT;\r\nreturn tmp;\r\n}\r\nvoid r600_power_level_set_enter_index(struct radeon_device *rdev,\r\nenum r600_power_level index)\r\n{\r\nWREG32_P(TARGET_AND_CURRENT_PROFILE_INDEX, DYN_PWR_ENTER_INDEX(index),\r\n~DYN_PWR_ENTER_INDEX_MASK);\r\n}\r\nvoid r600_wait_for_power_level_unequal(struct radeon_device *rdev,\r\nenum r600_power_level index)\r\n{\r\nint i;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (r600_power_level_get_target_index(rdev) != index)\r\nbreak;\r\nudelay(1);\r\n}\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (r600_power_level_get_current_index(rdev) != index)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\nvoid r600_wait_for_power_level(struct radeon_device *rdev,\r\nenum r600_power_level index)\r\n{\r\nint i;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (r600_power_level_get_target_index(rdev) == index)\r\nbreak;\r\nudelay(1);\r\n}\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (r600_power_level_get_current_index(rdev) == index)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\nvoid r600_start_dpm(struct radeon_device *rdev)\r\n{\r\nr600_enable_sclk_control(rdev, false);\r\nr600_enable_mclk_control(rdev, false);\r\nr600_dynamicpm_enable(rdev, true);\r\nradeon_wait_for_vblank(rdev, 0);\r\nradeon_wait_for_vblank(rdev, 1);\r\nr600_enable_spll_bypass(rdev, true);\r\nr600_wait_for_spll_change(rdev);\r\nr600_enable_spll_bypass(rdev, false);\r\nr600_wait_for_spll_change(rdev);\r\nr600_enable_spll_bypass(rdev, true);\r\nr600_wait_for_spll_change(rdev);\r\nr600_enable_spll_bypass(rdev, false);\r\nr600_wait_for_spll_change(rdev);\r\nr600_enable_sclk_control(rdev, true);\r\nr600_enable_mclk_control(rdev, true);\r\n}\r\nvoid r600_stop_dpm(struct radeon_device *rdev)\r\n{\r\nr600_dynamicpm_enable(rdev, false);\r\n}\r\nint r600_dpm_pre_set_power_state(struct radeon_device *rdev)\r\n{\r\nreturn 0;\r\n}\r\nvoid r600_dpm_post_set_power_state(struct radeon_device *rdev)\r\n{\r\n}\r\nbool r600_is_uvd_state(u32 class, u32 class2)\r\n{\r\nif (class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\r\nreturn true;\r\nif (class & ATOM_PPLIB_CLASSIFICATION_HD2STATE)\r\nreturn true;\r\nif (class & ATOM_PPLIB_CLASSIFICATION_HDSTATE)\r\nreturn true;\r\nif (class & ATOM_PPLIB_CLASSIFICATION_SDSTATE)\r\nreturn true;\r\nif (class2 & ATOM_PPLIB_CLASSIFICATION2_MVC)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int r600_set_thermal_temperature_range(struct radeon_device *rdev,\r\nint min_temp, int max_temp)\r\n{\r\nint low_temp = 0 * 1000;\r\nint high_temp = 255 * 1000;\r\nif (low_temp < min_temp)\r\nlow_temp = min_temp;\r\nif (high_temp > max_temp)\r\nhigh_temp = max_temp;\r\nif (high_temp < low_temp) {\r\nDRM_ERROR("invalid thermal range: %d - %d\n", low_temp, high_temp);\r\nreturn -EINVAL;\r\n}\r\nWREG32_P(CG_THERMAL_INT, DIG_THERM_INTH(high_temp / 1000), ~DIG_THERM_INTH_MASK);\r\nWREG32_P(CG_THERMAL_INT, DIG_THERM_INTL(low_temp / 1000), ~DIG_THERM_INTL_MASK);\r\nWREG32_P(CG_THERMAL_CTRL, DIG_THERM_DPM(high_temp / 1000), ~DIG_THERM_DPM_MASK);\r\nrdev->pm.dpm.thermal.min_temp = low_temp;\r\nrdev->pm.dpm.thermal.max_temp = high_temp;\r\nreturn 0;\r\n}\r\nbool r600_is_internal_thermal_sensor(enum radeon_int_thermal_type sensor)\r\n{\r\nswitch (sensor) {\r\ncase THERMAL_TYPE_RV6XX:\r\ncase THERMAL_TYPE_RV770:\r\ncase THERMAL_TYPE_EVERGREEN:\r\ncase THERMAL_TYPE_SUMO:\r\ncase THERMAL_TYPE_NI:\r\ncase THERMAL_TYPE_SI:\r\ncase THERMAL_TYPE_CI:\r\ncase THERMAL_TYPE_KV:\r\nreturn true;\r\ncase THERMAL_TYPE_ADT7473_WITH_INTERNAL:\r\ncase THERMAL_TYPE_EMC2103_WITH_INTERNAL:\r\nreturn false;\r\ncase THERMAL_TYPE_NONE:\r\ncase THERMAL_TYPE_EXTERNAL:\r\ncase THERMAL_TYPE_EXTERNAL_GPIO:\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nint r600_dpm_late_enable(struct radeon_device *rdev)\r\n{\r\nint ret;\r\nif (rdev->irq.installed &&\r\nr600_is_internal_thermal_sensor(rdev->pm.int_thermal_type)) {\r\nret = r600_set_thermal_temperature_range(rdev, R600_TEMP_RANGE_MIN, R600_TEMP_RANGE_MAX);\r\nif (ret)\r\nreturn ret;\r\nrdev->irq.dpm_thermal = true;\r\nradeon_irq_set(rdev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int r600_parse_clk_voltage_dep_table(struct radeon_clock_voltage_dependency_table *radeon_table,\r\nATOM_PPLIB_Clock_Voltage_Dependency_Table *atom_table)\r\n{\r\nu32 size = atom_table->ucNumEntries *\r\nsizeof(struct radeon_clock_voltage_dependency_entry);\r\nint i;\r\nATOM_PPLIB_Clock_Voltage_Dependency_Record *entry;\r\nradeon_table->entries = kzalloc(size, GFP_KERNEL);\r\nif (!radeon_table->entries)\r\nreturn -ENOMEM;\r\nentry = &atom_table->entries[0];\r\nfor (i = 0; i < atom_table->ucNumEntries; i++) {\r\nradeon_table->entries[i].clk = le16_to_cpu(entry->usClockLow) |\r\n(entry->ucClockHigh << 16);\r\nradeon_table->entries[i].v = le16_to_cpu(entry->usVoltage);\r\nentry = (ATOM_PPLIB_Clock_Voltage_Dependency_Record *)\r\n((u8 *)entry + sizeof(ATOM_PPLIB_Clock_Voltage_Dependency_Record));\r\n}\r\nradeon_table->count = atom_table->ucNumEntries;\r\nreturn 0;\r\n}\r\nint r600_get_platform_caps(struct radeon_device *rdev)\r\n{\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nunion power_info *power_info;\r\nint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\r\nu16 data_offset;\r\nu8 frev, crev;\r\nif (!atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset))\r\nreturn -EINVAL;\r\npower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\r\nrdev->pm.dpm.platform_caps = le32_to_cpu(power_info->pplib.ulPlatformCaps);\r\nrdev->pm.dpm.backbias_response_time = le16_to_cpu(power_info->pplib.usBackbiasTime);\r\nrdev->pm.dpm.voltage_response_time = le16_to_cpu(power_info->pplib.usVoltageTime);\r\nreturn 0;\r\n}\r\nint r600_parse_extended_power_table(struct radeon_device *rdev)\r\n{\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nunion power_info *power_info;\r\nunion fan_info *fan_info;\r\nATOM_PPLIB_Clock_Voltage_Dependency_Table *dep_table;\r\nint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\r\nu16 data_offset;\r\nu8 frev, crev;\r\nint ret, i;\r\nif (!atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset))\r\nreturn -EINVAL;\r\npower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\r\nif (le16_to_cpu(power_info->pplib.usTableSize) >=\r\nsizeof(struct _ATOM_PPLIB_POWERPLAYTABLE3)) {\r\nif (power_info->pplib3.usFanTableOffset) {\r\nfan_info = (union fan_info *)(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib3.usFanTableOffset));\r\nrdev->pm.dpm.fan.t_hyst = fan_info->fan.ucTHyst;\r\nrdev->pm.dpm.fan.t_min = le16_to_cpu(fan_info->fan.usTMin);\r\nrdev->pm.dpm.fan.t_med = le16_to_cpu(fan_info->fan.usTMed);\r\nrdev->pm.dpm.fan.t_high = le16_to_cpu(fan_info->fan.usTHigh);\r\nrdev->pm.dpm.fan.pwm_min = le16_to_cpu(fan_info->fan.usPWMMin);\r\nrdev->pm.dpm.fan.pwm_med = le16_to_cpu(fan_info->fan.usPWMMed);\r\nrdev->pm.dpm.fan.pwm_high = le16_to_cpu(fan_info->fan.usPWMHigh);\r\nif (fan_info->fan.ucFanTableFormat >= 2)\r\nrdev->pm.dpm.fan.t_max = le16_to_cpu(fan_info->fan2.usTMax);\r\nelse\r\nrdev->pm.dpm.fan.t_max = 10900;\r\nrdev->pm.dpm.fan.cycle_delay = 100000;\r\nrdev->pm.dpm.fan.ucode_fan_control = true;\r\n}\r\n}\r\nif (le16_to_cpu(power_info->pplib.usTableSize) >=\r\nsizeof(struct _ATOM_PPLIB_POWERPLAYTABLE4)) {\r\nif (power_info->pplib4.usVddcDependencyOnSCLKOffset) {\r\ndep_table = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib4.usVddcDependencyOnSCLKOffset));\r\nret = r600_parse_clk_voltage_dep_table(&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk,\r\ndep_table);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (power_info->pplib4.usVddciDependencyOnMCLKOffset) {\r\ndep_table = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib4.usVddciDependencyOnMCLKOffset));\r\nret = r600_parse_clk_voltage_dep_table(&rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk,\r\ndep_table);\r\nif (ret) {\r\nkfree(rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries);\r\nreturn ret;\r\n}\r\n}\r\nif (power_info->pplib4.usVddcDependencyOnMCLKOffset) {\r\ndep_table = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib4.usVddcDependencyOnMCLKOffset));\r\nret = r600_parse_clk_voltage_dep_table(&rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk,\r\ndep_table);\r\nif (ret) {\r\nkfree(rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries);\r\nkfree(rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk.entries);\r\nreturn ret;\r\n}\r\n}\r\nif (power_info->pplib4.usMvddDependencyOnMCLKOffset) {\r\ndep_table = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib4.usMvddDependencyOnMCLKOffset));\r\nret = r600_parse_clk_voltage_dep_table(&rdev->pm.dpm.dyn_state.mvdd_dependency_on_mclk,\r\ndep_table);\r\nif (ret) {\r\nkfree(rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries);\r\nkfree(rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk.entries);\r\nkfree(rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk.entries);\r\nreturn ret;\r\n}\r\n}\r\nif (power_info->pplib4.usMaxClockVoltageOnDCOffset) {\r\nATOM_PPLIB_Clock_Voltage_Limit_Table *clk_v =\r\n(ATOM_PPLIB_Clock_Voltage_Limit_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib4.usMaxClockVoltageOnDCOffset));\r\nif (clk_v->ucNumEntries) {\r\nrdev->pm.dpm.dyn_state.max_clock_voltage_on_dc.sclk =\r\nle16_to_cpu(clk_v->entries[0].usSclkLow) |\r\n(clk_v->entries[0].ucSclkHigh << 16);\r\nrdev->pm.dpm.dyn_state.max_clock_voltage_on_dc.mclk =\r\nle16_to_cpu(clk_v->entries[0].usMclkLow) |\r\n(clk_v->entries[0].ucMclkHigh << 16);\r\nrdev->pm.dpm.dyn_state.max_clock_voltage_on_dc.vddc =\r\nle16_to_cpu(clk_v->entries[0].usVddc);\r\nrdev->pm.dpm.dyn_state.max_clock_voltage_on_dc.vddci =\r\nle16_to_cpu(clk_v->entries[0].usVddci);\r\n}\r\n}\r\nif (power_info->pplib4.usVddcPhaseShedLimitsTableOffset) {\r\nATOM_PPLIB_PhaseSheddingLimits_Table *psl =\r\n(ATOM_PPLIB_PhaseSheddingLimits_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib4.usVddcPhaseShedLimitsTableOffset));\r\nATOM_PPLIB_PhaseSheddingLimits_Record *entry;\r\nrdev->pm.dpm.dyn_state.phase_shedding_limits_table.entries =\r\nkzalloc(psl->ucNumEntries *\r\nsizeof(struct radeon_phase_shedding_limits_entry),\r\nGFP_KERNEL);\r\nif (!rdev->pm.dpm.dyn_state.phase_shedding_limits_table.entries) {\r\nr600_free_extended_power_table(rdev);\r\nreturn -ENOMEM;\r\n}\r\nentry = &psl->entries[0];\r\nfor (i = 0; i < psl->ucNumEntries; i++) {\r\nrdev->pm.dpm.dyn_state.phase_shedding_limits_table.entries[i].sclk =\r\nle16_to_cpu(entry->usSclkLow) | (entry->ucSclkHigh << 16);\r\nrdev->pm.dpm.dyn_state.phase_shedding_limits_table.entries[i].mclk =\r\nle16_to_cpu(entry->usMclkLow) | (entry->ucMclkHigh << 16);\r\nrdev->pm.dpm.dyn_state.phase_shedding_limits_table.entries[i].voltage =\r\nle16_to_cpu(entry->usVoltage);\r\nentry = (ATOM_PPLIB_PhaseSheddingLimits_Record *)\r\n((u8 *)entry + sizeof(ATOM_PPLIB_PhaseSheddingLimits_Record));\r\n}\r\nrdev->pm.dpm.dyn_state.phase_shedding_limits_table.count =\r\npsl->ucNumEntries;\r\n}\r\n}\r\nif (le16_to_cpu(power_info->pplib.usTableSize) >=\r\nsizeof(struct _ATOM_PPLIB_POWERPLAYTABLE5)) {\r\nrdev->pm.dpm.tdp_limit = le32_to_cpu(power_info->pplib5.ulTDPLimit);\r\nrdev->pm.dpm.near_tdp_limit = le32_to_cpu(power_info->pplib5.ulNearTDPLimit);\r\nrdev->pm.dpm.near_tdp_limit_adjusted = rdev->pm.dpm.near_tdp_limit;\r\nrdev->pm.dpm.tdp_od_limit = le16_to_cpu(power_info->pplib5.usTDPODLimit);\r\nif (rdev->pm.dpm.tdp_od_limit)\r\nrdev->pm.dpm.power_control = true;\r\nelse\r\nrdev->pm.dpm.power_control = false;\r\nrdev->pm.dpm.tdp_adjustment = 0;\r\nrdev->pm.dpm.sq_ramping_threshold = le32_to_cpu(power_info->pplib5.ulSQRampingThreshold);\r\nrdev->pm.dpm.cac_leakage = le32_to_cpu(power_info->pplib5.ulCACLeakage);\r\nrdev->pm.dpm.load_line_slope = le16_to_cpu(power_info->pplib5.usLoadLineSlope);\r\nif (power_info->pplib5.usCACLeakageTableOffset) {\r\nATOM_PPLIB_CAC_Leakage_Table *cac_table =\r\n(ATOM_PPLIB_CAC_Leakage_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib5.usCACLeakageTableOffset));\r\nATOM_PPLIB_CAC_Leakage_Record *entry;\r\nu32 size = cac_table->ucNumEntries * sizeof(struct radeon_cac_leakage_table);\r\nrdev->pm.dpm.dyn_state.cac_leakage_table.entries = kzalloc(size, GFP_KERNEL);\r\nif (!rdev->pm.dpm.dyn_state.cac_leakage_table.entries) {\r\nr600_free_extended_power_table(rdev);\r\nreturn -ENOMEM;\r\n}\r\nentry = &cac_table->entries[0];\r\nfor (i = 0; i < cac_table->ucNumEntries; i++) {\r\nif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_EVV) {\r\nrdev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc1 =\r\nle16_to_cpu(entry->usVddc1);\r\nrdev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc2 =\r\nle16_to_cpu(entry->usVddc2);\r\nrdev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc3 =\r\nle16_to_cpu(entry->usVddc3);\r\n} else {\r\nrdev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc =\r\nle16_to_cpu(entry->usVddc);\r\nrdev->pm.dpm.dyn_state.cac_leakage_table.entries[i].leakage =\r\nle32_to_cpu(entry->ulLeakageValue);\r\n}\r\nentry = (ATOM_PPLIB_CAC_Leakage_Record *)\r\n((u8 *)entry + sizeof(ATOM_PPLIB_CAC_Leakage_Record));\r\n}\r\nrdev->pm.dpm.dyn_state.cac_leakage_table.count = cac_table->ucNumEntries;\r\n}\r\n}\r\nif (le16_to_cpu(power_info->pplib.usTableSize) >=\r\nsizeof(struct _ATOM_PPLIB_POWERPLAYTABLE3)) {\r\nATOM_PPLIB_EXTENDEDHEADER *ext_hdr = (ATOM_PPLIB_EXTENDEDHEADER *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib3.usExtendendedHeaderOffset));\r\nif ((le16_to_cpu(ext_hdr->usSize) >= SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V2) &&\r\next_hdr->usVCETableOffset) {\r\nVCEClockInfoArray *array = (VCEClockInfoArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usVCETableOffset) + 1);\r\nATOM_PPLIB_VCE_Clock_Voltage_Limit_Table *limits =\r\n(ATOM_PPLIB_VCE_Clock_Voltage_Limit_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usVCETableOffset) + 1 +\r\n1 + array->ucNumEntries * sizeof(VCEClockInfo));\r\nATOM_PPLIB_VCE_State_Table *states =\r\n(ATOM_PPLIB_VCE_State_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usVCETableOffset) + 1 +\r\n1 + (array->ucNumEntries * sizeof (VCEClockInfo)) +\r\n1 + (limits->numEntries * sizeof(ATOM_PPLIB_VCE_Clock_Voltage_Limit_Record)));\r\nATOM_PPLIB_VCE_Clock_Voltage_Limit_Record *entry;\r\nATOM_PPLIB_VCE_State_Record *state_entry;\r\nVCEClockInfo *vce_clk;\r\nu32 size = limits->numEntries *\r\nsizeof(struct radeon_vce_clock_voltage_dependency_entry);\r\nrdev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries =\r\nkzalloc(size, GFP_KERNEL);\r\nif (!rdev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries) {\r\nr600_free_extended_power_table(rdev);\r\nreturn -ENOMEM;\r\n}\r\nrdev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.count =\r\nlimits->numEntries;\r\nentry = &limits->entries[0];\r\nstate_entry = &states->entries[0];\r\nfor (i = 0; i < limits->numEntries; i++) {\r\nvce_clk = (VCEClockInfo *)\r\n((u8 *)&array->entries[0] +\r\n(entry->ucVCEClockInfoIndex * sizeof(VCEClockInfo)));\r\nrdev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries[i].evclk =\r\nle16_to_cpu(vce_clk->usEVClkLow) | (vce_clk->ucEVClkHigh << 16);\r\nrdev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries[i].ecclk =\r\nle16_to_cpu(vce_clk->usECClkLow) | (vce_clk->ucECClkHigh << 16);\r\nrdev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries[i].v =\r\nle16_to_cpu(entry->usVoltage);\r\nentry = (ATOM_PPLIB_VCE_Clock_Voltage_Limit_Record *)\r\n((u8 *)entry + sizeof(ATOM_PPLIB_VCE_Clock_Voltage_Limit_Record));\r\n}\r\nfor (i = 0; i < states->numEntries; i++) {\r\nif (i >= RADEON_MAX_VCE_LEVELS)\r\nbreak;\r\nvce_clk = (VCEClockInfo *)\r\n((u8 *)&array->entries[0] +\r\n(state_entry->ucVCEClockInfoIndex * sizeof(VCEClockInfo)));\r\nrdev->pm.dpm.vce_states[i].evclk =\r\nle16_to_cpu(vce_clk->usEVClkLow) | (vce_clk->ucEVClkHigh << 16);\r\nrdev->pm.dpm.vce_states[i].ecclk =\r\nle16_to_cpu(vce_clk->usECClkLow) | (vce_clk->ucECClkHigh << 16);\r\nrdev->pm.dpm.vce_states[i].clk_idx =\r\nstate_entry->ucClockInfoIndex & 0x3f;\r\nrdev->pm.dpm.vce_states[i].pstate =\r\n(state_entry->ucClockInfoIndex & 0xc0) >> 6;\r\nstate_entry = (ATOM_PPLIB_VCE_State_Record *)\r\n((u8 *)state_entry + sizeof(ATOM_PPLIB_VCE_State_Record));\r\n}\r\n}\r\nif ((le16_to_cpu(ext_hdr->usSize) >= SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V3) &&\r\next_hdr->usUVDTableOffset) {\r\nUVDClockInfoArray *array = (UVDClockInfoArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usUVDTableOffset) + 1);\r\nATOM_PPLIB_UVD_Clock_Voltage_Limit_Table *limits =\r\n(ATOM_PPLIB_UVD_Clock_Voltage_Limit_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usUVDTableOffset) + 1 +\r\n1 + (array->ucNumEntries * sizeof (UVDClockInfo)));\r\nATOM_PPLIB_UVD_Clock_Voltage_Limit_Record *entry;\r\nu32 size = limits->numEntries *\r\nsizeof(struct radeon_uvd_clock_voltage_dependency_entry);\r\nrdev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries =\r\nkzalloc(size, GFP_KERNEL);\r\nif (!rdev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries) {\r\nr600_free_extended_power_table(rdev);\r\nreturn -ENOMEM;\r\n}\r\nrdev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.count =\r\nlimits->numEntries;\r\nentry = &limits->entries[0];\r\nfor (i = 0; i < limits->numEntries; i++) {\r\nUVDClockInfo *uvd_clk = (UVDClockInfo *)\r\n((u8 *)&array->entries[0] +\r\n(entry->ucUVDClockInfoIndex * sizeof(UVDClockInfo)));\r\nrdev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries[i].vclk =\r\nle16_to_cpu(uvd_clk->usVClkLow) | (uvd_clk->ucVClkHigh << 16);\r\nrdev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries[i].dclk =\r\nle16_to_cpu(uvd_clk->usDClkLow) | (uvd_clk->ucDClkHigh << 16);\r\nrdev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries[i].v =\r\nle16_to_cpu(entry->usVoltage);\r\nentry = (ATOM_PPLIB_UVD_Clock_Voltage_Limit_Record *)\r\n((u8 *)entry + sizeof(ATOM_PPLIB_UVD_Clock_Voltage_Limit_Record));\r\n}\r\n}\r\nif ((le16_to_cpu(ext_hdr->usSize) >= SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V4) &&\r\next_hdr->usSAMUTableOffset) {\r\nATOM_PPLIB_SAMClk_Voltage_Limit_Table *limits =\r\n(ATOM_PPLIB_SAMClk_Voltage_Limit_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usSAMUTableOffset) + 1);\r\nATOM_PPLIB_SAMClk_Voltage_Limit_Record *entry;\r\nu32 size = limits->numEntries *\r\nsizeof(struct radeon_clock_voltage_dependency_entry);\r\nrdev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table.entries =\r\nkzalloc(size, GFP_KERNEL);\r\nif (!rdev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table.entries) {\r\nr600_free_extended_power_table(rdev);\r\nreturn -ENOMEM;\r\n}\r\nrdev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table.count =\r\nlimits->numEntries;\r\nentry = &limits->entries[0];\r\nfor (i = 0; i < limits->numEntries; i++) {\r\nrdev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table.entries[i].clk =\r\nle16_to_cpu(entry->usSAMClockLow) | (entry->ucSAMClockHigh << 16);\r\nrdev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table.entries[i].v =\r\nle16_to_cpu(entry->usVoltage);\r\nentry = (ATOM_PPLIB_SAMClk_Voltage_Limit_Record *)\r\n((u8 *)entry + sizeof(ATOM_PPLIB_SAMClk_Voltage_Limit_Record));\r\n}\r\n}\r\nif ((le16_to_cpu(ext_hdr->usSize) >= SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V5) &&\r\next_hdr->usPPMTableOffset) {\r\nATOM_PPLIB_PPM_Table *ppm = (ATOM_PPLIB_PPM_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usPPMTableOffset));\r\nrdev->pm.dpm.dyn_state.ppm_table =\r\nkzalloc(sizeof(struct radeon_ppm_table), GFP_KERNEL);\r\nif (!rdev->pm.dpm.dyn_state.ppm_table) {\r\nr600_free_extended_power_table(rdev);\r\nreturn -ENOMEM;\r\n}\r\nrdev->pm.dpm.dyn_state.ppm_table->ppm_design = ppm->ucPpmDesign;\r\nrdev->pm.dpm.dyn_state.ppm_table->cpu_core_number =\r\nle16_to_cpu(ppm->usCpuCoreNumber);\r\nrdev->pm.dpm.dyn_state.ppm_table->platform_tdp =\r\nle32_to_cpu(ppm->ulPlatformTDP);\r\nrdev->pm.dpm.dyn_state.ppm_table->small_ac_platform_tdp =\r\nle32_to_cpu(ppm->ulSmallACPlatformTDP);\r\nrdev->pm.dpm.dyn_state.ppm_table->platform_tdc =\r\nle32_to_cpu(ppm->ulPlatformTDC);\r\nrdev->pm.dpm.dyn_state.ppm_table->small_ac_platform_tdc =\r\nle32_to_cpu(ppm->ulSmallACPlatformTDC);\r\nrdev->pm.dpm.dyn_state.ppm_table->apu_tdp =\r\nle32_to_cpu(ppm->ulApuTDP);\r\nrdev->pm.dpm.dyn_state.ppm_table->dgpu_tdp =\r\nle32_to_cpu(ppm->ulDGpuTDP);\r\nrdev->pm.dpm.dyn_state.ppm_table->dgpu_ulv_power =\r\nle32_to_cpu(ppm->ulDGpuUlvPower);\r\nrdev->pm.dpm.dyn_state.ppm_table->tj_max =\r\nle32_to_cpu(ppm->ulTjmax);\r\n}\r\nif ((le16_to_cpu(ext_hdr->usSize) >= SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V6) &&\r\next_hdr->usACPTableOffset) {\r\nATOM_PPLIB_ACPClk_Voltage_Limit_Table *limits =\r\n(ATOM_PPLIB_ACPClk_Voltage_Limit_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usACPTableOffset) + 1);\r\nATOM_PPLIB_ACPClk_Voltage_Limit_Record *entry;\r\nu32 size = limits->numEntries *\r\nsizeof(struct radeon_clock_voltage_dependency_entry);\r\nrdev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table.entries =\r\nkzalloc(size, GFP_KERNEL);\r\nif (!rdev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table.entries) {\r\nr600_free_extended_power_table(rdev);\r\nreturn -ENOMEM;\r\n}\r\nrdev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table.count =\r\nlimits->numEntries;\r\nentry = &limits->entries[0];\r\nfor (i = 0; i < limits->numEntries; i++) {\r\nrdev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table.entries[i].clk =\r\nle16_to_cpu(entry->usACPClockLow) | (entry->ucACPClockHigh << 16);\r\nrdev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table.entries[i].v =\r\nle16_to_cpu(entry->usVoltage);\r\nentry = (ATOM_PPLIB_ACPClk_Voltage_Limit_Record *)\r\n((u8 *)entry + sizeof(ATOM_PPLIB_ACPClk_Voltage_Limit_Record));\r\n}\r\n}\r\nif ((le16_to_cpu(ext_hdr->usSize) >= SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V7) &&\r\next_hdr->usPowerTuneTableOffset) {\r\nu8 rev = *(u8 *)(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usPowerTuneTableOffset));\r\nATOM_PowerTune_Table *pt;\r\nrdev->pm.dpm.dyn_state.cac_tdp_table =\r\nkzalloc(sizeof(struct radeon_cac_tdp_table), GFP_KERNEL);\r\nif (!rdev->pm.dpm.dyn_state.cac_tdp_table) {\r\nr600_free_extended_power_table(rdev);\r\nreturn -ENOMEM;\r\n}\r\nif (rev > 0) {\r\nATOM_PPLIB_POWERTUNE_Table_V1 *ppt = (ATOM_PPLIB_POWERTUNE_Table_V1 *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usPowerTuneTableOffset));\r\nrdev->pm.dpm.dyn_state.cac_tdp_table->maximum_power_delivery_limit =\r\nppt->usMaximumPowerDeliveryLimit;\r\npt = &ppt->power_tune_table;\r\n} else {\r\nATOM_PPLIB_POWERTUNE_Table *ppt = (ATOM_PPLIB_POWERTUNE_Table *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(ext_hdr->usPowerTuneTableOffset));\r\nrdev->pm.dpm.dyn_state.cac_tdp_table->maximum_power_delivery_limit = 255;\r\npt = &ppt->power_tune_table;\r\n}\r\nrdev->pm.dpm.dyn_state.cac_tdp_table->tdp = le16_to_cpu(pt->usTDP);\r\nrdev->pm.dpm.dyn_state.cac_tdp_table->configurable_tdp =\r\nle16_to_cpu(pt->usConfigurableTDP);\r\nrdev->pm.dpm.dyn_state.cac_tdp_table->tdc = le16_to_cpu(pt->usTDC);\r\nrdev->pm.dpm.dyn_state.cac_tdp_table->battery_power_limit =\r\nle16_to_cpu(pt->usBatteryPowerLimit);\r\nrdev->pm.dpm.dyn_state.cac_tdp_table->small_power_limit =\r\nle16_to_cpu(pt->usSmallPowerLimit);\r\nrdev->pm.dpm.dyn_state.cac_tdp_table->low_cac_leakage =\r\nle16_to_cpu(pt->usLowCACLeakage);\r\nrdev->pm.dpm.dyn_state.cac_tdp_table->high_cac_leakage =\r\nle16_to_cpu(pt->usHighCACLeakage);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid r600_free_extended_power_table(struct radeon_device *rdev)\r\n{\r\nstruct radeon_dpm_dynamic_state *dyn_state = &rdev->pm.dpm.dyn_state;\r\nkfree(dyn_state->vddc_dependency_on_sclk.entries);\r\nkfree(dyn_state->vddci_dependency_on_mclk.entries);\r\nkfree(dyn_state->vddc_dependency_on_mclk.entries);\r\nkfree(dyn_state->mvdd_dependency_on_mclk.entries);\r\nkfree(dyn_state->cac_leakage_table.entries);\r\nkfree(dyn_state->phase_shedding_limits_table.entries);\r\nkfree(dyn_state->ppm_table);\r\nkfree(dyn_state->cac_tdp_table);\r\nkfree(dyn_state->vce_clock_voltage_dependency_table.entries);\r\nkfree(dyn_state->uvd_clock_voltage_dependency_table.entries);\r\nkfree(dyn_state->samu_clock_voltage_dependency_table.entries);\r\nkfree(dyn_state->acp_clock_voltage_dependency_table.entries);\r\n}\r\nenum radeon_pcie_gen r600_get_pcie_gen_support(struct radeon_device *rdev,\r\nu32 sys_mask,\r\nenum radeon_pcie_gen asic_gen,\r\nenum radeon_pcie_gen default_gen)\r\n{\r\nswitch (asic_gen) {\r\ncase RADEON_PCIE_GEN1:\r\nreturn RADEON_PCIE_GEN1;\r\ncase RADEON_PCIE_GEN2:\r\nreturn RADEON_PCIE_GEN2;\r\ncase RADEON_PCIE_GEN3:\r\nreturn RADEON_PCIE_GEN3;\r\ndefault:\r\nif ((sys_mask & DRM_PCIE_SPEED_80) && (default_gen == RADEON_PCIE_GEN3))\r\nreturn RADEON_PCIE_GEN3;\r\nelse if ((sys_mask & DRM_PCIE_SPEED_50) && (default_gen == RADEON_PCIE_GEN2))\r\nreturn RADEON_PCIE_GEN2;\r\nelse\r\nreturn RADEON_PCIE_GEN1;\r\n}\r\nreturn RADEON_PCIE_GEN1;\r\n}\r\nu16 r600_get_pcie_lane_support(struct radeon_device *rdev,\r\nu16 asic_lanes,\r\nu16 default_lanes)\r\n{\r\nswitch (asic_lanes) {\r\ncase 0:\r\ndefault:\r\nreturn default_lanes;\r\ncase 1:\r\nreturn 1;\r\ncase 2:\r\nreturn 2;\r\ncase 4:\r\nreturn 4;\r\ncase 8:\r\nreturn 8;\r\ncase 12:\r\nreturn 12;\r\ncase 16:\r\nreturn 16;\r\n}\r\n}\r\nu8 r600_encode_pci_lane_width(u32 lanes)\r\n{\r\nu8 encoded_lanes[] = { 0, 1, 2, 0, 3, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 6 };\r\nif (lanes > 16)\r\nreturn 0;\r\nreturn encoded_lanes[lanes];\r\n}
