static void am335x_phy_wkup(struct phy_control *phy_ctrl, u32 id, bool on)\r\n{\r\nstruct am335x_control_usb *usb_ctrl;\r\nu32 val;\r\nu32 reg;\r\nusb_ctrl = container_of(phy_ctrl, struct am335x_control_usb, phy_ctrl);\r\nswitch (id) {\r\ncase 0:\r\nreg = AM335X_PHY0_WK_EN;\r\nbreak;\r\ncase 1:\r\nreg = AM335X_PHY1_WK_EN;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nspin_lock(&usb_ctrl->lock);\r\nval = readl(usb_ctrl->wkup);\r\nif (on)\r\nval |= reg;\r\nelse\r\nval &= ~reg;\r\nwritel(val, usb_ctrl->wkup);\r\nspin_unlock(&usb_ctrl->lock);\r\n}\r\nstatic void am335x_phy_power(struct phy_control *phy_ctrl, u32 id, bool on)\r\n{\r\nstruct am335x_control_usb *usb_ctrl;\r\nu32 val;\r\nu32 reg;\r\nusb_ctrl = container_of(phy_ctrl, struct am335x_control_usb, phy_ctrl);\r\nswitch (id) {\r\ncase 0:\r\nreg = AM335X_USB0_CTRL;\r\nbreak;\r\ncase 1:\r\nreg = AM335X_USB1_CTRL;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nval = readl(usb_ctrl->phy_reg + reg);\r\nif (on) {\r\nval &= ~(USBPHY_CM_PWRDN | USBPHY_OTG_PWRDN);\r\nval |= USBPHY_OTGVDET_EN | USBPHY_OTGSESSEND_EN;\r\n} else {\r\nval |= USBPHY_CM_PWRDN | USBPHY_OTG_PWRDN;\r\n}\r\nwritel(val, usb_ctrl->phy_reg + reg);\r\nif (on)\r\nmdelay(1);\r\n}\r\nstatic int match(struct device *dev, void *data)\r\n{\r\nstruct device_node *node = (struct device_node *)data;\r\nreturn dev->of_node == node &&\r\ndev->driver == &am335x_control_driver.driver;\r\n}\r\nstruct phy_control *am335x_get_phy_control(struct device *dev)\r\n{\r\nstruct device_node *node;\r\nstruct am335x_control_usb *ctrl_usb;\r\nnode = of_parse_phandle(dev->of_node, "ti,ctrl_mod", 0);\r\nif (!node)\r\nreturn NULL;\r\ndev = bus_find_device(&platform_bus_type, NULL, node, match);\r\nctrl_usb = dev_get_drvdata(dev);\r\nif (!ctrl_usb)\r\nreturn NULL;\r\nreturn &ctrl_usb->phy_ctrl;\r\n}\r\nstatic int am335x_control_usb_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct am335x_control_usb *ctrl_usb;\r\nconst struct of_device_id *of_id;\r\nconst struct phy_control *phy_ctrl;\r\nof_id = of_match_node(omap_control_usb_id_table, pdev->dev.of_node);\r\nif (!of_id)\r\nreturn -EINVAL;\r\nphy_ctrl = of_id->data;\r\nctrl_usb = devm_kzalloc(&pdev->dev, sizeof(*ctrl_usb), GFP_KERNEL);\r\nif (!ctrl_usb) {\r\ndev_err(&pdev->dev, "unable to alloc memory for control usb\n");\r\nreturn -ENOMEM;\r\n}\r\nctrl_usb->dev = &pdev->dev;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "phy_ctrl");\r\nctrl_usb->phy_reg = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(ctrl_usb->phy_reg))\r\nreturn PTR_ERR(ctrl_usb->phy_reg);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "wakeup");\r\nctrl_usb->wkup = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(ctrl_usb->wkup))\r\nreturn PTR_ERR(ctrl_usb->wkup);\r\nspin_lock_init(&ctrl_usb->lock);\r\nctrl_usb->phy_ctrl = *phy_ctrl;\r\ndev_set_drvdata(ctrl_usb->dev, ctrl_usb);\r\nreturn 0;\r\n}
