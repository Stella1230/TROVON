static inline u32 wakeupgen_readl(u8 idx, u32 cpu)\r\n{\r\nreturn readl_relaxed(wakeupgen_base + OMAP_WKG_ENB_A_0 +\r\n(cpu * CPU_ENA_OFFSET) + (idx * 4));\r\n}\r\nstatic inline void wakeupgen_writel(u32 val, u8 idx, u32 cpu)\r\n{\r\nwritel_relaxed(val, wakeupgen_base + OMAP_WKG_ENB_A_0 +\r\n(cpu * CPU_ENA_OFFSET) + (idx * 4));\r\n}\r\nstatic inline void sar_writel(u32 val, u32 offset, u8 idx)\r\n{\r\nwritel_relaxed(val, sar_base + offset + (idx * 4));\r\n}\r\nstatic inline int _wakeupgen_get_irq_info(u32 irq, u32 *bit_posn, u8 *reg_index)\r\n{\r\nunsigned int spi_irq;\r\nif (irq < OMAP44XX_IRQ_GIC_START)\r\nreturn -EINVAL;\r\nspi_irq = irq - OMAP44XX_IRQ_GIC_START;\r\nif (spi_irq > MAX_IRQS) {\r\npr_err("omap wakeupGen: Invalid IRQ%d\n", irq);\r\nreturn -EINVAL;\r\n}\r\n*reg_index = spi_irq >> 5;\r\n*bit_posn = spi_irq %= 32;\r\nreturn 0;\r\n}\r\nstatic void _wakeupgen_clear(unsigned int irq, unsigned int cpu)\r\n{\r\nu32 val, bit_number;\r\nu8 i;\r\nif (_wakeupgen_get_irq_info(irq, &bit_number, &i))\r\nreturn;\r\nval = wakeupgen_readl(i, cpu);\r\nval &= ~BIT(bit_number);\r\nwakeupgen_writel(val, i, cpu);\r\n}\r\nstatic void _wakeupgen_set(unsigned int irq, unsigned int cpu)\r\n{\r\nu32 val, bit_number;\r\nu8 i;\r\nif (_wakeupgen_get_irq_info(irq, &bit_number, &i))\r\nreturn;\r\nval = wakeupgen_readl(i, cpu);\r\nval |= BIT(bit_number);\r\nwakeupgen_writel(val, i, cpu);\r\n}\r\nstatic void wakeupgen_mask(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&wakeupgen_lock, flags);\r\n_wakeupgen_clear(d->hwirq, irq_target_cpu[d->hwirq]);\r\nraw_spin_unlock_irqrestore(&wakeupgen_lock, flags);\r\n}\r\nstatic void wakeupgen_unmask(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&wakeupgen_lock, flags);\r\n_wakeupgen_set(d->hwirq, irq_target_cpu[d->hwirq]);\r\nraw_spin_unlock_irqrestore(&wakeupgen_lock, flags);\r\n}\r\nstatic void _wakeupgen_save_masks(unsigned int cpu)\r\n{\r\nu8 i;\r\nfor (i = 0; i < irq_banks; i++)\r\nper_cpu(irqmasks, cpu)[i] = wakeupgen_readl(i, cpu);\r\n}\r\nstatic void _wakeupgen_restore_masks(unsigned int cpu)\r\n{\r\nu8 i;\r\nfor (i = 0; i < irq_banks; i++)\r\nwakeupgen_writel(per_cpu(irqmasks, cpu)[i], i, cpu);\r\n}\r\nstatic void _wakeupgen_set_all(unsigned int cpu, unsigned int reg)\r\n{\r\nu8 i;\r\nfor (i = 0; i < irq_banks; i++)\r\nwakeupgen_writel(reg, i, cpu);\r\n}\r\nstatic void wakeupgen_irqmask_all(unsigned int cpu, unsigned int set)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&wakeupgen_lock, flags);\r\nif (set) {\r\n_wakeupgen_save_masks(cpu);\r\n_wakeupgen_set_all(cpu, WKG_MASK_ALL);\r\n} else {\r\n_wakeupgen_set_all(cpu, WKG_UNMASK_ALL);\r\n_wakeupgen_restore_masks(cpu);\r\n}\r\nraw_spin_unlock_irqrestore(&wakeupgen_lock, flags);\r\n}\r\nstatic inline void omap4_irq_save_context(void)\r\n{\r\nu32 i, val;\r\nif (omap_rev() == OMAP4430_REV_ES1_0)\r\nreturn;\r\nfor (i = 0; i < irq_banks; i++) {\r\nval = wakeupgen_readl(i, 0);\r\nsar_writel(val, WAKEUPGENENB_OFFSET_CPU0, i);\r\nval = wakeupgen_readl(i, 1);\r\nsar_writel(val, WAKEUPGENENB_OFFSET_CPU1, i);\r\nsar_writel(0x0, WAKEUPGENENB_SECURE_OFFSET_CPU0, i);\r\nsar_writel(0x0, WAKEUPGENENB_SECURE_OFFSET_CPU1, i);\r\n}\r\nval = readl_relaxed(wakeupgen_base + OMAP_AUX_CORE_BOOT_0);\r\nwritel_relaxed(val, sar_base + AUXCOREBOOT0_OFFSET);\r\nval = readl_relaxed(wakeupgen_base + OMAP_AUX_CORE_BOOT_1);\r\nwritel_relaxed(val, sar_base + AUXCOREBOOT1_OFFSET);\r\nval = readl_relaxed(wakeupgen_base + OMAP_PTMSYNCREQ_MASK);\r\nwritel_relaxed(val, sar_base + PTMSYNCREQ_MASK_OFFSET);\r\nval = readl_relaxed(wakeupgen_base + OMAP_PTMSYNCREQ_EN);\r\nwritel_relaxed(val, sar_base + PTMSYNCREQ_EN_OFFSET);\r\nval = readl_relaxed(sar_base + SAR_BACKUP_STATUS_OFFSET);\r\nval |= SAR_BACKUP_STATUS_WAKEUPGEN;\r\nwritel_relaxed(val, sar_base + SAR_BACKUP_STATUS_OFFSET);\r\n}\r\nstatic inline void omap5_irq_save_context(void)\r\n{\r\nu32 i, val;\r\nfor (i = 0; i < irq_banks; i++) {\r\nval = wakeupgen_readl(i, 0);\r\nsar_writel(val, OMAP5_WAKEUPGENENB_OFFSET_CPU0, i);\r\nval = wakeupgen_readl(i, 1);\r\nsar_writel(val, OMAP5_WAKEUPGENENB_OFFSET_CPU1, i);\r\nsar_writel(0x0, OMAP5_WAKEUPGENENB_SECURE_OFFSET_CPU0, i);\r\nsar_writel(0x0, OMAP5_WAKEUPGENENB_SECURE_OFFSET_CPU1, i);\r\n}\r\nval = readl_relaxed(wakeupgen_base + OMAP_AUX_CORE_BOOT_0);\r\nwritel_relaxed(val, sar_base + OMAP5_AUXCOREBOOT0_OFFSET);\r\nval = readl_relaxed(wakeupgen_base + OMAP_AUX_CORE_BOOT_0);\r\nwritel_relaxed(val, sar_base + OMAP5_AUXCOREBOOT1_OFFSET);\r\nval = readl_relaxed(sar_base + OMAP5_SAR_BACKUP_STATUS_OFFSET);\r\nval |= SAR_BACKUP_STATUS_WAKEUPGEN;\r\nwritel_relaxed(val, sar_base + OMAP5_SAR_BACKUP_STATUS_OFFSET);\r\n}\r\nstatic void irq_save_context(void)\r\n{\r\nif (!sar_base)\r\nsar_base = omap4_get_sar_ram_base();\r\nif (soc_is_omap54xx())\r\nomap5_irq_save_context();\r\nelse\r\nomap4_irq_save_context();\r\n}\r\nstatic void irq_sar_clear(void)\r\n{\r\nu32 val;\r\nu32 offset = SAR_BACKUP_STATUS_OFFSET;\r\nif (soc_is_omap54xx())\r\noffset = OMAP5_SAR_BACKUP_STATUS_OFFSET;\r\nval = readl_relaxed(sar_base + offset);\r\nval &= ~SAR_BACKUP_STATUS_WAKEUPGEN;\r\nwritel_relaxed(val, sar_base + offset);\r\n}\r\nstatic void irq_save_secure_context(void)\r\n{\r\nu32 ret;\r\nret = omap_secure_dispatcher(OMAP4_HAL_SAVEGIC_INDEX,\r\nFLAG_START_CRITICAL,\r\n0, 0, 0, 0, 0);\r\nif (ret != API_HAL_RET_VALUE_OK)\r\npr_err("GIC and Wakeupgen context save failed\n");\r\n}\r\nstatic int irq_cpu_hotplug_notify(struct notifier_block *self,\r\nunsigned long action, void *hcpu)\r\n{\r\nunsigned int cpu = (unsigned int)hcpu;\r\nswitch (action) {\r\ncase CPU_ONLINE:\r\nwakeupgen_irqmask_all(cpu, 0);\r\nbreak;\r\ncase CPU_DEAD:\r\nwakeupgen_irqmask_all(cpu, 1);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void __init irq_hotplug_init(void)\r\n{\r\nregister_hotcpu_notifier(&irq_hotplug_notifier);\r\n}\r\nstatic void __init irq_hotplug_init(void)\r\n{}\r\nstatic int irq_notifier(struct notifier_block *self, unsigned long cmd, void *v)\r\n{\r\nswitch (cmd) {\r\ncase CPU_CLUSTER_PM_ENTER:\r\nif (omap_type() == OMAP2_DEVICE_TYPE_GP)\r\nirq_save_context();\r\nelse\r\nirq_save_secure_context();\r\nbreak;\r\ncase CPU_CLUSTER_PM_EXIT:\r\nif (omap_type() == OMAP2_DEVICE_TYPE_GP)\r\nirq_sar_clear();\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void __init irq_pm_init(void)\r\n{\r\nif (!soc_is_omap54xx())\r\ncpu_pm_register_notifier(&irq_notifier_block);\r\n}\r\nstatic void __init irq_pm_init(void)\r\n{}\r\nvoid __iomem *omap_get_wakeupgen_base(void)\r\n{\r\nreturn wakeupgen_base;\r\n}\r\nint omap_secure_apis_support(void)\r\n{\r\nreturn omap_secure_apis;\r\n}\r\nint __init omap_wakeupgen_init(void)\r\n{\r\nint i;\r\nunsigned int boot_cpu = smp_processor_id();\r\nif (omap_rev() == OMAP4430_REV_ES1_0) {\r\nWARN(1, "WakeupGen: Not supported on OMAP4430 ES1.0\n");\r\nreturn -EPERM;\r\n}\r\nwakeupgen_base = ioremap(OMAP_WKUPGEN_BASE, SZ_4K);\r\nif (WARN_ON(!wakeupgen_base))\r\nreturn -ENOMEM;\r\nif (cpu_is_omap44xx()) {\r\nirq_banks = OMAP4_NR_BANKS;\r\nmax_irqs = OMAP4_NR_IRQS;\r\nomap_secure_apis = 1;\r\n} else if (soc_is_am43xx()) {\r\nirq_banks = AM43XX_NR_REG_BANKS;\r\nmax_irqs = AM43XX_IRQS;\r\n}\r\nfor (i = 0; i < irq_banks; i++) {\r\nwakeupgen_writel(0, i, CPU0_ID);\r\nif (!soc_is_am43xx())\r\nwakeupgen_writel(0, i, CPU1_ID);\r\n}\r\ngic_arch_extn.irq_mask = wakeupgen_mask;\r\ngic_arch_extn.irq_unmask = wakeupgen_unmask;\r\ngic_arch_extn.flags = IRQCHIP_MASK_ON_SUSPEND | IRQCHIP_SKIP_SET_WAKE;\r\nfor (i = 0; i < max_irqs; i++)\r\nirq_target_cpu[i] = boot_cpu;\r\nirq_hotplug_init();\r\nirq_pm_init();\r\nreturn 0;\r\n}
