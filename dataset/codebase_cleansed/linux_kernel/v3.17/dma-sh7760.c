static void camelot_txdma(void *data)\r\n{\r\nstruct camelot_pcm *cam = data;\r\ncam->tx_period ^= 1;\r\nsnd_pcm_period_elapsed(cam->tx_ss);\r\n}\r\nstatic void camelot_rxdma(void *data)\r\n{\r\nstruct camelot_pcm *cam = data;\r\ncam->rx_period ^= 1;\r\nsnd_pcm_period_elapsed(cam->rx_ss);\r\n}\r\nstatic int camelot_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct camelot_pcm *cam = &cam_pcm_data[rtd->cpu_dai->id];\r\nint recv = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? 0:1;\r\nint ret, dmairq;\r\nsnd_soc_set_runtime_hwparams(substream, &camelot_pcm_hardware);\r\ndmairq = (recv) ? cam->txid + 2 : cam->txid;\r\nif (recv) {\r\ncam->rx_ss = substream;\r\nret = dmabrg_request_irq(dmairq, camelot_rxdma, cam);\r\nif (unlikely(ret)) {\r\npr_debug("audio unit %d irqs already taken!\n",\r\nrtd->cpu_dai->id);\r\nreturn -EBUSY;\r\n}\r\n(void)dmabrg_request_irq(dmairq + 1,camelot_rxdma, cam);\r\n} else {\r\ncam->tx_ss = substream;\r\nret = dmabrg_request_irq(dmairq, camelot_txdma, cam);\r\nif (unlikely(ret)) {\r\npr_debug("audio unit %d irqs already taken!\n",\r\nrtd->cpu_dai->id);\r\nreturn -EBUSY;\r\n}\r\n(void)dmabrg_request_irq(dmairq + 1, camelot_txdma, cam);\r\n}\r\nreturn 0;\r\n}\r\nstatic int camelot_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct camelot_pcm *cam = &cam_pcm_data[rtd->cpu_dai->id];\r\nint recv = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? 0:1;\r\nint dmairq;\r\ndmairq = (recv) ? cam->txid + 2 : cam->txid;\r\nif (recv)\r\ncam->rx_ss = NULL;\r\nelse\r\ncam->tx_ss = NULL;\r\ndmabrg_free_irq(dmairq + 1);\r\ndmabrg_free_irq(dmairq);\r\nreturn 0;\r\n}\r\nstatic int camelot_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct camelot_pcm *cam = &cam_pcm_data[rtd->cpu_dai->id];\r\nint recv = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? 0:1;\r\nint ret;\r\nret = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (ret < 0)\r\nreturn ret;\r\nif (recv) {\r\ncam->rx_period_size = params_period_bytes(hw_params);\r\ncam->rx_period = 0;\r\n} else {\r\ncam->tx_period_size = params_period_bytes(hw_params);\r\ncam->tx_period = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int camelot_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int camelot_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct camelot_pcm *cam = &cam_pcm_data[rtd->cpu_dai->id];\r\npr_debug("PCM data: addr 0x%08ulx len %d\n",\r\n(u32)runtime->dma_addr, runtime->dma_bytes);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nBRGREG(BRGATXSAR) = (unsigned long)runtime->dma_area;\r\nBRGREG(BRGATXTCR) = runtime->dma_bytes;\r\n} else {\r\nBRGREG(BRGARXDAR) = (unsigned long)runtime->dma_area;\r\nBRGREG(BRGARXTCR) = runtime->dma_bytes;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void dmabrg_play_dma_start(struct camelot_pcm *cam)\r\n{\r\nunsigned long acr = BRGREG(BRGACR) & ~(ACR_TDS | ACR_RDS);\r\nBRGREG(BRGACR) = acr | ACR_TDE | ACR_TAR | ACR_TAM_2WORD;\r\n}\r\nstatic inline void dmabrg_play_dma_stop(struct camelot_pcm *cam)\r\n{\r\nunsigned long acr = BRGREG(BRGACR) & ~(ACR_TDS | ACR_RDS);\r\nBRGREG(BRGACR) = acr | ACR_TDS;\r\n}\r\nstatic inline void dmabrg_rec_dma_start(struct camelot_pcm *cam)\r\n{\r\nunsigned long acr = BRGREG(BRGACR) & ~(ACR_TDS | ACR_RDS);\r\nBRGREG(BRGACR) = acr | ACR_RDE | ACR_RAR | ACR_RAM_2WORD;\r\n}\r\nstatic inline void dmabrg_rec_dma_stop(struct camelot_pcm *cam)\r\n{\r\nunsigned long acr = BRGREG(BRGACR) & ~(ACR_TDS | ACR_RDS);\r\nBRGREG(BRGACR) = acr | ACR_RDS;\r\n}\r\nstatic int camelot_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct camelot_pcm *cam = &cam_pcm_data[rtd->cpu_dai->id];\r\nint recv = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? 0:1;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nif (recv)\r\ndmabrg_rec_dma_start(cam);\r\nelse\r\ndmabrg_play_dma_start(cam);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nif (recv)\r\ndmabrg_rec_dma_stop(cam);\r\nelse\r\ndmabrg_play_dma_stop(cam);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t camelot_pos(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct camelot_pcm *cam = &cam_pcm_data[rtd->cpu_dai->id];\r\nint recv = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? 0:1;\r\nunsigned long pos;\r\nif (recv)\r\npos = cam->rx_period ? cam->rx_period_size : 0;\r\nelse\r\npos = cam->tx_period ? cam->tx_period_size : 0;\r\nreturn bytes_to_frames(runtime, pos);\r\n}\r\nstatic void camelot_pcm_free(struct snd_pcm *pcm)\r\n{\r\nsnd_pcm_lib_preallocate_free_for_all(pcm);\r\n}\r\nstatic int camelot_pcm_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm,\r\nSNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL),\r\nDMABRG_PREALLOC_BUFFER, DMABRG_PREALLOC_BUFFER_MAX);\r\nreturn 0;\r\n}\r\nstatic int sh7760_soc_platform_probe(struct platform_device *pdev)\r\n{\r\nreturn snd_soc_register_platform(&pdev->dev, &sh7760_soc_platform);\r\n}\r\nstatic int sh7760_soc_platform_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nreturn 0;\r\n}
