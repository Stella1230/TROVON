void\r\nsnd_emu10k1_ops_setup(struct snd_emux *emux)\r\n{\r\nemux->ops = emu10k1_ops;\r\n}\r\nint\r\nsnd_emu10k1_synth_get_voice(struct snd_emu10k1 *hw)\r\n{\r\nstruct snd_emux *emu;\r\nstruct snd_emux_voice *vp;\r\nstruct best_voice best[V_END];\r\nunsigned long flags;\r\nint i;\r\nemu = hw->synth;\r\nspin_lock_irqsave(&emu->voice_lock, flags);\r\nlookup_voices(emu, hw, best, 1);\r\nfor (i = 0; i < V_END; i++) {\r\nif (best[i].voice >= 0) {\r\nint ch;\r\nvp = &emu->voices[best[i].voice];\r\nif ((ch = vp->ch) < 0) {\r\ncontinue;\r\n}\r\nvp->emu->num_voices--;\r\nvp->ch = -1;\r\nvp->state = SNDRV_EMUX_ST_OFF;\r\nspin_unlock_irqrestore(&emu->voice_lock, flags);\r\nreturn ch;\r\n}\r\n}\r\nspin_unlock_irqrestore(&emu->voice_lock, flags);\r\nreturn -ENOMEM;\r\n}\r\nstatic void\r\nrelease_voice(struct snd_emux_voice *vp)\r\n{\r\nint dcysusv;\r\nstruct snd_emu10k1 *hw;\r\nhw = vp->hw;\r\ndcysusv = 0x8000 | (unsigned char)vp->reg.parm.modrelease;\r\nsnd_emu10k1_ptr_write(hw, DCYSUSM, vp->ch, dcysusv);\r\ndcysusv = 0x8000 | (unsigned char)vp->reg.parm.volrelease | DCYSUSV_CHANNELENABLE_MASK;\r\nsnd_emu10k1_ptr_write(hw, DCYSUSV, vp->ch, dcysusv);\r\n}\r\nstatic void\r\nterminate_voice(struct snd_emux_voice *vp)\r\n{\r\nstruct snd_emu10k1 *hw;\r\nif (snd_BUG_ON(!vp))\r\nreturn;\r\nhw = vp->hw;\r\nsnd_emu10k1_ptr_write(hw, DCYSUSV, vp->ch, 0x807f | DCYSUSV_CHANNELENABLE_MASK);\r\nif (vp->block) {\r\nstruct snd_emu10k1_memblk *emem;\r\nemem = (struct snd_emu10k1_memblk *)vp->block;\r\nif (emem->map_locked > 0)\r\nemem->map_locked--;\r\n}\r\n}\r\nstatic void\r\nfree_voice(struct snd_emux_voice *vp)\r\n{\r\nstruct snd_emu10k1 *hw;\r\nhw = vp->hw;\r\nif (hw && (vp->ch >= 0)) {\r\nsnd_emu10k1_ptr_write(hw, IFATN, vp->ch, 0xff00);\r\nsnd_emu10k1_ptr_write(hw, DCYSUSV, vp->ch, 0x807f | DCYSUSV_CHANNELENABLE_MASK);\r\nsnd_emu10k1_ptr_write(hw, VTFT, vp->ch, 0xffff);\r\nsnd_emu10k1_ptr_write(hw, CVCF, vp->ch, 0xffff);\r\nsnd_emu10k1_voice_free(hw, &hw->voices[vp->ch]);\r\nvp->emu->num_voices--;\r\nvp->ch = -1;\r\n}\r\n}\r\nstatic void\r\nupdate_voice(struct snd_emux_voice *vp, int update)\r\n{\r\nstruct snd_emu10k1 *hw;\r\nhw = vp->hw;\r\nif (update & SNDRV_EMUX_UPDATE_VOLUME)\r\nsnd_emu10k1_ptr_write(hw, IFATN_ATTENUATION, vp->ch, vp->avol);\r\nif (update & SNDRV_EMUX_UPDATE_PITCH)\r\nsnd_emu10k1_ptr_write(hw, IP, vp->ch, vp->apitch);\r\nif (update & SNDRV_EMUX_UPDATE_PAN) {\r\nsnd_emu10k1_ptr_write(hw, PTRX_FXSENDAMOUNT_A, vp->ch, vp->apan);\r\nsnd_emu10k1_ptr_write(hw, PTRX_FXSENDAMOUNT_B, vp->ch, vp->aaux);\r\n}\r\nif (update & SNDRV_EMUX_UPDATE_FMMOD)\r\nset_fmmod(hw, vp);\r\nif (update & SNDRV_EMUX_UPDATE_TREMFREQ)\r\nsnd_emu10k1_ptr_write(hw, TREMFRQ, vp->ch, vp->reg.parm.tremfrq);\r\nif (update & SNDRV_EMUX_UPDATE_FM2FRQ2)\r\nset_fm2frq2(hw, vp);\r\nif (update & SNDRV_EMUX_UPDATE_Q)\r\nset_filterQ(hw, vp);\r\n}\r\nstatic void\r\nlookup_voices(struct snd_emux *emu, struct snd_emu10k1 *hw,\r\nstruct best_voice *best, int active_only)\r\n{\r\nstruct snd_emux_voice *vp;\r\nstruct best_voice *bp;\r\nint i;\r\nfor (i = 0; i < V_END; i++) {\r\nbest[i].time = (unsigned int)-1;\r\nbest[i].voice = -1;\r\n}\r\nfor (i = 0; i < emu->max_voices; i++) {\r\nint state, val;\r\nvp = &emu->voices[i];\r\nstate = vp->state;\r\nif (state == SNDRV_EMUX_ST_OFF) {\r\nif (vp->ch < 0) {\r\nif (active_only)\r\ncontinue;\r\nbp = best + V_FREE;\r\n} else\r\nbp = best + V_OFF;\r\n}\r\nelse if (state == SNDRV_EMUX_ST_RELEASED ||\r\nstate == SNDRV_EMUX_ST_PENDING) {\r\nbp = best + V_RELEASED;\r\n#if 1\r\nval = snd_emu10k1_ptr_read(hw, CVCF_CURRENTVOL, vp->ch);\r\nif (! val)\r\nbp = best + V_OFF;\r\n#endif\r\n}\r\nelse if (state == SNDRV_EMUX_ST_STANDBY)\r\ncontinue;\r\nelse if (state & SNDRV_EMUX_ST_ON)\r\nbp = best + V_PLAYING;\r\nelse\r\ncontinue;\r\nif (bp != best + V_OFF && bp != best + V_FREE &&\r\n(vp->reg.sample_mode & SNDRV_SFNT_SAMPLE_SINGLESHOT)) {\r\nval = snd_emu10k1_ptr_read(hw, CCCA_CURRADDR, vp->ch);\r\nif (val >= vp->reg.loopstart)\r\nbp = best + V_OFF;\r\n}\r\nif (vp->time < bp->time) {\r\nbp->time = vp->time;\r\nbp->voice = i;\r\n}\r\n}\r\n}\r\nstatic struct snd_emux_voice *\r\nget_voice(struct snd_emux *emu, struct snd_emux_port *port)\r\n{\r\nstruct snd_emu10k1 *hw;\r\nstruct snd_emux_voice *vp;\r\nstruct best_voice best[V_END];\r\nint i;\r\nhw = emu->hw;\r\nlookup_voices(emu, hw, best, 0);\r\nfor (i = 0; i < V_END; i++) {\r\nif (best[i].voice >= 0) {\r\nvp = &emu->voices[best[i].voice];\r\nif (vp->ch < 0) {\r\nstruct snd_emu10k1_voice *hwvoice;\r\nif (snd_emu10k1_voice_alloc(hw, EMU10K1_SYNTH, 1, &hwvoice) < 0 || hwvoice == NULL)\r\ncontinue;\r\nvp->ch = hwvoice->number;\r\nemu->num_voices++;\r\n}\r\nreturn vp;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nstart_voice(struct snd_emux_voice *vp)\r\n{\r\nunsigned int temp;\r\nint ch;\r\nunsigned int addr, mapped_offset;\r\nstruct snd_midi_channel *chan;\r\nstruct snd_emu10k1 *hw;\r\nstruct snd_emu10k1_memblk *emem;\r\nhw = vp->hw;\r\nch = vp->ch;\r\nif (snd_BUG_ON(ch < 0))\r\nreturn -EINVAL;\r\nchan = vp->chan;\r\nemem = (struct snd_emu10k1_memblk *)vp->block;\r\nif (emem == NULL)\r\nreturn -EINVAL;\r\nemem->map_locked++;\r\nif (snd_emu10k1_memblk_map(hw, emem) < 0) {\r\nreturn -ENOMEM;\r\n}\r\nmapped_offset = snd_emu10k1_memblk_offset(emem) >> 1;\r\nvp->reg.start += mapped_offset;\r\nvp->reg.end += mapped_offset;\r\nvp->reg.loopstart += mapped_offset;\r\nvp->reg.loopend += mapped_offset;\r\nif (hw->audigy) {\r\ntemp = FXBUS_MIDI_LEFT | (FXBUS_MIDI_RIGHT << 8) |\r\n(FXBUS_MIDI_REVERB << 16) | (FXBUS_MIDI_CHORUS << 24);\r\nsnd_emu10k1_ptr_write(hw, A_FXRT1, ch, temp);\r\n} else {\r\ntemp = (FXBUS_MIDI_LEFT << 16) | (FXBUS_MIDI_RIGHT << 20) |\r\n(FXBUS_MIDI_REVERB << 24) | (FXBUS_MIDI_CHORUS << 28);\r\nsnd_emu10k1_ptr_write(hw, FXRT, ch, temp);\r\n}\r\nsnd_emu10k1_ptr_write(hw, DCYSUSV, ch, 0x0000);\r\nsnd_emu10k1_ptr_write(hw, VTFT, ch, 0x0000FFFF);\r\nsnd_emu10k1_ptr_write(hw, CVCF, ch, 0x0000FFFF);\r\nsnd_emu10k1_ptr_write(hw, PTRX, ch, 0);\r\nsnd_emu10k1_ptr_write(hw, CPF, ch, 0);\r\nsnd_emu10k1_ptr_write(hw, IP, vp->ch, vp->apitch);\r\nsnd_emu10k1_ptr_write(hw, ENVVAL, ch, vp->reg.parm.moddelay);\r\nsnd_emu10k1_ptr_write(hw, ATKHLDM, ch, vp->reg.parm.modatkhld);\r\nsnd_emu10k1_ptr_write(hw, DCYSUSM, ch, vp->reg.parm.moddcysus);\r\nsnd_emu10k1_ptr_write(hw, ENVVOL, ch, vp->reg.parm.voldelay);\r\nsnd_emu10k1_ptr_write(hw, ATKHLDV, ch, vp->reg.parm.volatkhld);\r\ntemp = (unsigned int)vp->acutoff << 8 | (unsigned char)vp->avol;\r\nsnd_emu10k1_ptr_write(hw, IFATN, vp->ch, temp);\r\nsnd_emu10k1_ptr_write(hw, PEFE, ch, vp->reg.parm.pefe);\r\nsnd_emu10k1_ptr_write(hw, LFOVAL1, ch, vp->reg.parm.lfo1delay);\r\nsnd_emu10k1_ptr_write(hw, LFOVAL2, ch, vp->reg.parm.lfo2delay);\r\nset_fmmod(hw, vp);\r\nsnd_emu10k1_ptr_write(hw, TREMFRQ, vp->ch, vp->reg.parm.tremfrq);\r\nset_fm2frq2(hw, vp);\r\ntemp = vp->reg.parm.reverb;\r\ntemp += (int)vp->chan->control[MIDI_CTL_E1_REVERB_DEPTH] * 9 / 10;\r\nLIMITMAX(temp, 255);\r\naddr = vp->reg.loopstart;\r\nsnd_emu10k1_ptr_write(hw, PSST, vp->ch, (temp << 24) | addr);\r\naddr = vp->reg.loopend;\r\ntemp = vp->reg.parm.chorus;\r\ntemp += (int)chan->control[MIDI_CTL_E3_CHORUS_DEPTH] * 9 / 10;\r\nLIMITMAX(temp, 255);\r\ntemp = (temp <<24) | addr;\r\nsnd_emu10k1_ptr_write(hw, DSL, ch, temp);\r\nsnd_emu10k1_ptr_write(hw, Z1, ch, 0);\r\nsnd_emu10k1_ptr_write(hw, Z2, ch, 0);\r\ntemp = (hw->silent_page.addr << 1) | MAP_PTI_MASK;\r\nsnd_emu10k1_ptr_write(hw, MAPA, ch, temp);\r\nsnd_emu10k1_ptr_write(hw, MAPB, ch, temp);\r\n#if 0\r\n{\r\nunsigned int val, sample;\r\nval = 32;\r\nif (vp->reg.sample_mode & SNDRV_SFNT_SAMPLE_8BITS)\r\nsample = 0x80808080;\r\nelse {\r\nsample = 0;\r\nval *= 2;\r\n}\r\nsnd_emu10k1_ptr_write(hw, CCR, ch, 0x1c << 16);\r\nsnd_emu10k1_ptr_write(hw, CDE, ch, sample);\r\nsnd_emu10k1_ptr_write(hw, CDF, ch, sample);\r\ntemp = ((unsigned int)hw->silent_page.addr << 1) | MAP_PTI_MASK;\r\nsnd_emu10k1_ptr_write(hw, MAPA, ch, temp);\r\nsnd_emu10k1_ptr_write(hw, MAPB, ch, temp);\r\nval -= 4;\r\nval <<= 25;\r\nval |= 0x1c << 16;\r\nsnd_emu10k1_ptr_write(hw, CCR, ch, val);\r\n}\r\n#endif\r\naddr = vp->reg.start;\r\ntemp = vp->reg.parm.filterQ;\r\ntemp = (temp<<28) | addr;\r\nif (vp->apitch < 0xe400)\r\ntemp |= CCCA_INTERPROM_0;\r\nelse {\r\nunsigned int shift = (vp->apitch - 0xe000) >> 10;\r\ntemp |= shift << 25;\r\n}\r\nif (vp->reg.sample_mode & SNDRV_SFNT_SAMPLE_8BITS)\r\ntemp |= CCCA_8BITSELECT;\r\nsnd_emu10k1_ptr_write(hw, CCCA, ch, temp);\r\ntemp = (unsigned int)vp->vtarget << 16;\r\nsnd_emu10k1_ptr_write(hw, VTFT, ch, temp | vp->ftarget);\r\nsnd_emu10k1_ptr_write(hw, CVCF, ch, temp | 0xff00);\r\nreturn 0;\r\n}\r\nstatic void\r\ntrigger_voice(struct snd_emux_voice *vp)\r\n{\r\nunsigned int temp, ptarget;\r\nstruct snd_emu10k1 *hw;\r\nstruct snd_emu10k1_memblk *emem;\r\nhw = vp->hw;\r\nemem = (struct snd_emu10k1_memblk *)vp->block;\r\nif (! emem || emem->mapped_page < 0)\r\nreturn;\r\n#if 0\r\nptarget = (unsigned int)vp->ptarget << 16;\r\n#else\r\nptarget = IP_TO_CP(vp->apitch);\r\n#endif\r\ntemp = ptarget | (vp->apan << 8) | vp->aaux;\r\nsnd_emu10k1_ptr_write(hw, PTRX, vp->ch, temp);\r\nsnd_emu10k1_ptr_write(hw, CPF, vp->ch, ptarget);\r\nsnd_emu10k1_ptr_write(hw, DCYSUSV, vp->ch, vp->reg.parm.voldcysus|DCYSUSV_CHANNELENABLE_MASK);\r\n}\r\nstatic void\r\nset_fmmod(struct snd_emu10k1 *hw, struct snd_emux_voice *vp)\r\n{\r\nunsigned short fmmod;\r\nshort pitch;\r\nunsigned char cutoff;\r\nint modulation;\r\npitch = (char)(vp->reg.parm.fmmod>>8);\r\ncutoff = (vp->reg.parm.fmmod & 0xff);\r\nmodulation = vp->chan->gm_modulation + vp->chan->midi_pressure;\r\npitch += (MOD_SENSE * modulation) / 1200;\r\nLIMITVALUE(pitch, -128, 127);\r\nfmmod = ((unsigned char)pitch<<8) | cutoff;\r\nsnd_emu10k1_ptr_write(hw, FMMOD, vp->ch, fmmod);\r\n}\r\nstatic void\r\nset_fm2frq2(struct snd_emu10k1 *hw, struct snd_emux_voice *vp)\r\n{\r\nunsigned short fm2frq2;\r\nshort pitch;\r\nunsigned char freq;\r\nint modulation;\r\npitch = (char)(vp->reg.parm.fm2frq2>>8);\r\nfreq = vp->reg.parm.fm2frq2 & 0xff;\r\nmodulation = vp->chan->gm_modulation + vp->chan->midi_pressure;\r\npitch += (MOD_SENSE * modulation) / 1200;\r\nLIMITVALUE(pitch, -128, 127);\r\nfm2frq2 = ((unsigned char)pitch<<8) | freq;\r\nsnd_emu10k1_ptr_write(hw, FM2FRQ2, vp->ch, fm2frq2);\r\n}\r\nstatic void\r\nset_filterQ(struct snd_emu10k1 *hw, struct snd_emux_voice *vp)\r\n{\r\nunsigned int val;\r\nval = snd_emu10k1_ptr_read(hw, CCCA, vp->ch) & ~CCCA_RESONANCE;\r\nval |= (vp->reg.parm.filterQ << 28);\r\nsnd_emu10k1_ptr_write(hw, CCCA, vp->ch, val);\r\n}
