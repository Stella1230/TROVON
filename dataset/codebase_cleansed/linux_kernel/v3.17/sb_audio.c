int sb_audio_open(int dev, int mode)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nunsigned long flags;\r\nif (devc == NULL)\r\n{\r\nprintk(KERN_ERR "Sound Blaster: incomplete initialization.\n");\r\nreturn -ENXIO;\r\n}\r\nif (devc->caps & SB_NO_RECORDING && mode & OPEN_READ)\r\n{\r\nif (mode == OPEN_READ)\r\nreturn -EPERM;\r\n}\r\nspin_lock_irqsave(&devc->lock, flags);\r\nif (devc->opened)\r\n{\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\nreturn -EBUSY;\r\n}\r\nif (devc->dma16 != -1 && devc->dma16 != devc->dma8 && !devc->duplex)\r\n{\r\nif (sound_open_dma(devc->dma16, "Sound Blaster 16 bit"))\r\n{\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\nreturn -EBUSY;\r\n}\r\n}\r\ndevc->opened = mode;\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\ndevc->irq_mode = IMODE_NONE;\r\ndevc->irq_mode_16 = IMODE_NONE;\r\ndevc->fullduplex = devc->duplex &&\r\n((mode & OPEN_READ) && (mode & OPEN_WRITE));\r\nsb_dsp_reset(devc);\r\nif (devc->model == MDL_ESS) ess_mixer_reload (devc, SOUND_MIXER_RECLEV);\r\nif (devc->submodel == SUBMDL_ALS007)\r\n{\r\nif (mode & OPEN_READ)\r\nsb_setmixer(devc,ALS007_OUTPUT_CTRL2,\r\nsb_getmixer(devc,ALS007_OUTPUT_CTRL2) & 0xf9);\r\nelse\r\nsb_setmixer(devc,ALS007_OUTPUT_CTRL2,\r\nsb_getmixer(devc,ALS007_OUTPUT_CTRL2) | 0x06);\r\n}\r\nreturn 0;\r\n}\r\nvoid sb_audio_close(int dev)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nif(devc->duplex\r\n&& !devc->fullduplex\r\n&& (devc->opened & OPEN_READ) && (devc->opened & OPEN_WRITE))\r\n{\r\nstruct dma_buffparms *dmap_temp;\r\ndmap_temp = audio_devs[dev]->dmap_out;\r\naudio_devs[dev]->dmap_out = audio_devs[dev]->dmap_in;\r\naudio_devs[dev]->dmap_in = dmap_temp;\r\n}\r\naudio_devs[dev]->dmap_out->dma = devc->dma8;\r\naudio_devs[dev]->dmap_in->dma = ( devc->duplex ) ?\r\ndevc->dma16 : devc->dma8;\r\nif (devc->dma16 != -1 && devc->dma16 != devc->dma8 && !devc->duplex)\r\nsound_close_dma(devc->dma16);\r\nif ((devc->submodel == SUBMDL_ALS007) && (devc->opened & OPEN_READ))\r\n{\r\nsb_setmixer(devc,ALS007_OUTPUT_CTRL2,\r\nsb_getmixer(devc,ALS007_OUTPUT_CTRL2) | 0x06);\r\n}\r\ndevc->opened = 0;\r\n}\r\nstatic void sb_set_output_parms(int dev, unsigned long buf, int nr_bytes,\r\nint intrflag)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nif (!devc->fullduplex || devc->bits == AFMT_S16_LE)\r\n{\r\ndevc->trg_buf = buf;\r\ndevc->trg_bytes = nr_bytes;\r\ndevc->trg_intrflag = intrflag;\r\ndevc->irq_mode = IMODE_OUTPUT;\r\n}\r\nelse\r\n{\r\ndevc->trg_buf_16 = buf;\r\ndevc->trg_bytes_16 = nr_bytes;\r\ndevc->trg_intrflag_16 = intrflag;\r\ndevc->irq_mode_16 = IMODE_OUTPUT;\r\n}\r\n}\r\nstatic void sb_set_input_parms(int dev, unsigned long buf, int count, int intrflag)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nif (!devc->fullduplex || devc->bits != AFMT_S16_LE)\r\n{\r\ndevc->trg_buf = buf;\r\ndevc->trg_bytes = count;\r\ndevc->trg_intrflag = intrflag;\r\ndevc->irq_mode = IMODE_INPUT;\r\n}\r\nelse\r\n{\r\ndevc->trg_buf_16 = buf;\r\ndevc->trg_bytes_16 = count;\r\ndevc->trg_intrflag_16 = intrflag;\r\ndevc->irq_mode_16 = IMODE_INPUT;\r\n}\r\n}\r\nstatic void sb1_audio_output_block(int dev, unsigned long buf, int nr_bytes, int intrflag)\r\n{\r\nunsigned long flags;\r\nint count = nr_bytes;\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nif (audio_devs[dev]->dmap_out->dma > 3)\r\ncount >>= 1;\r\ncount--;\r\ndevc->irq_mode = IMODE_OUTPUT;\r\nspin_lock_irqsave(&devc->lock, flags);\r\nif (sb_dsp_command(devc, 0x14))\r\n{\r\nsb_dsp_command(devc, (unsigned char) (count & 0xff));\r\nsb_dsp_command(devc, (unsigned char) ((count >> 8) & 0xff));\r\n}\r\nelse\r\nprintk(KERN_WARNING "Sound Blaster: unable to start DAC.\n");\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\ndevc->intr_active = 1;\r\n}\r\nstatic void sb1_audio_start_input(int dev, unsigned long buf, int nr_bytes, int intrflag)\r\n{\r\nunsigned long flags;\r\nint count = nr_bytes;\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nif (audio_devs[dev]->dmap_out->dma > 3)\r\ncount >>= 1;\r\ncount--;\r\ndevc->irq_mode = IMODE_INPUT;\r\nspin_lock_irqsave(&devc->lock, flags);\r\nif (sb_dsp_command(devc, 0x24))\r\n{\r\nsb_dsp_command(devc, (unsigned char) (count & 0xff));\r\nsb_dsp_command(devc, (unsigned char) ((count >> 8) & 0xff));\r\n}\r\nelse\r\nprintk(KERN_ERR "Sound Blaster: unable to start ADC.\n");\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\ndevc->intr_active = 1;\r\n}\r\nstatic void sb1_audio_trigger(int dev, int bits)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nbits &= devc->irq_mode;\r\nif (!bits)\r\nsb_dsp_command(devc, 0xd0);\r\nelse\r\n{\r\nswitch (devc->irq_mode)\r\n{\r\ncase IMODE_INPUT:\r\nsb1_audio_start_input(dev, devc->trg_buf, devc->trg_bytes,\r\ndevc->trg_intrflag);\r\nbreak;\r\ncase IMODE_OUTPUT:\r\nsb1_audio_output_block(dev, devc->trg_buf, devc->trg_bytes,\r\ndevc->trg_intrflag);\r\nbreak;\r\n}\r\n}\r\ndevc->trigger_bits = bits;\r\n}\r\nstatic int sb1_audio_prepare_for_input(int dev, int bsize, int bcount)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devc->lock, flags);\r\nif (sb_dsp_command(devc, 0x40))\r\nsb_dsp_command(devc, devc->tconst);\r\nsb_dsp_command(devc, DSP_CMD_SPKOFF);\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\ndevc->trigger_bits = 0;\r\nreturn 0;\r\n}\r\nstatic int sb1_audio_prepare_for_output(int dev, int bsize, int bcount)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devc->lock, flags);\r\nif (sb_dsp_command(devc, 0x40))\r\nsb_dsp_command(devc, devc->tconst);\r\nsb_dsp_command(devc, DSP_CMD_SPKON);\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\ndevc->trigger_bits = 0;\r\nreturn 0;\r\n}\r\nstatic int sb1_audio_set_speed(int dev, int speed)\r\n{\r\nint max_speed = 23000;\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nint tmp;\r\nif (devc->opened & OPEN_READ)\r\nmax_speed = 13000;\r\nif (speed > 0)\r\n{\r\nif (speed < 4000)\r\nspeed = 4000;\r\nif (speed > max_speed)\r\nspeed = max_speed;\r\ndevc->tconst = (256 - ((1000000 + speed / 2) / speed)) & 0xff;\r\ntmp = 256 - devc->tconst;\r\nspeed = (1000000 + tmp / 2) / tmp;\r\ndevc->speed = speed;\r\n}\r\nreturn devc->speed;\r\n}\r\nstatic short sb1_audio_set_channels(int dev, short channels)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nreturn devc->channels = 1;\r\n}\r\nstatic unsigned int sb1_audio_set_bits(int dev, unsigned int bits)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nreturn devc->bits = 8;\r\n}\r\nstatic void sb1_audio_halt_xfer(int dev)\r\n{\r\nunsigned long flags;\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nspin_lock_irqsave(&devc->lock, flags);\r\nsb_dsp_reset(devc);\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\n}\r\nstatic void sb20_audio_output_block(int dev, unsigned long buf, int nr_bytes,\r\nint intrflag)\r\n{\r\nunsigned long flags;\r\nint count = nr_bytes;\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nunsigned char cmd;\r\nif (audio_devs[dev]->dmap_out->dma > 3)\r\ncount >>= 1;\r\ncount--;\r\ndevc->irq_mode = IMODE_OUTPUT;\r\nspin_lock_irqsave(&devc->lock, flags);\r\nif (sb_dsp_command(devc, 0x48))\r\n{\r\nsb_dsp_command(devc, (unsigned char) (count & 0xff));\r\nsb_dsp_command(devc, (unsigned char) ((count >> 8) & 0xff));\r\nif (devc->speed * devc->channels <= 23000)\r\ncmd = 0x1c;\r\nelse\r\ncmd = 0x90;\r\nif (!sb_dsp_command(devc, cmd))\r\nprintk(KERN_ERR "Sound Blaster: unable to start DAC.\n");\r\n}\r\nelse\r\nprintk(KERN_ERR "Sound Blaster: unable to start DAC.\n");\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\ndevc->intr_active = 1;\r\n}\r\nstatic void sb20_audio_start_input(int dev, unsigned long buf, int nr_bytes, int intrflag)\r\n{\r\nunsigned long flags;\r\nint count = nr_bytes;\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nunsigned char cmd;\r\nif (audio_devs[dev]->dmap_out->dma > 3)\r\ncount >>= 1;\r\ncount--;\r\ndevc->irq_mode = IMODE_INPUT;\r\nspin_lock_irqsave(&devc->lock, flags);\r\nif (sb_dsp_command(devc, 0x48))\r\n{\r\nsb_dsp_command(devc, (unsigned char) (count & 0xff));\r\nsb_dsp_command(devc, (unsigned char) ((count >> 8) & 0xff));\r\nif (devc->speed * devc->channels <= (devc->major == 3 ? 23000 : 13000))\r\ncmd = 0x2c;\r\nelse\r\ncmd = 0x98;\r\nif (!sb_dsp_command(devc, cmd))\r\nprintk(KERN_ERR "Sound Blaster: unable to start ADC.\n");\r\n}\r\nelse\r\nprintk(KERN_ERR "Sound Blaster: unable to start ADC.\n");\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\ndevc->intr_active = 1;\r\n}\r\nstatic void sb20_audio_trigger(int dev, int bits)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nbits &= devc->irq_mode;\r\nif (!bits)\r\nsb_dsp_command(devc, 0xd0);\r\nelse\r\n{\r\nswitch (devc->irq_mode)\r\n{\r\ncase IMODE_INPUT:\r\nsb20_audio_start_input(dev, devc->trg_buf, devc->trg_bytes,\r\ndevc->trg_intrflag);\r\nbreak;\r\ncase IMODE_OUTPUT:\r\nsb20_audio_output_block(dev, devc->trg_buf, devc->trg_bytes,\r\ndevc->trg_intrflag);\r\nbreak;\r\n}\r\n}\r\ndevc->trigger_bits = bits;\r\n}\r\nstatic int sb201_audio_set_speed(int dev, int speed)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nint tmp;\r\nint s;\r\nif (speed > 0)\r\n{\r\nif (speed < 4000)\r\nspeed = 4000;\r\nif (speed > 44100)\r\nspeed = 44100;\r\nif (devc->opened & OPEN_READ && speed > 15000)\r\nspeed = 15000;\r\ns = speed * devc->channels;\r\ndevc->tconst = (256 - ((1000000 + s / 2) / s)) & 0xff;\r\ntmp = 256 - devc->tconst;\r\nspeed = ((1000000 + tmp / 2) / tmp) / devc->channels;\r\ndevc->speed = speed;\r\n}\r\nreturn devc->speed;\r\n}\r\nstatic int sbpro_audio_prepare_for_input(int dev, int bsize, int bcount)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nunsigned long flags;\r\nunsigned char bits = 0;\r\nif (devc->dma16 >= 0 && devc->dma16 != devc->dma8)\r\naudio_devs[dev]->dmap_out->dma = audio_devs[dev]->dmap_in->dma =\r\ndevc->bits == 16 ? devc->dma16 : devc->dma8;\r\nif (devc->model == MDL_JAZZ || devc->model == MDL_SMW)\r\nif (devc->bits == AFMT_S16_LE)\r\nbits = 0x04;\r\nspin_lock_irqsave(&devc->lock, flags);\r\nif (sb_dsp_command(devc, 0x40))\r\nsb_dsp_command(devc, devc->tconst);\r\nsb_dsp_command(devc, DSP_CMD_SPKOFF);\r\nif (devc->channels == 1)\r\nsb_dsp_command(devc, 0xa0 | bits);\r\nelse\r\nsb_dsp_command(devc, 0xa8 | bits);\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\ndevc->trigger_bits = 0;\r\nreturn 0;\r\n}\r\nstatic int sbpro_audio_prepare_for_output(int dev, int bsize, int bcount)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nunsigned long flags;\r\nunsigned char tmp;\r\nunsigned char bits = 0;\r\nif (devc->dma16 >= 0 && devc->dma16 != devc->dma8)\r\naudio_devs[dev]->dmap_out->dma = audio_devs[dev]->dmap_in->dma = devc->bits == 16 ? devc->dma16 : devc->dma8;\r\nif (devc->model == MDL_SBPRO)\r\nsb_mixer_set_stereo(devc, devc->channels == 2);\r\nspin_lock_irqsave(&devc->lock, flags);\r\nif (sb_dsp_command(devc, 0x40))\r\nsb_dsp_command(devc, devc->tconst);\r\nsb_dsp_command(devc, DSP_CMD_SPKON);\r\nif (devc->model == MDL_JAZZ || devc->model == MDL_SMW)\r\n{\r\nif (devc->bits == AFMT_S16_LE)\r\nbits = 0x04;\r\nif (devc->channels == 1)\r\nsb_dsp_command(devc, 0xa0 | bits);\r\nelse\r\nsb_dsp_command(devc, 0xa8 | bits);\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\n}\r\nelse\r\n{\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\ntmp = sb_getmixer(devc, 0x0e);\r\nif (devc->channels == 1)\r\ntmp &= ~0x02;\r\nelse\r\ntmp |= 0x02;\r\nsb_setmixer(devc, 0x0e, tmp);\r\n}\r\ndevc->trigger_bits = 0;\r\nreturn 0;\r\n}\r\nstatic int sbpro_audio_set_speed(int dev, int speed)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nif (speed > 0)\r\n{\r\nif (speed < 4000)\r\nspeed = 4000;\r\nif (speed > 44100)\r\nspeed = 44100;\r\nif (devc->channels > 1 && speed > 22050)\r\nspeed = 22050;\r\nsb201_audio_set_speed(dev, speed);\r\n}\r\nreturn devc->speed;\r\n}\r\nstatic short sbpro_audio_set_channels(int dev, short channels)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nif (channels == 1 || channels == 2)\r\n{\r\nif (channels != devc->channels)\r\n{\r\ndevc->channels = channels;\r\nif (devc->model == MDL_SBPRO && devc->channels == 2)\r\nsbpro_audio_set_speed(dev, devc->speed);\r\n}\r\n}\r\nreturn devc->channels;\r\n}\r\nstatic int jazz16_audio_set_speed(int dev, int speed)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nif (speed > 0)\r\n{\r\nint tmp;\r\nint s;\r\nif (speed < 5000)\r\nspeed = 5000;\r\nif (speed > 44100)\r\nspeed = 44100;\r\ns = speed * devc->channels;\r\ndevc->tconst = (256 - ((1000000 + s / 2) / s)) & 0xff;\r\ntmp = 256 - devc->tconst;\r\nspeed = ((1000000 + tmp / 2) / tmp) / devc->channels;\r\ndevc->speed = speed;\r\n}\r\nreturn devc->speed;\r\n}\r\nstatic int sb16_audio_set_speed(int dev, int speed)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nint max_speed = devc->submodel == SUBMDL_ALS100 ? 48000 : 44100;\r\nif (speed > 0)\r\n{\r\nif (speed < 5000)\r\nspeed = 5000;\r\nif (speed > max_speed)\r\nspeed = max_speed;\r\ndevc->speed = speed;\r\n}\r\nreturn devc->speed;\r\n}\r\nstatic unsigned int sb16_audio_set_bits(int dev, unsigned int bits)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nif (bits != 0)\r\n{\r\nif (bits == AFMT_U8 || bits == AFMT_S16_LE)\r\ndevc->bits = bits;\r\nelse\r\ndevc->bits = AFMT_U8;\r\n}\r\nreturn devc->bits;\r\n}\r\nstatic int sb16_audio_prepare_for_input(int dev, int bsize, int bcount)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nif (!devc->fullduplex)\r\n{\r\naudio_devs[dev]->dmap_out->dma =\r\naudio_devs[dev]->dmap_in->dma =\r\ndevc->bits == AFMT_S16_LE ?\r\ndevc->dma16 : devc->dma8;\r\n}\r\nelse if (devc->bits == AFMT_S16_LE)\r\n{\r\naudio_devs[dev]->dmap_out->dma = devc->dma8;\r\naudio_devs[dev]->dmap_in->dma = devc->dma16;\r\n}\r\nelse\r\n{\r\naudio_devs[dev]->dmap_out->dma = devc->dma16;\r\naudio_devs[dev]->dmap_in->dma = devc->dma8;\r\n}\r\ndevc->trigger_bits = 0;\r\nreturn 0;\r\n}\r\nstatic int sb16_audio_prepare_for_output(int dev, int bsize, int bcount)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nif (!devc->fullduplex)\r\n{\r\naudio_devs[dev]->dmap_out->dma =\r\naudio_devs[dev]->dmap_in->dma =\r\ndevc->bits == AFMT_S16_LE ?\r\ndevc->dma16 : devc->dma8;\r\n}\r\nelse if (devc->bits == AFMT_S16_LE)\r\n{\r\naudio_devs[dev]->dmap_out->dma = devc->dma8;\r\naudio_devs[dev]->dmap_in->dma = devc->dma16;\r\n}\r\nelse\r\n{\r\naudio_devs[dev]->dmap_out->dma = devc->dma16;\r\naudio_devs[dev]->dmap_in->dma = devc->dma8;\r\n}\r\ndevc->trigger_bits = 0;\r\nreturn 0;\r\n}\r\nstatic void sb16_audio_output_block(int dev, unsigned long buf, int count,\r\nint intrflag)\r\n{\r\nunsigned long flags, cnt;\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nunsigned long bits;\r\nif (!devc->fullduplex || devc->bits == AFMT_S16_LE)\r\n{\r\ndevc->irq_mode = IMODE_OUTPUT;\r\ndevc->intr_active = 1;\r\n}\r\nelse\r\n{\r\ndevc->irq_mode_16 = IMODE_OUTPUT;\r\ndevc->intr_active_16 = 1;\r\n}\r\nspin_lock_irqsave(&devc->lock, flags);\r\nbits = devc->bits;\r\nif (devc->fullduplex)\r\ndevc->bits = (devc->bits == AFMT_S16_LE) ?\r\nAFMT_U8 : AFMT_S16_LE;\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\ncnt = count;\r\nif (devc->bits == AFMT_S16_LE)\r\ncnt >>= 1;\r\ncnt--;\r\nspin_lock_irqsave(&devc->lock, flags);\r\nsb_dsp_command(devc, 0x41);\r\nsb_dsp_command(devc, (unsigned char) ((devc->speed >> 8) & 0xff));\r\nsb_dsp_command(devc, (unsigned char) (devc->speed & 0xff));\r\nsb_dsp_command(devc, (devc->bits == AFMT_S16_LE ? 0xb6 : 0xc6));\r\nsb_dsp_command(devc, ((devc->channels == 2 ? 0x20 : 0) +\r\n(devc->bits == AFMT_S16_LE ? 0x10 : 0)));\r\nsb_dsp_command(devc, (unsigned char) (cnt & 0xff));\r\nsb_dsp_command(devc, (unsigned char) (cnt >> 8));\r\ndevc->bits = bits;\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\n}\r\nstatic void sb16_audio_start_input(int dev, unsigned long buf, int count, int intrflag)\r\n{\r\nunsigned long flags, cnt;\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nif (!devc->fullduplex || devc->bits != AFMT_S16_LE)\r\n{\r\ndevc->irq_mode = IMODE_INPUT;\r\ndevc->intr_active = 1;\r\n}\r\nelse\r\n{\r\ndevc->irq_mode_16 = IMODE_INPUT;\r\ndevc->intr_active_16 = 1;\r\n}\r\ncnt = count;\r\nif (devc->bits == AFMT_S16_LE)\r\ncnt >>= 1;\r\ncnt--;\r\nspin_lock_irqsave(&devc->lock, flags);\r\nsb_dsp_command(devc, 0x42);\r\nsb_dsp_command(devc, (unsigned char) ((devc->speed >> 8) & 0xff));\r\nsb_dsp_command(devc, (unsigned char) (devc->speed & 0xff));\r\nsb_dsp_command(devc, (devc->bits == AFMT_S16_LE ? 0xbe : 0xce));\r\nsb_dsp_command(devc, ((devc->channels == 2 ? 0x20 : 0) +\r\n(devc->bits == AFMT_S16_LE ? 0x10 : 0)));\r\nsb_dsp_command(devc, (unsigned char) (cnt & 0xff));\r\nsb_dsp_command(devc, (unsigned char) (cnt >> 8));\r\nspin_unlock_irqrestore(&devc->lock, flags);\r\n}\r\nstatic void sb16_audio_trigger(int dev, int bits)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nint bits_16 = bits & devc->irq_mode_16;\r\nbits &= devc->irq_mode;\r\nif (!bits && !bits_16)\r\nsb_dsp_command(devc, 0xd0);\r\nelse\r\n{\r\nif (bits)\r\n{\r\nswitch (devc->irq_mode)\r\n{\r\ncase IMODE_INPUT:\r\nsb16_audio_start_input(dev,\r\ndevc->trg_buf,\r\ndevc->trg_bytes,\r\ndevc->trg_intrflag);\r\nbreak;\r\ncase IMODE_OUTPUT:\r\nsb16_audio_output_block(dev,\r\ndevc->trg_buf,\r\ndevc->trg_bytes,\r\ndevc->trg_intrflag);\r\nbreak;\r\n}\r\n}\r\nif (bits_16)\r\n{\r\nswitch (devc->irq_mode_16)\r\n{\r\ncase IMODE_INPUT:\r\nsb16_audio_start_input(dev,\r\ndevc->trg_buf_16,\r\ndevc->trg_bytes_16,\r\ndevc->trg_intrflag_16);\r\nbreak;\r\ncase IMODE_OUTPUT:\r\nsb16_audio_output_block(dev,\r\ndevc->trg_buf_16,\r\ndevc->trg_bytes_16,\r\ndevc->trg_intrflag_16);\r\nbreak;\r\n}\r\n}\r\n}\r\ndevc->trigger_bits = bits | bits_16;\r\n}\r\nstatic void\r\nsb16_copy_from_user(int dev,\r\nchar *localbuf, int localoffs,\r\nconst char __user *userbuf, int useroffs,\r\nint max_in, int max_out,\r\nint *used, int *returned,\r\nint len)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\nint i, c, p, locallen;\r\nunsigned char *buf8;\r\nsigned short *buf16;\r\nif (!devc->fullduplex)\r\n{\r\nif (copy_from_user(localbuf + localoffs,\r\nuserbuf + useroffs, len))\r\nreturn;\r\n*used = len;\r\n*returned = len;\r\n}\r\nelse if (devc->bits == AFMT_S16_LE)\r\n{\r\nlen = ( (max_in >> 1) > max_out) ? max_out : (max_in >> 1);\r\nc = len;\r\np = 0;\r\nbuf8 = (unsigned char *)(localbuf + localoffs);\r\nwhile (c)\r\n{\r\nlocallen = (c >= LBUFCOPYSIZE ? LBUFCOPYSIZE : c);\r\nif (copy_from_user(lbuf16,\r\nuserbuf + useroffs + (p << 1),\r\nlocallen << 1))\r\nreturn;\r\nfor (i = 0; i < locallen; i++)\r\n{\r\nbuf8[p+i] = ~((lbuf16[i] >> 8) & 0xff) ^ 0x80;\r\n}\r\nc -= locallen; p += locallen;\r\n}\r\n*used = max_in > ( max_out << 1) ? (max_out << 1) : max_in;\r\n*returned = len;\r\n}\r\nelse\r\n{\r\nlen = max_in > (max_out >> 1) ? (max_out >> 1) : max_in;\r\nc = len;\r\np = 0;\r\nbuf16 = (signed short *)(localbuf + localoffs);\r\nwhile (c)\r\n{\r\nlocallen = (c >= LBUFCOPYSIZE ? LBUFCOPYSIZE : c);\r\nif (copy_from_user(lbuf8,\r\nuserbuf+useroffs + p,\r\nlocallen))\r\nreturn;\r\nfor (i = 0; i < locallen; i++)\r\n{\r\nbuf16[p+i] = (~lbuf8[i] ^ 0x80) << 8;\r\n}\r\nc -= locallen; p += locallen;\r\n}\r\n*used = len;\r\n*returned = len << 1;\r\n}\r\n}\r\nstatic void\r\nsb16_audio_mmap(int dev)\r\n{\r\nsb_devc *devc = audio_devs[dev]->devc;\r\ndevc->fullduplex = 0;\r\n}\r\nvoid sb_audio_init(sb_devc * devc, char *name, struct module *owner)\r\n{\r\nint audio_flags = 0;\r\nint format_mask = AFMT_U8;\r\nstruct audio_driver *driver = &sb1_audio_driver;\r\nswitch (devc->model)\r\n{\r\ncase MDL_SB1:\r\nDDB(printk("Will use standard SB1.x driver\n"));\r\naudio_flags = DMA_HARDSTOP;\r\nbreak;\r\ncase MDL_SB2:\r\nDDB(printk("Will use SB2.0 driver\n"));\r\naudio_flags = DMA_AUTOMODE;\r\ndriver = &sb20_audio_driver;\r\nbreak;\r\ncase MDL_SB201:\r\nDDB(printk("Will use SB2.01 (high speed) driver\n"));\r\naudio_flags = DMA_AUTOMODE;\r\ndriver = &sb201_audio_driver;\r\nbreak;\r\ncase MDL_JAZZ:\r\ncase MDL_SMW:\r\nDDB(printk("Will use Jazz16 driver\n"));\r\naudio_flags = DMA_AUTOMODE;\r\nformat_mask |= AFMT_S16_LE;\r\ndriver = &jazz16_audio_driver;\r\nbreak;\r\ncase MDL_ESS:\r\nDDB(printk("Will use ESS ES688/1688 driver\n"));\r\ndriver = ess_audio_init (devc, &audio_flags, &format_mask);\r\nbreak;\r\ncase MDL_SB16:\r\nDDB(printk("Will use SB16 driver\n"));\r\naudio_flags = DMA_AUTOMODE;\r\nformat_mask |= AFMT_S16_LE;\r\nif (devc->dma8 != devc->dma16 && devc->dma16 != -1)\r\n{\r\naudio_flags |= DMA_DUPLEX;\r\ndevc->duplex = 1;\r\n}\r\ndriver = &sb16_audio_driver;\r\nbreak;\r\ndefault:\r\nDDB(printk("Will use SB Pro driver\n"));\r\naudio_flags = DMA_AUTOMODE;\r\ndriver = &sbpro_audio_driver;\r\n}\r\nif (owner)\r\ndriver->owner = owner;\r\nif ((devc->dev = sound_install_audiodrv(AUDIO_DRIVER_VERSION,\r\nname,driver, sizeof(struct audio_driver),\r\naudio_flags, format_mask, devc,\r\ndevc->dma8,\r\ndevc->duplex ? devc->dma16 : devc->dma8)) < 0)\r\n{\r\nprintk(KERN_ERR "Sound Blaster: unable to install audio.\n");\r\nreturn;\r\n}\r\naudio_devs[devc->dev]->mixer_dev = devc->my_mixerdev;\r\naudio_devs[devc->dev]->min_fragment = 5;\r\n}
