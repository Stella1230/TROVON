static int m88ts2022_wr_regs(struct m88ts2022_priv *priv,\r\nu8 reg, const u8 *val, int len)\r\n{\r\n#define MAX_WR_LEN 3\r\n#define MAX_WR_XFER_LEN (MAX_WR_LEN + 1)\r\nint ret;\r\nu8 buf[MAX_WR_XFER_LEN];\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = priv->client->addr,\r\n.flags = 0,\r\n.len = 1 + len,\r\n.buf = buf,\r\n}\r\n};\r\nif (WARN_ON(len > MAX_WR_LEN))\r\nreturn -EINVAL;\r\nbuf[0] = reg;\r\nmemcpy(&buf[1], val, len);\r\nret = i2c_transfer(priv->client->adapter, msg, 1);\r\nif (ret == 1) {\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->client->dev,\r\n"%s: i2c wr failed=%d reg=%02x len=%d\n",\r\nKBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int m88ts2022_rd_regs(struct m88ts2022_priv *priv, u8 reg,\r\nu8 *val, int len)\r\n{\r\n#define MAX_RD_LEN 1\r\n#define MAX_RD_XFER_LEN (MAX_RD_LEN)\r\nint ret;\r\nu8 buf[MAX_RD_XFER_LEN];\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = priv->client->addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &reg,\r\n}, {\r\n.addr = priv->client->addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = buf,\r\n}\r\n};\r\nif (WARN_ON(len > MAX_RD_LEN))\r\nreturn -EINVAL;\r\nret = i2c_transfer(priv->client->adapter, msg, 2);\r\nif (ret == 2) {\r\nmemcpy(val, buf, len);\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->client->dev,\r\n"%s: i2c rd failed=%d reg=%02x len=%d\n",\r\nKBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int m88ts2022_wr_reg(struct m88ts2022_priv *priv, u8 reg, u8 val)\r\n{\r\nreturn m88ts2022_wr_regs(priv, reg, &val, 1);\r\n}\r\nstatic int m88ts2022_rd_reg(struct m88ts2022_priv *priv, u8 reg, u8 *val)\r\n{\r\nreturn m88ts2022_rd_regs(priv, reg, val, 1);\r\n}\r\nstatic int m88ts2022_wr_reg_mask(struct m88ts2022_priv *priv,\r\nu8 reg, u8 val, u8 mask)\r\n{\r\nint ret;\r\nu8 u8tmp;\r\nif (mask != 0xff) {\r\nret = m88ts2022_rd_regs(priv, reg, &u8tmp, 1);\r\nif (ret)\r\nreturn ret;\r\nval &= mask;\r\nu8tmp &= ~mask;\r\nval |= u8tmp;\r\n}\r\nreturn m88ts2022_wr_regs(priv, reg, &val, 1);\r\n}\r\nstatic int m88ts2022_cmd(struct dvb_frontend *fe,\r\nint op, int sleep, u8 reg, u8 mask, u8 val, u8 *reg_val)\r\n{\r\nstruct m88ts2022_priv *priv = fe->tuner_priv;\r\nint ret, i;\r\nu8 u8tmp;\r\nstruct m88ts2022_reg_val reg_vals[] = {\r\n{0x51, 0x1f - op},\r\n{0x51, 0x1f},\r\n{0x50, 0x00 + op},\r\n{0x50, 0x00},\r\n};\r\nfor (i = 0; i < 2; i++) {\r\ndev_dbg(&priv->client->dev,\r\n"%s: i=%d op=%02x reg=%02x mask=%02x val=%02x\n",\r\n__func__, i, op, reg, mask, val);\r\nfor (i = 0; i < ARRAY_SIZE(reg_vals); i++) {\r\nret = m88ts2022_wr_reg(priv, reg_vals[i].reg,\r\nreg_vals[i].val);\r\nif (ret)\r\ngoto err;\r\n}\r\nusleep_range(sleep * 1000, sleep * 10000);\r\nret = m88ts2022_rd_reg(priv, reg, &u8tmp);\r\nif (ret)\r\ngoto err;\r\nif ((u8tmp & mask) != val)\r\nbreak;\r\n}\r\nif (reg_val)\r\n*reg_val = u8tmp;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int m88ts2022_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct m88ts2022_priv *priv = fe->tuner_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\nunsigned int frequency_khz, frequency_offset_khz, f_3db_hz;\r\nunsigned int f_ref_khz, f_vco_khz, div_ref, div_out, pll_n, gdiv28;\r\nu8 buf[3], u8tmp, cap_code, lpf_gm, lpf_mxdiv, div_max, div_min;\r\nu16 u16tmp;\r\ndev_dbg(&priv->client->dev,\r\n"%s: frequency=%d symbol_rate=%d rolloff=%d\n",\r\n__func__, c->frequency, c->symbol_rate, c->rolloff);\r\nf_ref_khz = DIV_ROUND_CLOSEST(priv->cfg.clock, 1000);\r\ndiv_ref = DIV_ROUND_CLOSEST(f_ref_khz, 2000);\r\nif (c->symbol_rate < 5000000)\r\nfrequency_offset_khz = 3000;\r\nelse\r\nfrequency_offset_khz = 0;\r\nfrequency_khz = c->frequency + frequency_offset_khz;\r\nif (frequency_khz < 1103000) {\r\ndiv_out = 4;\r\nu8tmp = 0x1b;\r\n} else {\r\ndiv_out = 2;\r\nu8tmp = 0x0b;\r\n}\r\nbuf[0] = u8tmp;\r\nbuf[1] = 0x40;\r\nret = m88ts2022_wr_regs(priv, 0x10, buf, 2);\r\nif (ret)\r\ngoto err;\r\nf_vco_khz = frequency_khz * div_out;\r\npll_n = f_vco_khz * div_ref / f_ref_khz;\r\npll_n += pll_n % 2;\r\npriv->frequency_khz = pll_n * f_ref_khz / div_ref / div_out;\r\nif (pll_n < 4095)\r\nu16tmp = pll_n - 1024;\r\nelse if (pll_n < 6143)\r\nu16tmp = pll_n + 1024;\r\nelse\r\nu16tmp = pll_n + 3072;\r\nbuf[0] = (u16tmp >> 8) & 0x3f;\r\nbuf[1] = (u16tmp >> 0) & 0xff;\r\nbuf[2] = div_ref - 8;\r\nret = m88ts2022_wr_regs(priv, 0x01, buf, 3);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&priv->client->dev,\r\n"%s: frequency=%u offset=%d f_vco_khz=%u pll_n=%u div_ref=%u div_out=%u\n",\r\n__func__, priv->frequency_khz,\r\npriv->frequency_khz - c->frequency, f_vco_khz, pll_n,\r\ndiv_ref, div_out);\r\nret = m88ts2022_cmd(fe, 0x10, 5, 0x15, 0x40, 0x00, NULL);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_rd_reg(priv, 0x14, &u8tmp);\r\nif (ret)\r\ngoto err;\r\nu8tmp &= 0x7f;\r\nif (u8tmp < 64) {\r\nret = m88ts2022_wr_reg_mask(priv, 0x10, 0x80, 0x80);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_wr_reg(priv, 0x11, 0x6f);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_cmd(fe, 0x10, 5, 0x15, 0x40, 0x00, NULL);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = m88ts2022_rd_reg(priv, 0x14, &u8tmp);\r\nif (ret)\r\ngoto err;\r\nu8tmp &= 0x1f;\r\nif (u8tmp > 19) {\r\nret = m88ts2022_wr_reg_mask(priv, 0x10, 0x00, 0x02);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = m88ts2022_cmd(fe, 0x08, 5, 0x3c, 0xff, 0x00, NULL);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_wr_reg(priv, 0x25, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_wr_reg(priv, 0x27, 0x70);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_wr_reg(priv, 0x41, 0x09);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_wr_reg(priv, 0x08, 0x0b);\r\nif (ret)\r\ngoto err;\r\ngdiv28 = DIV_ROUND_CLOSEST(f_ref_khz * 1694U, 1000000U);\r\nret = m88ts2022_wr_reg(priv, 0x04, gdiv28);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_cmd(fe, 0x04, 2, 0x26, 0xff, 0x00, &u8tmp);\r\nif (ret)\r\ngoto err;\r\ncap_code = u8tmp & 0x3f;\r\nret = m88ts2022_wr_reg(priv, 0x41, 0x0d);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_cmd(fe, 0x04, 2, 0x26, 0xff, 0x00, &u8tmp);\r\nif (ret)\r\ngoto err;\r\nu8tmp &= 0x3f;\r\ncap_code = (cap_code + u8tmp) / 2;\r\ngdiv28 = gdiv28 * 207 / (cap_code * 2 + 151);\r\ndiv_max = gdiv28 * 135 / 100;\r\ndiv_min = gdiv28 * 78 / 100;\r\ndiv_max = clamp_val(div_max, 0U, 63U);\r\nf_3db_hz = c->symbol_rate * 135UL / 200UL;\r\nf_3db_hz += 2000000U + (frequency_offset_khz * 1000U);\r\nf_3db_hz = clamp(f_3db_hz, 7000000U, 40000000U);\r\n#define LPF_COEFF 3200U\r\nlpf_gm = DIV_ROUND_CLOSEST(f_3db_hz * gdiv28, LPF_COEFF * f_ref_khz);\r\nlpf_gm = clamp_val(lpf_gm, 1U, 23U);\r\nlpf_mxdiv = DIV_ROUND_CLOSEST(lpf_gm * LPF_COEFF * f_ref_khz, f_3db_hz);\r\nif (lpf_mxdiv < div_min)\r\nlpf_mxdiv = DIV_ROUND_CLOSEST(++lpf_gm * LPF_COEFF * f_ref_khz, f_3db_hz);\r\nlpf_mxdiv = clamp_val(lpf_mxdiv, 0U, div_max);\r\nret = m88ts2022_wr_reg(priv, 0x04, lpf_mxdiv);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_wr_reg(priv, 0x06, lpf_gm);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_cmd(fe, 0x04, 2, 0x26, 0xff, 0x00, &u8tmp);\r\nif (ret)\r\ngoto err;\r\ncap_code = u8tmp & 0x3f;\r\nret = m88ts2022_wr_reg(priv, 0x41, 0x09);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_cmd(fe, 0x04, 2, 0x26, 0xff, 0x00, &u8tmp);\r\nif (ret)\r\ngoto err;\r\nu8tmp &= 0x3f;\r\ncap_code = (cap_code + u8tmp) / 2;\r\nu8tmp = cap_code | 0x80;\r\nret = m88ts2022_wr_reg(priv, 0x25, u8tmp);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_wr_reg(priv, 0x27, 0x30);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_wr_reg(priv, 0x08, 0x09);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_cmd(fe, 0x01, 20, 0x21, 0xff, 0x00, NULL);\r\nif (ret)\r\ngoto err;\r\nerr:\r\nif (ret)\r\ndev_dbg(&priv->client->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int m88ts2022_init(struct dvb_frontend *fe)\r\n{\r\nstruct m88ts2022_priv *priv = fe->tuner_priv;\r\nint ret, i;\r\nu8 u8tmp;\r\nstatic const struct m88ts2022_reg_val reg_vals[] = {\r\n{0x7d, 0x9d},\r\n{0x7c, 0x9a},\r\n{0x7a, 0x76},\r\n{0x3b, 0x01},\r\n{0x63, 0x88},\r\n{0x61, 0x85},\r\n{0x22, 0x30},\r\n{0x30, 0x40},\r\n{0x20, 0x23},\r\n{0x24, 0x02},\r\n{0x12, 0xa0},\r\n};\r\ndev_dbg(&priv->client->dev, "%s:\n", __func__);\r\nret = m88ts2022_wr_reg(priv, 0x00, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_wr_reg(priv, 0x00, 0x03);\r\nif (ret)\r\ngoto err;\r\nswitch (priv->cfg.clock_out) {\r\ncase M88TS2022_CLOCK_OUT_DISABLED:\r\nu8tmp = 0x60;\r\nbreak;\r\ncase M88TS2022_CLOCK_OUT_ENABLED:\r\nu8tmp = 0x70;\r\nret = m88ts2022_wr_reg(priv, 0x05, priv->cfg.clock_out_div);\r\nif (ret)\r\ngoto err;\r\nbreak;\r\ncase M88TS2022_CLOCK_OUT_ENABLED_XTALOUT:\r\nu8tmp = 0x6c;\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\nret = m88ts2022_wr_reg(priv, 0x42, u8tmp);\r\nif (ret)\r\ngoto err;\r\nif (priv->cfg.loop_through)\r\nu8tmp = 0xec;\r\nelse\r\nu8tmp = 0x6c;\r\nret = m88ts2022_wr_reg(priv, 0x62, u8tmp);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(reg_vals); i++) {\r\nret = m88ts2022_wr_reg(priv, reg_vals[i].reg, reg_vals[i].val);\r\nif (ret)\r\ngoto err;\r\n}\r\nerr:\r\nif (ret)\r\ndev_dbg(&priv->client->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int m88ts2022_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct m88ts2022_priv *priv = fe->tuner_priv;\r\nint ret;\r\ndev_dbg(&priv->client->dev, "%s:\n", __func__);\r\nret = m88ts2022_wr_reg(priv, 0x00, 0x00);\r\nif (ret)\r\ngoto err;\r\nerr:\r\nif (ret)\r\ndev_dbg(&priv->client->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int m88ts2022_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct m88ts2022_priv *priv = fe->tuner_priv;\r\ndev_dbg(&priv->client->dev, "%s:\n", __func__);\r\n*frequency = priv->frequency_khz;\r\nreturn 0;\r\n}\r\nstatic int m88ts2022_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct m88ts2022_priv *priv = fe->tuner_priv;\r\ndev_dbg(&priv->client->dev, "%s:\n", __func__);\r\n*frequency = 0;\r\nreturn 0;\r\n}\r\nstatic int m88ts2022_get_rf_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct m88ts2022_priv *priv = fe->tuner_priv;\r\nint ret;\r\nu8 u8tmp;\r\nu16 gain, u16tmp;\r\nunsigned int gain1, gain2, gain3;\r\nret = m88ts2022_rd_reg(priv, 0x3d, &u8tmp);\r\nif (ret)\r\ngoto err;\r\ngain1 = (u8tmp >> 0) & 0x1f;\r\ngain1 = clamp(gain1, 0U, 15U);\r\nret = m88ts2022_rd_reg(priv, 0x21, &u8tmp);\r\nif (ret)\r\ngoto err;\r\ngain2 = (u8tmp >> 0) & 0x1f;\r\ngain2 = clamp(gain2, 2U, 16U);\r\nret = m88ts2022_rd_reg(priv, 0x66, &u8tmp);\r\nif (ret)\r\ngoto err;\r\ngain3 = (u8tmp >> 3) & 0x07;\r\ngain3 = clamp(gain3, 0U, 6U);\r\ngain = gain1 * 265 + gain2 * 338 + gain3 * 285;\r\nu16tmp = (0xffff - gain);\r\nu16tmp = clamp_val(u16tmp, 59000U, 61500U);\r\n*strength = (u16tmp - 59000) * 0xffff / (61500 - 59000);\r\nerr:\r\nif (ret)\r\ndev_dbg(&priv->client->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int m88ts2022_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct m88ts2022_config *cfg = client->dev.platform_data;\r\nstruct dvb_frontend *fe = cfg->fe;\r\nstruct m88ts2022_priv *priv;\r\nint ret;\r\nu8 chip_id, u8tmp;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\nret = -ENOMEM;\r\ndev_err(&client->dev, "%s: kzalloc() failed\n", KBUILD_MODNAME);\r\ngoto err;\r\n}\r\nmemcpy(&priv->cfg, cfg, sizeof(struct m88ts2022_config));\r\npriv->client = client;\r\nret = m88ts2022_rd_reg(priv, 0x00, &u8tmp);\r\nif (ret)\r\ngoto err;\r\nif ((u8tmp & 0x03) == 0x00) {\r\nret = m88ts2022_wr_reg(priv, 0x00, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nusleep_range(2000, 50000);\r\n}\r\nret = m88ts2022_wr_reg(priv, 0x00, 0x03);\r\nif (ret)\r\ngoto err;\r\nusleep_range(2000, 50000);\r\nret = m88ts2022_rd_reg(priv, 0x00, &chip_id);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&priv->client->dev, "%s: chip_id=%02x\n", __func__, chip_id);\r\nswitch (chip_id) {\r\ncase 0xc3:\r\ncase 0x83:\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\nswitch (priv->cfg.clock_out) {\r\ncase M88TS2022_CLOCK_OUT_DISABLED:\r\nu8tmp = 0x60;\r\nbreak;\r\ncase M88TS2022_CLOCK_OUT_ENABLED:\r\nu8tmp = 0x70;\r\nret = m88ts2022_wr_reg(priv, 0x05, priv->cfg.clock_out_div);\r\nif (ret)\r\ngoto err;\r\nbreak;\r\ncase M88TS2022_CLOCK_OUT_ENABLED_XTALOUT:\r\nu8tmp = 0x6c;\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\nret = m88ts2022_wr_reg(priv, 0x42, u8tmp);\r\nif (ret)\r\ngoto err;\r\nif (priv->cfg.loop_through)\r\nu8tmp = 0xec;\r\nelse\r\nu8tmp = 0x6c;\r\nret = m88ts2022_wr_reg(priv, 0x62, u8tmp);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_wr_reg(priv, 0x00, 0x00);\r\nif (ret)\r\ngoto err;\r\ndev_info(&priv->client->dev,\r\n"%s: Montage M88TS2022 successfully identified\n",\r\nKBUILD_MODNAME);\r\nfe->tuner_priv = priv;\r\nmemcpy(&fe->ops.tuner_ops, &m88ts2022_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\ni2c_set_clientdata(client, priv);\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "%s: failed=%d\n", __func__, ret);\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nstatic int m88ts2022_remove(struct i2c_client *client)\r\n{\r\nstruct m88ts2022_priv *priv = i2c_get_clientdata(client);\r\nstruct dvb_frontend *fe = priv->cfg.fe;\r\ndev_dbg(&client->dev, "%s:\n", __func__);\r\nmemset(&fe->ops.tuner_ops, 0, sizeof(struct dvb_tuner_ops));\r\nfe->tuner_priv = NULL;\r\nkfree(priv);\r\nreturn 0;\r\n}
