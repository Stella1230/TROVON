static int __cmd_record(int argc, const char **argv)\r\n{\r\nint rec_argc, i = 0, j;\r\nconst char **rec_argv;\r\nchar event[64];\r\nint ret;\r\nrec_argc = argc + 4;\r\nrec_argv = calloc(rec_argc + 1, sizeof(char *));\r\nif (!rec_argv)\r\nreturn -1;\r\nrec_argv[i++] = strdup("record");\r\nif (!strcmp(mem_operation, MEM_OPERATION_LOAD))\r\nrec_argv[i++] = strdup("-W");\r\nrec_argv[i++] = strdup("-d");\r\nrec_argv[i++] = strdup("-e");\r\nif (strcmp(mem_operation, MEM_OPERATION_LOAD))\r\nsprintf(event, "cpu/mem-stores/pp");\r\nelse\r\nsprintf(event, "cpu/mem-loads/pp");\r\nrec_argv[i++] = strdup(event);\r\nfor (j = 1; j < argc; j++, i++)\r\nrec_argv[i] = argv[j];\r\nret = cmd_record(i, rec_argv, NULL);\r\nfree(rec_argv);\r\nreturn ret;\r\n}\r\nstatic int\r\ndump_raw_samples(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nstruct perf_mem *mem = container_of(tool, struct perf_mem, tool);\r\nstruct addr_location al;\r\nconst char *fmt;\r\nif (perf_event__preprocess_sample(event, machine, &al, sample) < 0) {\r\nfprintf(stderr, "problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\nreturn -1;\r\n}\r\nif (al.filtered || (mem->hide_unresolved && al.sym == NULL))\r\nreturn 0;\r\nif (al.map != NULL)\r\nal.map->dso->hit = 1;\r\nif (symbol_conf.field_sep) {\r\nfmt = "%d%s%d%s0x%"PRIx64"%s0x%"PRIx64"%s%"PRIu64\r\n"%s0x%"PRIx64"%s%s:%s\n";\r\n} else {\r\nfmt = "%5d%s%5d%s0x%016"PRIx64"%s0x016%"PRIx64\r\n"%s%5"PRIu64"%s0x%06"PRIx64"%s%s:%s\n";\r\nsymbol_conf.field_sep = " ";\r\n}\r\nprintf(fmt,\r\nsample->pid,\r\nsymbol_conf.field_sep,\r\nsample->tid,\r\nsymbol_conf.field_sep,\r\nsample->ip,\r\nsymbol_conf.field_sep,\r\nsample->addr,\r\nsymbol_conf.field_sep,\r\nsample->weight,\r\nsymbol_conf.field_sep,\r\nsample->data_src,\r\nsymbol_conf.field_sep,\r\nal.map ? (al.map->dso ? al.map->dso->long_name : "???") : "???",\r\nal.sym ? al.sym->name : "???");\r\nreturn 0;\r\n}\r\nstatic int process_sample_event(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel __maybe_unused,\r\nstruct machine *machine)\r\n{\r\nreturn dump_raw_samples(tool, event, sample, machine);\r\n}\r\nstatic int report_raw_events(struct perf_mem *mem)\r\n{\r\nstruct perf_data_file file = {\r\n.path = input_name,\r\n.mode = PERF_DATA_MODE_READ,\r\n};\r\nint err = -EINVAL;\r\nint ret;\r\nstruct perf_session *session = perf_session__new(&file, false,\r\n&mem->tool);\r\nif (session == NULL)\r\nreturn -ENOMEM;\r\nif (mem->cpu_list) {\r\nret = perf_session__cpu_bitmap(session, mem->cpu_list,\r\nmem->cpu_bitmap);\r\nif (ret)\r\ngoto out_delete;\r\n}\r\nif (symbol__init() < 0)\r\nreturn -1;\r\nprintf("# PID, TID, IP, ADDR, LOCAL WEIGHT, DSRC, SYMBOL\n");\r\nerr = perf_session__process_events(session, &mem->tool);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\nout_delete:\r\nperf_session__delete(session);\r\nreturn err;\r\n}\r\nstatic int report_events(int argc, const char **argv, struct perf_mem *mem)\r\n{\r\nconst char **rep_argv;\r\nint ret, i = 0, j, rep_argc;\r\nif (mem->dump_raw)\r\nreturn report_raw_events(mem);\r\nrep_argc = argc + 3;\r\nrep_argv = calloc(rep_argc + 1, sizeof(char *));\r\nif (!rep_argv)\r\nreturn -1;\r\nrep_argv[i++] = strdup("report");\r\nrep_argv[i++] = strdup("--mem-mode");\r\nrep_argv[i++] = strdup("-n");\r\nif (strcmp(mem_operation, MEM_OPERATION_LOAD))\r\nrep_argv[i++] = strdup("--sort=mem,sym,dso,symbol_daddr,"\r\n"dso_daddr,tlb,locked");\r\nfor (j = 1; j < argc; j++, i++)\r\nrep_argv[i] = argv[j];\r\nret = cmd_report(i, rep_argv, NULL);\r\nfree(rep_argv);\r\nreturn ret;\r\n}\r\nint cmd_mem(int argc, const char **argv, const char *prefix __maybe_unused)\r\n{\r\nstruct stat st;\r\nstruct perf_mem mem = {\r\n.tool = {\r\n.sample = process_sample_event,\r\n.mmap = perf_event__process_mmap,\r\n.mmap2 = perf_event__process_mmap2,\r\n.comm = perf_event__process_comm,\r\n.lost = perf_event__process_lost,\r\n.fork = perf_event__process_fork,\r\n.build_id = perf_event__process_build_id,\r\n.ordered_samples = true,\r\n},\r\n.input_name = "perf.data",\r\n};\r\nconst struct option mem_options[] = {\r\nOPT_STRING('t', "type", &mem_operation,\r\n"type", "memory operations(load/store)"),\r\nOPT_BOOLEAN('D', "dump-raw-samples", &mem.dump_raw,\r\n"dump raw samples in ASCII"),\r\nOPT_BOOLEAN('U', "hide-unresolved", &mem.hide_unresolved,\r\n"Only display entries resolved to a symbol"),\r\nOPT_STRING('i', "input", &input_name, "file",\r\n"input file name"),\r\nOPT_STRING('C', "cpu", &mem.cpu_list, "cpu",\r\n"list of cpus to profile"),\r\nOPT_STRING('x', "field-separator", &symbol_conf.field_sep,\r\n"separator",\r\n"separator for columns, no spaces will be added"\r\n" between columns '.' is reserved."),\r\nOPT_END()\r\n};\r\nconst char *const mem_subcommands[] = { "record", "report", NULL };\r\nconst char *mem_usage[] = {\r\nNULL,\r\nNULL\r\n};\r\nargc = parse_options_subcommand(argc, argv, mem_options, mem_subcommands,\r\nmem_usage, PARSE_OPT_STOP_AT_NON_OPTION);\r\nif (!argc || !(strncmp(argv[0], "rec", 3) || mem_operation))\r\nusage_with_options(mem_usage, mem_options);\r\nif (!mem.input_name || !strlen(mem.input_name)) {\r\nif (!fstat(STDIN_FILENO, &st) && S_ISFIFO(st.st_mode))\r\nmem.input_name = "-";\r\nelse\r\nmem.input_name = "perf.data";\r\n}\r\nif (!strncmp(argv[0], "rec", 3))\r\nreturn __cmd_record(argc, argv);\r\nelse if (!strncmp(argv[0], "rep", 3))\r\nreturn report_events(argc, argv, &mem);\r\nelse\r\nusage_with_options(mem_usage, mem_options);\r\nreturn 0;\r\n}
