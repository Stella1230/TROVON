static inline int bcj_x86_test_msbyte(uint8_t b)\r\n{\r\nreturn b == 0x00 || b == 0xFF;\r\n}\r\nstatic size_t bcj_x86(struct xz_dec_bcj *s, uint8_t *buf, size_t size)\r\n{\r\nstatic const bool mask_to_allowed_status[8]\r\n= { true, true, true, false, true, false, false, false };\r\nstatic const uint8_t mask_to_bit_num[8] = { 0, 1, 2, 2, 3, 3, 3, 3 };\r\nsize_t i;\r\nsize_t prev_pos = (size_t)-1;\r\nuint32_t prev_mask = s->x86_prev_mask;\r\nuint32_t src;\r\nuint32_t dest;\r\nuint32_t j;\r\nuint8_t b;\r\nif (size <= 4)\r\nreturn 0;\r\nsize -= 4;\r\nfor (i = 0; i < size; ++i) {\r\nif ((buf[i] & 0xFE) != 0xE8)\r\ncontinue;\r\nprev_pos = i - prev_pos;\r\nif (prev_pos > 3) {\r\nprev_mask = 0;\r\n} else {\r\nprev_mask = (prev_mask << (prev_pos - 1)) & 7;\r\nif (prev_mask != 0) {\r\nb = buf[i + 4 - mask_to_bit_num[prev_mask]];\r\nif (!mask_to_allowed_status[prev_mask]\r\n|| bcj_x86_test_msbyte(b)) {\r\nprev_pos = i;\r\nprev_mask = (prev_mask << 1) | 1;\r\ncontinue;\r\n}\r\n}\r\n}\r\nprev_pos = i;\r\nif (bcj_x86_test_msbyte(buf[i + 4])) {\r\nsrc = get_unaligned_le32(buf + i + 1);\r\nwhile (true) {\r\ndest = src - (s->pos + (uint32_t)i + 5);\r\nif (prev_mask == 0)\r\nbreak;\r\nj = mask_to_bit_num[prev_mask] * 8;\r\nb = (uint8_t)(dest >> (24 - j));\r\nif (!bcj_x86_test_msbyte(b))\r\nbreak;\r\nsrc = dest ^ (((uint32_t)1 << (32 - j)) - 1);\r\n}\r\ndest &= 0x01FFFFFF;\r\ndest |= (uint32_t)0 - (dest & 0x01000000);\r\nput_unaligned_le32(dest, buf + i + 1);\r\ni += 4;\r\n} else {\r\nprev_mask = (prev_mask << 1) | 1;\r\n}\r\n}\r\nprev_pos = i - prev_pos;\r\ns->x86_prev_mask = prev_pos > 3 ? 0 : prev_mask << (prev_pos - 1);\r\nreturn i;\r\n}\r\nstatic size_t bcj_powerpc(struct xz_dec_bcj *s, uint8_t *buf, size_t size)\r\n{\r\nsize_t i;\r\nuint32_t instr;\r\nfor (i = 0; i + 4 <= size; i += 4) {\r\ninstr = get_unaligned_be32(buf + i);\r\nif ((instr & 0xFC000003) == 0x48000001) {\r\ninstr &= 0x03FFFFFC;\r\ninstr -= s->pos + (uint32_t)i;\r\ninstr &= 0x03FFFFFC;\r\ninstr |= 0x48000001;\r\nput_unaligned_be32(instr, buf + i);\r\n}\r\n}\r\nreturn i;\r\n}\r\nstatic size_t bcj_ia64(struct xz_dec_bcj *s, uint8_t *buf, size_t size)\r\n{\r\nstatic const uint8_t branch_table[32] = {\r\n0, 0, 0, 0, 0, 0, 0, 0,\r\n0, 0, 0, 0, 0, 0, 0, 0,\r\n4, 4, 6, 6, 0, 0, 7, 7,\r\n4, 4, 0, 0, 4, 4, 0, 0\r\n};\r\nsize_t i;\r\nsize_t j;\r\nuint32_t slot;\r\nuint32_t bit_pos;\r\nuint32_t byte_pos;\r\nuint32_t bit_res;\r\nuint32_t addr;\r\nuint32_t mask;\r\nuint64_t instr;\r\nuint64_t norm;\r\nfor (i = 0; i + 16 <= size; i += 16) {\r\nmask = branch_table[buf[i] & 0x1F];\r\nfor (slot = 0, bit_pos = 5; slot < 3; ++slot, bit_pos += 41) {\r\nif (((mask >> slot) & 1) == 0)\r\ncontinue;\r\nbyte_pos = bit_pos >> 3;\r\nbit_res = bit_pos & 7;\r\ninstr = 0;\r\nfor (j = 0; j < 6; ++j)\r\ninstr |= (uint64_t)(buf[i + j + byte_pos])\r\n<< (8 * j);\r\nnorm = instr >> bit_res;\r\nif (((norm >> 37) & 0x0F) == 0x05\r\n&& ((norm >> 9) & 0x07) == 0) {\r\naddr = (norm >> 13) & 0x0FFFFF;\r\naddr |= ((uint32_t)(norm >> 36) & 1) << 20;\r\naddr <<= 4;\r\naddr -= s->pos + (uint32_t)i;\r\naddr >>= 4;\r\nnorm &= ~((uint64_t)0x8FFFFF << 13);\r\nnorm |= (uint64_t)(addr & 0x0FFFFF) << 13;\r\nnorm |= (uint64_t)(addr & 0x100000)\r\n<< (36 - 20);\r\ninstr &= (1 << bit_res) - 1;\r\ninstr |= norm << bit_res;\r\nfor (j = 0; j < 6; j++)\r\nbuf[i + j + byte_pos]\r\n= (uint8_t)(instr >> (8 * j));\r\n}\r\n}\r\n}\r\nreturn i;\r\n}\r\nstatic size_t bcj_arm(struct xz_dec_bcj *s, uint8_t *buf, size_t size)\r\n{\r\nsize_t i;\r\nuint32_t addr;\r\nfor (i = 0; i + 4 <= size; i += 4) {\r\nif (buf[i + 3] == 0xEB) {\r\naddr = (uint32_t)buf[i] | ((uint32_t)buf[i + 1] << 8)\r\n| ((uint32_t)buf[i + 2] << 16);\r\naddr <<= 2;\r\naddr -= s->pos + (uint32_t)i + 8;\r\naddr >>= 2;\r\nbuf[i] = (uint8_t)addr;\r\nbuf[i + 1] = (uint8_t)(addr >> 8);\r\nbuf[i + 2] = (uint8_t)(addr >> 16);\r\n}\r\n}\r\nreturn i;\r\n}\r\nstatic size_t bcj_armthumb(struct xz_dec_bcj *s, uint8_t *buf, size_t size)\r\n{\r\nsize_t i;\r\nuint32_t addr;\r\nfor (i = 0; i + 4 <= size; i += 2) {\r\nif ((buf[i + 1] & 0xF8) == 0xF0\r\n&& (buf[i + 3] & 0xF8) == 0xF8) {\r\naddr = (((uint32_t)buf[i + 1] & 0x07) << 19)\r\n| ((uint32_t)buf[i] << 11)\r\n| (((uint32_t)buf[i + 3] & 0x07) << 8)\r\n| (uint32_t)buf[i + 2];\r\naddr <<= 1;\r\naddr -= s->pos + (uint32_t)i + 4;\r\naddr >>= 1;\r\nbuf[i + 1] = (uint8_t)(0xF0 | ((addr >> 19) & 0x07));\r\nbuf[i] = (uint8_t)(addr >> 11);\r\nbuf[i + 3] = (uint8_t)(0xF8 | ((addr >> 8) & 0x07));\r\nbuf[i + 2] = (uint8_t)addr;\r\ni += 2;\r\n}\r\n}\r\nreturn i;\r\n}\r\nstatic size_t bcj_sparc(struct xz_dec_bcj *s, uint8_t *buf, size_t size)\r\n{\r\nsize_t i;\r\nuint32_t instr;\r\nfor (i = 0; i + 4 <= size; i += 4) {\r\ninstr = get_unaligned_be32(buf + i);\r\nif ((instr >> 22) == 0x100 || (instr >> 22) == 0x1FF) {\r\ninstr <<= 2;\r\ninstr -= s->pos + (uint32_t)i;\r\ninstr >>= 2;\r\ninstr = ((uint32_t)0x40000000 - (instr & 0x400000))\r\n| 0x40000000 | (instr & 0x3FFFFF);\r\nput_unaligned_be32(instr, buf + i);\r\n}\r\n}\r\nreturn i;\r\n}\r\nstatic void bcj_apply(struct xz_dec_bcj *s,\r\nuint8_t *buf, size_t *pos, size_t size)\r\n{\r\nsize_t filtered;\r\nbuf += *pos;\r\nsize -= *pos;\r\nswitch (s->type) {\r\n#ifdef XZ_DEC_X86\r\ncase BCJ_X86:\r\nfiltered = bcj_x86(s, buf, size);\r\nbreak;\r\n#endif\r\n#ifdef XZ_DEC_POWERPC\r\ncase BCJ_POWERPC:\r\nfiltered = bcj_powerpc(s, buf, size);\r\nbreak;\r\n#endif\r\n#ifdef XZ_DEC_IA64\r\ncase BCJ_IA64:\r\nfiltered = bcj_ia64(s, buf, size);\r\nbreak;\r\n#endif\r\n#ifdef XZ_DEC_ARM\r\ncase BCJ_ARM:\r\nfiltered = bcj_arm(s, buf, size);\r\nbreak;\r\n#endif\r\n#ifdef XZ_DEC_ARMTHUMB\r\ncase BCJ_ARMTHUMB:\r\nfiltered = bcj_armthumb(s, buf, size);\r\nbreak;\r\n#endif\r\n#ifdef XZ_DEC_SPARC\r\ncase BCJ_SPARC:\r\nfiltered = bcj_sparc(s, buf, size);\r\nbreak;\r\n#endif\r\ndefault:\r\nfiltered = 0;\r\nbreak;\r\n}\r\n*pos += filtered;\r\ns->pos += filtered;\r\n}\r\nstatic void bcj_flush(struct xz_dec_bcj *s, struct xz_buf *b)\r\n{\r\nsize_t copy_size;\r\ncopy_size = min_t(size_t, s->temp.filtered, b->out_size - b->out_pos);\r\nmemcpy(b->out + b->out_pos, s->temp.buf, copy_size);\r\nb->out_pos += copy_size;\r\ns->temp.filtered -= copy_size;\r\ns->temp.size -= copy_size;\r\nmemmove(s->temp.buf, s->temp.buf + copy_size, s->temp.size);\r\n}\r\nXZ_EXTERN enum xz_ret xz_dec_bcj_run(struct xz_dec_bcj *s,\r\nstruct xz_dec_lzma2 *lzma2,\r\nstruct xz_buf *b)\r\n{\r\nsize_t out_start;\r\nif (s->temp.filtered > 0) {\r\nbcj_flush(s, b);\r\nif (s->temp.filtered > 0)\r\nreturn XZ_OK;\r\nif (s->ret == XZ_STREAM_END)\r\nreturn XZ_STREAM_END;\r\n}\r\nif (s->temp.size < b->out_size - b->out_pos || s->temp.size == 0) {\r\nout_start = b->out_pos;\r\nmemcpy(b->out + b->out_pos, s->temp.buf, s->temp.size);\r\nb->out_pos += s->temp.size;\r\ns->ret = xz_dec_lzma2_run(lzma2, b);\r\nif (s->ret != XZ_STREAM_END\r\n&& (s->ret != XZ_OK || s->single_call))\r\nreturn s->ret;\r\nbcj_apply(s, b->out, &out_start, b->out_pos);\r\nif (s->ret == XZ_STREAM_END)\r\nreturn XZ_STREAM_END;\r\ns->temp.size = b->out_pos - out_start;\r\nb->out_pos -= s->temp.size;\r\nmemcpy(s->temp.buf, b->out + b->out_pos, s->temp.size);\r\nif (b->out_pos + s->temp.size < b->out_size)\r\nreturn XZ_OK;\r\n}\r\nif (b->out_pos < b->out_size) {\r\ns->out = b->out;\r\ns->out_pos = b->out_pos;\r\ns->out_size = b->out_size;\r\nb->out = s->temp.buf;\r\nb->out_pos = s->temp.size;\r\nb->out_size = sizeof(s->temp.buf);\r\ns->ret = xz_dec_lzma2_run(lzma2, b);\r\ns->temp.size = b->out_pos;\r\nb->out = s->out;\r\nb->out_pos = s->out_pos;\r\nb->out_size = s->out_size;\r\nif (s->ret != XZ_OK && s->ret != XZ_STREAM_END)\r\nreturn s->ret;\r\nbcj_apply(s, s->temp.buf, &s->temp.filtered, s->temp.size);\r\nif (s->ret == XZ_STREAM_END)\r\ns->temp.filtered = s->temp.size;\r\nbcj_flush(s, b);\r\nif (s->temp.filtered > 0)\r\nreturn XZ_OK;\r\n}\r\nreturn s->ret;\r\n}\r\nXZ_EXTERN struct xz_dec_bcj *xz_dec_bcj_create(bool single_call)\r\n{\r\nstruct xz_dec_bcj *s = kmalloc(sizeof(*s), GFP_KERNEL);\r\nif (s != NULL)\r\ns->single_call = single_call;\r\nreturn s;\r\n}\r\nXZ_EXTERN enum xz_ret xz_dec_bcj_reset(struct xz_dec_bcj *s, uint8_t id)\r\n{\r\nswitch (id) {\r\n#ifdef XZ_DEC_X86\r\ncase BCJ_X86:\r\n#endif\r\n#ifdef XZ_DEC_POWERPC\r\ncase BCJ_POWERPC:\r\n#endif\r\n#ifdef XZ_DEC_IA64\r\ncase BCJ_IA64:\r\n#endif\r\n#ifdef XZ_DEC_ARM\r\ncase BCJ_ARM:\r\n#endif\r\n#ifdef XZ_DEC_ARMTHUMB\r\ncase BCJ_ARMTHUMB:\r\n#endif\r\n#ifdef XZ_DEC_SPARC\r\ncase BCJ_SPARC:\r\n#endif\r\nbreak;\r\ndefault:\r\nreturn XZ_OPTIONS_ERROR;\r\n}\r\ns->type = id;\r\ns->ret = XZ_OK;\r\ns->pos = 0;\r\ns->x86_prev_mask = 0;\r\ns->temp.filtered = 0;\r\ns->temp.size = 0;\r\nreturn XZ_OK;\r\n}
