static int\r\nminstrel_ht_get_group_idx(struct ieee80211_tx_rate *rate)\r\n{\r\nreturn GROUP_IDX((rate->idx / 8) + 1,\r\n!!(rate->flags & IEEE80211_TX_RC_SHORT_GI),\r\n!!(rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH));\r\n}\r\nstatic struct minstrel_rate_stats *\r\nminstrel_ht_get_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,\r\nstruct ieee80211_tx_rate *rate)\r\n{\r\nint group, idx;\r\nif (rate->flags & IEEE80211_TX_RC_MCS) {\r\ngroup = minstrel_ht_get_group_idx(rate);\r\nidx = rate->idx % 8;\r\n} else {\r\ngroup = MINSTREL_CCK_GROUP;\r\nfor (idx = 0; idx < ARRAY_SIZE(mp->cck_rates); idx++)\r\nif (rate->idx == mp->cck_rates[idx])\r\nbreak;\r\nif (!(mi->groups[group].supported & BIT(idx)))\r\nidx += 4;\r\n}\r\nreturn &mi->groups[group].rates[idx];\r\n}\r\nstatic inline struct minstrel_rate_stats *\r\nminstrel_get_ratestats(struct minstrel_ht_sta *mi, int index)\r\n{\r\nreturn &mi->groups[index / MCS_GROUP_RATES].rates[index % MCS_GROUP_RATES];\r\n}\r\nstatic void\r\nminstrel_calc_rate_ewma(struct minstrel_rate_stats *mr)\r\n{\r\nif (unlikely(mr->attempts > 0)) {\r\nmr->sample_skipped = 0;\r\nmr->cur_prob = MINSTREL_FRAC(mr->success, mr->attempts);\r\nif (!mr->att_hist)\r\nmr->probability = mr->cur_prob;\r\nelse\r\nmr->probability = minstrel_ewma(mr->probability,\r\nmr->cur_prob, EWMA_LEVEL);\r\nmr->att_hist += mr->attempts;\r\nmr->succ_hist += mr->success;\r\n} else {\r\nmr->sample_skipped++;\r\n}\r\nmr->last_success = mr->success;\r\nmr->last_attempts = mr->attempts;\r\nmr->success = 0;\r\nmr->attempts = 0;\r\n}\r\nstatic void\r\nminstrel_ht_calc_tp(struct minstrel_ht_sta *mi, int group, int rate)\r\n{\r\nstruct minstrel_rate_stats *mr;\r\nunsigned int nsecs = 0;\r\nunsigned int tp;\r\nunsigned int prob;\r\nmr = &mi->groups[group].rates[rate];\r\nprob = mr->probability;\r\nif (prob < MINSTREL_FRAC(1, 10)) {\r\nmr->cur_tp = 0;\r\nreturn;\r\n}\r\nif (prob > MINSTREL_FRAC(9, 10))\r\nprob = MINSTREL_FRAC(9, 10);\r\nif (group != MINSTREL_CCK_GROUP)\r\nnsecs = 1000 * mi->overhead / MINSTREL_TRUNC(mi->avg_ampdu_len);\r\nnsecs += minstrel_mcs_groups[group].duration[rate];\r\ntp = 1000000 * ((prob * 1000) / nsecs);\r\nmr->cur_tp = MINSTREL_TRUNC(tp);\r\n}\r\nstatic void\r\nminstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)\r\n{\r\nstruct minstrel_mcs_group_data *mg;\r\nstruct minstrel_rate_stats *mr;\r\nint cur_prob, cur_prob_tp, cur_tp, cur_tp2;\r\nint group, i, index;\r\nbool mi_rates_valid = false;\r\nif (mi->ampdu_packets > 0) {\r\nmi->avg_ampdu_len = minstrel_ewma(mi->avg_ampdu_len,\r\nMINSTREL_FRAC(mi->ampdu_len, mi->ampdu_packets), EWMA_LEVEL);\r\nmi->ampdu_len = 0;\r\nmi->ampdu_packets = 0;\r\n}\r\nmi->sample_slow = 0;\r\nmi->sample_count = 0;\r\nfor (group = 0; group < ARRAY_SIZE(minstrel_mcs_groups); group++) {\r\nbool mg_rates_valid = false;\r\ncur_prob = 0;\r\ncur_prob_tp = 0;\r\ncur_tp = 0;\r\ncur_tp2 = 0;\r\nmg = &mi->groups[group];\r\nif (!mg->supported)\r\ncontinue;\r\nmi->sample_count++;\r\nfor (i = 0; i < MCS_GROUP_RATES; i++) {\r\nif (!(mg->supported & BIT(i)))\r\ncontinue;\r\nindex = MCS_GROUP_RATES * group + i;\r\nif (!mg_rates_valid) {\r\nmg->max_tp_rate = mg->max_tp_rate2 =\r\nmg->max_prob_rate = i;\r\nif (!mi_rates_valid) {\r\nmi->max_tp_rate = mi->max_tp_rate2 =\r\nmi->max_prob_rate = index;\r\nmi_rates_valid = true;\r\n}\r\nmg_rates_valid = true;\r\n}\r\nmr = &mg->rates[i];\r\nmr->retry_updated = false;\r\nminstrel_calc_rate_ewma(mr);\r\nminstrel_ht_calc_tp(mi, group, i);\r\nif (!mr->cur_tp)\r\ncontinue;\r\nif ((mr->cur_tp > cur_prob_tp && mr->probability >\r\nMINSTREL_FRAC(3, 4)) || mr->probability > cur_prob) {\r\nmg->max_prob_rate = index;\r\ncur_prob = mr->probability;\r\ncur_prob_tp = mr->cur_tp;\r\n}\r\nif (mr->cur_tp > cur_tp) {\r\nswap(index, mg->max_tp_rate);\r\ncur_tp = mr->cur_tp;\r\nmr = minstrel_get_ratestats(mi, index);\r\n}\r\nif (index >= mg->max_tp_rate)\r\ncontinue;\r\nif (mr->cur_tp > cur_tp2) {\r\nmg->max_tp_rate2 = index;\r\ncur_tp2 = mr->cur_tp;\r\n}\r\n}\r\n}\r\nmi->sample_count *= 8;\r\ncur_prob = 0;\r\ncur_prob_tp = 0;\r\ncur_tp = 0;\r\ncur_tp2 = 0;\r\nfor (group = 0; group < ARRAY_SIZE(minstrel_mcs_groups); group++) {\r\nmg = &mi->groups[group];\r\nif (!mg->supported)\r\ncontinue;\r\nmr = minstrel_get_ratestats(mi, mg->max_tp_rate);\r\nif (cur_tp < mr->cur_tp) {\r\nmi->max_tp_rate2 = mi->max_tp_rate;\r\ncur_tp2 = cur_tp;\r\nmi->max_tp_rate = mg->max_tp_rate;\r\ncur_tp = mr->cur_tp;\r\nmi->max_prob_streams = minstrel_mcs_groups[group].streams - 1;\r\n}\r\nmr = minstrel_get_ratestats(mi, mg->max_tp_rate2);\r\nif (cur_tp2 < mr->cur_tp) {\r\nmi->max_tp_rate2 = mg->max_tp_rate2;\r\ncur_tp2 = mr->cur_tp;\r\n}\r\n}\r\nif (mi->max_prob_streams < 1)\r\nmi->max_prob_streams = 1;\r\nfor (group = 0; group < ARRAY_SIZE(minstrel_mcs_groups); group++) {\r\nmg = &mi->groups[group];\r\nif (!mg->supported)\r\ncontinue;\r\nmr = minstrel_get_ratestats(mi, mg->max_prob_rate);\r\nif (cur_prob_tp < mr->cur_tp &&\r\nminstrel_mcs_groups[group].streams <= mi->max_prob_streams) {\r\nmi->max_prob_rate = mg->max_prob_rate;\r\ncur_prob = mr->cur_prob;\r\ncur_prob_tp = mr->cur_tp;\r\n}\r\n}\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\nif (mp->fixed_rate_idx != -1) {\r\nmi->max_tp_rate = mp->fixed_rate_idx;\r\nmi->max_tp_rate2 = mp->fixed_rate_idx;\r\nmi->max_prob_rate = mp->fixed_rate_idx;\r\n}\r\n#endif\r\nmi->stats_update = jiffies;\r\n}\r\nstatic bool\r\nminstrel_ht_txstat_valid(struct minstrel_priv *mp, struct ieee80211_tx_rate *rate)\r\n{\r\nif (rate->idx < 0)\r\nreturn false;\r\nif (!rate->count)\r\nreturn false;\r\nif (rate->flags & IEEE80211_TX_RC_MCS)\r\nreturn true;\r\nreturn rate->idx == mp->cck_rates[0] ||\r\nrate->idx == mp->cck_rates[1] ||\r\nrate->idx == mp->cck_rates[2] ||\r\nrate->idx == mp->cck_rates[3];\r\n}\r\nstatic void\r\nminstrel_next_sample_idx(struct minstrel_ht_sta *mi)\r\n{\r\nstruct minstrel_mcs_group_data *mg;\r\nfor (;;) {\r\nmi->sample_group++;\r\nmi->sample_group %= ARRAY_SIZE(minstrel_mcs_groups);\r\nmg = &mi->groups[mi->sample_group];\r\nif (!mg->supported)\r\ncontinue;\r\nif (++mg->index >= MCS_GROUP_RATES) {\r\nmg->index = 0;\r\nif (++mg->column >= ARRAY_SIZE(sample_table))\r\nmg->column = 0;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nminstrel_downgrade_rate(struct minstrel_ht_sta *mi, unsigned int *idx,\r\nbool primary)\r\n{\r\nint group, orig_group;\r\norig_group = group = *idx / MCS_GROUP_RATES;\r\nwhile (group > 0) {\r\ngroup--;\r\nif (!mi->groups[group].supported)\r\ncontinue;\r\nif (minstrel_mcs_groups[group].streams >\r\nminstrel_mcs_groups[orig_group].streams)\r\ncontinue;\r\nif (primary)\r\n*idx = mi->groups[group].max_tp_rate;\r\nelse\r\n*idx = mi->groups[group].max_tp_rate2;\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nminstrel_aggr_check(struct ieee80211_sta *pubsta, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\r\nu16 tid;\r\nif (unlikely(!ieee80211_is_data_qos(hdr->frame_control)))\r\nreturn;\r\nif (unlikely(skb->protocol == cpu_to_be16(ETH_P_PAE)))\r\nreturn;\r\ntid = *ieee80211_get_qos_ctl(hdr) & IEEE80211_QOS_CTL_TID_MASK;\r\nif (likely(sta->ampdu_mlme.tid_tx[tid]))\r\nreturn;\r\nif (skb_get_queue_mapping(skb) == IEEE80211_AC_VO)\r\nreturn;\r\nieee80211_start_tx_ba_session(pubsta, tid, 5000);\r\n}\r\nstatic void\r\nminstrel_ht_tx_status(void *priv, struct ieee80211_supported_band *sband,\r\nstruct ieee80211_sta *sta, void *priv_sta,\r\nstruct sk_buff *skb)\r\n{\r\nstruct minstrel_ht_sta_priv *msp = priv_sta;\r\nstruct minstrel_ht_sta *mi = &msp->ht;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_tx_rate *ar = info->status.rates;\r\nstruct minstrel_rate_stats *rate, *rate2;\r\nstruct minstrel_priv *mp = priv;\r\nbool last, update = false;\r\nint i;\r\nif (!msp->is_ht)\r\nreturn mac80211_minstrel.tx_status(priv, sband, sta, &msp->legacy, skb);\r\nif ((info->flags & IEEE80211_TX_CTL_AMPDU) &&\r\n!(info->flags & IEEE80211_TX_STAT_AMPDU))\r\nreturn;\r\nif (!(info->flags & IEEE80211_TX_STAT_AMPDU)) {\r\ninfo->status.ampdu_ack_len =\r\n(info->flags & IEEE80211_TX_STAT_ACK ? 1 : 0);\r\ninfo->status.ampdu_len = 1;\r\n}\r\nmi->ampdu_packets++;\r\nmi->ampdu_len += info->status.ampdu_len;\r\nif (!mi->sample_wait && !mi->sample_tries && mi->sample_count > 0) {\r\nmi->sample_wait = 16 + 2 * MINSTREL_TRUNC(mi->avg_ampdu_len);\r\nmi->sample_tries = 1;\r\nmi->sample_count--;\r\n}\r\nif (info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE)\r\nmi->sample_packets += info->status.ampdu_len;\r\nlast = !minstrel_ht_txstat_valid(mp, &ar[0]);\r\nfor (i = 0; !last; i++) {\r\nlast = (i == IEEE80211_TX_MAX_RATES - 1) ||\r\n!minstrel_ht_txstat_valid(mp, &ar[i + 1]);\r\nrate = minstrel_ht_get_stats(mp, mi, &ar[i]);\r\nif (last)\r\nrate->success += info->status.ampdu_ack_len;\r\nrate->attempts += ar[i].count * info->status.ampdu_len;\r\n}\r\nrate = minstrel_get_ratestats(mi, mi->max_tp_rate);\r\nif (rate->attempts > 30 &&\r\nMINSTREL_FRAC(rate->success, rate->attempts) <\r\nMINSTREL_FRAC(20, 100)) {\r\nminstrel_downgrade_rate(mi, &mi->max_tp_rate, true);\r\nupdate = true;\r\n}\r\nrate2 = minstrel_get_ratestats(mi, mi->max_tp_rate2);\r\nif (rate2->attempts > 30 &&\r\nMINSTREL_FRAC(rate2->success, rate2->attempts) <\r\nMINSTREL_FRAC(20, 100)) {\r\nminstrel_downgrade_rate(mi, &mi->max_tp_rate2, false);\r\nupdate = true;\r\n}\r\nif (time_after(jiffies, mi->stats_update + (mp->update_interval / 2 * HZ) / 1000)) {\r\nupdate = true;\r\nminstrel_ht_update_stats(mp, mi);\r\nif (!(info->flags & IEEE80211_TX_CTL_AMPDU) &&\r\nmi->max_prob_rate / MCS_GROUP_RATES != MINSTREL_CCK_GROUP)\r\nminstrel_aggr_check(sta, skb);\r\n}\r\nif (update)\r\nminstrel_ht_update_rates(mp, mi);\r\n}\r\nstatic void\r\nminstrel_calc_retransmit(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,\r\nint index)\r\n{\r\nstruct minstrel_rate_stats *mr;\r\nconst struct mcs_group *group;\r\nunsigned int tx_time, tx_time_rtscts, tx_time_data;\r\nunsigned int cw = mp->cw_min;\r\nunsigned int ctime = 0;\r\nunsigned int t_slot = 9;\r\nunsigned int ampdu_len = MINSTREL_TRUNC(mi->avg_ampdu_len);\r\nunsigned int overhead = 0, overhead_rtscts = 0;\r\nmr = minstrel_get_ratestats(mi, index);\r\nif (mr->probability < MINSTREL_FRAC(1, 10)) {\r\nmr->retry_count = 1;\r\nmr->retry_count_rtscts = 1;\r\nreturn;\r\n}\r\nmr->retry_count = 2;\r\nmr->retry_count_rtscts = 2;\r\nmr->retry_updated = true;\r\ngroup = &minstrel_mcs_groups[index / MCS_GROUP_RATES];\r\ntx_time_data = group->duration[index % MCS_GROUP_RATES] * ampdu_len / 1000;\r\nctime = (t_slot * cw) >> 1;\r\ncw = min((cw << 1) | 1, mp->cw_max);\r\nctime += (t_slot * cw) >> 1;\r\ncw = min((cw << 1) | 1, mp->cw_max);\r\nif (index / MCS_GROUP_RATES != MINSTREL_CCK_GROUP) {\r\noverhead = mi->overhead;\r\noverhead_rtscts = mi->overhead_rtscts;\r\n}\r\ntx_time = ctime + 2 * (overhead + tx_time_data);\r\ntx_time_rtscts = ctime + 2 * (overhead_rtscts + tx_time_data);\r\ndo {\r\nctime = (t_slot * cw) >> 1;\r\ncw = min((cw << 1) | 1, mp->cw_max);\r\ntx_time += ctime + overhead + tx_time_data;\r\ntx_time_rtscts += ctime + overhead_rtscts + tx_time_data;\r\nif (tx_time_rtscts < mp->segment_size)\r\nmr->retry_count_rtscts++;\r\n} while ((tx_time < mp->segment_size) &&\r\n(++mr->retry_count < mp->max_retry));\r\n}\r\nstatic void\r\nminstrel_ht_set_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,\r\nstruct ieee80211_sta_rates *ratetbl, int offset, int index)\r\n{\r\nconst struct mcs_group *group = &minstrel_mcs_groups[index / MCS_GROUP_RATES];\r\nstruct minstrel_rate_stats *mr;\r\nu8 idx;\r\nu16 flags;\r\nmr = minstrel_get_ratestats(mi, index);\r\nif (!mr->retry_updated)\r\nminstrel_calc_retransmit(mp, mi, index);\r\nif (mr->probability < MINSTREL_FRAC(20, 100) || !mr->retry_count) {\r\nratetbl->rate[offset].count = 2;\r\nratetbl->rate[offset].count_rts = 2;\r\nratetbl->rate[offset].count_cts = 2;\r\n} else {\r\nratetbl->rate[offset].count = mr->retry_count;\r\nratetbl->rate[offset].count_cts = mr->retry_count;\r\nratetbl->rate[offset].count_rts = mr->retry_count_rtscts;\r\n}\r\nif (index / MCS_GROUP_RATES == MINSTREL_CCK_GROUP) {\r\nidx = mp->cck_rates[index % ARRAY_SIZE(mp->cck_rates)];\r\nflags = 0;\r\n} else {\r\nidx = index % MCS_GROUP_RATES + (group->streams - 1) * 8;\r\nflags = IEEE80211_TX_RC_MCS | group->flags;\r\n}\r\nif (offset > 0) {\r\nratetbl->rate[offset].count = ratetbl->rate[offset].count_rts;\r\nflags |= IEEE80211_TX_RC_USE_RTS_CTS;\r\n}\r\nratetbl->rate[offset].idx = idx;\r\nratetbl->rate[offset].flags = flags;\r\n}\r\nstatic void\r\nminstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)\r\n{\r\nstruct ieee80211_sta_rates *rates;\r\nint i = 0;\r\nrates = kzalloc(sizeof(*rates), GFP_ATOMIC);\r\nif (!rates)\r\nreturn;\r\nminstrel_ht_set_rate(mp, mi, rates, i++, mi->max_tp_rate);\r\nif (mp->hw->max_rates >= 3) {\r\nminstrel_ht_set_rate(mp, mi, rates, i++, mi->max_tp_rate2);\r\n}\r\nif (mp->hw->max_rates >= 2) {\r\nminstrel_ht_set_rate(mp, mi, rates, i++, mi->max_prob_rate);\r\n}\r\nrates->rate[i].idx = -1;\r\nrate_control_set_rates(mp->hw, mi->sta, rates);\r\n}\r\nstatic inline int\r\nminstrel_get_duration(int index)\r\n{\r\nconst struct mcs_group *group = &minstrel_mcs_groups[index / MCS_GROUP_RATES];\r\nreturn group->duration[index % MCS_GROUP_RATES];\r\n}\r\nstatic int\r\nminstrel_get_sample_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)\r\n{\r\nstruct minstrel_rate_stats *mr;\r\nstruct minstrel_mcs_group_data *mg;\r\nunsigned int sample_dur, sample_group;\r\nint sample_idx = 0;\r\nif (mi->sample_wait > 0) {\r\nmi->sample_wait--;\r\nreturn -1;\r\n}\r\nif (!mi->sample_tries)\r\nreturn -1;\r\nsample_group = mi->sample_group;\r\nmg = &mi->groups[sample_group];\r\nsample_idx = sample_table[mg->column][mg->index];\r\nminstrel_next_sample_idx(mi);\r\nif (!(mg->supported & BIT(sample_idx)))\r\nreturn -1;\r\nmr = &mg->rates[sample_idx];\r\nsample_idx += sample_group * MCS_GROUP_RATES;\r\nif (sample_idx == mi->max_tp_rate ||\r\nsample_idx == mi->max_tp_rate2 ||\r\nsample_idx == mi->max_prob_rate)\r\nreturn -1;\r\nif (mr->probability > MINSTREL_FRAC(95, 100))\r\nreturn -1;\r\nsample_dur = minstrel_get_duration(sample_idx);\r\nif (sample_dur >= minstrel_get_duration(mi->max_tp_rate2) &&\r\n(mi->max_prob_streams <\r\nminstrel_mcs_groups[sample_group].streams ||\r\nsample_dur >= minstrel_get_duration(mi->max_prob_rate))) {\r\nif (mr->sample_skipped < 20)\r\nreturn -1;\r\nif (mi->sample_slow++ > 2)\r\nreturn -1;\r\n}\r\nmi->sample_tries--;\r\nreturn sample_idx;\r\n}\r\nstatic void\r\nminstrel_ht_check_cck_shortpreamble(struct minstrel_priv *mp,\r\nstruct minstrel_ht_sta *mi, bool val)\r\n{\r\nu8 supported = mi->groups[MINSTREL_CCK_GROUP].supported;\r\nif (!supported || !mi->cck_supported_short)\r\nreturn;\r\nif (supported & (mi->cck_supported_short << (val * 4)))\r\nreturn;\r\nsupported ^= mi->cck_supported_short | (mi->cck_supported_short << 4);\r\nmi->groups[MINSTREL_CCK_GROUP].supported = supported;\r\n}\r\nstatic void\r\nminstrel_ht_get_rate(void *priv, struct ieee80211_sta *sta, void *priv_sta,\r\nstruct ieee80211_tx_rate_control *txrc)\r\n{\r\nconst struct mcs_group *sample_group;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(txrc->skb);\r\nstruct ieee80211_tx_rate *rate = &info->status.rates[0];\r\nstruct minstrel_ht_sta_priv *msp = priv_sta;\r\nstruct minstrel_ht_sta *mi = &msp->ht;\r\nstruct minstrel_priv *mp = priv;\r\nint sample_idx;\r\nif (rate_control_send_low(sta, priv_sta, txrc))\r\nreturn;\r\nif (!msp->is_ht)\r\nreturn mac80211_minstrel.get_rate(priv, sta, &msp->legacy, txrc);\r\ninfo->flags |= mi->tx_flags;\r\nminstrel_ht_check_cck_shortpreamble(mp, mi, txrc->short_preamble);\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\nif (mp->fixed_rate_idx != -1)\r\nreturn;\r\n#endif\r\nif (mp->hw->max_rates == 1 &&\r\n(info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO))\r\nsample_idx = -1;\r\nelse\r\nsample_idx = minstrel_get_sample_rate(mp, mi);\r\nmi->total_packets++;\r\nif (mi->total_packets == ~0) {\r\nmi->total_packets = 0;\r\nmi->sample_packets = 0;\r\n}\r\nif (sample_idx < 0)\r\nreturn;\r\nsample_group = &minstrel_mcs_groups[sample_idx / MCS_GROUP_RATES];\r\ninfo->flags |= IEEE80211_TX_CTL_RATE_CTRL_PROBE;\r\nrate->count = 1;\r\nif (sample_idx / MCS_GROUP_RATES == MINSTREL_CCK_GROUP) {\r\nint idx = sample_idx % ARRAY_SIZE(mp->cck_rates);\r\nrate->idx = mp->cck_rates[idx];\r\nrate->flags = 0;\r\nreturn;\r\n}\r\nrate->idx = sample_idx % MCS_GROUP_RATES +\r\n(sample_group->streams - 1) * 8;\r\nrate->flags = IEEE80211_TX_RC_MCS | sample_group->flags;\r\n}\r\nstatic void\r\nminstrel_ht_update_cck(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,\r\nstruct ieee80211_supported_band *sband,\r\nstruct ieee80211_sta *sta)\r\n{\r\nint i;\r\nif (sband->band != IEEE80211_BAND_2GHZ)\r\nreturn;\r\nif (!(mp->hw->flags & IEEE80211_HW_SUPPORTS_HT_CCK_RATES))\r\nreturn;\r\nmi->cck_supported = 0;\r\nmi->cck_supported_short = 0;\r\nfor (i = 0; i < 4; i++) {\r\nif (!rate_supported(sta, sband->band, mp->cck_rates[i]))\r\ncontinue;\r\nmi->cck_supported |= BIT(i);\r\nif (sband->bitrates[i].flags & IEEE80211_RATE_SHORT_PREAMBLE)\r\nmi->cck_supported_short |= BIT(i);\r\n}\r\nmi->groups[MINSTREL_CCK_GROUP].supported = mi->cck_supported;\r\n}\r\nstatic void\r\nminstrel_ht_update_caps(void *priv, struct ieee80211_supported_band *sband,\r\nstruct cfg80211_chan_def *chandef,\r\nstruct ieee80211_sta *sta, void *priv_sta)\r\n{\r\nstruct minstrel_priv *mp = priv;\r\nstruct minstrel_ht_sta_priv *msp = priv_sta;\r\nstruct minstrel_ht_sta *mi = &msp->ht;\r\nstruct ieee80211_mcs_info *mcs = &sta->ht_cap.mcs;\r\nu16 sta_cap = sta->ht_cap.cap;\r\nint n_supported = 0;\r\nint ack_dur;\r\nint stbc;\r\nint i;\r\nif (!sta->ht_cap.ht_supported)\r\ngoto use_legacy;\r\nBUILD_BUG_ON(ARRAY_SIZE(minstrel_mcs_groups) !=\r\nMINSTREL_MAX_STREAMS * MINSTREL_STREAM_GROUPS + 1);\r\nmsp->is_ht = true;\r\nmemset(mi, 0, sizeof(*mi));\r\nmi->sta = sta;\r\nmi->stats_update = jiffies;\r\nack_dur = ieee80211_frame_duration(sband->band, 10, 60, 1, 1, 0);\r\nmi->overhead = ieee80211_frame_duration(sband->band, 0, 60, 1, 1, 0);\r\nmi->overhead += ack_dur;\r\nmi->overhead_rtscts = mi->overhead + 2 * ack_dur;\r\nmi->avg_ampdu_len = MINSTREL_FRAC(1, 1);\r\nif (mp->has_mrr) {\r\nmi->sample_count = 16;\r\nmi->sample_wait = 0;\r\n} else {\r\nmi->sample_count = 8;\r\nmi->sample_wait = 8;\r\n}\r\nmi->sample_tries = 4;\r\nstbc = (sta_cap & IEEE80211_HT_CAP_RX_STBC) >>\r\nIEEE80211_HT_CAP_RX_STBC_SHIFT;\r\nmi->tx_flags |= stbc << IEEE80211_TX_CTL_STBC_SHIFT;\r\nif (sta_cap & IEEE80211_HT_CAP_LDPC_CODING)\r\nmi->tx_flags |= IEEE80211_TX_CTL_LDPC;\r\nfor (i = 0; i < ARRAY_SIZE(mi->groups); i++) {\r\nmi->groups[i].supported = 0;\r\nif (i == MINSTREL_CCK_GROUP) {\r\nminstrel_ht_update_cck(mp, mi, sband, sta);\r\ncontinue;\r\n}\r\nif (minstrel_mcs_groups[i].flags & IEEE80211_TX_RC_SHORT_GI) {\r\nif (minstrel_mcs_groups[i].flags & IEEE80211_TX_RC_40_MHZ_WIDTH) {\r\nif (!(sta_cap & IEEE80211_HT_CAP_SGI_40))\r\ncontinue;\r\n} else {\r\nif (!(sta_cap & IEEE80211_HT_CAP_SGI_20))\r\ncontinue;\r\n}\r\n}\r\nif (minstrel_mcs_groups[i].flags & IEEE80211_TX_RC_40_MHZ_WIDTH &&\r\nsta->bandwidth < IEEE80211_STA_RX_BW_40)\r\ncontinue;\r\nif (sta->smps_mode == IEEE80211_SMPS_STATIC &&\r\nminstrel_mcs_groups[i].streams > 1)\r\ncontinue;\r\nmi->groups[i].supported =\r\nmcs->rx_mask[minstrel_mcs_groups[i].streams - 1];\r\nif (mi->groups[i].supported)\r\nn_supported++;\r\n}\r\nif (!n_supported)\r\ngoto use_legacy;\r\nminstrel_ht_update_stats(mp, mi);\r\nminstrel_ht_update_rates(mp, mi);\r\nreturn;\r\nuse_legacy:\r\nmsp->is_ht = false;\r\nmemset(&msp->legacy, 0, sizeof(msp->legacy));\r\nmsp->legacy.r = msp->ratelist;\r\nmsp->legacy.sample_table = msp->sample_table;\r\nreturn mac80211_minstrel.rate_init(priv, sband, chandef, sta,\r\n&msp->legacy);\r\n}\r\nstatic void\r\nminstrel_ht_rate_init(void *priv, struct ieee80211_supported_band *sband,\r\nstruct cfg80211_chan_def *chandef,\r\nstruct ieee80211_sta *sta, void *priv_sta)\r\n{\r\nminstrel_ht_update_caps(priv, sband, chandef, sta, priv_sta);\r\n}\r\nstatic void\r\nminstrel_ht_rate_update(void *priv, struct ieee80211_supported_band *sband,\r\nstruct cfg80211_chan_def *chandef,\r\nstruct ieee80211_sta *sta, void *priv_sta,\r\nu32 changed)\r\n{\r\nminstrel_ht_update_caps(priv, sband, chandef, sta, priv_sta);\r\n}\r\nstatic void *\r\nminstrel_ht_alloc_sta(void *priv, struct ieee80211_sta *sta, gfp_t gfp)\r\n{\r\nstruct ieee80211_supported_band *sband;\r\nstruct minstrel_ht_sta_priv *msp;\r\nstruct minstrel_priv *mp = priv;\r\nstruct ieee80211_hw *hw = mp->hw;\r\nint max_rates = 0;\r\nint i;\r\nfor (i = 0; i < IEEE80211_NUM_BANDS; i++) {\r\nsband = hw->wiphy->bands[i];\r\nif (sband && sband->n_bitrates > max_rates)\r\nmax_rates = sband->n_bitrates;\r\n}\r\nmsp = kzalloc(sizeof(*msp), gfp);\r\nif (!msp)\r\nreturn NULL;\r\nmsp->ratelist = kzalloc(sizeof(struct minstrel_rate) * max_rates, gfp);\r\nif (!msp->ratelist)\r\ngoto error;\r\nmsp->sample_table = kmalloc(SAMPLE_COLUMNS * max_rates, gfp);\r\nif (!msp->sample_table)\r\ngoto error1;\r\nreturn msp;\r\nerror1:\r\nkfree(msp->ratelist);\r\nerror:\r\nkfree(msp);\r\nreturn NULL;\r\n}\r\nstatic void\r\nminstrel_ht_free_sta(void *priv, struct ieee80211_sta *sta, void *priv_sta)\r\n{\r\nstruct minstrel_ht_sta_priv *msp = priv_sta;\r\nkfree(msp->sample_table);\r\nkfree(msp->ratelist);\r\nkfree(msp);\r\n}\r\nstatic void *\r\nminstrel_ht_alloc(struct ieee80211_hw *hw, struct dentry *debugfsdir)\r\n{\r\nreturn mac80211_minstrel.alloc(hw, debugfsdir);\r\n}\r\nstatic void\r\nminstrel_ht_free(void *priv)\r\n{\r\nmac80211_minstrel.free(priv);\r\n}\r\nstatic u32 minstrel_ht_get_expected_throughput(void *priv_sta)\r\n{\r\nstruct minstrel_ht_sta_priv *msp = priv_sta;\r\nstruct minstrel_ht_sta *mi = &msp->ht;\r\nint i, j;\r\nif (!msp->is_ht)\r\nreturn mac80211_minstrel.get_expected_throughput(priv_sta);\r\ni = mi->max_tp_rate / MCS_GROUP_RATES;\r\nj = mi->max_tp_rate % MCS_GROUP_RATES;\r\nreturn mi->groups[i].rates[j].cur_tp * AVG_PKT_SIZE * 8 / 1024;\r\n}\r\nstatic void __init init_sample_table(void)\r\n{\r\nint col, i, new_idx;\r\nu8 rnd[MCS_GROUP_RATES];\r\nmemset(sample_table, 0xff, sizeof(sample_table));\r\nfor (col = 0; col < SAMPLE_COLUMNS; col++) {\r\nprandom_bytes(rnd, sizeof(rnd));\r\nfor (i = 0; i < MCS_GROUP_RATES; i++) {\r\nnew_idx = (i + rnd[i]) % MCS_GROUP_RATES;\r\nwhile (sample_table[col][new_idx] != 0xff)\r\nnew_idx = (new_idx + 1) % MCS_GROUP_RATES;\r\nsample_table[col][new_idx] = i;\r\n}\r\n}\r\n}\r\nint __init\r\nrc80211_minstrel_ht_init(void)\r\n{\r\ninit_sample_table();\r\nreturn ieee80211_rate_control_register(&mac80211_minstrel_ht);\r\n}\r\nvoid\r\nrc80211_minstrel_ht_exit(void)\r\n{\r\nieee80211_rate_control_unregister(&mac80211_minstrel_ht);\r\n}
