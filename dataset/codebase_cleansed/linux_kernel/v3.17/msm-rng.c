static int msm_rng_enable(struct hwrng *hwrng, int enable)\r\n{\r\nstruct msm_rng *rng = to_msm_rng(hwrng);\r\nu32 val;\r\nint ret;\r\nret = clk_prepare_enable(rng->clk);\r\nif (ret)\r\nreturn ret;\r\nif (enable) {\r\nval = readl_relaxed(rng->base + PRNG_CONFIG);\r\nif (val & PRNG_CONFIG_HW_ENABLE)\r\ngoto already_enabled;\r\nval = readl_relaxed(rng->base + PRNG_LFSR_CFG);\r\nval &= ~PRNG_LFSR_CFG_MASK;\r\nval |= PRNG_LFSR_CFG_CLOCKS;\r\nwritel(val, rng->base + PRNG_LFSR_CFG);\r\nval = readl_relaxed(rng->base + PRNG_CONFIG);\r\nval |= PRNG_CONFIG_HW_ENABLE;\r\nwritel(val, rng->base + PRNG_CONFIG);\r\n} else {\r\nval = readl_relaxed(rng->base + PRNG_CONFIG);\r\nval &= ~PRNG_CONFIG_HW_ENABLE;\r\nwritel(val, rng->base + PRNG_CONFIG);\r\n}\r\nalready_enabled:\r\nclk_disable_unprepare(rng->clk);\r\nreturn 0;\r\n}\r\nstatic int msm_rng_read(struct hwrng *hwrng, void *data, size_t max, bool wait)\r\n{\r\nstruct msm_rng *rng = to_msm_rng(hwrng);\r\nsize_t currsize = 0;\r\nu32 *retdata = data;\r\nsize_t maxsize;\r\nint ret;\r\nu32 val;\r\nmaxsize = min_t(size_t, MAX_HW_FIFO_SIZE, max);\r\nif (maxsize < WORD_SZ)\r\nreturn 0;\r\nret = clk_prepare_enable(rng->clk);\r\nif (ret)\r\nreturn ret;\r\ndo {\r\nval = readl_relaxed(rng->base + PRNG_STATUS);\r\nif (!(val & PRNG_STATUS_DATA_AVAIL))\r\nbreak;\r\nval = readl_relaxed(rng->base + PRNG_DATA_OUT);\r\nif (!val)\r\nbreak;\r\n*retdata++ = val;\r\ncurrsize += WORD_SZ;\r\nif ((maxsize - currsize) < WORD_SZ)\r\nbreak;\r\n} while (currsize < maxsize);\r\nclk_disable_unprepare(rng->clk);\r\nreturn currsize;\r\n}\r\nstatic int msm_rng_init(struct hwrng *hwrng)\r\n{\r\nreturn msm_rng_enable(hwrng, 1);\r\n}\r\nstatic void msm_rng_cleanup(struct hwrng *hwrng)\r\n{\r\nmsm_rng_enable(hwrng, 0);\r\n}\r\nstatic int msm_rng_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct msm_rng *rng;\r\nint ret;\r\nrng = devm_kzalloc(&pdev->dev, sizeof(*rng), GFP_KERNEL);\r\nif (!rng)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, rng);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrng->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(rng->base))\r\nreturn PTR_ERR(rng->base);\r\nrng->clk = devm_clk_get(&pdev->dev, "core");\r\nif (IS_ERR(rng->clk))\r\nreturn PTR_ERR(rng->clk);\r\nrng->hwrng.name = KBUILD_MODNAME,\r\nrng->hwrng.init = msm_rng_init,\r\nrng->hwrng.cleanup = msm_rng_cleanup,\r\nrng->hwrng.read = msm_rng_read,\r\nret = hwrng_register(&rng->hwrng);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register hwrng\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int msm_rng_remove(struct platform_device *pdev)\r\n{\r\nstruct msm_rng *rng = platform_get_drvdata(pdev);\r\nhwrng_unregister(&rng->hwrng);\r\nreturn 0;\r\n}
