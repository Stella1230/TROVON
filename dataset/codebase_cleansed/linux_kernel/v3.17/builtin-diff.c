static int setup_compute_opt_wdiff(char *opt)\r\n{\r\nchar *w1_str = opt;\r\nchar *w2_str;\r\nint ret = -EINVAL;\r\nif (!opt)\r\ngoto out;\r\nw2_str = strchr(opt, ',');\r\nif (!w2_str)\r\ngoto out;\r\n*w2_str++ = 0x0;\r\nif (!*w2_str)\r\ngoto out;\r\ncompute_wdiff_w1 = strtol(w1_str, NULL, 10);\r\ncompute_wdiff_w2 = strtol(w2_str, NULL, 10);\r\nif (!compute_wdiff_w1 || !compute_wdiff_w2)\r\ngoto out;\r\npr_debug("compute wdiff w1(%" PRId64 ") w2(%" PRId64 ")\n",\r\ncompute_wdiff_w1, compute_wdiff_w2);\r\nret = 0;\r\nout:\r\nif (ret)\r\npr_err("Failed: wrong weight data, use 'wdiff:w1,w2'\n");\r\nreturn ret;\r\n}\r\nstatic int setup_compute_opt(char *opt)\r\n{\r\nif (compute == COMPUTE_WEIGHTED_DIFF)\r\nreturn setup_compute_opt_wdiff(opt);\r\nif (opt) {\r\npr_err("Failed: extra option specified '%s'", opt);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int setup_compute(const struct option *opt, const char *str,\r\nint unset __maybe_unused)\r\n{\r\nint *cp = (int *) opt->value;\r\nchar *cstr = (char *) str;\r\nchar buf[50];\r\nunsigned i;\r\nchar *option;\r\nif (!str) {\r\n*cp = COMPUTE_DELTA;\r\nreturn 0;\r\n}\r\noption = strchr(str, ':');\r\nif (option) {\r\nunsigned len = option++ - str;\r\nif (len >= sizeof(buf))\r\nreturn -EINVAL;\r\nstrncpy(buf, str, len);\r\nbuf[len] = 0x0;\r\ncstr = buf;\r\n}\r\nfor (i = 0; i < COMPUTE_MAX; i++)\r\nif (!strcmp(cstr, compute_names[i])) {\r\n*cp = i;\r\nreturn setup_compute_opt(option);\r\n}\r\npr_err("Failed: '%s' is not computation method "\r\n"(use 'delta','ratio' or 'wdiff')\n", str);\r\nreturn -EINVAL;\r\n}\r\nstatic double period_percent(struct hist_entry *he, u64 period)\r\n{\r\nu64 total = hists__total_period(he->hists);\r\nreturn (period * 100.0) / total;\r\n}\r\nstatic double compute_delta(struct hist_entry *he, struct hist_entry *pair)\r\n{\r\ndouble old_percent = period_percent(he, he->stat.period);\r\ndouble new_percent = period_percent(pair, pair->stat.period);\r\npair->diff.period_ratio_delta = new_percent - old_percent;\r\npair->diff.computed = true;\r\nreturn pair->diff.period_ratio_delta;\r\n}\r\nstatic double compute_ratio(struct hist_entry *he, struct hist_entry *pair)\r\n{\r\ndouble old_period = he->stat.period ?: 1;\r\ndouble new_period = pair->stat.period;\r\npair->diff.computed = true;\r\npair->diff.period_ratio = new_period / old_period;\r\nreturn pair->diff.period_ratio;\r\n}\r\nstatic s64 compute_wdiff(struct hist_entry *he, struct hist_entry *pair)\r\n{\r\nu64 old_period = he->stat.period;\r\nu64 new_period = pair->stat.period;\r\npair->diff.computed = true;\r\npair->diff.wdiff = new_period * compute_wdiff_w2 -\r\nold_period * compute_wdiff_w1;\r\nreturn pair->diff.wdiff;\r\n}\r\nstatic int formula_delta(struct hist_entry *he, struct hist_entry *pair,\r\nchar *buf, size_t size)\r\n{\r\nu64 he_total = he->hists->stats.total_period;\r\nu64 pair_total = pair->hists->stats.total_period;\r\nif (symbol_conf.filter_relative) {\r\nhe_total = he->hists->stats.total_non_filtered_period;\r\npair_total = pair->hists->stats.total_non_filtered_period;\r\n}\r\nreturn scnprintf(buf, size,\r\n"(%" PRIu64 " * 100 / %" PRIu64 ") - "\r\n"(%" PRIu64 " * 100 / %" PRIu64 ")",\r\npair->stat.period, pair_total,\r\nhe->stat.period, he_total);\r\n}\r\nstatic int formula_ratio(struct hist_entry *he, struct hist_entry *pair,\r\nchar *buf, size_t size)\r\n{\r\ndouble old_period = he->stat.period;\r\ndouble new_period = pair->stat.period;\r\nreturn scnprintf(buf, size, "%.0F / %.0F", new_period, old_period);\r\n}\r\nstatic int formula_wdiff(struct hist_entry *he, struct hist_entry *pair,\r\nchar *buf, size_t size)\r\n{\r\nu64 old_period = he->stat.period;\r\nu64 new_period = pair->stat.period;\r\nreturn scnprintf(buf, size,\r\n"(%" PRIu64 " * " "%" PRId64 ") - (%" PRIu64 " * " "%" PRId64 ")",\r\nnew_period, compute_wdiff_w2, old_period, compute_wdiff_w1);\r\n}\r\nstatic int formula_fprintf(struct hist_entry *he, struct hist_entry *pair,\r\nchar *buf, size_t size)\r\n{\r\nswitch (compute) {\r\ncase COMPUTE_DELTA:\r\nreturn formula_delta(he, pair, buf, size);\r\ncase COMPUTE_RATIO:\r\nreturn formula_ratio(he, pair, buf, size);\r\ncase COMPUTE_WEIGHTED_DIFF:\r\nreturn formula_wdiff(he, pair, buf, size);\r\ndefault:\r\nBUG_ON(1);\r\n}\r\nreturn -1;\r\n}\r\nstatic int hists__add_entry(struct hists *hists,\r\nstruct addr_location *al, u64 period,\r\nu64 weight, u64 transaction)\r\n{\r\nif (__hists__add_entry(hists, al, NULL, NULL, NULL, period, weight,\r\ntransaction, true) != NULL)\r\nreturn 0;\r\nreturn -ENOMEM;\r\n}\r\nstatic int diff__process_sample_event(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine)\r\n{\r\nstruct addr_location al;\r\nif (perf_event__preprocess_sample(event, machine, &al, sample) < 0) {\r\npr_warning("problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\nreturn -1;\r\n}\r\nif (hists__add_entry(&evsel->hists, &al, sample->period,\r\nsample->weight, sample->transaction)) {\r\npr_warning("problem incrementing symbol period, skipping event\n");\r\nreturn -1;\r\n}\r\nevsel->hists.stats.total_period += sample->period;\r\nif (!al.filtered)\r\nevsel->hists.stats.total_non_filtered_period += sample->period;\r\nreturn 0;\r\n}\r\nstatic struct perf_evsel *evsel_match(struct perf_evsel *evsel,\r\nstruct perf_evlist *evlist)\r\n{\r\nstruct perf_evsel *e;\r\nevlist__for_each(evlist, e) {\r\nif (perf_evsel__match2(evsel, e))\r\nreturn e;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void perf_evlist__collapse_resort(struct perf_evlist *evlist)\r\n{\r\nstruct perf_evsel *evsel;\r\nevlist__for_each(evlist, evsel) {\r\nstruct hists *hists = &evsel->hists;\r\nhists__collapse_resort(hists, NULL);\r\n}\r\n}\r\nstatic struct hist_entry*\r\nget_pair_data(struct hist_entry *he, struct data__file *d)\r\n{\r\nif (hist_entry__has_pairs(he)) {\r\nstruct hist_entry *pair;\r\nlist_for_each_entry(pair, &he->pairs.head, pairs.node)\r\nif (pair->hists == d->hists)\r\nreturn pair;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct hist_entry*\r\nget_pair_fmt(struct hist_entry *he, struct diff_hpp_fmt *dfmt)\r\n{\r\nvoid *ptr = dfmt - dfmt->idx;\r\nstruct data__file *d = container_of(ptr, struct data__file, fmt);\r\nreturn get_pair_data(he, d);\r\n}\r\nstatic void hists__baseline_only(struct hists *hists)\r\n{\r\nstruct rb_root *root;\r\nstruct rb_node *next;\r\nif (sort__need_collapse)\r\nroot = &hists->entries_collapsed;\r\nelse\r\nroot = hists->entries_in;\r\nnext = rb_first(root);\r\nwhile (next != NULL) {\r\nstruct hist_entry *he = rb_entry(next, struct hist_entry, rb_node_in);\r\nnext = rb_next(&he->rb_node_in);\r\nif (!hist_entry__next_pair(he)) {\r\nrb_erase(&he->rb_node_in, root);\r\nhist_entry__free(he);\r\n}\r\n}\r\n}\r\nstatic void hists__precompute(struct hists *hists)\r\n{\r\nstruct rb_root *root;\r\nstruct rb_node *next;\r\nif (sort__need_collapse)\r\nroot = &hists->entries_collapsed;\r\nelse\r\nroot = hists->entries_in;\r\nnext = rb_first(root);\r\nwhile (next != NULL) {\r\nstruct hist_entry *he, *pair;\r\nhe = rb_entry(next, struct hist_entry, rb_node_in);\r\nnext = rb_next(&he->rb_node_in);\r\npair = get_pair_data(he, &data__files[sort_compute]);\r\nif (!pair)\r\ncontinue;\r\nswitch (compute) {\r\ncase COMPUTE_DELTA:\r\ncompute_delta(he, pair);\r\nbreak;\r\ncase COMPUTE_RATIO:\r\ncompute_ratio(he, pair);\r\nbreak;\r\ncase COMPUTE_WEIGHTED_DIFF:\r\ncompute_wdiff(he, pair);\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\n}\r\n}\r\n}\r\nstatic int64_t cmp_doubles(double l, double r)\r\n{\r\nif (l > r)\r\nreturn -1;\r\nelse if (l < r)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int64_t\r\n__hist_entry__cmp_compute(struct hist_entry *left, struct hist_entry *right,\r\nint c)\r\n{\r\nswitch (c) {\r\ncase COMPUTE_DELTA:\r\n{\r\ndouble l = left->diff.period_ratio_delta;\r\ndouble r = right->diff.period_ratio_delta;\r\nreturn cmp_doubles(l, r);\r\n}\r\ncase COMPUTE_RATIO:\r\n{\r\ndouble l = left->diff.period_ratio;\r\ndouble r = right->diff.period_ratio;\r\nreturn cmp_doubles(l, r);\r\n}\r\ncase COMPUTE_WEIGHTED_DIFF:\r\n{\r\ns64 l = left->diff.wdiff;\r\ns64 r = right->diff.wdiff;\r\nreturn r - l;\r\n}\r\ndefault:\r\nBUG_ON(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int64_t\r\nhist_entry__cmp_compute(struct hist_entry *left, struct hist_entry *right,\r\nint c)\r\n{\r\nbool pairs_left = hist_entry__has_pairs(left);\r\nbool pairs_right = hist_entry__has_pairs(right);\r\nstruct hist_entry *p_right, *p_left;\r\nif (!pairs_left && !pairs_right)\r\nreturn 0;\r\nif (!pairs_left || !pairs_right)\r\nreturn pairs_left ? -1 : 1;\r\np_left = get_pair_data(left, &data__files[sort_compute]);\r\np_right = get_pair_data(right, &data__files[sort_compute]);\r\nif (!p_left && !p_right)\r\nreturn 0;\r\nif (!p_left || !p_right)\r\nreturn p_left ? -1 : 1;\r\nreturn __hist_entry__cmp_compute(p_left, p_right, c);\r\n}\r\nstatic void insert_hist_entry_by_compute(struct rb_root *root,\r\nstruct hist_entry *he,\r\nint c)\r\n{\r\nstruct rb_node **p = &root->rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct hist_entry *iter;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\niter = rb_entry(parent, struct hist_entry, rb_node);\r\nif (hist_entry__cmp_compute(he, iter, c) < 0)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\nrb_link_node(&he->rb_node, parent, p);\r\nrb_insert_color(&he->rb_node, root);\r\n}\r\nstatic void hists__compute_resort(struct hists *hists)\r\n{\r\nstruct rb_root *root;\r\nstruct rb_node *next;\r\nif (sort__need_collapse)\r\nroot = &hists->entries_collapsed;\r\nelse\r\nroot = hists->entries_in;\r\nhists->entries = RB_ROOT;\r\nnext = rb_first(root);\r\nhists__reset_stats(hists);\r\nhists__reset_col_len(hists);\r\nwhile (next != NULL) {\r\nstruct hist_entry *he;\r\nhe = rb_entry(next, struct hist_entry, rb_node_in);\r\nnext = rb_next(&he->rb_node_in);\r\ninsert_hist_entry_by_compute(&hists->entries, he, compute);\r\nhists__inc_stats(hists, he);\r\nif (!he->filtered)\r\nhists__calc_col_len(hists, he);\r\n}\r\n}\r\nstatic void hists__process(struct hists *hists)\r\n{\r\nif (show_baseline_only)\r\nhists__baseline_only(hists);\r\nif (sort_compute) {\r\nhists__precompute(hists);\r\nhists__compute_resort(hists);\r\n} else {\r\nhists__output_resort(hists);\r\n}\r\nhists__fprintf(hists, true, 0, 0, 0, stdout);\r\n}\r\nstatic void data__fprintf(void)\r\n{\r\nstruct data__file *d;\r\nint i;\r\nfprintf(stdout, "# Data files:\n");\r\ndata__for_each_file(i, d)\r\nfprintf(stdout, "# [%d] %s %s\n",\r\nd->idx, d->file.path,\r\n!d->idx ? "(Baseline)" : "");\r\nfprintf(stdout, "#\n");\r\n}\r\nstatic void data_process(void)\r\n{\r\nstruct perf_evlist *evlist_base = data__files[0].session->evlist;\r\nstruct perf_evsel *evsel_base;\r\nbool first = true;\r\nevlist__for_each(evlist_base, evsel_base) {\r\nstruct data__file *d;\r\nint i;\r\ndata__for_each_file_new(i, d) {\r\nstruct perf_evlist *evlist = d->session->evlist;\r\nstruct perf_evsel *evsel;\r\nevsel = evsel_match(evsel_base, evlist);\r\nif (!evsel)\r\ncontinue;\r\nd->hists = &evsel->hists;\r\nhists__match(&evsel_base->hists, &evsel->hists);\r\nif (!show_baseline_only)\r\nhists__link(&evsel_base->hists,\r\n&evsel->hists);\r\n}\r\nfprintf(stdout, "%s# Event '%s'\n#\n", first ? "" : "\n",\r\nperf_evsel__name(evsel_base));\r\nfirst = false;\r\nif (verbose || data__files_cnt > 2)\r\ndata__fprintf();\r\nhists__process(&evsel_base->hists);\r\n}\r\n}\r\nstatic void data__free(struct data__file *d)\r\n{\r\nint col;\r\nfor (col = 0; col < PERF_HPP_DIFF__MAX_INDEX; col++) {\r\nstruct diff_hpp_fmt *fmt = &d->fmt[col];\r\nzfree(&fmt->header);\r\n}\r\n}\r\nstatic int __cmd_diff(void)\r\n{\r\nstruct data__file *d;\r\nint ret = -EINVAL, i;\r\ndata__for_each_file(i, d) {\r\nd->session = perf_session__new(&d->file, false, &tool);\r\nif (!d->session) {\r\npr_err("Failed to open %s\n", d->file.path);\r\nret = -ENOMEM;\r\ngoto out_delete;\r\n}\r\nret = perf_session__process_events(d->session, &tool);\r\nif (ret) {\r\npr_err("Failed to process %s\n", d->file.path);\r\ngoto out_delete;\r\n}\r\nperf_evlist__collapse_resort(d->session->evlist);\r\n}\r\ndata_process();\r\nout_delete:\r\ndata__for_each_file(i, d) {\r\nif (d->session)\r\nperf_session__delete(d->session);\r\ndata__free(d);\r\n}\r\nfree(data__files);\r\nreturn ret;\r\n}\r\nstatic double baseline_percent(struct hist_entry *he)\r\n{\r\nu64 total = hists__total_period(he->hists);\r\nreturn 100.0 * he->stat.period / total;\r\n}\r\nstatic int hpp__color_baseline(struct perf_hpp_fmt *fmt,\r\nstruct perf_hpp *hpp, struct hist_entry *he)\r\n{\r\nstruct diff_hpp_fmt *dfmt =\r\ncontainer_of(fmt, struct diff_hpp_fmt, fmt);\r\ndouble percent = baseline_percent(he);\r\nchar pfmt[20] = " ";\r\nif (!he->dummy) {\r\nscnprintf(pfmt, 20, "%%%d.2f%%%%", dfmt->header_width - 1);\r\nreturn percent_color_snprintf(hpp->buf, hpp->size,\r\npfmt, percent);\r\n} else\r\nreturn scnprintf(hpp->buf, hpp->size, "%*s",\r\ndfmt->header_width, pfmt);\r\n}\r\nstatic int hpp__entry_baseline(struct hist_entry *he, char *buf, size_t size)\r\n{\r\ndouble percent = baseline_percent(he);\r\nconst char *fmt = symbol_conf.field_sep ? "%.2f" : "%6.2f%%";\r\nint ret = 0;\r\nif (!he->dummy)\r\nret = scnprintf(buf, size, fmt, percent);\r\nreturn ret;\r\n}\r\nstatic int __hpp__color_compare(struct perf_hpp_fmt *fmt,\r\nstruct perf_hpp *hpp, struct hist_entry *he,\r\nint comparison_method)\r\n{\r\nstruct diff_hpp_fmt *dfmt =\r\ncontainer_of(fmt, struct diff_hpp_fmt, fmt);\r\nstruct hist_entry *pair = get_pair_fmt(he, dfmt);\r\ndouble diff;\r\ns64 wdiff;\r\nchar pfmt[20] = " ";\r\nif (!pair)\r\ngoto dummy_print;\r\nswitch (comparison_method) {\r\ncase COMPUTE_DELTA:\r\nif (pair->diff.computed)\r\ndiff = pair->diff.period_ratio_delta;\r\nelse\r\ndiff = compute_delta(he, pair);\r\nif (fabs(diff) < 0.01)\r\ngoto dummy_print;\r\nscnprintf(pfmt, 20, "%%%+d.2f%%%%", dfmt->header_width - 1);\r\nreturn percent_color_snprintf(hpp->buf, hpp->size,\r\npfmt, diff);\r\ncase COMPUTE_RATIO:\r\nif (he->dummy)\r\ngoto dummy_print;\r\nif (pair->diff.computed)\r\ndiff = pair->diff.period_ratio;\r\nelse\r\ndiff = compute_ratio(he, pair);\r\nscnprintf(pfmt, 20, "%%%d.6f", dfmt->header_width);\r\nreturn value_color_snprintf(hpp->buf, hpp->size,\r\npfmt, diff);\r\ncase COMPUTE_WEIGHTED_DIFF:\r\nif (he->dummy)\r\ngoto dummy_print;\r\nif (pair->diff.computed)\r\nwdiff = pair->diff.wdiff;\r\nelse\r\nwdiff = compute_wdiff(he, pair);\r\nscnprintf(pfmt, 20, "%%14ld", dfmt->header_width);\r\nreturn color_snprintf(hpp->buf, hpp->size,\r\nget_percent_color(wdiff),\r\npfmt, wdiff);\r\ndefault:\r\nBUG_ON(1);\r\n}\r\ndummy_print:\r\nreturn scnprintf(hpp->buf, hpp->size, "%*s",\r\ndfmt->header_width, pfmt);\r\n}\r\nstatic int hpp__color_delta(struct perf_hpp_fmt *fmt,\r\nstruct perf_hpp *hpp, struct hist_entry *he)\r\n{\r\nreturn __hpp__color_compare(fmt, hpp, he, COMPUTE_DELTA);\r\n}\r\nstatic int hpp__color_ratio(struct perf_hpp_fmt *fmt,\r\nstruct perf_hpp *hpp, struct hist_entry *he)\r\n{\r\nreturn __hpp__color_compare(fmt, hpp, he, COMPUTE_RATIO);\r\n}\r\nstatic int hpp__color_wdiff(struct perf_hpp_fmt *fmt,\r\nstruct perf_hpp *hpp, struct hist_entry *he)\r\n{\r\nreturn __hpp__color_compare(fmt, hpp, he, COMPUTE_WEIGHTED_DIFF);\r\n}\r\nstatic void\r\nhpp__entry_unpair(struct hist_entry *he, int idx, char *buf, size_t size)\r\n{\r\nswitch (idx) {\r\ncase PERF_HPP_DIFF__PERIOD_BASELINE:\r\nscnprintf(buf, size, "%" PRIu64, he->stat.period);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nhpp__entry_pair(struct hist_entry *he, struct hist_entry *pair,\r\nint idx, char *buf, size_t size)\r\n{\r\ndouble diff;\r\ndouble ratio;\r\ns64 wdiff;\r\nswitch (idx) {\r\ncase PERF_HPP_DIFF__DELTA:\r\nif (pair->diff.computed)\r\ndiff = pair->diff.period_ratio_delta;\r\nelse\r\ndiff = compute_delta(he, pair);\r\nif (fabs(diff) >= 0.01)\r\nscnprintf(buf, size, "%+4.2F%%", diff);\r\nbreak;\r\ncase PERF_HPP_DIFF__RATIO:\r\nif (he->dummy)\r\nbreak;\r\nif (pair->diff.computed)\r\nratio = pair->diff.period_ratio;\r\nelse\r\nratio = compute_ratio(he, pair);\r\nif (ratio > 0.0)\r\nscnprintf(buf, size, "%14.6F", ratio);\r\nbreak;\r\ncase PERF_HPP_DIFF__WEIGHTED_DIFF:\r\nif (he->dummy)\r\nbreak;\r\nif (pair->diff.computed)\r\nwdiff = pair->diff.wdiff;\r\nelse\r\nwdiff = compute_wdiff(he, pair);\r\nif (wdiff != 0)\r\nscnprintf(buf, size, "%14ld", wdiff);\r\nbreak;\r\ncase PERF_HPP_DIFF__FORMULA:\r\nformula_fprintf(he, pair, buf, size);\r\nbreak;\r\ncase PERF_HPP_DIFF__PERIOD:\r\nscnprintf(buf, size, "%" PRIu64, pair->stat.period);\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\n};\r\n}\r\nstatic void\r\n__hpp__entry_global(struct hist_entry *he, struct diff_hpp_fmt *dfmt,\r\nchar *buf, size_t size)\r\n{\r\nstruct hist_entry *pair = get_pair_fmt(he, dfmt);\r\nint idx = dfmt->idx;\r\nif (idx == PERF_HPP_DIFF__BASELINE)\r\nhpp__entry_baseline(he, buf, size);\r\nelse {\r\nif (pair)\r\nhpp__entry_pair(he, pair, idx, buf, size);\r\nelse\r\nhpp__entry_unpair(he, idx, buf, size);\r\n}\r\n}\r\nstatic int hpp__entry_global(struct perf_hpp_fmt *_fmt, struct perf_hpp *hpp,\r\nstruct hist_entry *he)\r\n{\r\nstruct diff_hpp_fmt *dfmt =\r\ncontainer_of(_fmt, struct diff_hpp_fmt, fmt);\r\nchar buf[MAX_COL_WIDTH] = " ";\r\n__hpp__entry_global(he, dfmt, buf, MAX_COL_WIDTH);\r\nif (symbol_conf.field_sep)\r\nreturn scnprintf(hpp->buf, hpp->size, "%s", buf);\r\nelse\r\nreturn scnprintf(hpp->buf, hpp->size, "%*s",\r\ndfmt->header_width, buf);\r\n}\r\nstatic int hpp__header(struct perf_hpp_fmt *fmt, struct perf_hpp *hpp,\r\nstruct perf_evsel *evsel __maybe_unused)\r\n{\r\nstruct diff_hpp_fmt *dfmt =\r\ncontainer_of(fmt, struct diff_hpp_fmt, fmt);\r\nBUG_ON(!dfmt->header);\r\nreturn scnprintf(hpp->buf, hpp->size, dfmt->header);\r\n}\r\nstatic int hpp__width(struct perf_hpp_fmt *fmt,\r\nstruct perf_hpp *hpp __maybe_unused,\r\nstruct perf_evsel *evsel __maybe_unused)\r\n{\r\nstruct diff_hpp_fmt *dfmt =\r\ncontainer_of(fmt, struct diff_hpp_fmt, fmt);\r\nBUG_ON(dfmt->header_width <= 0);\r\nreturn dfmt->header_width;\r\n}\r\nstatic void init_header(struct data__file *d, struct diff_hpp_fmt *dfmt)\r\n{\r\n#define MAX_HEADER_NAME 100\r\nchar buf_indent[MAX_HEADER_NAME];\r\nchar buf[MAX_HEADER_NAME];\r\nconst char *header = NULL;\r\nint width = 0;\r\nBUG_ON(dfmt->idx >= PERF_HPP_DIFF__MAX_INDEX);\r\nheader = columns[dfmt->idx].name;\r\nwidth = columns[dfmt->idx].width;\r\nBUG_ON(!header);\r\nif (data__files_cnt > 2)\r\nscnprintf(buf, MAX_HEADER_NAME, "%s/%d", header, d->idx);\r\n#define NAME (data__files_cnt > 2 ? buf : header)\r\ndfmt->header_width = width;\r\nwidth = (int) strlen(NAME);\r\nif (dfmt->header_width < width)\r\ndfmt->header_width = width;\r\nscnprintf(buf_indent, MAX_HEADER_NAME, "%*s",\r\ndfmt->header_width, NAME);\r\ndfmt->header = strdup(buf_indent);\r\n#undef MAX_HEADER_NAME\r\n#undef NAME\r\n}\r\nstatic void data__hpp_register(struct data__file *d, int idx)\r\n{\r\nstruct diff_hpp_fmt *dfmt = &d->fmt[idx];\r\nstruct perf_hpp_fmt *fmt = &dfmt->fmt;\r\ndfmt->idx = idx;\r\nfmt->header = hpp__header;\r\nfmt->width = hpp__width;\r\nfmt->entry = hpp__entry_global;\r\nswitch (idx) {\r\ncase PERF_HPP_DIFF__BASELINE:\r\nfmt->color = hpp__color_baseline;\r\nbreak;\r\ncase PERF_HPP_DIFF__DELTA:\r\nfmt->color = hpp__color_delta;\r\nbreak;\r\ncase PERF_HPP_DIFF__RATIO:\r\nfmt->color = hpp__color_ratio;\r\nbreak;\r\ncase PERF_HPP_DIFF__WEIGHTED_DIFF:\r\nfmt->color = hpp__color_wdiff;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ninit_header(d, dfmt);\r\nperf_hpp__column_register(fmt);\r\n}\r\nstatic void ui_init(void)\r\n{\r\nstruct data__file *d;\r\nint i;\r\ndata__for_each_file(i, d) {\r\ndata__hpp_register(d, i ? compute_2_hpp[compute] :\r\nPERF_HPP_DIFF__BASELINE);\r\nif (show_formula && i)\r\ndata__hpp_register(d, PERF_HPP_DIFF__FORMULA);\r\nif (show_period)\r\ndata__hpp_register(d, i ? PERF_HPP_DIFF__PERIOD :\r\nPERF_HPP_DIFF__PERIOD_BASELINE);\r\n}\r\n}\r\nstatic int data_init(int argc, const char **argv)\r\n{\r\nstruct data__file *d;\r\nstatic const char *defaults[] = {\r\n"perf.data.old",\r\n"perf.data",\r\n};\r\nbool use_default = true;\r\nint i;\r\ndata__files_cnt = 2;\r\nif (argc) {\r\nif (argc == 1)\r\ndefaults[1] = argv[0];\r\nelse {\r\ndata__files_cnt = argc;\r\nuse_default = false;\r\n}\r\n} else if (perf_guest) {\r\ndefaults[0] = "perf.data.host";\r\ndefaults[1] = "perf.data.guest";\r\n}\r\nif (sort_compute >= (unsigned int) data__files_cnt) {\r\npr_err("Order option out of limit.\n");\r\nreturn -EINVAL;\r\n}\r\ndata__files = zalloc(sizeof(*data__files) * data__files_cnt);\r\nif (!data__files)\r\nreturn -ENOMEM;\r\ndata__for_each_file(i, d) {\r\nstruct perf_data_file *file = &d->file;\r\nfile->path = use_default ? defaults[i] : argv[i];\r\nfile->mode = PERF_DATA_MODE_READ,\r\nfile->force = force,\r\nd->idx = i;\r\n}\r\nreturn 0;\r\n}\r\nint cmd_diff(int argc, const char **argv, const char *prefix __maybe_unused)\r\n{\r\nperf_config(perf_default_config, NULL);\r\nargc = parse_options(argc, argv, options, diff_usage, 0);\r\nif (symbol__init() < 0)\r\nreturn -1;\r\nif (data_init(argc, argv) < 0)\r\nreturn -1;\r\nui_init();\r\nsort__mode = SORT_MODE__DIFF;\r\nif (setup_sorting() < 0)\r\nusage_with_options(diff_usage, options);\r\nsetup_pager();\r\nsort__setup_elide(NULL);\r\nreturn __cmd_diff();\r\n}
