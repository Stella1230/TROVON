static u32 ryxr_calc(struct rtc_time *tm)\r\n{\r\nreturn ((tm->tm_year + 1900) << RYxR_YEAR_S)\r\n| ((tm->tm_mon + 1) << RYxR_MONTH_S)\r\n| tm->tm_mday;\r\n}\r\nstatic u32 rdxr_calc(struct rtc_time *tm)\r\n{\r\nreturn ((((tm->tm_mday + 6) / 7) << RDxR_WOM_S) & RDxR_WOM_MASK)\r\n| (((tm->tm_wday + 1) << RDxR_DOW_S) & RDxR_DOW_MASK)\r\n| (tm->tm_hour << RDxR_HOUR_S)\r\n| (tm->tm_min << RDxR_MIN_S)\r\n| tm->tm_sec;\r\n}\r\nstatic void tm_calc(u32 rycr, u32 rdcr, struct rtc_time *tm)\r\n{\r\ntm->tm_year = ((rycr & RYxR_YEAR_MASK) >> RYxR_YEAR_S) - 1900;\r\ntm->tm_mon = (((rycr & RYxR_MONTH_MASK) >> RYxR_MONTH_S)) - 1;\r\ntm->tm_mday = (rycr & RYxR_DAY_MASK);\r\ntm->tm_wday = ((rycr & RDxR_DOW_MASK) >> RDxR_DOW_S) - 1;\r\ntm->tm_hour = (rdcr & RDxR_HOUR_MASK) >> RDxR_HOUR_S;\r\ntm->tm_min = (rdcr & RDxR_MIN_MASK) >> RDxR_MIN_S;\r\ntm->tm_sec = rdcr & RDxR_SEC_MASK;\r\n}\r\nstatic void rtsr_clear_bits(struct pxa_rtc *pxa_rtc, u32 mask)\r\n{\r\nu32 rtsr;\r\nrtsr = rtc_readl(pxa_rtc, RTSR);\r\nrtsr &= ~RTSR_TRIG_MASK;\r\nrtsr &= ~mask;\r\nrtc_writel(pxa_rtc, RTSR, rtsr);\r\n}\r\nstatic void rtsr_set_bits(struct pxa_rtc *pxa_rtc, u32 mask)\r\n{\r\nu32 rtsr;\r\nrtsr = rtc_readl(pxa_rtc, RTSR);\r\nrtsr &= ~RTSR_TRIG_MASK;\r\nrtsr |= mask;\r\nrtc_writel(pxa_rtc, RTSR, rtsr);\r\n}\r\nstatic irqreturn_t pxa_rtc_irq(int irq, void *dev_id)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev_id);\r\nstruct pxa_rtc *pxa_rtc = platform_get_drvdata(pdev);\r\nu32 rtsr;\r\nunsigned long events = 0;\r\nspin_lock(&pxa_rtc->lock);\r\nrtsr = rtc_readl(pxa_rtc, RTSR);\r\nrtc_writel(pxa_rtc, RTSR, rtsr);\r\nrtsr_clear_bits(pxa_rtc, RTSR_RDALE1 | RTSR_PIALE | RTSR_HZE);\r\nif (rtsr & RTSR_RDAL1)\r\nrtsr &= ~RTSR_RDALE1;\r\nif (rtsr & RTSR_RDAL1)\r\nevents |= RTC_AF | RTC_IRQF;\r\nif (rtsr & RTSR_HZ)\r\nevents |= RTC_UF | RTC_IRQF;\r\nif (rtsr & RTSR_PIAL)\r\nevents |= RTC_PF | RTC_IRQF;\r\nrtc_update_irq(pxa_rtc->rtc, 1, events);\r\nrtc_writel(pxa_rtc, RTSR, rtsr & ~RTSR_TRIG_MASK);\r\nspin_unlock(&pxa_rtc->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pxa_rtc_open(struct device *dev)\r\n{\r\nstruct pxa_rtc *pxa_rtc = dev_get_drvdata(dev);\r\nint ret;\r\nret = request_irq(pxa_rtc->irq_1Hz, pxa_rtc_irq, 0,\r\n"rtc 1Hz", dev);\r\nif (ret < 0) {\r\ndev_err(dev, "can't get irq %i, err %d\n", pxa_rtc->irq_1Hz,\r\nret);\r\ngoto err_irq_1Hz;\r\n}\r\nret = request_irq(pxa_rtc->irq_Alrm, pxa_rtc_irq, 0,\r\n"rtc Alrm", dev);\r\nif (ret < 0) {\r\ndev_err(dev, "can't get irq %i, err %d\n", pxa_rtc->irq_Alrm,\r\nret);\r\ngoto err_irq_Alrm;\r\n}\r\nreturn 0;\r\nerr_irq_Alrm:\r\nfree_irq(pxa_rtc->irq_1Hz, dev);\r\nerr_irq_1Hz:\r\nreturn ret;\r\n}\r\nstatic void pxa_rtc_release(struct device *dev)\r\n{\r\nstruct pxa_rtc *pxa_rtc = dev_get_drvdata(dev);\r\nspin_lock_irq(&pxa_rtc->lock);\r\nrtsr_clear_bits(pxa_rtc, RTSR_PIALE | RTSR_RDALE1 | RTSR_HZE);\r\nspin_unlock_irq(&pxa_rtc->lock);\r\nfree_irq(pxa_rtc->irq_Alrm, dev);\r\nfree_irq(pxa_rtc->irq_1Hz, dev);\r\n}\r\nstatic int pxa_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct pxa_rtc *pxa_rtc = dev_get_drvdata(dev);\r\nspin_lock_irq(&pxa_rtc->lock);\r\nif (enabled)\r\nrtsr_set_bits(pxa_rtc, RTSR_RDALE1);\r\nelse\r\nrtsr_clear_bits(pxa_rtc, RTSR_RDALE1);\r\nspin_unlock_irq(&pxa_rtc->lock);\r\nreturn 0;\r\n}\r\nstatic int pxa_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct pxa_rtc *pxa_rtc = dev_get_drvdata(dev);\r\nu32 rycr, rdcr;\r\nrycr = rtc_readl(pxa_rtc, RYCR);\r\nrdcr = rtc_readl(pxa_rtc, RDCR);\r\ntm_calc(rycr, rdcr, tm);\r\nreturn 0;\r\n}\r\nstatic int pxa_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct pxa_rtc *pxa_rtc = dev_get_drvdata(dev);\r\nrtc_writel(pxa_rtc, RYCR, ryxr_calc(tm));\r\nrtc_writel(pxa_rtc, RDCR, rdxr_calc(tm));\r\nreturn 0;\r\n}\r\nstatic int pxa_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct pxa_rtc *pxa_rtc = dev_get_drvdata(dev);\r\nu32 rtsr, ryar, rdar;\r\nryar = rtc_readl(pxa_rtc, RYAR1);\r\nrdar = rtc_readl(pxa_rtc, RDAR1);\r\ntm_calc(ryar, rdar, &alrm->time);\r\nrtsr = rtc_readl(pxa_rtc, RTSR);\r\nalrm->enabled = (rtsr & RTSR_RDALE1) ? 1 : 0;\r\nalrm->pending = (rtsr & RTSR_RDAL1) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int pxa_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct pxa_rtc *pxa_rtc = dev_get_drvdata(dev);\r\nu32 rtsr;\r\nspin_lock_irq(&pxa_rtc->lock);\r\nrtc_writel(pxa_rtc, RYAR1, ryxr_calc(&alrm->time));\r\nrtc_writel(pxa_rtc, RDAR1, rdxr_calc(&alrm->time));\r\nrtsr = rtc_readl(pxa_rtc, RTSR);\r\nif (alrm->enabled)\r\nrtsr |= RTSR_RDALE1;\r\nelse\r\nrtsr &= ~RTSR_RDALE1;\r\nrtc_writel(pxa_rtc, RTSR, rtsr);\r\nspin_unlock_irq(&pxa_rtc->lock);\r\nreturn 0;\r\n}\r\nstatic int pxa_rtc_proc(struct device *dev, struct seq_file *seq)\r\n{\r\nstruct pxa_rtc *pxa_rtc = dev_get_drvdata(dev);\r\nseq_printf(seq, "trim/divider\t: 0x%08x\n", rtc_readl(pxa_rtc, RTTR));\r\nseq_printf(seq, "update_IRQ\t: %s\n",\r\n(rtc_readl(pxa_rtc, RTSR) & RTSR_HZE) ? "yes" : "no");\r\nseq_printf(seq, "periodic_IRQ\t: %s\n",\r\n(rtc_readl(pxa_rtc, RTSR) & RTSR_PIALE) ? "yes" : "no");\r\nseq_printf(seq, "periodic_freq\t: %u\n", rtc_readl(pxa_rtc, PIAR));\r\nreturn 0;\r\n}\r\nstatic int __init pxa_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct pxa_rtc *pxa_rtc;\r\nint ret;\r\nu32 rttr;\r\npxa_rtc = devm_kzalloc(dev, sizeof(*pxa_rtc), GFP_KERNEL);\r\nif (!pxa_rtc)\r\nreturn -ENOMEM;\r\nspin_lock_init(&pxa_rtc->lock);\r\nplatform_set_drvdata(pdev, pxa_rtc);\r\npxa_rtc->ress = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!pxa_rtc->ress) {\r\ndev_err(dev, "No I/O memory resource defined\n");\r\nreturn -ENXIO;\r\n}\r\npxa_rtc->irq_1Hz = platform_get_irq(pdev, 0);\r\nif (pxa_rtc->irq_1Hz < 0) {\r\ndev_err(dev, "No 1Hz IRQ resource defined\n");\r\nreturn -ENXIO;\r\n}\r\npxa_rtc->irq_Alrm = platform_get_irq(pdev, 1);\r\nif (pxa_rtc->irq_Alrm < 0) {\r\ndev_err(dev, "No alarm IRQ resource defined\n");\r\nreturn -ENXIO;\r\n}\r\npxa_rtc_open(dev);\r\npxa_rtc->base = devm_ioremap(dev, pxa_rtc->ress->start,\r\nresource_size(pxa_rtc->ress));\r\nif (!pxa_rtc->base) {\r\ndev_err(dev, "Unable to map pxa RTC I/O memory\n");\r\nreturn -ENOMEM;\r\n}\r\nif (rtc_readl(pxa_rtc, RTTR) == 0) {\r\nrttr = RTC_DEF_DIVIDER + (RTC_DEF_TRIM << 16);\r\nrtc_writel(pxa_rtc, RTTR, rttr);\r\ndev_warn(dev, "warning: initializing default clock"\r\n" divider/trim value\n");\r\n}\r\nrtsr_clear_bits(pxa_rtc, RTSR_PIALE | RTSR_RDALE1 | RTSR_HZE);\r\npxa_rtc->rtc = devm_rtc_device_register(&pdev->dev, "pxa-rtc",\r\n&pxa_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(pxa_rtc->rtc)) {\r\nret = PTR_ERR(pxa_rtc->rtc);\r\ndev_err(dev, "Failed to register RTC device -> %d\n", ret);\r\nreturn ret;\r\n}\r\ndevice_init_wakeup(dev, 1);\r\nreturn 0;\r\n}\r\nstatic int __exit pxa_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\npxa_rtc_release(dev);\r\nreturn 0;\r\n}\r\nstatic int pxa_rtc_suspend(struct device *dev)\r\n{\r\nstruct pxa_rtc *pxa_rtc = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\nenable_irq_wake(pxa_rtc->irq_Alrm);\r\nreturn 0;\r\n}\r\nstatic int pxa_rtc_resume(struct device *dev)\r\n{\r\nstruct pxa_rtc *pxa_rtc = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(pxa_rtc->irq_Alrm);\r\nreturn 0;\r\n}
