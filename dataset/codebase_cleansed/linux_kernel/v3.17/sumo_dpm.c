static struct sumo_ps *sumo_get_ps(struct radeon_ps *rps)\r\n{\r\nstruct sumo_ps *ps = rps->ps_priv;\r\nreturn ps;\r\n}\r\nstruct sumo_power_info *sumo_get_pi(struct radeon_device *rdev)\r\n{\r\nstruct sumo_power_info *pi = rdev->pm.dpm.priv;\r\nreturn pi;\r\n}\r\nstatic void sumo_gfx_clockgating_enable(struct radeon_device *rdev, bool enable)\r\n{\r\nif (enable)\r\nWREG32_P(SCLK_PWRMGT_CNTL, DYN_GFX_CLK_OFF_EN, ~DYN_GFX_CLK_OFF_EN);\r\nelse {\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~DYN_GFX_CLK_OFF_EN);\r\nWREG32_P(SCLK_PWRMGT_CNTL, GFX_CLK_FORCE_ON, ~GFX_CLK_FORCE_ON);\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~GFX_CLK_FORCE_ON);\r\nRREG32(GB_ADDR_CONFIG);\r\n}\r\n}\r\nstatic void sumo_mg_clockgating_enable(struct radeon_device *rdev, bool enable)\r\n{\r\nu32 local0;\r\nu32 local1;\r\nlocal0 = RREG32(CG_CGTT_LOCAL_0);\r\nlocal1 = RREG32(CG_CGTT_LOCAL_1);\r\nif (enable) {\r\nWREG32(CG_CGTT_LOCAL_0, (0 & CGCG_CGTT_LOCAL0_MASK) | (local0 & ~CGCG_CGTT_LOCAL0_MASK) );\r\nWREG32(CG_CGTT_LOCAL_1, (0 & CGCG_CGTT_LOCAL1_MASK) | (local1 & ~CGCG_CGTT_LOCAL1_MASK) );\r\n} else {\r\nWREG32(CG_CGTT_LOCAL_0, (0xFFFFFFFF & CGCG_CGTT_LOCAL0_MASK) | (local0 & ~CGCG_CGTT_LOCAL0_MASK) );\r\nWREG32(CG_CGTT_LOCAL_1, (0xFFFFCFFF & CGCG_CGTT_LOCAL1_MASK) | (local1 & ~CGCG_CGTT_LOCAL1_MASK) );\r\n}\r\n}\r\nstatic void sumo_program_git(struct radeon_device *rdev)\r\n{\r\nu32 p, u;\r\nu32 xclk = radeon_get_xclk(rdev);\r\nr600_calculate_u_and_p(SUMO_GICST_DFLT,\r\nxclk, 16, &p, &u);\r\nWREG32_P(CG_GIT, CG_GICST(p), ~CG_GICST_MASK);\r\n}\r\nstatic void sumo_program_grsd(struct radeon_device *rdev)\r\n{\r\nu32 p, u;\r\nu32 xclk = radeon_get_xclk(rdev);\r\nu32 grs = 256 * 25 / 100;\r\nr600_calculate_u_and_p(1, xclk, 14, &p, &u);\r\nWREG32(CG_GCOOR, PHC(grs) | SDC(p) | SU(u));\r\n}\r\nvoid sumo_gfx_clockgating_initialize(struct radeon_device *rdev)\r\n{\r\nsumo_program_git(rdev);\r\nsumo_program_grsd(rdev);\r\n}\r\nstatic void sumo_gfx_powergating_initialize(struct radeon_device *rdev)\r\n{\r\nu32 rcu_pwr_gating_cntl;\r\nu32 p, u;\r\nu32 p_c, p_p, d_p;\r\nu32 r_t, i_t;\r\nu32 xclk = radeon_get_xclk(rdev);\r\nif (rdev->family == CHIP_PALM) {\r\np_c = 4;\r\nd_p = 10;\r\nr_t = 10;\r\ni_t = 4;\r\np_p = 50 + 1000/200 + 6 * 32;\r\n} else {\r\np_c = 16;\r\nd_p = 50;\r\nr_t = 50;\r\ni_t = 50;\r\np_p = 113;\r\n}\r\nWREG32(CG_SCRATCH2, 0x01B60A17);\r\nr600_calculate_u_and_p(SUMO_GFXPOWERGATINGT_DFLT,\r\nxclk, 16, &p, &u);\r\nWREG32_P(CG_PWR_GATING_CNTL, PGP(p) | PGU(u),\r\n~(PGP_MASK | PGU_MASK));\r\nr600_calculate_u_and_p(SUMO_VOLTAGEDROPT_DFLT,\r\nxclk, 16, &p, &u);\r\nWREG32_P(CG_CG_VOLTAGE_CNTL, PGP(p) | PGU(u),\r\n~(PGP_MASK | PGU_MASK));\r\nif (rdev->family == CHIP_PALM) {\r\nWREG32_RCU(RCU_PWR_GATING_SEQ0, 0x10103210);\r\nWREG32_RCU(RCU_PWR_GATING_SEQ1, 0x10101010);\r\n} else {\r\nWREG32_RCU(RCU_PWR_GATING_SEQ0, 0x76543210);\r\nWREG32_RCU(RCU_PWR_GATING_SEQ1, 0xFEDCBA98);\r\n}\r\nrcu_pwr_gating_cntl = RREG32_RCU(RCU_PWR_GATING_CNTL);\r\nrcu_pwr_gating_cntl &=\r\n~(RSVD_MASK | PCV_MASK | PGS_MASK);\r\nrcu_pwr_gating_cntl |= PCV(p_c) | PGS(1) | PWR_GATING_EN;\r\nif (rdev->family == CHIP_PALM) {\r\nrcu_pwr_gating_cntl &= ~PCP_MASK;\r\nrcu_pwr_gating_cntl |= PCP(0x77);\r\n}\r\nWREG32_RCU(RCU_PWR_GATING_CNTL, rcu_pwr_gating_cntl);\r\nrcu_pwr_gating_cntl = RREG32_RCU(RCU_PWR_GATING_CNTL_2);\r\nrcu_pwr_gating_cntl &= ~(MPPU_MASK | MPPD_MASK);\r\nrcu_pwr_gating_cntl |= MPPU(p_p) | MPPD(50);\r\nWREG32_RCU(RCU_PWR_GATING_CNTL_2, rcu_pwr_gating_cntl);\r\nrcu_pwr_gating_cntl = RREG32_RCU(RCU_PWR_GATING_CNTL_3);\r\nrcu_pwr_gating_cntl &= ~(DPPU_MASK | DPPD_MASK);\r\nrcu_pwr_gating_cntl |= DPPU(d_p) | DPPD(50);\r\nWREG32_RCU(RCU_PWR_GATING_CNTL_3, rcu_pwr_gating_cntl);\r\nrcu_pwr_gating_cntl = RREG32_RCU(RCU_PWR_GATING_CNTL_4);\r\nrcu_pwr_gating_cntl &= ~(RT_MASK | IT_MASK);\r\nrcu_pwr_gating_cntl |= RT(r_t) | IT(i_t);\r\nWREG32_RCU(RCU_PWR_GATING_CNTL_4, rcu_pwr_gating_cntl);\r\nif (rdev->family == CHIP_PALM)\r\nWREG32_RCU(RCU_PWR_GATING_CNTL_5, 0xA02);\r\nsumo_smu_pg_init(rdev);\r\nrcu_pwr_gating_cntl = RREG32_RCU(RCU_PWR_GATING_CNTL);\r\nrcu_pwr_gating_cntl &=\r\n~(RSVD_MASK | PCV_MASK | PGS_MASK);\r\nrcu_pwr_gating_cntl |= PCV(p_c) | PGS(4) | PWR_GATING_EN;\r\nif (rdev->family == CHIP_PALM) {\r\nrcu_pwr_gating_cntl &= ~PCP_MASK;\r\nrcu_pwr_gating_cntl |= PCP(0x77);\r\n}\r\nWREG32_RCU(RCU_PWR_GATING_CNTL, rcu_pwr_gating_cntl);\r\nif (rdev->family == CHIP_PALM) {\r\nrcu_pwr_gating_cntl = RREG32_RCU(RCU_PWR_GATING_CNTL_2);\r\nrcu_pwr_gating_cntl &= ~(MPPU_MASK | MPPD_MASK);\r\nrcu_pwr_gating_cntl |= MPPU(113) | MPPD(50);\r\nWREG32_RCU(RCU_PWR_GATING_CNTL_2, rcu_pwr_gating_cntl);\r\nrcu_pwr_gating_cntl = RREG32_RCU(RCU_PWR_GATING_CNTL_3);\r\nrcu_pwr_gating_cntl &= ~(DPPU_MASK | DPPD_MASK);\r\nrcu_pwr_gating_cntl |= DPPU(16) | DPPD(50);\r\nWREG32_RCU(RCU_PWR_GATING_CNTL_3, rcu_pwr_gating_cntl);\r\n}\r\nsumo_smu_pg_init(rdev);\r\nrcu_pwr_gating_cntl = RREG32_RCU(RCU_PWR_GATING_CNTL);\r\nrcu_pwr_gating_cntl &=\r\n~(RSVD_MASK | PCV_MASK | PGS_MASK);\r\nrcu_pwr_gating_cntl |= PGS(5) | PWR_GATING_EN;\r\nif (rdev->family == CHIP_PALM) {\r\nrcu_pwr_gating_cntl |= PCV(4);\r\nrcu_pwr_gating_cntl &= ~PCP_MASK;\r\nrcu_pwr_gating_cntl |= PCP(0x77);\r\n} else\r\nrcu_pwr_gating_cntl |= PCV(11);\r\nWREG32_RCU(RCU_PWR_GATING_CNTL, rcu_pwr_gating_cntl);\r\nif (rdev->family == CHIP_PALM) {\r\nrcu_pwr_gating_cntl = RREG32_RCU(RCU_PWR_GATING_CNTL_2);\r\nrcu_pwr_gating_cntl &= ~(MPPU_MASK | MPPD_MASK);\r\nrcu_pwr_gating_cntl |= MPPU(113) | MPPD(50);\r\nWREG32_RCU(RCU_PWR_GATING_CNTL_2, rcu_pwr_gating_cntl);\r\nrcu_pwr_gating_cntl = RREG32_RCU(RCU_PWR_GATING_CNTL_3);\r\nrcu_pwr_gating_cntl &= ~(DPPU_MASK | DPPD_MASK);\r\nrcu_pwr_gating_cntl |= DPPU(22) | DPPD(50);\r\nWREG32_RCU(RCU_PWR_GATING_CNTL_3, rcu_pwr_gating_cntl);\r\n}\r\nsumo_smu_pg_init(rdev);\r\n}\r\nstatic void sumo_gfx_powergating_enable(struct radeon_device *rdev, bool enable)\r\n{\r\nif (enable)\r\nWREG32_P(CG_PWR_GATING_CNTL, DYN_PWR_DOWN_EN, ~DYN_PWR_DOWN_EN);\r\nelse {\r\nWREG32_P(CG_PWR_GATING_CNTL, 0, ~DYN_PWR_DOWN_EN);\r\nRREG32(GB_ADDR_CONFIG);\r\n}\r\n}\r\nstatic int sumo_enable_clock_power_gating(struct radeon_device *rdev)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nif (pi->enable_gfx_clock_gating)\r\nsumo_gfx_clockgating_initialize(rdev);\r\nif (pi->enable_gfx_power_gating)\r\nsumo_gfx_powergating_initialize(rdev);\r\nif (pi->enable_mg_clock_gating)\r\nsumo_mg_clockgating_enable(rdev, true);\r\nif (pi->enable_gfx_clock_gating)\r\nsumo_gfx_clockgating_enable(rdev, true);\r\nif (pi->enable_gfx_power_gating)\r\nsumo_gfx_powergating_enable(rdev, true);\r\nreturn 0;\r\n}\r\nstatic void sumo_disable_clock_power_gating(struct radeon_device *rdev)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nif (pi->enable_gfx_clock_gating)\r\nsumo_gfx_clockgating_enable(rdev, false);\r\nif (pi->enable_gfx_power_gating)\r\nsumo_gfx_powergating_enable(rdev, false);\r\nif (pi->enable_mg_clock_gating)\r\nsumo_mg_clockgating_enable(rdev, false);\r\n}\r\nstatic void sumo_calculate_bsp(struct radeon_device *rdev,\r\nu32 high_clk)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nu32 xclk = radeon_get_xclk(rdev);\r\npi->pasi = 65535 * 100 / high_clk;\r\npi->asi = 65535 * 100 / high_clk;\r\nr600_calculate_u_and_p(pi->asi,\r\nxclk, 16, &pi->bsp, &pi->bsu);\r\nr600_calculate_u_and_p(pi->pasi,\r\nxclk, 16, &pi->pbsp, &pi->pbsu);\r\npi->dsp = BSP(pi->bsp) | BSU(pi->bsu);\r\npi->psp = BSP(pi->pbsp) | BSU(pi->pbsu);\r\n}\r\nstatic void sumo_init_bsp(struct radeon_device *rdev)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nWREG32(CG_BSP_0, pi->psp);\r\n}\r\nstatic void sumo_program_bsp(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nstruct sumo_ps *ps = sumo_get_ps(rps);\r\nu32 i;\r\nu32 highest_engine_clock = ps->levels[ps->num_levels - 1].sclk;\r\nif (ps->flags & SUMO_POWERSTATE_FLAGS_BOOST_STATE)\r\nhighest_engine_clock = pi->boost_pl.sclk;\r\nsumo_calculate_bsp(rdev, highest_engine_clock);\r\nfor (i = 0; i < ps->num_levels - 1; i++)\r\nWREG32(CG_BSP_0 + (i * 4), pi->dsp);\r\nWREG32(CG_BSP_0 + (i * 4), pi->psp);\r\nif (ps->flags & SUMO_POWERSTATE_FLAGS_BOOST_STATE)\r\nWREG32(CG_BSP_0 + (BOOST_DPM_LEVEL * 4), pi->psp);\r\n}\r\nstatic void sumo_write_at(struct radeon_device *rdev,\r\nu32 index, u32 value)\r\n{\r\nif (index == 0)\r\nWREG32(CG_AT_0, value);\r\nelse if (index == 1)\r\nWREG32(CG_AT_1, value);\r\nelse if (index == 2)\r\nWREG32(CG_AT_2, value);\r\nelse if (index == 3)\r\nWREG32(CG_AT_3, value);\r\nelse if (index == 4)\r\nWREG32(CG_AT_4, value);\r\nelse if (index == 5)\r\nWREG32(CG_AT_5, value);\r\nelse if (index == 6)\r\nWREG32(CG_AT_6, value);\r\nelse if (index == 7)\r\nWREG32(CG_AT_7, value);\r\n}\r\nstatic void sumo_program_at(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nstruct sumo_ps *ps = sumo_get_ps(rps);\r\nu32 asi;\r\nu32 i;\r\nu32 m_a;\r\nu32 a_t;\r\nu32 r[SUMO_MAX_HARDWARE_POWERLEVELS];\r\nu32 l[SUMO_MAX_HARDWARE_POWERLEVELS];\r\nr[0] = SUMO_R_DFLT0;\r\nr[1] = SUMO_R_DFLT1;\r\nr[2] = SUMO_R_DFLT2;\r\nr[3] = SUMO_R_DFLT3;\r\nr[4] = SUMO_R_DFLT4;\r\nl[0] = SUMO_L_DFLT0;\r\nl[1] = SUMO_L_DFLT1;\r\nl[2] = SUMO_L_DFLT2;\r\nl[3] = SUMO_L_DFLT3;\r\nl[4] = SUMO_L_DFLT4;\r\nfor (i = 0; i < ps->num_levels; i++) {\r\nasi = (i == ps->num_levels - 1) ? pi->pasi : pi->asi;\r\nm_a = asi * ps->levels[i].sclk / 100;\r\na_t = CG_R(m_a * r[i] / 100) | CG_L(m_a * l[i] / 100);\r\nsumo_write_at(rdev, i, a_t);\r\n}\r\nif (ps->flags & SUMO_POWERSTATE_FLAGS_BOOST_STATE) {\r\nasi = pi->pasi;\r\nm_a = asi * pi->boost_pl.sclk / 100;\r\na_t = CG_R(m_a * r[ps->num_levels - 1] / 100) |\r\nCG_L(m_a * l[ps->num_levels - 1] / 100);\r\nsumo_write_at(rdev, BOOST_DPM_LEVEL, a_t);\r\n}\r\n}\r\nstatic void sumo_program_tp(struct radeon_device *rdev)\r\n{\r\nint i;\r\nenum r600_td td = R600_TD_DFLT;\r\nfor (i = 0; i < SUMO_PM_NUMBER_OF_TC; i++) {\r\nWREG32_P(CG_FFCT_0 + (i * 4), UTC_0(sumo_utc[i]), ~UTC_0_MASK);\r\nWREG32_P(CG_FFCT_0 + (i * 4), DTC_0(sumo_dtc[i]), ~DTC_0_MASK);\r\n}\r\nif (td == R600_TD_AUTO)\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~FIR_FORCE_TREND_SEL);\r\nelse\r\nWREG32_P(SCLK_PWRMGT_CNTL, FIR_FORCE_TREND_SEL, ~FIR_FORCE_TREND_SEL);\r\nif (td == R600_TD_UP)\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~FIR_TREND_MODE);\r\nif (td == R600_TD_DOWN)\r\nWREG32_P(SCLK_PWRMGT_CNTL, FIR_TREND_MODE, ~FIR_TREND_MODE);\r\n}\r\nvoid sumo_program_vc(struct radeon_device *rdev, u32 vrc)\r\n{\r\nWREG32(CG_FTV, vrc);\r\n}\r\nvoid sumo_clear_vc(struct radeon_device *rdev)\r\n{\r\nWREG32(CG_FTV, 0);\r\n}\r\nvoid sumo_program_sstp(struct radeon_device *rdev)\r\n{\r\nu32 p, u;\r\nu32 xclk = radeon_get_xclk(rdev);\r\nr600_calculate_u_and_p(SUMO_SST_DFLT,\r\nxclk, 16, &p, &u);\r\nWREG32(CG_SSP, SSTU(u) | SST(p));\r\n}\r\nstatic void sumo_set_divider_value(struct radeon_device *rdev,\r\nu32 index, u32 divider)\r\n{\r\nu32 reg_index = index / 4;\r\nu32 field_index = index % 4;\r\nif (field_index == 0)\r\nWREG32_P(CG_SCLK_DPM_CTRL + (reg_index * 4),\r\nSCLK_FSTATE_0_DIV(divider), ~SCLK_FSTATE_0_DIV_MASK);\r\nelse if (field_index == 1)\r\nWREG32_P(CG_SCLK_DPM_CTRL + (reg_index * 4),\r\nSCLK_FSTATE_1_DIV(divider), ~SCLK_FSTATE_1_DIV_MASK);\r\nelse if (field_index == 2)\r\nWREG32_P(CG_SCLK_DPM_CTRL + (reg_index * 4),\r\nSCLK_FSTATE_2_DIV(divider), ~SCLK_FSTATE_2_DIV_MASK);\r\nelse if (field_index == 3)\r\nWREG32_P(CG_SCLK_DPM_CTRL + (reg_index * 4),\r\nSCLK_FSTATE_3_DIV(divider), ~SCLK_FSTATE_3_DIV_MASK);\r\n}\r\nstatic void sumo_set_ds_dividers(struct radeon_device *rdev,\r\nu32 index, u32 divider)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nif (pi->enable_sclk_ds) {\r\nu32 dpm_ctrl = RREG32(CG_SCLK_DPM_CTRL_6);\r\ndpm_ctrl &= ~(0x7 << (index * 3));\r\ndpm_ctrl |= (divider << (index * 3));\r\nWREG32(CG_SCLK_DPM_CTRL_6, dpm_ctrl);\r\n}\r\n}\r\nstatic void sumo_set_ss_dividers(struct radeon_device *rdev,\r\nu32 index, u32 divider)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nif (pi->enable_sclk_ds) {\r\nu32 dpm_ctrl = RREG32(CG_SCLK_DPM_CTRL_11);\r\ndpm_ctrl &= ~(0x7 << (index * 3));\r\ndpm_ctrl |= (divider << (index * 3));\r\nWREG32(CG_SCLK_DPM_CTRL_11, dpm_ctrl);\r\n}\r\n}\r\nstatic void sumo_set_vid(struct radeon_device *rdev, u32 index, u32 vid)\r\n{\r\nu32 voltage_cntl = RREG32(CG_DPM_VOLTAGE_CNTL);\r\nvoltage_cntl &= ~(DPM_STATE0_LEVEL_MASK << (index * 2));\r\nvoltage_cntl |= (vid << (DPM_STATE0_LEVEL_SHIFT + index * 2));\r\nWREG32(CG_DPM_VOLTAGE_CNTL, voltage_cntl);\r\n}\r\nstatic void sumo_set_allos_gnb_slow(struct radeon_device *rdev, u32 index, u32 gnb_slow)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nu32 temp = gnb_slow;\r\nu32 cg_sclk_dpm_ctrl_3;\r\nif (pi->driver_nbps_policy_disable)\r\ntemp = 1;\r\ncg_sclk_dpm_ctrl_3 = RREG32(CG_SCLK_DPM_CTRL_3);\r\ncg_sclk_dpm_ctrl_3 &= ~(GNB_SLOW_FSTATE_0_MASK << index);\r\ncg_sclk_dpm_ctrl_3 |= (temp << (GNB_SLOW_FSTATE_0_SHIFT + index));\r\nWREG32(CG_SCLK_DPM_CTRL_3, cg_sclk_dpm_ctrl_3);\r\n}\r\nstatic void sumo_program_power_level(struct radeon_device *rdev,\r\nstruct sumo_pl *pl, u32 index)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nint ret;\r\nstruct atom_clock_dividers dividers;\r\nu32 ds_en = RREG32(DEEP_SLEEP_CNTL) & ENABLE_DS;\r\nret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\r\npl->sclk, false, &dividers);\r\nif (ret)\r\nreturn;\r\nsumo_set_divider_value(rdev, index, dividers.post_div);\r\nsumo_set_vid(rdev, index, pl->vddc_index);\r\nif (pl->ss_divider_index == 0 || pl->ds_divider_index == 0) {\r\nif (ds_en)\r\nWREG32_P(DEEP_SLEEP_CNTL, 0, ~ENABLE_DS);\r\n} else {\r\nsumo_set_ss_dividers(rdev, index, pl->ss_divider_index);\r\nsumo_set_ds_dividers(rdev, index, pl->ds_divider_index);\r\nif (!ds_en)\r\nWREG32_P(DEEP_SLEEP_CNTL, ENABLE_DS, ~ENABLE_DS);\r\n}\r\nsumo_set_allos_gnb_slow(rdev, index, pl->allow_gnb_slow);\r\nif (pi->enable_boost)\r\nsumo_set_tdp_limit(rdev, index, pl->sclk_dpm_tdp_limit);\r\n}\r\nstatic void sumo_power_level_enable(struct radeon_device *rdev, u32 index, bool enable)\r\n{\r\nu32 reg_index = index / 4;\r\nu32 field_index = index % 4;\r\nif (field_index == 0)\r\nWREG32_P(CG_SCLK_DPM_CTRL + (reg_index * 4),\r\nenable ? SCLK_FSTATE_0_VLD : 0, ~SCLK_FSTATE_0_VLD);\r\nelse if (field_index == 1)\r\nWREG32_P(CG_SCLK_DPM_CTRL + (reg_index * 4),\r\nenable ? SCLK_FSTATE_1_VLD : 0, ~SCLK_FSTATE_1_VLD);\r\nelse if (field_index == 2)\r\nWREG32_P(CG_SCLK_DPM_CTRL + (reg_index * 4),\r\nenable ? SCLK_FSTATE_2_VLD : 0, ~SCLK_FSTATE_2_VLD);\r\nelse if (field_index == 3)\r\nWREG32_P(CG_SCLK_DPM_CTRL + (reg_index * 4),\r\nenable ? SCLK_FSTATE_3_VLD : 0, ~SCLK_FSTATE_3_VLD);\r\n}\r\nstatic bool sumo_dpm_enabled(struct radeon_device *rdev)\r\n{\r\nif (RREG32(CG_SCLK_DPM_CTRL_3) & DPM_SCLK_ENABLE)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic void sumo_start_dpm(struct radeon_device *rdev)\r\n{\r\nWREG32_P(CG_SCLK_DPM_CTRL_3, DPM_SCLK_ENABLE, ~DPM_SCLK_ENABLE);\r\n}\r\nstatic void sumo_stop_dpm(struct radeon_device *rdev)\r\n{\r\nWREG32_P(CG_SCLK_DPM_CTRL_3, 0, ~DPM_SCLK_ENABLE);\r\n}\r\nstatic void sumo_set_forced_mode(struct radeon_device *rdev, bool enable)\r\n{\r\nif (enable)\r\nWREG32_P(CG_SCLK_DPM_CTRL_3, FORCE_SCLK_STATE_EN, ~FORCE_SCLK_STATE_EN);\r\nelse\r\nWREG32_P(CG_SCLK_DPM_CTRL_3, 0, ~FORCE_SCLK_STATE_EN);\r\n}\r\nstatic void sumo_set_forced_mode_enabled(struct radeon_device *rdev)\r\n{\r\nint i;\r\nsumo_set_forced_mode(rdev, true);\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (RREG32(CG_SCLK_STATUS) & SCLK_OVERCLK_DETECT)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\nstatic void sumo_wait_for_level_0(struct radeon_device *rdev)\r\n{\r\nint i;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif ((RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURR_SCLK_INDEX_MASK) == 0)\r\nbreak;\r\nudelay(1);\r\n}\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif ((RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURR_INDEX_MASK) == 0)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\nstatic void sumo_set_forced_mode_disabled(struct radeon_device *rdev)\r\n{\r\nsumo_set_forced_mode(rdev, false);\r\n}\r\nstatic void sumo_enable_power_level_0(struct radeon_device *rdev)\r\n{\r\nsumo_power_level_enable(rdev, 0, true);\r\n}\r\nstatic void sumo_patch_boost_state(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nstruct sumo_ps *new_ps = sumo_get_ps(rps);\r\nif (new_ps->flags & SUMO_POWERSTATE_FLAGS_BOOST_STATE) {\r\npi->boost_pl = new_ps->levels[new_ps->num_levels - 1];\r\npi->boost_pl.sclk = pi->sys_info.boost_sclk;\r\npi->boost_pl.vddc_index = pi->sys_info.boost_vid_2bit;\r\npi->boost_pl.sclk_dpm_tdp_limit = pi->sys_info.sclk_dpm_tdp_limit_boost;\r\n}\r\n}\r\nstatic void sumo_pre_notify_alt_vddnb_change(struct radeon_device *rdev,\r\nstruct radeon_ps *new_rps,\r\nstruct radeon_ps *old_rps)\r\n{\r\nstruct sumo_ps *new_ps = sumo_get_ps(new_rps);\r\nstruct sumo_ps *old_ps = sumo_get_ps(old_rps);\r\nu32 nbps1_old = 0;\r\nu32 nbps1_new = 0;\r\nif (old_ps != NULL)\r\nnbps1_old = (old_ps->flags & SUMO_POWERSTATE_FLAGS_FORCE_NBPS1_STATE) ? 1 : 0;\r\nnbps1_new = (new_ps->flags & SUMO_POWERSTATE_FLAGS_FORCE_NBPS1_STATE) ? 1 : 0;\r\nif (nbps1_old == 1 && nbps1_new == 0)\r\nsumo_smu_notify_alt_vddnb_change(rdev, 0, 0);\r\n}\r\nstatic void sumo_post_notify_alt_vddnb_change(struct radeon_device *rdev,\r\nstruct radeon_ps *new_rps,\r\nstruct radeon_ps *old_rps)\r\n{\r\nstruct sumo_ps *new_ps = sumo_get_ps(new_rps);\r\nstruct sumo_ps *old_ps = sumo_get_ps(old_rps);\r\nu32 nbps1_old = 0;\r\nu32 nbps1_new = 0;\r\nif (old_ps != NULL)\r\nnbps1_old = (old_ps->flags & SUMO_POWERSTATE_FLAGS_FORCE_NBPS1_STATE)? 1 : 0;\r\nnbps1_new = (new_ps->flags & SUMO_POWERSTATE_FLAGS_FORCE_NBPS1_STATE)? 1 : 0;\r\nif (nbps1_old == 0 && nbps1_new == 1)\r\nsumo_smu_notify_alt_vddnb_change(rdev, 1, 1);\r\n}\r\nstatic void sumo_enable_boost(struct radeon_device *rdev,\r\nstruct radeon_ps *rps,\r\nbool enable)\r\n{\r\nstruct sumo_ps *new_ps = sumo_get_ps(rps);\r\nif (enable) {\r\nif (new_ps->flags & SUMO_POWERSTATE_FLAGS_BOOST_STATE)\r\nsumo_boost_state_enable(rdev, true);\r\n} else\r\nsumo_boost_state_enable(rdev, false);\r\n}\r\nstatic void sumo_set_forced_level(struct radeon_device *rdev, u32 index)\r\n{\r\nWREG32_P(CG_SCLK_DPM_CTRL_3, FORCE_SCLK_STATE(index), ~FORCE_SCLK_STATE_MASK);\r\n}\r\nstatic void sumo_set_forced_level_0(struct radeon_device *rdev)\r\n{\r\nsumo_set_forced_level(rdev, 0);\r\n}\r\nstatic void sumo_program_wl(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct sumo_ps *new_ps = sumo_get_ps(rps);\r\nu32 dpm_ctrl4 = RREG32(CG_SCLK_DPM_CTRL_4);\r\ndpm_ctrl4 &= 0xFFFFFF00;\r\ndpm_ctrl4 |= (1 << (new_ps->num_levels - 1));\r\nif (new_ps->flags & SUMO_POWERSTATE_FLAGS_BOOST_STATE)\r\ndpm_ctrl4 |= (1 << BOOST_DPM_LEVEL);\r\nWREG32(CG_SCLK_DPM_CTRL_4, dpm_ctrl4);\r\n}\r\nstatic void sumo_program_power_levels_0_to_n(struct radeon_device *rdev,\r\nstruct radeon_ps *new_rps,\r\nstruct radeon_ps *old_rps)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nstruct sumo_ps *new_ps = sumo_get_ps(new_rps);\r\nstruct sumo_ps *old_ps = sumo_get_ps(old_rps);\r\nu32 i;\r\nu32 n_current_state_levels = (old_ps == NULL) ? 1 : old_ps->num_levels;\r\nfor (i = 0; i < new_ps->num_levels; i++) {\r\nsumo_program_power_level(rdev, &new_ps->levels[i], i);\r\nsumo_power_level_enable(rdev, i, true);\r\n}\r\nfor (i = new_ps->num_levels; i < n_current_state_levels; i++)\r\nsumo_power_level_enable(rdev, i, false);\r\nif (new_ps->flags & SUMO_POWERSTATE_FLAGS_BOOST_STATE)\r\nsumo_program_power_level(rdev, &pi->boost_pl, BOOST_DPM_LEVEL);\r\n}\r\nstatic void sumo_enable_acpi_pm(struct radeon_device *rdev)\r\n{\r\nWREG32_P(GENERAL_PWRMGT, STATIC_PM_EN, ~STATIC_PM_EN);\r\n}\r\nstatic void sumo_program_power_level_enter_state(struct radeon_device *rdev)\r\n{\r\nWREG32_P(CG_SCLK_DPM_CTRL_5, SCLK_FSTATE_BOOTUP(0), ~SCLK_FSTATE_BOOTUP_MASK);\r\n}\r\nstatic void sumo_program_acpi_power_level(struct radeon_device *rdev)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nstruct atom_clock_dividers dividers;\r\nint ret;\r\nret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\r\npi->acpi_pl.sclk,\r\nfalse, &dividers);\r\nif (ret)\r\nreturn;\r\nWREG32_P(CG_ACPI_CNTL, SCLK_ACPI_DIV(dividers.post_div), ~SCLK_ACPI_DIV_MASK);\r\nWREG32_P(CG_ACPI_VOLTAGE_CNTL, 0, ~ACPI_VOLTAGE_EN);\r\n}\r\nstatic void sumo_program_bootup_state(struct radeon_device *rdev)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nu32 dpm_ctrl4 = RREG32(CG_SCLK_DPM_CTRL_4);\r\nu32 i;\r\nsumo_program_power_level(rdev, &pi->boot_pl, 0);\r\ndpm_ctrl4 &= 0xFFFFFF00;\r\nWREG32(CG_SCLK_DPM_CTRL_4, dpm_ctrl4);\r\nfor (i = 1; i < 8; i++)\r\nsumo_power_level_enable(rdev, i, false);\r\n}\r\nstatic void sumo_setup_uvd_clocks(struct radeon_device *rdev,\r\nstruct radeon_ps *new_rps,\r\nstruct radeon_ps *old_rps)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nif (pi->enable_gfx_power_gating) {\r\nsumo_gfx_powergating_enable(rdev, false);\r\n}\r\nradeon_set_uvd_clocks(rdev, new_rps->vclk, new_rps->dclk);\r\nif (pi->enable_gfx_power_gating) {\r\nif (!pi->disable_gfx_power_gating_in_uvd ||\r\n!r600_is_uvd_state(new_rps->class, new_rps->class2))\r\nsumo_gfx_powergating_enable(rdev, true);\r\n}\r\n}\r\nstatic void sumo_set_uvd_clock_before_set_eng_clock(struct radeon_device *rdev,\r\nstruct radeon_ps *new_rps,\r\nstruct radeon_ps *old_rps)\r\n{\r\nstruct sumo_ps *new_ps = sumo_get_ps(new_rps);\r\nstruct sumo_ps *current_ps = sumo_get_ps(old_rps);\r\nif ((new_rps->vclk == old_rps->vclk) &&\r\n(new_rps->dclk == old_rps->dclk))\r\nreturn;\r\nif (new_ps->levels[new_ps->num_levels - 1].sclk >=\r\ncurrent_ps->levels[current_ps->num_levels - 1].sclk)\r\nreturn;\r\nsumo_setup_uvd_clocks(rdev, new_rps, old_rps);\r\n}\r\nstatic void sumo_set_uvd_clock_after_set_eng_clock(struct radeon_device *rdev,\r\nstruct radeon_ps *new_rps,\r\nstruct radeon_ps *old_rps)\r\n{\r\nstruct sumo_ps *new_ps = sumo_get_ps(new_rps);\r\nstruct sumo_ps *current_ps = sumo_get_ps(old_rps);\r\nif ((new_rps->vclk == old_rps->vclk) &&\r\n(new_rps->dclk == old_rps->dclk))\r\nreturn;\r\nif (new_ps->levels[new_ps->num_levels - 1].sclk <\r\ncurrent_ps->levels[current_ps->num_levels - 1].sclk)\r\nreturn;\r\nsumo_setup_uvd_clocks(rdev, new_rps, old_rps);\r\n}\r\nvoid sumo_take_smu_control(struct radeon_device *rdev, bool enable)\r\n{\r\n#if 0\r\nu32 v = RREG32(DOUT_SCRATCH3);\r\nif (enable)\r\nv |= 0x4;\r\nelse\r\nv &= 0xFFFFFFFB;\r\nWREG32(DOUT_SCRATCH3, v);\r\n#endif\r\n}\r\nstatic void sumo_enable_sclk_ds(struct radeon_device *rdev, bool enable)\r\n{\r\nif (enable) {\r\nu32 deep_sleep_cntl = RREG32(DEEP_SLEEP_CNTL);\r\nu32 deep_sleep_cntl2 = RREG32(DEEP_SLEEP_CNTL2);\r\nu32 t = 1;\r\ndeep_sleep_cntl &= ~R_DIS;\r\ndeep_sleep_cntl &= ~HS_MASK;\r\ndeep_sleep_cntl |= HS(t > 4095 ? 4095 : t);\r\ndeep_sleep_cntl2 |= LB_UFP_EN;\r\ndeep_sleep_cntl2 &= INOUT_C_MASK;\r\ndeep_sleep_cntl2 |= INOUT_C(0xf);\r\nWREG32(DEEP_SLEEP_CNTL2, deep_sleep_cntl2);\r\nWREG32(DEEP_SLEEP_CNTL, deep_sleep_cntl);\r\n} else\r\nWREG32_P(DEEP_SLEEP_CNTL, 0, ~ENABLE_DS);\r\n}\r\nstatic void sumo_program_bootup_at(struct radeon_device *rdev)\r\n{\r\nWREG32_P(CG_AT_0, CG_R(0xffff), ~CG_R_MASK);\r\nWREG32_P(CG_AT_0, CG_L(0), ~CG_L_MASK);\r\n}\r\nstatic void sumo_reset_am(struct radeon_device *rdev)\r\n{\r\nWREG32_P(SCLK_PWRMGT_CNTL, FIR_RESET, ~FIR_RESET);\r\n}\r\nstatic void sumo_start_am(struct radeon_device *rdev)\r\n{\r\nWREG32_P(SCLK_PWRMGT_CNTL, 0, ~FIR_RESET);\r\n}\r\nstatic void sumo_program_ttp(struct radeon_device *rdev)\r\n{\r\nu32 xclk = radeon_get_xclk(rdev);\r\nu32 p, u;\r\nu32 cg_sclk_dpm_ctrl_5 = RREG32(CG_SCLK_DPM_CTRL_5);\r\nr600_calculate_u_and_p(1000,\r\nxclk, 16, &p, &u);\r\ncg_sclk_dpm_ctrl_5 &= ~(TT_TP_MASK | TT_TU_MASK);\r\ncg_sclk_dpm_ctrl_5 |= TT_TP(p) | TT_TU(u);\r\nWREG32(CG_SCLK_DPM_CTRL_5, cg_sclk_dpm_ctrl_5);\r\n}\r\nstatic void sumo_program_ttt(struct radeon_device *rdev)\r\n{\r\nu32 cg_sclk_dpm_ctrl_3 = RREG32(CG_SCLK_DPM_CTRL_3);\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\ncg_sclk_dpm_ctrl_3 &= ~(GNB_TT_MASK | GNB_THERMTHRO_MASK);\r\ncg_sclk_dpm_ctrl_3 |= GNB_TT(pi->thermal_auto_throttling + 49);\r\nWREG32(CG_SCLK_DPM_CTRL_3, cg_sclk_dpm_ctrl_3);\r\n}\r\nstatic void sumo_enable_voltage_scaling(struct radeon_device *rdev, bool enable)\r\n{\r\nif (enable) {\r\nWREG32_P(CG_DPM_VOLTAGE_CNTL, DPM_VOLTAGE_EN, ~DPM_VOLTAGE_EN);\r\nWREG32_P(CG_CG_VOLTAGE_CNTL, 0, ~CG_VOLTAGE_EN);\r\n} else {\r\nWREG32_P(CG_CG_VOLTAGE_CNTL, CG_VOLTAGE_EN, ~CG_VOLTAGE_EN);\r\nWREG32_P(CG_DPM_VOLTAGE_CNTL, 0, ~DPM_VOLTAGE_EN);\r\n}\r\n}\r\nstatic void sumo_override_cnb_thermal_events(struct radeon_device *rdev)\r\n{\r\nWREG32_P(CG_SCLK_DPM_CTRL_3, CNB_THERMTHRO_MASK_SCLK,\r\n~CNB_THERMTHRO_MASK_SCLK);\r\n}\r\nstatic void sumo_program_dc_hto(struct radeon_device *rdev)\r\n{\r\nu32 cg_sclk_dpm_ctrl_4 = RREG32(CG_SCLK_DPM_CTRL_4);\r\nu32 p, u;\r\nu32 xclk = radeon_get_xclk(rdev);\r\nr600_calculate_u_and_p(100000,\r\nxclk, 14, &p, &u);\r\ncg_sclk_dpm_ctrl_4 &= ~(DC_HDC_MASK | DC_HU_MASK);\r\ncg_sclk_dpm_ctrl_4 |= DC_HDC(p) | DC_HU(u);\r\nWREG32(CG_SCLK_DPM_CTRL_4, cg_sclk_dpm_ctrl_4);\r\n}\r\nstatic void sumo_force_nbp_state(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nstruct sumo_ps *new_ps = sumo_get_ps(rps);\r\nif (!pi->driver_nbps_policy_disable) {\r\nif (new_ps->flags & SUMO_POWERSTATE_FLAGS_FORCE_NBPS1_STATE)\r\nWREG32_P(CG_SCLK_DPM_CTRL_3, FORCE_NB_PSTATE_1, ~FORCE_NB_PSTATE_1);\r\nelse\r\nWREG32_P(CG_SCLK_DPM_CTRL_3, 0, ~FORCE_NB_PSTATE_1);\r\n}\r\n}\r\nu32 sumo_get_sleep_divider_from_id(u32 id)\r\n{\r\nreturn 1 << id;\r\n}\r\nu32 sumo_get_sleep_divider_id_from_clock(struct radeon_device *rdev,\r\nu32 sclk,\r\nu32 min_sclk_in_sr)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nu32 i;\r\nu32 temp;\r\nu32 min = (min_sclk_in_sr > SUMO_MINIMUM_ENGINE_CLOCK) ?\r\nmin_sclk_in_sr : SUMO_MINIMUM_ENGINE_CLOCK;\r\nif (sclk < min)\r\nreturn 0;\r\nif (!pi->enable_sclk_ds)\r\nreturn 0;\r\nfor (i = SUMO_MAX_DEEPSLEEP_DIVIDER_ID; ; i--) {\r\ntemp = sclk / sumo_get_sleep_divider_from_id(i);\r\nif (temp >= min || i == 0)\r\nbreak;\r\n}\r\nreturn i;\r\n}\r\nstatic u32 sumo_get_valid_engine_clock(struct radeon_device *rdev,\r\nu32 lower_limit)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nu32 i;\r\nfor (i = 0; i < pi->sys_info.sclk_voltage_mapping_table.num_max_dpm_entries; i++) {\r\nif (pi->sys_info.sclk_voltage_mapping_table.entries[i].sclk_frequency >= lower_limit)\r\nreturn pi->sys_info.sclk_voltage_mapping_table.entries[i].sclk_frequency;\r\n}\r\nreturn pi->sys_info.sclk_voltage_mapping_table.entries[pi->sys_info.sclk_voltage_mapping_table.num_max_dpm_entries - 1].sclk_frequency;\r\n}\r\nstatic void sumo_patch_thermal_state(struct radeon_device *rdev,\r\nstruct sumo_ps *ps,\r\nstruct sumo_ps *current_ps)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nu32 sclk_in_sr = pi->sys_info.min_sclk;\r\nu32 current_vddc;\r\nu32 current_sclk;\r\nu32 current_index = 0;\r\nif (current_ps) {\r\ncurrent_vddc = current_ps->levels[current_index].vddc_index;\r\ncurrent_sclk = current_ps->levels[current_index].sclk;\r\n} else {\r\ncurrent_vddc = pi->boot_pl.vddc_index;\r\ncurrent_sclk = pi->boot_pl.sclk;\r\n}\r\nps->levels[0].vddc_index = current_vddc;\r\nif (ps->levels[0].sclk > current_sclk)\r\nps->levels[0].sclk = current_sclk;\r\nps->levels[0].ss_divider_index =\r\nsumo_get_sleep_divider_id_from_clock(rdev, ps->levels[0].sclk, sclk_in_sr);\r\nps->levels[0].ds_divider_index =\r\nsumo_get_sleep_divider_id_from_clock(rdev, ps->levels[0].sclk, SUMO_MINIMUM_ENGINE_CLOCK);\r\nif (ps->levels[0].ds_divider_index > ps->levels[0].ss_divider_index + 1)\r\nps->levels[0].ds_divider_index = ps->levels[0].ss_divider_index + 1;\r\nif (ps->levels[0].ss_divider_index == ps->levels[0].ds_divider_index) {\r\nif (ps->levels[0].ss_divider_index > 1)\r\nps->levels[0].ss_divider_index = ps->levels[0].ss_divider_index - 1;\r\n}\r\nif (ps->levels[0].ss_divider_index == 0)\r\nps->levels[0].ds_divider_index = 0;\r\nif (ps->levels[0].ds_divider_index == 0)\r\nps->levels[0].ss_divider_index = 0;\r\n}\r\nstatic void sumo_apply_state_adjust_rules(struct radeon_device *rdev,\r\nstruct radeon_ps *new_rps,\r\nstruct radeon_ps *old_rps)\r\n{\r\nstruct sumo_ps *ps = sumo_get_ps(new_rps);\r\nstruct sumo_ps *current_ps = sumo_get_ps(old_rps);\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nu32 min_voltage = 0;\r\nu32 min_sclk = pi->sys_info.min_sclk;\r\nu32 sclk_in_sr = pi->sys_info.min_sclk;\r\nu32 i;\r\nif (new_rps->class & ATOM_PPLIB_CLASSIFICATION_THERMAL)\r\nreturn sumo_patch_thermal_state(rdev, ps, current_ps);\r\nif (pi->enable_boost) {\r\nif (new_rps->class & ATOM_PPLIB_CLASSIFICATION_UI_PERFORMANCE)\r\nps->flags |= SUMO_POWERSTATE_FLAGS_BOOST_STATE;\r\n}\r\nif ((new_rps->class & ATOM_PPLIB_CLASSIFICATION_UI_BATTERY) ||\r\n(new_rps->class & ATOM_PPLIB_CLASSIFICATION_SDSTATE) ||\r\n(new_rps->class & ATOM_PPLIB_CLASSIFICATION_HDSTATE))\r\nps->flags |= SUMO_POWERSTATE_FLAGS_FORCE_NBPS1_STATE;\r\nfor (i = 0; i < ps->num_levels; i++) {\r\nif (ps->levels[i].vddc_index < min_voltage)\r\nps->levels[i].vddc_index = min_voltage;\r\nif (ps->levels[i].sclk < min_sclk)\r\nps->levels[i].sclk =\r\nsumo_get_valid_engine_clock(rdev, min_sclk);\r\nps->levels[i].ss_divider_index =\r\nsumo_get_sleep_divider_id_from_clock(rdev, ps->levels[i].sclk, sclk_in_sr);\r\nps->levels[i].ds_divider_index =\r\nsumo_get_sleep_divider_id_from_clock(rdev, ps->levels[i].sclk, SUMO_MINIMUM_ENGINE_CLOCK);\r\nif (ps->levels[i].ds_divider_index > ps->levels[i].ss_divider_index + 1)\r\nps->levels[i].ds_divider_index = ps->levels[i].ss_divider_index + 1;\r\nif (ps->levels[i].ss_divider_index == ps->levels[i].ds_divider_index) {\r\nif (ps->levels[i].ss_divider_index > 1)\r\nps->levels[i].ss_divider_index = ps->levels[i].ss_divider_index - 1;\r\n}\r\nif (ps->levels[i].ss_divider_index == 0)\r\nps->levels[i].ds_divider_index = 0;\r\nif (ps->levels[i].ds_divider_index == 0)\r\nps->levels[i].ss_divider_index = 0;\r\nif (ps->flags & SUMO_POWERSTATE_FLAGS_FORCE_NBPS1_STATE)\r\nps->levels[i].allow_gnb_slow = 1;\r\nelse if ((new_rps->class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE) ||\r\n(new_rps->class2 & ATOM_PPLIB_CLASSIFICATION2_MVC))\r\nps->levels[i].allow_gnb_slow = 0;\r\nelse if (i == ps->num_levels - 1)\r\nps->levels[i].allow_gnb_slow = 0;\r\nelse\r\nps->levels[i].allow_gnb_slow = 1;\r\n}\r\n}\r\nstatic void sumo_cleanup_asic(struct radeon_device *rdev)\r\n{\r\nsumo_take_smu_control(rdev, false);\r\n}\r\nstatic int sumo_set_thermal_temperature_range(struct radeon_device *rdev,\r\nint min_temp, int max_temp)\r\n{\r\nint low_temp = 0 * 1000;\r\nint high_temp = 255 * 1000;\r\nif (low_temp < min_temp)\r\nlow_temp = min_temp;\r\nif (high_temp > max_temp)\r\nhigh_temp = max_temp;\r\nif (high_temp < low_temp) {\r\nDRM_ERROR("invalid thermal range: %d - %d\n", low_temp, high_temp);\r\nreturn -EINVAL;\r\n}\r\nWREG32_P(CG_THERMAL_INT, DIG_THERM_INTH(49 + (high_temp / 1000)), ~DIG_THERM_INTH_MASK);\r\nWREG32_P(CG_THERMAL_INT, DIG_THERM_INTL(49 + (low_temp / 1000)), ~DIG_THERM_INTL_MASK);\r\nrdev->pm.dpm.thermal.min_temp = low_temp;\r\nrdev->pm.dpm.thermal.max_temp = high_temp;\r\nreturn 0;\r\n}\r\nstatic void sumo_update_current_ps(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct sumo_ps *new_ps = sumo_get_ps(rps);\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\npi->current_rps = *rps;\r\npi->current_ps = *new_ps;\r\npi->current_rps.ps_priv = &pi->current_ps;\r\n}\r\nstatic void sumo_update_requested_ps(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct sumo_ps *new_ps = sumo_get_ps(rps);\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\npi->requested_rps = *rps;\r\npi->requested_ps = *new_ps;\r\npi->requested_rps.ps_priv = &pi->requested_ps;\r\n}\r\nint sumo_dpm_enable(struct radeon_device *rdev)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nif (sumo_dpm_enabled(rdev))\r\nreturn -EINVAL;\r\nsumo_program_bootup_state(rdev);\r\nsumo_init_bsp(rdev);\r\nsumo_reset_am(rdev);\r\nsumo_program_tp(rdev);\r\nsumo_program_bootup_at(rdev);\r\nsumo_start_am(rdev);\r\nif (pi->enable_auto_thermal_throttling) {\r\nsumo_program_ttp(rdev);\r\nsumo_program_ttt(rdev);\r\n}\r\nsumo_program_dc_hto(rdev);\r\nsumo_program_power_level_enter_state(rdev);\r\nsumo_enable_voltage_scaling(rdev, true);\r\nsumo_program_sstp(rdev);\r\nsumo_program_vc(rdev, SUMO_VRC_DFLT);\r\nsumo_override_cnb_thermal_events(rdev);\r\nsumo_start_dpm(rdev);\r\nsumo_wait_for_level_0(rdev);\r\nif (pi->enable_sclk_ds)\r\nsumo_enable_sclk_ds(rdev, true);\r\nif (pi->enable_boost)\r\nsumo_enable_boost_timer(rdev);\r\nsumo_update_current_ps(rdev, rdev->pm.dpm.boot_ps);\r\nreturn 0;\r\n}\r\nint sumo_dpm_late_enable(struct radeon_device *rdev)\r\n{\r\nint ret;\r\nret = sumo_enable_clock_power_gating(rdev);\r\nif (ret)\r\nreturn ret;\r\nif (rdev->irq.installed &&\r\nr600_is_internal_thermal_sensor(rdev->pm.int_thermal_type)) {\r\nret = sumo_set_thermal_temperature_range(rdev, R600_TEMP_RANGE_MIN, R600_TEMP_RANGE_MAX);\r\nif (ret)\r\nreturn ret;\r\nrdev->irq.dpm_thermal = true;\r\nradeon_irq_set(rdev);\r\n}\r\nreturn 0;\r\n}\r\nvoid sumo_dpm_disable(struct radeon_device *rdev)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nif (!sumo_dpm_enabled(rdev))\r\nreturn;\r\nsumo_disable_clock_power_gating(rdev);\r\nif (pi->enable_sclk_ds)\r\nsumo_enable_sclk_ds(rdev, false);\r\nsumo_clear_vc(rdev);\r\nsumo_wait_for_level_0(rdev);\r\nsumo_stop_dpm(rdev);\r\nsumo_enable_voltage_scaling(rdev, false);\r\nif (rdev->irq.installed &&\r\nr600_is_internal_thermal_sensor(rdev->pm.int_thermal_type)) {\r\nrdev->irq.dpm_thermal = false;\r\nradeon_irq_set(rdev);\r\n}\r\nsumo_update_current_ps(rdev, rdev->pm.dpm.boot_ps);\r\n}\r\nint sumo_dpm_pre_set_power_state(struct radeon_device *rdev)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nstruct radeon_ps requested_ps = *rdev->pm.dpm.requested_ps;\r\nstruct radeon_ps *new_ps = &requested_ps;\r\nsumo_update_requested_ps(rdev, new_ps);\r\nif (pi->enable_dynamic_patch_ps)\r\nsumo_apply_state_adjust_rules(rdev,\r\n&pi->requested_rps,\r\n&pi->current_rps);\r\nreturn 0;\r\n}\r\nint sumo_dpm_set_power_state(struct radeon_device *rdev)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nstruct radeon_ps *new_ps = &pi->requested_rps;\r\nstruct radeon_ps *old_ps = &pi->current_rps;\r\nif (pi->enable_dpm)\r\nsumo_set_uvd_clock_before_set_eng_clock(rdev, new_ps, old_ps);\r\nif (pi->enable_boost) {\r\nsumo_enable_boost(rdev, new_ps, false);\r\nsumo_patch_boost_state(rdev, new_ps);\r\n}\r\nif (pi->enable_dpm) {\r\nsumo_pre_notify_alt_vddnb_change(rdev, new_ps, old_ps);\r\nsumo_enable_power_level_0(rdev);\r\nsumo_set_forced_level_0(rdev);\r\nsumo_set_forced_mode_enabled(rdev);\r\nsumo_wait_for_level_0(rdev);\r\nsumo_program_power_levels_0_to_n(rdev, new_ps, old_ps);\r\nsumo_program_wl(rdev, new_ps);\r\nsumo_program_bsp(rdev, new_ps);\r\nsumo_program_at(rdev, new_ps);\r\nsumo_force_nbp_state(rdev, new_ps);\r\nsumo_set_forced_mode_disabled(rdev);\r\nsumo_set_forced_mode_enabled(rdev);\r\nsumo_set_forced_mode_disabled(rdev);\r\nsumo_post_notify_alt_vddnb_change(rdev, new_ps, old_ps);\r\n}\r\nif (pi->enable_boost)\r\nsumo_enable_boost(rdev, new_ps, true);\r\nif (pi->enable_dpm)\r\nsumo_set_uvd_clock_after_set_eng_clock(rdev, new_ps, old_ps);\r\nreturn 0;\r\n}\r\nvoid sumo_dpm_post_set_power_state(struct radeon_device *rdev)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nstruct radeon_ps *new_ps = &pi->requested_rps;\r\nsumo_update_current_ps(rdev, new_ps);\r\n}\r\nvoid sumo_dpm_reset_asic(struct radeon_device *rdev)\r\n{\r\nsumo_program_bootup_state(rdev);\r\nsumo_enable_power_level_0(rdev);\r\nsumo_set_forced_level_0(rdev);\r\nsumo_set_forced_mode_enabled(rdev);\r\nsumo_wait_for_level_0(rdev);\r\nsumo_set_forced_mode_disabled(rdev);\r\nsumo_set_forced_mode_enabled(rdev);\r\nsumo_set_forced_mode_disabled(rdev);\r\n}\r\nvoid sumo_dpm_setup_asic(struct radeon_device *rdev)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nsumo_initialize_m3_arb(rdev);\r\npi->fw_version = sumo_get_running_fw_version(rdev);\r\nDRM_INFO("Found smc ucode version: 0x%08x\n", pi->fw_version);\r\nsumo_program_acpi_power_level(rdev);\r\nsumo_enable_acpi_pm(rdev);\r\nsumo_take_smu_control(rdev, true);\r\n}\r\nvoid sumo_dpm_display_configuration_changed(struct radeon_device *rdev)\r\n{\r\n}\r\nstatic void sumo_patch_boot_state(struct radeon_device *rdev,\r\nstruct sumo_ps *ps)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nps->num_levels = 1;\r\nps->flags = 0;\r\nps->levels[0] = pi->boot_pl;\r\n}\r\nstatic void sumo_parse_pplib_non_clock_info(struct radeon_device *rdev,\r\nstruct radeon_ps *rps,\r\nstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info,\r\nu8 table_rev)\r\n{\r\nstruct sumo_ps *ps = sumo_get_ps(rps);\r\nrps->caps = le32_to_cpu(non_clock_info->ulCapsAndSettings);\r\nrps->class = le16_to_cpu(non_clock_info->usClassification);\r\nrps->class2 = le16_to_cpu(non_clock_info->usClassification2);\r\nif (ATOM_PPLIB_NONCLOCKINFO_VER1 < table_rev) {\r\nrps->vclk = le32_to_cpu(non_clock_info->ulVCLK);\r\nrps->dclk = le32_to_cpu(non_clock_info->ulDCLK);\r\n} else {\r\nrps->vclk = 0;\r\nrps->dclk = 0;\r\n}\r\nif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT) {\r\nrdev->pm.dpm.boot_ps = rps;\r\nsumo_patch_boot_state(rdev, ps);\r\n}\r\nif (rps->class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\r\nrdev->pm.dpm.uvd_ps = rps;\r\n}\r\nstatic void sumo_parse_pplib_clock_info(struct radeon_device *rdev,\r\nstruct radeon_ps *rps, int index,\r\nunion pplib_clock_info *clock_info)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nstruct sumo_ps *ps = sumo_get_ps(rps);\r\nstruct sumo_pl *pl = &ps->levels[index];\r\nu32 sclk;\r\nsclk = le16_to_cpu(clock_info->sumo.usEngineClockLow);\r\nsclk |= clock_info->sumo.ucEngineClockHigh << 16;\r\npl->sclk = sclk;\r\npl->vddc_index = clock_info->sumo.vddcIndex;\r\npl->sclk_dpm_tdp_limit = clock_info->sumo.tdpLimit;\r\nps->num_levels = index + 1;\r\nif (pi->enable_sclk_ds) {\r\npl->ds_divider_index = 5;\r\npl->ss_divider_index = 4;\r\n}\r\n}\r\nstatic int sumo_parse_power_table(struct radeon_device *rdev)\r\n{\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info;\r\nunion pplib_power_state *power_state;\r\nint i, j, k, non_clock_array_index, clock_array_index;\r\nunion pplib_clock_info *clock_info;\r\nstruct _StateArray *state_array;\r\nstruct _ClockInfoArray *clock_info_array;\r\nstruct _NonClockInfoArray *non_clock_info_array;\r\nunion power_info *power_info;\r\nint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\r\nu16 data_offset;\r\nu8 frev, crev;\r\nu8 *power_state_offset;\r\nstruct sumo_ps *ps;\r\nif (!atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset))\r\nreturn -EINVAL;\r\npower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\r\nstate_array = (struct _StateArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usStateArrayOffset));\r\nclock_info_array = (struct _ClockInfoArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usClockInfoArrayOffset));\r\nnon_clock_info_array = (struct _NonClockInfoArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset));\r\nrdev->pm.dpm.ps = kzalloc(sizeof(struct radeon_ps) *\r\nstate_array->ucNumEntries, GFP_KERNEL);\r\nif (!rdev->pm.dpm.ps)\r\nreturn -ENOMEM;\r\npower_state_offset = (u8 *)state_array->states;\r\nfor (i = 0; i < state_array->ucNumEntries; i++) {\r\nu8 *idx;\r\npower_state = (union pplib_power_state *)power_state_offset;\r\nnon_clock_array_index = power_state->v2.nonClockInfoIndex;\r\nnon_clock_info = (struct _ATOM_PPLIB_NONCLOCK_INFO *)\r\n&non_clock_info_array->nonClockInfo[non_clock_array_index];\r\nif (!rdev->pm.power_state[i].clock_info)\r\nreturn -EINVAL;\r\nps = kzalloc(sizeof(struct sumo_ps), GFP_KERNEL);\r\nif (ps == NULL) {\r\nkfree(rdev->pm.dpm.ps);\r\nreturn -ENOMEM;\r\n}\r\nrdev->pm.dpm.ps[i].ps_priv = ps;\r\nk = 0;\r\nidx = (u8 *)&power_state->v2.clockInfoIndex[0];\r\nfor (j = 0; j < power_state->v2.ucNumDPMLevels; j++) {\r\nclock_array_index = idx[j];\r\nif (k >= SUMO_MAX_HARDWARE_POWERLEVELS)\r\nbreak;\r\nclock_info = (union pplib_clock_info *)\r\n((u8 *)&clock_info_array->clockInfo[0] +\r\n(clock_array_index * clock_info_array->ucEntrySize));\r\nsumo_parse_pplib_clock_info(rdev,\r\n&rdev->pm.dpm.ps[i], k,\r\nclock_info);\r\nk++;\r\n}\r\nsumo_parse_pplib_non_clock_info(rdev, &rdev->pm.dpm.ps[i],\r\nnon_clock_info,\r\nnon_clock_info_array->ucEntrySize);\r\npower_state_offset += 2 + power_state->v2.ucNumDPMLevels;\r\n}\r\nrdev->pm.dpm.num_ps = state_array->ucNumEntries;\r\nreturn 0;\r\n}\r\nu32 sumo_convert_vid2_to_vid7(struct radeon_device *rdev,\r\nstruct sumo_vid_mapping_table *vid_mapping_table,\r\nu32 vid_2bit)\r\n{\r\nu32 i;\r\nfor (i = 0; i < vid_mapping_table->num_entries; i++) {\r\nif (vid_mapping_table->entries[i].vid_2bit == vid_2bit)\r\nreturn vid_mapping_table->entries[i].vid_7bit;\r\n}\r\nreturn vid_mapping_table->entries[vid_mapping_table->num_entries - 1].vid_7bit;\r\n}\r\nu32 sumo_convert_vid7_to_vid2(struct radeon_device *rdev,\r\nstruct sumo_vid_mapping_table *vid_mapping_table,\r\nu32 vid_7bit)\r\n{\r\nu32 i;\r\nfor (i = 0; i < vid_mapping_table->num_entries; i++) {\r\nif (vid_mapping_table->entries[i].vid_7bit == vid_7bit)\r\nreturn vid_mapping_table->entries[i].vid_2bit;\r\n}\r\nreturn vid_mapping_table->entries[vid_mapping_table->num_entries - 1].vid_2bit;\r\n}\r\nstatic u16 sumo_convert_voltage_index_to_value(struct radeon_device *rdev,\r\nu32 vid_2bit)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nu32 vid_7bit = sumo_convert_vid2_to_vid7(rdev, &pi->sys_info.vid_mapping_table, vid_2bit);\r\nif (vid_7bit > 0x7C)\r\nreturn 0;\r\nreturn (15500 - vid_7bit * 125 + 5) / 10;\r\n}\r\nstatic void sumo_construct_display_voltage_mapping_table(struct radeon_device *rdev,\r\nstruct sumo_disp_clock_voltage_mapping_table *disp_clk_voltage_mapping_table,\r\nATOM_CLK_VOLT_CAPABILITY *table)\r\n{\r\nu32 i;\r\nfor (i = 0; i < SUMO_MAX_NUMBER_VOLTAGES; i++) {\r\nif (table[i].ulMaximumSupportedCLK == 0)\r\nbreak;\r\ndisp_clk_voltage_mapping_table->display_clock_frequency[i] =\r\ntable[i].ulMaximumSupportedCLK;\r\n}\r\ndisp_clk_voltage_mapping_table->num_max_voltage_levels = i;\r\nif (disp_clk_voltage_mapping_table->num_max_voltage_levels == 0) {\r\ndisp_clk_voltage_mapping_table->display_clock_frequency[0] = 80000;\r\ndisp_clk_voltage_mapping_table->num_max_voltage_levels = 1;\r\n}\r\n}\r\nvoid sumo_construct_sclk_voltage_mapping_table(struct radeon_device *rdev,\r\nstruct sumo_sclk_voltage_mapping_table *sclk_voltage_mapping_table,\r\nATOM_AVAILABLE_SCLK_LIST *table)\r\n{\r\nu32 i;\r\nu32 n = 0;\r\nu32 prev_sclk = 0;\r\nfor (i = 0; i < SUMO_MAX_HARDWARE_POWERLEVELS; i++) {\r\nif (table[i].ulSupportedSCLK > prev_sclk) {\r\nsclk_voltage_mapping_table->entries[n].sclk_frequency =\r\ntable[i].ulSupportedSCLK;\r\nsclk_voltage_mapping_table->entries[n].vid_2bit =\r\ntable[i].usVoltageIndex;\r\nprev_sclk = table[i].ulSupportedSCLK;\r\nn++;\r\n}\r\n}\r\nsclk_voltage_mapping_table->num_max_dpm_entries = n;\r\n}\r\nvoid sumo_construct_vid_mapping_table(struct radeon_device *rdev,\r\nstruct sumo_vid_mapping_table *vid_mapping_table,\r\nATOM_AVAILABLE_SCLK_LIST *table)\r\n{\r\nu32 i, j;\r\nfor (i = 0; i < SUMO_MAX_HARDWARE_POWERLEVELS; i++) {\r\nif (table[i].ulSupportedSCLK != 0) {\r\nvid_mapping_table->entries[table[i].usVoltageIndex].vid_7bit =\r\ntable[i].usVoltageID;\r\nvid_mapping_table->entries[table[i].usVoltageIndex].vid_2bit =\r\ntable[i].usVoltageIndex;\r\n}\r\n}\r\nfor (i = 0; i < SUMO_MAX_NUMBER_VOLTAGES; i++) {\r\nif (vid_mapping_table->entries[i].vid_7bit == 0) {\r\nfor (j = i + 1; j < SUMO_MAX_NUMBER_VOLTAGES; j++) {\r\nif (vid_mapping_table->entries[j].vid_7bit != 0) {\r\nvid_mapping_table->entries[i] =\r\nvid_mapping_table->entries[j];\r\nvid_mapping_table->entries[j].vid_7bit = 0;\r\nbreak;\r\n}\r\n}\r\nif (j == SUMO_MAX_NUMBER_VOLTAGES)\r\nbreak;\r\n}\r\n}\r\nvid_mapping_table->num_entries = i;\r\n}\r\nstatic int sumo_parse_sys_info_table(struct radeon_device *rdev)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nint index = GetIndexIntoMasterTable(DATA, IntegratedSystemInfo);\r\nunion igp_info *igp_info;\r\nu8 frev, crev;\r\nu16 data_offset;\r\nint i;\r\nif (atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset)) {\r\nigp_info = (union igp_info *)(mode_info->atom_context->bios +\r\ndata_offset);\r\nif (crev != 6) {\r\nDRM_ERROR("Unsupported IGP table: %d %d\n", frev, crev);\r\nreturn -EINVAL;\r\n}\r\npi->sys_info.bootup_sclk = le32_to_cpu(igp_info->info_6.ulBootUpEngineClock);\r\npi->sys_info.min_sclk = le32_to_cpu(igp_info->info_6.ulMinEngineClock);\r\npi->sys_info.bootup_uma_clk = le32_to_cpu(igp_info->info_6.ulBootUpUMAClock);\r\npi->sys_info.bootup_nb_voltage_index =\r\nle16_to_cpu(igp_info->info_6.usBootUpNBVoltage);\r\nif (igp_info->info_6.ucHtcTmpLmt == 0)\r\npi->sys_info.htc_tmp_lmt = 203;\r\nelse\r\npi->sys_info.htc_tmp_lmt = igp_info->info_6.ucHtcTmpLmt;\r\nif (igp_info->info_6.ucHtcHystLmt == 0)\r\npi->sys_info.htc_hyst_lmt = 5;\r\nelse\r\npi->sys_info.htc_hyst_lmt = igp_info->info_6.ucHtcHystLmt;\r\nif (pi->sys_info.htc_tmp_lmt <= pi->sys_info.htc_hyst_lmt) {\r\nDRM_ERROR("The htcTmpLmt should be larger than htcHystLmt.\n");\r\n}\r\nfor (i = 0; i < NUMBER_OF_M3ARB_PARAM_SETS; i++) {\r\npi->sys_info.csr_m3_arb_cntl_default[i] =\r\nle32_to_cpu(igp_info->info_6.ulCSR_M3_ARB_CNTL_DEFAULT[i]);\r\npi->sys_info.csr_m3_arb_cntl_uvd[i] =\r\nle32_to_cpu(igp_info->info_6.ulCSR_M3_ARB_CNTL_UVD[i]);\r\npi->sys_info.csr_m3_arb_cntl_fs3d[i] =\r\nle32_to_cpu(igp_info->info_6.ulCSR_M3_ARB_CNTL_FS3D[i]);\r\n}\r\npi->sys_info.sclk_dpm_boost_margin =\r\nle32_to_cpu(igp_info->info_6.SclkDpmBoostMargin);\r\npi->sys_info.sclk_dpm_throttle_margin =\r\nle32_to_cpu(igp_info->info_6.SclkDpmThrottleMargin);\r\npi->sys_info.sclk_dpm_tdp_limit_pg =\r\nle16_to_cpu(igp_info->info_6.SclkDpmTdpLimitPG);\r\npi->sys_info.gnb_tdp_limit = le16_to_cpu(igp_info->info_6.GnbTdpLimit);\r\npi->sys_info.sclk_dpm_tdp_limit_boost =\r\nle16_to_cpu(igp_info->info_6.SclkDpmTdpLimitBoost);\r\npi->sys_info.boost_sclk = le32_to_cpu(igp_info->info_6.ulBoostEngineCLock);\r\npi->sys_info.boost_vid_2bit = igp_info->info_6.ulBoostVid_2bit;\r\nif (igp_info->info_6.EnableBoost)\r\npi->sys_info.enable_boost = true;\r\nelse\r\npi->sys_info.enable_boost = false;\r\nsumo_construct_display_voltage_mapping_table(rdev,\r\n&pi->sys_info.disp_clk_voltage_mapping_table,\r\nigp_info->info_6.sDISPCLK_Voltage);\r\nsumo_construct_sclk_voltage_mapping_table(rdev,\r\n&pi->sys_info.sclk_voltage_mapping_table,\r\nigp_info->info_6.sAvail_SCLK);\r\nsumo_construct_vid_mapping_table(rdev, &pi->sys_info.vid_mapping_table,\r\nigp_info->info_6.sAvail_SCLK);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sumo_construct_boot_and_acpi_state(struct radeon_device *rdev)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\npi->boot_pl.sclk = pi->sys_info.bootup_sclk;\r\npi->boot_pl.vddc_index = pi->sys_info.bootup_nb_voltage_index;\r\npi->boot_pl.ds_divider_index = 0;\r\npi->boot_pl.ss_divider_index = 0;\r\npi->boot_pl.allow_gnb_slow = 1;\r\npi->acpi_pl = pi->boot_pl;\r\npi->current_ps.num_levels = 1;\r\npi->current_ps.levels[0] = pi->boot_pl;\r\n}\r\nint sumo_dpm_init(struct radeon_device *rdev)\r\n{\r\nstruct sumo_power_info *pi;\r\nu32 hw_rev = (RREG32(HW_REV) & ATI_REV_ID_MASK) >> ATI_REV_ID_SHIFT;\r\nint ret;\r\npi = kzalloc(sizeof(struct sumo_power_info), GFP_KERNEL);\r\nif (pi == NULL)\r\nreturn -ENOMEM;\r\nrdev->pm.dpm.priv = pi;\r\npi->driver_nbps_policy_disable = false;\r\nif ((rdev->family == CHIP_PALM) && (hw_rev < 3))\r\npi->disable_gfx_power_gating_in_uvd = true;\r\nelse\r\npi->disable_gfx_power_gating_in_uvd = false;\r\npi->enable_alt_vddnb = true;\r\npi->enable_sclk_ds = true;\r\npi->enable_dynamic_m3_arbiter = false;\r\npi->enable_dynamic_patch_ps = true;\r\nif (rdev->family == CHIP_PALM)\r\npi->enable_gfx_power_gating = false;\r\nelse\r\npi->enable_gfx_power_gating = true;\r\npi->enable_gfx_clock_gating = true;\r\npi->enable_mg_clock_gating = true;\r\npi->enable_auto_thermal_throttling = true;\r\nret = sumo_parse_sys_info_table(rdev);\r\nif (ret)\r\nreturn ret;\r\nsumo_construct_boot_and_acpi_state(rdev);\r\nret = r600_get_platform_caps(rdev);\r\nif (ret)\r\nreturn ret;\r\nret = sumo_parse_power_table(rdev);\r\nif (ret)\r\nreturn ret;\r\npi->pasi = CYPRESS_HASI_DFLT;\r\npi->asi = RV770_ASI_DFLT;\r\npi->thermal_auto_throttling = pi->sys_info.htc_tmp_lmt;\r\npi->enable_boost = pi->sys_info.enable_boost;\r\npi->enable_dpm = true;\r\nreturn 0;\r\n}\r\nvoid sumo_dpm_print_power_state(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nint i;\r\nstruct sumo_ps *ps = sumo_get_ps(rps);\r\nr600_dpm_print_class_info(rps->class, rps->class2);\r\nr600_dpm_print_cap_info(rps->caps);\r\nprintk("\tuvd vclk: %d dclk: %d\n", rps->vclk, rps->dclk);\r\nfor (i = 0; i < ps->num_levels; i++) {\r\nstruct sumo_pl *pl = &ps->levels[i];\r\nprintk("\t\tpower level %d sclk: %u vddc: %u\n",\r\ni, pl->sclk,\r\nsumo_convert_voltage_index_to_value(rdev, pl->vddc_index));\r\n}\r\nr600_dpm_print_ps_status(rdev, rps);\r\n}\r\nvoid sumo_dpm_debugfs_print_current_performance_level(struct radeon_device *rdev,\r\nstruct seq_file *m)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nstruct radeon_ps *rps = &pi->current_rps;\r\nstruct sumo_ps *ps = sumo_get_ps(rps);\r\nstruct sumo_pl *pl;\r\nu32 current_index =\r\n(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURR_INDEX_MASK) >>\r\nCURR_INDEX_SHIFT;\r\nif (current_index == BOOST_DPM_LEVEL) {\r\npl = &pi->boost_pl;\r\nseq_printf(m, "uvd vclk: %d dclk: %d\n", rps->vclk, rps->dclk);\r\nseq_printf(m, "power level %d sclk: %u vddc: %u\n",\r\ncurrent_index, pl->sclk,\r\nsumo_convert_voltage_index_to_value(rdev, pl->vddc_index));\r\n} else if (current_index >= ps->num_levels) {\r\nseq_printf(m, "invalid dpm profile %d\n", current_index);\r\n} else {\r\npl = &ps->levels[current_index];\r\nseq_printf(m, "uvd vclk: %d dclk: %d\n", rps->vclk, rps->dclk);\r\nseq_printf(m, "power level %d sclk: %u vddc: %u\n",\r\ncurrent_index, pl->sclk,\r\nsumo_convert_voltage_index_to_value(rdev, pl->vddc_index));\r\n}\r\n}\r\nvoid sumo_dpm_fini(struct radeon_device *rdev)\r\n{\r\nint i;\r\nsumo_cleanup_asic(rdev);\r\nfor (i = 0; i < rdev->pm.dpm.num_ps; i++) {\r\nkfree(rdev->pm.dpm.ps[i].ps_priv);\r\n}\r\nkfree(rdev->pm.dpm.ps);\r\nkfree(rdev->pm.dpm.priv);\r\n}\r\nu32 sumo_dpm_get_sclk(struct radeon_device *rdev, bool low)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nstruct sumo_ps *requested_state = sumo_get_ps(&pi->requested_rps);\r\nif (low)\r\nreturn requested_state->levels[0].sclk;\r\nelse\r\nreturn requested_state->levels[requested_state->num_levels - 1].sclk;\r\n}\r\nu32 sumo_dpm_get_mclk(struct radeon_device *rdev, bool low)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nreturn pi->sys_info.bootup_uma_clk;\r\n}\r\nint sumo_dpm_force_performance_level(struct radeon_device *rdev,\r\nenum radeon_dpm_forced_level level)\r\n{\r\nstruct sumo_power_info *pi = sumo_get_pi(rdev);\r\nstruct radeon_ps *rps = &pi->current_rps;\r\nstruct sumo_ps *ps = sumo_get_ps(rps);\r\nint i;\r\nif (ps->num_levels <= 1)\r\nreturn 0;\r\nif (level == RADEON_DPM_FORCED_LEVEL_HIGH) {\r\nif (pi->enable_boost)\r\nsumo_enable_boost(rdev, rps, false);\r\nsumo_power_level_enable(rdev, ps->num_levels - 1, true);\r\nsumo_set_forced_level(rdev, ps->num_levels - 1);\r\nsumo_set_forced_mode_enabled(rdev);\r\nfor (i = 0; i < ps->num_levels - 1; i++) {\r\nsumo_power_level_enable(rdev, i, false);\r\n}\r\nsumo_set_forced_mode(rdev, false);\r\nsumo_set_forced_mode_enabled(rdev);\r\nsumo_set_forced_mode(rdev, false);\r\n} else if (level == RADEON_DPM_FORCED_LEVEL_LOW) {\r\nif (pi->enable_boost)\r\nsumo_enable_boost(rdev, rps, false);\r\nsumo_power_level_enable(rdev, 0, true);\r\nsumo_set_forced_level(rdev, 0);\r\nsumo_set_forced_mode_enabled(rdev);\r\nfor (i = 1; i < ps->num_levels; i++) {\r\nsumo_power_level_enable(rdev, i, false);\r\n}\r\nsumo_set_forced_mode(rdev, false);\r\nsumo_set_forced_mode_enabled(rdev);\r\nsumo_set_forced_mode(rdev, false);\r\n} else {\r\nfor (i = 0; i < ps->num_levels; i++) {\r\nsumo_power_level_enable(rdev, i, true);\r\n}\r\nif (pi->enable_boost)\r\nsumo_enable_boost(rdev, rps, true);\r\n}\r\nrdev->pm.dpm.forced_level = level;\r\nreturn 0;\r\n}
