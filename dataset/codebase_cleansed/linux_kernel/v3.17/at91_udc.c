static void proc_ep_show(struct seq_file *s, struct at91_ep *ep)\r\n{\r\nstatic char *types[] = {\r\n"control", "out-iso", "out-bulk", "out-int",\r\n"BOGUS", "in-iso", "in-bulk", "in-int"};\r\nu32 csr;\r\nstruct at91_request *req;\r\nunsigned long flags;\r\nstruct at91_udc *udc = ep->udc;\r\nspin_lock_irqsave(&udc->lock, flags);\r\ncsr = __raw_readl(ep->creg);\r\nseq_printf(s, "\n");\r\nseq_printf(s, "%s, maxpacket %d %s%s %s%s\n",\r\nep->ep.name, ep->ep.maxpacket,\r\nep->is_in ? "in" : "out",\r\nep->is_iso ? " iso" : "",\r\nep->is_pingpong\r\n? (ep->fifo_bank ? "pong" : "ping")\r\n: "",\r\nep->stopped ? " stopped" : "");\r\nseq_printf(s, "csr %08x rxbytes=%d %s %s %s" EIGHTBITS "\n",\r\ncsr,\r\n(csr & 0x07ff0000) >> 16,\r\n(csr & (1 << 15)) ? "enabled" : "disabled",\r\n(csr & (1 << 11)) ? "DATA1" : "DATA0",\r\ntypes[(csr & 0x700) >> 8],\r\n(!(csr & 0x700))\r\n? ((csr & (1 << 7)) ? " IN" : " OUT")\r\n: "",\r\n(csr & (1 << 6)) ? " rxdatabk1" : "",\r\n(csr & (1 << 5)) ? " forcestall" : "",\r\n(csr & (1 << 4)) ? " txpktrdy" : "",\r\n(csr & (1 << 3)) ? " stallsent" : "",\r\n(csr & (1 << 2)) ? " rxsetup" : "",\r\n(csr & (1 << 1)) ? " rxdatabk0" : "",\r\n(csr & (1 << 0)) ? " txcomp" : "");\r\nif (list_empty (&ep->queue))\r\nseq_printf(s, "\t(queue empty)\n");\r\nelse list_for_each_entry (req, &ep->queue, queue) {\r\nunsigned length = req->req.actual;\r\nseq_printf(s, "\treq %p len %d/%d buf %p\n",\r\n&req->req, length,\r\nreq->req.length, req->req.buf);\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\n}\r\nstatic void proc_irq_show(struct seq_file *s, const char *label, u32 mask)\r\n{\r\nint i;\r\nseq_printf(s, "%s %04x:%s%s" FOURBITS, label, mask,\r\n(mask & (1 << 13)) ? " wakeup" : "",\r\n(mask & (1 << 12)) ? " endbusres" : "",\r\n(mask & (1 << 11)) ? " sofint" : "",\r\n(mask & (1 << 10)) ? " extrsm" : "",\r\n(mask & (1 << 9)) ? " rxrsm" : "",\r\n(mask & (1 << 8)) ? " rxsusp" : "");\r\nfor (i = 0; i < 8; i++) {\r\nif (mask & (1 << i))\r\nseq_printf(s, " ep%d", i);\r\n}\r\nseq_printf(s, "\n");\r\n}\r\nstatic int proc_udc_show(struct seq_file *s, void *unused)\r\n{\r\nstruct at91_udc *udc = s->private;\r\nstruct at91_ep *ep;\r\nu32 tmp;\r\nseq_printf(s, "%s: version %s\n", driver_name, DRIVER_VERSION);\r\nseq_printf(s, "vbus %s, pullup %s, %s powered%s, gadget %s\n\n",\r\nudc->vbus ? "present" : "off",\r\nudc->enabled\r\n? (udc->vbus ? "active" : "enabled")\r\n: "disabled",\r\nudc->selfpowered ? "self" : "VBUS",\r\nudc->suspended ? ", suspended" : "",\r\nudc->driver ? udc->driver->driver.name : "(none)");\r\nif (!udc->clocked) {\r\nseq_printf(s, "(not clocked)\n");\r\nreturn 0;\r\n}\r\ntmp = at91_udp_read(udc, AT91_UDP_FRM_NUM);\r\nseq_printf(s, "frame %05x:%s%s frame=%d\n", tmp,\r\n(tmp & AT91_UDP_FRM_OK) ? " ok" : "",\r\n(tmp & AT91_UDP_FRM_ERR) ? " err" : "",\r\n(tmp & AT91_UDP_NUM));\r\ntmp = at91_udp_read(udc, AT91_UDP_GLB_STAT);\r\nseq_printf(s, "glbstate %02x:%s" FOURBITS "\n", tmp,\r\n(tmp & AT91_UDP_RMWUPE) ? " rmwupe" : "",\r\n(tmp & AT91_UDP_RSMINPR) ? " rsminpr" : "",\r\n(tmp & AT91_UDP_ESR) ? " esr" : "",\r\n(tmp & AT91_UDP_CONFG) ? " confg" : "",\r\n(tmp & AT91_UDP_FADDEN) ? " fadden" : "");\r\ntmp = at91_udp_read(udc, AT91_UDP_FADDR);\r\nseq_printf(s, "faddr %03x:%s fadd=%d\n", tmp,\r\n(tmp & AT91_UDP_FEN) ? " fen" : "",\r\n(tmp & AT91_UDP_FADD));\r\nproc_irq_show(s, "imr ", at91_udp_read(udc, AT91_UDP_IMR));\r\nproc_irq_show(s, "isr ", at91_udp_read(udc, AT91_UDP_ISR));\r\nif (udc->enabled && udc->vbus) {\r\nproc_ep_show(s, &udc->ep[0]);\r\nlist_for_each_entry (ep, &udc->gadget.ep_list, ep.ep_list) {\r\nif (ep->ep.desc)\r\nproc_ep_show(s, ep);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int proc_udc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, proc_udc_show, PDE_DATA(inode));\r\n}\r\nstatic void create_debug_file(struct at91_udc *udc)\r\n{\r\nudc->pde = proc_create_data(debug_filename, 0, NULL, &proc_ops, udc);\r\n}\r\nstatic void remove_debug_file(struct at91_udc *udc)\r\n{\r\nif (udc->pde)\r\nremove_proc_entry(debug_filename, NULL);\r\n}\r\nstatic inline void create_debug_file(struct at91_udc *udc) {}\r\nstatic inline void remove_debug_file(struct at91_udc *udc) {}\r\nstatic void done(struct at91_ep *ep, struct at91_request *req, int status)\r\n{\r\nunsigned stopped = ep->stopped;\r\nstruct at91_udc *udc = ep->udc;\r\nlist_del_init(&req->queue);\r\nif (req->req.status == -EINPROGRESS)\r\nreq->req.status = status;\r\nelse\r\nstatus = req->req.status;\r\nif (status && status != -ESHUTDOWN)\r\nVDBG("%s done %p, status %d\n", ep->ep.name, req, status);\r\nep->stopped = 1;\r\nspin_unlock(&udc->lock);\r\nreq->req.complete(&ep->ep, &req->req);\r\nspin_lock(&udc->lock);\r\nep->stopped = stopped;\r\nif (list_empty(&ep->queue) && ep->int_mask != (1 << 0))\r\nat91_udp_write(udc, AT91_UDP_IDR, ep->int_mask);\r\n}\r\nstatic int read_fifo (struct at91_ep *ep, struct at91_request *req)\r\n{\r\nu32 __iomem *creg = ep->creg;\r\nu8 __iomem *dreg = ep->creg + (AT91_UDP_FDR(0) - AT91_UDP_CSR(0));\r\nu32 csr;\r\nu8 *buf;\r\nunsigned int count, bufferspace, is_done;\r\nbuf = req->req.buf + req->req.actual;\r\nbufferspace = req->req.length - req->req.actual;\r\nrescan:\r\ncsr = __raw_readl(creg);\r\nif ((csr & RX_DATA_READY) == 0)\r\nreturn 0;\r\ncount = (csr & AT91_UDP_RXBYTECNT) >> 16;\r\nif (count > ep->ep.maxpacket)\r\ncount = ep->ep.maxpacket;\r\nif (count > bufferspace) {\r\nDBG("%s buffer overflow\n", ep->ep.name);\r\nreq->req.status = -EOVERFLOW;\r\ncount = bufferspace;\r\n}\r\n__raw_readsb(dreg, buf, count);\r\ncsr |= CLR_FX;\r\nif (ep->is_pingpong) {\r\nif (ep->fifo_bank == 0) {\r\ncsr &= ~(SET_FX | AT91_UDP_RX_DATA_BK0);\r\nep->fifo_bank = 1;\r\n} else {\r\ncsr &= ~(SET_FX | AT91_UDP_RX_DATA_BK1);\r\nep->fifo_bank = 0;\r\n}\r\n} else\r\ncsr &= ~(SET_FX | AT91_UDP_RX_DATA_BK0);\r\n__raw_writel(csr, creg);\r\nreq->req.actual += count;\r\nis_done = (count < ep->ep.maxpacket);\r\nif (count == bufferspace)\r\nis_done = 1;\r\nPACKET("%s %p out/%d%s\n", ep->ep.name, &req->req, count,\r\nis_done ? " (done)" : "");\r\nif (is_done)\r\ndone(ep, req, 0);\r\nelse if (ep->is_pingpong) {\r\ncsr = __raw_readl(creg);\r\nbufferspace -= count;\r\nbuf += count;\r\ngoto rescan;\r\n}\r\nreturn is_done;\r\n}\r\nstatic int write_fifo(struct at91_ep *ep, struct at91_request *req)\r\n{\r\nu32 __iomem *creg = ep->creg;\r\nu32 csr = __raw_readl(creg);\r\nu8 __iomem *dreg = ep->creg + (AT91_UDP_FDR(0) - AT91_UDP_CSR(0));\r\nunsigned total, count, is_last;\r\nu8 *buf;\r\nif (unlikely(csr & (AT91_UDP_TXCOMP | AT91_UDP_TXPKTRDY))) {\r\nif (csr & AT91_UDP_TXCOMP) {\r\ncsr |= CLR_FX;\r\ncsr &= ~(SET_FX | AT91_UDP_TXCOMP);\r\n__raw_writel(csr, creg);\r\ncsr = __raw_readl(creg);\r\n}\r\nif (csr & AT91_UDP_TXPKTRDY)\r\nreturn 0;\r\n}\r\nbuf = req->req.buf + req->req.actual;\r\nprefetch(buf);\r\ntotal = req->req.length - req->req.actual;\r\nif (ep->ep.maxpacket < total) {\r\ncount = ep->ep.maxpacket;\r\nis_last = 0;\r\n} else {\r\ncount = total;\r\nis_last = (count < ep->ep.maxpacket) || !req->req.zero;\r\n}\r\n__raw_writesb(dreg, buf, count);\r\ncsr &= ~SET_FX;\r\ncsr |= CLR_FX | AT91_UDP_TXPKTRDY;\r\n__raw_writel(csr, creg);\r\nreq->req.actual += count;\r\nPACKET("%s %p in/%d%s\n", ep->ep.name, &req->req, count,\r\nis_last ? " (done)" : "");\r\nif (is_last)\r\ndone(ep, req, 0);\r\nreturn is_last;\r\n}\r\nstatic void nuke(struct at91_ep *ep, int status)\r\n{\r\nstruct at91_request *req;\r\nep->stopped = 1;\r\nif (list_empty(&ep->queue))\r\nreturn;\r\nVDBG("%s %s\n", __func__, ep->ep.name);\r\nwhile (!list_empty(&ep->queue)) {\r\nreq = list_entry(ep->queue.next, struct at91_request, queue);\r\ndone(ep, req, status);\r\n}\r\n}\r\nstatic int at91_ep_enable(struct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct at91_ep *ep = container_of(_ep, struct at91_ep, ep);\r\nstruct at91_udc *udc;\r\nu16 maxpacket;\r\nu32 tmp;\r\nunsigned long flags;\r\nif (!_ep || !ep\r\n|| !desc || _ep->name == ep0name\r\n|| desc->bDescriptorType != USB_DT_ENDPOINT\r\n|| (maxpacket = usb_endpoint_maxp(desc)) == 0\r\n|| maxpacket > ep->maxpacket) {\r\nDBG("bad ep or descriptor\n");\r\nreturn -EINVAL;\r\n}\r\nudc = ep->udc;\r\nif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {\r\nDBG("bogus device state\n");\r\nreturn -ESHUTDOWN;\r\n}\r\ntmp = usb_endpoint_type(desc);\r\nswitch (tmp) {\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\nDBG("only one control endpoint\n");\r\nreturn -EINVAL;\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (maxpacket > 64)\r\ngoto bogus_max;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\nswitch (maxpacket) {\r\ncase 8:\r\ncase 16:\r\ncase 32:\r\ncase 64:\r\ngoto ok;\r\n}\r\nbogus_max:\r\nDBG("bogus maxpacket %d\n", maxpacket);\r\nreturn -EINVAL;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nif (!ep->is_pingpong) {\r\nDBG("iso requires double buffering\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\n}\r\nok:\r\nspin_lock_irqsave(&udc->lock, flags);\r\nep->is_in = usb_endpoint_dir_in(desc);\r\nep->is_iso = (tmp == USB_ENDPOINT_XFER_ISOC);\r\nep->stopped = 0;\r\nif (ep->is_in)\r\ntmp |= 0x04;\r\ntmp <<= 8;\r\ntmp |= AT91_UDP_EPEDS;\r\n__raw_writel(tmp, ep->creg);\r\nep->ep.maxpacket = maxpacket;\r\nat91_udp_write(udc, AT91_UDP_RST_EP, ep->int_mask);\r\nat91_udp_write(udc, AT91_UDP_RST_EP, 0);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int at91_ep_disable (struct usb_ep * _ep)\r\n{\r\nstruct at91_ep *ep = container_of(_ep, struct at91_ep, ep);\r\nstruct at91_udc *udc = ep->udc;\r\nunsigned long flags;\r\nif (ep == &ep->udc->ep[0])\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nnuke(ep, -ESHUTDOWN);\r\nep->ep.desc = NULL;\r\nep->ep.maxpacket = ep->maxpacket;\r\nif (ep->udc->clocked) {\r\nat91_udp_write(udc, AT91_UDP_RST_EP, ep->int_mask);\r\nat91_udp_write(udc, AT91_UDP_RST_EP, 0);\r\n__raw_writel(0, ep->creg);\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct usb_request *\r\nat91_ep_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)\r\n{\r\nstruct at91_request *req;\r\nreq = kzalloc(sizeof (struct at91_request), gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic void at91_ep_free_request(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct at91_request *req;\r\nreq = container_of(_req, struct at91_request, req);\r\nBUG_ON(!list_empty(&req->queue));\r\nkfree(req);\r\n}\r\nstatic int at91_ep_queue(struct usb_ep *_ep,\r\nstruct usb_request *_req, gfp_t gfp_flags)\r\n{\r\nstruct at91_request *req;\r\nstruct at91_ep *ep;\r\nstruct at91_udc *udc;\r\nint status;\r\nunsigned long flags;\r\nreq = container_of(_req, struct at91_request, req);\r\nep = container_of(_ep, struct at91_ep, ep);\r\nif (!_req || !_req->complete\r\n|| !_req->buf || !list_empty(&req->queue)) {\r\nDBG("invalid request\n");\r\nreturn -EINVAL;\r\n}\r\nif (!_ep || (!ep->ep.desc && ep->ep.name != ep0name)) {\r\nDBG("invalid ep\n");\r\nreturn -EINVAL;\r\n}\r\nudc = ep->udc;\r\nif (!udc || !udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {\r\nDBG("invalid device\n");\r\nreturn -EINVAL;\r\n}\r\n_req->status = -EINPROGRESS;\r\n_req->actual = 0;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (list_empty(&ep->queue) && !ep->stopped) {\r\nint is_ep0;\r\nis_ep0 = (ep->ep.name == ep0name);\r\nif (is_ep0) {\r\nu32 tmp;\r\nif (!udc->req_pending) {\r\nstatus = -EINVAL;\r\ngoto done;\r\n}\r\nif (udc->wait_for_config_ack) {\r\ntmp = at91_udp_read(udc, AT91_UDP_GLB_STAT);\r\ntmp ^= AT91_UDP_CONFG;\r\nVDBG("toggle config\n");\r\nat91_udp_write(udc, AT91_UDP_GLB_STAT, tmp);\r\n}\r\nif (req->req.length == 0) {\r\nep0_in_status:\r\nPACKET("ep0 in/status\n");\r\nstatus = 0;\r\ntmp = __raw_readl(ep->creg);\r\ntmp &= ~SET_FX;\r\ntmp |= CLR_FX | AT91_UDP_TXPKTRDY;\r\n__raw_writel(tmp, ep->creg);\r\nudc->req_pending = 0;\r\ngoto done;\r\n}\r\n}\r\nif (ep->is_in)\r\nstatus = write_fifo(ep, req);\r\nelse {\r\nstatus = read_fifo(ep, req);\r\nif (status && is_ep0)\r\ngoto ep0_in_status;\r\n}\r\n} else\r\nstatus = 0;\r\nif (req && !status) {\r\nlist_add_tail (&req->queue, &ep->queue);\r\nat91_udp_write(udc, AT91_UDP_IER, ep->int_mask);\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn (status < 0) ? status : 0;\r\n}\r\nstatic int at91_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct at91_ep *ep;\r\nstruct at91_request *req;\r\nunsigned long flags;\r\nstruct at91_udc *udc;\r\nep = container_of(_ep, struct at91_ep, ep);\r\nif (!_ep || ep->ep.name == ep0name)\r\nreturn -EINVAL;\r\nudc = ep->udc;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nlist_for_each_entry (req, &ep->queue, queue) {\r\nif (&req->req == _req)\r\nbreak;\r\n}\r\nif (&req->req != _req) {\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn -EINVAL;\r\n}\r\ndone(ep, req, -ECONNRESET);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int at91_ep_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nstruct at91_ep *ep = container_of(_ep, struct at91_ep, ep);\r\nstruct at91_udc *udc = ep->udc;\r\nu32 __iomem *creg;\r\nu32 csr;\r\nunsigned long flags;\r\nint status = 0;\r\nif (!_ep || ep->is_iso || !ep->udc->clocked)\r\nreturn -EINVAL;\r\ncreg = ep->creg;\r\nspin_lock_irqsave(&udc->lock, flags);\r\ncsr = __raw_readl(creg);\r\nif (ep->is_in && (!list_empty(&ep->queue) || (csr >> 16) != 0))\r\nstatus = -EAGAIN;\r\nelse {\r\ncsr |= CLR_FX;\r\ncsr &= ~SET_FX;\r\nif (value) {\r\ncsr |= AT91_UDP_FORCESTALL;\r\nVDBG("halt %s\n", ep->ep.name);\r\n} else {\r\nat91_udp_write(udc, AT91_UDP_RST_EP, ep->int_mask);\r\nat91_udp_write(udc, AT91_UDP_RST_EP, 0);\r\ncsr &= ~AT91_UDP_FORCESTALL;\r\n}\r\n__raw_writel(csr, creg);\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn status;\r\n}\r\nstatic int at91_get_frame(struct usb_gadget *gadget)\r\n{\r\nstruct at91_udc *udc = to_udc(gadget);\r\nif (!to_udc(gadget)->clocked)\r\nreturn -EINVAL;\r\nreturn at91_udp_read(udc, AT91_UDP_FRM_NUM) & AT91_UDP_NUM;\r\n}\r\nstatic int at91_wakeup(struct usb_gadget *gadget)\r\n{\r\nstruct at91_udc *udc = to_udc(gadget);\r\nu32 glbstate;\r\nint status = -EINVAL;\r\nunsigned long flags;\r\nDBG("%s\n", __func__ );\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (!udc->clocked || !udc->suspended)\r\ngoto done;\r\nglbstate = at91_udp_read(udc, AT91_UDP_GLB_STAT);\r\nif (!(glbstate & AT91_UDP_ESR))\r\ngoto done;\r\nglbstate |= AT91_UDP_ESR;\r\nat91_udp_write(udc, AT91_UDP_GLB_STAT, glbstate);\r\ndone:\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn status;\r\n}\r\nstatic void udc_reinit(struct at91_udc *udc)\r\n{\r\nu32 i;\r\nINIT_LIST_HEAD(&udc->gadget.ep_list);\r\nINIT_LIST_HEAD(&udc->gadget.ep0->ep_list);\r\nfor (i = 0; i < NUM_ENDPOINTS; i++) {\r\nstruct at91_ep *ep = &udc->ep[i];\r\nif (i != 0)\r\nlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\r\nep->ep.desc = NULL;\r\nep->stopped = 0;\r\nep->fifo_bank = 0;\r\nusb_ep_set_maxpacket_limit(&ep->ep, ep->maxpacket);\r\nep->creg = (void __iomem *) udc->udp_baseaddr + AT91_UDP_CSR(i);\r\nINIT_LIST_HEAD(&ep->queue);\r\n}\r\n}\r\nstatic void stop_activity(struct at91_udc *udc)\r\n{\r\nstruct usb_gadget_driver *driver = udc->driver;\r\nint i;\r\nif (udc->gadget.speed == USB_SPEED_UNKNOWN)\r\ndriver = NULL;\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nudc->suspended = 0;\r\nfor (i = 0; i < NUM_ENDPOINTS; i++) {\r\nstruct at91_ep *ep = &udc->ep[i];\r\nep->stopped = 1;\r\nnuke(ep, -ESHUTDOWN);\r\n}\r\nif (driver) {\r\nspin_unlock(&udc->lock);\r\ndriver->disconnect(&udc->gadget);\r\nspin_lock(&udc->lock);\r\n}\r\nudc_reinit(udc);\r\n}\r\nstatic void clk_on(struct at91_udc *udc)\r\n{\r\nif (udc->clocked)\r\nreturn;\r\nudc->clocked = 1;\r\nif (IS_ENABLED(CONFIG_COMMON_CLK)) {\r\nclk_set_rate(udc->uclk, 48000000);\r\nclk_prepare_enable(udc->uclk);\r\n}\r\nclk_prepare_enable(udc->iclk);\r\nclk_prepare_enable(udc->fclk);\r\n}\r\nstatic void clk_off(struct at91_udc *udc)\r\n{\r\nif (!udc->clocked)\r\nreturn;\r\nudc->clocked = 0;\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nclk_disable_unprepare(udc->fclk);\r\nclk_disable_unprepare(udc->iclk);\r\nif (IS_ENABLED(CONFIG_COMMON_CLK))\r\nclk_disable_unprepare(udc->uclk);\r\n}\r\nstatic void pullup(struct at91_udc *udc, int is_on)\r\n{\r\nint active = !udc->board.pullup_active_low;\r\nif (!udc->enabled || !udc->vbus)\r\nis_on = 0;\r\nDBG("%sactive\n", is_on ? "" : "in");\r\nif (is_on) {\r\nclk_on(udc);\r\nat91_udp_write(udc, AT91_UDP_ICR, AT91_UDP_RXRSM);\r\nat91_udp_write(udc, AT91_UDP_TXVC, 0);\r\nif (cpu_is_at91rm9200())\r\ngpio_set_value(udc->board.pullup_pin, active);\r\nelse if (cpu_is_at91sam9260() || cpu_is_at91sam9263() || cpu_is_at91sam9g20()) {\r\nu32 txvc = at91_udp_read(udc, AT91_UDP_TXVC);\r\ntxvc |= AT91_UDP_TXVC_PUON;\r\nat91_udp_write(udc, AT91_UDP_TXVC, txvc);\r\n} else if (cpu_is_at91sam9261() || cpu_is_at91sam9g10()) {\r\nu32 usbpucr;\r\nusbpucr = at91_matrix_read(AT91_MATRIX_USBPUCR);\r\nusbpucr |= AT91_MATRIX_USBPUCR_PUON;\r\nat91_matrix_write(AT91_MATRIX_USBPUCR, usbpucr);\r\n}\r\n} else {\r\nstop_activity(udc);\r\nat91_udp_write(udc, AT91_UDP_IDR, AT91_UDP_RXRSM);\r\nat91_udp_write(udc, AT91_UDP_TXVC, AT91_UDP_TXVC_TXVDIS);\r\nif (cpu_is_at91rm9200())\r\ngpio_set_value(udc->board.pullup_pin, !active);\r\nelse if (cpu_is_at91sam9260() || cpu_is_at91sam9263() || cpu_is_at91sam9g20()) {\r\nu32 txvc = at91_udp_read(udc, AT91_UDP_TXVC);\r\ntxvc &= ~AT91_UDP_TXVC_PUON;\r\nat91_udp_write(udc, AT91_UDP_TXVC, txvc);\r\n} else if (cpu_is_at91sam9261() || cpu_is_at91sam9g10()) {\r\nu32 usbpucr;\r\nusbpucr = at91_matrix_read(AT91_MATRIX_USBPUCR);\r\nusbpucr &= ~AT91_MATRIX_USBPUCR_PUON;\r\nat91_matrix_write(AT91_MATRIX_USBPUCR, usbpucr);\r\n}\r\nclk_off(udc);\r\n}\r\n}\r\nstatic int at91_vbus_session(struct usb_gadget *gadget, int is_active)\r\n{\r\nstruct at91_udc *udc = to_udc(gadget);\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nudc->vbus = (is_active != 0);\r\nif (udc->driver)\r\npullup(udc, is_active);\r\nelse\r\npullup(udc, 0);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int at91_pullup(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct at91_udc *udc = to_udc(gadget);\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nudc->enabled = is_on = !!is_on;\r\npullup(udc, is_on);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int at91_set_selfpowered(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct at91_udc *udc = to_udc(gadget);\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nudc->selfpowered = (is_on != 0);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int handle_ep(struct at91_ep *ep)\r\n{\r\nstruct at91_request *req;\r\nu32 __iomem *creg = ep->creg;\r\nu32 csr = __raw_readl(creg);\r\nif (!list_empty(&ep->queue))\r\nreq = list_entry(ep->queue.next,\r\nstruct at91_request, queue);\r\nelse\r\nreq = NULL;\r\nif (ep->is_in) {\r\nif (csr & (AT91_UDP_STALLSENT | AT91_UDP_TXCOMP)) {\r\ncsr |= CLR_FX;\r\ncsr &= ~(SET_FX | AT91_UDP_STALLSENT | AT91_UDP_TXCOMP);\r\n__raw_writel(csr, creg);\r\n}\r\nif (req)\r\nreturn write_fifo(ep, req);\r\n} else {\r\nif (csr & AT91_UDP_STALLSENT) {\r\nif (ep->is_iso && req)\r\nreq->req.status = -EILSEQ;\r\ncsr |= CLR_FX;\r\ncsr &= ~(SET_FX | AT91_UDP_STALLSENT);\r\n__raw_writel(csr, creg);\r\ncsr = __raw_readl(creg);\r\n}\r\nif (req && (csr & RX_DATA_READY))\r\nreturn read_fifo(ep, req);\r\n}\r\nreturn 0;\r\n}\r\nstatic void handle_setup(struct at91_udc *udc, struct at91_ep *ep, u32 csr)\r\n{\r\nu32 __iomem *creg = ep->creg;\r\nu8 __iomem *dreg = ep->creg + (AT91_UDP_FDR(0) - AT91_UDP_CSR(0));\r\nunsigned rxcount, i = 0;\r\nu32 tmp;\r\nunion setup pkt;\r\nint status = 0;\r\nrxcount = (csr & AT91_UDP_RXBYTECNT) >> 16;\r\nif (likely(rxcount == 8)) {\r\nwhile (rxcount--)\r\npkt.raw[i++] = __raw_readb(dreg);\r\nif (pkt.r.bRequestType & USB_DIR_IN) {\r\ncsr |= AT91_UDP_DIR;\r\nep->is_in = 1;\r\n} else {\r\ncsr &= ~AT91_UDP_DIR;\r\nep->is_in = 0;\r\n}\r\n} else {\r\nERR("SETUP len %d, csr %08x\n", rxcount, csr);\r\nstatus = -EINVAL;\r\n}\r\ncsr |= CLR_FX;\r\ncsr &= ~(SET_FX | AT91_UDP_RXSETUP);\r\n__raw_writel(csr, creg);\r\nudc->wait_for_addr_ack = 0;\r\nudc->wait_for_config_ack = 0;\r\nep->stopped = 0;\r\nif (unlikely(status != 0))\r\ngoto stall;\r\n#define w_index le16_to_cpu(pkt.r.wIndex)\r\n#define w_value le16_to_cpu(pkt.r.wValue)\r\n#define w_length le16_to_cpu(pkt.r.wLength)\r\nVDBG("SETUP %02x.%02x v%04x i%04x l%04x\n",\r\npkt.r.bRequestType, pkt.r.bRequest,\r\nw_value, w_index, w_length);\r\nudc->req_pending = 1;\r\ncsr = __raw_readl(creg);\r\ncsr |= CLR_FX;\r\ncsr &= ~SET_FX;\r\nswitch ((pkt.r.bRequestType << 8) | pkt.r.bRequest) {\r\ncase ((USB_TYPE_STANDARD|USB_RECIP_DEVICE) << 8)\r\n| USB_REQ_SET_ADDRESS:\r\n__raw_writel(csr | AT91_UDP_TXPKTRDY, creg);\r\nudc->addr = w_value;\r\nudc->wait_for_addr_ack = 1;\r\nudc->req_pending = 0;\r\nreturn;\r\ncase ((USB_TYPE_STANDARD|USB_RECIP_DEVICE) << 8)\r\n| USB_REQ_SET_CONFIGURATION:\r\ntmp = at91_udp_read(udc, AT91_UDP_GLB_STAT) & AT91_UDP_CONFG;\r\nif (pkt.r.wValue)\r\nudc->wait_for_config_ack = (tmp == 0);\r\nelse\r\nudc->wait_for_config_ack = (tmp != 0);\r\nif (udc->wait_for_config_ack)\r\nVDBG("wait for config\n");\r\nbreak;\r\ncase ((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_DEVICE) << 8)\r\n| USB_REQ_GET_STATUS:\r\ntmp = (udc->selfpowered << USB_DEVICE_SELF_POWERED);\r\nif (at91_udp_read(udc, AT91_UDP_GLB_STAT) & AT91_UDP_ESR)\r\ntmp |= (1 << USB_DEVICE_REMOTE_WAKEUP);\r\nPACKET("get device status\n");\r\n__raw_writeb(tmp, dreg);\r\n__raw_writeb(0, dreg);\r\ngoto write_in;\r\ncase ((USB_TYPE_STANDARD|USB_RECIP_DEVICE) << 8)\r\n| USB_REQ_SET_FEATURE:\r\nif (w_value != USB_DEVICE_REMOTE_WAKEUP)\r\ngoto stall;\r\ntmp = at91_udp_read(udc, AT91_UDP_GLB_STAT);\r\ntmp |= AT91_UDP_ESR;\r\nat91_udp_write(udc, AT91_UDP_GLB_STAT, tmp);\r\ngoto succeed;\r\ncase ((USB_TYPE_STANDARD|USB_RECIP_DEVICE) << 8)\r\n| USB_REQ_CLEAR_FEATURE:\r\nif (w_value != USB_DEVICE_REMOTE_WAKEUP)\r\ngoto stall;\r\ntmp = at91_udp_read(udc, AT91_UDP_GLB_STAT);\r\ntmp &= ~AT91_UDP_ESR;\r\nat91_udp_write(udc, AT91_UDP_GLB_STAT, tmp);\r\ngoto succeed;\r\ncase ((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_INTERFACE) << 8)\r\n| USB_REQ_GET_STATUS:\r\nPACKET("get interface status\n");\r\n__raw_writeb(0, dreg);\r\n__raw_writeb(0, dreg);\r\ngoto write_in;\r\ncase ((USB_TYPE_STANDARD|USB_RECIP_INTERFACE) << 8)\r\n| USB_REQ_SET_FEATURE:\r\ncase ((USB_TYPE_STANDARD|USB_RECIP_INTERFACE) << 8)\r\n| USB_REQ_CLEAR_FEATURE:\r\ngoto stall;\r\ncase ((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_ENDPOINT) << 8)\r\n| USB_REQ_GET_STATUS:\r\ntmp = w_index & USB_ENDPOINT_NUMBER_MASK;\r\nep = &udc->ep[tmp];\r\nif (tmp >= NUM_ENDPOINTS || (tmp && !ep->ep.desc))\r\ngoto stall;\r\nif (tmp) {\r\nif ((w_index & USB_DIR_IN)) {\r\nif (!ep->is_in)\r\ngoto stall;\r\n} else if (ep->is_in)\r\ngoto stall;\r\n}\r\nPACKET("get %s status\n", ep->ep.name);\r\nif (__raw_readl(ep->creg) & AT91_UDP_FORCESTALL)\r\ntmp = (1 << USB_ENDPOINT_HALT);\r\nelse\r\ntmp = 0;\r\n__raw_writeb(tmp, dreg);\r\n__raw_writeb(0, dreg);\r\ngoto write_in;\r\ncase ((USB_TYPE_STANDARD|USB_RECIP_ENDPOINT) << 8)\r\n| USB_REQ_SET_FEATURE:\r\ntmp = w_index & USB_ENDPOINT_NUMBER_MASK;\r\nep = &udc->ep[tmp];\r\nif (w_value != USB_ENDPOINT_HALT || tmp >= NUM_ENDPOINTS)\r\ngoto stall;\r\nif (!ep->ep.desc || ep->is_iso)\r\ngoto stall;\r\nif ((w_index & USB_DIR_IN)) {\r\nif (!ep->is_in)\r\ngoto stall;\r\n} else if (ep->is_in)\r\ngoto stall;\r\ntmp = __raw_readl(ep->creg);\r\ntmp &= ~SET_FX;\r\ntmp |= CLR_FX | AT91_UDP_FORCESTALL;\r\n__raw_writel(tmp, ep->creg);\r\ngoto succeed;\r\ncase ((USB_TYPE_STANDARD|USB_RECIP_ENDPOINT) << 8)\r\n| USB_REQ_CLEAR_FEATURE:\r\ntmp = w_index & USB_ENDPOINT_NUMBER_MASK;\r\nep = &udc->ep[tmp];\r\nif (w_value != USB_ENDPOINT_HALT || tmp >= NUM_ENDPOINTS)\r\ngoto stall;\r\nif (tmp == 0)\r\ngoto succeed;\r\nif (!ep->ep.desc || ep->is_iso)\r\ngoto stall;\r\nif ((w_index & USB_DIR_IN)) {\r\nif (!ep->is_in)\r\ngoto stall;\r\n} else if (ep->is_in)\r\ngoto stall;\r\nat91_udp_write(udc, AT91_UDP_RST_EP, ep->int_mask);\r\nat91_udp_write(udc, AT91_UDP_RST_EP, 0);\r\ntmp = __raw_readl(ep->creg);\r\ntmp |= CLR_FX;\r\ntmp &= ~(SET_FX | AT91_UDP_FORCESTALL);\r\n__raw_writel(tmp, ep->creg);\r\nif (!list_empty(&ep->queue))\r\nhandle_ep(ep);\r\ngoto succeed;\r\n}\r\n#undef w_value\r\n#undef w_index\r\n#undef w_length\r\nif (udc->driver) {\r\nspin_unlock(&udc->lock);\r\nstatus = udc->driver->setup(&udc->gadget, &pkt.r);\r\nspin_lock(&udc->lock);\r\n}\r\nelse\r\nstatus = -ENODEV;\r\nif (status < 0) {\r\nstall:\r\nVDBG("req %02x.%02x protocol STALL; stat %d\n",\r\npkt.r.bRequestType, pkt.r.bRequest, status);\r\ncsr |= AT91_UDP_FORCESTALL;\r\n__raw_writel(csr, creg);\r\nudc->req_pending = 0;\r\n}\r\nreturn;\r\nsucceed:\r\nPACKET("ep0 in/status\n");\r\nwrite_in:\r\ncsr |= AT91_UDP_TXPKTRDY;\r\n__raw_writel(csr, creg);\r\nudc->req_pending = 0;\r\n}\r\nstatic void handle_ep0(struct at91_udc *udc)\r\n{\r\nstruct at91_ep *ep0 = &udc->ep[0];\r\nu32 __iomem *creg = ep0->creg;\r\nu32 csr = __raw_readl(creg);\r\nstruct at91_request *req;\r\nif (unlikely(csr & AT91_UDP_STALLSENT)) {\r\nnuke(ep0, -EPROTO);\r\nudc->req_pending = 0;\r\ncsr |= CLR_FX;\r\ncsr &= ~(SET_FX | AT91_UDP_STALLSENT | AT91_UDP_FORCESTALL);\r\n__raw_writel(csr, creg);\r\nVDBG("ep0 stalled\n");\r\ncsr = __raw_readl(creg);\r\n}\r\nif (csr & AT91_UDP_RXSETUP) {\r\nnuke(ep0, 0);\r\nudc->req_pending = 0;\r\nhandle_setup(udc, ep0, csr);\r\nreturn;\r\n}\r\nif (list_empty(&ep0->queue))\r\nreq = NULL;\r\nelse\r\nreq = list_entry(ep0->queue.next, struct at91_request, queue);\r\nif (csr & AT91_UDP_TXCOMP) {\r\ncsr |= CLR_FX;\r\ncsr &= ~(SET_FX | AT91_UDP_TXCOMP);\r\nif (req && ep0->is_in) {\r\nif (handle_ep(ep0))\r\nudc->req_pending = 0;\r\n} else {\r\nudc->req_pending = 0;\r\n__raw_writel(csr, creg);\r\nif (udc->wait_for_addr_ack) {\r\nu32 tmp;\r\nat91_udp_write(udc, AT91_UDP_FADDR,\r\nAT91_UDP_FEN | udc->addr);\r\ntmp = at91_udp_read(udc, AT91_UDP_GLB_STAT);\r\ntmp &= ~AT91_UDP_FADDEN;\r\nif (udc->addr)\r\ntmp |= AT91_UDP_FADDEN;\r\nat91_udp_write(udc, AT91_UDP_GLB_STAT, tmp);\r\nudc->wait_for_addr_ack = 0;\r\nVDBG("address %d\n", udc->addr);\r\n}\r\n}\r\n}\r\nelse if (csr & AT91_UDP_RX_DATA_BK0) {\r\ncsr |= CLR_FX;\r\ncsr &= ~(SET_FX | AT91_UDP_RX_DATA_BK0);\r\nif (!ep0->is_in) {\r\nif (req) {\r\nif (handle_ep(ep0)) {\r\nPACKET("ep0 in/status\n");\r\ncsr = __raw_readl(creg);\r\ncsr &= ~SET_FX;\r\ncsr |= CLR_FX | AT91_UDP_TXPKTRDY;\r\n__raw_writel(csr, creg);\r\nudc->req_pending = 0;\r\n}\r\n} else if (udc->req_pending) {\r\nDBG("no control-OUT deferred responses!\n");\r\n__raw_writel(csr | AT91_UDP_FORCESTALL, creg);\r\nudc->req_pending = 0;\r\n}\r\n} else {\r\nPACKET("ep0 out/status ACK\n");\r\n__raw_writel(csr, creg);\r\nif (req)\r\ndone(ep0, req, 0);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t at91_udc_irq (int irq, void *_udc)\r\n{\r\nstruct at91_udc *udc = _udc;\r\nu32 rescans = 5;\r\nint disable_clock = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (!udc->clocked) {\r\nclk_on(udc);\r\ndisable_clock = 1;\r\n}\r\nwhile (rescans--) {\r\nu32 status;\r\nstatus = at91_udp_read(udc, AT91_UDP_ISR)\r\n& at91_udp_read(udc, AT91_UDP_IMR);\r\nif (!status)\r\nbreak;\r\nif (status & AT91_UDP_ENDBUSRES) {\r\nat91_udp_write(udc, AT91_UDP_IDR, ~MINIMUS_INTERRUPTUS);\r\nat91_udp_write(udc, AT91_UDP_IER, MINIMUS_INTERRUPTUS);\r\nat91_udp_write(udc, AT91_UDP_ICR, AT91_UDP_ENDBUSRES);\r\nat91_udp_write(udc, AT91_UDP_ICR, AT91_UDP_ENDBUSRES);\r\nVDBG("end bus reset\n");\r\nudc->addr = 0;\r\nstop_activity(udc);\r\nat91_udp_write(udc, AT91_UDP_CSR(0),\r\nAT91_UDP_EPEDS | AT91_UDP_EPTYPE_CTRL);\r\nudc->gadget.speed = USB_SPEED_FULL;\r\nudc->suspended = 0;\r\nat91_udp_write(udc, AT91_UDP_IER, AT91_UDP_EP(0));\r\n} else if (status & AT91_UDP_RXSUSP) {\r\nat91_udp_write(udc, AT91_UDP_IDR, AT91_UDP_RXSUSP);\r\nat91_udp_write(udc, AT91_UDP_IER, AT91_UDP_RXRSM);\r\nat91_udp_write(udc, AT91_UDP_ICR, AT91_UDP_RXSUSP);\r\nif (udc->suspended)\r\ncontinue;\r\nudc->suspended = 1;\r\nif (udc->driver && udc->driver->suspend) {\r\nspin_unlock(&udc->lock);\r\nudc->driver->suspend(&udc->gadget);\r\nspin_lock(&udc->lock);\r\n}\r\n} else if (status & AT91_UDP_RXRSM) {\r\nat91_udp_write(udc, AT91_UDP_IDR, AT91_UDP_RXRSM);\r\nat91_udp_write(udc, AT91_UDP_IER, AT91_UDP_RXSUSP);\r\nat91_udp_write(udc, AT91_UDP_ICR, AT91_UDP_RXRSM);\r\nif (!udc->suspended)\r\ncontinue;\r\nudc->suspended = 0;\r\nif (udc->driver && udc->driver->resume) {\r\nspin_unlock(&udc->lock);\r\nudc->driver->resume(&udc->gadget);\r\nspin_lock(&udc->lock);\r\n}\r\n} else {\r\nint i;\r\nunsigned mask = 1;\r\nstruct at91_ep *ep = &udc->ep[1];\r\nif (status & mask)\r\nhandle_ep0(udc);\r\nfor (i = 1; i < NUM_ENDPOINTS; i++) {\r\nmask <<= 1;\r\nif (status & mask)\r\nhandle_ep(ep);\r\nep++;\r\n}\r\n}\r\n}\r\nif (disable_clock)\r\nclk_off(udc);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void nop_release(struct device *dev)\r\n{\r\n}\r\nstatic void at91_vbus_update(struct at91_udc *udc, unsigned value)\r\n{\r\nvalue ^= udc->board.vbus_active_low;\r\nif (value != udc->vbus)\r\nat91_vbus_session(&udc->gadget, value);\r\n}\r\nstatic irqreturn_t at91_vbus_irq(int irq, void *_udc)\r\n{\r\nstruct at91_udc *udc = _udc;\r\nudelay(10);\r\nat91_vbus_update(udc, gpio_get_value(udc->board.vbus_pin));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void at91_vbus_timer_work(struct work_struct *work)\r\n{\r\nstruct at91_udc *udc = container_of(work, struct at91_udc,\r\nvbus_timer_work);\r\nat91_vbus_update(udc, gpio_get_value_cansleep(udc->board.vbus_pin));\r\nif (!timer_pending(&udc->vbus_timer))\r\nmod_timer(&udc->vbus_timer, jiffies + VBUS_POLL_TIMEOUT);\r\n}\r\nstatic void at91_vbus_timer(unsigned long data)\r\n{\r\nstruct at91_udc *udc = (struct at91_udc *)data;\r\nschedule_work(&udc->vbus_timer_work);\r\n}\r\nstatic int at91_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct at91_udc *udc;\r\nudc = container_of(gadget, struct at91_udc, gadget);\r\nudc->driver = driver;\r\nudc->gadget.dev.of_node = udc->pdev->dev.of_node;\r\nudc->enabled = 1;\r\nudc->selfpowered = 1;\r\nDBG("bound to %s\n", driver->driver.name);\r\nreturn 0;\r\n}\r\nstatic int at91_stop(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct at91_udc *udc;\r\nunsigned long flags;\r\nudc = container_of(gadget, struct at91_udc, gadget);\r\nspin_lock_irqsave(&udc->lock, flags);\r\nudc->enabled = 0;\r\nat91_udp_write(udc, AT91_UDP_IDR, ~0);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nudc->driver = NULL;\r\nDBG("unbound from %s\n", driver->driver.name);\r\nreturn 0;\r\n}\r\nstatic void at91udc_shutdown(struct platform_device *dev)\r\n{\r\nstruct at91_udc *udc = platform_get_drvdata(dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\npullup(platform_get_drvdata(dev), 0);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\n}\r\nstatic void at91udc_of_init(struct at91_udc *udc,\r\nstruct device_node *np)\r\n{\r\nstruct at91_udc_data *board = &udc->board;\r\nu32 val;\r\nenum of_gpio_flags flags;\r\nif (of_property_read_u32(np, "atmel,vbus-polled", &val) == 0)\r\nboard->vbus_polled = 1;\r\nboard->vbus_pin = of_get_named_gpio_flags(np, "atmel,vbus-gpio", 0,\r\n&flags);\r\nboard->vbus_active_low = (flags & OF_GPIO_ACTIVE_LOW) ? 1 : 0;\r\nboard->pullup_pin = of_get_named_gpio_flags(np, "atmel,pullup-gpio", 0,\r\n&flags);\r\nboard->pullup_active_low = (flags & OF_GPIO_ACTIVE_LOW) ? 1 : 0;\r\n}\r\nstatic int at91udc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct at91_udc *udc;\r\nint retval;\r\nstruct resource *res;\r\nif (!dev_get_platdata(dev) && !pdev->dev.of_node) {\r\nDBG("missing platform_data\n");\r\nreturn -ENODEV;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENXIO;\r\nif (!request_mem_region(res->start, resource_size(res), driver_name)) {\r\nDBG("someone's using UDC memory\n");\r\nreturn -EBUSY;\r\n}\r\nudc = &controller;\r\nudc->gadget.dev.parent = dev;\r\nif (IS_ENABLED(CONFIG_OF) && pdev->dev.of_node)\r\nat91udc_of_init(udc, pdev->dev.of_node);\r\nelse\r\nmemcpy(&udc->board, dev_get_platdata(dev),\r\nsizeof(struct at91_udc_data));\r\nudc->pdev = pdev;\r\nudc->enabled = 0;\r\nspin_lock_init(&udc->lock);\r\nif (cpu_is_at91rm9200()) {\r\nif (!gpio_is_valid(udc->board.pullup_pin)) {\r\nDBG("no D+ pullup?\n");\r\nretval = -ENODEV;\r\ngoto fail0;\r\n}\r\nretval = gpio_request(udc->board.pullup_pin, "udc_pullup");\r\nif (retval) {\r\nDBG("D+ pullup is busy\n");\r\ngoto fail0;\r\n}\r\ngpio_direction_output(udc->board.pullup_pin,\r\nudc->board.pullup_active_low);\r\n}\r\nif (cpu_is_at91sam9260() || cpu_is_at91sam9g20()) {\r\nudc->ep[0].maxpacket = 64;\r\nudc->ep[3].maxpacket = 64;\r\nudc->ep[4].maxpacket = 512;\r\nudc->ep[5].maxpacket = 512;\r\n} else if (cpu_is_at91sam9261() || cpu_is_at91sam9g10()) {\r\nudc->ep[3].maxpacket = 64;\r\n} else if (cpu_is_at91sam9263()) {\r\nudc->ep[0].maxpacket = 64;\r\nudc->ep[3].maxpacket = 64;\r\n}\r\nudc->udp_baseaddr = ioremap(res->start, resource_size(res));\r\nif (!udc->udp_baseaddr) {\r\nretval = -ENOMEM;\r\ngoto fail0a;\r\n}\r\nudc_reinit(udc);\r\nudc->iclk = clk_get(dev, "udc_clk");\r\nudc->fclk = clk_get(dev, "udpck");\r\nif (IS_ENABLED(CONFIG_COMMON_CLK))\r\nudc->uclk = clk_get(dev, "usb_clk");\r\nif (IS_ERR(udc->iclk) || IS_ERR(udc->fclk) ||\r\n(IS_ENABLED(CONFIG_COMMON_CLK) && IS_ERR(udc->uclk))) {\r\nDBG("clocks missing\n");\r\nretval = -ENODEV;\r\ngoto fail1;\r\n}\r\nretval = clk_prepare_enable(udc->iclk);\r\nif (retval)\r\ngoto fail1;\r\nat91_udp_write(udc, AT91_UDP_TXVC, AT91_UDP_TXVC_TXVDIS);\r\nat91_udp_write(udc, AT91_UDP_IDR, 0xffffffff);\r\nat91_udp_write(udc, AT91_UDP_ICR, 0xffffffff);\r\nclk_disable_unprepare(udc->iclk);\r\nudc->udp_irq = platform_get_irq(pdev, 0);\r\nretval = request_irq(udc->udp_irq, at91_udc_irq,\r\n0, driver_name, udc);\r\nif (retval < 0) {\r\nDBG("request irq %d failed\n", udc->udp_irq);\r\ngoto fail1;\r\n}\r\nif (gpio_is_valid(udc->board.vbus_pin)) {\r\nretval = gpio_request(udc->board.vbus_pin, "udc_vbus");\r\nif (retval < 0) {\r\nDBG("request vbus pin failed\n");\r\ngoto fail2;\r\n}\r\ngpio_direction_input(udc->board.vbus_pin);\r\nudc->vbus = gpio_get_value_cansleep(udc->board.vbus_pin) ^\r\nudc->board.vbus_active_low;\r\nif (udc->board.vbus_polled) {\r\nINIT_WORK(&udc->vbus_timer_work, at91_vbus_timer_work);\r\nsetup_timer(&udc->vbus_timer, at91_vbus_timer,\r\n(unsigned long)udc);\r\nmod_timer(&udc->vbus_timer,\r\njiffies + VBUS_POLL_TIMEOUT);\r\n} else {\r\nif (request_irq(gpio_to_irq(udc->board.vbus_pin),\r\nat91_vbus_irq, 0, driver_name, udc)) {\r\nDBG("request vbus irq %d failed\n",\r\nudc->board.vbus_pin);\r\nretval = -EBUSY;\r\ngoto fail3;\r\n}\r\n}\r\n} else {\r\nDBG("no VBUS detection, assuming always-on\n");\r\nudc->vbus = 1;\r\n}\r\nretval = usb_add_gadget_udc(dev, &udc->gadget);\r\nif (retval)\r\ngoto fail4;\r\ndev_set_drvdata(dev, udc);\r\ndevice_init_wakeup(dev, 1);\r\ncreate_debug_file(udc);\r\nINFO("%s version %s\n", driver_name, DRIVER_VERSION);\r\nreturn 0;\r\nfail4:\r\nif (gpio_is_valid(udc->board.vbus_pin) && !udc->board.vbus_polled)\r\nfree_irq(gpio_to_irq(udc->board.vbus_pin), udc);\r\nfail3:\r\nif (gpio_is_valid(udc->board.vbus_pin))\r\ngpio_free(udc->board.vbus_pin);\r\nfail2:\r\nfree_irq(udc->udp_irq, udc);\r\nfail1:\r\nif (IS_ENABLED(CONFIG_COMMON_CLK) && !IS_ERR(udc->uclk))\r\nclk_put(udc->uclk);\r\nif (!IS_ERR(udc->fclk))\r\nclk_put(udc->fclk);\r\nif (!IS_ERR(udc->iclk))\r\nclk_put(udc->iclk);\r\niounmap(udc->udp_baseaddr);\r\nfail0a:\r\nif (cpu_is_at91rm9200())\r\ngpio_free(udc->board.pullup_pin);\r\nfail0:\r\nrelease_mem_region(res->start, resource_size(res));\r\nDBG("%s probe failed, %d\n", driver_name, retval);\r\nreturn retval;\r\n}\r\nstatic int __exit at91udc_remove(struct platform_device *pdev)\r\n{\r\nstruct at91_udc *udc = platform_get_drvdata(pdev);\r\nstruct resource *res;\r\nunsigned long flags;\r\nDBG("remove\n");\r\nusb_del_gadget_udc(&udc->gadget);\r\nif (udc->driver)\r\nreturn -EBUSY;\r\nspin_lock_irqsave(&udc->lock, flags);\r\npullup(udc, 0);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nremove_debug_file(udc);\r\nif (gpio_is_valid(udc->board.vbus_pin)) {\r\nfree_irq(gpio_to_irq(udc->board.vbus_pin), udc);\r\ngpio_free(udc->board.vbus_pin);\r\n}\r\nfree_irq(udc->udp_irq, udc);\r\niounmap(udc->udp_baseaddr);\r\nif (cpu_is_at91rm9200())\r\ngpio_free(udc->board.pullup_pin);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\nclk_put(udc->iclk);\r\nclk_put(udc->fclk);\r\nif (IS_ENABLED(CONFIG_COMMON_CLK))\r\nclk_put(udc->uclk);\r\nreturn 0;\r\n}\r\nstatic int at91udc_suspend(struct platform_device *pdev, pm_message_t mesg)\r\n{\r\nstruct at91_udc *udc = platform_get_drvdata(pdev);\r\nint wake = udc->driver && device_may_wakeup(&pdev->dev);\r\nunsigned long flags;\r\nif ((!udc->suspended && udc->addr)\r\n|| !wake\r\n|| at91_suspend_entering_slow_clock()) {\r\nspin_lock_irqsave(&udc->lock, flags);\r\npullup(udc, 0);\r\nwake = 0;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\n} else\r\nenable_irq_wake(udc->udp_irq);\r\nudc->active_suspend = wake;\r\nif (gpio_is_valid(udc->board.vbus_pin) && !udc->board.vbus_polled && wake)\r\nenable_irq_wake(udc->board.vbus_pin);\r\nreturn 0;\r\n}\r\nstatic int at91udc_resume(struct platform_device *pdev)\r\n{\r\nstruct at91_udc *udc = platform_get_drvdata(pdev);\r\nunsigned long flags;\r\nif (gpio_is_valid(udc->board.vbus_pin) && !udc->board.vbus_polled &&\r\nudc->active_suspend)\r\ndisable_irq_wake(udc->board.vbus_pin);\r\nif (udc->active_suspend)\r\ndisable_irq_wake(udc->udp_irq);\r\nelse {\r\nspin_lock_irqsave(&udc->lock, flags);\r\npullup(udc, 1);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\n}\r\nreturn 0;\r\n}
