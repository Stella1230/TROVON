static inline unsigned int pit_read(unsigned int reg_offset)\r\n{\r\nreturn __raw_readl(pit_base_addr + reg_offset);\r\n}\r\nstatic inline void pit_write(unsigned int reg_offset, unsigned long value)\r\n{\r\n__raw_writel(value, pit_base_addr + reg_offset);\r\n}\r\nstatic cycle_t read_pit_clk(struct clocksource *cs)\r\n{\r\nunsigned long flags;\r\nu32 elapsed;\r\nu32 t;\r\nraw_local_irq_save(flags);\r\nelapsed = pit_cnt;\r\nt = pit_read(AT91_PIT_PIIR);\r\nraw_local_irq_restore(flags);\r\nelapsed += PIT_PICNT(t) * pit_cycle;\r\nelapsed += PIT_CPIV(t);\r\nreturn elapsed;\r\n}\r\nstatic void\r\npit_clkevt_mode(enum clock_event_mode mode, struct clock_event_device *dev)\r\n{\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\npit_cnt += pit_cycle * PIT_PICNT(pit_read(AT91_PIT_PIVR));\r\npit_write(AT91_PIT_MR, (pit_cycle - 1) | AT91_PIT_PITEN\r\n| AT91_PIT_PITIEN);\r\nbreak;\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\nBUG();\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\ncase CLOCK_EVT_MODE_UNUSED:\r\npit_write(AT91_PIT_MR, (pit_cycle - 1) | AT91_PIT_PITEN);\r\nbreak;\r\ncase CLOCK_EVT_MODE_RESUME:\r\nbreak;\r\n}\r\n}\r\nstatic void at91sam926x_pit_suspend(struct clock_event_device *cedev)\r\n{\r\npit_write(AT91_PIT_MR, 0);\r\n}\r\nstatic void at91sam926x_pit_reset(void)\r\n{\r\npit_write(AT91_PIT_MR, 0);\r\nwhile (PIT_CPIV(pit_read(AT91_PIT_PIVR)) != 0)\r\ncpu_relax();\r\npit_write(AT91_PIT_MR, (pit_cycle - 1) | AT91_PIT_PITEN);\r\n}\r\nstatic void at91sam926x_pit_resume(struct clock_event_device *cedev)\r\n{\r\nat91sam926x_pit_reset();\r\n}\r\nstatic irqreturn_t at91sam926x_pit_interrupt(int irq, void *dev_id)\r\n{\r\nWARN_ON_ONCE(!irqs_disabled());\r\nif ((pit_clkevt.mode == CLOCK_EVT_MODE_PERIODIC)\r\n&& (pit_read(AT91_PIT_SR) & AT91_PIT_PITS)) {\r\nunsigned nr_ticks;\r\nnr_ticks = PIT_PICNT(pit_read(AT91_PIT_PIVR));\r\ndo {\r\npit_cnt += pit_cycle;\r\npit_clkevt.event_handler(&pit_clkevt);\r\nnr_ticks--;\r\n} while (nr_ticks);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int __init of_at91sam926x_pit_init(void)\r\n{\r\nstruct device_node *np;\r\nint ret;\r\nnp = of_find_matching_node(NULL, pit_timer_ids);\r\nif (!np)\r\ngoto err;\r\npit_base_addr = of_iomap(np, 0);\r\nif (!pit_base_addr)\r\ngoto node_err;\r\nmck = of_clk_get(np, 0);\r\nret = irq_of_parse_and_map(np, 0);\r\nif (!ret) {\r\npr_crit("AT91: PIT: Unable to get IRQ from DT\n");\r\nif (!IS_ERR(mck))\r\nclk_put(mck);\r\ngoto ioremap_err;\r\n}\r\nat91sam926x_pit_irq.irq = ret;\r\nof_node_put(np);\r\nreturn 0;\r\nioremap_err:\r\niounmap(pit_base_addr);\r\nnode_err:\r\nof_node_put(np);\r\nerr:\r\nreturn -EINVAL;\r\n}\r\nstatic int __init of_at91sam926x_pit_init(void)\r\n{\r\nreturn -EINVAL;\r\n}\r\nvoid __init at91sam926x_pit_init(void)\r\n{\r\nunsigned long pit_rate;\r\nunsigned bits;\r\nint ret;\r\nmck = ERR_PTR(-ENOENT);\r\nof_at91sam926x_pit_init();\r\nif (IS_ERR(mck))\r\nmck = clk_get(NULL, "mck");\r\nif (IS_ERR(mck))\r\npanic("AT91: PIT: Unable to get mck clk\n");\r\npit_rate = clk_get_rate(mck) / 16;\r\npit_cycle = (pit_rate + HZ/2) / HZ;\r\nWARN_ON(((pit_cycle - 1) & ~AT91_PIT_PIV) != 0);\r\nat91sam926x_pit_reset();\r\nbits = 12 + ilog2(pit_cycle) ;\r\npit_clk.mask = CLOCKSOURCE_MASK(bits);\r\nclocksource_register_hz(&pit_clk, pit_rate);\r\nret = setup_irq(at91sam926x_pit_irq.irq, &at91sam926x_pit_irq);\r\nif (ret)\r\npr_crit("AT91: PIT: Unable to setup IRQ\n");\r\npit_clkevt.mult = div_sc(pit_rate, NSEC_PER_SEC, pit_clkevt.shift);\r\npit_clkevt.cpumask = cpumask_of(0);\r\nclockevents_register_device(&pit_clkevt);\r\n}\r\nvoid __init at91sam926x_ioremap_pit(u32 addr)\r\n{\r\n#if defined(CONFIG_OF)\r\nstruct device_node *np =\r\nof_find_matching_node(NULL, pit_timer_ids);\r\nif (np) {\r\nof_node_put(np);\r\nreturn;\r\n}\r\n#endif\r\npit_base_addr = ioremap(addr, 16);\r\nif (!pit_base_addr)\r\npanic("Impossible to ioremap PIT\n");\r\n}
