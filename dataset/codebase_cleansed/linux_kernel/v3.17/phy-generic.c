struct platform_device *usb_phy_generic_register(void)\r\n{\r\nreturn platform_device_register_simple("usb_phy_generic",\r\nPLATFORM_DEVID_AUTO, NULL, 0);\r\n}\r\nvoid usb_phy_generic_unregister(struct platform_device *pdev)\r\n{\r\nplatform_device_unregister(pdev);\r\n}\r\nstatic int nop_set_suspend(struct usb_phy *x, int suspend)\r\n{\r\nreturn 0;\r\n}\r\nstatic void nop_reset_set(struct usb_phy_generic *nop, int asserted)\r\n{\r\nint value;\r\nif (!gpio_is_valid(nop->gpio_reset))\r\nreturn;\r\nvalue = asserted;\r\nif (nop->reset_active_low)\r\nvalue = !value;\r\ngpio_set_value_cansleep(nop->gpio_reset, value);\r\nif (!asserted)\r\nusleep_range(10000, 20000);\r\n}\r\nint usb_gen_phy_init(struct usb_phy *phy)\r\n{\r\nstruct usb_phy_generic *nop = dev_get_drvdata(phy->dev);\r\nif (!IS_ERR(nop->vcc)) {\r\nif (regulator_enable(nop->vcc))\r\ndev_err(phy->dev, "Failed to enable power\n");\r\n}\r\nif (!IS_ERR(nop->clk))\r\nclk_prepare_enable(nop->clk);\r\nnop_reset_set(nop, 0);\r\nreturn 0;\r\n}\r\nvoid usb_gen_phy_shutdown(struct usb_phy *phy)\r\n{\r\nstruct usb_phy_generic *nop = dev_get_drvdata(phy->dev);\r\nnop_reset_set(nop, 1);\r\nif (!IS_ERR(nop->clk))\r\nclk_disable_unprepare(nop->clk);\r\nif (!IS_ERR(nop->vcc)) {\r\nif (regulator_disable(nop->vcc))\r\ndev_err(phy->dev, "Failed to disable power\n");\r\n}\r\n}\r\nstatic int nop_set_peripheral(struct usb_otg *otg, struct usb_gadget *gadget)\r\n{\r\nif (!otg)\r\nreturn -ENODEV;\r\nif (!gadget) {\r\notg->gadget = NULL;\r\nreturn -ENODEV;\r\n}\r\notg->gadget = gadget;\r\notg->phy->state = OTG_STATE_B_IDLE;\r\nreturn 0;\r\n}\r\nstatic int nop_set_host(struct usb_otg *otg, struct usb_bus *host)\r\n{\r\nif (!otg)\r\nreturn -ENODEV;\r\nif (!host) {\r\notg->host = NULL;\r\nreturn -ENODEV;\r\n}\r\notg->host = host;\r\nreturn 0;\r\n}\r\nint usb_phy_gen_create_phy(struct device *dev, struct usb_phy_generic *nop,\r\nstruct usb_phy_generic_platform_data *pdata)\r\n{\r\nenum usb_phy_type type = USB_PHY_TYPE_USB2;\r\nint err;\r\nu32 clk_rate = 0;\r\nbool needs_vcc = false;\r\nnop->reset_active_low = true;\r\nif (dev->of_node) {\r\nstruct device_node *node = dev->of_node;\r\nenum of_gpio_flags flags = 0;\r\nif (of_property_read_u32(node, "clock-frequency", &clk_rate))\r\nclk_rate = 0;\r\nneeds_vcc = of_property_read_bool(node, "vcc-supply");\r\nnop->gpio_reset = of_get_named_gpio_flags(node, "reset-gpios",\r\n0, &flags);\r\nif (nop->gpio_reset == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nnop->reset_active_low = flags & OF_GPIO_ACTIVE_LOW;\r\n} else if (pdata) {\r\ntype = pdata->type;\r\nclk_rate = pdata->clk_rate;\r\nneeds_vcc = pdata->needs_vcc;\r\nnop->gpio_reset = pdata->gpio_reset;\r\n} else {\r\nnop->gpio_reset = -1;\r\n}\r\nnop->phy.otg = devm_kzalloc(dev, sizeof(*nop->phy.otg),\r\nGFP_KERNEL);\r\nif (!nop->phy.otg)\r\nreturn -ENOMEM;\r\nnop->clk = devm_clk_get(dev, "main_clk");\r\nif (IS_ERR(nop->clk)) {\r\ndev_dbg(dev, "Can't get phy clock: %ld\n",\r\nPTR_ERR(nop->clk));\r\n}\r\nif (!IS_ERR(nop->clk) && clk_rate) {\r\nerr = clk_set_rate(nop->clk, clk_rate);\r\nif (err) {\r\ndev_err(dev, "Error setting clock rate\n");\r\nreturn err;\r\n}\r\n}\r\nnop->vcc = devm_regulator_get(dev, "vcc");\r\nif (IS_ERR(nop->vcc)) {\r\ndev_dbg(dev, "Error getting vcc regulator: %ld\n",\r\nPTR_ERR(nop->vcc));\r\nif (needs_vcc)\r\nreturn -EPROBE_DEFER;\r\n}\r\nif (gpio_is_valid(nop->gpio_reset)) {\r\nunsigned long gpio_flags;\r\nif (nop->reset_active_low)\r\ngpio_flags = GPIOF_OUT_INIT_LOW;\r\nelse\r\ngpio_flags = GPIOF_OUT_INIT_HIGH;\r\nerr = devm_gpio_request_one(dev, nop->gpio_reset,\r\ngpio_flags, dev_name(dev));\r\nif (err) {\r\ndev_err(dev, "Error requesting RESET GPIO %d\n",\r\nnop->gpio_reset);\r\nreturn err;\r\n}\r\n}\r\nnop->dev = dev;\r\nnop->phy.dev = nop->dev;\r\nnop->phy.label = "nop-xceiv";\r\nnop->phy.set_suspend = nop_set_suspend;\r\nnop->phy.state = OTG_STATE_UNDEFINED;\r\nnop->phy.type = type;\r\nnop->phy.otg->phy = &nop->phy;\r\nnop->phy.otg->set_host = nop_set_host;\r\nnop->phy.otg->set_peripheral = nop_set_peripheral;\r\nreturn 0;\r\n}\r\nstatic int usb_phy_generic_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct usb_phy_generic *nop;\r\nint err;\r\nnop = devm_kzalloc(dev, sizeof(*nop), GFP_KERNEL);\r\nif (!nop)\r\nreturn -ENOMEM;\r\nerr = usb_phy_gen_create_phy(dev, nop, dev_get_platdata(&pdev->dev));\r\nif (err)\r\nreturn err;\r\nnop->phy.init = usb_gen_phy_init;\r\nnop->phy.shutdown = usb_gen_phy_shutdown;\r\nerr = usb_add_phy_dev(&nop->phy);\r\nif (err) {\r\ndev_err(&pdev->dev, "can't register transceiver, err: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nplatform_set_drvdata(pdev, nop);\r\nreturn 0;\r\n}\r\nstatic int usb_phy_generic_remove(struct platform_device *pdev)\r\n{\r\nstruct usb_phy_generic *nop = platform_get_drvdata(pdev);\r\nusb_remove_phy(&nop->phy);\r\nreturn 0;\r\n}\r\nstatic int __init usb_phy_generic_init(void)\r\n{\r\nreturn platform_driver_register(&usb_phy_generic_driver);\r\n}\r\nstatic void __exit usb_phy_generic_exit(void)\r\n{\r\nplatform_driver_unregister(&usb_phy_generic_driver);\r\n}
