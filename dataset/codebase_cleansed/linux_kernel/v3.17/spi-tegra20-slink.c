static inline u32 tegra_slink_readl(struct tegra_slink_data *tspi,\r\nunsigned long reg)\r\n{\r\nreturn readl(tspi->base + reg);\r\n}\r\nstatic inline void tegra_slink_writel(struct tegra_slink_data *tspi,\r\nu32 val, unsigned long reg)\r\n{\r\nwritel(val, tspi->base + reg);\r\nif (reg != SLINK_TX_FIFO)\r\nreadl(tspi->base + SLINK_MAS_DATA);\r\n}\r\nstatic void tegra_slink_clear_status(struct tegra_slink_data *tspi)\r\n{\r\nu32 val_write;\r\ntegra_slink_readl(tspi, SLINK_STATUS);\r\nval_write = SLINK_RDY | SLINK_FIFO_ERROR;\r\ntegra_slink_writel(tspi, val_write, SLINK_STATUS);\r\n}\r\nstatic u32 tegra_slink_get_packed_size(struct tegra_slink_data *tspi,\r\nstruct spi_transfer *t)\r\n{\r\nswitch (tspi->bytes_per_word) {\r\ncase 0:\r\nreturn SLINK_PACK_SIZE_4;\r\ncase 1:\r\nreturn SLINK_PACK_SIZE_8;\r\ncase 2:\r\nreturn SLINK_PACK_SIZE_16;\r\ncase 4:\r\nreturn SLINK_PACK_SIZE_32;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic unsigned tegra_slink_calculate_curr_xfer_param(\r\nstruct spi_device *spi, struct tegra_slink_data *tspi,\r\nstruct spi_transfer *t)\r\n{\r\nunsigned remain_len = t->len - tspi->cur_pos;\r\nunsigned max_word;\r\nunsigned bits_per_word;\r\nunsigned max_len;\r\nunsigned total_fifo_words;\r\nbits_per_word = t->bits_per_word;\r\ntspi->bytes_per_word = DIV_ROUND_UP(bits_per_word, 8);\r\nif (bits_per_word == 8 || bits_per_word == 16) {\r\ntspi->is_packed = 1;\r\ntspi->words_per_32bit = 32/bits_per_word;\r\n} else {\r\ntspi->is_packed = 0;\r\ntspi->words_per_32bit = 1;\r\n}\r\ntspi->packed_size = tegra_slink_get_packed_size(tspi, t);\r\nif (tspi->is_packed) {\r\nmax_len = min(remain_len, tspi->max_buf_size);\r\ntspi->curr_dma_words = max_len/tspi->bytes_per_word;\r\ntotal_fifo_words = max_len/4;\r\n} else {\r\nmax_word = (remain_len - 1) / tspi->bytes_per_word + 1;\r\nmax_word = min(max_word, tspi->max_buf_size/4);\r\ntspi->curr_dma_words = max_word;\r\ntotal_fifo_words = max_word;\r\n}\r\nreturn total_fifo_words;\r\n}\r\nstatic unsigned tegra_slink_fill_tx_fifo_from_client_txbuf(\r\nstruct tegra_slink_data *tspi, struct spi_transfer *t)\r\n{\r\nunsigned nbytes;\r\nunsigned tx_empty_count;\r\nu32 fifo_status;\r\nunsigned max_n_32bit;\r\nunsigned i, count;\r\nunsigned int written_words;\r\nunsigned fifo_words_left;\r\nu8 *tx_buf = (u8 *)t->tx_buf + tspi->cur_tx_pos;\r\nfifo_status = tegra_slink_readl(tspi, SLINK_STATUS2);\r\ntx_empty_count = SLINK_TX_FIFO_EMPTY_COUNT(fifo_status);\r\nif (tspi->is_packed) {\r\nfifo_words_left = tx_empty_count * tspi->words_per_32bit;\r\nwritten_words = min(fifo_words_left, tspi->curr_dma_words);\r\nnbytes = written_words * tspi->bytes_per_word;\r\nmax_n_32bit = DIV_ROUND_UP(nbytes, 4);\r\nfor (count = 0; count < max_n_32bit; count++) {\r\nu32 x = 0;\r\nfor (i = 0; (i < 4) && nbytes; i++, nbytes--)\r\nx |= (u32)(*tx_buf++) << (i * 8);\r\ntegra_slink_writel(tspi, x, SLINK_TX_FIFO);\r\n}\r\n} else {\r\nmax_n_32bit = min(tspi->curr_dma_words, tx_empty_count);\r\nwritten_words = max_n_32bit;\r\nnbytes = written_words * tspi->bytes_per_word;\r\nfor (count = 0; count < max_n_32bit; count++) {\r\nu32 x = 0;\r\nfor (i = 0; nbytes && (i < tspi->bytes_per_word);\r\ni++, nbytes--)\r\nx |= (u32)(*tx_buf++) << (i * 8);\r\ntegra_slink_writel(tspi, x, SLINK_TX_FIFO);\r\n}\r\n}\r\ntspi->cur_tx_pos += written_words * tspi->bytes_per_word;\r\nreturn written_words;\r\n}\r\nstatic unsigned int tegra_slink_read_rx_fifo_to_client_rxbuf(\r\nstruct tegra_slink_data *tspi, struct spi_transfer *t)\r\n{\r\nunsigned rx_full_count;\r\nu32 fifo_status;\r\nunsigned i, count;\r\nunsigned int read_words = 0;\r\nunsigned len;\r\nu8 *rx_buf = (u8 *)t->rx_buf + tspi->cur_rx_pos;\r\nfifo_status = tegra_slink_readl(tspi, SLINK_STATUS2);\r\nrx_full_count = SLINK_RX_FIFO_FULL_COUNT(fifo_status);\r\nif (tspi->is_packed) {\r\nlen = tspi->curr_dma_words * tspi->bytes_per_word;\r\nfor (count = 0; count < rx_full_count; count++) {\r\nu32 x = tegra_slink_readl(tspi, SLINK_RX_FIFO);\r\nfor (i = 0; len && (i < 4); i++, len--)\r\n*rx_buf++ = (x >> i*8) & 0xFF;\r\n}\r\ntspi->cur_rx_pos += tspi->curr_dma_words * tspi->bytes_per_word;\r\nread_words += tspi->curr_dma_words;\r\n} else {\r\nfor (count = 0; count < rx_full_count; count++) {\r\nu32 x = tegra_slink_readl(tspi, SLINK_RX_FIFO);\r\nfor (i = 0; (i < tspi->bytes_per_word); i++)\r\n*rx_buf++ = (x >> (i*8)) & 0xFF;\r\n}\r\ntspi->cur_rx_pos += rx_full_count * tspi->bytes_per_word;\r\nread_words += rx_full_count;\r\n}\r\nreturn read_words;\r\n}\r\nstatic void tegra_slink_copy_client_txbuf_to_spi_txbuf(\r\nstruct tegra_slink_data *tspi, struct spi_transfer *t)\r\n{\r\ndma_sync_single_for_cpu(tspi->dev, tspi->tx_dma_phys,\r\ntspi->dma_buf_size, DMA_TO_DEVICE);\r\nif (tspi->is_packed) {\r\nunsigned len = tspi->curr_dma_words * tspi->bytes_per_word;\r\nmemcpy(tspi->tx_dma_buf, t->tx_buf + tspi->cur_pos, len);\r\n} else {\r\nunsigned int i;\r\nunsigned int count;\r\nu8 *tx_buf = (u8 *)t->tx_buf + tspi->cur_tx_pos;\r\nunsigned consume = tspi->curr_dma_words * tspi->bytes_per_word;\r\nfor (count = 0; count < tspi->curr_dma_words; count++) {\r\nu32 x = 0;\r\nfor (i = 0; consume && (i < tspi->bytes_per_word);\r\ni++, consume--)\r\nx |= (u32)(*tx_buf++) << (i * 8);\r\ntspi->tx_dma_buf[count] = x;\r\n}\r\n}\r\ntspi->cur_tx_pos += tspi->curr_dma_words * tspi->bytes_per_word;\r\ndma_sync_single_for_device(tspi->dev, tspi->tx_dma_phys,\r\ntspi->dma_buf_size, DMA_TO_DEVICE);\r\n}\r\nstatic void tegra_slink_copy_spi_rxbuf_to_client_rxbuf(\r\nstruct tegra_slink_data *tspi, struct spi_transfer *t)\r\n{\r\nunsigned len;\r\ndma_sync_single_for_cpu(tspi->dev, tspi->rx_dma_phys,\r\ntspi->dma_buf_size, DMA_FROM_DEVICE);\r\nif (tspi->is_packed) {\r\nlen = tspi->curr_dma_words * tspi->bytes_per_word;\r\nmemcpy(t->rx_buf + tspi->cur_rx_pos, tspi->rx_dma_buf, len);\r\n} else {\r\nunsigned int i;\r\nunsigned int count;\r\nunsigned char *rx_buf = t->rx_buf + tspi->cur_rx_pos;\r\nu32 rx_mask = ((u32)1 << t->bits_per_word) - 1;\r\nfor (count = 0; count < tspi->curr_dma_words; count++) {\r\nu32 x = tspi->rx_dma_buf[count] & rx_mask;\r\nfor (i = 0; (i < tspi->bytes_per_word); i++)\r\n*rx_buf++ = (x >> (i*8)) & 0xFF;\r\n}\r\n}\r\ntspi->cur_rx_pos += tspi->curr_dma_words * tspi->bytes_per_word;\r\ndma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,\r\ntspi->dma_buf_size, DMA_FROM_DEVICE);\r\n}\r\nstatic void tegra_slink_dma_complete(void *args)\r\n{\r\nstruct completion *dma_complete = args;\r\ncomplete(dma_complete);\r\n}\r\nstatic int tegra_slink_start_tx_dma(struct tegra_slink_data *tspi, int len)\r\n{\r\nreinit_completion(&tspi->tx_dma_complete);\r\ntspi->tx_dma_desc = dmaengine_prep_slave_single(tspi->tx_dma_chan,\r\ntspi->tx_dma_phys, len, DMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!tspi->tx_dma_desc) {\r\ndev_err(tspi->dev, "Not able to get desc for Tx\n");\r\nreturn -EIO;\r\n}\r\ntspi->tx_dma_desc->callback = tegra_slink_dma_complete;\r\ntspi->tx_dma_desc->callback_param = &tspi->tx_dma_complete;\r\ndmaengine_submit(tspi->tx_dma_desc);\r\ndma_async_issue_pending(tspi->tx_dma_chan);\r\nreturn 0;\r\n}\r\nstatic int tegra_slink_start_rx_dma(struct tegra_slink_data *tspi, int len)\r\n{\r\nreinit_completion(&tspi->rx_dma_complete);\r\ntspi->rx_dma_desc = dmaengine_prep_slave_single(tspi->rx_dma_chan,\r\ntspi->rx_dma_phys, len, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!tspi->rx_dma_desc) {\r\ndev_err(tspi->dev, "Not able to get desc for Rx\n");\r\nreturn -EIO;\r\n}\r\ntspi->rx_dma_desc->callback = tegra_slink_dma_complete;\r\ntspi->rx_dma_desc->callback_param = &tspi->rx_dma_complete;\r\ndmaengine_submit(tspi->rx_dma_desc);\r\ndma_async_issue_pending(tspi->rx_dma_chan);\r\nreturn 0;\r\n}\r\nstatic int tegra_slink_start_dma_based_transfer(\r\nstruct tegra_slink_data *tspi, struct spi_transfer *t)\r\n{\r\nu32 val;\r\nunsigned int len;\r\nint ret = 0;\r\nu32 status;\r\nstatus = tegra_slink_readl(tspi, SLINK_STATUS);\r\nif ((status & SLINK_FIFO_EMPTY) != SLINK_FIFO_EMPTY) {\r\ndev_err(tspi->dev, "Rx/Tx fifo are not empty status 0x%08x\n",\r\n(unsigned)status);\r\nreturn -EIO;\r\n}\r\nval = SLINK_DMA_BLOCK_SIZE(tspi->curr_dma_words - 1);\r\nval |= tspi->packed_size;\r\nif (tspi->is_packed)\r\nlen = DIV_ROUND_UP(tspi->curr_dma_words * tspi->bytes_per_word,\r\n4) * 4;\r\nelse\r\nlen = tspi->curr_dma_words * 4;\r\nif (len & 0xF)\r\nval |= SLINK_TX_TRIG_1 | SLINK_RX_TRIG_1;\r\nelse if (((len) >> 4) & 0x1)\r\nval |= SLINK_TX_TRIG_4 | SLINK_RX_TRIG_4;\r\nelse\r\nval |= SLINK_TX_TRIG_8 | SLINK_RX_TRIG_8;\r\nif (tspi->cur_direction & DATA_DIR_TX)\r\nval |= SLINK_IE_TXC;\r\nif (tspi->cur_direction & DATA_DIR_RX)\r\nval |= SLINK_IE_RXC;\r\ntegra_slink_writel(tspi, val, SLINK_DMA_CTL);\r\ntspi->dma_control_reg = val;\r\nif (tspi->cur_direction & DATA_DIR_TX) {\r\ntegra_slink_copy_client_txbuf_to_spi_txbuf(tspi, t);\r\nwmb();\r\nret = tegra_slink_start_tx_dma(tspi, len);\r\nif (ret < 0) {\r\ndev_err(tspi->dev,\r\n"Starting tx dma failed, err %d\n", ret);\r\nreturn ret;\r\n}\r\nstatus = tegra_slink_readl(tspi, SLINK_STATUS);\r\nwhile (!(status & SLINK_TX_FULL))\r\nstatus = tegra_slink_readl(tspi, SLINK_STATUS);\r\n}\r\nif (tspi->cur_direction & DATA_DIR_RX) {\r\ndma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,\r\ntspi->dma_buf_size, DMA_FROM_DEVICE);\r\nret = tegra_slink_start_rx_dma(tspi, len);\r\nif (ret < 0) {\r\ndev_err(tspi->dev,\r\n"Starting rx dma failed, err %d\n", ret);\r\nif (tspi->cur_direction & DATA_DIR_TX)\r\ndmaengine_terminate_all(tspi->tx_dma_chan);\r\nreturn ret;\r\n}\r\n}\r\ntspi->is_curr_dma_xfer = true;\r\nif (tspi->is_packed) {\r\nval |= SLINK_PACKED;\r\ntegra_slink_writel(tspi, val, SLINK_DMA_CTL);\r\nudelay(1);\r\n}\r\ntspi->dma_control_reg = val;\r\nval |= SLINK_DMA_EN;\r\ntegra_slink_writel(tspi, val, SLINK_DMA_CTL);\r\nreturn ret;\r\n}\r\nstatic int tegra_slink_start_cpu_based_transfer(\r\nstruct tegra_slink_data *tspi, struct spi_transfer *t)\r\n{\r\nu32 val;\r\nunsigned cur_words;\r\nval = tspi->packed_size;\r\nif (tspi->cur_direction & DATA_DIR_TX)\r\nval |= SLINK_IE_TXC;\r\nif (tspi->cur_direction & DATA_DIR_RX)\r\nval |= SLINK_IE_RXC;\r\ntegra_slink_writel(tspi, val, SLINK_DMA_CTL);\r\ntspi->dma_control_reg = val;\r\nif (tspi->cur_direction & DATA_DIR_TX)\r\ncur_words = tegra_slink_fill_tx_fifo_from_client_txbuf(tspi, t);\r\nelse\r\ncur_words = tspi->curr_dma_words;\r\nval |= SLINK_DMA_BLOCK_SIZE(cur_words - 1);\r\ntegra_slink_writel(tspi, val, SLINK_DMA_CTL);\r\ntspi->dma_control_reg = val;\r\ntspi->is_curr_dma_xfer = false;\r\nif (tspi->is_packed) {\r\nval |= SLINK_PACKED;\r\ntegra_slink_writel(tspi, val, SLINK_DMA_CTL);\r\nudelay(1);\r\nwmb();\r\n}\r\ntspi->dma_control_reg = val;\r\nval |= SLINK_DMA_EN;\r\ntegra_slink_writel(tspi, val, SLINK_DMA_CTL);\r\nreturn 0;\r\n}\r\nstatic int tegra_slink_init_dma_param(struct tegra_slink_data *tspi,\r\nbool dma_to_memory)\r\n{\r\nstruct dma_chan *dma_chan;\r\nu32 *dma_buf;\r\ndma_addr_t dma_phys;\r\nint ret;\r\nstruct dma_slave_config dma_sconfig;\r\ndma_chan = dma_request_slave_channel_reason(tspi->dev,\r\ndma_to_memory ? "rx" : "tx");\r\nif (IS_ERR(dma_chan)) {\r\nret = PTR_ERR(dma_chan);\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(tspi->dev,\r\n"Dma channel is not available: %d\n", ret);\r\nreturn ret;\r\n}\r\ndma_buf = dma_alloc_coherent(tspi->dev, tspi->dma_buf_size,\r\n&dma_phys, GFP_KERNEL);\r\nif (!dma_buf) {\r\ndev_err(tspi->dev, " Not able to allocate the dma buffer\n");\r\ndma_release_channel(dma_chan);\r\nreturn -ENOMEM;\r\n}\r\nif (dma_to_memory) {\r\ndma_sconfig.src_addr = tspi->phys + SLINK_RX_FIFO;\r\ndma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ndma_sconfig.src_maxburst = 0;\r\n} else {\r\ndma_sconfig.dst_addr = tspi->phys + SLINK_TX_FIFO;\r\ndma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ndma_sconfig.dst_maxburst = 0;\r\n}\r\nret = dmaengine_slave_config(dma_chan, &dma_sconfig);\r\nif (ret)\r\ngoto scrub;\r\nif (dma_to_memory) {\r\ntspi->rx_dma_chan = dma_chan;\r\ntspi->rx_dma_buf = dma_buf;\r\ntspi->rx_dma_phys = dma_phys;\r\n} else {\r\ntspi->tx_dma_chan = dma_chan;\r\ntspi->tx_dma_buf = dma_buf;\r\ntspi->tx_dma_phys = dma_phys;\r\n}\r\nreturn 0;\r\nscrub:\r\ndma_free_coherent(tspi->dev, tspi->dma_buf_size, dma_buf, dma_phys);\r\ndma_release_channel(dma_chan);\r\nreturn ret;\r\n}\r\nstatic void tegra_slink_deinit_dma_param(struct tegra_slink_data *tspi,\r\nbool dma_to_memory)\r\n{\r\nu32 *dma_buf;\r\ndma_addr_t dma_phys;\r\nstruct dma_chan *dma_chan;\r\nif (dma_to_memory) {\r\ndma_buf = tspi->rx_dma_buf;\r\ndma_chan = tspi->rx_dma_chan;\r\ndma_phys = tspi->rx_dma_phys;\r\ntspi->rx_dma_chan = NULL;\r\ntspi->rx_dma_buf = NULL;\r\n} else {\r\ndma_buf = tspi->tx_dma_buf;\r\ndma_chan = tspi->tx_dma_chan;\r\ndma_phys = tspi->tx_dma_phys;\r\ntspi->tx_dma_buf = NULL;\r\ntspi->tx_dma_chan = NULL;\r\n}\r\nif (!dma_chan)\r\nreturn;\r\ndma_free_coherent(tspi->dev, tspi->dma_buf_size, dma_buf, dma_phys);\r\ndma_release_channel(dma_chan);\r\n}\r\nstatic int tegra_slink_start_transfer_one(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct tegra_slink_data *tspi = spi_master_get_devdata(spi->master);\r\nu32 speed;\r\nu8 bits_per_word;\r\nunsigned total_fifo_words;\r\nint ret;\r\nu32 command;\r\nu32 command2;\r\nbits_per_word = t->bits_per_word;\r\nspeed = t->speed_hz;\r\nif (speed != tspi->cur_speed) {\r\nclk_set_rate(tspi->clk, speed * 4);\r\ntspi->cur_speed = speed;\r\n}\r\ntspi->cur_spi = spi;\r\ntspi->cur_pos = 0;\r\ntspi->cur_rx_pos = 0;\r\ntspi->cur_tx_pos = 0;\r\ntspi->curr_xfer = t;\r\ntotal_fifo_words = tegra_slink_calculate_curr_xfer_param(spi, tspi, t);\r\ncommand = tspi->command_reg;\r\ncommand &= ~SLINK_BIT_LENGTH(~0);\r\ncommand |= SLINK_BIT_LENGTH(bits_per_word - 1);\r\ncommand2 = tspi->command2_reg;\r\ncommand2 &= ~(SLINK_RXEN | SLINK_TXEN);\r\ntegra_slink_writel(tspi, command, SLINK_COMMAND);\r\ntspi->command_reg = command;\r\ntspi->cur_direction = 0;\r\nif (t->rx_buf) {\r\ncommand2 |= SLINK_RXEN;\r\ntspi->cur_direction |= DATA_DIR_RX;\r\n}\r\nif (t->tx_buf) {\r\ncommand2 |= SLINK_TXEN;\r\ntspi->cur_direction |= DATA_DIR_TX;\r\n}\r\ntegra_slink_writel(tspi, command2, SLINK_COMMAND2);\r\ntspi->command2_reg = command2;\r\nif (total_fifo_words > SLINK_FIFO_DEPTH)\r\nret = tegra_slink_start_dma_based_transfer(tspi, t);\r\nelse\r\nret = tegra_slink_start_cpu_based_transfer(tspi, t);\r\nreturn ret;\r\n}\r\nstatic int tegra_slink_setup(struct spi_device *spi)\r\n{\r\nstatic const u32 cs_pol_bit[MAX_CHIP_SELECT] = {\r\nSLINK_CS_POLARITY,\r\nSLINK_CS_POLARITY1,\r\nSLINK_CS_POLARITY2,\r\nSLINK_CS_POLARITY3,\r\n};\r\nstruct tegra_slink_data *tspi = spi_master_get_devdata(spi->master);\r\nu32 val;\r\nunsigned long flags;\r\nint ret;\r\ndev_dbg(&spi->dev, "setup %d bpw, %scpol, %scpha, %dHz\n",\r\nspi->bits_per_word,\r\nspi->mode & SPI_CPOL ? "" : "~",\r\nspi->mode & SPI_CPHA ? "" : "~",\r\nspi->max_speed_hz);\r\nret = pm_runtime_get_sync(tspi->dev);\r\nif (ret < 0) {\r\ndev_err(tspi->dev, "pm runtime failed, e = %d\n", ret);\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&tspi->lock, flags);\r\nval = tspi->def_command_reg;\r\nif (spi->mode & SPI_CS_HIGH)\r\nval |= cs_pol_bit[spi->chip_select];\r\nelse\r\nval &= ~cs_pol_bit[spi->chip_select];\r\ntspi->def_command_reg = val;\r\ntegra_slink_writel(tspi, tspi->def_command_reg, SLINK_COMMAND);\r\nspin_unlock_irqrestore(&tspi->lock, flags);\r\npm_runtime_put(tspi->dev);\r\nreturn 0;\r\n}\r\nstatic int tegra_slink_prepare_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct tegra_slink_data *tspi = spi_master_get_devdata(master);\r\nstruct spi_device *spi = msg->spi;\r\ntegra_slink_clear_status(tspi);\r\ntspi->command_reg = tspi->def_command_reg;\r\ntspi->command_reg |= SLINK_CS_SW | SLINK_CS_VALUE;\r\ntspi->command2_reg = tspi->def_command2_reg;\r\ntspi->command2_reg |= SLINK_SS_EN_CS(spi->chip_select);\r\ntspi->command_reg &= ~SLINK_MODES;\r\nif (spi->mode & SPI_CPHA)\r\ntspi->command_reg |= SLINK_CK_SDA;\r\nif (spi->mode & SPI_CPOL)\r\ntspi->command_reg |= SLINK_IDLE_SCLK_DRIVE_HIGH;\r\nelse\r\ntspi->command_reg |= SLINK_IDLE_SCLK_DRIVE_LOW;\r\nreturn 0;\r\n}\r\nstatic int tegra_slink_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct tegra_slink_data *tspi = spi_master_get_devdata(master);\r\nint ret;\r\nreinit_completion(&tspi->xfer_completion);\r\nret = tegra_slink_start_transfer_one(spi, xfer);\r\nif (ret < 0) {\r\ndev_err(tspi->dev,\r\n"spi can not start transfer, err %d\n", ret);\r\nreturn ret;\r\n}\r\nret = wait_for_completion_timeout(&tspi->xfer_completion,\r\nSLINK_DMA_TIMEOUT);\r\nif (WARN_ON(ret == 0)) {\r\ndev_err(tspi->dev,\r\n"spi trasfer timeout, err %d\n", ret);\r\nreturn -EIO;\r\n}\r\nif (tspi->tx_status)\r\nreturn tspi->tx_status;\r\nif (tspi->rx_status)\r\nreturn tspi->rx_status;\r\nreturn 0;\r\n}\r\nstatic int tegra_slink_unprepare_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct tegra_slink_data *tspi = spi_master_get_devdata(master);\r\ntegra_slink_writel(tspi, tspi->def_command_reg, SLINK_COMMAND);\r\ntegra_slink_writel(tspi, tspi->def_command2_reg, SLINK_COMMAND2);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t handle_cpu_based_xfer(struct tegra_slink_data *tspi)\r\n{\r\nstruct spi_transfer *t = tspi->curr_xfer;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tspi->lock, flags);\r\nif (tspi->tx_status || tspi->rx_status ||\r\n(tspi->status_reg & SLINK_BSY)) {\r\ndev_err(tspi->dev,\r\n"CpuXfer ERROR bit set 0x%x\n", tspi->status_reg);\r\ndev_err(tspi->dev,\r\n"CpuXfer 0x%08x:0x%08x:0x%08x\n", tspi->command_reg,\r\ntspi->command2_reg, tspi->dma_control_reg);\r\nreset_control_assert(tspi->rst);\r\nudelay(2);\r\nreset_control_deassert(tspi->rst);\r\ncomplete(&tspi->xfer_completion);\r\ngoto exit;\r\n}\r\nif (tspi->cur_direction & DATA_DIR_RX)\r\ntegra_slink_read_rx_fifo_to_client_rxbuf(tspi, t);\r\nif (tspi->cur_direction & DATA_DIR_TX)\r\ntspi->cur_pos = tspi->cur_tx_pos;\r\nelse\r\ntspi->cur_pos = tspi->cur_rx_pos;\r\nif (tspi->cur_pos == t->len) {\r\ncomplete(&tspi->xfer_completion);\r\ngoto exit;\r\n}\r\ntegra_slink_calculate_curr_xfer_param(tspi->cur_spi, tspi, t);\r\ntegra_slink_start_cpu_based_transfer(tspi, t);\r\nexit:\r\nspin_unlock_irqrestore(&tspi->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t handle_dma_based_xfer(struct tegra_slink_data *tspi)\r\n{\r\nstruct spi_transfer *t = tspi->curr_xfer;\r\nlong wait_status;\r\nint err = 0;\r\nunsigned total_fifo_words;\r\nunsigned long flags;\r\nif (tspi->cur_direction & DATA_DIR_TX) {\r\nif (tspi->tx_status) {\r\ndmaengine_terminate_all(tspi->tx_dma_chan);\r\nerr += 1;\r\n} else {\r\nwait_status = wait_for_completion_interruptible_timeout(\r\n&tspi->tx_dma_complete, SLINK_DMA_TIMEOUT);\r\nif (wait_status <= 0) {\r\ndmaengine_terminate_all(tspi->tx_dma_chan);\r\ndev_err(tspi->dev, "TxDma Xfer failed\n");\r\nerr += 1;\r\n}\r\n}\r\n}\r\nif (tspi->cur_direction & DATA_DIR_RX) {\r\nif (tspi->rx_status) {\r\ndmaengine_terminate_all(tspi->rx_dma_chan);\r\nerr += 2;\r\n} else {\r\nwait_status = wait_for_completion_interruptible_timeout(\r\n&tspi->rx_dma_complete, SLINK_DMA_TIMEOUT);\r\nif (wait_status <= 0) {\r\ndmaengine_terminate_all(tspi->rx_dma_chan);\r\ndev_err(tspi->dev, "RxDma Xfer failed\n");\r\nerr += 2;\r\n}\r\n}\r\n}\r\nspin_lock_irqsave(&tspi->lock, flags);\r\nif (err) {\r\ndev_err(tspi->dev,\r\n"DmaXfer: ERROR bit set 0x%x\n", tspi->status_reg);\r\ndev_err(tspi->dev,\r\n"DmaXfer 0x%08x:0x%08x:0x%08x\n", tspi->command_reg,\r\ntspi->command2_reg, tspi->dma_control_reg);\r\nreset_control_assert(tspi->rst);\r\nudelay(2);\r\nreset_control_assert(tspi->rst);\r\ncomplete(&tspi->xfer_completion);\r\nspin_unlock_irqrestore(&tspi->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (tspi->cur_direction & DATA_DIR_RX)\r\ntegra_slink_copy_spi_rxbuf_to_client_rxbuf(tspi, t);\r\nif (tspi->cur_direction & DATA_DIR_TX)\r\ntspi->cur_pos = tspi->cur_tx_pos;\r\nelse\r\ntspi->cur_pos = tspi->cur_rx_pos;\r\nif (tspi->cur_pos == t->len) {\r\ncomplete(&tspi->xfer_completion);\r\ngoto exit;\r\n}\r\ntotal_fifo_words = tegra_slink_calculate_curr_xfer_param(tspi->cur_spi,\r\ntspi, t);\r\nif (total_fifo_words > SLINK_FIFO_DEPTH)\r\nerr = tegra_slink_start_dma_based_transfer(tspi, t);\r\nelse\r\nerr = tegra_slink_start_cpu_based_transfer(tspi, t);\r\nexit:\r\nspin_unlock_irqrestore(&tspi->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t tegra_slink_isr_thread(int irq, void *context_data)\r\n{\r\nstruct tegra_slink_data *tspi = context_data;\r\nif (!tspi->is_curr_dma_xfer)\r\nreturn handle_cpu_based_xfer(tspi);\r\nreturn handle_dma_based_xfer(tspi);\r\n}\r\nstatic irqreturn_t tegra_slink_isr(int irq, void *context_data)\r\n{\r\nstruct tegra_slink_data *tspi = context_data;\r\ntspi->status_reg = tegra_slink_readl(tspi, SLINK_STATUS);\r\nif (tspi->cur_direction & DATA_DIR_TX)\r\ntspi->tx_status = tspi->status_reg &\r\n(SLINK_TX_OVF | SLINK_TX_UNF);\r\nif (tspi->cur_direction & DATA_DIR_RX)\r\ntspi->rx_status = tspi->status_reg &\r\n(SLINK_RX_OVF | SLINK_RX_UNF);\r\ntegra_slink_clear_status(tspi);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic int tegra_slink_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct tegra_slink_data *tspi;\r\nstruct resource *r;\r\nint ret, spi_irq;\r\nconst struct tegra_slink_chip_data *cdata = NULL;\r\nconst struct of_device_id *match;\r\nmatch = of_match_device(tegra_slink_of_match, &pdev->dev);\r\nif (!match) {\r\ndev_err(&pdev->dev, "Error: No device match found\n");\r\nreturn -ENODEV;\r\n}\r\ncdata = match->data;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*tspi));\r\nif (!master) {\r\ndev_err(&pdev->dev, "master allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\r\nmaster->setup = tegra_slink_setup;\r\nmaster->prepare_message = tegra_slink_prepare_message;\r\nmaster->transfer_one = tegra_slink_transfer_one;\r\nmaster->unprepare_message = tegra_slink_unprepare_message;\r\nmaster->auto_runtime_pm = true;\r\nmaster->num_chipselect = MAX_CHIP_SELECT;\r\nplatform_set_drvdata(pdev, master);\r\ntspi = spi_master_get_devdata(master);\r\ntspi->master = master;\r\ntspi->dev = &pdev->dev;\r\ntspi->chip_data = cdata;\r\nspin_lock_init(&tspi->lock);\r\nif (of_property_read_u32(tspi->dev->of_node, "spi-max-frequency",\r\n&master->max_speed_hz))\r\nmaster->max_speed_hz = 25000000;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\ndev_err(&pdev->dev, "No IO memory resource\n");\r\nret = -ENODEV;\r\ngoto exit_free_master;\r\n}\r\ntspi->phys = r->start;\r\ntspi->base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(tspi->base)) {\r\nret = PTR_ERR(tspi->base);\r\ngoto exit_free_master;\r\n}\r\nspi_irq = platform_get_irq(pdev, 0);\r\ntspi->irq = spi_irq;\r\nret = request_threaded_irq(tspi->irq, tegra_slink_isr,\r\ntegra_slink_isr_thread, IRQF_ONESHOT,\r\ndev_name(&pdev->dev), tspi);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to register ISR for IRQ %d\n",\r\ntspi->irq);\r\ngoto exit_free_master;\r\n}\r\ntspi->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(tspi->clk)) {\r\ndev_err(&pdev->dev, "can not get clock\n");\r\nret = PTR_ERR(tspi->clk);\r\ngoto exit_free_irq;\r\n}\r\ntspi->rst = devm_reset_control_get(&pdev->dev, "spi");\r\nif (IS_ERR(tspi->rst)) {\r\ndev_err(&pdev->dev, "can not get reset\n");\r\nret = PTR_ERR(tspi->rst);\r\ngoto exit_free_irq;\r\n}\r\ntspi->max_buf_size = SLINK_FIFO_DEPTH << 2;\r\ntspi->dma_buf_size = DEFAULT_SPI_DMA_BUF_LEN;\r\nret = tegra_slink_init_dma_param(tspi, true);\r\nif (ret < 0)\r\ngoto exit_free_irq;\r\nret = tegra_slink_init_dma_param(tspi, false);\r\nif (ret < 0)\r\ngoto exit_rx_dma_free;\r\ntspi->max_buf_size = tspi->dma_buf_size;\r\ninit_completion(&tspi->tx_dma_complete);\r\ninit_completion(&tspi->rx_dma_complete);\r\ninit_completion(&tspi->xfer_completion);\r\npm_runtime_enable(&pdev->dev);\r\nif (!pm_runtime_enabled(&pdev->dev)) {\r\nret = tegra_slink_runtime_resume(&pdev->dev);\r\nif (ret)\r\ngoto exit_pm_disable;\r\n}\r\nret = pm_runtime_get_sync(&pdev->dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "pm runtime get failed, e = %d\n", ret);\r\ngoto exit_pm_disable;\r\n}\r\ntspi->def_command_reg = SLINK_M_S;\r\ntspi->def_command2_reg = SLINK_CS_ACTIVE_BETWEEN;\r\ntegra_slink_writel(tspi, tspi->def_command_reg, SLINK_COMMAND);\r\ntegra_slink_writel(tspi, tspi->def_command2_reg, SLINK_COMMAND2);\r\npm_runtime_put(&pdev->dev);\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nret = devm_spi_register_master(&pdev->dev, master);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "can not register to master err %d\n", ret);\r\ngoto exit_pm_disable;\r\n}\r\nreturn ret;\r\nexit_pm_disable:\r\npm_runtime_disable(&pdev->dev);\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\ntegra_slink_runtime_suspend(&pdev->dev);\r\ntegra_slink_deinit_dma_param(tspi, false);\r\nexit_rx_dma_free:\r\ntegra_slink_deinit_dma_param(tspi, true);\r\nexit_free_irq:\r\nfree_irq(spi_irq, tspi);\r\nexit_free_master:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int tegra_slink_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct tegra_slink_data *tspi = spi_master_get_devdata(master);\r\nfree_irq(tspi->irq, tspi);\r\nif (tspi->tx_dma_chan)\r\ntegra_slink_deinit_dma_param(tspi, false);\r\nif (tspi->rx_dma_chan)\r\ntegra_slink_deinit_dma_param(tspi, true);\r\npm_runtime_disable(&pdev->dev);\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\ntegra_slink_runtime_suspend(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int tegra_slink_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nreturn spi_master_suspend(master);\r\n}\r\nstatic int tegra_slink_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct tegra_slink_data *tspi = spi_master_get_devdata(master);\r\nint ret;\r\nret = pm_runtime_get_sync(dev);\r\nif (ret < 0) {\r\ndev_err(dev, "pm runtime failed, e = %d\n", ret);\r\nreturn ret;\r\n}\r\ntegra_slink_writel(tspi, tspi->command_reg, SLINK_COMMAND);\r\ntegra_slink_writel(tspi, tspi->command2_reg, SLINK_COMMAND2);\r\npm_runtime_put(dev);\r\nreturn spi_master_resume(master);\r\n}\r\nstatic int tegra_slink_runtime_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct tegra_slink_data *tspi = spi_master_get_devdata(master);\r\ntegra_slink_readl(tspi, SLINK_MAS_DATA);\r\nclk_disable_unprepare(tspi->clk);\r\nreturn 0;\r\n}\r\nstatic int tegra_slink_runtime_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct tegra_slink_data *tspi = spi_master_get_devdata(master);\r\nint ret;\r\nret = clk_prepare_enable(tspi->clk);\r\nif (ret < 0) {\r\ndev_err(tspi->dev, "clk_prepare failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
