static int compat_agpioc_info_wrap(struct agp_file_private *priv, void __user *arg)\r\n{\r\nstruct agp_info32 userinfo;\r\nstruct agp_kern_info kerninfo;\r\nagp_copy_info(agp_bridge, &kerninfo);\r\nuserinfo.version.major = kerninfo.version.major;\r\nuserinfo.version.minor = kerninfo.version.minor;\r\nuserinfo.bridge_id = kerninfo.device->vendor |\r\n(kerninfo.device->device << 16);\r\nuserinfo.agp_mode = kerninfo.mode;\r\nuserinfo.aper_base = (compat_long_t)kerninfo.aper_base;\r\nuserinfo.aper_size = kerninfo.aper_size;\r\nuserinfo.pg_total = userinfo.pg_system = kerninfo.max_memory;\r\nuserinfo.pg_used = kerninfo.current_memory;\r\nif (copy_to_user(arg, &userinfo, sizeof(userinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int compat_agpioc_reserve_wrap(struct agp_file_private *priv, void __user *arg)\r\n{\r\nstruct agp_region32 ureserve;\r\nstruct agp_region kreserve;\r\nstruct agp_client *client;\r\nstruct agp_file_private *client_priv;\r\nDBG("");\r\nif (copy_from_user(&ureserve, arg, sizeof(ureserve)))\r\nreturn -EFAULT;\r\nif ((unsigned) ureserve.seg_count >= ~0U/sizeof(struct agp_segment32))\r\nreturn -EFAULT;\r\nkreserve.pid = ureserve.pid;\r\nkreserve.seg_count = ureserve.seg_count;\r\nclient = agp_find_client_by_pid(kreserve.pid);\r\nif (kreserve.seg_count == 0) {\r\nclient_priv = agp_find_private(kreserve.pid);\r\nif (client_priv != NULL) {\r\nset_bit(AGP_FF_IS_CLIENT, &client_priv->access_flags);\r\nset_bit(AGP_FF_IS_VALID, &client_priv->access_flags);\r\n}\r\nif (client == NULL) {\r\nreturn 0;\r\n}\r\nreturn agp_remove_client(kreserve.pid);\r\n} else {\r\nstruct agp_segment32 *usegment;\r\nstruct agp_segment *ksegment;\r\nint seg;\r\nif (ureserve.seg_count >= 16384)\r\nreturn -EINVAL;\r\nusegment = kmalloc(sizeof(*usegment) * ureserve.seg_count, GFP_KERNEL);\r\nif (!usegment)\r\nreturn -ENOMEM;\r\nksegment = kmalloc(sizeof(*ksegment) * kreserve.seg_count, GFP_KERNEL);\r\nif (!ksegment) {\r\nkfree(usegment);\r\nreturn -ENOMEM;\r\n}\r\nif (copy_from_user(usegment, (void __user *) ureserve.seg_list,\r\nsizeof(*usegment) * ureserve.seg_count)) {\r\nkfree(usegment);\r\nkfree(ksegment);\r\nreturn -EFAULT;\r\n}\r\nfor (seg = 0; seg < ureserve.seg_count; seg++) {\r\nksegment[seg].pg_start = usegment[seg].pg_start;\r\nksegment[seg].pg_count = usegment[seg].pg_count;\r\nksegment[seg].prot = usegment[seg].prot;\r\n}\r\nkfree(usegment);\r\nkreserve.seg_list = ksegment;\r\nif (client == NULL) {\r\nclient = agp_create_client(kreserve.pid);\r\nif (client == NULL) {\r\nkfree(ksegment);\r\nreturn -ENOMEM;\r\n}\r\nclient_priv = agp_find_private(kreserve.pid);\r\nif (client_priv != NULL) {\r\nset_bit(AGP_FF_IS_CLIENT, &client_priv->access_flags);\r\nset_bit(AGP_FF_IS_VALID, &client_priv->access_flags);\r\n}\r\n}\r\nreturn agp_create_segment(client, &kreserve);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int compat_agpioc_allocate_wrap(struct agp_file_private *priv, void __user *arg)\r\n{\r\nstruct agp_memory *memory;\r\nstruct agp_allocate32 alloc;\r\nDBG("");\r\nif (copy_from_user(&alloc, arg, sizeof(alloc)))\r\nreturn -EFAULT;\r\nmemory = agp_allocate_memory_wrap(alloc.pg_count, alloc.type);\r\nif (memory == NULL)\r\nreturn -ENOMEM;\r\nalloc.key = memory->key;\r\nalloc.physical = memory->physical;\r\nif (copy_to_user(arg, &alloc, sizeof(alloc))) {\r\nagp_free_memory_wrap(memory);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int compat_agpioc_bind_wrap(struct agp_file_private *priv, void __user *arg)\r\n{\r\nstruct agp_bind32 bind_info;\r\nstruct agp_memory *memory;\r\nDBG("");\r\nif (copy_from_user(&bind_info, arg, sizeof(bind_info)))\r\nreturn -EFAULT;\r\nmemory = agp_find_mem_by_key(bind_info.key);\r\nif (memory == NULL)\r\nreturn -EINVAL;\r\nreturn agp_bind_memory(memory, bind_info.pg_start);\r\n}\r\nstatic int compat_agpioc_unbind_wrap(struct agp_file_private *priv, void __user *arg)\r\n{\r\nstruct agp_memory *memory;\r\nstruct agp_unbind32 unbind;\r\nDBG("");\r\nif (copy_from_user(&unbind, arg, sizeof(unbind)))\r\nreturn -EFAULT;\r\nmemory = agp_find_mem_by_key(unbind.key);\r\nif (memory == NULL)\r\nreturn -EINVAL;\r\nreturn agp_unbind_memory(memory);\r\n}\r\nlong compat_agp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct agp_file_private *curr_priv = file->private_data;\r\nint ret_val = -ENOTTY;\r\nmutex_lock(&(agp_fe.agp_mutex));\r\nif ((agp_fe.current_controller == NULL) &&\r\n(cmd != AGPIOC_ACQUIRE32)) {\r\nret_val = -EINVAL;\r\ngoto ioctl_out;\r\n}\r\nif ((agp_fe.backend_acquired != true) &&\r\n(cmd != AGPIOC_ACQUIRE32)) {\r\nret_val = -EBUSY;\r\ngoto ioctl_out;\r\n}\r\nif (cmd != AGPIOC_ACQUIRE32) {\r\nif (!(test_bit(AGP_FF_IS_CONTROLLER, &curr_priv->access_flags))) {\r\nret_val = -EPERM;\r\ngoto ioctl_out;\r\n}\r\nif (agp_fe.current_controller->pid != curr_priv->my_pid) {\r\nret_val = -EBUSY;\r\ngoto ioctl_out;\r\n}\r\n}\r\nswitch (cmd) {\r\ncase AGPIOC_INFO32:\r\nret_val = compat_agpioc_info_wrap(curr_priv, (void __user *) arg);\r\nbreak;\r\ncase AGPIOC_ACQUIRE32:\r\nret_val = agpioc_acquire_wrap(curr_priv);\r\nbreak;\r\ncase AGPIOC_RELEASE32:\r\nret_val = agpioc_release_wrap(curr_priv);\r\nbreak;\r\ncase AGPIOC_SETUP32:\r\nret_val = agpioc_setup_wrap(curr_priv, (void __user *) arg);\r\nbreak;\r\ncase AGPIOC_RESERVE32:\r\nret_val = compat_agpioc_reserve_wrap(curr_priv, (void __user *) arg);\r\nbreak;\r\ncase AGPIOC_PROTECT32:\r\nret_val = agpioc_protect_wrap(curr_priv);\r\nbreak;\r\ncase AGPIOC_ALLOCATE32:\r\nret_val = compat_agpioc_allocate_wrap(curr_priv, (void __user *) arg);\r\nbreak;\r\ncase AGPIOC_DEALLOCATE32:\r\nret_val = agpioc_deallocate_wrap(curr_priv, (int) arg);\r\nbreak;\r\ncase AGPIOC_BIND32:\r\nret_val = compat_agpioc_bind_wrap(curr_priv, (void __user *) arg);\r\nbreak;\r\ncase AGPIOC_UNBIND32:\r\nret_val = compat_agpioc_unbind_wrap(curr_priv, (void __user *) arg);\r\nbreak;\r\ncase AGPIOC_CHIPSET_FLUSH32:\r\nbreak;\r\n}\r\nioctl_out:\r\nDBG("ioctl returns %d\n", ret_val);\r\nmutex_unlock(&(agp_fe.agp_mutex));\r\nreturn ret_val;\r\n}
