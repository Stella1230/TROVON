int cvmx_l2c_get_core_way_partition(uint32_t core)\r\n{\r\nuint32_t field;\r\nif (core >= cvmx_octeon_num_cores())\r\nreturn -1;\r\nif (OCTEON_IS_MODEL(OCTEON_CN63XX))\r\nreturn cvmx_read_csr(CVMX_L2C_WPAR_PPX(core)) & 0xffff;\r\nfield = (core & 0x3) * 8;\r\nswitch (core & 0xC) {\r\ncase 0x0:\r\nreturn (cvmx_read_csr(CVMX_L2C_SPAR0) & (0xFF << field)) >> field;\r\ncase 0x4:\r\nreturn (cvmx_read_csr(CVMX_L2C_SPAR1) & (0xFF << field)) >> field;\r\ncase 0x8:\r\nreturn (cvmx_read_csr(CVMX_L2C_SPAR2) & (0xFF << field)) >> field;\r\ncase 0xC:\r\nreturn (cvmx_read_csr(CVMX_L2C_SPAR3) & (0xFF << field)) >> field;\r\n}\r\nreturn 0;\r\n}\r\nint cvmx_l2c_set_core_way_partition(uint32_t core, uint32_t mask)\r\n{\r\nuint32_t field;\r\nuint32_t valid_mask;\r\nvalid_mask = (0x1 << cvmx_l2c_get_num_assoc()) - 1;\r\nmask &= valid_mask;\r\nif (mask == valid_mask && !OCTEON_IS_MODEL(OCTEON_CN63XX))\r\nreturn -1;\r\nif (core >= cvmx_octeon_num_cores())\r\nreturn -1;\r\nif (OCTEON_IS_MODEL(OCTEON_CN63XX)) {\r\ncvmx_write_csr(CVMX_L2C_WPAR_PPX(core), mask);\r\nreturn 0;\r\n}\r\nfield = (core & 0x3) * 8;\r\nswitch (core & 0xC) {\r\ncase 0x0:\r\ncvmx_write_csr(CVMX_L2C_SPAR0,\r\n(cvmx_read_csr(CVMX_L2C_SPAR0) & ~(0xFF << field)) |\r\nmask << field);\r\nbreak;\r\ncase 0x4:\r\ncvmx_write_csr(CVMX_L2C_SPAR1,\r\n(cvmx_read_csr(CVMX_L2C_SPAR1) & ~(0xFF << field)) |\r\nmask << field);\r\nbreak;\r\ncase 0x8:\r\ncvmx_write_csr(CVMX_L2C_SPAR2,\r\n(cvmx_read_csr(CVMX_L2C_SPAR2) & ~(0xFF << field)) |\r\nmask << field);\r\nbreak;\r\ncase 0xC:\r\ncvmx_write_csr(CVMX_L2C_SPAR3,\r\n(cvmx_read_csr(CVMX_L2C_SPAR3) & ~(0xFF << field)) |\r\nmask << field);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint cvmx_l2c_set_hw_way_partition(uint32_t mask)\r\n{\r\nuint32_t valid_mask;\r\nvalid_mask = (0x1 << cvmx_l2c_get_num_assoc()) - 1;\r\nmask &= valid_mask;\r\nif (mask == valid_mask && !OCTEON_IS_MODEL(OCTEON_CN63XX))\r\nreturn -1;\r\nif (OCTEON_IS_MODEL(OCTEON_CN63XX))\r\ncvmx_write_csr(CVMX_L2C_WPAR_IOBX(0), mask);\r\nelse\r\ncvmx_write_csr(CVMX_L2C_SPAR4,\r\n(cvmx_read_csr(CVMX_L2C_SPAR4) & ~0xFF) | mask);\r\nreturn 0;\r\n}\r\nint cvmx_l2c_get_hw_way_partition(void)\r\n{\r\nif (OCTEON_IS_MODEL(OCTEON_CN63XX))\r\nreturn cvmx_read_csr(CVMX_L2C_WPAR_IOBX(0)) & 0xffff;\r\nelse\r\nreturn cvmx_read_csr(CVMX_L2C_SPAR4) & (0xFF);\r\n}\r\nvoid cvmx_l2c_config_perf(uint32_t counter, enum cvmx_l2c_event event,\r\nuint32_t clear_on_read)\r\n{\r\nif (OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN3XXX)) {\r\nunion cvmx_l2c_pfctl pfctl;\r\npfctl.u64 = cvmx_read_csr(CVMX_L2C_PFCTL);\r\nswitch (counter) {\r\ncase 0:\r\npfctl.s.cnt0sel = event;\r\npfctl.s.cnt0ena = 1;\r\npfctl.s.cnt0rdclr = clear_on_read;\r\nbreak;\r\ncase 1:\r\npfctl.s.cnt1sel = event;\r\npfctl.s.cnt1ena = 1;\r\npfctl.s.cnt1rdclr = clear_on_read;\r\nbreak;\r\ncase 2:\r\npfctl.s.cnt2sel = event;\r\npfctl.s.cnt2ena = 1;\r\npfctl.s.cnt2rdclr = clear_on_read;\r\nbreak;\r\ncase 3:\r\ndefault:\r\npfctl.s.cnt3sel = event;\r\npfctl.s.cnt3ena = 1;\r\npfctl.s.cnt3rdclr = clear_on_read;\r\nbreak;\r\n}\r\ncvmx_write_csr(CVMX_L2C_PFCTL, pfctl.u64);\r\n} else {\r\nunion cvmx_l2c_tadx_prf l2c_tadx_prf;\r\nint tad;\r\ncvmx_dprintf("L2C performance counter events are different for this chip, mapping 'event' to cvmx_l2c_tad_event_t\n");\r\nif (clear_on_read)\r\ncvmx_dprintf("L2C counters don't support clear on read for this chip\n");\r\nl2c_tadx_prf.u64 = cvmx_read_csr(CVMX_L2C_TADX_PRF(0));\r\nswitch (counter) {\r\ncase 0:\r\nl2c_tadx_prf.s.cnt0sel = event;\r\nbreak;\r\ncase 1:\r\nl2c_tadx_prf.s.cnt1sel = event;\r\nbreak;\r\ncase 2:\r\nl2c_tadx_prf.s.cnt2sel = event;\r\nbreak;\r\ndefault:\r\ncase 3:\r\nl2c_tadx_prf.s.cnt3sel = event;\r\nbreak;\r\n}\r\nfor (tad = 0; tad < CVMX_L2C_TADS; tad++)\r\ncvmx_write_csr(CVMX_L2C_TADX_PRF(tad),\r\nl2c_tadx_prf.u64);\r\n}\r\n}\r\nuint64_t cvmx_l2c_read_perf(uint32_t counter)\r\n{\r\nswitch (counter) {\r\ncase 0:\r\nif (OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN3XXX))\r\nreturn cvmx_read_csr(CVMX_L2C_PFC0);\r\nelse {\r\nuint64_t counter = 0;\r\nint tad;\r\nfor (tad = 0; tad < CVMX_L2C_TADS; tad++)\r\ncounter += cvmx_read_csr(CVMX_L2C_TADX_PFC0(tad));\r\nreturn counter;\r\n}\r\ncase 1:\r\nif (OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN3XXX))\r\nreturn cvmx_read_csr(CVMX_L2C_PFC1);\r\nelse {\r\nuint64_t counter = 0;\r\nint tad;\r\nfor (tad = 0; tad < CVMX_L2C_TADS; tad++)\r\ncounter += cvmx_read_csr(CVMX_L2C_TADX_PFC1(tad));\r\nreturn counter;\r\n}\r\ncase 2:\r\nif (OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN3XXX))\r\nreturn cvmx_read_csr(CVMX_L2C_PFC2);\r\nelse {\r\nuint64_t counter = 0;\r\nint tad;\r\nfor (tad = 0; tad < CVMX_L2C_TADS; tad++)\r\ncounter += cvmx_read_csr(CVMX_L2C_TADX_PFC2(tad));\r\nreturn counter;\r\n}\r\ncase 3:\r\ndefault:\r\nif (OCTEON_IS_MODEL(OCTEON_CN5XXX) || OCTEON_IS_MODEL(OCTEON_CN3XXX))\r\nreturn cvmx_read_csr(CVMX_L2C_PFC3);\r\nelse {\r\nuint64_t counter = 0;\r\nint tad;\r\nfor (tad = 0; tad < CVMX_L2C_TADS; tad++)\r\ncounter += cvmx_read_csr(CVMX_L2C_TADX_PFC3(tad));\r\nreturn counter;\r\n}\r\n}\r\n}\r\nstatic void fault_in(uint64_t addr, int len)\r\n{\r\nchar *ptr;\r\nlen += addr & CVMX_CACHE_LINE_MASK;\r\naddr &= ~CVMX_CACHE_LINE_MASK;\r\nptr = cvmx_phys_to_ptr(addr);\r\nCVMX_DCACHE_INVALIDATE;\r\nwhile (len > 0) {\r\nACCESS_ONCE(*ptr);\r\nlen -= CVMX_CACHE_LINE_SIZE;\r\nptr += CVMX_CACHE_LINE_SIZE;\r\n}\r\n}\r\nint cvmx_l2c_lock_line(uint64_t addr)\r\n{\r\nif (OCTEON_IS_MODEL(OCTEON_CN63XX)) {\r\nint shift = CVMX_L2C_TAG_ADDR_ALIAS_SHIFT;\r\nuint64_t assoc = cvmx_l2c_get_num_assoc();\r\nuint64_t tag = addr >> shift;\r\nuint64_t index = CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS, cvmx_l2c_address_to_index(addr) << CVMX_L2C_IDX_ADDR_SHIFT);\r\nuint64_t way;\r\nunion cvmx_l2c_tadx_tag l2c_tadx_tag;\r\nCVMX_CACHE_LCKL2(CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS, addr), 0);\r\nfor (way = 0; way < assoc; way++) {\r\nCVMX_CACHE_LTGL2I(index | (way << shift), 0);\r\nCVMX_SYNC;\r\nl2c_tadx_tag.u64 = cvmx_read_csr(CVMX_L2C_TADX_TAG(0));\r\nif (l2c_tadx_tag.s.valid && l2c_tadx_tag.s.tag == tag)\r\nbreak;\r\n}\r\nif (way >= assoc) {\r\nreturn -1;\r\n}\r\nif (!l2c_tadx_tag.s.lock) {\r\nreturn -1;\r\n}\r\nreturn way;\r\n} else {\r\nint retval = 0;\r\nunion cvmx_l2c_dbg l2cdbg;\r\nunion cvmx_l2c_lckbase lckbase;\r\nunion cvmx_l2c_lckoff lckoff;\r\nunion cvmx_l2t_err l2t_err;\r\ncvmx_spinlock_lock(&cvmx_l2c_spinlock);\r\nl2cdbg.u64 = 0;\r\nlckbase.u64 = 0;\r\nlckoff.u64 = 0;\r\nl2t_err.u64 = cvmx_read_csr(CVMX_L2T_ERR);\r\nl2t_err.s.lckerr = 1;\r\nl2t_err.s.lckerr2 = 1;\r\ncvmx_write_csr(CVMX_L2T_ERR, l2t_err.u64);\r\naddr &= ~CVMX_CACHE_LINE_MASK;\r\nl2cdbg.s.ppnum = cvmx_get_core_num();\r\nCVMX_SYNC;\r\ncvmx_write_csr(CVMX_L2C_DBG, l2cdbg.u64);\r\ncvmx_read_csr(CVMX_L2C_DBG);\r\nlckoff.s.lck_offset = 0;\r\ncvmx_write_csr(CVMX_L2C_LCKOFF, lckoff.u64);\r\ncvmx_read_csr(CVMX_L2C_LCKOFF);\r\nif (((union cvmx_l2c_cfg)(cvmx_read_csr(CVMX_L2C_CFG))).s.idxalias) {\r\nint alias_shift = CVMX_L2C_IDX_ADDR_SHIFT + 2 * CVMX_L2_SET_BITS - 1;\r\nuint64_t addr_tmp = addr ^ (addr & ((1 << alias_shift) - 1)) >> CVMX_L2_SET_BITS;\r\nlckbase.s.lck_base = addr_tmp >> 7;\r\n} else {\r\nlckbase.s.lck_base = addr >> 7;\r\n}\r\nlckbase.s.lck_ena = 1;\r\ncvmx_write_csr(CVMX_L2C_LCKBASE, lckbase.u64);\r\ncvmx_read_csr(CVMX_L2C_LCKBASE);\r\nfault_in(addr, CVMX_CACHE_LINE_SIZE);\r\nlckbase.s.lck_ena = 0;\r\ncvmx_write_csr(CVMX_L2C_LCKBASE, lckbase.u64);\r\ncvmx_read_csr(CVMX_L2C_LCKBASE);\r\ncvmx_write_csr(CVMX_L2C_DBG, 0);\r\ncvmx_read_csr(CVMX_L2C_DBG);\r\nl2t_err.u64 = cvmx_read_csr(CVMX_L2T_ERR);\r\nif (l2t_err.s.lckerr || l2t_err.s.lckerr2)\r\nretval = 1;\r\ncvmx_spinlock_unlock(&cvmx_l2c_spinlock);\r\nreturn retval;\r\n}\r\n}\r\nint cvmx_l2c_lock_mem_region(uint64_t start, uint64_t len)\r\n{\r\nint retval = 0;\r\nlen += start & CVMX_CACHE_LINE_MASK;\r\nstart &= ~CVMX_CACHE_LINE_MASK;\r\nlen = (len + CVMX_CACHE_LINE_MASK) & ~CVMX_CACHE_LINE_MASK;\r\nwhile (len) {\r\nretval += cvmx_l2c_lock_line(start);\r\nstart += CVMX_CACHE_LINE_SIZE;\r\nlen -= CVMX_CACHE_LINE_SIZE;\r\n}\r\nreturn retval;\r\n}\r\nvoid cvmx_l2c_flush(void)\r\n{\r\nuint64_t assoc, set;\r\nuint64_t n_assoc, n_set;\r\nn_set = cvmx_l2c_get_num_sets();\r\nn_assoc = cvmx_l2c_get_num_assoc();\r\nif (OCTEON_IS_MODEL(OCTEON_CN6XXX)) {\r\nuint64_t address;\r\nint assoc_shift = CVMX_L2C_TAG_ADDR_ALIAS_SHIFT;\r\nint set_shift = CVMX_L2C_IDX_ADDR_SHIFT;\r\nfor (set = 0; set < n_set; set++) {\r\nfor (assoc = 0; assoc < n_assoc; assoc++) {\r\naddress = CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS,\r\n(assoc << assoc_shift) | (set << set_shift));\r\nCVMX_CACHE_WBIL2I(address, 0);\r\n}\r\n}\r\n} else {\r\nfor (set = 0; set < n_set; set++)\r\nfor (assoc = 0; assoc < n_assoc; assoc++)\r\ncvmx_l2c_flush_line(assoc, set);\r\n}\r\n}\r\nint cvmx_l2c_unlock_line(uint64_t address)\r\n{\r\nif (OCTEON_IS_MODEL(OCTEON_CN63XX)) {\r\nint assoc;\r\nunion cvmx_l2c_tag tag;\r\nuint32_t tag_addr;\r\nuint32_t index = cvmx_l2c_address_to_index(address);\r\ntag_addr = ((address >> CVMX_L2C_TAG_ADDR_ALIAS_SHIFT) & ((1 << CVMX_L2C_TAG_ADDR_ALIAS_SHIFT) - 1));\r\nfor (assoc = 0; assoc < CVMX_L2_ASSOC; assoc++) {\r\ntag = cvmx_l2c_get_tag(assoc, index);\r\nif (tag.s.V && (tag.s.addr == tag_addr)) {\r\nCVMX_CACHE_WBIL2(CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS, address), 0);\r\nreturn tag.s.L;\r\n}\r\n}\r\n} else {\r\nint assoc;\r\nunion cvmx_l2c_tag tag;\r\nuint32_t tag_addr;\r\nuint32_t index = cvmx_l2c_address_to_index(address);\r\ntag_addr = ((address >> CVMX_L2C_TAG_ADDR_ALIAS_SHIFT) & ((1 << CVMX_L2C_TAG_ADDR_ALIAS_SHIFT) - 1));\r\nfor (assoc = 0; assoc < CVMX_L2_ASSOC; assoc++) {\r\ntag = cvmx_l2c_get_tag(assoc, index);\r\nif (tag.s.V && (tag.s.addr == tag_addr)) {\r\ncvmx_l2c_flush_line(assoc, index);\r\nreturn tag.s.L;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint cvmx_l2c_unlock_mem_region(uint64_t start, uint64_t len)\r\n{\r\nint num_unlocked = 0;\r\nlen += start & CVMX_CACHE_LINE_MASK;\r\nstart &= ~CVMX_CACHE_LINE_MASK;\r\nlen = (len + CVMX_CACHE_LINE_MASK) & ~CVMX_CACHE_LINE_MASK;\r\nwhile (len > 0) {\r\nnum_unlocked += cvmx_l2c_unlock_line(start);\r\nstart += CVMX_CACHE_LINE_SIZE;\r\nlen -= CVMX_CACHE_LINE_SIZE;\r\n}\r\nreturn num_unlocked;\r\n}\r\nstatic union __cvmx_l2c_tag __read_l2_tag(uint64_t assoc, uint64_t index)\r\n{\r\nuint64_t debug_tag_addr = CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS, (index << 7) + 96);\r\nuint64_t core = cvmx_get_core_num();\r\nunion __cvmx_l2c_tag tag_val;\r\nuint64_t dbg_addr = CVMX_L2C_DBG;\r\nunsigned long flags;\r\nunion cvmx_l2c_dbg debug_val;\r\ndebug_val.u64 = 0;\r\ndebug_val.s.ppnum = core;\r\ndebug_val.s.l2t = 1;\r\ndebug_val.s.set = assoc;\r\nlocal_irq_save(flags);\r\nCVMX_SYNC;\r\nCVMX_DCACHE_INVALIDATE;\r\nasm volatile (\r\n".set push\n\t"\r\n".set mips64\n\t"\r\n".set noreorder\n\t"\r\n"sd %[dbg_val], 0(%[dbg_addr])\n\t"\r\n"ld $0, 0(%[dbg_addr])\n\t"\r\n"ld %[tag_val], 0(%[tag_addr])\n\t"\r\n"sd $0, 0(%[dbg_addr])\n\t"\r\n"ld $0, 0(%[dbg_addr])\n\t"\r\n"cache 9, 0($0)\n\t"\r\n".set pop"\r\n: [tag_val] "=r" (tag_val)\r\n: [dbg_addr] "r" (dbg_addr), [dbg_val] "r" (debug_val), [tag_addr] "r" (debug_tag_addr)\r\n: "memory");\r\nlocal_irq_restore(flags);\r\nreturn tag_val;\r\n}\r\nunion cvmx_l2c_tag cvmx_l2c_get_tag(uint32_t association, uint32_t index)\r\n{\r\nunion cvmx_l2c_tag tag;\r\ntag.u64 = 0;\r\nif ((int)association >= cvmx_l2c_get_num_assoc()) {\r\ncvmx_dprintf("ERROR: cvmx_l2c_get_tag association out of range\n");\r\nreturn tag;\r\n}\r\nif ((int)index >= cvmx_l2c_get_num_sets()) {\r\ncvmx_dprintf("ERROR: cvmx_l2c_get_tag index out of range (arg: %d, max: %d)\n",\r\n(int)index, cvmx_l2c_get_num_sets());\r\nreturn tag;\r\n}\r\nif (OCTEON_IS_MODEL(OCTEON_CN63XX)) {\r\nunion cvmx_l2c_tadx_tag l2c_tadx_tag;\r\nuint64_t address = CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS,\r\n(association << CVMX_L2C_TAG_ADDR_ALIAS_SHIFT) |\r\n(index << CVMX_L2C_IDX_ADDR_SHIFT));\r\nCVMX_CACHE_LTGL2I(address, 0);\r\nCVMX_SYNC;\r\nl2c_tadx_tag.u64 = cvmx_read_csr(CVMX_L2C_TADX_TAG(0));\r\ntag.s.V = l2c_tadx_tag.s.valid;\r\ntag.s.D = l2c_tadx_tag.s.dirty;\r\ntag.s.L = l2c_tadx_tag.s.lock;\r\ntag.s.U = l2c_tadx_tag.s.use;\r\ntag.s.addr = l2c_tadx_tag.s.tag;\r\n} else {\r\nunion __cvmx_l2c_tag tmp_tag;\r\ntmp_tag = __read_l2_tag(association, index);\r\nif (OCTEON_IS_MODEL(OCTEON_CN58XX) || OCTEON_IS_MODEL(OCTEON_CN56XX)) {\r\ntag.s.V = tmp_tag.cn58xx.V;\r\ntag.s.D = tmp_tag.cn58xx.D;\r\ntag.s.L = tmp_tag.cn58xx.L;\r\ntag.s.U = tmp_tag.cn58xx.U;\r\ntag.s.addr = tmp_tag.cn58xx.addr;\r\n} else if (OCTEON_IS_MODEL(OCTEON_CN38XX)) {\r\ntag.s.V = tmp_tag.cn38xx.V;\r\ntag.s.D = tmp_tag.cn38xx.D;\r\ntag.s.L = tmp_tag.cn38xx.L;\r\ntag.s.U = tmp_tag.cn38xx.U;\r\ntag.s.addr = tmp_tag.cn38xx.addr;\r\n} else if (OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN52XX)) {\r\ntag.s.V = tmp_tag.cn31xx.V;\r\ntag.s.D = tmp_tag.cn31xx.D;\r\ntag.s.L = tmp_tag.cn31xx.L;\r\ntag.s.U = tmp_tag.cn31xx.U;\r\ntag.s.addr = tmp_tag.cn31xx.addr;\r\n} else if (OCTEON_IS_MODEL(OCTEON_CN30XX)) {\r\ntag.s.V = tmp_tag.cn30xx.V;\r\ntag.s.D = tmp_tag.cn30xx.D;\r\ntag.s.L = tmp_tag.cn30xx.L;\r\ntag.s.U = tmp_tag.cn30xx.U;\r\ntag.s.addr = tmp_tag.cn30xx.addr;\r\n} else if (OCTEON_IS_MODEL(OCTEON_CN50XX)) {\r\ntag.s.V = tmp_tag.cn50xx.V;\r\ntag.s.D = tmp_tag.cn50xx.D;\r\ntag.s.L = tmp_tag.cn50xx.L;\r\ntag.s.U = tmp_tag.cn50xx.U;\r\ntag.s.addr = tmp_tag.cn50xx.addr;\r\n} else {\r\ncvmx_dprintf("Unsupported OCTEON Model in %s\n", __func__);\r\n}\r\n}\r\nreturn tag;\r\n}\r\nuint32_t cvmx_l2c_address_to_index(uint64_t addr)\r\n{\r\nuint64_t idx = addr >> CVMX_L2C_IDX_ADDR_SHIFT;\r\nint indxalias = 0;\r\nif (OCTEON_IS_MODEL(OCTEON_CN6XXX)) {\r\nunion cvmx_l2c_ctl l2c_ctl;\r\nl2c_ctl.u64 = cvmx_read_csr(CVMX_L2C_CTL);\r\nindxalias = !l2c_ctl.s.disidxalias;\r\n} else {\r\nunion cvmx_l2c_cfg l2c_cfg;\r\nl2c_cfg.u64 = cvmx_read_csr(CVMX_L2C_CFG);\r\nindxalias = l2c_cfg.s.idxalias;\r\n}\r\nif (indxalias) {\r\nif (OCTEON_IS_MODEL(OCTEON_CN63XX)) {\r\nuint32_t a_14_12 = (idx / (CVMX_L2C_MEMBANK_SELECT_SIZE/(1<<CVMX_L2C_IDX_ADDR_SHIFT))) & 0x7;\r\nidx ^= idx / cvmx_l2c_get_num_sets();\r\nidx ^= a_14_12;\r\n} else {\r\nidx ^= ((addr & CVMX_L2C_ALIAS_MASK) >> CVMX_L2C_TAG_ADDR_ALIAS_SHIFT);\r\n}\r\n}\r\nidx &= CVMX_L2C_IDX_MASK;\r\nreturn idx;\r\n}\r\nint cvmx_l2c_get_cache_size_bytes(void)\r\n{\r\nreturn cvmx_l2c_get_num_sets() * cvmx_l2c_get_num_assoc() *\r\nCVMX_CACHE_LINE_SIZE;\r\n}\r\nint cvmx_l2c_get_set_bits(void)\r\n{\r\nint l2_set_bits;\r\nif (OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN58XX))\r\nl2_set_bits = 11;\r\nelse if (OCTEON_IS_MODEL(OCTEON_CN38XX) || OCTEON_IS_MODEL(OCTEON_CN63XX))\r\nl2_set_bits = 10;\r\nelse if (OCTEON_IS_MODEL(OCTEON_CN31XX) || OCTEON_IS_MODEL(OCTEON_CN52XX))\r\nl2_set_bits = 9;\r\nelse if (OCTEON_IS_MODEL(OCTEON_CN30XX))\r\nl2_set_bits = 8;\r\nelse if (OCTEON_IS_MODEL(OCTEON_CN50XX))\r\nl2_set_bits = 7;\r\nelse {\r\ncvmx_dprintf("Unsupported OCTEON Model in %s\n", __func__);\r\nl2_set_bits = 11;\r\n}\r\nreturn l2_set_bits;\r\n}\r\nint cvmx_l2c_get_num_sets(void)\r\n{\r\nreturn 1 << cvmx_l2c_get_set_bits();\r\n}\r\nint cvmx_l2c_get_num_assoc(void)\r\n{\r\nint l2_assoc;\r\nif (OCTEON_IS_MODEL(OCTEON_CN56XX) ||\r\nOCTEON_IS_MODEL(OCTEON_CN52XX) ||\r\nOCTEON_IS_MODEL(OCTEON_CN58XX) ||\r\nOCTEON_IS_MODEL(OCTEON_CN50XX) ||\r\nOCTEON_IS_MODEL(OCTEON_CN38XX))\r\nl2_assoc = 8;\r\nelse if (OCTEON_IS_MODEL(OCTEON_CN63XX))\r\nl2_assoc = 16;\r\nelse if (OCTEON_IS_MODEL(OCTEON_CN31XX) ||\r\nOCTEON_IS_MODEL(OCTEON_CN30XX))\r\nl2_assoc = 4;\r\nelse {\r\ncvmx_dprintf("Unsupported OCTEON Model in %s\n", __func__);\r\nl2_assoc = 8;\r\n}\r\nif (OCTEON_IS_MODEL(OCTEON_CN63XX)) {\r\nunion cvmx_mio_fus_dat3 mio_fus_dat3;\r\nmio_fus_dat3.u64 = cvmx_read_csr(CVMX_MIO_FUS_DAT3);\r\nif (mio_fus_dat3.s.l2c_crip == 3)\r\nl2_assoc = 4;\r\nelse if (mio_fus_dat3.s.l2c_crip == 2)\r\nl2_assoc = 8;\r\nelse if (mio_fus_dat3.s.l2c_crip == 1)\r\nl2_assoc = 12;\r\n} else {\r\nunion cvmx_l2d_fus3 val;\r\nval.u64 = cvmx_read_csr(CVMX_L2D_FUS3);\r\nif ((val.u64 >> 35) & 0x1)\r\nl2_assoc = l2_assoc >> 2;\r\nelse if ((val.u64 >> 34) & 0x1)\r\nl2_assoc = l2_assoc >> 1;\r\n}\r\nreturn l2_assoc;\r\n}\r\nvoid cvmx_l2c_flush_line(uint32_t assoc, uint32_t index)\r\n{\r\nif (index > (uint32_t)cvmx_l2c_get_num_sets()) {\r\ncvmx_dprintf("ERROR: cvmx_l2c_flush_line index out of range.\n");\r\nreturn;\r\n}\r\nif (assoc > (uint32_t)cvmx_l2c_get_num_assoc()) {\r\ncvmx_dprintf("ERROR: cvmx_l2c_flush_line association out of range.\n");\r\nreturn;\r\n}\r\nif (OCTEON_IS_MODEL(OCTEON_CN63XX)) {\r\nuint64_t address;\r\naddress = CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS,\r\n(assoc << CVMX_L2C_TAG_ADDR_ALIAS_SHIFT) |\r\n(index << CVMX_L2C_IDX_ADDR_SHIFT));\r\nCVMX_CACHE_WBIL2I(address, 0);\r\n} else {\r\nunion cvmx_l2c_dbg l2cdbg;\r\nl2cdbg.u64 = 0;\r\nif (!OCTEON_IS_MODEL(OCTEON_CN30XX))\r\nl2cdbg.s.ppnum = cvmx_get_core_num();\r\nl2cdbg.s.finv = 1;\r\nl2cdbg.s.set = assoc;\r\ncvmx_spinlock_lock(&cvmx_l2c_spinlock);\r\nCVMX_SYNC;\r\ncvmx_write_csr(CVMX_L2C_DBG, l2cdbg.u64);\r\ncvmx_read_csr(CVMX_L2C_DBG);\r\nCVMX_PREPARE_FOR_STORE(CVMX_ADD_SEG(CVMX_MIPS_SPACE_XKPHYS,\r\nindex * CVMX_CACHE_LINE_SIZE),\r\n0);\r\nCVMX_SYNC;\r\ncvmx_write_csr(CVMX_L2C_DBG, 0);\r\ncvmx_read_csr(CVMX_L2C_DBG);\r\ncvmx_spinlock_unlock(&cvmx_l2c_spinlock);\r\n}\r\n}
