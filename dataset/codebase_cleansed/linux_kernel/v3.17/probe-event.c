static int e_snprintf(char *str, size_t size, const char *format, ...)\r\n{\r\nint ret;\r\nva_list ap;\r\nva_start(ap, format);\r\nret = vsnprintf(str, size, format, ap);\r\nva_end(ap);\r\nif (ret >= (int)size)\r\nret = -E2BIG;\r\nreturn ret;\r\n}\r\nstatic int init_symbol_maps(bool user_only)\r\n{\r\nint ret;\r\nsymbol_conf.sort_by_name = true;\r\nret = symbol__init();\r\nif (ret < 0) {\r\npr_debug("Failed to init symbol map.\n");\r\ngoto out;\r\n}\r\nif (host_machine || user_only)\r\nreturn 0;\r\nif (symbol_conf.vmlinux_name)\r\npr_debug("Use vmlinux: %s\n", symbol_conf.vmlinux_name);\r\nhost_machine = machine__new_host();\r\nif (!host_machine) {\r\npr_debug("machine__new_host() failed.\n");\r\nsymbol__exit();\r\nret = -1;\r\n}\r\nout:\r\nif (ret < 0)\r\npr_warning("Failed to init vmlinux path.\n");\r\nreturn ret;\r\n}\r\nstatic void exit_symbol_maps(void)\r\n{\r\nif (host_machine) {\r\nmachine__delete(host_machine);\r\nhost_machine = NULL;\r\n}\r\nsymbol__exit();\r\n}\r\nstatic struct symbol *__find_kernel_function_by_name(const char *name,\r\nstruct map **mapp)\r\n{\r\nreturn machine__find_kernel_function_by_name(host_machine, name, mapp,\r\nNULL);\r\n}\r\nstatic struct symbol *__find_kernel_function(u64 addr, struct map **mapp)\r\n{\r\nreturn machine__find_kernel_function(host_machine, addr, mapp, NULL);\r\n}\r\nstatic struct ref_reloc_sym *kernel_get_ref_reloc_sym(void)\r\n{\r\nstruct kmap *kmap;\r\nif (map__load(host_machine->vmlinux_maps[MAP__FUNCTION], NULL) < 0)\r\nreturn NULL;\r\nkmap = map__kmap(host_machine->vmlinux_maps[MAP__FUNCTION]);\r\nreturn kmap->ref_reloc_sym;\r\n}\r\nstatic u64 kernel_get_symbol_address_by_name(const char *name, bool reloc)\r\n{\r\nstruct ref_reloc_sym *reloc_sym;\r\nstruct symbol *sym;\r\nstruct map *map;\r\nreloc_sym = kernel_get_ref_reloc_sym();\r\nif (reloc_sym && strcmp(name, reloc_sym->name) == 0)\r\nreturn (reloc) ? reloc_sym->addr : reloc_sym->unrelocated_addr;\r\nelse {\r\nsym = __find_kernel_function_by_name(name, &map);\r\nif (sym)\r\nreturn map->unmap_ip(map, sym->start) -\r\n(reloc) ? 0 : map->reloc;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct map *kernel_get_module_map(const char *module)\r\n{\r\nstruct rb_node *nd;\r\nstruct map_groups *grp = &host_machine->kmaps;\r\nif (module && strchr(module, '/'))\r\nreturn machine__new_module(host_machine, 0, module);\r\nif (!module)\r\nmodule = "kernel";\r\nfor (nd = rb_first(&grp->maps[MAP__FUNCTION]); nd; nd = rb_next(nd)) {\r\nstruct map *pos = rb_entry(nd, struct map, rb_node);\r\nif (strncmp(pos->dso->short_name + 1, module,\r\npos->dso->short_name_len - 2) == 0) {\r\nreturn pos;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct dso *kernel_get_module_dso(const char *module)\r\n{\r\nstruct dso *dso;\r\nstruct map *map;\r\nconst char *vmlinux_name;\r\nif (module) {\r\nlist_for_each_entry(dso, &host_machine->kernel_dsos, node) {\r\nif (strncmp(dso->short_name + 1, module,\r\ndso->short_name_len - 2) == 0)\r\ngoto found;\r\n}\r\npr_debug("Failed to find module %s.\n", module);\r\nreturn NULL;\r\n}\r\nmap = host_machine->vmlinux_maps[MAP__FUNCTION];\r\ndso = map->dso;\r\nvmlinux_name = symbol_conf.vmlinux_name;\r\nif (vmlinux_name) {\r\nif (dso__load_vmlinux(dso, map, vmlinux_name, false, NULL) <= 0)\r\nreturn NULL;\r\n} else {\r\nif (dso__load_vmlinux_path(dso, map, NULL) <= 0) {\r\npr_debug("Failed to load kernel map.\n");\r\nreturn NULL;\r\n}\r\n}\r\nfound:\r\nreturn dso;\r\n}\r\nconst char *kernel_get_module_path(const char *module)\r\n{\r\nstruct dso *dso = kernel_get_module_dso(module);\r\nreturn (dso) ? dso->long_name : NULL;\r\n}\r\nstatic int convert_exec_to_group(const char *exec, char **result)\r\n{\r\nchar *ptr1, *ptr2, *exec_copy;\r\nchar buf[64];\r\nint ret;\r\nexec_copy = strdup(exec);\r\nif (!exec_copy)\r\nreturn -ENOMEM;\r\nptr1 = basename(exec_copy);\r\nif (!ptr1) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nptr2 = strpbrk(ptr1, "-._");\r\nif (ptr2)\r\n*ptr2 = '\0';\r\nret = e_snprintf(buf, 64, "%s_%s", PERFPROBE_GROUP, ptr1);\r\nif (ret < 0)\r\ngoto out;\r\n*result = strdup(buf);\r\nret = *result ? 0 : -ENOMEM;\r\nout:\r\nfree(exec_copy);\r\nreturn ret;\r\n}\r\nstatic void clear_probe_trace_events(struct probe_trace_event *tevs, int ntevs)\r\n{\r\nint i;\r\nfor (i = 0; i < ntevs; i++)\r\nclear_probe_trace_event(tevs + i);\r\n}\r\nstatic struct debuginfo *open_debuginfo(const char *module)\r\n{\r\nconst char *path = module;\r\nif (!module || !strchr(module, '/')) {\r\npath = kernel_get_module_path(module);\r\nif (!path) {\r\npr_err("Failed to find path of %s module.\n",\r\nmodule ?: "kernel");\r\nreturn NULL;\r\n}\r\n}\r\nreturn debuginfo__new(path);\r\n}\r\nstatic int get_text_start_address(const char *exec, unsigned long *address)\r\n{\r\nElf *elf;\r\nGElf_Ehdr ehdr;\r\nGElf_Shdr shdr;\r\nint fd, ret = -ENOENT;\r\nfd = open(exec, O_RDONLY);\r\nif (fd < 0)\r\nreturn -errno;\r\nelf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);\r\nif (elf == NULL)\r\nreturn -EINVAL;\r\nif (gelf_getehdr(elf, &ehdr) == NULL)\r\ngoto out;\r\nif (!elf_section_by_name(elf, &ehdr, &shdr, ".text", NULL))\r\ngoto out;\r\n*address = shdr.sh_addr - shdr.sh_offset;\r\nret = 0;\r\nout:\r\nelf_end(elf);\r\nreturn ret;\r\n}\r\nstatic int find_perf_probe_point_from_dwarf(struct probe_trace_point *tp,\r\nstruct perf_probe_point *pp,\r\nbool is_kprobe)\r\n{\r\nstruct debuginfo *dinfo = NULL;\r\nunsigned long stext = 0;\r\nu64 addr = tp->address;\r\nint ret = -ENOENT;\r\nif (!is_kprobe) {\r\nif (!addr) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nret = get_text_start_address(tp->module, &stext);\r\nif (ret < 0)\r\ngoto error;\r\naddr += stext;\r\n} else {\r\naddr = kernel_get_symbol_address_by_name(tp->symbol, false);\r\nif (addr == 0)\r\ngoto error;\r\naddr += tp->offset;\r\n}\r\npr_debug("try to find information at %" PRIx64 " in %s\n", addr,\r\ntp->module ? : "kernel");\r\ndinfo = open_debuginfo(tp->module);\r\nif (dinfo) {\r\nret = debuginfo__find_probe_point(dinfo,\r\n(unsigned long)addr, pp);\r\ndebuginfo__delete(dinfo);\r\n} else {\r\npr_debug("Failed to open debuginfo at 0x%" PRIx64 "\n", addr);\r\nret = -ENOENT;\r\n}\r\nif (ret > 0) {\r\npp->retprobe = tp->retprobe;\r\nreturn 0;\r\n}\r\nerror:\r\npr_debug("Failed to find corresponding probes from debuginfo.\n");\r\nreturn ret ? : -ENOENT;\r\n}\r\nstatic int add_exec_to_probe_trace_events(struct probe_trace_event *tevs,\r\nint ntevs, const char *exec)\r\n{\r\nint i, ret = 0;\r\nunsigned long stext = 0;\r\nif (!exec)\r\nreturn 0;\r\nret = get_text_start_address(exec, &stext);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < ntevs && ret >= 0; i++) {\r\ntevs[i].point.address -= stext;\r\ntevs[i].point.module = strdup(exec);\r\nif (!tevs[i].point.module) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\ntevs[i].uprobes = true;\r\n}\r\nreturn ret;\r\n}\r\nstatic int add_module_to_probe_trace_events(struct probe_trace_event *tevs,\r\nint ntevs, const char *module)\r\n{\r\nint i, ret = 0;\r\nchar *tmp;\r\nif (!module)\r\nreturn 0;\r\ntmp = strrchr(module, '/');\r\nif (tmp) {\r\nmodule = strdup(tmp + 1);\r\nif (!module)\r\nreturn -ENOMEM;\r\ntmp = strchr(module, '.');\r\nif (tmp)\r\n*tmp = '\0';\r\ntmp = (char *)module;\r\n}\r\nfor (i = 0; i < ntevs; i++) {\r\ntevs[i].point.module = strdup(module);\r\nif (!tevs[i].point.module) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\n}\r\nfree(tmp);\r\nreturn ret;\r\n}\r\nstatic int post_process_probe_trace_events(struct probe_trace_event *tevs,\r\nint ntevs, const char *module,\r\nbool uprobe)\r\n{\r\nstruct ref_reloc_sym *reloc_sym;\r\nchar *tmp;\r\nint i;\r\nif (uprobe)\r\nreturn add_exec_to_probe_trace_events(tevs, ntevs, module);\r\nif (module)\r\nreturn add_module_to_probe_trace_events(tevs, ntevs, module);\r\nreloc_sym = kernel_get_ref_reloc_sym();\r\nif (!reloc_sym) {\r\npr_warning("Relocated base symbol is not found!\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ntevs; i++) {\r\nif (tevs[i].point.address) {\r\ntmp = strdup(reloc_sym->name);\r\nif (!tmp)\r\nreturn -ENOMEM;\r\nfree(tevs[i].point.symbol);\r\ntevs[i].point.symbol = tmp;\r\ntevs[i].point.offset = tevs[i].point.address -\r\nreloc_sym->unrelocated_addr;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int try_to_find_probe_trace_events(struct perf_probe_event *pev,\r\nstruct probe_trace_event **tevs,\r\nint max_tevs, const char *target)\r\n{\r\nbool need_dwarf = perf_probe_event_need_dwarf(pev);\r\nstruct debuginfo *dinfo;\r\nint ntevs, ret = 0;\r\ndinfo = open_debuginfo(target);\r\nif (!dinfo) {\r\nif (need_dwarf) {\r\npr_warning("Failed to open debuginfo file.\n");\r\nreturn -ENOENT;\r\n}\r\npr_debug("Could not open debuginfo. Try to use symbols.\n");\r\nreturn 0;\r\n}\r\npr_debug("Try to find probe point from debuginfo.\n");\r\nntevs = debuginfo__find_trace_events(dinfo, pev, tevs, max_tevs);\r\ndebuginfo__delete(dinfo);\r\nif (ntevs > 0) {\r\npr_debug("Found %d probe_trace_events.\n", ntevs);\r\nret = post_process_probe_trace_events(*tevs, ntevs,\r\ntarget, pev->uprobes);\r\nif (ret < 0) {\r\nclear_probe_trace_events(*tevs, ntevs);\r\nzfree(tevs);\r\n}\r\nreturn ret < 0 ? ret : ntevs;\r\n}\r\nif (ntevs == 0) {\r\npr_warning("Probe point '%s' not found.\n",\r\nsynthesize_perf_probe_point(&pev->point));\r\nreturn -ENOENT;\r\n}\r\npr_debug("An error occurred in debuginfo analysis (%d).\n", ntevs);\r\nif (ntevs == -EBADF) {\r\npr_warning("Warning: No dwarf info found in the vmlinux - "\r\n"please rebuild kernel with CONFIG_DEBUG_INFO=y.\n");\r\nif (!need_dwarf) {\r\npr_debug("Trying to use symbols.\n");\r\nreturn 0;\r\n}\r\n}\r\nreturn ntevs;\r\n}\r\nstatic int get_real_path(const char *raw_path, const char *comp_dir,\r\nchar **new_path)\r\n{\r\nconst char *prefix = symbol_conf.source_prefix;\r\nif (!prefix) {\r\nif (raw_path[0] != '/' && comp_dir)\r\nprefix = comp_dir;\r\nelse {\r\nif (access(raw_path, R_OK) == 0) {\r\n*new_path = strdup(raw_path);\r\nreturn 0;\r\n} else\r\nreturn -errno;\r\n}\r\n}\r\n*new_path = malloc((strlen(prefix) + strlen(raw_path) + 2));\r\nif (!*new_path)\r\nreturn -ENOMEM;\r\nfor (;;) {\r\nsprintf(*new_path, "%s/%s", prefix, raw_path);\r\nif (access(*new_path, R_OK) == 0)\r\nreturn 0;\r\nif (!symbol_conf.source_prefix)\r\nreturn -errno;\r\nswitch (errno) {\r\ncase ENAMETOOLONG:\r\ncase ENOENT:\r\ncase EROFS:\r\ncase EFAULT:\r\nraw_path = strchr(++raw_path, '/');\r\nif (!raw_path) {\r\nzfree(new_path);\r\nreturn -ENOENT;\r\n}\r\ncontinue;\r\ndefault:\r\nzfree(new_path);\r\nreturn -errno;\r\n}\r\n}\r\n}\r\nstatic int __show_one_line(FILE *fp, int l, bool skip, bool show_num)\r\n{\r\nchar buf[LINEBUF_SIZE];\r\nconst char *color = show_num ? "" : PERF_COLOR_BLUE;\r\nconst char *prefix = NULL;\r\ndo {\r\nif (fgets(buf, LINEBUF_SIZE, fp) == NULL)\r\ngoto error;\r\nif (skip)\r\ncontinue;\r\nif (!prefix) {\r\nprefix = show_num ? "%7d " : " ";\r\ncolor_fprintf(stdout, color, prefix, l);\r\n}\r\ncolor_fprintf(stdout, color, "%s", buf);\r\n} while (strchr(buf, '\n') == NULL);\r\nreturn 1;\r\nerror:\r\nif (ferror(fp)) {\r\npr_warning("File read error: %s\n", strerror(errno));\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int _show_one_line(FILE *fp, int l, bool skip, bool show_num)\r\n{\r\nint rv = __show_one_line(fp, l, skip, show_num);\r\nif (rv == 0) {\r\npr_warning("Source file is shorter than expected.\n");\r\nrv = -1;\r\n}\r\nreturn rv;\r\n}\r\nstatic int __show_line_range(struct line_range *lr, const char *module)\r\n{\r\nint l = 1;\r\nstruct int_node *ln;\r\nstruct debuginfo *dinfo;\r\nFILE *fp;\r\nint ret;\r\nchar *tmp;\r\ndinfo = open_debuginfo(module);\r\nif (!dinfo) {\r\npr_warning("Failed to open debuginfo file.\n");\r\nreturn -ENOENT;\r\n}\r\nret = debuginfo__find_line_range(dinfo, lr);\r\ndebuginfo__delete(dinfo);\r\nif (ret == 0 || ret == -ENOENT) {\r\npr_warning("Specified source line is not found.\n");\r\nreturn -ENOENT;\r\n} else if (ret < 0) {\r\npr_warning("Debuginfo analysis failed.\n");\r\nreturn ret;\r\n}\r\ntmp = lr->path;\r\nret = get_real_path(tmp, lr->comp_dir, &lr->path);\r\nfree(tmp);\r\nif (ret < 0) {\r\npr_warning("Failed to find source file path.\n");\r\nreturn ret;\r\n}\r\nsetup_pager();\r\nif (lr->function)\r\nfprintf(stdout, "<%s@%s:%d>\n", lr->function, lr->path,\r\nlr->start - lr->offset);\r\nelse\r\nfprintf(stdout, "<%s:%d>\n", lr->path, lr->start);\r\nfp = fopen(lr->path, "r");\r\nif (fp == NULL) {\r\npr_warning("Failed to open %s: %s\n", lr->path,\r\nstrerror(errno));\r\nreturn -errno;\r\n}\r\nwhile (l < lr->start) {\r\nret = skip_one_line(fp, l++);\r\nif (ret < 0)\r\ngoto end;\r\n}\r\nintlist__for_each(ln, lr->line_list) {\r\nfor (; ln->i > l; l++) {\r\nret = show_one_line(fp, l - lr->offset);\r\nif (ret < 0)\r\ngoto end;\r\n}\r\nret = show_one_line_with_num(fp, l++ - lr->offset);\r\nif (ret < 0)\r\ngoto end;\r\n}\r\nif (lr->end == INT_MAX)\r\nlr->end = l + NR_ADDITIONAL_LINES;\r\nwhile (l <= lr->end) {\r\nret = show_one_line_or_eof(fp, l++ - lr->offset);\r\nif (ret <= 0)\r\nbreak;\r\n}\r\nend:\r\nfclose(fp);\r\nreturn ret;\r\n}\r\nint show_line_range(struct line_range *lr, const char *module)\r\n{\r\nint ret;\r\nret = init_symbol_maps(false);\r\nif (ret < 0)\r\nreturn ret;\r\nret = __show_line_range(lr, module);\r\nexit_symbol_maps();\r\nreturn ret;\r\n}\r\nstatic int show_available_vars_at(struct debuginfo *dinfo,\r\nstruct perf_probe_event *pev,\r\nint max_vls, struct strfilter *_filter,\r\nbool externs)\r\n{\r\nchar *buf;\r\nint ret, i, nvars;\r\nstruct str_node *node;\r\nstruct variable_list *vls = NULL, *vl;\r\nconst char *var;\r\nbuf = synthesize_perf_probe_point(&pev->point);\r\nif (!buf)\r\nreturn -EINVAL;\r\npr_debug("Searching variables at %s\n", buf);\r\nret = debuginfo__find_available_vars_at(dinfo, pev, &vls,\r\nmax_vls, externs);\r\nif (ret <= 0) {\r\nif (ret == 0 || ret == -ENOENT) {\r\npr_err("Failed to find the address of %s\n", buf);\r\nret = -ENOENT;\r\n} else\r\npr_warning("Debuginfo analysis failed.\n");\r\ngoto end;\r\n}\r\nfprintf(stdout, "Available variables at %s\n", buf);\r\nfor (i = 0; i < ret; i++) {\r\nvl = &vls[i];\r\nfprintf(stdout, "\t@<%s+%lu>\n", vl->point.symbol,\r\nvl->point.offset);\r\nzfree(&vl->point.symbol);\r\nnvars = 0;\r\nif (vl->vars) {\r\nstrlist__for_each(node, vl->vars) {\r\nvar = strchr(node->s, '\t') + 1;\r\nif (strfilter__compare(_filter, var)) {\r\nfprintf(stdout, "\t\t%s\n", node->s);\r\nnvars++;\r\n}\r\n}\r\nstrlist__delete(vl->vars);\r\n}\r\nif (nvars == 0)\r\nfprintf(stdout, "\t\t(No matched variables)\n");\r\n}\r\nfree(vls);\r\nend:\r\nfree(buf);\r\nreturn ret;\r\n}\r\nint show_available_vars(struct perf_probe_event *pevs, int npevs,\r\nint max_vls, const char *module,\r\nstruct strfilter *_filter, bool externs)\r\n{\r\nint i, ret = 0;\r\nstruct debuginfo *dinfo;\r\nret = init_symbol_maps(false);\r\nif (ret < 0)\r\nreturn ret;\r\ndinfo = open_debuginfo(module);\r\nif (!dinfo) {\r\npr_warning("Failed to open debuginfo file.\n");\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nsetup_pager();\r\nfor (i = 0; i < npevs && ret >= 0; i++)\r\nret = show_available_vars_at(dinfo, &pevs[i], max_vls, _filter,\r\nexterns);\r\ndebuginfo__delete(dinfo);\r\nout:\r\nexit_symbol_maps();\r\nreturn ret;\r\n}\r\nstatic int\r\nfind_perf_probe_point_from_dwarf(struct probe_trace_point *tp __maybe_unused,\r\nstruct perf_probe_point *pp __maybe_unused,\r\nbool is_kprobe __maybe_unused)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int try_to_find_probe_trace_events(struct perf_probe_event *pev,\r\nstruct probe_trace_event **tevs __maybe_unused,\r\nint max_tevs __maybe_unused,\r\nconst char *target __maybe_unused)\r\n{\r\nif (perf_probe_event_need_dwarf(pev)) {\r\npr_warning("Debuginfo-analysis is not supported.\n");\r\nreturn -ENOSYS;\r\n}\r\nreturn 0;\r\n}\r\nint show_line_range(struct line_range *lr __maybe_unused,\r\nconst char *module __maybe_unused)\r\n{\r\npr_warning("Debuginfo-analysis is not supported.\n");\r\nreturn -ENOSYS;\r\n}\r\nint show_available_vars(struct perf_probe_event *pevs __maybe_unused,\r\nint npevs __maybe_unused, int max_vls __maybe_unused,\r\nconst char *module __maybe_unused,\r\nstruct strfilter *filter __maybe_unused,\r\nbool externs __maybe_unused)\r\n{\r\npr_warning("Debuginfo-analysis is not supported.\n");\r\nreturn -ENOSYS;\r\n}\r\nvoid line_range__clear(struct line_range *lr)\r\n{\r\nfree(lr->function);\r\nfree(lr->file);\r\nfree(lr->path);\r\nfree(lr->comp_dir);\r\nintlist__delete(lr->line_list);\r\nmemset(lr, 0, sizeof(*lr));\r\n}\r\nint line_range__init(struct line_range *lr)\r\n{\r\nmemset(lr, 0, sizeof(*lr));\r\nlr->line_list = intlist__new(NULL);\r\nif (!lr->line_list)\r\nreturn -ENOMEM;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int parse_line_num(char **ptr, int *val, const char *what)\r\n{\r\nconst char *start = *ptr;\r\nerrno = 0;\r\n*val = strtol(*ptr, ptr, 0);\r\nif (errno || *ptr == start) {\r\nsemantic_error("'%s' is not a valid number.\n", what);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint parse_line_range_desc(const char *arg, struct line_range *lr)\r\n{\r\nchar *range, *file, *name = strdup(arg);\r\nint err;\r\nif (!name)\r\nreturn -ENOMEM;\r\nlr->start = 0;\r\nlr->end = INT_MAX;\r\nrange = strchr(name, ':');\r\nif (range) {\r\n*range++ = '\0';\r\nerr = parse_line_num(&range, &lr->start, "start line");\r\nif (err)\r\ngoto err;\r\nif (*range == '+' || *range == '-') {\r\nconst char c = *range++;\r\nerr = parse_line_num(&range, &lr->end, "end line");\r\nif (err)\r\ngoto err;\r\nif (c == '+') {\r\nlr->end += lr->start;\r\nlr->end--;\r\n}\r\n}\r\npr_debug("Line range is %d to %d\n", lr->start, lr->end);\r\nerr = -EINVAL;\r\nif (lr->start > lr->end) {\r\nsemantic_error("Start line must be smaller"\r\n" than end line.\n");\r\ngoto err;\r\n}\r\nif (*range != '\0') {\r\nsemantic_error("Tailing with invalid str '%s'.\n", range);\r\ngoto err;\r\n}\r\n}\r\nfile = strchr(name, '@');\r\nif (file) {\r\n*file = '\0';\r\nlr->file = strdup(++file);\r\nif (lr->file == NULL) {\r\nerr = -ENOMEM;\r\ngoto err;\r\n}\r\nlr->function = name;\r\n} else if (strchr(name, '.'))\r\nlr->file = name;\r\nelse\r\nlr->function = name;\r\nreturn 0;\r\nerr:\r\nfree(name);\r\nreturn err;\r\n}\r\nstatic bool check_event_name(const char *name)\r\n{\r\nif (!isalpha(*name) && *name != '_')\r\nreturn false;\r\nwhile (*++name != '\0') {\r\nif (!isalpha(*name) && !isdigit(*name) && *name != '_')\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int parse_perf_probe_point(char *arg, struct perf_probe_event *pev)\r\n{\r\nstruct perf_probe_point *pp = &pev->point;\r\nchar *ptr, *tmp;\r\nchar c, nc = 0;\r\nptr = strpbrk(arg, ";=@+%");\r\nif (ptr && *ptr == '=') {\r\n*ptr = '\0';\r\ntmp = ptr + 1;\r\nif (strchr(arg, ':')) {\r\nsemantic_error("Group name is not supported yet.\n");\r\nreturn -ENOTSUP;\r\n}\r\nif (!check_event_name(arg)) {\r\nsemantic_error("%s is bad for event name -it must "\r\n"follow C symbol-naming rule.\n", arg);\r\nreturn -EINVAL;\r\n}\r\npev->event = strdup(arg);\r\nif (pev->event == NULL)\r\nreturn -ENOMEM;\r\npev->group = NULL;\r\narg = tmp;\r\n}\r\nptr = strpbrk(arg, ";:+@%");\r\nif (ptr) {\r\nnc = *ptr;\r\n*ptr++ = '\0';\r\n}\r\ntmp = strdup(arg);\r\nif (tmp == NULL)\r\nreturn -ENOMEM;\r\nif (strchr(tmp, '.'))\r\npp->file = tmp;\r\nelse\r\npp->function = tmp;\r\nwhile (ptr) {\r\narg = ptr;\r\nc = nc;\r\nif (c == ';') {\r\npp->lazy_line = strdup(arg);\r\nif (pp->lazy_line == NULL)\r\nreturn -ENOMEM;\r\nbreak;\r\n}\r\nptr = strpbrk(arg, ";:+@%");\r\nif (ptr) {\r\nnc = *ptr;\r\n*ptr++ = '\0';\r\n}\r\nswitch (c) {\r\ncase ':':\r\npp->line = strtoul(arg, &tmp, 0);\r\nif (*tmp != '\0') {\r\nsemantic_error("There is non-digit char"\r\n" in line number.\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase '+':\r\npp->offset = strtoul(arg, &tmp, 0);\r\nif (*tmp != '\0') {\r\nsemantic_error("There is non-digit character"\r\n" in offset.\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase '@':\r\nif (pp->file) {\r\nsemantic_error("SRC@SRC is not allowed.\n");\r\nreturn -EINVAL;\r\n}\r\npp->file = strdup(arg);\r\nif (pp->file == NULL)\r\nreturn -ENOMEM;\r\nbreak;\r\ncase '%':\r\nif (strcmp(arg, "return") == 0) {\r\npp->retprobe = 1;\r\n} else {\r\nsemantic_error("%%%s is not supported.\n", arg);\r\nreturn -ENOTSUP;\r\n}\r\nbreak;\r\ndefault:\r\npr_err("This program has a bug at %s:%d.\n",\r\n__FILE__, __LINE__);\r\nreturn -ENOTSUP;\r\nbreak;\r\n}\r\n}\r\nif (pp->lazy_line && pp->line) {\r\nsemantic_error("Lazy pattern can't be used with"\r\n" line number.\n");\r\nreturn -EINVAL;\r\n}\r\nif (pp->lazy_line && pp->offset) {\r\nsemantic_error("Lazy pattern can't be used with offset.\n");\r\nreturn -EINVAL;\r\n}\r\nif (pp->line && pp->offset) {\r\nsemantic_error("Offset can't be used with line number.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pp->line && !pp->lazy_line && pp->file && !pp->function) {\r\nsemantic_error("File always requires line number or "\r\n"lazy pattern.\n");\r\nreturn -EINVAL;\r\n}\r\nif (pp->offset && !pp->function) {\r\nsemantic_error("Offset requires an entry function.\n");\r\nreturn -EINVAL;\r\n}\r\nif (pp->retprobe && !pp->function) {\r\nsemantic_error("Return probe requires an entry function.\n");\r\nreturn -EINVAL;\r\n}\r\nif ((pp->offset || pp->line || pp->lazy_line) && pp->retprobe) {\r\nsemantic_error("Offset/Line/Lazy pattern can't be used with "\r\n"return probe.\n");\r\nreturn -EINVAL;\r\n}\r\npr_debug("symbol:%s file:%s line:%d offset:%lu return:%d lazy:%s\n",\r\npp->function, pp->file, pp->line, pp->offset, pp->retprobe,\r\npp->lazy_line);\r\nreturn 0;\r\n}\r\nstatic int parse_perf_probe_arg(char *str, struct perf_probe_arg *arg)\r\n{\r\nchar *tmp, *goodname;\r\nstruct perf_probe_arg_field **fieldp;\r\npr_debug("parsing arg: %s into ", str);\r\ntmp = strchr(str, '=');\r\nif (tmp) {\r\narg->name = strndup(str, tmp - str);\r\nif (arg->name == NULL)\r\nreturn -ENOMEM;\r\npr_debug("name:%s ", arg->name);\r\nstr = tmp + 1;\r\n}\r\ntmp = strchr(str, ':');\r\nif (tmp) {\r\n*tmp = '\0';\r\narg->type = strdup(tmp + 1);\r\nif (arg->type == NULL)\r\nreturn -ENOMEM;\r\npr_debug("type:%s ", arg->type);\r\n}\r\ntmp = strpbrk(str, "-.[");\r\nif (!is_c_varname(str) || !tmp) {\r\narg->var = strdup(str);\r\nif (arg->var == NULL)\r\nreturn -ENOMEM;\r\npr_debug("%s\n", arg->var);\r\nreturn 0;\r\n}\r\narg->var = strndup(str, tmp - str);\r\nif (arg->var == NULL)\r\nreturn -ENOMEM;\r\ngoodname = arg->var;\r\npr_debug("%s, ", arg->var);\r\nfieldp = &arg->field;\r\ndo {\r\n*fieldp = zalloc(sizeof(struct perf_probe_arg_field));\r\nif (*fieldp == NULL)\r\nreturn -ENOMEM;\r\nif (*tmp == '[') {\r\nstr = tmp;\r\n(*fieldp)->index = strtol(str + 1, &tmp, 0);\r\n(*fieldp)->ref = true;\r\nif (*tmp != ']' || tmp == str + 1) {\r\nsemantic_error("Array index must be a"\r\n" number.\n");\r\nreturn -EINVAL;\r\n}\r\ntmp++;\r\nif (*tmp == '\0')\r\ntmp = NULL;\r\n} else {\r\nif (*tmp == '.') {\r\nstr = tmp + 1;\r\n(*fieldp)->ref = false;\r\n} else if (tmp[1] == '>') {\r\nstr = tmp + 2;\r\n(*fieldp)->ref = true;\r\n} else {\r\nsemantic_error("Argument parse error: %s\n",\r\nstr);\r\nreturn -EINVAL;\r\n}\r\ntmp = strpbrk(str, "-.[");\r\n}\r\nif (tmp) {\r\n(*fieldp)->name = strndup(str, tmp - str);\r\nif ((*fieldp)->name == NULL)\r\nreturn -ENOMEM;\r\nif (*str != '[')\r\ngoodname = (*fieldp)->name;\r\npr_debug("%s(%d), ", (*fieldp)->name, (*fieldp)->ref);\r\nfieldp = &(*fieldp)->next;\r\n}\r\n} while (tmp);\r\n(*fieldp)->name = strdup(str);\r\nif ((*fieldp)->name == NULL)\r\nreturn -ENOMEM;\r\nif (*str != '[')\r\ngoodname = (*fieldp)->name;\r\npr_debug("%s(%d)\n", (*fieldp)->name, (*fieldp)->ref);\r\nif (!arg->name) {\r\narg->name = strdup(goodname);\r\nif (arg->name == NULL)\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nint parse_perf_probe_command(const char *cmd, struct perf_probe_event *pev)\r\n{\r\nchar **argv;\r\nint argc, i, ret = 0;\r\nargv = argv_split(cmd, &argc);\r\nif (!argv) {\r\npr_debug("Failed to split arguments.\n");\r\nreturn -ENOMEM;\r\n}\r\nif (argc - 1 > MAX_PROBE_ARGS) {\r\nsemantic_error("Too many probe arguments (%d).\n", argc - 1);\r\nret = -ERANGE;\r\ngoto out;\r\n}\r\nret = parse_perf_probe_point(argv[0], pev);\r\nif (ret < 0)\r\ngoto out;\r\npev->nargs = argc - 1;\r\npev->args = zalloc(sizeof(struct perf_probe_arg) * pev->nargs);\r\nif (pev->args == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < pev->nargs && ret >= 0; i++) {\r\nret = parse_perf_probe_arg(argv[i + 1], &pev->args[i]);\r\nif (ret >= 0 &&\r\nis_c_varname(pev->args[i].var) && pev->point.retprobe) {\r\nsemantic_error("You can't specify local variable for"\r\n" kretprobe.\n");\r\nret = -EINVAL;\r\n}\r\n}\r\nout:\r\nargv_free(argv);\r\nreturn ret;\r\n}\r\nbool perf_probe_event_need_dwarf(struct perf_probe_event *pev)\r\n{\r\nint i;\r\nif (pev->point.file || pev->point.line || pev->point.lazy_line)\r\nreturn true;\r\nfor (i = 0; i < pev->nargs; i++)\r\nif (is_c_varname(pev->args[i].var))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int parse_probe_trace_command(const char *cmd,\r\nstruct probe_trace_event *tev)\r\n{\r\nstruct probe_trace_point *tp = &tev->point;\r\nchar pr;\r\nchar *p;\r\nchar *argv0_str = NULL, *fmt, *fmt1_str, *fmt2_str, *fmt3_str;\r\nint ret, i, argc;\r\nchar **argv;\r\npr_debug("Parsing probe_events: %s\n", cmd);\r\nargv = argv_split(cmd, &argc);\r\nif (!argv) {\r\npr_debug("Failed to split arguments.\n");\r\nreturn -ENOMEM;\r\n}\r\nif (argc < 2) {\r\nsemantic_error("Too few probe arguments.\n");\r\nret = -ERANGE;\r\ngoto out;\r\n}\r\nargv0_str = strdup(argv[0]);\r\nif (argv0_str == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfmt1_str = strtok_r(argv0_str, ":", &fmt);\r\nfmt2_str = strtok_r(NULL, "/", &fmt);\r\nfmt3_str = strtok_r(NULL, " \t", &fmt);\r\nif (fmt1_str == NULL || strlen(fmt1_str) != 1 || fmt2_str == NULL\r\n|| fmt3_str == NULL) {\r\nsemantic_error("Failed to parse event name: %s\n", argv[0]);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\npr = fmt1_str[0];\r\ntev->group = strdup(fmt2_str);\r\ntev->event = strdup(fmt3_str);\r\nif (tev->group == NULL || tev->event == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\npr_debug("Group:%s Event:%s probe:%c\n", tev->group, tev->event, pr);\r\ntp->retprobe = (pr == 'r');\r\np = strchr(argv[1], ':');\r\nif (p) {\r\ntp->module = strndup(argv[1], p - argv[1]);\r\np++;\r\n} else\r\np = argv[1];\r\nfmt1_str = strtok_r(p, "+", &fmt);\r\nif (fmt1_str[0] == '0')\r\ntp->address = strtoul(fmt1_str, NULL, 0);\r\nelse {\r\ntp->symbol = strdup(fmt1_str);\r\nif (tp->symbol == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfmt2_str = strtok_r(NULL, "", &fmt);\r\nif (fmt2_str == NULL)\r\ntp->offset = 0;\r\nelse\r\ntp->offset = strtoul(fmt2_str, NULL, 10);\r\n}\r\ntev->nargs = argc - 2;\r\ntev->args = zalloc(sizeof(struct probe_trace_arg) * tev->nargs);\r\nif (tev->args == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < tev->nargs; i++) {\r\np = strchr(argv[i + 2], '=');\r\nif (p)\r\n*p++ = '\0';\r\nelse\r\np = argv[i + 2];\r\ntev->args[i].name = strdup(argv[i + 2]);\r\ntev->args[i].value = strdup(p);\r\nif (tev->args[i].name == NULL || tev->args[i].value == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\nret = 0;\r\nout:\r\nfree(argv0_str);\r\nargv_free(argv);\r\nreturn ret;\r\n}\r\nint synthesize_perf_probe_arg(struct perf_probe_arg *pa, char *buf, size_t len)\r\n{\r\nstruct perf_probe_arg_field *field = pa->field;\r\nint ret;\r\nchar *tmp = buf;\r\nif (pa->name && pa->var)\r\nret = e_snprintf(tmp, len, "%s=%s", pa->name, pa->var);\r\nelse\r\nret = e_snprintf(tmp, len, "%s", pa->name ? pa->name : pa->var);\r\nif (ret <= 0)\r\ngoto error;\r\ntmp += ret;\r\nlen -= ret;\r\nwhile (field) {\r\nif (field->name[0] == '[')\r\nret = e_snprintf(tmp, len, "%s", field->name);\r\nelse\r\nret = e_snprintf(tmp, len, "%s%s",\r\nfield->ref ? "->" : ".", field->name);\r\nif (ret <= 0)\r\ngoto error;\r\ntmp += ret;\r\nlen -= ret;\r\nfield = field->next;\r\n}\r\nif (pa->type) {\r\nret = e_snprintf(tmp, len, ":%s", pa->type);\r\nif (ret <= 0)\r\ngoto error;\r\ntmp += ret;\r\nlen -= ret;\r\n}\r\nreturn tmp - buf;\r\nerror:\r\npr_debug("Failed to synthesize perf probe argument: %s\n",\r\nstrerror(-ret));\r\nreturn ret;\r\n}\r\nstatic char *synthesize_perf_probe_point(struct perf_probe_point *pp)\r\n{\r\nchar *buf, *tmp;\r\nchar offs[32] = "", line[32] = "", file[32] = "";\r\nint ret, len;\r\nbuf = zalloc(MAX_CMDLEN);\r\nif (buf == NULL) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nif (pp->offset) {\r\nret = e_snprintf(offs, 32, "+%lu", pp->offset);\r\nif (ret <= 0)\r\ngoto error;\r\n}\r\nif (pp->line) {\r\nret = e_snprintf(line, 32, ":%d", pp->line);\r\nif (ret <= 0)\r\ngoto error;\r\n}\r\nif (pp->file) {\r\ntmp = pp->file;\r\nlen = strlen(tmp);\r\nif (len > 30) {\r\ntmp = strchr(pp->file + len - 30, '/');\r\ntmp = tmp ? tmp + 1 : pp->file + len - 30;\r\n}\r\nret = e_snprintf(file, 32, "@%s", tmp);\r\nif (ret <= 0)\r\ngoto error;\r\n}\r\nif (pp->function)\r\nret = e_snprintf(buf, MAX_CMDLEN, "%s%s%s%s%s", pp->function,\r\noffs, pp->retprobe ? "%return" : "", line,\r\nfile);\r\nelse\r\nret = e_snprintf(buf, MAX_CMDLEN, "%s%s", file, line);\r\nif (ret <= 0)\r\ngoto error;\r\nreturn buf;\r\nerror:\r\npr_debug("Failed to synthesize perf probe point: %s\n",\r\nstrerror(-ret));\r\nfree(buf);\r\nreturn NULL;\r\n}\r\nstatic int __synthesize_probe_trace_arg_ref(struct probe_trace_arg_ref *ref,\r\nchar **buf, size_t *buflen,\r\nint depth)\r\n{\r\nint ret;\r\nif (ref->next) {\r\ndepth = __synthesize_probe_trace_arg_ref(ref->next, buf,\r\nbuflen, depth + 1);\r\nif (depth < 0)\r\ngoto out;\r\n}\r\nret = e_snprintf(*buf, *buflen, "%+ld(", ref->offset);\r\nif (ret < 0)\r\ndepth = ret;\r\nelse {\r\n*buf += ret;\r\n*buflen -= ret;\r\n}\r\nout:\r\nreturn depth;\r\n}\r\nstatic int synthesize_probe_trace_arg(struct probe_trace_arg *arg,\r\nchar *buf, size_t buflen)\r\n{\r\nstruct probe_trace_arg_ref *ref = arg->ref;\r\nint ret, depth = 0;\r\nchar *tmp = buf;\r\nif (arg->name)\r\nret = e_snprintf(buf, buflen, " %s=", arg->name);\r\nelse\r\nret = e_snprintf(buf, buflen, " ");\r\nif (ret < 0)\r\nreturn ret;\r\nbuf += ret;\r\nbuflen -= ret;\r\nif (arg->value[0] == '@' && arg->ref)\r\nref = ref->next;\r\nif (ref) {\r\ndepth = __synthesize_probe_trace_arg_ref(ref, &buf,\r\n&buflen, 1);\r\nif (depth < 0)\r\nreturn depth;\r\n}\r\nif (arg->value[0] == '@' && arg->ref)\r\nret = e_snprintf(buf, buflen, "%s%+ld", arg->value,\r\narg->ref->offset);\r\nelse\r\nret = e_snprintf(buf, buflen, "%s", arg->value);\r\nif (ret < 0)\r\nreturn ret;\r\nbuf += ret;\r\nbuflen -= ret;\r\nwhile (depth--) {\r\nret = e_snprintf(buf, buflen, ")");\r\nif (ret < 0)\r\nreturn ret;\r\nbuf += ret;\r\nbuflen -= ret;\r\n}\r\nif (arg->type) {\r\nret = e_snprintf(buf, buflen, ":%s", arg->type);\r\nif (ret <= 0)\r\nreturn ret;\r\nbuf += ret;\r\n}\r\nreturn buf - tmp;\r\n}\r\nchar *synthesize_probe_trace_command(struct probe_trace_event *tev)\r\n{\r\nstruct probe_trace_point *tp = &tev->point;\r\nchar *buf;\r\nint i, len, ret;\r\nbuf = zalloc(MAX_CMDLEN);\r\nif (buf == NULL)\r\nreturn NULL;\r\nlen = e_snprintf(buf, MAX_CMDLEN, "%c:%s/%s ", tp->retprobe ? 'r' : 'p',\r\ntev->group, tev->event);\r\nif (len <= 0)\r\ngoto error;\r\nif (tev->uprobes && (!tp->address || !tp->module))\r\ngoto error;\r\nif (tev->uprobes)\r\nret = e_snprintf(buf + len, MAX_CMDLEN - len, "%s:0x%lx",\r\ntp->module, tp->address);\r\nelse\r\nret = e_snprintf(buf + len, MAX_CMDLEN - len, "%s%s%s+%lu",\r\ntp->module ?: "", tp->module ? ":" : "",\r\ntp->symbol, tp->offset);\r\nif (ret <= 0)\r\ngoto error;\r\nlen += ret;\r\nfor (i = 0; i < tev->nargs; i++) {\r\nret = synthesize_probe_trace_arg(&tev->args[i], buf + len,\r\nMAX_CMDLEN - len);\r\nif (ret <= 0)\r\ngoto error;\r\nlen += ret;\r\n}\r\nreturn buf;\r\nerror:\r\nfree(buf);\r\nreturn NULL;\r\n}\r\nstatic int find_perf_probe_point_from_map(struct probe_trace_point *tp,\r\nstruct perf_probe_point *pp,\r\nbool is_kprobe)\r\n{\r\nstruct symbol *sym = NULL;\r\nstruct map *map;\r\nu64 addr;\r\nint ret = -ENOENT;\r\nif (!is_kprobe) {\r\nmap = dso__new_map(tp->module);\r\nif (!map)\r\ngoto out;\r\naddr = tp->address;\r\nsym = map__find_symbol(map, addr, NULL);\r\n} else {\r\naddr = kernel_get_symbol_address_by_name(tp->symbol, true);\r\nif (addr) {\r\naddr += tp->offset;\r\nsym = __find_kernel_function(addr, &map);\r\n}\r\n}\r\nif (!sym)\r\ngoto out;\r\npp->retprobe = tp->retprobe;\r\npp->offset = addr - map->unmap_ip(map, sym->start);\r\npp->function = strdup(sym->name);\r\nret = pp->function ? 0 : -ENOMEM;\r\nout:\r\nif (map && !is_kprobe) {\r\ndso__delete(map->dso);\r\nmap__delete(map);\r\n}\r\nreturn ret;\r\n}\r\nstatic int convert_to_perf_probe_point(struct probe_trace_point *tp,\r\nstruct perf_probe_point *pp,\r\nbool is_kprobe)\r\n{\r\nchar buf[128];\r\nint ret;\r\nret = find_perf_probe_point_from_dwarf(tp, pp, is_kprobe);\r\nif (!ret)\r\nreturn 0;\r\nret = find_perf_probe_point_from_map(tp, pp, is_kprobe);\r\nif (!ret)\r\nreturn 0;\r\npr_debug("Failed to find probe point from both of dwarf and map.\n");\r\nif (tp->symbol) {\r\npp->function = strdup(tp->symbol);\r\npp->offset = tp->offset;\r\n} else if (!tp->module && !is_kprobe) {\r\nret = e_snprintf(buf, 128, "0x%" PRIx64, (u64)tp->address);\r\nif (ret < 0)\r\nreturn ret;\r\npp->function = strdup(buf);\r\npp->offset = 0;\r\n}\r\nif (pp->function == NULL)\r\nreturn -ENOMEM;\r\npp->retprobe = tp->retprobe;\r\nreturn 0;\r\n}\r\nstatic int convert_to_perf_probe_event(struct probe_trace_event *tev,\r\nstruct perf_probe_event *pev, bool is_kprobe)\r\n{\r\nchar buf[64] = "";\r\nint i, ret;\r\npev->event = strdup(tev->event);\r\npev->group = strdup(tev->group);\r\nif (pev->event == NULL || pev->group == NULL)\r\nreturn -ENOMEM;\r\nret = convert_to_perf_probe_point(&tev->point, &pev->point, is_kprobe);\r\nif (ret < 0)\r\nreturn ret;\r\npev->nargs = tev->nargs;\r\npev->args = zalloc(sizeof(struct perf_probe_arg) * pev->nargs);\r\nif (pev->args == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < tev->nargs && ret >= 0; i++) {\r\nif (tev->args[i].name)\r\npev->args[i].name = strdup(tev->args[i].name);\r\nelse {\r\nret = synthesize_probe_trace_arg(&tev->args[i],\r\nbuf, 64);\r\npev->args[i].name = strdup(buf);\r\n}\r\nif (pev->args[i].name == NULL && ret >= 0)\r\nret = -ENOMEM;\r\n}\r\nif (ret < 0)\r\nclear_perf_probe_event(pev);\r\nreturn ret;\r\n}\r\nvoid clear_perf_probe_event(struct perf_probe_event *pev)\r\n{\r\nstruct perf_probe_point *pp = &pev->point;\r\nstruct perf_probe_arg_field *field, *next;\r\nint i;\r\nfree(pev->event);\r\nfree(pev->group);\r\nfree(pp->file);\r\nfree(pp->function);\r\nfree(pp->lazy_line);\r\nfor (i = 0; i < pev->nargs; i++) {\r\nfree(pev->args[i].name);\r\nfree(pev->args[i].var);\r\nfree(pev->args[i].type);\r\nfield = pev->args[i].field;\r\nwhile (field) {\r\nnext = field->next;\r\nzfree(&field->name);\r\nfree(field);\r\nfield = next;\r\n}\r\n}\r\nfree(pev->args);\r\nmemset(pev, 0, sizeof(*pev));\r\n}\r\nstatic void clear_probe_trace_event(struct probe_trace_event *tev)\r\n{\r\nstruct probe_trace_arg_ref *ref, *next;\r\nint i;\r\nfree(tev->event);\r\nfree(tev->group);\r\nfree(tev->point.symbol);\r\nfree(tev->point.module);\r\nfor (i = 0; i < tev->nargs; i++) {\r\nfree(tev->args[i].name);\r\nfree(tev->args[i].value);\r\nfree(tev->args[i].type);\r\nref = tev->args[i].ref;\r\nwhile (ref) {\r\nnext = ref->next;\r\nfree(ref);\r\nref = next;\r\n}\r\n}\r\nfree(tev->args);\r\nmemset(tev, 0, sizeof(*tev));\r\n}\r\nstatic void print_warn_msg(const char *file, bool is_kprobe)\r\n{\r\nif (errno == ENOENT) {\r\nconst char *config;\r\nif (!is_kprobe)\r\nconfig = "CONFIG_UPROBE_EVENTS";\r\nelse\r\nconfig = "CONFIG_KPROBE_EVENTS";\r\npr_warning("%s file does not exist - please rebuild kernel"\r\n" with %s.\n", file, config);\r\n} else\r\npr_warning("Failed to open %s file: %s\n", file,\r\nstrerror(errno));\r\n}\r\nstatic int open_probe_events(const char *trace_file, bool readwrite,\r\nbool is_kprobe)\r\n{\r\nchar buf[PATH_MAX];\r\nconst char *__debugfs;\r\nint ret;\r\n__debugfs = debugfs_find_mountpoint();\r\nif (__debugfs == NULL) {\r\npr_warning("Debugfs is not mounted.\n");\r\nreturn -ENOENT;\r\n}\r\nret = e_snprintf(buf, PATH_MAX, "%s/%s", __debugfs, trace_file);\r\nif (ret >= 0) {\r\npr_debug("Opening %s write=%d\n", buf, readwrite);\r\nif (readwrite && !probe_event_dry_run)\r\nret = open(buf, O_RDWR, O_APPEND);\r\nelse\r\nret = open(buf, O_RDONLY, 0);\r\nif (ret < 0)\r\nprint_warn_msg(buf, is_kprobe);\r\n}\r\nreturn ret;\r\n}\r\nstatic int open_kprobe_events(bool readwrite)\r\n{\r\nreturn open_probe_events("tracing/kprobe_events", readwrite, true);\r\n}\r\nstatic int open_uprobe_events(bool readwrite)\r\n{\r\nreturn open_probe_events("tracing/uprobe_events", readwrite, false);\r\n}\r\nstatic struct strlist *get_probe_trace_command_rawlist(int fd)\r\n{\r\nint ret, idx;\r\nFILE *fp;\r\nchar buf[MAX_CMDLEN];\r\nchar *p;\r\nstruct strlist *sl;\r\nsl = strlist__new(true, NULL);\r\nfp = fdopen(dup(fd), "r");\r\nwhile (!feof(fp)) {\r\np = fgets(buf, MAX_CMDLEN, fp);\r\nif (!p)\r\nbreak;\r\nidx = strlen(p) - 1;\r\nif (p[idx] == '\n')\r\np[idx] = '\0';\r\nret = strlist__add(sl, buf);\r\nif (ret < 0) {\r\npr_debug("strlist__add failed: %s\n", strerror(-ret));\r\nstrlist__delete(sl);\r\nreturn NULL;\r\n}\r\n}\r\nfclose(fp);\r\nreturn sl;\r\n}\r\nstatic int show_perf_probe_event(struct perf_probe_event *pev,\r\nconst char *module)\r\n{\r\nint i, ret;\r\nchar buf[128];\r\nchar *place;\r\nplace = synthesize_perf_probe_point(&pev->point);\r\nif (!place)\r\nreturn -EINVAL;\r\nret = e_snprintf(buf, 128, "%s:%s", pev->group, pev->event);\r\nif (ret < 0)\r\nreturn ret;\r\nprintf(" %-20s (on %s", buf, place);\r\nif (module)\r\nprintf(" in %s", module);\r\nif (pev->nargs > 0) {\r\nprintf(" with");\r\nfor (i = 0; i < pev->nargs; i++) {\r\nret = synthesize_perf_probe_arg(&pev->args[i],\r\nbuf, 128);\r\nif (ret < 0)\r\nbreak;\r\nprintf(" %s", buf);\r\n}\r\n}\r\nprintf(")\n");\r\nfree(place);\r\nreturn ret;\r\n}\r\nstatic int __show_perf_probe_events(int fd, bool is_kprobe)\r\n{\r\nint ret = 0;\r\nstruct probe_trace_event tev;\r\nstruct perf_probe_event pev;\r\nstruct strlist *rawlist;\r\nstruct str_node *ent;\r\nmemset(&tev, 0, sizeof(tev));\r\nmemset(&pev, 0, sizeof(pev));\r\nrawlist = get_probe_trace_command_rawlist(fd);\r\nif (!rawlist)\r\nreturn -ENOENT;\r\nstrlist__for_each(ent, rawlist) {\r\nret = parse_probe_trace_command(ent->s, &tev);\r\nif (ret >= 0) {\r\nret = convert_to_perf_probe_event(&tev, &pev,\r\nis_kprobe);\r\nif (ret >= 0)\r\nret = show_perf_probe_event(&pev,\r\ntev.point.module);\r\n}\r\nclear_perf_probe_event(&pev);\r\nclear_probe_trace_event(&tev);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nstrlist__delete(rawlist);\r\nreturn ret;\r\n}\r\nint show_perf_probe_events(void)\r\n{\r\nint fd, ret;\r\nsetup_pager();\r\nfd = open_kprobe_events(false);\r\nif (fd < 0)\r\nreturn fd;\r\nret = init_symbol_maps(false);\r\nif (ret < 0)\r\nreturn ret;\r\nret = __show_perf_probe_events(fd, true);\r\nclose(fd);\r\nfd = open_uprobe_events(false);\r\nif (fd >= 0) {\r\nret = __show_perf_probe_events(fd, false);\r\nclose(fd);\r\n}\r\nexit_symbol_maps();\r\nreturn ret;\r\n}\r\nstatic struct strlist *get_probe_trace_event_names(int fd, bool include_group)\r\n{\r\nchar buf[128];\r\nstruct strlist *sl, *rawlist;\r\nstruct str_node *ent;\r\nstruct probe_trace_event tev;\r\nint ret = 0;\r\nmemset(&tev, 0, sizeof(tev));\r\nrawlist = get_probe_trace_command_rawlist(fd);\r\nsl = strlist__new(true, NULL);\r\nstrlist__for_each(ent, rawlist) {\r\nret = parse_probe_trace_command(ent->s, &tev);\r\nif (ret < 0)\r\nbreak;\r\nif (include_group) {\r\nret = e_snprintf(buf, 128, "%s:%s", tev.group,\r\ntev.event);\r\nif (ret >= 0)\r\nret = strlist__add(sl, buf);\r\n} else\r\nret = strlist__add(sl, tev.event);\r\nclear_probe_trace_event(&tev);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nstrlist__delete(rawlist);\r\nif (ret < 0) {\r\nstrlist__delete(sl);\r\nreturn NULL;\r\n}\r\nreturn sl;\r\n}\r\nstatic int write_probe_trace_event(int fd, struct probe_trace_event *tev)\r\n{\r\nint ret = 0;\r\nchar *buf = synthesize_probe_trace_command(tev);\r\nif (!buf) {\r\npr_debug("Failed to synthesize probe trace event.\n");\r\nreturn -EINVAL;\r\n}\r\npr_debug("Writing event: %s\n", buf);\r\nif (!probe_event_dry_run) {\r\nret = write(fd, buf, strlen(buf));\r\nif (ret <= 0)\r\npr_warning("Failed to write event: %s\n",\r\nstrerror(errno));\r\n}\r\nfree(buf);\r\nreturn ret;\r\n}\r\nstatic int get_new_event_name(char *buf, size_t len, const char *base,\r\nstruct strlist *namelist, bool allow_suffix)\r\n{\r\nint i, ret;\r\nret = e_snprintf(buf, len, "%s", base);\r\nif (ret < 0) {\r\npr_debug("snprintf() failed: %s\n", strerror(-ret));\r\nreturn ret;\r\n}\r\nif (!strlist__has_entry(namelist, buf))\r\nreturn 0;\r\nif (!allow_suffix) {\r\npr_warning("Error: event \"%s\" already exists. "\r\n"(Use -f to force duplicates.)\n", base);\r\nreturn -EEXIST;\r\n}\r\nfor (i = 1; i < MAX_EVENT_INDEX; i++) {\r\nret = e_snprintf(buf, len, "%s_%d", base, i);\r\nif (ret < 0) {\r\npr_debug("snprintf() failed: %s\n", strerror(-ret));\r\nreturn ret;\r\n}\r\nif (!strlist__has_entry(namelist, buf))\r\nbreak;\r\n}\r\nif (i == MAX_EVENT_INDEX) {\r\npr_warning("Too many events are on the same function.\n");\r\nret = -ERANGE;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __add_probe_trace_events(struct perf_probe_event *pev,\r\nstruct probe_trace_event *tevs,\r\nint ntevs, bool allow_suffix)\r\n{\r\nint i, fd, ret;\r\nstruct probe_trace_event *tev = NULL;\r\nchar buf[64];\r\nconst char *event, *group;\r\nstruct strlist *namelist;\r\nif (pev->uprobes)\r\nfd = open_uprobe_events(true);\r\nelse\r\nfd = open_kprobe_events(true);\r\nif (fd < 0)\r\nreturn fd;\r\nnamelist = get_probe_trace_event_names(fd, false);\r\nif (!namelist) {\r\npr_debug("Failed to get current event list.\n");\r\nreturn -EIO;\r\n}\r\nret = 0;\r\nprintf("Added new event%s\n", (ntevs > 1) ? "s:" : ":");\r\nfor (i = 0; i < ntevs; i++) {\r\ntev = &tevs[i];\r\nif (pev->event)\r\nevent = pev->event;\r\nelse\r\nif (pev->point.function)\r\nevent = pev->point.function;\r\nelse\r\nevent = tev->point.symbol;\r\nif (pev->group)\r\ngroup = pev->group;\r\nelse\r\ngroup = PERFPROBE_GROUP;\r\nret = get_new_event_name(buf, 64, event,\r\nnamelist, allow_suffix);\r\nif (ret < 0)\r\nbreak;\r\nevent = buf;\r\ntev->event = strdup(event);\r\ntev->group = strdup(group);\r\nif (tev->event == NULL || tev->group == NULL) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nret = write_probe_trace_event(fd, tev);\r\nif (ret < 0)\r\nbreak;\r\nstrlist__add(namelist, event);\r\nevent = pev->event;\r\ngroup = pev->group;\r\npev->event = tev->event;\r\npev->group = tev->group;\r\nshow_perf_probe_event(pev, tev->point.module);\r\npev->event = (char *)event;\r\npev->group = (char *)group;\r\nallow_suffix = true;\r\n}\r\nif (ret >= 0) {\r\nprintf("\nYou can now use it in all perf tools, such as:\n\n");\r\nprintf("\tperf record -e %s:%s -aR sleep 1\n\n", tev->group,\r\ntev->event);\r\n}\r\nstrlist__delete(namelist);\r\nclose(fd);\r\nreturn ret;\r\n}\r\nstatic int probe_function_filter(struct map *map __maybe_unused,\r\nstruct symbol *sym)\r\n{\r\nif ((sym->binding == STB_GLOBAL || sym->binding == STB_LOCAL) &&\r\nstrcmp(looking_function_name, sym->name) == 0) {\r\nnum_matched_functions++;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int find_probe_trace_events_from_map(struct perf_probe_event *pev,\r\nstruct probe_trace_event **tevs,\r\nint max_tevs, const char *target)\r\n{\r\nstruct map *map = NULL;\r\nstruct kmap *kmap = NULL;\r\nstruct ref_reloc_sym *reloc_sym = NULL;\r\nstruct symbol *sym;\r\nstruct rb_node *nd;\r\nstruct probe_trace_event *tev;\r\nstruct perf_probe_point *pp = &pev->point;\r\nstruct probe_trace_point *tp;\r\nint ret, i;\r\nif (pev->uprobes)\r\nmap = dso__new_map(target);\r\nelse\r\nmap = kernel_get_module_map(target);\r\nif (!map) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nnum_matched_functions = 0;\r\nlooking_function_name = pp->function;\r\nret = map__load(map, probe_function_filter);\r\nif (ret || num_matched_functions == 0) {\r\npr_err("Failed to find symbol %s in %s\n", pp->function,\r\ntarget ? : "kernel");\r\nret = -ENOENT;\r\ngoto out;\r\n} else if (num_matched_functions > max_tevs) {\r\npr_err("Too many functions matched in %s\n",\r\ntarget ? : "kernel");\r\nret = -E2BIG;\r\ngoto out;\r\n}\r\nif (!pev->uprobes) {\r\nkmap = map__kmap(map);\r\nreloc_sym = kmap->ref_reloc_sym;\r\nif (!reloc_sym) {\r\npr_warning("Relocated base symbol is not found!\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\n*tevs = zalloc(sizeof(*tev) * num_matched_functions);\r\nif (!*tevs) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = 0;\r\nmap__for_each_symbol(map, sym, nd) {\r\ntev = (*tevs) + ret;\r\ntp = &tev->point;\r\nif (ret == num_matched_functions) {\r\npr_warning("Too many symbols are listed. Skip it.\n");\r\nbreak;\r\n}\r\nret++;\r\nif (pp->offset > sym->end - sym->start) {\r\npr_warning("Offset %ld is bigger than the size of %s\n",\r\npp->offset, sym->name);\r\nret = -ENOENT;\r\ngoto err_out;\r\n}\r\ntp->address = map->unmap_ip(map, sym->start) + pp->offset;\r\nif (reloc_sym) {\r\ntp->symbol = strdup_or_goto(reloc_sym->name, nomem_out);\r\ntp->offset = tp->address - reloc_sym->addr;\r\n} else {\r\ntp->symbol = strdup_or_goto(sym->name, nomem_out);\r\ntp->offset = pp->offset;\r\n}\r\ntp->retprobe = pp->retprobe;\r\nif (target)\r\ntev->point.module = strdup_or_goto(target, nomem_out);\r\ntev->uprobes = pev->uprobes;\r\ntev->nargs = pev->nargs;\r\nif (tev->nargs) {\r\ntev->args = zalloc(sizeof(struct probe_trace_arg) *\r\ntev->nargs);\r\nif (tev->args == NULL)\r\ngoto nomem_out;\r\n}\r\nfor (i = 0; i < tev->nargs; i++) {\r\nif (pev->args[i].name)\r\ntev->args[i].name =\r\nstrdup_or_goto(pev->args[i].name,\r\nnomem_out);\r\ntev->args[i].value = strdup_or_goto(pev->args[i].var,\r\nnomem_out);\r\nif (pev->args[i].type)\r\ntev->args[i].type =\r\nstrdup_or_goto(pev->args[i].type,\r\nnomem_out);\r\n}\r\n}\r\nout:\r\nif (map && pev->uprobes) {\r\ndso__delete(map->dso);\r\nmap__delete(map);\r\n}\r\nreturn ret;\r\nnomem_out:\r\nret = -ENOMEM;\r\nerr_out:\r\nclear_probe_trace_events(*tevs, num_matched_functions);\r\nzfree(tevs);\r\ngoto out;\r\n}\r\nstatic int convert_to_probe_trace_events(struct perf_probe_event *pev,\r\nstruct probe_trace_event **tevs,\r\nint max_tevs, const char *target)\r\n{\r\nint ret;\r\nif (pev->uprobes && !pev->group) {\r\nret = convert_exec_to_group(target, &pev->group);\r\nif (ret != 0) {\r\npr_warning("Failed to make a group name.\n");\r\nreturn ret;\r\n}\r\n}\r\nret = try_to_find_probe_trace_events(pev, tevs, max_tevs, target);\r\nif (ret != 0)\r\nreturn ret;\r\nreturn find_probe_trace_events_from_map(pev, tevs, max_tevs, target);\r\n}\r\nint add_perf_probe_events(struct perf_probe_event *pevs, int npevs,\r\nint max_tevs, const char *target, bool force_add)\r\n{\r\nint i, j, ret;\r\nstruct __event_package *pkgs;\r\nret = 0;\r\npkgs = zalloc(sizeof(struct __event_package) * npevs);\r\nif (pkgs == NULL)\r\nreturn -ENOMEM;\r\nret = init_symbol_maps(pevs->uprobes);\r\nif (ret < 0) {\r\nfree(pkgs);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < npevs; i++) {\r\npkgs[i].pev = &pevs[i];\r\nret = convert_to_probe_trace_events(pkgs[i].pev,\r\n&pkgs[i].tevs,\r\nmax_tevs,\r\ntarget);\r\nif (ret < 0)\r\ngoto end;\r\npkgs[i].ntevs = ret;\r\n}\r\nfor (i = 0; i < npevs; i++) {\r\nret = __add_probe_trace_events(pkgs[i].pev, pkgs[i].tevs,\r\npkgs[i].ntevs, force_add);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nend:\r\nfor (i = 0; i < npevs; i++) {\r\nfor (j = 0; j < pkgs[i].ntevs; j++)\r\nclear_probe_trace_event(&pkgs[i].tevs[j]);\r\nzfree(&pkgs[i].tevs);\r\n}\r\nfree(pkgs);\r\nexit_symbol_maps();\r\nreturn ret;\r\n}\r\nstatic int __del_trace_probe_event(int fd, struct str_node *ent)\r\n{\r\nchar *p;\r\nchar buf[128];\r\nint ret;\r\nret = e_snprintf(buf, 128, "-:%s", ent->s);\r\nif (ret < 0)\r\ngoto error;\r\np = strchr(buf + 2, ':');\r\nif (!p) {\r\npr_debug("Internal error: %s should have ':' but not.\n",\r\nent->s);\r\nret = -ENOTSUP;\r\ngoto error;\r\n}\r\n*p = '/';\r\npr_debug("Writing event: %s\n", buf);\r\nret = write(fd, buf, strlen(buf));\r\nif (ret < 0) {\r\nret = -errno;\r\ngoto error;\r\n}\r\nprintf("Removed event: %s\n", ent->s);\r\nreturn 0;\r\nerror:\r\npr_warning("Failed to delete event: %s\n", strerror(-ret));\r\nreturn ret;\r\n}\r\nstatic int del_trace_probe_event(int fd, const char *buf,\r\nstruct strlist *namelist)\r\n{\r\nstruct str_node *ent, *n;\r\nint ret = -1;\r\nif (strpbrk(buf, "*?")) {\r\nstrlist__for_each_safe(ent, n, namelist)\r\nif (strglobmatch(ent->s, buf)) {\r\nret = __del_trace_probe_event(fd, ent);\r\nif (ret < 0)\r\nbreak;\r\nstrlist__remove(namelist, ent);\r\n}\r\n} else {\r\nent = strlist__find(namelist, buf);\r\nif (ent) {\r\nret = __del_trace_probe_event(fd, ent);\r\nif (ret >= 0)\r\nstrlist__remove(namelist, ent);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint del_perf_probe_events(struct strlist *dellist)\r\n{\r\nint ret = -1, ufd = -1, kfd = -1;\r\nchar buf[128];\r\nconst char *group, *event;\r\nchar *p, *str;\r\nstruct str_node *ent;\r\nstruct strlist *namelist = NULL, *unamelist = NULL;\r\nkfd = open_kprobe_events(true);\r\nif (kfd < 0)\r\nreturn kfd;\r\nnamelist = get_probe_trace_event_names(kfd, true);\r\nufd = open_uprobe_events(true);\r\nif (ufd >= 0)\r\nunamelist = get_probe_trace_event_names(ufd, true);\r\nif (namelist == NULL && unamelist == NULL)\r\ngoto error;\r\nstrlist__for_each(ent, dellist) {\r\nstr = strdup(ent->s);\r\nif (str == NULL) {\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\npr_debug("Parsing: %s\n", str);\r\np = strchr(str, ':');\r\nif (p) {\r\ngroup = str;\r\n*p = '\0';\r\nevent = p + 1;\r\n} else {\r\ngroup = "*";\r\nevent = str;\r\n}\r\nret = e_snprintf(buf, 128, "%s:%s", group, event);\r\nif (ret < 0) {\r\npr_err("Failed to copy event.");\r\nfree(str);\r\ngoto error;\r\n}\r\npr_debug("Group: %s, Event: %s\n", group, event);\r\nif (namelist)\r\nret = del_trace_probe_event(kfd, buf, namelist);\r\nif (unamelist && ret != 0)\r\nret = del_trace_probe_event(ufd, buf, unamelist);\r\nif (ret != 0)\r\npr_info("Info: Event \"%s\" does not exist.\n", buf);\r\nfree(str);\r\n}\r\nerror:\r\nif (kfd >= 0) {\r\nstrlist__delete(namelist);\r\nclose(kfd);\r\n}\r\nif (ufd >= 0) {\r\nstrlist__delete(unamelist);\r\nclose(ufd);\r\n}\r\nreturn ret;\r\n}\r\nstatic int filter_available_functions(struct map *map __maybe_unused,\r\nstruct symbol *sym)\r\n{\r\nif ((sym->binding == STB_GLOBAL || sym->binding == STB_LOCAL) &&\r\nstrfilter__compare(available_func_filter, sym->name))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint show_available_funcs(const char *target, struct strfilter *_filter,\r\nbool user)\r\n{\r\nstruct map *map;\r\nint ret;\r\nret = init_symbol_maps(user);\r\nif (ret < 0)\r\nreturn ret;\r\nif (user)\r\nmap = dso__new_map(target);\r\nelse\r\nmap = kernel_get_module_map(target);\r\nif (!map) {\r\npr_err("Failed to get a map for %s\n", (target) ? : "kernel");\r\nreturn -EINVAL;\r\n}\r\navailable_func_filter = _filter;\r\nif (map__load(map, filter_available_functions)) {\r\npr_err("Failed to load symbols in %s\n", (target) ? : "kernel");\r\ngoto end;\r\n}\r\nif (!dso__sorted_by_name(map->dso, map->type))\r\ndso__sort_by_name(map->dso, map->type);\r\nsetup_pager();\r\ndso__fprintf_symbols_by_name(map->dso, map->type, stdout);\r\nend:\r\nif (user) {\r\ndso__delete(map->dso);\r\nmap__delete(map);\r\n}\r\nexit_symbol_maps();\r\nreturn ret;\r\n}
