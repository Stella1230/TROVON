static void ttc_set_interval(struct ttc_timer *timer,\r\nunsigned long cycles)\r\n{\r\nu32 ctrl_reg;\r\nctrl_reg = readl_relaxed(timer->base_addr + TTC_CNT_CNTRL_OFFSET);\r\nctrl_reg |= TTC_CNT_CNTRL_DISABLE_MASK;\r\nwritel_relaxed(ctrl_reg, timer->base_addr + TTC_CNT_CNTRL_OFFSET);\r\nwritel_relaxed(cycles, timer->base_addr + TTC_INTR_VAL_OFFSET);\r\nctrl_reg |= CNT_CNTRL_RESET;\r\nctrl_reg &= ~TTC_CNT_CNTRL_DISABLE_MASK;\r\nwritel_relaxed(ctrl_reg, timer->base_addr + TTC_CNT_CNTRL_OFFSET);\r\n}\r\nstatic irqreturn_t ttc_clock_event_interrupt(int irq, void *dev_id)\r\n{\r\nstruct ttc_timer_clockevent *ttce = dev_id;\r\nstruct ttc_timer *timer = &ttce->ttc;\r\nreadl_relaxed(timer->base_addr + TTC_ISR_OFFSET);\r\nttce->ce.event_handler(&ttce->ce);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic cycle_t __ttc_clocksource_read(struct clocksource *cs)\r\n{\r\nstruct ttc_timer *timer = &to_ttc_timer_clksrc(cs)->ttc;\r\nreturn (cycle_t)readl_relaxed(timer->base_addr +\r\nTTC_COUNT_VAL_OFFSET);\r\n}\r\nstatic u64 notrace ttc_sched_clock_read(void)\r\n{\r\nreturn readl_relaxed(ttc_sched_clock_val_reg);\r\n}\r\nstatic int ttc_set_next_event(unsigned long cycles,\r\nstruct clock_event_device *evt)\r\n{\r\nstruct ttc_timer_clockevent *ttce = to_ttc_timer_clkevent(evt);\r\nstruct ttc_timer *timer = &ttce->ttc;\r\nttc_set_interval(timer, cycles);\r\nreturn 0;\r\n}\r\nstatic void ttc_set_mode(enum clock_event_mode mode,\r\nstruct clock_event_device *evt)\r\n{\r\nstruct ttc_timer_clockevent *ttce = to_ttc_timer_clkevent(evt);\r\nstruct ttc_timer *timer = &ttce->ttc;\r\nu32 ctrl_reg;\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\nttc_set_interval(timer, DIV_ROUND_CLOSEST(ttce->ttc.freq,\r\nPRESCALE * HZ));\r\nbreak;\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\ncase CLOCK_EVT_MODE_UNUSED:\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\nctrl_reg = readl_relaxed(timer->base_addr +\r\nTTC_CNT_CNTRL_OFFSET);\r\nctrl_reg |= TTC_CNT_CNTRL_DISABLE_MASK;\r\nwritel_relaxed(ctrl_reg,\r\ntimer->base_addr + TTC_CNT_CNTRL_OFFSET);\r\nbreak;\r\ncase CLOCK_EVT_MODE_RESUME:\r\nctrl_reg = readl_relaxed(timer->base_addr +\r\nTTC_CNT_CNTRL_OFFSET);\r\nctrl_reg &= ~TTC_CNT_CNTRL_DISABLE_MASK;\r\nwritel_relaxed(ctrl_reg,\r\ntimer->base_addr + TTC_CNT_CNTRL_OFFSET);\r\nbreak;\r\n}\r\n}\r\nstatic int ttc_rate_change_clocksource_cb(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct clk_notifier_data *ndata = data;\r\nstruct ttc_timer *ttc = to_ttc_timer(nb);\r\nstruct ttc_timer_clocksource *ttccs = container_of(ttc,\r\nstruct ttc_timer_clocksource, ttc);\r\nswitch (event) {\r\ncase PRE_RATE_CHANGE:\r\n{\r\nu32 psv;\r\nunsigned long factor, rate_low, rate_high;\r\nif (ndata->new_rate > ndata->old_rate) {\r\nfactor = DIV_ROUND_CLOSEST(ndata->new_rate,\r\nndata->old_rate);\r\nrate_low = ndata->old_rate;\r\nrate_high = ndata->new_rate;\r\n} else {\r\nfactor = DIV_ROUND_CLOSEST(ndata->old_rate,\r\nndata->new_rate);\r\nrate_low = ndata->new_rate;\r\nrate_high = ndata->old_rate;\r\n}\r\nif (!is_power_of_2(factor))\r\nreturn NOTIFY_BAD;\r\nif (abs(rate_high - (factor * rate_low)) > MAX_F_ERR)\r\nreturn NOTIFY_BAD;\r\nfactor = __ilog2_u32(factor);\r\nttccs->scale_clk_ctrl_reg_old =\r\nreadl_relaxed(ttccs->ttc.base_addr +\r\nTTC_CLK_CNTRL_OFFSET);\r\npsv = (ttccs->scale_clk_ctrl_reg_old &\r\nTTC_CLK_CNTRL_PSV_MASK) >>\r\nTTC_CLK_CNTRL_PSV_SHIFT;\r\nif (ndata->new_rate < ndata->old_rate)\r\npsv -= factor;\r\nelse\r\npsv += factor;\r\nif (psv & ~(TTC_CLK_CNTRL_PSV_MASK >> TTC_CLK_CNTRL_PSV_SHIFT))\r\nreturn NOTIFY_BAD;\r\nttccs->scale_clk_ctrl_reg_new = ttccs->scale_clk_ctrl_reg_old &\r\n~TTC_CLK_CNTRL_PSV_MASK;\r\nttccs->scale_clk_ctrl_reg_new |= psv << TTC_CLK_CNTRL_PSV_SHIFT;\r\nif (ndata->new_rate < ndata->old_rate)\r\nreturn NOTIFY_DONE;\r\nwritel_relaxed(ttccs->scale_clk_ctrl_reg_new,\r\nttccs->ttc.base_addr + TTC_CLK_CNTRL_OFFSET);\r\nbreak;\r\n}\r\ncase POST_RATE_CHANGE:\r\nif (ndata->new_rate > ndata->old_rate)\r\nreturn NOTIFY_OK;\r\nwritel_relaxed(ttccs->scale_clk_ctrl_reg_new,\r\nttccs->ttc.base_addr + TTC_CLK_CNTRL_OFFSET);\r\nbreak;\r\ncase ABORT_RATE_CHANGE:\r\nif (ndata->new_rate < ndata->old_rate)\r\nreturn NOTIFY_OK;\r\nwritel_relaxed(ttccs->scale_clk_ctrl_reg_old,\r\nttccs->ttc.base_addr + TTC_CLK_CNTRL_OFFSET);\r\ndefault:\r\nreturn NOTIFY_DONE;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void __init ttc_setup_clocksource(struct clk *clk, void __iomem *base)\r\n{\r\nstruct ttc_timer_clocksource *ttccs;\r\nint err;\r\nttccs = kzalloc(sizeof(*ttccs), GFP_KERNEL);\r\nif (WARN_ON(!ttccs))\r\nreturn;\r\nttccs->ttc.clk = clk;\r\nerr = clk_prepare_enable(ttccs->ttc.clk);\r\nif (WARN_ON(err)) {\r\nkfree(ttccs);\r\nreturn;\r\n}\r\nttccs->ttc.freq = clk_get_rate(ttccs->ttc.clk);\r\nttccs->ttc.clk_rate_change_nb.notifier_call =\r\nttc_rate_change_clocksource_cb;\r\nttccs->ttc.clk_rate_change_nb.next = NULL;\r\nif (clk_notifier_register(ttccs->ttc.clk,\r\n&ttccs->ttc.clk_rate_change_nb))\r\npr_warn("Unable to register clock notifier.\n");\r\nttccs->ttc.base_addr = base;\r\nttccs->cs.name = "ttc_clocksource";\r\nttccs->cs.rating = 200;\r\nttccs->cs.read = __ttc_clocksource_read;\r\nttccs->cs.mask = CLOCKSOURCE_MASK(16);\r\nttccs->cs.flags = CLOCK_SOURCE_IS_CONTINUOUS;\r\nwritel_relaxed(0x0, ttccs->ttc.base_addr + TTC_IER_OFFSET);\r\nwritel_relaxed(CLK_CNTRL_PRESCALE | CLK_CNTRL_PRESCALE_EN,\r\nttccs->ttc.base_addr + TTC_CLK_CNTRL_OFFSET);\r\nwritel_relaxed(CNT_CNTRL_RESET,\r\nttccs->ttc.base_addr + TTC_CNT_CNTRL_OFFSET);\r\nerr = clocksource_register_hz(&ttccs->cs, ttccs->ttc.freq / PRESCALE);\r\nif (WARN_ON(err)) {\r\nkfree(ttccs);\r\nreturn;\r\n}\r\nttc_sched_clock_val_reg = base + TTC_COUNT_VAL_OFFSET;\r\nsched_clock_register(ttc_sched_clock_read, 16, ttccs->ttc.freq / PRESCALE);\r\n}\r\nstatic int ttc_rate_change_clockevent_cb(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct clk_notifier_data *ndata = data;\r\nstruct ttc_timer *ttc = to_ttc_timer(nb);\r\nstruct ttc_timer_clockevent *ttcce = container_of(ttc,\r\nstruct ttc_timer_clockevent, ttc);\r\nswitch (event) {\r\ncase POST_RATE_CHANGE:\r\nttc->freq = ndata->new_rate;\r\nclockevents_update_freq(&ttcce->ce, ndata->new_rate / PRESCALE);\r\ncase PRE_RATE_CHANGE:\r\ncase ABORT_RATE_CHANGE:\r\ndefault:\r\nreturn NOTIFY_DONE;\r\n}\r\n}\r\nstatic void __init ttc_setup_clockevent(struct clk *clk,\r\nvoid __iomem *base, u32 irq)\r\n{\r\nstruct ttc_timer_clockevent *ttcce;\r\nint err;\r\nttcce = kzalloc(sizeof(*ttcce), GFP_KERNEL);\r\nif (WARN_ON(!ttcce))\r\nreturn;\r\nttcce->ttc.clk = clk;\r\nerr = clk_prepare_enable(ttcce->ttc.clk);\r\nif (WARN_ON(err)) {\r\nkfree(ttcce);\r\nreturn;\r\n}\r\nttcce->ttc.clk_rate_change_nb.notifier_call =\r\nttc_rate_change_clockevent_cb;\r\nttcce->ttc.clk_rate_change_nb.next = NULL;\r\nif (clk_notifier_register(ttcce->ttc.clk,\r\n&ttcce->ttc.clk_rate_change_nb))\r\npr_warn("Unable to register clock notifier.\n");\r\nttcce->ttc.freq = clk_get_rate(ttcce->ttc.clk);\r\nttcce->ttc.base_addr = base;\r\nttcce->ce.name = "ttc_clockevent";\r\nttcce->ce.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;\r\nttcce->ce.set_next_event = ttc_set_next_event;\r\nttcce->ce.set_mode = ttc_set_mode;\r\nttcce->ce.rating = 200;\r\nttcce->ce.irq = irq;\r\nttcce->ce.cpumask = cpu_possible_mask;\r\nwritel_relaxed(0x23, ttcce->ttc.base_addr + TTC_CNT_CNTRL_OFFSET);\r\nwritel_relaxed(CLK_CNTRL_PRESCALE | CLK_CNTRL_PRESCALE_EN,\r\nttcce->ttc.base_addr + TTC_CLK_CNTRL_OFFSET);\r\nwritel_relaxed(0x1, ttcce->ttc.base_addr + TTC_IER_OFFSET);\r\nerr = request_irq(irq, ttc_clock_event_interrupt,\r\nIRQF_TIMER, ttcce->ce.name, ttcce);\r\nif (WARN_ON(err)) {\r\nkfree(ttcce);\r\nreturn;\r\n}\r\nclockevents_config_and_register(&ttcce->ce,\r\nttcce->ttc.freq / PRESCALE, 1, 0xfffe);\r\n}\r\nstatic void __init ttc_timer_init(struct device_node *timer)\r\n{\r\nunsigned int irq;\r\nvoid __iomem *timer_baseaddr;\r\nstruct clk *clk_cs, *clk_ce;\r\nstatic int initialized;\r\nint clksel;\r\nif (initialized)\r\nreturn;\r\ninitialized = 1;\r\ntimer_baseaddr = of_iomap(timer, 0);\r\nif (!timer_baseaddr) {\r\npr_err("ERROR: invalid timer base address\n");\r\nBUG();\r\n}\r\nirq = irq_of_parse_and_map(timer, 1);\r\nif (irq <= 0) {\r\npr_err("ERROR: invalid interrupt number\n");\r\nBUG();\r\n}\r\nclksel = readl_relaxed(timer_baseaddr + TTC_CLK_CNTRL_OFFSET);\r\nclksel = !!(clksel & TTC_CLK_CNTRL_CSRC_MASK);\r\nclk_cs = of_clk_get(timer, clksel);\r\nif (IS_ERR(clk_cs)) {\r\npr_err("ERROR: timer input clock not found\n");\r\nBUG();\r\n}\r\nclksel = readl_relaxed(timer_baseaddr + 4 + TTC_CLK_CNTRL_OFFSET);\r\nclksel = !!(clksel & TTC_CLK_CNTRL_CSRC_MASK);\r\nclk_ce = of_clk_get(timer, clksel);\r\nif (IS_ERR(clk_ce)) {\r\npr_err("ERROR: timer input clock not found\n");\r\nBUG();\r\n}\r\nttc_setup_clocksource(clk_cs, timer_baseaddr);\r\nttc_setup_clockevent(clk_ce, timer_baseaddr + 4, irq);\r\npr_info("%s #0 at %p, irq=%d\n", timer->name, timer_baseaddr, irq);\r\n}
