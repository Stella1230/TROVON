int ipoib_mcast_attach(struct net_device *dev, u16 mlid, union ib_gid *mgid, int set_qkey)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ib_qp_attr *qp_attr = NULL;\r\nint ret;\r\nu16 pkey_index;\r\nif (ib_find_pkey(priv->ca, priv->port, priv->pkey, &pkey_index)) {\r\nclear_bit(IPOIB_PKEY_ASSIGNED, &priv->flags);\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nset_bit(IPOIB_PKEY_ASSIGNED, &priv->flags);\r\nif (set_qkey) {\r\nret = -ENOMEM;\r\nqp_attr = kmalloc(sizeof *qp_attr, GFP_KERNEL);\r\nif (!qp_attr)\r\ngoto out;\r\nqp_attr->qkey = priv->qkey;\r\nret = ib_modify_qp(priv->qp, qp_attr, IB_QP_QKEY);\r\nif (ret) {\r\nipoib_warn(priv, "failed to modify QP, ret = %d\n", ret);\r\ngoto out;\r\n}\r\n}\r\nret = ib_attach_mcast(priv->qp, mgid, mlid);\r\nif (ret)\r\nipoib_warn(priv, "failed to attach to multicast group, ret = %d\n", ret);\r\nout:\r\nkfree(qp_attr);\r\nreturn ret;\r\n}\r\nint ipoib_init_qp(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nint ret;\r\nstruct ib_qp_attr qp_attr;\r\nint attr_mask;\r\nif (!test_bit(IPOIB_PKEY_ASSIGNED, &priv->flags))\r\nreturn -1;\r\nqp_attr.qp_state = IB_QPS_INIT;\r\nqp_attr.qkey = 0;\r\nqp_attr.port_num = priv->port;\r\nqp_attr.pkey_index = priv->pkey_index;\r\nattr_mask =\r\nIB_QP_QKEY |\r\nIB_QP_PORT |\r\nIB_QP_PKEY_INDEX |\r\nIB_QP_STATE;\r\nret = ib_modify_qp(priv->qp, &qp_attr, attr_mask);\r\nif (ret) {\r\nipoib_warn(priv, "failed to modify QP to init, ret = %d\n", ret);\r\ngoto out_fail;\r\n}\r\nqp_attr.qp_state = IB_QPS_RTR;\r\nattr_mask &= ~IB_QP_PORT;\r\nret = ib_modify_qp(priv->qp, &qp_attr, attr_mask);\r\nif (ret) {\r\nipoib_warn(priv, "failed to modify QP to RTR, ret = %d\n", ret);\r\ngoto out_fail;\r\n}\r\nqp_attr.qp_state = IB_QPS_RTS;\r\nqp_attr.sq_psn = 0;\r\nattr_mask |= IB_QP_SQ_PSN;\r\nattr_mask &= ~IB_QP_PKEY_INDEX;\r\nret = ib_modify_qp(priv->qp, &qp_attr, attr_mask);\r\nif (ret) {\r\nipoib_warn(priv, "failed to modify QP to RTS, ret = %d\n", ret);\r\ngoto out_fail;\r\n}\r\nreturn 0;\r\nout_fail:\r\nqp_attr.qp_state = IB_QPS_RESET;\r\nif (ib_modify_qp(priv->qp, &qp_attr, IB_QP_STATE))\r\nipoib_warn(priv, "Failed to modify QP to RESET state\n");\r\nreturn ret;\r\n}\r\nint ipoib_transport_dev_init(struct net_device *dev, struct ib_device *ca)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ib_qp_init_attr init_attr = {\r\n.cap = {\r\n.max_send_wr = ipoib_sendq_size,\r\n.max_recv_wr = ipoib_recvq_size,\r\n.max_send_sge = 1,\r\n.max_recv_sge = IPOIB_UD_RX_SG\r\n},\r\n.sq_sig_type = IB_SIGNAL_ALL_WR,\r\n.qp_type = IB_QPT_UD\r\n};\r\nint ret, size;\r\nint i;\r\npriv->pd = ib_alloc_pd(priv->ca);\r\nif (IS_ERR(priv->pd)) {\r\nprintk(KERN_WARNING "%s: failed to allocate PD\n", ca->name);\r\nreturn -ENODEV;\r\n}\r\npriv->mr = ib_get_dma_mr(priv->pd, IB_ACCESS_LOCAL_WRITE);\r\nif (IS_ERR(priv->mr)) {\r\nprintk(KERN_WARNING "%s: ib_get_dma_mr failed\n", ca->name);\r\ngoto out_free_pd;\r\n}\r\nsize = ipoib_recvq_size + 1;\r\nret = ipoib_cm_dev_init(dev);\r\nif (!ret) {\r\nsize += ipoib_sendq_size;\r\nif (ipoib_cm_has_srq(dev))\r\nsize += ipoib_recvq_size + 1;\r\nelse\r\nsize += ipoib_recvq_size * ipoib_max_conn_qp;\r\n}\r\npriv->recv_cq = ib_create_cq(priv->ca, ipoib_ib_completion, NULL, dev, size, 0);\r\nif (IS_ERR(priv->recv_cq)) {\r\nprintk(KERN_WARNING "%s: failed to create receive CQ\n", ca->name);\r\ngoto out_free_mr;\r\n}\r\npriv->send_cq = ib_create_cq(priv->ca, ipoib_send_comp_handler, NULL,\r\ndev, ipoib_sendq_size, 0);\r\nif (IS_ERR(priv->send_cq)) {\r\nprintk(KERN_WARNING "%s: failed to create send CQ\n", ca->name);\r\ngoto out_free_recv_cq;\r\n}\r\nif (ib_req_notify_cq(priv->recv_cq, IB_CQ_NEXT_COMP))\r\ngoto out_free_send_cq;\r\ninit_attr.send_cq = priv->send_cq;\r\ninit_attr.recv_cq = priv->recv_cq;\r\nif (priv->hca_caps & IB_DEVICE_UD_TSO)\r\ninit_attr.create_flags |= IB_QP_CREATE_IPOIB_UD_LSO;\r\nif (priv->hca_caps & IB_DEVICE_BLOCK_MULTICAST_LOOPBACK)\r\ninit_attr.create_flags |= IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK;\r\nif (priv->hca_caps & IB_DEVICE_MANAGED_FLOW_STEERING)\r\ninit_attr.create_flags |= IB_QP_CREATE_NETIF_QP;\r\nif (dev->features & NETIF_F_SG)\r\ninit_attr.cap.max_send_sge = MAX_SKB_FRAGS + 1;\r\npriv->qp = ib_create_qp(priv->pd, &init_attr);\r\nif (IS_ERR(priv->qp)) {\r\nprintk(KERN_WARNING "%s: failed to create QP\n", ca->name);\r\ngoto out_free_send_cq;\r\n}\r\npriv->dev->dev_addr[1] = (priv->qp->qp_num >> 16) & 0xff;\r\npriv->dev->dev_addr[2] = (priv->qp->qp_num >> 8) & 0xff;\r\npriv->dev->dev_addr[3] = (priv->qp->qp_num ) & 0xff;\r\nfor (i = 0; i < MAX_SKB_FRAGS + 1; ++i)\r\npriv->tx_sge[i].lkey = priv->mr->lkey;\r\npriv->tx_wr.opcode = IB_WR_SEND;\r\npriv->tx_wr.sg_list = priv->tx_sge;\r\npriv->tx_wr.send_flags = IB_SEND_SIGNALED;\r\npriv->rx_sge[0].lkey = priv->mr->lkey;\r\nif (ipoib_ud_need_sg(priv->max_ib_mtu)) {\r\npriv->rx_sge[0].length = IPOIB_UD_HEAD_SIZE;\r\npriv->rx_sge[1].length = PAGE_SIZE;\r\npriv->rx_sge[1].lkey = priv->mr->lkey;\r\npriv->rx_wr.num_sge = IPOIB_UD_RX_SG;\r\n} else {\r\npriv->rx_sge[0].length = IPOIB_UD_BUF_SIZE(priv->max_ib_mtu);\r\npriv->rx_wr.num_sge = 1;\r\n}\r\npriv->rx_wr.next = NULL;\r\npriv->rx_wr.sg_list = priv->rx_sge;\r\nreturn 0;\r\nout_free_send_cq:\r\nib_destroy_cq(priv->send_cq);\r\nout_free_recv_cq:\r\nib_destroy_cq(priv->recv_cq);\r\nout_free_mr:\r\nib_dereg_mr(priv->mr);\r\nipoib_cm_dev_cleanup(dev);\r\nout_free_pd:\r\nib_dealloc_pd(priv->pd);\r\nreturn -ENODEV;\r\n}\r\nvoid ipoib_transport_dev_cleanup(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nif (priv->qp) {\r\nif (ib_destroy_qp(priv->qp))\r\nipoib_warn(priv, "ib_qp_destroy failed\n");\r\npriv->qp = NULL;\r\nclear_bit(IPOIB_PKEY_ASSIGNED, &priv->flags);\r\n}\r\nif (ib_destroy_cq(priv->send_cq))\r\nipoib_warn(priv, "ib_cq_destroy (send) failed\n");\r\nif (ib_destroy_cq(priv->recv_cq))\r\nipoib_warn(priv, "ib_cq_destroy (recv) failed\n");\r\nipoib_cm_dev_cleanup(dev);\r\nif (ib_dereg_mr(priv->mr))\r\nipoib_warn(priv, "ib_dereg_mr failed\n");\r\nif (ib_dealloc_pd(priv->pd))\r\nipoib_warn(priv, "ib_dealloc_pd failed\n");\r\n}\r\nvoid ipoib_event(struct ib_event_handler *handler,\r\nstruct ib_event *record)\r\n{\r\nstruct ipoib_dev_priv *priv =\r\ncontainer_of(handler, struct ipoib_dev_priv, event_handler);\r\nif (record->element.port_num != priv->port)\r\nreturn;\r\nipoib_dbg(priv, "Event %d on device %s port %d\n", record->event,\r\nrecord->device->name, record->element.port_num);\r\nif (record->event == IB_EVENT_SM_CHANGE ||\r\nrecord->event == IB_EVENT_CLIENT_REREGISTER) {\r\nqueue_work(ipoib_workqueue, &priv->flush_light);\r\n} else if (record->event == IB_EVENT_PORT_ERR ||\r\nrecord->event == IB_EVENT_PORT_ACTIVE ||\r\nrecord->event == IB_EVENT_LID_CHANGE) {\r\nqueue_work(ipoib_workqueue, &priv->flush_normal);\r\n} else if (record->event == IB_EVENT_PKEY_CHANGE) {\r\nqueue_work(ipoib_workqueue, &priv->flush_heavy);\r\n}\r\n}
