static int __init cio_debug_init(void)\r\n{\r\ncio_debug_msg_id = debug_register("cio_msg", 16, 1, 11 * sizeof(long));\r\nif (!cio_debug_msg_id)\r\ngoto out_unregister;\r\ndebug_register_view(cio_debug_msg_id, &debug_sprintf_view);\r\ndebug_set_level(cio_debug_msg_id, 2);\r\ncio_debug_trace_id = debug_register("cio_trace", 16, 1, 16);\r\nif (!cio_debug_trace_id)\r\ngoto out_unregister;\r\ndebug_register_view(cio_debug_trace_id, &debug_hex_ascii_view);\r\ndebug_set_level(cio_debug_trace_id, 2);\r\ncio_debug_crw_id = debug_register("cio_crw", 8, 1, 8 * sizeof(long));\r\nif (!cio_debug_crw_id)\r\ngoto out_unregister;\r\ndebug_register_view(cio_debug_crw_id, &debug_sprintf_view);\r\ndebug_set_level(cio_debug_crw_id, 4);\r\nreturn 0;\r\nout_unregister:\r\nif (cio_debug_msg_id)\r\ndebug_unregister(cio_debug_msg_id);\r\nif (cio_debug_trace_id)\r\ndebug_unregister(cio_debug_trace_id);\r\nif (cio_debug_crw_id)\r\ndebug_unregister(cio_debug_crw_id);\r\nreturn -1;\r\n}\r\nint cio_set_options(struct subchannel *sch, int flags)\r\n{\r\nstruct io_subchannel_private *priv = to_io_private(sch);\r\npriv->options.suspend = (flags & DOIO_ALLOW_SUSPEND) != 0;\r\npriv->options.prefetch = (flags & DOIO_DENY_PREFETCH) != 0;\r\npriv->options.inter = (flags & DOIO_SUPPRESS_INTER) != 0;\r\nreturn 0;\r\n}\r\nstatic int\r\ncio_start_handle_notoper(struct subchannel *sch, __u8 lpm)\r\n{\r\nchar dbf_text[15];\r\nif (lpm != 0)\r\nsch->lpm &= ~lpm;\r\nelse\r\nsch->lpm = 0;\r\nCIO_MSG_EVENT(2, "cio_start: 'not oper' status for "\r\n"subchannel 0.%x.%04x!\n", sch->schid.ssid,\r\nsch->schid.sch_no);\r\nif (cio_update_schib(sch))\r\nreturn -ENODEV;\r\nsprintf(dbf_text, "no%s", dev_name(&sch->dev));\r\nCIO_TRACE_EVENT(0, dbf_text);\r\nCIO_HEX_EVENT(0, &sch->schib, sizeof (struct schib));\r\nreturn (sch->lpm ? -EACCES : -ENODEV);\r\n}\r\nint\r\ncio_start_key (struct subchannel *sch,\r\nstruct ccw1 * cpa,\r\n__u8 lpm,\r\n__u8 key)\r\n{\r\nstruct io_subchannel_private *priv = to_io_private(sch);\r\nunion orb *orb = &priv->orb;\r\nint ccode;\r\nCIO_TRACE_EVENT(5, "stIO");\r\nCIO_TRACE_EVENT(5, dev_name(&sch->dev));\r\nmemset(orb, 0, sizeof(union orb));\r\norb->cmd.intparm = (u32)(addr_t)sch;\r\norb->cmd.fmt = 1;\r\norb->cmd.pfch = priv->options.prefetch == 0;\r\norb->cmd.spnd = priv->options.suspend;\r\norb->cmd.ssic = priv->options.suspend && priv->options.inter;\r\norb->cmd.lpm = (lpm != 0) ? lpm : sch->lpm;\r\n#ifdef CONFIG_64BIT\r\norb->cmd.c64 = 1;\r\norb->cmd.i2k = 0;\r\n#endif\r\norb->cmd.key = key >> 4;\r\norb->cmd.cpa = (__u32) __pa(cpa);\r\nccode = ssch(sch->schid, orb);\r\nCIO_HEX_EVENT(5, &ccode, sizeof(ccode));\r\nswitch (ccode) {\r\ncase 0:\r\nsch->schib.scsw.cmd.actl |= SCSW_ACTL_START_PEND;\r\nreturn 0;\r\ncase 1:\r\ncase 2:\r\nreturn -EBUSY;\r\ncase 3:\r\nreturn cio_start_handle_notoper(sch, lpm);\r\ndefault:\r\nreturn ccode;\r\n}\r\n}\r\nint\r\ncio_start (struct subchannel *sch, struct ccw1 *cpa, __u8 lpm)\r\n{\r\nreturn cio_start_key(sch, cpa, lpm, PAGE_DEFAULT_KEY);\r\n}\r\nint\r\ncio_resume (struct subchannel *sch)\r\n{\r\nint ccode;\r\nCIO_TRACE_EVENT(4, "resIO");\r\nCIO_TRACE_EVENT(4, dev_name(&sch->dev));\r\nccode = rsch (sch->schid);\r\nCIO_HEX_EVENT(4, &ccode, sizeof(ccode));\r\nswitch (ccode) {\r\ncase 0:\r\nsch->schib.scsw.cmd.actl |= SCSW_ACTL_RESUME_PEND;\r\nreturn 0;\r\ncase 1:\r\nreturn -EBUSY;\r\ncase 2:\r\nreturn -EINVAL;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nint\r\ncio_halt(struct subchannel *sch)\r\n{\r\nint ccode;\r\nif (!sch)\r\nreturn -ENODEV;\r\nCIO_TRACE_EVENT(2, "haltIO");\r\nCIO_TRACE_EVENT(2, dev_name(&sch->dev));\r\nccode = hsch (sch->schid);\r\nCIO_HEX_EVENT(2, &ccode, sizeof(ccode));\r\nswitch (ccode) {\r\ncase 0:\r\nsch->schib.scsw.cmd.actl |= SCSW_ACTL_HALT_PEND;\r\nreturn 0;\r\ncase 1:\r\ncase 2:\r\nreturn -EBUSY;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nint\r\ncio_clear(struct subchannel *sch)\r\n{\r\nint ccode;\r\nif (!sch)\r\nreturn -ENODEV;\r\nCIO_TRACE_EVENT(2, "clearIO");\r\nCIO_TRACE_EVENT(2, dev_name(&sch->dev));\r\nccode = csch (sch->schid);\r\nCIO_HEX_EVENT(2, &ccode, sizeof(ccode));\r\nswitch (ccode) {\r\ncase 0:\r\nsch->schib.scsw.cmd.actl |= SCSW_ACTL_CLEAR_PEND;\r\nreturn 0;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nint\r\ncio_cancel (struct subchannel *sch)\r\n{\r\nint ccode;\r\nif (!sch)\r\nreturn -ENODEV;\r\nCIO_TRACE_EVENT(2, "cancelIO");\r\nCIO_TRACE_EVENT(2, dev_name(&sch->dev));\r\nccode = xsch (sch->schid);\r\nCIO_HEX_EVENT(2, &ccode, sizeof(ccode));\r\nswitch (ccode) {\r\ncase 0:\r\nif (cio_update_schib(sch))\r\nreturn -ENODEV;\r\nreturn 0;\r\ncase 1:\r\nreturn -EBUSY;\r\ncase 2:\r\nreturn -EINVAL;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic void cio_apply_config(struct subchannel *sch, struct schib *schib)\r\n{\r\nschib->pmcw.intparm = sch->config.intparm;\r\nschib->pmcw.mbi = sch->config.mbi;\r\nschib->pmcw.isc = sch->config.isc;\r\nschib->pmcw.ena = sch->config.ena;\r\nschib->pmcw.mme = sch->config.mme;\r\nschib->pmcw.mp = sch->config.mp;\r\nschib->pmcw.csense = sch->config.csense;\r\nschib->pmcw.mbfc = sch->config.mbfc;\r\nif (sch->config.mbfc)\r\nschib->mba = sch->config.mba;\r\n}\r\nstatic int cio_check_config(struct subchannel *sch, struct schib *schib)\r\n{\r\nreturn (schib->pmcw.intparm == sch->config.intparm) &&\r\n(schib->pmcw.mbi == sch->config.mbi) &&\r\n(schib->pmcw.isc == sch->config.isc) &&\r\n(schib->pmcw.ena == sch->config.ena) &&\r\n(schib->pmcw.mme == sch->config.mme) &&\r\n(schib->pmcw.mp == sch->config.mp) &&\r\n(schib->pmcw.csense == sch->config.csense) &&\r\n(schib->pmcw.mbfc == sch->config.mbfc) &&\r\n(!sch->config.mbfc || (schib->mba == sch->config.mba));\r\n}\r\nint cio_commit_config(struct subchannel *sch)\r\n{\r\nint ccode, retry, ret = 0;\r\nstruct schib schib;\r\nstruct irb irb;\r\nif (stsch_err(sch->schid, &schib) || !css_sch_is_valid(&schib))\r\nreturn -ENODEV;\r\nfor (retry = 0; retry < 5; retry++) {\r\ncio_apply_config(sch, &schib);\r\nccode = msch_err(sch->schid, &schib);\r\nif (ccode < 0)\r\nreturn ccode;\r\nswitch (ccode) {\r\ncase 0:\r\nif (stsch_err(sch->schid, &schib) ||\r\n!css_sch_is_valid(&schib))\r\nreturn -ENODEV;\r\nif (cio_check_config(sch, &schib)) {\r\nmemcpy(&sch->schib, &schib, sizeof(schib));\r\nreturn 0;\r\n}\r\nret = -EAGAIN;\r\nbreak;\r\ncase 1:\r\nret = -EBUSY;\r\nif (tsch(sch->schid, &irb))\r\nreturn ret;\r\nbreak;\r\ncase 2:\r\nudelay(100);\r\nret = -EBUSY;\r\nbreak;\r\ncase 3:\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint cio_update_schib(struct subchannel *sch)\r\n{\r\nstruct schib schib;\r\nif (stsch_err(sch->schid, &schib) || !css_sch_is_valid(&schib))\r\nreturn -ENODEV;\r\nmemcpy(&sch->schib, &schib, sizeof(schib));\r\nreturn 0;\r\n}\r\nint cio_enable_subchannel(struct subchannel *sch, u32 intparm)\r\n{\r\nint ret;\r\nCIO_TRACE_EVENT(2, "ensch");\r\nCIO_TRACE_EVENT(2, dev_name(&sch->dev));\r\nif (sch_is_pseudo_sch(sch))\r\nreturn -EINVAL;\r\nif (cio_update_schib(sch))\r\nreturn -ENODEV;\r\nsch->config.ena = 1;\r\nsch->config.isc = sch->isc;\r\nsch->config.intparm = intparm;\r\nret = cio_commit_config(sch);\r\nif (ret == -EIO) {\r\nsch->config.csense = 0;\r\nret = cio_commit_config(sch);\r\n}\r\nCIO_HEX_EVENT(2, &ret, sizeof(ret));\r\nreturn ret;\r\n}\r\nint cio_disable_subchannel(struct subchannel *sch)\r\n{\r\nint ret;\r\nCIO_TRACE_EVENT(2, "dissch");\r\nCIO_TRACE_EVENT(2, dev_name(&sch->dev));\r\nif (sch_is_pseudo_sch(sch))\r\nreturn 0;\r\nif (cio_update_schib(sch))\r\nreturn -ENODEV;\r\nsch->config.ena = 0;\r\nret = cio_commit_config(sch);\r\nCIO_HEX_EVENT(2, &ret, sizeof(ret));\r\nreturn ret;\r\n}\r\nstatic int cio_check_devno_blacklisted(struct subchannel *sch)\r\n{\r\nif (is_blacklisted(sch->schid.ssid, sch->schib.pmcw.dev)) {\r\nCIO_MSG_EVENT(6, "Blacklisted device detected "\r\n"at devno %04X, subchannel set %x\n",\r\nsch->schib.pmcw.dev, sch->schid.ssid);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cio_validate_io_subchannel(struct subchannel *sch)\r\n{\r\nif (!css_sch_is_valid(&sch->schib))\r\nreturn -ENODEV;\r\nreturn cio_check_devno_blacklisted(sch);\r\n}\r\nstatic int cio_validate_msg_subchannel(struct subchannel *sch)\r\n{\r\nif (!css_sch_is_valid(&sch->schib))\r\nreturn -ENODEV;\r\nreturn cio_check_devno_blacklisted(sch);\r\n}\r\nint cio_validate_subchannel(struct subchannel *sch, struct subchannel_id schid)\r\n{\r\nchar dbf_txt[15];\r\nint ccode;\r\nint err;\r\nsprintf(dbf_txt, "valsch%x", schid.sch_no);\r\nCIO_TRACE_EVENT(4, dbf_txt);\r\nccode = stsch_err(schid, &sch->schib);\r\nif (ccode) {\r\nerr = (ccode == 3) ? -ENXIO : ccode;\r\ngoto out;\r\n}\r\nsch->st = sch->schib.pmcw.st;\r\nsch->schid = schid;\r\nswitch (sch->st) {\r\ncase SUBCHANNEL_TYPE_IO:\r\nerr = cio_validate_io_subchannel(sch);\r\nbreak;\r\ncase SUBCHANNEL_TYPE_MSG:\r\nerr = cio_validate_msg_subchannel(sch);\r\nbreak;\r\ndefault:\r\nerr = 0;\r\n}\r\nif (err)\r\ngoto out;\r\nCIO_MSG_EVENT(4, "Subchannel 0.%x.%04x reports subchannel type %04X\n",\r\nsch->schid.ssid, sch->schid.sch_no, sch->st);\r\nout:\r\nreturn err;\r\n}\r\nstatic irqreturn_t do_cio_interrupt(int irq, void *dummy)\r\n{\r\nstruct tpi_info *tpi_info;\r\nstruct subchannel *sch;\r\nstruct irb *irb;\r\n__this_cpu_write(s390_idle.nohz_delay, 1);\r\ntpi_info = (struct tpi_info *) &get_irq_regs()->int_code;\r\nirb = &__get_cpu_var(cio_irb);\r\nsch = (struct subchannel *)(unsigned long) tpi_info->intparm;\r\nif (!sch) {\r\ninc_irq_stat(IRQIO_CIO);\r\ntsch(tpi_info->schid, irb);\r\nreturn IRQ_HANDLED;\r\n}\r\nspin_lock(sch->lock);\r\nif (tsch(tpi_info->schid, irb) == 0) {\r\nmemcpy (&sch->schib.scsw, &irb->scsw, sizeof (irb->scsw));\r\nif (sch->driver && sch->driver->irq)\r\nsch->driver->irq(sch);\r\nelse\r\ninc_irq_stat(IRQIO_CIO);\r\n} else\r\ninc_irq_stat(IRQIO_CIO);\r\nspin_unlock(sch->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid __init init_cio_interrupts(void)\r\n{\r\nirq_set_chip_and_handler(IO_INTERRUPT,\r\n&dummy_irq_chip, handle_percpu_irq);\r\nsetup_irq(IO_INTERRUPT, &io_interrupt);\r\n}\r\nvoid cio_tsch(struct subchannel *sch)\r\n{\r\nstruct irb *irb;\r\nint irq_context;\r\nirb = &__get_cpu_var(cio_irb);\r\nif (tsch(sch->schid, irb) != 0)\r\nreturn;\r\nmemcpy(&sch->schib.scsw, &irb->scsw, sizeof(union scsw));\r\nirq_context = in_interrupt();\r\nif (!irq_context) {\r\nlocal_bh_disable();\r\nirq_enter();\r\n}\r\nkstat_incr_irq_this_cpu(IO_INTERRUPT);\r\nif (sch->driver && sch->driver->irq)\r\nsch->driver->irq(sch);\r\nelse\r\ninc_irq_stat(IRQIO_CIO);\r\nif (!irq_context) {\r\nirq_exit();\r\n_local_bh_enable();\r\n}\r\n}\r\nstatic int cio_test_for_console(struct subchannel_id schid, void *data)\r\n{\r\nstruct schib schib;\r\nif (stsch_err(schid, &schib) != 0)\r\nreturn -ENXIO;\r\nif ((schib.pmcw.st == SUBCHANNEL_TYPE_IO) && schib.pmcw.dnv &&\r\n(schib.pmcw.dev == console_devno)) {\r\nconsole_irq = schid.sch_no;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cio_get_console_sch_no(void)\r\n{\r\nstruct subchannel_id schid;\r\nstruct schib schib;\r\ninit_subchannel_id(&schid);\r\nif (console_irq != -1) {\r\nschid.sch_no = console_irq;\r\nif (stsch_err(schid, &schib) != 0 ||\r\n(schib.pmcw.st != SUBCHANNEL_TYPE_IO) || !schib.pmcw.dnv)\r\nreturn -1;\r\nconsole_devno = schib.pmcw.dev;\r\n} else if (console_devno != -1) {\r\nfor_each_subchannel(cio_test_for_console, NULL);\r\n}\r\nreturn console_irq;\r\n}\r\nstruct subchannel *cio_probe_console(void)\r\n{\r\nstruct subchannel_id schid;\r\nstruct subchannel *sch;\r\nint sch_no, ret;\r\nsch_no = cio_get_console_sch_no();\r\nif (sch_no == -1) {\r\npr_warning("No CCW console was found\n");\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\ninit_subchannel_id(&schid);\r\nschid.sch_no = sch_no;\r\nsch = css_alloc_subchannel(schid);\r\nif (IS_ERR(sch))\r\nreturn sch;\r\nlockdep_set_class(sch->lock, &console_sch_key);\r\nisc_register(CONSOLE_ISC);\r\nsch->config.isc = CONSOLE_ISC;\r\nsch->config.intparm = (u32)(addr_t)sch;\r\nret = cio_commit_config(sch);\r\nif (ret) {\r\nisc_unregister(CONSOLE_ISC);\r\nput_device(&sch->dev);\r\nreturn ERR_PTR(ret);\r\n}\r\nconsole_sch = sch;\r\nreturn sch;\r\n}\r\nint cio_is_console(struct subchannel_id schid)\r\n{\r\nif (!console_sch)\r\nreturn 0;\r\nreturn schid_equal(&schid, &console_sch->schid);\r\n}\r\nvoid cio_register_early_subchannels(void)\r\n{\r\nint ret;\r\nif (!console_sch)\r\nreturn;\r\nret = css_register_subchannel(console_sch);\r\nif (ret)\r\nput_device(&console_sch->dev);\r\n}\r\nstatic int\r\n__disable_subchannel_easy(struct subchannel_id schid, struct schib *schib)\r\n{\r\nint retry, cc;\r\ncc = 0;\r\nfor (retry=0;retry<3;retry++) {\r\nschib->pmcw.ena = 0;\r\ncc = msch_err(schid, schib);\r\nif (cc)\r\nreturn (cc==3?-ENODEV:-EBUSY);\r\nif (stsch_err(schid, schib) || !css_sch_is_valid(schib))\r\nreturn -ENODEV;\r\nif (!schib->pmcw.ena)\r\nreturn 0;\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int\r\n__clear_io_subchannel_easy(struct subchannel_id schid)\r\n{\r\nint retry;\r\nif (csch(schid))\r\nreturn -ENODEV;\r\nfor (retry=0;retry<20;retry++) {\r\nstruct tpi_info ti;\r\nif (tpi(&ti)) {\r\ntsch(ti.schid, &__get_cpu_var(cio_irb));\r\nif (schid_equal(&ti.schid, &schid))\r\nreturn 0;\r\n}\r\nudelay_simple(100);\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic void __clear_chsc_subchannel_easy(void)\r\n{\r\nudelay_simple(100);\r\n}\r\nstatic void cio_reset_pgm_check_handler(void)\r\n{\r\npgm_check_occured = 1;\r\n}\r\nstatic int stsch_reset(struct subchannel_id schid, struct schib *addr)\r\n{\r\nint rc;\r\npgm_check_occured = 0;\r\ns390_base_pgm_handler_fn = cio_reset_pgm_check_handler;\r\nrc = stsch_err(schid, addr);\r\ns390_base_pgm_handler_fn = NULL;\r\nbarrier();\r\nif (pgm_check_occured)\r\nreturn -EIO;\r\nelse\r\nreturn rc;\r\n}\r\nstatic int __shutdown_subchannel_easy(struct subchannel_id schid, void *data)\r\n{\r\nstruct schib schib;\r\nif (stsch_reset(schid, &schib))\r\nreturn -ENXIO;\r\nif (!schib.pmcw.ena)\r\nreturn 0;\r\nswitch(__disable_subchannel_easy(schid, &schib)) {\r\ncase 0:\r\ncase -ENODEV:\r\nbreak;\r\ndefault:\r\nswitch (schib.pmcw.st) {\r\ncase SUBCHANNEL_TYPE_IO:\r\nif (__clear_io_subchannel_easy(schid))\r\ngoto out;\r\nbreak;\r\ncase SUBCHANNEL_TYPE_CHSC:\r\n__clear_chsc_subchannel_easy();\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nstsch_err(schid, &schib);\r\n__disable_subchannel_easy(schid, &schib);\r\n}\r\nout:\r\nreturn 0;\r\n}\r\nstatic void s390_reset_chpids_mcck_handler(void)\r\n{\r\nstruct crw crw;\r\nstruct mci *mci;\r\nmci = (struct mci *)&S390_lowcore.mcck_interruption_code;\r\nif (!mci->cp)\r\nreturn;\r\nwhile (stcrw(&crw) == 0) {\r\nif (crw.slct && crw.rsc == CRW_RSC_CPATH)\r\natomic_dec(&chpid_reset_count);\r\n}\r\n}\r\nstatic void css_reset(void)\r\n{\r\nint i, ret;\r\nunsigned long long timeout;\r\nstruct chp_id chpid;\r\nfor_each_subchannel(__shutdown_subchannel_easy, NULL);\r\ns390_base_mcck_handler_fn = s390_reset_chpids_mcck_handler;\r\n__ctl_set_bit(14, 28);\r\nlocal_mcck_enable();\r\nchp_id_init(&chpid);\r\nfor (i = 0; i <= __MAX_CHPID; i++) {\r\nchpid.id = i;\r\nret = rchp(chpid);\r\nif ((ret == 0) || (ret == 2))\r\natomic_inc(&chpid_reset_count);\r\n}\r\ntimeout = get_tod_clock_fast() + (RCHP_TIMEOUT << 12);\r\nwhile (atomic_read(&chpid_reset_count) != 0) {\r\nif (get_tod_clock_fast() > timeout)\r\nbreak;\r\ncpu_relax();\r\n}\r\nlocal_mcck_disable();\r\n__ctl_clear_bit(14, 28);\r\ns390_base_mcck_handler_fn = NULL;\r\n}\r\nstatic int __init init_css_reset_call(void)\r\n{\r\natomic_set(&chpid_reset_count, 0);\r\nregister_reset_call(&css_reset_call);\r\nreturn 0;\r\n}\r\nstatic int __reipl_subchannel_match(struct subchannel_id schid, void *data)\r\n{\r\nstruct schib schib;\r\nstruct sch_match_id *match_id = data;\r\nif (stsch_reset(schid, &schib))\r\nreturn -ENXIO;\r\nif ((schib.pmcw.st == SUBCHANNEL_TYPE_IO) && schib.pmcw.dnv &&\r\n(schib.pmcw.dev == match_id->devid.devno) &&\r\n(schid.ssid == match_id->devid.ssid)) {\r\nmatch_id->schid = schid;\r\nmatch_id->rc = 0;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int reipl_find_schid(struct ccw_dev_id *devid,\r\nstruct subchannel_id *schid)\r\n{\r\nstruct sch_match_id match_id;\r\nmatch_id.devid = *devid;\r\nmatch_id.rc = -ENODEV;\r\nfor_each_subchannel(__reipl_subchannel_match, &match_id);\r\nif (match_id.rc == 0)\r\n*schid = match_id.schid;\r\nreturn match_id.rc;\r\n}\r\nvoid reipl_ccw_dev(struct ccw_dev_id *devid)\r\n{\r\nstruct subchannel_id uninitialized_var(schid);\r\ns390_reset_system(NULL, NULL);\r\nif (reipl_find_schid(devid, &schid) != 0)\r\npanic("IPL Device not found\n");\r\ndo_reipl_asm(*((__u32*)&schid));\r\n}\r\nint __init cio_get_iplinfo(struct cio_iplinfo *iplinfo)\r\n{\r\nstruct subchannel_id schid;\r\nstruct schib schib;\r\nschid = *(struct subchannel_id *)&S390_lowcore.subchannel_id;\r\nif (!schid.one)\r\nreturn -ENODEV;\r\nif (stsch_err(schid, &schib))\r\nreturn -ENODEV;\r\nif (schib.pmcw.st != SUBCHANNEL_TYPE_IO)\r\nreturn -ENODEV;\r\nif (!schib.pmcw.dnv)\r\nreturn -ENODEV;\r\niplinfo->devno = schib.pmcw.dev;\r\niplinfo->is_qdio = schib.pmcw.qf;\r\nreturn 0;\r\n}\r\nint cio_tm_start_key(struct subchannel *sch, struct tcw *tcw, u8 lpm, u8 key)\r\n{\r\nint cc;\r\nunion orb *orb = &to_io_private(sch)->orb;\r\nmemset(orb, 0, sizeof(union orb));\r\norb->tm.intparm = (u32) (addr_t) sch;\r\norb->tm.key = key >> 4;\r\norb->tm.b = 1;\r\norb->tm.lpm = lpm ? lpm : sch->lpm;\r\norb->tm.tcw = (u32) (addr_t) tcw;\r\ncc = ssch(sch->schid, orb);\r\nswitch (cc) {\r\ncase 0:\r\nreturn 0;\r\ncase 1:\r\ncase 2:\r\nreturn -EBUSY;\r\ndefault:\r\nreturn cio_start_handle_notoper(sch, lpm);\r\n}\r\n}\r\nint cio_tm_intrg(struct subchannel *sch)\r\n{\r\nint cc;\r\nif (!to_io_private(sch)->orb.tm.b)\r\nreturn -EINVAL;\r\ncc = xsch(sch->schid);\r\nswitch (cc) {\r\ncase 0:\r\ncase 2:\r\nreturn 0;\r\ncase 1:\r\nreturn -EBUSY;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}
