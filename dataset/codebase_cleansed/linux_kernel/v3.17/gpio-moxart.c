static inline struct moxart_gpio_chip *to_moxart_gpio(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct moxart_gpio_chip, gpio);\r\n}\r\nstatic int moxart_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn pinctrl_request_gpio(offset);\r\n}\r\nstatic void moxart_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\npinctrl_free_gpio(offset);\r\n}\r\nstatic void moxart_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct moxart_gpio_chip *gc = to_moxart_gpio(chip);\r\nvoid __iomem *ioaddr = gc->base + GPIO_DATA_OUT;\r\nu32 reg = readl(ioaddr);\r\nif (value)\r\nreg = reg | BIT(offset);\r\nelse\r\nreg = reg & ~BIT(offset);\r\nwritel(reg, ioaddr);\r\n}\r\nstatic int moxart_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct moxart_gpio_chip *gc = to_moxart_gpio(chip);\r\nu32 ret = readl(gc->base + GPIO_PIN_DIRECTION);\r\nif (ret & BIT(offset))\r\nreturn !!(readl(gc->base + GPIO_DATA_OUT) & BIT(offset));\r\nelse\r\nreturn !!(readl(gc->base + GPIO_DATA_IN) & BIT(offset));\r\n}\r\nstatic int moxart_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct moxart_gpio_chip *gc = to_moxart_gpio(chip);\r\nvoid __iomem *ioaddr = gc->base + GPIO_PIN_DIRECTION;\r\nwritel(readl(ioaddr) & ~BIT(offset), ioaddr);\r\nreturn 0;\r\n}\r\nstatic int moxart_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct moxart_gpio_chip *gc = to_moxart_gpio(chip);\r\nvoid __iomem *ioaddr = gc->base + GPIO_PIN_DIRECTION;\r\nmoxart_gpio_set(chip, offset, value);\r\nwritel(readl(ioaddr) | BIT(offset), ioaddr);\r\nreturn 0;\r\n}\r\nstatic int moxart_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct moxart_gpio_chip *mgc;\r\nint ret;\r\nmgc = devm_kzalloc(dev, sizeof(*mgc), GFP_KERNEL);\r\nif (!mgc)\r\nreturn -ENOMEM;\r\nmgc->gpio = moxart_template_chip;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmgc->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(mgc->base))\r\nreturn PTR_ERR(mgc->base);\r\nmgc->gpio.dev = dev;\r\nret = gpiochip_add(&mgc->gpio);\r\nif (ret) {\r\ndev_err(dev, "%s: gpiochip_add failed\n",\r\ndev->of_node->full_name);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
