static u8\r\nacpi_tb_compare_tables(struct acpi_table_desc *table_desc, u32 table_index)\r\n{\r\nacpi_status status = AE_OK;\r\nu8 is_identical;\r\nstruct acpi_table_header *table;\r\nu32 table_length;\r\nu8 table_flags;\r\nstatus =\r\nacpi_tb_acquire_table(&acpi_gbl_root_table_list.tables[table_index],\r\n&table, &table_length, &table_flags);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (FALSE);\r\n}\r\nis_identical = (u8)((table_desc->length != table_length ||\r\nACPI_MEMCMP(table_desc->pointer, table,\r\ntable_length)) ? FALSE : TRUE);\r\nacpi_tb_release_table(table, table_length, table_flags);\r\nreturn (is_identical);\r\n}\r\nvoid\r\nacpi_tb_install_table_with_override(u32 table_index,\r\nstruct acpi_table_desc *new_table_desc,\r\nu8 override)\r\n{\r\nif (table_index >= acpi_gbl_root_table_list.current_table_count) {\r\nreturn;\r\n}\r\nif (override) {\r\nacpi_tb_override_table(new_table_desc);\r\n}\r\nacpi_tb_init_table_descriptor(&acpi_gbl_root_table_list.\r\ntables[table_index],\r\nnew_table_desc->address,\r\nnew_table_desc->flags,\r\nnew_table_desc->pointer);\r\nacpi_tb_print_table_header(new_table_desc->address,\r\nnew_table_desc->pointer);\r\nif (table_index == ACPI_TABLE_INDEX_DSDT) {\r\nacpi_ut_set_integer_width(new_table_desc->pointer->revision);\r\n}\r\n}\r\nacpi_status\r\nacpi_tb_install_fixed_table(acpi_physical_address address,\r\nchar *signature, u32 table_index)\r\n{\r\nstruct acpi_table_desc new_table_desc;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(tb_install_fixed_table);\r\nif (!address) {\r\nACPI_ERROR((AE_INFO,\r\n"Null physical address for ACPI table [%s]",\r\nsignature));\r\nreturn (AE_NO_MEMORY);\r\n}\r\nstatus = acpi_tb_acquire_temp_table(&new_table_desc, address,\r\nACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_ERROR((AE_INFO, "Could not acquire table length at %p",\r\nACPI_CAST_PTR(void, address)));\r\nreturn_ACPI_STATUS(status);\r\n}\r\nstatus = acpi_tb_verify_temp_table(&new_table_desc, signature);\r\nif (ACPI_FAILURE(status)) {\r\ngoto release_and_exit;\r\n}\r\nacpi_tb_install_table_with_override(table_index, &new_table_desc, TRUE);\r\nrelease_and_exit:\r\nacpi_tb_release_temp_table(&new_table_desc);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_tb_install_standard_table(acpi_physical_address address,\r\nu8 flags,\r\nu8 reload, u8 override, u32 *table_index)\r\n{\r\nu32 i;\r\nacpi_status status = AE_OK;\r\nstruct acpi_table_desc new_table_desc;\r\nACPI_FUNCTION_TRACE(tb_install_standard_table);\r\nstatus = acpi_tb_acquire_temp_table(&new_table_desc, address, flags);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_ERROR((AE_INFO, "Could not acquire table length at %p",\r\nACPI_CAST_PTR(void, address)));\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (!reload &&\r\nacpi_gbl_disable_ssdt_table_install &&\r\nACPI_COMPARE_NAME(&new_table_desc.signature, ACPI_SIG_SSDT)) {\r\nACPI_INFO((AE_INFO, "Ignoring installation of %4.4s at %p",\r\nnew_table_desc.signature.ascii, ACPI_CAST_PTR(void,\r\naddress)));\r\ngoto release_and_exit;\r\n}\r\nstatus = acpi_tb_verify_temp_table(&new_table_desc, NULL);\r\nif (ACPI_FAILURE(status)) {\r\ngoto release_and_exit;\r\n}\r\nif (reload) {\r\nif ((new_table_desc.signature.ascii[0] != 0x00) &&\r\n(!ACPI_COMPARE_NAME\r\n(&new_table_desc.signature, ACPI_SIG_SSDT))\r\n&& (ACPI_STRNCMP(new_table_desc.signature.ascii, "OEM", 3)))\r\n{\r\nACPI_BIOS_ERROR((AE_INFO,\r\n"Table has invalid signature [%4.4s] (0x%8.8X), "\r\n"must be SSDT or OEMx",\r\nacpi_ut_valid_acpi_name(new_table_desc.\r\nsignature.\r\nascii) ?\r\nnew_table_desc.signature.\r\nascii : "????",\r\nnew_table_desc.signature.integer));\r\nstatus = AE_BAD_SIGNATURE;\r\ngoto release_and_exit;\r\n}\r\nfor (i = 0; i < acpi_gbl_root_table_list.current_table_count;\r\n++i) {\r\nif (!acpi_tb_compare_tables(&new_table_desc, i)) {\r\ncontinue;\r\n}\r\nif (acpi_gbl_root_table_list.tables[i].\r\nflags & ACPI_TABLE_IS_LOADED) {\r\nstatus = AE_ALREADY_EXISTS;\r\ngoto release_and_exit;\r\n} else {\r\nacpi_tb_uninstall_table(&new_table_desc);\r\n*table_index = i;\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\n}\r\n}\r\nstatus = acpi_tb_get_next_root_index(&i);\r\nif (ACPI_FAILURE(status)) {\r\ngoto release_and_exit;\r\n}\r\n*table_index = i;\r\nacpi_tb_install_table_with_override(i, &new_table_desc, override);\r\nrelease_and_exit:\r\nacpi_tb_release_temp_table(&new_table_desc);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nvoid acpi_tb_override_table(struct acpi_table_desc *old_table_desc)\r\n{\r\nacpi_status status;\r\nchar *override_type;\r\nstruct acpi_table_desc new_table_desc;\r\nstruct acpi_table_header *table;\r\nacpi_physical_address address;\r\nu32 length;\r\nstatus = acpi_os_table_override(old_table_desc->pointer, &table);\r\nif (ACPI_SUCCESS(status) && table) {\r\nacpi_tb_acquire_temp_table(&new_table_desc,\r\nACPI_PTR_TO_PHYSADDR(table),\r\nACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL);\r\noverride_type = "Logical";\r\ngoto finish_override;\r\n}\r\nstatus = acpi_os_physical_table_override(old_table_desc->pointer,\r\n&address, &length);\r\nif (ACPI_SUCCESS(status) && address && length) {\r\nacpi_tb_acquire_temp_table(&new_table_desc, address,\r\nACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL);\r\noverride_type = "Physical";\r\ngoto finish_override;\r\n}\r\nreturn;\r\nfinish_override:\r\nstatus = acpi_tb_verify_temp_table(&new_table_desc, NULL);\r\nif (ACPI_FAILURE(status)) {\r\nreturn;\r\n}\r\nACPI_INFO((AE_INFO, "%4.4s " ACPI_PRINTF_UINT\r\n" %s table override, new table: " ACPI_PRINTF_UINT,\r\nold_table_desc->signature.ascii,\r\nACPI_FORMAT_TO_UINT(old_table_desc->address),\r\noverride_type, ACPI_FORMAT_TO_UINT(new_table_desc.address)));\r\nacpi_tb_uninstall_table(old_table_desc);\r\nacpi_tb_init_table_descriptor(old_table_desc, new_table_desc.address,\r\nnew_table_desc.flags,\r\nnew_table_desc.pointer);\r\nacpi_tb_validate_temp_table(old_table_desc);\r\nacpi_tb_release_temp_table(&new_table_desc);\r\n}\r\nacpi_status\r\nacpi_tb_store_table(acpi_physical_address address,\r\nstruct acpi_table_header * table,\r\nu32 length, u8 flags, u32 *table_index)\r\n{\r\nacpi_status status;\r\nstruct acpi_table_desc *table_desc;\r\nstatus = acpi_tb_get_next_root_index(table_index);\r\nif (ACPI_FAILURE(status)) {\r\nreturn (status);\r\n}\r\ntable_desc = &acpi_gbl_root_table_list.tables[*table_index];\r\nacpi_tb_init_table_descriptor(table_desc, address, flags, table);\r\ntable_desc->pointer = table;\r\nreturn (AE_OK);\r\n}\r\nvoid acpi_tb_uninstall_table(struct acpi_table_desc *table_desc)\r\n{\r\nACPI_FUNCTION_TRACE(tb_uninstall_table);\r\nif (!table_desc->address) {\r\nreturn_VOID;\r\n}\r\nacpi_tb_invalidate_table(table_desc);\r\nif ((table_desc->flags & ACPI_TABLE_ORIGIN_MASK) ==\r\nACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL) {\r\nACPI_FREE(ACPI_CAST_PTR(void, table_desc->address));\r\n}\r\ntable_desc->address = ACPI_PTR_TO_PHYSADDR(NULL);\r\nreturn_VOID;\r\n}
