static unsigned char *pep_get_sb(struct sk_buff *skb, u8 *ptype, u8 *plen,\r\nvoid *buf)\r\n{\r\nvoid *data = NULL;\r\nstruct {\r\nu8 sb_type;\r\nu8 sb_len;\r\n} *ph, h;\r\nint buflen = *plen;\r\nph = skb_header_pointer(skb, 0, 2, &h);\r\nif (ph == NULL || ph->sb_len < 2 || !pskb_may_pull(skb, ph->sb_len))\r\nreturn NULL;\r\nph->sb_len -= 2;\r\n*ptype = ph->sb_type;\r\n*plen = ph->sb_len;\r\nif (buflen > ph->sb_len)\r\nbuflen = ph->sb_len;\r\ndata = skb_header_pointer(skb, 2, buflen, buf);\r\n__skb_pull(skb, 2 + ph->sb_len);\r\nreturn data;\r\n}\r\nstatic struct sk_buff *pep_alloc_skb(struct sock *sk, const void *payload,\r\nint len, gfp_t priority)\r\n{\r\nstruct sk_buff *skb = alloc_skb(MAX_PNPIPE_HEADER + len, priority);\r\nif (!skb)\r\nreturn NULL;\r\nskb_set_owner_w(skb, sk);\r\nskb_reserve(skb, MAX_PNPIPE_HEADER);\r\n__skb_put(skb, len);\r\nskb_copy_to_linear_data(skb, payload, len);\r\n__skb_push(skb, sizeof(struct pnpipehdr));\r\nskb_reset_transport_header(skb);\r\nreturn skb;\r\n}\r\nstatic int pep_reply(struct sock *sk, struct sk_buff *oskb, u8 code,\r\nconst void *data, int len, gfp_t priority)\r\n{\r\nconst struct pnpipehdr *oph = pnp_hdr(oskb);\r\nstruct pnpipehdr *ph;\r\nstruct sk_buff *skb;\r\nstruct sockaddr_pn peer;\r\nskb = pep_alloc_skb(sk, data, len, priority);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nph = pnp_hdr(skb);\r\nph->utid = oph->utid;\r\nph->message_id = oph->message_id + 1;\r\nph->pipe_handle = oph->pipe_handle;\r\nph->error_code = code;\r\npn_skb_get_src_sockaddr(oskb, &peer);\r\nreturn pn_skb_send(sk, skb, &peer);\r\n}\r\nstatic int pep_indicate(struct sock *sk, u8 id, u8 code,\r\nconst void *data, int len, gfp_t priority)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nstruct pnpipehdr *ph;\r\nstruct sk_buff *skb;\r\nskb = pep_alloc_skb(sk, data, len, priority);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nph = pnp_hdr(skb);\r\nph->utid = 0;\r\nph->message_id = id;\r\nph->pipe_handle = pn->pipe_handle;\r\nph->data[0] = code;\r\nreturn pn_skb_send(sk, skb, NULL);\r\n}\r\nstatic int pipe_handler_request(struct sock *sk, u8 id, u8 code,\r\nconst void *data, int len)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nstruct pnpipehdr *ph;\r\nstruct sk_buff *skb;\r\nskb = pep_alloc_skb(sk, data, len, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nph = pnp_hdr(skb);\r\nph->utid = id;\r\nph->message_id = id;\r\nph->pipe_handle = pn->pipe_handle;\r\nph->data[0] = code;\r\nreturn pn_skb_send(sk, skb, NULL);\r\n}\r\nstatic int pipe_handler_send_created_ind(struct sock *sk)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nu8 data[4] = {\r\nPN_PIPE_SB_NEGOTIATED_FC, pep_sb_size(2),\r\npn->tx_fc, pn->rx_fc,\r\n};\r\nreturn pep_indicate(sk, PNS_PIPE_CREATED_IND, 1 ,\r\ndata, 4, GFP_ATOMIC);\r\n}\r\nstatic int pep_accept_conn(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstatic const u8 data[20] = {\r\nPAD, PAD, PAD, 2 ,\r\nPN_PIPE_SB_REQUIRED_FC_TX, pep_sb_size(5), 3, PAD,\r\nPN_MULTI_CREDIT_FLOW_CONTROL,\r\nPN_ONE_CREDIT_FLOW_CONTROL,\r\nPN_LEGACY_FLOW_CONTROL,\r\nPAD,\r\nPN_PIPE_SB_PREFERRED_FC_RX, pep_sb_size(5), 3, PAD,\r\nPN_MULTI_CREDIT_FLOW_CONTROL,\r\nPN_ONE_CREDIT_FLOW_CONTROL,\r\nPN_LEGACY_FLOW_CONTROL,\r\nPAD,\r\n};\r\nmight_sleep();\r\nreturn pep_reply(sk, skb, PN_PIPE_NO_ERROR, data, sizeof(data),\r\nGFP_KERNEL);\r\n}\r\nstatic int pep_reject_conn(struct sock *sk, struct sk_buff *skb, u8 code,\r\ngfp_t priority)\r\n{\r\nstatic const u8 data[4] = { PAD, PAD, PAD, 0 };\r\nWARN_ON(code == PN_PIPE_NO_ERROR);\r\nreturn pep_reply(sk, skb, code, data, sizeof(data), priority);\r\n}\r\nstatic int pep_ctrlreq_error(struct sock *sk, struct sk_buff *oskb, u8 code,\r\ngfp_t priority)\r\n{\r\nconst struct pnpipehdr *oph = pnp_hdr(oskb);\r\nstruct sk_buff *skb;\r\nstruct pnpipehdr *ph;\r\nstruct sockaddr_pn dst;\r\nu8 data[4] = {\r\noph->data[0],\r\ncode,\r\nPAD, PAD,\r\n};\r\nskb = pep_alloc_skb(sk, data, 4, priority);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nph = pnp_hdr(skb);\r\nph->utid = oph->utid;\r\nph->message_id = PNS_PEP_CTRL_RESP;\r\nph->pipe_handle = oph->pipe_handle;\r\nph->data[0] = oph->data[1];\r\npn_skb_get_src_sockaddr(oskb, &dst);\r\nreturn pn_skb_send(sk, skb, &dst);\r\n}\r\nstatic int pipe_snd_status(struct sock *sk, u8 type, u8 status, gfp_t priority)\r\n{\r\nu8 data[4] = { type, PAD, PAD, status };\r\nreturn pep_indicate(sk, PNS_PEP_STATUS_IND, PN_PEP_TYPE_COMMON,\r\ndata, 4, priority);\r\n}\r\nstatic void pipe_grant_credits(struct sock *sk, gfp_t priority)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nBUG_ON(sk->sk_state != TCP_ESTABLISHED);\r\nswitch (pn->rx_fc) {\r\ncase PN_LEGACY_FLOW_CONTROL:\r\nbreak;\r\ncase PN_ONE_CREDIT_FLOW_CONTROL:\r\nif (pipe_snd_status(sk, PN_PEP_IND_FLOW_CONTROL,\r\nPEP_IND_READY, priority) == 0)\r\npn->rx_credits = 1;\r\nbreak;\r\ncase PN_MULTI_CREDIT_FLOW_CONTROL:\r\nif ((pn->rx_credits + CREDITS_THR) > CREDITS_MAX)\r\nbreak;\r\nif (pipe_snd_status(sk, PN_PEP_IND_ID_MCFC_GRANT_CREDITS,\r\nCREDITS_MAX - pn->rx_credits,\r\npriority) == 0)\r\npn->rx_credits = CREDITS_MAX;\r\nbreak;\r\n}\r\n}\r\nstatic int pipe_rcv_status(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nstruct pnpipehdr *hdr;\r\nint wake = 0;\r\nif (!pskb_may_pull(skb, sizeof(*hdr) + 4))\r\nreturn -EINVAL;\r\nhdr = pnp_hdr(skb);\r\nif (hdr->data[0] != PN_PEP_TYPE_COMMON) {\r\nLIMIT_NETDEBUG(KERN_DEBUG"Phonet unknown PEP type: %u\n",\r\n(unsigned int)hdr->data[0]);\r\nreturn -EOPNOTSUPP;\r\n}\r\nswitch (hdr->data[1]) {\r\ncase PN_PEP_IND_FLOW_CONTROL:\r\nswitch (pn->tx_fc) {\r\ncase PN_LEGACY_FLOW_CONTROL:\r\nswitch (hdr->data[4]) {\r\ncase PEP_IND_BUSY:\r\natomic_set(&pn->tx_credits, 0);\r\nbreak;\r\ncase PEP_IND_READY:\r\natomic_set(&pn->tx_credits, wake = 1);\r\nbreak;\r\n}\r\nbreak;\r\ncase PN_ONE_CREDIT_FLOW_CONTROL:\r\nif (hdr->data[4] == PEP_IND_READY)\r\natomic_set(&pn->tx_credits, wake = 1);\r\nbreak;\r\n}\r\nbreak;\r\ncase PN_PEP_IND_ID_MCFC_GRANT_CREDITS:\r\nif (pn->tx_fc != PN_MULTI_CREDIT_FLOW_CONTROL)\r\nbreak;\r\natomic_add(wake = hdr->data[4], &pn->tx_credits);\r\nbreak;\r\ndefault:\r\nLIMIT_NETDEBUG(KERN_DEBUG"Phonet unknown PEP indication: %u\n",\r\n(unsigned int)hdr->data[1]);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (wake)\r\nsk->sk_write_space(sk);\r\nreturn 0;\r\n}\r\nstatic int pipe_rcv_created(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nstruct pnpipehdr *hdr = pnp_hdr(skb);\r\nu8 n_sb = hdr->data[0];\r\npn->rx_fc = pn->tx_fc = PN_LEGACY_FLOW_CONTROL;\r\n__skb_pull(skb, sizeof(*hdr));\r\nwhile (n_sb > 0) {\r\nu8 type, buf[2], len = sizeof(buf);\r\nu8 *data = pep_get_sb(skb, &type, &len, buf);\r\nif (data == NULL)\r\nreturn -EINVAL;\r\nswitch (type) {\r\ncase PN_PIPE_SB_NEGOTIATED_FC:\r\nif (len < 2 || (data[0] | data[1]) > 3)\r\nbreak;\r\npn->tx_fc = data[0] & 3;\r\npn->rx_fc = data[1] & 3;\r\nbreak;\r\n}\r\nn_sb--;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pipe_do_rcv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nstruct pnpipehdr *hdr = pnp_hdr(skb);\r\nstruct sk_buff_head *queue;\r\nint err = 0;\r\nBUG_ON(sk->sk_state == TCP_CLOSE_WAIT);\r\nswitch (hdr->message_id) {\r\ncase PNS_PEP_CONNECT_REQ:\r\npep_reject_conn(sk, skb, PN_PIPE_ERR_PEP_IN_USE, GFP_ATOMIC);\r\nbreak;\r\ncase PNS_PEP_DISCONNECT_REQ:\r\npep_reply(sk, skb, PN_PIPE_NO_ERROR, NULL, 0, GFP_ATOMIC);\r\nsk->sk_state = TCP_CLOSE_WAIT;\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_state_change(sk);\r\nbreak;\r\ncase PNS_PEP_ENABLE_REQ:\r\npep_reply(sk, skb, PN_PIPE_NO_ERROR, NULL, 0, GFP_ATOMIC);\r\nbreak;\r\ncase PNS_PEP_RESET_REQ:\r\nswitch (hdr->state_after_reset) {\r\ncase PN_PIPE_DISABLE:\r\npn->init_enable = 0;\r\nbreak;\r\ncase PN_PIPE_ENABLE:\r\npn->init_enable = 1;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\ncase PNS_PEP_DISABLE_REQ:\r\natomic_set(&pn->tx_credits, 0);\r\npep_reply(sk, skb, PN_PIPE_NO_ERROR, NULL, 0, GFP_ATOMIC);\r\nbreak;\r\ncase PNS_PEP_CTRL_REQ:\r\nif (skb_queue_len(&pn->ctrlreq_queue) >= PNPIPE_CTRLREQ_MAX) {\r\natomic_inc(&sk->sk_drops);\r\nbreak;\r\n}\r\n__skb_pull(skb, 4);\r\nqueue = &pn->ctrlreq_queue;\r\ngoto queue;\r\ncase PNS_PIPE_ALIGNED_DATA:\r\n__skb_pull(skb, 1);\r\ncase PNS_PIPE_DATA:\r\n__skb_pull(skb, 3);\r\nif (!pn_flow_safe(pn->rx_fc)) {\r\nerr = sock_queue_rcv_skb(sk, skb);\r\nif (!err)\r\nreturn NET_RX_SUCCESS;\r\nerr = -ENOBUFS;\r\nbreak;\r\n}\r\nif (pn->rx_credits == 0) {\r\natomic_inc(&sk->sk_drops);\r\nerr = -ENOBUFS;\r\nbreak;\r\n}\r\npn->rx_credits--;\r\nqueue = &sk->sk_receive_queue;\r\ngoto queue;\r\ncase PNS_PEP_STATUS_IND:\r\npipe_rcv_status(sk, skb);\r\nbreak;\r\ncase PNS_PIPE_REDIRECTED_IND:\r\nerr = pipe_rcv_created(sk, skb);\r\nbreak;\r\ncase PNS_PIPE_CREATED_IND:\r\nerr = pipe_rcv_created(sk, skb);\r\nif (err)\r\nbreak;\r\ncase PNS_PIPE_RESET_IND:\r\nif (!pn->init_enable)\r\nbreak;\r\ncase PNS_PIPE_ENABLED_IND:\r\nif (!pn_flow_safe(pn->tx_fc)) {\r\natomic_set(&pn->tx_credits, 1);\r\nsk->sk_write_space(sk);\r\n}\r\nif (sk->sk_state == TCP_ESTABLISHED)\r\nbreak;\r\nsk->sk_state = TCP_ESTABLISHED;\r\npipe_grant_credits(sk, GFP_ATOMIC);\r\nbreak;\r\ncase PNS_PIPE_DISABLED_IND:\r\nsk->sk_state = TCP_SYN_RECV;\r\npn->rx_credits = 0;\r\nbreak;\r\ndefault:\r\nLIMIT_NETDEBUG(KERN_DEBUG"Phonet unknown PEP message: %u\n",\r\nhdr->message_id);\r\nerr = -EINVAL;\r\n}\r\nout:\r\nkfree_skb(skb);\r\nreturn (err == -ENOBUFS) ? NET_RX_DROP : NET_RX_SUCCESS;\r\nqueue:\r\nskb->dev = NULL;\r\nskb_set_owner_r(skb, sk);\r\nskb_queue_tail(queue, skb);\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_data_ready(sk);\r\nreturn NET_RX_SUCCESS;\r\n}\r\nstatic void pipe_destruct(struct sock *sk)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nskb_queue_purge(&sk->sk_receive_queue);\r\nskb_queue_purge(&pn->ctrlreq_queue);\r\n}\r\nstatic u8 pipe_negotiate_fc(const u8 *fcs, unsigned int n)\r\n{\r\nunsigned int i;\r\nu8 final_fc = PN_NO_FLOW_CONTROL;\r\nfor (i = 0; i < n; i++) {\r\nu8 fc = fcs[i];\r\nif (fc > final_fc && fc < PN_MAX_FLOW_CONTROL)\r\nfinal_fc = fc;\r\n}\r\nreturn final_fc;\r\n}\r\nstatic int pep_connresp_rcv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nstruct pnpipehdr *hdr;\r\nu8 n_sb;\r\nif (!pskb_pull(skb, sizeof(*hdr) + 4))\r\nreturn -EINVAL;\r\nhdr = pnp_hdr(skb);\r\nif (hdr->error_code != PN_PIPE_NO_ERROR)\r\nreturn -ECONNREFUSED;\r\nn_sb = hdr->data[4];\r\nwhile (n_sb > 0) {\r\nu8 type, buf[6], len = sizeof(buf);\r\nconst u8 *data = pep_get_sb(skb, &type, &len, buf);\r\nif (data == NULL)\r\nreturn -EINVAL;\r\nswitch (type) {\r\ncase PN_PIPE_SB_REQUIRED_FC_TX:\r\nif (len < 2 || len < data[0])\r\nbreak;\r\npn->tx_fc = pipe_negotiate_fc(data + 2, len - 2);\r\nbreak;\r\ncase PN_PIPE_SB_PREFERRED_FC_RX:\r\nif (len < 2 || len < data[0])\r\nbreak;\r\npn->rx_fc = pipe_negotiate_fc(data + 2, len - 2);\r\nbreak;\r\n}\r\nn_sb--;\r\n}\r\nreturn pipe_handler_send_created_ind(sk);\r\n}\r\nstatic int pep_enableresp_rcv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct pnpipehdr *hdr = pnp_hdr(skb);\r\nif (hdr->error_code != PN_PIPE_NO_ERROR)\r\nreturn -ECONNREFUSED;\r\nreturn pep_indicate(sk, PNS_PIPE_ENABLED_IND, 0 ,\r\nNULL, 0, GFP_ATOMIC);\r\n}\r\nstatic void pipe_start_flow_control(struct sock *sk)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nif (!pn_flow_safe(pn->tx_fc)) {\r\natomic_set(&pn->tx_credits, 1);\r\nsk->sk_write_space(sk);\r\n}\r\npipe_grant_credits(sk, GFP_ATOMIC);\r\n}\r\nstatic int pipe_handler_do_rcv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nstruct pnpipehdr *hdr = pnp_hdr(skb);\r\nint err = NET_RX_SUCCESS;\r\nswitch (hdr->message_id) {\r\ncase PNS_PIPE_ALIGNED_DATA:\r\n__skb_pull(skb, 1);\r\ncase PNS_PIPE_DATA:\r\n__skb_pull(skb, 3);\r\nif (!pn_flow_safe(pn->rx_fc)) {\r\nerr = sock_queue_rcv_skb(sk, skb);\r\nif (!err)\r\nreturn NET_RX_SUCCESS;\r\nerr = NET_RX_DROP;\r\nbreak;\r\n}\r\nif (pn->rx_credits == 0) {\r\natomic_inc(&sk->sk_drops);\r\nerr = NET_RX_DROP;\r\nbreak;\r\n}\r\npn->rx_credits--;\r\nskb->dev = NULL;\r\nskb_set_owner_r(skb, sk);\r\nskb_queue_tail(&sk->sk_receive_queue, skb);\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_data_ready(sk);\r\nreturn NET_RX_SUCCESS;\r\ncase PNS_PEP_CONNECT_RESP:\r\nif (sk->sk_state != TCP_SYN_SENT)\r\nbreak;\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_state_change(sk);\r\nif (pep_connresp_rcv(sk, skb)) {\r\nsk->sk_state = TCP_CLOSE_WAIT;\r\nbreak;\r\n}\r\nif (pn->init_enable == PN_PIPE_DISABLE)\r\nsk->sk_state = TCP_SYN_RECV;\r\nelse {\r\nsk->sk_state = TCP_ESTABLISHED;\r\npipe_start_flow_control(sk);\r\n}\r\nbreak;\r\ncase PNS_PEP_ENABLE_RESP:\r\nif (sk->sk_state != TCP_SYN_SENT)\r\nbreak;\r\nif (pep_enableresp_rcv(sk, skb)) {\r\nsk->sk_state = TCP_CLOSE_WAIT;\r\nbreak;\r\n}\r\nsk->sk_state = TCP_ESTABLISHED;\r\npipe_start_flow_control(sk);\r\nbreak;\r\ncase PNS_PEP_DISCONNECT_RESP:\r\nbreak;\r\ncase PNS_PEP_STATUS_IND:\r\npipe_rcv_status(sk, skb);\r\nbreak;\r\n}\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nstatic struct sock *pep_find_pipe(const struct hlist_head *hlist,\r\nconst struct sockaddr_pn *dst,\r\nu8 pipe_handle)\r\n{\r\nstruct sock *sknode;\r\nu16 dobj = pn_sockaddr_get_object(dst);\r\nsk_for_each(sknode, hlist) {\r\nstruct pep_sock *pnnode = pep_sk(sknode);\r\nif (pnnode->pn_sk.sobject != dobj)\r\ncontinue;\r\nif (pnnode->pipe_handle != pipe_handle)\r\ncontinue;\r\nif (sknode->sk_state == TCP_CLOSE_WAIT)\r\ncontinue;\r\nsock_hold(sknode);\r\nreturn sknode;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int pep_do_rcv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nstruct sock *sknode;\r\nstruct pnpipehdr *hdr;\r\nstruct sockaddr_pn dst;\r\nu8 pipe_handle;\r\nif (!pskb_may_pull(skb, sizeof(*hdr)))\r\ngoto drop;\r\nhdr = pnp_hdr(skb);\r\npipe_handle = hdr->pipe_handle;\r\nif (pipe_handle == PN_PIPE_INVALID_HANDLE)\r\ngoto drop;\r\npn_skb_get_dst_sockaddr(skb, &dst);\r\nsknode = pep_find_pipe(&pn->hlist, &dst, pipe_handle);\r\nif (sknode)\r\nreturn sk_receive_skb(sknode, skb, 1);\r\nswitch (hdr->message_id) {\r\ncase PNS_PEP_CONNECT_REQ:\r\nif (sk->sk_state != TCP_LISTEN || sk_acceptq_is_full(sk)) {\r\npep_reject_conn(sk, skb, PN_PIPE_ERR_PEP_IN_USE,\r\nGFP_ATOMIC);\r\nbreak;\r\n}\r\nskb_queue_head(&sk->sk_receive_queue, skb);\r\nsk_acceptq_added(sk);\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_data_ready(sk);\r\nreturn NET_RX_SUCCESS;\r\ncase PNS_PEP_DISCONNECT_REQ:\r\npep_reply(sk, skb, PN_PIPE_NO_ERROR, NULL, 0, GFP_ATOMIC);\r\nbreak;\r\ncase PNS_PEP_CTRL_REQ:\r\npep_ctrlreq_error(sk, skb, PN_PIPE_INVALID_HANDLE, GFP_ATOMIC);\r\nbreak;\r\ncase PNS_PEP_RESET_REQ:\r\ncase PNS_PEP_ENABLE_REQ:\r\ncase PNS_PEP_DISABLE_REQ:\r\nbreak;\r\ndefault:\r\nif ((1 << sk->sk_state)\r\n& ~(TCPF_CLOSE|TCPF_LISTEN|TCPF_CLOSE_WAIT))\r\nreturn pipe_handler_do_rcv(sk, skb);\r\n}\r\ndrop:\r\nkfree_skb(skb);\r\nreturn NET_RX_SUCCESS;\r\n}\r\nstatic int pipe_do_remove(struct sock *sk)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nstruct pnpipehdr *ph;\r\nstruct sk_buff *skb;\r\nskb = pep_alloc_skb(sk, NULL, 0, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nph = pnp_hdr(skb);\r\nph->utid = 0;\r\nph->message_id = PNS_PIPE_REMOVE_REQ;\r\nph->pipe_handle = pn->pipe_handle;\r\nph->data[0] = PAD;\r\nreturn pn_skb_send(sk, skb, NULL);\r\n}\r\nstatic void pep_sock_close(struct sock *sk, long timeout)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nint ifindex = 0;\r\nsock_hold(sk);\r\nsk_common_release(sk);\r\nlock_sock(sk);\r\nif ((1 << sk->sk_state) & (TCPF_SYN_RECV|TCPF_ESTABLISHED)) {\r\nif (sk->sk_backlog_rcv == pipe_do_rcv)\r\npipe_do_remove(sk);\r\nelse\r\npipe_handler_request(sk, PNS_PEP_DISCONNECT_REQ, PAD,\r\nNULL, 0);\r\n}\r\nsk->sk_state = TCP_CLOSE;\r\nifindex = pn->ifindex;\r\npn->ifindex = 0;\r\nrelease_sock(sk);\r\nif (ifindex)\r\ngprs_detach(sk);\r\nsock_put(sk);\r\n}\r\nstatic struct sock *pep_sock_accept(struct sock *sk, int flags, int *errp)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk), *newpn;\r\nstruct sock *newsk = NULL;\r\nstruct sk_buff *skb;\r\nstruct pnpipehdr *hdr;\r\nstruct sockaddr_pn dst, src;\r\nint err;\r\nu16 peer_type;\r\nu8 pipe_handle, enabled, n_sb;\r\nu8 aligned = 0;\r\nskb = skb_recv_datagram(sk, 0, flags & O_NONBLOCK, errp);\r\nif (!skb)\r\nreturn NULL;\r\nlock_sock(sk);\r\nif (sk->sk_state != TCP_LISTEN) {\r\nerr = -EINVAL;\r\ngoto drop;\r\n}\r\nsk_acceptq_removed(sk);\r\nerr = -EPROTO;\r\nif (!pskb_may_pull(skb, sizeof(*hdr) + 4))\r\ngoto drop;\r\nhdr = pnp_hdr(skb);\r\npipe_handle = hdr->pipe_handle;\r\nswitch (hdr->state_after_connect) {\r\ncase PN_PIPE_DISABLE:\r\nenabled = 0;\r\nbreak;\r\ncase PN_PIPE_ENABLE:\r\nenabled = 1;\r\nbreak;\r\ndefault:\r\npep_reject_conn(sk, skb, PN_PIPE_ERR_INVALID_PARAM,\r\nGFP_KERNEL);\r\ngoto drop;\r\n}\r\npeer_type = hdr->other_pep_type << 8;\r\nn_sb = hdr->data[4];\r\nwhile (n_sb > 0) {\r\nu8 type, buf[1], len = sizeof(buf);\r\nconst u8 *data = pep_get_sb(skb, &type, &len, buf);\r\nif (data == NULL)\r\ngoto drop;\r\nswitch (type) {\r\ncase PN_PIPE_SB_CONNECT_REQ_PEP_SUB_TYPE:\r\nif (len < 1)\r\ngoto drop;\r\npeer_type = (peer_type & 0xff00) | data[0];\r\nbreak;\r\ncase PN_PIPE_SB_ALIGNED_DATA:\r\naligned = data[0] != 0;\r\nbreak;\r\n}\r\nn_sb--;\r\n}\r\nnewsk = pep_find_pipe(&pn->hlist, &dst, pipe_handle);\r\nif (unlikely(newsk)) {\r\n__sock_put(newsk);\r\nnewsk = NULL;\r\npep_reject_conn(sk, skb, PN_PIPE_ERR_PEP_IN_USE, GFP_KERNEL);\r\ngoto drop;\r\n}\r\nnewsk = sk_alloc(sock_net(sk), PF_PHONET, GFP_KERNEL, sk->sk_prot);\r\nif (!newsk) {\r\npep_reject_conn(sk, skb, PN_PIPE_ERR_OVERLOAD, GFP_KERNEL);\r\nerr = -ENOBUFS;\r\ngoto drop;\r\n}\r\nsock_init_data(NULL, newsk);\r\nnewsk->sk_state = TCP_SYN_RECV;\r\nnewsk->sk_backlog_rcv = pipe_do_rcv;\r\nnewsk->sk_protocol = sk->sk_protocol;\r\nnewsk->sk_destruct = pipe_destruct;\r\nnewpn = pep_sk(newsk);\r\npn_skb_get_dst_sockaddr(skb, &dst);\r\npn_skb_get_src_sockaddr(skb, &src);\r\nnewpn->pn_sk.sobject = pn_sockaddr_get_object(&dst);\r\nnewpn->pn_sk.dobject = pn_sockaddr_get_object(&src);\r\nnewpn->pn_sk.resource = pn_sockaddr_get_resource(&dst);\r\nsock_hold(sk);\r\nnewpn->listener = sk;\r\nskb_queue_head_init(&newpn->ctrlreq_queue);\r\nnewpn->pipe_handle = pipe_handle;\r\natomic_set(&newpn->tx_credits, 0);\r\nnewpn->ifindex = 0;\r\nnewpn->peer_type = peer_type;\r\nnewpn->rx_credits = 0;\r\nnewpn->rx_fc = newpn->tx_fc = PN_LEGACY_FLOW_CONTROL;\r\nnewpn->init_enable = enabled;\r\nnewpn->aligned = aligned;\r\nerr = pep_accept_conn(newsk, skb);\r\nif (err) {\r\nsock_put(newsk);\r\nnewsk = NULL;\r\ngoto drop;\r\n}\r\nsk_add_node(newsk, &pn->hlist);\r\ndrop:\r\nrelease_sock(sk);\r\nkfree_skb(skb);\r\n*errp = err;\r\nreturn newsk;\r\n}\r\nstatic int pep_sock_connect(struct sock *sk, struct sockaddr *addr, int len)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nint err;\r\nu8 data[4] = { 0 , PAD, PAD, PAD };\r\nif (pn->pipe_handle == PN_PIPE_INVALID_HANDLE)\r\npn->pipe_handle = 1;\r\nerr = pipe_handler_request(sk, PNS_PEP_CONNECT_REQ,\r\npn->init_enable, data, 4);\r\nif (err) {\r\npn->pipe_handle = PN_PIPE_INVALID_HANDLE;\r\nreturn err;\r\n}\r\nsk->sk_state = TCP_SYN_SENT;\r\nreturn 0;\r\n}\r\nstatic int pep_sock_enable(struct sock *sk, struct sockaddr *addr, int len)\r\n{\r\nint err;\r\nerr = pipe_handler_request(sk, PNS_PEP_ENABLE_REQ, PAD,\r\nNULL, 0);\r\nif (err)\r\nreturn err;\r\nsk->sk_state = TCP_SYN_SENT;\r\nreturn 0;\r\n}\r\nstatic int pep_ioctl(struct sock *sk, int cmd, unsigned long arg)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nint answ;\r\nint ret = -ENOIOCTLCMD;\r\nswitch (cmd) {\r\ncase SIOCINQ:\r\nif (sk->sk_state == TCP_LISTEN) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nlock_sock(sk);\r\nif (sock_flag(sk, SOCK_URGINLINE) &&\r\n!skb_queue_empty(&pn->ctrlreq_queue))\r\nansw = skb_peek(&pn->ctrlreq_queue)->len;\r\nelse if (!skb_queue_empty(&sk->sk_receive_queue))\r\nansw = skb_peek(&sk->sk_receive_queue)->len;\r\nelse\r\nansw = 0;\r\nrelease_sock(sk);\r\nret = put_user(answ, (int __user *)arg);\r\nbreak;\r\ncase SIOCPNENABLEPIPE:\r\nlock_sock(sk);\r\nif (sk->sk_state == TCP_SYN_SENT)\r\nret = -EBUSY;\r\nelse if (sk->sk_state == TCP_ESTABLISHED)\r\nret = -EISCONN;\r\nelse\r\nret = pep_sock_enable(sk, NULL, 0);\r\nrelease_sock(sk);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int pep_init(struct sock *sk)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nsk->sk_destruct = pipe_destruct;\r\nINIT_HLIST_HEAD(&pn->hlist);\r\npn->listener = NULL;\r\nskb_queue_head_init(&pn->ctrlreq_queue);\r\natomic_set(&pn->tx_credits, 0);\r\npn->ifindex = 0;\r\npn->peer_type = 0;\r\npn->pipe_handle = PN_PIPE_INVALID_HANDLE;\r\npn->rx_credits = 0;\r\npn->rx_fc = pn->tx_fc = PN_LEGACY_FLOW_CONTROL;\r\npn->init_enable = 1;\r\npn->aligned = 0;\r\nreturn 0;\r\n}\r\nstatic int pep_setsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nint val = 0, err = 0;\r\nif (level != SOL_PNPIPE)\r\nreturn -ENOPROTOOPT;\r\nif (optlen >= sizeof(int)) {\r\nif (get_user(val, (int __user *) optval))\r\nreturn -EFAULT;\r\n}\r\nlock_sock(sk);\r\nswitch (optname) {\r\ncase PNPIPE_ENCAP:\r\nif (val && val != PNPIPE_ENCAP_IP) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (!pn->ifindex == !val)\r\nbreak;\r\nif (!capable(CAP_NET_ADMIN)) {\r\nerr = -EPERM;\r\nbreak;\r\n}\r\nif (val) {\r\nrelease_sock(sk);\r\nerr = gprs_attach(sk);\r\nif (err > 0) {\r\npn->ifindex = err;\r\nerr = 0;\r\n}\r\n} else {\r\npn->ifindex = 0;\r\nrelease_sock(sk);\r\ngprs_detach(sk);\r\nerr = 0;\r\n}\r\ngoto out_norel;\r\ncase PNPIPE_HANDLE:\r\nif ((sk->sk_state == TCP_CLOSE) &&\r\n(val >= 0) && (val < PN_PIPE_INVALID_HANDLE))\r\npn->pipe_handle = val;\r\nelse\r\nerr = -EINVAL;\r\nbreak;\r\ncase PNPIPE_INITSTATE:\r\npn->init_enable = !!val;\r\nbreak;\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\n}\r\nrelease_sock(sk);\r\nout_norel:\r\nreturn err;\r\n}\r\nstatic int pep_getsockopt(struct sock *sk, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nint len, val;\r\nif (level != SOL_PNPIPE)\r\nreturn -ENOPROTOOPT;\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nswitch (optname) {\r\ncase PNPIPE_ENCAP:\r\nval = pn->ifindex ? PNPIPE_ENCAP_IP : PNPIPE_ENCAP_NONE;\r\nbreak;\r\ncase PNPIPE_IFINDEX:\r\nval = pn->ifindex;\r\nbreak;\r\ncase PNPIPE_HANDLE:\r\nval = pn->pipe_handle;\r\nif (val == PN_PIPE_INVALID_HANDLE)\r\nreturn -EINVAL;\r\nbreak;\r\ncase PNPIPE_INITSTATE:\r\nval = pn->init_enable;\r\nbreak;\r\ndefault:\r\nreturn -ENOPROTOOPT;\r\n}\r\nlen = min_t(unsigned int, sizeof(int), len);\r\nif (put_user(len, optlen))\r\nreturn -EFAULT;\r\nif (put_user(val, (int __user *) optval))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int pipe_skb_send(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nstruct pnpipehdr *ph;\r\nint err;\r\nif (pn_flow_safe(pn->tx_fc) &&\r\n!atomic_add_unless(&pn->tx_credits, -1, 0)) {\r\nkfree_skb(skb);\r\nreturn -ENOBUFS;\r\n}\r\nskb_push(skb, 3 + pn->aligned);\r\nskb_reset_transport_header(skb);\r\nph = pnp_hdr(skb);\r\nph->utid = 0;\r\nif (pn->aligned) {\r\nph->message_id = PNS_PIPE_ALIGNED_DATA;\r\nph->data[0] = 0;\r\n} else\r\nph->message_id = PNS_PIPE_DATA;\r\nph->pipe_handle = pn->pipe_handle;\r\nerr = pn_skb_send(sk, skb, NULL);\r\nif (err && pn_flow_safe(pn->tx_fc))\r\natomic_inc(&pn->tx_credits);\r\nreturn err;\r\n}\r\nstatic int pep_sendmsg(struct kiocb *iocb, struct sock *sk,\r\nstruct msghdr *msg, size_t len)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nstruct sk_buff *skb;\r\nlong timeo;\r\nint flags = msg->msg_flags;\r\nint err, done;\r\nif (len > USHRT_MAX)\r\nreturn -EMSGSIZE;\r\nif ((msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR|MSG_NOSIGNAL|\r\nMSG_CMSG_COMPAT)) ||\r\n!(msg->msg_flags & MSG_EOR))\r\nreturn -EOPNOTSUPP;\r\nskb = sock_alloc_send_skb(sk, MAX_PNPIPE_HEADER + len,\r\nflags & MSG_DONTWAIT, &err);\r\nif (!skb)\r\nreturn err;\r\nskb_reserve(skb, MAX_PHONET_HEADER + 3 + pn->aligned);\r\nerr = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);\r\nif (err < 0)\r\ngoto outfree;\r\nlock_sock(sk);\r\ntimeo = sock_sndtimeo(sk, flags & MSG_DONTWAIT);\r\nif ((1 << sk->sk_state) & (TCPF_LISTEN|TCPF_CLOSE)) {\r\nerr = -ENOTCONN;\r\ngoto out;\r\n}\r\nif (sk->sk_state != TCP_ESTABLISHED) {\r\ndisabled:\r\nerr = sk_stream_wait_connect(sk, &timeo);\r\nif (err)\r\ngoto out;\r\nif (sk->sk_state == TCP_CLOSE_WAIT) {\r\nerr = -ECONNRESET;\r\ngoto out;\r\n}\r\n}\r\nBUG_ON(sk->sk_state != TCP_ESTABLISHED);\r\ndone = atomic_read(&pn->tx_credits);\r\nwhile (!done) {\r\nDEFINE_WAIT(wait);\r\nif (!timeo) {\r\nerr = -EAGAIN;\r\ngoto out;\r\n}\r\nif (signal_pending(current)) {\r\nerr = sock_intr_errno(timeo);\r\ngoto out;\r\n}\r\nprepare_to_wait(sk_sleep(sk), &wait,\r\nTASK_INTERRUPTIBLE);\r\ndone = sk_wait_event(sk, &timeo, atomic_read(&pn->tx_credits));\r\nfinish_wait(sk_sleep(sk), &wait);\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\ngoto disabled;\r\n}\r\nerr = pipe_skb_send(sk, skb);\r\nif (err >= 0)\r\nerr = len;\r\nskb = NULL;\r\nout:\r\nrelease_sock(sk);\r\noutfree:\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nint pep_writeable(struct sock *sk)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nreturn atomic_read(&pn->tx_credits);\r\n}\r\nint pep_write(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *rskb, *fs;\r\nint flen = 0;\r\nif (pep_sk(sk)->aligned)\r\nreturn pipe_skb_send(sk, skb);\r\nrskb = alloc_skb(MAX_PNPIPE_HEADER, GFP_ATOMIC);\r\nif (!rskb) {\r\nkfree_skb(skb);\r\nreturn -ENOMEM;\r\n}\r\nskb_shinfo(rskb)->frag_list = skb;\r\nrskb->len += skb->len;\r\nrskb->data_len += rskb->len;\r\nrskb->truesize += rskb->len;\r\nskb_walk_frags(skb, fs)\r\nflen += fs->len;\r\nskb->next = skb_shinfo(skb)->frag_list;\r\nskb_frag_list_init(skb);\r\nskb->len -= flen;\r\nskb->data_len -= flen;\r\nskb->truesize -= flen;\r\nskb_reserve(rskb, MAX_PHONET_HEADER + 3);\r\nreturn pipe_skb_send(sk, rskb);\r\n}\r\nstruct sk_buff *pep_read(struct sock *sk)\r\n{\r\nstruct sk_buff *skb = skb_dequeue(&sk->sk_receive_queue);\r\nif (sk->sk_state == TCP_ESTABLISHED)\r\npipe_grant_credits(sk, GFP_ATOMIC);\r\nreturn skb;\r\n}\r\nstatic int pep_recvmsg(struct kiocb *iocb, struct sock *sk,\r\nstruct msghdr *msg, size_t len, int noblock,\r\nint flags, int *addr_len)\r\n{\r\nstruct sk_buff *skb;\r\nint err;\r\nif (flags & ~(MSG_OOB|MSG_PEEK|MSG_TRUNC|MSG_DONTWAIT|MSG_WAITALL|\r\nMSG_NOSIGNAL|MSG_CMSG_COMPAT))\r\nreturn -EOPNOTSUPP;\r\nif (unlikely(1 << sk->sk_state & (TCPF_LISTEN | TCPF_CLOSE)))\r\nreturn -ENOTCONN;\r\nif ((flags & MSG_OOB) || sock_flag(sk, SOCK_URGINLINE)) {\r\nstruct pep_sock *pn = pep_sk(sk);\r\nif (flags & MSG_PEEK)\r\nreturn -EOPNOTSUPP;\r\nskb = skb_dequeue(&pn->ctrlreq_queue);\r\nif (skb) {\r\npep_ctrlreq_error(sk, skb, PN_PIPE_NO_ERROR,\r\nGFP_KERNEL);\r\nmsg->msg_flags |= MSG_OOB;\r\ngoto copy;\r\n}\r\nif (flags & MSG_OOB)\r\nreturn -EINVAL;\r\n}\r\nskb = skb_recv_datagram(sk, flags, noblock, &err);\r\nlock_sock(sk);\r\nif (skb == NULL) {\r\nif (err == -ENOTCONN && sk->sk_state == TCP_CLOSE_WAIT)\r\nerr = -ECONNRESET;\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nif (sk->sk_state == TCP_ESTABLISHED)\r\npipe_grant_credits(sk, GFP_KERNEL);\r\nrelease_sock(sk);\r\ncopy:\r\nmsg->msg_flags |= MSG_EOR;\r\nif (skb->len > len)\r\nmsg->msg_flags |= MSG_TRUNC;\r\nelse\r\nlen = skb->len;\r\nerr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len);\r\nif (!err)\r\nerr = (flags & MSG_TRUNC) ? skb->len : len;\r\nskb_free_datagram(sk, skb);\r\nreturn err;\r\n}\r\nstatic void pep_sock_unhash(struct sock *sk)\r\n{\r\nstruct pep_sock *pn = pep_sk(sk);\r\nstruct sock *skparent = NULL;\r\nlock_sock(sk);\r\nif (pn->listener != NULL) {\r\nskparent = pn->listener;\r\npn->listener = NULL;\r\nrelease_sock(sk);\r\npn = pep_sk(skparent);\r\nlock_sock(skparent);\r\nsk_del_node_init(sk);\r\nsk = skparent;\r\n}\r\nif (hlist_empty(&pn->hlist))\r\npn_sock_unhash(&pn->pn_sk.sk);\r\nrelease_sock(sk);\r\nif (skparent)\r\nsock_put(skparent);\r\n}\r\nstatic int __init pep_register(void)\r\n{\r\nreturn phonet_proto_register(PN_PROTO_PIPE, &pep_pn_proto);\r\n}\r\nstatic void __exit pep_unregister(void)\r\n{\r\nphonet_proto_unregister(PN_PROTO_PIPE, &pep_pn_proto);\r\n}
