static bool CheckCondition(const u32 condition, const u32 hex)\r\n{\r\nu32 _board = (hex & 0x000000FF);\r\nu32 _interface = (hex & 0x0000FF00) >> 8;\r\nu32 _platform = (hex & 0x00FF0000) >> 16;\r\nu32 cond = condition;\r\nif (condition == 0xCDCDCDCD)\r\nreturn true;\r\ncond = condition & 0x000000FF;\r\nif ((_board == cond) && cond != 0x00)\r\nreturn false;\r\ncond = condition & 0x0000FF00;\r\ncond = cond >> 8;\r\nif ((_interface & cond) == 0 && cond != 0x07)\r\nreturn false;\r\ncond = condition & 0x00FF0000;\r\ncond = cond >> 16;\r\nif ((_platform & cond) == 0 && cond != 0x0F)\r\nreturn false;\r\nreturn true;\r\n}\r\nenum HAL_STATUS ODM_ReadAndConfig_AGC_TAB_1T_8188E(struct odm_dm_struct *dm_odm)\r\n{\r\nu32 hex = 0;\r\nu32 i = 0;\r\nu8 platform = dm_odm->SupportPlatform;\r\nu8 interfaceValue = dm_odm->SupportInterface;\r\nu8 board = dm_odm->BoardType;\r\nu32 arraylen = sizeof(array_agc_tab_1t_8188e)/sizeof(u32);\r\nu32 *array = array_agc_tab_1t_8188e;\r\nbool biol = false;\r\nstruct adapter *adapter = dm_odm->Adapter;\r\nstruct xmit_frame *pxmit_frame = NULL;\r\nu8 bndy_cnt = 1;\r\nenum HAL_STATUS rst = HAL_STATUS_SUCCESS;\r\nhex += board;\r\nhex += interfaceValue << 8;\r\nhex += platform << 16;\r\nhex += 0xFF000000;\r\nbiol = rtw_IOL_applied(adapter);\r\nif (biol) {\r\npxmit_frame = rtw_IOL_accquire_xmit_frame(adapter);\r\nif (pxmit_frame == NULL) {\r\npr_info("rtw_IOL_accquire_xmit_frame failed\n");\r\nreturn HAL_STATUS_FAILURE;\r\n}\r\n}\r\nfor (i = 0; i < arraylen; i += 2) {\r\nu32 v1 = array[i];\r\nu32 v2 = array[i+1];\r\nif (v1 < 0xCDCDCDCD) {\r\nif (biol) {\r\nif (rtw_IOL_cmd_boundary_handle(pxmit_frame))\r\nbndy_cnt++;\r\nrtw_IOL_append_WD_cmd(pxmit_frame, (u16)v1, v2, bMaskDWord);\r\n} else {\r\nodm_ConfigBB_AGC_8188E(dm_odm, v1, bMaskDWord, v2);\r\n}\r\ncontinue;\r\n} else {\r\nif (!CheckCondition(array[i], hex)) {\r\nread_next_pair(array, v1, v2, i);\r\nwhile (v2 != 0xDEAD &&\r\nv2 != 0xCDEF &&\r\nv2 != 0xCDCD && i < arraylen - 2)\r\nread_next_pair(array, v1, v2, i);\r\ni -= 2;\r\n} else {\r\nread_next_pair(array, v1, v2, i);\r\nwhile (v2 != 0xDEAD &&\r\nv2 != 0xCDEF &&\r\nv2 != 0xCDCD && i < arraylen - 2) {\r\nif (biol) {\r\nif (rtw_IOL_cmd_boundary_handle(pxmit_frame))\r\nbndy_cnt++;\r\nrtw_IOL_append_WD_cmd(pxmit_frame, (u16)v1, v2, bMaskDWord);\r\n} else {\r\nodm_ConfigBB_AGC_8188E(dm_odm, v1, bMaskDWord, v2);\r\n}\r\nread_next_pair(array, v1, v2, i);\r\n}\r\nwhile (v2 != 0xDEAD && i < arraylen - 2)\r\nread_next_pair(array, v1, v2, i);\r\n}\r\n}\r\n}\r\nif (biol) {\r\nif (!rtw_IOL_exec_cmds_sync(dm_odm->Adapter, pxmit_frame, 1000, bndy_cnt)) {\r\nprintk("~~~ %s IOL_exec_cmds Failed !!!\n", __func__);\r\nrst = HAL_STATUS_FAILURE;\r\n}\r\n}\r\nreturn rst;\r\n}\r\nenum HAL_STATUS ODM_ReadAndConfig_PHY_REG_1T_8188E(struct odm_dm_struct *dm_odm)\r\n{\r\nu32 hex = 0;\r\nu32 i = 0;\r\nu8 platform = dm_odm->SupportPlatform;\r\nu8 interfaceValue = dm_odm->SupportInterface;\r\nu8 board = dm_odm->BoardType;\r\nu32 arraylen = sizeof(array_phy_reg_1t_8188e)/sizeof(u32);\r\nu32 *array = array_phy_reg_1t_8188e;\r\nbool biol = false;\r\nstruct adapter *adapter = dm_odm->Adapter;\r\nstruct xmit_frame *pxmit_frame = NULL;\r\nu8 bndy_cnt = 1;\r\nenum HAL_STATUS rst = HAL_STATUS_SUCCESS;\r\nhex += board;\r\nhex += interfaceValue << 8;\r\nhex += platform << 16;\r\nhex += 0xFF000000;\r\nbiol = rtw_IOL_applied(adapter);\r\nif (biol) {\r\npxmit_frame = rtw_IOL_accquire_xmit_frame(adapter);\r\nif (pxmit_frame == NULL) {\r\npr_info("rtw_IOL_accquire_xmit_frame failed\n");\r\nreturn HAL_STATUS_FAILURE;\r\n}\r\n}\r\nfor (i = 0; i < arraylen; i += 2) {\r\nu32 v1 = array[i];\r\nu32 v2 = array[i+1];\r\nif (v1 < 0xCDCDCDCD) {\r\nif (biol) {\r\nif (rtw_IOL_cmd_boundary_handle(pxmit_frame))\r\nbndy_cnt++;\r\nif (v1 == 0xfe) {\r\nrtw_IOL_append_DELAY_MS_cmd(pxmit_frame, 50);\r\n} else if (v1 == 0xfd) {\r\nrtw_IOL_append_DELAY_MS_cmd(pxmit_frame, 5);\r\n} else if (v1 == 0xfc) {\r\nrtw_IOL_append_DELAY_MS_cmd(pxmit_frame, 1);\r\n} else if (v1 == 0xfb) {\r\nrtw_IOL_append_DELAY_US_cmd(pxmit_frame, 50);\r\n} else if (v1 == 0xfa) {\r\nrtw_IOL_append_DELAY_US_cmd(pxmit_frame, 5);\r\n} else if (v1 == 0xf9) {\r\nrtw_IOL_append_DELAY_US_cmd(pxmit_frame, 1);\r\n} else {\r\nif (v1 == 0xa24)\r\ndm_odm->RFCalibrateInfo.RegA24 = v2;\r\nrtw_IOL_append_WD_cmd(pxmit_frame, (u16)v1, v2, bMaskDWord);\r\n}\r\n} else {\r\nodm_ConfigBB_PHY_8188E(dm_odm, v1, bMaskDWord, v2);\r\n}\r\ncontinue;\r\n} else {\r\nif (!CheckCondition(array[i], hex)) {\r\nread_next_pair(array, v1, v2, i);\r\nwhile (v2 != 0xDEAD &&\r\nv2 != 0xCDEF &&\r\nv2 != 0xCDCD && i < arraylen - 2)\r\nread_next_pair(array, v1, v2, i);\r\ni -= 2;\r\n} else {\r\nread_next_pair(array, v1, v2, i);\r\nwhile (v2 != 0xDEAD &&\r\nv2 != 0xCDEF &&\r\nv2 != 0xCDCD && i < arraylen - 2) {\r\nif (biol) {\r\nif (rtw_IOL_cmd_boundary_handle(pxmit_frame))\r\nbndy_cnt++;\r\nif (v1 == 0xfe) {\r\nrtw_IOL_append_DELAY_MS_cmd(pxmit_frame, 50);\r\n} else if (v1 == 0xfd) {\r\nrtw_IOL_append_DELAY_MS_cmd(pxmit_frame, 5);\r\n} else if (v1 == 0xfc) {\r\nrtw_IOL_append_DELAY_MS_cmd(pxmit_frame, 1);\r\n} else if (v1 == 0xfb) {\r\nrtw_IOL_append_DELAY_US_cmd(pxmit_frame, 50);\r\n} else if (v1 == 0xfa) {\r\nrtw_IOL_append_DELAY_US_cmd(pxmit_frame, 5);\r\n} else if (v1 == 0xf9) {\r\nrtw_IOL_append_DELAY_US_cmd(pxmit_frame, 1);\r\n} else{\r\nif (v1 == 0xa24)\r\ndm_odm->RFCalibrateInfo.RegA24 = v2;\r\nrtw_IOL_append_WD_cmd(pxmit_frame, (u16)v1, v2, bMaskDWord);\r\n}\r\n} else {\r\nodm_ConfigBB_PHY_8188E(dm_odm, v1, bMaskDWord, v2);\r\n}\r\nread_next_pair(array, v1, v2, i);\r\n}\r\nwhile (v2 != 0xDEAD && i < arraylen - 2)\r\nread_next_pair(array, v1, v2, i);\r\n}\r\n}\r\n}\r\nif (biol) {\r\nif (!rtw_IOL_exec_cmds_sync(dm_odm->Adapter, pxmit_frame, 1000, bndy_cnt)) {\r\nrst = HAL_STATUS_FAILURE;\r\npr_info("~~~ IOL Config %s Failed !!!\n", __func__);\r\n}\r\n}\r\nreturn rst;\r\n}\r\nvoid ODM_ReadAndConfig_PHY_REG_PG_8188E(struct odm_dm_struct *dm_odm)\r\n{\r\nu32 hex;\r\nu32 i = 0;\r\nu8 platform = dm_odm->SupportPlatform;\r\nu8 interfaceValue = dm_odm->SupportInterface;\r\nu8 board = dm_odm->BoardType;\r\nu32 arraylen = sizeof(array_phy_reg_pg_8188e) / sizeof(u32);\r\nu32 *array = array_phy_reg_pg_8188e;\r\nhex = board + (interfaceValue << 8);\r\nhex += (platform << 16) + 0xFF000000;\r\nfor (i = 0; i < arraylen; i += 3) {\r\nu32 v1 = array[i];\r\nu32 v2 = array[i+1];\r\nu32 v3 = array[i+2];\r\nif (v1 < 0xCDCDCDCD) {\r\nodm_ConfigBB_PHY_REG_PG_8188E(dm_odm, v1, v2, v3);\r\ncontinue;\r\n} else {\r\nif (!CheckCondition(array[i], hex)) {\r\ni += 2;\r\nv1 = array[i];\r\nv2 = array[i+1];\r\nv3 = array[i+2];\r\nwhile (v2 != 0xDEAD) {\r\ni += 3;\r\nv1 = array[i];\r\nv2 = array[i+1];\r\nv3 = array[i+1];\r\n}\r\n}\r\n}\r\n}\r\n}
