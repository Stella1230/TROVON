static void batadv_gw_node_free_ref(struct batadv_gw_node *gw_node)\r\n{\r\nif (atomic_dec_and_test(&gw_node->refcount)) {\r\nbatadv_orig_node_free_ref(gw_node->orig_node);\r\nkfree_rcu(gw_node, rcu);\r\n}\r\n}\r\nstatic struct batadv_gw_node *\r\nbatadv_gw_get_selected_gw_node(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_gw_node *gw_node;\r\nrcu_read_lock();\r\ngw_node = rcu_dereference(bat_priv->gw.curr_gw);\r\nif (!gw_node)\r\ngoto out;\r\nif (!atomic_inc_not_zero(&gw_node->refcount))\r\ngw_node = NULL;\r\nout:\r\nrcu_read_unlock();\r\nreturn gw_node;\r\n}\r\nstruct batadv_orig_node *\r\nbatadv_gw_get_selected_orig(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_gw_node *gw_node;\r\nstruct batadv_orig_node *orig_node = NULL;\r\ngw_node = batadv_gw_get_selected_gw_node(bat_priv);\r\nif (!gw_node)\r\ngoto out;\r\nrcu_read_lock();\r\norig_node = gw_node->orig_node;\r\nif (!orig_node)\r\ngoto unlock;\r\nif (!atomic_inc_not_zero(&orig_node->refcount))\r\norig_node = NULL;\r\nunlock:\r\nrcu_read_unlock();\r\nout:\r\nif (gw_node)\r\nbatadv_gw_node_free_ref(gw_node);\r\nreturn orig_node;\r\n}\r\nstatic void batadv_gw_select(struct batadv_priv *bat_priv,\r\nstruct batadv_gw_node *new_gw_node)\r\n{\r\nstruct batadv_gw_node *curr_gw_node;\r\nspin_lock_bh(&bat_priv->gw.list_lock);\r\nif (new_gw_node && !atomic_inc_not_zero(&new_gw_node->refcount))\r\nnew_gw_node = NULL;\r\ncurr_gw_node = rcu_dereference_protected(bat_priv->gw.curr_gw, 1);\r\nrcu_assign_pointer(bat_priv->gw.curr_gw, new_gw_node);\r\nif (curr_gw_node)\r\nbatadv_gw_node_free_ref(curr_gw_node);\r\nspin_unlock_bh(&bat_priv->gw.list_lock);\r\n}\r\nvoid batadv_gw_reselect(struct batadv_priv *bat_priv)\r\n{\r\natomic_set(&bat_priv->gw.reselect, 1);\r\n}\r\nstatic struct batadv_gw_node *\r\nbatadv_gw_get_best_gw_node(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_neigh_node *router;\r\nstruct batadv_neigh_ifinfo *router_ifinfo;\r\nstruct batadv_gw_node *gw_node, *curr_gw = NULL;\r\nuint32_t max_gw_factor = 0, tmp_gw_factor = 0;\r\nuint32_t gw_divisor;\r\nuint8_t max_tq = 0;\r\nuint8_t tq_avg;\r\nstruct batadv_orig_node *orig_node;\r\ngw_divisor = BATADV_TQ_LOCAL_WINDOW_SIZE * BATADV_TQ_LOCAL_WINDOW_SIZE;\r\ngw_divisor *= 64;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(gw_node, &bat_priv->gw.list, list) {\r\nif (gw_node->deleted)\r\ncontinue;\r\norig_node = gw_node->orig_node;\r\nrouter = batadv_orig_router_get(orig_node, BATADV_IF_DEFAULT);\r\nif (!router)\r\ncontinue;\r\nrouter_ifinfo = batadv_neigh_ifinfo_get(router,\r\nBATADV_IF_DEFAULT);\r\nif (!router_ifinfo)\r\ngoto next;\r\nif (!atomic_inc_not_zero(&gw_node->refcount))\r\ngoto next;\r\ntq_avg = router_ifinfo->bat_iv.tq_avg;\r\nswitch (atomic_read(&bat_priv->gw_sel_class)) {\r\ncase 1:\r\ntmp_gw_factor = tq_avg * tq_avg;\r\ntmp_gw_factor *= gw_node->bandwidth_down;\r\ntmp_gw_factor *= 100 * 100;\r\ntmp_gw_factor /= gw_divisor;\r\nif ((tmp_gw_factor > max_gw_factor) ||\r\n((tmp_gw_factor == max_gw_factor) &&\r\n(tq_avg > max_tq))) {\r\nif (curr_gw)\r\nbatadv_gw_node_free_ref(curr_gw);\r\ncurr_gw = gw_node;\r\natomic_inc(&curr_gw->refcount);\r\n}\r\nbreak;\r\ndefault:\r\nif (tq_avg > max_tq) {\r\nif (curr_gw)\r\nbatadv_gw_node_free_ref(curr_gw);\r\ncurr_gw = gw_node;\r\natomic_inc(&curr_gw->refcount);\r\n}\r\nbreak;\r\n}\r\nif (tq_avg > max_tq)\r\nmax_tq = tq_avg;\r\nif (tmp_gw_factor > max_gw_factor)\r\nmax_gw_factor = tmp_gw_factor;\r\nbatadv_gw_node_free_ref(gw_node);\r\nnext:\r\nbatadv_neigh_node_free_ref(router);\r\nif (router_ifinfo)\r\nbatadv_neigh_ifinfo_free_ref(router_ifinfo);\r\n}\r\nrcu_read_unlock();\r\nreturn curr_gw;\r\n}\r\nvoid batadv_gw_check_client_stop(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_gw_node *curr_gw;\r\nif (atomic_read(&bat_priv->gw_mode) != BATADV_GW_MODE_CLIENT)\r\nreturn;\r\ncurr_gw = batadv_gw_get_selected_gw_node(bat_priv);\r\nif (!curr_gw)\r\nreturn;\r\nbatadv_gw_select(bat_priv, NULL);\r\nbatadv_throw_uevent(bat_priv, BATADV_UEV_GW, BATADV_UEV_DEL, NULL);\r\nbatadv_gw_node_free_ref(curr_gw);\r\n}\r\nvoid batadv_gw_election(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_gw_node *curr_gw = NULL, *next_gw = NULL;\r\nstruct batadv_neigh_node *router = NULL;\r\nstruct batadv_neigh_ifinfo *router_ifinfo = NULL;\r\nchar gw_addr[18] = { '\0' };\r\nif (atomic_read(&bat_priv->gw_mode) != BATADV_GW_MODE_CLIENT)\r\ngoto out;\r\ncurr_gw = batadv_gw_get_selected_gw_node(bat_priv);\r\nif (!batadv_atomic_dec_not_zero(&bat_priv->gw.reselect) && curr_gw)\r\ngoto out;\r\nnext_gw = batadv_gw_get_best_gw_node(bat_priv);\r\nif (curr_gw == next_gw)\r\ngoto out;\r\nif (next_gw) {\r\nsprintf(gw_addr, "%pM", next_gw->orig_node->orig);\r\nrouter = batadv_orig_router_get(next_gw->orig_node,\r\nBATADV_IF_DEFAULT);\r\nif (!router) {\r\nbatadv_gw_reselect(bat_priv);\r\ngoto out;\r\n}\r\nrouter_ifinfo = batadv_neigh_ifinfo_get(router,\r\nBATADV_IF_DEFAULT);\r\nif (!router_ifinfo) {\r\nbatadv_gw_reselect(bat_priv);\r\ngoto out;\r\n}\r\n}\r\nif ((curr_gw) && (!next_gw)) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Removing selected gateway - no gateway in range\n");\r\nbatadv_throw_uevent(bat_priv, BATADV_UEV_GW, BATADV_UEV_DEL,\r\nNULL);\r\n} else if ((!curr_gw) && (next_gw)) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Adding route to gateway %pM (bandwidth: %u.%u/%u.%u MBit, tq: %i)\n",\r\nnext_gw->orig_node->orig,\r\nnext_gw->bandwidth_down / 10,\r\nnext_gw->bandwidth_down % 10,\r\nnext_gw->bandwidth_up / 10,\r\nnext_gw->bandwidth_up % 10,\r\nrouter_ifinfo->bat_iv.tq_avg);\r\nbatadv_throw_uevent(bat_priv, BATADV_UEV_GW, BATADV_UEV_ADD,\r\ngw_addr);\r\n} else {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Changing route to gateway %pM (bandwidth: %u.%u/%u.%u MBit, tq: %i)\n",\r\nnext_gw->orig_node->orig,\r\nnext_gw->bandwidth_down / 10,\r\nnext_gw->bandwidth_down % 10,\r\nnext_gw->bandwidth_up / 10,\r\nnext_gw->bandwidth_up % 10,\r\nrouter_ifinfo->bat_iv.tq_avg);\r\nbatadv_throw_uevent(bat_priv, BATADV_UEV_GW, BATADV_UEV_CHANGE,\r\ngw_addr);\r\n}\r\nbatadv_gw_select(bat_priv, next_gw);\r\nout:\r\nif (curr_gw)\r\nbatadv_gw_node_free_ref(curr_gw);\r\nif (next_gw)\r\nbatadv_gw_node_free_ref(next_gw);\r\nif (router)\r\nbatadv_neigh_node_free_ref(router);\r\nif (router_ifinfo)\r\nbatadv_neigh_ifinfo_free_ref(router_ifinfo);\r\n}\r\nvoid batadv_gw_check_election(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_neigh_ifinfo *router_orig_tq = NULL;\r\nstruct batadv_neigh_ifinfo *router_gw_tq = NULL;\r\nstruct batadv_orig_node *curr_gw_orig;\r\nstruct batadv_neigh_node *router_gw = NULL, *router_orig = NULL;\r\nuint8_t gw_tq_avg, orig_tq_avg;\r\ncurr_gw_orig = batadv_gw_get_selected_orig(bat_priv);\r\nif (!curr_gw_orig)\r\ngoto reselect;\r\nrouter_gw = batadv_orig_router_get(curr_gw_orig, BATADV_IF_DEFAULT);\r\nif (!router_gw)\r\ngoto reselect;\r\nrouter_gw_tq = batadv_neigh_ifinfo_get(router_gw,\r\nBATADV_IF_DEFAULT);\r\nif (!router_gw_tq)\r\ngoto reselect;\r\nif (curr_gw_orig == orig_node)\r\ngoto out;\r\nrouter_orig = batadv_orig_router_get(orig_node, BATADV_IF_DEFAULT);\r\nif (!router_orig)\r\ngoto out;\r\nrouter_orig_tq = batadv_neigh_ifinfo_get(router_orig,\r\nBATADV_IF_DEFAULT);\r\nif (!router_orig_tq)\r\ngoto out;\r\ngw_tq_avg = router_gw_tq->bat_iv.tq_avg;\r\norig_tq_avg = router_orig_tq->bat_iv.tq_avg;\r\nif (orig_tq_avg < gw_tq_avg)\r\ngoto out;\r\nif ((atomic_read(&bat_priv->gw_sel_class) > 3) &&\r\n(orig_tq_avg - gw_tq_avg < atomic_read(&bat_priv->gw_sel_class)))\r\ngoto out;\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Restarting gateway selection: better gateway found (tq curr: %i, tq new: %i)\n",\r\ngw_tq_avg, orig_tq_avg);\r\nreselect:\r\nbatadv_gw_reselect(bat_priv);\r\nout:\r\nif (curr_gw_orig)\r\nbatadv_orig_node_free_ref(curr_gw_orig);\r\nif (router_gw)\r\nbatadv_neigh_node_free_ref(router_gw);\r\nif (router_orig)\r\nbatadv_neigh_node_free_ref(router_orig);\r\nif (router_gw_tq)\r\nbatadv_neigh_ifinfo_free_ref(router_gw_tq);\r\nif (router_orig_tq)\r\nbatadv_neigh_ifinfo_free_ref(router_orig_tq);\r\n}\r\nstatic void batadv_gw_node_add(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_tvlv_gateway_data *gateway)\r\n{\r\nstruct batadv_gw_node *gw_node;\r\nif (gateway->bandwidth_down == 0)\r\nreturn;\r\nif (!atomic_inc_not_zero(&orig_node->refcount))\r\nreturn;\r\ngw_node = kzalloc(sizeof(*gw_node), GFP_ATOMIC);\r\nif (!gw_node) {\r\nbatadv_orig_node_free_ref(orig_node);\r\nreturn;\r\n}\r\nINIT_HLIST_NODE(&gw_node->list);\r\ngw_node->orig_node = orig_node;\r\natomic_set(&gw_node->refcount, 1);\r\nspin_lock_bh(&bat_priv->gw.list_lock);\r\nhlist_add_head_rcu(&gw_node->list, &bat_priv->gw.list);\r\nspin_unlock_bh(&bat_priv->gw.list_lock);\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Found new gateway %pM -> gw bandwidth: %u.%u/%u.%u MBit\n",\r\norig_node->orig,\r\nntohl(gateway->bandwidth_down) / 10,\r\nntohl(gateway->bandwidth_down) % 10,\r\nntohl(gateway->bandwidth_up) / 10,\r\nntohl(gateway->bandwidth_up) % 10);\r\n}\r\nstatic struct batadv_gw_node *\r\nbatadv_gw_node_get(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_gw_node *gw_node_tmp, *gw_node = NULL;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(gw_node_tmp, &bat_priv->gw.list, list) {\r\nif (gw_node_tmp->orig_node != orig_node)\r\ncontinue;\r\nif (gw_node_tmp->deleted)\r\ncontinue;\r\nif (!atomic_inc_not_zero(&gw_node_tmp->refcount))\r\ncontinue;\r\ngw_node = gw_node_tmp;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn gw_node;\r\n}\r\nvoid batadv_gw_node_update(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_tvlv_gateway_data *gateway)\r\n{\r\nstruct batadv_gw_node *gw_node, *curr_gw = NULL;\r\ngw_node = batadv_gw_node_get(bat_priv, orig_node);\r\nif (!gw_node) {\r\nbatadv_gw_node_add(bat_priv, orig_node, gateway);\r\ngoto out;\r\n}\r\nif ((gw_node->bandwidth_down == ntohl(gateway->bandwidth_down)) &&\r\n(gw_node->bandwidth_up == ntohl(gateway->bandwidth_up)))\r\ngoto out;\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Gateway bandwidth of originator %pM changed from %u.%u/%u.%u MBit to %u.%u/%u.%u MBit\n",\r\norig_node->orig,\r\ngw_node->bandwidth_down / 10,\r\ngw_node->bandwidth_down % 10,\r\ngw_node->bandwidth_up / 10,\r\ngw_node->bandwidth_up % 10,\r\nntohl(gateway->bandwidth_down) / 10,\r\nntohl(gateway->bandwidth_down) % 10,\r\nntohl(gateway->bandwidth_up) / 10,\r\nntohl(gateway->bandwidth_up) % 10);\r\ngw_node->bandwidth_down = ntohl(gateway->bandwidth_down);\r\ngw_node->bandwidth_up = ntohl(gateway->bandwidth_up);\r\ngw_node->deleted = 0;\r\nif (ntohl(gateway->bandwidth_down) == 0) {\r\ngw_node->deleted = jiffies;\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Gateway %pM removed from gateway list\n",\r\norig_node->orig);\r\ncurr_gw = batadv_gw_get_selected_gw_node(bat_priv);\r\nif (gw_node == curr_gw)\r\nbatadv_gw_reselect(bat_priv);\r\n}\r\nout:\r\nif (curr_gw)\r\nbatadv_gw_node_free_ref(curr_gw);\r\nif (gw_node)\r\nbatadv_gw_node_free_ref(gw_node);\r\n}\r\nvoid batadv_gw_node_delete(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_tvlv_gateway_data gateway;\r\ngateway.bandwidth_down = 0;\r\ngateway.bandwidth_up = 0;\r\nbatadv_gw_node_update(bat_priv, orig_node, &gateway);\r\n}\r\nvoid batadv_gw_node_purge(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_gw_node *gw_node, *curr_gw;\r\nstruct hlist_node *node_tmp;\r\nunsigned long timeout = msecs_to_jiffies(2 * BATADV_PURGE_TIMEOUT);\r\nint do_reselect = 0;\r\ncurr_gw = batadv_gw_get_selected_gw_node(bat_priv);\r\nspin_lock_bh(&bat_priv->gw.list_lock);\r\nhlist_for_each_entry_safe(gw_node, node_tmp,\r\n&bat_priv->gw.list, list) {\r\nif (((!gw_node->deleted) ||\r\n(time_before(jiffies, gw_node->deleted + timeout))) &&\r\natomic_read(&bat_priv->mesh_state) == BATADV_MESH_ACTIVE)\r\ncontinue;\r\nif (curr_gw == gw_node)\r\ndo_reselect = 1;\r\nhlist_del_rcu(&gw_node->list);\r\nbatadv_gw_node_free_ref(gw_node);\r\n}\r\nspin_unlock_bh(&bat_priv->gw.list_lock);\r\nif (do_reselect)\r\nbatadv_gw_reselect(bat_priv);\r\nif (curr_gw)\r\nbatadv_gw_node_free_ref(curr_gw);\r\n}\r\nstatic int batadv_write_buffer_text(struct batadv_priv *bat_priv,\r\nstruct seq_file *seq,\r\nconst struct batadv_gw_node *gw_node)\r\n{\r\nstruct batadv_gw_node *curr_gw;\r\nstruct batadv_neigh_node *router;\r\nstruct batadv_neigh_ifinfo *router_ifinfo = NULL;\r\nint ret = -1;\r\nrouter = batadv_orig_router_get(gw_node->orig_node, BATADV_IF_DEFAULT);\r\nif (!router)\r\ngoto out;\r\nrouter_ifinfo = batadv_neigh_ifinfo_get(router, BATADV_IF_DEFAULT);\r\nif (!router_ifinfo)\r\ngoto out;\r\ncurr_gw = batadv_gw_get_selected_gw_node(bat_priv);\r\nret = seq_printf(seq, "%s %pM (%3i) %pM [%10s]: %u.%u/%u.%u MBit\n",\r\n(curr_gw == gw_node ? "=>" : " "),\r\ngw_node->orig_node->orig,\r\nrouter_ifinfo->bat_iv.tq_avg, router->addr,\r\nrouter->if_incoming->net_dev->name,\r\ngw_node->bandwidth_down / 10,\r\ngw_node->bandwidth_down % 10,\r\ngw_node->bandwidth_up / 10,\r\ngw_node->bandwidth_up % 10);\r\nif (curr_gw)\r\nbatadv_gw_node_free_ref(curr_gw);\r\nout:\r\nif (router_ifinfo)\r\nbatadv_neigh_ifinfo_free_ref(router_ifinfo);\r\nif (router)\r\nbatadv_neigh_node_free_ref(router);\r\nreturn ret;\r\n}\r\nint batadv_gw_client_seq_print_text(struct seq_file *seq, void *offset)\r\n{\r\nstruct net_device *net_dev = (struct net_device *)seq->private;\r\nstruct batadv_priv *bat_priv = netdev_priv(net_dev);\r\nstruct batadv_hard_iface *primary_if;\r\nstruct batadv_gw_node *gw_node;\r\nint gw_count = 0;\r\nprimary_if = batadv_seq_print_text_primary_if_get(seq);\r\nif (!primary_if)\r\ngoto out;\r\nseq_printf(seq,\r\n" %-12s (%s/%i) %17s [%10s]: advertised uplink bandwidth ... [B.A.T.M.A.N. adv %s, MainIF/MAC: %s/%pM (%s)]\n",\r\n"Gateway", "#", BATADV_TQ_MAX_VALUE, "Nexthop", "outgoingIF",\r\nBATADV_SOURCE_VERSION, primary_if->net_dev->name,\r\nprimary_if->net_dev->dev_addr, net_dev->name);\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(gw_node, &bat_priv->gw.list, list) {\r\nif (gw_node->deleted)\r\ncontinue;\r\nif (batadv_write_buffer_text(bat_priv, seq, gw_node) < 0)\r\ncontinue;\r\ngw_count++;\r\n}\r\nrcu_read_unlock();\r\nif (gw_count == 0)\r\nseq_puts(seq, "No gateways in range ...\n");\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_free_ref(primary_if);\r\nreturn 0;\r\n}\r\nenum batadv_dhcp_recipient\r\nbatadv_gw_dhcp_recipient_get(struct sk_buff *skb, unsigned int *header_len,\r\nuint8_t *chaddr)\r\n{\r\nenum batadv_dhcp_recipient ret = BATADV_DHCP_NO;\r\nstruct ethhdr *ethhdr;\r\nstruct iphdr *iphdr;\r\nstruct ipv6hdr *ipv6hdr;\r\nstruct udphdr *udphdr;\r\nstruct vlan_ethhdr *vhdr;\r\nint chaddr_offset;\r\n__be16 proto;\r\nuint8_t *p;\r\nif (!pskb_may_pull(skb, *header_len + ETH_HLEN))\r\nreturn BATADV_DHCP_NO;\r\nethhdr = eth_hdr(skb);\r\nproto = ethhdr->h_proto;\r\n*header_len += ETH_HLEN;\r\nif (proto == htons(ETH_P_8021Q)) {\r\nif (!pskb_may_pull(skb, *header_len + VLAN_HLEN))\r\nreturn BATADV_DHCP_NO;\r\nvhdr = vlan_eth_hdr(skb);\r\nproto = vhdr->h_vlan_encapsulated_proto;\r\n*header_len += VLAN_HLEN;\r\n}\r\nswitch (proto) {\r\ncase htons(ETH_P_IP):\r\nif (!pskb_may_pull(skb, *header_len + sizeof(*iphdr)))\r\nreturn BATADV_DHCP_NO;\r\niphdr = (struct iphdr *)(skb->data + *header_len);\r\n*header_len += iphdr->ihl * 4;\r\nif (iphdr->protocol != IPPROTO_UDP)\r\nreturn BATADV_DHCP_NO;\r\nbreak;\r\ncase htons(ETH_P_IPV6):\r\nif (!pskb_may_pull(skb, *header_len + sizeof(*ipv6hdr)))\r\nreturn BATADV_DHCP_NO;\r\nipv6hdr = (struct ipv6hdr *)(skb->data + *header_len);\r\n*header_len += sizeof(*ipv6hdr);\r\nif (ipv6hdr->nexthdr != IPPROTO_UDP)\r\nreturn BATADV_DHCP_NO;\r\nbreak;\r\ndefault:\r\nreturn BATADV_DHCP_NO;\r\n}\r\nif (!pskb_may_pull(skb, *header_len + sizeof(*udphdr)))\r\nreturn BATADV_DHCP_NO;\r\nethhdr = eth_hdr(skb);\r\nif (ntohs(ethhdr->h_proto) == ETH_P_8021Q)\r\nethhdr = (struct ethhdr *)(skb->data + VLAN_HLEN);\r\nudphdr = (struct udphdr *)(skb->data + *header_len);\r\n*header_len += sizeof(*udphdr);\r\nswitch (proto) {\r\ncase htons(ETH_P_IP):\r\nif (udphdr->dest == htons(67))\r\nret = BATADV_DHCP_TO_SERVER;\r\nelse if (udphdr->source == htons(67))\r\nret = BATADV_DHCP_TO_CLIENT;\r\nbreak;\r\ncase htons(ETH_P_IPV6):\r\nif (udphdr->dest == htons(547))\r\nret = BATADV_DHCP_TO_SERVER;\r\nelse if (udphdr->source == htons(547))\r\nret = BATADV_DHCP_TO_CLIENT;\r\nbreak;\r\n}\r\nchaddr_offset = *header_len + BATADV_DHCP_CHADDR_OFFSET;\r\nif (ret == BATADV_DHCP_TO_CLIENT &&\r\npskb_may_pull(skb, chaddr_offset + ETH_ALEN)) {\r\np = skb->data + *header_len + BATADV_DHCP_HTYPE_OFFSET;\r\nif (*p != BATADV_DHCP_HTYPE_ETHERNET)\r\nreturn BATADV_DHCP_NO;\r\np = skb->data + *header_len + BATADV_DHCP_HLEN_OFFSET;\r\nif (*p != ETH_ALEN)\r\nreturn BATADV_DHCP_NO;\r\nether_addr_copy(chaddr, skb->data + chaddr_offset);\r\n}\r\nreturn ret;\r\n}\r\nbool batadv_gw_out_of_range(struct batadv_priv *bat_priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct batadv_neigh_node *neigh_curr = NULL, *neigh_old = NULL;\r\nstruct batadv_orig_node *orig_dst_node = NULL;\r\nstruct batadv_gw_node *gw_node = NULL, *curr_gw = NULL;\r\nstruct batadv_neigh_ifinfo *curr_ifinfo, *old_ifinfo;\r\nstruct ethhdr *ethhdr = (struct ethhdr *)skb->data;\r\nbool out_of_range = false;\r\nuint8_t curr_tq_avg;\r\nunsigned short vid;\r\nvid = batadv_get_vid(skb, 0);\r\norig_dst_node = batadv_transtable_search(bat_priv, ethhdr->h_source,\r\nethhdr->h_dest, vid);\r\nif (!orig_dst_node)\r\ngoto out;\r\ngw_node = batadv_gw_node_get(bat_priv, orig_dst_node);\r\nif (!gw_node->bandwidth_down == 0)\r\ngoto out;\r\nswitch (atomic_read(&bat_priv->gw_mode)) {\r\ncase BATADV_GW_MODE_SERVER:\r\ncurr_tq_avg = BATADV_TQ_MAX_VALUE;\r\nbreak;\r\ncase BATADV_GW_MODE_CLIENT:\r\ncurr_gw = batadv_gw_get_selected_gw_node(bat_priv);\r\nif (!curr_gw)\r\ngoto out;\r\nif (curr_gw->orig_node == orig_dst_node)\r\ngoto out;\r\nneigh_curr = batadv_find_router(bat_priv, curr_gw->orig_node,\r\nNULL);\r\nif (!neigh_curr)\r\ngoto out;\r\ncurr_ifinfo = batadv_neigh_ifinfo_get(neigh_curr,\r\nBATADV_IF_DEFAULT);\r\nif (!curr_ifinfo)\r\ngoto out;\r\ncurr_tq_avg = curr_ifinfo->bat_iv.tq_avg;\r\nbatadv_neigh_ifinfo_free_ref(curr_ifinfo);\r\nbreak;\r\ncase BATADV_GW_MODE_OFF:\r\ndefault:\r\ngoto out;\r\n}\r\nneigh_old = batadv_find_router(bat_priv, orig_dst_node, NULL);\r\nif (!neigh_old)\r\ngoto out;\r\nold_ifinfo = batadv_neigh_ifinfo_get(neigh_old, BATADV_IF_DEFAULT);\r\nif (!old_ifinfo)\r\ngoto out;\r\nif ((curr_tq_avg - old_ifinfo->bat_iv.tq_avg) > BATADV_GW_THRESHOLD)\r\nout_of_range = true;\r\nbatadv_neigh_ifinfo_free_ref(old_ifinfo);\r\nout:\r\nif (orig_dst_node)\r\nbatadv_orig_node_free_ref(orig_dst_node);\r\nif (curr_gw)\r\nbatadv_gw_node_free_ref(curr_gw);\r\nif (gw_node)\r\nbatadv_gw_node_free_ref(gw_node);\r\nif (neigh_old)\r\nbatadv_neigh_node_free_ref(neigh_old);\r\nif (neigh_curr)\r\nbatadv_neigh_node_free_ref(neigh_curr);\r\nreturn out_of_range;\r\n}
