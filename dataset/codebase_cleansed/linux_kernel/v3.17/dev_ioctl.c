static int dev_ifname(struct net *net, struct ifreq __user *arg)\r\n{\r\nstruct ifreq ifr;\r\nint error;\r\nif (copy_from_user(&ifr, arg, sizeof(struct ifreq)))\r\nreturn -EFAULT;\r\nerror = netdev_get_name(net, ifr.ifr_name, ifr.ifr_ifindex);\r\nif (error)\r\nreturn error;\r\nif (copy_to_user(arg, &ifr, sizeof(struct ifreq)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nint register_gifconf(unsigned int family, gifconf_func_t *gifconf)\r\n{\r\nif (family >= NPROTO)\r\nreturn -EINVAL;\r\ngifconf_list[family] = gifconf;\r\nreturn 0;\r\n}\r\nstatic int dev_ifconf(struct net *net, char __user *arg)\r\n{\r\nstruct ifconf ifc;\r\nstruct net_device *dev;\r\nchar __user *pos;\r\nint len;\r\nint total;\r\nint i;\r\nif (copy_from_user(&ifc, arg, sizeof(struct ifconf)))\r\nreturn -EFAULT;\r\npos = ifc.ifc_buf;\r\nlen = ifc.ifc_len;\r\ntotal = 0;\r\nfor_each_netdev(net, dev) {\r\nfor (i = 0; i < NPROTO; i++) {\r\nif (gifconf_list[i]) {\r\nint done;\r\nif (!pos)\r\ndone = gifconf_list[i](dev, NULL, 0);\r\nelse\r\ndone = gifconf_list[i](dev, pos + total,\r\nlen - total);\r\nif (done < 0)\r\nreturn -EFAULT;\r\ntotal += done;\r\n}\r\n}\r\n}\r\nifc.ifc_len = total;\r\nreturn copy_to_user(arg, &ifc, sizeof(struct ifconf)) ? -EFAULT : 0;\r\n}\r\nstatic int dev_ifsioc_locked(struct net *net, struct ifreq *ifr, unsigned int cmd)\r\n{\r\nint err;\r\nstruct net_device *dev = dev_get_by_name_rcu(net, ifr->ifr_name);\r\nif (!dev)\r\nreturn -ENODEV;\r\nswitch (cmd) {\r\ncase SIOCGIFFLAGS:\r\nifr->ifr_flags = (short) dev_get_flags(dev);\r\nreturn 0;\r\ncase SIOCGIFMETRIC:\r\nifr->ifr_metric = 0;\r\nreturn 0;\r\ncase SIOCGIFMTU:\r\nifr->ifr_mtu = dev->mtu;\r\nreturn 0;\r\ncase SIOCGIFHWADDR:\r\nif (!dev->addr_len)\r\nmemset(ifr->ifr_hwaddr.sa_data, 0, sizeof ifr->ifr_hwaddr.sa_data);\r\nelse\r\nmemcpy(ifr->ifr_hwaddr.sa_data, dev->dev_addr,\r\nmin(sizeof ifr->ifr_hwaddr.sa_data, (size_t) dev->addr_len));\r\nifr->ifr_hwaddr.sa_family = dev->type;\r\nreturn 0;\r\ncase SIOCGIFSLAVE:\r\nerr = -EINVAL;\r\nbreak;\r\ncase SIOCGIFMAP:\r\nifr->ifr_map.mem_start = dev->mem_start;\r\nifr->ifr_map.mem_end = dev->mem_end;\r\nifr->ifr_map.base_addr = dev->base_addr;\r\nifr->ifr_map.irq = dev->irq;\r\nifr->ifr_map.dma = dev->dma;\r\nifr->ifr_map.port = dev->if_port;\r\nreturn 0;\r\ncase SIOCGIFINDEX:\r\nifr->ifr_ifindex = dev->ifindex;\r\nreturn 0;\r\ncase SIOCGIFTXQLEN:\r\nifr->ifr_qlen = dev->tx_queue_len;\r\nreturn 0;\r\ndefault:\r\nWARN_ON(1);\r\nerr = -ENOTTY;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int net_hwtstamp_validate(struct ifreq *ifr)\r\n{\r\nstruct hwtstamp_config cfg;\r\nenum hwtstamp_tx_types tx_type;\r\nenum hwtstamp_rx_filters rx_filter;\r\nint tx_type_valid = 0;\r\nint rx_filter_valid = 0;\r\nif (copy_from_user(&cfg, ifr->ifr_data, sizeof(cfg)))\r\nreturn -EFAULT;\r\nif (cfg.flags)\r\nreturn -EINVAL;\r\ntx_type = cfg.tx_type;\r\nrx_filter = cfg.rx_filter;\r\nswitch (tx_type) {\r\ncase HWTSTAMP_TX_OFF:\r\ncase HWTSTAMP_TX_ON:\r\ncase HWTSTAMP_TX_ONESTEP_SYNC:\r\ntx_type_valid = 1;\r\nbreak;\r\n}\r\nswitch (rx_filter) {\r\ncase HWTSTAMP_FILTER_NONE:\r\ncase HWTSTAMP_FILTER_ALL:\r\ncase HWTSTAMP_FILTER_SOME:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\r\nrx_filter_valid = 1;\r\nbreak;\r\n}\r\nif (!tx_type_valid || !rx_filter_valid)\r\nreturn -ERANGE;\r\nreturn 0;\r\n}\r\nstatic int dev_ifsioc(struct net *net, struct ifreq *ifr, unsigned int cmd)\r\n{\r\nint err;\r\nstruct net_device *dev = __dev_get_by_name(net, ifr->ifr_name);\r\nconst struct net_device_ops *ops;\r\nif (!dev)\r\nreturn -ENODEV;\r\nops = dev->netdev_ops;\r\nswitch (cmd) {\r\ncase SIOCSIFFLAGS:\r\nreturn dev_change_flags(dev, ifr->ifr_flags);\r\ncase SIOCSIFMETRIC:\r\nreturn -EOPNOTSUPP;\r\ncase SIOCSIFMTU:\r\nreturn dev_set_mtu(dev, ifr->ifr_mtu);\r\ncase SIOCSIFHWADDR:\r\nreturn dev_set_mac_address(dev, &ifr->ifr_hwaddr);\r\ncase SIOCSIFHWBROADCAST:\r\nif (ifr->ifr_hwaddr.sa_family != dev->type)\r\nreturn -EINVAL;\r\nmemcpy(dev->broadcast, ifr->ifr_hwaddr.sa_data,\r\nmin(sizeof ifr->ifr_hwaddr.sa_data, (size_t) dev->addr_len));\r\ncall_netdevice_notifiers(NETDEV_CHANGEADDR, dev);\r\nreturn 0;\r\ncase SIOCSIFMAP:\r\nif (ops->ndo_set_config) {\r\nif (!netif_device_present(dev))\r\nreturn -ENODEV;\r\nreturn ops->ndo_set_config(dev, &ifr->ifr_map);\r\n}\r\nreturn -EOPNOTSUPP;\r\ncase SIOCADDMULTI:\r\nif (!ops->ndo_set_rx_mode ||\r\nifr->ifr_hwaddr.sa_family != AF_UNSPEC)\r\nreturn -EINVAL;\r\nif (!netif_device_present(dev))\r\nreturn -ENODEV;\r\nreturn dev_mc_add_global(dev, ifr->ifr_hwaddr.sa_data);\r\ncase SIOCDELMULTI:\r\nif (!ops->ndo_set_rx_mode ||\r\nifr->ifr_hwaddr.sa_family != AF_UNSPEC)\r\nreturn -EINVAL;\r\nif (!netif_device_present(dev))\r\nreturn -ENODEV;\r\nreturn dev_mc_del_global(dev, ifr->ifr_hwaddr.sa_data);\r\ncase SIOCSIFTXQLEN:\r\nif (ifr->ifr_qlen < 0)\r\nreturn -EINVAL;\r\ndev->tx_queue_len = ifr->ifr_qlen;\r\nreturn 0;\r\ncase SIOCSIFNAME:\r\nifr->ifr_newname[IFNAMSIZ-1] = '\0';\r\nreturn dev_change_name(dev, ifr->ifr_newname);\r\ncase SIOCSHWTSTAMP:\r\nerr = net_hwtstamp_validate(ifr);\r\nif (err)\r\nreturn err;\r\ndefault:\r\nif ((cmd >= SIOCDEVPRIVATE &&\r\ncmd <= SIOCDEVPRIVATE + 15) ||\r\ncmd == SIOCBONDENSLAVE ||\r\ncmd == SIOCBONDRELEASE ||\r\ncmd == SIOCBONDSETHWADDR ||\r\ncmd == SIOCBONDSLAVEINFOQUERY ||\r\ncmd == SIOCBONDINFOQUERY ||\r\ncmd == SIOCBONDCHANGEACTIVE ||\r\ncmd == SIOCGMIIPHY ||\r\ncmd == SIOCGMIIREG ||\r\ncmd == SIOCSMIIREG ||\r\ncmd == SIOCBRADDIF ||\r\ncmd == SIOCBRDELIF ||\r\ncmd == SIOCSHWTSTAMP ||\r\ncmd == SIOCGHWTSTAMP ||\r\ncmd == SIOCWANDEV) {\r\nerr = -EOPNOTSUPP;\r\nif (ops->ndo_do_ioctl) {\r\nif (netif_device_present(dev))\r\nerr = ops->ndo_do_ioctl(dev, ifr, cmd);\r\nelse\r\nerr = -ENODEV;\r\n}\r\n} else\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nvoid dev_load(struct net *net, const char *name)\r\n{\r\nstruct net_device *dev;\r\nint no_module;\r\nrcu_read_lock();\r\ndev = dev_get_by_name_rcu(net, name);\r\nrcu_read_unlock();\r\nno_module = !dev;\r\nif (no_module && capable(CAP_NET_ADMIN))\r\nno_module = request_module("netdev-%s", name);\r\nif (no_module && capable(CAP_SYS_MODULE)) {\r\nif (!request_module("%s", name))\r\npr_warn("Loading kernel module for a network device with CAP_SYS_MODULE (deprecated). Use CAP_NET_ADMIN and alias netdev-%s instead.\n",\r\nname);\r\n}\r\n}\r\nint dev_ioctl(struct net *net, unsigned int cmd, void __user *arg)\r\n{\r\nstruct ifreq ifr;\r\nint ret;\r\nchar *colon;\r\nif (cmd == SIOCGIFCONF) {\r\nrtnl_lock();\r\nret = dev_ifconf(net, (char __user *) arg);\r\nrtnl_unlock();\r\nreturn ret;\r\n}\r\nif (cmd == SIOCGIFNAME)\r\nreturn dev_ifname(net, (struct ifreq __user *)arg);\r\nif (copy_from_user(&ifr, arg, sizeof(struct ifreq)))\r\nreturn -EFAULT;\r\nifr.ifr_name[IFNAMSIZ-1] = 0;\r\ncolon = strchr(ifr.ifr_name, ':');\r\nif (colon)\r\n*colon = 0;\r\nswitch (cmd) {\r\ncase SIOCGIFFLAGS:\r\ncase SIOCGIFMETRIC:\r\ncase SIOCGIFMTU:\r\ncase SIOCGIFHWADDR:\r\ncase SIOCGIFSLAVE:\r\ncase SIOCGIFMAP:\r\ncase SIOCGIFINDEX:\r\ncase SIOCGIFTXQLEN:\r\ndev_load(net, ifr.ifr_name);\r\nrcu_read_lock();\r\nret = dev_ifsioc_locked(net, &ifr, cmd);\r\nrcu_read_unlock();\r\nif (!ret) {\r\nif (colon)\r\n*colon = ':';\r\nif (copy_to_user(arg, &ifr,\r\nsizeof(struct ifreq)))\r\nret = -EFAULT;\r\n}\r\nreturn ret;\r\ncase SIOCETHTOOL:\r\ndev_load(net, ifr.ifr_name);\r\nrtnl_lock();\r\nret = dev_ethtool(net, &ifr);\r\nrtnl_unlock();\r\nif (!ret) {\r\nif (colon)\r\n*colon = ':';\r\nif (copy_to_user(arg, &ifr,\r\nsizeof(struct ifreq)))\r\nret = -EFAULT;\r\n}\r\nreturn ret;\r\ncase SIOCGMIIPHY:\r\ncase SIOCGMIIREG:\r\ncase SIOCSIFNAME:\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\ndev_load(net, ifr.ifr_name);\r\nrtnl_lock();\r\nret = dev_ifsioc(net, &ifr, cmd);\r\nrtnl_unlock();\r\nif (!ret) {\r\nif (colon)\r\n*colon = ':';\r\nif (copy_to_user(arg, &ifr,\r\nsizeof(struct ifreq)))\r\nret = -EFAULT;\r\n}\r\nreturn ret;\r\ncase SIOCSIFMAP:\r\ncase SIOCSIFTXQLEN:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\ncase SIOCSIFFLAGS:\r\ncase SIOCSIFMETRIC:\r\ncase SIOCSIFMTU:\r\ncase SIOCSIFHWADDR:\r\ncase SIOCSIFSLAVE:\r\ncase SIOCADDMULTI:\r\ncase SIOCDELMULTI:\r\ncase SIOCSIFHWBROADCAST:\r\ncase SIOCSMIIREG:\r\ncase SIOCBONDENSLAVE:\r\ncase SIOCBONDRELEASE:\r\ncase SIOCBONDSETHWADDR:\r\ncase SIOCBONDCHANGEACTIVE:\r\ncase SIOCBRADDIF:\r\ncase SIOCBRDELIF:\r\ncase SIOCSHWTSTAMP:\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\ncase SIOCBONDSLAVEINFOQUERY:\r\ncase SIOCBONDINFOQUERY:\r\ndev_load(net, ifr.ifr_name);\r\nrtnl_lock();\r\nret = dev_ifsioc(net, &ifr, cmd);\r\nrtnl_unlock();\r\nreturn ret;\r\ncase SIOCGIFMEM:\r\ncase SIOCSIFMEM:\r\ncase SIOCSIFLINK:\r\nreturn -ENOTTY;\r\ndefault:\r\nif (cmd == SIOCWANDEV ||\r\ncmd == SIOCGHWTSTAMP ||\r\n(cmd >= SIOCDEVPRIVATE &&\r\ncmd <= SIOCDEVPRIVATE + 15)) {\r\ndev_load(net, ifr.ifr_name);\r\nrtnl_lock();\r\nret = dev_ifsioc(net, &ifr, cmd);\r\nrtnl_unlock();\r\nif (!ret && copy_to_user(arg, &ifr,\r\nsizeof(struct ifreq)))\r\nret = -EFAULT;\r\nreturn ret;\r\n}\r\nif (cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST)\r\nreturn wext_handle_ioctl(net, &ifr, cmd, arg);\r\nreturn -ENOTTY;\r\n}\r\n}
