static int tps65023_dcdc_get_voltage_sel(struct regulator_dev *dev)\r\n{\r\nstruct tps_pmic *tps = rdev_get_drvdata(dev);\r\nint dcdc = rdev_get_id(dev);\r\nif (dcdc < TPS65023_DCDC_1 || dcdc > TPS65023_DCDC_3)\r\nreturn -EINVAL;\r\nif (dcdc != tps->core_regulator)\r\nreturn 0;\r\nreturn regulator_get_voltage_sel_regmap(dev);\r\n}\r\nstatic int tps65023_dcdc_set_voltage_sel(struct regulator_dev *dev,\r\nunsigned selector)\r\n{\r\nstruct tps_pmic *tps = rdev_get_drvdata(dev);\r\nint dcdc = rdev_get_id(dev);\r\nif (dcdc != tps->core_regulator)\r\nreturn -EINVAL;\r\nreturn regulator_set_voltage_sel_regmap(dev, selector);\r\n}\r\nstatic int tps_65023_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct tps_driver_data *drv_data = (void *)id->driver_data;\r\nconst struct tps_info *info = drv_data->info;\r\nstruct regulator_config config = { };\r\nstruct regulator_init_data *init_data;\r\nstruct regulator_dev *rdev;\r\nstruct tps_pmic *tps;\r\nint i;\r\nint error;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\ninit_data = dev_get_platdata(&client->dev);\r\nif (!init_data)\r\nreturn -EIO;\r\ntps = devm_kzalloc(&client->dev, sizeof(*tps), GFP_KERNEL);\r\nif (!tps)\r\nreturn -ENOMEM;\r\ntps->regmap = devm_regmap_init_i2c(client, &tps65023_regmap_config);\r\nif (IS_ERR(tps->regmap)) {\r\nerror = PTR_ERR(tps->regmap);\r\ndev_err(&client->dev, "Failed to allocate register map: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\ntps->core_regulator = drv_data->core_regulator;\r\nfor (i = 0; i < TPS65023_NUM_REGULATOR; i++, info++, init_data++) {\r\ntps->info[i] = info;\r\ntps->desc[i].name = info->name;\r\ntps->desc[i].id = i;\r\ntps->desc[i].n_voltages = info->table_len;\r\ntps->desc[i].volt_table = info->table;\r\ntps->desc[i].ops = (i > TPS65023_DCDC_3 ?\r\n&tps65023_ldo_ops : &tps65023_dcdc_ops);\r\ntps->desc[i].type = REGULATOR_VOLTAGE;\r\ntps->desc[i].owner = THIS_MODULE;\r\ntps->desc[i].enable_reg = TPS65023_REG_REG_CTRL;\r\nswitch (i) {\r\ncase TPS65023_LDO_1:\r\ntps->desc[i].vsel_reg = TPS65023_REG_LDO_CTRL;\r\ntps->desc[i].vsel_mask = 0x07;\r\ntps->desc[i].enable_mask = 1 << 1;\r\nbreak;\r\ncase TPS65023_LDO_2:\r\ntps->desc[i].vsel_reg = TPS65023_REG_LDO_CTRL;\r\ntps->desc[i].vsel_mask = 0x70;\r\ntps->desc[i].enable_mask = 1 << 2;\r\nbreak;\r\ndefault:\r\ntps->desc[i].enable_mask =\r\n1 << (TPS65023_NUM_REGULATOR - i);\r\ntps->desc[i].vsel_reg = TPS65023_REG_DEF_CORE;\r\ntps->desc[i].vsel_mask = info->table_len - 1;\r\ntps->desc[i].apply_reg = TPS65023_REG_CON_CTRL2;\r\ntps->desc[i].apply_bit = TPS65023_REG_CTRL2_GO;\r\n}\r\nconfig.dev = &client->dev;\r\nconfig.init_data = init_data;\r\nconfig.driver_data = tps;\r\nconfig.regmap = tps->regmap;\r\nrdev = devm_regulator_register(&client->dev, &tps->desc[i],\r\n&config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&client->dev, "failed to register %s\n",\r\nid->name);\r\nreturn PTR_ERR(rdev);\r\n}\r\ntps->rdev[i] = rdev;\r\n}\r\ni2c_set_clientdata(client, tps);\r\nregmap_update_bits(tps->regmap, TPS65023_REG_CON_CTRL2,\r\nTPS65023_REG_CTRL2_CORE_ADJ,\r\nTPS65023_REG_CTRL2_CORE_ADJ);\r\nreturn 0;\r\n}\r\nstatic int __init tps_65023_init(void)\r\n{\r\nreturn i2c_add_driver(&tps_65023_i2c_driver);\r\n}\r\nstatic void __exit tps_65023_cleanup(void)\r\n{\r\ni2c_del_driver(&tps_65023_i2c_driver);\r\n}
