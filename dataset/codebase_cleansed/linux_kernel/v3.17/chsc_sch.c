static void CHSC_LOG_HEX(int level, void *data, int length)\r\n{\r\nwhile (length > 0) {\r\ndebug_event(chsc_debug_log_id, level, data, length);\r\nlength -= chsc_debug_log_id->buf_size;\r\ndata += chsc_debug_log_id->buf_size;\r\n}\r\n}\r\nstatic void chsc_subchannel_irq(struct subchannel *sch)\r\n{\r\nstruct chsc_private *private = dev_get_drvdata(&sch->dev);\r\nstruct chsc_request *request = private->request;\r\nstruct irb *irb = &__get_cpu_var(cio_irb);\r\nCHSC_LOG(4, "irb");\r\nCHSC_LOG_HEX(4, irb, sizeof(*irb));\r\ninc_irq_stat(IRQIO_CSC);\r\nif (!request) {\r\nCHSC_MSG(0, "Interrupt on sch 0.%x.%04x with no request\n",\r\nsch->schid.ssid, sch->schid.sch_no);\r\nreturn;\r\n}\r\nprivate->request = NULL;\r\nmemcpy(&request->irb, irb, sizeof(*irb));\r\ncio_update_schib(sch);\r\ncomplete(&request->completion);\r\nput_device(&sch->dev);\r\n}\r\nstatic int chsc_subchannel_probe(struct subchannel *sch)\r\n{\r\nstruct chsc_private *private;\r\nint ret;\r\nCHSC_MSG(6, "Detected chsc subchannel 0.%x.%04x\n",\r\nsch->schid.ssid, sch->schid.sch_no);\r\nsch->isc = CHSC_SCH_ISC;\r\nprivate = kzalloc(sizeof(*private), GFP_KERNEL);\r\nif (!private)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&sch->dev, private);\r\nret = cio_enable_subchannel(sch, (u32)(unsigned long)sch);\r\nif (ret) {\r\nCHSC_MSG(0, "Failed to enable 0.%x.%04x: %d\n",\r\nsch->schid.ssid, sch->schid.sch_no, ret);\r\ndev_set_drvdata(&sch->dev, NULL);\r\nkfree(private);\r\n} else {\r\nif (dev_get_uevent_suppress(&sch->dev)) {\r\ndev_set_uevent_suppress(&sch->dev, 0);\r\nkobject_uevent(&sch->dev.kobj, KOBJ_ADD);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int chsc_subchannel_remove(struct subchannel *sch)\r\n{\r\nstruct chsc_private *private;\r\ncio_disable_subchannel(sch);\r\nprivate = dev_get_drvdata(&sch->dev);\r\ndev_set_drvdata(&sch->dev, NULL);\r\nif (private->request) {\r\ncomplete(&private->request->completion);\r\nput_device(&sch->dev);\r\n}\r\nkfree(private);\r\nreturn 0;\r\n}\r\nstatic void chsc_subchannel_shutdown(struct subchannel *sch)\r\n{\r\ncio_disable_subchannel(sch);\r\n}\r\nstatic int chsc_subchannel_prepare(struct subchannel *sch)\r\n{\r\nint cc;\r\nstruct schib schib;\r\ncc = stsch_err(sch->schid, &schib);\r\nif (!cc && scsw_stctl(&schib.scsw))\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic int chsc_subchannel_freeze(struct subchannel *sch)\r\n{\r\nreturn cio_disable_subchannel(sch);\r\n}\r\nstatic int chsc_subchannel_restore(struct subchannel *sch)\r\n{\r\nreturn cio_enable_subchannel(sch, (u32)(unsigned long)sch);\r\n}\r\nstatic int __init chsc_init_dbfs(void)\r\n{\r\nchsc_debug_msg_id = debug_register("chsc_msg", 8, 1, 4 * sizeof(long));\r\nif (!chsc_debug_msg_id)\r\ngoto out;\r\ndebug_register_view(chsc_debug_msg_id, &debug_sprintf_view);\r\ndebug_set_level(chsc_debug_msg_id, 2);\r\nchsc_debug_log_id = debug_register("chsc_log", 16, 1, 16);\r\nif (!chsc_debug_log_id)\r\ngoto out;\r\ndebug_register_view(chsc_debug_log_id, &debug_hex_ascii_view);\r\ndebug_set_level(chsc_debug_log_id, 2);\r\nreturn 0;\r\nout:\r\nif (chsc_debug_msg_id)\r\ndebug_unregister(chsc_debug_msg_id);\r\nreturn -ENOMEM;\r\n}\r\nstatic void chsc_remove_dbfs(void)\r\n{\r\ndebug_unregister(chsc_debug_log_id);\r\ndebug_unregister(chsc_debug_msg_id);\r\n}\r\nstatic int __init chsc_init_sch_driver(void)\r\n{\r\nreturn css_driver_register(&chsc_subchannel_driver);\r\n}\r\nstatic void chsc_cleanup_sch_driver(void)\r\n{\r\ncss_driver_unregister(&chsc_subchannel_driver);\r\n}\r\nstatic int chsc_subchannel_match_next_free(struct device *dev, void *data)\r\n{\r\nstruct subchannel *sch = to_subchannel(dev);\r\nreturn sch->schib.pmcw.ena && !scsw_fctl(&sch->schib.scsw);\r\n}\r\nstatic struct subchannel *chsc_get_next_subchannel(struct subchannel *sch)\r\n{\r\nstruct device *dev;\r\ndev = driver_find_device(&chsc_subchannel_driver.drv,\r\nsch ? &sch->dev : NULL, NULL,\r\nchsc_subchannel_match_next_free);\r\nreturn dev ? to_subchannel(dev) : NULL;\r\n}\r\nstatic int chsc_async(struct chsc_async_area *chsc_area,\r\nstruct chsc_request *request)\r\n{\r\nint cc;\r\nstruct chsc_private *private;\r\nstruct subchannel *sch = NULL;\r\nint ret = -ENODEV;\r\nchar dbf[10];\r\nchsc_area->header.key = PAGE_DEFAULT_KEY >> 4;\r\nwhile ((sch = chsc_get_next_subchannel(sch))) {\r\nspin_lock(sch->lock);\r\nprivate = dev_get_drvdata(&sch->dev);\r\nif (private->request) {\r\nspin_unlock(sch->lock);\r\nret = -EBUSY;\r\ncontinue;\r\n}\r\nchsc_area->header.sid = sch->schid;\r\nCHSC_LOG(2, "schid");\r\nCHSC_LOG_HEX(2, &sch->schid, sizeof(sch->schid));\r\ncc = chsc(chsc_area);\r\nsnprintf(dbf, sizeof(dbf), "cc:%d", cc);\r\nCHSC_LOG(2, dbf);\r\nswitch (cc) {\r\ncase 0:\r\nret = 0;\r\nbreak;\r\ncase 1:\r\nsch->schib.scsw.cmd.fctl |= SCSW_FCTL_START_FUNC;\r\nret = -EINPROGRESS;\r\nprivate->request = request;\r\nbreak;\r\ncase 2:\r\nret = -EBUSY;\r\nbreak;\r\ndefault:\r\nret = -ENODEV;\r\n}\r\nspin_unlock(sch->lock);\r\nCHSC_MSG(2, "chsc on 0.%x.%04x returned cc=%d\n",\r\nsch->schid.ssid, sch->schid.sch_no, cc);\r\nif (ret == -EINPROGRESS)\r\nreturn -EINPROGRESS;\r\nput_device(&sch->dev);\r\nif (ret == 0)\r\nreturn 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void chsc_log_command(void *chsc_area)\r\n{\r\nchar dbf[10];\r\nsnprintf(dbf, sizeof(dbf), "CHSC:%x", ((uint16_t *)chsc_area)[1]);\r\nCHSC_LOG(0, dbf);\r\nCHSC_LOG_HEX(0, chsc_area, 32);\r\n}\r\nstatic int chsc_examine_irb(struct chsc_request *request)\r\n{\r\nint backed_up;\r\nif (!(scsw_stctl(&request->irb.scsw) & SCSW_STCTL_STATUS_PEND))\r\nreturn -EIO;\r\nbacked_up = scsw_cstat(&request->irb.scsw) & SCHN_STAT_CHAIN_CHECK;\r\nrequest->irb.scsw.cmd.cstat &= ~SCHN_STAT_CHAIN_CHECK;\r\nif (scsw_cstat(&request->irb.scsw) == 0)\r\nreturn 0;\r\nif (!backed_up)\r\nreturn 0;\r\nif (scsw_cstat(&request->irb.scsw) & SCHN_STAT_PROG_CHECK)\r\nreturn -EIO;\r\nif (scsw_cstat(&request->irb.scsw) & SCHN_STAT_PROT_CHECK)\r\nreturn -EPERM;\r\nif (scsw_cstat(&request->irb.scsw) & SCHN_STAT_CHN_DATA_CHK)\r\nreturn -EAGAIN;\r\nif (scsw_cstat(&request->irb.scsw) & SCHN_STAT_CHN_CTRL_CHK)\r\nreturn -EAGAIN;\r\nreturn -EIO;\r\n}\r\nstatic int chsc_ioctl_start(void __user *user_area)\r\n{\r\nstruct chsc_request *request;\r\nstruct chsc_async_area *chsc_area;\r\nint ret;\r\nchar dbf[10];\r\nif (!css_general_characteristics.dynio)\r\nreturn -EOPNOTSUPP;\r\nchsc_area = (void *)get_zeroed_page(GFP_DMA | GFP_KERNEL);\r\nif (!chsc_area)\r\nreturn -ENOMEM;\r\nrequest = kzalloc(sizeof(*request), GFP_KERNEL);\r\nif (!request) {\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\ninit_completion(&request->completion);\r\nif (copy_from_user(chsc_area, user_area, PAGE_SIZE)) {\r\nret = -EFAULT;\r\ngoto out_free;\r\n}\r\nchsc_log_command(chsc_area);\r\nspin_lock_irq(&chsc_lock);\r\nret = chsc_async(chsc_area, request);\r\nspin_unlock_irq(&chsc_lock);\r\nif (ret == -EINPROGRESS) {\r\nwait_for_completion(&request->completion);\r\nret = chsc_examine_irb(request);\r\n}\r\nif (!ret)\r\nif (copy_to_user(user_area, chsc_area, PAGE_SIZE))\r\nret = -EFAULT;\r\nout_free:\r\nsnprintf(dbf, sizeof(dbf), "ret:%d", ret);\r\nCHSC_LOG(0, dbf);\r\nkfree(request);\r\nfree_page((unsigned long)chsc_area);\r\nreturn ret;\r\n}\r\nstatic int chsc_ioctl_on_close_set(void __user *user_area)\r\n{\r\nchar dbf[13];\r\nint ret;\r\nmutex_lock(&on_close_mutex);\r\nif (on_close_chsc_area) {\r\nret = -EBUSY;\r\ngoto out_unlock;\r\n}\r\non_close_request = kzalloc(sizeof(*on_close_request), GFP_KERNEL);\r\nif (!on_close_request) {\r\nret = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\non_close_chsc_area = (void *)get_zeroed_page(GFP_DMA | GFP_KERNEL);\r\nif (!on_close_chsc_area) {\r\nret = -ENOMEM;\r\ngoto out_free_request;\r\n}\r\nif (copy_from_user(on_close_chsc_area, user_area, PAGE_SIZE)) {\r\nret = -EFAULT;\r\ngoto out_free_chsc;\r\n}\r\nret = 0;\r\ngoto out_unlock;\r\nout_free_chsc:\r\nfree_page((unsigned long)on_close_chsc_area);\r\non_close_chsc_area = NULL;\r\nout_free_request:\r\nkfree(on_close_request);\r\non_close_request = NULL;\r\nout_unlock:\r\nmutex_unlock(&on_close_mutex);\r\nsnprintf(dbf, sizeof(dbf), "ocsret:%d", ret);\r\nCHSC_LOG(0, dbf);\r\nreturn ret;\r\n}\r\nstatic int chsc_ioctl_on_close_remove(void)\r\n{\r\nchar dbf[13];\r\nint ret;\r\nmutex_lock(&on_close_mutex);\r\nif (!on_close_chsc_area) {\r\nret = -ENOENT;\r\ngoto out_unlock;\r\n}\r\nfree_page((unsigned long)on_close_chsc_area);\r\non_close_chsc_area = NULL;\r\nkfree(on_close_request);\r\non_close_request = NULL;\r\nret = 0;\r\nout_unlock:\r\nmutex_unlock(&on_close_mutex);\r\nsnprintf(dbf, sizeof(dbf), "ocrret:%d", ret);\r\nCHSC_LOG(0, dbf);\r\nreturn ret;\r\n}\r\nstatic int chsc_ioctl_start_sync(void __user *user_area)\r\n{\r\nstruct chsc_sync_area *chsc_area;\r\nint ret, ccode;\r\nchsc_area = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!chsc_area)\r\nreturn -ENOMEM;\r\nif (copy_from_user(chsc_area, user_area, PAGE_SIZE)) {\r\nret = -EFAULT;\r\ngoto out_free;\r\n}\r\nif (chsc_area->header.code & 0x4000) {\r\nret = -EINVAL;\r\ngoto out_free;\r\n}\r\nchsc_log_command(chsc_area);\r\nccode = chsc(chsc_area);\r\nif (ccode != 0) {\r\nret = -EIO;\r\ngoto out_free;\r\n}\r\nif (copy_to_user(user_area, chsc_area, PAGE_SIZE))\r\nret = -EFAULT;\r\nelse\r\nret = 0;\r\nout_free:\r\nfree_page((unsigned long)chsc_area);\r\nreturn ret;\r\n}\r\nstatic int chsc_ioctl_info_channel_path(void __user *user_cd)\r\n{\r\nstruct chsc_chp_cd *cd;\r\nint ret, ccode;\r\nstruct {\r\nstruct chsc_header request;\r\nu32 : 2;\r\nu32 m : 1;\r\nu32 : 1;\r\nu32 fmt1 : 4;\r\nu32 cssid : 8;\r\nu32 : 8;\r\nu32 first_chpid : 8;\r\nu32 : 24;\r\nu32 last_chpid : 8;\r\nu32 : 32;\r\nstruct chsc_header response;\r\nu8 data[PAGE_SIZE - 20];\r\n} __attribute__ ((packed)) *scpcd_area;\r\nscpcd_area = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!scpcd_area)\r\nreturn -ENOMEM;\r\ncd = kzalloc(sizeof(*cd), GFP_KERNEL);\r\nif (!cd) {\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\nif (copy_from_user(cd, user_cd, sizeof(*cd))) {\r\nret = -EFAULT;\r\ngoto out_free;\r\n}\r\nscpcd_area->request.length = 0x0010;\r\nscpcd_area->request.code = 0x0028;\r\nscpcd_area->m = cd->m;\r\nscpcd_area->fmt1 = cd->fmt;\r\nscpcd_area->cssid = cd->chpid.cssid;\r\nscpcd_area->first_chpid = cd->chpid.id;\r\nscpcd_area->last_chpid = cd->chpid.id;\r\nccode = chsc(scpcd_area);\r\nif (ccode != 0) {\r\nret = -EIO;\r\ngoto out_free;\r\n}\r\nif (scpcd_area->response.code != 0x0001) {\r\nret = -EIO;\r\nCHSC_MSG(0, "scpcd: response code=%x\n",\r\nscpcd_area->response.code);\r\ngoto out_free;\r\n}\r\nmemcpy(&cd->cpcb, &scpcd_area->response, scpcd_area->response.length);\r\nif (copy_to_user(user_cd, cd, sizeof(*cd)))\r\nret = -EFAULT;\r\nelse\r\nret = 0;\r\nout_free:\r\nkfree(cd);\r\nfree_page((unsigned long)scpcd_area);\r\nreturn ret;\r\n}\r\nstatic int chsc_ioctl_info_cu(void __user *user_cd)\r\n{\r\nstruct chsc_cu_cd *cd;\r\nint ret, ccode;\r\nstruct {\r\nstruct chsc_header request;\r\nu32 : 2;\r\nu32 m : 1;\r\nu32 : 1;\r\nu32 fmt1 : 4;\r\nu32 cssid : 8;\r\nu32 : 8;\r\nu32 first_cun : 8;\r\nu32 : 24;\r\nu32 last_cun : 8;\r\nu32 : 32;\r\nstruct chsc_header response;\r\nu8 data[PAGE_SIZE - 20];\r\n} __attribute__ ((packed)) *scucd_area;\r\nscucd_area = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!scucd_area)\r\nreturn -ENOMEM;\r\ncd = kzalloc(sizeof(*cd), GFP_KERNEL);\r\nif (!cd) {\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\nif (copy_from_user(cd, user_cd, sizeof(*cd))) {\r\nret = -EFAULT;\r\ngoto out_free;\r\n}\r\nscucd_area->request.length = 0x0010;\r\nscucd_area->request.code = 0x0028;\r\nscucd_area->m = cd->m;\r\nscucd_area->fmt1 = cd->fmt;\r\nscucd_area->cssid = cd->cssid;\r\nscucd_area->first_cun = cd->cun;\r\nscucd_area->last_cun = cd->cun;\r\nccode = chsc(scucd_area);\r\nif (ccode != 0) {\r\nret = -EIO;\r\ngoto out_free;\r\n}\r\nif (scucd_area->response.code != 0x0001) {\r\nret = -EIO;\r\nCHSC_MSG(0, "scucd: response code=%x\n",\r\nscucd_area->response.code);\r\ngoto out_free;\r\n}\r\nmemcpy(&cd->cucb, &scucd_area->response, scucd_area->response.length);\r\nif (copy_to_user(user_cd, cd, sizeof(*cd)))\r\nret = -EFAULT;\r\nelse\r\nret = 0;\r\nout_free:\r\nkfree(cd);\r\nfree_page((unsigned long)scucd_area);\r\nreturn ret;\r\n}\r\nstatic int chsc_ioctl_info_sch_cu(void __user *user_cud)\r\n{\r\nstruct chsc_sch_cud *cud;\r\nint ret, ccode;\r\nstruct {\r\nstruct chsc_header request;\r\nu32 : 2;\r\nu32 m : 1;\r\nu32 : 5;\r\nu32 fmt1 : 4;\r\nu32 : 2;\r\nu32 ssid : 2;\r\nu32 first_sch : 16;\r\nu32 : 8;\r\nu32 cssid : 8;\r\nu32 last_sch : 16;\r\nu32 : 32;\r\nstruct chsc_header response;\r\nu8 data[PAGE_SIZE - 20];\r\n} __attribute__ ((packed)) *sscud_area;\r\nsscud_area = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!sscud_area)\r\nreturn -ENOMEM;\r\ncud = kzalloc(sizeof(*cud), GFP_KERNEL);\r\nif (!cud) {\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\nif (copy_from_user(cud, user_cud, sizeof(*cud))) {\r\nret = -EFAULT;\r\ngoto out_free;\r\n}\r\nsscud_area->request.length = 0x0010;\r\nsscud_area->request.code = 0x0006;\r\nsscud_area->m = cud->schid.m;\r\nsscud_area->fmt1 = cud->fmt;\r\nsscud_area->ssid = cud->schid.ssid;\r\nsscud_area->first_sch = cud->schid.sch_no;\r\nsscud_area->cssid = cud->schid.cssid;\r\nsscud_area->last_sch = cud->schid.sch_no;\r\nccode = chsc(sscud_area);\r\nif (ccode != 0) {\r\nret = -EIO;\r\ngoto out_free;\r\n}\r\nif (sscud_area->response.code != 0x0001) {\r\nret = -EIO;\r\nCHSC_MSG(0, "sscud: response code=%x\n",\r\nsscud_area->response.code);\r\ngoto out_free;\r\n}\r\nmemcpy(&cud->scub, &sscud_area->response, sscud_area->response.length);\r\nif (copy_to_user(user_cud, cud, sizeof(*cud)))\r\nret = -EFAULT;\r\nelse\r\nret = 0;\r\nout_free:\r\nkfree(cud);\r\nfree_page((unsigned long)sscud_area);\r\nreturn ret;\r\n}\r\nstatic int chsc_ioctl_conf_info(void __user *user_ci)\r\n{\r\nstruct chsc_conf_info *ci;\r\nint ret, ccode;\r\nstruct {\r\nstruct chsc_header request;\r\nu32 : 2;\r\nu32 m : 1;\r\nu32 : 1;\r\nu32 fmt1 : 4;\r\nu32 cssid : 8;\r\nu32 : 6;\r\nu32 ssid : 2;\r\nu32 : 8;\r\nu64 : 64;\r\nstruct chsc_header response;\r\nu8 data[PAGE_SIZE - 20];\r\n} __attribute__ ((packed)) *sci_area;\r\nsci_area = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!sci_area)\r\nreturn -ENOMEM;\r\nci = kzalloc(sizeof(*ci), GFP_KERNEL);\r\nif (!ci) {\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\nif (copy_from_user(ci, user_ci, sizeof(*ci))) {\r\nret = -EFAULT;\r\ngoto out_free;\r\n}\r\nsci_area->request.length = 0x0010;\r\nsci_area->request.code = 0x0012;\r\nsci_area->m = ci->id.m;\r\nsci_area->fmt1 = ci->fmt;\r\nsci_area->cssid = ci->id.cssid;\r\nsci_area->ssid = ci->id.ssid;\r\nccode = chsc(sci_area);\r\nif (ccode != 0) {\r\nret = -EIO;\r\ngoto out_free;\r\n}\r\nif (sci_area->response.code != 0x0001) {\r\nret = -EIO;\r\nCHSC_MSG(0, "sci: response code=%x\n",\r\nsci_area->response.code);\r\ngoto out_free;\r\n}\r\nmemcpy(&ci->scid, &sci_area->response, sci_area->response.length);\r\nif (copy_to_user(user_ci, ci, sizeof(*ci)))\r\nret = -EFAULT;\r\nelse\r\nret = 0;\r\nout_free:\r\nkfree(ci);\r\nfree_page((unsigned long)sci_area);\r\nreturn ret;\r\n}\r\nstatic int chsc_ioctl_conf_comp_list(void __user *user_ccl)\r\n{\r\nstruct chsc_comp_list *ccl;\r\nint ret, ccode;\r\nstruct {\r\nstruct chsc_header request;\r\nu32 ctype : 8;\r\nu32 : 4;\r\nu32 fmt : 4;\r\nu32 : 16;\r\nu64 : 64;\r\nu32 list_parm[2];\r\nu64 : 64;\r\nstruct chsc_header response;\r\nu8 data[PAGE_SIZE - 36];\r\n} __attribute__ ((packed)) *sccl_area;\r\nstruct {\r\nu32 m : 1;\r\nu32 : 31;\r\nu32 cssid : 8;\r\nu32 : 16;\r\nu32 chpid : 8;\r\n} __attribute__ ((packed)) *chpid_parm;\r\nstruct {\r\nu32 f_cssid : 8;\r\nu32 l_cssid : 8;\r\nu32 : 16;\r\nu32 res;\r\n} __attribute__ ((packed)) *cssids_parm;\r\nsccl_area = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!sccl_area)\r\nreturn -ENOMEM;\r\nccl = kzalloc(sizeof(*ccl), GFP_KERNEL);\r\nif (!ccl) {\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\nif (copy_from_user(ccl, user_ccl, sizeof(*ccl))) {\r\nret = -EFAULT;\r\ngoto out_free;\r\n}\r\nsccl_area->request.length = 0x0020;\r\nsccl_area->request.code = 0x0030;\r\nsccl_area->fmt = ccl->req.fmt;\r\nsccl_area->ctype = ccl->req.ctype;\r\nswitch (sccl_area->ctype) {\r\ncase CCL_CU_ON_CHP:\r\ncase CCL_IOP_CHP:\r\nchpid_parm = (void *)&sccl_area->list_parm;\r\nchpid_parm->m = ccl->req.chpid.m;\r\nchpid_parm->cssid = ccl->req.chpid.chp.cssid;\r\nchpid_parm->chpid = ccl->req.chpid.chp.id;\r\nbreak;\r\ncase CCL_CSS_IMG:\r\ncase CCL_CSS_IMG_CONF_CHAR:\r\ncssids_parm = (void *)&sccl_area->list_parm;\r\ncssids_parm->f_cssid = ccl->req.cssids.f_cssid;\r\ncssids_parm->l_cssid = ccl->req.cssids.l_cssid;\r\nbreak;\r\n}\r\nccode = chsc(sccl_area);\r\nif (ccode != 0) {\r\nret = -EIO;\r\ngoto out_free;\r\n}\r\nif (sccl_area->response.code != 0x0001) {\r\nret = -EIO;\r\nCHSC_MSG(0, "sccl: response code=%x\n",\r\nsccl_area->response.code);\r\ngoto out_free;\r\n}\r\nmemcpy(&ccl->sccl, &sccl_area->response, sccl_area->response.length);\r\nif (copy_to_user(user_ccl, ccl, sizeof(*ccl)))\r\nret = -EFAULT;\r\nelse\r\nret = 0;\r\nout_free:\r\nkfree(ccl);\r\nfree_page((unsigned long)sccl_area);\r\nreturn ret;\r\n}\r\nstatic int chsc_ioctl_chpd(void __user *user_chpd)\r\n{\r\nstruct chsc_scpd *scpd_area;\r\nstruct chsc_cpd_info *chpd;\r\nint ret;\r\nchpd = kzalloc(sizeof(*chpd), GFP_KERNEL);\r\nscpd_area = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!scpd_area || !chpd) {\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\nif (copy_from_user(chpd, user_chpd, sizeof(*chpd))) {\r\nret = -EFAULT;\r\ngoto out_free;\r\n}\r\nret = chsc_determine_channel_path_desc(chpd->chpid, chpd->fmt,\r\nchpd->rfmt, chpd->c, chpd->m,\r\nscpd_area);\r\nif (ret)\r\ngoto out_free;\r\nmemcpy(&chpd->chpdb, &scpd_area->response, scpd_area->response.length);\r\nif (copy_to_user(user_chpd, chpd, sizeof(*chpd)))\r\nret = -EFAULT;\r\nout_free:\r\nkfree(chpd);\r\nfree_page((unsigned long)scpd_area);\r\nreturn ret;\r\n}\r\nstatic int chsc_ioctl_dcal(void __user *user_dcal)\r\n{\r\nstruct chsc_dcal *dcal;\r\nint ret, ccode;\r\nstruct {\r\nstruct chsc_header request;\r\nu32 atype : 8;\r\nu32 : 4;\r\nu32 fmt : 4;\r\nu32 : 16;\r\nu32 res0[2];\r\nu32 list_parm[2];\r\nu32 res1[2];\r\nstruct chsc_header response;\r\nu8 data[PAGE_SIZE - 36];\r\n} __attribute__ ((packed)) *sdcal_area;\r\nsdcal_area = (void *)get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!sdcal_area)\r\nreturn -ENOMEM;\r\ndcal = kzalloc(sizeof(*dcal), GFP_KERNEL);\r\nif (!dcal) {\r\nret = -ENOMEM;\r\ngoto out_free;\r\n}\r\nif (copy_from_user(dcal, user_dcal, sizeof(*dcal))) {\r\nret = -EFAULT;\r\ngoto out_free;\r\n}\r\nsdcal_area->request.length = 0x0020;\r\nsdcal_area->request.code = 0x0034;\r\nsdcal_area->atype = dcal->req.atype;\r\nsdcal_area->fmt = dcal->req.fmt;\r\nmemcpy(&sdcal_area->list_parm, &dcal->req.list_parm,\r\nsizeof(sdcal_area->list_parm));\r\nccode = chsc(sdcal_area);\r\nif (ccode != 0) {\r\nret = -EIO;\r\ngoto out_free;\r\n}\r\nif (sdcal_area->response.code != 0x0001) {\r\nret = -EIO;\r\nCHSC_MSG(0, "sdcal: response code=%x\n",\r\nsdcal_area->response.code);\r\ngoto out_free;\r\n}\r\nmemcpy(&dcal->sdcal, &sdcal_area->response,\r\nsdcal_area->response.length);\r\nif (copy_to_user(user_dcal, dcal, sizeof(*dcal)))\r\nret = -EFAULT;\r\nelse\r\nret = 0;\r\nout_free:\r\nkfree(dcal);\r\nfree_page((unsigned long)sdcal_area);\r\nreturn ret;\r\n}\r\nstatic long chsc_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvoid __user *argp;\r\nCHSC_MSG(2, "chsc_ioctl called, cmd=%x\n", cmd);\r\nif (is_compat_task())\r\nargp = compat_ptr(arg);\r\nelse\r\nargp = (void __user *)arg;\r\nswitch (cmd) {\r\ncase CHSC_START:\r\nreturn chsc_ioctl_start(argp);\r\ncase CHSC_START_SYNC:\r\nreturn chsc_ioctl_start_sync(argp);\r\ncase CHSC_INFO_CHANNEL_PATH:\r\nreturn chsc_ioctl_info_channel_path(argp);\r\ncase CHSC_INFO_CU:\r\nreturn chsc_ioctl_info_cu(argp);\r\ncase CHSC_INFO_SCH_CU:\r\nreturn chsc_ioctl_info_sch_cu(argp);\r\ncase CHSC_INFO_CI:\r\nreturn chsc_ioctl_conf_info(argp);\r\ncase CHSC_INFO_CCL:\r\nreturn chsc_ioctl_conf_comp_list(argp);\r\ncase CHSC_INFO_CPD:\r\nreturn chsc_ioctl_chpd(argp);\r\ncase CHSC_INFO_DCAL:\r\nreturn chsc_ioctl_dcal(argp);\r\ncase CHSC_ON_CLOSE_SET:\r\nreturn chsc_ioctl_on_close_set(argp);\r\ncase CHSC_ON_CLOSE_REMOVE:\r\nreturn chsc_ioctl_on_close_remove();\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic int chsc_open(struct inode *inode, struct file *file)\r\n{\r\nif (!atomic_dec_and_test(&chsc_ready_for_use)) {\r\natomic_inc(&chsc_ready_for_use);\r\nreturn -EBUSY;\r\n}\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int chsc_release(struct inode *inode, struct file *filp)\r\n{\r\nchar dbf[13];\r\nint ret;\r\nmutex_lock(&on_close_mutex);\r\nif (!on_close_chsc_area)\r\ngoto out_unlock;\r\ninit_completion(&on_close_request->completion);\r\nCHSC_LOG(0, "on_close");\r\nchsc_log_command(on_close_chsc_area);\r\nspin_lock_irq(&chsc_lock);\r\nret = chsc_async(on_close_chsc_area, on_close_request);\r\nspin_unlock_irq(&chsc_lock);\r\nif (ret == -EINPROGRESS) {\r\nwait_for_completion(&on_close_request->completion);\r\nret = chsc_examine_irb(on_close_request);\r\n}\r\nsnprintf(dbf, sizeof(dbf), "relret:%d", ret);\r\nCHSC_LOG(0, dbf);\r\nfree_page((unsigned long)on_close_chsc_area);\r\non_close_chsc_area = NULL;\r\nkfree(on_close_request);\r\non_close_request = NULL;\r\nout_unlock:\r\nmutex_unlock(&on_close_mutex);\r\natomic_inc(&chsc_ready_for_use);\r\nreturn 0;\r\n}\r\nstatic int __init chsc_misc_init(void)\r\n{\r\nreturn misc_register(&chsc_misc_device);\r\n}\r\nstatic void chsc_misc_cleanup(void)\r\n{\r\nmisc_deregister(&chsc_misc_device);\r\n}\r\nstatic int __init chsc_sch_init(void)\r\n{\r\nint ret;\r\nret = chsc_init_dbfs();\r\nif (ret)\r\nreturn ret;\r\nisc_register(CHSC_SCH_ISC);\r\nret = chsc_init_sch_driver();\r\nif (ret)\r\ngoto out_dbf;\r\nret = chsc_misc_init();\r\nif (ret)\r\ngoto out_driver;\r\nreturn ret;\r\nout_driver:\r\nchsc_cleanup_sch_driver();\r\nout_dbf:\r\nisc_unregister(CHSC_SCH_ISC);\r\nchsc_remove_dbfs();\r\nreturn ret;\r\n}\r\nstatic void __exit chsc_sch_exit(void)\r\n{\r\nchsc_misc_cleanup();\r\nchsc_cleanup_sch_driver();\r\nisc_unregister(CHSC_SCH_ISC);\r\nchsc_remove_dbfs();\r\n}
