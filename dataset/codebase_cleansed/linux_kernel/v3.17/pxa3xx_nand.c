static enum pxa3xx_nand_variant\r\npxa3xx_nand_get_variant(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(pxa3xx_nand_dt_ids, &pdev->dev);\r\nif (!of_id)\r\nreturn PXA3XX_NAND_VARIANT_PXA;\r\nreturn (enum pxa3xx_nand_variant)of_id->data;\r\n}\r\nstatic void pxa3xx_nand_set_timing(struct pxa3xx_nand_host *host,\r\nconst struct pxa3xx_nand_timing *t)\r\n{\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nunsigned long nand_clk = clk_get_rate(info->clk);\r\nuint32_t ndtr0, ndtr1;\r\nndtr0 = NDTR0_tCH(ns2cycle(t->tCH, nand_clk)) |\r\nNDTR0_tCS(ns2cycle(t->tCS, nand_clk)) |\r\nNDTR0_tWH(ns2cycle(t->tWH, nand_clk)) |\r\nNDTR0_tWP(ns2cycle(t->tWP, nand_clk)) |\r\nNDTR0_tRH(ns2cycle(t->tRH, nand_clk)) |\r\nNDTR0_tRP(ns2cycle(t->tRP, nand_clk));\r\nndtr1 = NDTR1_tR(ns2cycle(t->tR, nand_clk)) |\r\nNDTR1_tWHR(ns2cycle(t->tWHR, nand_clk)) |\r\nNDTR1_tAR(ns2cycle(t->tAR, nand_clk));\r\ninfo->ndtr0cs0 = ndtr0;\r\ninfo->ndtr1cs0 = ndtr1;\r\nnand_writel(info, NDTR0CS0, ndtr0);\r\nnand_writel(info, NDTR1CS0, ndtr1);\r\n}\r\nstatic void pxa3xx_set_datasize(struct pxa3xx_nand_info *info,\r\nstruct mtd_info *mtd)\r\n{\r\nint oob_enable = info->reg_ndcr & NDCR_SPARE_EN;\r\ninfo->data_size = mtd->writesize;\r\nif (!oob_enable)\r\nreturn;\r\ninfo->oob_size = info->spare_size;\r\nif (!info->use_ecc)\r\ninfo->oob_size += info->ecc_size;\r\n}\r\nstatic void pxa3xx_nand_start(struct pxa3xx_nand_info *info)\r\n{\r\nuint32_t ndcr;\r\nndcr = info->reg_ndcr;\r\nif (info->use_ecc) {\r\nndcr |= NDCR_ECC_EN;\r\nif (info->ecc_bch)\r\nnand_writel(info, NDECCCTRL, 0x1);\r\n} else {\r\nndcr &= ~NDCR_ECC_EN;\r\nif (info->ecc_bch)\r\nnand_writel(info, NDECCCTRL, 0x0);\r\n}\r\nif (info->use_dma)\r\nndcr |= NDCR_DMA_EN;\r\nelse\r\nndcr &= ~NDCR_DMA_EN;\r\nif (info->use_spare)\r\nndcr |= NDCR_SPARE_EN;\r\nelse\r\nndcr &= ~NDCR_SPARE_EN;\r\nndcr |= NDCR_ND_RUN;\r\nnand_writel(info, NDCR, 0);\r\nnand_writel(info, NDSR, NDSR_MASK);\r\nnand_writel(info, NDCR, ndcr);\r\n}\r\nstatic void pxa3xx_nand_stop(struct pxa3xx_nand_info *info)\r\n{\r\nuint32_t ndcr;\r\nint timeout = NAND_STOP_DELAY;\r\nndcr = nand_readl(info, NDCR);\r\nwhile ((ndcr & NDCR_ND_RUN) && (timeout-- > 0)) {\r\nndcr = nand_readl(info, NDCR);\r\nudelay(1);\r\n}\r\nif (timeout <= 0) {\r\nndcr &= ~NDCR_ND_RUN;\r\nnand_writel(info, NDCR, ndcr);\r\n}\r\nnand_writel(info, NDSR, NDSR_MASK);\r\n}\r\nstatic void __maybe_unused\r\nenable_int(struct pxa3xx_nand_info *info, uint32_t int_mask)\r\n{\r\nuint32_t ndcr;\r\nndcr = nand_readl(info, NDCR);\r\nnand_writel(info, NDCR, ndcr & ~int_mask);\r\n}\r\nstatic void disable_int(struct pxa3xx_nand_info *info, uint32_t int_mask)\r\n{\r\nuint32_t ndcr;\r\nndcr = nand_readl(info, NDCR);\r\nnand_writel(info, NDCR, ndcr | int_mask);\r\n}\r\nstatic void handle_data_pio(struct pxa3xx_nand_info *info)\r\n{\r\nunsigned int do_bytes = min(info->data_size, info->chunk_size);\r\nswitch (info->state) {\r\ncase STATE_PIO_WRITING:\r\n__raw_writesl(info->mmio_base + NDDB,\r\ninfo->data_buff + info->data_buff_pos,\r\nDIV_ROUND_UP(do_bytes, 4));\r\nif (info->oob_size > 0)\r\n__raw_writesl(info->mmio_base + NDDB,\r\ninfo->oob_buff + info->oob_buff_pos,\r\nDIV_ROUND_UP(info->oob_size, 4));\r\nbreak;\r\ncase STATE_PIO_READING:\r\n__raw_readsl(info->mmio_base + NDDB,\r\ninfo->data_buff + info->data_buff_pos,\r\nDIV_ROUND_UP(do_bytes, 4));\r\nif (info->oob_size > 0)\r\n__raw_readsl(info->mmio_base + NDDB,\r\ninfo->oob_buff + info->oob_buff_pos,\r\nDIV_ROUND_UP(info->oob_size, 4));\r\nbreak;\r\ndefault:\r\ndev_err(&info->pdev->dev, "%s: invalid state %d\n", __func__,\r\ninfo->state);\r\nBUG();\r\n}\r\ninfo->data_buff_pos += do_bytes;\r\ninfo->oob_buff_pos += info->oob_size;\r\ninfo->data_size -= do_bytes;\r\n}\r\nstatic void start_data_dma(struct pxa3xx_nand_info *info)\r\n{\r\nstruct pxa_dma_desc *desc = info->data_desc;\r\nint dma_len = ALIGN(info->data_size + info->oob_size, 32);\r\ndesc->ddadr = DDADR_STOP;\r\ndesc->dcmd = DCMD_ENDIRQEN | DCMD_WIDTH4 | DCMD_BURST32 | dma_len;\r\nswitch (info->state) {\r\ncase STATE_DMA_WRITING:\r\ndesc->dsadr = info->data_buff_phys;\r\ndesc->dtadr = info->mmio_phys + NDDB;\r\ndesc->dcmd |= DCMD_INCSRCADDR | DCMD_FLOWTRG;\r\nbreak;\r\ncase STATE_DMA_READING:\r\ndesc->dtadr = info->data_buff_phys;\r\ndesc->dsadr = info->mmio_phys + NDDB;\r\ndesc->dcmd |= DCMD_INCTRGADDR | DCMD_FLOWSRC;\r\nbreak;\r\ndefault:\r\ndev_err(&info->pdev->dev, "%s: invalid state %d\n", __func__,\r\ninfo->state);\r\nBUG();\r\n}\r\nDRCMR(info->drcmr_dat) = DRCMR_MAPVLD | info->data_dma_ch;\r\nDDADR(info->data_dma_ch) = info->data_desc_addr;\r\nDCSR(info->data_dma_ch) |= DCSR_RUN;\r\n}\r\nstatic void pxa3xx_nand_data_dma_irq(int channel, void *data)\r\n{\r\nstruct pxa3xx_nand_info *info = data;\r\nuint32_t dcsr;\r\ndcsr = DCSR(channel);\r\nDCSR(channel) = dcsr;\r\nif (dcsr & DCSR_BUSERR) {\r\ninfo->retcode = ERR_DMABUSERR;\r\n}\r\ninfo->state = STATE_DMA_DONE;\r\nenable_int(info, NDCR_INT_MASK);\r\nnand_writel(info, NDSR, NDSR_WRDREQ | NDSR_RDDREQ);\r\n}\r\nstatic void start_data_dma(struct pxa3xx_nand_info *info)\r\n{}\r\nstatic irqreturn_t pxa3xx_nand_irq(int irq, void *devid)\r\n{\r\nstruct pxa3xx_nand_info *info = devid;\r\nunsigned int status, is_completed = 0, is_ready = 0;\r\nunsigned int ready, cmd_done;\r\nif (info->cs == 0) {\r\nready = NDSR_FLASH_RDY;\r\ncmd_done = NDSR_CS0_CMDD;\r\n} else {\r\nready = NDSR_RDY;\r\ncmd_done = NDSR_CS1_CMDD;\r\n}\r\nstatus = nand_readl(info, NDSR);\r\nif (status & NDSR_UNCORERR)\r\ninfo->retcode = ERR_UNCORERR;\r\nif (status & NDSR_CORERR) {\r\ninfo->retcode = ERR_CORERR;\r\nif (info->variant == PXA3XX_NAND_VARIANT_ARMADA370 &&\r\ninfo->ecc_bch)\r\ninfo->ecc_err_cnt = NDSR_ERR_CNT(status);\r\nelse\r\ninfo->ecc_err_cnt = 1;\r\ninfo->max_bitflips = max_t(unsigned int,\r\ninfo->max_bitflips,\r\ninfo->ecc_err_cnt);\r\n}\r\nif (status & (NDSR_RDDREQ | NDSR_WRDREQ)) {\r\nif (info->use_dma) {\r\ndisable_int(info, NDCR_INT_MASK);\r\ninfo->state = (status & NDSR_RDDREQ) ?\r\nSTATE_DMA_READING : STATE_DMA_WRITING;\r\nstart_data_dma(info);\r\ngoto NORMAL_IRQ_EXIT;\r\n} else {\r\ninfo->state = (status & NDSR_RDDREQ) ?\r\nSTATE_PIO_READING : STATE_PIO_WRITING;\r\nhandle_data_pio(info);\r\n}\r\n}\r\nif (status & cmd_done) {\r\ninfo->state = STATE_CMD_DONE;\r\nis_completed = 1;\r\n}\r\nif (status & ready) {\r\ninfo->state = STATE_READY;\r\nis_ready = 1;\r\n}\r\nif (status & NDSR_WRCMDREQ) {\r\nnand_writel(info, NDSR, NDSR_WRCMDREQ);\r\nstatus &= ~NDSR_WRCMDREQ;\r\ninfo->state = STATE_CMD_HANDLE;\r\nnand_writel(info, NDCB0, info->ndcb0);\r\nnand_writel(info, NDCB0, info->ndcb1);\r\nnand_writel(info, NDCB0, info->ndcb2);\r\nif (info->variant == PXA3XX_NAND_VARIANT_ARMADA370)\r\nnand_writel(info, NDCB0, info->ndcb3);\r\n}\r\nnand_writel(info, NDSR, status);\r\nif (is_completed)\r\ncomplete(&info->cmd_complete);\r\nif (is_ready)\r\ncomplete(&info->dev_ready);\r\nNORMAL_IRQ_EXIT:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline int is_buf_blank(uint8_t *buf, size_t len)\r\n{\r\nfor (; len > 0; len--)\r\nif (*buf++ != 0xff)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void set_command_address(struct pxa3xx_nand_info *info,\r\nunsigned int page_size, uint16_t column, int page_addr)\r\n{\r\nif (page_size < PAGE_CHUNK_SIZE) {\r\ninfo->ndcb1 = ((page_addr & 0xFFFFFF) << 8)\r\n| (column & 0xFF);\r\ninfo->ndcb2 = 0;\r\n} else {\r\ninfo->ndcb1 = ((page_addr & 0xFFFF) << 16)\r\n| (column & 0xFFFF);\r\nif (page_addr & 0xFF0000)\r\ninfo->ndcb2 = (page_addr & 0xFF0000) >> 16;\r\nelse\r\ninfo->ndcb2 = 0;\r\n}\r\n}\r\nstatic void prepare_start_command(struct pxa3xx_nand_info *info, int command)\r\n{\r\nstruct pxa3xx_nand_host *host = info->host[info->cs];\r\nstruct mtd_info *mtd = host->mtd;\r\ninfo->buf_start = 0;\r\ninfo->buf_count = 0;\r\ninfo->oob_size = 0;\r\ninfo->data_buff_pos = 0;\r\ninfo->oob_buff_pos = 0;\r\ninfo->use_ecc = 0;\r\ninfo->use_spare = 1;\r\ninfo->retcode = ERR_NONE;\r\ninfo->ecc_err_cnt = 0;\r\ninfo->ndcb3 = 0;\r\ninfo->need_wait = 0;\r\nswitch (command) {\r\ncase NAND_CMD_READ0:\r\ncase NAND_CMD_PAGEPROG:\r\ninfo->use_ecc = 1;\r\ncase NAND_CMD_READOOB:\r\npxa3xx_set_datasize(info, mtd);\r\nbreak;\r\ncase NAND_CMD_PARAM:\r\ninfo->use_spare = 0;\r\nbreak;\r\ndefault:\r\ninfo->ndcb1 = 0;\r\ninfo->ndcb2 = 0;\r\nbreak;\r\n}\r\nif (command == NAND_CMD_READ0 ||\r\ncommand == NAND_CMD_READOOB ||\r\ncommand == NAND_CMD_SEQIN) {\r\ninfo->buf_count = mtd->writesize + mtd->oobsize;\r\nmemset(info->data_buff, 0xFF, info->buf_count);\r\n}\r\n}\r\nstatic int prepare_set_command(struct pxa3xx_nand_info *info, int command,\r\nint ext_cmd_type, uint16_t column, int page_addr)\r\n{\r\nint addr_cycle, exec_cmd;\r\nstruct pxa3xx_nand_host *host;\r\nstruct mtd_info *mtd;\r\nhost = info->host[info->cs];\r\nmtd = host->mtd;\r\naddr_cycle = 0;\r\nexec_cmd = 1;\r\nif (info->cs != 0)\r\ninfo->ndcb0 = NDCB0_CSEL;\r\nelse\r\ninfo->ndcb0 = 0;\r\nif (command == NAND_CMD_SEQIN)\r\nexec_cmd = 0;\r\naddr_cycle = NDCB0_ADDR_CYC(host->row_addr_cycles\r\n+ host->col_addr_cycles);\r\nswitch (command) {\r\ncase NAND_CMD_READOOB:\r\ncase NAND_CMD_READ0:\r\ninfo->buf_start = column;\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(0)\r\n| addr_cycle\r\n| NAND_CMD_READ0;\r\nif (command == NAND_CMD_READOOB)\r\ninfo->buf_start += mtd->writesize;\r\nif (mtd->writesize == PAGE_CHUNK_SIZE) {\r\ninfo->ndcb0 |= NDCB0_DBC | (NAND_CMD_READSTART << 8);\r\n} else if (mtd->writesize > PAGE_CHUNK_SIZE) {\r\ninfo->ndcb0 |= NDCB0_DBC | (NAND_CMD_READSTART << 8)\r\n| NDCB0_LEN_OVRD\r\n| NDCB0_EXT_CMD_TYPE(ext_cmd_type);\r\ninfo->ndcb3 = info->chunk_size +\r\ninfo->oob_size;\r\n}\r\nset_command_address(info, mtd->writesize, column, page_addr);\r\nbreak;\r\ncase NAND_CMD_SEQIN:\r\ninfo->buf_start = column;\r\nset_command_address(info, mtd->writesize, 0, page_addr);\r\nif (mtd->writesize > PAGE_CHUNK_SIZE) {\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(0x1)\r\n| NDCB0_EXT_CMD_TYPE(ext_cmd_type)\r\n| addr_cycle\r\n| command;\r\ninfo->data_size = 0;\r\nexec_cmd = 1;\r\n}\r\nbreak;\r\ncase NAND_CMD_PAGEPROG:\r\nif (is_buf_blank(info->data_buff,\r\n(mtd->writesize + mtd->oobsize))) {\r\nexec_cmd = 0;\r\nbreak;\r\n}\r\nif (mtd->writesize > PAGE_CHUNK_SIZE) {\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(0x1)\r\n| NDCB0_LEN_OVRD\r\n| NDCB0_EXT_CMD_TYPE(ext_cmd_type);\r\ninfo->ndcb3 = info->chunk_size +\r\ninfo->oob_size;\r\nif (info->data_size == 0) {\r\ninfo->ndcb0 = NDCB0_CMD_TYPE(0x1)\r\n| NDCB0_EXT_CMD_TYPE(ext_cmd_type)\r\n| command;\r\ninfo->ndcb1 = 0;\r\ninfo->ndcb2 = 0;\r\ninfo->ndcb3 = 0;\r\n}\r\n} else {\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(0x1)\r\n| NDCB0_AUTO_RS\r\n| NDCB0_ST_ROW_EN\r\n| NDCB0_DBC\r\n| (NAND_CMD_PAGEPROG << 8)\r\n| NAND_CMD_SEQIN\r\n| addr_cycle;\r\n}\r\nbreak;\r\ncase NAND_CMD_PARAM:\r\ninfo->buf_count = 256;\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(0)\r\n| NDCB0_ADDR_CYC(1)\r\n| NDCB0_LEN_OVRD\r\n| command;\r\ninfo->ndcb1 = (column & 0xFF);\r\ninfo->ndcb3 = 256;\r\ninfo->data_size = 256;\r\nbreak;\r\ncase NAND_CMD_READID:\r\ninfo->buf_count = host->read_id_bytes;\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(3)\r\n| NDCB0_ADDR_CYC(1)\r\n| command;\r\ninfo->ndcb1 = (column & 0xFF);\r\ninfo->data_size = 8;\r\nbreak;\r\ncase NAND_CMD_STATUS:\r\ninfo->buf_count = 1;\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(4)\r\n| NDCB0_ADDR_CYC(1)\r\n| command;\r\ninfo->data_size = 8;\r\nbreak;\r\ncase NAND_CMD_ERASE1:\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(2)\r\n| NDCB0_AUTO_RS\r\n| NDCB0_ADDR_CYC(3)\r\n| NDCB0_DBC\r\n| (NAND_CMD_ERASE2 << 8)\r\n| NAND_CMD_ERASE1;\r\ninfo->ndcb1 = page_addr;\r\ninfo->ndcb2 = 0;\r\nbreak;\r\ncase NAND_CMD_RESET:\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(5)\r\n| command;\r\nbreak;\r\ncase NAND_CMD_ERASE2:\r\nexec_cmd = 0;\r\nbreak;\r\ndefault:\r\nexec_cmd = 0;\r\ndev_err(&info->pdev->dev, "non-supported command %x\n",\r\ncommand);\r\nbreak;\r\n}\r\nreturn exec_cmd;\r\n}\r\nstatic void nand_cmdfunc(struct mtd_info *mtd, unsigned command,\r\nint column, int page_addr)\r\n{\r\nstruct pxa3xx_nand_host *host = mtd->priv;\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nint ret, exec_cmd;\r\nif (info->reg_ndcr & NDCR_DWIDTH_M)\r\ncolumn /= 2;\r\nif (info->cs != host->cs) {\r\ninfo->cs = host->cs;\r\nnand_writel(info, NDTR0CS0, info->ndtr0cs0);\r\nnand_writel(info, NDTR1CS0, info->ndtr1cs0);\r\n}\r\nprepare_start_command(info, command);\r\ninfo->state = STATE_PREPARED;\r\nexec_cmd = prepare_set_command(info, command, 0, column, page_addr);\r\nif (exec_cmd) {\r\ninit_completion(&info->cmd_complete);\r\ninit_completion(&info->dev_ready);\r\ninfo->need_wait = 1;\r\npxa3xx_nand_start(info);\r\nret = wait_for_completion_timeout(&info->cmd_complete,\r\nCHIP_DELAY_TIMEOUT);\r\nif (!ret) {\r\ndev_err(&info->pdev->dev, "Wait time out!!!\n");\r\npxa3xx_nand_stop(info);\r\n}\r\n}\r\ninfo->state = STATE_IDLE;\r\n}\r\nstatic void nand_cmdfunc_extended(struct mtd_info *mtd,\r\nconst unsigned command,\r\nint column, int page_addr)\r\n{\r\nstruct pxa3xx_nand_host *host = mtd->priv;\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nint ret, exec_cmd, ext_cmd_type;\r\nif (info->reg_ndcr & NDCR_DWIDTH_M)\r\ncolumn /= 2;\r\nif (info->cs != host->cs) {\r\ninfo->cs = host->cs;\r\nnand_writel(info, NDTR0CS0, info->ndtr0cs0);\r\nnand_writel(info, NDTR1CS0, info->ndtr1cs0);\r\n}\r\nswitch (command) {\r\ncase NAND_CMD_READ0:\r\ncase NAND_CMD_READOOB:\r\next_cmd_type = EXT_CMD_TYPE_MONO;\r\nbreak;\r\ncase NAND_CMD_SEQIN:\r\next_cmd_type = EXT_CMD_TYPE_DISPATCH;\r\nbreak;\r\ncase NAND_CMD_PAGEPROG:\r\next_cmd_type = EXT_CMD_TYPE_NAKED_RW;\r\nbreak;\r\ndefault:\r\next_cmd_type = 0;\r\nbreak;\r\n}\r\nprepare_start_command(info, command);\r\ninfo->need_wait = 1;\r\ninit_completion(&info->dev_ready);\r\ndo {\r\ninfo->state = STATE_PREPARED;\r\nexec_cmd = prepare_set_command(info, command, ext_cmd_type,\r\ncolumn, page_addr);\r\nif (!exec_cmd) {\r\ninfo->need_wait = 0;\r\ncomplete(&info->dev_ready);\r\nbreak;\r\n}\r\ninit_completion(&info->cmd_complete);\r\npxa3xx_nand_start(info);\r\nret = wait_for_completion_timeout(&info->cmd_complete,\r\nCHIP_DELAY_TIMEOUT);\r\nif (!ret) {\r\ndev_err(&info->pdev->dev, "Wait time out!!!\n");\r\npxa3xx_nand_stop(info);\r\nbreak;\r\n}\r\nif (info->data_size == 0 && command != NAND_CMD_PAGEPROG)\r\nbreak;\r\nif (info->data_size == 0 &&\r\ncommand == NAND_CMD_PAGEPROG &&\r\next_cmd_type == EXT_CMD_TYPE_DISPATCH)\r\nbreak;\r\nif (command == NAND_CMD_READ0 || command == NAND_CMD_READOOB) {\r\nif (info->data_size == info->chunk_size)\r\next_cmd_type = EXT_CMD_TYPE_LAST_RW;\r\nelse\r\next_cmd_type = EXT_CMD_TYPE_NAKED_RW;\r\n} else if (command == NAND_CMD_PAGEPROG &&\r\ninfo->data_size == 0) {\r\next_cmd_type = EXT_CMD_TYPE_DISPATCH;\r\n}\r\n} while (1);\r\ninfo->state = STATE_IDLE;\r\n}\r\nstatic int pxa3xx_nand_write_page_hwecc(struct mtd_info *mtd,\r\nstruct nand_chip *chip, const uint8_t *buf, int oob_required)\r\n{\r\nchip->write_buf(mtd, buf, mtd->writesize);\r\nchip->write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_read_page_hwecc(struct mtd_info *mtd,\r\nstruct nand_chip *chip, uint8_t *buf, int oob_required,\r\nint page)\r\n{\r\nstruct pxa3xx_nand_host *host = mtd->priv;\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nchip->read_buf(mtd, buf, mtd->writesize);\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nif (info->retcode == ERR_CORERR && info->use_ecc) {\r\nmtd->ecc_stats.corrected += info->ecc_err_cnt;\r\n} else if (info->retcode == ERR_UNCORERR) {\r\nif (is_buf_blank(buf, mtd->writesize))\r\ninfo->retcode = ERR_NONE;\r\nelse\r\nmtd->ecc_stats.failed++;\r\n}\r\nreturn info->max_bitflips;\r\n}\r\nstatic uint8_t pxa3xx_nand_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct pxa3xx_nand_host *host = mtd->priv;\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nchar retval = 0xFF;\r\nif (info->buf_start < info->buf_count)\r\nretval = info->data_buff[info->buf_start++];\r\nreturn retval;\r\n}\r\nstatic u16 pxa3xx_nand_read_word(struct mtd_info *mtd)\r\n{\r\nstruct pxa3xx_nand_host *host = mtd->priv;\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nu16 retval = 0xFFFF;\r\nif (!(info->buf_start & 0x01) && info->buf_start < info->buf_count) {\r\nretval = *((u16 *)(info->data_buff+info->buf_start));\r\ninfo->buf_start += 2;\r\n}\r\nreturn retval;\r\n}\r\nstatic void pxa3xx_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nstruct pxa3xx_nand_host *host = mtd->priv;\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nint real_len = min_t(size_t, len, info->buf_count - info->buf_start);\r\nmemcpy(buf, info->data_buff + info->buf_start, real_len);\r\ninfo->buf_start += real_len;\r\n}\r\nstatic void pxa3xx_nand_write_buf(struct mtd_info *mtd,\r\nconst uint8_t *buf, int len)\r\n{\r\nstruct pxa3xx_nand_host *host = mtd->priv;\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nint real_len = min_t(size_t, len, info->buf_count - info->buf_start);\r\nmemcpy(info->data_buff + info->buf_start, buf, real_len);\r\ninfo->buf_start += real_len;\r\n}\r\nstatic void pxa3xx_nand_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\nreturn;\r\n}\r\nstatic int pxa3xx_nand_waitfunc(struct mtd_info *mtd, struct nand_chip *this)\r\n{\r\nstruct pxa3xx_nand_host *host = mtd->priv;\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nint ret;\r\nif (info->need_wait) {\r\nret = wait_for_completion_timeout(&info->dev_ready,\r\nCHIP_DELAY_TIMEOUT);\r\ninfo->need_wait = 0;\r\nif (!ret) {\r\ndev_err(&info->pdev->dev, "Ready time out!!!\n");\r\nreturn NAND_STATUS_FAIL;\r\n}\r\n}\r\nif (this->state == FL_WRITING || this->state == FL_ERASING) {\r\nif (info->retcode == ERR_NONE)\r\nreturn 0;\r\nelse\r\nreturn NAND_STATUS_FAIL;\r\n}\r\nreturn NAND_STATUS_READY;\r\n}\r\nstatic int pxa3xx_nand_config_flash(struct pxa3xx_nand_info *info,\r\nconst struct pxa3xx_nand_flash *f)\r\n{\r\nstruct platform_device *pdev = info->pdev;\r\nstruct pxa3xx_nand_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct pxa3xx_nand_host *host = info->host[info->cs];\r\nuint32_t ndcr = 0x0;\r\nif (f->page_size != 2048 && f->page_size != 512) {\r\ndev_err(&pdev->dev, "Current only support 2048 and 512 size\n");\r\nreturn -EINVAL;\r\n}\r\nif (f->flash_width != 16 && f->flash_width != 8) {\r\ndev_err(&pdev->dev, "Only support 8bit and 16 bit!\n");\r\nreturn -EINVAL;\r\n}\r\nhost->read_id_bytes = (f->page_size == 2048) ? 4 : 2;\r\nhost->col_addr_cycles = (f->page_size == 2048) ? 2 : 1;\r\nif (f->num_blocks * f->page_per_block > 65536)\r\nhost->row_addr_cycles = 3;\r\nelse\r\nhost->row_addr_cycles = 2;\r\nndcr |= (pdata->enable_arbiter) ? NDCR_ND_ARB_EN : 0;\r\nndcr |= (host->col_addr_cycles == 2) ? NDCR_RA_START : 0;\r\nndcr |= (f->page_per_block == 64) ? NDCR_PG_PER_BLK : 0;\r\nndcr |= (f->page_size == 2048) ? NDCR_PAGE_SZ : 0;\r\nndcr |= (f->flash_width == 16) ? NDCR_DWIDTH_M : 0;\r\nndcr |= (f->dfc_width == 16) ? NDCR_DWIDTH_C : 0;\r\nndcr |= NDCR_RD_ID_CNT(host->read_id_bytes);\r\nndcr |= NDCR_SPARE_EN;\r\ninfo->reg_ndcr = ndcr;\r\npxa3xx_nand_set_timing(host, f->timing);\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_detect_config(struct pxa3xx_nand_info *info)\r\n{\r\nstruct pxa3xx_nand_host *host = info->host[0];\r\nuint32_t ndcr = nand_readl(info, NDCR);\r\nif (ndcr & NDCR_PAGE_SZ) {\r\ninfo->chunk_size = 2048;\r\nhost->read_id_bytes = 4;\r\n} else {\r\ninfo->chunk_size = 512;\r\nhost->read_id_bytes = 2;\r\n}\r\ninfo->reg_ndcr = ndcr & ~NDCR_INT_MASK;\r\ninfo->ndtr0cs0 = nand_readl(info, NDTR0CS0);\r\ninfo->ndtr1cs0 = nand_readl(info, NDTR1CS0);\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_init_buff(struct pxa3xx_nand_info *info)\r\n{\r\nstruct platform_device *pdev = info->pdev;\r\nint data_desc_offset = info->buf_size - sizeof(struct pxa_dma_desc);\r\nif (use_dma == 0) {\r\ninfo->data_buff = kmalloc(info->buf_size, GFP_KERNEL);\r\nif (info->data_buff == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\ninfo->data_buff = dma_alloc_coherent(&pdev->dev, info->buf_size,\r\n&info->data_buff_phys, GFP_KERNEL);\r\nif (info->data_buff == NULL) {\r\ndev_err(&pdev->dev, "failed to allocate dma buffer\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo->data_desc = (void *)info->data_buff + data_desc_offset;\r\ninfo->data_desc_addr = info->data_buff_phys + data_desc_offset;\r\ninfo->data_dma_ch = pxa_request_dma("nand-data", DMA_PRIO_LOW,\r\npxa3xx_nand_data_dma_irq, info);\r\nif (info->data_dma_ch < 0) {\r\ndev_err(&pdev->dev, "failed to request data dma\n");\r\ndma_free_coherent(&pdev->dev, info->buf_size,\r\ninfo->data_buff, info->data_buff_phys);\r\nreturn info->data_dma_ch;\r\n}\r\ninfo->use_dma = 1;\r\nreturn 0;\r\n}\r\nstatic void pxa3xx_nand_free_buff(struct pxa3xx_nand_info *info)\r\n{\r\nstruct platform_device *pdev = info->pdev;\r\nif (info->use_dma) {\r\npxa_free_dma(info->data_dma_ch);\r\ndma_free_coherent(&pdev->dev, info->buf_size,\r\ninfo->data_buff, info->data_buff_phys);\r\n} else {\r\nkfree(info->data_buff);\r\n}\r\n}\r\nstatic int pxa3xx_nand_init_buff(struct pxa3xx_nand_info *info)\r\n{\r\ninfo->data_buff = kmalloc(info->buf_size, GFP_KERNEL);\r\nif (info->data_buff == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void pxa3xx_nand_free_buff(struct pxa3xx_nand_info *info)\r\n{\r\nkfree(info->data_buff);\r\n}\r\nstatic int pxa3xx_nand_sensing(struct pxa3xx_nand_info *info)\r\n{\r\nstruct mtd_info *mtd;\r\nstruct nand_chip *chip;\r\nint ret;\r\nmtd = info->host[info->cs]->mtd;\r\nchip = mtd->priv;\r\nret = pxa3xx_nand_config_flash(info, &builtin_flash_types[0]);\r\nif (ret)\r\nreturn ret;\r\nchip->cmdfunc(mtd, NAND_CMD_RESET, 0, 0);\r\nret = chip->waitfunc(mtd, chip);\r\nif (ret & NAND_STATUS_FAIL)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int pxa_ecc_init(struct pxa3xx_nand_info *info,\r\nstruct nand_ecc_ctrl *ecc,\r\nint strength, int ecc_stepsize, int page_size)\r\n{\r\nif (strength == 1 && ecc_stepsize == 512 && page_size == 2048) {\r\ninfo->chunk_size = 2048;\r\ninfo->spare_size = 40;\r\ninfo->ecc_size = 24;\r\necc->mode = NAND_ECC_HW;\r\necc->size = 512;\r\necc->strength = 1;\r\n} else if (strength == 1 && ecc_stepsize == 512 && page_size == 512) {\r\ninfo->chunk_size = 512;\r\ninfo->spare_size = 8;\r\ninfo->ecc_size = 8;\r\necc->mode = NAND_ECC_HW;\r\necc->size = 512;\r\necc->strength = 1;\r\n} else if (strength == 4 && ecc_stepsize == 512 && page_size == 2048) {\r\ninfo->ecc_bch = 1;\r\ninfo->chunk_size = 2048;\r\ninfo->spare_size = 32;\r\ninfo->ecc_size = 32;\r\necc->mode = NAND_ECC_HW;\r\necc->size = info->chunk_size;\r\necc->layout = &ecc_layout_2KB_bch4bit;\r\necc->strength = 16;\r\n} else if (strength == 4 && ecc_stepsize == 512 && page_size == 4096) {\r\ninfo->ecc_bch = 1;\r\ninfo->chunk_size = 2048;\r\ninfo->spare_size = 32;\r\ninfo->ecc_size = 32;\r\necc->mode = NAND_ECC_HW;\r\necc->size = info->chunk_size;\r\necc->layout = &ecc_layout_4KB_bch4bit;\r\necc->strength = 16;\r\n} else if (strength == 8 && ecc_stepsize == 512 && page_size == 4096) {\r\ninfo->ecc_bch = 1;\r\ninfo->chunk_size = 1024;\r\ninfo->spare_size = 0;\r\ninfo->ecc_size = 32;\r\necc->mode = NAND_ECC_HW;\r\necc->size = info->chunk_size;\r\necc->layout = &ecc_layout_4KB_bch8bit;\r\necc->strength = 16;\r\n} else {\r\ndev_err(&info->pdev->dev,\r\n"ECC strength %d at page size %d is not supported\n",\r\nstrength, page_size);\r\nreturn -ENODEV;\r\n}\r\ndev_info(&info->pdev->dev, "ECC strength %d, ECC step size %d\n",\r\necc->strength, ecc->size);\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_scan(struct mtd_info *mtd)\r\n{\r\nstruct pxa3xx_nand_host *host = mtd->priv;\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nstruct platform_device *pdev = info->pdev;\r\nstruct pxa3xx_nand_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct nand_flash_dev pxa3xx_flash_ids[2], *def = NULL;\r\nconst struct pxa3xx_nand_flash *f = NULL;\r\nstruct nand_chip *chip = mtd->priv;\r\nuint32_t id = -1;\r\nuint64_t chipsize;\r\nint i, ret, num;\r\nuint16_t ecc_strength, ecc_step;\r\nif (pdata->keep_config && !pxa3xx_nand_detect_config(info))\r\ngoto KEEP_CONFIG;\r\nret = pxa3xx_nand_sensing(info);\r\nif (ret) {\r\ndev_info(&info->pdev->dev, "There is no chip on cs %d!\n",\r\ninfo->cs);\r\nreturn ret;\r\n}\r\nchip->cmdfunc(mtd, NAND_CMD_READID, 0, 0);\r\nid = *((uint16_t *)(info->data_buff));\r\nif (id != 0)\r\ndev_info(&info->pdev->dev, "Detect a flash id %x\n", id);\r\nelse {\r\ndev_warn(&info->pdev->dev,\r\n"Read out ID 0, potential timing set wrong!!\n");\r\nreturn -EINVAL;\r\n}\r\nnum = ARRAY_SIZE(builtin_flash_types) + pdata->num_flash - 1;\r\nfor (i = 0; i < num; i++) {\r\nif (i < pdata->num_flash)\r\nf = pdata->flash + i;\r\nelse\r\nf = &builtin_flash_types[i - pdata->num_flash + 1];\r\nif (f->chip_id == id)\r\nbreak;\r\n}\r\nif (i >= (ARRAY_SIZE(builtin_flash_types) + pdata->num_flash - 1)) {\r\ndev_err(&info->pdev->dev, "ERROR!! flash not defined!!!\n");\r\nreturn -EINVAL;\r\n}\r\nret = pxa3xx_nand_config_flash(info, f);\r\nif (ret) {\r\ndev_err(&info->pdev->dev, "ERROR! Configure failed\n");\r\nreturn ret;\r\n}\r\npxa3xx_flash_ids[0].name = f->name;\r\npxa3xx_flash_ids[0].dev_id = (f->chip_id >> 8) & 0xffff;\r\npxa3xx_flash_ids[0].pagesize = f->page_size;\r\nchipsize = (uint64_t)f->num_blocks * f->page_per_block * f->page_size;\r\npxa3xx_flash_ids[0].chipsize = chipsize >> 20;\r\npxa3xx_flash_ids[0].erasesize = f->page_size * f->page_per_block;\r\nif (f->flash_width == 16)\r\npxa3xx_flash_ids[0].options = NAND_BUSWIDTH_16;\r\npxa3xx_flash_ids[1].name = NULL;\r\ndef = pxa3xx_flash_ids;\r\nKEEP_CONFIG:\r\nif (info->reg_ndcr & NDCR_DWIDTH_M)\r\nchip->options |= NAND_BUSWIDTH_16;\r\nif (info->variant == PXA3XX_NAND_VARIANT_ARMADA370)\r\nnand_writel(info, NDECCCTRL, 0x0);\r\nif (nand_scan_ident(mtd, 1, def))\r\nreturn -ENODEV;\r\nif (pdata->flash_bbt) {\r\nchip->bbt_options |= NAND_BBT_USE_FLASH |\r\nNAND_BBT_NO_OOB_BBM;\r\nchip->bbt_td = &bbt_main_descr;\r\nchip->bbt_md = &bbt_mirror_descr;\r\n}\r\nif (mtd->writesize > PAGE_CHUNK_SIZE) {\r\nif (info->variant == PXA3XX_NAND_VARIANT_ARMADA370) {\r\nchip->cmdfunc = nand_cmdfunc_extended;\r\n} else {\r\ndev_err(&info->pdev->dev,\r\n"unsupported page size on this variant\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (pdata->ecc_strength && pdata->ecc_step_size) {\r\necc_strength = pdata->ecc_strength;\r\necc_step = pdata->ecc_step_size;\r\n} else {\r\necc_strength = chip->ecc_strength_ds;\r\necc_step = chip->ecc_step_ds;\r\n}\r\nif (ecc_strength < 1 && ecc_step < 1) {\r\necc_strength = 1;\r\necc_step = 512;\r\n}\r\nret = pxa_ecc_init(info, &chip->ecc, ecc_strength,\r\necc_step, mtd->writesize);\r\nif (ret)\r\nreturn ret;\r\nif (mtd->writesize >= 2048)\r\nhost->col_addr_cycles = 2;\r\nelse\r\nhost->col_addr_cycles = 1;\r\nkfree(info->data_buff);\r\ninfo->buf_size = mtd->writesize + mtd->oobsize;\r\nret = pxa3xx_nand_init_buff(info);\r\nif (ret)\r\nreturn ret;\r\ninfo->oob_buff = info->data_buff + mtd->writesize;\r\nif ((mtd->size >> chip->page_shift) > 65536)\r\nhost->row_addr_cycles = 3;\r\nelse\r\nhost->row_addr_cycles = 2;\r\nreturn nand_scan_tail(mtd);\r\n}\r\nstatic int alloc_nand_resource(struct platform_device *pdev)\r\n{\r\nstruct pxa3xx_nand_platform_data *pdata;\r\nstruct pxa3xx_nand_info *info;\r\nstruct pxa3xx_nand_host *host;\r\nstruct nand_chip *chip = NULL;\r\nstruct mtd_info *mtd;\r\nstruct resource *r;\r\nint ret, irq, cs;\r\npdata = dev_get_platdata(&pdev->dev);\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info) + (sizeof(*mtd) +\r\nsizeof(*host)) * pdata->num_cs, GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->pdev = pdev;\r\ninfo->variant = pxa3xx_nand_get_variant(pdev);\r\nfor (cs = 0; cs < pdata->num_cs; cs++) {\r\nmtd = (struct mtd_info *)((unsigned int)&info[1] +\r\n(sizeof(*mtd) + sizeof(*host)) * cs);\r\nchip = (struct nand_chip *)(&mtd[1]);\r\nhost = (struct pxa3xx_nand_host *)chip;\r\ninfo->host[cs] = host;\r\nhost->mtd = mtd;\r\nhost->cs = cs;\r\nhost->info_data = info;\r\nmtd->priv = host;\r\nmtd->owner = THIS_MODULE;\r\nchip->ecc.read_page = pxa3xx_nand_read_page_hwecc;\r\nchip->ecc.write_page = pxa3xx_nand_write_page_hwecc;\r\nchip->controller = &info->controller;\r\nchip->waitfunc = pxa3xx_nand_waitfunc;\r\nchip->select_chip = pxa3xx_nand_select_chip;\r\nchip->read_word = pxa3xx_nand_read_word;\r\nchip->read_byte = pxa3xx_nand_read_byte;\r\nchip->read_buf = pxa3xx_nand_read_buf;\r\nchip->write_buf = pxa3xx_nand_write_buf;\r\nchip->options |= NAND_NO_SUBPAGE_WRITE;\r\nchip->cmdfunc = nand_cmdfunc;\r\n}\r\nspin_lock_init(&chip->controller->lock);\r\ninit_waitqueue_head(&chip->controller->wq);\r\ninfo->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(info->clk)) {\r\ndev_err(&pdev->dev, "failed to get nand clock\n");\r\nreturn PTR_ERR(info->clk);\r\n}\r\nret = clk_prepare_enable(info->clk);\r\nif (ret < 0)\r\nreturn ret;\r\nif (use_dma) {\r\nif (pdev->dev.of_node &&\r\nof_machine_is_compatible("marvell,pxa3xx")) {\r\ninfo->drcmr_dat = 97;\r\ninfo->drcmr_cmd = 99;\r\n} else {\r\nr = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (r == NULL) {\r\ndev_err(&pdev->dev,\r\n"no resource defined for data DMA\n");\r\nret = -ENXIO;\r\ngoto fail_disable_clk;\r\n}\r\ninfo->drcmr_dat = r->start;\r\nr = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (r == NULL) {\r\ndev_err(&pdev->dev,\r\n"no resource defined for cmd DMA\n");\r\nret = -ENXIO;\r\ngoto fail_disable_clk;\r\n}\r\ninfo->drcmr_cmd = r->start;\r\n}\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no IRQ resource defined\n");\r\nret = -ENXIO;\r\ngoto fail_disable_clk;\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ninfo->mmio_base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(info->mmio_base)) {\r\nret = PTR_ERR(info->mmio_base);\r\ngoto fail_disable_clk;\r\n}\r\ninfo->mmio_phys = r->start;\r\ninfo->buf_size = INIT_BUFFER_SIZE;\r\ninfo->data_buff = kmalloc(info->buf_size, GFP_KERNEL);\r\nif (info->data_buff == NULL) {\r\nret = -ENOMEM;\r\ngoto fail_disable_clk;\r\n}\r\ndisable_int(info, NDSR_MASK);\r\nret = request_irq(irq, pxa3xx_nand_irq, 0, pdev->name, info);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to request IRQ\n");\r\ngoto fail_free_buf;\r\n}\r\nplatform_set_drvdata(pdev, info);\r\nreturn 0;\r\nfail_free_buf:\r\nfree_irq(irq, info);\r\nkfree(info->data_buff);\r\nfail_disable_clk:\r\nclk_disable_unprepare(info->clk);\r\nreturn ret;\r\n}\r\nstatic int pxa3xx_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct pxa3xx_nand_info *info = platform_get_drvdata(pdev);\r\nstruct pxa3xx_nand_platform_data *pdata;\r\nint irq, cs;\r\nif (!info)\r\nreturn 0;\r\npdata = dev_get_platdata(&pdev->dev);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq >= 0)\r\nfree_irq(irq, info);\r\npxa3xx_nand_free_buff(info);\r\nclk_disable_unprepare(info->clk);\r\nfor (cs = 0; cs < pdata->num_cs; cs++)\r\nnand_release(info->host[cs]->mtd);\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_probe_dt(struct platform_device *pdev)\r\n{\r\nstruct pxa3xx_nand_platform_data *pdata;\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *of_id =\r\nof_match_device(pxa3xx_nand_dt_ids, &pdev->dev);\r\nif (!of_id)\r\nreturn 0;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nif (of_get_property(np, "marvell,nand-enable-arbiter", NULL))\r\npdata->enable_arbiter = 1;\r\nif (of_get_property(np, "marvell,nand-keep-config", NULL))\r\npdata->keep_config = 1;\r\nof_property_read_u32(np, "num-cs", &pdata->num_cs);\r\npdata->flash_bbt = of_get_nand_on_flash_bbt(np);\r\npdata->ecc_strength = of_get_nand_ecc_strength(np);\r\nif (pdata->ecc_strength < 0)\r\npdata->ecc_strength = 0;\r\npdata->ecc_step_size = of_get_nand_ecc_step_size(np);\r\nif (pdata->ecc_step_size < 0)\r\npdata->ecc_step_size = 0;\r\npdev->dev.platform_data = pdata;\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct pxa3xx_nand_platform_data *pdata;\r\nstruct mtd_part_parser_data ppdata = {};\r\nstruct pxa3xx_nand_info *info;\r\nint ret, cs, probe_success;\r\n#ifndef ARCH_HAS_DMA\r\nif (use_dma) {\r\nuse_dma = 0;\r\ndev_warn(&pdev->dev,\r\n"This platform can't do DMA on this device\n");\r\n}\r\n#endif\r\nret = pxa3xx_nand_probe_dt(pdev);\r\nif (ret)\r\nreturn ret;\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data defined\n");\r\nreturn -ENODEV;\r\n}\r\nret = alloc_nand_resource(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "alloc nand resource failed\n");\r\nreturn ret;\r\n}\r\ninfo = platform_get_drvdata(pdev);\r\nprobe_success = 0;\r\nfor (cs = 0; cs < pdata->num_cs; cs++) {\r\nstruct mtd_info *mtd = info->host[cs]->mtd;\r\nmtd->name = "pxa3xx_nand-0";\r\ninfo->cs = cs;\r\nret = pxa3xx_nand_scan(mtd);\r\nif (ret) {\r\ndev_warn(&pdev->dev, "failed to scan nand at cs %d\n",\r\ncs);\r\ncontinue;\r\n}\r\nppdata.of_node = pdev->dev.of_node;\r\nret = mtd_device_parse_register(mtd, NULL,\r\n&ppdata, pdata->parts[cs],\r\npdata->nr_parts[cs]);\r\nif (!ret)\r\nprobe_success = 1;\r\n}\r\nif (!probe_success) {\r\npxa3xx_nand_remove(pdev);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct pxa3xx_nand_info *info = platform_get_drvdata(pdev);\r\nstruct pxa3xx_nand_platform_data *pdata;\r\nstruct mtd_info *mtd;\r\nint cs;\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (info->state) {\r\ndev_err(&pdev->dev, "driver busy, state = %d\n", info->state);\r\nreturn -EAGAIN;\r\n}\r\nfor (cs = 0; cs < pdata->num_cs; cs++) {\r\nmtd = info->host[cs]->mtd;\r\nmtd_suspend(mtd);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_resume(struct platform_device *pdev)\r\n{\r\nstruct pxa3xx_nand_info *info = platform_get_drvdata(pdev);\r\nstruct pxa3xx_nand_platform_data *pdata;\r\nstruct mtd_info *mtd;\r\nint cs;\r\npdata = dev_get_platdata(&pdev->dev);\r\ndisable_int(info, NDCR_INT_MASK);\r\ninfo->cs = 0xff;\r\nnand_writel(info, NDSR, NDSR_MASK);\r\nfor (cs = 0; cs < pdata->num_cs; cs++) {\r\nmtd = info->host[cs]->mtd;\r\nmtd_resume(mtd);\r\n}\r\nreturn 0;\r\n}
