static int da9063_set_current_limit(struct regulator_dev *rdev,\r\nint min_uA, int max_uA)\r\n{\r\nstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\r\nconst struct da9063_regulator_info *rinfo = regl->info;\r\nint n, tval;\r\nfor (n = 0; n < rinfo->n_current_limits; n++) {\r\ntval = rinfo->current_limits[n];\r\nif (tval >= min_uA && tval <= max_uA)\r\nreturn regmap_field_write(regl->ilimit, n);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int da9063_get_current_limit(struct regulator_dev *rdev)\r\n{\r\nstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\r\nconst struct da9063_regulator_info *rinfo = regl->info;\r\nunsigned int sel;\r\nint ret;\r\nret = regmap_field_read(regl->ilimit, &sel);\r\nif (ret < 0)\r\nreturn ret;\r\nif (sel >= rinfo->n_current_limits)\r\nsel = rinfo->n_current_limits - 1;\r\nreturn rinfo->current_limits[sel];\r\n}\r\nstatic int da9063_buck_set_mode(struct regulator_dev *rdev, unsigned mode)\r\n{\r\nstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\r\nunsigned val;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_FAST:\r\nval = BUCK_MODE_SYNC;\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\nval = BUCK_MODE_AUTO;\r\nbreak;\r\ncase REGULATOR_MODE_STANDBY:\r\nval = BUCK_MODE_SLEEP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_field_write(regl->mode, val);\r\n}\r\nstatic unsigned da9063_buck_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\r\nstruct regmap_field *field;\r\nunsigned int val, mode = 0;\r\nint ret;\r\nret = regmap_field_read(regl->mode, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (val) {\r\ndefault:\r\ncase BUCK_MODE_MANUAL:\r\nmode = REGULATOR_MODE_FAST | REGULATOR_MODE_STANDBY;\r\nbreak;\r\ncase BUCK_MODE_SLEEP:\r\nreturn REGULATOR_MODE_STANDBY;\r\ncase BUCK_MODE_SYNC:\r\nreturn REGULATOR_MODE_FAST;\r\ncase BUCK_MODE_AUTO:\r\nreturn REGULATOR_MODE_NORMAL;\r\n}\r\nret = regmap_field_read(regl->suspend, &val);\r\nif (ret < 0)\r\nreturn 0;\r\nif (val)\r\nfield = regl->suspend_sleep;\r\nelse\r\nfield = regl->sleep;\r\nret = regmap_field_read(field, &val);\r\nif (ret < 0)\r\nreturn 0;\r\nif (val)\r\nmode &= REGULATOR_MODE_STANDBY;\r\nelse\r\nmode &= REGULATOR_MODE_NORMAL | REGULATOR_MODE_FAST;\r\nreturn mode;\r\n}\r\nstatic int da9063_ldo_set_mode(struct regulator_dev *rdev, unsigned mode)\r\n{\r\nstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\r\nunsigned val;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_NORMAL:\r\nval = 0;\r\nbreak;\r\ncase REGULATOR_MODE_STANDBY:\r\nval = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_field_write(regl->sleep, val);\r\n}\r\nstatic unsigned da9063_ldo_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\r\nstruct regmap_field *field;\r\nint ret, val;\r\nret = regmap_field_read(regl->suspend, &val);\r\nif (ret < 0)\r\nreturn 0;\r\nif (val)\r\nfield = regl->suspend_sleep;\r\nelse\r\nfield = regl->sleep;\r\nret = regmap_field_read(field, &val);\r\nif (ret < 0)\r\nreturn 0;\r\nif (val)\r\nreturn REGULATOR_MODE_STANDBY;\r\nelse\r\nreturn REGULATOR_MODE_NORMAL;\r\n}\r\nstatic int da9063_buck_get_status(struct regulator_dev *rdev)\r\n{\r\nint ret = regulator_is_enabled_regmap(rdev);\r\nif (ret == 0) {\r\nret = REGULATOR_STATUS_OFF;\r\n} else if (ret > 0) {\r\nret = da9063_buck_get_mode(rdev);\r\nif (ret > 0)\r\nret = regulator_mode_to_status(ret);\r\nelse if (ret == 0)\r\nret = -EIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int da9063_ldo_get_status(struct regulator_dev *rdev)\r\n{\r\nint ret = regulator_is_enabled_regmap(rdev);\r\nif (ret == 0) {\r\nret = REGULATOR_STATUS_OFF;\r\n} else if (ret > 0) {\r\nret = da9063_ldo_get_mode(rdev);\r\nif (ret > 0)\r\nret = regulator_mode_to_status(ret);\r\nelse if (ret == 0)\r\nret = -EIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int da9063_set_suspend_voltage(struct regulator_dev *rdev, int uV)\r\n{\r\nstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\r\nconst struct da9063_regulator_info *rinfo = regl->info;\r\nint ret, sel;\r\nsel = regulator_map_voltage_linear(rdev, uV, uV);\r\nif (sel < 0)\r\nreturn sel;\r\nsel <<= ffs(rdev->desc->vsel_mask) - 1;\r\nret = regmap_update_bits(regl->hw->regmap, rinfo->suspend_vsel_reg,\r\nrdev->desc->vsel_mask, sel);\r\nreturn ret;\r\n}\r\nstatic int da9063_suspend_enable(struct regulator_dev *rdev)\r\n{\r\nstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\r\nreturn regmap_field_write(regl->suspend, 1);\r\n}\r\nstatic int da9063_suspend_disable(struct regulator_dev *rdev)\r\n{\r\nstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\r\nreturn regmap_field_write(regl->suspend, 0);\r\n}\r\nstatic int da9063_buck_set_suspend_mode(struct regulator_dev *rdev, unsigned mode)\r\n{\r\nstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\r\nint val;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_FAST:\r\nval = BUCK_MODE_SYNC;\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\nval = BUCK_MODE_AUTO;\r\nbreak;\r\ncase REGULATOR_MODE_STANDBY:\r\nval = BUCK_MODE_SLEEP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_field_write(regl->mode, val);\r\n}\r\nstatic int da9063_ldo_set_suspend_mode(struct regulator_dev *rdev, unsigned mode)\r\n{\r\nstruct da9063_regulator *regl = rdev_get_drvdata(rdev);\r\nunsigned val;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_NORMAL:\r\nval = 0;\r\nbreak;\r\ncase REGULATOR_MODE_STANDBY:\r\nval = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_field_write(regl->suspend_sleep, val);\r\n}\r\nstatic irqreturn_t da9063_ldo_lim_event(int irq, void *data)\r\n{\r\nstruct da9063_regulators *regulators = data;\r\nstruct da9063 *hw = regulators->regulator[0].hw;\r\nstruct da9063_regulator *regl;\r\nint bits, i , ret;\r\nret = regmap_read(hw->regmap, DA9063_REG_STATUS_D, &bits);\r\nif (ret < 0)\r\nreturn IRQ_NONE;\r\nfor (i = regulators->n_regulators - 1; i >= 0; i--) {\r\nregl = &regulators->regulator[i];\r\nif (regl->info->oc_event.reg != DA9063_REG_STATUS_D)\r\ncontinue;\r\nif (BIT(regl->info->oc_event.lsb) & bits)\r\nregulator_notifier_call_chain(regl->rdev,\r\nREGULATOR_EVENT_OVER_CURRENT, NULL);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic const struct regulator_init_data *da9063_get_regulator_initdata(\r\nconst struct da9063_regulators_pdata *regl_pdata, int id)\r\n{\r\nint i;\r\nfor (i = 0; i < regl_pdata->n_regulators; i++) {\r\nif (id == regl_pdata->regulator_data[i].id)\r\nreturn regl_pdata->regulator_data[i].initdata;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct da9063_regulators_pdata *da9063_parse_regulators_dt(\r\nstruct platform_device *pdev,\r\nstruct of_regulator_match **da9063_reg_matches)\r\n{\r\nstruct da9063_regulators_pdata *pdata;\r\nstruct da9063_regulator_data *rdata;\r\nstruct device_node *node;\r\nint i, n, num;\r\nnode = of_get_child_by_name(pdev->dev.parent->of_node, "regulators");\r\nif (!node) {\r\ndev_err(&pdev->dev, "Regulators device node not found\n");\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nnum = of_regulator_match(&pdev->dev, node, da9063_matches,\r\nARRAY_SIZE(da9063_matches));\r\nof_node_put(node);\r\nif (num < 0) {\r\ndev_err(&pdev->dev, "Failed to match regulators\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\npdata->regulator_data = devm_kzalloc(&pdev->dev,\r\nnum * sizeof(*pdata->regulator_data),\r\nGFP_KERNEL);\r\nif (!pdata->regulator_data)\r\nreturn ERR_PTR(-ENOMEM);\r\npdata->n_regulators = num;\r\nn = 0;\r\nfor (i = 0; i < ARRAY_SIZE(da9063_matches); i++) {\r\nif (!da9063_matches[i].init_data)\r\ncontinue;\r\nrdata = &pdata->regulator_data[n];\r\nrdata->id = i;\r\nrdata->initdata = da9063_matches[i].init_data;\r\nn++;\r\n};\r\n*da9063_reg_matches = da9063_matches;\r\nreturn pdata;\r\n}\r\nstatic struct da9063_regulators_pdata *da9063_parse_regulators_dt(\r\nstruct platform_device *pdev,\r\nstruct of_regulator_match **da9063_reg_matches)\r\n{\r\n*da9063_reg_matches = NULL;\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstatic int da9063_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct da9063 *da9063 = dev_get_drvdata(pdev->dev.parent);\r\nstruct da9063_pdata *da9063_pdata = dev_get_platdata(da9063->dev);\r\nstruct of_regulator_match *da9063_reg_matches = NULL;\r\nstruct da9063_regulators_pdata *regl_pdata;\r\nconst struct da9063_dev_model *model;\r\nstruct da9063_regulators *regulators;\r\nstruct da9063_regulator *regl;\r\nstruct regulator_config config;\r\nbool bcores_merged, bmem_bio_merged;\r\nint id, irq, n, n_regulators, ret, val;\r\nsize_t size;\r\nregl_pdata = da9063_pdata ? da9063_pdata->regulators_pdata : NULL;\r\nif (!regl_pdata)\r\nregl_pdata = da9063_parse_regulators_dt(pdev,\r\n&da9063_reg_matches);\r\nif (IS_ERR(regl_pdata) || regl_pdata->n_regulators == 0) {\r\ndev_err(&pdev->dev,\r\n"No regulators defined for the platform\n");\r\nreturn PTR_ERR(regl_pdata);\r\n}\r\nfor (model = regulators_models; model->regulator_info; model++) {\r\nif (model->dev_model == da9063->model)\r\nbreak;\r\n}\r\nif (!model->regulator_info) {\r\ndev_err(&pdev->dev, "Chip model not recognised (%u)\n",\r\nda9063->model);\r\nreturn -ENODEV;\r\n}\r\nret = regmap_read(da9063->regmap, DA9063_REG_CONFIG_H, &val);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"Error while reading BUCKs configuration\n");\r\nreturn ret;\r\n}\r\nbcores_merged = val & DA9063_BCORE_MERGE;\r\nbmem_bio_merged = val & DA9063_BUCK_MERGE;\r\nn_regulators = model->n_regulators;\r\nif (bcores_merged)\r\nn_regulators -= 2;\r\nelse\r\nn_regulators--;\r\nif (bmem_bio_merged)\r\nn_regulators -= 2;\r\nelse\r\nn_regulators--;\r\nsize = sizeof(struct da9063_regulators) +\r\nn_regulators * sizeof(struct da9063_regulator);\r\nregulators = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);\r\nif (!regulators)\r\nreturn -ENOMEM;\r\nregulators->n_regulators = n_regulators;\r\nplatform_set_drvdata(pdev, regulators);\r\nn = 0;\r\nid = 0;\r\nwhile (n < regulators->n_regulators) {\r\nswitch (id) {\r\ncase DA9063_ID_BCORE1:\r\ncase DA9063_ID_BCORE2:\r\nif (bcores_merged) {\r\nid++;\r\ncontinue;\r\n}\r\nbreak;\r\ncase DA9063_ID_BMEM:\r\ncase DA9063_ID_BIO:\r\nif (bmem_bio_merged) {\r\nid++;\r\ncontinue;\r\n}\r\nbreak;\r\ncase DA9063_ID_BCORES_MERGED:\r\nif (!bcores_merged) {\r\nid++;\r\ncontinue;\r\n}\r\nbreak;\r\ncase DA9063_ID_BMEM_BIO_MERGED:\r\nif (!bmem_bio_merged) {\r\nid++;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nregl = &regulators->regulator[n];\r\nregl->hw = da9063;\r\nregl->info = &model->regulator_info[id];\r\nregl->desc = regl->info->desc;\r\nregl->desc.type = REGULATOR_VOLTAGE;\r\nregl->desc.owner = THIS_MODULE;\r\nif (regl->info->mode.reg)\r\nregl->mode = devm_regmap_field_alloc(&pdev->dev,\r\nda9063->regmap, regl->info->mode);\r\nif (regl->info->suspend.reg)\r\nregl->suspend = devm_regmap_field_alloc(&pdev->dev,\r\nda9063->regmap, regl->info->suspend);\r\nif (regl->info->sleep.reg)\r\nregl->sleep = devm_regmap_field_alloc(&pdev->dev,\r\nda9063->regmap, regl->info->sleep);\r\nif (regl->info->suspend_sleep.reg)\r\nregl->suspend_sleep = devm_regmap_field_alloc(&pdev->dev,\r\nda9063->regmap, regl->info->suspend_sleep);\r\nif (regl->info->ilimit.reg)\r\nregl->ilimit = devm_regmap_field_alloc(&pdev->dev,\r\nda9063->regmap, regl->info->ilimit);\r\nmemset(&config, 0, sizeof(config));\r\nconfig.dev = &pdev->dev;\r\nconfig.init_data = da9063_get_regulator_initdata(regl_pdata, id);\r\nconfig.driver_data = regl;\r\nif (da9063_reg_matches)\r\nconfig.of_node = da9063_reg_matches[id].of_node;\r\nconfig.regmap = da9063->regmap;\r\nregl->rdev = devm_regulator_register(&pdev->dev, &regl->desc,\r\n&config);\r\nif (IS_ERR(regl->rdev)) {\r\ndev_err(&pdev->dev,\r\n"Failed to register %s regulator\n",\r\nregl->desc.name);\r\nreturn PTR_ERR(regl->rdev);\r\n}\r\nid++;\r\nn++;\r\n}\r\nirq = platform_get_irq_byname(pdev, "LDO_LIM");\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "Failed to get IRQ.\n");\r\nreturn irq;\r\n}\r\nregulators->irq_ldo_lim = regmap_irq_get_virq(da9063->regmap_irq, irq);\r\nif (regulators->irq_ldo_lim >= 0) {\r\nret = request_threaded_irq(regulators->irq_ldo_lim,\r\nNULL, da9063_ldo_lim_event,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\n"LDO_LIM", regulators);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Failed to request LDO_LIM IRQ.\n");\r\nregulators->irq_ldo_lim = -ENXIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int da9063_regulator_remove(struct platform_device *pdev)\r\n{\r\nstruct da9063_regulators *regulators = platform_get_drvdata(pdev);\r\nfree_irq(regulators->irq_ldo_lim, regulators);\r\nfree_irq(regulators->irq_uvov, regulators);\r\nreturn 0;\r\n}\r\nstatic int __init da9063_regulator_init(void)\r\n{\r\nreturn platform_driver_register(&da9063_regulator_driver);\r\n}\r\nstatic void __exit da9063_regulator_cleanup(void)\r\n{\r\nplatform_driver_unregister(&da9063_regulator_driver);\r\n}
