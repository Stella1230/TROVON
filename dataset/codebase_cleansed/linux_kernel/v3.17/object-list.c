void fscache_objlist_add(struct fscache_object *obj)\r\n{\r\nstruct fscache_object *xobj;\r\nstruct rb_node **p = &fscache_object_list.rb_node, *parent = NULL;\r\nASSERT(RB_EMPTY_NODE(&obj->objlist_link));\r\nwrite_lock(&fscache_object_list_lock);\r\nwhile (*p) {\r\nparent = *p;\r\nxobj = rb_entry(parent, struct fscache_object, objlist_link);\r\nif (obj < xobj)\r\np = &(*p)->rb_left;\r\nelse if (obj > xobj)\r\np = &(*p)->rb_right;\r\nelse\r\nBUG();\r\n}\r\nrb_link_node(&obj->objlist_link, parent, p);\r\nrb_insert_color(&obj->objlist_link, &fscache_object_list);\r\nwrite_unlock(&fscache_object_list_lock);\r\n}\r\nvoid fscache_objlist_remove(struct fscache_object *obj)\r\n{\r\nif (RB_EMPTY_NODE(&obj->objlist_link))\r\nreturn;\r\nwrite_lock(&fscache_object_list_lock);\r\nBUG_ON(RB_EMPTY_ROOT(&fscache_object_list));\r\nrb_erase(&obj->objlist_link, &fscache_object_list);\r\nwrite_unlock(&fscache_object_list_lock);\r\n}\r\nstatic struct fscache_object *fscache_objlist_lookup(loff_t *_pos)\r\n{\r\nstruct fscache_object *pobj, *obj = NULL, *minobj = NULL;\r\nstruct rb_node *p;\r\nunsigned long pos;\r\nif (*_pos >= (unsigned long) ERR_PTR(-ENOENT))\r\nreturn NULL;\r\npos = *_pos;\r\nif (pos == 0)\r\nreturn (struct fscache_object *)(long)++(*_pos);\r\nif (pos < 3)\r\nreturn (struct fscache_object *)pos;\r\npobj = (struct fscache_object *)pos;\r\np = fscache_object_list.rb_node;\r\nwhile (p) {\r\nobj = rb_entry(p, struct fscache_object, objlist_link);\r\nif (pobj < obj) {\r\nif (!minobj || minobj > obj)\r\nminobj = obj;\r\np = p->rb_left;\r\n} else if (pobj > obj) {\r\np = p->rb_right;\r\n} else {\r\nminobj = obj;\r\nbreak;\r\n}\r\nobj = NULL;\r\n}\r\nif (!minobj)\r\n*_pos = (unsigned long) ERR_PTR(-ENOENT);\r\nelse if (minobj != obj)\r\n*_pos = (unsigned long) minobj;\r\nreturn minobj;\r\n}\r\nstatic void *fscache_objlist_start(struct seq_file *m, loff_t *_pos)\r\n__acquires(&fscache_object_list_lock\r\nstatic void *fscache_objlist_next(struct seq_file *m, void *v, loff_t *_pos)\r\n{\r\n(*_pos)++;\r\nreturn fscache_objlist_lookup(_pos);\r\n}\r\nstatic void fscache_objlist_stop(struct seq_file *m, void *v)\r\n__releases(&fscache_object_list_lock\r\nstatic int fscache_objlist_show(struct seq_file *m, void *v)\r\n{\r\nstruct fscache_objlist_data *data = m->private;\r\nstruct fscache_object *obj = v;\r\nstruct fscache_cookie *cookie;\r\nunsigned long config = data->config;\r\nchar _type[3], *type;\r\nu8 *buf = data->buf, *p;\r\nif ((unsigned long) v == 1) {\r\nseq_puts(m, "OBJECT PARENT STAT CHLDN OPS OOP IPR EX READS"\r\n" EM EV FL S"\r\n" | NETFS_COOKIE_DEF TY FL NETFS_DATA");\r\nif (config & (FSCACHE_OBJLIST_CONFIG_KEY |\r\nFSCACHE_OBJLIST_CONFIG_AUX))\r\nseq_puts(m, " ");\r\nif (config & FSCACHE_OBJLIST_CONFIG_KEY)\r\nseq_puts(m, "OBJECT_KEY");\r\nif ((config & (FSCACHE_OBJLIST_CONFIG_KEY |\r\nFSCACHE_OBJLIST_CONFIG_AUX)) ==\r\n(FSCACHE_OBJLIST_CONFIG_KEY | FSCACHE_OBJLIST_CONFIG_AUX))\r\nseq_puts(m, ", ");\r\nif (config & FSCACHE_OBJLIST_CONFIG_AUX)\r\nseq_puts(m, "AUX_DATA");\r\nseq_puts(m, "\n");\r\nreturn 0;\r\n}\r\nif ((unsigned long) v == 2) {\r\nseq_puts(m, "======== ======== ==== ===== === === === == ====="\r\n" == == == ="\r\n" | ================ == == ================");\r\nif (config & (FSCACHE_OBJLIST_CONFIG_KEY |\r\nFSCACHE_OBJLIST_CONFIG_AUX))\r\nseq_puts(m, " ================");\r\nseq_puts(m, "\n");\r\nreturn 0;\r\n}\r\n#define FILTER(criterion, _yes, _no) \\r\ndo { \\r\nunsigned long yes = FSCACHE_OBJLIST_CONFIG_##_yes; \\r\nunsigned long no = FSCACHE_OBJLIST_CONFIG_##_no; \\r\nif (criterion) { \\r\nif (!(config & yes)) \\r\nreturn 0; \\r\n} else { \\r\nif (!(config & no)) \\r\nreturn 0; \\r\n} \\r\n} while(0)\r\ncookie = obj->cookie;\r\nif (~config) {\r\nFILTER(cookie->def,\r\nCOOKIE, NOCOOKIE);\r\nFILTER(fscache_object_is_active(obj) ||\r\nobj->n_ops != 0 ||\r\nobj->n_obj_ops != 0 ||\r\nobj->flags ||\r\n!list_empty(&obj->dependents),\r\nBUSY, IDLE);\r\nFILTER(test_bit(FSCACHE_OBJECT_PENDING_WRITE, &obj->flags),\r\nPENDWR, NOPENDWR);\r\nFILTER(atomic_read(&obj->n_reads),\r\nREADS, NOREADS);\r\nFILTER(obj->events & obj->event_mask,\r\nEVENTS, NOEVENTS);\r\nFILTER(work_busy(&obj->work), WORK, NOWORK);\r\n}\r\nseq_printf(m,\r\n"%8x %8x %s %5u %3u %3u %3u %2u %5u %2lx %2lx %2lx %1x | ",\r\nobj->debug_id,\r\nobj->parent ? obj->parent->debug_id : -1,\r\nobj->state->short_name,\r\nobj->n_children,\r\nobj->n_ops,\r\nobj->n_obj_ops,\r\nobj->n_in_progress,\r\nobj->n_exclusive,\r\natomic_read(&obj->n_reads),\r\nobj->event_mask,\r\nobj->events,\r\nobj->flags,\r\nwork_busy(&obj->work));\r\nif (fscache_use_cookie(obj)) {\r\nuint16_t keylen = 0, auxlen = 0;\r\nswitch (cookie->def->type) {\r\ncase 0:\r\ntype = "IX";\r\nbreak;\r\ncase 1:\r\ntype = "DT";\r\nbreak;\r\ndefault:\r\nsprintf(_type, "%02u", cookie->def->type);\r\ntype = _type;\r\nbreak;\r\n}\r\nseq_printf(m, "%-16s %s %2lx %16p",\r\ncookie->def->name,\r\ntype,\r\ncookie->flags,\r\ncookie->netfs_data);\r\nif (cookie->def->get_key &&\r\nconfig & FSCACHE_OBJLIST_CONFIG_KEY)\r\nkeylen = cookie->def->get_key(cookie->netfs_data,\r\nbuf, 400);\r\nif (cookie->def->get_aux &&\r\nconfig & FSCACHE_OBJLIST_CONFIG_AUX)\r\nauxlen = cookie->def->get_aux(cookie->netfs_data,\r\nbuf + keylen, 512 - keylen);\r\nfscache_unuse_cookie(obj);\r\nif (keylen > 0 || auxlen > 0) {\r\nseq_puts(m, " ");\r\nfor (p = buf; keylen > 0; keylen--)\r\nseq_printf(m, "%02x", *p++);\r\nif (auxlen > 0) {\r\nif (config & FSCACHE_OBJLIST_CONFIG_KEY)\r\nseq_puts(m, ", ");\r\nfor (; auxlen > 0; auxlen--)\r\nseq_printf(m, "%02x", *p++);\r\n}\r\n}\r\nseq_puts(m, "\n");\r\n} else {\r\nseq_puts(m, "<no_netfs>\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void fscache_objlist_config(struct fscache_objlist_data *data)\r\n{\r\n#ifdef CONFIG_KEYS\r\nstruct user_key_payload *confkey;\r\nunsigned long config;\r\nstruct key *key;\r\nconst char *buf;\r\nint len;\r\nkey = request_key(&key_type_user, "fscache:objlist", NULL);\r\nif (IS_ERR(key))\r\ngoto no_config;\r\nconfig = 0;\r\nrcu_read_lock();\r\nconfkey = key->payload.data;\r\nbuf = confkey->data;\r\nfor (len = confkey->datalen - 1; len >= 0; len--) {\r\nswitch (buf[len]) {\r\ncase 'K': config |= FSCACHE_OBJLIST_CONFIG_KEY; break;\r\ncase 'A': config |= FSCACHE_OBJLIST_CONFIG_AUX; break;\r\ncase 'C': config |= FSCACHE_OBJLIST_CONFIG_COOKIE; break;\r\ncase 'c': config |= FSCACHE_OBJLIST_CONFIG_NOCOOKIE; break;\r\ncase 'B': config |= FSCACHE_OBJLIST_CONFIG_BUSY; break;\r\ncase 'b': config |= FSCACHE_OBJLIST_CONFIG_IDLE; break;\r\ncase 'W': config |= FSCACHE_OBJLIST_CONFIG_PENDWR; break;\r\ncase 'w': config |= FSCACHE_OBJLIST_CONFIG_NOPENDWR; break;\r\ncase 'R': config |= FSCACHE_OBJLIST_CONFIG_READS; break;\r\ncase 'r': config |= FSCACHE_OBJLIST_CONFIG_NOREADS; break;\r\ncase 'S': config |= FSCACHE_OBJLIST_CONFIG_WORK; break;\r\ncase 's': config |= FSCACHE_OBJLIST_CONFIG_NOWORK; break;\r\n}\r\n}\r\nrcu_read_unlock();\r\nkey_put(key);\r\nif (!(config & (FSCACHE_OBJLIST_CONFIG_COOKIE | FSCACHE_OBJLIST_CONFIG_NOCOOKIE)))\r\nconfig |= FSCACHE_OBJLIST_CONFIG_COOKIE | FSCACHE_OBJLIST_CONFIG_NOCOOKIE;\r\nif (!(config & (FSCACHE_OBJLIST_CONFIG_BUSY | FSCACHE_OBJLIST_CONFIG_IDLE)))\r\nconfig |= FSCACHE_OBJLIST_CONFIG_BUSY | FSCACHE_OBJLIST_CONFIG_IDLE;\r\nif (!(config & (FSCACHE_OBJLIST_CONFIG_PENDWR | FSCACHE_OBJLIST_CONFIG_NOPENDWR)))\r\nconfig |= FSCACHE_OBJLIST_CONFIG_PENDWR | FSCACHE_OBJLIST_CONFIG_NOPENDWR;\r\nif (!(config & (FSCACHE_OBJLIST_CONFIG_READS | FSCACHE_OBJLIST_CONFIG_NOREADS)))\r\nconfig |= FSCACHE_OBJLIST_CONFIG_READS | FSCACHE_OBJLIST_CONFIG_NOREADS;\r\nif (!(config & (FSCACHE_OBJLIST_CONFIG_EVENTS | FSCACHE_OBJLIST_CONFIG_NOEVENTS)))\r\nconfig |= FSCACHE_OBJLIST_CONFIG_EVENTS | FSCACHE_OBJLIST_CONFIG_NOEVENTS;\r\nif (!(config & (FSCACHE_OBJLIST_CONFIG_WORK | FSCACHE_OBJLIST_CONFIG_NOWORK)))\r\nconfig |= FSCACHE_OBJLIST_CONFIG_WORK | FSCACHE_OBJLIST_CONFIG_NOWORK;\r\ndata->config = config;\r\nreturn;\r\nno_config:\r\n#endif\r\ndata->config = ULONG_MAX;\r\n}\r\nstatic int fscache_objlist_open(struct inode *inode, struct file *file)\r\n{\r\nstruct fscache_objlist_data *data;\r\nstruct seq_file *m;\r\nint ret;\r\nret = seq_open(file, &fscache_objlist_ops);\r\nif (ret < 0)\r\nreturn ret;\r\nm = file->private_data;\r\ndata = kmalloc(sizeof(struct fscache_objlist_data), GFP_KERNEL);\r\nif (!data) {\r\nseq_release(inode, file);\r\nreturn -ENOMEM;\r\n}\r\nfscache_objlist_config(data);\r\nm->private = data;\r\nreturn 0;\r\n}\r\nstatic int fscache_objlist_release(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *m = file->private_data;\r\nkfree(m->private);\r\nm->private = NULL;\r\nreturn seq_release(inode, file);\r\n}
