static int efi_pstore_open(struct pstore_info *psi)\r\n{\r\npsi->data = NULL;\r\nreturn 0;\r\n}\r\nstatic int efi_pstore_close(struct pstore_info *psi)\r\n{\r\npsi->data = NULL;\r\nreturn 0;\r\n}\r\nstatic inline u64 generic_id(unsigned long timestamp,\r\nunsigned int part, int count)\r\n{\r\nreturn ((u64) timestamp * 100 + part) * 1000 + count;\r\n}\r\nstatic int efi_pstore_read_func(struct efivar_entry *entry, void *data)\r\n{\r\nefi_guid_t vendor = LINUX_EFI_CRASH_GUID;\r\nstruct pstore_read_data *cb_data = data;\r\nchar name[DUMP_NAME_LEN], data_type;\r\nint i;\r\nint cnt;\r\nunsigned int part;\r\nunsigned long time, size;\r\nif (efi_guidcmp(entry->var.VendorGuid, vendor))\r\nreturn 0;\r\nfor (i = 0; i < DUMP_NAME_LEN; i++)\r\nname[i] = entry->var.VariableName[i];\r\nif (sscanf(name, "dump-type%u-%u-%d-%lu-%c",\r\ncb_data->type, &part, &cnt, &time, &data_type) == 5) {\r\n*cb_data->id = generic_id(time, part, cnt);\r\n*cb_data->count = cnt;\r\ncb_data->timespec->tv_sec = time;\r\ncb_data->timespec->tv_nsec = 0;\r\nif (data_type == 'C')\r\n*cb_data->compressed = true;\r\nelse\r\n*cb_data->compressed = false;\r\n} else if (sscanf(name, "dump-type%u-%u-%d-%lu",\r\ncb_data->type, &part, &cnt, &time) == 4) {\r\n*cb_data->id = generic_id(time, part, cnt);\r\n*cb_data->count = cnt;\r\ncb_data->timespec->tv_sec = time;\r\ncb_data->timespec->tv_nsec = 0;\r\n*cb_data->compressed = false;\r\n} else if (sscanf(name, "dump-type%u-%u-%lu",\r\ncb_data->type, &part, &time) == 3) {\r\n*cb_data->id = generic_id(time, part, 0);\r\n*cb_data->count = 0;\r\ncb_data->timespec->tv_sec = time;\r\ncb_data->timespec->tv_nsec = 0;\r\n*cb_data->compressed = false;\r\n} else\r\nreturn 0;\r\nentry->var.DataSize = 1024;\r\n__efivar_entry_get(entry, &entry->var.Attributes,\r\n&entry->var.DataSize, entry->var.Data);\r\nsize = entry->var.DataSize;\r\nmemcpy(*cb_data->buf, entry->var.Data,\r\n(size_t)min_t(unsigned long, EFIVARS_DATA_SIZE_MAX, size));\r\nreturn size;\r\n}\r\nstatic void efi_pstore_scan_sysfs_enter(struct efivar_entry *pos,\r\nstruct efivar_entry *next,\r\nstruct list_head *head)\r\n{\r\npos->scanning = true;\r\nif (&next->list != head)\r\nnext->scanning = true;\r\n}\r\nstatic inline void __efi_pstore_scan_sysfs_exit(struct efivar_entry *entry,\r\nbool turn_off_scanning)\r\n{\r\nif (entry->deleting) {\r\nlist_del(&entry->list);\r\nefivar_entry_iter_end();\r\nefivar_unregister(entry);\r\nefivar_entry_iter_begin();\r\n} else if (turn_off_scanning)\r\nentry->scanning = false;\r\n}\r\nstatic void efi_pstore_scan_sysfs_exit(struct efivar_entry *pos,\r\nstruct efivar_entry *next,\r\nstruct list_head *head, bool stop)\r\n{\r\n__efi_pstore_scan_sysfs_exit(pos, true);\r\nif (stop)\r\n__efi_pstore_scan_sysfs_exit(next, &next->list != head);\r\n}\r\nstatic int efi_pstore_sysfs_entry_iter(void *data, struct efivar_entry **pos)\r\n{\r\nstruct efivar_entry *entry, *n;\r\nstruct list_head *head = &efivar_sysfs_list;\r\nint size = 0;\r\nif (!*pos) {\r\nlist_for_each_entry_safe(entry, n, head, list) {\r\nefi_pstore_scan_sysfs_enter(entry, n, head);\r\nsize = efi_pstore_read_func(entry, data);\r\nefi_pstore_scan_sysfs_exit(entry, n, head, size < 0);\r\nif (size)\r\nbreak;\r\n}\r\n*pos = n;\r\nreturn size;\r\n}\r\nlist_for_each_entry_safe_from((*pos), n, head, list) {\r\nefi_pstore_scan_sysfs_enter((*pos), n, head);\r\nsize = efi_pstore_read_func((*pos), data);\r\nefi_pstore_scan_sysfs_exit((*pos), n, head, size < 0);\r\nif (size)\r\nbreak;\r\n}\r\n*pos = n;\r\nreturn size;\r\n}\r\nstatic ssize_t efi_pstore_read(u64 *id, enum pstore_type_id *type,\r\nint *count, struct timespec *timespec,\r\nchar **buf, bool *compressed,\r\nstruct pstore_info *psi)\r\n{\r\nstruct pstore_read_data data;\r\nssize_t size;\r\ndata.id = id;\r\ndata.type = type;\r\ndata.count = count;\r\ndata.timespec = timespec;\r\ndata.compressed = compressed;\r\ndata.buf = buf;\r\n*data.buf = kzalloc(EFIVARS_DATA_SIZE_MAX, GFP_KERNEL);\r\nif (!*data.buf)\r\nreturn -ENOMEM;\r\nefivar_entry_iter_begin();\r\nsize = efi_pstore_sysfs_entry_iter(&data,\r\n(struct efivar_entry **)&psi->data);\r\nefivar_entry_iter_end();\r\nif (size <= 0)\r\nkfree(*data.buf);\r\nreturn size;\r\n}\r\nstatic int efi_pstore_write(enum pstore_type_id type,\r\nenum kmsg_dump_reason reason, u64 *id,\r\nunsigned int part, int count, bool compressed, size_t size,\r\nstruct pstore_info *psi)\r\n{\r\nchar name[DUMP_NAME_LEN];\r\nefi_char16_t efi_name[DUMP_NAME_LEN];\r\nefi_guid_t vendor = LINUX_EFI_CRASH_GUID;\r\nint i, ret = 0;\r\nsprintf(name, "dump-type%u-%u-%d-%lu-%c", type, part, count,\r\nget_seconds(), compressed ? 'C' : 'D');\r\nfor (i = 0; i < DUMP_NAME_LEN; i++)\r\nefi_name[i] = name[i];\r\nefivar_entry_set_safe(efi_name, vendor, PSTORE_EFI_ATTRIBUTES,\r\n!pstore_cannot_block_path(reason),\r\nsize, psi->buf);\r\nif (reason == KMSG_DUMP_OOPS)\r\nefivar_run_worker();\r\n*id = part;\r\nreturn ret;\r\n}\r\nstatic int efi_pstore_erase_func(struct efivar_entry *entry, void *data)\r\n{\r\nstruct pstore_erase_data *ed = data;\r\nefi_guid_t vendor = LINUX_EFI_CRASH_GUID;\r\nefi_char16_t efi_name_old[DUMP_NAME_LEN];\r\nefi_char16_t *efi_name = ed->name;\r\nunsigned long ucs2_len = ucs2_strlen(ed->name);\r\nchar name_old[DUMP_NAME_LEN];\r\nint i;\r\nif (efi_guidcmp(entry->var.VendorGuid, vendor))\r\nreturn 0;\r\nif (ucs2_strncmp(entry->var.VariableName,\r\nefi_name, (size_t)ucs2_len)) {\r\nsprintf(name_old, "dump-type%u-%u-%lu", ed->type,\r\n(unsigned int)ed->id, ed->time.tv_sec);\r\nfor (i = 0; i < DUMP_NAME_LEN; i++)\r\nefi_name_old[i] = name_old[i];\r\nif (ucs2_strncmp(entry->var.VariableName, efi_name_old,\r\nucs2_strlen(efi_name_old)))\r\nreturn 0;\r\n}\r\nif (entry->scanning) {\r\nentry->deleting = true;\r\n} else\r\nlist_del(&entry->list);\r\n__efivar_entry_delete(entry);\r\nreturn 1;\r\n}\r\nstatic int efi_pstore_erase(enum pstore_type_id type, u64 id, int count,\r\nstruct timespec time, struct pstore_info *psi)\r\n{\r\nstruct pstore_erase_data edata;\r\nstruct efivar_entry *entry = NULL;\r\nchar name[DUMP_NAME_LEN];\r\nefi_char16_t efi_name[DUMP_NAME_LEN];\r\nint found, i;\r\nunsigned int part;\r\ndo_div(id, 1000);\r\npart = do_div(id, 100);\r\nsprintf(name, "dump-type%u-%u-%d-%lu", type, part, count, time.tv_sec);\r\nfor (i = 0; i < DUMP_NAME_LEN; i++)\r\nefi_name[i] = name[i];\r\nedata.id = part;\r\nedata.type = type;\r\nedata.count = count;\r\nedata.time = time;\r\nedata.name = efi_name;\r\nefivar_entry_iter_begin();\r\nfound = __efivar_entry_iter(efi_pstore_erase_func, &efivar_sysfs_list, &edata, &entry);\r\nif (found && !entry->scanning) {\r\nefivar_entry_iter_end();\r\nefivar_unregister(entry);\r\n} else\r\nefivar_entry_iter_end();\r\nreturn 0;\r\n}\r\nstatic __init int efivars_pstore_init(void)\r\n{\r\nif (!efi_enabled(EFI_RUNTIME_SERVICES))\r\nreturn 0;\r\nif (!efivars_kobject())\r\nreturn 0;\r\nif (efivars_pstore_disable)\r\nreturn 0;\r\nefi_pstore_info.buf = kmalloc(4096, GFP_KERNEL);\r\nif (!efi_pstore_info.buf)\r\nreturn -ENOMEM;\r\nefi_pstore_info.bufsize = 1024;\r\nspin_lock_init(&efi_pstore_info.buf_lock);\r\nif (pstore_register(&efi_pstore_info)) {\r\nkfree(efi_pstore_info.buf);\r\nefi_pstore_info.buf = NULL;\r\nefi_pstore_info.bufsize = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic __exit void efivars_pstore_exit(void)\r\n{\r\n}
