int rtl8723au_init_recv_priv(struct rtw_adapter *padapter)\r\n{\r\nstruct recv_priv *precvpriv = &padapter->recvpriv;\r\nint i, size, res = _SUCCESS;\r\nstruct recv_buf *precvbuf;\r\nunsigned long tmpaddr;\r\nunsigned long alignment;\r\nstruct sk_buff *pskb;\r\ntasklet_init(&precvpriv->recv_tasklet,\r\n(void(*)(unsigned long))rtl8723au_recv_tasklet,\r\n(unsigned long)padapter);\r\nprecvpriv->int_in_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!precvpriv->int_in_urb)\r\nDBG_8723A("alloc_urb for interrupt in endpoint fail !!!!\n");\r\nprecvpriv->int_in_buf = kzalloc(USB_INTR_CONTENT_LENGTH, GFP_KERNEL);\r\nif (!precvpriv->int_in_buf)\r\nDBG_8723A("alloc_mem for interrupt in endpoint fail !!!!\n");\r\nsize = NR_RECVBUFF * sizeof(struct recv_buf);\r\nprecvpriv->precv_buf = kzalloc(size, GFP_KERNEL);\r\nif (!precvpriv->precv_buf) {\r\nres = _FAIL;\r\nRT_TRACE(_module_rtl871x_recv_c_, _drv_err_,\r\n("alloc recv_buf fail!\n"));\r\ngoto exit;\r\n}\r\nprecvbuf = (struct recv_buf *)precvpriv->precv_buf;\r\nfor (i = 0; i < NR_RECVBUFF; i++) {\r\nINIT_LIST_HEAD(&precvbuf->list);\r\nprecvbuf->purb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!precvbuf->purb)\r\nbreak;\r\nprecvbuf->adapter = padapter;\r\nprecvbuf++;\r\n}\r\nskb_queue_head_init(&precvpriv->rx_skb_queue);\r\nskb_queue_head_init(&precvpriv->free_recv_skb_queue);\r\nfor (i = 0; i < NR_PREALLOC_RECV_SKB; i++) {\r\nsize = MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ;\r\npskb = __netdev_alloc_skb(padapter->pnetdev, size, GFP_KERNEL);\r\nif (pskb) {\r\npskb->dev = padapter->pnetdev;\r\ntmpaddr = (unsigned long)pskb->data;\r\nalignment = tmpaddr & (RECVBUFF_ALIGN_SZ-1);\r\nskb_reserve(pskb, (RECVBUFF_ALIGN_SZ - alignment));\r\nskb_queue_tail(&precvpriv->free_recv_skb_queue, pskb);\r\n}\r\npskb = NULL;\r\n}\r\nexit:\r\nreturn res;\r\n}\r\nvoid rtl8723au_free_recv_priv(struct rtw_adapter *padapter)\r\n{\r\nint i;\r\nstruct recv_buf *precvbuf;\r\nstruct recv_priv *precvpriv = &padapter->recvpriv;\r\nprecvbuf = (struct recv_buf *)precvpriv->precv_buf;\r\nfor (i = 0; i < NR_RECVBUFF; i++) {\r\nusb_free_urb(precvbuf->purb);\r\nif (precvbuf->pskb)\r\ndev_kfree_skb_any(precvbuf->pskb);\r\nprecvbuf++;\r\n}\r\nkfree(precvpriv->precv_buf);\r\nusb_free_urb(precvpriv->int_in_urb);\r\nkfree(precvpriv->int_in_buf);\r\nif (skb_queue_len(&precvpriv->rx_skb_queue))\r\nDBG_8723A(KERN_WARNING "rx_skb_queue not empty\n");\r\nskb_queue_purge(&precvpriv->rx_skb_queue);\r\nif (skb_queue_len(&precvpriv->free_recv_skb_queue)) {\r\nDBG_8723A(KERN_WARNING "free_recv_skb_queue not empty, %d\n",\r\nskb_queue_len(&precvpriv->free_recv_skb_queue));\r\n}\r\nskb_queue_purge(&precvpriv->free_recv_skb_queue);\r\n}\r\nvoid update_recvframe_attrib(struct recv_frame *precvframe,\r\nstruct recv_stat *prxstat)\r\n{\r\nstruct rx_pkt_attrib *pattrib;\r\nstruct recv_stat_cpu report;\r\nstruct rxreport_8723a *prxreport;\r\nreport.rxdw0 = le32_to_cpu(prxstat->rxdw0);\r\nreport.rxdw1 = le32_to_cpu(prxstat->rxdw1);\r\nreport.rxdw2 = le32_to_cpu(prxstat->rxdw2);\r\nreport.rxdw3 = le32_to_cpu(prxstat->rxdw3);\r\nreport.rxdw4 = le32_to_cpu(prxstat->rxdw4);\r\nreport.rxdw5 = le32_to_cpu(prxstat->rxdw5);\r\nprxreport = (struct rxreport_8723a *)&report;\r\npattrib = &precvframe->attrib;\r\nmemset(pattrib, 0, sizeof(struct rx_pkt_attrib));\r\npattrib->pkt_len = (u16)prxreport->pktlen;\r\npattrib->drvinfo_sz = (u8)(prxreport->drvinfosize << 3);\r\npattrib->physt = (u8)prxreport->physt;\r\npattrib->crc_err = (u8)prxreport->crc32;\r\npattrib->icv_err = (u8)prxreport->icverr;\r\npattrib->bdecrypted = (u8)(prxreport->swdec ? 0 : 1);\r\npattrib->encrypt = (u8)prxreport->security;\r\npattrib->qos = (u8)prxreport->qos;\r\npattrib->priority = (u8)prxreport->tid;\r\npattrib->amsdu = (u8)prxreport->amsdu;\r\npattrib->seq_num = (u16)prxreport->seq;\r\npattrib->frag_num = (u8)prxreport->frag;\r\npattrib->mfrag = (u8)prxreport->mf;\r\npattrib->mdata = (u8)prxreport->md;\r\npattrib->mcs_rate = (u8)prxreport->rxmcs;\r\npattrib->rxht = (u8)prxreport->rxht;\r\n}\r\nvoid update_recvframe_phyinfo(struct recv_frame *precvframe,\r\nstruct phy_stat *pphy_status)\r\n{\r\nstruct rtw_adapter *padapter = precvframe->adapter;\r\nstruct rx_pkt_attrib *pattrib = &precvframe->attrib;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct phy_info *pPHYInfo = &pattrib->phy_info;\r\nstruct odm_packet_info pkt_info;\r\nu8 *sa = NULL, *da;\r\nstruct sta_priv *pstapriv;\r\nstruct sta_info *psta;\r\nstruct sk_buff *skb = precvframe->pkt;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\r\nbool matchbssid = false;\r\nu8 *bssid;\r\nmatchbssid = (!ieee80211_is_ctl(hdr->frame_control) &&\r\n!pattrib->icv_err && !pattrib->crc_err);\r\nif (matchbssid) {\r\nswitch (hdr->frame_control &\r\ncpu_to_le16(IEEE80211_FCTL_TODS |\r\nIEEE80211_FCTL_FROMDS)) {\r\ncase cpu_to_le16(IEEE80211_FCTL_TODS):\r\nbssid = hdr->addr1;\r\nbreak;\r\ncase cpu_to_le16(IEEE80211_FCTL_FROMDS):\r\nbssid = hdr->addr2;\r\nbreak;\r\ncase cpu_to_le16(0):\r\nbssid = hdr->addr3;\r\nbreak;\r\ndefault:\r\nbssid = NULL;\r\nmatchbssid = false;\r\n}\r\nif (bssid)\r\nmatchbssid = ether_addr_equal(\r\nget_bssid(&padapter->mlmepriv), bssid);\r\n}\r\npkt_info.bPacketMatchBSSID = matchbssid;\r\nda = ieee80211_get_DA(hdr);\r\npkt_info.bPacketToSelf = pkt_info.bPacketMatchBSSID &&\r\n(!memcmp(da, myid(&padapter->eeprompriv), ETH_ALEN));\r\npkt_info.bPacketBeacon = pkt_info.bPacketMatchBSSID &&\r\nieee80211_is_beacon(hdr->frame_control);\r\npkt_info.StationID = 0xFF;\r\nif (pkt_info.bPacketBeacon) {\r\nif (check_fwstate(&padapter->mlmepriv, WIFI_STATION_STATE) == true)\r\nsa = padapter->mlmepriv.cur_network.network.MacAddress;\r\n} else {\r\nsa = ieee80211_get_SA(hdr);\r\n}\r\npstapriv = &padapter->stapriv;\r\npsta = rtw_get_stainfo23a(pstapriv, sa);\r\nif (psta) {\r\npkt_info.StationID = psta->mac_id;\r\n}\r\npkt_info.Rate = pattrib->mcs_rate;\r\nODM_PhyStatusQuery23a(&pHalData->odmpriv, pPHYInfo,\r\n(u8 *)pphy_status, &pkt_info);\r\nprecvframe->psta = NULL;\r\nif (pkt_info.bPacketMatchBSSID &&\r\n(check_fwstate(&padapter->mlmepriv, WIFI_AP_STATE) == true)) {\r\nif (psta) {\r\nprecvframe->psta = psta;\r\nrtl8723a_process_phy_info(padapter, precvframe);\r\n}\r\n} else if (pkt_info.bPacketToSelf || pkt_info.bPacketBeacon) {\r\nif (check_fwstate(&padapter->mlmepriv,\r\nWIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) ==\r\ntrue) {\r\nif (psta)\r\nprecvframe->psta = psta;\r\n}\r\nrtl8723a_process_phy_info(padapter, precvframe);\r\n}\r\n}
