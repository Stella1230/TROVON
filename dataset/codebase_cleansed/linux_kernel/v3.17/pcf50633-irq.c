int pcf50633_register_irq(struct pcf50633 *pcf, int irq,\r\nvoid (*handler) (int, void *), void *data)\r\n{\r\nif (irq < 0 || irq >= PCF50633_NUM_IRQ || !handler)\r\nreturn -EINVAL;\r\nif (WARN_ON(pcf->irq_handler[irq].handler))\r\nreturn -EBUSY;\r\nmutex_lock(&pcf->lock);\r\npcf->irq_handler[irq].handler = handler;\r\npcf->irq_handler[irq].data = data;\r\nmutex_unlock(&pcf->lock);\r\nreturn 0;\r\n}\r\nint pcf50633_free_irq(struct pcf50633 *pcf, int irq)\r\n{\r\nif (irq < 0 || irq >= PCF50633_NUM_IRQ)\r\nreturn -EINVAL;\r\nmutex_lock(&pcf->lock);\r\npcf->irq_handler[irq].handler = NULL;\r\nmutex_unlock(&pcf->lock);\r\nreturn 0;\r\n}\r\nstatic int __pcf50633_irq_mask_set(struct pcf50633 *pcf, int irq, u8 mask)\r\n{\r\nu8 reg, bit;\r\nint ret = 0, idx;\r\nidx = irq >> 3;\r\nreg = PCF50633_REG_INT1M + idx;\r\nbit = 1 << (irq & 0x07);\r\npcf50633_reg_set_bit_mask(pcf, reg, bit, mask ? bit : 0);\r\nmutex_lock(&pcf->lock);\r\nif (mask)\r\npcf->mask_regs[idx] |= bit;\r\nelse\r\npcf->mask_regs[idx] &= ~bit;\r\nmutex_unlock(&pcf->lock);\r\nreturn ret;\r\n}\r\nint pcf50633_irq_mask(struct pcf50633 *pcf, int irq)\r\n{\r\ndev_dbg(pcf->dev, "Masking IRQ %d\n", irq);\r\nreturn __pcf50633_irq_mask_set(pcf, irq, 1);\r\n}\r\nint pcf50633_irq_unmask(struct pcf50633 *pcf, int irq)\r\n{\r\ndev_dbg(pcf->dev, "Unmasking IRQ %d\n", irq);\r\nreturn __pcf50633_irq_mask_set(pcf, irq, 0);\r\n}\r\nint pcf50633_irq_mask_get(struct pcf50633 *pcf, int irq)\r\n{\r\nu8 reg, bits;\r\nreg = irq >> 3;\r\nbits = 1 << (irq & 0x07);\r\nreturn pcf->mask_regs[reg] & bits;\r\n}\r\nstatic void pcf50633_irq_call_handler(struct pcf50633 *pcf, int irq)\r\n{\r\nif (pcf->irq_handler[irq].handler)\r\npcf->irq_handler[irq].handler(irq, pcf->irq_handler[irq].data);\r\n}\r\nstatic irqreturn_t pcf50633_irq(int irq, void *data)\r\n{\r\nstruct pcf50633 *pcf = data;\r\nint ret, i, j;\r\nu8 pcf_int[5], chgstat;\r\nret = pcf50633_read_block(pcf, PCF50633_REG_INT1,\r\nARRAY_SIZE(pcf_int), pcf_int);\r\nif (ret != ARRAY_SIZE(pcf_int)) {\r\ndev_err(pcf->dev, "Error reading INT registers\n");\r\ngoto out;\r\n}\r\npcf50633_reg_write(pcf, PCF50633_REG_OOCSHDWN, 0x04);\r\nif (pcf_int[0] & (PCF50633_INT1_USBINS | PCF50633_INT1_USBREM)) {\r\nchgstat = pcf50633_reg_read(pcf, PCF50633_REG_MBCS2);\r\nif (chgstat & (0x3 << 4))\r\npcf_int[0] &= ~PCF50633_INT1_USBREM;\r\nelse\r\npcf_int[0] &= ~PCF50633_INT1_USBINS;\r\n}\r\nif (pcf_int[0] & (PCF50633_INT1_ADPINS | PCF50633_INT1_ADPREM)) {\r\nchgstat = pcf50633_reg_read(pcf, PCF50633_REG_MBCS2);\r\nif (chgstat & (0x3 << 4))\r\npcf_int[0] &= ~PCF50633_INT1_ADPREM;\r\nelse\r\npcf_int[0] &= ~PCF50633_INT1_ADPINS;\r\n}\r\ndev_dbg(pcf->dev, "INT1=0x%02x INT2=0x%02x INT3=0x%02x "\r\n"INT4=0x%02x INT5=0x%02x\n", pcf_int[0],\r\npcf_int[1], pcf_int[2], pcf_int[3], pcf_int[4]);\r\nif ((pcf_int[0] & PCF50633_INT1_SECOND) && pcf->onkey1s_held) {\r\ndev_info(pcf->dev, "ONKEY1S held for %d secs\n",\r\npcf->onkey1s_held);\r\nif (pcf->onkey1s_held++ == PCF50633_ONKEY1S_TIMEOUT)\r\nif (pcf->pdata->force_shutdown)\r\npcf->pdata->force_shutdown(pcf);\r\n}\r\nif (pcf_int[2] & PCF50633_INT3_ONKEY1S) {\r\ndev_info(pcf->dev, "ONKEY1S held\n");\r\npcf->onkey1s_held = 1 ;\r\npcf50633_reg_clear_bits(pcf, PCF50633_REG_INT1M,\r\nPCF50633_INT1_SECOND);\r\npcf50633_reg_clear_bits(pcf, PCF50633_REG_INT2M,\r\nPCF50633_INT2_ONKEYR);\r\n}\r\nif ((pcf_int[1] & PCF50633_INT2_ONKEYR) && pcf->onkey1s_held) {\r\npcf->onkey1s_held = 0;\r\nif (pcf->mask_regs[0] & PCF50633_INT1_SECOND)\r\npcf50633_reg_set_bit_mask(pcf,\r\nPCF50633_REG_INT1M,\r\nPCF50633_INT1_SECOND,\r\nPCF50633_INT1_SECOND);\r\nif (pcf->mask_regs[1] & PCF50633_INT2_ONKEYR)\r\npcf50633_reg_set_bit_mask(pcf,\r\nPCF50633_REG_INT2M,\r\nPCF50633_INT2_ONKEYR,\r\nPCF50633_INT2_ONKEYR);\r\n}\r\nif (pcf->is_suspended) {\r\npcf->is_suspended = 0;\r\nfor (i = 0; i < ARRAY_SIZE(pcf_int); i++)\r\npcf->resume_reason[i] = pcf_int[i] &\r\npcf->pdata->resumers[i];\r\npcf_int[1] &= ~(PCF50633_INT2_ONKEYR | PCF50633_INT2_ONKEYF);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(pcf_int); i++) {\r\npcf_int[i] &= ~pcf->mask_regs[i];\r\nfor (j = 0; j < 8 ; j++)\r\nif (pcf_int[i] & (1 << j))\r\npcf50633_irq_call_handler(pcf, (i * 8) + j);\r\n}\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nint pcf50633_irq_suspend(struct pcf50633 *pcf)\r\n{\r\nint ret;\r\nint i;\r\nu8 res[5];\r\ndisable_irq(pcf->irq);\r\nret = pcf50633_read_block(pcf, PCF50633_REG_INT1M,\r\nARRAY_SIZE(pcf->suspend_irq_masks),\r\npcf->suspend_irq_masks);\r\nif (ret < 0) {\r\ndev_err(pcf->dev, "error saving irq masks\n");\r\ngoto out;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(res); i++)\r\nres[i] = ~pcf->pdata->resumers[i];\r\nret = pcf50633_write_block(pcf, PCF50633_REG_INT1M,\r\nARRAY_SIZE(res), &res[0]);\r\nif (ret < 0) {\r\ndev_err(pcf->dev, "error writing wakeup irq masks\n");\r\ngoto out;\r\n}\r\npcf->is_suspended = 1;\r\nout:\r\nreturn ret;\r\n}\r\nint pcf50633_irq_resume(struct pcf50633 *pcf)\r\n{\r\nint ret;\r\nret = pcf50633_write_block(pcf, PCF50633_REG_INT1M,\r\nARRAY_SIZE(pcf->suspend_irq_masks),\r\npcf->suspend_irq_masks);\r\nif (ret < 0)\r\ndev_err(pcf->dev, "Error restoring saved suspend masks\n");\r\nenable_irq(pcf->irq);\r\nreturn ret;\r\n}\r\nint pcf50633_irq_init(struct pcf50633 *pcf, int irq)\r\n{\r\nint ret;\r\npcf->irq = irq;\r\npcf->mask_regs[0] = 0x80;\r\npcf50633_reg_write(pcf, PCF50633_REG_INT1M, pcf->mask_regs[0]);\r\npcf50633_reg_write(pcf, PCF50633_REG_INT2M, 0x00);\r\npcf50633_reg_write(pcf, PCF50633_REG_INT3M, 0x00);\r\npcf50633_reg_write(pcf, PCF50633_REG_INT4M, 0x00);\r\npcf50633_reg_write(pcf, PCF50633_REG_INT5M, 0x00);\r\nret = request_threaded_irq(irq, NULL, pcf50633_irq,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\n"pcf50633", pcf);\r\nif (ret)\r\ndev_err(pcf->dev, "Failed to request IRQ %d\n", ret);\r\nif (enable_irq_wake(irq) < 0)\r\ndev_err(pcf->dev, "IRQ %u cannot be enabled as wake-up source"\r\n"in this hardware revision", irq);\r\nreturn ret;\r\n}\r\nvoid pcf50633_irq_free(struct pcf50633 *pcf)\r\n{\r\nfree_irq(pcf->irq, pcf);\r\n}
