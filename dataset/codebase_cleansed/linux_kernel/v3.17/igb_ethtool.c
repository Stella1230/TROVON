static int igb_get_settings(struct net_device *netdev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct e1000_dev_spec_82575 *dev_spec = &hw->dev_spec._82575;\r\nstruct e1000_sfp_flags *eth_flags = &dev_spec->eth_flags;\r\nu32 status;\r\nu32 speed;\r\nstatus = rd32(E1000_STATUS);\r\nif (hw->phy.media_type == e1000_media_type_copper) {\r\necmd->supported = (SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_1000baseT_Full|\r\nSUPPORTED_Autoneg |\r\nSUPPORTED_TP |\r\nSUPPORTED_Pause);\r\necmd->advertising = ADVERTISED_TP;\r\nif (hw->mac.autoneg == 1) {\r\necmd->advertising |= ADVERTISED_Autoneg;\r\necmd->advertising |= hw->phy.autoneg_advertised;\r\n}\r\necmd->port = PORT_TP;\r\necmd->phy_address = hw->phy.addr;\r\necmd->transceiver = XCVR_INTERNAL;\r\n} else {\r\necmd->supported = (SUPPORTED_FIBRE |\r\nSUPPORTED_1000baseKX_Full |\r\nSUPPORTED_Autoneg |\r\nSUPPORTED_Pause);\r\necmd->advertising = (ADVERTISED_FIBRE |\r\nADVERTISED_1000baseKX_Full);\r\nif (hw->mac.type == e1000_i354) {\r\nif ((hw->device_id ==\r\nE1000_DEV_ID_I354_BACKPLANE_2_5GBPS) &&\r\n!(status & E1000_STATUS_2P5_SKU_OVER)) {\r\necmd->supported |= SUPPORTED_2500baseX_Full;\r\necmd->supported &=\r\n~SUPPORTED_1000baseKX_Full;\r\necmd->advertising |= ADVERTISED_2500baseX_Full;\r\necmd->advertising &=\r\n~ADVERTISED_1000baseKX_Full;\r\n}\r\n}\r\nif (eth_flags->e100_base_fx) {\r\necmd->supported |= SUPPORTED_100baseT_Full;\r\necmd->advertising |= ADVERTISED_100baseT_Full;\r\n}\r\nif (hw->mac.autoneg == 1)\r\necmd->advertising |= ADVERTISED_Autoneg;\r\necmd->port = PORT_FIBRE;\r\necmd->transceiver = XCVR_EXTERNAL;\r\n}\r\nif (hw->mac.autoneg != 1)\r\necmd->advertising &= ~(ADVERTISED_Pause |\r\nADVERTISED_Asym_Pause);\r\nswitch (hw->fc.requested_mode) {\r\ncase e1000_fc_full:\r\necmd->advertising |= ADVERTISED_Pause;\r\nbreak;\r\ncase e1000_fc_rx_pause:\r\necmd->advertising |= (ADVERTISED_Pause |\r\nADVERTISED_Asym_Pause);\r\nbreak;\r\ncase e1000_fc_tx_pause:\r\necmd->advertising |= ADVERTISED_Asym_Pause;\r\nbreak;\r\ndefault:\r\necmd->advertising &= ~(ADVERTISED_Pause |\r\nADVERTISED_Asym_Pause);\r\n}\r\nif (status & E1000_STATUS_LU) {\r\nif ((status & E1000_STATUS_2P5_SKU) &&\r\n!(status & E1000_STATUS_2P5_SKU_OVER)) {\r\nspeed = SPEED_2500;\r\n} else if (status & E1000_STATUS_SPEED_1000) {\r\nspeed = SPEED_1000;\r\n} else if (status & E1000_STATUS_SPEED_100) {\r\nspeed = SPEED_100;\r\n} else {\r\nspeed = SPEED_10;\r\n}\r\nif ((status & E1000_STATUS_FD) ||\r\nhw->phy.media_type != e1000_media_type_copper)\r\necmd->duplex = DUPLEX_FULL;\r\nelse\r\necmd->duplex = DUPLEX_HALF;\r\n} else {\r\nspeed = SPEED_UNKNOWN;\r\necmd->duplex = DUPLEX_UNKNOWN;\r\n}\r\nethtool_cmd_speed_set(ecmd, speed);\r\nif ((hw->phy.media_type == e1000_media_type_fiber) ||\r\nhw->mac.autoneg)\r\necmd->autoneg = AUTONEG_ENABLE;\r\nelse\r\necmd->autoneg = AUTONEG_DISABLE;\r\nif (hw->phy.media_type == e1000_media_type_copper)\r\necmd->eth_tp_mdix = hw->phy.is_mdix ? ETH_TP_MDI_X :\r\nETH_TP_MDI;\r\nelse\r\necmd->eth_tp_mdix = ETH_TP_MDI_INVALID;\r\nif (hw->phy.mdix == AUTO_ALL_MODES)\r\necmd->eth_tp_mdix_ctrl = ETH_TP_MDI_AUTO;\r\nelse\r\necmd->eth_tp_mdix_ctrl = hw->phy.mdix;\r\nreturn 0;\r\n}\r\nstatic int igb_set_settings(struct net_device *netdev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nif (igb_check_reset_block(hw)) {\r\ndev_err(&adapter->pdev->dev,\r\n"Cannot change link characteristics when SoL/IDER is active.\n");\r\nreturn -EINVAL;\r\n}\r\nif (ecmd->eth_tp_mdix_ctrl) {\r\nif (hw->phy.media_type != e1000_media_type_copper)\r\nreturn -EOPNOTSUPP;\r\nif ((ecmd->eth_tp_mdix_ctrl != ETH_TP_MDI_AUTO) &&\r\n(ecmd->autoneg != AUTONEG_ENABLE)) {\r\ndev_err(&adapter->pdev->dev, "forcing MDI/MDI-X state is not supported when link speed and/or duplex are forced\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nwhile (test_and_set_bit(__IGB_RESETTING, &adapter->state))\r\nusleep_range(1000, 2000);\r\nif (ecmd->autoneg == AUTONEG_ENABLE) {\r\nhw->mac.autoneg = 1;\r\nif (hw->phy.media_type == e1000_media_type_fiber) {\r\nhw->phy.autoneg_advertised = ecmd->advertising |\r\nADVERTISED_FIBRE |\r\nADVERTISED_Autoneg;\r\nswitch (adapter->link_speed) {\r\ncase SPEED_2500:\r\nhw->phy.autoneg_advertised =\r\nADVERTISED_2500baseX_Full;\r\nbreak;\r\ncase SPEED_1000:\r\nhw->phy.autoneg_advertised =\r\nADVERTISED_1000baseT_Full;\r\nbreak;\r\ncase SPEED_100:\r\nhw->phy.autoneg_advertised =\r\nADVERTISED_100baseT_Full;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nhw->phy.autoneg_advertised = ecmd->advertising |\r\nADVERTISED_TP |\r\nADVERTISED_Autoneg;\r\n}\r\necmd->advertising = hw->phy.autoneg_advertised;\r\nif (adapter->fc_autoneg)\r\nhw->fc.requested_mode = e1000_fc_default;\r\n} else {\r\nu32 speed = ethtool_cmd_speed(ecmd);\r\nif (igb_set_spd_dplx(adapter, speed, ecmd->duplex)) {\r\nclear_bit(__IGB_RESETTING, &adapter->state);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (ecmd->eth_tp_mdix_ctrl) {\r\nif (ecmd->eth_tp_mdix_ctrl == ETH_TP_MDI_AUTO)\r\nhw->phy.mdix = AUTO_ALL_MODES;\r\nelse\r\nhw->phy.mdix = ecmd->eth_tp_mdix_ctrl;\r\n}\r\nif (netif_running(adapter->netdev)) {\r\nigb_down(adapter);\r\nigb_up(adapter);\r\n} else\r\nigb_reset(adapter);\r\nclear_bit(__IGB_RESETTING, &adapter->state);\r\nreturn 0;\r\n}\r\nstatic u32 igb_get_link(struct net_device *netdev)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_mac_info *mac = &adapter->hw.mac;\r\nif (!netif_carrier_ok(netdev))\r\nmac->get_link_status = 1;\r\nreturn igb_has_link(adapter);\r\n}\r\nstatic void igb_get_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\npause->autoneg =\r\n(adapter->fc_autoneg ? AUTONEG_ENABLE : AUTONEG_DISABLE);\r\nif (hw->fc.current_mode == e1000_fc_rx_pause)\r\npause->rx_pause = 1;\r\nelse if (hw->fc.current_mode == e1000_fc_tx_pause)\r\npause->tx_pause = 1;\r\nelse if (hw->fc.current_mode == e1000_fc_full) {\r\npause->rx_pause = 1;\r\npause->tx_pause = 1;\r\n}\r\n}\r\nstatic int igb_set_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nint retval = 0;\r\nif (hw->dev_spec._82575.eth_flags.e100_base_fx)\r\nreturn -EINVAL;\r\nadapter->fc_autoneg = pause->autoneg;\r\nwhile (test_and_set_bit(__IGB_RESETTING, &adapter->state))\r\nusleep_range(1000, 2000);\r\nif (adapter->fc_autoneg == AUTONEG_ENABLE) {\r\nhw->fc.requested_mode = e1000_fc_default;\r\nif (netif_running(adapter->netdev)) {\r\nigb_down(adapter);\r\nigb_up(adapter);\r\n} else {\r\nigb_reset(adapter);\r\n}\r\n} else {\r\nif (pause->rx_pause && pause->tx_pause)\r\nhw->fc.requested_mode = e1000_fc_full;\r\nelse if (pause->rx_pause && !pause->tx_pause)\r\nhw->fc.requested_mode = e1000_fc_rx_pause;\r\nelse if (!pause->rx_pause && pause->tx_pause)\r\nhw->fc.requested_mode = e1000_fc_tx_pause;\r\nelse if (!pause->rx_pause && !pause->tx_pause)\r\nhw->fc.requested_mode = e1000_fc_none;\r\nhw->fc.current_mode = hw->fc.requested_mode;\r\nretval = ((hw->phy.media_type == e1000_media_type_copper) ?\r\nigb_force_mac_fc(hw) : igb_setup_link(hw));\r\n}\r\nclear_bit(__IGB_RESETTING, &adapter->state);\r\nreturn retval;\r\n}\r\nstatic u32 igb_get_msglevel(struct net_device *netdev)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nreturn adapter->msg_enable;\r\n}\r\nstatic void igb_set_msglevel(struct net_device *netdev, u32 data)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nadapter->msg_enable = data;\r\n}\r\nstatic int igb_get_regs_len(struct net_device *netdev)\r\n{\r\n#define IGB_REGS_LEN 739\r\nreturn IGB_REGS_LEN * sizeof(u32);\r\n}\r\nstatic void igb_get_regs(struct net_device *netdev,\r\nstruct ethtool_regs *regs, void *p)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 *regs_buff = p;\r\nu8 i;\r\nmemset(p, 0, IGB_REGS_LEN * sizeof(u32));\r\nregs->version = (1 << 24) | (hw->revision_id << 16) | hw->device_id;\r\nregs_buff[0] = rd32(E1000_CTRL);\r\nregs_buff[1] = rd32(E1000_STATUS);\r\nregs_buff[2] = rd32(E1000_CTRL_EXT);\r\nregs_buff[3] = rd32(E1000_MDIC);\r\nregs_buff[4] = rd32(E1000_SCTL);\r\nregs_buff[5] = rd32(E1000_CONNSW);\r\nregs_buff[6] = rd32(E1000_VET);\r\nregs_buff[7] = rd32(E1000_LEDCTL);\r\nregs_buff[8] = rd32(E1000_PBA);\r\nregs_buff[9] = rd32(E1000_PBS);\r\nregs_buff[10] = rd32(E1000_FRTIMER);\r\nregs_buff[11] = rd32(E1000_TCPTIMER);\r\nregs_buff[12] = rd32(E1000_EECD);\r\nregs_buff[13] = rd32(E1000_EICS);\r\nregs_buff[14] = rd32(E1000_EICS);\r\nregs_buff[15] = rd32(E1000_EIMS);\r\nregs_buff[16] = rd32(E1000_EIMC);\r\nregs_buff[17] = rd32(E1000_EIAC);\r\nregs_buff[18] = rd32(E1000_EIAM);\r\nregs_buff[19] = rd32(E1000_ICS);\r\nregs_buff[20] = rd32(E1000_ICS);\r\nregs_buff[21] = rd32(E1000_IMS);\r\nregs_buff[22] = rd32(E1000_IMC);\r\nregs_buff[23] = rd32(E1000_IAC);\r\nregs_buff[24] = rd32(E1000_IAM);\r\nregs_buff[25] = rd32(E1000_IMIRVP);\r\nregs_buff[26] = rd32(E1000_FCAL);\r\nregs_buff[27] = rd32(E1000_FCAH);\r\nregs_buff[28] = rd32(E1000_FCTTV);\r\nregs_buff[29] = rd32(E1000_FCRTL);\r\nregs_buff[30] = rd32(E1000_FCRTH);\r\nregs_buff[31] = rd32(E1000_FCRTV);\r\nregs_buff[32] = rd32(E1000_RCTL);\r\nregs_buff[33] = rd32(E1000_RXCSUM);\r\nregs_buff[34] = rd32(E1000_RLPML);\r\nregs_buff[35] = rd32(E1000_RFCTL);\r\nregs_buff[36] = rd32(E1000_MRQC);\r\nregs_buff[37] = rd32(E1000_VT_CTL);\r\nregs_buff[38] = rd32(E1000_TCTL);\r\nregs_buff[39] = rd32(E1000_TCTL_EXT);\r\nregs_buff[40] = rd32(E1000_TIPG);\r\nregs_buff[41] = rd32(E1000_DTXCTL);\r\nregs_buff[42] = rd32(E1000_WUC);\r\nregs_buff[43] = rd32(E1000_WUFC);\r\nregs_buff[44] = rd32(E1000_WUS);\r\nregs_buff[45] = rd32(E1000_IPAV);\r\nregs_buff[46] = rd32(E1000_WUPL);\r\nregs_buff[47] = rd32(E1000_PCS_CFG0);\r\nregs_buff[48] = rd32(E1000_PCS_LCTL);\r\nregs_buff[49] = rd32(E1000_PCS_LSTAT);\r\nregs_buff[50] = rd32(E1000_PCS_ANADV);\r\nregs_buff[51] = rd32(E1000_PCS_LPAB);\r\nregs_buff[52] = rd32(E1000_PCS_NPTX);\r\nregs_buff[53] = rd32(E1000_PCS_LPABNP);\r\nregs_buff[54] = adapter->stats.crcerrs;\r\nregs_buff[55] = adapter->stats.algnerrc;\r\nregs_buff[56] = adapter->stats.symerrs;\r\nregs_buff[57] = adapter->stats.rxerrc;\r\nregs_buff[58] = adapter->stats.mpc;\r\nregs_buff[59] = adapter->stats.scc;\r\nregs_buff[60] = adapter->stats.ecol;\r\nregs_buff[61] = adapter->stats.mcc;\r\nregs_buff[62] = adapter->stats.latecol;\r\nregs_buff[63] = adapter->stats.colc;\r\nregs_buff[64] = adapter->stats.dc;\r\nregs_buff[65] = adapter->stats.tncrs;\r\nregs_buff[66] = adapter->stats.sec;\r\nregs_buff[67] = adapter->stats.htdpmc;\r\nregs_buff[68] = adapter->stats.rlec;\r\nregs_buff[69] = adapter->stats.xonrxc;\r\nregs_buff[70] = adapter->stats.xontxc;\r\nregs_buff[71] = adapter->stats.xoffrxc;\r\nregs_buff[72] = adapter->stats.xofftxc;\r\nregs_buff[73] = adapter->stats.fcruc;\r\nregs_buff[74] = adapter->stats.prc64;\r\nregs_buff[75] = adapter->stats.prc127;\r\nregs_buff[76] = adapter->stats.prc255;\r\nregs_buff[77] = adapter->stats.prc511;\r\nregs_buff[78] = adapter->stats.prc1023;\r\nregs_buff[79] = adapter->stats.prc1522;\r\nregs_buff[80] = adapter->stats.gprc;\r\nregs_buff[81] = adapter->stats.bprc;\r\nregs_buff[82] = adapter->stats.mprc;\r\nregs_buff[83] = adapter->stats.gptc;\r\nregs_buff[84] = adapter->stats.gorc;\r\nregs_buff[86] = adapter->stats.gotc;\r\nregs_buff[88] = adapter->stats.rnbc;\r\nregs_buff[89] = adapter->stats.ruc;\r\nregs_buff[90] = adapter->stats.rfc;\r\nregs_buff[91] = adapter->stats.roc;\r\nregs_buff[92] = adapter->stats.rjc;\r\nregs_buff[93] = adapter->stats.mgprc;\r\nregs_buff[94] = adapter->stats.mgpdc;\r\nregs_buff[95] = adapter->stats.mgptc;\r\nregs_buff[96] = adapter->stats.tor;\r\nregs_buff[98] = adapter->stats.tot;\r\nregs_buff[100] = adapter->stats.tpr;\r\nregs_buff[101] = adapter->stats.tpt;\r\nregs_buff[102] = adapter->stats.ptc64;\r\nregs_buff[103] = adapter->stats.ptc127;\r\nregs_buff[104] = adapter->stats.ptc255;\r\nregs_buff[105] = adapter->stats.ptc511;\r\nregs_buff[106] = adapter->stats.ptc1023;\r\nregs_buff[107] = adapter->stats.ptc1522;\r\nregs_buff[108] = adapter->stats.mptc;\r\nregs_buff[109] = adapter->stats.bptc;\r\nregs_buff[110] = adapter->stats.tsctc;\r\nregs_buff[111] = adapter->stats.iac;\r\nregs_buff[112] = adapter->stats.rpthc;\r\nregs_buff[113] = adapter->stats.hgptc;\r\nregs_buff[114] = adapter->stats.hgorc;\r\nregs_buff[116] = adapter->stats.hgotc;\r\nregs_buff[118] = adapter->stats.lenerrs;\r\nregs_buff[119] = adapter->stats.scvpc;\r\nregs_buff[120] = adapter->stats.hrmpc;\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[121 + i] = rd32(E1000_SRRCTL(i));\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[125 + i] = rd32(E1000_PSRTYPE(i));\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[129 + i] = rd32(E1000_RDBAL(i));\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[133 + i] = rd32(E1000_RDBAH(i));\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[137 + i] = rd32(E1000_RDLEN(i));\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[141 + i] = rd32(E1000_RDH(i));\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[145 + i] = rd32(E1000_RDT(i));\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[149 + i] = rd32(E1000_RXDCTL(i));\r\nfor (i = 0; i < 10; i++)\r\nregs_buff[153 + i] = rd32(E1000_EITR(i));\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[163 + i] = rd32(E1000_IMIR(i));\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[171 + i] = rd32(E1000_IMIREXT(i));\r\nfor (i = 0; i < 16; i++)\r\nregs_buff[179 + i] = rd32(E1000_RAL(i));\r\nfor (i = 0; i < 16; i++)\r\nregs_buff[195 + i] = rd32(E1000_RAH(i));\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[211 + i] = rd32(E1000_TDBAL(i));\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[215 + i] = rd32(E1000_TDBAH(i));\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[219 + i] = rd32(E1000_TDLEN(i));\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[223 + i] = rd32(E1000_TDH(i));\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[227 + i] = rd32(E1000_TDT(i));\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[231 + i] = rd32(E1000_TXDCTL(i));\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[235 + i] = rd32(E1000_TDWBAL(i));\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[239 + i] = rd32(E1000_TDWBAH(i));\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[243 + i] = rd32(E1000_DCA_TXCTRL(i));\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[247 + i] = rd32(E1000_IP4AT_REG(i));\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[251 + i] = rd32(E1000_IP6AT_REG(i));\r\nfor (i = 0; i < 32; i++)\r\nregs_buff[255 + i] = rd32(E1000_WUPM_REG(i));\r\nfor (i = 0; i < 128; i++)\r\nregs_buff[287 + i] = rd32(E1000_FFMT_REG(i));\r\nfor (i = 0; i < 128; i++)\r\nregs_buff[415 + i] = rd32(E1000_FFVT_REG(i));\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[543 + i] = rd32(E1000_FFLT_REG(i));\r\nregs_buff[547] = rd32(E1000_TDFH);\r\nregs_buff[548] = rd32(E1000_TDFT);\r\nregs_buff[549] = rd32(E1000_TDFHS);\r\nregs_buff[550] = rd32(E1000_TDFPC);\r\nif (hw->mac.type > e1000_82580) {\r\nregs_buff[551] = adapter->stats.o2bgptc;\r\nregs_buff[552] = adapter->stats.b2ospc;\r\nregs_buff[553] = adapter->stats.o2bspc;\r\nregs_buff[554] = adapter->stats.b2ogprc;\r\n}\r\nif (hw->mac.type != e1000_82576)\r\nreturn;\r\nfor (i = 0; i < 12; i++)\r\nregs_buff[555 + i] = rd32(E1000_SRRCTL(i + 4));\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[567 + i] = rd32(E1000_PSRTYPE(i + 4));\r\nfor (i = 0; i < 12; i++)\r\nregs_buff[571 + i] = rd32(E1000_RDBAL(i + 4));\r\nfor (i = 0; i < 12; i++)\r\nregs_buff[583 + i] = rd32(E1000_RDBAH(i + 4));\r\nfor (i = 0; i < 12; i++)\r\nregs_buff[595 + i] = rd32(E1000_RDLEN(i + 4));\r\nfor (i = 0; i < 12; i++)\r\nregs_buff[607 + i] = rd32(E1000_RDH(i + 4));\r\nfor (i = 0; i < 12; i++)\r\nregs_buff[619 + i] = rd32(E1000_RDT(i + 4));\r\nfor (i = 0; i < 12; i++)\r\nregs_buff[631 + i] = rd32(E1000_RXDCTL(i + 4));\r\nfor (i = 0; i < 12; i++)\r\nregs_buff[643 + i] = rd32(E1000_TDBAL(i + 4));\r\nfor (i = 0; i < 12; i++)\r\nregs_buff[655 + i] = rd32(E1000_TDBAH(i + 4));\r\nfor (i = 0; i < 12; i++)\r\nregs_buff[667 + i] = rd32(E1000_TDLEN(i + 4));\r\nfor (i = 0; i < 12; i++)\r\nregs_buff[679 + i] = rd32(E1000_TDH(i + 4));\r\nfor (i = 0; i < 12; i++)\r\nregs_buff[691 + i] = rd32(E1000_TDT(i + 4));\r\nfor (i = 0; i < 12; i++)\r\nregs_buff[703 + i] = rd32(E1000_TXDCTL(i + 4));\r\nfor (i = 0; i < 12; i++)\r\nregs_buff[715 + i] = rd32(E1000_TDWBAL(i + 4));\r\nfor (i = 0; i < 12; i++)\r\nregs_buff[727 + i] = rd32(E1000_TDWBAH(i + 4));\r\n}\r\nstatic int igb_get_eeprom_len(struct net_device *netdev)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nreturn adapter->hw.nvm.word_size * 2;\r\n}\r\nstatic int igb_get_eeprom(struct net_device *netdev,\r\nstruct ethtool_eeprom *eeprom, u8 *bytes)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu16 *eeprom_buff;\r\nint first_word, last_word;\r\nint ret_val = 0;\r\nu16 i;\r\nif (eeprom->len == 0)\r\nreturn -EINVAL;\r\neeprom->magic = hw->vendor_id | (hw->device_id << 16);\r\nfirst_word = eeprom->offset >> 1;\r\nlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\r\neeprom_buff = kmalloc(sizeof(u16) *\r\n(last_word - first_word + 1), GFP_KERNEL);\r\nif (!eeprom_buff)\r\nreturn -ENOMEM;\r\nif (hw->nvm.type == e1000_nvm_eeprom_spi)\r\nret_val = hw->nvm.ops.read(hw, first_word,\r\nlast_word - first_word + 1,\r\neeprom_buff);\r\nelse {\r\nfor (i = 0; i < last_word - first_word + 1; i++) {\r\nret_val = hw->nvm.ops.read(hw, first_word + i, 1,\r\n&eeprom_buff[i]);\r\nif (ret_val)\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < last_word - first_word + 1; i++)\r\nle16_to_cpus(&eeprom_buff[i]);\r\nmemcpy(bytes, (u8 *)eeprom_buff + (eeprom->offset & 1),\r\neeprom->len);\r\nkfree(eeprom_buff);\r\nreturn ret_val;\r\n}\r\nstatic int igb_set_eeprom(struct net_device *netdev,\r\nstruct ethtool_eeprom *eeprom, u8 *bytes)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu16 *eeprom_buff;\r\nvoid *ptr;\r\nint max_len, first_word, last_word, ret_val = 0;\r\nu16 i;\r\nif (eeprom->len == 0)\r\nreturn -EOPNOTSUPP;\r\nif ((hw->mac.type >= e1000_i210) &&\r\n!igb_get_flash_presence_i210(hw)) {\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (eeprom->magic != (hw->vendor_id | (hw->device_id << 16)))\r\nreturn -EFAULT;\r\nmax_len = hw->nvm.word_size * 2;\r\nfirst_word = eeprom->offset >> 1;\r\nlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\r\neeprom_buff = kmalloc(max_len, GFP_KERNEL);\r\nif (!eeprom_buff)\r\nreturn -ENOMEM;\r\nptr = (void *)eeprom_buff;\r\nif (eeprom->offset & 1) {\r\nret_val = hw->nvm.ops.read(hw, first_word, 1,\r\n&eeprom_buff[0]);\r\nptr++;\r\n}\r\nif (((eeprom->offset + eeprom->len) & 1) && (ret_val == 0)) {\r\nret_val = hw->nvm.ops.read(hw, last_word, 1,\r\n&eeprom_buff[last_word - first_word]);\r\n}\r\nfor (i = 0; i < last_word - first_word + 1; i++)\r\nle16_to_cpus(&eeprom_buff[i]);\r\nmemcpy(ptr, bytes, eeprom->len);\r\nfor (i = 0; i < last_word - first_word + 1; i++)\r\neeprom_buff[i] = cpu_to_le16(eeprom_buff[i]);\r\nret_val = hw->nvm.ops.write(hw, first_word,\r\nlast_word - first_word + 1, eeprom_buff);\r\nif (ret_val == 0)\r\nhw->nvm.ops.update(hw);\r\nigb_set_fw_version(adapter);\r\nkfree(eeprom_buff);\r\nreturn ret_val;\r\n}\r\nstatic void igb_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nstrlcpy(drvinfo->driver, igb_driver_name, sizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->version, igb_driver_version, sizeof(drvinfo->version));\r\nstrlcpy(drvinfo->fw_version, adapter->fw_version,\r\nsizeof(drvinfo->fw_version));\r\nstrlcpy(drvinfo->bus_info, pci_name(adapter->pdev),\r\nsizeof(drvinfo->bus_info));\r\ndrvinfo->n_stats = IGB_STATS_LEN;\r\ndrvinfo->testinfo_len = IGB_TEST_LEN;\r\ndrvinfo->regdump_len = igb_get_regs_len(netdev);\r\ndrvinfo->eedump_len = igb_get_eeprom_len(netdev);\r\n}\r\nstatic void igb_get_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nring->rx_max_pending = IGB_MAX_RXD;\r\nring->tx_max_pending = IGB_MAX_TXD;\r\nring->rx_pending = adapter->rx_ring_count;\r\nring->tx_pending = adapter->tx_ring_count;\r\n}\r\nstatic int igb_set_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nstruct igb_ring *temp_ring;\r\nint i, err = 0;\r\nu16 new_rx_count, new_tx_count;\r\nif ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))\r\nreturn -EINVAL;\r\nnew_rx_count = min_t(u32, ring->rx_pending, IGB_MAX_RXD);\r\nnew_rx_count = max_t(u16, new_rx_count, IGB_MIN_RXD);\r\nnew_rx_count = ALIGN(new_rx_count, REQ_RX_DESCRIPTOR_MULTIPLE);\r\nnew_tx_count = min_t(u32, ring->tx_pending, IGB_MAX_TXD);\r\nnew_tx_count = max_t(u16, new_tx_count, IGB_MIN_TXD);\r\nnew_tx_count = ALIGN(new_tx_count, REQ_TX_DESCRIPTOR_MULTIPLE);\r\nif ((new_tx_count == adapter->tx_ring_count) &&\r\n(new_rx_count == adapter->rx_ring_count)) {\r\nreturn 0;\r\n}\r\nwhile (test_and_set_bit(__IGB_RESETTING, &adapter->state))\r\nusleep_range(1000, 2000);\r\nif (!netif_running(adapter->netdev)) {\r\nfor (i = 0; i < adapter->num_tx_queues; i++)\r\nadapter->tx_ring[i]->count = new_tx_count;\r\nfor (i = 0; i < adapter->num_rx_queues; i++)\r\nadapter->rx_ring[i]->count = new_rx_count;\r\nadapter->tx_ring_count = new_tx_count;\r\nadapter->rx_ring_count = new_rx_count;\r\ngoto clear_reset;\r\n}\r\nif (adapter->num_tx_queues > adapter->num_rx_queues)\r\ntemp_ring = vmalloc(adapter->num_tx_queues *\r\nsizeof(struct igb_ring));\r\nelse\r\ntemp_ring = vmalloc(adapter->num_rx_queues *\r\nsizeof(struct igb_ring));\r\nif (!temp_ring) {\r\nerr = -ENOMEM;\r\ngoto clear_reset;\r\n}\r\nigb_down(adapter);\r\nif (new_tx_count != adapter->tx_ring_count) {\r\nfor (i = 0; i < adapter->num_tx_queues; i++) {\r\nmemcpy(&temp_ring[i], adapter->tx_ring[i],\r\nsizeof(struct igb_ring));\r\ntemp_ring[i].count = new_tx_count;\r\nerr = igb_setup_tx_resources(&temp_ring[i]);\r\nif (err) {\r\nwhile (i) {\r\ni--;\r\nigb_free_tx_resources(&temp_ring[i]);\r\n}\r\ngoto err_setup;\r\n}\r\n}\r\nfor (i = 0; i < adapter->num_tx_queues; i++) {\r\nigb_free_tx_resources(adapter->tx_ring[i]);\r\nmemcpy(adapter->tx_ring[i], &temp_ring[i],\r\nsizeof(struct igb_ring));\r\n}\r\nadapter->tx_ring_count = new_tx_count;\r\n}\r\nif (new_rx_count != adapter->rx_ring_count) {\r\nfor (i = 0; i < adapter->num_rx_queues; i++) {\r\nmemcpy(&temp_ring[i], adapter->rx_ring[i],\r\nsizeof(struct igb_ring));\r\ntemp_ring[i].count = new_rx_count;\r\nerr = igb_setup_rx_resources(&temp_ring[i]);\r\nif (err) {\r\nwhile (i) {\r\ni--;\r\nigb_free_rx_resources(&temp_ring[i]);\r\n}\r\ngoto err_setup;\r\n}\r\n}\r\nfor (i = 0; i < adapter->num_rx_queues; i++) {\r\nigb_free_rx_resources(adapter->rx_ring[i]);\r\nmemcpy(adapter->rx_ring[i], &temp_ring[i],\r\nsizeof(struct igb_ring));\r\n}\r\nadapter->rx_ring_count = new_rx_count;\r\n}\r\nerr_setup:\r\nigb_up(adapter);\r\nvfree(temp_ring);\r\nclear_reset:\r\nclear_bit(__IGB_RESETTING, &adapter->state);\r\nreturn err;\r\n}\r\nstatic bool reg_pattern_test(struct igb_adapter *adapter, u64 *data,\r\nint reg, u32 mask, u32 write)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 pat, val;\r\nstatic const u32 _test[] = {\r\n0x5A5A5A5A, 0xA5A5A5A5, 0x00000000, 0xFFFFFFFF};\r\nfor (pat = 0; pat < ARRAY_SIZE(_test); pat++) {\r\nwr32(reg, (_test[pat] & write));\r\nval = rd32(reg) & mask;\r\nif (val != (_test[pat] & write & mask)) {\r\ndev_err(&adapter->pdev->dev,\r\n"pattern test reg %04X failed: got 0x%08X expected 0x%08X\n",\r\nreg, val, (_test[pat] & write & mask));\r\n*data = reg;\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic bool reg_set_and_check(struct igb_adapter *adapter, u64 *data,\r\nint reg, u32 mask, u32 write)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 val;\r\nwr32(reg, write & mask);\r\nval = rd32(reg);\r\nif ((write & mask) != (val & mask)) {\r\ndev_err(&adapter->pdev->dev,\r\n"set/check reg %04X test failed: got 0x%08X expected 0x%08X\n",\r\nreg, (val & mask), (write & mask));\r\n*data = reg;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int igb_reg_test(struct igb_adapter *adapter, u64 *data)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct igb_reg_test *test;\r\nu32 value, before, after;\r\nu32 i, toggle;\r\nswitch (adapter->hw.mac.type) {\r\ncase e1000_i350:\r\ncase e1000_i354:\r\ntest = reg_test_i350;\r\ntoggle = 0x7FEFF3FF;\r\nbreak;\r\ncase e1000_i210:\r\ncase e1000_i211:\r\ntest = reg_test_i210;\r\ntoggle = 0x7FEFF3FF;\r\nbreak;\r\ncase e1000_82580:\r\ntest = reg_test_82580;\r\ntoggle = 0x7FEFF3FF;\r\nbreak;\r\ncase e1000_82576:\r\ntest = reg_test_82576;\r\ntoggle = 0x7FFFF3FF;\r\nbreak;\r\ndefault:\r\ntest = reg_test_82575;\r\ntoggle = 0x7FFFF3FF;\r\nbreak;\r\n}\r\nbefore = rd32(E1000_STATUS);\r\nvalue = (rd32(E1000_STATUS) & toggle);\r\nwr32(E1000_STATUS, toggle);\r\nafter = rd32(E1000_STATUS) & toggle;\r\nif (value != after) {\r\ndev_err(&adapter->pdev->dev,\r\n"failed STATUS register test got: 0x%08X expected: 0x%08X\n",\r\nafter, value);\r\n*data = 1;\r\nreturn 1;\r\n}\r\nwr32(E1000_STATUS, before);\r\nwhile (test->reg) {\r\nfor (i = 0; i < test->array_len; i++) {\r\nswitch (test->test_type) {\r\ncase PATTERN_TEST:\r\nREG_PATTERN_TEST(test->reg +\r\n(i * test->reg_offset),\r\ntest->mask,\r\ntest->write);\r\nbreak;\r\ncase SET_READ_TEST:\r\nREG_SET_AND_CHECK(test->reg +\r\n(i * test->reg_offset),\r\ntest->mask,\r\ntest->write);\r\nbreak;\r\ncase WRITE_NO_TEST:\r\nwritel(test->write,\r\n(adapter->hw.hw_addr + test->reg)\r\n+ (i * test->reg_offset));\r\nbreak;\r\ncase TABLE32_TEST:\r\nREG_PATTERN_TEST(test->reg + (i * 4),\r\ntest->mask,\r\ntest->write);\r\nbreak;\r\ncase TABLE64_TEST_LO:\r\nREG_PATTERN_TEST(test->reg + (i * 8),\r\ntest->mask,\r\ntest->write);\r\nbreak;\r\ncase TABLE64_TEST_HI:\r\nREG_PATTERN_TEST((test->reg + 4) + (i * 8),\r\ntest->mask,\r\ntest->write);\r\nbreak;\r\n}\r\n}\r\ntest++;\r\n}\r\n*data = 0;\r\nreturn 0;\r\n}\r\nstatic int igb_eeprom_test(struct igb_adapter *adapter, u64 *data)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\n*data = 0;\r\nswitch (hw->mac.type) {\r\ncase e1000_i210:\r\ncase e1000_i211:\r\nif (igb_get_flash_presence_i210(hw)) {\r\nif (adapter->hw.nvm.ops.validate(&adapter->hw) < 0)\r\n*data = 2;\r\n}\r\nbreak;\r\ndefault:\r\nif (adapter->hw.nvm.ops.validate(&adapter->hw) < 0)\r\n*data = 2;\r\nbreak;\r\n}\r\nreturn *data;\r\n}\r\nstatic irqreturn_t igb_test_intr(int irq, void *data)\r\n{\r\nstruct igb_adapter *adapter = (struct igb_adapter *) data;\r\nstruct e1000_hw *hw = &adapter->hw;\r\nadapter->test_icr |= rd32(E1000_ICR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int igb_intr_test(struct igb_adapter *adapter, u64 *data)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct net_device *netdev = adapter->netdev;\r\nu32 mask, ics_mask, i = 0, shared_int = true;\r\nu32 irq = adapter->pdev->irq;\r\n*data = 0;\r\nif (adapter->flags & IGB_FLAG_HAS_MSIX) {\r\nif (request_irq(adapter->msix_entries[0].vector,\r\nigb_test_intr, 0, netdev->name, adapter)) {\r\n*data = 1;\r\nreturn -1;\r\n}\r\n} else if (adapter->flags & IGB_FLAG_HAS_MSI) {\r\nshared_int = false;\r\nif (request_irq(irq,\r\nigb_test_intr, 0, netdev->name, adapter)) {\r\n*data = 1;\r\nreturn -1;\r\n}\r\n} else if (!request_irq(irq, igb_test_intr, IRQF_PROBE_SHARED,\r\nnetdev->name, adapter)) {\r\nshared_int = false;\r\n} else if (request_irq(irq, igb_test_intr, IRQF_SHARED,\r\nnetdev->name, adapter)) {\r\n*data = 1;\r\nreturn -1;\r\n}\r\ndev_info(&adapter->pdev->dev, "testing %s interrupt\n",\r\n(shared_int ? "shared" : "unshared"));\r\nwr32(E1000_IMC, ~0);\r\nwrfl();\r\nusleep_range(10000, 11000);\r\nswitch (hw->mac.type) {\r\ncase e1000_82575:\r\nics_mask = 0x37F47EDD;\r\nbreak;\r\ncase e1000_82576:\r\nics_mask = 0x77D4FBFD;\r\nbreak;\r\ncase e1000_82580:\r\nics_mask = 0x77DCFED5;\r\nbreak;\r\ncase e1000_i350:\r\ncase e1000_i354:\r\ncase e1000_i210:\r\ncase e1000_i211:\r\nics_mask = 0x77DCFED5;\r\nbreak;\r\ndefault:\r\nics_mask = 0x7FFFFFFF;\r\nbreak;\r\n}\r\nfor (; i < 31; i++) {\r\nmask = 1 << i;\r\nif (!(mask & ics_mask))\r\ncontinue;\r\nif (!shared_int) {\r\nadapter->test_icr = 0;\r\nwr32(E1000_ICR, ~0);\r\nwr32(E1000_IMC, mask);\r\nwr32(E1000_ICS, mask);\r\nwrfl();\r\nusleep_range(10000, 11000);\r\nif (adapter->test_icr & mask) {\r\n*data = 3;\r\nbreak;\r\n}\r\n}\r\nadapter->test_icr = 0;\r\nwr32(E1000_ICR, ~0);\r\nwr32(E1000_IMS, mask);\r\nwr32(E1000_ICS, mask);\r\nwrfl();\r\nusleep_range(10000, 11000);\r\nif (!(adapter->test_icr & mask)) {\r\n*data = 4;\r\nbreak;\r\n}\r\nif (!shared_int) {\r\nadapter->test_icr = 0;\r\nwr32(E1000_ICR, ~0);\r\nwr32(E1000_IMC, ~mask);\r\nwr32(E1000_ICS, ~mask);\r\nwrfl();\r\nusleep_range(10000, 11000);\r\nif (adapter->test_icr & mask) {\r\n*data = 5;\r\nbreak;\r\n}\r\n}\r\n}\r\nwr32(E1000_IMC, ~0);\r\nwrfl();\r\nusleep_range(10000, 11000);\r\nif (adapter->flags & IGB_FLAG_HAS_MSIX)\r\nfree_irq(adapter->msix_entries[0].vector, adapter);\r\nelse\r\nfree_irq(irq, adapter);\r\nreturn *data;\r\n}\r\nstatic void igb_free_desc_rings(struct igb_adapter *adapter)\r\n{\r\nigb_free_tx_resources(&adapter->test_tx_ring);\r\nigb_free_rx_resources(&adapter->test_rx_ring);\r\n}\r\nstatic int igb_setup_desc_rings(struct igb_adapter *adapter)\r\n{\r\nstruct igb_ring *tx_ring = &adapter->test_tx_ring;\r\nstruct igb_ring *rx_ring = &adapter->test_rx_ring;\r\nstruct e1000_hw *hw = &adapter->hw;\r\nint ret_val;\r\ntx_ring->count = IGB_DEFAULT_TXD;\r\ntx_ring->dev = &adapter->pdev->dev;\r\ntx_ring->netdev = adapter->netdev;\r\ntx_ring->reg_idx = adapter->vfs_allocated_count;\r\nif (igb_setup_tx_resources(tx_ring)) {\r\nret_val = 1;\r\ngoto err_nomem;\r\n}\r\nigb_setup_tctl(adapter);\r\nigb_configure_tx_ring(adapter, tx_ring);\r\nrx_ring->count = IGB_DEFAULT_RXD;\r\nrx_ring->dev = &adapter->pdev->dev;\r\nrx_ring->netdev = adapter->netdev;\r\nrx_ring->reg_idx = adapter->vfs_allocated_count;\r\nif (igb_setup_rx_resources(rx_ring)) {\r\nret_val = 3;\r\ngoto err_nomem;\r\n}\r\nwr32(E1000_MRQC, adapter->vfs_allocated_count << 3);\r\nigb_setup_rctl(adapter);\r\nigb_configure_rx_ring(adapter, rx_ring);\r\nigb_alloc_rx_buffers(rx_ring, igb_desc_unused(rx_ring));\r\nreturn 0;\r\nerr_nomem:\r\nigb_free_desc_rings(adapter);\r\nreturn ret_val;\r\n}\r\nstatic void igb_phy_disable_receiver(struct igb_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nigb_write_phy_reg(hw, 29, 0x001F);\r\nigb_write_phy_reg(hw, 30, 0x8FFC);\r\nigb_write_phy_reg(hw, 29, 0x001A);\r\nigb_write_phy_reg(hw, 30, 0x8FF0);\r\n}\r\nstatic int igb_integrated_phy_loopback(struct igb_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 ctrl_reg = 0;\r\nhw->mac.autoneg = false;\r\nif (hw->phy.type == e1000_phy_m88) {\r\nif (hw->phy.id != I210_I_PHY_ID) {\r\nigb_write_phy_reg(hw, M88E1000_PHY_SPEC_CTRL, 0x0808);\r\nigb_write_phy_reg(hw, PHY_CONTROL, 0x9140);\r\nigb_write_phy_reg(hw, PHY_CONTROL, 0x8140);\r\n} else {\r\nigb_write_phy_reg(hw, I347AT4_PAGE_SELECT, 0);\r\nigb_write_phy_reg(hw, PHY_CONTROL, 0x4140);\r\n}\r\n} else if (hw->phy.type == e1000_phy_82580) {\r\nigb_write_phy_reg(hw, I82580_PHY_LBK_CTRL, 0x8041);\r\n}\r\nmsleep(50);\r\nigb_write_phy_reg(hw, PHY_CONTROL, 0x4140);\r\nctrl_reg = rd32(E1000_CTRL);\r\nctrl_reg &= ~E1000_CTRL_SPD_SEL;\r\nctrl_reg |= (E1000_CTRL_FRCSPD |\r\nE1000_CTRL_FRCDPX |\r\nE1000_CTRL_SPD_1000 |\r\nE1000_CTRL_FD |\r\nE1000_CTRL_SLU);\r\nif (hw->phy.type == e1000_phy_m88)\r\nctrl_reg |= E1000_CTRL_ILOS;\r\nwr32(E1000_CTRL, ctrl_reg);\r\nif (hw->phy.type == e1000_phy_m88)\r\nigb_phy_disable_receiver(adapter);\r\nmdelay(500);\r\nreturn 0;\r\n}\r\nstatic int igb_set_phy_loopback(struct igb_adapter *adapter)\r\n{\r\nreturn igb_integrated_phy_loopback(adapter);\r\n}\r\nstatic int igb_setup_loopback_test(struct igb_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 reg;\r\nreg = rd32(E1000_CTRL_EXT);\r\nif (reg & E1000_CTRL_EXT_LINK_MODE_MASK) {\r\nif ((hw->device_id == E1000_DEV_ID_DH89XXCC_SGMII) ||\r\n(hw->device_id == E1000_DEV_ID_DH89XXCC_SERDES) ||\r\n(hw->device_id == E1000_DEV_ID_DH89XXCC_BACKPLANE) ||\r\n(hw->device_id == E1000_DEV_ID_DH89XXCC_SFP) ||\r\n(hw->device_id == E1000_DEV_ID_I354_SGMII) ||\r\n(hw->device_id == E1000_DEV_ID_I354_BACKPLANE_2_5GBPS)) {\r\nreg = rd32(E1000_MPHY_ADDR_CTL);\r\nreg = (reg & E1000_MPHY_ADDR_CTL_OFFSET_MASK) |\r\nE1000_MPHY_PCS_CLK_REG_OFFSET;\r\nwr32(E1000_MPHY_ADDR_CTL, reg);\r\nreg = rd32(E1000_MPHY_DATA);\r\nreg |= E1000_MPHY_PCS_CLK_REG_DIGINELBEN;\r\nwr32(E1000_MPHY_DATA, reg);\r\n}\r\nreg = rd32(E1000_RCTL);\r\nreg |= E1000_RCTL_LBM_TCVR;\r\nwr32(E1000_RCTL, reg);\r\nwr32(E1000_SCTL, E1000_ENABLE_SERDES_LOOPBACK);\r\nreg = rd32(E1000_CTRL);\r\nreg &= ~(E1000_CTRL_RFCE |\r\nE1000_CTRL_TFCE |\r\nE1000_CTRL_LRST);\r\nreg |= E1000_CTRL_SLU |\r\nE1000_CTRL_FD;\r\nwr32(E1000_CTRL, reg);\r\nreg = rd32(E1000_CONNSW);\r\nreg &= ~E1000_CONNSW_ENRGSRC;\r\nwr32(E1000_CONNSW, reg);\r\nif (hw->mac.type >= e1000_82580) {\r\nreg = rd32(E1000_PCS_CFG0);\r\nreg |= E1000_PCS_CFG_IGN_SD;\r\nwr32(E1000_PCS_CFG0, reg);\r\n}\r\nreg = rd32(E1000_PCS_LCTL);\r\nreg &= ~E1000_PCS_LCTL_AN_ENABLE;\r\nreg |= E1000_PCS_LCTL_FLV_LINK_UP |\r\nE1000_PCS_LCTL_FSV_1000 |\r\nE1000_PCS_LCTL_FDV_FULL |\r\nE1000_PCS_LCTL_FSD |\r\nE1000_PCS_LCTL_FORCE_LINK;\r\nwr32(E1000_PCS_LCTL, reg);\r\nreturn 0;\r\n}\r\nreturn igb_set_phy_loopback(adapter);\r\n}\r\nstatic void igb_loopback_cleanup(struct igb_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 rctl;\r\nu16 phy_reg;\r\nif ((hw->device_id == E1000_DEV_ID_DH89XXCC_SGMII) ||\r\n(hw->device_id == E1000_DEV_ID_DH89XXCC_SERDES) ||\r\n(hw->device_id == E1000_DEV_ID_DH89XXCC_BACKPLANE) ||\r\n(hw->device_id == E1000_DEV_ID_DH89XXCC_SFP) ||\r\n(hw->device_id == E1000_DEV_ID_I354_SGMII)) {\r\nu32 reg;\r\nreg = rd32(E1000_MPHY_ADDR_CTL);\r\nreg = (reg & E1000_MPHY_ADDR_CTL_OFFSET_MASK) |\r\nE1000_MPHY_PCS_CLK_REG_OFFSET;\r\nwr32(E1000_MPHY_ADDR_CTL, reg);\r\nreg = rd32(E1000_MPHY_DATA);\r\nreg &= ~E1000_MPHY_PCS_CLK_REG_DIGINELBEN;\r\nwr32(E1000_MPHY_DATA, reg);\r\n}\r\nrctl = rd32(E1000_RCTL);\r\nrctl &= ~(E1000_RCTL_LBM_TCVR | E1000_RCTL_LBM_MAC);\r\nwr32(E1000_RCTL, rctl);\r\nhw->mac.autoneg = true;\r\nigb_read_phy_reg(hw, PHY_CONTROL, &phy_reg);\r\nif (phy_reg & MII_CR_LOOPBACK) {\r\nphy_reg &= ~MII_CR_LOOPBACK;\r\nigb_write_phy_reg(hw, PHY_CONTROL, phy_reg);\r\nigb_phy_sw_reset(hw);\r\n}\r\n}\r\nstatic void igb_create_lbtest_frame(struct sk_buff *skb,\r\nunsigned int frame_size)\r\n{\r\nmemset(skb->data, 0xFF, frame_size);\r\nframe_size /= 2;\r\nmemset(&skb->data[frame_size], 0xAA, frame_size - 1);\r\nmemset(&skb->data[frame_size + 10], 0xBE, 1);\r\nmemset(&skb->data[frame_size + 12], 0xAF, 1);\r\n}\r\nstatic int igb_check_lbtest_frame(struct igb_rx_buffer *rx_buffer,\r\nunsigned int frame_size)\r\n{\r\nunsigned char *data;\r\nbool match = true;\r\nframe_size >>= 1;\r\ndata = kmap(rx_buffer->page);\r\nif (data[3] != 0xFF ||\r\ndata[frame_size + 10] != 0xBE ||\r\ndata[frame_size + 12] != 0xAF)\r\nmatch = false;\r\nkunmap(rx_buffer->page);\r\nreturn match;\r\n}\r\nstatic int igb_clean_test_rings(struct igb_ring *rx_ring,\r\nstruct igb_ring *tx_ring,\r\nunsigned int size)\r\n{\r\nunion e1000_adv_rx_desc *rx_desc;\r\nstruct igb_rx_buffer *rx_buffer_info;\r\nstruct igb_tx_buffer *tx_buffer_info;\r\nu16 rx_ntc, tx_ntc, count = 0;\r\nrx_ntc = rx_ring->next_to_clean;\r\ntx_ntc = tx_ring->next_to_clean;\r\nrx_desc = IGB_RX_DESC(rx_ring, rx_ntc);\r\nwhile (igb_test_staterr(rx_desc, E1000_RXD_STAT_DD)) {\r\nrx_buffer_info = &rx_ring->rx_buffer_info[rx_ntc];\r\ndma_sync_single_for_cpu(rx_ring->dev,\r\nrx_buffer_info->dma,\r\nIGB_RX_BUFSZ,\r\nDMA_FROM_DEVICE);\r\nif (igb_check_lbtest_frame(rx_buffer_info, size))\r\ncount++;\r\ndma_sync_single_for_device(rx_ring->dev,\r\nrx_buffer_info->dma,\r\nIGB_RX_BUFSZ,\r\nDMA_FROM_DEVICE);\r\ntx_buffer_info = &tx_ring->tx_buffer_info[tx_ntc];\r\nigb_unmap_and_free_tx_resource(tx_ring, tx_buffer_info);\r\nrx_ntc++;\r\nif (rx_ntc == rx_ring->count)\r\nrx_ntc = 0;\r\ntx_ntc++;\r\nif (tx_ntc == tx_ring->count)\r\ntx_ntc = 0;\r\nrx_desc = IGB_RX_DESC(rx_ring, rx_ntc);\r\n}\r\nnetdev_tx_reset_queue(txring_txq(tx_ring));\r\nigb_alloc_rx_buffers(rx_ring, count);\r\nrx_ring->next_to_clean = rx_ntc;\r\ntx_ring->next_to_clean = tx_ntc;\r\nreturn count;\r\n}\r\nstatic int igb_run_loopback_test(struct igb_adapter *adapter)\r\n{\r\nstruct igb_ring *tx_ring = &adapter->test_tx_ring;\r\nstruct igb_ring *rx_ring = &adapter->test_rx_ring;\r\nu16 i, j, lc, good_cnt;\r\nint ret_val = 0;\r\nunsigned int size = IGB_RX_HDR_LEN;\r\nnetdev_tx_t tx_ret_val;\r\nstruct sk_buff *skb;\r\nskb = alloc_skb(size, GFP_KERNEL);\r\nif (!skb)\r\nreturn 11;\r\nigb_create_lbtest_frame(skb, size);\r\nskb_put(skb, size);\r\nif (rx_ring->count <= tx_ring->count)\r\nlc = ((tx_ring->count / 64) * 2) + 1;\r\nelse\r\nlc = ((rx_ring->count / 64) * 2) + 1;\r\nfor (j = 0; j <= lc; j++) {\r\ngood_cnt = 0;\r\nfor (i = 0; i < 64; i++) {\r\nskb_get(skb);\r\ntx_ret_val = igb_xmit_frame_ring(skb, tx_ring);\r\nif (tx_ret_val == NETDEV_TX_OK)\r\ngood_cnt++;\r\n}\r\nif (good_cnt != 64) {\r\nret_val = 12;\r\nbreak;\r\n}\r\nmsleep(200);\r\ngood_cnt = igb_clean_test_rings(rx_ring, tx_ring, size);\r\nif (good_cnt != 64) {\r\nret_val = 13;\r\nbreak;\r\n}\r\n}\r\nkfree_skb(skb);\r\nreturn ret_val;\r\n}\r\nstatic int igb_loopback_test(struct igb_adapter *adapter, u64 *data)\r\n{\r\nif (igb_check_reset_block(&adapter->hw)) {\r\ndev_err(&adapter->pdev->dev,\r\n"Cannot do PHY loopback test when SoL/IDER is active.\n");\r\n*data = 0;\r\ngoto out;\r\n}\r\nif (adapter->hw.mac.type == e1000_i354) {\r\ndev_info(&adapter->pdev->dev,\r\n"Loopback test not supported on i354.\n");\r\n*data = 0;\r\ngoto out;\r\n}\r\n*data = igb_setup_desc_rings(adapter);\r\nif (*data)\r\ngoto out;\r\n*data = igb_setup_loopback_test(adapter);\r\nif (*data)\r\ngoto err_loopback;\r\n*data = igb_run_loopback_test(adapter);\r\nigb_loopback_cleanup(adapter);\r\nerr_loopback:\r\nigb_free_desc_rings(adapter);\r\nout:\r\nreturn *data;\r\n}\r\nstatic int igb_link_test(struct igb_adapter *adapter, u64 *data)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\n*data = 0;\r\nif (hw->phy.media_type == e1000_media_type_internal_serdes) {\r\nint i = 0;\r\nhw->mac.serdes_has_link = false;\r\ndo {\r\nhw->mac.ops.check_for_link(&adapter->hw);\r\nif (hw->mac.serdes_has_link)\r\nreturn *data;\r\nmsleep(20);\r\n} while (i++ < 3750);\r\n*data = 1;\r\n} else {\r\nhw->mac.ops.check_for_link(&adapter->hw);\r\nif (hw->mac.autoneg)\r\nmsleep(5000);\r\nif (!(rd32(E1000_STATUS) & E1000_STATUS_LU))\r\n*data = 1;\r\n}\r\nreturn *data;\r\n}\r\nstatic void igb_diag_test(struct net_device *netdev,\r\nstruct ethtool_test *eth_test, u64 *data)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nu16 autoneg_advertised;\r\nu8 forced_speed_duplex, autoneg;\r\nbool if_running = netif_running(netdev);\r\nset_bit(__IGB_TESTING, &adapter->state);\r\nif (adapter->hw.dev_spec._82575.mas_capable)\r\neth_test->flags &= ~ETH_TEST_FL_OFFLINE;\r\nif (eth_test->flags == ETH_TEST_FL_OFFLINE) {\r\nautoneg_advertised = adapter->hw.phy.autoneg_advertised;\r\nforced_speed_duplex = adapter->hw.mac.forced_speed_duplex;\r\nautoneg = adapter->hw.mac.autoneg;\r\ndev_info(&adapter->pdev->dev, "offline testing starting\n");\r\nigb_power_up_link(adapter);\r\nif (igb_link_test(adapter, &data[4]))\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\nif (if_running)\r\ndev_close(netdev);\r\nelse\r\nigb_reset(adapter);\r\nif (igb_reg_test(adapter, &data[0]))\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\nigb_reset(adapter);\r\nif (igb_eeprom_test(adapter, &data[1]))\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\nigb_reset(adapter);\r\nif (igb_intr_test(adapter, &data[2]))\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\nigb_reset(adapter);\r\nigb_power_up_link(adapter);\r\nif (igb_loopback_test(adapter, &data[3]))\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\nadapter->hw.phy.autoneg_advertised = autoneg_advertised;\r\nadapter->hw.mac.forced_speed_duplex = forced_speed_duplex;\r\nadapter->hw.mac.autoneg = autoneg;\r\nadapter->hw.phy.autoneg_wait_to_complete = true;\r\nigb_reset(adapter);\r\nadapter->hw.phy.autoneg_wait_to_complete = false;\r\nclear_bit(__IGB_TESTING, &adapter->state);\r\nif (if_running)\r\ndev_open(netdev);\r\n} else {\r\ndev_info(&adapter->pdev->dev, "online testing starting\n");\r\nif (if_running && igb_link_test(adapter, &data[4]))\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\nelse\r\ndata[4] = 0;\r\ndata[0] = 0;\r\ndata[1] = 0;\r\ndata[2] = 0;\r\ndata[3] = 0;\r\nclear_bit(__IGB_TESTING, &adapter->state);\r\n}\r\nmsleep_interruptible(4 * 1000);\r\n}\r\nstatic void igb_get_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nwol->wolopts = 0;\r\nif (!(adapter->flags & IGB_FLAG_WOL_SUPPORTED))\r\nreturn;\r\nwol->supported = WAKE_UCAST | WAKE_MCAST |\r\nWAKE_BCAST | WAKE_MAGIC |\r\nWAKE_PHY;\r\nswitch (adapter->hw.device_id) {\r\ndefault:\r\nbreak;\r\n}\r\nif (adapter->wol & E1000_WUFC_EX)\r\nwol->wolopts |= WAKE_UCAST;\r\nif (adapter->wol & E1000_WUFC_MC)\r\nwol->wolopts |= WAKE_MCAST;\r\nif (adapter->wol & E1000_WUFC_BC)\r\nwol->wolopts |= WAKE_BCAST;\r\nif (adapter->wol & E1000_WUFC_MAG)\r\nwol->wolopts |= WAKE_MAGIC;\r\nif (adapter->wol & E1000_WUFC_LNKC)\r\nwol->wolopts |= WAKE_PHY;\r\n}\r\nstatic int igb_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nif (wol->wolopts & (WAKE_ARP | WAKE_MAGICSECURE))\r\nreturn -EOPNOTSUPP;\r\nif (!(adapter->flags & IGB_FLAG_WOL_SUPPORTED))\r\nreturn wol->wolopts ? -EOPNOTSUPP : 0;\r\nadapter->wol = 0;\r\nif (wol->wolopts & WAKE_UCAST)\r\nadapter->wol |= E1000_WUFC_EX;\r\nif (wol->wolopts & WAKE_MCAST)\r\nadapter->wol |= E1000_WUFC_MC;\r\nif (wol->wolopts & WAKE_BCAST)\r\nadapter->wol |= E1000_WUFC_BC;\r\nif (wol->wolopts & WAKE_MAGIC)\r\nadapter->wol |= E1000_WUFC_MAG;\r\nif (wol->wolopts & WAKE_PHY)\r\nadapter->wol |= E1000_WUFC_LNKC;\r\ndevice_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);\r\nreturn 0;\r\n}\r\nstatic int igb_set_phys_id(struct net_device *netdev,\r\nenum ethtool_phys_id_state state)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nswitch (state) {\r\ncase ETHTOOL_ID_ACTIVE:\r\nigb_blink_led(hw);\r\nreturn 2;\r\ncase ETHTOOL_ID_ON:\r\nigb_blink_led(hw);\r\nbreak;\r\ncase ETHTOOL_ID_OFF:\r\nigb_led_off(hw);\r\nbreak;\r\ncase ETHTOOL_ID_INACTIVE:\r\nigb_led_off(hw);\r\nclear_bit(IGB_LED_ON, &adapter->led_status);\r\nigb_cleanup_led(hw);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int igb_set_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nint i;\r\nif ((ec->rx_coalesce_usecs > IGB_MAX_ITR_USECS) ||\r\n((ec->rx_coalesce_usecs > 3) &&\r\n(ec->rx_coalesce_usecs < IGB_MIN_ITR_USECS)) ||\r\n(ec->rx_coalesce_usecs == 2))\r\nreturn -EINVAL;\r\nif ((ec->tx_coalesce_usecs > IGB_MAX_ITR_USECS) ||\r\n((ec->tx_coalesce_usecs > 3) &&\r\n(ec->tx_coalesce_usecs < IGB_MIN_ITR_USECS)) ||\r\n(ec->tx_coalesce_usecs == 2))\r\nreturn -EINVAL;\r\nif ((adapter->flags & IGB_FLAG_QUEUE_PAIRS) && ec->tx_coalesce_usecs)\r\nreturn -EINVAL;\r\nif (ec->rx_coalesce_usecs == 0) {\r\nif (adapter->flags & IGB_FLAG_DMAC)\r\nadapter->flags &= ~IGB_FLAG_DMAC;\r\n}\r\nif (ec->rx_coalesce_usecs && ec->rx_coalesce_usecs <= 3)\r\nadapter->rx_itr_setting = ec->rx_coalesce_usecs;\r\nelse\r\nadapter->rx_itr_setting = ec->rx_coalesce_usecs << 2;\r\nif (adapter->flags & IGB_FLAG_QUEUE_PAIRS)\r\nadapter->tx_itr_setting = adapter->rx_itr_setting;\r\nelse if (ec->tx_coalesce_usecs && ec->tx_coalesce_usecs <= 3)\r\nadapter->tx_itr_setting = ec->tx_coalesce_usecs;\r\nelse\r\nadapter->tx_itr_setting = ec->tx_coalesce_usecs << 2;\r\nfor (i = 0; i < adapter->num_q_vectors; i++) {\r\nstruct igb_q_vector *q_vector = adapter->q_vector[i];\r\nq_vector->tx.work_limit = adapter->tx_work_limit;\r\nif (q_vector->rx.ring)\r\nq_vector->itr_val = adapter->rx_itr_setting;\r\nelse\r\nq_vector->itr_val = adapter->tx_itr_setting;\r\nif (q_vector->itr_val && q_vector->itr_val <= 3)\r\nq_vector->itr_val = IGB_START_ITR;\r\nq_vector->set_itr = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int igb_get_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nif (adapter->rx_itr_setting <= 3)\r\nec->rx_coalesce_usecs = adapter->rx_itr_setting;\r\nelse\r\nec->rx_coalesce_usecs = adapter->rx_itr_setting >> 2;\r\nif (!(adapter->flags & IGB_FLAG_QUEUE_PAIRS)) {\r\nif (adapter->tx_itr_setting <= 3)\r\nec->tx_coalesce_usecs = adapter->tx_itr_setting;\r\nelse\r\nec->tx_coalesce_usecs = adapter->tx_itr_setting >> 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic int igb_nway_reset(struct net_device *netdev)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nif (netif_running(netdev))\r\nigb_reinit_locked(adapter);\r\nreturn 0;\r\n}\r\nstatic int igb_get_sset_count(struct net_device *netdev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn IGB_STATS_LEN;\r\ncase ETH_SS_TEST:\r\nreturn IGB_TEST_LEN;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nstatic void igb_get_ethtool_stats(struct net_device *netdev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nstruct rtnl_link_stats64 *net_stats = &adapter->stats64;\r\nunsigned int start;\r\nstruct igb_ring *ring;\r\nint i, j;\r\nchar *p;\r\nspin_lock(&adapter->stats64_lock);\r\nigb_update_stats(adapter, net_stats);\r\nfor (i = 0; i < IGB_GLOBAL_STATS_LEN; i++) {\r\np = (char *)adapter + igb_gstrings_stats[i].stat_offset;\r\ndata[i] = (igb_gstrings_stats[i].sizeof_stat ==\r\nsizeof(u64)) ? *(u64 *)p : *(u32 *)p;\r\n}\r\nfor (j = 0; j < IGB_NETDEV_STATS_LEN; j++, i++) {\r\np = (char *)net_stats + igb_gstrings_net_stats[j].stat_offset;\r\ndata[i] = (igb_gstrings_net_stats[j].sizeof_stat ==\r\nsizeof(u64)) ? *(u64 *)p : *(u32 *)p;\r\n}\r\nfor (j = 0; j < adapter->num_tx_queues; j++) {\r\nu64 restart2;\r\nring = adapter->tx_ring[j];\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&ring->tx_syncp);\r\ndata[i] = ring->tx_stats.packets;\r\ndata[i+1] = ring->tx_stats.bytes;\r\ndata[i+2] = ring->tx_stats.restart_queue;\r\n} while (u64_stats_fetch_retry_irq(&ring->tx_syncp, start));\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&ring->tx_syncp2);\r\nrestart2 = ring->tx_stats.restart_queue2;\r\n} while (u64_stats_fetch_retry_irq(&ring->tx_syncp2, start));\r\ndata[i+2] += restart2;\r\ni += IGB_TX_QUEUE_STATS_LEN;\r\n}\r\nfor (j = 0; j < adapter->num_rx_queues; j++) {\r\nring = adapter->rx_ring[j];\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&ring->rx_syncp);\r\ndata[i] = ring->rx_stats.packets;\r\ndata[i+1] = ring->rx_stats.bytes;\r\ndata[i+2] = ring->rx_stats.drops;\r\ndata[i+3] = ring->rx_stats.csum_err;\r\ndata[i+4] = ring->rx_stats.alloc_failed;\r\n} while (u64_stats_fetch_retry_irq(&ring->rx_syncp, start));\r\ni += IGB_RX_QUEUE_STATS_LEN;\r\n}\r\nspin_unlock(&adapter->stats64_lock);\r\n}\r\nstatic void igb_get_strings(struct net_device *netdev, u32 stringset, u8 *data)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nu8 *p = data;\r\nint i;\r\nswitch (stringset) {\r\ncase ETH_SS_TEST:\r\nmemcpy(data, *igb_gstrings_test,\r\nIGB_TEST_LEN*ETH_GSTRING_LEN);\r\nbreak;\r\ncase ETH_SS_STATS:\r\nfor (i = 0; i < IGB_GLOBAL_STATS_LEN; i++) {\r\nmemcpy(p, igb_gstrings_stats[i].stat_string,\r\nETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\n}\r\nfor (i = 0; i < IGB_NETDEV_STATS_LEN; i++) {\r\nmemcpy(p, igb_gstrings_net_stats[i].stat_string,\r\nETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\n}\r\nfor (i = 0; i < adapter->num_tx_queues; i++) {\r\nsprintf(p, "tx_queue_%u_packets", i);\r\np += ETH_GSTRING_LEN;\r\nsprintf(p, "tx_queue_%u_bytes", i);\r\np += ETH_GSTRING_LEN;\r\nsprintf(p, "tx_queue_%u_restart", i);\r\np += ETH_GSTRING_LEN;\r\n}\r\nfor (i = 0; i < adapter->num_rx_queues; i++) {\r\nsprintf(p, "rx_queue_%u_packets", i);\r\np += ETH_GSTRING_LEN;\r\nsprintf(p, "rx_queue_%u_bytes", i);\r\np += ETH_GSTRING_LEN;\r\nsprintf(p, "rx_queue_%u_drops", i);\r\np += ETH_GSTRING_LEN;\r\nsprintf(p, "rx_queue_%u_csum_err", i);\r\np += ETH_GSTRING_LEN;\r\nsprintf(p, "rx_queue_%u_alloc_failed", i);\r\np += ETH_GSTRING_LEN;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int igb_get_ts_info(struct net_device *dev,\r\nstruct ethtool_ts_info *info)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(dev);\r\nif (adapter->ptp_clock)\r\ninfo->phc_index = ptp_clock_index(adapter->ptp_clock);\r\nelse\r\ninfo->phc_index = -1;\r\nswitch (adapter->hw.mac.type) {\r\ncase e1000_82575:\r\ninfo->so_timestamping =\r\nSOF_TIMESTAMPING_TX_SOFTWARE |\r\nSOF_TIMESTAMPING_RX_SOFTWARE |\r\nSOF_TIMESTAMPING_SOFTWARE;\r\nreturn 0;\r\ncase e1000_82576:\r\ncase e1000_82580:\r\ncase e1000_i350:\r\ncase e1000_i354:\r\ncase e1000_i210:\r\ncase e1000_i211:\r\ninfo->so_timestamping =\r\nSOF_TIMESTAMPING_TX_SOFTWARE |\r\nSOF_TIMESTAMPING_RX_SOFTWARE |\r\nSOF_TIMESTAMPING_SOFTWARE |\r\nSOF_TIMESTAMPING_TX_HARDWARE |\r\nSOF_TIMESTAMPING_RX_HARDWARE |\r\nSOF_TIMESTAMPING_RAW_HARDWARE;\r\ninfo->tx_types =\r\n(1 << HWTSTAMP_TX_OFF) |\r\n(1 << HWTSTAMP_TX_ON);\r\ninfo->rx_filters = 1 << HWTSTAMP_FILTER_NONE;\r\nif (adapter->hw.mac.type >= e1000_82580)\r\ninfo->rx_filters |= 1 << HWTSTAMP_FILTER_ALL;\r\nelse\r\ninfo->rx_filters |=\r\n(1 << HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |\r\n(1 << HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L2_SYNC) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_EVENT);\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int igb_get_rss_hash_opts(struct igb_adapter *adapter,\r\nstruct ethtool_rxnfc *cmd)\r\n{\r\ncmd->data = 0;\r\nswitch (cmd->flow_type) {\r\ncase TCP_V4_FLOW:\r\ncmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\ncase UDP_V4_FLOW:\r\nif (adapter->flags & IGB_FLAG_RSS_FIELD_IPV4_UDP)\r\ncmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\ncase SCTP_V4_FLOW:\r\ncase AH_ESP_V4_FLOW:\r\ncase AH_V4_FLOW:\r\ncase ESP_V4_FLOW:\r\ncase IPV4_FLOW:\r\ncmd->data |= RXH_IP_SRC | RXH_IP_DST;\r\nbreak;\r\ncase TCP_V6_FLOW:\r\ncmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\ncase UDP_V6_FLOW:\r\nif (adapter->flags & IGB_FLAG_RSS_FIELD_IPV6_UDP)\r\ncmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\ncase SCTP_V6_FLOW:\r\ncase AH_ESP_V6_FLOW:\r\ncase AH_V6_FLOW:\r\ncase ESP_V6_FLOW:\r\ncase IPV6_FLOW:\r\ncmd->data |= RXH_IP_SRC | RXH_IP_DST;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int igb_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,\r\nu32 *rule_locs)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(dev);\r\nint ret = -EOPNOTSUPP;\r\nswitch (cmd->cmd) {\r\ncase ETHTOOL_GRXRINGS:\r\ncmd->data = adapter->num_rx_queues;\r\nret = 0;\r\nbreak;\r\ncase ETHTOOL_GRXFH:\r\nret = igb_get_rss_hash_opts(adapter, cmd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int igb_set_rss_hash_opt(struct igb_adapter *adapter,\r\nstruct ethtool_rxnfc *nfc)\r\n{\r\nu32 flags = adapter->flags;\r\nif (nfc->data & ~(RXH_IP_SRC | RXH_IP_DST |\r\nRXH_L4_B_0_1 | RXH_L4_B_2_3))\r\nreturn -EINVAL;\r\nswitch (nfc->flow_type) {\r\ncase TCP_V4_FLOW:\r\ncase TCP_V6_FLOW:\r\nif (!(nfc->data & RXH_IP_SRC) ||\r\n!(nfc->data & RXH_IP_DST) ||\r\n!(nfc->data & RXH_L4_B_0_1) ||\r\n!(nfc->data & RXH_L4_B_2_3))\r\nreturn -EINVAL;\r\nbreak;\r\ncase UDP_V4_FLOW:\r\nif (!(nfc->data & RXH_IP_SRC) ||\r\n!(nfc->data & RXH_IP_DST))\r\nreturn -EINVAL;\r\nswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\r\ncase 0:\r\nflags &= ~IGB_FLAG_RSS_FIELD_IPV4_UDP;\r\nbreak;\r\ncase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\r\nflags |= IGB_FLAG_RSS_FIELD_IPV4_UDP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase UDP_V6_FLOW:\r\nif (!(nfc->data & RXH_IP_SRC) ||\r\n!(nfc->data & RXH_IP_DST))\r\nreturn -EINVAL;\r\nswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\r\ncase 0:\r\nflags &= ~IGB_FLAG_RSS_FIELD_IPV6_UDP;\r\nbreak;\r\ncase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\r\nflags |= IGB_FLAG_RSS_FIELD_IPV6_UDP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase AH_ESP_V4_FLOW:\r\ncase AH_V4_FLOW:\r\ncase ESP_V4_FLOW:\r\ncase SCTP_V4_FLOW:\r\ncase AH_ESP_V6_FLOW:\r\ncase AH_V6_FLOW:\r\ncase ESP_V6_FLOW:\r\ncase SCTP_V6_FLOW:\r\nif (!(nfc->data & RXH_IP_SRC) ||\r\n!(nfc->data & RXH_IP_DST) ||\r\n(nfc->data & RXH_L4_B_0_1) ||\r\n(nfc->data & RXH_L4_B_2_3))\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (flags != adapter->flags) {\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 mrqc = rd32(E1000_MRQC);\r\nif ((flags & UDP_RSS_FLAGS) &&\r\n!(adapter->flags & UDP_RSS_FLAGS))\r\ndev_err(&adapter->pdev->dev,\r\n"enabling UDP RSS: fragmented packets may arrive out of order to the stack above\n");\r\nadapter->flags = flags;\r\nmrqc |= E1000_MRQC_RSS_FIELD_IPV4 |\r\nE1000_MRQC_RSS_FIELD_IPV4_TCP |\r\nE1000_MRQC_RSS_FIELD_IPV6 |\r\nE1000_MRQC_RSS_FIELD_IPV6_TCP;\r\nmrqc &= ~(E1000_MRQC_RSS_FIELD_IPV4_UDP |\r\nE1000_MRQC_RSS_FIELD_IPV6_UDP);\r\nif (flags & IGB_FLAG_RSS_FIELD_IPV4_UDP)\r\nmrqc |= E1000_MRQC_RSS_FIELD_IPV4_UDP;\r\nif (flags & IGB_FLAG_RSS_FIELD_IPV6_UDP)\r\nmrqc |= E1000_MRQC_RSS_FIELD_IPV6_UDP;\r\nwr32(E1000_MRQC, mrqc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int igb_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(dev);\r\nint ret = -EOPNOTSUPP;\r\nswitch (cmd->cmd) {\r\ncase ETHTOOL_SRXFH:\r\nret = igb_set_rss_hash_opt(adapter, cmd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int igb_get_eee(struct net_device *netdev, struct ethtool_eee *edata)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 ret_val;\r\nu16 phy_data;\r\nif ((hw->mac.type < e1000_i350) ||\r\n(hw->phy.media_type != e1000_media_type_copper))\r\nreturn -EOPNOTSUPP;\r\nedata->supported = (SUPPORTED_1000baseT_Full |\r\nSUPPORTED_100baseT_Full);\r\nif (!hw->dev_spec._82575.eee_disable)\r\nedata->advertised =\r\nmmd_eee_adv_to_ethtool_adv_t(adapter->eee_advert);\r\nif (hw->mac.type == e1000_i354) {\r\nigb_get_eee_status_i354(hw, (bool *)&edata->eee_active);\r\n} else {\r\nu32 eeer;\r\neeer = rd32(E1000_EEER);\r\nif (eeer & E1000_EEER_EEE_NEG)\r\nedata->eee_active = true;\r\nif (eeer & E1000_EEER_TX_LPI_EN)\r\nedata->tx_lpi_enabled = true;\r\n}\r\nswitch (hw->mac.type) {\r\ncase e1000_i350:\r\nret_val = igb_read_emi_reg(hw, E1000_EEE_LP_ADV_ADDR_I350,\r\n&phy_data);\r\nif (ret_val)\r\nreturn -ENODATA;\r\nedata->lp_advertised = mmd_eee_adv_to_ethtool_adv_t(phy_data);\r\nbreak;\r\ncase e1000_i354:\r\ncase e1000_i210:\r\ncase e1000_i211:\r\nret_val = igb_read_xmdio_reg(hw, E1000_EEE_LP_ADV_ADDR_I210,\r\nE1000_EEE_LP_ADV_DEV_I210,\r\n&phy_data);\r\nif (ret_val)\r\nreturn -ENODATA;\r\nedata->lp_advertised = mmd_eee_adv_to_ethtool_adv_t(phy_data);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nedata->eee_enabled = !hw->dev_spec._82575.eee_disable;\r\nif ((hw->mac.type == e1000_i354) &&\r\n(edata->eee_enabled))\r\nedata->tx_lpi_enabled = true;\r\nif (adapter->link_duplex == HALF_DUPLEX) {\r\nedata->eee_enabled = false;\r\nedata->eee_active = false;\r\nedata->tx_lpi_enabled = false;\r\nedata->advertised &= ~edata->advertised;\r\n}\r\nreturn 0;\r\n}\r\nstatic int igb_set_eee(struct net_device *netdev,\r\nstruct ethtool_eee *edata)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct ethtool_eee eee_curr;\r\ns32 ret_val;\r\nif ((hw->mac.type < e1000_i350) ||\r\n(hw->phy.media_type != e1000_media_type_copper))\r\nreturn -EOPNOTSUPP;\r\nmemset(&eee_curr, 0, sizeof(struct ethtool_eee));\r\nret_val = igb_get_eee(netdev, &eee_curr);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (eee_curr.eee_enabled) {\r\nif (eee_curr.tx_lpi_enabled != edata->tx_lpi_enabled) {\r\ndev_err(&adapter->pdev->dev,\r\n"Setting EEE tx-lpi is not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (edata->tx_lpi_timer) {\r\ndev_err(&adapter->pdev->dev,\r\n"Setting EEE Tx LPI timer is not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (edata->advertised &\r\n~(ADVERTISE_100_FULL | ADVERTISE_1000_FULL)) {\r\ndev_err(&adapter->pdev->dev,\r\n"EEE Advertisement supports only 100Tx and or 100T full duplex\n");\r\nreturn -EINVAL;\r\n}\r\n} else if (!edata->eee_enabled) {\r\ndev_err(&adapter->pdev->dev,\r\n"Setting EEE options are not supported with EEE disabled\n");\r\nreturn -EINVAL;\r\n}\r\nadapter->eee_advert = ethtool_adv_to_mmd_eee_adv_t(edata->advertised);\r\nif (hw->dev_spec._82575.eee_disable != !edata->eee_enabled) {\r\nhw->dev_spec._82575.eee_disable = !edata->eee_enabled;\r\nadapter->flags |= IGB_FLAG_EEE;\r\nif (hw->mac.type == e1000_i350)\r\nigb_set_eee_i350(hw);\r\nelse\r\nigb_set_eee_i354(hw);\r\nif (netif_running(netdev))\r\nigb_reinit_locked(adapter);\r\nelse\r\nigb_reset(adapter);\r\n}\r\nreturn 0;\r\n}\r\nstatic int igb_get_module_info(struct net_device *netdev,\r\nstruct ethtool_modinfo *modinfo)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 status = 0;\r\nu16 sff8472_rev, addr_mode;\r\nbool page_swap = false;\r\nif ((hw->phy.media_type == e1000_media_type_copper) ||\r\n(hw->phy.media_type == e1000_media_type_unknown))\r\nreturn -EOPNOTSUPP;\r\nstatus = igb_read_phy_reg_i2c(hw, IGB_SFF_8472_COMP, &sff8472_rev);\r\nif (status)\r\nreturn -EIO;\r\nstatus = igb_read_phy_reg_i2c(hw, IGB_SFF_8472_SWAP, &addr_mode);\r\nif (status)\r\nreturn -EIO;\r\nif ((addr_mode & 0xFF) & IGB_SFF_ADDRESSING_MODE) {\r\nhw_dbg("Address change required to access page 0xA2, but not supported. Please report the module type to the driver maintainers.\n");\r\npage_swap = true;\r\n}\r\nif ((sff8472_rev & 0xFF) == IGB_SFF_8472_UNSUP || page_swap) {\r\nmodinfo->type = ETH_MODULE_SFF_8079;\r\nmodinfo->eeprom_len = ETH_MODULE_SFF_8079_LEN;\r\n} else {\r\nmodinfo->type = ETH_MODULE_SFF_8472;\r\nmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int igb_get_module_eeprom(struct net_device *netdev,\r\nstruct ethtool_eeprom *ee, u8 *data)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 status = 0;\r\nu16 *dataword;\r\nu16 first_word, last_word;\r\nint i = 0;\r\nif (ee->len == 0)\r\nreturn -EINVAL;\r\nfirst_word = ee->offset >> 1;\r\nlast_word = (ee->offset + ee->len - 1) >> 1;\r\ndataword = kmalloc(sizeof(u16) * (last_word - first_word + 1),\r\nGFP_KERNEL);\r\nif (!dataword)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < last_word - first_word + 1; i++) {\r\nstatus = igb_read_phy_reg_i2c(hw, first_word + i, &dataword[i]);\r\nif (status) {\r\nkfree(dataword);\r\nreturn -EIO;\r\n}\r\nbe16_to_cpus(&dataword[i]);\r\n}\r\nmemcpy(data, (u8 *)dataword + (ee->offset & 1), ee->len);\r\nkfree(dataword);\r\nreturn 0;\r\n}\r\nstatic int igb_ethtool_begin(struct net_device *netdev)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\npm_runtime_get_sync(&adapter->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic void igb_ethtool_complete(struct net_device *netdev)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\npm_runtime_put(&adapter->pdev->dev);\r\n}\r\nstatic u32 igb_get_rxfh_indir_size(struct net_device *netdev)\r\n{\r\nreturn IGB_RETA_SIZE;\r\n}\r\nstatic int igb_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nint i;\r\nfor (i = 0; i < IGB_RETA_SIZE; i++)\r\nindir[i] = adapter->rss_indir_tbl[i];\r\nreturn 0;\r\n}\r\nvoid igb_write_rss_indir_tbl(struct igb_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 reg = E1000_RETA(0);\r\nu32 shift = 0;\r\nint i = 0;\r\nswitch (hw->mac.type) {\r\ncase e1000_82575:\r\nshift = 6;\r\nbreak;\r\ncase e1000_82576:\r\nif (adapter->vfs_allocated_count)\r\nshift = 3;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwhile (i < IGB_RETA_SIZE) {\r\nu32 val = 0;\r\nint j;\r\nfor (j = 3; j >= 0; j--) {\r\nval <<= 8;\r\nval |= adapter->rss_indir_tbl[i + j];\r\n}\r\nwr32(reg, val << shift);\r\nreg += 4;\r\ni += 4;\r\n}\r\n}\r\nstatic int igb_set_rxfh(struct net_device *netdev, const u32 *indir,\r\nconst u8 *key)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nint i;\r\nu32 num_queues;\r\nnum_queues = adapter->rss_queues;\r\nswitch (hw->mac.type) {\r\ncase e1000_82576:\r\nif (adapter->vfs_allocated_count)\r\nnum_queues = 2;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfor (i = 0; i < IGB_RETA_SIZE; i++)\r\nif (indir[i] >= num_queues)\r\nreturn -EINVAL;\r\nfor (i = 0; i < IGB_RETA_SIZE; i++)\r\nadapter->rss_indir_tbl[i] = indir[i];\r\nigb_write_rss_indir_tbl(adapter);\r\nreturn 0;\r\n}\r\nstatic unsigned int igb_max_channels(struct igb_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nunsigned int max_combined = 0;\r\nswitch (hw->mac.type) {\r\ncase e1000_i211:\r\nmax_combined = IGB_MAX_RX_QUEUES_I211;\r\nbreak;\r\ncase e1000_82575:\r\ncase e1000_i210:\r\nmax_combined = IGB_MAX_RX_QUEUES_82575;\r\nbreak;\r\ncase e1000_i350:\r\nif (!!adapter->vfs_allocated_count) {\r\nmax_combined = 1;\r\nbreak;\r\n}\r\ncase e1000_82576:\r\nif (!!adapter->vfs_allocated_count) {\r\nmax_combined = 2;\r\nbreak;\r\n}\r\ncase e1000_82580:\r\ncase e1000_i354:\r\ndefault:\r\nmax_combined = IGB_MAX_RX_QUEUES;\r\nbreak;\r\n}\r\nreturn max_combined;\r\n}\r\nstatic void igb_get_channels(struct net_device *netdev,\r\nstruct ethtool_channels *ch)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nch->max_combined = igb_max_channels(adapter);\r\nif (adapter->flags & IGB_FLAG_HAS_MSIX) {\r\nch->max_other = NON_Q_VECTORS;\r\nch->other_count = NON_Q_VECTORS;\r\n}\r\nch->combined_count = adapter->rss_queues;\r\n}\r\nstatic int igb_set_channels(struct net_device *netdev,\r\nstruct ethtool_channels *ch)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nunsigned int count = ch->combined_count;\r\nif (!count || ch->rx_count || ch->tx_count)\r\nreturn -EINVAL;\r\nif (ch->other_count != NON_Q_VECTORS)\r\nreturn -EINVAL;\r\nif (count > igb_max_channels(adapter))\r\nreturn -EINVAL;\r\nif (count != adapter->rss_queues) {\r\nadapter->rss_queues = count;\r\nreturn igb_reinit_queues(adapter);\r\n}\r\nreturn 0;\r\n}\r\nvoid igb_set_ethtool_ops(struct net_device *netdev)\r\n{\r\nnetdev->ethtool_ops = &igb_ethtool_ops;\r\n}
