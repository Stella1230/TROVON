void inet_sock_destruct(struct sock *sk)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\n__skb_queue_purge(&sk->sk_receive_queue);\r\n__skb_queue_purge(&sk->sk_error_queue);\r\nsk_mem_reclaim(sk);\r\nif (sk->sk_type == SOCK_STREAM && sk->sk_state != TCP_CLOSE) {\r\npr_err("Attempt to release TCP socket in state %d %p\n",\r\nsk->sk_state, sk);\r\nreturn;\r\n}\r\nif (!sock_flag(sk, SOCK_DEAD)) {\r\npr_err("Attempt to release alive inet socket %p\n", sk);\r\nreturn;\r\n}\r\nWARN_ON(atomic_read(&sk->sk_rmem_alloc));\r\nWARN_ON(atomic_read(&sk->sk_wmem_alloc));\r\nWARN_ON(sk->sk_wmem_queued);\r\nWARN_ON(sk->sk_forward_alloc);\r\nkfree(rcu_dereference_protected(inet->inet_opt, 1));\r\ndst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\r\ndst_release(sk->sk_rx_dst);\r\nsk_refcnt_debug_dec(sk);\r\n}\r\nstatic int inet_autobind(struct sock *sk)\r\n{\r\nstruct inet_sock *inet;\r\nlock_sock(sk);\r\ninet = inet_sk(sk);\r\nif (!inet->inet_num) {\r\nif (sk->sk_prot->get_port(sk, 0)) {\r\nrelease_sock(sk);\r\nreturn -EAGAIN;\r\n}\r\ninet->inet_sport = htons(inet->inet_num);\r\n}\r\nrelease_sock(sk);\r\nreturn 0;\r\n}\r\nint inet_listen(struct socket *sock, int backlog)\r\n{\r\nstruct sock *sk = sock->sk;\r\nunsigned char old_state;\r\nint err;\r\nlock_sock(sk);\r\nerr = -EINVAL;\r\nif (sock->state != SS_UNCONNECTED || sock->type != SOCK_STREAM)\r\ngoto out;\r\nold_state = sk->sk_state;\r\nif (!((1 << old_state) & (TCPF_CLOSE | TCPF_LISTEN)))\r\ngoto out;\r\nif (old_state != TCP_LISTEN) {\r\nif ((sysctl_tcp_fastopen & TFO_SERVER_ENABLE) != 0 &&\r\ninet_csk(sk)->icsk_accept_queue.fastopenq == NULL) {\r\nif ((sysctl_tcp_fastopen & TFO_SERVER_WO_SOCKOPT1) != 0)\r\nerr = fastopen_init_queue(sk, backlog);\r\nelse if ((sysctl_tcp_fastopen &\r\nTFO_SERVER_WO_SOCKOPT2) != 0)\r\nerr = fastopen_init_queue(sk,\r\n((uint)sysctl_tcp_fastopen) >> 16);\r\nelse\r\nerr = 0;\r\nif (err)\r\ngoto out;\r\n}\r\nerr = inet_csk_listen_start(sk, backlog);\r\nif (err)\r\ngoto out;\r\n}\r\nsk->sk_max_ack_backlog = backlog;\r\nerr = 0;\r\nout:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int inet_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct sock *sk;\r\nstruct inet_protosw *answer;\r\nstruct inet_sock *inet;\r\nstruct proto *answer_prot;\r\nunsigned char answer_flags;\r\nint try_loading_module = 0;\r\nint err;\r\nsock->state = SS_UNCONNECTED;\r\nlookup_protocol:\r\nerr = -ESOCKTNOSUPPORT;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(answer, &inetsw[sock->type], list) {\r\nerr = 0;\r\nif (protocol == answer->protocol) {\r\nif (protocol != IPPROTO_IP)\r\nbreak;\r\n} else {\r\nif (IPPROTO_IP == protocol) {\r\nprotocol = answer->protocol;\r\nbreak;\r\n}\r\nif (IPPROTO_IP == answer->protocol)\r\nbreak;\r\n}\r\nerr = -EPROTONOSUPPORT;\r\n}\r\nif (unlikely(err)) {\r\nif (try_loading_module < 2) {\r\nrcu_read_unlock();\r\nif (++try_loading_module == 1)\r\nrequest_module("net-pf-%d-proto-%d-type-%d",\r\nPF_INET, protocol, sock->type);\r\nelse\r\nrequest_module("net-pf-%d-proto-%d",\r\nPF_INET, protocol);\r\ngoto lookup_protocol;\r\n} else\r\ngoto out_rcu_unlock;\r\n}\r\nerr = -EPERM;\r\nif (sock->type == SOCK_RAW && !kern &&\r\n!ns_capable(net->user_ns, CAP_NET_RAW))\r\ngoto out_rcu_unlock;\r\nsock->ops = answer->ops;\r\nanswer_prot = answer->prot;\r\nanswer_flags = answer->flags;\r\nrcu_read_unlock();\r\nWARN_ON(answer_prot->slab == NULL);\r\nerr = -ENOBUFS;\r\nsk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot);\r\nif (sk == NULL)\r\ngoto out;\r\nerr = 0;\r\nif (INET_PROTOSW_REUSE & answer_flags)\r\nsk->sk_reuse = SK_CAN_REUSE;\r\ninet = inet_sk(sk);\r\ninet->is_icsk = (INET_PROTOSW_ICSK & answer_flags) != 0;\r\ninet->nodefrag = 0;\r\nif (SOCK_RAW == sock->type) {\r\ninet->inet_num = protocol;\r\nif (IPPROTO_RAW == protocol)\r\ninet->hdrincl = 1;\r\n}\r\nif (net->ipv4.sysctl_ip_no_pmtu_disc)\r\ninet->pmtudisc = IP_PMTUDISC_DONT;\r\nelse\r\ninet->pmtudisc = IP_PMTUDISC_WANT;\r\ninet->inet_id = 0;\r\nsock_init_data(sock, sk);\r\nsk->sk_destruct = inet_sock_destruct;\r\nsk->sk_protocol = protocol;\r\nsk->sk_backlog_rcv = sk->sk_prot->backlog_rcv;\r\ninet->uc_ttl = -1;\r\ninet->mc_loop = 1;\r\ninet->mc_ttl = 1;\r\ninet->mc_all = 1;\r\ninet->mc_index = 0;\r\ninet->mc_list = NULL;\r\ninet->rcv_tos = 0;\r\nsk_refcnt_debug_inc(sk);\r\nif (inet->inet_num) {\r\ninet->inet_sport = htons(inet->inet_num);\r\nsk->sk_prot->hash(sk);\r\n}\r\nif (sk->sk_prot->init) {\r\nerr = sk->sk_prot->init(sk);\r\nif (err)\r\nsk_common_release(sk);\r\n}\r\nout:\r\nreturn err;\r\nout_rcu_unlock:\r\nrcu_read_unlock();\r\ngoto out;\r\n}\r\nint inet_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nif (sk) {\r\nlong timeout;\r\nsock_rps_reset_flow(sk);\r\nip_mc_drop_socket(sk);\r\ntimeout = 0;\r\nif (sock_flag(sk, SOCK_LINGER) &&\r\n!(current->flags & PF_EXITING))\r\ntimeout = sk->sk_lingertime;\r\nsock->sk = NULL;\r\nsk->sk_prot->close(sk, timeout);\r\n}\r\nreturn 0;\r\n}\r\nint inet_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\r\n{\r\nstruct sockaddr_in *addr = (struct sockaddr_in *)uaddr;\r\nstruct sock *sk = sock->sk;\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct net *net = sock_net(sk);\r\nunsigned short snum;\r\nint chk_addr_ret;\r\nint err;\r\nif (sk->sk_prot->bind) {\r\nerr = sk->sk_prot->bind(sk, uaddr, addr_len);\r\ngoto out;\r\n}\r\nerr = -EINVAL;\r\nif (addr_len < sizeof(struct sockaddr_in))\r\ngoto out;\r\nif (addr->sin_family != AF_INET) {\r\nerr = -EAFNOSUPPORT;\r\nif (addr->sin_family != AF_UNSPEC ||\r\naddr->sin_addr.s_addr != htonl(INADDR_ANY))\r\ngoto out;\r\n}\r\nchk_addr_ret = inet_addr_type(net, addr->sin_addr.s_addr);\r\nerr = -EADDRNOTAVAIL;\r\nif (!sysctl_ip_nonlocal_bind &&\r\n!(inet->freebind || inet->transparent) &&\r\naddr->sin_addr.s_addr != htonl(INADDR_ANY) &&\r\nchk_addr_ret != RTN_LOCAL &&\r\nchk_addr_ret != RTN_MULTICAST &&\r\nchk_addr_ret != RTN_BROADCAST)\r\ngoto out;\r\nsnum = ntohs(addr->sin_port);\r\nerr = -EACCES;\r\nif (snum && snum < PROT_SOCK &&\r\n!ns_capable(net->user_ns, CAP_NET_BIND_SERVICE))\r\ngoto out;\r\nlock_sock(sk);\r\nerr = -EINVAL;\r\nif (sk->sk_state != TCP_CLOSE || inet->inet_num)\r\ngoto out_release_sock;\r\ninet->inet_rcv_saddr = inet->inet_saddr = addr->sin_addr.s_addr;\r\nif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\r\ninet->inet_saddr = 0;\r\nif (sk->sk_prot->get_port(sk, snum)) {\r\ninet->inet_saddr = inet->inet_rcv_saddr = 0;\r\nerr = -EADDRINUSE;\r\ngoto out_release_sock;\r\n}\r\nif (inet->inet_rcv_saddr)\r\nsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\r\nif (snum)\r\nsk->sk_userlocks |= SOCK_BINDPORT_LOCK;\r\ninet->inet_sport = htons(inet->inet_num);\r\ninet->inet_daddr = 0;\r\ninet->inet_dport = 0;\r\nsk_dst_reset(sk);\r\nerr = 0;\r\nout_release_sock:\r\nrelease_sock(sk);\r\nout:\r\nreturn err;\r\n}\r\nint inet_dgram_connect(struct socket *sock, struct sockaddr *uaddr,\r\nint addr_len, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nif (addr_len < sizeof(uaddr->sa_family))\r\nreturn -EINVAL;\r\nif (uaddr->sa_family == AF_UNSPEC)\r\nreturn sk->sk_prot->disconnect(sk, flags);\r\nif (!inet_sk(sk)->inet_num && inet_autobind(sk))\r\nreturn -EAGAIN;\r\nreturn sk->sk_prot->connect(sk, uaddr, addr_len);\r\n}\r\nstatic long inet_wait_for_connect(struct sock *sk, long timeo, int writebias)\r\n{\r\nDEFINE_WAIT(wait);\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\nsk->sk_write_pending += writebias;\r\nwhile ((1 << sk->sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV)) {\r\nrelease_sock(sk);\r\ntimeo = schedule_timeout(timeo);\r\nlock_sock(sk);\r\nif (signal_pending(current) || !timeo)\r\nbreak;\r\nprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\r\n}\r\nfinish_wait(sk_sleep(sk), &wait);\r\nsk->sk_write_pending -= writebias;\r\nreturn timeo;\r\n}\r\nint __inet_stream_connect(struct socket *sock, struct sockaddr *uaddr,\r\nint addr_len, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint err;\r\nlong timeo;\r\nif (addr_len < sizeof(uaddr->sa_family))\r\nreturn -EINVAL;\r\nif (uaddr->sa_family == AF_UNSPEC) {\r\nerr = sk->sk_prot->disconnect(sk, flags);\r\nsock->state = err ? SS_DISCONNECTING : SS_UNCONNECTED;\r\ngoto out;\r\n}\r\nswitch (sock->state) {\r\ndefault:\r\nerr = -EINVAL;\r\ngoto out;\r\ncase SS_CONNECTED:\r\nerr = -EISCONN;\r\ngoto out;\r\ncase SS_CONNECTING:\r\nerr = -EALREADY;\r\nbreak;\r\ncase SS_UNCONNECTED:\r\nerr = -EISCONN;\r\nif (sk->sk_state != TCP_CLOSE)\r\ngoto out;\r\nerr = sk->sk_prot->connect(sk, uaddr, addr_len);\r\nif (err < 0)\r\ngoto out;\r\nsock->state = SS_CONNECTING;\r\nerr = -EINPROGRESS;\r\nbreak;\r\n}\r\ntimeo = sock_sndtimeo(sk, flags & O_NONBLOCK);\r\nif ((1 << sk->sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV)) {\r\nint writebias = (sk->sk_protocol == IPPROTO_TCP) &&\r\ntcp_sk(sk)->fastopen_req &&\r\ntcp_sk(sk)->fastopen_req->data ? 1 : 0;\r\nif (!timeo || !inet_wait_for_connect(sk, timeo, writebias))\r\ngoto out;\r\nerr = sock_intr_errno(timeo);\r\nif (signal_pending(current))\r\ngoto out;\r\n}\r\nif (sk->sk_state == TCP_CLOSE)\r\ngoto sock_error;\r\nsock->state = SS_CONNECTED;\r\nerr = 0;\r\nout:\r\nreturn err;\r\nsock_error:\r\nerr = sock_error(sk) ? : -ECONNABORTED;\r\nsock->state = SS_UNCONNECTED;\r\nif (sk->sk_prot->disconnect(sk, flags))\r\nsock->state = SS_DISCONNECTING;\r\ngoto out;\r\n}\r\nint inet_stream_connect(struct socket *sock, struct sockaddr *uaddr,\r\nint addr_len, int flags)\r\n{\r\nint err;\r\nlock_sock(sock->sk);\r\nerr = __inet_stream_connect(sock, uaddr, addr_len, flags);\r\nrelease_sock(sock->sk);\r\nreturn err;\r\n}\r\nint inet_accept(struct socket *sock, struct socket *newsock, int flags)\r\n{\r\nstruct sock *sk1 = sock->sk;\r\nint err = -EINVAL;\r\nstruct sock *sk2 = sk1->sk_prot->accept(sk1, flags, &err);\r\nif (!sk2)\r\ngoto do_err;\r\nlock_sock(sk2);\r\nsock_rps_record_flow(sk2);\r\nWARN_ON(!((1 << sk2->sk_state) &\r\n(TCPF_ESTABLISHED | TCPF_SYN_RECV |\r\nTCPF_CLOSE_WAIT | TCPF_CLOSE)));\r\nsock_graft(sk2, newsock);\r\nnewsock->state = SS_CONNECTED;\r\nerr = 0;\r\nrelease_sock(sk2);\r\ndo_err:\r\nreturn err;\r\n}\r\nint inet_getname(struct socket *sock, struct sockaddr *uaddr,\r\nint *uaddr_len, int peer)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct inet_sock *inet = inet_sk(sk);\r\nDECLARE_SOCKADDR(struct sockaddr_in *, sin, uaddr);\r\nsin->sin_family = AF_INET;\r\nif (peer) {\r\nif (!inet->inet_dport ||\r\n(((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_SYN_SENT)) &&\r\npeer == 1))\r\nreturn -ENOTCONN;\r\nsin->sin_port = inet->inet_dport;\r\nsin->sin_addr.s_addr = inet->inet_daddr;\r\n} else {\r\n__be32 addr = inet->inet_rcv_saddr;\r\nif (!addr)\r\naddr = inet->inet_saddr;\r\nsin->sin_port = inet->inet_sport;\r\nsin->sin_addr.s_addr = addr;\r\n}\r\nmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\r\n*uaddr_len = sizeof(*sin);\r\nreturn 0;\r\n}\r\nint inet_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\r\nsize_t size)\r\n{\r\nstruct sock *sk = sock->sk;\r\nsock_rps_record_flow(sk);\r\nif (!inet_sk(sk)->inet_num && !sk->sk_prot->no_autobind &&\r\ninet_autobind(sk))\r\nreturn -EAGAIN;\r\nreturn sk->sk_prot->sendmsg(iocb, sk, msg, size);\r\n}\r\nssize_t inet_sendpage(struct socket *sock, struct page *page, int offset,\r\nsize_t size, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nsock_rps_record_flow(sk);\r\nif (!inet_sk(sk)->inet_num && !sk->sk_prot->no_autobind &&\r\ninet_autobind(sk))\r\nreturn -EAGAIN;\r\nif (sk->sk_prot->sendpage)\r\nreturn sk->sk_prot->sendpage(sk, page, offset, size, flags);\r\nreturn sock_no_sendpage(sock, page, offset, size, flags);\r\n}\r\nint inet_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\r\nsize_t size, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint addr_len = 0;\r\nint err;\r\nsock_rps_record_flow(sk);\r\nerr = sk->sk_prot->recvmsg(iocb, sk, msg, size, flags & MSG_DONTWAIT,\r\nflags & ~MSG_DONTWAIT, &addr_len);\r\nif (err >= 0)\r\nmsg->msg_namelen = addr_len;\r\nreturn err;\r\n}\r\nint inet_shutdown(struct socket *sock, int how)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint err = 0;\r\nhow++;\r\nif ((how & ~SHUTDOWN_MASK) || !how)\r\nreturn -EINVAL;\r\nlock_sock(sk);\r\nif (sock->state == SS_CONNECTING) {\r\nif ((1 << sk->sk_state) &\r\n(TCPF_SYN_SENT | TCPF_SYN_RECV | TCPF_CLOSE))\r\nsock->state = SS_DISCONNECTING;\r\nelse\r\nsock->state = SS_CONNECTED;\r\n}\r\nswitch (sk->sk_state) {\r\ncase TCP_CLOSE:\r\nerr = -ENOTCONN;\r\ndefault:\r\nsk->sk_shutdown |= how;\r\nif (sk->sk_prot->shutdown)\r\nsk->sk_prot->shutdown(sk, how);\r\nbreak;\r\ncase TCP_LISTEN:\r\nif (!(how & RCV_SHUTDOWN))\r\nbreak;\r\ncase TCP_SYN_SENT:\r\nerr = sk->sk_prot->disconnect(sk, O_NONBLOCK);\r\nsock->state = err ? SS_DISCONNECTING : SS_UNCONNECTED;\r\nbreak;\r\n}\r\nsk->sk_state_change(sk);\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nint inet_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint err = 0;\r\nstruct net *net = sock_net(sk);\r\nswitch (cmd) {\r\ncase SIOCGSTAMP:\r\nerr = sock_get_timestamp(sk, (struct timeval __user *)arg);\r\nbreak;\r\ncase SIOCGSTAMPNS:\r\nerr = sock_get_timestampns(sk, (struct timespec __user *)arg);\r\nbreak;\r\ncase SIOCADDRT:\r\ncase SIOCDELRT:\r\ncase SIOCRTMSG:\r\nerr = ip_rt_ioctl(net, cmd, (void __user *)arg);\r\nbreak;\r\ncase SIOCDARP:\r\ncase SIOCGARP:\r\ncase SIOCSARP:\r\nerr = arp_ioctl(net, cmd, (void __user *)arg);\r\nbreak;\r\ncase SIOCGIFADDR:\r\ncase SIOCSIFADDR:\r\ncase SIOCGIFBRDADDR:\r\ncase SIOCSIFBRDADDR:\r\ncase SIOCGIFNETMASK:\r\ncase SIOCSIFNETMASK:\r\ncase SIOCGIFDSTADDR:\r\ncase SIOCSIFDSTADDR:\r\ncase SIOCSIFPFLAGS:\r\ncase SIOCGIFPFLAGS:\r\ncase SIOCSIFFLAGS:\r\nerr = devinet_ioctl(net, cmd, (void __user *)arg);\r\nbreak;\r\ndefault:\r\nif (sk->sk_prot->ioctl)\r\nerr = sk->sk_prot->ioctl(sk, cmd, arg);\r\nelse\r\nerr = -ENOIOCTLCMD;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int inet_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct sock *sk = sock->sk;\r\nint err = -ENOIOCTLCMD;\r\nif (sk->sk_prot->compat_ioctl)\r\nerr = sk->sk_prot->compat_ioctl(sk, cmd, arg);\r\nreturn err;\r\n}\r\nvoid inet_register_protosw(struct inet_protosw *p)\r\n{\r\nstruct list_head *lh;\r\nstruct inet_protosw *answer;\r\nint protocol = p->protocol;\r\nstruct list_head *last_perm;\r\nspin_lock_bh(&inetsw_lock);\r\nif (p->type >= SOCK_MAX)\r\ngoto out_illegal;\r\nanswer = NULL;\r\nlast_perm = &inetsw[p->type];\r\nlist_for_each(lh, &inetsw[p->type]) {\r\nanswer = list_entry(lh, struct inet_protosw, list);\r\nif (INET_PROTOSW_PERMANENT & answer->flags) {\r\nif (protocol == answer->protocol)\r\nbreak;\r\nlast_perm = lh;\r\n}\r\nanswer = NULL;\r\n}\r\nif (answer)\r\ngoto out_permanent;\r\nlist_add_rcu(&p->list, last_perm);\r\nout:\r\nspin_unlock_bh(&inetsw_lock);\r\nreturn;\r\nout_permanent:\r\npr_err("Attempt to override permanent protocol %d\n", protocol);\r\ngoto out;\r\nout_illegal:\r\npr_err("Ignoring attempt to register invalid socket type %d\n",\r\np->type);\r\ngoto out;\r\n}\r\nvoid inet_unregister_protosw(struct inet_protosw *p)\r\n{\r\nif (INET_PROTOSW_PERMANENT & p->flags) {\r\npr_err("Attempt to unregister permanent protocol %d\n",\r\np->protocol);\r\n} else {\r\nspin_lock_bh(&inetsw_lock);\r\nlist_del_rcu(&p->list);\r\nspin_unlock_bh(&inetsw_lock);\r\nsynchronize_net();\r\n}\r\n}\r\nstatic int inet_sk_reselect_saddr(struct sock *sk)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\n__be32 old_saddr = inet->inet_saddr;\r\n__be32 daddr = inet->inet_daddr;\r\nstruct flowi4 *fl4;\r\nstruct rtable *rt;\r\n__be32 new_saddr;\r\nstruct ip_options_rcu *inet_opt;\r\ninet_opt = rcu_dereference_protected(inet->inet_opt,\r\nsock_owned_by_user(sk));\r\nif (inet_opt && inet_opt->opt.srr)\r\ndaddr = inet_opt->opt.faddr;\r\nfl4 = &inet->cork.fl.u.ip4;\r\nrt = ip_route_connect(fl4, daddr, 0, RT_CONN_FLAGS(sk),\r\nsk->sk_bound_dev_if, sk->sk_protocol,\r\ninet->inet_sport, inet->inet_dport, sk);\r\nif (IS_ERR(rt))\r\nreturn PTR_ERR(rt);\r\nsk_setup_caps(sk, &rt->dst);\r\nnew_saddr = fl4->saddr;\r\nif (new_saddr == old_saddr)\r\nreturn 0;\r\nif (sysctl_ip_dynaddr > 1) {\r\npr_info("%s(): shifting inet->saddr from %pI4 to %pI4\n",\r\n__func__, &old_saddr, &new_saddr);\r\n}\r\ninet->inet_saddr = inet->inet_rcv_saddr = new_saddr;\r\n__sk_prot_rehash(sk);\r\nreturn 0;\r\n}\r\nint inet_sk_rebuild_header(struct sock *sk)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);\r\n__be32 daddr;\r\nstruct ip_options_rcu *inet_opt;\r\nstruct flowi4 *fl4;\r\nint err;\r\nif (rt)\r\nreturn 0;\r\nrcu_read_lock();\r\ninet_opt = rcu_dereference(inet->inet_opt);\r\ndaddr = inet->inet_daddr;\r\nif (inet_opt && inet_opt->opt.srr)\r\ndaddr = inet_opt->opt.faddr;\r\nrcu_read_unlock();\r\nfl4 = &inet->cork.fl.u.ip4;\r\nrt = ip_route_output_ports(sock_net(sk), fl4, sk, daddr, inet->inet_saddr,\r\ninet->inet_dport, inet->inet_sport,\r\nsk->sk_protocol, RT_CONN_FLAGS(sk),\r\nsk->sk_bound_dev_if);\r\nif (!IS_ERR(rt)) {\r\nerr = 0;\r\nsk_setup_caps(sk, &rt->dst);\r\n} else {\r\nerr = PTR_ERR(rt);\r\nsk->sk_route_caps = 0;\r\nif (!sysctl_ip_dynaddr ||\r\nsk->sk_state != TCP_SYN_SENT ||\r\n(sk->sk_userlocks & SOCK_BINDADDR_LOCK) ||\r\n(err = inet_sk_reselect_saddr(sk)) != 0)\r\nsk->sk_err_soft = -err;\r\n}\r\nreturn err;\r\n}\r\nstatic int inet_gso_send_check(struct sk_buff *skb)\r\n{\r\nconst struct net_offload *ops;\r\nconst struct iphdr *iph;\r\nint proto;\r\nint ihl;\r\nint err = -EINVAL;\r\nif (unlikely(!pskb_may_pull(skb, sizeof(*iph))))\r\ngoto out;\r\niph = ip_hdr(skb);\r\nihl = iph->ihl * 4;\r\nif (ihl < sizeof(*iph))\r\ngoto out;\r\nproto = iph->protocol;\r\nif (unlikely(!pskb_may_pull(skb, ihl)))\r\ngoto out;\r\n__skb_pull(skb, ihl);\r\nskb_reset_transport_header(skb);\r\nerr = -EPROTONOSUPPORT;\r\nops = rcu_dereference(inet_offloads[proto]);\r\nif (likely(ops && ops->callbacks.gso_send_check))\r\nerr = ops->callbacks.gso_send_check(skb);\r\nout:\r\nreturn err;\r\n}\r\nstatic struct sk_buff *inet_gso_segment(struct sk_buff *skb,\r\nnetdev_features_t features)\r\n{\r\nstruct sk_buff *segs = ERR_PTR(-EINVAL);\r\nconst struct net_offload *ops;\r\nunsigned int offset = 0;\r\nbool udpfrag, encap;\r\nstruct iphdr *iph;\r\nint proto;\r\nint nhoff;\r\nint ihl;\r\nint id;\r\nif (unlikely(skb_shinfo(skb)->gso_type &\r\n~(SKB_GSO_TCPV4 |\r\nSKB_GSO_UDP |\r\nSKB_GSO_DODGY |\r\nSKB_GSO_TCP_ECN |\r\nSKB_GSO_GRE |\r\nSKB_GSO_GRE_CSUM |\r\nSKB_GSO_IPIP |\r\nSKB_GSO_SIT |\r\nSKB_GSO_TCPV6 |\r\nSKB_GSO_UDP_TUNNEL |\r\nSKB_GSO_UDP_TUNNEL_CSUM |\r\nSKB_GSO_MPLS |\r\n0)))\r\ngoto out;\r\nskb_reset_network_header(skb);\r\nnhoff = skb_network_header(skb) - skb_mac_header(skb);\r\nif (unlikely(!pskb_may_pull(skb, sizeof(*iph))))\r\ngoto out;\r\niph = ip_hdr(skb);\r\nihl = iph->ihl * 4;\r\nif (ihl < sizeof(*iph))\r\ngoto out;\r\nid = ntohs(iph->id);\r\nproto = iph->protocol;\r\nif (unlikely(!pskb_may_pull(skb, ihl)))\r\ngoto out;\r\n__skb_pull(skb, ihl);\r\nencap = SKB_GSO_CB(skb)->encap_level > 0;\r\nif (encap)\r\nfeatures = skb->dev->hw_enc_features & netif_skb_features(skb);\r\nSKB_GSO_CB(skb)->encap_level += ihl;\r\nskb_reset_transport_header(skb);\r\nsegs = ERR_PTR(-EPROTONOSUPPORT);\r\nif (skb->encapsulation &&\r\nskb_shinfo(skb)->gso_type & (SKB_GSO_SIT|SKB_GSO_IPIP))\r\nudpfrag = proto == IPPROTO_UDP && encap;\r\nelse\r\nudpfrag = proto == IPPROTO_UDP && !skb->encapsulation;\r\nops = rcu_dereference(inet_offloads[proto]);\r\nif (likely(ops && ops->callbacks.gso_segment))\r\nsegs = ops->callbacks.gso_segment(skb, features);\r\nif (IS_ERR_OR_NULL(segs))\r\ngoto out;\r\nskb = segs;\r\ndo {\r\niph = (struct iphdr *)(skb_mac_header(skb) + nhoff);\r\nif (udpfrag) {\r\niph->id = htons(id);\r\niph->frag_off = htons(offset >> 3);\r\nif (skb->next != NULL)\r\niph->frag_off |= htons(IP_MF);\r\noffset += skb->len - nhoff - ihl;\r\n} else {\r\niph->id = htons(id++);\r\n}\r\niph->tot_len = htons(skb->len - nhoff);\r\nip_send_check(iph);\r\nif (encap)\r\nskb_reset_inner_headers(skb);\r\nskb->network_header = (u8 *)iph - skb->head;\r\n} while ((skb = skb->next));\r\nout:\r\nreturn segs;\r\n}\r\nstatic struct sk_buff **inet_gro_receive(struct sk_buff **head,\r\nstruct sk_buff *skb)\r\n{\r\nconst struct net_offload *ops;\r\nstruct sk_buff **pp = NULL;\r\nstruct sk_buff *p;\r\nconst struct iphdr *iph;\r\nunsigned int hlen;\r\nunsigned int off;\r\nunsigned int id;\r\nint flush = 1;\r\nint proto;\r\noff = skb_gro_offset(skb);\r\nhlen = off + sizeof(*iph);\r\niph = skb_gro_header_fast(skb, off);\r\nif (skb_gro_header_hard(skb, hlen)) {\r\niph = skb_gro_header_slow(skb, hlen, off);\r\nif (unlikely(!iph))\r\ngoto out;\r\n}\r\nproto = iph->protocol;\r\nrcu_read_lock();\r\nops = rcu_dereference(inet_offloads[proto]);\r\nif (!ops || !ops->callbacks.gro_receive)\r\ngoto out_unlock;\r\nif (*(u8 *)iph != 0x45)\r\ngoto out_unlock;\r\nif (unlikely(ip_fast_csum((u8 *)iph, 5)))\r\ngoto out_unlock;\r\nid = ntohl(*(__be32 *)&iph->id);\r\nflush = (u16)((ntohl(*(__be32 *)iph) ^ skb_gro_len(skb)) | (id & ~IP_DF));\r\nid >>= 16;\r\nfor (p = *head; p; p = p->next) {\r\nstruct iphdr *iph2;\r\nif (!NAPI_GRO_CB(p)->same_flow)\r\ncontinue;\r\niph2 = (struct iphdr *)(p->data + off);\r\nif ((iph->protocol ^ iph2->protocol) |\r\n((__force u32)iph->saddr ^ (__force u32)iph2->saddr) |\r\n((__force u32)iph->daddr ^ (__force u32)iph2->daddr)) {\r\nNAPI_GRO_CB(p)->same_flow = 0;\r\ncontinue;\r\n}\r\nNAPI_GRO_CB(p)->flush |=\r\n(iph->ttl ^ iph2->ttl) |\r\n(iph->tos ^ iph2->tos) |\r\n((iph->frag_off ^ iph2->frag_off) & htons(IP_DF));\r\nNAPI_GRO_CB(p)->flush_id =\r\n((u16)(ntohs(iph2->id) + NAPI_GRO_CB(p)->count) ^ id);\r\nNAPI_GRO_CB(p)->flush |= flush;\r\n}\r\nNAPI_GRO_CB(skb)->flush |= flush;\r\nskb_set_network_header(skb, off);\r\nskb_gro_pull(skb, sizeof(*iph));\r\nskb_set_transport_header(skb, skb_gro_offset(skb));\r\npp = ops->callbacks.gro_receive(head, skb);\r\nout_unlock:\r\nrcu_read_unlock();\r\nout:\r\nNAPI_GRO_CB(skb)->flush |= flush;\r\nreturn pp;\r\n}\r\nstatic int inet_gro_complete(struct sk_buff *skb, int nhoff)\r\n{\r\n__be16 newlen = htons(skb->len - nhoff);\r\nstruct iphdr *iph = (struct iphdr *)(skb->data + nhoff);\r\nconst struct net_offload *ops;\r\nint proto = iph->protocol;\r\nint err = -ENOSYS;\r\nif (skb->encapsulation)\r\nskb_set_inner_network_header(skb, nhoff);\r\ncsum_replace2(&iph->check, iph->tot_len, newlen);\r\niph->tot_len = newlen;\r\nrcu_read_lock();\r\nops = rcu_dereference(inet_offloads[proto]);\r\nif (WARN_ON(!ops || !ops->callbacks.gro_complete))\r\ngoto out_unlock;\r\nerr = ops->callbacks.gro_complete(skb, nhoff + sizeof(*iph));\r\nout_unlock:\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nint inet_ctl_sock_create(struct sock **sk, unsigned short family,\r\nunsigned short type, unsigned char protocol,\r\nstruct net *net)\r\n{\r\nstruct socket *sock;\r\nint rc = sock_create_kern(family, type, protocol, &sock);\r\nif (rc == 0) {\r\n*sk = sock->sk;\r\n(*sk)->sk_allocation = GFP_ATOMIC;\r\n(*sk)->sk_prot->unhash(*sk);\r\nsk_change_net(*sk, net);\r\n}\r\nreturn rc;\r\n}\r\nunsigned long snmp_fold_field(void __percpu *mib, int offt)\r\n{\r\nunsigned long res = 0;\r\nint i;\r\nfor_each_possible_cpu(i)\r\nres += *(((unsigned long *) per_cpu_ptr(mib, i)) + offt);\r\nreturn res;\r\n}\r\nu64 snmp_fold_field64(void __percpu *mib, int offt, size_t syncp_offset)\r\n{\r\nu64 res = 0;\r\nint cpu;\r\nfor_each_possible_cpu(cpu) {\r\nvoid *bhptr;\r\nstruct u64_stats_sync *syncp;\r\nu64 v;\r\nunsigned int start;\r\nbhptr = per_cpu_ptr(mib, cpu);\r\nsyncp = (struct u64_stats_sync *)(bhptr + syncp_offset);\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(syncp);\r\nv = *(((u64 *) bhptr) + offt);\r\n} while (u64_stats_fetch_retry_irq(syncp, start));\r\nres += v;\r\n}\r\nreturn res;\r\n}\r\nstatic __net_init int ipv4_mib_init_net(struct net *net)\r\n{\r\nint i;\r\nnet->mib.tcp_statistics = alloc_percpu(struct tcp_mib);\r\nif (!net->mib.tcp_statistics)\r\ngoto err_tcp_mib;\r\nnet->mib.ip_statistics = alloc_percpu(struct ipstats_mib);\r\nif (!net->mib.ip_statistics)\r\ngoto err_ip_mib;\r\nfor_each_possible_cpu(i) {\r\nstruct ipstats_mib *af_inet_stats;\r\naf_inet_stats = per_cpu_ptr(net->mib.ip_statistics, i);\r\nu64_stats_init(&af_inet_stats->syncp);\r\n}\r\nnet->mib.net_statistics = alloc_percpu(struct linux_mib);\r\nif (!net->mib.net_statistics)\r\ngoto err_net_mib;\r\nnet->mib.udp_statistics = alloc_percpu(struct udp_mib);\r\nif (!net->mib.udp_statistics)\r\ngoto err_udp_mib;\r\nnet->mib.udplite_statistics = alloc_percpu(struct udp_mib);\r\nif (!net->mib.udplite_statistics)\r\ngoto err_udplite_mib;\r\nnet->mib.icmp_statistics = alloc_percpu(struct icmp_mib);\r\nif (!net->mib.icmp_statistics)\r\ngoto err_icmp_mib;\r\nnet->mib.icmpmsg_statistics = kzalloc(sizeof(struct icmpmsg_mib),\r\nGFP_KERNEL);\r\nif (!net->mib.icmpmsg_statistics)\r\ngoto err_icmpmsg_mib;\r\ntcp_mib_init(net);\r\nreturn 0;\r\nerr_icmpmsg_mib:\r\nfree_percpu(net->mib.icmp_statistics);\r\nerr_icmp_mib:\r\nfree_percpu(net->mib.udplite_statistics);\r\nerr_udplite_mib:\r\nfree_percpu(net->mib.udp_statistics);\r\nerr_udp_mib:\r\nfree_percpu(net->mib.net_statistics);\r\nerr_net_mib:\r\nfree_percpu(net->mib.ip_statistics);\r\nerr_ip_mib:\r\nfree_percpu(net->mib.tcp_statistics);\r\nerr_tcp_mib:\r\nreturn -ENOMEM;\r\n}\r\nstatic __net_exit void ipv4_mib_exit_net(struct net *net)\r\n{\r\nkfree(net->mib.icmpmsg_statistics);\r\nfree_percpu(net->mib.icmp_statistics);\r\nfree_percpu(net->mib.udplite_statistics);\r\nfree_percpu(net->mib.udp_statistics);\r\nfree_percpu(net->mib.net_statistics);\r\nfree_percpu(net->mib.ip_statistics);\r\nfree_percpu(net->mib.tcp_statistics);\r\n}\r\nstatic int __init init_ipv4_mibs(void)\r\n{\r\nreturn register_pernet_subsys(&ipv4_mib_ops);\r\n}\r\nstatic __net_init int inet_init_net(struct net *net)\r\n{\r\nseqlock_init(&net->ipv4.ip_local_ports.lock);\r\nnet->ipv4.ip_local_ports.range[0] = 32768;\r\nnet->ipv4.ip_local_ports.range[1] = 61000;\r\nseqlock_init(&net->ipv4.ping_group_range.lock);\r\nnet->ipv4.ping_group_range.range[0] = make_kgid(&init_user_ns, 1);\r\nnet->ipv4.ping_group_range.range[1] = make_kgid(&init_user_ns, 0);\r\nreturn 0;\r\n}\r\nstatic __net_exit void inet_exit_net(struct net *net)\r\n{\r\n}\r\nstatic int __init init_inet_pernet_ops(void)\r\n{\r\nreturn register_pernet_subsys(&af_inet_ops);\r\n}\r\nstatic int __init ipv4_offload_init(void)\r\n{\r\nif (udpv4_offload_init() < 0)\r\npr_crit("%s: Cannot add UDP protocol offload\n", __func__);\r\nif (tcpv4_offload_init() < 0)\r\npr_crit("%s: Cannot add TCP protocol offload\n", __func__);\r\ndev_add_offload(&ip_packet_offload);\r\ninet_add_offload(&ipip_offload, IPPROTO_IPIP);\r\nreturn 0;\r\n}\r\nstatic int __init inet_init(void)\r\n{\r\nstruct inet_protosw *q;\r\nstruct list_head *r;\r\nint rc = -EINVAL;\r\nBUILD_BUG_ON(sizeof(struct inet_skb_parm) > FIELD_SIZEOF(struct sk_buff, cb));\r\nrc = proto_register(&tcp_prot, 1);\r\nif (rc)\r\ngoto out;\r\nrc = proto_register(&udp_prot, 1);\r\nif (rc)\r\ngoto out_unregister_tcp_proto;\r\nrc = proto_register(&raw_prot, 1);\r\nif (rc)\r\ngoto out_unregister_udp_proto;\r\nrc = proto_register(&ping_prot, 1);\r\nif (rc)\r\ngoto out_unregister_raw_proto;\r\n(void)sock_register(&inet_family_ops);\r\n#ifdef CONFIG_SYSCTL\r\nip_static_sysctl_init();\r\n#endif\r\nif (inet_add_protocol(&icmp_protocol, IPPROTO_ICMP) < 0)\r\npr_crit("%s: Cannot add ICMP protocol\n", __func__);\r\nif (inet_add_protocol(&udp_protocol, IPPROTO_UDP) < 0)\r\npr_crit("%s: Cannot add UDP protocol\n", __func__);\r\nif (inet_add_protocol(&tcp_protocol, IPPROTO_TCP) < 0)\r\npr_crit("%s: Cannot add TCP protocol\n", __func__);\r\n#ifdef CONFIG_IP_MULTICAST\r\nif (inet_add_protocol(&igmp_protocol, IPPROTO_IGMP) < 0)\r\npr_crit("%s: Cannot add IGMP protocol\n", __func__);\r\n#endif\r\nfor (r = &inetsw[0]; r < &inetsw[SOCK_MAX]; ++r)\r\nINIT_LIST_HEAD(r);\r\nfor (q = inetsw_array; q < &inetsw_array[INETSW_ARRAY_LEN]; ++q)\r\ninet_register_protosw(q);\r\narp_init();\r\nip_init();\r\ntcp_v4_init();\r\ntcp_init();\r\nudp_init();\r\nudplite4_register();\r\nping_init();\r\nif (icmp_init() < 0)\r\npanic("Failed to create the ICMP control socket.\n");\r\n#if defined(CONFIG_IP_MROUTE)\r\nif (ip_mr_init())\r\npr_crit("%s: Cannot init ipv4 mroute\n", __func__);\r\n#endif\r\nif (init_inet_pernet_ops())\r\npr_crit("%s: Cannot init ipv4 inet pernet ops\n", __func__);\r\nif (init_ipv4_mibs())\r\npr_crit("%s: Cannot init ipv4 mibs\n", __func__);\r\nipv4_proc_init();\r\nipfrag_init();\r\ndev_add_pack(&ip_packet_type);\r\nrc = 0;\r\nout:\r\nreturn rc;\r\nout_unregister_raw_proto:\r\nproto_unregister(&raw_prot);\r\nout_unregister_udp_proto:\r\nproto_unregister(&udp_prot);\r\nout_unregister_tcp_proto:\r\nproto_unregister(&tcp_prot);\r\ngoto out;\r\n}\r\nstatic int __init ipv4_proc_init(void)\r\n{\r\nint rc = 0;\r\nif (raw_proc_init())\r\ngoto out_raw;\r\nif (tcp4_proc_init())\r\ngoto out_tcp;\r\nif (udp4_proc_init())\r\ngoto out_udp;\r\nif (ping_proc_init())\r\ngoto out_ping;\r\nif (ip_misc_proc_init())\r\ngoto out_misc;\r\nout:\r\nreturn rc;\r\nout_misc:\r\nping_proc_exit();\r\nout_ping:\r\nudp4_proc_exit();\r\nout_udp:\r\ntcp4_proc_exit();\r\nout_tcp:\r\nraw_proc_exit();\r\nout_raw:\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nstatic int __init ipv4_proc_init(void)\r\n{\r\nreturn 0;\r\n}
