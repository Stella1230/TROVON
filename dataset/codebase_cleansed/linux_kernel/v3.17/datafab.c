static inline int\r\ndatafab_bulk_read(struct us_data *us, unsigned char *data, unsigned int len) {\r\nif (len == 0)\r\nreturn USB_STOR_XFER_GOOD;\r\nusb_stor_dbg(us, "len = %d\n", len);\r\nreturn usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\r\ndata, len, NULL);\r\n}\r\nstatic inline int\r\ndatafab_bulk_write(struct us_data *us, unsigned char *data, unsigned int len) {\r\nif (len == 0)\r\nreturn USB_STOR_XFER_GOOD;\r\nusb_stor_dbg(us, "len = %d\n", len);\r\nreturn usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\r\ndata, len, NULL);\r\n}\r\nstatic int datafab_read_data(struct us_data *us,\r\nstruct datafab_info *info,\r\nu32 sector,\r\nu32 sectors)\r\n{\r\nunsigned char *command = us->iobuf;\r\nunsigned char *buffer;\r\nunsigned char thistime;\r\nunsigned int totallen, alloclen;\r\nint len, result;\r\nunsigned int sg_offset = 0;\r\nstruct scatterlist *sg = NULL;\r\nif (sectors > 0x0FFFFFFF)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nif (info->lun == -1) {\r\nresult = datafab_determine_lun(us, info);\r\nif (result != USB_STOR_TRANSPORT_GOOD)\r\nreturn result;\r\n}\r\ntotallen = sectors * info->ssize;\r\nalloclen = min(totallen, 65536u);\r\nbuffer = kmalloc(alloclen, GFP_NOIO);\r\nif (buffer == NULL)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\ndo {\r\nlen = min(totallen, alloclen);\r\nthistime = (len / info->ssize) & 0xff;\r\ncommand[0] = 0;\r\ncommand[1] = thistime;\r\ncommand[2] = sector & 0xFF;\r\ncommand[3] = (sector >> 8) & 0xFF;\r\ncommand[4] = (sector >> 16) & 0xFF;\r\ncommand[5] = 0xE0 + (info->lun << 4);\r\ncommand[5] |= (sector >> 24) & 0x0F;\r\ncommand[6] = 0x20;\r\ncommand[7] = 0x01;\r\nresult = datafab_bulk_write(us, command, 8);\r\nif (result != USB_STOR_XFER_GOOD)\r\ngoto leave;\r\nresult = datafab_bulk_read(us, buffer, len);\r\nif (result != USB_STOR_XFER_GOOD)\r\ngoto leave;\r\nusb_stor_access_xfer_buf(buffer, len, us->srb,\r\n&sg, &sg_offset, TO_XFER_BUF);\r\nsector += thistime;\r\ntotallen -= len;\r\n} while (totallen > 0);\r\nkfree(buffer);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\nleave:\r\nkfree(buffer);\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nstatic int datafab_write_data(struct us_data *us,\r\nstruct datafab_info *info,\r\nu32 sector,\r\nu32 sectors)\r\n{\r\nunsigned char *command = us->iobuf;\r\nunsigned char *reply = us->iobuf;\r\nunsigned char *buffer;\r\nunsigned char thistime;\r\nunsigned int totallen, alloclen;\r\nint len, result;\r\nunsigned int sg_offset = 0;\r\nstruct scatterlist *sg = NULL;\r\nif (sectors > 0x0FFFFFFF)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nif (info->lun == -1) {\r\nresult = datafab_determine_lun(us, info);\r\nif (result != USB_STOR_TRANSPORT_GOOD)\r\nreturn result;\r\n}\r\ntotallen = sectors * info->ssize;\r\nalloclen = min(totallen, 65536u);\r\nbuffer = kmalloc(alloclen, GFP_NOIO);\r\nif (buffer == NULL)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\ndo {\r\nlen = min(totallen, alloclen);\r\nthistime = (len / info->ssize) & 0xff;\r\nusb_stor_access_xfer_buf(buffer, len, us->srb,\r\n&sg, &sg_offset, FROM_XFER_BUF);\r\ncommand[0] = 0;\r\ncommand[1] = thistime;\r\ncommand[2] = sector & 0xFF;\r\ncommand[3] = (sector >> 8) & 0xFF;\r\ncommand[4] = (sector >> 16) & 0xFF;\r\ncommand[5] = 0xE0 + (info->lun << 4);\r\ncommand[5] |= (sector >> 24) & 0x0F;\r\ncommand[6] = 0x30;\r\ncommand[7] = 0x02;\r\nresult = datafab_bulk_write(us, command, 8);\r\nif (result != USB_STOR_XFER_GOOD)\r\ngoto leave;\r\nresult = datafab_bulk_write(us, buffer, len);\r\nif (result != USB_STOR_XFER_GOOD)\r\ngoto leave;\r\nresult = datafab_bulk_read(us, reply, 2);\r\nif (result != USB_STOR_XFER_GOOD)\r\ngoto leave;\r\nif (reply[0] != 0x50 && reply[1] != 0) {\r\nusb_stor_dbg(us, "Gah! write return code: %02x %02x\n",\r\nreply[0], reply[1]);\r\nresult = USB_STOR_TRANSPORT_ERROR;\r\ngoto leave;\r\n}\r\nsector += thistime;\r\ntotallen -= len;\r\n} while (totallen > 0);\r\nkfree(buffer);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\nleave:\r\nkfree(buffer);\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nstatic int datafab_determine_lun(struct us_data *us,\r\nstruct datafab_info *info)\r\n{\r\nstatic unsigned char scommand[8] = { 0, 1, 0, 0, 0, 0xa0, 0xec, 1 };\r\nunsigned char *command = us->iobuf;\r\nunsigned char *buf;\r\nint count = 0, rc;\r\nif (!info)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nmemcpy(command, scommand, 8);\r\nbuf = kmalloc(512, GFP_NOIO);\r\nif (!buf)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nusb_stor_dbg(us, "locating...\n");\r\nwhile (count++ < 3) {\r\ncommand[5] = 0xa0;\r\nrc = datafab_bulk_write(us, command, 8);\r\nif (rc != USB_STOR_XFER_GOOD) {\r\nrc = USB_STOR_TRANSPORT_ERROR;\r\ngoto leave;\r\n}\r\nrc = datafab_bulk_read(us, buf, 512);\r\nif (rc == USB_STOR_XFER_GOOD) {\r\ninfo->lun = 0;\r\nrc = USB_STOR_TRANSPORT_GOOD;\r\ngoto leave;\r\n}\r\ncommand[5] = 0xb0;\r\nrc = datafab_bulk_write(us, command, 8);\r\nif (rc != USB_STOR_XFER_GOOD) {\r\nrc = USB_STOR_TRANSPORT_ERROR;\r\ngoto leave;\r\n}\r\nrc = datafab_bulk_read(us, buf, 512);\r\nif (rc == USB_STOR_XFER_GOOD) {\r\ninfo->lun = 1;\r\nrc = USB_STOR_TRANSPORT_GOOD;\r\ngoto leave;\r\n}\r\nmsleep(20);\r\n}\r\nrc = USB_STOR_TRANSPORT_ERROR;\r\nleave:\r\nkfree(buf);\r\nreturn rc;\r\n}\r\nstatic int datafab_id_device(struct us_data *us,\r\nstruct datafab_info *info)\r\n{\r\nstatic unsigned char scommand[8] = { 0, 1, 0, 0, 0, 0xa0, 0xec, 1 };\r\nunsigned char *command = us->iobuf;\r\nunsigned char *reply;\r\nint rc;\r\nif (!info)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nif (info->lun == -1) {\r\nrc = datafab_determine_lun(us, info);\r\nif (rc != USB_STOR_TRANSPORT_GOOD)\r\nreturn rc;\r\n}\r\nmemcpy(command, scommand, 8);\r\nreply = kmalloc(512, GFP_NOIO);\r\nif (!reply)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\ncommand[5] += (info->lun << 4);\r\nrc = datafab_bulk_write(us, command, 8);\r\nif (rc != USB_STOR_XFER_GOOD) {\r\nrc = USB_STOR_TRANSPORT_ERROR;\r\ngoto leave;\r\n}\r\nrc = datafab_bulk_read(us, reply, 512);\r\nif (rc == USB_STOR_XFER_GOOD) {\r\ninfo->sectors = ((u32)(reply[117]) << 24) |\r\n((u32)(reply[116]) << 16) |\r\n((u32)(reply[115]) << 8) |\r\n((u32)(reply[114]) );\r\nrc = USB_STOR_TRANSPORT_GOOD;\r\ngoto leave;\r\n}\r\nrc = USB_STOR_TRANSPORT_ERROR;\r\nleave:\r\nkfree(reply);\r\nreturn rc;\r\n}\r\nstatic int datafab_handle_mode_sense(struct us_data *us,\r\nstruct scsi_cmnd * srb,\r\nint sense_6)\r\n{\r\nstatic unsigned char rw_err_page[12] = {\r\n0x1, 0xA, 0x21, 1, 0, 0, 0, 0, 1, 0, 0, 0\r\n};\r\nstatic unsigned char cache_page[12] = {\r\n0x8, 0xA, 0x1, 0, 0, 0, 0, 0, 0, 0, 0, 0\r\n};\r\nstatic unsigned char rbac_page[12] = {\r\n0x1B, 0xA, 0, 0x81, 0, 0, 0, 0, 0, 0, 0, 0\r\n};\r\nstatic unsigned char timer_page[8] = {\r\n0x1C, 0x6, 0, 0, 0, 0\r\n};\r\nunsigned char pc, page_code;\r\nunsigned int i = 0;\r\nstruct datafab_info *info = (struct datafab_info *) (us->extra);\r\nunsigned char *ptr = us->iobuf;\r\npc = srb->cmnd[2] >> 6;\r\npage_code = srb->cmnd[2] & 0x3F;\r\nswitch (pc) {\r\ncase 0x0:\r\nusb_stor_dbg(us, "Current values\n");\r\nbreak;\r\ncase 0x1:\r\nusb_stor_dbg(us, "Changeable values\n");\r\nbreak;\r\ncase 0x2:\r\nusb_stor_dbg(us, "Default values\n");\r\nbreak;\r\ncase 0x3:\r\nusb_stor_dbg(us, "Saves values\n");\r\nbreak;\r\n}\r\nmemset(ptr, 0, 8);\r\nif (sense_6) {\r\nptr[2] = 0x00;\r\ni = 4;\r\n} else {\r\nptr[3] = 0x00;\r\ni = 8;\r\n}\r\nswitch (page_code) {\r\ndefault:\r\ninfo->sense_key = 0x05;\r\ninfo->sense_asc = 0x24;\r\ninfo->sense_ascq = 0x00;\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\ncase 0x1:\r\nmemcpy(ptr + i, rw_err_page, sizeof(rw_err_page));\r\ni += sizeof(rw_err_page);\r\nbreak;\r\ncase 0x8:\r\nmemcpy(ptr + i, cache_page, sizeof(cache_page));\r\ni += sizeof(cache_page);\r\nbreak;\r\ncase 0x1B:\r\nmemcpy(ptr + i, rbac_page, sizeof(rbac_page));\r\ni += sizeof(rbac_page);\r\nbreak;\r\ncase 0x1C:\r\nmemcpy(ptr + i, timer_page, sizeof(timer_page));\r\ni += sizeof(timer_page);\r\nbreak;\r\ncase 0x3F:\r\nmemcpy(ptr + i, timer_page, sizeof(timer_page));\r\ni += sizeof(timer_page);\r\nmemcpy(ptr + i, rbac_page, sizeof(rbac_page));\r\ni += sizeof(rbac_page);\r\nmemcpy(ptr + i, cache_page, sizeof(cache_page));\r\ni += sizeof(cache_page);\r\nmemcpy(ptr + i, rw_err_page, sizeof(rw_err_page));\r\ni += sizeof(rw_err_page);\r\nbreak;\r\n}\r\nif (sense_6)\r\nptr[0] = i - 1;\r\nelse\r\n((__be16 *) ptr)[0] = cpu_to_be16(i - 2);\r\nusb_stor_set_xfer_buf(ptr, i, srb);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic void datafab_info_destructor(void *extra)\r\n{\r\n}\r\nstatic int datafab_transport(struct scsi_cmnd *srb, struct us_data *us)\r\n{\r\nstruct datafab_info *info;\r\nint rc;\r\nunsigned long block, blocks;\r\nunsigned char *ptr = us->iobuf;\r\nstatic unsigned char inquiry_reply[8] = {\r\n0x00, 0x80, 0x00, 0x01, 0x1F, 0x00, 0x00, 0x00\r\n};\r\nif (!us->extra) {\r\nus->extra = kzalloc(sizeof(struct datafab_info), GFP_NOIO);\r\nif (!us->extra)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nus->extra_destructor = datafab_info_destructor;\r\n((struct datafab_info *)us->extra)->lun = -1;\r\n}\r\ninfo = (struct datafab_info *) (us->extra);\r\nif (srb->cmnd[0] == INQUIRY) {\r\nusb_stor_dbg(us, "INQUIRY - Returning bogus response\n");\r\nmemcpy(ptr, inquiry_reply, sizeof(inquiry_reply));\r\nfill_inquiry_response(us, ptr, 36);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nif (srb->cmnd[0] == READ_CAPACITY) {\r\ninfo->ssize = 0x200;\r\nrc = datafab_id_device(us, info);\r\nif (rc != USB_STOR_TRANSPORT_GOOD)\r\nreturn rc;\r\nusb_stor_dbg(us, "READ_CAPACITY: %ld sectors, %ld bytes per sector\n",\r\ninfo->sectors, info->ssize);\r\n((__be32 *) ptr)[0] = cpu_to_be32(info->sectors - 1);\r\n((__be32 *) ptr)[1] = cpu_to_be32(info->ssize);\r\nusb_stor_set_xfer_buf(ptr, 8, srb);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nif (srb->cmnd[0] == MODE_SELECT_10) {\r\nusb_stor_dbg(us, "Gah! MODE_SELECT_10\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nif (srb->cmnd[0] == READ_10) {\r\nblock = ((u32)(srb->cmnd[2]) << 24) | ((u32)(srb->cmnd[3]) << 16) |\r\n((u32)(srb->cmnd[4]) << 8) | ((u32)(srb->cmnd[5]));\r\nblocks = ((u32)(srb->cmnd[7]) << 8) | ((u32)(srb->cmnd[8]));\r\nusb_stor_dbg(us, "READ_10: read block 0x%04lx count %ld\n",\r\nblock, blocks);\r\nreturn datafab_read_data(us, info, block, blocks);\r\n}\r\nif (srb->cmnd[0] == READ_12) {\r\nblock = ((u32)(srb->cmnd[2]) << 24) | ((u32)(srb->cmnd[3]) << 16) |\r\n((u32)(srb->cmnd[4]) << 8) | ((u32)(srb->cmnd[5]));\r\nblocks = ((u32)(srb->cmnd[6]) << 24) | ((u32)(srb->cmnd[7]) << 16) |\r\n((u32)(srb->cmnd[8]) << 8) | ((u32)(srb->cmnd[9]));\r\nusb_stor_dbg(us, "READ_12: read block 0x%04lx count %ld\n",\r\nblock, blocks);\r\nreturn datafab_read_data(us, info, block, blocks);\r\n}\r\nif (srb->cmnd[0] == WRITE_10) {\r\nblock = ((u32)(srb->cmnd[2]) << 24) | ((u32)(srb->cmnd[3]) << 16) |\r\n((u32)(srb->cmnd[4]) << 8) | ((u32)(srb->cmnd[5]));\r\nblocks = ((u32)(srb->cmnd[7]) << 8) | ((u32)(srb->cmnd[8]));\r\nusb_stor_dbg(us, "WRITE_10: write block 0x%04lx count %ld\n",\r\nblock, blocks);\r\nreturn datafab_write_data(us, info, block, blocks);\r\n}\r\nif (srb->cmnd[0] == WRITE_12) {\r\nblock = ((u32)(srb->cmnd[2]) << 24) | ((u32)(srb->cmnd[3]) << 16) |\r\n((u32)(srb->cmnd[4]) << 8) | ((u32)(srb->cmnd[5]));\r\nblocks = ((u32)(srb->cmnd[6]) << 24) | ((u32)(srb->cmnd[7]) << 16) |\r\n((u32)(srb->cmnd[8]) << 8) | ((u32)(srb->cmnd[9]));\r\nusb_stor_dbg(us, "WRITE_12: write block 0x%04lx count %ld\n",\r\nblock, blocks);\r\nreturn datafab_write_data(us, info, block, blocks);\r\n}\r\nif (srb->cmnd[0] == TEST_UNIT_READY) {\r\nusb_stor_dbg(us, "TEST_UNIT_READY\n");\r\nreturn datafab_id_device(us, info);\r\n}\r\nif (srb->cmnd[0] == REQUEST_SENSE) {\r\nusb_stor_dbg(us, "REQUEST_SENSE - Returning faked response\n");\r\nmemset(ptr, 0, 18);\r\nptr[0] = 0xF0;\r\nptr[2] = info->sense_key;\r\nptr[7] = 11;\r\nptr[12] = info->sense_asc;\r\nptr[13] = info->sense_ascq;\r\nusb_stor_set_xfer_buf(ptr, 18, srb);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nif (srb->cmnd[0] == MODE_SENSE) {\r\nusb_stor_dbg(us, "MODE_SENSE_6 detected\n");\r\nreturn datafab_handle_mode_sense(us, srb, 1);\r\n}\r\nif (srb->cmnd[0] == MODE_SENSE_10) {\r\nusb_stor_dbg(us, "MODE_SENSE_10 detected\n");\r\nreturn datafab_handle_mode_sense(us, srb, 0);\r\n}\r\nif (srb->cmnd[0] == ALLOW_MEDIUM_REMOVAL) {\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nif (srb->cmnd[0] == START_STOP) {\r\nusb_stor_dbg(us, "START_STOP\n");\r\nrc = datafab_id_device(us, info);\r\nif (rc == USB_STOR_TRANSPORT_GOOD) {\r\ninfo->sense_key = NO_SENSE;\r\nsrb->result = SUCCESS;\r\n} else {\r\ninfo->sense_key = UNIT_ATTENTION;\r\nsrb->result = SAM_STAT_CHECK_CONDITION;\r\n}\r\nreturn rc;\r\n}\r\nusb_stor_dbg(us, "Gah! Unknown command: %d (0x%x)\n",\r\nsrb->cmnd[0], srb->cmnd[0]);\r\ninfo->sense_key = 0x05;\r\ninfo->sense_asc = 0x20;\r\ninfo->sense_ascq = 0x00;\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\nstatic int datafab_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct us_data *us;\r\nint result;\r\nresult = usb_stor_probe1(&us, intf, id,\r\n(id - datafab_usb_ids) + datafab_unusual_dev_list);\r\nif (result)\r\nreturn result;\r\nus->transport_name = "Datafab Bulk-Only";\r\nus->transport = datafab_transport;\r\nus->transport_reset = usb_stor_Bulk_reset;\r\nus->max_lun = 1;\r\nresult = usb_stor_probe2(us);\r\nreturn result;\r\n}
