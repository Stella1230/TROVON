static void armada_370_xp_irq_mask(struct irq_data *d)\r\n{\r\nirq_hw_number_t hwirq = irqd_to_hwirq(d);\r\nif (hwirq != ARMADA_370_XP_TIMER0_PER_CPU_IRQ)\r\nwritel(hwirq, main_int_base +\r\nARMADA_370_XP_INT_CLEAR_ENABLE_OFFS);\r\nelse\r\nwritel(hwirq, per_cpu_int_base +\r\nARMADA_370_XP_INT_SET_MASK_OFFS);\r\n}\r\nstatic void armada_370_xp_irq_unmask(struct irq_data *d)\r\n{\r\nirq_hw_number_t hwirq = irqd_to_hwirq(d);\r\nif (hwirq != ARMADA_370_XP_TIMER0_PER_CPU_IRQ)\r\nwritel(hwirq, main_int_base +\r\nARMADA_370_XP_INT_SET_ENABLE_OFFS);\r\nelse\r\nwritel(hwirq, per_cpu_int_base +\r\nARMADA_370_XP_INT_CLEAR_MASK_OFFS);\r\n}\r\nstatic int armada_370_xp_alloc_msi(void)\r\n{\r\nint hwirq;\r\nmutex_lock(&msi_used_lock);\r\nhwirq = find_first_zero_bit(&msi_used, PCI_MSI_DOORBELL_NR);\r\nif (hwirq >= PCI_MSI_DOORBELL_NR)\r\nhwirq = -ENOSPC;\r\nelse\r\nset_bit(hwirq, msi_used);\r\nmutex_unlock(&msi_used_lock);\r\nreturn hwirq;\r\n}\r\nstatic void armada_370_xp_free_msi(int hwirq)\r\n{\r\nmutex_lock(&msi_used_lock);\r\nif (!test_bit(hwirq, msi_used))\r\npr_err("trying to free unused MSI#%d\n", hwirq);\r\nelse\r\nclear_bit(hwirq, msi_used);\r\nmutex_unlock(&msi_used_lock);\r\n}\r\nstatic int armada_370_xp_setup_msi_irq(struct msi_chip *chip,\r\nstruct pci_dev *pdev,\r\nstruct msi_desc *desc)\r\n{\r\nstruct msi_msg msg;\r\nint virq, hwirq;\r\nhwirq = armada_370_xp_alloc_msi();\r\nif (hwirq < 0)\r\nreturn hwirq;\r\nvirq = irq_create_mapping(armada_370_xp_msi_domain, hwirq);\r\nif (!virq) {\r\narmada_370_xp_free_msi(hwirq);\r\nreturn -EINVAL;\r\n}\r\nirq_set_msi_desc(virq, desc);\r\nmsg.address_lo = msi_doorbell_addr;\r\nmsg.address_hi = 0;\r\nmsg.data = 0xf00 | (hwirq + 16);\r\nwrite_msi_msg(virq, &msg);\r\nreturn 0;\r\n}\r\nstatic void armada_370_xp_teardown_msi_irq(struct msi_chip *chip,\r\nunsigned int irq)\r\n{\r\nstruct irq_data *d = irq_get_irq_data(irq);\r\nunsigned long hwirq = d->hwirq;\r\nirq_dispose_mapping(irq);\r\narmada_370_xp_free_msi(hwirq);\r\n}\r\nstatic int armada_370_xp_check_msi_device(struct msi_chip *chip, struct pci_dev *dev,\r\nint nvec, int type)\r\n{\r\nif (type == PCI_CAP_ID_MSI)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int armada_370_xp_msi_map(struct irq_domain *domain, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nirq_set_chip_and_handler(virq, &armada_370_xp_msi_irq_chip,\r\nhandle_simple_irq);\r\nset_irq_flags(virq, IRQF_VALID);\r\nreturn 0;\r\n}\r\nstatic int armada_370_xp_msi_init(struct device_node *node,\r\nphys_addr_t main_int_phys_base)\r\n{\r\nstruct msi_chip *msi_chip;\r\nu32 reg;\r\nint ret;\r\nmsi_doorbell_addr = main_int_phys_base +\r\nARMADA_370_XP_SW_TRIG_INT_OFFS;\r\nmsi_chip = kzalloc(sizeof(*msi_chip), GFP_KERNEL);\r\nif (!msi_chip)\r\nreturn -ENOMEM;\r\nmsi_chip->setup_irq = armada_370_xp_setup_msi_irq;\r\nmsi_chip->teardown_irq = armada_370_xp_teardown_msi_irq;\r\nmsi_chip->check_device = armada_370_xp_check_msi_device;\r\nmsi_chip->of_node = node;\r\narmada_370_xp_msi_domain =\r\nirq_domain_add_linear(NULL, PCI_MSI_DOORBELL_NR,\r\n&armada_370_xp_msi_irq_ops,\r\nNULL);\r\nif (!armada_370_xp_msi_domain) {\r\nkfree(msi_chip);\r\nreturn -ENOMEM;\r\n}\r\nret = of_pci_msi_chip_add(msi_chip);\r\nif (ret < 0) {\r\nirq_domain_remove(armada_370_xp_msi_domain);\r\nkfree(msi_chip);\r\nreturn ret;\r\n}\r\nreg = readl(per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_MSK_OFFS)\r\n| PCI_MSI_DOORBELL_MASK;\r\nwritel(reg, per_cpu_int_base +\r\nARMADA_370_XP_IN_DRBEL_MSK_OFFS);\r\nwritel(1, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);\r\nreturn 0;\r\n}\r\nstatic inline int armada_370_xp_msi_init(struct device_node *node,\r\nphys_addr_t main_int_phys_base)\r\n{\r\nreturn 0;\r\n}\r\nstatic int armada_xp_set_affinity(struct irq_data *d,\r\nconst struct cpumask *mask_val, bool force)\r\n{\r\nirq_hw_number_t hwirq = irqd_to_hwirq(d);\r\nunsigned long reg, mask;\r\nint cpu;\r\ncpu = cpumask_any_and(mask_val, cpu_online_mask);\r\nmask = 1UL << cpu_logical_map(cpu);\r\nraw_spin_lock(&irq_controller_lock);\r\nreg = readl(main_int_base + ARMADA_370_XP_INT_SOURCE_CTL(hwirq));\r\nreg = (reg & (~ARMADA_370_XP_INT_SOURCE_CPU_MASK)) | mask;\r\nwritel(reg, main_int_base + ARMADA_370_XP_INT_SOURCE_CTL(hwirq));\r\nraw_spin_unlock(&irq_controller_lock);\r\nreturn 0;\r\n}\r\nstatic int armada_370_xp_mpic_irq_map(struct irq_domain *h,\r\nunsigned int virq, irq_hw_number_t hw)\r\n{\r\narmada_370_xp_irq_mask(irq_get_irq_data(virq));\r\nif (hw != ARMADA_370_XP_TIMER0_PER_CPU_IRQ)\r\nwritel(hw, per_cpu_int_base +\r\nARMADA_370_XP_INT_CLEAR_MASK_OFFS);\r\nelse\r\nwritel(hw, main_int_base + ARMADA_370_XP_INT_SET_ENABLE_OFFS);\r\nirq_set_status_flags(virq, IRQ_LEVEL);\r\nif (hw == ARMADA_370_XP_TIMER0_PER_CPU_IRQ) {\r\nirq_set_percpu_devid(virq);\r\nirq_set_chip_and_handler(virq, &armada_370_xp_irq_chip,\r\nhandle_percpu_devid_irq);\r\n} else {\r\nirq_set_chip_and_handler(virq, &armada_370_xp_irq_chip,\r\nhandle_level_irq);\r\n}\r\nset_irq_flags(virq, IRQF_VALID | IRQF_PROBE);\r\nreturn 0;\r\n}\r\nstatic void armada_mpic_send_doorbell(const struct cpumask *mask,\r\nunsigned int irq)\r\n{\r\nint cpu;\r\nunsigned long map = 0;\r\nfor_each_cpu(cpu, mask)\r\nmap |= 1 << cpu_logical_map(cpu);\r\ndsb();\r\nwritel((map << 8) | irq, main_int_base +\r\nARMADA_370_XP_SW_TRIG_INT_OFFS);\r\n}\r\nstatic void armada_xp_mpic_smp_cpu_init(void)\r\n{\r\nu32 control;\r\nint nr_irqs, i;\r\ncontrol = readl(main_int_base + ARMADA_370_XP_INT_CONTROL);\r\nnr_irqs = (control >> 2) & 0x3ff;\r\nfor (i = 0; i < nr_irqs; i++)\r\nwritel(i, per_cpu_int_base + ARMADA_370_XP_INT_SET_MASK_OFFS);\r\nwritel(0, per_cpu_int_base + ARMADA_370_XP_IN_DRBEL_CAUSE_OFFS);\r\nwritel(IPI_DOORBELL_MASK, per_cpu_int_base +\r\nARMADA_370_XP_IN_DRBEL_MSK_OFFS);\r\nwritel(0, per_cpu_int_base + ARMADA_370_XP_INT_CLEAR_MASK_OFFS);\r\n}\r\nstatic int armada_xp_mpic_secondary_init(struct notifier_block *nfb,\r\nunsigned long action, void *hcpu)\r\n{\r\nif (action == CPU_STARTING || action == CPU_STARTING_FROZEN)\r\narmada_xp_mpic_smp_cpu_init();\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void armada_370_xp_handle_msi_irq(struct pt_regs *regs, bool is_chained)\r\n{\r\nu32 msimask, msinr;\r\nmsimask = readl_relaxed(per_cpu_int_base +\r\nARMADA_370_XP_IN_DRBEL_CAUSE_OFFS)\r\n& PCI_MSI_DOORBELL_MASK;\r\nwritel(~msimask, per_cpu_int_base +\r\nARMADA_370_XP_IN_DRBEL_CAUSE_OFFS);\r\nfor (msinr = PCI_MSI_DOORBELL_START;\r\nmsinr < PCI_MSI_DOORBELL_END; msinr++) {\r\nint irq;\r\nif (!(msimask & BIT(msinr)))\r\ncontinue;\r\nirq = irq_find_mapping(armada_370_xp_msi_domain,\r\nmsinr - 16);\r\nif (is_chained)\r\ngeneric_handle_irq(irq);\r\nelse\r\nhandle_IRQ(irq, regs);\r\n}\r\n}\r\nstatic void armada_370_xp_handle_msi_irq(struct pt_regs *r, bool b) {}\r\nstatic void armada_370_xp_mpic_handle_cascade_irq(unsigned int irq,\r\nstruct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_get_chip(irq);\r\nunsigned long irqmap, irqn;\r\nunsigned int cascade_irq;\r\nchained_irq_enter(chip, desc);\r\nirqmap = readl_relaxed(per_cpu_int_base + ARMADA_375_PPI_CAUSE);\r\nif (irqmap & BIT(0)) {\r\narmada_370_xp_handle_msi_irq(NULL, true);\r\nirqmap &= ~BIT(0);\r\n}\r\nfor_each_set_bit(irqn, &irqmap, BITS_PER_LONG) {\r\ncascade_irq = irq_find_mapping(armada_370_xp_mpic_domain, irqn);\r\ngeneric_handle_irq(cascade_irq);\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void __exception_irq_entry\r\narmada_370_xp_handle_irq(struct pt_regs *regs)\r\n{\r\nu32 irqstat, irqnr;\r\ndo {\r\nirqstat = readl_relaxed(per_cpu_int_base +\r\nARMADA_370_XP_CPU_INTACK_OFFS);\r\nirqnr = irqstat & 0x3FF;\r\nif (irqnr > 1022)\r\nbreak;\r\nif (irqnr > 1) {\r\nirqnr = irq_find_mapping(armada_370_xp_mpic_domain,\r\nirqnr);\r\nhandle_IRQ(irqnr, regs);\r\ncontinue;\r\n}\r\nif (irqnr == 1)\r\narmada_370_xp_handle_msi_irq(regs, false);\r\n#ifdef CONFIG_SMP\r\nif (irqnr == 0) {\r\nu32 ipimask, ipinr;\r\nipimask = readl_relaxed(per_cpu_int_base +\r\nARMADA_370_XP_IN_DRBEL_CAUSE_OFFS)\r\n& IPI_DOORBELL_MASK;\r\nwritel(~ipimask, per_cpu_int_base +\r\nARMADA_370_XP_IN_DRBEL_CAUSE_OFFS);\r\nfor (ipinr = IPI_DOORBELL_START;\r\nipinr < IPI_DOORBELL_END; ipinr++) {\r\nif (ipimask & (0x1 << ipinr))\r\nhandle_IPI(ipinr, regs);\r\n}\r\ncontinue;\r\n}\r\n#endif\r\n} while (1);\r\n}\r\nstatic int __init armada_370_xp_mpic_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nstruct resource main_int_res, per_cpu_int_res;\r\nint parent_irq, nr_irqs, i;\r\nu32 control;\r\nBUG_ON(of_address_to_resource(node, 0, &main_int_res));\r\nBUG_ON(of_address_to_resource(node, 1, &per_cpu_int_res));\r\nBUG_ON(!request_mem_region(main_int_res.start,\r\nresource_size(&main_int_res),\r\nnode->full_name));\r\nBUG_ON(!request_mem_region(per_cpu_int_res.start,\r\nresource_size(&per_cpu_int_res),\r\nnode->full_name));\r\nmain_int_base = ioremap(main_int_res.start,\r\nresource_size(&main_int_res));\r\nBUG_ON(!main_int_base);\r\nper_cpu_int_base = ioremap(per_cpu_int_res.start,\r\nresource_size(&per_cpu_int_res));\r\nBUG_ON(!per_cpu_int_base);\r\ncontrol = readl(main_int_base + ARMADA_370_XP_INT_CONTROL);\r\nnr_irqs = (control >> 2) & 0x3ff;\r\nfor (i = 0; i < nr_irqs; i++)\r\nwritel(i, main_int_base + ARMADA_370_XP_INT_CLEAR_ENABLE_OFFS);\r\narmada_370_xp_mpic_domain =\r\nirq_domain_add_linear(node, nr_irqs,\r\n&armada_370_xp_mpic_irq_ops, NULL);\r\nBUG_ON(!armada_370_xp_mpic_domain);\r\n#ifdef CONFIG_SMP\r\narmada_xp_mpic_smp_cpu_init();\r\n#endif\r\narmada_370_xp_msi_init(node, main_int_res.start);\r\nparent_irq = irq_of_parse_and_map(node, 0);\r\nif (parent_irq <= 0) {\r\nirq_set_default_host(armada_370_xp_mpic_domain);\r\nset_handle_irq(armada_370_xp_handle_irq);\r\n#ifdef CONFIG_SMP\r\nset_smp_cross_call(armada_mpic_send_doorbell);\r\nregister_cpu_notifier(&armada_370_xp_mpic_cpu_notifier);\r\n#endif\r\n} else {\r\nirq_set_chained_handler(parent_irq,\r\narmada_370_xp_mpic_handle_cascade_irq);\r\n}\r\nreturn 0;\r\n}
