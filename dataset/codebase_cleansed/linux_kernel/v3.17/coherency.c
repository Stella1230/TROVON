int set_cpu_coherent(void)\r\n{\r\nif (!coherency_base) {\r\npr_warn("Can't make current CPU cache coherent.\n");\r\npr_warn("Coherency fabric is not initialized\n");\r\nreturn 1;\r\n}\r\nll_add_cpu_to_smp_group();\r\nreturn ll_enable_coherency();\r\n}\r\nstatic inline void mvebu_hwcc_armada375_sync_io_barrier_wa(void)\r\n{\r\nint idx = smp_processor_id();\r\nwritel(0x1, coherency_wa_buf[idx]);\r\nwhile ((readl(xor_base + XOR_ACTIVATION(idx)) >> 4) & 0x3)\r\n;\r\ndmb();\r\nwritel(0x1, xor_base + XOR_ACTIVATION(idx));\r\nwhile (readl(coherency_wa_buf[idx]))\r\n;\r\n}\r\nstatic void __init armada_375_coherency_init_wa(void)\r\n{\r\nconst struct mbus_dram_target_info *dram;\r\nstruct device_node *xor_node;\r\nstruct property *xor_status;\r\nstruct clk *xor_clk;\r\nu32 win_enable = 0;\r\nint i;\r\npr_warn("enabling coherency workaround for Armada 375 Z1, one XOR engine disabled\n");\r\nxor_node = of_find_compatible_node(NULL, NULL, "marvell,orion-xor");\r\nBUG_ON(!xor_node);\r\nxor_status = kzalloc(sizeof(struct property), GFP_KERNEL);\r\nBUG_ON(!xor_status);\r\nxor_status->value = kstrdup("disabled", GFP_KERNEL);\r\nBUG_ON(!xor_status->value);\r\nxor_status->length = 8;\r\nxor_status->name = kstrdup("status", GFP_KERNEL);\r\nBUG_ON(!xor_status->name);\r\nof_update_property(xor_node, xor_status);\r\nxor_base = of_iomap(xor_node, 0);\r\nxor_high_base = of_iomap(xor_node, 1);\r\nxor_clk = of_clk_get_by_name(xor_node, NULL);\r\nBUG_ON(!xor_clk);\r\nclk_prepare_enable(xor_clk);\r\ndram = mv_mbus_dram_info();\r\nfor (i = 0; i < 8; i++) {\r\nwritel(0, xor_base + WINDOW_BASE(i));\r\nwritel(0, xor_base + WINDOW_SIZE(i));\r\nif (i < 4)\r\nwritel(0, xor_base + WINDOW_REMAP_HIGH(i));\r\n}\r\nfor (i = 0; i < dram->num_cs; i++) {\r\nconst struct mbus_dram_window *cs = dram->cs + i;\r\nwritel((cs->base & 0xffff0000) |\r\n(cs->mbus_attr << 8) |\r\ndram->mbus_dram_target_id, xor_base + WINDOW_BASE(i));\r\nwritel((cs->size - 1) & 0xffff0000, xor_base + WINDOW_SIZE(i));\r\nwin_enable |= (1 << i);\r\nwin_enable |= 3 << (16 + (2 * i));\r\n}\r\nwritel(win_enable, xor_base + WINDOW_BAR_ENABLE(0));\r\nwritel(win_enable, xor_base + WINDOW_BAR_ENABLE(1));\r\nwritel(0, xor_base + WINDOW_OVERRIDE_CTRL(0));\r\nwritel(0, xor_base + WINDOW_OVERRIDE_CTRL(1));\r\nfor (i = 0; i < CONFIG_NR_CPUS; i++) {\r\ncoherency_wa_buf[i] = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nBUG_ON(!coherency_wa_buf[i]);\r\ncoherency_wa_buf_phys[i] =\r\nvirt_to_phys(coherency_wa_buf[i]);\r\nBUG_ON(!coherency_wa_buf_phys[i]);\r\nwritel(0x444, xor_base + XOR_CONFIG(i));\r\nwritel(128, xor_base + XOR_BLOCK_SIZE(i));\r\nwritel(coherency_wa_buf_phys[i],\r\nxor_base + XOR_DEST_POINTER(i));\r\n}\r\nwritel(0x0, xor_base + XOR_INIT_VALUE_LOW);\r\nwritel(0x0, xor_base + XOR_INIT_VALUE_HIGH);\r\ncoherency_wa_enabled = true;\r\n}\r\nstatic inline void mvebu_hwcc_sync_io_barrier(void)\r\n{\r\nif (coherency_wa_enabled) {\r\nmvebu_hwcc_armada375_sync_io_barrier_wa();\r\nreturn;\r\n}\r\nwritel(0x1, coherency_cpu_base + IO_SYNC_BARRIER_CTL_OFFSET);\r\nwhile (readl(coherency_cpu_base + IO_SYNC_BARRIER_CTL_OFFSET) & 0x1);\r\n}\r\nstatic dma_addr_t mvebu_hwcc_dma_map_page(struct device *dev, struct page *page,\r\nunsigned long offset, size_t size,\r\nenum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nif (dir != DMA_TO_DEVICE)\r\nmvebu_hwcc_sync_io_barrier();\r\nreturn pfn_to_dma(dev, page_to_pfn(page)) + offset;\r\n}\r\nstatic void mvebu_hwcc_dma_unmap_page(struct device *dev, dma_addr_t dma_handle,\r\nsize_t size, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nif (dir != DMA_TO_DEVICE)\r\nmvebu_hwcc_sync_io_barrier();\r\n}\r\nstatic void mvebu_hwcc_dma_sync(struct device *dev, dma_addr_t dma_handle,\r\nsize_t size, enum dma_data_direction dir)\r\n{\r\nif (dir != DMA_TO_DEVICE)\r\nmvebu_hwcc_sync_io_barrier();\r\n}\r\nstatic int mvebu_hwcc_notifier(struct notifier_block *nb,\r\nunsigned long event, void *__dev)\r\n{\r\nstruct device *dev = __dev;\r\nif (event != BUS_NOTIFY_ADD_DEVICE)\r\nreturn NOTIFY_DONE;\r\nset_dma_ops(dev, &mvebu_hwcc_dma_ops);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void __init armada_370_coherency_init(struct device_node *np)\r\n{\r\nstruct resource res;\r\nof_address_to_resource(np, 0, &res);\r\ncoherency_phys_base = res.start;\r\nsync_cache_w(&coherency_phys_base);\r\ncoherency_base = of_iomap(np, 0);\r\ncoherency_cpu_base = of_iomap(np, 1);\r\nset_cpu_coherent();\r\n}\r\nstatic void __iomem *\r\narmada_pcie_wa_ioremap_caller(phys_addr_t phys_addr, size_t size,\r\nunsigned int mtype, void *caller)\r\n{\r\nstruct resource pcie_mem;\r\nmvebu_mbus_get_pcie_mem_aperture(&pcie_mem);\r\nif (pcie_mem.start <= phys_addr && (phys_addr + size) <= pcie_mem.end)\r\nmtype = MT_UNCACHED;\r\nreturn __arm_ioremap_caller(phys_addr, size, mtype, caller);\r\n}\r\nstatic void __init armada_375_380_coherency_init(struct device_node *np)\r\n{\r\nstruct device_node *cache_dn;\r\ncoherency_cpu_base = of_iomap(np, 0);\r\narch_ioremap_caller = armada_pcie_wa_ioremap_caller;\r\nfor_each_compatible_node(cache_dn, NULL, "arm,pl310-cache") {\r\nstruct property *p;\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\np->name = kstrdup("arm,io-coherent", GFP_KERNEL);\r\nof_add_property(cache_dn, p);\r\n}\r\n}\r\nstatic int coherency_type(void)\r\n{\r\nstruct device_node *np;\r\nconst struct of_device_id *match;\r\nnp = of_find_matching_node_and_match(NULL, of_coherency_table, &match);\r\nif (np) {\r\nint type = (int) match->data;\r\nif (type == COHERENCY_FABRIC_TYPE_ARMADA_370_XP)\r\nreturn type;\r\nelse if (type == COHERENCY_FABRIC_TYPE_ARMADA_375 && is_smp())\r\nreturn type;\r\nelse if (type == COHERENCY_FABRIC_TYPE_ARMADA_380 && is_smp())\r\nreturn type;\r\n}\r\nreturn COHERENCY_FABRIC_TYPE_NONE;\r\n}\r\nint coherency_available(void)\r\n{\r\nreturn coherency_type() != COHERENCY_FABRIC_TYPE_NONE;\r\n}\r\nint __init coherency_init(void)\r\n{\r\nint type = coherency_type();\r\nstruct device_node *np;\r\nnp = of_find_matching_node(NULL, of_coherency_table);\r\nif (type == COHERENCY_FABRIC_TYPE_ARMADA_370_XP)\r\narmada_370_coherency_init(np);\r\nelse if (type == COHERENCY_FABRIC_TYPE_ARMADA_375 ||\r\ntype == COHERENCY_FABRIC_TYPE_ARMADA_380)\r\narmada_375_380_coherency_init(np);\r\nreturn 0;\r\n}\r\nstatic int __init coherency_late_init(void)\r\n{\r\nint type = coherency_type();\r\nif (type == COHERENCY_FABRIC_TYPE_NONE)\r\nreturn 0;\r\nif (type == COHERENCY_FABRIC_TYPE_ARMADA_375) {\r\nu32 dev, rev;\r\nif (mvebu_get_soc_id(&dev, &rev) == 0 &&\r\nrev == ARMADA_375_Z1_REV)\r\narmada_375_coherency_init_wa();\r\n}\r\nbus_register_notifier(&platform_bus_type,\r\n&mvebu_hwcc_nb);\r\nreturn 0;\r\n}\r\nstatic int __init coherency_pci_init(void)\r\n{\r\nif (coherency_available())\r\nbus_register_notifier(&pci_bus_type,\r\n&mvebu_hwcc_pci_nb);\r\nreturn 0;\r\n}
