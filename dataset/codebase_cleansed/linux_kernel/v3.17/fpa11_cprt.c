unsigned int EmulateCPRT(const unsigned int opcode)\r\n{\r\nif (opcode & 0x800000) {\r\nreturn PerformComparison(opcode);\r\n}\r\nswitch ((opcode & 0x700000) >> 20) {\r\ncase FLT_CODE >> 20:\r\nreturn PerformFLT(opcode);\r\nbreak;\r\ncase FIX_CODE >> 20:\r\nreturn PerformFIX(opcode);\r\nbreak;\r\ncase WFS_CODE >> 20:\r\nwriteFPSR(readRegister(getRd(opcode)));\r\nbreak;\r\ncase RFS_CODE >> 20:\r\nwriteRegister(getRd(opcode), readFPSR());\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nunsigned int PerformFLT(const unsigned int opcode)\r\n{\r\nFPA11 *fpa11 = GET_FPA11();\r\nstruct roundingData roundData;\r\nroundData.mode = SetRoundingMode(opcode);\r\nroundData.precision = SetRoundingPrecision(opcode);\r\nroundData.exception = 0;\r\nswitch (opcode & MASK_ROUNDING_PRECISION) {\r\ncase ROUND_SINGLE:\r\n{\r\nfpa11->fType[getFn(opcode)] = typeSingle;\r\nfpa11->fpreg[getFn(opcode)].fSingle = int32_to_float32(&roundData, readRegister(getRd(opcode)));\r\n}\r\nbreak;\r\ncase ROUND_DOUBLE:\r\n{\r\nfpa11->fType[getFn(opcode)] = typeDouble;\r\nfpa11->fpreg[getFn(opcode)].fDouble = int32_to_float64(readRegister(getRd(opcode)));\r\n}\r\nbreak;\r\n#ifdef CONFIG_FPE_NWFPE_XP\r\ncase ROUND_EXTENDED:\r\n{\r\nfpa11->fType[getFn(opcode)] = typeExtended;\r\nfpa11->fpreg[getFn(opcode)].fExtended = int32_to_floatx80(readRegister(getRd(opcode)));\r\n}\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn 0;\r\n}\r\nif (roundData.exception)\r\nfloat_raise(roundData.exception);\r\nreturn 1;\r\n}\r\nunsigned int PerformFIX(const unsigned int opcode)\r\n{\r\nFPA11 *fpa11 = GET_FPA11();\r\nunsigned int Fn = getFm(opcode);\r\nstruct roundingData roundData;\r\nroundData.mode = SetRoundingMode(opcode);\r\nroundData.precision = SetRoundingPrecision(opcode);\r\nroundData.exception = 0;\r\nswitch (fpa11->fType[Fn]) {\r\ncase typeSingle:\r\n{\r\nwriteRegister(getRd(opcode), float32_to_int32(&roundData, fpa11->fpreg[Fn].fSingle));\r\n}\r\nbreak;\r\ncase typeDouble:\r\n{\r\nwriteRegister(getRd(opcode), float64_to_int32(&roundData, fpa11->fpreg[Fn].fDouble));\r\n}\r\nbreak;\r\n#ifdef CONFIG_FPE_NWFPE_XP\r\ncase typeExtended:\r\n{\r\nwriteRegister(getRd(opcode), floatx80_to_int32(&roundData, fpa11->fpreg[Fn].fExtended));\r\n}\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn 0;\r\n}\r\nif (roundData.exception)\r\nfloat_raise(roundData.exception);\r\nreturn 1;\r\n}\r\nstatic unsigned int PerformComparison(const unsigned int opcode)\r\n{\r\nFPA11 *fpa11 = GET_FPA11();\r\nunsigned int Fn = getFn(opcode), Fm = getFm(opcode);\r\nint e_flag = opcode & 0x400000;\r\nint n_flag = opcode & 0x200000;\r\nunsigned int flags = 0;\r\n#ifdef CONFIG_FPE_NWFPE_XP\r\nfloatx80 rFn, rFm;\r\nswitch (fpa11->fType[Fn]) {\r\ncase typeSingle:\r\nif (float32_is_nan(fpa11->fpreg[Fn].fSingle))\r\ngoto unordered;\r\nrFn = float32_to_floatx80(fpa11->fpreg[Fn].fSingle);\r\nbreak;\r\ncase typeDouble:\r\nif (float64_is_nan(fpa11->fpreg[Fn].fDouble))\r\ngoto unordered;\r\nrFn = float64_to_floatx80(fpa11->fpreg[Fn].fDouble);\r\nbreak;\r\ncase typeExtended:\r\nif (floatx80_is_nan(fpa11->fpreg[Fn].fExtended))\r\ngoto unordered;\r\nrFn = fpa11->fpreg[Fn].fExtended;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (CONSTANT_FM(opcode)) {\r\nrFm = getExtendedConstant(Fm);\r\nif (floatx80_is_nan(rFm))\r\ngoto unordered;\r\n} else {\r\nswitch (fpa11->fType[Fm]) {\r\ncase typeSingle:\r\nif (float32_is_nan(fpa11->fpreg[Fm].fSingle))\r\ngoto unordered;\r\nrFm = float32_to_floatx80(fpa11->fpreg[Fm].fSingle);\r\nbreak;\r\ncase typeDouble:\r\nif (float64_is_nan(fpa11->fpreg[Fm].fDouble))\r\ngoto unordered;\r\nrFm = float64_to_floatx80(fpa11->fpreg[Fm].fDouble);\r\nbreak;\r\ncase typeExtended:\r\nif (floatx80_is_nan(fpa11->fpreg[Fm].fExtended))\r\ngoto unordered;\r\nrFm = fpa11->fpreg[Fm].fExtended;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nif (n_flag)\r\nrFm.high ^= 0x8000;\r\nif (floatx80_lt(rFn, rFm))\r\nflags |= CC_NEGATIVE;\r\nif (floatx80_eq(rFn, rFm))\r\nflags |= CC_ZERO;\r\nif (floatx80_lt(rFm, rFn))\r\nflags |= CC_CARRY;\r\n#else\r\nif (CONSTANT_FM(opcode)) {\r\nif (fpa11->fType[Fn] == typeSingle) {\r\nfloat32 rFm = getSingleConstant(Fm);\r\nfloat32 rFn = fpa11->fpreg[Fn].fSingle;\r\nif (float32_is_nan(rFn))\r\ngoto unordered;\r\nif (n_flag)\r\nrFm ^= 0x80000000;\r\nif (float32_lt_nocheck(rFn, rFm))\r\nflags |= CC_NEGATIVE;\r\nif (float32_eq_nocheck(rFn, rFm))\r\nflags |= CC_ZERO;\r\nif (float32_lt_nocheck(rFm, rFn))\r\nflags |= CC_CARRY;\r\n} else {\r\nfloat64 rFm = getDoubleConstant(Fm);\r\nfloat64 rFn = fpa11->fpreg[Fn].fDouble;\r\nif (float64_is_nan(rFn))\r\ngoto unordered;\r\nif (n_flag)\r\nrFm ^= 0x8000000000000000ULL;\r\nif (float64_lt_nocheck(rFn, rFm))\r\nflags |= CC_NEGATIVE;\r\nif (float64_eq_nocheck(rFn, rFm))\r\nflags |= CC_ZERO;\r\nif (float64_lt_nocheck(rFm, rFn))\r\nflags |= CC_CARRY;\r\n}\r\n} else {\r\nif (fpa11->fType[Fn] == typeSingle\r\n&& fpa11->fType[Fm] == typeSingle) {\r\nfloat32 rFm = fpa11->fpreg[Fm].fSingle;\r\nfloat32 rFn = fpa11->fpreg[Fn].fSingle;\r\nif (float32_is_nan(rFn)\r\n|| float32_is_nan(rFm))\r\ngoto unordered;\r\nif (n_flag)\r\nrFm ^= 0x80000000;\r\nif (float32_lt_nocheck(rFn, rFm))\r\nflags |= CC_NEGATIVE;\r\nif (float32_eq_nocheck(rFn, rFm))\r\nflags |= CC_ZERO;\r\nif (float32_lt_nocheck(rFm, rFn))\r\nflags |= CC_CARRY;\r\n} else {\r\nfloat64 rFm, rFn;\r\nrFm = (fpa11->fType[Fm] == typeSingle) ?\r\nfloat32_to_float64(fpa11->fpreg[Fm].fSingle)\r\n: fpa11->fpreg[Fm].fDouble;\r\nrFn = (fpa11->fType[Fn] == typeSingle) ?\r\nfloat32_to_float64(fpa11->fpreg[Fn].fSingle)\r\n: fpa11->fpreg[Fn].fDouble;\r\nif (float64_is_nan(rFn)\r\n|| float64_is_nan(rFm))\r\ngoto unordered;\r\nif (n_flag)\r\nrFm ^= 0x8000000000000000ULL;\r\nif (float64_lt_nocheck(rFn, rFm))\r\nflags |= CC_NEGATIVE;\r\nif (float64_eq_nocheck(rFn, rFm))\r\nflags |= CC_ZERO;\r\nif (float64_lt_nocheck(rFm, rFn))\r\nflags |= CC_CARRY;\r\n}\r\n}\r\n#endif\r\nwriteConditionCodes(flags);\r\nreturn 1;\r\nunordered:\r\nflags |= CC_OVERFLOW;\r\nflags &= ~(CC_ZERO | CC_NEGATIVE);\r\nif (BIT_AC & readFPSR())\r\nflags |= CC_CARRY;\r\nif (e_flag)\r\nfloat_raise(float_flag_invalid);\r\nwriteConditionCodes(flags);\r\nreturn 1;\r\n}
