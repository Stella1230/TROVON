int cx18_claim_stream(struct cx18_open_id *id, int type)\r\n{\r\nstruct cx18 *cx = id->cx;\r\nstruct cx18_stream *s = &cx->streams[type];\r\nstruct cx18_stream *s_assoc;\r\nif (type == CX18_ENC_STREAM_TYPE_IDX) {\r\nCX18_WARN("MPEG Index stream cannot be claimed "\r\n"directly, but something tried.\n");\r\nreturn -EINVAL;\r\n}\r\nif (test_and_set_bit(CX18_F_S_CLAIMED, &s->s_flags)) {\r\nif (s->id == id->open_id) {\r\nreturn 0;\r\n}\r\nif (s->id == -1 && type == CX18_ENC_STREAM_TYPE_VBI) {\r\ns->id = id->open_id;\r\nCX18_DEBUG_INFO("Start Read VBI\n");\r\nreturn 0;\r\n}\r\nCX18_DEBUG_INFO("Stream %d is busy\n", type);\r\nreturn -EBUSY;\r\n}\r\ns->id = id->open_id;\r\nif (type != CX18_ENC_STREAM_TYPE_MPG)\r\nreturn 0;\r\ns_assoc = &cx->streams[CX18_ENC_STREAM_TYPE_IDX];\r\nif (cx->vbi.insert_mpeg && !cx18_raw_vbi(cx))\r\ns_assoc = &cx->streams[CX18_ENC_STREAM_TYPE_VBI];\r\nelse if (!cx18_stream_enabled(s_assoc))\r\nreturn 0;\r\nset_bit(CX18_F_S_CLAIMED, &s_assoc->s_flags);\r\nset_bit(CX18_F_S_INTERNAL_USE, &s_assoc->s_flags);\r\nreturn 0;\r\n}\r\nvoid cx18_release_stream(struct cx18_stream *s)\r\n{\r\nstruct cx18 *cx = s->cx;\r\nstruct cx18_stream *s_assoc;\r\ns->id = -1;\r\nif (s->type == CX18_ENC_STREAM_TYPE_IDX) {\r\nreturn;\r\n}\r\nif (s->type == CX18_ENC_STREAM_TYPE_VBI &&\r\ntest_bit(CX18_F_S_INTERNAL_USE, &s->s_flags)) {\r\nreturn;\r\n}\r\nif (!test_and_clear_bit(CX18_F_S_CLAIMED, &s->s_flags)) {\r\nCX18_DEBUG_WARN("Release stream %s not in use!\n", s->name);\r\nreturn;\r\n}\r\ncx18_flush_queues(s);\r\nif (s->type != CX18_ENC_STREAM_TYPE_MPG)\r\nreturn;\r\ns_assoc = &cx->streams[CX18_ENC_STREAM_TYPE_IDX];\r\nif (test_and_clear_bit(CX18_F_S_INTERNAL_USE, &s_assoc->s_flags)) {\r\nclear_bit(CX18_F_S_CLAIMED, &s_assoc->s_flags);\r\ncx18_flush_queues(s_assoc);\r\n}\r\ns_assoc = &cx->streams[CX18_ENC_STREAM_TYPE_VBI];\r\nif (test_and_clear_bit(CX18_F_S_INTERNAL_USE, &s_assoc->s_flags)) {\r\nif (s_assoc->id == -1) {\r\nclear_bit(CX18_F_S_CLAIMED, &s_assoc->s_flags);\r\ncx18_flush_queues(s_assoc);\r\n}\r\n}\r\n}\r\nstatic void cx18_dualwatch(struct cx18 *cx)\r\n{\r\nstruct v4l2_tuner vt;\r\nu32 new_stereo_mode;\r\nconst u32 dual = 0x0200;\r\nnew_stereo_mode = v4l2_ctrl_g_ctrl(cx->cxhdl.audio_mode);\r\nmemset(&vt, 0, sizeof(vt));\r\ncx18_call_all(cx, tuner, g_tuner, &vt);\r\nif (vt.audmode == V4L2_TUNER_MODE_LANG1_LANG2 &&\r\n(vt.rxsubchans & V4L2_TUNER_SUB_LANG2))\r\nnew_stereo_mode = dual;\r\nif (new_stereo_mode == cx->dualwatch_stereo_mode)\r\nreturn;\r\nCX18_DEBUG_INFO("dualwatch: change stereo flag from 0x%x to 0x%x.\n",\r\ncx->dualwatch_stereo_mode, new_stereo_mode);\r\nif (v4l2_ctrl_s_ctrl(cx->cxhdl.audio_mode, new_stereo_mode))\r\nCX18_DEBUG_INFO("dualwatch: changing stereo flag failed\n");\r\n}\r\nstatic struct cx18_mdl *cx18_get_mdl(struct cx18_stream *s, int non_block,\r\nint *err)\r\n{\r\nstruct cx18 *cx = s->cx;\r\nstruct cx18_stream *s_vbi = &cx->streams[CX18_ENC_STREAM_TYPE_VBI];\r\nstruct cx18_mdl *mdl;\r\nDEFINE_WAIT(wait);\r\n*err = 0;\r\nwhile (1) {\r\nif (s->type == CX18_ENC_STREAM_TYPE_MPG) {\r\nif (time_after(jiffies, cx->dualwatch_jiffies + msecs_to_jiffies(1000))) {\r\ncx->dualwatch_jiffies = jiffies;\r\ncx18_dualwatch(cx);\r\n}\r\nif (test_bit(CX18_F_S_INTERNAL_USE, &s_vbi->s_flags) &&\r\n!test_bit(CX18_F_S_APPL_IO, &s_vbi->s_flags)) {\r\nwhile ((mdl = cx18_dequeue(s_vbi,\r\n&s_vbi->q_full))) {\r\ncx18_process_vbi_data(cx, mdl,\r\ns_vbi->type);\r\ncx18_stream_put_mdl_fw(s_vbi, mdl);\r\n}\r\n}\r\nmdl = &cx->vbi.sliced_mpeg_mdl;\r\nif (mdl->readpos != mdl->bytesused)\r\nreturn mdl;\r\n}\r\nmdl = cx18_dequeue(s, &s->q_full);\r\nif (mdl) {\r\nif (!test_and_clear_bit(CX18_F_M_NEED_SWAP,\r\n&mdl->m_flags))\r\nreturn mdl;\r\nif (s->type == CX18_ENC_STREAM_TYPE_MPG)\r\ncx18_mdl_swap(mdl);\r\nelse {\r\ncx18_process_vbi_data(cx, mdl, s->type);\r\n}\r\nreturn mdl;\r\n}\r\nif (!test_bit(CX18_F_S_STREAMING, &s->s_flags)) {\r\nCX18_DEBUG_INFO("EOS %s\n", s->name);\r\nreturn NULL;\r\n}\r\nif (non_block) {\r\n*err = -EAGAIN;\r\nreturn NULL;\r\n}\r\nprepare_to_wait(&s->waitq, &wait, TASK_INTERRUPTIBLE);\r\nif (!atomic_read(&s->q_full.depth))\r\nschedule();\r\nfinish_wait(&s->waitq, &wait);\r\nif (signal_pending(current)) {\r\nCX18_DEBUG_INFO("User stopped %s\n", s->name);\r\n*err = -EINTR;\r\nreturn NULL;\r\n}\r\n}\r\n}\r\nstatic void cx18_setup_sliced_vbi_mdl(struct cx18 *cx)\r\n{\r\nstruct cx18_mdl *mdl = &cx->vbi.sliced_mpeg_mdl;\r\nstruct cx18_buffer *buf = &cx->vbi.sliced_mpeg_buf;\r\nint idx = cx->vbi.inserted_frame % CX18_VBI_FRAMES;\r\nbuf->buf = cx->vbi.sliced_mpeg_data[idx];\r\nbuf->bytesused = cx->vbi.sliced_mpeg_size[idx];\r\nbuf->readpos = 0;\r\nmdl->curr_buf = NULL;\r\nmdl->bytesused = cx->vbi.sliced_mpeg_size[idx];\r\nmdl->readpos = 0;\r\n}\r\nstatic size_t cx18_copy_buf_to_user(struct cx18_stream *s,\r\nstruct cx18_buffer *buf, char __user *ubuf, size_t ucount, bool *stop)\r\n{\r\nstruct cx18 *cx = s->cx;\r\nsize_t len = buf->bytesused - buf->readpos;\r\n*stop = false;\r\nif (len > ucount)\r\nlen = ucount;\r\nif (cx->vbi.insert_mpeg && s->type == CX18_ENC_STREAM_TYPE_MPG &&\r\n!cx18_raw_vbi(cx) && buf != &cx->vbi.sliced_mpeg_buf) {\r\nconst char *start = buf->buf + buf->readpos;\r\nconst char *p = start + 1;\r\nconst u8 *q;\r\nu8 ch = cx->search_pack_header ? 0xba : 0xe0;\r\nint stuffing, i;\r\nwhile (start + len > p) {\r\nq = memchr(p, 0, start + len - p);\r\nif (q == NULL)\r\nbreak;\r\np = q + 1;\r\nif ((char *)q + 15 >= buf->buf + buf->bytesused ||\r\nq[1] != 0 || q[2] != 1 || q[3] != ch)\r\ncontinue;\r\nif (!cx->search_pack_header) {\r\nif ((q[6] & 0xc0) != 0x80)\r\ncontinue;\r\nif (((q[7] & 0xc0) == 0x80 &&\r\n(q[9] & 0xf0) == 0x20) ||\r\n((q[7] & 0xc0) == 0xc0 &&\r\n(q[9] & 0xf0) == 0x30)) {\r\nch = 0xba;\r\ncx->search_pack_header = 1;\r\np = q + 9;\r\n}\r\ncontinue;\r\n}\r\nstuffing = q[13] & 7;\r\nfor (i = 0; i < stuffing; i++)\r\nif (q[14 + i] != 0xff)\r\nbreak;\r\nif (i == stuffing &&\r\n(q[4] & 0xc4) == 0x44 &&\r\n(q[12] & 3) == 3 &&\r\nq[14 + stuffing] == 0 &&\r\nq[15 + stuffing] == 0 &&\r\nq[16 + stuffing] == 1) {\r\ncx->search_pack_header = 0;\r\nlen = (char *)q - start;\r\ncx18_setup_sliced_vbi_mdl(cx);\r\n*stop = true;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (copy_to_user(ubuf, (u8 *)buf->buf + buf->readpos, len)) {\r\nCX18_DEBUG_WARN("copy %zd bytes to user failed for %s\n",\r\nlen, s->name);\r\nreturn -EFAULT;\r\n}\r\nbuf->readpos += len;\r\nif (s->type == CX18_ENC_STREAM_TYPE_MPG &&\r\nbuf != &cx->vbi.sliced_mpeg_buf)\r\ncx->mpg_data_received += len;\r\nreturn len;\r\n}\r\nstatic size_t cx18_copy_mdl_to_user(struct cx18_stream *s,\r\nstruct cx18_mdl *mdl, char __user *ubuf, size_t ucount)\r\n{\r\nsize_t tot_written = 0;\r\nint rc;\r\nbool stop = false;\r\nif (mdl->curr_buf == NULL)\r\nmdl->curr_buf = list_first_entry(&mdl->buf_list,\r\nstruct cx18_buffer, list);\r\nif (list_entry_is_past_end(mdl->curr_buf, &mdl->buf_list, list)) {\r\nmdl->readpos = mdl->bytesused;\r\nreturn 0;\r\n}\r\nlist_for_each_entry_from(mdl->curr_buf, &mdl->buf_list, list) {\r\nif (mdl->curr_buf->readpos >= mdl->curr_buf->bytesused)\r\ncontinue;\r\nrc = cx18_copy_buf_to_user(s, mdl->curr_buf, ubuf + tot_written,\r\nucount - tot_written, &stop);\r\nif (rc < 0)\r\nreturn rc;\r\nmdl->readpos += rc;\r\ntot_written += rc;\r\nif (stop ||\r\ntot_written >= ucount ||\r\nmdl->curr_buf->readpos < mdl->curr_buf->bytesused ||\r\nmdl->readpos >= mdl->bytesused)\r\nbreak;\r\n}\r\nreturn tot_written;\r\n}\r\nstatic ssize_t cx18_read(struct cx18_stream *s, char __user *ubuf,\r\nsize_t tot_count, int non_block)\r\n{\r\nstruct cx18 *cx = s->cx;\r\nsize_t tot_written = 0;\r\nint single_frame = 0;\r\nif (atomic_read(&cx->ana_capturing) == 0 && s->id == -1) {\r\nCX18_DEBUG_WARN("Stream %s not initialized before read\n",\r\ns->name);\r\nreturn -EIO;\r\n}\r\nif (s->type == CX18_ENC_STREAM_TYPE_VBI && !cx18_raw_vbi(cx))\r\nsingle_frame = 1;\r\nfor (;;) {\r\nstruct cx18_mdl *mdl;\r\nint rc;\r\nmdl = cx18_get_mdl(s, non_block, &rc);\r\nif (mdl == NULL) {\r\nif (tot_written)\r\nbreak;\r\nif (rc == 0) {\r\nclear_bit(CX18_F_S_STREAMOFF, &s->s_flags);\r\nclear_bit(CX18_F_S_APPL_IO, &s->s_flags);\r\ncx18_release_stream(s);\r\n}\r\nreturn rc;\r\n}\r\nrc = cx18_copy_mdl_to_user(s, mdl, ubuf + tot_written,\r\ntot_count - tot_written);\r\nif (mdl != &cx->vbi.sliced_mpeg_mdl) {\r\nif (mdl->readpos == mdl->bytesused)\r\ncx18_stream_put_mdl_fw(s, mdl);\r\nelse\r\ncx18_push(s, mdl, &s->q_full);\r\n} else if (mdl->readpos == mdl->bytesused) {\r\nint idx = cx->vbi.inserted_frame % CX18_VBI_FRAMES;\r\ncx->vbi.sliced_mpeg_size[idx] = 0;\r\ncx->vbi.inserted_frame++;\r\ncx->vbi_data_inserted += mdl->bytesused;\r\n}\r\nif (rc < 0)\r\nreturn rc;\r\ntot_written += rc;\r\nif (tot_written == tot_count || single_frame)\r\nbreak;\r\n}\r\nreturn tot_written;\r\n}\r\nstatic ssize_t cx18_read_pos(struct cx18_stream *s, char __user *ubuf,\r\nsize_t count, loff_t *pos, int non_block)\r\n{\r\nssize_t rc = count ? cx18_read(s, ubuf, count, non_block) : 0;\r\nstruct cx18 *cx = s->cx;\r\nCX18_DEBUG_HI_FILE("read %zd from %s, got %zd\n", count, s->name, rc);\r\nif (rc > 0)\r\npos += rc;\r\nreturn rc;\r\n}\r\nint cx18_start_capture(struct cx18_open_id *id)\r\n{\r\nstruct cx18 *cx = id->cx;\r\nstruct cx18_stream *s = &cx->streams[id->type];\r\nstruct cx18_stream *s_vbi;\r\nstruct cx18_stream *s_idx;\r\nif (s->type == CX18_ENC_STREAM_TYPE_RAD) {\r\nreturn -EPERM;\r\n}\r\nif (cx18_claim_stream(id, s->type))\r\nreturn -EBUSY;\r\nif (test_bit(CX18_F_S_STREAMOFF, &s->s_flags) ||\r\ntest_and_set_bit(CX18_F_S_STREAMING, &s->s_flags)) {\r\nset_bit(CX18_F_S_APPL_IO, &s->s_flags);\r\nreturn 0;\r\n}\r\ns_vbi = &cx->streams[CX18_ENC_STREAM_TYPE_VBI];\r\ns_idx = &cx->streams[CX18_ENC_STREAM_TYPE_IDX];\r\nif (s->type == CX18_ENC_STREAM_TYPE_MPG) {\r\nif (test_bit(CX18_F_S_INTERNAL_USE, &s_idx->s_flags) &&\r\n!test_and_set_bit(CX18_F_S_STREAMING, &s_idx->s_flags)) {\r\nif (cx18_start_v4l2_encode_stream(s_idx)) {\r\nCX18_DEBUG_WARN("IDX capture start failed\n");\r\nclear_bit(CX18_F_S_STREAMING, &s_idx->s_flags);\r\ngoto start_failed;\r\n}\r\nCX18_DEBUG_INFO("IDX capture started\n");\r\n}\r\nif (test_bit(CX18_F_S_INTERNAL_USE, &s_vbi->s_flags) &&\r\n!test_and_set_bit(CX18_F_S_STREAMING, &s_vbi->s_flags)) {\r\nif (cx18_start_v4l2_encode_stream(s_vbi)) {\r\nCX18_DEBUG_WARN("VBI capture start failed\n");\r\nclear_bit(CX18_F_S_STREAMING, &s_vbi->s_flags);\r\ngoto start_failed;\r\n}\r\nCX18_DEBUG_INFO("VBI insertion started\n");\r\n}\r\n}\r\nif (!cx18_start_v4l2_encode_stream(s)) {\r\nset_bit(CX18_F_S_APPL_IO, &s->s_flags);\r\nif (test_and_clear_bit(CX18_F_I_ENC_PAUSED, &cx->i_flags))\r\ncx18_vapi(cx, CX18_CPU_CAPTURE_PAUSE, 1, s->handle);\r\nreturn 0;\r\n}\r\nstart_failed:\r\nCX18_DEBUG_WARN("Failed to start capturing for stream %s\n", s->name);\r\nif (s->type == CX18_ENC_STREAM_TYPE_MPG) {\r\nif (test_bit(CX18_F_S_STREAMING, &s_idx->s_flags)) {\r\ncx18_stop_v4l2_encode_stream(s_idx, 0);\r\nclear_bit(CX18_F_S_STREAMING, &s_idx->s_flags);\r\n}\r\nif (test_bit(CX18_F_S_STREAMING, &s_vbi->s_flags) &&\r\n!test_bit(CX18_F_S_APPL_IO, &s_vbi->s_flags)) {\r\ncx18_stop_v4l2_encode_stream(s_vbi, 0);\r\nclear_bit(CX18_F_S_STREAMING, &s_vbi->s_flags);\r\n}\r\n}\r\nclear_bit(CX18_F_S_STREAMING, &s->s_flags);\r\ncx18_release_stream(s);\r\nreturn -EIO;\r\n}\r\nssize_t cx18_v4l2_read(struct file *filp, char __user *buf, size_t count,\r\nloff_t *pos)\r\n{\r\nstruct cx18_open_id *id = file2id(filp);\r\nstruct cx18 *cx = id->cx;\r\nstruct cx18_stream *s = &cx->streams[id->type];\r\nint rc;\r\nCX18_DEBUG_HI_FILE("read %zd bytes from %s\n", count, s->name);\r\nmutex_lock(&cx->serialize_lock);\r\nrc = cx18_start_capture(id);\r\nmutex_unlock(&cx->serialize_lock);\r\nif (rc)\r\nreturn rc;\r\nif ((s->vb_type == V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\r\n(id->type == CX18_ENC_STREAM_TYPE_YUV)) {\r\nreturn videobuf_read_stream(&s->vbuf_q, buf, count, pos, 0,\r\nfilp->f_flags & O_NONBLOCK);\r\n}\r\nreturn cx18_read_pos(s, buf, count, pos, filp->f_flags & O_NONBLOCK);\r\n}\r\nunsigned int cx18_v4l2_enc_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct cx18_open_id *id = file2id(filp);\r\nstruct cx18 *cx = id->cx;\r\nstruct cx18_stream *s = &cx->streams[id->type];\r\nint eof = test_bit(CX18_F_S_STREAMOFF, &s->s_flags);\r\nif (!eof && !test_bit(CX18_F_S_STREAMING, &s->s_flags)) {\r\nint rc;\r\nmutex_lock(&cx->serialize_lock);\r\nrc = cx18_start_capture(id);\r\nmutex_unlock(&cx->serialize_lock);\r\nif (rc) {\r\nCX18_DEBUG_INFO("Could not start capture for %s (%d)\n",\r\ns->name, rc);\r\nreturn POLLERR;\r\n}\r\nCX18_DEBUG_FILE("Encoder poll started capture\n");\r\n}\r\nif ((s->vb_type == V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\r\n(id->type == CX18_ENC_STREAM_TYPE_YUV)) {\r\nint videobuf_poll = videobuf_poll_stream(filp, &s->vbuf_q, wait);\r\nif (eof && videobuf_poll == POLLERR)\r\nreturn POLLHUP;\r\nelse\r\nreturn videobuf_poll;\r\n}\r\nCX18_DEBUG_HI_FILE("Encoder poll\n");\r\npoll_wait(filp, &s->waitq, wait);\r\nif (atomic_read(&s->q_full.depth))\r\nreturn POLLIN | POLLRDNORM;\r\nif (eof)\r\nreturn POLLHUP;\r\nreturn 0;\r\n}\r\nint cx18_v4l2_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct cx18_open_id *id = file->private_data;\r\nstruct cx18 *cx = id->cx;\r\nstruct cx18_stream *s = &cx->streams[id->type];\r\nint eof = test_bit(CX18_F_S_STREAMOFF, &s->s_flags);\r\nif ((s->vb_type == V4L2_BUF_TYPE_VIDEO_CAPTURE) &&\r\n(id->type == CX18_ENC_STREAM_TYPE_YUV)) {\r\nif (!eof && !test_bit(CX18_F_S_STREAMING, &s->s_flags)) {\r\nint rc;\r\nmutex_lock(&cx->serialize_lock);\r\nrc = cx18_start_capture(id);\r\nmutex_unlock(&cx->serialize_lock);\r\nif (rc) {\r\nCX18_DEBUG_INFO(\r\n"Could not start capture for %s (%d)\n",\r\ns->name, rc);\r\nreturn -EINVAL;\r\n}\r\nCX18_DEBUG_FILE("Encoder mmap started capture\n");\r\n}\r\nreturn videobuf_mmap_mapper(&s->vbuf_q, vma);\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid cx18_vb_timeout(unsigned long data)\r\n{\r\nstruct cx18_stream *s = (struct cx18_stream *)data;\r\nstruct cx18_videobuf_buffer *buf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&s->vb_lock, flags);\r\nwhile (!list_empty(&s->vb_capture)) {\r\nbuf = list_entry(s->vb_capture.next,\r\nstruct cx18_videobuf_buffer, vb.queue);\r\nlist_del(&buf->vb.queue);\r\nbuf->vb.state = VIDEOBUF_ERROR;\r\nwake_up(&buf->vb.done);\r\n}\r\nspin_unlock_irqrestore(&s->vb_lock, flags);\r\n}\r\nvoid cx18_stop_capture(struct cx18_open_id *id, int gop_end)\r\n{\r\nstruct cx18 *cx = id->cx;\r\nstruct cx18_stream *s = &cx->streams[id->type];\r\nstruct cx18_stream *s_vbi = &cx->streams[CX18_ENC_STREAM_TYPE_VBI];\r\nstruct cx18_stream *s_idx = &cx->streams[CX18_ENC_STREAM_TYPE_IDX];\r\nCX18_DEBUG_IOCTL("close() of %s\n", s->name);\r\nif (test_bit(CX18_F_S_STREAMING, &s->s_flags)) {\r\nCX18_DEBUG_INFO("close stopping capture\n");\r\nif (id->type == CX18_ENC_STREAM_TYPE_MPG) {\r\nif (test_bit(CX18_F_S_STREAMING, &s_vbi->s_flags) &&\r\n!test_bit(CX18_F_S_APPL_IO, &s_vbi->s_flags)) {\r\nCX18_DEBUG_INFO("close stopping embedded VBI "\r\n"capture\n");\r\ncx18_stop_v4l2_encode_stream(s_vbi, 0);\r\n}\r\nif (test_bit(CX18_F_S_STREAMING, &s_idx->s_flags)) {\r\nCX18_DEBUG_INFO("close stopping IDX capture\n");\r\ncx18_stop_v4l2_encode_stream(s_idx, 0);\r\n}\r\n}\r\nif (id->type == CX18_ENC_STREAM_TYPE_VBI &&\r\ntest_bit(CX18_F_S_INTERNAL_USE, &s->s_flags))\r\ns->id = -1;\r\nelse\r\ncx18_stop_v4l2_encode_stream(s, gop_end);\r\n}\r\nif (!gop_end) {\r\nclear_bit(CX18_F_S_APPL_IO, &s->s_flags);\r\nclear_bit(CX18_F_S_STREAMOFF, &s->s_flags);\r\ncx18_release_stream(s);\r\n}\r\n}\r\nint cx18_v4l2_close(struct file *filp)\r\n{\r\nstruct v4l2_fh *fh = filp->private_data;\r\nstruct cx18_open_id *id = fh2id(fh);\r\nstruct cx18 *cx = id->cx;\r\nstruct cx18_stream *s = &cx->streams[id->type];\r\nCX18_DEBUG_IOCTL("close() of %s\n", s->name);\r\nmutex_lock(&cx->serialize_lock);\r\nif (id->type == CX18_ENC_STREAM_TYPE_RAD &&\r\nv4l2_fh_is_singular_file(filp)) {\r\ncx18_mute(cx);\r\nclear_bit(CX18_F_I_RADIO_USER, &cx->i_flags);\r\ncx18_call_all(cx, video, s_std, cx->std);\r\ncx18_audio_set_io(cx);\r\nif (atomic_read(&cx->ana_capturing) > 0) {\r\ncx18_vapi(cx, CX18_CPU_SET_VIDEO_MUTE, 2, s->handle,\r\n(v4l2_ctrl_g_ctrl(cx->cxhdl.video_mute) |\r\n(v4l2_ctrl_g_ctrl(cx->cxhdl.video_mute_yuv) << 8)));\r\n}\r\ncx18_unmute(cx);\r\n}\r\nv4l2_fh_del(fh);\r\nv4l2_fh_exit(fh);\r\nif (s->id == id->open_id)\r\ncx18_stop_capture(id, 0);\r\nkfree(id);\r\nmutex_unlock(&cx->serialize_lock);\r\nreturn 0;\r\n}\r\nstatic int cx18_serialized_open(struct cx18_stream *s, struct file *filp)\r\n{\r\nstruct cx18 *cx = s->cx;\r\nstruct cx18_open_id *item;\r\nCX18_DEBUG_FILE("open %s\n", s->name);\r\nitem = kzalloc(sizeof(struct cx18_open_id), GFP_KERNEL);\r\nif (NULL == item) {\r\nCX18_DEBUG_WARN("nomem on v4l2 open\n");\r\nreturn -ENOMEM;\r\n}\r\nv4l2_fh_init(&item->fh, s->video_dev);\r\nitem->cx = cx;\r\nitem->type = s->type;\r\nitem->open_id = cx->open_id++;\r\nfilp->private_data = &item->fh;\r\nv4l2_fh_add(&item->fh);\r\nif (item->type == CX18_ENC_STREAM_TYPE_RAD &&\r\nv4l2_fh_is_singular_file(filp)) {\r\nif (!test_bit(CX18_F_I_RADIO_USER, &cx->i_flags)) {\r\nif (atomic_read(&cx->ana_capturing) > 0) {\r\nv4l2_fh_del(&item->fh);\r\nv4l2_fh_exit(&item->fh);\r\nkfree(item);\r\nreturn -EBUSY;\r\n}\r\n}\r\nset_bit(CX18_F_I_RADIO_USER, &cx->i_flags);\r\ncx18_mute(cx);\r\ncx18_call_all(cx, tuner, s_radio);\r\ncx18_audio_set_io(cx);\r\ncx18_unmute(cx);\r\n}\r\nreturn 0;\r\n}\r\nint cx18_v4l2_open(struct file *filp)\r\n{\r\nint res;\r\nstruct video_device *video_dev = video_devdata(filp);\r\nstruct cx18_stream *s = video_get_drvdata(video_dev);\r\nstruct cx18 *cx = s->cx;\r\nmutex_lock(&cx->serialize_lock);\r\nif (cx18_init_on_first_open(cx)) {\r\nCX18_ERR("Failed to initialize on %s\n",\r\nvideo_device_node_name(video_dev));\r\nmutex_unlock(&cx->serialize_lock);\r\nreturn -ENXIO;\r\n}\r\nres = cx18_serialized_open(s, filp);\r\nmutex_unlock(&cx->serialize_lock);\r\nreturn res;\r\n}\r\nvoid cx18_mute(struct cx18 *cx)\r\n{\r\nu32 h;\r\nif (atomic_read(&cx->ana_capturing)) {\r\nh = cx18_find_handle(cx);\r\nif (h != CX18_INVALID_TASK_HANDLE)\r\ncx18_vapi(cx, CX18_CPU_SET_AUDIO_MUTE, 2, h, 1);\r\nelse\r\nCX18_ERR("Can't find valid task handle for mute\n");\r\n}\r\nCX18_DEBUG_INFO("Mute\n");\r\n}\r\nvoid cx18_unmute(struct cx18 *cx)\r\n{\r\nu32 h;\r\nif (atomic_read(&cx->ana_capturing)) {\r\nh = cx18_find_handle(cx);\r\nif (h != CX18_INVALID_TASK_HANDLE) {\r\ncx18_msleep_timeout(100, 0);\r\ncx18_vapi(cx, CX18_CPU_SET_MISC_PARAMETERS, 2, h, 12);\r\ncx18_vapi(cx, CX18_CPU_SET_AUDIO_MUTE, 2, h, 0);\r\n} else\r\nCX18_ERR("Can't find valid task handle for unmute\n");\r\n}\r\nCX18_DEBUG_INFO("Unmute\n");\r\n}
