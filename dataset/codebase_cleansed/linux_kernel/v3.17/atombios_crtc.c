static void atombios_overscan_setup(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nSET_CRTC_OVERSCAN_PS_ALLOCATION args;\r\nint index = GetIndexIntoMasterTable(COMMAND, SetCRTC_OverScan);\r\nint a1, a2;\r\nmemset(&args, 0, sizeof(args));\r\nargs.ucCRTC = radeon_crtc->crtc_id;\r\nswitch (radeon_crtc->rmx_type) {\r\ncase RMX_CENTER:\r\nargs.usOverscanTop = cpu_to_le16((adjusted_mode->crtc_vdisplay - mode->crtc_vdisplay) / 2);\r\nargs.usOverscanBottom = cpu_to_le16((adjusted_mode->crtc_vdisplay - mode->crtc_vdisplay) / 2);\r\nargs.usOverscanLeft = cpu_to_le16((adjusted_mode->crtc_hdisplay - mode->crtc_hdisplay) / 2);\r\nargs.usOverscanRight = cpu_to_le16((adjusted_mode->crtc_hdisplay - mode->crtc_hdisplay) / 2);\r\nbreak;\r\ncase RMX_ASPECT:\r\na1 = mode->crtc_vdisplay * adjusted_mode->crtc_hdisplay;\r\na2 = adjusted_mode->crtc_vdisplay * mode->crtc_hdisplay;\r\nif (a1 > a2) {\r\nargs.usOverscanLeft = cpu_to_le16((adjusted_mode->crtc_hdisplay - (a2 / mode->crtc_vdisplay)) / 2);\r\nargs.usOverscanRight = cpu_to_le16((adjusted_mode->crtc_hdisplay - (a2 / mode->crtc_vdisplay)) / 2);\r\n} else if (a2 > a1) {\r\nargs.usOverscanTop = cpu_to_le16((adjusted_mode->crtc_vdisplay - (a1 / mode->crtc_hdisplay)) / 2);\r\nargs.usOverscanBottom = cpu_to_le16((adjusted_mode->crtc_vdisplay - (a1 / mode->crtc_hdisplay)) / 2);\r\n}\r\nbreak;\r\ncase RMX_FULL:\r\ndefault:\r\nargs.usOverscanRight = cpu_to_le16(radeon_crtc->h_border);\r\nargs.usOverscanLeft = cpu_to_le16(radeon_crtc->h_border);\r\nargs.usOverscanBottom = cpu_to_le16(radeon_crtc->v_border);\r\nargs.usOverscanTop = cpu_to_le16(radeon_crtc->v_border);\r\nbreak;\r\n}\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nstatic void atombios_scaler_setup(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nENABLE_SCALER_PS_ALLOCATION args;\r\nint index = GetIndexIntoMasterTable(COMMAND, EnableScaler);\r\nstruct radeon_encoder *radeon_encoder =\r\nto_radeon_encoder(radeon_crtc->encoder);\r\nenum radeon_tv_std tv_std = TV_STD_NTSC;\r\nbool is_tv = false, is_cv = false;\r\nif (!ASIC_IS_AVIVO(rdev) && radeon_crtc->crtc_id)\r\nreturn;\r\nif (radeon_encoder->active_device & ATOM_DEVICE_TV_SUPPORT) {\r\nstruct radeon_encoder_atom_dac *tv_dac = radeon_encoder->enc_priv;\r\ntv_std = tv_dac->tv_std;\r\nis_tv = true;\r\n}\r\nmemset(&args, 0, sizeof(args));\r\nargs.ucScaler = radeon_crtc->crtc_id;\r\nif (is_tv) {\r\nswitch (tv_std) {\r\ncase TV_STD_NTSC:\r\ndefault:\r\nargs.ucTVStandard = ATOM_TV_NTSC;\r\nbreak;\r\ncase TV_STD_PAL:\r\nargs.ucTVStandard = ATOM_TV_PAL;\r\nbreak;\r\ncase TV_STD_PAL_M:\r\nargs.ucTVStandard = ATOM_TV_PALM;\r\nbreak;\r\ncase TV_STD_PAL_60:\r\nargs.ucTVStandard = ATOM_TV_PAL60;\r\nbreak;\r\ncase TV_STD_NTSC_J:\r\nargs.ucTVStandard = ATOM_TV_NTSCJ;\r\nbreak;\r\ncase TV_STD_SCART_PAL:\r\nargs.ucTVStandard = ATOM_TV_PAL;\r\nbreak;\r\ncase TV_STD_SECAM:\r\nargs.ucTVStandard = ATOM_TV_SECAM;\r\nbreak;\r\ncase TV_STD_PAL_CN:\r\nargs.ucTVStandard = ATOM_TV_PALCN;\r\nbreak;\r\n}\r\nargs.ucEnable = SCALER_ENABLE_MULTITAP_MODE;\r\n} else if (is_cv) {\r\nargs.ucTVStandard = ATOM_TV_CV;\r\nargs.ucEnable = SCALER_ENABLE_MULTITAP_MODE;\r\n} else {\r\nswitch (radeon_crtc->rmx_type) {\r\ncase RMX_FULL:\r\nargs.ucEnable = ATOM_SCALER_EXPANSION;\r\nbreak;\r\ncase RMX_CENTER:\r\nargs.ucEnable = ATOM_SCALER_CENTER;\r\nbreak;\r\ncase RMX_ASPECT:\r\nargs.ucEnable = ATOM_SCALER_EXPANSION;\r\nbreak;\r\ndefault:\r\nif (ASIC_IS_AVIVO(rdev))\r\nargs.ucEnable = ATOM_SCALER_DISABLE;\r\nelse\r\nargs.ucEnable = ATOM_SCALER_CENTER;\r\nbreak;\r\n}\r\n}\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\nif ((is_tv || is_cv)\r\n&& rdev->family >= CHIP_RV515 && rdev->family <= CHIP_R580) {\r\natom_rv515_force_tv_scaler(rdev, radeon_crtc);\r\n}\r\n}\r\nstatic void atombios_lock_crtc(struct drm_crtc *crtc, int lock)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nint index =\r\nGetIndexIntoMasterTable(COMMAND, UpdateCRTC_DoubleBufferRegisters);\r\nENABLE_CRTC_PS_ALLOCATION args;\r\nmemset(&args, 0, sizeof(args));\r\nargs.ucCRTC = radeon_crtc->crtc_id;\r\nargs.ucEnable = lock;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nstatic void atombios_enable_crtc(struct drm_crtc *crtc, int state)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nint index = GetIndexIntoMasterTable(COMMAND, EnableCRTC);\r\nENABLE_CRTC_PS_ALLOCATION args;\r\nmemset(&args, 0, sizeof(args));\r\nargs.ucCRTC = radeon_crtc->crtc_id;\r\nargs.ucEnable = state;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nstatic void atombios_enable_crtc_memreq(struct drm_crtc *crtc, int state)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nint index = GetIndexIntoMasterTable(COMMAND, EnableCRTCMemReq);\r\nENABLE_CRTC_PS_ALLOCATION args;\r\nmemset(&args, 0, sizeof(args));\r\nargs.ucCRTC = radeon_crtc->crtc_id;\r\nargs.ucEnable = state;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nstatic void atombios_blank_crtc(struct drm_crtc *crtc, int state)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nint index = GetIndexIntoMasterTable(COMMAND, BlankCRTC);\r\nBLANK_CRTC_PS_ALLOCATION args;\r\nu32 vga_control = 0;\r\nmemset(&args, 0, sizeof(args));\r\nif (ASIC_IS_DCE8(rdev)) {\r\nvga_control = RREG32(vga_control_regs[radeon_crtc->crtc_id]);\r\nWREG32(vga_control_regs[radeon_crtc->crtc_id], vga_control | 1);\r\n}\r\nargs.ucCRTC = radeon_crtc->crtc_id;\r\nargs.ucBlanking = state;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\nif (ASIC_IS_DCE8(rdev)) {\r\nWREG32(vga_control_regs[radeon_crtc->crtc_id], vga_control);\r\n}\r\n}\r\nstatic void atombios_powergate_crtc(struct drm_crtc *crtc, int state)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nint index = GetIndexIntoMasterTable(COMMAND, EnableDispPowerGating);\r\nENABLE_DISP_POWER_GATING_PARAMETERS_V2_1 args;\r\nmemset(&args, 0, sizeof(args));\r\nargs.ucDispPipeId = radeon_crtc->crtc_id;\r\nargs.ucEnable = state;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nvoid atombios_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\nradeon_crtc->enabled = true;\r\natombios_enable_crtc(crtc, ATOM_ENABLE);\r\nif (ASIC_IS_DCE3(rdev) && !ASIC_IS_DCE6(rdev))\r\natombios_enable_crtc_memreq(crtc, ATOM_ENABLE);\r\natombios_blank_crtc(crtc, ATOM_DISABLE);\r\ndrm_vblank_post_modeset(dev, radeon_crtc->crtc_id);\r\nradeon_crtc_load_lut(crtc);\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ncase DRM_MODE_DPMS_OFF:\r\ndrm_vblank_pre_modeset(dev, radeon_crtc->crtc_id);\r\nif (radeon_crtc->enabled)\r\natombios_blank_crtc(crtc, ATOM_ENABLE);\r\nif (ASIC_IS_DCE3(rdev) && !ASIC_IS_DCE6(rdev))\r\natombios_enable_crtc_memreq(crtc, ATOM_DISABLE);\r\natombios_enable_crtc(crtc, ATOM_DISABLE);\r\nradeon_crtc->enabled = false;\r\nbreak;\r\n}\r\nradeon_pm_compute_clocks(rdev);\r\n}\r\nstatic void\r\natombios_set_crtc_dtd_timing(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nSET_CRTC_USING_DTD_TIMING_PARAMETERS args;\r\nint index = GetIndexIntoMasterTable(COMMAND, SetCRTC_UsingDTDTiming);\r\nu16 misc = 0;\r\nmemset(&args, 0, sizeof(args));\r\nargs.usH_Size = cpu_to_le16(mode->crtc_hdisplay - (radeon_crtc->h_border * 2));\r\nargs.usH_Blanking_Time =\r\ncpu_to_le16(mode->crtc_hblank_end - mode->crtc_hdisplay + (radeon_crtc->h_border * 2));\r\nargs.usV_Size = cpu_to_le16(mode->crtc_vdisplay - (radeon_crtc->v_border * 2));\r\nargs.usV_Blanking_Time =\r\ncpu_to_le16(mode->crtc_vblank_end - mode->crtc_vdisplay + (radeon_crtc->v_border * 2));\r\nargs.usH_SyncOffset =\r\ncpu_to_le16(mode->crtc_hsync_start - mode->crtc_hdisplay + radeon_crtc->h_border);\r\nargs.usH_SyncWidth =\r\ncpu_to_le16(mode->crtc_hsync_end - mode->crtc_hsync_start);\r\nargs.usV_SyncOffset =\r\ncpu_to_le16(mode->crtc_vsync_start - mode->crtc_vdisplay + radeon_crtc->v_border);\r\nargs.usV_SyncWidth =\r\ncpu_to_le16(mode->crtc_vsync_end - mode->crtc_vsync_start);\r\nargs.ucH_Border = radeon_crtc->h_border;\r\nargs.ucV_Border = radeon_crtc->v_border;\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\nmisc |= ATOM_VSYNC_POLARITY;\r\nif (mode->flags & DRM_MODE_FLAG_NHSYNC)\r\nmisc |= ATOM_HSYNC_POLARITY;\r\nif (mode->flags & DRM_MODE_FLAG_CSYNC)\r\nmisc |= ATOM_COMPOSITESYNC;\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE)\r\nmisc |= ATOM_INTERLACE;\r\nif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\r\nmisc |= ATOM_DOUBLE_CLOCK_MODE;\r\nargs.susModeMiscInfo.usAccess = cpu_to_le16(misc);\r\nargs.ucCRTC = radeon_crtc->crtc_id;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nstatic void atombios_crtc_set_timing(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nSET_CRTC_TIMING_PARAMETERS_PS_ALLOCATION args;\r\nint index = GetIndexIntoMasterTable(COMMAND, SetCRTC_Timing);\r\nu16 misc = 0;\r\nmemset(&args, 0, sizeof(args));\r\nargs.usH_Total = cpu_to_le16(mode->crtc_htotal);\r\nargs.usH_Disp = cpu_to_le16(mode->crtc_hdisplay);\r\nargs.usH_SyncStart = cpu_to_le16(mode->crtc_hsync_start);\r\nargs.usH_SyncWidth =\r\ncpu_to_le16(mode->crtc_hsync_end - mode->crtc_hsync_start);\r\nargs.usV_Total = cpu_to_le16(mode->crtc_vtotal);\r\nargs.usV_Disp = cpu_to_le16(mode->crtc_vdisplay);\r\nargs.usV_SyncStart = cpu_to_le16(mode->crtc_vsync_start);\r\nargs.usV_SyncWidth =\r\ncpu_to_le16(mode->crtc_vsync_end - mode->crtc_vsync_start);\r\nargs.ucOverscanRight = radeon_crtc->h_border;\r\nargs.ucOverscanLeft = radeon_crtc->h_border;\r\nargs.ucOverscanBottom = radeon_crtc->v_border;\r\nargs.ucOverscanTop = radeon_crtc->v_border;\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\nmisc |= ATOM_VSYNC_POLARITY;\r\nif (mode->flags & DRM_MODE_FLAG_NHSYNC)\r\nmisc |= ATOM_HSYNC_POLARITY;\r\nif (mode->flags & DRM_MODE_FLAG_CSYNC)\r\nmisc |= ATOM_COMPOSITESYNC;\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE)\r\nmisc |= ATOM_INTERLACE;\r\nif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\r\nmisc |= ATOM_DOUBLE_CLOCK_MODE;\r\nargs.susModeMiscInfo.usAccess = cpu_to_le16(misc);\r\nargs.ucCRTC = radeon_crtc->crtc_id;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nstatic void atombios_disable_ss(struct radeon_device *rdev, int pll_id)\r\n{\r\nu32 ss_cntl;\r\nif (ASIC_IS_DCE4(rdev)) {\r\nswitch (pll_id) {\r\ncase ATOM_PPLL1:\r\nss_cntl = RREG32(EVERGREEN_P1PLL_SS_CNTL);\r\nss_cntl &= ~EVERGREEN_PxPLL_SS_EN;\r\nWREG32(EVERGREEN_P1PLL_SS_CNTL, ss_cntl);\r\nbreak;\r\ncase ATOM_PPLL2:\r\nss_cntl = RREG32(EVERGREEN_P2PLL_SS_CNTL);\r\nss_cntl &= ~EVERGREEN_PxPLL_SS_EN;\r\nWREG32(EVERGREEN_P2PLL_SS_CNTL, ss_cntl);\r\nbreak;\r\ncase ATOM_DCPLL:\r\ncase ATOM_PPLL_INVALID:\r\nreturn;\r\n}\r\n} else if (ASIC_IS_AVIVO(rdev)) {\r\nswitch (pll_id) {\r\ncase ATOM_PPLL1:\r\nss_cntl = RREG32(AVIVO_P1PLL_INT_SS_CNTL);\r\nss_cntl &= ~1;\r\nWREG32(AVIVO_P1PLL_INT_SS_CNTL, ss_cntl);\r\nbreak;\r\ncase ATOM_PPLL2:\r\nss_cntl = RREG32(AVIVO_P2PLL_INT_SS_CNTL);\r\nss_cntl &= ~1;\r\nWREG32(AVIVO_P2PLL_INT_SS_CNTL, ss_cntl);\r\nbreak;\r\ncase ATOM_DCPLL:\r\ncase ATOM_PPLL_INVALID:\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void atombios_crtc_program_ss(struct radeon_device *rdev,\r\nint enable,\r\nint pll_id,\r\nint crtc_id,\r\nstruct radeon_atom_ss *ss)\r\n{\r\nunsigned i;\r\nint index = GetIndexIntoMasterTable(COMMAND, EnableSpreadSpectrumOnPPLL);\r\nunion atom_enable_ss args;\r\nif (enable) {\r\nif (ss->percentage == 0)\r\nreturn;\r\nif (ss->type & ATOM_EXTERNAL_SS_MASK)\r\nreturn;\r\n} else {\r\nfor (i = 0; i < rdev->num_crtc; i++) {\r\nif (rdev->mode_info.crtcs[i] &&\r\nrdev->mode_info.crtcs[i]->enabled &&\r\ni != crtc_id &&\r\npll_id == rdev->mode_info.crtcs[i]->pll_id) {\r\nreturn;\r\n}\r\n}\r\n}\r\nmemset(&args, 0, sizeof(args));\r\nif (ASIC_IS_DCE5(rdev)) {\r\nargs.v3.usSpreadSpectrumAmountFrac = cpu_to_le16(0);\r\nargs.v3.ucSpreadSpectrumType = ss->type & ATOM_SS_CENTRE_SPREAD_MODE_MASK;\r\nswitch (pll_id) {\r\ncase ATOM_PPLL1:\r\nargs.v3.ucSpreadSpectrumType |= ATOM_PPLL_SS_TYPE_V3_P1PLL;\r\nbreak;\r\ncase ATOM_PPLL2:\r\nargs.v3.ucSpreadSpectrumType |= ATOM_PPLL_SS_TYPE_V3_P2PLL;\r\nbreak;\r\ncase ATOM_DCPLL:\r\nargs.v3.ucSpreadSpectrumType |= ATOM_PPLL_SS_TYPE_V3_DCPLL;\r\nbreak;\r\ncase ATOM_PPLL_INVALID:\r\nreturn;\r\n}\r\nargs.v3.usSpreadSpectrumAmount = cpu_to_le16(ss->amount);\r\nargs.v3.usSpreadSpectrumStep = cpu_to_le16(ss->step);\r\nargs.v3.ucEnable = enable;\r\n} else if (ASIC_IS_DCE4(rdev)) {\r\nargs.v2.usSpreadSpectrumPercentage = cpu_to_le16(ss->percentage);\r\nargs.v2.ucSpreadSpectrumType = ss->type & ATOM_SS_CENTRE_SPREAD_MODE_MASK;\r\nswitch (pll_id) {\r\ncase ATOM_PPLL1:\r\nargs.v2.ucSpreadSpectrumType |= ATOM_PPLL_SS_TYPE_V2_P1PLL;\r\nbreak;\r\ncase ATOM_PPLL2:\r\nargs.v2.ucSpreadSpectrumType |= ATOM_PPLL_SS_TYPE_V2_P2PLL;\r\nbreak;\r\ncase ATOM_DCPLL:\r\nargs.v2.ucSpreadSpectrumType |= ATOM_PPLL_SS_TYPE_V2_DCPLL;\r\nbreak;\r\ncase ATOM_PPLL_INVALID:\r\nreturn;\r\n}\r\nargs.v2.usSpreadSpectrumAmount = cpu_to_le16(ss->amount);\r\nargs.v2.usSpreadSpectrumStep = cpu_to_le16(ss->step);\r\nargs.v2.ucEnable = enable;\r\n} else if (ASIC_IS_DCE3(rdev)) {\r\nargs.v1.usSpreadSpectrumPercentage = cpu_to_le16(ss->percentage);\r\nargs.v1.ucSpreadSpectrumType = ss->type & ATOM_SS_CENTRE_SPREAD_MODE_MASK;\r\nargs.v1.ucSpreadSpectrumStep = ss->step;\r\nargs.v1.ucSpreadSpectrumDelay = ss->delay;\r\nargs.v1.ucSpreadSpectrumRange = ss->range;\r\nargs.v1.ucPpll = pll_id;\r\nargs.v1.ucEnable = enable;\r\n} else if (ASIC_IS_AVIVO(rdev)) {\r\nif ((enable == ATOM_DISABLE) || (ss->percentage == 0) ||\r\n(ss->type & ATOM_EXTERNAL_SS_MASK)) {\r\natombios_disable_ss(rdev, pll_id);\r\nreturn;\r\n}\r\nargs.lvds_ss_2.usSpreadSpectrumPercentage = cpu_to_le16(ss->percentage);\r\nargs.lvds_ss_2.ucSpreadSpectrumType = ss->type & ATOM_SS_CENTRE_SPREAD_MODE_MASK;\r\nargs.lvds_ss_2.ucSpreadSpectrumStep = ss->step;\r\nargs.lvds_ss_2.ucSpreadSpectrumDelay = ss->delay;\r\nargs.lvds_ss_2.ucSpreadSpectrumRange = ss->range;\r\nargs.lvds_ss_2.ucEnable = enable;\r\n} else {\r\nif (enable == ATOM_DISABLE) {\r\natombios_disable_ss(rdev, pll_id);\r\nreturn;\r\n}\r\nargs.lvds_ss.usSpreadSpectrumPercentage = cpu_to_le16(ss->percentage);\r\nargs.lvds_ss.ucSpreadSpectrumType = ss->type & ATOM_SS_CENTRE_SPREAD_MODE_MASK;\r\nargs.lvds_ss.ucSpreadSpectrumStepSize_Delay = (ss->step & 3) << 2;\r\nargs.lvds_ss.ucSpreadSpectrumStepSize_Delay |= (ss->delay & 7) << 4;\r\nargs.lvds_ss.ucEnable = enable;\r\n}\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nstatic u32 atombios_adjust_pll(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct drm_encoder *encoder = radeon_crtc->encoder;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\r\nu32 adjusted_clock = mode->clock;\r\nint encoder_mode = atombios_get_encoder_mode(encoder);\r\nu32 dp_clock = mode->clock;\r\nu32 clock = mode->clock;\r\nint bpc = radeon_crtc->bpc;\r\nbool is_duallink = radeon_dig_monitor_is_duallink(encoder, mode->clock);\r\nradeon_crtc->pll_flags = 0;\r\nif (ASIC_IS_AVIVO(rdev)) {\r\nif ((rdev->family == CHIP_RS600) ||\r\n(rdev->family == CHIP_RS690) ||\r\n(rdev->family == CHIP_RS740))\r\nradeon_crtc->pll_flags |= (\r\nRADEON_PLL_PREFER_CLOSEST_LOWER);\r\nif (ASIC_IS_DCE32(rdev) && mode->clock > 200000)\r\nradeon_crtc->pll_flags |= RADEON_PLL_PREFER_HIGH_FB_DIV;\r\nelse\r\nradeon_crtc->pll_flags |= RADEON_PLL_PREFER_LOW_REF_DIV;\r\nif (rdev->family < CHIP_RV770)\r\nradeon_crtc->pll_flags |= RADEON_PLL_PREFER_MINM_OVER_MAXP;\r\nif (ASIC_IS_DCE41(rdev) || ASIC_IS_DCE61(rdev) || ASIC_IS_DCE8(rdev))\r\nradeon_crtc->pll_flags |= RADEON_PLL_USE_FRAC_FB_DIV;\r\nif ((rdev->family == CHIP_RS780) || (rdev->family == CHIP_RS880))\r\nradeon_crtc->pll_flags |= RADEON_PLL_USE_FRAC_FB_DIV;\r\nif (ASIC_IS_DCE32(rdev) && mode->clock > 165000)\r\nradeon_crtc->pll_flags |= RADEON_PLL_USE_FRAC_FB_DIV;\r\n} else {\r\nradeon_crtc->pll_flags |= RADEON_PLL_LEGACY;\r\nif (mode->clock > 200000)\r\nradeon_crtc->pll_flags |= RADEON_PLL_PREFER_HIGH_FB_DIV;\r\nelse\r\nradeon_crtc->pll_flags |= RADEON_PLL_PREFER_LOW_REF_DIV;\r\n}\r\nif ((radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT | ATOM_DEVICE_DFP_SUPPORT)) ||\r\n(radeon_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE)) {\r\nif (connector) {\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nstruct radeon_connector_atom_dig *dig_connector =\r\nradeon_connector->con_priv;\r\ndp_clock = dig_connector->dp_clock;\r\n}\r\n}\r\nif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\r\nif (radeon_crtc->ss_enabled) {\r\nif (radeon_crtc->ss.refdiv) {\r\nradeon_crtc->pll_flags |= RADEON_PLL_USE_REF_DIV;\r\nradeon_crtc->pll_reference_div = radeon_crtc->ss.refdiv;\r\nif (ASIC_IS_AVIVO(rdev))\r\nradeon_crtc->pll_flags |= RADEON_PLL_USE_FRAC_FB_DIV;\r\n}\r\n}\r\n}\r\nif (ASIC_IS_AVIVO(rdev)) {\r\nif (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1)\r\nadjusted_clock = mode->clock * 2;\r\nif (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT))\r\nradeon_crtc->pll_flags |= RADEON_PLL_PREFER_CLOSEST_LOWER;\r\nif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))\r\nradeon_crtc->pll_flags |= RADEON_PLL_IS_LCD;\r\n} else {\r\nif (encoder->encoder_type != DRM_MODE_ENCODER_DAC)\r\nradeon_crtc->pll_flags |= RADEON_PLL_NO_ODD_POST_DIV;\r\nif (encoder->encoder_type == DRM_MODE_ENCODER_LVDS)\r\nradeon_crtc->pll_flags |= RADEON_PLL_USE_REF_DIV;\r\n}\r\nif (encoder_mode == ATOM_ENCODER_MODE_HDMI) {\r\nswitch (bpc) {\r\ncase 8:\r\ndefault:\r\nbreak;\r\ncase 10:\r\nclock = (clock * 5) / 4;\r\nbreak;\r\ncase 12:\r\nclock = (clock * 3) / 2;\r\nbreak;\r\ncase 16:\r\nclock = clock * 2;\r\nbreak;\r\n}\r\n}\r\nif (ASIC_IS_DCE3(rdev)) {\r\nunion adjust_pixel_clock args;\r\nu8 frev, crev;\r\nint index;\r\nindex = GetIndexIntoMasterTable(COMMAND, AdjustDisplayPll);\r\nif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev,\r\n&crev))\r\nreturn adjusted_clock;\r\nmemset(&args, 0, sizeof(args));\r\nswitch (frev) {\r\ncase 1:\r\nswitch (crev) {\r\ncase 1:\r\ncase 2:\r\nargs.v1.usPixelClock = cpu_to_le16(clock / 10);\r\nargs.v1.ucTransmitterID = radeon_encoder->encoder_id;\r\nargs.v1.ucEncodeMode = encoder_mode;\r\nif (radeon_crtc->ss_enabled && radeon_crtc->ss.percentage)\r\nargs.v1.ucConfig |=\r\nADJUST_DISPLAY_CONFIG_SS_ENABLE;\r\natom_execute_table(rdev->mode_info.atom_context,\r\nindex, (uint32_t *)&args);\r\nadjusted_clock = le16_to_cpu(args.v1.usPixelClock) * 10;\r\nbreak;\r\ncase 3:\r\nargs.v3.sInput.usPixelClock = cpu_to_le16(clock / 10);\r\nargs.v3.sInput.ucTransmitterID = radeon_encoder->encoder_id;\r\nargs.v3.sInput.ucEncodeMode = encoder_mode;\r\nargs.v3.sInput.ucDispPllConfig = 0;\r\nif (radeon_crtc->ss_enabled && radeon_crtc->ss.percentage)\r\nargs.v3.sInput.ucDispPllConfig |=\r\nDISPPLL_CONFIG_SS_ENABLE;\r\nif (ENCODER_MODE_IS_DP(encoder_mode)) {\r\nargs.v3.sInput.ucDispPllConfig |=\r\nDISPPLL_CONFIG_COHERENT_MODE;\r\nargs.v3.sInput.usPixelClock = cpu_to_le16(dp_clock / 10);\r\n} else if (radeon_encoder->devices & (ATOM_DEVICE_DFP_SUPPORT)) {\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nif (dig->coherent_mode)\r\nargs.v3.sInput.ucDispPllConfig |=\r\nDISPPLL_CONFIG_COHERENT_MODE;\r\nif (is_duallink)\r\nargs.v3.sInput.ucDispPllConfig |=\r\nDISPPLL_CONFIG_DUAL_LINK;\r\n}\r\nif (radeon_encoder_get_dp_bridge_encoder_id(encoder) !=\r\nENCODER_OBJECT_ID_NONE)\r\nargs.v3.sInput.ucExtTransmitterID =\r\nradeon_encoder_get_dp_bridge_encoder_id(encoder);\r\nelse\r\nargs.v3.sInput.ucExtTransmitterID = 0;\r\natom_execute_table(rdev->mode_info.atom_context,\r\nindex, (uint32_t *)&args);\r\nadjusted_clock = le32_to_cpu(args.v3.sOutput.ulDispPllFreq) * 10;\r\nif (args.v3.sOutput.ucRefDiv) {\r\nradeon_crtc->pll_flags |= RADEON_PLL_USE_FRAC_FB_DIV;\r\nradeon_crtc->pll_flags |= RADEON_PLL_USE_REF_DIV;\r\nradeon_crtc->pll_reference_div = args.v3.sOutput.ucRefDiv;\r\n}\r\nif (args.v3.sOutput.ucPostDiv) {\r\nradeon_crtc->pll_flags |= RADEON_PLL_USE_FRAC_FB_DIV;\r\nradeon_crtc->pll_flags |= RADEON_PLL_USE_POST_DIV;\r\nradeon_crtc->pll_post_div = args.v3.sOutput.ucPostDiv;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d %d\n", frev, crev);\r\nreturn adjusted_clock;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d %d\n", frev, crev);\r\nreturn adjusted_clock;\r\n}\r\n}\r\nreturn adjusted_clock;\r\n}\r\nstatic void atombios_crtc_set_disp_eng_pll(struct radeon_device *rdev,\r\nu32 dispclk)\r\n{\r\nu8 frev, crev;\r\nint index;\r\nunion set_pixel_clock args;\r\nmemset(&args, 0, sizeof(args));\r\nindex = GetIndexIntoMasterTable(COMMAND, SetPixelClock);\r\nif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev,\r\n&crev))\r\nreturn;\r\nswitch (frev) {\r\ncase 1:\r\nswitch (crev) {\r\ncase 5:\r\nargs.v5.ucCRTC = ATOM_CRTC_INVALID;\r\nargs.v5.usPixelClock = cpu_to_le16(dispclk);\r\nargs.v5.ucPpll = ATOM_DCPLL;\r\nbreak;\r\ncase 6:\r\nargs.v6.ulDispEngClkFreq = cpu_to_le32(dispclk);\r\nif (ASIC_IS_DCE61(rdev) || ASIC_IS_DCE8(rdev))\r\nargs.v6.ucPpll = ATOM_EXT_PLL1;\r\nelse if (ASIC_IS_DCE6(rdev))\r\nargs.v6.ucPpll = ATOM_PPLL0;\r\nelse\r\nargs.v6.ucPpll = ATOM_DCPLL;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d %d\n", frev, crev);\r\nreturn;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d %d\n", frev, crev);\r\nreturn;\r\n}\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nstatic void atombios_crtc_program_pll(struct drm_crtc *crtc,\r\nu32 crtc_id,\r\nint pll_id,\r\nu32 encoder_mode,\r\nu32 encoder_id,\r\nu32 clock,\r\nu32 ref_div,\r\nu32 fb_div,\r\nu32 frac_fb_div,\r\nu32 post_div,\r\nint bpc,\r\nbool ss_enabled,\r\nstruct radeon_atom_ss *ss)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nu8 frev, crev;\r\nint index = GetIndexIntoMasterTable(COMMAND, SetPixelClock);\r\nunion set_pixel_clock args;\r\nmemset(&args, 0, sizeof(args));\r\nif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev,\r\n&crev))\r\nreturn;\r\nswitch (frev) {\r\ncase 1:\r\nswitch (crev) {\r\ncase 1:\r\nif (clock == ATOM_DISABLE)\r\nreturn;\r\nargs.v1.usPixelClock = cpu_to_le16(clock / 10);\r\nargs.v1.usRefDiv = cpu_to_le16(ref_div);\r\nargs.v1.usFbDiv = cpu_to_le16(fb_div);\r\nargs.v1.ucFracFbDiv = frac_fb_div;\r\nargs.v1.ucPostDiv = post_div;\r\nargs.v1.ucPpll = pll_id;\r\nargs.v1.ucCRTC = crtc_id;\r\nargs.v1.ucRefDivSrc = 1;\r\nbreak;\r\ncase 2:\r\nargs.v2.usPixelClock = cpu_to_le16(clock / 10);\r\nargs.v2.usRefDiv = cpu_to_le16(ref_div);\r\nargs.v2.usFbDiv = cpu_to_le16(fb_div);\r\nargs.v2.ucFracFbDiv = frac_fb_div;\r\nargs.v2.ucPostDiv = post_div;\r\nargs.v2.ucPpll = pll_id;\r\nargs.v2.ucCRTC = crtc_id;\r\nargs.v2.ucRefDivSrc = 1;\r\nbreak;\r\ncase 3:\r\nargs.v3.usPixelClock = cpu_to_le16(clock / 10);\r\nargs.v3.usRefDiv = cpu_to_le16(ref_div);\r\nargs.v3.usFbDiv = cpu_to_le16(fb_div);\r\nargs.v3.ucFracFbDiv = frac_fb_div;\r\nargs.v3.ucPostDiv = post_div;\r\nargs.v3.ucPpll = pll_id;\r\nif (crtc_id == ATOM_CRTC2)\r\nargs.v3.ucMiscInfo = PIXEL_CLOCK_MISC_CRTC_SEL_CRTC2;\r\nelse\r\nargs.v3.ucMiscInfo = PIXEL_CLOCK_MISC_CRTC_SEL_CRTC1;\r\nif (ss_enabled && (ss->type & ATOM_EXTERNAL_SS_MASK))\r\nargs.v3.ucMiscInfo |= PIXEL_CLOCK_MISC_REF_DIV_SRC;\r\nargs.v3.ucTransmitterId = encoder_id;\r\nargs.v3.ucEncoderMode = encoder_mode;\r\nbreak;\r\ncase 5:\r\nargs.v5.ucCRTC = crtc_id;\r\nargs.v5.usPixelClock = cpu_to_le16(clock / 10);\r\nargs.v5.ucRefDiv = ref_div;\r\nargs.v5.usFbDiv = cpu_to_le16(fb_div);\r\nargs.v5.ulFbDivDecFrac = cpu_to_le32(frac_fb_div * 100000);\r\nargs.v5.ucPostDiv = post_div;\r\nargs.v5.ucMiscInfo = 0;\r\nif (ss_enabled && (ss->type & ATOM_EXTERNAL_SS_MASK))\r\nargs.v5.ucMiscInfo |= PIXEL_CLOCK_V5_MISC_REF_DIV_SRC;\r\nif (encoder_mode == ATOM_ENCODER_MODE_HDMI) {\r\nswitch (bpc) {\r\ncase 8:\r\ndefault:\r\nargs.v5.ucMiscInfo |= PIXEL_CLOCK_V5_MISC_HDMI_24BPP;\r\nbreak;\r\ncase 10:\r\nargs.v5.ucMiscInfo |= PIXEL_CLOCK_V5_MISC_HDMI_32BPP;\r\nbreak;\r\ncase 12:\r\nargs.v5.ucMiscInfo |= PIXEL_CLOCK_V5_MISC_HDMI_30BPP;\r\nbreak;\r\n}\r\n}\r\nargs.v5.ucTransmitterID = encoder_id;\r\nargs.v5.ucEncoderMode = encoder_mode;\r\nargs.v5.ucPpll = pll_id;\r\nbreak;\r\ncase 6:\r\nargs.v6.ulDispEngClkFreq = cpu_to_le32(crtc_id << 24 | clock / 10);\r\nargs.v6.ucRefDiv = ref_div;\r\nargs.v6.usFbDiv = cpu_to_le16(fb_div);\r\nargs.v6.ulFbDivDecFrac = cpu_to_le32(frac_fb_div * 100000);\r\nargs.v6.ucPostDiv = post_div;\r\nargs.v6.ucMiscInfo = 0;\r\nif (ss_enabled && (ss->type & ATOM_EXTERNAL_SS_MASK))\r\nargs.v6.ucMiscInfo |= PIXEL_CLOCK_V6_MISC_REF_DIV_SRC;\r\nif (encoder_mode == ATOM_ENCODER_MODE_HDMI) {\r\nswitch (bpc) {\r\ncase 8:\r\ndefault:\r\nargs.v6.ucMiscInfo |= PIXEL_CLOCK_V6_MISC_HDMI_24BPP;\r\nbreak;\r\ncase 10:\r\nargs.v6.ucMiscInfo |= PIXEL_CLOCK_V6_MISC_HDMI_30BPP_V6;\r\nbreak;\r\ncase 12:\r\nargs.v6.ucMiscInfo |= PIXEL_CLOCK_V6_MISC_HDMI_36BPP_V6;\r\nbreak;\r\ncase 16:\r\nargs.v6.ucMiscInfo |= PIXEL_CLOCK_V6_MISC_HDMI_48BPP;\r\nbreak;\r\n}\r\n}\r\nargs.v6.ucTransmitterID = encoder_id;\r\nargs.v6.ucEncoderMode = encoder_mode;\r\nargs.v6.ucPpll = pll_id;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d %d\n", frev, crev);\r\nreturn;\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown table version %d %d\n", frev, crev);\r\nreturn;\r\n}\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n}\r\nstatic bool atombios_crtc_prepare_pll(struct drm_crtc *crtc, struct drm_display_mode *mode)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder =\r\nto_radeon_encoder(radeon_crtc->encoder);\r\nint encoder_mode = atombios_get_encoder_mode(radeon_crtc->encoder);\r\nradeon_crtc->bpc = 8;\r\nradeon_crtc->ss_enabled = false;\r\nif ((radeon_encoder->active_device & (ATOM_DEVICE_LCD_SUPPORT | ATOM_DEVICE_DFP_SUPPORT)) ||\r\n(radeon_encoder_get_dp_bridge_encoder_id(radeon_crtc->encoder) != ENCODER_OBJECT_ID_NONE)) {\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nstruct drm_connector *connector =\r\nradeon_get_connector_for_encoder(radeon_crtc->encoder);\r\nstruct radeon_connector *radeon_connector =\r\nto_radeon_connector(connector);\r\nstruct radeon_connector_atom_dig *dig_connector =\r\nradeon_connector->con_priv;\r\nint dp_clock;\r\nradeon_connector->pixelclock_for_modeset = mode->clock;\r\nradeon_crtc->bpc = radeon_get_monitor_bpc(connector);\r\nswitch (encoder_mode) {\r\ncase ATOM_ENCODER_MODE_DP_MST:\r\ncase ATOM_ENCODER_MODE_DP:\r\ndp_clock = dig_connector->dp_clock / 10;\r\nif (ASIC_IS_DCE4(rdev))\r\nradeon_crtc->ss_enabled =\r\nradeon_atombios_get_asic_ss_info(rdev, &radeon_crtc->ss,\r\nASIC_INTERNAL_SS_ON_DP,\r\ndp_clock);\r\nelse {\r\nif (dp_clock == 16200) {\r\nradeon_crtc->ss_enabled =\r\nradeon_atombios_get_ppll_ss_info(rdev,\r\n&radeon_crtc->ss,\r\nATOM_DP_SS_ID2);\r\nif (!radeon_crtc->ss_enabled)\r\nradeon_crtc->ss_enabled =\r\nradeon_atombios_get_ppll_ss_info(rdev,\r\n&radeon_crtc->ss,\r\nATOM_DP_SS_ID1);\r\n} else {\r\nradeon_crtc->ss_enabled =\r\nradeon_atombios_get_ppll_ss_info(rdev,\r\n&radeon_crtc->ss,\r\nATOM_DP_SS_ID1);\r\n}\r\nradeon_crtc->ss_enabled = false;\r\n}\r\nbreak;\r\ncase ATOM_ENCODER_MODE_LVDS:\r\nif (ASIC_IS_DCE4(rdev))\r\nradeon_crtc->ss_enabled =\r\nradeon_atombios_get_asic_ss_info(rdev,\r\n&radeon_crtc->ss,\r\ndig->lcd_ss_id,\r\nmode->clock / 10);\r\nelse\r\nradeon_crtc->ss_enabled =\r\nradeon_atombios_get_ppll_ss_info(rdev,\r\n&radeon_crtc->ss,\r\ndig->lcd_ss_id);\r\nbreak;\r\ncase ATOM_ENCODER_MODE_DVI:\r\nif (ASIC_IS_DCE4(rdev))\r\nradeon_crtc->ss_enabled =\r\nradeon_atombios_get_asic_ss_info(rdev,\r\n&radeon_crtc->ss,\r\nASIC_INTERNAL_SS_ON_TMDS,\r\nmode->clock / 10);\r\nbreak;\r\ncase ATOM_ENCODER_MODE_HDMI:\r\nif (ASIC_IS_DCE4(rdev))\r\nradeon_crtc->ss_enabled =\r\nradeon_atombios_get_asic_ss_info(rdev,\r\n&radeon_crtc->ss,\r\nASIC_INTERNAL_SS_ON_HDMI,\r\nmode->clock / 10);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nradeon_crtc->adjusted_clock = atombios_adjust_pll(crtc, mode);\r\nreturn true;\r\n}\r\nstatic void atombios_crtc_set_pll(struct drm_crtc *crtc, struct drm_display_mode *mode)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder =\r\nto_radeon_encoder(radeon_crtc->encoder);\r\nu32 pll_clock = mode->clock;\r\nu32 clock = mode->clock;\r\nu32 ref_div = 0, fb_div = 0, frac_fb_div = 0, post_div = 0;\r\nstruct radeon_pll *pll;\r\nint encoder_mode = atombios_get_encoder_mode(radeon_crtc->encoder);\r\nif (ASIC_IS_DCE5(rdev) &&\r\n(encoder_mode == ATOM_ENCODER_MODE_HDMI) &&\r\n(radeon_crtc->bpc > 8))\r\nclock = radeon_crtc->adjusted_clock;\r\nswitch (radeon_crtc->pll_id) {\r\ncase ATOM_PPLL1:\r\npll = &rdev->clock.p1pll;\r\nbreak;\r\ncase ATOM_PPLL2:\r\npll = &rdev->clock.p2pll;\r\nbreak;\r\ncase ATOM_DCPLL:\r\ncase ATOM_PPLL_INVALID:\r\ndefault:\r\npll = &rdev->clock.dcpll;\r\nbreak;\r\n}\r\npll->flags = radeon_crtc->pll_flags;\r\npll->reference_div = radeon_crtc->pll_reference_div;\r\npll->post_div = radeon_crtc->pll_post_div;\r\nif (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT))\r\nradeon_compute_pll_legacy(pll, radeon_crtc->adjusted_clock, &pll_clock,\r\n&fb_div, &frac_fb_div, &ref_div, &post_div);\r\nelse if (ASIC_IS_AVIVO(rdev))\r\nradeon_compute_pll_avivo(pll, radeon_crtc->adjusted_clock, &pll_clock,\r\n&fb_div, &frac_fb_div, &ref_div, &post_div);\r\nelse\r\nradeon_compute_pll_legacy(pll, radeon_crtc->adjusted_clock, &pll_clock,\r\n&fb_div, &frac_fb_div, &ref_div, &post_div);\r\natombios_crtc_program_ss(rdev, ATOM_DISABLE, radeon_crtc->pll_id,\r\nradeon_crtc->crtc_id, &radeon_crtc->ss);\r\natombios_crtc_program_pll(crtc, radeon_crtc->crtc_id, radeon_crtc->pll_id,\r\nencoder_mode, radeon_encoder->encoder_id, clock,\r\nref_div, fb_div, frac_fb_div, post_div,\r\nradeon_crtc->bpc, radeon_crtc->ss_enabled, &radeon_crtc->ss);\r\nif (radeon_crtc->ss_enabled) {\r\nif (ASIC_IS_DCE4(rdev)) {\r\nu32 step_size;\r\nu32 amount = (((fb_div * 10) + frac_fb_div) *\r\n(u32)radeon_crtc->ss.percentage) /\r\n(100 * (u32)radeon_crtc->ss.percentage_divider);\r\nradeon_crtc->ss.amount = (amount / 10) & ATOM_PPLL_SS_AMOUNT_V2_FBDIV_MASK;\r\nradeon_crtc->ss.amount |= ((amount - (amount / 10)) << ATOM_PPLL_SS_AMOUNT_V2_NFRAC_SHIFT) &\r\nATOM_PPLL_SS_AMOUNT_V2_NFRAC_MASK;\r\nif (radeon_crtc->ss.type & ATOM_PPLL_SS_TYPE_V2_CENTRE_SPREAD)\r\nstep_size = (4 * amount * ref_div * ((u32)radeon_crtc->ss.rate * 2048)) /\r\n(125 * 25 * pll->reference_freq / 100);\r\nelse\r\nstep_size = (2 * amount * ref_div * ((u32)radeon_crtc->ss.rate * 2048)) /\r\n(125 * 25 * pll->reference_freq / 100);\r\nradeon_crtc->ss.step = step_size;\r\n}\r\natombios_crtc_program_ss(rdev, ATOM_ENABLE, radeon_crtc->pll_id,\r\nradeon_crtc->crtc_id, &radeon_crtc->ss);\r\n}\r\n}\r\nstatic int dce4_crtc_do_set_base(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nint x, int y, int atomic)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_framebuffer *radeon_fb;\r\nstruct drm_framebuffer *target_fb;\r\nstruct drm_gem_object *obj;\r\nstruct radeon_bo *rbo;\r\nuint64_t fb_location;\r\nuint32_t fb_format, fb_pitch_pixels, tiling_flags;\r\nunsigned bankw, bankh, mtaspect, tile_split;\r\nu32 fb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_NONE);\r\nu32 tmp, viewport_w, viewport_h;\r\nint r;\r\nbool bypass_lut = false;\r\nif (!atomic && !crtc->primary->fb) {\r\nDRM_DEBUG_KMS("No FB bound\n");\r\nreturn 0;\r\n}\r\nif (atomic) {\r\nradeon_fb = to_radeon_framebuffer(fb);\r\ntarget_fb = fb;\r\n}\r\nelse {\r\nradeon_fb = to_radeon_framebuffer(crtc->primary->fb);\r\ntarget_fb = crtc->primary->fb;\r\n}\r\nobj = radeon_fb->obj;\r\nrbo = gem_to_radeon_bo(obj);\r\nr = radeon_bo_reserve(rbo, false);\r\nif (unlikely(r != 0))\r\nreturn r;\r\nif (atomic)\r\nfb_location = radeon_bo_gpu_offset(rbo);\r\nelse {\r\nr = radeon_bo_pin(rbo, RADEON_GEM_DOMAIN_VRAM, &fb_location);\r\nif (unlikely(r != 0)) {\r\nradeon_bo_unreserve(rbo);\r\nreturn -EINVAL;\r\n}\r\n}\r\nradeon_bo_get_tiling_flags(rbo, &tiling_flags, NULL);\r\nradeon_bo_unreserve(rbo);\r\nswitch (target_fb->pixel_format) {\r\ncase DRM_FORMAT_C8:\r\nfb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_8BPP) |\r\nEVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_INDEXED));\r\nbreak;\r\ncase DRM_FORMAT_XRGB4444:\r\ncase DRM_FORMAT_ARGB4444:\r\nfb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_16BPP) |\r\nEVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_ARGB4444));\r\n#ifdef __BIG_ENDIAN\r\nfb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_8IN16);\r\n#endif\r\nbreak;\r\ncase DRM_FORMAT_XRGB1555:\r\ncase DRM_FORMAT_ARGB1555:\r\nfb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_16BPP) |\r\nEVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_ARGB1555));\r\n#ifdef __BIG_ENDIAN\r\nfb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_8IN16);\r\n#endif\r\nbreak;\r\ncase DRM_FORMAT_BGRX5551:\r\ncase DRM_FORMAT_BGRA5551:\r\nfb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_16BPP) |\r\nEVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_BGRA5551));\r\n#ifdef __BIG_ENDIAN\r\nfb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_8IN16);\r\n#endif\r\nbreak;\r\ncase DRM_FORMAT_RGB565:\r\nfb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_16BPP) |\r\nEVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_ARGB565));\r\n#ifdef __BIG_ENDIAN\r\nfb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_8IN16);\r\n#endif\r\nbreak;\r\ncase DRM_FORMAT_XRGB8888:\r\ncase DRM_FORMAT_ARGB8888:\r\nfb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_32BPP) |\r\nEVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_ARGB8888));\r\n#ifdef __BIG_ENDIAN\r\nfb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_8IN32);\r\n#endif\r\nbreak;\r\ncase DRM_FORMAT_XRGB2101010:\r\ncase DRM_FORMAT_ARGB2101010:\r\nfb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_32BPP) |\r\nEVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_ARGB2101010));\r\n#ifdef __BIG_ENDIAN\r\nfb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_8IN32);\r\n#endif\r\nbypass_lut = true;\r\nbreak;\r\ncase DRM_FORMAT_BGRX1010102:\r\ncase DRM_FORMAT_BGRA1010102:\r\nfb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_32BPP) |\r\nEVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_BGRA1010102));\r\n#ifdef __BIG_ENDIAN\r\nfb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_8IN32);\r\n#endif\r\nbypass_lut = true;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unsupported screen format %s\n",\r\ndrm_get_format_name(target_fb->pixel_format));\r\nreturn -EINVAL;\r\n}\r\nif (tiling_flags & RADEON_TILING_MACRO) {\r\nevergreen_tiling_fields(tiling_flags, &bankw, &bankh, &mtaspect, &tile_split);\r\nif (rdev->family >= CHIP_TAHITI) {\r\nunsigned index, num_banks;\r\nif (rdev->family >= CHIP_BONAIRE) {\r\nunsigned tileb, tile_split_bytes;\r\ntile_split_bytes = 64 << tile_split;\r\ntileb = 8 * 8 * target_fb->bits_per_pixel / 8;\r\ntileb = min(tile_split_bytes, tileb);\r\nfor (index = 0; tileb > 64; index++)\r\ntileb >>= 1;\r\nif (index >= 16) {\r\nDRM_ERROR("Wrong screen bpp (%u) or tile split (%u)\n",\r\ntarget_fb->bits_per_pixel, tile_split);\r\nreturn -EINVAL;\r\n}\r\nnum_banks = (rdev->config.cik.macrotile_mode_array[index] >> 6) & 0x3;\r\n} else {\r\nswitch (target_fb->bits_per_pixel) {\r\ncase 8:\r\nindex = 10;\r\nbreak;\r\ncase 16:\r\nindex = SI_TILE_MODE_COLOR_2D_SCANOUT_16BPP;\r\nbreak;\r\ndefault:\r\ncase 32:\r\nindex = SI_TILE_MODE_COLOR_2D_SCANOUT_32BPP;\r\nbreak;\r\n}\r\nnum_banks = (rdev->config.si.tile_mode_array[index] >> 20) & 0x3;\r\n}\r\nfb_format |= EVERGREEN_GRPH_NUM_BANKS(num_banks);\r\n} else {\r\nif (rdev->family >= CHIP_CAYMAN)\r\ntmp = rdev->config.cayman.tile_config;\r\nelse\r\ntmp = rdev->config.evergreen.tile_config;\r\nswitch ((tmp & 0xf0) >> 4) {\r\ncase 0:\r\nfb_format |= EVERGREEN_GRPH_NUM_BANKS(EVERGREEN_ADDR_SURF_4_BANK);\r\nbreak;\r\ncase 1:\r\ndefault:\r\nfb_format |= EVERGREEN_GRPH_NUM_BANKS(EVERGREEN_ADDR_SURF_8_BANK);\r\nbreak;\r\ncase 2:\r\nfb_format |= EVERGREEN_GRPH_NUM_BANKS(EVERGREEN_ADDR_SURF_16_BANK);\r\nbreak;\r\n}\r\n}\r\nfb_format |= EVERGREEN_GRPH_ARRAY_MODE(EVERGREEN_GRPH_ARRAY_2D_TILED_THIN1);\r\nfb_format |= EVERGREEN_GRPH_TILE_SPLIT(tile_split);\r\nfb_format |= EVERGREEN_GRPH_BANK_WIDTH(bankw);\r\nfb_format |= EVERGREEN_GRPH_BANK_HEIGHT(bankh);\r\nfb_format |= EVERGREEN_GRPH_MACRO_TILE_ASPECT(mtaspect);\r\nif (rdev->family >= CHIP_BONAIRE) {\r\nfb_format |= CIK_GRPH_MICRO_TILE_MODE(CIK_DISPLAY_MICRO_TILING);\r\n}\r\n} else if (tiling_flags & RADEON_TILING_MICRO)\r\nfb_format |= EVERGREEN_GRPH_ARRAY_MODE(EVERGREEN_GRPH_ARRAY_1D_TILED_THIN1);\r\nif (rdev->family >= CHIP_BONAIRE) {\r\nu32 pipe_config = (rdev->config.cik.tile_mode_array[10] >> 6) & 0x1f;\r\nfb_format |= CIK_GRPH_PIPE_CONFIG(pipe_config);\r\n} else if ((rdev->family == CHIP_TAHITI) ||\r\n(rdev->family == CHIP_PITCAIRN))\r\nfb_format |= SI_GRPH_PIPE_CONFIG(SI_ADDR_SURF_P8_32x32_8x16);\r\nelse if ((rdev->family == CHIP_VERDE) ||\r\n(rdev->family == CHIP_OLAND) ||\r\n(rdev->family == CHIP_HAINAN))\r\nfb_format |= SI_GRPH_PIPE_CONFIG(SI_ADDR_SURF_P4_8x16);\r\nswitch (radeon_crtc->crtc_id) {\r\ncase 0:\r\nWREG32(AVIVO_D1VGA_CONTROL, 0);\r\nbreak;\r\ncase 1:\r\nWREG32(AVIVO_D2VGA_CONTROL, 0);\r\nbreak;\r\ncase 2:\r\nWREG32(EVERGREEN_D3VGA_CONTROL, 0);\r\nbreak;\r\ncase 3:\r\nWREG32(EVERGREEN_D4VGA_CONTROL, 0);\r\nbreak;\r\ncase 4:\r\nWREG32(EVERGREEN_D5VGA_CONTROL, 0);\r\nbreak;\r\ncase 5:\r\nWREG32(EVERGREEN_D6VGA_CONTROL, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nWREG32(EVERGREEN_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH + radeon_crtc->crtc_offset,\r\nupper_32_bits(fb_location));\r\nWREG32(EVERGREEN_GRPH_SECONDARY_SURFACE_ADDRESS_HIGH + radeon_crtc->crtc_offset,\r\nupper_32_bits(fb_location));\r\nWREG32(EVERGREEN_GRPH_PRIMARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset,\r\n(u32)fb_location & EVERGREEN_GRPH_SURFACE_ADDRESS_MASK);\r\nWREG32(EVERGREEN_GRPH_SECONDARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset,\r\n(u32) fb_location & EVERGREEN_GRPH_SURFACE_ADDRESS_MASK);\r\nWREG32(EVERGREEN_GRPH_CONTROL + radeon_crtc->crtc_offset, fb_format);\r\nWREG32(EVERGREEN_GRPH_SWAP_CONTROL + radeon_crtc->crtc_offset, fb_swap);\r\nWREG32_P(EVERGREEN_GRPH_LUT_10BIT_BYPASS_CONTROL + radeon_crtc->crtc_offset,\r\n(bypass_lut ? EVERGREEN_LUT_10BIT_BYPASS_EN : 0),\r\n~EVERGREEN_LUT_10BIT_BYPASS_EN);\r\nif (bypass_lut)\r\nDRM_DEBUG_KMS("Bypassing hardware LUT due to 10 bit fb scanout.\n");\r\nWREG32(EVERGREEN_GRPH_SURFACE_OFFSET_X + radeon_crtc->crtc_offset, 0);\r\nWREG32(EVERGREEN_GRPH_SURFACE_OFFSET_Y + radeon_crtc->crtc_offset, 0);\r\nWREG32(EVERGREEN_GRPH_X_START + radeon_crtc->crtc_offset, 0);\r\nWREG32(EVERGREEN_GRPH_Y_START + radeon_crtc->crtc_offset, 0);\r\nWREG32(EVERGREEN_GRPH_X_END + radeon_crtc->crtc_offset, target_fb->width);\r\nWREG32(EVERGREEN_GRPH_Y_END + radeon_crtc->crtc_offset, target_fb->height);\r\nfb_pitch_pixels = target_fb->pitches[0] / (target_fb->bits_per_pixel / 8);\r\nWREG32(EVERGREEN_GRPH_PITCH + radeon_crtc->crtc_offset, fb_pitch_pixels);\r\nWREG32(EVERGREEN_GRPH_ENABLE + radeon_crtc->crtc_offset, 1);\r\nif (rdev->family >= CHIP_BONAIRE)\r\nWREG32(CIK_LB_DESKTOP_HEIGHT + radeon_crtc->crtc_offset,\r\ntarget_fb->height);\r\nelse\r\nWREG32(EVERGREEN_DESKTOP_HEIGHT + radeon_crtc->crtc_offset,\r\ntarget_fb->height);\r\nx &= ~3;\r\ny &= ~1;\r\nWREG32(EVERGREEN_VIEWPORT_START + radeon_crtc->crtc_offset,\r\n(x << 16) | y);\r\nviewport_w = crtc->mode.hdisplay;\r\nviewport_h = (crtc->mode.vdisplay + 1) & ~1;\r\nWREG32(EVERGREEN_VIEWPORT_SIZE + radeon_crtc->crtc_offset,\r\n(viewport_w << 16) | viewport_h);\r\ntmp = RREG32(EVERGREEN_GRPH_FLIP_CONTROL + radeon_crtc->crtc_offset);\r\ntmp &= ~EVERGREEN_GRPH_SURFACE_UPDATE_H_RETRACE_EN;\r\nWREG32(EVERGREEN_GRPH_FLIP_CONTROL + radeon_crtc->crtc_offset, tmp);\r\nWREG32(EVERGREEN_MASTER_UPDATE_MODE + radeon_crtc->crtc_offset, 3);\r\nif (!atomic && fb && fb != crtc->primary->fb) {\r\nradeon_fb = to_radeon_framebuffer(fb);\r\nrbo = gem_to_radeon_bo(radeon_fb->obj);\r\nr = radeon_bo_reserve(rbo, false);\r\nif (unlikely(r != 0))\r\nreturn r;\r\nradeon_bo_unpin(rbo);\r\nradeon_bo_unreserve(rbo);\r\n}\r\nradeon_bandwidth_update(rdev);\r\nreturn 0;\r\n}\r\nstatic int avivo_crtc_do_set_base(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nint x, int y, int atomic)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_framebuffer *radeon_fb;\r\nstruct drm_gem_object *obj;\r\nstruct radeon_bo *rbo;\r\nstruct drm_framebuffer *target_fb;\r\nuint64_t fb_location;\r\nuint32_t fb_format, fb_pitch_pixels, tiling_flags;\r\nu32 fb_swap = R600_D1GRPH_SWAP_ENDIAN_NONE;\r\nu32 tmp, viewport_w, viewport_h;\r\nint r;\r\nbool bypass_lut = false;\r\nif (!atomic && !crtc->primary->fb) {\r\nDRM_DEBUG_KMS("No FB bound\n");\r\nreturn 0;\r\n}\r\nif (atomic) {\r\nradeon_fb = to_radeon_framebuffer(fb);\r\ntarget_fb = fb;\r\n}\r\nelse {\r\nradeon_fb = to_radeon_framebuffer(crtc->primary->fb);\r\ntarget_fb = crtc->primary->fb;\r\n}\r\nobj = radeon_fb->obj;\r\nrbo = gem_to_radeon_bo(obj);\r\nr = radeon_bo_reserve(rbo, false);\r\nif (unlikely(r != 0))\r\nreturn r;\r\nif (atomic)\r\nfb_location = radeon_bo_gpu_offset(rbo);\r\nelse {\r\nr = radeon_bo_pin(rbo, RADEON_GEM_DOMAIN_VRAM, &fb_location);\r\nif (unlikely(r != 0)) {\r\nradeon_bo_unreserve(rbo);\r\nreturn -EINVAL;\r\n}\r\n}\r\nradeon_bo_get_tiling_flags(rbo, &tiling_flags, NULL);\r\nradeon_bo_unreserve(rbo);\r\nswitch (target_fb->pixel_format) {\r\ncase DRM_FORMAT_C8:\r\nfb_format =\r\nAVIVO_D1GRPH_CONTROL_DEPTH_8BPP |\r\nAVIVO_D1GRPH_CONTROL_8BPP_INDEXED;\r\nbreak;\r\ncase DRM_FORMAT_XRGB4444:\r\ncase DRM_FORMAT_ARGB4444:\r\nfb_format =\r\nAVIVO_D1GRPH_CONTROL_DEPTH_16BPP |\r\nAVIVO_D1GRPH_CONTROL_16BPP_ARGB4444;\r\n#ifdef __BIG_ENDIAN\r\nfb_swap = R600_D1GRPH_SWAP_ENDIAN_16BIT;\r\n#endif\r\nbreak;\r\ncase DRM_FORMAT_XRGB1555:\r\nfb_format =\r\nAVIVO_D1GRPH_CONTROL_DEPTH_16BPP |\r\nAVIVO_D1GRPH_CONTROL_16BPP_ARGB1555;\r\n#ifdef __BIG_ENDIAN\r\nfb_swap = R600_D1GRPH_SWAP_ENDIAN_16BIT;\r\n#endif\r\nbreak;\r\ncase DRM_FORMAT_RGB565:\r\nfb_format =\r\nAVIVO_D1GRPH_CONTROL_DEPTH_16BPP |\r\nAVIVO_D1GRPH_CONTROL_16BPP_RGB565;\r\n#ifdef __BIG_ENDIAN\r\nfb_swap = R600_D1GRPH_SWAP_ENDIAN_16BIT;\r\n#endif\r\nbreak;\r\ncase DRM_FORMAT_XRGB8888:\r\ncase DRM_FORMAT_ARGB8888:\r\nfb_format =\r\nAVIVO_D1GRPH_CONTROL_DEPTH_32BPP |\r\nAVIVO_D1GRPH_CONTROL_32BPP_ARGB8888;\r\n#ifdef __BIG_ENDIAN\r\nfb_swap = R600_D1GRPH_SWAP_ENDIAN_32BIT;\r\n#endif\r\nbreak;\r\ncase DRM_FORMAT_XRGB2101010:\r\ncase DRM_FORMAT_ARGB2101010:\r\nfb_format =\r\nAVIVO_D1GRPH_CONTROL_DEPTH_32BPP |\r\nAVIVO_D1GRPH_CONTROL_32BPP_ARGB2101010;\r\n#ifdef __BIG_ENDIAN\r\nfb_swap = R600_D1GRPH_SWAP_ENDIAN_32BIT;\r\n#endif\r\nbypass_lut = true;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unsupported screen format %s\n",\r\ndrm_get_format_name(target_fb->pixel_format));\r\nreturn -EINVAL;\r\n}\r\nif (rdev->family >= CHIP_R600) {\r\nif (tiling_flags & RADEON_TILING_MACRO)\r\nfb_format |= R600_D1GRPH_ARRAY_MODE_2D_TILED_THIN1;\r\nelse if (tiling_flags & RADEON_TILING_MICRO)\r\nfb_format |= R600_D1GRPH_ARRAY_MODE_1D_TILED_THIN1;\r\n} else {\r\nif (tiling_flags & RADEON_TILING_MACRO)\r\nfb_format |= AVIVO_D1GRPH_MACRO_ADDRESS_MODE;\r\nif (tiling_flags & RADEON_TILING_MICRO)\r\nfb_format |= AVIVO_D1GRPH_TILED;\r\n}\r\nif (radeon_crtc->crtc_id == 0)\r\nWREG32(AVIVO_D1VGA_CONTROL, 0);\r\nelse\r\nWREG32(AVIVO_D2VGA_CONTROL, 0);\r\nif (rdev->family >= CHIP_RV770) {\r\nif (radeon_crtc->crtc_id) {\r\nWREG32(R700_D2GRPH_PRIMARY_SURFACE_ADDRESS_HIGH, upper_32_bits(fb_location));\r\nWREG32(R700_D2GRPH_SECONDARY_SURFACE_ADDRESS_HIGH, upper_32_bits(fb_location));\r\n} else {\r\nWREG32(R700_D1GRPH_PRIMARY_SURFACE_ADDRESS_HIGH, upper_32_bits(fb_location));\r\nWREG32(R700_D1GRPH_SECONDARY_SURFACE_ADDRESS_HIGH, upper_32_bits(fb_location));\r\n}\r\n}\r\nWREG32(AVIVO_D1GRPH_PRIMARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset,\r\n(u32) fb_location);\r\nWREG32(AVIVO_D1GRPH_SECONDARY_SURFACE_ADDRESS +\r\nradeon_crtc->crtc_offset, (u32) fb_location);\r\nWREG32(AVIVO_D1GRPH_CONTROL + radeon_crtc->crtc_offset, fb_format);\r\nif (rdev->family >= CHIP_R600)\r\nWREG32(R600_D1GRPH_SWAP_CONTROL + radeon_crtc->crtc_offset, fb_swap);\r\nWREG32_P(AVIVO_D1GRPH_LUT_SEL + radeon_crtc->crtc_offset,\r\n(bypass_lut ? AVIVO_LUT_10BIT_BYPASS_EN : 0), ~AVIVO_LUT_10BIT_BYPASS_EN);\r\nif (bypass_lut)\r\nDRM_DEBUG_KMS("Bypassing hardware LUT due to 10 bit fb scanout.\n");\r\nWREG32(AVIVO_D1GRPH_SURFACE_OFFSET_X + radeon_crtc->crtc_offset, 0);\r\nWREG32(AVIVO_D1GRPH_SURFACE_OFFSET_Y + radeon_crtc->crtc_offset, 0);\r\nWREG32(AVIVO_D1GRPH_X_START + radeon_crtc->crtc_offset, 0);\r\nWREG32(AVIVO_D1GRPH_Y_START + radeon_crtc->crtc_offset, 0);\r\nWREG32(AVIVO_D1GRPH_X_END + radeon_crtc->crtc_offset, target_fb->width);\r\nWREG32(AVIVO_D1GRPH_Y_END + radeon_crtc->crtc_offset, target_fb->height);\r\nfb_pitch_pixels = target_fb->pitches[0] / (target_fb->bits_per_pixel / 8);\r\nWREG32(AVIVO_D1GRPH_PITCH + radeon_crtc->crtc_offset, fb_pitch_pixels);\r\nWREG32(AVIVO_D1GRPH_ENABLE + radeon_crtc->crtc_offset, 1);\r\nWREG32(AVIVO_D1MODE_DESKTOP_HEIGHT + radeon_crtc->crtc_offset,\r\ntarget_fb->height);\r\nx &= ~3;\r\ny &= ~1;\r\nWREG32(AVIVO_D1MODE_VIEWPORT_START + radeon_crtc->crtc_offset,\r\n(x << 16) | y);\r\nviewport_w = crtc->mode.hdisplay;\r\nviewport_h = (crtc->mode.vdisplay + 1) & ~1;\r\nWREG32(AVIVO_D1MODE_VIEWPORT_SIZE + radeon_crtc->crtc_offset,\r\n(viewport_w << 16) | viewport_h);\r\ntmp = RREG32(AVIVO_D1GRPH_FLIP_CONTROL + radeon_crtc->crtc_offset);\r\ntmp &= ~AVIVO_D1GRPH_SURFACE_UPDATE_H_RETRACE_EN;\r\nWREG32(AVIVO_D1GRPH_FLIP_CONTROL + radeon_crtc->crtc_offset, tmp);\r\nWREG32(AVIVO_D1MODE_MASTER_UPDATE_MODE + radeon_crtc->crtc_offset, 3);\r\nif (!atomic && fb && fb != crtc->primary->fb) {\r\nradeon_fb = to_radeon_framebuffer(fb);\r\nrbo = gem_to_radeon_bo(radeon_fb->obj);\r\nr = radeon_bo_reserve(rbo, false);\r\nif (unlikely(r != 0))\r\nreturn r;\r\nradeon_bo_unpin(rbo);\r\nradeon_bo_unreserve(rbo);\r\n}\r\nradeon_bandwidth_update(rdev);\r\nreturn 0;\r\n}\r\nint atombios_crtc_set_base(struct drm_crtc *crtc, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (ASIC_IS_DCE4(rdev))\r\nreturn dce4_crtc_do_set_base(crtc, old_fb, x, y, 0);\r\nelse if (ASIC_IS_AVIVO(rdev))\r\nreturn avivo_crtc_do_set_base(crtc, old_fb, x, y, 0);\r\nelse\r\nreturn radeon_crtc_do_set_base(crtc, old_fb, x, y, 0);\r\n}\r\nint atombios_crtc_set_base_atomic(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nint x, int y, enum mode_set_atomic state)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (ASIC_IS_DCE4(rdev))\r\nreturn dce4_crtc_do_set_base(crtc, fb, x, y, 1);\r\nelse if (ASIC_IS_AVIVO(rdev))\r\nreturn avivo_crtc_do_set_base(crtc, fb, x, y, 1);\r\nelse\r\nreturn radeon_crtc_do_set_base(crtc, fb, x, y, 1);\r\n}\r\nstatic void radeon_legacy_atom_fixup(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nu32 disp_merge_cntl;\r\nswitch (radeon_crtc->crtc_id) {\r\ncase 0:\r\ndisp_merge_cntl = RREG32(RADEON_DISP_MERGE_CNTL);\r\ndisp_merge_cntl &= ~RADEON_DISP_RGB_OFFSET_EN;\r\nWREG32(RADEON_DISP_MERGE_CNTL, disp_merge_cntl);\r\nbreak;\r\ncase 1:\r\ndisp_merge_cntl = RREG32(RADEON_DISP2_MERGE_CNTL);\r\ndisp_merge_cntl &= ~RADEON_DISP2_RGB_OFFSET_EN;\r\nWREG32(RADEON_DISP2_MERGE_CNTL, disp_merge_cntl);\r\nWREG32(RADEON_FP_H2_SYNC_STRT_WID, RREG32(RADEON_CRTC2_H_SYNC_STRT_WID));\r\nWREG32(RADEON_FP_V2_SYNC_STRT_WID, RREG32(RADEON_CRTC2_V_SYNC_STRT_WID));\r\nbreak;\r\n}\r\n}\r\nstatic u32 radeon_get_pll_use_mask(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_crtc *test_crtc;\r\nstruct radeon_crtc *test_radeon_crtc;\r\nu32 pll_in_use = 0;\r\nlist_for_each_entry(test_crtc, &dev->mode_config.crtc_list, head) {\r\nif (crtc == test_crtc)\r\ncontinue;\r\ntest_radeon_crtc = to_radeon_crtc(test_crtc);\r\nif (test_radeon_crtc->pll_id != ATOM_PPLL_INVALID)\r\npll_in_use |= (1 << test_radeon_crtc->pll_id);\r\n}\r\nreturn pll_in_use;\r\n}\r\nstatic int radeon_get_shared_dp_ppll(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_crtc *test_crtc;\r\nstruct radeon_crtc *test_radeon_crtc;\r\nlist_for_each_entry(test_crtc, &dev->mode_config.crtc_list, head) {\r\nif (crtc == test_crtc)\r\ncontinue;\r\ntest_radeon_crtc = to_radeon_crtc(test_crtc);\r\nif (test_radeon_crtc->encoder &&\r\nENCODER_MODE_IS_DP(atombios_get_encoder_mode(test_radeon_crtc->encoder))) {\r\nif (test_radeon_crtc->pll_id != ATOM_PPLL_INVALID)\r\nreturn test_radeon_crtc->pll_id;\r\n}\r\n}\r\nreturn ATOM_PPLL_INVALID;\r\n}\r\nstatic int radeon_get_shared_nondp_ppll(struct drm_crtc *crtc)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_crtc *test_crtc;\r\nstruct radeon_crtc *test_radeon_crtc;\r\nu32 adjusted_clock, test_adjusted_clock;\r\nadjusted_clock = radeon_crtc->adjusted_clock;\r\nif (adjusted_clock == 0)\r\nreturn ATOM_PPLL_INVALID;\r\nlist_for_each_entry(test_crtc, &dev->mode_config.crtc_list, head) {\r\nif (crtc == test_crtc)\r\ncontinue;\r\ntest_radeon_crtc = to_radeon_crtc(test_crtc);\r\nif (test_radeon_crtc->encoder &&\r\n!ENCODER_MODE_IS_DP(atombios_get_encoder_mode(test_radeon_crtc->encoder))) {\r\nif (test_radeon_crtc->connector == radeon_crtc->connector) {\r\nif (test_radeon_crtc->pll_id != ATOM_PPLL_INVALID)\r\nreturn test_radeon_crtc->pll_id;\r\n}\r\ntest_adjusted_clock = test_radeon_crtc->adjusted_clock;\r\nif ((crtc->mode.clock == test_crtc->mode.clock) &&\r\n(adjusted_clock == test_adjusted_clock) &&\r\n(radeon_crtc->ss_enabled == test_radeon_crtc->ss_enabled) &&\r\n(test_radeon_crtc->pll_id != ATOM_PPLL_INVALID))\r\nreturn test_radeon_crtc->pll_id;\r\n}\r\n}\r\nreturn ATOM_PPLL_INVALID;\r\n}\r\nstatic int radeon_atom_pick_pll(struct drm_crtc *crtc)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder =\r\nto_radeon_encoder(radeon_crtc->encoder);\r\nu32 pll_in_use;\r\nint pll;\r\nif (ASIC_IS_DCE8(rdev)) {\r\nif (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(radeon_crtc->encoder))) {\r\nif (rdev->clock.dp_extclk)\r\nreturn ATOM_PPLL_INVALID;\r\nelse {\r\npll = radeon_get_shared_dp_ppll(crtc);\r\nif (pll != ATOM_PPLL_INVALID)\r\nreturn pll;\r\n}\r\n} else {\r\npll = radeon_get_shared_nondp_ppll(crtc);\r\nif (pll != ATOM_PPLL_INVALID)\r\nreturn pll;\r\n}\r\nif ((rdev->family == CHIP_KAVERI) ||\r\n(rdev->family == CHIP_KABINI) ||\r\n(rdev->family == CHIP_MULLINS)) {\r\npll_in_use = radeon_get_pll_use_mask(crtc);\r\nif (!(pll_in_use & (1 << ATOM_PPLL2)))\r\nreturn ATOM_PPLL2;\r\nif (!(pll_in_use & (1 << ATOM_PPLL1)))\r\nreturn ATOM_PPLL1;\r\nDRM_ERROR("unable to allocate a PPLL\n");\r\nreturn ATOM_PPLL_INVALID;\r\n} else {\r\npll_in_use = radeon_get_pll_use_mask(crtc);\r\nif (!(pll_in_use & (1 << ATOM_PPLL2)))\r\nreturn ATOM_PPLL2;\r\nif (!(pll_in_use & (1 << ATOM_PPLL1)))\r\nreturn ATOM_PPLL1;\r\nif (!(pll_in_use & (1 << ATOM_PPLL0)))\r\nreturn ATOM_PPLL0;\r\nDRM_ERROR("unable to allocate a PPLL\n");\r\nreturn ATOM_PPLL_INVALID;\r\n}\r\n} else if (ASIC_IS_DCE61(rdev)) {\r\nstruct radeon_encoder_atom_dig *dig =\r\nradeon_encoder->enc_priv;\r\nif ((radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_UNIPHY) &&\r\n(dig->linkb == false))\r\nreturn ATOM_PPLL2;\r\nelse if (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(radeon_crtc->encoder))) {\r\nif (rdev->clock.dp_extclk)\r\nreturn ATOM_PPLL_INVALID;\r\nelse {\r\npll = radeon_get_shared_dp_ppll(crtc);\r\nif (pll != ATOM_PPLL_INVALID)\r\nreturn pll;\r\n}\r\n} else {\r\npll = radeon_get_shared_nondp_ppll(crtc);\r\nif (pll != ATOM_PPLL_INVALID)\r\nreturn pll;\r\n}\r\npll_in_use = radeon_get_pll_use_mask(crtc);\r\nif (!(pll_in_use & (1 << ATOM_PPLL0)))\r\nreturn ATOM_PPLL0;\r\nif (!(pll_in_use & (1 << ATOM_PPLL1)))\r\nreturn ATOM_PPLL1;\r\nDRM_ERROR("unable to allocate a PPLL\n");\r\nreturn ATOM_PPLL_INVALID;\r\n} else if (ASIC_IS_DCE41(rdev)) {\r\nif (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(radeon_crtc->encoder))) {\r\nif (rdev->clock.dp_extclk)\r\nreturn ATOM_PPLL_INVALID;\r\n}\r\npll_in_use = radeon_get_pll_use_mask(crtc);\r\nif (!(pll_in_use & (1 << ATOM_PPLL1)))\r\nreturn ATOM_PPLL1;\r\nif (!(pll_in_use & (1 << ATOM_PPLL2)))\r\nreturn ATOM_PPLL2;\r\nDRM_ERROR("unable to allocate a PPLL\n");\r\nreturn ATOM_PPLL_INVALID;\r\n} else if (ASIC_IS_DCE4(rdev)) {\r\nif (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(radeon_crtc->encoder))) {\r\nif (rdev->clock.dp_extclk)\r\nreturn ATOM_PPLL_INVALID;\r\nelse if (ASIC_IS_DCE6(rdev))\r\nreturn ATOM_PPLL0;\r\nelse if (ASIC_IS_DCE5(rdev))\r\nreturn ATOM_DCPLL;\r\nelse {\r\npll = radeon_get_shared_dp_ppll(crtc);\r\nif (pll != ATOM_PPLL_INVALID)\r\nreturn pll;\r\n}\r\n} else {\r\npll = radeon_get_shared_nondp_ppll(crtc);\r\nif (pll != ATOM_PPLL_INVALID)\r\nreturn pll;\r\n}\r\npll_in_use = radeon_get_pll_use_mask(crtc);\r\nif (!(pll_in_use & (1 << ATOM_PPLL1)))\r\nreturn ATOM_PPLL1;\r\nif (!(pll_in_use & (1 << ATOM_PPLL2)))\r\nreturn ATOM_PPLL2;\r\nDRM_ERROR("unable to allocate a PPLL\n");\r\nreturn ATOM_PPLL_INVALID;\r\n} else {\r\nreturn radeon_crtc->crtc_id;\r\n}\r\n}\r\nvoid radeon_atom_disp_eng_pll_init(struct radeon_device *rdev)\r\n{\r\nif (ASIC_IS_DCE6(rdev))\r\natombios_crtc_set_disp_eng_pll(rdev, rdev->clock.default_dispclk);\r\nelse if (ASIC_IS_DCE4(rdev)) {\r\nstruct radeon_atom_ss ss;\r\nbool ss_enabled = radeon_atombios_get_asic_ss_info(rdev, &ss,\r\nASIC_INTERNAL_SS_ON_DCPLL,\r\nrdev->clock.default_dispclk);\r\nif (ss_enabled)\r\natombios_crtc_program_ss(rdev, ATOM_DISABLE, ATOM_DCPLL, -1, &ss);\r\natombios_crtc_set_disp_eng_pll(rdev, rdev->clock.default_dispclk);\r\nif (ss_enabled)\r\natombios_crtc_program_ss(rdev, ATOM_ENABLE, ATOM_DCPLL, -1, &ss);\r\n}\r\n}\r\nint atombios_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nint x, int y, struct drm_framebuffer *old_fb)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder =\r\nto_radeon_encoder(radeon_crtc->encoder);\r\nbool is_tvcv = false;\r\nif (radeon_encoder->active_device &\r\n(ATOM_DEVICE_TV_SUPPORT | ATOM_DEVICE_CV_SUPPORT))\r\nis_tvcv = true;\r\nif (!radeon_crtc->adjusted_clock)\r\nreturn -EINVAL;\r\natombios_crtc_set_pll(crtc, adjusted_mode);\r\nif (ASIC_IS_DCE4(rdev))\r\natombios_set_crtc_dtd_timing(crtc, adjusted_mode);\r\nelse if (ASIC_IS_AVIVO(rdev)) {\r\nif (is_tvcv)\r\natombios_crtc_set_timing(crtc, adjusted_mode);\r\nelse\r\natombios_set_crtc_dtd_timing(crtc, adjusted_mode);\r\n} else {\r\natombios_crtc_set_timing(crtc, adjusted_mode);\r\nif (radeon_crtc->crtc_id == 0)\r\natombios_set_crtc_dtd_timing(crtc, adjusted_mode);\r\nradeon_legacy_atom_fixup(crtc);\r\n}\r\natombios_crtc_set_base(crtc, x, y, old_fb);\r\natombios_overscan_setup(crtc, mode, adjusted_mode);\r\natombios_scaler_setup(crtc);\r\nradeon_crtc->hw_mode = *adjusted_mode;\r\nreturn 0;\r\n}\r\nstatic bool atombios_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_encoder *encoder;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (encoder->crtc == crtc) {\r\nradeon_crtc->encoder = encoder;\r\nradeon_crtc->connector = radeon_get_connector_for_encoder(encoder);\r\nbreak;\r\n}\r\n}\r\nif ((radeon_crtc->encoder == NULL) || (radeon_crtc->connector == NULL)) {\r\nradeon_crtc->encoder = NULL;\r\nradeon_crtc->connector = NULL;\r\nreturn false;\r\n}\r\nif (!radeon_crtc_scaling_mode_fixup(crtc, mode, adjusted_mode))\r\nreturn false;\r\nif (!atombios_crtc_prepare_pll(crtc, adjusted_mode))\r\nreturn false;\r\nradeon_crtc->pll_id = radeon_atom_pick_pll(crtc);\r\nif ((radeon_crtc->pll_id == ATOM_PPLL_INVALID) &&\r\n!ENCODER_MODE_IS_DP(atombios_get_encoder_mode(radeon_crtc->encoder)))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void atombios_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (ASIC_IS_DCE6(rdev))\r\natombios_powergate_crtc(crtc, ATOM_DISABLE);\r\natombios_lock_crtc(crtc, ATOM_ENABLE);\r\natombios_crtc_dpms(crtc, DRM_MODE_DPMS_OFF);\r\n}\r\nstatic void atombios_crtc_commit(struct drm_crtc *crtc)\r\n{\r\natombios_crtc_dpms(crtc, DRM_MODE_DPMS_ON);\r\natombios_lock_crtc(crtc, ATOM_DISABLE);\r\n}\r\nstatic void atombios_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_atom_ss ss;\r\nint i;\r\natombios_crtc_dpms(crtc, DRM_MODE_DPMS_OFF);\r\nif (crtc->primary->fb) {\r\nint r;\r\nstruct radeon_framebuffer *radeon_fb;\r\nstruct radeon_bo *rbo;\r\nradeon_fb = to_radeon_framebuffer(crtc->primary->fb);\r\nrbo = gem_to_radeon_bo(radeon_fb->obj);\r\nr = radeon_bo_reserve(rbo, false);\r\nif (unlikely(r))\r\nDRM_ERROR("failed to reserve rbo before unpin\n");\r\nelse {\r\nradeon_bo_unpin(rbo);\r\nradeon_bo_unreserve(rbo);\r\n}\r\n}\r\nif (ASIC_IS_DCE4(rdev))\r\nWREG32(EVERGREEN_GRPH_ENABLE + radeon_crtc->crtc_offset, 0);\r\nelse if (ASIC_IS_AVIVO(rdev))\r\nWREG32(AVIVO_D1GRPH_ENABLE + radeon_crtc->crtc_offset, 0);\r\nif (ASIC_IS_DCE6(rdev))\r\natombios_powergate_crtc(crtc, ATOM_ENABLE);\r\nfor (i = 0; i < rdev->num_crtc; i++) {\r\nif (rdev->mode_info.crtcs[i] &&\r\nrdev->mode_info.crtcs[i]->enabled &&\r\ni != radeon_crtc->crtc_id &&\r\nradeon_crtc->pll_id == rdev->mode_info.crtcs[i]->pll_id) {\r\ngoto done;\r\n}\r\n}\r\nswitch (radeon_crtc->pll_id) {\r\ncase ATOM_PPLL1:\r\ncase ATOM_PPLL2:\r\natombios_crtc_program_pll(crtc, radeon_crtc->crtc_id, radeon_crtc->pll_id,\r\n0, 0, ATOM_DISABLE, 0, 0, 0, 0, 0, false, &ss);\r\nbreak;\r\ncase ATOM_PPLL0:\r\nif ((rdev->family == CHIP_ARUBA) ||\r\n(rdev->family == CHIP_BONAIRE) ||\r\n(rdev->family == CHIP_HAWAII))\r\natombios_crtc_program_pll(crtc, radeon_crtc->crtc_id, radeon_crtc->pll_id,\r\n0, 0, ATOM_DISABLE, 0, 0, 0, 0, 0, false, &ss);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndone:\r\nradeon_crtc->pll_id = ATOM_PPLL_INVALID;\r\nradeon_crtc->adjusted_clock = 0;\r\nradeon_crtc->encoder = NULL;\r\nradeon_crtc->connector = NULL;\r\n}\r\nvoid radeon_atombios_init_crtc(struct drm_device *dev,\r\nstruct radeon_crtc *radeon_crtc)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (ASIC_IS_DCE4(rdev)) {\r\nswitch (radeon_crtc->crtc_id) {\r\ncase 0:\r\ndefault:\r\nradeon_crtc->crtc_offset = EVERGREEN_CRTC0_REGISTER_OFFSET;\r\nbreak;\r\ncase 1:\r\nradeon_crtc->crtc_offset = EVERGREEN_CRTC1_REGISTER_OFFSET;\r\nbreak;\r\ncase 2:\r\nradeon_crtc->crtc_offset = EVERGREEN_CRTC2_REGISTER_OFFSET;\r\nbreak;\r\ncase 3:\r\nradeon_crtc->crtc_offset = EVERGREEN_CRTC3_REGISTER_OFFSET;\r\nbreak;\r\ncase 4:\r\nradeon_crtc->crtc_offset = EVERGREEN_CRTC4_REGISTER_OFFSET;\r\nbreak;\r\ncase 5:\r\nradeon_crtc->crtc_offset = EVERGREEN_CRTC5_REGISTER_OFFSET;\r\nbreak;\r\n}\r\n} else {\r\nif (radeon_crtc->crtc_id == 1)\r\nradeon_crtc->crtc_offset =\r\nAVIVO_D2CRTC_H_TOTAL - AVIVO_D1CRTC_H_TOTAL;\r\nelse\r\nradeon_crtc->crtc_offset = 0;\r\n}\r\nradeon_crtc->pll_id = ATOM_PPLL_INVALID;\r\nradeon_crtc->adjusted_clock = 0;\r\nradeon_crtc->encoder = NULL;\r\nradeon_crtc->connector = NULL;\r\ndrm_crtc_helper_add(&radeon_crtc->base, &atombios_helper_funcs);\r\n}
