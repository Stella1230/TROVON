static void\r\nkvp_register(int reg_value)\r\n{\r\nstruct cn_msg *msg;\r\nstruct hv_kvp_msg *kvp_msg;\r\nchar *version;\r\nmsg = kzalloc(sizeof(*msg) + sizeof(struct hv_kvp_msg), GFP_ATOMIC);\r\nif (msg) {\r\nkvp_msg = (struct hv_kvp_msg *)msg->data;\r\nversion = kvp_msg->body.kvp_register.version;\r\nmsg->id.idx = CN_KVP_IDX;\r\nmsg->id.val = CN_KVP_VAL;\r\nkvp_msg->kvp_hdr.operation = reg_value;\r\nstrcpy(version, HV_DRV_VERSION);\r\nmsg->len = sizeof(struct hv_kvp_msg);\r\ncn_netlink_send(msg, 0, 0, GFP_ATOMIC);\r\nkfree(msg);\r\n}\r\n}\r\nstatic void\r\nkvp_work_func(struct work_struct *dummy)\r\n{\r\nkvp_respond_to_host(NULL, HV_E_FAIL);\r\n}\r\nstatic void poll_channel(struct vmbus_channel *channel)\r\n{\r\nif (channel->target_cpu != smp_processor_id())\r\nsmp_call_function_single(channel->target_cpu,\r\nhv_kvp_onchannelcallback,\r\nchannel, true);\r\nelse\r\nhv_kvp_onchannelcallback(channel);\r\n}\r\nstatic int kvp_handle_handshake(struct hv_kvp_msg *msg)\r\n{\r\nint ret = 1;\r\nswitch (msg->kvp_hdr.operation) {\r\ncase KVP_OP_REGISTER:\r\ndm_reg_value = KVP_OP_REGISTER;\r\npr_info("KVP: IP injection functionality not available\n");\r\npr_info("KVP: Upgrade the KVP daemon\n");\r\nbreak;\r\ncase KVP_OP_REGISTER1:\r\ndm_reg_value = KVP_OP_REGISTER1;\r\nbreak;\r\ndefault:\r\npr_info("KVP: incompatible daemon\n");\r\npr_info("KVP: KVP version: %d, Daemon version: %d\n",\r\nKVP_OP_REGISTER1, msg->kvp_hdr.operation);\r\nret = 0;\r\n}\r\nif (ret) {\r\npr_info("KVP: user-mode registering done.\n");\r\nkvp_register(dm_reg_value);\r\nkvp_transaction.active = false;\r\nif (kvp_transaction.kvp_context)\r\npoll_channel(kvp_transaction.kvp_context);\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\nkvp_cn_callback(struct cn_msg *msg, struct netlink_skb_parms *nsp)\r\n{\r\nstruct hv_kvp_msg *message;\r\nstruct hv_kvp_msg_enumerate *data;\r\nint error = 0;\r\nmessage = (struct hv_kvp_msg *)msg->data;\r\nif (in_hand_shake) {\r\nif (kvp_handle_handshake(message))\r\nin_hand_shake = false;\r\nreturn;\r\n}\r\ndata = &message->body.kvp_enum_data;\r\nswitch (dm_reg_value) {\r\ncase KVP_OP_REGISTER:\r\nif (data->data.key[0] == 0)\r\nerror = HV_S_CONT;\r\nbreak;\r\ncase KVP_OP_REGISTER1:\r\nerror = message->error;\r\nbreak;\r\n}\r\nif (cancel_delayed_work_sync(&kvp_work))\r\nkvp_respond_to_host(message, error);\r\n}\r\nstatic int process_ob_ipinfo(void *in_msg, void *out_msg, int op)\r\n{\r\nstruct hv_kvp_msg *in = in_msg;\r\nstruct hv_kvp_ip_msg *out = out_msg;\r\nint len;\r\nswitch (op) {\r\ncase KVP_OP_GET_IP_INFO:\r\nlen = utf8s_to_utf16s((char *)in->body.kvp_ip_val.ip_addr,\r\nstrlen((char *)in->body.kvp_ip_val.ip_addr),\r\nUTF16_HOST_ENDIAN,\r\n(wchar_t *)out->kvp_ip_val.ip_addr,\r\nMAX_IP_ADDR_SIZE);\r\nif (len < 0)\r\nreturn len;\r\nlen = utf8s_to_utf16s((char *)in->body.kvp_ip_val.sub_net,\r\nstrlen((char *)in->body.kvp_ip_val.sub_net),\r\nUTF16_HOST_ENDIAN,\r\n(wchar_t *)out->kvp_ip_val.sub_net,\r\nMAX_IP_ADDR_SIZE);\r\nif (len < 0)\r\nreturn len;\r\nlen = utf8s_to_utf16s((char *)in->body.kvp_ip_val.gate_way,\r\nstrlen((char *)in->body.kvp_ip_val.gate_way),\r\nUTF16_HOST_ENDIAN,\r\n(wchar_t *)out->kvp_ip_val.gate_way,\r\nMAX_GATEWAY_SIZE);\r\nif (len < 0)\r\nreturn len;\r\nlen = utf8s_to_utf16s((char *)in->body.kvp_ip_val.dns_addr,\r\nstrlen((char *)in->body.kvp_ip_val.dns_addr),\r\nUTF16_HOST_ENDIAN,\r\n(wchar_t *)out->kvp_ip_val.dns_addr,\r\nMAX_IP_ADDR_SIZE);\r\nif (len < 0)\r\nreturn len;\r\nlen = utf8s_to_utf16s((char *)in->body.kvp_ip_val.adapter_id,\r\nstrlen((char *)in->body.kvp_ip_val.adapter_id),\r\nUTF16_HOST_ENDIAN,\r\n(wchar_t *)out->kvp_ip_val.adapter_id,\r\nMAX_IP_ADDR_SIZE);\r\nif (len < 0)\r\nreturn len;\r\nout->kvp_ip_val.dhcp_enabled =\r\nin->body.kvp_ip_val.dhcp_enabled;\r\nout->kvp_ip_val.addr_family =\r\nin->body.kvp_ip_val.addr_family;\r\n}\r\nreturn 0;\r\n}\r\nstatic void process_ib_ipinfo(void *in_msg, void *out_msg, int op)\r\n{\r\nstruct hv_kvp_ip_msg *in = in_msg;\r\nstruct hv_kvp_msg *out = out_msg;\r\nswitch (op) {\r\ncase KVP_OP_SET_IP_INFO:\r\nutf16s_to_utf8s((wchar_t *)in->kvp_ip_val.ip_addr,\r\nMAX_IP_ADDR_SIZE,\r\nUTF16_LITTLE_ENDIAN,\r\n(__u8 *)out->body.kvp_ip_val.ip_addr,\r\nMAX_IP_ADDR_SIZE);\r\nutf16s_to_utf8s((wchar_t *)in->kvp_ip_val.sub_net,\r\nMAX_IP_ADDR_SIZE,\r\nUTF16_LITTLE_ENDIAN,\r\n(__u8 *)out->body.kvp_ip_val.sub_net,\r\nMAX_IP_ADDR_SIZE);\r\nutf16s_to_utf8s((wchar_t *)in->kvp_ip_val.gate_way,\r\nMAX_GATEWAY_SIZE,\r\nUTF16_LITTLE_ENDIAN,\r\n(__u8 *)out->body.kvp_ip_val.gate_way,\r\nMAX_GATEWAY_SIZE);\r\nutf16s_to_utf8s((wchar_t *)in->kvp_ip_val.dns_addr,\r\nMAX_IP_ADDR_SIZE,\r\nUTF16_LITTLE_ENDIAN,\r\n(__u8 *)out->body.kvp_ip_val.dns_addr,\r\nMAX_IP_ADDR_SIZE);\r\nout->body.kvp_ip_val.dhcp_enabled = in->kvp_ip_val.dhcp_enabled;\r\ndefault:\r\nutf16s_to_utf8s((wchar_t *)in->kvp_ip_val.adapter_id,\r\nMAX_ADAPTER_ID_SIZE,\r\nUTF16_LITTLE_ENDIAN,\r\n(__u8 *)out->body.kvp_ip_val.adapter_id,\r\nMAX_ADAPTER_ID_SIZE);\r\nout->body.kvp_ip_val.addr_family = in->kvp_ip_val.addr_family;\r\n}\r\n}\r\nstatic void\r\nkvp_send_key(struct work_struct *dummy)\r\n{\r\nstruct cn_msg *msg;\r\nstruct hv_kvp_msg *message;\r\nstruct hv_kvp_msg *in_msg;\r\n__u8 operation = kvp_transaction.kvp_msg->kvp_hdr.operation;\r\n__u8 pool = kvp_transaction.kvp_msg->kvp_hdr.pool;\r\n__u32 val32;\r\n__u64 val64;\r\nmsg = kzalloc(sizeof(*msg) + sizeof(struct hv_kvp_msg) , GFP_ATOMIC);\r\nif (!msg)\r\nreturn;\r\nmsg->id.idx = CN_KVP_IDX;\r\nmsg->id.val = CN_KVP_VAL;\r\nmessage = (struct hv_kvp_msg *)msg->data;\r\nmessage->kvp_hdr.operation = operation;\r\nmessage->kvp_hdr.pool = pool;\r\nin_msg = kvp_transaction.kvp_msg;\r\nswitch (message->kvp_hdr.operation) {\r\ncase KVP_OP_SET_IP_INFO:\r\nprocess_ib_ipinfo(in_msg, message, KVP_OP_SET_IP_INFO);\r\nbreak;\r\ncase KVP_OP_GET_IP_INFO:\r\nprocess_ib_ipinfo(in_msg, message, KVP_OP_GET_IP_INFO);\r\nbreak;\r\ncase KVP_OP_SET:\r\nswitch (in_msg->body.kvp_set.data.value_type) {\r\ncase REG_SZ:\r\nmessage->body.kvp_set.data.value_size =\r\nutf16s_to_utf8s(\r\n(wchar_t *)in_msg->body.kvp_set.data.value,\r\nin_msg->body.kvp_set.data.value_size,\r\nUTF16_LITTLE_ENDIAN,\r\nmessage->body.kvp_set.data.value,\r\nHV_KVP_EXCHANGE_MAX_VALUE_SIZE - 1) + 1;\r\nbreak;\r\ncase REG_U32:\r\nval32 = in_msg->body.kvp_set.data.value_u32;\r\nmessage->body.kvp_set.data.value_size =\r\nsprintf(message->body.kvp_set.data.value,\r\n"%d", val32) + 1;\r\nbreak;\r\ncase REG_U64:\r\nval64 = in_msg->body.kvp_set.data.value_u64;\r\nmessage->body.kvp_set.data.value_size =\r\nsprintf(message->body.kvp_set.data.value,\r\n"%llu", val64) + 1;\r\nbreak;\r\n}\r\ncase KVP_OP_GET:\r\nmessage->body.kvp_set.data.key_size =\r\nutf16s_to_utf8s(\r\n(wchar_t *)in_msg->body.kvp_set.data.key,\r\nin_msg->body.kvp_set.data.key_size,\r\nUTF16_LITTLE_ENDIAN,\r\nmessage->body.kvp_set.data.key,\r\nHV_KVP_EXCHANGE_MAX_KEY_SIZE - 1) + 1;\r\nbreak;\r\ncase KVP_OP_DELETE:\r\nmessage->body.kvp_delete.key_size =\r\nutf16s_to_utf8s(\r\n(wchar_t *)in_msg->body.kvp_delete.key,\r\nin_msg->body.kvp_delete.key_size,\r\nUTF16_LITTLE_ENDIAN,\r\nmessage->body.kvp_delete.key,\r\nHV_KVP_EXCHANGE_MAX_KEY_SIZE - 1) + 1;\r\nbreak;\r\ncase KVP_OP_ENUMERATE:\r\nmessage->body.kvp_enum_data.index =\r\nin_msg->body.kvp_enum_data.index;\r\nbreak;\r\n}\r\nmsg->len = sizeof(struct hv_kvp_msg);\r\ncn_netlink_send(msg, 0, 0, GFP_ATOMIC);\r\nkfree(msg);\r\nreturn;\r\n}\r\nstatic void\r\nkvp_respond_to_host(struct hv_kvp_msg *msg_to_host, int error)\r\n{\r\nstruct hv_kvp_msg *kvp_msg;\r\nstruct hv_kvp_exchg_msg_value *kvp_data;\r\nchar *key_name;\r\nchar *value;\r\nstruct icmsg_hdr *icmsghdrp;\r\nint keylen = 0;\r\nint valuelen = 0;\r\nu32 buf_len;\r\nstruct vmbus_channel *channel;\r\nu64 req_id;\r\nint ret;\r\nif (!kvp_transaction.active) {\r\npr_warn("KVP: Transaction not active\n");\r\nreturn;\r\n}\r\nbuf_len = kvp_transaction.recv_len;\r\nchannel = kvp_transaction.recv_channel;\r\nreq_id = kvp_transaction.recv_req_id;\r\nkvp_transaction.active = false;\r\nicmsghdrp = (struct icmsg_hdr *)\r\n&recv_buffer[sizeof(struct vmbuspipe_hdr)];\r\nif (channel->onchannel_callback == NULL)\r\nreturn;\r\nicmsghdrp->status = error;\r\nif (error) {\r\ngoto response_done;\r\n}\r\nkvp_msg = (struct hv_kvp_msg *)\r\n&recv_buffer[sizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nswitch (kvp_transaction.kvp_msg->kvp_hdr.operation) {\r\ncase KVP_OP_GET_IP_INFO:\r\nret = process_ob_ipinfo(msg_to_host,\r\n(struct hv_kvp_ip_msg *)kvp_msg,\r\nKVP_OP_GET_IP_INFO);\r\nif (ret < 0)\r\nicmsghdrp->status = HV_E_FAIL;\r\ngoto response_done;\r\ncase KVP_OP_SET_IP_INFO:\r\ngoto response_done;\r\ncase KVP_OP_GET:\r\nkvp_data = &kvp_msg->body.kvp_get.data;\r\ngoto copy_value;\r\ncase KVP_OP_SET:\r\ncase KVP_OP_DELETE:\r\ngoto response_done;\r\ndefault:\r\nbreak;\r\n}\r\nkvp_data = &kvp_msg->body.kvp_enum_data.data;\r\nkey_name = msg_to_host->body.kvp_enum_data.data.key;\r\nkeylen = utf8s_to_utf16s(key_name, strlen(key_name), UTF16_HOST_ENDIAN,\r\n(wchar_t *) kvp_data->key,\r\n(HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2) - 2);\r\nkvp_data->key_size = 2*(keylen + 1);\r\ncopy_value:\r\nvalue = msg_to_host->body.kvp_enum_data.data.value;\r\nvaluelen = utf8s_to_utf16s(value, strlen(value), UTF16_HOST_ENDIAN,\r\n(wchar_t *) kvp_data->value,\r\n(HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2) - 2);\r\nkvp_data->value_size = 2*(valuelen + 1);\r\nif ((keylen < 0) || (valuelen < 0))\r\nicmsghdrp->status = HV_E_FAIL;\r\nkvp_data->value_type = REG_SZ;\r\nresponse_done:\r\nicmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, recv_buffer, buf_len, req_id,\r\nVM_PKT_DATA_INBAND, 0);\r\npoll_channel(channel);\r\n}\r\nvoid hv_kvp_onchannelcallback(void *context)\r\n{\r\nstruct vmbus_channel *channel = context;\r\nu32 recvlen;\r\nu64 requestid;\r\nstruct hv_kvp_msg *kvp_msg;\r\nstruct icmsg_hdr *icmsghdrp;\r\nstruct icmsg_negotiate *negop = NULL;\r\nint util_fw_version;\r\nint kvp_srv_version;\r\nif (kvp_transaction.active) {\r\nkvp_transaction.kvp_context = context;\r\nreturn;\r\n}\r\nvmbus_recvpacket(channel, recv_buffer, PAGE_SIZE * 4, &recvlen,\r\n&requestid);\r\nif (recvlen > 0) {\r\nicmsghdrp = (struct icmsg_hdr *)&recv_buffer[\r\nsizeof(struct vmbuspipe_hdr)];\r\nif (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {\r\nswitch (vmbus_proto_version) {\r\ncase (VERSION_WS2008):\r\nutil_fw_version = UTIL_WS2K8_FW_VERSION;\r\nkvp_srv_version = WS2008_SRV_VERSION;\r\nbreak;\r\ncase (VERSION_WIN7):\r\nutil_fw_version = UTIL_FW_VERSION;\r\nkvp_srv_version = WIN7_SRV_VERSION;\r\nbreak;\r\ndefault:\r\nutil_fw_version = UTIL_FW_VERSION;\r\nkvp_srv_version = WIN8_SRV_VERSION;\r\n}\r\nvmbus_prep_negotiate_resp(icmsghdrp, negop,\r\nrecv_buffer, util_fw_version,\r\nkvp_srv_version);\r\n} else {\r\nkvp_msg = (struct hv_kvp_msg *)&recv_buffer[\r\nsizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nkvp_transaction.recv_len = recvlen;\r\nkvp_transaction.recv_channel = channel;\r\nkvp_transaction.recv_req_id = requestid;\r\nkvp_transaction.active = true;\r\nkvp_transaction.kvp_msg = kvp_msg;\r\nschedule_work(&kvp_sendkey_work);\r\nschedule_delayed_work(&kvp_work, 5*HZ);\r\nreturn;\r\n}\r\nicmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION\r\n| ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, recv_buffer,\r\nrecvlen, requestid,\r\nVM_PKT_DATA_INBAND, 0);\r\n}\r\n}\r\nint\r\nhv_kvp_init(struct hv_util_service *srv)\r\n{\r\nint err;\r\nerr = cn_add_callback(&kvp_id, kvp_name, kvp_cn_callback);\r\nif (err)\r\nreturn err;\r\nrecv_buffer = srv->recv_buffer;\r\nkvp_transaction.active = true;\r\nreturn 0;\r\n}\r\nvoid hv_kvp_deinit(void)\r\n{\r\ncn_del_callback(&kvp_id);\r\ncancel_delayed_work_sync(&kvp_work);\r\ncancel_work_sync(&kvp_sendkey_work);\r\n}
