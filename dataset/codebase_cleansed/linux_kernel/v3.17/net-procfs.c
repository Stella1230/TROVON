static inline struct net_device *dev_from_same_bucket(struct seq_file *seq, loff_t *pos)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nstruct net_device *dev;\r\nstruct hlist_head *h;\r\nunsigned int count = 0, offset = get_offset(*pos);\r\nh = &net->dev_name_head[get_bucket(*pos)];\r\nhlist_for_each_entry_rcu(dev, h, name_hlist) {\r\nif (++count == offset)\r\nreturn dev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline struct net_device *dev_from_bucket(struct seq_file *seq, loff_t *pos)\r\n{\r\nstruct net_device *dev;\r\nunsigned int bucket;\r\ndo {\r\ndev = dev_from_same_bucket(seq, pos);\r\nif (dev)\r\nreturn dev;\r\nbucket = get_bucket(*pos) + 1;\r\n*pos = set_bucket_offset(bucket, 1);\r\n} while (bucket < NETDEV_HASHENTRIES);\r\nreturn NULL;\r\n}\r\nstatic void *dev_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(RCU)\r\n{\r\nrcu_read_lock();\r\nif (!*pos)\r\nreturn SEQ_START_TOKEN;\r\nif (get_bucket(*pos) >= NETDEV_HASHENTRIES)\r\nreturn NULL;\r\nreturn dev_from_bucket(seq, pos);\r\n}\r\nstatic void *dev_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\n++*pos;\r\nreturn dev_from_bucket(seq, pos);\r\n}\r\nstatic void dev_seq_stop(struct seq_file *seq, void *v)\r\n__releases(RCU)\r\n{\r\nrcu_read_unlock();\r\n}\r\nstatic void dev_seq_printf_stats(struct seq_file *seq, struct net_device *dev)\r\n{\r\nstruct rtnl_link_stats64 temp;\r\nconst struct rtnl_link_stats64 *stats = dev_get_stats(dev, &temp);\r\nseq_printf(seq, "%6s: %7llu %7llu %4llu %4llu %4llu %5llu %10llu %9llu "\r\n"%8llu %7llu %4llu %4llu %4llu %5llu %7llu %10llu\n",\r\ndev->name, stats->rx_bytes, stats->rx_packets,\r\nstats->rx_errors,\r\nstats->rx_dropped + stats->rx_missed_errors,\r\nstats->rx_fifo_errors,\r\nstats->rx_length_errors + stats->rx_over_errors +\r\nstats->rx_crc_errors + stats->rx_frame_errors,\r\nstats->rx_compressed, stats->multicast,\r\nstats->tx_bytes, stats->tx_packets,\r\nstats->tx_errors, stats->tx_dropped,\r\nstats->tx_fifo_errors, stats->collisions,\r\nstats->tx_carrier_errors +\r\nstats->tx_aborted_errors +\r\nstats->tx_window_errors +\r\nstats->tx_heartbeat_errors,\r\nstats->tx_compressed);\r\n}\r\nstatic int dev_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq, "Inter-| Receive "\r\n" | Transmit\n"\r\n" face |bytes packets errs drop fifo frame "\r\n"compressed multicast|bytes packets errs "\r\n"drop fifo colls carrier compressed\n");\r\nelse\r\ndev_seq_printf_stats(seq, v);\r\nreturn 0;\r\n}\r\nstatic struct softnet_data *softnet_get_online(loff_t *pos)\r\n{\r\nstruct softnet_data *sd = NULL;\r\nwhile (*pos < nr_cpu_ids)\r\nif (cpu_online(*pos)) {\r\nsd = &per_cpu(softnet_data, *pos);\r\nbreak;\r\n} else\r\n++*pos;\r\nreturn sd;\r\n}\r\nstatic void *softnet_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nreturn softnet_get_online(pos);\r\n}\r\nstatic void *softnet_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\n++*pos;\r\nreturn softnet_get_online(pos);\r\n}\r\nstatic void softnet_seq_stop(struct seq_file *seq, void *v)\r\n{\r\n}\r\nstatic int softnet_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct softnet_data *sd = v;\r\nunsigned int flow_limit_count = 0;\r\n#ifdef CONFIG_NET_FLOW_LIMIT\r\nstruct sd_flow_limit *fl;\r\nrcu_read_lock();\r\nfl = rcu_dereference(sd->flow_limit);\r\nif (fl)\r\nflow_limit_count = fl->count;\r\nrcu_read_unlock();\r\n#endif\r\nseq_printf(seq,\r\n"%08x %08x %08x %08x %08x %08x %08x %08x %08x %08x %08x\n",\r\nsd->processed, sd->dropped, sd->time_squeeze, 0,\r\n0, 0, 0, 0,\r\nsd->cpu_collision, sd->received_rps, flow_limit_count);\r\nreturn 0;\r\n}\r\nstatic int dev_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &dev_seq_ops,\r\nsizeof(struct seq_net_private));\r\n}\r\nstatic int softnet_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &softnet_seq_ops);\r\n}\r\nstatic void *ptype_get_idx(loff_t pos)\r\n{\r\nstruct packet_type *pt = NULL;\r\nloff_t i = 0;\r\nint t;\r\nlist_for_each_entry_rcu(pt, &ptype_all, list) {\r\nif (i == pos)\r\nreturn pt;\r\n++i;\r\n}\r\nfor (t = 0; t < PTYPE_HASH_SIZE; t++) {\r\nlist_for_each_entry_rcu(pt, &ptype_base[t], list) {\r\nif (i == pos)\r\nreturn pt;\r\n++i;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *ptype_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(RCU)\r\n{\r\nrcu_read_lock();\r\nreturn *pos ? ptype_get_idx(*pos - 1) : SEQ_START_TOKEN;\r\n}\r\nstatic void *ptype_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct packet_type *pt;\r\nstruct list_head *nxt;\r\nint hash;\r\n++*pos;\r\nif (v == SEQ_START_TOKEN)\r\nreturn ptype_get_idx(0);\r\npt = v;\r\nnxt = pt->list.next;\r\nif (pt->type == htons(ETH_P_ALL)) {\r\nif (nxt != &ptype_all)\r\ngoto found;\r\nhash = 0;\r\nnxt = ptype_base[0].next;\r\n} else\r\nhash = ntohs(pt->type) & PTYPE_HASH_MASK;\r\nwhile (nxt == &ptype_base[hash]) {\r\nif (++hash >= PTYPE_HASH_SIZE)\r\nreturn NULL;\r\nnxt = ptype_base[hash].next;\r\n}\r\nfound:\r\nreturn list_entry(nxt, struct packet_type, list);\r\n}\r\nstatic void ptype_seq_stop(struct seq_file *seq, void *v)\r\n__releases(RCU)\r\n{\r\nrcu_read_unlock();\r\n}\r\nstatic int ptype_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct packet_type *pt = v;\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq, "Type Device Function\n");\r\nelse if (pt->dev == NULL || dev_net(pt->dev) == seq_file_net(seq)) {\r\nif (pt->type == htons(ETH_P_ALL))\r\nseq_puts(seq, "ALL ");\r\nelse\r\nseq_printf(seq, "%04x", ntohs(pt->type));\r\nseq_printf(seq, " %-8s %pf\n",\r\npt->dev ? pt->dev->name : "", pt->func);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ptype_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &ptype_seq_ops,\r\nsizeof(struct seq_net_private));\r\n}\r\nstatic int __net_init dev_proc_net_init(struct net *net)\r\n{\r\nint rc = -ENOMEM;\r\nif (!proc_create("dev", S_IRUGO, net->proc_net, &dev_seq_fops))\r\ngoto out;\r\nif (!proc_create("softnet_stat", S_IRUGO, net->proc_net,\r\n&softnet_seq_fops))\r\ngoto out_dev;\r\nif (!proc_create("ptype", S_IRUGO, net->proc_net, &ptype_seq_fops))\r\ngoto out_softnet;\r\nif (wext_proc_init(net))\r\ngoto out_ptype;\r\nrc = 0;\r\nout:\r\nreturn rc;\r\nout_ptype:\r\nremove_proc_entry("ptype", net->proc_net);\r\nout_softnet:\r\nremove_proc_entry("softnet_stat", net->proc_net);\r\nout_dev:\r\nremove_proc_entry("dev", net->proc_net);\r\ngoto out;\r\n}\r\nstatic void __net_exit dev_proc_net_exit(struct net *net)\r\n{\r\nwext_proc_exit(net);\r\nremove_proc_entry("ptype", net->proc_net);\r\nremove_proc_entry("softnet_stat", net->proc_net);\r\nremove_proc_entry("dev", net->proc_net);\r\n}\r\nstatic int dev_mc_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nstruct net_device *dev = v;\r\nif (v == SEQ_START_TOKEN)\r\nreturn 0;\r\nnetif_addr_lock_bh(dev);\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint i;\r\nseq_printf(seq, "%-4d %-15s %-5d %-5d ", dev->ifindex,\r\ndev->name, ha->refcount, ha->global_use);\r\nfor (i = 0; i < dev->addr_len; i++)\r\nseq_printf(seq, "%02x", ha->addr[i]);\r\nseq_putc(seq, '\n');\r\n}\r\nnetif_addr_unlock_bh(dev);\r\nreturn 0;\r\n}\r\nstatic int dev_mc_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &dev_mc_seq_ops,\r\nsizeof(struct seq_net_private));\r\n}\r\nstatic int __net_init dev_mc_net_init(struct net *net)\r\n{\r\nif (!proc_create("dev_mcast", 0, net->proc_net, &dev_mc_seq_fops))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __net_exit dev_mc_net_exit(struct net *net)\r\n{\r\nremove_proc_entry("dev_mcast", net->proc_net);\r\n}\r\nint __init dev_proc_init(void)\r\n{\r\nint ret = register_pernet_subsys(&dev_proc_ops);\r\nif (!ret)\r\nreturn register_pernet_subsys(&dev_mc_net_ops);\r\nreturn ret;\r\n}
