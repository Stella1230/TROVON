int rt2x00usb_vendor_request(struct rt2x00_dev *rt2x00dev,\r\nconst u8 request, const u8 requesttype,\r\nconst u16 offset, const u16 value,\r\nvoid *buffer, const u16 buffer_length,\r\nconst int timeout)\r\n{\r\nstruct usb_device *usb_dev = to_usb_device_intf(rt2x00dev->dev);\r\nint status;\r\nunsigned int i;\r\nunsigned int pipe =\r\n(requesttype == USB_VENDOR_REQUEST_IN) ?\r\nusb_rcvctrlpipe(usb_dev, 0) : usb_sndctrlpipe(usb_dev, 0);\r\nif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\r\nreturn -ENODEV;\r\nfor (i = 0; i < REGISTER_BUSY_COUNT; i++) {\r\nstatus = usb_control_msg(usb_dev, pipe, request, requesttype,\r\nvalue, offset, buffer, buffer_length,\r\ntimeout);\r\nif (status >= 0)\r\nreturn 0;\r\nelse if (status == -ENODEV) {\r\nclear_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags);\r\nbreak;\r\n}\r\n}\r\nif (status == -EPROTO)\r\nclear_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags);\r\nrt2x00_err(rt2x00dev,\r\n"Vendor Request 0x%02x failed for offset 0x%04x with error %d\n",\r\nrequest, offset, status);\r\nreturn status;\r\n}\r\nint rt2x00usb_vendor_req_buff_lock(struct rt2x00_dev *rt2x00dev,\r\nconst u8 request, const u8 requesttype,\r\nconst u16 offset, void *buffer,\r\nconst u16 buffer_length, const int timeout)\r\n{\r\nint status;\r\nBUG_ON(!mutex_is_locked(&rt2x00dev->csr_mutex));\r\nif (unlikely(!rt2x00dev->csr.cache || buffer_length > CSR_CACHE_SIZE)) {\r\nrt2x00_err(rt2x00dev, "CSR cache not available\n");\r\nreturn -ENOMEM;\r\n}\r\nif (requesttype == USB_VENDOR_REQUEST_OUT)\r\nmemcpy(rt2x00dev->csr.cache, buffer, buffer_length);\r\nstatus = rt2x00usb_vendor_request(rt2x00dev, request, requesttype,\r\noffset, 0, rt2x00dev->csr.cache,\r\nbuffer_length, timeout);\r\nif (!status && requesttype == USB_VENDOR_REQUEST_IN)\r\nmemcpy(buffer, rt2x00dev->csr.cache, buffer_length);\r\nreturn status;\r\n}\r\nint rt2x00usb_vendor_request_buff(struct rt2x00_dev *rt2x00dev,\r\nconst u8 request, const u8 requesttype,\r\nconst u16 offset, void *buffer,\r\nconst u16 buffer_length, const int timeout)\r\n{\r\nint status = 0;\r\nunsigned char *tb;\r\nu16 off, len, bsize;\r\nmutex_lock(&rt2x00dev->csr_mutex);\r\ntb = (char *)buffer;\r\noff = offset;\r\nlen = buffer_length;\r\nwhile (len && !status) {\r\nbsize = min_t(u16, CSR_CACHE_SIZE, len);\r\nstatus = rt2x00usb_vendor_req_buff_lock(rt2x00dev, request,\r\nrequesttype, off, tb,\r\nbsize, timeout);\r\ntb += bsize;\r\nlen -= bsize;\r\noff += bsize;\r\n}\r\nmutex_unlock(&rt2x00dev->csr_mutex);\r\nreturn status;\r\n}\r\nint rt2x00usb_regbusy_read(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int offset,\r\nconst struct rt2x00_field32 field,\r\nu32 *reg)\r\n{\r\nunsigned int i;\r\nif (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\r\nreturn -ENODEV;\r\nfor (i = 0; i < REGISTER_BUSY_COUNT; i++) {\r\nrt2x00usb_register_read_lock(rt2x00dev, offset, reg);\r\nif (!rt2x00_get_field32(*reg, field))\r\nreturn 1;\r\nudelay(REGISTER_BUSY_DELAY);\r\n}\r\nrt2x00_err(rt2x00dev, "Indirect register access failed: offset=0x%.08x, value=0x%.08x\n",\r\noffset, *reg);\r\n*reg = ~0;\r\nreturn 0;\r\n}\r\nstatic void rt2x00usb_register_read_async_cb(struct urb *urb)\r\n{\r\nstruct rt2x00_async_read_data *rd = urb->context;\r\nif (rd->callback(rd->rt2x00dev, urb->status, le32_to_cpu(rd->reg))) {\r\nif (usb_submit_urb(urb, GFP_ATOMIC) < 0)\r\nkfree(rd);\r\n} else\r\nkfree(rd);\r\n}\r\nvoid rt2x00usb_register_read_async(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int offset,\r\nbool (*callback)(struct rt2x00_dev*, int, u32))\r\n{\r\nstruct usb_device *usb_dev = to_usb_device_intf(rt2x00dev->dev);\r\nstruct urb *urb;\r\nstruct rt2x00_async_read_data *rd;\r\nrd = kmalloc(sizeof(*rd), GFP_ATOMIC);\r\nif (!rd)\r\nreturn;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb) {\r\nkfree(rd);\r\nreturn;\r\n}\r\nrd->rt2x00dev = rt2x00dev;\r\nrd->callback = callback;\r\nrd->cr.bRequestType = USB_VENDOR_REQUEST_IN;\r\nrd->cr.bRequest = USB_MULTI_READ;\r\nrd->cr.wValue = 0;\r\nrd->cr.wIndex = cpu_to_le16(offset);\r\nrd->cr.wLength = cpu_to_le16(sizeof(u32));\r\nusb_fill_control_urb(urb, usb_dev, usb_rcvctrlpipe(usb_dev, 0),\r\n(unsigned char *)(&rd->cr), &rd->reg, sizeof(rd->reg),\r\nrt2x00usb_register_read_async_cb, rd);\r\nif (usb_submit_urb(urb, GFP_ATOMIC) < 0)\r\nkfree(rd);\r\nusb_free_urb(urb);\r\n}\r\nstatic void rt2x00usb_work_txdone_entry(struct queue_entry *entry)\r\n{\r\nif (test_bit(ENTRY_DATA_IO_FAILED, &entry->flags))\r\nrt2x00lib_txdone_noinfo(entry, TXDONE_FAILURE);\r\nelse\r\nrt2x00lib_txdone_noinfo(entry, TXDONE_UNKNOWN);\r\n}\r\nstatic void rt2x00usb_work_txdone(struct work_struct *work)\r\n{\r\nstruct rt2x00_dev *rt2x00dev =\r\ncontainer_of(work, struct rt2x00_dev, txdone_work);\r\nstruct data_queue *queue;\r\nstruct queue_entry *entry;\r\ntx_queue_for_each(rt2x00dev, queue) {\r\nwhile (!rt2x00queue_empty(queue)) {\r\nentry = rt2x00queue_get_entry(queue, Q_INDEX_DONE);\r\nif (test_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags) ||\r\n!test_bit(ENTRY_DATA_STATUS_PENDING, &entry->flags))\r\nbreak;\r\nrt2x00usb_work_txdone_entry(entry);\r\n}\r\n}\r\n}\r\nstatic void rt2x00usb_interrupt_txdone(struct urb *urb)\r\n{\r\nstruct queue_entry *entry = (struct queue_entry *)urb->context;\r\nstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\r\nif (!test_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags))\r\nreturn;\r\nif (urb->status)\r\nset_bit(ENTRY_DATA_IO_FAILED, &entry->flags);\r\nrt2x00lib_dmadone(entry);\r\nif (rt2x00dev->ops->lib->tx_dma_done)\r\nrt2x00dev->ops->lib->tx_dma_done(entry);\r\nif (!test_bit(REQUIRE_TXSTATUS_FIFO, &rt2x00dev->cap_flags) ||\r\n!kfifo_is_empty(&rt2x00dev->txstatus_fifo))\r\nqueue_work(rt2x00dev->workqueue, &rt2x00dev->txdone_work);\r\n}\r\nstatic bool rt2x00usb_kick_tx_entry(struct queue_entry *entry, void *data)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\r\nstruct usb_device *usb_dev = to_usb_device_intf(rt2x00dev->dev);\r\nstruct queue_entry_priv_usb *entry_priv = entry->priv_data;\r\nu32 length;\r\nint status;\r\nif (!test_and_clear_bit(ENTRY_DATA_PENDING, &entry->flags) ||\r\ntest_bit(ENTRY_DATA_STATUS_PENDING, &entry->flags))\r\nreturn false;\r\nlength = rt2x00dev->ops->lib->get_tx_data_len(entry);\r\nstatus = skb_padto(entry->skb, length);\r\nif (unlikely(status)) {\r\nrt2x00_warn(rt2x00dev, "TX SKB padding error, out of memory\n");\r\nset_bit(ENTRY_DATA_IO_FAILED, &entry->flags);\r\nrt2x00lib_dmadone(entry);\r\nreturn false;\r\n}\r\nusb_fill_bulk_urb(entry_priv->urb, usb_dev,\r\nusb_sndbulkpipe(usb_dev, entry->queue->usb_endpoint),\r\nentry->skb->data, length,\r\nrt2x00usb_interrupt_txdone, entry);\r\nstatus = usb_submit_urb(entry_priv->urb, GFP_ATOMIC);\r\nif (status) {\r\nif (status == -ENODEV)\r\nclear_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags);\r\nset_bit(ENTRY_DATA_IO_FAILED, &entry->flags);\r\nrt2x00lib_dmadone(entry);\r\n}\r\nreturn false;\r\n}\r\nstatic void rt2x00usb_work_rxdone(struct work_struct *work)\r\n{\r\nstruct rt2x00_dev *rt2x00dev =\r\ncontainer_of(work, struct rt2x00_dev, rxdone_work);\r\nstruct queue_entry *entry;\r\nstruct skb_frame_desc *skbdesc;\r\nu8 rxd[32];\r\nwhile (!rt2x00queue_empty(rt2x00dev->rx)) {\r\nentry = rt2x00queue_get_entry(rt2x00dev->rx, Q_INDEX_DONE);\r\nif (test_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags) ||\r\n!test_bit(ENTRY_DATA_STATUS_PENDING, &entry->flags))\r\nbreak;\r\nskbdesc = get_skb_frame_desc(entry->skb);\r\nskbdesc->desc = rxd;\r\nskbdesc->desc_len = entry->queue->desc_size;\r\nrt2x00lib_rxdone(entry, GFP_KERNEL);\r\n}\r\n}\r\nstatic void rt2x00usb_interrupt_rxdone(struct urb *urb)\r\n{\r\nstruct queue_entry *entry = (struct queue_entry *)urb->context;\r\nstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\r\nif (!test_and_clear_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags))\r\nreturn;\r\nrt2x00lib_dmadone(entry);\r\nif (urb->actual_length < entry->queue->desc_size || urb->status)\r\nset_bit(ENTRY_DATA_IO_FAILED, &entry->flags);\r\nqueue_work(rt2x00dev->workqueue, &rt2x00dev->rxdone_work);\r\n}\r\nstatic bool rt2x00usb_kick_rx_entry(struct queue_entry *entry, void *data)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\r\nstruct usb_device *usb_dev = to_usb_device_intf(rt2x00dev->dev);\r\nstruct queue_entry_priv_usb *entry_priv = entry->priv_data;\r\nint status;\r\nif (test_and_set_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags) ||\r\ntest_bit(ENTRY_DATA_STATUS_PENDING, &entry->flags))\r\nreturn false;\r\nrt2x00lib_dmastart(entry);\r\nusb_fill_bulk_urb(entry_priv->urb, usb_dev,\r\nusb_rcvbulkpipe(usb_dev, entry->queue->usb_endpoint),\r\nentry->skb->data, entry->skb->len,\r\nrt2x00usb_interrupt_rxdone, entry);\r\nstatus = usb_submit_urb(entry_priv->urb, GFP_ATOMIC);\r\nif (status) {\r\nif (status == -ENODEV)\r\nclear_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags);\r\nset_bit(ENTRY_DATA_IO_FAILED, &entry->flags);\r\nrt2x00lib_dmadone(entry);\r\n}\r\nreturn false;\r\n}\r\nvoid rt2x00usb_kick_queue(struct data_queue *queue)\r\n{\r\nswitch (queue->qid) {\r\ncase QID_AC_VO:\r\ncase QID_AC_VI:\r\ncase QID_AC_BE:\r\ncase QID_AC_BK:\r\nif (!rt2x00queue_empty(queue))\r\nrt2x00queue_for_each_entry(queue,\r\nQ_INDEX_DONE,\r\nQ_INDEX,\r\nNULL,\r\nrt2x00usb_kick_tx_entry);\r\nbreak;\r\ncase QID_RX:\r\nif (!rt2x00queue_full(queue))\r\nrt2x00queue_for_each_entry(queue,\r\nQ_INDEX,\r\nQ_INDEX_DONE,\r\nNULL,\r\nrt2x00usb_kick_rx_entry);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic bool rt2x00usb_flush_entry(struct queue_entry *entry, void *data)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\r\nstruct queue_entry_priv_usb *entry_priv = entry->priv_data;\r\nstruct queue_entry_priv_usb_bcn *bcn_priv = entry->priv_data;\r\nif (!test_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags))\r\nreturn false;\r\nusb_kill_urb(entry_priv->urb);\r\nif ((entry->queue->qid == QID_BEACON) &&\r\n(test_bit(REQUIRE_BEACON_GUARD, &rt2x00dev->cap_flags)))\r\nusb_kill_urb(bcn_priv->guardian_urb);\r\nreturn false;\r\n}\r\nvoid rt2x00usb_flush_queue(struct data_queue *queue, bool drop)\r\n{\r\nstruct work_struct *completion;\r\nunsigned int i;\r\nif (drop)\r\nrt2x00queue_for_each_entry(queue, Q_INDEX_DONE, Q_INDEX, NULL,\r\nrt2x00usb_flush_entry);\r\nswitch (queue->qid) {\r\ncase QID_AC_VO:\r\ncase QID_AC_VI:\r\ncase QID_AC_BE:\r\ncase QID_AC_BK:\r\ncompletion = &queue->rt2x00dev->txdone_work;\r\nbreak;\r\ncase QID_RX:\r\ncompletion = &queue->rt2x00dev->rxdone_work;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nfor (i = 0; i < 10; i++) {\r\nif (rt2x00queue_empty(queue))\r\nbreak;\r\nqueue_work(queue->rt2x00dev->workqueue, completion);\r\nmsleep(10);\r\n}\r\n}\r\nstatic void rt2x00usb_watchdog_tx_dma(struct data_queue *queue)\r\n{\r\nrt2x00_warn(queue->rt2x00dev, "TX queue %d DMA timed out, invoke forced forced reset\n",\r\nqueue->qid);\r\nrt2x00queue_stop_queue(queue);\r\nrt2x00queue_flush_queue(queue, true);\r\nrt2x00queue_start_queue(queue);\r\n}\r\nstatic int rt2x00usb_dma_timeout(struct data_queue *queue)\r\n{\r\nstruct queue_entry *entry;\r\nentry = rt2x00queue_get_entry(queue, Q_INDEX_DMA_DONE);\r\nreturn rt2x00queue_dma_timeout(entry);\r\n}\r\nvoid rt2x00usb_watchdog(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct data_queue *queue;\r\ntx_queue_for_each(rt2x00dev, queue) {\r\nif (!rt2x00queue_empty(queue)) {\r\nif (rt2x00usb_dma_timeout(queue))\r\nrt2x00usb_watchdog_tx_dma(queue);\r\n}\r\n}\r\n}\r\nvoid rt2x00usb_disable_radio(struct rt2x00_dev *rt2x00dev)\r\n{\r\nrt2x00usb_vendor_request_sw(rt2x00dev, USB_RX_CONTROL, 0, 0,\r\nREGISTER_TIMEOUT);\r\n}\r\nvoid rt2x00usb_clear_entry(struct queue_entry *entry)\r\n{\r\nentry->flags = 0;\r\nif (entry->queue->qid == QID_RX)\r\nrt2x00usb_kick_rx_entry(entry, NULL);\r\n}\r\nstatic void rt2x00usb_assign_endpoint(struct data_queue *queue,\r\nstruct usb_endpoint_descriptor *ep_desc)\r\n{\r\nstruct usb_device *usb_dev = to_usb_device_intf(queue->rt2x00dev->dev);\r\nint pipe;\r\nqueue->usb_endpoint = usb_endpoint_num(ep_desc);\r\nif (queue->qid == QID_RX) {\r\npipe = usb_rcvbulkpipe(usb_dev, queue->usb_endpoint);\r\nqueue->usb_maxpacket = usb_maxpacket(usb_dev, pipe, 0);\r\n} else {\r\npipe = usb_sndbulkpipe(usb_dev, queue->usb_endpoint);\r\nqueue->usb_maxpacket = usb_maxpacket(usb_dev, pipe, 1);\r\n}\r\nif (!queue->usb_maxpacket)\r\nqueue->usb_maxpacket = 1;\r\n}\r\nstatic int rt2x00usb_find_endpoints(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(rt2x00dev->dev);\r\nstruct usb_host_interface *intf_desc = intf->cur_altsetting;\r\nstruct usb_endpoint_descriptor *ep_desc;\r\nstruct data_queue *queue = rt2x00dev->tx;\r\nstruct usb_endpoint_descriptor *tx_ep_desc = NULL;\r\nunsigned int i;\r\nfor (i = 0; i < intf_desc->desc.bNumEndpoints; i++) {\r\nep_desc = &intf_desc->endpoint[i].desc;\r\nif (usb_endpoint_is_bulk_in(ep_desc)) {\r\nrt2x00usb_assign_endpoint(rt2x00dev->rx, ep_desc);\r\n} else if (usb_endpoint_is_bulk_out(ep_desc) &&\r\n(queue != queue_end(rt2x00dev))) {\r\nrt2x00usb_assign_endpoint(queue, ep_desc);\r\nqueue = queue_next(queue);\r\ntx_ep_desc = ep_desc;\r\n}\r\n}\r\nif (!rt2x00dev->rx->usb_endpoint || !rt2x00dev->tx->usb_endpoint) {\r\nrt2x00_err(rt2x00dev, "Bulk-in/Bulk-out endpoints not found\n");\r\nreturn -EPIPE;\r\n}\r\ntxall_queue_for_each(rt2x00dev, queue) {\r\nif (!queue->usb_endpoint)\r\nrt2x00usb_assign_endpoint(queue, tx_ep_desc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt2x00usb_alloc_entries(struct data_queue *queue)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\r\nstruct queue_entry_priv_usb *entry_priv;\r\nstruct queue_entry_priv_usb_bcn *bcn_priv;\r\nunsigned int i;\r\nfor (i = 0; i < queue->limit; i++) {\r\nentry_priv = queue->entries[i].priv_data;\r\nentry_priv->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!entry_priv->urb)\r\nreturn -ENOMEM;\r\n}\r\nif (queue->qid != QID_BEACON ||\r\n!test_bit(REQUIRE_BEACON_GUARD, &rt2x00dev->cap_flags))\r\nreturn 0;\r\nfor (i = 0; i < queue->limit; i++) {\r\nbcn_priv = queue->entries[i].priv_data;\r\nbcn_priv->guardian_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!bcn_priv->guardian_urb)\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rt2x00usb_free_entries(struct data_queue *queue)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\r\nstruct queue_entry_priv_usb *entry_priv;\r\nstruct queue_entry_priv_usb_bcn *bcn_priv;\r\nunsigned int i;\r\nif (!queue->entries)\r\nreturn;\r\nfor (i = 0; i < queue->limit; i++) {\r\nentry_priv = queue->entries[i].priv_data;\r\nusb_kill_urb(entry_priv->urb);\r\nusb_free_urb(entry_priv->urb);\r\n}\r\nif (queue->qid != QID_BEACON ||\r\n!test_bit(REQUIRE_BEACON_GUARD, &rt2x00dev->cap_flags))\r\nreturn;\r\nfor (i = 0; i < queue->limit; i++) {\r\nbcn_priv = queue->entries[i].priv_data;\r\nusb_kill_urb(bcn_priv->guardian_urb);\r\nusb_free_urb(bcn_priv->guardian_urb);\r\n}\r\n}\r\nint rt2x00usb_initialize(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct data_queue *queue;\r\nint status;\r\nstatus = rt2x00usb_find_endpoints(rt2x00dev);\r\nif (status)\r\ngoto exit;\r\nqueue_for_each(rt2x00dev, queue) {\r\nstatus = rt2x00usb_alloc_entries(queue);\r\nif (status)\r\ngoto exit;\r\n}\r\nreturn 0;\r\nexit:\r\nrt2x00usb_uninitialize(rt2x00dev);\r\nreturn status;\r\n}\r\nvoid rt2x00usb_uninitialize(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct data_queue *queue;\r\nqueue_for_each(rt2x00dev, queue)\r\nrt2x00usb_free_entries(queue);\r\n}\r\nstatic void rt2x00usb_free_reg(struct rt2x00_dev *rt2x00dev)\r\n{\r\nkfree(rt2x00dev->rf);\r\nrt2x00dev->rf = NULL;\r\nkfree(rt2x00dev->eeprom);\r\nrt2x00dev->eeprom = NULL;\r\nkfree(rt2x00dev->csr.cache);\r\nrt2x00dev->csr.cache = NULL;\r\n}\r\nstatic int rt2x00usb_alloc_reg(struct rt2x00_dev *rt2x00dev)\r\n{\r\nrt2x00dev->csr.cache = kzalloc(CSR_CACHE_SIZE, GFP_KERNEL);\r\nif (!rt2x00dev->csr.cache)\r\ngoto exit;\r\nrt2x00dev->eeprom = kzalloc(rt2x00dev->ops->eeprom_size, GFP_KERNEL);\r\nif (!rt2x00dev->eeprom)\r\ngoto exit;\r\nrt2x00dev->rf = kzalloc(rt2x00dev->ops->rf_size, GFP_KERNEL);\r\nif (!rt2x00dev->rf)\r\ngoto exit;\r\nreturn 0;\r\nexit:\r\nrt2x00_probe_err("Failed to allocate registers\n");\r\nrt2x00usb_free_reg(rt2x00dev);\r\nreturn -ENOMEM;\r\n}\r\nint rt2x00usb_probe(struct usb_interface *usb_intf,\r\nconst struct rt2x00_ops *ops)\r\n{\r\nstruct usb_device *usb_dev = interface_to_usbdev(usb_intf);\r\nstruct ieee80211_hw *hw;\r\nstruct rt2x00_dev *rt2x00dev;\r\nint retval;\r\nusb_dev = usb_get_dev(usb_dev);\r\nusb_reset_device(usb_dev);\r\nhw = ieee80211_alloc_hw(sizeof(struct rt2x00_dev), ops->hw);\r\nif (!hw) {\r\nrt2x00_probe_err("Failed to allocate hardware\n");\r\nretval = -ENOMEM;\r\ngoto exit_put_device;\r\n}\r\nusb_set_intfdata(usb_intf, hw);\r\nrt2x00dev = hw->priv;\r\nrt2x00dev->dev = &usb_intf->dev;\r\nrt2x00dev->ops = ops;\r\nrt2x00dev->hw = hw;\r\nrt2x00_set_chip_intf(rt2x00dev, RT2X00_CHIP_INTF_USB);\r\nINIT_WORK(&rt2x00dev->rxdone_work, rt2x00usb_work_rxdone);\r\nINIT_WORK(&rt2x00dev->txdone_work, rt2x00usb_work_txdone);\r\nhrtimer_init(&rt2x00dev->txstatus_timer, CLOCK_MONOTONIC,\r\nHRTIMER_MODE_REL);\r\nretval = rt2x00usb_alloc_reg(rt2x00dev);\r\nif (retval)\r\ngoto exit_free_device;\r\nretval = rt2x00lib_probe_dev(rt2x00dev);\r\nif (retval)\r\ngoto exit_free_reg;\r\nreturn 0;\r\nexit_free_reg:\r\nrt2x00usb_free_reg(rt2x00dev);\r\nexit_free_device:\r\nieee80211_free_hw(hw);\r\nexit_put_device:\r\nusb_put_dev(usb_dev);\r\nusb_set_intfdata(usb_intf, NULL);\r\nreturn retval;\r\n}\r\nvoid rt2x00usb_disconnect(struct usb_interface *usb_intf)\r\n{\r\nstruct ieee80211_hw *hw = usb_get_intfdata(usb_intf);\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nrt2x00lib_remove_dev(rt2x00dev);\r\nrt2x00usb_free_reg(rt2x00dev);\r\nieee80211_free_hw(hw);\r\nusb_set_intfdata(usb_intf, NULL);\r\nusb_put_dev(interface_to_usbdev(usb_intf));\r\n}\r\nint rt2x00usb_suspend(struct usb_interface *usb_intf, pm_message_t state)\r\n{\r\nstruct ieee80211_hw *hw = usb_get_intfdata(usb_intf);\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nreturn rt2x00lib_suspend(rt2x00dev, state);\r\n}\r\nint rt2x00usb_resume(struct usb_interface *usb_intf)\r\n{\r\nstruct ieee80211_hw *hw = usb_get_intfdata(usb_intf);\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nreturn rt2x00lib_resume(rt2x00dev);\r\n}
