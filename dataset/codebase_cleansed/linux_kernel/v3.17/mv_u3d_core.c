static void mv_u3d_ep0_reset(struct mv_u3d *u3d)\r\n{\r\nstruct mv_u3d_ep *ep;\r\nu32 epxcr;\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nep = &u3d->eps[i];\r\nep->u3d = u3d;\r\nep->ep_context = &u3d->ep_context[1];\r\n}\r\nepxcr = ioread32(&u3d->vuc_regs->epcr[0].epxoutcr0);\r\nepxcr |= MV_U3D_EPXCR_EP_INIT;\r\niowrite32(epxcr, &u3d->vuc_regs->epcr[0].epxoutcr0);\r\nudelay(5);\r\nepxcr &= ~MV_U3D_EPXCR_EP_INIT;\r\niowrite32(epxcr, &u3d->vuc_regs->epcr[0].epxoutcr0);\r\nepxcr = ((MV_U3D_EP0_MAX_PKT_SIZE\r\n<< MV_U3D_EPXCR_MAX_PACKET_SIZE_SHIFT)\r\n| (1 << MV_U3D_EPXCR_MAX_BURST_SIZE_SHIFT)\r\n| (1 << MV_U3D_EPXCR_EP_ENABLE_SHIFT)\r\n| MV_U3D_EPXCR_EP_TYPE_CONTROL);\r\niowrite32(epxcr, &u3d->vuc_regs->epcr[0].epxoutcr1);\r\nepxcr = ioread32(&u3d->vuc_regs->epcr[0].epxincr0);\r\nepxcr |= MV_U3D_EPXCR_EP_INIT;\r\niowrite32(epxcr, &u3d->vuc_regs->epcr[0].epxincr0);\r\nudelay(5);\r\nepxcr &= ~MV_U3D_EPXCR_EP_INIT;\r\niowrite32(epxcr, &u3d->vuc_regs->epcr[0].epxincr0);\r\nepxcr = ((MV_U3D_EP0_MAX_PKT_SIZE\r\n<< MV_U3D_EPXCR_MAX_PACKET_SIZE_SHIFT)\r\n| (1 << MV_U3D_EPXCR_MAX_BURST_SIZE_SHIFT)\r\n| (1 << MV_U3D_EPXCR_EP_ENABLE_SHIFT)\r\n| MV_U3D_EPXCR_EP_TYPE_CONTROL);\r\niowrite32(epxcr, &u3d->vuc_regs->epcr[0].epxincr1);\r\n}\r\nstatic void mv_u3d_ep0_stall(struct mv_u3d *u3d)\r\n{\r\nu32 tmp;\r\ndev_dbg(u3d->dev, "%s\n", __func__);\r\ntmp = ioread32(&u3d->vuc_regs->epcr[0].epxoutcr0);\r\ntmp |= MV_U3D_EPXCR_EP_HALT;\r\niowrite32(tmp, &u3d->vuc_regs->epcr[0].epxoutcr0);\r\ntmp = ioread32(&u3d->vuc_regs->epcr[0].epxincr0);\r\ntmp |= MV_U3D_EPXCR_EP_HALT;\r\niowrite32(tmp, &u3d->vuc_regs->epcr[0].epxincr0);\r\nu3d->ep0_state = MV_U3D_WAIT_FOR_SETUP;\r\nu3d->ep0_dir = MV_U3D_EP_DIR_OUT;\r\n}\r\nstatic int mv_u3d_process_ep_req(struct mv_u3d *u3d, int index,\r\nstruct mv_u3d_req *curr_req)\r\n{\r\nstruct mv_u3d_trb *curr_trb;\r\ndma_addr_t cur_deq_lo;\r\nstruct mv_u3d_ep_context *curr_ep_context;\r\nint trb_complete, actual, remaining_length = 0;\r\nint direction, ep_num;\r\nint retval = 0;\r\nu32 tmp, status, length;\r\ncurr_ep_context = &u3d->ep_context[index];\r\ndirection = index % 2;\r\nep_num = index / 2;\r\ntrb_complete = 0;\r\nactual = curr_req->req.length;\r\nwhile (!list_empty(&curr_req->trb_list)) {\r\ncurr_trb = list_entry(curr_req->trb_list.next,\r\nstruct mv_u3d_trb, trb_list);\r\nif (!curr_trb->trb_hw->ctrl.own) {\r\ndev_err(u3d->dev, "%s, TRB own error!\n",\r\nu3d->eps[index].name);\r\nreturn 1;\r\n}\r\ncurr_trb->trb_hw->ctrl.own = 0;\r\nif (direction == MV_U3D_EP_DIR_OUT) {\r\ntmp = ioread32(&u3d->vuc_regs->rxst[ep_num].statuslo);\r\ncur_deq_lo =\r\nioread32(&u3d->vuc_regs->rxst[ep_num].curdeqlo);\r\n} else {\r\ntmp = ioread32(&u3d->vuc_regs->txst[ep_num].statuslo);\r\ncur_deq_lo =\r\nioread32(&u3d->vuc_regs->txst[ep_num].curdeqlo);\r\n}\r\nstatus = tmp >> MV_U3D_XFERSTATUS_COMPLETE_SHIFT;\r\nlength = tmp & MV_U3D_XFERSTATUS_TRB_LENGTH_MASK;\r\nif (status == MV_U3D_COMPLETE_SUCCESS ||\r\n(status == MV_U3D_COMPLETE_SHORT_PACKET &&\r\ndirection == MV_U3D_EP_DIR_OUT)) {\r\nremaining_length += length;\r\nactual -= remaining_length;\r\n} else {\r\ndev_err(u3d->dev,\r\n"complete_tr error: ep=%d %s: error = 0x%x\n",\r\nindex >> 1, direction ? "SEND" : "RECV",\r\nstatus);\r\nretval = -EPROTO;\r\n}\r\nlist_del_init(&curr_trb->trb_list);\r\n}\r\nif (retval)\r\nreturn retval;\r\ncurr_req->req.actual = actual;\r\nreturn 0;\r\n}\r\nstatic\r\nvoid mv_u3d_done(struct mv_u3d_ep *ep, struct mv_u3d_req *req, int status)\r\n__releases(&ep->udc->lock\r\nstatic int mv_u3d_queue_trb(struct mv_u3d_ep *ep, struct mv_u3d_req *req)\r\n{\r\nu32 tmp, direction;\r\nstruct mv_u3d *u3d;\r\nstruct mv_u3d_ep_context *ep_context;\r\nint retval = 0;\r\nu3d = ep->u3d;\r\ndirection = mv_u3d_ep_dir(ep);\r\nif (ep->ep_num == 0)\r\nep_context = &(u3d->ep_context[1]);\r\nelse\r\nep_context = &(u3d->ep_context[ep->ep_num * 2 + direction]);\r\nif (!list_empty(&ep->queue)) {\r\ndev_err(u3d->dev, "add trb to non-empty queue!\n");\r\nretval = -ENOMEM;\r\nWARN_ON(1);\r\n} else {\r\nep_context->rsvd0 = cpu_to_le32(1);\r\nep_context->rsvd1 = 0;\r\nep_context->trb_addr_lo =\r\ncpu_to_le32(req->trb_head->trb_dma | DCS_ENABLE);\r\nep_context->trb_addr_hi = 0;\r\nwmb();\r\nif (ep->ep_num == 0)\r\ntmp = 0x1;\r\nelse\r\ntmp = ep->ep_num * 2\r\n+ ((direction == MV_U3D_EP_DIR_OUT) ? 0 : 1);\r\niowrite32(tmp, &u3d->op_regs->doorbell);\r\n}\r\nreturn retval;\r\n}\r\nstatic struct mv_u3d_trb *mv_u3d_build_trb_one(struct mv_u3d_req *req,\r\nunsigned *length, dma_addr_t *dma)\r\n{\r\nu32 temp;\r\nunsigned int direction;\r\nstruct mv_u3d_trb *trb;\r\nstruct mv_u3d_trb_hw *trb_hw;\r\nstruct mv_u3d *u3d;\r\n*length = req->req.length - req->req.actual;\r\nBUG_ON(*length > (unsigned)MV_U3D_EP_MAX_LENGTH_TRANSFER);\r\nu3d = req->ep->u3d;\r\ntrb = kzalloc(sizeof(*trb), GFP_ATOMIC);\r\nif (!trb)\r\nreturn NULL;\r\ntrb_hw = dma_pool_alloc(u3d->trb_pool, GFP_ATOMIC, dma);\r\nif (!trb_hw) {\r\nkfree(trb);\r\ndev_err(u3d->dev,\r\n"%s, dma_pool_alloc fail\n", __func__);\r\nreturn NULL;\r\n}\r\ntrb->trb_dma = *dma;\r\ntrb->trb_hw = trb_hw;\r\ntemp = (u32)(req->req.dma + req->req.actual);\r\ntrb_hw->buf_addr_lo = cpu_to_le32(temp);\r\ntrb_hw->buf_addr_hi = 0;\r\ntrb_hw->trb_len = cpu_to_le32(*length);\r\ntrb_hw->ctrl.own = 1;\r\nif (req->ep->ep_num == 0)\r\ntrb_hw->ctrl.type = TYPE_DATA;\r\nelse\r\ntrb_hw->ctrl.type = TYPE_NORMAL;\r\nreq->req.actual += *length;\r\ndirection = mv_u3d_ep_dir(req->ep);\r\nif (direction == MV_U3D_EP_DIR_IN)\r\ntrb_hw->ctrl.dir = 1;\r\nelse\r\ntrb_hw->ctrl.dir = 0;\r\nif (!req->req.no_interrupt)\r\ntrb_hw->ctrl.ioc = 1;\r\ntrb_hw->ctrl.chain = 0;\r\nwmb();\r\nreturn trb;\r\n}\r\nstatic int mv_u3d_build_trb_chain(struct mv_u3d_req *req, unsigned *length,\r\nstruct mv_u3d_trb *trb, int *is_last)\r\n{\r\nu32 temp;\r\nunsigned int direction;\r\nstruct mv_u3d *u3d;\r\n*length = min(req->req.length - req->req.actual,\r\n(unsigned)MV_U3D_EP_MAX_LENGTH_TRANSFER);\r\nu3d = req->ep->u3d;\r\ntrb->trb_dma = 0;\r\ntemp = (u32)(req->req.dma + req->req.actual);\r\ntrb->trb_hw->buf_addr_lo = cpu_to_le32(temp);\r\ntrb->trb_hw->buf_addr_hi = 0;\r\ntrb->trb_hw->trb_len = cpu_to_le32(*length);\r\ntrb->trb_hw->ctrl.own = 1;\r\nif (req->ep->ep_num == 0)\r\ntrb->trb_hw->ctrl.type = TYPE_DATA;\r\nelse\r\ntrb->trb_hw->ctrl.type = TYPE_NORMAL;\r\nreq->req.actual += *length;\r\ndirection = mv_u3d_ep_dir(req->ep);\r\nif (direction == MV_U3D_EP_DIR_IN)\r\ntrb->trb_hw->ctrl.dir = 1;\r\nelse\r\ntrb->trb_hw->ctrl.dir = 0;\r\nif (req->req.zero) {\r\nif (*length == 0 || (*length % req->ep->ep.maxpacket) != 0)\r\n*is_last = 1;\r\nelse\r\n*is_last = 0;\r\n} else if (req->req.length == req->req.actual)\r\n*is_last = 1;\r\nelse\r\n*is_last = 0;\r\nif (*is_last && !req->req.no_interrupt)\r\ntrb->trb_hw->ctrl.ioc = 1;\r\nif (*is_last)\r\ntrb->trb_hw->ctrl.chain = 0;\r\nelse {\r\ntrb->trb_hw->ctrl.chain = 1;\r\ndev_dbg(u3d->dev, "chain trb\n");\r\n}\r\nwmb();\r\nreturn 0;\r\n}\r\nstatic int mv_u3d_req_to_trb(struct mv_u3d_req *req)\r\n{\r\nunsigned count;\r\nint is_last;\r\nstruct mv_u3d_trb *trb;\r\nstruct mv_u3d_trb_hw *trb_hw;\r\nstruct mv_u3d *u3d;\r\ndma_addr_t dma;\r\nunsigned length;\r\nunsigned trb_num;\r\nu3d = req->ep->u3d;\r\nINIT_LIST_HEAD(&req->trb_list);\r\nlength = req->req.length - req->req.actual;\r\nif (length <= (unsigned)MV_U3D_EP_MAX_LENGTH_TRANSFER) {\r\ntrb = mv_u3d_build_trb_one(req, &count, &dma);\r\nlist_add_tail(&trb->trb_list, &req->trb_list);\r\nreq->trb_head = trb;\r\nreq->trb_count = 1;\r\nreq->chain = 0;\r\n} else {\r\ntrb_num = length / MV_U3D_EP_MAX_LENGTH_TRANSFER;\r\nif (length % MV_U3D_EP_MAX_LENGTH_TRANSFER)\r\ntrb_num++;\r\ntrb = kcalloc(trb_num, sizeof(*trb), GFP_ATOMIC);\r\nif (!trb)\r\nreturn -ENOMEM;\r\ntrb_hw = kcalloc(trb_num, sizeof(*trb_hw), GFP_ATOMIC);\r\nif (!trb_hw) {\r\nkfree(trb);\r\nreturn -ENOMEM;\r\n}\r\ndo {\r\ntrb->trb_hw = trb_hw;\r\nif (mv_u3d_build_trb_chain(req, &count,\r\ntrb, &is_last)) {\r\ndev_err(u3d->dev,\r\n"%s, mv_u3d_build_trb_chain fail\n",\r\n__func__);\r\nreturn -EIO;\r\n}\r\nlist_add_tail(&trb->trb_list, &req->trb_list);\r\nreq->trb_count++;\r\ntrb++;\r\ntrb_hw++;\r\n} while (!is_last);\r\nreq->trb_head = list_entry(req->trb_list.next,\r\nstruct mv_u3d_trb, trb_list);\r\nreq->trb_head->trb_dma = dma_map_single(u3d->gadget.dev.parent,\r\nreq->trb_head->trb_hw,\r\ntrb_num * sizeof(*trb_hw),\r\nDMA_BIDIRECTIONAL);\r\nreq->chain = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmv_u3d_start_queue(struct mv_u3d_ep *ep)\r\n{\r\nstruct mv_u3d *u3d = ep->u3d;\r\nstruct mv_u3d_req *req;\r\nint ret;\r\nif (!list_empty(&ep->req_list) && !ep->processing)\r\nreq = list_entry(ep->req_list.next, struct mv_u3d_req, list);\r\nelse\r\nreturn 0;\r\nep->processing = 1;\r\nret = usb_gadget_map_request(&u3d->gadget, &req->req,\r\nmv_u3d_ep_dir(ep));\r\nif (ret)\r\nreturn ret;\r\nreq->req.status = -EINPROGRESS;\r\nreq->req.actual = 0;\r\nreq->trb_count = 0;\r\nif (!mv_u3d_req_to_trb(req)) {\r\nret = mv_u3d_queue_trb(ep, req);\r\nif (ret) {\r\nep->processing = 0;\r\nreturn ret;\r\n}\r\n} else {\r\nep->processing = 0;\r\ndev_err(u3d->dev, "%s, mv_u3d_req_to_trb fail\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nif (req)\r\nlist_add_tail(&req->queue, &ep->queue);\r\nreturn 0;\r\n}\r\nstatic int mv_u3d_ep_enable(struct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct mv_u3d *u3d;\r\nstruct mv_u3d_ep *ep;\r\nstruct mv_u3d_ep_context *ep_context;\r\nu16 max = 0;\r\nunsigned maxburst = 0;\r\nu32 epxcr, direction;\r\nif (!_ep || !desc || desc->bDescriptorType != USB_DT_ENDPOINT)\r\nreturn -EINVAL;\r\nep = container_of(_ep, struct mv_u3d_ep, ep);\r\nu3d = ep->u3d;\r\nif (!u3d->driver || u3d->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\ndirection = mv_u3d_ep_dir(ep);\r\nmax = le16_to_cpu(desc->wMaxPacketSize);\r\nif (!_ep->maxburst)\r\n_ep->maxburst = 1;\r\nmaxburst = _ep->maxburst;\r\nep_context = (struct mv_u3d_ep_context *)ep->ep_context;\r\nswitch (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {\r\ncase USB_ENDPOINT_XFER_BULK:\r\nif (maxburst > 16) {\r\ndev_dbg(u3d->dev,\r\n"max burst should not be greater "\r\n"than 16 on bulk ep\n");\r\nmaxburst = 1;\r\n_ep->maxburst = maxburst;\r\n}\r\ndev_dbg(u3d->dev,\r\n"maxburst: %d on bulk %s\n", maxburst, ep->name);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\nmaxburst = 1;\r\n_ep->maxburst = maxburst;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (maxburst != 1) {\r\ndev_dbg(u3d->dev,\r\n"max burst should be 1 on int ep "\r\n"if transfer size is not 1024\n");\r\nmaxburst = 1;\r\n_ep->maxburst = maxburst;\r\n}\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nif (maxburst != 1) {\r\ndev_dbg(u3d->dev,\r\n"max burst should be 1 on isoc ep "\r\n"if transfer size is not 1024\n");\r\nmaxburst = 1;\r\n_ep->maxburst = maxburst;\r\n}\r\nbreak;\r\ndefault:\r\ngoto en_done;\r\n}\r\nep->ep.maxpacket = max;\r\nep->ep.desc = desc;\r\nep->enabled = 1;\r\nif (direction == MV_U3D_EP_DIR_OUT) {\r\nepxcr = ioread32(&u3d->vuc_regs->epcr[ep->ep_num].epxoutcr0);\r\nepxcr |= MV_U3D_EPXCR_EP_INIT;\r\niowrite32(epxcr, &u3d->vuc_regs->epcr[ep->ep_num].epxoutcr0);\r\nudelay(5);\r\nepxcr &= ~MV_U3D_EPXCR_EP_INIT;\r\niowrite32(epxcr, &u3d->vuc_regs->epcr[ep->ep_num].epxoutcr0);\r\nepxcr = ((max << MV_U3D_EPXCR_MAX_PACKET_SIZE_SHIFT)\r\n| ((maxburst - 1) << MV_U3D_EPXCR_MAX_BURST_SIZE_SHIFT)\r\n| (1 << MV_U3D_EPXCR_EP_ENABLE_SHIFT)\r\n| (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK));\r\niowrite32(epxcr, &u3d->vuc_regs->epcr[ep->ep_num].epxoutcr1);\r\n} else {\r\nepxcr = ioread32(&u3d->vuc_regs->epcr[ep->ep_num].epxincr0);\r\nepxcr |= MV_U3D_EPXCR_EP_INIT;\r\niowrite32(epxcr, &u3d->vuc_regs->epcr[ep->ep_num].epxincr0);\r\nudelay(5);\r\nepxcr &= ~MV_U3D_EPXCR_EP_INIT;\r\niowrite32(epxcr, &u3d->vuc_regs->epcr[ep->ep_num].epxincr0);\r\nepxcr = ((max << MV_U3D_EPXCR_MAX_PACKET_SIZE_SHIFT)\r\n| ((maxburst - 1) << MV_U3D_EPXCR_MAX_BURST_SIZE_SHIFT)\r\n| (1 << MV_U3D_EPXCR_EP_ENABLE_SHIFT)\r\n| (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK));\r\niowrite32(epxcr, &u3d->vuc_regs->epcr[ep->ep_num].epxincr1);\r\n}\r\nreturn 0;\r\nen_done:\r\nreturn -EINVAL;\r\n}\r\nstatic int mv_u3d_ep_disable(struct usb_ep *_ep)\r\n{\r\nstruct mv_u3d *u3d;\r\nstruct mv_u3d_ep *ep;\r\nstruct mv_u3d_ep_context *ep_context;\r\nu32 epxcr, direction;\r\nunsigned long flags;\r\nif (!_ep)\r\nreturn -EINVAL;\r\nep = container_of(_ep, struct mv_u3d_ep, ep);\r\nif (!ep->ep.desc)\r\nreturn -EINVAL;\r\nu3d = ep->u3d;\r\nep_context = ep->ep_context;\r\ndirection = mv_u3d_ep_dir(ep);\r\nspin_lock_irqsave(&u3d->lock, flags);\r\nmv_u3d_nuke(ep, -ESHUTDOWN);\r\nspin_unlock_irqrestore(&u3d->lock, flags);\r\nif (direction == MV_U3D_EP_DIR_OUT) {\r\nepxcr = ioread32(&u3d->vuc_regs->epcr[ep->ep_num].epxoutcr1);\r\nepxcr &= ~((1 << MV_U3D_EPXCR_EP_ENABLE_SHIFT)\r\n| USB_ENDPOINT_XFERTYPE_MASK);\r\niowrite32(epxcr, &u3d->vuc_regs->epcr[ep->ep_num].epxoutcr1);\r\n} else {\r\nepxcr = ioread32(&u3d->vuc_regs->epcr[ep->ep_num].epxincr1);\r\nepxcr &= ~((1 << MV_U3D_EPXCR_EP_ENABLE_SHIFT)\r\n| USB_ENDPOINT_XFERTYPE_MASK);\r\niowrite32(epxcr, &u3d->vuc_regs->epcr[ep->ep_num].epxincr1);\r\n}\r\nep->enabled = 0;\r\nep->ep.desc = NULL;\r\nreturn 0;\r\n}\r\nstatic struct usb_request *\r\nmv_u3d_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)\r\n{\r\nstruct mv_u3d_req *req = NULL;\r\nreq = kzalloc(sizeof *req, gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic void mv_u3d_free_request(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct mv_u3d_req *req = container_of(_req, struct mv_u3d_req, req);\r\nkfree(req);\r\n}\r\nstatic void mv_u3d_ep_fifo_flush(struct usb_ep *_ep)\r\n{\r\nstruct mv_u3d *u3d;\r\nu32 direction;\r\nstruct mv_u3d_ep *ep = container_of(_ep, struct mv_u3d_ep, ep);\r\nunsigned int loops;\r\nu32 tmp;\r\nif (!ep->enabled)\r\nreturn;\r\nu3d = ep->u3d;\r\ndirection = mv_u3d_ep_dir(ep);\r\nif (!ep->ep_num) {\r\nif (direction == MV_U3D_EP_DIR_OUT) {\r\ntmp = ioread32(&u3d->vuc_regs->epcr[0].epxoutcr0);\r\ntmp |= MV_U3D_EPXCR_EP_FLUSH;\r\niowrite32(tmp, &u3d->vuc_regs->epcr[0].epxoutcr0);\r\nudelay(10);\r\ntmp &= ~MV_U3D_EPXCR_EP_FLUSH;\r\niowrite32(tmp, &u3d->vuc_regs->epcr[0].epxoutcr0);\r\n} else {\r\ntmp = ioread32(&u3d->vuc_regs->epcr[0].epxincr0);\r\ntmp |= MV_U3D_EPXCR_EP_FLUSH;\r\niowrite32(tmp, &u3d->vuc_regs->epcr[0].epxincr0);\r\nudelay(10);\r\ntmp &= ~MV_U3D_EPXCR_EP_FLUSH;\r\niowrite32(tmp, &u3d->vuc_regs->epcr[0].epxincr0);\r\n}\r\nreturn;\r\n}\r\nif (direction == MV_U3D_EP_DIR_OUT) {\r\ntmp = ioread32(&u3d->vuc_regs->epcr[ep->ep_num].epxoutcr0);\r\ntmp |= MV_U3D_EPXCR_EP_FLUSH;\r\niowrite32(tmp, &u3d->vuc_regs->epcr[ep->ep_num].epxoutcr0);\r\nloops = LOOPS(MV_U3D_FLUSH_TIMEOUT);\r\nwhile (ioread32(&u3d->vuc_regs->epcr[ep->ep_num].epxoutcr0) &\r\nMV_U3D_EPXCR_EP_FLUSH) {\r\nif (loops == 0) {\r\ndev_dbg(u3d->dev,\r\n"EP FLUSH TIMEOUT for ep%d%s\n", ep->ep_num,\r\ndirection ? "in" : "out");\r\nreturn;\r\n}\r\nloops--;\r\nudelay(LOOPS_USEC);\r\n}\r\n} else {\r\ntmp = ioread32(&u3d->vuc_regs->epcr[ep->ep_num].epxincr0);\r\ntmp |= MV_U3D_EPXCR_EP_FLUSH;\r\niowrite32(tmp, &u3d->vuc_regs->epcr[ep->ep_num].epxincr0);\r\nloops = LOOPS(MV_U3D_FLUSH_TIMEOUT);\r\nwhile (ioread32(&u3d->vuc_regs->epcr[ep->ep_num].epxincr0) &\r\nMV_U3D_EPXCR_EP_FLUSH) {\r\nif (loops == 0) {\r\ndev_dbg(u3d->dev,\r\n"EP FLUSH TIMEOUT for ep%d%s\n", ep->ep_num,\r\ndirection ? "in" : "out");\r\nreturn;\r\n}\r\nloops--;\r\nudelay(LOOPS_USEC);\r\n}\r\n}\r\n}\r\nstatic int\r\nmv_u3d_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)\r\n{\r\nstruct mv_u3d_ep *ep;\r\nstruct mv_u3d_req *req;\r\nstruct mv_u3d *u3d;\r\nunsigned long flags;\r\nint is_first_req = 0;\r\nif (unlikely(!_ep || !_req))\r\nreturn -EINVAL;\r\nep = container_of(_ep, struct mv_u3d_ep, ep);\r\nu3d = ep->u3d;\r\nreq = container_of(_req, struct mv_u3d_req, req);\r\nif (!ep->ep_num\r\n&& u3d->ep0_state == MV_U3D_STATUS_STAGE\r\n&& !_req->length) {\r\ndev_dbg(u3d->dev, "ep0 status stage\n");\r\nu3d->ep0_state = MV_U3D_WAIT_FOR_SETUP;\r\nreturn 0;\r\n}\r\ndev_dbg(u3d->dev, "%s: %s, req: 0x%p\n",\r\n__func__, _ep->name, req);\r\nif (!req->req.complete || !req->req.buf\r\n|| !list_empty(&req->queue)) {\r\ndev_err(u3d->dev,\r\n"%s, bad params, _req: 0x%p,"\r\n"req->req.complete: 0x%p, req->req.buf: 0x%p,"\r\n"list_empty: 0x%x\n",\r\n__func__, _req,\r\nreq->req.complete, req->req.buf,\r\nlist_empty(&req->queue));\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(!ep->ep.desc)) {\r\ndev_err(u3d->dev, "%s, bad ep\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (ep->ep.desc->bmAttributes == USB_ENDPOINT_XFER_ISOC) {\r\nif (req->req.length > ep->ep.maxpacket)\r\nreturn -EMSGSIZE;\r\n}\r\nif (!u3d->driver || u3d->gadget.speed == USB_SPEED_UNKNOWN) {\r\ndev_err(u3d->dev,\r\n"bad params of driver/speed\n");\r\nreturn -ESHUTDOWN;\r\n}\r\nreq->ep = ep;\r\nspin_lock_irqsave(&ep->req_lock, flags);\r\nis_first_req = list_empty(&ep->req_list);\r\nlist_add_tail(&req->list, &ep->req_list);\r\nspin_unlock_irqrestore(&ep->req_lock, flags);\r\nif (!is_first_req) {\r\ndev_dbg(u3d->dev, "list is not empty\n");\r\nreturn 0;\r\n}\r\ndev_dbg(u3d->dev, "call mv_u3d_start_queue from usb_ep_queue\n");\r\nspin_lock_irqsave(&u3d->lock, flags);\r\nmv_u3d_start_queue(ep);\r\nspin_unlock_irqrestore(&u3d->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mv_u3d_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct mv_u3d_ep *ep;\r\nstruct mv_u3d_req *req;\r\nstruct mv_u3d *u3d;\r\nstruct mv_u3d_ep_context *ep_context;\r\nstruct mv_u3d_req *next_req;\r\nunsigned long flags;\r\nint ret = 0;\r\nif (!_ep || !_req)\r\nreturn -EINVAL;\r\nep = container_of(_ep, struct mv_u3d_ep, ep);\r\nu3d = ep->u3d;\r\nspin_lock_irqsave(&ep->u3d->lock, flags);\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nif (&req->req == _req)\r\nbreak;\r\n}\r\nif (&req->req != _req) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (ep->queue.next == &req->queue) {\r\n_req->status = -ECONNRESET;\r\nmv_u3d_ep_fifo_flush(_ep);\r\nif (req->queue.next != &ep->queue) {\r\ndev_dbg(u3d->dev,\r\n"it is the last request in this ep queue\n");\r\nep_context = ep->ep_context;\r\nnext_req = list_entry(req->queue.next,\r\nstruct mv_u3d_req, queue);\r\niowrite32((unsigned long) next_req->trb_head,\r\n&ep_context->trb_addr_lo);\r\n} else {\r\nstruct mv_u3d_ep_context *ep_context;\r\nep_context = ep->ep_context;\r\nep_context->trb_addr_lo = 0;\r\nep_context->trb_addr_hi = 0;\r\n}\r\n} else\r\nWARN_ON(1);\r\nmv_u3d_done(ep, req, -ECONNRESET);\r\nif (!list_empty(&ep->req_list)) {\r\nstruct mv_u3d_req *curr_req;\r\ncurr_req = list_entry(ep->req_list.next,\r\nstruct mv_u3d_req, list);\r\nif (curr_req == req) {\r\nlist_del_init(&req->list);\r\nep->processing = 0;\r\n}\r\n}\r\nout:\r\nspin_unlock_irqrestore(&ep->u3d->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void\r\nmv_u3d_ep_set_stall(struct mv_u3d *u3d, u8 ep_num, u8 direction, int stall)\r\n{\r\nu32 tmp;\r\nstruct mv_u3d_ep *ep = u3d->eps;\r\ndev_dbg(u3d->dev, "%s\n", __func__);\r\nif (direction == MV_U3D_EP_DIR_OUT) {\r\ntmp = ioread32(&u3d->vuc_regs->epcr[ep->ep_num].epxoutcr0);\r\nif (stall)\r\ntmp |= MV_U3D_EPXCR_EP_HALT;\r\nelse\r\ntmp &= ~MV_U3D_EPXCR_EP_HALT;\r\niowrite32(tmp, &u3d->vuc_regs->epcr[ep->ep_num].epxoutcr0);\r\n} else {\r\ntmp = ioread32(&u3d->vuc_regs->epcr[ep->ep_num].epxincr0);\r\nif (stall)\r\ntmp |= MV_U3D_EPXCR_EP_HALT;\r\nelse\r\ntmp &= ~MV_U3D_EPXCR_EP_HALT;\r\niowrite32(tmp, &u3d->vuc_regs->epcr[ep->ep_num].epxincr0);\r\n}\r\n}\r\nstatic int mv_u3d_ep_set_halt_wedge(struct usb_ep *_ep, int halt, int wedge)\r\n{\r\nstruct mv_u3d_ep *ep;\r\nunsigned long flags = 0;\r\nint status = 0;\r\nstruct mv_u3d *u3d;\r\nep = container_of(_ep, struct mv_u3d_ep, ep);\r\nu3d = ep->u3d;\r\nif (!ep->ep.desc) {\r\nstatus = -EINVAL;\r\ngoto out;\r\n}\r\nif (ep->ep.desc->bmAttributes == USB_ENDPOINT_XFER_ISOC) {\r\nstatus = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nif (halt && (mv_u3d_ep_dir(ep) == MV_U3D_EP_DIR_IN)\r\n&& !list_empty(&ep->queue)) {\r\nstatus = -EAGAIN;\r\ngoto out;\r\n}\r\nspin_lock_irqsave(&ep->u3d->lock, flags);\r\nmv_u3d_ep_set_stall(u3d, ep->ep_num, mv_u3d_ep_dir(ep), halt);\r\nif (halt && wedge)\r\nep->wedge = 1;\r\nelse if (!halt)\r\nep->wedge = 0;\r\nspin_unlock_irqrestore(&ep->u3d->lock, flags);\r\nif (ep->ep_num == 0)\r\nu3d->ep0_dir = MV_U3D_EP_DIR_OUT;\r\nout:\r\nreturn status;\r\n}\r\nstatic int mv_u3d_ep_set_halt(struct usb_ep *_ep, int halt)\r\n{\r\nreturn mv_u3d_ep_set_halt_wedge(_ep, halt, 0);\r\n}\r\nstatic int mv_u3d_ep_set_wedge(struct usb_ep *_ep)\r\n{\r\nreturn mv_u3d_ep_set_halt_wedge(_ep, 1, 1);\r\n}\r\nstatic void mv_u3d_controller_stop(struct mv_u3d *u3d)\r\n{\r\nu32 tmp;\r\nif (!u3d->clock_gating && u3d->vbus_valid_detect)\r\niowrite32(MV_U3D_INTR_ENABLE_VBUS_VALID,\r\n&u3d->vuc_regs->intrenable);\r\nelse\r\niowrite32(0, &u3d->vuc_regs->intrenable);\r\niowrite32(~0x0, &u3d->vuc_regs->endcomplete);\r\niowrite32(~0x0, &u3d->vuc_regs->trbunderrun);\r\niowrite32(~0x0, &u3d->vuc_regs->trbcomplete);\r\niowrite32(~0x0, &u3d->vuc_regs->linkchange);\r\niowrite32(0x1, &u3d->vuc_regs->setuplock);\r\ntmp = ioread32(&u3d->op_regs->usbcmd);\r\ntmp &= ~MV_U3D_CMD_RUN_STOP;\r\niowrite32(tmp, &u3d->op_regs->usbcmd);\r\ndev_dbg(u3d->dev, "after u3d_stop, USBCMD 0x%x\n",\r\nioread32(&u3d->op_regs->usbcmd));\r\n}\r\nstatic void mv_u3d_controller_start(struct mv_u3d *u3d)\r\n{\r\nu32 usbintr;\r\nu32 temp;\r\ntemp = ioread32(&u3d->vuc_regs->ltssm);\r\ntemp |= MV_U3D_LTSSM_PHY_INIT_DONE;\r\niowrite32(temp, &u3d->vuc_regs->ltssm);\r\nusbintr = MV_U3D_INTR_ENABLE_LINK_CHG | MV_U3D_INTR_ENABLE_TXDESC_ERR |\r\nMV_U3D_INTR_ENABLE_RXDESC_ERR | MV_U3D_INTR_ENABLE_TX_COMPLETE |\r\nMV_U3D_INTR_ENABLE_RX_COMPLETE | MV_U3D_INTR_ENABLE_SETUP |\r\n(u3d->vbus_valid_detect ? MV_U3D_INTR_ENABLE_VBUS_VALID : 0);\r\niowrite32(usbintr, &u3d->vuc_regs->intrenable);\r\niowrite32(0x1, &u3d->vuc_regs->ctrlepenable);\r\niowrite32(MV_U3D_CMD_RUN_STOP, &u3d->op_regs->usbcmd);\r\ndev_dbg(u3d->dev, "after u3d_start, USBCMD 0x%x\n",\r\nioread32(&u3d->op_regs->usbcmd));\r\n}\r\nstatic int mv_u3d_controller_reset(struct mv_u3d *u3d)\r\n{\r\nunsigned int loops;\r\nu32 tmp;\r\ntmp = ioread32(&u3d->op_regs->usbcmd);\r\ntmp &= ~MV_U3D_CMD_RUN_STOP;\r\niowrite32(tmp, &u3d->op_regs->usbcmd);\r\niowrite32(MV_U3D_CMD_CTRL_RESET, &u3d->op_regs->usbcmd);\r\nloops = LOOPS(MV_U3D_RESET_TIMEOUT);\r\nwhile (ioread32(&u3d->op_regs->usbcmd) & MV_U3D_CMD_CTRL_RESET) {\r\nif (loops == 0) {\r\ndev_err(u3d->dev,\r\n"Wait for RESET completed TIMEOUT\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nloops--;\r\nudelay(LOOPS_USEC);\r\n}\r\niowrite32(u3d->ep_context_dma, &u3d->op_regs->dcbaapl);\r\niowrite32(0, &u3d->op_regs->dcbaaph);\r\nreturn 0;\r\n}\r\nstatic int mv_u3d_enable(struct mv_u3d *u3d)\r\n{\r\nstruct mv_usb_platform_data *pdata = dev_get_platdata(u3d->dev);\r\nint retval;\r\nif (u3d->active)\r\nreturn 0;\r\nif (!u3d->clock_gating) {\r\nu3d->active = 1;\r\nreturn 0;\r\n}\r\ndev_dbg(u3d->dev, "enable u3d\n");\r\nclk_enable(u3d->clk);\r\nif (pdata->phy_init) {\r\nretval = pdata->phy_init(u3d->phy_regs);\r\nif (retval) {\r\ndev_err(u3d->dev,\r\n"init phy error %d\n", retval);\r\nclk_disable(u3d->clk);\r\nreturn retval;\r\n}\r\n}\r\nu3d->active = 1;\r\nreturn 0;\r\n}\r\nstatic void mv_u3d_disable(struct mv_u3d *u3d)\r\n{\r\nstruct mv_usb_platform_data *pdata = dev_get_platdata(u3d->dev);\r\nif (u3d->clock_gating && u3d->active) {\r\ndev_dbg(u3d->dev, "disable u3d\n");\r\nif (pdata->phy_deinit)\r\npdata->phy_deinit(u3d->phy_regs);\r\nclk_disable(u3d->clk);\r\nu3d->active = 0;\r\n}\r\n}\r\nstatic int mv_u3d_vbus_session(struct usb_gadget *gadget, int is_active)\r\n{\r\nstruct mv_u3d *u3d;\r\nunsigned long flags;\r\nint retval = 0;\r\nu3d = container_of(gadget, struct mv_u3d, gadget);\r\nspin_lock_irqsave(&u3d->lock, flags);\r\nu3d->vbus_active = (is_active != 0);\r\ndev_dbg(u3d->dev, "%s: softconnect %d, vbus_active %d\n",\r\n__func__, u3d->softconnect, u3d->vbus_active);\r\nif (u3d->driver && u3d->softconnect && u3d->vbus_active) {\r\nretval = mv_u3d_enable(u3d);\r\nif (retval == 0) {\r\nmv_u3d_controller_reset(u3d);\r\nmv_u3d_ep0_reset(u3d);\r\nmv_u3d_controller_start(u3d);\r\n}\r\n} else if (u3d->driver && u3d->softconnect) {\r\nif (!u3d->active)\r\ngoto out;\r\nmv_u3d_stop_activity(u3d, u3d->driver);\r\nmv_u3d_controller_stop(u3d);\r\nmv_u3d_disable(u3d);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&u3d->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int mv_u3d_vbus_draw(struct usb_gadget *gadget, unsigned mA)\r\n{\r\nstruct mv_u3d *u3d = container_of(gadget, struct mv_u3d, gadget);\r\nu3d->power = mA;\r\nreturn 0;\r\n}\r\nstatic int mv_u3d_pullup(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct mv_u3d *u3d = container_of(gadget, struct mv_u3d, gadget);\r\nunsigned long flags;\r\nint retval = 0;\r\nspin_lock_irqsave(&u3d->lock, flags);\r\ndev_dbg(u3d->dev, "%s: softconnect %d, vbus_active %d\n",\r\n__func__, u3d->softconnect, u3d->vbus_active);\r\nu3d->softconnect = (is_on != 0);\r\nif (u3d->driver && u3d->softconnect && u3d->vbus_active) {\r\nretval = mv_u3d_enable(u3d);\r\nif (retval == 0) {\r\nmv_u3d_controller_reset(u3d);\r\nmv_u3d_ep0_reset(u3d);\r\nmv_u3d_controller_start(u3d);\r\n}\r\n} else if (u3d->driver && u3d->vbus_active) {\r\nmv_u3d_stop_activity(u3d, u3d->driver);\r\nmv_u3d_controller_stop(u3d);\r\nmv_u3d_disable(u3d);\r\n}\r\nspin_unlock_irqrestore(&u3d->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int mv_u3d_start(struct usb_gadget *g,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct mv_u3d *u3d = container_of(g, struct mv_u3d, gadget);\r\nstruct mv_usb_platform_data *pdata = dev_get_platdata(u3d->dev);\r\nunsigned long flags;\r\nif (u3d->driver)\r\nreturn -EBUSY;\r\nspin_lock_irqsave(&u3d->lock, flags);\r\nif (!u3d->clock_gating) {\r\nclk_enable(u3d->clk);\r\nif (pdata->phy_init)\r\npdata->phy_init(u3d->phy_regs);\r\n}\r\ndriver->driver.bus = NULL;\r\nu3d->driver = driver;\r\nu3d->ep0_dir = USB_DIR_OUT;\r\nspin_unlock_irqrestore(&u3d->lock, flags);\r\nu3d->vbus_valid_detect = 1;\r\nreturn 0;\r\n}\r\nstatic int mv_u3d_stop(struct usb_gadget *g,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct mv_u3d *u3d = container_of(g, struct mv_u3d, gadget);\r\nstruct mv_usb_platform_data *pdata = dev_get_platdata(u3d->dev);\r\nunsigned long flags;\r\nu3d->vbus_valid_detect = 0;\r\nspin_lock_irqsave(&u3d->lock, flags);\r\nclk_enable(u3d->clk);\r\nif (pdata->phy_init)\r\npdata->phy_init(u3d->phy_regs);\r\nmv_u3d_controller_stop(u3d);\r\nu3d->gadget.speed = USB_SPEED_UNKNOWN;\r\nmv_u3d_stop_activity(u3d, driver);\r\nmv_u3d_disable(u3d);\r\nif (pdata->phy_deinit)\r\npdata->phy_deinit(u3d->phy_regs);\r\nclk_disable(u3d->clk);\r\nspin_unlock_irqrestore(&u3d->lock, flags);\r\nu3d->driver = NULL;\r\nreturn 0;\r\n}\r\nstatic int mv_u3d_eps_init(struct mv_u3d *u3d)\r\n{\r\nstruct mv_u3d_ep *ep;\r\nchar name[14];\r\nint i;\r\nep = &u3d->eps[1];\r\nep->u3d = u3d;\r\nstrncpy(ep->name, "ep0", sizeof(ep->name));\r\nep->ep.name = ep->name;\r\nep->ep.ops = &mv_u3d_ep_ops;\r\nep->wedge = 0;\r\nusb_ep_set_maxpacket_limit(&ep->ep, MV_U3D_EP0_MAX_PKT_SIZE);\r\nep->ep_num = 0;\r\nep->ep.desc = &mv_u3d_ep0_desc;\r\nINIT_LIST_HEAD(&ep->queue);\r\nINIT_LIST_HEAD(&ep->req_list);\r\nep->ep_type = USB_ENDPOINT_XFER_CONTROL;\r\nep->ep_context = &u3d->ep_context[1];\r\nfor (i = 2; i < u3d->max_eps * 2; i++) {\r\nep = &u3d->eps[i];\r\nif (i & 1) {\r\nsnprintf(name, sizeof(name), "ep%din", i >> 1);\r\nep->direction = MV_U3D_EP_DIR_IN;\r\n} else {\r\nsnprintf(name, sizeof(name), "ep%dout", i >> 1);\r\nep->direction = MV_U3D_EP_DIR_OUT;\r\n}\r\nep->u3d = u3d;\r\nstrncpy(ep->name, name, sizeof(ep->name));\r\nep->ep.name = ep->name;\r\nep->ep.ops = &mv_u3d_ep_ops;\r\nusb_ep_set_maxpacket_limit(&ep->ep, (unsigned short) ~0);\r\nep->ep_num = i / 2;\r\nINIT_LIST_HEAD(&ep->queue);\r\nlist_add_tail(&ep->ep.ep_list, &u3d->gadget.ep_list);\r\nINIT_LIST_HEAD(&ep->req_list);\r\nspin_lock_init(&ep->req_lock);\r\nep->ep_context = &u3d->ep_context[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic void mv_u3d_nuke(struct mv_u3d_ep *ep, int status)\r\n{\r\nmv_u3d_ep_fifo_flush(&ep->ep);\r\nwhile (!list_empty(&ep->queue)) {\r\nstruct mv_u3d_req *req = NULL;\r\nreq = list_entry(ep->queue.next, struct mv_u3d_req, queue);\r\nmv_u3d_done(ep, req, status);\r\n}\r\n}\r\nstatic\r\nvoid mv_u3d_stop_activity(struct mv_u3d *u3d, struct usb_gadget_driver *driver)\r\n{\r\nstruct mv_u3d_ep *ep;\r\nmv_u3d_nuke(&u3d->eps[1], -ESHUTDOWN);\r\nlist_for_each_entry(ep, &u3d->gadget.ep_list, ep.ep_list) {\r\nmv_u3d_nuke(ep, -ESHUTDOWN);\r\n}\r\nif (driver) {\r\nspin_unlock(&u3d->lock);\r\ndriver->disconnect(&u3d->gadget);\r\nspin_lock(&u3d->lock);\r\n}\r\n}\r\nstatic void mv_u3d_irq_process_error(struct mv_u3d *u3d)\r\n{\r\nu3d->errors++;\r\ndev_err(u3d->dev, "%s\n", __func__);\r\n}\r\nstatic void mv_u3d_irq_process_link_change(struct mv_u3d *u3d)\r\n{\r\nu32 linkchange;\r\nlinkchange = ioread32(&u3d->vuc_regs->linkchange);\r\niowrite32(linkchange, &u3d->vuc_regs->linkchange);\r\ndev_dbg(u3d->dev, "linkchange: 0x%x\n", linkchange);\r\nif (linkchange & MV_U3D_LINK_CHANGE_LINK_UP) {\r\ndev_dbg(u3d->dev, "link up: ltssm state: 0x%x\n",\r\nioread32(&u3d->vuc_regs->ltssmstate));\r\nu3d->usb_state = USB_STATE_DEFAULT;\r\nu3d->ep0_dir = MV_U3D_EP_DIR_OUT;\r\nu3d->ep0_state = MV_U3D_WAIT_FOR_SETUP;\r\nu3d->gadget.speed = USB_SPEED_SUPER;\r\n}\r\nif (linkchange & MV_U3D_LINK_CHANGE_SUSPEND) {\r\ndev_dbg(u3d->dev, "link suspend\n");\r\nu3d->resume_state = u3d->usb_state;\r\nu3d->usb_state = USB_STATE_SUSPENDED;\r\n}\r\nif (linkchange & MV_U3D_LINK_CHANGE_RESUME) {\r\ndev_dbg(u3d->dev, "link resume\n");\r\nu3d->usb_state = u3d->resume_state;\r\nu3d->resume_state = 0;\r\n}\r\nif (linkchange & MV_U3D_LINK_CHANGE_WRESET) {\r\ndev_dbg(u3d->dev, "warm reset\n");\r\nu3d->usb_state = USB_STATE_POWERED;\r\n}\r\nif (linkchange & MV_U3D_LINK_CHANGE_HRESET) {\r\ndev_dbg(u3d->dev, "hot reset\n");\r\nu3d->usb_state = USB_STATE_DEFAULT;\r\n}\r\nif (linkchange & MV_U3D_LINK_CHANGE_INACT)\r\ndev_dbg(u3d->dev, "inactive\n");\r\nif (linkchange & MV_U3D_LINK_CHANGE_DISABLE_AFTER_U0)\r\ndev_dbg(u3d->dev, "ss.disabled\n");\r\nif (linkchange & MV_U3D_LINK_CHANGE_VBUS_INVALID) {\r\ndev_dbg(u3d->dev, "vbus invalid\n");\r\nu3d->usb_state = USB_STATE_ATTACHED;\r\nu3d->vbus_valid_detect = 1;\r\nif (!u3d->vbus) {\r\nspin_unlock(&u3d->lock);\r\nmv_u3d_vbus_session(&u3d->gadget, 0);\r\nspin_lock(&u3d->lock);\r\n}\r\n}\r\n}\r\nstatic void mv_u3d_ch9setaddress(struct mv_u3d *u3d,\r\nstruct usb_ctrlrequest *setup)\r\n{\r\nu32 tmp;\r\nif (u3d->usb_state != USB_STATE_DEFAULT) {\r\ndev_err(u3d->dev,\r\n"%s, cannot setaddr in this state (%d)\n",\r\n__func__, u3d->usb_state);\r\ngoto err;\r\n}\r\nu3d->dev_addr = (u8)setup->wValue;\r\ndev_dbg(u3d->dev, "%s: 0x%x\n", __func__, u3d->dev_addr);\r\nif (u3d->dev_addr > 127) {\r\ndev_err(u3d->dev,\r\n"%s, u3d address is wrong (out of range)\n", __func__);\r\nu3d->dev_addr = 0;\r\ngoto err;\r\n}\r\nu3d->usb_state = USB_STATE_ADDRESS;\r\ntmp = ioread32(&u3d->vuc_regs->devaddrtiebrkr);\r\ntmp &= ~0x7F;\r\ntmp |= (u32)u3d->dev_addr;\r\niowrite32(tmp, &u3d->vuc_regs->devaddrtiebrkr);\r\nreturn;\r\nerr:\r\nmv_u3d_ep0_stall(u3d);\r\n}\r\nstatic int mv_u3d_is_set_configuration(struct usb_ctrlrequest *setup)\r\n{\r\nif ((setup->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD)\r\nif (setup->bRequest == USB_REQ_SET_CONFIGURATION)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void mv_u3d_handle_setup_packet(struct mv_u3d *u3d, u8 ep_num,\r\nstruct usb_ctrlrequest *setup)\r\n__releases(&u3c->lock\r\nstatic void mv_u3d_get_setup_data(struct mv_u3d *u3d, u8 ep_num, u8 *buffer_ptr)\r\n{\r\nstruct mv_u3d_ep_context *epcontext;\r\nepcontext = &u3d->ep_context[ep_num * 2 + MV_U3D_EP_DIR_IN];\r\nmemcpy(buffer_ptr, (u8 *) &epcontext->setup_buffer, 8);\r\n}\r\nstatic void mv_u3d_irq_process_setup(struct mv_u3d *u3d)\r\n{\r\nu32 tmp, i;\r\ntmp = ioread32(&u3d->vuc_regs->setuplock);\r\nif (tmp) {\r\nfor (i = 0; i < u3d->max_eps; i++) {\r\nif (tmp & (1 << i)) {\r\nmv_u3d_get_setup_data(u3d, i,\r\n(u8 *)(&u3d->local_setup_buff));\r\nmv_u3d_handle_setup_packet(u3d, i,\r\n&u3d->local_setup_buff);\r\n}\r\n}\r\n}\r\niowrite32(tmp, &u3d->vuc_regs->setuplock);\r\n}\r\nstatic void mv_u3d_irq_process_tr_complete(struct mv_u3d *u3d)\r\n{\r\nu32 tmp, bit_pos;\r\nint i, ep_num = 0, direction = 0;\r\nstruct mv_u3d_ep *curr_ep;\r\nstruct mv_u3d_req *curr_req, *temp_req;\r\nint status;\r\ntmp = ioread32(&u3d->vuc_regs->endcomplete);\r\ndev_dbg(u3d->dev, "tr_complete: ep: 0x%x\n", tmp);\r\nif (!tmp)\r\nreturn;\r\niowrite32(tmp, &u3d->vuc_regs->endcomplete);\r\nfor (i = 0; i < u3d->max_eps * 2; i++) {\r\nep_num = i >> 1;\r\ndirection = i % 2;\r\nbit_pos = 1 << (ep_num + 16 * direction);\r\nif (!(bit_pos & tmp))\r\ncontinue;\r\nif (i == 0)\r\ncurr_ep = &u3d->eps[1];\r\nelse\r\ncurr_ep = &u3d->eps[i];\r\ndev_dbg(u3d->dev, "tr comp: check req_list\n");\r\nspin_lock(&curr_ep->req_lock);\r\nif (!list_empty(&curr_ep->req_list)) {\r\nstruct mv_u3d_req *req;\r\nreq = list_entry(curr_ep->req_list.next,\r\nstruct mv_u3d_req, list);\r\nlist_del_init(&req->list);\r\ncurr_ep->processing = 0;\r\n}\r\nspin_unlock(&curr_ep->req_lock);\r\nlist_for_each_entry_safe(curr_req, temp_req,\r\n&curr_ep->queue, queue) {\r\nstatus = mv_u3d_process_ep_req(u3d, i, curr_req);\r\nif (status)\r\nbreak;\r\ncurr_req->req.status = status;\r\nif (ep_num == 0) {\r\nmv_u3d_done(curr_ep, curr_req, 0);\r\nbreak;\r\n} else {\r\nmv_u3d_done(curr_ep, curr_req, status);\r\n}\r\n}\r\ndev_dbg(u3d->dev, "call mv_u3d_start_queue from ep complete\n");\r\nmv_u3d_start_queue(curr_ep);\r\n}\r\n}\r\nstatic irqreturn_t mv_u3d_irq(int irq, void *dev)\r\n{\r\nstruct mv_u3d *u3d = (struct mv_u3d *)dev;\r\nu32 status, intr;\r\nu32 bridgesetting;\r\nu32 trbunderrun;\r\nspin_lock(&u3d->lock);\r\nstatus = ioread32(&u3d->vuc_regs->intrcause);\r\nintr = ioread32(&u3d->vuc_regs->intrenable);\r\nstatus &= intr;\r\nif (status == 0) {\r\nspin_unlock(&u3d->lock);\r\ndev_err(u3d->dev, "irq error!\n");\r\nreturn IRQ_NONE;\r\n}\r\nif (status & MV_U3D_USBINT_VBUS_VALID) {\r\nbridgesetting = ioread32(&u3d->vuc_regs->bridgesetting);\r\nif (bridgesetting & MV_U3D_BRIDGE_SETTING_VBUS_VALID) {\r\nbridgesetting = MV_U3D_BRIDGE_SETTING_VBUS_VALID;\r\niowrite32(bridgesetting, &u3d->vuc_regs->bridgesetting);\r\ndev_dbg(u3d->dev, "vbus valid\n");\r\nu3d->usb_state = USB_STATE_POWERED;\r\nu3d->vbus_valid_detect = 0;\r\nif (!u3d->vbus) {\r\nspin_unlock(&u3d->lock);\r\nmv_u3d_vbus_session(&u3d->gadget, 1);\r\nspin_lock(&u3d->lock);\r\n}\r\n} else\r\ndev_err(u3d->dev, "vbus bit is not set\n");\r\n}\r\nif (status & MV_U3D_USBINT_UNDER_RUN) {\r\ntrbunderrun = ioread32(&u3d->vuc_regs->trbunderrun);\r\ndev_err(u3d->dev, "under run, ep%d\n", trbunderrun);\r\niowrite32(trbunderrun, &u3d->vuc_regs->trbunderrun);\r\nmv_u3d_irq_process_error(u3d);\r\n}\r\nif (status & (MV_U3D_USBINT_RXDESC_ERR | MV_U3D_USBINT_TXDESC_ERR)) {\r\niowrite32(status & (MV_U3D_USBINT_RXDESC_ERR\r\n| MV_U3D_USBINT_TXDESC_ERR),\r\n&u3d->vuc_regs->intrcause);\r\ndev_err(u3d->dev, "desc err 0x%x\n", status);\r\nmv_u3d_irq_process_error(u3d);\r\n}\r\nif (status & MV_U3D_USBINT_LINK_CHG)\r\nmv_u3d_irq_process_link_change(u3d);\r\nif (status & MV_U3D_USBINT_TX_COMPLETE)\r\nmv_u3d_irq_process_tr_complete(u3d);\r\nif (status & MV_U3D_USBINT_RX_COMPLETE)\r\nmv_u3d_irq_process_tr_complete(u3d);\r\nif (status & MV_U3D_USBINT_SETUP)\r\nmv_u3d_irq_process_setup(u3d);\r\nspin_unlock(&u3d->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mv_u3d_remove(struct platform_device *dev)\r\n{\r\nstruct mv_u3d *u3d = platform_get_drvdata(dev);\r\nBUG_ON(u3d == NULL);\r\nusb_del_gadget_udc(&u3d->gadget);\r\nif (u3d->trb_pool)\r\ndma_pool_destroy(u3d->trb_pool);\r\nif (u3d->ep_context)\r\ndma_free_coherent(&dev->dev, u3d->ep_context_size,\r\nu3d->ep_context, u3d->ep_context_dma);\r\nkfree(u3d->eps);\r\nif (u3d->irq)\r\nfree_irq(u3d->irq, u3d);\r\nif (u3d->cap_regs)\r\niounmap(u3d->cap_regs);\r\nu3d->cap_regs = NULL;\r\nkfree(u3d->status_req);\r\nclk_put(u3d->clk);\r\nkfree(u3d);\r\nreturn 0;\r\n}\r\nstatic int mv_u3d_probe(struct platform_device *dev)\r\n{\r\nstruct mv_u3d *u3d = NULL;\r\nstruct mv_usb_platform_data *pdata = dev_get_platdata(&dev->dev);\r\nint retval = 0;\r\nstruct resource *r;\r\nsize_t size;\r\nif (!dev_get_platdata(&dev->dev)) {\r\ndev_err(&dev->dev, "missing platform_data\n");\r\nretval = -ENODEV;\r\ngoto err_pdata;\r\n}\r\nu3d = kzalloc(sizeof(*u3d), GFP_KERNEL);\r\nif (!u3d) {\r\nretval = -ENOMEM;\r\ngoto err_alloc_private;\r\n}\r\nspin_lock_init(&u3d->lock);\r\nplatform_set_drvdata(dev, u3d);\r\nu3d->dev = &dev->dev;\r\nu3d->vbus = pdata->vbus;\r\nu3d->clk = clk_get(&dev->dev, NULL);\r\nif (IS_ERR(u3d->clk)) {\r\nretval = PTR_ERR(u3d->clk);\r\ngoto err_get_clk;\r\n}\r\nr = platform_get_resource_byname(dev, IORESOURCE_MEM, "capregs");\r\nif (!r) {\r\ndev_err(&dev->dev, "no I/O memory resource defined\n");\r\nretval = -ENODEV;\r\ngoto err_get_cap_regs;\r\n}\r\nu3d->cap_regs = (struct mv_u3d_cap_regs __iomem *)\r\nioremap(r->start, resource_size(r));\r\nif (!u3d->cap_regs) {\r\ndev_err(&dev->dev, "failed to map I/O memory\n");\r\nretval = -EBUSY;\r\ngoto err_map_cap_regs;\r\n} else {\r\ndev_dbg(&dev->dev, "cap_regs address: 0x%lx/0x%lx\n",\r\n(unsigned long) r->start,\r\n(unsigned long) u3d->cap_regs);\r\n}\r\nclk_enable(u3d->clk);\r\nif (pdata->phy_init) {\r\nretval = pdata->phy_init(u3d->phy_regs);\r\nif (retval) {\r\ndev_err(&dev->dev, "init phy error %d\n", retval);\r\ngoto err_u3d_enable;\r\n}\r\n}\r\nu3d->op_regs = (struct mv_u3d_op_regs __iomem *)(u3d->cap_regs\r\n+ MV_U3D_USB3_OP_REGS_OFFSET);\r\nu3d->vuc_regs = (struct mv_u3d_vuc_regs __iomem *)(u3d->cap_regs\r\n+ ioread32(&u3d->cap_regs->vuoff));\r\nu3d->max_eps = 16;\r\nmv_u3d_controller_stop(u3d);\r\niowrite32(0xFFFFFFFF, &u3d->vuc_regs->intrcause);\r\nif (pdata->phy_deinit)\r\npdata->phy_deinit(u3d->phy_regs);\r\nclk_disable(u3d->clk);\r\nsize = u3d->max_eps * sizeof(struct mv_u3d_ep_context) * 2;\r\nsize = (size + MV_U3D_EP_CONTEXT_ALIGNMENT - 1)\r\n& ~(MV_U3D_EP_CONTEXT_ALIGNMENT - 1);\r\nu3d->ep_context = dma_alloc_coherent(&dev->dev, size,\r\n&u3d->ep_context_dma, GFP_KERNEL);\r\nif (!u3d->ep_context) {\r\ndev_err(&dev->dev, "allocate ep context memory failed\n");\r\nretval = -ENOMEM;\r\ngoto err_alloc_ep_context;\r\n}\r\nu3d->ep_context_size = size;\r\nu3d->trb_pool = dma_pool_create("u3d_trb",\r\n&dev->dev,\r\nsizeof(struct mv_u3d_trb_hw),\r\nMV_U3D_TRB_ALIGNMENT,\r\nMV_U3D_DMA_BOUNDARY);\r\nif (!u3d->trb_pool) {\r\nretval = -ENOMEM;\r\ngoto err_alloc_trb_pool;\r\n}\r\nsize = u3d->max_eps * sizeof(struct mv_u3d_ep) * 2;\r\nu3d->eps = kzalloc(size, GFP_KERNEL);\r\nif (!u3d->eps) {\r\nretval = -ENOMEM;\r\ngoto err_alloc_eps;\r\n}\r\nu3d->status_req = kzalloc(sizeof(struct mv_u3d_req) + 8, GFP_KERNEL);\r\nif (!u3d->status_req) {\r\nretval = -ENOMEM;\r\ngoto err_alloc_status_req;\r\n}\r\nINIT_LIST_HEAD(&u3d->status_req->queue);\r\nu3d->status_req->req.buf = (char *)u3d->status_req\r\n+ sizeof(struct mv_u3d_req);\r\nu3d->status_req->req.dma = virt_to_phys(u3d->status_req->req.buf);\r\nu3d->resume_state = USB_STATE_NOTATTACHED;\r\nu3d->usb_state = USB_STATE_ATTACHED;\r\nu3d->ep0_dir = MV_U3D_EP_DIR_OUT;\r\nu3d->remote_wakeup = 0;\r\nr = platform_get_resource(dev, IORESOURCE_IRQ, 0);\r\nif (!r) {\r\ndev_err(&dev->dev, "no IRQ resource defined\n");\r\nretval = -ENODEV;\r\ngoto err_get_irq;\r\n}\r\nu3d->irq = r->start;\r\nif (request_irq(u3d->irq, mv_u3d_irq,\r\nIRQF_SHARED, driver_name, u3d)) {\r\nu3d->irq = 0;\r\ndev_err(&dev->dev, "Request irq %d for u3d failed\n",\r\nu3d->irq);\r\nretval = -ENODEV;\r\ngoto err_request_irq;\r\n}\r\nu3d->gadget.ops = &mv_u3d_ops;\r\nu3d->gadget.ep0 = &u3d->eps[1].ep;\r\nINIT_LIST_HEAD(&u3d->gadget.ep_list);\r\nu3d->gadget.speed = USB_SPEED_UNKNOWN;\r\nu3d->gadget.name = driver_name;\r\nmv_u3d_eps_init(u3d);\r\nif (u3d->vbus) {\r\nu3d->clock_gating = 1;\r\ndev_err(&dev->dev, "external vbus detection\n");\r\n}\r\nif (!u3d->clock_gating)\r\nu3d->vbus_active = 1;\r\nu3d->vbus_valid_detect = 1;\r\nretval = usb_add_gadget_udc(&dev->dev, &u3d->gadget);\r\nif (retval)\r\ngoto err_unregister;\r\ndev_dbg(&dev->dev, "successful probe usb3 device %s clock gating.\n",\r\nu3d->clock_gating ? "with" : "without");\r\nreturn 0;\r\nerr_unregister:\r\nfree_irq(u3d->irq, u3d);\r\nerr_request_irq:\r\nerr_get_irq:\r\nkfree(u3d->status_req);\r\nerr_alloc_status_req:\r\nkfree(u3d->eps);\r\nerr_alloc_eps:\r\ndma_pool_destroy(u3d->trb_pool);\r\nerr_alloc_trb_pool:\r\ndma_free_coherent(&dev->dev, u3d->ep_context_size,\r\nu3d->ep_context, u3d->ep_context_dma);\r\nerr_alloc_ep_context:\r\nif (pdata->phy_deinit)\r\npdata->phy_deinit(u3d->phy_regs);\r\nclk_disable(u3d->clk);\r\nerr_u3d_enable:\r\niounmap(u3d->cap_regs);\r\nerr_map_cap_regs:\r\nerr_get_cap_regs:\r\nerr_get_clk:\r\nclk_put(u3d->clk);\r\nkfree(u3d);\r\nerr_alloc_private:\r\nerr_pdata:\r\nreturn retval;\r\n}\r\nstatic int mv_u3d_suspend(struct device *dev)\r\n{\r\nstruct mv_u3d *u3d = dev_get_drvdata(dev);\r\nif (!u3d->clock_gating) {\r\nmv_u3d_controller_stop(u3d);\r\nspin_lock_irq(&u3d->lock);\r\nmv_u3d_stop_activity(u3d, u3d->driver);\r\nspin_unlock_irq(&u3d->lock);\r\nmv_u3d_disable(u3d);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mv_u3d_resume(struct device *dev)\r\n{\r\nstruct mv_u3d *u3d = dev_get_drvdata(dev);\r\nint retval;\r\nif (!u3d->clock_gating) {\r\nretval = mv_u3d_enable(u3d);\r\nif (retval)\r\nreturn retval;\r\nif (u3d->driver && u3d->softconnect) {\r\nmv_u3d_controller_reset(u3d);\r\nmv_u3d_ep0_reset(u3d);\r\nmv_u3d_controller_start(u3d);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void mv_u3d_shutdown(struct platform_device *dev)\r\n{\r\nstruct mv_u3d *u3d = platform_get_drvdata(dev);\r\nu32 tmp;\r\ntmp = ioread32(&u3d->op_regs->usbcmd);\r\ntmp &= ~MV_U3D_CMD_RUN_STOP;\r\niowrite32(tmp, &u3d->op_regs->usbcmd);\r\n}
