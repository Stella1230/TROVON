static inline int is_imx25_esdhc(struct pltfm_imx_data *data)\r\n{\r\nreturn data->socdata == &esdhc_imx25_data;\r\n}\r\nstatic inline int is_imx53_esdhc(struct pltfm_imx_data *data)\r\n{\r\nreturn data->socdata == &esdhc_imx53_data;\r\n}\r\nstatic inline int is_imx6q_usdhc(struct pltfm_imx_data *data)\r\n{\r\nreturn data->socdata == &usdhc_imx6q_data;\r\n}\r\nstatic inline int esdhc_is_usdhc(struct pltfm_imx_data *data)\r\n{\r\nreturn !!(data->socdata->flags & ESDHC_FLAG_USDHC);\r\n}\r\nstatic inline void esdhc_clrset_le(struct sdhci_host *host, u32 mask, u32 val, int reg)\r\n{\r\nvoid __iomem *base = host->ioaddr + (reg & ~0x3);\r\nu32 shift = (reg & 0x3) * 8;\r\nwritel(((readl(base) & ~(mask << shift)) | (val << shift)), base);\r\n}\r\nstatic u32 esdhc_readl_le(struct sdhci_host *host, int reg)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = pltfm_host->priv;\r\nu32 val = readl(host->ioaddr + reg);\r\nif (unlikely(reg == SDHCI_PRESENT_STATE)) {\r\nu32 fsl_prss = val;\r\nval = fsl_prss & 0x000FFFFF;\r\nval |= (fsl_prss & 0x0F000000) >> 4;\r\nval |= (fsl_prss & 0x00800000) << 1;\r\n}\r\nif (unlikely(reg == SDHCI_CAPABILITIES)) {\r\nif (imx_data->socdata->flags & ESDHC_FLAG_HAVE_CAP1)\r\nval &= 0xffff0000;\r\nif (val & SDHCI_CAN_DO_ADMA1) {\r\nval &= ~SDHCI_CAN_DO_ADMA1;\r\nval |= SDHCI_CAN_DO_ADMA2;\r\n}\r\n}\r\nif (unlikely(reg == SDHCI_CAPABILITIES_1)) {\r\nif (esdhc_is_usdhc(imx_data)) {\r\nif (imx_data->socdata->flags & ESDHC_FLAG_HAVE_CAP1)\r\nval = readl(host->ioaddr + SDHCI_CAPABILITIES) & 0xFFFF;\r\nelse\r\nval = SDHCI_SUPPORT_DDR50 | SDHCI_SUPPORT_SDR104\r\n| SDHCI_SUPPORT_SDR50\r\n| SDHCI_USE_SDR50_TUNING;\r\n}\r\n}\r\nif (unlikely(reg == SDHCI_MAX_CURRENT) && esdhc_is_usdhc(imx_data)) {\r\nval = 0;\r\nval |= 0xFF << SDHCI_MAX_CURRENT_330_SHIFT;\r\nval |= 0xFF << SDHCI_MAX_CURRENT_300_SHIFT;\r\nval |= 0xFF << SDHCI_MAX_CURRENT_180_SHIFT;\r\n}\r\nif (unlikely(reg == SDHCI_INT_STATUS)) {\r\nif (val & ESDHC_INT_VENDOR_SPEC_DMA_ERR) {\r\nval &= ~ESDHC_INT_VENDOR_SPEC_DMA_ERR;\r\nval |= SDHCI_INT_ADMA_ERROR;\r\n}\r\nif ((imx_data->multiblock_status == WAIT_FOR_INT) &&\r\n((val & SDHCI_INT_RESPONSE) == SDHCI_INT_RESPONSE)) {\r\nval &= ~SDHCI_INT_RESPONSE;\r\nwritel(SDHCI_INT_RESPONSE, host->ioaddr +\r\nSDHCI_INT_STATUS);\r\nimx_data->multiblock_status = NO_CMD_PENDING;\r\n}\r\n}\r\nreturn val;\r\n}\r\nstatic void esdhc_writel_le(struct sdhci_host *host, u32 val, int reg)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = pltfm_host->priv;\r\nu32 data;\r\nif (unlikely(reg == SDHCI_INT_ENABLE || reg == SDHCI_SIGNAL_ENABLE)) {\r\nif (val & SDHCI_INT_CARD_INT) {\r\ndata = readl(host->ioaddr + SDHCI_HOST_CONTROL);\r\ndata &= ~ESDHC_CTRL_D3CD;\r\nwritel(data, host->ioaddr + SDHCI_HOST_CONTROL);\r\ndata |= ESDHC_CTRL_D3CD;\r\nwritel(data, host->ioaddr + SDHCI_HOST_CONTROL);\r\n}\r\n}\r\nif (unlikely((imx_data->socdata->flags & ESDHC_FLAG_MULTIBLK_NO_INT)\r\n&& (reg == SDHCI_INT_STATUS)\r\n&& (val & SDHCI_INT_DATA_END))) {\r\nu32 v;\r\nv = readl(host->ioaddr + ESDHC_VENDOR_SPEC);\r\nv &= ~ESDHC_VENDOR_SPEC_SDIO_QUIRK;\r\nwritel(v, host->ioaddr + ESDHC_VENDOR_SPEC);\r\nif (imx_data->multiblock_status == MULTIBLK_IN_PROCESS)\r\n{\r\ndata = MMC_STOP_TRANSMISSION << 24 |\r\nSDHCI_CMD_ABORTCMD << 16;\r\nwritel(data, host->ioaddr + SDHCI_TRANSFER_MODE);\r\nimx_data->multiblock_status = WAIT_FOR_INT;\r\n}\r\n}\r\nif (unlikely(reg == SDHCI_INT_ENABLE || reg == SDHCI_SIGNAL_ENABLE)) {\r\nif (val & SDHCI_INT_ADMA_ERROR) {\r\nval &= ~SDHCI_INT_ADMA_ERROR;\r\nval |= ESDHC_INT_VENDOR_SPEC_DMA_ERR;\r\n}\r\n}\r\nwritel(val, host->ioaddr + reg);\r\n}\r\nstatic u16 esdhc_readw_le(struct sdhci_host *host, int reg)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = pltfm_host->priv;\r\nu16 ret = 0;\r\nu32 val;\r\nif (unlikely(reg == SDHCI_HOST_VERSION)) {\r\nreg ^= 2;\r\nif (esdhc_is_usdhc(imx_data)) {\r\nreturn SDHCI_SPEC_300;\r\n}\r\n}\r\nif (unlikely(reg == SDHCI_HOST_CONTROL2)) {\r\nval = readl(host->ioaddr + ESDHC_VENDOR_SPEC);\r\nif (val & ESDHC_VENDOR_SPEC_VSELECT)\r\nret |= SDHCI_CTRL_VDD_180;\r\nif (esdhc_is_usdhc(imx_data)) {\r\nif (imx_data->socdata->flags & ESDHC_FLAG_MAN_TUNING)\r\nval = readl(host->ioaddr + ESDHC_MIX_CTRL);\r\nelse if (imx_data->socdata->flags & ESDHC_FLAG_STD_TUNING)\r\nval = readl(host->ioaddr + SDHCI_ACMD12_ERR);\r\n}\r\nif (val & ESDHC_MIX_CTRL_EXE_TUNE)\r\nret |= SDHCI_CTRL_EXEC_TUNING;\r\nif (val & ESDHC_MIX_CTRL_SMPCLK_SEL)\r\nret |= SDHCI_CTRL_TUNED_CLK;\r\nret &= ~SDHCI_CTRL_PRESET_VAL_ENABLE;\r\nreturn ret;\r\n}\r\nif (unlikely(reg == SDHCI_TRANSFER_MODE)) {\r\nif (esdhc_is_usdhc(imx_data)) {\r\nu32 m = readl(host->ioaddr + ESDHC_MIX_CTRL);\r\nret = m & ESDHC_MIX_CTRL_SDHCI_MASK;\r\nif (m & ESDHC_MIX_CTRL_AC23EN) {\r\nret &= ~ESDHC_MIX_CTRL_AC23EN;\r\nret |= SDHCI_TRNS_AUTO_CMD23;\r\n}\r\n} else {\r\nret = readw(host->ioaddr + SDHCI_TRANSFER_MODE);\r\n}\r\nreturn ret;\r\n}\r\nreturn readw(host->ioaddr + reg);\r\n}\r\nstatic void esdhc_writew_le(struct sdhci_host *host, u16 val, int reg)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = pltfm_host->priv;\r\nu32 new_val = 0;\r\nswitch (reg) {\r\ncase SDHCI_CLOCK_CONTROL:\r\nnew_val = readl(host->ioaddr + ESDHC_VENDOR_SPEC);\r\nif (val & SDHCI_CLOCK_CARD_EN)\r\nnew_val |= ESDHC_VENDOR_SPEC_FRC_SDCLK_ON;\r\nelse\r\nnew_val &= ~ESDHC_VENDOR_SPEC_FRC_SDCLK_ON;\r\nwritel(new_val, host->ioaddr + ESDHC_VENDOR_SPEC);\r\nreturn;\r\ncase SDHCI_HOST_CONTROL2:\r\nnew_val = readl(host->ioaddr + ESDHC_VENDOR_SPEC);\r\nif (val & SDHCI_CTRL_VDD_180)\r\nnew_val |= ESDHC_VENDOR_SPEC_VSELECT;\r\nelse\r\nnew_val &= ~ESDHC_VENDOR_SPEC_VSELECT;\r\nwritel(new_val, host->ioaddr + ESDHC_VENDOR_SPEC);\r\nif (imx_data->socdata->flags & ESDHC_FLAG_MAN_TUNING) {\r\nnew_val = readl(host->ioaddr + ESDHC_MIX_CTRL);\r\nif (val & SDHCI_CTRL_TUNED_CLK)\r\nnew_val |= ESDHC_MIX_CTRL_SMPCLK_SEL;\r\nelse\r\nnew_val &= ~ESDHC_MIX_CTRL_SMPCLK_SEL;\r\nwritel(new_val , host->ioaddr + ESDHC_MIX_CTRL);\r\n} else if (imx_data->socdata->flags & ESDHC_FLAG_STD_TUNING) {\r\nu32 v = readl(host->ioaddr + SDHCI_ACMD12_ERR);\r\nu32 m = readl(host->ioaddr + ESDHC_MIX_CTRL);\r\nif (val & SDHCI_CTRL_TUNED_CLK) {\r\nv |= ESDHC_MIX_CTRL_SMPCLK_SEL;\r\n} else {\r\nv &= ~ESDHC_MIX_CTRL_SMPCLK_SEL;\r\nm &= ~ESDHC_MIX_CTRL_FBCLK_SEL;\r\n}\r\nif (val & SDHCI_CTRL_EXEC_TUNING) {\r\nv |= ESDHC_MIX_CTRL_EXE_TUNE;\r\nm |= ESDHC_MIX_CTRL_FBCLK_SEL;\r\n} else {\r\nv &= ~ESDHC_MIX_CTRL_EXE_TUNE;\r\n}\r\nwritel(v, host->ioaddr + SDHCI_ACMD12_ERR);\r\nwritel(m, host->ioaddr + ESDHC_MIX_CTRL);\r\n}\r\nreturn;\r\ncase SDHCI_TRANSFER_MODE:\r\nif ((imx_data->socdata->flags & ESDHC_FLAG_MULTIBLK_NO_INT)\r\n&& (host->cmd->opcode == SD_IO_RW_EXTENDED)\r\n&& (host->cmd->data->blocks > 1)\r\n&& (host->cmd->data->flags & MMC_DATA_READ)) {\r\nu32 v;\r\nv = readl(host->ioaddr + ESDHC_VENDOR_SPEC);\r\nv |= ESDHC_VENDOR_SPEC_SDIO_QUIRK;\r\nwritel(v, host->ioaddr + ESDHC_VENDOR_SPEC);\r\n}\r\nif (esdhc_is_usdhc(imx_data)) {\r\nu32 m = readl(host->ioaddr + ESDHC_MIX_CTRL);\r\nif (val & SDHCI_TRNS_AUTO_CMD23) {\r\nval &= ~SDHCI_TRNS_AUTO_CMD23;\r\nval |= ESDHC_MIX_CTRL_AC23EN;\r\n}\r\nm = val | (m & ~ESDHC_MIX_CTRL_SDHCI_MASK);\r\nwritel(m, host->ioaddr + ESDHC_MIX_CTRL);\r\n} else {\r\nimx_data->scratchpad = val;\r\n}\r\nreturn;\r\ncase SDHCI_COMMAND:\r\nif (host->cmd->opcode == MMC_STOP_TRANSMISSION)\r\nval |= SDHCI_CMD_ABORTCMD;\r\nif ((host->cmd->opcode == MMC_SET_BLOCK_COUNT) &&\r\n(imx_data->socdata->flags & ESDHC_FLAG_MULTIBLK_NO_INT))\r\nimx_data->multiblock_status = MULTIBLK_IN_PROCESS;\r\nif (esdhc_is_usdhc(imx_data))\r\nwritel(val << 16,\r\nhost->ioaddr + SDHCI_TRANSFER_MODE);\r\nelse\r\nwritel(val << 16 | imx_data->scratchpad,\r\nhost->ioaddr + SDHCI_TRANSFER_MODE);\r\nreturn;\r\ncase SDHCI_BLOCK_SIZE:\r\nval &= ~SDHCI_MAKE_BLKSZ(0x7, 0);\r\nbreak;\r\n}\r\nesdhc_clrset_le(host, 0xffff, val, reg);\r\n}\r\nstatic void esdhc_writeb_le(struct sdhci_host *host, u8 val, int reg)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = pltfm_host->priv;\r\nu32 new_val;\r\nu32 mask;\r\nswitch (reg) {\r\ncase SDHCI_POWER_CONTROL:\r\nreturn;\r\ncase SDHCI_HOST_CONTROL:\r\nnew_val = val & SDHCI_CTRL_LED;\r\nnew_val |= ESDHC_HOST_CONTROL_LE;\r\nif (!is_imx25_esdhc(imx_data)) {\r\nnew_val |= (val & SDHCI_CTRL_DMA_MASK) << 5;\r\n}\r\nmask = 0xffff & ~(ESDHC_CTRL_BUSWIDTH_MASK | ESDHC_CTRL_D3CD);\r\nesdhc_clrset_le(host, mask, new_val, reg);\r\nreturn;\r\n}\r\nesdhc_clrset_le(host, 0xff, val, reg);\r\nif ((reg == SDHCI_SOFTWARE_RESET) && (val & 1)) {\r\nesdhc_clrset_le(host, 0x7, 0x7, ESDHC_SYSTEM_CONTROL);\r\nif (esdhc_is_usdhc(imx_data)) {\r\nnew_val = readl(host->ioaddr + ESDHC_MIX_CTRL);\r\nwritel(new_val & ESDHC_MIX_CTRL_TUNING_MASK,\r\nhost->ioaddr + ESDHC_MIX_CTRL);\r\nimx_data->is_ddr = 0;\r\n}\r\n}\r\n}\r\nstatic unsigned int esdhc_pltfm_get_max_clock(struct sdhci_host *host)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = pltfm_host->priv;\r\nstruct esdhc_platform_data *boarddata = &imx_data->boarddata;\r\nif (boarddata->f_max && (boarddata->f_max < pltfm_host->clock))\r\nreturn boarddata->f_max;\r\nelse\r\nreturn pltfm_host->clock;\r\n}\r\nstatic unsigned int esdhc_pltfm_get_min_clock(struct sdhci_host *host)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nreturn pltfm_host->clock / 256 / 16;\r\n}\r\nstatic inline void esdhc_pltfm_set_clock(struct sdhci_host *host,\r\nunsigned int clock)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = pltfm_host->priv;\r\nunsigned int host_clock = pltfm_host->clock;\r\nint pre_div = 2;\r\nint div = 1;\r\nu32 temp, val;\r\nif (clock == 0) {\r\nhost->mmc->actual_clock = 0;\r\nif (esdhc_is_usdhc(imx_data)) {\r\nval = readl(host->ioaddr + ESDHC_VENDOR_SPEC);\r\nwritel(val & ~ESDHC_VENDOR_SPEC_FRC_SDCLK_ON,\r\nhost->ioaddr + ESDHC_VENDOR_SPEC);\r\n}\r\nreturn;\r\n}\r\nif (esdhc_is_usdhc(imx_data) && !imx_data->is_ddr)\r\npre_div = 1;\r\ntemp = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);\r\ntemp &= ~(ESDHC_CLOCK_IPGEN | ESDHC_CLOCK_HCKEN | ESDHC_CLOCK_PEREN\r\n| ESDHC_CLOCK_MASK);\r\nsdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);\r\nwhile (host_clock / pre_div / 16 > clock && pre_div < 256)\r\npre_div *= 2;\r\nwhile (host_clock / pre_div / div > clock && div < 16)\r\ndiv++;\r\nhost->mmc->actual_clock = host_clock / pre_div / div;\r\ndev_dbg(mmc_dev(host->mmc), "desired SD clock: %d, actual: %d\n",\r\nclock, host->mmc->actual_clock);\r\nif (imx_data->is_ddr)\r\npre_div >>= 2;\r\nelse\r\npre_div >>= 1;\r\ndiv--;\r\ntemp = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);\r\ntemp |= (ESDHC_CLOCK_IPGEN | ESDHC_CLOCK_HCKEN | ESDHC_CLOCK_PEREN\r\n| (div << ESDHC_DIVIDER_SHIFT)\r\n| (pre_div << ESDHC_PREDIV_SHIFT));\r\nsdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);\r\nif (esdhc_is_usdhc(imx_data)) {\r\nval = readl(host->ioaddr + ESDHC_VENDOR_SPEC);\r\nwritel(val | ESDHC_VENDOR_SPEC_FRC_SDCLK_ON,\r\nhost->ioaddr + ESDHC_VENDOR_SPEC);\r\n}\r\nmdelay(1);\r\n}\r\nstatic unsigned int esdhc_pltfm_get_ro(struct sdhci_host *host)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = pltfm_host->priv;\r\nstruct esdhc_platform_data *boarddata = &imx_data->boarddata;\r\nswitch (boarddata->wp_type) {\r\ncase ESDHC_WP_GPIO:\r\nreturn mmc_gpio_get_ro(host->mmc);\r\ncase ESDHC_WP_CONTROLLER:\r\nreturn !(readl(host->ioaddr + SDHCI_PRESENT_STATE) &\r\nSDHCI_WRITE_PROTECT);\r\ncase ESDHC_WP_NONE:\r\nbreak;\r\n}\r\nreturn -ENOSYS;\r\n}\r\nstatic void esdhc_pltfm_set_bus_width(struct sdhci_host *host, int width)\r\n{\r\nu32 ctrl;\r\nswitch (width) {\r\ncase MMC_BUS_WIDTH_8:\r\nctrl = ESDHC_CTRL_8BITBUS;\r\nbreak;\r\ncase MMC_BUS_WIDTH_4:\r\nctrl = ESDHC_CTRL_4BITBUS;\r\nbreak;\r\ndefault:\r\nctrl = 0;\r\nbreak;\r\n}\r\nesdhc_clrset_le(host, ESDHC_CTRL_BUSWIDTH_MASK, ctrl,\r\nSDHCI_HOST_CONTROL);\r\n}\r\nstatic void esdhc_prepare_tuning(struct sdhci_host *host, u32 val)\r\n{\r\nu32 reg;\r\nmdelay(1);\r\npm_runtime_get_sync(host->mmc->parent);\r\nreg = readl(host->ioaddr + ESDHC_MIX_CTRL);\r\nreg |= ESDHC_MIX_CTRL_EXE_TUNE | ESDHC_MIX_CTRL_SMPCLK_SEL |\r\nESDHC_MIX_CTRL_FBCLK_SEL;\r\nwritel(reg, host->ioaddr + ESDHC_MIX_CTRL);\r\nwritel(val << 8, host->ioaddr + ESDHC_TUNE_CTRL_STATUS);\r\ndev_dbg(mmc_dev(host->mmc),\r\n"tunning with delay 0x%x ESDHC_TUNE_CTRL_STATUS 0x%x\n",\r\nval, readl(host->ioaddr + ESDHC_TUNE_CTRL_STATUS));\r\n}\r\nstatic void esdhc_request_done(struct mmc_request *mrq)\r\n{\r\ncomplete(&mrq->completion);\r\n}\r\nstatic int esdhc_send_tuning_cmd(struct sdhci_host *host, u32 opcode,\r\nstruct scatterlist *sg)\r\n{\r\nstruct mmc_command cmd = {0};\r\nstruct mmc_request mrq = {NULL};\r\nstruct mmc_data data = {0};\r\ncmd.opcode = opcode;\r\ncmd.arg = 0;\r\ncmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;\r\ndata.blksz = ESDHC_TUNING_BLOCK_PATTERN_LEN;\r\ndata.blocks = 1;\r\ndata.flags = MMC_DATA_READ;\r\ndata.sg = sg;\r\ndata.sg_len = 1;\r\nmrq.cmd = &cmd;\r\nmrq.cmd->mrq = &mrq;\r\nmrq.data = &data;\r\nmrq.data->mrq = &mrq;\r\nmrq.cmd->data = mrq.data;\r\nmrq.done = esdhc_request_done;\r\ninit_completion(&(mrq.completion));\r\nspin_lock_irq(&host->lock);\r\nhost->mrq = &mrq;\r\nsdhci_send_command(host, mrq.cmd);\r\nspin_unlock_irq(&host->lock);\r\nwait_for_completion(&mrq.completion);\r\nif (cmd.error)\r\nreturn cmd.error;\r\nif (data.error)\r\nreturn data.error;\r\nreturn 0;\r\n}\r\nstatic void esdhc_post_tuning(struct sdhci_host *host)\r\n{\r\nu32 reg;\r\nreg = readl(host->ioaddr + ESDHC_MIX_CTRL);\r\nreg &= ~ESDHC_MIX_CTRL_EXE_TUNE;\r\nwritel(reg, host->ioaddr + ESDHC_MIX_CTRL);\r\n}\r\nstatic int esdhc_executing_tuning(struct sdhci_host *host, u32 opcode)\r\n{\r\nstruct scatterlist sg;\r\nchar *tuning_pattern;\r\nint min, max, avg, ret;\r\ntuning_pattern = kmalloc(ESDHC_TUNING_BLOCK_PATTERN_LEN, GFP_KERNEL);\r\nif (!tuning_pattern)\r\nreturn -ENOMEM;\r\nsg_init_one(&sg, tuning_pattern, ESDHC_TUNING_BLOCK_PATTERN_LEN);\r\nmin = ESDHC_TUNE_CTRL_MIN;\r\nwhile (min < ESDHC_TUNE_CTRL_MAX) {\r\nesdhc_prepare_tuning(host, min);\r\nif (!esdhc_send_tuning_cmd(host, opcode, &sg))\r\nbreak;\r\nmin += ESDHC_TUNE_CTRL_STEP;\r\n}\r\nmax = min + ESDHC_TUNE_CTRL_STEP;\r\nwhile (max < ESDHC_TUNE_CTRL_MAX) {\r\nesdhc_prepare_tuning(host, max);\r\nif (esdhc_send_tuning_cmd(host, opcode, &sg)) {\r\nmax -= ESDHC_TUNE_CTRL_STEP;\r\nbreak;\r\n}\r\nmax += ESDHC_TUNE_CTRL_STEP;\r\n}\r\navg = (min + max) / 2;\r\nesdhc_prepare_tuning(host, avg);\r\nret = esdhc_send_tuning_cmd(host, opcode, &sg);\r\nesdhc_post_tuning(host);\r\nkfree(tuning_pattern);\r\ndev_dbg(mmc_dev(host->mmc), "tunning %s at 0x%x ret %d\n",\r\nret ? "failed" : "passed", avg, ret);\r\nreturn ret;\r\n}\r\nstatic int esdhc_change_pinstate(struct sdhci_host *host,\r\nunsigned int uhs)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = pltfm_host->priv;\r\nstruct pinctrl_state *pinctrl;\r\ndev_dbg(mmc_dev(host->mmc), "change pinctrl state for uhs %d\n", uhs);\r\nif (IS_ERR(imx_data->pinctrl) ||\r\nIS_ERR(imx_data->pins_default) ||\r\nIS_ERR(imx_data->pins_100mhz) ||\r\nIS_ERR(imx_data->pins_200mhz))\r\nreturn -EINVAL;\r\nswitch (uhs) {\r\ncase MMC_TIMING_UHS_SDR50:\r\npinctrl = imx_data->pins_100mhz;\r\nbreak;\r\ncase MMC_TIMING_UHS_SDR104:\r\ncase MMC_TIMING_MMC_HS200:\r\npinctrl = imx_data->pins_200mhz;\r\nbreak;\r\ndefault:\r\npinctrl = imx_data->pins_default;\r\n}\r\nreturn pinctrl_select_state(imx_data->pinctrl, pinctrl);\r\n}\r\nstatic void esdhc_set_uhs_signaling(struct sdhci_host *host, unsigned timing)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = pltfm_host->priv;\r\nstruct esdhc_platform_data *boarddata = &imx_data->boarddata;\r\nswitch (timing) {\r\ncase MMC_TIMING_UHS_SDR12:\r\ncase MMC_TIMING_UHS_SDR25:\r\ncase MMC_TIMING_UHS_SDR50:\r\ncase MMC_TIMING_UHS_SDR104:\r\ncase MMC_TIMING_MMC_HS200:\r\nbreak;\r\ncase MMC_TIMING_UHS_DDR50:\r\ncase MMC_TIMING_MMC_DDR52:\r\nwritel(readl(host->ioaddr + ESDHC_MIX_CTRL) |\r\nESDHC_MIX_CTRL_DDREN,\r\nhost->ioaddr + ESDHC_MIX_CTRL);\r\nimx_data->is_ddr = 1;\r\nif (boarddata->delay_line) {\r\nu32 v;\r\nv = boarddata->delay_line <<\r\nESDHC_DLL_OVERRIDE_VAL_SHIFT |\r\n(1 << ESDHC_DLL_OVERRIDE_EN_SHIFT);\r\nif (is_imx53_esdhc(imx_data))\r\nv <<= 1;\r\nwritel(v, host->ioaddr + ESDHC_DLL_CTRL);\r\n}\r\nbreak;\r\n}\r\nesdhc_change_pinstate(host, timing);\r\n}\r\nstatic void esdhc_reset(struct sdhci_host *host, u8 mask)\r\n{\r\nsdhci_reset(host, mask);\r\nsdhci_writel(host, host->ier, SDHCI_INT_ENABLE);\r\nsdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);\r\n}\r\nstatic int\r\nsdhci_esdhc_imx_probe_dt(struct platform_device *pdev,\r\nstruct esdhc_platform_data *boarddata)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nif (!np)\r\nreturn -ENODEV;\r\nif (of_get_property(np, "non-removable", NULL))\r\nboarddata->cd_type = ESDHC_CD_PERMANENT;\r\nif (of_get_property(np, "fsl,cd-controller", NULL))\r\nboarddata->cd_type = ESDHC_CD_CONTROLLER;\r\nif (of_get_property(np, "fsl,wp-controller", NULL))\r\nboarddata->wp_type = ESDHC_WP_CONTROLLER;\r\nboarddata->cd_gpio = of_get_named_gpio(np, "cd-gpios", 0);\r\nif (gpio_is_valid(boarddata->cd_gpio))\r\nboarddata->cd_type = ESDHC_CD_GPIO;\r\nboarddata->wp_gpio = of_get_named_gpio(np, "wp-gpios", 0);\r\nif (gpio_is_valid(boarddata->wp_gpio))\r\nboarddata->wp_type = ESDHC_WP_GPIO;\r\nof_property_read_u32(np, "bus-width", &boarddata->max_bus_width);\r\nof_property_read_u32(np, "max-frequency", &boarddata->f_max);\r\nif (of_find_property(np, "no-1-8-v", NULL))\r\nboarddata->support_vsel = false;\r\nelse\r\nboarddata->support_vsel = true;\r\nif (of_property_read_u32(np, "fsl,delay-line", &boarddata->delay_line))\r\nboarddata->delay_line = 0;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nsdhci_esdhc_imx_probe_dt(struct platform_device *pdev,\r\nstruct esdhc_platform_data *boarddata)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int sdhci_esdhc_imx_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(imx_esdhc_dt_ids, &pdev->dev);\r\nstruct sdhci_pltfm_host *pltfm_host;\r\nstruct sdhci_host *host;\r\nstruct esdhc_platform_data *boarddata;\r\nint err;\r\nstruct pltfm_imx_data *imx_data;\r\nhost = sdhci_pltfm_init(pdev, &sdhci_esdhc_imx_pdata, 0);\r\nif (IS_ERR(host))\r\nreturn PTR_ERR(host);\r\npltfm_host = sdhci_priv(host);\r\nimx_data = devm_kzalloc(&pdev->dev, sizeof(*imx_data), GFP_KERNEL);\r\nif (!imx_data) {\r\nerr = -ENOMEM;\r\ngoto free_sdhci;\r\n}\r\nimx_data->socdata = of_id ? of_id->data : (struct esdhc_soc_data *)\r\npdev->id_entry->driver_data;\r\npltfm_host->priv = imx_data;\r\nimx_data->clk_ipg = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(imx_data->clk_ipg)) {\r\nerr = PTR_ERR(imx_data->clk_ipg);\r\ngoto free_sdhci;\r\n}\r\nimx_data->clk_ahb = devm_clk_get(&pdev->dev, "ahb");\r\nif (IS_ERR(imx_data->clk_ahb)) {\r\nerr = PTR_ERR(imx_data->clk_ahb);\r\ngoto free_sdhci;\r\n}\r\nimx_data->clk_per = devm_clk_get(&pdev->dev, "per");\r\nif (IS_ERR(imx_data->clk_per)) {\r\nerr = PTR_ERR(imx_data->clk_per);\r\ngoto free_sdhci;\r\n}\r\npltfm_host->clk = imx_data->clk_per;\r\npltfm_host->clock = clk_get_rate(pltfm_host->clk);\r\nclk_prepare_enable(imx_data->clk_per);\r\nclk_prepare_enable(imx_data->clk_ipg);\r\nclk_prepare_enable(imx_data->clk_ahb);\r\nimx_data->pinctrl = devm_pinctrl_get(&pdev->dev);\r\nif (IS_ERR(imx_data->pinctrl)) {\r\nerr = PTR_ERR(imx_data->pinctrl);\r\ngoto disable_clk;\r\n}\r\nimx_data->pins_default = pinctrl_lookup_state(imx_data->pinctrl,\r\nPINCTRL_STATE_DEFAULT);\r\nif (IS_ERR(imx_data->pins_default)) {\r\nerr = PTR_ERR(imx_data->pins_default);\r\ndev_err(mmc_dev(host->mmc), "could not get default state\n");\r\ngoto disable_clk;\r\n}\r\nhost->quirks |= SDHCI_QUIRK_BROKEN_TIMEOUT_VAL;\r\nif (imx_data->socdata->flags & ESDHC_FLAG_ENGCM07207)\r\nhost->quirks |= SDHCI_QUIRK_NO_MULTIBLOCK\r\n| SDHCI_QUIRK_BROKEN_ADMA;\r\nif (esdhc_is_usdhc(imx_data)) {\r\nwritel(0x08100810, host->ioaddr + ESDHC_WTMK_LVL);\r\nhost->quirks2 |= SDHCI_QUIRK2_PRESET_VALUE_BROKEN;\r\nhost->mmc->caps |= MMC_CAP_1_8V_DDR;\r\n}\r\nif (imx_data->socdata->flags & ESDHC_FLAG_MAN_TUNING)\r\nsdhci_esdhc_ops.platform_execute_tuning =\r\nesdhc_executing_tuning;\r\nif (imx_data->socdata->flags & ESDHC_FLAG_STD_TUNING)\r\nwritel(readl(host->ioaddr + ESDHC_TUNING_CTRL) |\r\nESDHC_STD_TUNING_EN | ESDHC_TUNING_START_TAP,\r\nhost->ioaddr + ESDHC_TUNING_CTRL);\r\nboarddata = &imx_data->boarddata;\r\nif (sdhci_esdhc_imx_probe_dt(pdev, boarddata) < 0) {\r\nif (!host->mmc->parent->platform_data) {\r\ndev_err(mmc_dev(host->mmc), "no board data!\n");\r\nerr = -EINVAL;\r\ngoto disable_clk;\r\n}\r\nimx_data->boarddata = *((struct esdhc_platform_data *)\r\nhost->mmc->parent->platform_data);\r\n}\r\nif (boarddata->wp_type == ESDHC_WP_GPIO) {\r\nerr = mmc_gpio_request_ro(host->mmc, boarddata->wp_gpio);\r\nif (err) {\r\ndev_err(mmc_dev(host->mmc),\r\n"failed to request write-protect gpio!\n");\r\ngoto disable_clk;\r\n}\r\nhost->mmc->caps2 |= MMC_CAP2_RO_ACTIVE_HIGH;\r\n}\r\nswitch (boarddata->cd_type) {\r\ncase ESDHC_CD_GPIO:\r\nerr = mmc_gpio_request_cd(host->mmc, boarddata->cd_gpio, 0);\r\nif (err) {\r\ndev_err(mmc_dev(host->mmc),\r\n"failed to request card-detect gpio!\n");\r\ngoto disable_clk;\r\n}\r\ncase ESDHC_CD_CONTROLLER:\r\nhost->quirks &= ~SDHCI_QUIRK_BROKEN_CARD_DETECTION;\r\nbreak;\r\ncase ESDHC_CD_PERMANENT:\r\nhost->mmc->caps |= MMC_CAP_NONREMOVABLE;\r\nbreak;\r\ncase ESDHC_CD_NONE:\r\nbreak;\r\n}\r\nswitch (boarddata->max_bus_width) {\r\ncase 8:\r\nhost->mmc->caps |= MMC_CAP_8_BIT_DATA | MMC_CAP_4_BIT_DATA;\r\nbreak;\r\ncase 4:\r\nhost->mmc->caps |= MMC_CAP_4_BIT_DATA;\r\nbreak;\r\ncase 1:\r\ndefault:\r\nhost->quirks |= SDHCI_QUIRK_FORCE_1_BIT_DATA;\r\nbreak;\r\n}\r\nif ((boarddata->support_vsel) && esdhc_is_usdhc(imx_data)) {\r\nimx_data->pins_100mhz = pinctrl_lookup_state(imx_data->pinctrl,\r\nESDHC_PINCTRL_STATE_100MHZ);\r\nimx_data->pins_200mhz = pinctrl_lookup_state(imx_data->pinctrl,\r\nESDHC_PINCTRL_STATE_200MHZ);\r\nif (IS_ERR(imx_data->pins_100mhz) ||\r\nIS_ERR(imx_data->pins_200mhz)) {\r\ndev_warn(mmc_dev(host->mmc),\r\n"could not get ultra high speed state, work on normal mode\n");\r\nhost->quirks2 |= SDHCI_QUIRK2_NO_1_8_V;\r\n}\r\n} else {\r\nhost->quirks2 |= SDHCI_QUIRK2_NO_1_8_V;\r\n}\r\nerr = sdhci_add_host(host);\r\nif (err)\r\ngoto disable_clk;\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_set_autosuspend_delay(&pdev->dev, 50);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_suspend_ignore_children(&pdev->dev, 1);\r\nreturn 0;\r\ndisable_clk:\r\nclk_disable_unprepare(imx_data->clk_per);\r\nclk_disable_unprepare(imx_data->clk_ipg);\r\nclk_disable_unprepare(imx_data->clk_ahb);\r\nfree_sdhci:\r\nsdhci_pltfm_free(pdev);\r\nreturn err;\r\n}\r\nstatic int sdhci_esdhc_imx_remove(struct platform_device *pdev)\r\n{\r\nstruct sdhci_host *host = platform_get_drvdata(pdev);\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = pltfm_host->priv;\r\nint dead = (readl(host->ioaddr + SDHCI_INT_STATUS) == 0xffffffff);\r\nsdhci_remove_host(host, dead);\r\npm_runtime_dont_use_autosuspend(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nif (!IS_ENABLED(CONFIG_PM_RUNTIME)) {\r\nclk_disable_unprepare(imx_data->clk_per);\r\nclk_disable_unprepare(imx_data->clk_ipg);\r\nclk_disable_unprepare(imx_data->clk_ahb);\r\n}\r\nsdhci_pltfm_free(pdev);\r\nreturn 0;\r\n}\r\nstatic int sdhci_esdhc_runtime_suspend(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = pltfm_host->priv;\r\nint ret;\r\nret = sdhci_runtime_suspend_host(host);\r\nif (!sdhci_sdio_irq_enabled(host)) {\r\nclk_disable_unprepare(imx_data->clk_per);\r\nclk_disable_unprepare(imx_data->clk_ipg);\r\n}\r\nclk_disable_unprepare(imx_data->clk_ahb);\r\nreturn ret;\r\n}\r\nstatic int sdhci_esdhc_runtime_resume(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct pltfm_imx_data *imx_data = pltfm_host->priv;\r\nif (!sdhci_sdio_irq_enabled(host)) {\r\nclk_prepare_enable(imx_data->clk_per);\r\nclk_prepare_enable(imx_data->clk_ipg);\r\n}\r\nclk_prepare_enable(imx_data->clk_ahb);\r\nreturn sdhci_runtime_resume_host(host);\r\n}
