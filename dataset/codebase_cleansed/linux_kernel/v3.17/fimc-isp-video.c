static int isp_video_capture_queue_setup(struct vb2_queue *vq,\r\nconst struct v4l2_format *pfmt,\r\nunsigned int *num_buffers, unsigned int *num_planes,\r\nunsigned int sizes[], void *allocators[])\r\n{\r\nstruct fimc_isp *isp = vb2_get_drv_priv(vq);\r\nstruct v4l2_pix_format_mplane *vid_fmt = &isp->video_capture.pixfmt;\r\nconst struct v4l2_pix_format_mplane *pixm = NULL;\r\nconst struct fimc_fmt *fmt;\r\nunsigned int wh, i;\r\nif (pfmt) {\r\npixm = &pfmt->fmt.pix_mp;\r\nfmt = fimc_isp_find_format(&pixm->pixelformat, NULL, -1);\r\nwh = pixm->width * pixm->height;\r\n} else {\r\nfmt = isp->video_capture.format;\r\nwh = vid_fmt->width * vid_fmt->height;\r\n}\r\nif (fmt == NULL)\r\nreturn -EINVAL;\r\n*num_buffers = clamp_t(u32, *num_buffers, FIMC_ISP_REQ_BUFS_MIN,\r\nFIMC_ISP_REQ_BUFS_MAX);\r\n*num_planes = fmt->memplanes;\r\nfor (i = 0; i < fmt->memplanes; i++) {\r\nunsigned int size = (wh * fmt->depth[i]) / 8;\r\nif (pixm)\r\nsizes[i] = max(size, pixm->plane_fmt[i].sizeimage);\r\nelse\r\nsizes[i] = size;\r\nallocators[i] = isp->alloc_ctx;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline struct param_dma_output *__get_isp_dma2(struct fimc_is *is)\r\n{\r\nreturn &__get_curr_is_config(is)->isp.dma2_output;\r\n}\r\nstatic int isp_video_capture_start_streaming(struct vb2_queue *q,\r\nunsigned int count)\r\n{\r\nstruct fimc_isp *isp = vb2_get_drv_priv(q);\r\nstruct fimc_is *is = fimc_isp_to_is(isp);\r\nstruct param_dma_output *dma = __get_isp_dma2(is);\r\nstruct fimc_is_video *video = &isp->video_capture;\r\nint ret;\r\nif (!test_bit(ST_ISP_VID_CAP_BUF_PREP, &isp->state) ||\r\ntest_bit(ST_ISP_VID_CAP_STREAMING, &isp->state))\r\nreturn 0;\r\ndma->cmd = DMA_OUTPUT_COMMAND_ENABLE;\r\ndma->notify_dma_done = DMA_OUTPUT_NOTIFY_DMA_DONE_ENABLE;\r\ndma->buffer_address = is->is_dma_p_region +\r\nDMA2_OUTPUT_ADDR_ARRAY_OFFS;\r\ndma->buffer_number = video->reqbufs_count;\r\ndma->dma_out_mask = video->buf_mask;\r\nisp_dbg(2, &video->ve.vdev,\r\n"buf_count: %d, planes: %d, dma addr table: %#x\n",\r\nvideo->buf_count, video->format->memplanes,\r\ndma->buffer_address);\r\nfimc_is_mem_barrier();\r\nfimc_is_set_param_bit(is, PARAM_ISP_DMA2_OUTPUT);\r\n__fimc_is_hw_update_param(is, PARAM_ISP_DMA2_OUTPUT);\r\nret = fimc_is_itf_s_param(is, false);\r\nif (ret < 0)\r\nreturn ret;\r\nret = fimc_pipeline_call(&video->ve, set_stream, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nset_bit(ST_ISP_VID_CAP_STREAMING, &isp->state);\r\nreturn ret;\r\n}\r\nstatic void isp_video_capture_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct fimc_isp *isp = vb2_get_drv_priv(q);\r\nstruct fimc_is *is = fimc_isp_to_is(isp);\r\nstruct param_dma_output *dma = __get_isp_dma2(is);\r\nint ret;\r\nret = fimc_pipeline_call(&isp->video_capture.ve, set_stream, 0);\r\nif (ret < 0)\r\nreturn;\r\ndma->cmd = DMA_OUTPUT_COMMAND_DISABLE;\r\ndma->notify_dma_done = DMA_OUTPUT_NOTIFY_DMA_DONE_DISABLE;\r\ndma->buffer_number = 0;\r\ndma->buffer_address = 0;\r\ndma->dma_out_mask = 0;\r\nfimc_is_set_param_bit(is, PARAM_ISP_DMA2_OUTPUT);\r\n__fimc_is_hw_update_param(is, PARAM_ISP_DMA2_OUTPUT);\r\nret = fimc_is_itf_s_param(is, false);\r\nif (ret < 0)\r\ndev_warn(&is->pdev->dev, "%s: DMA stop failed\n", __func__);\r\nfimc_is_hw_set_isp_buf_mask(is, 0);\r\nclear_bit(ST_ISP_VID_CAP_BUF_PREP, &isp->state);\r\nclear_bit(ST_ISP_VID_CAP_STREAMING, &isp->state);\r\nisp->video_capture.buf_count = 0;\r\n}\r\nstatic int isp_video_capture_buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct fimc_isp *isp = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct fimc_is_video *video = &isp->video_capture;\r\nint i;\r\nif (video->format == NULL)\r\nreturn -EINVAL;\r\nfor (i = 0; i < video->format->memplanes; i++) {\r\nunsigned long size = video->pixfmt.plane_fmt[i].sizeimage;\r\nif (vb2_plane_size(vb, i) < size) {\r\nv4l2_err(&video->ve.vdev,\r\n"User buffer too small (%ld < %ld)\n",\r\nvb2_plane_size(vb, i), size);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, i, size);\r\n}\r\nif (test_bit(ST_ISP_VID_CAP_BUF_PREP, &isp->state)) {\r\ndma_addr_t dma_addr = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nint i;\r\nfor (i = 0; i < video->buf_count; i++)\r\nif (video->buffers[i]->dma_addr[0] == dma_addr)\r\nreturn 0;\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void isp_video_capture_buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct fimc_isp *isp = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct fimc_is_video *video = &isp->video_capture;\r\nstruct fimc_is *is = fimc_isp_to_is(isp);\r\nstruct isp_video_buf *ivb = to_isp_video_buf(vb);\r\nunsigned long flags;\r\nunsigned int i;\r\nif (test_bit(ST_ISP_VID_CAP_BUF_PREP, &isp->state)) {\r\nspin_lock_irqsave(&is->slock, flags);\r\nvideo->buf_mask |= BIT(ivb->index);\r\nspin_unlock_irqrestore(&is->slock, flags);\r\n} else {\r\nunsigned int num_planes = video->format->memplanes;\r\nivb->index = video->buf_count;\r\nvideo->buffers[ivb->index] = ivb;\r\nfor (i = 0; i < num_planes; i++) {\r\nint buf_index = ivb->index * num_planes + i;\r\nivb->dma_addr[i] = vb2_dma_contig_plane_dma_addr(vb, i);\r\nis->is_p_region->shared[32 + buf_index] =\r\nivb->dma_addr[i];\r\nisp_dbg(2, &video->ve.vdev,\r\n"dma_buf %d (%d/%d/%d) addr: %#x\n",\r\nbuf_index, ivb->index, i, vb->v4l2_buf.index,\r\nivb->dma_addr[i]);\r\n}\r\nif (++video->buf_count < video->reqbufs_count)\r\nreturn;\r\nvideo->buf_mask = (1UL << video->buf_count) - 1;\r\nset_bit(ST_ISP_VID_CAP_BUF_PREP, &isp->state);\r\n}\r\nif (!test_bit(ST_ISP_VID_CAP_STREAMING, &isp->state))\r\nisp_video_capture_start_streaming(vb->vb2_queue, 0);\r\n}\r\nvoid fimc_isp_video_irq_handler(struct fimc_is *is)\r\n{\r\nstruct fimc_is_video *video = &is->isp.video_capture;\r\nstruct vb2_buffer *vb;\r\nint buf_index;\r\nif (!test_bit(ST_ISP_VID_CAP_STREAMING, &is->isp.state))\r\nreturn;\r\nbuf_index = (is->i2h_cmd.args[1] - 1) % video->buf_count;\r\nvb = &video->buffers[buf_index]->vb;\r\nv4l2_get_timestamp(&vb->v4l2_buf.timestamp);\r\nvb2_buffer_done(vb, VB2_BUF_STATE_DONE);\r\nvideo->buf_mask &= ~BIT(buf_index);\r\nfimc_is_hw_set_isp_buf_mask(is, video->buf_mask);\r\n}\r\nstatic int isp_video_open(struct file *file)\r\n{\r\nstruct fimc_isp *isp = video_drvdata(file);\r\nstruct exynos_video_entity *ve = &isp->video_capture.ve;\r\nstruct media_entity *me = &ve->vdev.entity;\r\nint ret;\r\nif (mutex_lock_interruptible(&isp->video_lock))\r\nreturn -ERESTARTSYS;\r\nret = v4l2_fh_open(file);\r\nif (ret < 0)\r\ngoto unlock;\r\nret = pm_runtime_get_sync(&isp->pdev->dev);\r\nif (ret < 0)\r\ngoto rel_fh;\r\nif (v4l2_fh_is_singular_file(file)) {\r\nmutex_lock(&me->parent->graph_mutex);\r\nret = fimc_pipeline_call(ve, open, me, true);\r\nif (ret == 0)\r\nme->use_count++;\r\nmutex_unlock(&me->parent->graph_mutex);\r\n}\r\nif (!ret)\r\ngoto unlock;\r\nrel_fh:\r\nv4l2_fh_release(file);\r\nunlock:\r\nmutex_unlock(&isp->video_lock);\r\nreturn ret;\r\n}\r\nstatic int isp_video_release(struct file *file)\r\n{\r\nstruct fimc_isp *isp = video_drvdata(file);\r\nstruct fimc_is_video *ivc = &isp->video_capture;\r\nstruct media_entity *entity = &ivc->ve.vdev.entity;\r\nstruct media_device *mdev = entity->parent;\r\nint ret = 0;\r\nmutex_lock(&isp->video_lock);\r\nif (v4l2_fh_is_singular_file(file) && ivc->streaming) {\r\nmedia_entity_pipeline_stop(entity);\r\nivc->streaming = 0;\r\n}\r\nvb2_fop_release(file);\r\nif (v4l2_fh_is_singular_file(file)) {\r\nfimc_pipeline_call(&ivc->ve, close);\r\nmutex_lock(&mdev->graph_mutex);\r\nentity->use_count--;\r\nmutex_unlock(&mdev->graph_mutex);\r\n}\r\npm_runtime_put(&isp->pdev->dev);\r\nmutex_unlock(&isp->video_lock);\r\nreturn ret;\r\n}\r\nstatic int isp_video_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct fimc_isp *isp = video_drvdata(file);\r\n__fimc_vidioc_querycap(&isp->pdev->dev, cap, V4L2_CAP_STREAMING);\r\nreturn 0;\r\n}\r\nstatic int isp_video_enum_fmt_mplane(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nconst struct fimc_fmt *fmt;\r\nif (f->index >= FIMC_ISP_NUM_FORMATS)\r\nreturn -EINVAL;\r\nfmt = fimc_isp_find_format(NULL, NULL, f->index);\r\nif (WARN_ON(fmt == NULL))\r\nreturn -EINVAL;\r\nstrlcpy(f->description, fmt->name, sizeof(f->description));\r\nf->pixelformat = fmt->fourcc;\r\nreturn 0;\r\n}\r\nstatic int isp_video_g_fmt_mplane(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct fimc_isp *isp = video_drvdata(file);\r\nf->fmt.pix_mp = isp->video_capture.pixfmt;\r\nreturn 0;\r\n}\r\nstatic void __isp_video_try_fmt(struct fimc_isp *isp,\r\nstruct v4l2_pix_format_mplane *pixm,\r\nconst struct fimc_fmt **fmt)\r\n{\r\n*fmt = fimc_isp_find_format(&pixm->pixelformat, NULL, 2);\r\npixm->colorspace = V4L2_COLORSPACE_SRGB;\r\npixm->field = V4L2_FIELD_NONE;\r\npixm->num_planes = (*fmt)->memplanes;\r\npixm->pixelformat = (*fmt)->fourcc;\r\nv4l_bound_align_image(&pixm->width, FIMC_ISP_SOURCE_WIDTH_MIN,\r\nFIMC_ISP_SOURCE_WIDTH_MAX, 3,\r\n&pixm->height, FIMC_ISP_SOURCE_HEIGHT_MIN,\r\nFIMC_ISP_SOURCE_HEIGHT_MAX, 0, 0);\r\n}\r\nstatic int isp_video_try_fmt_mplane(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct fimc_isp *isp = video_drvdata(file);\r\n__isp_video_try_fmt(isp, &f->fmt.pix_mp, NULL);\r\nreturn 0;\r\n}\r\nstatic int isp_video_s_fmt_mplane(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct fimc_isp *isp = video_drvdata(file);\r\nstruct fimc_is *is = fimc_isp_to_is(isp);\r\nstruct v4l2_pix_format_mplane *pixm = &f->fmt.pix_mp;\r\nconst struct fimc_fmt *ifmt = NULL;\r\nstruct param_dma_output *dma = __get_isp_dma2(is);\r\n__isp_video_try_fmt(isp, pixm, &ifmt);\r\nif (WARN_ON(ifmt == NULL))\r\nreturn -EINVAL;\r\ndma->format = DMA_OUTPUT_FORMAT_BAYER;\r\ndma->order = DMA_OUTPUT_ORDER_GB_BG;\r\ndma->plane = ifmt->memplanes;\r\ndma->bitwidth = ifmt->depth[0];\r\ndma->width = pixm->width;\r\ndma->height = pixm->height;\r\nfimc_is_mem_barrier();\r\nisp->video_capture.format = ifmt;\r\nisp->video_capture.pixfmt = *pixm;\r\nreturn 0;\r\n}\r\nstatic int isp_video_pipeline_validate(struct fimc_isp *isp)\r\n{\r\nstruct v4l2_subdev *sd = &isp->subdev;\r\nstruct v4l2_subdev_format sink_fmt, src_fmt;\r\nstruct media_pad *pad;\r\nint ret;\r\nwhile (1) {\r\npad = &sd->entity.pads[0];\r\nif (!(pad->flags & MEDIA_PAD_FL_SINK))\r\nbreak;\r\nsink_fmt.pad = pad->index;\r\nsink_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &sink_fmt);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn -EPIPE;\r\npad = media_entity_remote_pad(pad);\r\nif (pad == NULL ||\r\nmedia_entity_type(pad->entity) != MEDIA_ENT_T_V4L2_SUBDEV)\r\nbreak;\r\nsd = media_entity_to_v4l2_subdev(pad->entity);\r\nsrc_fmt.pad = pad->index;\r\nsrc_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &src_fmt);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn -EPIPE;\r\nif (src_fmt.format.width != sink_fmt.format.width ||\r\nsrc_fmt.format.height != sink_fmt.format.height ||\r\nsrc_fmt.format.code != sink_fmt.format.code)\r\nreturn -EPIPE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int isp_video_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct fimc_isp *isp = video_drvdata(file);\r\nstruct exynos_video_entity *ve = &isp->video_capture.ve;\r\nstruct media_entity *me = &ve->vdev.entity;\r\nint ret;\r\nret = media_entity_pipeline_start(me, &ve->pipe->mp);\r\nif (ret < 0)\r\nreturn ret;\r\nret = isp_video_pipeline_validate(isp);\r\nif (ret < 0)\r\ngoto p_stop;\r\nret = vb2_ioctl_streamon(file, priv, type);\r\nif (ret < 0)\r\ngoto p_stop;\r\nisp->video_capture.streaming = 1;\r\nreturn 0;\r\np_stop:\r\nmedia_entity_pipeline_stop(me);\r\nreturn ret;\r\n}\r\nstatic int isp_video_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct fimc_isp *isp = video_drvdata(file);\r\nstruct fimc_is_video *video = &isp->video_capture;\r\nint ret;\r\nret = vb2_ioctl_streamoff(file, priv, type);\r\nif (ret < 0)\r\nreturn ret;\r\nmedia_entity_pipeline_stop(&video->ve.vdev.entity);\r\nvideo->streaming = 0;\r\nreturn 0;\r\n}\r\nstatic int isp_video_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *rb)\r\n{\r\nstruct fimc_isp *isp = video_drvdata(file);\r\nint ret;\r\nret = vb2_ioctl_reqbufs(file, priv, rb);\r\nif (ret < 0)\r\nreturn ret;\r\nif (rb->count && rb->count < FIMC_ISP_REQ_BUFS_MIN) {\r\nrb->count = 0;\r\nvb2_ioctl_reqbufs(file, priv, rb);\r\nret = -ENOMEM;\r\n}\r\nisp->video_capture.reqbufs_count = rb->count;\r\nreturn ret;\r\n}\r\nint fimc_isp_video_device_register(struct fimc_isp *isp,\r\nstruct v4l2_device *v4l2_dev,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct vb2_queue *q = &isp->video_capture.vb_queue;\r\nstruct fimc_is_video *iv;\r\nstruct video_device *vdev;\r\nint ret;\r\nif (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\niv = &isp->video_capture;\r\nelse\r\nreturn -ENOSYS;\r\nmutex_init(&isp->video_lock);\r\nINIT_LIST_HEAD(&iv->pending_buf_q);\r\nINIT_LIST_HEAD(&iv->active_buf_q);\r\niv->format = fimc_isp_find_format(NULL, NULL, 0);\r\niv->pixfmt.width = IS_DEFAULT_WIDTH;\r\niv->pixfmt.height = IS_DEFAULT_HEIGHT;\r\niv->pixfmt.pixelformat = iv->format->fourcc;\r\niv->pixfmt.colorspace = V4L2_COLORSPACE_SRGB;\r\niv->reqbufs_count = 0;\r\nmemset(q, 0, sizeof(*q));\r\nq->type = type;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR;\r\nq->ops = &isp_video_capture_qops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->buf_struct_size = sizeof(struct isp_video_buf);\r\nq->drv_priv = isp;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->lock = &isp->video_lock;\r\nret = vb2_queue_init(q);\r\nif (ret < 0)\r\nreturn ret;\r\nvdev = &iv->ve.vdev;\r\nmemset(vdev, 0, sizeof(*vdev));\r\nsnprintf(vdev->name, sizeof(vdev->name), "fimc-is-isp.%s",\r\ntype == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE ?\r\n"capture" : "output");\r\nvdev->queue = q;\r\nvdev->fops = &isp_video_fops;\r\nvdev->ioctl_ops = &isp_video_ioctl_ops;\r\nvdev->v4l2_dev = v4l2_dev;\r\nvdev->minor = -1;\r\nvdev->release = video_device_release_empty;\r\nvdev->lock = &isp->video_lock;\r\niv->pad.flags = MEDIA_PAD_FL_SINK;\r\nret = media_entity_init(&vdev->entity, 1, &iv->pad, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nvideo_set_drvdata(vdev, isp);\r\nret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);\r\nif (ret < 0) {\r\nmedia_entity_cleanup(&vdev->entity);\r\nreturn ret;\r\n}\r\nv4l2_info(v4l2_dev, "Registered %s as /dev/%s\n",\r\nvdev->name, video_device_node_name(vdev));\r\nreturn 0;\r\n}\r\nvoid fimc_isp_video_device_unregister(struct fimc_isp *isp,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct exynos_video_entity *ve;\r\nif (type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\nve = &isp->video_capture.ve;\r\nelse\r\nreturn;\r\nmutex_lock(&isp->video_lock);\r\nif (video_is_registered(&ve->vdev)) {\r\nvideo_unregister_device(&ve->vdev);\r\nmedia_entity_cleanup(&ve->vdev.entity);\r\nve->pipe = NULL;\r\n}\r\nmutex_unlock(&isp->video_lock);\r\n}
