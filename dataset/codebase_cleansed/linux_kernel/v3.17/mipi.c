static inline unsigned long tegra_mipi_readl(struct tegra_mipi *mipi,\r\nunsigned long reg)\r\n{\r\nreturn readl(mipi->regs + (reg << 2));\r\n}\r\nstatic inline void tegra_mipi_writel(struct tegra_mipi *mipi,\r\nunsigned long value, unsigned long reg)\r\n{\r\nwritel(value, mipi->regs + (reg << 2));\r\n}\r\nstruct tegra_mipi_device *tegra_mipi_request(struct device *device)\r\n{\r\nstruct device_node *np = device->of_node;\r\nstruct tegra_mipi_device *dev;\r\nstruct of_phandle_args args;\r\nint err;\r\nerr = of_parse_phandle_with_args(np, "nvidia,mipi-calibrate",\r\n"#nvidia,mipi-calibrate-cells", 0,\r\n&args);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nof_node_put(args.np);\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\ndev->pdev = of_find_device_by_node(args.np);\r\nif (!dev->pdev) {\r\nof_node_put(args.np);\r\nerr = -ENODEV;\r\ngoto free;\r\n}\r\nof_node_put(args.np);\r\ndev->mipi = platform_get_drvdata(dev->pdev);\r\nif (!dev->mipi) {\r\nerr = -EPROBE_DEFER;\r\ngoto pdev_put;\r\n}\r\ndev->pads = args.args[0];\r\ndev->device = device;\r\nreturn dev;\r\npdev_put:\r\nplatform_device_put(dev->pdev);\r\nfree:\r\nkfree(dev);\r\nout:\r\nreturn ERR_PTR(err);\r\n}\r\nvoid tegra_mipi_free(struct tegra_mipi_device *device)\r\n{\r\nplatform_device_put(device->pdev);\r\nkfree(device);\r\n}\r\nstatic int tegra_mipi_wait(struct tegra_mipi *mipi)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(250);\r\nunsigned long value;\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = tegra_mipi_readl(mipi, MIPI_CAL_STATUS);\r\nif ((value & MIPI_CAL_STATUS_ACTIVE) == 0 &&\r\n(value & MIPI_CAL_STATUS_DONE) != 0)\r\nreturn 0;\r\nusleep_range(10, 50);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nint tegra_mipi_calibrate(struct tegra_mipi_device *device)\r\n{\r\nunsigned long value;\r\nunsigned int i;\r\nint err;\r\nerr = clk_enable(device->mipi->clk);\r\nif (err < 0)\r\nreturn err;\r\nmutex_lock(&device->mipi->lock);\r\nvalue = tegra_mipi_readl(device->mipi, MIPI_CAL_BIAS_PAD_CFG0);\r\nvalue &= ~MIPI_CAL_BIAS_PAD_PDVCLAMP;\r\nvalue |= MIPI_CAL_BIAS_PAD_E_VCLAMP_REF;\r\ntegra_mipi_writel(device->mipi, value, MIPI_CAL_BIAS_PAD_CFG0);\r\nvalue = tegra_mipi_readl(device->mipi, MIPI_CAL_BIAS_PAD_CFG2);\r\nvalue &= ~MIPI_CAL_BIAS_PAD_PDVREG;\r\ntegra_mipi_writel(device->mipi, value, MIPI_CAL_BIAS_PAD_CFG2);\r\nfor (i = 0; i < ARRAY_SIZE(modules); i++) {\r\nif (device->pads & BIT(i))\r\nvalue = MIPI_CAL_CONFIG_SELECT |\r\nMIPI_CAL_CONFIG_HSPDOS(0) |\r\nMIPI_CAL_CONFIG_HSPUOS(4) |\r\nMIPI_CAL_CONFIG_TERMOS(5);\r\nelse\r\nvalue = 0;\r\ntegra_mipi_writel(device->mipi, value, modules[i].reg);\r\n}\r\ntegra_mipi_writel(device->mipi, MIPI_CAL_CTRL_START, MIPI_CAL_CTRL);\r\nerr = tegra_mipi_wait(device->mipi);\r\nmutex_unlock(&device->mipi->lock);\r\nclk_disable(device->mipi->clk);\r\nreturn err;\r\n}\r\nstatic int tegra_mipi_probe(struct platform_device *pdev)\r\n{\r\nstruct tegra_mipi *mipi;\r\nstruct resource *res;\r\nint err;\r\nmipi = devm_kzalloc(&pdev->dev, sizeof(*mipi), GFP_KERNEL);\r\nif (!mipi)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmipi->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(mipi->regs))\r\nreturn PTR_ERR(mipi->regs);\r\nmutex_init(&mipi->lock);\r\nmipi->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(mipi->clk)) {\r\ndev_err(&pdev->dev, "failed to get clock\n");\r\nreturn PTR_ERR(mipi->clk);\r\n}\r\nerr = clk_prepare(mipi->clk);\r\nif (err < 0)\r\nreturn err;\r\nplatform_set_drvdata(pdev, mipi);\r\nreturn 0;\r\n}\r\nstatic int tegra_mipi_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_mipi *mipi = platform_get_drvdata(pdev);\r\nclk_unprepare(mipi->clk);\r\nreturn 0;\r\n}
