static void nft_byteorder_eval(const struct nft_expr *expr,\r\nstruct nft_data data[NFT_REG_MAX + 1],\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_byteorder *priv = nft_expr_priv(expr);\r\nstruct nft_data *src = &data[priv->sreg], *dst = &data[priv->dreg];\r\nunion { u32 u32; u16 u16; } *s, *d;\r\nunsigned int i;\r\ns = (void *)src->data;\r\nd = (void *)dst->data;\r\nswitch (priv->size) {\r\ncase 4:\r\nswitch (priv->op) {\r\ncase NFT_BYTEORDER_NTOH:\r\nfor (i = 0; i < priv->len / 4; i++)\r\nd[i].u32 = ntohl((__force __be32)s[i].u32);\r\nbreak;\r\ncase NFT_BYTEORDER_HTON:\r\nfor (i = 0; i < priv->len / 4; i++)\r\nd[i].u32 = (__force __u32)htonl(s[i].u32);\r\nbreak;\r\n}\r\nbreak;\r\ncase 2:\r\nswitch (priv->op) {\r\ncase NFT_BYTEORDER_NTOH:\r\nfor (i = 0; i < priv->len / 2; i++)\r\nd[i].u16 = ntohs((__force __be16)s[i].u16);\r\nbreak;\r\ncase NFT_BYTEORDER_HTON:\r\nfor (i = 0; i < priv->len / 2; i++)\r\nd[i].u16 = (__force __u16)htons(s[i].u16);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int nft_byteorder_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_byteorder *priv = nft_expr_priv(expr);\r\nint err;\r\nif (tb[NFTA_BYTEORDER_SREG] == NULL ||\r\ntb[NFTA_BYTEORDER_DREG] == NULL ||\r\ntb[NFTA_BYTEORDER_LEN] == NULL ||\r\ntb[NFTA_BYTEORDER_SIZE] == NULL ||\r\ntb[NFTA_BYTEORDER_OP] == NULL)\r\nreturn -EINVAL;\r\npriv->sreg = ntohl(nla_get_be32(tb[NFTA_BYTEORDER_SREG]));\r\nerr = nft_validate_input_register(priv->sreg);\r\nif (err < 0)\r\nreturn err;\r\npriv->dreg = ntohl(nla_get_be32(tb[NFTA_BYTEORDER_DREG]));\r\nerr = nft_validate_output_register(priv->dreg);\r\nif (err < 0)\r\nreturn err;\r\nerr = nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);\r\nif (err < 0)\r\nreturn err;\r\npriv->op = ntohl(nla_get_be32(tb[NFTA_BYTEORDER_OP]));\r\nswitch (priv->op) {\r\ncase NFT_BYTEORDER_NTOH:\r\ncase NFT_BYTEORDER_HTON:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npriv->len = ntohl(nla_get_be32(tb[NFTA_BYTEORDER_LEN]));\r\nif (priv->len == 0 || priv->len > FIELD_SIZEOF(struct nft_data, data))\r\nreturn -EINVAL;\r\npriv->size = ntohl(nla_get_be32(tb[NFTA_BYTEORDER_SIZE]));\r\nswitch (priv->size) {\r\ncase 2:\r\ncase 4:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nft_byteorder_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_byteorder *priv = nft_expr_priv(expr);\r\nif (nla_put_be32(skb, NFTA_BYTEORDER_SREG, htonl(priv->sreg)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_BYTEORDER_DREG, htonl(priv->dreg)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_BYTEORDER_OP, htonl(priv->op)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_BYTEORDER_LEN, htonl(priv->len)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_BYTEORDER_SIZE, htonl(priv->size)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nint __init nft_byteorder_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_byteorder_type);\r\n}\r\nvoid nft_byteorder_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_byteorder_type);\r\n}
