static void omap24xxcam_clock_put(struct omap24xxcam_device *cam)\r\n{\r\nif (cam->ick != NULL && !IS_ERR(cam->ick))\r\nclk_put(cam->ick);\r\nif (cam->fck != NULL && !IS_ERR(cam->fck))\r\nclk_put(cam->fck);\r\ncam->ick = cam->fck = NULL;\r\n}\r\nstatic int omap24xxcam_clock_get(struct omap24xxcam_device *cam)\r\n{\r\nint rval = 0;\r\ncam->fck = clk_get(cam->dev, "fck");\r\nif (IS_ERR(cam->fck)) {\r\ndev_err(cam->dev, "can't get camera fck");\r\nrval = PTR_ERR(cam->fck);\r\nomap24xxcam_clock_put(cam);\r\nreturn rval;\r\n}\r\ncam->ick = clk_get(cam->dev, "ick");\r\nif (IS_ERR(cam->ick)) {\r\ndev_err(cam->dev, "can't get camera ick");\r\nrval = PTR_ERR(cam->ick);\r\nomap24xxcam_clock_put(cam);\r\n}\r\nreturn rval;\r\n}\r\nstatic void omap24xxcam_clock_on(struct omap24xxcam_device *cam)\r\n{\r\nclk_enable(cam->fck);\r\nclk_enable(cam->ick);\r\n}\r\nstatic void omap24xxcam_clock_off(struct omap24xxcam_device *cam)\r\n{\r\nclk_disable(cam->fck);\r\nclk_disable(cam->ick);\r\n}\r\nstatic void omap24xxcam_core_xclk_set(const struct omap24xxcam_device *cam,\r\nu32 xclk)\r\n{\r\nif (xclk) {\r\nu32 divisor = CAM_MCLK / xclk;\r\nif (divisor == 1)\r\nomap24xxcam_reg_out(cam->mmio_base + CC_REG_OFFSET,\r\nCC_CTRL_XCLK,\r\nCC_CTRL_XCLK_DIV_BYPASS);\r\nelse\r\nomap24xxcam_reg_out(cam->mmio_base + CC_REG_OFFSET,\r\nCC_CTRL_XCLK, divisor);\r\n} else\r\nomap24xxcam_reg_out(cam->mmio_base + CC_REG_OFFSET,\r\nCC_CTRL_XCLK, CC_CTRL_XCLK_DIV_STABLE_LOW);\r\n}\r\nstatic void omap24xxcam_core_hwinit(const struct omap24xxcam_device *cam)\r\n{\r\nomap24xxcam_reg_out(cam->mmio_base + CC_REG_OFFSET, CC_SYSCONFIG,\r\nCC_SYSCONFIG_AUTOIDLE);\r\nomap24xxcam_reg_out(cam->mmio_base + CC_REG_OFFSET, CC_CTRL_DMA,\r\nCC_CTRL_DMA_EN | (DMA_THRESHOLD / 4 - 1));\r\nomap24xxcam_reg_out(cam->mmio_base + CC_REG_OFFSET, CC_IRQENABLE,\r\nCC_IRQENABLE_FW_ERR_IRQ\r\n| CC_IRQENABLE_FSC_ERR_IRQ\r\n| CC_IRQENABLE_SSC_ERR_IRQ\r\n| CC_IRQENABLE_FIFO_OF_IRQ);\r\n}\r\nstatic void omap24xxcam_core_enable(const struct omap24xxcam_device *cam)\r\n{\r\nomap24xxcam_reg_out(cam->mmio_base + CC_REG_OFFSET, CC_CTRL,\r\ncam->cc_ctrl);\r\n}\r\nstatic void omap24xxcam_core_disable(const struct omap24xxcam_device *cam)\r\n{\r\nomap24xxcam_reg_out(cam->mmio_base + CC_REG_OFFSET, CC_CTRL,\r\nCC_CTRL_CC_RST);\r\n}\r\nstatic void omap24xxcam_core_isr(struct omap24xxcam_device *cam)\r\n{\r\nu32 cc_irqstatus;\r\nconst u32 cc_irqstatus_err =\r\nCC_IRQSTATUS_FW_ERR_IRQ\r\n| CC_IRQSTATUS_FSC_ERR_IRQ\r\n| CC_IRQSTATUS_SSC_ERR_IRQ\r\n| CC_IRQSTATUS_FIFO_UF_IRQ\r\n| CC_IRQSTATUS_FIFO_OF_IRQ;\r\ncc_irqstatus = omap24xxcam_reg_in(cam->mmio_base + CC_REG_OFFSET,\r\nCC_IRQSTATUS);\r\nomap24xxcam_reg_out(cam->mmio_base + CC_REG_OFFSET, CC_IRQSTATUS,\r\ncc_irqstatus);\r\nif (cc_irqstatus & cc_irqstatus_err\r\n&& !atomic_read(&cam->in_reset)) {\r\ndev_dbg(cam->dev, "resetting camera, cc_irqstatus 0x%x\n",\r\ncc_irqstatus);\r\nomap24xxcam_reset(cam);\r\n}\r\n}\r\nstatic void omap24xxcam_vbq_free_mmap_buffer(struct videobuf_buffer *vb)\r\n{\r\nstruct videobuf_dmabuf *dma = videobuf_to_dma(vb);\r\nsize_t alloc_size;\r\nstruct page *page;\r\nint i;\r\nif (dma->sglist == NULL)\r\nreturn;\r\ni = dma->sglen;\r\nwhile (i) {\r\ni--;\r\nalloc_size = sg_dma_len(&dma->sglist[i]);\r\npage = sg_page(&dma->sglist[i]);\r\ndo {\r\nClearPageReserved(page++);\r\n} while (alloc_size -= PAGE_SIZE);\r\n__free_pages(sg_page(&dma->sglist[i]),\r\nget_order(sg_dma_len(&dma->sglist[i])));\r\n}\r\nkfree(dma->sglist);\r\ndma->sglist = NULL;\r\n}\r\nstatic void omap24xxcam_vbq_free_mmap_buffers(struct videobuf_queue *vbq)\r\n{\r\nint i;\r\nmutex_lock(&vbq->vb_lock);\r\nfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\r\nif (NULL == vbq->bufs[i])\r\ncontinue;\r\nif (V4L2_MEMORY_MMAP != vbq->bufs[i]->memory)\r\ncontinue;\r\nvbq->ops->buf_release(vbq, vbq->bufs[i]);\r\nomap24xxcam_vbq_free_mmap_buffer(vbq->bufs[i]);\r\nkfree(vbq->bufs[i]);\r\nvbq->bufs[i] = NULL;\r\n}\r\nmutex_unlock(&vbq->vb_lock);\r\nvideobuf_mmap_free(vbq);\r\n}\r\nstatic int omap24xxcam_vbq_alloc_mmap_buffer(struct videobuf_buffer *vb)\r\n{\r\nunsigned int order;\r\nsize_t alloc_size, size = vb->bsize;\r\nstruct page *page;\r\nint max_pages, err = 0, i = 0;\r\nstruct videobuf_dmabuf *dma = videobuf_to_dma(vb);\r\nmax_pages = vb->bsize >> PAGE_SHIFT;\r\ndma->sglist = kcalloc(max_pages, sizeof(*dma->sglist), GFP_KERNEL);\r\nif (dma->sglist == NULL) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nwhile (size) {\r\norder = get_order(size);\r\nif ((PAGE_SIZE << order) > size)\r\norder--;\r\npage = alloc_pages(GFP_KERNEL, order);\r\nwhile (page == NULL) {\r\norder--;\r\npage = alloc_pages(GFP_KERNEL, order);\r\nif (page == NULL && !order) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\nsize -= (PAGE_SIZE << order);\r\nsg_set_page(&dma->sglist[i], page, PAGE_SIZE << order, 0);\r\ndma->sglen++;\r\ni++;\r\nalloc_size = (PAGE_SIZE << order);\r\nmemset(page_address(page), 0, alloc_size);\r\ndo {\r\nSetPageReserved(page++);\r\n} while (alloc_size -= PAGE_SIZE);\r\n}\r\ndma->nr_pages = dma->sglen;\r\ndma->direction = PCI_DMA_FROMDEVICE;\r\nreturn 0;\r\nout:\r\nomap24xxcam_vbq_free_mmap_buffer(vb);\r\nreturn err;\r\n}\r\nstatic int omap24xxcam_vbq_alloc_mmap_buffers(struct videobuf_queue *vbq,\r\nunsigned int count)\r\n{\r\nint i, err = 0;\r\nstruct omap24xxcam_fh *fh =\r\ncontainer_of(vbq, struct omap24xxcam_fh, vbq);\r\nmutex_lock(&vbq->vb_lock);\r\nfor (i = 0; i < count; i++) {\r\nerr = omap24xxcam_vbq_alloc_mmap_buffer(vbq->bufs[i]);\r\nif (err)\r\ngoto out;\r\ndev_dbg(fh->cam->dev, "sglen is %d for buffer %d\n",\r\nvideobuf_to_dma(vbq->bufs[i])->sglen, i);\r\n}\r\nmutex_unlock(&vbq->vb_lock);\r\nreturn 0;\r\nout:\r\nwhile (i) {\r\ni--;\r\nomap24xxcam_vbq_free_mmap_buffer(vbq->bufs[i]);\r\n}\r\nmutex_unlock(&vbq->vb_lock);\r\nreturn err;\r\n}\r\nstatic void omap24xxcam_vbq_complete(struct omap24xxcam_sgdma *sgdma,\r\nu32 csr, void *arg)\r\n{\r\nstruct omap24xxcam_device *cam =\r\ncontainer_of(sgdma, struct omap24xxcam_device, sgdma);\r\nstruct omap24xxcam_fh *fh = cam->streaming->private_data;\r\nstruct videobuf_buffer *vb = (struct videobuf_buffer *)arg;\r\nconst u32 csr_error = CAMDMA_CSR_MISALIGNED_ERR\r\n| CAMDMA_CSR_SUPERVISOR_ERR | CAMDMA_CSR_SECURE_ERR\r\n| CAMDMA_CSR_TRANS_ERR | CAMDMA_CSR_DROP;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cam->core_enable_disable_lock, flags);\r\nif (--cam->sgdma_in_queue == 0)\r\nomap24xxcam_core_disable(cam);\r\nspin_unlock_irqrestore(&cam->core_enable_disable_lock, flags);\r\nv4l2_get_timestamp(&vb->ts);\r\nvb->field_count = atomic_add_return(2, &fh->field_count);\r\nif (csr & csr_error) {\r\nvb->state = VIDEOBUF_ERROR;\r\nif (!atomic_read(&fh->cam->in_reset)) {\r\ndev_dbg(cam->dev, "resetting camera, csr 0x%x\n", csr);\r\nomap24xxcam_reset(cam);\r\n}\r\n} else\r\nvb->state = VIDEOBUF_DONE;\r\nwake_up(&vb->done);\r\n}\r\nstatic void omap24xxcam_vbq_release(struct videobuf_queue *vbq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct videobuf_dmabuf *dma = videobuf_to_dma(vb);\r\nvideobuf_waiton(vbq, vb, 0, 0);\r\nif (vb->memory == V4L2_MEMORY_MMAP) {\r\ndma_unmap_sg(vbq->dev, dma->sglist, dma->sglen,\r\ndma->direction);\r\ndma->direction = DMA_NONE;\r\n} else {\r\nvideobuf_dma_unmap(vbq->dev, videobuf_to_dma(vb));\r\nvideobuf_dma_free(videobuf_to_dma(vb));\r\n}\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic int omap24xxcam_vbq_setup(struct videobuf_queue *vbq, unsigned int *cnt,\r\nunsigned int *size)\r\n{\r\nstruct omap24xxcam_fh *fh = vbq->priv_data;\r\nif (*cnt <= 0)\r\n*cnt = VIDEO_MAX_FRAME;\r\nif (*cnt > VIDEO_MAX_FRAME)\r\n*cnt = VIDEO_MAX_FRAME;\r\n*size = fh->pix.sizeimage;\r\nif (*size * *cnt > fh->cam->capture_mem)\r\n*cnt = fh->cam->capture_mem / *size;\r\nreturn 0;\r\n}\r\nstatic int omap24xxcam_dma_iolock(struct videobuf_queue *vbq,\r\nstruct videobuf_dmabuf *dma)\r\n{\r\nint err = 0;\r\ndma->direction = PCI_DMA_FROMDEVICE;\r\nif (!dma_map_sg(vbq->dev, dma->sglist, dma->sglen, dma->direction)) {\r\nkfree(dma->sglist);\r\ndma->sglist = NULL;\r\ndma->sglen = 0;\r\nerr = -EIO;\r\n}\r\nreturn err;\r\n}\r\nstatic int omap24xxcam_vbq_prepare(struct videobuf_queue *vbq,\r\nstruct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct omap24xxcam_fh *fh = vbq->priv_data;\r\nint err = 0;\r\nif (vb->baddr) {\r\nif (fh->pix.sizeimage > vb->bsize) {\r\nerr = -EINVAL;\r\n} else\r\nvb->size = fh->pix.sizeimage;\r\n} else {\r\nif (vb->state != VIDEOBUF_NEEDS_INIT) {\r\nif (fh->pix.sizeimage > vb->size) {\r\nomap24xxcam_vbq_release(vbq, vb);\r\nvb->size = fh->pix.sizeimage;\r\n}\r\n} else {\r\nvb->size = fh->pix.sizeimage;\r\n}\r\n}\r\nif (err)\r\nreturn err;\r\nvb->width = fh->pix.width;\r\nvb->height = fh->pix.height;\r\nvb->field = field;\r\nif (vb->state == VIDEOBUF_NEEDS_INIT) {\r\nif (vb->memory == V4L2_MEMORY_MMAP)\r\nerr = omap24xxcam_dma_iolock(vbq, videobuf_to_dma(vb));\r\nelse\r\nerr = videobuf_iolock(vbq, vb, NULL);\r\n}\r\nif (!err)\r\nvb->state = VIDEOBUF_PREPARED;\r\nelse\r\nomap24xxcam_vbq_release(vbq, vb);\r\nreturn err;\r\n}\r\nstatic void omap24xxcam_vbq_queue(struct videobuf_queue *vbq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct omap24xxcam_fh *fh = vbq->priv_data;\r\nstruct omap24xxcam_device *cam = fh->cam;\r\nenum videobuf_state state = vb->state;\r\nunsigned long flags;\r\nint err;\r\nvb->state = VIDEOBUF_ACTIVE;\r\nerr = omap24xxcam_sgdma_queue(&fh->cam->sgdma,\r\nvideobuf_to_dma(vb)->sglist,\r\nvideobuf_to_dma(vb)->sglen, vb->size,\r\nomap24xxcam_vbq_complete, vb);\r\nif (!err) {\r\nspin_lock_irqsave(&cam->core_enable_disable_lock, flags);\r\nif (++cam->sgdma_in_queue == 1\r\n&& !atomic_read(&cam->in_reset))\r\nomap24xxcam_core_enable(cam);\r\nspin_unlock_irqrestore(&cam->core_enable_disable_lock, flags);\r\n} else {\r\ndev_err(cam->dev, "failed to queue a video buffer for dma!\n");\r\ndev_err(cam->dev, "likely a bug in the driver!\n");\r\nvb->state = state;\r\n}\r\n}\r\nstatic void omap24xxcam_poweron_reset(struct omap24xxcam_device *cam)\r\n{\r\nint max_loop = RESET_TIMEOUT_NS;\r\nomap24xxcam_reg_out(cam->mmio_base,\r\nCAM_SYSCONFIG,\r\nCAM_SYSCONFIG_SOFTRESET);\r\nwhile (!(omap24xxcam_reg_in(cam->mmio_base, CAM_SYSSTATUS)\r\n& CAM_SYSSTATUS_RESETDONE)\r\n&& --max_loop) {\r\nndelay(1);\r\n}\r\nif (!(omap24xxcam_reg_in(cam->mmio_base, CAM_SYSSTATUS)\r\n& CAM_SYSSTATUS_RESETDONE))\r\ndev_err(cam->dev, "camera soft reset timeout\n");\r\n}\r\nstatic void omap24xxcam_hwinit(struct omap24xxcam_device *cam)\r\n{\r\nomap24xxcam_poweron_reset(cam);\r\nomap24xxcam_reg_out(cam->mmio_base, CAM_SYSCONFIG,\r\nCAM_SYSCONFIG_AUTOIDLE);\r\nomap24xxcam_reg_out(cam->mmio_base,\r\nCAMMMU_REG_OFFSET + CAMMMU_SYSCONFIG,\r\nCAMMMU_SYSCONFIG_AUTOIDLE);\r\nomap24xxcam_core_hwinit(cam);\r\nomap24xxcam_dma_hwinit(&cam->sgdma.dma);\r\n}\r\nstatic void omap24xxcam_stalled_dma_reset(unsigned long data)\r\n{\r\nstruct omap24xxcam_device *cam = (struct omap24xxcam_device *)data;\r\nif (!atomic_read(&cam->in_reset)) {\r\ndev_dbg(cam->dev, "dma stalled, resetting camera\n");\r\nomap24xxcam_reset(cam);\r\n}\r\n}\r\nstatic void omap24xxcam_capture_stop(struct omap24xxcam_device *cam)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cam->core_enable_disable_lock, flags);\r\nif (atomic_inc_return(&cam->in_reset) != 1) {\r\nspin_unlock_irqrestore(&cam->core_enable_disable_lock, flags);\r\nreturn;\r\n}\r\nomap24xxcam_core_disable(cam);\r\nspin_unlock_irqrestore(&cam->core_enable_disable_lock, flags);\r\nomap24xxcam_sgdma_sync(&cam->sgdma);\r\n}\r\nstatic void omap24xxcam_capture_cont(struct omap24xxcam_device *cam)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cam->core_enable_disable_lock, flags);\r\nif (atomic_read(&cam->in_reset) != 1)\r\ngoto out;\r\nomap24xxcam_hwinit(cam);\r\nomap24xxcam_sensor_if_enable(cam);\r\nomap24xxcam_sgdma_process(&cam->sgdma);\r\nif (cam->sgdma_in_queue)\r\nomap24xxcam_core_enable(cam);\r\nout:\r\natomic_dec(&cam->in_reset);\r\nspin_unlock_irqrestore(&cam->core_enable_disable_lock, flags);\r\n}\r\nstatic ssize_t\r\nomap24xxcam_streaming_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct omap24xxcam_device *cam = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", cam->streaming ? "active" : "inactive");\r\n}\r\nstatic void omap24xxcam_reset(struct omap24xxcam_device *cam)\r\n{\r\nomap24xxcam_capture_stop(cam);\r\nomap24xxcam_capture_cont(cam);\r\n}\r\nstatic irqreturn_t omap24xxcam_isr(int irq, void *arg)\r\n{\r\nstruct omap24xxcam_device *cam = (struct omap24xxcam_device *)arg;\r\nu32 irqstatus;\r\nunsigned int irqhandled = 0;\r\nirqstatus = omap24xxcam_reg_in(cam->mmio_base, CAM_IRQSTATUS);\r\nif (irqstatus &\r\n(CAM_IRQSTATUS_DMA_IRQ2 | CAM_IRQSTATUS_DMA_IRQ1\r\n| CAM_IRQSTATUS_DMA_IRQ0)) {\r\nomap24xxcam_dma_isr(&cam->sgdma.dma);\r\nirqhandled = 1;\r\n}\r\nif (irqstatus & CAM_IRQSTATUS_CC_IRQ) {\r\nomap24xxcam_core_isr(cam);\r\nirqhandled = 1;\r\n}\r\nif (irqstatus & CAM_IRQSTATUS_MMU_IRQ)\r\ndev_err(cam->dev, "unhandled camera MMU interrupt!\n");\r\nreturn IRQ_RETVAL(irqhandled);\r\n}\r\nstatic int omap24xxcam_sensor_if_enable(struct omap24xxcam_device *cam)\r\n{\r\nint rval;\r\nstruct v4l2_ifparm p;\r\nrval = vidioc_int_g_ifparm(cam->sdev, &p);\r\nif (rval) {\r\ndev_err(cam->dev, "vidioc_int_g_ifparm failed with %d\n", rval);\r\nreturn rval;\r\n}\r\ncam->if_type = p.if_type;\r\ncam->cc_ctrl = CC_CTRL_CC_EN;\r\nswitch (p.if_type) {\r\ncase V4L2_IF_TYPE_BT656:\r\nif (p.u.bt656.frame_start_on_rising_vs)\r\ncam->cc_ctrl |= CC_CTRL_NOBT_SYNCHRO;\r\nif (p.u.bt656.bt_sync_correct)\r\ncam->cc_ctrl |= CC_CTRL_BT_CORRECT;\r\nif (p.u.bt656.swap)\r\ncam->cc_ctrl |= CC_CTRL_PAR_ORDERCAM;\r\nif (p.u.bt656.latch_clk_inv)\r\ncam->cc_ctrl |= CC_CTRL_PAR_CLK_POL;\r\nif (p.u.bt656.nobt_hs_inv)\r\ncam->cc_ctrl |= CC_CTRL_NOBT_HS_POL;\r\nif (p.u.bt656.nobt_vs_inv)\r\ncam->cc_ctrl |= CC_CTRL_NOBT_VS_POL;\r\nswitch (p.u.bt656.mode) {\r\ncase V4L2_IF_TYPE_BT656_MODE_NOBT_8BIT:\r\ncam->cc_ctrl |= CC_CTRL_PAR_MODE_NOBT8;\r\nbreak;\r\ncase V4L2_IF_TYPE_BT656_MODE_NOBT_10BIT:\r\ncam->cc_ctrl |= CC_CTRL_PAR_MODE_NOBT10;\r\nbreak;\r\ncase V4L2_IF_TYPE_BT656_MODE_NOBT_12BIT:\r\ncam->cc_ctrl |= CC_CTRL_PAR_MODE_NOBT12;\r\nbreak;\r\ncase V4L2_IF_TYPE_BT656_MODE_BT_8BIT:\r\ncam->cc_ctrl |= CC_CTRL_PAR_MODE_BT8;\r\nbreak;\r\ncase V4L2_IF_TYPE_BT656_MODE_BT_10BIT:\r\ncam->cc_ctrl |= CC_CTRL_PAR_MODE_BT10;\r\nbreak;\r\ndefault:\r\ndev_err(cam->dev,\r\n"bt656 interface mode %d not supported\n",\r\np.u.bt656.mode);\r\nreturn -EINVAL;\r\n}\r\nif (p.u.bt656.clock_curr != cam->if_u.bt656.xclk) {\r\nu32 xclk = p.u.bt656.clock_curr;\r\nu32 divisor;\r\nif (xclk == 0)\r\nreturn -EINVAL;\r\nif (xclk > CAM_MCLK)\r\nxclk = CAM_MCLK;\r\ndivisor = CAM_MCLK / xclk;\r\nif (divisor * xclk < CAM_MCLK)\r\ndivisor++;\r\nif (CAM_MCLK / divisor < p.u.bt656.clock_min\r\n&& divisor > 1)\r\ndivisor--;\r\nif (divisor > 30)\r\ndivisor = 30;\r\nxclk = CAM_MCLK / divisor;\r\nif (xclk < p.u.bt656.clock_min\r\n|| xclk > p.u.bt656.clock_max)\r\nreturn -EINVAL;\r\ncam->if_u.bt656.xclk = xclk;\r\n}\r\nomap24xxcam_core_xclk_set(cam, cam->if_u.bt656.xclk);\r\nbreak;\r\ndefault:\r\ndev_err(cam->dev, "interface type %d not supported\n",\r\np.if_type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap24xxcam_sensor_if_disable(const struct omap24xxcam_device *cam)\r\n{\r\nswitch (cam->if_type) {\r\ncase V4L2_IF_TYPE_BT656:\r\nomap24xxcam_core_xclk_set(cam, 0);\r\nbreak;\r\n}\r\n}\r\nstatic int omap24xxcam_sensor_init(struct omap24xxcam_device *cam)\r\n{\r\nint err = 0;\r\nstruct v4l2_int_device *sdev = cam->sdev;\r\nomap24xxcam_clock_on(cam);\r\nerr = omap24xxcam_sensor_if_enable(cam);\r\nif (err) {\r\ndev_err(cam->dev, "sensor interface could not be enabled at "\r\n"initialisation, %d\n", err);\r\ncam->sdev = NULL;\r\ngoto out;\r\n}\r\nvidioc_int_s_power(sdev, 1);\r\nerr = vidioc_int_dev_init(sdev);\r\nif (err) {\r\ndev_err(cam->dev, "cannot initialize sensor, error %d\n", err);\r\ncam->sdev = NULL;\r\ngoto out;\r\n}\r\ndev_info(cam->dev, "sensor is %s\n", sdev->name);\r\nout:\r\nomap24xxcam_sensor_if_disable(cam);\r\nomap24xxcam_clock_off(cam);\r\nvidioc_int_s_power(sdev, 0);\r\nreturn err;\r\n}\r\nstatic void omap24xxcam_sensor_exit(struct omap24xxcam_device *cam)\r\n{\r\nif (cam->sdev)\r\nvidioc_int_dev_exit(cam->sdev);\r\n}\r\nstatic void omap24xxcam_sensor_disable(struct omap24xxcam_device *cam)\r\n{\r\nomap24xxcam_sensor_if_disable(cam);\r\nomap24xxcam_clock_off(cam);\r\nvidioc_int_s_power(cam->sdev, 0);\r\n}\r\nstatic int omap24xxcam_sensor_enable(struct omap24xxcam_device *cam)\r\n{\r\nint rval;\r\nomap24xxcam_clock_on(cam);\r\nomap24xxcam_sensor_if_enable(cam);\r\nrval = vidioc_int_s_power(cam->sdev, 1);\r\nif (rval)\r\ngoto out;\r\nrval = vidioc_int_init(cam->sdev);\r\nif (rval)\r\ngoto out;\r\nreturn 0;\r\nout:\r\nomap24xxcam_sensor_disable(cam);\r\nreturn rval;\r\n}\r\nstatic void omap24xxcam_sensor_reset_work(struct work_struct *work)\r\n{\r\nstruct omap24xxcam_device *cam =\r\ncontainer_of(work, struct omap24xxcam_device,\r\nsensor_reset_work);\r\nif (atomic_read(&cam->reset_disable))\r\nreturn;\r\nomap24xxcam_capture_stop(cam);\r\nif (vidioc_int_reset(cam->sdev) == 0) {\r\nvidioc_int_init(cam->sdev);\r\n} else {\r\nomap24xxcam_sensor_disable(cam);\r\nomap24xxcam_sensor_enable(cam);\r\n}\r\nomap24xxcam_capture_cont(cam);\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *fh,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct omap24xxcam_fh *ofh = fh;\r\nstruct omap24xxcam_device *cam = ofh->cam;\r\nstrlcpy(cap->driver, CAM_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, cam->vfd->name, sizeof(cap->card));\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *fh,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct omap24xxcam_fh *ofh = fh;\r\nstruct omap24xxcam_device *cam = ofh->cam;\r\nint rval;\r\nrval = vidioc_int_enum_fmt_cap(cam->sdev, f);\r\nreturn rval;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct omap24xxcam_fh *ofh = fh;\r\nstruct omap24xxcam_device *cam = ofh->cam;\r\nint rval;\r\nmutex_lock(&cam->mutex);\r\nrval = vidioc_int_g_fmt_cap(cam->sdev, f);\r\nmutex_unlock(&cam->mutex);\r\nreturn rval;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct omap24xxcam_fh *ofh = fh;\r\nstruct omap24xxcam_device *cam = ofh->cam;\r\nint rval;\r\nmutex_lock(&cam->mutex);\r\nif (cam->streaming) {\r\nrval = -EBUSY;\r\ngoto out;\r\n}\r\nrval = vidioc_int_s_fmt_cap(cam->sdev, f);\r\nout:\r\nmutex_unlock(&cam->mutex);\r\nif (!rval) {\r\nmutex_lock(&ofh->vbq.vb_lock);\r\nofh->pix = f->fmt.pix;\r\nmutex_unlock(&ofh->vbq.vb_lock);\r\n}\r\nmemset(f, 0, sizeof(*f));\r\nvidioc_g_fmt_vid_cap(file, fh, f);\r\nreturn rval;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct omap24xxcam_fh *ofh = fh;\r\nstruct omap24xxcam_device *cam = ofh->cam;\r\nint rval;\r\nmutex_lock(&cam->mutex);\r\nrval = vidioc_int_try_fmt_cap(cam->sdev, f);\r\nmutex_unlock(&cam->mutex);\r\nreturn rval;\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *fh,\r\nstruct v4l2_requestbuffers *b)\r\n{\r\nstruct omap24xxcam_fh *ofh = fh;\r\nstruct omap24xxcam_device *cam = ofh->cam;\r\nint rval;\r\nmutex_lock(&cam->mutex);\r\nif (cam->streaming) {\r\nmutex_unlock(&cam->mutex);\r\nreturn -EBUSY;\r\n}\r\nomap24xxcam_vbq_free_mmap_buffers(&ofh->vbq);\r\nmutex_unlock(&cam->mutex);\r\nrval = videobuf_reqbufs(&ofh->vbq, b);\r\nif (rval < 0 || b->memory != V4L2_MEMORY_MMAP)\r\ngoto out;\r\nrval = omap24xxcam_vbq_alloc_mmap_buffers(&ofh->vbq, rval);\r\nif (rval)\r\nomap24xxcam_vbq_free_mmap_buffers(&ofh->vbq);\r\nout:\r\nreturn rval;\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *fh,\r\nstruct v4l2_buffer *b)\r\n{\r\nstruct omap24xxcam_fh *ofh = fh;\r\nreturn videobuf_querybuf(&ofh->vbq, b);\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *fh, struct v4l2_buffer *b)\r\n{\r\nstruct omap24xxcam_fh *ofh = fh;\r\nreturn videobuf_qbuf(&ofh->vbq, b);\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *fh, struct v4l2_buffer *b)\r\n{\r\nstruct omap24xxcam_fh *ofh = fh;\r\nstruct omap24xxcam_device *cam = ofh->cam;\r\nstruct videobuf_buffer *vb;\r\nint rval;\r\nvideobuf_dqbuf_again:\r\nrval = videobuf_dqbuf(&ofh->vbq, b, file->f_flags & O_NONBLOCK);\r\nif (rval)\r\ngoto out;\r\nvb = ofh->vbq.bufs[b->index];\r\nmutex_lock(&cam->mutex);\r\nrval = vidioc_int_g_needs_reset(cam->sdev, (void *)vb->baddr);\r\nmutex_unlock(&cam->mutex);\r\nif (rval == -EIO)\r\nschedule_work(&cam->sensor_reset_work);\r\nelse\r\nrval = 0;\r\nout:\r\nif (rval == -EIO) {\r\nvideobuf_qbuf(&ofh->vbq, b);\r\nif (!(file->f_flags & O_NONBLOCK))\r\ngoto videobuf_dqbuf_again;\r\nrval = -EAGAIN;\r\n}\r\nreturn rval;\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type i)\r\n{\r\nstruct omap24xxcam_fh *ofh = fh;\r\nstruct omap24xxcam_device *cam = ofh->cam;\r\nint rval;\r\nmutex_lock(&cam->mutex);\r\nif (cam->streaming) {\r\nrval = -EBUSY;\r\ngoto out;\r\n}\r\nrval = omap24xxcam_sensor_if_enable(cam);\r\nif (rval) {\r\ndev_dbg(cam->dev, "vidioc_int_g_ifparm failed\n");\r\ngoto out;\r\n}\r\nrval = videobuf_streamon(&ofh->vbq);\r\nif (!rval) {\r\ncam->streaming = file;\r\nsysfs_notify(&cam->dev->kobj, NULL, "streaming");\r\n}\r\nout:\r\nmutex_unlock(&cam->mutex);\r\nreturn rval;\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *fh, enum v4l2_buf_type i)\r\n{\r\nstruct omap24xxcam_fh *ofh = fh;\r\nstruct omap24xxcam_device *cam = ofh->cam;\r\nstruct videobuf_queue *q = &ofh->vbq;\r\nint rval;\r\natomic_inc(&cam->reset_disable);\r\nflush_work(&cam->sensor_reset_work);\r\nrval = videobuf_streamoff(q);\r\nif (!rval) {\r\nmutex_lock(&cam->mutex);\r\ncam->streaming = NULL;\r\nmutex_unlock(&cam->mutex);\r\nsysfs_notify(&cam->dev->kobj, NULL, "streaming");\r\n}\r\natomic_dec(&cam->reset_disable);\r\nreturn rval;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *fh,\r\nstruct v4l2_input *inp)\r\n{\r\nif (inp->index > 0)\r\nreturn -EINVAL;\r\nstrlcpy(inp->name, "camera", sizeof(inp->name));\r\ninp->type = V4L2_INPUT_TYPE_CAMERA;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *fh, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *fh, unsigned int i)\r\n{\r\nif (i > 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *fh,\r\nstruct v4l2_queryctrl *a)\r\n{\r\nstruct omap24xxcam_fh *ofh = fh;\r\nstruct omap24xxcam_device *cam = ofh->cam;\r\nint rval;\r\nrval = vidioc_int_queryctrl(cam->sdev, a);\r\nreturn rval;\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *fh,\r\nstruct v4l2_control *a)\r\n{\r\nstruct omap24xxcam_fh *ofh = fh;\r\nstruct omap24xxcam_device *cam = ofh->cam;\r\nint rval;\r\nmutex_lock(&cam->mutex);\r\nrval = vidioc_int_g_ctrl(cam->sdev, a);\r\nmutex_unlock(&cam->mutex);\r\nreturn rval;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *fh,\r\nstruct v4l2_control *a)\r\n{\r\nstruct omap24xxcam_fh *ofh = fh;\r\nstruct omap24xxcam_device *cam = ofh->cam;\r\nint rval;\r\nmutex_lock(&cam->mutex);\r\nrval = vidioc_int_s_ctrl(cam->sdev, a);\r\nmutex_unlock(&cam->mutex);\r\nreturn rval;\r\n}\r\nstatic int vidioc_g_parm(struct file *file, void *fh,\r\nstruct v4l2_streamparm *a) {\r\nstruct omap24xxcam_fh *ofh = fh;\r\nstruct omap24xxcam_device *cam = ofh->cam;\r\nint rval;\r\nmutex_lock(&cam->mutex);\r\nrval = vidioc_int_g_parm(cam->sdev, a);\r\nmutex_unlock(&cam->mutex);\r\nreturn rval;\r\n}\r\nstatic int vidioc_s_parm(struct file *file, void *fh,\r\nstruct v4l2_streamparm *a)\r\n{\r\nstruct omap24xxcam_fh *ofh = fh;\r\nstruct omap24xxcam_device *cam = ofh->cam;\r\nstruct v4l2_streamparm old_streamparm;\r\nint rval;\r\nmutex_lock(&cam->mutex);\r\nif (cam->streaming) {\r\nrval = -EBUSY;\r\ngoto out;\r\n}\r\nold_streamparm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nrval = vidioc_int_g_parm(cam->sdev, &old_streamparm);\r\nif (rval)\r\ngoto out;\r\nrval = vidioc_int_s_parm(cam->sdev, a);\r\nif (rval)\r\ngoto out;\r\nrval = omap24xxcam_sensor_if_enable(cam);\r\nif (rval)\r\nvidioc_int_s_parm(cam->sdev, &old_streamparm);\r\nout:\r\nmutex_unlock(&cam->mutex);\r\nreturn rval;\r\n}\r\nstatic unsigned int omap24xxcam_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct omap24xxcam_fh *fh = file->private_data;\r\nstruct omap24xxcam_device *cam = fh->cam;\r\nstruct videobuf_buffer *vb;\r\nmutex_lock(&cam->mutex);\r\nif (cam->streaming != file) {\r\nmutex_unlock(&cam->mutex);\r\nreturn POLLERR;\r\n}\r\nmutex_unlock(&cam->mutex);\r\nmutex_lock(&fh->vbq.vb_lock);\r\nif (list_empty(&fh->vbq.stream)) {\r\nmutex_unlock(&fh->vbq.vb_lock);\r\nreturn POLLERR;\r\n}\r\nvb = list_entry(fh->vbq.stream.next, struct videobuf_buffer, stream);\r\nmutex_unlock(&fh->vbq.vb_lock);\r\npoll_wait(file, &vb->done, wait);\r\nif (vb->state == VIDEOBUF_DONE || vb->state == VIDEOBUF_ERROR)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int omap24xxcam_mmap_buffers(struct file *file,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct omap24xxcam_fh *fh = file->private_data;\r\nstruct omap24xxcam_device *cam = fh->cam;\r\nstruct videobuf_queue *vbq = &fh->vbq;\r\nunsigned int first, last, size, i, j;\r\nint err = 0;\r\nmutex_lock(&cam->mutex);\r\nif (cam->streaming) {\r\nmutex_unlock(&cam->mutex);\r\nreturn -EBUSY;\r\n}\r\nmutex_unlock(&cam->mutex);\r\nmutex_lock(&vbq->vb_lock);\r\nfor (first = 0; first < VIDEO_MAX_FRAME; first++) {\r\nif (NULL == vbq->bufs[first])\r\ncontinue;\r\nif (V4L2_MEMORY_MMAP != vbq->bufs[first]->memory)\r\ncontinue;\r\nif (vbq->bufs[first]->boff == (vma->vm_pgoff << PAGE_SHIFT))\r\nbreak;\r\n}\r\nfor (size = 0, last = first; last < VIDEO_MAX_FRAME; last++) {\r\nif (NULL == vbq->bufs[last])\r\ncontinue;\r\nif (V4L2_MEMORY_MMAP != vbq->bufs[last]->memory)\r\ncontinue;\r\nsize += vbq->bufs[last]->bsize;\r\nif (size == (vma->vm_end - vma->vm_start))\r\nbreak;\r\n}\r\nsize = 0;\r\nfor (i = first; i <= last && i < VIDEO_MAX_FRAME; i++) {\r\nstruct videobuf_dmabuf *dma = videobuf_to_dma(vbq->bufs[i]);\r\nfor (j = 0; j < dma->sglen; j++) {\r\nerr = remap_pfn_range(\r\nvma, vma->vm_start + size,\r\npage_to_pfn(sg_page(&dma->sglist[j])),\r\nsg_dma_len(&dma->sglist[j]), vma->vm_page_prot);\r\nif (err)\r\ngoto out;\r\nsize += sg_dma_len(&dma->sglist[j]);\r\n}\r\n}\r\nout:\r\nmutex_unlock(&vbq->vb_lock);\r\nreturn err;\r\n}\r\nstatic int omap24xxcam_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct omap24xxcam_fh *fh = file->private_data;\r\nint rval;\r\nrval = videobuf_mmap_mapper(&fh->vbq, vma);\r\nif (rval)\r\nreturn rval;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nrval = omap24xxcam_mmap_buffers(file, vma);\r\nif (rval)\r\nkfree(vma->vm_private_data);\r\nreturn rval;\r\n}\r\nstatic int omap24xxcam_open(struct file *file)\r\n{\r\nstruct omap24xxcam_device *cam = omap24xxcam.priv;\r\nstruct omap24xxcam_fh *fh;\r\nstruct v4l2_format format;\r\nif (!cam || !cam->vfd)\r\nreturn -ENODEV;\r\nfh = kzalloc(sizeof(*fh), GFP_KERNEL);\r\nif (fh == NULL)\r\nreturn -ENOMEM;\r\nmutex_lock(&cam->mutex);\r\nif (cam->sdev == NULL || !try_module_get(cam->sdev->module)) {\r\nmutex_unlock(&cam->mutex);\r\ngoto out_try_module_get;\r\n}\r\nif (atomic_inc_return(&cam->users) == 1) {\r\nomap24xxcam_hwinit(cam);\r\nif (omap24xxcam_sensor_enable(cam)) {\r\nmutex_unlock(&cam->mutex);\r\ngoto out_omap24xxcam_sensor_enable;\r\n}\r\n}\r\nmutex_unlock(&cam->mutex);\r\nfh->cam = cam;\r\nmutex_lock(&cam->mutex);\r\nvidioc_int_g_fmt_cap(cam->sdev, &format);\r\nmutex_unlock(&cam->mutex);\r\nfh->pix = format.fmt.pix;\r\nfile->private_data = fh;\r\nspin_lock_init(&fh->vbq_lock);\r\nvideobuf_queue_sg_init(&fh->vbq, &omap24xxcam_vbq_ops, NULL,\r\n&fh->vbq_lock, V4L2_BUF_TYPE_VIDEO_CAPTURE,\r\nV4L2_FIELD_NONE,\r\nsizeof(struct videobuf_buffer), fh, NULL);\r\nreturn 0;\r\nout_omap24xxcam_sensor_enable:\r\nomap24xxcam_poweron_reset(cam);\r\nmodule_put(cam->sdev->module);\r\nout_try_module_get:\r\nkfree(fh);\r\nreturn -ENODEV;\r\n}\r\nstatic int omap24xxcam_release(struct file *file)\r\n{\r\nstruct omap24xxcam_fh *fh = file->private_data;\r\nstruct omap24xxcam_device *cam = fh->cam;\r\natomic_inc(&cam->reset_disable);\r\nflush_work(&cam->sensor_reset_work);\r\nvideobuf_streamoff(&fh->vbq);\r\nmutex_lock(&cam->mutex);\r\nif (cam->streaming == file) {\r\ncam->streaming = NULL;\r\nmutex_unlock(&cam->mutex);\r\nsysfs_notify(&cam->dev->kobj, NULL, "streaming");\r\n} else {\r\nmutex_unlock(&cam->mutex);\r\n}\r\natomic_dec(&cam->reset_disable);\r\nomap24xxcam_vbq_free_mmap_buffers(&fh->vbq);\r\nflush_work(&cam->sensor_reset_work);\r\nmutex_lock(&cam->mutex);\r\nif (atomic_dec_return(&cam->users) == 0) {\r\nomap24xxcam_sensor_disable(cam);\r\nomap24xxcam_poweron_reset(cam);\r\n}\r\nmutex_unlock(&cam->mutex);\r\nfile->private_data = NULL;\r\nmodule_put(cam->sdev->module);\r\nkfree(fh);\r\nreturn 0;\r\n}\r\nstatic int omap24xxcam_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct omap24xxcam_device *cam = platform_get_drvdata(pdev);\r\nif (atomic_read(&cam->users) == 0)\r\nreturn 0;\r\nif (!atomic_read(&cam->reset_disable))\r\nomap24xxcam_capture_stop(cam);\r\nomap24xxcam_sensor_disable(cam);\r\nomap24xxcam_poweron_reset(cam);\r\nreturn 0;\r\n}\r\nstatic int omap24xxcam_resume(struct platform_device *pdev)\r\n{\r\nstruct omap24xxcam_device *cam = platform_get_drvdata(pdev);\r\nif (atomic_read(&cam->users) == 0)\r\nreturn 0;\r\nomap24xxcam_hwinit(cam);\r\nomap24xxcam_sensor_enable(cam);\r\nif (!atomic_read(&cam->reset_disable))\r\nomap24xxcam_capture_cont(cam);\r\nreturn 0;\r\n}\r\nstatic int omap24xxcam_device_register(struct v4l2_int_device *s)\r\n{\r\nstruct omap24xxcam_device *cam = s->u.slave->master->priv;\r\nstruct video_device *vfd;\r\nint rval;\r\nif (cam->sdev)\r\nreturn -EBUSY;\r\ncam->sdev = s;\r\nif (device_create_file(cam->dev, &dev_attr_streaming) != 0) {\r\ndev_err(cam->dev, "could not register sysfs entry\n");\r\nrval = -EBUSY;\r\ngoto err;\r\n}\r\nvfd = cam->vfd = video_device_alloc();\r\nif (!vfd) {\r\ndev_err(cam->dev, "could not allocate video device struct\n");\r\nrval = -ENOMEM;\r\ngoto err;\r\n}\r\nvfd->release = video_device_release;\r\nvfd->v4l2_dev = &cam->v4l2_dev;\r\nstrlcpy(vfd->name, CAM_NAME, sizeof(vfd->name));\r\nvfd->fops = &omap24xxcam_fops;\r\nvfd->ioctl_ops = &omap24xxcam_ioctl_fops;\r\nomap24xxcam_hwinit(cam);\r\nrval = omap24xxcam_sensor_init(cam);\r\nif (rval)\r\ngoto err;\r\nif (video_register_device(vfd, VFL_TYPE_GRABBER, video_nr) < 0) {\r\ndev_err(cam->dev, "could not register V4L device\n");\r\nrval = -EBUSY;\r\ngoto err;\r\n}\r\nomap24xxcam_poweron_reset(cam);\r\ndev_info(cam->dev, "registered device %s\n",\r\nvideo_device_node_name(vfd));\r\nreturn 0;\r\nerr:\r\nomap24xxcam_device_unregister(s);\r\nreturn rval;\r\n}\r\nstatic void omap24xxcam_device_unregister(struct v4l2_int_device *s)\r\n{\r\nstruct omap24xxcam_device *cam = s->u.slave->master->priv;\r\nomap24xxcam_sensor_exit(cam);\r\nif (cam->vfd) {\r\nif (!video_is_registered(cam->vfd)) {\r\nvideo_device_release(cam->vfd);\r\n} else {\r\nvideo_unregister_device(cam->vfd);\r\n}\r\ncam->vfd = NULL;\r\n}\r\ndevice_remove_file(cam->dev, &dev_attr_streaming);\r\ncam->sdev = NULL;\r\n}\r\nstatic int omap24xxcam_probe(struct platform_device *pdev)\r\n{\r\nstruct omap24xxcam_device *cam;\r\nstruct resource *mem;\r\nint irq;\r\ncam = kzalloc(sizeof(*cam), GFP_KERNEL);\r\nif (!cam) {\r\ndev_err(&pdev->dev, "could not allocate memory\n");\r\ngoto err;\r\n}\r\nplatform_set_drvdata(pdev, cam);\r\ncam->dev = &pdev->dev;\r\nif (v4l2_device_register(&pdev->dev, &cam->v4l2_dev)) {\r\ndev_err(&pdev->dev, "v4l2_device_register failed\n");\r\ngoto err;\r\n}\r\nif (capture_mem < 320 * 240 * 2 * 2)\r\ncapture_mem = 320 * 240 * 2 * 2;\r\ncam->capture_mem = capture_mem;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(cam->dev, "no mem resource?\n");\r\ngoto err;\r\n}\r\nif (!request_mem_region(mem->start, resource_size(mem), pdev->name)) {\r\ndev_err(cam->dev,\r\n"cannot reserve camera register I/O region\n");\r\ngoto err;\r\n}\r\ncam->mmio_base_phys = mem->start;\r\ncam->mmio_size = resource_size(mem);\r\ncam->mmio_base = ioremap_nocache(cam->mmio_base_phys, cam->mmio_size);\r\nif (!cam->mmio_base) {\r\ndev_err(cam->dev, "cannot map camera register I/O region\n");\r\ngoto err;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0) {\r\ndev_err(cam->dev, "no irq for camera?\n");\r\ngoto err;\r\n}\r\nif (request_irq(irq, omap24xxcam_isr, 0, CAM_NAME, cam)) {\r\ndev_err(cam->dev,\r\n"could not install interrupt service routine\n");\r\ngoto err;\r\n}\r\ncam->irq = irq;\r\nif (omap24xxcam_clock_get(cam))\r\ngoto err;\r\nINIT_WORK(&cam->sensor_reset_work, omap24xxcam_sensor_reset_work);\r\nmutex_init(&cam->mutex);\r\nspin_lock_init(&cam->core_enable_disable_lock);\r\nomap24xxcam_sgdma_init(&cam->sgdma,\r\ncam->mmio_base + CAMDMA_REG_OFFSET,\r\nomap24xxcam_stalled_dma_reset,\r\n(unsigned long)cam);\r\nomap24xxcam.priv = cam;\r\nif (v4l2_int_device_register(&omap24xxcam))\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nomap24xxcam_remove(pdev);\r\nreturn -ENODEV;\r\n}\r\nstatic int omap24xxcam_remove(struct platform_device *pdev)\r\n{\r\nstruct omap24xxcam_device *cam = platform_get_drvdata(pdev);\r\nif (!cam)\r\nreturn 0;\r\nif (omap24xxcam.priv != NULL)\r\nv4l2_int_device_unregister(&omap24xxcam);\r\nomap24xxcam.priv = NULL;\r\nomap24xxcam_clock_put(cam);\r\nif (cam->irq) {\r\nfree_irq(cam->irq, cam);\r\ncam->irq = 0;\r\n}\r\nif (cam->mmio_base) {\r\niounmap((void *)cam->mmio_base);\r\ncam->mmio_base = 0;\r\n}\r\nif (cam->mmio_base_phys) {\r\nrelease_mem_region(cam->mmio_base_phys, cam->mmio_size);\r\ncam->mmio_base_phys = 0;\r\n}\r\nv4l2_device_unregister(&cam->v4l2_dev);\r\nkfree(cam);\r\nreturn 0;\r\n}
