static int stmmac_mdio_busy_wait(void __iomem *ioaddr, unsigned int mii_addr)\r\n{\r\nunsigned long curr;\r\nunsigned long finish = jiffies + 3 * HZ;\r\ndo {\r\ncurr = jiffies;\r\nif (readl(ioaddr + mii_addr) & MII_BUSY)\r\ncpu_relax();\r\nelse\r\nreturn 0;\r\n} while (!time_after_eq(curr, finish));\r\nreturn -EBUSY;\r\n}\r\nstatic int stmmac_mdio_read(struct mii_bus *bus, int phyaddr, int phyreg)\r\n{\r\nstruct net_device *ndev = bus->priv;\r\nstruct stmmac_priv *priv = netdev_priv(ndev);\r\nunsigned int mii_address = priv->hw->mii.addr;\r\nunsigned int mii_data = priv->hw->mii.data;\r\nint data;\r\nu16 regValue = (((phyaddr << 11) & (0x0000F800)) |\r\n((phyreg << 6) & (0x000007C0)));\r\nregValue |= MII_BUSY | ((priv->clk_csr & 0xF) << 2);\r\nif (stmmac_mdio_busy_wait(priv->ioaddr, mii_address))\r\nreturn -EBUSY;\r\nwritel(regValue, priv->ioaddr + mii_address);\r\nif (stmmac_mdio_busy_wait(priv->ioaddr, mii_address))\r\nreturn -EBUSY;\r\ndata = (int)readl(priv->ioaddr + mii_data);\r\nreturn data;\r\n}\r\nstatic int stmmac_mdio_write(struct mii_bus *bus, int phyaddr, int phyreg,\r\nu16 phydata)\r\n{\r\nstruct net_device *ndev = bus->priv;\r\nstruct stmmac_priv *priv = netdev_priv(ndev);\r\nunsigned int mii_address = priv->hw->mii.addr;\r\nunsigned int mii_data = priv->hw->mii.data;\r\nu16 value =\r\n(((phyaddr << 11) & (0x0000F800)) | ((phyreg << 6) & (0x000007C0)))\r\n| MII_WRITE;\r\nvalue |= MII_BUSY | ((priv->clk_csr & 0xF) << 2);\r\nif (stmmac_mdio_busy_wait(priv->ioaddr, mii_address))\r\nreturn -EBUSY;\r\nwritel(phydata, priv->ioaddr + mii_data);\r\nwritel(value, priv->ioaddr + mii_address);\r\nreturn stmmac_mdio_busy_wait(priv->ioaddr, mii_address);\r\n}\r\nint stmmac_mdio_reset(struct mii_bus *bus)\r\n{\r\n#if defined(CONFIG_STMMAC_PLATFORM)\r\nstruct net_device *ndev = bus->priv;\r\nstruct stmmac_priv *priv = netdev_priv(ndev);\r\nunsigned int mii_address = priv->hw->mii.addr;\r\nstruct stmmac_mdio_bus_data *data = priv->plat->mdio_bus_data;\r\n#ifdef CONFIG_OF\r\nif (priv->device->of_node) {\r\nint reset_gpio, active_low;\r\nif (data->reset_gpio < 0) {\r\nstruct device_node *np = priv->device->of_node;\r\nif (!np)\r\nreturn 0;\r\ndata->reset_gpio = of_get_named_gpio(np,\r\n"snps,reset-gpio", 0);\r\nif (data->reset_gpio < 0)\r\nreturn 0;\r\ndata->active_low = of_property_read_bool(np,\r\n"snps,reset-active-low");\r\nof_property_read_u32_array(np,\r\n"snps,reset-delays-us", data->delays, 3);\r\n}\r\nreset_gpio = data->reset_gpio;\r\nactive_low = data->active_low;\r\nif (!gpio_request(reset_gpio, "mdio-reset")) {\r\ngpio_direction_output(reset_gpio, active_low ? 1 : 0);\r\nudelay(data->delays[0]);\r\ngpio_set_value(reset_gpio, active_low ? 0 : 1);\r\nudelay(data->delays[1]);\r\ngpio_set_value(reset_gpio, active_low ? 1 : 0);\r\nudelay(data->delays[2]);\r\n}\r\n}\r\n#endif\r\nif (data->phy_reset) {\r\npr_debug("stmmac_mdio_reset: calling phy_reset\n");\r\ndata->phy_reset(priv->plat->bsp_priv);\r\n}\r\nwritel(0, priv->ioaddr + mii_address);\r\n#endif\r\nreturn 0;\r\n}\r\nint stmmac_mdio_register(struct net_device *ndev)\r\n{\r\nint err = 0;\r\nstruct mii_bus *new_bus;\r\nint *irqlist;\r\nstruct stmmac_priv *priv = netdev_priv(ndev);\r\nstruct stmmac_mdio_bus_data *mdio_bus_data = priv->plat->mdio_bus_data;\r\nint addr, found;\r\nif (!mdio_bus_data)\r\nreturn 0;\r\nnew_bus = mdiobus_alloc();\r\nif (new_bus == NULL)\r\nreturn -ENOMEM;\r\nif (mdio_bus_data->irqs) {\r\nirqlist = mdio_bus_data->irqs;\r\n} else {\r\nfor (addr = 0; addr < PHY_MAX_ADDR; addr++)\r\npriv->mii_irq[addr] = PHY_POLL;\r\nirqlist = priv->mii_irq;\r\n}\r\n#ifdef CONFIG_OF\r\nif (priv->device->of_node)\r\nmdio_bus_data->reset_gpio = -1;\r\n#endif\r\nnew_bus->name = "stmmac";\r\nnew_bus->read = &stmmac_mdio_read;\r\nnew_bus->write = &stmmac_mdio_write;\r\nnew_bus->reset = &stmmac_mdio_reset;\r\nsnprintf(new_bus->id, MII_BUS_ID_SIZE, "%s-%x",\r\nnew_bus->name, priv->plat->bus_id);\r\nnew_bus->priv = ndev;\r\nnew_bus->irq = irqlist;\r\nnew_bus->phy_mask = mdio_bus_data->phy_mask;\r\nnew_bus->parent = priv->device;\r\nerr = mdiobus_register(new_bus);\r\nif (err != 0) {\r\npr_err("%s: Cannot register as MDIO bus\n", new_bus->name);\r\ngoto bus_register_fail;\r\n}\r\nfound = 0;\r\nfor (addr = 0; addr < PHY_MAX_ADDR; addr++) {\r\nstruct phy_device *phydev = new_bus->phy_map[addr];\r\nif (phydev) {\r\nint act = 0;\r\nchar irq_num[4];\r\nchar *irq_str;\r\nif ((mdio_bus_data->irqs == NULL) &&\r\n(mdio_bus_data->probed_phy_irq > 0)) {\r\nirqlist[addr] = mdio_bus_data->probed_phy_irq;\r\nphydev->irq = mdio_bus_data->probed_phy_irq;\r\n}\r\nif (priv->plat->phy_addr == -1)\r\npriv->plat->phy_addr = addr;\r\nact = (priv->plat->phy_addr == addr);\r\nswitch (phydev->irq) {\r\ncase PHY_POLL:\r\nirq_str = "POLL";\r\nbreak;\r\ncase PHY_IGNORE_INTERRUPT:\r\nirq_str = "IGNORE";\r\nbreak;\r\ndefault:\r\nsprintf(irq_num, "%d", phydev->irq);\r\nirq_str = irq_num;\r\nbreak;\r\n}\r\npr_info("%s: PHY ID %08x at %d IRQ %s (%s)%s\n",\r\nndev->name, phydev->phy_id, addr,\r\nirq_str, dev_name(&phydev->dev),\r\nact ? " active" : "");\r\nfound = 1;\r\n}\r\n}\r\nif (!found) {\r\npr_warning("%s: No PHY found\n", ndev->name);\r\nmdiobus_unregister(new_bus);\r\nmdiobus_free(new_bus);\r\nreturn -ENODEV;\r\n}\r\npriv->mii = new_bus;\r\nreturn 0;\r\nbus_register_fail:\r\nmdiobus_free(new_bus);\r\nreturn err;\r\n}\r\nint stmmac_mdio_unregister(struct net_device *ndev)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(ndev);\r\nif (!priv->mii)\r\nreturn 0;\r\nmdiobus_unregister(priv->mii);\r\npriv->mii->priv = NULL;\r\nmdiobus_free(priv->mii);\r\npriv->mii = NULL;\r\nreturn 0;\r\n}
