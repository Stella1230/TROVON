static void usage(void)\r\n{\r\nfprintf(stderr, "Usage: kallsyms [--all-symbols] "\r\n"[--symbol-prefix=<prefix char>] "\r\n"[--page-offset=<CONFIG_PAGE_OFFSET>] "\r\n"< in.map > out.S\n");\r\nexit(1);\r\n}\r\nstatic inline int is_arm_mapping_symbol(const char *str)\r\n{\r\nreturn str[0] == '$' && strchr("atd", str[1])\r\n&& (str[2] == '\0' || str[2] == '.');\r\n}\r\nstatic int check_symbol_range(const char *sym, unsigned long long addr,\r\nstruct addr_range *ranges, int entries)\r\n{\r\nsize_t i;\r\nstruct addr_range *ar;\r\nfor (i = 0; i < entries; ++i) {\r\nar = &ranges[i];\r\nif (strcmp(sym, ar->start_sym) == 0) {\r\nar->start = addr;\r\nreturn 0;\r\n} else if (strcmp(sym, ar->end_sym) == 0) {\r\nar->end = addr;\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int read_symbol(FILE *in, struct sym_entry *s)\r\n{\r\nchar str[500];\r\nchar *sym, stype;\r\nint rc;\r\nrc = fscanf(in, "%llx %c %499s\n", &s->addr, &stype, str);\r\nif (rc != 3) {\r\nif (rc != EOF && fgets(str, 500, in) == NULL)\r\nfprintf(stderr, "Read error or end of file.\n");\r\nreturn -1;\r\n}\r\nif (strlen(str) > KSYM_NAME_LEN) {\r\nfprintf(stderr, "Symbol %s too long for kallsyms (%zu vs %d).\n"\r\n"Please increase KSYM_NAME_LEN both in kernel and kallsyms.c\n",\r\nstr, strlen(str), KSYM_NAME_LEN);\r\nreturn -1;\r\n}\r\nsym = str;\r\nif (symbol_prefix_char && str[0] == symbol_prefix_char)\r\nsym++;\r\nif (strcmp(sym, "_text") == 0)\r\n_text = s->addr;\r\nelse if (check_symbol_range(sym, s->addr, text_ranges,\r\nARRAY_SIZE(text_ranges)) == 0)\r\n;\r\nelse if (toupper(stype) == 'A')\r\n{\r\nif (strcmp(sym, "__kernel_syscall_via_break") &&\r\nstrcmp(sym, "__kernel_syscall_via_epc") &&\r\nstrcmp(sym, "__kernel_sigtramp") &&\r\nstrcmp(sym, "__gp"))\r\nreturn -1;\r\n}\r\nelse if (toupper(stype) == 'U' ||\r\nis_arm_mapping_symbol(sym))\r\nreturn -1;\r\nelse if (str[0] == '$')\r\nreturn -1;\r\nelse if (stype == 'N')\r\nreturn -1;\r\ns->len = strlen(str) + 1;\r\ns->sym = malloc(s->len + 1);\r\nif (!s->sym) {\r\nfprintf(stderr, "kallsyms failure: "\r\n"unable to allocate required amount of memory\n");\r\nexit(EXIT_FAILURE);\r\n}\r\nstrcpy((char *)s->sym + 1, str);\r\ns->sym[0] = stype;\r\ncheck_symbol_range(sym, s->addr, &percpu_range, 1);\r\nreturn 0;\r\n}\r\nstatic int symbol_in_range(struct sym_entry *s, struct addr_range *ranges,\r\nint entries)\r\n{\r\nsize_t i;\r\nstruct addr_range *ar;\r\nfor (i = 0; i < entries; ++i) {\r\nar = &ranges[i];\r\nif (s->addr >= ar->start && s->addr <= ar->end)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int symbol_valid(struct sym_entry *s)\r\n{\r\nstatic char *special_symbols[] = {\r\n"kallsyms_addresses",\r\n"kallsyms_num_syms",\r\n"kallsyms_names",\r\n"kallsyms_markers",\r\n"kallsyms_token_table",\r\n"kallsyms_token_index",\r\n"_SDA_BASE_",\r\n"_SDA2_BASE_",\r\nNULL };\r\nint i;\r\nint offset = 1;\r\nif (s->addr < kernel_start_addr)\r\nreturn 0;\r\nif (symbol_prefix_char && *(s->sym + 1) == symbol_prefix_char)\r\noffset++;\r\nif (!all_symbols) {\r\nif (symbol_in_range(s, text_ranges,\r\nARRAY_SIZE(text_ranges)) == 0)\r\nreturn 0;\r\nif ((s->addr == text_range_text->end &&\r\nstrcmp((char *)s->sym + offset,\r\ntext_range_text->end_sym)) ||\r\n(s->addr == text_range_inittext->end &&\r\nstrcmp((char *)s->sym + offset,\r\ntext_range_inittext->end_sym)))\r\nreturn 0;\r\n}\r\nif (strstr((char *)s->sym + offset, "_compiled."))\r\nreturn 0;\r\nfor (i = 0; special_symbols[i]; i++)\r\nif( strcmp((char *)s->sym + offset, special_symbols[i]) == 0 )\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void read_map(FILE *in)\r\n{\r\nwhile (!feof(in)) {\r\nif (table_cnt >= table_size) {\r\ntable_size += 10000;\r\ntable = realloc(table, sizeof(*table) * table_size);\r\nif (!table) {\r\nfprintf(stderr, "out of memory\n");\r\nexit (1);\r\n}\r\n}\r\nif (read_symbol(in, &table[table_cnt]) == 0) {\r\ntable[table_cnt].start_pos = table_cnt;\r\ntable_cnt++;\r\n}\r\n}\r\n}\r\nstatic void output_label(char *label)\r\n{\r\nif (symbol_prefix_char)\r\nprintf(".globl %c%s\n", symbol_prefix_char, label);\r\nelse\r\nprintf(".globl %s\n", label);\r\nprintf("\tALGN\n");\r\nif (symbol_prefix_char)\r\nprintf("%c%s:\n", symbol_prefix_char, label);\r\nelse\r\nprintf("%s:\n", label);\r\n}\r\nstatic int expand_symbol(unsigned char *data, int len, char *result)\r\n{\r\nint c, rlen, total=0;\r\nwhile (len) {\r\nc = *data;\r\nif (best_table[c][0]==c && best_table_len[c]==1) {\r\n*result++ = c;\r\ntotal++;\r\n} else {\r\nrlen = expand_symbol(best_table[c], best_table_len[c], result);\r\ntotal += rlen;\r\nresult += rlen;\r\n}\r\ndata++;\r\nlen--;\r\n}\r\n*result=0;\r\nreturn total;\r\n}\r\nstatic int symbol_absolute(struct sym_entry *s)\r\n{\r\nreturn toupper(s->sym[0]) == 'A';\r\n}\r\nstatic void write_src(void)\r\n{\r\nunsigned int i, k, off;\r\nunsigned int best_idx[256];\r\nunsigned int *markers;\r\nchar buf[KSYM_NAME_LEN];\r\nprintf("#include <asm/types.h>\n");\r\nprintf("#if BITS_PER_LONG == 64\n");\r\nprintf("#define PTR .quad\n");\r\nprintf("#define ALGN .align 8\n");\r\nprintf("#else\n");\r\nprintf("#define PTR .long\n");\r\nprintf("#define ALGN .align 4\n");\r\nprintf("#endif\n");\r\nprintf("\t.section .rodata, \"a\"\n");\r\noutput_label("kallsyms_addresses");\r\nfor (i = 0; i < table_cnt; i++) {\r\nif (!symbol_absolute(&table[i])) {\r\nif (_text <= table[i].addr)\r\nprintf("\tPTR\t_text + %#llx\n",\r\ntable[i].addr - _text);\r\nelse\r\nprintf("\tPTR\t_text - %#llx\n",\r\n_text - table[i].addr);\r\n} else {\r\nprintf("\tPTR\t%#llx\n", table[i].addr);\r\n}\r\n}\r\nprintf("\n");\r\noutput_label("kallsyms_num_syms");\r\nprintf("\tPTR\t%d\n", table_cnt);\r\nprintf("\n");\r\nmarkers = malloc(sizeof(unsigned int) * ((table_cnt + 255) / 256));\r\nif (!markers) {\r\nfprintf(stderr, "kallsyms failure: "\r\n"unable to allocate required memory\n");\r\nexit(EXIT_FAILURE);\r\n}\r\noutput_label("kallsyms_names");\r\noff = 0;\r\nfor (i = 0; i < table_cnt; i++) {\r\nif ((i & 0xFF) == 0)\r\nmarkers[i >> 8] = off;\r\nprintf("\t.byte 0x%02x", table[i].len);\r\nfor (k = 0; k < table[i].len; k++)\r\nprintf(", 0x%02x", table[i].sym[k]);\r\nprintf("\n");\r\noff += table[i].len + 1;\r\n}\r\nprintf("\n");\r\noutput_label("kallsyms_markers");\r\nfor (i = 0; i < ((table_cnt + 255) >> 8); i++)\r\nprintf("\tPTR\t%d\n", markers[i]);\r\nprintf("\n");\r\nfree(markers);\r\noutput_label("kallsyms_token_table");\r\noff = 0;\r\nfor (i = 0; i < 256; i++) {\r\nbest_idx[i] = off;\r\nexpand_symbol(best_table[i], best_table_len[i], buf);\r\nprintf("\t.asciz\t\"%s\"\n", buf);\r\noff += strlen(buf) + 1;\r\n}\r\nprintf("\n");\r\noutput_label("kallsyms_token_index");\r\nfor (i = 0; i < 256; i++)\r\nprintf("\t.short\t%d\n", best_idx[i]);\r\nprintf("\n");\r\n}\r\nstatic void learn_symbol(unsigned char *symbol, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len - 1; i++)\r\ntoken_profit[ symbol[i] + (symbol[i + 1] << 8) ]++;\r\n}\r\nstatic void forget_symbol(unsigned char *symbol, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len - 1; i++)\r\ntoken_profit[ symbol[i] + (symbol[i + 1] << 8) ]--;\r\n}\r\nstatic void build_initial_tok_table(void)\r\n{\r\nunsigned int i, pos;\r\npos = 0;\r\nfor (i = 0; i < table_cnt; i++) {\r\nif ( symbol_valid(&table[i]) ) {\r\nif (pos != i)\r\ntable[pos] = table[i];\r\nlearn_symbol(table[pos].sym, table[pos].len);\r\npos++;\r\n}\r\n}\r\ntable_cnt = pos;\r\n}\r\nstatic void *find_token(unsigned char *str, int len, unsigned char *token)\r\n{\r\nint i;\r\nfor (i = 0; i < len - 1; i++) {\r\nif (str[i] == token[0] && str[i+1] == token[1])\r\nreturn &str[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic void compress_symbols(unsigned char *str, int idx)\r\n{\r\nunsigned int i, len, size;\r\nunsigned char *p1, *p2;\r\nfor (i = 0; i < table_cnt; i++) {\r\nlen = table[i].len;\r\np1 = table[i].sym;\r\np2 = find_token(p1, len, str);\r\nif (!p2) continue;\r\nforget_symbol(table[i].sym, len);\r\nsize = len;\r\ndo {\r\n*p2 = idx;\r\np2++;\r\nsize -= (p2 - p1);\r\nmemmove(p2, p2 + 1, size);\r\np1 = p2;\r\nlen--;\r\nif (size < 2) break;\r\np2 = find_token(p1, size, str);\r\n} while (p2);\r\ntable[i].len = len;\r\nlearn_symbol(table[i].sym, len);\r\n}\r\n}\r\nstatic int find_best_token(void)\r\n{\r\nint i, best, bestprofit;\r\nbestprofit=-10000;\r\nbest = 0;\r\nfor (i = 0; i < 0x10000; i++) {\r\nif (token_profit[i] > bestprofit) {\r\nbest = i;\r\nbestprofit = token_profit[i];\r\n}\r\n}\r\nreturn best;\r\n}\r\nstatic void optimize_result(void)\r\n{\r\nint i, best;\r\nfor (i = 255; i >= 0; i--) {\r\nif (!best_table_len[i]) {\r\nbest = find_best_token();\r\nif (token_profit[best] == 0)\r\nbreak;\r\nbest_table_len[i] = 2;\r\nbest_table[i][0] = best & 0xFF;\r\nbest_table[i][1] = (best >> 8) & 0xFF;\r\ncompress_symbols(best_table[i], i);\r\n}\r\n}\r\n}\r\nstatic void insert_real_symbols_in_table(void)\r\n{\r\nunsigned int i, j, c;\r\nmemset(best_table, 0, sizeof(best_table));\r\nmemset(best_table_len, 0, sizeof(best_table_len));\r\nfor (i = 0; i < table_cnt; i++) {\r\nfor (j = 0; j < table[i].len; j++) {\r\nc = table[i].sym[j];\r\nbest_table[c][0]=c;\r\nbest_table_len[c]=1;\r\n}\r\n}\r\n}\r\nstatic void optimize_token_table(void)\r\n{\r\nbuild_initial_tok_table();\r\ninsert_real_symbols_in_table();\r\nif (!table_cnt) {\r\nfprintf(stderr, "No valid symbol.\n");\r\nexit(1);\r\n}\r\noptimize_result();\r\n}\r\nstatic int may_be_linker_script_provide_symbol(const struct sym_entry *se)\r\n{\r\nconst char *symbol = (char *)se->sym + 1;\r\nint len = se->len - 1;\r\nif (len < 8)\r\nreturn 0;\r\nif (symbol[0] != '_' || symbol[1] != '_')\r\nreturn 0;\r\nif (!memcmp(symbol + 2, "start_", 6))\r\nreturn 1;\r\nif (!memcmp(symbol + 2, "stop_", 5))\r\nreturn 1;\r\nif (!memcmp(symbol + 2, "end_", 4))\r\nreturn 1;\r\nif (!memcmp(symbol + len - 6, "_start", 6))\r\nreturn 1;\r\nif (!memcmp(symbol + len - 4, "_end", 4))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int prefix_underscores_count(const char *str)\r\n{\r\nconst char *tail = str;\r\nwhile (*tail == '_')\r\ntail++;\r\nreturn tail - str;\r\n}\r\nstatic int compare_symbols(const void *a, const void *b)\r\n{\r\nconst struct sym_entry *sa;\r\nconst struct sym_entry *sb;\r\nint wa, wb;\r\nsa = a;\r\nsb = b;\r\nif (sa->addr > sb->addr)\r\nreturn 1;\r\nif (sa->addr < sb->addr)\r\nreturn -1;\r\nwa = (sa->sym[0] == 'w') || (sa->sym[0] == 'W');\r\nwb = (sb->sym[0] == 'w') || (sb->sym[0] == 'W');\r\nif (wa != wb)\r\nreturn wa - wb;\r\nwa = may_be_linker_script_provide_symbol(sa);\r\nwb = may_be_linker_script_provide_symbol(sb);\r\nif (wa != wb)\r\nreturn wa - wb;\r\nwa = prefix_underscores_count((const char *)sa->sym + 1);\r\nwb = prefix_underscores_count((const char *)sb->sym + 1);\r\nif (wa != wb)\r\nreturn wa - wb;\r\nreturn sa->start_pos - sb->start_pos;\r\n}\r\nstatic void sort_symbols(void)\r\n{\r\nqsort(table, table_cnt, sizeof(struct sym_entry), compare_symbols);\r\n}\r\nstatic void make_percpus_absolute(void)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < table_cnt; i++)\r\nif (symbol_in_range(&table[i], &percpu_range, 1))\r\ntable[i].sym[0] = 'A';\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nif (argc >= 2) {\r\nint i;\r\nfor (i = 1; i < argc; i++) {\r\nif(strcmp(argv[i], "--all-symbols") == 0)\r\nall_symbols = 1;\r\nelse if (strcmp(argv[i], "--absolute-percpu") == 0)\r\nabsolute_percpu = 1;\r\nelse if (strncmp(argv[i], "--symbol-prefix=", 16) == 0) {\r\nchar *p = &argv[i][16];\r\nif ((*p == '"' && *(p+2) == '"') || (*p == '\'' && *(p+2) == '\''))\r\np++;\r\nsymbol_prefix_char = *p;\r\n} else if (strncmp(argv[i], "--page-offset=", 14) == 0) {\r\nconst char *p = &argv[i][14];\r\nkernel_start_addr = strtoull(p, NULL, 16);\r\n} else\r\nusage();\r\n}\r\n} else if (argc != 1)\r\nusage();\r\nread_map(stdin);\r\nif (absolute_percpu)\r\nmake_percpus_absolute();\r\nsort_symbols();\r\noptimize_token_table();\r\nwrite_src();\r\nreturn 0;\r\n}
