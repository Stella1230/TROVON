static void __hdmi_write8(struct sh_hdmi *hdmi, u8 data, u8 reg)\r\n{\r\niowrite8(data, hdmi->base + reg);\r\n}\r\nstatic u8 __hdmi_read8(struct sh_hdmi *hdmi, u8 reg)\r\n{\r\nreturn ioread8(hdmi->base + reg);\r\n}\r\nstatic void __hdmi_write32(struct sh_hdmi *hdmi, u8 data, u8 reg)\r\n{\r\niowrite32((u32)data, hdmi->base + (reg * 4));\r\nudelay(100);\r\n}\r\nstatic u8 __hdmi_read32(struct sh_hdmi *hdmi, u8 reg)\r\n{\r\nreturn (u8)ioread32(hdmi->base + (reg * 4));\r\n}\r\nstatic void hdmi_write(struct sh_hdmi *hdmi, u8 data, u8 reg)\r\n{\r\nhdmi->write(hdmi, data, reg);\r\n}\r\nstatic u8 hdmi_read(struct sh_hdmi *hdmi, u8 reg)\r\n{\r\nreturn hdmi->read(hdmi, reg);\r\n}\r\nstatic void hdmi_bit_set(struct sh_hdmi *hdmi, u8 mask, u8 data, u8 reg)\r\n{\r\nu8 val = hdmi_read(hdmi, reg);\r\nval &= ~mask;\r\nval |= (data & mask);\r\nhdmi_write(hdmi, val, reg);\r\n}\r\nstatic void hdmi_htop1_write(struct sh_hdmi *hdmi, u32 data, u32 reg)\r\n{\r\niowrite32(data, hdmi->htop1 + reg);\r\nudelay(100);\r\n}\r\nstatic u32 hdmi_htop1_read(struct sh_hdmi *hdmi, u32 reg)\r\n{\r\nreturn ioread32(hdmi->htop1 + reg);\r\n}\r\nstatic unsigned int sh_hdmi_snd_read(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nstruct sh_hdmi *hdmi = snd_soc_codec_get_drvdata(codec);\r\nreturn hdmi_read(hdmi, reg);\r\n}\r\nstatic int sh_hdmi_snd_write(struct snd_soc_codec *codec,\r\nunsigned int reg,\r\nunsigned int value)\r\n{\r\nstruct sh_hdmi *hdmi = snd_soc_codec_get_drvdata(codec);\r\nhdmi_write(hdmi, value, reg);\r\nreturn 0;\r\n}\r\nstatic int sh_hdmi_snd_probe(struct snd_soc_codec *codec)\r\n{\r\ndev_info(codec->dev, "SH Mobile HDMI Audio Codec");\r\nreturn 0;\r\n}\r\nstatic void sh_hdmi_external_video_param(struct sh_hdmi *hdmi)\r\n{\r\nstruct fb_videomode *mode = &hdmi->mode;\r\nu16 htotal, hblank, hdelay, vtotal, vblank, vdelay, voffset;\r\nu8 sync = 0;\r\nhtotal = mode->xres + mode->right_margin + mode->left_margin\r\n+ mode->hsync_len;\r\nhdelay = mode->hsync_len + mode->left_margin;\r\nhblank = mode->right_margin + hdelay;\r\nvtotal = mode->yres + mode->upper_margin + mode->lower_margin\r\n+ mode->vsync_len;\r\nvdelay = mode->vsync_len + mode->upper_margin;\r\nvblank = mode->lower_margin + vdelay;\r\nvoffset = min(mode->upper_margin / 2, 6U);\r\nif (mode->sync & FB_SYNC_HOR_HIGH_ACT)\r\nsync |= 4;\r\nif (mode->sync & FB_SYNC_VERT_HIGH_ACT)\r\nsync |= 8;\r\ndev_dbg(hdmi->dev, "H: %u, %u, %u, %u; V: %u, %u, %u, %u; sync 0x%x\n",\r\nhtotal, hblank, hdelay, mode->hsync_len,\r\nvtotal, vblank, vdelay, mode->vsync_len, sync);\r\nhdmi_write(hdmi, sync | (voffset << 4), HDMI_EXTERNAL_VIDEO_PARAM_SETTINGS);\r\nhdmi_write(hdmi, htotal, HDMI_EXTERNAL_H_TOTAL_7_0);\r\nhdmi_write(hdmi, htotal >> 8, HDMI_EXTERNAL_H_TOTAL_11_8);\r\nhdmi_write(hdmi, hblank, HDMI_EXTERNAL_H_BLANK_7_0);\r\nhdmi_write(hdmi, hblank >> 8, HDMI_EXTERNAL_H_BLANK_9_8);\r\nhdmi_write(hdmi, hdelay, HDMI_EXTERNAL_H_DELAY_7_0);\r\nhdmi_write(hdmi, hdelay >> 8, HDMI_EXTERNAL_H_DELAY_9_8);\r\nhdmi_write(hdmi, mode->hsync_len, HDMI_EXTERNAL_H_DURATION_7_0);\r\nhdmi_write(hdmi, mode->hsync_len >> 8, HDMI_EXTERNAL_H_DURATION_9_8);\r\nhdmi_write(hdmi, vtotal, HDMI_EXTERNAL_V_TOTAL_7_0);\r\nhdmi_write(hdmi, vtotal >> 8, HDMI_EXTERNAL_V_TOTAL_9_8);\r\nhdmi_write(hdmi, vblank, HDMI_EXTERNAL_V_BLANK);\r\nhdmi_write(hdmi, vdelay, HDMI_EXTERNAL_V_DELAY);\r\nhdmi_write(hdmi, mode->vsync_len, HDMI_EXTERNAL_V_DURATION);\r\nif (!hdmi->preprogrammed_vic)\r\nhdmi_write(hdmi, sync | 1 | (voffset << 4),\r\nHDMI_EXTERNAL_VIDEO_PARAM_SETTINGS);\r\n}\r\nstatic void sh_hdmi_video_config(struct sh_hdmi *hdmi)\r\n{\r\nhdmi_write(hdmi, 0x20, HDMI_AUDIO_VIDEO_SETTING_1);\r\nhdmi_write(hdmi, 0x34, HDMI_VIDEO_SETTING_1);\r\nhdmi_write(hdmi, 0x20, HDMI_DEEP_COLOR_MODES);\r\n}\r\nstatic void sh_hdmi_audio_config(struct sh_hdmi *hdmi)\r\n{\r\nu8 data;\r\nstruct sh_mobile_hdmi_info *pdata = dev_get_platdata(hdmi->dev);\r\nhdmi_write(hdmi, 0x00, HDMI_L_R_DATA_SWAP_CTRL_RPKT);\r\nhdmi_write(hdmi, 0x18, HDMI_20_BIT_N_FOR_AUDIO_RPKT_15_8);\r\nhdmi_write(hdmi, 0x00, HDMI_20_BIT_N_FOR_AUDIO_RPKT_7_0);\r\nhdmi_write(hdmi, 0x20, HDMI_SPDIF_AUDIO_SAMP_FREQ_CTS);\r\nswitch (pdata->flags & HDMI_SND_SRC_MASK) {\r\ndefault:\r\ncase HDMI_SND_SRC_I2S:\r\ndata = 0x0 << 3;\r\nbreak;\r\ncase HDMI_SND_SRC_SPDIF:\r\ndata = 0x1 << 3;\r\nbreak;\r\ncase HDMI_SND_SRC_DSD:\r\ndata = 0x2 << 3;\r\nbreak;\r\ncase HDMI_SND_SRC_HBR:\r\ndata = 0x3 << 3;\r\nbreak;\r\n}\r\nhdmi_write(hdmi, data, HDMI_AUDIO_SETTING_1);\r\nhdmi_write(hdmi, 0x40, HDMI_AUDIO_SETTING_2);\r\nhdmi_write(hdmi, 0x04, HDMI_I2S_AUDIO_SET);\r\nhdmi_write(hdmi, 0x00, HDMI_DSD_AUDIO_SET);\r\nhdmi_write(hdmi, 0x00, HDMI_I2S_INPUT_PIN_SWAP);\r\nhdmi_write(hdmi, 0x00, HDMI_AUDIO_STATUS_BITS_SETTING_1);\r\nhdmi_write(hdmi, 0x00, HDMI_AUDIO_STATUS_BITS_SETTING_2);\r\nhdmi_write(hdmi, 0x00, HDMI_CATEGORY_CODE);\r\nhdmi_write(hdmi, 0x00, HDMI_SOURCE_NUM_AUDIO_WORD_LEN);\r\nhdmi_write(hdmi, 0x20, HDMI_AUDIO_VIDEO_SETTING_1);\r\n}\r\nstatic void sh_hdmi_phy_config(struct sh_hdmi *hdmi)\r\n{\r\nif (hdmi->mode.pixclock < 10000) {\r\nhdmi_write(hdmi, 0x1d, HDMI_SLIPHDMIT_PARAM_SETTINGS_1);\r\nhdmi_write(hdmi, 0x00, HDMI_SLIPHDMIT_PARAM_SETTINGS_2);\r\nhdmi_write(hdmi, 0x00, HDMI_SLIPHDMIT_PARAM_SETTINGS_3);\r\nhdmi_write(hdmi, 0x4c, HDMI_SLIPHDMIT_PARAM_SETTINGS_5);\r\nhdmi_write(hdmi, 0x1e, HDMI_SLIPHDMIT_PARAM_SETTINGS_6);\r\nhdmi_write(hdmi, 0x48, HDMI_SLIPHDMIT_PARAM_SETTINGS_7);\r\nhdmi_write(hdmi, 0x0e, HDMI_SLIPHDMIT_PARAM_SETTINGS_8);\r\nhdmi_write(hdmi, 0x25, HDMI_SLIPHDMIT_PARAM_SETTINGS_9);\r\nhdmi_write(hdmi, 0x04, HDMI_SLIPHDMIT_PARAM_SETTINGS_10);\r\n} else if (hdmi->mode.pixclock < 30000) {\r\nhdmi_write(hdmi, 0x0f, HDMI_SLIPHDMIT_PARAM_SETTINGS_1);\r\nhdmi_write(hdmi, 0x00, HDMI_SLIPHDMIT_PARAM_SETTINGS_2);\r\nhdmi_write(hdmi, 0x00, HDMI_SLIPHDMIT_PARAM_SETTINGS_3);\r\nhdmi_write(hdmi, 0x44, HDMI_SLIPHDMIT_PARAM_SETTINGS_5);\r\nhdmi_write(hdmi, 0x32, HDMI_SLIPHDMIT_PARAM_SETTINGS_6);\r\nhdmi_write(hdmi, 0x4A, HDMI_SLIPHDMIT_PARAM_SETTINGS_7);\r\nhdmi_write(hdmi, 0x00, HDMI_SLIPHDMIT_PARAM_SETTINGS_8);\r\nhdmi_write(hdmi, 0x25, HDMI_SLIPHDMIT_PARAM_SETTINGS_9);\r\nhdmi_write(hdmi, 0x04, HDMI_SLIPHDMIT_PARAM_SETTINGS_10);\r\n} else {\r\nhdmi_write(hdmi, 0x19, HDMI_SLIPHDMIT_PARAM_SETTINGS_1);\r\nhdmi_write(hdmi, 0x00, HDMI_SLIPHDMIT_PARAM_SETTINGS_2);\r\nhdmi_write(hdmi, 0x00, HDMI_SLIPHDMIT_PARAM_SETTINGS_3);\r\nhdmi_write(hdmi, 0x44, HDMI_SLIPHDMIT_PARAM_SETTINGS_5);\r\nhdmi_write(hdmi, 0x32, HDMI_SLIPHDMIT_PARAM_SETTINGS_6);\r\nhdmi_write(hdmi, 0x48, HDMI_SLIPHDMIT_PARAM_SETTINGS_7);\r\nhdmi_write(hdmi, 0x0F, HDMI_SLIPHDMIT_PARAM_SETTINGS_8);\r\nhdmi_write(hdmi, 0x20, HDMI_SLIPHDMIT_PARAM_SETTINGS_9);\r\nhdmi_write(hdmi, 0x04, HDMI_SLIPHDMIT_PARAM_SETTINGS_10);\r\n}\r\n}\r\nstatic void sh_hdmi_avi_infoframe_setup(struct sh_hdmi *hdmi)\r\n{\r\nu8 vic;\r\nhdmi_write(hdmi, 0x06, HDMI_CTRL_PKT_BUF_INDEX);\r\nhdmi_write(hdmi, 0x82, HDMI_CTRL_PKT_BUF_ACCESS_HB0);\r\nhdmi_write(hdmi, 0x02, HDMI_CTRL_PKT_BUF_ACCESS_HB1);\r\nhdmi_write(hdmi, 0x0D, HDMI_CTRL_PKT_BUF_ACCESS_HB2);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB0);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB1);\r\nhdmi_write(hdmi, 0x28, HDMI_CTRL_PKT_BUF_ACCESS_PB2);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB3);\r\nif (hdmi->preprogrammed_vic)\r\nvic = hdmi->preprogrammed_vic;\r\nelse\r\nvic = 4;\r\nhdmi_write(hdmi, vic, HDMI_CTRL_PKT_BUF_ACCESS_PB4);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB5);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB6);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB7);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB8);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB9);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB10);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB11);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB12);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB13);\r\n}\r\nstatic void sh_hdmi_audio_infoframe_setup(struct sh_hdmi *hdmi)\r\n{\r\nhdmi_write(hdmi, 0x08, HDMI_CTRL_PKT_BUF_INDEX);\r\nhdmi_write(hdmi, 0x84, HDMI_CTRL_PKT_BUF_ACCESS_HB0);\r\nhdmi_write(hdmi, 0x01, HDMI_CTRL_PKT_BUF_ACCESS_HB1);\r\nhdmi_write(hdmi, 0x0A, HDMI_CTRL_PKT_BUF_ACCESS_HB2);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB0);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB1);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB2);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB3);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB4);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB5);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB6);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB7);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB8);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB9);\r\nhdmi_write(hdmi, 0x00, HDMI_CTRL_PKT_BUF_ACCESS_PB10);\r\n}\r\nstatic void sh_hdmi_configure(struct sh_hdmi *hdmi)\r\n{\r\nsh_hdmi_video_config(hdmi);\r\nsh_hdmi_audio_config(hdmi);\r\nsh_hdmi_phy_config(hdmi);\r\nsh_hdmi_avi_infoframe_setup(hdmi);\r\nsh_hdmi_audio_infoframe_setup(hdmi);\r\nhdmi_write(hdmi, 0x8E, HDMI_CTRL_PKT_AUTO_SEND);\r\nmsleep(10);\r\nhdmi_bit_set(hdmi, 0xFC, 0x4C, HDMI_SYSTEM_CTRL);\r\nudelay(10);\r\nhdmi_bit_set(hdmi, 0xFC, 0x40, HDMI_SYSTEM_CTRL);\r\n}\r\nstatic unsigned long sh_hdmi_rate_error(struct sh_hdmi *hdmi,\r\nconst struct fb_videomode *mode,\r\nunsigned long *hdmi_rate, unsigned long *parent_rate)\r\n{\r\nunsigned long target = PICOS2KHZ(mode->pixclock) * 1000, rate_error;\r\nstruct sh_mobile_hdmi_info *pdata = dev_get_platdata(hdmi->dev);\r\n*hdmi_rate = clk_round_rate(hdmi->hdmi_clk, target);\r\nif ((long)*hdmi_rate < 0)\r\n*hdmi_rate = clk_get_rate(hdmi->hdmi_clk);\r\nrate_error = (long)*hdmi_rate > 0 ? abs(*hdmi_rate - target) : ULONG_MAX;\r\nif (rate_error && pdata->clk_optimize_parent)\r\nrate_error = pdata->clk_optimize_parent(target, hdmi_rate, parent_rate);\r\nelse if (clk_get_parent(hdmi->hdmi_clk))\r\n*parent_rate = clk_get_rate(clk_get_parent(hdmi->hdmi_clk));\r\ndev_dbg(hdmi->dev, "%u-%u-%u-%u x %u-%u-%u-%u\n",\r\nmode->left_margin, mode->xres,\r\nmode->right_margin, mode->hsync_len,\r\nmode->upper_margin, mode->yres,\r\nmode->lower_margin, mode->vsync_len);\r\ndev_dbg(hdmi->dev, "\t@%lu(+/-%lu)Hz, e=%lu / 1000, r=%uHz, p=%luHz\n", target,\r\nrate_error, rate_error ? 10000 / (10 * target / rate_error) : 0,\r\nmode->refresh, *parent_rate);\r\nreturn rate_error;\r\n}\r\nstatic int sh_hdmi_read_edid(struct sh_hdmi *hdmi, unsigned long *hdmi_rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct sh_mobile_lcdc_chan *ch = hdmi->entity.lcdc;\r\nconst struct fb_videomode *mode, *found = NULL;\r\nunsigned int f_width = 0, f_height = 0, f_refresh = 0;\r\nunsigned long found_rate_error = ULONG_MAX;\r\nbool scanning = false, preferred_bad = false;\r\nbool use_edid_mode = false;\r\nu8 edid[128];\r\nchar *forced;\r\nint i;\r\ndev_dbg(hdmi->dev, "Read back EDID code:");\r\nfor (i = 0; i < 128; i++) {\r\nedid[i] = (hdmi->htop1) ?\r\n(u8)hdmi_htop1_read(hdmi, HDMI_HTOP1_EDID_DATA_READ + (i * 4)) :\r\nhdmi_read(hdmi, HDMI_EDID_KSV_FIFO_ACCESS_WINDOW);\r\n#ifdef DEBUG\r\nif ((i % 16) == 0) {\r\nprintk(KERN_CONT "\n");\r\nprintk(KERN_DEBUG "%02X | %02X", i, edid[i]);\r\n} else {\r\nprintk(KERN_CONT " %02X", edid[i]);\r\n}\r\n#endif\r\n}\r\n#ifdef DEBUG\r\nprintk(KERN_CONT "\n");\r\n#endif\r\nif (!hdmi->edid_blocks) {\r\nfb_edid_to_monspecs(edid, &hdmi->monspec);\r\nhdmi->edid_blocks = edid[126] + 1;\r\ndev_dbg(hdmi->dev, "%d main modes, %d extension blocks\n",\r\nhdmi->monspec.modedb_len, hdmi->edid_blocks - 1);\r\n} else {\r\ndev_dbg(hdmi->dev, "Extension %u detected, DTD start %u\n",\r\nedid[0], edid[2]);\r\nfb_edid_add_monspecs(edid, &hdmi->monspec);\r\n}\r\nif (hdmi->edid_blocks > hdmi->edid_segment_nr * 2 +\r\n(hdmi->edid_block_addr >> 7) + 1) {\r\nif (hdmi->edid_block_addr) {\r\nhdmi->edid_block_addr = 0;\r\nhdmi->edid_segment_nr++;\r\n} else {\r\nhdmi->edid_block_addr = 0x80;\r\n}\r\nhdmi_write(hdmi, hdmi->edid_block_addr, HDMI_EDID_WORD_ADDRESS);\r\nhdmi_write(hdmi, 0xC6, HDMI_INTERRUPT_MASK_1);\r\nhdmi_write(hdmi, hdmi->edid_segment_nr, HDMI_EDID_SEGMENT_POINTER);\r\nreturn -EAGAIN;\r\n}\r\ndev_dbg(hdmi->dev, "%d main and extended modes\n", hdmi->monspec.modedb_len);\r\nfb_get_options("sh_mobile_lcdc", &forced);\r\nif (forced && *forced) {\r\ni = sscanf(forced, "%ux%u@%u",\r\n&f_width, &f_height, &f_refresh);\r\nif (i < 2) {\r\nf_width = 0;\r\nf_height = 0;\r\n} else {\r\nscanning = true;\r\n}\r\ndev_dbg(hdmi->dev, "Forced mode %ux%u@%uHz\n",\r\nf_width, f_height, f_refresh);\r\n}\r\nfor (i = 0, mode = hdmi->monspec.modedb;\r\ni < hdmi->monspec.modedb_len && scanning;\r\ni++, mode++) {\r\nunsigned long rate_error;\r\nif (!f_width && !f_height) {\r\nif ((mode->flag & FB_MODE_IS_FIRST) || preferred_bad)\r\nscanning = false;\r\nelse\r\ncontinue;\r\n} else if (f_width != mode->xres || f_height != mode->yres) {\r\ncontinue;\r\n}\r\nrate_error = sh_hdmi_rate_error(hdmi, mode, hdmi_rate, parent_rate);\r\nif (scanning) {\r\nif (f_refresh == mode->refresh || (!f_refresh && !rate_error))\r\nscanning = false;\r\nelse if (found && found_rate_error <= rate_error)\r\ncontinue;\r\n}\r\nif (ch && ch->notify &&\r\nch->notify(ch, SH_MOBILE_LCDC_EVENT_DISPLAY_MODE, mode,\r\nNULL)) {\r\nscanning = true;\r\npreferred_bad = true;\r\ncontinue;\r\n}\r\nfound = mode;\r\nfound_rate_error = rate_error;\r\nuse_edid_mode = true;\r\n}\r\nif (!found && hdmi->entity.def_mode.xres != 0) {\r\nfound = &hdmi->entity.def_mode;\r\nfound_rate_error = sh_hdmi_rate_error(hdmi, found, hdmi_rate,\r\nparent_rate);\r\n}\r\nif (!found)\r\nreturn -ENXIO;\r\nif (found->xres == 640 && found->yres == 480 && found->refresh == 60)\r\nhdmi->preprogrammed_vic = 1;\r\nelse if (found->xres == 720 && found->yres == 480 && found->refresh == 60)\r\nhdmi->preprogrammed_vic = 2;\r\nelse if (found->xres == 720 && found->yres == 576 && found->refresh == 50)\r\nhdmi->preprogrammed_vic = 17;\r\nelse if (found->xres == 1280 && found->yres == 720 && found->refresh == 60)\r\nhdmi->preprogrammed_vic = 4;\r\nelse if (found->xres == 1920 && found->yres == 1080 && found->refresh == 24)\r\nhdmi->preprogrammed_vic = 32;\r\nelse if (found->xres == 1920 && found->yres == 1080 && found->refresh == 50)\r\nhdmi->preprogrammed_vic = 31;\r\nelse if (found->xres == 1920 && found->yres == 1080 && found->refresh == 60)\r\nhdmi->preprogrammed_vic = 16;\r\nelse\r\nhdmi->preprogrammed_vic = 0;\r\ndev_dbg(hdmi->dev, "Using %s %s mode %ux%u@%uHz (%luHz), "\r\n"clock error %luHz\n", use_edid_mode ? "EDID" : "default",\r\nhdmi->preprogrammed_vic ? "VIC" : "external", found->xres,\r\nfound->yres, found->refresh, PICOS2KHZ(found->pixclock) * 1000,\r\nfound_rate_error);\r\nhdmi->mode = *found;\r\nsh_hdmi_external_video_param(hdmi);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t sh_hdmi_hotplug(int irq, void *dev_id)\r\n{\r\nstruct sh_hdmi *hdmi = dev_id;\r\nu8 status1, status2, mask1, mask2;\r\nhdmi_bit_set(hdmi, 0xFC, 0x2C, HDMI_SYSTEM_CTRL);\r\nudelay(10);\r\nhdmi_bit_set(hdmi, 0xFC, 0x20, HDMI_SYSTEM_CTRL);\r\nstatus1 = hdmi_read(hdmi, HDMI_INTERRUPT_STATUS_1);\r\nstatus2 = hdmi_read(hdmi, HDMI_INTERRUPT_STATUS_2);\r\nmask1 = hdmi_read(hdmi, HDMI_INTERRUPT_MASK_1);\r\nmask2 = hdmi_read(hdmi, HDMI_INTERRUPT_MASK_2);\r\nhdmi_write(hdmi, 0xFF, HDMI_INTERRUPT_STATUS_1);\r\nhdmi_write(hdmi, 0xFF, HDMI_INTERRUPT_STATUS_2);\r\nif (printk_ratelimit())\r\ndev_dbg(hdmi->dev, "IRQ #%d: Status #1: 0x%x & 0x%x, #2: 0x%x & 0x%x\n",\r\nirq, status1, mask1, status2, mask2);\r\nif (!((status1 & mask1) | (status2 & mask2))) {\r\nreturn IRQ_NONE;\r\n} else if (status1 & 0xc0) {\r\nu8 msens;\r\nudelay(500);\r\nmsens = hdmi_read(hdmi, HDMI_HOT_PLUG_MSENS_STATUS);\r\ndev_dbg(hdmi->dev, "MSENS 0x%x\n", msens);\r\nif ((msens & 0xC0) == 0xC0) {\r\nhdmi->edid_segment_nr = 0;\r\nhdmi->edid_block_addr = 0;\r\nhdmi->edid_blocks = 0;\r\nhdmi->hp_state = HDMI_HOTPLUG_CONNECTED;\r\nhdmi_write(hdmi, 0x00, HDMI_EDID_WORD_ADDRESS);\r\nhdmi_write(hdmi, 0xC6, HDMI_INTERRUPT_MASK_1);\r\nhdmi_write(hdmi, 0x00, HDMI_EDID_SEGMENT_POINTER);\r\n} else if (!(status1 & 0x80)) {\r\nif (hdmi->hp_state != HDMI_HOTPLUG_DISCONNECTED) {\r\nhdmi->hp_state = HDMI_HOTPLUG_DISCONNECTED;\r\nschedule_delayed_work(&hdmi->edid_work, 0);\r\n}\r\n}\r\n} else if (status1 & 2) {\r\nhdmi_write(hdmi, hdmi->edid_block_addr, HDMI_EDID_WORD_ADDRESS);\r\nhdmi_write(hdmi, hdmi->edid_segment_nr, HDMI_EDID_SEGMENT_POINTER);\r\n} else if (status1 & 4) {\r\nhdmi_write(hdmi, 0xC0, HDMI_INTERRUPT_MASK_1);\r\nschedule_delayed_work(&hdmi->edid_work, msecs_to_jiffies(10));\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sh_hdmi_display_on(struct sh_mobile_lcdc_entity *entity)\r\n{\r\nstruct sh_hdmi *hdmi = entity_to_sh_hdmi(entity);\r\ndev_dbg(hdmi->dev, "%s(%p): state %x\n", __func__, hdmi,\r\nhdmi->hp_state);\r\nif (hdmi->hp_state == HDMI_HOTPLUG_EDID_DONE) {\r\nhdmi_bit_set(hdmi, 0xFC, 0x80, HDMI_SYSTEM_CTRL);\r\ndev_dbg(hdmi->dev, "HDMI running\n");\r\n}\r\nreturn hdmi->hp_state == HDMI_HOTPLUG_DISCONNECTED\r\n? SH_MOBILE_LCDC_DISPLAY_DISCONNECTED\r\n: SH_MOBILE_LCDC_DISPLAY_CONNECTED;\r\n}\r\nstatic void sh_hdmi_display_off(struct sh_mobile_lcdc_entity *entity)\r\n{\r\nstruct sh_hdmi *hdmi = entity_to_sh_hdmi(entity);\r\ndev_dbg(hdmi->dev, "%s(%p)\n", __func__, hdmi);\r\nhdmi_bit_set(hdmi, 0xFC, 0x10, HDMI_SYSTEM_CTRL);\r\n}\r\nstatic long sh_hdmi_clk_configure(struct sh_hdmi *hdmi, unsigned long hdmi_rate,\r\nunsigned long parent_rate)\r\n{\r\nint ret;\r\nif (parent_rate && clk_get_parent(hdmi->hdmi_clk)) {\r\nret = clk_set_rate(clk_get_parent(hdmi->hdmi_clk), parent_rate);\r\nif (ret < 0) {\r\ndev_warn(hdmi->dev, "Cannot set parent rate %ld: %d\n", parent_rate, ret);\r\nhdmi_rate = clk_round_rate(hdmi->hdmi_clk, hdmi_rate);\r\n} else {\r\ndev_dbg(hdmi->dev, "HDMI set parent frequency %lu\n", parent_rate);\r\n}\r\n}\r\nret = clk_set_rate(hdmi->hdmi_clk, hdmi_rate);\r\nif (ret < 0) {\r\ndev_warn(hdmi->dev, "Cannot set rate %ld: %d\n", hdmi_rate, ret);\r\nhdmi_rate = 0;\r\n} else {\r\ndev_dbg(hdmi->dev, "HDMI set frequency %lu\n", hdmi_rate);\r\n}\r\nreturn hdmi_rate;\r\n}\r\nstatic void sh_hdmi_edid_work_fn(struct work_struct *work)\r\n{\r\nstruct sh_hdmi *hdmi = container_of(work, struct sh_hdmi, edid_work.work);\r\nstruct sh_mobile_lcdc_chan *ch = hdmi->entity.lcdc;\r\nint ret;\r\ndev_dbg(hdmi->dev, "%s(%p): begin, hotplug status %d\n", __func__, hdmi,\r\nhdmi->hp_state);\r\nif (hdmi->hp_state == HDMI_HOTPLUG_CONNECTED) {\r\nunsigned long parent_rate = 0, hdmi_rate;\r\nret = sh_hdmi_read_edid(hdmi, &hdmi_rate, &parent_rate);\r\nif (ret < 0)\r\ngoto out;\r\nhdmi->hp_state = HDMI_HOTPLUG_EDID_DONE;\r\nret = sh_hdmi_clk_configure(hdmi, hdmi_rate, parent_rate);\r\nif (ret < 0)\r\ngoto out;\r\nmsleep(10);\r\nsh_hdmi_configure(hdmi);\r\nmsleep(10);\r\nif (ch && ch->notify)\r\nch->notify(ch, SH_MOBILE_LCDC_EVENT_DISPLAY_CONNECT,\r\n&hdmi->mode, &hdmi->monspec);\r\n} else {\r\nhdmi->monspec.modedb_len = 0;\r\nfb_destroy_modedb(hdmi->monspec.modedb);\r\nhdmi->monspec.modedb = NULL;\r\nif (ch && ch->notify)\r\nch->notify(ch, SH_MOBILE_LCDC_EVENT_DISPLAY_DISCONNECT,\r\nNULL, NULL);\r\nret = 0;\r\n}\r\nout:\r\nif (ret < 0 && ret != -EAGAIN)\r\nhdmi->hp_state = HDMI_HOTPLUG_DISCONNECTED;\r\ndev_dbg(hdmi->dev, "%s(%p): end\n", __func__, hdmi);\r\n}\r\nstatic void sh_hdmi_htop1_init(struct sh_hdmi *hdmi)\r\n{\r\nhdmi_htop1_write(hdmi, 0x00000000, HDMI_HTOP1_HTOP_DCL_MODE);\r\nhdmi_htop1_write(hdmi, 0x0000000b, 0x0010);\r\nhdmi_htop1_write(hdmi, 0x00006710, HDMI_HTOP1_HTOP_DCL_FRC_MODE);\r\nhdmi_htop1_write(hdmi, 0x01020406, HDMI_HTOP1_HTOP_DCL_FIL_PARA_Y1_1);\r\nhdmi_htop1_write(hdmi, 0x07080806, HDMI_HTOP1_HTOP_DCL_FIL_PARA_Y1_2);\r\nhdmi_htop1_write(hdmi, 0x01020406, HDMI_HTOP1_HTOP_DCL_FIL_PARA_CB1_1);\r\nhdmi_htop1_write(hdmi, 0x07080806, HDMI_HTOP1_HTOP_DCL_FIL_PARA_CB1_2);\r\nhdmi_htop1_write(hdmi, 0x01020406, HDMI_HTOP1_HTOP_DCL_FIL_PARA_CR1_1);\r\nhdmi_htop1_write(hdmi, 0x07080806, HDMI_HTOP1_HTOP_DCL_FIL_PARA_CR1_2);\r\nhdmi_htop1_write(hdmi, 0x01020406, HDMI_HTOP1_HTOP_DCL_FIL_PARA_Y2_1);\r\nhdmi_htop1_write(hdmi, 0x07080806, HDMI_HTOP1_HTOP_DCL_FIL_PARA_Y2_2);\r\nhdmi_htop1_write(hdmi, 0x01020406, HDMI_HTOP1_HTOP_DCL_FIL_PARA_CB2_1);\r\nhdmi_htop1_write(hdmi, 0x07080806, HDMI_HTOP1_HTOP_DCL_FIL_PARA_CB2_2);\r\nhdmi_htop1_write(hdmi, 0x01020406, HDMI_HTOP1_HTOP_DCL_FIL_PARA_CR2_1);\r\nhdmi_htop1_write(hdmi, 0x07080806, HDMI_HTOP1_HTOP_DCL_FIL_PARA_CR2_2);\r\nhdmi_htop1_write(hdmi, 0x00000000, HDMI_HTOP1_HTOP_DCL_COR_PARA_Y1);\r\nhdmi_htop1_write(hdmi, 0x00000000, HDMI_HTOP1_HTOP_DCL_COR_PARA_CB1);\r\nhdmi_htop1_write(hdmi, 0x00000000, HDMI_HTOP1_HTOP_DCL_COR_PARA_CR1);\r\nhdmi_htop1_write(hdmi, 0x00000000, HDMI_HTOP1_HTOP_DCL_COR_PARA_Y2);\r\nhdmi_htop1_write(hdmi, 0x00000000, HDMI_HTOP1_HTOP_DCL_COR_PARA_CB2);\r\nhdmi_htop1_write(hdmi, 0x00000000, HDMI_HTOP1_HTOP_DCL_COR_PARA_CR2);\r\nhdmi_htop1_write(hdmi, 0x00000008, HDMI_HTOP1_CURRENT);\r\nhdmi_htop1_write(hdmi, 0x00000000, HDMI_HTOP1_TISEMP0_1);\r\nhdmi_htop1_write(hdmi, 0x00000000, HDMI_HTOP1_TISEMP2_C);\r\nhdmi_htop1_write(hdmi, 0x00000000, HDMI_HTOP1_PHY_TEST_MODE);\r\nhdmi_htop1_write(hdmi, 0x00000081, HDMI_HTOP1_TISIDRV);\r\nhdmi_htop1_write(hdmi, 0x00000000, HDMI_HTOP1_PLLBW);\r\nhdmi_htop1_write(hdmi, 0x0000000f, HDMI_HTOP1_TISEN);\r\nhdmi_htop1_write(hdmi, 0x0000000f, HDMI_HTOP1_TISDREN);\r\nhdmi_htop1_write(hdmi, 0x00000003, HDMI_HTOP1_ENABLE_SELECTOR);\r\nhdmi_htop1_write(hdmi, 0x00000001, HDMI_HTOP1_MACRO_RESET);\r\nhdmi_htop1_write(hdmi, 0x00000016, HDMI_HTOP1_CISRANGE);\r\nmsleep(100);\r\nhdmi_htop1_write(hdmi, 0x00000001, HDMI_HTOP1_ENABLE_SELECTOR);\r\nmsleep(100);\r\nhdmi_htop1_write(hdmi, 0x00000003, HDMI_HTOP1_ENABLE_SELECTOR);\r\nhdmi_htop1_write(hdmi, 0x00000001, HDMI_HTOP1_MACRO_RESET);\r\nhdmi_htop1_write(hdmi, 0x0000000f, HDMI_HTOP1_TISEN);\r\nhdmi_htop1_write(hdmi, 0x0000000f, HDMI_HTOP1_TISDREN);\r\nhdmi_htop1_write(hdmi, 0x00000000, HDMI_HTOP1_VIDEO_INPUT);\r\nhdmi_htop1_write(hdmi, 0x00000000, HDMI_HTOP1_CLK_TO_PHY);\r\nhdmi_htop1_write(hdmi, 0x00000000, HDMI_HTOP1_VIDEO_INPUT2);\r\nhdmi_htop1_write(hdmi, 0x0000000a, HDMI_HTOP1_CLK_SET);\r\n}\r\nstatic int __init sh_hdmi_probe(struct platform_device *pdev)\r\n{\r\nstruct sh_mobile_hdmi_info *pdata = dev_get_platdata(&pdev->dev);\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nstruct resource *htop1_res;\r\nint irq = platform_get_irq(pdev, 0), ret;\r\nstruct sh_hdmi *hdmi;\r\nlong rate;\r\nif (!res || !pdata || irq < 0)\r\nreturn -ENODEV;\r\nhtop1_res = NULL;\r\nif (pdata->flags & HDMI_HAS_HTOP1) {\r\nhtop1_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!htop1_res) {\r\ndev_err(&pdev->dev, "htop1 needs register base\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nhdmi = devm_kzalloc(&pdev->dev, sizeof(*hdmi), GFP_KERNEL);\r\nif (!hdmi) {\r\ndev_err(&pdev->dev, "Cannot allocate device data\n");\r\nreturn -ENOMEM;\r\n}\r\nhdmi->dev = &pdev->dev;\r\nhdmi->entity.owner = THIS_MODULE;\r\nhdmi->entity.ops = &sh_hdmi_ops;\r\nhdmi->hdmi_clk = clk_get(&pdev->dev, "ick");\r\nif (IS_ERR(hdmi->hdmi_clk)) {\r\nret = PTR_ERR(hdmi->hdmi_clk);\r\ndev_err(&pdev->dev, "Unable to get clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (pdata->flags & HDMI_32BIT_REG) {\r\nhdmi->write = __hdmi_write32;\r\nhdmi->read = __hdmi_read32;\r\n} else {\r\nhdmi->write = __hdmi_write8;\r\nhdmi->read = __hdmi_read8;\r\n}\r\nrate = clk_round_rate(hdmi->hdmi_clk, PICOS2KHZ(37037));\r\nif (rate > 0)\r\nrate = sh_hdmi_clk_configure(hdmi, rate, 0);\r\nif (rate < 0) {\r\nret = rate;\r\ngoto erate;\r\n}\r\nret = clk_prepare_enable(hdmi->hdmi_clk);\r\nif (ret < 0) {\r\ndev_err(hdmi->dev, "Cannot enable clock: %d\n", ret);\r\ngoto erate;\r\n}\r\ndev_dbg(&pdev->dev, "Enabled HDMI clock at %luHz\n", rate);\r\nif (!request_mem_region(res->start, resource_size(res), dev_name(&pdev->dev))) {\r\ndev_err(&pdev->dev, "HDMI register region already claimed\n");\r\nret = -EBUSY;\r\ngoto ereqreg;\r\n}\r\nhdmi->base = ioremap(res->start, resource_size(res));\r\nif (!hdmi->base) {\r\ndev_err(&pdev->dev, "HDMI register region already claimed\n");\r\nret = -ENOMEM;\r\ngoto emap;\r\n}\r\nplatform_set_drvdata(pdev, &hdmi->entity);\r\nINIT_DELAYED_WORK(&hdmi->edid_work, sh_hdmi_edid_work_fn);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get_sync(&pdev->dev);\r\nif (pdata->flags & HDMI_OUTPUT_PUSH_PULL)\r\nhdmi_bit_set(hdmi, 0x02, 0x02, HDMI_SYSTEM_CTRL);\r\nif (pdata->flags & HDMI_OUTPUT_POLARITY_HI)\r\nhdmi_bit_set(hdmi, 0x01, 0x01, HDMI_SYSTEM_CTRL);\r\nif (htop1_res) {\r\nhdmi->htop1 = ioremap(htop1_res->start, resource_size(htop1_res));\r\nif (!hdmi->htop1) {\r\ndev_err(&pdev->dev, "control register region already claimed\n");\r\nret = -ENOMEM;\r\ngoto emap_htop1;\r\n}\r\nsh_hdmi_htop1_init(hdmi);\r\n}\r\ndev_info(&pdev->dev, "Detected HDMI controller 0x%x:0x%x\n",\r\nhdmi_read(hdmi, HDMI_PRODUCT_ID), hdmi_read(hdmi, HDMI_REVISION_ID));\r\nret = request_irq(irq, sh_hdmi_hotplug, 0,\r\ndev_name(&pdev->dev), hdmi);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Unable to request irq: %d\n", ret);\r\ngoto ereqirq;\r\n}\r\nret = snd_soc_register_codec(&pdev->dev,\r\n&soc_codec_dev_sh_hdmi, &sh_hdmi_dai, 1);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "codec registration failed\n");\r\ngoto ecodec;\r\n}\r\nreturn 0;\r\necodec:\r\nfree_irq(irq, hdmi);\r\nereqirq:\r\nif (hdmi->htop1)\r\niounmap(hdmi->htop1);\r\nemap_htop1:\r\npm_runtime_put(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\niounmap(hdmi->base);\r\nemap:\r\nrelease_mem_region(res->start, resource_size(res));\r\nereqreg:\r\nclk_disable_unprepare(hdmi->hdmi_clk);\r\nerate:\r\nclk_put(hdmi->hdmi_clk);\r\nreturn ret;\r\n}\r\nstatic int __exit sh_hdmi_remove(struct platform_device *pdev)\r\n{\r\nstruct sh_hdmi *hdmi = entity_to_sh_hdmi(platform_get_drvdata(pdev));\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nint irq = platform_get_irq(pdev, 0);\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nfree_irq(irq, hdmi);\r\ncancel_delayed_work_sync(&hdmi->edid_work);\r\npm_runtime_put(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nclk_disable_unprepare(hdmi->hdmi_clk);\r\nclk_put(hdmi->hdmi_clk);\r\nif (hdmi->htop1)\r\niounmap(hdmi->htop1);\r\niounmap(hdmi->base);\r\nrelease_mem_region(res->start, resource_size(res));\r\nreturn 0;\r\n}
