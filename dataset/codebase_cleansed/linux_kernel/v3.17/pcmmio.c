static void pcmmio_dio_write(struct comedi_device *dev, unsigned int val,\r\nint page, int port)\r\n{\r\nstruct pcmmio_private *devpriv = dev->private;\r\nunsigned long iobase = dev->iobase;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->pagelock, flags);\r\nif (page == 0) {\r\noutb(val & 0xff, iobase + PCMMIO_PORT_REG(port + 0));\r\noutb((val >> 8) & 0xff, iobase + PCMMIO_PORT_REG(port + 1));\r\noutb((val >> 16) & 0xff, iobase + PCMMIO_PORT_REG(port + 2));\r\n} else {\r\noutb(PCMMIO_PAGE(page), iobase + PCMMIO_PAGE_LOCK_REG);\r\noutb(val & 0xff, iobase + PCMMIO_PAGE_REG(0));\r\noutb((val >> 8) & 0xff, iobase + PCMMIO_PAGE_REG(1));\r\noutb((val >> 16) & 0xff, iobase + PCMMIO_PAGE_REG(2));\r\n}\r\nspin_unlock_irqrestore(&devpriv->pagelock, flags);\r\n}\r\nstatic unsigned int pcmmio_dio_read(struct comedi_device *dev,\r\nint page, int port)\r\n{\r\nstruct pcmmio_private *devpriv = dev->private;\r\nunsigned long iobase = dev->iobase;\r\nunsigned long flags;\r\nunsigned int val;\r\nspin_lock_irqsave(&devpriv->pagelock, flags);\r\nif (page == 0) {\r\nval = inb(iobase + PCMMIO_PORT_REG(port + 0));\r\nval |= (inb(iobase + PCMMIO_PORT_REG(port + 1)) << 8);\r\nval |= (inb(iobase + PCMMIO_PORT_REG(port + 2)) << 16);\r\n} else {\r\noutb(PCMMIO_PAGE(page), iobase + PCMMIO_PAGE_LOCK_REG);\r\nval = inb(iobase + PCMMIO_PAGE_REG(0));\r\nval |= (inb(iobase + PCMMIO_PAGE_REG(1)) << 8);\r\nval |= (inb(iobase + PCMMIO_PAGE_REG(2)) << 16);\r\n}\r\nspin_unlock_irqrestore(&devpriv->pagelock, flags);\r\nreturn val;\r\n}\r\nstatic int pcmmio_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint port = s->index == 2 ? 0 : 3;\r\nunsigned int chanmask = (1 << s->n_chan) - 1;\r\nunsigned int mask;\r\nunsigned int val;\r\nmask = comedi_dio_update_state(s, data);\r\nif (mask) {\r\nval = ~s->state & chanmask;\r\nval &= s->io_bits;\r\npcmmio_dio_write(dev, val, 0, port);\r\n}\r\nval = pcmmio_dio_read(dev, 0, port);\r\ndata[1] = ~val & chanmask;\r\nreturn insn->n;\r\n}\r\nstatic int pcmmio_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint port = s->index == 2 ? 0 : 3;\r\nint ret;\r\nret = comedi_dio_insn_config(dev, s, insn, data, 0);\r\nif (ret)\r\nreturn ret;\r\nif (data[0] == INSN_CONFIG_DIO_INPUT)\r\npcmmio_dio_write(dev, s->io_bits, 0, port);\r\nreturn insn->n;\r\n}\r\nstatic void pcmmio_reset(struct comedi_device *dev)\r\n{\r\npcmmio_dio_write(dev, 0, 0, 0);\r\npcmmio_dio_write(dev, 0, 0, 3);\r\npcmmio_dio_write(dev, 0, PCMMIO_PAGE_POL, 0);\r\npcmmio_dio_write(dev, 0, PCMMIO_PAGE_ENAB, 0);\r\npcmmio_dio_write(dev, 0, PCMMIO_PAGE_INT_ID, 0);\r\n}\r\nstatic void pcmmio_stop_intr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pcmmio_private *devpriv = dev->private;\r\ndevpriv->enabled_mask = 0;\r\ndevpriv->active = 0;\r\ns->async->inttrig = NULL;\r\npcmmio_dio_write(dev, 0, PCMMIO_PAGE_ENAB, 0);\r\n}\r\nstatic void pcmmio_handle_dio_intr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int triggered)\r\n{\r\nstruct pcmmio_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int oldevents = s->async->events;\r\nunsigned int val = 0;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&devpriv->spinlock, flags);\r\nif (!devpriv->active)\r\ngoto done;\r\nif (!(triggered & devpriv->enabled_mask))\r\ngoto done;\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nif (triggered & (1 << chan))\r\nval |= (1 << i);\r\n}\r\nif (comedi_buf_put(s, val) &&\r\ncomedi_buf_put(s, val >> 16)) {\r\ns->async->events |= (COMEDI_CB_BLOCK | COMEDI_CB_EOS);\r\n} else {\r\npcmmio_stop_intr(dev, s);\r\n}\r\nif (cmd->stop_src == TRIG_COUNT && devpriv->stop_count > 0) {\r\ndevpriv->stop_count--;\r\nif (devpriv->stop_count == 0) {\r\ns->async->events |= COMEDI_CB_EOA;\r\npcmmio_stop_intr(dev, s);\r\n}\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&devpriv->spinlock, flags);\r\nif (oldevents != s->async->events)\r\ncomedi_event(dev, s);\r\n}\r\nstatic irqreturn_t interrupt_pcmmio(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nunsigned int triggered;\r\nunsigned char int_pend;\r\nint_pend = inb(dev->iobase + PCMMIO_INT_PENDING_REG) & 0x07;\r\nif (!int_pend)\r\nreturn IRQ_NONE;\r\ntriggered = pcmmio_dio_read(dev, PCMMIO_PAGE_INT_ID, 0);\r\npcmmio_dio_write(dev, 0, PCMMIO_PAGE_INT_ID, 0);\r\npcmmio_handle_dio_intr(dev, s, triggered);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pcmmio_start_intr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pcmmio_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int bits = 0;\r\nunsigned int pol_bits = 0;\r\nint i;\r\nif (cmd->stop_src == TRIG_COUNT && devpriv->stop_count == 0) {\r\ns->async->events |= COMEDI_CB_EOA;\r\ndevpriv->active = 0;\r\nreturn 1;\r\n}\r\ndevpriv->enabled_mask = 0;\r\ndevpriv->active = 1;\r\nif (cmd->chanlist) {\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nunsigned int chanspec = cmd->chanlist[i];\r\nunsigned int chan = CR_CHAN(chanspec);\r\nunsigned int range = CR_RANGE(chanspec);\r\nunsigned int aref = CR_AREF(chanspec);\r\nbits |= (1 << chan);\r\npol_bits |= (((aref || range) ? 1 : 0) << chan);\r\n}\r\n}\r\nbits &= ((1 << s->n_chan) - 1);\r\ndevpriv->enabled_mask = bits;\r\npcmmio_dio_write(dev, pol_bits, PCMMIO_PAGE_POL, 0);\r\npcmmio_dio_write(dev, bits, PCMMIO_PAGE_ENAB, 0);\r\nreturn 0;\r\n}\r\nstatic int pcmmio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct pcmmio_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->spinlock, flags);\r\nif (devpriv->active)\r\npcmmio_stop_intr(dev, s);\r\nspin_unlock_irqrestore(&devpriv->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int pcmmio_inttrig_start_intr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct pcmmio_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned long flags;\r\nint event = 0;\r\nif (trig_num != cmd->start_arg)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&devpriv->spinlock, flags);\r\ns->async->inttrig = NULL;\r\nif (devpriv->active)\r\nevent = pcmmio_start_intr(dev, s);\r\nspin_unlock_irqrestore(&devpriv->spinlock, flags);\r\nif (event)\r\ncomedi_event(dev, s);\r\nreturn 1;\r\n}\r\nstatic int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct pcmmio_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned long flags;\r\nint event = 0;\r\nspin_lock_irqsave(&devpriv->spinlock, flags);\r\ndevpriv->active = 1;\r\nif (cmd->stop_src == TRIG_COUNT)\r\ndevpriv->stop_count = cmd->stop_arg;\r\nelse\r\ndevpriv->stop_count = 0;\r\nif (cmd->start_src == TRIG_INT)\r\ns->async->inttrig = pcmmio_inttrig_start_intr;\r\nelse\r\nevent = pcmmio_start_intr(dev, s);\r\nspin_unlock_irqrestore(&devpriv->spinlock, flags);\r\nif (event)\r\ncomedi_event(dev, s);\r\nreturn 0;\r\n}\r\nstatic int pcmmio_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nerr |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);\r\nerr |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);\r\nerr |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);\r\nerr |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= cfc_check_trigger_is_unique(cmd->start_src);\r\nerr |= cfc_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);\r\nswitch (cmd->stop_src) {\r\ncase TRIG_COUNT:\r\nbreak;\r\ncase TRIG_NONE:\r\nerr |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (err)\r\nreturn 3;\r\nreturn 0;\r\n}\r\nstatic int pcmmio_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned char status;\r\nstatus = inb(dev->iobase + PCMMIO_AI_STATUS_REG);\r\nif (status & PCMMIO_AI_STATUS_DATA_READY)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int pcmmio_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned long iobase = dev->iobase;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nunsigned int aref = CR_AREF(insn->chanspec);\r\nunsigned char cmd = 0;\r\nunsigned int val;\r\nint ret;\r\nint i;\r\nif (chan > 7) {\r\nchan -= 8;\r\niobase += PCMMIO_AI_2ND_ADC_OFFSET;\r\n}\r\nif (aref == AREF_GROUND)\r\ncmd |= PCMMIO_AI_CMD_SE;\r\nif (chan % 2)\r\ncmd |= PCMMIO_AI_CMD_ODD_CHAN;\r\ncmd |= PCMMIO_AI_CMD_CHAN_SEL(chan / 2);\r\ncmd |= PCMMIO_AI_CMD_RANGE(range);\r\noutb(cmd, iobase + PCMMIO_AI_CMD_REG);\r\nret = comedi_timeout(dev, s, insn, pcmmio_ai_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\nval = inb(iobase + PCMMIO_AI_LSB_REG);\r\nval |= inb(iobase + PCMMIO_AI_MSB_REG) << 8;\r\nfor (i = 0; i < insn->n; i++) {\r\noutb(cmd, iobase + PCMMIO_AI_CMD_REG);\r\nret = comedi_timeout(dev, s, insn, pcmmio_ai_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\nval = inb(iobase + PCMMIO_AI_LSB_REG);\r\nval |= inb(iobase + PCMMIO_AI_MSB_REG) << 8;\r\nif (comedi_range_is_bipolar(s, range))\r\nval = comedi_offset_munge(s, val);\r\ndata[i] = val;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int pcmmio_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct pcmmio_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nint i;\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = devpriv->ao_readback[chan];\r\nreturn insn->n;\r\n}\r\nstatic int pcmmio_ao_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned char status;\r\nstatus = inb(dev->iobase + PCMMIO_AO_STATUS_REG);\r\nif (status & PCMMIO_AO_STATUS_DATA_READY)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int pcmmio_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct pcmmio_private *devpriv = dev->private;\r\nunsigned long iobase = dev->iobase;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nunsigned int val = devpriv->ao_readback[chan];\r\nunsigned char cmd = 0;\r\nint ret;\r\nint i;\r\nif (chan > 3) {\r\ncmd |= PCMMIO_AO_CMD_CHAN_SEL(chan - 4);\r\niobase += PCMMIO_AO_2ND_DAC_OFFSET;\r\n} else {\r\ncmd |= PCMMIO_AO_CMD_CHAN_SEL(chan);\r\n}\r\noutb(PCMMIO_AO_LSB_SPAN(range), iobase + PCMMIO_AO_LSB_REG);\r\noutb(0, iobase + PCMMIO_AO_MSB_REG);\r\noutb(cmd | PCMMIO_AO_CMD_WR_SPAN_UPDATE, iobase + PCMMIO_AO_CMD_REG);\r\nret = comedi_timeout(dev, s, insn, pcmmio_ao_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < insn->n; i++) {\r\nval = data[i];\r\noutb(val & 0xff, iobase + PCMMIO_AO_LSB_REG);\r\noutb((val >> 8) & 0xff, iobase + PCMMIO_AO_MSB_REG);\r\noutb(cmd | PCMMIO_AO_CMD_WR_CODE_UPDATE,\r\niobase + PCMMIO_AO_CMD_REG);\r\nret = comedi_timeout(dev, s, insn, pcmmio_ao_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\ndevpriv->ao_readback[chan] = val;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct pcmmio_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nret = comedi_request_region(dev, it->options[0], 32);\r\nif (ret)\r\nreturn ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&devpriv->pagelock);\r\nspin_lock_init(&devpriv->spinlock);\r\npcmmio_reset(dev);\r\nif (it->options[1]) {\r\nret = request_irq(it->options[1], interrupt_pcmmio, 0,\r\ndev->board_name, dev);\r\nif (ret == 0) {\r\ndev->irq = it->options[1];\r\noutb(PCMMIO_AI_RES_ENA_DIO_RES_ACCESS,\r\ndev->iobase + PCMMIO_AI_RES_ENA_REG);\r\noutb(PCMMIO_RESOURCE_IRQ(dev->irq),\r\ndev->iobase + PCMMIO_RESOURCE_REG);\r\n}\r\n}\r\nret = comedi_alloc_subdevices(dev, 4);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF;\r\ns->n_chan = 16;\r\ns->maxdata = 0xffff;\r\ns->range_table = &pcmmio_ai_ranges;\r\ns->insn_read = pcmmio_ai_insn_read;\r\noutb(PCMMIO_AI_RES_ENA_CMD_REG_ACCESS,\r\ndev->iobase + PCMMIO_AI_RES_ENA_REG);\r\noutb(PCMMIO_AI_RES_ENA_CMD_REG_ACCESS,\r\ndev->iobase + PCMMIO_AI_RES_ENA_REG + PCMMIO_AI_2ND_ADC_OFFSET);\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 0xffff;\r\ns->range_table = &pcmmio_ao_ranges;\r\ns->insn_read = pcmmio_ao_insn_read;\r\ns->insn_write = pcmmio_ao_insn_write;\r\noutb(0, dev->iobase + PCMMIO_AO_RESOURCE_ENA_REG);\r\noutb(0, dev->iobase + PCMMIO_AO_2ND_DAC_OFFSET +\r\nPCMMIO_AO_RESOURCE_ENA_REG);\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 24;\r\ns->maxdata = 1;\r\ns->len_chanlist = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = pcmmio_dio_insn_bits;\r\ns->insn_config = pcmmio_dio_insn_config;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->len_chanlist = s->n_chan;\r\ns->cancel = pcmmio_cancel;\r\ns->do_cmd = pcmmio_cmd;\r\ns->do_cmdtest = pcmmio_cmdtest;\r\n}\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 24;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = pcmmio_dio_insn_bits;\r\ns->insn_config = pcmmio_dio_insn_config;\r\nreturn 0;\r\n}
