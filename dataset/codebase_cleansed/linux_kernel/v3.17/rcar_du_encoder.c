struct drm_encoder *\r\nrcar_du_connector_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct rcar_du_connector *rcon = to_rcar_connector(connector);\r\nreturn &rcon->encoder->encoder;\r\n}\r\nstatic void rcar_du_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct rcar_du_encoder *renc = to_rcar_encoder(encoder);\r\nif (renc->lvds)\r\nrcar_du_lvdsenc_dpms(renc->lvds, encoder->crtc, mode);\r\n}\r\nstatic bool rcar_du_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct rcar_du_encoder *renc = to_rcar_encoder(encoder);\r\nconst struct drm_display_mode *panel_mode;\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_connector *connector;\r\nbool found = false;\r\nif (encoder->encoder_type == DRM_MODE_ENCODER_DAC)\r\nreturn true;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nif (connector->encoder == encoder) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\ndev_dbg(dev->dev, "mode_fixup: no connector found\n");\r\nreturn false;\r\n}\r\nif (list_empty(&connector->modes)) {\r\ndev_dbg(dev->dev, "mode_fixup: empty modes list\n");\r\nreturn false;\r\n}\r\npanel_mode = list_first_entry(&connector->modes,\r\nstruct drm_display_mode, head);\r\nif (mode->hdisplay != panel_mode->hdisplay ||\r\nmode->vdisplay != panel_mode->vdisplay)\r\nreturn false;\r\ndrm_mode_copy(adjusted_mode, panel_mode);\r\nif (renc->lvds)\r\nadjusted_mode->clock = clamp(adjusted_mode->clock,\r\n30000, 150000);\r\nreturn true;\r\n}\r\nstatic void rcar_du_encoder_mode_prepare(struct drm_encoder *encoder)\r\n{\r\nstruct rcar_du_encoder *renc = to_rcar_encoder(encoder);\r\nif (renc->lvds)\r\nrcar_du_lvdsenc_dpms(renc->lvds, encoder->crtc,\r\nDRM_MODE_DPMS_OFF);\r\n}\r\nstatic void rcar_du_encoder_mode_commit(struct drm_encoder *encoder)\r\n{\r\nstruct rcar_du_encoder *renc = to_rcar_encoder(encoder);\r\nif (renc->lvds)\r\nrcar_du_lvdsenc_dpms(renc->lvds, encoder->crtc,\r\nDRM_MODE_DPMS_ON);\r\n}\r\nstatic void rcar_du_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct rcar_du_encoder *renc = to_rcar_encoder(encoder);\r\nrcar_du_crtc_route_output(encoder->crtc, renc->output);\r\n}\r\nint rcar_du_encoder_init(struct rcar_du_device *rcdu,\r\nenum rcar_du_encoder_type type,\r\nenum rcar_du_output output,\r\nconst struct rcar_du_encoder_data *data)\r\n{\r\nstruct rcar_du_encoder *renc;\r\nunsigned int encoder_type;\r\nint ret;\r\nrenc = devm_kzalloc(rcdu->dev, sizeof(*renc), GFP_KERNEL);\r\nif (renc == NULL)\r\nreturn -ENOMEM;\r\nrenc->output = output;\r\nswitch (output) {\r\ncase RCAR_DU_OUTPUT_LVDS0:\r\nrenc->lvds = rcdu->lvds[0];\r\nbreak;\r\ncase RCAR_DU_OUTPUT_LVDS1:\r\nrenc->lvds = rcdu->lvds[1];\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (type) {\r\ncase RCAR_DU_ENCODER_VGA:\r\nencoder_type = DRM_MODE_ENCODER_DAC;\r\nbreak;\r\ncase RCAR_DU_ENCODER_LVDS:\r\nencoder_type = DRM_MODE_ENCODER_LVDS;\r\nbreak;\r\ncase RCAR_DU_ENCODER_NONE:\r\ndefault:\r\nencoder_type = rcdu->info->routes[output].encoder_type;\r\nbreak;\r\n}\r\nret = drm_encoder_init(rcdu->ddev, &renc->encoder, &encoder_funcs,\r\nencoder_type);\r\nif (ret < 0)\r\nreturn ret;\r\ndrm_encoder_helper_add(&renc->encoder, &encoder_helper_funcs);\r\nswitch (encoder_type) {\r\ncase DRM_MODE_ENCODER_LVDS:\r\nreturn rcar_du_lvds_connector_init(rcdu, renc,\r\n&data->connector.lvds.panel);\r\ncase DRM_MODE_ENCODER_DAC:\r\nreturn rcar_du_vga_connector_init(rcdu, renc);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}
