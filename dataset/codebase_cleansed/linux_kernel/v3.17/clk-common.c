static inline unsigned long clkc_readl(unsigned reg)\r\n{\r\nreturn readl(sirfsoc_clk_vbase + reg);\r\n}\r\nstatic inline void clkc_writel(u32 val, unsigned reg)\r\n{\r\nwritel(val, sirfsoc_clk_vbase + reg);\r\n}\r\nstatic unsigned long pll_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nunsigned long fin = parent_rate;\r\nstruct clk_pll *clk = to_pllclk(hw);\r\nu32 regcfg2 = clk->regofs + SIRFSOC_CLKC_PLL1_CFG2 -\r\nSIRFSOC_CLKC_PLL1_CFG0;\r\nif (clkc_readl(regcfg2) & BIT(2)) {\r\nreturn fin;\r\n} else {\r\nu32 cfg0 = clkc_readl(clk->regofs);\r\nu32 nf = (cfg0 & (BIT(13) - 1)) + 1;\r\nu32 nr = ((cfg0 >> 13) & (BIT(6) - 1)) + 1;\r\nu32 od = ((cfg0 >> 19) & (BIT(4) - 1)) + 1;\r\nWARN_ON(fin % MHZ);\r\nreturn fin / MHZ * nf / nr / od * MHZ;\r\n}\r\n}\r\nstatic long pll_clk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nunsigned long fin, nf, nr, od;\r\nu64 dividend;\r\nrate = rate - rate % MHZ;\r\nnf = rate / MHZ;\r\nif (nf > BIT(13))\r\nnf = BIT(13);\r\nif (nf < 1)\r\nnf = 1;\r\nfin = *parent_rate;\r\nnr = fin / MHZ;\r\nif (nr > BIT(6))\r\nnr = BIT(6);\r\nod = 1;\r\ndividend = (u64)fin * nf;\r\ndo_div(dividend, nr * od);\r\nreturn (long)dividend;\r\n}\r\nstatic int pll_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pll *clk = to_pllclk(hw);\r\nunsigned long fin, nf, nr, od, reg;\r\nnf = rate / MHZ;\r\nif (unlikely((rate % MHZ) || nf > BIT(13) || nf < 1))\r\nreturn -EINVAL;\r\nfin = parent_rate;\r\nBUG_ON(fin < MHZ);\r\nnr = fin / MHZ;\r\nBUG_ON((fin % MHZ) || nr > BIT(6));\r\nod = 1;\r\nreg = (nf - 1) | ((nr - 1) << 13) | ((od - 1) << 19);\r\nclkc_writel(reg, clk->regofs);\r\nreg = clk->regofs + SIRFSOC_CLKC_PLL1_CFG1 - SIRFSOC_CLKC_PLL1_CFG0;\r\nclkc_writel((nf >> 1) - 1, reg);\r\nreg = clk->regofs + SIRFSOC_CLKC_PLL1_CFG2 - SIRFSOC_CLKC_PLL1_CFG0;\r\nwhile (!(clkc_readl(reg) & BIT(6)))\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nstatic long cpu_clk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct clk *parent_clk = clk_get_parent(hw->clk);\r\nstruct clk *pll_parent_clk = clk_get_parent(parent_clk);\r\nunsigned long pll_parent_rate = clk_get_rate(pll_parent_clk);\r\nreturn pll_clk_round_rate(__clk_get_hw(parent_clk), rate, &pll_parent_rate);\r\n}\r\nstatic unsigned long cpu_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk *parent_clk = clk_get_parent(hw->clk);\r\nreturn __clk_get_rate(parent_clk);\r\n}\r\nstatic int usb_pll_clk_enable(struct clk_hw *hw)\r\n{\r\nu32 reg = readl(sirfsoc_rsc_vbase + SIRFSOC_USBPHY_PLL_CTRL);\r\nreg &= ~(SIRFSOC_USBPHY_PLL_POWERDOWN | SIRFSOC_USBPHY_PLL_BYPASS);\r\nwritel(reg, sirfsoc_rsc_vbase + SIRFSOC_USBPHY_PLL_CTRL);\r\nwhile (!(readl(sirfsoc_rsc_vbase + SIRFSOC_USBPHY_PLL_CTRL) &\r\nSIRFSOC_USBPHY_PLL_LOCK))\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nstatic void usb_pll_clk_disable(struct clk_hw *clk)\r\n{\r\nu32 reg = readl(sirfsoc_rsc_vbase + SIRFSOC_USBPHY_PLL_CTRL);\r\nreg |= (SIRFSOC_USBPHY_PLL_POWERDOWN | SIRFSOC_USBPHY_PLL_BYPASS);\r\nwritel(reg, sirfsoc_rsc_vbase + SIRFSOC_USBPHY_PLL_CTRL);\r\n}\r\nstatic unsigned long usb_pll_clk_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nu32 reg = readl(sirfsoc_rsc_vbase + SIRFSOC_USBPHY_PLL_CTRL);\r\nreturn (reg & SIRFSOC_USBPHY_PLL_BYPASS) ? parent_rate : 48*MHZ;\r\n}\r\nstatic u8 dmn_clk_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_dmn *clk = to_dmnclk(hw);\r\nu32 cfg = clkc_readl(clk->regofs);\r\nif (strcmp(hw->init->name, "io") == 0)\r\nreturn 4;\r\nWARN_ON((cfg & (BIT(3) - 1)) > 4);\r\nreturn cfg & (BIT(3) - 1);\r\n}\r\nstatic int dmn_clk_set_parent(struct clk_hw *hw, u8 parent)\r\n{\r\nstruct clk_dmn *clk = to_dmnclk(hw);\r\nu32 cfg = clkc_readl(clk->regofs);\r\nif (strcmp(hw->init->name, "io") == 0)\r\nreturn -EINVAL;\r\ncfg &= ~(BIT(3) - 1);\r\nclkc_writel(cfg | parent, clk->regofs);\r\nwhile (clkc_readl(clk->regofs) & BIT(3))\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nstatic unsigned long dmn_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nunsigned long fin = parent_rate;\r\nstruct clk_dmn *clk = to_dmnclk(hw);\r\nu32 cfg = clkc_readl(clk->regofs);\r\nif (cfg & BIT(24)) {\r\nreturn fin;\r\n} else {\r\nu32 wait = (cfg >> 16) & (BIT(4) - 1);\r\nu32 hold = (cfg >> 20) & (BIT(4) - 1);\r\nreturn fin / (wait + hold + 2);\r\n}\r\n}\r\nstatic long dmn_clk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nunsigned long fin;\r\nunsigned ratio, wait, hold;\r\nunsigned bits = (strcmp(hw->init->name, "mem") == 0) ? 3 : 4;\r\nfin = *parent_rate;\r\nratio = fin / rate;\r\nif (ratio < 2)\r\nratio = 2;\r\nif (ratio > BIT(bits + 1))\r\nratio = BIT(bits + 1);\r\nwait = (ratio >> 1) - 1;\r\nhold = ratio - wait - 2;\r\nreturn fin / (wait + hold + 2);\r\n}\r\nstatic int dmn_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_dmn *clk = to_dmnclk(hw);\r\nunsigned long fin;\r\nunsigned ratio, wait, hold, reg;\r\nunsigned bits = (strcmp(hw->init->name, "mem") == 0) ? 3 : 4;\r\nfin = parent_rate;\r\nratio = fin / rate;\r\nif (unlikely(ratio < 2 || ratio > BIT(bits + 1)))\r\nreturn -EINVAL;\r\nWARN_ON(fin % rate);\r\nwait = (ratio >> 1) - 1;\r\nhold = ratio - wait - 2;\r\nreg = clkc_readl(clk->regofs);\r\nreg &= ~(((BIT(bits) - 1) << 16) | ((BIT(bits) - 1) << 20));\r\nreg |= (wait << 16) | (hold << 20) | BIT(25);\r\nclkc_writel(reg, clk->regofs);\r\nwhile (clkc_readl(clk->regofs) & BIT(25))\r\ncpu_relax();\r\nreturn 0;\r\n}\r\nstatic int cpu_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nint ret1, ret2;\r\nstruct clk *cur_parent;\r\nif (rate == clk_get_rate(clk_pll1.hw.clk)) {\r\nret1 = clk_set_parent(hw->clk, clk_pll1.hw.clk);\r\nreturn ret1;\r\n}\r\nif (rate == clk_get_rate(clk_pll2.hw.clk)) {\r\nret1 = clk_set_parent(hw->clk, clk_pll2.hw.clk);\r\nreturn ret1;\r\n}\r\nif (rate == clk_get_rate(clk_pll3.hw.clk)) {\r\nret1 = clk_set_parent(hw->clk, clk_pll3.hw.clk);\r\nreturn ret1;\r\n}\r\ncur_parent = clk_get_parent(hw->clk);\r\nif (cur_parent == clk_pll1.hw.clk) {\r\nret1 = clk_set_parent(hw->clk, clk_pll2.hw.clk);\r\nBUG_ON(ret1);\r\n}\r\nret2 = clk_set_rate(clk_pll1.hw.clk, rate);\r\nret1 = clk_set_parent(hw->clk, clk_pll1.hw.clk);\r\nreturn ret2 ? ret2 : ret1;\r\n}\r\nstatic int std_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nu32 reg;\r\nint bit;\r\nstruct clk_std *clk = to_stdclk(hw);\r\nbit = clk->enable_bit % 32;\r\nreg = clk->enable_bit / 32;\r\nreg = SIRFSOC_CLKC_CLK_EN0 + reg * sizeof(reg);\r\nreturn !!(clkc_readl(reg) & BIT(bit));\r\n}\r\nstatic int std_clk_enable(struct clk_hw *hw)\r\n{\r\nu32 val, reg;\r\nint bit;\r\nstruct clk_std *clk = to_stdclk(hw);\r\nBUG_ON(clk->enable_bit < 0 || clk->enable_bit > 63);\r\nbit = clk->enable_bit % 32;\r\nreg = clk->enable_bit / 32;\r\nreg = SIRFSOC_CLKC_CLK_EN0 + reg * sizeof(reg);\r\nval = clkc_readl(reg) | BIT(bit);\r\nclkc_writel(val, reg);\r\nreturn 0;\r\n}\r\nstatic void std_clk_disable(struct clk_hw *hw)\r\n{\r\nu32 val, reg;\r\nint bit;\r\nstruct clk_std *clk = to_stdclk(hw);\r\nBUG_ON(clk->enable_bit < 0 || clk->enable_bit > 63);\r\nbit = clk->enable_bit % 32;\r\nreg = clk->enable_bit / 32;\r\nreg = SIRFSOC_CLKC_CLK_EN0 + reg * sizeof(reg);\r\nval = clkc_readl(reg) & ~BIT(bit);\r\nclkc_writel(val, reg);\r\n}
