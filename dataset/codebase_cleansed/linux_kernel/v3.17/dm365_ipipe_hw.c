static void ipipe_clock_enable(void *__iomem base_addr)\r\n{\r\nregw_ip(base_addr, IPIPE_GCK_MMR_DEFAULT, IPIPE_GCK_MMR);\r\nregw_ip(base_addr, IPIPE_GCK_PIX_DEFAULT, IPIPE_GCK_PIX);\r\n}\r\nstatic void\r\nrsz_set_common_params(void *__iomem rsz_base, struct resizer_params *params)\r\n{\r\nstruct rsz_common_params *rsz_common = &params->rsz_common;\r\nu32 val;\r\nregw_rsz(rsz_base, params->oper_mode, RSZ_SRC_MODE);\r\nval = (rsz_common->passthrough << RSZ_BYPASS_SHIFT) |\r\nrsz_common->source;\r\nregw_rsz(rsz_base, val, RSZ_SRC_FMT0);\r\nval = (rsz_common->raw_flip & 1) |\r\n(rsz_common->src_img_fmt << RSZ_SRC_IMG_FMT_SHIFT) |\r\n((rsz_common->y_c & 1) << RSZ_SRC_Y_C_SEL_SHIFT);\r\nregw_rsz(rsz_base, val, RSZ_SRC_FMT1);\r\nregw_rsz(rsz_base, rsz_common->vps & IPIPE_RSZ_VPS_MASK, RSZ_SRC_VPS);\r\nregw_rsz(rsz_base, rsz_common->hps & IPIPE_RSZ_HPS_MASK, RSZ_SRC_HPS);\r\nregw_rsz(rsz_base, rsz_common->vsz & IPIPE_RSZ_VSZ_MASK, RSZ_SRC_VSZ);\r\nregw_rsz(rsz_base, rsz_common->hsz & IPIPE_RSZ_HSZ_MASK, RSZ_SRC_HSZ);\r\nregw_rsz(rsz_base, rsz_common->yuv_y_min, RSZ_YUV_Y_MIN);\r\nregw_rsz(rsz_base, rsz_common->yuv_y_max, RSZ_YUV_Y_MAX);\r\nregw_rsz(rsz_base, rsz_common->yuv_c_min, RSZ_YUV_C_MIN);\r\nregw_rsz(rsz_base, rsz_common->yuv_c_max, RSZ_YUV_C_MAX);\r\nregw_rsz(rsz_base, rsz_common->out_chr_pos, RSZ_YUV_PHS);\r\n}\r\nstatic void\r\nrsz_set_rsz_regs(void *__iomem rsz_base, unsigned int rsz_id,\r\nstruct resizer_params *params)\r\n{\r\nstruct resizer_scale_param *rsc_params;\r\nstruct rsz_ext_mem_param *ext_mem;\r\nstruct resizer_rgb *rgb;\r\nu32 reg_base;\r\nu32 val;\r\nrsc_params = &params->rsz_rsc_param[rsz_id];\r\nrgb = &params->rsz2rgb[rsz_id];\r\next_mem = &params->ext_mem_param[rsz_id];\r\nif (rsz_id == RSZ_A) {\r\nval = rsc_params->h_flip << RSZA_H_FLIP_SHIFT;\r\nval |= rsc_params->v_flip << RSZA_V_FLIP_SHIFT;\r\nreg_base = RSZ_EN_A;\r\n} else {\r\nval = rsc_params->h_flip << RSZB_H_FLIP_SHIFT;\r\nval |= rsc_params->v_flip << RSZB_V_FLIP_SHIFT;\r\nreg_base = RSZ_EN_B;\r\n}\r\nregw_rsz(rsz_base, val, RSZ_SEQ);\r\nregw_rsz(rsz_base, params->oper_mode, reg_base + RSZ_MODE);\r\nval = (rsc_params->cen << RSZ_CEN_SHIFT) | rsc_params->yen;\r\nregw_rsz(rsz_base, val, reg_base + RSZ_420);\r\nregw_rsz(rsz_base, rsc_params->i_vps & RSZ_VPS_MASK,\r\nreg_base + RSZ_I_VPS);\r\nregw_rsz(rsz_base, rsc_params->i_hps & RSZ_HPS_MASK,\r\nreg_base + RSZ_I_HPS);\r\nregw_rsz(rsz_base, rsc_params->o_vsz & RSZ_O_VSZ_MASK,\r\nreg_base + RSZ_O_VSZ);\r\nregw_rsz(rsz_base, rsc_params->o_hsz & RSZ_O_HSZ_MASK,\r\nreg_base + RSZ_O_HSZ);\r\nregw_rsz(rsz_base, rsc_params->v_phs_y & RSZ_V_PHS_MASK,\r\nreg_base + RSZ_V_PHS_Y);\r\nregw_rsz(rsz_base, rsc_params->v_phs_c & RSZ_V_PHS_MASK,\r\nreg_base + RSZ_V_PHS_C);\r\nregw_rsz(rsz_base, rsc_params->v_dif & RSZ_V_DIF_MASK,\r\nreg_base + RSZ_V_DIF);\r\nval = (rsc_params->v_typ_y & 1) |\r\n((rsc_params->v_typ_c & 1) << RSZ_TYP_C_SHIFT);\r\nregw_rsz(rsz_base, val, reg_base + RSZ_V_TYP);\r\nval = (rsc_params->v_lpf_int_y & RSZ_LPF_INT_MASK) |\r\n((rsc_params->v_lpf_int_c & RSZ_LPF_INT_MASK) <<\r\nRSZ_LPF_INT_C_SHIFT);\r\nregw_rsz(rsz_base, val, reg_base + RSZ_V_LPF);\r\nregw_rsz(rsz_base, rsc_params->h_phs &\r\nRSZ_H_PHS_MASK, reg_base + RSZ_H_PHS);\r\nregw_rsz(rsz_base, 0, reg_base + RSZ_H_PHS_ADJ);\r\nregw_rsz(rsz_base, rsc_params->h_dif &\r\nRSZ_H_DIF_MASK, reg_base + RSZ_H_DIF);\r\nval = (rsc_params->h_typ_y & 1) |\r\n((rsc_params->h_typ_c & 1) << RSZ_TYP_C_SHIFT);\r\nregw_rsz(rsz_base, val, reg_base + RSZ_H_TYP);\r\nval = (rsc_params->h_lpf_int_y & RSZ_LPF_INT_MASK) |\r\n((rsc_params->h_lpf_int_c & RSZ_LPF_INT_MASK) <<\r\nRSZ_LPF_INT_C_SHIFT);\r\nregw_rsz(rsz_base, val, reg_base + RSZ_H_LPF);\r\nregw_rsz(rsz_base, rsc_params->dscale_en & 1, reg_base + RSZ_DWN_EN);\r\nval = (rsc_params->h_dscale_ave_sz & RSZ_DWN_SCALE_AV_SZ_MASK) |\r\n((rsc_params->v_dscale_ave_sz & RSZ_DWN_SCALE_AV_SZ_MASK) <<\r\nRSZ_DWN_SCALE_AV_SZ_V_SHIFT);\r\nregw_rsz(rsz_base, val, reg_base + RSZ_DWN_AV);\r\nregw_rsz(rsz_base, rgb->rgb_en, reg_base + RSZ_RGB_EN);\r\nval = (rgb->rgb_typ << RSZ_RGB_TYP_SHIFT) |\r\n(rgb->rgb_msk0 << RSZ_RGB_MSK0_SHIFT) |\r\n(rgb->rgb_msk1 << RSZ_RGB_MSK1_SHIFT);\r\nregw_rsz(rsz_base, val, reg_base + RSZ_RGB_TYP);\r\nregw_rsz(rsz_base, rgb->rgb_alpha_val & RSZ_RGB_ALPHA_MASK,\r\nreg_base + RSZ_RGB_BLD);\r\nregw_rsz(rsz_base, ext_mem->rsz_sdr_oft_y, reg_base + RSZ_SDR_Y_OFT);\r\nregw_rsz(rsz_base, ext_mem->rsz_sdr_ptr_s_y,\r\nreg_base + RSZ_SDR_Y_PTR_S);\r\nregw_rsz(rsz_base, ext_mem->rsz_sdr_ptr_e_y,\r\nreg_base + RSZ_SDR_Y_PTR_E);\r\nregw_rsz(rsz_base, ext_mem->rsz_sdr_oft_c, reg_base + RSZ_SDR_C_OFT);\r\nregw_rsz(rsz_base, ext_mem->rsz_sdr_ptr_s_c,\r\nreg_base + RSZ_SDR_C_PTR_S);\r\nregw_rsz(rsz_base, (ext_mem->rsz_sdr_ptr_e_c >> 1),\r\nreg_base + RSZ_SDR_C_PTR_E);\r\n}\r\nstatic void\r\nipipe_setup_resizer(void *__iomem rsz_base, struct resizer_params *params)\r\n{\r\nregw_rsz(rsz_base, 1, RSZ_GCK_MMR);\r\nif (params->rsz_common.passthrough)\r\nregw_rsz(rsz_base, 0, RSZ_GCK_SDR);\r\nelse\r\nregw_rsz(rsz_base, 1, RSZ_GCK_SDR);\r\nrsz_set_common_params(rsz_base, params);\r\nregw_rsz(rsz_base, params->rsz_en[RSZ_A], RSZ_EN_A);\r\nif (params->rsz_en[RSZ_A])\r\nrsz_set_rsz_regs(rsz_base, RSZ_A, params);\r\nregw_rsz(rsz_base, params->rsz_en[RSZ_B], RSZ_EN_B);\r\nif (params->rsz_en[RSZ_B])\r\nrsz_set_rsz_regs(rsz_base, RSZ_B, params);\r\n}\r\nstatic u32 ipipe_get_color_pat(enum v4l2_mbus_pixelcode pix)\r\n{\r\nswitch (pix) {\r\ncase V4L2_MBUS_FMT_SGRBG10_ALAW8_1X8:\r\ncase V4L2_MBUS_FMT_SGRBG10_DPCM8_1X8:\r\ncase V4L2_MBUS_FMT_SGRBG12_1X12:\r\nreturn ipipe_sgrbg_pattern;\r\ndefault:\r\nreturn ipipe_srggb_pattern;\r\n}\r\n}\r\nstatic int ipipe_get_data_path(struct vpfe_ipipe_device *ipipe)\r\n{\r\nenum v4l2_mbus_pixelcode temp_pix_fmt;\r\nswitch (ipipe->formats[IPIPE_PAD_SINK].code) {\r\ncase V4L2_MBUS_FMT_SBGGR8_1X8:\r\ncase V4L2_MBUS_FMT_SGRBG10_ALAW8_1X8:\r\ncase V4L2_MBUS_FMT_SGRBG10_DPCM8_1X8:\r\ncase V4L2_MBUS_FMT_SGRBG12_1X12:\r\ntemp_pix_fmt = V4L2_MBUS_FMT_SGRBG12_1X12;\r\nbreak;\r\ndefault:\r\ntemp_pix_fmt = V4L2_MBUS_FMT_UYVY8_2X8;\r\n}\r\nif (temp_pix_fmt == V4L2_MBUS_FMT_SGRBG12_1X12) {\r\nif (ipipe->formats[IPIPE_PAD_SOURCE].code ==\r\nV4L2_MBUS_FMT_SGRBG12_1X12)\r\nreturn IPIPE_RAW2RAW;\r\nreturn IPIPE_RAW2YUV;\r\n}\r\nreturn IPIPE_YUV2YUV;\r\n}\r\nstatic int get_ipipe_mode(struct vpfe_ipipe_device *ipipe)\r\n{\r\nstruct vpfe_device *vpfe_dev = to_vpfe_device(ipipe);\r\nu16 ipipeif_sink = vpfe_dev->vpfe_ipipeif.input;\r\nif (ipipeif_sink == IPIPEIF_INPUT_MEMORY)\r\nreturn IPIPE_MODE_SINGLE_SHOT;\r\nelse if (ipipeif_sink == IPIPEIF_INPUT_ISIF)\r\nreturn IPIPE_MODE_CONTINUOUS;\r\nreturn -EINVAL;\r\n}\r\nint config_ipipe_hw(struct vpfe_ipipe_device *ipipe)\r\n{\r\nstruct vpfe_ipipe_input_config *config = &ipipe->config.input_config;\r\nvoid __iomem *ipipe_base = ipipe->base_addr;\r\nstruct v4l2_mbus_framefmt *outformat;\r\nu32 color_pat;\r\nu32 ipipe_mode;\r\nu32 data_path;\r\nvpss_enable_clock(VPSS_IPIPE_CLOCK, 1);\r\nipipe_clock_enable(ipipe_base);\r\nif (ipipe->input == IPIPE_INPUT_NONE) {\r\nregw_ip(ipipe_base, 0, IPIPE_SRC_EN);\r\nreturn 0;\r\n}\r\nipipe_mode = get_ipipe_mode(ipipe);\r\nif (ipipe_mode < 0) {\r\npr_err("Failed to get ipipe mode");\r\nreturn -EINVAL;\r\n}\r\nregw_ip(ipipe_base, ipipe_mode, IPIPE_SRC_MODE);\r\ndata_path = ipipe_get_data_path(ipipe);\r\nregw_ip(ipipe_base, data_path, IPIPE_SRC_FMT);\r\nregw_ip(ipipe_base, config->vst & IPIPE_RSZ_VPS_MASK, IPIPE_SRC_VPS);\r\nregw_ip(ipipe_base, config->hst & IPIPE_RSZ_HPS_MASK, IPIPE_SRC_HPS);\r\noutformat = &ipipe->formats[IPIPE_PAD_SOURCE];\r\nregw_ip(ipipe_base, (outformat->height + 1) & IPIPE_RSZ_VSZ_MASK,\r\nIPIPE_SRC_VSZ);\r\nregw_ip(ipipe_base, (outformat->width + 1) & IPIPE_RSZ_HSZ_MASK,\r\nIPIPE_SRC_HSZ);\r\nif (data_path == IPIPE_RAW2YUV ||\r\ndata_path == IPIPE_RAW2RAW) {\r\ncolor_pat =\r\nipipe_get_color_pat(ipipe->formats[IPIPE_PAD_SINK].code);\r\nregw_ip(ipipe_base, color_pat, IPIPE_SRC_COL);\r\n}\r\nreturn 0;\r\n}\r\nint config_rsz_hw(struct vpfe_resizer_device *resizer,\r\nstruct resizer_params *config)\r\n{\r\nstruct vpfe_device *vpfe_dev = to_vpfe_device(resizer);\r\nvoid *__iomem ipipe_base = vpfe_dev->vpfe_ipipe.base_addr;\r\nvoid *__iomem rsz_base = vpfe_dev->vpfe_resizer.base_addr;\r\nvpss_enable_clock(VPSS_IPIPE_CLOCK, 1);\r\nipipe_clock_enable(ipipe_base);\r\nipipe_setup_resizer(rsz_base, config);\r\nreturn 0;\r\n}\r\nstatic void\r\nrsz_set_y_address(void *__iomem rsz_base, unsigned int address,\r\nunsigned int offset)\r\n{\r\nu32 val;\r\nval = address & SET_LOW_ADDR;\r\nregw_rsz(rsz_base, val, offset + RSZ_SDR_Y_BAD_L);\r\nregw_rsz(rsz_base, val, offset + RSZ_SDR_Y_SAD_L);\r\nval = (address & SET_HIGH_ADDR) >> 16;\r\nregw_rsz(rsz_base, val, offset + RSZ_SDR_Y_BAD_H);\r\nregw_rsz(rsz_base, val, offset + RSZ_SDR_Y_SAD_H);\r\n}\r\nstatic void\r\nrsz_set_c_address(void *__iomem rsz_base, unsigned int address,\r\nunsigned int offset)\r\n{\r\nu32 val;\r\nval = address & SET_LOW_ADDR;\r\nregw_rsz(rsz_base, val, offset + RSZ_SDR_C_BAD_L);\r\nregw_rsz(rsz_base, val, offset + RSZ_SDR_C_SAD_L);\r\nval = (address & SET_HIGH_ADDR) >> 16;\r\nregw_rsz(rsz_base, val, offset + RSZ_SDR_C_BAD_H);\r\nregw_rsz(rsz_base, val, offset + RSZ_SDR_C_SAD_H);\r\n}\r\nint\r\nresizer_set_outaddr(void *__iomem rsz_base, struct resizer_params *params,\r\nint resize_no, unsigned int address)\r\n{\r\nstruct resizer_scale_param *rsc_param;\r\nstruct rsz_ext_mem_param *mem_param;\r\nstruct rsz_common_params *rsz_common;\r\nunsigned int rsz_start_add;\r\nunsigned int val;\r\nif (resize_no != RSZ_A && resize_no != RSZ_B)\r\nreturn -EINVAL;\r\nmem_param = &params->ext_mem_param[resize_no];\r\nrsc_param = &params->rsz_rsc_param[resize_no];\r\nrsz_common = &params->rsz_common;\r\nif (resize_no == RSZ_A)\r\nrsz_start_add = RSZ_EN_A;\r\nelse\r\nrsz_start_add = RSZ_EN_B;\r\nif (rsz_common->src_img_fmt == RSZ_IMG_420) {\r\nif (rsz_common->y_c) {\r\nval = address + mem_param->flip_ofst_c;\r\nrsz_set_c_address(rsz_base, val, rsz_start_add);\r\n} else {\r\nval = address + mem_param->flip_ofst_y;\r\nrsz_set_y_address(rsz_base, val, rsz_start_add);\r\n}\r\n} else {\r\nif (rsc_param->cen && rsc_param->yen) {\r\nval = address + mem_param->c_offset +\r\nmem_param->flip_ofst_c +\r\nmem_param->user_y_ofst +\r\nmem_param->user_c_ofst;\r\nif (resize_no == RSZ_B)\r\nval +=\r\nparams->ext_mem_param[RSZ_A].user_y_ofst +\r\nparams->ext_mem_param[RSZ_A].user_c_ofst;\r\nrsz_set_c_address(rsz_base, val, rsz_start_add);\r\n}\r\nval = address + mem_param->flip_ofst_y + mem_param->user_y_ofst;\r\nif (resize_no == RSZ_B)\r\nval += params->ext_mem_param[RSZ_A].user_y_ofst +\r\nparams->ext_mem_param[RSZ_A].user_c_ofst;\r\nrsz_set_y_address(rsz_base, val, rsz_start_add);\r\n}\r\nregw_rsz(rsz_base, params->rsz_en[resize_no], rsz_start_add);\r\nreturn 0;\r\n}\r\nvoid\r\nipipe_set_lutdpc_regs(void *__iomem base_addr, void *__iomem isp5_base_addr,\r\nstruct vpfe_ipipe_lutdpc *dpc)\r\n{\r\nu32 max_tbl_size = LUT_DPC_MAX_SIZE >> 1;\r\nu32 lut_start_addr = DPC_TB0_START_ADDR;\r\nu32 val;\r\nu32 count;\r\nipipe_clock_enable(base_addr);\r\nregw_ip(base_addr, dpc->en, DPC_LUT_EN);\r\nif (dpc->en != 1)\r\nreturn;\r\nval = LUTDPC_TBL_256_EN | (dpc->repl_white & 1);\r\nregw_ip(base_addr, val, DPC_LUT_SEL);\r\nregw_ip(base_addr, LUT_DPC_START_ADDR, DPC_LUT_ADR);\r\nregw_ip(base_addr, dpc->dpc_size, DPC_LUT_SIZ & LUT_DPC_SIZE_MASK);\r\nif (dpc->table == NULL)\r\nreturn;\r\nfor (count = 0; count < dpc->dpc_size; count++) {\r\nif (count >= max_tbl_size)\r\nlut_start_addr = DPC_TB1_START_ADDR;\r\nval = (dpc->table[count].horz_pos & LUT_DPC_H_POS_MASK) |\r\n((dpc->table[count].vert_pos & LUT_DPC_V_POS_MASK) <<\r\nLUT_DPC_V_POS_SHIFT) | (dpc->table[count].method <<\r\nLUT_DPC_CORR_METH_SHIFT);\r\nw_ip_table(isp5_base_addr, val, (lut_start_addr +\r\n((count % max_tbl_size) << 2)));\r\n}\r\n}\r\nstatic void\r\nset_dpc_thresholds(void *__iomem base_addr,\r\nstruct vpfe_ipipe_otfdpc_2_0_cfg *dpc_thr)\r\n{\r\nregw_ip(base_addr, dpc_thr->corr_thr.r & OTFDPC_DPC2_THR_MASK,\r\nDPC_OTF_2C_THR_R);\r\nregw_ip(base_addr, dpc_thr->corr_thr.gr & OTFDPC_DPC2_THR_MASK,\r\nDPC_OTF_2C_THR_GR);\r\nregw_ip(base_addr, dpc_thr->corr_thr.gb & OTFDPC_DPC2_THR_MASK,\r\nDPC_OTF_2C_THR_GB);\r\nregw_ip(base_addr, dpc_thr->corr_thr.b & OTFDPC_DPC2_THR_MASK,\r\nDPC_OTF_2C_THR_B);\r\nregw_ip(base_addr, dpc_thr->det_thr.r & OTFDPC_DPC2_THR_MASK,\r\nDPC_OTF_2D_THR_R);\r\nregw_ip(base_addr, dpc_thr->det_thr.gr & OTFDPC_DPC2_THR_MASK,\r\nDPC_OTF_2D_THR_GR);\r\nregw_ip(base_addr, dpc_thr->det_thr.gb & OTFDPC_DPC2_THR_MASK,\r\nDPC_OTF_2D_THR_GB);\r\nregw_ip(base_addr, dpc_thr->det_thr.b & OTFDPC_DPC2_THR_MASK,\r\nDPC_OTF_2D_THR_B);\r\n}\r\nvoid ipipe_set_otfdpc_regs(void *__iomem base_addr,\r\nstruct vpfe_ipipe_otfdpc *otfdpc)\r\n{\r\nstruct vpfe_ipipe_otfdpc_2_0_cfg *dpc_2_0 = &otfdpc->alg_cfg.dpc_2_0;\r\nstruct vpfe_ipipe_otfdpc_3_0_cfg *dpc_3_0 = &otfdpc->alg_cfg.dpc_3_0;\r\nu32 val;\r\nipipe_clock_enable(base_addr);\r\nregw_ip(base_addr, (otfdpc->en & 1), DPC_OTF_EN);\r\nif (!otfdpc->en)\r\nreturn;\r\nval = (otfdpc->det_method << OTF_DET_METHOD_SHIFT) | otfdpc->alg;\r\nregw_ip(base_addr, val, DPC_OTF_TYP);\r\nif (otfdpc->det_method == VPFE_IPIPE_DPC_OTF_MIN_MAX) {\r\ndpc_2_0->det_thr.r = dpc_2_0->det_thr.gb =\r\ndpc_2_0->det_thr.gr = dpc_2_0->det_thr.b = 0;\r\nset_dpc_thresholds(base_addr, dpc_2_0);\r\nreturn;\r\n}\r\nif (otfdpc->alg == VPFE_IPIPE_OTFDPC_2_0) {\r\nset_dpc_thresholds(base_addr, dpc_2_0);\r\nreturn;\r\n}\r\nregw_ip(base_addr, dpc_3_0->act_adj_shf &\r\nOTF_DPC3_0_SHF_MASK, DPC_OTF_3_SHF);\r\nregw_ip(base_addr, ((dpc_3_0->det_thr & OTF_DPC3_0_THR_MASK) <<\r\nOTF_DPC3_0_THR_SHIFT), DPC_OTF_3D_THR);\r\nregw_ip(base_addr, dpc_3_0->det_slp &\r\nOTF_DPC3_0_SLP_MASK, DPC_OTF_3D_SLP);\r\nregw_ip(base_addr, dpc_3_0->det_thr_min &\r\nOTF_DPC3_0_DET_MASK, DPC_OTF_3D_MIN);\r\nregw_ip(base_addr, dpc_3_0->det_thr_max &\r\nOTF_DPC3_0_DET_MASK, DPC_OTF_3D_MAX);\r\nregw_ip(base_addr, ((dpc_3_0->corr_thr & OTF_DPC3_0_THR_MASK) <<\r\nOTF_DPC3_0_THR_SHIFT), DPC_OTF_3C_THR);\r\nregw_ip(base_addr, dpc_3_0->corr_slp &\r\nOTF_DPC3_0_SLP_MASK, DPC_OTF_3C_SLP);\r\nregw_ip(base_addr, dpc_3_0->corr_thr_min &\r\nOTF_DPC3_0_CORR_MASK, DPC_OTF_3C_MIN);\r\nregw_ip(base_addr, dpc_3_0->corr_thr_max &\r\nOTF_DPC3_0_CORR_MASK, DPC_OTF_3C_MAX);\r\n}\r\nvoid\r\nipipe_set_d2f_regs(void *__iomem base_addr, unsigned int id,\r\nstruct vpfe_ipipe_nf *noise_filter)\r\n{\r\nu32 offset = D2F_1ST;\r\nint count;\r\nu32 val;\r\nif (id == IPIPE_D2F_2ND)\r\noffset = D2F_2ND;\r\nipipe_clock_enable(base_addr);\r\nregw_ip(base_addr, noise_filter->en & 1, offset + D2F_EN);\r\nif (!noise_filter->en)\r\nreturn;\r\nval = ((noise_filter->spread_val & D2F_SPR_VAL_MASK) <<\r\nD2F_SPR_VAL_SHIFT) | ((noise_filter->shft_val &\r\nD2F_SHFT_VAL_MASK) << D2F_SHFT_VAL_SHIFT) |\r\n(noise_filter->gr_sample_meth << D2F_SAMPLE_METH_SHIFT) |\r\n((noise_filter->apply_lsc_gain & 1) <<\r\nD2F_APPLY_LSC_GAIN_SHIFT) | D2F_USE_SPR_REG_VAL;\r\nregw_ip(base_addr, val, offset + D2F_TYP);\r\nregw_ip(base_addr, noise_filter->edge_det_min_thr &\r\nD2F_EDGE_DET_THR_MASK, offset + D2F_EDG_MIN);\r\nregw_ip(base_addr, noise_filter->edge_det_max_thr &\r\nD2F_EDGE_DET_THR_MASK, offset + D2F_EDG_MAX);\r\nfor (count = 0; count < VPFE_IPIPE_NF_STR_TABLE_SIZE; count++)\r\nregw_ip(base_addr,\r\n(noise_filter->str[count] & D2F_STR_VAL_MASK),\r\noffset + D2F_STR + count * 4);\r\nfor (count = 0; count < VPFE_IPIPE_NF_THR_TABLE_SIZE; count++)\r\nregw_ip(base_addr, noise_filter->thr[count] & D2F_THR_VAL_MASK,\r\noffset + D2F_THR + count * 4);\r\n}\r\nvoid ipipe_set_gic_regs(void *__iomem base_addr, struct vpfe_ipipe_gic *gic)\r\n{\r\nu32 val;\r\nipipe_clock_enable(base_addr);\r\nregw_ip(base_addr, gic->en & 1, GIC_EN);\r\nif (!gic->en)\r\nreturn;\r\nval = (gic->wt_fn_type << GIC_TYP_SHIFT) |\r\n(gic->thr_sel << GIC_THR_SEL_SHIFT) |\r\n((gic->apply_lsc_gain & 1) << GIC_APPLY_LSC_GAIN_SHIFT);\r\nregw_ip(base_addr, val, GIC_TYP);\r\nregw_ip(base_addr, gic->gain & GIC_GAIN_MASK, GIC_GAN);\r\nif (gic->gic_alg != VPFE_IPIPE_GIC_ALG_ADAPT_GAIN) {\r\nregw_ip(base_addr, GIC_THR_MASK, GIC_THR);\r\nreturn;\r\n}\r\nif (gic->thr_sel == VPFE_IPIPE_GIC_THR_REG) {\r\nregw_ip(base_addr, gic->thr & GIC_THR_MASK, GIC_THR);\r\nregw_ip(base_addr, gic->slope & GIC_SLOPE_MASK, GIC_SLP);\r\n} else {\r\nval = IPIPE_U8Q5(gic->nf2_thr_gain.decimal,\r\ngic->nf2_thr_gain.integer);\r\nregw_ip(base_addr, val, GIC_NFGAN);\r\n}\r\n}\r\nvoid ipipe_set_wb_regs(void *__iomem base_addr, struct vpfe_ipipe_wb *wb)\r\n{\r\nu32 val;\r\nipipe_clock_enable(base_addr);\r\nregw_ip(base_addr, wb->ofst_r & WB_OFFSET_MASK, WB2_OFT_R);\r\nregw_ip(base_addr, wb->ofst_gr & WB_OFFSET_MASK, WB2_OFT_GR);\r\nregw_ip(base_addr, wb->ofst_gb & WB_OFFSET_MASK, WB2_OFT_GB);\r\nregw_ip(base_addr, wb->ofst_b & WB_OFFSET_MASK, WB2_OFT_B);\r\nval = IPIPE_U13Q9(wb->gain_r.decimal, wb->gain_r.integer);\r\nregw_ip(base_addr, val, WB2_WGN_R);\r\nval = IPIPE_U13Q9(wb->gain_gr.decimal, wb->gain_gr.integer);\r\nregw_ip(base_addr, val, WB2_WGN_GR);\r\nval = IPIPE_U13Q9(wb->gain_gb.decimal, wb->gain_gb.integer);\r\nregw_ip(base_addr, val, WB2_WGN_GB);\r\nval = IPIPE_U13Q9(wb->gain_b.decimal, wb->gain_b.integer);\r\nregw_ip(base_addr, val, WB2_WGN_B);\r\n}\r\nvoid ipipe_set_cfa_regs(void *__iomem base_addr, struct vpfe_ipipe_cfa *cfa)\r\n{\r\nipipe_clock_enable(base_addr);\r\nregw_ip(base_addr, cfa->alg, CFA_MODE);\r\nregw_ip(base_addr, cfa->hpf_thr_2dir & CFA_HPF_THR_2DIR_MASK,\r\nCFA_2DIR_HPF_THR);\r\nregw_ip(base_addr, cfa->hpf_slp_2dir & CFA_HPF_SLOPE_2DIR_MASK,\r\nCFA_2DIR_HPF_SLP);\r\nregw_ip(base_addr, cfa->hp_mix_thr_2dir & CFA_HPF_MIX_THR_2DIR_MASK,\r\nCFA_2DIR_MIX_THR);\r\nregw_ip(base_addr, cfa->hp_mix_slope_2dir & CFA_HPF_MIX_SLP_2DIR_MASK,\r\nCFA_2DIR_MIX_SLP);\r\nregw_ip(base_addr, cfa->dir_thr_2dir & CFA_DIR_THR_2DIR_MASK,\r\nCFA_2DIR_DIR_THR);\r\nregw_ip(base_addr, cfa->dir_slope_2dir & CFA_DIR_SLP_2DIR_MASK,\r\nCFA_2DIR_DIR_SLP);\r\nregw_ip(base_addr, cfa->nd_wt_2dir & CFA_ND_WT_2DIR_MASK,\r\nCFA_2DIR_NDWT);\r\nregw_ip(base_addr, cfa->hue_fract_daa & CFA_DAA_HUE_FRA_MASK,\r\nCFA_MONO_HUE_FRA);\r\nregw_ip(base_addr, cfa->edge_thr_daa & CFA_DAA_EDG_THR_MASK,\r\nCFA_MONO_EDG_THR);\r\nregw_ip(base_addr, cfa->thr_min_daa & CFA_DAA_THR_MIN_MASK,\r\nCFA_MONO_THR_MIN);\r\nregw_ip(base_addr, cfa->thr_slope_daa & CFA_DAA_THR_SLP_MASK,\r\nCFA_MONO_THR_SLP);\r\nregw_ip(base_addr, cfa->slope_min_daa & CFA_DAA_SLP_MIN_MASK,\r\nCFA_MONO_SLP_MIN);\r\nregw_ip(base_addr, cfa->slope_slope_daa & CFA_DAA_SLP_SLP_MASK,\r\nCFA_MONO_SLP_SLP);\r\nregw_ip(base_addr, cfa->lp_wt_daa & CFA_DAA_LP_WT_MASK,\r\nCFA_MONO_LPWT);\r\n}\r\nvoid\r\nipipe_set_rgb2rgb_regs(void *__iomem base_addr, unsigned int id,\r\nstruct vpfe_ipipe_rgb2rgb *rgb)\r\n{\r\nu32 offset_mask = RGB2RGB_1_OFST_MASK;\r\nu32 offset = RGB1_MUL_BASE;\r\nu32 integ_mask = 0xf;\r\nu32 val;\r\nipipe_clock_enable(base_addr);\r\nif (id == IPIPE_RGB2RGB_2) {\r\noffset = RGB2_MUL_BASE;\r\ninteg_mask = 0x7;\r\noffset_mask = RGB2RGB_2_OFST_MASK;\r\n}\r\nval = (rgb->coef_rr.decimal & 0xff) |\r\n((rgb->coef_rr.integer & integ_mask) << 8);\r\nregw_ip(base_addr, val, offset + RGB_MUL_RR);\r\nval = (rgb->coef_gr.decimal & 0xff) |\r\n((rgb->coef_gr.integer & integ_mask) << 8);\r\nregw_ip(base_addr, val, offset + RGB_MUL_GR);\r\nval = (rgb->coef_br.decimal & 0xff) |\r\n((rgb->coef_br.integer & integ_mask) << 8);\r\nregw_ip(base_addr, val, offset + RGB_MUL_BR);\r\nval = (rgb->coef_rg.decimal & 0xff) |\r\n((rgb->coef_rg.integer & integ_mask) << 8);\r\nregw_ip(base_addr, val, offset + RGB_MUL_RG);\r\nval = (rgb->coef_gg.decimal & 0xff) |\r\n((rgb->coef_gg.integer & integ_mask) << 8);\r\nregw_ip(base_addr, val, offset + RGB_MUL_GG);\r\nval = (rgb->coef_bg.decimal & 0xff) |\r\n((rgb->coef_bg.integer & integ_mask) << 8);\r\nregw_ip(base_addr, val, offset + RGB_MUL_BG);\r\nval = (rgb->coef_rb.decimal & 0xff) |\r\n((rgb->coef_rb.integer & integ_mask) << 8);\r\nregw_ip(base_addr, val, offset + RGB_MUL_RB);\r\nval = (rgb->coef_gb.decimal & 0xff) |\r\n((rgb->coef_gb.integer & integ_mask) << 8);\r\nregw_ip(base_addr, val, offset + RGB_MUL_GB);\r\nval = (rgb->coef_bb.decimal & 0xff) |\r\n((rgb->coef_bb.integer & integ_mask) << 8);\r\nregw_ip(base_addr, val, offset + RGB_MUL_BB);\r\nregw_ip(base_addr, rgb->out_ofst_r & offset_mask, offset + RGB_OFT_OR);\r\nregw_ip(base_addr, rgb->out_ofst_g & offset_mask, offset + RGB_OFT_OG);\r\nregw_ip(base_addr, rgb->out_ofst_b & offset_mask, offset + RGB_OFT_OB);\r\n}\r\nstatic void\r\nipipe_update_gamma_tbl(void *__iomem isp5_base_addr,\r\nstruct vpfe_ipipe_gamma_entry *table, int size, u32 addr)\r\n{\r\nint count;\r\nu32 val;\r\nfor (count = 0; count < size; count++) {\r\nval = table[count].slope & GAMMA_MASK;\r\nval |= (table[count].offset & GAMMA_MASK) << GAMMA_SHIFT;\r\nw_ip_table(isp5_base_addr, val, (addr + (count * 4)));\r\n}\r\n}\r\nvoid\r\nipipe_set_gamma_regs(void *__iomem base_addr, void *__iomem isp5_base_addr,\r\nstruct vpfe_ipipe_gamma *gamma)\r\n{\r\nint table_size;\r\nu32 val;\r\nipipe_clock_enable(base_addr);\r\nval = (gamma->bypass_r << GAMMA_BYPR_SHIFT) |\r\n(gamma->bypass_b << GAMMA_BYPG_SHIFT) |\r\n(gamma->bypass_g << GAMMA_BYPB_SHIFT) |\r\n(gamma->tbl_sel << GAMMA_TBL_SEL_SHIFT) |\r\n(gamma->tbl_size << GAMMA_TBL_SIZE_SHIFT);\r\nregw_ip(base_addr, val, GMM_CFG);\r\nif (gamma->tbl_sel != VPFE_IPIPE_GAMMA_TBL_RAM)\r\nreturn;\r\ntable_size = gamma->tbl_size;\r\nif (!gamma->bypass_r && gamma->table_r != NULL)\r\nipipe_update_gamma_tbl(isp5_base_addr, gamma->table_r,\r\ntable_size, GAMMA_R_START_ADDR);\r\nif (!gamma->bypass_b && gamma->table_b != NULL)\r\nipipe_update_gamma_tbl(isp5_base_addr, gamma->table_b,\r\ntable_size, GAMMA_B_START_ADDR);\r\nif (!gamma->bypass_g && gamma->table_g != NULL)\r\nipipe_update_gamma_tbl(isp5_base_addr, gamma->table_g,\r\ntable_size, GAMMA_G_START_ADDR);\r\n}\r\nvoid\r\nipipe_set_3d_lut_regs(void *__iomem base_addr, void *__iomem isp5_base_addr,\r\nstruct vpfe_ipipe_3d_lut *lut_3d)\r\n{\r\nstruct vpfe_ipipe_3d_lut_entry *tbl;\r\nu32 bnk_index;\r\nu32 tbl_index;\r\nu32 val;\r\nu32 i;\r\nipipe_clock_enable(base_addr);\r\nregw_ip(base_addr, lut_3d->en, D3LUT_EN);\r\nif (!lut_3d->en)\r\nreturn;\r\nif (!lut_3d->table)\r\nreturn;\r\ntbl = lut_3d->table;\r\nfor (i = 0; i < VPFE_IPIPE_MAX_SIZE_3D_LUT; i++) {\r\nval = tbl[i].b & D3_LUT_ENTRY_MASK;\r\nval |= (tbl[i].g & D3_LUT_ENTRY_MASK) <<\r\nD3_LUT_ENTRY_G_SHIFT;\r\nval |= (tbl[i].r & D3_LUT_ENTRY_MASK) <<\r\nD3_LUT_ENTRY_R_SHIFT;\r\nbnk_index = i % 4;\r\ntbl_index = i >> 2;\r\ntbl_index <<= 2;\r\nif (bnk_index == 0)\r\nw_ip_table(isp5_base_addr, val,\r\ntbl_index + D3L_TB0_START_ADDR);\r\nelse if (bnk_index == 1)\r\nw_ip_table(isp5_base_addr, val,\r\ntbl_index + D3L_TB1_START_ADDR);\r\nelse if (bnk_index == 2)\r\nw_ip_table(isp5_base_addr, val,\r\ntbl_index + D3L_TB2_START_ADDR);\r\nelse\r\nw_ip_table(isp5_base_addr, val,\r\ntbl_index + D3L_TB3_START_ADDR);\r\n}\r\n}\r\nvoid\r\nipipe_set_lum_adj_regs(void *__iomem base_addr, struct ipipe_lum_adj *lum_adj)\r\n{\r\nu32 val;\r\nipipe_clock_enable(base_addr);\r\nval = lum_adj->contrast << LUM_ADJ_CONTR_SHIFT |\r\nlum_adj->brightness << LUM_ADJ_BRIGHT_SHIFT;\r\nregw_ip(base_addr, val, YUV_ADJ);\r\n}\r\nvoid ipipe_set_rgb2ycbcr_regs(void *__iomem base_addr,\r\nstruct vpfe_ipipe_rgb2yuv *yuv)\r\n{\r\nu32 val;\r\nipipe_clock_enable(base_addr);\r\nval = IPIPE_S12Q8(yuv->coef_ry.decimal, yuv->coef_ry.integer);\r\nregw_ip(base_addr, val, YUV_MUL_RY);\r\nval = IPIPE_S12Q8(yuv->coef_gy.decimal, yuv->coef_gy.integer);\r\nregw_ip(base_addr, val, YUV_MUL_GY);\r\nval = IPIPE_S12Q8(yuv->coef_by.decimal, yuv->coef_by.integer);\r\nregw_ip(base_addr, val, YUV_MUL_BY);\r\nval = IPIPE_S12Q8(yuv->coef_rcb.decimal, yuv->coef_rcb.integer);\r\nregw_ip(base_addr, val, YUV_MUL_RCB);\r\nval = IPIPE_S12Q8(yuv->coef_gcb.decimal, yuv->coef_gcb.integer);\r\nregw_ip(base_addr, val, YUV_MUL_GCB);\r\nval = IPIPE_S12Q8(yuv->coef_bcb.decimal, yuv->coef_bcb.integer);\r\nregw_ip(base_addr, val, YUV_MUL_BCB);\r\nval = IPIPE_S12Q8(yuv->coef_rcr.decimal, yuv->coef_rcr.integer);\r\nregw_ip(base_addr, val, YUV_MUL_RCR);\r\nval = IPIPE_S12Q8(yuv->coef_gcr.decimal, yuv->coef_gcr.integer);\r\nregw_ip(base_addr, val, YUV_MUL_GCR);\r\nval = IPIPE_S12Q8(yuv->coef_bcr.decimal, yuv->coef_bcr.integer);\r\nregw_ip(base_addr, val, YUV_MUL_BCR);\r\nregw_ip(base_addr, yuv->out_ofst_y & RGB2YCBCR_OFST_MASK, YUV_OFT_Y);\r\nregw_ip(base_addr, yuv->out_ofst_cb & RGB2YCBCR_OFST_MASK, YUV_OFT_CB);\r\nregw_ip(base_addr, yuv->out_ofst_cr & RGB2YCBCR_OFST_MASK, YUV_OFT_CR);\r\n}\r\nvoid\r\nipipe_set_yuv422_conv_regs(void *__iomem base_addr,\r\nstruct vpfe_ipipe_yuv422_conv *conv)\r\n{\r\nu32 val;\r\nipipe_clock_enable(base_addr);\r\nval = (conv->chrom_pos << 0) | (conv->en_chrom_lpf << 1);\r\nregw_ip(base_addr, val, YUV_PHS);\r\n}\r\nvoid\r\nipipe_set_gbce_regs(void *__iomem base_addr, void *__iomem isp5_base_addr,\r\nstruct vpfe_ipipe_gbce *gbce)\r\n{\r\nunsigned int count;\r\nu32 mask = GBCE_Y_VAL_MASK;\r\nif (gbce->type == VPFE_IPIPE_GBCE_GAIN_TBL)\r\nmask = GBCE_GAIN_VAL_MASK;\r\nipipe_clock_enable(base_addr);\r\nregw_ip(base_addr, gbce->en & 1, GBCE_EN);\r\nif (!gbce->en)\r\nreturn;\r\nregw_ip(base_addr, gbce->type, GBCE_TYP);\r\nif (!gbce->table)\r\nreturn;\r\nfor (count = 0; count < VPFE_IPIPE_MAX_SIZE_GBCE_LUT; count += 2)\r\nw_ip_table(isp5_base_addr, ((gbce->table[count + 1] & mask) <<\r\nGBCE_ENTRY_SHIFT) | (gbce->table[count] & mask),\r\n((count/2) << 2) + GBCE_TB_START_ADDR);\r\n}\r\nvoid\r\nipipe_set_ee_regs(void *__iomem base_addr, void *__iomem isp5_base_addr,\r\nstruct vpfe_ipipe_yee *ee)\r\n{\r\nunsigned int count;\r\nu32 val;\r\nipipe_clock_enable(base_addr);\r\nregw_ip(base_addr, ee->en, YEE_EN);\r\nif (!ee->en)\r\nreturn;\r\nval = ee->en_halo_red & 1;\r\nval |= ee->merge_meth << YEE_HALO_RED_EN_SHIFT;\r\nregw_ip(base_addr, val, YEE_TYP);\r\nregw_ip(base_addr, ee->hpf_shft, YEE_SHF);\r\nregw_ip(base_addr, ee->hpf_coef_00 & YEE_COEF_MASK, YEE_MUL_00);\r\nregw_ip(base_addr, ee->hpf_coef_01 & YEE_COEF_MASK, YEE_MUL_01);\r\nregw_ip(base_addr, ee->hpf_coef_02 & YEE_COEF_MASK, YEE_MUL_02);\r\nregw_ip(base_addr, ee->hpf_coef_10 & YEE_COEF_MASK, YEE_MUL_10);\r\nregw_ip(base_addr, ee->hpf_coef_11 & YEE_COEF_MASK, YEE_MUL_11);\r\nregw_ip(base_addr, ee->hpf_coef_12 & YEE_COEF_MASK, YEE_MUL_12);\r\nregw_ip(base_addr, ee->hpf_coef_20 & YEE_COEF_MASK, YEE_MUL_20);\r\nregw_ip(base_addr, ee->hpf_coef_21 & YEE_COEF_MASK, YEE_MUL_21);\r\nregw_ip(base_addr, ee->hpf_coef_22 & YEE_COEF_MASK, YEE_MUL_22);\r\nregw_ip(base_addr, ee->yee_thr & YEE_THR_MASK, YEE_THR);\r\nregw_ip(base_addr, ee->es_gain & YEE_ES_GAIN_MASK, YEE_E_GAN);\r\nregw_ip(base_addr, ee->es_thr1 & YEE_ES_THR1_MASK, YEE_E_THR1);\r\nregw_ip(base_addr, ee->es_thr2 & YEE_THR_MASK, YEE_E_THR2);\r\nregw_ip(base_addr, ee->es_gain_grad & YEE_THR_MASK, YEE_G_GAN);\r\nregw_ip(base_addr, ee->es_ofst_grad & YEE_THR_MASK, YEE_G_OFT);\r\nif (ee->table == NULL)\r\nreturn;\r\nfor (count = 0; count < VPFE_IPIPE_MAX_SIZE_YEE_LUT; count += 2)\r\nw_ip_table(isp5_base_addr, ((ee->table[count + 1] &\r\nYEE_ENTRY_MASK) << YEE_ENTRY_SHIFT) |\r\n(ee->table[count] & YEE_ENTRY_MASK),\r\n((count/2) << 2) + YEE_TB_START_ADDR);\r\n}\r\nstatic void ipipe_set_mf(void *__iomem base_addr)\r\n{\r\nregw_ip(base_addr, VPFE_IPIPE_CAR_DYN_SWITCH, CAR_TYP);\r\nregw_ip(base_addr, CAR_MF_THR, CAR_SW);\r\n}\r\nstatic void\r\nipipe_set_gain_ctrl(void *__iomem base_addr, struct vpfe_ipipe_car *car)\r\n{\r\nregw_ip(base_addr, VPFE_IPIPE_CAR_CHR_GAIN_CTRL, CAR_TYP);\r\nregw_ip(base_addr, car->hpf, CAR_HPF_TYP);\r\nregw_ip(base_addr, car->hpf_shft & CAR_HPF_SHIFT_MASK, CAR_HPF_SHF);\r\nregw_ip(base_addr, car->hpf_thr, CAR_HPF_THR);\r\nregw_ip(base_addr, car->gain1.gain, CAR_GN1_GAN);\r\nregw_ip(base_addr, car->gain1.shft & CAR_GAIN1_SHFT_MASK, CAR_GN1_SHF);\r\nregw_ip(base_addr, car->gain1.gain_min & CAR_GAIN_MIN_MASK,\r\nCAR_GN1_MIN);\r\nregw_ip(base_addr, car->gain2.gain, CAR_GN2_GAN);\r\nregw_ip(base_addr, car->gain2.shft & CAR_GAIN2_SHFT_MASK, CAR_GN2_SHF);\r\nregw_ip(base_addr, car->gain2.gain_min & CAR_GAIN_MIN_MASK,\r\nCAR_GN2_MIN);\r\n}\r\nvoid ipipe_set_car_regs(void *__iomem base_addr, struct vpfe_ipipe_car *car)\r\n{\r\nu32 val;\r\nipipe_clock_enable(base_addr);\r\nregw_ip(base_addr, car->en, CAR_EN);\r\nif (!car->en)\r\nreturn;\r\nswitch (car->meth) {\r\ncase VPFE_IPIPE_CAR_MED_FLTR:\r\nipipe_set_mf(base_addr);\r\nbreak;\r\ncase VPFE_IPIPE_CAR_CHR_GAIN_CTRL:\r\nipipe_set_gain_ctrl(base_addr, car);\r\nbreak;\r\ndefault:\r\nipipe_set_mf(base_addr);\r\nipipe_set_gain_ctrl(base_addr, car);\r\nregw_ip(base_addr, VPFE_IPIPE_CAR_DYN_SWITCH, CAR_TYP);\r\nval = car->sw1;\r\nval <<= CAR_SW1_SHIFT;\r\nval |= car->sw0;\r\nregw_ip(base_addr, val, CAR_SW);\r\n}\r\n}\r\nvoid ipipe_set_cgs_regs(void *__iomem base_addr, struct vpfe_ipipe_cgs *cgs)\r\n{\r\nipipe_clock_enable(base_addr);\r\nregw_ip(base_addr, cgs->en, CGS_EN);\r\nif (!cgs->en)\r\nreturn;\r\nregw_ip(base_addr, cgs->h_thr, CGS_GN1_H_THR);\r\nregw_ip(base_addr, cgs->h_slope, CGS_GN1_H_GAN);\r\nregw_ip(base_addr, cgs->h_shft & CAR_SHIFT_MASK, CGS_GN1_H_SHF);\r\nregw_ip(base_addr, cgs->h_min, CGS_GN1_H_MIN);\r\n}\r\nvoid rsz_src_enable(void *__iomem rsz_base, int enable)\r\n{\r\nregw_rsz(rsz_base, enable, RSZ_SRC_EN);\r\n}\r\nint rsz_enable(void *__iomem rsz_base, int rsz_id, int enable)\r\n{\r\nif (rsz_id == RSZ_A) {\r\nregw_rsz(rsz_base, enable, RSZ_EN_A);\r\nregw_rsz(rsz_base, enable, RSZ_SRC_EN);\r\n} else if (rsz_id == RSZ_B) {\r\nregw_rsz(rsz_base, enable, RSZ_EN_B);\r\n} else {\r\nBUG();\r\n}\r\nreturn 0;\r\n}
