int btrfs_init_dev_replace(struct btrfs_fs_info *fs_info)\r\n{\r\nstruct btrfs_key key;\r\nstruct btrfs_root *dev_root = fs_info->dev_root;\r\nstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\r\nstruct extent_buffer *eb;\r\nint slot;\r\nint ret = 0;\r\nstruct btrfs_path *path = NULL;\r\nint item_size;\r\nstruct btrfs_dev_replace_item *ptr;\r\nu64 src_devid;\r\npath = btrfs_alloc_path();\r\nif (!path) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nkey.objectid = 0;\r\nkey.type = BTRFS_DEV_REPLACE_KEY;\r\nkey.offset = 0;\r\nret = btrfs_search_slot(NULL, dev_root, &key, path, 0, 0);\r\nif (ret) {\r\nno_valid_dev_replace_entry_found:\r\nret = 0;\r\ndev_replace->replace_state =\r\nBTRFS_DEV_REPLACE_ITEM_STATE_NEVER_STARTED;\r\ndev_replace->cont_reading_from_srcdev_mode =\r\nBTRFS_DEV_REPLACE_ITEM_CONT_READING_FROM_SRCDEV_MODE_ALWAYS;\r\ndev_replace->replace_state = 0;\r\ndev_replace->time_started = 0;\r\ndev_replace->time_stopped = 0;\r\natomic64_set(&dev_replace->num_write_errors, 0);\r\natomic64_set(&dev_replace->num_uncorrectable_read_errors, 0);\r\ndev_replace->cursor_left = 0;\r\ndev_replace->committed_cursor_left = 0;\r\ndev_replace->cursor_left_last_write_of_item = 0;\r\ndev_replace->cursor_right = 0;\r\ndev_replace->srcdev = NULL;\r\ndev_replace->tgtdev = NULL;\r\ndev_replace->is_valid = 0;\r\ndev_replace->item_needs_writeback = 0;\r\ngoto out;\r\n}\r\nslot = path->slots[0];\r\neb = path->nodes[0];\r\nitem_size = btrfs_item_size_nr(eb, slot);\r\nptr = btrfs_item_ptr(eb, slot, struct btrfs_dev_replace_item);\r\nif (item_size != sizeof(struct btrfs_dev_replace_item)) {\r\nbtrfs_warn(fs_info,\r\n"dev_replace entry found has unexpected size, ignore entry");\r\ngoto no_valid_dev_replace_entry_found;\r\n}\r\nsrc_devid = btrfs_dev_replace_src_devid(eb, ptr);\r\ndev_replace->cont_reading_from_srcdev_mode =\r\nbtrfs_dev_replace_cont_reading_from_srcdev_mode(eb, ptr);\r\ndev_replace->replace_state = btrfs_dev_replace_replace_state(eb, ptr);\r\ndev_replace->time_started = btrfs_dev_replace_time_started(eb, ptr);\r\ndev_replace->time_stopped =\r\nbtrfs_dev_replace_time_stopped(eb, ptr);\r\natomic64_set(&dev_replace->num_write_errors,\r\nbtrfs_dev_replace_num_write_errors(eb, ptr));\r\natomic64_set(&dev_replace->num_uncorrectable_read_errors,\r\nbtrfs_dev_replace_num_uncorrectable_read_errors(eb, ptr));\r\ndev_replace->cursor_left = btrfs_dev_replace_cursor_left(eb, ptr);\r\ndev_replace->committed_cursor_left = dev_replace->cursor_left;\r\ndev_replace->cursor_left_last_write_of_item = dev_replace->cursor_left;\r\ndev_replace->cursor_right = btrfs_dev_replace_cursor_right(eb, ptr);\r\ndev_replace->is_valid = 1;\r\ndev_replace->item_needs_writeback = 0;\r\nswitch (dev_replace->replace_state) {\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\r\ndev_replace->srcdev = NULL;\r\ndev_replace->tgtdev = NULL;\r\nbreak;\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\r\ndev_replace->srcdev = btrfs_find_device(fs_info, src_devid,\r\nNULL, NULL);\r\ndev_replace->tgtdev = btrfs_find_device(fs_info,\r\nBTRFS_DEV_REPLACE_DEVID,\r\nNULL, NULL);\r\nif (!dev_replace->srcdev &&\r\n!btrfs_test_opt(dev_root, DEGRADED)) {\r\nret = -EIO;\r\nbtrfs_warn(fs_info,\r\n"cannot mount because device replace operation is ongoing and");\r\nbtrfs_warn(fs_info,\r\n"srcdev (devid %llu) is missing, need to run 'btrfs dev scan'?",\r\nsrc_devid);\r\n}\r\nif (!dev_replace->tgtdev &&\r\n!btrfs_test_opt(dev_root, DEGRADED)) {\r\nret = -EIO;\r\nbtrfs_warn(fs_info,\r\n"cannot mount because device replace operation is ongoing and");\r\nbtrfs_warn(fs_info,\r\n"tgtdev (devid %llu) is missing, need to run 'btrfs dev scan'?",\r\nBTRFS_DEV_REPLACE_DEVID);\r\n}\r\nif (dev_replace->tgtdev) {\r\nif (dev_replace->srcdev) {\r\ndev_replace->tgtdev->total_bytes =\r\ndev_replace->srcdev->total_bytes;\r\ndev_replace->tgtdev->disk_total_bytes =\r\ndev_replace->srcdev->disk_total_bytes;\r\ndev_replace->tgtdev->bytes_used =\r\ndev_replace->srcdev->bytes_used;\r\n}\r\ndev_replace->tgtdev->is_tgtdev_for_dev_replace = 1;\r\nbtrfs_init_dev_replace_tgtdev_for_resume(fs_info,\r\ndev_replace->tgtdev);\r\n}\r\nbreak;\r\n}\r\nout:\r\nif (path)\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nint btrfs_run_dev_replace(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info)\r\n{\r\nint ret;\r\nstruct btrfs_root *dev_root = fs_info->dev_root;\r\nstruct btrfs_path *path;\r\nstruct btrfs_key key;\r\nstruct extent_buffer *eb;\r\nstruct btrfs_dev_replace_item *ptr;\r\nstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\r\nbtrfs_dev_replace_lock(dev_replace);\r\nif (!dev_replace->is_valid ||\r\n!dev_replace->item_needs_writeback) {\r\nbtrfs_dev_replace_unlock(dev_replace);\r\nreturn 0;\r\n}\r\nbtrfs_dev_replace_unlock(dev_replace);\r\nkey.objectid = 0;\r\nkey.type = BTRFS_DEV_REPLACE_KEY;\r\nkey.offset = 0;\r\npath = btrfs_alloc_path();\r\nif (!path) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = btrfs_search_slot(trans, dev_root, &key, path, -1, 1);\r\nif (ret < 0) {\r\nbtrfs_warn(fs_info, "error %d while searching for dev_replace item!",\r\nret);\r\ngoto out;\r\n}\r\nif (ret == 0 &&\r\nbtrfs_item_size_nr(path->nodes[0], path->slots[0]) < sizeof(*ptr)) {\r\nret = btrfs_del_item(trans, dev_root, path);\r\nif (ret != 0) {\r\nbtrfs_warn(fs_info, "delete too small dev_replace item failed %d!",\r\nret);\r\ngoto out;\r\n}\r\nret = 1;\r\n}\r\nif (ret == 1) {\r\nbtrfs_release_path(path);\r\nret = btrfs_insert_empty_item(trans, dev_root, path,\r\n&key, sizeof(*ptr));\r\nif (ret < 0) {\r\nbtrfs_warn(fs_info, "insert dev_replace item failed %d!",\r\nret);\r\ngoto out;\r\n}\r\n}\r\neb = path->nodes[0];\r\nptr = btrfs_item_ptr(eb, path->slots[0],\r\nstruct btrfs_dev_replace_item);\r\nbtrfs_dev_replace_lock(dev_replace);\r\nif (dev_replace->srcdev)\r\nbtrfs_set_dev_replace_src_devid(eb, ptr,\r\ndev_replace->srcdev->devid);\r\nelse\r\nbtrfs_set_dev_replace_src_devid(eb, ptr, (u64)-1);\r\nbtrfs_set_dev_replace_cont_reading_from_srcdev_mode(eb, ptr,\r\ndev_replace->cont_reading_from_srcdev_mode);\r\nbtrfs_set_dev_replace_replace_state(eb, ptr,\r\ndev_replace->replace_state);\r\nbtrfs_set_dev_replace_time_started(eb, ptr, dev_replace->time_started);\r\nbtrfs_set_dev_replace_time_stopped(eb, ptr, dev_replace->time_stopped);\r\nbtrfs_set_dev_replace_num_write_errors(eb, ptr,\r\natomic64_read(&dev_replace->num_write_errors));\r\nbtrfs_set_dev_replace_num_uncorrectable_read_errors(eb, ptr,\r\natomic64_read(&dev_replace->num_uncorrectable_read_errors));\r\ndev_replace->cursor_left_last_write_of_item =\r\ndev_replace->cursor_left;\r\nbtrfs_set_dev_replace_cursor_left(eb, ptr,\r\ndev_replace->cursor_left_last_write_of_item);\r\nbtrfs_set_dev_replace_cursor_right(eb, ptr,\r\ndev_replace->cursor_right);\r\ndev_replace->item_needs_writeback = 0;\r\nbtrfs_dev_replace_unlock(dev_replace);\r\nbtrfs_mark_buffer_dirty(eb);\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nvoid btrfs_after_dev_replace_commit(struct btrfs_fs_info *fs_info)\r\n{\r\nstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\r\ndev_replace->committed_cursor_left =\r\ndev_replace->cursor_left_last_write_of_item;\r\n}\r\nint btrfs_dev_replace_start(struct btrfs_root *root,\r\nstruct btrfs_ioctl_dev_replace_args *args)\r\n{\r\nstruct btrfs_trans_handle *trans;\r\nstruct btrfs_fs_info *fs_info = root->fs_info;\r\nstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\r\nint ret;\r\nstruct btrfs_device *tgt_device = NULL;\r\nstruct btrfs_device *src_device = NULL;\r\nif (btrfs_fs_incompat(fs_info, RAID56)) {\r\nbtrfs_warn(fs_info, "dev_replace cannot yet handle RAID5/RAID6");\r\nreturn -EOPNOTSUPP;\r\n}\r\nswitch (args->start.cont_reading_from_srcdev_mode) {\r\ncase BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_ALWAYS:\r\ncase BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_AVOID:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif ((args->start.srcdevid == 0 && args->start.srcdev_name[0] == '\0') ||\r\nargs->start.tgtdev_name[0] == '\0')\r\nreturn -EINVAL;\r\nmutex_lock(&fs_info->volume_mutex);\r\nret = btrfs_init_dev_replace_tgtdev(root, args->start.tgtdev_name,\r\n&tgt_device);\r\nif (ret) {\r\nbtrfs_err(fs_info, "target device %s is invalid!",\r\nargs->start.tgtdev_name);\r\nmutex_unlock(&fs_info->volume_mutex);\r\nreturn -EINVAL;\r\n}\r\nret = btrfs_dev_replace_find_srcdev(root, args->start.srcdevid,\r\nargs->start.srcdev_name,\r\n&src_device);\r\nmutex_unlock(&fs_info->volume_mutex);\r\nif (ret) {\r\nret = -EINVAL;\r\ngoto leave_no_lock;\r\n}\r\nif (tgt_device->total_bytes < src_device->total_bytes) {\r\nbtrfs_err(fs_info, "target device is smaller than source device!");\r\nret = -EINVAL;\r\ngoto leave_no_lock;\r\n}\r\nbtrfs_dev_replace_lock(dev_replace);\r\nswitch (dev_replace->replace_state) {\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\r\nbreak;\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\r\nargs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_ALREADY_STARTED;\r\ngoto leave;\r\n}\r\ndev_replace->cont_reading_from_srcdev_mode =\r\nargs->start.cont_reading_from_srcdev_mode;\r\nWARN_ON(!src_device);\r\ndev_replace->srcdev = src_device;\r\nWARN_ON(!tgt_device);\r\ndev_replace->tgtdev = tgt_device;\r\nprintk_in_rcu(KERN_INFO\r\n"BTRFS: dev_replace from %s (devid %llu) to %s started\n",\r\nsrc_device->missing ? "<missing disk>" :\r\nrcu_str_deref(src_device->name),\r\nsrc_device->devid,\r\nrcu_str_deref(tgt_device->name));\r\ntgt_device->total_bytes = src_device->total_bytes;\r\ntgt_device->disk_total_bytes = src_device->disk_total_bytes;\r\ntgt_device->bytes_used = src_device->bytes_used;\r\ndev_replace->replace_state = BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED;\r\ndev_replace->time_started = get_seconds();\r\ndev_replace->cursor_left = 0;\r\ndev_replace->committed_cursor_left = 0;\r\ndev_replace->cursor_left_last_write_of_item = 0;\r\ndev_replace->cursor_right = 0;\r\ndev_replace->is_valid = 1;\r\ndev_replace->item_needs_writeback = 1;\r\nargs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR;\r\nbtrfs_dev_replace_unlock(dev_replace);\r\nbtrfs_wait_ordered_roots(root->fs_info, -1);\r\ntrans = btrfs_start_transaction(root, 0);\r\nif (IS_ERR(trans)) {\r\nret = PTR_ERR(trans);\r\nbtrfs_dev_replace_lock(dev_replace);\r\ngoto leave;\r\n}\r\nret = btrfs_commit_transaction(trans, root);\r\nWARN_ON(ret);\r\nret = btrfs_scrub_dev(fs_info, src_device->devid, 0,\r\nsrc_device->total_bytes,\r\n&dev_replace->scrub_progress, 0, 1);\r\nret = btrfs_dev_replace_finishing(root->fs_info, ret);\r\nWARN_ON(ret);\r\nreturn 0;\r\nleave:\r\ndev_replace->srcdev = NULL;\r\ndev_replace->tgtdev = NULL;\r\nbtrfs_dev_replace_unlock(dev_replace);\r\nleave_no_lock:\r\nif (tgt_device)\r\nbtrfs_destroy_dev_replace_tgtdev(fs_info, tgt_device);\r\nreturn ret;\r\n}\r\nstatic void btrfs_rm_dev_replace_blocked(struct btrfs_fs_info *fs_info)\r\n{\r\ns64 writers;\r\nDEFINE_WAIT(wait);\r\nset_bit(BTRFS_FS_STATE_DEV_REPLACING, &fs_info->fs_state);\r\ndo {\r\nprepare_to_wait(&fs_info->replace_wait, &wait,\r\nTASK_UNINTERRUPTIBLE);\r\nwriters = percpu_counter_sum(&fs_info->bio_counter);\r\nif (writers)\r\nschedule();\r\nfinish_wait(&fs_info->replace_wait, &wait);\r\n} while (writers);\r\n}\r\nstatic void btrfs_rm_dev_replace_unblocked(struct btrfs_fs_info *fs_info)\r\n{\r\nclear_bit(BTRFS_FS_STATE_DEV_REPLACING, &fs_info->fs_state);\r\nif (waitqueue_active(&fs_info->replace_wait))\r\nwake_up(&fs_info->replace_wait);\r\n}\r\nstatic int btrfs_dev_replace_finishing(struct btrfs_fs_info *fs_info,\r\nint scrub_ret)\r\n{\r\nstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\r\nstruct btrfs_device *tgt_device;\r\nstruct btrfs_device *src_device;\r\nstruct btrfs_root *root = fs_info->tree_root;\r\nu8 uuid_tmp[BTRFS_UUID_SIZE];\r\nstruct btrfs_trans_handle *trans;\r\nint ret = 0;\r\nmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\r\nbtrfs_dev_replace_lock(dev_replace);\r\nif (dev_replace->replace_state !=\r\nBTRFS_IOCTL_DEV_REPLACE_STATE_STARTED) {\r\nbtrfs_dev_replace_unlock(dev_replace);\r\nmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\r\nreturn 0;\r\n}\r\ntgt_device = dev_replace->tgtdev;\r\nsrc_device = dev_replace->srcdev;\r\nbtrfs_dev_replace_unlock(dev_replace);\r\nret = btrfs_start_delalloc_roots(root->fs_info, 0, -1);\r\nif (ret) {\r\nmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\r\nreturn ret;\r\n}\r\nbtrfs_wait_ordered_roots(root->fs_info, -1);\r\ntrans = btrfs_start_transaction(root, 0);\r\nif (IS_ERR(trans)) {\r\nmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\r\nreturn PTR_ERR(trans);\r\n}\r\nret = btrfs_commit_transaction(trans, root);\r\nWARN_ON(ret);\r\nmutex_lock(&root->fs_info->chunk_mutex);\r\nmutex_lock(&root->fs_info->fs_devices->device_list_mutex);\r\nbtrfs_dev_replace_lock(dev_replace);\r\ndev_replace->replace_state =\r\nscrub_ret ? BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED\r\n: BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED;\r\ndev_replace->tgtdev = NULL;\r\ndev_replace->srcdev = NULL;\r\ndev_replace->time_stopped = get_seconds();\r\ndev_replace->item_needs_writeback = 1;\r\nif (!scrub_ret) {\r\nbtrfs_dev_replace_update_device_in_mapping_tree(fs_info,\r\nsrc_device,\r\ntgt_device);\r\n} else {\r\nprintk_in_rcu(KERN_ERR\r\n"BTRFS: btrfs_scrub_dev(%s, %llu, %s) failed %d\n",\r\nsrc_device->missing ? "<missing disk>" :\r\nrcu_str_deref(src_device->name),\r\nsrc_device->devid,\r\nrcu_str_deref(tgt_device->name), scrub_ret);\r\nbtrfs_dev_replace_unlock(dev_replace);\r\nmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\r\nmutex_unlock(&root->fs_info->chunk_mutex);\r\nif (tgt_device)\r\nbtrfs_destroy_dev_replace_tgtdev(fs_info, tgt_device);\r\nmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\r\nreturn 0;\r\n}\r\nprintk_in_rcu(KERN_INFO\r\n"BTRFS: dev_replace from %s (devid %llu) to %s) finished\n",\r\nsrc_device->missing ? "<missing disk>" :\r\nrcu_str_deref(src_device->name),\r\nsrc_device->devid,\r\nrcu_str_deref(tgt_device->name));\r\ntgt_device->is_tgtdev_for_dev_replace = 0;\r\ntgt_device->devid = src_device->devid;\r\nsrc_device->devid = BTRFS_DEV_REPLACE_DEVID;\r\ntgt_device->bytes_used = src_device->bytes_used;\r\nmemcpy(uuid_tmp, tgt_device->uuid, sizeof(uuid_tmp));\r\nmemcpy(tgt_device->uuid, src_device->uuid, sizeof(tgt_device->uuid));\r\nmemcpy(src_device->uuid, uuid_tmp, sizeof(src_device->uuid));\r\ntgt_device->total_bytes = src_device->total_bytes;\r\ntgt_device->disk_total_bytes = src_device->disk_total_bytes;\r\ntgt_device->bytes_used = src_device->bytes_used;\r\nif (fs_info->sb->s_bdev == src_device->bdev)\r\nfs_info->sb->s_bdev = tgt_device->bdev;\r\nif (fs_info->fs_devices->latest_bdev == src_device->bdev)\r\nfs_info->fs_devices->latest_bdev = tgt_device->bdev;\r\nlist_add(&tgt_device->dev_alloc_list, &fs_info->fs_devices->alloc_list);\r\nbtrfs_kobj_rm_device(fs_info, src_device);\r\nbtrfs_kobj_add_device(fs_info, tgt_device);\r\nbtrfs_rm_dev_replace_blocked(fs_info);\r\nbtrfs_rm_dev_replace_srcdev(fs_info, src_device);\r\nbtrfs_rm_dev_replace_unblocked(fs_info);\r\nbtrfs_dev_replace_unlock(dev_replace);\r\nmutex_unlock(&root->fs_info->fs_devices->device_list_mutex);\r\nmutex_unlock(&root->fs_info->chunk_mutex);\r\ntrans = btrfs_start_transaction(root, 0);\r\nif (!IS_ERR(trans))\r\nbtrfs_commit_transaction(trans, root);\r\nmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\r\nreturn 0;\r\n}\r\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\r\nstruct btrfs_fs_info *fs_info,\r\nstruct btrfs_device *srcdev,\r\nstruct btrfs_device *tgtdev)\r\n{\r\nstruct extent_map_tree *em_tree = &fs_info->mapping_tree.map_tree;\r\nstruct extent_map *em;\r\nstruct map_lookup *map;\r\nu64 start = 0;\r\nint i;\r\nwrite_lock(&em_tree->lock);\r\ndo {\r\nem = lookup_extent_mapping(em_tree, start, (u64)-1);\r\nif (!em)\r\nbreak;\r\nmap = (struct map_lookup *)em->bdev;\r\nfor (i = 0; i < map->num_stripes; i++)\r\nif (srcdev == map->stripes[i].dev)\r\nmap->stripes[i].dev = tgtdev;\r\nstart = em->start + em->len;\r\nfree_extent_map(em);\r\n} while (start);\r\nwrite_unlock(&em_tree->lock);\r\n}\r\nstatic int btrfs_dev_replace_find_srcdev(struct btrfs_root *root, u64 srcdevid,\r\nchar *srcdev_name,\r\nstruct btrfs_device **device)\r\n{\r\nint ret;\r\nif (srcdevid) {\r\nret = 0;\r\n*device = btrfs_find_device(root->fs_info, srcdevid, NULL,\r\nNULL);\r\nif (!*device)\r\nret = -ENOENT;\r\n} else {\r\nret = btrfs_find_device_missing_or_by_path(root, srcdev_name,\r\ndevice);\r\n}\r\nreturn ret;\r\n}\r\nvoid btrfs_dev_replace_status(struct btrfs_fs_info *fs_info,\r\nstruct btrfs_ioctl_dev_replace_args *args)\r\n{\r\nstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\r\nbtrfs_dev_replace_lock(dev_replace);\r\nargs->result = BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR;\r\nargs->status.replace_state = dev_replace->replace_state;\r\nargs->status.time_started = dev_replace->time_started;\r\nargs->status.time_stopped = dev_replace->time_stopped;\r\nargs->status.num_write_errors =\r\natomic64_read(&dev_replace->num_write_errors);\r\nargs->status.num_uncorrectable_read_errors =\r\natomic64_read(&dev_replace->num_uncorrectable_read_errors);\r\nswitch (dev_replace->replace_state) {\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\r\nargs->status.progress_1000 = 0;\r\nbreak;\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\r\nargs->status.progress_1000 = 1000;\r\nbreak;\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\r\nargs->status.progress_1000 = div64_u64(dev_replace->cursor_left,\r\ndiv64_u64(dev_replace->srcdev->total_bytes, 1000));\r\nbreak;\r\n}\r\nbtrfs_dev_replace_unlock(dev_replace);\r\n}\r\nint btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info,\r\nstruct btrfs_ioctl_dev_replace_args *args)\r\n{\r\nargs->result = __btrfs_dev_replace_cancel(fs_info);\r\nreturn 0;\r\n}\r\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info)\r\n{\r\nstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\r\nstruct btrfs_device *tgt_device = NULL;\r\nstruct btrfs_trans_handle *trans;\r\nstruct btrfs_root *root = fs_info->tree_root;\r\nu64 result;\r\nint ret;\r\nif (fs_info->sb->s_flags & MS_RDONLY)\r\nreturn -EROFS;\r\nmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\r\nbtrfs_dev_replace_lock(dev_replace);\r\nswitch (dev_replace->replace_state) {\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\r\nresult = BTRFS_IOCTL_DEV_REPLACE_RESULT_NOT_STARTED;\r\nbtrfs_dev_replace_unlock(dev_replace);\r\ngoto leave;\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\r\nresult = BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR;\r\ntgt_device = dev_replace->tgtdev;\r\ndev_replace->tgtdev = NULL;\r\ndev_replace->srcdev = NULL;\r\nbreak;\r\n}\r\ndev_replace->replace_state = BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED;\r\ndev_replace->time_stopped = get_seconds();\r\ndev_replace->item_needs_writeback = 1;\r\nbtrfs_dev_replace_unlock(dev_replace);\r\nbtrfs_scrub_cancel(fs_info);\r\ntrans = btrfs_start_transaction(root, 0);\r\nif (IS_ERR(trans)) {\r\nmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\r\nreturn PTR_ERR(trans);\r\n}\r\nret = btrfs_commit_transaction(trans, root);\r\nWARN_ON(ret);\r\nif (tgt_device)\r\nbtrfs_destroy_dev_replace_tgtdev(fs_info, tgt_device);\r\nleave:\r\nmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\r\nreturn result;\r\n}\r\nvoid btrfs_dev_replace_suspend_for_unmount(struct btrfs_fs_info *fs_info)\r\n{\r\nstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\r\nmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\r\nbtrfs_dev_replace_lock(dev_replace);\r\nswitch (dev_replace->replace_state) {\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\r\nbreak;\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\r\ndev_replace->replace_state =\r\nBTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED;\r\ndev_replace->time_stopped = get_seconds();\r\ndev_replace->item_needs_writeback = 1;\r\nbtrfs_info(fs_info, "suspending dev_replace for unmount");\r\nbreak;\r\n}\r\nbtrfs_dev_replace_unlock(dev_replace);\r\nmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\r\n}\r\nint btrfs_resume_dev_replace_async(struct btrfs_fs_info *fs_info)\r\n{\r\nstruct task_struct *task;\r\nstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\r\nbtrfs_dev_replace_lock(dev_replace);\r\nswitch (dev_replace->replace_state) {\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\r\nbtrfs_dev_replace_unlock(dev_replace);\r\nreturn 0;\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\r\nbreak;\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\r\ndev_replace->replace_state =\r\nBTRFS_IOCTL_DEV_REPLACE_STATE_STARTED;\r\nbreak;\r\n}\r\nif (!dev_replace->tgtdev || !dev_replace->tgtdev->bdev) {\r\nbtrfs_info(fs_info, "cannot continue dev_replace, tgtdev is missing");\r\nbtrfs_info(fs_info,\r\n"you may cancel the operation after 'mount -o degraded'");\r\nbtrfs_dev_replace_unlock(dev_replace);\r\nreturn 0;\r\n}\r\nbtrfs_dev_replace_unlock(dev_replace);\r\nWARN_ON(atomic_xchg(\r\n&fs_info->mutually_exclusive_operation_running, 1));\r\ntask = kthread_run(btrfs_dev_replace_kthread, fs_info, "btrfs-devrepl");\r\nreturn PTR_ERR_OR_ZERO(task);\r\n}\r\nstatic int btrfs_dev_replace_kthread(void *data)\r\n{\r\nstruct btrfs_fs_info *fs_info = data;\r\nstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\r\nstruct btrfs_ioctl_dev_replace_args *status_args;\r\nu64 progress;\r\nstatus_args = kzalloc(sizeof(*status_args), GFP_NOFS);\r\nif (status_args) {\r\nbtrfs_dev_replace_status(fs_info, status_args);\r\nprogress = status_args->status.progress_1000;\r\nkfree(status_args);\r\ndo_div(progress, 10);\r\nprintk_in_rcu(KERN_INFO\r\n"BTRFS: continuing dev_replace from %s (devid %llu) to %s @%u%%\n",\r\ndev_replace->srcdev->missing ? "<missing disk>" :\r\nrcu_str_deref(dev_replace->srcdev->name),\r\ndev_replace->srcdev->devid,\r\ndev_replace->tgtdev ?\r\nrcu_str_deref(dev_replace->tgtdev->name) :\r\n"<missing target disk>",\r\n(unsigned int)progress);\r\n}\r\nbtrfs_dev_replace_continue_on_mount(fs_info);\r\natomic_set(&fs_info->mutually_exclusive_operation_running, 0);\r\nreturn 0;\r\n}\r\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info)\r\n{\r\nstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\r\nint ret;\r\nret = btrfs_scrub_dev(fs_info, dev_replace->srcdev->devid,\r\ndev_replace->committed_cursor_left,\r\ndev_replace->srcdev->total_bytes,\r\n&dev_replace->scrub_progress, 0, 1);\r\nret = btrfs_dev_replace_finishing(fs_info, ret);\r\nWARN_ON(ret);\r\nreturn 0;\r\n}\r\nint btrfs_dev_replace_is_ongoing(struct btrfs_dev_replace *dev_replace)\r\n{\r\nif (!dev_replace->is_valid)\r\nreturn 0;\r\nswitch (dev_replace->replace_state) {\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\r\nreturn 0;\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\r\ncase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nvoid btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\r\n{\r\nif (atomic_read(&dev_replace->nesting_level) == 0) {\r\nacquire_lock:\r\nmutex_lock(&dev_replace->lock);\r\nmutex_lock(&dev_replace->lock_management_lock);\r\ndev_replace->lock_owner = current->pid;\r\natomic_inc(&dev_replace->nesting_level);\r\nmutex_unlock(&dev_replace->lock_management_lock);\r\nreturn;\r\n}\r\nmutex_lock(&dev_replace->lock_management_lock);\r\nif (atomic_read(&dev_replace->nesting_level) > 0 &&\r\ndev_replace->lock_owner == current->pid) {\r\nWARN_ON(!mutex_is_locked(&dev_replace->lock));\r\natomic_inc(&dev_replace->nesting_level);\r\nmutex_unlock(&dev_replace->lock_management_lock);\r\nreturn;\r\n}\r\nmutex_unlock(&dev_replace->lock_management_lock);\r\ngoto acquire_lock;\r\n}\r\nvoid btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\r\n{\r\nWARN_ON(!mutex_is_locked(&dev_replace->lock));\r\nmutex_lock(&dev_replace->lock_management_lock);\r\nWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\r\nWARN_ON(dev_replace->lock_owner != current->pid);\r\natomic_dec(&dev_replace->nesting_level);\r\nif (atomic_read(&dev_replace->nesting_level) == 0) {\r\ndev_replace->lock_owner = 0;\r\nmutex_unlock(&dev_replace->lock_management_lock);\r\nmutex_unlock(&dev_replace->lock);\r\n} else {\r\nmutex_unlock(&dev_replace->lock_management_lock);\r\n}\r\n}\r\nvoid btrfs_bio_counter_inc_noblocked(struct btrfs_fs_info *fs_info)\r\n{\r\npercpu_counter_inc(&fs_info->bio_counter);\r\n}\r\nvoid btrfs_bio_counter_dec(struct btrfs_fs_info *fs_info)\r\n{\r\npercpu_counter_dec(&fs_info->bio_counter);\r\nif (waitqueue_active(&fs_info->replace_wait))\r\nwake_up(&fs_info->replace_wait);\r\n}\r\nvoid btrfs_bio_counter_inc_blocked(struct btrfs_fs_info *fs_info)\r\n{\r\nDEFINE_WAIT(wait);\r\nagain:\r\npercpu_counter_inc(&fs_info->bio_counter);\r\nif (test_bit(BTRFS_FS_STATE_DEV_REPLACING, &fs_info->fs_state)) {\r\nbtrfs_bio_counter_dec(fs_info);\r\nwait_event(fs_info->replace_wait,\r\n!test_bit(BTRFS_FS_STATE_DEV_REPLACING,\r\n&fs_info->fs_state));\r\ngoto again;\r\n}\r\n}
