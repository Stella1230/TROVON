static struct acm *acm_get_by_index(unsigned index)\r\n{\r\nstruct acm *acm;\r\nmutex_lock(&acm_table_lock);\r\nacm = acm_table[index];\r\nif (acm) {\r\nmutex_lock(&acm->mutex);\r\nif (acm->disconnected) {\r\nmutex_unlock(&acm->mutex);\r\nacm = NULL;\r\n} else {\r\ntty_port_get(&acm->port);\r\nmutex_unlock(&acm->mutex);\r\n}\r\n}\r\nmutex_unlock(&acm_table_lock);\r\nreturn acm;\r\n}\r\nstatic int acm_alloc_minor(struct acm *acm)\r\n{\r\nint minor;\r\nmutex_lock(&acm_table_lock);\r\nfor (minor = 0; minor < ACM_TTY_MINORS; minor++) {\r\nif (!acm_table[minor]) {\r\nacm_table[minor] = acm;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&acm_table_lock);\r\nreturn minor;\r\n}\r\nstatic void acm_release_minor(struct acm *acm)\r\n{\r\nmutex_lock(&acm_table_lock);\r\nacm_table[acm->minor] = NULL;\r\nmutex_unlock(&acm_table_lock);\r\n}\r\nstatic int acm_ctrl_msg(struct acm *acm, int request, int value,\r\nvoid *buf, int len)\r\n{\r\nint retval;\r\nretval = usb_autopm_get_interface(acm->control);\r\nif (retval)\r\nreturn retval;\r\nretval = usb_control_msg(acm->dev, usb_sndctrlpipe(acm->dev, 0),\r\nrequest, USB_RT_ACM, value,\r\nacm->control->altsetting[0].desc.bInterfaceNumber,\r\nbuf, len, 5000);\r\ndev_dbg(&acm->control->dev,\r\n"%s - rq 0x%02x, val %#x, len %#x, result %d\n",\r\n__func__, request, value, len, retval);\r\nusb_autopm_put_interface(acm->control);\r\nreturn retval < 0 ? retval : 0;\r\n}\r\nstatic int acm_wb_alloc(struct acm *acm)\r\n{\r\nint i, wbn;\r\nstruct acm_wb *wb;\r\nwbn = 0;\r\ni = 0;\r\nfor (;;) {\r\nwb = &acm->wb[wbn];\r\nif (!wb->use) {\r\nwb->use = 1;\r\nreturn wbn;\r\n}\r\nwbn = (wbn + 1) % ACM_NW;\r\nif (++i >= ACM_NW)\r\nreturn -1;\r\n}\r\n}\r\nstatic int acm_wb_is_avail(struct acm *acm)\r\n{\r\nint i, n;\r\nunsigned long flags;\r\nn = ACM_NW;\r\nspin_lock_irqsave(&acm->write_lock, flags);\r\nfor (i = 0; i < ACM_NW; i++)\r\nn -= acm->wb[i].use;\r\nspin_unlock_irqrestore(&acm->write_lock, flags);\r\nreturn n;\r\n}\r\nstatic void acm_write_done(struct acm *acm, struct acm_wb *wb)\r\n{\r\nwb->use = 0;\r\nacm->transmitting--;\r\nusb_autopm_put_interface_async(acm->control);\r\n}\r\nstatic int acm_start_wb(struct acm *acm, struct acm_wb *wb)\r\n{\r\nint rc;\r\nacm->transmitting++;\r\nwb->urb->transfer_buffer = wb->buf;\r\nwb->urb->transfer_dma = wb->dmah;\r\nwb->urb->transfer_buffer_length = wb->len;\r\nwb->urb->dev = acm->dev;\r\nrc = usb_submit_urb(wb->urb, GFP_ATOMIC);\r\nif (rc < 0) {\r\ndev_err(&acm->data->dev,\r\n"%s - usb_submit_urb(write bulk) failed: %d\n",\r\n__func__, rc);\r\nacm_write_done(acm, wb);\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t show_caps\r\n(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct acm *acm = usb_get_intfdata(intf);\r\nreturn sprintf(buf, "%d", acm->ctrl_caps);\r\n}\r\nstatic ssize_t show_country_codes\r\n(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct acm *acm = usb_get_intfdata(intf);\r\nmemcpy(buf, acm->country_codes, acm->country_code_size);\r\nreturn acm->country_code_size;\r\n}\r\nstatic ssize_t show_country_rel_date\r\n(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_interface *intf = to_usb_interface(dev);\r\nstruct acm *acm = usb_get_intfdata(intf);\r\nreturn sprintf(buf, "%d", acm->country_rel_date);\r\n}\r\nstatic void acm_ctrl_irq(struct urb *urb)\r\n{\r\nstruct acm *acm = urb->context;\r\nstruct usb_cdc_notification *dr = urb->transfer_buffer;\r\nunsigned char *data;\r\nint newctrl;\r\nint difference;\r\nint retval;\r\nint status = urb->status;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&acm->control->dev,\r\n"%s - urb shutting down with status: %d\n",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndev_dbg(&acm->control->dev,\r\n"%s - nonzero urb status received: %d\n",\r\n__func__, status);\r\ngoto exit;\r\n}\r\nusb_mark_last_busy(acm->dev);\r\ndata = (unsigned char *)(dr + 1);\r\nswitch (dr->bNotificationType) {\r\ncase USB_CDC_NOTIFY_NETWORK_CONNECTION:\r\ndev_dbg(&acm->control->dev, "%s - network connection: %d\n",\r\n__func__, dr->wValue);\r\nbreak;\r\ncase USB_CDC_NOTIFY_SERIAL_STATE:\r\nnewctrl = get_unaligned_le16(data);\r\nif (!acm->clocal && (acm->ctrlin & ~newctrl & ACM_CTRL_DCD)) {\r\ndev_dbg(&acm->control->dev, "%s - calling hangup\n",\r\n__func__);\r\ntty_port_tty_hangup(&acm->port, false);\r\n}\r\ndifference = acm->ctrlin ^ newctrl;\r\nspin_lock(&acm->read_lock);\r\nacm->ctrlin = newctrl;\r\nacm->oldcount = acm->iocount;\r\nif (difference & ACM_CTRL_DSR)\r\nacm->iocount.dsr++;\r\nif (difference & ACM_CTRL_BRK)\r\nacm->iocount.brk++;\r\nif (difference & ACM_CTRL_RI)\r\nacm->iocount.rng++;\r\nif (difference & ACM_CTRL_DCD)\r\nacm->iocount.dcd++;\r\nif (difference & ACM_CTRL_FRAMING)\r\nacm->iocount.frame++;\r\nif (difference & ACM_CTRL_PARITY)\r\nacm->iocount.parity++;\r\nif (difference & ACM_CTRL_OVERRUN)\r\nacm->iocount.overrun++;\r\nspin_unlock(&acm->read_lock);\r\nif (difference)\r\nwake_up_all(&acm->wioctl);\r\nbreak;\r\ndefault:\r\ndev_dbg(&acm->control->dev,\r\n"%s - unknown notification %d received: index %d "\r\n"len %d data0 %d data1 %d\n",\r\n__func__,\r\ndr->bNotificationType, dr->wIndex,\r\ndr->wLength, data[0], data[1]);\r\nbreak;\r\n}\r\nexit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(&acm->control->dev, "%s - usb_submit_urb failed: %d\n",\r\n__func__, retval);\r\n}\r\nstatic int acm_submit_read_urb(struct acm *acm, int index, gfp_t mem_flags)\r\n{\r\nint res;\r\nif (!test_and_clear_bit(index, &acm->read_urbs_free))\r\nreturn 0;\r\ndev_vdbg(&acm->data->dev, "%s - urb %d\n", __func__, index);\r\nres = usb_submit_urb(acm->read_urbs[index], mem_flags);\r\nif (res) {\r\nif (res != -EPERM) {\r\ndev_err(&acm->data->dev,\r\n"%s - usb_submit_urb failed: %d\n",\r\n__func__, res);\r\n}\r\nset_bit(index, &acm->read_urbs_free);\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acm_submit_read_urbs(struct acm *acm, gfp_t mem_flags)\r\n{\r\nint res;\r\nint i;\r\nfor (i = 0; i < acm->rx_buflimit; ++i) {\r\nres = acm_submit_read_urb(acm, i, mem_flags);\r\nif (res)\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic void acm_process_read_urb(struct acm *acm, struct urb *urb)\r\n{\r\nif (!urb->actual_length)\r\nreturn;\r\ntty_insert_flip_string(&acm->port, urb->transfer_buffer,\r\nurb->actual_length);\r\ntty_flip_buffer_push(&acm->port);\r\n}\r\nstatic void acm_read_bulk_callback(struct urb *urb)\r\n{\r\nstruct acm_rb *rb = urb->context;\r\nstruct acm *acm = rb->instance;\r\nunsigned long flags;\r\ndev_vdbg(&acm->data->dev, "%s - urb %d, len %d\n", __func__,\r\nrb->index, urb->actual_length);\r\nset_bit(rb->index, &acm->read_urbs_free);\r\nif (!acm->dev) {\r\ndev_dbg(&acm->data->dev, "%s - disconnected\n", __func__);\r\nreturn;\r\n}\r\nif (urb->status) {\r\ndev_dbg(&acm->data->dev, "%s - non-zero urb status: %d\n",\r\n__func__, urb->status);\r\nreturn;\r\n}\r\nusb_mark_last_busy(acm->dev);\r\nacm_process_read_urb(acm, urb);\r\nspin_lock_irqsave(&acm->read_lock, flags);\r\nacm->throttled = acm->throttle_req;\r\nif (!acm->throttled) {\r\nspin_unlock_irqrestore(&acm->read_lock, flags);\r\nacm_submit_read_urb(acm, rb->index, GFP_ATOMIC);\r\n} else {\r\nspin_unlock_irqrestore(&acm->read_lock, flags);\r\n}\r\n}\r\nstatic void acm_write_bulk(struct urb *urb)\r\n{\r\nstruct acm_wb *wb = urb->context;\r\nstruct acm *acm = wb->instance;\r\nunsigned long flags;\r\nif (urb->status || (urb->actual_length != urb->transfer_buffer_length))\r\ndev_vdbg(&acm->data->dev, "%s - len %d/%d, status %d\n",\r\n__func__,\r\nurb->actual_length,\r\nurb->transfer_buffer_length,\r\nurb->status);\r\nspin_lock_irqsave(&acm->write_lock, flags);\r\nacm_write_done(acm, wb);\r\nspin_unlock_irqrestore(&acm->write_lock, flags);\r\nschedule_work(&acm->work);\r\n}\r\nstatic void acm_softint(struct work_struct *work)\r\n{\r\nstruct acm *acm = container_of(work, struct acm, work);\r\ndev_vdbg(&acm->data->dev, "%s\n", __func__);\r\ntty_port_tty_wakeup(&acm->port);\r\n}\r\nstatic int acm_tty_install(struct tty_driver *driver, struct tty_struct *tty)\r\n{\r\nstruct acm *acm;\r\nint retval;\r\ndev_dbg(tty->dev, "%s\n", __func__);\r\nacm = acm_get_by_index(tty->index);\r\nif (!acm)\r\nreturn -ENODEV;\r\nretval = tty_standard_install(driver, tty);\r\nif (retval)\r\ngoto error_init_termios;\r\ntty->driver_data = acm;\r\nreturn 0;\r\nerror_init_termios:\r\ntty_port_put(&acm->port);\r\nreturn retval;\r\n}\r\nstatic int acm_tty_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\ndev_dbg(tty->dev, "%s\n", __func__);\r\nreturn tty_port_open(&acm->port, tty, filp);\r\n}\r\nstatic void acm_port_dtr_rts(struct tty_port *port, int raise)\r\n{\r\nstruct acm *acm = container_of(port, struct acm, port);\r\nint val;\r\nint res;\r\nif (raise)\r\nval = ACM_CTRL_DTR | ACM_CTRL_RTS;\r\nelse\r\nval = 0;\r\nacm->ctrlout = val;\r\nres = acm_set_control(acm, val);\r\nif (res && (acm->ctrl_caps & USB_CDC_CAP_LINE))\r\ndev_err(&acm->control->dev, "failed to set dtr/rts\n");\r\n}\r\nstatic int acm_port_activate(struct tty_port *port, struct tty_struct *tty)\r\n{\r\nstruct acm *acm = container_of(port, struct acm, port);\r\nint retval = -ENODEV;\r\nint i;\r\ndev_dbg(&acm->control->dev, "%s\n", __func__);\r\nmutex_lock(&acm->mutex);\r\nif (acm->disconnected)\r\ngoto disconnected;\r\nretval = usb_autopm_get_interface(acm->control);\r\nif (retval)\r\ngoto error_get_interface;\r\nset_bit(TTY_NO_WRITE_SPLIT, &tty->flags);\r\nacm->control->needs_remote_wakeup = 1;\r\nacm->ctrlurb->dev = acm->dev;\r\nretval = usb_submit_urb(acm->ctrlurb, GFP_KERNEL);\r\nif (retval) {\r\ndev_err(&acm->control->dev,\r\n"%s - usb_submit_urb(ctrl irq) failed\n", __func__);\r\ngoto error_submit_urb;\r\n}\r\nspin_lock_irq(&acm->read_lock);\r\nacm->throttled = 0;\r\nacm->throttle_req = 0;\r\nspin_unlock_irq(&acm->read_lock);\r\nretval = acm_submit_read_urbs(acm, GFP_KERNEL);\r\nif (retval)\r\ngoto error_submit_read_urbs;\r\nusb_autopm_put_interface(acm->control);\r\nmutex_unlock(&acm->mutex);\r\nreturn 0;\r\nerror_submit_read_urbs:\r\nfor (i = 0; i < acm->rx_buflimit; i++)\r\nusb_kill_urb(acm->read_urbs[i]);\r\nusb_kill_urb(acm->ctrlurb);\r\nerror_submit_urb:\r\nusb_autopm_put_interface(acm->control);\r\nerror_get_interface:\r\ndisconnected:\r\nmutex_unlock(&acm->mutex);\r\nreturn usb_translate_errors(retval);\r\n}\r\nstatic void acm_port_destruct(struct tty_port *port)\r\n{\r\nstruct acm *acm = container_of(port, struct acm, port);\r\ndev_dbg(&acm->control->dev, "%s\n", __func__);\r\nacm_release_minor(acm);\r\nusb_put_intf(acm->control);\r\nkfree(acm->country_codes);\r\nkfree(acm);\r\n}\r\nstatic void acm_port_shutdown(struct tty_port *port)\r\n{\r\nstruct acm *acm = container_of(port, struct acm, port);\r\nstruct urb *urb;\r\nstruct acm_wb *wb;\r\nint i;\r\ndev_dbg(&acm->control->dev, "%s\n", __func__);\r\nspin_lock_irq(&acm->write_lock);\r\nspin_unlock_irq(&acm->write_lock);\r\nusb_autopm_get_interface_no_resume(acm->control);\r\nacm->control->needs_remote_wakeup = 0;\r\nusb_autopm_put_interface(acm->control);\r\nfor (;;) {\r\nurb = usb_get_from_anchor(&acm->delayed);\r\nif (!urb)\r\nbreak;\r\nwb = urb->context;\r\nwb->use = 0;\r\nusb_autopm_put_interface_async(acm->control);\r\n}\r\nusb_kill_urb(acm->ctrlurb);\r\nfor (i = 0; i < ACM_NW; i++)\r\nusb_kill_urb(acm->wb[i].urb);\r\nfor (i = 0; i < acm->rx_buflimit; i++)\r\nusb_kill_urb(acm->read_urbs[i]);\r\n}\r\nstatic void acm_tty_cleanup(struct tty_struct *tty)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\ndev_dbg(&acm->control->dev, "%s\n", __func__);\r\ntty_port_put(&acm->port);\r\n}\r\nstatic void acm_tty_hangup(struct tty_struct *tty)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\ndev_dbg(&acm->control->dev, "%s\n", __func__);\r\ntty_port_hangup(&acm->port);\r\n}\r\nstatic void acm_tty_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\ndev_dbg(&acm->control->dev, "%s\n", __func__);\r\ntty_port_close(&acm->port, tty, filp);\r\n}\r\nstatic int acm_tty_write(struct tty_struct *tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\nint stat;\r\nunsigned long flags;\r\nint wbn;\r\nstruct acm_wb *wb;\r\nif (!count)\r\nreturn 0;\r\ndev_vdbg(&acm->data->dev, "%s - count %d\n", __func__, count);\r\nspin_lock_irqsave(&acm->write_lock, flags);\r\nwbn = acm_wb_alloc(acm);\r\nif (wbn < 0) {\r\nspin_unlock_irqrestore(&acm->write_lock, flags);\r\nreturn 0;\r\n}\r\nwb = &acm->wb[wbn];\r\nif (!acm->dev) {\r\nwb->use = 0;\r\nspin_unlock_irqrestore(&acm->write_lock, flags);\r\nreturn -ENODEV;\r\n}\r\ncount = (count > acm->writesize) ? acm->writesize : count;\r\ndev_vdbg(&acm->data->dev, "%s - write %d\n", __func__, count);\r\nmemcpy(wb->buf, buf, count);\r\nwb->len = count;\r\nstat = usb_autopm_get_interface_async(acm->control);\r\nif (stat) {\r\nwb->use = 0;\r\nspin_unlock_irqrestore(&acm->write_lock, flags);\r\nreturn stat;\r\n}\r\nif (acm->susp_count) {\r\nusb_anchor_urb(wb->urb, &acm->delayed);\r\nspin_unlock_irqrestore(&acm->write_lock, flags);\r\nreturn count;\r\n}\r\nstat = acm_start_wb(acm, wb);\r\nspin_unlock_irqrestore(&acm->write_lock, flags);\r\nif (stat < 0)\r\nreturn stat;\r\nreturn count;\r\n}\r\nstatic int acm_tty_write_room(struct tty_struct *tty)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\nreturn acm_wb_is_avail(acm) ? acm->writesize : 0;\r\n}\r\nstatic int acm_tty_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\nif (acm->disconnected)\r\nreturn 0;\r\nreturn (ACM_NW - acm_wb_is_avail(acm)) * acm->writesize;\r\n}\r\nstatic void acm_tty_throttle(struct tty_struct *tty)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\nspin_lock_irq(&acm->read_lock);\r\nacm->throttle_req = 1;\r\nspin_unlock_irq(&acm->read_lock);\r\n}\r\nstatic void acm_tty_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\nunsigned int was_throttled;\r\nspin_lock_irq(&acm->read_lock);\r\nwas_throttled = acm->throttled;\r\nacm->throttled = 0;\r\nacm->throttle_req = 0;\r\nspin_unlock_irq(&acm->read_lock);\r\nif (was_throttled)\r\nacm_submit_read_urbs(acm, GFP_KERNEL);\r\n}\r\nstatic int acm_tty_break_ctl(struct tty_struct *tty, int state)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\nint retval;\r\nretval = acm_send_break(acm, state ? 0xffff : 0);\r\nif (retval < 0)\r\ndev_dbg(&acm->control->dev, "%s - send break failed\n",\r\n__func__);\r\nreturn retval;\r\n}\r\nstatic int acm_tty_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\nreturn (acm->ctrlout & ACM_CTRL_DTR ? TIOCM_DTR : 0) |\r\n(acm->ctrlout & ACM_CTRL_RTS ? TIOCM_RTS : 0) |\r\n(acm->ctrlin & ACM_CTRL_DSR ? TIOCM_DSR : 0) |\r\n(acm->ctrlin & ACM_CTRL_RI ? TIOCM_RI : 0) |\r\n(acm->ctrlin & ACM_CTRL_DCD ? TIOCM_CD : 0) |\r\nTIOCM_CTS;\r\n}\r\nstatic int acm_tty_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\nunsigned int newctrl;\r\nnewctrl = acm->ctrlout;\r\nset = (set & TIOCM_DTR ? ACM_CTRL_DTR : 0) |\r\n(set & TIOCM_RTS ? ACM_CTRL_RTS : 0);\r\nclear = (clear & TIOCM_DTR ? ACM_CTRL_DTR : 0) |\r\n(clear & TIOCM_RTS ? ACM_CTRL_RTS : 0);\r\nnewctrl = (newctrl & ~clear) | set;\r\nif (acm->ctrlout == newctrl)\r\nreturn 0;\r\nreturn acm_set_control(acm, acm->ctrlout = newctrl);\r\n}\r\nstatic int get_serial_info(struct acm *acm, struct serial_struct __user *info)\r\n{\r\nstruct serial_struct tmp;\r\nif (!info)\r\nreturn -EINVAL;\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntmp.flags = ASYNC_LOW_LATENCY;\r\ntmp.xmit_fifo_size = acm->writesize;\r\ntmp.baud_base = le32_to_cpu(acm->line.dwDTERate);\r\ntmp.close_delay = acm->port.close_delay / 10;\r\ntmp.closing_wait = acm->port.closing_wait == ASYNC_CLOSING_WAIT_NONE ?\r\nASYNC_CLOSING_WAIT_NONE :\r\nacm->port.closing_wait / 10;\r\nif (copy_to_user(info, &tmp, sizeof(tmp)))\r\nreturn -EFAULT;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int set_serial_info(struct acm *acm,\r\nstruct serial_struct __user *newinfo)\r\n{\r\nstruct serial_struct new_serial;\r\nunsigned int closing_wait, close_delay;\r\nint retval = 0;\r\nif (copy_from_user(&new_serial, newinfo, sizeof(new_serial)))\r\nreturn -EFAULT;\r\nclose_delay = new_serial.close_delay * 10;\r\nclosing_wait = new_serial.closing_wait == ASYNC_CLOSING_WAIT_NONE ?\r\nASYNC_CLOSING_WAIT_NONE : new_serial.closing_wait * 10;\r\nmutex_lock(&acm->port.mutex);\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nif ((close_delay != acm->port.close_delay) ||\r\n(closing_wait != acm->port.closing_wait))\r\nretval = -EPERM;\r\nelse\r\nretval = -EOPNOTSUPP;\r\n} else {\r\nacm->port.close_delay = close_delay;\r\nacm->port.closing_wait = closing_wait;\r\n}\r\nmutex_unlock(&acm->port.mutex);\r\nreturn retval;\r\n}\r\nstatic int wait_serial_change(struct acm *acm, unsigned long arg)\r\n{\r\nint rv = 0;\r\nDECLARE_WAITQUEUE(wait, current);\r\nstruct async_icount old, new;\r\nif (arg & (TIOCM_DSR | TIOCM_RI | TIOCM_CD ))\r\nreturn -EINVAL;\r\ndo {\r\nspin_lock_irq(&acm->read_lock);\r\nold = acm->oldcount;\r\nnew = acm->iocount;\r\nacm->oldcount = new;\r\nspin_unlock_irq(&acm->read_lock);\r\nif ((arg & TIOCM_DSR) &&\r\nold.dsr != new.dsr)\r\nbreak;\r\nif ((arg & TIOCM_CD) &&\r\nold.dcd != new.dcd)\r\nbreak;\r\nif ((arg & TIOCM_RI) &&\r\nold.rng != new.rng)\r\nbreak;\r\nadd_wait_queue(&acm->wioctl, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule();\r\nremove_wait_queue(&acm->wioctl, &wait);\r\nif (acm->disconnected) {\r\nif (arg & TIOCM_CD)\r\nbreak;\r\nelse\r\nrv = -ENODEV;\r\n} else {\r\nif (signal_pending(current))\r\nrv = -ERESTARTSYS;\r\n}\r\n} while (!rv);\r\nreturn rv;\r\n}\r\nstatic int get_serial_usage(struct acm *acm,\r\nstruct serial_icounter_struct __user *count)\r\n{\r\nstruct serial_icounter_struct icount;\r\nint rv = 0;\r\nmemset(&icount, 0, sizeof(icount));\r\nicount.dsr = acm->iocount.dsr;\r\nicount.rng = acm->iocount.rng;\r\nicount.dcd = acm->iocount.dcd;\r\nicount.frame = acm->iocount.frame;\r\nicount.overrun = acm->iocount.overrun;\r\nicount.parity = acm->iocount.parity;\r\nicount.brk = acm->iocount.brk;\r\nif (copy_to_user(count, &icount, sizeof(icount)) > 0)\r\nrv = -EFAULT;\r\nreturn rv;\r\n}\r\nstatic int acm_tty_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\nint rv = -ENOIOCTLCMD;\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nrv = get_serial_info(acm, (struct serial_struct __user *) arg);\r\nbreak;\r\ncase TIOCSSERIAL:\r\nrv = set_serial_info(acm, (struct serial_struct __user *) arg);\r\nbreak;\r\ncase TIOCMIWAIT:\r\nrv = usb_autopm_get_interface(acm->control);\r\nif (rv < 0) {\r\nrv = -EIO;\r\nbreak;\r\n}\r\nrv = wait_serial_change(acm, arg);\r\nusb_autopm_put_interface(acm->control);\r\nbreak;\r\ncase TIOCGICOUNT:\r\nrv = get_serial_usage(acm, (struct serial_icounter_struct __user *) arg);\r\nbreak;\r\n}\r\nreturn rv;\r\n}\r\nstatic void acm_tty_set_termios(struct tty_struct *tty,\r\nstruct ktermios *termios_old)\r\n{\r\nstruct acm *acm = tty->driver_data;\r\nstruct ktermios *termios = &tty->termios;\r\nstruct usb_cdc_line_coding newline;\r\nint newctrl = acm->ctrlout;\r\nnewline.dwDTERate = cpu_to_le32(tty_get_baud_rate(tty));\r\nnewline.bCharFormat = termios->c_cflag & CSTOPB ? 2 : 0;\r\nnewline.bParityType = termios->c_cflag & PARENB ?\r\n(termios->c_cflag & PARODD ? 1 : 2) +\r\n(termios->c_cflag & CMSPAR ? 2 : 0) : 0;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nnewline.bDataBits = 5;\r\nbreak;\r\ncase CS6:\r\nnewline.bDataBits = 6;\r\nbreak;\r\ncase CS7:\r\nnewline.bDataBits = 7;\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nnewline.bDataBits = 8;\r\nbreak;\r\n}\r\nacm->clocal = ((termios->c_cflag & CLOCAL) != 0);\r\nif (!newline.dwDTERate) {\r\nnewline.dwDTERate = acm->line.dwDTERate;\r\nnewctrl &= ~ACM_CTRL_DTR;\r\n} else\r\nnewctrl |= ACM_CTRL_DTR;\r\nif (newctrl != acm->ctrlout)\r\nacm_set_control(acm, acm->ctrlout = newctrl);\r\nif (memcmp(&acm->line, &newline, sizeof newline)) {\r\nmemcpy(&acm->line, &newline, sizeof newline);\r\ndev_dbg(&acm->control->dev, "%s - set line: %d %d %d %d\n",\r\n__func__,\r\nle32_to_cpu(newline.dwDTERate),\r\nnewline.bCharFormat, newline.bParityType,\r\nnewline.bDataBits);\r\nacm_set_line(acm, &acm->line);\r\n}\r\n}\r\nstatic void acm_write_buffers_free(struct acm *acm)\r\n{\r\nint i;\r\nstruct acm_wb *wb;\r\nstruct usb_device *usb_dev = interface_to_usbdev(acm->control);\r\nfor (wb = &acm->wb[0], i = 0; i < ACM_NW; i++, wb++)\r\nusb_free_coherent(usb_dev, acm->writesize, wb->buf, wb->dmah);\r\n}\r\nstatic void acm_read_buffers_free(struct acm *acm)\r\n{\r\nstruct usb_device *usb_dev = interface_to_usbdev(acm->control);\r\nint i;\r\nfor (i = 0; i < acm->rx_buflimit; i++)\r\nusb_free_coherent(usb_dev, acm->readsize,\r\nacm->read_buffers[i].base, acm->read_buffers[i].dma);\r\n}\r\nstatic int acm_write_buffers_alloc(struct acm *acm)\r\n{\r\nint i;\r\nstruct acm_wb *wb;\r\nfor (wb = &acm->wb[0], i = 0; i < ACM_NW; i++, wb++) {\r\nwb->buf = usb_alloc_coherent(acm->dev, acm->writesize, GFP_KERNEL,\r\n&wb->dmah);\r\nif (!wb->buf) {\r\nwhile (i != 0) {\r\n--i;\r\n--wb;\r\nusb_free_coherent(acm->dev, acm->writesize,\r\nwb->buf, wb->dmah);\r\n}\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int acm_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_cdc_union_desc *union_header = NULL;\r\nstruct usb_cdc_country_functional_desc *cfd = NULL;\r\nunsigned char *buffer = intf->altsetting->extra;\r\nint buflen = intf->altsetting->extralen;\r\nstruct usb_interface *control_interface;\r\nstruct usb_interface *data_interface;\r\nstruct usb_endpoint_descriptor *epctrl = NULL;\r\nstruct usb_endpoint_descriptor *epread = NULL;\r\nstruct usb_endpoint_descriptor *epwrite = NULL;\r\nstruct usb_device *usb_dev = interface_to_usbdev(intf);\r\nstruct acm *acm;\r\nint minor;\r\nint ctrlsize, readsize;\r\nu8 *buf;\r\nu8 ac_management_function = 0;\r\nu8 call_management_function = 0;\r\nint call_interface_num = -1;\r\nint data_interface_num = -1;\r\nunsigned long quirks;\r\nint num_rx_buf;\r\nint i;\r\nint combined_interfaces = 0;\r\nstruct device *tty_dev;\r\nint rv = -ENOMEM;\r\nquirks = (unsigned long)id->driver_info;\r\nif (quirks == IGNORE_DEVICE)\r\nreturn -ENODEV;\r\nnum_rx_buf = (quirks == SINGLE_RX_URB) ? 1 : ACM_NR;\r\nif (quirks == NO_UNION_NORMAL) {\r\ndata_interface = usb_ifnum_to_if(usb_dev, 1);\r\ncontrol_interface = usb_ifnum_to_if(usb_dev, 0);\r\ngoto skip_normal_probe;\r\n}\r\nif (!buffer) {\r\ndev_err(&intf->dev, "Weird descriptor references\n");\r\nreturn -EINVAL;\r\n}\r\nif (!buflen) {\r\nif (intf->cur_altsetting->endpoint &&\r\nintf->cur_altsetting->endpoint->extralen &&\r\nintf->cur_altsetting->endpoint->extra) {\r\ndev_dbg(&intf->dev,\r\n"Seeking extra descriptors on endpoint\n");\r\nbuflen = intf->cur_altsetting->endpoint->extralen;\r\nbuffer = intf->cur_altsetting->endpoint->extra;\r\n} else {\r\ndev_err(&intf->dev,\r\n"Zero length descriptor references\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nwhile (buflen > 0) {\r\nif (buffer[1] != USB_DT_CS_INTERFACE) {\r\ndev_err(&intf->dev, "skipping garbage\n");\r\ngoto next_desc;\r\n}\r\nswitch (buffer[2]) {\r\ncase USB_CDC_UNION_TYPE:\r\nif (union_header) {\r\ndev_err(&intf->dev, "More than one "\r\n"union descriptor, skipping ...\n");\r\ngoto next_desc;\r\n}\r\nunion_header = (struct usb_cdc_union_desc *)buffer;\r\nbreak;\r\ncase USB_CDC_COUNTRY_TYPE:\r\ncfd = (struct usb_cdc_country_functional_desc *)buffer;\r\nbreak;\r\ncase USB_CDC_HEADER_TYPE:\r\nbreak;\r\ncase USB_CDC_ACM_TYPE:\r\nac_management_function = buffer[3];\r\nbreak;\r\ncase USB_CDC_CALL_MANAGEMENT_TYPE:\r\ncall_management_function = buffer[3];\r\ncall_interface_num = buffer[4];\r\nif ((quirks & NOT_A_MODEM) == 0 && (call_management_function & 3) != 3)\r\ndev_err(&intf->dev, "This device cannot do calls on its own. It is not a modem.\n");\r\nbreak;\r\ndefault:\r\ndev_dbg(&intf->dev, "Ignoring descriptor: "\r\n"type %02x, length %d\n",\r\nbuffer[2], buffer[0]);\r\nbreak;\r\n}\r\nnext_desc:\r\nbuflen -= buffer[0];\r\nbuffer += buffer[0];\r\n}\r\nif (!union_header) {\r\nif (call_interface_num > 0) {\r\ndev_dbg(&intf->dev, "No union descriptor, using call management descriptor\n");\r\nif (quirks & NO_DATA_INTERFACE)\r\ndata_interface = usb_ifnum_to_if(usb_dev, 0);\r\nelse\r\ndata_interface = usb_ifnum_to_if(usb_dev, (data_interface_num = call_interface_num));\r\ncontrol_interface = intf;\r\n} else {\r\nif (intf->cur_altsetting->desc.bNumEndpoints != 3) {\r\ndev_dbg(&intf->dev,"No union descriptor, giving up\n");\r\nreturn -ENODEV;\r\n} else {\r\ndev_warn(&intf->dev,"No union descriptor, testing for castrated device\n");\r\ncombined_interfaces = 1;\r\ncontrol_interface = data_interface = intf;\r\ngoto look_for_collapsed_interface;\r\n}\r\n}\r\n} else {\r\ncontrol_interface = usb_ifnum_to_if(usb_dev, union_header->bMasterInterface0);\r\ndata_interface = usb_ifnum_to_if(usb_dev, (data_interface_num = union_header->bSlaveInterface0));\r\nif (!control_interface || !data_interface) {\r\ndev_dbg(&intf->dev, "no interfaces\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (data_interface_num != call_interface_num)\r\ndev_dbg(&intf->dev, "Separate call control interface. That is not fully supported.\n");\r\nif (control_interface == data_interface) {\r\ndev_warn(&intf->dev,"Control and data interfaces are not separated!\n");\r\ncombined_interfaces = 1;\r\nquirks |= NO_CAP_LINE;\r\nif (data_interface->cur_altsetting->desc.bNumEndpoints != 3) {\r\ndev_err(&intf->dev, "This needs exactly 3 endpoints\n");\r\nreturn -EINVAL;\r\n}\r\nlook_for_collapsed_interface:\r\nfor (i = 0; i < 3; i++) {\r\nstruct usb_endpoint_descriptor *ep;\r\nep = &data_interface->cur_altsetting->endpoint[i].desc;\r\nif (usb_endpoint_is_int_in(ep))\r\nepctrl = ep;\r\nelse if (usb_endpoint_is_bulk_out(ep))\r\nepwrite = ep;\r\nelse if (usb_endpoint_is_bulk_in(ep))\r\nepread = ep;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nif (!epctrl || !epread || !epwrite)\r\nreturn -ENODEV;\r\nelse\r\ngoto made_compressed_probe;\r\n}\r\nskip_normal_probe:\r\nif (data_interface->cur_altsetting->desc.bInterfaceClass\r\n!= CDC_DATA_INTERFACE_TYPE) {\r\nif (control_interface->cur_altsetting->desc.bInterfaceClass\r\n== CDC_DATA_INTERFACE_TYPE) {\r\nstruct usb_interface *t;\r\ndev_dbg(&intf->dev,\r\n"Your device has switched interfaces.\n");\r\nt = control_interface;\r\ncontrol_interface = data_interface;\r\ndata_interface = t;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!combined_interfaces && intf != control_interface)\r\nreturn -ENODEV;\r\nif (!combined_interfaces && usb_interface_claimed(data_interface)) {\r\ndev_dbg(&intf->dev, "The data interface isn't available\n");\r\nreturn -EBUSY;\r\n}\r\nif (data_interface->cur_altsetting->desc.bNumEndpoints < 2 ||\r\ncontrol_interface->cur_altsetting->desc.bNumEndpoints == 0)\r\nreturn -EINVAL;\r\nepctrl = &control_interface->cur_altsetting->endpoint[0].desc;\r\nepread = &data_interface->cur_altsetting->endpoint[0].desc;\r\nepwrite = &data_interface->cur_altsetting->endpoint[1].desc;\r\nif (!usb_endpoint_dir_in(epread)) {\r\nstruct usb_endpoint_descriptor *t;\r\ndev_dbg(&intf->dev,\r\n"The data interface has switched endpoints\n");\r\nt = epread;\r\nepread = epwrite;\r\nepwrite = t;\r\n}\r\nmade_compressed_probe:\r\ndev_dbg(&intf->dev, "interfaces are valid\n");\r\nacm = kzalloc(sizeof(struct acm), GFP_KERNEL);\r\nif (acm == NULL) {\r\ndev_err(&intf->dev, "out of memory (acm kzalloc)\n");\r\ngoto alloc_fail;\r\n}\r\nminor = acm_alloc_minor(acm);\r\nif (minor == ACM_TTY_MINORS) {\r\ndev_err(&intf->dev, "no more free acm devices\n");\r\nkfree(acm);\r\nreturn -ENODEV;\r\n}\r\nctrlsize = usb_endpoint_maxp(epctrl);\r\nreadsize = usb_endpoint_maxp(epread) *\r\n(quirks == SINGLE_RX_URB ? 1 : 2);\r\nacm->combined_interfaces = combined_interfaces;\r\nacm->writesize = usb_endpoint_maxp(epwrite) * 20;\r\nacm->control = control_interface;\r\nacm->data = data_interface;\r\nacm->minor = minor;\r\nacm->dev = usb_dev;\r\nacm->ctrl_caps = ac_management_function;\r\nif (quirks & NO_CAP_LINE)\r\nacm->ctrl_caps &= ~USB_CDC_CAP_LINE;\r\nacm->ctrlsize = ctrlsize;\r\nacm->readsize = readsize;\r\nacm->rx_buflimit = num_rx_buf;\r\nINIT_WORK(&acm->work, acm_softint);\r\ninit_waitqueue_head(&acm->wioctl);\r\nspin_lock_init(&acm->write_lock);\r\nspin_lock_init(&acm->read_lock);\r\nmutex_init(&acm->mutex);\r\nacm->rx_endpoint = usb_rcvbulkpipe(usb_dev, epread->bEndpointAddress);\r\nacm->is_int_ep = usb_endpoint_xfer_int(epread);\r\nif (acm->is_int_ep)\r\nacm->bInterval = epread->bInterval;\r\ntty_port_init(&acm->port);\r\nacm->port.ops = &acm_port_ops;\r\ninit_usb_anchor(&acm->delayed);\r\nbuf = usb_alloc_coherent(usb_dev, ctrlsize, GFP_KERNEL, &acm->ctrl_dma);\r\nif (!buf) {\r\ndev_err(&intf->dev, "out of memory (ctrl buffer alloc)\n");\r\ngoto alloc_fail2;\r\n}\r\nacm->ctrl_buffer = buf;\r\nif (acm_write_buffers_alloc(acm) < 0) {\r\ndev_err(&intf->dev, "out of memory (write buffer alloc)\n");\r\ngoto alloc_fail4;\r\n}\r\nacm->ctrlurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!acm->ctrlurb) {\r\ndev_err(&intf->dev, "out of memory (ctrlurb kmalloc)\n");\r\ngoto alloc_fail5;\r\n}\r\nfor (i = 0; i < num_rx_buf; i++) {\r\nstruct acm_rb *rb = &(acm->read_buffers[i]);\r\nstruct urb *urb;\r\nrb->base = usb_alloc_coherent(acm->dev, readsize, GFP_KERNEL,\r\n&rb->dma);\r\nif (!rb->base) {\r\ndev_err(&intf->dev, "out of memory "\r\n"(read bufs usb_alloc_coherent)\n");\r\ngoto alloc_fail6;\r\n}\r\nrb->index = i;\r\nrb->instance = acm;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\ndev_err(&intf->dev,\r\n"out of memory (read urbs usb_alloc_urb)\n");\r\ngoto alloc_fail6;\r\n}\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nurb->transfer_dma = rb->dma;\r\nif (acm->is_int_ep) {\r\nusb_fill_int_urb(urb, acm->dev,\r\nacm->rx_endpoint,\r\nrb->base,\r\nacm->readsize,\r\nacm_read_bulk_callback, rb,\r\nacm->bInterval);\r\n} else {\r\nusb_fill_bulk_urb(urb, acm->dev,\r\nacm->rx_endpoint,\r\nrb->base,\r\nacm->readsize,\r\nacm_read_bulk_callback, rb);\r\n}\r\nacm->read_urbs[i] = urb;\r\n__set_bit(i, &acm->read_urbs_free);\r\n}\r\nfor (i = 0; i < ACM_NW; i++) {\r\nstruct acm_wb *snd = &(acm->wb[i]);\r\nsnd->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (snd->urb == NULL) {\r\ndev_err(&intf->dev,\r\n"out of memory (write urbs usb_alloc_urb)\n");\r\ngoto alloc_fail7;\r\n}\r\nif (usb_endpoint_xfer_int(epwrite))\r\nusb_fill_int_urb(snd->urb, usb_dev,\r\nusb_sndintpipe(usb_dev, epwrite->bEndpointAddress),\r\nNULL, acm->writesize, acm_write_bulk, snd, epwrite->bInterval);\r\nelse\r\nusb_fill_bulk_urb(snd->urb, usb_dev,\r\nusb_sndbulkpipe(usb_dev, epwrite->bEndpointAddress),\r\nNULL, acm->writesize, acm_write_bulk, snd);\r\nsnd->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nsnd->instance = acm;\r\n}\r\nusb_set_intfdata(intf, acm);\r\ni = device_create_file(&intf->dev, &dev_attr_bmCapabilities);\r\nif (i < 0)\r\ngoto alloc_fail7;\r\nif (cfd) {\r\nacm->country_codes = kmalloc(cfd->bLength - 4, GFP_KERNEL);\r\nif (!acm->country_codes)\r\ngoto skip_countries;\r\nacm->country_code_size = cfd->bLength - 4;\r\nmemcpy(acm->country_codes, (u8 *)&cfd->wCountyCode0,\r\ncfd->bLength - 4);\r\nacm->country_rel_date = cfd->iCountryCodeRelDate;\r\ni = device_create_file(&intf->dev, &dev_attr_wCountryCodes);\r\nif (i < 0) {\r\nkfree(acm->country_codes);\r\nacm->country_codes = NULL;\r\nacm->country_code_size = 0;\r\ngoto skip_countries;\r\n}\r\ni = device_create_file(&intf->dev,\r\n&dev_attr_iCountryCodeRelDate);\r\nif (i < 0) {\r\ndevice_remove_file(&intf->dev, &dev_attr_wCountryCodes);\r\nkfree(acm->country_codes);\r\nacm->country_codes = NULL;\r\nacm->country_code_size = 0;\r\ngoto skip_countries;\r\n}\r\n}\r\nskip_countries:\r\nusb_fill_int_urb(acm->ctrlurb, usb_dev,\r\nusb_rcvintpipe(usb_dev, epctrl->bEndpointAddress),\r\nacm->ctrl_buffer, ctrlsize, acm_ctrl_irq, acm,\r\nepctrl->bInterval ? epctrl->bInterval : 16);\r\nacm->ctrlurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nacm->ctrlurb->transfer_dma = acm->ctrl_dma;\r\ndev_info(&intf->dev, "ttyACM%d: USB ACM device\n", minor);\r\nacm->line.dwDTERate = cpu_to_le32(9600);\r\nacm->line.bDataBits = 8;\r\nacm_set_line(acm, &acm->line);\r\nusb_driver_claim_interface(&acm_driver, data_interface, acm);\r\nusb_set_intfdata(data_interface, acm);\r\nusb_get_intf(control_interface);\r\ntty_dev = tty_port_register_device(&acm->port, acm_tty_driver, minor,\r\n&control_interface->dev);\r\nif (IS_ERR(tty_dev)) {\r\nrv = PTR_ERR(tty_dev);\r\ngoto alloc_fail8;\r\n}\r\nreturn 0;\r\nalloc_fail8:\r\nif (acm->country_codes) {\r\ndevice_remove_file(&acm->control->dev,\r\n&dev_attr_wCountryCodes);\r\ndevice_remove_file(&acm->control->dev,\r\n&dev_attr_iCountryCodeRelDate);\r\n}\r\ndevice_remove_file(&acm->control->dev, &dev_attr_bmCapabilities);\r\nalloc_fail7:\r\nusb_set_intfdata(intf, NULL);\r\nfor (i = 0; i < ACM_NW; i++)\r\nusb_free_urb(acm->wb[i].urb);\r\nalloc_fail6:\r\nfor (i = 0; i < num_rx_buf; i++)\r\nusb_free_urb(acm->read_urbs[i]);\r\nacm_read_buffers_free(acm);\r\nusb_free_urb(acm->ctrlurb);\r\nalloc_fail5:\r\nacm_write_buffers_free(acm);\r\nalloc_fail4:\r\nusb_free_coherent(usb_dev, ctrlsize, acm->ctrl_buffer, acm->ctrl_dma);\r\nalloc_fail2:\r\nacm_release_minor(acm);\r\nkfree(acm);\r\nalloc_fail:\r\nreturn rv;\r\n}\r\nstatic void stop_data_traffic(struct acm *acm)\r\n{\r\nint i;\r\ndev_dbg(&acm->control->dev, "%s\n", __func__);\r\nusb_kill_urb(acm->ctrlurb);\r\nfor (i = 0; i < ACM_NW; i++)\r\nusb_kill_urb(acm->wb[i].urb);\r\nfor (i = 0; i < acm->rx_buflimit; i++)\r\nusb_kill_urb(acm->read_urbs[i]);\r\ncancel_work_sync(&acm->work);\r\n}\r\nstatic void acm_disconnect(struct usb_interface *intf)\r\n{\r\nstruct acm *acm = usb_get_intfdata(intf);\r\nstruct usb_device *usb_dev = interface_to_usbdev(intf);\r\nstruct tty_struct *tty;\r\nint i;\r\ndev_dbg(&intf->dev, "%s\n", __func__);\r\nif (!acm)\r\nreturn;\r\nmutex_lock(&acm->mutex);\r\nacm->disconnected = true;\r\nif (acm->country_codes) {\r\ndevice_remove_file(&acm->control->dev,\r\n&dev_attr_wCountryCodes);\r\ndevice_remove_file(&acm->control->dev,\r\n&dev_attr_iCountryCodeRelDate);\r\n}\r\nwake_up_all(&acm->wioctl);\r\ndevice_remove_file(&acm->control->dev, &dev_attr_bmCapabilities);\r\nusb_set_intfdata(acm->control, NULL);\r\nusb_set_intfdata(acm->data, NULL);\r\nmutex_unlock(&acm->mutex);\r\ntty = tty_port_tty_get(&acm->port);\r\nif (tty) {\r\ntty_vhangup(tty);\r\ntty_kref_put(tty);\r\n}\r\nstop_data_traffic(acm);\r\ntty_unregister_device(acm_tty_driver, acm->minor);\r\nusb_free_urb(acm->ctrlurb);\r\nfor (i = 0; i < ACM_NW; i++)\r\nusb_free_urb(acm->wb[i].urb);\r\nfor (i = 0; i < acm->rx_buflimit; i++)\r\nusb_free_urb(acm->read_urbs[i]);\r\nacm_write_buffers_free(acm);\r\nusb_free_coherent(usb_dev, acm->ctrlsize, acm->ctrl_buffer, acm->ctrl_dma);\r\nacm_read_buffers_free(acm);\r\nif (!acm->combined_interfaces)\r\nusb_driver_release_interface(&acm_driver, intf == acm->control ?\r\nacm->data : acm->control);\r\ntty_port_put(&acm->port);\r\n}\r\nstatic int acm_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct acm *acm = usb_get_intfdata(intf);\r\nint cnt;\r\nspin_lock_irq(&acm->write_lock);\r\nif (PMSG_IS_AUTO(message)) {\r\nif (acm->transmitting) {\r\nspin_unlock_irq(&acm->write_lock);\r\nreturn -EBUSY;\r\n}\r\n}\r\ncnt = acm->susp_count++;\r\nspin_unlock_irq(&acm->write_lock);\r\nif (cnt)\r\nreturn 0;\r\nstop_data_traffic(acm);\r\nreturn 0;\r\n}\r\nstatic int acm_resume(struct usb_interface *intf)\r\n{\r\nstruct acm *acm = usb_get_intfdata(intf);\r\nstruct urb *urb;\r\nint rv = 0;\r\nspin_lock_irq(&acm->write_lock);\r\nif (--acm->susp_count)\r\ngoto out;\r\nif (test_bit(ASYNCB_INITIALIZED, &acm->port.flags)) {\r\nrv = usb_submit_urb(acm->ctrlurb, GFP_ATOMIC);\r\nfor (;;) {\r\nurb = usb_get_from_anchor(&acm->delayed);\r\nif (!urb)\r\nbreak;\r\nacm_start_wb(acm, urb->context);\r\n}\r\nif (rv < 0)\r\ngoto out;\r\nrv = acm_submit_read_urbs(acm, GFP_ATOMIC);\r\n}\r\nout:\r\nspin_unlock_irq(&acm->write_lock);\r\nreturn rv;\r\n}\r\nstatic int acm_reset_resume(struct usb_interface *intf)\r\n{\r\nstruct acm *acm = usb_get_intfdata(intf);\r\nif (test_bit(ASYNCB_INITIALIZED, &acm->port.flags))\r\ntty_port_tty_hangup(&acm->port, false);\r\nreturn acm_resume(intf);\r\n}\r\nstatic int __init acm_init(void)\r\n{\r\nint retval;\r\nacm_tty_driver = alloc_tty_driver(ACM_TTY_MINORS);\r\nif (!acm_tty_driver)\r\nreturn -ENOMEM;\r\nacm_tty_driver->driver_name = "acm",\r\nacm_tty_driver->name = "ttyACM",\r\nacm_tty_driver->major = ACM_TTY_MAJOR,\r\nacm_tty_driver->minor_start = 0,\r\nacm_tty_driver->type = TTY_DRIVER_TYPE_SERIAL,\r\nacm_tty_driver->subtype = SERIAL_TYPE_NORMAL,\r\nacm_tty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;\r\nacm_tty_driver->init_termios = tty_std_termios;\r\nacm_tty_driver->init_termios.c_cflag = B9600 | CS8 | CREAD |\r\nHUPCL | CLOCAL;\r\ntty_set_operations(acm_tty_driver, &acm_ops);\r\nretval = tty_register_driver(acm_tty_driver);\r\nif (retval) {\r\nput_tty_driver(acm_tty_driver);\r\nreturn retval;\r\n}\r\nretval = usb_register(&acm_driver);\r\nif (retval) {\r\ntty_unregister_driver(acm_tty_driver);\r\nput_tty_driver(acm_tty_driver);\r\nreturn retval;\r\n}\r\nprintk(KERN_INFO KBUILD_MODNAME ": " DRIVER_DESC "\n");\r\nreturn 0;\r\n}\r\nstatic void __exit acm_exit(void)\r\n{\r\nusb_deregister(&acm_driver);\r\ntty_unregister_driver(acm_tty_driver);\r\nput_tty_driver(acm_tty_driver);\r\n}
