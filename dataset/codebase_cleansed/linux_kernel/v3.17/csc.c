u32 read_reg(struct csc_data *csc, int offset)\r\n{\r\nreturn ioread32(csc->base + offset);\r\n}\r\nvoid csc_set_coeff_bypass(struct csc_data *csc, u32 *csc_reg5)\r\n{\r\n*csc_reg5 |= CSC_BYPASS;\r\n}\r\nvoid csc_set_coeff(struct csc_data *csc, u32 *csc_reg0,\r\nenum v4l2_colorspace src_colorspace,\r\nenum v4l2_colorspace dst_colorspace)\r\n{\r\nu32 *csc_reg5 = csc_reg0 + 5;\r\nu32 *shadow_csc = csc_reg0;\r\nstruct colorspace_coeffs *sd_hd_coeffs;\r\nu16 *coeff, *end_coeff;\r\nenum v4l2_colorspace yuv_colorspace;\r\nint sel = 0;\r\nif (dst_colorspace == V4L2_COLORSPACE_SRGB &&\r\n(src_colorspace == V4L2_COLORSPACE_SMPTE170M ||\r\nsrc_colorspace == V4L2_COLORSPACE_REC709)) {\r\nsel = 1;\r\nyuv_colorspace = src_colorspace;\r\n} else if ((dst_colorspace == V4L2_COLORSPACE_SMPTE170M ||\r\ndst_colorspace == V4L2_COLORSPACE_REC709) &&\r\nsrc_colorspace == V4L2_COLORSPACE_SRGB) {\r\nsel = 3;\r\nyuv_colorspace = dst_colorspace;\r\n} else {\r\n*csc_reg5 |= CSC_BYPASS;\r\nreturn;\r\n}\r\nsd_hd_coeffs = &colorspace_coeffs[sel];\r\nif (yuv_colorspace == V4L2_COLORSPACE_SMPTE170M)\r\ncoeff = sd_hd_coeffs->sd;\r\nelse\r\ncoeff = sd_hd_coeffs->hd;\r\nend_coeff = coeff + 12;\r\nfor (; coeff < end_coeff; coeff += 2)\r\n*shadow_csc++ = (*(coeff + 1) << 16) | *coeff;\r\n}\r\nstruct csc_data *csc_create(struct platform_device *pdev)\r\n{\r\nstruct csc_data *csc;\r\ndev_dbg(&pdev->dev, "csc_create\n");\r\ncsc = devm_kzalloc(&pdev->dev, sizeof(*csc), GFP_KERNEL);\r\nif (!csc) {\r\ndev_err(&pdev->dev, "couldn't alloc csc_data\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ncsc->pdev = pdev;\r\ncsc->res = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"csc");\r\nif (csc->res == NULL) {\r\ndev_err(&pdev->dev, "missing platform resources data\n");\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\ncsc->base = devm_ioremap_resource(&pdev->dev, csc->res);\r\nif (IS_ERR(csc->base)) {\r\ndev_err(&pdev->dev, "failed to ioremap\n");\r\nreturn csc->base;\r\n}\r\nreturn csc;\r\n}
