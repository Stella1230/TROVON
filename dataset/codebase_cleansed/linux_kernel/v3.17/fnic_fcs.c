void fnic_handle_link(struct work_struct *work)\r\n{\r\nstruct fnic *fnic = container_of(work, struct fnic, link_work);\r\nunsigned long flags;\r\nint old_link_status;\r\nu32 old_link_down_cnt;\r\nspin_lock_irqsave(&fnic->fnic_lock, flags);\r\nif (fnic->stop_rx_link_events) {\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nreturn;\r\n}\r\nold_link_down_cnt = fnic->link_down_cnt;\r\nold_link_status = fnic->link_status;\r\nfnic->link_status = vnic_dev_link_status(fnic->vdev);\r\nfnic->link_down_cnt = vnic_dev_link_down_cnt(fnic->vdev);\r\nif (old_link_status == fnic->link_status) {\r\nif (!fnic->link_status) {\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nfnic_fc_trace_set_data(fnic->lport->host->host_no,\r\nFNIC_FC_LE, "Link Status: DOWN->DOWN",\r\nstrlen("Link Status: DOWN->DOWN"));\r\n} else {\r\nif (old_link_down_cnt != fnic->link_down_cnt) {\r\nfnic->lport->host_stats.link_failure_count++;\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nfnic_fc_trace_set_data(\r\nfnic->lport->host->host_no,\r\nFNIC_FC_LE,\r\n"Link Status:UP_DOWN_UP",\r\nstrlen("Link_Status:UP_DOWN_UP")\r\n);\r\nFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,\r\n"link down\n");\r\nfcoe_ctlr_link_down(&fnic->ctlr);\r\nif (fnic->config.flags & VFCF_FIP_CAPABLE) {\r\nfnic_fc_trace_set_data(\r\nfnic->lport->host->host_no,\r\nFNIC_FC_LE,\r\n"Link Status: UP_DOWN_UP_VLAN",\r\nstrlen(\r\n"Link Status: UP_DOWN_UP_VLAN")\r\n);\r\nfnic_fcoe_send_vlan_req(fnic);\r\nreturn;\r\n}\r\nFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,\r\n"link up\n");\r\nfcoe_ctlr_link_up(&fnic->ctlr);\r\n} else\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nfnic_fc_trace_set_data(\r\nfnic->lport->host->host_no, FNIC_FC_LE,\r\n"Link Status: UP_UP",\r\nstrlen("Link Status: UP_UP"));\r\n}\r\n} else if (fnic->link_status) {\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nif (fnic->config.flags & VFCF_FIP_CAPABLE) {\r\nfnic_fc_trace_set_data(\r\nfnic->lport->host->host_no,\r\nFNIC_FC_LE, "Link Status: DOWN_UP_VLAN",\r\nstrlen("Link Status: DOWN_UP_VLAN"));\r\nfnic_fcoe_send_vlan_req(fnic);\r\nreturn;\r\n}\r\nFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host, "link up\n");\r\nfnic_fc_trace_set_data(fnic->lport->host->host_no, FNIC_FC_LE,\r\n"Link Status: DOWN_UP", strlen("Link Status: DOWN_UP"));\r\nfcoe_ctlr_link_up(&fnic->ctlr);\r\n} else {\r\nfnic->lport->host_stats.link_failure_count++;\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host, "link down\n");\r\nfnic_fc_trace_set_data(\r\nfnic->lport->host->host_no, FNIC_FC_LE,\r\n"Link Status: UP_DOWN",\r\nstrlen("Link Status: UP_DOWN"));\r\nfcoe_ctlr_link_down(&fnic->ctlr);\r\n}\r\n}\r\nvoid fnic_handle_frame(struct work_struct *work)\r\n{\r\nstruct fnic *fnic = container_of(work, struct fnic, frame_work);\r\nstruct fc_lport *lp = fnic->lport;\r\nunsigned long flags;\r\nstruct sk_buff *skb;\r\nstruct fc_frame *fp;\r\nwhile ((skb = skb_dequeue(&fnic->frame_queue))) {\r\nspin_lock_irqsave(&fnic->fnic_lock, flags);\r\nif (fnic->stop_rx_link_events) {\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nfp = (struct fc_frame *)skb;\r\nif (fnic->state != FNIC_IN_FC_MODE &&\r\nfnic->state != FNIC_IN_ETH_MODE) {\r\nskb_queue_head(&fnic->frame_queue, skb);\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nfc_exch_recv(lp, fp);\r\n}\r\n}\r\nvoid fnic_fcoe_evlist_free(struct fnic *fnic)\r\n{\r\nstruct fnic_event *fevt = NULL;\r\nstruct fnic_event *next = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&fnic->fnic_lock, flags);\r\nif (list_empty(&fnic->evlist)) {\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nreturn;\r\n}\r\nlist_for_each_entry_safe(fevt, next, &fnic->evlist, list) {\r\nlist_del(&fevt->list);\r\nkfree(fevt);\r\n}\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\n}\r\nvoid fnic_handle_event(struct work_struct *work)\r\n{\r\nstruct fnic *fnic = container_of(work, struct fnic, event_work);\r\nstruct fnic_event *fevt = NULL;\r\nstruct fnic_event *next = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&fnic->fnic_lock, flags);\r\nif (list_empty(&fnic->evlist)) {\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nreturn;\r\n}\r\nlist_for_each_entry_safe(fevt, next, &fnic->evlist, list) {\r\nif (fnic->stop_rx_link_events) {\r\nlist_del(&fevt->list);\r\nkfree(fevt);\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nreturn;\r\n}\r\nif (fnic->state != FNIC_IN_FC_MODE &&\r\nfnic->state != FNIC_IN_ETH_MODE) {\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nreturn;\r\n}\r\nlist_del(&fevt->list);\r\nswitch (fevt->event) {\r\ncase FNIC_EVT_START_VLAN_DISC:\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nfnic_fcoe_send_vlan_req(fnic);\r\nspin_lock_irqsave(&fnic->fnic_lock, flags);\r\nbreak;\r\ncase FNIC_EVT_START_FCF_DISC:\r\nFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,\r\n"Start FCF Discovery\n");\r\nfnic_fcoe_start_fcf_disc(fnic);\r\nbreak;\r\ndefault:\r\nFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,\r\n"Unknown event 0x%x\n", fevt->event);\r\nbreak;\r\n}\r\nkfree(fevt);\r\n}\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\n}\r\nstatic inline int is_fnic_fip_flogi_reject(struct fcoe_ctlr *fip,\r\nstruct sk_buff *skb)\r\n{\r\nstruct fc_lport *lport = fip->lp;\r\nstruct fip_header *fiph;\r\nstruct fc_frame_header *fh = NULL;\r\nstruct fip_desc *desc;\r\nstruct fip_encaps *els;\r\nenum fip_desc_type els_dtype = 0;\r\nu16 op;\r\nu8 els_op;\r\nu8 sub;\r\nsize_t els_len = 0;\r\nsize_t rlen;\r\nsize_t dlen = 0;\r\nif (skb_linearize(skb))\r\nreturn 0;\r\nif (skb->len < sizeof(*fiph))\r\nreturn 0;\r\nfiph = (struct fip_header *)skb->data;\r\nop = ntohs(fiph->fip_op);\r\nsub = fiph->fip_subcode;\r\nif (op != FIP_OP_LS)\r\nreturn 0;\r\nif (sub != FIP_SC_REP)\r\nreturn 0;\r\nrlen = ntohs(fiph->fip_dl_len) * 4;\r\nif (rlen + sizeof(*fiph) > skb->len)\r\nreturn 0;\r\ndesc = (struct fip_desc *)(fiph + 1);\r\ndlen = desc->fip_dlen * FIP_BPW;\r\nif (desc->fip_dtype == FIP_DT_FLOGI) {\r\nif (dlen < sizeof(*els) + sizeof(*fh) + 1)\r\nreturn 0;\r\nels_len = dlen - sizeof(*els);\r\nels = (struct fip_encaps *)desc;\r\nfh = (struct fc_frame_header *)(els + 1);\r\nels_dtype = desc->fip_dtype;\r\nif (!fh)\r\nreturn 0;\r\nels_op = *(u8 *)(fh + 1);\r\nif (els_op == ELS_LS_RJT) {\r\nshost_printk(KERN_INFO, lport->host,\r\n"Flogi Request Rejected by Switch\n");\r\nreturn 1;\r\n}\r\nshost_printk(KERN_INFO, lport->host,\r\n"Flogi Request Accepted by Switch\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void fnic_fcoe_send_vlan_req(struct fnic *fnic)\r\n{\r\nstruct fcoe_ctlr *fip = &fnic->ctlr;\r\nstruct fnic_stats *fnic_stats = &fnic->fnic_stats;\r\nstruct sk_buff *skb;\r\nchar *eth_fr;\r\nint fr_len;\r\nstruct fip_vlan *vlan;\r\nu64 vlan_tov;\r\nfnic_fcoe_reset_vlans(fnic);\r\nfnic->set_vlan(fnic, 0);\r\nFNIC_FCS_DBG(KERN_INFO, fnic->lport->host,\r\n"Sending VLAN request...\n");\r\nskb = dev_alloc_skb(sizeof(struct fip_vlan));\r\nif (!skb)\r\nreturn;\r\nfr_len = sizeof(*vlan);\r\neth_fr = (char *)skb->data;\r\nvlan = (struct fip_vlan *)eth_fr;\r\nmemset(vlan, 0, sizeof(*vlan));\r\nmemcpy(vlan->eth.h_source, fip->ctl_src_addr, ETH_ALEN);\r\nmemcpy(vlan->eth.h_dest, fcoe_all_fcfs, ETH_ALEN);\r\nvlan->eth.h_proto = htons(ETH_P_FIP);\r\nvlan->fip.fip_ver = FIP_VER_ENCAPS(FIP_VER);\r\nvlan->fip.fip_op = htons(FIP_OP_VLAN);\r\nvlan->fip.fip_subcode = FIP_SC_VL_REQ;\r\nvlan->fip.fip_dl_len = htons(sizeof(vlan->desc) / FIP_BPW);\r\nvlan->desc.mac.fd_desc.fip_dtype = FIP_DT_MAC;\r\nvlan->desc.mac.fd_desc.fip_dlen = sizeof(vlan->desc.mac) / FIP_BPW;\r\nmemcpy(&vlan->desc.mac.fd_mac, fip->ctl_src_addr, ETH_ALEN);\r\nvlan->desc.wwnn.fd_desc.fip_dtype = FIP_DT_NAME;\r\nvlan->desc.wwnn.fd_desc.fip_dlen = sizeof(vlan->desc.wwnn) / FIP_BPW;\r\nput_unaligned_be64(fip->lp->wwnn, &vlan->desc.wwnn.fd_wwn);\r\natomic64_inc(&fnic_stats->vlan_stats.vlan_disc_reqs);\r\nskb_put(skb, sizeof(*vlan));\r\nskb->protocol = htons(ETH_P_FIP);\r\nskb_reset_mac_header(skb);\r\nskb_reset_network_header(skb);\r\nfip->send(fip, skb);\r\nvlan_tov = jiffies + msecs_to_jiffies(FCOE_CTLR_FIPVLAN_TOV);\r\nmod_timer(&fnic->fip_timer, round_jiffies(vlan_tov));\r\n}\r\nstatic void fnic_fcoe_process_vlan_resp(struct fnic *fnic, struct sk_buff *skb)\r\n{\r\nstruct fcoe_ctlr *fip = &fnic->ctlr;\r\nstruct fip_header *fiph;\r\nstruct fip_desc *desc;\r\nstruct fnic_stats *fnic_stats = &fnic->fnic_stats;\r\nu16 vid;\r\nsize_t rlen;\r\nsize_t dlen;\r\nstruct fcoe_vlan *vlan;\r\nu64 sol_time;\r\nunsigned long flags;\r\nFNIC_FCS_DBG(KERN_INFO, fnic->lport->host,\r\n"Received VLAN response...\n");\r\nfiph = (struct fip_header *) skb->data;\r\nFNIC_FCS_DBG(KERN_INFO, fnic->lport->host,\r\n"Received VLAN response... OP 0x%x SUB_OP 0x%x\n",\r\nntohs(fiph->fip_op), fiph->fip_subcode);\r\nrlen = ntohs(fiph->fip_dl_len) * 4;\r\nfnic_fcoe_reset_vlans(fnic);\r\nspin_lock_irqsave(&fnic->vlans_lock, flags);\r\ndesc = (struct fip_desc *)(fiph + 1);\r\nwhile (rlen > 0) {\r\ndlen = desc->fip_dlen * FIP_BPW;\r\nswitch (desc->fip_dtype) {\r\ncase FIP_DT_VLAN:\r\nvid = ntohs(((struct fip_vlan_desc *)desc)->fd_vlan);\r\nshost_printk(KERN_INFO, fnic->lport->host,\r\n"process_vlan_resp: FIP VLAN %d\n", vid);\r\nvlan = kmalloc(sizeof(*vlan),\r\nGFP_ATOMIC);\r\nif (!vlan) {\r\nspin_unlock_irqrestore(&fnic->vlans_lock,\r\nflags);\r\ngoto out;\r\n}\r\nmemset(vlan, 0, sizeof(struct fcoe_vlan));\r\nvlan->vid = vid & 0x0fff;\r\nvlan->state = FIP_VLAN_AVAIL;\r\nlist_add_tail(&vlan->list, &fnic->vlans);\r\nbreak;\r\n}\r\ndesc = (struct fip_desc *)((char *)desc + dlen);\r\nrlen -= dlen;\r\n}\r\nif (list_empty(&fnic->vlans)) {\r\natomic64_inc(&fnic_stats->vlan_stats.resp_withno_vlanID);\r\nFNIC_FCS_DBG(KERN_INFO, fnic->lport->host,\r\n"No VLAN descriptors in FIP VLAN response\n");\r\nspin_unlock_irqrestore(&fnic->vlans_lock, flags);\r\ngoto out;\r\n}\r\nvlan = list_first_entry(&fnic->vlans, struct fcoe_vlan, list);\r\nfnic->set_vlan(fnic, vlan->vid);\r\nvlan->state = FIP_VLAN_SENT;\r\nvlan->sol_count++;\r\nspin_unlock_irqrestore(&fnic->vlans_lock, flags);\r\nfcoe_ctlr_link_up(fip);\r\nsol_time = jiffies + msecs_to_jiffies(FCOE_CTLR_START_DELAY);\r\nmod_timer(&fnic->fip_timer, round_jiffies(sol_time));\r\nout:\r\nreturn;\r\n}\r\nstatic void fnic_fcoe_start_fcf_disc(struct fnic *fnic)\r\n{\r\nunsigned long flags;\r\nstruct fcoe_vlan *vlan;\r\nu64 sol_time;\r\nspin_lock_irqsave(&fnic->vlans_lock, flags);\r\nvlan = list_first_entry(&fnic->vlans, struct fcoe_vlan, list);\r\nfnic->set_vlan(fnic, vlan->vid);\r\nvlan->state = FIP_VLAN_SENT;\r\nvlan->sol_count = 1;\r\nspin_unlock_irqrestore(&fnic->vlans_lock, flags);\r\nfcoe_ctlr_link_up(&fnic->ctlr);\r\nsol_time = jiffies + msecs_to_jiffies(FCOE_CTLR_START_DELAY);\r\nmod_timer(&fnic->fip_timer, round_jiffies(sol_time));\r\n}\r\nstatic int fnic_fcoe_vlan_check(struct fnic *fnic, u16 flag)\r\n{\r\nunsigned long flags;\r\nstruct fcoe_vlan *fvlan;\r\nspin_lock_irqsave(&fnic->vlans_lock, flags);\r\nif (list_empty(&fnic->vlans)) {\r\nspin_unlock_irqrestore(&fnic->vlans_lock, flags);\r\nreturn -EINVAL;\r\n}\r\nfvlan = list_first_entry(&fnic->vlans, struct fcoe_vlan, list);\r\nif (fvlan->state == FIP_VLAN_USED) {\r\nspin_unlock_irqrestore(&fnic->vlans_lock, flags);\r\nreturn 0;\r\n}\r\nif (fvlan->state == FIP_VLAN_SENT) {\r\nfvlan->state = FIP_VLAN_USED;\r\nspin_unlock_irqrestore(&fnic->vlans_lock, flags);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&fnic->vlans_lock, flags);\r\nreturn -EINVAL;\r\n}\r\nstatic void fnic_event_enq(struct fnic *fnic, enum fnic_evt ev)\r\n{\r\nstruct fnic_event *fevt;\r\nunsigned long flags;\r\nfevt = kmalloc(sizeof(*fevt), GFP_ATOMIC);\r\nif (!fevt)\r\nreturn;\r\nfevt->fnic = fnic;\r\nfevt->event = ev;\r\nspin_lock_irqsave(&fnic->fnic_lock, flags);\r\nlist_add_tail(&fevt->list, &fnic->evlist);\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nschedule_work(&fnic->event_work);\r\n}\r\nstatic int fnic_fcoe_handle_fip_frame(struct fnic *fnic, struct sk_buff *skb)\r\n{\r\nstruct fip_header *fiph;\r\nint ret = 1;\r\nu16 op;\r\nu8 sub;\r\nif (!skb || !(skb->data))\r\nreturn -1;\r\nif (skb_linearize(skb))\r\ngoto drop;\r\nfiph = (struct fip_header *)skb->data;\r\nop = ntohs(fiph->fip_op);\r\nsub = fiph->fip_subcode;\r\nif (FIP_VER_DECAPS(fiph->fip_ver) != FIP_VER)\r\ngoto drop;\r\nif (ntohs(fiph->fip_dl_len) * FIP_BPW + sizeof(*fiph) > skb->len)\r\ngoto drop;\r\nif (op == FIP_OP_DISC && sub == FIP_SC_ADV) {\r\nif (fnic_fcoe_vlan_check(fnic, ntohs(fiph->fip_flags)))\r\ngoto drop;\r\nret = 1;\r\n} else if (op == FIP_OP_VLAN && sub == FIP_SC_VL_REP) {\r\nfnic_fcoe_process_vlan_resp(fnic, skb);\r\nret = 0;\r\n} else if (op == FIP_OP_CTRL && sub == FIP_SC_CLR_VLINK) {\r\nfnic_event_enq(fnic, FNIC_EVT_START_VLAN_DISC);\r\nret = 1;\r\n}\r\ndrop:\r\nreturn ret;\r\n}\r\nvoid fnic_handle_fip_frame(struct work_struct *work)\r\n{\r\nstruct fnic *fnic = container_of(work, struct fnic, fip_frame_work);\r\nstruct fnic_stats *fnic_stats = &fnic->fnic_stats;\r\nunsigned long flags;\r\nstruct sk_buff *skb;\r\nstruct ethhdr *eh;\r\nwhile ((skb = skb_dequeue(&fnic->fip_frame_queue))) {\r\nspin_lock_irqsave(&fnic->fnic_lock, flags);\r\nif (fnic->stop_rx_link_events) {\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nif (fnic->state != FNIC_IN_FC_MODE &&\r\nfnic->state != FNIC_IN_ETH_MODE) {\r\nskb_queue_head(&fnic->fip_frame_queue, skb);\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\neh = (struct ethhdr *)skb->data;\r\nif (eh->h_proto == htons(ETH_P_FIP)) {\r\nskb_pull(skb, sizeof(*eh));\r\nif (fnic_fcoe_handle_fip_frame(fnic, skb) <= 0) {\r\ndev_kfree_skb(skb);\r\ncontinue;\r\n}\r\nif (is_fnic_fip_flogi_reject(&fnic->ctlr, skb)) {\r\natomic64_inc(\r\n&fnic_stats->vlan_stats.flogi_rejects);\r\nshost_printk(KERN_INFO, fnic->lport->host,\r\n"Trigger a Link down - VLAN Disc\n");\r\nfcoe_ctlr_link_down(&fnic->ctlr);\r\nfnic_fcoe_send_vlan_req(fnic);\r\ndev_kfree_skb(skb);\r\ncontinue;\r\n}\r\nfcoe_ctlr_recv(&fnic->ctlr, skb);\r\ncontinue;\r\n}\r\n}\r\n}\r\nstatic inline int fnic_import_rq_eth_pkt(struct fnic *fnic, struct sk_buff *skb)\r\n{\r\nstruct fc_frame *fp;\r\nstruct ethhdr *eh;\r\nstruct fcoe_hdr *fcoe_hdr;\r\nstruct fcoe_crc_eof *ft;\r\neh = (struct ethhdr *)skb->data;\r\nif (eh->h_proto == htons(ETH_P_8021Q)) {\r\nmemmove((u8 *)eh + VLAN_HLEN, eh, ETH_ALEN * 2);\r\neh = (struct ethhdr *)skb_pull(skb, VLAN_HLEN);\r\nskb_reset_mac_header(skb);\r\n}\r\nif (eh->h_proto == htons(ETH_P_FIP)) {\r\nif (!(fnic->config.flags & VFCF_FIP_CAPABLE)) {\r\nprintk(KERN_ERR "Dropped FIP frame, as firmware "\r\n"uses non-FIP mode, Enable FIP "\r\n"using UCSM\n");\r\ngoto drop;\r\n}\r\nif ((fnic_fc_trace_set_data(fnic->lport->host->host_no,\r\nFNIC_FC_RECV|0x80, (char *)skb->data, skb->len)) != 0) {\r\nprintk(KERN_ERR "fnic ctlr frame trace error!!!");\r\n}\r\nskb_queue_tail(&fnic->fip_frame_queue, skb);\r\nqueue_work(fnic_fip_queue, &fnic->fip_frame_work);\r\nreturn 1;\r\n}\r\nif (eh->h_proto != htons(ETH_P_FCOE))\r\ngoto drop;\r\nskb_set_network_header(skb, sizeof(*eh));\r\nskb_pull(skb, sizeof(*eh));\r\nfcoe_hdr = (struct fcoe_hdr *)skb->data;\r\nif (FC_FCOE_DECAPS_VER(fcoe_hdr) != FC_FCOE_VER)\r\ngoto drop;\r\nfp = (struct fc_frame *)skb;\r\nfc_frame_init(fp);\r\nfr_sof(fp) = fcoe_hdr->fcoe_sof;\r\nskb_pull(skb, sizeof(struct fcoe_hdr));\r\nskb_reset_transport_header(skb);\r\nft = (struct fcoe_crc_eof *)(skb->data + skb->len - sizeof(*ft));\r\nfr_eof(fp) = ft->fcoe_eof;\r\nskb_trim(skb, skb->len - sizeof(*ft));\r\nreturn 0;\r\ndrop:\r\ndev_kfree_skb_irq(skb);\r\nreturn -1;\r\n}\r\nvoid fnic_update_mac_locked(struct fnic *fnic, u8 *new)\r\n{\r\nu8 *ctl = fnic->ctlr.ctl_src_addr;\r\nu8 *data = fnic->data_src_addr;\r\nif (is_zero_ether_addr(new))\r\nnew = ctl;\r\nif (ether_addr_equal(data, new))\r\nreturn;\r\nFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host, "update_mac %pM\n", new);\r\nif (!is_zero_ether_addr(data) && !ether_addr_equal(data, ctl))\r\nvnic_dev_del_addr(fnic->vdev, data);\r\nmemcpy(data, new, ETH_ALEN);\r\nif (!ether_addr_equal(new, ctl))\r\nvnic_dev_add_addr(fnic->vdev, new);\r\n}\r\nvoid fnic_update_mac(struct fc_lport *lport, u8 *new)\r\n{\r\nstruct fnic *fnic = lport_priv(lport);\r\nspin_lock_irq(&fnic->fnic_lock);\r\nfnic_update_mac_locked(fnic, new);\r\nspin_unlock_irq(&fnic->fnic_lock);\r\n}\r\nvoid fnic_set_port_id(struct fc_lport *lport, u32 port_id, struct fc_frame *fp)\r\n{\r\nstruct fnic *fnic = lport_priv(lport);\r\nu8 *mac;\r\nint ret;\r\nFNIC_FCS_DBG(KERN_DEBUG, lport->host, "set port_id %x fp %p\n",\r\nport_id, fp);\r\nif (!port_id) {\r\nfnic_update_mac(lport, fnic->ctlr.ctl_src_addr);\r\nfnic_set_eth_mode(fnic);\r\nreturn;\r\n}\r\nif (fp) {\r\nmac = fr_cb(fp)->granted_mac;\r\nif (is_zero_ether_addr(mac)) {\r\nfcoe_ctlr_recv_flogi(&fnic->ctlr, lport, fp);\r\n}\r\nfnic_update_mac(lport, mac);\r\n}\r\nspin_lock_irq(&fnic->fnic_lock);\r\nif (fnic->state == FNIC_IN_ETH_MODE || fnic->state == FNIC_IN_FC_MODE)\r\nfnic->state = FNIC_IN_ETH_TRANS_FC_MODE;\r\nelse {\r\nFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,\r\n"Unexpected fnic state %s while"\r\n" processing flogi resp\n",\r\nfnic_state_to_str(fnic->state));\r\nspin_unlock_irq(&fnic->fnic_lock);\r\nreturn;\r\n}\r\nspin_unlock_irq(&fnic->fnic_lock);\r\nret = fnic_flogi_reg_handler(fnic, port_id);\r\nif (ret < 0) {\r\nspin_lock_irq(&fnic->fnic_lock);\r\nif (fnic->state == FNIC_IN_ETH_TRANS_FC_MODE)\r\nfnic->state = FNIC_IN_ETH_MODE;\r\nspin_unlock_irq(&fnic->fnic_lock);\r\n}\r\n}\r\nstatic int fnic_rq_cmpl_handler_cont(struct vnic_dev *vdev,\r\nstruct cq_desc *cq_desc, u8 type,\r\nu16 q_number, u16 completed_index,\r\nvoid *opaque)\r\n{\r\nstruct fnic *fnic = vnic_dev_priv(vdev);\r\nvnic_rq_service(&fnic->rq[q_number], cq_desc, completed_index,\r\nVNIC_RQ_RETURN_DESC, fnic_rq_cmpl_frame_recv,\r\nNULL);\r\nreturn 0;\r\n}\r\nint fnic_rq_cmpl_handler(struct fnic *fnic, int rq_work_to_do)\r\n{\r\nunsigned int tot_rq_work_done = 0, cur_work_done;\r\nunsigned int i;\r\nint err;\r\nfor (i = 0; i < fnic->rq_count; i++) {\r\ncur_work_done = vnic_cq_service(&fnic->cq[i], rq_work_to_do,\r\nfnic_rq_cmpl_handler_cont,\r\nNULL);\r\nif (cur_work_done) {\r\nerr = vnic_rq_fill(&fnic->rq[i], fnic_alloc_rq_frame);\r\nif (err)\r\nshost_printk(KERN_ERR, fnic->lport->host,\r\n"fnic_alloc_rq_frame can't alloc"\r\n" frame\n");\r\n}\r\ntot_rq_work_done += cur_work_done;\r\n}\r\nreturn tot_rq_work_done;\r\n}\r\nint fnic_alloc_rq_frame(struct vnic_rq *rq)\r\n{\r\nstruct fnic *fnic = vnic_dev_priv(rq->vdev);\r\nstruct sk_buff *skb;\r\nu16 len;\r\ndma_addr_t pa;\r\nlen = FC_FRAME_HEADROOM + FC_MAX_FRAME + FC_FRAME_TAILROOM;\r\nskb = dev_alloc_skb(len);\r\nif (!skb) {\r\nFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,\r\n"Unable to allocate RQ sk_buff\n");\r\nreturn -ENOMEM;\r\n}\r\nskb_reset_mac_header(skb);\r\nskb_reset_transport_header(skb);\r\nskb_reset_network_header(skb);\r\nskb_put(skb, len);\r\npa = pci_map_single(fnic->pdev, skb->data, len, PCI_DMA_FROMDEVICE);\r\nfnic_queue_rq_desc(rq, skb, pa, len);\r\nreturn 0;\r\n}\r\nvoid fnic_free_rq_buf(struct vnic_rq *rq, struct vnic_rq_buf *buf)\r\n{\r\nstruct fc_frame *fp = buf->os_buf;\r\nstruct fnic *fnic = vnic_dev_priv(rq->vdev);\r\npci_unmap_single(fnic->pdev, buf->dma_addr, buf->len,\r\nPCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(fp_skb(fp));\r\nbuf->os_buf = NULL;\r\n}\r\nvoid fnic_eth_send(struct fcoe_ctlr *fip, struct sk_buff *skb)\r\n{\r\nstruct fnic *fnic = fnic_from_ctlr(fip);\r\nstruct vnic_wq *wq = &fnic->wq[0];\r\ndma_addr_t pa;\r\nstruct ethhdr *eth_hdr;\r\nstruct vlan_ethhdr *vlan_hdr;\r\nunsigned long flags;\r\nif (!fnic->vlan_hw_insert) {\r\neth_hdr = (struct ethhdr *)skb_mac_header(skb);\r\nvlan_hdr = (struct vlan_ethhdr *)skb_push(skb,\r\nsizeof(*vlan_hdr) - sizeof(*eth_hdr));\r\nmemcpy(vlan_hdr, eth_hdr, 2 * ETH_ALEN);\r\nvlan_hdr->h_vlan_proto = htons(ETH_P_8021Q);\r\nvlan_hdr->h_vlan_encapsulated_proto = eth_hdr->h_proto;\r\nvlan_hdr->h_vlan_TCI = htons(fnic->vlan_id);\r\nif ((fnic_fc_trace_set_data(fnic->lport->host->host_no,\r\nFNIC_FC_SEND|0x80, (char *)eth_hdr, skb->len)) != 0) {\r\nprintk(KERN_ERR "fnic ctlr frame trace error!!!");\r\n}\r\n} else {\r\nif ((fnic_fc_trace_set_data(fnic->lport->host->host_no,\r\nFNIC_FC_SEND|0x80, (char *)skb->data, skb->len)) != 0) {\r\nprintk(KERN_ERR "fnic ctlr frame trace error!!!");\r\n}\r\n}\r\npa = pci_map_single(fnic->pdev, skb->data, skb->len, PCI_DMA_TODEVICE);\r\nspin_lock_irqsave(&fnic->wq_lock[0], flags);\r\nif (!vnic_wq_desc_avail(wq)) {\r\npci_unmap_single(fnic->pdev, pa, skb->len, PCI_DMA_TODEVICE);\r\nspin_unlock_irqrestore(&fnic->wq_lock[0], flags);\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nfnic_queue_wq_eth_desc(wq, skb, pa, skb->len,\r\n0 ,\r\nfnic->vlan_id, 1);\r\nspin_unlock_irqrestore(&fnic->wq_lock[0], flags);\r\n}\r\nstatic int fnic_send_frame(struct fnic *fnic, struct fc_frame *fp)\r\n{\r\nstruct vnic_wq *wq = &fnic->wq[0];\r\nstruct sk_buff *skb;\r\ndma_addr_t pa;\r\nstruct ethhdr *eth_hdr;\r\nstruct vlan_ethhdr *vlan_hdr;\r\nstruct fcoe_hdr *fcoe_hdr;\r\nstruct fc_frame_header *fh;\r\nu32 tot_len, eth_hdr_len;\r\nint ret = 0;\r\nunsigned long flags;\r\nfh = fc_frame_header_get(fp);\r\nskb = fp_skb(fp);\r\nif (unlikely(fh->fh_r_ctl == FC_RCTL_ELS_REQ) &&\r\nfcoe_ctlr_els_send(&fnic->ctlr, fnic->lport, skb))\r\nreturn 0;\r\nif (!fnic->vlan_hw_insert) {\r\neth_hdr_len = sizeof(*vlan_hdr) + sizeof(*fcoe_hdr);\r\nvlan_hdr = (struct vlan_ethhdr *)skb_push(skb, eth_hdr_len);\r\neth_hdr = (struct ethhdr *)vlan_hdr;\r\nvlan_hdr->h_vlan_proto = htons(ETH_P_8021Q);\r\nvlan_hdr->h_vlan_encapsulated_proto = htons(ETH_P_FCOE);\r\nvlan_hdr->h_vlan_TCI = htons(fnic->vlan_id);\r\nfcoe_hdr = (struct fcoe_hdr *)(vlan_hdr + 1);\r\n} else {\r\neth_hdr_len = sizeof(*eth_hdr) + sizeof(*fcoe_hdr);\r\neth_hdr = (struct ethhdr *)skb_push(skb, eth_hdr_len);\r\neth_hdr->h_proto = htons(ETH_P_FCOE);\r\nfcoe_hdr = (struct fcoe_hdr *)(eth_hdr + 1);\r\n}\r\nif (fnic->ctlr.map_dest)\r\nfc_fcoe_set_mac(eth_hdr->h_dest, fh->fh_d_id);\r\nelse\r\nmemcpy(eth_hdr->h_dest, fnic->ctlr.dest_addr, ETH_ALEN);\r\nmemcpy(eth_hdr->h_source, fnic->data_src_addr, ETH_ALEN);\r\ntot_len = skb->len;\r\nBUG_ON(tot_len % 4);\r\nmemset(fcoe_hdr, 0, sizeof(*fcoe_hdr));\r\nfcoe_hdr->fcoe_sof = fr_sof(fp);\r\nif (FC_FCOE_VER)\r\nFC_FCOE_ENCAPS_VER(fcoe_hdr, FC_FCOE_VER);\r\npa = pci_map_single(fnic->pdev, eth_hdr, tot_len, PCI_DMA_TODEVICE);\r\nif ((fnic_fc_trace_set_data(fnic->lport->host->host_no, FNIC_FC_SEND,\r\n(char *)eth_hdr, tot_len)) != 0) {\r\nprintk(KERN_ERR "fnic ctlr frame trace error!!!");\r\n}\r\nspin_lock_irqsave(&fnic->wq_lock[0], flags);\r\nif (!vnic_wq_desc_avail(wq)) {\r\npci_unmap_single(fnic->pdev, pa,\r\ntot_len, PCI_DMA_TODEVICE);\r\nret = -1;\r\ngoto fnic_send_frame_end;\r\n}\r\nfnic_queue_wq_desc(wq, skb, pa, tot_len, fr_eof(fp),\r\n0 ,\r\nfnic->vlan_id, 1, 1, 1);\r\nfnic_send_frame_end:\r\nspin_unlock_irqrestore(&fnic->wq_lock[0], flags);\r\nif (ret)\r\ndev_kfree_skb_any(fp_skb(fp));\r\nreturn ret;\r\n}\r\nint fnic_send(struct fc_lport *lp, struct fc_frame *fp)\r\n{\r\nstruct fnic *fnic = lport_priv(lp);\r\nunsigned long flags;\r\nif (fnic->in_remove) {\r\ndev_kfree_skb(fp_skb(fp));\r\nreturn -1;\r\n}\r\nspin_lock_irqsave(&fnic->fnic_lock, flags);\r\nif (fnic->state != FNIC_IN_FC_MODE && fnic->state != FNIC_IN_ETH_MODE) {\r\nskb_queue_tail(&fnic->tx_queue, fp_skb(fp));\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nreturn fnic_send_frame(fnic, fp);\r\n}\r\nvoid fnic_flush_tx(struct fnic *fnic)\r\n{\r\nstruct sk_buff *skb;\r\nstruct fc_frame *fp;\r\nwhile ((skb = skb_dequeue(&fnic->tx_queue))) {\r\nfp = (struct fc_frame *)skb;\r\nfnic_send_frame(fnic, fp);\r\n}\r\n}\r\nstatic void fnic_set_eth_mode(struct fnic *fnic)\r\n{\r\nunsigned long flags;\r\nenum fnic_state old_state;\r\nint ret;\r\nspin_lock_irqsave(&fnic->fnic_lock, flags);\r\nagain:\r\nold_state = fnic->state;\r\nswitch (old_state) {\r\ncase FNIC_IN_FC_MODE:\r\ncase FNIC_IN_ETH_TRANS_FC_MODE:\r\ndefault:\r\nfnic->state = FNIC_IN_FC_TRANS_ETH_MODE;\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nret = fnic_fw_reset_handler(fnic);\r\nspin_lock_irqsave(&fnic->fnic_lock, flags);\r\nif (fnic->state != FNIC_IN_FC_TRANS_ETH_MODE)\r\ngoto again;\r\nif (ret)\r\nfnic->state = old_state;\r\nbreak;\r\ncase FNIC_IN_FC_TRANS_ETH_MODE:\r\ncase FNIC_IN_ETH_MODE:\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\n}\r\nstatic void fnic_wq_complete_frame_send(struct vnic_wq *wq,\r\nstruct cq_desc *cq_desc,\r\nstruct vnic_wq_buf *buf, void *opaque)\r\n{\r\nstruct sk_buff *skb = buf->os_buf;\r\nstruct fc_frame *fp = (struct fc_frame *)skb;\r\nstruct fnic *fnic = vnic_dev_priv(wq->vdev);\r\npci_unmap_single(fnic->pdev, buf->dma_addr,\r\nbuf->len, PCI_DMA_TODEVICE);\r\ndev_kfree_skb_irq(fp_skb(fp));\r\nbuf->os_buf = NULL;\r\n}\r\nstatic int fnic_wq_cmpl_handler_cont(struct vnic_dev *vdev,\r\nstruct cq_desc *cq_desc, u8 type,\r\nu16 q_number, u16 completed_index,\r\nvoid *opaque)\r\n{\r\nstruct fnic *fnic = vnic_dev_priv(vdev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&fnic->wq_lock[q_number], flags);\r\nvnic_wq_service(&fnic->wq[q_number], cq_desc, completed_index,\r\nfnic_wq_complete_frame_send, NULL);\r\nspin_unlock_irqrestore(&fnic->wq_lock[q_number], flags);\r\nreturn 0;\r\n}\r\nint fnic_wq_cmpl_handler(struct fnic *fnic, int work_to_do)\r\n{\r\nunsigned int wq_work_done = 0;\r\nunsigned int i;\r\nfor (i = 0; i < fnic->raw_wq_count; i++) {\r\nwq_work_done += vnic_cq_service(&fnic->cq[fnic->rq_count+i],\r\nwork_to_do,\r\nfnic_wq_cmpl_handler_cont,\r\nNULL);\r\n}\r\nreturn wq_work_done;\r\n}\r\nvoid fnic_free_wq_buf(struct vnic_wq *wq, struct vnic_wq_buf *buf)\r\n{\r\nstruct fc_frame *fp = buf->os_buf;\r\nstruct fnic *fnic = vnic_dev_priv(wq->vdev);\r\npci_unmap_single(fnic->pdev, buf->dma_addr,\r\nbuf->len, PCI_DMA_TODEVICE);\r\ndev_kfree_skb(fp_skb(fp));\r\nbuf->os_buf = NULL;\r\n}\r\nvoid fnic_fcoe_reset_vlans(struct fnic *fnic)\r\n{\r\nunsigned long flags;\r\nstruct fcoe_vlan *vlan;\r\nstruct fcoe_vlan *next;\r\nspin_lock_irqsave(&fnic->vlans_lock, flags);\r\nif (!list_empty(&fnic->vlans)) {\r\nlist_for_each_entry_safe(vlan, next, &fnic->vlans, list) {\r\nlist_del(&vlan->list);\r\nkfree(vlan);\r\n}\r\n}\r\nspin_unlock_irqrestore(&fnic->vlans_lock, flags);\r\n}\r\nvoid fnic_handle_fip_timer(struct fnic *fnic)\r\n{\r\nunsigned long flags;\r\nstruct fcoe_vlan *vlan;\r\nstruct fnic_stats *fnic_stats = &fnic->fnic_stats;\r\nu64 sol_time;\r\nspin_lock_irqsave(&fnic->fnic_lock, flags);\r\nif (fnic->stop_rx_link_events) {\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&fnic->fnic_lock, flags);\r\nif (fnic->ctlr.mode == FIP_ST_NON_FIP)\r\nreturn;\r\nspin_lock_irqsave(&fnic->vlans_lock, flags);\r\nif (list_empty(&fnic->vlans)) {\r\nFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,\r\n"Start VLAN Discovery\n");\r\nspin_unlock_irqrestore(&fnic->vlans_lock, flags);\r\nfnic_event_enq(fnic, FNIC_EVT_START_VLAN_DISC);\r\nreturn;\r\n}\r\nvlan = list_first_entry(&fnic->vlans, struct fcoe_vlan, list);\r\nshost_printk(KERN_DEBUG, fnic->lport->host,\r\n"fip_timer: vlan %d state %d sol_count %d\n",\r\nvlan->vid, vlan->state, vlan->sol_count);\r\nswitch (vlan->state) {\r\ncase FIP_VLAN_USED:\r\nFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,\r\n"FIP VLAN is selected for FC transaction\n");\r\nspin_unlock_irqrestore(&fnic->vlans_lock, flags);\r\nbreak;\r\ncase FIP_VLAN_FAILED:\r\nFNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,\r\n"Start VLAN Discovery\n");\r\nspin_unlock_irqrestore(&fnic->vlans_lock, flags);\r\nfnic_event_enq(fnic, FNIC_EVT_START_VLAN_DISC);\r\nbreak;\r\ncase FIP_VLAN_SENT:\r\nif (vlan->sol_count >= FCOE_CTLR_MAX_SOL) {\r\nshost_printk(KERN_INFO, fnic->lport->host,\r\n"Dequeue this VLAN ID %d from list\n",\r\nvlan->vid);\r\nlist_del(&vlan->list);\r\nkfree(vlan);\r\nvlan = NULL;\r\nif (list_empty(&fnic->vlans)) {\r\nspin_unlock_irqrestore(&fnic->vlans_lock,\r\nflags);\r\nshost_printk(KERN_INFO, fnic->lport->host,\r\n"fip_timer: vlan list empty, "\r\n"trigger vlan disc\n");\r\nfnic_event_enq(fnic, FNIC_EVT_START_VLAN_DISC);\r\nreturn;\r\n}\r\nvlan = list_first_entry(&fnic->vlans, struct fcoe_vlan,\r\nlist);\r\nfnic->set_vlan(fnic, vlan->vid);\r\nvlan->state = FIP_VLAN_SENT;\r\n}\r\nspin_unlock_irqrestore(&fnic->vlans_lock, flags);\r\natomic64_inc(&fnic_stats->vlan_stats.sol_expiry_count);\r\nvlan->sol_count++;\r\nsol_time = jiffies + msecs_to_jiffies\r\n(FCOE_CTLR_START_DELAY);\r\nmod_timer(&fnic->fip_timer, round_jiffies(sol_time));\r\nbreak;\r\n}\r\n}
