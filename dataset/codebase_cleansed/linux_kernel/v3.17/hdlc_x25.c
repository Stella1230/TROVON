static void x25_connect_disconnect(struct net_device *dev, int reason, int code)\r\n{\r\nstruct sk_buff *skb;\r\nunsigned char *ptr;\r\nif ((skb = dev_alloc_skb(1)) == NULL) {\r\nnetdev_err(dev, "out of memory\n");\r\nreturn;\r\n}\r\nptr = skb_put(skb, 1);\r\n*ptr = code;\r\nskb->protocol = x25_type_trans(skb, dev);\r\nnetif_rx(skb);\r\n}\r\nstatic void x25_connected(struct net_device *dev, int reason)\r\n{\r\nx25_connect_disconnect(dev, reason, X25_IFACE_CONNECT);\r\n}\r\nstatic void x25_disconnected(struct net_device *dev, int reason)\r\n{\r\nx25_connect_disconnect(dev, reason, X25_IFACE_DISCONNECT);\r\n}\r\nstatic int x25_data_indication(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nunsigned char *ptr;\r\nskb_push(skb, 1);\r\nif (skb_cow(skb, 1))\r\nreturn NET_RX_DROP;\r\nptr = skb->data;\r\n*ptr = X25_IFACE_DATA;\r\nskb->protocol = x25_type_trans(skb, dev);\r\nreturn netif_rx(skb);\r\n}\r\nstatic void x25_data_transmit(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nhdlc->xmit(skb, dev);\r\n}\r\nstatic netdev_tx_t x25_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nint result;\r\nswitch (skb->data[0]) {\r\ncase X25_IFACE_DATA:\r\nskb_pull(skb, 1);\r\nif ((result = lapb_data_request(dev, skb)) != LAPB_OK)\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\ncase X25_IFACE_CONNECT:\r\nif ((result = lapb_connect_request(dev))!= LAPB_OK) {\r\nif (result == LAPB_CONNECTED)\r\nx25_connected(dev, 0);\r\nelse\r\nnetdev_err(dev, "LAPB connect request failed, error code = %i\n",\r\nresult);\r\n}\r\nbreak;\r\ncase X25_IFACE_DISCONNECT:\r\nif ((result = lapb_disconnect_request(dev)) != LAPB_OK) {\r\nif (result == LAPB_NOTCONNECTED)\r\nx25_disconnected(dev, 0);\r\nelse\r\nnetdev_err(dev, "LAPB disconnect request failed, error code = %i\n",\r\nresult);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int x25_open(struct net_device *dev)\r\n{\r\nint result;\r\nstatic const struct lapb_register_struct cb = {\r\n.connect_confirmation = x25_connected,\r\n.connect_indication = x25_connected,\r\n.disconnect_confirmation = x25_disconnected,\r\n.disconnect_indication = x25_disconnected,\r\n.data_indication = x25_data_indication,\r\n.data_transmit = x25_data_transmit,\r\n};\r\nresult = lapb_register(dev, &cb);\r\nif (result != LAPB_OK)\r\nreturn result;\r\nreturn 0;\r\n}\r\nstatic void x25_close(struct net_device *dev)\r\n{\r\nlapb_unregister(dev);\r\n}\r\nstatic int x25_rx(struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = skb->dev;\r\nif ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL) {\r\ndev->stats.rx_dropped++;\r\nreturn NET_RX_DROP;\r\n}\r\nif (lapb_data_received(dev, skb) == LAPB_OK)\r\nreturn NET_RX_SUCCESS;\r\ndev->stats.rx_errors++;\r\ndev_kfree_skb_any(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic int x25_ioctl(struct net_device *dev, struct ifreq *ifr)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nint result;\r\nswitch (ifr->ifr_settings.type) {\r\ncase IF_GET_PROTO:\r\nif (dev_to_hdlc(dev)->proto != &proto)\r\nreturn -EINVAL;\r\nifr->ifr_settings.type = IF_PROTO_X25;\r\nreturn 0;\r\ncase IF_PROTO_X25:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (dev->flags & IFF_UP)\r\nreturn -EBUSY;\r\nresult=hdlc->attach(dev, ENCODING_NRZ,PARITY_CRC16_PR1_CCITT);\r\nif (result)\r\nreturn result;\r\nif ((result = attach_hdlc_protocol(dev, &proto, 0)))\r\nreturn result;\r\ndev->type = ARPHRD_X25;\r\nnetif_dormant_off(dev);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int __init mod_init(void)\r\n{\r\nregister_hdlc_protocol(&proto);\r\nreturn 0;\r\n}\r\nstatic void __exit mod_exit(void)\r\n{\r\nunregister_hdlc_protocol(&proto);\r\n}
