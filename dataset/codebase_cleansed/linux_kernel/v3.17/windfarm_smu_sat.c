struct smu_sdbp_header *smu_sat_get_sdb_partition(unsigned int sat_id, int id,\r\nunsigned int *size)\r\n{\r\nstruct wf_sat *sat;\r\nint err;\r\nunsigned int i, len;\r\nu8 *buf;\r\nu8 data[4];\r\nif (sat_id > 1 || (sat = sats[sat_id]) == NULL)\r\nreturn NULL;\r\nerr = i2c_smbus_write_word_data(sat->i2c, 8, id << 8);\r\nif (err) {\r\nprintk(KERN_ERR "smu_sat_get_sdb_part wr error %d\n", err);\r\nreturn NULL;\r\n}\r\nerr = i2c_smbus_read_word_data(sat->i2c, 9);\r\nif (err < 0) {\r\nprintk(KERN_ERR "smu_sat_get_sdb_part rd len error\n");\r\nreturn NULL;\r\n}\r\nlen = err;\r\nif (len == 0) {\r\nprintk(KERN_ERR "smu_sat_get_sdb_part no partition %x\n", id);\r\nreturn NULL;\r\n}\r\nlen = le16_to_cpu(len);\r\nlen = (len + 3) & ~3;\r\nbuf = kmalloc(len, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn NULL;\r\nfor (i = 0; i < len; i += 4) {\r\nerr = i2c_smbus_read_i2c_block_data(sat->i2c, 0xa, 4, data);\r\nif (err < 0) {\r\nprintk(KERN_ERR "smu_sat_get_sdb_part rd err %d\n",\r\nerr);\r\ngoto fail;\r\n}\r\nbuf[i] = data[1];\r\nbuf[i+1] = data[0];\r\nbuf[i+2] = data[3];\r\nbuf[i+3] = data[2];\r\n}\r\n#ifdef DEBUG\r\nDBG(KERN_DEBUG "sat %d partition %x:", sat_id, id);\r\nfor (i = 0; i < len; ++i)\r\nDBG(" %x", buf[i]);\r\nDBG("\n");\r\n#endif\r\nif (size)\r\n*size = len;\r\nreturn (struct smu_sdbp_header *) buf;\r\nfail:\r\nkfree(buf);\r\nreturn NULL;\r\n}\r\nstatic int wf_sat_read_cache(struct wf_sat *sat)\r\n{\r\nint err;\r\nerr = i2c_smbus_read_i2c_block_data(sat->i2c, 0x3f, 16, sat->cache);\r\nif (err < 0)\r\nreturn err;\r\nsat->last_read = jiffies;\r\n#ifdef LOTSA_DEBUG\r\n{\r\nint i;\r\nDBG(KERN_DEBUG "wf_sat_get: data is");\r\nfor (i = 0; i < 16; ++i)\r\nDBG(" %.2x", sat->cache[i]);\r\nDBG("\n");\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int wf_sat_sensor_get(struct wf_sensor *sr, s32 *value)\r\n{\r\nstruct wf_sat_sensor *sens = wf_to_sat(sr);\r\nstruct wf_sat *sat = sens->sat;\r\nint i, err;\r\ns32 val;\r\nif (sat->i2c == NULL)\r\nreturn -ENODEV;\r\nmutex_lock(&sat->mutex);\r\nif (time_after(jiffies, (sat->last_read + MAX_AGE))) {\r\nerr = wf_sat_read_cache(sat);\r\nif (err)\r\ngoto fail;\r\n}\r\ni = sens->index * 2;\r\nval = ((sat->cache[i] << 8) + sat->cache[i+1]) << sens->shift;\r\nif (sens->index2 >= 0) {\r\ni = sens->index2 * 2;\r\nval = (val * ((sat->cache[i] << 8) + sat->cache[i+1])) >> 4;\r\n}\r\n*value = val;\r\nerr = 0;\r\nfail:\r\nmutex_unlock(&sat->mutex);\r\nreturn err;\r\n}\r\nstatic void wf_sat_release(struct kref *ref)\r\n{\r\nstruct wf_sat *sat = container_of(ref, struct wf_sat, ref);\r\nif (sat->nr >= 0)\r\nsats[sat->nr] = NULL;\r\nkfree(sat);\r\n}\r\nstatic void wf_sat_sensor_release(struct wf_sensor *sr)\r\n{\r\nstruct wf_sat_sensor *sens = wf_to_sat(sr);\r\nstruct wf_sat *sat = sens->sat;\r\nkfree(sens);\r\nkref_put(&sat->ref, wf_sat_release);\r\n}\r\nstatic int wf_sat_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device_node *dev = client->dev.of_node;\r\nstruct wf_sat *sat;\r\nstruct wf_sat_sensor *sens;\r\nconst u32 *reg;\r\nconst char *loc, *type;\r\nu8 chip, core;\r\nstruct device_node *child;\r\nint shift, cpu, index;\r\nchar *name;\r\nint vsens[2], isens[2];\r\nsat = kzalloc(sizeof(struct wf_sat), GFP_KERNEL);\r\nif (sat == NULL)\r\nreturn -ENOMEM;\r\nsat->nr = -1;\r\nsat->node = of_node_get(dev);\r\nkref_init(&sat->ref);\r\nmutex_init(&sat->mutex);\r\nsat->i2c = client;\r\nINIT_LIST_HEAD(&sat->sensors);\r\ni2c_set_clientdata(client, sat);\r\nvsens[0] = vsens[1] = -1;\r\nisens[0] = isens[1] = -1;\r\nchild = NULL;\r\nwhile ((child = of_get_next_child(dev, child)) != NULL) {\r\nreg = of_get_property(child, "reg", NULL);\r\ntype = of_get_property(child, "device_type", NULL);\r\nloc = of_get_property(child, "location", NULL);\r\nif (reg == NULL || loc == NULL)\r\ncontinue;\r\nif (*reg < 0x30 || *reg > 0x37)\r\ncontinue;\r\nindex = *reg - 0x30;\r\nif (strncmp(loc, "CPU ", 4) != 0)\r\ncontinue;\r\nchip = loc[4] - 'A';\r\ncore = loc[5] - '0';\r\nif (chip > 1 || core > 1) {\r\nprintk(KERN_ERR "wf_sat_create: don't understand "\r\n"location %s for %s\n", loc, child->full_name);\r\ncontinue;\r\n}\r\ncpu = 2 * chip + core;\r\nif (sat->nr < 0)\r\nsat->nr = chip;\r\nelse if (sat->nr != chip) {\r\nprintk(KERN_ERR "wf_sat_create: can't cope with "\r\n"multiple CPU chips on one SAT (%s)\n", loc);\r\ncontinue;\r\n}\r\nif (strcmp(type, "voltage-sensor") == 0) {\r\nname = "cpu-voltage";\r\nshift = 4;\r\nvsens[core] = index;\r\n} else if (strcmp(type, "current-sensor") == 0) {\r\nname = "cpu-current";\r\nshift = 8;\r\nisens[core] = index;\r\n} else if (strcmp(type, "temp-sensor") == 0) {\r\nname = "cpu-temp";\r\nshift = 10;\r\n} else\r\ncontinue;\r\nsens = kzalloc(sizeof(struct wf_sat_sensor) + 16, GFP_KERNEL);\r\nif (sens == NULL) {\r\nprintk(KERN_ERR "wf_sat_create: couldn't create "\r\n"%s sensor %d (no memory)\n", name, cpu);\r\ncontinue;\r\n}\r\nsens->index = index;\r\nsens->index2 = -1;\r\nsens->shift = shift;\r\nsens->sat = sat;\r\nsens->sens.ops = &wf_sat_ops;\r\nsens->sens.name = (char *) (sens + 1);\r\nsnprintf((char *)sens->sens.name, 16, "%s-%d", name, cpu);\r\nif (wf_register_sensor(&sens->sens))\r\nkfree(sens);\r\nelse {\r\nlist_add(&sens->link, &sat->sensors);\r\nkref_get(&sat->ref);\r\n}\r\n}\r\nfor (core = 0; core < 2; ++core) {\r\nif (vsens[core] < 0 || isens[core] < 0)\r\ncontinue;\r\ncpu = 2 * sat->nr + core;\r\nsens = kzalloc(sizeof(struct wf_sat_sensor) + 16, GFP_KERNEL);\r\nif (sens == NULL) {\r\nprintk(KERN_ERR "wf_sat_create: couldn't create power "\r\n"sensor %d (no memory)\n", cpu);\r\ncontinue;\r\n}\r\nsens->index = vsens[core];\r\nsens->index2 = isens[core];\r\nsens->shift = 0;\r\nsens->sat = sat;\r\nsens->sens.ops = &wf_sat_ops;\r\nsens->sens.name = (char *) (sens + 1);\r\nsnprintf((char *)sens->sens.name, 16, "cpu-power-%d", cpu);\r\nif (wf_register_sensor(&sens->sens))\r\nkfree(sens);\r\nelse {\r\nlist_add(&sens->link, &sat->sensors);\r\nkref_get(&sat->ref);\r\n}\r\n}\r\nif (sat->nr >= 0)\r\nsats[sat->nr] = sat;\r\nreturn 0;\r\n}\r\nstatic int wf_sat_remove(struct i2c_client *client)\r\n{\r\nstruct wf_sat *sat = i2c_get_clientdata(client);\r\nstruct wf_sat_sensor *sens;\r\nwhile(!list_empty(&sat->sensors)) {\r\nsens = list_first_entry(&sat->sensors,\r\nstruct wf_sat_sensor, link);\r\nlist_del(&sens->link);\r\nwf_unregister_sensor(&sens->sens);\r\n}\r\nsat->i2c = NULL;\r\nkref_put(&sat->ref, wf_sat_release);\r\nreturn 0;\r\n}
