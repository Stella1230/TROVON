struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\r\nint flags, pol_lookup_t lookup)\r\n{\r\nstruct fib_lookup_arg arg = {\r\n.lookup_ptr = lookup,\r\n.flags = FIB_LOOKUP_NOREF,\r\n};\r\nfib_rules_lookup(net->ipv6.fib6_rules_ops,\r\nflowi6_to_flowi(fl6), flags, &arg);\r\nif (arg.result)\r\nreturn arg.result;\r\ndst_hold(&net->ipv6.ip6_null_entry->dst);\r\nreturn &net->ipv6.ip6_null_entry->dst;\r\n}\r\nstatic int fib6_rule_action(struct fib_rule *rule, struct flowi *flp,\r\nint flags, struct fib_lookup_arg *arg)\r\n{\r\nstruct flowi6 *flp6 = &flp->u.ip6;\r\nstruct rt6_info *rt = NULL;\r\nstruct fib6_table *table;\r\nstruct net *net = rule->fr_net;\r\npol_lookup_t lookup = arg->lookup_ptr;\r\nint err = 0;\r\nswitch (rule->action) {\r\ncase FR_ACT_TO_TBL:\r\nbreak;\r\ncase FR_ACT_UNREACHABLE:\r\nerr = -ENETUNREACH;\r\nrt = net->ipv6.ip6_null_entry;\r\ngoto discard_pkt;\r\ndefault:\r\ncase FR_ACT_BLACKHOLE:\r\nerr = -EINVAL;\r\nrt = net->ipv6.ip6_blk_hole_entry;\r\ngoto discard_pkt;\r\ncase FR_ACT_PROHIBIT:\r\nerr = -EACCES;\r\nrt = net->ipv6.ip6_prohibit_entry;\r\ngoto discard_pkt;\r\n}\r\ntable = fib6_get_table(net, rule->table);\r\nif (!table) {\r\nerr = -EAGAIN;\r\ngoto out;\r\n}\r\nrt = lookup(net, table, flp6, flags);\r\nif (rt != net->ipv6.ip6_null_entry) {\r\nstruct fib6_rule *r = (struct fib6_rule *)rule;\r\nif ((rule->flags & FIB_RULE_FIND_SADDR) &&\r\nr->src.plen && !(flags & RT6_LOOKUP_F_HAS_SADDR)) {\r\nstruct in6_addr saddr;\r\nif (ipv6_dev_get_saddr(net,\r\nip6_dst_idev(&rt->dst)->dev,\r\n&flp6->daddr,\r\nrt6_flags2srcprefs(flags),\r\n&saddr))\r\ngoto again;\r\nif (!ipv6_prefix_equal(&saddr, &r->src.addr,\r\nr->src.plen))\r\ngoto again;\r\nflp6->saddr = saddr;\r\n}\r\ngoto out;\r\n}\r\nagain:\r\nip6_rt_put(rt);\r\nerr = -EAGAIN;\r\nrt = NULL;\r\ngoto out;\r\ndiscard_pkt:\r\ndst_hold(&rt->dst);\r\nout:\r\narg->result = rt;\r\nreturn err;\r\n}\r\nstatic bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\r\n{\r\nstruct rt6_info *rt = (struct rt6_info *) arg->result;\r\nstruct net_device *dev = NULL;\r\nif (rt->rt6i_idev)\r\ndev = rt->rt6i_idev->dev;\r\nif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\r\ngoto suppress_route;\r\nif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\r\ngoto suppress_route;\r\nreturn false;\r\nsuppress_route:\r\nip6_rt_put(rt);\r\nreturn true;\r\n}\r\nstatic int fib6_rule_match(struct fib_rule *rule, struct flowi *fl, int flags)\r\n{\r\nstruct fib6_rule *r = (struct fib6_rule *) rule;\r\nstruct flowi6 *fl6 = &fl->u.ip6;\r\nif (r->dst.plen &&\r\n!ipv6_prefix_equal(&fl6->daddr, &r->dst.addr, r->dst.plen))\r\nreturn 0;\r\nif (r->src.plen) {\r\nif (flags & RT6_LOOKUP_F_HAS_SADDR) {\r\nif (!ipv6_prefix_equal(&fl6->saddr, &r->src.addr,\r\nr->src.plen))\r\nreturn 0;\r\n} else if (!(r->common.flags & FIB_RULE_FIND_SADDR))\r\nreturn 0;\r\n}\r\nif (r->tclass && r->tclass != ip6_tclass(fl6->flowlabel))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int fib6_rule_configure(struct fib_rule *rule, struct sk_buff *skb,\r\nstruct fib_rule_hdr *frh,\r\nstruct nlattr **tb)\r\n{\r\nint err = -EINVAL;\r\nstruct net *net = sock_net(skb->sk);\r\nstruct fib6_rule *rule6 = (struct fib6_rule *) rule;\r\nif (rule->action == FR_ACT_TO_TBL) {\r\nif (rule->table == RT6_TABLE_UNSPEC)\r\ngoto errout;\r\nif (fib6_new_table(net, rule->table) == NULL) {\r\nerr = -ENOBUFS;\r\ngoto errout;\r\n}\r\n}\r\nif (frh->src_len)\r\nnla_memcpy(&rule6->src.addr, tb[FRA_SRC],\r\nsizeof(struct in6_addr));\r\nif (frh->dst_len)\r\nnla_memcpy(&rule6->dst.addr, tb[FRA_DST],\r\nsizeof(struct in6_addr));\r\nrule6->src.plen = frh->src_len;\r\nrule6->dst.plen = frh->dst_len;\r\nrule6->tclass = frh->tos;\r\nerr = 0;\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int fib6_rule_compare(struct fib_rule *rule, struct fib_rule_hdr *frh,\r\nstruct nlattr **tb)\r\n{\r\nstruct fib6_rule *rule6 = (struct fib6_rule *) rule;\r\nif (frh->src_len && (rule6->src.plen != frh->src_len))\r\nreturn 0;\r\nif (frh->dst_len && (rule6->dst.plen != frh->dst_len))\r\nreturn 0;\r\nif (frh->tos && (rule6->tclass != frh->tos))\r\nreturn 0;\r\nif (frh->src_len &&\r\nnla_memcmp(tb[FRA_SRC], &rule6->src.addr, sizeof(struct in6_addr)))\r\nreturn 0;\r\nif (frh->dst_len &&\r\nnla_memcmp(tb[FRA_DST], &rule6->dst.addr, sizeof(struct in6_addr)))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int fib6_rule_fill(struct fib_rule *rule, struct sk_buff *skb,\r\nstruct fib_rule_hdr *frh)\r\n{\r\nstruct fib6_rule *rule6 = (struct fib6_rule *) rule;\r\nfrh->dst_len = rule6->dst.plen;\r\nfrh->src_len = rule6->src.plen;\r\nfrh->tos = rule6->tclass;\r\nif ((rule6->dst.plen &&\r\nnla_put(skb, FRA_DST, sizeof(struct in6_addr),\r\n&rule6->dst.addr)) ||\r\n(rule6->src.plen &&\r\nnla_put(skb, FRA_SRC, sizeof(struct in6_addr),\r\n&rule6->src.addr)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -ENOBUFS;\r\n}\r\nstatic u32 fib6_rule_default_pref(struct fib_rules_ops *ops)\r\n{\r\nreturn 0x3FFF;\r\n}\r\nstatic size_t fib6_rule_nlmsg_payload(struct fib_rule *rule)\r\n{\r\nreturn nla_total_size(16)\r\n+ nla_total_size(16);\r\n}\r\nstatic int __net_init fib6_rules_net_init(struct net *net)\r\n{\r\nstruct fib_rules_ops *ops;\r\nint err = -ENOMEM;\r\nops = fib_rules_register(&fib6_rules_ops_template, net);\r\nif (IS_ERR(ops))\r\nreturn PTR_ERR(ops);\r\nnet->ipv6.fib6_rules_ops = ops;\r\nerr = fib_default_rule_add(net->ipv6.fib6_rules_ops, 0,\r\nRT6_TABLE_LOCAL, 0);\r\nif (err)\r\ngoto out_fib6_rules_ops;\r\nerr = fib_default_rule_add(net->ipv6.fib6_rules_ops,\r\n0x7FFE, RT6_TABLE_MAIN, 0);\r\nif (err)\r\ngoto out_fib6_rules_ops;\r\nout:\r\nreturn err;\r\nout_fib6_rules_ops:\r\nfib_rules_unregister(ops);\r\ngoto out;\r\n}\r\nstatic void __net_exit fib6_rules_net_exit(struct net *net)\r\n{\r\nfib_rules_unregister(net->ipv6.fib6_rules_ops);\r\n}\r\nint __init fib6_rules_init(void)\r\n{\r\nreturn register_pernet_subsys(&fib6_rules_net_ops);\r\n}\r\nvoid fib6_rules_cleanup(void)\r\n{\r\nunregister_pernet_subsys(&fib6_rules_net_ops);\r\n}
