static int asix_mdio_bus_read(struct mii_bus *bus, int phy_id, int regnum)\r\n{\r\nreturn asix_mdio_read(((struct usbnet *)bus->priv)->net, phy_id,\r\nregnum);\r\n}\r\nstatic int asix_mdio_bus_write(struct mii_bus *bus, int phy_id, int regnum,\r\nu16 val)\r\n{\r\nasix_mdio_write(((struct usbnet *)bus->priv)->net, phy_id, regnum, val);\r\nreturn 0;\r\n}\r\nstatic int ax88172a_ioctl(struct net_device *net, struct ifreq *rq, int cmd)\r\n{\r\nif (!netif_running(net))\r\nreturn -EINVAL;\r\nif (!net->phydev)\r\nreturn -ENODEV;\r\nreturn phy_mii_ioctl(net->phydev, rq, cmd);\r\n}\r\nstatic void ax88172a_adjust_link(struct net_device *netdev)\r\n{\r\nstruct phy_device *phydev = netdev->phydev;\r\nstruct usbnet *dev = netdev_priv(netdev);\r\nstruct ax88172a_private *priv = dev->driver_priv;\r\nu16 mode = 0;\r\nif (phydev->link) {\r\nmode = AX88772_MEDIUM_DEFAULT;\r\nif (phydev->duplex == DUPLEX_HALF)\r\nmode &= ~AX_MEDIUM_FD;\r\nif (phydev->speed != SPEED_100)\r\nmode &= ~AX_MEDIUM_PS;\r\n}\r\nif (mode != priv->oldmode) {\r\nasix_write_medium_mode(dev, mode);\r\npriv->oldmode = mode;\r\nnetdev_dbg(netdev, "speed %u duplex %d, setting mode to 0x%04x\n",\r\nphydev->speed, phydev->duplex, mode);\r\nphy_print_status(phydev);\r\n}\r\n}\r\nstatic void ax88172a_status(struct usbnet *dev, struct urb *urb)\r\n{\r\n}\r\nstatic int ax88172a_init_mdio(struct usbnet *dev)\r\n{\r\nstruct ax88172a_private *priv = dev->driver_priv;\r\nint ret, i;\r\npriv->mdio = mdiobus_alloc();\r\nif (!priv->mdio) {\r\nnetdev_err(dev->net, "Could not allocate MDIO bus\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->mdio->priv = (void *)dev;\r\npriv->mdio->read = &asix_mdio_bus_read;\r\npriv->mdio->write = &asix_mdio_bus_write;\r\npriv->mdio->name = "Asix MDIO Bus";\r\nsnprintf(priv->mdio->id, MII_BUS_ID_SIZE, "usb-%03d:%03d",\r\ndev->udev->bus->busnum, dev->udev->devnum);\r\npriv->mdio->irq = kzalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);\r\nif (!priv->mdio->irq) {\r\nret = -ENOMEM;\r\ngoto mfree;\r\n}\r\nfor (i = 0; i < PHY_MAX_ADDR; i++)\r\npriv->mdio->irq[i] = PHY_POLL;\r\nret = mdiobus_register(priv->mdio);\r\nif (ret) {\r\nnetdev_err(dev->net, "Could not register MDIO bus\n");\r\ngoto ifree;\r\n}\r\nnetdev_info(dev->net, "registered mdio bus %s\n", priv->mdio->id);\r\nreturn 0;\r\nifree:\r\nkfree(priv->mdio->irq);\r\nmfree:\r\nmdiobus_free(priv->mdio);\r\nreturn ret;\r\n}\r\nstatic void ax88172a_remove_mdio(struct usbnet *dev)\r\n{\r\nstruct ax88172a_private *priv = dev->driver_priv;\r\nnetdev_info(dev->net, "deregistering mdio bus %s\n", priv->mdio->id);\r\nmdiobus_unregister(priv->mdio);\r\nkfree(priv->mdio->irq);\r\nmdiobus_free(priv->mdio);\r\n}\r\nstatic int ax88172a_get_settings(struct net_device *net,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nif (!net->phydev)\r\nreturn -ENODEV;\r\nreturn phy_ethtool_gset(net->phydev, cmd);\r\n}\r\nstatic int ax88172a_set_settings(struct net_device *net,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nif (!net->phydev)\r\nreturn -ENODEV;\r\nreturn phy_ethtool_sset(net->phydev, cmd);\r\n}\r\nstatic int ax88172a_nway_reset(struct net_device *net)\r\n{\r\nif (!net->phydev)\r\nreturn -ENODEV;\r\nreturn phy_start_aneg(net->phydev);\r\n}\r\nstatic int ax88172a_reset_phy(struct usbnet *dev, int embd_phy)\r\n{\r\nint ret;\r\nret = asix_sw_reset(dev, AX_SWRESET_IPPD);\r\nif (ret < 0)\r\ngoto err;\r\nmsleep(150);\r\nret = asix_sw_reset(dev, AX_SWRESET_CLEAR);\r\nif (ret < 0)\r\ngoto err;\r\nmsleep(150);\r\nret = asix_sw_reset(dev, embd_phy ? AX_SWRESET_IPRL : AX_SWRESET_IPPD);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int ax88172a_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nint ret;\r\nu8 buf[ETH_ALEN];\r\nstruct ax88172a_private *priv;\r\nusbnet_get_endpoints(dev, intf);\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\ndev->driver_priv = priv;\r\nret = asix_read_cmd(dev, AX_CMD_READ_NODE_ID, 0, 0, ETH_ALEN, buf);\r\nif (ret < 0) {\r\nnetdev_err(dev->net, "Failed to read MAC address: %d\n", ret);\r\ngoto free;\r\n}\r\nmemcpy(dev->net->dev_addr, buf, ETH_ALEN);\r\ndev->net->netdev_ops = &ax88172a_netdev_ops;\r\ndev->net->ethtool_ops = &ax88172a_ethtool_ops;\r\nret = asix_read_cmd(dev, AX_CMD_SW_PHY_STATUS, 0, 0, 1, buf);\r\nif (ret < 0) {\r\nnetdev_err(dev->net, "Failed to read software interface selection register: %d\n",\r\nret);\r\ngoto free;\r\n}\r\nnetdev_dbg(dev->net, "AX_CMD_SW_PHY_STATUS = 0x%02x\n", buf[0]);\r\nswitch (buf[0] & AX_PHY_SELECT_MASK) {\r\ncase AX_PHY_SELECT_INTERNAL:\r\nnetdev_dbg(dev->net, "use internal phy\n");\r\npriv->use_embdphy = 1;\r\nbreak;\r\ncase AX_PHY_SELECT_EXTERNAL:\r\nnetdev_dbg(dev->net, "use external phy\n");\r\npriv->use_embdphy = 0;\r\nbreak;\r\ndefault:\r\nnetdev_err(dev->net, "Interface mode not supported by driver\n");\r\nret = -ENOTSUPP;\r\ngoto free;\r\n}\r\npriv->phy_addr = asix_read_phy_addr(dev, priv->use_embdphy);\r\nax88172a_reset_phy(dev, priv->use_embdphy);\r\nif (dev->driver_info->flags & FLAG_FRAMING_AX) {\r\ndev->rx_urb_size = 2048;\r\n}\r\nret = ax88172a_init_mdio(dev);\r\nif (ret)\r\ngoto free;\r\nreturn 0;\r\nfree:\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nstatic int ax88172a_stop(struct usbnet *dev)\r\n{\r\nstruct ax88172a_private *priv = dev->driver_priv;\r\nnetdev_dbg(dev->net, "Stopping interface\n");\r\nif (priv->phydev) {\r\nnetdev_info(dev->net, "Disconnecting from phy %s\n",\r\npriv->phy_name);\r\nphy_stop(priv->phydev);\r\nphy_disconnect(priv->phydev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ax88172a_unbind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nstruct ax88172a_private *priv = dev->driver_priv;\r\nax88172a_remove_mdio(dev);\r\nkfree(priv);\r\n}\r\nstatic int ax88172a_reset(struct usbnet *dev)\r\n{\r\nstruct asix_data *data = (struct asix_data *)&dev->data;\r\nstruct ax88172a_private *priv = dev->driver_priv;\r\nint ret;\r\nu16 rx_ctl;\r\nax88172a_reset_phy(dev, priv->use_embdphy);\r\nmsleep(150);\r\nrx_ctl = asix_read_rx_ctl(dev);\r\nnetdev_dbg(dev->net, "RX_CTL is 0x%04x after software reset\n", rx_ctl);\r\nret = asix_write_rx_ctl(dev, 0x0000);\r\nif (ret < 0)\r\ngoto out;\r\nrx_ctl = asix_read_rx_ctl(dev);\r\nnetdev_dbg(dev->net, "RX_CTL is 0x%04x setting to 0x0000\n", rx_ctl);\r\nmsleep(150);\r\nret = asix_write_cmd(dev, AX_CMD_WRITE_IPG0,\r\nAX88772_IPG0_DEFAULT | AX88772_IPG1_DEFAULT,\r\nAX88772_IPG2_DEFAULT, 0, NULL);\r\nif (ret < 0) {\r\nnetdev_err(dev->net, "Write IPG,IPG1,IPG2 failed: %d\n", ret);\r\ngoto out;\r\n}\r\nmemcpy(data->mac_addr, dev->net->dev_addr, ETH_ALEN);\r\nret = asix_write_cmd(dev, AX_CMD_WRITE_NODE_ID, 0, 0, ETH_ALEN,\r\ndata->mac_addr);\r\nif (ret < 0)\r\ngoto out;\r\nret = asix_write_rx_ctl(dev, AX_DEFAULT_RX_CTL);\r\nif (ret < 0)\r\ngoto out;\r\nrx_ctl = asix_read_rx_ctl(dev);\r\nnetdev_dbg(dev->net, "RX_CTL is 0x%04x after all initializations\n",\r\nrx_ctl);\r\nrx_ctl = asix_read_medium_status(dev);\r\nnetdev_dbg(dev->net, "Medium Status is 0x%04x after all initializations\n",\r\nrx_ctl);\r\nsnprintf(priv->phy_name, 20, PHY_ID_FMT,\r\npriv->mdio->id, priv->phy_addr);\r\npriv->phydev = phy_connect(dev->net, priv->phy_name,\r\n&ax88172a_adjust_link,\r\nPHY_INTERFACE_MODE_MII);\r\nif (IS_ERR(priv->phydev)) {\r\nnetdev_err(dev->net, "Could not connect to PHY device %s\n",\r\npriv->phy_name);\r\nret = PTR_ERR(priv->phydev);\r\ngoto out;\r\n}\r\nnetdev_info(dev->net, "Connected to phy %s\n", priv->phy_name);\r\ngenphy_resume(priv->phydev);\r\nphy_start(priv->phydev);\r\nreturn 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ax88172a_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nstruct ax88172a_private *dp = dev->driver_priv;\r\nstruct asix_rx_fixup_info *rx = &dp->rx_fixup_info;\r\nreturn asix_rx_fixup_internal(dev, skb, rx);\r\n}
