void ide_tf_readback(ide_drive_t *drive, struct ide_cmd *cmd)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nconst struct ide_tp_ops *tp_ops = hwif->tp_ops;\r\ntp_ops->write_devctl(hwif, ATA_DEVCTL_OBS);\r\ntp_ops->tf_read(drive, &cmd->tf, cmd->valid.in.tf);\r\nif (cmd->tf_flags & IDE_TFLAG_LBA48) {\r\ntp_ops->write_devctl(hwif, ATA_HOB | ATA_DEVCTL_OBS);\r\ntp_ops->tf_read(drive, &cmd->hob, cmd->valid.in.hob);\r\n}\r\n}\r\nvoid ide_tf_dump(const char *s, struct ide_cmd *cmd)\r\n{\r\n#ifdef DEBUG\r\nprintk("%s: tf: feat 0x%02x nsect 0x%02x lbal 0x%02x "\r\n"lbam 0x%02x lbah 0x%02x dev 0x%02x cmd 0x%02x\n",\r\ns, cmd->tf.feature, cmd->tf.nsect,\r\ncmd->tf.lbal, cmd->tf.lbam, cmd->tf.lbah,\r\ncmd->tf.device, cmd->tf.command);\r\nprintk("%s: hob: nsect 0x%02x lbal 0x%02x lbam 0x%02x lbah 0x%02x\n",\r\ns, cmd->hob.nsect, cmd->hob.lbal, cmd->hob.lbam, cmd->hob.lbah);\r\n#endif\r\n}\r\nint taskfile_lib_get_identify(ide_drive_t *drive, u8 *buf)\r\n{\r\nstruct ide_cmd cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.tf.nsect = 0x01;\r\nif (drive->media == ide_disk)\r\ncmd.tf.command = ATA_CMD_ID_ATA;\r\nelse\r\ncmd.tf.command = ATA_CMD_ID_ATAPI;\r\ncmd.valid.out.tf = IDE_VALID_OUT_TF | IDE_VALID_DEVICE;\r\ncmd.valid.in.tf = IDE_VALID_IN_TF | IDE_VALID_DEVICE;\r\ncmd.protocol = ATA_PROT_PIO;\r\nreturn ide_raw_taskfile(drive, &cmd, buf, 1);\r\n}\r\nide_startstop_t do_rw_taskfile(ide_drive_t *drive, struct ide_cmd *orig_cmd)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct ide_cmd *cmd = &hwif->cmd;\r\nstruct ide_taskfile *tf = &cmd->tf;\r\nide_handler_t *handler = NULL;\r\nconst struct ide_tp_ops *tp_ops = hwif->tp_ops;\r\nconst struct ide_dma_ops *dma_ops = hwif->dma_ops;\r\nif (orig_cmd->protocol == ATA_PROT_PIO &&\r\n(orig_cmd->tf_flags & IDE_TFLAG_MULTI_PIO) &&\r\ndrive->mult_count == 0) {\r\npr_err("%s: multimode not set!\n", drive->name);\r\nreturn ide_stopped;\r\n}\r\nif (orig_cmd->ftf_flags & IDE_FTFLAG_FLAGGED)\r\norig_cmd->ftf_flags |= IDE_FTFLAG_SET_IN_FLAGS;\r\nmemcpy(cmd, orig_cmd, sizeof(*cmd));\r\nif ((cmd->tf_flags & IDE_TFLAG_DMA_PIO_FALLBACK) == 0) {\r\nide_tf_dump(drive->name, cmd);\r\ntp_ops->write_devctl(hwif, ATA_DEVCTL_OBS);\r\nif (cmd->ftf_flags & IDE_FTFLAG_OUT_DATA) {\r\nu8 data[2] = { cmd->tf.data, cmd->hob.data };\r\ntp_ops->output_data(drive, cmd, data, 2);\r\n}\r\nif (cmd->valid.out.tf & IDE_VALID_DEVICE) {\r\nu8 HIHI = (cmd->tf_flags & IDE_TFLAG_LBA48) ?\r\n0xE0 : 0xEF;\r\nif (!(cmd->ftf_flags & IDE_FTFLAG_FLAGGED))\r\ncmd->tf.device &= HIHI;\r\ncmd->tf.device |= drive->select;\r\n}\r\ntp_ops->tf_load(drive, &cmd->hob, cmd->valid.out.hob);\r\ntp_ops->tf_load(drive, &cmd->tf, cmd->valid.out.tf);\r\n}\r\nswitch (cmd->protocol) {\r\ncase ATA_PROT_PIO:\r\nif (cmd->tf_flags & IDE_TFLAG_WRITE) {\r\ntp_ops->exec_command(hwif, tf->command);\r\nndelay(400);\r\nreturn pre_task_out_intr(drive, cmd);\r\n}\r\nhandler = task_pio_intr;\r\ncase ATA_PROT_NODATA:\r\nif (handler == NULL)\r\nhandler = task_no_data_intr;\r\nide_execute_command(drive, cmd, handler, WAIT_WORSTCASE);\r\nreturn ide_started;\r\ncase ATA_PROT_DMA:\r\nif (ide_dma_prepare(drive, cmd))\r\nreturn ide_stopped;\r\nhwif->expiry = dma_ops->dma_timer_expiry;\r\nide_execute_command(drive, cmd, ide_dma_intr, 2 * WAIT_CMD);\r\ndma_ops->dma_start(drive);\r\ndefault:\r\nreturn ide_started;\r\n}\r\n}\r\nstatic ide_startstop_t task_no_data_intr(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct ide_cmd *cmd = &hwif->cmd;\r\nstruct ide_taskfile *tf = &cmd->tf;\r\nint custom = (cmd->tf_flags & IDE_TFLAG_CUSTOM_HANDLER) ? 1 : 0;\r\nint retries = (custom && tf->command == ATA_CMD_INIT_DEV_PARAMS) ? 5 : 1;\r\nu8 stat;\r\nlocal_irq_enable_in_hardirq();\r\nwhile (1) {\r\nstat = hwif->tp_ops->read_status(hwif);\r\nif ((stat & ATA_BUSY) == 0 || retries-- == 0)\r\nbreak;\r\nudelay(10);\r\n};\r\nif (!OK_STAT(stat, ATA_DRDY, BAD_STAT)) {\r\nif (custom && tf->command == ATA_CMD_SET_MULTI) {\r\ndrive->mult_req = drive->mult_count = 0;\r\ndrive->special_flags |= IDE_SFLAG_RECALIBRATE;\r\n(void)ide_dump_status(drive, __func__, stat);\r\nreturn ide_stopped;\r\n} else if (custom && tf->command == ATA_CMD_INIT_DEV_PARAMS) {\r\nif ((stat & (ATA_ERR | ATA_DRQ)) == 0) {\r\nide_set_handler(drive, &task_no_data_intr,\r\nWAIT_WORSTCASE);\r\nreturn ide_started;\r\n}\r\n}\r\nreturn ide_error(drive, "task_no_data_intr", stat);\r\n}\r\nif (custom && tf->command == ATA_CMD_SET_MULTI)\r\ndrive->mult_count = drive->mult_req;\r\nif (custom == 0 || tf->command == ATA_CMD_IDLEIMMEDIATE ||\r\ntf->command == ATA_CMD_CHK_POWER) {\r\nstruct request *rq = hwif->rq;\r\nif (blk_pm_request(rq))\r\nide_complete_pm_rq(drive, rq);\r\nelse\r\nide_finish_cmd(drive, cmd, stat);\r\n}\r\nreturn ide_stopped;\r\n}\r\nstatic u8 wait_drive_not_busy(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nint retries;\r\nu8 stat;\r\nfor (retries = 0; retries < 1000; retries++) {\r\nstat = hwif->tp_ops->read_status(hwif);\r\nif (stat & ATA_BUSY)\r\nudelay(10);\r\nelse\r\nbreak;\r\n}\r\nif (stat & ATA_BUSY)\r\npr_err("%s: drive still BUSY!\n", drive->name);\r\nreturn stat;\r\n}\r\nvoid ide_pio_bytes(ide_drive_t *drive, struct ide_cmd *cmd,\r\nunsigned int write, unsigned int len)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct scatterlist *sg = hwif->sg_table;\r\nstruct scatterlist *cursg = cmd->cursg;\r\nunsigned long uninitialized_var(flags);\r\nstruct page *page;\r\nunsigned int offset;\r\nu8 *buf;\r\ncursg = cmd->cursg;\r\nif (cursg == NULL)\r\ncursg = cmd->cursg = sg;\r\nwhile (len) {\r\nunsigned nr_bytes = min(len, cursg->length - cmd->cursg_ofs);\r\nint page_is_high;\r\npage = sg_page(cursg);\r\noffset = cursg->offset + cmd->cursg_ofs;\r\npage = nth_page(page, (offset >> PAGE_SHIFT));\r\noffset %= PAGE_SIZE;\r\nnr_bytes = min_t(unsigned, nr_bytes, (PAGE_SIZE - offset));\r\npage_is_high = PageHighMem(page);\r\nif (page_is_high)\r\nlocal_irq_save(flags);\r\nbuf = kmap_atomic(page) + offset;\r\ncmd->nleft -= nr_bytes;\r\ncmd->cursg_ofs += nr_bytes;\r\nif (cmd->cursg_ofs == cursg->length) {\r\ncursg = cmd->cursg = sg_next(cmd->cursg);\r\ncmd->cursg_ofs = 0;\r\n}\r\nif (write)\r\nhwif->tp_ops->output_data(drive, cmd, buf, nr_bytes);\r\nelse\r\nhwif->tp_ops->input_data(drive, cmd, buf, nr_bytes);\r\nkunmap_atomic(buf);\r\nif (page_is_high)\r\nlocal_irq_restore(flags);\r\nlen -= nr_bytes;\r\n}\r\n}\r\nstatic void ide_pio_datablock(ide_drive_t *drive, struct ide_cmd *cmd,\r\nunsigned int write)\r\n{\r\nunsigned int nr_bytes;\r\nu8 saved_io_32bit = drive->io_32bit;\r\nif (cmd->tf_flags & IDE_TFLAG_FS)\r\ncmd->rq->errors = 0;\r\nif (cmd->tf_flags & IDE_TFLAG_IO_16BIT)\r\ndrive->io_32bit = 0;\r\ntouch_softlockup_watchdog();\r\nif (cmd->tf_flags & IDE_TFLAG_MULTI_PIO)\r\nnr_bytes = min_t(unsigned, cmd->nleft, drive->mult_count << 9);\r\nelse\r\nnr_bytes = SECTOR_SIZE;\r\nide_pio_bytes(drive, cmd, write, nr_bytes);\r\ndrive->io_32bit = saved_io_32bit;\r\n}\r\nstatic void ide_error_cmd(ide_drive_t *drive, struct ide_cmd *cmd)\r\n{\r\nif (cmd->tf_flags & IDE_TFLAG_FS) {\r\nint nr_bytes = cmd->nbytes - cmd->nleft;\r\nif (cmd->protocol == ATA_PROT_PIO &&\r\n((cmd->tf_flags & IDE_TFLAG_WRITE) || cmd->nleft == 0)) {\r\nif (cmd->tf_flags & IDE_TFLAG_MULTI_PIO)\r\nnr_bytes -= drive->mult_count << 9;\r\nelse\r\nnr_bytes -= SECTOR_SIZE;\r\n}\r\nif (nr_bytes > 0)\r\nide_complete_rq(drive, 0, nr_bytes);\r\n}\r\n}\r\nvoid ide_finish_cmd(ide_drive_t *drive, struct ide_cmd *cmd, u8 stat)\r\n{\r\nstruct request *rq = drive->hwif->rq;\r\nu8 err = ide_read_error(drive), nsect = cmd->tf.nsect;\r\nu8 set_xfer = !!(cmd->tf_flags & IDE_TFLAG_SET_XFER);\r\nide_complete_cmd(drive, cmd, stat, err);\r\nrq->errors = err;\r\nif (err == 0 && set_xfer) {\r\nide_set_xfer_rate(drive, nsect);\r\nide_driveid_update(drive);\r\n}\r\nide_complete_rq(drive, err ? -EIO : 0, blk_rq_bytes(rq));\r\n}\r\nstatic ide_startstop_t task_pio_intr(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nstruct ide_cmd *cmd = &drive->hwif->cmd;\r\nu8 stat = hwif->tp_ops->read_status(hwif);\r\nu8 write = !!(cmd->tf_flags & IDE_TFLAG_WRITE);\r\nif (write == 0) {\r\nif (stat & ATA_ERR)\r\ngoto out_err;\r\nif ((stat & ATA_DRQ) == 0) {\r\nif (OK_STAT(stat, ATA_DRDY, ATA_BUSY))\r\ngoto out_end;\r\ngoto out_wait;\r\n}\r\n} else {\r\nif (!OK_STAT(stat, DRIVE_READY, drive->bad_wstat))\r\ngoto out_err;\r\nif (((stat & ATA_DRQ) == 0) ^ (cmd->nleft == 0))\r\ngoto out_err;\r\n}\r\nif (write && cmd->nleft == 0)\r\ngoto out_end;\r\nide_pio_datablock(drive, cmd, write);\r\nif (write == 0 && cmd->nleft == 0) {\r\nstat = wait_drive_not_busy(drive);\r\nif (!OK_STAT(stat, 0, BAD_STAT))\r\ngoto out_err;\r\ngoto out_end;\r\n}\r\nout_wait:\r\nide_set_handler(drive, &task_pio_intr, WAIT_WORSTCASE);\r\nreturn ide_started;\r\nout_end:\r\nif ((cmd->tf_flags & IDE_TFLAG_FS) == 0)\r\nide_finish_cmd(drive, cmd, stat);\r\nelse\r\nide_complete_rq(drive, 0, blk_rq_sectors(cmd->rq) << 9);\r\nreturn ide_stopped;\r\nout_err:\r\nide_error_cmd(drive, cmd);\r\nreturn ide_error(drive, __func__, stat);\r\n}\r\nstatic ide_startstop_t pre_task_out_intr(ide_drive_t *drive,\r\nstruct ide_cmd *cmd)\r\n{\r\nide_startstop_t startstop;\r\nif (ide_wait_stat(&startstop, drive, ATA_DRQ,\r\ndrive->bad_wstat, WAIT_DRQ)) {\r\npr_err("%s: no DRQ after issuing %sWRITE%s\n", drive->name,\r\n(cmd->tf_flags & IDE_TFLAG_MULTI_PIO) ? "MULT" : "",\r\n(drive->dev_flags & IDE_DFLAG_LBA48) ? "_EXT" : "");\r\nreturn startstop;\r\n}\r\nif ((drive->dev_flags & IDE_DFLAG_UNMASK) == 0)\r\nlocal_irq_disable();\r\nide_set_handler(drive, &task_pio_intr, WAIT_WORSTCASE);\r\nide_pio_datablock(drive, cmd, 1);\r\nreturn ide_started;\r\n}\r\nint ide_raw_taskfile(ide_drive_t *drive, struct ide_cmd *cmd, u8 *buf,\r\nu16 nsect)\r\n{\r\nstruct request *rq;\r\nint error;\r\nint rw = !(cmd->tf_flags & IDE_TFLAG_WRITE) ? READ : WRITE;\r\nrq = blk_get_request(drive->queue, rw, __GFP_WAIT);\r\nrq->cmd_type = REQ_TYPE_ATA_TASKFILE;\r\nif (nsect) {\r\nerror = blk_rq_map_kern(drive->queue, rq, buf,\r\nnsect * SECTOR_SIZE, __GFP_WAIT);\r\nif (error)\r\ngoto put_req;\r\n}\r\nrq->special = cmd;\r\ncmd->rq = rq;\r\nerror = blk_execute_rq(drive->queue, NULL, rq, 0);\r\nput_req:\r\nblk_put_request(rq);\r\nreturn error;\r\n}\r\nint ide_no_data_taskfile(ide_drive_t *drive, struct ide_cmd *cmd)\r\n{\r\ncmd->protocol = ATA_PROT_NODATA;\r\nreturn ide_raw_taskfile(drive, cmd, NULL, 0);\r\n}\r\nint ide_taskfile_ioctl(ide_drive_t *drive, unsigned long arg)\r\n{\r\nide_task_request_t *req_task;\r\nstruct ide_cmd cmd;\r\nu8 *outbuf = NULL;\r\nu8 *inbuf = NULL;\r\nu8 *data_buf = NULL;\r\nint err = 0;\r\nint tasksize = sizeof(struct ide_task_request_s);\r\nunsigned int taskin = 0;\r\nunsigned int taskout = 0;\r\nu16 nsect = 0;\r\nchar __user *buf = (char __user *)arg;\r\nreq_task = memdup_user(buf, tasksize);\r\nif (IS_ERR(req_task))\r\nreturn PTR_ERR(req_task);\r\ntaskout = req_task->out_size;\r\ntaskin = req_task->in_size;\r\nif (taskin > 65536 || taskout > 65536) {\r\nerr = -EINVAL;\r\ngoto abort;\r\n}\r\nif (taskout) {\r\nint outtotal = tasksize;\r\noutbuf = kzalloc(taskout, GFP_KERNEL);\r\nif (outbuf == NULL) {\r\nerr = -ENOMEM;\r\ngoto abort;\r\n}\r\nif (copy_from_user(outbuf, buf + outtotal, taskout)) {\r\nerr = -EFAULT;\r\ngoto abort;\r\n}\r\n}\r\nif (taskin) {\r\nint intotal = tasksize + taskout;\r\ninbuf = kzalloc(taskin, GFP_KERNEL);\r\nif (inbuf == NULL) {\r\nerr = -ENOMEM;\r\ngoto abort;\r\n}\r\nif (copy_from_user(inbuf, buf + intotal, taskin)) {\r\nerr = -EFAULT;\r\ngoto abort;\r\n}\r\n}\r\nmemset(&cmd, 0, sizeof(cmd));\r\nmemcpy(&cmd.hob, req_task->hob_ports, HDIO_DRIVE_HOB_HDR_SIZE - 2);\r\nmemcpy(&cmd.tf, req_task->io_ports, HDIO_DRIVE_TASK_HDR_SIZE);\r\ncmd.valid.out.tf = IDE_VALID_DEVICE;\r\ncmd.valid.in.tf = IDE_VALID_DEVICE | IDE_VALID_IN_TF;\r\ncmd.tf_flags = IDE_TFLAG_IO_16BIT;\r\nif (drive->dev_flags & IDE_DFLAG_LBA48) {\r\ncmd.tf_flags |= IDE_TFLAG_LBA48;\r\ncmd.valid.in.hob = IDE_VALID_IN_HOB;\r\n}\r\nif (req_task->out_flags.all) {\r\ncmd.ftf_flags |= IDE_FTFLAG_FLAGGED;\r\nif (req_task->out_flags.b.data)\r\ncmd.ftf_flags |= IDE_FTFLAG_OUT_DATA;\r\nif (req_task->out_flags.b.nsector_hob)\r\ncmd.valid.out.hob |= IDE_VALID_NSECT;\r\nif (req_task->out_flags.b.sector_hob)\r\ncmd.valid.out.hob |= IDE_VALID_LBAL;\r\nif (req_task->out_flags.b.lcyl_hob)\r\ncmd.valid.out.hob |= IDE_VALID_LBAM;\r\nif (req_task->out_flags.b.hcyl_hob)\r\ncmd.valid.out.hob |= IDE_VALID_LBAH;\r\nif (req_task->out_flags.b.error_feature)\r\ncmd.valid.out.tf |= IDE_VALID_FEATURE;\r\nif (req_task->out_flags.b.nsector)\r\ncmd.valid.out.tf |= IDE_VALID_NSECT;\r\nif (req_task->out_flags.b.sector)\r\ncmd.valid.out.tf |= IDE_VALID_LBAL;\r\nif (req_task->out_flags.b.lcyl)\r\ncmd.valid.out.tf |= IDE_VALID_LBAM;\r\nif (req_task->out_flags.b.hcyl)\r\ncmd.valid.out.tf |= IDE_VALID_LBAH;\r\n} else {\r\ncmd.valid.out.tf |= IDE_VALID_OUT_TF;\r\nif (cmd.tf_flags & IDE_TFLAG_LBA48)\r\ncmd.valid.out.hob |= IDE_VALID_OUT_HOB;\r\n}\r\nif (req_task->in_flags.b.data)\r\ncmd.ftf_flags |= IDE_FTFLAG_IN_DATA;\r\nif (req_task->req_cmd == IDE_DRIVE_TASK_RAW_WRITE) {\r\nif (req_task->data_phase == TASKFILE_IN_DMAQ ||\r\nreq_task->data_phase == TASKFILE_IN_DMA)\r\ncmd.tf_flags |= IDE_TFLAG_WRITE;\r\n}\r\ncmd.protocol = ATA_PROT_DMA;\r\nswitch (req_task->data_phase) {\r\ncase TASKFILE_MULTI_OUT:\r\nif (!drive->mult_count) {\r\npr_err("%s: %s Multimode Write multcount is not set\n",\r\ndrive->name, __func__);\r\nerr = -EPERM;\r\ngoto abort;\r\n}\r\ncmd.tf_flags |= IDE_TFLAG_MULTI_PIO;\r\ncase TASKFILE_OUT:\r\ncmd.protocol = ATA_PROT_PIO;\r\ncase TASKFILE_OUT_DMAQ:\r\ncase TASKFILE_OUT_DMA:\r\ncmd.tf_flags |= IDE_TFLAG_WRITE;\r\nnsect = taskout / SECTOR_SIZE;\r\ndata_buf = outbuf;\r\nbreak;\r\ncase TASKFILE_MULTI_IN:\r\nif (!drive->mult_count) {\r\npr_err("%s: %s Multimode Read multcount is not set\n",\r\ndrive->name, __func__);\r\nerr = -EPERM;\r\ngoto abort;\r\n}\r\ncmd.tf_flags |= IDE_TFLAG_MULTI_PIO;\r\ncase TASKFILE_IN:\r\ncmd.protocol = ATA_PROT_PIO;\r\ncase TASKFILE_IN_DMAQ:\r\ncase TASKFILE_IN_DMA:\r\nnsect = taskin / SECTOR_SIZE;\r\ndata_buf = inbuf;\r\nbreak;\r\ncase TASKFILE_NO_DATA:\r\ncmd.protocol = ATA_PROT_NODATA;\r\nbreak;\r\ndefault:\r\nerr = -EFAULT;\r\ngoto abort;\r\n}\r\nif (req_task->req_cmd == IDE_DRIVE_TASK_NO_DATA)\r\nnsect = 0;\r\nelse if (!nsect) {\r\nnsect = (cmd.hob.nsect << 8) | cmd.tf.nsect;\r\nif (!nsect) {\r\npr_err("%s: in/out command without data\n",\r\ndrive->name);\r\nerr = -EFAULT;\r\ngoto abort;\r\n}\r\n}\r\nerr = ide_raw_taskfile(drive, &cmd, data_buf, nsect);\r\nmemcpy(req_task->hob_ports, &cmd.hob, HDIO_DRIVE_HOB_HDR_SIZE - 2);\r\nmemcpy(req_task->io_ports, &cmd.tf, HDIO_DRIVE_TASK_HDR_SIZE);\r\nif ((cmd.ftf_flags & IDE_FTFLAG_SET_IN_FLAGS) &&\r\nreq_task->in_flags.all == 0) {\r\nreq_task->in_flags.all = IDE_TASKFILE_STD_IN_FLAGS;\r\nif (drive->dev_flags & IDE_DFLAG_LBA48)\r\nreq_task->in_flags.all |= (IDE_HOB_STD_IN_FLAGS << 8);\r\n}\r\nif (copy_to_user(buf, req_task, tasksize)) {\r\nerr = -EFAULT;\r\ngoto abort;\r\n}\r\nif (taskout) {\r\nint outtotal = tasksize;\r\nif (copy_to_user(buf + outtotal, outbuf, taskout)) {\r\nerr = -EFAULT;\r\ngoto abort;\r\n}\r\n}\r\nif (taskin) {\r\nint intotal = tasksize + taskout;\r\nif (copy_to_user(buf + intotal, inbuf, taskin)) {\r\nerr = -EFAULT;\r\ngoto abort;\r\n}\r\n}\r\nabort:\r\nkfree(req_task);\r\nkfree(outbuf);\r\nkfree(inbuf);\r\nreturn err;\r\n}
