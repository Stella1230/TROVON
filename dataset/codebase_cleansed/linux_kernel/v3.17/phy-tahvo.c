static ssize_t vbus_state_show(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct tahvo_usb *tu = dev_get_drvdata(device);\r\nreturn sprintf(buf, "%s\n", tu->vbus_state ? "on" : "off");\r\n}\r\nstatic void check_vbus_state(struct tahvo_usb *tu)\r\n{\r\nstruct retu_dev *rdev = dev_get_drvdata(tu->pt_dev->dev.parent);\r\nint reg, prev_state;\r\nreg = retu_read(rdev, TAHVO_REG_IDSR);\r\nif (reg & TAHVO_STAT_VBUS) {\r\nswitch (tu->phy.state) {\r\ncase OTG_STATE_B_IDLE:\r\nif (tu->phy.otg->gadget)\r\nusb_gadget_vbus_connect(tu->phy.otg->gadget);\r\ntu->phy.state = OTG_STATE_B_PERIPHERAL;\r\nbreak;\r\ncase OTG_STATE_A_IDLE:\r\ntu->phy.state = OTG_STATE_A_HOST;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndev_info(&tu->pt_dev->dev, "USB cable connected\n");\r\n} else {\r\nswitch (tu->phy.state) {\r\ncase OTG_STATE_B_PERIPHERAL:\r\nif (tu->phy.otg->gadget)\r\nusb_gadget_vbus_disconnect(tu->phy.otg->gadget);\r\ntu->phy.state = OTG_STATE_B_IDLE;\r\nbreak;\r\ncase OTG_STATE_A_HOST:\r\ntu->phy.state = OTG_STATE_A_IDLE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndev_info(&tu->pt_dev->dev, "USB cable disconnected\n");\r\n}\r\nprev_state = tu->vbus_state;\r\ntu->vbus_state = reg & TAHVO_STAT_VBUS;\r\nif (prev_state != tu->vbus_state) {\r\nextcon_set_cable_state(&tu->extcon, "USB", tu->vbus_state);\r\nsysfs_notify(&tu->pt_dev->dev.kobj, NULL, "vbus_state");\r\n}\r\n}\r\nstatic void tahvo_usb_become_host(struct tahvo_usb *tu)\r\n{\r\nstruct retu_dev *rdev = dev_get_drvdata(tu->pt_dev->dev.parent);\r\nextcon_set_cable_state(&tu->extcon, "USB-HOST", true);\r\nretu_write(rdev, TAHVO_REG_USBR, USBR_REGOUT | USBR_NSUSPEND |\r\nUSBR_MASTER_SW2 | USBR_MASTER_SW1);\r\ntu->phy.state = OTG_STATE_A_IDLE;\r\ncheck_vbus_state(tu);\r\n}\r\nstatic void tahvo_usb_stop_host(struct tahvo_usb *tu)\r\n{\r\ntu->phy.state = OTG_STATE_A_IDLE;\r\n}\r\nstatic void tahvo_usb_become_peripheral(struct tahvo_usb *tu)\r\n{\r\nstruct retu_dev *rdev = dev_get_drvdata(tu->pt_dev->dev.parent);\r\nextcon_set_cable_state(&tu->extcon, "USB-HOST", false);\r\nretu_write(rdev, TAHVO_REG_USBR, USBR_SLAVE_CONTROL | USBR_REGOUT |\r\nUSBR_NSUSPEND | USBR_SLAVE_SW);\r\ntu->phy.state = OTG_STATE_B_IDLE;\r\ncheck_vbus_state(tu);\r\n}\r\nstatic void tahvo_usb_stop_peripheral(struct tahvo_usb *tu)\r\n{\r\nif (tu->phy.otg->gadget)\r\nusb_gadget_vbus_disconnect(tu->phy.otg->gadget);\r\ntu->phy.state = OTG_STATE_B_IDLE;\r\n}\r\nstatic void tahvo_usb_power_off(struct tahvo_usb *tu)\r\n{\r\nstruct retu_dev *rdev = dev_get_drvdata(tu->pt_dev->dev.parent);\r\nif (tu->phy.otg->gadget)\r\nusb_gadget_vbus_disconnect(tu->phy.otg->gadget);\r\nretu_write(rdev, TAHVO_REG_USBR, 0);\r\ntu->phy.state = OTG_STATE_UNDEFINED;\r\n}\r\nstatic int tahvo_usb_set_suspend(struct usb_phy *dev, int suspend)\r\n{\r\nstruct tahvo_usb *tu = container_of(dev, struct tahvo_usb, phy);\r\nstruct retu_dev *rdev = dev_get_drvdata(tu->pt_dev->dev.parent);\r\nu16 w;\r\ndev_dbg(&tu->pt_dev->dev, "%s\n", __func__);\r\nw = retu_read(rdev, TAHVO_REG_USBR);\r\nif (suspend)\r\nw &= ~USBR_NSUSPEND;\r\nelse\r\nw |= USBR_NSUSPEND;\r\nretu_write(rdev, TAHVO_REG_USBR, w);\r\nreturn 0;\r\n}\r\nstatic int tahvo_usb_set_host(struct usb_otg *otg, struct usb_bus *host)\r\n{\r\nstruct tahvo_usb *tu = container_of(otg->phy, struct tahvo_usb, phy);\r\ndev_dbg(&tu->pt_dev->dev, "%s %p\n", __func__, host);\r\nmutex_lock(&tu->serialize);\r\nif (host == NULL) {\r\nif (tu->tahvo_mode == TAHVO_MODE_HOST)\r\ntahvo_usb_power_off(tu);\r\notg->host = NULL;\r\nmutex_unlock(&tu->serialize);\r\nreturn 0;\r\n}\r\nif (tu->tahvo_mode == TAHVO_MODE_HOST) {\r\notg->host = NULL;\r\ntahvo_usb_become_host(tu);\r\n}\r\notg->host = host;\r\nmutex_unlock(&tu->serialize);\r\nreturn 0;\r\n}\r\nstatic int tahvo_usb_set_peripheral(struct usb_otg *otg,\r\nstruct usb_gadget *gadget)\r\n{\r\nstruct tahvo_usb *tu = container_of(otg->phy, struct tahvo_usb, phy);\r\ndev_dbg(&tu->pt_dev->dev, "%s %p\n", __func__, gadget);\r\nmutex_lock(&tu->serialize);\r\nif (!gadget) {\r\nif (tu->tahvo_mode == TAHVO_MODE_PERIPHERAL)\r\ntahvo_usb_power_off(tu);\r\ntu->phy.otg->gadget = NULL;\r\nmutex_unlock(&tu->serialize);\r\nreturn 0;\r\n}\r\ntu->phy.otg->gadget = gadget;\r\nif (tu->tahvo_mode == TAHVO_MODE_PERIPHERAL)\r\ntahvo_usb_become_peripheral(tu);\r\nmutex_unlock(&tu->serialize);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t tahvo_usb_vbus_interrupt(int irq, void *_tu)\r\n{\r\nstruct tahvo_usb *tu = _tu;\r\nmutex_lock(&tu->serialize);\r\ncheck_vbus_state(tu);\r\nmutex_unlock(&tu->serialize);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic ssize_t otg_mode_show(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct tahvo_usb *tu = dev_get_drvdata(device);\r\nswitch (tu->tahvo_mode) {\r\ncase TAHVO_MODE_HOST:\r\nreturn sprintf(buf, "host\n");\r\ncase TAHVO_MODE_PERIPHERAL:\r\nreturn sprintf(buf, "peripheral\n");\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t otg_mode_store(struct device *device,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct tahvo_usb *tu = dev_get_drvdata(device);\r\nint r;\r\nmutex_lock(&tu->serialize);\r\nif (count >= 4 && strncmp(buf, "host", 4) == 0) {\r\nif (tu->tahvo_mode == TAHVO_MODE_PERIPHERAL)\r\ntahvo_usb_stop_peripheral(tu);\r\ntu->tahvo_mode = TAHVO_MODE_HOST;\r\nif (tu->phy.otg->host) {\r\ndev_info(device, "HOST mode: host controller present\n");\r\ntahvo_usb_become_host(tu);\r\n} else {\r\ndev_info(device, "HOST mode: no host controller, powering off\n");\r\ntahvo_usb_power_off(tu);\r\n}\r\nr = strlen(buf);\r\n} else if (count >= 10 && strncmp(buf, "peripheral", 10) == 0) {\r\nif (tu->tahvo_mode == TAHVO_MODE_HOST)\r\ntahvo_usb_stop_host(tu);\r\ntu->tahvo_mode = TAHVO_MODE_PERIPHERAL;\r\nif (tu->phy.otg->gadget) {\r\ndev_info(device, "PERIPHERAL mode: gadget driver present\n");\r\ntahvo_usb_become_peripheral(tu);\r\n} else {\r\ndev_info(device, "PERIPHERAL mode: no gadget driver, powering off\n");\r\ntahvo_usb_power_off(tu);\r\n}\r\nr = strlen(buf);\r\n} else {\r\nr = -EINVAL;\r\n}\r\nmutex_unlock(&tu->serialize);\r\nreturn r;\r\n}\r\nstatic int tahvo_usb_probe(struct platform_device *pdev)\r\n{\r\nstruct retu_dev *rdev = dev_get_drvdata(pdev->dev.parent);\r\nstruct tahvo_usb *tu;\r\nint ret;\r\ntu = devm_kzalloc(&pdev->dev, sizeof(*tu), GFP_KERNEL);\r\nif (!tu)\r\nreturn -ENOMEM;\r\ntu->phy.otg = devm_kzalloc(&pdev->dev, sizeof(*tu->phy.otg),\r\nGFP_KERNEL);\r\nif (!tu->phy.otg)\r\nreturn -ENOMEM;\r\ntu->pt_dev = pdev;\r\n#ifdef CONFIG_TAHVO_USB_HOST_BY_DEFAULT\r\ntu->tahvo_mode = TAHVO_MODE_HOST;\r\n#else\r\ntu->tahvo_mode = TAHVO_MODE_PERIPHERAL;\r\n#endif\r\nmutex_init(&tu->serialize);\r\ntu->ick = devm_clk_get(&pdev->dev, "usb_l4_ick");\r\nif (!IS_ERR(tu->ick))\r\nclk_enable(tu->ick);\r\ntu->vbus_state = retu_read(rdev, TAHVO_REG_IDSR) & TAHVO_STAT_VBUS;\r\ntu->extcon.name = DRIVER_NAME;\r\ntu->extcon.supported_cable = tahvo_cable;\r\ntu->extcon.dev.parent = &pdev->dev;\r\nret = extcon_dev_register(&tu->extcon);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not register extcon device: %d\n",\r\nret);\r\ngoto err_disable_clk;\r\n}\r\nextcon_set_cable_state(&tu->extcon, "USB-HOST",\r\ntu->tahvo_mode == TAHVO_MODE_HOST);\r\nextcon_set_cable_state(&tu->extcon, "USB", tu->vbus_state);\r\ntahvo_usb_power_off(tu);\r\ntu->phy.dev = &pdev->dev;\r\ntu->phy.state = OTG_STATE_UNDEFINED;\r\ntu->phy.label = DRIVER_NAME;\r\ntu->phy.set_suspend = tahvo_usb_set_suspend;\r\ntu->phy.otg->phy = &tu->phy;\r\ntu->phy.otg->set_host = tahvo_usb_set_host;\r\ntu->phy.otg->set_peripheral = tahvo_usb_set_peripheral;\r\nret = usb_add_phy(&tu->phy, USB_PHY_TYPE_USB2);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "cannot register USB transceiver: %d\n",\r\nret);\r\ngoto err_extcon_unreg;\r\n}\r\ndev_set_drvdata(&pdev->dev, tu);\r\ntu->irq = platform_get_irq(pdev, 0);\r\nret = request_threaded_irq(tu->irq, NULL, tahvo_usb_vbus_interrupt, 0,\r\n"tahvo-vbus", tu);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not register tahvo-vbus irq: %d\n",\r\nret);\r\ngoto err_remove_phy;\r\n}\r\nret = sysfs_create_group(&pdev->dev.kobj, &tahvo_attr_group);\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot create sysfs group: %d\n", ret);\r\ngoto err_free_irq;\r\n}\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(tu->irq, tu);\r\nerr_remove_phy:\r\nusb_remove_phy(&tu->phy);\r\nerr_extcon_unreg:\r\nextcon_dev_unregister(&tu->extcon);\r\nerr_disable_clk:\r\nif (!IS_ERR(tu->ick))\r\nclk_disable(tu->ick);\r\nreturn ret;\r\n}\r\nstatic int tahvo_usb_remove(struct platform_device *pdev)\r\n{\r\nstruct tahvo_usb *tu = platform_get_drvdata(pdev);\r\nsysfs_remove_group(&pdev->dev.kobj, &tahvo_attr_group);\r\nfree_irq(tu->irq, tu);\r\nusb_remove_phy(&tu->phy);\r\nextcon_dev_unregister(&tu->extcon);\r\nif (!IS_ERR(tu->ick))\r\nclk_disable(tu->ick);\r\nreturn 0;\r\n}
