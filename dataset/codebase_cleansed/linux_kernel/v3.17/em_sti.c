static inline unsigned long em_sti_read(struct em_sti_priv *p, int offs)\r\n{\r\nreturn ioread32(p->base + offs);\r\n}\r\nstatic inline void em_sti_write(struct em_sti_priv *p, int offs,\r\nunsigned long value)\r\n{\r\niowrite32(value, p->base + offs);\r\n}\r\nstatic int em_sti_enable(struct em_sti_priv *p)\r\n{\r\nint ret;\r\nret = clk_prepare_enable(p->clk);\r\nif (ret) {\r\ndev_err(&p->pdev->dev, "cannot enable clock\n");\r\nreturn ret;\r\n}\r\np->rate = clk_get_rate(p->clk);\r\nem_sti_write(p, STI_SET_H, 0x40000000);\r\nem_sti_write(p, STI_SET_L, 0x00000000);\r\nem_sti_write(p, STI_INTENCLR, 3);\r\nem_sti_write(p, STI_INTFFCLR, 3);\r\nem_sti_write(p, STI_CONTROL, 1);\r\nreturn 0;\r\n}\r\nstatic void em_sti_disable(struct em_sti_priv *p)\r\n{\r\nem_sti_write(p, STI_INTENCLR, 3);\r\nclk_disable_unprepare(p->clk);\r\n}\r\nstatic cycle_t em_sti_count(struct em_sti_priv *p)\r\n{\r\ncycle_t ticks;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&p->lock, flags);\r\nticks = (cycle_t)(em_sti_read(p, STI_COUNT_H) & 0xffff) << 32;\r\nticks |= em_sti_read(p, STI_COUNT_L);\r\nraw_spin_unlock_irqrestore(&p->lock, flags);\r\nreturn ticks;\r\n}\r\nstatic cycle_t em_sti_set_next(struct em_sti_priv *p, cycle_t next)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&p->lock, flags);\r\nem_sti_write(p, STI_INTENCLR, 1);\r\nem_sti_write(p, STI_COMPA_H, next >> 32);\r\nem_sti_write(p, STI_COMPA_L, next & 0xffffffff);\r\nem_sti_write(p, STI_INTFFCLR, 1);\r\nem_sti_write(p, STI_INTENSET, 1);\r\nraw_spin_unlock_irqrestore(&p->lock, flags);\r\nreturn next;\r\n}\r\nstatic irqreturn_t em_sti_interrupt(int irq, void *dev_id)\r\n{\r\nstruct em_sti_priv *p = dev_id;\r\np->ced.event_handler(&p->ced);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int em_sti_start(struct em_sti_priv *p, unsigned int user)\r\n{\r\nunsigned long flags;\r\nint used_before;\r\nint ret = 0;\r\nraw_spin_lock_irqsave(&p->lock, flags);\r\nused_before = p->active[USER_CLOCKSOURCE] | p->active[USER_CLOCKEVENT];\r\nif (!used_before)\r\nret = em_sti_enable(p);\r\nif (!ret)\r\np->active[user] = 1;\r\nraw_spin_unlock_irqrestore(&p->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void em_sti_stop(struct em_sti_priv *p, unsigned int user)\r\n{\r\nunsigned long flags;\r\nint used_before, used_after;\r\nraw_spin_lock_irqsave(&p->lock, flags);\r\nused_before = p->active[USER_CLOCKSOURCE] | p->active[USER_CLOCKEVENT];\r\np->active[user] = 0;\r\nused_after = p->active[USER_CLOCKSOURCE] | p->active[USER_CLOCKEVENT];\r\nif (used_before && !used_after)\r\nem_sti_disable(p);\r\nraw_spin_unlock_irqrestore(&p->lock, flags);\r\n}\r\nstatic struct em_sti_priv *cs_to_em_sti(struct clocksource *cs)\r\n{\r\nreturn container_of(cs, struct em_sti_priv, cs);\r\n}\r\nstatic cycle_t em_sti_clocksource_read(struct clocksource *cs)\r\n{\r\nreturn em_sti_count(cs_to_em_sti(cs));\r\n}\r\nstatic int em_sti_clocksource_enable(struct clocksource *cs)\r\n{\r\nint ret;\r\nstruct em_sti_priv *p = cs_to_em_sti(cs);\r\nret = em_sti_start(p, USER_CLOCKSOURCE);\r\nif (!ret)\r\n__clocksource_updatefreq_hz(cs, p->rate);\r\nreturn ret;\r\n}\r\nstatic void em_sti_clocksource_disable(struct clocksource *cs)\r\n{\r\nem_sti_stop(cs_to_em_sti(cs), USER_CLOCKSOURCE);\r\n}\r\nstatic void em_sti_clocksource_resume(struct clocksource *cs)\r\n{\r\nem_sti_clocksource_enable(cs);\r\n}\r\nstatic int em_sti_register_clocksource(struct em_sti_priv *p)\r\n{\r\nstruct clocksource *cs = &p->cs;\r\nmemset(cs, 0, sizeof(*cs));\r\ncs->name = dev_name(&p->pdev->dev);\r\ncs->rating = 200;\r\ncs->read = em_sti_clocksource_read;\r\ncs->enable = em_sti_clocksource_enable;\r\ncs->disable = em_sti_clocksource_disable;\r\ncs->suspend = em_sti_clocksource_disable;\r\ncs->resume = em_sti_clocksource_resume;\r\ncs->mask = CLOCKSOURCE_MASK(48);\r\ncs->flags = CLOCK_SOURCE_IS_CONTINUOUS;\r\ndev_info(&p->pdev->dev, "used as clock source\n");\r\nclocksource_register_hz(cs, 1);\r\nreturn 0;\r\n}\r\nstatic struct em_sti_priv *ced_to_em_sti(struct clock_event_device *ced)\r\n{\r\nreturn container_of(ced, struct em_sti_priv, ced);\r\n}\r\nstatic void em_sti_clock_event_mode(enum clock_event_mode mode,\r\nstruct clock_event_device *ced)\r\n{\r\nstruct em_sti_priv *p = ced_to_em_sti(ced);\r\nswitch (ced->mode) {\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\nem_sti_stop(p, USER_CLOCKEVENT);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\ndev_info(&p->pdev->dev, "used for oneshot clock events\n");\r\nem_sti_start(p, USER_CLOCKEVENT);\r\nclockevents_config(&p->ced, p->rate);\r\nbreak;\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\ncase CLOCK_EVT_MODE_UNUSED:\r\nem_sti_stop(p, USER_CLOCKEVENT);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int em_sti_clock_event_next(unsigned long delta,\r\nstruct clock_event_device *ced)\r\n{\r\nstruct em_sti_priv *p = ced_to_em_sti(ced);\r\ncycle_t next;\r\nint safe;\r\nnext = em_sti_set_next(p, em_sti_count(p) + delta);\r\nsafe = em_sti_count(p) < (next - 1);\r\nreturn !safe;\r\n}\r\nstatic void em_sti_register_clockevent(struct em_sti_priv *p)\r\n{\r\nstruct clock_event_device *ced = &p->ced;\r\nmemset(ced, 0, sizeof(*ced));\r\nced->name = dev_name(&p->pdev->dev);\r\nced->features = CLOCK_EVT_FEAT_ONESHOT;\r\nced->rating = 200;\r\nced->cpumask = cpu_possible_mask;\r\nced->set_next_event = em_sti_clock_event_next;\r\nced->set_mode = em_sti_clock_event_mode;\r\ndev_info(&p->pdev->dev, "used for clock events\n");\r\nclockevents_config_and_register(ced, 1, 2, 0xffffffff);\r\n}\r\nstatic int em_sti_probe(struct platform_device *pdev)\r\n{\r\nstruct em_sti_priv *p;\r\nstruct resource *res;\r\nint irq;\r\np = devm_kzalloc(&pdev->dev, sizeof(*p), GFP_KERNEL);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\np->pdev = pdev;\r\nplatform_set_drvdata(pdev, p);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "failed to get irq\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\np->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(p->base))\r\nreturn PTR_ERR(p->base);\r\np->clk = devm_clk_get(&pdev->dev, "sclk");\r\nif (IS_ERR(p->clk)) {\r\ndev_err(&pdev->dev, "cannot get clock\n");\r\nreturn PTR_ERR(p->clk);\r\n}\r\nif (devm_request_irq(&pdev->dev, irq, em_sti_interrupt,\r\nIRQF_TIMER | IRQF_IRQPOLL | IRQF_NOBALANCING,\r\ndev_name(&pdev->dev), p)) {\r\ndev_err(&pdev->dev, "failed to request low IRQ\n");\r\nreturn -ENOENT;\r\n}\r\nraw_spin_lock_init(&p->lock);\r\nem_sti_register_clockevent(p);\r\nem_sti_register_clocksource(p);\r\nreturn 0;\r\n}\r\nstatic int em_sti_remove(struct platform_device *pdev)\r\n{\r\nreturn -EBUSY;\r\n}\r\nstatic int __init em_sti_init(void)\r\n{\r\nreturn platform_driver_register(&em_sti_device_driver);\r\n}\r\nstatic void __exit em_sti_exit(void)\r\n{\r\nplatform_driver_unregister(&em_sti_device_driver);\r\n}
