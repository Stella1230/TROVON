static void fimc_is_put_clocks(struct fimc_is *is)\r\n{\r\nint i;\r\nfor (i = 0; i < ISS_CLKS_MAX; i++) {\r\nif (IS_ERR(is->clocks[i]))\r\ncontinue;\r\nclk_put(is->clocks[i]);\r\nis->clocks[i] = ERR_PTR(-EINVAL);\r\n}\r\n}\r\nstatic int fimc_is_get_clocks(struct fimc_is *is)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < ISS_CLKS_MAX; i++)\r\nis->clocks[i] = ERR_PTR(-EINVAL);\r\nfor (i = 0; i < ISS_CLKS_MAX; i++) {\r\nis->clocks[i] = clk_get(&is->pdev->dev, fimc_is_clocks[i]);\r\nif (IS_ERR(is->clocks[i])) {\r\nret = PTR_ERR(is->clocks[i]);\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\nfimc_is_put_clocks(is);\r\ndev_err(&is->pdev->dev, "failed to get clock: %s\n",\r\nfimc_is_clocks[i]);\r\nreturn ret;\r\n}\r\nstatic int fimc_is_setup_clocks(struct fimc_is *is)\r\n{\r\nint ret;\r\nret = clk_set_parent(is->clocks[ISS_CLK_ACLK200],\r\nis->clocks[ISS_CLK_ACLK200_DIV]);\r\nif (ret < 0)\r\nreturn ret;\r\nret = clk_set_parent(is->clocks[ISS_CLK_ACLK400MCUISP],\r\nis->clocks[ISS_CLK_ACLK400MCUISP_DIV]);\r\nif (ret < 0)\r\nreturn ret;\r\nret = clk_set_rate(is->clocks[ISS_CLK_ISP_DIV0], ACLK_AXI_FREQUENCY);\r\nif (ret < 0)\r\nreturn ret;\r\nret = clk_set_rate(is->clocks[ISS_CLK_ISP_DIV1], ACLK_AXI_FREQUENCY);\r\nif (ret < 0)\r\nreturn ret;\r\nret = clk_set_rate(is->clocks[ISS_CLK_MCUISP_DIV0],\r\nATCLK_MCUISP_FREQUENCY);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn clk_set_rate(is->clocks[ISS_CLK_MCUISP_DIV1],\r\nATCLK_MCUISP_FREQUENCY);\r\n}\r\nstatic int fimc_is_enable_clocks(struct fimc_is *is)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < ISS_GATE_CLKS_MAX; i++) {\r\nif (IS_ERR(is->clocks[i]))\r\ncontinue;\r\nret = clk_prepare_enable(is->clocks[i]);\r\nif (ret < 0) {\r\ndev_err(&is->pdev->dev, "clock %s enable failed\n",\r\nfimc_is_clocks[i]);\r\nfor (--i; i >= 0; i--)\r\nclk_disable(is->clocks[i]);\r\nreturn ret;\r\n}\r\npr_debug("enabled clock: %s\n", fimc_is_clocks[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void fimc_is_disable_clocks(struct fimc_is *is)\r\n{\r\nint i;\r\nfor (i = 0; i < ISS_GATE_CLKS_MAX; i++) {\r\nif (!IS_ERR(is->clocks[i])) {\r\nclk_disable_unprepare(is->clocks[i]);\r\npr_debug("disabled clock: %s\n", fimc_is_clocks[i]);\r\n}\r\n}\r\n}\r\nstatic int fimc_is_parse_sensor_config(struct fimc_is *is, unsigned int index,\r\nstruct device_node *node)\r\n{\r\nstruct fimc_is_sensor *sensor = &is->sensor[index];\r\nu32 tmp = 0;\r\nint ret;\r\nsensor->drvdata = fimc_is_sensor_get_drvdata(node);\r\nif (!sensor->drvdata) {\r\ndev_err(&is->pdev->dev, "no driver data found for: %s\n",\r\nnode->full_name);\r\nreturn -EINVAL;\r\n}\r\nnode = of_graph_get_next_endpoint(node, NULL);\r\nif (!node)\r\nreturn -ENXIO;\r\nnode = of_graph_get_remote_port(node);\r\nif (!node)\r\nreturn -ENXIO;\r\nret = of_property_read_u32(node, "reg", &tmp);\r\nif (ret < 0) {\r\ndev_err(&is->pdev->dev, "reg property not found at: %s\n",\r\nnode->full_name);\r\nreturn ret;\r\n}\r\nsensor->i2c_bus = tmp - FIMC_INPUT_MIPI_CSI2_0;\r\nreturn 0;\r\n}\r\nstatic int fimc_is_register_subdevs(struct fimc_is *is)\r\n{\r\nstruct device_node *i2c_bus, *child;\r\nint ret, index = 0;\r\nret = fimc_isp_subdev_create(&is->isp);\r\nif (ret < 0)\r\nreturn ret;\r\nis->isp.alloc_ctx = is->alloc_ctx;\r\nfor_each_compatible_node(i2c_bus, NULL, FIMC_IS_I2C_COMPATIBLE) {\r\nfor_each_available_child_of_node(i2c_bus, child) {\r\nret = fimc_is_parse_sensor_config(is, index, child);\r\nif (ret < 0 || index >= FIMC_IS_SENSORS_NUM) {\r\nof_node_put(child);\r\nreturn ret;\r\n}\r\nindex++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int fimc_is_unregister_subdevs(struct fimc_is *is)\r\n{\r\nfimc_isp_subdev_destroy(&is->isp);\r\nreturn 0;\r\n}\r\nstatic int fimc_is_load_setfile(struct fimc_is *is, char *file_name)\r\n{\r\nconst struct firmware *fw;\r\nvoid *buf;\r\nint ret;\r\nret = request_firmware(&fw, file_name, &is->pdev->dev);\r\nif (ret < 0) {\r\ndev_err(&is->pdev->dev, "firmware request failed (%d)\n", ret);\r\nreturn ret;\r\n}\r\nbuf = is->memory.vaddr + is->setfile.base;\r\nmemcpy(buf, fw->data, fw->size);\r\nfimc_is_mem_barrier();\r\nis->setfile.size = fw->size;\r\npr_debug("mem vaddr: %p, setfile buf: %p\n", is->memory.vaddr, buf);\r\nmemcpy(is->fw.setfile_info,\r\nfw->data + fw->size - FIMC_IS_SETFILE_INFO_LEN,\r\nFIMC_IS_SETFILE_INFO_LEN - 1);\r\nis->fw.setfile_info[FIMC_IS_SETFILE_INFO_LEN - 1] = '\0';\r\nis->setfile.state = 1;\r\npr_debug("FIMC-IS setfile loaded: base: %#x, size: %zu B\n",\r\nis->setfile.base, fw->size);\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nint fimc_is_cpu_set_power(struct fimc_is *is, int on)\r\n{\r\nunsigned int timeout = FIMC_IS_POWER_ON_TIMEOUT;\r\nif (on) {\r\nmcuctl_write(0, is, REG_WDT_ISP);\r\nmcuctl_write(is->memory.paddr, is, MCUCTL_REG_BBOAR);\r\npmuisp_write(0x18000, is, REG_PMU_ISP_ARM_OPTION);\r\npmuisp_write(0x1, is, REG_PMU_ISP_ARM_CONFIGURATION);\r\n} else {\r\npmuisp_write(0x10000, is, REG_PMU_ISP_ARM_OPTION);\r\npmuisp_write(0x0, is, REG_PMU_ISP_ARM_CONFIGURATION);\r\nwhile (pmuisp_read(is, REG_PMU_ISP_ARM_STATUS) & 1) {\r\nif (timeout == 0)\r\nreturn -ETIME;\r\ntimeout--;\r\nudelay(1);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint fimc_is_wait_event(struct fimc_is *is, unsigned long bit,\r\nunsigned int state, unsigned int timeout)\r\n{\r\nint ret = wait_event_timeout(is->irq_queue,\r\n!state ^ test_bit(bit, &is->state),\r\ntimeout);\r\nif (ret == 0) {\r\ndev_WARN(&is->pdev->dev, "%s() timed out\n", __func__);\r\nreturn -ETIME;\r\n}\r\nreturn 0;\r\n}\r\nint fimc_is_start_firmware(struct fimc_is *is)\r\n{\r\nstruct device *dev = &is->pdev->dev;\r\nint ret;\r\nif (is->fw.f_w == NULL) {\r\ndev_err(dev, "firmware is not loaded\n");\r\nreturn -EINVAL;\r\n}\r\nmemcpy(is->memory.vaddr, is->fw.f_w->data, is->fw.f_w->size);\r\nwmb();\r\nret = fimc_is_cpu_set_power(is, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = fimc_is_wait_event(is, IS_ST_A5_PWR_ON, 1,\r\nmsecs_to_jiffies(FIMC_IS_FW_LOAD_TIMEOUT));\r\nif (ret < 0)\r\ndev_err(dev, "FIMC-IS CPU power on failed\n");\r\nreturn ret;\r\n}\r\nstatic int fimc_is_alloc_cpu_memory(struct fimc_is *is)\r\n{\r\nstruct device *dev = &is->pdev->dev;\r\nis->memory.vaddr = dma_alloc_coherent(dev, FIMC_IS_CPU_MEM_SIZE,\r\n&is->memory.paddr, GFP_KERNEL);\r\nif (is->memory.vaddr == NULL)\r\nreturn -ENOMEM;\r\nis->memory.size = FIMC_IS_CPU_MEM_SIZE;\r\nmemset(is->memory.vaddr, 0, is->memory.size);\r\ndev_info(dev, "FIMC-IS CPU memory base: %#x\n", (u32)is->memory.paddr);\r\nif (((u32)is->memory.paddr) & FIMC_IS_FW_ADDR_MASK) {\r\ndev_err(dev, "invalid firmware memory alignment: %#x\n",\r\n(u32)is->memory.paddr);\r\ndma_free_coherent(dev, is->memory.size, is->memory.vaddr,\r\nis->memory.paddr);\r\nreturn -EIO;\r\n}\r\nis->is_p_region = (struct is_region *)(is->memory.vaddr +\r\nFIMC_IS_CPU_MEM_SIZE - FIMC_IS_REGION_SIZE);\r\nis->is_dma_p_region = is->memory.paddr +\r\nFIMC_IS_CPU_MEM_SIZE - FIMC_IS_REGION_SIZE;\r\nis->is_shared_region = (struct is_share_region *)(is->memory.vaddr +\r\nFIMC_IS_SHARED_REGION_OFFSET);\r\nreturn 0;\r\n}\r\nstatic void fimc_is_free_cpu_memory(struct fimc_is *is)\r\n{\r\nstruct device *dev = &is->pdev->dev;\r\nif (is->memory.vaddr == NULL)\r\nreturn;\r\ndma_free_coherent(dev, is->memory.size, is->memory.vaddr,\r\nis->memory.paddr);\r\n}\r\nstatic void fimc_is_load_firmware(const struct firmware *fw, void *context)\r\n{\r\nstruct fimc_is *is = context;\r\nstruct device *dev = &is->pdev->dev;\r\nvoid *buf;\r\nint ret;\r\nif (fw == NULL) {\r\ndev_err(dev, "firmware request failed\n");\r\nreturn;\r\n}\r\nmutex_lock(&is->lock);\r\nif (fw->size < FIMC_IS_FW_SIZE_MIN || fw->size > FIMC_IS_FW_SIZE_MAX) {\r\ndev_err(dev, "wrong firmware size: %d\n", fw->size);\r\ngoto done;\r\n}\r\nis->fw.size = fw->size;\r\nret = fimc_is_alloc_cpu_memory(is);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to allocate FIMC-IS CPU memory\n");\r\ngoto done;\r\n}\r\nmemcpy(is->memory.vaddr, fw->data, fw->size);\r\nwmb();\r\nbuf = (void *)(is->memory.vaddr + fw->size - FIMC_IS_FW_DESC_LEN);\r\nmemcpy(&is->fw.info, buf, FIMC_IS_FW_INFO_LEN);\r\nis->fw.info[FIMC_IS_FW_INFO_LEN] = 0;\r\nbuf = (void *)(is->memory.vaddr + fw->size - FIMC_IS_FW_VER_LEN);\r\nmemcpy(&is->fw.version, buf, FIMC_IS_FW_VER_LEN);\r\nis->fw.version[FIMC_IS_FW_VER_LEN - 1] = 0;\r\nis->fw.state = 1;\r\ndev_info(dev, "loaded firmware: %s, rev. %s\n",\r\nis->fw.info, is->fw.version);\r\ndev_dbg(dev, "FW size: %d, paddr: %#x\n", fw->size, is->memory.paddr);\r\nis->is_shared_region->chip_id = 0xe4412;\r\nis->is_shared_region->chip_rev_no = 1;\r\nfimc_is_mem_barrier();\r\nif (is->fw.f_w)\r\nrelease_firmware(is->fw.f_w);\r\nis->fw.f_w = fw;\r\ndone:\r\nmutex_unlock(&is->lock);\r\n}\r\nstatic int fimc_is_request_firmware(struct fimc_is *is, const char *fw_name)\r\n{\r\nreturn request_firmware_nowait(THIS_MODULE,\r\nFW_ACTION_HOTPLUG, fw_name, &is->pdev->dev,\r\nGFP_KERNEL, is, fimc_is_load_firmware);\r\n}\r\nstatic void fimc_is_general_irq_handler(struct fimc_is *is)\r\n{\r\nis->i2h_cmd.cmd = mcuctl_read(is, MCUCTL_REG_ISSR(10));\r\nswitch (is->i2h_cmd.cmd) {\r\ncase IHC_GET_SENSOR_NUM:\r\nfimc_is_hw_get_params(is, 1);\r\nfimc_is_hw_wait_intmsr0_intmsd0(is);\r\nfimc_is_hw_set_sensor_num(is);\r\npr_debug("ISP FW version: %#x\n", is->i2h_cmd.args[0]);\r\nbreak;\r\ncase IHC_SET_FACE_MARK:\r\ncase IHC_FRAME_DONE:\r\nfimc_is_hw_get_params(is, 2);\r\nbreak;\r\ncase IHC_SET_SHOT_MARK:\r\ncase IHC_AA_DONE:\r\ncase IH_REPLY_DONE:\r\nfimc_is_hw_get_params(is, 3);\r\nbreak;\r\ncase IH_REPLY_NOT_DONE:\r\nfimc_is_hw_get_params(is, 4);\r\nbreak;\r\ncase IHC_NOT_READY:\r\nbreak;\r\ndefault:\r\npr_info("unknown command: %#x\n", is->i2h_cmd.cmd);\r\n}\r\nfimc_is_fw_clear_irq1(is, FIMC_IS_INT_GENERAL);\r\nswitch (is->i2h_cmd.cmd) {\r\ncase IHC_GET_SENSOR_NUM:\r\nfimc_is_hw_set_intgr0_gd0(is);\r\nset_bit(IS_ST_A5_PWR_ON, &is->state);\r\nbreak;\r\ncase IHC_SET_SHOT_MARK:\r\nbreak;\r\ncase IHC_SET_FACE_MARK:\r\nis->fd_header.count = is->i2h_cmd.args[0];\r\nis->fd_header.index = is->i2h_cmd.args[1];\r\nis->fd_header.offset = 0;\r\nbreak;\r\ncase IHC_FRAME_DONE:\r\nbreak;\r\ncase IHC_AA_DONE:\r\npr_debug("AA_DONE - %d, %d, %d\n", is->i2h_cmd.args[0],\r\nis->i2h_cmd.args[1], is->i2h_cmd.args[2]);\r\nbreak;\r\ncase IH_REPLY_DONE:\r\npr_debug("ISR_DONE: args[0]: %#x\n", is->i2h_cmd.args[0]);\r\nswitch (is->i2h_cmd.args[0]) {\r\ncase HIC_PREVIEW_STILL...HIC_CAPTURE_VIDEO:\r\nset_bit(IS_ST_CHANGE_MODE, &is->state);\r\nis->isp.cac_margin_x = is->i2h_cmd.args[1];\r\nis->isp.cac_margin_y = is->i2h_cmd.args[2];\r\npr_debug("CAC margin (x,y): (%d,%d)\n",\r\nis->isp.cac_margin_x, is->isp.cac_margin_y);\r\nbreak;\r\ncase HIC_STREAM_ON:\r\nclear_bit(IS_ST_STREAM_OFF, &is->state);\r\nset_bit(IS_ST_STREAM_ON, &is->state);\r\nbreak;\r\ncase HIC_STREAM_OFF:\r\nclear_bit(IS_ST_STREAM_ON, &is->state);\r\nset_bit(IS_ST_STREAM_OFF, &is->state);\r\nbreak;\r\ncase HIC_SET_PARAMETER:\r\nis->config[is->config_index].p_region_index[0] = 0;\r\nis->config[is->config_index].p_region_index[1] = 0;\r\nset_bit(IS_ST_BLOCK_CMD_CLEARED, &is->state);\r\npr_debug("HIC_SET_PARAMETER\n");\r\nbreak;\r\ncase HIC_GET_PARAMETER:\r\nbreak;\r\ncase HIC_SET_TUNE:\r\nbreak;\r\ncase HIC_GET_STATUS:\r\nbreak;\r\ncase HIC_OPEN_SENSOR:\r\nset_bit(IS_ST_OPEN_SENSOR, &is->state);\r\npr_debug("data lanes: %d, settle line: %d\n",\r\nis->i2h_cmd.args[2], is->i2h_cmd.args[1]);\r\nbreak;\r\ncase HIC_CLOSE_SENSOR:\r\nclear_bit(IS_ST_OPEN_SENSOR, &is->state);\r\nis->sensor_index = 0;\r\nbreak;\r\ncase HIC_MSG_TEST:\r\npr_debug("config MSG level completed\n");\r\nbreak;\r\ncase HIC_POWER_DOWN:\r\nclear_bit(IS_ST_PWR_SUBIP_ON, &is->state);\r\nbreak;\r\ncase HIC_GET_SET_FILE_ADDR:\r\nis->setfile.base = is->i2h_cmd.args[1];\r\nset_bit(IS_ST_SETFILE_LOADED, &is->state);\r\nbreak;\r\ncase HIC_LOAD_SET_FILE:\r\nset_bit(IS_ST_SETFILE_LOADED, &is->state);\r\nbreak;\r\n}\r\nbreak;\r\ncase IH_REPLY_NOT_DONE:\r\npr_err("ISR_NDONE: %d: %#x, %s\n", is->i2h_cmd.args[0],\r\nis->i2h_cmd.args[1],\r\nfimc_is_strerr(is->i2h_cmd.args[1]));\r\nif (is->i2h_cmd.args[1] & IS_ERROR_TIME_OUT_FLAG)\r\npr_err("IS_ERROR_TIME_OUT\n");\r\nswitch (is->i2h_cmd.args[1]) {\r\ncase IS_ERROR_SET_PARAMETER:\r\nfimc_is_mem_barrier();\r\n}\r\nswitch (is->i2h_cmd.args[0]) {\r\ncase HIC_SET_PARAMETER:\r\nis->config[is->config_index].p_region_index[0] = 0;\r\nis->config[is->config_index].p_region_index[1] = 0;\r\nset_bit(IS_ST_BLOCK_CMD_CLEARED, &is->state);\r\nbreak;\r\n}\r\nbreak;\r\ncase IHC_NOT_READY:\r\npr_err("IS control sequence error: Not Ready\n");\r\nbreak;\r\n}\r\nwake_up(&is->irq_queue);\r\n}\r\nstatic irqreturn_t fimc_is_irq_handler(int irq, void *priv)\r\n{\r\nstruct fimc_is *is = priv;\r\nunsigned long flags;\r\nu32 status;\r\nspin_lock_irqsave(&is->slock, flags);\r\nstatus = mcuctl_read(is, MCUCTL_REG_INTSR1);\r\nif (status & (1UL << FIMC_IS_INT_GENERAL))\r\nfimc_is_general_irq_handler(is);\r\nif (status & (1UL << FIMC_IS_INT_FRAME_DONE_ISP))\r\nfimc_isp_irq_handler(is);\r\nspin_unlock_irqrestore(&is->slock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int fimc_is_hw_open_sensor(struct fimc_is *is,\r\nstruct fimc_is_sensor *sensor)\r\n{\r\nstruct sensor_open_extended *soe = (void *)&is->is_p_region->shared;\r\nfimc_is_hw_wait_intmsr0_intmsd0(is);\r\nsoe->self_calibration_mode = 1;\r\nsoe->actuator_type = 0;\r\nsoe->mipi_lane_num = 0;\r\nsoe->mclk = 0;\r\nsoe->mipi_speed = 0;\r\nsoe->fast_open_sensor = 0;\r\nsoe->i2c_sclk = 88000000;\r\nfimc_is_mem_barrier();\r\nmcuctl_write(HIC_OPEN_SENSOR, is, MCUCTL_REG_ISSR(0));\r\nmcuctl_write(is->sensor_index, is, MCUCTL_REG_ISSR(1));\r\nmcuctl_write(sensor->drvdata->id, is, MCUCTL_REG_ISSR(2));\r\nmcuctl_write(sensor->i2c_bus, is, MCUCTL_REG_ISSR(3));\r\nmcuctl_write(is->is_dma_p_region, is, MCUCTL_REG_ISSR(4));\r\nfimc_is_hw_set_intgr0_gd0(is);\r\nreturn fimc_is_wait_event(is, IS_ST_OPEN_SENSOR, 1,\r\nsensor->drvdata->open_timeout);\r\n}\r\nint fimc_is_hw_initialize(struct fimc_is *is)\r\n{\r\nconst int config_ids[] = {\r\nIS_SC_PREVIEW_STILL, IS_SC_PREVIEW_VIDEO,\r\nIS_SC_CAPTURE_STILL, IS_SC_CAPTURE_VIDEO\r\n};\r\nstruct device *dev = &is->pdev->dev;\r\nu32 prev_id;\r\nint i, ret;\r\nret = fimc_is_hw_open_sensor(is, &is->sensor[0]);\r\nif (ret < 0)\r\nreturn ret;\r\nfimc_is_hw_get_setfile_addr(is);\r\nret = fimc_is_wait_event(is, IS_ST_SETFILE_LOADED, 1,\r\nFIMC_IS_CONFIG_TIMEOUT);\r\nif (ret < 0) {\r\ndev_err(dev, "get setfile address timed out\n");\r\nreturn ret;\r\n}\r\npr_debug("setfile.base: %#x\n", is->setfile.base);\r\nfimc_is_load_setfile(is, FIMC_IS_SETFILE_6A3);\r\nclear_bit(IS_ST_SETFILE_LOADED, &is->state);\r\nfimc_is_hw_load_setfile(is);\r\nret = fimc_is_wait_event(is, IS_ST_SETFILE_LOADED, 1,\r\nFIMC_IS_CONFIG_TIMEOUT);\r\nif (ret < 0) {\r\ndev_err(dev, "loading setfile timed out\n");\r\nreturn ret;\r\n}\r\npr_debug("setfile: base: %#x, size: %d\n",\r\nis->setfile.base, is->setfile.size);\r\npr_info("FIMC-IS Setfile info: %s\n", is->fw.setfile_info);\r\nif (is->is_p_region->shared[MAX_SHARED_COUNT - 1] !=\r\nFIMC_IS_MAGIC_NUMBER) {\r\ndev_err(dev, "magic number error!\n");\r\nreturn -EIO;\r\n}\r\npr_debug("shared region: %#x, parameter region: %#x\n",\r\nis->memory.paddr + FIMC_IS_SHARED_REGION_OFFSET,\r\nis->is_dma_p_region);\r\nis->setfile.sub_index = 0;\r\nfimc_is_hw_stream_off(is);\r\nret = fimc_is_wait_event(is, IS_ST_STREAM_OFF, 1,\r\nFIMC_IS_CONFIG_TIMEOUT);\r\nif (ret < 0) {\r\ndev_err(dev, "stream off timeout\n");\r\nreturn ret;\r\n}\r\nprev_id = is->config_index;\r\nfor (i = 0; i < ARRAY_SIZE(config_ids); i++) {\r\nis->config_index = config_ids[i];\r\nfimc_is_set_initial_params(is);\r\nret = fimc_is_itf_s_param(is, true);\r\nif (ret < 0) {\r\nis->config_index = prev_id;\r\nreturn ret;\r\n}\r\n}\r\nis->config_index = prev_id;\r\nset_bit(IS_ST_INIT_DONE, &is->state);\r\ndev_info(dev, "initialization sequence completed (%d)\n",\r\nis->config_index);\r\nreturn 0;\r\n}\r\nstatic int fimc_is_log_show(struct seq_file *s, void *data)\r\n{\r\nstruct fimc_is *is = s->private;\r\nconst u8 *buf = is->memory.vaddr + FIMC_IS_DEBUG_REGION_OFFSET;\r\nif (is->memory.vaddr == NULL) {\r\ndev_err(&is->pdev->dev, "firmware memory is not initialized\n");\r\nreturn -EIO;\r\n}\r\nseq_printf(s, "%s\n", buf);\r\nreturn 0;\r\n}\r\nstatic int fimc_is_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, fimc_is_log_show, inode->i_private);\r\n}\r\nstatic void fimc_is_debugfs_remove(struct fimc_is *is)\r\n{\r\ndebugfs_remove_recursive(is->debugfs_entry);\r\nis->debugfs_entry = NULL;\r\n}\r\nstatic int fimc_is_debugfs_create(struct fimc_is *is)\r\n{\r\nstruct dentry *dentry;\r\nis->debugfs_entry = debugfs_create_dir("fimc_is", NULL);\r\ndentry = debugfs_create_file("fw_log", S_IRUGO, is->debugfs_entry,\r\nis, &fimc_is_debugfs_fops);\r\nif (!dentry)\r\nfimc_is_debugfs_remove(is);\r\nreturn is->debugfs_entry == NULL ? -EIO : 0;\r\n}\r\nstatic int fimc_is_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct fimc_is *is;\r\nstruct resource res;\r\nstruct device_node *node;\r\nint ret;\r\nis = devm_kzalloc(&pdev->dev, sizeof(*is), GFP_KERNEL);\r\nif (!is)\r\nreturn -ENOMEM;\r\nis->pdev = pdev;\r\nis->isp.pdev = pdev;\r\ninit_waitqueue_head(&is->irq_queue);\r\nspin_lock_init(&is->slock);\r\nmutex_init(&is->lock);\r\nret = of_address_to_resource(dev->of_node, 0, &res);\r\nif (ret < 0)\r\nreturn ret;\r\nis->regs = devm_ioremap_resource(dev, &res);\r\nif (IS_ERR(is->regs))\r\nreturn PTR_ERR(is->regs);\r\nnode = of_get_child_by_name(dev->of_node, "pmu");\r\nif (!node)\r\nreturn -ENODEV;\r\nis->pmu_regs = of_iomap(node, 0);\r\nif (!is->pmu_regs)\r\nreturn -ENOMEM;\r\nis->irq = irq_of_parse_and_map(dev->of_node, 0);\r\nif (is->irq < 0) {\r\ndev_err(dev, "no irq found\n");\r\nreturn is->irq;\r\n}\r\nret = fimc_is_get_clocks(is);\r\nif (ret < 0)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, is);\r\nret = request_irq(is->irq, fimc_is_irq_handler, 0, dev_name(dev), is);\r\nif (ret < 0) {\r\ndev_err(dev, "irq request failed\n");\r\ngoto err_clk;\r\n}\r\npm_runtime_enable(dev);\r\nif (!pm_runtime_enabled(dev)) {\r\nret = fimc_is_runtime_resume(dev);\r\nif (ret < 0)\r\ngoto err_irq;\r\n}\r\nret = pm_runtime_get_sync(dev);\r\nif (ret < 0)\r\ngoto err_pm;\r\nis->alloc_ctx = vb2_dma_contig_init_ctx(dev);\r\nif (IS_ERR(is->alloc_ctx)) {\r\nret = PTR_ERR(is->alloc_ctx);\r\ngoto err_pm;\r\n}\r\nret = fimc_is_register_subdevs(is);\r\nif (ret < 0)\r\ngoto err_vb;\r\nret = fimc_is_debugfs_create(is);\r\nif (ret < 0)\r\ngoto err_sd;\r\nret = fimc_is_request_firmware(is, FIMC_IS_FW_FILENAME);\r\nif (ret < 0)\r\ngoto err_dfs;\r\npm_runtime_put_sync(dev);\r\ndev_dbg(dev, "FIMC-IS registered successfully\n");\r\nreturn 0;\r\nerr_dfs:\r\nfimc_is_debugfs_remove(is);\r\nerr_sd:\r\nfimc_is_unregister_subdevs(is);\r\nerr_vb:\r\nvb2_dma_contig_cleanup_ctx(is->alloc_ctx);\r\nerr_pm:\r\nif (!pm_runtime_enabled(dev))\r\nfimc_is_runtime_suspend(dev);\r\nerr_irq:\r\nfree_irq(is->irq, is);\r\nerr_clk:\r\nfimc_is_put_clocks(is);\r\nreturn ret;\r\n}\r\nstatic int fimc_is_runtime_resume(struct device *dev)\r\n{\r\nstruct fimc_is *is = dev_get_drvdata(dev);\r\nint ret;\r\nret = fimc_is_setup_clocks(is);\r\nif (ret)\r\nreturn ret;\r\nreturn fimc_is_enable_clocks(is);\r\n}\r\nstatic int fimc_is_runtime_suspend(struct device *dev)\r\n{\r\nstruct fimc_is *is = dev_get_drvdata(dev);\r\nfimc_is_disable_clocks(is);\r\nreturn 0;\r\n}\r\nstatic int fimc_is_resume(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int fimc_is_suspend(struct device *dev)\r\n{\r\nstruct fimc_is *is = dev_get_drvdata(dev);\r\nif (test_bit(IS_ST_A5_PWR_ON, &is->state))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int fimc_is_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct fimc_is *is = dev_get_drvdata(dev);\r\npm_runtime_disable(dev);\r\npm_runtime_set_suspended(dev);\r\nif (!pm_runtime_status_suspended(dev))\r\nfimc_is_runtime_suspend(dev);\r\nfree_irq(is->irq, is);\r\nfimc_is_unregister_subdevs(is);\r\nvb2_dma_contig_cleanup_ctx(is->alloc_ctx);\r\nfimc_is_put_clocks(is);\r\nfimc_is_debugfs_remove(is);\r\nif (is->fw.f_w)\r\nrelease_firmware(is->fw.f_w);\r\nfimc_is_free_cpu_memory(is);\r\nreturn 0;\r\n}\r\nstatic int fimc_is_module_init(void)\r\n{\r\nint ret;\r\nret = fimc_is_register_i2c_driver();\r\nif (ret < 0)\r\nreturn ret;\r\nret = platform_driver_register(&fimc_is_driver);\r\nif (ret < 0)\r\nfimc_is_unregister_i2c_driver();\r\nreturn ret;\r\n}\r\nstatic void fimc_is_module_exit(void)\r\n{\r\nfimc_is_unregister_i2c_driver();\r\nplatform_driver_unregister(&fimc_is_driver);\r\n}
