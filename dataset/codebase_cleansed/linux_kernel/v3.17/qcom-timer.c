static irqreturn_t msm_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nif (evt->mode == CLOCK_EVT_MODE_ONESHOT) {\r\nu32 ctrl = readl_relaxed(event_base + TIMER_ENABLE);\r\nctrl &= ~TIMER_ENABLE_EN;\r\nwritel_relaxed(ctrl, event_base + TIMER_ENABLE);\r\n}\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int msm_timer_set_next_event(unsigned long cycles,\r\nstruct clock_event_device *evt)\r\n{\r\nu32 ctrl = readl_relaxed(event_base + TIMER_ENABLE);\r\nctrl &= ~TIMER_ENABLE_EN;\r\nwritel_relaxed(ctrl, event_base + TIMER_ENABLE);\r\nwritel_relaxed(ctrl, event_base + TIMER_CLEAR);\r\nwritel_relaxed(cycles, event_base + TIMER_MATCH_VAL);\r\nif (sts_base)\r\nwhile (readl_relaxed(sts_base) & TIMER_STS_GPT0_CLR_PEND)\r\ncpu_relax();\r\nwritel_relaxed(ctrl | TIMER_ENABLE_EN, event_base + TIMER_ENABLE);\r\nreturn 0;\r\n}\r\nstatic void msm_timer_set_mode(enum clock_event_mode mode,\r\nstruct clock_event_device *evt)\r\n{\r\nu32 ctrl;\r\nctrl = readl_relaxed(event_base + TIMER_ENABLE);\r\nctrl &= ~(TIMER_ENABLE_EN | TIMER_ENABLE_CLR_ON_MATCH_EN);\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_RESUME:\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\nbreak;\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\nbreak;\r\ncase CLOCK_EVT_MODE_UNUSED:\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\nbreak;\r\n}\r\nwritel_relaxed(ctrl, event_base + TIMER_ENABLE);\r\n}\r\nstatic notrace cycle_t msm_read_timer_count(struct clocksource *cs)\r\n{\r\nreturn readl_relaxed(source_base + TIMER_COUNT_VAL);\r\n}\r\nstatic int msm_local_timer_setup(struct clock_event_device *evt)\r\n{\r\nint cpu = smp_processor_id();\r\nint err;\r\nevt->irq = msm_timer_irq;\r\nevt->name = "msm_timer";\r\nevt->features = CLOCK_EVT_FEAT_ONESHOT;\r\nevt->rating = 200;\r\nevt->set_mode = msm_timer_set_mode;\r\nevt->set_next_event = msm_timer_set_next_event;\r\nevt->cpumask = cpumask_of(cpu);\r\nclockevents_config_and_register(evt, GPT_HZ, 4, 0xffffffff);\r\nif (msm_timer_has_ppi) {\r\nenable_percpu_irq(evt->irq, IRQ_TYPE_EDGE_RISING);\r\n} else {\r\nerr = request_irq(evt->irq, msm_timer_interrupt,\r\nIRQF_TIMER | IRQF_NOBALANCING |\r\nIRQF_TRIGGER_RISING, "gp_timer", evt);\r\nif (err)\r\npr_err("request_irq failed\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void msm_local_timer_stop(struct clock_event_device *evt)\r\n{\r\nevt->set_mode(CLOCK_EVT_MODE_UNUSED, evt);\r\ndisable_percpu_irq(evt->irq);\r\n}\r\nstatic int msm_timer_cpu_notify(struct notifier_block *self,\r\nunsigned long action, void *hcpu)\r\n{\r\nswitch (action & ~CPU_TASKS_FROZEN) {\r\ncase CPU_STARTING:\r\nmsm_local_timer_setup(this_cpu_ptr(msm_evt));\r\nbreak;\r\ncase CPU_DYING:\r\nmsm_local_timer_stop(this_cpu_ptr(msm_evt));\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic u64 notrace msm_sched_clock_read(void)\r\n{\r\nreturn msm_clocksource.read(&msm_clocksource);\r\n}\r\nstatic unsigned long msm_read_current_timer(void)\r\n{\r\nreturn msm_clocksource.read(&msm_clocksource);\r\n}\r\nstatic void __init msm_timer_init(u32 dgt_hz, int sched_bits, int irq,\r\nbool percpu)\r\n{\r\nstruct clocksource *cs = &msm_clocksource;\r\nint res = 0;\r\nmsm_timer_irq = irq;\r\nmsm_timer_has_ppi = percpu;\r\nmsm_evt = alloc_percpu(struct clock_event_device);\r\nif (!msm_evt) {\r\npr_err("memory allocation failed for clockevents\n");\r\ngoto err;\r\n}\r\nif (percpu)\r\nres = request_percpu_irq(irq, msm_timer_interrupt,\r\n"gp_timer", msm_evt);\r\nif (res) {\r\npr_err("request_percpu_irq failed\n");\r\n} else {\r\nres = register_cpu_notifier(&msm_timer_cpu_nb);\r\nif (res) {\r\nfree_percpu_irq(irq, msm_evt);\r\ngoto err;\r\n}\r\nmsm_local_timer_setup(__this_cpu_ptr(msm_evt));\r\n}\r\nerr:\r\nwritel_relaxed(TIMER_ENABLE_EN, source_base + TIMER_ENABLE);\r\nres = clocksource_register_hz(cs, dgt_hz);\r\nif (res)\r\npr_err("clocksource_register failed\n");\r\nsched_clock_register(msm_sched_clock_read, sched_bits, dgt_hz);\r\nmsm_delay_timer.freq = dgt_hz;\r\nregister_current_timer_delay(&msm_delay_timer);\r\n}\r\nstatic void __init msm_dt_timer_init(struct device_node *np)\r\n{\r\nu32 freq;\r\nint irq;\r\nstruct resource res;\r\nu32 percpu_offset;\r\nvoid __iomem *base;\r\nvoid __iomem *cpu0_base;\r\nbase = of_iomap(np, 0);\r\nif (!base) {\r\npr_err("Failed to map event base\n");\r\nreturn;\r\n}\r\nirq = irq_of_parse_and_map(np, 1);\r\nif (irq <= 0) {\r\npr_err("Can't get irq\n");\r\nreturn;\r\n}\r\nif (of_property_read_u32(np, "cpu-offset", &percpu_offset))\r\npercpu_offset = 0;\r\nif (of_address_to_resource(np, 0, &res)) {\r\npr_err("Failed to parse DGT resource\n");\r\nreturn;\r\n}\r\ncpu0_base = ioremap(res.start + percpu_offset, resource_size(&res));\r\nif (!cpu0_base) {\r\npr_err("Failed to map source base\n");\r\nreturn;\r\n}\r\nif (of_property_read_u32(np, "clock-frequency", &freq)) {\r\npr_err("Unknown frequency\n");\r\nreturn;\r\n}\r\nevent_base = base + 0x4;\r\nsts_base = base + 0x88;\r\nsource_base = cpu0_base + 0x24;\r\nfreq /= 4;\r\nwritel_relaxed(DGT_CLK_CTL_DIV_4, source_base + DGT_CLK_CTL);\r\nmsm_timer_init(freq, 32, irq, !!percpu_offset);\r\n}\r\nstatic int __init msm_timer_map(phys_addr_t addr, u32 event, u32 source,\r\nu32 sts)\r\n{\r\nvoid __iomem *base;\r\nbase = ioremap(addr, SZ_256);\r\nif (!base) {\r\npr_err("Failed to map timer base\n");\r\nreturn -ENOMEM;\r\n}\r\nevent_base = base + event;\r\nsource_base = base + source;\r\nif (sts)\r\nsts_base = base + sts;\r\nreturn 0;\r\n}\r\nstatic notrace cycle_t msm_read_timer_count_shift(struct clocksource *cs)\r\n{\r\nreturn msm_read_timer_count(cs) >> MSM_DGT_SHIFT;\r\n}\r\nvoid __init msm7x01_timer_init(void)\r\n{\r\nstruct clocksource *cs = &msm_clocksource;\r\nif (msm_timer_map(0xc0100000, 0x0, 0x10, 0x0))\r\nreturn;\r\ncs->read = msm_read_timer_count_shift;\r\ncs->mask = CLOCKSOURCE_MASK((32 - MSM_DGT_SHIFT));\r\nmsm_timer_init(19200000 >> MSM_DGT_SHIFT, 32 - MSM_DGT_SHIFT, 7,\r\nfalse);\r\n}\r\nvoid __init msm7x30_timer_init(void)\r\n{\r\nif (msm_timer_map(0xc0100000, 0x4, 0x24, 0x80))\r\nreturn;\r\nmsm_timer_init(24576000 / 4, 32, 1, false);\r\n}\r\nvoid __init qsd8x50_timer_init(void)\r\n{\r\nif (msm_timer_map(0xAC100000, 0x0, 0x10, 0x34))\r\nreturn;\r\nmsm_timer_init(19200000 / 4, 32, 7, false);\r\n}
