static int oaktrail_rfkill_set(void *data, bool blocked)\r\n{\r\nu8 value;\r\nu8 result;\r\nunsigned long radio = (unsigned long) data;\r\nec_read(OT_EC_DEVICE_STATE_ADDRESS, &result);\r\nif (!blocked)\r\nvalue = (u8) (result | radio);\r\nelse\r\nvalue = (u8) (result & ~radio);\r\nec_write(OT_EC_DEVICE_STATE_ADDRESS, value);\r\nreturn 0;\r\n}\r\nstatic struct rfkill *oaktrail_rfkill_new(char *name, enum rfkill_type type,\r\nunsigned long mask)\r\n{\r\nstruct rfkill *rfkill_dev;\r\nu8 value;\r\nint err;\r\nrfkill_dev = rfkill_alloc(name, &oaktrail_device->dev, type,\r\n&oaktrail_rfkill_ops, (void *)mask);\r\nif (!rfkill_dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nec_read(OT_EC_DEVICE_STATE_ADDRESS, &value);\r\nrfkill_init_sw_state(rfkill_dev, (value & mask) != 1);\r\nerr = rfkill_register(rfkill_dev);\r\nif (err) {\r\nrfkill_destroy(rfkill_dev);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn rfkill_dev;\r\n}\r\nstatic inline void __oaktrail_rfkill_cleanup(struct rfkill *rf)\r\n{\r\nif (rf) {\r\nrfkill_unregister(rf);\r\nrfkill_destroy(rf);\r\n}\r\n}\r\nstatic void oaktrail_rfkill_cleanup(void)\r\n{\r\n__oaktrail_rfkill_cleanup(wifi_rfkill);\r\n__oaktrail_rfkill_cleanup(bt_rfkill);\r\n__oaktrail_rfkill_cleanup(gps_rfkill);\r\n__oaktrail_rfkill_cleanup(wwan_rfkill);\r\n}\r\nstatic int oaktrail_rfkill_init(void)\r\n{\r\nint ret;\r\nwifi_rfkill = oaktrail_rfkill_new("oaktrail-wifi",\r\nRFKILL_TYPE_WLAN,\r\nOT_EC_WIFI_MASK);\r\nif (IS_ERR(wifi_rfkill)) {\r\nret = PTR_ERR(wifi_rfkill);\r\nwifi_rfkill = NULL;\r\ngoto cleanup;\r\n}\r\nbt_rfkill = oaktrail_rfkill_new("oaktrail-bluetooth",\r\nRFKILL_TYPE_BLUETOOTH,\r\nOT_EC_BT_MASK);\r\nif (IS_ERR(bt_rfkill)) {\r\nret = PTR_ERR(bt_rfkill);\r\nbt_rfkill = NULL;\r\ngoto cleanup;\r\n}\r\ngps_rfkill = oaktrail_rfkill_new("oaktrail-gps",\r\nRFKILL_TYPE_GPS,\r\nOT_EC_GPS_MASK);\r\nif (IS_ERR(gps_rfkill)) {\r\nret = PTR_ERR(gps_rfkill);\r\ngps_rfkill = NULL;\r\ngoto cleanup;\r\n}\r\nwwan_rfkill = oaktrail_rfkill_new("oaktrail-wwan",\r\nRFKILL_TYPE_WWAN,\r\nOT_EC_WWAN_MASK);\r\nif (IS_ERR(wwan_rfkill)) {\r\nret = PTR_ERR(wwan_rfkill);\r\nwwan_rfkill = NULL;\r\ngoto cleanup;\r\n}\r\nreturn 0;\r\ncleanup:\r\noaktrail_rfkill_cleanup();\r\nreturn ret;\r\n}\r\nstatic int get_backlight_brightness(struct backlight_device *b)\r\n{\r\nu8 value;\r\nec_read(OT_EC_BL_BRIGHTNESS_ADDRESS, &value);\r\nreturn value;\r\n}\r\nstatic int set_backlight_brightness(struct backlight_device *b)\r\n{\r\nu8 percent = (u8) b->props.brightness;\r\nif (percent < 0 || percent > OT_EC_BL_BRIGHTNESS_MAX)\r\nreturn -EINVAL;\r\nec_write(OT_EC_BL_BRIGHTNESS_ADDRESS, percent);\r\nec_write(OT_EC_BL_CONTROL_ADDRESS, OT_EC_BL_CONTROL_ON_DATA);\r\nreturn 0;\r\n}\r\nstatic int oaktrail_backlight_init(void)\r\n{\r\nstruct backlight_device *bd;\r\nstruct backlight_properties props;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = OT_EC_BL_BRIGHTNESS_MAX;\r\nbd = backlight_device_register(DRIVER_NAME,\r\n&oaktrail_device->dev, NULL,\r\n&oaktrail_bl_ops,\r\n&props);\r\nif (IS_ERR(bd)) {\r\noaktrail_bl_device = NULL;\r\npr_warning("Unable to register backlight device\n");\r\nreturn PTR_ERR(bd);\r\n}\r\noaktrail_bl_device = bd;\r\nbd->props.brightness = get_backlight_brightness(bd);\r\nbd->props.power = FB_BLANK_UNBLANK;\r\nbacklight_update_status(bd);\r\nreturn 0;\r\n}\r\nstatic void oaktrail_backlight_exit(void)\r\n{\r\nif (oaktrail_bl_device)\r\nbacklight_device_unregister(oaktrail_bl_device);\r\n}\r\nstatic int oaktrail_probe(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int oaktrail_remove(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int dmi_check_cb(const struct dmi_system_id *id)\r\n{\r\npr_info("Identified model '%s'\n", id->ident);\r\nreturn 0;\r\n}\r\nstatic int __init oaktrail_init(void)\r\n{\r\nint ret;\r\nif (acpi_disabled) {\r\npr_err("ACPI needs to be enabled for this driver to work!\n");\r\nreturn -ENODEV;\r\n}\r\nif (!force && !dmi_check_system(oaktrail_dmi_table)) {\r\npr_err("Platform not recognized (You could try the module's force-parameter)");\r\nreturn -ENODEV;\r\n}\r\nret = platform_driver_register(&oaktrail_driver);\r\nif (ret) {\r\npr_warning("Unable to register platform driver\n");\r\ngoto err_driver_reg;\r\n}\r\noaktrail_device = platform_device_alloc(DRIVER_NAME, -1);\r\nif (!oaktrail_device) {\r\npr_warning("Unable to allocate platform device\n");\r\nret = -ENOMEM;\r\ngoto err_device_alloc;\r\n}\r\nret = platform_device_add(oaktrail_device);\r\nif (ret) {\r\npr_warning("Unable to add platform device\n");\r\ngoto err_device_add;\r\n}\r\nif (!acpi_video_backlight_support()) {\r\nret = oaktrail_backlight_init();\r\nif (ret)\r\ngoto err_backlight;\r\n} else\r\npr_info("Backlight controlled by ACPI video driver\n");\r\nret = oaktrail_rfkill_init();\r\nif (ret) {\r\npr_warning("Setup rfkill failed\n");\r\ngoto err_rfkill;\r\n}\r\npr_info("Driver "DRIVER_VERSION" successfully loaded\n");\r\nreturn 0;\r\nerr_rfkill:\r\noaktrail_backlight_exit();\r\nerr_backlight:\r\nplatform_device_del(oaktrail_device);\r\nerr_device_add:\r\nplatform_device_put(oaktrail_device);\r\nerr_device_alloc:\r\nplatform_driver_unregister(&oaktrail_driver);\r\nerr_driver_reg:\r\nreturn ret;\r\n}\r\nstatic void __exit oaktrail_cleanup(void)\r\n{\r\noaktrail_backlight_exit();\r\noaktrail_rfkill_cleanup();\r\nplatform_device_unregister(oaktrail_device);\r\nplatform_driver_unregister(&oaktrail_driver);\r\npr_info("Driver unloaded\n");\r\n}
