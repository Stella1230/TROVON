const char *gcov_info_filename(struct gcov_info *info)\r\n{\r\nreturn info->filename;\r\n}\r\nunsigned int gcov_info_version(struct gcov_info *info)\r\n{\r\nreturn info->version;\r\n}\r\nstruct gcov_info *gcov_info_next(struct gcov_info *info)\r\n{\r\nif (!info)\r\nreturn gcov_info_head;\r\nreturn info->next;\r\n}\r\nvoid gcov_info_link(struct gcov_info *info)\r\n{\r\ninfo->next = gcov_info_head;\r\ngcov_info_head = info;\r\n}\r\nvoid gcov_info_unlink(struct gcov_info *prev, struct gcov_info *info)\r\n{\r\nif (prev)\r\nprev->next = info->next;\r\nelse\r\ngcov_info_head = info->next;\r\n}\r\nstatic int counter_active(struct gcov_info *info, unsigned int type)\r\n{\r\nreturn (1 << type) & info->ctr_mask;\r\n}\r\nstatic unsigned int num_counter_active(struct gcov_info *info)\r\n{\r\nunsigned int i;\r\nunsigned int result = 0;\r\nfor (i = 0; i < GCOV_COUNTERS; i++) {\r\nif (counter_active(info, i))\r\nresult++;\r\n}\r\nreturn result;\r\n}\r\nvoid gcov_info_reset(struct gcov_info *info)\r\n{\r\nunsigned int active = num_counter_active(info);\r\nunsigned int i;\r\nfor (i = 0; i < active; i++) {\r\nmemset(info->counts[i].values, 0,\r\ninfo->counts[i].num * sizeof(gcov_type));\r\n}\r\n}\r\nint gcov_info_is_compatible(struct gcov_info *info1, struct gcov_info *info2)\r\n{\r\nreturn (info1->stamp == info2->stamp);\r\n}\r\nvoid gcov_info_add(struct gcov_info *dest, struct gcov_info *source)\r\n{\r\nunsigned int i;\r\nunsigned int j;\r\nfor (i = 0; i < num_counter_active(dest); i++) {\r\nfor (j = 0; j < dest->counts[i].num; j++) {\r\ndest->counts[i].values[j] +=\r\nsource->counts[i].values[j];\r\n}\r\n}\r\n}\r\nstatic size_t get_fn_size(struct gcov_info *info)\r\n{\r\nsize_t size;\r\nsize = sizeof(struct gcov_fn_info) + num_counter_active(info) *\r\nsizeof(unsigned int);\r\nif (__alignof__(struct gcov_fn_info) > sizeof(unsigned int))\r\nsize = ALIGN(size, __alignof__(struct gcov_fn_info));\r\nreturn size;\r\n}\r\nstatic struct gcov_fn_info *get_fn_info(struct gcov_info *info, unsigned int fn)\r\n{\r\nreturn (struct gcov_fn_info *)\r\n((char *) info->functions + fn * get_fn_size(info));\r\n}\r\nstruct gcov_info *gcov_info_dup(struct gcov_info *info)\r\n{\r\nstruct gcov_info *dup;\r\nunsigned int i;\r\nunsigned int active;\r\nactive = num_counter_active(info);\r\ndup = kzalloc(sizeof(struct gcov_info) +\r\nsizeof(struct gcov_ctr_info) * active, GFP_KERNEL);\r\nif (!dup)\r\nreturn NULL;\r\ndup->version = info->version;\r\ndup->stamp = info->stamp;\r\ndup->n_functions = info->n_functions;\r\ndup->ctr_mask = info->ctr_mask;\r\ndup->filename = kstrdup(info->filename, GFP_KERNEL);\r\nif (!dup->filename)\r\ngoto err_free;\r\ndup->functions = kmemdup(info->functions, info->n_functions *\r\nget_fn_size(info), GFP_KERNEL);\r\nif (!dup->functions)\r\ngoto err_free;\r\nfor (i = 0; i < active ; i++) {\r\nstruct gcov_ctr_info *ctr = &info->counts[i];\r\nsize_t size = ctr->num * sizeof(gcov_type);\r\ndup->counts[i].num = ctr->num;\r\ndup->counts[i].merge = ctr->merge;\r\ndup->counts[i].values = vmalloc(size);\r\nif (!dup->counts[i].values)\r\ngoto err_free;\r\nmemcpy(dup->counts[i].values, ctr->values, size);\r\n}\r\nreturn dup;\r\nerr_free:\r\ngcov_info_free(dup);\r\nreturn NULL;\r\n}\r\nvoid gcov_info_free(struct gcov_info *info)\r\n{\r\nunsigned int active = num_counter_active(info);\r\nunsigned int i;\r\nfor (i = 0; i < active ; i++)\r\nvfree(info->counts[i].values);\r\nkfree(info->functions);\r\nkfree(info->filename);\r\nkfree(info);\r\n}\r\nstatic struct gcov_fn_info *get_func(struct gcov_iterator *iter)\r\n{\r\nreturn get_fn_info(iter->info, iter->function);\r\n}\r\nstatic struct type_info *get_type(struct gcov_iterator *iter)\r\n{\r\nreturn &iter->type_info[iter->type];\r\n}\r\nstruct gcov_iterator *gcov_iter_new(struct gcov_info *info)\r\n{\r\nstruct gcov_iterator *iter;\r\niter = kzalloc(sizeof(struct gcov_iterator) +\r\nnum_counter_active(info) * sizeof(struct type_info),\r\nGFP_KERNEL);\r\nif (iter)\r\niter->info = info;\r\nreturn iter;\r\n}\r\nvoid gcov_iter_free(struct gcov_iterator *iter)\r\n{\r\nkfree(iter);\r\n}\r\nstruct gcov_info *gcov_iter_get_info(struct gcov_iterator *iter)\r\n{\r\nreturn iter->info;\r\n}\r\nvoid gcov_iter_start(struct gcov_iterator *iter)\r\n{\r\nint i;\r\niter->record = 0;\r\niter->function = 0;\r\niter->type = 0;\r\niter->count = 0;\r\niter->num_types = 0;\r\nfor (i = 0; i < GCOV_COUNTERS; i++) {\r\nif (counter_active(iter->info, i)) {\r\niter->type_info[iter->num_types].ctr_type = i;\r\niter->type_info[iter->num_types++].offset = 0;\r\n}\r\n}\r\n}\r\nint gcov_iter_next(struct gcov_iterator *iter)\r\n{\r\nswitch (iter->record) {\r\ncase RECORD_FILE_MAGIC:\r\ncase RECORD_GCOV_VERSION:\r\ncase RECORD_FUNCTION_TAG:\r\ncase RECORD_FUNCTON_TAG_LEN:\r\ncase RECORD_FUNCTION_IDENT:\r\ncase RECORD_COUNT_TAG:\r\niter->record++;\r\nbreak;\r\ncase RECORD_COUNT:\r\niter->count++;\r\ncase RECORD_COUNT_LEN:\r\nif (iter->count < get_func(iter)->n_ctrs[iter->type]) {\r\niter->record = 9;\r\nbreak;\r\n}\r\nget_type(iter)->offset += iter->count;\r\niter->count = 0;\r\niter->type++;\r\ncase RECORD_FUNCTION_CHECK:\r\nif (iter->type < iter->num_types) {\r\niter->record = 7;\r\nbreak;\r\n}\r\niter->type = 0;\r\niter->function++;\r\ncase RECORD_TIME_STAMP:\r\nif (iter->function < iter->info->n_functions)\r\niter->record = 3;\r\nelse\r\niter->record = -1;\r\nbreak;\r\n}\r\nif (iter->record == -1)\r\nreturn -EINVAL;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int seq_write_gcov_u32(struct seq_file *seq, u32 v)\r\n{\r\nreturn seq_write(seq, &v, sizeof(v));\r\n}\r\nstatic int seq_write_gcov_u64(struct seq_file *seq, u64 v)\r\n{\r\nu32 data[2];\r\ndata[0] = (v & 0xffffffffUL);\r\ndata[1] = (v >> 32);\r\nreturn seq_write(seq, data, sizeof(data));\r\n}\r\nint gcov_iter_write(struct gcov_iterator *iter, struct seq_file *seq)\r\n{\r\nint rc = -EINVAL;\r\nswitch (iter->record) {\r\ncase RECORD_FILE_MAGIC:\r\nrc = seq_write_gcov_u32(seq, GCOV_DATA_MAGIC);\r\nbreak;\r\ncase RECORD_GCOV_VERSION:\r\nrc = seq_write_gcov_u32(seq, iter->info->version);\r\nbreak;\r\ncase RECORD_TIME_STAMP:\r\nrc = seq_write_gcov_u32(seq, iter->info->stamp);\r\nbreak;\r\ncase RECORD_FUNCTION_TAG:\r\nrc = seq_write_gcov_u32(seq, GCOV_TAG_FUNCTION);\r\nbreak;\r\ncase RECORD_FUNCTON_TAG_LEN:\r\nrc = seq_write_gcov_u32(seq, 2);\r\nbreak;\r\ncase RECORD_FUNCTION_IDENT:\r\nrc = seq_write_gcov_u32(seq, get_func(iter)->ident);\r\nbreak;\r\ncase RECORD_FUNCTION_CHECK:\r\nrc = seq_write_gcov_u32(seq, get_func(iter)->checksum);\r\nbreak;\r\ncase RECORD_COUNT_TAG:\r\nrc = seq_write_gcov_u32(seq,\r\nGCOV_TAG_FOR_COUNTER(get_type(iter)->ctr_type));\r\nbreak;\r\ncase RECORD_COUNT_LEN:\r\nrc = seq_write_gcov_u32(seq,\r\nget_func(iter)->n_ctrs[iter->type] * 2);\r\nbreak;\r\ncase RECORD_COUNT:\r\nrc = seq_write_gcov_u64(seq,\r\niter->info->counts[iter->type].\r\nvalues[iter->count + get_type(iter)->offset]);\r\nbreak;\r\n}\r\nreturn rc;\r\n}
