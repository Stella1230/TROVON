static inline void\r\nStartI2C(struct i2c_platform_data *adap)\r\n{\r\npr_debug("StartI2C\n");\r\npic32_bus_writel(I2CCON_SEN, adap->base + PIC32_I2CxCONSET);\r\n}\r\nstatic inline void\r\nStopI2C(struct i2c_platform_data *adap)\r\n{\r\npr_debug("StopI2C\n");\r\npic32_bus_writel(I2CCON_PEN, adap->base + PIC32_I2CxCONSET);\r\n}\r\nstatic inline void\r\nAckI2C(struct i2c_platform_data *adap)\r\n{\r\npr_debug("AckI2C\n");\r\npic32_bus_writel(I2CCON_ACKDT, adap->base + PIC32_I2CxCONCLR);\r\npic32_bus_writel(I2CCON_ACKEN, adap->base + PIC32_I2CxCONSET);\r\n}\r\nstatic inline void\r\nNotAckI2C(struct i2c_platform_data *adap)\r\n{\r\npr_debug("NakI2C\n");\r\npic32_bus_writel(I2CCON_ACKDT, adap->base + PIC32_I2CxCONSET);\r\npic32_bus_writel(I2CCON_ACKEN, adap->base + PIC32_I2CxCONSET);\r\n}\r\nstatic inline int\r\nIdleI2C(struct i2c_platform_data *adap)\r\n{\r\nint i;\r\npr_debug("IdleI2C\n");\r\nfor (i = 0; i < adap->ctl_timeout; i++) {\r\nif (((pic32_bus_readl(adap->base + PIC32_I2CxCON) &\r\n(I2CCON_ACKEN | I2CCON_RCEN | I2CCON_PEN | I2CCON_RSEN |\r\nI2CCON_SEN)) == 0) &&\r\n((pic32_bus_readl(adap->base + PIC32_I2CxSTAT) &\r\n(I2CSTAT_TRSTAT)) == 0))\r\nreturn 0;\r\nudelay(1);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic inline u32\r\nMasterWriteI2C(struct i2c_platform_data *adap, u32 byte)\r\n{\r\npr_debug("MasterWriteI2C\n");\r\npic32_bus_writel(byte, adap->base + PIC32_I2CxTRN);\r\nreturn pic32_bus_readl(adap->base + PIC32_I2CxSTAT) & I2CSTAT_IWCOL;\r\n}\r\nstatic inline u32\r\nMasterReadI2C(struct i2c_platform_data *adap)\r\n{\r\npr_debug("MasterReadI2C\n");\r\npic32_bus_writel(I2CCON_RCEN, adap->base + PIC32_I2CxCONSET);\r\nwhile (pic32_bus_readl(adap->base + PIC32_I2CxCON) & I2CCON_RCEN)\r\n;\r\npic32_bus_writel(I2CSTAT_I2COV, adap->base + PIC32_I2CxSTATCLR);\r\nreturn pic32_bus_readl(adap->base + PIC32_I2CxRCV);\r\n}\r\nstatic int\r\ndo_address(struct i2c_platform_data *adap, unsigned int addr, int rd)\r\n{\r\npr_debug("doaddress\n");\r\nIdleI2C(adap);\r\nStartI2C(adap);\r\nIdleI2C(adap);\r\naddr <<= 1;\r\nif (rd)\r\naddr |= 1;\r\nif (MasterWriteI2C(adap, addr))\r\nreturn -EIO;\r\nIdleI2C(adap);\r\nif (pic32_bus_readl(adap->base + PIC32_I2CxSTAT) & I2CSTAT_ACKSTAT)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int\r\ni2c_read(struct i2c_platform_data *adap, unsigned char *buf,\r\nunsigned int len)\r\n{\r\nint i;\r\nu32 data;\r\npr_debug("i2c_read\n");\r\ni = 0;\r\nwhile (i < len) {\r\ndata = MasterReadI2C(adap);\r\nbuf[i++] = data;\r\nif (i < len)\r\nAckI2C(adap);\r\nelse\r\nNotAckI2C(adap);\r\n}\r\nStopI2C(adap);\r\nIdleI2C(adap);\r\nreturn 0;\r\n}\r\nstatic int\r\ni2c_write(struct i2c_platform_data *adap, unsigned char *buf,\r\nunsigned int len)\r\n{\r\nint i;\r\nu32 data;\r\npr_debug("i2c_write\n");\r\ni = 0;\r\nwhile (i < len) {\r\ndata = buf[i];\r\nif (MasterWriteI2C(adap, data))\r\nreturn -EIO;\r\nIdleI2C(adap);\r\nif (pic32_bus_readl(adap->base + PIC32_I2CxSTAT) &\r\nI2CSTAT_ACKSTAT)\r\nreturn -EIO;\r\ni++;\r\n}\r\nStopI2C(adap);\r\nIdleI2C(adap);\r\nreturn 0;\r\n}\r\nstatic int\r\nplatform_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs, int num)\r\n{\r\nstruct i2c_platform_data *adap = i2c_adap->algo_data;\r\nstruct i2c_msg *p;\r\nint i, err = 0;\r\npr_debug("platform_xfer\n");\r\nfor (i = 0; i < num; i++) {\r\n#define __BUFSIZE 80\r\nint ii;\r\nstatic char buf[__BUFSIZE];\r\nchar *b = buf;\r\np = &msgs[i];\r\nb += sprintf(buf, " [%d bytes]", p->len);\r\nif ((p->flags & I2C_M_RD) == 0) {\r\nfor (ii = 0; ii < p->len; ii++) {\r\nif (b < &buf[__BUFSIZE-4]) {\r\nb += sprintf(b, " %02x", p->buf[ii]);\r\n} else {\r\nstrcat(b, "...");\r\nbreak;\r\n}\r\n}\r\n}\r\npr_debug("xfer%d: DevAddr: %04x Op:%s Data:%s\n", i, p->addr,\r\n(p->flags & I2C_M_RD) ? "Rd" : "Wr", buf);\r\n}\r\nfor (i = 0; !err && i < num; i++) {\r\np = &msgs[i];\r\nerr = do_address(adap, p->addr, p->flags & I2C_M_RD);\r\nif (err || !p->len)\r\ncontinue;\r\nif (p->flags & I2C_M_RD)\r\nerr = i2c_read(adap, p->buf, p->len);\r\nelse\r\nerr = i2c_write(adap, p->buf, p->len);\r\n}\r\nif (err == 0)\r\nerr = num;\r\nreturn err;\r\n}\r\nstatic u32\r\nplatform_func(struct i2c_adapter *adap)\r\n{\r\npr_debug("platform_algo\n");\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic void i2c_platform_setup(struct i2c_platform_data *priv)\r\n{\r\npr_debug("i2c_platform_setup\n");\r\npic32_bus_writel(500, priv->base + PIC32_I2CxBRG);\r\npic32_bus_writel(I2CCON_ON, priv->base + PIC32_I2CxCONCLR);\r\npic32_bus_writel(I2CCON_ON, priv->base + PIC32_I2CxCONSET);\r\npic32_bus_writel((I2CSTAT_BCL | I2CSTAT_IWCOL),\r\n(priv->base + PIC32_I2CxSTATCLR));\r\n}\r\nstatic void i2c_platform_disable(struct i2c_platform_data *priv)\r\n{\r\npr_debug("i2c_platform_disable\n");\r\n}\r\nstatic int i2c_platform_probe(struct platform_device *pdev)\r\n{\r\nstruct i2c_platform_data *priv;\r\nstruct resource *r;\r\nint ret;\r\npr_debug("i2c_platform_probe\n");\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r)\r\nreturn -ENODEV;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(struct i2c_platform_data),\r\nGFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\n#if 0\r\npriv->base = bus_request_region(r->start, resource_size(r),\r\npdev->name);\r\n#else\r\npriv->base = r->start;\r\n#endif\r\nif (!priv->base)\r\nreturn -EBUSY;\r\npriv->xfer_timeout = 200;\r\npriv->ack_timeout = 200;\r\npriv->ctl_timeout = 200;\r\npriv->adap.nr = pdev->id;\r\npriv->adap.algo = &platform_algo;\r\npriv->adap.algo_data = priv;\r\npriv->adap.dev.parent = &pdev->dev;\r\nstrlcpy(priv->adap.name, "PIC32 I2C", sizeof(priv->adap.name));\r\ni2c_platform_setup(priv);\r\nret = i2c_add_numbered_adapter(&priv->adap);\r\nif (ret) {\r\ni2c_platform_disable(priv);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nreturn 0;\r\n}\r\nstatic int i2c_platform_remove(struct platform_device *pdev)\r\n{\r\nstruct i2c_platform_data *priv = platform_get_drvdata(pdev);\r\npr_debug("i2c_platform_remove\n");\r\nplatform_set_drvdata(pdev, NULL);\r\ni2c_del_adapter(&priv->adap);\r\ni2c_platform_disable(priv);\r\nreturn 0;\r\n}\r\nstatic int\r\ni2c_platform_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct i2c_platform_data *priv = platform_get_drvdata(pdev);\r\ndev_dbg(&pdev->dev, "i2c_platform_disable\n");\r\ni2c_platform_disable(priv);\r\nreturn 0;\r\n}\r\nstatic int\r\ni2c_platform_resume(struct platform_device *pdev)\r\n{\r\nstruct i2c_platform_data *priv = platform_get_drvdata(pdev);\r\ndev_dbg(&pdev->dev, "i2c_platform_setup\n");\r\ni2c_platform_setup(priv);\r\nreturn 0;\r\n}\r\nstatic int __init\r\ni2c_platform_init(void)\r\n{\r\npr_debug("i2c_platform_init\n");\r\nreturn platform_driver_register(&i2c_platform_driver);\r\n}\r\nstatic void __exit\r\ni2c_platform_exit(void)\r\n{\r\npr_debug("i2c_platform_exit\n");\r\nplatform_driver_unregister(&i2c_platform_driver);\r\n}
