static int __init omap4430_phy_power_down(void)\r\n{\r\nvoid __iomem *ctrl_base;\r\nif (!cpu_is_omap44xx())\r\nreturn 0;\r\nctrl_base = ioremap(OMAP443X_SCM_BASE, SZ_1K);\r\nif (!ctrl_base) {\r\npr_err("control module ioremap failed\n");\r\nreturn -ENOMEM;\r\n}\r\nwritel_relaxed(PHY_PD, ctrl_base + CONTROL_DEV_CONF);\r\niounmap(ctrl_base);\r\nreturn 0;\r\n}\r\nvoid am35x_musb_reset(void)\r\n{\r\nu32 regval;\r\nregval = omap_ctrl_readl(AM35XX_CONTROL_IP_SW_RESET);\r\nregval |= AM35XX_USBOTGSS_SW_RST;\r\nomap_ctrl_writel(regval, AM35XX_CONTROL_IP_SW_RESET);\r\nregval &= ~AM35XX_USBOTGSS_SW_RST;\r\nomap_ctrl_writel(regval, AM35XX_CONTROL_IP_SW_RESET);\r\nregval = omap_ctrl_readl(AM35XX_CONTROL_IP_SW_RESET);\r\n}\r\nvoid am35x_musb_phy_power(u8 on)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(100);\r\nu32 devconf2;\r\nif (on) {\r\ndevconf2 = omap_ctrl_readl(AM35XX_CONTROL_DEVCONF2);\r\ndevconf2 &= ~(CONF2_RESET | CONF2_PHYPWRDN | CONF2_OTGPWRDN);\r\ndevconf2 |= CONF2_PHY_PLLON;\r\nomap_ctrl_writel(devconf2, AM35XX_CONTROL_DEVCONF2);\r\npr_info(KERN_INFO "Waiting for PHY clock good...\n");\r\nwhile (!(omap_ctrl_readl(AM35XX_CONTROL_DEVCONF2)\r\n& CONF2_PHYCLKGD)) {\r\ncpu_relax();\r\nif (time_after(jiffies, timeout)) {\r\npr_err(KERN_ERR "musb PHY clock good timed out\n");\r\nbreak;\r\n}\r\n}\r\n} else {\r\ndevconf2 = omap_ctrl_readl(AM35XX_CONTROL_DEVCONF2);\r\ndevconf2 &= ~CONF2_PHY_PLLON;\r\ndevconf2 |= CONF2_PHYPWRDN | CONF2_OTGPWRDN;\r\nomap_ctrl_writel(devconf2, AM35XX_CONTROL_DEVCONF2);\r\n}\r\n}\r\nvoid am35x_musb_clear_irq(void)\r\n{\r\nu32 regval;\r\nregval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);\r\nregval |= AM35XX_USBOTGSS_INT_CLR;\r\nomap_ctrl_writel(regval, AM35XX_CONTROL_LVL_INTR_CLEAR);\r\nregval = omap_ctrl_readl(AM35XX_CONTROL_LVL_INTR_CLEAR);\r\n}\r\nvoid am35x_set_mode(u8 musb_mode)\r\n{\r\nu32 devconf2 = omap_ctrl_readl(AM35XX_CONTROL_DEVCONF2);\r\ndevconf2 &= ~CONF2_OTGMODE;\r\nswitch (musb_mode) {\r\ncase MUSB_HOST:\r\ndevconf2 |= CONF2_FORCE_HOST;\r\nbreak;\r\ncase MUSB_PERIPHERAL:\r\ndevconf2 |= CONF2_FORCE_DEVICE;\r\nbreak;\r\ncase MUSB_OTG:\r\ndevconf2 |= CONF2_NO_OVERRIDE;\r\nbreak;\r\ndefault:\r\npr_info(KERN_INFO "Unsupported mode %u\n", musb_mode);\r\n}\r\nomap_ctrl_writel(devconf2, AM35XX_CONTROL_DEVCONF2);\r\n}\r\nvoid ti81xx_musb_phy_power(u8 on)\r\n{\r\nvoid __iomem *scm_base = NULL;\r\nu32 usbphycfg;\r\nscm_base = ioremap(TI81XX_SCM_BASE, SZ_2K);\r\nif (!scm_base) {\r\npr_err("system control module ioremap failed\n");\r\nreturn;\r\n}\r\nusbphycfg = readl_relaxed(scm_base + USBCTRL0);\r\nif (on) {\r\nif (cpu_is_ti816x()) {\r\nusbphycfg |= TI816X_USBPHY0_NORMAL_MODE;\r\nusbphycfg &= ~TI816X_USBPHY_REFCLK_OSC;\r\n} else if (cpu_is_ti814x()) {\r\nusbphycfg &= ~(USBPHY_CM_PWRDN | USBPHY_OTG_PWRDN\r\n| USBPHY_DPINPUT | USBPHY_DMINPUT);\r\nusbphycfg |= (USBPHY_OTGVDET_EN | USBPHY_OTGSESSEND_EN\r\n| USBPHY_DPOPBUFCTL | USBPHY_DMOPBUFCTL);\r\n}\r\n} else {\r\nif (cpu_is_ti816x())\r\nusbphycfg &= ~TI816X_USBPHY0_NORMAL_MODE;\r\nelse if (cpu_is_ti814x())\r\nusbphycfg |= USBPHY_CM_PWRDN | USBPHY_OTG_PWRDN;\r\n}\r\nwritel_relaxed(usbphycfg, scm_base + USBCTRL0);\r\niounmap(scm_base);\r\n}
