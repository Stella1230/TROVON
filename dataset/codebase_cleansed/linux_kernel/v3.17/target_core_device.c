sense_reason_t\r\ntransport_lookup_cmd_lun(struct se_cmd *se_cmd, u32 unpacked_lun)\r\n{\r\nstruct se_lun *se_lun = NULL;\r\nstruct se_session *se_sess = se_cmd->se_sess;\r\nstruct se_device *dev;\r\nunsigned long flags;\r\nif (unpacked_lun >= TRANSPORT_MAX_LUNS_PER_TPG)\r\nreturn TCM_NON_EXISTENT_LUN;\r\nspin_lock_irqsave(&se_sess->se_node_acl->device_list_lock, flags);\r\nse_cmd->se_deve = se_sess->se_node_acl->device_list[unpacked_lun];\r\nif (se_cmd->se_deve->lun_flags & TRANSPORT_LUNFLAGS_INITIATOR_ACCESS) {\r\nstruct se_dev_entry *deve = se_cmd->se_deve;\r\ndeve->total_cmds++;\r\nif ((se_cmd->data_direction == DMA_TO_DEVICE) &&\r\n(deve->lun_flags & TRANSPORT_LUNFLAGS_READ_ONLY)) {\r\npr_err("TARGET_CORE[%s]: Detected WRITE_PROTECTED LUN"\r\n" Access for 0x%08x\n",\r\nse_cmd->se_tfo->get_fabric_name(),\r\nunpacked_lun);\r\nspin_unlock_irqrestore(&se_sess->se_node_acl->device_list_lock, flags);\r\nreturn TCM_WRITE_PROTECTED;\r\n}\r\nif (se_cmd->data_direction == DMA_TO_DEVICE)\r\ndeve->write_bytes += se_cmd->data_length;\r\nelse if (se_cmd->data_direction == DMA_FROM_DEVICE)\r\ndeve->read_bytes += se_cmd->data_length;\r\nse_lun = deve->se_lun;\r\nse_cmd->se_lun = deve->se_lun;\r\nse_cmd->pr_res_key = deve->pr_res_key;\r\nse_cmd->orig_fe_lun = unpacked_lun;\r\nse_cmd->se_cmd_flags |= SCF_SE_LUN_CMD;\r\npercpu_ref_get(&se_lun->lun_ref);\r\nse_cmd->lun_ref_active = true;\r\n}\r\nspin_unlock_irqrestore(&se_sess->se_node_acl->device_list_lock, flags);\r\nif (!se_lun) {\r\nif (unpacked_lun != 0) {\r\npr_err("TARGET_CORE[%s]: Detected NON_EXISTENT_LUN"\r\n" Access for 0x%08x\n",\r\nse_cmd->se_tfo->get_fabric_name(),\r\nunpacked_lun);\r\nreturn TCM_NON_EXISTENT_LUN;\r\n}\r\nif ((se_cmd->data_direction != DMA_FROM_DEVICE) &&\r\n(se_cmd->data_direction != DMA_NONE))\r\nreturn TCM_WRITE_PROTECTED;\r\nse_lun = &se_sess->se_tpg->tpg_virt_lun0;\r\nse_cmd->se_lun = &se_sess->se_tpg->tpg_virt_lun0;\r\nse_cmd->orig_fe_lun = 0;\r\nse_cmd->se_cmd_flags |= SCF_SE_LUN_CMD;\r\npercpu_ref_get(&se_lun->lun_ref);\r\nse_cmd->lun_ref_active = true;\r\n}\r\nse_cmd->se_dev = se_lun->lun_se_dev;\r\ndev = se_lun->lun_se_dev;\r\natomic_long_inc(&dev->num_cmds);\r\nif (se_cmd->data_direction == DMA_TO_DEVICE)\r\natomic_long_add(se_cmd->data_length, &dev->write_bytes);\r\nelse if (se_cmd->data_direction == DMA_FROM_DEVICE)\r\natomic_long_add(se_cmd->data_length, &dev->read_bytes);\r\nreturn 0;\r\n}\r\nint transport_lookup_tmr_lun(struct se_cmd *se_cmd, u32 unpacked_lun)\r\n{\r\nstruct se_dev_entry *deve;\r\nstruct se_lun *se_lun = NULL;\r\nstruct se_session *se_sess = se_cmd->se_sess;\r\nstruct se_tmr_req *se_tmr = se_cmd->se_tmr_req;\r\nunsigned long flags;\r\nif (unpacked_lun >= TRANSPORT_MAX_LUNS_PER_TPG)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&se_sess->se_node_acl->device_list_lock, flags);\r\nse_cmd->se_deve = se_sess->se_node_acl->device_list[unpacked_lun];\r\ndeve = se_cmd->se_deve;\r\nif (deve->lun_flags & TRANSPORT_LUNFLAGS_INITIATOR_ACCESS) {\r\nse_tmr->tmr_lun = deve->se_lun;\r\nse_cmd->se_lun = deve->se_lun;\r\nse_lun = deve->se_lun;\r\nse_cmd->pr_res_key = deve->pr_res_key;\r\nse_cmd->orig_fe_lun = unpacked_lun;\r\n}\r\nspin_unlock_irqrestore(&se_sess->se_node_acl->device_list_lock, flags);\r\nif (!se_lun) {\r\npr_debug("TARGET_CORE[%s]: Detected NON_EXISTENT_LUN"\r\n" Access for 0x%08x\n",\r\nse_cmd->se_tfo->get_fabric_name(),\r\nunpacked_lun);\r\nreturn -ENODEV;\r\n}\r\nse_cmd->se_dev = se_lun->lun_se_dev;\r\nse_tmr->tmr_dev = se_lun->lun_se_dev;\r\nspin_lock_irqsave(&se_tmr->tmr_dev->se_tmr_lock, flags);\r\nlist_add_tail(&se_tmr->tmr_list, &se_tmr->tmr_dev->dev_tmr_list);\r\nspin_unlock_irqrestore(&se_tmr->tmr_dev->se_tmr_lock, flags);\r\nreturn 0;\r\n}\r\nstruct se_dev_entry *core_get_se_deve_from_rtpi(\r\nstruct se_node_acl *nacl,\r\nu16 rtpi)\r\n{\r\nstruct se_dev_entry *deve;\r\nstruct se_lun *lun;\r\nstruct se_port *port;\r\nstruct se_portal_group *tpg = nacl->se_tpg;\r\nu32 i;\r\nspin_lock_irq(&nacl->device_list_lock);\r\nfor (i = 0; i < TRANSPORT_MAX_LUNS_PER_TPG; i++) {\r\ndeve = nacl->device_list[i];\r\nif (!(deve->lun_flags & TRANSPORT_LUNFLAGS_INITIATOR_ACCESS))\r\ncontinue;\r\nlun = deve->se_lun;\r\nif (!lun) {\r\npr_err("%s device entries device pointer is"\r\n" NULL, but Initiator has access.\n",\r\ntpg->se_tpg_tfo->get_fabric_name());\r\ncontinue;\r\n}\r\nport = lun->lun_sep;\r\nif (!port) {\r\npr_err("%s device entries device pointer is"\r\n" NULL, but Initiator has access.\n",\r\ntpg->se_tpg_tfo->get_fabric_name());\r\ncontinue;\r\n}\r\nif (port->sep_rtpi != rtpi)\r\ncontinue;\r\natomic_inc(&deve->pr_ref_count);\r\nsmp_mb__after_atomic();\r\nspin_unlock_irq(&nacl->device_list_lock);\r\nreturn deve;\r\n}\r\nspin_unlock_irq(&nacl->device_list_lock);\r\nreturn NULL;\r\n}\r\nint core_free_device_list_for_node(\r\nstruct se_node_acl *nacl,\r\nstruct se_portal_group *tpg)\r\n{\r\nstruct se_dev_entry *deve;\r\nstruct se_lun *lun;\r\nu32 i;\r\nif (!nacl->device_list)\r\nreturn 0;\r\nspin_lock_irq(&nacl->device_list_lock);\r\nfor (i = 0; i < TRANSPORT_MAX_LUNS_PER_TPG; i++) {\r\ndeve = nacl->device_list[i];\r\nif (!(deve->lun_flags & TRANSPORT_LUNFLAGS_INITIATOR_ACCESS))\r\ncontinue;\r\nif (!deve->se_lun) {\r\npr_err("%s device entries device pointer is"\r\n" NULL, but Initiator has access.\n",\r\ntpg->se_tpg_tfo->get_fabric_name());\r\ncontinue;\r\n}\r\nlun = deve->se_lun;\r\nspin_unlock_irq(&nacl->device_list_lock);\r\ncore_disable_device_list_for_node(lun, NULL, deve->mapped_lun,\r\nTRANSPORT_LUNFLAGS_NO_ACCESS, nacl, tpg);\r\nspin_lock_irq(&nacl->device_list_lock);\r\n}\r\nspin_unlock_irq(&nacl->device_list_lock);\r\narray_free(nacl->device_list, TRANSPORT_MAX_LUNS_PER_TPG);\r\nnacl->device_list = NULL;\r\nreturn 0;\r\n}\r\nvoid core_update_device_list_access(\r\nu32 mapped_lun,\r\nu32 lun_access,\r\nstruct se_node_acl *nacl)\r\n{\r\nstruct se_dev_entry *deve;\r\nspin_lock_irq(&nacl->device_list_lock);\r\ndeve = nacl->device_list[mapped_lun];\r\nif (lun_access & TRANSPORT_LUNFLAGS_READ_WRITE) {\r\ndeve->lun_flags &= ~TRANSPORT_LUNFLAGS_READ_ONLY;\r\ndeve->lun_flags |= TRANSPORT_LUNFLAGS_READ_WRITE;\r\n} else {\r\ndeve->lun_flags &= ~TRANSPORT_LUNFLAGS_READ_WRITE;\r\ndeve->lun_flags |= TRANSPORT_LUNFLAGS_READ_ONLY;\r\n}\r\nspin_unlock_irq(&nacl->device_list_lock);\r\n}\r\nint core_enable_device_list_for_node(\r\nstruct se_lun *lun,\r\nstruct se_lun_acl *lun_acl,\r\nu32 mapped_lun,\r\nu32 lun_access,\r\nstruct se_node_acl *nacl,\r\nstruct se_portal_group *tpg)\r\n{\r\nstruct se_port *port = lun->lun_sep;\r\nstruct se_dev_entry *deve;\r\nspin_lock_irq(&nacl->device_list_lock);\r\ndeve = nacl->device_list[mapped_lun];\r\nif (deve->lun_flags & TRANSPORT_LUNFLAGS_INITIATOR_ACCESS) {\r\nif (deve->se_lun_acl != NULL) {\r\npr_err("struct se_dev_entry->se_lun_acl"\r\n" already set for demo mode -> explicit"\r\n" LUN ACL transition\n");\r\nspin_unlock_irq(&nacl->device_list_lock);\r\nreturn -EINVAL;\r\n}\r\nif (deve->se_lun != lun) {\r\npr_err("struct se_dev_entry->se_lun does"\r\n" match passed struct se_lun for demo mode"\r\n" -> explicit LUN ACL transition\n");\r\nspin_unlock_irq(&nacl->device_list_lock);\r\nreturn -EINVAL;\r\n}\r\ndeve->se_lun_acl = lun_acl;\r\nif (lun_access & TRANSPORT_LUNFLAGS_READ_WRITE) {\r\ndeve->lun_flags &= ~TRANSPORT_LUNFLAGS_READ_ONLY;\r\ndeve->lun_flags |= TRANSPORT_LUNFLAGS_READ_WRITE;\r\n} else {\r\ndeve->lun_flags &= ~TRANSPORT_LUNFLAGS_READ_WRITE;\r\ndeve->lun_flags |= TRANSPORT_LUNFLAGS_READ_ONLY;\r\n}\r\nspin_unlock_irq(&nacl->device_list_lock);\r\nreturn 0;\r\n}\r\ndeve->se_lun = lun;\r\ndeve->se_lun_acl = lun_acl;\r\ndeve->mapped_lun = mapped_lun;\r\ndeve->lun_flags |= TRANSPORT_LUNFLAGS_INITIATOR_ACCESS;\r\nif (lun_access & TRANSPORT_LUNFLAGS_READ_WRITE) {\r\ndeve->lun_flags &= ~TRANSPORT_LUNFLAGS_READ_ONLY;\r\ndeve->lun_flags |= TRANSPORT_LUNFLAGS_READ_WRITE;\r\n} else {\r\ndeve->lun_flags &= ~TRANSPORT_LUNFLAGS_READ_WRITE;\r\ndeve->lun_flags |= TRANSPORT_LUNFLAGS_READ_ONLY;\r\n}\r\ndeve->creation_time = get_jiffies_64();\r\ndeve->attach_count++;\r\nspin_unlock_irq(&nacl->device_list_lock);\r\nspin_lock_bh(&port->sep_alua_lock);\r\nlist_add_tail(&deve->alua_port_list, &port->sep_alua_list);\r\nspin_unlock_bh(&port->sep_alua_lock);\r\nreturn 0;\r\n}\r\nint core_disable_device_list_for_node(\r\nstruct se_lun *lun,\r\nstruct se_lun_acl *lun_acl,\r\nu32 mapped_lun,\r\nu32 lun_access,\r\nstruct se_node_acl *nacl,\r\nstruct se_portal_group *tpg)\r\n{\r\nstruct se_port *port = lun->lun_sep;\r\nstruct se_dev_entry *deve = nacl->device_list[mapped_lun];\r\nspin_lock_bh(&port->sep_alua_lock);\r\nlist_del(&deve->alua_port_list);\r\nspin_unlock_bh(&port->sep_alua_lock);\r\nwhile (atomic_read(&deve->pr_ref_count) != 0)\r\ncpu_relax();\r\nspin_lock_irq(&nacl->device_list_lock);\r\ncore_scsi3_ua_release_all(deve);\r\ndeve->se_lun = NULL;\r\ndeve->se_lun_acl = NULL;\r\ndeve->lun_flags = 0;\r\ndeve->creation_time = 0;\r\ndeve->attach_count--;\r\nspin_unlock_irq(&nacl->device_list_lock);\r\ncore_scsi3_free_pr_reg_from_nacl(lun->lun_se_dev, nacl);\r\nreturn 0;\r\n}\r\nvoid core_clear_lun_from_tpg(struct se_lun *lun, struct se_portal_group *tpg)\r\n{\r\nstruct se_node_acl *nacl;\r\nstruct se_dev_entry *deve;\r\nu32 i;\r\nspin_lock_irq(&tpg->acl_node_lock);\r\nlist_for_each_entry(nacl, &tpg->acl_node_list, acl_list) {\r\nspin_unlock_irq(&tpg->acl_node_lock);\r\nspin_lock_irq(&nacl->device_list_lock);\r\nfor (i = 0; i < TRANSPORT_MAX_LUNS_PER_TPG; i++) {\r\ndeve = nacl->device_list[i];\r\nif (lun != deve->se_lun)\r\ncontinue;\r\nspin_unlock_irq(&nacl->device_list_lock);\r\ncore_disable_device_list_for_node(lun, NULL,\r\ndeve->mapped_lun, TRANSPORT_LUNFLAGS_NO_ACCESS,\r\nnacl, tpg);\r\nspin_lock_irq(&nacl->device_list_lock);\r\n}\r\nspin_unlock_irq(&nacl->device_list_lock);\r\nspin_lock_irq(&tpg->acl_node_lock);\r\n}\r\nspin_unlock_irq(&tpg->acl_node_lock);\r\n}\r\nstatic struct se_port *core_alloc_port(struct se_device *dev)\r\n{\r\nstruct se_port *port, *port_tmp;\r\nport = kzalloc(sizeof(struct se_port), GFP_KERNEL);\r\nif (!port) {\r\npr_err("Unable to allocate struct se_port\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nINIT_LIST_HEAD(&port->sep_alua_list);\r\nINIT_LIST_HEAD(&port->sep_list);\r\natomic_set(&port->sep_tg_pt_secondary_offline, 0);\r\nspin_lock_init(&port->sep_alua_lock);\r\nmutex_init(&port->sep_tg_pt_md_mutex);\r\nspin_lock(&dev->se_port_lock);\r\nif (dev->dev_port_count == 0x0000ffff) {\r\npr_warn("Reached dev->dev_port_count =="\r\n" 0x0000ffff\n");\r\nspin_unlock(&dev->se_port_lock);\r\nreturn ERR_PTR(-ENOSPC);\r\n}\r\nagain:\r\nport->sep_rtpi = dev->dev_rpti_counter++;\r\nif (!port->sep_rtpi)\r\ngoto again;\r\nlist_for_each_entry(port_tmp, &dev->dev_sep_list, sep_list) {\r\nif (port->sep_rtpi == port_tmp->sep_rtpi)\r\ngoto again;\r\n}\r\nspin_unlock(&dev->se_port_lock);\r\nreturn port;\r\n}\r\nstatic void core_export_port(\r\nstruct se_device *dev,\r\nstruct se_portal_group *tpg,\r\nstruct se_port *port,\r\nstruct se_lun *lun)\r\n{\r\nstruct t10_alua_tg_pt_gp_member *tg_pt_gp_mem = NULL;\r\nspin_lock(&dev->se_port_lock);\r\nspin_lock(&lun->lun_sep_lock);\r\nport->sep_tpg = tpg;\r\nport->sep_lun = lun;\r\nlun->lun_sep = port;\r\nspin_unlock(&lun->lun_sep_lock);\r\nlist_add_tail(&port->sep_list, &dev->dev_sep_list);\r\nspin_unlock(&dev->se_port_lock);\r\nif (dev->transport->transport_type != TRANSPORT_PLUGIN_PHBA_PDEV &&\r\n!(dev->se_hba->hba_flags & HBA_FLAGS_INTERNAL_USE)) {\r\ntg_pt_gp_mem = core_alua_allocate_tg_pt_gp_mem(port);\r\nif (IS_ERR(tg_pt_gp_mem) || !tg_pt_gp_mem) {\r\npr_err("Unable to allocate t10_alua_tg_pt"\r\n"_gp_member_t\n");\r\nreturn;\r\n}\r\nspin_lock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\n__core_alua_attach_tg_pt_gp_mem(tg_pt_gp_mem,\r\ndev->t10_alua.default_tg_pt_gp);\r\nspin_unlock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);\r\npr_debug("%s/%s: Adding to default ALUA Target Port"\r\n" Group: alua/default_tg_pt_gp\n",\r\ndev->transport->name, tpg->se_tpg_tfo->get_fabric_name());\r\n}\r\ndev->dev_port_count++;\r\nport->sep_index = port->sep_rtpi;\r\n}\r\nstatic void core_release_port(struct se_device *dev, struct se_port *port)\r\n__releases(&dev->se_port_lock\r\nint core_dev_export(\r\nstruct se_device *dev,\r\nstruct se_portal_group *tpg,\r\nstruct se_lun *lun)\r\n{\r\nstruct se_hba *hba = dev->se_hba;\r\nstruct se_port *port;\r\nport = core_alloc_port(dev);\r\nif (IS_ERR(port))\r\nreturn PTR_ERR(port);\r\nlun->lun_se_dev = dev;\r\nspin_lock(&hba->device_lock);\r\ndev->export_count++;\r\nspin_unlock(&hba->device_lock);\r\ncore_export_port(dev, tpg, port, lun);\r\nreturn 0;\r\n}\r\nvoid core_dev_unexport(\r\nstruct se_device *dev,\r\nstruct se_portal_group *tpg,\r\nstruct se_lun *lun)\r\n{\r\nstruct se_hba *hba = dev->se_hba;\r\nstruct se_port *port = lun->lun_sep;\r\nspin_lock(&lun->lun_sep_lock);\r\nif (lun->lun_se_dev == NULL) {\r\nspin_unlock(&lun->lun_sep_lock);\r\nreturn;\r\n}\r\nspin_unlock(&lun->lun_sep_lock);\r\nspin_lock(&dev->se_port_lock);\r\ncore_release_port(dev, port);\r\nspin_unlock(&dev->se_port_lock);\r\nspin_lock(&hba->device_lock);\r\ndev->export_count--;\r\nspin_unlock(&hba->device_lock);\r\nlun->lun_sep = NULL;\r\nlun->lun_se_dev = NULL;\r\n}\r\nstatic void se_release_vpd_for_dev(struct se_device *dev)\r\n{\r\nstruct t10_vpd *vpd, *vpd_tmp;\r\nspin_lock(&dev->t10_wwn.t10_vpd_lock);\r\nlist_for_each_entry_safe(vpd, vpd_tmp,\r\n&dev->t10_wwn.t10_vpd_list, vpd_list) {\r\nlist_del(&vpd->vpd_list);\r\nkfree(vpd);\r\n}\r\nspin_unlock(&dev->t10_wwn.t10_vpd_lock);\r\n}\r\nstatic u32 se_dev_align_max_sectors(u32 max_sectors, u32 block_size)\r\n{\r\nu32 aligned_max_sectors;\r\nu32 alignment;\r\nalignment = max(1ul, PAGE_SIZE / block_size);\r\naligned_max_sectors = rounddown(max_sectors, alignment);\r\nif (max_sectors != aligned_max_sectors)\r\npr_info("Rounding down aligned max_sectors from %u to %u\n",\r\nmax_sectors, aligned_max_sectors);\r\nreturn aligned_max_sectors;\r\n}\r\nint se_dev_set_max_unmap_lba_count(\r\nstruct se_device *dev,\r\nu32 max_unmap_lba_count)\r\n{\r\ndev->dev_attrib.max_unmap_lba_count = max_unmap_lba_count;\r\npr_debug("dev[%p]: Set max_unmap_lba_count: %u\n",\r\ndev, dev->dev_attrib.max_unmap_lba_count);\r\nreturn 0;\r\n}\r\nint se_dev_set_max_unmap_block_desc_count(\r\nstruct se_device *dev,\r\nu32 max_unmap_block_desc_count)\r\n{\r\ndev->dev_attrib.max_unmap_block_desc_count =\r\nmax_unmap_block_desc_count;\r\npr_debug("dev[%p]: Set max_unmap_block_desc_count: %u\n",\r\ndev, dev->dev_attrib.max_unmap_block_desc_count);\r\nreturn 0;\r\n}\r\nint se_dev_set_unmap_granularity(\r\nstruct se_device *dev,\r\nu32 unmap_granularity)\r\n{\r\ndev->dev_attrib.unmap_granularity = unmap_granularity;\r\npr_debug("dev[%p]: Set unmap_granularity: %u\n",\r\ndev, dev->dev_attrib.unmap_granularity);\r\nreturn 0;\r\n}\r\nint se_dev_set_unmap_granularity_alignment(\r\nstruct se_device *dev,\r\nu32 unmap_granularity_alignment)\r\n{\r\ndev->dev_attrib.unmap_granularity_alignment = unmap_granularity_alignment;\r\npr_debug("dev[%p]: Set unmap_granularity_alignment: %u\n",\r\ndev, dev->dev_attrib.unmap_granularity_alignment);\r\nreturn 0;\r\n}\r\nint se_dev_set_max_write_same_len(\r\nstruct se_device *dev,\r\nu32 max_write_same_len)\r\n{\r\ndev->dev_attrib.max_write_same_len = max_write_same_len;\r\npr_debug("dev[%p]: Set max_write_same_len: %u\n",\r\ndev, dev->dev_attrib.max_write_same_len);\r\nreturn 0;\r\n}\r\nstatic void dev_set_t10_wwn_model_alias(struct se_device *dev)\r\n{\r\nconst char *configname;\r\nconfigname = config_item_name(&dev->dev_group.cg_item);\r\nif (strlen(configname) >= 16) {\r\npr_warn("dev[%p]: Backstore name '%s' is too long for "\r\n"INQUIRY_MODEL, truncating to 16 bytes\n", dev,\r\nconfigname);\r\n}\r\nsnprintf(&dev->t10_wwn.model[0], 16, "%s", configname);\r\n}\r\nint se_dev_set_emulate_model_alias(struct se_device *dev, int flag)\r\n{\r\nif (dev->export_count) {\r\npr_err("dev[%p]: Unable to change model alias"\r\n" while export_count is %d\n",\r\ndev, dev->export_count);\r\nreturn -EINVAL;\r\n}\r\nif (flag != 0 && flag != 1) {\r\npr_err("Illegal value %d\n", flag);\r\nreturn -EINVAL;\r\n}\r\nif (flag) {\r\ndev_set_t10_wwn_model_alias(dev);\r\n} else {\r\nstrncpy(&dev->t10_wwn.model[0],\r\ndev->transport->inquiry_prod, 16);\r\n}\r\ndev->dev_attrib.emulate_model_alias = flag;\r\nreturn 0;\r\n}\r\nint se_dev_set_emulate_dpo(struct se_device *dev, int flag)\r\n{\r\nif (flag != 0 && flag != 1) {\r\npr_err("Illegal value %d\n", flag);\r\nreturn -EINVAL;\r\n}\r\nif (flag) {\r\npr_err("dpo_emulated not supported\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint se_dev_set_emulate_fua_write(struct se_device *dev, int flag)\r\n{\r\nif (flag != 0 && flag != 1) {\r\npr_err("Illegal value %d\n", flag);\r\nreturn -EINVAL;\r\n}\r\nif (flag &&\r\ndev->transport->transport_type == TRANSPORT_PLUGIN_PHBA_PDEV) {\r\npr_err("emulate_fua_write not supported for pSCSI\n");\r\nreturn -EINVAL;\r\n}\r\ndev->dev_attrib.emulate_fua_write = flag;\r\npr_debug("dev[%p]: SE Device Forced Unit Access WRITEs: %d\n",\r\ndev, dev->dev_attrib.emulate_fua_write);\r\nreturn 0;\r\n}\r\nint se_dev_set_emulate_fua_read(struct se_device *dev, int flag)\r\n{\r\nif (flag != 0 && flag != 1) {\r\npr_err("Illegal value %d\n", flag);\r\nreturn -EINVAL;\r\n}\r\nif (flag) {\r\npr_err("ua read emulated not supported\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint se_dev_set_emulate_write_cache(struct se_device *dev, int flag)\r\n{\r\nif (flag != 0 && flag != 1) {\r\npr_err("Illegal value %d\n", flag);\r\nreturn -EINVAL;\r\n}\r\nif (flag &&\r\ndev->transport->transport_type == TRANSPORT_PLUGIN_PHBA_PDEV) {\r\npr_err("emulate_write_cache not supported for pSCSI\n");\r\nreturn -EINVAL;\r\n}\r\nif (flag &&\r\ndev->transport->get_write_cache) {\r\npr_err("emulate_write_cache not supported for this device\n");\r\nreturn -EINVAL;\r\n}\r\ndev->dev_attrib.emulate_write_cache = flag;\r\npr_debug("dev[%p]: SE Device WRITE_CACHE_EMULATION flag: %d\n",\r\ndev, dev->dev_attrib.emulate_write_cache);\r\nreturn 0;\r\n}\r\nint se_dev_set_emulate_ua_intlck_ctrl(struct se_device *dev, int flag)\r\n{\r\nif ((flag != 0) && (flag != 1) && (flag != 2)) {\r\npr_err("Illegal value %d\n", flag);\r\nreturn -EINVAL;\r\n}\r\nif (dev->export_count) {\r\npr_err("dev[%p]: Unable to change SE Device"\r\n" UA_INTRLCK_CTRL while export_count is %d\n",\r\ndev, dev->export_count);\r\nreturn -EINVAL;\r\n}\r\ndev->dev_attrib.emulate_ua_intlck_ctrl = flag;\r\npr_debug("dev[%p]: SE Device UA_INTRLCK_CTRL flag: %d\n",\r\ndev, dev->dev_attrib.emulate_ua_intlck_ctrl);\r\nreturn 0;\r\n}\r\nint se_dev_set_emulate_tas(struct se_device *dev, int flag)\r\n{\r\nif ((flag != 0) && (flag != 1)) {\r\npr_err("Illegal value %d\n", flag);\r\nreturn -EINVAL;\r\n}\r\nif (dev->export_count) {\r\npr_err("dev[%p]: Unable to change SE Device TAS while"\r\n" export_count is %d\n",\r\ndev, dev->export_count);\r\nreturn -EINVAL;\r\n}\r\ndev->dev_attrib.emulate_tas = flag;\r\npr_debug("dev[%p]: SE Device TASK_ABORTED status bit: %s\n",\r\ndev, (dev->dev_attrib.emulate_tas) ? "Enabled" : "Disabled");\r\nreturn 0;\r\n}\r\nint se_dev_set_emulate_tpu(struct se_device *dev, int flag)\r\n{\r\nif ((flag != 0) && (flag != 1)) {\r\npr_err("Illegal value %d\n", flag);\r\nreturn -EINVAL;\r\n}\r\nif (flag && !dev->dev_attrib.max_unmap_block_desc_count) {\r\npr_err("Generic Block Discard not supported\n");\r\nreturn -ENOSYS;\r\n}\r\ndev->dev_attrib.emulate_tpu = flag;\r\npr_debug("dev[%p]: SE Device Thin Provisioning UNMAP bit: %d\n",\r\ndev, flag);\r\nreturn 0;\r\n}\r\nint se_dev_set_emulate_tpws(struct se_device *dev, int flag)\r\n{\r\nif ((flag != 0) && (flag != 1)) {\r\npr_err("Illegal value %d\n", flag);\r\nreturn -EINVAL;\r\n}\r\nif (flag && !dev->dev_attrib.max_unmap_block_desc_count) {\r\npr_err("Generic Block Discard not supported\n");\r\nreturn -ENOSYS;\r\n}\r\ndev->dev_attrib.emulate_tpws = flag;\r\npr_debug("dev[%p]: SE Device Thin Provisioning WRITE_SAME: %d\n",\r\ndev, flag);\r\nreturn 0;\r\n}\r\nint se_dev_set_emulate_caw(struct se_device *dev, int flag)\r\n{\r\nif (flag != 0 && flag != 1) {\r\npr_err("Illegal value %d\n", flag);\r\nreturn -EINVAL;\r\n}\r\ndev->dev_attrib.emulate_caw = flag;\r\npr_debug("dev[%p]: SE Device CompareAndWrite (AtomicTestandSet): %d\n",\r\ndev, flag);\r\nreturn 0;\r\n}\r\nint se_dev_set_emulate_3pc(struct se_device *dev, int flag)\r\n{\r\nif (flag != 0 && flag != 1) {\r\npr_err("Illegal value %d\n", flag);\r\nreturn -EINVAL;\r\n}\r\ndev->dev_attrib.emulate_3pc = flag;\r\npr_debug("dev[%p]: SE Device 3rd Party Copy (EXTENDED_COPY): %d\n",\r\ndev, flag);\r\nreturn 0;\r\n}\r\nint se_dev_set_pi_prot_type(struct se_device *dev, int flag)\r\n{\r\nint rc, old_prot = dev->dev_attrib.pi_prot_type;\r\nif (flag != 0 && flag != 1 && flag != 2 && flag != 3) {\r\npr_err("Illegal value %d for pi_prot_type\n", flag);\r\nreturn -EINVAL;\r\n}\r\nif (flag == 2) {\r\npr_err("DIF TYPE2 protection currently not supported\n");\r\nreturn -ENOSYS;\r\n}\r\nif (dev->dev_attrib.hw_pi_prot_type) {\r\npr_warn("DIF protection enabled on underlying hardware,"\r\n" ignoring\n");\r\nreturn 0;\r\n}\r\nif (!dev->transport->init_prot || !dev->transport->free_prot) {\r\nif (flag == 0)\r\nreturn 0;\r\npr_err("DIF protection not supported by backend: %s\n",\r\ndev->transport->name);\r\nreturn -ENOSYS;\r\n}\r\nif (!(dev->dev_flags & DF_CONFIGURED)) {\r\npr_err("DIF protection requires device to be configured\n");\r\nreturn -ENODEV;\r\n}\r\nif (dev->export_count) {\r\npr_err("dev[%p]: Unable to change SE Device PROT type while"\r\n" export_count is %d\n", dev, dev->export_count);\r\nreturn -EINVAL;\r\n}\r\ndev->dev_attrib.pi_prot_type = flag;\r\nif (flag && !old_prot) {\r\nrc = dev->transport->init_prot(dev);\r\nif (rc) {\r\ndev->dev_attrib.pi_prot_type = old_prot;\r\nreturn rc;\r\n}\r\n} else if (!flag && old_prot) {\r\ndev->transport->free_prot(dev);\r\n}\r\npr_debug("dev[%p]: SE Device Protection Type: %d\n", dev, flag);\r\nreturn 0;\r\n}\r\nint se_dev_set_pi_prot_format(struct se_device *dev, int flag)\r\n{\r\nint rc;\r\nif (!flag)\r\nreturn 0;\r\nif (flag != 1) {\r\npr_err("Illegal value %d for pi_prot_format\n", flag);\r\nreturn -EINVAL;\r\n}\r\nif (!dev->transport->format_prot) {\r\npr_err("DIF protection format not supported by backend %s\n",\r\ndev->transport->name);\r\nreturn -ENOSYS;\r\n}\r\nif (!(dev->dev_flags & DF_CONFIGURED)) {\r\npr_err("DIF protection format requires device to be configured\n");\r\nreturn -ENODEV;\r\n}\r\nif (dev->export_count) {\r\npr_err("dev[%p]: Unable to format SE Device PROT type while"\r\n" export_count is %d\n", dev, dev->export_count);\r\nreturn -EINVAL;\r\n}\r\nrc = dev->transport->format_prot(dev);\r\nif (rc)\r\nreturn rc;\r\npr_debug("dev[%p]: SE Device Protection Format complete\n", dev);\r\nreturn 0;\r\n}\r\nint se_dev_set_enforce_pr_isids(struct se_device *dev, int flag)\r\n{\r\nif ((flag != 0) && (flag != 1)) {\r\npr_err("Illegal value %d\n", flag);\r\nreturn -EINVAL;\r\n}\r\ndev->dev_attrib.enforce_pr_isids = flag;\r\npr_debug("dev[%p]: SE Device enforce_pr_isids bit: %s\n", dev,\r\n(dev->dev_attrib.enforce_pr_isids) ? "Enabled" : "Disabled");\r\nreturn 0;\r\n}\r\nint se_dev_set_is_nonrot(struct se_device *dev, int flag)\r\n{\r\nif ((flag != 0) && (flag != 1)) {\r\nprintk(KERN_ERR "Illegal value %d\n", flag);\r\nreturn -EINVAL;\r\n}\r\ndev->dev_attrib.is_nonrot = flag;\r\npr_debug("dev[%p]: SE Device is_nonrot bit: %d\n",\r\ndev, flag);\r\nreturn 0;\r\n}\r\nint se_dev_set_emulate_rest_reord(struct se_device *dev, int flag)\r\n{\r\nif (flag != 0) {\r\nprintk(KERN_ERR "dev[%p]: SE Device emulatation of restricted"\r\n" reordering not implemented\n", dev);\r\nreturn -ENOSYS;\r\n}\r\ndev->dev_attrib.emulate_rest_reord = flag;\r\npr_debug("dev[%p]: SE Device emulate_rest_reord: %d\n", dev, flag);\r\nreturn 0;\r\n}\r\nint se_dev_set_queue_depth(struct se_device *dev, u32 queue_depth)\r\n{\r\nif (dev->export_count) {\r\npr_err("dev[%p]: Unable to change SE Device TCQ while"\r\n" export_count is %d\n",\r\ndev, dev->export_count);\r\nreturn -EINVAL;\r\n}\r\nif (!queue_depth) {\r\npr_err("dev[%p]: Illegal ZERO value for queue"\r\n"_depth\n", dev);\r\nreturn -EINVAL;\r\n}\r\nif (dev->transport->transport_type == TRANSPORT_PLUGIN_PHBA_PDEV) {\r\nif (queue_depth > dev->dev_attrib.hw_queue_depth) {\r\npr_err("dev[%p]: Passed queue_depth: %u"\r\n" exceeds TCM/SE_Device TCQ: %u\n",\r\ndev, queue_depth,\r\ndev->dev_attrib.hw_queue_depth);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (queue_depth > dev->dev_attrib.queue_depth) {\r\nif (queue_depth > dev->dev_attrib.hw_queue_depth) {\r\npr_err("dev[%p]: Passed queue_depth:"\r\n" %u exceeds TCM/SE_Device MAX"\r\n" TCQ: %u\n", dev, queue_depth,\r\ndev->dev_attrib.hw_queue_depth);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\ndev->dev_attrib.queue_depth = dev->queue_depth = queue_depth;\r\npr_debug("dev[%p]: SE Device TCQ Depth changed to: %u\n",\r\ndev, queue_depth);\r\nreturn 0;\r\n}\r\nint se_dev_set_fabric_max_sectors(struct se_device *dev, u32 fabric_max_sectors)\r\n{\r\nint block_size = dev->dev_attrib.block_size;\r\nif (dev->export_count) {\r\npr_err("dev[%p]: Unable to change SE Device"\r\n" fabric_max_sectors while export_count is %d\n",\r\ndev, dev->export_count);\r\nreturn -EINVAL;\r\n}\r\nif (!fabric_max_sectors) {\r\npr_err("dev[%p]: Illegal ZERO value for"\r\n" fabric_max_sectors\n", dev);\r\nreturn -EINVAL;\r\n}\r\nif (fabric_max_sectors < DA_STATUS_MAX_SECTORS_MIN) {\r\npr_err("dev[%p]: Passed fabric_max_sectors: %u less than"\r\n" DA_STATUS_MAX_SECTORS_MIN: %u\n", dev, fabric_max_sectors,\r\nDA_STATUS_MAX_SECTORS_MIN);\r\nreturn -EINVAL;\r\n}\r\nif (dev->transport->transport_type == TRANSPORT_PLUGIN_PHBA_PDEV) {\r\nif (fabric_max_sectors > dev->dev_attrib.hw_max_sectors) {\r\npr_err("dev[%p]: Passed fabric_max_sectors: %u"\r\n" greater than TCM/SE_Device max_sectors:"\r\n" %u\n", dev, fabric_max_sectors,\r\ndev->dev_attrib.hw_max_sectors);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (fabric_max_sectors > DA_STATUS_MAX_SECTORS_MAX) {\r\npr_err("dev[%p]: Passed fabric_max_sectors: %u"\r\n" greater than DA_STATUS_MAX_SECTORS_MAX:"\r\n" %u\n", dev, fabric_max_sectors,\r\nDA_STATUS_MAX_SECTORS_MAX);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!block_size) {\r\nblock_size = 512;\r\npr_warn("Defaulting to 512 for zero block_size\n");\r\n}\r\nfabric_max_sectors = se_dev_align_max_sectors(fabric_max_sectors,\r\nblock_size);\r\ndev->dev_attrib.fabric_max_sectors = fabric_max_sectors;\r\npr_debug("dev[%p]: SE Device max_sectors changed to %u\n",\r\ndev, fabric_max_sectors);\r\nreturn 0;\r\n}\r\nint se_dev_set_optimal_sectors(struct se_device *dev, u32 optimal_sectors)\r\n{\r\nif (dev->export_count) {\r\npr_err("dev[%p]: Unable to change SE Device"\r\n" optimal_sectors while export_count is %d\n",\r\ndev, dev->export_count);\r\nreturn -EINVAL;\r\n}\r\nif (dev->transport->transport_type == TRANSPORT_PLUGIN_PHBA_PDEV) {\r\npr_err("dev[%p]: Passed optimal_sectors cannot be"\r\n" changed for TCM/pSCSI\n", dev);\r\nreturn -EINVAL;\r\n}\r\nif (optimal_sectors > dev->dev_attrib.fabric_max_sectors) {\r\npr_err("dev[%p]: Passed optimal_sectors %u cannot be"\r\n" greater than fabric_max_sectors: %u\n", dev,\r\noptimal_sectors, dev->dev_attrib.fabric_max_sectors);\r\nreturn -EINVAL;\r\n}\r\ndev->dev_attrib.optimal_sectors = optimal_sectors;\r\npr_debug("dev[%p]: SE Device optimal_sectors changed to %u\n",\r\ndev, optimal_sectors);\r\nreturn 0;\r\n}\r\nint se_dev_set_block_size(struct se_device *dev, u32 block_size)\r\n{\r\nif (dev->export_count) {\r\npr_err("dev[%p]: Unable to change SE Device block_size"\r\n" while export_count is %d\n",\r\ndev, dev->export_count);\r\nreturn -EINVAL;\r\n}\r\nif ((block_size != 512) &&\r\n(block_size != 1024) &&\r\n(block_size != 2048) &&\r\n(block_size != 4096)) {\r\npr_err("dev[%p]: Illegal value for block_device: %u"\r\n" for SE device, must be 512, 1024, 2048 or 4096\n",\r\ndev, block_size);\r\nreturn -EINVAL;\r\n}\r\nif (dev->transport->transport_type == TRANSPORT_PLUGIN_PHBA_PDEV) {\r\npr_err("dev[%p]: Not allowed to change block_size for"\r\n" Physical Device, use for Linux/SCSI to change"\r\n" block_size for underlying hardware\n", dev);\r\nreturn -EINVAL;\r\n}\r\ndev->dev_attrib.block_size = block_size;\r\npr_debug("dev[%p]: SE Device block_size changed to %u\n",\r\ndev, block_size);\r\nif (dev->dev_attrib.max_bytes_per_io)\r\ndev->dev_attrib.hw_max_sectors =\r\ndev->dev_attrib.max_bytes_per_io / block_size;\r\nreturn 0;\r\n}\r\nstruct se_lun *core_dev_add_lun(\r\nstruct se_portal_group *tpg,\r\nstruct se_device *dev,\r\nu32 unpacked_lun)\r\n{\r\nstruct se_lun *lun;\r\nint rc;\r\nlun = core_tpg_alloc_lun(tpg, unpacked_lun);\r\nif (IS_ERR(lun))\r\nreturn lun;\r\nrc = core_tpg_add_lun(tpg, lun,\r\nTRANSPORT_LUNFLAGS_READ_WRITE, dev);\r\nif (rc < 0)\r\nreturn ERR_PTR(rc);\r\npr_debug("%s_TPG[%u]_LUN[%u] - Activated %s Logical Unit from"\r\n" CORE HBA: %u\n", tpg->se_tpg_tfo->get_fabric_name(),\r\ntpg->se_tpg_tfo->tpg_get_tag(tpg), lun->unpacked_lun,\r\ntpg->se_tpg_tfo->get_fabric_name(), dev->se_hba->hba_id);\r\nif (tpg->se_tpg_tfo->tpg_check_demo_mode(tpg)) {\r\nstruct se_node_acl *acl;\r\nspin_lock_irq(&tpg->acl_node_lock);\r\nlist_for_each_entry(acl, &tpg->acl_node_list, acl_list) {\r\nif (acl->dynamic_node_acl &&\r\n(!tpg->se_tpg_tfo->tpg_check_demo_mode_login_only ||\r\n!tpg->se_tpg_tfo->tpg_check_demo_mode_login_only(tpg))) {\r\nspin_unlock_irq(&tpg->acl_node_lock);\r\ncore_tpg_add_node_to_devs(acl, tpg);\r\nspin_lock_irq(&tpg->acl_node_lock);\r\n}\r\n}\r\nspin_unlock_irq(&tpg->acl_node_lock);\r\n}\r\nreturn lun;\r\n}\r\nint core_dev_del_lun(\r\nstruct se_portal_group *tpg,\r\nu32 unpacked_lun)\r\n{\r\nstruct se_lun *lun;\r\nlun = core_tpg_pre_dellun(tpg, unpacked_lun);\r\nif (IS_ERR(lun))\r\nreturn PTR_ERR(lun);\r\ncore_tpg_post_dellun(tpg, lun);\r\npr_debug("%s_TPG[%u]_LUN[%u] - Deactivated %s Logical Unit from"\r\n" device object\n", tpg->se_tpg_tfo->get_fabric_name(),\r\ntpg->se_tpg_tfo->tpg_get_tag(tpg), unpacked_lun,\r\ntpg->se_tpg_tfo->get_fabric_name());\r\nreturn 0;\r\n}\r\nstruct se_lun *core_get_lun_from_tpg(struct se_portal_group *tpg, u32 unpacked_lun)\r\n{\r\nstruct se_lun *lun;\r\nspin_lock(&tpg->tpg_lun_lock);\r\nif (unpacked_lun > (TRANSPORT_MAX_LUNS_PER_TPG-1)) {\r\npr_err("%s LUN: %u exceeds TRANSPORT_MAX_LUNS"\r\n"_PER_TPG-1: %u for Target Portal Group: %hu\n",\r\ntpg->se_tpg_tfo->get_fabric_name(), unpacked_lun,\r\nTRANSPORT_MAX_LUNS_PER_TPG-1,\r\ntpg->se_tpg_tfo->tpg_get_tag(tpg));\r\nspin_unlock(&tpg->tpg_lun_lock);\r\nreturn NULL;\r\n}\r\nlun = tpg->tpg_lun_list[unpacked_lun];\r\nif (lun->lun_status != TRANSPORT_LUN_STATUS_FREE) {\r\npr_err("%s Logical Unit Number: %u is not free on"\r\n" Target Portal Group: %hu, ignoring request.\n",\r\ntpg->se_tpg_tfo->get_fabric_name(), unpacked_lun,\r\ntpg->se_tpg_tfo->tpg_get_tag(tpg));\r\nspin_unlock(&tpg->tpg_lun_lock);\r\nreturn NULL;\r\n}\r\nspin_unlock(&tpg->tpg_lun_lock);\r\nreturn lun;\r\n}\r\nstatic struct se_lun *core_dev_get_lun(struct se_portal_group *tpg, u32 unpacked_lun)\r\n{\r\nstruct se_lun *lun;\r\nspin_lock(&tpg->tpg_lun_lock);\r\nif (unpacked_lun > (TRANSPORT_MAX_LUNS_PER_TPG-1)) {\r\npr_err("%s LUN: %u exceeds TRANSPORT_MAX_LUNS_PER"\r\n"_TPG-1: %u for Target Portal Group: %hu\n",\r\ntpg->se_tpg_tfo->get_fabric_name(), unpacked_lun,\r\nTRANSPORT_MAX_LUNS_PER_TPG-1,\r\ntpg->se_tpg_tfo->tpg_get_tag(tpg));\r\nspin_unlock(&tpg->tpg_lun_lock);\r\nreturn NULL;\r\n}\r\nlun = tpg->tpg_lun_list[unpacked_lun];\r\nif (lun->lun_status != TRANSPORT_LUN_STATUS_ACTIVE) {\r\npr_err("%s Logical Unit Number: %u is not active on"\r\n" Target Portal Group: %hu, ignoring request.\n",\r\ntpg->se_tpg_tfo->get_fabric_name(), unpacked_lun,\r\ntpg->se_tpg_tfo->tpg_get_tag(tpg));\r\nspin_unlock(&tpg->tpg_lun_lock);\r\nreturn NULL;\r\n}\r\nspin_unlock(&tpg->tpg_lun_lock);\r\nreturn lun;\r\n}\r\nstruct se_lun_acl *core_dev_init_initiator_node_lun_acl(\r\nstruct se_portal_group *tpg,\r\nstruct se_node_acl *nacl,\r\nu32 mapped_lun,\r\nint *ret)\r\n{\r\nstruct se_lun_acl *lacl;\r\nif (strlen(nacl->initiatorname) >= TRANSPORT_IQN_LEN) {\r\npr_err("%s InitiatorName exceeds maximum size.\n",\r\ntpg->se_tpg_tfo->get_fabric_name());\r\n*ret = -EOVERFLOW;\r\nreturn NULL;\r\n}\r\nlacl = kzalloc(sizeof(struct se_lun_acl), GFP_KERNEL);\r\nif (!lacl) {\r\npr_err("Unable to allocate memory for struct se_lun_acl.\n");\r\n*ret = -ENOMEM;\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&lacl->lacl_list);\r\nlacl->mapped_lun = mapped_lun;\r\nlacl->se_lun_nacl = nacl;\r\nsnprintf(lacl->initiatorname, TRANSPORT_IQN_LEN, "%s",\r\nnacl->initiatorname);\r\nreturn lacl;\r\n}\r\nint core_dev_add_initiator_node_lun_acl(\r\nstruct se_portal_group *tpg,\r\nstruct se_lun_acl *lacl,\r\nu32 unpacked_lun,\r\nu32 lun_access)\r\n{\r\nstruct se_lun *lun;\r\nstruct se_node_acl *nacl;\r\nlun = core_dev_get_lun(tpg, unpacked_lun);\r\nif (!lun) {\r\npr_err("%s Logical Unit Number: %u is not active on"\r\n" Target Portal Group: %hu, ignoring request.\n",\r\ntpg->se_tpg_tfo->get_fabric_name(), unpacked_lun,\r\ntpg->se_tpg_tfo->tpg_get_tag(tpg));\r\nreturn -EINVAL;\r\n}\r\nnacl = lacl->se_lun_nacl;\r\nif (!nacl)\r\nreturn -EINVAL;\r\nif ((lun->lun_access & TRANSPORT_LUNFLAGS_READ_ONLY) &&\r\n(lun_access & TRANSPORT_LUNFLAGS_READ_WRITE))\r\nlun_access = TRANSPORT_LUNFLAGS_READ_ONLY;\r\nlacl->se_lun = lun;\r\nif (core_enable_device_list_for_node(lun, lacl, lacl->mapped_lun,\r\nlun_access, nacl, tpg) < 0)\r\nreturn -EINVAL;\r\nspin_lock(&lun->lun_acl_lock);\r\nlist_add_tail(&lacl->lacl_list, &lun->lun_acl_list);\r\natomic_inc(&lun->lun_acl_count);\r\nsmp_mb__after_atomic();\r\nspin_unlock(&lun->lun_acl_lock);\r\npr_debug("%s_TPG[%hu]_LUN[%u->%u] - Added %s ACL for "\r\n" InitiatorNode: %s\n", tpg->se_tpg_tfo->get_fabric_name(),\r\ntpg->se_tpg_tfo->tpg_get_tag(tpg), unpacked_lun, lacl->mapped_lun,\r\n(lun_access & TRANSPORT_LUNFLAGS_READ_WRITE) ? "RW" : "RO",\r\nlacl->initiatorname);\r\ncore_scsi3_check_aptpl_registration(lun->lun_se_dev, tpg, lun, lacl);\r\nreturn 0;\r\n}\r\nint core_dev_del_initiator_node_lun_acl(\r\nstruct se_portal_group *tpg,\r\nstruct se_lun *lun,\r\nstruct se_lun_acl *lacl)\r\n{\r\nstruct se_node_acl *nacl;\r\nnacl = lacl->se_lun_nacl;\r\nif (!nacl)\r\nreturn -EINVAL;\r\nspin_lock(&lun->lun_acl_lock);\r\nlist_del(&lacl->lacl_list);\r\natomic_dec(&lun->lun_acl_count);\r\nsmp_mb__after_atomic();\r\nspin_unlock(&lun->lun_acl_lock);\r\ncore_disable_device_list_for_node(lun, NULL, lacl->mapped_lun,\r\nTRANSPORT_LUNFLAGS_NO_ACCESS, nacl, tpg);\r\nlacl->se_lun = NULL;\r\npr_debug("%s_TPG[%hu]_LUN[%u] - Removed ACL for"\r\n" InitiatorNode: %s Mapped LUN: %u\n",\r\ntpg->se_tpg_tfo->get_fabric_name(),\r\ntpg->se_tpg_tfo->tpg_get_tag(tpg), lun->unpacked_lun,\r\nlacl->initiatorname, lacl->mapped_lun);\r\nreturn 0;\r\n}\r\nvoid core_dev_free_initiator_node_lun_acl(\r\nstruct se_portal_group *tpg,\r\nstruct se_lun_acl *lacl)\r\n{\r\npr_debug("%s_TPG[%hu] - Freeing ACL for %s InitiatorNode: %s"\r\n" Mapped LUN: %u\n", tpg->se_tpg_tfo->get_fabric_name(),\r\ntpg->se_tpg_tfo->tpg_get_tag(tpg),\r\ntpg->se_tpg_tfo->get_fabric_name(),\r\nlacl->initiatorname, lacl->mapped_lun);\r\nkfree(lacl);\r\n}\r\nstatic void scsi_dump_inquiry(struct se_device *dev)\r\n{\r\nstruct t10_wwn *wwn = &dev->t10_wwn;\r\nchar buf[17];\r\nint i, device_type;\r\nfor (i = 0; i < 8; i++)\r\nif (wwn->vendor[i] >= 0x20)\r\nbuf[i] = wwn->vendor[i];\r\nelse\r\nbuf[i] = ' ';\r\nbuf[i] = '\0';\r\npr_debug(" Vendor: %s\n", buf);\r\nfor (i = 0; i < 16; i++)\r\nif (wwn->model[i] >= 0x20)\r\nbuf[i] = wwn->model[i];\r\nelse\r\nbuf[i] = ' ';\r\nbuf[i] = '\0';\r\npr_debug(" Model: %s\n", buf);\r\nfor (i = 0; i < 4; i++)\r\nif (wwn->revision[i] >= 0x20)\r\nbuf[i] = wwn->revision[i];\r\nelse\r\nbuf[i] = ' ';\r\nbuf[i] = '\0';\r\npr_debug(" Revision: %s\n", buf);\r\ndevice_type = dev->transport->get_device_type(dev);\r\npr_debug(" Type: %s ", scsi_device_type(device_type));\r\n}\r\nstruct se_device *target_alloc_device(struct se_hba *hba, const char *name)\r\n{\r\nstruct se_device *dev;\r\nstruct se_lun *xcopy_lun;\r\ndev = hba->transport->alloc_device(hba, name);\r\nif (!dev)\r\nreturn NULL;\r\ndev->dev_link_magic = SE_DEV_LINK_MAGIC;\r\ndev->se_hba = hba;\r\ndev->transport = hba->transport;\r\ndev->prot_length = sizeof(struct se_dif_v1_tuple);\r\nINIT_LIST_HEAD(&dev->dev_list);\r\nINIT_LIST_HEAD(&dev->dev_sep_list);\r\nINIT_LIST_HEAD(&dev->dev_tmr_list);\r\nINIT_LIST_HEAD(&dev->delayed_cmd_list);\r\nINIT_LIST_HEAD(&dev->state_list);\r\nINIT_LIST_HEAD(&dev->qf_cmd_list);\r\nINIT_LIST_HEAD(&dev->g_dev_node);\r\nspin_lock_init(&dev->execute_task_lock);\r\nspin_lock_init(&dev->delayed_cmd_lock);\r\nspin_lock_init(&dev->dev_reservation_lock);\r\nspin_lock_init(&dev->se_port_lock);\r\nspin_lock_init(&dev->se_tmr_lock);\r\nspin_lock_init(&dev->qf_cmd_lock);\r\nsema_init(&dev->caw_sem, 1);\r\natomic_set(&dev->dev_ordered_id, 0);\r\nINIT_LIST_HEAD(&dev->t10_wwn.t10_vpd_list);\r\nspin_lock_init(&dev->t10_wwn.t10_vpd_lock);\r\nINIT_LIST_HEAD(&dev->t10_pr.registration_list);\r\nINIT_LIST_HEAD(&dev->t10_pr.aptpl_reg_list);\r\nspin_lock_init(&dev->t10_pr.registration_lock);\r\nspin_lock_init(&dev->t10_pr.aptpl_reg_lock);\r\nINIT_LIST_HEAD(&dev->t10_alua.tg_pt_gps_list);\r\nspin_lock_init(&dev->t10_alua.tg_pt_gps_lock);\r\nINIT_LIST_HEAD(&dev->t10_alua.lba_map_list);\r\nspin_lock_init(&dev->t10_alua.lba_map_lock);\r\ndev->t10_wwn.t10_dev = dev;\r\ndev->t10_alua.t10_dev = dev;\r\ndev->dev_attrib.da_dev = dev;\r\ndev->dev_attrib.emulate_model_alias = DA_EMULATE_MODEL_ALIAS;\r\ndev->dev_attrib.emulate_dpo = DA_EMULATE_DPO;\r\ndev->dev_attrib.emulate_fua_write = DA_EMULATE_FUA_WRITE;\r\ndev->dev_attrib.emulate_fua_read = DA_EMULATE_FUA_READ;\r\ndev->dev_attrib.emulate_write_cache = DA_EMULATE_WRITE_CACHE;\r\ndev->dev_attrib.emulate_ua_intlck_ctrl = DA_EMULATE_UA_INTLLCK_CTRL;\r\ndev->dev_attrib.emulate_tas = DA_EMULATE_TAS;\r\ndev->dev_attrib.emulate_tpu = DA_EMULATE_TPU;\r\ndev->dev_attrib.emulate_tpws = DA_EMULATE_TPWS;\r\ndev->dev_attrib.emulate_caw = DA_EMULATE_CAW;\r\ndev->dev_attrib.emulate_3pc = DA_EMULATE_3PC;\r\ndev->dev_attrib.pi_prot_type = TARGET_DIF_TYPE0_PROT;\r\ndev->dev_attrib.enforce_pr_isids = DA_ENFORCE_PR_ISIDS;\r\ndev->dev_attrib.is_nonrot = DA_IS_NONROT;\r\ndev->dev_attrib.emulate_rest_reord = DA_EMULATE_REST_REORD;\r\ndev->dev_attrib.max_unmap_lba_count = DA_MAX_UNMAP_LBA_COUNT;\r\ndev->dev_attrib.max_unmap_block_desc_count =\r\nDA_MAX_UNMAP_BLOCK_DESC_COUNT;\r\ndev->dev_attrib.unmap_granularity = DA_UNMAP_GRANULARITY_DEFAULT;\r\ndev->dev_attrib.unmap_granularity_alignment =\r\nDA_UNMAP_GRANULARITY_ALIGNMENT_DEFAULT;\r\ndev->dev_attrib.max_write_same_len = DA_MAX_WRITE_SAME_LEN;\r\ndev->dev_attrib.fabric_max_sectors = DA_FABRIC_MAX_SECTORS;\r\ndev->dev_attrib.optimal_sectors = DA_FABRIC_MAX_SECTORS;\r\nxcopy_lun = &dev->xcopy_lun;\r\nxcopy_lun->lun_se_dev = dev;\r\ninit_completion(&xcopy_lun->lun_shutdown_comp);\r\nINIT_LIST_HEAD(&xcopy_lun->lun_acl_list);\r\nspin_lock_init(&xcopy_lun->lun_acl_lock);\r\nspin_lock_init(&xcopy_lun->lun_sep_lock);\r\ninit_completion(&xcopy_lun->lun_ref_comp);\r\nreturn dev;\r\n}\r\nint target_configure_device(struct se_device *dev)\r\n{\r\nstruct se_hba *hba = dev->se_hba;\r\nint ret;\r\nif (dev->dev_flags & DF_CONFIGURED) {\r\npr_err("se_dev->se_dev_ptr already set for storage"\r\n" object\n");\r\nreturn -EEXIST;\r\n}\r\nret = dev->transport->configure_device(dev);\r\nif (ret)\r\ngoto out;\r\ndev->dev_flags |= DF_CONFIGURED;\r\ndev->dev_attrib.block_size = dev->dev_attrib.hw_block_size;\r\ndev->dev_attrib.queue_depth = dev->dev_attrib.hw_queue_depth;\r\ndev->dev_attrib.hw_max_sectors =\r\nse_dev_align_max_sectors(dev->dev_attrib.hw_max_sectors,\r\ndev->dev_attrib.hw_block_size);\r\ndev->dev_index = scsi_get_new_index(SCSI_DEVICE_INDEX);\r\ndev->creation_time = get_jiffies_64();\r\nret = core_setup_alua(dev);\r\nif (ret)\r\ngoto out;\r\ndev->tmr_wq = alloc_workqueue("tmr-%s", WQ_MEM_RECLAIM | WQ_UNBOUND, 1,\r\ndev->transport->name);\r\nif (!dev->tmr_wq) {\r\npr_err("Unable to create tmr workqueue for %s\n",\r\ndev->transport->name);\r\nret = -ENOMEM;\r\ngoto out_free_alua;\r\n}\r\nINIT_WORK(&dev->qf_work_queue, target_qf_do_work);\r\nif (dev->transport->transport_type != TRANSPORT_PLUGIN_PHBA_PDEV) {\r\nstrncpy(&dev->t10_wwn.vendor[0], "LIO-ORG", 8);\r\nstrncpy(&dev->t10_wwn.model[0],\r\ndev->transport->inquiry_prod, 16);\r\nstrncpy(&dev->t10_wwn.revision[0],\r\ndev->transport->inquiry_rev, 4);\r\n}\r\nscsi_dump_inquiry(dev);\r\nspin_lock(&hba->device_lock);\r\nhba->dev_count++;\r\nspin_unlock(&hba->device_lock);\r\nmutex_lock(&g_device_mutex);\r\nlist_add_tail(&dev->g_dev_node, &g_device_list);\r\nmutex_unlock(&g_device_mutex);\r\nreturn 0;\r\nout_free_alua:\r\ncore_alua_free_lu_gp_mem(dev);\r\nout:\r\nse_release_vpd_for_dev(dev);\r\nreturn ret;\r\n}\r\nvoid target_free_device(struct se_device *dev)\r\n{\r\nstruct se_hba *hba = dev->se_hba;\r\nWARN_ON(!list_empty(&dev->dev_sep_list));\r\nif (dev->dev_flags & DF_CONFIGURED) {\r\ndestroy_workqueue(dev->tmr_wq);\r\nmutex_lock(&g_device_mutex);\r\nlist_del(&dev->g_dev_node);\r\nmutex_unlock(&g_device_mutex);\r\nspin_lock(&hba->device_lock);\r\nhba->dev_count--;\r\nspin_unlock(&hba->device_lock);\r\n}\r\ncore_alua_free_lu_gp_mem(dev);\r\ncore_alua_set_lba_map(dev, NULL, 0, 0);\r\ncore_scsi3_free_all_registrations(dev);\r\nse_release_vpd_for_dev(dev);\r\nif (dev->transport->free_prot)\r\ndev->transport->free_prot(dev);\r\ndev->transport->free_device(dev);\r\n}\r\nint core_dev_setup_virtual_lun0(void)\r\n{\r\nstruct se_hba *hba;\r\nstruct se_device *dev;\r\nchar buf[] = "rd_pages=8,rd_nullio=1";\r\nint ret;\r\nhba = core_alloc_hba("rd_mcp", 0, HBA_FLAGS_INTERNAL_USE);\r\nif (IS_ERR(hba))\r\nreturn PTR_ERR(hba);\r\ndev = target_alloc_device(hba, "virt_lun0");\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto out_free_hba;\r\n}\r\nhba->transport->set_configfs_dev_params(dev, buf, sizeof(buf));\r\nret = target_configure_device(dev);\r\nif (ret)\r\ngoto out_free_se_dev;\r\nlun0_hba = hba;\r\ng_lun0_dev = dev;\r\nreturn 0;\r\nout_free_se_dev:\r\ntarget_free_device(dev);\r\nout_free_hba:\r\ncore_delete_hba(hba);\r\nreturn ret;\r\n}\r\nvoid core_dev_release_virtual_lun0(void)\r\n{\r\nstruct se_hba *hba = lun0_hba;\r\nif (!hba)\r\nreturn;\r\nif (g_lun0_dev)\r\ntarget_free_device(g_lun0_dev);\r\ncore_delete_hba(hba);\r\n}
