static inline unsigned int ioready(void)\r\n{\r\nreturn readl(bus_status) & 1;\r\n}\r\nstatic inline void wait_ioready(void)\r\n{\r\ndo { } while (!ioready());\r\n}\r\nstatic inline void wait_ioclear(void)\r\n{\r\ndo { } while (ioready());\r\n}\r\nstatic inline void check_ioclear(void)\r\n{\r\nif (ioready()) {\r\ndo {\r\n(void) readl(bus_xfer);\r\nDELAY();\r\n} while (ioready());\r\n}\r\n}\r\nstatic u32 pic32_bus_readl(u32 reg)\r\n{\r\nunsigned long flags;\r\nu32 status, val;\r\nspin_lock_irqsave(&pic32_bus_lock, flags);\r\ncheck_ioclear();\r\nwritel((0x01 << 24) | (reg & 0x00ffffff), bus_xfer);\r\nDELAY();\r\nwait_ioready();\r\nstatus = readl(bus_xfer);\r\nDELAY();\r\nval = readl(bus_xfer);\r\nwait_ioclear();\r\nspin_unlock_irqrestore(&pic32_bus_lock, flags);\r\nreturn val;\r\n}\r\nstatic void pic32_bus_writel(u32 val, u32 reg)\r\n{\r\nunsigned long flags;\r\nu32 status;\r\nspin_lock_irqsave(&pic32_bus_lock, flags);\r\ncheck_ioclear();\r\nwritel((0x10 << 24) | (reg & 0x00ffffff), bus_xfer);\r\nDELAY();\r\nwritel(val, bus_xfer);\r\nDELAY();\r\nwait_ioready();\r\nstatus = readl(bus_xfer);\r\nwait_ioclear();\r\nspin_unlock_irqrestore(&pic32_bus_lock, flags);\r\n}\r\nstatic inline void pic32_i2c_start(struct pic32_i2c_platform_data *adap)\r\n{\r\npic32_bus_writel(PIC32_I2CCON_SEN, adap->base + PIC32_I2CxCONSET);\r\n}\r\nstatic inline void pic32_i2c_stop(struct pic32_i2c_platform_data *adap)\r\n{\r\npic32_bus_writel(PIC32_I2CCON_PEN, adap->base + PIC32_I2CxCONSET);\r\n}\r\nstatic inline void pic32_i2c_ack(struct pic32_i2c_platform_data *adap)\r\n{\r\npic32_bus_writel(PIC32_I2CCON_ACKDT, adap->base + PIC32_I2CxCONCLR);\r\npic32_bus_writel(PIC32_I2CCON_ACKEN, adap->base + PIC32_I2CxCONSET);\r\n}\r\nstatic inline void pic32_i2c_nack(struct pic32_i2c_platform_data *adap)\r\n{\r\npic32_bus_writel(PIC32_I2CCON_ACKDT, adap->base + PIC32_I2CxCONSET);\r\npic32_bus_writel(PIC32_I2CCON_ACKEN, adap->base + PIC32_I2CxCONSET);\r\n}\r\nstatic inline int pic32_i2c_idle(struct pic32_i2c_platform_data *adap)\r\n{\r\nint i;\r\nfor (i = 0; i < adap->ctl_timeout; i++) {\r\nif (((pic32_bus_readl(adap->base + PIC32_I2CxCON) &\r\n(PIC32_I2CCON_ACKEN | PIC32_I2CCON_RCEN |\r\nPIC32_I2CCON_PEN | PIC32_I2CCON_RSEN |\r\nPIC32_I2CCON_SEN)) == 0) &&\r\n((pic32_bus_readl(adap->base + PIC32_I2CxSTAT) &\r\n(PIC32_I2CSTAT_TRSTAT)) == 0))\r\nreturn 0;\r\nudelay(1);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic inline u32 pic32_i2c_master_write(struct pic32_i2c_platform_data *adap,\r\nu32 byte)\r\n{\r\npic32_bus_writel(byte, adap->base + PIC32_I2CxTRN);\r\nreturn pic32_bus_readl(adap->base + PIC32_I2CxSTAT) &\r\nPIC32_I2CSTAT_IWCOL;\r\n}\r\nstatic inline u32 pic32_i2c_master_read(struct pic32_i2c_platform_data *adap)\r\n{\r\npic32_bus_writel(PIC32_I2CCON_RCEN, adap->base + PIC32_I2CxCONSET);\r\nwhile (pic32_bus_readl(adap->base + PIC32_I2CxCON) & PIC32_I2CCON_RCEN)\r\n;\r\npic32_bus_writel(PIC32_I2CSTAT_I2COV, adap->base + PIC32_I2CxSTATCLR);\r\nreturn pic32_bus_readl(adap->base + PIC32_I2CxRCV);\r\n}\r\nstatic int pic32_i2c_address(struct pic32_i2c_platform_data *adap,\r\nunsigned int addr, int rd)\r\n{\r\npic32_i2c_idle(adap);\r\npic32_i2c_start(adap);\r\npic32_i2c_idle(adap);\r\naddr <<= 1;\r\nif (rd)\r\naddr |= 1;\r\nif (pic32_i2c_master_write(adap, addr))\r\nreturn -EIO;\r\npic32_i2c_idle(adap);\r\nif (pic32_bus_readl(adap->base + PIC32_I2CxSTAT) &\r\nPIC32_I2CSTAT_ACKSTAT)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int sead3_i2c_read(struct pic32_i2c_platform_data *adap,\r\nunsigned char *buf, unsigned int len)\r\n{\r\nu32 data;\r\nint i;\r\ni = 0;\r\nwhile (i < len) {\r\ndata = pic32_i2c_master_read(adap);\r\nbuf[i++] = data;\r\nif (i < len)\r\npic32_i2c_ack(adap);\r\nelse\r\npic32_i2c_nack(adap);\r\n}\r\npic32_i2c_stop(adap);\r\npic32_i2c_idle(adap);\r\nreturn 0;\r\n}\r\nstatic int sead3_i2c_write(struct pic32_i2c_platform_data *adap,\r\nunsigned char *buf, unsigned int len)\r\n{\r\nint i;\r\nu32 data;\r\ni = 0;\r\nwhile (i < len) {\r\ndata = buf[i];\r\nif (pic32_i2c_master_write(adap, data))\r\nreturn -EIO;\r\npic32_i2c_idle(adap);\r\nif (pic32_bus_readl(adap->base + PIC32_I2CxSTAT) &\r\nPIC32_I2CSTAT_ACKSTAT)\r\nreturn -EIO;\r\ni++;\r\n}\r\npic32_i2c_stop(adap);\r\npic32_i2c_idle(adap);\r\nreturn 0;\r\n}\r\nstatic int sead3_pic32_platform_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct pic32_i2c_platform_data *adap = i2c_adap->algo_data;\r\nstruct i2c_msg *p;\r\nint i, err = 0;\r\nfor (i = 0; i < num; i++) {\r\n#define __BUFSIZE 80\r\nint ii;\r\nstatic char buf[__BUFSIZE];\r\nchar *b = buf;\r\np = &msgs[i];\r\nb += sprintf(buf, " [%d bytes]", p->len);\r\nif ((p->flags & I2C_M_RD) == 0) {\r\nfor (ii = 0; ii < p->len; ii++) {\r\nif (b < &buf[__BUFSIZE-4]) {\r\nb += sprintf(b, " %02x", p->buf[ii]);\r\n} else {\r\nstrcat(b, "...");\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nfor (i = 0; !err && i < num; i++) {\r\np = &msgs[i];\r\nerr = pic32_i2c_address(adap, p->addr, p->flags & I2C_M_RD);\r\nif (err || !p->len)\r\ncontinue;\r\nif (p->flags & I2C_M_RD)\r\nerr = sead3_i2c_read(adap, p->buf, p->len);\r\nelse\r\nerr = sead3_i2c_write(adap, p->buf, p->len);\r\n}\r\nif (err == 0)\r\nerr = num;\r\nreturn err;\r\n}\r\nstatic u32 sead3_pic32_platform_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic void sead3_i2c_platform_setup(struct pic32_i2c_platform_data *priv)\r\n{\r\npic32_bus_writel(500, priv->base + PIC32_I2CxBRG);\r\npic32_bus_writel(PIC32_I2CCON_ON, priv->base + PIC32_I2CxCONCLR);\r\npic32_bus_writel(PIC32_I2CCON_ON, priv->base + PIC32_I2CxCONSET);\r\npic32_bus_writel(PIC32_I2CSTAT_BCL | PIC32_I2CSTAT_IWCOL,\r\npriv->base + PIC32_I2CxSTATCLR);\r\n}\r\nstatic int sead3_i2c_platform_probe(struct platform_device *pdev)\r\n{\r\nstruct pic32_i2c_platform_data *priv;\r\nstruct resource *r;\r\nint ret;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\npriv = kzalloc(sizeof(struct pic32_i2c_platform_data), GFP_KERNEL);\r\nif (!priv) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\npriv->base = r->start;\r\nif (!priv->base) {\r\nret = -EBUSY;\r\ngoto out_mem;\r\n}\r\npriv->xfer_timeout = 200;\r\npriv->ack_timeout = 200;\r\npriv->ctl_timeout = 200;\r\npriv->adap.nr = pdev->id;\r\npriv->adap.algo = &sead3_platform_algo;\r\npriv->adap.algo_data = priv;\r\npriv->adap.dev.parent = &pdev->dev;\r\nstrlcpy(priv->adap.name, "SEAD3 PIC32", sizeof(priv->adap.name));\r\nsead3_i2c_platform_setup(priv);\r\nret = i2c_add_numbered_adapter(&priv->adap);\r\nif (ret == 0) {\r\nplatform_set_drvdata(pdev, priv);\r\nreturn 0;\r\n}\r\nout_mem:\r\nkfree(priv);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int sead3_i2c_platform_remove(struct platform_device *pdev)\r\n{\r\nstruct pic32_i2c_platform_data *priv = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\ni2c_del_adapter(&priv->adap);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int sead3_i2c_platform_suspend(struct platform_device *pdev,\r\npm_message_t state)\r\n{\r\ndev_dbg(&pdev->dev, "i2c_platform_disable\n");\r\nreturn 0;\r\n}\r\nstatic int sead3_i2c_platform_resume(struct platform_device *pdev)\r\n{\r\nstruct pic32_i2c_platform_data *priv = platform_get_drvdata(pdev);\r\ndev_dbg(&pdev->dev, "sead3_i2c_platform_setup\n");\r\nsead3_i2c_platform_setup(priv);\r\nreturn 0;\r\n}\r\nstatic int __init sead3_i2c_platform_init(void)\r\n{\r\nreturn platform_driver_register(&sead3_i2c_platform_driver);\r\n}\r\nstatic void __exit sead3_i2c_platform_exit(void)\r\n{\r\nplatform_driver_unregister(&sead3_i2c_platform_driver);\r\n}
