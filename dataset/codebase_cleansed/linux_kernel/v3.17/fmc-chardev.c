static int fc_open(struct inode *ino, struct file *f)\r\n{\r\nstruct fmc_device *fmc;\r\nstruct fc_instance *fc;\r\nint minor = iminor(ino);\r\nlist_for_each_entry(fc, &fc_devices, list)\r\nif (fc->misc.minor == minor)\r\nbreak;\r\nif (fc->misc.minor != minor)\r\nreturn -ENODEV;\r\nfmc = fc->fmc;\r\nif (try_module_get(fmc->owner) == 0)\r\nreturn -ENODEV;\r\nf->private_data = fmc;\r\nreturn 0;\r\n}\r\nstatic int fc_release(struct inode *ino, struct file *f)\r\n{\r\nstruct fmc_device *fmc = f->private_data;\r\nmodule_put(fmc->owner);\r\nreturn 0;\r\n}\r\nstatic ssize_t fc_read(struct file *f, char __user *buf, size_t count,\r\nloff_t *offp)\r\n{\r\nstruct fmc_device *fmc = f->private_data;\r\nunsigned long addr;\r\nuint32_t val;\r\nif (count < sizeof(val))\r\nreturn -EINVAL;\r\ncount = sizeof(val);\r\naddr = *offp;\r\nif (addr > fmc->memlen)\r\nreturn -ESPIPE;\r\nval = fmc_readl(fmc, addr);\r\nif (copy_to_user(buf, &val, count))\r\nreturn -EFAULT;\r\n*offp += count;\r\nreturn count;\r\n}\r\nstatic ssize_t fc_write(struct file *f, const char __user *buf, size_t count,\r\nloff_t *offp)\r\n{\r\nstruct fmc_device *fmc = f->private_data;\r\nunsigned long addr;\r\nuint32_t val;\r\nif (count < sizeof(val))\r\nreturn -EINVAL;\r\ncount = sizeof(val);\r\naddr = *offp;\r\nif (addr > fmc->memlen)\r\nreturn -ESPIPE;\r\nif (copy_from_user(&val, buf, count))\r\nreturn -EFAULT;\r\nfmc_writel(fmc, val, addr);\r\n*offp += count;\r\nreturn count;\r\n}\r\nstatic int fc_probe(struct fmc_device *fmc)\r\n{\r\nint ret;\r\nint index = 0;\r\nstruct fc_instance *fc;\r\nif (fmc->op->validate)\r\nindex = fmc->op->validate(fmc, &fc_drv);\r\nif (index < 0)\r\nreturn -EINVAL;\r\nfc = kzalloc(sizeof(*fc), GFP_KERNEL);\r\nif (!fc)\r\nreturn -ENOMEM;\r\nfc->fmc = fmc;\r\nfc->misc.minor = MISC_DYNAMIC_MINOR;\r\nfc->misc.fops = &fc_fops;\r\nfc->misc.name = kstrdup(dev_name(&fmc->dev), GFP_KERNEL);\r\nret = misc_register(&fc->misc);\r\nif (ret < 0)\r\ngoto out;\r\nspin_lock(&fc_lock);\r\nlist_add(&fc->list, &fc_devices);\r\nspin_unlock(&fc_lock);\r\ndev_info(&fc->fmc->dev, "Created misc device \"%s\"\n",\r\nfc->misc.name);\r\nreturn 0;\r\nout:\r\nkfree(fc->misc.name);\r\nkfree(fc);\r\nreturn ret;\r\n}\r\nstatic int fc_remove(struct fmc_device *fmc)\r\n{\r\nstruct fc_instance *fc;\r\nlist_for_each_entry(fc, &fc_devices, list)\r\nif (fc->fmc == fmc)\r\nbreak;\r\nif (fc->fmc != fmc) {\r\ndev_err(&fmc->dev, "remove called but not found\n");\r\nreturn -ENODEV;\r\n}\r\nspin_lock(&fc_lock);\r\nlist_del(&fc->list);\r\nspin_unlock(&fc_lock);\r\nmisc_deregister(&fc->misc);\r\nkfree(fc->misc.name);\r\nkfree(fc);\r\nreturn 0;\r\n}\r\nstatic int fc_init(void)\r\n{\r\nint ret;\r\nret = fmc_driver_register(&fc_drv);\r\nreturn ret;\r\n}\r\nstatic void fc_exit(void)\r\n{\r\nfmc_driver_unregister(&fc_drv);\r\n}
