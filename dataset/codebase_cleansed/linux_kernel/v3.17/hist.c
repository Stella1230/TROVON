u16 hists__col_len(struct hists *hists, enum hist_column col)\r\n{\r\nreturn hists->col_len[col];\r\n}\r\nvoid hists__set_col_len(struct hists *hists, enum hist_column col, u16 len)\r\n{\r\nhists->col_len[col] = len;\r\n}\r\nbool hists__new_col_len(struct hists *hists, enum hist_column col, u16 len)\r\n{\r\nif (len > hists__col_len(hists, col)) {\r\nhists__set_col_len(hists, col, len);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid hists__reset_col_len(struct hists *hists)\r\n{\r\nenum hist_column col;\r\nfor (col = 0; col < HISTC_NR_COLS; ++col)\r\nhists__set_col_len(hists, col, 0);\r\n}\r\nstatic void hists__set_unres_dso_col_len(struct hists *hists, int dso)\r\n{\r\nconst unsigned int unresolved_col_width = BITS_PER_LONG / 4;\r\nif (hists__col_len(hists, dso) < unresolved_col_width &&\r\n!symbol_conf.col_width_list_str && !symbol_conf.field_sep &&\r\n!symbol_conf.dso_list)\r\nhists__set_col_len(hists, dso, unresolved_col_width);\r\n}\r\nvoid hists__calc_col_len(struct hists *hists, struct hist_entry *h)\r\n{\r\nconst unsigned int unresolved_col_width = BITS_PER_LONG / 4;\r\nint symlen;\r\nu16 len;\r\nif (h->ms.sym) {\r\nsymlen = h->ms.sym->namelen + 4;\r\nif (verbose)\r\nsymlen += BITS_PER_LONG / 4 + 2 + 3;\r\nhists__new_col_len(hists, HISTC_SYMBOL, symlen);\r\n} else {\r\nsymlen = unresolved_col_width + 4 + 2;\r\nhists__new_col_len(hists, HISTC_SYMBOL, symlen);\r\nhists__set_unres_dso_col_len(hists, HISTC_DSO);\r\n}\r\nlen = thread__comm_len(h->thread);\r\nif (hists__new_col_len(hists, HISTC_COMM, len))\r\nhists__set_col_len(hists, HISTC_THREAD, len + 6);\r\nif (h->ms.map) {\r\nlen = dso__name_len(h->ms.map->dso);\r\nhists__new_col_len(hists, HISTC_DSO, len);\r\n}\r\nif (h->parent)\r\nhists__new_col_len(hists, HISTC_PARENT, h->parent->namelen);\r\nif (h->branch_info) {\r\nif (h->branch_info->from.sym) {\r\nsymlen = (int)h->branch_info->from.sym->namelen + 4;\r\nif (verbose)\r\nsymlen += BITS_PER_LONG / 4 + 2 + 3;\r\nhists__new_col_len(hists, HISTC_SYMBOL_FROM, symlen);\r\nsymlen = dso__name_len(h->branch_info->from.map->dso);\r\nhists__new_col_len(hists, HISTC_DSO_FROM, symlen);\r\n} else {\r\nsymlen = unresolved_col_width + 4 + 2;\r\nhists__new_col_len(hists, HISTC_SYMBOL_FROM, symlen);\r\nhists__set_unres_dso_col_len(hists, HISTC_DSO_FROM);\r\n}\r\nif (h->branch_info->to.sym) {\r\nsymlen = (int)h->branch_info->to.sym->namelen + 4;\r\nif (verbose)\r\nsymlen += BITS_PER_LONG / 4 + 2 + 3;\r\nhists__new_col_len(hists, HISTC_SYMBOL_TO, symlen);\r\nsymlen = dso__name_len(h->branch_info->to.map->dso);\r\nhists__new_col_len(hists, HISTC_DSO_TO, symlen);\r\n} else {\r\nsymlen = unresolved_col_width + 4 + 2;\r\nhists__new_col_len(hists, HISTC_SYMBOL_TO, symlen);\r\nhists__set_unres_dso_col_len(hists, HISTC_DSO_TO);\r\n}\r\n}\r\nif (h->mem_info) {\r\nif (h->mem_info->daddr.sym) {\r\nsymlen = (int)h->mem_info->daddr.sym->namelen + 4\r\n+ unresolved_col_width + 2;\r\nhists__new_col_len(hists, HISTC_MEM_DADDR_SYMBOL,\r\nsymlen);\r\nhists__new_col_len(hists, HISTC_MEM_DCACHELINE,\r\nsymlen + 1);\r\n} else {\r\nsymlen = unresolved_col_width + 4 + 2;\r\nhists__new_col_len(hists, HISTC_MEM_DADDR_SYMBOL,\r\nsymlen);\r\n}\r\nif (h->mem_info->daddr.map) {\r\nsymlen = dso__name_len(h->mem_info->daddr.map->dso);\r\nhists__new_col_len(hists, HISTC_MEM_DADDR_DSO,\r\nsymlen);\r\n} else {\r\nsymlen = unresolved_col_width + 4 + 2;\r\nhists__set_unres_dso_col_len(hists, HISTC_MEM_DADDR_DSO);\r\n}\r\n} else {\r\nsymlen = unresolved_col_width + 4 + 2;\r\nhists__new_col_len(hists, HISTC_MEM_DADDR_SYMBOL, symlen);\r\nhists__set_unres_dso_col_len(hists, HISTC_MEM_DADDR_DSO);\r\n}\r\nhists__new_col_len(hists, HISTC_MEM_LOCKED, 6);\r\nhists__new_col_len(hists, HISTC_MEM_TLB, 22);\r\nhists__new_col_len(hists, HISTC_MEM_SNOOP, 12);\r\nhists__new_col_len(hists, HISTC_MEM_LVL, 21 + 3);\r\nhists__new_col_len(hists, HISTC_LOCAL_WEIGHT, 12);\r\nhists__new_col_len(hists, HISTC_GLOBAL_WEIGHT, 12);\r\nif (h->transaction)\r\nhists__new_col_len(hists, HISTC_TRANSACTION,\r\nhist_entry__transaction_len());\r\n}\r\nvoid hists__output_recalc_col_len(struct hists *hists, int max_rows)\r\n{\r\nstruct rb_node *next = rb_first(&hists->entries);\r\nstruct hist_entry *n;\r\nint row = 0;\r\nhists__reset_col_len(hists);\r\nwhile (next && row++ < max_rows) {\r\nn = rb_entry(next, struct hist_entry, rb_node);\r\nif (!n->filtered)\r\nhists__calc_col_len(hists, n);\r\nnext = rb_next(&n->rb_node);\r\n}\r\n}\r\nstatic void he_stat__add_cpumode_period(struct he_stat *he_stat,\r\nunsigned int cpumode, u64 period)\r\n{\r\nswitch (cpumode) {\r\ncase PERF_RECORD_MISC_KERNEL:\r\nhe_stat->period_sys += period;\r\nbreak;\r\ncase PERF_RECORD_MISC_USER:\r\nhe_stat->period_us += period;\r\nbreak;\r\ncase PERF_RECORD_MISC_GUEST_KERNEL:\r\nhe_stat->period_guest_sys += period;\r\nbreak;\r\ncase PERF_RECORD_MISC_GUEST_USER:\r\nhe_stat->period_guest_us += period;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void he_stat__add_period(struct he_stat *he_stat, u64 period,\r\nu64 weight)\r\n{\r\nhe_stat->period += period;\r\nhe_stat->weight += weight;\r\nhe_stat->nr_events += 1;\r\n}\r\nstatic void he_stat__add_stat(struct he_stat *dest, struct he_stat *src)\r\n{\r\ndest->period += src->period;\r\ndest->period_sys += src->period_sys;\r\ndest->period_us += src->period_us;\r\ndest->period_guest_sys += src->period_guest_sys;\r\ndest->period_guest_us += src->period_guest_us;\r\ndest->nr_events += src->nr_events;\r\ndest->weight += src->weight;\r\n}\r\nstatic void he_stat__decay(struct he_stat *he_stat)\r\n{\r\nhe_stat->period = (he_stat->period * 7) / 8;\r\nhe_stat->nr_events = (he_stat->nr_events * 7) / 8;\r\n}\r\nstatic bool hists__decay_entry(struct hists *hists, struct hist_entry *he)\r\n{\r\nu64 prev_period = he->stat.period;\r\nu64 diff;\r\nif (prev_period == 0)\r\nreturn true;\r\nhe_stat__decay(&he->stat);\r\nif (symbol_conf.cumulate_callchain)\r\nhe_stat__decay(he->stat_acc);\r\ndiff = prev_period - he->stat.period;\r\nhists->stats.total_period -= diff;\r\nif (!he->filtered)\r\nhists->stats.total_non_filtered_period -= diff;\r\nreturn he->stat.period == 0;\r\n}\r\nvoid hists__decay_entries(struct hists *hists, bool zap_user, bool zap_kernel)\r\n{\r\nstruct rb_node *next = rb_first(&hists->entries);\r\nstruct hist_entry *n;\r\nwhile (next) {\r\nn = rb_entry(next, struct hist_entry, rb_node);\r\nnext = rb_next(&n->rb_node);\r\nif (((zap_user && n->level == '.') ||\r\n(zap_kernel && n->level != '.') ||\r\nhists__decay_entry(hists, n)) &&\r\n!n->used) {\r\nrb_erase(&n->rb_node, &hists->entries);\r\nif (sort__need_collapse)\r\nrb_erase(&n->rb_node_in, &hists->entries_collapsed);\r\n--hists->nr_entries;\r\nif (!n->filtered)\r\n--hists->nr_non_filtered_entries;\r\nhist_entry__free(n);\r\n}\r\n}\r\n}\r\nstatic struct hist_entry *hist_entry__new(struct hist_entry *template,\r\nbool sample_self)\r\n{\r\nsize_t callchain_size = 0;\r\nstruct hist_entry *he;\r\nif (symbol_conf.use_callchain || symbol_conf.cumulate_callchain)\r\ncallchain_size = sizeof(struct callchain_root);\r\nhe = zalloc(sizeof(*he) + callchain_size);\r\nif (he != NULL) {\r\n*he = *template;\r\nif (symbol_conf.cumulate_callchain) {\r\nhe->stat_acc = malloc(sizeof(he->stat));\r\nif (he->stat_acc == NULL) {\r\nfree(he);\r\nreturn NULL;\r\n}\r\nmemcpy(he->stat_acc, &he->stat, sizeof(he->stat));\r\nif (!sample_self)\r\nmemset(&he->stat, 0, sizeof(he->stat));\r\n}\r\nif (he->ms.map)\r\nhe->ms.map->referenced = true;\r\nif (he->branch_info) {\r\nhe->branch_info = malloc(sizeof(*he->branch_info));\r\nif (he->branch_info == NULL) {\r\nfree(he->stat_acc);\r\nfree(he);\r\nreturn NULL;\r\n}\r\nmemcpy(he->branch_info, template->branch_info,\r\nsizeof(*he->branch_info));\r\nif (he->branch_info->from.map)\r\nhe->branch_info->from.map->referenced = true;\r\nif (he->branch_info->to.map)\r\nhe->branch_info->to.map->referenced = true;\r\n}\r\nif (he->mem_info) {\r\nif (he->mem_info->iaddr.map)\r\nhe->mem_info->iaddr.map->referenced = true;\r\nif (he->mem_info->daddr.map)\r\nhe->mem_info->daddr.map->referenced = true;\r\n}\r\nif (symbol_conf.use_callchain)\r\ncallchain_init(he->callchain);\r\nINIT_LIST_HEAD(&he->pairs.node);\r\n}\r\nreturn he;\r\n}\r\nstatic u8 symbol__parent_filter(const struct symbol *parent)\r\n{\r\nif (symbol_conf.exclude_other && parent == NULL)\r\nreturn 1 << HIST_FILTER__PARENT;\r\nreturn 0;\r\n}\r\nstatic struct hist_entry *add_hist_entry(struct hists *hists,\r\nstruct hist_entry *entry,\r\nstruct addr_location *al,\r\nbool sample_self)\r\n{\r\nstruct rb_node **p;\r\nstruct rb_node *parent = NULL;\r\nstruct hist_entry *he;\r\nint64_t cmp;\r\nu64 period = entry->stat.period;\r\nu64 weight = entry->stat.weight;\r\np = &hists->entries_in->rb_node;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\nhe = rb_entry(parent, struct hist_entry, rb_node_in);\r\ncmp = hist_entry__cmp(he, entry);\r\nif (!cmp) {\r\nif (sample_self)\r\nhe_stat__add_period(&he->stat, period, weight);\r\nif (symbol_conf.cumulate_callchain)\r\nhe_stat__add_period(he->stat_acc, period, weight);\r\nzfree(&entry->mem_info);\r\nif (he->ms.map != entry->ms.map) {\r\nhe->ms.map = entry->ms.map;\r\nif (he->ms.map)\r\nhe->ms.map->referenced = true;\r\n}\r\ngoto out;\r\n}\r\nif (cmp < 0)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\nhe = hist_entry__new(entry, sample_self);\r\nif (!he)\r\nreturn NULL;\r\nrb_link_node(&he->rb_node_in, parent, p);\r\nrb_insert_color(&he->rb_node_in, hists->entries_in);\r\nout:\r\nif (sample_self)\r\nhe_stat__add_cpumode_period(&he->stat, al->cpumode, period);\r\nif (symbol_conf.cumulate_callchain)\r\nhe_stat__add_cpumode_period(he->stat_acc, al->cpumode, period);\r\nreturn he;\r\n}\r\nstruct hist_entry *__hists__add_entry(struct hists *hists,\r\nstruct addr_location *al,\r\nstruct symbol *sym_parent,\r\nstruct branch_info *bi,\r\nstruct mem_info *mi,\r\nu64 period, u64 weight, u64 transaction,\r\nbool sample_self)\r\n{\r\nstruct hist_entry entry = {\r\n.thread = al->thread,\r\n.comm = thread__comm(al->thread),\r\n.ms = {\r\n.map = al->map,\r\n.sym = al->sym,\r\n},\r\n.cpu = al->cpu,\r\n.cpumode = al->cpumode,\r\n.ip = al->addr,\r\n.level = al->level,\r\n.stat = {\r\n.nr_events = 1,\r\n.period = period,\r\n.weight = weight,\r\n},\r\n.parent = sym_parent,\r\n.filtered = symbol__parent_filter(sym_parent) | al->filtered,\r\n.hists = hists,\r\n.branch_info = bi,\r\n.mem_info = mi,\r\n.transaction = transaction,\r\n};\r\nreturn add_hist_entry(hists, &entry, al, sample_self);\r\n}\r\nstatic int\r\niter_next_nop_entry(struct hist_entry_iter *iter __maybe_unused,\r\nstruct addr_location *al __maybe_unused)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\niter_add_next_nop_entry(struct hist_entry_iter *iter __maybe_unused,\r\nstruct addr_location *al __maybe_unused)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\niter_prepare_mem_entry(struct hist_entry_iter *iter, struct addr_location *al)\r\n{\r\nstruct perf_sample *sample = iter->sample;\r\nstruct mem_info *mi;\r\nmi = sample__resolve_mem(sample, al);\r\nif (mi == NULL)\r\nreturn -ENOMEM;\r\niter->priv = mi;\r\nreturn 0;\r\n}\r\nstatic int\r\niter_add_single_mem_entry(struct hist_entry_iter *iter, struct addr_location *al)\r\n{\r\nu64 cost;\r\nstruct mem_info *mi = iter->priv;\r\nstruct hist_entry *he;\r\nif (mi == NULL)\r\nreturn -EINVAL;\r\ncost = iter->sample->weight;\r\nif (!cost)\r\ncost = 1;\r\nhe = __hists__add_entry(&iter->evsel->hists, al, iter->parent, NULL, mi,\r\ncost, cost, 0, true);\r\nif (!he)\r\nreturn -ENOMEM;\r\niter->he = he;\r\nreturn 0;\r\n}\r\nstatic int\r\niter_finish_mem_entry(struct hist_entry_iter *iter,\r\nstruct addr_location *al __maybe_unused)\r\n{\r\nstruct perf_evsel *evsel = iter->evsel;\r\nstruct hist_entry *he = iter->he;\r\nint err = -EINVAL;\r\nif (he == NULL)\r\ngoto out;\r\nhists__inc_nr_samples(&evsel->hists, he->filtered);\r\nerr = hist_entry__append_callchain(he, iter->sample);\r\nout:\r\niter->priv = NULL;\r\niter->he = NULL;\r\nreturn err;\r\n}\r\nstatic int\r\niter_prepare_branch_entry(struct hist_entry_iter *iter, struct addr_location *al)\r\n{\r\nstruct branch_info *bi;\r\nstruct perf_sample *sample = iter->sample;\r\nbi = sample__resolve_bstack(sample, al);\r\nif (!bi)\r\nreturn -ENOMEM;\r\niter->curr = 0;\r\niter->total = sample->branch_stack->nr;\r\niter->priv = bi;\r\nreturn 0;\r\n}\r\nstatic int\r\niter_add_single_branch_entry(struct hist_entry_iter *iter __maybe_unused,\r\nstruct addr_location *al __maybe_unused)\r\n{\r\niter->he = NULL;\r\nreturn 0;\r\n}\r\nstatic int\r\niter_next_branch_entry(struct hist_entry_iter *iter, struct addr_location *al)\r\n{\r\nstruct branch_info *bi = iter->priv;\r\nint i = iter->curr;\r\nif (bi == NULL)\r\nreturn 0;\r\nif (iter->curr >= iter->total)\r\nreturn 0;\r\nal->map = bi[i].to.map;\r\nal->sym = bi[i].to.sym;\r\nal->addr = bi[i].to.addr;\r\nreturn 1;\r\n}\r\nstatic int\r\niter_add_next_branch_entry(struct hist_entry_iter *iter, struct addr_location *al)\r\n{\r\nstruct branch_info *bi;\r\nstruct perf_evsel *evsel = iter->evsel;\r\nstruct hist_entry *he = NULL;\r\nint i = iter->curr;\r\nint err = 0;\r\nbi = iter->priv;\r\nif (iter->hide_unresolved && !(bi[i].from.sym && bi[i].to.sym))\r\ngoto out;\r\nhe = __hists__add_entry(&evsel->hists, al, iter->parent, &bi[i], NULL,\r\n1, 1, 0, true);\r\nif (he == NULL)\r\nreturn -ENOMEM;\r\nhists__inc_nr_samples(&evsel->hists, he->filtered);\r\nout:\r\niter->he = he;\r\niter->curr++;\r\nreturn err;\r\n}\r\nstatic int\r\niter_finish_branch_entry(struct hist_entry_iter *iter,\r\nstruct addr_location *al __maybe_unused)\r\n{\r\nzfree(&iter->priv);\r\niter->he = NULL;\r\nreturn iter->curr >= iter->total ? 0 : -1;\r\n}\r\nstatic int\r\niter_prepare_normal_entry(struct hist_entry_iter *iter __maybe_unused,\r\nstruct addr_location *al __maybe_unused)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\niter_add_single_normal_entry(struct hist_entry_iter *iter, struct addr_location *al)\r\n{\r\nstruct perf_evsel *evsel = iter->evsel;\r\nstruct perf_sample *sample = iter->sample;\r\nstruct hist_entry *he;\r\nhe = __hists__add_entry(&evsel->hists, al, iter->parent, NULL, NULL,\r\nsample->period, sample->weight,\r\nsample->transaction, true);\r\nif (he == NULL)\r\nreturn -ENOMEM;\r\niter->he = he;\r\nreturn 0;\r\n}\r\nstatic int\r\niter_finish_normal_entry(struct hist_entry_iter *iter,\r\nstruct addr_location *al __maybe_unused)\r\n{\r\nstruct hist_entry *he = iter->he;\r\nstruct perf_evsel *evsel = iter->evsel;\r\nstruct perf_sample *sample = iter->sample;\r\nif (he == NULL)\r\nreturn 0;\r\niter->he = NULL;\r\nhists__inc_nr_samples(&evsel->hists, he->filtered);\r\nreturn hist_entry__append_callchain(he, sample);\r\n}\r\nstatic int\r\niter_prepare_cumulative_entry(struct hist_entry_iter *iter __maybe_unused,\r\nstruct addr_location *al __maybe_unused)\r\n{\r\nstruct hist_entry **he_cache;\r\ncallchain_cursor_commit(&callchain_cursor);\r\nhe_cache = malloc(sizeof(*he_cache) * (PERF_MAX_STACK_DEPTH + 1));\r\nif (he_cache == NULL)\r\nreturn -ENOMEM;\r\niter->priv = he_cache;\r\niter->curr = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\niter_add_single_cumulative_entry(struct hist_entry_iter *iter,\r\nstruct addr_location *al)\r\n{\r\nstruct perf_evsel *evsel = iter->evsel;\r\nstruct perf_sample *sample = iter->sample;\r\nstruct hist_entry **he_cache = iter->priv;\r\nstruct hist_entry *he;\r\nint err = 0;\r\nhe = __hists__add_entry(&evsel->hists, al, iter->parent, NULL, NULL,\r\nsample->period, sample->weight,\r\nsample->transaction, true);\r\nif (he == NULL)\r\nreturn -ENOMEM;\r\niter->he = he;\r\nhe_cache[iter->curr++] = he;\r\ncallchain_append(he->callchain, &callchain_cursor, sample->period);\r\ncallchain_cursor_commit(&callchain_cursor);\r\nhists__inc_nr_samples(&evsel->hists, he->filtered);\r\nreturn err;\r\n}\r\nstatic int\r\niter_next_cumulative_entry(struct hist_entry_iter *iter,\r\nstruct addr_location *al)\r\n{\r\nstruct callchain_cursor_node *node;\r\nnode = callchain_cursor_current(&callchain_cursor);\r\nif (node == NULL)\r\nreturn 0;\r\nreturn fill_callchain_info(al, node, iter->hide_unresolved);\r\n}\r\nstatic int\r\niter_add_next_cumulative_entry(struct hist_entry_iter *iter,\r\nstruct addr_location *al)\r\n{\r\nstruct perf_evsel *evsel = iter->evsel;\r\nstruct perf_sample *sample = iter->sample;\r\nstruct hist_entry **he_cache = iter->priv;\r\nstruct hist_entry *he;\r\nstruct hist_entry he_tmp = {\r\n.cpu = al->cpu,\r\n.thread = al->thread,\r\n.comm = thread__comm(al->thread),\r\n.ip = al->addr,\r\n.ms = {\r\n.map = al->map,\r\n.sym = al->sym,\r\n},\r\n.parent = iter->parent,\r\n};\r\nint i;\r\nstruct callchain_cursor cursor;\r\ncallchain_cursor_snapshot(&cursor, &callchain_cursor);\r\ncallchain_cursor_advance(&callchain_cursor);\r\nfor (i = 0; i < iter->curr; i++) {\r\nif (hist_entry__cmp(he_cache[i], &he_tmp) == 0) {\r\niter->he = NULL;\r\nreturn 0;\r\n}\r\n}\r\nhe = __hists__add_entry(&evsel->hists, al, iter->parent, NULL, NULL,\r\nsample->period, sample->weight,\r\nsample->transaction, false);\r\nif (he == NULL)\r\nreturn -ENOMEM;\r\niter->he = he;\r\nhe_cache[iter->curr++] = he;\r\ncallchain_append(he->callchain, &cursor, sample->period);\r\nreturn 0;\r\n}\r\nstatic int\r\niter_finish_cumulative_entry(struct hist_entry_iter *iter,\r\nstruct addr_location *al __maybe_unused)\r\n{\r\nzfree(&iter->priv);\r\niter->he = NULL;\r\nreturn 0;\r\n}\r\nint hist_entry_iter__add(struct hist_entry_iter *iter, struct addr_location *al,\r\nstruct perf_evsel *evsel, struct perf_sample *sample,\r\nint max_stack_depth, void *arg)\r\n{\r\nint err, err2;\r\nerr = sample__resolve_callchain(sample, &iter->parent, evsel, al,\r\nmax_stack_depth);\r\nif (err)\r\nreturn err;\r\niter->evsel = evsel;\r\niter->sample = sample;\r\nerr = iter->ops->prepare_entry(iter, al);\r\nif (err)\r\ngoto out;\r\nerr = iter->ops->add_single_entry(iter, al);\r\nif (err)\r\ngoto out;\r\nif (iter->he && iter->add_entry_cb) {\r\nerr = iter->add_entry_cb(iter, al, true, arg);\r\nif (err)\r\ngoto out;\r\n}\r\nwhile (iter->ops->next_entry(iter, al)) {\r\nerr = iter->ops->add_next_entry(iter, al);\r\nif (err)\r\nbreak;\r\nif (iter->he && iter->add_entry_cb) {\r\nerr = iter->add_entry_cb(iter, al, false, arg);\r\nif (err)\r\ngoto out;\r\n}\r\n}\r\nout:\r\nerr2 = iter->ops->finish_entry(iter, al);\r\nif (!err)\r\nerr = err2;\r\nreturn err;\r\n}\r\nint64_t\r\nhist_entry__cmp(struct hist_entry *left, struct hist_entry *right)\r\n{\r\nstruct perf_hpp_fmt *fmt;\r\nint64_t cmp = 0;\r\nperf_hpp__for_each_sort_list(fmt) {\r\nif (perf_hpp__should_skip(fmt))\r\ncontinue;\r\ncmp = fmt->cmp(left, right);\r\nif (cmp)\r\nbreak;\r\n}\r\nreturn cmp;\r\n}\r\nint64_t\r\nhist_entry__collapse(struct hist_entry *left, struct hist_entry *right)\r\n{\r\nstruct perf_hpp_fmt *fmt;\r\nint64_t cmp = 0;\r\nperf_hpp__for_each_sort_list(fmt) {\r\nif (perf_hpp__should_skip(fmt))\r\ncontinue;\r\ncmp = fmt->collapse(left, right);\r\nif (cmp)\r\nbreak;\r\n}\r\nreturn cmp;\r\n}\r\nvoid hist_entry__free(struct hist_entry *he)\r\n{\r\nzfree(&he->branch_info);\r\nzfree(&he->mem_info);\r\nzfree(&he->stat_acc);\r\nfree_srcline(he->srcline);\r\nfree(he);\r\n}\r\nstatic bool hists__collapse_insert_entry(struct hists *hists __maybe_unused,\r\nstruct rb_root *root,\r\nstruct hist_entry *he)\r\n{\r\nstruct rb_node **p = &root->rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct hist_entry *iter;\r\nint64_t cmp;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\niter = rb_entry(parent, struct hist_entry, rb_node_in);\r\ncmp = hist_entry__collapse(iter, he);\r\nif (!cmp) {\r\nhe_stat__add_stat(&iter->stat, &he->stat);\r\nif (symbol_conf.cumulate_callchain)\r\nhe_stat__add_stat(iter->stat_acc, he->stat_acc);\r\nif (symbol_conf.use_callchain) {\r\ncallchain_cursor_reset(&callchain_cursor);\r\ncallchain_merge(&callchain_cursor,\r\niter->callchain,\r\nhe->callchain);\r\n}\r\nhist_entry__free(he);\r\nreturn false;\r\n}\r\nif (cmp < 0)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\nrb_link_node(&he->rb_node_in, parent, p);\r\nrb_insert_color(&he->rb_node_in, root);\r\nreturn true;\r\n}\r\nstatic struct rb_root *hists__get_rotate_entries_in(struct hists *hists)\r\n{\r\nstruct rb_root *root;\r\npthread_mutex_lock(&hists->lock);\r\nroot = hists->entries_in;\r\nif (++hists->entries_in > &hists->entries_in_array[1])\r\nhists->entries_in = &hists->entries_in_array[0];\r\npthread_mutex_unlock(&hists->lock);\r\nreturn root;\r\n}\r\nstatic void hists__apply_filters(struct hists *hists, struct hist_entry *he)\r\n{\r\nhists__filter_entry_by_dso(hists, he);\r\nhists__filter_entry_by_thread(hists, he);\r\nhists__filter_entry_by_symbol(hists, he);\r\n}\r\nvoid hists__collapse_resort(struct hists *hists, struct ui_progress *prog)\r\n{\r\nstruct rb_root *root;\r\nstruct rb_node *next;\r\nstruct hist_entry *n;\r\nif (!sort__need_collapse)\r\nreturn;\r\nroot = hists__get_rotate_entries_in(hists);\r\nnext = rb_first(root);\r\nwhile (next) {\r\nif (session_done())\r\nbreak;\r\nn = rb_entry(next, struct hist_entry, rb_node_in);\r\nnext = rb_next(&n->rb_node_in);\r\nrb_erase(&n->rb_node_in, root);\r\nif (hists__collapse_insert_entry(hists, &hists->entries_collapsed, n)) {\r\nhists__apply_filters(hists, n);\r\n}\r\nif (prog)\r\nui_progress__update(prog, 1);\r\n}\r\n}\r\nstatic int hist_entry__sort(struct hist_entry *a, struct hist_entry *b)\r\n{\r\nstruct perf_hpp_fmt *fmt;\r\nint64_t cmp = 0;\r\nperf_hpp__for_each_sort_list(fmt) {\r\nif (perf_hpp__should_skip(fmt))\r\ncontinue;\r\ncmp = fmt->sort(a, b);\r\nif (cmp)\r\nbreak;\r\n}\r\nreturn cmp;\r\n}\r\nstatic void hists__reset_filter_stats(struct hists *hists)\r\n{\r\nhists->nr_non_filtered_entries = 0;\r\nhists->stats.total_non_filtered_period = 0;\r\n}\r\nvoid hists__reset_stats(struct hists *hists)\r\n{\r\nhists->nr_entries = 0;\r\nhists->stats.total_period = 0;\r\nhists__reset_filter_stats(hists);\r\n}\r\nstatic void hists__inc_filter_stats(struct hists *hists, struct hist_entry *h)\r\n{\r\nhists->nr_non_filtered_entries++;\r\nhists->stats.total_non_filtered_period += h->stat.period;\r\n}\r\nvoid hists__inc_stats(struct hists *hists, struct hist_entry *h)\r\n{\r\nif (!h->filtered)\r\nhists__inc_filter_stats(hists, h);\r\nhists->nr_entries++;\r\nhists->stats.total_period += h->stat.period;\r\n}\r\nstatic void __hists__insert_output_entry(struct rb_root *entries,\r\nstruct hist_entry *he,\r\nu64 min_callchain_hits)\r\n{\r\nstruct rb_node **p = &entries->rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct hist_entry *iter;\r\nif (symbol_conf.use_callchain)\r\ncallchain_param.sort(&he->sorted_chain, he->callchain,\r\nmin_callchain_hits, &callchain_param);\r\nwhile (*p != NULL) {\r\nparent = *p;\r\niter = rb_entry(parent, struct hist_entry, rb_node);\r\nif (hist_entry__sort(he, iter) > 0)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\nrb_link_node(&he->rb_node, parent, p);\r\nrb_insert_color(&he->rb_node, entries);\r\n}\r\nvoid hists__output_resort(struct hists *hists)\r\n{\r\nstruct rb_root *root;\r\nstruct rb_node *next;\r\nstruct hist_entry *n;\r\nu64 min_callchain_hits;\r\nmin_callchain_hits = hists->stats.total_period * (callchain_param.min_percent / 100);\r\nif (sort__need_collapse)\r\nroot = &hists->entries_collapsed;\r\nelse\r\nroot = hists->entries_in;\r\nnext = rb_first(root);\r\nhists->entries = RB_ROOT;\r\nhists__reset_stats(hists);\r\nhists__reset_col_len(hists);\r\nwhile (next) {\r\nn = rb_entry(next, struct hist_entry, rb_node_in);\r\nnext = rb_next(&n->rb_node_in);\r\n__hists__insert_output_entry(&hists->entries, n, min_callchain_hits);\r\nhists__inc_stats(hists, n);\r\nif (!n->filtered)\r\nhists__calc_col_len(hists, n);\r\n}\r\n}\r\nstatic void hists__remove_entry_filter(struct hists *hists, struct hist_entry *h,\r\nenum hist_filter filter)\r\n{\r\nh->filtered &= ~(1 << filter);\r\nif (h->filtered)\r\nreturn;\r\nh->ms.unfolded = false;\r\nh->row_offset = 0;\r\nhists->stats.nr_non_filtered_samples += h->stat.nr_events;\r\nhists__inc_filter_stats(hists, h);\r\nhists__calc_col_len(hists, h);\r\n}\r\nstatic bool hists__filter_entry_by_dso(struct hists *hists,\r\nstruct hist_entry *he)\r\n{\r\nif (hists->dso_filter != NULL &&\r\n(he->ms.map == NULL || he->ms.map->dso != hists->dso_filter)) {\r\nhe->filtered |= (1 << HIST_FILTER__DSO);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid hists__filter_by_dso(struct hists *hists)\r\n{\r\nstruct rb_node *nd;\r\nhists->stats.nr_non_filtered_samples = 0;\r\nhists__reset_filter_stats(hists);\r\nhists__reset_col_len(hists);\r\nfor (nd = rb_first(&hists->entries); nd; nd = rb_next(nd)) {\r\nstruct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);\r\nif (symbol_conf.exclude_other && !h->parent)\r\ncontinue;\r\nif (hists__filter_entry_by_dso(hists, h))\r\ncontinue;\r\nhists__remove_entry_filter(hists, h, HIST_FILTER__DSO);\r\n}\r\n}\r\nstatic bool hists__filter_entry_by_thread(struct hists *hists,\r\nstruct hist_entry *he)\r\n{\r\nif (hists->thread_filter != NULL &&\r\nhe->thread != hists->thread_filter) {\r\nhe->filtered |= (1 << HIST_FILTER__THREAD);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid hists__filter_by_thread(struct hists *hists)\r\n{\r\nstruct rb_node *nd;\r\nhists->stats.nr_non_filtered_samples = 0;\r\nhists__reset_filter_stats(hists);\r\nhists__reset_col_len(hists);\r\nfor (nd = rb_first(&hists->entries); nd; nd = rb_next(nd)) {\r\nstruct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);\r\nif (hists__filter_entry_by_thread(hists, h))\r\ncontinue;\r\nhists__remove_entry_filter(hists, h, HIST_FILTER__THREAD);\r\n}\r\n}\r\nstatic bool hists__filter_entry_by_symbol(struct hists *hists,\r\nstruct hist_entry *he)\r\n{\r\nif (hists->symbol_filter_str != NULL &&\r\n(!he->ms.sym || strstr(he->ms.sym->name,\r\nhists->symbol_filter_str) == NULL)) {\r\nhe->filtered |= (1 << HIST_FILTER__SYMBOL);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid hists__filter_by_symbol(struct hists *hists)\r\n{\r\nstruct rb_node *nd;\r\nhists->stats.nr_non_filtered_samples = 0;\r\nhists__reset_filter_stats(hists);\r\nhists__reset_col_len(hists);\r\nfor (nd = rb_first(&hists->entries); nd; nd = rb_next(nd)) {\r\nstruct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);\r\nif (hists__filter_entry_by_symbol(hists, h))\r\ncontinue;\r\nhists__remove_entry_filter(hists, h, HIST_FILTER__SYMBOL);\r\n}\r\n}\r\nvoid events_stats__inc(struct events_stats *stats, u32 type)\r\n{\r\n++stats->nr_events[0];\r\n++stats->nr_events[type];\r\n}\r\nvoid hists__inc_nr_events(struct hists *hists, u32 type)\r\n{\r\nevents_stats__inc(&hists->stats, type);\r\n}\r\nvoid hists__inc_nr_samples(struct hists *hists, bool filtered)\r\n{\r\nevents_stats__inc(&hists->stats, PERF_RECORD_SAMPLE);\r\nif (!filtered)\r\nhists->stats.nr_non_filtered_samples++;\r\n}\r\nstatic struct hist_entry *hists__add_dummy_entry(struct hists *hists,\r\nstruct hist_entry *pair)\r\n{\r\nstruct rb_root *root;\r\nstruct rb_node **p;\r\nstruct rb_node *parent = NULL;\r\nstruct hist_entry *he;\r\nint64_t cmp;\r\nif (sort__need_collapse)\r\nroot = &hists->entries_collapsed;\r\nelse\r\nroot = hists->entries_in;\r\np = &root->rb_node;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\nhe = rb_entry(parent, struct hist_entry, rb_node_in);\r\ncmp = hist_entry__collapse(he, pair);\r\nif (!cmp)\r\ngoto out;\r\nif (cmp < 0)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\nhe = hist_entry__new(pair, true);\r\nif (he) {\r\nmemset(&he->stat, 0, sizeof(he->stat));\r\nhe->hists = hists;\r\nrb_link_node(&he->rb_node_in, parent, p);\r\nrb_insert_color(&he->rb_node_in, root);\r\nhists__inc_stats(hists, he);\r\nhe->dummy = true;\r\n}\r\nout:\r\nreturn he;\r\n}\r\nstatic struct hist_entry *hists__find_entry(struct hists *hists,\r\nstruct hist_entry *he)\r\n{\r\nstruct rb_node *n;\r\nif (sort__need_collapse)\r\nn = hists->entries_collapsed.rb_node;\r\nelse\r\nn = hists->entries_in->rb_node;\r\nwhile (n) {\r\nstruct hist_entry *iter = rb_entry(n, struct hist_entry, rb_node_in);\r\nint64_t cmp = hist_entry__collapse(iter, he);\r\nif (cmp < 0)\r\nn = n->rb_left;\r\nelse if (cmp > 0)\r\nn = n->rb_right;\r\nelse\r\nreturn iter;\r\n}\r\nreturn NULL;\r\n}\r\nvoid hists__match(struct hists *leader, struct hists *other)\r\n{\r\nstruct rb_root *root;\r\nstruct rb_node *nd;\r\nstruct hist_entry *pos, *pair;\r\nif (sort__need_collapse)\r\nroot = &leader->entries_collapsed;\r\nelse\r\nroot = leader->entries_in;\r\nfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\r\npos = rb_entry(nd, struct hist_entry, rb_node_in);\r\npair = hists__find_entry(other, pos);\r\nif (pair)\r\nhist_entry__add_pair(pair, pos);\r\n}\r\n}\r\nint hists__link(struct hists *leader, struct hists *other)\r\n{\r\nstruct rb_root *root;\r\nstruct rb_node *nd;\r\nstruct hist_entry *pos, *pair;\r\nif (sort__need_collapse)\r\nroot = &other->entries_collapsed;\r\nelse\r\nroot = other->entries_in;\r\nfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\r\npos = rb_entry(nd, struct hist_entry, rb_node_in);\r\nif (!hist_entry__has_pairs(pos)) {\r\npair = hists__add_dummy_entry(leader, pos);\r\nif (pair == NULL)\r\nreturn -1;\r\nhist_entry__add_pair(pos, pair);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nu64 hists__total_period(struct hists *hists)\r\n{\r\nreturn symbol_conf.filter_relative ? hists->stats.total_non_filtered_period :\r\nhists->stats.total_period;\r\n}\r\nint parse_filter_percentage(const struct option *opt __maybe_unused,\r\nconst char *arg, int unset __maybe_unused)\r\n{\r\nif (!strcmp(arg, "relative"))\r\nsymbol_conf.filter_relative = true;\r\nelse if (!strcmp(arg, "absolute"))\r\nsymbol_conf.filter_relative = false;\r\nelse\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint perf_hist_config(const char *var, const char *value)\r\n{\r\nif (!strcmp(var, "hist.percentage"))\r\nreturn parse_filter_percentage(NULL, value, 0);\r\nreturn 0;\r\n}
