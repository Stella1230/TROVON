static inline unsigned int xfrm_dst_hash(struct net *net,\r\nconst xfrm_address_t *daddr,\r\nconst xfrm_address_t *saddr,\r\nu32 reqid,\r\nunsigned short family)\r\n{\r\nreturn __xfrm_dst_hash(daddr, saddr, reqid, family, net->xfrm.state_hmask);\r\n}\r\nstatic inline unsigned int xfrm_src_hash(struct net *net,\r\nconst xfrm_address_t *daddr,\r\nconst xfrm_address_t *saddr,\r\nunsigned short family)\r\n{\r\nreturn __xfrm_src_hash(daddr, saddr, family, net->xfrm.state_hmask);\r\n}\r\nstatic inline unsigned int\r\nxfrm_spi_hash(struct net *net, const xfrm_address_t *daddr,\r\n__be32 spi, u8 proto, unsigned short family)\r\n{\r\nreturn __xfrm_spi_hash(daddr, spi, proto, family, net->xfrm.state_hmask);\r\n}\r\nstatic void xfrm_hash_transfer(struct hlist_head *list,\r\nstruct hlist_head *ndsttable,\r\nstruct hlist_head *nsrctable,\r\nstruct hlist_head *nspitable,\r\nunsigned int nhashmask)\r\n{\r\nstruct hlist_node *tmp;\r\nstruct xfrm_state *x;\r\nhlist_for_each_entry_safe(x, tmp, list, bydst) {\r\nunsigned int h;\r\nh = __xfrm_dst_hash(&x->id.daddr, &x->props.saddr,\r\nx->props.reqid, x->props.family,\r\nnhashmask);\r\nhlist_add_head(&x->bydst, ndsttable+h);\r\nh = __xfrm_src_hash(&x->id.daddr, &x->props.saddr,\r\nx->props.family,\r\nnhashmask);\r\nhlist_add_head(&x->bysrc, nsrctable+h);\r\nif (x->id.spi) {\r\nh = __xfrm_spi_hash(&x->id.daddr, x->id.spi,\r\nx->id.proto, x->props.family,\r\nnhashmask);\r\nhlist_add_head(&x->byspi, nspitable+h);\r\n}\r\n}\r\n}\r\nstatic unsigned long xfrm_hash_new_size(unsigned int state_hmask)\r\n{\r\nreturn ((state_hmask + 1) << 1) * sizeof(struct hlist_head);\r\n}\r\nstatic void xfrm_hash_resize(struct work_struct *work)\r\n{\r\nstruct net *net = container_of(work, struct net, xfrm.state_hash_work);\r\nstruct hlist_head *ndst, *nsrc, *nspi, *odst, *osrc, *ospi;\r\nunsigned long nsize, osize;\r\nunsigned int nhashmask, ohashmask;\r\nint i;\r\nmutex_lock(&hash_resize_mutex);\r\nnsize = xfrm_hash_new_size(net->xfrm.state_hmask);\r\nndst = xfrm_hash_alloc(nsize);\r\nif (!ndst)\r\ngoto out_unlock;\r\nnsrc = xfrm_hash_alloc(nsize);\r\nif (!nsrc) {\r\nxfrm_hash_free(ndst, nsize);\r\ngoto out_unlock;\r\n}\r\nnspi = xfrm_hash_alloc(nsize);\r\nif (!nspi) {\r\nxfrm_hash_free(ndst, nsize);\r\nxfrm_hash_free(nsrc, nsize);\r\ngoto out_unlock;\r\n}\r\nspin_lock_bh(&net->xfrm.xfrm_state_lock);\r\nnhashmask = (nsize / sizeof(struct hlist_head)) - 1U;\r\nfor (i = net->xfrm.state_hmask; i >= 0; i--)\r\nxfrm_hash_transfer(net->xfrm.state_bydst+i, ndst, nsrc, nspi,\r\nnhashmask);\r\nodst = net->xfrm.state_bydst;\r\nosrc = net->xfrm.state_bysrc;\r\nospi = net->xfrm.state_byspi;\r\nohashmask = net->xfrm.state_hmask;\r\nnet->xfrm.state_bydst = ndst;\r\nnet->xfrm.state_bysrc = nsrc;\r\nnet->xfrm.state_byspi = nspi;\r\nnet->xfrm.state_hmask = nhashmask;\r\nspin_unlock_bh(&net->xfrm.xfrm_state_lock);\r\nosize = (ohashmask + 1) * sizeof(struct hlist_head);\r\nxfrm_hash_free(odst, osize);\r\nxfrm_hash_free(osrc, osize);\r\nxfrm_hash_free(ospi, osize);\r\nout_unlock:\r\nmutex_unlock(&hash_resize_mutex);\r\n}\r\nint xfrm_register_type(const struct xfrm_type *type, unsigned short family)\r\n{\r\nstruct xfrm_state_afinfo *afinfo = xfrm_state_get_afinfo(family);\r\nconst struct xfrm_type **typemap;\r\nint err = 0;\r\nif (unlikely(afinfo == NULL))\r\nreturn -EAFNOSUPPORT;\r\ntypemap = afinfo->type_map;\r\nspin_lock_bh(&xfrm_type_lock);\r\nif (likely(typemap[type->proto] == NULL))\r\ntypemap[type->proto] = type;\r\nelse\r\nerr = -EEXIST;\r\nspin_unlock_bh(&xfrm_type_lock);\r\nxfrm_state_put_afinfo(afinfo);\r\nreturn err;\r\n}\r\nint xfrm_unregister_type(const struct xfrm_type *type, unsigned short family)\r\n{\r\nstruct xfrm_state_afinfo *afinfo = xfrm_state_get_afinfo(family);\r\nconst struct xfrm_type **typemap;\r\nint err = 0;\r\nif (unlikely(afinfo == NULL))\r\nreturn -EAFNOSUPPORT;\r\ntypemap = afinfo->type_map;\r\nspin_lock_bh(&xfrm_type_lock);\r\nif (unlikely(typemap[type->proto] != type))\r\nerr = -ENOENT;\r\nelse\r\ntypemap[type->proto] = NULL;\r\nspin_unlock_bh(&xfrm_type_lock);\r\nxfrm_state_put_afinfo(afinfo);\r\nreturn err;\r\n}\r\nstatic const struct xfrm_type *xfrm_get_type(u8 proto, unsigned short family)\r\n{\r\nstruct xfrm_state_afinfo *afinfo;\r\nconst struct xfrm_type **typemap;\r\nconst struct xfrm_type *type;\r\nint modload_attempted = 0;\r\nretry:\r\nafinfo = xfrm_state_get_afinfo(family);\r\nif (unlikely(afinfo == NULL))\r\nreturn NULL;\r\ntypemap = afinfo->type_map;\r\ntype = typemap[proto];\r\nif (unlikely(type && !try_module_get(type->owner)))\r\ntype = NULL;\r\nif (!type && !modload_attempted) {\r\nxfrm_state_put_afinfo(afinfo);\r\nrequest_module("xfrm-type-%d-%d", family, proto);\r\nmodload_attempted = 1;\r\ngoto retry;\r\n}\r\nxfrm_state_put_afinfo(afinfo);\r\nreturn type;\r\n}\r\nstatic void xfrm_put_type(const struct xfrm_type *type)\r\n{\r\nmodule_put(type->owner);\r\n}\r\nint xfrm_register_mode(struct xfrm_mode *mode, int family)\r\n{\r\nstruct xfrm_state_afinfo *afinfo;\r\nstruct xfrm_mode **modemap;\r\nint err;\r\nif (unlikely(mode->encap >= XFRM_MODE_MAX))\r\nreturn -EINVAL;\r\nafinfo = xfrm_state_get_afinfo(family);\r\nif (unlikely(afinfo == NULL))\r\nreturn -EAFNOSUPPORT;\r\nerr = -EEXIST;\r\nmodemap = afinfo->mode_map;\r\nspin_lock_bh(&xfrm_mode_lock);\r\nif (modemap[mode->encap])\r\ngoto out;\r\nerr = -ENOENT;\r\nif (!try_module_get(afinfo->owner))\r\ngoto out;\r\nmode->afinfo = afinfo;\r\nmodemap[mode->encap] = mode;\r\nerr = 0;\r\nout:\r\nspin_unlock_bh(&xfrm_mode_lock);\r\nxfrm_state_put_afinfo(afinfo);\r\nreturn err;\r\n}\r\nint xfrm_unregister_mode(struct xfrm_mode *mode, int family)\r\n{\r\nstruct xfrm_state_afinfo *afinfo;\r\nstruct xfrm_mode **modemap;\r\nint err;\r\nif (unlikely(mode->encap >= XFRM_MODE_MAX))\r\nreturn -EINVAL;\r\nafinfo = xfrm_state_get_afinfo(family);\r\nif (unlikely(afinfo == NULL))\r\nreturn -EAFNOSUPPORT;\r\nerr = -ENOENT;\r\nmodemap = afinfo->mode_map;\r\nspin_lock_bh(&xfrm_mode_lock);\r\nif (likely(modemap[mode->encap] == mode)) {\r\nmodemap[mode->encap] = NULL;\r\nmodule_put(mode->afinfo->owner);\r\nerr = 0;\r\n}\r\nspin_unlock_bh(&xfrm_mode_lock);\r\nxfrm_state_put_afinfo(afinfo);\r\nreturn err;\r\n}\r\nstatic struct xfrm_mode *xfrm_get_mode(unsigned int encap, int family)\r\n{\r\nstruct xfrm_state_afinfo *afinfo;\r\nstruct xfrm_mode *mode;\r\nint modload_attempted = 0;\r\nif (unlikely(encap >= XFRM_MODE_MAX))\r\nreturn NULL;\r\nretry:\r\nafinfo = xfrm_state_get_afinfo(family);\r\nif (unlikely(afinfo == NULL))\r\nreturn NULL;\r\nmode = afinfo->mode_map[encap];\r\nif (unlikely(mode && !try_module_get(mode->owner)))\r\nmode = NULL;\r\nif (!mode && !modload_attempted) {\r\nxfrm_state_put_afinfo(afinfo);\r\nrequest_module("xfrm-mode-%d-%d", family, encap);\r\nmodload_attempted = 1;\r\ngoto retry;\r\n}\r\nxfrm_state_put_afinfo(afinfo);\r\nreturn mode;\r\n}\r\nstatic void xfrm_put_mode(struct xfrm_mode *mode)\r\n{\r\nmodule_put(mode->owner);\r\n}\r\nstatic void xfrm_state_gc_destroy(struct xfrm_state *x)\r\n{\r\ntasklet_hrtimer_cancel(&x->mtimer);\r\ndel_timer_sync(&x->rtimer);\r\nkfree(x->aalg);\r\nkfree(x->ealg);\r\nkfree(x->calg);\r\nkfree(x->encap);\r\nkfree(x->coaddr);\r\nkfree(x->replay_esn);\r\nkfree(x->preplay_esn);\r\nif (x->inner_mode)\r\nxfrm_put_mode(x->inner_mode);\r\nif (x->inner_mode_iaf)\r\nxfrm_put_mode(x->inner_mode_iaf);\r\nif (x->outer_mode)\r\nxfrm_put_mode(x->outer_mode);\r\nif (x->type) {\r\nx->type->destructor(x);\r\nxfrm_put_type(x->type);\r\n}\r\nsecurity_xfrm_state_free(x);\r\nkfree(x);\r\n}\r\nstatic void xfrm_state_gc_task(struct work_struct *work)\r\n{\r\nstruct net *net = container_of(work, struct net, xfrm.state_gc_work);\r\nstruct xfrm_state *x;\r\nstruct hlist_node *tmp;\r\nstruct hlist_head gc_list;\r\nspin_lock_bh(&xfrm_state_gc_lock);\r\nhlist_move_list(&net->xfrm.state_gc_list, &gc_list);\r\nspin_unlock_bh(&xfrm_state_gc_lock);\r\nhlist_for_each_entry_safe(x, tmp, &gc_list, gclist)\r\nxfrm_state_gc_destroy(x);\r\n}\r\nstatic inline unsigned long make_jiffies(long secs)\r\n{\r\nif (secs >= (MAX_SCHEDULE_TIMEOUT-1)/HZ)\r\nreturn MAX_SCHEDULE_TIMEOUT-1;\r\nelse\r\nreturn secs*HZ;\r\n}\r\nstatic enum hrtimer_restart xfrm_timer_handler(struct hrtimer *me)\r\n{\r\nstruct tasklet_hrtimer *thr = container_of(me, struct tasklet_hrtimer, timer);\r\nstruct xfrm_state *x = container_of(thr, struct xfrm_state, mtimer);\r\nunsigned long now = get_seconds();\r\nlong next = LONG_MAX;\r\nint warn = 0;\r\nint err = 0;\r\nspin_lock(&x->lock);\r\nif (x->km.state == XFRM_STATE_DEAD)\r\ngoto out;\r\nif (x->km.state == XFRM_STATE_EXPIRED)\r\ngoto expired;\r\nif (x->lft.hard_add_expires_seconds) {\r\nlong tmo = x->lft.hard_add_expires_seconds +\r\nx->curlft.add_time - now;\r\nif (tmo <= 0) {\r\nif (x->xflags & XFRM_SOFT_EXPIRE) {\r\nx->curlft.add_time = now - x->saved_tmo - 1;\r\ntmo = x->lft.hard_add_expires_seconds - x->saved_tmo;\r\n} else\r\ngoto expired;\r\n}\r\nif (tmo < next)\r\nnext = tmo;\r\n}\r\nif (x->lft.hard_use_expires_seconds) {\r\nlong tmo = x->lft.hard_use_expires_seconds +\r\n(x->curlft.use_time ? : now) - now;\r\nif (tmo <= 0)\r\ngoto expired;\r\nif (tmo < next)\r\nnext = tmo;\r\n}\r\nif (x->km.dying)\r\ngoto resched;\r\nif (x->lft.soft_add_expires_seconds) {\r\nlong tmo = x->lft.soft_add_expires_seconds +\r\nx->curlft.add_time - now;\r\nif (tmo <= 0) {\r\nwarn = 1;\r\nx->xflags &= ~XFRM_SOFT_EXPIRE;\r\n} else if (tmo < next) {\r\nnext = tmo;\r\nx->xflags |= XFRM_SOFT_EXPIRE;\r\nx->saved_tmo = tmo;\r\n}\r\n}\r\nif (x->lft.soft_use_expires_seconds) {\r\nlong tmo = x->lft.soft_use_expires_seconds +\r\n(x->curlft.use_time ? : now) - now;\r\nif (tmo <= 0)\r\nwarn = 1;\r\nelse if (tmo < next)\r\nnext = tmo;\r\n}\r\nx->km.dying = warn;\r\nif (warn)\r\nkm_state_expired(x, 0, 0);\r\nresched:\r\nif (next != LONG_MAX) {\r\ntasklet_hrtimer_start(&x->mtimer, ktime_set(next, 0), HRTIMER_MODE_REL);\r\n}\r\ngoto out;\r\nexpired:\r\nif (x->km.state == XFRM_STATE_ACQ && x->id.spi == 0)\r\nx->km.state = XFRM_STATE_EXPIRED;\r\nerr = __xfrm_state_delete(x);\r\nif (!err)\r\nkm_state_expired(x, 1, 0);\r\nxfrm_audit_state_delete(x, err ? 0 : 1, true);\r\nout:\r\nspin_unlock(&x->lock);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstruct xfrm_state *xfrm_state_alloc(struct net *net)\r\n{\r\nstruct xfrm_state *x;\r\nx = kzalloc(sizeof(struct xfrm_state), GFP_ATOMIC);\r\nif (x) {\r\nwrite_pnet(&x->xs_net, net);\r\natomic_set(&x->refcnt, 1);\r\natomic_set(&x->tunnel_users, 0);\r\nINIT_LIST_HEAD(&x->km.all);\r\nINIT_HLIST_NODE(&x->bydst);\r\nINIT_HLIST_NODE(&x->bysrc);\r\nINIT_HLIST_NODE(&x->byspi);\r\ntasklet_hrtimer_init(&x->mtimer, xfrm_timer_handler,\r\nCLOCK_BOOTTIME, HRTIMER_MODE_ABS);\r\nsetup_timer(&x->rtimer, xfrm_replay_timer_handler,\r\n(unsigned long)x);\r\nx->curlft.add_time = get_seconds();\r\nx->lft.soft_byte_limit = XFRM_INF;\r\nx->lft.soft_packet_limit = XFRM_INF;\r\nx->lft.hard_byte_limit = XFRM_INF;\r\nx->lft.hard_packet_limit = XFRM_INF;\r\nx->replay_maxage = 0;\r\nx->replay_maxdiff = 0;\r\nx->inner_mode = NULL;\r\nx->inner_mode_iaf = NULL;\r\nspin_lock_init(&x->lock);\r\n}\r\nreturn x;\r\n}\r\nvoid __xfrm_state_destroy(struct xfrm_state *x)\r\n{\r\nstruct net *net = xs_net(x);\r\nWARN_ON(x->km.state != XFRM_STATE_DEAD);\r\nspin_lock_bh(&xfrm_state_gc_lock);\r\nhlist_add_head(&x->gclist, &net->xfrm.state_gc_list);\r\nspin_unlock_bh(&xfrm_state_gc_lock);\r\nschedule_work(&net->xfrm.state_gc_work);\r\n}\r\nint __xfrm_state_delete(struct xfrm_state *x)\r\n{\r\nstruct net *net = xs_net(x);\r\nint err = -ESRCH;\r\nif (x->km.state != XFRM_STATE_DEAD) {\r\nx->km.state = XFRM_STATE_DEAD;\r\nspin_lock(&net->xfrm.xfrm_state_lock);\r\nlist_del(&x->km.all);\r\nhlist_del(&x->bydst);\r\nhlist_del(&x->bysrc);\r\nif (x->id.spi)\r\nhlist_del(&x->byspi);\r\nnet->xfrm.state_num--;\r\nspin_unlock(&net->xfrm.xfrm_state_lock);\r\nxfrm_state_put(x);\r\nerr = 0;\r\n}\r\nreturn err;\r\n}\r\nint xfrm_state_delete(struct xfrm_state *x)\r\n{\r\nint err;\r\nspin_lock_bh(&x->lock);\r\nerr = __xfrm_state_delete(x);\r\nspin_unlock_bh(&x->lock);\r\nreturn err;\r\n}\r\nstatic inline int\r\nxfrm_state_flush_secctx_check(struct net *net, u8 proto, bool task_valid)\r\n{\r\nint i, err = 0;\r\nfor (i = 0; i <= net->xfrm.state_hmask; i++) {\r\nstruct xfrm_state *x;\r\nhlist_for_each_entry(x, net->xfrm.state_bydst+i, bydst) {\r\nif (xfrm_id_proto_match(x->id.proto, proto) &&\r\n(err = security_xfrm_state_delete(x)) != 0) {\r\nxfrm_audit_state_delete(x, 0, task_valid);\r\nreturn err;\r\n}\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic inline int\r\nxfrm_state_flush_secctx_check(struct net *net, u8 proto, bool task_valid)\r\n{\r\nreturn 0;\r\n}\r\nint xfrm_state_flush(struct net *net, u8 proto, bool task_valid)\r\n{\r\nint i, err = 0, cnt = 0;\r\nspin_lock_bh(&net->xfrm.xfrm_state_lock);\r\nerr = xfrm_state_flush_secctx_check(net, proto, task_valid);\r\nif (err)\r\ngoto out;\r\nerr = -ESRCH;\r\nfor (i = 0; i <= net->xfrm.state_hmask; i++) {\r\nstruct xfrm_state *x;\r\nrestart:\r\nhlist_for_each_entry(x, net->xfrm.state_bydst+i, bydst) {\r\nif (!xfrm_state_kern(x) &&\r\nxfrm_id_proto_match(x->id.proto, proto)) {\r\nxfrm_state_hold(x);\r\nspin_unlock_bh(&net->xfrm.xfrm_state_lock);\r\nerr = xfrm_state_delete(x);\r\nxfrm_audit_state_delete(x, err ? 0 : 1,\r\ntask_valid);\r\nxfrm_state_put(x);\r\nif (!err)\r\ncnt++;\r\nspin_lock_bh(&net->xfrm.xfrm_state_lock);\r\ngoto restart;\r\n}\r\n}\r\n}\r\nif (cnt)\r\nerr = 0;\r\nout:\r\nspin_unlock_bh(&net->xfrm.xfrm_state_lock);\r\nreturn err;\r\n}\r\nvoid xfrm_sad_getinfo(struct net *net, struct xfrmk_sadinfo *si)\r\n{\r\nspin_lock_bh(&net->xfrm.xfrm_state_lock);\r\nsi->sadcnt = net->xfrm.state_num;\r\nsi->sadhcnt = net->xfrm.state_hmask;\r\nsi->sadhmcnt = xfrm_state_hashmax;\r\nspin_unlock_bh(&net->xfrm.xfrm_state_lock);\r\n}\r\nstatic int\r\nxfrm_init_tempstate(struct xfrm_state *x, const struct flowi *fl,\r\nconst struct xfrm_tmpl *tmpl,\r\nconst xfrm_address_t *daddr, const xfrm_address_t *saddr,\r\nunsigned short family)\r\n{\r\nstruct xfrm_state_afinfo *afinfo = xfrm_state_get_afinfo(family);\r\nif (!afinfo)\r\nreturn -1;\r\nafinfo->init_tempsel(&x->sel, fl);\r\nif (family != tmpl->encap_family) {\r\nxfrm_state_put_afinfo(afinfo);\r\nafinfo = xfrm_state_get_afinfo(tmpl->encap_family);\r\nif (!afinfo)\r\nreturn -1;\r\n}\r\nafinfo->init_temprop(x, tmpl, daddr, saddr);\r\nxfrm_state_put_afinfo(afinfo);\r\nreturn 0;\r\n}\r\nstatic struct xfrm_state *__xfrm_state_lookup(struct net *net, u32 mark,\r\nconst xfrm_address_t *daddr,\r\n__be32 spi, u8 proto,\r\nunsigned short family)\r\n{\r\nunsigned int h = xfrm_spi_hash(net, daddr, spi, proto, family);\r\nstruct xfrm_state *x;\r\nhlist_for_each_entry(x, net->xfrm.state_byspi+h, byspi) {\r\nif (x->props.family != family ||\r\nx->id.spi != spi ||\r\nx->id.proto != proto ||\r\n!xfrm_addr_equal(&x->id.daddr, daddr, family))\r\ncontinue;\r\nif ((mark & x->mark.m) != x->mark.v)\r\ncontinue;\r\nxfrm_state_hold(x);\r\nreturn x;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct xfrm_state *__xfrm_state_lookup_byaddr(struct net *net, u32 mark,\r\nconst xfrm_address_t *daddr,\r\nconst xfrm_address_t *saddr,\r\nu8 proto, unsigned short family)\r\n{\r\nunsigned int h = xfrm_src_hash(net, daddr, saddr, family);\r\nstruct xfrm_state *x;\r\nhlist_for_each_entry(x, net->xfrm.state_bysrc+h, bysrc) {\r\nif (x->props.family != family ||\r\nx->id.proto != proto ||\r\n!xfrm_addr_equal(&x->id.daddr, daddr, family) ||\r\n!xfrm_addr_equal(&x->props.saddr, saddr, family))\r\ncontinue;\r\nif ((mark & x->mark.m) != x->mark.v)\r\ncontinue;\r\nxfrm_state_hold(x);\r\nreturn x;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline struct xfrm_state *\r\n__xfrm_state_locate(struct xfrm_state *x, int use_spi, int family)\r\n{\r\nstruct net *net = xs_net(x);\r\nu32 mark = x->mark.v & x->mark.m;\r\nif (use_spi)\r\nreturn __xfrm_state_lookup(net, mark, &x->id.daddr,\r\nx->id.spi, x->id.proto, family);\r\nelse\r\nreturn __xfrm_state_lookup_byaddr(net, mark,\r\n&x->id.daddr,\r\n&x->props.saddr,\r\nx->id.proto, family);\r\n}\r\nstatic void xfrm_hash_grow_check(struct net *net, int have_hash_collision)\r\n{\r\nif (have_hash_collision &&\r\n(net->xfrm.state_hmask + 1) < xfrm_state_hashmax &&\r\nnet->xfrm.state_num > net->xfrm.state_hmask)\r\nschedule_work(&net->xfrm.state_hash_work);\r\n}\r\nstatic void xfrm_state_look_at(struct xfrm_policy *pol, struct xfrm_state *x,\r\nconst struct flowi *fl, unsigned short family,\r\nstruct xfrm_state **best, int *acq_in_progress,\r\nint *error)\r\n{\r\nif (x->km.state == XFRM_STATE_VALID) {\r\nif ((x->sel.family &&\r\n!xfrm_selector_match(&x->sel, fl, x->sel.family)) ||\r\n!security_xfrm_state_pol_flow_match(x, pol, fl))\r\nreturn;\r\nif (!*best ||\r\n(*best)->km.dying > x->km.dying ||\r\n((*best)->km.dying == x->km.dying &&\r\n(*best)->curlft.add_time < x->curlft.add_time))\r\n*best = x;\r\n} else if (x->km.state == XFRM_STATE_ACQ) {\r\n*acq_in_progress = 1;\r\n} else if (x->km.state == XFRM_STATE_ERROR ||\r\nx->km.state == XFRM_STATE_EXPIRED) {\r\nif (xfrm_selector_match(&x->sel, fl, x->sel.family) &&\r\nsecurity_xfrm_state_pol_flow_match(x, pol, fl))\r\n*error = -ESRCH;\r\n}\r\n}\r\nstruct xfrm_state *\r\nxfrm_state_find(const xfrm_address_t *daddr, const xfrm_address_t *saddr,\r\nconst struct flowi *fl, struct xfrm_tmpl *tmpl,\r\nstruct xfrm_policy *pol, int *err,\r\nunsigned short family)\r\n{\r\nstatic xfrm_address_t saddr_wildcard = { };\r\nstruct net *net = xp_net(pol);\r\nunsigned int h, h_wildcard;\r\nstruct xfrm_state *x, *x0, *to_put;\r\nint acquire_in_progress = 0;\r\nint error = 0;\r\nstruct xfrm_state *best = NULL;\r\nu32 mark = pol->mark.v & pol->mark.m;\r\nunsigned short encap_family = tmpl->encap_family;\r\nstruct km_event c;\r\nto_put = NULL;\r\nspin_lock_bh(&net->xfrm.xfrm_state_lock);\r\nh = xfrm_dst_hash(net, daddr, saddr, tmpl->reqid, encap_family);\r\nhlist_for_each_entry(x, net->xfrm.state_bydst+h, bydst) {\r\nif (x->props.family == encap_family &&\r\nx->props.reqid == tmpl->reqid &&\r\n(mark & x->mark.m) == x->mark.v &&\r\n!(x->props.flags & XFRM_STATE_WILDRECV) &&\r\nxfrm_state_addr_check(x, daddr, saddr, encap_family) &&\r\ntmpl->mode == x->props.mode &&\r\ntmpl->id.proto == x->id.proto &&\r\n(tmpl->id.spi == x->id.spi || !tmpl->id.spi))\r\nxfrm_state_look_at(pol, x, fl, encap_family,\r\n&best, &acquire_in_progress, &error);\r\n}\r\nif (best || acquire_in_progress)\r\ngoto found;\r\nh_wildcard = xfrm_dst_hash(net, daddr, &saddr_wildcard, tmpl->reqid, encap_family);\r\nhlist_for_each_entry(x, net->xfrm.state_bydst+h_wildcard, bydst) {\r\nif (x->props.family == encap_family &&\r\nx->props.reqid == tmpl->reqid &&\r\n(mark & x->mark.m) == x->mark.v &&\r\n!(x->props.flags & XFRM_STATE_WILDRECV) &&\r\nxfrm_addr_equal(&x->id.daddr, daddr, encap_family) &&\r\ntmpl->mode == x->props.mode &&\r\ntmpl->id.proto == x->id.proto &&\r\n(tmpl->id.spi == x->id.spi || !tmpl->id.spi))\r\nxfrm_state_look_at(pol, x, fl, encap_family,\r\n&best, &acquire_in_progress, &error);\r\n}\r\nfound:\r\nx = best;\r\nif (!x && !error && !acquire_in_progress) {\r\nif (tmpl->id.spi &&\r\n(x0 = __xfrm_state_lookup(net, mark, daddr, tmpl->id.spi,\r\ntmpl->id.proto, encap_family)) != NULL) {\r\nto_put = x0;\r\nerror = -EEXIST;\r\ngoto out;\r\n}\r\nc.net = net;\r\nif (!km_is_alive(&c)) {\r\nerror = -ESRCH;\r\ngoto out;\r\n}\r\nx = xfrm_state_alloc(net);\r\nif (x == NULL) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\nxfrm_init_tempstate(x, fl, tmpl, daddr, saddr, family);\r\nmemcpy(&x->mark, &pol->mark, sizeof(x->mark));\r\nerror = security_xfrm_state_alloc_acquire(x, pol->security, fl->flowi_secid);\r\nif (error) {\r\nx->km.state = XFRM_STATE_DEAD;\r\nto_put = x;\r\nx = NULL;\r\ngoto out;\r\n}\r\nif (km_query(x, tmpl, pol) == 0) {\r\nx->km.state = XFRM_STATE_ACQ;\r\nlist_add(&x->km.all, &net->xfrm.state_all);\r\nhlist_add_head(&x->bydst, net->xfrm.state_bydst+h);\r\nh = xfrm_src_hash(net, daddr, saddr, encap_family);\r\nhlist_add_head(&x->bysrc, net->xfrm.state_bysrc+h);\r\nif (x->id.spi) {\r\nh = xfrm_spi_hash(net, &x->id.daddr, x->id.spi, x->id.proto, encap_family);\r\nhlist_add_head(&x->byspi, net->xfrm.state_byspi+h);\r\n}\r\nx->lft.hard_add_expires_seconds = net->xfrm.sysctl_acq_expires;\r\ntasklet_hrtimer_start(&x->mtimer, ktime_set(net->xfrm.sysctl_acq_expires, 0), HRTIMER_MODE_REL);\r\nnet->xfrm.state_num++;\r\nxfrm_hash_grow_check(net, x->bydst.next != NULL);\r\n} else {\r\nx->km.state = XFRM_STATE_DEAD;\r\nto_put = x;\r\nx = NULL;\r\nerror = -ESRCH;\r\n}\r\n}\r\nout:\r\nif (x)\r\nxfrm_state_hold(x);\r\nelse\r\n*err = acquire_in_progress ? -EAGAIN : error;\r\nspin_unlock_bh(&net->xfrm.xfrm_state_lock);\r\nif (to_put)\r\nxfrm_state_put(to_put);\r\nreturn x;\r\n}\r\nstruct xfrm_state *\r\nxfrm_stateonly_find(struct net *net, u32 mark,\r\nxfrm_address_t *daddr, xfrm_address_t *saddr,\r\nunsigned short family, u8 mode, u8 proto, u32 reqid)\r\n{\r\nunsigned int h;\r\nstruct xfrm_state *rx = NULL, *x = NULL;\r\nspin_lock_bh(&net->xfrm.xfrm_state_lock);\r\nh = xfrm_dst_hash(net, daddr, saddr, reqid, family);\r\nhlist_for_each_entry(x, net->xfrm.state_bydst+h, bydst) {\r\nif (x->props.family == family &&\r\nx->props.reqid == reqid &&\r\n(mark & x->mark.m) == x->mark.v &&\r\n!(x->props.flags & XFRM_STATE_WILDRECV) &&\r\nxfrm_state_addr_check(x, daddr, saddr, family) &&\r\nmode == x->props.mode &&\r\nproto == x->id.proto &&\r\nx->km.state == XFRM_STATE_VALID) {\r\nrx = x;\r\nbreak;\r\n}\r\n}\r\nif (rx)\r\nxfrm_state_hold(rx);\r\nspin_unlock_bh(&net->xfrm.xfrm_state_lock);\r\nreturn rx;\r\n}\r\nstruct xfrm_state *xfrm_state_lookup_byspi(struct net *net, __be32 spi,\r\nunsigned short family)\r\n{\r\nstruct xfrm_state *x;\r\nstruct xfrm_state_walk *w;\r\nspin_lock_bh(&net->xfrm.xfrm_state_lock);\r\nlist_for_each_entry(w, &net->xfrm.state_all, all) {\r\nx = container_of(w, struct xfrm_state, km);\r\nif (x->props.family != family ||\r\nx->id.spi != spi)\r\ncontinue;\r\nspin_unlock_bh(&net->xfrm.xfrm_state_lock);\r\nxfrm_state_hold(x);\r\nreturn x;\r\n}\r\nspin_unlock_bh(&net->xfrm.xfrm_state_lock);\r\nreturn NULL;\r\n}\r\nstatic void __xfrm_state_insert(struct xfrm_state *x)\r\n{\r\nstruct net *net = xs_net(x);\r\nunsigned int h;\r\nlist_add(&x->km.all, &net->xfrm.state_all);\r\nh = xfrm_dst_hash(net, &x->id.daddr, &x->props.saddr,\r\nx->props.reqid, x->props.family);\r\nhlist_add_head(&x->bydst, net->xfrm.state_bydst+h);\r\nh = xfrm_src_hash(net, &x->id.daddr, &x->props.saddr, x->props.family);\r\nhlist_add_head(&x->bysrc, net->xfrm.state_bysrc+h);\r\nif (x->id.spi) {\r\nh = xfrm_spi_hash(net, &x->id.daddr, x->id.spi, x->id.proto,\r\nx->props.family);\r\nhlist_add_head(&x->byspi, net->xfrm.state_byspi+h);\r\n}\r\ntasklet_hrtimer_start(&x->mtimer, ktime_set(1, 0), HRTIMER_MODE_REL);\r\nif (x->replay_maxage)\r\nmod_timer(&x->rtimer, jiffies + x->replay_maxage);\r\nnet->xfrm.state_num++;\r\nxfrm_hash_grow_check(net, x->bydst.next != NULL);\r\n}\r\nstatic void __xfrm_state_bump_genids(struct xfrm_state *xnew)\r\n{\r\nstruct net *net = xs_net(xnew);\r\nunsigned short family = xnew->props.family;\r\nu32 reqid = xnew->props.reqid;\r\nstruct xfrm_state *x;\r\nunsigned int h;\r\nu32 mark = xnew->mark.v & xnew->mark.m;\r\nh = xfrm_dst_hash(net, &xnew->id.daddr, &xnew->props.saddr, reqid, family);\r\nhlist_for_each_entry(x, net->xfrm.state_bydst+h, bydst) {\r\nif (x->props.family == family &&\r\nx->props.reqid == reqid &&\r\n(mark & x->mark.m) == x->mark.v &&\r\nxfrm_addr_equal(&x->id.daddr, &xnew->id.daddr, family) &&\r\nxfrm_addr_equal(&x->props.saddr, &xnew->props.saddr, family))\r\nx->genid++;\r\n}\r\n}\r\nvoid xfrm_state_insert(struct xfrm_state *x)\r\n{\r\nstruct net *net = xs_net(x);\r\nspin_lock_bh(&net->xfrm.xfrm_state_lock);\r\n__xfrm_state_bump_genids(x);\r\n__xfrm_state_insert(x);\r\nspin_unlock_bh(&net->xfrm.xfrm_state_lock);\r\n}\r\nstatic struct xfrm_state *__find_acq_core(struct net *net,\r\nconst struct xfrm_mark *m,\r\nunsigned short family, u8 mode,\r\nu32 reqid, u8 proto,\r\nconst xfrm_address_t *daddr,\r\nconst xfrm_address_t *saddr,\r\nint create)\r\n{\r\nunsigned int h = xfrm_dst_hash(net, daddr, saddr, reqid, family);\r\nstruct xfrm_state *x;\r\nu32 mark = m->v & m->m;\r\nhlist_for_each_entry(x, net->xfrm.state_bydst+h, bydst) {\r\nif (x->props.reqid != reqid ||\r\nx->props.mode != mode ||\r\nx->props.family != family ||\r\nx->km.state != XFRM_STATE_ACQ ||\r\nx->id.spi != 0 ||\r\nx->id.proto != proto ||\r\n(mark & x->mark.m) != x->mark.v ||\r\n!xfrm_addr_equal(&x->id.daddr, daddr, family) ||\r\n!xfrm_addr_equal(&x->props.saddr, saddr, family))\r\ncontinue;\r\nxfrm_state_hold(x);\r\nreturn x;\r\n}\r\nif (!create)\r\nreturn NULL;\r\nx = xfrm_state_alloc(net);\r\nif (likely(x)) {\r\nswitch (family) {\r\ncase AF_INET:\r\nx->sel.daddr.a4 = daddr->a4;\r\nx->sel.saddr.a4 = saddr->a4;\r\nx->sel.prefixlen_d = 32;\r\nx->sel.prefixlen_s = 32;\r\nx->props.saddr.a4 = saddr->a4;\r\nx->id.daddr.a4 = daddr->a4;\r\nbreak;\r\ncase AF_INET6:\r\n*(struct in6_addr *)x->sel.daddr.a6 = *(struct in6_addr *)daddr;\r\n*(struct in6_addr *)x->sel.saddr.a6 = *(struct in6_addr *)saddr;\r\nx->sel.prefixlen_d = 128;\r\nx->sel.prefixlen_s = 128;\r\n*(struct in6_addr *)x->props.saddr.a6 = *(struct in6_addr *)saddr;\r\n*(struct in6_addr *)x->id.daddr.a6 = *(struct in6_addr *)daddr;\r\nbreak;\r\n}\r\nx->km.state = XFRM_STATE_ACQ;\r\nx->id.proto = proto;\r\nx->props.family = family;\r\nx->props.mode = mode;\r\nx->props.reqid = reqid;\r\nx->mark.v = m->v;\r\nx->mark.m = m->m;\r\nx->lft.hard_add_expires_seconds = net->xfrm.sysctl_acq_expires;\r\nxfrm_state_hold(x);\r\ntasklet_hrtimer_start(&x->mtimer, ktime_set(net->xfrm.sysctl_acq_expires, 0), HRTIMER_MODE_REL);\r\nlist_add(&x->km.all, &net->xfrm.state_all);\r\nhlist_add_head(&x->bydst, net->xfrm.state_bydst+h);\r\nh = xfrm_src_hash(net, daddr, saddr, family);\r\nhlist_add_head(&x->bysrc, net->xfrm.state_bysrc+h);\r\nnet->xfrm.state_num++;\r\nxfrm_hash_grow_check(net, x->bydst.next != NULL);\r\n}\r\nreturn x;\r\n}\r\nint xfrm_state_add(struct xfrm_state *x)\r\n{\r\nstruct net *net = xs_net(x);\r\nstruct xfrm_state *x1, *to_put;\r\nint family;\r\nint err;\r\nu32 mark = x->mark.v & x->mark.m;\r\nint use_spi = xfrm_id_proto_match(x->id.proto, IPSEC_PROTO_ANY);\r\nfamily = x->props.family;\r\nto_put = NULL;\r\nspin_lock_bh(&net->xfrm.xfrm_state_lock);\r\nx1 = __xfrm_state_locate(x, use_spi, family);\r\nif (x1) {\r\nto_put = x1;\r\nx1 = NULL;\r\nerr = -EEXIST;\r\ngoto out;\r\n}\r\nif (use_spi && x->km.seq) {\r\nx1 = __xfrm_find_acq_byseq(net, mark, x->km.seq);\r\nif (x1 && ((x1->id.proto != x->id.proto) ||\r\n!xfrm_addr_equal(&x1->id.daddr, &x->id.daddr, family))) {\r\nto_put = x1;\r\nx1 = NULL;\r\n}\r\n}\r\nif (use_spi && !x1)\r\nx1 = __find_acq_core(net, &x->mark, family, x->props.mode,\r\nx->props.reqid, x->id.proto,\r\n&x->id.daddr, &x->props.saddr, 0);\r\n__xfrm_state_bump_genids(x);\r\n__xfrm_state_insert(x);\r\nerr = 0;\r\nout:\r\nspin_unlock_bh(&net->xfrm.xfrm_state_lock);\r\nif (x1) {\r\nxfrm_state_delete(x1);\r\nxfrm_state_put(x1);\r\n}\r\nif (to_put)\r\nxfrm_state_put(to_put);\r\nreturn err;\r\n}\r\nstatic struct xfrm_state *xfrm_state_clone(struct xfrm_state *orig)\r\n{\r\nstruct net *net = xs_net(orig);\r\nstruct xfrm_state *x = xfrm_state_alloc(net);\r\nif (!x)\r\ngoto out;\r\nmemcpy(&x->id, &orig->id, sizeof(x->id));\r\nmemcpy(&x->sel, &orig->sel, sizeof(x->sel));\r\nmemcpy(&x->lft, &orig->lft, sizeof(x->lft));\r\nx->props.mode = orig->props.mode;\r\nx->props.replay_window = orig->props.replay_window;\r\nx->props.reqid = orig->props.reqid;\r\nx->props.family = orig->props.family;\r\nx->props.saddr = orig->props.saddr;\r\nif (orig->aalg) {\r\nx->aalg = xfrm_algo_auth_clone(orig->aalg);\r\nif (!x->aalg)\r\ngoto error;\r\n}\r\nx->props.aalgo = orig->props.aalgo;\r\nif (orig->aead) {\r\nx->aead = xfrm_algo_aead_clone(orig->aead);\r\nif (!x->aead)\r\ngoto error;\r\n}\r\nif (orig->ealg) {\r\nx->ealg = xfrm_algo_clone(orig->ealg);\r\nif (!x->ealg)\r\ngoto error;\r\n}\r\nx->props.ealgo = orig->props.ealgo;\r\nif (orig->calg) {\r\nx->calg = xfrm_algo_clone(orig->calg);\r\nif (!x->calg)\r\ngoto error;\r\n}\r\nx->props.calgo = orig->props.calgo;\r\nif (orig->encap) {\r\nx->encap = kmemdup(orig->encap, sizeof(*x->encap), GFP_KERNEL);\r\nif (!x->encap)\r\ngoto error;\r\n}\r\nif (orig->coaddr) {\r\nx->coaddr = kmemdup(orig->coaddr, sizeof(*x->coaddr),\r\nGFP_KERNEL);\r\nif (!x->coaddr)\r\ngoto error;\r\n}\r\nif (orig->replay_esn) {\r\nif (xfrm_replay_clone(x, orig))\r\ngoto error;\r\n}\r\nmemcpy(&x->mark, &orig->mark, sizeof(x->mark));\r\nif (xfrm_init_state(x) < 0)\r\ngoto error;\r\nx->props.flags = orig->props.flags;\r\nx->props.extra_flags = orig->props.extra_flags;\r\nx->tfcpad = orig->tfcpad;\r\nx->replay_maxdiff = orig->replay_maxdiff;\r\nx->replay_maxage = orig->replay_maxage;\r\nx->curlft.add_time = orig->curlft.add_time;\r\nx->km.state = orig->km.state;\r\nx->km.seq = orig->km.seq;\r\nreturn x;\r\nerror:\r\nxfrm_state_put(x);\r\nout:\r\nreturn NULL;\r\n}\r\nstruct xfrm_state *xfrm_migrate_state_find(struct xfrm_migrate *m, struct net *net)\r\n{\r\nunsigned int h;\r\nstruct xfrm_state *x = NULL;\r\nspin_lock_bh(&net->xfrm.xfrm_state_lock);\r\nif (m->reqid) {\r\nh = xfrm_dst_hash(net, &m->old_daddr, &m->old_saddr,\r\nm->reqid, m->old_family);\r\nhlist_for_each_entry(x, net->xfrm.state_bydst+h, bydst) {\r\nif (x->props.mode != m->mode ||\r\nx->id.proto != m->proto)\r\ncontinue;\r\nif (m->reqid && x->props.reqid != m->reqid)\r\ncontinue;\r\nif (!xfrm_addr_equal(&x->id.daddr, &m->old_daddr,\r\nm->old_family) ||\r\n!xfrm_addr_equal(&x->props.saddr, &m->old_saddr,\r\nm->old_family))\r\ncontinue;\r\nxfrm_state_hold(x);\r\nbreak;\r\n}\r\n} else {\r\nh = xfrm_src_hash(net, &m->old_daddr, &m->old_saddr,\r\nm->old_family);\r\nhlist_for_each_entry(x, net->xfrm.state_bysrc+h, bysrc) {\r\nif (x->props.mode != m->mode ||\r\nx->id.proto != m->proto)\r\ncontinue;\r\nif (!xfrm_addr_equal(&x->id.daddr, &m->old_daddr,\r\nm->old_family) ||\r\n!xfrm_addr_equal(&x->props.saddr, &m->old_saddr,\r\nm->old_family))\r\ncontinue;\r\nxfrm_state_hold(x);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&net->xfrm.xfrm_state_lock);\r\nreturn x;\r\n}\r\nstruct xfrm_state *xfrm_state_migrate(struct xfrm_state *x,\r\nstruct xfrm_migrate *m)\r\n{\r\nstruct xfrm_state *xc;\r\nxc = xfrm_state_clone(x);\r\nif (!xc)\r\nreturn NULL;\r\nmemcpy(&xc->id.daddr, &m->new_daddr, sizeof(xc->id.daddr));\r\nmemcpy(&xc->props.saddr, &m->new_saddr, sizeof(xc->props.saddr));\r\nif (xfrm_addr_equal(&x->id.daddr, &m->new_daddr, m->new_family)) {\r\nxfrm_state_insert(xc);\r\n} else {\r\nif (xfrm_state_add(xc) < 0)\r\ngoto error;\r\n}\r\nreturn xc;\r\nerror:\r\nxfrm_state_put(xc);\r\nreturn NULL;\r\n}\r\nint xfrm_state_update(struct xfrm_state *x)\r\n{\r\nstruct xfrm_state *x1, *to_put;\r\nint err;\r\nint use_spi = xfrm_id_proto_match(x->id.proto, IPSEC_PROTO_ANY);\r\nstruct net *net = xs_net(x);\r\nto_put = NULL;\r\nspin_lock_bh(&net->xfrm.xfrm_state_lock);\r\nx1 = __xfrm_state_locate(x, use_spi, x->props.family);\r\nerr = -ESRCH;\r\nif (!x1)\r\ngoto out;\r\nif (xfrm_state_kern(x1)) {\r\nto_put = x1;\r\nerr = -EEXIST;\r\ngoto out;\r\n}\r\nif (x1->km.state == XFRM_STATE_ACQ) {\r\n__xfrm_state_insert(x);\r\nx = NULL;\r\n}\r\nerr = 0;\r\nout:\r\nspin_unlock_bh(&net->xfrm.xfrm_state_lock);\r\nif (to_put)\r\nxfrm_state_put(to_put);\r\nif (err)\r\nreturn err;\r\nif (!x) {\r\nxfrm_state_delete(x1);\r\nxfrm_state_put(x1);\r\nreturn 0;\r\n}\r\nerr = -EINVAL;\r\nspin_lock_bh(&x1->lock);\r\nif (likely(x1->km.state == XFRM_STATE_VALID)) {\r\nif (x->encap && x1->encap)\r\nmemcpy(x1->encap, x->encap, sizeof(*x1->encap));\r\nif (x->coaddr && x1->coaddr) {\r\nmemcpy(x1->coaddr, x->coaddr, sizeof(*x1->coaddr));\r\n}\r\nif (!use_spi && memcmp(&x1->sel, &x->sel, sizeof(x1->sel)))\r\nmemcpy(&x1->sel, &x->sel, sizeof(x1->sel));\r\nmemcpy(&x1->lft, &x->lft, sizeof(x1->lft));\r\nx1->km.dying = 0;\r\ntasklet_hrtimer_start(&x1->mtimer, ktime_set(1, 0), HRTIMER_MODE_REL);\r\nif (x1->curlft.use_time)\r\nxfrm_state_check_expire(x1);\r\nerr = 0;\r\nx->km.state = XFRM_STATE_DEAD;\r\n__xfrm_state_put(x);\r\n}\r\nspin_unlock_bh(&x1->lock);\r\nxfrm_state_put(x1);\r\nreturn err;\r\n}\r\nint xfrm_state_check_expire(struct xfrm_state *x)\r\n{\r\nif (!x->curlft.use_time)\r\nx->curlft.use_time = get_seconds();\r\nif (x->curlft.bytes >= x->lft.hard_byte_limit ||\r\nx->curlft.packets >= x->lft.hard_packet_limit) {\r\nx->km.state = XFRM_STATE_EXPIRED;\r\ntasklet_hrtimer_start(&x->mtimer, ktime_set(0, 0), HRTIMER_MODE_REL);\r\nreturn -EINVAL;\r\n}\r\nif (!x->km.dying &&\r\n(x->curlft.bytes >= x->lft.soft_byte_limit ||\r\nx->curlft.packets >= x->lft.soft_packet_limit)) {\r\nx->km.dying = 1;\r\nkm_state_expired(x, 0, 0);\r\n}\r\nreturn 0;\r\n}\r\nstruct xfrm_state *\r\nxfrm_state_lookup(struct net *net, u32 mark, const xfrm_address_t *daddr, __be32 spi,\r\nu8 proto, unsigned short family)\r\n{\r\nstruct xfrm_state *x;\r\nspin_lock_bh(&net->xfrm.xfrm_state_lock);\r\nx = __xfrm_state_lookup(net, mark, daddr, spi, proto, family);\r\nspin_unlock_bh(&net->xfrm.xfrm_state_lock);\r\nreturn x;\r\n}\r\nstruct xfrm_state *\r\nxfrm_state_lookup_byaddr(struct net *net, u32 mark,\r\nconst xfrm_address_t *daddr, const xfrm_address_t *saddr,\r\nu8 proto, unsigned short family)\r\n{\r\nstruct xfrm_state *x;\r\nspin_lock_bh(&net->xfrm.xfrm_state_lock);\r\nx = __xfrm_state_lookup_byaddr(net, mark, daddr, saddr, proto, family);\r\nspin_unlock_bh(&net->xfrm.xfrm_state_lock);\r\nreturn x;\r\n}\r\nstruct xfrm_state *\r\nxfrm_find_acq(struct net *net, const struct xfrm_mark *mark, u8 mode, u32 reqid,\r\nu8 proto, const xfrm_address_t *daddr,\r\nconst xfrm_address_t *saddr, int create, unsigned short family)\r\n{\r\nstruct xfrm_state *x;\r\nspin_lock_bh(&net->xfrm.xfrm_state_lock);\r\nx = __find_acq_core(net, mark, family, mode, reqid, proto, daddr, saddr, create);\r\nspin_unlock_bh(&net->xfrm.xfrm_state_lock);\r\nreturn x;\r\n}\r\nint\r\nxfrm_tmpl_sort(struct xfrm_tmpl **dst, struct xfrm_tmpl **src, int n,\r\nunsigned short family, struct net *net)\r\n{\r\nint err = 0;\r\nstruct xfrm_state_afinfo *afinfo = xfrm_state_get_afinfo(family);\r\nif (!afinfo)\r\nreturn -EAFNOSUPPORT;\r\nspin_lock_bh(&net->xfrm.xfrm_state_lock);\r\nif (afinfo->tmpl_sort)\r\nerr = afinfo->tmpl_sort(dst, src, n);\r\nspin_unlock_bh(&net->xfrm.xfrm_state_lock);\r\nxfrm_state_put_afinfo(afinfo);\r\nreturn err;\r\n}\r\nint\r\nxfrm_state_sort(struct xfrm_state **dst, struct xfrm_state **src, int n,\r\nunsigned short family)\r\n{\r\nint err = 0;\r\nstruct xfrm_state_afinfo *afinfo = xfrm_state_get_afinfo(family);\r\nstruct net *net = xs_net(*src);\r\nif (!afinfo)\r\nreturn -EAFNOSUPPORT;\r\nspin_lock_bh(&net->xfrm.xfrm_state_lock);\r\nif (afinfo->state_sort)\r\nerr = afinfo->state_sort(dst, src, n);\r\nspin_unlock_bh(&net->xfrm.xfrm_state_lock);\r\nxfrm_state_put_afinfo(afinfo);\r\nreturn err;\r\n}\r\nstatic struct xfrm_state *__xfrm_find_acq_byseq(struct net *net, u32 mark, u32 seq)\r\n{\r\nint i;\r\nfor (i = 0; i <= net->xfrm.state_hmask; i++) {\r\nstruct xfrm_state *x;\r\nhlist_for_each_entry(x, net->xfrm.state_bydst+i, bydst) {\r\nif (x->km.seq == seq &&\r\n(mark & x->mark.m) == x->mark.v &&\r\nx->km.state == XFRM_STATE_ACQ) {\r\nxfrm_state_hold(x);\r\nreturn x;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstruct xfrm_state *xfrm_find_acq_byseq(struct net *net, u32 mark, u32 seq)\r\n{\r\nstruct xfrm_state *x;\r\nspin_lock_bh(&net->xfrm.xfrm_state_lock);\r\nx = __xfrm_find_acq_byseq(net, mark, seq);\r\nspin_unlock_bh(&net->xfrm.xfrm_state_lock);\r\nreturn x;\r\n}\r\nu32 xfrm_get_acqseq(void)\r\n{\r\nu32 res;\r\nstatic atomic_t acqseq;\r\ndo {\r\nres = atomic_inc_return(&acqseq);\r\n} while (!res);\r\nreturn res;\r\n}\r\nint verify_spi_info(u8 proto, u32 min, u32 max)\r\n{\r\nswitch (proto) {\r\ncase IPPROTO_AH:\r\ncase IPPROTO_ESP:\r\nbreak;\r\ncase IPPROTO_COMP:\r\nif (max >= 0x10000)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (min > max)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint xfrm_alloc_spi(struct xfrm_state *x, u32 low, u32 high)\r\n{\r\nstruct net *net = xs_net(x);\r\nunsigned int h;\r\nstruct xfrm_state *x0;\r\nint err = -ENOENT;\r\n__be32 minspi = htonl(low);\r\n__be32 maxspi = htonl(high);\r\nu32 mark = x->mark.v & x->mark.m;\r\nspin_lock_bh(&x->lock);\r\nif (x->km.state == XFRM_STATE_DEAD)\r\ngoto unlock;\r\nerr = 0;\r\nif (x->id.spi)\r\ngoto unlock;\r\nerr = -ENOENT;\r\nif (minspi == maxspi) {\r\nx0 = xfrm_state_lookup(net, mark, &x->id.daddr, minspi, x->id.proto, x->props.family);\r\nif (x0) {\r\nxfrm_state_put(x0);\r\ngoto unlock;\r\n}\r\nx->id.spi = minspi;\r\n} else {\r\nu32 spi = 0;\r\nfor (h = 0; h < high-low+1; h++) {\r\nspi = low + prandom_u32()%(high-low+1);\r\nx0 = xfrm_state_lookup(net, mark, &x->id.daddr, htonl(spi), x->id.proto, x->props.family);\r\nif (x0 == NULL) {\r\nx->id.spi = htonl(spi);\r\nbreak;\r\n}\r\nxfrm_state_put(x0);\r\n}\r\n}\r\nif (x->id.spi) {\r\nspin_lock_bh(&net->xfrm.xfrm_state_lock);\r\nh = xfrm_spi_hash(net, &x->id.daddr, x->id.spi, x->id.proto, x->props.family);\r\nhlist_add_head(&x->byspi, net->xfrm.state_byspi+h);\r\nspin_unlock_bh(&net->xfrm.xfrm_state_lock);\r\nerr = 0;\r\n}\r\nunlock:\r\nspin_unlock_bh(&x->lock);\r\nreturn err;\r\n}\r\nstatic bool __xfrm_state_filter_match(struct xfrm_state *x,\r\nstruct xfrm_address_filter *filter)\r\n{\r\nif (filter) {\r\nif ((filter->family == AF_INET ||\r\nfilter->family == AF_INET6) &&\r\nx->props.family != filter->family)\r\nreturn false;\r\nreturn addr_match(&x->props.saddr, &filter->saddr,\r\nfilter->splen) &&\r\naddr_match(&x->id.daddr, &filter->daddr,\r\nfilter->dplen);\r\n}\r\nreturn true;\r\n}\r\nint xfrm_state_walk(struct net *net, struct xfrm_state_walk *walk,\r\nint (*func)(struct xfrm_state *, int, void*),\r\nvoid *data)\r\n{\r\nstruct xfrm_state *state;\r\nstruct xfrm_state_walk *x;\r\nint err = 0;\r\nif (walk->seq != 0 && list_empty(&walk->all))\r\nreturn 0;\r\nspin_lock_bh(&net->xfrm.xfrm_state_lock);\r\nif (list_empty(&walk->all))\r\nx = list_first_entry(&net->xfrm.state_all, struct xfrm_state_walk, all);\r\nelse\r\nx = list_entry(&walk->all, struct xfrm_state_walk, all);\r\nlist_for_each_entry_from(x, &net->xfrm.state_all, all) {\r\nif (x->state == XFRM_STATE_DEAD)\r\ncontinue;\r\nstate = container_of(x, struct xfrm_state, km);\r\nif (!xfrm_id_proto_match(state->id.proto, walk->proto))\r\ncontinue;\r\nif (!__xfrm_state_filter_match(state, walk->filter))\r\ncontinue;\r\nerr = func(state, walk->seq, data);\r\nif (err) {\r\nlist_move_tail(&walk->all, &x->all);\r\ngoto out;\r\n}\r\nwalk->seq++;\r\n}\r\nif (walk->seq == 0) {\r\nerr = -ENOENT;\r\ngoto out;\r\n}\r\nlist_del_init(&walk->all);\r\nout:\r\nspin_unlock_bh(&net->xfrm.xfrm_state_lock);\r\nreturn err;\r\n}\r\nvoid xfrm_state_walk_init(struct xfrm_state_walk *walk, u8 proto,\r\nstruct xfrm_address_filter *filter)\r\n{\r\nINIT_LIST_HEAD(&walk->all);\r\nwalk->proto = proto;\r\nwalk->state = XFRM_STATE_DEAD;\r\nwalk->seq = 0;\r\nwalk->filter = filter;\r\n}\r\nvoid xfrm_state_walk_done(struct xfrm_state_walk *walk, struct net *net)\r\n{\r\nkfree(walk->filter);\r\nif (list_empty(&walk->all))\r\nreturn;\r\nspin_lock_bh(&net->xfrm.xfrm_state_lock);\r\nlist_del(&walk->all);\r\nspin_unlock_bh(&net->xfrm.xfrm_state_lock);\r\n}\r\nstatic void xfrm_replay_timer_handler(unsigned long data)\r\n{\r\nstruct xfrm_state *x = (struct xfrm_state *)data;\r\nspin_lock(&x->lock);\r\nif (x->km.state == XFRM_STATE_VALID) {\r\nif (xfrm_aevent_is_on(xs_net(x)))\r\nx->repl->notify(x, XFRM_REPLAY_TIMEOUT);\r\nelse\r\nx->xflags |= XFRM_TIME_DEFER;\r\n}\r\nspin_unlock(&x->lock);\r\n}\r\nvoid km_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)\r\n{\r\nstruct xfrm_mgr *km;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(km, &xfrm_km_list, list)\r\nif (km->notify_policy)\r\nkm->notify_policy(xp, dir, c);\r\nrcu_read_unlock();\r\n}\r\nvoid km_state_notify(struct xfrm_state *x, const struct km_event *c)\r\n{\r\nstruct xfrm_mgr *km;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(km, &xfrm_km_list, list)\r\nif (km->notify)\r\nkm->notify(x, c);\r\nrcu_read_unlock();\r\n}\r\nvoid km_state_expired(struct xfrm_state *x, int hard, u32 portid)\r\n{\r\nstruct km_event c;\r\nc.data.hard = hard;\r\nc.portid = portid;\r\nc.event = XFRM_MSG_EXPIRE;\r\nkm_state_notify(x, &c);\r\n}\r\nint km_query(struct xfrm_state *x, struct xfrm_tmpl *t, struct xfrm_policy *pol)\r\n{\r\nint err = -EINVAL, acqret;\r\nstruct xfrm_mgr *km;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(km, &xfrm_km_list, list) {\r\nacqret = km->acquire(x, t, pol);\r\nif (!acqret)\r\nerr = acqret;\r\n}\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nint km_new_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr, __be16 sport)\r\n{\r\nint err = -EINVAL;\r\nstruct xfrm_mgr *km;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(km, &xfrm_km_list, list) {\r\nif (km->new_mapping)\r\nerr = km->new_mapping(x, ipaddr, sport);\r\nif (!err)\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nvoid km_policy_expired(struct xfrm_policy *pol, int dir, int hard, u32 portid)\r\n{\r\nstruct km_event c;\r\nc.data.hard = hard;\r\nc.portid = portid;\r\nc.event = XFRM_MSG_POLEXPIRE;\r\nkm_policy_notify(pol, dir, &c);\r\n}\r\nint km_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\r\nconst struct xfrm_migrate *m, int num_migrate,\r\nconst struct xfrm_kmaddress *k)\r\n{\r\nint err = -EINVAL;\r\nint ret;\r\nstruct xfrm_mgr *km;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(km, &xfrm_km_list, list) {\r\nif (km->migrate) {\r\nret = km->migrate(sel, dir, type, m, num_migrate, k);\r\nif (!ret)\r\nerr = ret;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nint km_report(struct net *net, u8 proto, struct xfrm_selector *sel, xfrm_address_t *addr)\r\n{\r\nint err = -EINVAL;\r\nint ret;\r\nstruct xfrm_mgr *km;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(km, &xfrm_km_list, list) {\r\nif (km->report) {\r\nret = km->report(net, proto, sel, addr);\r\nif (!ret)\r\nerr = ret;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nbool km_is_alive(const struct km_event *c)\r\n{\r\nstruct xfrm_mgr *km;\r\nbool is_alive = false;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(km, &xfrm_km_list, list) {\r\nif (km->is_alive && km->is_alive(c)) {\r\nis_alive = true;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn is_alive;\r\n}\r\nint xfrm_user_policy(struct sock *sk, int optname, u8 __user *optval, int optlen)\r\n{\r\nint err;\r\nu8 *data;\r\nstruct xfrm_mgr *km;\r\nstruct xfrm_policy *pol = NULL;\r\nif (optlen <= 0 || optlen > PAGE_SIZE)\r\nreturn -EMSGSIZE;\r\ndata = kmalloc(optlen, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nerr = -EFAULT;\r\nif (copy_from_user(data, optval, optlen))\r\ngoto out;\r\nerr = -EINVAL;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(km, &xfrm_km_list, list) {\r\npol = km->compile_policy(sk, optname, data,\r\noptlen, &err);\r\nif (err >= 0)\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nif (err >= 0) {\r\nxfrm_sk_policy_insert(sk, err, pol);\r\nxfrm_pol_put(pol);\r\nerr = 0;\r\n}\r\nout:\r\nkfree(data);\r\nreturn err;\r\n}\r\nint xfrm_register_km(struct xfrm_mgr *km)\r\n{\r\nspin_lock_bh(&xfrm_km_lock);\r\nlist_add_tail_rcu(&km->list, &xfrm_km_list);\r\nspin_unlock_bh(&xfrm_km_lock);\r\nreturn 0;\r\n}\r\nint xfrm_unregister_km(struct xfrm_mgr *km)\r\n{\r\nspin_lock_bh(&xfrm_km_lock);\r\nlist_del_rcu(&km->list);\r\nspin_unlock_bh(&xfrm_km_lock);\r\nsynchronize_rcu();\r\nreturn 0;\r\n}\r\nint xfrm_state_register_afinfo(struct xfrm_state_afinfo *afinfo)\r\n{\r\nint err = 0;\r\nif (unlikely(afinfo == NULL))\r\nreturn -EINVAL;\r\nif (unlikely(afinfo->family >= NPROTO))\r\nreturn -EAFNOSUPPORT;\r\nspin_lock_bh(&xfrm_state_afinfo_lock);\r\nif (unlikely(xfrm_state_afinfo[afinfo->family] != NULL))\r\nerr = -ENOBUFS;\r\nelse\r\nrcu_assign_pointer(xfrm_state_afinfo[afinfo->family], afinfo);\r\nspin_unlock_bh(&xfrm_state_afinfo_lock);\r\nreturn err;\r\n}\r\nint xfrm_state_unregister_afinfo(struct xfrm_state_afinfo *afinfo)\r\n{\r\nint err = 0;\r\nif (unlikely(afinfo == NULL))\r\nreturn -EINVAL;\r\nif (unlikely(afinfo->family >= NPROTO))\r\nreturn -EAFNOSUPPORT;\r\nspin_lock_bh(&xfrm_state_afinfo_lock);\r\nif (likely(xfrm_state_afinfo[afinfo->family] != NULL)) {\r\nif (unlikely(xfrm_state_afinfo[afinfo->family] != afinfo))\r\nerr = -EINVAL;\r\nelse\r\nRCU_INIT_POINTER(xfrm_state_afinfo[afinfo->family], NULL);\r\n}\r\nspin_unlock_bh(&xfrm_state_afinfo_lock);\r\nsynchronize_rcu();\r\nreturn err;\r\n}\r\nstruct xfrm_state_afinfo *xfrm_state_get_afinfo(unsigned int family)\r\n{\r\nstruct xfrm_state_afinfo *afinfo;\r\nif (unlikely(family >= NPROTO))\r\nreturn NULL;\r\nrcu_read_lock();\r\nafinfo = rcu_dereference(xfrm_state_afinfo[family]);\r\nif (unlikely(!afinfo))\r\nrcu_read_unlock();\r\nreturn afinfo;\r\n}\r\nvoid xfrm_state_put_afinfo(struct xfrm_state_afinfo *afinfo)\r\n{\r\nrcu_read_unlock();\r\n}\r\nvoid xfrm_state_delete_tunnel(struct xfrm_state *x)\r\n{\r\nif (x->tunnel) {\r\nstruct xfrm_state *t = x->tunnel;\r\nif (atomic_read(&t->tunnel_users) == 2)\r\nxfrm_state_delete(t);\r\natomic_dec(&t->tunnel_users);\r\nxfrm_state_put(t);\r\nx->tunnel = NULL;\r\n}\r\n}\r\nint xfrm_state_mtu(struct xfrm_state *x, int mtu)\r\n{\r\nint res;\r\nspin_lock_bh(&x->lock);\r\nif (x->km.state == XFRM_STATE_VALID &&\r\nx->type && x->type->get_mtu)\r\nres = x->type->get_mtu(x, mtu);\r\nelse\r\nres = mtu - x->props.header_len;\r\nspin_unlock_bh(&x->lock);\r\nreturn res;\r\n}\r\nint __xfrm_init_state(struct xfrm_state *x, bool init_replay)\r\n{\r\nstruct xfrm_state_afinfo *afinfo;\r\nstruct xfrm_mode *inner_mode;\r\nint family = x->props.family;\r\nint err;\r\nerr = -EAFNOSUPPORT;\r\nafinfo = xfrm_state_get_afinfo(family);\r\nif (!afinfo)\r\ngoto error;\r\nerr = 0;\r\nif (afinfo->init_flags)\r\nerr = afinfo->init_flags(x);\r\nxfrm_state_put_afinfo(afinfo);\r\nif (err)\r\ngoto error;\r\nerr = -EPROTONOSUPPORT;\r\nif (x->sel.family != AF_UNSPEC) {\r\ninner_mode = xfrm_get_mode(x->props.mode, x->sel.family);\r\nif (inner_mode == NULL)\r\ngoto error;\r\nif (!(inner_mode->flags & XFRM_MODE_FLAG_TUNNEL) &&\r\nfamily != x->sel.family) {\r\nxfrm_put_mode(inner_mode);\r\ngoto error;\r\n}\r\nx->inner_mode = inner_mode;\r\n} else {\r\nstruct xfrm_mode *inner_mode_iaf;\r\nint iafamily = AF_INET;\r\ninner_mode = xfrm_get_mode(x->props.mode, x->props.family);\r\nif (inner_mode == NULL)\r\ngoto error;\r\nif (!(inner_mode->flags & XFRM_MODE_FLAG_TUNNEL)) {\r\nxfrm_put_mode(inner_mode);\r\ngoto error;\r\n}\r\nx->inner_mode = inner_mode;\r\nif (x->props.family == AF_INET)\r\niafamily = AF_INET6;\r\ninner_mode_iaf = xfrm_get_mode(x->props.mode, iafamily);\r\nif (inner_mode_iaf) {\r\nif (inner_mode_iaf->flags & XFRM_MODE_FLAG_TUNNEL)\r\nx->inner_mode_iaf = inner_mode_iaf;\r\nelse\r\nxfrm_put_mode(inner_mode_iaf);\r\n}\r\n}\r\nx->type = xfrm_get_type(x->id.proto, family);\r\nif (x->type == NULL)\r\ngoto error;\r\nerr = x->type->init_state(x);\r\nif (err)\r\ngoto error;\r\nx->outer_mode = xfrm_get_mode(x->props.mode, family);\r\nif (x->outer_mode == NULL) {\r\nerr = -EPROTONOSUPPORT;\r\ngoto error;\r\n}\r\nif (init_replay) {\r\nerr = xfrm_init_replay(x);\r\nif (err)\r\ngoto error;\r\n}\r\nx->km.state = XFRM_STATE_VALID;\r\nerror:\r\nreturn err;\r\n}\r\nint xfrm_init_state(struct xfrm_state *x)\r\n{\r\nreturn __xfrm_init_state(x, true);\r\n}\r\nint __net_init xfrm_state_init(struct net *net)\r\n{\r\nunsigned int sz;\r\nINIT_LIST_HEAD(&net->xfrm.state_all);\r\nsz = sizeof(struct hlist_head) * 8;\r\nnet->xfrm.state_bydst = xfrm_hash_alloc(sz);\r\nif (!net->xfrm.state_bydst)\r\ngoto out_bydst;\r\nnet->xfrm.state_bysrc = xfrm_hash_alloc(sz);\r\nif (!net->xfrm.state_bysrc)\r\ngoto out_bysrc;\r\nnet->xfrm.state_byspi = xfrm_hash_alloc(sz);\r\nif (!net->xfrm.state_byspi)\r\ngoto out_byspi;\r\nnet->xfrm.state_hmask = ((sz / sizeof(struct hlist_head)) - 1);\r\nnet->xfrm.state_num = 0;\r\nINIT_WORK(&net->xfrm.state_hash_work, xfrm_hash_resize);\r\nINIT_HLIST_HEAD(&net->xfrm.state_gc_list);\r\nINIT_WORK(&net->xfrm.state_gc_work, xfrm_state_gc_task);\r\nspin_lock_init(&net->xfrm.xfrm_state_lock);\r\nreturn 0;\r\nout_byspi:\r\nxfrm_hash_free(net->xfrm.state_bysrc, sz);\r\nout_bysrc:\r\nxfrm_hash_free(net->xfrm.state_bydst, sz);\r\nout_bydst:\r\nreturn -ENOMEM;\r\n}\r\nvoid xfrm_state_fini(struct net *net)\r\n{\r\nunsigned int sz;\r\nflush_work(&net->xfrm.state_hash_work);\r\nxfrm_state_flush(net, IPSEC_PROTO_ANY, false);\r\nflush_work(&net->xfrm.state_gc_work);\r\nWARN_ON(!list_empty(&net->xfrm.state_all));\r\nsz = (net->xfrm.state_hmask + 1) * sizeof(struct hlist_head);\r\nWARN_ON(!hlist_empty(net->xfrm.state_byspi));\r\nxfrm_hash_free(net->xfrm.state_byspi, sz);\r\nWARN_ON(!hlist_empty(net->xfrm.state_bysrc));\r\nxfrm_hash_free(net->xfrm.state_bysrc, sz);\r\nWARN_ON(!hlist_empty(net->xfrm.state_bydst));\r\nxfrm_hash_free(net->xfrm.state_bydst, sz);\r\n}\r\nstatic void xfrm_audit_helper_sainfo(struct xfrm_state *x,\r\nstruct audit_buffer *audit_buf)\r\n{\r\nstruct xfrm_sec_ctx *ctx = x->security;\r\nu32 spi = ntohl(x->id.spi);\r\nif (ctx)\r\naudit_log_format(audit_buf, " sec_alg=%u sec_doi=%u sec_obj=%s",\r\nctx->ctx_alg, ctx->ctx_doi, ctx->ctx_str);\r\nswitch (x->props.family) {\r\ncase AF_INET:\r\naudit_log_format(audit_buf, " src=%pI4 dst=%pI4",\r\n&x->props.saddr.a4, &x->id.daddr.a4);\r\nbreak;\r\ncase AF_INET6:\r\naudit_log_format(audit_buf, " src=%pI6 dst=%pI6",\r\nx->props.saddr.a6, x->id.daddr.a6);\r\nbreak;\r\n}\r\naudit_log_format(audit_buf, " spi=%u(0x%x)", spi, spi);\r\n}\r\nstatic void xfrm_audit_helper_pktinfo(struct sk_buff *skb, u16 family,\r\nstruct audit_buffer *audit_buf)\r\n{\r\nconst struct iphdr *iph4;\r\nconst struct ipv6hdr *iph6;\r\nswitch (family) {\r\ncase AF_INET:\r\niph4 = ip_hdr(skb);\r\naudit_log_format(audit_buf, " src=%pI4 dst=%pI4",\r\n&iph4->saddr, &iph4->daddr);\r\nbreak;\r\ncase AF_INET6:\r\niph6 = ipv6_hdr(skb);\r\naudit_log_format(audit_buf,\r\n" src=%pI6 dst=%pI6 flowlbl=0x%x%02x%02x",\r\n&iph6->saddr, &iph6->daddr,\r\niph6->flow_lbl[0] & 0x0f,\r\niph6->flow_lbl[1],\r\niph6->flow_lbl[2]);\r\nbreak;\r\n}\r\n}\r\nvoid xfrm_audit_state_add(struct xfrm_state *x, int result, bool task_valid)\r\n{\r\nstruct audit_buffer *audit_buf;\r\naudit_buf = xfrm_audit_start("SAD-add");\r\nif (audit_buf == NULL)\r\nreturn;\r\nxfrm_audit_helper_usrinfo(task_valid, audit_buf);\r\nxfrm_audit_helper_sainfo(x, audit_buf);\r\naudit_log_format(audit_buf, " res=%u", result);\r\naudit_log_end(audit_buf);\r\n}\r\nvoid xfrm_audit_state_delete(struct xfrm_state *x, int result, bool task_valid)\r\n{\r\nstruct audit_buffer *audit_buf;\r\naudit_buf = xfrm_audit_start("SAD-delete");\r\nif (audit_buf == NULL)\r\nreturn;\r\nxfrm_audit_helper_usrinfo(task_valid, audit_buf);\r\nxfrm_audit_helper_sainfo(x, audit_buf);\r\naudit_log_format(audit_buf, " res=%u", result);\r\naudit_log_end(audit_buf);\r\n}\r\nvoid xfrm_audit_state_replay_overflow(struct xfrm_state *x,\r\nstruct sk_buff *skb)\r\n{\r\nstruct audit_buffer *audit_buf;\r\nu32 spi;\r\naudit_buf = xfrm_audit_start("SA-replay-overflow");\r\nif (audit_buf == NULL)\r\nreturn;\r\nxfrm_audit_helper_pktinfo(skb, x->props.family, audit_buf);\r\nspi = ntohl(x->id.spi);\r\naudit_log_format(audit_buf, " spi=%u(0x%x)", spi, spi);\r\naudit_log_end(audit_buf);\r\n}\r\nvoid xfrm_audit_state_replay(struct xfrm_state *x,\r\nstruct sk_buff *skb, __be32 net_seq)\r\n{\r\nstruct audit_buffer *audit_buf;\r\nu32 spi;\r\naudit_buf = xfrm_audit_start("SA-replayed-pkt");\r\nif (audit_buf == NULL)\r\nreturn;\r\nxfrm_audit_helper_pktinfo(skb, x->props.family, audit_buf);\r\nspi = ntohl(x->id.spi);\r\naudit_log_format(audit_buf, " spi=%u(0x%x) seqno=%u",\r\nspi, spi, ntohl(net_seq));\r\naudit_log_end(audit_buf);\r\n}\r\nvoid xfrm_audit_state_notfound_simple(struct sk_buff *skb, u16 family)\r\n{\r\nstruct audit_buffer *audit_buf;\r\naudit_buf = xfrm_audit_start("SA-notfound");\r\nif (audit_buf == NULL)\r\nreturn;\r\nxfrm_audit_helper_pktinfo(skb, family, audit_buf);\r\naudit_log_end(audit_buf);\r\n}\r\nvoid xfrm_audit_state_notfound(struct sk_buff *skb, u16 family,\r\n__be32 net_spi, __be32 net_seq)\r\n{\r\nstruct audit_buffer *audit_buf;\r\nu32 spi;\r\naudit_buf = xfrm_audit_start("SA-notfound");\r\nif (audit_buf == NULL)\r\nreturn;\r\nxfrm_audit_helper_pktinfo(skb, family, audit_buf);\r\nspi = ntohl(net_spi);\r\naudit_log_format(audit_buf, " spi=%u(0x%x) seqno=%u",\r\nspi, spi, ntohl(net_seq));\r\naudit_log_end(audit_buf);\r\n}\r\nvoid xfrm_audit_state_icvfail(struct xfrm_state *x,\r\nstruct sk_buff *skb, u8 proto)\r\n{\r\nstruct audit_buffer *audit_buf;\r\n__be32 net_spi;\r\n__be32 net_seq;\r\naudit_buf = xfrm_audit_start("SA-icv-failure");\r\nif (audit_buf == NULL)\r\nreturn;\r\nxfrm_audit_helper_pktinfo(skb, x->props.family, audit_buf);\r\nif (xfrm_parse_spi(skb, proto, &net_spi, &net_seq) == 0) {\r\nu32 spi = ntohl(net_spi);\r\naudit_log_format(audit_buf, " spi=%u(0x%x) seqno=%u",\r\nspi, spi, ntohl(net_seq));\r\n}\r\naudit_log_end(audit_buf);\r\n}
