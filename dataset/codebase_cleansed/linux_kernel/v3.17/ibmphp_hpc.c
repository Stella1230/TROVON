void __init ibmphp_hpc_initvars (void)\r\n{\r\ndebug ("%s - Entry\n", __func__);\r\nmutex_init(&sem_hpcaccess);\r\nsema_init(&semOperations, 1);\r\nsema_init(&sem_exit, 0);\r\nto_debug = 0;\r\ndebug ("%s - Exit\n", __func__);\r\n}\r\nstatic u8 i2c_ctrl_read (struct controller *ctlr_ptr, void __iomem *WPGBbar, u8 index)\r\n{\r\nu8 status;\r\nint i;\r\nvoid __iomem *wpg_addr;\r\nunsigned long wpg_data;\r\nunsigned long ultemp;\r\nunsigned long data;\r\ndebug_polling ("%s - Entry WPGBbar[%p] index[%x] \n", __func__, WPGBbar, index);\r\nif (ctlr_ptr->ctlr_type == 0x02) {\r\ndata = WPG_READATADDR_MASK;\r\nultemp = (unsigned long)ctlr_ptr->u.wpeg_ctlr.i2c_addr;\r\nultemp = ultemp >> 1;\r\ndata |= (ultemp << 8);\r\ndata |= (unsigned long)index;\r\n} else if (ctlr_ptr->ctlr_type == 0x04) {\r\ndata = WPG_READDIRECT_MASK;\r\nultemp = (unsigned long)index;\r\nultemp = ultemp << 8;\r\ndata |= ultemp;\r\n} else {\r\nerr ("this controller type is not supported \n");\r\nreturn HPC_ERROR;\r\n}\r\nwpg_data = swab32 (data);\r\nwpg_addr = WPGBbar + WPG_I2CMOSUP_OFFSET;\r\nwritel (wpg_data, wpg_addr);\r\ndata = 0x00000000;\r\nwpg_data = swab32 (data);\r\nwpg_addr = WPGBbar + WPG_I2CMBUFL_OFFSET;\r\nwritel (wpg_data, wpg_addr);\r\ndata = WPG_I2CMCNTL_STARTOP_MASK;\r\nwpg_data = swab32 (data);\r\nwpg_addr = WPGBbar + WPG_I2CMCNTL_OFFSET + WPG_I2C_OR;\r\nwritel (wpg_data, wpg_addr);\r\ni = CMD_COMPLETE_TOUT_SEC;\r\nwhile (i) {\r\nmsleep(10);\r\nwpg_addr = WPGBbar + WPG_I2CMCNTL_OFFSET;\r\nwpg_data = readl (wpg_addr);\r\ndata = swab32 (wpg_data);\r\nif (!(data & WPG_I2CMCNTL_STARTOP_MASK))\r\nbreak;\r\ni--;\r\n}\r\nif (i == 0) {\r\ndebug ("%s - Error : WPG timeout\n", __func__);\r\nreturn HPC_ERROR;\r\n}\r\ni = CMD_COMPLETE_TOUT_SEC;\r\nwhile (i) {\r\nmsleep(10);\r\nwpg_addr = WPGBbar + WPG_I2CSTAT_OFFSET;\r\nwpg_data = readl (wpg_addr);\r\ndata = swab32 (wpg_data);\r\nif (HPC_I2CSTATUS_CHECK (data))\r\nbreak;\r\ni--;\r\n}\r\nif (i == 0) {\r\ndebug ("ctrl_read - Exit Error:I2C timeout\n");\r\nreturn HPC_ERROR;\r\n}\r\nwpg_addr = WPGBbar + WPG_I2CMBUFL_OFFSET;\r\nwpg_data = readl (wpg_addr);\r\ndata = swab32 (wpg_data);\r\nstatus = (u8) data;\r\ndebug_polling ("%s - Exit index[%x] status[%x]\n", __func__, index, status);\r\nreturn (status);\r\n}\r\nstatic u8 i2c_ctrl_write (struct controller *ctlr_ptr, void __iomem *WPGBbar, u8 index, u8 cmd)\r\n{\r\nu8 rc;\r\nvoid __iomem *wpg_addr;\r\nunsigned long wpg_data;\r\nunsigned long ultemp;\r\nunsigned long data;\r\nint i;\r\ndebug_polling ("%s - Entry WPGBbar[%p] index[%x] cmd[%x]\n", __func__, WPGBbar, index, cmd);\r\nrc = 0;\r\ndata = 0x00000000;\r\nif (ctlr_ptr->ctlr_type == 0x02) {\r\ndata = WPG_WRITEATADDR_MASK;\r\nultemp = (unsigned long)ctlr_ptr->u.wpeg_ctlr.i2c_addr;\r\nultemp = ultemp >> 1;\r\ndata |= (ultemp << 8);\r\ndata |= (unsigned long)index;\r\n} else if (ctlr_ptr->ctlr_type == 0x04) {\r\ndata = WPG_WRITEDIRECT_MASK;\r\nultemp = (unsigned long)index;\r\nultemp = ultemp << 8;\r\ndata |= ultemp;\r\n} else {\r\nerr ("this controller type is not supported \n");\r\nreturn HPC_ERROR;\r\n}\r\nwpg_data = swab32 (data);\r\nwpg_addr = WPGBbar + WPG_I2CMOSUP_OFFSET;\r\nwritel (wpg_data, wpg_addr);\r\ndata = 0x00000000 | (unsigned long)cmd;\r\nwpg_data = swab32 (data);\r\nwpg_addr = WPGBbar + WPG_I2CMBUFL_OFFSET;\r\nwritel (wpg_data, wpg_addr);\r\ndata = WPG_I2CMCNTL_STARTOP_MASK;\r\nwpg_data = swab32 (data);\r\nwpg_addr = WPGBbar + WPG_I2CMCNTL_OFFSET + WPG_I2C_OR;\r\nwritel (wpg_data, wpg_addr);\r\ni = CMD_COMPLETE_TOUT_SEC;\r\nwhile (i) {\r\nmsleep(10);\r\nwpg_addr = WPGBbar + WPG_I2CMCNTL_OFFSET;\r\nwpg_data = readl (wpg_addr);\r\ndata = swab32 (wpg_data);\r\nif (!(data & WPG_I2CMCNTL_STARTOP_MASK))\r\nbreak;\r\ni--;\r\n}\r\nif (i == 0) {\r\ndebug ("%s - Exit Error:WPG timeout\n", __func__);\r\nrc = HPC_ERROR;\r\n}\r\ni = CMD_COMPLETE_TOUT_SEC;\r\nwhile (i) {\r\nmsleep(10);\r\nwpg_addr = WPGBbar + WPG_I2CSTAT_OFFSET;\r\nwpg_data = readl (wpg_addr);\r\ndata = swab32 (wpg_data);\r\nif (HPC_I2CSTATUS_CHECK (data))\r\nbreak;\r\ni--;\r\n}\r\nif (i == 0) {\r\ndebug ("ctrl_read - Error : I2C timeout\n");\r\nrc = HPC_ERROR;\r\n}\r\ndebug_polling ("%s Exit rc[%x]\n", __func__, rc);\r\nreturn (rc);\r\n}\r\nstatic u8 isa_ctrl_read (struct controller *ctlr_ptr, u8 offset)\r\n{\r\nu16 start_address;\r\nu16 end_address;\r\nu8 data;\r\nstart_address = ctlr_ptr->u.isa_ctlr.io_start;\r\nend_address = ctlr_ptr->u.isa_ctlr.io_end;\r\ndata = inb (start_address + offset);\r\nreturn data;\r\n}\r\nstatic void isa_ctrl_write (struct controller *ctlr_ptr, u8 offset, u8 data)\r\n{\r\nu16 start_address;\r\nu16 port_address;\r\nstart_address = ctlr_ptr->u.isa_ctlr.io_start;\r\nport_address = start_address + (u16) offset;\r\noutb (data, port_address);\r\n}\r\nstatic u8 pci_ctrl_read (struct controller *ctrl, u8 offset)\r\n{\r\nu8 data = 0x00;\r\ndebug ("inside pci_ctrl_read\n");\r\nif (ctrl->ctrl_dev)\r\npci_read_config_byte (ctrl->ctrl_dev, HPC_PCI_OFFSET + offset, &data);\r\nreturn data;\r\n}\r\nstatic u8 pci_ctrl_write (struct controller *ctrl, u8 offset, u8 data)\r\n{\r\nu8 rc = -ENODEV;\r\ndebug ("inside pci_ctrl_write\n");\r\nif (ctrl->ctrl_dev) {\r\npci_write_config_byte (ctrl->ctrl_dev, HPC_PCI_OFFSET + offset, data);\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nstatic u8 ctrl_read (struct controller *ctlr, void __iomem *base, u8 offset)\r\n{\r\nu8 rc;\r\nswitch (ctlr->ctlr_type) {\r\ncase 0:\r\nrc = isa_ctrl_read (ctlr, offset);\r\nbreak;\r\ncase 1:\r\nrc = pci_ctrl_read (ctlr, offset);\r\nbreak;\r\ncase 2:\r\ncase 4:\r\nrc = i2c_ctrl_read (ctlr, base, offset);\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nreturn rc;\r\n}\r\nstatic u8 ctrl_write (struct controller *ctlr, void __iomem *base, u8 offset, u8 data)\r\n{\r\nu8 rc = 0;\r\nswitch (ctlr->ctlr_type) {\r\ncase 0:\r\nisa_ctrl_write(ctlr, offset, data);\r\nbreak;\r\ncase 1:\r\nrc = pci_ctrl_write (ctlr, offset, data);\r\nbreak;\r\ncase 2:\r\ncase 4:\r\nrc = i2c_ctrl_write(ctlr, base, offset, data);\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nreturn rc;\r\n}\r\nstatic u8 hpc_writecmdtoindex (u8 cmd, u8 index)\r\n{\r\nu8 rc;\r\nswitch (cmd) {\r\ncase HPC_CTLR_ENABLEIRQ:\r\ncase HPC_CTLR_CLEARIRQ:\r\ncase HPC_CTLR_RESET:\r\ncase HPC_CTLR_IRQSTEER:\r\ncase HPC_CTLR_DISABLEIRQ:\r\ncase HPC_ALLSLOT_ON:\r\ncase HPC_ALLSLOT_OFF:\r\nrc = 0x0F;\r\nbreak;\r\ncase HPC_SLOT_OFF:\r\ncase HPC_SLOT_ON:\r\ncase HPC_SLOT_ATTNOFF:\r\ncase HPC_SLOT_ATTNON:\r\ncase HPC_SLOT_BLINKLED:\r\nrc = index;\r\nbreak;\r\ncase HPC_BUS_33CONVMODE:\r\ncase HPC_BUS_66CONVMODE:\r\ncase HPC_BUS_66PCIXMODE:\r\ncase HPC_BUS_100PCIXMODE:\r\ncase HPC_BUS_133PCIXMODE:\r\nrc = index + WPG_1ST_BUS_INDEX - 1;\r\nbreak;\r\ndefault:\r\nerr ("hpc_writecmdtoindex - Error invalid cmd[%x]\n", cmd);\r\nrc = HPC_ERROR;\r\n}\r\nreturn rc;\r\n}\r\nstatic u8 hpc_readcmdtoindex (u8 cmd, u8 index)\r\n{\r\nu8 rc;\r\nswitch (cmd) {\r\ncase READ_CTLRSTATUS:\r\nrc = 0x0F;\r\nbreak;\r\ncase READ_SLOTSTATUS:\r\ncase READ_ALLSTAT:\r\nrc = index;\r\nbreak;\r\ncase READ_EXTSLOTSTATUS:\r\nrc = index + WPG_1ST_EXTSLOT_INDEX;\r\nbreak;\r\ncase READ_BUSSTATUS:\r\nrc = index + WPG_1ST_BUS_INDEX - 1;\r\nbreak;\r\ncase READ_SLOTLATCHLOWREG:\r\nrc = 0x28;\r\nbreak;\r\ncase READ_REVLEVEL:\r\nrc = 0x25;\r\nbreak;\r\ncase READ_HPCOPTIONS:\r\nrc = 0x27;\r\nbreak;\r\ndefault:\r\nrc = HPC_ERROR;\r\n}\r\nreturn rc;\r\n}\r\nint ibmphp_hpc_readslot (struct slot *pslot, u8 cmd, u8 *pstatus)\r\n{\r\nvoid __iomem *wpg_bbar = NULL;\r\nstruct controller *ctlr_ptr;\r\nstruct list_head *pslotlist;\r\nu8 index, status;\r\nint rc = 0;\r\nint busindex;\r\ndebug_polling ("%s - Entry pslot[%p] cmd[%x] pstatus[%p]\n", __func__, pslot, cmd, pstatus);\r\nif ((pslot == NULL)\r\n|| ((pstatus == NULL) && (cmd != READ_ALLSTAT) && (cmd != READ_BUSSTATUS))) {\r\nrc = -EINVAL;\r\nerr ("%s - Error invalid pointer, rc[%d]\n", __func__, rc);\r\nreturn rc;\r\n}\r\nif (cmd == READ_BUSSTATUS) {\r\nbusindex = ibmphp_get_bus_index (pslot->bus);\r\nif (busindex < 0) {\r\nrc = -EINVAL;\r\nerr ("%s - Exit Error:invalid bus, rc[%d]\n", __func__, rc);\r\nreturn rc;\r\n} else\r\nindex = (u8) busindex;\r\n} else\r\nindex = pslot->ctlr_index;\r\nindex = hpc_readcmdtoindex (cmd, index);\r\nif (index == HPC_ERROR) {\r\nrc = -EINVAL;\r\nerr ("%s - Exit Error:invalid index, rc[%d]\n", __func__, rc);\r\nreturn rc;\r\n}\r\nctlr_ptr = pslot->ctrl;\r\nget_hpc_access ();\r\nif ((ctlr_ptr->ctlr_type == 2) || (ctlr_ptr->ctlr_type == 4))\r\nwpg_bbar = ioremap (ctlr_ptr->u.wpeg_ctlr.wpegbbar, WPG_I2C_IOREMAP_SIZE);\r\nrc = hpc_wait_ctlr_notworking (HPC_CTLR_WORKING_TOUT, ctlr_ptr, wpg_bbar, &status);\r\nif (!rc) {\r\nswitch (cmd) {\r\ncase READ_ALLSTAT:\r\npslot->ctrl->status = status;\r\npslot->status = ctrl_read (ctlr_ptr, wpg_bbar, index);\r\nrc = hpc_wait_ctlr_notworking (HPC_CTLR_WORKING_TOUT, ctlr_ptr, wpg_bbar,\r\n&status);\r\nif (!rc)\r\npslot->ext_status = ctrl_read (ctlr_ptr, wpg_bbar, index + WPG_1ST_EXTSLOT_INDEX);\r\nbreak;\r\ncase READ_SLOTSTATUS:\r\n*pstatus = ctrl_read (ctlr_ptr, wpg_bbar, index);\r\nbreak;\r\ncase READ_EXTSLOTSTATUS:\r\n*pstatus = ctrl_read (ctlr_ptr, wpg_bbar, index);\r\nbreak;\r\ncase READ_CTLRSTATUS:\r\n*pstatus = status;\r\nbreak;\r\ncase READ_BUSSTATUS:\r\npslot->busstatus = ctrl_read (ctlr_ptr, wpg_bbar, index);\r\nbreak;\r\ncase READ_REVLEVEL:\r\n*pstatus = ctrl_read (ctlr_ptr, wpg_bbar, index);\r\nbreak;\r\ncase READ_HPCOPTIONS:\r\n*pstatus = ctrl_read (ctlr_ptr, wpg_bbar, index);\r\nbreak;\r\ncase READ_SLOTLATCHLOWREG:\r\n*pstatus = ctrl_read (ctlr_ptr, wpg_bbar, index);\r\nbreak;\r\ncase READ_ALLSLOT:\r\nlist_for_each (pslotlist, &ibmphp_slot_head) {\r\npslot = list_entry (pslotlist, struct slot, ibm_slot_list);\r\nindex = pslot->ctlr_index;\r\nrc = hpc_wait_ctlr_notworking (HPC_CTLR_WORKING_TOUT, ctlr_ptr,\r\nwpg_bbar, &status);\r\nif (!rc) {\r\npslot->status = ctrl_read (ctlr_ptr, wpg_bbar, index);\r\nrc = hpc_wait_ctlr_notworking (HPC_CTLR_WORKING_TOUT,\r\nctlr_ptr, wpg_bbar, &status);\r\nif (!rc)\r\npslot->ext_status =\r\nctrl_read (ctlr_ptr, wpg_bbar,\r\nindex + WPG_1ST_EXTSLOT_INDEX);\r\n} else {\r\nerr ("%s - Error ctrl_read failed\n", __func__);\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\n}\r\nif ((ctlr_ptr->ctlr_type == 2) || (ctlr_ptr->ctlr_type == 4))\r\niounmap (wpg_bbar);\r\nfree_hpc_access ();\r\ndebug_polling ("%s - Exit rc[%d]\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint ibmphp_hpc_writeslot (struct slot *pslot, u8 cmd)\r\n{\r\nvoid __iomem *wpg_bbar = NULL;\r\nstruct controller *ctlr_ptr;\r\nu8 index, status;\r\nint busindex;\r\nu8 done;\r\nint rc = 0;\r\nint timeout;\r\ndebug_polling ("%s - Entry pslot[%p] cmd[%x]\n", __func__, pslot, cmd);\r\nif (pslot == NULL) {\r\nrc = -EINVAL;\r\nerr ("%s - Error Exit rc[%d]\n", __func__, rc);\r\nreturn rc;\r\n}\r\nif ((cmd == HPC_BUS_33CONVMODE) || (cmd == HPC_BUS_66CONVMODE) ||\r\n(cmd == HPC_BUS_66PCIXMODE) || (cmd == HPC_BUS_100PCIXMODE) ||\r\n(cmd == HPC_BUS_133PCIXMODE)) {\r\nbusindex = ibmphp_get_bus_index (pslot->bus);\r\nif (busindex < 0) {\r\nrc = -EINVAL;\r\nerr ("%s - Exit Error:invalid bus, rc[%d]\n", __func__, rc);\r\nreturn rc;\r\n} else\r\nindex = (u8) busindex;\r\n} else\r\nindex = pslot->ctlr_index;\r\nindex = hpc_writecmdtoindex (cmd, index);\r\nif (index == HPC_ERROR) {\r\nrc = -EINVAL;\r\nerr ("%s - Error Exit rc[%d]\n", __func__, rc);\r\nreturn rc;\r\n}\r\nctlr_ptr = pslot->ctrl;\r\nget_hpc_access ();\r\nif ((ctlr_ptr->ctlr_type == 2) || (ctlr_ptr->ctlr_type == 4)) {\r\nwpg_bbar = ioremap (ctlr_ptr->u.wpeg_ctlr.wpegbbar, WPG_I2C_IOREMAP_SIZE);\r\ndebug ("%s - ctlr id[%x] physical[%lx] logical[%lx] i2c[%x]\n", __func__,\r\nctlr_ptr->ctlr_id, (ulong) (ctlr_ptr->u.wpeg_ctlr.wpegbbar), (ulong) wpg_bbar,\r\nctlr_ptr->u.wpeg_ctlr.i2c_addr);\r\n}\r\nrc = hpc_wait_ctlr_notworking (HPC_CTLR_WORKING_TOUT, ctlr_ptr, wpg_bbar, &status);\r\nif (!rc) {\r\nctrl_write (ctlr_ptr, wpg_bbar, index, cmd);\r\ntimeout = CMD_COMPLETE_TOUT_SEC;\r\ndone = 0;\r\nwhile (!done) {\r\nrc = hpc_wait_ctlr_notworking (HPC_CTLR_WORKING_TOUT, ctlr_ptr, wpg_bbar,\r\n&status);\r\nif (!rc) {\r\nif (NEEDTOCHECK_CMDSTATUS (cmd)) {\r\nif (CTLR_FINISHED (status) == HPC_CTLR_FINISHED_YES)\r\ndone = 1;\r\n} else\r\ndone = 1;\r\n}\r\nif (!done) {\r\nmsleep(1000);\r\nif (timeout < 1) {\r\ndone = 1;\r\nerr ("%s - Error command complete timeout\n", __func__);\r\nrc = -EFAULT;\r\n} else\r\ntimeout--;\r\n}\r\n}\r\nctlr_ptr->status = status;\r\n}\r\nif ((ctlr_ptr->ctlr_type == 2) || (ctlr_ptr->ctlr_type == 4))\r\niounmap (wpg_bbar);\r\nfree_hpc_access ();\r\ndebug_polling ("%s - Exit rc[%d]\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic void get_hpc_access (void)\r\n{\r\nmutex_lock(&sem_hpcaccess);\r\n}\r\nvoid free_hpc_access (void)\r\n{\r\nmutex_unlock(&sem_hpcaccess);\r\n}\r\nvoid ibmphp_lock_operations (void)\r\n{\r\ndown (&semOperations);\r\nto_debug = 1;\r\n}\r\nvoid ibmphp_unlock_operations (void)\r\n{\r\ndebug ("%s - Entry\n", __func__);\r\nup (&semOperations);\r\nto_debug = 0;\r\ndebug ("%s - Exit\n", __func__);\r\n}\r\nstatic int poll_hpc(void *data)\r\n{\r\nstruct slot myslot;\r\nstruct slot *pslot = NULL;\r\nstruct list_head *pslotlist;\r\nint rc;\r\nint poll_state = POLL_LATCH_REGISTER;\r\nu8 oldlatchlow = 0x00;\r\nu8 curlatchlow = 0x00;\r\nint poll_count = 0;\r\nu8 ctrl_count = 0x00;\r\ndebug ("%s - Entry\n", __func__);\r\nwhile (!kthread_should_stop()) {\r\ndown (&semOperations);\r\nswitch (poll_state) {\r\ncase POLL_LATCH_REGISTER:\r\noldlatchlow = curlatchlow;\r\nctrl_count = 0x00;\r\nlist_for_each (pslotlist, &ibmphp_slot_head) {\r\nif (ctrl_count >= ibmphp_get_total_controllers())\r\nbreak;\r\npslot = list_entry (pslotlist, struct slot, ibm_slot_list);\r\nif (pslot->ctrl->ctlr_relative_id == ctrl_count) {\r\nctrl_count++;\r\nif (READ_SLOT_LATCH (pslot->ctrl)) {\r\nrc = ibmphp_hpc_readslot (pslot,\r\nREAD_SLOTLATCHLOWREG,\r\n&curlatchlow);\r\nif (oldlatchlow != curlatchlow)\r\nprocess_changeinlatch (oldlatchlow,\r\ncurlatchlow,\r\npslot->ctrl);\r\n}\r\n}\r\n}\r\n++poll_count;\r\npoll_state = POLL_SLEEP;\r\nbreak;\r\ncase POLL_SLOTS:\r\nlist_for_each (pslotlist, &ibmphp_slot_head) {\r\npslot = list_entry (pslotlist, struct slot, ibm_slot_list);\r\nmemcpy ((void *) &myslot, (void *) pslot,\r\nsizeof (struct slot));\r\nrc = ibmphp_hpc_readslot (pslot, READ_ALLSTAT, NULL);\r\nif ((myslot.status != pslot->status)\r\n|| (myslot.ext_status != pslot->ext_status))\r\nprocess_changeinstatus (pslot, &myslot);\r\n}\r\nctrl_count = 0x00;\r\nlist_for_each (pslotlist, &ibmphp_slot_head) {\r\nif (ctrl_count >= ibmphp_get_total_controllers())\r\nbreak;\r\npslot = list_entry (pslotlist, struct slot, ibm_slot_list);\r\nif (pslot->ctrl->ctlr_relative_id == ctrl_count) {\r\nctrl_count++;\r\nif (READ_SLOT_LATCH (pslot->ctrl))\r\nrc = ibmphp_hpc_readslot (pslot,\r\nREAD_SLOTLATCHLOWREG,\r\n&curlatchlow);\r\n}\r\n}\r\n++poll_count;\r\npoll_state = POLL_SLEEP;\r\nbreak;\r\ncase POLL_SLEEP:\r\nup (&semOperations);\r\nmsleep(POLL_INTERVAL_SEC * 1000);\r\nif (kthread_should_stop())\r\ngoto out_sleep;\r\ndown (&semOperations);\r\nif (poll_count >= POLL_LATCH_CNT) {\r\npoll_count = 0;\r\npoll_state = POLL_SLOTS;\r\n} else\r\npoll_state = POLL_LATCH_REGISTER;\r\nbreak;\r\n}\r\nup (&semOperations);\r\nout_sleep:\r\nmsleep(100);\r\n}\r\nup (&sem_exit);\r\ndebug ("%s - Exit\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int process_changeinstatus (struct slot *pslot, struct slot *poldslot)\r\n{\r\nu8 status;\r\nint rc = 0;\r\nu8 disable = 0;\r\nu8 update = 0;\r\ndebug ("process_changeinstatus - Entry pslot[%p], poldslot[%p]\n", pslot, poldslot);\r\nif ((pslot->status & 0x01) != (poldslot->status & 0x01))\r\nupdate = 1;\r\nif ((pslot->status & 0x04) != (poldslot->status & 0x04))\r\nupdate = 1;\r\nif (((pslot->status & 0x08) != (poldslot->status & 0x08))\r\n|| ((pslot->status & 0x10) != (poldslot->status & 0x10)))\r\nupdate = 1;\r\nif ((pslot->status & 0x20) != (poldslot->status & 0x20))\r\nif ((poldslot->status & 0x20) && (SLOT_CONNECT (poldslot->status) == HPC_SLOT_CONNECTED) && (SLOT_PRESENT (poldslot->status)))\r\ndisable = 1;\r\nif ((pslot->status & 0x80) != (poldslot->status & 0x80)) {\r\nupdate = 1;\r\nif (pslot->status & 0x80) {\r\nif (SLOT_PWRGD (pslot->status)) {\r\nmsleep(1000);\r\nrc = ibmphp_hpc_readslot (pslot, READ_SLOTSTATUS, &status);\r\nif (SLOT_PWRGD (status))\r\nupdate = 1;\r\nelse\r\npslot->status &= ~HPC_SLOT_POWER;\r\n}\r\n}\r\nelse if ((SLOT_PWRGD (poldslot->status) == HPC_SLOT_PWRGD_GOOD)\r\n&& (SLOT_CONNECT (poldslot->status) == HPC_SLOT_CONNECTED) && (SLOT_PRESENT (poldslot->status))) {\r\ndisable = 1;\r\n}\r\n}\r\nif ((pslot->ext_status & 0x08) != (poldslot->ext_status & 0x08))\r\nupdate = 1;\r\nif (disable) {\r\ndebug ("process_changeinstatus - disable slot\n");\r\npslot->flag = 0;\r\nrc = ibmphp_do_disable_slot (pslot);\r\n}\r\nif (update || disable) {\r\nibmphp_update_slot_info (pslot);\r\n}\r\ndebug ("%s - Exit rc[%d] disable[%x] update[%x]\n", __func__, rc, disable, update);\r\nreturn rc;\r\n}\r\nstatic int process_changeinlatch (u8 old, u8 new, struct controller *ctrl)\r\n{\r\nstruct slot myslot, *pslot;\r\nu8 i;\r\nu8 mask;\r\nint rc = 0;\r\ndebug ("%s - Entry old[%x], new[%x]\n", __func__, old, new);\r\nfor (i = ctrl->starting_slot_num; i <= ctrl->ending_slot_num; i++) {\r\nmask = 0x01 << i;\r\nif ((mask & old) != (mask & new)) {\r\npslot = ibmphp_get_slot_from_physical_num (i);\r\nif (pslot) {\r\nmemcpy ((void *) &myslot, (void *) pslot, sizeof (struct slot));\r\nrc = ibmphp_hpc_readslot (pslot, READ_ALLSTAT, NULL);\r\ndebug ("%s - call process_changeinstatus for slot[%d]\n", __func__, i);\r\nprocess_changeinstatus (pslot, &myslot);\r\n} else {\r\nrc = -EINVAL;\r\nerr ("%s - Error bad pointer for slot[%d]\n", __func__, i);\r\n}\r\n}\r\n}\r\ndebug ("%s - Exit rc[%d]\n", __func__, rc);\r\nreturn rc;\r\n}\r\nint __init ibmphp_hpc_start_poll_thread (void)\r\n{\r\ndebug ("%s - Entry\n", __func__);\r\nibmphp_poll_thread = kthread_run(poll_hpc, NULL, "hpc_poll");\r\nif (IS_ERR(ibmphp_poll_thread)) {\r\nerr ("%s - Error, thread not started\n", __func__);\r\nreturn PTR_ERR(ibmphp_poll_thread);\r\n}\r\nreturn 0;\r\n}\r\nvoid __exit ibmphp_hpc_stop_poll_thread (void)\r\n{\r\ndebug ("%s - Entry\n", __func__);\r\nkthread_stop(ibmphp_poll_thread);\r\ndebug ("before locking operations \n");\r\nibmphp_lock_operations ();\r\ndebug ("after locking operations \n");\r\ndebug ("before sem_exit down \n");\r\ndown (&sem_exit);\r\ndebug ("after sem_exit down \n");\r\ndebug ("before free_hpc_access \n");\r\nfree_hpc_access ();\r\ndebug ("after free_hpc_access \n");\r\nibmphp_unlock_operations ();\r\ndebug ("after unlock operations \n");\r\nup (&sem_exit);\r\ndebug ("after sem exit up\n");\r\ndebug ("%s - Exit\n", __func__);\r\n}\r\nstatic int hpc_wait_ctlr_notworking (int timeout, struct controller *ctlr_ptr, void __iomem *wpg_bbar,\r\nu8 *pstatus)\r\n{\r\nint rc = 0;\r\nu8 done = 0;\r\ndebug_polling ("hpc_wait_ctlr_notworking - Entry timeout[%d]\n", timeout);\r\nwhile (!done) {\r\n*pstatus = ctrl_read (ctlr_ptr, wpg_bbar, WPG_CTLR_INDEX);\r\nif (*pstatus == HPC_ERROR) {\r\nrc = HPC_ERROR;\r\ndone = 1;\r\n}\r\nif (CTLR_WORKING (*pstatus) == HPC_CTLR_WORKING_NO)\r\ndone = 1;\r\nif (!done) {\r\nmsleep(1000);\r\nif (timeout < 1) {\r\ndone = 1;\r\nerr ("HPCreadslot - Error ctlr timeout\n");\r\nrc = HPC_ERROR;\r\n} else\r\ntimeout--;\r\n}\r\n}\r\ndebug_polling ("hpc_wait_ctlr_notworking - Exit rc[%x] status[%x]\n", rc, *pstatus);\r\nreturn rc;\r\n}
