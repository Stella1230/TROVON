static inline const struct cpumask *cpu_core_mask(int cpu)\r\n{\r\nreturn cpumask_of(0);\r\n}\r\nstatic void freq_table_redup(struct cpufreq_frequency_table *freq_table,\r\nint count)\r\n{\r\nint i, j;\r\nfor (i = 1; i < count; i++) {\r\nfor (j = 0; j < i; j++) {\r\nif (freq_table[j].frequency == CPUFREQ_ENTRY_INVALID ||\r\nfreq_table[j].frequency !=\r\nfreq_table[i].frequency)\r\ncontinue;\r\nfreq_table[i].frequency = CPUFREQ_ENTRY_INVALID;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void freq_table_sort(struct cpufreq_frequency_table *freq_table,\r\nint count)\r\n{\r\nint i, j, ind;\r\nunsigned int freq, max_freq;\r\nstruct cpufreq_frequency_table table;\r\nfor (i = 0; i < count - 1; i++) {\r\nmax_freq = freq_table[i].frequency;\r\nind = i;\r\nfor (j = i + 1; j < count; j++) {\r\nfreq = freq_table[j].frequency;\r\nif (freq == CPUFREQ_ENTRY_INVALID ||\r\nfreq <= max_freq)\r\ncontinue;\r\nind = j;\r\nmax_freq = freq;\r\n}\r\nif (ind != i) {\r\ntable.driver_data = freq_table[i].driver_data;\r\ntable.frequency = freq_table[i].frequency;\r\nfreq_table[i].driver_data = freq_table[ind].driver_data;\r\nfreq_table[i].frequency = freq_table[ind].frequency;\r\nfreq_table[ind].driver_data = table.driver_data;\r\nfreq_table[ind].frequency = table.frequency;\r\n}\r\n}\r\n}\r\nstatic int corenet_cpufreq_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nstruct device_node *np;\r\nint i, count, ret;\r\nu32 freq, mask;\r\nstruct clk *clk;\r\nstruct cpufreq_frequency_table *table;\r\nstruct cpu_data *data;\r\nunsigned int cpu = policy->cpu;\r\nu64 u64temp;\r\nnp = of_get_cpu_node(cpu, NULL);\r\nif (!np)\r\nreturn -ENODEV;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data) {\r\npr_err("%s: no memory\n", __func__);\r\ngoto err_np;\r\n}\r\npolicy->clk = of_clk_get(np, 0);\r\nif (IS_ERR(policy->clk)) {\r\npr_err("%s: no clock information\n", __func__);\r\ngoto err_nomem2;\r\n}\r\ndata->parent = of_parse_phandle(np, "clocks", 0);\r\nif (!data->parent) {\r\npr_err("%s: could not get clock information\n", __func__);\r\ngoto err_nomem2;\r\n}\r\ncount = of_property_count_strings(data->parent, "clock-names");\r\ntable = kcalloc(count + 1, sizeof(*table), GFP_KERNEL);\r\nif (!table) {\r\npr_err("%s: no memory\n", __func__);\r\ngoto err_node;\r\n}\r\nif (fmask)\r\nmask = fmask[get_hard_smp_processor_id(cpu)];\r\nelse\r\nmask = 0x0;\r\nfor (i = 0; i < count; i++) {\r\nclk = of_clk_get(data->parent, i);\r\nfreq = clk_get_rate(clk);\r\nif (freq < min_cpufreq || (mask & (1 << i)))\r\ntable[i].frequency = CPUFREQ_ENTRY_INVALID;\r\nelse\r\ntable[i].frequency = freq / 1000;\r\ntable[i].driver_data = i;\r\n}\r\nfreq_table_redup(table, count);\r\nfreq_table_sort(table, count);\r\ntable[i].frequency = CPUFREQ_TABLE_END;\r\nret = cpufreq_table_validate_and_show(policy, table);\r\nif (ret) {\r\npr_err("invalid frequency table: %d\n", ret);\r\ngoto err_nomem1;\r\n}\r\ndata->table = table;\r\nper_cpu(cpu_data, cpu) = data;\r\ncpumask_copy(policy->cpus, per_cpu(cpu_mask, cpu));\r\nfor_each_cpu(i, per_cpu(cpu_mask, cpu))\r\nper_cpu(cpu_data, i) = data;\r\nu64temp = 12ULL * NSEC_PER_SEC;\r\ndo_div(u64temp, fsl_get_sys_freq());\r\npolicy->cpuinfo.transition_latency = u64temp + 1;\r\nof_node_put(np);\r\nreturn 0;\r\nerr_nomem1:\r\nkfree(table);\r\nerr_node:\r\nof_node_put(data->parent);\r\nerr_nomem2:\r\nper_cpu(cpu_data, cpu) = NULL;\r\nkfree(data);\r\nerr_np:\r\nof_node_put(np);\r\nreturn -ENODEV;\r\n}\r\nstatic int __exit corenet_cpufreq_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\nstruct cpu_data *data = per_cpu(cpu_data, policy->cpu);\r\nunsigned int cpu;\r\nof_node_put(data->parent);\r\nkfree(data->table);\r\nkfree(data);\r\nfor_each_cpu(cpu, per_cpu(cpu_mask, policy->cpu))\r\nper_cpu(cpu_data, cpu) = NULL;\r\nreturn 0;\r\n}\r\nstatic int corenet_cpufreq_target(struct cpufreq_policy *policy,\r\nunsigned int index)\r\n{\r\nstruct clk *parent;\r\nstruct cpu_data *data = per_cpu(cpu_data, policy->cpu);\r\nparent = of_clk_get(data->parent, data->table[index].driver_data);\r\nreturn clk_set_parent(policy->clk, parent);\r\n}\r\nstatic int __init ppc_corenet_cpufreq_init(void)\r\n{\r\nint ret;\r\nstruct device_node *np;\r\nconst struct of_device_id *match;\r\nconst struct soc_data *data;\r\nunsigned int cpu;\r\nnp = of_find_matching_node(NULL, node_matches);\r\nif (!np)\r\nreturn -ENODEV;\r\nfor_each_possible_cpu(cpu) {\r\nif (!alloc_cpumask_var(&per_cpu(cpu_mask, cpu), GFP_KERNEL))\r\ngoto err_mask;\r\ncpumask_copy(per_cpu(cpu_mask, cpu), cpu_core_mask(cpu));\r\n}\r\nmatch = of_match_node(node_matches, np);\r\ndata = match->data;\r\nif (data) {\r\nif (data->flag)\r\nfmask = data->freq_mask;\r\nmin_cpufreq = fsl_get_sys_freq();\r\n} else {\r\nmin_cpufreq = fsl_get_sys_freq() / 2;\r\n}\r\nof_node_put(np);\r\nret = cpufreq_register_driver(&ppc_corenet_cpufreq_driver);\r\nif (!ret)\r\npr_info("Freescale PowerPC corenet CPU frequency scaling driver\n");\r\nreturn ret;\r\nerr_mask:\r\nfor_each_possible_cpu(cpu)\r\nfree_cpumask_var(per_cpu(cpu_mask, cpu));\r\nreturn -ENOMEM;\r\n}\r\nstatic void __exit ppc_corenet_cpufreq_exit(void)\r\n{\r\nunsigned int cpu;\r\nfor_each_possible_cpu(cpu)\r\nfree_cpumask_var(per_cpu(cpu_mask, cpu));\r\ncpufreq_unregister_driver(&ppc_corenet_cpufreq_driver);\r\n}
