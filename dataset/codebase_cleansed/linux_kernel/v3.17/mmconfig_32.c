static u32 get_base_addr(unsigned int seg, int bus, unsigned devfn)\r\n{\r\nstruct pci_mmcfg_region *cfg = pci_mmconfig_lookup(seg, bus);\r\nif (cfg)\r\nreturn cfg->address;\r\nreturn 0;\r\n}\r\nstatic void pci_exp_set_dev_base(unsigned int base, int bus, int devfn)\r\n{\r\nu32 dev_base = base | PCI_MMCFG_BUS_OFFSET(bus) | (devfn << 12);\r\nint cpu = smp_processor_id();\r\nif (dev_base != mmcfg_last_accessed_device ||\r\ncpu != mmcfg_last_accessed_cpu) {\r\nmmcfg_last_accessed_device = dev_base;\r\nmmcfg_last_accessed_cpu = cpu;\r\nset_fixmap_nocache(FIX_PCIE_MCFG, dev_base);\r\n}\r\n}\r\nstatic int pci_mmcfg_read(unsigned int seg, unsigned int bus,\r\nunsigned int devfn, int reg, int len, u32 *value)\r\n{\r\nunsigned long flags;\r\nu32 base;\r\nif ((bus > 255) || (devfn > 255) || (reg > 4095)) {\r\nerr: *value = -1;\r\nreturn -EINVAL;\r\n}\r\nrcu_read_lock();\r\nbase = get_base_addr(seg, bus, devfn);\r\nif (!base) {\r\nrcu_read_unlock();\r\ngoto err;\r\n}\r\nraw_spin_lock_irqsave(&pci_config_lock, flags);\r\npci_exp_set_dev_base(base, bus, devfn);\r\nswitch (len) {\r\ncase 1:\r\n*value = mmio_config_readb(mmcfg_virt_addr + reg);\r\nbreak;\r\ncase 2:\r\n*value = mmio_config_readw(mmcfg_virt_addr + reg);\r\nbreak;\r\ncase 4:\r\n*value = mmio_config_readl(mmcfg_virt_addr + reg);\r\nbreak;\r\n}\r\nraw_spin_unlock_irqrestore(&pci_config_lock, flags);\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic int pci_mmcfg_write(unsigned int seg, unsigned int bus,\r\nunsigned int devfn, int reg, int len, u32 value)\r\n{\r\nunsigned long flags;\r\nu32 base;\r\nif ((bus > 255) || (devfn > 255) || (reg > 4095))\r\nreturn -EINVAL;\r\nrcu_read_lock();\r\nbase = get_base_addr(seg, bus, devfn);\r\nif (!base) {\r\nrcu_read_unlock();\r\nreturn -EINVAL;\r\n}\r\nraw_spin_lock_irqsave(&pci_config_lock, flags);\r\npci_exp_set_dev_base(base, bus, devfn);\r\nswitch (len) {\r\ncase 1:\r\nmmio_config_writeb(mmcfg_virt_addr + reg, value);\r\nbreak;\r\ncase 2:\r\nmmio_config_writew(mmcfg_virt_addr + reg, value);\r\nbreak;\r\ncase 4:\r\nmmio_config_writel(mmcfg_virt_addr + reg, value);\r\nbreak;\r\n}\r\nraw_spin_unlock_irqrestore(&pci_config_lock, flags);\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nint __init pci_mmcfg_arch_init(void)\r\n{\r\nprintk(KERN_INFO "PCI: Using MMCONFIG for extended config space\n");\r\nraw_pci_ext_ops = &pci_mmcfg;\r\nreturn 1;\r\n}\r\nvoid __init pci_mmcfg_arch_free(void)\r\n{\r\n}\r\nint pci_mmcfg_arch_map(struct pci_mmcfg_region *cfg)\r\n{\r\nreturn 0;\r\n}\r\nvoid pci_mmcfg_arch_unmap(struct pci_mmcfg_region *cfg)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&pci_config_lock, flags);\r\nmmcfg_last_accessed_device = 0;\r\nraw_spin_unlock_irqrestore(&pci_config_lock, flags);\r\n}
