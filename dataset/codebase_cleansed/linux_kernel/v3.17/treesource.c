struct boot_info *dt_from_source(const char *fname)\r\n{\r\nthe_boot_info = NULL;\r\ntreesource_error = 0;\r\nsrcfile_push(fname);\r\nyyin = current_srcfile->f;\r\nyylloc.file = current_srcfile;\r\nif (yyparse() != 0)\r\ndie("Unable to parse input tree\n");\r\nif (treesource_error)\r\ndie("Syntax error parsing input tree\n");\r\nreturn the_boot_info;\r\n}\r\nstatic void write_prefix(FILE *f, int level)\r\n{\r\nint i;\r\nfor (i = 0; i < level; i++)\r\nfputc('\t', f);\r\n}\r\nstatic int isstring(char c)\r\n{\r\nreturn (isprint(c)\r\n|| (c == '\0')\r\n|| strchr("\a\b\t\n\v\f\r", c));\r\n}\r\nstatic void write_propval_string(FILE *f, struct data val)\r\n{\r\nconst char *str = val.val;\r\nint i;\r\nstruct marker *m = val.markers;\r\nassert(str[val.len-1] == '\0');\r\nwhile (m && (m->offset == 0)) {\r\nif (m->type == LABEL)\r\nfprintf(f, "%s: ", m->ref);\r\nm = m->next;\r\n}\r\nfprintf(f, "\"");\r\nfor (i = 0; i < (val.len-1); i++) {\r\nchar c = str[i];\r\nswitch (c) {\r\ncase '\a':\r\nfprintf(f, "\\a");\r\nbreak;\r\ncase '\b':\r\nfprintf(f, "\\b");\r\nbreak;\r\ncase '\t':\r\nfprintf(f, "\\t");\r\nbreak;\r\ncase '\n':\r\nfprintf(f, "\\n");\r\nbreak;\r\ncase '\v':\r\nfprintf(f, "\\v");\r\nbreak;\r\ncase '\f':\r\nfprintf(f, "\\f");\r\nbreak;\r\ncase '\r':\r\nfprintf(f, "\\r");\r\nbreak;\r\ncase '\\':\r\nfprintf(f, "\\\\");\r\nbreak;\r\ncase '\"':\r\nfprintf(f, "\\\"");\r\nbreak;\r\ncase '\0':\r\nfprintf(f, "\", ");\r\nwhile (m && (m->offset < i)) {\r\nif (m->type == LABEL) {\r\nassert(m->offset == (i+1));\r\nfprintf(f, "%s: ", m->ref);\r\n}\r\nm = m->next;\r\n}\r\nfprintf(f, "\"");\r\nbreak;\r\ndefault:\r\nif (isprint(c))\r\nfprintf(f, "%c", c);\r\nelse\r\nfprintf(f, "\\x%02hhx", c);\r\n}\r\n}\r\nfprintf(f, "\"");\r\nfor_each_marker_of_type(m, LABEL) {\r\nassert (m->offset == val.len);\r\nfprintf(f, " %s:", m->ref);\r\n}\r\n}\r\nstatic void write_propval_cells(FILE *f, struct data val)\r\n{\r\nvoid *propend = val.val + val.len;\r\ncell_t *cp = (cell_t *)val.val;\r\nstruct marker *m = val.markers;\r\nfprintf(f, "<");\r\nfor (;;) {\r\nwhile (m && (m->offset <= ((char *)cp - val.val))) {\r\nif (m->type == LABEL) {\r\nassert(m->offset == ((char *)cp - val.val));\r\nfprintf(f, "%s: ", m->ref);\r\n}\r\nm = m->next;\r\n}\r\nfprintf(f, "0x%x", fdt32_to_cpu(*cp++));\r\nif ((void *)cp >= propend)\r\nbreak;\r\nfprintf(f, " ");\r\n}\r\nfor_each_marker_of_type(m, LABEL) {\r\nassert (m->offset == val.len);\r\nfprintf(f, " %s:", m->ref);\r\n}\r\nfprintf(f, ">");\r\n}\r\nstatic void write_propval_bytes(FILE *f, struct data val)\r\n{\r\nvoid *propend = val.val + val.len;\r\nconst char *bp = val.val;\r\nstruct marker *m = val.markers;\r\nfprintf(f, "[");\r\nfor (;;) {\r\nwhile (m && (m->offset == (bp-val.val))) {\r\nif (m->type == LABEL)\r\nfprintf(f, "%s: ", m->ref);\r\nm = m->next;\r\n}\r\nfprintf(f, "%02hhx", *bp++);\r\nif ((const void *)bp >= propend)\r\nbreak;\r\nfprintf(f, " ");\r\n}\r\nfor_each_marker_of_type(m, LABEL) {\r\nassert (m->offset == val.len);\r\nfprintf(f, " %s:", m->ref);\r\n}\r\nfprintf(f, "]");\r\n}\r\nstatic void write_propval(FILE *f, struct property *prop)\r\n{\r\nint len = prop->val.len;\r\nconst char *p = prop->val.val;\r\nstruct marker *m = prop->val.markers;\r\nint nnotstring = 0, nnul = 0;\r\nint nnotstringlbl = 0, nnotcelllbl = 0;\r\nint i;\r\nif (len == 0) {\r\nfprintf(f, ";\n");\r\nreturn;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nif (! isstring(p[i]))\r\nnnotstring++;\r\nif (p[i] == '\0')\r\nnnul++;\r\n}\r\nfor_each_marker_of_type(m, LABEL) {\r\nif ((m->offset > 0) && (prop->val.val[m->offset - 1] != '\0'))\r\nnnotstringlbl++;\r\nif ((m->offset % sizeof(cell_t)) != 0)\r\nnnotcelllbl++;\r\n}\r\nfprintf(f, " = ");\r\nif ((p[len-1] == '\0') && (nnotstring == 0) && (nnul < (len-nnul))\r\n&& (nnotstringlbl == 0)) {\r\nwrite_propval_string(f, prop->val);\r\n} else if (((len % sizeof(cell_t)) == 0) && (nnotcelllbl == 0)) {\r\nwrite_propval_cells(f, prop->val);\r\n} else {\r\nwrite_propval_bytes(f, prop->val);\r\n}\r\nfprintf(f, ";\n");\r\n}\r\nstatic void write_tree_source_node(FILE *f, struct node *tree, int level)\r\n{\r\nstruct property *prop;\r\nstruct node *child;\r\nstruct label *l;\r\nwrite_prefix(f, level);\r\nfor_each_label(tree->labels, l)\r\nfprintf(f, "%s: ", l->label);\r\nif (tree->name && (*tree->name))\r\nfprintf(f, "%s {\n", tree->name);\r\nelse\r\nfprintf(f, "/ {\n");\r\nfor_each_property(tree, prop) {\r\nwrite_prefix(f, level+1);\r\nfor_each_label(prop->labels, l)\r\nfprintf(f, "%s: ", l->label);\r\nfprintf(f, "%s", prop->name);\r\nwrite_propval(f, prop);\r\n}\r\nfor_each_child(tree, child) {\r\nfprintf(f, "\n");\r\nwrite_tree_source_node(f, child, level+1);\r\n}\r\nwrite_prefix(f, level);\r\nfprintf(f, "};\n");\r\n}\r\nvoid dt_to_source(FILE *f, struct boot_info *bi)\r\n{\r\nstruct reserve_info *re;\r\nfprintf(f, "/dts-v1/;\n\n");\r\nfor (re = bi->reservelist; re; re = re->next) {\r\nstruct label *l;\r\nfor_each_label(re->labels, l)\r\nfprintf(f, "%s: ", l->label);\r\nfprintf(f, "/memreserve/\t0x%016llx 0x%016llx;\n",\r\n(unsigned long long)re->re.address,\r\n(unsigned long long)re->re.size);\r\n}\r\nwrite_tree_source_node(f, bi->dt, 0);\r\n}
