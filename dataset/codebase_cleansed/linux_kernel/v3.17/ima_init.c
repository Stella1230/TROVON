static void __init ima_add_boot_aggregate(void)\r\n{\r\nstatic const char op[] = "add_boot_aggregate";\r\nconst char *audit_cause = "ENOMEM";\r\nstruct ima_template_entry *entry;\r\nstruct integrity_iint_cache tmp_iint, *iint = &tmp_iint;\r\nint result = -ENOMEM;\r\nint violation = 0;\r\nstruct {\r\nstruct ima_digest_data hdr;\r\nchar digest[TPM_DIGEST_SIZE];\r\n} hash;\r\nmemset(iint, 0, sizeof(*iint));\r\nmemset(&hash, 0, sizeof(hash));\r\niint->ima_hash = &hash.hdr;\r\niint->ima_hash->algo = HASH_ALGO_SHA1;\r\niint->ima_hash->length = SHA1_DIGEST_SIZE;\r\nif (ima_used_chip) {\r\nresult = ima_calc_boot_aggregate(&hash.hdr);\r\nif (result < 0) {\r\naudit_cause = "hashing_error";\r\ngoto err_out;\r\n}\r\n}\r\nresult = ima_alloc_init_template(iint, NULL, boot_aggregate_name,\r\nNULL, 0, &entry);\r\nif (result < 0)\r\nreturn;\r\nresult = ima_store_template(entry, violation, NULL,\r\nboot_aggregate_name);\r\nif (result < 0)\r\nima_free_template_entry(entry);\r\nreturn;\r\nerr_out:\r\nintegrity_audit_msg(AUDIT_INTEGRITY_PCR, NULL, boot_aggregate_name, op,\r\naudit_cause, result, 0);\r\n}\r\nint __init ima_init(void)\r\n{\r\nu8 pcr_i[TPM_DIGEST_SIZE];\r\nint rc;\r\nima_used_chip = 0;\r\nrc = tpm_pcr_read(TPM_ANY_NUM, 0, pcr_i);\r\nif (rc == 0)\r\nima_used_chip = 1;\r\nif (!ima_used_chip)\r\npr_info("No TPM chip found, activating TPM-bypass!\n");\r\nrc = ima_init_crypto();\r\nif (rc)\r\nreturn rc;\r\nrc = ima_init_template();\r\nif (rc != 0)\r\nreturn rc;\r\nima_add_boot_aggregate();\r\nima_init_policy();\r\nreturn ima_fs_init();\r\n}
