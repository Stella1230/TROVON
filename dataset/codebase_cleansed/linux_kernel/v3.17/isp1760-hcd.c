static inline struct isp1760_hcd *hcd_to_priv(struct usb_hcd *hcd)\r\n{\r\nreturn (struct isp1760_hcd *) (hcd->hcd_priv);\r\n}\r\nstatic u32 reg_read32(void __iomem *base, u32 reg)\r\n{\r\nreturn readl(base + reg);\r\n}\r\nstatic void reg_write32(void __iomem *base, u32 reg, u32 val)\r\n{\r\nwritel(val, base + reg);\r\n}\r\nstatic void bank_reads8(void __iomem *src_base, u32 src_offset, u32 bank_addr,\r\n__u32 *dst, u32 bytes)\r\n{\r\n__u32 __iomem *src;\r\nu32 val;\r\n__u8 *src_byteptr;\r\n__u8 *dst_byteptr;\r\nsrc = src_base + (bank_addr | src_offset);\r\nif (src_offset < PAYLOAD_OFFSET) {\r\nwhile (bytes >= 4) {\r\n*dst = le32_to_cpu(__raw_readl(src));\r\nbytes -= 4;\r\nsrc++;\r\ndst++;\r\n}\r\n} else {\r\nwhile (bytes >= 4) {\r\n*dst = __raw_readl(src);\r\nbytes -= 4;\r\nsrc++;\r\ndst++;\r\n}\r\n}\r\nif (!bytes)\r\nreturn;\r\nif (src_offset < PAYLOAD_OFFSET)\r\nval = le32_to_cpu(__raw_readl(src));\r\nelse\r\nval = __raw_readl(src);\r\ndst_byteptr = (void *) dst;\r\nsrc_byteptr = (void *) &val;\r\nwhile (bytes > 0) {\r\n*dst_byteptr = *src_byteptr;\r\ndst_byteptr++;\r\nsrc_byteptr++;\r\nbytes--;\r\n}\r\n}\r\nstatic void mem_reads8(void __iomem *src_base, u32 src_offset, void *dst,\r\nu32 bytes)\r\n{\r\nreg_write32(src_base, HC_MEMORY_REG, src_offset + ISP_BANK(0));\r\nndelay(90);\r\nbank_reads8(src_base, src_offset, ISP_BANK(0), dst, bytes);\r\n}\r\nstatic void mem_writes8(void __iomem *dst_base, u32 dst_offset,\r\n__u32 const *src, u32 bytes)\r\n{\r\n__u32 __iomem *dst;\r\ndst = dst_base + dst_offset;\r\nif (dst_offset < PAYLOAD_OFFSET) {\r\nwhile (bytes >= 4) {\r\n__raw_writel(cpu_to_le32(*src), dst);\r\nbytes -= 4;\r\nsrc++;\r\ndst++;\r\n}\r\n} else {\r\nwhile (bytes >= 4) {\r\n__raw_writel(*src, dst);\r\nbytes -= 4;\r\nsrc++;\r\ndst++;\r\n}\r\n}\r\nif (!bytes)\r\nreturn;\r\nif (dst_offset < PAYLOAD_OFFSET)\r\n__raw_writel(cpu_to_le32(*src), dst);\r\nelse\r\n__raw_writel(*src, dst);\r\n}\r\nstatic void ptd_read(void __iomem *base, u32 ptd_offset, u32 slot,\r\nstruct ptd *ptd)\r\n{\r\nreg_write32(base, HC_MEMORY_REG,\r\nISP_BANK(0) + ptd_offset + slot*sizeof(*ptd));\r\nndelay(90);\r\nbank_reads8(base, ptd_offset + slot*sizeof(*ptd), ISP_BANK(0),\r\n(void *) ptd, sizeof(*ptd));\r\n}\r\nstatic void ptd_write(void __iomem *base, u32 ptd_offset, u32 slot,\r\nstruct ptd *ptd)\r\n{\r\nmem_writes8(base, ptd_offset + slot*sizeof(*ptd) + sizeof(ptd->dw0),\r\n&ptd->dw1, 7*sizeof(ptd->dw1));\r\nwmb();\r\nmem_writes8(base, ptd_offset + slot*sizeof(*ptd), &ptd->dw0,\r\nsizeof(ptd->dw0));\r\n}\r\nstatic void init_memory(struct isp1760_hcd *priv)\r\n{\r\nint i, curr;\r\nu32 payload_addr;\r\npayload_addr = PAYLOAD_OFFSET;\r\nfor (i = 0; i < BLOCK_1_NUM; i++) {\r\npriv->memory_pool[i].start = payload_addr;\r\npriv->memory_pool[i].size = BLOCK_1_SIZE;\r\npriv->memory_pool[i].free = 1;\r\npayload_addr += priv->memory_pool[i].size;\r\n}\r\ncurr = i;\r\nfor (i = 0; i < BLOCK_2_NUM; i++) {\r\npriv->memory_pool[curr + i].start = payload_addr;\r\npriv->memory_pool[curr + i].size = BLOCK_2_SIZE;\r\npriv->memory_pool[curr + i].free = 1;\r\npayload_addr += priv->memory_pool[curr + i].size;\r\n}\r\ncurr = i;\r\nfor (i = 0; i < BLOCK_3_NUM; i++) {\r\npriv->memory_pool[curr + i].start = payload_addr;\r\npriv->memory_pool[curr + i].size = BLOCK_3_SIZE;\r\npriv->memory_pool[curr + i].free = 1;\r\npayload_addr += priv->memory_pool[curr + i].size;\r\n}\r\nWARN_ON(payload_addr - priv->memory_pool[0].start > PAYLOAD_AREA_SIZE);\r\n}\r\nstatic void alloc_mem(struct usb_hcd *hcd, struct isp1760_qtd *qtd)\r\n{\r\nstruct isp1760_hcd *priv = hcd_to_priv(hcd);\r\nint i;\r\nWARN_ON(qtd->payload_addr);\r\nif (!qtd->length)\r\nreturn;\r\nfor (i = 0; i < BLOCKS; i++) {\r\nif (priv->memory_pool[i].size >= qtd->length &&\r\npriv->memory_pool[i].free) {\r\npriv->memory_pool[i].free = 0;\r\nqtd->payload_addr = priv->memory_pool[i].start;\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void free_mem(struct usb_hcd *hcd, struct isp1760_qtd *qtd)\r\n{\r\nstruct isp1760_hcd *priv = hcd_to_priv(hcd);\r\nint i;\r\nif (!qtd->payload_addr)\r\nreturn;\r\nfor (i = 0; i < BLOCKS; i++) {\r\nif (priv->memory_pool[i].start == qtd->payload_addr) {\r\nWARN_ON(priv->memory_pool[i].free);\r\npriv->memory_pool[i].free = 1;\r\nqtd->payload_addr = 0;\r\nreturn;\r\n}\r\n}\r\ndev_err(hcd->self.controller, "%s: Invalid pointer: %08x\n",\r\n__func__, qtd->payload_addr);\r\nWARN_ON(1);\r\nqtd->payload_addr = 0;\r\n}\r\nstatic int handshake(struct usb_hcd *hcd, u32 reg,\r\nu32 mask, u32 done, int usec)\r\n{\r\nu32 result;\r\ndo {\r\nresult = reg_read32(hcd->regs, reg);\r\nif (result == ~0)\r\nreturn -ENODEV;\r\nresult &= mask;\r\nif (result == done)\r\nreturn 0;\r\nudelay(1);\r\nusec--;\r\n} while (usec > 0);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int ehci_reset(struct usb_hcd *hcd)\r\n{\r\nint retval;\r\nstruct isp1760_hcd *priv = hcd_to_priv(hcd);\r\nu32 command = reg_read32(hcd->regs, HC_USBCMD);\r\ncommand |= CMD_RESET;\r\nreg_write32(hcd->regs, HC_USBCMD, command);\r\nhcd->state = HC_STATE_HALT;\r\npriv->next_statechange = jiffies;\r\nretval = handshake(hcd, HC_USBCMD,\r\nCMD_RESET, 0, 250 * 1000);\r\nreturn retval;\r\n}\r\nstatic struct isp1760_qh *qh_alloc(gfp_t flags)\r\n{\r\nstruct isp1760_qh *qh;\r\nqh = kmem_cache_zalloc(qh_cachep, flags);\r\nif (!qh)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&qh->qh_list);\r\nINIT_LIST_HEAD(&qh->qtd_list);\r\nqh->slot = -1;\r\nreturn qh;\r\n}\r\nstatic void qh_free(struct isp1760_qh *qh)\r\n{\r\nWARN_ON(!list_empty(&qh->qtd_list));\r\nWARN_ON(qh->slot > -1);\r\nkmem_cache_free(qh_cachep, qh);\r\n}\r\nstatic int priv_init(struct usb_hcd *hcd)\r\n{\r\nstruct isp1760_hcd *priv = hcd_to_priv(hcd);\r\nu32 hcc_params;\r\nint i;\r\nspin_lock_init(&priv->lock);\r\nfor (i = 0; i < QH_END; i++)\r\nINIT_LIST_HEAD(&priv->qh_list[i]);\r\npriv->periodic_size = DEFAULT_I_TDPS;\r\nhcc_params = reg_read32(hcd->regs, HC_HCCPARAMS);\r\nif (HCC_ISOC_CACHE(hcc_params))\r\npriv->i_thresh = 8;\r\nelse\r\npriv->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);\r\nreturn 0;\r\n}\r\nstatic int isp1760_hc_setup(struct usb_hcd *hcd)\r\n{\r\nstruct isp1760_hcd *priv = hcd_to_priv(hcd);\r\nint result;\r\nu32 scratch, hwmode;\r\nif (gpio_is_valid(priv->rst_gpio)) {\r\nunsigned int rst_lvl;\r\nrst_lvl = (priv->devflags &\r\nISP1760_FLAG_RESET_ACTIVE_HIGH) ? 1 : 0;\r\ngpio_set_value(priv->rst_gpio, rst_lvl);\r\nmdelay(50);\r\ngpio_set_value(priv->rst_gpio, !rst_lvl);\r\n}\r\nhwmode = HW_DATA_BUS_32BIT;\r\nif (priv->devflags & ISP1760_FLAG_BUS_WIDTH_16)\r\nhwmode &= ~HW_DATA_BUS_32BIT;\r\nif (priv->devflags & ISP1760_FLAG_ANALOG_OC)\r\nhwmode |= HW_ANA_DIGI_OC;\r\nif (priv->devflags & ISP1760_FLAG_DACK_POL_HIGH)\r\nhwmode |= HW_DACK_POL_HIGH;\r\nif (priv->devflags & ISP1760_FLAG_DREQ_POL_HIGH)\r\nhwmode |= HW_DREQ_POL_HIGH;\r\nif (priv->devflags & ISP1760_FLAG_INTR_POL_HIGH)\r\nhwmode |= HW_INTR_HIGH_ACT;\r\nif (priv->devflags & ISP1760_FLAG_INTR_EDGE_TRIG)\r\nhwmode |= HW_INTR_EDGE_TRIG;\r\nreg_write32(hcd->regs, HC_HW_MODE_CTRL, hwmode);\r\nreg_write32(hcd->regs, HC_HW_MODE_CTRL, hwmode);\r\nreg_write32(hcd->regs, HC_SCRATCH_REG, 0xdeadbabe);\r\nscratch = reg_read32(hcd->regs, HC_CHIP_ID_REG);\r\nscratch = reg_read32(hcd->regs, HC_SCRATCH_REG);\r\nif (scratch != 0xdeadbabe) {\r\ndev_err(hcd->self.controller, "Scratch test failed.\n");\r\nreturn -ENODEV;\r\n}\r\nreg_write32(hcd->regs, HC_BUFFER_STATUS_REG, 0);\r\nreg_write32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG, NO_TRANSFER_ACTIVE);\r\nreg_write32(hcd->regs, HC_INT_PTD_SKIPMAP_REG, NO_TRANSFER_ACTIVE);\r\nreg_write32(hcd->regs, HC_ISO_PTD_SKIPMAP_REG, NO_TRANSFER_ACTIVE);\r\nreg_write32(hcd->regs, HC_RESET_REG, SW_RESET_RESET_ALL);\r\nmdelay(100);\r\nreg_write32(hcd->regs, HC_RESET_REG, SW_RESET_RESET_HC);\r\nmdelay(100);\r\nresult = ehci_reset(hcd);\r\nif (result)\r\nreturn result;\r\ndev_info(hcd->self.controller, "bus width: %d, oc: %s\n",\r\n(priv->devflags & ISP1760_FLAG_BUS_WIDTH_16) ?\r\n16 : 32, (priv->devflags & ISP1760_FLAG_ANALOG_OC) ?\r\n"analog" : "digital");\r\nreg_write32(hcd->regs, HC_HW_MODE_CTRL, hwmode | ALL_ATX_RESET);\r\nmdelay(10);\r\nreg_write32(hcd->regs, HC_HW_MODE_CTRL, hwmode);\r\nreg_write32(hcd->regs, HC_INTERRUPT_ENABLE, INTERRUPT_ENABLE_MASK);\r\nreg_write32(hcd->regs, HC_PORT1_CTRL, PORT1_POWER | PORT1_INIT2);\r\nmdelay(10);\r\npriv->hcs_params = reg_read32(hcd->regs, HC_HCSPARAMS);\r\nreturn priv_init(hcd);\r\n}\r\nstatic u32 base_to_chip(u32 base)\r\n{\r\nreturn ((base - 0x400) >> 3);\r\n}\r\nstatic int last_qtd_of_urb(struct isp1760_qtd *qtd, struct isp1760_qh *qh)\r\n{\r\nstruct urb *urb;\r\nif (list_is_last(&qtd->qtd_list, &qh->qtd_list))\r\nreturn 1;\r\nurb = qtd->urb;\r\nqtd = list_entry(qtd->qtd_list.next, typeof(*qtd), qtd_list);\r\nreturn (qtd->urb != urb);\r\n}\r\nstatic void create_ptd_atl(struct isp1760_qh *qh,\r\nstruct isp1760_qtd *qtd, struct ptd *ptd)\r\n{\r\nu32 maxpacket;\r\nu32 multi;\r\nu32 rl = RL_COUNTER;\r\nu32 nak = NAK_COUNTER;\r\nmemset(ptd, 0, sizeof(*ptd));\r\nmaxpacket = usb_maxpacket(qtd->urb->dev, qtd->urb->pipe,\r\nusb_pipeout(qtd->urb->pipe));\r\nmulti = 1 + ((maxpacket >> 11) & 0x3);\r\nmaxpacket &= 0x7ff;\r\nptd->dw0 = DW0_VALID_BIT;\r\nptd->dw0 |= TO_DW0_LENGTH(qtd->length);\r\nptd->dw0 |= TO_DW0_MAXPACKET(maxpacket);\r\nptd->dw0 |= TO_DW0_ENDPOINT(usb_pipeendpoint(qtd->urb->pipe));\r\nptd->dw1 = usb_pipeendpoint(qtd->urb->pipe) >> 1;\r\nptd->dw1 |= TO_DW1_DEVICE_ADDR(usb_pipedevice(qtd->urb->pipe));\r\nptd->dw1 |= TO_DW1_PID_TOKEN(qtd->packet_type);\r\nif (usb_pipebulk(qtd->urb->pipe))\r\nptd->dw1 |= DW1_TRANS_BULK;\r\nelse if (usb_pipeint(qtd->urb->pipe))\r\nptd->dw1 |= DW1_TRANS_INT;\r\nif (qtd->urb->dev->speed != USB_SPEED_HIGH) {\r\nptd->dw1 |= DW1_TRANS_SPLIT;\r\nif (qtd->urb->dev->speed == USB_SPEED_LOW)\r\nptd->dw1 |= DW1_SE_USB_LOSPEED;\r\nptd->dw1 |= TO_DW1_PORT_NUM(qtd->urb->dev->ttport);\r\nptd->dw1 |= TO_DW1_HUB_NUM(qtd->urb->dev->tt->hub->devnum);\r\nif (usb_pipeint(qtd->urb->pipe) &&\r\n(qtd->urb->dev->speed == USB_SPEED_LOW))\r\nptd->dw1 |= 2 << 16;\r\nrl = 0;\r\nnak = 0;\r\n} else {\r\nptd->dw0 |= TO_DW0_MULTI(multi);\r\nif (usb_pipecontrol(qtd->urb->pipe) ||\r\nusb_pipebulk(qtd->urb->pipe))\r\nptd->dw3 |= TO_DW3_PING(qh->ping);\r\n}\r\nptd->dw2 = 0;\r\nptd->dw2 |= TO_DW2_DATA_START_ADDR(base_to_chip(qtd->payload_addr));\r\nptd->dw2 |= TO_DW2_RL(rl);\r\nptd->dw3 |= TO_DW3_NAKCOUNT(nak);\r\nptd->dw3 |= TO_DW3_DATA_TOGGLE(qh->toggle);\r\nif (usb_pipecontrol(qtd->urb->pipe)) {\r\nif (qtd->data_buffer == qtd->urb->setup_packet)\r\nptd->dw3 &= ~TO_DW3_DATA_TOGGLE(1);\r\nelse if (last_qtd_of_urb(qtd, qh))\r\nptd->dw3 |= TO_DW3_DATA_TOGGLE(1);\r\n}\r\nptd->dw3 |= DW3_ACTIVE_BIT;\r\nptd->dw3 |= TO_DW3_CERR(ERR_COUNTER);\r\n}\r\nstatic void transform_add_int(struct isp1760_qh *qh,\r\nstruct isp1760_qtd *qtd, struct ptd *ptd)\r\n{\r\nu32 usof;\r\nu32 period;\r\nif (qtd->urb->dev->speed == USB_SPEED_HIGH) {\r\nperiod = qtd->urb->interval >> 3;\r\nif (qtd->urb->interval > 4)\r\nusof = 0x01;\r\nelse if (qtd->urb->interval > 2)\r\nusof = 0x22;\r\nelse if (qtd->urb->interval > 1)\r\nusof = 0x55;\r\nelse\r\nusof = 0xff;\r\n} else {\r\nperiod = qtd->urb->interval;\r\nusof = 0x0f;\r\nptd->dw5 = 0xff;\r\n}\r\nperiod = period >> 1;\r\nperiod &= 0xf8;\r\nptd->dw2 |= period;\r\nptd->dw4 = usof;\r\n}\r\nstatic void create_ptd_int(struct isp1760_qh *qh,\r\nstruct isp1760_qtd *qtd, struct ptd *ptd)\r\n{\r\ncreate_ptd_atl(qh, qtd, ptd);\r\ntransform_add_int(qh, qtd, ptd);\r\n}\r\nstatic void isp1760_urb_done(struct usb_hcd *hcd, struct urb *urb)\r\n__releases(priv->lock)\r\n__acquires(priv->lock)\r\n{\r\nstruct isp1760_hcd *priv = hcd_to_priv(hcd);\r\nif (!urb->unlinked) {\r\nif (urb->status == -EINPROGRESS)\r\nurb->status = 0;\r\n}\r\nif (usb_pipein(urb->pipe) && usb_pipetype(urb->pipe) != PIPE_CONTROL) {\r\nvoid *ptr;\r\nfor (ptr = urb->transfer_buffer;\r\nptr < urb->transfer_buffer + urb->transfer_buffer_length;\r\nptr += PAGE_SIZE)\r\nflush_dcache_page(virt_to_page(ptr));\r\n}\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nspin_unlock(&priv->lock);\r\nusb_hcd_giveback_urb(hcd, urb, urb->status);\r\nspin_lock(&priv->lock);\r\n}\r\nstatic struct isp1760_qtd *qtd_alloc(gfp_t flags, struct urb *urb,\r\nu8 packet_type)\r\n{\r\nstruct isp1760_qtd *qtd;\r\nqtd = kmem_cache_zalloc(qtd_cachep, flags);\r\nif (!qtd)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&qtd->qtd_list);\r\nqtd->urb = urb;\r\nqtd->packet_type = packet_type;\r\nqtd->status = QTD_ENQUEUED;\r\nqtd->actual_length = 0;\r\nreturn qtd;\r\n}\r\nstatic void qtd_free(struct isp1760_qtd *qtd)\r\n{\r\nWARN_ON(qtd->payload_addr);\r\nkmem_cache_free(qtd_cachep, qtd);\r\n}\r\nstatic void start_bus_transfer(struct usb_hcd *hcd, u32 ptd_offset, int slot,\r\nstruct slotinfo *slots, struct isp1760_qtd *qtd,\r\nstruct isp1760_qh *qh, struct ptd *ptd)\r\n{\r\nstruct isp1760_hcd *priv = hcd_to_priv(hcd);\r\nint skip_map;\r\nWARN_ON((slot < 0) || (slot > 31));\r\nWARN_ON(qtd->length && !qtd->payload_addr);\r\nWARN_ON(slots[slot].qtd);\r\nWARN_ON(slots[slot].qh);\r\nWARN_ON(qtd->status != QTD_PAYLOAD_ALLOC);\r\nif (ptd_offset == ATL_PTD_OFFSET) {\r\npriv->atl_done_map |= reg_read32(hcd->regs,\r\nHC_ATL_PTD_DONEMAP_REG);\r\npriv->atl_done_map &= ~(1 << slot);\r\n} else {\r\npriv->int_done_map |= reg_read32(hcd->regs,\r\nHC_INT_PTD_DONEMAP_REG);\r\npriv->int_done_map &= ~(1 << slot);\r\n}\r\nqh->slot = slot;\r\nqtd->status = QTD_XFER_STARTED;\r\nslots[slot].timestamp = jiffies;\r\nslots[slot].qtd = qtd;\r\nslots[slot].qh = qh;\r\nptd_write(hcd->regs, ptd_offset, slot, ptd);\r\nif (ptd_offset == ATL_PTD_OFFSET) {\r\nskip_map = reg_read32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG);\r\nskip_map &= ~(1 << qh->slot);\r\nreg_write32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG, skip_map);\r\n} else {\r\nskip_map = reg_read32(hcd->regs, HC_INT_PTD_SKIPMAP_REG);\r\nskip_map &= ~(1 << qh->slot);\r\nreg_write32(hcd->regs, HC_INT_PTD_SKIPMAP_REG, skip_map);\r\n}\r\n}\r\nstatic int is_short_bulk(struct isp1760_qtd *qtd)\r\n{\r\nreturn (usb_pipebulk(qtd->urb->pipe) &&\r\n(qtd->actual_length < qtd->length));\r\n}\r\nstatic void collect_qtds(struct usb_hcd *hcd, struct isp1760_qh *qh,\r\nstruct list_head *urb_list)\r\n{\r\nint last_qtd;\r\nstruct isp1760_qtd *qtd, *qtd_next;\r\nstruct urb_listitem *urb_listitem;\r\nlist_for_each_entry_safe(qtd, qtd_next, &qh->qtd_list, qtd_list) {\r\nif (qtd->status < QTD_XFER_COMPLETE)\r\nbreak;\r\nlast_qtd = last_qtd_of_urb(qtd, qh);\r\nif ((!last_qtd) && (qtd->status == QTD_RETIRE))\r\nqtd_next->status = QTD_RETIRE;\r\nif (qtd->status == QTD_XFER_COMPLETE) {\r\nif (qtd->actual_length) {\r\nswitch (qtd->packet_type) {\r\ncase IN_PID:\r\nmem_reads8(hcd->regs, qtd->payload_addr,\r\nqtd->data_buffer,\r\nqtd->actual_length);\r\ncase OUT_PID:\r\nqtd->urb->actual_length +=\r\nqtd->actual_length;\r\ncase SETUP_PID:\r\nbreak;\r\n}\r\n}\r\nif (is_short_bulk(qtd)) {\r\nif (qtd->urb->transfer_flags & URB_SHORT_NOT_OK)\r\nqtd->urb->status = -EREMOTEIO;\r\nif (!last_qtd)\r\nqtd_next->status = QTD_RETIRE;\r\n}\r\n}\r\nif (qtd->payload_addr)\r\nfree_mem(hcd, qtd);\r\nif (last_qtd) {\r\nif ((qtd->status == QTD_RETIRE) &&\r\n(qtd->urb->status == -EINPROGRESS))\r\nqtd->urb->status = -EPIPE;\r\nurb_listitem = kmem_cache_zalloc(urb_listitem_cachep,\r\nGFP_ATOMIC);\r\nif (unlikely(!urb_listitem))\r\nbreak;\r\nurb_listitem->urb = qtd->urb;\r\nlist_add_tail(&urb_listitem->urb_list, urb_list);\r\n}\r\nlist_del(&qtd->qtd_list);\r\nqtd_free(qtd);\r\n}\r\n}\r\nstatic void enqueue_qtds(struct usb_hcd *hcd, struct isp1760_qh *qh)\r\n{\r\nstruct isp1760_hcd *priv = hcd_to_priv(hcd);\r\nint ptd_offset;\r\nstruct slotinfo *slots;\r\nint curr_slot, free_slot;\r\nint n;\r\nstruct ptd ptd;\r\nstruct isp1760_qtd *qtd;\r\nif (unlikely(list_empty(&qh->qtd_list))) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nif (qh->tt_buffer_dirty)\r\nreturn;\r\nif (usb_pipeint(list_entry(qh->qtd_list.next, struct isp1760_qtd,\r\nqtd_list)->urb->pipe)) {\r\nptd_offset = INT_PTD_OFFSET;\r\nslots = priv->int_slots;\r\n} else {\r\nptd_offset = ATL_PTD_OFFSET;\r\nslots = priv->atl_slots;\r\n}\r\nfree_slot = -1;\r\nfor (curr_slot = 0; curr_slot < 32; curr_slot++) {\r\nif ((free_slot == -1) && (slots[curr_slot].qtd == NULL))\r\nfree_slot = curr_slot;\r\nif (slots[curr_slot].qh == qh)\r\nbreak;\r\n}\r\nn = 0;\r\nlist_for_each_entry(qtd, &qh->qtd_list, qtd_list) {\r\nif (qtd->status == QTD_ENQUEUED) {\r\nWARN_ON(qtd->payload_addr);\r\nalloc_mem(hcd, qtd);\r\nif ((qtd->length) && (!qtd->payload_addr))\r\nbreak;\r\nif ((qtd->length) &&\r\n((qtd->packet_type == SETUP_PID) ||\r\n(qtd->packet_type == OUT_PID))) {\r\nmem_writes8(hcd->regs, qtd->payload_addr,\r\nqtd->data_buffer, qtd->length);\r\n}\r\nqtd->status = QTD_PAYLOAD_ALLOC;\r\n}\r\nif (qtd->status == QTD_PAYLOAD_ALLOC) {\r\nif ((curr_slot > 31) && (free_slot > -1)) {\r\nif (usb_pipeint(qtd->urb->pipe))\r\ncreate_ptd_int(qh, qtd, &ptd);\r\nelse\r\ncreate_ptd_atl(qh, qtd, &ptd);\r\nstart_bus_transfer(hcd, ptd_offset, free_slot,\r\nslots, qtd, qh, &ptd);\r\ncurr_slot = free_slot;\r\n}\r\nn++;\r\nif (n >= ENQUEUE_DEPTH)\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void schedule_ptds(struct usb_hcd *hcd)\r\n{\r\nstruct isp1760_hcd *priv;\r\nstruct isp1760_qh *qh, *qh_next;\r\nstruct list_head *ep_queue;\r\nLIST_HEAD(urb_list);\r\nstruct urb_listitem *urb_listitem, *urb_listitem_next;\r\nint i;\r\nif (!hcd) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\npriv = hcd_to_priv(hcd);\r\nfor (i = 0; i < QH_END; i++) {\r\nep_queue = &priv->qh_list[i];\r\nlist_for_each_entry_safe(qh, qh_next, ep_queue, qh_list) {\r\ncollect_qtds(hcd, qh, &urb_list);\r\nif (list_empty(&qh->qtd_list))\r\nlist_del(&qh->qh_list);\r\n}\r\n}\r\nlist_for_each_entry_safe(urb_listitem, urb_listitem_next, &urb_list,\r\nurb_list) {\r\nisp1760_urb_done(hcd, urb_listitem->urb);\r\nkmem_cache_free(urb_listitem_cachep, urb_listitem);\r\n}\r\nfor (i = 0; i < QH_END; i++) {\r\nep_queue = &priv->qh_list[i];\r\nlist_for_each_entry_safe(qh, qh_next, ep_queue, qh_list)\r\nenqueue_qtds(hcd, qh);\r\n}\r\n}\r\nstatic int check_int_transfer(struct usb_hcd *hcd, struct ptd *ptd,\r\nstruct urb *urb)\r\n{\r\n__dw dw4;\r\nint i;\r\ndw4 = ptd->dw4;\r\ndw4 >>= 8;\r\nif (ptd->dw3 & DW3_HALT_BIT) {\r\nurb->status = -EPROTO;\r\nfor (i = 0; i < 8; i++) {\r\nswitch (dw4 & 0x7) {\r\ncase INT_UNDERRUN:\r\ndev_dbg(hcd->self.controller, "%s: underrun "\r\n"during uFrame %d\n",\r\n__func__, i);\r\nurb->status = -ECOMM;\r\nbreak;\r\ncase INT_EXACT:\r\ndev_dbg(hcd->self.controller, "%s: transaction "\r\n"error during uFrame %d\n",\r\n__func__, i);\r\nurb->status = -EPROTO;\r\nbreak;\r\ncase INT_BABBLE:\r\ndev_dbg(hcd->self.controller, "%s: babble "\r\n"error during uFrame %d\n",\r\n__func__, i);\r\nurb->status = -EOVERFLOW;\r\nbreak;\r\n}\r\ndw4 >>= 3;\r\n}\r\nreturn PTD_STATE_URB_RETIRE;\r\n}\r\nreturn PTD_STATE_QTD_DONE;\r\n}\r\nstatic int check_atl_transfer(struct usb_hcd *hcd, struct ptd *ptd,\r\nstruct urb *urb)\r\n{\r\nWARN_ON(!ptd);\r\nif (ptd->dw3 & DW3_HALT_BIT) {\r\nif (ptd->dw3 & DW3_BABBLE_BIT)\r\nurb->status = -EOVERFLOW;\r\nelse if (FROM_DW3_CERR(ptd->dw3))\r\nurb->status = -EPIPE;\r\nelse if (ptd->dw3 & DW3_ERROR_BIT)\r\nurb->status = -EPROTO;\r\nelse\r\nurb->status = -EPROTO;\r\nreturn PTD_STATE_URB_RETIRE;\r\n}\r\nif ((ptd->dw3 & DW3_ERROR_BIT) && (ptd->dw3 & DW3_ACTIVE_BIT)) {\r\ndev_dbg(hcd->self.controller, "PID error; reloading ptd\n");\r\nreturn PTD_STATE_QTD_RELOAD;\r\n}\r\nif (!FROM_DW3_NAKCOUNT(ptd->dw3) && (ptd->dw3 & DW3_ACTIVE_BIT)) {\r\nreturn PTD_STATE_QTD_RELOAD;\r\n}\r\nreturn PTD_STATE_QTD_DONE;\r\n}\r\nstatic void handle_done_ptds(struct usb_hcd *hcd)\r\n{\r\nstruct isp1760_hcd *priv = hcd_to_priv(hcd);\r\nstruct ptd ptd;\r\nstruct isp1760_qh *qh;\r\nint slot;\r\nint state;\r\nstruct slotinfo *slots;\r\nu32 ptd_offset;\r\nstruct isp1760_qtd *qtd;\r\nint modified;\r\nint skip_map;\r\nskip_map = reg_read32(hcd->regs, HC_INT_PTD_SKIPMAP_REG);\r\npriv->int_done_map &= ~skip_map;\r\nskip_map = reg_read32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG);\r\npriv->atl_done_map &= ~skip_map;\r\nmodified = priv->int_done_map || priv->atl_done_map;\r\nwhile (priv->int_done_map || priv->atl_done_map) {\r\nif (priv->int_done_map) {\r\nslot = __ffs(priv->int_done_map);\r\npriv->int_done_map &= ~(1 << slot);\r\nslots = priv->int_slots;\r\nif (!slots[slot].qh) {\r\nWARN_ON(1);\r\ncontinue;\r\n}\r\nptd_offset = INT_PTD_OFFSET;\r\nptd_read(hcd->regs, INT_PTD_OFFSET, slot, &ptd);\r\nstate = check_int_transfer(hcd, &ptd,\r\nslots[slot].qtd->urb);\r\n} else {\r\nslot = __ffs(priv->atl_done_map);\r\npriv->atl_done_map &= ~(1 << slot);\r\nslots = priv->atl_slots;\r\nif (!slots[slot].qh) {\r\nWARN_ON(1);\r\ncontinue;\r\n}\r\nptd_offset = ATL_PTD_OFFSET;\r\nptd_read(hcd->regs, ATL_PTD_OFFSET, slot, &ptd);\r\nstate = check_atl_transfer(hcd, &ptd,\r\nslots[slot].qtd->urb);\r\n}\r\nqtd = slots[slot].qtd;\r\nslots[slot].qtd = NULL;\r\nqh = slots[slot].qh;\r\nslots[slot].qh = NULL;\r\nqh->slot = -1;\r\nWARN_ON(qtd->status != QTD_XFER_STARTED);\r\nswitch (state) {\r\ncase PTD_STATE_QTD_DONE:\r\nif ((usb_pipeint(qtd->urb->pipe)) &&\r\n(qtd->urb->dev->speed != USB_SPEED_HIGH))\r\nqtd->actual_length =\r\nFROM_DW3_SCS_NRBYTESTRANSFERRED(ptd.dw3);\r\nelse\r\nqtd->actual_length =\r\nFROM_DW3_NRBYTESTRANSFERRED(ptd.dw3);\r\nqtd->status = QTD_XFER_COMPLETE;\r\nif (list_is_last(&qtd->qtd_list, &qh->qtd_list) ||\r\nis_short_bulk(qtd))\r\nqtd = NULL;\r\nelse\r\nqtd = list_entry(qtd->qtd_list.next,\r\ntypeof(*qtd), qtd_list);\r\nqh->toggle = FROM_DW3_DATA_TOGGLE(ptd.dw3);\r\nqh->ping = FROM_DW3_PING(ptd.dw3);\r\nbreak;\r\ncase PTD_STATE_QTD_RELOAD:\r\nqtd->status = QTD_PAYLOAD_ALLOC;\r\nptd.dw0 |= DW0_VALID_BIT;\r\nptd.dw3 &= ~TO_DW3_NAKCOUNT(0xf);\r\nptd.dw3 |= TO_DW3_NAKCOUNT(FROM_DW2_RL(ptd.dw2));\r\nptd.dw3 &= ~TO_DW3_CERR(3);\r\nptd.dw3 |= TO_DW3_CERR(ERR_COUNTER);\r\nqh->toggle = FROM_DW3_DATA_TOGGLE(ptd.dw3);\r\nqh->ping = FROM_DW3_PING(ptd.dw3);\r\nbreak;\r\ncase PTD_STATE_URB_RETIRE:\r\nqtd->status = QTD_RETIRE;\r\nif ((qtd->urb->dev->speed != USB_SPEED_HIGH) &&\r\n(qtd->urb->status != -EPIPE) &&\r\n(qtd->urb->status != -EREMOTEIO)) {\r\nqh->tt_buffer_dirty = 1;\r\nif (usb_hub_clear_tt_buffer(qtd->urb))\r\nqh->tt_buffer_dirty = 0;\r\n}\r\nqtd = NULL;\r\nqh->toggle = 0;\r\nqh->ping = 0;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\ncontinue;\r\n}\r\nif (qtd && (qtd->status == QTD_PAYLOAD_ALLOC)) {\r\nif (slots == priv->int_slots) {\r\nif (state == PTD_STATE_QTD_RELOAD)\r\ndev_err(hcd->self.controller,\r\n"%s: PTD_STATE_QTD_RELOAD on "\r\n"interrupt packet\n", __func__);\r\nif (state != PTD_STATE_QTD_RELOAD)\r\ncreate_ptd_int(qh, qtd, &ptd);\r\n} else {\r\nif (state != PTD_STATE_QTD_RELOAD)\r\ncreate_ptd_atl(qh, qtd, &ptd);\r\n}\r\nstart_bus_transfer(hcd, ptd_offset, slot, slots, qtd,\r\nqh, &ptd);\r\n}\r\n}\r\nif (modified)\r\nschedule_ptds(hcd);\r\n}\r\nstatic irqreturn_t isp1760_irq(struct usb_hcd *hcd)\r\n{\r\nstruct isp1760_hcd *priv = hcd_to_priv(hcd);\r\nu32 imask;\r\nirqreturn_t irqret = IRQ_NONE;\r\nspin_lock(&priv->lock);\r\nif (!(hcd->state & HC_STATE_RUNNING))\r\ngoto leave;\r\nimask = reg_read32(hcd->regs, HC_INTERRUPT_REG);\r\nif (unlikely(!imask))\r\ngoto leave;\r\nreg_write32(hcd->regs, HC_INTERRUPT_REG, imask);\r\npriv->int_done_map |= reg_read32(hcd->regs, HC_INT_PTD_DONEMAP_REG);\r\npriv->atl_done_map |= reg_read32(hcd->regs, HC_ATL_PTD_DONEMAP_REG);\r\nhandle_done_ptds(hcd);\r\nirqret = IRQ_HANDLED;\r\nleave:\r\nspin_unlock(&priv->lock);\r\nreturn irqret;\r\n}\r\nstatic void errata2_function(unsigned long data)\r\n{\r\nstruct usb_hcd *hcd = (struct usb_hcd *) data;\r\nstruct isp1760_hcd *priv = hcd_to_priv(hcd);\r\nint slot;\r\nstruct ptd ptd;\r\nunsigned long spinflags;\r\nspin_lock_irqsave(&priv->lock, spinflags);\r\nfor (slot = 0; slot < 32; slot++)\r\nif (priv->atl_slots[slot].qh && time_after(jiffies,\r\npriv->atl_slots[slot].timestamp +\r\nSLOT_TIMEOUT * HZ / 1000)) {\r\nptd_read(hcd->regs, ATL_PTD_OFFSET, slot, &ptd);\r\nif (!FROM_DW0_VALID(ptd.dw0) &&\r\n!FROM_DW3_ACTIVE(ptd.dw3))\r\npriv->atl_done_map |= 1 << slot;\r\n}\r\nif (priv->atl_done_map)\r\nhandle_done_ptds(hcd);\r\nspin_unlock_irqrestore(&priv->lock, spinflags);\r\nerrata2_timer.expires = jiffies + SLOT_CHECK_PERIOD * HZ / 1000;\r\nadd_timer(&errata2_timer);\r\n}\r\nstatic int isp1760_run(struct usb_hcd *hcd)\r\n{\r\nint retval;\r\nu32 temp;\r\nu32 command;\r\nu32 chipid;\r\nhcd->uses_new_polling = 1;\r\nhcd->state = HC_STATE_RUNNING;\r\nreg_write32(hcd->regs, HC_ATL_IRQ_MASK_AND_REG, 0);\r\nreg_write32(hcd->regs, HC_ATL_IRQ_MASK_OR_REG, 0xffffffff);\r\nreg_write32(hcd->regs, HC_INT_IRQ_MASK_AND_REG, 0);\r\nreg_write32(hcd->regs, HC_INT_IRQ_MASK_OR_REG, 0xffffffff);\r\nreg_write32(hcd->regs, HC_ISO_IRQ_MASK_AND_REG, 0);\r\nreg_write32(hcd->regs, HC_ISO_IRQ_MASK_OR_REG, 0xffffffff);\r\ntemp = reg_read32(hcd->regs, HC_HW_MODE_CTRL);\r\nreg_write32(hcd->regs, HC_HW_MODE_CTRL, temp | HW_GLOBAL_INTR_EN);\r\ncommand = reg_read32(hcd->regs, HC_USBCMD);\r\ncommand &= ~(CMD_LRESET|CMD_RESET);\r\ncommand |= CMD_RUN;\r\nreg_write32(hcd->regs, HC_USBCMD, command);\r\nretval = handshake(hcd, HC_USBCMD, CMD_RUN, CMD_RUN, 250 * 1000);\r\nif (retval)\r\nreturn retval;\r\ndown_write(&ehci_cf_port_reset_rwsem);\r\nreg_write32(hcd->regs, HC_CONFIGFLAG, FLAG_CF);\r\nretval = handshake(hcd, HC_CONFIGFLAG, FLAG_CF, FLAG_CF, 250 * 1000);\r\nup_write(&ehci_cf_port_reset_rwsem);\r\nif (retval)\r\nreturn retval;\r\ninit_timer(&errata2_timer);\r\nerrata2_timer.function = errata2_function;\r\nerrata2_timer.data = (unsigned long) hcd;\r\nerrata2_timer.expires = jiffies + SLOT_CHECK_PERIOD * HZ / 1000;\r\nadd_timer(&errata2_timer);\r\nchipid = reg_read32(hcd->regs, HC_CHIP_ID_REG);\r\ndev_info(hcd->self.controller, "USB ISP %04x HW rev. %d started\n",\r\nchipid & 0xffff, chipid >> 16);\r\nreg_write32(hcd->regs, HC_ATL_PTD_LASTPTD_REG, 0x80000000);\r\nreg_write32(hcd->regs, HC_INT_PTD_LASTPTD_REG, 0x80000000);\r\nreg_write32(hcd->regs, HC_ISO_PTD_LASTPTD_REG, 0x00000001);\r\nreg_write32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG, 0xffffffff);\r\nreg_write32(hcd->regs, HC_INT_PTD_SKIPMAP_REG, 0xffffffff);\r\nreg_write32(hcd->regs, HC_ISO_PTD_SKIPMAP_REG, 0xffffffff);\r\nreg_write32(hcd->regs, HC_BUFFER_STATUS_REG,\r\nATL_BUF_FILL | INT_BUF_FILL);\r\nreturn 0;\r\n}\r\nstatic int qtd_fill(struct isp1760_qtd *qtd, void *databuffer, size_t len)\r\n{\r\nqtd->data_buffer = databuffer;\r\nif (len > MAX_PAYLOAD_SIZE)\r\nlen = MAX_PAYLOAD_SIZE;\r\nqtd->length = len;\r\nreturn qtd->length;\r\n}\r\nstatic void qtd_list_free(struct list_head *qtd_list)\r\n{\r\nstruct isp1760_qtd *qtd, *qtd_next;\r\nlist_for_each_entry_safe(qtd, qtd_next, qtd_list, qtd_list) {\r\nlist_del(&qtd->qtd_list);\r\nqtd_free(qtd);\r\n}\r\n}\r\nstatic void packetize_urb(struct usb_hcd *hcd,\r\nstruct urb *urb, struct list_head *head, gfp_t flags)\r\n{\r\nstruct isp1760_qtd *qtd;\r\nvoid *buf;\r\nint len, maxpacketsize;\r\nu8 packet_type;\r\nif (!urb->transfer_buffer && urb->transfer_buffer_length) {\r\ndev_err(hcd->self.controller,\r\n"buf is null, dma is %08lx len is %d\n",\r\n(long unsigned)urb->transfer_dma,\r\nurb->transfer_buffer_length);\r\nWARN_ON(1);\r\n}\r\nif (usb_pipein(urb->pipe))\r\npacket_type = IN_PID;\r\nelse\r\npacket_type = OUT_PID;\r\nif (usb_pipecontrol(urb->pipe)) {\r\nqtd = qtd_alloc(flags, urb, SETUP_PID);\r\nif (!qtd)\r\ngoto cleanup;\r\nqtd_fill(qtd, urb->setup_packet, sizeof(struct usb_ctrlrequest));\r\nlist_add_tail(&qtd->qtd_list, head);\r\nif (urb->transfer_buffer_length == 0)\r\npacket_type = IN_PID;\r\n}\r\nmaxpacketsize = max_packet(usb_maxpacket(urb->dev, urb->pipe,\r\nusb_pipeout(urb->pipe)));\r\nbuf = urb->transfer_buffer;\r\nlen = urb->transfer_buffer_length;\r\nfor (;;) {\r\nint this_qtd_len;\r\nqtd = qtd_alloc(flags, urb, packet_type);\r\nif (!qtd)\r\ngoto cleanup;\r\nthis_qtd_len = qtd_fill(qtd, buf, len);\r\nlist_add_tail(&qtd->qtd_list, head);\r\nlen -= this_qtd_len;\r\nbuf += this_qtd_len;\r\nif (len <= 0)\r\nbreak;\r\n}\r\nif (urb->transfer_buffer_length != 0) {\r\nint one_more = 0;\r\nif (usb_pipecontrol(urb->pipe)) {\r\none_more = 1;\r\nif (packet_type == IN_PID)\r\npacket_type = OUT_PID;\r\nelse\r\npacket_type = IN_PID;\r\n} else if (usb_pipebulk(urb->pipe)\r\n&& (urb->transfer_flags & URB_ZERO_PACKET)\r\n&& !(urb->transfer_buffer_length %\r\nmaxpacketsize)) {\r\none_more = 1;\r\n}\r\nif (one_more) {\r\nqtd = qtd_alloc(flags, urb, packet_type);\r\nif (!qtd)\r\ngoto cleanup;\r\nqtd_fill(qtd, NULL, 0);\r\nlist_add_tail(&qtd->qtd_list, head);\r\n}\r\n}\r\nreturn;\r\ncleanup:\r\nqtd_list_free(head);\r\n}\r\nstatic int isp1760_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nstruct isp1760_hcd *priv = hcd_to_priv(hcd);\r\nstruct list_head *ep_queue;\r\nstruct isp1760_qh *qh, *qhit;\r\nunsigned long spinflags;\r\nLIST_HEAD(new_qtds);\r\nint retval;\r\nint qh_in_queue;\r\nswitch (usb_pipetype(urb->pipe)) {\r\ncase PIPE_CONTROL:\r\nep_queue = &priv->qh_list[QH_CONTROL];\r\nbreak;\r\ncase PIPE_BULK:\r\nep_queue = &priv->qh_list[QH_BULK];\r\nbreak;\r\ncase PIPE_INTERRUPT:\r\nif (urb->interval < 0)\r\nreturn -EINVAL;\r\nep_queue = &priv->qh_list[QH_INTERRUPT];\r\nbreak;\r\ncase PIPE_ISOCHRONOUS:\r\ndev_err(hcd->self.controller, "%s: isochronous USB packets "\r\n"not yet supported\n",\r\n__func__);\r\nreturn -EPIPE;\r\ndefault:\r\ndev_err(hcd->self.controller, "%s: unknown pipe type\n",\r\n__func__);\r\nreturn -EPIPE;\r\n}\r\nif (usb_pipein(urb->pipe))\r\nurb->actual_length = 0;\r\npacketize_urb(hcd, urb, &new_qtds, mem_flags);\r\nif (list_empty(&new_qtds))\r\nreturn -ENOMEM;\r\nretval = 0;\r\nspin_lock_irqsave(&priv->lock, spinflags);\r\nif (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags)) {\r\nretval = -ESHUTDOWN;\r\nqtd_list_free(&new_qtds);\r\ngoto out;\r\n}\r\nretval = usb_hcd_link_urb_to_ep(hcd, urb);\r\nif (retval) {\r\nqtd_list_free(&new_qtds);\r\ngoto out;\r\n}\r\nqh = urb->ep->hcpriv;\r\nif (qh) {\r\nqh_in_queue = 0;\r\nlist_for_each_entry(qhit, ep_queue, qh_list) {\r\nif (qhit == qh) {\r\nqh_in_queue = 1;\r\nbreak;\r\n}\r\n}\r\nif (!qh_in_queue)\r\nlist_add_tail(&qh->qh_list, ep_queue);\r\n} else {\r\nqh = qh_alloc(GFP_ATOMIC);\r\nif (!qh) {\r\nretval = -ENOMEM;\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nqtd_list_free(&new_qtds);\r\ngoto out;\r\n}\r\nlist_add_tail(&qh->qh_list, ep_queue);\r\nurb->ep->hcpriv = qh;\r\n}\r\nlist_splice_tail(&new_qtds, &qh->qtd_list);\r\nschedule_ptds(hcd);\r\nout:\r\nspin_unlock_irqrestore(&priv->lock, spinflags);\r\nreturn retval;\r\n}\r\nstatic void kill_transfer(struct usb_hcd *hcd, struct urb *urb,\r\nstruct isp1760_qh *qh)\r\n{\r\nstruct isp1760_hcd *priv = hcd_to_priv(hcd);\r\nint skip_map;\r\nWARN_ON(qh->slot == -1);\r\nif (usb_pipecontrol(urb->pipe) || usb_pipebulk(urb->pipe)) {\r\nskip_map = reg_read32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG);\r\nskip_map |= (1 << qh->slot);\r\nreg_write32(hcd->regs, HC_ATL_PTD_SKIPMAP_REG, skip_map);\r\npriv->atl_slots[qh->slot].qh = NULL;\r\npriv->atl_slots[qh->slot].qtd = NULL;\r\n} else {\r\nskip_map = reg_read32(hcd->regs, HC_INT_PTD_SKIPMAP_REG);\r\nskip_map |= (1 << qh->slot);\r\nreg_write32(hcd->regs, HC_INT_PTD_SKIPMAP_REG, skip_map);\r\npriv->int_slots[qh->slot].qh = NULL;\r\npriv->int_slots[qh->slot].qtd = NULL;\r\n}\r\nqh->slot = -1;\r\n}\r\nstatic void dequeue_urb_from_qtd(struct usb_hcd *hcd, struct isp1760_qh *qh,\r\nstruct isp1760_qtd *qtd)\r\n{\r\nstruct urb *urb;\r\nint urb_was_running;\r\nurb = qtd->urb;\r\nurb_was_running = 0;\r\nlist_for_each_entry_from(qtd, &qh->qtd_list, qtd_list) {\r\nif (qtd->urb != urb)\r\nbreak;\r\nif (qtd->status >= QTD_XFER_STARTED)\r\nurb_was_running = 1;\r\nif (last_qtd_of_urb(qtd, qh) &&\r\n(qtd->status >= QTD_XFER_COMPLETE))\r\nurb_was_running = 0;\r\nif (qtd->status == QTD_XFER_STARTED)\r\nkill_transfer(hcd, urb, qh);\r\nqtd->status = QTD_RETIRE;\r\n}\r\nif ((urb->dev->speed != USB_SPEED_HIGH) && urb_was_running) {\r\nqh->tt_buffer_dirty = 1;\r\nif (usb_hub_clear_tt_buffer(urb))\r\nqh->tt_buffer_dirty = 0;\r\n}\r\n}\r\nstatic int isp1760_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,\r\nint status)\r\n{\r\nstruct isp1760_hcd *priv = hcd_to_priv(hcd);\r\nunsigned long spinflags;\r\nstruct isp1760_qh *qh;\r\nstruct isp1760_qtd *qtd;\r\nint retval = 0;\r\nspin_lock_irqsave(&priv->lock, spinflags);\r\nretval = usb_hcd_check_unlink_urb(hcd, urb, status);\r\nif (retval)\r\ngoto out;\r\nqh = urb->ep->hcpriv;\r\nif (!qh) {\r\nretval = -EINVAL;\r\ngoto out;\r\n}\r\nlist_for_each_entry(qtd, &qh->qtd_list, qtd_list)\r\nif (qtd->urb == urb) {\r\ndequeue_urb_from_qtd(hcd, qh, qtd);\r\nlist_move(&qtd->qtd_list, &qh->qtd_list);\r\nbreak;\r\n}\r\nurb->status = status;\r\nschedule_ptds(hcd);\r\nout:\r\nspin_unlock_irqrestore(&priv->lock, spinflags);\r\nreturn retval;\r\n}\r\nstatic void isp1760_endpoint_disable(struct usb_hcd *hcd,\r\nstruct usb_host_endpoint *ep)\r\n{\r\nstruct isp1760_hcd *priv = hcd_to_priv(hcd);\r\nunsigned long spinflags;\r\nstruct isp1760_qh *qh, *qh_iter;\r\nint i;\r\nspin_lock_irqsave(&priv->lock, spinflags);\r\nqh = ep->hcpriv;\r\nif (!qh)\r\ngoto out;\r\nWARN_ON(!list_empty(&qh->qtd_list));\r\nfor (i = 0; i < QH_END; i++)\r\nlist_for_each_entry(qh_iter, &priv->qh_list[i], qh_list)\r\nif (qh_iter == qh) {\r\nlist_del(&qh_iter->qh_list);\r\ni = QH_END;\r\nbreak;\r\n}\r\nqh_free(qh);\r\nep->hcpriv = NULL;\r\nschedule_ptds(hcd);\r\nout:\r\nspin_unlock_irqrestore(&priv->lock, spinflags);\r\n}\r\nstatic int isp1760_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct isp1760_hcd *priv = hcd_to_priv(hcd);\r\nu32 temp, status = 0;\r\nu32 mask;\r\nint retval = 1;\r\nunsigned long flags;\r\nif (!HC_IS_RUNNING(hcd->state))\r\nreturn 0;\r\nbuf[0] = 0;\r\nmask = PORT_CSC;\r\nspin_lock_irqsave(&priv->lock, flags);\r\ntemp = reg_read32(hcd->regs, HC_PORTSC1);\r\nif (temp & PORT_OWNER) {\r\nif (temp & PORT_CSC) {\r\ntemp &= ~PORT_CSC;\r\nreg_write32(hcd->regs, HC_PORTSC1, temp);\r\ngoto done;\r\n}\r\n}\r\nif ((temp & mask) != 0\r\n|| ((temp & PORT_RESUME) != 0\r\n&& time_after_eq(jiffies,\r\npriv->reset_done))) {\r\nbuf [0] |= 1 << (0 + 1);\r\nstatus = STS_PCD;\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn status ? retval : 0;\r\n}\r\nstatic void isp1760_hub_descriptor(struct isp1760_hcd *priv,\r\nstruct usb_hub_descriptor *desc)\r\n{\r\nint ports = HCS_N_PORTS(priv->hcs_params);\r\nu16 temp;\r\ndesc->bDescriptorType = 0x29;\r\ndesc->bPwrOn2PwrGood = 10;\r\ndesc->bHubContrCurrent = 0;\r\ndesc->bNbrPorts = ports;\r\ntemp = 1 + (ports / 8);\r\ndesc->bDescLength = 7 + 2 * temp;\r\nmemset(&desc->u.hs.DeviceRemovable[0], 0, temp);\r\nmemset(&desc->u.hs.DeviceRemovable[temp], 0xff, temp);\r\ntemp = 0x0008;\r\nif (HCS_PPC(priv->hcs_params))\r\ntemp |= 0x0001;\r\nelse\r\ntemp |= 0x0002;\r\ndesc->wHubCharacteristics = cpu_to_le16(temp);\r\n}\r\nstatic int check_reset_complete(struct usb_hcd *hcd, int index,\r\nint port_status)\r\n{\r\nif (!(port_status & PORT_CONNECT))\r\nreturn port_status;\r\nif (!(port_status & PORT_PE)) {\r\ndev_info(hcd->self.controller,\r\n"port %d full speed --> companion\n",\r\nindex + 1);\r\nport_status |= PORT_OWNER;\r\nport_status &= ~PORT_RWC_BITS;\r\nreg_write32(hcd->regs, HC_PORTSC1, port_status);\r\n} else\r\ndev_info(hcd->self.controller, "port %d high speed\n",\r\nindex + 1);\r\nreturn port_status;\r\n}\r\nstatic int isp1760_hub_control(struct usb_hcd *hcd, u16 typeReq,\r\nu16 wValue, u16 wIndex, char *buf, u16 wLength)\r\n{\r\nstruct isp1760_hcd *priv = hcd_to_priv(hcd);\r\nint ports = HCS_N_PORTS(priv->hcs_params);\r\nu32 temp, status;\r\nunsigned long flags;\r\nint retval = 0;\r\nunsigned selector;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nswitch (typeReq) {\r\ncase ClearHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_LOCAL_POWER:\r\ncase C_HUB_OVER_CURRENT:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase ClearPortFeature:\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\ntemp = reg_read32(hcd->regs, HC_PORTSC1);\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_ENABLE:\r\nreg_write32(hcd->regs, HC_PORTSC1, temp & ~PORT_PE);\r\nbreak;\r\ncase USB_PORT_FEAT_C_ENABLE:\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\nif (temp & PORT_RESET)\r\ngoto error;\r\nif (temp & PORT_SUSPEND) {\r\nif ((temp & PORT_PE) == 0)\r\ngoto error;\r\ntemp &= ~(PORT_RWC_BITS);\r\nreg_write32(hcd->regs, HC_PORTSC1,\r\ntemp | PORT_RESUME);\r\npriv->reset_done = jiffies +\r\nmsecs_to_jiffies(20);\r\n}\r\nbreak;\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nif (HCS_PPC(priv->hcs_params))\r\nreg_write32(hcd->regs, HC_PORTSC1,\r\ntemp & ~PORT_POWER);\r\nbreak;\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\nreg_write32(hcd->regs, HC_PORTSC1, temp | PORT_CSC);\r\nbreak;\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\nbreak;\r\ncase USB_PORT_FEAT_C_RESET:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nreg_read32(hcd->regs, HC_USBCMD);\r\nbreak;\r\ncase GetHubDescriptor:\r\nisp1760_hub_descriptor(priv, (struct usb_hub_descriptor *)\r\nbuf);\r\nbreak;\r\ncase GetHubStatus:\r\nmemset(buf, 0, 4);\r\nbreak;\r\ncase GetPortStatus:\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\nstatus = 0;\r\ntemp = reg_read32(hcd->regs, HC_PORTSC1);\r\nif (temp & PORT_CSC)\r\nstatus |= USB_PORT_STAT_C_CONNECTION << 16;\r\nif (temp & PORT_RESUME) {\r\ndev_err(hcd->self.controller, "Port resume should be skipped.\n");\r\nif (!priv->reset_done) {\r\npriv->reset_done = jiffies\r\n+ msecs_to_jiffies(20);\r\nmod_timer(&hcd->rh_timer, priv->reset_done);\r\n}\r\nelse if (time_after_eq(jiffies,\r\npriv->reset_done)) {\r\nstatus |= USB_PORT_STAT_C_SUSPEND << 16;\r\npriv->reset_done = 0;\r\ntemp = reg_read32(hcd->regs, HC_PORTSC1);\r\nreg_write32(hcd->regs, HC_PORTSC1,\r\ntemp & ~(PORT_RWC_BITS | PORT_RESUME));\r\nretval = handshake(hcd, HC_PORTSC1,\r\nPORT_RESUME, 0, 2000 );\r\nif (retval != 0) {\r\ndev_err(hcd->self.controller,\r\n"port %d resume error %d\n",\r\nwIndex + 1, retval);\r\ngoto error;\r\n}\r\ntemp &= ~(PORT_SUSPEND|PORT_RESUME|(3<<10));\r\n}\r\n}\r\nif ((temp & PORT_RESET)\r\n&& time_after_eq(jiffies,\r\npriv->reset_done)) {\r\nstatus |= USB_PORT_STAT_C_RESET << 16;\r\npriv->reset_done = 0;\r\nreg_write32(hcd->regs, HC_PORTSC1, temp & ~PORT_RESET);\r\nretval = handshake(hcd, HC_PORTSC1,\r\nPORT_RESET, 0, 750);\r\nif (retval != 0) {\r\ndev_err(hcd->self.controller, "port %d reset error %d\n",\r\nwIndex + 1, retval);\r\ngoto error;\r\n}\r\ntemp = check_reset_complete(hcd, wIndex,\r\nreg_read32(hcd->regs, HC_PORTSC1));\r\n}\r\nif (temp & PORT_OWNER)\r\ndev_err(hcd->self.controller, "PORT_OWNER is set\n");\r\nif (temp & PORT_CONNECT) {\r\nstatus |= USB_PORT_STAT_CONNECTION;\r\nstatus |= USB_PORT_STAT_HIGH_SPEED;\r\n}\r\nif (temp & PORT_PE)\r\nstatus |= USB_PORT_STAT_ENABLE;\r\nif (temp & (PORT_SUSPEND|PORT_RESUME))\r\nstatus |= USB_PORT_STAT_SUSPEND;\r\nif (temp & PORT_RESET)\r\nstatus |= USB_PORT_STAT_RESET;\r\nif (temp & PORT_POWER)\r\nstatus |= USB_PORT_STAT_POWER;\r\nput_unaligned(cpu_to_le32(status), (__le32 *) buf);\r\nbreak;\r\ncase SetHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_LOCAL_POWER:\r\ncase C_HUB_OVER_CURRENT:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase SetPortFeature:\r\nselector = wIndex >> 8;\r\nwIndex &= 0xff;\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\ntemp = reg_read32(hcd->regs, HC_PORTSC1);\r\nif (temp & PORT_OWNER)\r\nbreak;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_ENABLE:\r\nreg_write32(hcd->regs, HC_PORTSC1, temp | PORT_PE);\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\nif ((temp & PORT_PE) == 0\r\n|| (temp & PORT_RESET) != 0)\r\ngoto error;\r\nreg_write32(hcd->regs, HC_PORTSC1, temp | PORT_SUSPEND);\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nif (HCS_PPC(priv->hcs_params))\r\nreg_write32(hcd->regs, HC_PORTSC1,\r\ntemp | PORT_POWER);\r\nbreak;\r\ncase USB_PORT_FEAT_RESET:\r\nif (temp & PORT_RESUME)\r\ngoto error;\r\nif ((temp & (PORT_PE|PORT_CONNECT)) == PORT_CONNECT\r\n&& PORT_USB11(temp)) {\r\ntemp |= PORT_OWNER;\r\n} else {\r\ntemp |= PORT_RESET;\r\ntemp &= ~PORT_PE;\r\npriv->reset_done = jiffies +\r\nmsecs_to_jiffies(50);\r\n}\r\nreg_write32(hcd->regs, HC_PORTSC1, temp);\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nreg_read32(hcd->regs, HC_USBCMD);\r\nbreak;\r\ndefault:\r\nerror:\r\nretval = -EPIPE;\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int isp1760_get_frame(struct usb_hcd *hcd)\r\n{\r\nstruct isp1760_hcd *priv = hcd_to_priv(hcd);\r\nu32 fr;\r\nfr = reg_read32(hcd->regs, HC_FRINDEX);\r\nreturn (fr >> 3) % priv->periodic_size;\r\n}\r\nstatic void isp1760_stop(struct usb_hcd *hcd)\r\n{\r\nstruct isp1760_hcd *priv = hcd_to_priv(hcd);\r\nu32 temp;\r\ndel_timer(&errata2_timer);\r\nisp1760_hub_control(hcd, ClearPortFeature, USB_PORT_FEAT_POWER, 1,\r\nNULL, 0);\r\nmdelay(20);\r\nspin_lock_irq(&priv->lock);\r\nehci_reset(hcd);\r\ntemp = reg_read32(hcd->regs, HC_HW_MODE_CTRL);\r\nreg_write32(hcd->regs, HC_HW_MODE_CTRL, temp &= ~HW_GLOBAL_INTR_EN);\r\nspin_unlock_irq(&priv->lock);\r\nreg_write32(hcd->regs, HC_CONFIGFLAG, 0);\r\n}\r\nstatic void isp1760_shutdown(struct usb_hcd *hcd)\r\n{\r\nu32 command, temp;\r\nisp1760_stop(hcd);\r\ntemp = reg_read32(hcd->regs, HC_HW_MODE_CTRL);\r\nreg_write32(hcd->regs, HC_HW_MODE_CTRL, temp &= ~HW_GLOBAL_INTR_EN);\r\ncommand = reg_read32(hcd->regs, HC_USBCMD);\r\ncommand &= ~CMD_RUN;\r\nreg_write32(hcd->regs, HC_USBCMD, command);\r\n}\r\nstatic void isp1760_clear_tt_buffer_complete(struct usb_hcd *hcd,\r\nstruct usb_host_endpoint *ep)\r\n{\r\nstruct isp1760_hcd *priv = hcd_to_priv(hcd);\r\nstruct isp1760_qh *qh = ep->hcpriv;\r\nunsigned long spinflags;\r\nif (!qh)\r\nreturn;\r\nspin_lock_irqsave(&priv->lock, spinflags);\r\nqh->tt_buffer_dirty = 0;\r\nschedule_ptds(hcd);\r\nspin_unlock_irqrestore(&priv->lock, spinflags);\r\n}\r\nint __init init_kmem_once(void)\r\n{\r\nurb_listitem_cachep = kmem_cache_create("isp1760_urb_listitem",\r\nsizeof(struct urb_listitem), 0, SLAB_TEMPORARY |\r\nSLAB_MEM_SPREAD, NULL);\r\nif (!urb_listitem_cachep)\r\nreturn -ENOMEM;\r\nqtd_cachep = kmem_cache_create("isp1760_qtd",\r\nsizeof(struct isp1760_qtd), 0, SLAB_TEMPORARY |\r\nSLAB_MEM_SPREAD, NULL);\r\nif (!qtd_cachep)\r\nreturn -ENOMEM;\r\nqh_cachep = kmem_cache_create("isp1760_qh", sizeof(struct isp1760_qh),\r\n0, SLAB_TEMPORARY | SLAB_MEM_SPREAD, NULL);\r\nif (!qh_cachep) {\r\nkmem_cache_destroy(qtd_cachep);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid deinit_kmem_cache(void)\r\n{\r\nkmem_cache_destroy(qtd_cachep);\r\nkmem_cache_destroy(qh_cachep);\r\nkmem_cache_destroy(urb_listitem_cachep);\r\n}\r\nstruct usb_hcd *isp1760_register(phys_addr_t res_start, resource_size_t res_len,\r\nint irq, unsigned long irqflags,\r\nint rst_gpio,\r\nstruct device *dev, const char *busname,\r\nunsigned int devflags)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct isp1760_hcd *priv;\r\nint ret;\r\nif (usb_disabled())\r\nreturn ERR_PTR(-ENODEV);\r\ndev->dma_mask = NULL;\r\nhcd = usb_create_hcd(&isp1760_hc_driver, dev, dev_name(dev));\r\nif (!hcd)\r\nreturn ERR_PTR(-ENOMEM);\r\npriv = hcd_to_priv(hcd);\r\npriv->devflags = devflags;\r\npriv->rst_gpio = rst_gpio;\r\ninit_memory(priv);\r\nhcd->regs = ioremap(res_start, res_len);\r\nif (!hcd->regs) {\r\nret = -EIO;\r\ngoto err_put;\r\n}\r\nhcd->irq = irq;\r\nhcd->rsrc_start = res_start;\r\nhcd->rsrc_len = res_len;\r\nret = usb_add_hcd(hcd, irq, irqflags);\r\nif (ret)\r\ngoto err_unmap;\r\ndevice_wakeup_enable(hcd->self.controller);\r\nreturn hcd;\r\nerr_unmap:\r\niounmap(hcd->regs);\r\nerr_put:\r\nusb_put_hcd(hcd);\r\nreturn ERR_PTR(ret);\r\n}
