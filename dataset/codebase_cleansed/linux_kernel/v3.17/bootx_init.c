static void __init bootx_printf(const char *format, ...)\r\n{\r\nconst char *p, *q, *s;\r\nva_list args;\r\nunsigned long v;\r\nva_start(args, format);\r\nfor (p = format; *p != 0; p = q) {\r\nfor (q = p; *q != 0 && *q != '\n' && *q != '%'; ++q)\r\n;\r\nif (q > p)\r\nbtext_drawtext(p, q - p);\r\nif (*q == 0)\r\nbreak;\r\nif (*q == '\n') {\r\n++q;\r\nbtext_flushline();\r\nbtext_drawstring("\r\n");\r\nbtext_flushline();\r\ncontinue;\r\n}\r\n++q;\r\nif (*q == 0)\r\nbreak;\r\nswitch (*q) {\r\ncase 's':\r\n++q;\r\ns = va_arg(args, const char *);\r\nif (s == NULL)\r\ns = "<NULL>";\r\nbtext_drawstring(s);\r\nbreak;\r\ncase 'x':\r\n++q;\r\nv = va_arg(args, unsigned long);\r\nbtext_drawhex(v);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void __init bootx_printf(const char *format, ...) {}\r\nstatic void * __init bootx_early_getprop(unsigned long base,\r\nunsigned long node,\r\nchar *prop)\r\n{\r\nstruct bootx_dt_node *np = (struct bootx_dt_node *)(base + node);\r\nu32 *ppp = &np->properties;\r\nwhile(*ppp) {\r\nstruct bootx_dt_prop *pp =\r\n(struct bootx_dt_prop *)(base + *ppp);\r\nif (strcmp((char *)((unsigned long)pp->name + base),\r\nprop) == 0) {\r\nreturn (void *)((unsigned long)pp->value + base);\r\n}\r\nppp = &pp->next;\r\n}\r\nreturn NULL;\r\n}\r\nstatic unsigned long __init bootx_dt_find_string(char *str)\r\n{\r\nchar *s, *os;\r\ns = os = (char *)bootx_dt_strbase;\r\ns += 4;\r\nwhile (s < (char *)bootx_dt_strend) {\r\nif (strcmp(s, str) == 0)\r\nreturn s - os;\r\ns += strlen(s) + 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init bootx_dt_add_prop(char *name, void *data, int size,\r\nunsigned long *mem_end)\r\n{\r\nunsigned long soff = bootx_dt_find_string(name);\r\nif (data == NULL)\r\nsize = 0;\r\nif (soff == 0) {\r\nbootx_printf("WARNING: Can't find string index for <%s>\n",\r\nname);\r\nreturn;\r\n}\r\nif (size > 0x20000) {\r\nbootx_printf("WARNING: ignoring large property ");\r\nbootx_printf("%s length 0x%x\n", name, size);\r\nreturn;\r\n}\r\ndt_push_token(OF_DT_PROP, mem_end);\r\ndt_push_token(size, mem_end);\r\ndt_push_token(soff, mem_end);\r\nif (size && data) {\r\nmemcpy((void *)*mem_end, data, size);\r\n*mem_end = _ALIGN_UP(*mem_end + size, 4);\r\n}\r\n}\r\nstatic void __init bootx_add_chosen_props(unsigned long base,\r\nunsigned long *mem_end)\r\n{\r\nu32 val;\r\nbootx_dt_add_prop("linux,bootx", NULL, 0, mem_end);\r\nif (bootx_info->kernelParamsOffset) {\r\nchar *args = (char *)((unsigned long)bootx_info) +\r\nbootx_info->kernelParamsOffset;\r\nbootx_dt_add_prop("bootargs", args, strlen(args) + 1, mem_end);\r\n}\r\nif (bootx_info->ramDisk) {\r\nval = ((unsigned long)bootx_info) + bootx_info->ramDisk;\r\nbootx_dt_add_prop("linux,initrd-start", &val, 4, mem_end);\r\nval += bootx_info->ramDiskSize;\r\nbootx_dt_add_prop("linux,initrd-end", &val, 4, mem_end);\r\n}\r\nif (strlen(bootx_disp_path))\r\nbootx_dt_add_prop("linux,stdout-path", bootx_disp_path,\r\nstrlen(bootx_disp_path) + 1, mem_end);\r\n}\r\nstatic void __init bootx_add_display_props(unsigned long base,\r\nunsigned long *mem_end,\r\nint has_real_node)\r\n{\r\nboot_infos_t *bi = bootx_info;\r\nu32 tmp;\r\nif (has_real_node) {\r\nbootx_dt_add_prop("linux,boot-display", NULL, 0, mem_end);\r\nbootx_dt_add_prop("linux,opened", NULL, 0, mem_end);\r\n} else\r\nbootx_dt_add_prop("linux,bootx-noscreen", NULL, 0, mem_end);\r\ntmp = bi->dispDeviceDepth;\r\nbootx_dt_add_prop("linux,bootx-depth", &tmp, 4, mem_end);\r\ntmp = bi->dispDeviceRect[2] - bi->dispDeviceRect[0];\r\nbootx_dt_add_prop("linux,bootx-width", &tmp, 4, mem_end);\r\ntmp = bi->dispDeviceRect[3] - bi->dispDeviceRect[1];\r\nbootx_dt_add_prop("linux,bootx-height", &tmp, 4, mem_end);\r\ntmp = bi->dispDeviceRowBytes;\r\nbootx_dt_add_prop("linux,bootx-linebytes", &tmp, 4, mem_end);\r\ntmp = (u32)bi->dispDeviceBase;\r\nif (tmp == 0)\r\ntmp = (u32)bi->logicalDisplayBase;\r\ntmp += bi->dispDeviceRect[1] * bi->dispDeviceRowBytes;\r\ntmp += bi->dispDeviceRect[0] * ((bi->dispDeviceDepth + 7) / 8);\r\nbootx_dt_add_prop("linux,bootx-addr", &tmp, 4, mem_end);\r\n}\r\nstatic void __init bootx_dt_add_string(char *s, unsigned long *mem_end)\r\n{\r\nunsigned int l = strlen(s) + 1;\r\nmemcpy((void *)*mem_end, s, l);\r\nbootx_dt_strend = *mem_end = *mem_end + l;\r\n}\r\nstatic void __init bootx_scan_dt_build_strings(unsigned long base,\r\nunsigned long node,\r\nunsigned long *mem_end)\r\n{\r\nstruct bootx_dt_node *np = (struct bootx_dt_node *)(base + node);\r\nu32 *cpp, *ppp = &np->properties;\r\nunsigned long soff;\r\nchar *namep;\r\nnamep = np->full_name ? (char *)(base + np->full_name) : NULL;\r\nif (namep == NULL) {\r\nbootx_printf("Node without a full name !\n");\r\nnamep = "";\r\n}\r\nDBG("* strings: %s\n", namep);\r\nif (!strcmp(namep, "/chosen")) {\r\nDBG(" detected /chosen ! adding properties names !\n");\r\nbootx_dt_add_string("linux,bootx", mem_end);\r\nbootx_dt_add_string("linux,stdout-path", mem_end);\r\nbootx_dt_add_string("linux,initrd-start", mem_end);\r\nbootx_dt_add_string("linux,initrd-end", mem_end);\r\nbootx_dt_add_string("bootargs", mem_end);\r\nbootx_node_chosen = node;\r\n}\r\nif (node == bootx_info->dispDeviceRegEntryOffset) {\r\nDBG(" detected display ! adding properties names !\n");\r\nbootx_dt_add_string("linux,boot-display", mem_end);\r\nbootx_dt_add_string("linux,opened", mem_end);\r\nstrncpy(bootx_disp_path, namep, 255);\r\n}\r\nwhile (*ppp) {\r\nstruct bootx_dt_prop *pp =\r\n(struct bootx_dt_prop *)(base + *ppp);\r\nnamep = pp->name ? (char *)(base + pp->name) : NULL;\r\nif (namep == NULL || strcmp(namep, "name") == 0)\r\ngoto next;\r\nsoff = bootx_dt_find_string(namep);\r\nif (soff == 0)\r\nbootx_dt_add_string(namep, mem_end);\r\nnext:\r\nppp = &pp->next;\r\n}\r\ncpp = &np->child;\r\nwhile(*cpp) {\r\nnp = (struct bootx_dt_node *)(base + *cpp);\r\nbootx_scan_dt_build_strings(base, *cpp, mem_end);\r\ncpp = &np->sibling;\r\n}\r\n}\r\nstatic void __init bootx_scan_dt_build_struct(unsigned long base,\r\nunsigned long node,\r\nunsigned long *mem_end)\r\n{\r\nstruct bootx_dt_node *np = (struct bootx_dt_node *)(base + node);\r\nu32 *cpp, *ppp = &np->properties;\r\nchar *namep, *p, *ep, *lp;\r\nint l;\r\ndt_push_token(OF_DT_BEGIN_NODE, mem_end);\r\nnamep = np->full_name ? (char *)(base + np->full_name) : NULL;\r\nif (namep == NULL)\r\nnamep = "";\r\nl = strlen(namep);\r\nDBG("* struct: %s\n", namep);\r\nmemcpy((void *)*mem_end, namep, l + 1);\r\nnamep = (char *)*mem_end;\r\nfor (lp = p = namep, ep = namep + l; p < ep; p++) {\r\nif (*p == '/')\r\nlp = namep;\r\nelse if (*p != 0)\r\n*lp++ = *p;\r\n}\r\n*lp = 0;\r\n*mem_end = _ALIGN_UP((unsigned long)lp + 1, 4);\r\nwhile (*ppp) {\r\nstruct bootx_dt_prop *pp =\r\n(struct bootx_dt_prop *)(base + *ppp);\r\nnamep = pp->name ? (char *)(base + pp->name) : NULL;\r\nif (namep == NULL || !strcmp(namep, "name"))\r\ngoto next;\r\nif (node == bootx_node_chosen && !strcmp(namep, "bootargs"))\r\ngoto next;\r\nbootx_dt_add_prop(namep,\r\npp->value ? (void *)(base + pp->value): NULL,\r\npp->length, mem_end);\r\nnext:\r\nppp = &pp->next;\r\n}\r\nif (node == bootx_node_chosen) {\r\nbootx_add_chosen_props(base, mem_end);\r\nif (bootx_info->dispDeviceRegEntryOffset == 0)\r\nbootx_add_display_props(base, mem_end, 0);\r\n}\r\nelse if (node == bootx_info->dispDeviceRegEntryOffset)\r\nbootx_add_display_props(base, mem_end, 1);\r\ncpp = &np->child;\r\nwhile(*cpp) {\r\nnp = (struct bootx_dt_node *)(base + *cpp);\r\nbootx_scan_dt_build_struct(base, *cpp, mem_end);\r\ncpp = &np->sibling;\r\n}\r\ndt_push_token(OF_DT_END_NODE, mem_end);\r\n}\r\nstatic unsigned long __init bootx_flatten_dt(unsigned long start)\r\n{\r\nboot_infos_t *bi = bootx_info;\r\nunsigned long mem_start, mem_end;\r\nstruct boot_param_header *hdr;\r\nunsigned long base;\r\nu64 *rsvmap;\r\nmem_start = mem_end = _ALIGN_UP(((unsigned long)bi) + start, 4);\r\nDBG("Boot params header at: %x\n", mem_start);\r\nhdr = (struct boot_param_header *)mem_start;\r\nmem_end += sizeof(struct boot_param_header);\r\nrsvmap = (u64 *)(_ALIGN_UP(mem_end, 8));\r\nhdr->off_mem_rsvmap = ((unsigned long)rsvmap) - mem_start;\r\nmem_end = ((unsigned long)rsvmap) + 8 * sizeof(u64);\r\nbase = ((unsigned long)bi) + bi->deviceTreeOffset;\r\nDBG("Building string array at: %x\n", mem_end);\r\nDBG("Device Tree Base=%x\n", base);\r\nbootx_dt_strbase = mem_end;\r\nmem_end += 4;\r\nbootx_dt_strend = mem_end;\r\nbootx_scan_dt_build_strings(base, 4, &mem_end);\r\nbootx_dt_add_string("linux,bootx-noscreen", &mem_end);\r\nbootx_dt_add_string("linux,bootx-depth", &mem_end);\r\nbootx_dt_add_string("linux,bootx-width", &mem_end);\r\nbootx_dt_add_string("linux,bootx-height", &mem_end);\r\nbootx_dt_add_string("linux,bootx-linebytes", &mem_end);\r\nbootx_dt_add_string("linux,bootx-addr", &mem_end);\r\nhdr->off_dt_strings = bootx_dt_strbase - mem_start;\r\nhdr->dt_strings_size = bootx_dt_strend - bootx_dt_strbase;\r\nmem_end = _ALIGN(mem_end, 16);\r\nDBG("Building device tree structure at: %x\n", mem_end);\r\nhdr->off_dt_struct = mem_end - mem_start;\r\nbootx_scan_dt_build_struct(base, 4, &mem_end);\r\ndt_push_token(OF_DT_END, &mem_end);\r\nhdr->boot_cpuid_phys = 0;\r\nhdr->magic = OF_DT_HEADER;\r\nhdr->totalsize = mem_end - mem_start;\r\nhdr->version = OF_DT_VERSION;\r\nhdr->last_comp_version = 0x10;\r\nmem_end = _ALIGN(mem_end, PAGE_SIZE);\r\nDBG("End of boot params: %x\n", mem_end);\r\nrsvmap[0] = mem_start;\r\nrsvmap[1] = mem_end;\r\nif (bootx_info->ramDisk) {\r\nrsvmap[2] = ((unsigned long)bootx_info) + bootx_info->ramDisk;\r\nrsvmap[3] = rsvmap[2] + bootx_info->ramDiskSize;\r\nrsvmap[4] = 0;\r\nrsvmap[5] = 0;\r\n} else {\r\nrsvmap[2] = 0;\r\nrsvmap[3] = 0;\r\n}\r\nreturn (unsigned long)hdr;\r\n}\r\nstatic void __init btext_welcome(boot_infos_t *bi)\r\n{\r\nunsigned long flags;\r\nunsigned long pvr;\r\nbootx_printf("Welcome to Linux, kernel " UTS_RELEASE "\n");\r\nbootx_printf("\nlinked at : 0x%x", KERNELBASE);\r\nbootx_printf("\nframe buffer at : 0x%x", bi->dispDeviceBase);\r\nbootx_printf(" (phys), 0x%x", bi->logicalDisplayBase);\r\nbootx_printf(" (log)");\r\nbootx_printf("\nklimit : 0x%x",(unsigned long)klimit);\r\nbootx_printf("\nboot_info at : 0x%x", bi);\r\n__asm__ __volatile__ ("mfmsr %0" : "=r" (flags));\r\nbootx_printf("\nMSR : 0x%x", flags);\r\n__asm__ __volatile__ ("mfspr %0, 287" : "=r" (pvr));\r\nbootx_printf("\nPVR : 0x%x", pvr);\r\npvr >>= 16;\r\nif (pvr > 1) {\r\n__asm__ __volatile__ ("mfspr %0, 1008" : "=r" (flags));\r\nbootx_printf("\nHID0 : 0x%x", flags);\r\n}\r\nif (pvr == 8 || pvr == 12 || pvr == 0x800c) {\r\n__asm__ __volatile__ ("mfspr %0, 1019" : "=r" (flags));\r\nbootx_printf("\nICTC : 0x%x", flags);\r\n}\r\n#ifdef DEBUG\r\nbootx_printf("\n\n");\r\nbootx_printf("bi->deviceTreeOffset : 0x%x\n",\r\nbi->deviceTreeOffset);\r\nbootx_printf("bi->deviceTreeSize : 0x%x\n",\r\nbi->deviceTreeSize);\r\n#endif\r\nbootx_printf("\n\n");\r\n}\r\nvoid __init bootx_init(unsigned long r3, unsigned long r4)\r\n{\r\nboot_infos_t *bi = (boot_infos_t *) r4;\r\nunsigned long hdr;\r\nunsigned long space;\r\nunsigned long ptr, x;\r\nchar *model;\r\nunsigned long offset = reloc_offset();\r\nreloc_got2(offset);\r\nbootx_info = bi;\r\nbootx_dt_strbase = bootx_dt_strend = 0;\r\nbootx_node_chosen = 0;\r\nbootx_disp_path[0] = 0;\r\nif (!BOOT_INFO_IS_V2_COMPATIBLE(bi))\r\nbi->logicalDisplayBase = bi->dispDeviceBase;\r\nif (bi->dispDeviceDepth == 16)\r\nbi->dispDeviceDepth = 15;\r\n#ifdef CONFIG_BOOTX_TEXT\r\nptr = (unsigned long)bi->logicalDisplayBase;\r\nptr += bi->dispDeviceRect[1] * bi->dispDeviceRowBytes;\r\nptr += bi->dispDeviceRect[0] * ((bi->dispDeviceDepth + 7) / 8);\r\nbtext_setup_display(bi->dispDeviceRect[2] - bi->dispDeviceRect[0],\r\nbi->dispDeviceRect[3] - bi->dispDeviceRect[1],\r\nbi->dispDeviceDepth, bi->dispDeviceRowBytes,\r\n(unsigned long)bi->logicalDisplayBase);\r\nbtext_clearscreen();\r\nbtext_flushscreen();\r\n#endif\r\nif (!BOOT_INFO_IS_COMPATIBLE(bi)) {\r\nbootx_printf(" !!! WARNING - Incompatible version"\r\n" of BootX !!!\n\n\n");\r\nfor (;;)\r\n;\r\n}\r\nif (bi->architecture != BOOT_ARCH_PCI) {\r\nbootx_printf(" !!! WARNING - Usupported machine"\r\n" architecture !\n");\r\nfor (;;)\r\n;\r\n}\r\n#ifdef CONFIG_BOOTX_TEXT\r\nbtext_welcome(bi);\r\n#endif\r\nif (bi->version < 4) {\r\nmodel = (char *) bootx_early_getprop(r4 + bi->deviceTreeOffset,\r\n4, "model");\r\nif (model\r\n&& (strcmp(model, "iMac,1") == 0\r\n|| strcmp(model, "PowerMac1,1") == 0)) {\r\nbootx_printf("iMac,1 detected, shutting down USB\n");\r\nout_le32((unsigned __iomem *)0x80880008, 1);\r\n}\r\n}\r\nif (bi->version < 5) {\r\nspace = bi->deviceTreeOffset + bi->deviceTreeSize;\r\nif (bi->ramDisk >= space)\r\nspace = bi->ramDisk + bi->ramDiskSize;\r\n} else\r\nspace = bi->totalParamsSize;\r\nbootx_printf("Total space used by parameters & ramdisk: 0x%x\n", space);\r\nif (bi->version < 4) {\r\nbootx_printf("Touching pages...\n");\r\nfor (ptr = ((unsigned long) &_stext) & PAGE_MASK;\r\nptr < (unsigned long)bi + space; ptr += PAGE_SIZE)\r\nx = *(volatile unsigned long *)ptr;\r\n}\r\nbootx_printf("Preparing boot params...\n");\r\nhdr = bootx_flatten_dt(space);\r\n#ifdef CONFIG_BOOTX_TEXT\r\n#ifdef SET_BOOT_BAT\r\nbootx_printf("Preparing BAT...\n");\r\nbtext_prepare_BAT();\r\n#else\r\nbtext_unmap();\r\n#endif\r\n#endif\r\nreloc_got2(-offset);\r\n__start(hdr, KERNELBASE + offset, 0);\r\n}
