static u32 goldfish_cmd_status(struct goldfish_pipe *pipe, u32 cmd)\r\n{\r\nunsigned long flags;\r\nu32 status;\r\nstruct goldfish_pipe_dev *dev = pipe->dev;\r\nspin_lock_irqsave(&dev->lock, flags);\r\ngf_write64((u64)(unsigned long)pipe, dev->base + PIPE_REG_CHANNEL,\r\ndev->base + PIPE_REG_CHANNEL_HIGH);\r\nwritel(cmd, dev->base + PIPE_REG_COMMAND);\r\nstatus = readl(dev->base + PIPE_REG_STATUS);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn status;\r\n}\r\nstatic void goldfish_cmd(struct goldfish_pipe *pipe, u32 cmd)\r\n{\r\nunsigned long flags;\r\nstruct goldfish_pipe_dev *dev = pipe->dev;\r\nspin_lock_irqsave(&dev->lock, flags);\r\ngf_write64((u64)(unsigned long)pipe, dev->base + PIPE_REG_CHANNEL,\r\ndev->base + PIPE_REG_CHANNEL_HIGH);\r\nwritel(cmd, dev->base + PIPE_REG_COMMAND);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\n}\r\nstatic int goldfish_pipe_error_convert(int status)\r\n{\r\nswitch (status) {\r\ncase PIPE_ERROR_AGAIN:\r\nreturn -EAGAIN;\r\ncase PIPE_ERROR_NOMEM:\r\nreturn -ENOMEM;\r\ncase PIPE_ERROR_IO:\r\nreturn -EIO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int valid_batchbuffer_addr(struct goldfish_pipe_dev *dev,\r\nstruct access_params *aps)\r\n{\r\nu32 aph, apl;\r\nu64 paddr;\r\naph = readl(dev->base + PIPE_REG_PARAMS_ADDR_HIGH);\r\napl = readl(dev->base + PIPE_REG_PARAMS_ADDR_LOW);\r\npaddr = ((u64)aph << 32) | apl;\r\nif (paddr != (__pa(aps)))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int setup_access_params_addr(struct platform_device *pdev,\r\nstruct goldfish_pipe_dev *dev)\r\n{\r\nu64 paddr;\r\nstruct access_params *aps;\r\naps = devm_kzalloc(&pdev->dev, sizeof(struct access_params), GFP_KERNEL);\r\nif (!aps)\r\nreturn -1;\r\npaddr = __pa(aps);\r\nwritel((u32)(paddr >> 32), dev->base + PIPE_REG_PARAMS_ADDR_HIGH);\r\nwritel((u32)paddr, dev->base + PIPE_REG_PARAMS_ADDR_LOW);\r\nif (valid_batchbuffer_addr(dev, aps)) {\r\ndev->aps = aps;\r\nreturn 0;\r\n} else\r\nreturn -1;\r\n}\r\nstatic int access_with_param(struct goldfish_pipe_dev *dev, const int cmd,\r\nunsigned long address, unsigned long avail,\r\nstruct goldfish_pipe *pipe, int *status)\r\n{\r\nstruct access_params *aps = dev->aps;\r\nif (aps == NULL)\r\nreturn -1;\r\naps->result = INITIAL_BATCH_RESULT;\r\naps->channel = (unsigned long)pipe;\r\naps->size = avail;\r\naps->address = address;\r\naps->cmd = cmd;\r\nwritel(cmd, dev->base + PIPE_REG_ACCESS_PARAMS);\r\nif (aps->result == INITIAL_BATCH_RESULT)\r\nreturn -1;\r\n*status = aps->result;\r\nreturn 0;\r\n}\r\nstatic ssize_t goldfish_pipe_read_write(struct file *filp, char __user *buffer,\r\nsize_t bufflen, int is_write)\r\n{\r\nunsigned long irq_flags;\r\nstruct goldfish_pipe *pipe = filp->private_data;\r\nstruct goldfish_pipe_dev *dev = pipe->dev;\r\nconst int cmd_offset = is_write ? 0\r\n: (CMD_READ_BUFFER - CMD_WRITE_BUFFER);\r\nunsigned long address, address_end;\r\nint ret = 0;\r\nif (test_bit(BIT_CLOSED_ON_HOST, &pipe->flags))\r\nreturn -EIO;\r\nif (unlikely(bufflen) == 0)\r\nreturn 0;\r\nif (!access_ok(is_write ? VERIFY_WRITE : VERIFY_READ,\r\nbuffer, bufflen))\r\nreturn -EFAULT;\r\nif (mutex_lock_interruptible(&pipe->lock))\r\nreturn -ERESTARTSYS;\r\naddress = (unsigned long)(void *)buffer;\r\naddress_end = address + bufflen;\r\nwhile (address < address_end) {\r\nunsigned long page_end = (address & PAGE_MASK) + PAGE_SIZE;\r\nunsigned long next = page_end < address_end ? page_end\r\n: address_end;\r\nunsigned long avail = next - address;\r\nint status, wakeBit;\r\nif (is_write) {\r\nchar c;\r\nif (__get_user(c, (char __user *)address)) {\r\nif (!ret)\r\nret = -EFAULT;\r\nbreak;\r\n}\r\n} else {\r\nif (__put_user(0, (char __user *)address)) {\r\nif (!ret)\r\nret = -EFAULT;\r\nbreak;\r\n}\r\n}\r\nspin_lock_irqsave(&dev->lock, irq_flags);\r\nif (access_with_param(dev, CMD_WRITE_BUFFER + cmd_offset,\r\naddress, avail, pipe, &status)) {\r\ngf_write64((u64)(unsigned long)pipe,\r\ndev->base + PIPE_REG_CHANNEL,\r\ndev->base + PIPE_REG_CHANNEL_HIGH);\r\nwritel(avail, dev->base + PIPE_REG_SIZE);\r\ngf_write64(address, dev->base + PIPE_REG_ADDRESS,\r\ndev->base + PIPE_REG_ADDRESS_HIGH);\r\nwritel(CMD_WRITE_BUFFER + cmd_offset,\r\ndev->base + PIPE_REG_COMMAND);\r\nstatus = readl(dev->base + PIPE_REG_STATUS);\r\n}\r\nspin_unlock_irqrestore(&dev->lock, irq_flags);\r\nif (status > 0) {\r\nret += status;\r\naddress += status;\r\ncontinue;\r\n}\r\nif (status == 0)\r\nbreak;\r\nif (ret > 0)\r\nbreak;\r\nif (status != PIPE_ERROR_AGAIN ||\r\n(filp->f_flags & O_NONBLOCK) != 0) {\r\nret = goldfish_pipe_error_convert(status);\r\nbreak;\r\n}\r\nwakeBit = is_write ? BIT_WAKE_ON_WRITE : BIT_WAKE_ON_READ;\r\nset_bit(wakeBit, &pipe->flags);\r\ngoldfish_cmd(pipe, CMD_WAKE_ON_WRITE + cmd_offset);\r\nmutex_unlock(&pipe->lock);\r\nwhile (test_bit(wakeBit, &pipe->flags)) {\r\nif (wait_event_interruptible(\r\npipe->wake_queue,\r\n!test_bit(wakeBit, &pipe->flags)))\r\nreturn -ERESTARTSYS;\r\nif (test_bit(BIT_CLOSED_ON_HOST, &pipe->flags))\r\nreturn -EIO;\r\n}\r\nif (mutex_lock_interruptible(&pipe->lock))\r\nreturn -ERESTARTSYS;\r\ncontinue;\r\n}\r\nmutex_unlock(&pipe->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t goldfish_pipe_read(struct file *filp, char __user *buffer,\r\nsize_t bufflen, loff_t *ppos)\r\n{\r\nreturn goldfish_pipe_read_write(filp, buffer, bufflen, 0);\r\n}\r\nstatic ssize_t goldfish_pipe_write(struct file *filp,\r\nconst char __user *buffer, size_t bufflen,\r\nloff_t *ppos)\r\n{\r\nreturn goldfish_pipe_read_write(filp, (char __user *)buffer,\r\nbufflen, 1);\r\n}\r\nstatic unsigned int goldfish_pipe_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct goldfish_pipe *pipe = filp->private_data;\r\nunsigned int mask = 0;\r\nint status;\r\nmutex_lock(&pipe->lock);\r\npoll_wait(filp, &pipe->wake_queue, wait);\r\nstatus = goldfish_cmd_status(pipe, CMD_POLL);\r\nmutex_unlock(&pipe->lock);\r\nif (status & PIPE_POLL_IN)\r\nmask |= POLLIN | POLLRDNORM;\r\nif (status & PIPE_POLL_OUT)\r\nmask |= POLLOUT | POLLWRNORM;\r\nif (status & PIPE_POLL_HUP)\r\nmask |= POLLHUP;\r\nif (test_bit(BIT_CLOSED_ON_HOST, &pipe->flags))\r\nmask |= POLLERR;\r\nreturn mask;\r\n}\r\nstatic irqreturn_t goldfish_pipe_interrupt(int irq, void *dev_id)\r\n{\r\nstruct goldfish_pipe_dev *dev = dev_id;\r\nunsigned long irq_flags;\r\nint count = 0;\r\nspin_lock_irqsave(&dev->lock, irq_flags);\r\nfor (;;) {\r\nstruct goldfish_pipe *pipe;\r\nunsigned long wakes;\r\nunsigned long channel = 0;\r\n#ifdef CONFIG_64BIT\r\nchannel = (u64)readl(dev->base + PIPE_REG_CHANNEL_HIGH) << 32;\r\nif (channel == 0)\r\nbreak;\r\n#endif\r\nchannel |= readl(dev->base + PIPE_REG_CHANNEL);\r\nif (channel == 0)\r\nbreak;\r\nwakes = readl(dev->base + PIPE_REG_WAKES);\r\npipe = (struct goldfish_pipe *)(ptrdiff_t)channel;\r\nif (wakes & PIPE_WAKE_CLOSED) {\r\nset_bit(BIT_CLOSED_ON_HOST, &pipe->flags);\r\nwakes |= PIPE_WAKE_READ | PIPE_WAKE_WRITE;\r\n}\r\nif (wakes & PIPE_WAKE_READ)\r\nclear_bit(BIT_WAKE_ON_READ, &pipe->flags);\r\nif (wakes & PIPE_WAKE_WRITE)\r\nclear_bit(BIT_WAKE_ON_WRITE, &pipe->flags);\r\nwake_up_interruptible(&pipe->wake_queue);\r\ncount++;\r\n}\r\nspin_unlock_irqrestore(&dev->lock, irq_flags);\r\nreturn (count == 0) ? IRQ_NONE : IRQ_HANDLED;\r\n}\r\nstatic int goldfish_pipe_open(struct inode *inode, struct file *file)\r\n{\r\nstruct goldfish_pipe *pipe;\r\nstruct goldfish_pipe_dev *dev = pipe_dev;\r\nint32_t status;\r\npipe = kzalloc(sizeof(*pipe), GFP_KERNEL);\r\nif (pipe == NULL)\r\nreturn -ENOMEM;\r\npipe->dev = dev;\r\nmutex_init(&pipe->lock);\r\ninit_waitqueue_head(&pipe->wake_queue);\r\nstatus = goldfish_cmd_status(pipe, CMD_OPEN);\r\nif (status < 0) {\r\nkfree(pipe);\r\nreturn status;\r\n}\r\nfile->private_data = pipe;\r\nreturn 0;\r\n}\r\nstatic int goldfish_pipe_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct goldfish_pipe *pipe = filp->private_data;\r\ngoldfish_cmd(pipe, CMD_CLOSE);\r\nkfree(pipe);\r\nfilp->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int goldfish_pipe_probe(struct platform_device *pdev)\r\n{\r\nint err;\r\nstruct resource *r;\r\nstruct goldfish_pipe_dev *dev = pipe_dev;\r\nWARN_ON(dev->base != NULL);\r\nspin_lock_init(&dev->lock);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (r == NULL || resource_size(r) < PAGE_SIZE) {\r\ndev_err(&pdev->dev, "can't allocate i/o page\n");\r\nreturn -EINVAL;\r\n}\r\ndev->base = devm_ioremap(&pdev->dev, r->start, PAGE_SIZE);\r\nif (dev->base == NULL) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nreturn -EINVAL;\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (r == NULL) {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\ndev->irq = r->start;\r\nerr = devm_request_irq(&pdev->dev, dev->irq, goldfish_pipe_interrupt,\r\nIRQF_SHARED, "goldfish_pipe", dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "unable to allocate IRQ\n");\r\ngoto error;\r\n}\r\nerr = misc_register(&goldfish_pipe_device);\r\nif (err) {\r\ndev_err(&pdev->dev, "unable to register device\n");\r\ngoto error;\r\n}\r\nsetup_access_params_addr(pdev, dev);\r\nreturn 0;\r\nerror:\r\ndev->base = NULL;\r\nreturn err;\r\n}\r\nstatic int goldfish_pipe_remove(struct platform_device *pdev)\r\n{\r\nstruct goldfish_pipe_dev *dev = pipe_dev;\r\nmisc_deregister(&goldfish_pipe_device);\r\ndev->base = NULL;\r\nreturn 0;\r\n}
