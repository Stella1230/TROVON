static int m88rs2000_writereg(struct m88rs2000_state *state,\r\nu8 reg, u8 data)\r\n{\r\nint ret;\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = {\r\n.addr = state->config->demod_addr,\r\n.flags = 0,\r\n.buf = buf,\r\n.len = 2\r\n};\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1)\r\ndeb_info("%s: writereg error (reg == 0x%02x, val == 0x%02x, "\r\n"ret == %i)\n", __func__, reg, data, ret);\r\nreturn (ret != 1) ? -EREMOTEIO : 0;\r\n}\r\nstatic u8 m88rs2000_readreg(struct m88rs2000_state *state, u8 reg)\r\n{\r\nint ret;\r\nu8 b0[] = { reg };\r\nu8 b1[] = { 0 };\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = state->config->demod_addr,\r\n.flags = 0,\r\n.buf = b0,\r\n.len = 1\r\n}, {\r\n.addr = state->config->demod_addr,\r\n.flags = I2C_M_RD,\r\n.buf = b1,\r\n.len = 1\r\n}\r\n};\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2)\r\ndeb_info("%s: readreg error (reg == 0x%02x, ret == %i)\n",\r\n__func__, reg, ret);\r\nreturn b1[0];\r\n}\r\nstatic u32 m88rs2000_get_mclk(struct dvb_frontend *fe)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nu32 mclk;\r\nu8 reg;\r\nreg = m88rs2000_readreg(state, 0x86);\r\nif (!reg || reg == 0xff)\r\nreturn 0;\r\nreg /= 2;\r\nreg += 1;\r\nmclk = (u32)(reg * RS2000_FE_CRYSTAL_KHZ + 28 / 2) / 28;\r\nreturn mclk;\r\n}\r\nstatic int m88rs2000_set_carrieroffset(struct dvb_frontend *fe, s16 offset)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nu32 mclk;\r\ns32 tmp;\r\nu8 reg;\r\nint ret;\r\nmclk = m88rs2000_get_mclk(fe);\r\nif (!mclk)\r\nreturn -EINVAL;\r\ntmp = (offset * 4096 + (s32)mclk / 2) / (s32)mclk;\r\nif (tmp < 0)\r\ntmp += 4096;\r\nret = m88rs2000_writereg(state, 0x9c, (u8)(tmp >> 4));\r\nreg = m88rs2000_readreg(state, 0x9d);\r\nreg &= 0xf;\r\nreg |= (u8)(tmp & 0xf) << 4;\r\nret |= m88rs2000_writereg(state, 0x9d, reg);\r\nreturn ret;\r\n}\r\nstatic int m88rs2000_set_symbolrate(struct dvb_frontend *fe, u32 srate)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nint ret;\r\nu64 temp;\r\nu32 mclk;\r\nu8 b[3];\r\nif ((srate < 1000000) || (srate > 45000000))\r\nreturn -EINVAL;\r\nmclk = m88rs2000_get_mclk(fe);\r\nif (!mclk)\r\nreturn -EINVAL;\r\ntemp = srate / 1000;\r\ntemp *= 1 << 24;\r\ndo_div(temp, mclk);\r\nb[0] = (u8) (temp >> 16) & 0xff;\r\nb[1] = (u8) (temp >> 8) & 0xff;\r\nb[2] = (u8) temp & 0xff;\r\nret = m88rs2000_writereg(state, 0x93, b[2]);\r\nret |= m88rs2000_writereg(state, 0x94, b[1]);\r\nret |= m88rs2000_writereg(state, 0x95, b[0]);\r\nif (srate > 10000000)\r\nret |= m88rs2000_writereg(state, 0xa0, 0x20);\r\nelse\r\nret |= m88rs2000_writereg(state, 0xa0, 0x60);\r\nret |= m88rs2000_writereg(state, 0xa1, 0xe0);\r\nif (srate > 12000000)\r\nret |= m88rs2000_writereg(state, 0xa3, 0x20);\r\nelse if (srate > 2800000)\r\nret |= m88rs2000_writereg(state, 0xa3, 0x98);\r\nelse\r\nret |= m88rs2000_writereg(state, 0xa3, 0x90);\r\ndeb_info("m88rs2000: m88rs2000_set_symbolrate\n");\r\nreturn ret;\r\n}\r\nstatic int m88rs2000_send_diseqc_msg(struct dvb_frontend *fe,\r\nstruct dvb_diseqc_master_cmd *m)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nint i;\r\nu8 reg;\r\ndeb_info("%s\n", __func__);\r\nm88rs2000_writereg(state, 0x9a, 0x30);\r\nreg = m88rs2000_readreg(state, 0xb2);\r\nreg &= 0x3f;\r\nm88rs2000_writereg(state, 0xb2, reg);\r\nfor (i = 0; i < m->msg_len; i++)\r\nm88rs2000_writereg(state, 0xb3 + i, m->msg[i]);\r\nreg = m88rs2000_readreg(state, 0xb1);\r\nreg &= 0x87;\r\nreg |= ((m->msg_len - 1) << 3) | 0x07;\r\nreg &= 0x7f;\r\nm88rs2000_writereg(state, 0xb1, reg);\r\nfor (i = 0; i < 15; i++) {\r\nif ((m88rs2000_readreg(state, 0xb1) & 0x40) == 0x0)\r\nbreak;\r\nmsleep(20);\r\n}\r\nreg = m88rs2000_readreg(state, 0xb1);\r\nif ((reg & 0x40) > 0x0) {\r\nreg &= 0x7f;\r\nreg |= 0x40;\r\nm88rs2000_writereg(state, 0xb1, reg);\r\n}\r\nreg = m88rs2000_readreg(state, 0xb2);\r\nreg &= 0x3f;\r\nreg |= 0x80;\r\nm88rs2000_writereg(state, 0xb2, reg);\r\nm88rs2000_writereg(state, 0x9a, 0xb0);\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_send_diseqc_burst(struct dvb_frontend *fe,\r\nfe_sec_mini_cmd_t burst)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nu8 reg0, reg1;\r\ndeb_info("%s\n", __func__);\r\nm88rs2000_writereg(state, 0x9a, 0x30);\r\nmsleep(50);\r\nreg0 = m88rs2000_readreg(state, 0xb1);\r\nreg1 = m88rs2000_readreg(state, 0xb2);\r\nm88rs2000_writereg(state, 0xb2, reg1);\r\nm88rs2000_writereg(state, 0xb1, reg0);\r\nm88rs2000_writereg(state, 0x9a, 0xb0);\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t tone)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nu8 reg0, reg1;\r\nm88rs2000_writereg(state, 0x9a, 0x30);\r\nreg0 = m88rs2000_readreg(state, 0xb1);\r\nreg1 = m88rs2000_readreg(state, 0xb2);\r\nreg1 &= 0x3f;\r\nswitch (tone) {\r\ncase SEC_TONE_ON:\r\nreg0 |= 0x4;\r\nreg0 &= 0xbc;\r\nbreak;\r\ncase SEC_TONE_OFF:\r\nreg1 |= 0x80;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nm88rs2000_writereg(state, 0xb2, reg1);\r\nm88rs2000_writereg(state, 0xb1, reg0);\r\nm88rs2000_writereg(state, 0x9a, 0xb0);\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_tab_set(struct m88rs2000_state *state,\r\nstruct inittab *tab)\r\n{\r\nint ret = 0;\r\nu8 i;\r\nif (tab == NULL)\r\nreturn -EINVAL;\r\nfor (i = 0; i < 255; i++) {\r\nswitch (tab[i].cmd) {\r\ncase 0x01:\r\nret = m88rs2000_writereg(state, tab[i].reg,\r\ntab[i].val);\r\nbreak;\r\ncase 0x10:\r\nif (tab[i].reg > 0)\r\nmdelay(tab[i].reg);\r\nbreak;\r\ncase 0xff:\r\nif (tab[i].reg == 0xaa && tab[i].val == 0xff)\r\nreturn 0;\r\ncase 0x00:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (ret < 0)\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t volt)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nu8 data;\r\ndata = m88rs2000_readreg(state, 0xb2);\r\ndata |= 0x03;\r\nswitch (volt) {\r\ncase SEC_VOLTAGE_18:\r\ndata &= ~0x03;\r\nbreak;\r\ncase SEC_VOLTAGE_13:\r\ndata &= ~0x03;\r\ndata |= 0x01;\r\nbreak;\r\ncase SEC_VOLTAGE_OFF:\r\nbreak;\r\n}\r\nm88rs2000_writereg(state, 0xb2, data);\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_init(struct dvb_frontend *fe)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nint ret;\r\ndeb_info("m88rs2000: init chip\n");\r\nif (state->config->inittab)\r\nret = m88rs2000_tab_set(state,\r\n(struct inittab *)state->config->inittab);\r\nelse\r\nret = m88rs2000_tab_set(state, m88rs2000_setup);\r\nreturn ret;\r\n}\r\nstatic int m88rs2000_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nint ret;\r\nret = m88rs2000_tab_set(state, m88rs2000_shutdown);\r\nreturn ret;\r\n}\r\nstatic int m88rs2000_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nu8 reg = m88rs2000_readreg(state, 0x8c);\r\n*status = 0;\r\nif ((reg & 0xee) == 0xee) {\r\n*status = FE_HAS_CARRIER | FE_HAS_SIGNAL | FE_HAS_VITERBI\r\n| FE_HAS_SYNC | FE_HAS_LOCK;\r\nif (state->config->set_ts_params)\r\nstate->config->set_ts_params(fe, CALL_IS_READ);\r\n}\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nu8 tmp0, tmp1;\r\nm88rs2000_writereg(state, 0x9a, 0x30);\r\ntmp0 = m88rs2000_readreg(state, 0xd8);\r\nif ((tmp0 & 0x10) != 0) {\r\nm88rs2000_writereg(state, 0x9a, 0xb0);\r\n*ber = 0xffffffff;\r\nreturn 0;\r\n}\r\n*ber = (m88rs2000_readreg(state, 0xd7) << 8) |\r\nm88rs2000_readreg(state, 0xd6);\r\ntmp1 = m88rs2000_readreg(state, 0xd9);\r\nm88rs2000_writereg(state, 0xd9, (tmp1 & ~7) | 4);\r\nm88rs2000_writereg(state, 0xd8, (tmp0 & ~8) | 0x30);\r\nm88rs2000_writereg(state, 0xd8, (tmp0 & ~8) | 0x30);\r\nm88rs2000_writereg(state, 0x9a, 0xb0);\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *strength)\r\n{\r\nif (fe->ops.tuner_ops.get_rf_strength)\r\nfe->ops.tuner_ops.get_rf_strength(fe, strength);\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\n*snr = 512 * m88rs2000_readreg(state, 0x65);\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nu8 tmp;\r\n*ucblocks = (m88rs2000_readreg(state, 0xd5) << 8) |\r\nm88rs2000_readreg(state, 0xd4);\r\ntmp = m88rs2000_readreg(state, 0xd8);\r\nm88rs2000_writereg(state, 0xd8, tmp & ~0x20);\r\nm88rs2000_writereg(state, 0xd8, tmp | 0x20);\r\nm88rs2000_writereg(state, 0xd8, tmp | 0x20);\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_set_fec(struct m88rs2000_state *state,\r\nfe_code_rate_t fec)\r\n{\r\nu8 fec_set, reg;\r\nint ret;\r\nswitch (fec) {\r\ncase FEC_1_2:\r\nfec_set = 0x8;\r\nbreak;\r\ncase FEC_2_3:\r\nfec_set = 0x10;\r\nbreak;\r\ncase FEC_3_4:\r\nfec_set = 0x20;\r\nbreak;\r\ncase FEC_5_6:\r\nfec_set = 0x40;\r\nbreak;\r\ncase FEC_7_8:\r\nfec_set = 0x80;\r\nbreak;\r\ncase FEC_AUTO:\r\ndefault:\r\nfec_set = 0x0;\r\n}\r\nreg = m88rs2000_readreg(state, 0x70);\r\nreg &= 0x7;\r\nret = m88rs2000_writereg(state, 0x70, reg | fec_set);\r\nret |= m88rs2000_writereg(state, 0x76, 0x8);\r\nreturn ret;\r\n}\r\nstatic fe_code_rate_t m88rs2000_get_fec(struct m88rs2000_state *state)\r\n{\r\nu8 reg;\r\nm88rs2000_writereg(state, 0x9a, 0x30);\r\nreg = m88rs2000_readreg(state, 0x76);\r\nm88rs2000_writereg(state, 0x9a, 0xb0);\r\nreg &= 0xf0;\r\nreg >>= 5;\r\nswitch (reg) {\r\ncase 0x4:\r\nreturn FEC_1_2;\r\ncase 0x3:\r\nreturn FEC_2_3;\r\ncase 0x2:\r\nreturn FEC_3_4;\r\ncase 0x1:\r\nreturn FEC_5_6;\r\ncase 0x0:\r\nreturn FEC_7_8;\r\ndefault:\r\nbreak;\r\n}\r\nreturn FEC_AUTO;\r\n}\r\nstatic int m88rs2000_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nfe_status_t status;\r\nint i, ret = 0;\r\nu32 tuner_freq;\r\ns16 offset = 0;\r\nu8 reg;\r\nstate->no_lock_count = 0;\r\nif (c->delivery_system != SYS_DVBS) {\r\ndeb_info("%s: unsupported delivery "\r\n"system selected (%d)\n",\r\n__func__, c->delivery_system);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (fe->ops.tuner_ops.set_params)\r\nret = fe->ops.tuner_ops.set_params(fe);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nif (fe->ops.tuner_ops.get_frequency)\r\nret = fe->ops.tuner_ops.get_frequency(fe, &tuner_freq);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\noffset = (s16)((s32)tuner_freq - c->frequency);\r\nif (((c->frequency % 192857) >= (192857 - 3000)) ||\r\n(c->frequency % 192857) <= 3000)\r\nret = m88rs2000_writereg(state, 0x86, 0xc2);\r\nelse\r\nret = m88rs2000_writereg(state, 0x86, 0xc6);\r\nret |= m88rs2000_set_carrieroffset(fe, offset);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nif (c->symbol_rate > 27500000)\r\nret = m88rs2000_writereg(state, 0xf1, 0xa4);\r\nelse\r\nret = m88rs2000_writereg(state, 0xf1, 0xbf);\r\nret |= m88rs2000_tab_set(state, fe_reset);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nret = m88rs2000_set_fec(state, c->fec_inner);\r\nret |= m88rs2000_writereg(state, 0x85, 0x1);\r\nret |= m88rs2000_writereg(state, 0x8a, 0xbf);\r\nret |= m88rs2000_writereg(state, 0x8d, 0x1e);\r\nret |= m88rs2000_writereg(state, 0x90, 0xf1);\r\nret |= m88rs2000_writereg(state, 0x91, 0x08);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nret = m88rs2000_set_symbolrate(fe, c->symbol_rate);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nret = m88rs2000_tab_set(state, fe_trigger);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nfor (i = 0; i < 25; i++) {\r\nreg = m88rs2000_readreg(state, 0x8c);\r\nif ((reg & 0xee) == 0xee) {\r\nstatus = FE_HAS_LOCK;\r\nbreak;\r\n}\r\nstate->no_lock_count++;\r\nif (state->no_lock_count == 15) {\r\nreg = m88rs2000_readreg(state, 0x70);\r\nreg ^= 0x4;\r\nm88rs2000_writereg(state, 0x70, reg);\r\nstate->no_lock_count = 0;\r\n}\r\nmsleep(20);\r\n}\r\nif (status & FE_HAS_LOCK) {\r\nstate->fec_inner = m88rs2000_get_fec(state);\r\nreg = m88rs2000_readreg(state, 0x65);\r\n}\r\nstate->tuner_frequency = c->frequency;\r\nstate->symbol_rate = c->symbol_rate;\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nc->fec_inner = state->fec_inner;\r\nc->frequency = state->tuner_frequency;\r\nc->symbol_rate = state->symbol_rate;\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *tune)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nif (c->symbol_rate > 3000000)\r\ntune->min_delay_ms = 2000;\r\nelse\r\ntune->min_delay_ms = 3000;\r\ntune->step_size = c->symbol_rate / 16000;\r\ntune->max_drift = c->symbol_rate / 2000;\r\nreturn 0;\r\n}\r\nstatic int m88rs2000_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nif (enable)\r\nm88rs2000_writereg(state, 0x81, 0x84);\r\nelse\r\nm88rs2000_writereg(state, 0x81, 0x81);\r\nudelay(10);\r\nreturn 0;\r\n}\r\nstatic void m88rs2000_release(struct dvb_frontend *fe)\r\n{\r\nstruct m88rs2000_state *state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *m88rs2000_attach(const struct m88rs2000_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct m88rs2000_state *state = NULL;\r\nstate = kzalloc(sizeof(struct m88rs2000_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->tuner_frequency = 0;\r\nstate->symbol_rate = 0;\r\nstate->fec_inner = 0;\r\nmemcpy(&state->frontend.ops, &m88rs2000_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
