int InterfaceIdleModeRespond(struct bcm_mini_adapter *Adapter,\r\nunsigned int *puiBuffer)\r\n{\r\nint status = STATUS_SUCCESS;\r\nunsigned int uiRegRead = 0;\r\nint bytes;\r\nif (ntohl(*puiBuffer) == GO_TO_IDLE_MODE_PAYLOAD) {\r\nif (ntohl(*(puiBuffer+1)) == 0) {\r\nstatus = wrmalt(Adapter, SW_ABORT_IDLEMODE_LOC,\r\n&uiRegRead, sizeof(uiRegRead));\r\nif (status)\r\nreturn status;\r\nif (Adapter->ulPowerSaveMode ==\r\nDEVICE_POWERSAVE_MODE_AS_MANUAL_CLOCK_GATING) {\r\nuiRegRead = 0x00000000;\r\nstatus = wrmalt(Adapter,\r\nDEBUG_INTERRUPT_GENERATOR_REGISTOR,\r\n&uiRegRead, sizeof(uiRegRead));\r\nif (status)\r\nreturn status;\r\n}\r\nelse if (Adapter->ulPowerSaveMode !=\r\nDEVICE_POWERSAVE_MODE_AS_PROTOCOL_IDLE_MODE) {\r\nbytes = rdmalt(Adapter, DEVICE_INT_OUT_EP_REG0,\r\n&uiRegRead, sizeof(uiRegRead));\r\nif (bytes < 0) {\r\nstatus = bytes;\r\nreturn status;\r\n}\r\nbytes = rdmalt(Adapter, DEVICE_INT_OUT_EP_REG1,\r\n&uiRegRead, sizeof(uiRegRead));\r\nif (bytes < 0) {\r\nstatus = bytes;\r\nreturn status;\r\n}\r\n}\r\nAdapter->IdleMode = false;\r\nAdapter->bTriedToWakeUpFromlowPowerMode = false;\r\nwake_up(&Adapter->lowpower_mode_wait_queue);\r\n} else {\r\nif (TRUE == Adapter->IdleMode)\r\nreturn status;\r\nuiRegRead = 0;\r\nif (Adapter->chip_id == BCS220_2 ||\r\nAdapter->chip_id == BCS220_2BC ||\r\nAdapter->chip_id == BCS250_BC ||\r\nAdapter->chip_id == BCS220_3) {\r\nbytes = rdmalt(Adapter, HPM_CONFIG_MSW,\r\n&uiRegRead, sizeof(uiRegRead));\r\nif (bytes < 0) {\r\nstatus = bytes;\r\nreturn status;\r\n}\r\nuiRegRead |= (1<<17);\r\nstatus = wrmalt(Adapter, HPM_CONFIG_MSW,\r\n&uiRegRead, sizeof(uiRegRead));\r\nif (status)\r\nreturn status;\r\n}\r\nSendIdleModeResponse(Adapter);\r\n}\r\n} else if (ntohl(*puiBuffer) == IDLE_MODE_SF_UPDATE_MSG) {\r\nOverrideServiceFlowParams(Adapter, puiBuffer);\r\n}\r\nreturn status;\r\n}\r\nstatic int InterfaceAbortIdlemode(struct bcm_mini_adapter *Adapter,\r\nunsigned int Pattern)\r\n{\r\nint status = STATUS_SUCCESS;\r\nunsigned int value;\r\nunsigned int chip_id;\r\nunsigned long timeout = 0, itr = 0;\r\nint lenwritten = 0;\r\nunsigned char aucAbortPattern[8] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\r\n0xFF, 0xFF, 0xFF};\r\nstruct bcm_interface_adapter *psInterfaceAdapter =\r\nAdapter->pvInterfaceAdapter;\r\nif ((TRUE == psInterfaceAdapter->bSuspended) &&\r\n(TRUE == Adapter->bDoSuspend))\r\nstatus = usb_autopm_get_interface(\r\npsInterfaceAdapter->interface);\r\nif ((Adapter->ulPowerSaveMode ==\r\nDEVICE_POWERSAVE_MODE_AS_MANUAL_CLOCK_GATING) ||\r\n(Adapter->ulPowerSaveMode ==\r\nDEVICE_POWERSAVE_MODE_AS_PROTOCOL_IDLE_MODE)) {\r\nstatus = wrmalt(Adapter, SW_ABORT_IDLEMODE_LOC,\r\n&Pattern, sizeof(Pattern));\r\nif (status)\r\nreturn status;\r\n}\r\nif (Adapter->ulPowerSaveMode ==\r\nDEVICE_POWERSAVE_MODE_AS_MANUAL_CLOCK_GATING) {\r\nvalue = 0x80000000;\r\nstatus = wrmalt(Adapter,\r\nDEBUG_INTERRUPT_GENERATOR_REGISTOR,\r\n&value, sizeof(value));\r\nif (status)\r\nreturn status;\r\n} else if (Adapter->ulPowerSaveMode !=\r\nDEVICE_POWERSAVE_MODE_AS_PROTOCOL_IDLE_MODE) {\r\nstatus = usb_interrupt_msg(psInterfaceAdapter->udev,\r\nusb_sndintpipe(psInterfaceAdapter->udev,\r\npsInterfaceAdapter->sIntrOut.int_out_endpointAddr),\r\naucAbortPattern,\r\n8,\r\n&lenwritten,\r\n5000);\r\nif (status)\r\nreturn status;\r\nelse\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS,\r\nIDLE_MODE, DBG_LVL_ALL,\r\n"NOB Sent down :%d", lenwritten);\r\ntimeout = jiffies + msecs_to_jiffies(50);\r\nwhile (time_after(timeout, jiffies)) {\r\nitr++;\r\nrdmalt(Adapter, CHIP_ID_REG, &chip_id, sizeof(UINT));\r\nif (0xbece3200 == (chip_id&~(0xF0)))\r\nchip_id = chip_id&~(0xF0);\r\nif (chip_id == Adapter->chip_id)\r\nbreak;\r\n}\r\nif (time_before(timeout, jiffies))\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS,\r\nIDLE_MODE, DBG_LVL_ALL,\r\n"Not able to read chip-id even after 25 msec");\r\nelse\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS,\r\nIDLE_MODE, DBG_LVL_ALL,\r\n"Number of completed iteration to"\r\n"read chip-id :%lu", itr);\r\nstatus = wrmalt(Adapter, SW_ABORT_IDLEMODE_LOC,\r\n&Pattern, sizeof(status));\r\nif (status)\r\nreturn status;\r\n}\r\nreturn status;\r\n}\r\nint InterfaceIdleModeWakeup(struct bcm_mini_adapter *Adapter)\r\n{\r\nif (Adapter->bTriedToWakeUpFromlowPowerMode) {\r\nBCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS,\r\nIDLE_MODE, DBG_LVL_ALL,\r\n"Wake up already attempted.. ignoring\n");\r\n} else {\r\nAdapter->bTriedToWakeUpFromlowPowerMode = TRUE;\r\nInterfaceAbortIdlemode(Adapter, Adapter->usIdleModePattern);\r\n}\r\nreturn 0;\r\n}\r\nvoid InterfaceHandleShutdownModeWakeup(struct bcm_mini_adapter *Adapter)\r\n{\r\nunsigned int uiRegVal = 0;\r\nINT Status = 0;\r\nint bytes;\r\nif (Adapter->ulPowerSaveMode ==\r\nDEVICE_POWERSAVE_MODE_AS_MANUAL_CLOCK_GATING) {\r\nuiRegVal = 0;\r\nStatus = wrmalt(Adapter,\r\nDEBUG_INTERRUPT_GENERATOR_REGISTOR,\r\n&uiRegVal, sizeof(uiRegVal));\r\nif (Status)\r\nreturn;\r\n}\r\nelse {\r\nbytes = rdmalt(Adapter,\r\nDEVICE_INT_OUT_EP_REG0,\r\n&uiRegVal, sizeof(uiRegVal));\r\nif (bytes < 0) {\r\nStatus = bytes;\r\nreturn;\r\n}\r\nbytes = rdmalt(Adapter,\r\nDEVICE_INT_OUT_EP_REG1,\r\n&uiRegVal, sizeof(uiRegVal));\r\nif (bytes < 0) {\r\nStatus = bytes;\r\nreturn;\r\n}\r\n}\r\n}
