static void ocfs2_dump_meta_lvb_info(u64 level,\r\nconst char *function,\r\nunsigned int line,\r\nstruct ocfs2_lock_res *lockres)\r\n{\r\nstruct ocfs2_meta_lvb *lvb = ocfs2_dlm_lvb(&lockres->l_lksb);\r\nmlog(level, "LVB information for %s (called from %s:%u):\n",\r\nlockres->l_name, function, line);\r\nmlog(level, "version: %u, clusters: %u, generation: 0x%x\n",\r\nlvb->lvb_version, be32_to_cpu(lvb->lvb_iclusters),\r\nbe32_to_cpu(lvb->lvb_igeneration));\r\nmlog(level, "size: %llu, uid %u, gid %u, mode 0x%x\n",\r\n(unsigned long long)be64_to_cpu(lvb->lvb_isize),\r\nbe32_to_cpu(lvb->lvb_iuid), be32_to_cpu(lvb->lvb_igid),\r\nbe16_to_cpu(lvb->lvb_imode));\r\nmlog(level, "nlink %u, atime_packed 0x%llx, ctime_packed 0x%llx, "\r\n"mtime_packed 0x%llx iattr 0x%x\n", be16_to_cpu(lvb->lvb_inlink),\r\n(long long)be64_to_cpu(lvb->lvb_iatime_packed),\r\n(long long)be64_to_cpu(lvb->lvb_ictime_packed),\r\n(long long)be64_to_cpu(lvb->lvb_imtime_packed),\r\nbe32_to_cpu(lvb->lvb_iattr));\r\n}\r\nstatic inline int ocfs2_is_inode_lock(struct ocfs2_lock_res *lockres)\r\n{\r\nreturn lockres->l_type == OCFS2_LOCK_TYPE_META ||\r\nlockres->l_type == OCFS2_LOCK_TYPE_RW ||\r\nlockres->l_type == OCFS2_LOCK_TYPE_OPEN;\r\n}\r\nstatic inline struct ocfs2_lock_res *ocfs2_lksb_to_lock_res(struct ocfs2_dlm_lksb *lksb)\r\n{\r\nreturn container_of(lksb, struct ocfs2_lock_res, l_lksb);\r\n}\r\nstatic inline struct inode *ocfs2_lock_res_inode(struct ocfs2_lock_res *lockres)\r\n{\r\nBUG_ON(!ocfs2_is_inode_lock(lockres));\r\nreturn (struct inode *) lockres->l_priv;\r\n}\r\nstatic inline struct ocfs2_dentry_lock *ocfs2_lock_res_dl(struct ocfs2_lock_res *lockres)\r\n{\r\nBUG_ON(lockres->l_type != OCFS2_LOCK_TYPE_DENTRY);\r\nreturn (struct ocfs2_dentry_lock *)lockres->l_priv;\r\n}\r\nstatic inline struct ocfs2_mem_dqinfo *ocfs2_lock_res_qinfo(struct ocfs2_lock_res *lockres)\r\n{\r\nBUG_ON(lockres->l_type != OCFS2_LOCK_TYPE_QINFO);\r\nreturn (struct ocfs2_mem_dqinfo *)lockres->l_priv;\r\n}\r\nstatic inline struct ocfs2_refcount_tree *\r\nocfs2_lock_res_refcount_tree(struct ocfs2_lock_res *res)\r\n{\r\nreturn container_of(res, struct ocfs2_refcount_tree, rf_lockres);\r\n}\r\nstatic inline struct ocfs2_super *ocfs2_get_lockres_osb(struct ocfs2_lock_res *lockres)\r\n{\r\nif (lockres->l_ops->get_osb)\r\nreturn lockres->l_ops->get_osb(lockres);\r\nreturn (struct ocfs2_super *)lockres->l_priv;\r\n}\r\nstatic inline void ocfs2_cluster_unlock(struct ocfs2_super *osb,\r\nstruct ocfs2_lock_res *lockres,\r\nint level)\r\n{\r\n__ocfs2_cluster_unlock(osb, lockres, level, _RET_IP_);\r\n}\r\nstatic void ocfs2_build_lock_name(enum ocfs2_lock_type type,\r\nu64 blkno,\r\nu32 generation,\r\nchar *name)\r\n{\r\nint len;\r\nBUG_ON(type >= OCFS2_NUM_LOCK_TYPES);\r\nlen = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, "%c%s%016llx%08x",\r\nocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD,\r\n(long long)blkno, generation);\r\nBUG_ON(len != (OCFS2_LOCK_ID_MAX_LEN - 1));\r\nmlog(0, "built lock resource with name: %s\n", name);\r\n}\r\nstatic void ocfs2_add_lockres_tracking(struct ocfs2_lock_res *res,\r\nstruct ocfs2_dlm_debug *dlm_debug)\r\n{\r\nmlog(0, "Add tracking for lockres %s\n", res->l_name);\r\nspin_lock(&ocfs2_dlm_tracking_lock);\r\nlist_add(&res->l_debug_list, &dlm_debug->d_lockres_tracking);\r\nspin_unlock(&ocfs2_dlm_tracking_lock);\r\n}\r\nstatic void ocfs2_remove_lockres_tracking(struct ocfs2_lock_res *res)\r\n{\r\nspin_lock(&ocfs2_dlm_tracking_lock);\r\nif (!list_empty(&res->l_debug_list))\r\nlist_del_init(&res->l_debug_list);\r\nspin_unlock(&ocfs2_dlm_tracking_lock);\r\n}\r\nstatic void ocfs2_init_lock_stats(struct ocfs2_lock_res *res)\r\n{\r\nres->l_lock_refresh = 0;\r\nmemset(&res->l_lock_prmode, 0, sizeof(struct ocfs2_lock_stats));\r\nmemset(&res->l_lock_exmode, 0, sizeof(struct ocfs2_lock_stats));\r\n}\r\nstatic void ocfs2_update_lock_stats(struct ocfs2_lock_res *res, int level,\r\nstruct ocfs2_mask_waiter *mw, int ret)\r\n{\r\nu32 usec;\r\nktime_t kt;\r\nstruct ocfs2_lock_stats *stats;\r\nif (level == LKM_PRMODE)\r\nstats = &res->l_lock_prmode;\r\nelse if (level == LKM_EXMODE)\r\nstats = &res->l_lock_exmode;\r\nelse\r\nreturn;\r\nkt = ktime_sub(ktime_get(), mw->mw_lock_start);\r\nusec = ktime_to_us(kt);\r\nstats->ls_gets++;\r\nstats->ls_total += ktime_to_ns(kt);\r\nif (unlikely(stats->ls_gets == 0)) {\r\nstats->ls_gets++;\r\nstats->ls_total = ktime_to_ns(kt);\r\n}\r\nif (stats->ls_max < usec)\r\nstats->ls_max = usec;\r\nif (ret)\r\nstats->ls_fail++;\r\n}\r\nstatic inline void ocfs2_track_lock_refresh(struct ocfs2_lock_res *lockres)\r\n{\r\nlockres->l_lock_refresh++;\r\n}\r\nstatic inline void ocfs2_init_start_time(struct ocfs2_mask_waiter *mw)\r\n{\r\nmw->mw_lock_start = ktime_get();\r\n}\r\nstatic inline void ocfs2_init_lock_stats(struct ocfs2_lock_res *res)\r\n{\r\n}\r\nstatic inline void ocfs2_update_lock_stats(struct ocfs2_lock_res *res,\r\nint level, struct ocfs2_mask_waiter *mw, int ret)\r\n{\r\n}\r\nstatic inline void ocfs2_track_lock_refresh(struct ocfs2_lock_res *lockres)\r\n{\r\n}\r\nstatic inline void ocfs2_init_start_time(struct ocfs2_mask_waiter *mw)\r\n{\r\n}\r\nstatic void ocfs2_lock_res_init_common(struct ocfs2_super *osb,\r\nstruct ocfs2_lock_res *res,\r\nenum ocfs2_lock_type type,\r\nstruct ocfs2_lock_res_ops *ops,\r\nvoid *priv)\r\n{\r\nres->l_type = type;\r\nres->l_ops = ops;\r\nres->l_priv = priv;\r\nres->l_level = DLM_LOCK_IV;\r\nres->l_requested = DLM_LOCK_IV;\r\nres->l_blocking = DLM_LOCK_IV;\r\nres->l_action = OCFS2_AST_INVALID;\r\nres->l_unlock_action = OCFS2_UNLOCK_INVALID;\r\nres->l_flags = OCFS2_LOCK_INITIALIZED;\r\nocfs2_add_lockres_tracking(res, osb->osb_dlm_debug);\r\nocfs2_init_lock_stats(res);\r\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\r\nif (type != OCFS2_LOCK_TYPE_OPEN)\r\nlockdep_init_map(&res->l_lockdep_map, ocfs2_lock_type_strings[type],\r\n&lockdep_keys[type], 0);\r\nelse\r\nres->l_lockdep_map.key = NULL;\r\n#endif\r\n}\r\nvoid ocfs2_lock_res_init_once(struct ocfs2_lock_res *res)\r\n{\r\nmemset(res, 0, sizeof(struct ocfs2_lock_res));\r\nspin_lock_init(&res->l_lock);\r\ninit_waitqueue_head(&res->l_event);\r\nINIT_LIST_HEAD(&res->l_blocked_list);\r\nINIT_LIST_HEAD(&res->l_mask_waiters);\r\n}\r\nvoid ocfs2_inode_lock_res_init(struct ocfs2_lock_res *res,\r\nenum ocfs2_lock_type type,\r\nunsigned int generation,\r\nstruct inode *inode)\r\n{\r\nstruct ocfs2_lock_res_ops *ops;\r\nswitch(type) {\r\ncase OCFS2_LOCK_TYPE_RW:\r\nops = &ocfs2_inode_rw_lops;\r\nbreak;\r\ncase OCFS2_LOCK_TYPE_META:\r\nops = &ocfs2_inode_inode_lops;\r\nbreak;\r\ncase OCFS2_LOCK_TYPE_OPEN:\r\nops = &ocfs2_inode_open_lops;\r\nbreak;\r\ndefault:\r\nmlog_bug_on_msg(1, "type: %d\n", type);\r\nops = NULL;\r\nbreak;\r\n};\r\nocfs2_build_lock_name(type, OCFS2_I(inode)->ip_blkno,\r\ngeneration, res->l_name);\r\nocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), res, type, ops, inode);\r\n}\r\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres)\r\n{\r\nstruct inode *inode = ocfs2_lock_res_inode(lockres);\r\nreturn OCFS2_SB(inode->i_sb);\r\n}\r\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres)\r\n{\r\nstruct ocfs2_mem_dqinfo *info = lockres->l_priv;\r\nreturn OCFS2_SB(info->dqi_gi.dqi_sb);\r\n}\r\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres)\r\n{\r\nstruct ocfs2_file_private *fp = lockres->l_priv;\r\nreturn OCFS2_SB(fp->fp_file->f_mapping->host->i_sb);\r\n}\r\nstatic __u64 ocfs2_get_dentry_lock_ino(struct ocfs2_lock_res *lockres)\r\n{\r\n__be64 inode_blkno_be;\r\nmemcpy(&inode_blkno_be, &lockres->l_name[OCFS2_DENTRY_LOCK_INO_START],\r\nsizeof(__be64));\r\nreturn be64_to_cpu(inode_blkno_be);\r\n}\r\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres)\r\n{\r\nstruct ocfs2_dentry_lock *dl = lockres->l_priv;\r\nreturn OCFS2_SB(dl->dl_inode->i_sb);\r\n}\r\nvoid ocfs2_dentry_lock_res_init(struct ocfs2_dentry_lock *dl,\r\nu64 parent, struct inode *inode)\r\n{\r\nint len;\r\nu64 inode_blkno = OCFS2_I(inode)->ip_blkno;\r\n__be64 inode_blkno_be = cpu_to_be64(inode_blkno);\r\nstruct ocfs2_lock_res *lockres = &dl->dl_lockres;\r\nocfs2_lock_res_init_once(lockres);\r\nlen = snprintf(lockres->l_name, OCFS2_DENTRY_LOCK_INO_START,\r\n"%c%016llx",\r\nocfs2_lock_type_char(OCFS2_LOCK_TYPE_DENTRY),\r\n(long long)parent);\r\nBUG_ON(len != (OCFS2_DENTRY_LOCK_INO_START - 1));\r\nmemcpy(&lockres->l_name[OCFS2_DENTRY_LOCK_INO_START], &inode_blkno_be,\r\nsizeof(__be64));\r\nocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), lockres,\r\nOCFS2_LOCK_TYPE_DENTRY, &ocfs2_dentry_lops,\r\ndl);\r\n}\r\nstatic void ocfs2_super_lock_res_init(struct ocfs2_lock_res *res,\r\nstruct ocfs2_super *osb)\r\n{\r\nocfs2_lock_res_init_once(res);\r\nocfs2_build_lock_name(OCFS2_LOCK_TYPE_SUPER, OCFS2_SUPER_BLOCK_BLKNO,\r\n0, res->l_name);\r\nocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_SUPER,\r\n&ocfs2_super_lops, osb);\r\n}\r\nstatic void ocfs2_rename_lock_res_init(struct ocfs2_lock_res *res,\r\nstruct ocfs2_super *osb)\r\n{\r\nocfs2_lock_res_init_once(res);\r\nocfs2_build_lock_name(OCFS2_LOCK_TYPE_RENAME, 0, 0, res->l_name);\r\nocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_RENAME,\r\n&ocfs2_rename_lops, osb);\r\n}\r\nstatic void ocfs2_nfs_sync_lock_res_init(struct ocfs2_lock_res *res,\r\nstruct ocfs2_super *osb)\r\n{\r\nocfs2_lock_res_init_once(res);\r\nocfs2_build_lock_name(OCFS2_LOCK_TYPE_NFS_SYNC, 0, 0, res->l_name);\r\nocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_NFS_SYNC,\r\n&ocfs2_nfs_sync_lops, osb);\r\n}\r\nstatic void ocfs2_orphan_scan_lock_res_init(struct ocfs2_lock_res *res,\r\nstruct ocfs2_super *osb)\r\n{\r\nocfs2_lock_res_init_once(res);\r\nocfs2_build_lock_name(OCFS2_LOCK_TYPE_ORPHAN_SCAN, 0, 0, res->l_name);\r\nocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_ORPHAN_SCAN,\r\n&ocfs2_orphan_scan_lops, osb);\r\n}\r\nvoid ocfs2_file_lock_res_init(struct ocfs2_lock_res *lockres,\r\nstruct ocfs2_file_private *fp)\r\n{\r\nstruct inode *inode = fp->fp_file->f_mapping->host;\r\nstruct ocfs2_inode_info *oi = OCFS2_I(inode);\r\nocfs2_lock_res_init_once(lockres);\r\nocfs2_build_lock_name(OCFS2_LOCK_TYPE_FLOCK, oi->ip_blkno,\r\ninode->i_generation, lockres->l_name);\r\nocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), lockres,\r\nOCFS2_LOCK_TYPE_FLOCK, &ocfs2_flock_lops,\r\nfp);\r\nlockres->l_flags |= OCFS2_LOCK_NOCACHE;\r\n}\r\nvoid ocfs2_qinfo_lock_res_init(struct ocfs2_lock_res *lockres,\r\nstruct ocfs2_mem_dqinfo *info)\r\n{\r\nocfs2_lock_res_init_once(lockres);\r\nocfs2_build_lock_name(OCFS2_LOCK_TYPE_QINFO, info->dqi_gi.dqi_type,\r\n0, lockres->l_name);\r\nocfs2_lock_res_init_common(OCFS2_SB(info->dqi_gi.dqi_sb), lockres,\r\nOCFS2_LOCK_TYPE_QINFO, &ocfs2_qinfo_lops,\r\ninfo);\r\n}\r\nvoid ocfs2_refcount_lock_res_init(struct ocfs2_lock_res *lockres,\r\nstruct ocfs2_super *osb, u64 ref_blkno,\r\nunsigned int generation)\r\n{\r\nocfs2_lock_res_init_once(lockres);\r\nocfs2_build_lock_name(OCFS2_LOCK_TYPE_REFCOUNT, ref_blkno,\r\ngeneration, lockres->l_name);\r\nocfs2_lock_res_init_common(osb, lockres, OCFS2_LOCK_TYPE_REFCOUNT,\r\n&ocfs2_refcount_block_lops, osb);\r\n}\r\nvoid ocfs2_lock_res_free(struct ocfs2_lock_res *res)\r\n{\r\nif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\r\nreturn;\r\nocfs2_remove_lockres_tracking(res);\r\nmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\r\n"Lockres %s is on the blocked list\n",\r\nres->l_name);\r\nmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\r\n"Lockres %s has mask waiters pending\n",\r\nres->l_name);\r\nmlog_bug_on_msg(spin_is_locked(&res->l_lock),\r\n"Lockres %s is locked\n",\r\nres->l_name);\r\nmlog_bug_on_msg(res->l_ro_holders,\r\n"Lockres %s has %u ro holders\n",\r\nres->l_name, res->l_ro_holders);\r\nmlog_bug_on_msg(res->l_ex_holders,\r\n"Lockres %s has %u ex holders\n",\r\nres->l_name, res->l_ex_holders);\r\nmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\r\nres->l_flags = 0UL;\r\n}\r\nstatic inline void ocfs2_inc_holders(struct ocfs2_lock_res *lockres,\r\nint level)\r\n{\r\nBUG_ON(!lockres);\r\nswitch(level) {\r\ncase DLM_LOCK_EX:\r\nlockres->l_ex_holders++;\r\nbreak;\r\ncase DLM_LOCK_PR:\r\nlockres->l_ro_holders++;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic inline void ocfs2_dec_holders(struct ocfs2_lock_res *lockres,\r\nint level)\r\n{\r\nBUG_ON(!lockres);\r\nswitch(level) {\r\ncase DLM_LOCK_EX:\r\nBUG_ON(!lockres->l_ex_holders);\r\nlockres->l_ex_holders--;\r\nbreak;\r\ncase DLM_LOCK_PR:\r\nBUG_ON(!lockres->l_ro_holders);\r\nlockres->l_ro_holders--;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic inline int ocfs2_highest_compat_lock_level(int level)\r\n{\r\nint new_level = DLM_LOCK_EX;\r\nif (level == DLM_LOCK_EX)\r\nnew_level = DLM_LOCK_NL;\r\nelse if (level == DLM_LOCK_PR)\r\nnew_level = DLM_LOCK_PR;\r\nreturn new_level;\r\n}\r\nstatic void lockres_set_flags(struct ocfs2_lock_res *lockres,\r\nunsigned long newflags)\r\n{\r\nstruct ocfs2_mask_waiter *mw, *tmp;\r\nassert_spin_locked(&lockres->l_lock);\r\nlockres->l_flags = newflags;\r\nlist_for_each_entry_safe(mw, tmp, &lockres->l_mask_waiters, mw_item) {\r\nif ((lockres->l_flags & mw->mw_mask) != mw->mw_goal)\r\ncontinue;\r\nlist_del_init(&mw->mw_item);\r\nmw->mw_status = 0;\r\ncomplete(&mw->mw_complete);\r\n}\r\n}\r\nstatic void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)\r\n{\r\nlockres_set_flags(lockres, lockres->l_flags | or);\r\n}\r\nstatic void lockres_clear_flags(struct ocfs2_lock_res *lockres,\r\nunsigned long clear)\r\n{\r\nlockres_set_flags(lockres, lockres->l_flags & ~clear);\r\n}\r\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres)\r\n{\r\nBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\r\nBUG_ON(!(lockres->l_flags & OCFS2_LOCK_ATTACHED));\r\nBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BLOCKED));\r\nBUG_ON(lockres->l_blocking <= DLM_LOCK_NL);\r\nlockres->l_level = lockres->l_requested;\r\nif (lockres->l_level <=\r\nocfs2_highest_compat_lock_level(lockres->l_blocking)) {\r\nlockres->l_blocking = DLM_LOCK_NL;\r\nlockres_clear_flags(lockres, OCFS2_LOCK_BLOCKED);\r\n}\r\nlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\r\n}\r\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres)\r\n{\r\nBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\r\nBUG_ON(!(lockres->l_flags & OCFS2_LOCK_ATTACHED));\r\nif (lockres->l_level == DLM_LOCK_NL &&\r\nlockres->l_ops->flags & LOCK_TYPE_REQUIRES_REFRESH)\r\nlockres_or_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\r\nlockres->l_level = lockres->l_requested;\r\nlockres_or_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\r\nlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\r\n}\r\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres)\r\n{\r\nBUG_ON((!(lockres->l_flags & OCFS2_LOCK_BUSY)));\r\nBUG_ON(lockres->l_flags & OCFS2_LOCK_ATTACHED);\r\nif (lockres->l_requested > DLM_LOCK_NL &&\r\n!(lockres->l_flags & OCFS2_LOCK_LOCAL) &&\r\nlockres->l_ops->flags & LOCK_TYPE_REQUIRES_REFRESH)\r\nlockres_or_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\r\nlockres->l_level = lockres->l_requested;\r\nlockres_or_flags(lockres, OCFS2_LOCK_ATTACHED);\r\nlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\r\n}\r\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres,\r\nint level)\r\n{\r\nint needs_downconvert = 0;\r\nassert_spin_locked(&lockres->l_lock);\r\nif (level > lockres->l_blocking) {\r\nif (ocfs2_highest_compat_lock_level(level) <\r\nocfs2_highest_compat_lock_level(lockres->l_blocking))\r\nneeds_downconvert = 1;\r\nlockres->l_blocking = level;\r\n}\r\nmlog(ML_BASTS, "lockres %s, block %d, level %d, l_block %d, dwn %d\n",\r\nlockres->l_name, level, lockres->l_level, lockres->l_blocking,\r\nneeds_downconvert);\r\nif (needs_downconvert)\r\nlockres_or_flags(lockres, OCFS2_LOCK_BLOCKED);\r\nmlog(0, "needs_downconvert = %d\n", needs_downconvert);\r\nreturn needs_downconvert;\r\n}\r\nstatic void __lockres_clear_pending(struct ocfs2_lock_res *lockres,\r\nunsigned int generation,\r\nstruct ocfs2_super *osb)\r\n{\r\nassert_spin_locked(&lockres->l_lock);\r\nif (!(lockres->l_flags & OCFS2_LOCK_PENDING) ||\r\n(lockres->l_pending_gen != generation))\r\nreturn;\r\nlockres_clear_flags(lockres, OCFS2_LOCK_PENDING);\r\nlockres->l_pending_gen++;\r\nif (lockres->l_flags & OCFS2_LOCK_BLOCKED)\r\nocfs2_wake_downconvert_thread(osb);\r\n}\r\nstatic void lockres_clear_pending(struct ocfs2_lock_res *lockres,\r\nunsigned int generation,\r\nstruct ocfs2_super *osb)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\n__lockres_clear_pending(lockres, generation, osb);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\n}\r\nstatic unsigned int lockres_set_pending(struct ocfs2_lock_res *lockres)\r\n{\r\nassert_spin_locked(&lockres->l_lock);\r\nBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));\r\nlockres_or_flags(lockres, OCFS2_LOCK_PENDING);\r\nreturn lockres->l_pending_gen;\r\n}\r\nstatic void ocfs2_blocking_ast(struct ocfs2_dlm_lksb *lksb, int level)\r\n{\r\nstruct ocfs2_lock_res *lockres = ocfs2_lksb_to_lock_res(lksb);\r\nstruct ocfs2_super *osb = ocfs2_get_lockres_osb(lockres);\r\nint needs_downconvert;\r\nunsigned long flags;\r\nBUG_ON(level <= DLM_LOCK_NL);\r\nmlog(ML_BASTS, "BAST fired for lockres %s, blocking %d, level %d, "\r\n"type %s\n", lockres->l_name, level, lockres->l_level,\r\nocfs2_lock_type_string(lockres->l_type));\r\nif (lockres->l_flags & OCFS2_LOCK_NOCACHE)\r\nreturn;\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nneeds_downconvert = ocfs2_generic_handle_bast(lockres, level);\r\nif (needs_downconvert)\r\nocfs2_schedule_blocked_lock(osb, lockres);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nwake_up(&lockres->l_event);\r\nocfs2_wake_downconvert_thread(osb);\r\n}\r\nstatic void ocfs2_locking_ast(struct ocfs2_dlm_lksb *lksb)\r\n{\r\nstruct ocfs2_lock_res *lockres = ocfs2_lksb_to_lock_res(lksb);\r\nstruct ocfs2_super *osb = ocfs2_get_lockres_osb(lockres);\r\nunsigned long flags;\r\nint status;\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nstatus = ocfs2_dlm_lock_status(&lockres->l_lksb);\r\nif (status == -EAGAIN) {\r\nlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\r\ngoto out;\r\n}\r\nif (status) {\r\nmlog(ML_ERROR, "lockres %s: lksb status value of %d!\n",\r\nlockres->l_name, status);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nreturn;\r\n}\r\nmlog(ML_BASTS, "AST fired for lockres %s, action %d, unlock %d, "\r\n"level %d => %d\n", lockres->l_name, lockres->l_action,\r\nlockres->l_unlock_action, lockres->l_level, lockres->l_requested);\r\nswitch(lockres->l_action) {\r\ncase OCFS2_AST_ATTACH:\r\nocfs2_generic_handle_attach_action(lockres);\r\nlockres_clear_flags(lockres, OCFS2_LOCK_LOCAL);\r\nbreak;\r\ncase OCFS2_AST_CONVERT:\r\nocfs2_generic_handle_convert_action(lockres);\r\nbreak;\r\ncase OCFS2_AST_DOWNCONVERT:\r\nocfs2_generic_handle_downconvert_action(lockres);\r\nbreak;\r\ndefault:\r\nmlog(ML_ERROR, "lockres %s: AST fired with invalid action: %u, "\r\n"flags 0x%lx, unlock: %u\n",\r\nlockres->l_name, lockres->l_action, lockres->l_flags,\r\nlockres->l_unlock_action);\r\nBUG();\r\n}\r\nout:\r\nlockres->l_action = OCFS2_AST_INVALID;\r\nif (lockres->l_unlock_action == OCFS2_UNLOCK_CANCEL_CONVERT)\r\nlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\r\n__lockres_clear_pending(lockres, lockres->l_pending_gen, osb);\r\nwake_up(&lockres->l_event);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\n}\r\nstatic void ocfs2_unlock_ast(struct ocfs2_dlm_lksb *lksb, int error)\r\n{\r\nstruct ocfs2_lock_res *lockres = ocfs2_lksb_to_lock_res(lksb);\r\nunsigned long flags;\r\nmlog(ML_BASTS, "UNLOCK AST fired for lockres %s, action = %d\n",\r\nlockres->l_name, lockres->l_unlock_action);\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nif (error) {\r\nmlog(ML_ERROR, "Dlm passes error %d for lock %s, "\r\n"unlock_action %d\n", error, lockres->l_name,\r\nlockres->l_unlock_action);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nreturn;\r\n}\r\nswitch(lockres->l_unlock_action) {\r\ncase OCFS2_UNLOCK_CANCEL_CONVERT:\r\nmlog(0, "Cancel convert success for %s\n", lockres->l_name);\r\nlockres->l_action = OCFS2_AST_INVALID;\r\nif (lockres->l_flags & OCFS2_LOCK_BLOCKED)\r\nocfs2_wake_downconvert_thread(ocfs2_get_lockres_osb(lockres));\r\nbreak;\r\ncase OCFS2_UNLOCK_DROP_LOCK:\r\nlockres->l_level = DLM_LOCK_IV;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\r\nlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\r\nwake_up(&lockres->l_event);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\n}\r\nvoid ocfs2_set_locking_protocol(void)\r\n{\r\nocfs2_stack_glue_set_max_proto_version(&lproto.lp_max_version);\r\n}\r\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\r\nint convert)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nlockres_clear_flags(lockres, OCFS2_LOCK_BUSY);\r\nlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\r\nif (convert)\r\nlockres->l_action = OCFS2_AST_INVALID;\r\nelse\r\nlockres->l_unlock_action = OCFS2_UNLOCK_INVALID;\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nwake_up(&lockres->l_event);\r\n}\r\nstatic int ocfs2_lock_create(struct ocfs2_super *osb,\r\nstruct ocfs2_lock_res *lockres,\r\nint level,\r\nu32 dlm_flags)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nunsigned int gen;\r\nmlog(0, "lock %s, level = %d, flags = %u\n", lockres->l_name, level,\r\ndlm_flags);\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nif ((lockres->l_flags & OCFS2_LOCK_ATTACHED) ||\r\n(lockres->l_flags & OCFS2_LOCK_BUSY)) {\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\ngoto bail;\r\n}\r\nlockres->l_action = OCFS2_AST_ATTACH;\r\nlockres->l_requested = level;\r\nlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\r\ngen = lockres_set_pending(lockres);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nret = ocfs2_dlm_lock(osb->cconn,\r\nlevel,\r\n&lockres->l_lksb,\r\ndlm_flags,\r\nlockres->l_name,\r\nOCFS2_LOCK_ID_MAX_LEN - 1);\r\nlockres_clear_pending(lockres, gen, osb);\r\nif (ret) {\r\nocfs2_log_dlm_error("ocfs2_dlm_lock", ret, lockres);\r\nocfs2_recover_from_dlm_error(lockres, 1);\r\n}\r\nmlog(0, "lock %s, return from ocfs2_dlm_lock\n", lockres->l_name);\r\nbail:\r\nreturn ret;\r\n}\r\nstatic inline int ocfs2_check_wait_flag(struct ocfs2_lock_res *lockres,\r\nint flag)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nret = lockres->l_flags & flag;\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nreturn ret;\r\n}\r\nstatic inline void ocfs2_wait_on_busy_lock(struct ocfs2_lock_res *lockres)\r\n{\r\nwait_event(lockres->l_event,\r\n!ocfs2_check_wait_flag(lockres, OCFS2_LOCK_BUSY));\r\n}\r\nstatic inline void ocfs2_wait_on_refreshing_lock(struct ocfs2_lock_res *lockres)\r\n{\r\nwait_event(lockres->l_event,\r\n!ocfs2_check_wait_flag(lockres, OCFS2_LOCK_REFRESHING));\r\n}\r\nstatic inline int ocfs2_may_continue_on_blocked_lock(struct ocfs2_lock_res *lockres,\r\nint wanted)\r\n{\r\nBUG_ON(!(lockres->l_flags & OCFS2_LOCK_BLOCKED));\r\nreturn wanted <= ocfs2_highest_compat_lock_level(lockres->l_blocking);\r\n}\r\nstatic void ocfs2_init_mask_waiter(struct ocfs2_mask_waiter *mw)\r\n{\r\nINIT_LIST_HEAD(&mw->mw_item);\r\ninit_completion(&mw->mw_complete);\r\nocfs2_init_start_time(mw);\r\n}\r\nstatic int ocfs2_wait_for_mask(struct ocfs2_mask_waiter *mw)\r\n{\r\nwait_for_completion(&mw->mw_complete);\r\nreinit_completion(&mw->mw_complete);\r\nreturn mw->mw_status;\r\n}\r\nstatic void lockres_add_mask_waiter(struct ocfs2_lock_res *lockres,\r\nstruct ocfs2_mask_waiter *mw,\r\nunsigned long mask,\r\nunsigned long goal)\r\n{\r\nBUG_ON(!list_empty(&mw->mw_item));\r\nassert_spin_locked(&lockres->l_lock);\r\nlist_add_tail(&mw->mw_item, &lockres->l_mask_waiters);\r\nmw->mw_mask = mask;\r\nmw->mw_goal = goal;\r\n}\r\nstatic int lockres_remove_mask_waiter(struct ocfs2_lock_res *lockres,\r\nstruct ocfs2_mask_waiter *mw)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nif (!list_empty(&mw->mw_item)) {\r\nif ((lockres->l_flags & mw->mw_mask) != mw->mw_goal)\r\nret = -EBUSY;\r\nlist_del_init(&mw->mw_item);\r\ninit_completion(&mw->mw_complete);\r\n}\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_wait_for_mask_interruptible(struct ocfs2_mask_waiter *mw,\r\nstruct ocfs2_lock_res *lockres)\r\n{\r\nint ret;\r\nret = wait_for_completion_interruptible(&mw->mw_complete);\r\nif (ret)\r\nlockres_remove_mask_waiter(lockres, mw);\r\nelse\r\nret = mw->mw_status;\r\nreinit_completion(&mw->mw_complete);\r\nreturn ret;\r\n}\r\nstatic int __ocfs2_cluster_lock(struct ocfs2_super *osb,\r\nstruct ocfs2_lock_res *lockres,\r\nint level,\r\nu32 lkm_flags,\r\nint arg_flags,\r\nint l_subclass,\r\nunsigned long caller_ip)\r\n{\r\nstruct ocfs2_mask_waiter mw;\r\nint wait, catch_signals = !(osb->s_mount_opt & OCFS2_MOUNT_NOINTR);\r\nint ret = 0;\r\nunsigned long flags;\r\nunsigned int gen;\r\nint noqueue_attempted = 0;\r\nocfs2_init_mask_waiter(&mw);\r\nif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB)\r\nlkm_flags |= DLM_LKF_VALBLK;\r\nagain:\r\nwait = 0;\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nif (catch_signals && signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\ngoto unlock;\r\n}\r\nmlog_bug_on_msg(lockres->l_flags & OCFS2_LOCK_FREEING,\r\n"Cluster lock called on freeing lockres %s! flags "\r\n"0x%lx\n", lockres->l_name, lockres->l_flags);\r\nif (lockres->l_flags & OCFS2_LOCK_BUSY &&\r\nlevel > lockres->l_level) {\r\nlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\r\nwait = 1;\r\ngoto unlock;\r\n}\r\nif (lockres->l_flags & OCFS2_LOCK_UPCONVERT_FINISHING) {\r\nif (level <= lockres->l_level)\r\ngoto update_holders;\r\n}\r\nif (lockres->l_flags & OCFS2_LOCK_BLOCKED &&\r\n!ocfs2_may_continue_on_blocked_lock(lockres, level)) {\r\nlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BLOCKED, 0);\r\nwait = 1;\r\ngoto unlock;\r\n}\r\nif (level > lockres->l_level) {\r\nif (noqueue_attempted > 0) {\r\nret = -EAGAIN;\r\ngoto unlock;\r\n}\r\nif (lkm_flags & DLM_LKF_NOQUEUE)\r\nnoqueue_attempted = 1;\r\nif (lockres->l_action != OCFS2_AST_INVALID)\r\nmlog(ML_ERROR, "lockres %s has action %u pending\n",\r\nlockres->l_name, lockres->l_action);\r\nif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\r\nlockres->l_action = OCFS2_AST_ATTACH;\r\nlkm_flags &= ~DLM_LKF_CONVERT;\r\n} else {\r\nlockres->l_action = OCFS2_AST_CONVERT;\r\nlkm_flags |= DLM_LKF_CONVERT;\r\n}\r\nlockres->l_requested = level;\r\nlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\r\ngen = lockres_set_pending(lockres);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nBUG_ON(level == DLM_LOCK_IV);\r\nBUG_ON(level == DLM_LOCK_NL);\r\nmlog(ML_BASTS, "lockres %s, convert from %d to %d\n",\r\nlockres->l_name, lockres->l_level, level);\r\nret = ocfs2_dlm_lock(osb->cconn,\r\nlevel,\r\n&lockres->l_lksb,\r\nlkm_flags,\r\nlockres->l_name,\r\nOCFS2_LOCK_ID_MAX_LEN - 1);\r\nlockres_clear_pending(lockres, gen, osb);\r\nif (ret) {\r\nif (!(lkm_flags & DLM_LKF_NOQUEUE) ||\r\n(ret != -EAGAIN)) {\r\nocfs2_log_dlm_error("ocfs2_dlm_lock",\r\nret, lockres);\r\n}\r\nocfs2_recover_from_dlm_error(lockres, 1);\r\ngoto out;\r\n}\r\nmlog(0, "lock %s, successful return from ocfs2_dlm_lock\n",\r\nlockres->l_name);\r\ncatch_signals = 0;\r\ngoto again;\r\n}\r\nupdate_holders:\r\nocfs2_inc_holders(lockres, level);\r\nret = 0;\r\nunlock:\r\nlockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nout:\r\nif (wait && arg_flags & OCFS2_LOCK_NONBLOCK &&\r\nmw.mw_mask & (OCFS2_LOCK_BUSY|OCFS2_LOCK_BLOCKED)) {\r\nwait = 0;\r\nif (lockres_remove_mask_waiter(lockres, &mw))\r\nret = -EAGAIN;\r\nelse\r\ngoto again;\r\n}\r\nif (wait) {\r\nret = ocfs2_wait_for_mask(&mw);\r\nif (ret == 0)\r\ngoto again;\r\nmlog_errno(ret);\r\n}\r\nocfs2_update_lock_stats(lockres, level, &mw, ret);\r\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\r\nif (!ret && lockres->l_lockdep_map.key != NULL) {\r\nif (level == DLM_LOCK_PR)\r\nrwsem_acquire_read(&lockres->l_lockdep_map, l_subclass,\r\n!!(arg_flags & OCFS2_META_LOCK_NOQUEUE),\r\ncaller_ip);\r\nelse\r\nrwsem_acquire(&lockres->l_lockdep_map, l_subclass,\r\n!!(arg_flags & OCFS2_META_LOCK_NOQUEUE),\r\ncaller_ip);\r\n}\r\n#endif\r\nreturn ret;\r\n}\r\nstatic inline int ocfs2_cluster_lock(struct ocfs2_super *osb,\r\nstruct ocfs2_lock_res *lockres,\r\nint level,\r\nu32 lkm_flags,\r\nint arg_flags)\r\n{\r\nreturn __ocfs2_cluster_lock(osb, lockres, level, lkm_flags, arg_flags,\r\n0, _RET_IP_);\r\n}\r\nstatic void __ocfs2_cluster_unlock(struct ocfs2_super *osb,\r\nstruct ocfs2_lock_res *lockres,\r\nint level,\r\nunsigned long caller_ip)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nocfs2_dec_holders(lockres, level);\r\nocfs2_downconvert_on_unlock(osb, lockres);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\r\nif (lockres->l_lockdep_map.key != NULL)\r\nrwsem_release(&lockres->l_lockdep_map, 1, caller_ip);\r\n#endif\r\n}\r\nstatic int ocfs2_create_new_lock(struct ocfs2_super *osb,\r\nstruct ocfs2_lock_res *lockres,\r\nint ex,\r\nint local)\r\n{\r\nint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\r\nunsigned long flags;\r\nu32 lkm_flags = local ? DLM_LKF_LOCAL : 0;\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nBUG_ON(lockres->l_flags & OCFS2_LOCK_ATTACHED);\r\nlockres_or_flags(lockres, OCFS2_LOCK_LOCAL);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nreturn ocfs2_lock_create(osb, lockres, level, lkm_flags);\r\n}\r\nint ocfs2_create_new_inode_locks(struct inode *inode)\r\n{\r\nint ret;\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nBUG_ON(!inode);\r\nBUG_ON(!ocfs2_inode_is_new(inode));\r\nmlog(0, "Inode %llu\n", (unsigned long long)OCFS2_I(inode)->ip_blkno);\r\nret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_rw_lockres, 1, 1);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto bail;\r\n}\r\nret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_inode_lockres, 1, 0);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto bail;\r\n}\r\nret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_open_lockres, 0, 0);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto bail;\r\n}\r\nbail:\r\nreturn ret;\r\n}\r\nint ocfs2_rw_lock(struct inode *inode, int write)\r\n{\r\nint status, level;\r\nstruct ocfs2_lock_res *lockres;\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nBUG_ON(!inode);\r\nmlog(0, "inode %llu take %s RW lock\n",\r\n(unsigned long long)OCFS2_I(inode)->ip_blkno,\r\nwrite ? "EXMODE" : "PRMODE");\r\nif (ocfs2_mount_local(osb))\r\nreturn 0;\r\nlockres = &OCFS2_I(inode)->ip_rw_lockres;\r\nlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\r\nstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres, level, 0,\r\n0);\r\nif (status < 0)\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nvoid ocfs2_rw_unlock(struct inode *inode, int write)\r\n{\r\nint level = write ? DLM_LOCK_EX : DLM_LOCK_PR;\r\nstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_rw_lockres;\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nmlog(0, "inode %llu drop %s RW lock\n",\r\n(unsigned long long)OCFS2_I(inode)->ip_blkno,\r\nwrite ? "EXMODE" : "PRMODE");\r\nif (!ocfs2_mount_local(osb))\r\nocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\r\n}\r\nint ocfs2_open_lock(struct inode *inode)\r\n{\r\nint status = 0;\r\nstruct ocfs2_lock_res *lockres;\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nBUG_ON(!inode);\r\nmlog(0, "inode %llu take PRMODE open lock\n",\r\n(unsigned long long)OCFS2_I(inode)->ip_blkno);\r\nif (ocfs2_is_hard_readonly(osb) || ocfs2_mount_local(osb))\r\ngoto out;\r\nlockres = &OCFS2_I(inode)->ip_open_lockres;\r\nstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres,\r\nDLM_LOCK_PR, 0, 0);\r\nif (status < 0)\r\nmlog_errno(status);\r\nout:\r\nreturn status;\r\n}\r\nint ocfs2_try_open_lock(struct inode *inode, int write)\r\n{\r\nint status = 0, level;\r\nstruct ocfs2_lock_res *lockres;\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nBUG_ON(!inode);\r\nmlog(0, "inode %llu try to take %s open lock\n",\r\n(unsigned long long)OCFS2_I(inode)->ip_blkno,\r\nwrite ? "EXMODE" : "PRMODE");\r\nif (ocfs2_is_hard_readonly(osb)) {\r\nif (write)\r\nstatus = -EROFS;\r\ngoto out;\r\n}\r\nif (ocfs2_mount_local(osb))\r\ngoto out;\r\nlockres = &OCFS2_I(inode)->ip_open_lockres;\r\nlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\r\nstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres,\r\nlevel, DLM_LKF_NOQUEUE, 0);\r\nout:\r\nreturn status;\r\n}\r\nvoid ocfs2_open_unlock(struct inode *inode)\r\n{\r\nstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_open_lockres;\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nmlog(0, "inode %llu drop open lock\n",\r\n(unsigned long long)OCFS2_I(inode)->ip_blkno);\r\nif (ocfs2_mount_local(osb))\r\ngoto out;\r\nif(lockres->l_ro_holders)\r\nocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres,\r\nDLM_LOCK_PR);\r\nif(lockres->l_ex_holders)\r\nocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres,\r\nDLM_LOCK_EX);\r\nout:\r\nreturn;\r\n}\r\nstatic int ocfs2_flock_handle_signal(struct ocfs2_lock_res *lockres,\r\nint level)\r\n{\r\nint ret;\r\nstruct ocfs2_super *osb = ocfs2_get_lockres_osb(lockres);\r\nunsigned long flags;\r\nstruct ocfs2_mask_waiter mw;\r\nocfs2_init_mask_waiter(&mw);\r\nretry_cancel:\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nif (lockres->l_flags & OCFS2_LOCK_BUSY) {\r\nret = ocfs2_prepare_cancel_convert(osb, lockres);\r\nif (ret) {\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nret = ocfs2_cancel_convert(osb, lockres);\r\nif (ret < 0) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\ngoto retry_cancel;\r\n}\r\nlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nocfs2_wait_for_mask(&mw);\r\ngoto retry_cancel;\r\n}\r\nret = -ERESTARTSYS;\r\nif (lockres->l_level == level)\r\nret = 0;\r\nmlog(0, "Cancel returning %d. flags: 0x%lx, level: %d, act: %d\n", ret,\r\nlockres->l_flags, lockres->l_level, lockres->l_action);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nout:\r\nreturn ret;\r\n}\r\nint ocfs2_file_lock(struct file *file, int ex, int trylock)\r\n{\r\nint ret, level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\r\nunsigned int lkm_flags = trylock ? DLM_LKF_NOQUEUE : 0;\r\nunsigned long flags;\r\nstruct ocfs2_file_private *fp = file->private_data;\r\nstruct ocfs2_lock_res *lockres = &fp->fp_flock;\r\nstruct ocfs2_super *osb = OCFS2_SB(file->f_mapping->host->i_sb);\r\nstruct ocfs2_mask_waiter mw;\r\nocfs2_init_mask_waiter(&mw);\r\nif ((lockres->l_flags & OCFS2_LOCK_BUSY) ||\r\n(lockres->l_level > DLM_LOCK_NL)) {\r\nmlog(ML_ERROR,\r\n"File lock \"%s\" has busy or locked state: flags: 0x%lx, "\r\n"level: %u\n", lockres->l_name, lockres->l_flags,\r\nlockres->l_level);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\r\nlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nret = ocfs2_lock_create(osb, lockres, DLM_LOCK_NL, 0);\r\nif (ret < 0) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nret = ocfs2_wait_for_mask(&mw);\r\nif (ret) {\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\n}\r\nlockres->l_action = OCFS2_AST_CONVERT;\r\nlkm_flags |= DLM_LKF_CONVERT;\r\nlockres->l_requested = level;\r\nlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\r\nlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nret = ocfs2_dlm_lock(osb->cconn, level, &lockres->l_lksb, lkm_flags,\r\nlockres->l_name, OCFS2_LOCK_ID_MAX_LEN - 1);\r\nif (ret) {\r\nif (!trylock || (ret != -EAGAIN)) {\r\nocfs2_log_dlm_error("ocfs2_dlm_lock", ret, lockres);\r\nret = -EINVAL;\r\n}\r\nocfs2_recover_from_dlm_error(lockres, 1);\r\nlockres_remove_mask_waiter(lockres, &mw);\r\ngoto out;\r\n}\r\nret = ocfs2_wait_for_mask_interruptible(&mw, lockres);\r\nif (ret == -ERESTARTSYS) {\r\nret = ocfs2_flock_handle_signal(lockres, level);\r\n} else if (!ret && (level > lockres->l_level)) {\r\nBUG_ON(!trylock);\r\nret = -EAGAIN;\r\n}\r\nout:\r\nmlog(0, "Lock: \"%s\" ex: %d, trylock: %d, returns: %d\n",\r\nlockres->l_name, ex, trylock, ret);\r\nreturn ret;\r\n}\r\nvoid ocfs2_file_unlock(struct file *file)\r\n{\r\nint ret;\r\nunsigned int gen;\r\nunsigned long flags;\r\nstruct ocfs2_file_private *fp = file->private_data;\r\nstruct ocfs2_lock_res *lockres = &fp->fp_flock;\r\nstruct ocfs2_super *osb = OCFS2_SB(file->f_mapping->host->i_sb);\r\nstruct ocfs2_mask_waiter mw;\r\nocfs2_init_mask_waiter(&mw);\r\nif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED))\r\nreturn;\r\nif (lockres->l_level == DLM_LOCK_NL)\r\nreturn;\r\nmlog(0, "Unlock: \"%s\" flags: 0x%lx, level: %d, act: %d\n",\r\nlockres->l_name, lockres->l_flags, lockres->l_level,\r\nlockres->l_action);\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nlockres_or_flags(lockres, OCFS2_LOCK_BLOCKED);\r\nlockres->l_blocking = DLM_LOCK_EX;\r\ngen = ocfs2_prepare_downconvert(lockres, DLM_LOCK_NL);\r\nlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nret = ocfs2_downconvert_lock(osb, lockres, DLM_LOCK_NL, 0, gen);\r\nif (ret) {\r\nmlog_errno(ret);\r\nreturn;\r\n}\r\nret = ocfs2_wait_for_mask(&mw);\r\nif (ret)\r\nmlog_errno(ret);\r\n}\r\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\r\nstruct ocfs2_lock_res *lockres)\r\n{\r\nint kick = 0;\r\nif (lockres->l_flags & OCFS2_LOCK_BLOCKED) {\r\nswitch(lockres->l_blocking) {\r\ncase DLM_LOCK_EX:\r\nif (!lockres->l_ex_holders && !lockres->l_ro_holders)\r\nkick = 1;\r\nbreak;\r\ncase DLM_LOCK_PR:\r\nif (!lockres->l_ex_holders)\r\nkick = 1;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nif (kick)\r\nocfs2_wake_downconvert_thread(osb);\r\n}\r\nstatic u64 ocfs2_pack_timespec(struct timespec *spec)\r\n{\r\nu64 res;\r\nu64 sec = spec->tv_sec;\r\nu32 nsec = spec->tv_nsec;\r\nres = (sec << OCFS2_SEC_SHIFT) | (nsec & OCFS2_NSEC_MASK);\r\nreturn res;\r\n}\r\nstatic void __ocfs2_stuff_meta_lvb(struct inode *inode)\r\n{\r\nstruct ocfs2_inode_info *oi = OCFS2_I(inode);\r\nstruct ocfs2_lock_res *lockres = &oi->ip_inode_lockres;\r\nstruct ocfs2_meta_lvb *lvb;\r\nlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\r\nif (oi->ip_flags & OCFS2_INODE_DELETED) {\r\nlvb->lvb_version = 0;\r\ngoto out;\r\n}\r\nlvb->lvb_version = OCFS2_LVB_VERSION;\r\nlvb->lvb_isize = cpu_to_be64(i_size_read(inode));\r\nlvb->lvb_iclusters = cpu_to_be32(oi->ip_clusters);\r\nlvb->lvb_iuid = cpu_to_be32(i_uid_read(inode));\r\nlvb->lvb_igid = cpu_to_be32(i_gid_read(inode));\r\nlvb->lvb_imode = cpu_to_be16(inode->i_mode);\r\nlvb->lvb_inlink = cpu_to_be16(inode->i_nlink);\r\nlvb->lvb_iatime_packed =\r\ncpu_to_be64(ocfs2_pack_timespec(&inode->i_atime));\r\nlvb->lvb_ictime_packed =\r\ncpu_to_be64(ocfs2_pack_timespec(&inode->i_ctime));\r\nlvb->lvb_imtime_packed =\r\ncpu_to_be64(ocfs2_pack_timespec(&inode->i_mtime));\r\nlvb->lvb_iattr = cpu_to_be32(oi->ip_attr);\r\nlvb->lvb_idynfeatures = cpu_to_be16(oi->ip_dyn_features);\r\nlvb->lvb_igeneration = cpu_to_be32(inode->i_generation);\r\nout:\r\nmlog_meta_lvb(0, lockres);\r\n}\r\nstatic void ocfs2_unpack_timespec(struct timespec *spec,\r\nu64 packed_time)\r\n{\r\nspec->tv_sec = packed_time >> OCFS2_SEC_SHIFT;\r\nspec->tv_nsec = packed_time & OCFS2_NSEC_MASK;\r\n}\r\nstatic void ocfs2_refresh_inode_from_lvb(struct inode *inode)\r\n{\r\nstruct ocfs2_inode_info *oi = OCFS2_I(inode);\r\nstruct ocfs2_lock_res *lockres = &oi->ip_inode_lockres;\r\nstruct ocfs2_meta_lvb *lvb;\r\nmlog_meta_lvb(0, lockres);\r\nlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\r\nspin_lock(&oi->ip_lock);\r\noi->ip_clusters = be32_to_cpu(lvb->lvb_iclusters);\r\ni_size_write(inode, be64_to_cpu(lvb->lvb_isize));\r\noi->ip_attr = be32_to_cpu(lvb->lvb_iattr);\r\noi->ip_dyn_features = be16_to_cpu(lvb->lvb_idynfeatures);\r\nocfs2_set_inode_flags(inode);\r\nif (S_ISLNK(inode->i_mode) && !oi->ip_clusters)\r\ninode->i_blocks = 0;\r\nelse\r\ninode->i_blocks = ocfs2_inode_sector_count(inode);\r\ni_uid_write(inode, be32_to_cpu(lvb->lvb_iuid));\r\ni_gid_write(inode, be32_to_cpu(lvb->lvb_igid));\r\ninode->i_mode = be16_to_cpu(lvb->lvb_imode);\r\nset_nlink(inode, be16_to_cpu(lvb->lvb_inlink));\r\nocfs2_unpack_timespec(&inode->i_atime,\r\nbe64_to_cpu(lvb->lvb_iatime_packed));\r\nocfs2_unpack_timespec(&inode->i_mtime,\r\nbe64_to_cpu(lvb->lvb_imtime_packed));\r\nocfs2_unpack_timespec(&inode->i_ctime,\r\nbe64_to_cpu(lvb->lvb_ictime_packed));\r\nspin_unlock(&oi->ip_lock);\r\n}\r\nstatic inline int ocfs2_meta_lvb_is_trustable(struct inode *inode,\r\nstruct ocfs2_lock_res *lockres)\r\n{\r\nstruct ocfs2_meta_lvb *lvb = ocfs2_dlm_lvb(&lockres->l_lksb);\r\nif (ocfs2_dlm_lvb_valid(&lockres->l_lksb)\r\n&& lvb->lvb_version == OCFS2_LVB_VERSION\r\n&& be32_to_cpu(lvb->lvb_igeneration) == inode->i_generation)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ocfs2_should_refresh_lock_res(struct ocfs2_lock_res *lockres)\r\n{\r\nunsigned long flags;\r\nint status = 0;\r\nrefresh_check:\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nif (!(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH)) {\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\ngoto bail;\r\n}\r\nif (lockres->l_flags & OCFS2_LOCK_REFRESHING) {\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nocfs2_wait_on_refreshing_lock(lockres);\r\ngoto refresh_check;\r\n}\r\nlockres_or_flags(lockres, OCFS2_LOCK_REFRESHING);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nstatus = 1;\r\nbail:\r\nmlog(0, "status %d\n", status);\r\nreturn status;\r\n}\r\nstatic inline void ocfs2_complete_lock_res_refresh(struct ocfs2_lock_res *lockres,\r\nint status)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nlockres_clear_flags(lockres, OCFS2_LOCK_REFRESHING);\r\nif (!status)\r\nlockres_clear_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nwake_up(&lockres->l_event);\r\n}\r\nstatic int ocfs2_inode_lock_update(struct inode *inode,\r\nstruct buffer_head **bh)\r\n{\r\nint status = 0;\r\nstruct ocfs2_inode_info *oi = OCFS2_I(inode);\r\nstruct ocfs2_lock_res *lockres = &oi->ip_inode_lockres;\r\nstruct ocfs2_dinode *fe;\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nif (ocfs2_mount_local(osb))\r\ngoto bail;\r\nspin_lock(&oi->ip_lock);\r\nif (oi->ip_flags & OCFS2_INODE_DELETED) {\r\nmlog(0, "Orphaned inode %llu was deleted while we "\r\n"were waiting on a lock. ip_flags = 0x%x\n",\r\n(unsigned long long)oi->ip_blkno, oi->ip_flags);\r\nspin_unlock(&oi->ip_lock);\r\nstatus = -ENOENT;\r\ngoto bail;\r\n}\r\nspin_unlock(&oi->ip_lock);\r\nif (!ocfs2_should_refresh_lock_res(lockres))\r\ngoto bail;\r\nocfs2_metadata_cache_purge(INODE_CACHE(inode));\r\nocfs2_extent_map_trunc(inode, 0);\r\nif (ocfs2_meta_lvb_is_trustable(inode, lockres)) {\r\nmlog(0, "Trusting LVB on inode %llu\n",\r\n(unsigned long long)oi->ip_blkno);\r\nocfs2_refresh_inode_from_lvb(inode);\r\n} else {\r\nstatus = ocfs2_read_inode_block(inode, bh);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto bail_refresh;\r\n}\r\nfe = (struct ocfs2_dinode *) (*bh)->b_data;\r\nmlog_bug_on_msg(inode->i_generation !=\r\nle32_to_cpu(fe->i_generation),\r\n"Invalid dinode %llu disk generation: %u "\r\n"inode->i_generation: %u\n",\r\n(unsigned long long)oi->ip_blkno,\r\nle32_to_cpu(fe->i_generation),\r\ninode->i_generation);\r\nmlog_bug_on_msg(le64_to_cpu(fe->i_dtime) ||\r\n!(fe->i_flags & cpu_to_le32(OCFS2_VALID_FL)),\r\n"Stale dinode %llu dtime: %llu flags: 0x%x\n",\r\n(unsigned long long)oi->ip_blkno,\r\n(unsigned long long)le64_to_cpu(fe->i_dtime),\r\nle32_to_cpu(fe->i_flags));\r\nocfs2_refresh_inode(inode, fe);\r\nocfs2_track_lock_refresh(lockres);\r\n}\r\nstatus = 0;\r\nbail_refresh:\r\nocfs2_complete_lock_res_refresh(lockres, status);\r\nbail:\r\nreturn status;\r\n}\r\nstatic int ocfs2_assign_bh(struct inode *inode,\r\nstruct buffer_head **ret_bh,\r\nstruct buffer_head *passed_bh)\r\n{\r\nint status;\r\nif (passed_bh) {\r\n*ret_bh = passed_bh;\r\nget_bh(*ret_bh);\r\nreturn 0;\r\n}\r\nstatus = ocfs2_read_inode_block(inode, ret_bh);\r\nif (status < 0)\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nint ocfs2_inode_lock_full_nested(struct inode *inode,\r\nstruct buffer_head **ret_bh,\r\nint ex,\r\nint arg_flags,\r\nint subclass)\r\n{\r\nint status, level, acquired;\r\nu32 dlm_flags;\r\nstruct ocfs2_lock_res *lockres = NULL;\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nstruct buffer_head *local_bh = NULL;\r\nBUG_ON(!inode);\r\nmlog(0, "inode %llu, take %s META lock\n",\r\n(unsigned long long)OCFS2_I(inode)->ip_blkno,\r\nex ? "EXMODE" : "PRMODE");\r\nstatus = 0;\r\nacquired = 0;\r\nif (ocfs2_is_hard_readonly(osb)) {\r\nif (ex)\r\nstatus = -EROFS;\r\ngoto getbh;\r\n}\r\nif (ocfs2_mount_local(osb))\r\ngoto local;\r\nif (!(arg_flags & OCFS2_META_LOCK_RECOVERY))\r\nocfs2_wait_for_recovery(osb);\r\nlockres = &OCFS2_I(inode)->ip_inode_lockres;\r\nlevel = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\r\ndlm_flags = 0;\r\nif (arg_flags & OCFS2_META_LOCK_NOQUEUE)\r\ndlm_flags |= DLM_LKF_NOQUEUE;\r\nstatus = __ocfs2_cluster_lock(osb, lockres, level, dlm_flags,\r\narg_flags, subclass, _RET_IP_);\r\nif (status < 0) {\r\nif (status != -EAGAIN)\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nacquired = 1;\r\nif (!(arg_flags & OCFS2_META_LOCK_RECOVERY))\r\nocfs2_wait_for_recovery(osb);\r\nlocal:\r\nif (inode->i_state & I_NEW) {\r\nstatus = 0;\r\nif (lockres)\r\nocfs2_complete_lock_res_refresh(lockres, 0);\r\ngoto bail;\r\n}\r\nstatus = ocfs2_inode_lock_update(inode, &local_bh);\r\nif (status < 0) {\r\nif (status != -ENOENT)\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\ngetbh:\r\nif (ret_bh) {\r\nstatus = ocfs2_assign_bh(inode, ret_bh, local_bh);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\n}\r\nbail:\r\nif (status < 0) {\r\nif (ret_bh && (*ret_bh)) {\r\nbrelse(*ret_bh);\r\n*ret_bh = NULL;\r\n}\r\nif (acquired)\r\nocfs2_inode_unlock(inode, ex);\r\n}\r\nif (local_bh)\r\nbrelse(local_bh);\r\nreturn status;\r\n}\r\nint ocfs2_inode_lock_with_page(struct inode *inode,\r\nstruct buffer_head **ret_bh,\r\nint ex,\r\nstruct page *page)\r\n{\r\nint ret;\r\nret = ocfs2_inode_lock_full(inode, ret_bh, ex, OCFS2_LOCK_NONBLOCK);\r\nif (ret == -EAGAIN) {\r\nunlock_page(page);\r\nif (ocfs2_inode_lock(inode, ret_bh, ex) == 0)\r\nocfs2_inode_unlock(inode, ex);\r\nret = AOP_TRUNCATED_PAGE;\r\n}\r\nreturn ret;\r\n}\r\nint ocfs2_inode_lock_atime(struct inode *inode,\r\nstruct vfsmount *vfsmnt,\r\nint *level)\r\n{\r\nint ret;\r\nret = ocfs2_inode_lock(inode, NULL, 0);\r\nif (ret < 0) {\r\nmlog_errno(ret);\r\nreturn ret;\r\n}\r\nif (ocfs2_should_update_atime(inode, vfsmnt)) {\r\nstruct buffer_head *bh = NULL;\r\nocfs2_inode_unlock(inode, 0);\r\nret = ocfs2_inode_lock(inode, &bh, 1);\r\nif (ret < 0) {\r\nmlog_errno(ret);\r\nreturn ret;\r\n}\r\n*level = 1;\r\nif (ocfs2_should_update_atime(inode, vfsmnt))\r\nocfs2_update_inode_atime(inode, bh);\r\nif (bh)\r\nbrelse(bh);\r\n} else\r\n*level = 0;\r\nreturn ret;\r\n}\r\nvoid ocfs2_inode_unlock(struct inode *inode,\r\nint ex)\r\n{\r\nint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\r\nstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\r\nstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\r\nmlog(0, "inode %llu drop %s META lock\n",\r\n(unsigned long long)OCFS2_I(inode)->ip_blkno,\r\nex ? "EXMODE" : "PRMODE");\r\nif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\r\n!ocfs2_mount_local(osb))\r\nocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\r\n}\r\nint ocfs2_orphan_scan_lock(struct ocfs2_super *osb, u32 *seqno)\r\n{\r\nstruct ocfs2_lock_res *lockres;\r\nstruct ocfs2_orphan_scan_lvb *lvb;\r\nint status = 0;\r\nif (ocfs2_is_hard_readonly(osb))\r\nreturn -EROFS;\r\nif (ocfs2_mount_local(osb))\r\nreturn 0;\r\nlockres = &osb->osb_orphan_scan.os_lockres;\r\nstatus = ocfs2_cluster_lock(osb, lockres, DLM_LOCK_EX, 0, 0);\r\nif (status < 0)\r\nreturn status;\r\nlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\r\nif (ocfs2_dlm_lvb_valid(&lockres->l_lksb) &&\r\nlvb->lvb_version == OCFS2_ORPHAN_LVB_VERSION)\r\n*seqno = be32_to_cpu(lvb->lvb_os_seqno);\r\nelse\r\n*seqno = osb->osb_orphan_scan.os_seqno + 1;\r\nreturn status;\r\n}\r\nvoid ocfs2_orphan_scan_unlock(struct ocfs2_super *osb, u32 seqno)\r\n{\r\nstruct ocfs2_lock_res *lockres;\r\nstruct ocfs2_orphan_scan_lvb *lvb;\r\nif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb)) {\r\nlockres = &osb->osb_orphan_scan.os_lockres;\r\nlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\r\nlvb->lvb_version = OCFS2_ORPHAN_LVB_VERSION;\r\nlvb->lvb_os_seqno = cpu_to_be32(seqno);\r\nocfs2_cluster_unlock(osb, lockres, DLM_LOCK_EX);\r\n}\r\n}\r\nint ocfs2_super_lock(struct ocfs2_super *osb,\r\nint ex)\r\n{\r\nint status = 0;\r\nint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\r\nstruct ocfs2_lock_res *lockres = &osb->osb_super_lockres;\r\nif (ocfs2_is_hard_readonly(osb))\r\nreturn -EROFS;\r\nif (ocfs2_mount_local(osb))\r\ngoto bail;\r\nstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nstatus = ocfs2_should_refresh_lock_res(lockres);\r\nif (status) {\r\nstatus = ocfs2_refresh_slot_info(osb);\r\nocfs2_complete_lock_res_refresh(lockres, status);\r\nif (status < 0) {\r\nocfs2_cluster_unlock(osb, lockres, level);\r\nmlog_errno(status);\r\n}\r\nocfs2_track_lock_refresh(lockres);\r\n}\r\nbail:\r\nreturn status;\r\n}\r\nvoid ocfs2_super_unlock(struct ocfs2_super *osb,\r\nint ex)\r\n{\r\nint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\r\nstruct ocfs2_lock_res *lockres = &osb->osb_super_lockres;\r\nif (!ocfs2_mount_local(osb))\r\nocfs2_cluster_unlock(osb, lockres, level);\r\n}\r\nint ocfs2_rename_lock(struct ocfs2_super *osb)\r\n{\r\nint status;\r\nstruct ocfs2_lock_res *lockres = &osb->osb_rename_lockres;\r\nif (ocfs2_is_hard_readonly(osb))\r\nreturn -EROFS;\r\nif (ocfs2_mount_local(osb))\r\nreturn 0;\r\nstatus = ocfs2_cluster_lock(osb, lockres, DLM_LOCK_EX, 0, 0);\r\nif (status < 0)\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nvoid ocfs2_rename_unlock(struct ocfs2_super *osb)\r\n{\r\nstruct ocfs2_lock_res *lockres = &osb->osb_rename_lockres;\r\nif (!ocfs2_mount_local(osb))\r\nocfs2_cluster_unlock(osb, lockres, DLM_LOCK_EX);\r\n}\r\nint ocfs2_nfs_sync_lock(struct ocfs2_super *osb, int ex)\r\n{\r\nint status;\r\nstruct ocfs2_lock_res *lockres = &osb->osb_nfs_sync_lockres;\r\nif (ocfs2_is_hard_readonly(osb))\r\nreturn -EROFS;\r\nif (ocfs2_mount_local(osb))\r\nreturn 0;\r\nstatus = ocfs2_cluster_lock(osb, lockres, ex ? LKM_EXMODE : LKM_PRMODE,\r\n0, 0);\r\nif (status < 0)\r\nmlog(ML_ERROR, "lock on nfs sync lock failed %d\n", status);\r\nreturn status;\r\n}\r\nvoid ocfs2_nfs_sync_unlock(struct ocfs2_super *osb, int ex)\r\n{\r\nstruct ocfs2_lock_res *lockres = &osb->osb_nfs_sync_lockres;\r\nif (!ocfs2_mount_local(osb))\r\nocfs2_cluster_unlock(osb, lockres,\r\nex ? LKM_EXMODE : LKM_PRMODE);\r\n}\r\nint ocfs2_dentry_lock(struct dentry *dentry, int ex)\r\n{\r\nint ret;\r\nint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\r\nstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\r\nstruct ocfs2_super *osb = OCFS2_SB(dentry->d_sb);\r\nBUG_ON(!dl);\r\nif (ocfs2_is_hard_readonly(osb)) {\r\nif (ex)\r\nreturn -EROFS;\r\nreturn 0;\r\n}\r\nif (ocfs2_mount_local(osb))\r\nreturn 0;\r\nret = ocfs2_cluster_lock(osb, &dl->dl_lockres, level, 0, 0);\r\nif (ret < 0)\r\nmlog_errno(ret);\r\nreturn ret;\r\n}\r\nvoid ocfs2_dentry_unlock(struct dentry *dentry, int ex)\r\n{\r\nint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\r\nstruct ocfs2_dentry_lock *dl = dentry->d_fsdata;\r\nstruct ocfs2_super *osb = OCFS2_SB(dentry->d_sb);\r\nif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\r\nocfs2_cluster_unlock(osb, &dl->dl_lockres, level);\r\n}\r\nstatic void ocfs2_dlm_debug_free(struct kref *kref)\r\n{\r\nstruct ocfs2_dlm_debug *dlm_debug;\r\ndlm_debug = container_of(kref, struct ocfs2_dlm_debug, d_refcnt);\r\nkfree(dlm_debug);\r\n}\r\nvoid ocfs2_put_dlm_debug(struct ocfs2_dlm_debug *dlm_debug)\r\n{\r\nif (dlm_debug)\r\nkref_put(&dlm_debug->d_refcnt, ocfs2_dlm_debug_free);\r\n}\r\nstatic void ocfs2_get_dlm_debug(struct ocfs2_dlm_debug *debug)\r\n{\r\nkref_get(&debug->d_refcnt);\r\n}\r\nstruct ocfs2_dlm_debug *ocfs2_new_dlm_debug(void)\r\n{\r\nstruct ocfs2_dlm_debug *dlm_debug;\r\ndlm_debug = kmalloc(sizeof(struct ocfs2_dlm_debug), GFP_KERNEL);\r\nif (!dlm_debug) {\r\nmlog_errno(-ENOMEM);\r\ngoto out;\r\n}\r\nkref_init(&dlm_debug->d_refcnt);\r\nINIT_LIST_HEAD(&dlm_debug->d_lockres_tracking);\r\ndlm_debug->d_locking_state = NULL;\r\nout:\r\nreturn dlm_debug;\r\n}\r\nstatic struct ocfs2_lock_res *ocfs2_dlm_next_res(struct ocfs2_lock_res *start,\r\nstruct ocfs2_dlm_seq_priv *priv)\r\n{\r\nstruct ocfs2_lock_res *iter, *ret = NULL;\r\nstruct ocfs2_dlm_debug *dlm_debug = priv->p_dlm_debug;\r\nassert_spin_locked(&ocfs2_dlm_tracking_lock);\r\nlist_for_each_entry(iter, &start->l_debug_list, l_debug_list) {\r\nif (&iter->l_debug_list == &dlm_debug->d_lockres_tracking) {\r\nmlog(0, "End of list found, %p\n", ret);\r\nbreak;\r\n}\r\nif (iter->l_ops != NULL) {\r\nret = iter;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void *ocfs2_dlm_seq_start(struct seq_file *m, loff_t *pos)\r\n{\r\nstruct ocfs2_dlm_seq_priv *priv = m->private;\r\nstruct ocfs2_lock_res *iter;\r\nspin_lock(&ocfs2_dlm_tracking_lock);\r\niter = ocfs2_dlm_next_res(&priv->p_iter_res, priv);\r\nif (iter) {\r\npriv->p_tmp_res = *iter;\r\niter = &priv->p_tmp_res;\r\n}\r\nspin_unlock(&ocfs2_dlm_tracking_lock);\r\nreturn iter;\r\n}\r\nstatic void ocfs2_dlm_seq_stop(struct seq_file *m, void *v)\r\n{\r\n}\r\nstatic void *ocfs2_dlm_seq_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\nstruct ocfs2_dlm_seq_priv *priv = m->private;\r\nstruct ocfs2_lock_res *iter = v;\r\nstruct ocfs2_lock_res *dummy = &priv->p_iter_res;\r\nspin_lock(&ocfs2_dlm_tracking_lock);\r\niter = ocfs2_dlm_next_res(iter, priv);\r\nlist_del_init(&dummy->l_debug_list);\r\nif (iter) {\r\nlist_add(&dummy->l_debug_list, &iter->l_debug_list);\r\npriv->p_tmp_res = *iter;\r\niter = &priv->p_tmp_res;\r\n}\r\nspin_unlock(&ocfs2_dlm_tracking_lock);\r\nreturn iter;\r\n}\r\nstatic int ocfs2_dlm_seq_show(struct seq_file *m, void *v)\r\n{\r\nint i;\r\nchar *lvb;\r\nstruct ocfs2_lock_res *lockres = v;\r\nif (!lockres)\r\nreturn -EINVAL;\r\nseq_printf(m, "0x%x\t", OCFS2_DLM_DEBUG_STR_VERSION);\r\nif (lockres->l_type == OCFS2_LOCK_TYPE_DENTRY)\r\nseq_printf(m, "%.*s%08x\t", OCFS2_DENTRY_LOCK_INO_START - 1,\r\nlockres->l_name,\r\n(unsigned int)ocfs2_get_dentry_lock_ino(lockres));\r\nelse\r\nseq_printf(m, "%.*s\t", OCFS2_LOCK_ID_MAX_LEN, lockres->l_name);\r\nseq_printf(m, "%d\t"\r\n"0x%lx\t"\r\n"0x%x\t"\r\n"0x%x\t"\r\n"%u\t"\r\n"%u\t"\r\n"%d\t"\r\n"%d\t",\r\nlockres->l_level,\r\nlockres->l_flags,\r\nlockres->l_action,\r\nlockres->l_unlock_action,\r\nlockres->l_ro_holders,\r\nlockres->l_ex_holders,\r\nlockres->l_requested,\r\nlockres->l_blocking);\r\nlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\r\nfor(i = 0; i < DLM_LVB_LEN; i++)\r\nseq_printf(m, "0x%x\t", lvb[i]);\r\n#ifdef CONFIG_OCFS2_FS_STATS\r\n# define lock_num_prmode(_l) ((_l)->l_lock_prmode.ls_gets)\r\n# define lock_num_exmode(_l) ((_l)->l_lock_exmode.ls_gets)\r\n# define lock_num_prmode_failed(_l) ((_l)->l_lock_prmode.ls_fail)\r\n# define lock_num_exmode_failed(_l) ((_l)->l_lock_exmode.ls_fail)\r\n# define lock_total_prmode(_l) ((_l)->l_lock_prmode.ls_total)\r\n# define lock_total_exmode(_l) ((_l)->l_lock_exmode.ls_total)\r\n# define lock_max_prmode(_l) ((_l)->l_lock_prmode.ls_max)\r\n# define lock_max_exmode(_l) ((_l)->l_lock_exmode.ls_max)\r\n# define lock_refresh(_l) ((_l)->l_lock_refresh)\r\n#else\r\n# define lock_num_prmode(_l) (0)\r\n# define lock_num_exmode(_l) (0)\r\n# define lock_num_prmode_failed(_l) (0)\r\n# define lock_num_exmode_failed(_l) (0)\r\n# define lock_total_prmode(_l) (0ULL)\r\n# define lock_total_exmode(_l) (0ULL)\r\n# define lock_max_prmode(_l) (0)\r\n# define lock_max_exmode(_l) (0)\r\n# define lock_refresh(_l) (0)\r\n#endif\r\nseq_printf(m, "%u\t"\r\n"%u\t"\r\n"%u\t"\r\n"%u\t"\r\n"%llu\t"\r\n"%llu\t"\r\n"%u\t"\r\n"%u\t"\r\n"%u\t",\r\nlock_num_prmode(lockres),\r\nlock_num_exmode(lockres),\r\nlock_num_prmode_failed(lockres),\r\nlock_num_exmode_failed(lockres),\r\nlock_total_prmode(lockres),\r\nlock_total_exmode(lockres),\r\nlock_max_prmode(lockres),\r\nlock_max_exmode(lockres),\r\nlock_refresh(lockres));\r\nseq_printf(m, "\n");\r\nreturn 0;\r\n}\r\nstatic int ocfs2_dlm_debug_release(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct ocfs2_dlm_seq_priv *priv = seq->private;\r\nstruct ocfs2_lock_res *res = &priv->p_iter_res;\r\nocfs2_remove_lockres_tracking(res);\r\nocfs2_put_dlm_debug(priv->p_dlm_debug);\r\nreturn seq_release_private(inode, file);\r\n}\r\nstatic int ocfs2_dlm_debug_open(struct inode *inode, struct file *file)\r\n{\r\nint ret;\r\nstruct ocfs2_dlm_seq_priv *priv;\r\nstruct seq_file *seq;\r\nstruct ocfs2_super *osb;\r\npriv = kzalloc(sizeof(struct ocfs2_dlm_seq_priv), GFP_KERNEL);\r\nif (!priv) {\r\nret = -ENOMEM;\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nosb = inode->i_private;\r\nocfs2_get_dlm_debug(osb->osb_dlm_debug);\r\npriv->p_dlm_debug = osb->osb_dlm_debug;\r\nINIT_LIST_HEAD(&priv->p_iter_res.l_debug_list);\r\nret = seq_open(file, &ocfs2_dlm_seq_ops);\r\nif (ret) {\r\nkfree(priv);\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nseq = file->private_data;\r\nseq->private = priv;\r\nocfs2_add_lockres_tracking(&priv->p_iter_res,\r\npriv->p_dlm_debug);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ocfs2_dlm_init_debug(struct ocfs2_super *osb)\r\n{\r\nint ret = 0;\r\nstruct ocfs2_dlm_debug *dlm_debug = osb->osb_dlm_debug;\r\ndlm_debug->d_locking_state = debugfs_create_file("locking_state",\r\nS_IFREG|S_IRUSR,\r\nosb->osb_debug_root,\r\nosb,\r\n&ocfs2_dlm_debug_fops);\r\nif (!dlm_debug->d_locking_state) {\r\nret = -EINVAL;\r\nmlog(ML_ERROR,\r\n"Unable to create locking state debugfs file.\n");\r\ngoto out;\r\n}\r\nocfs2_get_dlm_debug(dlm_debug);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void ocfs2_dlm_shutdown_debug(struct ocfs2_super *osb)\r\n{\r\nstruct ocfs2_dlm_debug *dlm_debug = osb->osb_dlm_debug;\r\nif (dlm_debug) {\r\ndebugfs_remove(dlm_debug->d_locking_state);\r\nocfs2_put_dlm_debug(dlm_debug);\r\n}\r\n}\r\nint ocfs2_dlm_init(struct ocfs2_super *osb)\r\n{\r\nint status = 0;\r\nstruct ocfs2_cluster_connection *conn = NULL;\r\nif (ocfs2_mount_local(osb)) {\r\nosb->node_num = 0;\r\ngoto local;\r\n}\r\nstatus = ocfs2_dlm_init_debug(osb);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nosb->dc_task = kthread_run(ocfs2_downconvert_thread, osb, "ocfs2dc");\r\nif (IS_ERR(osb->dc_task)) {\r\nstatus = PTR_ERR(osb->dc_task);\r\nosb->dc_task = NULL;\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nstatus = ocfs2_cluster_connect(osb->osb_cluster_stack,\r\nosb->osb_cluster_name,\r\nstrlen(osb->osb_cluster_name),\r\nosb->uuid_str,\r\nstrlen(osb->uuid_str),\r\n&lproto, ocfs2_do_node_down, osb,\r\n&conn);\r\nif (status) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nstatus = ocfs2_cluster_this_node(conn, &osb->node_num);\r\nif (status < 0) {\r\nmlog_errno(status);\r\nmlog(ML_ERROR,\r\n"could not find this host's node number\n");\r\nocfs2_cluster_disconnect(conn, 0);\r\ngoto bail;\r\n}\r\nlocal:\r\nocfs2_super_lock_res_init(&osb->osb_super_lockres, osb);\r\nocfs2_rename_lock_res_init(&osb->osb_rename_lockres, osb);\r\nocfs2_nfs_sync_lock_res_init(&osb->osb_nfs_sync_lockres, osb);\r\nocfs2_orphan_scan_lock_res_init(&osb->osb_orphan_scan.os_lockres, osb);\r\nosb->cconn = conn;\r\nstatus = 0;\r\nbail:\r\nif (status < 0) {\r\nocfs2_dlm_shutdown_debug(osb);\r\nif (osb->dc_task)\r\nkthread_stop(osb->dc_task);\r\n}\r\nreturn status;\r\n}\r\nvoid ocfs2_dlm_shutdown(struct ocfs2_super *osb,\r\nint hangup_pending)\r\n{\r\nocfs2_drop_osb_locks(osb);\r\nif (osb->dc_task) {\r\nkthread_stop(osb->dc_task);\r\nosb->dc_task = NULL;\r\n}\r\nocfs2_lock_res_free(&osb->osb_super_lockres);\r\nocfs2_lock_res_free(&osb->osb_rename_lockres);\r\nocfs2_lock_res_free(&osb->osb_nfs_sync_lockres);\r\nocfs2_lock_res_free(&osb->osb_orphan_scan.os_lockres);\r\nocfs2_cluster_disconnect(osb->cconn, hangup_pending);\r\nosb->cconn = NULL;\r\nocfs2_dlm_shutdown_debug(osb);\r\n}\r\nstatic int ocfs2_drop_lock(struct ocfs2_super *osb,\r\nstruct ocfs2_lock_res *lockres)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nu32 lkm_flags = 0;\r\nif (!(lockres->l_flags & OCFS2_LOCK_INITIALIZED))\r\ngoto out;\r\nif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB)\r\nlkm_flags |= DLM_LKF_VALBLK;\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nmlog_bug_on_msg(!(lockres->l_flags & OCFS2_LOCK_FREEING),\r\n"lockres %s, flags 0x%lx\n",\r\nlockres->l_name, lockres->l_flags);\r\nwhile (lockres->l_flags & OCFS2_LOCK_BUSY) {\r\nmlog(0, "waiting on busy lock \"%s\": flags = %lx, action = "\r\n"%u, unlock_action = %u\n",\r\nlockres->l_name, lockres->l_flags, lockres->l_action,\r\nlockres->l_unlock_action);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nocfs2_wait_on_busy_lock(lockres);\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\n}\r\nif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB) {\r\nif (lockres->l_flags & OCFS2_LOCK_ATTACHED &&\r\nlockres->l_level == DLM_LOCK_EX &&\r\n!(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH))\r\nlockres->l_ops->set_lvb(lockres);\r\n}\r\nif (lockres->l_flags & OCFS2_LOCK_BUSY)\r\nmlog(ML_ERROR, "destroying busy lock: \"%s\"\n",\r\nlockres->l_name);\r\nif (lockres->l_flags & OCFS2_LOCK_BLOCKED)\r\nmlog(0, "destroying blocked lock: \"%s\"\n", lockres->l_name);\r\nif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\ngoto out;\r\n}\r\nlockres_clear_flags(lockres, OCFS2_LOCK_ATTACHED);\r\nBUG_ON(lockres->l_action != OCFS2_AST_INVALID);\r\nlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\r\nlockres->l_unlock_action = OCFS2_UNLOCK_DROP_LOCK;\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nmlog(0, "lock %s\n", lockres->l_name);\r\nret = ocfs2_dlm_unlock(osb->cconn, &lockres->l_lksb, lkm_flags);\r\nif (ret) {\r\nocfs2_log_dlm_error("ocfs2_dlm_unlock", ret, lockres);\r\nmlog(ML_ERROR, "lockres flags: %lu\n", lockres->l_flags);\r\nocfs2_dlm_dump_lksb(&lockres->l_lksb);\r\nBUG();\r\n}\r\nmlog(0, "lock %s, successful return from ocfs2_dlm_unlock\n",\r\nlockres->l_name);\r\nocfs2_wait_on_busy_lock(lockres);\r\nout:\r\nreturn 0;\r\n}\r\nvoid ocfs2_mark_lockres_freeing(struct ocfs2_super *osb,\r\nstruct ocfs2_lock_res *lockres)\r\n{\r\nint status;\r\nstruct ocfs2_mask_waiter mw;\r\nunsigned long flags, flags2;\r\nocfs2_init_mask_waiter(&mw);\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nlockres->l_flags |= OCFS2_LOCK_FREEING;\r\nif (lockres->l_flags & OCFS2_LOCK_QUEUED && current == osb->dc_task) {\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nspin_lock_irqsave(&osb->dc_task_lock, flags2);\r\nlist_del_init(&lockres->l_blocked_list);\r\nosb->blocked_lock_count--;\r\nspin_unlock_irqrestore(&osb->dc_task_lock, flags2);\r\nWARN_ON_ONCE(lockres->l_ops->post_unlock);\r\nocfs2_process_blocked_lock(osb, lockres);\r\nreturn;\r\n}\r\nwhile (lockres->l_flags & OCFS2_LOCK_QUEUED) {\r\nlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_QUEUED, 0);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nmlog(0, "Waiting on lockres %s\n", lockres->l_name);\r\nstatus = ocfs2_wait_for_mask(&mw);\r\nif (status)\r\nmlog_errno(status);\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\n}\r\nvoid ocfs2_simple_drop_lockres(struct ocfs2_super *osb,\r\nstruct ocfs2_lock_res *lockres)\r\n{\r\nint ret;\r\nocfs2_mark_lockres_freeing(osb, lockres);\r\nret = ocfs2_drop_lock(osb, lockres);\r\nif (ret)\r\nmlog_errno(ret);\r\n}\r\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb)\r\n{\r\nocfs2_simple_drop_lockres(osb, &osb->osb_super_lockres);\r\nocfs2_simple_drop_lockres(osb, &osb->osb_rename_lockres);\r\nocfs2_simple_drop_lockres(osb, &osb->osb_nfs_sync_lockres);\r\nocfs2_simple_drop_lockres(osb, &osb->osb_orphan_scan.os_lockres);\r\n}\r\nint ocfs2_drop_inode_locks(struct inode *inode)\r\n{\r\nint status, err;\r\nerr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\r\n&OCFS2_I(inode)->ip_open_lockres);\r\nif (err < 0)\r\nmlog_errno(err);\r\nstatus = err;\r\nerr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\r\n&OCFS2_I(inode)->ip_inode_lockres);\r\nif (err < 0)\r\nmlog_errno(err);\r\nif (err < 0 && !status)\r\nstatus = err;\r\nerr = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),\r\n&OCFS2_I(inode)->ip_rw_lockres);\r\nif (err < 0)\r\nmlog_errno(err);\r\nif (err < 0 && !status)\r\nstatus = err;\r\nreturn status;\r\n}\r\nstatic unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,\r\nint new_level)\r\n{\r\nassert_spin_locked(&lockres->l_lock);\r\nBUG_ON(lockres->l_blocking <= DLM_LOCK_NL);\r\nif (lockres->l_level <= new_level) {\r\nmlog(ML_ERROR, "lockres %s, lvl %d <= %d, blcklst %d, mask %d, "\r\n"type %d, flags 0x%lx, hold %d %d, act %d %d, req %d, "\r\n"block %d, pgen %d\n", lockres->l_name, lockres->l_level,\r\nnew_level, list_empty(&lockres->l_blocked_list),\r\nlist_empty(&lockres->l_mask_waiters), lockres->l_type,\r\nlockres->l_flags, lockres->l_ro_holders,\r\nlockres->l_ex_holders, lockres->l_action,\r\nlockres->l_unlock_action, lockres->l_requested,\r\nlockres->l_blocking, lockres->l_pending_gen);\r\nBUG();\r\n}\r\nmlog(ML_BASTS, "lockres %s, level %d => %d, blocking %d\n",\r\nlockres->l_name, lockres->l_level, new_level, lockres->l_blocking);\r\nlockres->l_action = OCFS2_AST_DOWNCONVERT;\r\nlockres->l_requested = new_level;\r\nlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\r\nreturn lockres_set_pending(lockres);\r\n}\r\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\r\nstruct ocfs2_lock_res *lockres,\r\nint new_level,\r\nint lvb,\r\nunsigned int generation)\r\n{\r\nint ret;\r\nu32 dlm_flags = DLM_LKF_CONVERT;\r\nmlog(ML_BASTS, "lockres %s, level %d => %d\n", lockres->l_name,\r\nlockres->l_level, new_level);\r\nif (lvb)\r\ndlm_flags |= DLM_LKF_VALBLK;\r\nret = ocfs2_dlm_lock(osb->cconn,\r\nnew_level,\r\n&lockres->l_lksb,\r\ndlm_flags,\r\nlockres->l_name,\r\nOCFS2_LOCK_ID_MAX_LEN - 1);\r\nlockres_clear_pending(lockres, generation, osb);\r\nif (ret) {\r\nocfs2_log_dlm_error("ocfs2_dlm_lock", ret, lockres);\r\nocfs2_recover_from_dlm_error(lockres, 1);\r\ngoto bail;\r\n}\r\nret = 0;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\r\nstruct ocfs2_lock_res *lockres)\r\n{\r\nassert_spin_locked(&lockres->l_lock);\r\nif (lockres->l_unlock_action == OCFS2_UNLOCK_CANCEL_CONVERT) {\r\nmlog(ML_BASTS, "lockres %s, skip convert\n", lockres->l_name);\r\nreturn 0;\r\n}\r\nBUG_ON(lockres->l_action != OCFS2_AST_CONVERT &&\r\nlockres->l_action != OCFS2_AST_DOWNCONVERT);\r\nlockres->l_unlock_action = OCFS2_UNLOCK_CANCEL_CONVERT;\r\nmlog_bug_on_msg(!(lockres->l_flags & OCFS2_LOCK_BUSY),\r\n"lock %s, invalid flags: 0x%lx\n",\r\nlockres->l_name, lockres->l_flags);\r\nmlog(ML_BASTS, "lockres %s\n", lockres->l_name);\r\nreturn 1;\r\n}\r\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\r\nstruct ocfs2_lock_res *lockres)\r\n{\r\nint ret;\r\nret = ocfs2_dlm_unlock(osb->cconn, &lockres->l_lksb,\r\nDLM_LKF_CANCEL);\r\nif (ret) {\r\nocfs2_log_dlm_error("ocfs2_dlm_unlock", ret, lockres);\r\nocfs2_recover_from_dlm_error(lockres, 0);\r\n}\r\nmlog(ML_BASTS, "lockres %s\n", lockres->l_name);\r\nreturn ret;\r\n}\r\nstatic int ocfs2_unblock_lock(struct ocfs2_super *osb,\r\nstruct ocfs2_lock_res *lockres,\r\nstruct ocfs2_unblock_ctl *ctl)\r\n{\r\nunsigned long flags;\r\nint blocking;\r\nint new_level;\r\nint level;\r\nint ret = 0;\r\nint set_lvb = 0;\r\nunsigned int gen;\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nrecheck:\r\nif (!(lockres->l_flags & OCFS2_LOCK_BLOCKED)) {\r\nBUG_ON(lockres->l_blocking != DLM_LOCK_NL);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nret = 0;\r\ngoto leave;\r\n}\r\nif (lockres->l_flags & OCFS2_LOCK_BUSY) {\r\nif (lockres->l_flags & OCFS2_LOCK_PENDING) {\r\nmlog(ML_BASTS, "lockres %s, ReQ: Pending\n",\r\nlockres->l_name);\r\ngoto leave_requeue;\r\n}\r\nctl->requeue = 1;\r\nret = ocfs2_prepare_cancel_convert(osb, lockres);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nif (ret) {\r\nret = ocfs2_cancel_convert(osb, lockres);\r\nif (ret < 0)\r\nmlog_errno(ret);\r\n}\r\ngoto leave;\r\n}\r\nif (lockres->l_flags & OCFS2_LOCK_UPCONVERT_FINISHING)\r\ngoto leave_requeue;\r\nif (lockres->l_level == DLM_LOCK_NL) {\r\nBUG_ON(lockres->l_ex_holders || lockres->l_ro_holders);\r\nmlog(ML_BASTS, "lockres %s, Aborting dc\n", lockres->l_name);\r\nlockres->l_blocking = DLM_LOCK_NL;\r\nlockres_clear_flags(lockres, OCFS2_LOCK_BLOCKED);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\ngoto leave;\r\n}\r\nif ((lockres->l_blocking == DLM_LOCK_EX)\r\n&& (lockres->l_ex_holders || lockres->l_ro_holders)) {\r\nmlog(ML_BASTS, "lockres %s, ReQ: EX/PR Holders %u,%u\n",\r\nlockres->l_name, lockres->l_ex_holders,\r\nlockres->l_ro_holders);\r\ngoto leave_requeue;\r\n}\r\nif (lockres->l_blocking == DLM_LOCK_PR &&\r\nlockres->l_ex_holders) {\r\nmlog(ML_BASTS, "lockres %s, ReQ: EX Holders %u\n",\r\nlockres->l_name, lockres->l_ex_holders);\r\ngoto leave_requeue;\r\n}\r\nif ((lockres->l_ops->flags & LOCK_TYPE_REQUIRES_REFRESH)\r\n&& (lockres->l_flags & OCFS2_LOCK_REFRESHING)) {\r\nmlog(ML_BASTS, "lockres %s, ReQ: Lock Refreshing\n",\r\nlockres->l_name);\r\ngoto leave_requeue;\r\n}\r\nnew_level = ocfs2_highest_compat_lock_level(lockres->l_blocking);\r\nif (lockres->l_ops->check_downconvert\r\n&& !lockres->l_ops->check_downconvert(lockres, new_level)) {\r\nmlog(ML_BASTS, "lockres %s, ReQ: Checkpointing\n",\r\nlockres->l_name);\r\ngoto leave_requeue;\r\n}\r\nif (!lockres->l_ops->downconvert_worker)\r\ngoto downconvert;\r\nblocking = lockres->l_blocking;\r\nlevel = lockres->l_level;\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nctl->unblock_action = lockres->l_ops->downconvert_worker(lockres, blocking);\r\nif (ctl->unblock_action == UNBLOCK_STOP_POST) {\r\nmlog(ML_BASTS, "lockres %s, UNBLOCK_STOP_POST\n",\r\nlockres->l_name);\r\ngoto leave;\r\n}\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nif ((blocking != lockres->l_blocking) || (level != lockres->l_level)) {\r\nmlog(ML_BASTS, "lockres %s, block=%d:%d, level=%d:%d, "\r\n"Recheck\n", lockres->l_name, blocking,\r\nlockres->l_blocking, level, lockres->l_level);\r\ngoto recheck;\r\n}\r\ndownconvert:\r\nctl->requeue = 0;\r\nif (lockres->l_ops->flags & LOCK_TYPE_USES_LVB) {\r\nif (lockres->l_level == DLM_LOCK_EX)\r\nset_lvb = 1;\r\nif (set_lvb && !(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH))\r\nlockres->l_ops->set_lvb(lockres);\r\n}\r\ngen = ocfs2_prepare_downconvert(lockres, new_level);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nret = ocfs2_downconvert_lock(osb, lockres, new_level, set_lvb,\r\ngen);\r\nleave:\r\nif (ret)\r\nmlog_errno(ret);\r\nreturn ret;\r\nleave_requeue:\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nctl->requeue = 1;\r\nreturn 0;\r\n}\r\nstatic int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\r\nint blocking)\r\n{\r\nstruct inode *inode;\r\nstruct address_space *mapping;\r\nstruct ocfs2_inode_info *oi;\r\ninode = ocfs2_lock_res_inode(lockres);\r\nmapping = inode->i_mapping;\r\nif (S_ISDIR(inode->i_mode)) {\r\noi = OCFS2_I(inode);\r\noi->ip_dir_lock_gen++;\r\nmlog(0, "generation: %u\n", oi->ip_dir_lock_gen);\r\ngoto out;\r\n}\r\nif (!S_ISREG(inode->i_mode))\r\ngoto out;\r\nunmap_mapping_range(mapping, 0, 0, 0);\r\nif (filemap_fdatawrite(mapping)) {\r\nmlog(ML_ERROR, "Could not sync inode %llu for downconvert!",\r\n(unsigned long long)OCFS2_I(inode)->ip_blkno);\r\n}\r\nsync_mapping_buffers(mapping);\r\nif (blocking == DLM_LOCK_EX) {\r\ntruncate_inode_pages(mapping, 0);\r\n} else {\r\nfilemap_fdatawait(mapping);\r\n}\r\nout:\r\nreturn UNBLOCK_CONTINUE;\r\n}\r\nstatic int ocfs2_ci_checkpointed(struct ocfs2_caching_info *ci,\r\nstruct ocfs2_lock_res *lockres,\r\nint new_level)\r\n{\r\nint checkpointed = ocfs2_ci_fully_checkpointed(ci);\r\nBUG_ON(new_level != DLM_LOCK_NL && new_level != DLM_LOCK_PR);\r\nBUG_ON(lockres->l_level != DLM_LOCK_EX && !checkpointed);\r\nif (checkpointed)\r\nreturn 1;\r\nocfs2_start_checkpoint(OCFS2_SB(ocfs2_metadata_cache_get_super(ci)));\r\nreturn 0;\r\n}\r\nstatic int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,\r\nint new_level)\r\n{\r\nstruct inode *inode = ocfs2_lock_res_inode(lockres);\r\nreturn ocfs2_ci_checkpointed(INODE_CACHE(inode), lockres, new_level);\r\n}\r\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres)\r\n{\r\nstruct inode *inode = ocfs2_lock_res_inode(lockres);\r\n__ocfs2_stuff_meta_lvb(inode);\r\n}\r\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\r\nstruct ocfs2_lock_res *lockres)\r\n{\r\nstruct ocfs2_dentry_lock *dl = ocfs2_lock_res_dl(lockres);\r\nocfs2_dentry_lock_put(osb, dl);\r\n}\r\nstatic int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\r\nint blocking)\r\n{\r\nstruct ocfs2_dentry_lock *dl = ocfs2_lock_res_dl(lockres);\r\nstruct ocfs2_inode_info *oi = OCFS2_I(dl->dl_inode);\r\nstruct dentry *dentry;\r\nunsigned long flags;\r\nint extra_ref = 0;\r\nif (blocking == DLM_LOCK_PR)\r\nreturn UNBLOCK_CONTINUE;\r\nspin_lock(&oi->ip_lock);\r\noi->ip_flags |= OCFS2_INODE_MAYBE_ORPHANED;\r\nspin_unlock(&oi->ip_lock);\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nspin_lock(&dentry_attach_lock);\r\nif (!(lockres->l_flags & OCFS2_LOCK_FREEING)\r\n&& dl->dl_count) {\r\ndl->dl_count++;\r\nextra_ref = 1;\r\n}\r\nspin_unlock(&dentry_attach_lock);\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nmlog(0, "extra_ref = %d\n", extra_ref);\r\nif (!extra_ref)\r\nreturn UNBLOCK_CONTINUE;\r\nspin_lock(&dentry_attach_lock);\r\nwhile (1) {\r\ndentry = ocfs2_find_local_alias(dl->dl_inode,\r\ndl->dl_parent_blkno, 1);\r\nif (!dentry)\r\nbreak;\r\nspin_unlock(&dentry_attach_lock);\r\nmlog(0, "d_delete(%.*s);\n", dentry->d_name.len,\r\ndentry->d_name.name);\r\nd_delete(dentry);\r\ndput(dentry);\r\nspin_lock(&dentry_attach_lock);\r\n}\r\nspin_unlock(&dentry_attach_lock);\r\nif (dl->dl_count == 1)\r\nreturn UNBLOCK_STOP_POST;\r\nreturn UNBLOCK_CONTINUE_POST;\r\n}\r\nstatic int ocfs2_check_refcount_downconvert(struct ocfs2_lock_res *lockres,\r\nint new_level)\r\n{\r\nstruct ocfs2_refcount_tree *tree =\r\nocfs2_lock_res_refcount_tree(lockres);\r\nreturn ocfs2_ci_checkpointed(&tree->rf_ci, lockres, new_level);\r\n}\r\nstatic int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\r\nint blocking)\r\n{\r\nstruct ocfs2_refcount_tree *tree =\r\nocfs2_lock_res_refcount_tree(lockres);\r\nocfs2_metadata_cache_purge(&tree->rf_ci);\r\nreturn UNBLOCK_CONTINUE;\r\n}\r\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres)\r\n{\r\nstruct ocfs2_qinfo_lvb *lvb;\r\nstruct ocfs2_mem_dqinfo *oinfo = ocfs2_lock_res_qinfo(lockres);\r\nstruct mem_dqinfo *info = sb_dqinfo(oinfo->dqi_gi.dqi_sb,\r\noinfo->dqi_gi.dqi_type);\r\nlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\r\nlvb->lvb_version = OCFS2_QINFO_LVB_VERSION;\r\nlvb->lvb_bgrace = cpu_to_be32(info->dqi_bgrace);\r\nlvb->lvb_igrace = cpu_to_be32(info->dqi_igrace);\r\nlvb->lvb_syncms = cpu_to_be32(oinfo->dqi_syncms);\r\nlvb->lvb_blocks = cpu_to_be32(oinfo->dqi_gi.dqi_blocks);\r\nlvb->lvb_free_blk = cpu_to_be32(oinfo->dqi_gi.dqi_free_blk);\r\nlvb->lvb_free_entry = cpu_to_be32(oinfo->dqi_gi.dqi_free_entry);\r\n}\r\nvoid ocfs2_qinfo_unlock(struct ocfs2_mem_dqinfo *oinfo, int ex)\r\n{\r\nstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\r\nstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\r\nint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\r\nif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))\r\nocfs2_cluster_unlock(osb, lockres, level);\r\n}\r\nstatic int ocfs2_refresh_qinfo(struct ocfs2_mem_dqinfo *oinfo)\r\n{\r\nstruct mem_dqinfo *info = sb_dqinfo(oinfo->dqi_gi.dqi_sb,\r\noinfo->dqi_gi.dqi_type);\r\nstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\r\nstruct ocfs2_qinfo_lvb *lvb = ocfs2_dlm_lvb(&lockres->l_lksb);\r\nstruct buffer_head *bh = NULL;\r\nstruct ocfs2_global_disk_dqinfo *gdinfo;\r\nint status = 0;\r\nif (ocfs2_dlm_lvb_valid(&lockres->l_lksb) &&\r\nlvb->lvb_version == OCFS2_QINFO_LVB_VERSION) {\r\ninfo->dqi_bgrace = be32_to_cpu(lvb->lvb_bgrace);\r\ninfo->dqi_igrace = be32_to_cpu(lvb->lvb_igrace);\r\noinfo->dqi_syncms = be32_to_cpu(lvb->lvb_syncms);\r\noinfo->dqi_gi.dqi_blocks = be32_to_cpu(lvb->lvb_blocks);\r\noinfo->dqi_gi.dqi_free_blk = be32_to_cpu(lvb->lvb_free_blk);\r\noinfo->dqi_gi.dqi_free_entry =\r\nbe32_to_cpu(lvb->lvb_free_entry);\r\n} else {\r\nstatus = ocfs2_read_quota_phys_block(oinfo->dqi_gqinode,\r\noinfo->dqi_giblk, &bh);\r\nif (status) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\ngdinfo = (struct ocfs2_global_disk_dqinfo *)\r\n(bh->b_data + OCFS2_GLOBAL_INFO_OFF);\r\ninfo->dqi_bgrace = le32_to_cpu(gdinfo->dqi_bgrace);\r\ninfo->dqi_igrace = le32_to_cpu(gdinfo->dqi_igrace);\r\noinfo->dqi_syncms = le32_to_cpu(gdinfo->dqi_syncms);\r\noinfo->dqi_gi.dqi_blocks = le32_to_cpu(gdinfo->dqi_blocks);\r\noinfo->dqi_gi.dqi_free_blk = le32_to_cpu(gdinfo->dqi_free_blk);\r\noinfo->dqi_gi.dqi_free_entry =\r\nle32_to_cpu(gdinfo->dqi_free_entry);\r\nbrelse(bh);\r\nocfs2_track_lock_refresh(lockres);\r\n}\r\nbail:\r\nreturn status;\r\n}\r\nint ocfs2_qinfo_lock(struct ocfs2_mem_dqinfo *oinfo, int ex)\r\n{\r\nstruct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;\r\nstruct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);\r\nint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\r\nint status = 0;\r\nif (ocfs2_is_hard_readonly(osb)) {\r\nif (ex)\r\nstatus = -EROFS;\r\ngoto bail;\r\n}\r\nif (ocfs2_mount_local(osb))\r\ngoto bail;\r\nstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\r\nif (status < 0) {\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nif (!ocfs2_should_refresh_lock_res(lockres))\r\ngoto bail;\r\nstatus = ocfs2_refresh_qinfo(oinfo);\r\nif (status)\r\nocfs2_qinfo_unlock(oinfo, ex);\r\nocfs2_complete_lock_res_refresh(lockres, status);\r\nbail:\r\nreturn status;\r\n}\r\nint ocfs2_refcount_lock(struct ocfs2_refcount_tree *ref_tree, int ex)\r\n{\r\nint status;\r\nint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\r\nstruct ocfs2_lock_res *lockres = &ref_tree->rf_lockres;\r\nstruct ocfs2_super *osb = lockres->l_priv;\r\nif (ocfs2_is_hard_readonly(osb))\r\nreturn -EROFS;\r\nif (ocfs2_mount_local(osb))\r\nreturn 0;\r\nstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\r\nif (status < 0)\r\nmlog_errno(status);\r\nreturn status;\r\n}\r\nvoid ocfs2_refcount_unlock(struct ocfs2_refcount_tree *ref_tree, int ex)\r\n{\r\nint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\r\nstruct ocfs2_lock_res *lockres = &ref_tree->rf_lockres;\r\nstruct ocfs2_super *osb = lockres->l_priv;\r\nif (!ocfs2_mount_local(osb))\r\nocfs2_cluster_unlock(osb, lockres, level);\r\n}\r\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\r\nstruct ocfs2_lock_res *lockres)\r\n{\r\nint status;\r\nstruct ocfs2_unblock_ctl ctl = {0, 0,};\r\nunsigned long flags;\r\nBUG_ON(!lockres);\r\nBUG_ON(!lockres->l_ops);\r\nmlog(ML_BASTS, "lockres %s blocked\n", lockres->l_name);\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nif (lockres->l_flags & OCFS2_LOCK_FREEING)\r\ngoto unqueue;\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nstatus = ocfs2_unblock_lock(osb, lockres, &ctl);\r\nif (status < 0)\r\nmlog_errno(status);\r\nspin_lock_irqsave(&lockres->l_lock, flags);\r\nunqueue:\r\nif (lockres->l_flags & OCFS2_LOCK_FREEING || !ctl.requeue) {\r\nlockres_clear_flags(lockres, OCFS2_LOCK_QUEUED);\r\n} else\r\nocfs2_schedule_blocked_lock(osb, lockres);\r\nmlog(ML_BASTS, "lockres %s, requeue = %s.\n", lockres->l_name,\r\nctl.requeue ? "yes" : "no");\r\nspin_unlock_irqrestore(&lockres->l_lock, flags);\r\nif (ctl.unblock_action != UNBLOCK_CONTINUE\r\n&& lockres->l_ops->post_unlock)\r\nlockres->l_ops->post_unlock(osb, lockres);\r\n}\r\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\r\nstruct ocfs2_lock_res *lockres)\r\n{\r\nunsigned long flags;\r\nassert_spin_locked(&lockres->l_lock);\r\nif (lockres->l_flags & OCFS2_LOCK_FREEING) {\r\nmlog(ML_BASTS, "lockres %s won't be scheduled: flags 0x%lx\n",\r\nlockres->l_name, lockres->l_flags);\r\nreturn;\r\n}\r\nlockres_or_flags(lockres, OCFS2_LOCK_QUEUED);\r\nspin_lock_irqsave(&osb->dc_task_lock, flags);\r\nif (list_empty(&lockres->l_blocked_list)) {\r\nlist_add_tail(&lockres->l_blocked_list,\r\n&osb->blocked_lock_list);\r\nosb->blocked_lock_count++;\r\n}\r\nspin_unlock_irqrestore(&osb->dc_task_lock, flags);\r\n}\r\nstatic void ocfs2_downconvert_thread_do_work(struct ocfs2_super *osb)\r\n{\r\nunsigned long processed;\r\nunsigned long flags;\r\nstruct ocfs2_lock_res *lockres;\r\nspin_lock_irqsave(&osb->dc_task_lock, flags);\r\nosb->dc_work_sequence = osb->dc_wake_sequence;\r\nprocessed = osb->blocked_lock_count;\r\nwhile (processed) {\r\nBUG_ON(list_empty(&osb->blocked_lock_list));\r\nlockres = list_entry(osb->blocked_lock_list.next,\r\nstruct ocfs2_lock_res, l_blocked_list);\r\nlist_del_init(&lockres->l_blocked_list);\r\nosb->blocked_lock_count--;\r\nspin_unlock_irqrestore(&osb->dc_task_lock, flags);\r\nBUG_ON(!processed);\r\nprocessed--;\r\nocfs2_process_blocked_lock(osb, lockres);\r\nspin_lock_irqsave(&osb->dc_task_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&osb->dc_task_lock, flags);\r\n}\r\nstatic int ocfs2_downconvert_thread_lists_empty(struct ocfs2_super *osb)\r\n{\r\nint empty = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&osb->dc_task_lock, flags);\r\nif (list_empty(&osb->blocked_lock_list))\r\nempty = 1;\r\nspin_unlock_irqrestore(&osb->dc_task_lock, flags);\r\nreturn empty;\r\n}\r\nstatic int ocfs2_downconvert_thread_should_wake(struct ocfs2_super *osb)\r\n{\r\nint should_wake = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&osb->dc_task_lock, flags);\r\nif (osb->dc_work_sequence != osb->dc_wake_sequence)\r\nshould_wake = 1;\r\nspin_unlock_irqrestore(&osb->dc_task_lock, flags);\r\nreturn should_wake;\r\n}\r\nstatic int ocfs2_downconvert_thread(void *arg)\r\n{\r\nint status = 0;\r\nstruct ocfs2_super *osb = arg;\r\nwhile (!(kthread_should_stop() &&\r\nocfs2_downconvert_thread_lists_empty(osb))) {\r\nwait_event_interruptible(osb->dc_event,\r\nocfs2_downconvert_thread_should_wake(osb) ||\r\nkthread_should_stop());\r\nmlog(0, "downconvert_thread: awoken\n");\r\nocfs2_downconvert_thread_do_work(osb);\r\n}\r\nosb->dc_task = NULL;\r\nreturn status;\r\n}\r\nvoid ocfs2_wake_downconvert_thread(struct ocfs2_super *osb)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&osb->dc_task_lock, flags);\r\nosb->dc_wake_sequence++;\r\nspin_unlock_irqrestore(&osb->dc_task_lock, flags);\r\nwake_up(&osb->dc_event);\r\n}
