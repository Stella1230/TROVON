static inline void vpif_wr_bit(u32 reg, u32 bit, u32 val)\r\n{\r\nif (val)\r\nvpif_set_bit(reg, bit);\r\nelse\r\nvpif_clr_bit(reg, bit);\r\n}\r\nstatic void vpif_set_mode_info(const struct vpif_channel_config_params *config,\r\nu8 channel_id, u8 config_channel_id)\r\n{\r\nu32 value;\r\nvalue = (config->eav2sav & vpifregs[config_channel_id].width_mask);\r\nvalue <<= VPIF_CH_LEN_SHIFT;\r\nvalue |= (config->sav2eav & vpifregs[config_channel_id].width_mask);\r\nregw(value, vpifregs[channel_id].h_cfg);\r\nvalue = (config->l1 & vpifregs[config_channel_id].len_mask);\r\nvalue <<= VPIF_CH_LEN_SHIFT;\r\nvalue |= (config->l3 & vpifregs[config_channel_id].len_mask);\r\nregw(value, vpifregs[channel_id].v_cfg_00);\r\nvalue = (config->l5 & vpifregs[config_channel_id].len_mask);\r\nvalue <<= VPIF_CH_LEN_SHIFT;\r\nvalue |= (config->l7 & vpifregs[config_channel_id].len_mask);\r\nregw(value, vpifregs[channel_id].v_cfg_01);\r\nvalue = (config->l9 & vpifregs[config_channel_id].len_mask);\r\nvalue <<= VPIF_CH_LEN_SHIFT;\r\nvalue |= (config->l11 & vpifregs[config_channel_id].len_mask);\r\nregw(value, vpifregs[channel_id].v_cfg_02);\r\nvalue = (config->vsize & vpifregs[config_channel_id].len_mask);\r\nregw(value, vpifregs[channel_id].v_cfg);\r\n}\r\nstatic void config_vpif_params(struct vpif_params *vpifparams,\r\nu8 channel_id, u8 found)\r\n{\r\nconst struct vpif_channel_config_params *config = &vpifparams->std_info;\r\nu32 value, ch_nip, reg;\r\nu8 start, end;\r\nint i;\r\nstart = channel_id;\r\nend = channel_id + found;\r\nfor (i = start; i < end; i++) {\r\nreg = vpifregs[i].ch_ctrl;\r\nif (channel_id < 2)\r\nch_nip = VPIF_CAPTURE_CH_NIP;\r\nelse\r\nch_nip = VPIF_DISPLAY_CH_NIP;\r\nvpif_wr_bit(reg, ch_nip, config->frm_fmt);\r\nvpif_wr_bit(reg, VPIF_CH_YC_MUX_BIT, config->ycmux_mode);\r\nvpif_wr_bit(reg, VPIF_CH_INPUT_FIELD_FRAME_BIT,\r\nvpifparams->video_params.storage_mode);\r\nvpif_clr_bit(reg, VPIF_CH_SDR_FMT_BIT);\r\nvpif_wr_bit(reg, VPIF_CH_DATA_MODE_BIT, config->capture_format);\r\nif (channel_id > 1)\r\nvpif_set_bit(reg, VPIF_DISPLAY_PIX_EN_BIT);\r\nelse if (config->capture_format) {\r\nvpif_wr_bit(reg, VPIF_CH_FID_POLARITY_BIT,\r\nvpifparams->iface.fid_pol);\r\nvpif_wr_bit(reg, VPIF_CH_V_VALID_POLARITY_BIT,\r\nvpifparams->iface.vd_pol);\r\nvpif_wr_bit(reg, VPIF_CH_H_VALID_POLARITY_BIT,\r\nvpifparams->iface.hd_pol);\r\nvalue = regr(reg);\r\nvalue &= ~(0x3u <<\r\nVPIF_CH_DATA_WIDTH_BIT);\r\nvalue |= ((vpifparams->params.data_sz) <<\r\nVPIF_CH_DATA_WIDTH_BIT);\r\nregw(value, reg);\r\n}\r\nregw((vpifparams->video_params.hpitch),\r\nvpifregs[i].line_offset);\r\n}\r\n}\r\nint vpif_set_video_params(struct vpif_params *vpifparams, u8 channel_id)\r\n{\r\nconst struct vpif_channel_config_params *config = &vpifparams->std_info;\r\nint found = 1;\r\nvpif_set_mode_info(config, channel_id, channel_id);\r\nif (!config->ycmux_mode) {\r\nvpif_set_mode_info(config, channel_id + 1, channel_id);\r\nfound = 2;\r\n}\r\nconfig_vpif_params(vpifparams, channel_id, found);\r\nregw(0x80, VPIF_REQ_SIZE);\r\nregw(0x01, VPIF_EMULATION_CTRL);\r\nreturn found;\r\n}\r\nvoid vpif_set_vbi_display_params(struct vpif_vbi_params *vbiparams,\r\nu8 channel_id)\r\n{\r\nu32 value;\r\nvalue = 0x3F8 & (vbiparams->hstart0);\r\nvalue |= 0x3FFFFFF & ((vbiparams->vstart0) << 16);\r\nregw(value, vpifregs[channel_id].vanc0_strt);\r\nvalue = 0x3F8 & (vbiparams->hstart1);\r\nvalue |= 0x3FFFFFF & ((vbiparams->vstart1) << 16);\r\nregw(value, vpifregs[channel_id].vanc1_strt);\r\nvalue = 0x3F8 & (vbiparams->hsize0);\r\nvalue |= 0x3FFFFFF & ((vbiparams->vsize0) << 16);\r\nregw(value, vpifregs[channel_id].vanc0_size);\r\nvalue = 0x3F8 & (vbiparams->hsize1);\r\nvalue |= 0x3FFFFFF & ((vbiparams->vsize1) << 16);\r\nregw(value, vpifregs[channel_id].vanc1_size);\r\n}\r\nint vpif_channel_getfid(u8 channel_id)\r\n{\r\nreturn (regr(vpifregs[channel_id].ch_ctrl) & VPIF_CH_FID_MASK)\r\n>> VPIF_CH_FID_SHIFT;\r\n}\r\nstatic int vpif_probe(struct platform_device *pdev)\r\n{\r\nstatic struct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nvpif_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(vpif_base))\r\nreturn PTR_ERR(vpif_base);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get(&pdev->dev);\r\nspin_lock_init(&vpif_lock);\r\ndev_info(&pdev->dev, "vpif probe success\n");\r\nreturn 0;\r\n}\r\nstatic int vpif_remove(struct platform_device *pdev)\r\n{\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int vpif_suspend(struct device *dev)\r\n{\r\npm_runtime_put(dev);\r\nreturn 0;\r\n}\r\nstatic int vpif_resume(struct device *dev)\r\n{\r\npm_runtime_get(dev);\r\nreturn 0;\r\n}\r\nstatic void vpif_exit(void)\r\n{\r\nplatform_driver_unregister(&vpif_driver);\r\n}\r\nstatic int __init vpif_init(void)\r\n{\r\nreturn platform_driver_register(&vpif_driver);\r\n}
