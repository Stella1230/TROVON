int __init kmemcheck_init(void)\r\n{\r\n#ifdef CONFIG_SMP\r\nif (setup_max_cpus > 1) {\r\nprintk(KERN_INFO\r\n"kmemcheck: Limiting number of CPUs to 1.\n");\r\nsetup_max_cpus = 1;\r\n}\r\n#endif\r\nif (!kmemcheck_selftest()) {\r\nprintk(KERN_INFO "kmemcheck: self-tests failed; disabling\n");\r\nkmemcheck_enabled = 0;\r\nreturn -EINVAL;\r\n}\r\nprintk(KERN_INFO "kmemcheck: Initialized\n");\r\nreturn 0;\r\n}\r\nstatic int __init param_kmemcheck(char *str)\r\n{\r\nint val;\r\nint ret;\r\nif (!str)\r\nreturn -EINVAL;\r\nret = kstrtoint(str, 0, &val);\r\nif (ret)\r\nreturn ret;\r\nkmemcheck_enabled = val;\r\nreturn 0;\r\n}\r\nint kmemcheck_show_addr(unsigned long address)\r\n{\r\npte_t *pte;\r\npte = kmemcheck_pte_lookup(address);\r\nif (!pte)\r\nreturn 0;\r\nset_pte(pte, __pte(pte_val(*pte) | _PAGE_PRESENT));\r\n__flush_tlb_one(address);\r\nreturn 1;\r\n}\r\nint kmemcheck_hide_addr(unsigned long address)\r\n{\r\npte_t *pte;\r\npte = kmemcheck_pte_lookup(address);\r\nif (!pte)\r\nreturn 0;\r\nset_pte(pte, __pte(pte_val(*pte) & ~_PAGE_PRESENT));\r\n__flush_tlb_one(address);\r\nreturn 1;\r\n}\r\nbool kmemcheck_active(struct pt_regs *regs)\r\n{\r\nstruct kmemcheck_context *data = &__get_cpu_var(kmemcheck_context);\r\nreturn data->balance > 0;\r\n}\r\nstatic void kmemcheck_save_addr(unsigned long addr)\r\n{\r\nstruct kmemcheck_context *data = &__get_cpu_var(kmemcheck_context);\r\nBUG_ON(data->n_addrs >= ARRAY_SIZE(data->addr));\r\ndata->addr[data->n_addrs++] = addr;\r\n}\r\nstatic unsigned int kmemcheck_show_all(void)\r\n{\r\nstruct kmemcheck_context *data = &__get_cpu_var(kmemcheck_context);\r\nunsigned int i;\r\nunsigned int n;\r\nn = 0;\r\nfor (i = 0; i < data->n_addrs; ++i)\r\nn += kmemcheck_show_addr(data->addr[i]);\r\nreturn n;\r\n}\r\nstatic unsigned int kmemcheck_hide_all(void)\r\n{\r\nstruct kmemcheck_context *data = &__get_cpu_var(kmemcheck_context);\r\nunsigned int i;\r\nunsigned int n;\r\nn = 0;\r\nfor (i = 0; i < data->n_addrs; ++i)\r\nn += kmemcheck_hide_addr(data->addr[i]);\r\nreturn n;\r\n}\r\nvoid kmemcheck_show(struct pt_regs *regs)\r\n{\r\nstruct kmemcheck_context *data = &__get_cpu_var(kmemcheck_context);\r\nBUG_ON(!irqs_disabled());\r\nif (unlikely(data->balance != 0)) {\r\nkmemcheck_show_all();\r\nkmemcheck_error_save_bug(regs);\r\ndata->balance = 0;\r\nreturn;\r\n}\r\nif (kmemcheck_show_all() == 0)\r\nreturn;\r\n++data->balance;\r\nif (!(regs->flags & X86_EFLAGS_TF))\r\ndata->flags = regs->flags;\r\nregs->flags |= X86_EFLAGS_TF;\r\nregs->flags &= ~X86_EFLAGS_IF;\r\n}\r\nvoid kmemcheck_hide(struct pt_regs *regs)\r\n{\r\nstruct kmemcheck_context *data = &__get_cpu_var(kmemcheck_context);\r\nint n;\r\nBUG_ON(!irqs_disabled());\r\nif (unlikely(data->balance != 1)) {\r\nkmemcheck_show_all();\r\nkmemcheck_error_save_bug(regs);\r\ndata->n_addrs = 0;\r\ndata->balance = 0;\r\nif (!(data->flags & X86_EFLAGS_TF))\r\nregs->flags &= ~X86_EFLAGS_TF;\r\nif (data->flags & X86_EFLAGS_IF)\r\nregs->flags |= X86_EFLAGS_IF;\r\nreturn;\r\n}\r\nif (kmemcheck_enabled)\r\nn = kmemcheck_hide_all();\r\nelse\r\nn = kmemcheck_show_all();\r\nif (n == 0)\r\nreturn;\r\n--data->balance;\r\ndata->n_addrs = 0;\r\nif (!(data->flags & X86_EFLAGS_TF))\r\nregs->flags &= ~X86_EFLAGS_TF;\r\nif (data->flags & X86_EFLAGS_IF)\r\nregs->flags |= X86_EFLAGS_IF;\r\n}\r\nvoid kmemcheck_show_pages(struct page *p, unsigned int n)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < n; ++i) {\r\nunsigned long address;\r\npte_t *pte;\r\nunsigned int level;\r\naddress = (unsigned long) page_address(&p[i]);\r\npte = lookup_address(address, &level);\r\nBUG_ON(!pte);\r\nBUG_ON(level != PG_LEVEL_4K);\r\nset_pte(pte, __pte(pte_val(*pte) | _PAGE_PRESENT));\r\nset_pte(pte, __pte(pte_val(*pte) & ~_PAGE_HIDDEN));\r\n__flush_tlb_one(address);\r\n}\r\n}\r\nbool kmemcheck_page_is_tracked(struct page *p)\r\n{\r\nreturn kmemcheck_pte_lookup((unsigned long) page_address(p));\r\n}\r\nvoid kmemcheck_hide_pages(struct page *p, unsigned int n)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < n; ++i) {\r\nunsigned long address;\r\npte_t *pte;\r\nunsigned int level;\r\naddress = (unsigned long) page_address(&p[i]);\r\npte = lookup_address(address, &level);\r\nBUG_ON(!pte);\r\nBUG_ON(level != PG_LEVEL_4K);\r\nset_pte(pte, __pte(pte_val(*pte) & ~_PAGE_PRESENT));\r\nset_pte(pte, __pte(pte_val(*pte) | _PAGE_HIDDEN));\r\n__flush_tlb_one(address);\r\n}\r\n}\r\nstatic void kmemcheck_read_strict(struct pt_regs *regs,\r\nunsigned long addr, unsigned int size)\r\n{\r\nvoid *shadow;\r\nenum kmemcheck_shadow status;\r\nshadow = kmemcheck_shadow_lookup(addr);\r\nif (!shadow)\r\nreturn;\r\nkmemcheck_save_addr(addr);\r\nstatus = kmemcheck_shadow_test(shadow, size);\r\nif (status == KMEMCHECK_SHADOW_INITIALIZED)\r\nreturn;\r\nif (kmemcheck_enabled)\r\nkmemcheck_error_save(status, addr, size, regs);\r\nif (kmemcheck_enabled == 2)\r\nkmemcheck_enabled = 0;\r\nkmemcheck_shadow_set(shadow, size);\r\n}\r\nbool kmemcheck_is_obj_initialized(unsigned long addr, size_t size)\r\n{\r\nenum kmemcheck_shadow status;\r\nvoid *shadow;\r\nshadow = kmemcheck_shadow_lookup(addr);\r\nif (!shadow)\r\nreturn true;\r\nstatus = kmemcheck_shadow_test_all(shadow, size);\r\nreturn status == KMEMCHECK_SHADOW_INITIALIZED;\r\n}\r\nstatic void kmemcheck_read(struct pt_regs *regs,\r\nunsigned long addr, unsigned int size)\r\n{\r\nunsigned long page = addr & PAGE_MASK;\r\nunsigned long next_addr = addr + size - 1;\r\nunsigned long next_page = next_addr & PAGE_MASK;\r\nif (likely(page == next_page)) {\r\nkmemcheck_read_strict(regs, addr, size);\r\nreturn;\r\n}\r\nkmemcheck_read_strict(regs, addr, next_page - addr);\r\nkmemcheck_read_strict(regs, next_page, next_addr - next_page);\r\n}\r\nstatic void kmemcheck_write_strict(struct pt_regs *regs,\r\nunsigned long addr, unsigned int size)\r\n{\r\nvoid *shadow;\r\nshadow = kmemcheck_shadow_lookup(addr);\r\nif (!shadow)\r\nreturn;\r\nkmemcheck_save_addr(addr);\r\nkmemcheck_shadow_set(shadow, size);\r\n}\r\nstatic void kmemcheck_write(struct pt_regs *regs,\r\nunsigned long addr, unsigned int size)\r\n{\r\nunsigned long page = addr & PAGE_MASK;\r\nunsigned long next_addr = addr + size - 1;\r\nunsigned long next_page = next_addr & PAGE_MASK;\r\nif (likely(page == next_page)) {\r\nkmemcheck_write_strict(regs, addr, size);\r\nreturn;\r\n}\r\nkmemcheck_write_strict(regs, addr, next_page - addr);\r\nkmemcheck_write_strict(regs, next_page, next_addr - next_page);\r\n}\r\nstatic void kmemcheck_copy(struct pt_regs *regs,\r\nunsigned long src_addr, unsigned long dst_addr, unsigned int size)\r\n{\r\nuint8_t shadow[8];\r\nenum kmemcheck_shadow status;\r\nunsigned long page;\r\nunsigned long next_addr;\r\nunsigned long next_page;\r\nuint8_t *x;\r\nunsigned int i;\r\nunsigned int n;\r\nBUG_ON(size > sizeof(shadow));\r\npage = src_addr & PAGE_MASK;\r\nnext_addr = src_addr + size - 1;\r\nnext_page = next_addr & PAGE_MASK;\r\nif (likely(page == next_page)) {\r\nx = kmemcheck_shadow_lookup(src_addr);\r\nif (x) {\r\nkmemcheck_save_addr(src_addr);\r\nfor (i = 0; i < size; ++i)\r\nshadow[i] = x[i];\r\n} else {\r\nfor (i = 0; i < size; ++i)\r\nshadow[i] = KMEMCHECK_SHADOW_INITIALIZED;\r\n}\r\n} else {\r\nn = next_page - src_addr;\r\nBUG_ON(n > sizeof(shadow));\r\nx = kmemcheck_shadow_lookup(src_addr);\r\nif (x) {\r\nkmemcheck_save_addr(src_addr);\r\nfor (i = 0; i < n; ++i)\r\nshadow[i] = x[i];\r\n} else {\r\nfor (i = 0; i < n; ++i)\r\nshadow[i] = KMEMCHECK_SHADOW_INITIALIZED;\r\n}\r\nx = kmemcheck_shadow_lookup(next_page);\r\nif (x) {\r\nkmemcheck_save_addr(next_page);\r\nfor (i = n; i < size; ++i)\r\nshadow[i] = x[i - n];\r\n} else {\r\nfor (i = n; i < size; ++i)\r\nshadow[i] = KMEMCHECK_SHADOW_INITIALIZED;\r\n}\r\n}\r\npage = dst_addr & PAGE_MASK;\r\nnext_addr = dst_addr + size - 1;\r\nnext_page = next_addr & PAGE_MASK;\r\nif (likely(page == next_page)) {\r\nx = kmemcheck_shadow_lookup(dst_addr);\r\nif (x) {\r\nkmemcheck_save_addr(dst_addr);\r\nfor (i = 0; i < size; ++i) {\r\nx[i] = shadow[i];\r\nshadow[i] = KMEMCHECK_SHADOW_INITIALIZED;\r\n}\r\n}\r\n} else {\r\nn = next_page - dst_addr;\r\nBUG_ON(n > sizeof(shadow));\r\nx = kmemcheck_shadow_lookup(dst_addr);\r\nif (x) {\r\nkmemcheck_save_addr(dst_addr);\r\nfor (i = 0; i < n; ++i) {\r\nx[i] = shadow[i];\r\nshadow[i] = KMEMCHECK_SHADOW_INITIALIZED;\r\n}\r\n}\r\nx = kmemcheck_shadow_lookup(next_page);\r\nif (x) {\r\nkmemcheck_save_addr(next_page);\r\nfor (i = n; i < size; ++i) {\r\nx[i - n] = shadow[i];\r\nshadow[i] = KMEMCHECK_SHADOW_INITIALIZED;\r\n}\r\n}\r\n}\r\nstatus = kmemcheck_shadow_test(shadow, size);\r\nif (status == KMEMCHECK_SHADOW_INITIALIZED)\r\nreturn;\r\nif (kmemcheck_enabled)\r\nkmemcheck_error_save(status, src_addr, size, regs);\r\nif (kmemcheck_enabled == 2)\r\nkmemcheck_enabled = 0;\r\n}\r\nstatic void kmemcheck_access(struct pt_regs *regs,\r\nunsigned long fallback_address, enum kmemcheck_method fallback_method)\r\n{\r\nconst uint8_t *insn;\r\nconst uint8_t *insn_primary;\r\nunsigned int size;\r\nstruct kmemcheck_context *data = &__get_cpu_var(kmemcheck_context);\r\nif (data->busy) {\r\nkmemcheck_show_addr(fallback_address);\r\nkmemcheck_error_save_bug(regs);\r\nreturn;\r\n}\r\ndata->busy = true;\r\ninsn = (const uint8_t *) regs->ip;\r\ninsn_primary = kmemcheck_opcode_get_primary(insn);\r\nkmemcheck_opcode_decode(insn, &size);\r\nswitch (insn_primary[0]) {\r\n#ifdef CONFIG_KMEMCHECK_BITOPS_OK\r\ncase 0x80:\r\ncase 0x81:\r\ncase 0x82:\r\ncase 0x83:\r\nswitch ((insn_primary[1] >> 3) & 7) {\r\ncase 1:\r\ncase 4:\r\ncase 6:\r\nkmemcheck_write(regs, fallback_address, size);\r\ngoto out;\r\ncase 0:\r\ncase 2:\r\ncase 3:\r\ncase 5:\r\ncase 7:\r\nbreak;\r\n}\r\nbreak;\r\n#endif\r\ncase 0xa4:\r\ncase 0xa5:\r\nkmemcheck_copy(regs, regs->si, regs->di, size);\r\ngoto out;\r\ncase 0xa6:\r\ncase 0xa7:\r\nkmemcheck_read(regs, regs->si, size);\r\nkmemcheck_read(regs, regs->di, size);\r\ngoto out;\r\n}\r\nswitch (fallback_method) {\r\ncase KMEMCHECK_READ:\r\nkmemcheck_read(regs, fallback_address, size);\r\ngoto out;\r\ncase KMEMCHECK_WRITE:\r\nkmemcheck_write(regs, fallback_address, size);\r\ngoto out;\r\n}\r\nout:\r\ndata->busy = false;\r\n}\r\nbool kmemcheck_fault(struct pt_regs *regs, unsigned long address,\r\nunsigned long error_code)\r\n{\r\npte_t *pte;\r\nif (regs->flags & X86_VM_MASK)\r\nreturn false;\r\nif (regs->cs != __KERNEL_CS)\r\nreturn false;\r\npte = kmemcheck_pte_lookup(address);\r\nif (!pte)\r\nreturn false;\r\nWARN_ON_ONCE(in_nmi());\r\nif (error_code & 2)\r\nkmemcheck_access(regs, address, KMEMCHECK_WRITE);\r\nelse\r\nkmemcheck_access(regs, address, KMEMCHECK_READ);\r\nkmemcheck_show(regs);\r\nreturn true;\r\n}\r\nbool kmemcheck_trap(struct pt_regs *regs)\r\n{\r\nif (!kmemcheck_active(regs))\r\nreturn false;\r\nkmemcheck_hide(regs);\r\nreturn true;\r\n}
