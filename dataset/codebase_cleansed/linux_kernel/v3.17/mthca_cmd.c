static inline int go_bit(struct mthca_dev *dev)\r\n{\r\nreturn readl(dev->hcr + HCR_STATUS_OFFSET) &\r\nswab32(1 << HCR_GO_BIT);\r\n}\r\nstatic void mthca_cmd_post_dbell(struct mthca_dev *dev,\r\nu64 in_param,\r\nu64 out_param,\r\nu32 in_modifier,\r\nu8 op_modifier,\r\nu16 op,\r\nu16 token)\r\n{\r\nvoid __iomem *ptr = dev->cmd.dbell_map;\r\nu16 *offs = dev->cmd.dbell_offsets;\r\n__raw_writel((__force u32) cpu_to_be32(in_param >> 32), ptr + offs[0]);\r\nwmb();\r\n__raw_writel((__force u32) cpu_to_be32(in_param & 0xfffffffful), ptr + offs[1]);\r\nwmb();\r\n__raw_writel((__force u32) cpu_to_be32(in_modifier), ptr + offs[2]);\r\nwmb();\r\n__raw_writel((__force u32) cpu_to_be32(out_param >> 32), ptr + offs[3]);\r\nwmb();\r\n__raw_writel((__force u32) cpu_to_be32(out_param & 0xfffffffful), ptr + offs[4]);\r\nwmb();\r\n__raw_writel((__force u32) cpu_to_be32(token << 16), ptr + offs[5]);\r\nwmb();\r\n__raw_writel((__force u32) cpu_to_be32((1 << HCR_GO_BIT) |\r\n(1 << HCA_E_BIT) |\r\n(op_modifier << HCR_OPMOD_SHIFT) |\r\nop), ptr + offs[6]);\r\nwmb();\r\n__raw_writel((__force u32) 0, ptr + offs[7]);\r\nwmb();\r\n}\r\nstatic int mthca_cmd_post_hcr(struct mthca_dev *dev,\r\nu64 in_param,\r\nu64 out_param,\r\nu32 in_modifier,\r\nu8 op_modifier,\r\nu16 op,\r\nu16 token,\r\nint event)\r\n{\r\nif (event) {\r\nunsigned long end = jiffies + GO_BIT_TIMEOUT;\r\nwhile (go_bit(dev) && time_before(jiffies, end)) {\r\nset_current_state(TASK_RUNNING);\r\nschedule();\r\n}\r\n}\r\nif (go_bit(dev))\r\nreturn -EAGAIN;\r\n__raw_writel((__force u32) cpu_to_be32(in_param >> 32), dev->hcr + 0 * 4);\r\n__raw_writel((__force u32) cpu_to_be32(in_param & 0xfffffffful), dev->hcr + 1 * 4);\r\n__raw_writel((__force u32) cpu_to_be32(in_modifier), dev->hcr + 2 * 4);\r\n__raw_writel((__force u32) cpu_to_be32(out_param >> 32), dev->hcr + 3 * 4);\r\n__raw_writel((__force u32) cpu_to_be32(out_param & 0xfffffffful), dev->hcr + 4 * 4);\r\n__raw_writel((__force u32) cpu_to_be32(token << 16), dev->hcr + 5 * 4);\r\nwmb();\r\n__raw_writel((__force u32) cpu_to_be32((1 << HCR_GO_BIT) |\r\n(event ? (1 << HCA_E_BIT) : 0) |\r\n(op_modifier << HCR_OPMOD_SHIFT) |\r\nop), dev->hcr + 6 * 4);\r\nreturn 0;\r\n}\r\nstatic int mthca_cmd_post(struct mthca_dev *dev,\r\nu64 in_param,\r\nu64 out_param,\r\nu32 in_modifier,\r\nu8 op_modifier,\r\nu16 op,\r\nu16 token,\r\nint event)\r\n{\r\nint err = 0;\r\nmutex_lock(&dev->cmd.hcr_mutex);\r\nif (event && dev->cmd.flags & MTHCA_CMD_POST_DOORBELLS && fw_cmd_doorbell)\r\nmthca_cmd_post_dbell(dev, in_param, out_param, in_modifier,\r\nop_modifier, op, token);\r\nelse\r\nerr = mthca_cmd_post_hcr(dev, in_param, out_param, in_modifier,\r\nop_modifier, op, token, event);\r\nmmiowb();\r\nmutex_unlock(&dev->cmd.hcr_mutex);\r\nreturn err;\r\n}\r\nstatic int mthca_status_to_errno(u8 status)\r\n{\r\nstatic const int trans_table[] = {\r\n[MTHCA_CMD_STAT_INTERNAL_ERR] = -EIO,\r\n[MTHCA_CMD_STAT_BAD_OP] = -EPERM,\r\n[MTHCA_CMD_STAT_BAD_PARAM] = -EINVAL,\r\n[MTHCA_CMD_STAT_BAD_SYS_STATE] = -ENXIO,\r\n[MTHCA_CMD_STAT_BAD_RESOURCE] = -EBADF,\r\n[MTHCA_CMD_STAT_RESOURCE_BUSY] = -EBUSY,\r\n[MTHCA_CMD_STAT_DDR_MEM_ERR] = -ENOMEM,\r\n[MTHCA_CMD_STAT_EXCEED_LIM] = -ENOMEM,\r\n[MTHCA_CMD_STAT_BAD_RES_STATE] = -EBADF,\r\n[MTHCA_CMD_STAT_BAD_INDEX] = -EBADF,\r\n[MTHCA_CMD_STAT_BAD_NVMEM] = -EFAULT,\r\n[MTHCA_CMD_STAT_BAD_QPEE_STATE] = -EINVAL,\r\n[MTHCA_CMD_STAT_BAD_SEG_PARAM] = -EFAULT,\r\n[MTHCA_CMD_STAT_REG_BOUND] = -EBUSY,\r\n[MTHCA_CMD_STAT_LAM_NOT_PRE] = -EAGAIN,\r\n[MTHCA_CMD_STAT_BAD_PKT] = -EBADMSG,\r\n[MTHCA_CMD_STAT_BAD_SIZE] = -ENOMEM,\r\n};\r\nif (status >= ARRAY_SIZE(trans_table) ||\r\n(status != MTHCA_CMD_STAT_OK\r\n&& trans_table[status] == 0))\r\nreturn -EINVAL;\r\nreturn trans_table[status];\r\n}\r\nstatic int mthca_cmd_poll(struct mthca_dev *dev,\r\nu64 in_param,\r\nu64 *out_param,\r\nint out_is_imm,\r\nu32 in_modifier,\r\nu8 op_modifier,\r\nu16 op,\r\nunsigned long timeout)\r\n{\r\nint err = 0;\r\nunsigned long end;\r\nu8 status;\r\ndown(&dev->cmd.poll_sem);\r\nerr = mthca_cmd_post(dev, in_param,\r\nout_param ? *out_param : 0,\r\nin_modifier, op_modifier,\r\nop, CMD_POLL_TOKEN, 0);\r\nif (err)\r\ngoto out;\r\nend = timeout + jiffies;\r\nwhile (go_bit(dev) && time_before(jiffies, end)) {\r\nset_current_state(TASK_RUNNING);\r\nschedule();\r\n}\r\nif (go_bit(dev)) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nif (out_is_imm)\r\n*out_param =\r\n(u64) be32_to_cpu((__force __be32)\r\n__raw_readl(dev->hcr + HCR_OUT_PARAM_OFFSET)) << 32 |\r\n(u64) be32_to_cpu((__force __be32)\r\n__raw_readl(dev->hcr + HCR_OUT_PARAM_OFFSET + 4));\r\nstatus = be32_to_cpu((__force __be32) __raw_readl(dev->hcr + HCR_STATUS_OFFSET)) >> 24;\r\nif (status) {\r\nmthca_dbg(dev, "Command %02x completed with status %02x\n",\r\nop, status);\r\nerr = mthca_status_to_errno(status);\r\n}\r\nout:\r\nup(&dev->cmd.poll_sem);\r\nreturn err;\r\n}\r\nvoid mthca_cmd_event(struct mthca_dev *dev,\r\nu16 token,\r\nu8 status,\r\nu64 out_param)\r\n{\r\nstruct mthca_cmd_context *context =\r\n&dev->cmd.context[token & dev->cmd.token_mask];\r\nif (token != context->token)\r\nreturn;\r\ncontext->result = 0;\r\ncontext->status = status;\r\ncontext->out_param = out_param;\r\ncomplete(&context->done);\r\n}\r\nstatic int mthca_cmd_wait(struct mthca_dev *dev,\r\nu64 in_param,\r\nu64 *out_param,\r\nint out_is_imm,\r\nu32 in_modifier,\r\nu8 op_modifier,\r\nu16 op,\r\nunsigned long timeout)\r\n{\r\nint err = 0;\r\nstruct mthca_cmd_context *context;\r\ndown(&dev->cmd.event_sem);\r\nspin_lock(&dev->cmd.context_lock);\r\nBUG_ON(dev->cmd.free_head < 0);\r\ncontext = &dev->cmd.context[dev->cmd.free_head];\r\ncontext->token += dev->cmd.token_mask + 1;\r\ndev->cmd.free_head = context->next;\r\nspin_unlock(&dev->cmd.context_lock);\r\ninit_completion(&context->done);\r\nerr = mthca_cmd_post(dev, in_param,\r\nout_param ? *out_param : 0,\r\nin_modifier, op_modifier,\r\nop, context->token, 1);\r\nif (err)\r\ngoto out;\r\nif (!wait_for_completion_timeout(&context->done, timeout)) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nerr = context->result;\r\nif (err)\r\ngoto out;\r\nif (context->status) {\r\nmthca_dbg(dev, "Command %02x completed with status %02x\n",\r\nop, context->status);\r\nerr = mthca_status_to_errno(context->status);\r\n}\r\nif (out_is_imm)\r\n*out_param = context->out_param;\r\nout:\r\nspin_lock(&dev->cmd.context_lock);\r\ncontext->next = dev->cmd.free_head;\r\ndev->cmd.free_head = context - dev->cmd.context;\r\nspin_unlock(&dev->cmd.context_lock);\r\nup(&dev->cmd.event_sem);\r\nreturn err;\r\n}\r\nstatic int mthca_cmd_box(struct mthca_dev *dev,\r\nu64 in_param,\r\nu64 out_param,\r\nu32 in_modifier,\r\nu8 op_modifier,\r\nu16 op,\r\nunsigned long timeout)\r\n{\r\nif (dev->cmd.flags & MTHCA_CMD_USE_EVENTS)\r\nreturn mthca_cmd_wait(dev, in_param, &out_param, 0,\r\nin_modifier, op_modifier, op,\r\ntimeout);\r\nelse\r\nreturn mthca_cmd_poll(dev, in_param, &out_param, 0,\r\nin_modifier, op_modifier, op,\r\ntimeout);\r\n}\r\nstatic int mthca_cmd(struct mthca_dev *dev,\r\nu64 in_param,\r\nu32 in_modifier,\r\nu8 op_modifier,\r\nu16 op,\r\nunsigned long timeout)\r\n{\r\nreturn mthca_cmd_box(dev, in_param, 0, in_modifier,\r\nop_modifier, op, timeout);\r\n}\r\nstatic int mthca_cmd_imm(struct mthca_dev *dev,\r\nu64 in_param,\r\nu64 *out_param,\r\nu32 in_modifier,\r\nu8 op_modifier,\r\nu16 op,\r\nunsigned long timeout)\r\n{\r\nif (dev->cmd.flags & MTHCA_CMD_USE_EVENTS)\r\nreturn mthca_cmd_wait(dev, in_param, out_param, 1,\r\nin_modifier, op_modifier, op,\r\ntimeout);\r\nelse\r\nreturn mthca_cmd_poll(dev, in_param, out_param, 1,\r\nin_modifier, op_modifier, op,\r\ntimeout);\r\n}\r\nint mthca_cmd_init(struct mthca_dev *dev)\r\n{\r\nmutex_init(&dev->cmd.hcr_mutex);\r\nsema_init(&dev->cmd.poll_sem, 1);\r\ndev->cmd.flags = 0;\r\ndev->hcr = ioremap(pci_resource_start(dev->pdev, 0) + MTHCA_HCR_BASE,\r\nMTHCA_HCR_SIZE);\r\nif (!dev->hcr) {\r\nmthca_err(dev, "Couldn't map command register.");\r\nreturn -ENOMEM;\r\n}\r\ndev->cmd.pool = pci_pool_create("mthca_cmd", dev->pdev,\r\nMTHCA_MAILBOX_SIZE,\r\nMTHCA_MAILBOX_SIZE, 0);\r\nif (!dev->cmd.pool) {\r\niounmap(dev->hcr);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid mthca_cmd_cleanup(struct mthca_dev *dev)\r\n{\r\npci_pool_destroy(dev->cmd.pool);\r\niounmap(dev->hcr);\r\nif (dev->cmd.flags & MTHCA_CMD_POST_DOORBELLS)\r\niounmap(dev->cmd.dbell_map);\r\n}\r\nint mthca_cmd_use_events(struct mthca_dev *dev)\r\n{\r\nint i;\r\ndev->cmd.context = kmalloc(dev->cmd.max_cmds *\r\nsizeof (struct mthca_cmd_context),\r\nGFP_KERNEL);\r\nif (!dev->cmd.context)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < dev->cmd.max_cmds; ++i) {\r\ndev->cmd.context[i].token = i;\r\ndev->cmd.context[i].next = i + 1;\r\n}\r\ndev->cmd.context[dev->cmd.max_cmds - 1].next = -1;\r\ndev->cmd.free_head = 0;\r\nsema_init(&dev->cmd.event_sem, dev->cmd.max_cmds);\r\nspin_lock_init(&dev->cmd.context_lock);\r\nfor (dev->cmd.token_mask = 1;\r\ndev->cmd.token_mask < dev->cmd.max_cmds;\r\ndev->cmd.token_mask <<= 1)\r\n;\r\n--dev->cmd.token_mask;\r\ndev->cmd.flags |= MTHCA_CMD_USE_EVENTS;\r\ndown(&dev->cmd.poll_sem);\r\nreturn 0;\r\n}\r\nvoid mthca_cmd_use_polling(struct mthca_dev *dev)\r\n{\r\nint i;\r\ndev->cmd.flags &= ~MTHCA_CMD_USE_EVENTS;\r\nfor (i = 0; i < dev->cmd.max_cmds; ++i)\r\ndown(&dev->cmd.event_sem);\r\nkfree(dev->cmd.context);\r\nup(&dev->cmd.poll_sem);\r\n}\r\nstruct mthca_mailbox *mthca_alloc_mailbox(struct mthca_dev *dev,\r\ngfp_t gfp_mask)\r\n{\r\nstruct mthca_mailbox *mailbox;\r\nmailbox = kmalloc(sizeof *mailbox, gfp_mask);\r\nif (!mailbox)\r\nreturn ERR_PTR(-ENOMEM);\r\nmailbox->buf = pci_pool_alloc(dev->cmd.pool, gfp_mask, &mailbox->dma);\r\nif (!mailbox->buf) {\r\nkfree(mailbox);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nreturn mailbox;\r\n}\r\nvoid mthca_free_mailbox(struct mthca_dev *dev, struct mthca_mailbox *mailbox)\r\n{\r\nif (!mailbox)\r\nreturn;\r\npci_pool_free(dev->cmd.pool, mailbox->buf, mailbox->dma);\r\nkfree(mailbox);\r\n}\r\nint mthca_SYS_EN(struct mthca_dev *dev)\r\n{\r\nu64 out;\r\nint ret;\r\nret = mthca_cmd_imm(dev, 0, &out, 0, 0, CMD_SYS_EN, CMD_TIME_CLASS_D);\r\nif (ret == -ENOMEM)\r\nmthca_warn(dev, "SYS_EN DDR error: syn=%x, sock=%d, "\r\n"sladdr=%d, SPD source=%s\n",\r\n(int) (out >> 6) & 0xf, (int) (out >> 4) & 3,\r\n(int) (out >> 1) & 7, (int) out & 1 ? "NVMEM" : "DIMM");\r\nreturn ret;\r\n}\r\nint mthca_SYS_DIS(struct mthca_dev *dev)\r\n{\r\nreturn mthca_cmd(dev, 0, 0, 0, CMD_SYS_DIS, CMD_TIME_CLASS_C);\r\n}\r\nstatic int mthca_map_cmd(struct mthca_dev *dev, u16 op, struct mthca_icm *icm,\r\nu64 virt)\r\n{\r\nstruct mthca_mailbox *mailbox;\r\nstruct mthca_icm_iter iter;\r\n__be64 *pages;\r\nint lg;\r\nint nent = 0;\r\nint i;\r\nint err = 0;\r\nint ts = 0, tc = 0;\r\nmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\nmemset(mailbox->buf, 0, MTHCA_MAILBOX_SIZE);\r\npages = mailbox->buf;\r\nfor (mthca_icm_first(icm, &iter);\r\n!mthca_icm_last(&iter);\r\nmthca_icm_next(&iter)) {\r\nlg = ffs(mthca_icm_addr(&iter) | mthca_icm_size(&iter)) - 1;\r\nif (lg < MTHCA_ICM_PAGE_SHIFT) {\r\nmthca_warn(dev, "Got FW area not aligned to %d (%llx/%lx).\n",\r\nMTHCA_ICM_PAGE_SIZE,\r\n(unsigned long long) mthca_icm_addr(&iter),\r\nmthca_icm_size(&iter));\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nfor (i = 0; i < mthca_icm_size(&iter) >> lg; ++i) {\r\nif (virt != -1) {\r\npages[nent * 2] = cpu_to_be64(virt);\r\nvirt += 1 << lg;\r\n}\r\npages[nent * 2 + 1] =\r\ncpu_to_be64((mthca_icm_addr(&iter) + (i << lg)) |\r\n(lg - MTHCA_ICM_PAGE_SHIFT));\r\nts += 1 << (lg - 10);\r\n++tc;\r\nif (++nent == MTHCA_MAILBOX_SIZE / 16) {\r\nerr = mthca_cmd(dev, mailbox->dma, nent, 0, op,\r\nCMD_TIME_CLASS_B);\r\nif (err)\r\ngoto out;\r\nnent = 0;\r\n}\r\n}\r\n}\r\nif (nent)\r\nerr = mthca_cmd(dev, mailbox->dma, nent, 0, op,\r\nCMD_TIME_CLASS_B);\r\nswitch (op) {\r\ncase CMD_MAP_FA:\r\nmthca_dbg(dev, "Mapped %d chunks/%d KB for FW.\n", tc, ts);\r\nbreak;\r\ncase CMD_MAP_ICM_AUX:\r\nmthca_dbg(dev, "Mapped %d chunks/%d KB for ICM aux.\n", tc, ts);\r\nbreak;\r\ncase CMD_MAP_ICM:\r\nmthca_dbg(dev, "Mapped %d chunks/%d KB at %llx for ICM.\n",\r\ntc, ts, (unsigned long long) virt - (ts << 10));\r\nbreak;\r\n}\r\nout:\r\nmthca_free_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nint mthca_MAP_FA(struct mthca_dev *dev, struct mthca_icm *icm)\r\n{\r\nreturn mthca_map_cmd(dev, CMD_MAP_FA, icm, -1);\r\n}\r\nint mthca_UNMAP_FA(struct mthca_dev *dev)\r\n{\r\nreturn mthca_cmd(dev, 0, 0, 0, CMD_UNMAP_FA, CMD_TIME_CLASS_B);\r\n}\r\nint mthca_RUN_FW(struct mthca_dev *dev)\r\n{\r\nreturn mthca_cmd(dev, 0, 0, 0, CMD_RUN_FW, CMD_TIME_CLASS_A);\r\n}\r\nstatic void mthca_setup_cmd_doorbells(struct mthca_dev *dev, u64 base)\r\n{\r\nphys_addr_t addr;\r\nu16 max_off = 0;\r\nint i;\r\nfor (i = 0; i < 8; ++i)\r\nmax_off = max(max_off, dev->cmd.dbell_offsets[i]);\r\nif ((base & PAGE_MASK) != ((base + max_off) & PAGE_MASK)) {\r\nmthca_warn(dev, "Firmware doorbell region at 0x%016llx, "\r\n"length 0x%x crosses a page boundary\n",\r\n(unsigned long long) base, max_off);\r\nreturn;\r\n}\r\naddr = pci_resource_start(dev->pdev, 2) +\r\n((pci_resource_len(dev->pdev, 2) - 1) & base);\r\ndev->cmd.dbell_map = ioremap(addr, max_off + sizeof(u32));\r\nif (!dev->cmd.dbell_map)\r\nreturn;\r\ndev->cmd.flags |= MTHCA_CMD_POST_DOORBELLS;\r\nmthca_dbg(dev, "Mapped doorbell page for posting FW commands\n");\r\n}\r\nint mthca_QUERY_FW(struct mthca_dev *dev)\r\n{\r\nstruct mthca_mailbox *mailbox;\r\nu32 *outbox;\r\nu64 base;\r\nu32 tmp;\r\nint err = 0;\r\nu8 lg;\r\nint i;\r\n#define QUERY_FW_OUT_SIZE 0x100\r\n#define QUERY_FW_VER_OFFSET 0x00\r\n#define QUERY_FW_MAX_CMD_OFFSET 0x0f\r\n#define QUERY_FW_ERR_START_OFFSET 0x30\r\n#define QUERY_FW_ERR_SIZE_OFFSET 0x38\r\n#define QUERY_FW_CMD_DB_EN_OFFSET 0x10\r\n#define QUERY_FW_CMD_DB_OFFSET 0x50\r\n#define QUERY_FW_CMD_DB_BASE 0x60\r\n#define QUERY_FW_START_OFFSET 0x20\r\n#define QUERY_FW_END_OFFSET 0x28\r\n#define QUERY_FW_SIZE_OFFSET 0x00\r\n#define QUERY_FW_CLR_INT_BASE_OFFSET 0x20\r\n#define QUERY_FW_EQ_ARM_BASE_OFFSET 0x40\r\n#define QUERY_FW_EQ_SET_CI_BASE_OFFSET 0x48\r\nmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\noutbox = mailbox->buf;\r\nerr = mthca_cmd_box(dev, 0, mailbox->dma, 0, 0, CMD_QUERY_FW,\r\nCMD_TIME_CLASS_A);\r\nif (err)\r\ngoto out;\r\nMTHCA_GET(dev->fw_ver, outbox, QUERY_FW_VER_OFFSET);\r\ndev->fw_ver = (dev->fw_ver & 0xffff00000000ull) |\r\n((dev->fw_ver & 0xffff0000ull) >> 16) |\r\n((dev->fw_ver & 0x0000ffffull) << 16);\r\nMTHCA_GET(lg, outbox, QUERY_FW_MAX_CMD_OFFSET);\r\ndev->cmd.max_cmds = 1 << lg;\r\nmthca_dbg(dev, "FW version %012llx, max commands %d\n",\r\n(unsigned long long) dev->fw_ver, dev->cmd.max_cmds);\r\nMTHCA_GET(dev->catas_err.addr, outbox, QUERY_FW_ERR_START_OFFSET);\r\nMTHCA_GET(dev->catas_err.size, outbox, QUERY_FW_ERR_SIZE_OFFSET);\r\nmthca_dbg(dev, "Catastrophic error buffer at 0x%llx, size 0x%x\n",\r\n(unsigned long long) dev->catas_err.addr, dev->catas_err.size);\r\nMTHCA_GET(tmp, outbox, QUERY_FW_CMD_DB_EN_OFFSET);\r\nif (tmp & 0x1) {\r\nmthca_dbg(dev, "FW supports commands through doorbells\n");\r\nMTHCA_GET(base, outbox, QUERY_FW_CMD_DB_BASE);\r\nfor (i = 0; i < MTHCA_CMD_NUM_DBELL_DWORDS; ++i)\r\nMTHCA_GET(dev->cmd.dbell_offsets[i], outbox,\r\nQUERY_FW_CMD_DB_OFFSET + (i << 1));\r\nmthca_setup_cmd_doorbells(dev, base);\r\n}\r\nif (mthca_is_memfree(dev)) {\r\nMTHCA_GET(dev->fw.arbel.fw_pages, outbox, QUERY_FW_SIZE_OFFSET);\r\nMTHCA_GET(dev->fw.arbel.clr_int_base, outbox, QUERY_FW_CLR_INT_BASE_OFFSET);\r\nMTHCA_GET(dev->fw.arbel.eq_arm_base, outbox, QUERY_FW_EQ_ARM_BASE_OFFSET);\r\nMTHCA_GET(dev->fw.arbel.eq_set_ci_base, outbox, QUERY_FW_EQ_SET_CI_BASE_OFFSET);\r\nmthca_dbg(dev, "FW size %d KB\n", dev->fw.arbel.fw_pages << 2);\r\ndev->fw.arbel.fw_pages =\r\nALIGN(dev->fw.arbel.fw_pages, PAGE_SIZE / MTHCA_ICM_PAGE_SIZE) >>\r\n(PAGE_SHIFT - MTHCA_ICM_PAGE_SHIFT);\r\nmthca_dbg(dev, "Clear int @ %llx, EQ arm @ %llx, EQ set CI @ %llx\n",\r\n(unsigned long long) dev->fw.arbel.clr_int_base,\r\n(unsigned long long) dev->fw.arbel.eq_arm_base,\r\n(unsigned long long) dev->fw.arbel.eq_set_ci_base);\r\n} else {\r\nMTHCA_GET(dev->fw.tavor.fw_start, outbox, QUERY_FW_START_OFFSET);\r\nMTHCA_GET(dev->fw.tavor.fw_end, outbox, QUERY_FW_END_OFFSET);\r\nmthca_dbg(dev, "FW size %d KB (start %llx, end %llx)\n",\r\n(int) ((dev->fw.tavor.fw_end - dev->fw.tavor.fw_start) >> 10),\r\n(unsigned long long) dev->fw.tavor.fw_start,\r\n(unsigned long long) dev->fw.tavor.fw_end);\r\n}\r\nout:\r\nmthca_free_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nint mthca_ENABLE_LAM(struct mthca_dev *dev)\r\n{\r\nstruct mthca_mailbox *mailbox;\r\nu8 info;\r\nu32 *outbox;\r\nint err = 0;\r\n#define ENABLE_LAM_OUT_SIZE 0x100\r\n#define ENABLE_LAM_START_OFFSET 0x00\r\n#define ENABLE_LAM_END_OFFSET 0x08\r\n#define ENABLE_LAM_INFO_OFFSET 0x13\r\n#define ENABLE_LAM_INFO_HIDDEN_FLAG (1 << 4)\r\n#define ENABLE_LAM_INFO_ECC_MASK 0x3\r\nmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\noutbox = mailbox->buf;\r\nerr = mthca_cmd_box(dev, 0, mailbox->dma, 0, 0, CMD_ENABLE_LAM,\r\nCMD_TIME_CLASS_C);\r\nif (err)\r\ngoto out;\r\nMTHCA_GET(dev->ddr_start, outbox, ENABLE_LAM_START_OFFSET);\r\nMTHCA_GET(dev->ddr_end, outbox, ENABLE_LAM_END_OFFSET);\r\nMTHCA_GET(info, outbox, ENABLE_LAM_INFO_OFFSET);\r\nif (!!(info & ENABLE_LAM_INFO_HIDDEN_FLAG) !=\r\n!!(dev->mthca_flags & MTHCA_FLAG_DDR_HIDDEN)) {\r\nmthca_info(dev, "FW reports that HCA-attached memory "\r\n"is %s hidden; does not match PCI config\n",\r\n(info & ENABLE_LAM_INFO_HIDDEN_FLAG) ?\r\n"" : "not");\r\n}\r\nif (info & ENABLE_LAM_INFO_HIDDEN_FLAG)\r\nmthca_dbg(dev, "HCA-attached memory is hidden.\n");\r\nmthca_dbg(dev, "HCA memory size %d KB (start %llx, end %llx)\n",\r\n(int) ((dev->ddr_end - dev->ddr_start) >> 10),\r\n(unsigned long long) dev->ddr_start,\r\n(unsigned long long) dev->ddr_end);\r\nout:\r\nmthca_free_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nint mthca_DISABLE_LAM(struct mthca_dev *dev)\r\n{\r\nreturn mthca_cmd(dev, 0, 0, 0, CMD_SYS_DIS, CMD_TIME_CLASS_C);\r\n}\r\nint mthca_QUERY_DDR(struct mthca_dev *dev)\r\n{\r\nstruct mthca_mailbox *mailbox;\r\nu8 info;\r\nu32 *outbox;\r\nint err = 0;\r\n#define QUERY_DDR_OUT_SIZE 0x100\r\n#define QUERY_DDR_START_OFFSET 0x00\r\n#define QUERY_DDR_END_OFFSET 0x08\r\n#define QUERY_DDR_INFO_OFFSET 0x13\r\n#define QUERY_DDR_INFO_HIDDEN_FLAG (1 << 4)\r\n#define QUERY_DDR_INFO_ECC_MASK 0x3\r\nmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\noutbox = mailbox->buf;\r\nerr = mthca_cmd_box(dev, 0, mailbox->dma, 0, 0, CMD_QUERY_DDR,\r\nCMD_TIME_CLASS_A);\r\nif (err)\r\ngoto out;\r\nMTHCA_GET(dev->ddr_start, outbox, QUERY_DDR_START_OFFSET);\r\nMTHCA_GET(dev->ddr_end, outbox, QUERY_DDR_END_OFFSET);\r\nMTHCA_GET(info, outbox, QUERY_DDR_INFO_OFFSET);\r\nif (!!(info & QUERY_DDR_INFO_HIDDEN_FLAG) !=\r\n!!(dev->mthca_flags & MTHCA_FLAG_DDR_HIDDEN)) {\r\nmthca_info(dev, "FW reports that HCA-attached memory "\r\n"is %s hidden; does not match PCI config\n",\r\n(info & QUERY_DDR_INFO_HIDDEN_FLAG) ?\r\n"" : "not");\r\n}\r\nif (info & QUERY_DDR_INFO_HIDDEN_FLAG)\r\nmthca_dbg(dev, "HCA-attached memory is hidden.\n");\r\nmthca_dbg(dev, "HCA memory size %d KB (start %llx, end %llx)\n",\r\n(int) ((dev->ddr_end - dev->ddr_start) >> 10),\r\n(unsigned long long) dev->ddr_start,\r\n(unsigned long long) dev->ddr_end);\r\nout:\r\nmthca_free_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nint mthca_QUERY_DEV_LIM(struct mthca_dev *dev,\r\nstruct mthca_dev_lim *dev_lim)\r\n{\r\nstruct mthca_mailbox *mailbox;\r\nu32 *outbox;\r\nu8 field;\r\nu16 size;\r\nu16 stat_rate;\r\nint err;\r\n#define QUERY_DEV_LIM_OUT_SIZE 0x100\r\n#define QUERY_DEV_LIM_MAX_SRQ_SZ_OFFSET 0x10\r\n#define QUERY_DEV_LIM_MAX_QP_SZ_OFFSET 0x11\r\n#define QUERY_DEV_LIM_RSVD_QP_OFFSET 0x12\r\n#define QUERY_DEV_LIM_MAX_QP_OFFSET 0x13\r\n#define QUERY_DEV_LIM_RSVD_SRQ_OFFSET 0x14\r\n#define QUERY_DEV_LIM_MAX_SRQ_OFFSET 0x15\r\n#define QUERY_DEV_LIM_RSVD_EEC_OFFSET 0x16\r\n#define QUERY_DEV_LIM_MAX_EEC_OFFSET 0x17\r\n#define QUERY_DEV_LIM_MAX_CQ_SZ_OFFSET 0x19\r\n#define QUERY_DEV_LIM_RSVD_CQ_OFFSET 0x1a\r\n#define QUERY_DEV_LIM_MAX_CQ_OFFSET 0x1b\r\n#define QUERY_DEV_LIM_MAX_MPT_OFFSET 0x1d\r\n#define QUERY_DEV_LIM_RSVD_EQ_OFFSET 0x1e\r\n#define QUERY_DEV_LIM_MAX_EQ_OFFSET 0x1f\r\n#define QUERY_DEV_LIM_RSVD_MTT_OFFSET 0x20\r\n#define QUERY_DEV_LIM_MAX_MRW_SZ_OFFSET 0x21\r\n#define QUERY_DEV_LIM_RSVD_MRW_OFFSET 0x22\r\n#define QUERY_DEV_LIM_MAX_MTT_SEG_OFFSET 0x23\r\n#define QUERY_DEV_LIM_MAX_AV_OFFSET 0x27\r\n#define QUERY_DEV_LIM_MAX_REQ_QP_OFFSET 0x29\r\n#define QUERY_DEV_LIM_MAX_RES_QP_OFFSET 0x2b\r\n#define QUERY_DEV_LIM_MAX_RDMA_OFFSET 0x2f\r\n#define QUERY_DEV_LIM_RSZ_SRQ_OFFSET 0x33\r\n#define QUERY_DEV_LIM_ACK_DELAY_OFFSET 0x35\r\n#define QUERY_DEV_LIM_MTU_WIDTH_OFFSET 0x36\r\n#define QUERY_DEV_LIM_VL_PORT_OFFSET 0x37\r\n#define QUERY_DEV_LIM_MAX_GID_OFFSET 0x3b\r\n#define QUERY_DEV_LIM_RATE_SUPPORT_OFFSET 0x3c\r\n#define QUERY_DEV_LIM_MAX_PKEY_OFFSET 0x3f\r\n#define QUERY_DEV_LIM_FLAGS_OFFSET 0x44\r\n#define QUERY_DEV_LIM_RSVD_UAR_OFFSET 0x48\r\n#define QUERY_DEV_LIM_UAR_SZ_OFFSET 0x49\r\n#define QUERY_DEV_LIM_PAGE_SZ_OFFSET 0x4b\r\n#define QUERY_DEV_LIM_MAX_SG_OFFSET 0x51\r\n#define QUERY_DEV_LIM_MAX_DESC_SZ_OFFSET 0x52\r\n#define QUERY_DEV_LIM_MAX_SG_RQ_OFFSET 0x55\r\n#define QUERY_DEV_LIM_MAX_DESC_SZ_RQ_OFFSET 0x56\r\n#define QUERY_DEV_LIM_MAX_QP_MCG_OFFSET 0x61\r\n#define QUERY_DEV_LIM_RSVD_MCG_OFFSET 0x62\r\n#define QUERY_DEV_LIM_MAX_MCG_OFFSET 0x63\r\n#define QUERY_DEV_LIM_RSVD_PD_OFFSET 0x64\r\n#define QUERY_DEV_LIM_MAX_PD_OFFSET 0x65\r\n#define QUERY_DEV_LIM_RSVD_RDD_OFFSET 0x66\r\n#define QUERY_DEV_LIM_MAX_RDD_OFFSET 0x67\r\n#define QUERY_DEV_LIM_EEC_ENTRY_SZ_OFFSET 0x80\r\n#define QUERY_DEV_LIM_QPC_ENTRY_SZ_OFFSET 0x82\r\n#define QUERY_DEV_LIM_EEEC_ENTRY_SZ_OFFSET 0x84\r\n#define QUERY_DEV_LIM_EQPC_ENTRY_SZ_OFFSET 0x86\r\n#define QUERY_DEV_LIM_EQC_ENTRY_SZ_OFFSET 0x88\r\n#define QUERY_DEV_LIM_CQC_ENTRY_SZ_OFFSET 0x8a\r\n#define QUERY_DEV_LIM_SRQ_ENTRY_SZ_OFFSET 0x8c\r\n#define QUERY_DEV_LIM_UAR_ENTRY_SZ_OFFSET 0x8e\r\n#define QUERY_DEV_LIM_MTT_ENTRY_SZ_OFFSET 0x90\r\n#define QUERY_DEV_LIM_MPT_ENTRY_SZ_OFFSET 0x92\r\n#define QUERY_DEV_LIM_PBL_SZ_OFFSET 0x96\r\n#define QUERY_DEV_LIM_BMME_FLAGS_OFFSET 0x97\r\n#define QUERY_DEV_LIM_RSVD_LKEY_OFFSET 0x98\r\n#define QUERY_DEV_LIM_LAMR_OFFSET 0x9f\r\n#define QUERY_DEV_LIM_MAX_ICM_SZ_OFFSET 0xa0\r\nmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\noutbox = mailbox->buf;\r\nerr = mthca_cmd_box(dev, 0, mailbox->dma, 0, 0, CMD_QUERY_DEV_LIM,\r\nCMD_TIME_CLASS_A);\r\nif (err)\r\ngoto out;\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_QP_OFFSET);\r\ndev_lim->reserved_qps = 1 << (field & 0xf);\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_QP_OFFSET);\r\ndev_lim->max_qps = 1 << (field & 0x1f);\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_SRQ_OFFSET);\r\ndev_lim->reserved_srqs = 1 << (field >> 4);\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_SRQ_OFFSET);\r\ndev_lim->max_srqs = 1 << (field & 0x1f);\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_EEC_OFFSET);\r\ndev_lim->reserved_eecs = 1 << (field & 0xf);\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_EEC_OFFSET);\r\ndev_lim->max_eecs = 1 << (field & 0x1f);\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_CQ_SZ_OFFSET);\r\ndev_lim->max_cq_sz = 1 << field;\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_CQ_OFFSET);\r\ndev_lim->reserved_cqs = 1 << (field & 0xf);\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_CQ_OFFSET);\r\ndev_lim->max_cqs = 1 << (field & 0x1f);\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_MPT_OFFSET);\r\ndev_lim->max_mpts = 1 << (field & 0x3f);\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_EQ_OFFSET);\r\ndev_lim->reserved_eqs = 1 << (field & 0xf);\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_EQ_OFFSET);\r\ndev_lim->max_eqs = 1 << (field & 0x7);\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_MTT_OFFSET);\r\nif (mthca_is_memfree(dev))\r\ndev_lim->reserved_mtts = ALIGN((1 << (field >> 4)) * sizeof(u64),\r\ndev->limits.mtt_seg_size) / dev->limits.mtt_seg_size;\r\nelse\r\ndev_lim->reserved_mtts = 1 << (field >> 4);\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_MRW_SZ_OFFSET);\r\ndev_lim->max_mrw_sz = 1 << field;\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_MRW_OFFSET);\r\ndev_lim->reserved_mrws = 1 << (field & 0xf);\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_MTT_SEG_OFFSET);\r\ndev_lim->max_mtt_seg = 1 << (field & 0x3f);\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_REQ_QP_OFFSET);\r\ndev_lim->max_requester_per_qp = 1 << (field & 0x3f);\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_RES_QP_OFFSET);\r\ndev_lim->max_responder_per_qp = 1 << (field & 0x3f);\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_RDMA_OFFSET);\r\ndev_lim->max_rdma_global = 1 << (field & 0x3f);\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_ACK_DELAY_OFFSET);\r\ndev_lim->local_ca_ack_delay = field & 0x1f;\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MTU_WIDTH_OFFSET);\r\ndev_lim->max_mtu = field >> 4;\r\ndev_lim->max_port_width = field & 0xf;\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_VL_PORT_OFFSET);\r\ndev_lim->max_vl = field >> 4;\r\ndev_lim->num_ports = field & 0xf;\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_GID_OFFSET);\r\ndev_lim->max_gids = 1 << (field & 0xf);\r\nMTHCA_GET(stat_rate, outbox, QUERY_DEV_LIM_RATE_SUPPORT_OFFSET);\r\ndev_lim->stat_rate_support = stat_rate;\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_PKEY_OFFSET);\r\ndev_lim->max_pkeys = 1 << (field & 0xf);\r\nMTHCA_GET(dev_lim->flags, outbox, QUERY_DEV_LIM_FLAGS_OFFSET);\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_UAR_OFFSET);\r\ndev_lim->reserved_uars = field >> 4;\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_UAR_SZ_OFFSET);\r\ndev_lim->uar_size = 1 << ((field & 0x3f) + 20);\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_PAGE_SZ_OFFSET);\r\ndev_lim->min_page_sz = 1 << field;\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_SG_OFFSET);\r\ndev_lim->max_sg = field;\r\nMTHCA_GET(size, outbox, QUERY_DEV_LIM_MAX_DESC_SZ_OFFSET);\r\ndev_lim->max_desc_sz = size;\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_QP_MCG_OFFSET);\r\ndev_lim->max_qp_per_mcg = 1 << field;\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_MCG_OFFSET);\r\ndev_lim->reserved_mgms = field & 0xf;\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_MCG_OFFSET);\r\ndev_lim->max_mcgs = 1 << field;\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_PD_OFFSET);\r\ndev_lim->reserved_pds = field >> 4;\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_PD_OFFSET);\r\ndev_lim->max_pds = 1 << (field & 0x3f);\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_RDD_OFFSET);\r\ndev_lim->reserved_rdds = field >> 4;\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_RDD_OFFSET);\r\ndev_lim->max_rdds = 1 << (field & 0x3f);\r\nMTHCA_GET(size, outbox, QUERY_DEV_LIM_EEC_ENTRY_SZ_OFFSET);\r\ndev_lim->eec_entry_sz = size;\r\nMTHCA_GET(size, outbox, QUERY_DEV_LIM_QPC_ENTRY_SZ_OFFSET);\r\ndev_lim->qpc_entry_sz = size;\r\nMTHCA_GET(size, outbox, QUERY_DEV_LIM_EEEC_ENTRY_SZ_OFFSET);\r\ndev_lim->eeec_entry_sz = size;\r\nMTHCA_GET(size, outbox, QUERY_DEV_LIM_EQPC_ENTRY_SZ_OFFSET);\r\ndev_lim->eqpc_entry_sz = size;\r\nMTHCA_GET(size, outbox, QUERY_DEV_LIM_EQC_ENTRY_SZ_OFFSET);\r\ndev_lim->eqc_entry_sz = size;\r\nMTHCA_GET(size, outbox, QUERY_DEV_LIM_CQC_ENTRY_SZ_OFFSET);\r\ndev_lim->cqc_entry_sz = size;\r\nMTHCA_GET(size, outbox, QUERY_DEV_LIM_SRQ_ENTRY_SZ_OFFSET);\r\ndev_lim->srq_entry_sz = size;\r\nMTHCA_GET(size, outbox, QUERY_DEV_LIM_UAR_ENTRY_SZ_OFFSET);\r\ndev_lim->uar_scratch_entry_sz = size;\r\nif (mthca_is_memfree(dev)) {\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_SRQ_SZ_OFFSET);\r\ndev_lim->max_srq_sz = 1 << field;\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_QP_SZ_OFFSET);\r\ndev_lim->max_qp_sz = 1 << field;\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSZ_SRQ_OFFSET);\r\ndev_lim->hca.arbel.resize_srq = field & 1;\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_SG_RQ_OFFSET);\r\ndev_lim->max_sg = min_t(int, field, dev_lim->max_sg);\r\nMTHCA_GET(size, outbox, QUERY_DEV_LIM_MAX_DESC_SZ_RQ_OFFSET);\r\ndev_lim->max_desc_sz = min_t(int, size, dev_lim->max_desc_sz);\r\nMTHCA_GET(size, outbox, QUERY_DEV_LIM_MPT_ENTRY_SZ_OFFSET);\r\ndev_lim->mpt_entry_sz = size;\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_PBL_SZ_OFFSET);\r\ndev_lim->hca.arbel.max_pbl_sz = 1 << (field & 0x3f);\r\nMTHCA_GET(dev_lim->hca.arbel.bmme_flags, outbox,\r\nQUERY_DEV_LIM_BMME_FLAGS_OFFSET);\r\nMTHCA_GET(dev_lim->hca.arbel.reserved_lkey, outbox,\r\nQUERY_DEV_LIM_RSVD_LKEY_OFFSET);\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_LAMR_OFFSET);\r\ndev_lim->hca.arbel.lam_required = field & 1;\r\nMTHCA_GET(dev_lim->hca.arbel.max_icm_sz, outbox,\r\nQUERY_DEV_LIM_MAX_ICM_SZ_OFFSET);\r\nif (dev_lim->hca.arbel.bmme_flags & 1)\r\nmthca_dbg(dev, "Base MM extensions: yes "\r\n"(flags %d, max PBL %d, rsvd L_Key %08x)\n",\r\ndev_lim->hca.arbel.bmme_flags,\r\ndev_lim->hca.arbel.max_pbl_sz,\r\ndev_lim->hca.arbel.reserved_lkey);\r\nelse\r\nmthca_dbg(dev, "Base MM extensions: no\n");\r\nmthca_dbg(dev, "Max ICM size %lld MB\n",\r\n(unsigned long long) dev_lim->hca.arbel.max_icm_sz >> 20);\r\n} else {\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_SRQ_SZ_OFFSET);\r\ndev_lim->max_srq_sz = (1 << field) - 1;\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_QP_SZ_OFFSET);\r\ndev_lim->max_qp_sz = (1 << field) - 1;\r\nMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_AV_OFFSET);\r\ndev_lim->hca.tavor.max_avs = 1 << (field & 0x3f);\r\ndev_lim->mpt_entry_sz = MTHCA_MPT_ENTRY_SIZE;\r\n}\r\nmthca_dbg(dev, "Max QPs: %d, reserved QPs: %d, entry size: %d\n",\r\ndev_lim->max_qps, dev_lim->reserved_qps, dev_lim->qpc_entry_sz);\r\nmthca_dbg(dev, "Max SRQs: %d, reserved SRQs: %d, entry size: %d\n",\r\ndev_lim->max_srqs, dev_lim->reserved_srqs, dev_lim->srq_entry_sz);\r\nmthca_dbg(dev, "Max CQs: %d, reserved CQs: %d, entry size: %d\n",\r\ndev_lim->max_cqs, dev_lim->reserved_cqs, dev_lim->cqc_entry_sz);\r\nmthca_dbg(dev, "Max EQs: %d, reserved EQs: %d, entry size: %d\n",\r\ndev_lim->max_eqs, dev_lim->reserved_eqs, dev_lim->eqc_entry_sz);\r\nmthca_dbg(dev, "reserved MPTs: %d, reserved MTTs: %d\n",\r\ndev_lim->reserved_mrws, dev_lim->reserved_mtts);\r\nmthca_dbg(dev, "Max PDs: %d, reserved PDs: %d, reserved UARs: %d\n",\r\ndev_lim->max_pds, dev_lim->reserved_pds, dev_lim->reserved_uars);\r\nmthca_dbg(dev, "Max QP/MCG: %d, reserved MGMs: %d\n",\r\ndev_lim->max_pds, dev_lim->reserved_mgms);\r\nmthca_dbg(dev, "Max CQEs: %d, max WQEs: %d, max SRQ WQEs: %d\n",\r\ndev_lim->max_cq_sz, dev_lim->max_qp_sz, dev_lim->max_srq_sz);\r\nmthca_dbg(dev, "Flags: %08x\n", dev_lim->flags);\r\nout:\r\nmthca_free_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nstatic void get_board_id(void *vsd, char *board_id)\r\n{\r\nint i;\r\n#define VSD_OFFSET_SIG1 0x00\r\n#define VSD_OFFSET_SIG2 0xde\r\n#define VSD_OFFSET_MLX_BOARD_ID 0xd0\r\n#define VSD_OFFSET_TS_BOARD_ID 0x20\r\n#define VSD_SIGNATURE_TOPSPIN 0x5ad\r\nmemset(board_id, 0, MTHCA_BOARD_ID_LEN);\r\nif (be16_to_cpup(vsd + VSD_OFFSET_SIG1) == VSD_SIGNATURE_TOPSPIN &&\r\nbe16_to_cpup(vsd + VSD_OFFSET_SIG2) == VSD_SIGNATURE_TOPSPIN) {\r\nstrlcpy(board_id, vsd + VSD_OFFSET_TS_BOARD_ID, MTHCA_BOARD_ID_LEN);\r\n} else {\r\nfor (i = 0; i < 4; ++i)\r\n((u32 *) board_id)[i] =\r\nswab32(*(u32 *) (vsd + VSD_OFFSET_MLX_BOARD_ID + i * 4));\r\n}\r\n}\r\nint mthca_QUERY_ADAPTER(struct mthca_dev *dev,\r\nstruct mthca_adapter *adapter)\r\n{\r\nstruct mthca_mailbox *mailbox;\r\nu32 *outbox;\r\nint err;\r\n#define QUERY_ADAPTER_OUT_SIZE 0x100\r\n#define QUERY_ADAPTER_VENDOR_ID_OFFSET 0x00\r\n#define QUERY_ADAPTER_DEVICE_ID_OFFSET 0x04\r\n#define QUERY_ADAPTER_REVISION_ID_OFFSET 0x08\r\n#define QUERY_ADAPTER_INTA_PIN_OFFSET 0x10\r\n#define QUERY_ADAPTER_VSD_OFFSET 0x20\r\nmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\noutbox = mailbox->buf;\r\nerr = mthca_cmd_box(dev, 0, mailbox->dma, 0, 0, CMD_QUERY_ADAPTER,\r\nCMD_TIME_CLASS_A);\r\nif (err)\r\ngoto out;\r\nif (!mthca_is_memfree(dev)) {\r\nMTHCA_GET(adapter->vendor_id, outbox,\r\nQUERY_ADAPTER_VENDOR_ID_OFFSET);\r\nMTHCA_GET(adapter->device_id, outbox,\r\nQUERY_ADAPTER_DEVICE_ID_OFFSET);\r\nMTHCA_GET(adapter->revision_id, outbox,\r\nQUERY_ADAPTER_REVISION_ID_OFFSET);\r\n}\r\nMTHCA_GET(adapter->inta_pin, outbox, QUERY_ADAPTER_INTA_PIN_OFFSET);\r\nget_board_id(outbox + QUERY_ADAPTER_VSD_OFFSET / 4,\r\nadapter->board_id);\r\nout:\r\nmthca_free_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nint mthca_INIT_HCA(struct mthca_dev *dev,\r\nstruct mthca_init_hca_param *param)\r\n{\r\nstruct mthca_mailbox *mailbox;\r\n__be32 *inbox;\r\nint err;\r\n#define INIT_HCA_IN_SIZE 0x200\r\n#define INIT_HCA_FLAGS1_OFFSET 0x00c\r\n#define INIT_HCA_FLAGS2_OFFSET 0x014\r\n#define INIT_HCA_QPC_OFFSET 0x020\r\n#define INIT_HCA_QPC_BASE_OFFSET (INIT_HCA_QPC_OFFSET + 0x10)\r\n#define INIT_HCA_LOG_QP_OFFSET (INIT_HCA_QPC_OFFSET + 0x17)\r\n#define INIT_HCA_EEC_BASE_OFFSET (INIT_HCA_QPC_OFFSET + 0x20)\r\n#define INIT_HCA_LOG_EEC_OFFSET (INIT_HCA_QPC_OFFSET + 0x27)\r\n#define INIT_HCA_SRQC_BASE_OFFSET (INIT_HCA_QPC_OFFSET + 0x28)\r\n#define INIT_HCA_LOG_SRQ_OFFSET (INIT_HCA_QPC_OFFSET + 0x2f)\r\n#define INIT_HCA_CQC_BASE_OFFSET (INIT_HCA_QPC_OFFSET + 0x30)\r\n#define INIT_HCA_LOG_CQ_OFFSET (INIT_HCA_QPC_OFFSET + 0x37)\r\n#define INIT_HCA_EQPC_BASE_OFFSET (INIT_HCA_QPC_OFFSET + 0x40)\r\n#define INIT_HCA_EEEC_BASE_OFFSET (INIT_HCA_QPC_OFFSET + 0x50)\r\n#define INIT_HCA_EQC_BASE_OFFSET (INIT_HCA_QPC_OFFSET + 0x60)\r\n#define INIT_HCA_LOG_EQ_OFFSET (INIT_HCA_QPC_OFFSET + 0x67)\r\n#define INIT_HCA_RDB_BASE_OFFSET (INIT_HCA_QPC_OFFSET + 0x70)\r\n#define INIT_HCA_UDAV_OFFSET 0x0b0\r\n#define INIT_HCA_UDAV_LKEY_OFFSET (INIT_HCA_UDAV_OFFSET + 0x0)\r\n#define INIT_HCA_UDAV_PD_OFFSET (INIT_HCA_UDAV_OFFSET + 0x4)\r\n#define INIT_HCA_MCAST_OFFSET 0x0c0\r\n#define INIT_HCA_MC_BASE_OFFSET (INIT_HCA_MCAST_OFFSET + 0x00)\r\n#define INIT_HCA_LOG_MC_ENTRY_SZ_OFFSET (INIT_HCA_MCAST_OFFSET + 0x12)\r\n#define INIT_HCA_MC_HASH_SZ_OFFSET (INIT_HCA_MCAST_OFFSET + 0x16)\r\n#define INIT_HCA_LOG_MC_TABLE_SZ_OFFSET (INIT_HCA_MCAST_OFFSET + 0x1b)\r\n#define INIT_HCA_TPT_OFFSET 0x0f0\r\n#define INIT_HCA_MPT_BASE_OFFSET (INIT_HCA_TPT_OFFSET + 0x00)\r\n#define INIT_HCA_MTT_SEG_SZ_OFFSET (INIT_HCA_TPT_OFFSET + 0x09)\r\n#define INIT_HCA_LOG_MPT_SZ_OFFSET (INIT_HCA_TPT_OFFSET + 0x0b)\r\n#define INIT_HCA_MTT_BASE_OFFSET (INIT_HCA_TPT_OFFSET + 0x10)\r\n#define INIT_HCA_UAR_OFFSET 0x120\r\n#define INIT_HCA_UAR_BASE_OFFSET (INIT_HCA_UAR_OFFSET + 0x00)\r\n#define INIT_HCA_UARC_SZ_OFFSET (INIT_HCA_UAR_OFFSET + 0x09)\r\n#define INIT_HCA_LOG_UAR_SZ_OFFSET (INIT_HCA_UAR_OFFSET + 0x0a)\r\n#define INIT_HCA_UAR_PAGE_SZ_OFFSET (INIT_HCA_UAR_OFFSET + 0x0b)\r\n#define INIT_HCA_UAR_SCATCH_BASE_OFFSET (INIT_HCA_UAR_OFFSET + 0x10)\r\n#define INIT_HCA_UAR_CTX_BASE_OFFSET (INIT_HCA_UAR_OFFSET + 0x18)\r\nmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\ninbox = mailbox->buf;\r\nmemset(inbox, 0, INIT_HCA_IN_SIZE);\r\nif (dev->mthca_flags & MTHCA_FLAG_SINAI_OPT)\r\nMTHCA_PUT(inbox, 0x1, INIT_HCA_FLAGS1_OFFSET);\r\n#if defined(__LITTLE_ENDIAN)\r\n*(inbox + INIT_HCA_FLAGS2_OFFSET / 4) &= ~cpu_to_be32(1 << 1);\r\n#elif defined(__BIG_ENDIAN)\r\n*(inbox + INIT_HCA_FLAGS2_OFFSET / 4) |= cpu_to_be32(1 << 1);\r\n#else\r\n#error Host endianness not defined\r\n#endif\r\n*(inbox + INIT_HCA_FLAGS2_OFFSET / 4) |= cpu_to_be32(1);\r\nif (dev->device_cap_flags & IB_DEVICE_UD_IP_CSUM)\r\n*(inbox + INIT_HCA_FLAGS2_OFFSET / 4) |= cpu_to_be32(7 << 3);\r\nMTHCA_PUT(inbox, param->qpc_base, INIT_HCA_QPC_BASE_OFFSET);\r\nMTHCA_PUT(inbox, param->log_num_qps, INIT_HCA_LOG_QP_OFFSET);\r\nMTHCA_PUT(inbox, param->eec_base, INIT_HCA_EEC_BASE_OFFSET);\r\nMTHCA_PUT(inbox, param->log_num_eecs, INIT_HCA_LOG_EEC_OFFSET);\r\nMTHCA_PUT(inbox, param->srqc_base, INIT_HCA_SRQC_BASE_OFFSET);\r\nMTHCA_PUT(inbox, param->log_num_srqs, INIT_HCA_LOG_SRQ_OFFSET);\r\nMTHCA_PUT(inbox, param->cqc_base, INIT_HCA_CQC_BASE_OFFSET);\r\nMTHCA_PUT(inbox, param->log_num_cqs, INIT_HCA_LOG_CQ_OFFSET);\r\nMTHCA_PUT(inbox, param->eqpc_base, INIT_HCA_EQPC_BASE_OFFSET);\r\nMTHCA_PUT(inbox, param->eeec_base, INIT_HCA_EEEC_BASE_OFFSET);\r\nMTHCA_PUT(inbox, param->eqc_base, INIT_HCA_EQC_BASE_OFFSET);\r\nMTHCA_PUT(inbox, param->log_num_eqs, INIT_HCA_LOG_EQ_OFFSET);\r\nMTHCA_PUT(inbox, param->rdb_base, INIT_HCA_RDB_BASE_OFFSET);\r\nMTHCA_PUT(inbox, param->mc_base, INIT_HCA_MC_BASE_OFFSET);\r\nMTHCA_PUT(inbox, param->log_mc_entry_sz, INIT_HCA_LOG_MC_ENTRY_SZ_OFFSET);\r\nMTHCA_PUT(inbox, param->mc_hash_sz, INIT_HCA_MC_HASH_SZ_OFFSET);\r\nMTHCA_PUT(inbox, param->log_mc_table_sz, INIT_HCA_LOG_MC_TABLE_SZ_OFFSET);\r\nMTHCA_PUT(inbox, param->mpt_base, INIT_HCA_MPT_BASE_OFFSET);\r\nif (!mthca_is_memfree(dev))\r\nMTHCA_PUT(inbox, param->mtt_seg_sz, INIT_HCA_MTT_SEG_SZ_OFFSET);\r\nMTHCA_PUT(inbox, param->log_mpt_sz, INIT_HCA_LOG_MPT_SZ_OFFSET);\r\nMTHCA_PUT(inbox, param->mtt_base, INIT_HCA_MTT_BASE_OFFSET);\r\n{\r\nu8 uar_page_sz = PAGE_SHIFT - 12;\r\nMTHCA_PUT(inbox, uar_page_sz, INIT_HCA_UAR_PAGE_SZ_OFFSET);\r\n}\r\nMTHCA_PUT(inbox, param->uar_scratch_base, INIT_HCA_UAR_SCATCH_BASE_OFFSET);\r\nif (mthca_is_memfree(dev)) {\r\nMTHCA_PUT(inbox, param->log_uarc_sz, INIT_HCA_UARC_SZ_OFFSET);\r\nMTHCA_PUT(inbox, param->log_uar_sz, INIT_HCA_LOG_UAR_SZ_OFFSET);\r\nMTHCA_PUT(inbox, param->uarc_base, INIT_HCA_UAR_CTX_BASE_OFFSET);\r\n}\r\nerr = mthca_cmd(dev, mailbox->dma, 0, 0,\r\nCMD_INIT_HCA, CMD_TIME_CLASS_D);\r\nmthca_free_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nint mthca_INIT_IB(struct mthca_dev *dev,\r\nstruct mthca_init_ib_param *param,\r\nint port)\r\n{\r\nstruct mthca_mailbox *mailbox;\r\nu32 *inbox;\r\nint err;\r\nu32 flags;\r\n#define INIT_IB_IN_SIZE 56\r\n#define INIT_IB_FLAGS_OFFSET 0x00\r\n#define INIT_IB_FLAG_SIG (1 << 18)\r\n#define INIT_IB_FLAG_NG (1 << 17)\r\n#define INIT_IB_FLAG_G0 (1 << 16)\r\n#define INIT_IB_VL_SHIFT 4\r\n#define INIT_IB_PORT_WIDTH_SHIFT 8\r\n#define INIT_IB_MTU_SHIFT 12\r\n#define INIT_IB_MAX_GID_OFFSET 0x06\r\n#define INIT_IB_MAX_PKEY_OFFSET 0x0a\r\n#define INIT_IB_GUID0_OFFSET 0x10\r\n#define INIT_IB_NODE_GUID_OFFSET 0x18\r\n#define INIT_IB_SI_GUID_OFFSET 0x20\r\nmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\ninbox = mailbox->buf;\r\nmemset(inbox, 0, INIT_IB_IN_SIZE);\r\nflags = 0;\r\nflags |= param->set_guid0 ? INIT_IB_FLAG_G0 : 0;\r\nflags |= param->set_node_guid ? INIT_IB_FLAG_NG : 0;\r\nflags |= param->set_si_guid ? INIT_IB_FLAG_SIG : 0;\r\nflags |= param->vl_cap << INIT_IB_VL_SHIFT;\r\nflags |= param->port_width << INIT_IB_PORT_WIDTH_SHIFT;\r\nflags |= param->mtu_cap << INIT_IB_MTU_SHIFT;\r\nMTHCA_PUT(inbox, flags, INIT_IB_FLAGS_OFFSET);\r\nMTHCA_PUT(inbox, param->gid_cap, INIT_IB_MAX_GID_OFFSET);\r\nMTHCA_PUT(inbox, param->pkey_cap, INIT_IB_MAX_PKEY_OFFSET);\r\nMTHCA_PUT(inbox, param->guid0, INIT_IB_GUID0_OFFSET);\r\nMTHCA_PUT(inbox, param->node_guid, INIT_IB_NODE_GUID_OFFSET);\r\nMTHCA_PUT(inbox, param->si_guid, INIT_IB_SI_GUID_OFFSET);\r\nerr = mthca_cmd(dev, mailbox->dma, port, 0, CMD_INIT_IB,\r\nCMD_TIME_CLASS_A);\r\nmthca_free_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nint mthca_CLOSE_IB(struct mthca_dev *dev, int port)\r\n{\r\nreturn mthca_cmd(dev, 0, port, 0, CMD_CLOSE_IB, CMD_TIME_CLASS_A);\r\n}\r\nint mthca_CLOSE_HCA(struct mthca_dev *dev, int panic)\r\n{\r\nreturn mthca_cmd(dev, 0, 0, panic, CMD_CLOSE_HCA, CMD_TIME_CLASS_C);\r\n}\r\nint mthca_SET_IB(struct mthca_dev *dev, struct mthca_set_ib_param *param,\r\nint port)\r\n{\r\nstruct mthca_mailbox *mailbox;\r\nu32 *inbox;\r\nint err;\r\nu32 flags = 0;\r\n#define SET_IB_IN_SIZE 0x40\r\n#define SET_IB_FLAGS_OFFSET 0x00\r\n#define SET_IB_FLAG_SIG (1 << 18)\r\n#define SET_IB_FLAG_RQK (1 << 0)\r\n#define SET_IB_CAP_MASK_OFFSET 0x04\r\n#define SET_IB_SI_GUID_OFFSET 0x08\r\nmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\ninbox = mailbox->buf;\r\nmemset(inbox, 0, SET_IB_IN_SIZE);\r\nflags |= param->set_si_guid ? SET_IB_FLAG_SIG : 0;\r\nflags |= param->reset_qkey_viol ? SET_IB_FLAG_RQK : 0;\r\nMTHCA_PUT(inbox, flags, SET_IB_FLAGS_OFFSET);\r\nMTHCA_PUT(inbox, param->cap_mask, SET_IB_CAP_MASK_OFFSET);\r\nMTHCA_PUT(inbox, param->si_guid, SET_IB_SI_GUID_OFFSET);\r\nerr = mthca_cmd(dev, mailbox->dma, port, 0, CMD_SET_IB,\r\nCMD_TIME_CLASS_B);\r\nmthca_free_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nint mthca_MAP_ICM(struct mthca_dev *dev, struct mthca_icm *icm, u64 virt)\r\n{\r\nreturn mthca_map_cmd(dev, CMD_MAP_ICM, icm, virt);\r\n}\r\nint mthca_MAP_ICM_page(struct mthca_dev *dev, u64 dma_addr, u64 virt)\r\n{\r\nstruct mthca_mailbox *mailbox;\r\n__be64 *inbox;\r\nint err;\r\nmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\ninbox = mailbox->buf;\r\ninbox[0] = cpu_to_be64(virt);\r\ninbox[1] = cpu_to_be64(dma_addr);\r\nerr = mthca_cmd(dev, mailbox->dma, 1, 0, CMD_MAP_ICM,\r\nCMD_TIME_CLASS_B);\r\nmthca_free_mailbox(dev, mailbox);\r\nif (!err)\r\nmthca_dbg(dev, "Mapped page at %llx to %llx for ICM.\n",\r\n(unsigned long long) dma_addr, (unsigned long long) virt);\r\nreturn err;\r\n}\r\nint mthca_UNMAP_ICM(struct mthca_dev *dev, u64 virt, u32 page_count)\r\n{\r\nmthca_dbg(dev, "Unmapping %d pages at %llx from ICM.\n",\r\npage_count, (unsigned long long) virt);\r\nreturn mthca_cmd(dev, virt, page_count, 0,\r\nCMD_UNMAP_ICM, CMD_TIME_CLASS_B);\r\n}\r\nint mthca_MAP_ICM_AUX(struct mthca_dev *dev, struct mthca_icm *icm)\r\n{\r\nreturn mthca_map_cmd(dev, CMD_MAP_ICM_AUX, icm, -1);\r\n}\r\nint mthca_UNMAP_ICM_AUX(struct mthca_dev *dev)\r\n{\r\nreturn mthca_cmd(dev, 0, 0, 0, CMD_UNMAP_ICM_AUX, CMD_TIME_CLASS_B);\r\n}\r\nint mthca_SET_ICM_SIZE(struct mthca_dev *dev, u64 icm_size, u64 *aux_pages)\r\n{\r\nint ret = mthca_cmd_imm(dev, icm_size, aux_pages, 0,\r\n0, CMD_SET_ICM_SIZE, CMD_TIME_CLASS_A);\r\nif (ret)\r\nreturn ret;\r\n*aux_pages = ALIGN(*aux_pages, PAGE_SIZE / MTHCA_ICM_PAGE_SIZE) >>\r\n(PAGE_SHIFT - MTHCA_ICM_PAGE_SHIFT);\r\nreturn 0;\r\n}\r\nint mthca_SW2HW_MPT(struct mthca_dev *dev, struct mthca_mailbox *mailbox,\r\nint mpt_index)\r\n{\r\nreturn mthca_cmd(dev, mailbox->dma, mpt_index, 0, CMD_SW2HW_MPT,\r\nCMD_TIME_CLASS_B);\r\n}\r\nint mthca_HW2SW_MPT(struct mthca_dev *dev, struct mthca_mailbox *mailbox,\r\nint mpt_index)\r\n{\r\nreturn mthca_cmd_box(dev, 0, mailbox ? mailbox->dma : 0, mpt_index,\r\n!mailbox, CMD_HW2SW_MPT,\r\nCMD_TIME_CLASS_B);\r\n}\r\nint mthca_WRITE_MTT(struct mthca_dev *dev, struct mthca_mailbox *mailbox,\r\nint num_mtt)\r\n{\r\nreturn mthca_cmd(dev, mailbox->dma, num_mtt, 0, CMD_WRITE_MTT,\r\nCMD_TIME_CLASS_B);\r\n}\r\nint mthca_SYNC_TPT(struct mthca_dev *dev)\r\n{\r\nreturn mthca_cmd(dev, 0, 0, 0, CMD_SYNC_TPT, CMD_TIME_CLASS_B);\r\n}\r\nint mthca_MAP_EQ(struct mthca_dev *dev, u64 event_mask, int unmap,\r\nint eq_num)\r\n{\r\nmthca_dbg(dev, "%s mask %016llx for eqn %d\n",\r\nunmap ? "Clearing" : "Setting",\r\n(unsigned long long) event_mask, eq_num);\r\nreturn mthca_cmd(dev, event_mask, (unmap << 31) | eq_num,\r\n0, CMD_MAP_EQ, CMD_TIME_CLASS_B);\r\n}\r\nint mthca_SW2HW_EQ(struct mthca_dev *dev, struct mthca_mailbox *mailbox,\r\nint eq_num)\r\n{\r\nreturn mthca_cmd(dev, mailbox->dma, eq_num, 0, CMD_SW2HW_EQ,\r\nCMD_TIME_CLASS_A);\r\n}\r\nint mthca_HW2SW_EQ(struct mthca_dev *dev, struct mthca_mailbox *mailbox,\r\nint eq_num)\r\n{\r\nreturn mthca_cmd_box(dev, 0, mailbox->dma, eq_num, 0,\r\nCMD_HW2SW_EQ,\r\nCMD_TIME_CLASS_A);\r\n}\r\nint mthca_SW2HW_CQ(struct mthca_dev *dev, struct mthca_mailbox *mailbox,\r\nint cq_num)\r\n{\r\nreturn mthca_cmd(dev, mailbox->dma, cq_num, 0, CMD_SW2HW_CQ,\r\nCMD_TIME_CLASS_A);\r\n}\r\nint mthca_HW2SW_CQ(struct mthca_dev *dev, struct mthca_mailbox *mailbox,\r\nint cq_num)\r\n{\r\nreturn mthca_cmd_box(dev, 0, mailbox->dma, cq_num, 0,\r\nCMD_HW2SW_CQ,\r\nCMD_TIME_CLASS_A);\r\n}\r\nint mthca_RESIZE_CQ(struct mthca_dev *dev, int cq_num, u32 lkey, u8 log_size)\r\n{\r\nstruct mthca_mailbox *mailbox;\r\n__be32 *inbox;\r\nint err;\r\n#define RESIZE_CQ_IN_SIZE 0x40\r\n#define RESIZE_CQ_LOG_SIZE_OFFSET 0x0c\r\n#define RESIZE_CQ_LKEY_OFFSET 0x1c\r\nmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\r\nif (IS_ERR(mailbox))\r\nreturn PTR_ERR(mailbox);\r\ninbox = mailbox->buf;\r\nmemset(inbox, 0, RESIZE_CQ_IN_SIZE);\r\nMTHCA_PUT(inbox, log_size, RESIZE_CQ_LOG_SIZE_OFFSET);\r\nMTHCA_PUT(inbox, lkey, RESIZE_CQ_LKEY_OFFSET);\r\nerr = mthca_cmd(dev, mailbox->dma, cq_num, 1, CMD_RESIZE_CQ,\r\nCMD_TIME_CLASS_B);\r\nmthca_free_mailbox(dev, mailbox);\r\nreturn err;\r\n}\r\nint mthca_SW2HW_SRQ(struct mthca_dev *dev, struct mthca_mailbox *mailbox,\r\nint srq_num)\r\n{\r\nreturn mthca_cmd(dev, mailbox->dma, srq_num, 0, CMD_SW2HW_SRQ,\r\nCMD_TIME_CLASS_A);\r\n}\r\nint mthca_HW2SW_SRQ(struct mthca_dev *dev, struct mthca_mailbox *mailbox,\r\nint srq_num)\r\n{\r\nreturn mthca_cmd_box(dev, 0, mailbox->dma, srq_num, 0,\r\nCMD_HW2SW_SRQ,\r\nCMD_TIME_CLASS_A);\r\n}\r\nint mthca_QUERY_SRQ(struct mthca_dev *dev, u32 num,\r\nstruct mthca_mailbox *mailbox)\r\n{\r\nreturn mthca_cmd_box(dev, 0, mailbox->dma, num, 0,\r\nCMD_QUERY_SRQ, CMD_TIME_CLASS_A);\r\n}\r\nint mthca_ARM_SRQ(struct mthca_dev *dev, int srq_num, int limit)\r\n{\r\nreturn mthca_cmd(dev, limit, srq_num, 0, CMD_ARM_SRQ,\r\nCMD_TIME_CLASS_B);\r\n}\r\nint mthca_MODIFY_QP(struct mthca_dev *dev, enum ib_qp_state cur,\r\nenum ib_qp_state next, u32 num, int is_ee,\r\nstruct mthca_mailbox *mailbox, u32 optmask)\r\n{\r\nstatic const u16 op[IB_QPS_ERR + 1][IB_QPS_ERR + 1] = {\r\n[IB_QPS_RESET] = {\r\n[IB_QPS_RESET] = CMD_ERR2RST_QPEE,\r\n[IB_QPS_ERR] = CMD_2ERR_QPEE,\r\n[IB_QPS_INIT] = CMD_RST2INIT_QPEE,\r\n},\r\n[IB_QPS_INIT] = {\r\n[IB_QPS_RESET] = CMD_ERR2RST_QPEE,\r\n[IB_QPS_ERR] = CMD_2ERR_QPEE,\r\n[IB_QPS_INIT] = CMD_INIT2INIT_QPEE,\r\n[IB_QPS_RTR] = CMD_INIT2RTR_QPEE,\r\n},\r\n[IB_QPS_RTR] = {\r\n[IB_QPS_RESET] = CMD_ERR2RST_QPEE,\r\n[IB_QPS_ERR] = CMD_2ERR_QPEE,\r\n[IB_QPS_RTS] = CMD_RTR2RTS_QPEE,\r\n},\r\n[IB_QPS_RTS] = {\r\n[IB_QPS_RESET] = CMD_ERR2RST_QPEE,\r\n[IB_QPS_ERR] = CMD_2ERR_QPEE,\r\n[IB_QPS_RTS] = CMD_RTS2RTS_QPEE,\r\n[IB_QPS_SQD] = CMD_RTS2SQD_QPEE,\r\n},\r\n[IB_QPS_SQD] = {\r\n[IB_QPS_RESET] = CMD_ERR2RST_QPEE,\r\n[IB_QPS_ERR] = CMD_2ERR_QPEE,\r\n[IB_QPS_RTS] = CMD_SQD2RTS_QPEE,\r\n[IB_QPS_SQD] = CMD_SQD2SQD_QPEE,\r\n},\r\n[IB_QPS_SQE] = {\r\n[IB_QPS_RESET] = CMD_ERR2RST_QPEE,\r\n[IB_QPS_ERR] = CMD_2ERR_QPEE,\r\n[IB_QPS_RTS] = CMD_SQERR2RTS_QPEE,\r\n},\r\n[IB_QPS_ERR] = {\r\n[IB_QPS_RESET] = CMD_ERR2RST_QPEE,\r\n[IB_QPS_ERR] = CMD_2ERR_QPEE,\r\n}\r\n};\r\nu8 op_mod = 0;\r\nint my_mailbox = 0;\r\nint err;\r\nif (op[cur][next] == CMD_ERR2RST_QPEE) {\r\nop_mod = 3;\r\nif (!mailbox) {\r\nmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\r\nif (!IS_ERR(mailbox)) {\r\nmy_mailbox = 1;\r\nop_mod = 2;\r\n} else\r\nmailbox = NULL;\r\n}\r\nerr = mthca_cmd_box(dev, 0, mailbox ? mailbox->dma : 0,\r\n(!!is_ee << 24) | num, op_mod,\r\nop[cur][next], CMD_TIME_CLASS_C);\r\nif (0 && mailbox) {\r\nint i;\r\nmthca_dbg(dev, "Dumping QP context:\n");\r\nprintk(" %08x\n", be32_to_cpup(mailbox->buf));\r\nfor (i = 0; i < 0x100 / 4; ++i) {\r\nif (i % 8 == 0)\r\nprintk("[%02x] ", i * 4);\r\nprintk(" %08x",\r\nbe32_to_cpu(((__be32 *) mailbox->buf)[i + 2]));\r\nif ((i + 1) % 8 == 0)\r\nprintk("\n");\r\n}\r\n}\r\nif (my_mailbox)\r\nmthca_free_mailbox(dev, mailbox);\r\n} else {\r\nif (0) {\r\nint i;\r\nmthca_dbg(dev, "Dumping QP context:\n");\r\nprintk(" opt param mask: %08x\n", be32_to_cpup(mailbox->buf));\r\nfor (i = 0; i < 0x100 / 4; ++i) {\r\nif (i % 8 == 0)\r\nprintk(" [%02x] ", i * 4);\r\nprintk(" %08x",\r\nbe32_to_cpu(((__be32 *) mailbox->buf)[i + 2]));\r\nif ((i + 1) % 8 == 0)\r\nprintk("\n");\r\n}\r\n}\r\nerr = mthca_cmd(dev, mailbox->dma, optmask | (!!is_ee << 24) | num,\r\nop_mod, op[cur][next], CMD_TIME_CLASS_C);\r\n}\r\nreturn err;\r\n}\r\nint mthca_QUERY_QP(struct mthca_dev *dev, u32 num, int is_ee,\r\nstruct mthca_mailbox *mailbox)\r\n{\r\nreturn mthca_cmd_box(dev, 0, mailbox->dma, (!!is_ee << 24) | num, 0,\r\nCMD_QUERY_QPEE, CMD_TIME_CLASS_A);\r\n}\r\nint mthca_CONF_SPECIAL_QP(struct mthca_dev *dev, int type, u32 qpn)\r\n{\r\nu8 op_mod;\r\nswitch (type) {\r\ncase IB_QPT_SMI:\r\nop_mod = 0;\r\nbreak;\r\ncase IB_QPT_GSI:\r\nop_mod = 1;\r\nbreak;\r\ncase IB_QPT_RAW_IPV6:\r\nop_mod = 2;\r\nbreak;\r\ncase IB_QPT_RAW_ETHERTYPE:\r\nop_mod = 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn mthca_cmd(dev, 0, qpn, op_mod, CMD_CONF_SPECIAL_QP,\r\nCMD_TIME_CLASS_B);\r\n}\r\nint mthca_MAD_IFC(struct mthca_dev *dev, int ignore_mkey, int ignore_bkey,\r\nint port, struct ib_wc *in_wc, struct ib_grh *in_grh,\r\nvoid *in_mad, void *response_mad)\r\n{\r\nstruct mthca_mailbox *inmailbox, *outmailbox;\r\nvoid *inbox;\r\nint err;\r\nu32 in_modifier = port;\r\nu8 op_modifier = 0;\r\n#define MAD_IFC_BOX_SIZE 0x400\r\n#define MAD_IFC_MY_QPN_OFFSET 0x100\r\n#define MAD_IFC_RQPN_OFFSET 0x108\r\n#define MAD_IFC_SL_OFFSET 0x10c\r\n#define MAD_IFC_G_PATH_OFFSET 0x10d\r\n#define MAD_IFC_RLID_OFFSET 0x10e\r\n#define MAD_IFC_PKEY_OFFSET 0x112\r\n#define MAD_IFC_GRH_OFFSET 0x140\r\ninmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\r\nif (IS_ERR(inmailbox))\r\nreturn PTR_ERR(inmailbox);\r\ninbox = inmailbox->buf;\r\noutmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\r\nif (IS_ERR(outmailbox)) {\r\nmthca_free_mailbox(dev, inmailbox);\r\nreturn PTR_ERR(outmailbox);\r\n}\r\nmemcpy(inbox, in_mad, 256);\r\nif (ignore_mkey || !in_wc)\r\nop_modifier |= 0x1;\r\nif (ignore_bkey || !in_wc)\r\nop_modifier |= 0x2;\r\nif (in_wc) {\r\nu8 val;\r\nmemset(inbox + 256, 0, 256);\r\nMTHCA_PUT(inbox, in_wc->qp->qp_num, MAD_IFC_MY_QPN_OFFSET);\r\nMTHCA_PUT(inbox, in_wc->src_qp, MAD_IFC_RQPN_OFFSET);\r\nval = in_wc->sl << 4;\r\nMTHCA_PUT(inbox, val, MAD_IFC_SL_OFFSET);\r\nval = in_wc->dlid_path_bits |\r\n(in_wc->wc_flags & IB_WC_GRH ? 0x80 : 0);\r\nMTHCA_PUT(inbox, val, MAD_IFC_G_PATH_OFFSET);\r\nMTHCA_PUT(inbox, in_wc->slid, MAD_IFC_RLID_OFFSET);\r\nMTHCA_PUT(inbox, in_wc->pkey_index, MAD_IFC_PKEY_OFFSET);\r\nif (in_grh)\r\nmemcpy(inbox + MAD_IFC_GRH_OFFSET, in_grh, 40);\r\nop_modifier |= 0x4;\r\nin_modifier |= in_wc->slid << 16;\r\n}\r\nerr = mthca_cmd_box(dev, inmailbox->dma, outmailbox->dma,\r\nin_modifier, op_modifier,\r\nCMD_MAD_IFC, CMD_TIME_CLASS_C);\r\nif (!err)\r\nmemcpy(response_mad, outmailbox->buf, 256);\r\nmthca_free_mailbox(dev, inmailbox);\r\nmthca_free_mailbox(dev, outmailbox);\r\nreturn err;\r\n}\r\nint mthca_READ_MGM(struct mthca_dev *dev, int index,\r\nstruct mthca_mailbox *mailbox)\r\n{\r\nreturn mthca_cmd_box(dev, 0, mailbox->dma, index, 0,\r\nCMD_READ_MGM, CMD_TIME_CLASS_A);\r\n}\r\nint mthca_WRITE_MGM(struct mthca_dev *dev, int index,\r\nstruct mthca_mailbox *mailbox)\r\n{\r\nreturn mthca_cmd(dev, mailbox->dma, index, 0, CMD_WRITE_MGM,\r\nCMD_TIME_CLASS_A);\r\n}\r\nint mthca_MGID_HASH(struct mthca_dev *dev, struct mthca_mailbox *mailbox,\r\nu16 *hash)\r\n{\r\nu64 imm;\r\nint err;\r\nerr = mthca_cmd_imm(dev, mailbox->dma, &imm, 0, 0, CMD_MGID_HASH,\r\nCMD_TIME_CLASS_A);\r\n*hash = imm;\r\nreturn err;\r\n}\r\nint mthca_NOP(struct mthca_dev *dev)\r\n{\r\nreturn mthca_cmd(dev, 0, 0x1f, 0, CMD_NOP, msecs_to_jiffies(100));\r\n}
