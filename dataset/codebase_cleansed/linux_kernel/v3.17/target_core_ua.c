sense_reason_t\r\ntarget_scsi3_ua_check(struct se_cmd *cmd)\r\n{\r\nstruct se_dev_entry *deve;\r\nstruct se_session *sess = cmd->se_sess;\r\nstruct se_node_acl *nacl;\r\nif (!sess)\r\nreturn 0;\r\nnacl = sess->se_node_acl;\r\nif (!nacl)\r\nreturn 0;\r\ndeve = nacl->device_list[cmd->orig_fe_lun];\r\nif (!atomic_read(&deve->ua_count))\r\nreturn 0;\r\nswitch (cmd->t_task_cdb[0]) {\r\ncase INQUIRY:\r\ncase REPORT_LUNS:\r\ncase REQUEST_SENSE:\r\nreturn 0;\r\ndefault:\r\nreturn TCM_CHECK_CONDITION_UNIT_ATTENTION;\r\n}\r\n}\r\nint core_scsi3_ua_allocate(\r\nstruct se_node_acl *nacl,\r\nu32 unpacked_lun,\r\nu8 asc,\r\nu8 ascq)\r\n{\r\nstruct se_dev_entry *deve;\r\nstruct se_ua *ua, *ua_p, *ua_tmp;\r\nif (!nacl)\r\nreturn -EINVAL;\r\nua = kmem_cache_zalloc(se_ua_cache, GFP_ATOMIC);\r\nif (!ua) {\r\npr_err("Unable to allocate struct se_ua\n");\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&ua->ua_nacl_list);\r\nua->ua_nacl = nacl;\r\nua->ua_asc = asc;\r\nua->ua_ascq = ascq;\r\nspin_lock_irq(&nacl->device_list_lock);\r\ndeve = nacl->device_list[unpacked_lun];\r\nspin_lock(&deve->ua_lock);\r\nlist_for_each_entry_safe(ua_p, ua_tmp, &deve->ua_list, ua_nacl_list) {\r\nif ((ua_p->ua_asc == asc) && (ua_p->ua_ascq == ascq)) {\r\nspin_unlock(&deve->ua_lock);\r\nspin_unlock_irq(&nacl->device_list_lock);\r\nkmem_cache_free(se_ua_cache, ua);\r\nreturn 0;\r\n}\r\nif (ua_p->ua_asc == 0x29) {\r\nif ((asc == 0x29) && (ascq > ua_p->ua_ascq))\r\nlist_add(&ua->ua_nacl_list,\r\n&deve->ua_list);\r\nelse\r\nlist_add_tail(&ua->ua_nacl_list,\r\n&deve->ua_list);\r\n} else if (ua_p->ua_asc == 0x2a) {\r\nif ((asc == 0x29) || (ascq > ua_p->ua_asc))\r\nlist_add(&ua->ua_nacl_list,\r\n&deve->ua_list);\r\nelse\r\nlist_add_tail(&ua->ua_nacl_list,\r\n&deve->ua_list);\r\n} else\r\nlist_add_tail(&ua->ua_nacl_list,\r\n&deve->ua_list);\r\nspin_unlock(&deve->ua_lock);\r\nspin_unlock_irq(&nacl->device_list_lock);\r\natomic_inc(&deve->ua_count);\r\nsmp_mb__after_atomic();\r\nreturn 0;\r\n}\r\nlist_add_tail(&ua->ua_nacl_list, &deve->ua_list);\r\nspin_unlock(&deve->ua_lock);\r\nspin_unlock_irq(&nacl->device_list_lock);\r\npr_debug("[%s]: Allocated UNIT ATTENTION, mapped LUN: %u, ASC:"\r\n" 0x%02x, ASCQ: 0x%02x\n",\r\nnacl->se_tpg->se_tpg_tfo->get_fabric_name(), unpacked_lun,\r\nasc, ascq);\r\natomic_inc(&deve->ua_count);\r\nsmp_mb__after_atomic();\r\nreturn 0;\r\n}\r\nvoid core_scsi3_ua_release_all(\r\nstruct se_dev_entry *deve)\r\n{\r\nstruct se_ua *ua, *ua_p;\r\nspin_lock(&deve->ua_lock);\r\nlist_for_each_entry_safe(ua, ua_p, &deve->ua_list, ua_nacl_list) {\r\nlist_del(&ua->ua_nacl_list);\r\nkmem_cache_free(se_ua_cache, ua);\r\natomic_dec(&deve->ua_count);\r\nsmp_mb__after_atomic();\r\n}\r\nspin_unlock(&deve->ua_lock);\r\n}\r\nvoid core_scsi3_ua_for_check_condition(\r\nstruct se_cmd *cmd,\r\nu8 *asc,\r\nu8 *ascq)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_dev_entry *deve;\r\nstruct se_session *sess = cmd->se_sess;\r\nstruct se_node_acl *nacl;\r\nstruct se_ua *ua = NULL, *ua_p;\r\nint head = 1;\r\nif (!sess)\r\nreturn;\r\nnacl = sess->se_node_acl;\r\nif (!nacl)\r\nreturn;\r\nspin_lock_irq(&nacl->device_list_lock);\r\ndeve = nacl->device_list[cmd->orig_fe_lun];\r\nif (!atomic_read(&deve->ua_count)) {\r\nspin_unlock_irq(&nacl->device_list_lock);\r\nreturn;\r\n}\r\nspin_lock(&deve->ua_lock);\r\nlist_for_each_entry_safe(ua, ua_p, &deve->ua_list, ua_nacl_list) {\r\nif (dev->dev_attrib.emulate_ua_intlck_ctrl != 0) {\r\n*asc = ua->ua_asc;\r\n*ascq = ua->ua_ascq;\r\nbreak;\r\n}\r\nif (head) {\r\n*asc = ua->ua_asc;\r\n*ascq = ua->ua_ascq;\r\nhead = 0;\r\n}\r\nlist_del(&ua->ua_nacl_list);\r\nkmem_cache_free(se_ua_cache, ua);\r\natomic_dec(&deve->ua_count);\r\nsmp_mb__after_atomic();\r\n}\r\nspin_unlock(&deve->ua_lock);\r\nspin_unlock_irq(&nacl->device_list_lock);\r\npr_debug("[%s]: %s UNIT ATTENTION condition with"\r\n" INTLCK_CTRL: %d, mapped LUN: %u, got CDB: 0x%02x"\r\n" reported ASC: 0x%02x, ASCQ: 0x%02x\n",\r\nnacl->se_tpg->se_tpg_tfo->get_fabric_name(),\r\n(dev->dev_attrib.emulate_ua_intlck_ctrl != 0) ? "Reporting" :\r\n"Releasing", dev->dev_attrib.emulate_ua_intlck_ctrl,\r\ncmd->orig_fe_lun, cmd->t_task_cdb[0], *asc, *ascq);\r\n}\r\nint core_scsi3_ua_clear_for_request_sense(\r\nstruct se_cmd *cmd,\r\nu8 *asc,\r\nu8 *ascq)\r\n{\r\nstruct se_dev_entry *deve;\r\nstruct se_session *sess = cmd->se_sess;\r\nstruct se_node_acl *nacl;\r\nstruct se_ua *ua = NULL, *ua_p;\r\nint head = 1;\r\nif (!sess)\r\nreturn -EINVAL;\r\nnacl = sess->se_node_acl;\r\nif (!nacl)\r\nreturn -EINVAL;\r\nspin_lock_irq(&nacl->device_list_lock);\r\ndeve = nacl->device_list[cmd->orig_fe_lun];\r\nif (!atomic_read(&deve->ua_count)) {\r\nspin_unlock_irq(&nacl->device_list_lock);\r\nreturn -EPERM;\r\n}\r\nspin_lock(&deve->ua_lock);\r\nlist_for_each_entry_safe(ua, ua_p, &deve->ua_list, ua_nacl_list) {\r\nif (head) {\r\n*asc = ua->ua_asc;\r\n*ascq = ua->ua_ascq;\r\nhead = 0;\r\n}\r\nlist_del(&ua->ua_nacl_list);\r\nkmem_cache_free(se_ua_cache, ua);\r\natomic_dec(&deve->ua_count);\r\nsmp_mb__after_atomic();\r\n}\r\nspin_unlock(&deve->ua_lock);\r\nspin_unlock_irq(&nacl->device_list_lock);\r\npr_debug("[%s]: Released UNIT ATTENTION condition, mapped"\r\n" LUN: %u, got REQUEST_SENSE reported ASC: 0x%02x,"\r\n" ASCQ: 0x%02x\n", nacl->se_tpg->se_tpg_tfo->get_fabric_name(),\r\ncmd->orig_fe_lun, *asc, *ascq);\r\nreturn (head) ? -EPERM : 0;\r\n}
