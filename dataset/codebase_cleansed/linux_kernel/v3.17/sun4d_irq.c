static unsigned int sun4d_encode_irq(int board, int lvl, int slot)\r\n{\r\nreturn (board + 1) << 5 | (lvl << 2) | slot;\r\n}\r\nstatic void sun4d_sbus_handler_irq(int sbusl)\r\n{\r\nunsigned int bus_mask;\r\nunsigned int sbino, slot;\r\nunsigned int sbil;\r\nbus_mask = bw_get_intr_mask(sbusl) & 0x3ffff;\r\nbw_clear_intr_mask(sbusl, bus_mask);\r\nsbil = (sbusl << 2);\r\nfor (sbino = 0; bus_mask; sbino++, bus_mask >>= 1) {\r\nunsigned int idx, mask;\r\nif (!(bus_mask & 1))\r\ncontinue;\r\nmask = acquire_sbi(SBI2DEVID(sbino), 0xf << sbil);\r\nmask &= (0xf << sbil);\r\nslot = (1 << sbil);\r\nfor (idx = 0; mask != 0; idx++, slot <<= 1) {\r\nunsigned int pil;\r\nstruct irq_bucket *p;\r\nif (!(mask & slot))\r\ncontinue;\r\nmask &= ~slot;\r\npil = sun4d_encode_irq(sbino, sbusl, idx);\r\np = irq_map[pil];\r\nwhile (p) {\r\nstruct irq_bucket *next;\r\nnext = p->next;\r\ngeneric_handle_irq(p->irq);\r\np = next;\r\n}\r\nrelease_sbi(SBI2DEVID(sbino), slot);\r\n}\r\n}\r\n}\r\nvoid sun4d_handler_irq(unsigned int pil, struct pt_regs *regs)\r\n{\r\nstruct pt_regs *old_regs;\r\nint sbusl = pil_to_sbus[pil];\r\ncc_get_ipen();\r\ncc_set_iclr(1 << pil);\r\n#ifdef CONFIG_SMP\r\nif (pil == SUN4D_IPI_IRQ)\r\nsun4d_ipi_interrupt();\r\n#endif\r\nold_regs = set_irq_regs(regs);\r\nirq_enter();\r\nif (sbusl == 0) {\r\nstruct irq_bucket *p;\r\np = irq_map[pil];\r\nwhile (p) {\r\nstruct irq_bucket *next;\r\nnext = p->next;\r\ngeneric_handle_irq(p->irq);\r\np = next;\r\n}\r\n} else {\r\nsun4d_sbus_handler_irq(sbusl);\r\n}\r\nirq_exit();\r\nset_irq_regs(old_regs);\r\n}\r\nstatic void sun4d_mask_irq(struct irq_data *data)\r\n{\r\nstruct sun4d_handler_data *handler_data = data->handler_data;\r\nunsigned int real_irq;\r\n#ifdef CONFIG_SMP\r\nint cpuid = handler_data->cpuid;\r\nunsigned long flags;\r\n#endif\r\nreal_irq = handler_data->real_irq;\r\n#ifdef CONFIG_SMP\r\nspin_lock_irqsave(&sun4d_imsk_lock, flags);\r\ncc_set_imsk_other(cpuid, cc_get_imsk_other(cpuid) | (1 << real_irq));\r\nspin_unlock_irqrestore(&sun4d_imsk_lock, flags);\r\n#else\r\ncc_set_imsk(cc_get_imsk() | (1 << real_irq));\r\n#endif\r\n}\r\nstatic void sun4d_unmask_irq(struct irq_data *data)\r\n{\r\nstruct sun4d_handler_data *handler_data = data->handler_data;\r\nunsigned int real_irq;\r\n#ifdef CONFIG_SMP\r\nint cpuid = handler_data->cpuid;\r\nunsigned long flags;\r\n#endif\r\nreal_irq = handler_data->real_irq;\r\n#ifdef CONFIG_SMP\r\nspin_lock_irqsave(&sun4d_imsk_lock, flags);\r\ncc_set_imsk_other(cpuid, cc_get_imsk_other(cpuid) & ~(1 << real_irq));\r\nspin_unlock_irqrestore(&sun4d_imsk_lock, flags);\r\n#else\r\ncc_set_imsk(cc_get_imsk() & ~(1 << real_irq));\r\n#endif\r\n}\r\nstatic unsigned int sun4d_startup_irq(struct irq_data *data)\r\n{\r\nirq_link(data->irq);\r\nsun4d_unmask_irq(data);\r\nreturn 0;\r\n}\r\nstatic void sun4d_shutdown_irq(struct irq_data *data)\r\n{\r\nsun4d_mask_irq(data);\r\nirq_unlink(data->irq);\r\n}\r\nvoid __init sun4d_distribute_irqs(void)\r\n{\r\nstruct device_node *dp;\r\nint cpuid = cpu_logical_map(1);\r\nif (cpuid == -1)\r\ncpuid = cpu_logical_map(0);\r\nfor_each_node_by_name(dp, "sbi") {\r\nint devid = of_getintprop_default(dp, "device-id", 0);\r\nint board = of_getintprop_default(dp, "board#", 0);\r\nboard_to_cpu[board] = cpuid;\r\nset_sbi_tid(devid, cpuid << 3);\r\n}\r\nprintk(KERN_ERR "All sbus IRQs directed to CPU%d\n", cpuid);\r\n}\r\nstatic void sun4d_clear_clock_irq(void)\r\n{\r\nsbus_readl(&sun4d_timers->l10_timer_limit);\r\n}\r\nstatic void sun4d_load_profile_irq(int cpu, unsigned int limit)\r\n{\r\nunsigned int value = limit ? timer_value(limit) : 0;\r\nbw_set_prof_limit(cpu, value);\r\n}\r\nstatic void __init sun4d_load_profile_irqs(void)\r\n{\r\nint cpu = 0, mid;\r\nwhile (!cpu_find_by_instance(cpu, NULL, &mid)) {\r\nsun4d_load_profile_irq(mid >> 3, 0);\r\ncpu++;\r\n}\r\n}\r\nstatic unsigned int _sun4d_build_device_irq(unsigned int real_irq,\r\nunsigned int pil,\r\nunsigned int board)\r\n{\r\nstruct sun4d_handler_data *handler_data;\r\nunsigned int irq;\r\nirq = irq_alloc(real_irq, pil);\r\nif (irq == 0) {\r\nprom_printf("IRQ: allocate for %d %d %d failed\n",\r\nreal_irq, pil, board);\r\ngoto err_out;\r\n}\r\nhandler_data = irq_get_handler_data(irq);\r\nif (unlikely(handler_data))\r\ngoto err_out;\r\nhandler_data = kzalloc(sizeof(struct sun4d_handler_data), GFP_ATOMIC);\r\nif (unlikely(!handler_data)) {\r\nprom_printf("IRQ: kzalloc(sun4d_handler_data) failed.\n");\r\nprom_halt();\r\n}\r\nhandler_data->cpuid = board_to_cpu[board];\r\nhandler_data->real_irq = real_irq;\r\nirq_set_chip_and_handler_name(irq, &sun4d_irq,\r\nhandle_level_irq, "level");\r\nirq_set_handler_data(irq, handler_data);\r\nerr_out:\r\nreturn irq;\r\n}\r\nstatic unsigned int sun4d_build_device_irq(struct platform_device *op,\r\nunsigned int real_irq)\r\n{\r\nstruct device_node *dp = op->dev.of_node;\r\nstruct device_node *board_parent, *bus = dp->parent;\r\nchar *bus_connection;\r\nconst struct linux_prom_registers *regs;\r\nunsigned int pil;\r\nunsigned int irq;\r\nint board, slot;\r\nint sbusl;\r\nirq = real_irq;\r\nwhile (bus) {\r\nif (!strcmp(bus->name, "sbi")) {\r\nbus_connection = "io-unit";\r\nbreak;\r\n}\r\nif (!strcmp(bus->name, "bootbus")) {\r\nbus_connection = "cpu-unit";\r\nbreak;\r\n}\r\nbus = bus->parent;\r\n}\r\nif (!bus)\r\ngoto err_out;\r\nregs = of_get_property(dp, "reg", NULL);\r\nif (!regs)\r\ngoto err_out;\r\nslot = regs->which_io;\r\nif (!bus->parent || strcmp(bus->parent->name, bus_connection)) {\r\nprintk(KERN_ERR "%s: Error, parent is not %s.\n",\r\nbus->full_name, bus_connection);\r\ngoto err_out;\r\n}\r\nboard_parent = bus->parent;\r\nboard = of_getintprop_default(board_parent, "board#", -1);\r\nif (board == -1) {\r\nprintk(KERN_ERR "%s: Error, lacks board# property.\n",\r\nboard_parent->full_name);\r\ngoto err_out;\r\n}\r\nsbusl = pil_to_sbus[real_irq];\r\nif (sbusl)\r\npil = sun4d_encode_irq(board, sbusl, slot);\r\nelse\r\npil = real_irq;\r\nirq = _sun4d_build_device_irq(real_irq, pil, board);\r\nerr_out:\r\nreturn irq;\r\n}\r\nstatic unsigned int sun4d_build_timer_irq(unsigned int board,\r\nunsigned int real_irq)\r\n{\r\nreturn _sun4d_build_device_irq(real_irq, real_irq, board);\r\n}\r\nstatic void __init sun4d_fixup_trap_table(void)\r\n{\r\n#ifdef CONFIG_SMP\r\nunsigned long flags;\r\nstruct tt_entry *trap_table = &sparc_ttable[SP_TRAP_IRQ1 + (14 - 1)];\r\nlvl14_save[2] += smp4d_ticker - real_irq_entry;\r\nlocal_irq_save(flags);\r\npatchme_maybe_smp_msg[0] = 0x01000000;\r\ntrap_table->inst_one = lvl14_save[0];\r\ntrap_table->inst_two = lvl14_save[1];\r\ntrap_table->inst_three = lvl14_save[2];\r\ntrap_table->inst_four = lvl14_save[3];\r\nlocal_ops->cache_all();\r\nlocal_irq_restore(flags);\r\n#endif\r\n}\r\nstatic void __init sun4d_init_timers(void)\r\n{\r\nstruct device_node *dp;\r\nstruct resource res;\r\nunsigned int irq;\r\nconst u32 *reg;\r\nint err;\r\nint board;\r\ndp = of_find_node_by_name(NULL, "cpu-unit");\r\nif (!dp) {\r\nprom_printf("sun4d_init_timers: Unable to find cpu-unit\n");\r\nprom_halt();\r\n}\r\nreg = of_get_property(dp, "reg", NULL);\r\nif (!reg) {\r\nprom_printf("sun4d_init_timers: No reg property\n");\r\nprom_halt();\r\n}\r\nboard = of_getintprop_default(dp, "board#", -1);\r\nif (board == -1) {\r\nprom_printf("sun4d_init_timers: No board# property on cpu-unit\n");\r\nprom_halt();\r\n}\r\nof_node_put(dp);\r\nres.start = reg[1];\r\nres.end = reg[2] - 1;\r\nres.flags = reg[0] & 0xff;\r\nsun4d_timers = of_ioremap(&res, BW_TIMER_LIMIT,\r\nsizeof(struct sun4d_timer_regs), "user timer");\r\nif (!sun4d_timers) {\r\nprom_printf("sun4d_init_timers: Can't map timer regs\n");\r\nprom_halt();\r\n}\r\n#ifdef CONFIG_SMP\r\nsparc_config.cs_period = SBUS_CLOCK_RATE * 2;\r\n#else\r\nsparc_config.cs_period = SBUS_CLOCK_RATE / HZ;\r\nsparc_config.features |= FEAT_L10_CLOCKEVENT;\r\n#endif\r\nsparc_config.features |= FEAT_L10_CLOCKSOURCE;\r\nsbus_writel(timer_value(sparc_config.cs_period),\r\n&sun4d_timers->l10_timer_limit);\r\nmaster_l10_counter = &sun4d_timers->l10_cur_count;\r\nirq = sun4d_build_timer_irq(board, SUN4D_TIMER_IRQ);\r\nerr = request_irq(irq, timer_interrupt, IRQF_TIMER, "timer", NULL);\r\nif (err) {\r\nprom_printf("sun4d_init_timers: request_irq() failed with %d\n",\r\nerr);\r\nprom_halt();\r\n}\r\nsun4d_load_profile_irqs();\r\nsun4d_fixup_trap_table();\r\n}\r\nvoid __init sun4d_init_sbi_irq(void)\r\n{\r\nstruct device_node *dp;\r\nint target_cpu;\r\ntarget_cpu = boot_cpu_id;\r\nfor_each_node_by_name(dp, "sbi") {\r\nint devid = of_getintprop_default(dp, "device-id", 0);\r\nint board = of_getintprop_default(dp, "board#", 0);\r\nunsigned int mask;\r\nset_sbi_tid(devid, target_cpu << 3);\r\nboard_to_cpu[board] = target_cpu;\r\nmask = acquire_sbi(devid, 0xffffffff);\r\nif (mask) {\r\nprintk(KERN_ERR "Clearing pending IRQs %08x on SBI %d\n",\r\nmask, board);\r\nrelease_sbi(devid, mask);\r\n}\r\n}\r\n}\r\nvoid __init sun4d_init_IRQ(void)\r\n{\r\nlocal_irq_disable();\r\nsparc_config.init_timers = sun4d_init_timers;\r\nsparc_config.build_device_irq = sun4d_build_device_irq;\r\nsparc_config.clock_rate = SBUS_CLOCK_RATE;\r\nsparc_config.clear_clock_irq = sun4d_clear_clock_irq;\r\nsparc_config.load_profile_irq = sun4d_load_profile_irq;\r\n}
