int pccard_read_tuple(struct pcmcia_socket *s, unsigned int function,\r\ncisdata_t code, void *parse)\r\n{\r\ntuple_t tuple;\r\ncisdata_t *buf;\r\nint ret;\r\nbuf = kmalloc(256, GFP_KERNEL);\r\nif (buf == NULL) {\r\ndev_printk(KERN_WARNING, &s->dev, "no memory to read tuple\n");\r\nreturn -ENOMEM;\r\n}\r\ntuple.DesiredTuple = code;\r\ntuple.Attributes = 0;\r\nif (function == BIND_FN_ALL)\r\ntuple.Attributes = TUPLE_RETURN_COMMON;\r\nret = pccard_get_first_tuple(s, function, &tuple);\r\nif (ret != 0)\r\ngoto done;\r\ntuple.TupleData = buf;\r\ntuple.TupleOffset = 0;\r\ntuple.TupleDataMax = 255;\r\nret = pccard_get_tuple_data(s, &tuple);\r\nif (ret != 0)\r\ngoto done;\r\nret = pcmcia_parse_tuple(&tuple, parse);\r\ndone:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nint pccard_loop_tuple(struct pcmcia_socket *s, unsigned int function,\r\ncisdata_t code, cisparse_t *parse, void *priv_data,\r\nint (*loop_tuple) (tuple_t *tuple,\r\ncisparse_t *parse,\r\nvoid *priv_data))\r\n{\r\ntuple_t tuple;\r\ncisdata_t *buf;\r\nint ret;\r\nbuf = kzalloc(256, GFP_KERNEL);\r\nif (buf == NULL) {\r\ndev_printk(KERN_WARNING, &s->dev, "no memory to read tuple\n");\r\nreturn -ENOMEM;\r\n}\r\ntuple.TupleData = buf;\r\ntuple.TupleDataMax = 255;\r\ntuple.TupleOffset = 0;\r\ntuple.DesiredTuple = code;\r\ntuple.Attributes = 0;\r\nret = pccard_get_first_tuple(s, function, &tuple);\r\nwhile (!ret) {\r\nif (pccard_get_tuple_data(s, &tuple))\r\ngoto next_entry;\r\nif (parse)\r\nif (pcmcia_parse_tuple(&tuple, parse))\r\ngoto next_entry;\r\nret = loop_tuple(&tuple, parse, priv_data);\r\nif (!ret)\r\nbreak;\r\nnext_entry:\r\nret = pccard_get_next_tuple(s, function, &tuple);\r\n}\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int pcmcia_io_cfg_data_width(unsigned int flags)\r\n{\r\nif (!(flags & CISTPL_IO_8BIT))\r\nreturn IO_DATA_PATH_WIDTH_16;\r\nif (!(flags & CISTPL_IO_16BIT))\r\nreturn IO_DATA_PATH_WIDTH_8;\r\nreturn IO_DATA_PATH_WIDTH_AUTO;\r\n}\r\nstatic int pcmcia_do_loop_config(tuple_t *tuple, cisparse_t *parse, void *priv)\r\n{\r\nstruct pcmcia_cfg_mem *cfg_mem = priv;\r\nstruct pcmcia_device *p_dev = cfg_mem->p_dev;\r\ncistpl_cftable_entry_t *cfg = &parse->cftable_entry;\r\ncistpl_cftable_entry_t *dflt = &cfg_mem->dflt;\r\nunsigned int flags = p_dev->config_flags;\r\nunsigned int vcc = p_dev->socket->socket.Vcc;\r\ndev_dbg(&p_dev->dev, "testing configuration %x, autoconf %x\n",\r\ncfg->index, flags);\r\ncfg_mem->p_dev->config_index = cfg->index;\r\nif (cfg->flags & CISTPL_CFTABLE_DEFAULT)\r\ncfg_mem->dflt = *cfg;\r\nif (flags & CONF_AUTO_CHECK_VCC) {\r\nif (cfg->vcc.present & (1 << CISTPL_POWER_VNOM)) {\r\nif (vcc != cfg->vcc.param[CISTPL_POWER_VNOM] / 10000)\r\nreturn -ENODEV;\r\n} else if (dflt->vcc.present & (1 << CISTPL_POWER_VNOM)) {\r\nif (vcc != dflt->vcc.param[CISTPL_POWER_VNOM] / 10000)\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (flags & CONF_AUTO_SET_VPP) {\r\nif (cfg->vpp1.present & (1 << CISTPL_POWER_VNOM))\r\np_dev->vpp = cfg->vpp1.param[CISTPL_POWER_VNOM] / 10000;\r\nelse if (dflt->vpp1.present & (1 << CISTPL_POWER_VNOM))\r\np_dev->vpp =\r\ndflt->vpp1.param[CISTPL_POWER_VNOM] / 10000;\r\n}\r\nif ((flags & CONF_AUTO_AUDIO) && (cfg->flags & CISTPL_CFTABLE_AUDIO))\r\np_dev->config_flags |= CONF_ENABLE_SPKR;\r\nif (flags & CONF_AUTO_SET_IO) {\r\ncistpl_io_t *io = (cfg->io.nwin) ? &cfg->io : &dflt->io;\r\nint i = 0;\r\np_dev->resource[0]->start = p_dev->resource[0]->end = 0;\r\np_dev->resource[1]->start = p_dev->resource[1]->end = 0;\r\nif (io->nwin == 0)\r\nreturn -ENODEV;\r\np_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\np_dev->resource[0]->flags |=\r\npcmcia_io_cfg_data_width(io->flags);\r\nif (io->nwin > 1) {\r\ni = (io->win[1].len > io->win[0].len);\r\np_dev->resource[1]->flags = p_dev->resource[0]->flags;\r\np_dev->resource[1]->start = io->win[1-i].base;\r\np_dev->resource[1]->end = io->win[1-i].len;\r\n}\r\np_dev->resource[0]->start = io->win[i].base;\r\np_dev->resource[0]->end = io->win[i].len;\r\np_dev->io_lines = io->flags & CISTPL_IO_LINES_MASK;\r\n}\r\nif (flags & CONF_AUTO_SET_IOMEM) {\r\ncistpl_mem_t *mem = (cfg->mem.nwin) ? &cfg->mem : &dflt->mem;\r\np_dev->resource[2]->start = p_dev->resource[2]->end = 0;\r\nif (mem->nwin == 0)\r\nreturn -ENODEV;\r\np_dev->resource[2]->start = mem->win[0].host_addr;\r\np_dev->resource[2]->end = mem->win[0].len;\r\nif (p_dev->resource[2]->end < 0x1000)\r\np_dev->resource[2]->end = 0x1000;\r\np_dev->card_addr = mem->win[0].card_addr;\r\n}\r\ndev_dbg(&p_dev->dev,\r\n"checking configuration %x: %pr %pr %pr (%d lines)\n",\r\np_dev->config_index, p_dev->resource[0], p_dev->resource[1],\r\np_dev->resource[2], p_dev->io_lines);\r\nreturn cfg_mem->conf_check(p_dev, cfg_mem->priv_data);\r\n}\r\nint pcmcia_loop_config(struct pcmcia_device *p_dev,\r\nint (*conf_check) (struct pcmcia_device *p_dev,\r\nvoid *priv_data),\r\nvoid *priv_data)\r\n{\r\nstruct pcmcia_cfg_mem *cfg_mem;\r\nint ret;\r\ncfg_mem = kzalloc(sizeof(struct pcmcia_cfg_mem), GFP_KERNEL);\r\nif (cfg_mem == NULL)\r\nreturn -ENOMEM;\r\ncfg_mem->p_dev = p_dev;\r\ncfg_mem->conf_check = conf_check;\r\ncfg_mem->priv_data = priv_data;\r\nret = pccard_loop_tuple(p_dev->socket, p_dev->func,\r\nCISTPL_CFTABLE_ENTRY, &cfg_mem->parse,\r\ncfg_mem, pcmcia_do_loop_config);\r\nkfree(cfg_mem);\r\nreturn ret;\r\n}\r\nstatic int pcmcia_do_loop_tuple(tuple_t *tuple, cisparse_t *parse, void *priv)\r\n{\r\nstruct pcmcia_loop_mem *loop = priv;\r\nreturn loop->loop_tuple(loop->p_dev, tuple, loop->priv_data);\r\n}\r\nint pcmcia_loop_tuple(struct pcmcia_device *p_dev, cisdata_t code,\r\nint (*loop_tuple) (struct pcmcia_device *p_dev,\r\ntuple_t *tuple,\r\nvoid *priv_data),\r\nvoid *priv_data)\r\n{\r\nstruct pcmcia_loop_mem loop = {\r\n.p_dev = p_dev,\r\n.loop_tuple = loop_tuple,\r\n.priv_data = priv_data};\r\nreturn pccard_loop_tuple(p_dev->socket, p_dev->func, code, NULL,\r\n&loop, pcmcia_do_loop_tuple);\r\n}\r\nstatic int pcmcia_do_get_tuple(struct pcmcia_device *p_dev, tuple_t *tuple,\r\nvoid *priv)\r\n{\r\nstruct pcmcia_loop_get *get = priv;\r\n*get->buf = kzalloc(tuple->TupleDataLen, GFP_KERNEL);\r\nif (*get->buf) {\r\nget->len = tuple->TupleDataLen;\r\nmemcpy(*get->buf, tuple->TupleData, tuple->TupleDataLen);\r\n} else\r\ndev_dbg(&p_dev->dev, "do_get_tuple: out of memory\n");\r\nreturn 0;\r\n}\r\nsize_t pcmcia_get_tuple(struct pcmcia_device *p_dev, cisdata_t code,\r\nunsigned char **buf)\r\n{\r\nstruct pcmcia_loop_get get = {\r\n.len = 0,\r\n.buf = buf,\r\n};\r\n*get.buf = NULL;\r\npcmcia_loop_tuple(p_dev, code, pcmcia_do_get_tuple, &get);\r\nreturn get.len;\r\n}\r\nstatic int pcmcia_do_get_mac(struct pcmcia_device *p_dev, tuple_t *tuple,\r\nvoid *priv)\r\n{\r\nstruct net_device *dev = priv;\r\nint i;\r\nif (tuple->TupleData[0] != CISTPL_FUNCE_LAN_NODE_ID)\r\nreturn -EINVAL;\r\nif (tuple->TupleDataLen < ETH_ALEN + 2) {\r\ndev_warn(&p_dev->dev, "Invalid CIS tuple length for "\r\n"LAN_NODE_ID\n");\r\nreturn -EINVAL;\r\n}\r\nif (tuple->TupleData[1] != ETH_ALEN) {\r\ndev_warn(&p_dev->dev, "Invalid header for LAN_NODE_ID\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = tuple->TupleData[i+2];\r\nreturn 0;\r\n}\r\nint pcmcia_get_mac_from_cis(struct pcmcia_device *p_dev, struct net_device *dev)\r\n{\r\nreturn pcmcia_loop_tuple(p_dev, CISTPL_FUNCE, pcmcia_do_get_mac, dev);\r\n}
