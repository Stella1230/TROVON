static void update_linkspeed_register(struct net_device *dev,\r\nunsigned int speed, unsigned int duplex)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nunsigned int val;\r\nval = __raw_readl(ether->reg + REG_MCMDR);\r\nif (speed == SPEED_100) {\r\nif (duplex == DUPLEX_FULL) {\r\nval |= (MCMDR_OPMOD | MCMDR_FDUP);\r\n} else {\r\nval |= MCMDR_OPMOD;\r\nval &= ~MCMDR_FDUP;\r\n}\r\n} else {\r\nif (duplex == DUPLEX_FULL) {\r\nval |= MCMDR_FDUP;\r\nval &= ~MCMDR_OPMOD;\r\n} else {\r\nval &= ~(MCMDR_FDUP | MCMDR_OPMOD);\r\n}\r\n}\r\n__raw_writel(val, ether->reg + REG_MCMDR);\r\n}\r\nstatic void update_linkspeed(struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nstruct platform_device *pdev;\r\nunsigned int bmsr, bmcr, lpa, speed, duplex;\r\npdev = ether->pdev;\r\nif (!mii_link_ok(&ether->mii)) {\r\nether->linkflag = 0x0;\r\nnetif_carrier_off(dev);\r\ndev_warn(&pdev->dev, "%s: Link down.\n", dev->name);\r\nreturn;\r\n}\r\nif (ether->linkflag == 1)\r\nreturn;\r\nbmsr = w90p910_mdio_read(dev, ether->mii.phy_id, MII_BMSR);\r\nbmcr = w90p910_mdio_read(dev, ether->mii.phy_id, MII_BMCR);\r\nif (bmcr & BMCR_ANENABLE) {\r\nif (!(bmsr & BMSR_ANEGCOMPLETE))\r\nreturn;\r\nlpa = w90p910_mdio_read(dev, ether->mii.phy_id, MII_LPA);\r\nif ((lpa & LPA_100FULL) || (lpa & LPA_100HALF))\r\nspeed = SPEED_100;\r\nelse\r\nspeed = SPEED_10;\r\nif ((lpa & LPA_100FULL) || (lpa & LPA_10FULL))\r\nduplex = DUPLEX_FULL;\r\nelse\r\nduplex = DUPLEX_HALF;\r\n} else {\r\nspeed = (bmcr & BMCR_SPEED100) ? SPEED_100 : SPEED_10;\r\nduplex = (bmcr & BMCR_FULLDPLX) ? DUPLEX_FULL : DUPLEX_HALF;\r\n}\r\nupdate_linkspeed_register(dev, speed, duplex);\r\ndev_info(&pdev->dev, "%s: Link now %i-%s\n", dev->name, speed,\r\n(duplex == DUPLEX_FULL) ? "FullDuplex" : "HalfDuplex");\r\nether->linkflag = 0x01;\r\nnetif_carrier_on(dev);\r\n}\r\nstatic void w90p910_check_link(unsigned long dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *) dev_id;\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nupdate_linkspeed(dev);\r\nmod_timer(&ether->check_timer, jiffies + msecs_to_jiffies(1000));\r\n}\r\nstatic void w90p910_write_cam(struct net_device *dev,\r\nunsigned int x, unsigned char *pval)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nunsigned int msw, lsw;\r\nmsw = (pval[0] << 24) | (pval[1] << 16) | (pval[2] << 8) | pval[3];\r\nlsw = (pval[4] << 24) | (pval[5] << 16);\r\n__raw_writel(lsw, ether->reg + REG_CAML_BASE + x * CAM_ENTRY_SIZE);\r\n__raw_writel(msw, ether->reg + REG_CAMM_BASE + x * CAM_ENTRY_SIZE);\r\n}\r\nstatic int w90p910_init_desc(struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether;\r\nstruct w90p910_txbd *tdesc;\r\nstruct w90p910_rxbd *rdesc;\r\nstruct platform_device *pdev;\r\nunsigned int i;\r\nether = netdev_priv(dev);\r\npdev = ether->pdev;\r\nether->tdesc = dma_alloc_coherent(&pdev->dev, sizeof(struct tran_pdesc),\r\n&ether->tdesc_phys, GFP_KERNEL);\r\nif (!ether->tdesc)\r\nreturn -ENOMEM;\r\nether->rdesc = dma_alloc_coherent(&pdev->dev, sizeof(struct recv_pdesc),\r\n&ether->rdesc_phys, GFP_KERNEL);\r\nif (!ether->rdesc) {\r\ndma_free_coherent(&pdev->dev, sizeof(struct tran_pdesc),\r\nether->tdesc, ether->tdesc_phys);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < TX_DESC_SIZE; i++) {\r\nunsigned int offset;\r\ntdesc = &(ether->tdesc->desclist[i]);\r\nif (i == TX_DESC_SIZE - 1)\r\noffset = offsetof(struct tran_pdesc, desclist[0]);\r\nelse\r\noffset = offsetof(struct tran_pdesc, desclist[i + 1]);\r\ntdesc->next = ether->tdesc_phys + offset;\r\ntdesc->buffer = ether->tdesc_phys +\r\noffsetof(struct tran_pdesc, tran_buf[i]);\r\ntdesc->sl = 0;\r\ntdesc->mode = 0;\r\n}\r\nether->start_tx_ptr = ether->tdesc_phys;\r\nfor (i = 0; i < RX_DESC_SIZE; i++) {\r\nunsigned int offset;\r\nrdesc = &(ether->rdesc->desclist[i]);\r\nif (i == RX_DESC_SIZE - 1)\r\noffset = offsetof(struct recv_pdesc, desclist[0]);\r\nelse\r\noffset = offsetof(struct recv_pdesc, desclist[i + 1]);\r\nrdesc->next = ether->rdesc_phys + offset;\r\nrdesc->sl = RX_OWEN_DMA;\r\nrdesc->buffer = ether->rdesc_phys +\r\noffsetof(struct recv_pdesc, recv_buf[i]);\r\n}\r\nether->start_rx_ptr = ether->rdesc_phys;\r\nreturn 0;\r\n}\r\nstatic void w90p910_set_fifo_threshold(struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nunsigned int val;\r\nval = TXTHD | BLENGTH;\r\n__raw_writel(val, ether->reg + REG_FFTCR);\r\n}\r\nstatic void w90p910_return_default_idle(struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nunsigned int val;\r\nval = __raw_readl(ether->reg + REG_MCMDR);\r\nval |= SWR;\r\n__raw_writel(val, ether->reg + REG_MCMDR);\r\n}\r\nstatic void w90p910_trigger_rx(struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\n__raw_writel(ENSTART, ether->reg + REG_RSDR);\r\n}\r\nstatic void w90p910_trigger_tx(struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\n__raw_writel(ENSTART, ether->reg + REG_TSDR);\r\n}\r\nstatic void w90p910_enable_mac_interrupt(struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nunsigned int val;\r\nval = ENTXINTR | ENRXINTR | ENRXGD | ENTXCP;\r\nval |= ENTXBERR | ENRXBERR | ENTXABT;\r\n__raw_writel(val, ether->reg + REG_MIEN);\r\n}\r\nstatic void w90p910_get_and_clear_int(struct net_device *dev,\r\nunsigned int *val)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\n*val = __raw_readl(ether->reg + REG_MISTA);\r\n__raw_writel(*val, ether->reg + REG_MISTA);\r\n}\r\nstatic void w90p910_set_global_maccmd(struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nunsigned int val;\r\nval = __raw_readl(ether->reg + REG_MCMDR);\r\nval |= MCMDR_SPCRC | MCMDR_ENMDC | MCMDR_ACP | ENMDC;\r\n__raw_writel(val, ether->reg + REG_MCMDR);\r\n}\r\nstatic void w90p910_enable_cam(struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nunsigned int val;\r\nw90p910_write_cam(dev, CAM0, dev->dev_addr);\r\nval = __raw_readl(ether->reg + REG_CAMEN);\r\nval |= CAM0EN;\r\n__raw_writel(val, ether->reg + REG_CAMEN);\r\n}\r\nstatic void w90p910_enable_cam_command(struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nunsigned int val;\r\nval = CAMCMR_ECMP | CAMCMR_ABP | CAMCMR_AMP;\r\n__raw_writel(val, ether->reg + REG_CAMCMR);\r\n}\r\nstatic void w90p910_enable_tx(struct net_device *dev, unsigned int enable)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nunsigned int val;\r\nval = __raw_readl(ether->reg + REG_MCMDR);\r\nif (enable)\r\nval |= MCMDR_TXON;\r\nelse\r\nval &= ~MCMDR_TXON;\r\n__raw_writel(val, ether->reg + REG_MCMDR);\r\n}\r\nstatic void w90p910_enable_rx(struct net_device *dev, unsigned int enable)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nunsigned int val;\r\nval = __raw_readl(ether->reg + REG_MCMDR);\r\nif (enable)\r\nval |= MCMDR_RXON;\r\nelse\r\nval &= ~MCMDR_RXON;\r\n__raw_writel(val, ether->reg + REG_MCMDR);\r\n}\r\nstatic void w90p910_set_curdest(struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\n__raw_writel(ether->start_rx_ptr, ether->reg + REG_RXDLSA);\r\n__raw_writel(ether->start_tx_ptr, ether->reg + REG_TXDLSA);\r\n}\r\nstatic void w90p910_reset_mac(struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nw90p910_enable_tx(dev, 0);\r\nw90p910_enable_rx(dev, 0);\r\nw90p910_set_fifo_threshold(dev);\r\nw90p910_return_default_idle(dev);\r\nif (!netif_queue_stopped(dev))\r\nnetif_stop_queue(dev);\r\nw90p910_init_desc(dev);\r\ndev->trans_start = jiffies;\r\nether->cur_tx = 0x0;\r\nether->finish_tx = 0x0;\r\nether->cur_rx = 0x0;\r\nw90p910_set_curdest(dev);\r\nw90p910_enable_cam(dev);\r\nw90p910_enable_cam_command(dev);\r\nw90p910_enable_mac_interrupt(dev);\r\nw90p910_enable_tx(dev, 1);\r\nw90p910_enable_rx(dev, 1);\r\nw90p910_trigger_tx(dev);\r\nw90p910_trigger_rx(dev);\r\ndev->trans_start = jiffies;\r\nif (netif_queue_stopped(dev))\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void w90p910_mdio_write(struct net_device *dev,\r\nint phy_id, int reg, int data)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nstruct platform_device *pdev;\r\nunsigned int val, i;\r\npdev = ether->pdev;\r\n__raw_writel(data, ether->reg + REG_MIID);\r\nval = (phy_id << 0x08) | reg;\r\nval |= PHYBUSY | PHYWR | MDCCR_VAL;\r\n__raw_writel(val, ether->reg + REG_MIIDA);\r\nfor (i = 0; i < DELAY; i++) {\r\nif ((__raw_readl(ether->reg + REG_MIIDA) & PHYBUSY) == 0)\r\nbreak;\r\n}\r\nif (i == DELAY)\r\ndev_warn(&pdev->dev, "mdio write timed out\n");\r\n}\r\nstatic int w90p910_mdio_read(struct net_device *dev, int phy_id, int reg)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nstruct platform_device *pdev;\r\nunsigned int val, i, data;\r\npdev = ether->pdev;\r\nval = (phy_id << 0x08) | reg;\r\nval |= PHYBUSY | MDCCR_VAL;\r\n__raw_writel(val, ether->reg + REG_MIIDA);\r\nfor (i = 0; i < DELAY; i++) {\r\nif ((__raw_readl(ether->reg + REG_MIIDA) & PHYBUSY) == 0)\r\nbreak;\r\n}\r\nif (i == DELAY) {\r\ndev_warn(&pdev->dev, "mdio read timed out\n");\r\ndata = 0xffff;\r\n} else {\r\ndata = __raw_readl(ether->reg + REG_MIID);\r\n}\r\nreturn data;\r\n}\r\nstatic int w90p910_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *address = addr;\r\nif (!is_valid_ether_addr(address->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(dev->dev_addr, address->sa_data, dev->addr_len);\r\nw90p910_write_cam(dev, CAM0, dev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic int w90p910_ether_close(struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nstruct platform_device *pdev;\r\npdev = ether->pdev;\r\ndma_free_coherent(&pdev->dev, sizeof(struct recv_pdesc),\r\nether->rdesc, ether->rdesc_phys);\r\ndma_free_coherent(&pdev->dev, sizeof(struct tran_pdesc),\r\nether->tdesc, ether->tdesc_phys);\r\nnetif_stop_queue(dev);\r\ndel_timer_sync(&ether->check_timer);\r\nclk_disable(ether->rmiiclk);\r\nclk_disable(ether->clk);\r\nfree_irq(ether->txirq, dev);\r\nfree_irq(ether->rxirq, dev);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *w90p910_ether_stats(struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether;\r\nether = netdev_priv(dev);\r\nreturn &ether->stats;\r\n}\r\nstatic int w90p910_send_frame(struct net_device *dev,\r\nunsigned char *data, int length)\r\n{\r\nstruct w90p910_ether *ether;\r\nstruct w90p910_txbd *txbd;\r\nstruct platform_device *pdev;\r\nunsigned char *buffer;\r\nether = netdev_priv(dev);\r\npdev = ether->pdev;\r\ntxbd = &ether->tdesc->desclist[ether->cur_tx];\r\nbuffer = ether->tdesc->tran_buf[ether->cur_tx];\r\nif (length > 1514) {\r\ndev_err(&pdev->dev, "send data %d bytes, check it\n", length);\r\nlength = 1514;\r\n}\r\ntxbd->sl = length & 0xFFFF;\r\nmemcpy(buffer, data, length);\r\ntxbd->mode = TX_OWEN_DMA | PADDINGMODE | CRCMODE | MACTXINTEN;\r\nw90p910_enable_tx(dev, 1);\r\nw90p910_trigger_tx(dev);\r\nif (++ether->cur_tx >= TX_DESC_SIZE)\r\nether->cur_tx = 0;\r\ntxbd = &ether->tdesc->desclist[ether->cur_tx];\r\nif (txbd->mode & TX_OWEN_DMA)\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int w90p910_ether_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nif (!(w90p910_send_frame(dev, skb->data, skb->len))) {\r\nether->skb = skb;\r\ndev_kfree_skb_irq(skb);\r\nreturn 0;\r\n}\r\nreturn -EAGAIN;\r\n}\r\nstatic irqreturn_t w90p910_tx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct w90p910_ether *ether;\r\nstruct w90p910_txbd *txbd;\r\nstruct platform_device *pdev;\r\nstruct net_device *dev;\r\nunsigned int cur_entry, entry, status;\r\ndev = dev_id;\r\nether = netdev_priv(dev);\r\npdev = ether->pdev;\r\nw90p910_get_and_clear_int(dev, &status);\r\ncur_entry = __raw_readl(ether->reg + REG_CTXDSA);\r\nentry = ether->tdesc_phys +\r\noffsetof(struct tran_pdesc, desclist[ether->finish_tx]);\r\nwhile (entry != cur_entry) {\r\ntxbd = &ether->tdesc->desclist[ether->finish_tx];\r\nif (++ether->finish_tx >= TX_DESC_SIZE)\r\nether->finish_tx = 0;\r\nif (txbd->sl & TXDS_TXCP) {\r\nether->stats.tx_packets++;\r\nether->stats.tx_bytes += txbd->sl & 0xFFFF;\r\n} else {\r\nether->stats.tx_errors++;\r\n}\r\ntxbd->sl = 0x0;\r\ntxbd->mode = 0x0;\r\nif (netif_queue_stopped(dev))\r\nnetif_wake_queue(dev);\r\nentry = ether->tdesc_phys +\r\noffsetof(struct tran_pdesc, desclist[ether->finish_tx]);\r\n}\r\nif (status & MISTA_EXDEF) {\r\ndev_err(&pdev->dev, "emc defer exceed interrupt\n");\r\n} else if (status & MISTA_TXBERR) {\r\ndev_err(&pdev->dev, "emc bus error interrupt\n");\r\nw90p910_reset_mac(dev);\r\n} else if (status & MISTA_TDU) {\r\nif (netif_queue_stopped(dev))\r\nnetif_wake_queue(dev);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void netdev_rx(struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether;\r\nstruct w90p910_rxbd *rxbd;\r\nstruct platform_device *pdev;\r\nstruct sk_buff *skb;\r\nunsigned char *data;\r\nunsigned int length, status, val, entry;\r\nether = netdev_priv(dev);\r\npdev = ether->pdev;\r\nrxbd = &ether->rdesc->desclist[ether->cur_rx];\r\ndo {\r\nval = __raw_readl(ether->reg + REG_CRXDSA);\r\nentry = ether->rdesc_phys +\r\noffsetof(struct recv_pdesc, desclist[ether->cur_rx]);\r\nif (val == entry)\r\nbreak;\r\nstatus = rxbd->sl;\r\nlength = status & 0xFFFF;\r\nif (status & RXDS_RXGD) {\r\ndata = ether->rdesc->recv_buf[ether->cur_rx];\r\nskb = netdev_alloc_skb(dev, length + 2);\r\nif (!skb) {\r\nether->stats.rx_dropped++;\r\nreturn;\r\n}\r\nskb_reserve(skb, 2);\r\nskb_put(skb, length);\r\nskb_copy_to_linear_data(skb, data, length);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nether->stats.rx_packets++;\r\nether->stats.rx_bytes += length;\r\nnetif_rx(skb);\r\n} else {\r\nether->stats.rx_errors++;\r\nif (status & RXDS_RP) {\r\ndev_err(&pdev->dev, "rx runt err\n");\r\nether->stats.rx_length_errors++;\r\n} else if (status & RXDS_CRCE) {\r\ndev_err(&pdev->dev, "rx crc err\n");\r\nether->stats.rx_crc_errors++;\r\n} else if (status & RXDS_ALIE) {\r\ndev_err(&pdev->dev, "rx aligment err\n");\r\nether->stats.rx_frame_errors++;\r\n} else if (status & RXDS_PTLE) {\r\ndev_err(&pdev->dev, "rx longer err\n");\r\nether->stats.rx_over_errors++;\r\n}\r\n}\r\nrxbd->sl = RX_OWEN_DMA;\r\nrxbd->reserved = 0x0;\r\nif (++ether->cur_rx >= RX_DESC_SIZE)\r\nether->cur_rx = 0;\r\nrxbd = &ether->rdesc->desclist[ether->cur_rx];\r\n} while (1);\r\n}\r\nstatic irqreturn_t w90p910_rx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev;\r\nstruct w90p910_ether *ether;\r\nstruct platform_device *pdev;\r\nunsigned int status;\r\ndev = dev_id;\r\nether = netdev_priv(dev);\r\npdev = ether->pdev;\r\nw90p910_get_and_clear_int(dev, &status);\r\nif (status & MISTA_RDU) {\r\nnetdev_rx(dev);\r\nw90p910_trigger_rx(dev);\r\nreturn IRQ_HANDLED;\r\n} else if (status & MISTA_RXBERR) {\r\ndev_err(&pdev->dev, "emc rx bus error\n");\r\nw90p910_reset_mac(dev);\r\n}\r\nnetdev_rx(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int w90p910_ether_open(struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether;\r\nstruct platform_device *pdev;\r\nether = netdev_priv(dev);\r\npdev = ether->pdev;\r\nw90p910_reset_mac(dev);\r\nw90p910_set_fifo_threshold(dev);\r\nw90p910_set_curdest(dev);\r\nw90p910_enable_cam(dev);\r\nw90p910_enable_cam_command(dev);\r\nw90p910_enable_mac_interrupt(dev);\r\nw90p910_set_global_maccmd(dev);\r\nw90p910_enable_rx(dev, 1);\r\nclk_enable(ether->rmiiclk);\r\nclk_enable(ether->clk);\r\nether->rx_packets = 0x0;\r\nether->rx_bytes = 0x0;\r\nif (request_irq(ether->txirq, w90p910_tx_interrupt,\r\n0x0, pdev->name, dev)) {\r\ndev_err(&pdev->dev, "register irq tx failed\n");\r\nreturn -EAGAIN;\r\n}\r\nif (request_irq(ether->rxirq, w90p910_rx_interrupt,\r\n0x0, pdev->name, dev)) {\r\ndev_err(&pdev->dev, "register irq rx failed\n");\r\nfree_irq(ether->txirq, dev);\r\nreturn -EAGAIN;\r\n}\r\nmod_timer(&ether->check_timer, jiffies + msecs_to_jiffies(1000));\r\nnetif_start_queue(dev);\r\nw90p910_trigger_rx(dev);\r\ndev_info(&pdev->dev, "%s is OPENED\n", dev->name);\r\nreturn 0;\r\n}\r\nstatic void w90p910_ether_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether;\r\nunsigned int rx_mode;\r\nether = netdev_priv(dev);\r\nif (dev->flags & IFF_PROMISC)\r\nrx_mode = CAMCMR_AUP | CAMCMR_AMP | CAMCMR_ABP | CAMCMR_ECMP;\r\nelse if ((dev->flags & IFF_ALLMULTI) || !netdev_mc_empty(dev))\r\nrx_mode = CAMCMR_AMP | CAMCMR_ABP | CAMCMR_ECMP;\r\nelse\r\nrx_mode = CAMCMR_ECMP | CAMCMR_ABP;\r\n__raw_writel(rx_mode, ether->reg + REG_CAMCMR);\r\n}\r\nstatic int w90p910_ether_ioctl(struct net_device *dev,\r\nstruct ifreq *ifr, int cmd)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nstruct mii_ioctl_data *data = if_mii(ifr);\r\nreturn generic_mii_ioctl(&ether->mii, data, cmd, NULL);\r\n}\r\nstatic void w90p910_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));\r\n}\r\nstatic int w90p910_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nreturn mii_ethtool_gset(&ether->mii, cmd);\r\n}\r\nstatic int w90p910_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nreturn mii_ethtool_sset(&ether->mii, cmd);\r\n}\r\nstatic int w90p910_nway_reset(struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nreturn mii_nway_restart(&ether->mii);\r\n}\r\nstatic u32 w90p910_get_link(struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nreturn mii_link_ok(&ether->mii);\r\n}\r\nstatic void __init get_mac_address(struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nstruct platform_device *pdev;\r\nchar addr[ETH_ALEN];\r\npdev = ether->pdev;\r\naddr[0] = 0x00;\r\naddr[1] = 0x02;\r\naddr[2] = 0xac;\r\naddr[3] = 0x55;\r\naddr[4] = 0x88;\r\naddr[5] = 0xa8;\r\nif (is_valid_ether_addr(addr))\r\nmemcpy(dev->dev_addr, &addr, ETH_ALEN);\r\nelse\r\ndev_err(&pdev->dev, "invalid mac address\n");\r\n}\r\nstatic int w90p910_ether_setup(struct net_device *dev)\r\n{\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nether_setup(dev);\r\ndev->netdev_ops = &w90p910_ether_netdev_ops;\r\ndev->ethtool_ops = &w90p910_ether_ethtool_ops;\r\ndev->tx_queue_len = 16;\r\ndev->dma = 0x0;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nget_mac_address(dev);\r\nether->cur_tx = 0x0;\r\nether->cur_rx = 0x0;\r\nether->finish_tx = 0x0;\r\nether->linkflag = 0x0;\r\nether->mii.phy_id = 0x01;\r\nether->mii.phy_id_mask = 0x1f;\r\nether->mii.reg_num_mask = 0x1f;\r\nether->mii.dev = dev;\r\nether->mii.mdio_read = w90p910_mdio_read;\r\nether->mii.mdio_write = w90p910_mdio_write;\r\nsetup_timer(&ether->check_timer, w90p910_check_link,\r\n(unsigned long)dev);\r\nreturn 0;\r\n}\r\nstatic int w90p910_ether_probe(struct platform_device *pdev)\r\n{\r\nstruct w90p910_ether *ether;\r\nstruct net_device *dev;\r\nint error;\r\ndev = alloc_etherdev(sizeof(struct w90p910_ether));\r\nif (!dev)\r\nreturn -ENOMEM;\r\nether = netdev_priv(dev);\r\nether->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (ether->res == NULL) {\r\ndev_err(&pdev->dev, "failed to get I/O memory\n");\r\nerror = -ENXIO;\r\ngoto failed_free;\r\n}\r\nif (!request_mem_region(ether->res->start,\r\nresource_size(ether->res), pdev->name)) {\r\ndev_err(&pdev->dev, "failed to request I/O memory\n");\r\nerror = -EBUSY;\r\ngoto failed_free;\r\n}\r\nether->reg = ioremap(ether->res->start, resource_size(ether->res));\r\nif (ether->reg == NULL) {\r\ndev_err(&pdev->dev, "failed to remap I/O memory\n");\r\nerror = -ENXIO;\r\ngoto failed_free_mem;\r\n}\r\nether->txirq = platform_get_irq(pdev, 0);\r\nif (ether->txirq < 0) {\r\ndev_err(&pdev->dev, "failed to get ether tx irq\n");\r\nerror = -ENXIO;\r\ngoto failed_free_io;\r\n}\r\nether->rxirq = platform_get_irq(pdev, 1);\r\nif (ether->rxirq < 0) {\r\ndev_err(&pdev->dev, "failed to get ether rx irq\n");\r\nerror = -ENXIO;\r\ngoto failed_free_io;\r\n}\r\nplatform_set_drvdata(pdev, dev);\r\nether->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(ether->clk)) {\r\ndev_err(&pdev->dev, "failed to get ether clock\n");\r\nerror = PTR_ERR(ether->clk);\r\ngoto failed_free_io;\r\n}\r\nether->rmiiclk = clk_get(&pdev->dev, "RMII");\r\nif (IS_ERR(ether->rmiiclk)) {\r\ndev_err(&pdev->dev, "failed to get ether clock\n");\r\nerror = PTR_ERR(ether->rmiiclk);\r\ngoto failed_put_clk;\r\n}\r\nether->pdev = pdev;\r\nw90p910_ether_setup(dev);\r\nerror = register_netdev(dev);\r\nif (error != 0) {\r\ndev_err(&pdev->dev, "Regiter EMC w90p910 FAILED\n");\r\nerror = -ENODEV;\r\ngoto failed_put_rmiiclk;\r\n}\r\nreturn 0;\r\nfailed_put_rmiiclk:\r\nclk_put(ether->rmiiclk);\r\nfailed_put_clk:\r\nclk_put(ether->clk);\r\nfailed_free_io:\r\niounmap(ether->reg);\r\nfailed_free_mem:\r\nrelease_mem_region(ether->res->start, resource_size(ether->res));\r\nfailed_free:\r\nfree_netdev(dev);\r\nreturn error;\r\n}\r\nstatic int w90p910_ether_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct w90p910_ether *ether = netdev_priv(dev);\r\nunregister_netdev(dev);\r\nclk_put(ether->rmiiclk);\r\nclk_put(ether->clk);\r\niounmap(ether->reg);\r\nrelease_mem_region(ether->res->start, resource_size(ether->res));\r\ndel_timer_sync(&ether->check_timer);\r\nfree_netdev(dev);\r\nreturn 0;\r\n}
