void core_pr_dump_initiator_port(\r\nstruct t10_pr_registration *pr_reg,\r\nchar *buf,\r\nu32 size)\r\n{\r\nif (!pr_reg->isid_present_at_reg)\r\nbuf[0] = '\0';\r\nsnprintf(buf, size, ",i,0x%s", pr_reg->pr_reg_isid);\r\n}\r\nstatic sense_reason_t\r\ntarget_scsi2_reservation_check(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_session *sess = cmd->se_sess;\r\nswitch (cmd->t_task_cdb[0]) {\r\ncase INQUIRY:\r\ncase RELEASE:\r\ncase RELEASE_10:\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nif (!dev->dev_reserved_node_acl || !sess)\r\nreturn 0;\r\nif (dev->dev_reserved_node_acl != sess->se_node_acl)\r\nreturn TCM_RESERVATION_CONFLICT;\r\nif (dev->dev_reservation_flags & DRF_SPC2_RESERVATIONS_WITH_ISID) {\r\nif (dev->dev_res_bin_isid != sess->sess_bin_isid)\r\nreturn TCM_RESERVATION_CONFLICT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int target_check_scsi2_reservation_conflict(struct se_cmd *cmd)\r\n{\r\nstruct se_session *se_sess = cmd->se_sess;\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct t10_pr_registration *pr_reg;\r\nstruct t10_reservation *pr_tmpl = &dev->t10_pr;\r\nint conflict = 0;\r\npr_reg = core_scsi3_locate_pr_reg(cmd->se_dev, se_sess->se_node_acl,\r\nse_sess);\r\nif (pr_reg) {\r\nif (pr_reg->pr_res_holder) {\r\ncore_scsi3_put_pr_reg(pr_reg);\r\nreturn 1;\r\n}\r\nif ((pr_reg->pr_res_type == PR_TYPE_WRITE_EXCLUSIVE_REGONLY) ||\r\n(pr_reg->pr_res_type == PR_TYPE_EXCLUSIVE_ACCESS_REGONLY) ||\r\n(pr_reg->pr_res_type == PR_TYPE_WRITE_EXCLUSIVE_ALLREG) ||\r\n(pr_reg->pr_res_type == PR_TYPE_EXCLUSIVE_ACCESS_ALLREG)) {\r\ncore_scsi3_put_pr_reg(pr_reg);\r\nreturn 1;\r\n}\r\ncore_scsi3_put_pr_reg(pr_reg);\r\nconflict = 1;\r\n} else {\r\nspin_lock(&pr_tmpl->registration_lock);\r\nconflict = (list_empty(&pr_tmpl->registration_list)) ? 0 : 1;\r\nspin_unlock(&pr_tmpl->registration_lock);\r\n}\r\nif (conflict) {\r\npr_err("Received legacy SPC-2 RESERVE/RELEASE"\r\n" while active SPC-3 registrations exist,"\r\n" returning RESERVATION_CONFLICT\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nsense_reason_t\r\ntarget_scsi2_reservation_release(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_session *sess = cmd->se_sess;\r\nstruct se_portal_group *tpg;\r\nint rc;\r\nif (!sess || !sess->se_tpg)\r\ngoto out;\r\nrc = target_check_scsi2_reservation_conflict(cmd);\r\nif (rc == 1)\r\ngoto out;\r\nif (rc < 0)\r\nreturn TCM_RESERVATION_CONFLICT;\r\nspin_lock(&dev->dev_reservation_lock);\r\nif (!dev->dev_reserved_node_acl || !sess)\r\ngoto out_unlock;\r\nif (dev->dev_reserved_node_acl != sess->se_node_acl)\r\ngoto out_unlock;\r\nif (dev->dev_res_bin_isid != sess->sess_bin_isid)\r\ngoto out_unlock;\r\ndev->dev_reserved_node_acl = NULL;\r\ndev->dev_reservation_flags &= ~DRF_SPC2_RESERVATIONS;\r\nif (dev->dev_reservation_flags & DRF_SPC2_RESERVATIONS_WITH_ISID) {\r\ndev->dev_res_bin_isid = 0;\r\ndev->dev_reservation_flags &= ~DRF_SPC2_RESERVATIONS_WITH_ISID;\r\n}\r\ntpg = sess->se_tpg;\r\npr_debug("SCSI-2 Released reservation for %s LUN: %u ->"\r\n" MAPPED LUN: %u for %s\n", tpg->se_tpg_tfo->get_fabric_name(),\r\ncmd->se_lun->unpacked_lun, cmd->se_deve->mapped_lun,\r\nsess->se_node_acl->initiatorname);\r\nout_unlock:\r\nspin_unlock(&dev->dev_reservation_lock);\r\nout:\r\ntarget_complete_cmd(cmd, GOOD);\r\nreturn 0;\r\n}\r\nsense_reason_t\r\ntarget_scsi2_reservation_reserve(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_session *sess = cmd->se_sess;\r\nstruct se_portal_group *tpg;\r\nsense_reason_t ret = 0;\r\nint rc;\r\nif ((cmd->t_task_cdb[1] & 0x01) &&\r\n(cmd->t_task_cdb[1] & 0x02)) {\r\npr_err("LongIO and Obselete Bits set, returning"\r\n" ILLEGAL_REQUEST\n");\r\nreturn TCM_UNSUPPORTED_SCSI_OPCODE;\r\n}\r\nif (!sess || !sess->se_tpg)\r\ngoto out;\r\nrc = target_check_scsi2_reservation_conflict(cmd);\r\nif (rc == 1)\r\ngoto out;\r\nif (rc < 0)\r\nreturn TCM_RESERVATION_CONFLICT;\r\ntpg = sess->se_tpg;\r\nspin_lock(&dev->dev_reservation_lock);\r\nif (dev->dev_reserved_node_acl &&\r\n(dev->dev_reserved_node_acl != sess->se_node_acl)) {\r\npr_err("SCSI-2 RESERVATION CONFLIFT for %s fabric\n",\r\ntpg->se_tpg_tfo->get_fabric_name());\r\npr_err("Original reserver LUN: %u %s\n",\r\ncmd->se_lun->unpacked_lun,\r\ndev->dev_reserved_node_acl->initiatorname);\r\npr_err("Current attempt - LUN: %u -> MAPPED LUN: %u"\r\n" from %s \n", cmd->se_lun->unpacked_lun,\r\ncmd->se_deve->mapped_lun,\r\nsess->se_node_acl->initiatorname);\r\nret = TCM_RESERVATION_CONFLICT;\r\ngoto out_unlock;\r\n}\r\ndev->dev_reserved_node_acl = sess->se_node_acl;\r\ndev->dev_reservation_flags |= DRF_SPC2_RESERVATIONS;\r\nif (sess->sess_bin_isid != 0) {\r\ndev->dev_res_bin_isid = sess->sess_bin_isid;\r\ndev->dev_reservation_flags |= DRF_SPC2_RESERVATIONS_WITH_ISID;\r\n}\r\npr_debug("SCSI-2 Reserved %s LUN: %u -> MAPPED LUN: %u"\r\n" for %s\n", tpg->se_tpg_tfo->get_fabric_name(),\r\ncmd->se_lun->unpacked_lun, cmd->se_deve->mapped_lun,\r\nsess->se_node_acl->initiatorname);\r\nout_unlock:\r\nspin_unlock(&dev->dev_reservation_lock);\r\nout:\r\nif (!ret)\r\ntarget_complete_cmd(cmd, GOOD);\r\nreturn ret;\r\n}\r\nstatic int core_scsi3_pr_seq_non_holder(\r\nstruct se_cmd *cmd,\r\nu32 pr_reg_type)\r\n{\r\nunsigned char *cdb = cmd->t_task_cdb;\r\nstruct se_dev_entry *se_deve;\r\nstruct se_session *se_sess = cmd->se_sess;\r\nint other_cdb = 0, ignore_reg;\r\nint registered_nexus = 0, ret = 1;\r\nint all_reg = 0, reg_only = 0;\r\nint we = 0;\r\nint legacy = 0;\r\nse_deve = se_sess->se_node_acl->device_list[cmd->orig_fe_lun];\r\nignore_reg = (pr_reg_type & 0x80000000);\r\nif (ignore_reg)\r\npr_reg_type &= ~0x80000000;\r\nswitch (pr_reg_type) {\r\ncase PR_TYPE_WRITE_EXCLUSIVE:\r\nwe = 1;\r\ncase PR_TYPE_EXCLUSIVE_ACCESS:\r\nif ((se_deve->def_pr_registered) && !(ignore_reg))\r\nregistered_nexus = 1;\r\nbreak;\r\ncase PR_TYPE_WRITE_EXCLUSIVE_REGONLY:\r\nwe = 1;\r\ncase PR_TYPE_EXCLUSIVE_ACCESS_REGONLY:\r\nreg_only = 1;\r\nif ((se_deve->def_pr_registered) && !(ignore_reg))\r\nregistered_nexus = 1;\r\nbreak;\r\ncase PR_TYPE_WRITE_EXCLUSIVE_ALLREG:\r\nwe = 1;\r\ncase PR_TYPE_EXCLUSIVE_ACCESS_ALLREG:\r\nall_reg = 1;\r\nif ((se_deve->def_pr_registered) && !(ignore_reg))\r\nregistered_nexus = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (cdb[0]) {\r\ncase SECURITY_PROTOCOL_IN:\r\nif (registered_nexus)\r\nreturn 0;\r\nret = (we) ? 0 : 1;\r\nbreak;\r\ncase MODE_SENSE:\r\ncase MODE_SENSE_10:\r\ncase READ_ATTRIBUTE:\r\ncase READ_BUFFER:\r\ncase RECEIVE_DIAGNOSTIC:\r\nif (legacy) {\r\nret = 1;\r\nbreak;\r\n}\r\nif (registered_nexus) {\r\nret = 0;\r\nbreak;\r\n}\r\nret = (we) ? 0 : 1;\r\nbreak;\r\ncase PERSISTENT_RESERVE_OUT:\r\nswitch (cdb[1] & 0x1f) {\r\ncase PRO_CLEAR:\r\ncase PRO_PREEMPT:\r\ncase PRO_PREEMPT_AND_ABORT:\r\nret = (registered_nexus) ? 0 : 1;\r\nbreak;\r\ncase PRO_REGISTER:\r\ncase PRO_REGISTER_AND_IGNORE_EXISTING_KEY:\r\nret = 0;\r\nbreak;\r\ncase PRO_REGISTER_AND_MOVE:\r\ncase PRO_RESERVE:\r\nret = 1;\r\nbreak;\r\ncase PRO_RELEASE:\r\nret = (registered_nexus) ? 0 : 1;\r\nbreak;\r\ndefault:\r\npr_err("Unknown PERSISTENT_RESERVE_OUT service"\r\n" action: 0x%02x\n", cdb[1] & 0x1f);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase RELEASE:\r\ncase RELEASE_10:\r\nret = 0;\r\nbreak;\r\ncase RESERVE:\r\ncase RESERVE_10:\r\nret = 0;\r\nbreak;\r\ncase TEST_UNIT_READY:\r\nret = (legacy) ? 1 : 0;\r\nbreak;\r\ncase MAINTENANCE_IN:\r\nswitch (cdb[1] & 0x1f) {\r\ncase MI_MANAGEMENT_PROTOCOL_IN:\r\nif (registered_nexus) {\r\nret = 0;\r\nbreak;\r\n}\r\nret = (we) ? 0 : 1;\r\nbreak;\r\ncase MI_REPORT_SUPPORTED_OPERATION_CODES:\r\ncase MI_REPORT_SUPPORTED_TASK_MANAGEMENT_FUNCTIONS:\r\nif (legacy) {\r\nret = 1;\r\nbreak;\r\n}\r\nif (registered_nexus) {\r\nret = 0;\r\nbreak;\r\n}\r\nret = (we) ? 0 : 1;\r\nbreak;\r\ncase MI_REPORT_ALIASES:\r\ncase MI_REPORT_IDENTIFYING_INFORMATION:\r\ncase MI_REPORT_PRIORITY:\r\ncase MI_REPORT_TARGET_PGS:\r\ncase MI_REPORT_TIMESTAMP:\r\nret = 0;\r\nbreak;\r\ndefault:\r\npr_err("Unknown MI Service Action: 0x%02x\n",\r\n(cdb[1] & 0x1f));\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase ACCESS_CONTROL_IN:\r\ncase ACCESS_CONTROL_OUT:\r\ncase INQUIRY:\r\ncase LOG_SENSE:\r\ncase READ_MEDIA_SERIAL_NUMBER:\r\ncase REPORT_LUNS:\r\ncase REQUEST_SENSE:\r\ncase PERSISTENT_RESERVE_IN:\r\nret = 0;\r\nbreak;\r\ndefault:\r\nother_cdb = 1;\r\nbreak;\r\n}\r\nif (!ret && !other_cdb) {\r\npr_debug("Allowing explicit CDB: 0x%02x for %s"\r\n" reservation holder\n", cdb[0],\r\ncore_scsi3_pr_dump_type(pr_reg_type));\r\nreturn ret;\r\n}\r\nif (we && !registered_nexus) {\r\nif (cmd->data_direction == DMA_TO_DEVICE) {\r\npr_debug("%s Conflict for unregistered nexus"\r\n" %s CDB: 0x%02x to %s reservation\n",\r\ntransport_dump_cmd_direction(cmd),\r\nse_sess->se_node_acl->initiatorname, cdb[0],\r\ncore_scsi3_pr_dump_type(pr_reg_type));\r\nreturn 1;\r\n} else {\r\nif (!registered_nexus) {\r\npr_debug("Allowing implicit CDB: 0x%02x"\r\n" for %s reservation on unregistered"\r\n" nexus\n", cdb[0],\r\ncore_scsi3_pr_dump_type(pr_reg_type));\r\n}\r\nreturn 0;\r\n}\r\n} else if ((reg_only) || (all_reg)) {\r\nif (registered_nexus) {\r\npr_debug("Allowing implicit CDB: 0x%02x for %s"\r\n" reservation\n", cdb[0],\r\ncore_scsi3_pr_dump_type(pr_reg_type));\r\nreturn 0;\r\n}\r\n}\r\npr_debug("%s Conflict for %sregistered nexus %s CDB: 0x%2x"\r\n" for %s reservation\n", transport_dump_cmd_direction(cmd),\r\n(registered_nexus) ? "" : "un",\r\nse_sess->se_node_acl->initiatorname, cdb[0],\r\ncore_scsi3_pr_dump_type(pr_reg_type));\r\nreturn 1;\r\n}\r\nstatic sense_reason_t\r\ntarget_scsi3_pr_reservation_check(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_session *sess = cmd->se_sess;\r\nu32 pr_reg_type;\r\nif (!dev->dev_pr_res_holder)\r\nreturn 0;\r\npr_reg_type = dev->dev_pr_res_holder->pr_res_type;\r\ncmd->pr_res_key = dev->dev_pr_res_holder->pr_res_key;\r\nif (dev->dev_pr_res_holder->pr_reg_nacl != sess->se_node_acl)\r\ngoto check_nonholder;\r\nif (dev->dev_pr_res_holder->isid_present_at_reg) {\r\nif (dev->dev_pr_res_holder->pr_reg_bin_isid !=\r\nsess->sess_bin_isid) {\r\npr_reg_type |= 0x80000000;\r\ngoto check_nonholder;\r\n}\r\n}\r\nreturn 0;\r\ncheck_nonholder:\r\nif (core_scsi3_pr_seq_non_holder(cmd, pr_reg_type))\r\nreturn TCM_RESERVATION_CONFLICT;\r\nreturn 0;\r\n}\r\nstatic u32 core_scsi3_pr_generation(struct se_device *dev)\r\n{\r\nu32 prg;\r\nspin_lock(&dev->dev_reservation_lock);\r\nprg = dev->t10_pr.pr_generation++;\r\nspin_unlock(&dev->dev_reservation_lock);\r\nreturn prg;\r\n}\r\nstatic struct t10_pr_registration *__core_scsi3_do_alloc_registration(\r\nstruct se_device *dev,\r\nstruct se_node_acl *nacl,\r\nstruct se_dev_entry *deve,\r\nunsigned char *isid,\r\nu64 sa_res_key,\r\nint all_tg_pt,\r\nint aptpl)\r\n{\r\nstruct t10_pr_registration *pr_reg;\r\npr_reg = kmem_cache_zalloc(t10_pr_reg_cache, GFP_ATOMIC);\r\nif (!pr_reg) {\r\npr_err("Unable to allocate struct t10_pr_registration\n");\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&pr_reg->pr_reg_list);\r\nINIT_LIST_HEAD(&pr_reg->pr_reg_abort_list);\r\nINIT_LIST_HEAD(&pr_reg->pr_reg_aptpl_list);\r\nINIT_LIST_HEAD(&pr_reg->pr_reg_atp_list);\r\nINIT_LIST_HEAD(&pr_reg->pr_reg_atp_mem_list);\r\natomic_set(&pr_reg->pr_res_holders, 0);\r\npr_reg->pr_reg_nacl = nacl;\r\npr_reg->pr_reg_deve = deve;\r\npr_reg->pr_res_mapped_lun = deve->mapped_lun;\r\npr_reg->pr_aptpl_target_lun = deve->se_lun->unpacked_lun;\r\npr_reg->pr_res_key = sa_res_key;\r\npr_reg->pr_reg_all_tg_pt = all_tg_pt;\r\npr_reg->pr_reg_aptpl = aptpl;\r\npr_reg->pr_reg_tg_pt_lun = deve->se_lun;\r\nif (isid != NULL) {\r\npr_reg->pr_reg_bin_isid = get_unaligned_be64(isid);\r\nsnprintf(pr_reg->pr_reg_isid, PR_REG_ISID_LEN, "%s", isid);\r\npr_reg->isid_present_at_reg = 1;\r\n}\r\nreturn pr_reg;\r\n}\r\nstatic struct t10_pr_registration *__core_scsi3_alloc_registration(\r\nstruct se_device *dev,\r\nstruct se_node_acl *nacl,\r\nstruct se_dev_entry *deve,\r\nunsigned char *isid,\r\nu64 sa_res_key,\r\nint all_tg_pt,\r\nint aptpl)\r\n{\r\nstruct se_dev_entry *deve_tmp;\r\nstruct se_node_acl *nacl_tmp;\r\nstruct se_port *port, *port_tmp;\r\nstruct target_core_fabric_ops *tfo = nacl->se_tpg->se_tpg_tfo;\r\nstruct t10_pr_registration *pr_reg, *pr_reg_atp, *pr_reg_tmp, *pr_reg_tmp_safe;\r\nint ret;\r\npr_reg = __core_scsi3_do_alloc_registration(dev, nacl, deve, isid,\r\nsa_res_key, all_tg_pt, aptpl);\r\nif (!pr_reg)\r\nreturn NULL;\r\nif (!all_tg_pt)\r\nreturn pr_reg;\r\nspin_lock(&dev->se_port_lock);\r\nlist_for_each_entry_safe(port, port_tmp, &dev->dev_sep_list, sep_list) {\r\natomic_inc(&port->sep_tg_pt_ref_cnt);\r\nsmp_mb__after_atomic();\r\nspin_unlock(&dev->se_port_lock);\r\nspin_lock_bh(&port->sep_alua_lock);\r\nlist_for_each_entry(deve_tmp, &port->sep_alua_list,\r\nalua_port_list) {\r\nif (!deve_tmp->se_lun_acl)\r\ncontinue;\r\nnacl_tmp = deve_tmp->se_lun_acl->se_lun_nacl;\r\nif (nacl == nacl_tmp)\r\ncontinue;\r\nif (tfo != nacl_tmp->se_tpg->se_tpg_tfo)\r\ncontinue;\r\nif (strcmp(nacl->initiatorname, nacl_tmp->initiatorname))\r\ncontinue;\r\natomic_inc(&deve_tmp->pr_ref_count);\r\nsmp_mb__after_atomic();\r\nspin_unlock_bh(&port->sep_alua_lock);\r\nret = core_scsi3_lunacl_depend_item(deve_tmp);\r\nif (ret < 0) {\r\npr_err("core_scsi3_lunacl_depend"\r\n"_item() failed\n");\r\natomic_dec(&port->sep_tg_pt_ref_cnt);\r\nsmp_mb__after_atomic();\r\natomic_dec(&deve_tmp->pr_ref_count);\r\nsmp_mb__after_atomic();\r\ngoto out;\r\n}\r\npr_reg_atp = __core_scsi3_do_alloc_registration(dev,\r\nnacl_tmp, deve_tmp, NULL,\r\nsa_res_key, all_tg_pt, aptpl);\r\nif (!pr_reg_atp) {\r\natomic_dec(&port->sep_tg_pt_ref_cnt);\r\nsmp_mb__after_atomic();\r\natomic_dec(&deve_tmp->pr_ref_count);\r\nsmp_mb__after_atomic();\r\ncore_scsi3_lunacl_undepend_item(deve_tmp);\r\ngoto out;\r\n}\r\nlist_add_tail(&pr_reg_atp->pr_reg_atp_mem_list,\r\n&pr_reg->pr_reg_atp_list);\r\nspin_lock_bh(&port->sep_alua_lock);\r\n}\r\nspin_unlock_bh(&port->sep_alua_lock);\r\nspin_lock(&dev->se_port_lock);\r\natomic_dec(&port->sep_tg_pt_ref_cnt);\r\nsmp_mb__after_atomic();\r\n}\r\nspin_unlock(&dev->se_port_lock);\r\nreturn pr_reg;\r\nout:\r\nlist_for_each_entry_safe(pr_reg_tmp, pr_reg_tmp_safe,\r\n&pr_reg->pr_reg_atp_list, pr_reg_atp_mem_list) {\r\nlist_del(&pr_reg_tmp->pr_reg_atp_mem_list);\r\ncore_scsi3_lunacl_undepend_item(pr_reg_tmp->pr_reg_deve);\r\nkmem_cache_free(t10_pr_reg_cache, pr_reg_tmp);\r\n}\r\nkmem_cache_free(t10_pr_reg_cache, pr_reg);\r\nreturn NULL;\r\n}\r\nint core_scsi3_alloc_aptpl_registration(\r\nstruct t10_reservation *pr_tmpl,\r\nu64 sa_res_key,\r\nunsigned char *i_port,\r\nunsigned char *isid,\r\nu32 mapped_lun,\r\nunsigned char *t_port,\r\nu16 tpgt,\r\nu32 target_lun,\r\nint res_holder,\r\nint all_tg_pt,\r\nu8 type)\r\n{\r\nstruct t10_pr_registration *pr_reg;\r\nif (!i_port || !t_port || !sa_res_key) {\r\npr_err("Illegal parameters for APTPL registration\n");\r\nreturn -EINVAL;\r\n}\r\npr_reg = kmem_cache_zalloc(t10_pr_reg_cache, GFP_KERNEL);\r\nif (!pr_reg) {\r\npr_err("Unable to allocate struct t10_pr_registration\n");\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&pr_reg->pr_reg_list);\r\nINIT_LIST_HEAD(&pr_reg->pr_reg_abort_list);\r\nINIT_LIST_HEAD(&pr_reg->pr_reg_aptpl_list);\r\nINIT_LIST_HEAD(&pr_reg->pr_reg_atp_list);\r\nINIT_LIST_HEAD(&pr_reg->pr_reg_atp_mem_list);\r\natomic_set(&pr_reg->pr_res_holders, 0);\r\npr_reg->pr_reg_nacl = NULL;\r\npr_reg->pr_reg_deve = NULL;\r\npr_reg->pr_res_mapped_lun = mapped_lun;\r\npr_reg->pr_aptpl_target_lun = target_lun;\r\npr_reg->pr_res_key = sa_res_key;\r\npr_reg->pr_reg_all_tg_pt = all_tg_pt;\r\npr_reg->pr_reg_aptpl = 1;\r\npr_reg->pr_reg_tg_pt_lun = NULL;\r\npr_reg->pr_res_scope = 0;\r\npr_reg->pr_res_type = type;\r\nif (isid != NULL) {\r\npr_reg->pr_reg_bin_isid = get_unaligned_be64(isid);\r\nsnprintf(pr_reg->pr_reg_isid, PR_REG_ISID_LEN, "%s", isid);\r\npr_reg->isid_present_at_reg = 1;\r\n}\r\nsnprintf(pr_reg->pr_iport, PR_APTPL_MAX_IPORT_LEN, "%s", i_port);\r\nsnprintf(pr_reg->pr_tport, PR_APTPL_MAX_TPORT_LEN, "%s", t_port);\r\npr_reg->pr_reg_tpgt = tpgt;\r\npr_reg->pr_res_holder = res_holder;\r\nlist_add_tail(&pr_reg->pr_reg_aptpl_list, &pr_tmpl->aptpl_reg_list);\r\npr_debug("SPC-3 PR APTPL Successfully added registration%s from"\r\n" metadata\n", (res_holder) ? "+reservation" : "");\r\nreturn 0;\r\n}\r\nstatic void core_scsi3_aptpl_reserve(\r\nstruct se_device *dev,\r\nstruct se_portal_group *tpg,\r\nstruct se_node_acl *node_acl,\r\nstruct t10_pr_registration *pr_reg)\r\n{\r\nchar i_buf[PR_REG_ISID_ID_LEN];\r\nmemset(i_buf, 0, PR_REG_ISID_ID_LEN);\r\ncore_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);\r\nspin_lock(&dev->dev_reservation_lock);\r\ndev->dev_pr_res_holder = pr_reg;\r\nspin_unlock(&dev->dev_reservation_lock);\r\npr_debug("SPC-3 PR [%s] Service Action: APTPL RESERVE created"\r\n" new reservation holder TYPE: %s ALL_TG_PT: %d\n",\r\ntpg->se_tpg_tfo->get_fabric_name(),\r\ncore_scsi3_pr_dump_type(pr_reg->pr_res_type),\r\n(pr_reg->pr_reg_all_tg_pt) ? 1 : 0);\r\npr_debug("SPC-3 PR [%s] RESERVE Node: %s%s\n",\r\ntpg->se_tpg_tfo->get_fabric_name(), node_acl->initiatorname,\r\ni_buf);\r\n}\r\nstatic int __core_scsi3_check_aptpl_registration(\r\nstruct se_device *dev,\r\nstruct se_portal_group *tpg,\r\nstruct se_lun *lun,\r\nu32 target_lun,\r\nstruct se_node_acl *nacl,\r\nstruct se_dev_entry *deve)\r\n{\r\nstruct t10_pr_registration *pr_reg, *pr_reg_tmp;\r\nstruct t10_reservation *pr_tmpl = &dev->t10_pr;\r\nunsigned char i_port[PR_APTPL_MAX_IPORT_LEN];\r\nunsigned char t_port[PR_APTPL_MAX_TPORT_LEN];\r\nu16 tpgt;\r\nmemset(i_port, 0, PR_APTPL_MAX_IPORT_LEN);\r\nmemset(t_port, 0, PR_APTPL_MAX_TPORT_LEN);\r\nsnprintf(i_port, PR_APTPL_MAX_IPORT_LEN, "%s", nacl->initiatorname);\r\nsnprintf(t_port, PR_APTPL_MAX_TPORT_LEN, "%s",\r\ntpg->se_tpg_tfo->tpg_get_wwn(tpg));\r\ntpgt = tpg->se_tpg_tfo->tpg_get_tag(tpg);\r\nspin_lock(&pr_tmpl->aptpl_reg_lock);\r\nlist_for_each_entry_safe(pr_reg, pr_reg_tmp, &pr_tmpl->aptpl_reg_list,\r\npr_reg_aptpl_list) {\r\nif (!strcmp(pr_reg->pr_iport, i_port) &&\r\n(pr_reg->pr_res_mapped_lun == deve->mapped_lun) &&\r\n!(strcmp(pr_reg->pr_tport, t_port)) &&\r\n(pr_reg->pr_reg_tpgt == tpgt) &&\r\n(pr_reg->pr_aptpl_target_lun == target_lun)) {\r\npr_reg->pr_reg_nacl = nacl;\r\npr_reg->pr_reg_deve = deve;\r\npr_reg->pr_reg_tg_pt_lun = lun;\r\nlist_del(&pr_reg->pr_reg_aptpl_list);\r\nspin_unlock(&pr_tmpl->aptpl_reg_lock);\r\n__core_scsi3_add_registration(dev, nacl, pr_reg, 0, 0);\r\nif (pr_reg->pr_res_holder)\r\ncore_scsi3_aptpl_reserve(dev, tpg,\r\nnacl, pr_reg);\r\nspin_lock(&pr_tmpl->aptpl_reg_lock);\r\npr_tmpl->pr_aptpl_active = 1;\r\n}\r\n}\r\nspin_unlock(&pr_tmpl->aptpl_reg_lock);\r\nreturn 0;\r\n}\r\nint core_scsi3_check_aptpl_registration(\r\nstruct se_device *dev,\r\nstruct se_portal_group *tpg,\r\nstruct se_lun *lun,\r\nstruct se_lun_acl *lun_acl)\r\n{\r\nstruct se_node_acl *nacl = lun_acl->se_lun_nacl;\r\nstruct se_dev_entry *deve = nacl->device_list[lun_acl->mapped_lun];\r\nif (dev->dev_reservation_flags & DRF_SPC2_RESERVATIONS)\r\nreturn 0;\r\nreturn __core_scsi3_check_aptpl_registration(dev, tpg, lun,\r\nlun->unpacked_lun, nacl, deve);\r\n}\r\nstatic void __core_scsi3_dump_registration(\r\nstruct target_core_fabric_ops *tfo,\r\nstruct se_device *dev,\r\nstruct se_node_acl *nacl,\r\nstruct t10_pr_registration *pr_reg,\r\nenum register_type register_type)\r\n{\r\nstruct se_portal_group *se_tpg = nacl->se_tpg;\r\nchar i_buf[PR_REG_ISID_ID_LEN];\r\nmemset(&i_buf[0], 0, PR_REG_ISID_ID_LEN);\r\ncore_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);\r\npr_debug("SPC-3 PR [%s] Service Action: REGISTER%s Initiator"\r\n" Node: %s%s\n", tfo->get_fabric_name(), (register_type == REGISTER_AND_MOVE) ?\r\n"_AND_MOVE" : (register_type == REGISTER_AND_IGNORE_EXISTING_KEY) ?\r\n"_AND_IGNORE_EXISTING_KEY" : "", nacl->initiatorname,\r\ni_buf);\r\npr_debug("SPC-3 PR [%s] registration on Target Port: %s,0x%04x\n",\r\ntfo->get_fabric_name(), tfo->tpg_get_wwn(se_tpg),\r\ntfo->tpg_get_tag(se_tpg));\r\npr_debug("SPC-3 PR [%s] for %s TCM Subsystem %s Object Target"\r\n" Port(s)\n", tfo->get_fabric_name(),\r\n(pr_reg->pr_reg_all_tg_pt) ? "ALL" : "SINGLE",\r\ndev->transport->name);\r\npr_debug("SPC-3 PR [%s] SA Res Key: 0x%016Lx PRgeneration:"\r\n" 0x%08x APTPL: %d\n", tfo->get_fabric_name(),\r\npr_reg->pr_res_key, pr_reg->pr_res_generation,\r\npr_reg->pr_reg_aptpl);\r\n}\r\nstatic void __core_scsi3_add_registration(\r\nstruct se_device *dev,\r\nstruct se_node_acl *nacl,\r\nstruct t10_pr_registration *pr_reg,\r\nenum register_type register_type,\r\nint register_move)\r\n{\r\nstruct target_core_fabric_ops *tfo = nacl->se_tpg->se_tpg_tfo;\r\nstruct t10_pr_registration *pr_reg_tmp, *pr_reg_tmp_safe;\r\nstruct t10_reservation *pr_tmpl = &dev->t10_pr;\r\npr_reg->pr_res_generation = (register_move) ?\r\ndev->t10_pr.pr_generation++ :\r\ncore_scsi3_pr_generation(dev);\r\nspin_lock(&pr_tmpl->registration_lock);\r\nlist_add_tail(&pr_reg->pr_reg_list, &pr_tmpl->registration_list);\r\npr_reg->pr_reg_deve->def_pr_registered = 1;\r\n__core_scsi3_dump_registration(tfo, dev, nacl, pr_reg, register_type);\r\nspin_unlock(&pr_tmpl->registration_lock);\r\nif (!pr_reg->pr_reg_all_tg_pt || register_move)\r\nreturn;\r\nlist_for_each_entry_safe(pr_reg_tmp, pr_reg_tmp_safe,\r\n&pr_reg->pr_reg_atp_list, pr_reg_atp_mem_list) {\r\nlist_del(&pr_reg_tmp->pr_reg_atp_mem_list);\r\npr_reg_tmp->pr_res_generation = core_scsi3_pr_generation(dev);\r\nspin_lock(&pr_tmpl->registration_lock);\r\nlist_add_tail(&pr_reg_tmp->pr_reg_list,\r\n&pr_tmpl->registration_list);\r\npr_reg_tmp->pr_reg_deve->def_pr_registered = 1;\r\n__core_scsi3_dump_registration(tfo, dev,\r\npr_reg_tmp->pr_reg_nacl, pr_reg_tmp,\r\nregister_type);\r\nspin_unlock(&pr_tmpl->registration_lock);\r\ncore_scsi3_lunacl_undepend_item(pr_reg_tmp->pr_reg_deve);\r\n}\r\n}\r\nstatic int core_scsi3_alloc_registration(\r\nstruct se_device *dev,\r\nstruct se_node_acl *nacl,\r\nstruct se_dev_entry *deve,\r\nunsigned char *isid,\r\nu64 sa_res_key,\r\nint all_tg_pt,\r\nint aptpl,\r\nenum register_type register_type,\r\nint register_move)\r\n{\r\nstruct t10_pr_registration *pr_reg;\r\npr_reg = __core_scsi3_alloc_registration(dev, nacl, deve, isid,\r\nsa_res_key, all_tg_pt, aptpl);\r\nif (!pr_reg)\r\nreturn -EPERM;\r\n__core_scsi3_add_registration(dev, nacl, pr_reg,\r\nregister_type, register_move);\r\nreturn 0;\r\n}\r\nstatic struct t10_pr_registration *__core_scsi3_locate_pr_reg(\r\nstruct se_device *dev,\r\nstruct se_node_acl *nacl,\r\nunsigned char *isid)\r\n{\r\nstruct t10_reservation *pr_tmpl = &dev->t10_pr;\r\nstruct t10_pr_registration *pr_reg, *pr_reg_tmp;\r\nstruct se_portal_group *tpg;\r\nspin_lock(&pr_tmpl->registration_lock);\r\nlist_for_each_entry_safe(pr_reg, pr_reg_tmp,\r\n&pr_tmpl->registration_list, pr_reg_list) {\r\nif (pr_reg->pr_reg_nacl != nacl)\r\ncontinue;\r\ntpg = pr_reg->pr_reg_nacl->se_tpg;\r\nif (!pr_reg->isid_present_at_reg) {\r\nif (tpg->se_tpg_tfo->sess_get_initiator_sid != NULL) {\r\nif (dev->dev_attrib.enforce_pr_isids)\r\ncontinue;\r\n}\r\natomic_inc(&pr_reg->pr_res_holders);\r\nsmp_mb__after_atomic();\r\nspin_unlock(&pr_tmpl->registration_lock);\r\nreturn pr_reg;\r\n}\r\nif (!isid)\r\ncontinue;\r\nif (strcmp(isid, pr_reg->pr_reg_isid))\r\ncontinue;\r\natomic_inc(&pr_reg->pr_res_holders);\r\nsmp_mb__after_atomic();\r\nspin_unlock(&pr_tmpl->registration_lock);\r\nreturn pr_reg;\r\n}\r\nspin_unlock(&pr_tmpl->registration_lock);\r\nreturn NULL;\r\n}\r\nstatic struct t10_pr_registration *core_scsi3_locate_pr_reg(\r\nstruct se_device *dev,\r\nstruct se_node_acl *nacl,\r\nstruct se_session *sess)\r\n{\r\nstruct se_portal_group *tpg = nacl->se_tpg;\r\nunsigned char buf[PR_REG_ISID_LEN], *isid_ptr = NULL;\r\nif (tpg->se_tpg_tfo->sess_get_initiator_sid != NULL) {\r\nmemset(&buf[0], 0, PR_REG_ISID_LEN);\r\ntpg->se_tpg_tfo->sess_get_initiator_sid(sess, &buf[0],\r\nPR_REG_ISID_LEN);\r\nisid_ptr = &buf[0];\r\n}\r\nreturn __core_scsi3_locate_pr_reg(dev, nacl, isid_ptr);\r\n}\r\nstatic void core_scsi3_put_pr_reg(struct t10_pr_registration *pr_reg)\r\n{\r\natomic_dec(&pr_reg->pr_res_holders);\r\nsmp_mb__after_atomic();\r\n}\r\nstatic int core_scsi3_check_implicit_release(\r\nstruct se_device *dev,\r\nstruct t10_pr_registration *pr_reg)\r\n{\r\nstruct se_node_acl *nacl = pr_reg->pr_reg_nacl;\r\nstruct t10_pr_registration *pr_res_holder;\r\nint ret = 0;\r\nspin_lock(&dev->dev_reservation_lock);\r\npr_res_holder = dev->dev_pr_res_holder;\r\nif (!pr_res_holder) {\r\nspin_unlock(&dev->dev_reservation_lock);\r\nreturn ret;\r\n}\r\nif (pr_res_holder == pr_reg) {\r\n__core_scsi3_complete_pro_release(dev, nacl, pr_reg, 0);\r\nret = 1;\r\n} else if (pr_reg->pr_reg_all_tg_pt &&\r\n(!strcmp(pr_res_holder->pr_reg_nacl->initiatorname,\r\npr_reg->pr_reg_nacl->initiatorname)) &&\r\n(pr_res_holder->pr_res_key == pr_reg->pr_res_key)) {\r\npr_err("SPC-3 PR: Unable to perform ALL_TG_PT=1"\r\n" UNREGISTER while existing reservation with matching"\r\n" key 0x%016Lx is present from another SCSI Initiator"\r\n" Port\n", pr_reg->pr_res_key);\r\nret = -EPERM;\r\n}\r\nspin_unlock(&dev->dev_reservation_lock);\r\nreturn ret;\r\n}\r\nstatic void __core_scsi3_free_registration(\r\nstruct se_device *dev,\r\nstruct t10_pr_registration *pr_reg,\r\nstruct list_head *preempt_and_abort_list,\r\nint dec_holders)\r\n{\r\nstruct target_core_fabric_ops *tfo =\r\npr_reg->pr_reg_nacl->se_tpg->se_tpg_tfo;\r\nstruct t10_reservation *pr_tmpl = &dev->t10_pr;\r\nchar i_buf[PR_REG_ISID_ID_LEN];\r\nmemset(i_buf, 0, PR_REG_ISID_ID_LEN);\r\ncore_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);\r\npr_reg->pr_reg_deve->def_pr_registered = 0;\r\npr_reg->pr_reg_deve->pr_res_key = 0;\r\nlist_del(&pr_reg->pr_reg_list);\r\nif (dec_holders)\r\ncore_scsi3_put_pr_reg(pr_reg);\r\nwhile (atomic_read(&pr_reg->pr_res_holders) != 0) {\r\nspin_unlock(&pr_tmpl->registration_lock);\r\npr_debug("SPC-3 PR [%s] waiting for pr_res_holders\n",\r\ntfo->get_fabric_name());\r\ncpu_relax();\r\nspin_lock(&pr_tmpl->registration_lock);\r\n}\r\npr_debug("SPC-3 PR [%s] Service Action: UNREGISTER Initiator"\r\n" Node: %s%s\n", tfo->get_fabric_name(),\r\npr_reg->pr_reg_nacl->initiatorname,\r\ni_buf);\r\npr_debug("SPC-3 PR [%s] for %s TCM Subsystem %s Object Target"\r\n" Port(s)\n", tfo->get_fabric_name(),\r\n(pr_reg->pr_reg_all_tg_pt) ? "ALL" : "SINGLE",\r\ndev->transport->name);\r\npr_debug("SPC-3 PR [%s] SA Res Key: 0x%016Lx PRgeneration:"\r\n" 0x%08x\n", tfo->get_fabric_name(), pr_reg->pr_res_key,\r\npr_reg->pr_res_generation);\r\nif (!preempt_and_abort_list) {\r\npr_reg->pr_reg_deve = NULL;\r\npr_reg->pr_reg_nacl = NULL;\r\nkmem_cache_free(t10_pr_reg_cache, pr_reg);\r\nreturn;\r\n}\r\nlist_add_tail(&pr_reg->pr_reg_abort_list, preempt_and_abort_list);\r\n}\r\nvoid core_scsi3_free_pr_reg_from_nacl(\r\nstruct se_device *dev,\r\nstruct se_node_acl *nacl)\r\n{\r\nstruct t10_reservation *pr_tmpl = &dev->t10_pr;\r\nstruct t10_pr_registration *pr_reg, *pr_reg_tmp, *pr_res_holder;\r\nspin_lock(&dev->dev_reservation_lock);\r\npr_res_holder = dev->dev_pr_res_holder;\r\nif ((pr_res_holder != NULL) &&\r\n(pr_res_holder->pr_reg_nacl == nacl))\r\n__core_scsi3_complete_pro_release(dev, nacl, pr_res_holder, 0);\r\nspin_unlock(&dev->dev_reservation_lock);\r\nspin_lock(&pr_tmpl->registration_lock);\r\nlist_for_each_entry_safe(pr_reg, pr_reg_tmp,\r\n&pr_tmpl->registration_list, pr_reg_list) {\r\nif (pr_reg->pr_reg_nacl != nacl)\r\ncontinue;\r\n__core_scsi3_free_registration(dev, pr_reg, NULL, 0);\r\n}\r\nspin_unlock(&pr_tmpl->registration_lock);\r\n}\r\nvoid core_scsi3_free_all_registrations(\r\nstruct se_device *dev)\r\n{\r\nstruct t10_reservation *pr_tmpl = &dev->t10_pr;\r\nstruct t10_pr_registration *pr_reg, *pr_reg_tmp, *pr_res_holder;\r\nspin_lock(&dev->dev_reservation_lock);\r\npr_res_holder = dev->dev_pr_res_holder;\r\nif (pr_res_holder != NULL) {\r\nstruct se_node_acl *pr_res_nacl = pr_res_holder->pr_reg_nacl;\r\n__core_scsi3_complete_pro_release(dev, pr_res_nacl,\r\npr_res_holder, 0);\r\n}\r\nspin_unlock(&dev->dev_reservation_lock);\r\nspin_lock(&pr_tmpl->registration_lock);\r\nlist_for_each_entry_safe(pr_reg, pr_reg_tmp,\r\n&pr_tmpl->registration_list, pr_reg_list) {\r\n__core_scsi3_free_registration(dev, pr_reg, NULL, 0);\r\n}\r\nspin_unlock(&pr_tmpl->registration_lock);\r\nspin_lock(&pr_tmpl->aptpl_reg_lock);\r\nlist_for_each_entry_safe(pr_reg, pr_reg_tmp, &pr_tmpl->aptpl_reg_list,\r\npr_reg_aptpl_list) {\r\nlist_del(&pr_reg->pr_reg_aptpl_list);\r\nkmem_cache_free(t10_pr_reg_cache, pr_reg);\r\n}\r\nspin_unlock(&pr_tmpl->aptpl_reg_lock);\r\n}\r\nstatic int core_scsi3_tpg_depend_item(struct se_portal_group *tpg)\r\n{\r\nreturn configfs_depend_item(tpg->se_tpg_tfo->tf_subsys,\r\n&tpg->tpg_group.cg_item);\r\n}\r\nstatic void core_scsi3_tpg_undepend_item(struct se_portal_group *tpg)\r\n{\r\nconfigfs_undepend_item(tpg->se_tpg_tfo->tf_subsys,\r\n&tpg->tpg_group.cg_item);\r\natomic_dec(&tpg->tpg_pr_ref_count);\r\nsmp_mb__after_atomic();\r\n}\r\nstatic int core_scsi3_nodeacl_depend_item(struct se_node_acl *nacl)\r\n{\r\nstruct se_portal_group *tpg = nacl->se_tpg;\r\nif (nacl->dynamic_node_acl)\r\nreturn 0;\r\nreturn configfs_depend_item(tpg->se_tpg_tfo->tf_subsys,\r\n&nacl->acl_group.cg_item);\r\n}\r\nstatic void core_scsi3_nodeacl_undepend_item(struct se_node_acl *nacl)\r\n{\r\nstruct se_portal_group *tpg = nacl->se_tpg;\r\nif (nacl->dynamic_node_acl) {\r\natomic_dec(&nacl->acl_pr_ref_count);\r\nsmp_mb__after_atomic();\r\nreturn;\r\n}\r\nconfigfs_undepend_item(tpg->se_tpg_tfo->tf_subsys,\r\n&nacl->acl_group.cg_item);\r\natomic_dec(&nacl->acl_pr_ref_count);\r\nsmp_mb__after_atomic();\r\n}\r\nstatic int core_scsi3_lunacl_depend_item(struct se_dev_entry *se_deve)\r\n{\r\nstruct se_lun_acl *lun_acl = se_deve->se_lun_acl;\r\nstruct se_node_acl *nacl;\r\nstruct se_portal_group *tpg;\r\nif (!lun_acl)\r\nreturn 0;\r\nnacl = lun_acl->se_lun_nacl;\r\ntpg = nacl->se_tpg;\r\nreturn configfs_depend_item(tpg->se_tpg_tfo->tf_subsys,\r\n&lun_acl->se_lun_group.cg_item);\r\n}\r\nstatic void core_scsi3_lunacl_undepend_item(struct se_dev_entry *se_deve)\r\n{\r\nstruct se_lun_acl *lun_acl = se_deve->se_lun_acl;\r\nstruct se_node_acl *nacl;\r\nstruct se_portal_group *tpg;\r\nif (!lun_acl) {\r\natomic_dec(&se_deve->pr_ref_count);\r\nsmp_mb__after_atomic();\r\nreturn;\r\n}\r\nnacl = lun_acl->se_lun_nacl;\r\ntpg = nacl->se_tpg;\r\nconfigfs_undepend_item(tpg->se_tpg_tfo->tf_subsys,\r\n&lun_acl->se_lun_group.cg_item);\r\natomic_dec(&se_deve->pr_ref_count);\r\nsmp_mb__after_atomic();\r\n}\r\nstatic sense_reason_t\r\ncore_scsi3_decode_spec_i_port(\r\nstruct se_cmd *cmd,\r\nstruct se_portal_group *tpg,\r\nunsigned char *l_isid,\r\nu64 sa_res_key,\r\nint all_tg_pt,\r\nint aptpl)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_port *tmp_port;\r\nstruct se_portal_group *dest_tpg = NULL, *tmp_tpg;\r\nstruct se_session *se_sess = cmd->se_sess;\r\nstruct se_node_acl *dest_node_acl = NULL;\r\nstruct se_dev_entry *dest_se_deve = NULL, *local_se_deve;\r\nstruct t10_pr_registration *dest_pr_reg, *local_pr_reg, *pr_reg_e;\r\nstruct t10_pr_registration *pr_reg_tmp, *pr_reg_tmp_safe;\r\nLIST_HEAD(tid_dest_list);\r\nstruct pr_transport_id_holder *tidh_new, *tidh, *tidh_tmp;\r\nstruct target_core_fabric_ops *tmp_tf_ops;\r\nunsigned char *buf;\r\nunsigned char *ptr, *i_str = NULL, proto_ident, tmp_proto_ident;\r\nchar *iport_ptr = NULL, dest_iport[64], i_buf[PR_REG_ISID_ID_LEN];\r\nsense_reason_t ret;\r\nu32 tpdl, tid_len = 0;\r\nint dest_local_nexus;\r\nu32 dest_rtpi = 0;\r\nmemset(dest_iport, 0, 64);\r\nlocal_se_deve = se_sess->se_node_acl->device_list[cmd->orig_fe_lun];\r\ntidh_new = kzalloc(sizeof(struct pr_transport_id_holder), GFP_KERNEL);\r\nif (!tidh_new) {\r\npr_err("Unable to allocate tidh_new\n");\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\nINIT_LIST_HEAD(&tidh_new->dest_list);\r\ntidh_new->dest_tpg = tpg;\r\ntidh_new->dest_node_acl = se_sess->se_node_acl;\r\ntidh_new->dest_se_deve = local_se_deve;\r\nlocal_pr_reg = __core_scsi3_alloc_registration(cmd->se_dev,\r\nse_sess->se_node_acl, local_se_deve, l_isid,\r\nsa_res_key, all_tg_pt, aptpl);\r\nif (!local_pr_reg) {\r\nkfree(tidh_new);\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\ntidh_new->dest_pr_reg = local_pr_reg;\r\ntidh_new->dest_local_nexus = 1;\r\nlist_add_tail(&tidh_new->dest_list, &tid_dest_list);\r\nif (cmd->data_length < 28) {\r\npr_warn("SPC-PR: Received PR OUT parameter list"\r\n" length too small: %u\n", cmd->data_length);\r\nret = TCM_INVALID_PARAMETER_LIST;\r\ngoto out;\r\n}\r\nbuf = transport_kmap_data_sg(cmd);\r\nif (!buf) {\r\nret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\ngoto out;\r\n}\r\ntpdl = (buf[24] & 0xff) << 24;\r\ntpdl |= (buf[25] & 0xff) << 16;\r\ntpdl |= (buf[26] & 0xff) << 8;\r\ntpdl |= buf[27] & 0xff;\r\nif ((tpdl + 28) != cmd->data_length) {\r\npr_err("SPC-3 PR: Illegal tpdl: %u + 28 byte header"\r\n" does not equal CDB data_length: %u\n", tpdl,\r\ncmd->data_length);\r\nret = TCM_INVALID_PARAMETER_LIST;\r\ngoto out_unmap;\r\n}\r\nptr = &buf[28];\r\nwhile (tpdl > 0) {\r\nproto_ident = (ptr[0] & 0x0f);\r\ndest_tpg = NULL;\r\nspin_lock(&dev->se_port_lock);\r\nlist_for_each_entry(tmp_port, &dev->dev_sep_list, sep_list) {\r\ntmp_tpg = tmp_port->sep_tpg;\r\nif (!tmp_tpg)\r\ncontinue;\r\ntmp_tf_ops = tmp_tpg->se_tpg_tfo;\r\nif (!tmp_tf_ops)\r\ncontinue;\r\nif (!tmp_tf_ops->get_fabric_proto_ident ||\r\n!tmp_tf_ops->tpg_parse_pr_out_transport_id)\r\ncontinue;\r\ntmp_proto_ident = tmp_tf_ops->get_fabric_proto_ident(tmp_tpg);\r\nif (tmp_proto_ident != proto_ident)\r\ncontinue;\r\ndest_rtpi = tmp_port->sep_rtpi;\r\ni_str = tmp_tf_ops->tpg_parse_pr_out_transport_id(\r\ntmp_tpg, (const char *)ptr, &tid_len,\r\n&iport_ptr);\r\nif (!i_str)\r\ncontinue;\r\natomic_inc(&tmp_tpg->tpg_pr_ref_count);\r\nsmp_mb__after_atomic();\r\nspin_unlock(&dev->se_port_lock);\r\nif (core_scsi3_tpg_depend_item(tmp_tpg)) {\r\npr_err(" core_scsi3_tpg_depend_item()"\r\n" for tmp_tpg\n");\r\natomic_dec(&tmp_tpg->tpg_pr_ref_count);\r\nsmp_mb__after_atomic();\r\nret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\ngoto out_unmap;\r\n}\r\nspin_lock_irq(&tmp_tpg->acl_node_lock);\r\ndest_node_acl = __core_tpg_get_initiator_node_acl(\r\ntmp_tpg, i_str);\r\nif (dest_node_acl) {\r\natomic_inc(&dest_node_acl->acl_pr_ref_count);\r\nsmp_mb__after_atomic();\r\n}\r\nspin_unlock_irq(&tmp_tpg->acl_node_lock);\r\nif (!dest_node_acl) {\r\ncore_scsi3_tpg_undepend_item(tmp_tpg);\r\nspin_lock(&dev->se_port_lock);\r\ncontinue;\r\n}\r\nif (core_scsi3_nodeacl_depend_item(dest_node_acl)) {\r\npr_err("configfs_depend_item() failed"\r\n" for dest_node_acl->acl_group\n");\r\natomic_dec(&dest_node_acl->acl_pr_ref_count);\r\nsmp_mb__after_atomic();\r\ncore_scsi3_tpg_undepend_item(tmp_tpg);\r\nret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\ngoto out_unmap;\r\n}\r\ndest_tpg = tmp_tpg;\r\npr_debug("SPC-3 PR SPEC_I_PT: Located %s Node:"\r\n" %s Port RTPI: %hu\n",\r\ndest_tpg->se_tpg_tfo->get_fabric_name(),\r\ndest_node_acl->initiatorname, dest_rtpi);\r\nspin_lock(&dev->se_port_lock);\r\nbreak;\r\n}\r\nspin_unlock(&dev->se_port_lock);\r\nif (!dest_tpg) {\r\npr_err("SPC-3 PR SPEC_I_PT: Unable to locate"\r\n" dest_tpg\n");\r\nret = TCM_INVALID_PARAMETER_LIST;\r\ngoto out_unmap;\r\n}\r\npr_debug("SPC-3 PR SPEC_I_PT: Got %s data_length: %u tpdl: %u"\r\n" tid_len: %d for %s + %s\n",\r\ndest_tpg->se_tpg_tfo->get_fabric_name(), cmd->data_length,\r\ntpdl, tid_len, i_str, iport_ptr);\r\nif (tid_len > tpdl) {\r\npr_err("SPC-3 PR SPEC_I_PT: Illegal tid_len:"\r\n" %u for Transport ID: %s\n", tid_len, ptr);\r\ncore_scsi3_nodeacl_undepend_item(dest_node_acl);\r\ncore_scsi3_tpg_undepend_item(dest_tpg);\r\nret = TCM_INVALID_PARAMETER_LIST;\r\ngoto out_unmap;\r\n}\r\ndest_se_deve = core_get_se_deve_from_rtpi(dest_node_acl,\r\ndest_rtpi);\r\nif (!dest_se_deve) {\r\npr_err("Unable to locate %s dest_se_deve"\r\n" from destination RTPI: %hu\n",\r\ndest_tpg->se_tpg_tfo->get_fabric_name(),\r\ndest_rtpi);\r\ncore_scsi3_nodeacl_undepend_item(dest_node_acl);\r\ncore_scsi3_tpg_undepend_item(dest_tpg);\r\nret = TCM_INVALID_PARAMETER_LIST;\r\ngoto out_unmap;\r\n}\r\nif (core_scsi3_lunacl_depend_item(dest_se_deve)) {\r\npr_err("core_scsi3_lunacl_depend_item()"\r\n" failed\n");\r\natomic_dec(&dest_se_deve->pr_ref_count);\r\nsmp_mb__after_atomic();\r\ncore_scsi3_nodeacl_undepend_item(dest_node_acl);\r\ncore_scsi3_tpg_undepend_item(dest_tpg);\r\nret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\ngoto out_unmap;\r\n}\r\npr_debug("SPC-3 PR SPEC_I_PT: Located %s Node: %s"\r\n" dest_se_deve mapped_lun: %u\n",\r\ndest_tpg->se_tpg_tfo->get_fabric_name(),\r\ndest_node_acl->initiatorname, dest_se_deve->mapped_lun);\r\npr_reg_e = __core_scsi3_locate_pr_reg(dev, dest_node_acl,\r\niport_ptr);\r\nif (pr_reg_e) {\r\ncore_scsi3_put_pr_reg(pr_reg_e);\r\ncore_scsi3_lunacl_undepend_item(dest_se_deve);\r\ncore_scsi3_nodeacl_undepend_item(dest_node_acl);\r\ncore_scsi3_tpg_undepend_item(dest_tpg);\r\nptr += tid_len;\r\ntpdl -= tid_len;\r\ntid_len = 0;\r\ncontinue;\r\n}\r\ntidh_new = kzalloc(sizeof(struct pr_transport_id_holder),\r\nGFP_KERNEL);\r\nif (!tidh_new) {\r\npr_err("Unable to allocate tidh_new\n");\r\ncore_scsi3_lunacl_undepend_item(dest_se_deve);\r\ncore_scsi3_nodeacl_undepend_item(dest_node_acl);\r\ncore_scsi3_tpg_undepend_item(dest_tpg);\r\nret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\ngoto out_unmap;\r\n}\r\nINIT_LIST_HEAD(&tidh_new->dest_list);\r\ntidh_new->dest_tpg = dest_tpg;\r\ntidh_new->dest_node_acl = dest_node_acl;\r\ntidh_new->dest_se_deve = dest_se_deve;\r\ndest_pr_reg = __core_scsi3_alloc_registration(cmd->se_dev,\r\ndest_node_acl, dest_se_deve, iport_ptr,\r\nsa_res_key, all_tg_pt, aptpl);\r\nif (!dest_pr_reg) {\r\ncore_scsi3_lunacl_undepend_item(dest_se_deve);\r\ncore_scsi3_nodeacl_undepend_item(dest_node_acl);\r\ncore_scsi3_tpg_undepend_item(dest_tpg);\r\nkfree(tidh_new);\r\nret = TCM_INVALID_PARAMETER_LIST;\r\ngoto out_unmap;\r\n}\r\ntidh_new->dest_pr_reg = dest_pr_reg;\r\nlist_add_tail(&tidh_new->dest_list, &tid_dest_list);\r\nptr += tid_len;\r\ntpdl -= tid_len;\r\ntid_len = 0;\r\n}\r\ntransport_kunmap_data_sg(cmd);\r\nlist_for_each_entry_safe(tidh, tidh_tmp, &tid_dest_list, dest_list) {\r\ndest_tpg = tidh->dest_tpg;\r\ndest_node_acl = tidh->dest_node_acl;\r\ndest_se_deve = tidh->dest_se_deve;\r\ndest_pr_reg = tidh->dest_pr_reg;\r\ndest_local_nexus = tidh->dest_local_nexus;\r\nlist_del(&tidh->dest_list);\r\nkfree(tidh);\r\nmemset(i_buf, 0, PR_REG_ISID_ID_LEN);\r\ncore_pr_dump_initiator_port(dest_pr_reg, i_buf, PR_REG_ISID_ID_LEN);\r\n__core_scsi3_add_registration(cmd->se_dev, dest_node_acl,\r\ndest_pr_reg, 0, 0);\r\npr_debug("SPC-3 PR [%s] SPEC_I_PT: Successfully"\r\n" registered Transport ID for Node: %s%s Mapped LUN:"\r\n" %u\n", dest_tpg->se_tpg_tfo->get_fabric_name(),\r\ndest_node_acl->initiatorname, i_buf, dest_se_deve->mapped_lun);\r\nif (dest_local_nexus)\r\ncontinue;\r\ncore_scsi3_lunacl_undepend_item(dest_se_deve);\r\ncore_scsi3_nodeacl_undepend_item(dest_node_acl);\r\ncore_scsi3_tpg_undepend_item(dest_tpg);\r\n}\r\nreturn 0;\r\nout_unmap:\r\ntransport_kunmap_data_sg(cmd);\r\nout:\r\nlist_for_each_entry_safe(tidh, tidh_tmp, &tid_dest_list, dest_list) {\r\ndest_tpg = tidh->dest_tpg;\r\ndest_node_acl = tidh->dest_node_acl;\r\ndest_se_deve = tidh->dest_se_deve;\r\ndest_pr_reg = tidh->dest_pr_reg;\r\ndest_local_nexus = tidh->dest_local_nexus;\r\nlist_del(&tidh->dest_list);\r\nkfree(tidh);\r\nlist_for_each_entry_safe(pr_reg_tmp, pr_reg_tmp_safe,\r\n&dest_pr_reg->pr_reg_atp_list,\r\npr_reg_atp_mem_list) {\r\nlist_del(&pr_reg_tmp->pr_reg_atp_mem_list);\r\ncore_scsi3_lunacl_undepend_item(pr_reg_tmp->pr_reg_deve);\r\nkmem_cache_free(t10_pr_reg_cache, pr_reg_tmp);\r\n}\r\nkmem_cache_free(t10_pr_reg_cache, dest_pr_reg);\r\nif (dest_local_nexus)\r\ncontinue;\r\ncore_scsi3_lunacl_undepend_item(dest_se_deve);\r\ncore_scsi3_nodeacl_undepend_item(dest_node_acl);\r\ncore_scsi3_tpg_undepend_item(dest_tpg);\r\n}\r\nreturn ret;\r\n}\r\nstatic int core_scsi3_update_aptpl_buf(\r\nstruct se_device *dev,\r\nunsigned char *buf,\r\nu32 pr_aptpl_buf_len)\r\n{\r\nstruct se_lun *lun;\r\nstruct se_portal_group *tpg;\r\nstruct t10_pr_registration *pr_reg;\r\nunsigned char tmp[512], isid_buf[32];\r\nssize_t len = 0;\r\nint reg_count = 0;\r\nint ret = 0;\r\nspin_lock(&dev->dev_reservation_lock);\r\nspin_lock(&dev->t10_pr.registration_lock);\r\nlist_for_each_entry(pr_reg, &dev->t10_pr.registration_list,\r\npr_reg_list) {\r\ntmp[0] = '\0';\r\nisid_buf[0] = '\0';\r\ntpg = pr_reg->pr_reg_nacl->se_tpg;\r\nlun = pr_reg->pr_reg_tg_pt_lun;\r\nif (pr_reg->isid_present_at_reg)\r\nsnprintf(isid_buf, 32, "initiator_sid=%s\n",\r\npr_reg->pr_reg_isid);\r\nif (dev->dev_pr_res_holder == pr_reg) {\r\nsnprintf(tmp, 512, "PR_REG_START: %d"\r\n"\ninitiator_fabric=%s\n"\r\n"initiator_node=%s\n%s"\r\n"sa_res_key=%llu\n"\r\n"res_holder=1\nres_type=%02x\n"\r\n"res_scope=%02x\nres_all_tg_pt=%d\n"\r\n"mapped_lun=%u\n", reg_count,\r\ntpg->se_tpg_tfo->get_fabric_name(),\r\npr_reg->pr_reg_nacl->initiatorname, isid_buf,\r\npr_reg->pr_res_key, pr_reg->pr_res_type,\r\npr_reg->pr_res_scope, pr_reg->pr_reg_all_tg_pt,\r\npr_reg->pr_res_mapped_lun);\r\n} else {\r\nsnprintf(tmp, 512, "PR_REG_START: %d\n"\r\n"initiator_fabric=%s\ninitiator_node=%s\n%s"\r\n"sa_res_key=%llu\nres_holder=0\n"\r\n"res_all_tg_pt=%d\nmapped_lun=%u\n",\r\nreg_count, tpg->se_tpg_tfo->get_fabric_name(),\r\npr_reg->pr_reg_nacl->initiatorname, isid_buf,\r\npr_reg->pr_res_key, pr_reg->pr_reg_all_tg_pt,\r\npr_reg->pr_res_mapped_lun);\r\n}\r\nif ((len + strlen(tmp) >= pr_aptpl_buf_len)) {\r\npr_err("Unable to update renaming"\r\n" APTPL metadata\n");\r\nret = -EMSGSIZE;\r\ngoto out;\r\n}\r\nlen += sprintf(buf+len, "%s", tmp);\r\nsnprintf(tmp, 512, "target_fabric=%s\ntarget_node=%s\n"\r\n"tpgt=%hu\nport_rtpi=%hu\ntarget_lun=%u\nPR_REG_END:"\r\n" %d\n", tpg->se_tpg_tfo->get_fabric_name(),\r\ntpg->se_tpg_tfo->tpg_get_wwn(tpg),\r\ntpg->se_tpg_tfo->tpg_get_tag(tpg),\r\nlun->lun_sep->sep_rtpi, lun->unpacked_lun, reg_count);\r\nif ((len + strlen(tmp) >= pr_aptpl_buf_len)) {\r\npr_err("Unable to update renaming"\r\n" APTPL metadata\n");\r\nret = -EMSGSIZE;\r\ngoto out;\r\n}\r\nlen += sprintf(buf+len, "%s", tmp);\r\nreg_count++;\r\n}\r\nif (!reg_count)\r\nlen += sprintf(buf+len, "No Registrations or Reservations");\r\nout:\r\nspin_unlock(&dev->t10_pr.registration_lock);\r\nspin_unlock(&dev->dev_reservation_lock);\r\nreturn ret;\r\n}\r\nstatic int __core_scsi3_write_aptpl_to_file(\r\nstruct se_device *dev,\r\nunsigned char *buf)\r\n{\r\nstruct t10_wwn *wwn = &dev->t10_wwn;\r\nstruct file *file;\r\nint flags = O_RDWR | O_CREAT | O_TRUNC;\r\nchar path[512];\r\nu32 pr_aptpl_buf_len;\r\nint ret;\r\nmemset(path, 0, 512);\r\nif (strlen(&wwn->unit_serial[0]) >= 512) {\r\npr_err("WWN value for struct se_device does not fit"\r\n" into path buffer\n");\r\nreturn -EMSGSIZE;\r\n}\r\nsnprintf(path, 512, "/var/target/pr/aptpl_%s", &wwn->unit_serial[0]);\r\nfile = filp_open(path, flags, 0600);\r\nif (IS_ERR(file)) {\r\npr_err("filp_open(%s) for APTPL metadata"\r\n" failed\n", path);\r\nreturn PTR_ERR(file);\r\n}\r\npr_aptpl_buf_len = (strlen(buf) + 1);\r\nret = kernel_write(file, buf, pr_aptpl_buf_len, 0);\r\nif (ret < 0)\r\npr_debug("Error writing APTPL metadata file: %s\n", path);\r\nfput(file);\r\nreturn (ret < 0) ? -EIO : 0;\r\n}\r\nstatic sense_reason_t core_scsi3_update_and_write_aptpl(struct se_device *dev, bool aptpl)\r\n{\r\nunsigned char *buf;\r\nint rc;\r\nif (!aptpl) {\r\nchar *null_buf = "No Registrations or Reservations\n";\r\nrc = __core_scsi3_write_aptpl_to_file(dev, null_buf);\r\ndev->t10_pr.pr_aptpl_active = 0;\r\npr_debug("SPC-3 PR: Set APTPL Bit Deactivated\n");\r\nif (rc)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nreturn 0;\r\n}\r\nbuf = kzalloc(PR_APTPL_BUF_LEN, GFP_KERNEL);\r\nif (!buf)\r\nreturn TCM_OUT_OF_RESOURCES;\r\nrc = core_scsi3_update_aptpl_buf(dev, buf, PR_APTPL_BUF_LEN);\r\nif (rc < 0) {\r\nkfree(buf);\r\nreturn TCM_OUT_OF_RESOURCES;\r\n}\r\nrc = __core_scsi3_write_aptpl_to_file(dev, buf);\r\nif (rc != 0) {\r\npr_err("SPC-3 PR: Could not update APTPL\n");\r\nkfree(buf);\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\ndev->t10_pr.pr_aptpl_active = 1;\r\nkfree(buf);\r\npr_debug("SPC-3 PR: Set APTPL Bit Activated\n");\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\ncore_scsi3_emulate_pro_register(struct se_cmd *cmd, u64 res_key, u64 sa_res_key,\r\nbool aptpl, bool all_tg_pt, bool spec_i_pt, enum register_type register_type)\r\n{\r\nstruct se_session *se_sess = cmd->se_sess;\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_dev_entry *se_deve;\r\nstruct se_lun *se_lun = cmd->se_lun;\r\nstruct se_portal_group *se_tpg;\r\nstruct t10_pr_registration *pr_reg, *pr_reg_p, *pr_reg_tmp;\r\nstruct t10_reservation *pr_tmpl = &dev->t10_pr;\r\nunsigned char isid_buf[PR_REG_ISID_LEN], *isid_ptr = NULL;\r\nsense_reason_t ret = TCM_NO_SENSE;\r\nint pr_holder = 0, type;\r\nif (!se_sess || !se_lun) {\r\npr_err("SPC-3 PR: se_sess || struct se_lun is NULL!\n");\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\nse_tpg = se_sess->se_tpg;\r\nse_deve = se_sess->se_node_acl->device_list[cmd->orig_fe_lun];\r\nif (se_tpg->se_tpg_tfo->sess_get_initiator_sid) {\r\nmemset(&isid_buf[0], 0, PR_REG_ISID_LEN);\r\nse_tpg->se_tpg_tfo->sess_get_initiator_sid(se_sess, &isid_buf[0],\r\nPR_REG_ISID_LEN);\r\nisid_ptr = &isid_buf[0];\r\n}\r\npr_reg = core_scsi3_locate_pr_reg(dev, se_sess->se_node_acl, se_sess);\r\nif (!pr_reg) {\r\nif (res_key) {\r\npr_warn("SPC-3 PR: Reservation Key non-zero"\r\n" for SA REGISTER, returning CONFLICT\n");\r\nreturn TCM_RESERVATION_CONFLICT;\r\n}\r\nif (!sa_res_key)\r\nreturn 0;\r\nif (!spec_i_pt) {\r\nif (core_scsi3_alloc_registration(cmd->se_dev,\r\nse_sess->se_node_acl, se_deve, isid_ptr,\r\nsa_res_key, all_tg_pt, aptpl,\r\nregister_type, 0)) {\r\npr_err("Unable to allocate"\r\n" struct t10_pr_registration\n");\r\nreturn TCM_INVALID_PARAMETER_LIST;\r\n}\r\n} else {\r\nret = core_scsi3_decode_spec_i_port(cmd, se_tpg,\r\nisid_ptr, sa_res_key, all_tg_pt, aptpl);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nreturn core_scsi3_update_and_write_aptpl(dev, aptpl);\r\n}\r\nif ((register_type == REGISTER) && (res_key != pr_reg->pr_res_key)) {\r\npr_err("SPC-3 PR REGISTER: Received"\r\n" res_key: 0x%016Lx does not match"\r\n" existing SA REGISTER res_key:"\r\n" 0x%016Lx\n", res_key,\r\npr_reg->pr_res_key);\r\nret = TCM_RESERVATION_CONFLICT;\r\ngoto out;\r\n}\r\nif (spec_i_pt) {\r\npr_err("SPC-3 PR REGISTER: SPEC_I_PT"\r\n" set on a registered nexus\n");\r\nret = TCM_INVALID_PARAMETER_LIST;\r\ngoto out;\r\n}\r\nif (pr_reg->pr_reg_all_tg_pt && !all_tg_pt) {\r\npr_err("SPC-3 PR REGISTER: ALL_TG_PT=1"\r\n" registration exists, but ALL_TG_PT=1 bit not"\r\n" present in received PROUT\n");\r\nret = TCM_INVALID_CDB_FIELD;\r\ngoto out;\r\n}\r\nif (sa_res_key) {\r\npr_reg->pr_res_generation = core_scsi3_pr_generation(cmd->se_dev);\r\npr_reg->pr_res_key = sa_res_key;\r\npr_debug("SPC-3 PR [%s] REGISTER%s: Changed Reservation"\r\n" Key for %s to: 0x%016Lx PRgeneration:"\r\n" 0x%08x\n", cmd->se_tfo->get_fabric_name(),\r\n(register_type == REGISTER_AND_IGNORE_EXISTING_KEY) ? "_AND_IGNORE_EXISTING_KEY" : "",\r\npr_reg->pr_reg_nacl->initiatorname,\r\npr_reg->pr_res_key, pr_reg->pr_res_generation);\r\n} else {\r\npr_holder = core_scsi3_check_implicit_release(\r\ncmd->se_dev, pr_reg);\r\nif (pr_holder < 0) {\r\nret = TCM_RESERVATION_CONFLICT;\r\ngoto out;\r\n}\r\ntype = pr_reg->pr_res_type;\r\nspin_lock(&pr_tmpl->registration_lock);\r\nif (pr_reg->pr_reg_all_tg_pt) {\r\nlist_for_each_entry_safe(pr_reg_p, pr_reg_tmp,\r\n&pr_tmpl->registration_list,\r\npr_reg_list) {\r\nif (!pr_reg_p->pr_reg_all_tg_pt)\r\ncontinue;\r\nif (pr_reg_p->pr_res_key != res_key)\r\ncontinue;\r\nif (pr_reg == pr_reg_p)\r\ncontinue;\r\nif (strcmp(pr_reg->pr_reg_nacl->initiatorname,\r\npr_reg_p->pr_reg_nacl->initiatorname))\r\ncontinue;\r\n__core_scsi3_free_registration(dev,\r\npr_reg_p, NULL, 0);\r\n}\r\n}\r\n__core_scsi3_free_registration(cmd->se_dev, pr_reg, NULL, 1);\r\npr_reg = NULL;\r\nif (pr_holder &&\r\n(type == PR_TYPE_WRITE_EXCLUSIVE_REGONLY ||\r\ntype == PR_TYPE_EXCLUSIVE_ACCESS_REGONLY)) {\r\nlist_for_each_entry(pr_reg_p,\r\n&pr_tmpl->registration_list,\r\npr_reg_list) {\r\ncore_scsi3_ua_allocate(\r\npr_reg_p->pr_reg_nacl,\r\npr_reg_p->pr_res_mapped_lun,\r\n0x2A,\r\nASCQ_2AH_RESERVATIONS_RELEASED);\r\n}\r\n}\r\nspin_unlock(&pr_tmpl->registration_lock);\r\n}\r\nret = core_scsi3_update_and_write_aptpl(dev, aptpl);\r\nout:\r\nif (pr_reg)\r\ncore_scsi3_put_pr_reg(pr_reg);\r\nreturn ret;\r\n}\r\nunsigned char *core_scsi3_pr_dump_type(int type)\r\n{\r\nswitch (type) {\r\ncase PR_TYPE_WRITE_EXCLUSIVE:\r\nreturn "Write Exclusive Access";\r\ncase PR_TYPE_EXCLUSIVE_ACCESS:\r\nreturn "Exclusive Access";\r\ncase PR_TYPE_WRITE_EXCLUSIVE_REGONLY:\r\nreturn "Write Exclusive Access, Registrants Only";\r\ncase PR_TYPE_EXCLUSIVE_ACCESS_REGONLY:\r\nreturn "Exclusive Access, Registrants Only";\r\ncase PR_TYPE_WRITE_EXCLUSIVE_ALLREG:\r\nreturn "Write Exclusive Access, All Registrants";\r\ncase PR_TYPE_EXCLUSIVE_ACCESS_ALLREG:\r\nreturn "Exclusive Access, All Registrants";\r\ndefault:\r\nbreak;\r\n}\r\nreturn "Unknown SPC-3 PR Type";\r\n}\r\nstatic sense_reason_t\r\ncore_scsi3_pro_reserve(struct se_cmd *cmd, int type, int scope, u64 res_key)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_session *se_sess = cmd->se_sess;\r\nstruct se_lun *se_lun = cmd->se_lun;\r\nstruct t10_pr_registration *pr_reg, *pr_res_holder;\r\nstruct t10_reservation *pr_tmpl = &dev->t10_pr;\r\nchar i_buf[PR_REG_ISID_ID_LEN];\r\nsense_reason_t ret;\r\nmemset(i_buf, 0, PR_REG_ISID_ID_LEN);\r\nif (!se_sess || !se_lun) {\r\npr_err("SPC-3 PR: se_sess || struct se_lun is NULL!\n");\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\npr_reg = core_scsi3_locate_pr_reg(cmd->se_dev, se_sess->se_node_acl,\r\nse_sess);\r\nif (!pr_reg) {\r\npr_err("SPC-3 PR: Unable to locate"\r\n" PR_REGISTERED *pr_reg for RESERVE\n");\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\nif (res_key != pr_reg->pr_res_key) {\r\npr_err("SPC-3 PR RESERVE: Received res_key: 0x%016Lx"\r\n" does not match existing SA REGISTER res_key:"\r\n" 0x%016Lx\n", res_key, pr_reg->pr_res_key);\r\nret = TCM_RESERVATION_CONFLICT;\r\ngoto out_put_pr_reg;\r\n}\r\nif (scope != PR_SCOPE_LU_SCOPE) {\r\npr_err("SPC-3 PR: Illegal SCOPE: 0x%02x\n", scope);\r\nret = TCM_INVALID_PARAMETER_LIST;\r\ngoto out_put_pr_reg;\r\n}\r\nspin_lock(&dev->dev_reservation_lock);\r\npr_res_holder = dev->dev_pr_res_holder;\r\nif (pr_res_holder) {\r\nif (pr_res_holder != pr_reg) {\r\nstruct se_node_acl *pr_res_nacl = pr_res_holder->pr_reg_nacl;\r\npr_err("SPC-3 PR: Attempted RESERVE from"\r\n" [%s]: %s while reservation already held by"\r\n" [%s]: %s, returning RESERVATION_CONFLICT\n",\r\ncmd->se_tfo->get_fabric_name(),\r\nse_sess->se_node_acl->initiatorname,\r\npr_res_nacl->se_tpg->se_tpg_tfo->get_fabric_name(),\r\npr_res_holder->pr_reg_nacl->initiatorname);\r\nspin_unlock(&dev->dev_reservation_lock);\r\nret = TCM_RESERVATION_CONFLICT;\r\ngoto out_put_pr_reg;\r\n}\r\nif ((pr_res_holder->pr_res_type != type) ||\r\n(pr_res_holder->pr_res_scope != scope)) {\r\nstruct se_node_acl *pr_res_nacl = pr_res_holder->pr_reg_nacl;\r\npr_err("SPC-3 PR: Attempted RESERVE from"\r\n" [%s]: %s trying to change TYPE and/or SCOPE,"\r\n" while reservation already held by [%s]: %s,"\r\n" returning RESERVATION_CONFLICT\n",\r\ncmd->se_tfo->get_fabric_name(),\r\nse_sess->se_node_acl->initiatorname,\r\npr_res_nacl->se_tpg->se_tpg_tfo->get_fabric_name(),\r\npr_res_holder->pr_reg_nacl->initiatorname);\r\nspin_unlock(&dev->dev_reservation_lock);\r\nret = TCM_RESERVATION_CONFLICT;\r\ngoto out_put_pr_reg;\r\n}\r\nspin_unlock(&dev->dev_reservation_lock);\r\nret = 0;\r\ngoto out_put_pr_reg;\r\n}\r\npr_reg->pr_res_scope = scope;\r\npr_reg->pr_res_type = type;\r\npr_reg->pr_res_holder = 1;\r\ndev->dev_pr_res_holder = pr_reg;\r\ncore_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);\r\npr_debug("SPC-3 PR [%s] Service Action: RESERVE created new"\r\n" reservation holder TYPE: %s ALL_TG_PT: %d\n",\r\ncmd->se_tfo->get_fabric_name(), core_scsi3_pr_dump_type(type),\r\n(pr_reg->pr_reg_all_tg_pt) ? 1 : 0);\r\npr_debug("SPC-3 PR [%s] RESERVE Node: %s%s\n",\r\ncmd->se_tfo->get_fabric_name(),\r\nse_sess->se_node_acl->initiatorname,\r\ni_buf);\r\nspin_unlock(&dev->dev_reservation_lock);\r\nif (pr_tmpl->pr_aptpl_active)\r\ncore_scsi3_update_and_write_aptpl(cmd->se_dev, true);\r\nret = 0;\r\nout_put_pr_reg:\r\ncore_scsi3_put_pr_reg(pr_reg);\r\nreturn ret;\r\n}\r\nstatic sense_reason_t\r\ncore_scsi3_emulate_pro_reserve(struct se_cmd *cmd, int type, int scope,\r\nu64 res_key)\r\n{\r\nswitch (type) {\r\ncase PR_TYPE_WRITE_EXCLUSIVE:\r\ncase PR_TYPE_EXCLUSIVE_ACCESS:\r\ncase PR_TYPE_WRITE_EXCLUSIVE_REGONLY:\r\ncase PR_TYPE_EXCLUSIVE_ACCESS_REGONLY:\r\ncase PR_TYPE_WRITE_EXCLUSIVE_ALLREG:\r\ncase PR_TYPE_EXCLUSIVE_ACCESS_ALLREG:\r\nreturn core_scsi3_pro_reserve(cmd, type, scope, res_key);\r\ndefault:\r\npr_err("SPC-3 PR: Unknown Service Action RESERVE Type:"\r\n" 0x%02x\n", type);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\n}\r\nstatic void __core_scsi3_complete_pro_release(\r\nstruct se_device *dev,\r\nstruct se_node_acl *se_nacl,\r\nstruct t10_pr_registration *pr_reg,\r\nint explicit)\r\n{\r\nstruct target_core_fabric_ops *tfo = se_nacl->se_tpg->se_tpg_tfo;\r\nchar i_buf[PR_REG_ISID_ID_LEN];\r\nmemset(i_buf, 0, PR_REG_ISID_ID_LEN);\r\ncore_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);\r\ndev->dev_pr_res_holder = NULL;\r\npr_debug("SPC-3 PR [%s] Service Action: %s RELEASE cleared"\r\n" reservation holder TYPE: %s ALL_TG_PT: %d\n",\r\ntfo->get_fabric_name(), (explicit) ? "explicit" : "implicit",\r\ncore_scsi3_pr_dump_type(pr_reg->pr_res_type),\r\n(pr_reg->pr_reg_all_tg_pt) ? 1 : 0);\r\npr_debug("SPC-3 PR [%s] RELEASE Node: %s%s\n",\r\ntfo->get_fabric_name(), se_nacl->initiatorname,\r\ni_buf);\r\npr_reg->pr_res_holder = pr_reg->pr_res_type = pr_reg->pr_res_scope = 0;\r\n}\r\nstatic sense_reason_t\r\ncore_scsi3_emulate_pro_release(struct se_cmd *cmd, int type, int scope,\r\nu64 res_key)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_session *se_sess = cmd->se_sess;\r\nstruct se_lun *se_lun = cmd->se_lun;\r\nstruct t10_pr_registration *pr_reg, *pr_reg_p, *pr_res_holder;\r\nstruct t10_reservation *pr_tmpl = &dev->t10_pr;\r\nint all_reg = 0;\r\nsense_reason_t ret = 0;\r\nif (!se_sess || !se_lun) {\r\npr_err("SPC-3 PR: se_sess || struct se_lun is NULL!\n");\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\npr_reg = core_scsi3_locate_pr_reg(dev, se_sess->se_node_acl, se_sess);\r\nif (!pr_reg) {\r\npr_err("SPC-3 PR: Unable to locate"\r\n" PR_REGISTERED *pr_reg for RELEASE\n");\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\nspin_lock(&dev->dev_reservation_lock);\r\npr_res_holder = dev->dev_pr_res_holder;\r\nif (!pr_res_holder) {\r\nspin_unlock(&dev->dev_reservation_lock);\r\ngoto out_put_pr_reg;\r\n}\r\nif ((pr_res_holder->pr_res_type == PR_TYPE_WRITE_EXCLUSIVE_ALLREG) ||\r\n(pr_res_holder->pr_res_type == PR_TYPE_EXCLUSIVE_ACCESS_ALLREG))\r\nall_reg = 1;\r\nif ((all_reg == 0) && (pr_res_holder != pr_reg)) {\r\nspin_unlock(&dev->dev_reservation_lock);\r\ngoto out_put_pr_reg;\r\n}\r\nif (res_key != pr_reg->pr_res_key) {\r\npr_err("SPC-3 PR RELEASE: Received res_key: 0x%016Lx"\r\n" does not match existing SA REGISTER res_key:"\r\n" 0x%016Lx\n", res_key, pr_reg->pr_res_key);\r\nspin_unlock(&dev->dev_reservation_lock);\r\nret = TCM_RESERVATION_CONFLICT;\r\ngoto out_put_pr_reg;\r\n}\r\nif ((pr_res_holder->pr_res_type != type) ||\r\n(pr_res_holder->pr_res_scope != scope)) {\r\nstruct se_node_acl *pr_res_nacl = pr_res_holder->pr_reg_nacl;\r\npr_err("SPC-3 PR RELEASE: Attempted to release"\r\n" reservation from [%s]: %s with different TYPE "\r\n"and/or SCOPE while reservation already held by"\r\n" [%s]: %s, returning RESERVATION_CONFLICT\n",\r\ncmd->se_tfo->get_fabric_name(),\r\nse_sess->se_node_acl->initiatorname,\r\npr_res_nacl->se_tpg->se_tpg_tfo->get_fabric_name(),\r\npr_res_holder->pr_reg_nacl->initiatorname);\r\nspin_unlock(&dev->dev_reservation_lock);\r\nret = TCM_RESERVATION_CONFLICT;\r\ngoto out_put_pr_reg;\r\n}\r\n__core_scsi3_complete_pro_release(dev, se_sess->se_node_acl,\r\npr_reg, 1);\r\nspin_unlock(&dev->dev_reservation_lock);\r\nif ((type != PR_TYPE_WRITE_EXCLUSIVE_REGONLY) &&\r\n(type != PR_TYPE_EXCLUSIVE_ACCESS_REGONLY) &&\r\n(type != PR_TYPE_WRITE_EXCLUSIVE_ALLREG) &&\r\n(type != PR_TYPE_EXCLUSIVE_ACCESS_ALLREG)) {\r\ngoto write_aptpl;\r\n}\r\nspin_lock(&pr_tmpl->registration_lock);\r\nlist_for_each_entry(pr_reg_p, &pr_tmpl->registration_list,\r\npr_reg_list) {\r\nif (pr_reg_p == pr_reg)\r\ncontinue;\r\ncore_scsi3_ua_allocate(pr_reg_p->pr_reg_nacl,\r\npr_reg_p->pr_res_mapped_lun,\r\n0x2A, ASCQ_2AH_RESERVATIONS_RELEASED);\r\n}\r\nspin_unlock(&pr_tmpl->registration_lock);\r\nwrite_aptpl:\r\nif (pr_tmpl->pr_aptpl_active)\r\ncore_scsi3_update_and_write_aptpl(cmd->se_dev, true);\r\nout_put_pr_reg:\r\ncore_scsi3_put_pr_reg(pr_reg);\r\nreturn ret;\r\n}\r\nstatic sense_reason_t\r\ncore_scsi3_emulate_pro_clear(struct se_cmd *cmd, u64 res_key)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_node_acl *pr_reg_nacl;\r\nstruct se_session *se_sess = cmd->se_sess;\r\nstruct t10_reservation *pr_tmpl = &dev->t10_pr;\r\nstruct t10_pr_registration *pr_reg, *pr_reg_tmp, *pr_reg_n, *pr_res_holder;\r\nu32 pr_res_mapped_lun = 0;\r\nint calling_it_nexus = 0;\r\npr_reg_n = core_scsi3_locate_pr_reg(cmd->se_dev,\r\nse_sess->se_node_acl, se_sess);\r\nif (!pr_reg_n) {\r\npr_err("SPC-3 PR: Unable to locate"\r\n" PR_REGISTERED *pr_reg for CLEAR\n");\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\nif (res_key != pr_reg_n->pr_res_key) {\r\npr_err("SPC-3 PR REGISTER: Received"\r\n" res_key: 0x%016Lx does not match"\r\n" existing SA REGISTER res_key:"\r\n" 0x%016Lx\n", res_key, pr_reg_n->pr_res_key);\r\ncore_scsi3_put_pr_reg(pr_reg_n);\r\nreturn TCM_RESERVATION_CONFLICT;\r\n}\r\nspin_lock(&dev->dev_reservation_lock);\r\npr_res_holder = dev->dev_pr_res_holder;\r\nif (pr_res_holder) {\r\nstruct se_node_acl *pr_res_nacl = pr_res_holder->pr_reg_nacl;\r\n__core_scsi3_complete_pro_release(dev, pr_res_nacl,\r\npr_res_holder, 0);\r\n}\r\nspin_unlock(&dev->dev_reservation_lock);\r\nspin_lock(&pr_tmpl->registration_lock);\r\nlist_for_each_entry_safe(pr_reg, pr_reg_tmp,\r\n&pr_tmpl->registration_list, pr_reg_list) {\r\ncalling_it_nexus = (pr_reg_n == pr_reg) ? 1 : 0;\r\npr_reg_nacl = pr_reg->pr_reg_nacl;\r\npr_res_mapped_lun = pr_reg->pr_res_mapped_lun;\r\n__core_scsi3_free_registration(dev, pr_reg, NULL,\r\ncalling_it_nexus);\r\nif (!calling_it_nexus)\r\ncore_scsi3_ua_allocate(pr_reg_nacl, pr_res_mapped_lun,\r\n0x2A, ASCQ_2AH_RESERVATIONS_PREEMPTED);\r\n}\r\nspin_unlock(&pr_tmpl->registration_lock);\r\npr_debug("SPC-3 PR [%s] Service Action: CLEAR complete\n",\r\ncmd->se_tfo->get_fabric_name());\r\ncore_scsi3_update_and_write_aptpl(cmd->se_dev, false);\r\ncore_scsi3_pr_generation(dev);\r\nreturn 0;\r\n}\r\nstatic void __core_scsi3_complete_pro_preempt(\r\nstruct se_device *dev,\r\nstruct t10_pr_registration *pr_reg,\r\nstruct list_head *preempt_and_abort_list,\r\nint type,\r\nint scope,\r\nenum preempt_type preempt_type)\r\n{\r\nstruct se_node_acl *nacl = pr_reg->pr_reg_nacl;\r\nstruct target_core_fabric_ops *tfo = nacl->se_tpg->se_tpg_tfo;\r\nchar i_buf[PR_REG_ISID_ID_LEN];\r\nmemset(i_buf, 0, PR_REG_ISID_ID_LEN);\r\ncore_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);\r\nif (dev->dev_pr_res_holder)\r\n__core_scsi3_complete_pro_release(dev, nacl,\r\ndev->dev_pr_res_holder, 0);\r\ndev->dev_pr_res_holder = pr_reg;\r\npr_reg->pr_res_holder = 1;\r\npr_reg->pr_res_type = type;\r\npr_reg->pr_res_scope = scope;\r\npr_debug("SPC-3 PR [%s] Service Action: PREEMPT%s created new"\r\n" reservation holder TYPE: %s ALL_TG_PT: %d\n",\r\ntfo->get_fabric_name(), (preempt_type == PREEMPT_AND_ABORT) ? "_AND_ABORT" : "",\r\ncore_scsi3_pr_dump_type(type),\r\n(pr_reg->pr_reg_all_tg_pt) ? 1 : 0);\r\npr_debug("SPC-3 PR [%s] PREEMPT%s from Node: %s%s\n",\r\ntfo->get_fabric_name(), (preempt_type == PREEMPT_AND_ABORT) ? "_AND_ABORT" : "",\r\nnacl->initiatorname, i_buf);\r\nif (preempt_and_abort_list)\r\nlist_add_tail(&pr_reg->pr_reg_abort_list,\r\npreempt_and_abort_list);\r\n}\r\nstatic void core_scsi3_release_preempt_and_abort(\r\nstruct list_head *preempt_and_abort_list,\r\nstruct t10_pr_registration *pr_reg_holder)\r\n{\r\nstruct t10_pr_registration *pr_reg, *pr_reg_tmp;\r\nlist_for_each_entry_safe(pr_reg, pr_reg_tmp, preempt_and_abort_list,\r\npr_reg_abort_list) {\r\nlist_del(&pr_reg->pr_reg_abort_list);\r\nif (pr_reg_holder == pr_reg)\r\ncontinue;\r\nif (pr_reg->pr_res_holder) {\r\npr_warn("pr_reg->pr_res_holder still set\n");\r\ncontinue;\r\n}\r\npr_reg->pr_reg_deve = NULL;\r\npr_reg->pr_reg_nacl = NULL;\r\nkmem_cache_free(t10_pr_reg_cache, pr_reg);\r\n}\r\n}\r\nstatic sense_reason_t\r\ncore_scsi3_pro_preempt(struct se_cmd *cmd, int type, int scope, u64 res_key,\r\nu64 sa_res_key, enum preempt_type preempt_type)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_node_acl *pr_reg_nacl;\r\nstruct se_session *se_sess = cmd->se_sess;\r\nLIST_HEAD(preempt_and_abort_list);\r\nstruct t10_pr_registration *pr_reg, *pr_reg_tmp, *pr_reg_n, *pr_res_holder;\r\nstruct t10_reservation *pr_tmpl = &dev->t10_pr;\r\nu32 pr_res_mapped_lun = 0;\r\nint all_reg = 0, calling_it_nexus = 0, released_regs = 0;\r\nint prh_type = 0, prh_scope = 0;\r\nif (!se_sess)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\npr_reg_n = core_scsi3_locate_pr_reg(cmd->se_dev, se_sess->se_node_acl,\r\nse_sess);\r\nif (!pr_reg_n) {\r\npr_err("SPC-3 PR: Unable to locate"\r\n" PR_REGISTERED *pr_reg for PREEMPT%s\n",\r\n(preempt_type == PREEMPT_AND_ABORT) ? "_AND_ABORT" : "");\r\nreturn TCM_RESERVATION_CONFLICT;\r\n}\r\nif (pr_reg_n->pr_res_key != res_key) {\r\ncore_scsi3_put_pr_reg(pr_reg_n);\r\nreturn TCM_RESERVATION_CONFLICT;\r\n}\r\nif (scope != PR_SCOPE_LU_SCOPE) {\r\npr_err("SPC-3 PR: Illegal SCOPE: 0x%02x\n", scope);\r\ncore_scsi3_put_pr_reg(pr_reg_n);\r\nreturn TCM_INVALID_PARAMETER_LIST;\r\n}\r\nspin_lock(&dev->dev_reservation_lock);\r\npr_res_holder = dev->dev_pr_res_holder;\r\nif (pr_res_holder &&\r\n((pr_res_holder->pr_res_type == PR_TYPE_WRITE_EXCLUSIVE_ALLREG) ||\r\n(pr_res_holder->pr_res_type == PR_TYPE_EXCLUSIVE_ACCESS_ALLREG)))\r\nall_reg = 1;\r\nif (!all_reg && !sa_res_key) {\r\nspin_unlock(&dev->dev_reservation_lock);\r\ncore_scsi3_put_pr_reg(pr_reg_n);\r\nreturn TCM_INVALID_PARAMETER_LIST;\r\n}\r\nif (!pr_res_holder || (pr_res_holder->pr_res_key != sa_res_key)) {\r\nspin_lock(&pr_tmpl->registration_lock);\r\nlist_for_each_entry_safe(pr_reg, pr_reg_tmp,\r\n&pr_tmpl->registration_list, pr_reg_list) {\r\nif (!all_reg) {\r\nif (pr_reg->pr_res_key != sa_res_key)\r\ncontinue;\r\ncalling_it_nexus = (pr_reg_n == pr_reg) ? 1 : 0;\r\npr_reg_nacl = pr_reg->pr_reg_nacl;\r\npr_res_mapped_lun = pr_reg->pr_res_mapped_lun;\r\n__core_scsi3_free_registration(dev, pr_reg,\r\n(preempt_type == PREEMPT_AND_ABORT) ? &preempt_and_abort_list :\r\nNULL, calling_it_nexus);\r\nreleased_regs++;\r\n} else {\r\nif ((sa_res_key) &&\r\n(pr_reg->pr_res_key != sa_res_key))\r\ncontinue;\r\ncalling_it_nexus = (pr_reg_n == pr_reg) ? 1 : 0;\r\nif (calling_it_nexus)\r\ncontinue;\r\npr_reg_nacl = pr_reg->pr_reg_nacl;\r\npr_res_mapped_lun = pr_reg->pr_res_mapped_lun;\r\n__core_scsi3_free_registration(dev, pr_reg,\r\n(preempt_type == PREEMPT_AND_ABORT) ? &preempt_and_abort_list :\r\nNULL, 0);\r\nreleased_regs++;\r\n}\r\nif (!calling_it_nexus)\r\ncore_scsi3_ua_allocate(pr_reg_nacl,\r\npr_res_mapped_lun, 0x2A,\r\nASCQ_2AH_REGISTRATIONS_PREEMPTED);\r\n}\r\nspin_unlock(&pr_tmpl->registration_lock);\r\nif (!released_regs) {\r\nspin_unlock(&dev->dev_reservation_lock);\r\ncore_scsi3_put_pr_reg(pr_reg_n);\r\nreturn TCM_RESERVATION_CONFLICT;\r\n}\r\nif (pr_res_holder && all_reg && !(sa_res_key)) {\r\n__core_scsi3_complete_pro_preempt(dev, pr_reg_n,\r\n(preempt_type == PREEMPT_AND_ABORT) ? &preempt_and_abort_list : NULL,\r\ntype, scope, preempt_type);\r\nif (preempt_type == PREEMPT_AND_ABORT)\r\ncore_scsi3_release_preempt_and_abort(\r\n&preempt_and_abort_list, pr_reg_n);\r\n}\r\nspin_unlock(&dev->dev_reservation_lock);\r\nif (pr_tmpl->pr_aptpl_active)\r\ncore_scsi3_update_and_write_aptpl(cmd->se_dev, true);\r\ncore_scsi3_put_pr_reg(pr_reg_n);\r\ncore_scsi3_pr_generation(cmd->se_dev);\r\nreturn 0;\r\n}\r\nprh_type = pr_res_holder->pr_res_type;\r\nprh_scope = pr_res_holder->pr_res_scope;\r\nif (pr_reg_n != pr_res_holder)\r\n__core_scsi3_complete_pro_release(dev,\r\npr_res_holder->pr_reg_nacl,\r\ndev->dev_pr_res_holder, 0);\r\nspin_lock(&pr_tmpl->registration_lock);\r\nlist_for_each_entry_safe(pr_reg, pr_reg_tmp,\r\n&pr_tmpl->registration_list, pr_reg_list) {\r\ncalling_it_nexus = (pr_reg_n == pr_reg) ? 1 : 0;\r\nif (calling_it_nexus)\r\ncontinue;\r\nif (pr_reg->pr_res_key != sa_res_key)\r\ncontinue;\r\npr_reg_nacl = pr_reg->pr_reg_nacl;\r\npr_res_mapped_lun = pr_reg->pr_res_mapped_lun;\r\n__core_scsi3_free_registration(dev, pr_reg,\r\n(preempt_type == PREEMPT_AND_ABORT) ? &preempt_and_abort_list : NULL,\r\ncalling_it_nexus);\r\ncore_scsi3_ua_allocate(pr_reg_nacl, pr_res_mapped_lun, 0x2A,\r\nASCQ_2AH_REGISTRATIONS_PREEMPTED);\r\n}\r\nspin_unlock(&pr_tmpl->registration_lock);\r\n__core_scsi3_complete_pro_preempt(dev, pr_reg_n,\r\n(preempt_type == PREEMPT_AND_ABORT) ? &preempt_and_abort_list : NULL,\r\ntype, scope, preempt_type);\r\nif ((prh_type != type) || (prh_scope != scope)) {\r\nspin_lock(&pr_tmpl->registration_lock);\r\nlist_for_each_entry_safe(pr_reg, pr_reg_tmp,\r\n&pr_tmpl->registration_list, pr_reg_list) {\r\ncalling_it_nexus = (pr_reg_n == pr_reg) ? 1 : 0;\r\nif (calling_it_nexus)\r\ncontinue;\r\ncore_scsi3_ua_allocate(pr_reg->pr_reg_nacl,\r\npr_reg->pr_res_mapped_lun, 0x2A,\r\nASCQ_2AH_RESERVATIONS_RELEASED);\r\n}\r\nspin_unlock(&pr_tmpl->registration_lock);\r\n}\r\nspin_unlock(&dev->dev_reservation_lock);\r\nif (preempt_type == PREEMPT_AND_ABORT) {\r\ncore_tmr_lun_reset(dev, NULL, &preempt_and_abort_list, cmd);\r\ncore_scsi3_release_preempt_and_abort(&preempt_and_abort_list,\r\npr_reg_n);\r\n}\r\nif (pr_tmpl->pr_aptpl_active)\r\ncore_scsi3_update_and_write_aptpl(cmd->se_dev, true);\r\ncore_scsi3_put_pr_reg(pr_reg_n);\r\ncore_scsi3_pr_generation(cmd->se_dev);\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\ncore_scsi3_emulate_pro_preempt(struct se_cmd *cmd, int type, int scope,\r\nu64 res_key, u64 sa_res_key, enum preempt_type preempt_type)\r\n{\r\nswitch (type) {\r\ncase PR_TYPE_WRITE_EXCLUSIVE:\r\ncase PR_TYPE_EXCLUSIVE_ACCESS:\r\ncase PR_TYPE_WRITE_EXCLUSIVE_REGONLY:\r\ncase PR_TYPE_EXCLUSIVE_ACCESS_REGONLY:\r\ncase PR_TYPE_WRITE_EXCLUSIVE_ALLREG:\r\ncase PR_TYPE_EXCLUSIVE_ACCESS_ALLREG:\r\nreturn core_scsi3_pro_preempt(cmd, type, scope, res_key,\r\nsa_res_key, preempt_type);\r\ndefault:\r\npr_err("SPC-3 PR: Unknown Service Action PREEMPT%s"\r\n" Type: 0x%02x\n", (preempt_type == PREEMPT_AND_ABORT) ? "_AND_ABORT" : "", type);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\n}\r\nstatic sense_reason_t\r\ncore_scsi3_emulate_pro_register_and_move(struct se_cmd *cmd, u64 res_key,\r\nu64 sa_res_key, int aptpl, int unreg)\r\n{\r\nstruct se_session *se_sess = cmd->se_sess;\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_dev_entry *dest_se_deve = NULL;\r\nstruct se_lun *se_lun = cmd->se_lun;\r\nstruct se_node_acl *pr_res_nacl, *pr_reg_nacl, *dest_node_acl = NULL;\r\nstruct se_port *se_port;\r\nstruct se_portal_group *se_tpg, *dest_se_tpg = NULL;\r\nstruct target_core_fabric_ops *dest_tf_ops = NULL, *tf_ops;\r\nstruct t10_pr_registration *pr_reg, *pr_res_holder, *dest_pr_reg;\r\nstruct t10_reservation *pr_tmpl = &dev->t10_pr;\r\nunsigned char *buf;\r\nunsigned char *initiator_str;\r\nchar *iport_ptr = NULL, dest_iport[64], i_buf[PR_REG_ISID_ID_LEN];\r\nu32 tid_len, tmp_tid_len;\r\nint new_reg = 0, type, scope, matching_iname;\r\nsense_reason_t ret;\r\nunsigned short rtpi;\r\nunsigned char proto_ident;\r\nif (!se_sess || !se_lun) {\r\npr_err("SPC-3 PR: se_sess || struct se_lun is NULL!\n");\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\nmemset(dest_iport, 0, 64);\r\nmemset(i_buf, 0, PR_REG_ISID_ID_LEN);\r\nse_tpg = se_sess->se_tpg;\r\ntf_ops = se_tpg->se_tpg_tfo;\r\npr_reg = core_scsi3_locate_pr_reg(cmd->se_dev, se_sess->se_node_acl,\r\nse_sess);\r\nif (!pr_reg) {\r\npr_err("SPC-3 PR: Unable to locate PR_REGISTERED"\r\n" *pr_reg for REGISTER_AND_MOVE\n");\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\n}\r\nif (res_key != pr_reg->pr_res_key) {\r\npr_warn("SPC-3 PR REGISTER_AND_MOVE: Received"\r\n" res_key: 0x%016Lx does not match existing SA REGISTER"\r\n" res_key: 0x%016Lx\n", res_key, pr_reg->pr_res_key);\r\nret = TCM_RESERVATION_CONFLICT;\r\ngoto out_put_pr_reg;\r\n}\r\nif (!sa_res_key) {\r\npr_warn("SPC-3 PR REGISTER_AND_MOVE: Received zero"\r\n" sa_res_key\n");\r\nret = TCM_INVALID_PARAMETER_LIST;\r\ngoto out_put_pr_reg;\r\n}\r\nbuf = transport_kmap_data_sg(cmd);\r\nif (!buf) {\r\nret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\ngoto out_put_pr_reg;\r\n}\r\nrtpi = (buf[18] & 0xff) << 8;\r\nrtpi |= buf[19] & 0xff;\r\ntid_len = (buf[20] & 0xff) << 24;\r\ntid_len |= (buf[21] & 0xff) << 16;\r\ntid_len |= (buf[22] & 0xff) << 8;\r\ntid_len |= buf[23] & 0xff;\r\ntransport_kunmap_data_sg(cmd);\r\nbuf = NULL;\r\nif ((tid_len + 24) != cmd->data_length) {\r\npr_err("SPC-3 PR: Illegal tid_len: %u + 24 byte header"\r\n" does not equal CDB data_length: %u\n", tid_len,\r\ncmd->data_length);\r\nret = TCM_INVALID_PARAMETER_LIST;\r\ngoto out_put_pr_reg;\r\n}\r\nspin_lock(&dev->se_port_lock);\r\nlist_for_each_entry(se_port, &dev->dev_sep_list, sep_list) {\r\nif (se_port->sep_rtpi != rtpi)\r\ncontinue;\r\ndest_se_tpg = se_port->sep_tpg;\r\nif (!dest_se_tpg)\r\ncontinue;\r\ndest_tf_ops = dest_se_tpg->se_tpg_tfo;\r\nif (!dest_tf_ops)\r\ncontinue;\r\natomic_inc(&dest_se_tpg->tpg_pr_ref_count);\r\nsmp_mb__after_atomic();\r\nspin_unlock(&dev->se_port_lock);\r\nif (core_scsi3_tpg_depend_item(dest_se_tpg)) {\r\npr_err("core_scsi3_tpg_depend_item() failed"\r\n" for dest_se_tpg\n");\r\natomic_dec(&dest_se_tpg->tpg_pr_ref_count);\r\nsmp_mb__after_atomic();\r\nret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\ngoto out_put_pr_reg;\r\n}\r\nspin_lock(&dev->se_port_lock);\r\nbreak;\r\n}\r\nspin_unlock(&dev->se_port_lock);\r\nif (!dest_se_tpg || !dest_tf_ops) {\r\npr_err("SPC-3 PR REGISTER_AND_MOVE: Unable to locate"\r\n" fabric ops from Relative Target Port Identifier:"\r\n" %hu\n", rtpi);\r\nret = TCM_INVALID_PARAMETER_LIST;\r\ngoto out_put_pr_reg;\r\n}\r\nbuf = transport_kmap_data_sg(cmd);\r\nif (!buf) {\r\nret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\ngoto out_put_pr_reg;\r\n}\r\nproto_ident = (buf[24] & 0x0f);\r\npr_debug("SPC-3 PR REGISTER_AND_MOVE: Extracted Protocol Identifier:"\r\n" 0x%02x\n", proto_ident);\r\nif (proto_ident != dest_tf_ops->get_fabric_proto_ident(dest_se_tpg)) {\r\npr_err("SPC-3 PR REGISTER_AND_MOVE: Received"\r\n" proto_ident: 0x%02x does not match ident: 0x%02x"\r\n" from fabric: %s\n", proto_ident,\r\ndest_tf_ops->get_fabric_proto_ident(dest_se_tpg),\r\ndest_tf_ops->get_fabric_name());\r\nret = TCM_INVALID_PARAMETER_LIST;\r\ngoto out;\r\n}\r\nif (dest_tf_ops->tpg_parse_pr_out_transport_id == NULL) {\r\npr_err("SPC-3 PR REGISTER_AND_MOVE: Fabric does not"\r\n" containg a valid tpg_parse_pr_out_transport_id"\r\n" function pointer\n");\r\nret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\ngoto out;\r\n}\r\ninitiator_str = dest_tf_ops->tpg_parse_pr_out_transport_id(dest_se_tpg,\r\n(const char *)&buf[24], &tmp_tid_len, &iport_ptr);\r\nif (!initiator_str) {\r\npr_err("SPC-3 PR REGISTER_AND_MOVE: Unable to locate"\r\n" initiator_str from Transport ID\n");\r\nret = TCM_INVALID_PARAMETER_LIST;\r\ngoto out;\r\n}\r\ntransport_kunmap_data_sg(cmd);\r\nbuf = NULL;\r\npr_debug("SPC-3 PR [%s] Extracted initiator %s identifier: %s"\r\n" %s\n", dest_tf_ops->get_fabric_name(), (iport_ptr != NULL) ?\r\n"port" : "device", initiator_str, (iport_ptr != NULL) ?\r\niport_ptr : "");\r\npr_reg_nacl = pr_reg->pr_reg_nacl;\r\nmatching_iname = (!strcmp(initiator_str,\r\npr_reg_nacl->initiatorname)) ? 1 : 0;\r\nif (!matching_iname)\r\ngoto after_iport_check;\r\nif (!iport_ptr || !pr_reg->isid_present_at_reg) {\r\npr_err("SPC-3 PR REGISTER_AND_MOVE: TransportID: %s"\r\n" matches: %s on received I_T Nexus\n", initiator_str,\r\npr_reg_nacl->initiatorname);\r\nret = TCM_INVALID_PARAMETER_LIST;\r\ngoto out;\r\n}\r\nif (!strcmp(iport_ptr, pr_reg->pr_reg_isid)) {\r\npr_err("SPC-3 PR REGISTER_AND_MOVE: TransportID: %s %s"\r\n" matches: %s %s on received I_T Nexus\n",\r\ninitiator_str, iport_ptr, pr_reg_nacl->initiatorname,\r\npr_reg->pr_reg_isid);\r\nret = TCM_INVALID_PARAMETER_LIST;\r\ngoto out;\r\n}\r\nafter_iport_check:\r\nspin_lock_irq(&dest_se_tpg->acl_node_lock);\r\ndest_node_acl = __core_tpg_get_initiator_node_acl(dest_se_tpg,\r\ninitiator_str);\r\nif (dest_node_acl) {\r\natomic_inc(&dest_node_acl->acl_pr_ref_count);\r\nsmp_mb__after_atomic();\r\n}\r\nspin_unlock_irq(&dest_se_tpg->acl_node_lock);\r\nif (!dest_node_acl) {\r\npr_err("Unable to locate %s dest_node_acl for"\r\n" TransportID%s\n", dest_tf_ops->get_fabric_name(),\r\ninitiator_str);\r\nret = TCM_INVALID_PARAMETER_LIST;\r\ngoto out;\r\n}\r\nif (core_scsi3_nodeacl_depend_item(dest_node_acl)) {\r\npr_err("core_scsi3_nodeacl_depend_item() for"\r\n" dest_node_acl\n");\r\natomic_dec(&dest_node_acl->acl_pr_ref_count);\r\nsmp_mb__after_atomic();\r\ndest_node_acl = NULL;\r\nret = TCM_INVALID_PARAMETER_LIST;\r\ngoto out;\r\n}\r\npr_debug("SPC-3 PR REGISTER_AND_MOVE: Found %s dest_node_acl:"\r\n" %s from TransportID\n", dest_tf_ops->get_fabric_name(),\r\ndest_node_acl->initiatorname);\r\ndest_se_deve = core_get_se_deve_from_rtpi(dest_node_acl, rtpi);\r\nif (!dest_se_deve) {\r\npr_err("Unable to locate %s dest_se_deve from RTPI:"\r\n" %hu\n", dest_tf_ops->get_fabric_name(), rtpi);\r\nret = TCM_INVALID_PARAMETER_LIST;\r\ngoto out;\r\n}\r\nif (core_scsi3_lunacl_depend_item(dest_se_deve)) {\r\npr_err("core_scsi3_lunacl_depend_item() failed\n");\r\natomic_dec(&dest_se_deve->pr_ref_count);\r\nsmp_mb__after_atomic();\r\ndest_se_deve = NULL;\r\nret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\ngoto out;\r\n}\r\npr_debug("SPC-3 PR REGISTER_AND_MOVE: Located %s node %s LUN"\r\n" ACL for dest_se_deve->mapped_lun: %u\n",\r\ndest_tf_ops->get_fabric_name(), dest_node_acl->initiatorname,\r\ndest_se_deve->mapped_lun);\r\nspin_lock(&dev->dev_reservation_lock);\r\npr_res_holder = dev->dev_pr_res_holder;\r\nif (!pr_res_holder) {\r\npr_warn("SPC-3 PR REGISTER_AND_MOVE: No reservation"\r\n" currently held\n");\r\nspin_unlock(&dev->dev_reservation_lock);\r\nret = TCM_INVALID_CDB_FIELD;\r\ngoto out;\r\n}\r\nif (pr_res_holder != pr_reg) {\r\npr_warn("SPC-3 PR REGISTER_AND_MOVE: Calling I_T"\r\n" Nexus is not reservation holder\n");\r\nspin_unlock(&dev->dev_reservation_lock);\r\nret = TCM_RESERVATION_CONFLICT;\r\ngoto out;\r\n}\r\nif ((pr_res_holder->pr_res_type == PR_TYPE_WRITE_EXCLUSIVE_ALLREG) ||\r\n(pr_res_holder->pr_res_type == PR_TYPE_EXCLUSIVE_ACCESS_ALLREG)) {\r\npr_warn("SPC-3 PR REGISTER_AND_MOVE: Unable to move"\r\n" reservation for type: %s\n",\r\ncore_scsi3_pr_dump_type(pr_res_holder->pr_res_type));\r\nspin_unlock(&dev->dev_reservation_lock);\r\nret = TCM_RESERVATION_CONFLICT;\r\ngoto out;\r\n}\r\npr_res_nacl = pr_res_holder->pr_reg_nacl;\r\ntype = pr_res_holder->pr_res_type;\r\nscope = pr_res_holder->pr_res_type;\r\ndest_pr_reg = __core_scsi3_locate_pr_reg(dev, dest_node_acl,\r\niport_ptr);\r\nif (!dest_pr_reg) {\r\nif (core_scsi3_alloc_registration(cmd->se_dev,\r\ndest_node_acl, dest_se_deve, iport_ptr,\r\nsa_res_key, 0, aptpl, 2, 1)) {\r\nspin_unlock(&dev->dev_reservation_lock);\r\nret = TCM_INVALID_PARAMETER_LIST;\r\ngoto out;\r\n}\r\ndest_pr_reg = __core_scsi3_locate_pr_reg(dev, dest_node_acl,\r\niport_ptr);\r\nnew_reg = 1;\r\n}\r\n__core_scsi3_complete_pro_release(dev, pr_res_nacl,\r\ndev->dev_pr_res_holder, 0);\r\ndev->dev_pr_res_holder = dest_pr_reg;\r\ndest_pr_reg->pr_res_holder = 1;\r\ndest_pr_reg->pr_res_type = type;\r\npr_reg->pr_res_scope = scope;\r\ncore_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);\r\nif (!new_reg)\r\ndest_pr_reg->pr_res_generation = pr_tmpl->pr_generation++;\r\nspin_unlock(&dev->dev_reservation_lock);\r\npr_debug("SPC-3 PR [%s] Service Action: REGISTER_AND_MOVE"\r\n" created new reservation holder TYPE: %s on object RTPI:"\r\n" %hu PRGeneration: 0x%08x\n", dest_tf_ops->get_fabric_name(),\r\ncore_scsi3_pr_dump_type(type), rtpi,\r\ndest_pr_reg->pr_res_generation);\r\npr_debug("SPC-3 PR Successfully moved reservation from"\r\n" %s Fabric Node: %s%s -> %s Fabric Node: %s %s\n",\r\ntf_ops->get_fabric_name(), pr_reg_nacl->initiatorname,\r\ni_buf, dest_tf_ops->get_fabric_name(),\r\ndest_node_acl->initiatorname, (iport_ptr != NULL) ?\r\niport_ptr : "");\r\ncore_scsi3_lunacl_undepend_item(dest_se_deve);\r\ncore_scsi3_nodeacl_undepend_item(dest_node_acl);\r\ncore_scsi3_tpg_undepend_item(dest_se_tpg);\r\nif (unreg) {\r\nspin_lock(&pr_tmpl->registration_lock);\r\n__core_scsi3_free_registration(dev, pr_reg, NULL, 1);\r\nspin_unlock(&pr_tmpl->registration_lock);\r\n} else\r\ncore_scsi3_put_pr_reg(pr_reg);\r\ncore_scsi3_update_and_write_aptpl(cmd->se_dev, aptpl);\r\ntransport_kunmap_data_sg(cmd);\r\ncore_scsi3_put_pr_reg(dest_pr_reg);\r\nreturn 0;\r\nout:\r\nif (buf)\r\ntransport_kunmap_data_sg(cmd);\r\nif (dest_se_deve)\r\ncore_scsi3_lunacl_undepend_item(dest_se_deve);\r\nif (dest_node_acl)\r\ncore_scsi3_nodeacl_undepend_item(dest_node_acl);\r\ncore_scsi3_tpg_undepend_item(dest_se_tpg);\r\nout_put_pr_reg:\r\ncore_scsi3_put_pr_reg(pr_reg);\r\nreturn ret;\r\n}\r\nstatic unsigned long long core_scsi3_extract_reservation_key(unsigned char *cdb)\r\n{\r\nunsigned int __v1, __v2;\r\n__v1 = (cdb[0] << 24) | (cdb[1] << 16) | (cdb[2] << 8) | cdb[3];\r\n__v2 = (cdb[4] << 24) | (cdb[5] << 16) | (cdb[6] << 8) | cdb[7];\r\nreturn ((unsigned long long)__v2) | (unsigned long long)__v1 << 32;\r\n}\r\nsense_reason_t\r\ntarget_scsi3_emulate_pr_out(struct se_cmd *cmd)\r\n{\r\nunsigned char *cdb = &cmd->t_task_cdb[0];\r\nunsigned char *buf;\r\nu64 res_key, sa_res_key;\r\nint sa, scope, type, aptpl;\r\nint spec_i_pt = 0, all_tg_pt = 0, unreg = 0;\r\nsense_reason_t ret;\r\nif (cmd->se_dev->dev_reservation_flags & DRF_SPC2_RESERVATIONS) {\r\npr_err("Received PERSISTENT_RESERVE CDB while legacy"\r\n" SPC-2 reservation is held, returning"\r\n" RESERVATION_CONFLICT\n");\r\nreturn TCM_RESERVATION_CONFLICT;\r\n}\r\nif (!cmd->se_sess)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nif (cmd->data_length < 24) {\r\npr_warn("SPC-PR: Received PR OUT parameter list"\r\n" length too small: %u\n", cmd->data_length);\r\nreturn TCM_INVALID_PARAMETER_LIST;\r\n}\r\nsa = (cdb[1] & 0x1f);\r\nscope = (cdb[2] & 0xf0);\r\ntype = (cdb[2] & 0x0f);\r\nbuf = transport_kmap_data_sg(cmd);\r\nif (!buf)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nres_key = core_scsi3_extract_reservation_key(&buf[0]);\r\nsa_res_key = core_scsi3_extract_reservation_key(&buf[8]);\r\nif (sa != PRO_REGISTER_AND_MOVE) {\r\nspec_i_pt = (buf[20] & 0x08);\r\nall_tg_pt = (buf[20] & 0x04);\r\naptpl = (buf[20] & 0x01);\r\n} else {\r\naptpl = (buf[17] & 0x01);\r\nunreg = (buf[17] & 0x02);\r\n}\r\ntransport_kunmap_data_sg(cmd);\r\nbuf = NULL;\r\nif (spec_i_pt && ((cdb[1] & 0x1f) != PRO_REGISTER))\r\nreturn TCM_INVALID_PARAMETER_LIST;\r\nif (!spec_i_pt && ((cdb[1] & 0x1f) != PRO_REGISTER_AND_MOVE) &&\r\n(cmd->data_length != 24)) {\r\npr_warn("SPC-PR: Received PR OUT illegal parameter"\r\n" list length: %u\n", cmd->data_length);\r\nreturn TCM_INVALID_PARAMETER_LIST;\r\n}\r\nswitch (sa) {\r\ncase PRO_REGISTER:\r\nret = core_scsi3_emulate_pro_register(cmd,\r\nres_key, sa_res_key, aptpl, all_tg_pt, spec_i_pt, REGISTER);\r\nbreak;\r\ncase PRO_RESERVE:\r\nret = core_scsi3_emulate_pro_reserve(cmd, type, scope, res_key);\r\nbreak;\r\ncase PRO_RELEASE:\r\nret = core_scsi3_emulate_pro_release(cmd, type, scope, res_key);\r\nbreak;\r\ncase PRO_CLEAR:\r\nret = core_scsi3_emulate_pro_clear(cmd, res_key);\r\nbreak;\r\ncase PRO_PREEMPT:\r\nret = core_scsi3_emulate_pro_preempt(cmd, type, scope,\r\nres_key, sa_res_key, PREEMPT);\r\nbreak;\r\ncase PRO_PREEMPT_AND_ABORT:\r\nret = core_scsi3_emulate_pro_preempt(cmd, type, scope,\r\nres_key, sa_res_key, PREEMPT_AND_ABORT);\r\nbreak;\r\ncase PRO_REGISTER_AND_IGNORE_EXISTING_KEY:\r\nret = core_scsi3_emulate_pro_register(cmd,\r\n0, sa_res_key, aptpl, all_tg_pt, spec_i_pt, REGISTER_AND_IGNORE_EXISTING_KEY);\r\nbreak;\r\ncase PRO_REGISTER_AND_MOVE:\r\nret = core_scsi3_emulate_pro_register_and_move(cmd, res_key,\r\nsa_res_key, aptpl, unreg);\r\nbreak;\r\ndefault:\r\npr_err("Unknown PERSISTENT_RESERVE_OUT service"\r\n" action: 0x%02x\n", cdb[1] & 0x1f);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nif (!ret)\r\ntarget_complete_cmd(cmd, GOOD);\r\nreturn ret;\r\n}\r\nstatic sense_reason_t\r\ncore_scsi3_pri_read_keys(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct t10_pr_registration *pr_reg;\r\nunsigned char *buf;\r\nu32 add_len = 0, off = 8;\r\nif (cmd->data_length < 8) {\r\npr_err("PRIN SA READ_KEYS SCSI Data Length: %u"\r\n" too small\n", cmd->data_length);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nbuf = transport_kmap_data_sg(cmd);\r\nif (!buf)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nbuf[0] = ((dev->t10_pr.pr_generation >> 24) & 0xff);\r\nbuf[1] = ((dev->t10_pr.pr_generation >> 16) & 0xff);\r\nbuf[2] = ((dev->t10_pr.pr_generation >> 8) & 0xff);\r\nbuf[3] = (dev->t10_pr.pr_generation & 0xff);\r\nspin_lock(&dev->t10_pr.registration_lock);\r\nlist_for_each_entry(pr_reg, &dev->t10_pr.registration_list,\r\npr_reg_list) {\r\nif ((add_len + 8) > (cmd->data_length - 8))\r\nbreak;\r\nbuf[off++] = ((pr_reg->pr_res_key >> 56) & 0xff);\r\nbuf[off++] = ((pr_reg->pr_res_key >> 48) & 0xff);\r\nbuf[off++] = ((pr_reg->pr_res_key >> 40) & 0xff);\r\nbuf[off++] = ((pr_reg->pr_res_key >> 32) & 0xff);\r\nbuf[off++] = ((pr_reg->pr_res_key >> 24) & 0xff);\r\nbuf[off++] = ((pr_reg->pr_res_key >> 16) & 0xff);\r\nbuf[off++] = ((pr_reg->pr_res_key >> 8) & 0xff);\r\nbuf[off++] = (pr_reg->pr_res_key & 0xff);\r\nadd_len += 8;\r\n}\r\nspin_unlock(&dev->t10_pr.registration_lock);\r\nbuf[4] = ((add_len >> 24) & 0xff);\r\nbuf[5] = ((add_len >> 16) & 0xff);\r\nbuf[6] = ((add_len >> 8) & 0xff);\r\nbuf[7] = (add_len & 0xff);\r\ntransport_kunmap_data_sg(cmd);\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\ncore_scsi3_pri_read_reservation(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct t10_pr_registration *pr_reg;\r\nunsigned char *buf;\r\nu64 pr_res_key;\r\nu32 add_len = 16;\r\nif (cmd->data_length < 8) {\r\npr_err("PRIN SA READ_RESERVATIONS SCSI Data Length: %u"\r\n" too small\n", cmd->data_length);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nbuf = transport_kmap_data_sg(cmd);\r\nif (!buf)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nbuf[0] = ((dev->t10_pr.pr_generation >> 24) & 0xff);\r\nbuf[1] = ((dev->t10_pr.pr_generation >> 16) & 0xff);\r\nbuf[2] = ((dev->t10_pr.pr_generation >> 8) & 0xff);\r\nbuf[3] = (dev->t10_pr.pr_generation & 0xff);\r\nspin_lock(&dev->dev_reservation_lock);\r\npr_reg = dev->dev_pr_res_holder;\r\nif (pr_reg) {\r\nbuf[4] = ((add_len >> 24) & 0xff);\r\nbuf[5] = ((add_len >> 16) & 0xff);\r\nbuf[6] = ((add_len >> 8) & 0xff);\r\nbuf[7] = (add_len & 0xff);\r\nif (cmd->data_length < 22)\r\ngoto err;\r\nif ((pr_reg->pr_res_type == PR_TYPE_WRITE_EXCLUSIVE_ALLREG) ||\r\n(pr_reg->pr_res_type == PR_TYPE_EXCLUSIVE_ACCESS_ALLREG))\r\npr_res_key = 0;\r\nelse\r\npr_res_key = pr_reg->pr_res_key;\r\nbuf[8] = ((pr_res_key >> 56) & 0xff);\r\nbuf[9] = ((pr_res_key >> 48) & 0xff);\r\nbuf[10] = ((pr_res_key >> 40) & 0xff);\r\nbuf[11] = ((pr_res_key >> 32) & 0xff);\r\nbuf[12] = ((pr_res_key >> 24) & 0xff);\r\nbuf[13] = ((pr_res_key >> 16) & 0xff);\r\nbuf[14] = ((pr_res_key >> 8) & 0xff);\r\nbuf[15] = (pr_res_key & 0xff);\r\nbuf[21] = (pr_reg->pr_res_scope & 0xf0) |\r\n(pr_reg->pr_res_type & 0x0f);\r\n}\r\nerr:\r\nspin_unlock(&dev->dev_reservation_lock);\r\ntransport_kunmap_data_sg(cmd);\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\ncore_scsi3_pri_report_capabilities(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct t10_reservation *pr_tmpl = &dev->t10_pr;\r\nunsigned char *buf;\r\nu16 add_len = 8;\r\nif (cmd->data_length < 6) {\r\npr_err("PRIN SA REPORT_CAPABILITIES SCSI Data Length:"\r\n" %u too small\n", cmd->data_length);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nbuf = transport_kmap_data_sg(cmd);\r\nif (!buf)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nbuf[0] = ((add_len << 8) & 0xff);\r\nbuf[1] = (add_len & 0xff);\r\nbuf[2] |= 0x10;\r\nbuf[2] |= 0x08;\r\nbuf[2] |= 0x04;\r\nbuf[2] |= 0x01;\r\nbuf[3] |= 0x80;\r\nbuf[3] |= 0x10;\r\nif (pr_tmpl->pr_aptpl_active)\r\nbuf[3] |= 0x01;\r\nbuf[4] |= 0x80;\r\nbuf[4] |= 0x40;\r\nbuf[4] |= 0x20;\r\nbuf[4] |= 0x08;\r\nbuf[4] |= 0x02;\r\nbuf[5] |= 0x01;\r\ntransport_kunmap_data_sg(cmd);\r\nreturn 0;\r\n}\r\nstatic sense_reason_t\r\ncore_scsi3_pri_read_full_status(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nstruct se_node_acl *se_nacl;\r\nstruct se_portal_group *se_tpg;\r\nstruct t10_pr_registration *pr_reg, *pr_reg_tmp;\r\nstruct t10_reservation *pr_tmpl = &dev->t10_pr;\r\nunsigned char *buf;\r\nu32 add_desc_len = 0, add_len = 0, desc_len, exp_desc_len;\r\nu32 off = 8;\r\nint format_code = 0;\r\nif (cmd->data_length < 8) {\r\npr_err("PRIN SA READ_FULL_STATUS SCSI Data Length: %u"\r\n" too small\n", cmd->data_length);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nbuf = transport_kmap_data_sg(cmd);\r\nif (!buf)\r\nreturn TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;\r\nbuf[0] = ((dev->t10_pr.pr_generation >> 24) & 0xff);\r\nbuf[1] = ((dev->t10_pr.pr_generation >> 16) & 0xff);\r\nbuf[2] = ((dev->t10_pr.pr_generation >> 8) & 0xff);\r\nbuf[3] = (dev->t10_pr.pr_generation & 0xff);\r\nspin_lock(&pr_tmpl->registration_lock);\r\nlist_for_each_entry_safe(pr_reg, pr_reg_tmp,\r\n&pr_tmpl->registration_list, pr_reg_list) {\r\nse_nacl = pr_reg->pr_reg_nacl;\r\nse_tpg = pr_reg->pr_reg_nacl->se_tpg;\r\nadd_desc_len = 0;\r\natomic_inc(&pr_reg->pr_res_holders);\r\nsmp_mb__after_atomic();\r\nspin_unlock(&pr_tmpl->registration_lock);\r\nexp_desc_len = se_tpg->se_tpg_tfo->tpg_get_pr_transport_id_len(\r\nse_tpg, se_nacl, pr_reg, &format_code);\r\nif ((exp_desc_len + add_len) > cmd->data_length) {\r\npr_warn("SPC-3 PRIN READ_FULL_STATUS ran"\r\n" out of buffer: %d\n", cmd->data_length);\r\nspin_lock(&pr_tmpl->registration_lock);\r\natomic_dec(&pr_reg->pr_res_holders);\r\nsmp_mb__after_atomic();\r\nbreak;\r\n}\r\nbuf[off++] = ((pr_reg->pr_res_key >> 56) & 0xff);\r\nbuf[off++] = ((pr_reg->pr_res_key >> 48) & 0xff);\r\nbuf[off++] = ((pr_reg->pr_res_key >> 40) & 0xff);\r\nbuf[off++] = ((pr_reg->pr_res_key >> 32) & 0xff);\r\nbuf[off++] = ((pr_reg->pr_res_key >> 24) & 0xff);\r\nbuf[off++] = ((pr_reg->pr_res_key >> 16) & 0xff);\r\nbuf[off++] = ((pr_reg->pr_res_key >> 8) & 0xff);\r\nbuf[off++] = (pr_reg->pr_res_key & 0xff);\r\noff += 4;\r\nif (pr_reg->pr_reg_all_tg_pt)\r\nbuf[off] = 0x02;\r\nif (pr_reg->pr_res_holder) {\r\nbuf[off++] |= 0x01;\r\nbuf[off++] = (pr_reg->pr_res_scope & 0xf0) |\r\n(pr_reg->pr_res_type & 0x0f);\r\n} else\r\noff += 2;\r\noff += 4;\r\nif (!pr_reg->pr_reg_all_tg_pt) {\r\nstruct se_port *port = pr_reg->pr_reg_tg_pt_lun->lun_sep;\r\nbuf[off++] = ((port->sep_rtpi >> 8) & 0xff);\r\nbuf[off++] = (port->sep_rtpi & 0xff);\r\n} else\r\noff += 2;\r\ndesc_len = se_tpg->se_tpg_tfo->tpg_get_pr_transport_id(se_tpg,\r\nse_nacl, pr_reg, &format_code, &buf[off+4]);\r\nspin_lock(&pr_tmpl->registration_lock);\r\natomic_dec(&pr_reg->pr_res_holders);\r\nsmp_mb__after_atomic();\r\nbuf[off++] = ((desc_len >> 24) & 0xff);\r\nbuf[off++] = ((desc_len >> 16) & 0xff);\r\nbuf[off++] = ((desc_len >> 8) & 0xff);\r\nbuf[off++] = (desc_len & 0xff);\r\nadd_desc_len = (24 + desc_len);\r\noff += desc_len;\r\nadd_len += add_desc_len;\r\n}\r\nspin_unlock(&pr_tmpl->registration_lock);\r\nbuf[4] = ((add_len >> 24) & 0xff);\r\nbuf[5] = ((add_len >> 16) & 0xff);\r\nbuf[6] = ((add_len >> 8) & 0xff);\r\nbuf[7] = (add_len & 0xff);\r\ntransport_kunmap_data_sg(cmd);\r\nreturn 0;\r\n}\r\nsense_reason_t\r\ntarget_scsi3_emulate_pr_in(struct se_cmd *cmd)\r\n{\r\nsense_reason_t ret;\r\nif (cmd->se_dev->dev_reservation_flags & DRF_SPC2_RESERVATIONS) {\r\npr_err("Received PERSISTENT_RESERVE CDB while legacy"\r\n" SPC-2 reservation is held, returning"\r\n" RESERVATION_CONFLICT\n");\r\nreturn TCM_RESERVATION_CONFLICT;\r\n}\r\nswitch (cmd->t_task_cdb[1] & 0x1f) {\r\ncase PRI_READ_KEYS:\r\nret = core_scsi3_pri_read_keys(cmd);\r\nbreak;\r\ncase PRI_READ_RESERVATION:\r\nret = core_scsi3_pri_read_reservation(cmd);\r\nbreak;\r\ncase PRI_REPORT_CAPABILITIES:\r\nret = core_scsi3_pri_report_capabilities(cmd);\r\nbreak;\r\ncase PRI_READ_FULL_STATUS:\r\nret = core_scsi3_pri_read_full_status(cmd);\r\nbreak;\r\ndefault:\r\npr_err("Unknown PERSISTENT_RESERVE_IN service"\r\n" action: 0x%02x\n", cmd->t_task_cdb[1] & 0x1f);\r\nreturn TCM_INVALID_CDB_FIELD;\r\n}\r\nif (!ret)\r\ntarget_complete_cmd(cmd, GOOD);\r\nreturn ret;\r\n}\r\nsense_reason_t\r\ntarget_check_reservation(struct se_cmd *cmd)\r\n{\r\nstruct se_device *dev = cmd->se_dev;\r\nsense_reason_t ret;\r\nif (!cmd->se_sess)\r\nreturn 0;\r\nif (dev->se_hba->hba_flags & HBA_FLAGS_INTERNAL_USE)\r\nreturn 0;\r\nif (dev->transport->transport_type == TRANSPORT_PLUGIN_PHBA_PDEV)\r\nreturn 0;\r\nspin_lock(&dev->dev_reservation_lock);\r\nif (dev->dev_reservation_flags & DRF_SPC2_RESERVATIONS)\r\nret = target_scsi2_reservation_check(cmd);\r\nelse\r\nret = target_scsi3_pr_reservation_check(cmd);\r\nspin_unlock(&dev->dev_reservation_lock);\r\nreturn ret;\r\n}
