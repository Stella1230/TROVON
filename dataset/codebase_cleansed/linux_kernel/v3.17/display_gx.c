unsigned int gx_frame_buffer_size(void)\r\n{\r\nunsigned int val;\r\nif (!cs5535_has_vsa2()) {\r\nuint32_t hi, lo;\r\nrdmsr(MSR_GLIU_P2D_RO0, lo, hi);\r\nval = ((hi & 0xff) << 12) | ((lo & 0xfff00000) >> 20);\r\nval -= (lo & 0x000fffff);\r\nval += 1;\r\nreturn (val << 12);\r\n}\r\noutw(VSA_VR_UNLOCK, VSA_VRC_INDEX);\r\noutw(VSA_VR_MEM_SIZE, VSA_VRC_INDEX);\r\nval = (unsigned int)(inw(VSA_VRC_DATA)) & 0xFFl;\r\nreturn (val << 19);\r\n}\r\nint gx_line_delta(int xres, int bpp)\r\n{\r\nreturn (xres * (bpp >> 3) + 7) & ~0x7;\r\n}\r\nvoid gx_set_mode(struct fb_info *info)\r\n{\r\nstruct gxfb_par *par = info->par;\r\nu32 gcfg, dcfg;\r\nint hactive, hblankstart, hsyncstart, hsyncend, hblankend, htotal;\r\nint vactive, vblankstart, vsyncstart, vsyncend, vblankend, vtotal;\r\nwrite_dc(par, DC_UNLOCK, DC_UNLOCK_UNLOCK);\r\ngcfg = read_dc(par, DC_GENERAL_CFG);\r\ndcfg = read_dc(par, DC_DISPLAY_CFG);\r\ndcfg &= ~DC_DISPLAY_CFG_TGEN;\r\nwrite_dc(par, DC_DISPLAY_CFG, dcfg);\r\nudelay(100);\r\ngcfg &= ~(DC_GENERAL_CFG_DFLE | DC_GENERAL_CFG_CMPE |\r\nDC_GENERAL_CFG_DECE);\r\nwrite_dc(par, DC_GENERAL_CFG, gcfg);\r\ngx_set_dclk_frequency(info);\r\ngcfg &= DC_GENERAL_CFG_YUVM | DC_GENERAL_CFG_VDSE;\r\ndcfg = 0;\r\ngcfg |= (6 << DC_GENERAL_CFG_DFHPEL_SHIFT) |\r\n(5 << DC_GENERAL_CFG_DFHPSL_SHIFT) | DC_GENERAL_CFG_DFLE;\r\nwrite_dc(par, DC_FB_ST_OFFSET, 0);\r\nwrite_dc(par, DC_GFX_PITCH, info->fix.line_length >> 3);\r\nwrite_dc(par, DC_LINE_SIZE,\r\n((info->var.xres * info->var.bits_per_pixel/8) >> 3) + 2);\r\ndcfg |= DC_DISPLAY_CFG_GDEN | DC_DISPLAY_CFG_VDEN |\r\nDC_DISPLAY_CFG_A20M | DC_DISPLAY_CFG_A18M;\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\ndcfg |= DC_DISPLAY_CFG_DISP_MODE_8BPP;\r\nbreak;\r\ncase 16:\r\ndcfg |= DC_DISPLAY_CFG_DISP_MODE_16BPP;\r\nbreak;\r\ncase 32:\r\ndcfg |= DC_DISPLAY_CFG_DISP_MODE_24BPP;\r\ndcfg |= DC_DISPLAY_CFG_PALB;\r\nbreak;\r\n}\r\ndcfg |= DC_DISPLAY_CFG_TGEN;\r\nhactive = info->var.xres;\r\nhblankstart = hactive;\r\nhsyncstart = hblankstart + info->var.right_margin;\r\nhsyncend = hsyncstart + info->var.hsync_len;\r\nhblankend = hsyncend + info->var.left_margin;\r\nhtotal = hblankend;\r\nvactive = info->var.yres;\r\nvblankstart = vactive;\r\nvsyncstart = vblankstart + info->var.lower_margin;\r\nvsyncend = vsyncstart + info->var.vsync_len;\r\nvblankend = vsyncend + info->var.upper_margin;\r\nvtotal = vblankend;\r\nwrite_dc(par, DC_H_ACTIVE_TIMING, (hactive - 1) |\r\n((htotal - 1) << 16));\r\nwrite_dc(par, DC_H_BLANK_TIMING, (hblankstart - 1) |\r\n((hblankend - 1) << 16));\r\nwrite_dc(par, DC_H_SYNC_TIMING, (hsyncstart - 1) |\r\n((hsyncend - 1) << 16));\r\nwrite_dc(par, DC_V_ACTIVE_TIMING, (vactive - 1) |\r\n((vtotal - 1) << 16));\r\nwrite_dc(par, DC_V_BLANK_TIMING, (vblankstart - 1) |\r\n((vblankend - 1) << 16));\r\nwrite_dc(par, DC_V_SYNC_TIMING, (vsyncstart - 1) |\r\n((vsyncend - 1) << 16));\r\nwrite_dc(par, DC_DISPLAY_CFG, dcfg);\r\nwrite_dc(par, DC_GENERAL_CFG, gcfg);\r\ngx_configure_display(info);\r\nwrite_dc(par, DC_UNLOCK, DC_UNLOCK_LOCK);\r\n}\r\nvoid gx_set_hw_palette_reg(struct fb_info *info, unsigned regno,\r\nunsigned red, unsigned green, unsigned blue)\r\n{\r\nstruct gxfb_par *par = info->par;\r\nint val;\r\nval = (red << 8) & 0xff0000;\r\nval |= (green) & 0x00ff00;\r\nval |= (blue >> 8) & 0x0000ff;\r\nwrite_dc(par, DC_PAL_ADDRESS, regno);\r\nwrite_dc(par, DC_PAL_DATA, val);\r\n}
