static int gp2a_report(struct gp2a_data *dt)\r\n{\r\nint vo = gpio_get_value(dt->pdata->vout_gpio);\r\ninput_report_switch(dt->input, SW_FRONT_PROXIMITY, !vo);\r\ninput_sync(dt->input);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t gp2a_irq(int irq, void *handle)\r\n{\r\nstruct gp2a_data *dt = handle;\r\ngp2a_report(dt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int gp2a_enable(struct gp2a_data *dt)\r\n{\r\nreturn i2c_smbus_write_byte_data(dt->i2c_client, GP2A_ADDR_OPMOD,\r\nGP2A_CTRL_SSD);\r\n}\r\nstatic int gp2a_disable(struct gp2a_data *dt)\r\n{\r\nreturn i2c_smbus_write_byte_data(dt->i2c_client, GP2A_ADDR_OPMOD,\r\n0x00);\r\n}\r\nstatic int gp2a_device_open(struct input_dev *dev)\r\n{\r\nstruct gp2a_data *dt = input_get_drvdata(dev);\r\nint error;\r\nerror = gp2a_enable(dt);\r\nif (error < 0) {\r\ndev_err(&dt->i2c_client->dev,\r\n"unable to activate, err %d\n", error);\r\nreturn error;\r\n}\r\ngp2a_report(dt);\r\nreturn 0;\r\n}\r\nstatic void gp2a_device_close(struct input_dev *dev)\r\n{\r\nstruct gp2a_data *dt = input_get_drvdata(dev);\r\nint error;\r\nerror = gp2a_disable(dt);\r\nif (error < 0)\r\ndev_err(&dt->i2c_client->dev,\r\n"unable to deactivate, err %d\n", error);\r\n}\r\nstatic int gp2a_initialize(struct gp2a_data *dt)\r\n{\r\nint error;\r\nerror = i2c_smbus_write_byte_data(dt->i2c_client, GP2A_ADDR_GAIN,\r\n0x08);\r\nif (error < 0)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(dt->i2c_client, GP2A_ADDR_HYS,\r\n0xc2);\r\nif (error < 0)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(dt->i2c_client, GP2A_ADDR_CYCLE,\r\n0x04);\r\nif (error < 0)\r\nreturn error;\r\nerror = gp2a_disable(dt);\r\nreturn error;\r\n}\r\nstatic int gp2a_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct gp2a_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct gp2a_data *dt;\r\nint error;\r\nif (!pdata)\r\nreturn -EINVAL;\r\nif (pdata->hw_setup) {\r\nerror = pdata->hw_setup(client);\r\nif (error < 0)\r\nreturn error;\r\n}\r\nerror = gpio_request_one(pdata->vout_gpio, GPIOF_IN, GP2A_I2C_NAME);\r\nif (error)\r\ngoto err_hw_shutdown;\r\ndt = kzalloc(sizeof(struct gp2a_data), GFP_KERNEL);\r\nif (!dt) {\r\nerror = -ENOMEM;\r\ngoto err_free_gpio;\r\n}\r\ndt->pdata = pdata;\r\ndt->i2c_client = client;\r\nerror = gp2a_initialize(dt);\r\nif (error < 0)\r\ngoto err_free_mem;\r\ndt->input = input_allocate_device();\r\nif (!dt->input) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\ninput_set_drvdata(dt->input, dt);\r\ndt->input->open = gp2a_device_open;\r\ndt->input->close = gp2a_device_close;\r\ndt->input->name = GP2A_I2C_NAME;\r\ndt->input->id.bustype = BUS_I2C;\r\ndt->input->dev.parent = &client->dev;\r\ninput_set_capability(dt->input, EV_SW, SW_FRONT_PROXIMITY);\r\nerror = request_threaded_irq(client->irq, NULL, gp2a_irq,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |\r\nIRQF_ONESHOT,\r\nGP2A_I2C_NAME, dt);\r\nif (error) {\r\ndev_err(&client->dev, "irq request failed\n");\r\ngoto err_free_input_dev;\r\n}\r\nerror = input_register_device(dt->input);\r\nif (error) {\r\ndev_err(&client->dev, "device registration failed\n");\r\ngoto err_free_irq;\r\n}\r\ndevice_init_wakeup(&client->dev, pdata->wakeup);\r\ni2c_set_clientdata(client, dt);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(client->irq, dt);\r\nerr_free_input_dev:\r\ninput_free_device(dt->input);\r\nerr_free_mem:\r\nkfree(dt);\r\nerr_free_gpio:\r\ngpio_free(pdata->vout_gpio);\r\nerr_hw_shutdown:\r\nif (pdata->hw_shutdown)\r\npdata->hw_shutdown(client);\r\nreturn error;\r\n}\r\nstatic int gp2a_remove(struct i2c_client *client)\r\n{\r\nstruct gp2a_data *dt = i2c_get_clientdata(client);\r\nconst struct gp2a_platform_data *pdata = dt->pdata;\r\ndevice_init_wakeup(&client->dev, false);\r\nfree_irq(client->irq, dt);\r\ninput_unregister_device(dt->input);\r\nkfree(dt);\r\ngpio_free(pdata->vout_gpio);\r\nif (pdata->hw_shutdown)\r\npdata->hw_shutdown(client);\r\nreturn 0;\r\n}\r\nstatic int gp2a_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct gp2a_data *dt = i2c_get_clientdata(client);\r\nint retval = 0;\r\nif (device_may_wakeup(&client->dev)) {\r\nenable_irq_wake(client->irq);\r\n} else {\r\nmutex_lock(&dt->input->mutex);\r\nif (dt->input->users)\r\nretval = gp2a_disable(dt);\r\nmutex_unlock(&dt->input->mutex);\r\n}\r\nreturn retval;\r\n}\r\nstatic int gp2a_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct gp2a_data *dt = i2c_get_clientdata(client);\r\nint retval = 0;\r\nif (device_may_wakeup(&client->dev)) {\r\ndisable_irq_wake(client->irq);\r\n} else {\r\nmutex_lock(&dt->input->mutex);\r\nif (dt->input->users)\r\nretval = gp2a_enable(dt);\r\nmutex_unlock(&dt->input->mutex);\r\n}\r\nreturn retval;\r\n}
