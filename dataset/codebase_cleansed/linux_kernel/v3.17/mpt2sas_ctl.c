static struct _sas_device *\r\n_ctl_sas_device_find_by_handle(struct MPT2SAS_ADAPTER *ioc, u16 handle)\r\n{\r\nstruct _sas_device *sas_device, *r;\r\nr = NULL;\r\nlist_for_each_entry(sas_device, &ioc->sas_device_list, list) {\r\nif (sas_device->handle != handle)\r\ncontinue;\r\nr = sas_device;\r\ngoto out;\r\n}\r\nout:\r\nreturn r;\r\n}\r\nstatic void\r\n_ctl_display_some_debug(struct MPT2SAS_ADAPTER *ioc, u16 smid,\r\nchar *calling_function_name, MPI2DefaultReply_t *mpi_reply)\r\n{\r\nMpi2ConfigRequest_t *mpi_request;\r\nchar *desc = NULL;\r\nif (!(ioc->logging_level & MPT_DEBUG_IOCTL))\r\nreturn;\r\nmpi_request = mpt2sas_base_get_msg_frame(ioc, smid);\r\nswitch (mpi_request->Function) {\r\ncase MPI2_FUNCTION_SCSI_IO_REQUEST:\r\n{\r\nMpi2SCSIIORequest_t *scsi_request =\r\n(Mpi2SCSIIORequest_t *)mpi_request;\r\nsnprintf(ioc->tmp_string, MPT_STRING_LENGTH,\r\n"scsi_io, cmd(0x%02x), cdb_len(%d)",\r\nscsi_request->CDB.CDB32[0],\r\nle16_to_cpu(scsi_request->IoFlags) & 0xF);\r\ndesc = ioc->tmp_string;\r\nbreak;\r\n}\r\ncase MPI2_FUNCTION_SCSI_TASK_MGMT:\r\ndesc = "task_mgmt";\r\nbreak;\r\ncase MPI2_FUNCTION_IOC_INIT:\r\ndesc = "ioc_init";\r\nbreak;\r\ncase MPI2_FUNCTION_IOC_FACTS:\r\ndesc = "ioc_facts";\r\nbreak;\r\ncase MPI2_FUNCTION_CONFIG:\r\n{\r\nMpi2ConfigRequest_t *config_request =\r\n(Mpi2ConfigRequest_t *)mpi_request;\r\nsnprintf(ioc->tmp_string, MPT_STRING_LENGTH,\r\n"config, type(0x%02x), ext_type(0x%02x), number(%d)",\r\n(config_request->Header.PageType &\r\nMPI2_CONFIG_PAGETYPE_MASK), config_request->ExtPageType,\r\nconfig_request->Header.PageNumber);\r\ndesc = ioc->tmp_string;\r\nbreak;\r\n}\r\ncase MPI2_FUNCTION_PORT_FACTS:\r\ndesc = "port_facts";\r\nbreak;\r\ncase MPI2_FUNCTION_PORT_ENABLE:\r\ndesc = "port_enable";\r\nbreak;\r\ncase MPI2_FUNCTION_EVENT_NOTIFICATION:\r\ndesc = "event_notification";\r\nbreak;\r\ncase MPI2_FUNCTION_FW_DOWNLOAD:\r\ndesc = "fw_download";\r\nbreak;\r\ncase MPI2_FUNCTION_FW_UPLOAD:\r\ndesc = "fw_upload";\r\nbreak;\r\ncase MPI2_FUNCTION_RAID_ACTION:\r\ndesc = "raid_action";\r\nbreak;\r\ncase MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH:\r\n{\r\nMpi2SCSIIORequest_t *scsi_request =\r\n(Mpi2SCSIIORequest_t *)mpi_request;\r\nsnprintf(ioc->tmp_string, MPT_STRING_LENGTH,\r\n"raid_pass, cmd(0x%02x), cdb_len(%d)",\r\nscsi_request->CDB.CDB32[0],\r\nle16_to_cpu(scsi_request->IoFlags) & 0xF);\r\ndesc = ioc->tmp_string;\r\nbreak;\r\n}\r\ncase MPI2_FUNCTION_SAS_IO_UNIT_CONTROL:\r\ndesc = "sas_iounit_cntl";\r\nbreak;\r\ncase MPI2_FUNCTION_SATA_PASSTHROUGH:\r\ndesc = "sata_pass";\r\nbreak;\r\ncase MPI2_FUNCTION_DIAG_BUFFER_POST:\r\ndesc = "diag_buffer_post";\r\nbreak;\r\ncase MPI2_FUNCTION_DIAG_RELEASE:\r\ndesc = "diag_release";\r\nbreak;\r\ncase MPI2_FUNCTION_SMP_PASSTHROUGH:\r\ndesc = "smp_passthrough";\r\nbreak;\r\n}\r\nif (!desc)\r\nreturn;\r\nprintk(MPT2SAS_INFO_FMT "%s: %s, smid(%d)\n",\r\nioc->name, calling_function_name, desc, smid);\r\nif (!mpi_reply)\r\nreturn;\r\nif (mpi_reply->IOCStatus || mpi_reply->IOCLogInfo)\r\nprintk(MPT2SAS_INFO_FMT\r\n"\tiocstatus(0x%04x), loginfo(0x%08x)\n",\r\nioc->name, le16_to_cpu(mpi_reply->IOCStatus),\r\nle32_to_cpu(mpi_reply->IOCLogInfo));\r\nif (mpi_request->Function == MPI2_FUNCTION_SCSI_IO_REQUEST ||\r\nmpi_request->Function ==\r\nMPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH) {\r\nMpi2SCSIIOReply_t *scsi_reply =\r\n(Mpi2SCSIIOReply_t *)mpi_reply;\r\nstruct _sas_device *sas_device = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = _ctl_sas_device_find_by_handle(ioc,\r\nle16_to_cpu(scsi_reply->DevHandle));\r\nif (sas_device) {\r\nprintk(MPT2SAS_WARN_FMT "\tsas_address(0x%016llx), "\r\n"phy(%d)\n", ioc->name, (unsigned long long)\r\nsas_device->sas_address, sas_device->phy);\r\nprintk(MPT2SAS_WARN_FMT\r\n"\tenclosure_logical_id(0x%016llx), slot(%d)\n",\r\nioc->name, sas_device->enclosure_logical_id,\r\nsas_device->slot);\r\n}\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nif (scsi_reply->SCSIState || scsi_reply->SCSIStatus)\r\nprintk(MPT2SAS_INFO_FMT\r\n"\tscsi_state(0x%02x), scsi_status"\r\n"(0x%02x)\n", ioc->name,\r\nscsi_reply->SCSIState,\r\nscsi_reply->SCSIStatus);\r\n}\r\n}\r\nu8\r\nmpt2sas_ctl_done(struct MPT2SAS_ADAPTER *ioc, u16 smid, u8 msix_index,\r\nu32 reply)\r\n{\r\nMPI2DefaultReply_t *mpi_reply;\r\nMpi2SCSIIOReply_t *scsiio_reply;\r\nconst void *sense_data;\r\nu32 sz;\r\nif (ioc->ctl_cmds.status == MPT2_CMD_NOT_USED)\r\nreturn 1;\r\nif (ioc->ctl_cmds.smid != smid)\r\nreturn 1;\r\nioc->ctl_cmds.status |= MPT2_CMD_COMPLETE;\r\nmpi_reply = mpt2sas_base_get_reply_virt_addr(ioc, reply);\r\nif (mpi_reply) {\r\nmemcpy(ioc->ctl_cmds.reply, mpi_reply, mpi_reply->MsgLength*4);\r\nioc->ctl_cmds.status |= MPT2_CMD_REPLY_VALID;\r\nif (mpi_reply->Function == MPI2_FUNCTION_SCSI_IO_REQUEST ||\r\nmpi_reply->Function ==\r\nMPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH) {\r\nscsiio_reply = (Mpi2SCSIIOReply_t *)mpi_reply;\r\nif (scsiio_reply->SCSIState &\r\nMPI2_SCSI_STATE_AUTOSENSE_VALID) {\r\nsz = min_t(u32, SCSI_SENSE_BUFFERSIZE,\r\nle32_to_cpu(scsiio_reply->SenseCount));\r\nsense_data = mpt2sas_base_get_sense_buffer(ioc,\r\nsmid);\r\nmemcpy(ioc->ctl_cmds.sense, sense_data, sz);\r\n}\r\n}\r\n}\r\n#ifdef CONFIG_SCSI_MPT2SAS_LOGGING\r\n_ctl_display_some_debug(ioc, smid, "ctl_done", mpi_reply);\r\n#endif\r\nioc->ctl_cmds.status &= ~MPT2_CMD_PENDING;\r\ncomplete(&ioc->ctl_cmds.done);\r\nreturn 1;\r\n}\r\nstatic int\r\n_ctl_check_event_type(struct MPT2SAS_ADAPTER *ioc, u16 event)\r\n{\r\nu16 i;\r\nu32 desired_event;\r\nif (event >= 128 || !event || !ioc->event_log)\r\nreturn 0;\r\ndesired_event = (1 << (event % 32));\r\nif (!desired_event)\r\ndesired_event = 1;\r\ni = event / 32;\r\nreturn desired_event & ioc->event_type[i];\r\n}\r\nvoid\r\nmpt2sas_ctl_add_to_event_log(struct MPT2SAS_ADAPTER *ioc,\r\nMpi2EventNotificationReply_t *mpi_reply)\r\n{\r\nstruct MPT2_IOCTL_EVENTS *event_log;\r\nu16 event;\r\nint i;\r\nu32 sz, event_data_sz;\r\nu8 send_aen = 0;\r\nif (!ioc->event_log)\r\nreturn;\r\nevent = le16_to_cpu(mpi_reply->Event);\r\nif (_ctl_check_event_type(ioc, event)) {\r\ni = ioc->event_context % MPT2SAS_CTL_EVENT_LOG_SIZE;\r\nevent_log = ioc->event_log;\r\nevent_log[i].event = event;\r\nevent_log[i].context = ioc->event_context++;\r\nevent_data_sz = le16_to_cpu(mpi_reply->EventDataLength)*4;\r\nsz = min_t(u32, event_data_sz, MPT2_EVENT_DATA_SIZE);\r\nmemset(event_log[i].data, 0, MPT2_EVENT_DATA_SIZE);\r\nmemcpy(event_log[i].data, mpi_reply->EventData, sz);\r\nsend_aen = 1;\r\n}\r\nif (event == MPI2_EVENT_LOG_ENTRY_ADDED ||\r\n(send_aen && !ioc->aen_event_read_flag)) {\r\nioc->aen_event_read_flag = 1;\r\nwake_up_interruptible(&ctl_poll_wait);\r\nif (async_queue)\r\nkill_fasync(&async_queue, SIGIO, POLL_IN);\r\n}\r\n}\r\nvoid\r\nmpt2sas_ctl_event_callback(struct MPT2SAS_ADAPTER *ioc, u8 msix_index,\r\nu32 reply)\r\n{\r\nMpi2EventNotificationReply_t *mpi_reply;\r\nmpi_reply = mpt2sas_base_get_reply_virt_addr(ioc, reply);\r\nif (unlikely(!mpi_reply)) {\r\nprintk(MPT2SAS_ERR_FMT "mpi_reply not valid at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn;\r\n}\r\nmpt2sas_ctl_add_to_event_log(ioc, mpi_reply);\r\nreturn;\r\n}\r\nstatic int\r\n_ctl_verify_adapter(int ioc_number, struct MPT2SAS_ADAPTER **iocpp)\r\n{\r\nstruct MPT2SAS_ADAPTER *ioc;\r\nlist_for_each_entry(ioc, &mpt2sas_ioc_list, list) {\r\nif (ioc->id != ioc_number)\r\ncontinue;\r\n*iocpp = ioc;\r\nreturn ioc_number;\r\n}\r\n*iocpp = NULL;\r\nreturn -1;\r\n}\r\nvoid\r\nmpt2sas_ctl_reset_handler(struct MPT2SAS_ADAPTER *ioc, int reset_phase)\r\n{\r\nint i;\r\nu8 issue_reset;\r\nswitch (reset_phase) {\r\ncase MPT2_IOC_PRE_RESET:\r\ndtmprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "\r\n"MPT2_IOC_PRE_RESET\n", ioc->name, __func__));\r\nfor (i = 0; i < MPI2_DIAG_BUF_TYPE_COUNT; i++) {\r\nif (!(ioc->diag_buffer_status[i] &\r\nMPT2_DIAG_BUFFER_IS_REGISTERED))\r\ncontinue;\r\nif ((ioc->diag_buffer_status[i] &\r\nMPT2_DIAG_BUFFER_IS_RELEASED))\r\ncontinue;\r\n_ctl_send_release(ioc, i, &issue_reset);\r\n}\r\nbreak;\r\ncase MPT2_IOC_AFTER_RESET:\r\ndtmprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "\r\n"MPT2_IOC_AFTER_RESET\n", ioc->name, __func__));\r\nif (ioc->ctl_cmds.status & MPT2_CMD_PENDING) {\r\nioc->ctl_cmds.status |= MPT2_CMD_RESET;\r\nmpt2sas_base_free_smid(ioc, ioc->ctl_cmds.smid);\r\ncomplete(&ioc->ctl_cmds.done);\r\n}\r\nbreak;\r\ncase MPT2_IOC_DONE_RESET:\r\ndtmprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "\r\n"MPT2_IOC_DONE_RESET\n", ioc->name, __func__));\r\nfor (i = 0; i < MPI2_DIAG_BUF_TYPE_COUNT; i++) {\r\nif (!(ioc->diag_buffer_status[i] &\r\nMPT2_DIAG_BUFFER_IS_REGISTERED))\r\ncontinue;\r\nif ((ioc->diag_buffer_status[i] &\r\nMPT2_DIAG_BUFFER_IS_RELEASED))\r\ncontinue;\r\nioc->diag_buffer_status[i] |=\r\nMPT2_DIAG_BUFFER_IS_DIAG_RESET;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int\r\n_ctl_fasync(int fd, struct file *filep, int mode)\r\n{\r\nreturn fasync_helper(fd, filep, mode, &async_queue);\r\n}\r\nstatic unsigned int\r\n_ctl_poll(struct file *filep, poll_table *wait)\r\n{\r\nstruct MPT2SAS_ADAPTER *ioc;\r\npoll_wait(filep, &ctl_poll_wait, wait);\r\nlist_for_each_entry(ioc, &mpt2sas_ioc_list, list) {\r\nif (ioc->aen_event_read_flag)\r\nreturn POLLIN | POLLRDNORM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\n_ctl_set_task_mid(struct MPT2SAS_ADAPTER *ioc, struct mpt2_ioctl_command *karg,\r\nMpi2SCSITaskManagementRequest_t *tm_request)\r\n{\r\nu8 found = 0;\r\nu16 i;\r\nu16 handle;\r\nstruct scsi_cmnd *scmd;\r\nstruct MPT2SAS_DEVICE *priv_data;\r\nunsigned long flags;\r\nMpi2SCSITaskManagementReply_t *tm_reply;\r\nu32 sz;\r\nu32 lun;\r\nchar *desc = NULL;\r\nif (tm_request->TaskType == MPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK)\r\ndesc = "abort_task";\r\nelse if (tm_request->TaskType == MPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK)\r\ndesc = "query_task";\r\nelse\r\nreturn 0;\r\nlun = scsilun_to_int((struct scsi_lun *)tm_request->LUN);\r\nhandle = le16_to_cpu(tm_request->DevHandle);\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\nfor (i = ioc->scsiio_depth; i && !found; i--) {\r\nscmd = ioc->scsi_lookup[i - 1].scmd;\r\nif (scmd == NULL || scmd->device == NULL ||\r\nscmd->device->hostdata == NULL)\r\ncontinue;\r\nif (lun != scmd->device->lun)\r\ncontinue;\r\npriv_data = scmd->device->hostdata;\r\nif (priv_data->sas_target == NULL)\r\ncontinue;\r\nif (priv_data->sas_target->handle != handle)\r\ncontinue;\r\ntm_request->TaskMID = cpu_to_le16(ioc->scsi_lookup[i - 1].smid);\r\nfound = 1;\r\n}\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nif (!found) {\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "\r\n"handle(0x%04x), lun(%d), no active mid!!\n", ioc->name,\r\ndesc, le16_to_cpu(tm_request->DevHandle), lun));\r\ntm_reply = ioc->ctl_cmds.reply;\r\ntm_reply->DevHandle = tm_request->DevHandle;\r\ntm_reply->Function = MPI2_FUNCTION_SCSI_TASK_MGMT;\r\ntm_reply->TaskType = tm_request->TaskType;\r\ntm_reply->MsgLength = sizeof(Mpi2SCSITaskManagementReply_t)/4;\r\ntm_reply->VP_ID = tm_request->VP_ID;\r\ntm_reply->VF_ID = tm_request->VF_ID;\r\nsz = min_t(u32, karg->max_reply_bytes, ioc->reply_sz);\r\nif (copy_to_user(karg->reply_frame_buf_ptr, ioc->ctl_cmds.reply,\r\nsz))\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n", __FILE__,\r\n__LINE__, __func__);\r\nreturn 1;\r\n}\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "\r\n"handle(0x%04x), lun(%d), task_mid(%d)\n", ioc->name,\r\ndesc, le16_to_cpu(tm_request->DevHandle), lun,\r\nle16_to_cpu(tm_request->TaskMID)));\r\nreturn 0;\r\n}\r\nstatic long\r\n_ctl_do_mpt_command(struct MPT2SAS_ADAPTER *ioc, struct mpt2_ioctl_command karg,\r\nvoid __user *mf)\r\n{\r\nMPI2RequestHeader_t *mpi_request = NULL, *request;\r\nMPI2DefaultReply_t *mpi_reply;\r\nu32 ioc_state;\r\nu16 ioc_status;\r\nu16 smid;\r\nunsigned long timeout, timeleft;\r\nu8 issue_reset;\r\nu32 sz;\r\nvoid *psge;\r\nvoid *data_out = NULL;\r\ndma_addr_t data_out_dma;\r\nsize_t data_out_sz = 0;\r\nvoid *data_in = NULL;\r\ndma_addr_t data_in_dma;\r\nsize_t data_in_sz = 0;\r\nu32 sgl_flags;\r\nlong ret;\r\nu16 wait_state_count;\r\nissue_reset = 0;\r\nif (ioc->ctl_cmds.status != MPT2_CMD_NOT_USED) {\r\nprintk(MPT2SAS_ERR_FMT "%s: ctl_cmd in use\n",\r\nioc->name, __func__);\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\nwait_state_count = 0;\r\nioc_state = mpt2sas_base_get_iocstate(ioc, 1);\r\nwhile (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {\r\nif (wait_state_count++ == 10) {\r\nprintk(MPT2SAS_ERR_FMT\r\n"%s: failed due to ioc not operational\n",\r\nioc->name, __func__);\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nssleep(1);\r\nioc_state = mpt2sas_base_get_iocstate(ioc, 1);\r\nprintk(MPT2SAS_INFO_FMT "%s: waiting for "\r\n"operational state(count=%d)\n", ioc->name,\r\n__func__, wait_state_count);\r\n}\r\nif (wait_state_count)\r\nprintk(MPT2SAS_INFO_FMT "%s: ioc is operational\n",\r\nioc->name, __func__);\r\nmpi_request = kzalloc(ioc->request_sz, GFP_KERNEL);\r\nif (!mpi_request) {\r\nprintk(MPT2SAS_ERR_FMT "%s: failed obtaining a memory for "\r\n"mpi_request\n", ioc->name, __func__);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (karg.data_sge_offset * 4 > ioc->request_sz ||\r\nkarg.data_sge_offset > (UINT_MAX / 4)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (copy_from_user(mpi_request, mf, karg.data_sge_offset*4)) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n", __FILE__, __LINE__,\r\n__func__);\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nif (mpi_request->Function == MPI2_FUNCTION_SCSI_TASK_MGMT) {\r\nsmid = mpt2sas_base_get_smid_hpr(ioc, ioc->ctl_cb_idx);\r\nif (!smid) {\r\nprintk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",\r\nioc->name, __func__);\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\n} else {\r\nsmid = mpt2sas_base_get_smid_scsiio(ioc, ioc->ctl_cb_idx, NULL);\r\nif (!smid) {\r\nprintk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",\r\nioc->name, __func__);\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\n}\r\nret = 0;\r\nioc->ctl_cmds.status = MPT2_CMD_PENDING;\r\nmemset(ioc->ctl_cmds.reply, 0, ioc->reply_sz);\r\nrequest = mpt2sas_base_get_msg_frame(ioc, smid);\r\nmemcpy(request, mpi_request, karg.data_sge_offset*4);\r\nioc->ctl_cmds.smid = smid;\r\ndata_out_sz = karg.data_out_size;\r\ndata_in_sz = karg.data_in_size;\r\nif (mpi_request->Function == MPI2_FUNCTION_SCSI_IO_REQUEST ||\r\nmpi_request->Function == MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH) {\r\nif (!le16_to_cpu(mpi_request->FunctionDependent1) ||\r\nle16_to_cpu(mpi_request->FunctionDependent1) >\r\nioc->facts.MaxDevHandle) {\r\nret = -EINVAL;\r\nmpt2sas_base_free_smid(ioc, smid);\r\ngoto out;\r\n}\r\n}\r\nif (data_out_sz) {\r\ndata_out = pci_alloc_consistent(ioc->pdev, data_out_sz,\r\n&data_out_dma);\r\nif (!data_out) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n", __FILE__,\r\n__LINE__, __func__);\r\nret = -ENOMEM;\r\nmpt2sas_base_free_smid(ioc, smid);\r\ngoto out;\r\n}\r\nif (copy_from_user(data_out, karg.data_out_buf_ptr,\r\ndata_out_sz)) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n", __FILE__,\r\n__LINE__, __func__);\r\nret = -EFAULT;\r\nmpt2sas_base_free_smid(ioc, smid);\r\ngoto out;\r\n}\r\n}\r\nif (data_in_sz) {\r\ndata_in = pci_alloc_consistent(ioc->pdev, data_in_sz,\r\n&data_in_dma);\r\nif (!data_in) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n", __FILE__,\r\n__LINE__, __func__);\r\nret = -ENOMEM;\r\nmpt2sas_base_free_smid(ioc, smid);\r\ngoto out;\r\n}\r\n}\r\npsge = (void *)request + (karg.data_sge_offset*4);\r\nif (!data_out_sz && !data_in_sz) {\r\nmpt2sas_base_build_zero_len_sge(ioc, psge);\r\n} else if (data_out_sz && data_in_sz) {\r\nsgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |\r\nMPI2_SGE_FLAGS_END_OF_BUFFER | MPI2_SGE_FLAGS_HOST_TO_IOC);\r\nsgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;\r\nioc->base_add_sg_single(psge, sgl_flags |\r\ndata_out_sz, data_out_dma);\r\npsge += ioc->sge_size;\r\nsgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |\r\nMPI2_SGE_FLAGS_LAST_ELEMENT | MPI2_SGE_FLAGS_END_OF_BUFFER |\r\nMPI2_SGE_FLAGS_END_OF_LIST);\r\nsgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;\r\nioc->base_add_sg_single(psge, sgl_flags |\r\ndata_in_sz, data_in_dma);\r\n} else if (data_out_sz) {\r\nsgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |\r\nMPI2_SGE_FLAGS_LAST_ELEMENT | MPI2_SGE_FLAGS_END_OF_BUFFER |\r\nMPI2_SGE_FLAGS_END_OF_LIST | MPI2_SGE_FLAGS_HOST_TO_IOC);\r\nsgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;\r\nioc->base_add_sg_single(psge, sgl_flags |\r\ndata_out_sz, data_out_dma);\r\n} else if (data_in_sz) {\r\nsgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |\r\nMPI2_SGE_FLAGS_LAST_ELEMENT | MPI2_SGE_FLAGS_END_OF_BUFFER |\r\nMPI2_SGE_FLAGS_END_OF_LIST);\r\nsgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;\r\nioc->base_add_sg_single(psge, sgl_flags |\r\ndata_in_sz, data_in_dma);\r\n}\r\n#ifdef CONFIG_SCSI_MPT2SAS_LOGGING\r\n_ctl_display_some_debug(ioc, smid, "ctl_request", NULL);\r\n#endif\r\ninit_completion(&ioc->ctl_cmds.done);\r\nswitch (mpi_request->Function) {\r\ncase MPI2_FUNCTION_SCSI_IO_REQUEST:\r\ncase MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH:\r\n{\r\nMpi2SCSIIORequest_t *scsiio_request =\r\n(Mpi2SCSIIORequest_t *)request;\r\nscsiio_request->SenseBufferLength = SCSI_SENSE_BUFFERSIZE;\r\nscsiio_request->SenseBufferLowAddress =\r\nmpt2sas_base_get_sense_buffer_dma(ioc, smid);\r\nmemset(ioc->ctl_cmds.sense, 0, SCSI_SENSE_BUFFERSIZE);\r\nif (mpi_request->Function == MPI2_FUNCTION_SCSI_IO_REQUEST)\r\nmpt2sas_base_put_smid_scsi_io(ioc, smid,\r\nle16_to_cpu(mpi_request->FunctionDependent1));\r\nelse\r\nmpt2sas_base_put_smid_default(ioc, smid);\r\nbreak;\r\n}\r\ncase MPI2_FUNCTION_SCSI_TASK_MGMT:\r\n{\r\nMpi2SCSITaskManagementRequest_t *tm_request =\r\n(Mpi2SCSITaskManagementRequest_t *)request;\r\ndtmprintk(ioc, printk(MPT2SAS_INFO_FMT "TASK_MGMT: "\r\n"handle(0x%04x), task_type(0x%02x)\n", ioc->name,\r\nle16_to_cpu(tm_request->DevHandle), tm_request->TaskType));\r\nif (tm_request->TaskType ==\r\nMPI2_SCSITASKMGMT_TASKTYPE_ABORT_TASK ||\r\ntm_request->TaskType ==\r\nMPI2_SCSITASKMGMT_TASKTYPE_QUERY_TASK) {\r\nif (_ctl_set_task_mid(ioc, &karg, tm_request)) {\r\nmpt2sas_base_free_smid(ioc, smid);\r\ngoto out;\r\n}\r\n}\r\nmpt2sas_scsih_set_tm_flag(ioc, le16_to_cpu(\r\ntm_request->DevHandle));\r\nmpt2sas_base_put_smid_hi_priority(ioc, smid);\r\nbreak;\r\n}\r\ncase MPI2_FUNCTION_SMP_PASSTHROUGH:\r\n{\r\nMpi2SmpPassthroughRequest_t *smp_request =\r\n(Mpi2SmpPassthroughRequest_t *)mpi_request;\r\nu8 *data;\r\nsmp_request->PhysicalPort = 0xFF;\r\nif (smp_request->PassthroughFlags &\r\nMPI2_SMP_PT_REQ_PT_FLAGS_IMMEDIATE)\r\ndata = (u8 *)&smp_request->SGL;\r\nelse {\r\nif (unlikely(data_out == NULL)) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n",\r\n__FILE__, __LINE__, __func__);\r\nmpt2sas_base_free_smid(ioc, smid);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ndata = data_out;\r\n}\r\nif (data[1] == 0x91 && (data[10] == 1 || data[10] == 2)) {\r\nioc->ioc_link_reset_in_progress = 1;\r\nioc->ignore_loginfos = 1;\r\n}\r\nmpt2sas_base_put_smid_default(ioc, smid);\r\nbreak;\r\n}\r\ncase MPI2_FUNCTION_SAS_IO_UNIT_CONTROL:\r\n{\r\nMpi2SasIoUnitControlRequest_t *sasiounit_request =\r\n(Mpi2SasIoUnitControlRequest_t *)mpi_request;\r\nif (sasiounit_request->Operation == MPI2_SAS_OP_PHY_HARD_RESET\r\n|| sasiounit_request->Operation ==\r\nMPI2_SAS_OP_PHY_LINK_RESET) {\r\nioc->ioc_link_reset_in_progress = 1;\r\nioc->ignore_loginfos = 1;\r\n}\r\nmpt2sas_base_put_smid_default(ioc, smid);\r\nbreak;\r\n}\r\ndefault:\r\nmpt2sas_base_put_smid_default(ioc, smid);\r\nbreak;\r\n}\r\nif (karg.timeout < MPT2_IOCTL_DEFAULT_TIMEOUT)\r\ntimeout = MPT2_IOCTL_DEFAULT_TIMEOUT;\r\nelse\r\ntimeout = karg.timeout;\r\ntimeleft = wait_for_completion_timeout(&ioc->ctl_cmds.done,\r\ntimeout*HZ);\r\nif (mpi_request->Function == MPI2_FUNCTION_SCSI_TASK_MGMT) {\r\nMpi2SCSITaskManagementRequest_t *tm_request =\r\n(Mpi2SCSITaskManagementRequest_t *)mpi_request;\r\nmpt2sas_scsih_clear_tm_flag(ioc, le16_to_cpu(\r\ntm_request->DevHandle));\r\n} else if ((mpi_request->Function == MPI2_FUNCTION_SMP_PASSTHROUGH ||\r\nmpi_request->Function == MPI2_FUNCTION_SAS_IO_UNIT_CONTROL) &&\r\nioc->ioc_link_reset_in_progress) {\r\nioc->ioc_link_reset_in_progress = 0;\r\nioc->ignore_loginfos = 0;\r\n}\r\nif (!(ioc->ctl_cmds.status & MPT2_CMD_COMPLETE)) {\r\nprintk(MPT2SAS_ERR_FMT "%s: timeout\n", ioc->name,\r\n__func__);\r\n_debug_dump_mf(mpi_request, karg.data_sge_offset);\r\nif (!(ioc->ctl_cmds.status & MPT2_CMD_RESET))\r\nissue_reset = 1;\r\ngoto issue_host_reset;\r\n}\r\nmpi_reply = ioc->ctl_cmds.reply;\r\nioc_status = le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK;\r\n#ifdef CONFIG_SCSI_MPT2SAS_LOGGING\r\nif (mpi_reply->Function == MPI2_FUNCTION_SCSI_TASK_MGMT &&\r\n(ioc->logging_level & MPT_DEBUG_TM)) {\r\nMpi2SCSITaskManagementReply_t *tm_reply =\r\n(Mpi2SCSITaskManagementReply_t *)mpi_reply;\r\nprintk(MPT2SAS_INFO_FMT "TASK_MGMT: "\r\n"IOCStatus(0x%04x), IOCLogInfo(0x%08x), "\r\n"TerminationCount(0x%08x)\n", ioc->name,\r\nle16_to_cpu(tm_reply->IOCStatus),\r\nle32_to_cpu(tm_reply->IOCLogInfo),\r\nle32_to_cpu(tm_reply->TerminationCount));\r\n}\r\n#endif\r\nif (data_in_sz) {\r\nif (copy_to_user(karg.data_in_buf_ptr, data_in,\r\ndata_in_sz)) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n", __FILE__,\r\n__LINE__, __func__);\r\nret = -ENODATA;\r\ngoto out;\r\n}\r\n}\r\nif (karg.max_reply_bytes) {\r\nsz = min_t(u32, karg.max_reply_bytes, ioc->reply_sz);\r\nif (copy_to_user(karg.reply_frame_buf_ptr, ioc->ctl_cmds.reply,\r\nsz)) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n", __FILE__,\r\n__LINE__, __func__);\r\nret = -ENODATA;\r\ngoto out;\r\n}\r\n}\r\nif (karg.max_sense_bytes && (mpi_request->Function ==\r\nMPI2_FUNCTION_SCSI_IO_REQUEST || mpi_request->Function ==\r\nMPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)) {\r\nsz = min_t(u32, karg.max_sense_bytes, SCSI_SENSE_BUFFERSIZE);\r\nif (copy_to_user(karg.sense_data_ptr,\r\nioc->ctl_cmds.sense, sz)) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n", __FILE__,\r\n__LINE__, __func__);\r\nret = -ENODATA;\r\ngoto out;\r\n}\r\n}\r\nissue_host_reset:\r\nif (issue_reset) {\r\nret = -ENODATA;\r\nif ((mpi_request->Function == MPI2_FUNCTION_SCSI_IO_REQUEST ||\r\nmpi_request->Function ==\r\nMPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH ||\r\nmpi_request->Function == MPI2_FUNCTION_SATA_PASSTHROUGH)) {\r\nprintk(MPT2SAS_INFO_FMT "issue target reset: handle "\r\n"= (0x%04x)\n", ioc->name,\r\nle16_to_cpu(mpi_request->FunctionDependent1));\r\nmpt2sas_halt_firmware(ioc);\r\nmpt2sas_scsih_issue_tm(ioc,\r\nle16_to_cpu(mpi_request->FunctionDependent1), 0, 0,\r\n0, MPI2_SCSITASKMGMT_TASKTYPE_TARGET_RESET, 0, 10,\r\nTM_MUTEX_ON);\r\nioc->tm_cmds.status = MPT2_CMD_NOT_USED;\r\n} else\r\nmpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,\r\nFORCE_BIG_HAMMER);\r\n}\r\nout:\r\nif (data_in)\r\npci_free_consistent(ioc->pdev, data_in_sz, data_in,\r\ndata_in_dma);\r\nif (data_out)\r\npci_free_consistent(ioc->pdev, data_out_sz, data_out,\r\ndata_out_dma);\r\nkfree(mpi_request);\r\nioc->ctl_cmds.status = MPT2_CMD_NOT_USED;\r\nreturn ret;\r\n}\r\nstatic long\r\n_ctl_getiocinfo(struct MPT2SAS_ADAPTER *ioc, void __user *arg)\r\n{\r\nstruct mpt2_ioctl_iocinfo karg;\r\nif (copy_from_user(&karg, arg, sizeof(karg))) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn -EFAULT;\r\n}\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: enter\n", ioc->name,\r\n__func__));\r\nmemset(&karg, 0 , sizeof(karg));\r\nif (ioc->is_warpdrive)\r\nkarg.adapter_type = MPT2_IOCTL_INTERFACE_SAS2_SSS6200;\r\nelse\r\nkarg.adapter_type = MPT2_IOCTL_INTERFACE_SAS2;\r\nif (ioc->pfacts)\r\nkarg.port_number = ioc->pfacts[0].PortNumber;\r\nkarg.hw_rev = ioc->pdev->revision;\r\nkarg.pci_id = ioc->pdev->device;\r\nkarg.subsystem_device = ioc->pdev->subsystem_device;\r\nkarg.subsystem_vendor = ioc->pdev->subsystem_vendor;\r\nkarg.pci_information.u.bits.bus = ioc->pdev->bus->number;\r\nkarg.pci_information.u.bits.device = PCI_SLOT(ioc->pdev->devfn);\r\nkarg.pci_information.u.bits.function = PCI_FUNC(ioc->pdev->devfn);\r\nkarg.pci_information.segment_id = pci_domain_nr(ioc->pdev->bus);\r\nkarg.firmware_version = ioc->facts.FWVersion.Word;\r\nstrcpy(karg.driver_version, MPT2SAS_DRIVER_NAME);\r\nstrcat(karg.driver_version, "-");\r\nstrcat(karg.driver_version, MPT2SAS_DRIVER_VERSION);\r\nkarg.bios_version = le32_to_cpu(ioc->bios_pg3.BiosVersion);\r\nif (copy_to_user(arg, &karg, sizeof(karg))) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic long\r\n_ctl_eventquery(struct MPT2SAS_ADAPTER *ioc, void __user *arg)\r\n{\r\nstruct mpt2_ioctl_eventquery karg;\r\nif (copy_from_user(&karg, arg, sizeof(karg))) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn -EFAULT;\r\n}\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: enter\n", ioc->name,\r\n__func__));\r\nkarg.event_entries = MPT2SAS_CTL_EVENT_LOG_SIZE;\r\nmemcpy(karg.event_types, ioc->event_type,\r\nMPI2_EVENT_NOTIFY_EVENTMASK_WORDS * sizeof(u32));\r\nif (copy_to_user(arg, &karg, sizeof(karg))) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic long\r\n_ctl_eventenable(struct MPT2SAS_ADAPTER *ioc, void __user *arg)\r\n{\r\nstruct mpt2_ioctl_eventenable karg;\r\nif (copy_from_user(&karg, arg, sizeof(karg))) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn -EFAULT;\r\n}\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: enter\n", ioc->name,\r\n__func__));\r\nif (ioc->event_log)\r\nreturn 0;\r\nmemcpy(ioc->event_type, karg.event_types,\r\nMPI2_EVENT_NOTIFY_EVENTMASK_WORDS * sizeof(u32));\r\nmpt2sas_base_validate_event_type(ioc, ioc->event_type);\r\nioc->event_context = 0;\r\nioc->aen_event_read_flag = 0;\r\nioc->event_log = kcalloc(MPT2SAS_CTL_EVENT_LOG_SIZE,\r\nsizeof(struct MPT2_IOCTL_EVENTS), GFP_KERNEL);\r\nif (!ioc->event_log) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic long\r\n_ctl_eventreport(struct MPT2SAS_ADAPTER *ioc, void __user *arg)\r\n{\r\nstruct mpt2_ioctl_eventreport karg;\r\nu32 number_bytes, max_events, max;\r\nstruct mpt2_ioctl_eventreport __user *uarg = arg;\r\nif (copy_from_user(&karg, arg, sizeof(karg))) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn -EFAULT;\r\n}\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: enter\n", ioc->name,\r\n__func__));\r\nnumber_bytes = karg.hdr.max_data_size -\r\nsizeof(struct mpt2_ioctl_header);\r\nmax_events = number_bytes/sizeof(struct MPT2_IOCTL_EVENTS);\r\nmax = min_t(u32, MPT2SAS_CTL_EVENT_LOG_SIZE, max_events);\r\nif (!max || !ioc->event_log)\r\nreturn -ENODATA;\r\nnumber_bytes = max * sizeof(struct MPT2_IOCTL_EVENTS);\r\nif (copy_to_user(uarg->event_data, ioc->event_log, number_bytes)) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn -EFAULT;\r\n}\r\nioc->aen_event_read_flag = 0;\r\nreturn 0;\r\n}\r\nstatic long\r\n_ctl_do_reset(struct MPT2SAS_ADAPTER *ioc, void __user *arg)\r\n{\r\nstruct mpt2_ioctl_diag_reset karg;\r\nint retval;\r\nif (copy_from_user(&karg, arg, sizeof(karg))) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn -EFAULT;\r\n}\r\nif (ioc->shost_recovery || ioc->pci_error_recovery ||\r\nioc->is_driver_loading)\r\nreturn -EAGAIN;\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: enter\n", ioc->name,\r\n__func__));\r\nretval = mpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,\r\nFORCE_BIG_HAMMER);\r\nprintk(MPT2SAS_INFO_FMT "host reset: %s\n",\r\nioc->name, ((!retval) ? "SUCCESS" : "FAILED"));\r\nreturn 0;\r\n}\r\nstatic int\r\n_ctl_btdh_search_sas_device(struct MPT2SAS_ADAPTER *ioc,\r\nstruct mpt2_ioctl_btdh_mapping *btdh)\r\n{\r\nstruct _sas_device *sas_device;\r\nunsigned long flags;\r\nint rc = 0;\r\nif (list_empty(&ioc->sas_device_list))\r\nreturn rc;\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nlist_for_each_entry(sas_device, &ioc->sas_device_list, list) {\r\nif (btdh->bus == 0xFFFFFFFF && btdh->id == 0xFFFFFFFF &&\r\nbtdh->handle == sas_device->handle) {\r\nbtdh->bus = sas_device->channel;\r\nbtdh->id = sas_device->id;\r\nrc = 1;\r\ngoto out;\r\n} else if (btdh->bus == sas_device->channel && btdh->id ==\r\nsas_device->id && btdh->handle == 0xFFFF) {\r\nbtdh->handle = sas_device->handle;\r\nrc = 1;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nreturn rc;\r\n}\r\nstatic int\r\n_ctl_btdh_search_raid_device(struct MPT2SAS_ADAPTER *ioc,\r\nstruct mpt2_ioctl_btdh_mapping *btdh)\r\n{\r\nstruct _raid_device *raid_device;\r\nunsigned long flags;\r\nint rc = 0;\r\nif (list_empty(&ioc->raid_device_list))\r\nreturn rc;\r\nspin_lock_irqsave(&ioc->raid_device_lock, flags);\r\nlist_for_each_entry(raid_device, &ioc->raid_device_list, list) {\r\nif (btdh->bus == 0xFFFFFFFF && btdh->id == 0xFFFFFFFF &&\r\nbtdh->handle == raid_device->handle) {\r\nbtdh->bus = raid_device->channel;\r\nbtdh->id = raid_device->id;\r\nrc = 1;\r\ngoto out;\r\n} else if (btdh->bus == raid_device->channel && btdh->id ==\r\nraid_device->id && btdh->handle == 0xFFFF) {\r\nbtdh->handle = raid_device->handle;\r\nrc = 1;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nspin_unlock_irqrestore(&ioc->raid_device_lock, flags);\r\nreturn rc;\r\n}\r\nstatic long\r\n_ctl_btdh_mapping(struct MPT2SAS_ADAPTER *ioc, void __user *arg)\r\n{\r\nstruct mpt2_ioctl_btdh_mapping karg;\r\nint rc;\r\nif (copy_from_user(&karg, arg, sizeof(karg))) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn -EFAULT;\r\n}\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,\r\n__func__));\r\nrc = _ctl_btdh_search_sas_device(ioc, &karg);\r\nif (!rc)\r\n_ctl_btdh_search_raid_device(ioc, &karg);\r\nif (copy_to_user(arg, &karg, sizeof(karg))) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic u8\r\n_ctl_diag_capability(struct MPT2SAS_ADAPTER *ioc, u8 buffer_type)\r\n{\r\nu8 rc = 0;\r\nswitch (buffer_type) {\r\ncase MPI2_DIAG_BUF_TYPE_TRACE:\r\nif (ioc->facts.IOCCapabilities &\r\nMPI2_IOCFACTS_CAPABILITY_DIAG_TRACE_BUFFER)\r\nrc = 1;\r\nbreak;\r\ncase MPI2_DIAG_BUF_TYPE_SNAPSHOT:\r\nif (ioc->facts.IOCCapabilities &\r\nMPI2_IOCFACTS_CAPABILITY_SNAPSHOT_BUFFER)\r\nrc = 1;\r\nbreak;\r\ncase MPI2_DIAG_BUF_TYPE_EXTENDED:\r\nif (ioc->facts.IOCCapabilities &\r\nMPI2_IOCFACTS_CAPABILITY_EXTENDED_BUFFER)\r\nrc = 1;\r\n}\r\nreturn rc;\r\n}\r\nstatic long\r\n_ctl_diag_register_2(struct MPT2SAS_ADAPTER *ioc,\r\nstruct mpt2_diag_register *diag_register)\r\n{\r\nint rc, i;\r\nvoid *request_data = NULL;\r\ndma_addr_t request_data_dma;\r\nu32 request_data_sz = 0;\r\nMpi2DiagBufferPostRequest_t *mpi_request;\r\nMpi2DiagBufferPostReply_t *mpi_reply;\r\nu8 buffer_type;\r\nunsigned long timeleft;\r\nu16 smid;\r\nu16 ioc_status;\r\nu8 issue_reset = 0;\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,\r\n__func__));\r\nif (ioc->ctl_cmds.status != MPT2_CMD_NOT_USED) {\r\nprintk(MPT2SAS_ERR_FMT "%s: ctl_cmd in use\n",\r\nioc->name, __func__);\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nbuffer_type = diag_register->buffer_type;\r\nif (!_ctl_diag_capability(ioc, buffer_type)) {\r\nprintk(MPT2SAS_ERR_FMT "%s: doesn't have capability for "\r\n"buffer_type(0x%02x)\n", ioc->name, __func__, buffer_type);\r\nreturn -EPERM;\r\n}\r\nif (ioc->diag_buffer_status[buffer_type] &\r\nMPT2_DIAG_BUFFER_IS_REGISTERED) {\r\nprintk(MPT2SAS_ERR_FMT "%s: already has a registered "\r\n"buffer for buffer_type(0x%02x)\n", ioc->name, __func__,\r\nbuffer_type);\r\nreturn -EINVAL;\r\n}\r\nif (diag_register->requested_buffer_size % 4) {\r\nprintk(MPT2SAS_ERR_FMT "%s: the requested_buffer_size "\r\n"is not 4 byte aligned\n", ioc->name, __func__);\r\nreturn -EINVAL;\r\n}\r\nsmid = mpt2sas_base_get_smid(ioc, ioc->ctl_cb_idx);\r\nif (!smid) {\r\nprintk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",\r\nioc->name, __func__);\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nrc = 0;\r\nioc->ctl_cmds.status = MPT2_CMD_PENDING;\r\nmemset(ioc->ctl_cmds.reply, 0, ioc->reply_sz);\r\nmpi_request = mpt2sas_base_get_msg_frame(ioc, smid);\r\nioc->ctl_cmds.smid = smid;\r\nrequest_data = ioc->diag_buffer[buffer_type];\r\nrequest_data_sz = diag_register->requested_buffer_size;\r\nioc->unique_id[buffer_type] = diag_register->unique_id;\r\nioc->diag_buffer_status[buffer_type] = 0;\r\nmemcpy(ioc->product_specific[buffer_type],\r\ndiag_register->product_specific, MPT2_PRODUCT_SPECIFIC_DWORDS);\r\nioc->diagnostic_flags[buffer_type] = diag_register->diagnostic_flags;\r\nif (request_data) {\r\nrequest_data_dma = ioc->diag_buffer_dma[buffer_type];\r\nif (request_data_sz != ioc->diag_buffer_sz[buffer_type]) {\r\npci_free_consistent(ioc->pdev,\r\nioc->diag_buffer_sz[buffer_type],\r\nrequest_data, request_data_dma);\r\nrequest_data = NULL;\r\n}\r\n}\r\nif (request_data == NULL) {\r\nioc->diag_buffer_sz[buffer_type] = 0;\r\nioc->diag_buffer_dma[buffer_type] = 0;\r\nrequest_data = pci_alloc_consistent(\r\nioc->pdev, request_data_sz, &request_data_dma);\r\nif (request_data == NULL) {\r\nprintk(MPT2SAS_ERR_FMT "%s: failed allocating memory"\r\n" for diag buffers, requested size(%d)\n",\r\nioc->name, __func__, request_data_sz);\r\nmpt2sas_base_free_smid(ioc, smid);\r\nreturn -ENOMEM;\r\n}\r\nioc->diag_buffer[buffer_type] = request_data;\r\nioc->diag_buffer_sz[buffer_type] = request_data_sz;\r\nioc->diag_buffer_dma[buffer_type] = request_data_dma;\r\n}\r\nmpi_request->Function = MPI2_FUNCTION_DIAG_BUFFER_POST;\r\nmpi_request->BufferType = diag_register->buffer_type;\r\nmpi_request->Flags = cpu_to_le32(diag_register->diagnostic_flags);\r\nmpi_request->BufferAddress = cpu_to_le64(request_data_dma);\r\nmpi_request->BufferLength = cpu_to_le32(request_data_sz);\r\nmpi_request->VF_ID = 0;\r\nmpi_request->VP_ID = 0;\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: diag_buffer(0x%p), "\r\n"dma(0x%llx), sz(%d)\n", ioc->name, __func__, request_data,\r\n(unsigned long long)request_data_dma,\r\nle32_to_cpu(mpi_request->BufferLength)));\r\nfor (i = 0; i < MPT2_PRODUCT_SPECIFIC_DWORDS; i++)\r\nmpi_request->ProductSpecific[i] =\r\ncpu_to_le32(ioc->product_specific[buffer_type][i]);\r\ninit_completion(&ioc->ctl_cmds.done);\r\nmpt2sas_base_put_smid_default(ioc, smid);\r\ntimeleft = wait_for_completion_timeout(&ioc->ctl_cmds.done,\r\nMPT2_IOCTL_DEFAULT_TIMEOUT*HZ);\r\nif (!(ioc->ctl_cmds.status & MPT2_CMD_COMPLETE)) {\r\nprintk(MPT2SAS_ERR_FMT "%s: timeout\n", ioc->name,\r\n__func__);\r\n_debug_dump_mf(mpi_request,\r\nsizeof(Mpi2DiagBufferPostRequest_t)/4);\r\nif (!(ioc->ctl_cmds.status & MPT2_CMD_RESET))\r\nissue_reset = 1;\r\ngoto issue_host_reset;\r\n}\r\nif ((ioc->ctl_cmds.status & MPT2_CMD_REPLY_VALID) == 0) {\r\nprintk(MPT2SAS_ERR_FMT "%s: no reply message\n",\r\nioc->name, __func__);\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nmpi_reply = ioc->ctl_cmds.reply;\r\nioc_status = le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK;\r\nif (ioc_status == MPI2_IOCSTATUS_SUCCESS) {\r\nioc->diag_buffer_status[buffer_type] |=\r\nMPT2_DIAG_BUFFER_IS_REGISTERED;\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: success\n",\r\nioc->name, __func__));\r\n} else {\r\nprintk(MPT2SAS_INFO_FMT "%s: ioc_status(0x%04x) "\r\n"log_info(0x%08x)\n", ioc->name, __func__,\r\nioc_status, le32_to_cpu(mpi_reply->IOCLogInfo));\r\nrc = -EFAULT;\r\n}\r\nissue_host_reset:\r\nif (issue_reset)\r\nmpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,\r\nFORCE_BIG_HAMMER);\r\nout:\r\nif (rc && request_data)\r\npci_free_consistent(ioc->pdev, request_data_sz,\r\nrequest_data, request_data_dma);\r\nioc->ctl_cmds.status = MPT2_CMD_NOT_USED;\r\nreturn rc;\r\n}\r\nvoid\r\nmpt2sas_enable_diag_buffer(struct MPT2SAS_ADAPTER *ioc, u8 bits_to_register)\r\n{\r\nstruct mpt2_diag_register diag_register;\r\nmemset(&diag_register, 0, sizeof(struct mpt2_diag_register));\r\nif (bits_to_register & 1) {\r\nprintk(MPT2SAS_INFO_FMT "registering trace buffer support\n",\r\nioc->name);\r\ndiag_register.buffer_type = MPI2_DIAG_BUF_TYPE_TRACE;\r\ndiag_register.requested_buffer_size = (1024 * 1024);\r\ndiag_register.unique_id = 0x7075900;\r\n_ctl_diag_register_2(ioc, &diag_register);\r\n}\r\nif (bits_to_register & 2) {\r\nprintk(MPT2SAS_INFO_FMT "registering snapshot buffer support\n",\r\nioc->name);\r\ndiag_register.buffer_type = MPI2_DIAG_BUF_TYPE_SNAPSHOT;\r\ndiag_register.requested_buffer_size = 2 * (1024 * 1024);\r\ndiag_register.unique_id = 0x7075901;\r\n_ctl_diag_register_2(ioc, &diag_register);\r\n}\r\nif (bits_to_register & 4) {\r\nprintk(MPT2SAS_INFO_FMT "registering extended buffer support\n",\r\nioc->name);\r\ndiag_register.buffer_type = MPI2_DIAG_BUF_TYPE_EXTENDED;\r\ndiag_register.requested_buffer_size = 2 * (1024 * 1024);\r\ndiag_register.unique_id = 0x7075901;\r\n_ctl_diag_register_2(ioc, &diag_register);\r\n}\r\n}\r\nstatic long\r\n_ctl_diag_register(struct MPT2SAS_ADAPTER *ioc, void __user *arg)\r\n{\r\nstruct mpt2_diag_register karg;\r\nlong rc;\r\nif (copy_from_user(&karg, arg, sizeof(karg))) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn -EFAULT;\r\n}\r\nrc = _ctl_diag_register_2(ioc, &karg);\r\nreturn rc;\r\n}\r\nstatic long\r\n_ctl_diag_unregister(struct MPT2SAS_ADAPTER *ioc, void __user *arg)\r\n{\r\nstruct mpt2_diag_unregister karg;\r\nvoid *request_data;\r\ndma_addr_t request_data_dma;\r\nu32 request_data_sz;\r\nu8 buffer_type;\r\nif (copy_from_user(&karg, arg, sizeof(karg))) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn -EFAULT;\r\n}\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,\r\n__func__));\r\nbuffer_type = karg.unique_id & 0x000000ff;\r\nif (!_ctl_diag_capability(ioc, buffer_type)) {\r\nprintk(MPT2SAS_ERR_FMT "%s: doesn't have capability for "\r\n"buffer_type(0x%02x)\n", ioc->name, __func__, buffer_type);\r\nreturn -EPERM;\r\n}\r\nif ((ioc->diag_buffer_status[buffer_type] &\r\nMPT2_DIAG_BUFFER_IS_REGISTERED) == 0) {\r\nprintk(MPT2SAS_ERR_FMT "%s: buffer_type(0x%02x) is not "\r\n"registered\n", ioc->name, __func__, buffer_type);\r\nreturn -EINVAL;\r\n}\r\nif ((ioc->diag_buffer_status[buffer_type] &\r\nMPT2_DIAG_BUFFER_IS_RELEASED) == 0) {\r\nprintk(MPT2SAS_ERR_FMT "%s: buffer_type(0x%02x) has not been "\r\n"released\n", ioc->name, __func__, buffer_type);\r\nreturn -EINVAL;\r\n}\r\nif (karg.unique_id != ioc->unique_id[buffer_type]) {\r\nprintk(MPT2SAS_ERR_FMT "%s: unique_id(0x%08x) is not "\r\n"registered\n", ioc->name, __func__, karg.unique_id);\r\nreturn -EINVAL;\r\n}\r\nrequest_data = ioc->diag_buffer[buffer_type];\r\nif (!request_data) {\r\nprintk(MPT2SAS_ERR_FMT "%s: doesn't have memory allocated for "\r\n"buffer_type(0x%02x)\n", ioc->name, __func__, buffer_type);\r\nreturn -ENOMEM;\r\n}\r\nrequest_data_sz = ioc->diag_buffer_sz[buffer_type];\r\nrequest_data_dma = ioc->diag_buffer_dma[buffer_type];\r\npci_free_consistent(ioc->pdev, request_data_sz,\r\nrequest_data, request_data_dma);\r\nioc->diag_buffer[buffer_type] = NULL;\r\nioc->diag_buffer_status[buffer_type] = 0;\r\nreturn 0;\r\n}\r\nstatic long\r\n_ctl_diag_query(struct MPT2SAS_ADAPTER *ioc, void __user *arg)\r\n{\r\nstruct mpt2_diag_query karg;\r\nvoid *request_data;\r\nint i;\r\nu8 buffer_type;\r\nif (copy_from_user(&karg, arg, sizeof(karg))) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn -EFAULT;\r\n}\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,\r\n__func__));\r\nkarg.application_flags = 0;\r\nbuffer_type = karg.buffer_type;\r\nif (!_ctl_diag_capability(ioc, buffer_type)) {\r\nprintk(MPT2SAS_ERR_FMT "%s: doesn't have capability for "\r\n"buffer_type(0x%02x)\n", ioc->name, __func__, buffer_type);\r\nreturn -EPERM;\r\n}\r\nif ((ioc->diag_buffer_status[buffer_type] &\r\nMPT2_DIAG_BUFFER_IS_REGISTERED) == 0) {\r\nprintk(MPT2SAS_ERR_FMT "%s: buffer_type(0x%02x) is not "\r\n"registered\n", ioc->name, __func__, buffer_type);\r\nreturn -EINVAL;\r\n}\r\nif (karg.unique_id & 0xffffff00) {\r\nif (karg.unique_id != ioc->unique_id[buffer_type]) {\r\nprintk(MPT2SAS_ERR_FMT "%s: unique_id(0x%08x) is not "\r\n"registered\n", ioc->name, __func__,\r\nkarg.unique_id);\r\nreturn -EINVAL;\r\n}\r\n}\r\nrequest_data = ioc->diag_buffer[buffer_type];\r\nif (!request_data) {\r\nprintk(MPT2SAS_ERR_FMT "%s: doesn't have buffer for "\r\n"buffer_type(0x%02x)\n", ioc->name, __func__, buffer_type);\r\nreturn -ENOMEM;\r\n}\r\nif (ioc->diag_buffer_status[buffer_type] & MPT2_DIAG_BUFFER_IS_RELEASED)\r\nkarg.application_flags = (MPT2_APP_FLAGS_APP_OWNED |\r\nMPT2_APP_FLAGS_BUFFER_VALID);\r\nelse\r\nkarg.application_flags = (MPT2_APP_FLAGS_APP_OWNED |\r\nMPT2_APP_FLAGS_BUFFER_VALID |\r\nMPT2_APP_FLAGS_FW_BUFFER_ACCESS);\r\nfor (i = 0; i < MPT2_PRODUCT_SPECIFIC_DWORDS; i++)\r\nkarg.product_specific[i] =\r\nioc->product_specific[buffer_type][i];\r\nkarg.total_buffer_size = ioc->diag_buffer_sz[buffer_type];\r\nkarg.driver_added_buffer_size = 0;\r\nkarg.unique_id = ioc->unique_id[buffer_type];\r\nkarg.diagnostic_flags = ioc->diagnostic_flags[buffer_type];\r\nif (copy_to_user(arg, &karg, sizeof(struct mpt2_diag_query))) {\r\nprintk(MPT2SAS_ERR_FMT "%s: unable to write mpt2_diag_query "\r\n"data @ %p\n", ioc->name, __func__, arg);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\n_ctl_send_release(struct MPT2SAS_ADAPTER *ioc, u8 buffer_type, u8 *issue_reset)\r\n{\r\nMpi2DiagReleaseRequest_t *mpi_request;\r\nMpi2DiagReleaseReply_t *mpi_reply;\r\nu16 smid;\r\nu16 ioc_status;\r\nu32 ioc_state;\r\nint rc;\r\nunsigned long timeleft;\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,\r\n__func__));\r\nrc = 0;\r\n*issue_reset = 0;\r\nioc_state = mpt2sas_base_get_iocstate(ioc, 1);\r\nif (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "\r\n"skipping due to FAULT state\n", ioc->name,\r\n__func__));\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nif (ioc->ctl_cmds.status != MPT2_CMD_NOT_USED) {\r\nprintk(MPT2SAS_ERR_FMT "%s: ctl_cmd in use\n",\r\nioc->name, __func__);\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nsmid = mpt2sas_base_get_smid(ioc, ioc->ctl_cb_idx);\r\nif (!smid) {\r\nprintk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",\r\nioc->name, __func__);\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nioc->ctl_cmds.status = MPT2_CMD_PENDING;\r\nmemset(ioc->ctl_cmds.reply, 0, ioc->reply_sz);\r\nmpi_request = mpt2sas_base_get_msg_frame(ioc, smid);\r\nioc->ctl_cmds.smid = smid;\r\nmpi_request->Function = MPI2_FUNCTION_DIAG_RELEASE;\r\nmpi_request->BufferType = buffer_type;\r\nmpi_request->VF_ID = 0;\r\nmpi_request->VP_ID = 0;\r\ninit_completion(&ioc->ctl_cmds.done);\r\nmpt2sas_base_put_smid_default(ioc, smid);\r\ntimeleft = wait_for_completion_timeout(&ioc->ctl_cmds.done,\r\nMPT2_IOCTL_DEFAULT_TIMEOUT*HZ);\r\nif (!(ioc->ctl_cmds.status & MPT2_CMD_COMPLETE)) {\r\nprintk(MPT2SAS_ERR_FMT "%s: timeout\n", ioc->name,\r\n__func__);\r\n_debug_dump_mf(mpi_request,\r\nsizeof(Mpi2DiagReleaseRequest_t)/4);\r\nif (!(ioc->ctl_cmds.status & MPT2_CMD_RESET))\r\n*issue_reset = 1;\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nif ((ioc->ctl_cmds.status & MPT2_CMD_REPLY_VALID) == 0) {\r\nprintk(MPT2SAS_ERR_FMT "%s: no reply message\n",\r\nioc->name, __func__);\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nmpi_reply = ioc->ctl_cmds.reply;\r\nioc_status = le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK;\r\nif (ioc_status == MPI2_IOCSTATUS_SUCCESS) {\r\nioc->diag_buffer_status[buffer_type] |=\r\nMPT2_DIAG_BUFFER_IS_RELEASED;\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: success\n",\r\nioc->name, __func__));\r\n} else {\r\nprintk(MPT2SAS_INFO_FMT "%s: ioc_status(0x%04x) "\r\n"log_info(0x%08x)\n", ioc->name, __func__,\r\nioc_status, le32_to_cpu(mpi_reply->IOCLogInfo));\r\nrc = -EFAULT;\r\n}\r\nout:\r\nioc->ctl_cmds.status = MPT2_CMD_NOT_USED;\r\nreturn rc;\r\n}\r\nstatic long\r\n_ctl_diag_release(struct MPT2SAS_ADAPTER *ioc, void __user *arg)\r\n{\r\nstruct mpt2_diag_release karg;\r\nvoid *request_data;\r\nint rc;\r\nu8 buffer_type;\r\nu8 issue_reset = 0;\r\nif (copy_from_user(&karg, arg, sizeof(karg))) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn -EFAULT;\r\n}\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,\r\n__func__));\r\nbuffer_type = karg.unique_id & 0x000000ff;\r\nif (!_ctl_diag_capability(ioc, buffer_type)) {\r\nprintk(MPT2SAS_ERR_FMT "%s: doesn't have capability for "\r\n"buffer_type(0x%02x)\n", ioc->name, __func__, buffer_type);\r\nreturn -EPERM;\r\n}\r\nif ((ioc->diag_buffer_status[buffer_type] &\r\nMPT2_DIAG_BUFFER_IS_REGISTERED) == 0) {\r\nprintk(MPT2SAS_ERR_FMT "%s: buffer_type(0x%02x) is not "\r\n"registered\n", ioc->name, __func__, buffer_type);\r\nreturn -EINVAL;\r\n}\r\nif (karg.unique_id != ioc->unique_id[buffer_type]) {\r\nprintk(MPT2SAS_ERR_FMT "%s: unique_id(0x%08x) is not "\r\n"registered\n", ioc->name, __func__, karg.unique_id);\r\nreturn -EINVAL;\r\n}\r\nif (ioc->diag_buffer_status[buffer_type] &\r\nMPT2_DIAG_BUFFER_IS_RELEASED) {\r\nprintk(MPT2SAS_ERR_FMT "%s: buffer_type(0x%02x) "\r\n"is already released\n", ioc->name, __func__,\r\nbuffer_type);\r\nreturn 0;\r\n}\r\nrequest_data = ioc->diag_buffer[buffer_type];\r\nif (!request_data) {\r\nprintk(MPT2SAS_ERR_FMT "%s: doesn't have memory allocated for "\r\n"buffer_type(0x%02x)\n", ioc->name, __func__, buffer_type);\r\nreturn -ENOMEM;\r\n}\r\nif ((ioc->diag_buffer_status[buffer_type] &\r\nMPT2_DIAG_BUFFER_IS_DIAG_RESET)) {\r\nioc->diag_buffer_status[buffer_type] |=\r\nMPT2_DIAG_BUFFER_IS_RELEASED;\r\nioc->diag_buffer_status[buffer_type] &=\r\n~MPT2_DIAG_BUFFER_IS_DIAG_RESET;\r\nprintk(MPT2SAS_ERR_FMT "%s: buffer_type(0x%02x) "\r\n"was released due to host reset\n", ioc->name, __func__,\r\nbuffer_type);\r\nreturn 0;\r\n}\r\nrc = _ctl_send_release(ioc, buffer_type, &issue_reset);\r\nif (issue_reset)\r\nmpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,\r\nFORCE_BIG_HAMMER);\r\nreturn rc;\r\n}\r\nstatic long\r\n_ctl_diag_read_buffer(struct MPT2SAS_ADAPTER *ioc, void __user *arg)\r\n{\r\nstruct mpt2_diag_read_buffer karg;\r\nstruct mpt2_diag_read_buffer __user *uarg = arg;\r\nvoid *request_data, *diag_data;\r\nMpi2DiagBufferPostRequest_t *mpi_request;\r\nMpi2DiagBufferPostReply_t *mpi_reply;\r\nint rc, i;\r\nu8 buffer_type;\r\nunsigned long timeleft, request_size, copy_size;\r\nu16 smid;\r\nu16 ioc_status;\r\nu8 issue_reset = 0;\r\nif (copy_from_user(&karg, arg, sizeof(karg))) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn -EFAULT;\r\n}\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s\n", ioc->name,\r\n__func__));\r\nbuffer_type = karg.unique_id & 0x000000ff;\r\nif (!_ctl_diag_capability(ioc, buffer_type)) {\r\nprintk(MPT2SAS_ERR_FMT "%s: doesn't have capability for "\r\n"buffer_type(0x%02x)\n", ioc->name, __func__, buffer_type);\r\nreturn -EPERM;\r\n}\r\nif (karg.unique_id != ioc->unique_id[buffer_type]) {\r\nprintk(MPT2SAS_ERR_FMT "%s: unique_id(0x%08x) is not "\r\n"registered\n", ioc->name, __func__, karg.unique_id);\r\nreturn -EINVAL;\r\n}\r\nrequest_data = ioc->diag_buffer[buffer_type];\r\nif (!request_data) {\r\nprintk(MPT2SAS_ERR_FMT "%s: doesn't have buffer for "\r\n"buffer_type(0x%02x)\n", ioc->name, __func__, buffer_type);\r\nreturn -ENOMEM;\r\n}\r\nrequest_size = ioc->diag_buffer_sz[buffer_type];\r\nif ((karg.starting_offset % 4) || (karg.bytes_to_read % 4)) {\r\nprintk(MPT2SAS_ERR_FMT "%s: either the starting_offset "\r\n"or bytes_to_read are not 4 byte aligned\n", ioc->name,\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nif (karg.starting_offset > request_size)\r\nreturn -EINVAL;\r\ndiag_data = (void *)(request_data + karg.starting_offset);\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: diag_buffer(%p), "\r\n"offset(%d), sz(%d)\n", ioc->name, __func__,\r\ndiag_data, karg.starting_offset, karg.bytes_to_read));\r\nif ((diag_data + karg.bytes_to_read < diag_data) ||\r\n(diag_data + karg.bytes_to_read > request_data + request_size))\r\ncopy_size = request_size - karg.starting_offset;\r\nelse\r\ncopy_size = karg.bytes_to_read;\r\nif (copy_to_user((void __user *)uarg->diagnostic_data,\r\ndiag_data, copy_size)) {\r\nprintk(MPT2SAS_ERR_FMT "%s: Unable to write "\r\n"mpt_diag_read_buffer_t data @ %p\n", ioc->name,\r\n__func__, diag_data);\r\nreturn -EFAULT;\r\n}\r\nif ((karg.flags & MPT2_FLAGS_REREGISTER) == 0)\r\nreturn 0;\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: Reregister "\r\n"buffer_type(0x%02x)\n", ioc->name, __func__, buffer_type));\r\nif ((ioc->diag_buffer_status[buffer_type] &\r\nMPT2_DIAG_BUFFER_IS_RELEASED) == 0) {\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: "\r\n"buffer_type(0x%02x) is still registered\n", ioc->name,\r\n__func__, buffer_type));\r\nreturn 0;\r\n}\r\nif (ioc->ctl_cmds.status != MPT2_CMD_NOT_USED) {\r\nprintk(MPT2SAS_ERR_FMT "%s: ctl_cmd in use\n",\r\nioc->name, __func__);\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nsmid = mpt2sas_base_get_smid(ioc, ioc->ctl_cb_idx);\r\nif (!smid) {\r\nprintk(MPT2SAS_ERR_FMT "%s: failed obtaining a smid\n",\r\nioc->name, __func__);\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nrc = 0;\r\nioc->ctl_cmds.status = MPT2_CMD_PENDING;\r\nmemset(ioc->ctl_cmds.reply, 0, ioc->reply_sz);\r\nmpi_request = mpt2sas_base_get_msg_frame(ioc, smid);\r\nioc->ctl_cmds.smid = smid;\r\nmpi_request->Function = MPI2_FUNCTION_DIAG_BUFFER_POST;\r\nmpi_request->BufferType = buffer_type;\r\nmpi_request->BufferLength =\r\ncpu_to_le32(ioc->diag_buffer_sz[buffer_type]);\r\nmpi_request->BufferAddress =\r\ncpu_to_le64(ioc->diag_buffer_dma[buffer_type]);\r\nfor (i = 0; i < MPT2_PRODUCT_SPECIFIC_DWORDS; i++)\r\nmpi_request->ProductSpecific[i] =\r\ncpu_to_le32(ioc->product_specific[buffer_type][i]);\r\nmpi_request->VF_ID = 0;\r\nmpi_request->VP_ID = 0;\r\ninit_completion(&ioc->ctl_cmds.done);\r\nmpt2sas_base_put_smid_default(ioc, smid);\r\ntimeleft = wait_for_completion_timeout(&ioc->ctl_cmds.done,\r\nMPT2_IOCTL_DEFAULT_TIMEOUT*HZ);\r\nif (!(ioc->ctl_cmds.status & MPT2_CMD_COMPLETE)) {\r\nprintk(MPT2SAS_ERR_FMT "%s: timeout\n", ioc->name,\r\n__func__);\r\n_debug_dump_mf(mpi_request,\r\nsizeof(Mpi2DiagBufferPostRequest_t)/4);\r\nif (!(ioc->ctl_cmds.status & MPT2_CMD_RESET))\r\nissue_reset = 1;\r\ngoto issue_host_reset;\r\n}\r\nif ((ioc->ctl_cmds.status & MPT2_CMD_REPLY_VALID) == 0) {\r\nprintk(MPT2SAS_ERR_FMT "%s: no reply message\n",\r\nioc->name, __func__);\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nmpi_reply = ioc->ctl_cmds.reply;\r\nioc_status = le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK;\r\nif (ioc_status == MPI2_IOCSTATUS_SUCCESS) {\r\nioc->diag_buffer_status[buffer_type] |=\r\nMPT2_DIAG_BUFFER_IS_REGISTERED;\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT "%s: success\n",\r\nioc->name, __func__));\r\n} else {\r\nprintk(MPT2SAS_INFO_FMT "%s: ioc_status(0x%04x) "\r\n"log_info(0x%08x)\n", ioc->name, __func__,\r\nioc_status, le32_to_cpu(mpi_reply->IOCLogInfo));\r\nrc = -EFAULT;\r\n}\r\nissue_host_reset:\r\nif (issue_reset)\r\nmpt2sas_base_hard_reset_handler(ioc, CAN_SLEEP,\r\nFORCE_BIG_HAMMER);\r\nout:\r\nioc->ctl_cmds.status = MPT2_CMD_NOT_USED;\r\nreturn rc;\r\n}\r\nstatic long\r\n_ctl_compat_mpt_command(struct MPT2SAS_ADAPTER *ioc, unsigned cmd,\r\nvoid __user *arg)\r\n{\r\nstruct mpt2_ioctl_command32 karg32;\r\nstruct mpt2_ioctl_command32 __user *uarg;\r\nstruct mpt2_ioctl_command karg;\r\nif (_IOC_SIZE(cmd) != sizeof(struct mpt2_ioctl_command32))\r\nreturn -EINVAL;\r\nuarg = (struct mpt2_ioctl_command32 __user *) arg;\r\nif (copy_from_user(&karg32, (char __user *)arg, sizeof(karg32))) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn -EFAULT;\r\n}\r\nmemset(&karg, 0, sizeof(struct mpt2_ioctl_command));\r\nkarg.hdr.ioc_number = karg32.hdr.ioc_number;\r\nkarg.hdr.port_number = karg32.hdr.port_number;\r\nkarg.hdr.max_data_size = karg32.hdr.max_data_size;\r\nkarg.timeout = karg32.timeout;\r\nkarg.max_reply_bytes = karg32.max_reply_bytes;\r\nkarg.data_in_size = karg32.data_in_size;\r\nkarg.data_out_size = karg32.data_out_size;\r\nkarg.max_sense_bytes = karg32.max_sense_bytes;\r\nkarg.data_sge_offset = karg32.data_sge_offset;\r\nkarg.reply_frame_buf_ptr = compat_ptr(karg32.reply_frame_buf_ptr);\r\nkarg.data_in_buf_ptr = compat_ptr(karg32.data_in_buf_ptr);\r\nkarg.data_out_buf_ptr = compat_ptr(karg32.data_out_buf_ptr);\r\nkarg.sense_data_ptr = compat_ptr(karg32.sense_data_ptr);\r\nreturn _ctl_do_mpt_command(ioc, karg, &uarg->mf);\r\n}\r\nstatic long\r\n_ctl_ioctl_main(struct file *file, unsigned int cmd, void __user *arg,\r\nu8 compat)\r\n{\r\nstruct MPT2SAS_ADAPTER *ioc;\r\nstruct mpt2_ioctl_header ioctl_header;\r\nenum block_state state;\r\nlong ret = -EINVAL;\r\nif (copy_from_user(&ioctl_header, (char __user *)arg,\r\nsizeof(struct mpt2_ioctl_header))) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n",\r\n__FILE__, __LINE__, __func__);\r\nreturn -EFAULT;\r\n}\r\nif (_ctl_verify_adapter(ioctl_header.ioc_number, &ioc) == -1 || !ioc)\r\nreturn -ENODEV;\r\nif (ioc->shost_recovery || ioc->pci_error_recovery ||\r\nioc->is_driver_loading)\r\nreturn -EAGAIN;\r\nstate = (file->f_flags & O_NONBLOCK) ? NON_BLOCKING : BLOCKING;\r\nif (state == NON_BLOCKING) {\r\nif (!mutex_trylock(&ioc->ctl_cmds.mutex))\r\nreturn -EAGAIN;\r\n} else if (mutex_lock_interruptible(&ioc->ctl_cmds.mutex)) {\r\nreturn -ERESTARTSYS;\r\n}\r\nswitch (cmd) {\r\ncase MPT2IOCINFO:\r\nif (_IOC_SIZE(cmd) == sizeof(struct mpt2_ioctl_iocinfo))\r\nret = _ctl_getiocinfo(ioc, arg);\r\nbreak;\r\n#ifdef CONFIG_COMPAT\r\ncase MPT2COMMAND32:\r\n#endif\r\ncase MPT2COMMAND:\r\n{\r\nstruct mpt2_ioctl_command __user *uarg;\r\nstruct mpt2_ioctl_command karg;\r\n#ifdef CONFIG_COMPAT\r\nif (compat) {\r\nret = _ctl_compat_mpt_command(ioc, cmd, arg);\r\nbreak;\r\n}\r\n#endif\r\nif (copy_from_user(&karg, arg, sizeof(karg))) {\r\nprintk(KERN_ERR "failure at %s:%d/%s()!\n",\r\n__FILE__, __LINE__, __func__);\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nif (_IOC_SIZE(cmd) == sizeof(struct mpt2_ioctl_command)) {\r\nuarg = arg;\r\nret = _ctl_do_mpt_command(ioc, karg, &uarg->mf);\r\n}\r\nbreak;\r\n}\r\ncase MPT2EVENTQUERY:\r\nif (_IOC_SIZE(cmd) == sizeof(struct mpt2_ioctl_eventquery))\r\nret = _ctl_eventquery(ioc, arg);\r\nbreak;\r\ncase MPT2EVENTENABLE:\r\nif (_IOC_SIZE(cmd) == sizeof(struct mpt2_ioctl_eventenable))\r\nret = _ctl_eventenable(ioc, arg);\r\nbreak;\r\ncase MPT2EVENTREPORT:\r\nret = _ctl_eventreport(ioc, arg);\r\nbreak;\r\ncase MPT2HARDRESET:\r\nif (_IOC_SIZE(cmd) == sizeof(struct mpt2_ioctl_diag_reset))\r\nret = _ctl_do_reset(ioc, arg);\r\nbreak;\r\ncase MPT2BTDHMAPPING:\r\nif (_IOC_SIZE(cmd) == sizeof(struct mpt2_ioctl_btdh_mapping))\r\nret = _ctl_btdh_mapping(ioc, arg);\r\nbreak;\r\ncase MPT2DIAGREGISTER:\r\nif (_IOC_SIZE(cmd) == sizeof(struct mpt2_diag_register))\r\nret = _ctl_diag_register(ioc, arg);\r\nbreak;\r\ncase MPT2DIAGUNREGISTER:\r\nif (_IOC_SIZE(cmd) == sizeof(struct mpt2_diag_unregister))\r\nret = _ctl_diag_unregister(ioc, arg);\r\nbreak;\r\ncase MPT2DIAGQUERY:\r\nif (_IOC_SIZE(cmd) == sizeof(struct mpt2_diag_query))\r\nret = _ctl_diag_query(ioc, arg);\r\nbreak;\r\ncase MPT2DIAGRELEASE:\r\nif (_IOC_SIZE(cmd) == sizeof(struct mpt2_diag_release))\r\nret = _ctl_diag_release(ioc, arg);\r\nbreak;\r\ncase MPT2DIAGREADBUFFER:\r\nif (_IOC_SIZE(cmd) == sizeof(struct mpt2_diag_read_buffer))\r\nret = _ctl_diag_read_buffer(ioc, arg);\r\nbreak;\r\ndefault:\r\ndctlprintk(ioc, printk(MPT2SAS_INFO_FMT\r\n"unsupported ioctl opcode(0x%08x)\n", ioc->name, cmd));\r\nbreak;\r\n}\r\nmutex_unlock(&ioc->ctl_cmds.mutex);\r\nreturn ret;\r\n}\r\nstatic long\r\n_ctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nlong ret;\r\nret = _ctl_ioctl_main(file, cmd, (void __user *)arg, 0);\r\nreturn ret;\r\n}\r\nstatic long\r\n_ctl_ioctl_compat(struct file *file, unsigned cmd, unsigned long arg)\r\n{\r\nlong ret;\r\nret = _ctl_ioctl_main(file, cmd, (void __user *)arg, 1);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\n_ctl_version_fw_show(struct device *cdev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nreturn snprintf(buf, PAGE_SIZE, "%02d.%02d.%02d.%02d\n",\r\n(ioc->facts.FWVersion.Word & 0xFF000000) >> 24,\r\n(ioc->facts.FWVersion.Word & 0x00FF0000) >> 16,\r\n(ioc->facts.FWVersion.Word & 0x0000FF00) >> 8,\r\nioc->facts.FWVersion.Word & 0x000000FF);\r\n}\r\nstatic ssize_t\r\n_ctl_version_bios_show(struct device *cdev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nu32 version = le32_to_cpu(ioc->bios_pg3.BiosVersion);\r\nreturn snprintf(buf, PAGE_SIZE, "%02d.%02d.%02d.%02d\n",\r\n(version & 0xFF000000) >> 24,\r\n(version & 0x00FF0000) >> 16,\r\n(version & 0x0000FF00) >> 8,\r\nversion & 0x000000FF);\r\n}\r\nstatic ssize_t\r\n_ctl_version_mpi_show(struct device *cdev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nreturn snprintf(buf, PAGE_SIZE, "%03x.%02x\n",\r\nioc->facts.MsgVersion, ioc->facts.HeaderVersion >> 8);\r\n}\r\nstatic ssize_t\r\n_ctl_version_product_show(struct device *cdev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nreturn snprintf(buf, 16, "%s\n", ioc->manu_pg0.ChipName);\r\n}\r\nstatic ssize_t\r\n_ctl_version_nvdata_persistent_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nreturn snprintf(buf, PAGE_SIZE, "%08xh\n",\r\nle32_to_cpu(ioc->iounit_pg0.NvdataVersionPersistent.Word));\r\n}\r\nstatic ssize_t\r\n_ctl_version_nvdata_default_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nreturn snprintf(buf, PAGE_SIZE, "%08xh\n",\r\nle32_to_cpu(ioc->iounit_pg0.NvdataVersionDefault.Word));\r\n}\r\nstatic ssize_t\r\n_ctl_board_name_show(struct device *cdev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nreturn snprintf(buf, 16, "%s\n", ioc->manu_pg0.BoardName);\r\n}\r\nstatic ssize_t\r\n_ctl_board_assembly_show(struct device *cdev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nreturn snprintf(buf, 16, "%s\n", ioc->manu_pg0.BoardAssembly);\r\n}\r\nstatic ssize_t\r\n_ctl_board_tracer_show(struct device *cdev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nreturn snprintf(buf, 16, "%s\n", ioc->manu_pg0.BoardTracerNumber);\r\n}\r\nstatic ssize_t\r\n_ctl_io_delay_show(struct device *cdev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nreturn snprintf(buf, PAGE_SIZE, "%02d\n", ioc->io_missing_delay);\r\n}\r\nstatic ssize_t\r\n_ctl_device_delay_show(struct device *cdev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nreturn snprintf(buf, PAGE_SIZE, "%02d\n", ioc->device_missing_delay);\r\n}\r\nstatic ssize_t\r\n_ctl_fw_queue_depth_show(struct device *cdev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nreturn snprintf(buf, PAGE_SIZE, "%02d\n", ioc->facts.RequestCredit);\r\n}\r\nstatic ssize_t\r\n_ctl_host_sas_address_show(struct device *cdev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nreturn snprintf(buf, PAGE_SIZE, "0x%016llx\n",\r\n(unsigned long long)ioc->sas_hba.sas_address);\r\n}\r\nstatic ssize_t\r\n_ctl_logging_level_show(struct device *cdev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nreturn snprintf(buf, PAGE_SIZE, "%08xh\n", ioc->logging_level);\r\n}\r\nstatic ssize_t\r\n_ctl_logging_level_store(struct device *cdev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nint val = 0;\r\nif (sscanf(buf, "%x", &val) != 1)\r\nreturn -EINVAL;\r\nioc->logging_level = val;\r\nprintk(MPT2SAS_INFO_FMT "logging_level=%08xh\n", ioc->name,\r\nioc->logging_level);\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t\r\n_ctl_fwfault_debug_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ioc->fwfault_debug);\r\n}\r\nstatic ssize_t\r\n_ctl_fwfault_debug_store(struct device *cdev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nint val = 0;\r\nif (sscanf(buf, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nioc->fwfault_debug = val;\r\nprintk(MPT2SAS_INFO_FMT "fwfault_debug=%d\n", ioc->name,\r\nioc->fwfault_debug);\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t\r\n_ctl_ioc_reset_count_show(struct device *cdev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nreturn snprintf(buf, PAGE_SIZE, "%08d\n", ioc->ioc_reset_count);\r\n}\r\nstatic ssize_t\r\n_ctl_ioc_reply_queue_count_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu8 reply_queue_count;\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nif ((ioc->facts.IOCCapabilities &\r\nMPI2_IOCFACTS_CAPABILITY_MSI_X_INDEX) && ioc->msix_enable)\r\nreply_queue_count = ioc->reply_queue_count;\r\nelse\r\nreply_queue_count = 1;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", reply_queue_count);\r\n}\r\nstatic ssize_t\r\n_ctl_BRM_status_show(struct device *cdev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nMpi2IOUnitPage3_t *io_unit_pg3 = NULL;\r\nMpi2ConfigReply_t mpi_reply;\r\nu16 backup_rail_monitor_status = 0;\r\nu16 ioc_status;\r\nint sz;\r\nssize_t rc = 0;\r\nif (!ioc->is_warpdrive) {\r\nprintk(MPT2SAS_ERR_FMT "%s: BRM attribute is only for"\\r\n"warpdrive\n", ioc->name, __func__);\r\ngoto out;\r\n}\r\nsz = offsetof(Mpi2IOUnitPage3_t, GPIOVal) + (sizeof(u16) * 36);\r\nio_unit_pg3 = kzalloc(sz, GFP_KERNEL);\r\nif (!io_unit_pg3) {\r\nprintk(MPT2SAS_ERR_FMT "%s: failed allocating memory"\\r\n"for iounit_pg3: (%d) bytes\n", ioc->name, __func__, sz);\r\ngoto out;\r\n}\r\nif (mpt2sas_config_get_iounit_pg3(ioc, &mpi_reply, io_unit_pg3, sz) !=\r\n0) {\r\nprintk(MPT2SAS_ERR_FMT\r\n"%s: failed reading iounit_pg3\n", ioc->name,\r\n__func__);\r\ngoto out;\r\n}\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\nprintk(MPT2SAS_ERR_FMT "%s: iounit_pg3 failed with"\\r\n"ioc_status(0x%04x)\n", ioc->name, __func__, ioc_status);\r\ngoto out;\r\n}\r\nif (io_unit_pg3->GPIOCount < 25) {\r\nprintk(MPT2SAS_ERR_FMT "%s: iounit_pg3->GPIOCount less than"\\r\n"25 entries, detected (%d) entries\n", ioc->name, __func__,\r\nio_unit_pg3->GPIOCount);\r\ngoto out;\r\n}\r\nbackup_rail_monitor_status = le16_to_cpu(io_unit_pg3->GPIOVal[24]);\r\nrc = snprintf(buf, PAGE_SIZE, "%d\n", (backup_rail_monitor_status & 1));\r\nout:\r\nkfree(io_unit_pg3);\r\nreturn rc;\r\n}\r\nstatic ssize_t\r\n_ctl_host_trace_buffer_size_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nu32 size = 0;\r\nstruct DIAG_BUFFER_START *request_data;\r\nif (!ioc->diag_buffer[MPI2_DIAG_BUF_TYPE_TRACE]) {\r\nprintk(MPT2SAS_ERR_FMT "%s: host_trace_buffer is not "\r\n"registered\n", ioc->name, __func__);\r\nreturn 0;\r\n}\r\nif ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\r\nMPT2_DIAG_BUFFER_IS_REGISTERED) == 0) {\r\nprintk(MPT2SAS_ERR_FMT "%s: host_trace_buffer is not "\r\n"registered\n", ioc->name, __func__);\r\nreturn 0;\r\n}\r\nrequest_data = (struct DIAG_BUFFER_START *)\r\nioc->diag_buffer[MPI2_DIAG_BUF_TYPE_TRACE];\r\nif ((le32_to_cpu(request_data->DiagVersion) == 0x00000000 ||\r\nle32_to_cpu(request_data->DiagVersion) == 0x01000000) &&\r\nle32_to_cpu(request_data->Reserved3) == 0x4742444c)\r\nsize = le32_to_cpu(request_data->Size);\r\nioc->ring_buffer_sz = size;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", size);\r\n}\r\nstatic ssize_t\r\n_ctl_host_trace_buffer_show(struct device *cdev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nvoid *request_data;\r\nu32 size;\r\nif (!ioc->diag_buffer[MPI2_DIAG_BUF_TYPE_TRACE]) {\r\nprintk(MPT2SAS_ERR_FMT "%s: host_trace_buffer is not "\r\n"registered\n", ioc->name, __func__);\r\nreturn 0;\r\n}\r\nif ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\r\nMPT2_DIAG_BUFFER_IS_REGISTERED) == 0) {\r\nprintk(MPT2SAS_ERR_FMT "%s: host_trace_buffer is not "\r\n"registered\n", ioc->name, __func__);\r\nreturn 0;\r\n}\r\nif (ioc->ring_buffer_offset > ioc->ring_buffer_sz)\r\nreturn 0;\r\nsize = ioc->ring_buffer_sz - ioc->ring_buffer_offset;\r\nsize = (size > PAGE_SIZE) ? PAGE_SIZE : size;\r\nrequest_data = ioc->diag_buffer[0] + ioc->ring_buffer_offset;\r\nmemcpy(buf, request_data, size);\r\nreturn size;\r\n}\r\nstatic ssize_t\r\n_ctl_host_trace_buffer_store(struct device *cdev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nint val = 0;\r\nif (sscanf(buf, "%d", &val) != 1)\r\nreturn -EINVAL;\r\nioc->ring_buffer_offset = val;\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t\r\n_ctl_host_trace_buffer_enable_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nif ((!ioc->diag_buffer[MPI2_DIAG_BUF_TYPE_TRACE]) ||\r\n((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\r\nMPT2_DIAG_BUFFER_IS_REGISTERED) == 0))\r\nreturn snprintf(buf, PAGE_SIZE, "off\n");\r\nelse if ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\r\nMPT2_DIAG_BUFFER_IS_RELEASED))\r\nreturn snprintf(buf, PAGE_SIZE, "release\n");\r\nelse\r\nreturn snprintf(buf, PAGE_SIZE, "post\n");\r\n}\r\nstatic ssize_t\r\n_ctl_host_trace_buffer_enable_store(struct device *cdev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct MPT2SAS_ADAPTER *ioc = shost_priv(shost);\r\nchar str[10] = "";\r\nstruct mpt2_diag_register diag_register;\r\nu8 issue_reset = 0;\r\nif (sscanf(buf, "%9s", str) != 1)\r\nreturn -EINVAL;\r\nif (!strcmp(str, "post")) {\r\nif ((ioc->diag_buffer[MPI2_DIAG_BUF_TYPE_TRACE]) &&\r\n(ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\r\nMPT2_DIAG_BUFFER_IS_REGISTERED) &&\r\n((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\r\nMPT2_DIAG_BUFFER_IS_RELEASED) == 0))\r\ngoto out;\r\nmemset(&diag_register, 0, sizeof(struct mpt2_diag_register));\r\nprintk(MPT2SAS_INFO_FMT "posting host trace buffers\n",\r\nioc->name);\r\ndiag_register.buffer_type = MPI2_DIAG_BUF_TYPE_TRACE;\r\ndiag_register.requested_buffer_size = (1024 * 1024);\r\ndiag_register.unique_id = 0x7075900;\r\nioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] = 0;\r\n_ctl_diag_register_2(ioc, &diag_register);\r\n} else if (!strcmp(str, "release")) {\r\nif (!ioc->diag_buffer[MPI2_DIAG_BUF_TYPE_TRACE])\r\ngoto out;\r\nif ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\r\nMPT2_DIAG_BUFFER_IS_REGISTERED) == 0)\r\ngoto out;\r\nif ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\r\nMPT2_DIAG_BUFFER_IS_RELEASED))\r\ngoto out;\r\nprintk(MPT2SAS_INFO_FMT "releasing host trace buffer\n",\r\nioc->name);\r\n_ctl_send_release(ioc, MPI2_DIAG_BUF_TYPE_TRACE, &issue_reset);\r\n}\r\nout:\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t\r\n_ctl_device_sas_address_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nstruct MPT2SAS_DEVICE *sas_device_priv_data = sdev->hostdata;\r\nreturn snprintf(buf, PAGE_SIZE, "0x%016llx\n",\r\n(unsigned long long)sas_device_priv_data->sas_target->sas_address);\r\n}\r\nstatic ssize_t\r\n_ctl_device_handle_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nstruct MPT2SAS_DEVICE *sas_device_priv_data = sdev->hostdata;\r\nreturn snprintf(buf, PAGE_SIZE, "0x%04x\n",\r\nsas_device_priv_data->sas_target->handle);\r\n}\r\nvoid\r\nmpt2sas_ctl_init(void)\r\n{\r\nasync_queue = NULL;\r\nif (misc_register(&ctl_dev) < 0)\r\nprintk(KERN_ERR "%s can't register misc device [minor=%d]\n",\r\nMPT2SAS_DRIVER_NAME, MPT2SAS_MINOR);\r\ninit_waitqueue_head(&ctl_poll_wait);\r\n}\r\nvoid\r\nmpt2sas_ctl_exit(void)\r\n{\r\nstruct MPT2SAS_ADAPTER *ioc;\r\nint i;\r\nlist_for_each_entry(ioc, &mpt2sas_ioc_list, list) {\r\nfor (i = 0; i < MPI2_DIAG_BUF_TYPE_COUNT; i++) {\r\nif (!ioc->diag_buffer[i])\r\ncontinue;\r\npci_free_consistent(ioc->pdev, ioc->diag_buffer_sz[i],\r\nioc->diag_buffer[i], ioc->diag_buffer_dma[i]);\r\nioc->diag_buffer[i] = NULL;\r\nioc->diag_buffer_status[i] = 0;\r\n}\r\nkfree(ioc->event_log);\r\n}\r\nmisc_deregister(&ctl_dev);\r\n}
