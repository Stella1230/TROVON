static struct proc_dir_entry *\r\ncreateProcDir(const char *name, struct proc_dir_entry *parent)\r\n{\r\nstruct proc_dir_entry *p = proc_mkdir_mode(name, S_IFDIR, parent);\r\nif (p == NULL)\r\nERRDRV("failed to create /proc directory %s", name);\r\nreturn p;\r\n}\r\nstatic struct proc_dir_entry *\r\ncreateProcFile(const char *name, struct proc_dir_entry *parent,\r\nconst struct file_operations *fops, void *data)\r\n{\r\nstruct proc_dir_entry *p = proc_create_data(name, 0, parent,\r\nfops, data);\r\nif (p == NULL)\r\nERRDRV("failed to create /proc file %s", name);\r\nreturn p;\r\n}\r\nstatic int proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, seq_show, PDE_DATA(inode));\r\n}\r\nMYPROCTYPE *visor_proc_CreateType(struct proc_dir_entry *procDirRoot,\r\nconst char **name,\r\nconst char **propertyNames,\r\nvoid (*show_property)(struct seq_file *,\r\nvoid *, int))\r\n{\r\nint i = 0;\r\nMYPROCTYPE *rc = NULL, *type = NULL;\r\nstruct proc_dir_entry *parent = NULL;\r\nif (procDirRoot == NULL) {\r\nERRDRV("procDirRoot cannot be NULL!\n");\r\ngoto Away;\r\n}\r\nif (name == NULL || name[0] == NULL) {\r\nERRDRV("name must contain at least 1 node name!\n");\r\ngoto Away;\r\n}\r\ntype = kzalloc(sizeof(MYPROCTYPE), GFP_KERNEL | __GFP_NORETRY);\r\nif (type == NULL) {\r\nERRDRV("out of memory\n");\r\ngoto Away;\r\n}\r\ntype->name = name;\r\ntype->propertyNames = propertyNames;\r\ntype->nProperties = 0;\r\ntype->nNames = 0;\r\ntype->show_property = show_property;\r\ntype->procDirRoot = procDirRoot;\r\nif (type->propertyNames != NULL)\r\nwhile (type->propertyNames[type->nProperties] != NULL)\r\ntype->nProperties++;\r\nwhile (type->name[type->nNames] != NULL)\r\ntype->nNames++;\r\ntype->procDirs = kzalloc((type->nNames + 1) *\r\nsizeof(struct proc_dir_entry *),\r\nGFP_KERNEL | __GFP_NORETRY);\r\nif (type->procDirs == NULL) {\r\nERRDRV("out of memory\n");\r\ngoto Away;\r\n}\r\nparent = procDirRoot;\r\nfor (i = 0; i < type->nNames; i++) {\r\ntype->procDirs[i] = createProcDir(type->name[i], parent);\r\nif (type->procDirs[i] == NULL) {\r\nrc = NULL;\r\ngoto Away;\r\n}\r\nparent = type->procDirs[i];\r\n}\r\ntype->procDir = type->procDirs[type->nNames-1];\r\nrc = type;\r\nAway:\r\nif (rc == NULL) {\r\nif (type != NULL) {\r\nvisor_proc_DestroyType(type);\r\ntype = NULL;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nvoid visor_proc_DestroyType(MYPROCTYPE *type)\r\n{\r\nif (type == NULL)\r\nreturn;\r\nif (type->procDirs != NULL) {\r\nint i = type->nNames-1;\r\nwhile (i >= 0) {\r\nif (type->procDirs[i] != NULL) {\r\nstruct proc_dir_entry *parent = NULL;\r\nif (i == 0)\r\nparent = type->procDirRoot;\r\nelse\r\nparent = type->procDirs[i-1];\r\nremove_proc_entry(type->name[i], parent);\r\n}\r\ni--;\r\n}\r\nkfree(type->procDirs);\r\ntype->procDirs = NULL;\r\n}\r\nkfree(type);\r\n}\r\nMYPROCOBJECT *visor_proc_CreateObject(MYPROCTYPE *type,\r\nconst char *name, void *context)\r\n{\r\nMYPROCOBJECT *obj = NULL, *rc = NULL;\r\nint i = 0;\r\nif (type == NULL) {\r\nERRDRV("type cannot be NULL\n");\r\ngoto Away;\r\n}\r\nobj = kzalloc(sizeof(MYPROCOBJECT), GFP_KERNEL | __GFP_NORETRY);\r\nif (obj == NULL) {\r\nERRDRV("out of memory\n");\r\ngoto Away;\r\n}\r\nobj->type = type;\r\nobj->context = context;\r\nif (name == NULL) {\r\nobj->name = NULL;\r\nobj->procDir = type->procDir;\r\n} else {\r\nobj->namesize = strlen(name)+1;\r\nobj->name = kmalloc(obj->namesize, GFP_KERNEL | __GFP_NORETRY);\r\nif (obj->name == NULL) {\r\nobj->namesize = 0;\r\nERRDRV("out of memory\n");\r\ngoto Away;\r\n}\r\nstrcpy(obj->name, name);\r\nobj->procDir = createProcDir(obj->name, type->procDir);\r\nif (obj->procDir == NULL) {\r\ngoto Away;\r\n}\r\n}\r\nobj->procDirPropertyContexts =\r\nkzalloc((type->nProperties + 1) * sizeof(PROCDIRENTRYCONTEXT),\r\nGFP_KERNEL | __GFP_NORETRY);\r\nif (obj->procDirPropertyContexts == NULL) {\r\nERRDRV("out of memory\n");\r\ngoto Away;\r\n}\r\nobj->procDirProperties =\r\nkzalloc((type->nProperties + 1) * sizeof(struct proc_dir_entry *),\r\nGFP_KERNEL | __GFP_NORETRY);\r\nif (obj->procDirProperties == NULL) {\r\nERRDRV("out of memory\n");\r\ngoto Away;\r\n}\r\nfor (i = 0; i < type->nProperties; i++) {\r\nobj->procDirPropertyContexts[i].procObject = obj;\r\nobj->procDirPropertyContexts[i].propertyIndex = i;\r\nobj->procDirPropertyContexts[i].show_property =\r\ntype->show_property;\r\nif (type->propertyNames[i][0] != '\0') {\r\nobj->procDirProperties[i] =\r\ncreateProcFile(type->propertyNames[i],\r\nobj->procDir, &proc_fops,\r\n&obj->procDirPropertyContexts[i]);\r\nif (obj->procDirProperties[i] == NULL) {\r\nrc = NULL;\r\ngoto Away;\r\n}\r\n}\r\n}\r\nrc = obj;\r\nAway:\r\nif (rc == NULL) {\r\nif (obj != NULL) {\r\nvisor_proc_DestroyObject(obj);\r\nobj = NULL;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nvoid visor_proc_DestroyObject(MYPROCOBJECT *obj)\r\n{\r\nMYPROCTYPE *type = NULL;\r\nif (obj == NULL)\r\nreturn;\r\ntype = obj->type;\r\nif (type == NULL)\r\nreturn;\r\nif (obj->procDirProperties != NULL) {\r\nint i = 0;\r\nfor (i = 0; i < type->nProperties; i++) {\r\nif (obj->procDirProperties[i] != NULL) {\r\nremove_proc_entry(type->propertyNames[i],\r\nobj->procDir);\r\nobj->procDirProperties[i] = NULL;\r\n}\r\n}\r\nkfree(obj->procDirProperties);\r\nobj->procDirProperties = NULL;\r\n}\r\nif (obj->procDirPropertyContexts != NULL) {\r\nkfree(obj->procDirPropertyContexts);\r\nobj->procDirPropertyContexts = NULL;\r\n}\r\nif (obj->procDir != NULL) {\r\nif (obj->name != NULL)\r\nremove_proc_entry(obj->name, type->procDir);\r\nobj->procDir = NULL;\r\n}\r\nif (obj->name != NULL) {\r\nkfree(obj->name);\r\nobj->name = NULL;\r\n}\r\nkfree(obj);\r\n}\r\nstatic int seq_show(struct seq_file *seq, void *offset)\r\n{\r\nPROCDIRENTRYCONTEXT *ctx = (PROCDIRENTRYCONTEXT *)(seq->private);\r\nif (ctx == NULL) {\r\nERRDRV("I don't have a freakin' clue...");\r\nreturn 0;\r\n}\r\n(*ctx->show_property)(seq, ctx->procObject->context,\r\nctx->propertyIndex);\r\nreturn 0;\r\n}
