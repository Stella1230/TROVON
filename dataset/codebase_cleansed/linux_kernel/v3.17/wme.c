static int wme_downgrade_ac(struct sk_buff *skb)\r\n{\r\nswitch (skb->priority) {\r\ncase 6:\r\ncase 7:\r\nskb->priority = 5;\r\nreturn 0;\r\ncase 4:\r\ncase 5:\r\nskb->priority = 3;\r\nreturn 0;\r\ncase 0:\r\ncase 3:\r\nskb->priority = 2;\r\nreturn 0;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nstatic u16 ieee80211_downgrade_queue(struct ieee80211_sub_if_data *sdata,\r\nstruct sk_buff *skb)\r\n{\r\nwhile (unlikely(sdata->wmm_acm & BIT(skb->priority))) {\r\nif (wme_downgrade_ac(skb)) {\r\nbreak;\r\n}\r\n}\r\nreturn ieee802_1d_to_ac[skb->priority];\r\n}\r\nu16 ieee80211_select_queue_80211(struct ieee80211_sub_if_data *sdata,\r\nstruct sk_buff *skb,\r\nstruct ieee80211_hdr *hdr)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nu8 *p;\r\nif (local->hw.queues < IEEE80211_NUM_ACS)\r\nreturn 0;\r\nif (!ieee80211_is_data(hdr->frame_control)) {\r\nskb->priority = 7;\r\nreturn ieee802_1d_to_ac[skb->priority];\r\n}\r\nif (!ieee80211_is_data_qos(hdr->frame_control)) {\r\nskb->priority = 0;\r\nreturn ieee802_1d_to_ac[skb->priority];\r\n}\r\np = ieee80211_get_qos_ctl(hdr);\r\nskb->priority = *p & IEEE80211_QOS_CTL_TAG1D_MASK;\r\nreturn ieee80211_downgrade_queue(sdata, skb);\r\n}\r\nu16 ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sta_info *sta = NULL;\r\nconst u8 *ra = NULL;\r\nbool qos = false;\r\nstruct mac80211_qos_map *qos_map;\r\nif (local->hw.queues < IEEE80211_NUM_ACS || skb->len < 6) {\r\nskb->priority = 0;\r\nreturn 0;\r\n}\r\nrcu_read_lock();\r\nswitch (sdata->vif.type) {\r\ncase NL80211_IFTYPE_AP_VLAN:\r\nsta = rcu_dereference(sdata->u.vlan.sta);\r\nif (sta) {\r\nqos = test_sta_flag(sta, WLAN_STA_WME);\r\nbreak;\r\n}\r\ncase NL80211_IFTYPE_AP:\r\nra = skb->data;\r\nbreak;\r\ncase NL80211_IFTYPE_WDS:\r\nra = sdata->u.wds.remote_addr;\r\nbreak;\r\n#ifdef CONFIG_MAC80211_MESH\r\ncase NL80211_IFTYPE_MESH_POINT:\r\nqos = true;\r\nbreak;\r\n#endif\r\ncase NL80211_IFTYPE_STATION:\r\nra = sdata->u.mgd.bssid;\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nra = skb->data;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (!sta && ra && !is_multicast_ether_addr(ra)) {\r\nsta = sta_info_get(sdata, ra);\r\nif (sta)\r\nqos = test_sta_flag(sta, WLAN_STA_WME);\r\n}\r\nrcu_read_unlock();\r\nif (!qos) {\r\nskb->priority = 0;\r\nreturn IEEE80211_AC_BE;\r\n}\r\nif (skb->protocol == sdata->control_port_protocol) {\r\nskb->priority = 7;\r\nreturn ieee80211_downgrade_queue(sdata, skb);\r\n}\r\nrcu_read_lock();\r\nqos_map = rcu_dereference(sdata->qos_map);\r\nskb->priority = cfg80211_classify8021d(skb, qos_map ?\r\n&qos_map->qos_map : NULL);\r\nrcu_read_unlock();\r\nreturn ieee80211_downgrade_queue(sdata, skb);\r\n}\r\nvoid ieee80211_set_qos_hdr(struct ieee80211_sub_if_data *sdata,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr = (void *)skb->data;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nu8 *p;\r\nu8 ack_policy, tid;\r\nif (!ieee80211_is_data_qos(hdr->frame_control))\r\nreturn;\r\np = ieee80211_get_qos_ctl(hdr);\r\ntid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;\r\nack_policy = *p & IEEE80211_QOS_CTL_EOSP;\r\nif (is_multicast_ether_addr(hdr->addr1) ||\r\nsdata->noack_map & BIT(tid)) {\r\nack_policy |= IEEE80211_QOS_CTL_ACK_POLICY_NOACK;\r\ninfo->flags |= IEEE80211_TX_CTL_NO_ACK;\r\n}\r\n*p++ = ack_policy | tid;\r\nif (ieee80211_vif_is_mesh(&sdata->vif)) {\r\n*p &= ((IEEE80211_QOS_CTL_RSPI |\r\nIEEE80211_QOS_CTL_MESH_PS_LEVEL) >> 8);\r\nif (!ieee80211_is_qos_nullfunc(hdr->frame_control))\r\n*p |= (IEEE80211_QOS_CTL_MESH_CONTROL_PRESENT >> 8);\r\n} else {\r\n*p = 0;\r\n}\r\n}
