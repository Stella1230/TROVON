static int devid_to_int(struct ccw_dev_id *dev_id)\r\n{\r\nreturn dev_id->devno + (dev_id->ssid << 16);\r\n}\r\nstatic ssize_t\r\ntape_medium_state_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct tape_device *tdev;\r\ntdev = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%i\n", tdev->medium_state);\r\n}\r\nstatic ssize_t\r\ntape_first_minor_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct tape_device *tdev;\r\ntdev = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%i\n", tdev->first_minor);\r\n}\r\nstatic ssize_t\r\ntape_state_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct tape_device *tdev;\r\ntdev = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n", (tdev->first_minor < 0) ?\r\n"OFFLINE" : tape_state_verbose[tdev->tape_state]);\r\n}\r\nstatic ssize_t\r\ntape_operation_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct tape_device *tdev;\r\nssize_t rc;\r\ntdev = dev_get_drvdata(dev);\r\nif (tdev->first_minor < 0)\r\nreturn scnprintf(buf, PAGE_SIZE, "N/A\n");\r\nspin_lock_irq(get_ccwdev_lock(tdev->cdev));\r\nif (list_empty(&tdev->req_queue))\r\nrc = scnprintf(buf, PAGE_SIZE, "---\n");\r\nelse {\r\nstruct tape_request *req;\r\nreq = list_entry(tdev->req_queue.next, struct tape_request,\r\nlist);\r\nrc = scnprintf(buf,PAGE_SIZE, "%s\n", tape_op_verbose[req->op]);\r\n}\r\nspin_unlock_irq(get_ccwdev_lock(tdev->cdev));\r\nreturn rc;\r\n}\r\nstatic ssize_t\r\ntape_blocksize_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct tape_device *tdev;\r\ntdev = dev_get_drvdata(dev);\r\nreturn scnprintf(buf, PAGE_SIZE, "%i\n", tdev->char_data.block_size);\r\n}\r\nvoid\r\ntape_state_set(struct tape_device *device, enum tape_state newstate)\r\n{\r\nconst char *str;\r\nif (device->tape_state == TS_NOT_OPER) {\r\nDBF_EVENT(3, "ts_set err: not oper\n");\r\nreturn;\r\n}\r\nDBF_EVENT(4, "ts. dev: %x\n", device->first_minor);\r\nDBF_EVENT(4, "old ts:\t\n");\r\nif (device->tape_state < TS_SIZE && device->tape_state >=0 )\r\nstr = tape_state_verbose[device->tape_state];\r\nelse\r\nstr = "UNKNOWN TS";\r\nDBF_EVENT(4, "%s\n", str);\r\nDBF_EVENT(4, "new ts:\t\n");\r\nif (newstate < TS_SIZE && newstate >= 0)\r\nstr = tape_state_verbose[newstate];\r\nelse\r\nstr = "UNKNOWN TS";\r\nDBF_EVENT(4, "%s\n", str);\r\ndevice->tape_state = newstate;\r\nwake_up(&device->state_change_wq);\r\n}\r\nstatic void\r\ntape_med_state_work_handler(struct work_struct *work)\r\n{\r\nstatic char env_state_loaded[] = "MEDIUM_STATE=LOADED";\r\nstatic char env_state_unloaded[] = "MEDIUM_STATE=UNLOADED";\r\nstruct tape_med_state_work_data *p =\r\ncontainer_of(work, struct tape_med_state_work_data, work);\r\nstruct tape_device *device = p->device;\r\nchar *envp[] = { NULL, NULL };\r\nswitch (p->state) {\r\ncase MS_UNLOADED:\r\npr_info("%s: The tape cartridge has been successfully "\r\n"unloaded\n", dev_name(&device->cdev->dev));\r\nenvp[0] = env_state_unloaded;\r\nkobject_uevent_env(&device->cdev->dev.kobj, KOBJ_CHANGE, envp);\r\nbreak;\r\ncase MS_LOADED:\r\npr_info("%s: A tape cartridge has been mounted\n",\r\ndev_name(&device->cdev->dev));\r\nenvp[0] = env_state_loaded;\r\nkobject_uevent_env(&device->cdev->dev.kobj, KOBJ_CHANGE, envp);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ntape_put_device(device);\r\nkfree(p);\r\n}\r\nstatic void\r\ntape_med_state_work(struct tape_device *device, enum tape_medium_state state)\r\n{\r\nstruct tape_med_state_work_data *p;\r\np = kzalloc(sizeof(*p), GFP_ATOMIC);\r\nif (p) {\r\nINIT_WORK(&p->work, tape_med_state_work_handler);\r\np->device = tape_get_device(device);\r\np->state = state;\r\nschedule_work(&p->work);\r\n}\r\n}\r\nvoid\r\ntape_med_state_set(struct tape_device *device, enum tape_medium_state newstate)\r\n{\r\nenum tape_medium_state oldstate;\r\noldstate = device->medium_state;\r\nif (oldstate == newstate)\r\nreturn;\r\ndevice->medium_state = newstate;\r\nswitch(newstate){\r\ncase MS_UNLOADED:\r\ndevice->tape_generic_status |= GMT_DR_OPEN(~0);\r\nif (oldstate == MS_LOADED)\r\ntape_med_state_work(device, MS_UNLOADED);\r\nbreak;\r\ncase MS_LOADED:\r\ndevice->tape_generic_status &= ~GMT_DR_OPEN(~0);\r\nif (oldstate == MS_UNLOADED)\r\ntape_med_state_work(device, MS_LOADED);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwake_up(&device->state_change_wq);\r\n}\r\nstatic int\r\n__tape_cancel_io(struct tape_device *device, struct tape_request *request)\r\n{\r\nint retries;\r\nint rc;\r\nif (request->callback == NULL)\r\nreturn 0;\r\nrc = 0;\r\nfor (retries = 0; retries < 5; retries++) {\r\nrc = ccw_device_clear(device->cdev, (long) request);\r\nswitch (rc) {\r\ncase 0:\r\nrequest->status = TAPE_REQUEST_DONE;\r\nreturn 0;\r\ncase -EBUSY:\r\nrequest->status = TAPE_REQUEST_CANCEL;\r\nschedule_delayed_work(&device->tape_dnr, 0);\r\nreturn 0;\r\ncase -ENODEV:\r\nDBF_EXCEPTION(2, "device gone, retry\n");\r\nbreak;\r\ncase -EIO:\r\nDBF_EXCEPTION(2, "I/O error, retry\n");\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\ntape_assign_minor(struct tape_device *device)\r\n{\r\nstruct tape_device *tmp;\r\nint minor;\r\nminor = 0;\r\nwrite_lock(&tape_device_lock);\r\nlist_for_each_entry(tmp, &tape_device_list, node) {\r\nif (minor < tmp->first_minor)\r\nbreak;\r\nminor += TAPE_MINORS_PER_DEV;\r\n}\r\nif (minor >= 256) {\r\nwrite_unlock(&tape_device_lock);\r\nreturn -ENODEV;\r\n}\r\ndevice->first_minor = minor;\r\nlist_add_tail(&device->node, &tmp->node);\r\nwrite_unlock(&tape_device_lock);\r\nreturn 0;\r\n}\r\nstatic void\r\ntape_remove_minor(struct tape_device *device)\r\n{\r\nwrite_lock(&tape_device_lock);\r\nlist_del_init(&device->node);\r\ndevice->first_minor = -1;\r\nwrite_unlock(&tape_device_lock);\r\n}\r\nint\r\ntape_generic_online(struct tape_device *device,\r\nstruct tape_discipline *discipline)\r\n{\r\nint rc;\r\nDBF_LH(6, "tape_enable_device(%p, %p)\n", device, discipline);\r\nif (device->tape_state != TS_INIT) {\r\nDBF_LH(3, "Tapestate not INIT (%d)\n", device->tape_state);\r\nreturn -EINVAL;\r\n}\r\ninit_timer(&device->lb_timeout);\r\ndevice->lb_timeout.function = tape_long_busy_timeout;\r\ndevice->discipline = discipline;\r\nif (!try_module_get(discipline->owner)) {\r\nreturn -EINVAL;\r\n}\r\nrc = discipline->setup_device(device);\r\nif (rc)\r\ngoto out;\r\nrc = tape_assign_minor(device);\r\nif (rc)\r\ngoto out_discipline;\r\nrc = tapechar_setup_device(device);\r\nif (rc)\r\ngoto out_minor;\r\ntape_state_set(device, TS_UNUSED);\r\nDBF_LH(3, "(%08x): Drive set online\n", device->cdev_id);\r\nreturn 0;\r\nout_minor:\r\ntape_remove_minor(device);\r\nout_discipline:\r\ndevice->discipline->cleanup_device(device);\r\ndevice->discipline = NULL;\r\nout:\r\nmodule_put(discipline->owner);\r\nreturn rc;\r\n}\r\nstatic void\r\ntape_cleanup_device(struct tape_device *device)\r\n{\r\ntapechar_cleanup_device(device);\r\ndevice->discipline->cleanup_device(device);\r\nmodule_put(device->discipline->owner);\r\ntape_remove_minor(device);\r\ntape_med_state_set(device, MS_UNKNOWN);\r\n}\r\nint tape_generic_pm_suspend(struct ccw_device *cdev)\r\n{\r\nstruct tape_device *device;\r\ndevice = dev_get_drvdata(&cdev->dev);\r\nif (!device) {\r\nreturn -ENODEV;\r\n}\r\nDBF_LH(3, "(%08x): tape_generic_pm_suspend(%p)\n",\r\ndevice->cdev_id, device);\r\nif (device->medium_state != MS_UNLOADED) {\r\npr_err("A cartridge is loaded in tape device %s, "\r\n"refusing to suspend\n", dev_name(&cdev->dev));\r\nreturn -EBUSY;\r\n}\r\nspin_lock_irq(get_ccwdev_lock(device->cdev));\r\nswitch (device->tape_state) {\r\ncase TS_INIT:\r\ncase TS_NOT_OPER:\r\ncase TS_UNUSED:\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\nbreak;\r\ndefault:\r\npr_err("Tape device %s is busy, refusing to "\r\n"suspend\n", dev_name(&cdev->dev));\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\nreturn -EBUSY;\r\n}\r\nDBF_LH(3, "(%08x): Drive suspended.\n", device->cdev_id);\r\nreturn 0;\r\n}\r\nint\r\ntape_generic_offline(struct ccw_device *cdev)\r\n{\r\nstruct tape_device *device;\r\ndevice = dev_get_drvdata(&cdev->dev);\r\nif (!device) {\r\nreturn -ENODEV;\r\n}\r\nDBF_LH(3, "(%08x): tape_generic_offline(%p)\n",\r\ndevice->cdev_id, device);\r\nspin_lock_irq(get_ccwdev_lock(device->cdev));\r\nswitch (device->tape_state) {\r\ncase TS_INIT:\r\ncase TS_NOT_OPER:\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\nbreak;\r\ncase TS_UNUSED:\r\ntape_state_set(device, TS_INIT);\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\ntape_cleanup_device(device);\r\nbreak;\r\ndefault:\r\nDBF_EVENT(3, "(%08x): Set offline failed "\r\n"- drive in use.\n",\r\ndevice->cdev_id);\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\nreturn -EBUSY;\r\n}\r\nDBF_LH(3, "(%08x): Drive set offline.\n", device->cdev_id);\r\nreturn 0;\r\n}\r\nstatic struct tape_device *\r\ntape_alloc_device(void)\r\n{\r\nstruct tape_device *device;\r\ndevice = kzalloc(sizeof(struct tape_device), GFP_KERNEL);\r\nif (device == NULL) {\r\nDBF_EXCEPTION(2, "ti:no mem\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ndevice->modeset_byte = kmalloc(1, GFP_KERNEL | GFP_DMA);\r\nif (device->modeset_byte == NULL) {\r\nDBF_EXCEPTION(2, "ti:no mem\n");\r\nkfree(device);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nmutex_init(&device->mutex);\r\nINIT_LIST_HEAD(&device->req_queue);\r\nINIT_LIST_HEAD(&device->node);\r\ninit_waitqueue_head(&device->state_change_wq);\r\ninit_waitqueue_head(&device->wait_queue);\r\ndevice->tape_state = TS_INIT;\r\ndevice->medium_state = MS_UNKNOWN;\r\n*device->modeset_byte = 0;\r\ndevice->first_minor = -1;\r\natomic_set(&device->ref_count, 1);\r\nINIT_DELAYED_WORK(&device->tape_dnr, tape_delayed_next_request);\r\nreturn device;\r\n}\r\nstruct tape_device *\r\ntape_get_device(struct tape_device *device)\r\n{\r\nint count;\r\ncount = atomic_inc_return(&device->ref_count);\r\nDBF_EVENT(4, "tape_get_device(%p) = %i\n", device, count);\r\nreturn device;\r\n}\r\nvoid\r\ntape_put_device(struct tape_device *device)\r\n{\r\nint count;\r\ncount = atomic_dec_return(&device->ref_count);\r\nDBF_EVENT(4, "tape_put_device(%p) -> %i\n", device, count);\r\nBUG_ON(count < 0);\r\nif (count == 0) {\r\nkfree(device->modeset_byte);\r\nkfree(device);\r\n}\r\n}\r\nstruct tape_device *\r\ntape_find_device(int devindex)\r\n{\r\nstruct tape_device *device, *tmp;\r\ndevice = ERR_PTR(-ENODEV);\r\nread_lock(&tape_device_lock);\r\nlist_for_each_entry(tmp, &tape_device_list, node) {\r\nif (tmp->first_minor / TAPE_MINORS_PER_DEV == devindex) {\r\ndevice = tape_get_device(tmp);\r\nbreak;\r\n}\r\n}\r\nread_unlock(&tape_device_lock);\r\nreturn device;\r\n}\r\nint\r\ntape_generic_probe(struct ccw_device *cdev)\r\n{\r\nstruct tape_device *device;\r\nint ret;\r\nstruct ccw_dev_id dev_id;\r\ndevice = tape_alloc_device();\r\nif (IS_ERR(device))\r\nreturn -ENODEV;\r\nccw_device_set_options(cdev, CCWDEV_DO_PATHGROUP |\r\nCCWDEV_DO_MULTIPATH);\r\nret = sysfs_create_group(&cdev->dev.kobj, &tape_attr_group);\r\nif (ret) {\r\ntape_put_device(device);\r\nreturn ret;\r\n}\r\ndev_set_drvdata(&cdev->dev, device);\r\ncdev->handler = __tape_do_irq;\r\ndevice->cdev = cdev;\r\nccw_device_get_id(cdev, &dev_id);\r\ndevice->cdev_id = devid_to_int(&dev_id);\r\nreturn ret;\r\n}\r\nstatic void\r\n__tape_discard_requests(struct tape_device *device)\r\n{\r\nstruct tape_request * request;\r\nstruct list_head * l, *n;\r\nlist_for_each_safe(l, n, &device->req_queue) {\r\nrequest = list_entry(l, struct tape_request, list);\r\nif (request->status == TAPE_REQUEST_IN_IO)\r\nrequest->status = TAPE_REQUEST_DONE;\r\nlist_del(&request->list);\r\nrequest->device = NULL;\r\ntape_put_device(device);\r\nrequest->rc = -EIO;\r\nif (request->callback != NULL)\r\nrequest->callback(request, request->callback_data);\r\n}\r\n}\r\nvoid\r\ntape_generic_remove(struct ccw_device *cdev)\r\n{\r\nstruct tape_device * device;\r\ndevice = dev_get_drvdata(&cdev->dev);\r\nif (!device) {\r\nreturn;\r\n}\r\nDBF_LH(3, "(%08x): tape_generic_remove(%p)\n", device->cdev_id, cdev);\r\nspin_lock_irq(get_ccwdev_lock(device->cdev));\r\nswitch (device->tape_state) {\r\ncase TS_INIT:\r\ntape_state_set(device, TS_NOT_OPER);\r\ncase TS_NOT_OPER:\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\nbreak;\r\ncase TS_UNUSED:\r\ntape_state_set(device, TS_NOT_OPER);\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\ntape_cleanup_device(device);\r\nbreak;\r\ndefault:\r\nDBF_EVENT(3, "(%08x): Drive in use vanished!\n",\r\ndevice->cdev_id);\r\npr_warning("%s: A tape unit was detached while in "\r\n"use\n", dev_name(&device->cdev->dev));\r\ntape_state_set(device, TS_NOT_OPER);\r\n__tape_discard_requests(device);\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\ntape_cleanup_device(device);\r\n}\r\ndevice = dev_get_drvdata(&cdev->dev);\r\nif (device) {\r\nsysfs_remove_group(&cdev->dev.kobj, &tape_attr_group);\r\ndev_set_drvdata(&cdev->dev, NULL);\r\ntape_put_device(device);\r\n}\r\n}\r\nstruct tape_request *\r\ntape_alloc_request(int cplength, int datasize)\r\n{\r\nstruct tape_request *request;\r\nBUG_ON(datasize > PAGE_SIZE || (cplength*sizeof(struct ccw1)) > PAGE_SIZE);\r\nDBF_LH(6, "tape_alloc_request(%d, %d)\n", cplength, datasize);\r\nrequest = kzalloc(sizeof(struct tape_request), GFP_KERNEL);\r\nif (request == NULL) {\r\nDBF_EXCEPTION(1, "cqra nomem\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nif (cplength > 0) {\r\nrequest->cpaddr = kcalloc(cplength, sizeof(struct ccw1),\r\nGFP_ATOMIC | GFP_DMA);\r\nif (request->cpaddr == NULL) {\r\nDBF_EXCEPTION(1, "cqra nomem\n");\r\nkfree(request);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\n}\r\nif (datasize > 0) {\r\nrequest->cpdata = kzalloc(datasize, GFP_KERNEL | GFP_DMA);\r\nif (request->cpdata == NULL) {\r\nDBF_EXCEPTION(1, "cqra nomem\n");\r\nkfree(request->cpaddr);\r\nkfree(request);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\n}\r\nDBF_LH(6, "New request %p(%p/%p)\n", request, request->cpaddr,\r\nrequest->cpdata);\r\nreturn request;\r\n}\r\nvoid\r\ntape_free_request (struct tape_request * request)\r\n{\r\nDBF_LH(6, "Free request %p\n", request);\r\nif (request->device)\r\ntape_put_device(request->device);\r\nkfree(request->cpdata);\r\nkfree(request->cpaddr);\r\nkfree(request);\r\n}\r\nstatic int\r\n__tape_start_io(struct tape_device *device, struct tape_request *request)\r\n{\r\nint rc;\r\nrc = ccw_device_start(\r\ndevice->cdev,\r\nrequest->cpaddr,\r\n(unsigned long) request,\r\n0x00,\r\nrequest->options\r\n);\r\nif (rc == 0) {\r\nrequest->status = TAPE_REQUEST_IN_IO;\r\n} else if (rc == -EBUSY) {\r\nrequest->status = TAPE_REQUEST_QUEUED;\r\nschedule_delayed_work(&device->tape_dnr, 0);\r\nrc = 0;\r\n} else {\r\nDBF_EVENT(1, "tape: start request failed with RC = %i\n", rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic void\r\n__tape_start_next_request(struct tape_device *device)\r\n{\r\nstruct list_head *l, *n;\r\nstruct tape_request *request;\r\nint rc;\r\nDBF_LH(6, "__tape_start_next_request(%p)\n", device);\r\nlist_for_each_safe(l, n, &device->req_queue) {\r\nrequest = list_entry(l, struct tape_request, list);\r\nif (request->status == TAPE_REQUEST_IN_IO)\r\nreturn;\r\nif (request->status == TAPE_REQUEST_DONE)\r\nreturn;\r\nif (request->status == TAPE_REQUEST_CANCEL) {\r\nrc = __tape_cancel_io(device, request);\r\n} else {\r\nrc = __tape_start_io(device, request);\r\n}\r\nif (rc == 0)\r\nreturn;\r\nrequest->rc = rc;\r\nrequest->status = TAPE_REQUEST_DONE;\r\nlist_del(&request->list);\r\nif (request->callback != NULL)\r\nrequest->callback(request, request->callback_data);\r\n}\r\n}\r\nstatic void\r\ntape_delayed_next_request(struct work_struct *work)\r\n{\r\nstruct tape_device *device =\r\ncontainer_of(work, struct tape_device, tape_dnr.work);\r\nDBF_LH(6, "tape_delayed_next_request(%p)\n", device);\r\nspin_lock_irq(get_ccwdev_lock(device->cdev));\r\n__tape_start_next_request(device);\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\n}\r\nstatic void tape_long_busy_timeout(unsigned long data)\r\n{\r\nstruct tape_request *request;\r\nstruct tape_device *device;\r\ndevice = (struct tape_device *) data;\r\nspin_lock_irq(get_ccwdev_lock(device->cdev));\r\nrequest = list_entry(device->req_queue.next, struct tape_request, list);\r\nBUG_ON(request->status != TAPE_REQUEST_LONG_BUSY);\r\nDBF_LH(6, "%08x: Long busy timeout.\n", device->cdev_id);\r\n__tape_start_next_request(device);\r\ndevice->lb_timeout.data = 0UL;\r\ntape_put_device(device);\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\n}\r\nstatic void\r\n__tape_end_request(\r\nstruct tape_device * device,\r\nstruct tape_request * request,\r\nint rc)\r\n{\r\nDBF_LH(6, "__tape_end_request(%p, %p, %i)\n", device, request, rc);\r\nif (request) {\r\nrequest->rc = rc;\r\nrequest->status = TAPE_REQUEST_DONE;\r\nlist_del(&request->list);\r\nif (request->callback != NULL)\r\nrequest->callback(request, request->callback_data);\r\n}\r\nif (!list_empty(&device->req_queue))\r\n__tape_start_next_request(device);\r\n}\r\nvoid\r\ntape_dump_sense_dbf(struct tape_device *device, struct tape_request *request,\r\nstruct irb *irb)\r\n{\r\nunsigned int *sptr;\r\nconst char* op;\r\nif (request != NULL)\r\nop = tape_op_verbose[request->op];\r\nelse\r\nop = "---";\r\nDBF_EVENT(3, "DSTAT : %02x CSTAT: %02x\n",\r\nirb->scsw.cmd.dstat, irb->scsw.cmd.cstat);\r\nDBF_EVENT(3, "DEVICE: %08x OP\t: %s\n", device->cdev_id, op);\r\nsptr = (unsigned int *) irb->ecw;\r\nDBF_EVENT(3, "%08x %08x\n", sptr[0], sptr[1]);\r\nDBF_EVENT(3, "%08x %08x\n", sptr[2], sptr[3]);\r\nDBF_EVENT(3, "%08x %08x\n", sptr[4], sptr[5]);\r\nDBF_EVENT(3, "%08x %08x\n", sptr[6], sptr[7]);\r\n}\r\nstatic int\r\n__tape_start_request(struct tape_device *device, struct tape_request *request)\r\n{\r\nint rc;\r\nswitch (request->op) {\r\ncase TO_MSEN:\r\ncase TO_ASSIGN:\r\ncase TO_UNASSIGN:\r\ncase TO_READ_ATTMSG:\r\ncase TO_RDC:\r\nif (device->tape_state == TS_INIT)\r\nbreak;\r\nif (device->tape_state == TS_UNUSED)\r\nbreak;\r\ndefault:\r\nif (device->tape_state == TS_BLKUSE)\r\nbreak;\r\nif (device->tape_state != TS_IN_USE)\r\nreturn -ENODEV;\r\n}\r\nrequest->device = tape_get_device(device);\r\nif (list_empty(&device->req_queue)) {\r\nrc = __tape_start_io(device, request);\r\nif (rc)\r\nreturn rc;\r\nDBF_LH(5, "Request %p added for execution.\n", request);\r\nlist_add(&request->list, &device->req_queue);\r\n} else {\r\nDBF_LH(5, "Request %p add to queue.\n", request);\r\nrequest->status = TAPE_REQUEST_QUEUED;\r\nlist_add_tail(&request->list, &device->req_queue);\r\n}\r\nreturn 0;\r\n}\r\nint\r\ntape_do_io_async(struct tape_device *device, struct tape_request *request)\r\n{\r\nint rc;\r\nDBF_LH(6, "tape_do_io_async(%p, %p)\n", device, request);\r\nspin_lock_irq(get_ccwdev_lock(device->cdev));\r\nrc = __tape_start_request(device, request);\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\nreturn rc;\r\n}\r\nstatic void\r\n__tape_wake_up(struct tape_request *request, void *data)\r\n{\r\nrequest->callback = NULL;\r\nwake_up((wait_queue_head_t *) data);\r\n}\r\nint\r\ntape_do_io(struct tape_device *device, struct tape_request *request)\r\n{\r\nint rc;\r\nspin_lock_irq(get_ccwdev_lock(device->cdev));\r\nrequest->callback = __tape_wake_up;\r\nrequest->callback_data = &device->wait_queue;\r\nrc = __tape_start_request(device, request);\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\nif (rc)\r\nreturn rc;\r\nwait_event(device->wait_queue, (request->callback == NULL));\r\nreturn request->rc;\r\n}\r\nstatic void\r\n__tape_wake_up_interruptible(struct tape_request *request, void *data)\r\n{\r\nrequest->callback = NULL;\r\nwake_up_interruptible((wait_queue_head_t *) data);\r\n}\r\nint\r\ntape_do_io_interruptible(struct tape_device *device,\r\nstruct tape_request *request)\r\n{\r\nint rc;\r\nspin_lock_irq(get_ccwdev_lock(device->cdev));\r\nrequest->callback = __tape_wake_up_interruptible;\r\nrequest->callback_data = &device->wait_queue;\r\nrc = __tape_start_request(device, request);\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\nif (rc)\r\nreturn rc;\r\nrc = wait_event_interruptible(device->wait_queue,\r\n(request->callback == NULL));\r\nif (rc != -ERESTARTSYS)\r\nreturn request->rc;\r\nspin_lock_irq(get_ccwdev_lock(device->cdev));\r\nrc = __tape_cancel_io(device, request);\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\nif (rc == 0) {\r\ndo {\r\nrc = wait_event_interruptible(\r\ndevice->wait_queue,\r\n(request->callback == NULL)\r\n);\r\n} while (rc == -ERESTARTSYS);\r\nDBF_EVENT(3, "IO stopped on %08x\n", device->cdev_id);\r\nrc = -ERESTARTSYS;\r\n}\r\nreturn rc;\r\n}\r\nint\r\ntape_cancel_io(struct tape_device *device, struct tape_request *request)\r\n{\r\nint rc;\r\nspin_lock_irq(get_ccwdev_lock(device->cdev));\r\nrc = __tape_cancel_io(device, request);\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\nreturn rc;\r\n}\r\nstatic void\r\n__tape_do_irq (struct ccw_device *cdev, unsigned long intparm, struct irb *irb)\r\n{\r\nstruct tape_device *device;\r\nstruct tape_request *request;\r\nint rc;\r\ndevice = dev_get_drvdata(&cdev->dev);\r\nif (device == NULL) {\r\nreturn;\r\n}\r\nrequest = (struct tape_request *) intparm;\r\nDBF_LH(6, "__tape_do_irq(device=%p, request=%p)\n", device, request);\r\nif (IS_ERR(irb)) {\r\nswitch (PTR_ERR(irb)) {\r\ncase -ETIMEDOUT:\r\nDBF_LH(1, "(%08x): Request timed out\n",\r\ndevice->cdev_id);\r\ncase -EIO:\r\n__tape_end_request(device, request, -EIO);\r\nbreak;\r\ndefault:\r\nDBF_LH(1, "(%08x): Unexpected i/o error %li\n",\r\ndevice->cdev_id, PTR_ERR(irb));\r\n}\r\nreturn;\r\n}\r\nif (irb->scsw.cmd.cc != 0 &&\r\n(irb->scsw.cmd.fctl & SCSW_FCTL_START_FUNC) &&\r\n(request->status == TAPE_REQUEST_IN_IO)) {\r\nDBF_EVENT(3,"(%08x): deferred cc=%i, fctl=%i. restarting\n",\r\ndevice->cdev_id, irb->scsw.cmd.cc, irb->scsw.cmd.fctl);\r\nrequest->status = TAPE_REQUEST_QUEUED;\r\nschedule_delayed_work(&device->tape_dnr, HZ);\r\nreturn;\r\n}\r\nif(request != NULL)\r\nrequest->rescnt = irb->scsw.cmd.count;\r\nelse if ((irb->scsw.cmd.dstat == 0x85 || irb->scsw.cmd.dstat == 0x80) &&\r\n!list_empty(&device->req_queue)) {\r\nstruct tape_request *req;\r\nreq = list_entry(device->req_queue.next,\r\nstruct tape_request, list);\r\nif (req->status == TAPE_REQUEST_LONG_BUSY) {\r\nDBF_EVENT(3, "(%08x): del timer\n", device->cdev_id);\r\nif (del_timer(&device->lb_timeout)) {\r\ndevice->lb_timeout.data = 0UL;\r\ntape_put_device(device);\r\n__tape_start_next_request(device);\r\n}\r\nreturn;\r\n}\r\n}\r\nif (irb->scsw.cmd.dstat != 0x0c) {\r\nif(*(((__u8 *) irb->ecw) + 1) & SENSE_DRIVE_ONLINE)\r\ndevice->tape_generic_status |= GMT_ONLINE(~0);\r\nelse\r\ndevice->tape_generic_status &= ~GMT_ONLINE(~0);\r\nDBF_EVENT(3,"-- Tape Interrupthandler --\n");\r\ntape_dump_sense_dbf(device, request, irb);\r\n} else {\r\ndevice->tape_generic_status |= GMT_ONLINE(~0);\r\n}\r\nif (device->tape_state == TS_NOT_OPER) {\r\nDBF_EVENT(6, "tape:device is not operational\n");\r\nreturn;\r\n}\r\nif(request != NULL && request->status == TAPE_REQUEST_DONE) {\r\n__tape_end_request(device, request, -EIO);\r\nreturn;\r\n}\r\nrc = device->discipline->irq(device, request, irb);\r\nswitch (rc) {\r\ncase TAPE_IO_SUCCESS:\r\ndevice->tape_generic_status |= GMT_ONLINE(~0);\r\n__tape_end_request(device, request, rc);\r\nbreak;\r\ncase TAPE_IO_PENDING:\r\nbreak;\r\ncase TAPE_IO_LONG_BUSY:\r\ndevice->lb_timeout.data =\r\n(unsigned long) tape_get_device(device);\r\ndevice->lb_timeout.expires = jiffies +\r\nLONG_BUSY_TIMEOUT * HZ;\r\nDBF_EVENT(3, "(%08x): add timer\n", device->cdev_id);\r\nadd_timer(&device->lb_timeout);\r\nrequest->status = TAPE_REQUEST_LONG_BUSY;\r\nbreak;\r\ncase TAPE_IO_RETRY:\r\nrc = __tape_start_io(device, request);\r\nif (rc)\r\n__tape_end_request(device, request, rc);\r\nbreak;\r\ncase TAPE_IO_STOP:\r\nrc = __tape_cancel_io(device, request);\r\nif (rc)\r\n__tape_end_request(device, request, rc);\r\nbreak;\r\ndefault:\r\nif (rc > 0) {\r\nDBF_EVENT(6, "xunknownrc\n");\r\n__tape_end_request(device, request, -EIO);\r\n} else {\r\n__tape_end_request(device, request, rc);\r\n}\r\nbreak;\r\n}\r\n}\r\nint\r\ntape_open(struct tape_device *device)\r\n{\r\nint rc;\r\nspin_lock_irq(get_ccwdev_lock(device->cdev));\r\nif (device->tape_state == TS_NOT_OPER) {\r\nDBF_EVENT(6, "TAPE:nodev\n");\r\nrc = -ENODEV;\r\n} else if (device->tape_state == TS_IN_USE) {\r\nDBF_EVENT(6, "TAPE:dbusy\n");\r\nrc = -EBUSY;\r\n} else if (device->tape_state == TS_BLKUSE) {\r\nDBF_EVENT(6, "TAPE:dbusy\n");\r\nrc = -EBUSY;\r\n} else if (device->discipline != NULL &&\r\n!try_module_get(device->discipline->owner)) {\r\nDBF_EVENT(6, "TAPE:nodisc\n");\r\nrc = -ENODEV;\r\n} else {\r\ntape_state_set(device, TS_IN_USE);\r\nrc = 0;\r\n}\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\nreturn rc;\r\n}\r\nint\r\ntape_release(struct tape_device *device)\r\n{\r\nspin_lock_irq(get_ccwdev_lock(device->cdev));\r\nif (device->tape_state == TS_IN_USE)\r\ntape_state_set(device, TS_UNUSED);\r\nmodule_put(device->discipline->owner);\r\nspin_unlock_irq(get_ccwdev_lock(device->cdev));\r\nreturn 0;\r\n}\r\nint\r\ntape_mtop(struct tape_device *device, int mt_op, int mt_count)\r\n{\r\ntape_mtop_fn fn;\r\nint rc;\r\nDBF_EVENT(6, "TAPE:mtio\n");\r\nDBF_EVENT(6, "TAPE:ioop: %x\n", mt_op);\r\nDBF_EVENT(6, "TAPE:arg: %x\n", mt_count);\r\nif (mt_op < 0 || mt_op >= TAPE_NR_MTOPS)\r\nreturn -EINVAL;\r\nfn = device->discipline->mtop_array[mt_op];\r\nif (fn == NULL)\r\nreturn -EINVAL;\r\nif (mt_op == MTBSR || mt_op == MTFSR || mt_op == MTFSF ||\r\nmt_op == MTBSF || mt_op == MTFSFM || mt_op == MTBSFM) {\r\nrc = 0;\r\nfor (; mt_count > 500; mt_count -= 500)\r\nif ((rc = fn(device, 500)) != 0)\r\nbreak;\r\nif (rc == 0)\r\nrc = fn(device, mt_count);\r\n} else\r\nrc = fn(device, mt_count);\r\nreturn rc;\r\n}\r\nstatic int\r\ntape_init (void)\r\n{\r\nTAPE_DBF_AREA = debug_register ( "tape", 2, 2, 4*sizeof(long));\r\ndebug_register_view(TAPE_DBF_AREA, &debug_sprintf_view);\r\n#ifdef DBF_LIKE_HELL\r\ndebug_set_level(TAPE_DBF_AREA, 6);\r\n#endif\r\nDBF_EVENT(3, "tape init\n");\r\ntape_proc_init();\r\ntapechar_init ();\r\nreturn 0;\r\n}\r\nstatic void\r\ntape_exit(void)\r\n{\r\nDBF_EVENT(6, "tape exit\n");\r\ntapechar_exit();\r\ntape_proc_cleanup();\r\ndebug_unregister (TAPE_DBF_AREA);\r\n}
