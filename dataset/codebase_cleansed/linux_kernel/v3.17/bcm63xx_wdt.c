static void bcm63xx_wdt_hw_start(void)\r\n{\r\nbcm_writel(0xfffffffe, bcm63xx_wdt_device.regs + WDT_DEFVAL_REG);\r\nbcm_writel(WDT_START_1, bcm63xx_wdt_device.regs + WDT_CTL_REG);\r\nbcm_writel(WDT_START_2, bcm63xx_wdt_device.regs + WDT_CTL_REG);\r\n}\r\nstatic void bcm63xx_wdt_hw_stop(void)\r\n{\r\nbcm_writel(WDT_STOP_1, bcm63xx_wdt_device.regs + WDT_CTL_REG);\r\nbcm_writel(WDT_STOP_2, bcm63xx_wdt_device.regs + WDT_CTL_REG);\r\n}\r\nstatic void bcm63xx_wdt_isr(void *data)\r\n{\r\nstruct pt_regs *regs = get_irq_regs();\r\ndie(PFX " fire", regs);\r\n}\r\nstatic void bcm63xx_timer_tick(unsigned long unused)\r\n{\r\nif (!atomic_dec_and_test(&bcm63xx_wdt_device.ticks)) {\r\nbcm63xx_wdt_hw_start();\r\nmod_timer(&bcm63xx_wdt_device.timer, jiffies + HZ);\r\n} else\r\npr_crit("watchdog will restart system\n");\r\n}\r\nstatic void bcm63xx_wdt_pet(void)\r\n{\r\natomic_set(&bcm63xx_wdt_device.ticks, wdt_time);\r\n}\r\nstatic void bcm63xx_wdt_start(void)\r\n{\r\nbcm63xx_wdt_pet();\r\nbcm63xx_timer_tick(0);\r\n}\r\nstatic void bcm63xx_wdt_pause(void)\r\n{\r\ndel_timer_sync(&bcm63xx_wdt_device.timer);\r\nbcm63xx_wdt_hw_stop();\r\n}\r\nstatic int bcm63xx_wdt_settimeout(int new_time)\r\n{\r\nif ((new_time <= 0) || (new_time > WDT_MAX_TIME))\r\nreturn -EINVAL;\r\nwdt_time = new_time;\r\nreturn 0;\r\n}\r\nstatic int bcm63xx_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &bcm63xx_wdt_device.inuse))\r\nreturn -EBUSY;\r\nbcm63xx_wdt_start();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int bcm63xx_wdt_release(struct inode *inode, struct file *file)\r\n{\r\nif (expect_close == 42)\r\nbcm63xx_wdt_pause();\r\nelse {\r\npr_crit("Unexpected close, not stopping watchdog!\n");\r\nbcm63xx_wdt_start();\r\n}\r\nclear_bit(0, &bcm63xx_wdt_device.inuse);\r\nexpect_close = 0;\r\nreturn 0;\r\n}\r\nstatic ssize_t bcm63xx_wdt_write(struct file *file, const char *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nif (len) {\r\nif (!nowayout) {\r\nsize_t i;\r\nexpect_close = 0;\r\nfor (i = 0; i != len; i++) {\r\nchar c;\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nexpect_close = 42;\r\n}\r\n}\r\nbcm63xx_wdt_pet();\r\n}\r\nreturn len;\r\n}\r\nstatic long bcm63xx_wdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nint new_value, retval = -EINVAL;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user(argp, &bcm63xx_wdt_info,\r\nsizeof(bcm63xx_wdt_info)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_SETOPTIONS:\r\nif (get_user(new_value, p))\r\nreturn -EFAULT;\r\nif (new_value & WDIOS_DISABLECARD) {\r\nbcm63xx_wdt_pause();\r\nretval = 0;\r\n}\r\nif (new_value & WDIOS_ENABLECARD) {\r\nbcm63xx_wdt_start();\r\nretval = 0;\r\n}\r\nreturn retval;\r\ncase WDIOC_KEEPALIVE:\r\nbcm63xx_wdt_pet();\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(new_value, p))\r\nreturn -EFAULT;\r\nif (bcm63xx_wdt_settimeout(new_value))\r\nreturn -EINVAL;\r\nbcm63xx_wdt_pet();\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(wdt_time, p);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int bcm63xx_wdt_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct resource *r;\r\nsetup_timer(&bcm63xx_wdt_device.timer, bcm63xx_timer_tick, 0L);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\ndev_err(&pdev->dev, "failed to get resources\n");\r\nreturn -ENODEV;\r\n}\r\nbcm63xx_wdt_device.regs = devm_ioremap_nocache(&pdev->dev, r->start,\r\nresource_size(r));\r\nif (!bcm63xx_wdt_device.regs) {\r\ndev_err(&pdev->dev, "failed to remap I/O resources\n");\r\nreturn -ENXIO;\r\n}\r\nret = bcm63xx_timer_register(TIMER_WDT_ID, bcm63xx_wdt_isr, NULL);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to register wdt timer isr\n");\r\nreturn ret;\r\n}\r\nif (bcm63xx_wdt_settimeout(wdt_time)) {\r\nbcm63xx_wdt_settimeout(WDT_DEFAULT_TIME);\r\ndev_info(&pdev->dev,\r\n": wdt_time value must be 1 <= wdt_time <= 256, using %d\n",\r\nwdt_time);\r\n}\r\nret = misc_register(&bcm63xx_wdt_miscdev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to register watchdog device\n");\r\ngoto unregister_timer;\r\n}\r\ndev_info(&pdev->dev, " started, timer margin: %d sec\n",\r\nWDT_DEFAULT_TIME);\r\nreturn 0;\r\nunregister_timer:\r\nbcm63xx_timer_unregister(TIMER_WDT_ID);\r\nreturn ret;\r\n}\r\nstatic int bcm63xx_wdt_remove(struct platform_device *pdev)\r\n{\r\nif (!nowayout)\r\nbcm63xx_wdt_pause();\r\nmisc_deregister(&bcm63xx_wdt_miscdev);\r\nbcm63xx_timer_unregister(TIMER_WDT_ID);\r\nreturn 0;\r\n}\r\nstatic void bcm63xx_wdt_shutdown(struct platform_device *pdev)\r\n{\r\nbcm63xx_wdt_pause();\r\n}
