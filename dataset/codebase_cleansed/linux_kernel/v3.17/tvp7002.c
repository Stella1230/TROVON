static inline struct tvp7002 *to_tvp7002(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct tvp7002, sd);\r\n}\r\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct tvp7002, hdl)->sd;\r\n}\r\nstatic int tvp7002_read(struct v4l2_subdev *sd, u8 addr, u8 *dst)\r\n{\r\nstruct i2c_client *c = v4l2_get_subdevdata(sd);\r\nint retry;\r\nint error;\r\nfor (retry = 0; retry < I2C_RETRY_COUNT; retry++) {\r\nerror = i2c_smbus_read_byte_data(c, addr);\r\nif (error >= 0) {\r\n*dst = (u8)error;\r\nreturn 0;\r\n}\r\nmsleep_interruptible(10);\r\n}\r\nv4l2_err(sd, "TVP7002 read error %d\n", error);\r\nreturn error;\r\n}\r\nstatic inline void tvp7002_read_err(struct v4l2_subdev *sd, u8 reg,\r\nu8 *dst, int *err)\r\n{\r\nif (!*err)\r\n*err = tvp7002_read(sd, reg, dst);\r\n}\r\nstatic int tvp7002_write(struct v4l2_subdev *sd, u8 addr, u8 value)\r\n{\r\nstruct i2c_client *c;\r\nint retry;\r\nint error;\r\nc = v4l2_get_subdevdata(sd);\r\nfor (retry = 0; retry < I2C_RETRY_COUNT; retry++) {\r\nerror = i2c_smbus_write_byte_data(c, addr, value);\r\nif (error >= 0)\r\nreturn 0;\r\nv4l2_warn(sd, "Write: retry ... %d\n", retry);\r\nmsleep_interruptible(10);\r\n}\r\nv4l2_err(sd, "TVP7002 write error %d\n", error);\r\nreturn error;\r\n}\r\nstatic inline void tvp7002_write_err(struct v4l2_subdev *sd, u8 reg,\r\nu8 val, int *err)\r\n{\r\nif (!*err)\r\n*err = tvp7002_write(sd, reg, val);\r\n}\r\nstatic int tvp7002_write_inittab(struct v4l2_subdev *sd,\r\nconst struct i2c_reg_value *regs)\r\n{\r\nint error = 0;\r\nwhile (TVP7002_EOR != regs->reg) {\r\nif (TVP7002_WRITE == regs->type)\r\ntvp7002_write_err(sd, regs->reg, regs->value, &error);\r\nregs++;\r\n}\r\nreturn error;\r\n}\r\nstatic int tvp7002_s_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *dv_timings)\r\n{\r\nstruct tvp7002 *device = to_tvp7002(sd);\r\nconst struct v4l2_bt_timings *bt = &dv_timings->bt;\r\nint i;\r\nif (dv_timings->type != V4L2_DV_BT_656_1120)\r\nreturn -EINVAL;\r\nfor (i = 0; i < NUM_TIMINGS; i++) {\r\nconst struct v4l2_bt_timings *t = &tvp7002_timings[i].timings.bt;\r\nif (!memcmp(bt, t, &bt->standards - &bt->width)) {\r\ndevice->current_timings = &tvp7002_timings[i];\r\nreturn tvp7002_write_inittab(sd, tvp7002_timings[i].p_settings);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int tvp7002_g_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *dv_timings)\r\n{\r\nstruct tvp7002 *device = to_tvp7002(sd);\r\n*dv_timings = device->current_timings->timings;\r\nreturn 0;\r\n}\r\nstatic int tvp7002_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nint error = 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_GAIN:\r\ntvp7002_write_err(sd, TVP7002_R_FINE_GAIN, ctrl->val, &error);\r\ntvp7002_write_err(sd, TVP7002_G_FINE_GAIN, ctrl->val, &error);\r\ntvp7002_write_err(sd, TVP7002_B_FINE_GAIN, ctrl->val, &error);\r\nreturn error;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int tvp7002_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *f)\r\n{\r\nstruct tvp7002 *device = to_tvp7002(sd);\r\nconst struct v4l2_bt_timings *bt = &device->current_timings->timings.bt;\r\nf->width = bt->width;\r\nf->height = bt->height;\r\nf->code = V4L2_MBUS_FMT_YUYV10_1X20;\r\nf->field = device->current_timings->scanmode;\r\nf->colorspace = device->current_timings->color_space;\r\nv4l2_dbg(1, debug, sd, "MBUS_FMT: Width - %d, Height - %d",\r\nf->width, f->height);\r\nreturn 0;\r\n}\r\nstatic int tvp7002_query_dv(struct v4l2_subdev *sd, int *index)\r\n{\r\nconst struct tvp7002_timings_definition *timings = tvp7002_timings;\r\nu8 progressive;\r\nu32 lpfr;\r\nu32 cpln;\r\nint error = 0;\r\nu8 lpf_lsb;\r\nu8 lpf_msb;\r\nu8 cpl_lsb;\r\nu8 cpl_msb;\r\n*index = NUM_TIMINGS;\r\ntvp7002_read_err(sd, TVP7002_L_FRAME_STAT_LSBS, &lpf_lsb, &error);\r\ntvp7002_read_err(sd, TVP7002_L_FRAME_STAT_MSBS, &lpf_msb, &error);\r\nif (error < 0)\r\nreturn error;\r\ntvp7002_read_err(sd, TVP7002_CLK_L_STAT_LSBS, &cpl_lsb, &error);\r\ntvp7002_read_err(sd, TVP7002_CLK_L_STAT_MSBS, &cpl_msb, &error);\r\nif (error < 0)\r\nreturn error;\r\nlpfr = lpf_lsb | ((TVP7002_CL_MASK & lpf_msb) << TVP7002_CL_SHIFT);\r\ncpln = cpl_lsb | ((TVP7002_CL_MASK & cpl_msb) << TVP7002_CL_SHIFT);\r\nprogressive = (lpf_msb & TVP7002_INPR_MASK) >> TVP7002_IP_SHIFT;\r\nfor (*index = 0; *index < NUM_TIMINGS; (*index)++, timings++)\r\nif (lpfr == timings->lines_per_frame &&\r\nprogressive == timings->progressive) {\r\nif (timings->cpl_min == 0xffff)\r\nbreak;\r\nif (cpln >= timings->cpl_min && cpln <= timings->cpl_max)\r\nbreak;\r\n}\r\nif (*index == NUM_TIMINGS) {\r\nv4l2_dbg(1, debug, sd, "detection failed: lpf = %x, cpl = %x\n",\r\nlpfr, cpln);\r\nreturn -ENOLINK;\r\n}\r\nv4l2_dbg(1, debug, sd, "detected timings: %d\n", *index);\r\nreturn 0;\r\n}\r\nstatic int tvp7002_query_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nint index;\r\nint err = tvp7002_query_dv(sd, &index);\r\nif (err)\r\nreturn err;\r\n*timings = tvp7002_timings[index].timings;\r\nreturn 0;\r\n}\r\nstatic int tvp7002_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nu8 val;\r\nint ret;\r\nret = tvp7002_read(sd, reg->reg & 0xff, &val);\r\nreg->val = val;\r\nreg->size = 1;\r\nreturn ret;\r\n}\r\nstatic int tvp7002_s_register(struct v4l2_subdev *sd,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nreturn tvp7002_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\n}\r\nstatic int tvp7002_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned index,\r\nenum v4l2_mbus_pixelcode *code)\r\n{\r\nif (index)\r\nreturn -EINVAL;\r\n*code = V4L2_MBUS_FMT_YUYV10_1X20;\r\nreturn 0;\r\n}\r\nstatic int tvp7002_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct tvp7002 *device = to_tvp7002(sd);\r\nint error = 0;\r\nif (device->streaming == enable)\r\nreturn 0;\r\nif (enable) {\r\nerror = tvp7002_write(sd, TVP7002_MISC_CTL_2, 0x00);\r\ndevice->streaming = enable;\r\n} else {\r\nerror = tvp7002_write(sd, TVP7002_MISC_CTL_2, 0x03);\r\nif (error)\r\nv4l2_dbg(1, debug, sd, "Unable to stop streaming\n");\r\ndevice->streaming = enable;\r\n}\r\nreturn error;\r\n}\r\nstatic int tvp7002_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct tvp7002 *device = to_tvp7002(sd);\r\nconst struct v4l2_bt_timings *bt;\r\nint detected;\r\ntvp7002_query_dv(sd, &detected);\r\nbt = &device->current_timings->timings.bt;\r\nv4l2_info(sd, "Selected DV Timings: %ux%u\n", bt->width, bt->height);\r\nif (detected == NUM_TIMINGS) {\r\nv4l2_info(sd, "Detected DV Timings: None\n");\r\n} else {\r\nbt = &tvp7002_timings[detected].timings.bt;\r\nv4l2_info(sd, "Detected DV Timings: %ux%u\n",\r\nbt->width, bt->height);\r\n}\r\nv4l2_info(sd, "Streaming enabled: %s\n",\r\ndevice->streaming ? "yes" : "no");\r\nv4l2_ctrl_handler_log_status(&device->hdl, sd->name);\r\nreturn 0;\r\n}\r\nstatic int tvp7002_enum_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nif (timings->pad != 0)\r\nreturn -EINVAL;\r\nif (timings->index >= NUM_TIMINGS)\r\nreturn -EINVAL;\r\ntimings->timings = tvp7002_timings[timings->index].timings;\r\nreturn 0;\r\n}\r\nstatic int\r\ntvp7002_enum_mbus_code(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->index != 0)\r\nreturn -EINVAL;\r\ncode->code = V4L2_MBUS_FMT_YUYV10_1X20;\r\nreturn 0;\r\n}\r\nstatic int\r\ntvp7002_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct tvp7002 *tvp7002 = to_tvp7002(sd);\r\nfmt->format.code = V4L2_MBUS_FMT_YUYV10_1X20;\r\nfmt->format.width = tvp7002->current_timings->timings.bt.width;\r\nfmt->format.height = tvp7002->current_timings->timings.bt.height;\r\nfmt->format.field = tvp7002->current_timings->scanmode;\r\nfmt->format.colorspace = tvp7002->current_timings->color_space;\r\nreturn 0;\r\n}\r\nstatic int\r\ntvp7002_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nreturn tvp7002_get_pad_format(sd, fh, fmt);\r\n}\r\nstatic struct tvp7002_config *\r\ntvp7002_get_pdata(struct i2c_client *client)\r\n{\r\nstruct v4l2_of_endpoint bus_cfg;\r\nstruct tvp7002_config *pdata;\r\nstruct device_node *endpoint;\r\nunsigned int flags;\r\nif (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)\r\nreturn client->dev.platform_data;\r\nendpoint = of_graph_get_next_endpoint(client->dev.of_node, NULL);\r\nif (!endpoint)\r\nreturn NULL;\r\npdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\ngoto done;\r\nv4l2_of_parse_endpoint(endpoint, &bus_cfg);\r\nflags = bus_cfg.bus.parallel.flags;\r\nif (flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)\r\npdata->hs_polarity = 1;\r\nif (flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)\r\npdata->vs_polarity = 1;\r\nif (flags & V4L2_MBUS_PCLK_SAMPLE_RISING)\r\npdata->clk_polarity = 1;\r\nif (flags & V4L2_MBUS_FIELD_EVEN_HIGH)\r\npdata->fid_polarity = 1;\r\nif (flags & V4L2_MBUS_VIDEO_SOG_ACTIVE_HIGH)\r\npdata->sog_polarity = 1;\r\ndone:\r\nof_node_put(endpoint);\r\nreturn pdata;\r\n}\r\nstatic int tvp7002_probe(struct i2c_client *c, const struct i2c_device_id *id)\r\n{\r\nstruct tvp7002_config *pdata = tvp7002_get_pdata(c);\r\nstruct v4l2_subdev *sd;\r\nstruct tvp7002 *device;\r\nstruct v4l2_dv_timings timings;\r\nint polarity_a;\r\nint polarity_b;\r\nu8 revision;\r\nint error;\r\nif (pdata == NULL) {\r\ndev_err(&c->dev, "No platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(c->adapter,\r\nI2C_FUNC_SMBUS_READ_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))\r\nreturn -EIO;\r\ndevice = devm_kzalloc(&c->dev, sizeof(struct tvp7002), GFP_KERNEL);\r\nif (!device)\r\nreturn -ENOMEM;\r\nsd = &device->sd;\r\ndevice->pdata = pdata;\r\ndevice->current_timings = tvp7002_timings;\r\nv4l2_i2c_subdev_init(sd, c, &tvp7002_ops);\r\nv4l_info(c, "tvp7002 found @ 0x%02x (%s)\n",\r\nc->addr, c->adapter->name);\r\nerror = tvp7002_read(sd, TVP7002_CHIP_REV, &revision);\r\nif (error < 0)\r\nreturn error;\r\nv4l2_info(sd, "Rev. %02x detected.\n", revision);\r\nif (revision != 0x02)\r\nv4l2_info(sd, "Unknown revision detected.\n");\r\nerror = tvp7002_write_inittab(sd, tvp7002_init_default);\r\nif (error < 0)\r\nreturn error;\r\npolarity_a = 0x20 | device->pdata->hs_polarity << 5\r\n| device->pdata->vs_polarity << 2;\r\nerror = tvp7002_write(sd, TVP7002_SYNC_CTL_1, polarity_a);\r\nif (error < 0)\r\nreturn error;\r\npolarity_b = 0x01 | device->pdata->fid_polarity << 2\r\n| device->pdata->sog_polarity << 1\r\n| device->pdata->clk_polarity;\r\nerror = tvp7002_write(sd, TVP7002_MISC_CTL_3, polarity_b);\r\nif (error < 0)\r\nreturn error;\r\ntimings = device->current_timings->timings;\r\nerror = tvp7002_s_dv_timings(sd, &timings);\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\ndevice->pad.flags = MEDIA_PAD_FL_SOURCE;\r\ndevice->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\ndevice->sd.entity.flags |= MEDIA_ENT_T_V4L2_SUBDEV_DECODER;\r\nerror = media_entity_init(&device->sd.entity, 1, &device->pad, 0);\r\nif (error < 0)\r\nreturn error;\r\n#endif\r\nv4l2_ctrl_handler_init(&device->hdl, 1);\r\nv4l2_ctrl_new_std(&device->hdl, &tvp7002_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 255, 1, 0);\r\nsd->ctrl_handler = &device->hdl;\r\nif (device->hdl.error) {\r\nerror = device->hdl.error;\r\ngoto error;\r\n}\r\nv4l2_ctrl_handler_setup(&device->hdl);\r\nerror = v4l2_async_register_subdev(&device->sd);\r\nif (error)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nv4l2_ctrl_handler_free(&device->hdl);\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nmedia_entity_cleanup(&device->sd.entity);\r\n#endif\r\nreturn error;\r\n}\r\nstatic int tvp7002_remove(struct i2c_client *c)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(c);\r\nstruct tvp7002 *device = to_tvp7002(sd);\r\nv4l2_dbg(1, debug, sd, "Removing tvp7002 adapter"\r\n"on address 0x%x\n", c->addr);\r\nv4l2_async_unregister_subdev(&device->sd);\r\n#if defined(CONFIG_MEDIA_CONTROLLER)\r\nmedia_entity_cleanup(&device->sd.entity);\r\n#endif\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(&device->hdl);\r\nreturn 0;\r\n}
