void acpi_processor_power_init_bm_check(struct acpi_processor_flags *flags,\r\nunsigned int cpu)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu);\r\nflags->bm_check = 0;\r\nif (num_online_cpus() == 1)\r\nflags->bm_check = 1;\r\nelse if (c->x86_vendor == X86_VENDOR_INTEL) {\r\nflags->bm_check = 1;\r\n}\r\nif (c->x86_vendor == X86_VENDOR_INTEL &&\r\n(c->x86 > 0xf || (c->x86 == 6 && c->x86_model >= 0x0f)))\r\nflags->bm_control = 0;\r\n}\r\nstatic long acpi_processor_ffh_cstate_probe_cpu(void *_cx)\r\n{\r\nstruct acpi_processor_cx *cx = _cx;\r\nlong retval;\r\nunsigned int eax, ebx, ecx, edx;\r\nunsigned int edx_part;\r\nunsigned int cstate_type;\r\nunsigned int num_cstate_subtype;\r\ncpuid(CPUID_MWAIT_LEAF, &eax, &ebx, &ecx, &edx);\r\ncstate_type = ((cx->address >> MWAIT_SUBSTATE_SIZE) &\r\nMWAIT_CSTATE_MASK) + 1;\r\nedx_part = edx >> (cstate_type * MWAIT_SUBSTATE_SIZE);\r\nnum_cstate_subtype = edx_part & MWAIT_SUBSTATE_MASK;\r\nretval = 0;\r\nif (num_cstate_subtype == 0) {\r\npr_warn(FW_BUG "ACPI MWAIT C-state 0x%x not supported by HW (0x%x)\n", cx->address, edx_part);\r\nretval = -1;\r\ngoto out;\r\n}\r\nif (!(ecx & CPUID5_ECX_EXTENSIONS_SUPPORTED) ||\r\n!(ecx & CPUID5_ECX_INTERRUPT_BREAK)) {\r\nretval = -1;\r\ngoto out;\r\n}\r\nif (!mwait_supported[cstate_type]) {\r\nmwait_supported[cstate_type] = 1;\r\nprintk(KERN_DEBUG\r\n"Monitor-Mwait will be used to enter C-%d "\r\n"state\n", cx->type);\r\n}\r\nsnprintf(cx->desc,\r\nACPI_CX_DESC_LEN, "ACPI FFH INTEL MWAIT 0x%x",\r\ncx->address);\r\nout:\r\nreturn retval;\r\n}\r\nint acpi_processor_ffh_cstate_probe(unsigned int cpu,\r\nstruct acpi_processor_cx *cx, struct acpi_power_register *reg)\r\n{\r\nstruct cstate_entry *percpu_entry;\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu);\r\nlong retval;\r\nif (!cpu_cstate_entry || c->cpuid_level < CPUID_MWAIT_LEAF)\r\nreturn -1;\r\nif (reg->bit_offset != NATIVE_CSTATE_BEYOND_HALT)\r\nreturn -1;\r\npercpu_entry = per_cpu_ptr(cpu_cstate_entry, cpu);\r\npercpu_entry->states[cx->index].eax = 0;\r\npercpu_entry->states[cx->index].ecx = 0;\r\nretval = work_on_cpu(cpu, acpi_processor_ffh_cstate_probe_cpu, cx);\r\nif (retval == 0) {\r\npercpu_entry->states[cx->index].eax = cx->address;\r\npercpu_entry->states[cx->index].ecx = MWAIT_ECX_INTERRUPT_BREAK;\r\n}\r\nif ((c->x86_vendor == X86_VENDOR_INTEL) && !(reg->access_size & 0x2))\r\ncx->bm_sts_skip = 1;\r\nreturn retval;\r\n}\r\nvoid acpi_processor_ffh_cstate_enter(struct acpi_processor_cx *cx)\r\n{\r\nunsigned int cpu = smp_processor_id();\r\nstruct cstate_entry *percpu_entry;\r\npercpu_entry = per_cpu_ptr(cpu_cstate_entry, cpu);\r\nmwait_idle_with_hints(percpu_entry->states[cx->index].eax,\r\npercpu_entry->states[cx->index].ecx);\r\n}\r\nstatic int __init ffh_cstate_init(void)\r\n{\r\nstruct cpuinfo_x86 *c = &boot_cpu_data;\r\nif (c->x86_vendor != X86_VENDOR_INTEL)\r\nreturn -1;\r\ncpu_cstate_entry = alloc_percpu(struct cstate_entry);\r\nreturn 0;\r\n}\r\nstatic void __exit ffh_cstate_exit(void)\r\n{\r\nfree_percpu(cpu_cstate_entry);\r\ncpu_cstate_entry = NULL;\r\n}
