static void r600_hdmi_calc_cts(uint32_t clock, int *CTS, int *N, int freq)\r\n{\r\nint n, cts;\r\nunsigned long div, mul;\r\nn = 128 * freq;\r\ncts = clock * 1000;\r\ndiv = gcd(n, cts);\r\nn /= div;\r\ncts /= div;\r\nmul = ((128*freq/1000) + (n-1))/n;\r\nn *= mul;\r\ncts *= mul;\r\nif (n < (128*freq/1500))\r\nprintk(KERN_WARNING "Calculated ACR N value is too small. You may experience audio problems.\n");\r\nif (n > (128*freq/300))\r\nprintk(KERN_WARNING "Calculated ACR N value is too large. You may experience audio problems.\n");\r\n*N = n;\r\n*CTS = cts;\r\nDRM_DEBUG("Calculated ACR timing N=%d CTS=%d for frequency %d\n",\r\n*N, *CTS, freq);\r\n}\r\nstruct radeon_hdmi_acr r600_hdmi_acr(uint32_t clock)\r\n{\r\nstruct radeon_hdmi_acr res;\r\nu8 i;\r\nfor (i = 0; i < ARRAY_SIZE(r600_hdmi_predefined_acr); i++) {\r\nif (r600_hdmi_predefined_acr[i].clock == clock)\r\nreturn r600_hdmi_predefined_acr[i];\r\n}\r\nr600_hdmi_calc_cts(clock, &res.cts_32khz, &res.n_32khz, 32000);\r\nr600_hdmi_calc_cts(clock, &res.cts_44_1khz, &res.n_44_1khz, 44100);\r\nr600_hdmi_calc_cts(clock, &res.cts_48khz, &res.n_48khz, 48000);\r\nreturn res;\r\n}\r\nvoid r600_hdmi_update_ACR(struct drm_encoder *encoder, uint32_t clock)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_hdmi_acr acr = r600_hdmi_acr(clock);\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset = dig->afmt->offset;\r\nWREG32_P(HDMI0_ACR_32_0 + offset,\r\nHDMI0_ACR_CTS_32(acr.cts_32khz),\r\n~HDMI0_ACR_CTS_32_MASK);\r\nWREG32_P(HDMI0_ACR_32_1 + offset,\r\nHDMI0_ACR_N_32(acr.n_32khz),\r\n~HDMI0_ACR_N_32_MASK);\r\nWREG32_P(HDMI0_ACR_44_0 + offset,\r\nHDMI0_ACR_CTS_44(acr.cts_44_1khz),\r\n~HDMI0_ACR_CTS_44_MASK);\r\nWREG32_P(HDMI0_ACR_44_1 + offset,\r\nHDMI0_ACR_N_44(acr.n_44_1khz),\r\n~HDMI0_ACR_N_44_MASK);\r\nWREG32_P(HDMI0_ACR_48_0 + offset,\r\nHDMI0_ACR_CTS_48(acr.cts_48khz),\r\n~HDMI0_ACR_CTS_48_MASK);\r\nWREG32_P(HDMI0_ACR_48_1 + offset,\r\nHDMI0_ACR_N_48(acr.n_48khz),\r\n~HDMI0_ACR_N_48_MASK);\r\n}\r\nvoid r600_hdmi_update_avi_infoframe(struct drm_encoder *encoder, void *buffer,\r\nsize_t size)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset = dig->afmt->offset;\r\nuint8_t *frame = buffer + 3;\r\nuint8_t *header = buffer;\r\nWREG32(HDMI0_AVI_INFO0 + offset,\r\nframe[0x0] | (frame[0x1] << 8) | (frame[0x2] << 16) | (frame[0x3] << 24));\r\nWREG32(HDMI0_AVI_INFO1 + offset,\r\nframe[0x4] | (frame[0x5] << 8) | (frame[0x6] << 16) | (frame[0x7] << 24));\r\nWREG32(HDMI0_AVI_INFO2 + offset,\r\nframe[0x8] | (frame[0x9] << 8) | (frame[0xA] << 16) | (frame[0xB] << 24));\r\nWREG32(HDMI0_AVI_INFO3 + offset,\r\nframe[0xC] | (frame[0xD] << 8) | (header[1] << 24));\r\n}\r\nstatic void r600_hdmi_update_audio_infoframe(struct drm_encoder *encoder,\r\nconst void *buffer, size_t size)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset = dig->afmt->offset;\r\nconst u8 *frame = buffer + 3;\r\nWREG32(HDMI0_AUDIO_INFO0 + offset,\r\nframe[0x0] | (frame[0x1] << 8) | (frame[0x2] << 16) | (frame[0x3] << 24));\r\nWREG32(HDMI0_AUDIO_INFO1 + offset,\r\nframe[0x4] | (frame[0x5] << 8) | (frame[0x6] << 16) | (frame[0x8] << 24));\r\n}\r\nstatic bool r600_hdmi_is_audio_buffer_filled(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset = dig->afmt->offset;\r\nreturn (RREG32(HDMI0_STATUS + offset) & 0x10) != 0;\r\n}\r\nint r600_hdmi_buffer_status_changed(struct drm_encoder *encoder)\r\n{\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nint status, result;\r\nif (!dig->afmt || !dig->afmt->enabled)\r\nreturn 0;\r\nstatus = r600_hdmi_is_audio_buffer_filled(encoder);\r\nresult = dig->afmt->last_buffer_filled_status != status;\r\ndig->afmt->last_buffer_filled_status = status;\r\nreturn result;\r\n}\r\nvoid r600_hdmi_audio_workaround(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nuint32_t offset = dig->afmt->offset;\r\nbool hdmi_audio_workaround = false;\r\nu32 value;\r\nif (!hdmi_audio_workaround ||\r\nr600_hdmi_is_audio_buffer_filled(encoder))\r\nvalue = 0;\r\nelse\r\nvalue = HDMI0_AUDIO_TEST_EN;\r\nWREG32_P(HDMI0_AUDIO_PACKET_CONTROL + offset,\r\nvalue, ~HDMI0_AUDIO_TEST_EN);\r\n}\r\nvoid r600_audio_set_dto(struct drm_encoder *encoder, u32 clock)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nu32 base_rate = 24000;\r\nu32 max_ratio = clock / base_rate;\r\nu32 dto_phase;\r\nu32 dto_modulo = clock;\r\nu32 wallclock_ratio;\r\nu32 dto_cntl;\r\nif (!dig || !dig->afmt)\r\nreturn;\r\nif (max_ratio >= 8) {\r\ndto_phase = 192 * 1000;\r\nwallclock_ratio = 3;\r\n} else if (max_ratio >= 4) {\r\ndto_phase = 96 * 1000;\r\nwallclock_ratio = 2;\r\n} else if (max_ratio >= 2) {\r\ndto_phase = 48 * 1000;\r\nwallclock_ratio = 1;\r\n} else {\r\ndto_phase = 24 * 1000;\r\nwallclock_ratio = 0;\r\n}\r\nif (ASIC_IS_DCE32(rdev)) {\r\nif (dig->dig_encoder == 0) {\r\ndto_cntl = RREG32(DCCG_AUDIO_DTO0_CNTL) & ~DCCG_AUDIO_DTO_WALLCLOCK_RATIO_MASK;\r\ndto_cntl |= DCCG_AUDIO_DTO_WALLCLOCK_RATIO(wallclock_ratio);\r\nWREG32(DCCG_AUDIO_DTO0_CNTL, dto_cntl);\r\nWREG32(DCCG_AUDIO_DTO0_PHASE, dto_phase);\r\nWREG32(DCCG_AUDIO_DTO0_MODULE, dto_modulo);\r\nWREG32(DCCG_AUDIO_DTO_SELECT, 0);\r\n} else {\r\ndto_cntl = RREG32(DCCG_AUDIO_DTO1_CNTL) & ~DCCG_AUDIO_DTO_WALLCLOCK_RATIO_MASK;\r\ndto_cntl |= DCCG_AUDIO_DTO_WALLCLOCK_RATIO(wallclock_ratio);\r\nWREG32(DCCG_AUDIO_DTO1_CNTL, dto_cntl);\r\nWREG32(DCCG_AUDIO_DTO1_PHASE, dto_phase);\r\nWREG32(DCCG_AUDIO_DTO1_MODULE, dto_modulo);\r\nWREG32(DCCG_AUDIO_DTO_SELECT, 1);\r\n}\r\n} else {\r\nif (dig->dig_encoder == 0) {\r\nWREG32(DCCG_AUDIO_DTO0_PHASE, base_rate * 100);\r\nWREG32(DCCG_AUDIO_DTO0_MODULE, clock * 100);\r\nWREG32(DCCG_AUDIO_DTO_SELECT, 0);\r\n} else {\r\nWREG32(DCCG_AUDIO_DTO1_PHASE, base_rate * 100);\r\nWREG32(DCCG_AUDIO_DTO1_MODULE, clock * 100);\r\nWREG32(DCCG_AUDIO_DTO_SELECT, 1);\r\n}\r\n}\r\n}\r\nvoid r600_hdmi_setmode(struct drm_encoder *encoder, struct drm_display_mode *mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nu8 buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AVI_INFOFRAME_SIZE];\r\nstruct hdmi_avi_infoframe frame;\r\nuint32_t offset;\r\nuint32_t acr_ctl;\r\nssize_t err;\r\nif (!dig || !dig->afmt)\r\nreturn;\r\nif (!dig->afmt->enabled)\r\nreturn;\r\noffset = dig->afmt->offset;\r\ndig->afmt->pin = r600_audio_get_pin(rdev);\r\nr600_audio_enable(rdev, dig->afmt->pin, false);\r\nr600_audio_set_dto(encoder, mode->clock);\r\nWREG32_P(HDMI0_AUDIO_PACKET_CONTROL + offset,\r\nHDMI0_AUDIO_SAMPLE_SEND |\r\nHDMI0_AUDIO_DELAY_EN(1) |\r\nHDMI0_AUDIO_PACKETS_PER_LINE(3) |\r\nHDMI0_60958_CS_UPDATE,\r\n~(HDMI0_AUDIO_SAMPLE_SEND |\r\nHDMI0_AUDIO_DELAY_EN_MASK |\r\nHDMI0_AUDIO_PACKETS_PER_LINE_MASK |\r\nHDMI0_60958_CS_UPDATE));\r\nacr_ctl = ASIC_IS_DCE3(rdev) ? DCE3_HDMI0_ACR_PACKET_CONTROL :\r\nHDMI0_ACR_PACKET_CONTROL;\r\nWREG32_P(acr_ctl + offset,\r\nHDMI0_ACR_SOURCE |\r\nHDMI0_ACR_AUTO_SEND,\r\n~(HDMI0_ACR_SOURCE |\r\nHDMI0_ACR_AUTO_SEND));\r\nWREG32_OR(HDMI0_VBI_PACKET_CONTROL + offset,\r\nHDMI0_NULL_SEND |\r\nHDMI0_GC_SEND |\r\nHDMI0_GC_CONT);\r\nWREG32_OR(HDMI0_INFOFRAME_CONTROL0 + offset,\r\nHDMI0_AVI_INFO_SEND |\r\nHDMI0_AVI_INFO_CONT |\r\nHDMI0_AUDIO_INFO_SEND |\r\nHDMI0_AUDIO_INFO_UPDATE);\r\nWREG32_P(HDMI0_INFOFRAME_CONTROL1 + offset,\r\nHDMI0_AVI_INFO_LINE(2) |\r\nHDMI0_AUDIO_INFO_LINE(2),\r\n~(HDMI0_AVI_INFO_LINE_MASK |\r\nHDMI0_AUDIO_INFO_LINE_MASK));\r\nWREG32_AND(HDMI0_GC + offset,\r\n~HDMI0_GC_AVMUTE);\r\nerr = drm_hdmi_avi_infoframe_from_display_mode(&frame, mode);\r\nif (err < 0) {\r\nDRM_ERROR("failed to setup AVI infoframe: %zd\n", err);\r\nreturn;\r\n}\r\nerr = hdmi_avi_infoframe_pack(&frame, buffer, sizeof(buffer));\r\nif (err < 0) {\r\nDRM_ERROR("failed to pack AVI infoframe: %zd\n", err);\r\nreturn;\r\n}\r\nr600_hdmi_update_avi_infoframe(encoder, buffer, sizeof(buffer));\r\nWREG32_AND(HDMI0_GENERIC_PACKET_CONTROL + offset,\r\n~(HDMI0_GENERIC0_SEND |\r\nHDMI0_GENERIC0_CONT |\r\nHDMI0_GENERIC0_UPDATE |\r\nHDMI0_GENERIC1_SEND |\r\nHDMI0_GENERIC1_CONT |\r\nHDMI0_GENERIC0_LINE_MASK |\r\nHDMI0_GENERIC1_LINE_MASK));\r\nr600_hdmi_update_ACR(encoder, mode->clock);\r\nWREG32_P(HDMI0_60958_0 + offset,\r\nHDMI0_60958_CS_CHANNEL_NUMBER_L(1),\r\n~(HDMI0_60958_CS_CHANNEL_NUMBER_L_MASK |\r\nHDMI0_60958_CS_CLOCK_ACCURACY_MASK));\r\nWREG32_P(HDMI0_60958_1 + offset,\r\nHDMI0_60958_CS_CHANNEL_NUMBER_R(2),\r\n~HDMI0_60958_CS_CHANNEL_NUMBER_R_MASK);\r\nWREG32(HDMI0_RAMP_CONTROL0 + offset, 0x00FFFFFF);\r\nWREG32(HDMI0_RAMP_CONTROL1 + offset, 0x007FFFFF);\r\nWREG32(HDMI0_RAMP_CONTROL2 + offset, 0x00000001);\r\nWREG32(HDMI0_RAMP_CONTROL3 + offset, 0x00000001);\r\nr600_audio_enable(rdev, dig->afmt->pin, true);\r\n}\r\nvoid r600_hdmi_update_audio_settings(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nstruct r600_audio_pin audio = r600_audio_status(rdev);\r\nuint8_t buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AUDIO_INFOFRAME_SIZE];\r\nstruct hdmi_audio_infoframe frame;\r\nuint32_t offset;\r\nuint32_t value;\r\nssize_t err;\r\nif (!dig->afmt || !dig->afmt->enabled)\r\nreturn;\r\noffset = dig->afmt->offset;\r\nDRM_DEBUG("%s with %d channels, %d Hz sampling rate, %d bits per sample,\n",\r\nr600_hdmi_is_audio_buffer_filled(encoder) ? "playing" : "stopped",\r\naudio.channels, audio.rate, audio.bits_per_sample);\r\nDRM_DEBUG("0x%02X IEC60958 status bits and 0x%02X category code\n",\r\n(int)audio.status_bits, (int)audio.category_code);\r\nerr = hdmi_audio_infoframe_init(&frame);\r\nif (err < 0) {\r\nDRM_ERROR("failed to setup audio infoframe\n");\r\nreturn;\r\n}\r\nframe.channels = audio.channels;\r\nerr = hdmi_audio_infoframe_pack(&frame, buffer, sizeof(buffer));\r\nif (err < 0) {\r\nDRM_ERROR("failed to pack audio infoframe\n");\r\nreturn;\r\n}\r\nvalue = RREG32(HDMI0_AUDIO_PACKET_CONTROL + offset);\r\nif (value & HDMI0_AUDIO_TEST_EN)\r\nWREG32(HDMI0_AUDIO_PACKET_CONTROL + offset,\r\nvalue & ~HDMI0_AUDIO_TEST_EN);\r\nWREG32_OR(HDMI0_CONTROL + offset,\r\nHDMI0_ERROR_ACK);\r\nWREG32_AND(HDMI0_INFOFRAME_CONTROL0 + offset,\r\n~HDMI0_AUDIO_INFO_SOURCE);\r\nr600_hdmi_update_audio_infoframe(encoder, buffer, sizeof(buffer));\r\nWREG32_OR(HDMI0_INFOFRAME_CONTROL0 + offset,\r\nHDMI0_AUDIO_INFO_CONT |\r\nHDMI0_AUDIO_INFO_UPDATE);\r\n}\r\nvoid r600_hdmi_enable(struct drm_encoder *encoder, bool enable)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nu32 hdmi = HDMI0_ERROR_ACK;\r\nif (!dig || !dig->afmt)\r\nreturn;\r\nif (enable && dig->afmt->enabled)\r\nreturn;\r\nif (!enable && !dig->afmt->enabled)\r\nreturn;\r\nif (!ASIC_IS_DCE3(rdev)) {\r\nif (enable)\r\nhdmi |= HDMI0_ENABLE;\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\r\nif (enable) {\r\nWREG32_OR(AVIVO_TMDSA_CNTL, AVIVO_TMDSA_CNTL_HDMI_EN);\r\nhdmi |= HDMI0_STREAM(HDMI0_STREAM_TMDSA);\r\n} else {\r\nWREG32_AND(AVIVO_TMDSA_CNTL, ~AVIVO_TMDSA_CNTL_HDMI_EN);\r\n}\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\r\nif (enable) {\r\nWREG32_OR(AVIVO_LVTMA_CNTL, AVIVO_LVTMA_CNTL_HDMI_EN);\r\nhdmi |= HDMI0_STREAM(HDMI0_STREAM_LVTMA);\r\n} else {\r\nWREG32_AND(AVIVO_LVTMA_CNTL, ~AVIVO_LVTMA_CNTL_HDMI_EN);\r\n}\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_DDI:\r\nif (enable) {\r\nWREG32_OR(DDIA_CNTL, DDIA_HDMI_EN);\r\nhdmi |= HDMI0_STREAM(HDMI0_STREAM_DDIA);\r\n} else {\r\nWREG32_AND(DDIA_CNTL, ~DDIA_HDMI_EN);\r\n}\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\r\nif (enable)\r\nhdmi |= HDMI0_STREAM(HDMI0_STREAM_DVOA);\r\nbreak;\r\ndefault:\r\ndev_err(rdev->dev, "Invalid encoder for HDMI: 0x%X\n",\r\nradeon_encoder->encoder_id);\r\nbreak;\r\n}\r\nWREG32(HDMI0_CONTROL + dig->afmt->offset, hdmi);\r\n}\r\nif (rdev->irq.installed) {\r\nif (enable)\r\nradeon_irq_kms_enable_afmt(rdev, dig->afmt->id);\r\nelse\r\nradeon_irq_kms_disable_afmt(rdev, dig->afmt->id);\r\n}\r\ndig->afmt->enabled = enable;\r\nDRM_DEBUG("%sabling HDMI interface @ 0x%04X for encoder 0x%x\n",\r\nenable ? "En" : "Dis", dig->afmt->offset, radeon_encoder->encoder_id);\r\n}
