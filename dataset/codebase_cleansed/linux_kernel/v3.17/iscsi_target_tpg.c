struct iscsi_portal_group *iscsit_alloc_portal_group(struct iscsi_tiqn *tiqn, u16 tpgt)\r\n{\r\nstruct iscsi_portal_group *tpg;\r\ntpg = kzalloc(sizeof(struct iscsi_portal_group), GFP_KERNEL);\r\nif (!tpg) {\r\npr_err("Unable to allocate struct iscsi_portal_group\n");\r\nreturn NULL;\r\n}\r\ntpg->tpgt = tpgt;\r\ntpg->tpg_state = TPG_STATE_FREE;\r\ntpg->tpg_tiqn = tiqn;\r\nINIT_LIST_HEAD(&tpg->tpg_gnp_list);\r\nINIT_LIST_HEAD(&tpg->tpg_list);\r\nmutex_init(&tpg->tpg_access_lock);\r\nsema_init(&tpg->np_login_sem, 1);\r\nspin_lock_init(&tpg->tpg_state_lock);\r\nspin_lock_init(&tpg->tpg_np_lock);\r\nreturn tpg;\r\n}\r\nint iscsit_load_discovery_tpg(void)\r\n{\r\nstruct iscsi_param *param;\r\nstruct iscsi_portal_group *tpg;\r\nint ret;\r\ntpg = iscsit_alloc_portal_group(NULL, 1);\r\nif (!tpg) {\r\npr_err("Unable to allocate struct iscsi_portal_group\n");\r\nreturn -1;\r\n}\r\nret = core_tpg_register(\r\n&lio_target_fabric_configfs->tf_ops,\r\nNULL, &tpg->tpg_se_tpg, tpg,\r\nTRANSPORT_TPG_TYPE_DISCOVERY);\r\nif (ret < 0) {\r\nkfree(tpg);\r\nreturn -1;\r\n}\r\ntpg->sid = 1;\r\niscsit_set_default_tpg_attribs(tpg);\r\nif (iscsi_create_default_params(&tpg->param_list) < 0)\r\ngoto out;\r\nparam = iscsi_find_param_from_key(AUTHMETHOD, tpg->param_list);\r\nif (!param)\r\ngoto out;\r\nif (iscsi_update_param_value(param, "CHAP,None") < 0)\r\ngoto out;\r\ntpg->tpg_attrib.authentication = 0;\r\nspin_lock(&tpg->tpg_state_lock);\r\ntpg->tpg_state = TPG_STATE_ACTIVE;\r\nspin_unlock(&tpg->tpg_state_lock);\r\niscsit_global->discovery_tpg = tpg;\r\npr_debug("CORE[0] - Allocated Discovery TPG\n");\r\nreturn 0;\r\nout:\r\nif (tpg->sid == 1)\r\ncore_tpg_deregister(&tpg->tpg_se_tpg);\r\nkfree(tpg);\r\nreturn -1;\r\n}\r\nvoid iscsit_release_discovery_tpg(void)\r\n{\r\nstruct iscsi_portal_group *tpg = iscsit_global->discovery_tpg;\r\nif (!tpg)\r\nreturn;\r\ncore_tpg_deregister(&tpg->tpg_se_tpg);\r\nkfree(tpg);\r\niscsit_global->discovery_tpg = NULL;\r\n}\r\nstruct iscsi_portal_group *iscsit_get_tpg_from_np(\r\nstruct iscsi_tiqn *tiqn,\r\nstruct iscsi_np *np,\r\nstruct iscsi_tpg_np **tpg_np_out)\r\n{\r\nstruct iscsi_portal_group *tpg = NULL;\r\nstruct iscsi_tpg_np *tpg_np;\r\nspin_lock(&tiqn->tiqn_tpg_lock);\r\nlist_for_each_entry(tpg, &tiqn->tiqn_tpg_list, tpg_list) {\r\nspin_lock(&tpg->tpg_state_lock);\r\nif (tpg->tpg_state != TPG_STATE_ACTIVE) {\r\nspin_unlock(&tpg->tpg_state_lock);\r\ncontinue;\r\n}\r\nspin_unlock(&tpg->tpg_state_lock);\r\nspin_lock(&tpg->tpg_np_lock);\r\nlist_for_each_entry(tpg_np, &tpg->tpg_gnp_list, tpg_np_list) {\r\nif (tpg_np->tpg_np == np) {\r\n*tpg_np_out = tpg_np;\r\nkref_get(&tpg_np->tpg_np_kref);\r\nspin_unlock(&tpg->tpg_np_lock);\r\nspin_unlock(&tiqn->tiqn_tpg_lock);\r\nreturn tpg;\r\n}\r\n}\r\nspin_unlock(&tpg->tpg_np_lock);\r\n}\r\nspin_unlock(&tiqn->tiqn_tpg_lock);\r\nreturn NULL;\r\n}\r\nint iscsit_get_tpg(\r\nstruct iscsi_portal_group *tpg)\r\n{\r\nint ret;\r\nret = mutex_lock_interruptible(&tpg->tpg_access_lock);\r\nreturn ((ret != 0) || signal_pending(current)) ? -1 : 0;\r\n}\r\nvoid iscsit_put_tpg(struct iscsi_portal_group *tpg)\r\n{\r\nmutex_unlock(&tpg->tpg_access_lock);\r\n}\r\nstatic void iscsit_clear_tpg_np_login_thread(\r\nstruct iscsi_tpg_np *tpg_np,\r\nstruct iscsi_portal_group *tpg,\r\nbool shutdown)\r\n{\r\nif (!tpg_np->tpg_np) {\r\npr_err("struct iscsi_tpg_np->tpg_np is NULL!\n");\r\nreturn;\r\n}\r\nif (shutdown)\r\ntpg_np->tpg_np->enabled = false;\r\niscsit_reset_np_thread(tpg_np->tpg_np, tpg_np, tpg, shutdown);\r\n}\r\nstatic void iscsit_clear_tpg_np_login_threads(\r\nstruct iscsi_portal_group *tpg,\r\nbool shutdown)\r\n{\r\nstruct iscsi_tpg_np *tpg_np;\r\nspin_lock(&tpg->tpg_np_lock);\r\nlist_for_each_entry(tpg_np, &tpg->tpg_gnp_list, tpg_np_list) {\r\nif (!tpg_np->tpg_np) {\r\npr_err("struct iscsi_tpg_np->tpg_np is NULL!\n");\r\ncontinue;\r\n}\r\nspin_unlock(&tpg->tpg_np_lock);\r\niscsit_clear_tpg_np_login_thread(tpg_np, tpg, shutdown);\r\nspin_lock(&tpg->tpg_np_lock);\r\n}\r\nspin_unlock(&tpg->tpg_np_lock);\r\n}\r\nvoid iscsit_tpg_dump_params(struct iscsi_portal_group *tpg)\r\n{\r\niscsi_print_params(tpg->param_list);\r\n}\r\nstatic void iscsit_set_default_tpg_attribs(struct iscsi_portal_group *tpg)\r\n{\r\nstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\r\na->authentication = TA_AUTHENTICATION;\r\na->login_timeout = TA_LOGIN_TIMEOUT;\r\na->netif_timeout = TA_NETIF_TIMEOUT;\r\na->default_cmdsn_depth = TA_DEFAULT_CMDSN_DEPTH;\r\na->generate_node_acls = TA_GENERATE_NODE_ACLS;\r\na->cache_dynamic_acls = TA_CACHE_DYNAMIC_ACLS;\r\na->demo_mode_write_protect = TA_DEMO_MODE_WRITE_PROTECT;\r\na->prod_mode_write_protect = TA_PROD_MODE_WRITE_PROTECT;\r\na->demo_mode_discovery = TA_DEMO_MODE_DISCOVERY;\r\na->default_erl = TA_DEFAULT_ERL;\r\na->t10_pi = TA_DEFAULT_T10_PI;\r\n}\r\nint iscsit_tpg_add_portal_group(struct iscsi_tiqn *tiqn, struct iscsi_portal_group *tpg)\r\n{\r\nif (tpg->tpg_state != TPG_STATE_FREE) {\r\npr_err("Unable to add iSCSI Target Portal Group: %d"\r\n" while not in TPG_STATE_FREE state.\n", tpg->tpgt);\r\nreturn -EEXIST;\r\n}\r\niscsit_set_default_tpg_attribs(tpg);\r\nif (iscsi_create_default_params(&tpg->param_list) < 0)\r\ngoto err_out;\r\ntpg->tpg_attrib.tpg = tpg;\r\nspin_lock(&tpg->tpg_state_lock);\r\ntpg->tpg_state = TPG_STATE_INACTIVE;\r\nspin_unlock(&tpg->tpg_state_lock);\r\nspin_lock(&tiqn->tiqn_tpg_lock);\r\nlist_add_tail(&tpg->tpg_list, &tiqn->tiqn_tpg_list);\r\ntiqn->tiqn_ntpgs++;\r\npr_debug("CORE[%s]_TPG[%hu] - Added iSCSI Target Portal Group\n",\r\ntiqn->tiqn, tpg->tpgt);\r\nspin_unlock(&tiqn->tiqn_tpg_lock);\r\nreturn 0;\r\nerr_out:\r\nif (tpg->param_list) {\r\niscsi_release_param_list(tpg->param_list);\r\ntpg->param_list = NULL;\r\n}\r\nkfree(tpg);\r\nreturn -ENOMEM;\r\n}\r\nint iscsit_tpg_del_portal_group(\r\nstruct iscsi_tiqn *tiqn,\r\nstruct iscsi_portal_group *tpg,\r\nint force)\r\n{\r\nu8 old_state = tpg->tpg_state;\r\nspin_lock(&tpg->tpg_state_lock);\r\ntpg->tpg_state = TPG_STATE_INACTIVE;\r\nspin_unlock(&tpg->tpg_state_lock);\r\nif (iscsit_release_sessions_for_tpg(tpg, force) < 0) {\r\npr_err("Unable to delete iSCSI Target Portal Group:"\r\n" %hu while active sessions exist, and force=0\n",\r\ntpg->tpgt);\r\ntpg->tpg_state = old_state;\r\nreturn -EPERM;\r\n}\r\ncore_tpg_clear_object_luns(&tpg->tpg_se_tpg);\r\nif (tpg->param_list) {\r\niscsi_release_param_list(tpg->param_list);\r\ntpg->param_list = NULL;\r\n}\r\ncore_tpg_deregister(&tpg->tpg_se_tpg);\r\nspin_lock(&tpg->tpg_state_lock);\r\ntpg->tpg_state = TPG_STATE_FREE;\r\nspin_unlock(&tpg->tpg_state_lock);\r\nspin_lock(&tiqn->tiqn_tpg_lock);\r\ntiqn->tiqn_ntpgs--;\r\nlist_del(&tpg->tpg_list);\r\nspin_unlock(&tiqn->tiqn_tpg_lock);\r\npr_debug("CORE[%s]_TPG[%hu] - Deleted iSCSI Target Portal Group\n",\r\ntiqn->tiqn, tpg->tpgt);\r\nkfree(tpg);\r\nreturn 0;\r\n}\r\nint iscsit_tpg_enable_portal_group(struct iscsi_portal_group *tpg)\r\n{\r\nstruct iscsi_param *param;\r\nstruct iscsi_tiqn *tiqn = tpg->tpg_tiqn;\r\nint ret;\r\nspin_lock(&tpg->tpg_state_lock);\r\nif (tpg->tpg_state == TPG_STATE_ACTIVE) {\r\npr_err("iSCSI target portal group: %hu is already"\r\n" active, ignoring request.\n", tpg->tpgt);\r\nspin_unlock(&tpg->tpg_state_lock);\r\nreturn -EINVAL;\r\n}\r\nparam = iscsi_find_param_from_key(AUTHMETHOD, tpg->param_list);\r\nif (!param) {\r\nspin_unlock(&tpg->tpg_state_lock);\r\nreturn -EINVAL;\r\n}\r\nif (tpg->tpg_attrib.authentication) {\r\nif (!strcmp(param->value, NONE)) {\r\nret = iscsi_update_param_value(param, CHAP);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = iscsit_ta_authentication(tpg, 1);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\ntpg->tpg_state = TPG_STATE_ACTIVE;\r\nspin_unlock(&tpg->tpg_state_lock);\r\nspin_lock(&tiqn->tiqn_tpg_lock);\r\ntiqn->tiqn_active_tpgs++;\r\npr_debug("iSCSI_TPG[%hu] - Enabled iSCSI Target Portal Group\n",\r\ntpg->tpgt);\r\nspin_unlock(&tiqn->tiqn_tpg_lock);\r\nreturn 0;\r\nerr:\r\nspin_unlock(&tpg->tpg_state_lock);\r\nreturn ret;\r\n}\r\nint iscsit_tpg_disable_portal_group(struct iscsi_portal_group *tpg, int force)\r\n{\r\nstruct iscsi_tiqn *tiqn;\r\nu8 old_state = tpg->tpg_state;\r\nspin_lock(&tpg->tpg_state_lock);\r\nif (tpg->tpg_state == TPG_STATE_INACTIVE) {\r\npr_err("iSCSI Target Portal Group: %hu is already"\r\n" inactive, ignoring request.\n", tpg->tpgt);\r\nspin_unlock(&tpg->tpg_state_lock);\r\nreturn -EINVAL;\r\n}\r\ntpg->tpg_state = TPG_STATE_INACTIVE;\r\nspin_unlock(&tpg->tpg_state_lock);\r\niscsit_clear_tpg_np_login_threads(tpg, false);\r\nif (iscsit_release_sessions_for_tpg(tpg, force) < 0) {\r\nspin_lock(&tpg->tpg_state_lock);\r\ntpg->tpg_state = old_state;\r\nspin_unlock(&tpg->tpg_state_lock);\r\npr_err("Unable to disable iSCSI Target Portal Group:"\r\n" %hu while active sessions exist, and force=0\n",\r\ntpg->tpgt);\r\nreturn -EPERM;\r\n}\r\ntiqn = tpg->tpg_tiqn;\r\nif (!tiqn || (tpg == iscsit_global->discovery_tpg))\r\nreturn 0;\r\nspin_lock(&tiqn->tiqn_tpg_lock);\r\ntiqn->tiqn_active_tpgs--;\r\npr_debug("iSCSI_TPG[%hu] - Disabled iSCSI Target Portal Group\n",\r\ntpg->tpgt);\r\nspin_unlock(&tiqn->tiqn_tpg_lock);\r\nreturn 0;\r\n}\r\nstruct iscsi_node_attrib *iscsit_tpg_get_node_attrib(\r\nstruct iscsi_session *sess)\r\n{\r\nstruct se_session *se_sess = sess->se_sess;\r\nstruct se_node_acl *se_nacl = se_sess->se_node_acl;\r\nstruct iscsi_node_acl *acl = container_of(se_nacl, struct iscsi_node_acl,\r\nse_node_acl);\r\nreturn &acl->node_attrib;\r\n}\r\nstruct iscsi_tpg_np *iscsit_tpg_locate_child_np(\r\nstruct iscsi_tpg_np *tpg_np,\r\nint network_transport)\r\n{\r\nstruct iscsi_tpg_np *tpg_np_child, *tpg_np_child_tmp;\r\nspin_lock(&tpg_np->tpg_np_parent_lock);\r\nlist_for_each_entry_safe(tpg_np_child, tpg_np_child_tmp,\r\n&tpg_np->tpg_np_parent_list, tpg_np_child_list) {\r\nif (tpg_np_child->tpg_np->np_network_transport ==\r\nnetwork_transport) {\r\nspin_unlock(&tpg_np->tpg_np_parent_lock);\r\nreturn tpg_np_child;\r\n}\r\n}\r\nspin_unlock(&tpg_np->tpg_np_parent_lock);\r\nreturn NULL;\r\n}\r\nstatic bool iscsit_tpg_check_network_portal(\r\nstruct iscsi_tiqn *tiqn,\r\nstruct __kernel_sockaddr_storage *sockaddr,\r\nint network_transport)\r\n{\r\nstruct iscsi_portal_group *tpg;\r\nstruct iscsi_tpg_np *tpg_np;\r\nstruct iscsi_np *np;\r\nbool match = false;\r\nspin_lock(&tiqn->tiqn_tpg_lock);\r\nlist_for_each_entry(tpg, &tiqn->tiqn_tpg_list, tpg_list) {\r\nspin_lock(&tpg->tpg_np_lock);\r\nlist_for_each_entry(tpg_np, &tpg->tpg_gnp_list, tpg_np_list) {\r\nnp = tpg_np->tpg_np;\r\nmatch = iscsit_check_np_match(sockaddr, np,\r\nnetwork_transport);\r\nif (match)\r\nbreak;\r\n}\r\nspin_unlock(&tpg->tpg_np_lock);\r\n}\r\nspin_unlock(&tiqn->tiqn_tpg_lock);\r\nreturn match;\r\n}\r\nstruct iscsi_tpg_np *iscsit_tpg_add_network_portal(\r\nstruct iscsi_portal_group *tpg,\r\nstruct __kernel_sockaddr_storage *sockaddr,\r\nchar *ip_str,\r\nstruct iscsi_tpg_np *tpg_np_parent,\r\nint network_transport)\r\n{\r\nstruct iscsi_np *np;\r\nstruct iscsi_tpg_np *tpg_np;\r\nif (!tpg_np_parent) {\r\nif (iscsit_tpg_check_network_portal(tpg->tpg_tiqn, sockaddr,\r\nnetwork_transport)) {\r\npr_err("Network Portal: %s already exists on a"\r\n" different TPG on %s\n", ip_str,\r\ntpg->tpg_tiqn->tiqn);\r\nreturn ERR_PTR(-EEXIST);\r\n}\r\n}\r\ntpg_np = kzalloc(sizeof(struct iscsi_tpg_np), GFP_KERNEL);\r\nif (!tpg_np) {\r\npr_err("Unable to allocate memory for"\r\n" struct iscsi_tpg_np.\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nnp = iscsit_add_np(sockaddr, ip_str, network_transport);\r\nif (IS_ERR(np)) {\r\nkfree(tpg_np);\r\nreturn ERR_CAST(np);\r\n}\r\nINIT_LIST_HEAD(&tpg_np->tpg_np_list);\r\nINIT_LIST_HEAD(&tpg_np->tpg_np_child_list);\r\nINIT_LIST_HEAD(&tpg_np->tpg_np_parent_list);\r\nspin_lock_init(&tpg_np->tpg_np_parent_lock);\r\ninit_completion(&tpg_np->tpg_np_comp);\r\nkref_init(&tpg_np->tpg_np_kref);\r\ntpg_np->tpg_np = np;\r\nnp->tpg_np = tpg_np;\r\ntpg_np->tpg = tpg;\r\nspin_lock(&tpg->tpg_np_lock);\r\nlist_add_tail(&tpg_np->tpg_np_list, &tpg->tpg_gnp_list);\r\ntpg->num_tpg_nps++;\r\nif (tpg->tpg_tiqn)\r\ntpg->tpg_tiqn->tiqn_num_tpg_nps++;\r\nspin_unlock(&tpg->tpg_np_lock);\r\nif (tpg_np_parent) {\r\ntpg_np->tpg_np_parent = tpg_np_parent;\r\nspin_lock(&tpg_np_parent->tpg_np_parent_lock);\r\nlist_add_tail(&tpg_np->tpg_np_child_list,\r\n&tpg_np_parent->tpg_np_parent_list);\r\nspin_unlock(&tpg_np_parent->tpg_np_parent_lock);\r\n}\r\npr_debug("CORE[%s] - Added Network Portal: %s:%hu,%hu on %s\n",\r\ntpg->tpg_tiqn->tiqn, np->np_ip, np->np_port, tpg->tpgt,\r\nnp->np_transport->name);\r\nreturn tpg_np;\r\n}\r\nstatic int iscsit_tpg_release_np(\r\nstruct iscsi_tpg_np *tpg_np,\r\nstruct iscsi_portal_group *tpg,\r\nstruct iscsi_np *np)\r\n{\r\niscsit_clear_tpg_np_login_thread(tpg_np, tpg, true);\r\npr_debug("CORE[%s] - Removed Network Portal: %s:%hu,%hu on %s\n",\r\ntpg->tpg_tiqn->tiqn, np->np_ip, np->np_port, tpg->tpgt,\r\nnp->np_transport->name);\r\ntpg_np->tpg_np = NULL;\r\ntpg_np->tpg = NULL;\r\nkfree(tpg_np);\r\nreturn iscsit_del_np(np);\r\n}\r\nint iscsit_tpg_del_network_portal(\r\nstruct iscsi_portal_group *tpg,\r\nstruct iscsi_tpg_np *tpg_np)\r\n{\r\nstruct iscsi_np *np;\r\nstruct iscsi_tpg_np *tpg_np_child, *tpg_np_child_tmp;\r\nint ret = 0;\r\nnp = tpg_np->tpg_np;\r\nif (!np) {\r\npr_err("Unable to locate struct iscsi_np from"\r\n" struct iscsi_tpg_np\n");\r\nreturn -EINVAL;\r\n}\r\nif (!tpg_np->tpg_np_parent) {\r\nlist_for_each_entry_safe(tpg_np_child, tpg_np_child_tmp,\r\n&tpg_np->tpg_np_parent_list,\r\ntpg_np_child_list) {\r\nret = iscsit_tpg_del_network_portal(tpg, tpg_np_child);\r\nif (ret < 0)\r\npr_err("iscsit_tpg_del_network_portal()"\r\n" failed: %d\n", ret);\r\n}\r\n} else {\r\nspin_lock(&tpg_np->tpg_np_parent->tpg_np_parent_lock);\r\nlist_del(&tpg_np->tpg_np_child_list);\r\nspin_unlock(&tpg_np->tpg_np_parent->tpg_np_parent_lock);\r\n}\r\nspin_lock(&tpg->tpg_np_lock);\r\nlist_del(&tpg_np->tpg_np_list);\r\ntpg->num_tpg_nps--;\r\nif (tpg->tpg_tiqn)\r\ntpg->tpg_tiqn->tiqn_num_tpg_nps--;\r\nspin_unlock(&tpg->tpg_np_lock);\r\nreturn iscsit_tpg_release_np(tpg_np, tpg, np);\r\n}\r\nint iscsit_tpg_set_initiator_node_queue_depth(\r\nstruct iscsi_portal_group *tpg,\r\nunsigned char *initiatorname,\r\nu32 queue_depth,\r\nint force)\r\n{\r\nreturn core_tpg_set_initiator_node_queue_depth(&tpg->tpg_se_tpg,\r\ninitiatorname, queue_depth, force);\r\n}\r\nint iscsit_ta_authentication(struct iscsi_portal_group *tpg, u32 authentication)\r\n{\r\nunsigned char buf1[256], buf2[256], *none = NULL;\r\nint len;\r\nstruct iscsi_param *param;\r\nstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\r\nif ((authentication != 1) && (authentication != 0)) {\r\npr_err("Illegal value for authentication parameter:"\r\n" %u, ignoring request.\n", authentication);\r\nreturn -EINVAL;\r\n}\r\nmemset(buf1, 0, sizeof(buf1));\r\nmemset(buf2, 0, sizeof(buf2));\r\nparam = iscsi_find_param_from_key(AUTHMETHOD, tpg->param_list);\r\nif (!param)\r\nreturn -EINVAL;\r\nif (authentication) {\r\nsnprintf(buf1, sizeof(buf1), "%s", param->value);\r\nnone = strstr(buf1, NONE);\r\nif (!none)\r\ngoto out;\r\nif (!strncmp(none + 4, ",", 1)) {\r\nif (!strcmp(buf1, none))\r\nsprintf(buf2, "%s", none+5);\r\nelse {\r\nnone--;\r\n*none = '\0';\r\nlen = sprintf(buf2, "%s", buf1);\r\nnone += 5;\r\nsprintf(buf2 + len, "%s", none);\r\n}\r\n} else {\r\nnone--;\r\n*none = '\0';\r\nsprintf(buf2, "%s", buf1);\r\n}\r\nif (iscsi_update_param_value(param, buf2) < 0)\r\nreturn -EINVAL;\r\n} else {\r\nsnprintf(buf1, sizeof(buf1), "%s", param->value);\r\nnone = strstr(buf1, NONE);\r\nif (none)\r\ngoto out;\r\nstrncat(buf1, ",", strlen(","));\r\nstrncat(buf1, NONE, strlen(NONE));\r\nif (iscsi_update_param_value(param, buf1) < 0)\r\nreturn -EINVAL;\r\n}\r\nout:\r\na->authentication = authentication;\r\npr_debug("%s iSCSI Authentication Methods for TPG: %hu.\n",\r\na->authentication ? "Enforcing" : "Disabling", tpg->tpgt);\r\nreturn 0;\r\n}\r\nint iscsit_ta_login_timeout(\r\nstruct iscsi_portal_group *tpg,\r\nu32 login_timeout)\r\n{\r\nstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\r\nif (login_timeout > TA_LOGIN_TIMEOUT_MAX) {\r\npr_err("Requested Login Timeout %u larger than maximum"\r\n" %u\n", login_timeout, TA_LOGIN_TIMEOUT_MAX);\r\nreturn -EINVAL;\r\n} else if (login_timeout < TA_LOGIN_TIMEOUT_MIN) {\r\npr_err("Requested Logout Timeout %u smaller than"\r\n" minimum %u\n", login_timeout, TA_LOGIN_TIMEOUT_MIN);\r\nreturn -EINVAL;\r\n}\r\na->login_timeout = login_timeout;\r\npr_debug("Set Logout Timeout to %u for Target Portal Group"\r\n" %hu\n", a->login_timeout, tpg->tpgt);\r\nreturn 0;\r\n}\r\nint iscsit_ta_netif_timeout(\r\nstruct iscsi_portal_group *tpg,\r\nu32 netif_timeout)\r\n{\r\nstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\r\nif (netif_timeout > TA_NETIF_TIMEOUT_MAX) {\r\npr_err("Requested Network Interface Timeout %u larger"\r\n" than maximum %u\n", netif_timeout,\r\nTA_NETIF_TIMEOUT_MAX);\r\nreturn -EINVAL;\r\n} else if (netif_timeout < TA_NETIF_TIMEOUT_MIN) {\r\npr_err("Requested Network Interface Timeout %u smaller"\r\n" than minimum %u\n", netif_timeout,\r\nTA_NETIF_TIMEOUT_MIN);\r\nreturn -EINVAL;\r\n}\r\na->netif_timeout = netif_timeout;\r\npr_debug("Set Network Interface Timeout to %u for"\r\n" Target Portal Group %hu\n", a->netif_timeout, tpg->tpgt);\r\nreturn 0;\r\n}\r\nint iscsit_ta_generate_node_acls(\r\nstruct iscsi_portal_group *tpg,\r\nu32 flag)\r\n{\r\nstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\r\nif ((flag != 0) && (flag != 1)) {\r\npr_err("Illegal value %d\n", flag);\r\nreturn -EINVAL;\r\n}\r\na->generate_node_acls = flag;\r\npr_debug("iSCSI_TPG[%hu] - Generate Initiator Portal Group ACLs: %s\n",\r\ntpg->tpgt, (a->generate_node_acls) ? "Enabled" : "Disabled");\r\nif (flag == 1 && a->cache_dynamic_acls == 0) {\r\npr_debug("Explicitly setting cache_dynamic_acls=1 when "\r\n"generate_node_acls=1\n");\r\na->cache_dynamic_acls = 1;\r\n}\r\nreturn 0;\r\n}\r\nint iscsit_ta_default_cmdsn_depth(\r\nstruct iscsi_portal_group *tpg,\r\nu32 tcq_depth)\r\n{\r\nstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\r\nif (tcq_depth > TA_DEFAULT_CMDSN_DEPTH_MAX) {\r\npr_err("Requested Default Queue Depth: %u larger"\r\n" than maximum %u\n", tcq_depth,\r\nTA_DEFAULT_CMDSN_DEPTH_MAX);\r\nreturn -EINVAL;\r\n} else if (tcq_depth < TA_DEFAULT_CMDSN_DEPTH_MIN) {\r\npr_err("Requested Default Queue Depth: %u smaller"\r\n" than minimum %u\n", tcq_depth,\r\nTA_DEFAULT_CMDSN_DEPTH_MIN);\r\nreturn -EINVAL;\r\n}\r\na->default_cmdsn_depth = tcq_depth;\r\npr_debug("iSCSI_TPG[%hu] - Set Default CmdSN TCQ Depth to %u\n",\r\ntpg->tpgt, a->default_cmdsn_depth);\r\nreturn 0;\r\n}\r\nint iscsit_ta_cache_dynamic_acls(\r\nstruct iscsi_portal_group *tpg,\r\nu32 flag)\r\n{\r\nstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\r\nif ((flag != 0) && (flag != 1)) {\r\npr_err("Illegal value %d\n", flag);\r\nreturn -EINVAL;\r\n}\r\nif (a->generate_node_acls == 1 && flag == 0) {\r\npr_debug("Skipping cache_dynamic_acls=0 when"\r\n" generate_node_acls=1\n");\r\nreturn 0;\r\n}\r\na->cache_dynamic_acls = flag;\r\npr_debug("iSCSI_TPG[%hu] - Cache Dynamic Initiator Portal Group"\r\n" ACLs %s\n", tpg->tpgt, (a->cache_dynamic_acls) ?\r\n"Enabled" : "Disabled");\r\nreturn 0;\r\n}\r\nint iscsit_ta_demo_mode_write_protect(\r\nstruct iscsi_portal_group *tpg,\r\nu32 flag)\r\n{\r\nstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\r\nif ((flag != 0) && (flag != 1)) {\r\npr_err("Illegal value %d\n", flag);\r\nreturn -EINVAL;\r\n}\r\na->demo_mode_write_protect = flag;\r\npr_debug("iSCSI_TPG[%hu] - Demo Mode Write Protect bit: %s\n",\r\ntpg->tpgt, (a->demo_mode_write_protect) ? "ON" : "OFF");\r\nreturn 0;\r\n}\r\nint iscsit_ta_prod_mode_write_protect(\r\nstruct iscsi_portal_group *tpg,\r\nu32 flag)\r\n{\r\nstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\r\nif ((flag != 0) && (flag != 1)) {\r\npr_err("Illegal value %d\n", flag);\r\nreturn -EINVAL;\r\n}\r\na->prod_mode_write_protect = flag;\r\npr_debug("iSCSI_TPG[%hu] - Production Mode Write Protect bit:"\r\n" %s\n", tpg->tpgt, (a->prod_mode_write_protect) ?\r\n"ON" : "OFF");\r\nreturn 0;\r\n}\r\nint iscsit_ta_demo_mode_discovery(\r\nstruct iscsi_portal_group *tpg,\r\nu32 flag)\r\n{\r\nstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\r\nif ((flag != 0) && (flag != 1)) {\r\npr_err("Illegal value %d\n", flag);\r\nreturn -EINVAL;\r\n}\r\na->demo_mode_discovery = flag;\r\npr_debug("iSCSI_TPG[%hu] - Demo Mode Discovery bit:"\r\n" %s\n", tpg->tpgt, (a->demo_mode_discovery) ?\r\n"ON" : "OFF");\r\nreturn 0;\r\n}\r\nint iscsit_ta_default_erl(\r\nstruct iscsi_portal_group *tpg,\r\nu32 default_erl)\r\n{\r\nstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\r\nif ((default_erl != 0) && (default_erl != 1) && (default_erl != 2)) {\r\npr_err("Illegal value for default_erl: %u\n", default_erl);\r\nreturn -EINVAL;\r\n}\r\na->default_erl = default_erl;\r\npr_debug("iSCSI_TPG[%hu] - DefaultERL: %u\n", tpg->tpgt, a->default_erl);\r\nreturn 0;\r\n}\r\nint iscsit_ta_t10_pi(\r\nstruct iscsi_portal_group *tpg,\r\nu32 flag)\r\n{\r\nstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;\r\nif ((flag != 0) && (flag != 1)) {\r\npr_err("Illegal value %d\n", flag);\r\nreturn -EINVAL;\r\n}\r\na->t10_pi = flag;\r\npr_debug("iSCSI_TPG[%hu] - T10 Protection information bit:"\r\n" %s\n", tpg->tpgt, (a->t10_pi) ?\r\n"ON" : "OFF");\r\nreturn 0;\r\n}
