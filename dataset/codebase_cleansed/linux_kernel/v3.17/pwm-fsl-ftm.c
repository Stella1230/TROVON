static inline struct fsl_pwm_chip *to_fsl_chip(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct fsl_pwm_chip, chip);\r\n}\r\nstatic int fsl_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct fsl_pwm_chip *fpc = to_fsl_chip(chip);\r\nreturn clk_prepare_enable(fpc->clk[FSL_PWM_CLK_SYS]);\r\n}\r\nstatic void fsl_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct fsl_pwm_chip *fpc = to_fsl_chip(chip);\r\nclk_disable_unprepare(fpc->clk[FSL_PWM_CLK_SYS]);\r\n}\r\nstatic int fsl_pwm_calculate_default_ps(struct fsl_pwm_chip *fpc,\r\nenum fsl_pwm_clk index)\r\n{\r\nunsigned long sys_rate, cnt_rate;\r\nunsigned long long ratio;\r\nsys_rate = clk_get_rate(fpc->clk[FSL_PWM_CLK_SYS]);\r\nif (!sys_rate)\r\nreturn -EINVAL;\r\ncnt_rate = clk_get_rate(fpc->clk[fpc->cnt_select]);\r\nif (!cnt_rate)\r\nreturn -EINVAL;\r\nswitch (index) {\r\ncase FSL_PWM_CLK_SYS:\r\nfpc->clk_ps = 1;\r\nbreak;\r\ncase FSL_PWM_CLK_FIX:\r\nratio = 2 * cnt_rate - 1;\r\ndo_div(ratio, sys_rate);\r\nfpc->clk_ps = ratio;\r\nbreak;\r\ncase FSL_PWM_CLK_EXT:\r\nratio = 4 * cnt_rate - 1;\r\ndo_div(ratio, sys_rate);\r\nfpc->clk_ps = ratio;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned long fsl_pwm_calculate_cycles(struct fsl_pwm_chip *fpc,\r\nunsigned long period_ns)\r\n{\r\nunsigned long long c, c0;\r\nc = clk_get_rate(fpc->clk[fpc->cnt_select]);\r\nc = c * period_ns;\r\ndo_div(c, 1000000000UL);\r\ndo {\r\nc0 = c;\r\ndo_div(c0, (1 << fpc->clk_ps));\r\nif (c0 <= 0xFFFF)\r\nreturn (unsigned long)c0;\r\n} while (++fpc->clk_ps < 8);\r\nreturn 0;\r\n}\r\nstatic unsigned long fsl_pwm_calculate_period_cycles(struct fsl_pwm_chip *fpc,\r\nunsigned long period_ns,\r\nenum fsl_pwm_clk index)\r\n{\r\nint ret;\r\nret = fsl_pwm_calculate_default_ps(fpc, index);\r\nif (ret) {\r\ndev_err(fpc->chip.dev,\r\n"failed to calculate default prescaler: %d\n",\r\nret);\r\nreturn 0;\r\n}\r\nreturn fsl_pwm_calculate_cycles(fpc, period_ns);\r\n}\r\nstatic unsigned long fsl_pwm_calculate_period(struct fsl_pwm_chip *fpc,\r\nunsigned long period_ns)\r\n{\r\nenum fsl_pwm_clk m0, m1;\r\nunsigned long fix_rate, ext_rate, cycles;\r\ncycles = fsl_pwm_calculate_period_cycles(fpc, period_ns,\r\nFSL_PWM_CLK_SYS);\r\nif (cycles) {\r\nfpc->cnt_select = FSL_PWM_CLK_SYS;\r\nreturn cycles;\r\n}\r\nfix_rate = clk_get_rate(fpc->clk[FSL_PWM_CLK_FIX]);\r\next_rate = clk_get_rate(fpc->clk[FSL_PWM_CLK_EXT]);\r\nif (fix_rate > ext_rate) {\r\nm0 = FSL_PWM_CLK_FIX;\r\nm1 = FSL_PWM_CLK_EXT;\r\n} else {\r\nm0 = FSL_PWM_CLK_EXT;\r\nm1 = FSL_PWM_CLK_FIX;\r\n}\r\ncycles = fsl_pwm_calculate_period_cycles(fpc, period_ns, m0);\r\nif (cycles) {\r\nfpc->cnt_select = m0;\r\nreturn cycles;\r\n}\r\nfpc->cnt_select = m1;\r\nreturn fsl_pwm_calculate_period_cycles(fpc, period_ns, m1);\r\n}\r\nstatic unsigned long fsl_pwm_calculate_duty(struct fsl_pwm_chip *fpc,\r\nunsigned long period_ns,\r\nunsigned long duty_ns)\r\n{\r\nunsigned long long val, duty;\r\nval = readl(fpc->base + FTM_MOD);\r\nduty = duty_ns * (val + 1);\r\ndo_div(duty, period_ns);\r\nreturn (unsigned long)duty;\r\n}\r\nstatic int fsl_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct fsl_pwm_chip *fpc = to_fsl_chip(chip);\r\nu32 val, period, duty;\r\nmutex_lock(&fpc->lock);\r\nif (fpc->period_ns && fpc->period_ns != period_ns) {\r\ndev_err(fpc->chip.dev,\r\n"conflicting period requested for PWM %u\n",\r\npwm->hwpwm);\r\nmutex_unlock(&fpc->lock);\r\nreturn -EBUSY;\r\n}\r\nif (!fpc->period_ns && duty_ns) {\r\nperiod = fsl_pwm_calculate_period(fpc, period_ns);\r\nif (!period) {\r\ndev_err(fpc->chip.dev, "failed to calculate period\n");\r\nmutex_unlock(&fpc->lock);\r\nreturn -EINVAL;\r\n}\r\nval = readl(fpc->base + FTM_SC);\r\nval &= ~(FTM_SC_PS_MASK << FTM_SC_PS_SHIFT);\r\nval |= fpc->clk_ps;\r\nwritel(val, fpc->base + FTM_SC);\r\nwritel(period - 1, fpc->base + FTM_MOD);\r\nfpc->period_ns = period_ns;\r\n}\r\nmutex_unlock(&fpc->lock);\r\nduty = fsl_pwm_calculate_duty(fpc, period_ns, duty_ns);\r\nwritel(FTM_CSC_MSB | FTM_CSC_ELSB, fpc->base + FTM_CSC(pwm->hwpwm));\r\nwritel(duty, fpc->base + FTM_CV(pwm->hwpwm));\r\nreturn 0;\r\n}\r\nstatic int fsl_pwm_set_polarity(struct pwm_chip *chip,\r\nstruct pwm_device *pwm,\r\nenum pwm_polarity polarity)\r\n{\r\nstruct fsl_pwm_chip *fpc = to_fsl_chip(chip);\r\nu32 val;\r\nval = readl(fpc->base + FTM_POL);\r\nif (polarity == PWM_POLARITY_INVERSED)\r\nval |= BIT(pwm->hwpwm);\r\nelse\r\nval &= ~BIT(pwm->hwpwm);\r\nwritel(val, fpc->base + FTM_POL);\r\nreturn 0;\r\n}\r\nstatic int fsl_counter_clock_enable(struct fsl_pwm_chip *fpc)\r\n{\r\nu32 val;\r\nint ret;\r\nif (fpc->use_count != 0)\r\nreturn 0;\r\nval = readl(fpc->base + FTM_SC);\r\nval &= ~(FTM_SC_CLK_MASK << FTM_SC_CLK_SHIFT);\r\nval |= FTM_SC_CLK(fpc->cnt_select);\r\nwritel(val, fpc->base + FTM_SC);\r\nret = clk_prepare_enable(fpc->clk[fpc->cnt_select]);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(fpc->clk[FSL_PWM_CLK_CNTEN]);\r\nif (ret) {\r\nclk_disable_unprepare(fpc->clk[fpc->cnt_select]);\r\nreturn ret;\r\n}\r\nfpc->use_count++;\r\nreturn 0;\r\n}\r\nstatic int fsl_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct fsl_pwm_chip *fpc = to_fsl_chip(chip);\r\nu32 val;\r\nint ret;\r\nmutex_lock(&fpc->lock);\r\nval = readl(fpc->base + FTM_OUTMASK);\r\nval &= ~BIT(pwm->hwpwm);\r\nwritel(val, fpc->base + FTM_OUTMASK);\r\nret = fsl_counter_clock_enable(fpc);\r\nmutex_unlock(&fpc->lock);\r\nreturn ret;\r\n}\r\nstatic void fsl_counter_clock_disable(struct fsl_pwm_chip *fpc)\r\n{\r\nu32 val;\r\nif (fpc->use_count == 0)\r\nreturn;\r\nif (--fpc->use_count > 0)\r\nreturn;\r\nval = readl(fpc->base + FTM_SC);\r\nval &= ~(FTM_SC_CLK_MASK << FTM_SC_CLK_SHIFT);\r\nwritel(val, fpc->base + FTM_SC);\r\nclk_disable_unprepare(fpc->clk[FSL_PWM_CLK_CNTEN]);\r\nclk_disable_unprepare(fpc->clk[fpc->cnt_select]);\r\n}\r\nstatic void fsl_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct fsl_pwm_chip *fpc = to_fsl_chip(chip);\r\nu32 val;\r\nmutex_lock(&fpc->lock);\r\nval = readl(fpc->base + FTM_OUTMASK);\r\nval |= BIT(pwm->hwpwm);\r\nwritel(val, fpc->base + FTM_OUTMASK);\r\nfsl_counter_clock_disable(fpc);\r\nval = readl(fpc->base + FTM_OUTMASK);\r\nif ((val & 0xFF) == 0xFF)\r\nfpc->period_ns = 0;\r\nmutex_unlock(&fpc->lock);\r\n}\r\nstatic int fsl_pwm_init(struct fsl_pwm_chip *fpc)\r\n{\r\nint ret;\r\nret = clk_prepare_enable(fpc->clk[FSL_PWM_CLK_SYS]);\r\nif (ret)\r\nreturn ret;\r\nwritel(0x00, fpc->base + FTM_CNTIN);\r\nwritel(0x00, fpc->base + FTM_OUTINIT);\r\nwritel(0xFF, fpc->base + FTM_OUTMASK);\r\nclk_disable_unprepare(fpc->clk[FSL_PWM_CLK_SYS]);\r\nreturn 0;\r\n}\r\nstatic int fsl_pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct fsl_pwm_chip *fpc;\r\nstruct resource *res;\r\nint ret;\r\nfpc = devm_kzalloc(&pdev->dev, sizeof(*fpc), GFP_KERNEL);\r\nif (!fpc)\r\nreturn -ENOMEM;\r\nmutex_init(&fpc->lock);\r\nfpc->chip.dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nfpc->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(fpc->base))\r\nreturn PTR_ERR(fpc->base);\r\nfpc->clk[FSL_PWM_CLK_SYS] = devm_clk_get(&pdev->dev, "ftm_sys");\r\nif (IS_ERR(fpc->clk[FSL_PWM_CLK_SYS])) {\r\ndev_err(&pdev->dev, "failed to get \"ftm_sys\" clock\n");\r\nreturn PTR_ERR(fpc->clk[FSL_PWM_CLK_SYS]);\r\n}\r\nfpc->clk[FSL_PWM_CLK_FIX] = devm_clk_get(fpc->chip.dev, "ftm_fix");\r\nif (IS_ERR(fpc->clk[FSL_PWM_CLK_FIX]))\r\nreturn PTR_ERR(fpc->clk[FSL_PWM_CLK_FIX]);\r\nfpc->clk[FSL_PWM_CLK_EXT] = devm_clk_get(fpc->chip.dev, "ftm_ext");\r\nif (IS_ERR(fpc->clk[FSL_PWM_CLK_EXT]))\r\nreturn PTR_ERR(fpc->clk[FSL_PWM_CLK_EXT]);\r\nfpc->clk[FSL_PWM_CLK_CNTEN] =\r\ndevm_clk_get(fpc->chip.dev, "ftm_cnt_clk_en");\r\nif (IS_ERR(fpc->clk[FSL_PWM_CLK_CNTEN]))\r\nreturn PTR_ERR(fpc->clk[FSL_PWM_CLK_CNTEN]);\r\nfpc->chip.ops = &fsl_pwm_ops;\r\nfpc->chip.of_xlate = of_pwm_xlate_with_flags;\r\nfpc->chip.of_pwm_n_cells = 3;\r\nfpc->chip.base = -1;\r\nfpc->chip.npwm = 8;\r\nfpc->chip.can_sleep = true;\r\nret = pwmchip_add(&fpc->chip);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to add PWM chip: %d\n", ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, fpc);\r\nreturn fsl_pwm_init(fpc);\r\n}\r\nstatic int fsl_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct fsl_pwm_chip *fpc = platform_get_drvdata(pdev);\r\nreturn pwmchip_remove(&fpc->chip);\r\n}
